\section{[[cc/]]}

\subsection*{[[cc/cc.h]]}

<<constant NHUNK>>=
#define	NHUNK		50000L
@

<<constant BUFSIZ>>=
#define	BUFSIZ		8192
@

<<constant NSYMB>>=
#define	NSYMB		1500
@

<<constant NHASH>>=
#define	NHASH		1024
@

<<constant STRINGSZ>>=
#define	STRINGSZ	200
@

<<constant HISTSZ>>=
#define	HISTSZ		20
@

<<constant YYMAXDEPTH>>=
#define YYMAXDEPTH	1500
@

<<constant NTERM>>=
#define	NTERM		10
@

<<constant MAXALIGN>>=
#define	MAXALIGN	7
@

<<function SIGN>>=
#define	SIGN(n)		(1ULL<<(n-1))
@

<<function MASK>>=
#define	MASK(n)		(SIGN(n)|(SIGN(n)-1))
@

<<constant BITS>>=
#define	BITS	5
@

<<constant NVAR>>=
#define	NVAR	(BITS*sizeof(ulong)*8)
@

<<struct Bits>>=
struct	Bits
{
    ulong	b[BITS];
};
@

<<struct Node>>=
struct	Node
{
    Node*	left;
    Node*	right;
    void*	label;
    long	pc;
    int	reg;
    long	xoffset;
    double	fconst;		/* fp constant */
    vlong	vconst;		/* non fp const */
    char*	cstring;	/* character string */
    TRune*	rstring;	/* rune string */

    Sym*	sym;
    Type*	type;
    long	lineno;
    char	op;
    char	oldop;
    char xcast;
    char	class;
    char	etype;
    char	complex;
    char	addable;
    char	scale;
    char	garb;
};
@

<<constant Z>>=
#define	Z	((Node*)0)
@

<<struct SymCc>>=
struct	SymCc
{
    Sym*	link;
    Type*	type;
    Type*	suetag;
    Type*	tenum;
    char*	macro;
    long	varlineno;
    long	offset;
    vlong	vconst;
    double	fconst;
    Node*	label;
    ushort	lexical;
    char	*name;
    ushort	block;
    ushort	sueblock;
    char	class;
    char	sym;
    char	aused;
    char	sig;
};
@

<<constant S>>=
#define	S	((Sym*)0)
@

<<enum _anon_>>=
enum{
    SIGNONE = 0,
    SIGDONE = 1,
    SIGINTERN = 2,

    SIGNINTERN = 1729*325*1729,
};
@

<<struct Decl>>=
struct	Decl
{
    Decl*	link;
    Sym*	sym;
    Type*	type;
    long	varlineno;
    long	offset;
    short	val;
    ushort	block;
    char	class;
    char	aused;
};
@

<<constant D>>=
#define	D	((Decl*)0)
@

<<struct Type>>=
struct	Type
{
    Sym*	sym;
    Sym*	tag;
    Funct*	funct;
    Type*	link;
    Type*	down;
    long	width;
    long	offset;
    long	lineno;
    schar	shift;
    char	nbits;
    char	etype;
    char	garb;
};
@

<<constant T>>=
#define	T	((Type*)0)
@

<<constant NODECL>>=
#define	NODECL	((void(*)(int, Type*, Sym*))0)
@

<<struct Init>>=
struct	Init			/* general purpose initialization */
{
    int	code;
    ulong	value;
    char*	s;
};
@

<<struct Fi>>=
struct Fi
{
    char*	p;
    int	c;
};
@

<<struct Io>>=
struct	Io
{
    Io*	link;
    char*	p;
    char	b[BUFSIZ];
    short	c;
    short	f;
};
@

<<constant I>>=
#define	I	((Io*)0)
@

<<struct Hist>>=
struct	Hist
{
    Hist*	link;
    char*	name;
    long	line;
    long	offset;
};
@

<<constant H>>=
#define	H	((Hist*)0)
@

<<struct Term>>=
struct	Term
{
    vlong	mult;
    Node	*node;
};
@

<<enum _anon_ (cc/cc.h)>>=
enum
{
    Axxx,
    Ael1,
    Ael2,
    Asu2,
    Aarg0,
    Aarg1,
    Aarg2,
    Aaut3,
    NALIGN,
};
@

<<enum _anon_ (cc/cc.h)2>>=
enum				/* also in ../{8a,0a}.h */
{
    Plan9	= 1<<0,
    Unix	= 1<<1,
    Windows	= 1<<2,
};
@

<<enum _anon_ (cc/cc.h)3>>=
enum
{
    DMARK,
    DAUTO,
    DSUE,
    DLABEL,
};
@

<<enum _anon_ (cc/cc.h)4>>=
enum
{
    OXXX,
    OADD,
    OADDR,
    OAND,
    OANDAND,
    OARRAY,
    OAS,
    OASI,
    OASADD,
    OASAND,
    OASASHL,
    OASASHR,
    OASDIV,
    OASHL,
    OASHR,
    OASLDIV,
    OASLMOD,
    OASLMUL,
    OASLSHR,
    OASMOD,
    OASMUL,
    OASOR,
    OASSUB,
    OASXOR,
    OBIT,
    OBREAK,
    OCASE,
    OCAST,
    OCOMMA,
    OCOND,
    OCONST,
    OCONTINUE,
    ODIV,
    ODOT,
    ODOTDOT,
    ODWHILE,
    OENUM,
    OEQ,
    OFOR,
    OFUNC,
    OGE,
    OGOTO,
    OGT,
    OHI,
    OHS,
    OIF,
    OIND,
    OINDREG,
    OINIT,
    OLABEL,
    OLDIV,
    OLE,
    OLIST,
    OLMOD,
    OLMUL,
    OLO,
    OLS,
    OLSHR,
    OLT,
    OMOD,
    OMUL,
    ONAME,
    ONE,
    ONOT,
    OOR,
    OOROR,
    OPOSTDEC,
    OPOSTINC,
    OPREDEC,
    OPREINC,
    OPROTO,
    OREGISTER,
    ORETURN,
    OSET,
    OSIGN,
    OSIZE,
    OSTRING,
    OLSTRING,
    OSTRUCT,
    OSUB,
    OSWITCH,
    OUNION,
    OUSED,
    OWHILE,
    OXOR,
    ONEG,
    OCOM,
    OPOS,
    OELEM,

    OTST,		/* used in some compilers */
    OINDEX,
    OFAS,
    OREGPAIR,
    OEXREG,

    OEND
};
@

<<enum _anon_ (cc/cc.h)5>>=
enum
{
    TXXX,
    TCHAR,
    TUCHAR,
    TSHORT,
    TUSHORT,
    TINT,
    TUINT,
    TLONG,
    TULONG,
    TVLONG,
    TUVLONG,
    TFLOAT,
    TDOUBLE,
    TIND,
    TFUNC,
    TARRAY,
    TVOID,
    TSTRUCT,
    TUNION,
    TENUM,
    TDOT,
    NTYPE,

    TAUTO	= NTYPE,
    TEXTERN,
    TSTATIC,
    TTYPEDEF,
    TTYPESTR,
    TREGISTER,
    TCONSTNT,
    TVOLATILE,
    TUNSIGNED,
    TSIGNED,
    TFILE,
    TOLD,
    NALLTYPES,

    /* adapt size of Rune to target system's size */
    TRUNE = sizeof(TRune)==4? TUINT: TUSHORT,
};
@

<<enum _anon_ (cc/cc.h)6>>=
enum
{
    CXXX,
    CAUTO,
    CEXTERN,
    CGLOBL,
    CSTATIC,
    CLOCAL,
    CTYPEDEF,
    CTYPESTR,
    CPARAM,
    CSELEM,
    CLABEL,
    CEXREG,
    NCTYPES,
};
@

<<enum _anon_ (cc/cc.h)7>>=
enum
{
    GXXX		= 0,
    GCONSTNT	= 1<<0,
    GVOLATILE	= 1<<1,
    NGTYPES		= 1<<2,

    GINCOMPLETE	= 1<<2,
};
@

<<enum _anon_ (cc/cc.h)8>>=
enum
{
    BCHAR		= 1L<<TCHAR,
    BUCHAR		= 1L<<TUCHAR,
    BSHORT		= 1L<<TSHORT,
    BUSHORT		= 1L<<TUSHORT,
    BINT		= 1L<<TINT,
    BUINT		= 1L<<TUINT,
    BLONG		= 1L<<TLONG,
    BULONG		= 1L<<TULONG,
    BVLONG		= 1L<<TVLONG,
    BUVLONG		= 1L<<TUVLONG,
    BFLOAT		= 1L<<TFLOAT,
    BDOUBLE		= 1L<<TDOUBLE,
    BIND		= 1L<<TIND,
    BFUNC		= 1L<<TFUNC,
    BARRAY		= 1L<<TARRAY,
    BVOID		= 1L<<TVOID,
    BSTRUCT		= 1L<<TSTRUCT,
    BUNION		= 1L<<TUNION,
    BENUM		= 1L<<TENUM,
    BFILE		= 1L<<TFILE,
    BDOT		= 1L<<TDOT,
    BCONSTNT	= 1L<<TCONSTNT,
    BVOLATILE	= 1L<<TVOLATILE,
    BUNSIGNED	= 1L<<TUNSIGNED,
    BSIGNED		= 1L<<TSIGNED,
    BAUTO		= 1L<<TAUTO,
    BEXTERN		= 1L<<TEXTERN,
    BSTATIC		= 1L<<TSTATIC,
    BTYPEDEF	= 1L<<TTYPEDEF,
    BTYPESTR	= 1L<<TTYPESTR,
    BREGISTER	= 1L<<TREGISTER,

    BINTEGER	= BCHAR|BUCHAR|BSHORT|BUSHORT|BINT|BUINT|
                BLONG|BULONG|BVLONG|BUVLONG,
    BNUMBER		= BINTEGER|BFLOAT|BDOUBLE,

/* these can be overloaded with complex types */

    BCLASS		= BAUTO|BEXTERN|BSTATIC|BTYPEDEF|BTYPESTR|BREGISTER,
    BGARB		= BCONSTNT|BVOLATILE,
};
@

<<struct Funct>>=
struct	Funct
{
    Sym*	sym[OEND];
    Sym*	castto[NTYPE];
    Sym*	castfr[NTYPE];
};
@

<<struct En>>=
struct En
{
    Type*	tenum;		/* type of entire enum */
    Type*	cenum;		/* type of current enum run */
    vlong	lastenum;	/* value of current enum */
    double	floatenum;	/* value of current enum */
};
@


%-------------------------------------------------------------

<<cc/cc.h>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <ctype.h>

#pragma	lib	"../cc/cc.a$O"

typedef	struct	Node	Node;
typedef	struct	SymCc	Sym;
typedef	struct	Type	Type;
typedef	struct	Funct	Funct;
typedef	struct	Decl	Decl;
typedef	struct	Io	Io;
typedef	struct	Hist	Hist;
typedef	struct	Term	Term;
typedef	struct	Init	Init;
typedef	struct	Bits	Bits;

typedef	Rune	TRune;	/* target system type */

<<constant NHUNK>>
<<constant BUFSIZ>>
<<constant NSYMB>>
<<constant NHASH>>
<<constant STRINGSZ>>
<<constant HISTSZ>>
<<constant YYMAXDEPTH>>
<<constant NTERM>>
<<constant MAXALIGN>>

<<function SIGN>>
<<function MASK>>

<<constant BITS>>
<<constant NVAR>>
<<struct Bits>>

<<struct Node>>
<<constant Z>>

<<struct SymCc>>
<<constant S>>

<<enum _anon_>>

<<struct Decl>>
<<constant D>>

<<struct Type>>

<<constant T>>
<<constant NODECL>>

<<struct Init>>

<<struct Fi>>
extern struct Fi fi;

<<struct Io>>
<<constant I>>

<<struct Hist>>
<<constant H>>
extern Hist*	hist;

<<struct Term>>

<<enum _anon_ (cc/cc.h)>>

<<enum _anon_ (cc/cc.h)2>>

<<enum _anon_ (cc/cc.h)3>>
<<enum _anon_ (cc/cc.h)4>>
<<enum _anon_ (cc/cc.h)5>>
<<enum _anon_ (cc/cc.h)6>>
<<enum _anon_ (cc/cc.h)7>>
<<enum _anon_ (cc/cc.h)8>>

<<struct Funct>>

<<struct En>>
extern struct En en;

extern	int	autobn;
extern	long	autoffset;
extern	int	blockno;
extern	Decl*	dclstack;
extern	char	debug[256];
extern	Hist*	ehist;
extern	long	firstbit;
extern	Sym*	firstarg;
extern	Type*	firstargtype;
extern	Decl*	firstdcl;
extern	int	fperror;
extern	Sym*	hash[NHASH];
extern	int	hasdoubled;
extern	char*	hunk;
extern	char**	include;
extern	Io*	iofree;
extern	Io*	ionext;
extern	Io*	iostack;
extern	long	lastbit;
extern	char	lastclass;
extern	Type*	lastdcl;
extern	long	lastfield;
extern	Type*	lasttype;
extern	long	lineno;
extern	long	nearln;
extern	int	maxinclude;
extern	int	nerrors;
extern	int	newflag;
extern	long	nhunk;
extern	int	ninclude;
extern	Node*	nodproto;
extern	Node*	nodcast;
extern	Biobuf	outbuf;
extern	Biobuf	diagbuf;
extern	char*	outfile;
extern	char*	pathname;
extern	int	peekc;
extern	long	stkoff;
extern	Type*	strf;
extern	Type*	strl;
extern	char	symb[NSYMB];
extern	Sym*	symstring;
extern	int	taggen;
extern	Type*	tfield;
extern	Type*	tufield;
extern	int	thechar;
extern	char*	thestring;
extern	Type*	thisfn;
extern	long	thunk;
extern	Type*	types[NTYPE];
extern	Type*	fntypes[NTYPE];
extern	Node*	initlist;
extern	Term	term[NTERM];
extern	int	nterm;
extern	int	packflg;
extern	int	fproundflg;
extern	int	profileflg;
extern	int	ncontin;
extern	int	newvlongcode;
extern	int	canreach;
extern	int	warnreach;
extern	Bits	zbits;

extern	char	*onames[], *tnames[], *gnames[];
extern	char	*cnames[], *qnames[], *bnames[];
extern	char	tab[NTYPE][NTYPE];
extern	char	comrel[], invrel[], logrel[];
extern	long	ncast[], tadd[], tand[];
extern	long	targ[], tasadd[], tasign[], tcast[];
extern	long	tdot[], tfunct[], tindir[], tmul[];
extern	long	tnot[], trel[], tsub[];

extern	char	typeaf[];
extern	char	typefd[];
extern	char	typei[];
extern	char	typesu[];
extern	char	typesuv[];
extern	char	typeu[];
extern	char	typev[];
extern	char	typec[];
extern	char	typeh[];
extern	char	typeil[];
extern	char	typeilp[];
extern	char	typechl[];
extern	char	typechlv[];
extern	char	typechlvp[];
extern	char	typechlp[];
extern	char	typechlpfd[];

extern	char*	typeswitch;
extern	char*	typeword;
extern	char*	typecmplx;

extern	ulong	thash1;
extern	ulong	thash2;
extern	ulong	thash3;
extern	ulong	thash[];

/*
 *	compat.c/unix.c/windows.c
 */
int	mywait(int*);
int	mycreat(char*, int);
int	systemtype(int);
int	pathchar(void);
int	myaccess(char*);
char*	mygetwd(char*, int);
int	myexec(char*, char*[]);
int	mydup(int, int);
int	myfork(void);
int	mypipe(int*);
void*	mysbrk(ulong);

/*
 *	parser
 */
int	yyparse(void);
int	mpatov(char*, vlong*);

/*
 *	lex.c
 */
void*	allocn(void*, long, long);
void*	alloc(long);
void	cinit(void);
int	compile(char*, char**, int);
void	errorexit(void);
int	filbuf(void);
int	getc(void);
long	getr(void);
int	getnsc(void);
Sym*	lookup(void);
void	main(int, char*[]);
void	newfile(char*, int);
void	newio(void);
void	pushio(void);
long	escchar(long, int, int);
Sym*	slookup(char*);
void	syminit(Sym*);
void	unget(int);
long	yylex(void);
int	Lconv(Fmt*);
int	Tconv(Fmt*);
int	FNconv(Fmt*);
int	Oconv(Fmt*);
int	Qconv(Fmt*);
int	VBconv(Fmt*);
void	setinclude(char*);

/*
 * mac.c
 */
void	dodefine(char*);
void	domacro(void);
Sym*	getsym(void);
long	getnsn(void);
void	linehist(char*, int);
void	macdef(void);
void	macprag(void);
void	macend(void);
void	macexpand(Sym*, char*);
void	macif(int);
void	macinc(void);
void	maclin(void);
void	macund(void);

/*
 * dcl.c
 */
Node*	doinit(Sym*, Type*, long, Node*);
Type*	tcopy(Type*);
Node*	init1(Sym*, Type*, long, int);
Node*	newlist(Node*, Node*);
void	adecl(int, Type*, Sym*);
int	anyproto(Node*);
void	argmark(Node*, int);
void	dbgdecl(Sym*);
Node*	dcllabel(Sym*, int);
Node*	dodecl(void(*)(int, Type*, Sym*), int, Type*, Node*);
Sym*	mkstatic(Sym*);
void	doenum(Sym*, Node*);
void	snap(Type*);
Type*	dotag(Sym*, int, int);
void	edecl(int, Type*, Sym*);
Type*	fnproto(Node*);
Type*	fnproto1(Node*);
void	markdcl(void);
Type*	paramconv(Type*, int);
void	pdecl(int, Type*, Sym*);
Decl*	push(void);
Decl*	push1(Sym*);
Node*	revertdcl(void);
long	round(long, int);
int	rsametype(Type*, Type*, int, int);
int	sametype(Type*, Type*);
ulong	sign(Sym*);
ulong	signature(Type*);
void	sualign(Type*);
void	tmerge(Type*, Sym*);
void	walkparam(Node*, int);
void	xdecl(int, Type*, Sym*);
Node*	contig(Sym*, Node*, long);

/*
 * com.c
 */
void	ccom(Node*);
void	complex(Node*);
int	tcom(Node*);
int	tcoma(Node*, Node*, Type*, int);
int	tcomd(Node*);
int	tcomo(Node*, int);
int	tcomx(Node*);
int	tlvalue(Node*);
void	constas(Node*, Type*, Type*);
Node*	uncomma(Node*);
Node*	uncomargs(Node*);

/*
 * con.c
 */
void	acom(Node*);
void	acom1(vlong, Node*);
void	acom2(Node*, Type*);
int	acomcmp1(const void*, const void*);
int	acomcmp2(const void*, const void*);
int	addo(Node*);
void	evconst(Node*);

/*
 * funct.c
 */
int	isfunct(Node*);
void	dclfunct(Type*, Sym*);

/*
 * sub.c
 */
void	arith(Node*, int);
int	deadheads(Node*);
Type*	dotsearch(Sym*, Type*, Node*, long*);
long	dotoffset(Type*, Type*, Node*);
void	gethunk(void);
Node*	invert(Node*);
int	bitno(long);
void	makedot(Node*, Type*, long);
int	mixedasop(Type*, Type*);
Node*	new(int, Node*, Node*);
Node*	new1(int, Node*, Node*);
int	nilcast(Type*, Type*);
int	nocast(Type*, Type*);
void	prtree(Node*, char*);
void	prtree1(Node*, int, int);
void	relcon(Node*, Node*);
int	relindex(int);
int	simpleg(long);
Type*	garbt(Type*, long);
int	simplec(long);
Type*	simplet(long);
int	stcompat(Node*, Type*, Type*, long[]);
int	tcompat(Node*, Type*, Type*, long[]);
void	tinit(void);
Type*	typ(int, Type*);
Type*	copytyp(Type*);
void	typeext(Type*, Node*);
void	typeext1(Type*, Node*);
int	side(Node*);
int	vconst(Node*);
int	log2(uvlong);
int	vlog(Node*);
int	topbit(ulong);
void	simplifyshift(Node*);
long	typebitor(long, long);
void	diag(Node*, char*, ...);
void	warn(Node*, char*, ...);
void	yyerror(char*, ...);
void	fatal(Node*, char*, ...);

/*
 * acid.c
 */
void	acidtype(Type*);
void	acidvar(Sym*);

/*
 * pickle.c
 */
void	pickletype(Type*);

/*
 * bits.c
 */
Bits	bor(Bits, Bits);
Bits	band(Bits, Bits);
Bits	bnot(Bits);
int	bany(Bits*);
int	bnum(Bits);
Bits	blsh(uint);
int	beq(Bits, Bits);
int	bset(Bits, uint);

/*
 * dpchk.c
 */
void	dpcheck(Node*);
void	arginit(void);
void	pragvararg(void);
void	pragpack(void);
void	pragfpround(void);
void pragprofile(void);
void	pragincomplete(void);

/*
 * calls to machine depend part
 */
void	codgen(Node*, Node*);
void	gclean(void);
void	gextern(Sym*, Node*, long, long);
void	ginit(void);
long	outstring(char*, long);
long	outlstring(TRune*, long);
void	xcom(Node*);
long	exreg(Type*);
long	align(long, Type*, int);
long	maxround(long, long);

extern	schar	ewidth[];

/*
 * com64
 */
int	com64(Node*);
void	com64init(void);
void	bool64(Node*);
double	convvtof(vlong);
vlong	convftov(double);
double	convftox(double, int);
vlong	convvtox(vlong, int);

/*
 * machcap
 */
int	machcap(Node*);

#pragma	varargck	argpos	warn	2
#pragma	varargck	argpos	diag	2
#pragma	varargck	argpos	yyerror	1

#pragma	varargck	type	"F"	Node*
#pragma	varargck	type	"L"	long
#pragma	varargck	type	"Q"	long
#pragma	varargck	type	"O"	int
#pragma	varargck	type	"T"	Type*
#pragma	varargck	type	"|"	int
@
%$


\subsection*{[[cc/mac.c]]}

%-------------------------------------------------------------

<<cc/mac.c>>=
#include	"cc.h"

//#include	"macbody"
//TODO copy paste with aa/, maybe could factorize with another lib?
//

void	macund(void);
void	macdef(void);
void	macinc(void);
void	macprag(void);
void	maclin(void);
void	macif(int);
void	macend(void);

<<constant VARMAC>>

<<function getnsn>>

<<function getsym>>

<<function getsymdots>>

<<function getcom>>

<<function dodefine>>

<<global mactab>>

<<function domacro>>

<<function macund>>

<<constant NARG>>
<<function macdef>>

<<function macexpand>>

<<function macinc>>

<<function maclin>>

<<function macif>>

<<function macprag>>

<<function macend>>

<<function linehist>>

@


\subsection*{[[cc/omachcap.c]]}


%-------------------------------------------------------------

<<cc/omachcap.c>>=
#include	"cc.h"

/* default, like old cc */
//int
//machcap(Node*)
//{
//	return 0;
//}
@



\subsection*{[[cc/utils.c]]}

<<cc/utils.c>>=
#include "cc.h"

<<function errorexit>>

<<function gethunk>>

<<function alloc>>

<<function allocn>>

<<function yyerror>>

@

\subsection*{[[cc/globals.c]]}

<<global fi>>=
struct Fi fi;
@

<<global hist>>=
Hist*	hist;
@

<<global en>>=
struct En en;
@

<<global autobn>>=
int	autobn;
@

<<global autoffset>>=
long	autoffset;
@

<<global blockno>>=
int	blockno;
@

<<global dclstack>>=
Decl*	dclstack;
@

<<global debug>>=
char	debug[256];
@

<<global ehist>>=
Hist*	ehist;
@

<<global firstbit>>=
long	firstbit;
@

<<global firstarg>>=
Sym*	firstarg;
@

<<global firstargtype>>=
Type*	firstargtype;
@

<<global firstdcl>>=
Decl*	firstdcl;
@

<<global fperror>>=
int	fperror;
@

<<global hash>>=
Sym*	hash[NHASH];
@

<<global hasdoubled>>=
int	hasdoubled;
@

<<global hunk>>=
char*	hunk;
@

<<global include>>=
char**	include;
@

<<global iofree>>=
Io*	iofree;
@

<<global ionext>>=
Io*	ionext;
@

<<global iostack>>=
Io*	iostack;
@

<<global lastbit>>=
long	lastbit;
@

<<global lastclass>>=
char	lastclass;
@

<<global lastdcl>>=
Type*	lastdcl;
@

<<global lastfield>>=
long	lastfield;
@

<<global lasttype>>=
Type*	lasttype;
@

<<global lineno>>=
long	lineno;
@

<<global nearln>>=
long	nearln;
@

<<global maxinclude>>=
int	maxinclude;
@

<<global nerrors>>=
int	nerrors;
@

<<global newflag>>=
int	newflag;
@

<<global nhunk>>=
long	nhunk;
@

<<global ninclude>>=
int	ninclude;
@

<<global nodproto>>=
Node*	nodproto;
@

<<global nodcast>>=
Node*	nodcast;
@

<<global outbuf>>=
Biobuf	outbuf;
@

<<global diagbuf>>=
Biobuf	diagbuf;
@

<<global outfile>>=
char*	outfile;
@

<<global pathname>>=
char*	pathname;
@

<<global peekc>>=
int	peekc;
@

<<global stkoff>>=
long	stkoff;
@

<<global strf>>=
Type*	strf;
@

<<global strl>>=
Type*	strl;
@

<<global symb>>=
char	symb[NSYMB];
@

<<global symstring>>=
Sym*	symstring;
@

<<global taggen>>=
int	taggen;
@

<<global tfield>>=
Type*	tfield;
@

<<global tufield>>=
Type*	tufield;
@

<<global thechar>>=
int	thechar;
@

<<global thestring>>=
char*	thestring;
@

<<global thisfn>>=
Type*	thisfn;
@

<<global thunk>>=
long	thunk;
@

<<global types>>=
Type*	types[NTYPE];
@

<<global fntypes>>=
Type*	fntypes[NTYPE];
@

<<global initlist>>=
Node*	initlist;
@

<<global term>>=
Term	term[NTERM];
@

<<global nterm>>=
int	nterm;
@

<<global packflg>>=
int	packflg;
@

<<global fproundflg>>=
int	fproundflg;
@

<<global profileflg>>=
int	profileflg;
@

<<global ncontin>>=
int	ncontin;
@

<<global newvlongcode>>=
int	newvlongcode;
@

<<global canreach>>=
int	canreach;
@

<<global warnreach>>=
int	warnreach;
@

<<global zbits>>=
Bits	zbits;
@

<<global typeswitch>>=
char*	typeswitch;
@

<<global typeword>>=
char*	typeword;
@

<<global typecmplx>>=
char*	typecmplx;
@


%-------------------------------------------------------------

<<cc/globals.c>>=
#include "cc.h"

<<global fi>>
<<global hist>>
<<global en>>

<<global autobn>>
<<global autoffset>>
<<global blockno>>
<<global dclstack>>
<<global debug>>
<<global ehist>>
<<global firstbit>>
<<global firstarg>>
<<global firstargtype>>
<<global firstdcl>>
<<global fperror>>
<<global hash>>
<<global hasdoubled>>
<<global hunk>>
<<global include>>
<<global iofree>>
<<global ionext>>
<<global iostack>>
<<global lastbit>>
<<global lastclass>>
<<global lastdcl>>
<<global lastfield>>
<<global lasttype>>
<<global lineno>>
<<global nearln>>
<<global maxinclude>>
<<global nerrors>>
<<global newflag>>
<<global nhunk>>
<<global ninclude>>
<<global nodproto>>
<<global nodcast>>
<<global outbuf>>
<<global diagbuf>>
<<global outfile>>
<<global pathname>>
<<global peekc>>
<<global stkoff>>
<<global strf>>
<<global strl>>
<<global symb>>
<<global symstring>>
<<global taggen>>
<<global tfield>>
<<global tufield>>
<<global thechar>>
<<global thestring>>
<<global thisfn>>
<<global thunk>>
<<global types>>
<<global fntypes>>
<<global initlist>>
<<global term>>
<<global nterm>>
<<global packflg>>
<<global fproundflg>>
<<global profileflg>>
<<global ncontin>>
<<global newvlongcode>>
<<global canreach>>
<<global warnreach>>
<<global zbits>>

<<global typeswitch>>
<<global typeword>>
<<global typecmplx>>
@


\subsection*{[[cc/sub.c]]}

<<function new>>=
Node*
new(int t, Node *l, Node *r)
{
    Node *n;

    n = alloc(sizeof(*n));
    n->op = t;
    n->left = l;
    n->right = r;
    if(l && t != OGOTO)
        n->lineno = l->lineno;
    else if(r)
        n->lineno = r->lineno;
    else
        n->lineno = lineno;
    newflag = 1;
    return n;
}
@

<<function new1>>=
Node*
new1(int o, Node *l, Node *r)
{
    Node *n;

    n = new(o, l, r);
    n->lineno = nearln;
    return n;
}
@

<<function prtree>>=
void
prtree(Node *n, char *s)
{

    print(" == %s ==\n", s);
    prtree1(n, 0, 0);
    print("\n");
}
@

<<function prtree1>>=
void
prtree1(Node *n, int d, int f)
{
    int i;

    if(f)
    for(i=0; i<d; i++)
        print("   ");
    if(n == Z) {
        print("Z\n");
        return;
    }
    if(n->op == OLIST) {
        prtree1(n->left, d, 0);
        prtree1(n->right, d, 1);
        return;
    }
    d++;
    print("%O", n->op);
    i = 3;
    switch(n->op)
    {
    case ONAME:
        print(" \"%F\"", n);
        print(" %ld", n->xoffset);
        i = 0;
        break;

    case OINDREG:
        print(" %ld(R%d)", n->xoffset, n->reg);
        i = 0;
        break;

    case OREGISTER:
        if(n->xoffset)
            print(" %ld+R%d", n->xoffset, n->reg);
        else
            print(" R%d", n->reg);
        i = 0;
        break;

    case OSTRING:
        print(" \"%s\"", n->cstring);
        i = 0;
        break;

    case OLSTRING:
        if(sizeof(TRune) == sizeof(Rune))
            print(" \"%S\"", (Rune*)n->rstring);
        else
            print(" \"...\"");
        i = 0;
        break;

    case ODOT:
    case OELEM:
        print(" \"%F\"", n);
        break;

    case OCONST:
        if(typefd[n->type->etype])
            print(" \"%.8e\"", n->fconst);
        else
            print(" \"%lld\"", n->vconst);
        i = 0;
        break;
    }
    if(n->addable != 0)
        print(" <%d>", n->addable);
    if(n->type != T)
        print(" %T", n->type);
    if(n->complex != 0)
        print(" (%d)", n->complex);
    print(" %L\n", n->lineno);
    if(i & 2)
        prtree1(n->left, d, 1);
    if(i & 1)
        prtree1(n->right, d, 1);
}
@

<<function typ>>=
Type*
typ(int et, Type *d)
{
    Type *t;

    t = alloc(sizeof(*t));
    t->etype = et;
    t->link = d;
    t->down = T;
    t->sym = S;
    t->width = ewidth[et];
    t->offset = 0;
    t->shift = 0;
    t->nbits = 0;
    t->garb = 0;
    return t;
}
@

<<function copytyp>>=
Type*
copytyp(Type *t)
{
    Type *nt;

    nt = typ(TXXX, T);
    *nt = *t;
    return nt;
}
@

<<function garbt>>=
Type*
garbt(Type *t, long b)
{
    Type *t1;

    if(b & BGARB) {
        t1 = copytyp(t);
        t1->garb = simpleg(b);
        return t1;
    }
    return t;
}
@

<<function simpleg>>=
int
simpleg(long b)
{

    b &= BGARB;
    switch(b) {
    case BCONSTNT:
        return GCONSTNT;
    case BVOLATILE:
        return GVOLATILE;
    case BVOLATILE|BCONSTNT:
        return GCONSTNT|GVOLATILE;
    }
    return GXXX;
}
@

<<function simplec>>=
int
simplec(long b)
{

    b &= BCLASS;
    switch(b) {
    case 0:
    case BREGISTER:
        return CXXX;
    case BAUTO:
    case BAUTO|BREGISTER:
        return CAUTO;
    case BEXTERN:
        return CEXTERN;
    case BEXTERN|BREGISTER:
        return CEXREG;
    case BSTATIC:
        return CSTATIC;
    case BTYPEDEF:
        return CTYPEDEF;
    case BTYPESTR:
        return CTYPESTR;
    }
    diag(Z, "illegal combination of classes %Q", b);
    return CXXX;
}
@

<<function simplet>>=
Type*
simplet(long b)
{

    b &= ~BCLASS & ~BGARB;
    switch(b) {
    case BCHAR:
    case BCHAR|BSIGNED:
        return types[TCHAR];

    case BCHAR|BUNSIGNED:
        return types[TUCHAR];

    case BSHORT:
    case BSHORT|BINT:
    case BSHORT|BSIGNED:
    case BSHORT|BINT|BSIGNED:
        return types[TSHORT];

    case BUNSIGNED|BSHORT:
    case BUNSIGNED|BSHORT|BINT:
        return types[TUSHORT];

    case 0:
    case BINT:
    case BINT|BSIGNED:
    case BSIGNED:
        return types[TINT];

    case BUNSIGNED:
    case BUNSIGNED|BINT:
        return types[TUINT];

    case BLONG:
    case BLONG|BINT:
    case BLONG|BSIGNED:
    case BLONG|BINT|BSIGNED:
        return types[TLONG];

    case BUNSIGNED|BLONG:
    case BUNSIGNED|BLONG|BINT:
        return types[TULONG];

    case BVLONG|BLONG:
    case BVLONG|BLONG|BINT:
    case BVLONG|BLONG|BSIGNED:
    case BVLONG|BLONG|BINT|BSIGNED:
        return types[TVLONG];

    case BVLONG|BLONG|BUNSIGNED:
    case BVLONG|BLONG|BINT|BUNSIGNED:
        return types[TUVLONG];

    case BFLOAT:
        return types[TFLOAT];

    case BDOUBLE:
    case BDOUBLE|BLONG:
    case BFLOAT|BLONG:
        return types[TDOUBLE];

    case BVOID:
        return types[TVOID];
    }

    diag(Z, "illegal combination of types %Q", b);
    return types[TINT];
}
@

<<function stcompat>>=
int
stcompat(Node *n, Type *t1, Type *t2, long ttab[])
{
    int i;
    ulong b;

    i = 0;
    if(t2 != T)
        i = t2->etype;
    b = 1L << i;
    i = 0;
    if(t1 != T)
        i = t1->etype;
    if(b & ttab[i]) {
        if(ttab == tasign)
            if(b == BSTRUCT || b == BUNION)
                if(!sametype(t1, t2))
                    return 1;
        if(n->op != OCAST)
          if(b == BIND && i == TIND)
                if(!sametype(t1, t2))
                    return 1;
        return 0;
    }
    return 1;
}
@

<<function tcompat>>=
int
tcompat(Node *n, Type *t1, Type *t2, long ttab[])
{

    if(stcompat(n, t1, t2, ttab)) {
        if(t1 == T)
            diag(n, "incompatible type: \"%T\" for op \"%O\"",
                t2, n->op);
        else
            diag(n, "incompatible types: \"%T\" and \"%T\" for op \"%O\"",
                t1, t2, n->op);
        return 1;
    }
    return 0;
}
@

<<function makedot>>=
void
makedot(Node *n, Type *t, long o)
{
    Node *n1, *n2;

    if(t->nbits) {
        n1 = new(OXXX, Z, Z);
        *n1 = *n;
        n->op = OBIT;
        n->left = n1;
        n->right = Z;
        n->type = t;
        n->addable = n1->left->addable;
        n = n1;
    }
    n->addable = n->left->addable;
    if(n->addable == 0) {
        n1 = new1(OCONST, Z, Z);
        n1->vconst = o;
        n1->type = types[TLONG];
        n->right = n1;
        n->type = t;
        return;
    }
    n->left->type = t;
    if(o == 0) {
        *n = *n->left;
        return;
    }
    n->type = t;
    n1 = new1(OCONST, Z, Z);
    n1->vconst = o;
    t = typ(TIND, t);
    t->width = types[TIND]->width;
    n1->type = t;

    n2 = new1(OADDR, n->left, Z);
    n2->type = t;

    n1 = new1(OADD, n1, n2);
    n1->type = t;

    n->op = OIND;
    n->left = n1;
    n->right = Z;
}
@

<<function dotsearch>>=
Type*
dotsearch(Sym *s, Type *t, Node *n, long *off)
{
    Type *t1, *xt, *rt;

    xt = T;

    /*
     * look it up by name
     */
    for(t1 = t; t1 != T; t1 = t1->down)
        if(t1->sym == s) {
            if(xt != T)
                goto ambig;
            xt = t1;
        }

    /*
     * look it up by type
     */
    if(s->class == CTYPEDEF || s->class == CTYPESTR)
        for(t1 = t; t1 != T; t1 = t1->down)
            if(t1->sym == S && typesu[t1->etype])
                if(sametype(s->type, t1)) {
                    if(xt != T)
                        goto ambig;
                    xt = t1;
                }
    if(xt != T) {
        *off = xt->offset;
        return xt;
    }

    /*
     * look it up in unnamed substructures
     */
    for(t1 = t; t1 != T; t1 = t1->down)
        if(t1->sym == S && typesu[t1->etype]){
            rt = dotsearch(s, t1->link, n, off);
            if(rt != T) {
                if(xt != T)
                    goto ambig;
                xt = rt;
                *off += t1->offset;
            }
        }
    return xt;

ambig:
    diag(n, "ambiguous structure element: %s", s->name);
    return xt;
}
@

<<function dotoffset>>=
long
dotoffset(Type *st, Type *lt, Node *n)
{
    Type *t;
    Sym *g;
    long o, o1;

    o = -1;
    /*
     * first try matching at the top level
     * for matching tag names
     */
    g = st->tag;
    if(g != S)
        for(t=lt->link; t!=T; t=t->down)
            if(t->sym == S)
                if(g == t->tag) {
                    if(o >= 0)
                        goto ambig;
                    o = t->offset;
                }
    if(o >= 0)
        return o;

    /*
     * second try matching at the top level
     * for similar types
     */
    for(t=lt->link; t!=T; t=t->down)
        if(t->sym == S)
            if(sametype(st, t)) {
                if(o >= 0)
                    goto ambig;
                o = t->offset;
            }
    if(o >= 0)
        return o;

    /*
     * last try matching sub-levels
     */
    for(t=lt->link; t!=T; t=t->down)
        if(t->sym == S)
        if(typesu[t->etype]) {
            o1 = dotoffset(st, t, n);
            if(o1 >= 0) {
                if(o >= 0)
                    goto ambig;
                o = o1 + t->offset;
            }
        }
    return o;

ambig:
    diag(n, "ambiguous unnamed structure element");
    return o;
}
@

<<function allfloat>>=
/*
 * look into tree for floating point constant expressions
 */
int
allfloat(Node *n, int flag)
{

    if(n != Z) {
        if(n->type->etype != TDOUBLE)
            return 1;
        switch(n->op) {
        case OCONST:
            if(flag)
                n->type = types[TFLOAT];
            return 1;
        case OADD:	/* no need to get more exotic than this */
        case OSUB:
        case OMUL:
        case ODIV:
            if(!allfloat(n->right, flag))
                break;
        case OCAST:
            if(!allfloat(n->left, flag))
                break;
            if(flag)
                n->type = types[TFLOAT];
            return 1;
        }
    }
    return 0;
}
@

<<function constas>>=
void
constas(Node *n, Type *il, Type *ir)
{
    Type *l, *r;

    l = il;
    r = ir;

    if(l == T)
        return;
    if(l->garb & GCONSTNT) {
        warn(n, "assignment to a constant type (%T)", il);
        return;
    }
    if(r == T)
        return;
    for(;;) {
        if(l->etype != TIND || r->etype != TIND)
            break;
        l = l->link;
        r = r->link;
        if(l == T || r == T)
            break;
        if(r->garb & GCONSTNT)
            if(!(l->garb & GCONSTNT)) {
                warn(n, "assignment of a constant pointer type (%T)", ir);
                break;
            }
    }
}
@

<<function typeext1>>=
void
typeext1(Type *st, Node *l)
{
    if(st->etype == TFLOAT && allfloat(l, 0))
        allfloat(l, 1);
}
@

<<function typeext>>=
void
typeext(Type *st, Node *l)
{
    Type *lt;
    Node *n1, *n2;
    long o;

    lt = l->type;
    if(lt == T)
        return;
    if(st->etype == TIND && vconst(l) == 0) {
        l->type = st;
        l->vconst = 0;
        return;
    }
    typeext1(st, l);

    /*
     * extension of C
     * if assign of struct containing unnamed sub-struct
     * to type of sub-struct, insert the DOT.
     * if assign of *struct containing unnamed substruct
     * to type of *sub-struct, insert the add-offset
     */
    if(typesu[st->etype] && typesu[lt->etype]) {
        o = dotoffset(st, lt, l);
        if(o >= 0) {
            n1 = new1(OXXX, Z, Z);
            *n1 = *l;
            l->op = ODOT;
            l->left = n1;
            l->right = Z;
            makedot(l, st, o);
        }
        return;
    }
    if(st->etype == TIND && typesu[st->link->etype])
    if(lt->etype == TIND && typesu[lt->link->etype]) {
        o = dotoffset(st->link, lt->link, l);
        if(o >= 0) {
            l->type = st;
            if(o == 0)
                return;
            n1 = new1(OXXX, Z, Z);
            *n1 = *l;
            n2 = new1(OCONST, Z, Z);
            n2->vconst = o;
            n2->type = st;
            l->op = OADD;
            l->left = n1;
            l->right = n2;
        }
        return;
    }
}
@

<<function nocast>>=
/*
 * a cast that generates no code
 * (same size move)
 */
int
nocast(Type *t1, Type *t2)
{
    int i, b;

    if(t1->nbits)
        return 0;
    i = 0;
    if(t2 != T)
        i = t2->etype;
    b = 1<<i;
    i = 0;
    if(t1 != T)
        i = t1->etype;
    if(b & ncast[i])
        return 1;
    return 0;
}
@

<<function nilcast>>=
/*
 * a cast that has a noop semantic
 * (small to large, convert)
 */
int
nilcast(Type *t1, Type *t2)
{
    int et1, et2;

    if(t1 == T)
        return 0;
    if(t1->nbits)
        return 0;
    if(t2 == T)
        return 0;
    et1 = t1->etype;
    et2 = t2->etype;
    if(et1 == et2)
        return 1;
    if(typefd[et1] && typefd[et2]) {
        if(ewidth[et1] < ewidth[et2])
            return 1;
        return 0;
    }
    if(typechlp[et1] && typechlp[et2]) {
        if(ewidth[et1] < ewidth[et2])
            return 1;
        return 0;
    }
    return 0;
}
@

<<function arith>>=
/*
 * "the usual arithmetic conversions are performed"
 */
void
arith(Node *n, int f)
{
    Type *t1, *t2;
    int i, j, k;
    Node *n1;
    long w;

    t1 = n->left->type;
    if(n->right == Z)
        t2 = t1;
    else
        t2 = n->right->type;
    i = TXXX;
    if(t1 != T)
        i = t1->etype;
    j = TXXX;
    if(t2 != T)
        j = t2->etype;
    k = tab[i][j];
    if(k == TIND) {
        if(i == TIND)
            n->type = t1;
        else
        if(j == TIND)
            n->type = t2;
    } else {
        /* convert up to at least int */
        if(f == 1)
        while(k < TINT)
            k += 2;
        n->type = types[k];
    }
    if(n->op == OSUB)
    if(i == TIND && j == TIND) {
        w = n->right->type->link->width;
        if(w < 1 || n->left->type->link == T || n->left->type->link->width < 1)
            goto bad;
        n->type = types[ewidth[TIND] <= ewidth[TLONG]? TLONG: TVLONG];
        if(1 && ewidth[TIND] > ewidth[TLONG]){
            n1 = new1(OXXX, Z, Z);
            *n1 = *n;
            n->op = OCAST;
            n->left = n1;
            n->right = Z;
            n->type = types[TLONG];
        }
        if(w > 1) {
            n1 = new1(OXXX, Z, Z);
            *n1 = *n;
            n->op = ODIV;
            n->left = n1;
            n1 = new1(OCONST, Z, Z);
            n1->vconst = w;
            n1->type = n->type;
            n->right = n1;
            w = vlog(n1);
            if(w >= 0) {
                n->op = OASHR;
                n1->vconst = w;
            }
        }
        return;
    }
    if(!sametype(n->type, n->left->type)) {
        n->left = new1(OCAST, n->left, Z);
        n->left->type = n->type;
        if(n->type->etype == TIND) {
            w = n->type->link->width;
            if(w < 1) {
                snap(n->type->link);
                w = n->type->link->width;
                if(w < 1)
                    goto bad;
            }
            if(w > 1) {
                n1 = new1(OCONST, Z, Z);
                n1->vconst = w;
                n1->type = n->type;
                n->left = new1(OMUL, n->left, n1);
                n->left->type = n->type;
            }
        }
    }
    if(n->right != Z)
    if(!sametype(n->type, n->right->type)) {
        n->right = new1(OCAST, n->right, Z);
        n->right->type = n->type;
        if(n->type->etype == TIND) {
            w = n->type->link->width;
            if(w < 1) {
                snap(n->type->link);
                w = n->type->link->width;
                if(w < 1)
                    goto bad;
            }
            if(w != 1) {
                n1 = new1(OCONST, Z, Z);
                n1->vconst = w;
                n1->type = n->type;
                n->right = new1(OMUL, n->right, n1);
                n->right->type = n->type;
            }
        }
    }
    return;
bad:
    diag(n, "pointer addition not fully declared: %T", n->type->link);
}
@

<<function simplifyshift>>=
/*
 * try to rewrite shift & mask
 */
void
simplifyshift(Node *n)
{
    ulong c3;
    int o, s1, s2, c1, c2;

    if(!typechlp[n->type->etype])
        return;
    switch(n->op) {
    default:
        return;
    case OASHL:
        s1 = 0;
        break;
    case OLSHR:
        s1 = 1;
        break;
    case OASHR:
        s1 = 2;
        break;
    }
    if(n->right->op != OCONST)
        return;
    if(n->left->op != OAND)
        return;
    if(n->left->right->op != OCONST)
        return;
    switch(n->left->left->op) {
    default:
        return;
    case OASHL:
        s2 = 0;
        break;
    case OLSHR:
        s2 = 1;
        break;
    case OASHR:
        s2 = 2;
        break;
    }
    if(n->left->left->right->op != OCONST)
        return;

    c1 = n->right->vconst;
    c2 = n->left->left->right->vconst;
    c3 = n->left->right->vconst;

/*
    if(debug['h'])
        print("%.3o %ld %ld %d #%.lux\n",
            (s1<<3)|s2, c1, c2, topbit(c3), c3);
*/

    o = n->op;
    switch((s1<<3)|s2) {
    case 000:	/* (((e <<u c2) & c3) <<u c1) */
        c3 >>= c2;
        c1 += c2;
        if(c1 >= 32)
            break;
        goto rewrite1;

    case 002:	/* (((e >>s c2) & c3) <<u c1) */
        if(topbit(c3) >= (32-c2))
            break;
    case 001:	/* (((e >>u c2) & c3) <<u c1) */
        if(c1 > c2) {
            c3 <<= c2;
            c1 -= c2;
            o = OASHL;
            goto rewrite1;
        }
        c3 <<= c1;
        if(c1 == c2)
            goto rewrite0;
        c1 = c2-c1;
        o = OLSHR;
        goto rewrite2;

    case 022:	/* (((e >>s c2) & c3) >>s c1) */
        if(c2 <= 0)
            break;
    case 012:	/* (((e >>s c2) & c3) >>u c1) */
        if(topbit(c3) >= (32-c2))
            break;
        goto s11;
    case 021:	/* (((e >>u c2) & c3) >>s c1) */
        if(topbit(c3) >= 31 && c2 <= 0)
            break;
        goto s11;
    case 011:	/* (((e >>u c2) & c3) >>u c1) */
    s11:
        c3 <<= c2;
        c1 += c2;
        if(c1 >= 32)
            break;
        o = OLSHR;
        goto rewrite1;

    case 020:	/* (((e <<u c2) & c3) >>s c1) */
        if(topbit(c3) >= 31)
            break;
    case 010:	/* (((e <<u c2) & c3) >>u c1) */
        c3 >>= c1;
        if(c1 == c2)
            goto rewrite0;
        if(c1 > c2) {
            c1 -= c2;
            goto rewrite2;
        }
        c1 = c2 - c1;
        o = OASHL;
        goto rewrite2;
    }
    return;

rewrite0:	/* get rid of both shifts */
if(debug['<'])prtree(n, "rewrite0");
    *n = *n->left;
    n->left = n->left->left;
    n->right->vconst = c3;
    return;
rewrite1:	/* get rid of lower shift */
if(debug['<'])prtree(n, "rewrite1");
    n->left->left = n->left->left->left;
    n->left->right->vconst = c3;
    n->right->vconst = c1;
    n->op = o;
    return;
rewrite2:	/* get rid of upper shift */
if(debug['<'])prtree(n, "rewrite2");
    *n = *n->left;
    n->right->vconst = c3;
    n->left->right->vconst = c1;
    n->left->op = o;
}
@

<<function side>>=
int
side(Node *n)
{

loop:
    if(n != Z)
    switch(n->op) {
    case OCAST:
    case ONOT:
    case OADDR:
    case OIND:
        n = n->left;
        goto loop;

    case OCOND:
        if(side(n->left))
            break;
        n = n->right;

    case OEQ:
    case ONE:
    case OLT:
    case OGE:
    case OGT:
    case OLE:
    case OADD:
    case OSUB:
    case OMUL:
    case OLMUL:
    case ODIV:
    case OLDIV:
    case OLSHR:
    case OASHL:
    case OASHR:
    case OAND:
    case OOR:
    case OXOR:
    case OMOD:
    case OLMOD:
    case OANDAND:
    case OOROR:
    case OCOMMA:
    case ODOT:
        if(side(n->left))
            break;
        n = n->right;
        goto loop;

    case OSIGN:
    case OSIZE:
    case OCONST:
    case OSTRING:
    case OLSTRING:
    case ONAME:
        return 0;
    }
    return 1;
}
@

<<function vconst>>=
int
vconst(Node *n)
{
    int i;

    if(n == Z)
        goto no;
    if(n->op != OCONST)
        goto no;
    if(n->type == T)
        goto no;
    switch(n->type->etype)
    {
    case TFLOAT:
    case TDOUBLE:
        i = 100;
        if(n->fconst > i || n->fconst < -i)
            goto no;
        i = n->fconst;
        if(i != n->fconst)
            goto no;
        return i;

    case TVLONG:
    case TUVLONG:
        i = n->vconst;
        if(i != n->vconst)
            goto no;
        return i;

    case TCHAR:
    case TUCHAR:
    case TSHORT:
    case TUSHORT:
    case TINT:
    case TUINT:
    case TLONG:
    case TULONG:
    case TIND:
        i = n->vconst;
        if(i != n->vconst)
            goto no;
        return i;
    }
no:
    return -159;	/* first uninteresting constant */
}
@

<<function log2>>=
/*
 * return log(n) if n is a power of 2 constant
 */
int
log2(uvlong v)
{
    int s, i;
    uvlong m;

    s = 0;
    m = MASK(8*sizeof(uvlong));
    for(i=32; i; i>>=1) {
        m >>= i;
        if(!(v & m)) {
            v >>= i;
            s += i;
        }
    }
    if(v == 1)
        return s;
    return -1;
}
@

<<function vlog>>=
int
vlog(Node *n)
{
    if(n->op != OCONST)
        goto bad;
    if(typefd[n->type->etype])
        goto bad;

    return log2(n->vconst);

bad:
    return -1;
}
@

<<function topbit>>=
int
topbit(ulong v)
{
    int i;

    for(i = -1; v; i++)
        v >>= 1;
    return i;
}
@

<<function relcon>>=
/*
 * try to cast a constant down
 * rather than cast a variable up
 * example:
 *	if(c == 'a')
 */
void
relcon(Node *l, Node *r)
{
    vlong v;

    if(l->op != OCONST)
        return;
    if(r->op != OCAST)
        return;
    if(!nilcast(r->left->type, r->type))
        return;
    switch(r->type->etype) {
    default:
        return;
    case TCHAR:
    case TUCHAR:
    case TSHORT:
    case TUSHORT:
        v = convvtox(l->vconst, r->type->etype);
        if(v != l->vconst)
            return;
        break;
    }
    l->type = r->left->type;
    *r = *r->left;
}
@

<<function relindex>>=
int
relindex(int o)
{

    switch(o) {
    default:
        diag(Z, "bad in relindex: %O", o);
    case OEQ: return 0;
    case ONE: return 1;
    case OLE: return 2;
    case OLS: return 3;
    case OLT: return 4;
    case OLO: return 5;
    case OGE: return 6;
    case OHS: return 7;
    case OGT: return 8;
    case OHI: return 9;
    }
}
@

<<function invert>>=
Node*
invert(Node *n)
{
    Node *i;

    if(n == Z || n->op != OLIST)
        return n;
    i = n;
    for(n = n->left; n != Z; n = n->left) {
        if(n->op != OLIST)
            break;
        i->left = n->right;
        n->right = i;
        i = n;
    }
    i->left = n;
    return i;
}
@

<<function bitno>>=
int
bitno(long b)
{
    int i;

    for(i=0; i<32; i++)
        if(b & (1L<<i))
            return i;
    diag(Z, "bad in bitno");
    return 0;
}
@

<<function typebitor>>=
long
typebitor(long a, long b)
{
    long c;

    c = a | b;
    if(a & b)
        if((a & b) == BLONG)
            c |= BVLONG;		/* long long => vlong */
        else
            warn(Z, "once is enough: %Q", a & b);
    return c;
}
@

<<function diag>>=
void
diag(Node *n, char *fmt, ...)
{
    char buf[STRINGSZ];
    va_list arg;

    va_start(arg, fmt);
    vseprint(buf, buf+sizeof(buf), fmt, arg);
    va_end(arg);
    Bprint(&diagbuf, "%L %s\n", (n==Z)? nearln: n->lineno, buf);

    if(debug['X']){
        Bflush(&diagbuf);
        abort();
    }
    if(n != Z)
    if(debug['v'])
        prtree(n, "diagnostic");

    nerrors++;
    if(nerrors > 10) {
        Bprint(&diagbuf, "too many errors\n");
        errorexit();
    }
}
@

<<function warn>>=
void
warn(Node *n, char *fmt, ...)
{
    char buf[STRINGSZ];
    va_list arg;

    if(debug['w'] || debug['W']) {
        va_start(arg, fmt);
        vseprint(buf, buf+sizeof(buf), fmt, arg);
        va_end(arg);
        if(debug['W']) {
            diag(n, "%s", buf);
            return;
        }
        Bprint(&diagbuf, "warning: %L %s\n", (n==Z)? nearln: n->lineno, buf);

        if(n != Z)
        if(debug['v'])
            prtree(n, "warning");
    }
}
@

<<function fatal>>=
void
fatal(Node *n, char *fmt, ...)
{
    char buf[STRINGSZ];
    va_list arg;

    va_start(arg, fmt);
    vseprint(buf, buf+sizeof(buf), fmt, arg);
    va_end(arg);
    Bprint(&diagbuf, "%L %s\n", (n==Z)? nearln: n->lineno, buf);

    if(debug['X']){
        Bflush(&diagbuf);
        abort();
    }
    if(n != Z)
    if(debug['v'])
        prtree(n, "diagnostic");

    nerrors++;
    errorexit();
}
@

<<global thash1>>=
ulong	thash1	= 0x2edab8c9;
@

<<global thash2>>=
ulong	thash2	= 0x1dc74fb8;
@

<<global thash3>>=
ulong	thash3	= 0x1f241331;
@

<<global thash>>=
ulong	thash[NALLTYPES];
@

<<global thashinit>>=
Init	thashinit[] =
{
    TXXX,		0x17527bbd,	0,
    TCHAR,		0x5cedd32b,	0,
    TUCHAR,		0x552c4454,	0,
    TSHORT,		0x63040b4b,	0,
    TUSHORT,	0x32a45878,	0,
    TINT,		0x4151d5bd,	0,
    TUINT,		0x5ae707d6,	0,
    TLONG,		0x5ef20f47,	0,
    TULONG,		0x36d8eb8f,	0,
    TVLONG,		0x6e5e9590,	0,
    TUVLONG,	0x75910105,	0,
    TFLOAT,		0x25fd7af1,	0,
    TDOUBLE,	0x7c40a1b2,	0,
    TIND,		0x1b832357,	0,
    TFUNC,		0x6babc9cb,	0,
    TARRAY,		0x7c50986d,	0,
    TVOID,		0x44112eff,	0,
    TSTRUCT,	0x7c2da3bf,	0,
    TUNION,		0x3eb25e98,	0,
    TENUM,		0x44b54f61,	0,
    TFILE,		0x19242ac3,	0,
    TOLD,		0x22b15988,	0,
    TDOT,		0x0204f6b3,	0,
    -1,		0,		0,
};
@

<<global bnames>>=
char*	bnames[NALIGN];
@

<<global bnamesinit>>=
Init	bnamesinit[] =
{
    Axxx,	0,	"Axxx",
    Ael1,	0,	"el1",
    Ael2,	0,	"el2",
    Asu2,	0,	"su2",
    Aarg0,	0,	"arg0",
    Aarg1,	0,	"arg1",
    Aarg2,	0,	"arg2",
    Aaut3,	0,	"aut3",
    -1,	0,	0,
};
@

<<global tnames>>=
char*	tnames[NALLTYPES];
@

<<global tnamesinit>>=
Init	tnamesinit[] =
{
    TXXX,		0,	"TXXX",
    TCHAR,		0,	"CHAR",
    TUCHAR,		0,	"UCHAR",
    TSHORT,		0,	"SHORT",
    TUSHORT,	0,	"USHORT",
    TINT,		0,	"INT",
    TUINT,		0,	"UINT",
    TLONG,		0,	"LONG",
    TULONG,		0,	"ULONG",
    TVLONG,		0,	"VLONG",
    TUVLONG,	0,	"UVLONG",
    TFLOAT,		0,	"FLOAT",
    TDOUBLE,	0,	"DOUBLE",
    TIND,		0,	"IND",
    TFUNC,		0,	"FUNC",
    TARRAY,		0,	"ARRAY",
    TVOID,		0,	"VOID",
    TSTRUCT,	0,	"STRUCT",
    TUNION,		0,	"UNION",
    TENUM,		0,	"ENUM",
    TFILE,		0,	"FILE",
    TOLD,		0,	"OLD",
    TDOT,		0,	"DOT",
    -1,		0,	0,
};
@

<<global gnames>>=
char*	gnames[NGTYPES];
@

<<global gnamesinit>>=
Init	gnamesinit[] =
{
    GXXX,			0,	"GXXX",
    GCONSTNT,		0,	"CONST",
    GVOLATILE,		0,	"VOLATILE",
    GVOLATILE|GCONSTNT,	0,	"CONST-VOLATILE",
    -1,			0,	0,
};
@

<<global qnames>>=
char*	qnames[NALLTYPES];
@

<<global qnamesinit>>=
Init	qnamesinit[] =
{
    TXXX,		0,	"TXXX",
    TCHAR,		0,	"CHAR",
    TUCHAR,		0,	"UCHAR",
    TSHORT,		0,	"SHORT",
    TUSHORT,	0,	"USHORT",
    TINT,		0,	"INT",
    TUINT,		0,	"UINT",
    TLONG,		0,	"LONG",
    TULONG,		0,	"ULONG",
    TVLONG,		0,	"VLONG",
    TUVLONG,	0,	"UVLONG",
    TFLOAT,		0,	"FLOAT",
    TDOUBLE,	0,	"DOUBLE",
    TIND,		0,	"IND",
    TFUNC,		0,	"FUNC",
    TARRAY,		0,	"ARRAY",
    TVOID,		0,	"VOID",
    TSTRUCT,	0,	"STRUCT",
    TUNION,		0,	"UNION",
    TENUM,		0,	"ENUM",

    TAUTO,		0,	"AUTO",
    TEXTERN,	0,	"EXTERN",
    TSTATIC,	0,	"STATIC",
    TTYPEDEF,	0,	"TYPEDEF",
    TTYPESTR,	0,	"TYPESTR",
    TREGISTER,	0,	"REGISTER",
    TCONSTNT,	0,	"CONSTNT",
    TVOLATILE,	0,	"VOLATILE",
    TUNSIGNED,	0,	"UNSIGNED",
    TSIGNED,	0,	"SIGNED",
    TDOT,		0,	"DOT",
    TFILE,		0,	"FILE",
    TOLD,		0,	"OLD",
    -1,		0,	0,
};
@

<<global cnames>>=
char*	cnames[NCTYPES];
@

<<global cnamesinit>>=
Init	cnamesinit[] =
{
    CXXX,		0,	"CXXX",
    CAUTO,		0,	"AUTO",
    CEXTERN,	0,	"EXTERN",
    CGLOBL,		0,	"GLOBL",
    CSTATIC,	0,	"STATIC",
    CLOCAL,		0,	"LOCAL",
    CTYPEDEF,	0,	"TYPEDEF",
    CTYPESTR,	0,	"TYPESTR",
    CPARAM,		0,	"PARAM",
    CSELEM,		0,	"SELEM",
    CLABEL,		0,	"LABEL",
    CEXREG,		0,	"EXREG",
    -1,		0,	0,
};
@

<<global onames>>=
char*	onames[OEND+1];
@

<<global onamesinit>>=
Init	onamesinit[] =
{
    OXXX,		0,	"OXXX",
    OADD,		0,	"ADD",
    OADDR,		0,	"ADDR",
    OAND,		0,	"AND",
    OANDAND,	0,	"ANDAND",
    OARRAY,		0,	"ARRAY",
    OAS,		0,	"AS",
    OASI,		0,	"ASI",
    OASADD,		0,	"ASADD",
    OASAND,		0,	"ASAND",
    OASASHL,	0,	"ASASHL",
    OASASHR,	0,	"ASASHR",
    OASDIV,		0,	"ASDIV",
    OASHL,		0,	"ASHL",
    OASHR,		0,	"ASHR",
    OASLDIV,	0,	"ASLDIV",
    OASLMOD,	0,	"ASLMOD",
    OASLMUL,	0,	"ASLMUL",
    OASLSHR,	0,	"ASLSHR",
    OASMOD,		0,	"ASMOD",
    OASMUL,		0,	"ASMUL",
    OASOR,		0,	"ASOR",
    OASSUB,		0,	"ASSUB",
    OASXOR,		0,	"ASXOR",
    OBIT,		0,	"BIT",
    OBREAK,		0,	"BREAK",
    OCASE,		0,	"CASE",
    OCAST,		0,	"CAST",
    OCOMMA,		0,	"COMMA",
    OCOND,		0,	"COND",
    OCONST,		0,	"CONST",
    OCONTINUE,	0,	"CONTINUE",
    ODIV,		0,	"DIV",
    ODOT,		0,	"DOT",
    ODOTDOT,	0,	"DOTDOT",
    ODWHILE,	0,	"DWHILE",
    OENUM,		0,	"ENUM",
    OEQ,		0,	"EQ",
    OFOR,		0,	"FOR",
    OFUNC,		0,	"FUNC",
    OGE,		0,	"GE",
    OGOTO,		0,	"GOTO",
    OGT,		0,	"GT",
    OHI,		0,	"HI",
    OHS,		0,	"HS",
    OIF,		0,	"IF",
    OIND,		0,	"IND",
    OINDREG,	0,	"INDREG",
    OINIT,		0,	"INIT",
    OLABEL,		0,	"LABEL",
    OLDIV,		0,	"LDIV",
    OLE,		0,	"LE",
    OLIST,		0,	"LIST",
    OLMOD,		0,	"LMOD",
    OLMUL,		0,	"LMUL",
    OLO,		0,	"LO",
    OLS,		0,	"LS",
    OLSHR,		0,	"LSHR",
    OLT,		0,	"LT",
    OMOD,		0,	"MOD",
    OMUL,		0,	"MUL",
    ONAME,		0,	"NAME",
    ONE,		0,	"NE",
    ONOT,		0,	"NOT",
    OOR,		0,	"OR",
    OOROR,		0,	"OROR",
    OPOSTDEC,	0,	"POSTDEC",
    OPOSTINC,	0,	"POSTINC",
    OPREDEC,	0,	"PREDEC",
    OPREINC,	0,	"PREINC",
    OPROTO,		0,	"PROTO",
    OREGISTER,	0,	"REGISTER",
    ORETURN,	0,	"RETURN",
    OSET,		0,	"SET",
    OSIGN,		0,	"SIGN",
    OSIZE,		0,	"SIZE",
    OSTRING,	0,	"STRING",
    OLSTRING,	0,	"LSTRING",
    OSTRUCT,	0,	"STRUCT",
    OSUB,		0,	"SUB",
    OSWITCH,	0,	"SWITCH",
    OUNION,		0,	"UNION",
    OUSED,		0,	"USED",
    OWHILE,		0,	"WHILE",
    OXOR,		0,	"XOR",
    OPOS,		0,	"POS",
    ONEG,		0,	"NEG",
    OCOM,		0,	"COM",
    OELEM,		0,	"ELEM",
    OTST,		0,	"TST",
    OINDEX,		0,	"INDEX",
    OFAS,		0,	"FAS",
    OREGPAIR,	0,	"REGPAIR",
    OEXREG,		0,	"EXREG",
    OEND,		0,	"END",
    -1,		0,	0,
};
@

<<global comrel>>=
/*	OEQ, ONE, OLE, OLS, OLT, OLO, OGE, OHS, OGT, OHI */
char	comrel[12] =
{
    ONE, OEQ, OGT, OHI, OGE, OHS, OLT, OLO, OLE, OLS,
};
@

<<global invrel>>=
char	invrel[12] =
{
    OEQ, ONE, OGE, OHS, OGT, OHI, OLE, OLS, OLT, OLO,
};
@

<<global logrel>>=
char	logrel[12] =
{
    OEQ, ONE, OLS, OLS, OLO, OLO, OHS, OHS, OHI, OHI,
};
@

<<global typei>>=
char	typei[NTYPE];
@

<<global typeiinit>>=
int	typeiinit[] =
{
    TCHAR, TUCHAR, TSHORT, TUSHORT, TINT, TUINT, TLONG, TULONG, TVLONG, TUVLONG, -1,
};
@

<<global typeu>>=
char	typeu[NTYPE];
@

<<global typeuinit>>=
int	typeuinit[] =
{
    TUCHAR, TUSHORT, TUINT, TULONG, TUVLONG, TIND, -1,
};
@

<<global typesuv>>=
char	typesuv[NTYPE];
@

<<global typesuvinit>>=
int	typesuvinit[] =
{
    TVLONG, TUVLONG, TSTRUCT, TUNION, -1,
};
@

<<global typeilp>>=
char	typeilp[NTYPE];
@

<<global typeilpinit>>=
int	typeilpinit[] =
{
    TINT, TUINT, TLONG, TULONG, TIND, -1
};
@

<<global typechl>>=
char	typechl[NTYPE];
@

<<global typechlv>>=
char	typechlv[NTYPE];
@

<<global typechlvp>>=
char typechlvp[NTYPE];
@

<<global typechlinit>>=
int	typechlinit[] =
{
    TCHAR, TUCHAR, TSHORT, TUSHORT, TINT, TUINT, TLONG, TULONG, -1,
};
@

<<global typechlp>>=
char	typechlp[NTYPE];
@

<<global typechlpinit>>=
int	typechlpinit[] =
{
    TCHAR, TUCHAR, TSHORT, TUSHORT, TINT, TUINT, TLONG, TULONG, TIND, -1,
};
@

<<global typechlpfd>>=
char	typechlpfd[NTYPE];
@

<<global typechlpfdinit>>=
int	typechlpfdinit[] =
{
    TCHAR, TUCHAR, TSHORT, TUSHORT, TINT, TUINT, TLONG, TULONG, TFLOAT, TDOUBLE, TIND, -1,
};
@

<<global typec>>=
char	typec[NTYPE];
@

<<global typecinit>>=
int	typecinit[] =
{
    TCHAR, TUCHAR, -1
};
@

<<global typeh>>=
char	typeh[NTYPE];
@

<<global typehinit>>=
int	typehinit[] =
{
    TSHORT, TUSHORT, -1,
};
@

<<global typeil>>=
char	typeil[NTYPE];
@

<<global typeilinit>>=
int	typeilinit[] =
{
    TINT, TUINT, TLONG, TULONG, -1,
};
@

<<global typev>>=
char	typev[NTYPE];
@

<<global typevinit>>=
int	typevinit[] =
{
    TVLONG,	TUVLONG, -1,
};
@

<<global typefd>>=
char	typefd[NTYPE];
@

<<global typefdinit>>=
int	typefdinit[] =
{
    TFLOAT, TDOUBLE, -1,
};
@

<<global typeaf>>=
char	typeaf[NTYPE];
@

<<global typeafinit>>=
int	typeafinit[] =
{
    TFUNC, TARRAY, -1,
};
@

<<global typesu>>=
char	typesu[NTYPE];
@

<<global typesuinit>>=
int	typesuinit[] =
{
    TSTRUCT, TUNION, -1,
};
@

<<global tasign>>=
long	tasign[NTYPE];
@

<<global tasigninit>>=
Init	tasigninit[] =
{
    TCHAR,		BNUMBER,	0,
    TUCHAR,		BNUMBER,	0,
    TSHORT,		BNUMBER,	0,
    TUSHORT,	BNUMBER,	0,
    TINT,		BNUMBER,	0,
    TUINT,		BNUMBER,	0,
    TLONG,		BNUMBER,	0,
    TULONG,		BNUMBER,	0,
    TVLONG,		BNUMBER,	0,
    TUVLONG,	BNUMBER,	0,
    TFLOAT,		BNUMBER,	0,
    TDOUBLE,	BNUMBER,	0,
    TIND,		BIND,		0,
    TSTRUCT,	BSTRUCT,	0,
    TUNION,		BUNION,		0,
    -1,		0,		0,
};
@

<<global tasadd>>=
long	tasadd[NTYPE];
@

<<global tasaddinit>>=
Init	tasaddinit[] =
{
    TCHAR,		BNUMBER,	0,
    TUCHAR,		BNUMBER,	0,
    TSHORT,		BNUMBER,	0,
    TUSHORT,	BNUMBER,	0,
    TINT,		BNUMBER,	0,
    TUINT,		BNUMBER,	0,
    TLONG,		BNUMBER,	0,
    TULONG,		BNUMBER,	0,
    TVLONG,		BNUMBER,	0,
    TUVLONG,	BNUMBER,	0,
    TFLOAT,		BNUMBER,	0,
    TDOUBLE,	BNUMBER,	0,
    TIND,		BINTEGER,	0,
    -1,		0,		0,
};
@

<<global tcast>>=
long	tcast[NTYPE];
@

<<global tcastinit>>=
Init	tcastinit[] =
{
    TCHAR,		BNUMBER|BIND|BVOID,	0,
    TUCHAR,		BNUMBER|BIND|BVOID,	0,
    TSHORT,		BNUMBER|BIND|BVOID,	0,
    TUSHORT,	BNUMBER|BIND|BVOID,	0,
    TINT,		BNUMBER|BIND|BVOID,	0,
    TUINT,		BNUMBER|BIND|BVOID,	0,
    TLONG,		BNUMBER|BIND|BVOID,	0,
    TULONG,		BNUMBER|BIND|BVOID,	0,
    TVLONG,		BNUMBER|BIND|BVOID,	0,
    TUVLONG,	BNUMBER|BIND|BVOID,	0,
    TFLOAT,		BNUMBER|BVOID,		0,
    TDOUBLE,	BNUMBER|BVOID,		0,
    TIND,		BINTEGER|BIND|BVOID,	0,
    TVOID,		BVOID,			0,
    TSTRUCT,	BSTRUCT|BVOID,		0,
    TUNION,		BUNION|BVOID,		0,
    -1,		0,			0,
};
@

<<global tadd>>=
long	tadd[NTYPE];
@

<<global taddinit>>=
Init	taddinit[] =
{
    TCHAR,		BNUMBER|BIND,	0,
    TUCHAR,		BNUMBER|BIND,	0,
    TSHORT,		BNUMBER|BIND,	0,
    TUSHORT,	BNUMBER|BIND,	0,
    TINT,		BNUMBER|BIND,	0,
    TUINT,		BNUMBER|BIND,	0,
    TLONG,		BNUMBER|BIND,	0,
    TULONG,		BNUMBER|BIND,	0,
    TVLONG,		BNUMBER|BIND,	0,
    TUVLONG,	BNUMBER|BIND,	0,
    TFLOAT,		BNUMBER,	0,
    TDOUBLE,	BNUMBER,	0,
    TIND,		BINTEGER,	0,
    -1,		0,		0,
};
@

<<global tsub>>=
long	tsub[NTYPE];
@

<<global tsubinit>>=
Init	tsubinit[] =
{
    TCHAR,		BNUMBER,	0,
    TUCHAR,		BNUMBER,	0,
    TSHORT,		BNUMBER,	0,
    TUSHORT,	BNUMBER,	0,
    TINT,		BNUMBER,	0,
    TUINT,		BNUMBER,	0,
    TLONG,		BNUMBER,	0,
    TULONG,		BNUMBER,	0,
    TVLONG,		BNUMBER,	0,
    TUVLONG,	BNUMBER,	0,
    TFLOAT,		BNUMBER,	0,
    TDOUBLE,	BNUMBER,	0,
    TIND,		BINTEGER|BIND,	0,
    -1,		0,		0,
};
@

<<global tmul>>=
long	tmul[NTYPE];
@

<<global tmulinit>>=
Init	tmulinit[] =
{
    TCHAR,		BNUMBER,	0,
    TUCHAR,		BNUMBER,	0,
    TSHORT,		BNUMBER,	0,
    TUSHORT,	BNUMBER,	0,
    TINT,		BNUMBER,	0,
    TUINT,		BNUMBER,	0,
    TLONG,		BNUMBER,	0,
    TULONG,		BNUMBER,	0,
    TVLONG,		BNUMBER,	0,
    TUVLONG,	BNUMBER,	0,
    TFLOAT,		BNUMBER,	0,
    TDOUBLE,	BNUMBER,	0,
    -1,		0,		0,
};
@

<<global tand>>=
long	tand[NTYPE];
@

<<global tandinit>>=
Init	tandinit[] =
{
    TCHAR,		BINTEGER,	0,
    TUCHAR,		BINTEGER,	0,
    TSHORT,		BINTEGER,	0,
    TUSHORT,	BINTEGER,	0,
    TINT,		BNUMBER,	0,
    TUINT,		BNUMBER,	0,
    TLONG,		BINTEGER,	0,
    TULONG,		BINTEGER,	0,
    TVLONG,		BINTEGER,	0,
    TUVLONG,	BINTEGER,	0,
    -1,		0,		0,
};
@

<<global trel>>=
long	trel[NTYPE];
@

<<global trelinit>>=
Init	trelinit[] =
{
    TCHAR,		BNUMBER,	0,
    TUCHAR,		BNUMBER,	0,
    TSHORT,		BNUMBER,	0,
    TUSHORT,	BNUMBER,	0,
    TINT,		BNUMBER,	0,
    TUINT,		BNUMBER,	0,
    TLONG,		BNUMBER,	0,
    TULONG,		BNUMBER,	0,
    TVLONG,		BNUMBER,	0,
    TUVLONG,	BNUMBER,	0,
    TFLOAT,		BNUMBER,	0,
    TDOUBLE,	BNUMBER,	0,
    TIND,		BIND,		0,
    -1,		0,		0,
};
@

<<global tfunct>>=
long	tfunct[1] =
{
    BFUNC,
};
@

<<global tindir>>=
long	tindir[1] =
{
    BIND,
};
@

<<global tdot>>=
long	tdot[1] =
{
    BSTRUCT|BUNION,
};
@

<<global tnot>>=
long	tnot[1] =
{
    BNUMBER|BIND,
};
@

<<global targ>>=
long	targ[1] =
{
    BNUMBER|BIND|BSTRUCT|BUNION,
};
@

<<global tab>>=
char	tab[NTYPE][NTYPE] =
{
/*TXXX*/	{ 0,
        },

/*TCHAR*/	{ 0,	TCHAR, TUCHAR, TSHORT, TUSHORT, TINT, TUINT, TLONG,
            TULONG, TVLONG, TUVLONG, TFLOAT, TDOUBLE, TIND,
        },
/*TUCHAR*/	{ 0,	TUCHAR, TUCHAR, TUSHORT, TUSHORT, TUINT, TUINT, TULONG,
            TULONG, TUVLONG, TUVLONG, TFLOAT, TDOUBLE, TIND,
        },
/*TSHORT*/	{ 0,	TSHORT, TUSHORT, TSHORT, TUSHORT, TINT, TUINT, TLONG,
            TULONG, TVLONG, TUVLONG, TFLOAT, TDOUBLE, TIND,
        },
/*TUSHORT*/	{ 0,	TUSHORT, TUSHORT, TUSHORT, TUSHORT, TUINT, TUINT, TULONG,
            TULONG, TUVLONG, TUVLONG, TFLOAT, TDOUBLE, TIND,
        },
/*TINT*/	{ 0,	TINT, TUINT, TINT, TUINT, TINT, TUINT, TLONG,
            TULONG, TVLONG, TUVLONG, TFLOAT, TDOUBLE, TIND,
        },
/*TUINT*/	{ 0,	TUINT, TUINT, TUINT, TUINT, TUINT, TUINT, TULONG,
            TULONG, TUVLONG, TUVLONG, TFLOAT, TDOUBLE, TIND,
        },
/*TLONG*/	{ 0,	TLONG, TULONG, TLONG, TULONG, TLONG, TULONG, TLONG,
            TULONG, TVLONG, TUVLONG, TFLOAT, TDOUBLE, TIND,
        },
/*TULONG*/	{ 0,	TULONG, TULONG, TULONG, TULONG, TULONG, TULONG, TULONG,
            TULONG, TUVLONG, TUVLONG, TFLOAT, TDOUBLE, TIND,
        },
/*TVLONG*/	{ 0,	TVLONG, TUVLONG, TVLONG, TUVLONG, TVLONG, TUVLONG, TVLONG,
            TUVLONG, TVLONG, TUVLONG, TFLOAT, TDOUBLE, TIND,
        },
/*TUVLONG*/	{ 0,	TUVLONG, TUVLONG, TUVLONG, TUVLONG, TUVLONG, TUVLONG, TUVLONG,
            TUVLONG, TUVLONG, TUVLONG, TFLOAT, TDOUBLE, TIND,
        },
/*TFLOAT*/	{ 0,	TFLOAT, TFLOAT, TFLOAT, TFLOAT, TFLOAT, TFLOAT, TFLOAT,
            TFLOAT, TFLOAT, TFLOAT, TFLOAT, TDOUBLE, TIND,
        },
/*TDOUBLE*/	{ 0,	TDOUBLE, TDOUBLE, TDOUBLE, TDOUBLE, TDOUBLE, TDOUBLE, TDOUBLE,
            TDOUBLE, TDOUBLE, TDOUBLE, TFLOAT, TDOUBLE, TIND,
        },
/*TIND*/	{ 0,	TIND, TIND, TIND, TIND, TIND, TIND, TIND,
             TIND, TIND, TIND, TIND, TIND, TIND,
        },
};
@

<<function urk>>=
void
urk(char *name, int max, int i)
{
    if(i >= max) {
        fprint(2, "bad tinit: %s %d>=%d\n", name, i, max);
        exits("init");
    }
}
@

<<function tinit>>=
void
tinit(void)
{
    int *ip;
    Init *p;

    for(p=thashinit; p->code >= 0; p++) {
        urk("thash", nelem(thash), p->code);
        thash[p->code] = p->value;
    }
    for(p=bnamesinit; p->code >= 0; p++) {
        urk("bnames", nelem(bnames), p->code);
        bnames[p->code] = p->s;
    }
    for(p=tnamesinit; p->code >= 0; p++) {
        urk("tnames", nelem(tnames), p->code);
        tnames[p->code] = p->s;
    }
    for(p=gnamesinit; p->code >= 0; p++) {
        urk("gnames", nelem(gnames), p->code);
        gnames[p->code] = p->s;
    }
    for(p=qnamesinit; p->code >= 0; p++) {
        urk("qnames", nelem(qnames), p->code);
        qnames[p->code] = p->s;
    }
    for(p=cnamesinit; p->code >= 0; p++) {
        urk("cnames", nelem(cnames), p->code);
        cnames[p->code] = p->s;
    }
    for(p=onamesinit; p->code >= 0; p++) {
        urk("onames", nelem(onames), p->code);
        onames[p->code] = p->s;
    }
    for(ip=typeiinit; *ip>=0; ip++) {
        urk("typei", nelem(typei), *ip);
        typei[*ip] = 1;
    }
    for(ip=typeuinit; *ip>=0; ip++) {
        urk("typeu", nelem(typeu), *ip);
        typeu[*ip] = 1;
    }
    for(ip=typesuvinit; *ip>=0; ip++) {
        urk("typesuv", nelem(typesuv), *ip);
        typesuv[*ip] = 1;
    }
    for(ip=typeilpinit; *ip>=0; ip++) {
        urk("typeilp", nelem(typeilp), *ip);
        typeilp[*ip] = 1;
    }
    for(ip=typechlinit; *ip>=0; ip++) {
        urk("typechl", nelem(typechl), *ip);
        typechl[*ip] = 1;
        typechlv[*ip] = 1;
        typechlvp[*ip] = 1;
    }
    for(ip=typechlpinit; *ip>=0; ip++) {
        urk("typechlp", nelem(typechlp), *ip);
        typechlp[*ip] = 1;
        typechlvp[*ip] = 1;
    }
    for(ip=typechlpfdinit; *ip>=0; ip++) {
        urk("typechlpfd", nelem(typechlpfd), *ip);
        typechlpfd[*ip] = 1;
    }
    for(ip=typecinit; *ip>=0; ip++) {
        urk("typec", nelem(typec), *ip);
        typec[*ip] = 1;
    }
    for(ip=typehinit; *ip>=0; ip++) {
        urk("typeh", nelem(typeh), *ip);
        typeh[*ip] = 1;
    }
    for(ip=typeilinit; *ip>=0; ip++) {
        urk("typeil", nelem(typeil), *ip);
        typeil[*ip] = 1;
    }
    for(ip=typevinit; *ip>=0; ip++) {
        urk("typev", nelem(typev), *ip);
        typev[*ip] = 1;
        typechlv[*ip] = 1;
        typechlvp[*ip] = 1;
    }
    for(ip=typefdinit; *ip>=0; ip++) {
        urk("typefd", nelem(typefd), *ip);
        typefd[*ip] = 1;
    }
    for(ip=typeafinit; *ip>=0; ip++) {
        urk("typeaf", nelem(typeaf), *ip);
        typeaf[*ip] = 1;
    }
    for(ip=typesuinit; *ip >= 0; ip++) {
        urk("typesu", nelem(typesu), *ip);
        typesu[*ip] = 1;
    }
    for(p=tasigninit; p->code >= 0; p++) {
        urk("tasign", nelem(tasign), p->code);
        tasign[p->code] = p->value;
    }
    for(p=tasaddinit; p->code >= 0; p++) {
        urk("tasadd", nelem(tasadd), p->code);
        tasadd[p->code] = p->value;
    }
    for(p=tcastinit; p->code >= 0; p++) {
        urk("tcast", nelem(tcast), p->code);
        tcast[p->code] = p->value;
    }
    for(p=taddinit; p->code >= 0; p++) {
        urk("tadd", nelem(tadd), p->code);
        tadd[p->code] = p->value;
    }
    for(p=tsubinit; p->code >= 0; p++) {
        urk("tsub", nelem(tsub), p->code);
        tsub[p->code] = p->value;
    }
    for(p=tmulinit; p->code >= 0; p++) {
        urk("tmul", nelem(tmul), p->code);
        tmul[p->code] = p->value;
    }
    for(p=tandinit; p->code >= 0; p++) {
        urk("tand", nelem(tand), p->code);
        tand[p->code] = p->value;
    }
    for(p=trelinit; p->code >= 0; p++) {
        urk("trel", nelem(trel), p->code);
        trel[p->code] = p->value;
    }
    
    /* 32-bit defaults */
    typeword = typechlp;
    typeswitch = typechl;
    typecmplx = typesuv;
}
@

<<function deadhead>>=
/*
 * return 1 if it is impossible to jump into the middle of n.
 */
static int
deadhead(Node *n, int caseok)
{
loop:
    if(n == Z)
        return 1;
    switch(n->op) {
    case OLIST:
        if(!deadhead(n->left, caseok))
            return 0;
    rloop:
        n = n->right;
        goto loop;

    case ORETURN:
        break;

    case OLABEL:
        return 0;

    case OGOTO:
        break;

    case OCASE:
        if(!caseok)
            return 0;
        goto rloop;

    case OSWITCH:
        return deadhead(n->right, 1);

    case OWHILE:
    case ODWHILE:
        goto rloop;

    case OFOR:
        goto rloop;

    case OCONTINUE:
        break;

    case OBREAK:
        break;

    case OIF:
        return deadhead(n->right->left, caseok) && deadhead(n->right->right, caseok);

    case OSET:
    case OUSED:
        break;
    }
    return 1;
}
@

<<function deadheads>>=
int
deadheads(Node *c)
{
    return deadhead(c->left, 0) && deadhead(c->right, 0);
}
@

<<function mixedasop>>=
int
mixedasop(Type *l, Type *r)
{
    return !typefd[l->etype] && typefd[r->etype];
}
@


%-------------------------------------------------------------

<<cc/sub.c>>=
#include	"cc.h"

<<function new>>

<<function new1>>

<<function prtree>>

<<function prtree1>>

<<function typ>>

<<function copytyp>>

<<function garbt>>

<<function simpleg>>

<<function simplec>>

<<function simplet>>

<<function stcompat>>

<<function tcompat>>

<<function makedot>>

<<function dotsearch>>

<<function dotoffset>>

<<function allfloat>>

<<function constas>>

<<function typeext1>>

<<function typeext>>

<<function nocast>>

<<function nilcast>>

<<function arith>>

<<function simplifyshift>>

<<function side>>

<<function vconst>>

<<function log2>>

<<function vlog>>

<<function topbit>>

<<function relcon>>

<<function relindex>>

<<function invert>>

<<function bitno>>

<<function typebitor>>

<<function diag>>

<<function warn>>

<<function fatal>>

<<global thash1>>
<<global thash2>>
<<global thash3>>
<<global thash>>
<<global thashinit>>

<<global bnames>>
<<global bnamesinit>>

<<global tnames>>
<<global tnamesinit>>

<<global gnames>>
<<global gnamesinit>>

<<global qnames>>
<<global qnamesinit>>
<<global cnames>>
<<global cnamesinit>>

<<global onames>>
<<global onamesinit>>

<<global comrel>>
<<global invrel>>
<<global logrel>>

<<global typei>>
<<global typeiinit>>
<<global typeu>>
<<global typeuinit>>

<<global typesuv>>
<<global typesuvinit>>

<<global typeilp>>
<<global typeilpinit>>

<<global typechl>>
<<global typechlv>>
<<global typechlvp>>
<<global typechlinit>>

<<global typechlp>>
<<global typechlpinit>>

<<global typechlpfd>>
<<global typechlpfdinit>>

<<global typec>>
<<global typecinit>>

<<global typeh>>
<<global typehinit>>

<<global typeil>>
<<global typeilinit>>

<<global typev>>
<<global typevinit>>

<<global typefd>>
<<global typefdinit>>

<<global typeaf>>
<<global typeafinit>>

<<global typesu>>
<<global typesuinit>>

<<global tasign>>
<<global tasigninit>>

<<global tasadd>>
<<global tasaddinit>>

<<global tcast>>
<<global tcastinit>>

<<global tadd>>
<<global taddinit>>

<<global tsub>>
<<global tsubinit>>

<<global tmul>>
<<global tmulinit>>

<<global tand>>
<<global tandinit>>

<<global trel>>
<<global trelinit>>

<<global tfunct>>

<<global tindir>>

<<global tdot>>

<<global tnot>>

<<global targ>>

<<global tab>>

<<function urk>>

<<function tinit>>

<<function deadhead>>

<<function deadheads>>

<<function mixedasop>>
@


\subsection*{[[cc/bits.c]]}

<<function bor>>=
Bits
bor(Bits a, Bits b)
{
    Bits c;
    int i;

    for(i=0; i<BITS; i++)
        c.b[i] = a.b[i] | b.b[i];
    return c;
}
@

<<function band>>=
Bits
band(Bits a, Bits b)
{
    Bits c;
    int i;

    for(i=0; i<BITS; i++)
        c.b[i] = a.b[i] & b.b[i];
    return c;
}
@

<<function bany>>=
/*
Bits
bnot(Bits a)
{
    Bits c;
    int i;

    for(i=0; i<BITS; i++)
        c.b[i] = ~a.b[i];
    return c;
}
*/

int
bany(Bits *a)
{
    int i;

    for(i=0; i<BITS; i++)
        if(a->b[i])
            return 1;
    return 0;
}
@

<<function beq>>=
int
beq(Bits a, Bits b)
{
    int i;

    for(i=0; i<BITS; i++)
        if(a.b[i] != b.b[i])
            return 0;
    return 1;
}
@

<<function bnum>>=
int
bnum(Bits a)
{
    int i;
    long b;

    for(i=0; i<BITS; i++)
        if(b = a.b[i])
            return 32*i + bitno(b);
    diag(Z, "bad in bnum");
    return 0;
}
@

<<function blsh>>=
Bits
blsh(uint n)
{
    Bits c;

    c = zbits;
    c.b[n/32] = 1L << (n%32);
    return c;
}
@

<<function bset>>=
int
bset(Bits a, uint n)
{
    if(a.b[n/32] & (1L << (n%32)))
        return 1;
    return 0;
}
@


%-------------------------------------------------------------

<<cc/bits.c>>=
#include	"cc.h"

<<function bor>>

<<function band>>

<<function bany>>

<<function beq>>

<<function bnum>>

<<function blsh>>

<<function bset>>
@


\subsection*{[[cc/lex.c]]}

<<constant CPP>>=
#define	CPP	"/bin/cpp"
@

<<function main>>=
/*
 * known debug flags
 *	-a		acid declaration output
 *	-A		!B
 *	-B		non ANSI
 *	-d		print declarations
 *	-D name		define
 *	-F		format specification check
 *	-i		print initialization
 *	-I path		include
 *	-l		generate little-endian code
 *	-L		print every NAME symbol
 *	-M		constant multiplication
 *	-m		print add/sub/mul trees
 *	-n		print acid to file (%.c=%.acid) (with -a or -aa)
 *	-o file		output file
 *	-p		use standard cpp ANSI preprocessor (not on windows)
 *	-r		print registerization
 *	-s		print structure offsets (with -a or -aa)
 *	-S		print assembly
 *	-t		print type trees
 *	-V		enable void* conversion warnings
 *	-v		verbose printing
 *	-w		print warnings
 *	-X		abort on error
 *	-.		Inhibit search for includes in source directory
 */

void
main(int argc, char *argv[])
{
    char **defs, **np, *p;
    int nproc, nout, status, i, c, ndef, maxdef;

    memset(debug, 0, sizeof(debug));
    tinit();
    cinit();
    ginit();
    arginit();

    profileflg = 1;	/* #pragma can turn it off */
    tufield = simplet((1L<<tfield->etype) | BUNSIGNED);
    maxdef = 0;
    ndef = 0;
    outfile = 0;
    defs = nil;
    setinclude(".");
    ARGBEGIN {
    default:
        c = ARGC();
        if(c >= 0 && c < sizeof(debug))
            debug[c]++;
        break;

    case 'l':			/* for little-endian mips */
        if(thechar != 'v'){
            print("can only use -l with vc");
            errorexit();
        }
        thechar = '0';
        thestring = "spim";
        break;

    case 'o':
        outfile = ARGF();
        break;

    case 'D':
        p = ARGF();
        if(p) {
            if(ndef >= maxdef){
                maxdef += 50;
                np = alloc(maxdef * sizeof *np);
                if(defs != nil)
                    memmove(np, defs, (maxdef - 50) * sizeof *np);
                defs = np;
            }
            defs[ndef++] = p;
            dodefine(p);
        }
        break;

    case 'I':
        p = ARGF();
        if(p)
            setinclude(p);
        break;
    } ARGEND
    if(argc < 1 && outfile == 0) {
        print("usage: %cc [-options] files\n", thechar);
        errorexit();
    }
    if(argc > 1 && systemtype(Windows)){
        print("can't compile multiple files on windows\n");
        errorexit();
    }
    if(argc > 1 && !systemtype(Windows)) {
        nproc = 1;
        /*
         * if we're writing acid to standard output, don't compile
         * concurrently, to avoid interleaving output.
         */
        if(((!debug['a'] && !debug['Z']) || debug['n']) &&
            (p = getenv("NPROC")) != nil)
            nproc = atol(p);	/* */
        c = 0;
        nout = 0;
        for(;;) {
            while(nout < nproc && argc > 0) {
                i = myfork();
                if(i < 0) {
                    i = mywait(&status);
                    if(i < 0) {
                        print("cannot create a process\n");
                        errorexit();
                    }
                    if(status)
                        c++;
                    nout--;
                    continue;
                }
                if(i == 0) {
                    fprint(2, "%s:\n", *argv);
                    if (compile(*argv, defs, ndef))
                        errorexit();
                    exits(0);
                }
                nout++;
                argc--;
                argv++;
            }
            i = mywait(&status);
            if(i < 0) {
                if(c)
                    errorexit();
                exits(0);
            }
            if(status)
                c++;
            nout--;
        }
    }

    if(argc == 0)
        c = compile("stdin", defs, ndef);
    else
        c = compile(argv[0], defs, ndef);

    if(c)
        errorexit();
    exits(0);
}
@

<<function compile>>=
int
compile(char *file, char **defs, int ndef)
{
    char ofile[400], incfile[20];
    char *p, **av, opt[256];
    int i, c, fd[2];
    static int first = 1;

    strcpy(ofile, file);
    p = utfrrune(ofile, pathchar());
    if(p) {
        *p++ = 0;
        if(!debug['.'])
            include[0] = strdup(ofile);
    } else
        p = ofile;

    if(outfile == 0) {
        outfile = p;
        if(outfile) {
            if(p = utfrrune(outfile, '.'))
                if(p[1] == 'c' && p[2] == 0)
                    p[0] = 0;
            p = utfrune(outfile, 0);
            if(debug['a'] && debug['n'])
                strcat(p, ".acid");
            else if(debug['Z'] && debug['n'])
                strcat(p, "_pickle.c");
            else {
                p[0] = '.';
                p[1] = thechar;
                p[2] = 0;
            }
        } else
            outfile = "/dev/null";
    }

    if(p = getenv("INCLUDE")) {
        setinclude(p);
    } else {
        if(systemtype(Plan9)) {
            sprint(incfile, "/%s/include", thestring);
            setinclude(strdup(incfile));
            setinclude("/sys/include");
        }
    }
    if (first)
        Binit(&diagbuf, 1, OWRITE);
    /*
     * if we're writing acid to standard output, don't keep scratching
     * outbuf.
     */
    if((debug['a'] || debug['Z']) && !debug['n']) {
        if (first) {
            outfile = 0;
            Binit(&outbuf, dup(1, -1), OWRITE);
            dup(2, 1);
        }
    } else {
        c = mycreat(outfile, 0664);
        if(c < 0) {
            diag(Z, "cannot open %s - %r", outfile);
            outfile = 0;
            errorexit();
        }
        Binit(&outbuf, c, OWRITE);
    }
    newio();
    first = 0;

    /* Use an ANSI preprocessor */
    if(debug['p']) {
        if(systemtype(Windows)) {
            diag(Z, "-p option not supported on windows");
            errorexit();
        }
        if(myaccess(file) < 0) {
            diag(Z, "%s does not exist", file);
            errorexit();
        }
        if(mypipe(fd) < 0) {
            diag(Z, "pipe failed");
            errorexit();
        }
        switch(myfork()) {
        case -1:
            diag(Z, "fork failed");
            errorexit();
        case 0:
            close(fd[0]);
            mydup(fd[1], 1);
            close(fd[1]);
            av = alloc((3 + ndef + ninclude + 2) * sizeof *av);
            av[0] = CPP;
            i = 1;
            if(debug['.'])
                av[i++] = strdup("-.");
            /* 1999 ANSI C requires recognising // comments */
            av[i++] = strdup("-+");
            for(c = 0; c < ndef; c++) {
                sprint(opt, "-D%s", defs[c]);
                av[i++] = strdup(opt);
            }
            for(c = 0; c < ninclude; c++) {
                sprint(opt, "-I%s", include[c]);
                av[i++] = strdup(opt);
            }
            if(strcmp(file, "stdin") != 0)
                av[i++] = file;
            av[i] = 0;
            if(debug['p'] > 1) {
                for(c = 0; c < i; c++)
                    fprint(2, "%s ", av[c]);
                fprint(2, "\n");
            }
            myexec(av[0], av);
            fprint(2, "can't exec C preprocessor %s: %r\n", CPP);
            errorexit();
        default:
            close(fd[1]);
            newfile(file, fd[0]);
            break;
        }
    } else {
        if(strcmp(file, "stdin") == 0)
            newfile(file, 0);
        else
            newfile(file, -1);
    }
    yyparse();
    if(!debug['a'] && !debug['Z'])
        gclean();
    return nerrors;
}
@


<<function pushio>>=
void
pushio(void)
{
    Io *i;

    i = iostack;
    if(i == I) {
        yyerror("botch in pushio");
        errorexit();
    }
    i->p = fi.p;
    i->c = fi.c;
}
@

<<function newio>>=
void
newio(void)
{
    Io *i;
    static int pushdepth = 0;

    i = iofree;
    if(i == I) {
        pushdepth++;
        if(pushdepth > 1000) {
            yyerror("macro/io expansion too deep");
            errorexit();
        }
        i = alloc(sizeof(*i));
    } else
        iofree = i->link;
    i->c = 0;
    i->f = -1;
    ionext = i;
}
@

<<function newfile>>=
void
newfile(char *s, int f)
{
    Io *i;

    if(debug['e'])
        print("%L: %s\n", lineno, s);

    i = ionext;
    i->link = iostack;
    iostack = i;
    i->f = f;
    if(f < 0)
        i->f = open(s, 0);
    if(i->f < 0) {
        yyerror("%cc: %r: %s", thechar, s);
        errorexit();
    }
    fi.c = 0;
    linehist(s, 0);
}
@

<<function slookup>>=
Sym*
slookup(char *s)
{

    strcpy(symb, s);
    return lookup();
}
@

<<function lookup>>=
Sym*
lookup(void)
{
    Sym *s;
    ulong h;
    char *p;
    int c, n;

    h = 0;
    for(p=symb; *p;) {
        h = h * 3;
        h += *p++;
    }
    n = (p - symb) + 1;
    if((long)h < 0)
        h = ~h;
    h %= NHASH;
    c = symb[0];
    for(s = hash[h]; s != S; s = s->link) {
        if(s->name[0] != c)
            continue;
        if(strcmp(s->name, symb) == 0)
            return s;
    }
    s = alloc(sizeof(*s));
    s->name = alloc(n);
    memmove(s->name, symb, n);

    strcpy(s->name, symb);
    s->link = hash[h];
    hash[h] = s;
    syminit(s);

    return s;
}
@

<<function syminit>>=
void
syminit(Sym *s)
{
    s->lexical = LNAME;
    s->block = 0;
    s->offset = 0;
    s->type = T;
    s->suetag = T;
    s->class = CXXX;
    s->aused = 0;
    s->sig = SIGNONE;
}
@

<<constant EOF>>=
#define	EOF	(-1)
@

<<constant IGN>>=
#define	IGN	(-2)
@

<<constant ESC>>=
#define	ESC	(Runemask+1)		/* Rune flag: a literal byte */
@

<<function GETC>>=
#define	GETC()	((--fi.c < 0)? filbuf(): (*fi.p++ & 0xff))
@

<<enum _anon_ (cc/lex.c)>>=
enum
{
    Numdec		= 1<<0,
    Numlong		= 1<<1,
    Numuns		= 1<<2,
    Numvlong	= 1<<3,
    Numflt		= 1<<4,
};
@

<<function yylex>>=
long
yylex(void)
{
    vlong vv;
    long c, c1, t;
    char *cp;
    Rune rune;
    Sym *s;

    if(peekc != IGN) {
        c = peekc;
        peekc = IGN;
        goto l1;
    }
l0:
    c = GETC();

l1:
    if(c >= Runeself) {
        /*
         * extension --
         *	all multibyte runes are alpha
         */
        cp = symb;
        goto talph;
    }
    if(isspace(c)) {
        if(c == '\n')
            lineno++;
        goto l0;
    }
    if(isalpha(c)) {
        cp = symb;
        if(c != 'L')
            goto talph;
        *cp++ = c;
        c = GETC();
        if(c == '\'') {
            /* L'x' */
            c = escchar('\'', 1, 0);
            if(c == EOF)
                c = '\'';
            c1 = escchar('\'', 1, 0);
            if(c1 != EOF) {
                yyerror("missing '");
                peekc = c1;
            }
            yylval.vval = convvtox(c, TRUNE);
            return LUCONST;
        }
        if(c == '"') {
            goto caselq;
        }
        goto talph;
    }
    if(isdigit(c))
        goto tnum;
    switch(c)
    {

    case EOF:
        peekc = EOF;
        return -1;

    case '_':
        cp = symb;
        goto talph;

    case '#':
        domacro();
        goto l0;

    case '.':
        c1 = GETC();
        if(isdigit(c1)) {
            cp = symb;
            *cp++ = c;
            c = c1;
            c1 = 0;
            goto casedot;
        }
        break;

    case '"':
        strcpy(symb, "\"<string>\"");
        cp = alloc(0);
        c1 = 0;

        /* "..." */
        for(;;) {
            c = escchar('"', 0, 1);
            if(c == EOF)
                break;
            if(c & ESC) {
                cp = allocn(cp, c1, 1);
                cp[c1++] = c;
            } else {
                rune = c;
                c = runelen(rune);
                cp = allocn(cp, c1, c);
                runetochar(cp+c1, &rune);
                c1 += c;
            }
        }
        yylval.sval.l = c1;
        do {
            cp = allocn(cp, c1, 1);
            cp[c1++] = 0;
        } while(c1 & MAXALIGN);
        yylval.sval.s = cp;
        return LSTRING;

    caselq:
        /* L"..." */
        strcpy(symb, "\"L<string>\"");
        cp = alloc(0);
        c1 = 0;
        for(;;) {
            c = escchar('"', 1, 0);
            if(c == EOF)
                break;
            cp = allocn(cp, c1, sizeof(TRune));
            *(TRune*)(cp + c1) = c;
            c1 += sizeof(TRune);
        }
        yylval.sval.l = c1;
        do {
            cp = allocn(cp, c1, sizeof(TRune));
            *(TRune*)(cp + c1) = 0;
            c1 += sizeof(TRune);
        } while(c1 & MAXALIGN);
        yylval.sval.s = cp;
        return LLSTRING;

    case '\'':
        /* '.' */
        c = escchar('\'', 0, 0);
        if(c == EOF)
            c = '\'';
        c1 = escchar('\'', 0, 0);
        if(c1 != EOF) {
            yyerror("missing '");
            peekc = c1;
        }
        vv = c;
        yylval.vval = convvtox(vv, TUCHAR);
        if(yylval.vval != vv)
            yyerror("overflow in character constant: 0x%lx", c);
        else
        if(c & 0x80){
            nearln = lineno;
            warn(Z, "sign-extended character constant");
        }
        yylval.vval = convvtox(vv, TCHAR);
        return LCONST;

    case '/':
        c1 = GETC();
        if(c1 == '*') {
            for(;;) {
                c = getr();
                while(c == '*') {
                    c = getr();
                    if(c == '/')
                        goto l0;
                }
                if(c == EOF) {
                    yyerror("eof in comment");
                    errorexit();
                }
            }
        }
        if(c1 == '/') {
            for(;;) {
                c = getr();
                if(c == '\n')
                    goto l0;
                if(c == EOF) {
                    yyerror("eof in comment");
                    errorexit();
                }
            }
        }
        if(c1 == '=')
            return LDVE;
        break;

    case '*':
        c1 = GETC();
        if(c1 == '=')
            return LMLE;
        break;

    case '%':
        c1 = GETC();
        if(c1 == '=')
            return LMDE;
        break;

    case '+':
        c1 = GETC();
        if(c1 == '+')
            return LPP;
        if(c1 == '=')
            return LPE;
        break;

    case '-':
        c1 = GETC();
        if(c1 == '-')
            return LMM;
        if(c1 == '=')
            return LME;
        if(c1 == '>')
            return LMG;
        break;

    case '>':
        c1 = GETC();
        if(c1 == '>') {
            c = LRSH;
            c1 = GETC();
            if(c1 == '=')
                return LRSHE;
            break;
        }
        if(c1 == '=')
            return LGE;
        break;

    case '<':
        c1 = GETC();
        if(c1 == '<') {
            c = LLSH;
            c1 = GETC();
            if(c1 == '=')
                return LLSHE;
            break;
        }
        if(c1 == '=')
            return LLE;
        break;

    case '=':
        c1 = GETC();
        if(c1 == '=')
            return LEQ;
        break;

    case '!':
        c1 = GETC();
        if(c1 == '=')
            return LNE;
        break;

    case '&':
        c1 = GETC();
        if(c1 == '&')
            return LANDAND;
        if(c1 == '=')
            return LANDE;
        break;

    case '|':
        c1 = GETC();
        if(c1 == '|')
            return LOROR;
        if(c1 == '=')
            return LORE;
        break;

    case '^':
        c1 = GETC();
        if(c1 == '=')
            return LXORE;
        break;

    default:
        return c;
    }
    peekc = c1;
    return c;

talph:
    /*
     * cp is set to symb and some
     * prefix has been stored
     */
    for(;;) {
        if(c >= Runeself) {
            for(c1=0;;) {
                cp[c1++] = c;
                if(fullrune(cp, c1))
                    break;
                c = GETC();
            }
            cp += c1;
            c = GETC();
            continue;
        }
        if(!isalnum(c) && c != '_')
            break;
        *cp++ = c;
        c = GETC();
    }
    *cp = 0;
    if(debug['L'])
        print("%L: %s\n", lineno, symb);
    peekc = c;
    s = lookup();
    if(s->macro) {
        newio();
        cp = ionext->b;
        macexpand(s, cp);
        pushio();
        ionext->link = iostack;
        iostack = ionext;
        fi.p = cp;
        fi.c = strlen(cp);
        if(peekc != IGN) {
            cp[fi.c++] = peekc;
            cp[fi.c] = 0;
            peekc = IGN;
        }
        goto l0;
    }
    yylval.sym = s;
    if(s->class == CTYPEDEF || s->class == CTYPESTR)
        return LTYPE;
    return s->lexical;

tnum:
    c1 = 0;
    cp = symb;
    if(c != '0') {
        c1 |= Numdec;
        for(;;) {
            *cp++ = c;
            c = GETC();
            if(isdigit(c))
                continue;
            goto dc;
        }
    }
    *cp++ = c;
    c = GETC();
    if(c == 'x' || c == 'X')
        for(;;) {
            *cp++ = c;
            c = GETC();
            if(isdigit(c))
                continue;
            if(c >= 'a' && c <= 'f')
                continue;
            if(c >= 'A' && c <= 'F')
                continue;
            if(cp == symb+2)
                yyerror("malformed hex constant");
            goto ncu;
        }
    if(c < '0' || c > '7')
        goto dc;
    for(;;) {
        if(c >= '0' && c <= '7') {
            *cp++ = c;
            c = GETC();
            continue;
        }
        goto ncu;
    }

dc:
    if(c == '.')
        goto casedot;
    if(c == 'e' || c == 'E')
        goto casee;

ncu:
    if((c == 'U' || c == 'u') && !(c1 & Numuns)) {
        c = GETC();
        c1 |= Numuns;
        goto ncu;
    }
    if((c == 'L' || c == 'l') && !(c1 & Numvlong)) {
        c = GETC();
        if(c1 & Numlong)
            c1 |= Numvlong;
        c1 |= Numlong;
        goto ncu;
    }
    *cp = 0;
    peekc = c;
    if(mpatov(symb, &yylval.vval))
        yyerror("overflow in constant");

    vv = yylval.vval;
    if(c1 & Numvlong) {
        if((c1 & Numuns) || convvtox(vv, TVLONG) < 0) {
            c = LUVLCONST;
            t = TUVLONG;
            goto nret;
        }
        c = LVLCONST;
        t = TVLONG;
        goto nret;
    }
    if(c1 & Numlong) {
        if((c1 & Numuns) || convvtox(vv, TLONG) < 0) {
            c = LULCONST;
            t = TULONG;
            goto nret;
        }
        c = LLCONST;
        t = TLONG;
        goto nret;
    }
    if((c1 & Numuns) || convvtox(vv, TINT) < 0) {
        c = LUCONST;
        t = TUINT;
        goto nret;
    }
    c = LCONST;
    t = TINT;
    goto nret;

nret:
    yylval.vval = convvtox(vv, t);
    if(yylval.vval != vv){
        nearln = lineno;
        warn(Z, "truncated constant: %T %s", types[t], symb);
    }
    return c;

casedot:
    for(;;) {
        *cp++ = c;
        c = GETC();
        if(!isdigit(c))
            break;
    }
    if(c != 'e' && c != 'E')
        goto caseout;

casee:
    *cp++ = 'e';
    c = GETC();
    if(c == '+' || c == '-') {
        *cp++ = c;
        c = GETC();
    }
    if(!isdigit(c))
        yyerror("malformed fp constant exponent");
    while(isdigit(c)) {
        *cp++ = c;
        c = GETC();
    }

caseout:
    if(c == 'L' || c == 'l') {
        c = GETC();
        c1 |= Numlong;
    } else
    if(c == 'F' || c == 'f') {
        c = GETC();
        c1 |= Numflt;
    }
    *cp = 0;
    peekc = c;
    yylval.dval = strtod(symb, nil);
    if(isInf(yylval.dval, 1) || isInf(yylval.dval, -1)) {
        yyerror("overflow in float constant");
        yylval.dval = 0;
    }
    if(c1 & Numflt)
        return LFCONST;
    return LDCONST;
}
@

<<function mpatov>>=
/*
 * convert a string, s, to vlong in *v
 * return conversion overflow.
 * required syntax is [0[x]]d*
 */
int
mpatov(char *s, vlong *v)
{
    vlong n, nn;
    int c;

    n = 0;
    c = *s;
    if(c == '0')
        goto oct;
    while(c = *s++) {
        if(c >= '0' && c <= '9')
            nn = n*10 + c-'0';
        else
            goto bad;
        if(n < 0 && nn >= 0)
            goto bad;
        n = nn;
    }
    goto out;

oct:
    s++;
    c = *s;
    if(c == 'x' || c == 'X')
        goto hex;
    while(c = *s++) {
        if(c >= '0' || c <= '7')
            nn = n*8 + c-'0';
        else
            goto bad;
        if(n < 0 && nn >= 0)
            goto bad;
        n = nn;
    }
    goto out;

hex:
    s++;
    while(c = *s++) {
        if(c >= '0' && c <= '9')
            c += 0-'0';
        else
        if(c >= 'a' && c <= 'f')
            c += 10-'a';
        else
        if(c >= 'A' && c <= 'F')
            c += 10-'A';
        else
            goto bad;
        nn = n*16 + c;
        if(n < 0 && nn >= 0)
            goto bad;
        n = nn;
    }
out:
    *v = n;
    return 0;

bad:
    *v = ~0;
    return 1;
}
@

<<function getc>>=
int
getc(void)
{
    int c;

    if(peekc != IGN) {
        c = peekc;
        peekc = IGN;
    } else
        c = GETC();
    if(c == '\n')
        lineno++;
    if(c == EOF) {
        yyerror("End of file");
        errorexit();
    }
    return c;
}
@

<<function getr>>=
long
getr(void)
{
    int c, i;
    char str[UTFmax+1];
    Rune rune;


    c = getc();
    if(c < Runeself)
        return c;
    i = 0;
    str[i++] = c;

loop:
    c = getc();
    str[i++] = c;
    if(!fullrune(str, i))
        goto loop;
    c = chartorune(&rune, str);
    if(rune == Runeerror && c == 1) {
        nearln = lineno;
        diag(Z, "illegal rune in string");
        for(c=0; c<i; c++)
            print(" %.2x", *(uchar*)(str+c));
        print("\n");
    }
    return rune;
}
@

<<function getnsc>>=
int
getnsc(void)
{
    int c;

    if(peekc != IGN) {
        c = peekc;
        peekc = IGN;
    } else
        c = GETC();
    for(;;) {
        if(c >= Runeself || !isspace(c))
            return c;
        if(c == '\n') {
            lineno++;
            return c;
        }
        c = GETC();
    }
}
@

<<function unget>>=
void
unget(int c)
{

    peekc = c;
    if(c == '\n')
        lineno--;
}
@

<<function escchar>>=
long
escchar(long e, int longflg, int escflg)
{
    long c, l;
    int i;

loop:
    c = getr();
    if(c == '\n') {
        yyerror("newline in string");
        return EOF;
    }
    if(c != '\\') {
        if(c == e)
            c = EOF;
        return c;
    }
    c = getr();
    if(c == 'x') {
        /*
         * note this is not ansi,
         * supposed to only accept 2 hex
         */
        i = 2;
        if(longflg)
            i = 6;
        l = 0;
        for(; i>0; i--) {
            c = getc();
            if(c >= '0' && c <= '9') {
                l = l*16 + c-'0';
                continue;
            }
            if(c >= 'a' && c <= 'f') {
                l = l*16 + c-'a' + 10;
                continue;
            }
            if(c >= 'A' && c <= 'F') {
                l = l*16 + c-'A' + 10;
                continue;
            }
            unget(c);
            break;
        }
        if(escflg)
            l |= ESC;
        return l;
    }
    if(c >= '0' && c <= '7') {
        /*
         * note this is not ansi,
         * supposed to only accept 3 oct
         */
        i = 2;
        if(longflg)
            i = 8;
        l = c - '0';
        for(; i>0; i--) {
            c = getc();
            if(c >= '0' && c <= '7') {
                l = l*8 + c-'0';
                continue;
            }
            unget(c);
        }
        if(escflg)
            l |= ESC;
        return l;
    }
    switch(c)
    {
    case '\n':	goto loop;
    case 'n':	return '\n';
    case 't':	return '\t';
    case 'b':	return '\b';
    case 'r':	return '\r';
    case 'f':	return '\f';
    case 'a':	return '\a';
    case 'v':	return '\v';
    }
    return c;
}
@

<<global itab>>=
struct
{
    char	*name;
    ushort	lexical;
    ushort	type;
} itab[] =
{
    "auto",		LAUTO,		0,
    "break",	LBREAK,		0,
    "case",		LCASE,		0,
    "char",		LCHAR,		TCHAR,
    "const",	LCONSTNT,	0,
    "continue",	LCONTINUE,	0,
    "default",	LDEFAULT,	0,
    "do",		LDO,		0,
    "double",	LDOUBLE,	TDOUBLE,
    "else",		LELSE,		0,
    "enum",		LENUM,		0,
    "extern",	LEXTERN,	0,
    "float",	LFLOAT,		TFLOAT,
    "for",		LFOR,		0,
    "goto",		LGOTO,		0,
    "if",		LIF,		0,
    "inline",	LINLINE,	0,
    "int",		LINT,		TINT,
    "long",		LLONG,		TLONG,
    "register",	LREGISTER,	0,
    "restrict",	LRESTRICT,	0,
    "return",	LRETURN,	0,
    "SET",		LSET,		0,
    "short",	LSHORT,		TSHORT,
    "signed",	LSIGNED,	0,
    "signof",	LSIGNOF,	0,
    "sizeof",	LSIZEOF,	0,
    "static",	LSTATIC,	0,
    "struct",	LSTRUCT,	0,
    "switch",	LSWITCH,	0,
    "typedef",	LTYPEDEF,	0,
    "typestr",	LTYPESTR,	0,
    "union",	LUNION,		0,
    "unsigned",	LUNSIGNED,	0,
    "USED",		LUSED,		0,
    "void",		LVOID,		TVOID,
    "volatile",	LVOLATILE,	0,
    "while",	LWHILE,		0,
    0
};
@

<<function cinit>>=
void
cinit(void)
{
    Sym *s;
    int i;
    Type *t;

    nerrors = 0;
    lineno = 1;
    iostack = I;
    iofree = I;
    peekc = IGN;
    nhunk = 0;

    types[TXXX] = T;
    types[TCHAR] = typ(TCHAR, T);
    types[TUCHAR] = typ(TUCHAR, T);
    types[TSHORT] = typ(TSHORT, T);
    types[TUSHORT] = typ(TUSHORT, T);
    types[TINT] = typ(TINT, T);
    types[TUINT] = typ(TUINT, T);
    types[TLONG] = typ(TLONG, T);
    types[TULONG] = typ(TULONG, T);
    types[TVLONG] = typ(TVLONG, T);
    types[TUVLONG] = typ(TUVLONG, T);
    types[TFLOAT] = typ(TFLOAT, T);
    types[TDOUBLE] = typ(TDOUBLE, T);
    types[TVOID] = typ(TVOID, T);
    types[TENUM] = typ(TENUM, T);
    types[TFUNC] = typ(TFUNC, types[TINT]);
    types[TIND] = typ(TIND, types[TVOID]);

    for(i=0; i<NHASH; i++)
        hash[i] = S;
    for(i=0; itab[i].name; i++) {
        s = slookup(itab[i].name);
        s->lexical = itab[i].lexical;
        if(itab[i].type != 0)
            s->type = types[itab[i].type];
    }
    blockno = 0;
    autobn = 0;
    autoffset = 0;

    t = typ(TARRAY, types[TCHAR]);
    t->width = 0;
    symstring = slookup(".string");
    symstring->class = CSTATIC;
    symstring->type = t;

    t = typ(TARRAY, types[TCHAR]);
    t->width = 0;

    nodproto = new(OPROTO, Z, Z);
    dclstack = D;

    pathname = allocn(pathname, 0, 100);
    if(mygetwd(pathname, 99) == 0) {
        pathname = allocn(pathname, 100, 900);
        if(mygetwd(pathname, 999) == 0)
            strcpy(pathname, "/???");
    }

    fmtinstall('O', Oconv);
    fmtinstall('T', Tconv);
    fmtinstall('F', FNconv);
    fmtinstall('L', Lconv);
    fmtinstall('Q', Qconv);
    fmtinstall('|', VBconv);
}
@

<<function filbuf>>=
int
filbuf(void)
{
    Io *i;

loop:
    i = iostack;
    if(i == I)
        return EOF;
    if(i->f < 0)
        goto pop;
    fi.c = read(i->f, i->b, BUFSIZ) - 1;
    if(fi.c < 0) {
        close(i->f);
        linehist(0, 0);
        goto pop;
    }
    fi.p = i->b + 1;
    return i->b[0] & 0xff;

pop:
    iostack = i->link;
    i->link = iofree;
    iofree = i;
    i = iostack;
    if(i == I)
        return EOF;
    fi.p = i->p;
    fi.c = i->c;
    if(--fi.c < 0)
        goto loop;
    return *fi.p++ & 0xff;
}
@

<<function Oconv>>=
int
Oconv(Fmt *fp)
{
    int a;

    a = va_arg(fp->args, int);
    if(a < OXXX || a > OEND)
        return fmtprint(fp, "***badO %d***", a);

    return fmtstrcpy(fp, onames[a]);
}
@

<<struct Atab>>=
struct Atab
    {
        Hist*	incl;	/* start of this include file */
        long	idel;	/* delta line number to apply to include */
        Hist*	line;	/* start of this #line directive */
        long	ldel;	/* delta line number to apply to #line */
};
@

<<function Lconv>>=
int
Lconv(Fmt *fp)
{
    char str[STRINGSZ], s[STRINGSZ];
    Hist *h;
    long l, d;
    int i, n;
    struct Atab  a[HISTSZ];

    l = va_arg(fp->args, long);
    n = 0;
    for(h = hist; h != H; h = h->link) {
        if(l < h->line)
            break;
        if(h->name) {
            if(h->offset != 0) {		/* #line directive, not #pragma */
                if(n > 0 && n < HISTSZ && h->offset >= 0) {
                    a[n-1].line = h;
                    a[n-1].ldel = h->line - h->offset + 1;
                }
            } else {
                if(n < HISTSZ) {	/* beginning of file */
                    a[n].incl = h;
                    a[n].idel = h->line;
                    a[n].line = 0;
                }
                n++;
            }
            continue;
        }
        n--;
        if(n > 0 && n < HISTSZ) {
            d = h->line - a[n].incl->line;
            a[n-1].ldel += d;
            a[n-1].idel += d;
        }
    }
    if(n > HISTSZ)
        n = HISTSZ;
    str[0] = 0;
    for(i=n-1; i>=0; i--) {
        if(i != n-1) {
            if(fp->flags & ~(FmtWidth|FmtPrec))	/* BUG ROB - was f3 */
                break;
            strcat(str, " ");
        }
        if(a[i].line)
            snprint(s, STRINGSZ, "%s:%ld[%s:%ld]",
                a[i].line->name, l-a[i].ldel+1,
                a[i].incl->name, l-a[i].idel+1);
        else
            snprint(s, STRINGSZ, "%s:%ld",
                a[i].incl->name, l-a[i].idel+1);
        if(strlen(s)+strlen(str) >= STRINGSZ-10)
            break;
        strcat(str, s);
        l = a[i].incl->line - 1;	/* now print out start of this file */
    }
    if(n == 0)
        strcat(str, "<eof>");
    return fmtstrcpy(fp, str);
}
@

<<function Tconv>>=
int
Tconv(Fmt *fp)
{
    char str[STRINGSZ+20], s[STRINGSZ+20];
    Type *t, *t1;
    int et;
    long n;

    str[0] = 0;
    for(t = va_arg(fp->args, Type*); t != T; t = t->link) {
        et = t->etype;
        if(str[0])
            strcat(str, " ");
        if(t->garb&~GINCOMPLETE) {
            sprint(s, "%s ", gnames[t->garb&~GINCOMPLETE]);
            if(strlen(str) + strlen(s) < STRINGSZ)
                strcat(str, s);
        }
        sprint(s, "%s", tnames[et]);
        if(strlen(str) + strlen(s) < STRINGSZ)
            strcat(str, s);
        if(et == TFUNC && (t1 = t->down)) {
            sprint(s, "(%T", t1);
            if(strlen(str) + strlen(s) < STRINGSZ)
                strcat(str, s);
            while(t1 = t1->down) {
                sprint(s, ", %T", t1);
                if(strlen(str) + strlen(s) < STRINGSZ)
                    strcat(str, s);
            }
            if(strlen(str) + strlen(s) < STRINGSZ)
                strcat(str, ")");
        }
        if(et == TARRAY) {
            n = t->width;
            if(t->link && t->link->width)
                n /= t->link->width;
            sprint(s, "[%ld]", n);
            if(strlen(str) + strlen(s) < STRINGSZ)
                strcat(str, s);
        }
        if(t->nbits) {
            sprint(s, " %d:%d", t->shift, t->nbits);
            if(strlen(str) + strlen(s) < STRINGSZ)
                strcat(str, s);
        }
        if(typesu[et]) {
            if(t->tag) {
                strcat(str, " ");
                if(strlen(str) + strlen(t->tag->name) < STRINGSZ)
                    strcat(str, t->tag->name);
            } else
                strcat(str, " {}");
            break;
        }
    }
    return fmtstrcpy(fp, str);
}
@

<<function FNconv>>=
int
FNconv(Fmt *fp)
{
    char *str;
    Node *n;

    n = va_arg(fp->args, Node*);
    str = "<indirect>";
    if(n != Z && (n->op == ONAME || n->op == ODOT || n->op == OELEM))
        str = n->sym->name;
    return fmtstrcpy(fp, str);
}
@

<<function Qconv>>=
int
Qconv(Fmt *fp)
{
    char str[STRINGSZ+20], *s;
    long b;
    int i;

    str[0] = 0;
    for(b = va_arg(fp->args, long); b;) {
        i = bitno(b);
        if(str[0])
            strcat(str, " ");
        s = qnames[i];
        if(strlen(str) + strlen(s) >= STRINGSZ)
            break;
        strcat(str, s);
        b &= ~(1L << i);
    }
    return fmtstrcpy(fp, str);
}
@

<<function VBconv>>=
int
VBconv(Fmt *fp)
{
    char str[STRINGSZ];
    int i, n, t, pc;

    n = va_arg(fp->args, int);
    pc = 0;	/* BUG: was printcol */
    i = 0;
    while(pc < n) {
        t = (pc+4) & ~3;
        if(t <= n) {
            str[i++] = '\t';
            pc = t;
            continue;
        }
        str[i++] = ' ';
        pc++;
    }
    str[i] = 0;

    return fmtstrcpy(fp, str);
}
@


<<function setinclude>>=
void
setinclude(char *p)
{
    int i;
    char *e, **np;

    while(*p != 0) {
        e = strchr(p, ' ');
        if(e != 0)
            *e = '\0';

        for(i=0; i < ninclude; i++)
            if(strcmp(p, include[i]) == 0)
                break;

        if(i >= ninclude){
            if(i >= maxinclude){
                maxinclude += 20;
                np = alloc(maxinclude * sizeof *np);
                if(include != nil)
                    memmove(np, include, (maxinclude - 20) * sizeof *np);
                include = np;
            }
            include[ninclude++] = p;
        }

        if(e == 0)
            break;
        p = e+1;
    }
}
@


%-------------------------------------------------------------

<<cc/lex.c>>=
#include	"cc.h"
#include	"y.tab.h"

#ifndef	CPP
<<constant CPP>>
#endif

<<function main>>

<<function compile>>

<<function pushio>>

<<function newio>>

<<function newfile>>

<<function slookup>>

<<function lookup>>

<<function syminit>>

<<constant EOF>>
<<constant IGN>>
<<constant ESC>>
<<function GETC>>

<<enum _anon_ (cc/lex.c)>>

<<function yylex>>

<<function mpatov>>

<<function getc>>

<<function getr>>

<<function getnsc>>

<<function unget>>

<<function escchar>>

<<global itab>>

<<function cinit>>

<<function filbuf>>

<<function Oconv>>

<<struct Atab>>

<<function Lconv>>

<<function Tconv>>

<<function FNconv>>

<<function Qconv>>

<<function VBconv>>

<<function setinclude>>
@


\subsection*{[[cc/compat.c]]}

<<function malloc>>=
/*
 * fake mallocs
 */
void*
malloc(ulong n)
{
    return alloc(n);
}
@

<<function calloc>>=
void*
calloc(ulong m, ulong n)
{
    return alloc(m*n);
}
@

<<function realloc>>=
void*
realloc(void*, ulong)
{
    fprint(2, "realloc called\n");
    abort();
    return 0;
}
@

<<function free>>=
void
free(void*)
{
}
@

<<function mallocz>>=
/* needed when profiling */
void*
mallocz(ulong size, int clr)
{
    void *v;

    v = alloc(size);
    if(clr && v != nil)
        memset(v, 0, size);
    return v;
}
@

<<function setmalloctag>>=
void
setmalloctag(void*, ulong)
{
}
@


%-------------------------------------------------------------

<<cc/compat.c>>=
#include	"cc.h"

//#include	"compat"
//TODO copy paste with aa/, maybe could factorize with another lib?
//

int
myaccess(char *f)
{
 return access(f, AEXIST);
}

void*
mysbrk(ulong size)
{
 return sbrk(size);
}

int
mycreat(char *n, int p)
{

 return create(n, 1, p);
}

int
mywait(int *s)
{
 int p;
 Waitmsg *w;

 if((w = wait()) == nil)
  return -1;
 else{
  p = w->pid;
  *s = 0;
  if(w->msg[0])
   *s = 1;
  free(w);
  return p;
 }
}

int
mydup(int f1, int f2)
{
 return dup(f1,f2);
}

int
mypipe(int *fd)
{
 return pipe(fd);
}

int
systemtype(int sys)
{
 return sys & Plan9;
}

int
pathchar(void)
{
 return '/';
}

char*
mygetwd(char *path, int len)
{
 return getwd(path, len);
}

int
myexec(char *path, char *argv[])
{
 return exec(path, argv);
}

int
myfork(void)
{
 return fork();
}



<<function malloc>>

<<function calloc>>

<<function realloc>>

<<function free>>

<<function mallocz>>

<<function setmalloctag>>
@


\subsection*{[[cc/acid.c]]}

<<global kwd>>=
static char *kwd[] =
{
    "$adt", "$aggr", "$append", "$builtin", "$complex", "$defn",
    "$delete", "$do", "$else", "$eval", "$head", "$if",
    "$local", "$loop", "$return", "$tail", "$then",
    "$union", "$whatis", "$while",
};
@

<<function amap>>=
char*
amap(char *s)
{
    int i, bot, top, new;

    bot = 0;
    top = bot + nelem(kwd) - 1;
    while(bot <= top){
        new = bot + (top - bot)/2;
        i = strcmp(kwd[new]+1, s);
        if(i == 0)
            return kwd[new];

        if(i < 0)
            bot = new + 1;
        else
            top = new - 1;
    }
    return s;
}
@

<<function acidsue>>=
Sym*
acidsue(Type *t)
{
    int h;
    Sym *s;

    if(t != T)
    for(h=0; h<nelem(hash); h++)
        for(s = hash[h]; s != S; s = s->link)
            if(s->suetag && s->suetag->link == t)
                return s;
    return 0;
}
@

<<function acidfun>>=
Sym*
acidfun(Type *t)
{
    int h;
    Sym *s;

    for(h=0; h<nelem(hash); h++)
        for(s = hash[h]; s != S; s = s->link)
            if(s->type == t)
                return s;
    return 0;
}
@

<<global acidchar>>=
char	acidchar[NTYPE];
@

<<global acidcinit>>=
Init	acidcinit[] =
{
    TCHAR,		'C',	0,
    TUCHAR,		'b',	0,
    TSHORT,		'd',	0,
    TUSHORT,	'u',	0,
    TLONG,		'D',	0,
    TULONG,		'U',	0,
    TVLONG,		'V',	0,
    TUVLONG,	'W',	0,
    TFLOAT,		'f',	0,
    TDOUBLE,	'F',	0,
    TARRAY,		'a',	0,
    TIND,		'X',	0,
    -1,		0,	0,
};
@

<<function acidinit>>=
static void
acidinit(void)
{
    Init *p;

    for(p=acidcinit; p->code >= 0; p++)
        acidchar[p->code] = p->value;

    acidchar[TINT] = acidchar[TLONG];
    acidchar[TUINT] = acidchar[TULONG];
    if(types[TINT]->width != types[TLONG]->width) {
        acidchar[TINT] = acidchar[TSHORT];
        acidchar[TUINT] = acidchar[TUSHORT];
        if(types[TINT]->width != types[TSHORT]->width)
            warn(Z, "acidmember int not long or short");
    }
    if(types[TIND]->width == types[TUVLONG]->width)
        acidchar[TIND] = 'Y';
    
}
@

<<function acidmember>>=
void
acidmember(Type *t, long off, int flag)
{
    Sym *s, *s1;
    Type *l;
    static int acidcharinit = 0;

    if(acidcharinit == 0) {
        acidinit();
        acidcharinit = 1;
    }
    s = t->sym;
    switch(t->etype) {
    default:
        Bprint(&outbuf, "	T%d\n", t->etype);
        break;

    case TIND:
        if(s == S)
            break;
        if(flag) {
            for(l=t; l->etype==TIND; l=l->link)
                ;
            if(typesu[l->etype]) {
                s1 = acidsue(l->link);
                if(s1 != S) {
                    Bprint(&outbuf, "	'A' %s %ld %s;\n",
                        amap(s1->name),
                        t->offset+off, amap(s->name));
                    break;
                }
            }
        } else {
            Bprint(&outbuf,
                "\tprint(\"\t%s\t\", addr.%s\\X, \"\\n\");\n",
                amap(s->name), amap(s->name));
            break;
        }

    case TINT:
    case TUINT:
    case TCHAR:
    case TUCHAR:
    case TSHORT:
    case TUSHORT:
    case TLONG:
    case TULONG:
    case TVLONG:
    case TUVLONG:
    case TFLOAT:
    case TDOUBLE:
    case TARRAY:
        if(s == S)
            break;
        if(flag) {
            Bprint(&outbuf, "	'%c' %ld %s;\n",
            acidchar[t->etype], t->offset+off, amap(s->name));
        } else {
            Bprint(&outbuf, "\tprint(\"\t%s\t\", addr.%s, \"\\n\");\n",
                amap(s->name), amap(s->name));
        }
        break;

    case TSTRUCT:
    case TUNION:
        s1 = acidsue(t->link);
        if(s1 == S)
            break;
        if(flag) {
            if(s == S) {
                Bprint(&outbuf, "	{\n");
                for(l = t->link; l != T; l = l->down)
                    acidmember(l, t->offset+off, flag);
                Bprint(&outbuf, "	};\n");
            } else {
                Bprint(&outbuf, "	%s %ld %s;\n",
                    amap(s1->name),
                    t->offset+off, amap(s->name));
            }
        } else {
            if(s != S) {
                Bprint(&outbuf, "\tprint(\"%s %s {\\n\");\n",
                    amap(s1->name), amap(s->name));
                Bprint(&outbuf, "\t%s(addr.%s);\n",
                    amap(s1->name), amap(s->name));
                Bprint(&outbuf, "\tprint(\"}\\n\");\n");
            } else {
                Bprint(&outbuf, "\tprint(\"%s {\\n\");\n",
                    amap(s1->name));
                Bprint(&outbuf, "\t\t%s(addr+%ld);\n",
                    amap(s1->name), t->offset+off);
                Bprint(&outbuf, "\tprint(\"}\\n\");\n");
            }
        }
        break;
    }
}
@

<<function acidtype>>=
void
acidtype(Type *t)
{
    Sym *s;
    Type *l;
    Io *i;
    int n;
    char *an;

    if(!debug['a'])
        return;
    if(debug['a'] > 1) {
        n = 0;
        for(i=iostack; i; i=i->link)
            n++;
        if(n > 1)
            return;
    }
    s = acidsue(t->link);
    if(s == S)
        return;
    switch(t->etype) {
    default:
        Bprint(&outbuf, "T%d\n", t->etype);
        return;

    case TUNION:
    case TSTRUCT:
        if(debug['s'])
            goto asmstr;
        an = amap(s->name);
        Bprint(&outbuf, "sizeof%s = %ld;\n", an, t->width);
        Bprint(&outbuf, "aggr %s\n{\n", an);
        for(l = t->link; l != T; l = l->down)
            acidmember(l, 0, 1);
        Bprint(&outbuf, "};\n\n");

        Bprint(&outbuf, "defn\n%s(addr) {\n\tcomplex %s addr;\n", an, an);
        for(l = t->link; l != T; l = l->down)
            acidmember(l, 0, 0);
        Bprint(&outbuf, "};\n\n");
        break;
    asmstr:
        if(s == S)
            break;
        for(l = t->link; l != T; l = l->down)
            if(l->sym != S)
                Bprint(&outbuf, "#define\t%s.%s\t%ld\n",
                    s->name,
                    l->sym->name,
                    l->offset);
        break;
    }
}
@

<<function acidvar>>=
void
acidvar(Sym *s)
{
    int n;
    Io *i;
    Type *t;
    Sym *s1, *s2;

    if(!debug['a'] || debug['s'])
        return;
    if(debug['a'] > 1) {
        n = 0;
        for(i=iostack; i; i=i->link)
            n++;
        if(n > 1)
            return;
    }
    t = s->type;
    while(t && t->etype == TIND)
        t = t->link;
    if(t == T)
        return;
    if(t->etype == TENUM) {
        Bprint(&outbuf, "%s = ", amap(s->name));
        if(!typefd[t->etype])
            Bprint(&outbuf, "%lld;\n", s->vconst);
        else
            Bprint(&outbuf, "%f\n;", s->fconst);
        return;
    }
    if(!typesu[t->etype])
        return;
    s1 = acidsue(t->link);
    if(s1 == S)
        return;
    switch(s->class) {
    case CAUTO:
    case CPARAM:
        s2 = acidfun(thisfn);
        if(s2)
            Bprint(&outbuf, "complex %s %s:%s;\n",
                amap(s1->name), amap(s2->name), amap(s->name));
        break;
    
    case CSTATIC:
    case CEXTERN:
    case CGLOBL:
    case CLOCAL:
        Bprint(&outbuf, "complex %s %s;\n",
            amap(s1->name), amap(s->name));
        break;
    }
}
@


%-------------------------------------------------------------

<<cc/acid.c>>=
#include "cc.h"

<<global kwd>>

<<function amap>>

<<function acidsue>>

<<function acidfun>>

<<global acidchar>>
<<global acidcinit>>

<<function acidinit>>

<<function acidmember>>

<<function acidtype>>

<<function acidvar>>
@


\subsection*{[[cc/pickle.c]]}

<<global kwd (cc/pickle.c)>>=
static char *kwd[] =
{
    "$adt", "$aggr", "$append", "$complex", "$defn",
    "$delete", "$do", "$else", "$eval", "$head", "$if",
    "$local", "$loop", "$return", "$tail", "$then",
    "$union", "$whatis", "$while",
};
@
%$

<<global picklestr>>=
static char picklestr[] = "\tpickle(s, un, ";
@

<<function pmap>>=
static char*
pmap(char *s)
{
    int i, bot, top, new;

    bot = 0;
    top = bot + nelem(kwd) - 1;
    while(bot <= top){
        new = bot + (top - bot)/2;
        i = strcmp(kwd[new]+1, s);
        if(i == 0)
            return kwd[new];

        if(i < 0)
            bot = new + 1;
        else
            top = new - 1;
    }
    return s;
}
@

<<function picklesue>>=
Sym*
picklesue(Type *t)
{
    int h;
    Sym *s;

    if(t != T)
    for(h=0; h<nelem(hash); h++)
        for(s = hash[h]; s != S; s = s->link)
            if(s->suetag && s->suetag->link == t)
                return s;
    return 0;
}
@

<<function picklefun>>=
Sym*
picklefun(Type *t)
{
    int h;
    Sym *s;

    for(h=0; h<nelem(hash); h++)
        for(s = hash[h]; s != S; s = s->link)
            if(s->type == t)
                return s;
    return 0;
}
@

<<global picklechar>>=
char	picklechar[NTYPE];
@

<<global picklecinit>>=
Init	picklecinit[] =
{
    TCHAR,		'C',	0,
    TUCHAR,		'b',	0,
    TSHORT,		'd',	0,
    TUSHORT,		'u',	0,
    TLONG,		'D',	0,
    TULONG,		'U',	0,
    TVLONG,		'V',	0,
    TUVLONG,	'W',	0,
    TFLOAT,		'f',	0,
    TDOUBLE,		'F',	0,
    TARRAY,		'a',	0,
    TIND,		'X',	0,
    -1,		0,	0,
};
@

<<function pickleinit>>=
static void
pickleinit(void)
{
    Init *p;

    for(p=picklecinit; p->code >= 0; p++)
        picklechar[p->code] = p->value;

    picklechar[TINT] = picklechar[TLONG];
    picklechar[TUINT] = picklechar[TULONG];
    if(types[TINT]->width != types[TLONG]->width) {
        picklechar[TINT] = picklechar[TSHORT];
        picklechar[TUINT] = picklechar[TUSHORT];
        if(types[TINT]->width != types[TSHORT]->width)
            warn(Z, "picklemember int not long or short");
    }
    
}
@

<<function picklemember>>=
void
picklemember(Type *t, long off)
{
    Sym *s, *s1;
    static int picklecharinit = 0;

    if(picklecharinit == 0) {
        pickleinit();
        picklecharinit = 1;
    }
    s = t->sym;
    switch(t->etype) {
    default:
        Bprint(&outbuf, "	T%d\n", t->etype);
        break;

    case TIND:
        if(s == S)
            Bprint(&outbuf,
                "%s\"p\", (char*)addr+%ld+_i*%ld);\n",
                picklestr, t->offset+off, t->width);
        else
            Bprint(&outbuf,
                "%s\"p\", &addr->%s);\n",
                picklestr, pmap(s->name));
        break;

    case TINT:
    case TUINT:
    case TCHAR:
    case TUCHAR:
    case TSHORT:
    case TUSHORT:
    case TLONG:
    case TULONG:
    case TVLONG:
    case TUVLONG:
    case TFLOAT:
    case TDOUBLE:
        if(s == S)
            Bprint(&outbuf, "%s\"%c\", (char*)addr+%ld+_i*%ld);\n",
                picklestr, picklechar[t->etype], t->offset+off, t->width);
        else
            Bprint(&outbuf, "%s\"%c\", &addr->%s);\n",
                picklestr, picklechar[t->etype], pmap(s->name));
        break;
    case TARRAY:
        Bprint(&outbuf, "\tfor(_i = 0; _i < %ld; _i++) {\n\t",
            t->width/t->link->width);
        picklemember(t->link, t->offset+off);
        Bprint(&outbuf, "\t}\n\t_i = 0;\n\tUSED(_i);\n");
        break;

    case TSTRUCT:
    case TUNION:
        s1 = picklesue(t->link);
        if(s1 == S)
            break;
        if(s == S) {
            Bprint(&outbuf, "\tpickle_%s(s, un, (%s*)((char*)addr+%ld+_i*%ld));\n",
                pmap(s1->name), pmap(s1->name), t->offset+off, t->width);
        } else {
            Bprint(&outbuf, "\tpickle_%s(s, un, &addr->%s);\n",
                pmap(s1->name), pmap(s->name));
        }
        break;
    }
}
@

<<function pickletype>>=
void
pickletype(Type *t)
{
    Sym *s;
    Type *l;
    Io *i;
    int n;
    char *an;

    if(!debug['P'])
        return;
    if(debug['P'] > 1) {
        n = 0;
        for(i=iostack; i; i=i->link)
            n++;
        if(n > 1)
            return;
    }
    s = picklesue(t->link);
    if(s == S)
        return;
    switch(t->etype) {
    default:
        Bprint(&outbuf, "T%d\n", t->etype);
        return;

    case TUNION:
    case TSTRUCT:
        if(debug['s'])
            goto asmstr;
        an = pmap(s->name);

        Bprint(&outbuf, "void\npickle_%s(void *s, int un, %s *addr)\n{\n\tint _i = 0;\n\n\tUSED(_i);\n", an, an);
        for(l = t->link; l != T; l = l->down)
            picklemember(l, 0);
        Bprint(&outbuf, "}\n\n");
        break;
    asmstr:
        if(s == S)
            break;
        for(l = t->link; l != T; l = l->down)
            if(l->sym != S)
                Bprint(&outbuf, "#define\t%s.%s\t%ld\n",
                    s->name,
                    l->sym->name,
                    l->offset);
        break;
    }
}
@

<<function picklevar>>=
void
picklevar(Sym *s)
{
    int n;
    Io *i;
    Type *t;
    Sym *s1, *s2;

    if(!debug['P'] || debug['s'])
        return;
    if(debug['P'] > 1) {
        n = 0;
        for(i=iostack; i; i=i->link)
            n++;
        if(n > 1)
            return;
    }
    t = s->type;
    while(t && t->etype == TIND)
        t = t->link;
    if(t == T)
        return;
    if(t->etype == TENUM) {
        Bprint(&outbuf, "%s = ", pmap(s->name));
        if(!typefd[t->etype])
            Bprint(&outbuf, "%lld;\n", s->vconst);
        else
            Bprint(&outbuf, "%f\n;", s->fconst);
        return;
    }
    if(!typesu[t->etype])
        return;
    s1 = picklesue(t->link);
    if(s1 == S)
        return;
    switch(s->class) {
    case CAUTO:
    case CPARAM:
        s2 = picklefun(thisfn);
        if(s2)
            Bprint(&outbuf, "complex %s %s:%s;\n",
                pmap(s1->name), pmap(s2->name), pmap(s->name));
        break;
    
    case CSTATIC:
    case CEXTERN:
    case CGLOBL:
    case CLOCAL:
        Bprint(&outbuf, "complex %s %s;\n",
            pmap(s1->name), pmap(s->name));
        break;
    }
}
@


%-------------------------------------------------------------

<<cc/pickle.c>>=
#include "cc.h"

<<global kwd (cc/pickle.c)>>
<<global picklestr>>

<<function pmap>>

<<function picklesue>>

<<function picklefun>>

<<global picklechar>>
<<global picklecinit>>

<<function pickleinit>>

<<function picklemember>>

<<function pickletype>>

<<function picklevar>>
@


\subsection*{[[cc/com64.c]]}

<<constant FNX>>=
/*
 * this is machine dependent, but it is totally
 * common on all of the 64-bit symulating machines.
 */

#define	FNX	100	/* botch -- redefinition */
@

<<global nodaddv>>=
Node*	nodaddv;
@

<<global nodsubv>>=
Node*	nodsubv;
@

<<global nodmulv>>=
Node*	nodmulv;
@

<<global noddivv>>=
Node*	noddivv;
@

<<global noddivvu>>=
Node*	noddivvu;
@

<<global nodmodv>>=
Node*	nodmodv;
@

<<global nodmodvu>>=
Node*	nodmodvu;
@

<<global nodlshv>>=
Node*	nodlshv;
@

<<global nodrshav>>=
Node*	nodrshav;
@

<<global nodrshlv>>=
Node*	nodrshlv;
@

<<global nodandv>>=
Node*	nodandv;
@

<<global nodorv>>=
Node*	nodorv;
@

<<global nodxorv>>=
Node*	nodxorv;
@

<<global nodnegv>>=
Node*	nodnegv;
@

<<global nodcomv>>=
Node*	nodcomv;
@

<<global nodtestv>>=
Node*	nodtestv;
@

<<global nodeqv>>=
Node*	nodeqv;
@

<<global nodnev>>=
Node*	nodnev;
@

<<global nodlev>>=
Node*	nodlev;
@

<<global nodltv>>=
Node*	nodltv;
@

<<global nodgev>>=
Node*	nodgev;
@

<<global nodgtv>>=
Node*	nodgtv;
@

<<global nodhiv>>=
Node*	nodhiv;
@

<<global nodhsv>>=
Node*	nodhsv;
@

<<global nodlov>>=
Node*	nodlov;
@

<<global nodlsv>>=
Node*	nodlsv;
@

<<global nodf2v>>=
Node*	nodf2v;
@

<<global nodd2v>>=
Node*	nodd2v;
@

<<global nodp2v>>=
Node*	nodp2v;
@

<<global nodsi2v>>=
Node*	nodsi2v;
@

<<global nodui2v>>=
Node*	nodui2v;
@

<<global nodsl2v>>=
Node*	nodsl2v;
@

<<global nodul2v>>=
Node*	nodul2v;
@

<<global nodsh2v>>=
Node*	nodsh2v;
@

<<global noduh2v>>=
Node*	noduh2v;
@

<<global nodsc2v>>=
Node*	nodsc2v;
@

<<global noduc2v>>=
Node*	noduc2v;
@

<<global nodv2f>>=
Node*	nodv2f;
@

<<global nodv2d>>=
Node*	nodv2d;
@

<<global nodv2ui>>=
Node*	nodv2ui;
@

<<global nodv2si>>=
Node*	nodv2si;
@

<<global nodv2ul>>=
Node*	nodv2ul;
@

<<global nodv2sl>>=
Node*	nodv2sl;
@

<<global nodv2uh>>=
Node*	nodv2uh;
@

<<global nodv2sh>>=
Node*	nodv2sh;
@

<<global nodv2uc>>=
Node*	nodv2uc;
@

<<global nodv2sc>>=
Node*	nodv2sc;
@

<<global nodvpp>>=
Node*	nodvpp;
@

<<global nodppv>>=
Node*	nodppv;
@

<<global nodvmm>>=
Node*	nodvmm;
@

<<global nodmmv>>=
Node*	nodmmv;
@

<<global nodvasop>>=
Node*	nodvasop;
@

<<global etconv>>=
char	etconv[NTYPE];	/* for _vasop */
@

<<global initetconv>>=
Init	initetconv[] =
{
    TCHAR,		1,	0,
    TUCHAR,		2,	0,
    TSHORT,		3,	0,
    TUSHORT,	4,	0,
    TLONG,		5,	0,
    TULONG,		6,	0,
    TVLONG,		7,	0,
    TUVLONG,	8,	0,
    TINT,		9,	0,
    TUINT,		10,	0,
    -1,		0,	0,
};
@

<<function fvn>>=
Node*
fvn(char *name, int type)
{
    Node *n;

    n = new(ONAME, Z, Z);
    n->sym = slookup(name);
    n->sym->sig = SIGINTERN;
    if(fntypes[type] == 0)
        fntypes[type] = typ(TFUNC, types[type]);
    n->type = fntypes[type];
    n->etype = type;
    n->class = CGLOBL;
    n->addable = 10;
    n->complex = 0;
    return n;
}
@

<<function com64init>>=
void
com64init(void)
{
    Init *p;

    nodaddv = fvn("_addv", TVLONG);
    nodsubv = fvn("_subv", TVLONG);
    nodmulv = fvn("_mulv", TVLONG);
    noddivv = fvn("_divv", TVLONG);
    noddivvu = fvn("_divvu", TVLONG);
    nodmodv = fvn("_modv", TVLONG);
    nodmodvu = fvn("_modvu", TVLONG);
    nodlshv = fvn("_lshv", TVLONG);
    nodrshav = fvn("_rshav", TVLONG);
    nodrshlv = fvn("_rshlv", TVLONG);
    nodandv = fvn("_andv", TVLONG);
    nodorv = fvn("_orv", TVLONG);
    nodxorv = fvn("_xorv", TVLONG);
    nodnegv = fvn("_negv", TVLONG);
    nodcomv = fvn("_comv", TVLONG);

    nodtestv = fvn("_testv", TLONG);
    nodeqv = fvn("_eqv", TLONG);
    nodnev = fvn("_nev", TLONG);
    nodlev = fvn("_lev", TLONG);
    nodltv = fvn("_ltv", TLONG);
    nodgev = fvn("_gev", TLONG);
    nodgtv = fvn("_gtv", TLONG);
    nodhiv = fvn("_hiv", TLONG);
    nodhsv = fvn("_hsv", TLONG);
    nodlov = fvn("_lov", TLONG);
    nodlsv = fvn("_lsv", TLONG);

    nodf2v = fvn("_f2v", TVLONG);
    nodd2v = fvn("_d2v", TVLONG);
    nodp2v = fvn("_p2v", TVLONG);
    nodsi2v = fvn("_si2v", TVLONG);
    nodui2v = fvn("_ui2v", TVLONG);
    nodsl2v = fvn("_sl2v", TVLONG);
    nodul2v = fvn("_ul2v", TVLONG);
    nodsh2v = fvn("_sh2v", TVLONG);
    noduh2v = fvn("_uh2v", TVLONG);
    nodsc2v = fvn("_sc2v", TVLONG);
    noduc2v = fvn("_uc2v", TVLONG);

    nodv2f = fvn("_v2f", TFLOAT);
    nodv2d = fvn("_v2d", TDOUBLE);
    nodv2sl = fvn("_v2sl", TLONG);
    nodv2ul = fvn("_v2ul", TULONG);
    nodv2si = fvn("_v2si", TINT);
    nodv2ui = fvn("_v2ui", TUINT);
    nodv2sh = fvn("_v2sh", TSHORT);
    nodv2uh = fvn("_v2ul", TUSHORT);
    nodv2sc = fvn("_v2sc", TCHAR);
    nodv2uc = fvn("_v2uc", TUCHAR);

    nodvpp = fvn("_vpp", TVLONG);
    nodppv = fvn("_ppv", TVLONG);
    nodvmm = fvn("_vmm", TVLONG);
    nodmmv = fvn("_mmv", TVLONG);

    nodvasop = fvn("_vasop", TVLONG);

    for(p = initetconv; p->code >= 0; p++)
        etconv[p->code] = p->value;
}
@

<<function com64>>=
int
com64(Node *n)
{
    Node *l, *r, *a, *t;
    int lv, rv;

    if(n->type == 0)
        return 0;

    l = n->left;
    r = n->right;

    lv = 0;
    if(l && l->type && typev[l->type->etype])
        lv = 1;
    rv = 0;
    if(r && r->type && typev[r->type->etype])
        rv = 1;

    if(lv) {
        switch(n->op) {
        case OEQ:
            a = nodeqv;
            goto setbool;
        case ONE:
            a = nodnev;
            goto setbool;
        case OLE:
            a = nodlev;
            goto setbool;
        case OLT:
            a = nodltv;
            goto setbool;
        case OGE:
            a = nodgev;
            goto setbool;
        case OGT:
            a = nodgtv;
            goto setbool;
        case OHI:
            a = nodhiv;
            goto setbool;
        case OHS:
            a = nodhsv;
            goto setbool;
        case OLO:
            a = nodlov;
            goto setbool;
        case OLS:
            a = nodlsv;
            goto setbool;

        case OANDAND:
        case OOROR:
            if(machcap(n))
                return 1;

            if(rv) {
                r = new(OFUNC, nodtestv, r);
                n->right = r;
                r->complex = FNX;
                r->op = OFUNC;
                r->type = types[TLONG];
            }

        case OCOND:
        case ONOT:
            if(machcap(n))
                return 1;

            l = new(OFUNC, nodtestv, l);
            n->left = l;
            l->complex = FNX;
            l->op = OFUNC;
            l->type = types[TLONG];
            n->complex = FNX;
            return 1;
        }
    }

    if(rv) {
        if(machcap(n))
            return 1;
        switch(n->op) {
        case OANDAND:
        case OOROR:
            r = new(OFUNC, nodtestv, r);
            n->right = r;
            r->complex = FNX;
            r->op = OFUNC;
            r->type = types[TLONG];
            return 1;
        case OCOND:
            return 1;
        }
    }

    if(typev[n->type->etype]) {
        if(machcap(n))
            return 1;
        switch(n->op) {
        default:
            diag(n, "unknown vlong %O", n->op);
        case OFUNC:
            n->complex = FNX;
        case ORETURN:
        case OAS:
        case OIND:
        case OLIST:
        case OCOMMA:
            return 1;
        case OADD:
            a = nodaddv;
            goto setbop;
        case OSUB:
            a = nodsubv;
            goto setbop;
        case OMUL:
        case OLMUL:
            a = nodmulv;
            goto setbop;
        case ODIV:
            a = noddivv;
            goto setbop;
        case OLDIV:
            a = noddivvu;
            goto setbop;
        case OMOD:
            a = nodmodv;
            goto setbop;
        case OLMOD:
            a = nodmodvu;
            goto setbop;
        case OASHL:
            a = nodlshv;
            goto setbop;
        case OASHR:
            a = nodrshav;
            goto setbop;
        case OLSHR:
            a = nodrshlv;
            goto setbop;
        case OAND:
            a = nodandv;
            goto setbop;
        case OOR:
            a = nodorv;
            goto setbop;
        case OXOR:
            a = nodxorv;
            goto setbop;
        case OPOSTINC:
            a = nodvpp;
            goto setvinc;
        case OPOSTDEC:
            a = nodvmm;
            goto setvinc;
        case OPREINC:
            a = nodppv;
            goto setvinc;
        case OPREDEC:
            a = nodmmv;
            goto setvinc;
        case ONEG:
            a = nodnegv;
            goto setfnx;
        case OCOM:
            a = nodcomv;
            goto setfnx;
        case OCAST:
            switch(l->type->etype) {
            case TCHAR:
                a = nodsc2v;
                goto setfnxl;
            case TUCHAR:
                a = noduc2v;
                goto setfnxl;
            case TSHORT:
                a = nodsh2v;
                goto setfnxl;
            case TUSHORT:
                a = noduh2v;
                goto setfnxl;
            case TINT:
                a = nodsi2v;
                goto setfnx;
            case TUINT:
                a = nodui2v;
                goto setfnx;
            case TLONG:
                a = nodsl2v;
                goto setfnx;
            case TULONG:
                a = nodul2v;
                goto setfnx;
            case TFLOAT:
                a = nodf2v;
                goto setfnx;
            case TDOUBLE:
                a = nodd2v;
                goto setfnx;
            case TIND:
                a = nodp2v;
                goto setfnx;
            }
            diag(n, "unknown %T->vlong cast", l->type);
            return 1;
        case OASADD:
            a = nodaddv;
            goto setasop;
        case OASSUB:
            a = nodsubv;
            goto setasop;
        case OASMUL:
        case OASLMUL:
            a = nodmulv;
            goto setasop;
        case OASDIV:
            a = noddivv;
            goto setasop;
        case OASLDIV:
            a = noddivvu;
            goto setasop;
        case OASMOD:
            a = nodmodv;
            goto setasop;
        case OASLMOD:
            a = nodmodvu;
            goto setasop;
        case OASASHL:
            a = nodlshv;
            goto setasop;
        case OASASHR:
            a = nodrshav;
            goto setasop;
        case OASLSHR:
            a = nodrshlv;
            goto setasop;
        case OASAND:
            a = nodandv;
            goto setasop;
        case OASOR:
            a = nodorv;
            goto setasop;
        case OASXOR:
            a = nodxorv;
            goto setasop;
        }
    }

    if(typefd[n->type->etype] && l && l->op == OFUNC) {
        switch(n->op) {
        case OASADD:
        case OASSUB:
        case OASMUL:
        case OASLMUL:
        case OASDIV:
        case OASLDIV:
        case OASMOD:
        case OASLMOD:
        case OASASHL:
        case OASASHR:
        case OASLSHR:
        case OASAND:
        case OASOR:
        case OASXOR:
            if(l->right && typev[l->right->etype]) {
                diag(n, "sorry float <asop> vlong not implemented\n");
            }
        }
    }

    if(n->op == OCAST) {
        if(l->type && typev[l->type->etype]) {
            if(machcap(n))
                return 1;
            switch(n->type->etype) {
            case TDOUBLE:
                a = nodv2d;
                goto setfnx;
            case TFLOAT:
                a = nodv2f;
                goto setfnx;
            case TLONG:
                a = nodv2sl;
                goto setfnx;
            case TULONG:
                a = nodv2ul;
                goto setfnx;
            case TINT:
                a = nodv2si;
                goto setfnx;
            case TUINT:
                a = nodv2ui;
                goto setfnx;
            case TSHORT:
                a = nodv2sh;
                goto setfnx;
            case TUSHORT:
                a = nodv2uh;
                goto setfnx;
            case TCHAR:
                a = nodv2sc;
                goto setfnx;
            case TUCHAR:
                a = nodv2uc;
                goto setfnx;
            case TIND:	// small pun here
                a = nodv2ul;
                goto setfnx;
            }
            diag(n, "unknown vlong->%T cast", n->type);
            return 1;
        }
    }

    return 0;

setbop:
    n->left = a;
    n->right = new(OLIST, l, r);
    n->complex = FNX;
    n->op = OFUNC;
    return 1;

setfnxl:
    l = new(OCAST, l, 0);
    l->type = types[TLONG];
    l->complex = l->left->complex;

setfnx:
    n->left = a;
    n->right = l;
    n->complex = FNX;
    n->op = OFUNC;
    return 1;

setvinc:
    n->left = a;
    l = new(OADDR, l, Z);
    l->type = typ(TIND, l->left->type);
    l->complex = l->left->complex;
    n->right = new(OLIST, l, r);
    n->complex = FNX;
    n->op = OFUNC;
    return 1;

setbool:
    if(machcap(n))
        return 1;
    n->left = a;
    n->right = new(OLIST, l, r);
    n->complex = FNX;
    n->op = OFUNC;
    n->type = types[TLONG];
    return 1;

setasop:
    if(l->op == OFUNC) {
        l = l->right;
        goto setasop;
    }

    t = new(OCONST, 0, 0);
    t->vconst = etconv[l->type->etype];
    t->type = types[TLONG];
    t->addable = 20;
    r = new(OLIST, t, r);

    t = new(OADDR, a, 0);
    t->type = typ(TIND, a->type);
    r = new(OLIST, t, r);

    t = new(OADDR, l, 0);
    t->type = typ(TIND, l->type);
    t->complex = l->complex;
    r = new(OLIST, t, r);

    n->left = nodvasop;
    n->right = r;
    n->complex = FNX;
    n->op = OFUNC;

    return 1;
}
@

<<function bool64>>=
void
bool64(Node *n)
{
    Node *n1;

    if(machcap(Z))
        return;
    if(typev[n->type->etype]) {
        n1 = new(OXXX, 0, 0);
        *n1 = *n;

        n->right = n1;
        n->left = nodtestv;
        n->complex = FNX;
        n->addable = 0;
        n->op = OFUNC;
        n->type = types[TLONG];
    }
}
@

<<function convvtof>>=
/*
 * more machine depend stuff.
 * this is common for 8,16,32,64 bit machines.
 * this is common for ieee machines.
 */
double
convvtof(vlong v)
{
    double d;

    d = v;		/* BOTCH */
    return d;
}
@

<<function convftov>>=
vlong
convftov(double d)
{
    vlong v;


    v = d;		/* BOTCH */
    return v;
}
@

<<function convftox>>=
double
convftox(double d, int et)
{

    if(!typefd[et])
        diag(Z, "bad type in castftox %s", tnames[et]);
    return d;
}
@

<<function convvtox>>=
vlong
convvtox(vlong c, int et)
{
    int n;

    n = 8 * ewidth[et];
    c &= MASK(n);
    if(!typeu[et])
        if(c & SIGN(n))
            c |= ~MASK(n);
    return c;
}
@


%-------------------------------------------------------------

<<cc/com64.c>>=
#include "cc.h"

<<constant FNX>>

<<global nodaddv>>
<<global nodsubv>>
<<global nodmulv>>
<<global noddivv>>
<<global noddivvu>>
<<global nodmodv>>
<<global nodmodvu>>
<<global nodlshv>>
<<global nodrshav>>
<<global nodrshlv>>
<<global nodandv>>
<<global nodorv>>
<<global nodxorv>>
<<global nodnegv>>
<<global nodcomv>>

<<global nodtestv>>
<<global nodeqv>>
<<global nodnev>>
<<global nodlev>>
<<global nodltv>>
<<global nodgev>>
<<global nodgtv>>
<<global nodhiv>>
<<global nodhsv>>
<<global nodlov>>
<<global nodlsv>>

<<global nodf2v>>
<<global nodd2v>>
<<global nodp2v>>
<<global nodsi2v>>
<<global nodui2v>>
<<global nodsl2v>>
<<global nodul2v>>
<<global nodsh2v>>
<<global noduh2v>>
<<global nodsc2v>>
<<global noduc2v>>

<<global nodv2f>>
<<global nodv2d>>
<<global nodv2ui>>
<<global nodv2si>>
<<global nodv2ul>>
<<global nodv2sl>>
<<global nodv2uh>>
<<global nodv2sh>>
<<global nodv2uc>>
<<global nodv2sc>>

<<global nodvpp>>
<<global nodppv>>
<<global nodvmm>>
<<global nodmmv>>

<<global nodvasop>>

<<global etconv>>
<<global initetconv>>

<<function fvn>>

<<function com64init>>

<<function com64>>

<<function bool64>>

<<function convvtof>>

<<function convftov>>

<<function convftox>>

<<function convvtox>>
@


\subsection*{[[cc2/pswt.c]]}

<<function swcmp>>=
int
swcmp(const void *a1, const void *a2)
{
    C1 *p1, *p2;

    p1 = (C1*)a1;
    p2 = (C1*)a2;
    if(p1->val < p2->val)
        return -1;
    return p1->val > p2->val;
}
@

<<function doswit>>=
void
doswit(Node *n)
{
    Case *c;
    C1 *q, *iq, *iqh, *iql;
    long def, nc, i, j, isv, nh;
    Prog *hsb;
    Node *vr[2];
    int dup;

    def = 0;
    nc = 0;
    isv = 0;
    for(c = cases; c->link != C; c = c->link) {
        if(c->def) {
            if(def)
                diag(n, "more than one default in switch");
            def = c->label;
            continue;
        }
        isv |= c->isv;
        nc++;
    }
    if(typev[n->type->etype])
        isv = 1;
    else if(isv){
        warn(n, "32-bit switch expression with 64-bit case constant");
        isv = 0;
    }

    iq = alloc(nc*sizeof(C1));
    q = iq;
    for(c = cases; c->link != C; c = c->link) {
        if(c->def)
            continue;
        if(c->isv && !isv)
            continue;	/* can never match */
        q->label = c->label;
        if(isv)
            q->val = c->val;
        else
            q->val = (long)c->val;	/* cast ensures correct value for 32-bit switch on 64-bit architecture */
        q++;
    }
    qsort(iq, nc, sizeof(C1), swcmp);
    if(debug['K'])
    for(i=0; i<nc; i++)
        print("case %2ld: = %.8llux\n", i, (vlong)iq[i].val);
    dup = 0;
    for(i=0; i<nc-1; i++)
        if(iq[i].val == iq[i+1].val) {
            diag(n, "duplicate cases in switch %lld", (vlong)iq[i].val);
            dup = 1;
        }
    if(dup)
        return;
    if(def == 0) {
        def = breakpc;
        nbreak++;
    }
    if(!isv || ewidth[TIND] > ewidth[TLONG] || n->op == OREGISTER) {
        swit1(iq, nc, def, n);
        return;
    }

    /*
     * 64-bit case on 32-bit machine:
     * switch on high-order words, and
     * in each of those, switch on low-order words
     */
    if(n->op != OREGPAIR)
        fatal(n, "internal: expected register pair");
    if(thechar == '8'){	/* TO DO: need an enquiry function */
        vr[0] = n->left;	/* low */
        vr[1] = n->right;	/* high */
    }else{
        vr[0] = n->right;
        vr[1] = n->left;
    }
    vr[0]->type = types[TLONG];
    vr[1]->type = types[TLONG];
    gbranch(OGOTO);
    hsb = p;
    iqh = alloc(nc*sizeof(C1));
    iql = alloc(nc*sizeof(C1));
    nh = 0;
    for(i=0; i<nc;){
        iqh[nh].val = iq[i].val >> 32;
        q = iql;
        /* iq is sorted, so equal top halves are adjacent */
        for(j = i; j < nc; j++){
            if((iq[j].val>>32) != iqh[nh].val)
                break;
            q->val = (long)iq[j].val;
            q->label = iq[j].label;
            q++;
        }
        qsort(iql,  q-iql, sizeof(C1), swcmp);
                //if(0){for(int k=0; k<(q-iql); k++)print("nh=%ld k=%d h=%#llux l=%#llux lab=%ld\n", nh, k, (vlong)iqh[nh].val,  (vlong)iql[k].val, iql[k].label);}
        iqh[nh].label = pc;
        nh++;
        swit1(iql, q-iql, def, vr[0]);
        i = j;
    }
    patch(hsb, pc);
        //if(0){for(int k=0; k<nh; k++)print("k*=%d h=%#llux lab=%ld\n", k, (vlong)iqh[k].val,  iqh[k].label);}
    swit1(iqh, nh, def, vr[1]);
}
@

<<function casf>>=
void
casf(void)
{
    Case *c;

    c = alloc(sizeof(*c));
    c->link = cases;
    cases = c;
}
@

<<function outlstring>>=
long
outlstring(TRune *s, long n)
{
    char buf[sizeof(TRune)];
    uint c;
    int i;
    long r;

    if(suppress)
        return nstring;
    while(nstring & (sizeof(TRune)-1))
        outstring("", 1);
    r = nstring;
    while(n > 0) {
        c = *s++;
        if(align(0, types[TCHAR], Aarg1)) {
            for(i = 0; i < sizeof(TRune); i++)
                buf[i] = c>>(8*(sizeof(TRune) - i - 1));
        } else {
            for(i = 0; i < sizeof(TRune); i++)
                buf[i] = c>>(8*i);
        }
        outstring(buf, sizeof(TRune));
        n -= sizeof(TRune);
    }
    return r;
}
@

<<function nullwarn>>=
void
nullwarn(Node *l, Node *r)
{
    warn(Z, "result of operation not used");
    if(l != Z)
        cgen(l, Z);
    if(r != Z)
        cgen(r, Z);
}
@

<<function ieeedtod>>=
void
ieeedtod(Ieee *ieee, double native)
{
    double fr, ho, f;
    int exp;

    if(native < 0) {
        ieeedtod(ieee, -native);
        ieee->h |= 0x80000000L;
        return;
    }
    if(native == 0) {
        ieee->l = 0;
        ieee->h = 0;
        return;
    }
    fr = frexp(native, &exp);
    f = 2097152L;		/* shouldnt use fp constants here */
    fr = modf(fr*f, &ho);
    ieee->h = ho;
    ieee->h &= 0xfffffL;
    ieee->h |= (exp+1022L) << 20;
    f = 65536L;
    fr = modf(fr*f, &ho);
    ieee->l = ho;
    ieee->l <<= 16;
    ieee->l |= (long)(fr*f);
}
@


%-------------------------------------------------------------

<<cc2/pswt.c>>=
#include "gc.h"

<<function swcmp>>

<<function doswit>>

<<function casf>>

<<function outlstring>>

<<function nullwarn>>

<<function ieeedtod>>
@


\subsection*{[[cc/dcl.c]]}

<<function dodecl>>=
Node*
dodecl(void (*f)(int,Type*,Sym*), int c, Type *t, Node *n)
{
    Sym *s;
    Node *n1;
    long v;

    nearln = lineno;
    lastfield = 0;

loop:
    if(n != Z)
    switch(n->op) {
    default:
        diag(n, "unknown declarator: %O", n->op);
        break;

    case OARRAY:
        t = typ(TARRAY, t);
        t->width = 0;
        n1 = n->right;
        n = n->left;
        if(n1 != Z) {
            complex(n1);
            v = -1;
            if(n1->op == OCONST)
                v = n1->vconst;
            if(v <= 0) {
                diag(n, "array size must be a positive constant");
                v = 1;
            }
            t->width = v * t->link->width;
        }
        goto loop;

    case OIND:
        t = typ(TIND, t);
        t->garb = n->garb;
        n = n->left;
        goto loop;

    case OFUNC:
        t = typ(TFUNC, t);
        t->down = fnproto(n);
        n = n->left;
        goto loop;

    case OBIT:
        n1 = n->right;
        complex(n1);
        lastfield = -1;
        if(n1->op == OCONST)
            lastfield = n1->vconst;
        if(lastfield < 0) {
            diag(n, "field width must be non-negative constant");
            lastfield = 1;
        }
        if(lastfield == 0) {
            lastbit = 0;
            firstbit = 1;
            if(n->left != Z) {
                diag(n, "zero width named field");
                lastfield = 1;
            }
        }
        if(!typei[t->etype]) {
            diag(n, "field type must be int-like");
            t = types[TINT];
            lastfield = 1;
        }
        if(lastfield > tfield->width*8) {
            diag(n, "field width larger than field unit");
            lastfield = 1;
        }
        lastbit += lastfield;
        if(lastbit > tfield->width*8) {
            lastbit = lastfield;
            firstbit = 1;
        }
        n = n->left;
        goto loop;

    case ONAME:
        if(f == NODECL)
            break;
        s = n->sym;
        (*f)(c, t, s);
        if(s->class == CLOCAL)
            s = mkstatic(s);
        firstbit = 0;
        n->sym = s;
        n->type = s->type;
        n->xoffset = s->offset;
        n->class = s->class;
        n->etype = TVOID;
        if(n->type != T)
            n->etype = n->type->etype;
        if(debug['d'])
            dbgdecl(s);
        acidvar(s);
        s->varlineno = lineno;
        break;
    }
    lastdcl = t;
    return n;
}
@

<<function mkstatic>>=
Sym*
mkstatic(Sym *s)
{
    Sym *s1;

    if(s->class != CLOCAL)
        return s;
    snprint(symb, NSYMB, "%s$%d", s->name, s->block);
    s1 = lookup();
    if(s1->class != CSTATIC) {
        s1->type = s->type;
        s1->offset = s->offset;
        s1->block = s->block;
        s1->class = CSTATIC;
    }
    return s1;
}
@

<<function tcopy>>=
/*
 * make a copy of a typedef
 * the problem is to split out incomplete
 * arrays so that it is in the variable
 * rather than the typedef.
 */
Type*
tcopy(Type *t)
{
    Type *tl, *tx;
    int et;

    if(t == T)
        return t;
    et = t->etype;
    if(typesu[et])
        return t;
    tl = tcopy(t->link);
    if(tl != t->link ||
      (et == TARRAY && t->width == 0)) {
        tx = copytyp(t);
        tx->link = tl;
        return tx;
    }
    return t;
}
@

<<function doinit>>=
Node*
doinit(Sym *s, Type *t, long o, Node *a)
{
    Node *n;

    if(t == T)
        return Z;
    if(s->class == CEXTERN) {
        s->class = CGLOBL;
        if(debug['d'])
            dbgdecl(s);
    }
    if(debug['i']) {
        print("t = %T; o = %ld; n = %s\n", t, o, s->name);
        prtree(a, "doinit value");
    }


    n = initlist;
    if(a->op == OINIT)
        a = a->left;
    initlist = a;

    a = init1(s, t, o, 0);
    if(initlist != Z)
        diag(initlist, "more initializers than structure: %s",
            s->name);
    initlist = n;

    return a;
}
@

<<function peekinit>>=
/*
 * get next major operator,
 * dont advance initlist.
 */
Node*
peekinit(void)
{
    Node *a;

    a = initlist;

loop:
    if(a == Z)
        return a;
    if(a->op == OLIST) {
        a = a->left;
        goto loop;
    }
    return a;
}
@

<<function nextinit>>=
/*
 * consume and return next element on
 * initlist. expand strings.
 */
Node*
nextinit(void)
{
    Node *a, *b, *n;

    a = initlist;
    n = Z;

    if(a == Z)
        return a;
    if(a->op == OLIST) {
        n = a->right;
        a = a->left;
    }
    if(a->op == OUSED) {
        a = a->left;
        b = new(OCONST, Z, Z);
        b->type = a->type->link;
        if(a->op == OSTRING) {
            b->vconst = convvtox(*a->cstring, TCHAR);
            a->cstring++;
        }
        if(a->op == OLSTRING) {
            b->vconst = convvtox(*a->rstring, TRUNE);
            a->rstring++;
        }
        a->type->width -= b->type->width;
        if(a->type->width <= 0)
            initlist = n;
        return b;
    }
    initlist = n;
    return a;
}
@

<<function isstruct>>=
int
isstruct(Node *a, Type *t)
{
    Node *n;

    switch(a->op) {
    case ODOTDOT:
        n = a->left;
        if(n && n->type && sametype(n->type, t))
            return 1;
    case OSTRING:
    case OLSTRING:
    case OCONST:
    case OINIT:
    case OELEM:
        return 0;
    }

    n = new(ODOTDOT, Z, Z);
    *n = *a;

    /*
     * ODOTDOT is a flag for tcom
     * a second tcom will not be performed
     */
    a->op = ODOTDOT;
    a->left = n;
    a->right = Z;

    if(tcom(n))
        return 0;

    if(sametype(n->type, t))
        return 1;
    return 0;
}
@

<<function init1>>=
Node*
init1(Sym *s, Type *t, long o, int exflag)
{
    Node *a, *l, *r, nod;
    Type *t1;
    long e, w, so, mw;

    a = peekinit();
    if(a == Z)
        return Z;

    if(debug['i']) {
        print("t = %T; o = %ld; n = %s\n", t, o, s->name);
        prtree(a, "init1 value");
    }

    if(exflag && a->op == OINIT)
        return doinit(s, t, o, nextinit());

    switch(t->etype) {
    default:
        diag(Z, "unknown type in initialization: %T to: %s", t, s->name);
        return Z;

    case TCHAR:
    case TUCHAR:
    case TINT:
    case TUINT:
    case TSHORT:
    case TUSHORT:
    case TLONG:
    case TULONG:
    case TVLONG:
    case TUVLONG:
    case TFLOAT:
    case TDOUBLE:
    case TIND:
    single:
        if(a->op == OARRAY || a->op == OELEM)
            return Z;

        a = nextinit();
        if(a == Z)
            return Z;

        if(t->nbits)
            diag(Z, "cannot initialize bitfields");
        if(s->class == CAUTO) {
            l = new(ONAME, Z, Z);
            l->sym = s;
            l->type = t;
            l->etype = TVOID;
            if(s->type)
                l->etype = s->type->etype;
            l->xoffset = s->offset + o;
            l->class = s->class;

            l = new(OASI, l, a);
            return l;
        }

        complex(a);
        if(a->type == T)
            return Z;

        if(a->op == OCONST) {
            if(vconst(a) && t->etype == TIND && a->type && a->type->etype != TIND){
                diag(a, "initialize pointer to an integer: %s", s->name);
                return Z;
            }
            if(!sametype(a->type, t)) {
                /* hoop jumping to save malloc */
                if(nodcast == Z)
                    nodcast = new(OCAST, Z, Z);
                nod = *nodcast;
                nod.left = a;
                nod.type = t;
                nod.lineno = a->lineno;
                complex(&nod);
                if(nod.type)
                    *a = nod;
            }
            if(a->op != OCONST) {
                diag(a, "initializer is not a constant: %s",
                    s->name);
                return Z;
            }
            if(vconst(a) == 0)
                return Z;
            goto gext;
        }
        if(t->etype == TIND) {
            while(a->op == OCAST) {
                warn(a, "CAST in initialization ignored");
                a = a->left;
            }
            if(!sametype(t, a->type)) {
                diag(a, "initialization of incompatible pointers: %s\n%T and %T",
                    s->name, t, a->type);
            }
            if(a->op == OADDR)
                a = a->left;
            goto gext;
        }

        while(a->op == OCAST)
            a = a->left;
        if(a->op == OADDR) {
            warn(a, "initialize pointer to an integer: %s", s->name);
            a = a->left;
            goto gext;
        }
        diag(a, "initializer is not a constant: %s", s->name);
        return Z;

    gext:
        gextern(s, a, o, t->width);

        return Z;

    case TARRAY:
        w = t->link->width;
        if(a->op == OSTRING || a->op == OLSTRING)
        if(typei[t->link->etype]) {
            /*
             * get rid of null if sizes match exactly
             */
            a = nextinit();
            mw = t->width/w;
            so = a->type->width/a->type->link->width;
            if(mw && so > mw) {
                if(so != mw+1)
                    diag(a, "string initialization larger than array");
                a->type->width -= a->type->link->width;
            }

            /*
             * arrange strings to be expanded
             * inside OINIT braces.
             */
            a = new(OUSED, a, Z);
            return doinit(s, t, o, a);
        }

        mw = -w;
        l = Z;
        for(e=0;;) {
            /*
             * peek ahead for element initializer
             */
            a = peekinit();
            if(a == Z)
                break;
            if(a->op == OELEM && t->link->etype != TSTRUCT)
                break;
            if(a->op == OARRAY) {
                if(e && exflag)
                    break;
                a = nextinit();
                r = a->left;
                complex(r);
                if(r->op != OCONST) {
                    diag(r, "initializer subscript must be constant");
                    return Z;
                }
                e = r->vconst;
                if(t->width != 0)
                    if(e < 0 || e*w >= t->width) {
                        diag(a, "initialization index out of range: %ld", e);
                        continue;
                    }
            }

            so = e*w;
            if(so > mw)
                mw = so;
            if(t->width != 0)
                if(mw >= t->width)
                    break;
            r = init1(s, t->link, o+so, 1);
            l = newlist(l, r);
            e++;
        }
        if(t->width == 0)
            t->width = mw+w;
        return l;

    case TUNION:
    case TSTRUCT:
        /*
         * peek ahead to find type of rhs.
         * if its a structure, then treat
         * this element as a variable
         * rather than an aggregate.
         */
        if(isstruct(a, t))
            goto single;

        if(t->width <= 0) {
            diag(Z, "incomplete structure: %s", s->name);
            return Z;
        }
        l = Z;

    again:
        for(t1 = t->link; t1 != T; t1 = t1->down) {
            if(a->op == OARRAY && t1->etype != TARRAY)
                break;
            if(a->op == OELEM) {
                if(t1->sym != a->sym)
                    continue;
                nextinit();
            }
            r = init1(s, t1, o+t1->offset, 1);
            l = newlist(l, r);
            a = peekinit();
            if(a == Z)
                break;
            if(a->op == OELEM)
                goto again;
        }
        if(a && a->op == OELEM)
            diag(a, "structure element not found %F", a);
        return l;
    }
}
@

<<function newlist>>=
Node*
newlist(Node *l, Node *r)
{
    if(r == Z)
        return l;
    if(l == Z)
        return r;
    return new(OLIST, l, r);
}
@

<<function sualign>>=
void
sualign(Type *t)
{
    Type *l;
    long o, w;

    o = 0;
    switch(t->etype) {

    case TSTRUCT:
        t->offset = 0;
        w = 0;
        for(l = t->link; l != T; l = l->down) {
            if(l->nbits) {
                if(l->shift <= 0) {
                    l->shift = -l->shift;
                    w = round(w, tfield->width);
                    o = w;
                    w += tfield->width;
                }
                l->offset = o;
            } else {
                if(l->width < 0 ||
                   l->width == 0 && l->down != T)
                    if(l->sym)
                        diag(Z, "incomplete structure element: %s",
                            l->sym->name);
                    else
                        diag(Z, "incomplete structure element");
                w = align(w, l, Ael1);
                l->offset = w;
                w = align(w, l, Ael2);
            }
        }
        w = align(w, t, Asu2);
        t->width = w;
        acidtype(t);
        pickletype(t);
        return;

    case TUNION:
        t->offset = 0;
        w = 0;
        for(l = t->link; l != T; l = l->down) {
            if(l->width <= 0)
                if(l->sym)
                    diag(Z, "incomplete union element: %s",
                        l->sym->name);
                else
                    diag(Z, "incomplete union element");
            l->offset = 0;
            l->shift = 0;
            o = align(align(0, l, Ael1), l, Ael2);
            if(o > w)
                w = o;
        }
        w = align(w, t, Asu2);
        t->width = w;
        acidtype(t);
        pickletype(t);
        return;

    default:
        diag(Z, "unknown type in sualign: %T", t);
        break;
    }
}
@

<<function round>>=
long
round(long v, int w)
{
    int r;

    if(w <= 0 || w > 8) {
        diag(Z, "rounding by %d", w);
        w = 1;
    }
    r = v%w;
    if(r)
        v += w-r;
    return v;
}
@

<<function ofnproto>>=
Type*
ofnproto(Node *n)
{
    Type *tl, *tr, *t;

    if(n == Z)
        return T;
    switch(n->op) {
    case OLIST:
        tl = ofnproto(n->left);
        tr = ofnproto(n->right);
        if(tl == T)
            return tr;
        tl->down = tr;
        return tl;

    case ONAME:
        t = copytyp(n->sym->type);
        t->down = T;
        return t;
    }
    return T;
}
@

<<constant ANSIPROTO>>=
#define	ANSIPROTO	1
@

<<constant OLDPROTO>>=
#define	OLDPROTO	2
@

<<function argmark>>=
void
argmark(Node *n, int pass)
{
    Type *t;

    autoffset = align(0, thisfn->link, Aarg0);
    stkoff = 0;
    for(; n->left != Z; n = n->left) {
        if(n->op != OFUNC || n->left->op != ONAME)
            continue;
        walkparam(n->right, pass);
        if(pass != 0 && anyproto(n->right) == OLDPROTO) {
            t = typ(TFUNC, n->left->sym->type->link);
            t->down = typ(TOLD, T);
            t->down->down = ofnproto(n->right);
            tmerge(t, n->left->sym);
            n->left->sym->type = t;
        }
        break;
    }
    autoffset = 0;
    stkoff = 0;
}
@

<<function walkparam>>=
void
walkparam(Node *n, int pass)
{
    Sym *s;
    Node *n1;

    if(n != Z && n->op == OPROTO && n->left == Z && n->type == types[TVOID])
        return;

loop:
    if(n == Z)
        return;
    switch(n->op) {
    default:
        diag(n, "argument not a name/prototype: %O", n->op);
        break;

    case OLIST:
        walkparam(n->left, pass);
        n = n->right;
        goto loop;

    case OPROTO:
        for(n1 = n; n1 != Z; n1=n1->left)
            if(n1->op == ONAME) {
                if(pass == 0) {
                    s = n1->sym;
                    push1(s);
                    s->offset = -1;
                    break;
                }
                dodecl(pdecl, CPARAM, n->type, n->left);
                break;
            }
        if(n1)
            break;
        if(pass == 0) {
            /*
             * extension:
             *	allow no name in argument declaration
            diag(Z, "no name in argument declaration");
             */
            break;
        }
        dodecl(NODECL, CPARAM, n->type, n->left);
        pdecl(CPARAM, lastdcl, S);
        break;

    case ODOTDOT:
        break;
    
    case ONAME:
        s = n->sym;
        if(pass == 0) {
            push1(s);
            s->offset = -1;
            break;
        }
        if(s->offset != -1) {
            if(autoffset == 0) {
                firstarg = s;
                firstargtype = s->type;
            }
            autoffset = align(autoffset, s->type, Aarg1);
            s->offset = autoffset;
            autoffset = align(autoffset, s->type, Aarg2);
        } else
            dodecl(pdecl, CXXX, types[TINT], n);
        break;
    }
}
@

<<function markdcl>>=
void
markdcl(void)
{
    Decl *d;

    blockno++;
    d = push();
    d->val = DMARK;
    d->offset = autoffset;
    d->block = autobn;
    autobn = blockno;
}
@

<<function revertdcl>>=
Node*
revertdcl(void)
{
    Decl *d;
    Sym *s;
    Node *n, *n1;

    n = Z;
    for(;;) {
        d = dclstack;
        if(d == D) {
            diag(Z, "pop off dcl stack");
            break;
        }
        dclstack = d->link;
        s = d->sym;
        switch(d->val) {
        case DMARK:
            autoffset = d->offset;
            autobn = d->block;
            return n;

        case DAUTO:
            if(debug['d'])
                print("revert1 \"%s\"\n", s->name);
            if(s->aused == 0) {
                nearln = s->varlineno;
                if(s->class == CAUTO)
                    warn(Z, "auto declared and not used: %s", s->name);
                if(s->class == CPARAM)
                    warn(Z, "param declared and not used: %s", s->name);
            }
            if(s->type && (s->type->garb & GVOLATILE)) {
                n1 = new(ONAME, Z, Z);
                n1->sym = s;
                n1->type = s->type;
                n1->etype = TVOID;
                if(n1->type != T)
                    n1->etype = n1->type->etype;
                n1->xoffset = s->offset;
                n1->class = s->class;

                n1 = new(OADDR, n1, Z);
                n1 = new(OUSED, n1, Z);
                if(n == Z)
                    n = n1;
                else
                    n = new(OLIST, n1, n);
            }
            s->type = d->type;
            s->class = d->class;
            s->offset = d->offset;
            s->block = d->block;
            s->varlineno = d->varlineno;
            s->aused = d->aused;
            break;

        case DSUE:
            if(debug['d'])
                print("revert2 \"%s\"\n", s->name);
            s->suetag = d->type;
            s->sueblock = d->block;
            break;

        case DLABEL:
            if(debug['d'])
                print("revert3 \"%s\"\n", s->name);
            if(s->label && s->label->addable == 0)
                warn(s->label, "label declared and not used \"%s\"", s->name);
            s->label = Z;
            break;
        }
    }
    return n;
}
@

<<function fnproto>>=
Type*
fnproto(Node *n)
{
    int r;

    r = anyproto(n->right);
    if(r == 0 || (r & OLDPROTO)) {
        if(r & ANSIPROTO)
            diag(n, "mixed ansi/old function declaration: %F", n->left);
        return T;
    }
    return fnproto1(n->right);
}
@

<<function anyproto>>=
int
anyproto(Node *n)
{
    int r;

    r = 0;

loop:
    if(n == Z)
        return r;
    switch(n->op) {
    case OLIST:
        r |= anyproto(n->left);
        n = n->right;
        goto loop;

    case ODOTDOT:
    case OPROTO:
        return r | ANSIPROTO;
    }
    return r | OLDPROTO;
}
@

<<function fnproto1>>=
Type*
fnproto1(Node *n)
{
    Type *t;

    if(n == Z)
        return T;
    switch(n->op) {
    case OLIST:
        t = fnproto1(n->left);
        if(t != T)
            t->down = fnproto1(n->right);
        return t;

    case OPROTO:
        lastdcl = T;
        dodecl(NODECL, CXXX, n->type, n->left);
        t = typ(TXXX, T);
        if(lastdcl != T)
            *t = *paramconv(lastdcl, 1);
        return t;

    case ONAME:
        diag(n, "incomplete argument prototype");
        return typ(TINT, T);

    case ODOTDOT:
        return typ(TDOT, T);
    }
    diag(n, "unknown op in fnproto");
    return T;
}
@

<<function dbgdecl>>=
void
dbgdecl(Sym *s)
{
    print("decl \"%s\": C=%s [B=%d:O=%ld] T=%T\n",
        s->name, cnames[s->class], s->block, s->offset, s->type);
}
@

<<function push>>=
Decl*
push(void)
{
    Decl *d;

    d = alloc(sizeof(*d));
    d->link = dclstack;
    dclstack = d;
    return d;
}
@

<<function push1>>=
Decl*
push1(Sym *s)
{
    Decl *d;

    d = push();
    d->sym = s;
    d->val = DAUTO;
    d->type = s->type;
    d->class = s->class;
    d->offset = s->offset;
    d->block = s->block;
    d->varlineno = s->varlineno;
    d->aused = s->aused;
    return d;
}
@

<<function sametype>>=
int
sametype(Type *t1, Type *t2)
{

    if(t1 == t2)
        return 1;
    return rsametype(t1, t2, 5, 1);
}
@

<<function rsametype>>=
int
rsametype(Type *t1, Type *t2, int n, int f)
{
    int et;

    n--;
    for(;;) {
        if(t1 == t2)
            return 1;
        if(t1 == T || t2 == T)
            return 0;
        if(n <= 0)
            return 1;
        et = t1->etype;
        if(et != t2->etype)
            return 0;
        if(et == TFUNC) {
            if(!rsametype(t1->link, t2->link, n, 0))
                return 0;
            t1 = t1->down;
            t2 = t2->down;
            while(t1 != T && t2 != T) {
                if(t1->etype == TOLD) {
                    t1 = t1->down;
                    continue;
                }
                if(t2->etype == TOLD) {
                    t2 = t2->down;
                    continue;
                }
                while(t1 != T || t2 != T) {
                    if(!rsametype(t1, t2, n, 0))
                        return 0;
                    t1 = t1->down;
                    t2 = t2->down;
                }
                break;
            }
            return 1;
        }
        if(et == TARRAY)
            if(t1->width != t2->width && t1->width != 0 && t2->width != 0)
                return 0;
        if(typesu[et]) {
            if(t1->link == T)
                snap(t1);
            if(t2->link == T)
                snap(t2);
            if(t1 != t2 && t1->link == T && t2->link == T){
                /* structs with missing or different tag names aren't considered equal */
                if(t1->tag == nil || t2->tag == nil ||
                   strcmp(t1->tag->name, t2->tag->name) != 0)
                    return 0;
            }
            t1 = t1->link;
            t2 = t2->link;
            for(;;) {
                if(t1 == t2)
                    return 1;
                if(!rsametype(t1, t2, n, 0))
                    return 0;
                t1 = t1->down;
                t2 = t2->down;
            }
        }
        t1 = t1->link;
        t2 = t2->link;
        if((f || !debug['V']) && et == TIND) {
            if(t1 != T && t1->etype == TVOID)
                return 1;
            if(t2 != T && t2->etype == TVOID)
                return 1;
        }
    }
}
@

<<struct Typetab>>=
struct Typetab{
    int n;
    Type **a;
};
@

<<function sigind>>=
static int
sigind(Type *t, Typetab *tt)
{
    int n;
    Type **a, **na, **p, **e;

    n = tt->n;
    a = tt->a;
    e = a+n;
    /* linear search seems ok */
    for(p = a ; p < e; p++)
        if(sametype(*p, t))
            return p-a;
    if((n&15) == 0){
        na = malloc((n+16)*sizeof(Type*));
        memmove(na, a, n*sizeof(Type*));
        free(a);
        a = tt->a = na;
    }
    a[tt->n++] = t;
    return -1;
}
@

<<function signat>>=
static ulong
signat(Type *t, Typetab *tt)
{
    int i;
    Type *t1;
    long s;

    s = 0;
    for(; t; t=t->link) {
        s = s*thash1 + thash[t->etype];
        if(t->garb&GINCOMPLETE)
            return s;
        switch(t->etype) {
        default:
            return s;
        case TARRAY:
            s = s*thash2 + 0;	/* was t->width */
            break;
        case TFUNC:
            for(t1=t->down; t1; t1=t1->down)
                s = s*thash3 + signat(t1, tt);
            break;
        case TSTRUCT:
        case TUNION:
            if((i = sigind(t, tt)) >= 0){
                s = s*thash2 + i;
                return s;
            }
            for(t1=t->link; t1; t1=t1->down)
                s = s*thash3 + signat(t1, tt);
            return s;
        case TIND:
            break;
        }
    }
    return s;
}
@

<<function signature>>=
ulong
signature(Type *t)
{
    ulong s;
    Typetab tt;

    tt.n = 0;
    tt.a = nil;
    s = signat(t, &tt);
    free(tt.a);
    return s;
}
@

<<function sign>>=
ulong
sign(Sym *s)
{
    ulong v;
    Type *t;

    if(s->sig == SIGINTERN)
        return SIGNINTERN;
    if((t = s->type) == T)
        return 0;
    v = signature(t);
    if(v == 0)
        v = SIGNINTERN;
    return v;
}
@

<<function snap>>=
void
snap(Type *t)
{
    if(typesu[t->etype])
    if(t->link == T && t->tag && t->tag->suetag) {
        t->link = t->tag->suetag->link;
        t->width = t->tag->suetag->width;
    }
}
@

<<function dotag>>=
Type*
dotag(Sym *s, int et, int bn)
{
    Decl *d;

    if(bn != 0 && bn != s->sueblock) {
        d = push();
        d->sym = s;
        d->val = DSUE;
        d->type = s->suetag;
        d->block = s->sueblock;
        s->suetag = T;
    }
    if(s->suetag == T) {
        s->suetag = typ(et, T);
        s->sueblock = autobn;
    }
    if(s->suetag->etype != et)
        diag(Z, "tag used for more than one type: %s",
            s->name);
    if(s->suetag->tag == S)
        s->suetag->tag = s;
    return s->suetag;
}
@

<<function dcllabel>>=
Node*
dcllabel(Sym *s, int f)
{
    Decl *d, d1;
    Node *n;

    n = s->label;
    if(n != Z) {
        if(f) {
            if(n->complex)
                diag(Z, "label reused: %s", s->name);
            n->complex = 1;	// declared
        } else
            n->addable = 1;	// used
        return n;
    }

    d = push();
    d->sym = s;
    d->val = DLABEL;
    dclstack = d->link;

    d1 = *firstdcl;
    *firstdcl = *d;
    *d = d1;

    firstdcl->link = d;
    firstdcl = d;

    n = new(OXXX, Z, Z);
    n->sym = s;
    n->complex = f;
    n->addable = !f;
    s->label = n;

    if(debug['d'])
        dbgdecl(s);
    return n;
}
@

<<function paramconv>>=
Type*
paramconv(Type *t, int f)
{

    switch(t->etype) {
    case TARRAY:
        t = typ(TIND, t->link);
        t->width = types[TIND]->width;
        break;

    case TFUNC:
        t = typ(TIND, t);
        t->width = types[TIND]->width;
        break;

    case TFLOAT:
        if(!f)
            t = types[TDOUBLE];
        break;

    case TCHAR:
    case TSHORT:
        if(!f)
            t = types[TINT];
        break;

    case TUCHAR:
    case TUSHORT:
        if(!f)
            t = types[TUINT];
        break;
    }
    return t;
}
@

<<function adecl>>=
void
adecl(int c, Type *t, Sym *s)
{

    if(c == CSTATIC)
        c = CLOCAL;
    if(t->etype == TFUNC) {
        if(c == CXXX)
            c = CEXTERN;
        if(c == CLOCAL)
            c = CSTATIC;
        if(c == CAUTO || c == CEXREG)
            diag(Z, "function cannot be %s %s", cnames[c], s->name);
    }
    if(c == CXXX)
        c = CAUTO;
    if(s) {
        if(s->class == CSTATIC)
            if(c == CEXTERN || c == CGLOBL) {
                warn(Z, "just say static: %s", s->name);
                c = CSTATIC;
            }
        if(s->class == CAUTO || s->class == CPARAM || s->class == CLOCAL)
        if(s->block == autobn)
            diag(Z, "auto redeclaration of: %s", s->name);
        if(c != CPARAM)
            push1(s);
        s->block = autobn;
        s->offset = 0;
        s->type = t;
        s->class = c;
        s->aused = 0;
    }
    switch(c) {
    case CAUTO:
        autoffset = align(autoffset, t, Aaut3);
        stkoff = maxround(stkoff, autoffset);
        s->offset = -autoffset;
        break;

    case CPARAM:
        if(autoffset == 0) {
            firstarg = s;
            firstargtype = t;
        }
        autoffset = align(autoffset, t, Aarg1);
        if(s)
            s->offset = autoffset;
        autoffset = align(autoffset, t, Aarg2);
        break;
    }
}
@

<<function pdecl>>=
void
pdecl(int c, Type *t, Sym *s)
{
    if(s && s->offset != -1) {
        diag(Z, "not a parameter: %s", s->name);
        return;
    }
    t = paramconv(t, c==CPARAM);
    if(c == CXXX)
        c = CPARAM;
    if(c != CPARAM) {
        diag(Z, "parameter cannot have class: %s", s->name);
        c = CPARAM;
    }
    if(typesu[t->etype] && t->width <= 0)
        diag(Z, "incomplete structure: %s", t->tag->name);
    adecl(c, t, s);
}
@

<<function xdecl>>=
void
xdecl(int c, Type *t, Sym *s)
{
    long o;

    o = 0;
    switch(c) {
    case CEXREG:
        o = exreg(t);
        if(o == 0)
            c = CEXTERN;
        if(s->class == CGLOBL)
            c = CGLOBL;
        break;

    case CEXTERN:
        if(s->class == CGLOBL)
            c = CGLOBL;
        break;

    case CXXX:
        c = CGLOBL;
        if(s->class == CEXTERN)
            s->class = CGLOBL;
        break;

    case CAUTO:
        diag(Z, "overspecified class: %s %s %s", s->name, cnames[c], cnames[s->class]);
        c = CEXTERN;
        break;

    case CTYPESTR:
        if(!typesuv[t->etype]) {
            diag(Z, "typestr must be struct/union: %s", s->name);
            break;
        }
        dclfunct(t, s);
        break;
    }

    if(s->class == CSTATIC)
        if(c == CEXTERN || c == CGLOBL) {
            warn(Z, "overspecified class: %s %s %s", s->name, cnames[c], cnames[s->class]);
            c = CSTATIC;
        }
    if(s->type != T)
        if(s->class != c || !sametype(t, s->type) || t->etype == TENUM) {
            diag(Z, "external redeclaration of: %s", s->name);
            Bprint(&diagbuf, "	%s %T %L\n", cnames[c], t, nearln);
            Bprint(&diagbuf, "	%s %T %L\n", cnames[s->class], s->type, s->varlineno);
        }
    tmerge(t, s);
    s->type = t;
    s->class = c;
    s->block = 0;
    s->offset = o;
}
@

<<function tmerge>>=
void
tmerge(Type *t1, Sym *s)
{
    Type *ta, *tb, *t2;

    t2 = s->type;
/*print("merge	%T; %T\n", t1, t2);/**/
    for(;;) {
        if(t1 == T || t2 == T || t1 == t2)
            break;
        if(t1->etype != t2->etype)
            break;
        switch(t1->etype) {
        case TFUNC:
            ta = t1->down;
            tb = t2->down;
            if(ta == T) {
                t1->down = tb;
                break;
            }
            if(tb == T)
                break;
            while(ta != T && tb != T) {
                if(ta == tb)
                    break;
                /* ignore old-style flag */
                if(ta->etype == TOLD) {
                    ta = ta->down;
                    continue;
                }
                if(tb->etype == TOLD) {
                    tb = tb->down;
                    continue;
                }
                /* checking terminated by ... */
                if(ta->etype == TDOT && tb->etype == TDOT) {
                    ta = T;
                    tb = T;
                    break;
                }
                if(!sametype(ta, tb))
                    break;
                ta = ta->down;
                tb = tb->down;
            }
            if(ta != tb)
                diag(Z, "function inconsistently declared: %s", s->name);

            /* take new-style over old-style */
            ta = t1->down;
            tb = t2->down;
            if(ta != T && ta->etype == TOLD)
                if(tb != T && tb->etype != TOLD)
                    t1->down = tb;
            break;

        case TARRAY:
            /* should we check array size change? */
            if(t2->width > t1->width)
                t1->width = t2->width;
            break;

        case TUNION:
        case TSTRUCT:
            return;
        }
        t1 = t1->link;
        t2 = t2->link;
    }
}
@

<<function edecl>>=
void
edecl(int c, Type *t, Sym *s)
{
    Type *t1;

    if(s == S) {
        if(!typesu[t->etype])
            diag(Z, "unnamed structure element must be struct/union");
        if(c != CXXX)
            diag(Z, "unnamed structure element cannot have class");
    } else
        if(c != CXXX)
            diag(Z, "structure element cannot have class: %s", s->name);
    t1 = t;
    t = copytyp(t1);
    t->sym = s;
    t->down = T;
    if(lastfield) {
        t->shift = lastbit - lastfield;
        t->nbits = lastfield;
        if(firstbit)
            t->shift = -t->shift;
        if(typeu[t->etype])
            t->etype = tufield->etype;
        else
            t->etype = tfield->etype;
    }
    if(strf == T)
        strf = t;
    else
        strl->down = t;
    strl = t;
}
@

<<function maxtype>>=
/*
 * this routine is very suspect.
 * ansi requires the enum type to
 * be represented as an 'int'
 * this means that 0x81234567
 * would be illegal. this routine
 * makes signed and unsigned go
 * to unsigned.
 */
Type*
maxtype(Type *t1, Type *t2)
{

    if(t1 == T)
        return t2;
    if(t2 == T)
        return t1;
    if(t1->etype > t2->etype)
        return t1;
    return t2;
}
@

<<function doenum>>=
void
doenum(Sym *s, Node *n)
{

    if(n) {
        complex(n);
        if(n->op != OCONST) {
            diag(n, "enum not a constant: %s", s->name);
            return;
        }
        en.cenum = n->type;
        en.tenum = maxtype(en.cenum, en.tenum);

        if(!typefd[en.cenum->etype])
            en.lastenum = n->vconst;
        else
            en.floatenum = n->fconst;
    }
    if(dclstack)
        push1(s);
    xdecl(CXXX, types[TENUM], s);

    if(en.cenum == T) {
        en.tenum = types[TINT];
        en.cenum = types[TINT];
        en.lastenum = 0;
    }
    s->tenum = en.cenum;

    if(!typefd[s->tenum->etype]) {
        s->vconst = convvtox(en.lastenum, s->tenum->etype);
        en.lastenum++;
    } else {
        s->fconst = en.floatenum;
        en.floatenum++;
    }

    if(debug['d'])
        dbgdecl(s);
    acidvar(s);
}
@

<<function symadjust>>=
void
symadjust(Sym *s, Node *n, long del)
{

    switch(n->op) {
    default:
        if(n->left)
            symadjust(s, n->left, del);
        if(n->right)
            symadjust(s, n->right, del);
        return;

    case ONAME:
        if(n->sym == s)
            n->xoffset -= del;
        return;

    case OCONST:
    case OSTRING:
    case OLSTRING:
    case OINDREG:
    case OREGISTER:
        return;
    }
}
@

<<function contig>>=
Node*
contig(Sym *s, Node *n, long v)
{
    Node *p, *r, *q, *m;
    long w;
    Type *zt;

    if(debug['i']) {
        print("contig v = %ld; s = %s\n", v, s->name);
        prtree(n, "doinit value");
    }

    if(n == Z)
        goto no;
    w = s->type->width;

    /*
     * nightmare: an automatic array whose size
     * increases when it is initialized
     */
    if(v != w) {
        if(v != 0)
            diag(n, "automatic adjustable array: %s", s->name);
        v = s->offset;
        autoffset = align(autoffset, s->type, Aaut3);
        s->offset = -autoffset;
        stkoff = maxround(stkoff, autoffset);
        symadjust(s, n, v - s->offset);
    }
    if(w <= ewidth[TIND])
        goto no;
    if(n->op == OAS)
        diag(Z, "oops in contig");
/*ZZZ this appears incorrect
need to check if the list completely covers the data.
if not, bail
 */
    if(n->op == OLIST)
        goto no;
    if(n->op == OASI)
        if(n->left->type)
        if(n->left->type->width == w)
            goto no;
    while(w & (ewidth[TIND]-1))
        w++;
/*
 * insert the following code, where long becomes vlong if pointers are fat
 *
    *(long**)&X = (long*)((char*)X + sizeof(X));
    do {
        *(long**)&X -= 1;
        **(long**)&X = 0;
    } while(*(long**)&X);
 */

    for(q=n; q->op != ONAME; q=q->left)
        ;

    zt = ewidth[TIND] > ewidth[TLONG]? types[TVLONG]: types[TLONG];

    p = new(ONAME, Z, Z);
    *p = *q;
    p->type = typ(TIND, zt);
    p->xoffset = s->offset;

    r = new(ONAME, Z, Z);
    *r = *p;
    r = new(OPOSTDEC, r, Z);

    q = new(ONAME, Z, Z);
    *q = *p;
    q = new(OIND, q, Z);

    m = new(OCONST, Z, Z);
    m->vconst = 0;
    m->type = zt;

    q = new(OAS, q, m);

    r = new(OLIST, r, q);

    q = new(ONAME, Z, Z);
    *q = *p;
    r = new(ODWHILE, q, r);

    q = new(ONAME, Z, Z);
    *q = *p;
    q->type = q->type->link;
    q->xoffset += w;
    q = new(OADDR, q, 0);

    q = new(OASI, p, q);
    r = new(OLIST, q, r);

    n = new(OLIST, r, n);

no:
    return n;
}
@


%-------------------------------------------------------------

<<cc/dcl.c>>=
#include "cc.h"

<<function dodecl>>

<<function mkstatic>>

<<function tcopy>>

<<function doinit>>

<<function peekinit>>

<<function nextinit>>

<<function isstruct>>

<<function init1>>

<<function newlist>>

<<function sualign>>

<<function round>>

<<function ofnproto>>

<<constant ANSIPROTO>>
<<constant OLDPROTO>>

<<function argmark>>

<<function walkparam>>

<<function markdcl>>

<<function revertdcl>>

<<function fnproto>>

<<function anyproto>>

<<function fnproto1>>

<<function dbgdecl>>

<<function push>>

<<function push1>>

<<function sametype>>

<<function rsametype>>

typedef struct Typetab Typetab;

<<struct Typetab>>

<<function sigind>>

<<function signat>>

<<function signature>>

<<function sign>>

<<function snap>>

<<function dotag>>

<<function dcllabel>>

<<function paramconv>>

<<function adecl>>

<<function pdecl>>

<<function xdecl>>

<<function tmerge>>

<<function edecl>>

<<function maxtype>>

<<function doenum>>

<<function symadjust>>

<<function contig>>
@


\subsection*{[[cc/funct.c]]}

<<struct Ftab>>=
struct	Ftab
{
    char	op;
    char*	name;
    char	typ;
};
@

<<struct Gtab>>=
struct	Gtab
{
    char	etype;
    char*	name;
};
@

<<global gtabinit>>=
//Gtab	gtabinit[NTYPE];

Gtab	gtabinit[NTYPE] =
{
    TCHAR,		"c",
    TUCHAR,		"uc",
    TSHORT,		"h",
    TUSHORT,	"uh",
    TINT,		"i",
    TUINT,		"ui",
    TLONG,		"l",
    TULONG,		"ul",
    TVLONG,		"v",
    TUVLONG,	"uv",
    TFLOAT,		"f",
    TDOUBLE,	"d",
    TXXX
};
@

<<global ftabinit>>=
Ftab	ftabinit[OEND] =
{
    OADD,		"add",		1,
    OAND,		"and",		1,
    OASHL,		"ashl",		1,
    OASHR,		"ashr",		1,
    ODIV,		"div",		1,
    OLDIV,		"ldiv",		1,
    OLMOD,		"lmod",		1,
    OLMUL,		"lmul",		1,
    OLSHR,		"lshr",		1,
    OMOD,		"mod",		1,
    OMUL,		"mul",		1,
    OOR,		"or",		1,
    OSUB,		"sub",		1,
    OXOR,		"xor",		1,

    OEQ,		"eq",		2,
    OGE,		"ge",		2,
    OGT,		"gt",		2,
    OHI,		"hi",		2,
    OHS,		"hs",		2,
    OLE,		"le",		2,
    OLO,		"lo",		2,
    OLS,		"ls",		2,
    OLT,		"lt",		2,
    ONE,		"ne",		2,

    OASADD,		"asadd",	3,
    OASAND,		"asand",	3,
    OASASHL,	"asashl",	3,
    OASASHR,	"asashr",	3,
    OASDIV,		"asdiv",	3,
    OASLDIV,	"asldiv",	3,
    OASLMOD,	"aslmod",	3,
    OASLMUL,	"aslmul",	3,
    OASLSHR,	"aslshr",	3,
    OASMOD,		"asmod",	3,
    OASMUL,		"asmul",	3,
    OASOR,		"asor",		3,
    OASSUB,		"assub",	3,
    OASXOR,		"asxor",	3,

    OPOS,		"pos",		4,
    ONEG,		"neg",		4,
    OCOM,		"com",		4,
    ONOT,		"not",		4,

//	OPOSTDEC,
//	OPOSTINC,
//	OPREDEC,
//	OPREINC,

    OXXX,
};
@

<<function isfunct>>=
//	Node*	nodmmv;


int
isfunct(Node *n)
{
    Type *t, *t1;
    Funct *f;
    Node *l;
    Sym *s;
    int o;

    o = n->op;
    if(n->left == Z)
        goto no;
    t = n->left->type;
    if(t == T)
        goto no;
    f = t->funct;

    switch(o) {
    case OAS:	// put cast on rhs
    case OASI:
    case OASADD:
    case OASAND:
    case OASASHL:
    case OASASHR:
    case OASDIV:
    case OASLDIV:
    case OASLMOD:
    case OASLMUL:
    case OASLSHR:
    case OASMOD:
    case OASMUL:
    case OASOR:
    case OASSUB:
    case OASXOR:
        if(n->right == Z)
            goto no;
        t1 = n->right->type;
        if(t1 == T)
            goto no;
        if(t1->funct == f)
            break;

        l = new(OXXX, Z, Z);
        *l = *n->right;

        n->right->left = l;
        n->right->right = Z;
        n->right->type = t;
        n->right->op = OCAST;

        if(!isfunct(n->right))
            prtree(n, "isfunc !");
        break;

    case OCAST:	// t f(T) or T f(t)
        t1 = n->type;
        if(t1 == T)
            goto no;
        if(f != nil) {
            s = f->castfr[t1->etype];
            if(s == S)
                goto no;
            n->right = n->left;
            goto build;
        }
        f = t1->funct;
        if(f != nil) {
            s = f->castto[t->etype];
            if(s == S)
                goto no;
            n->right = n->left;
            goto build;
        }
        goto no;
    }

    if(f == nil)
        goto no;
    s = f->sym[o];
    if(s == S)
        goto no;

    /*
     * the answer is yes,
     * now we rewrite the node
     * and give diagnostics
     */
    switch(o) {
    default:
        diag(n, "isfunct op missing %O\n", o);
        goto bad;

    case OADD:	// T f(T, T)
    case OAND:
    case OASHL:
    case OASHR:
    case ODIV:
    case OLDIV:
    case OLMOD:
    case OLMUL:
    case OLSHR:
    case OMOD:
    case OMUL:
    case OOR:
    case OSUB:
    case OXOR:

    case OEQ:	// int f(T, T)
    case OGE:
    case OGT:
    case OHI:
    case OHS:
    case OLE:
    case OLO:
    case OLS:
    case OLT:
    case ONE:
        if(n->right == Z)
            goto bad;
        t1 = n->right->type;
        if(t1 == T)
            goto bad;
        if(t1->funct != f)
            goto bad;
        n->right = new(OLIST, n->left, n->right);
        break;

    case OAS:	// structure copies done by the compiler
    case OASI:
        goto no;

    case OASADD:	// T f(T*, T)
    case OASAND:
    case OASASHL:
    case OASASHR:
    case OASDIV:
    case OASLDIV:
    case OASLMOD:
    case OASLMUL:
    case OASLSHR:
    case OASMOD:
    case OASMUL:
    case OASOR:
    case OASSUB:
    case OASXOR:
        if(n->right == Z)
            goto bad;
        t1 = n->right->type;
        if(t1 == T)
            goto bad;
        if(t1->funct != f)
            goto bad;
        n->right = new(OLIST, new(OADDR, n->left, Z), n->right);
        break;

    case OPOS:	// T f(T)
    case ONEG:
    case ONOT:
    case OCOM:
        n->right = n->left;
        break;


    }

build:
    l = new(ONAME, Z, Z);
    l->sym = s;
    l->type = s->type;
    l->etype = s->type->etype;
    l->xoffset = s->offset;
    l->class = s->class;
    tcomo(l, 0);

    n->op = OFUNC;
    n->left = l;
    n->type = l->type->link;
    if(tcompat(n, T, l->type, tfunct))
        goto bad;
    if(tcoma(n->left, n->right, l->type->down, 1))
        goto bad;
    return 1;

no:
    return 0;

bad:
    diag(n, "cant rewrite typestr for op %O\n", o);
    prtree(n, "isfunct");
    n->type = T;
    return 1;
}
@

<<function dclfunct>>=
void
dclfunct(Type *t, Sym *s)
{
    Funct *f;
    Node *n;
    Type *f1, *f2, *f3, *f4;
    int o, i, c;
    char str[100];

    if(t->funct)
        return;

    // recognize generated tag of dorm _%d_
    if(t->tag == S)
        goto bad;
    for(i=0; c = t->tag->name[i]; i++) {
        if(c == '_') {
            if(i == 0 || t->tag->name[i+1] == 0)
                continue;
            break;
        }
        if(c < '0' || c > '9')
            break;
    }
    if(c == 0)
        goto bad;

    f = alloc(sizeof(*f));
    for(o=0; o<sizeof(f->sym); o++)
        f->sym[o] = S;

    t->funct = f;

    f1 = typ(TFUNC, t);
    f1->down = copytyp(t);
    f1->down->down = t;

    f2 = typ(TFUNC, types[TINT]);
    f2->down = copytyp(t);
    f2->down->down = t;

    f3 = typ(TFUNC, t);
    f3->down = typ(TIND, t);
    f3->down->down = t;

    f4 = typ(TFUNC, t);
    f4->down = t;

    for(i=0;; i++) {
        o = ftabinit[i].op;
        if(o == OXXX)
            break;
        sprint(str, "%s_%s_", t->tag->name, ftabinit[i].name);
        n = new(ONAME, Z, Z);
        n->sym = slookup(str);
        f->sym[o] = n->sym;
        switch(ftabinit[i].typ) {
        default:
            diag(Z, "dclfunct op missing %d\n", ftabinit[i].typ);
            break;

        case 1:	// T f(T,T)	+
            dodecl(xdecl, CEXTERN, f1, n);
            break;

        case 2:	// int f(T,T)	==
            dodecl(xdecl, CEXTERN, f2, n);
            break;

        case 3:	// void f(T*,T)	+=
            dodecl(xdecl, CEXTERN, f3, n);
            break;

        case 4:	// T f(T)	~
            dodecl(xdecl, CEXTERN, f4, n);
            break;
        }
    }
    for(i=0;; i++) {
        o = gtabinit[i].etype;
        if(o == TXXX)
            break;

        /*
         * OCAST types T1 _T2_T1_(T2)
         */
        sprint(str, "_%s%s_", gtabinit[i].name, t->tag->name);
        n = new(ONAME, Z, Z);
        n->sym = slookup(str);
        f->castto[o] = n->sym;

        f1 = typ(TFUNC, t);
        f1->down = types[o];
        dodecl(xdecl, CEXTERN, f1, n);

        sprint(str, "%s_%s_", t->tag->name, gtabinit[i].name);
        n = new(ONAME, Z, Z);
        n->sym = slookup(str);
        f->castfr[o] = n->sym;

        f1 = typ(TFUNC, types[o]);
        f1->down = t;
        dodecl(xdecl, CEXTERN, f1, n);
    }
    return;
bad:
    diag(Z, "dclfunct bad %T %s\n", t, s->name);
}
@


%-------------------------------------------------------------

<<cc/funct.c>>=
#include	"cc.h"

typedef	struct	Ftab	Ftab;
<<struct Ftab>>
typedef	struct	Gtab	Gtab;
<<struct Gtab>>

//Ftab	ftabinit[OEND];
<<global gtabinit>>

<<global ftabinit>>

//	Node*	nodtestv;

//	Node*	nodvpp;
//	Node*	nodppv;
//	Node*	nodvmm;
<<function isfunct>>

<<function dclfunct>>

@


\subsection*{[[cc/scon.c]]}

<<function acast>>=
static Node*
acast(Type *t, Node *n)
{
    if(n->type->etype != t->etype || n->op == OBIT) {
        n = new1(OCAST, n, Z);
        if(nocast(n->left->type, t))
            *n = *n->left;
        n->type = t;
    }
    return n;
}
@

<<function evconst>>=
void
evconst(Node *n)
{
    Node *l, *r;
    int et, isf;
    vlong v;
    double d;

    if(n == Z || n->type == T)
        return;

    et = n->type->etype;
    isf = typefd[et];

    l = n->left;
    r = n->right;

    d = 0;
    v = 0;

    switch(n->op) {
    default:
        return;

    case ONEG:
        if(isf)
            d = -l->fconst;
        else
            v = -l->vconst;
        break;

    case OCOM:
        v = ~l->vconst;
        break;

    case OCAST:
        if(et == TVOID)
            return;
        et = l->type->etype;
        if(isf) {
            if(typefd[et])
                d = l->fconst;
            else
                d = l->vconst;
        } else {
            if(typefd[et])
                v = l->fconst;
            else
                v = convvtox(l->vconst, n->type->etype);
        }
        break;

    case OCONST:
        break;

    case OADD:
        if(isf)
            d = l->fconst + r->fconst;
        else {
            v = l->vconst + r->vconst;
        }
        break;

    case OSUB:
        if(isf)
            d = l->fconst - r->fconst;
        else
            v = l->vconst - r->vconst;
        break;

    case OMUL:
        if(isf)
            d = l->fconst * r->fconst;
        else {
            v = l->vconst * r->vconst;
        }
        break;

    case OLMUL:
        v = (uvlong)l->vconst * (uvlong)r->vconst;
        break;


    case ODIV:
        if(vconst(r) == 0) {
            warn(n, "divide by zero");
            return;
        }
        if(isf)
            d = l->fconst / r->fconst;
        else
            v = l->vconst / r->vconst;
        break;

    case OLDIV:
        if(vconst(r) == 0) {
            warn(n, "divide by zero");
            return;
        }
        v = (uvlong)l->vconst / (uvlong)r->vconst;
        break;

    case OMOD:
        if(vconst(r) == 0) {
            warn(n, "modulo by zero");
            return;
        }
        v = l->vconst % r->vconst;
        break;

    case OLMOD:
        if(vconst(r) == 0) {
            warn(n, "modulo by zero");
            return;
        }
        v = (uvlong)l->vconst % (uvlong)r->vconst;
        break;

    case OAND:
        v = l->vconst & r->vconst;
        break;

    case OOR:
        v = l->vconst | r->vconst;
        break;

    case OXOR:
        v = l->vconst ^ r->vconst;
        break;

    case OLSHR:
        v = (uvlong)l->vconst >> r->vconst;
        break;

    case OASHR:
        v = l->vconst >> r->vconst;
        break;

    case OASHL:
        v = l->vconst << r->vconst;
        break;

    case OLO:
        v = (uvlong)l->vconst < (uvlong)r->vconst;
        break;

    case OLT:
        if(typefd[l->type->etype])
            v = l->fconst < r->fconst;
        else
            v = l->vconst < r->vconst;
        break;

    case OHI:
        v = (uvlong)l->vconst > (uvlong)r->vconst;
        break;

    case OGT:
        if(typefd[l->type->etype])
            v = l->fconst > r->fconst;
        else
            v = l->vconst > r->vconst;
        break;

    case OLS:
        v = (uvlong)l->vconst <= (uvlong)r->vconst;
        break;

    case OLE:
        if(typefd[l->type->etype])
            v = l->fconst <= r->fconst;
        else
            v = l->vconst <= r->vconst;
        break;

    case OHS:
        v = (uvlong)l->vconst >= (uvlong)r->vconst;
        break;

    case OGE:
        if(typefd[l->type->etype])
            v = l->fconst >= r->fconst;
        else
            v = l->vconst >= r->vconst;
        break;

    case OEQ:
        if(typefd[l->type->etype])
            v = l->fconst == r->fconst;
        else
            v = l->vconst == r->vconst;
        break;

    case ONE:
        if(typefd[l->type->etype])
            v = l->fconst != r->fconst;
        else
            v = l->vconst != r->vconst;
        break;

    case ONOT:
        if(typefd[l->type->etype])
            v = !l->fconst;
        else
            v = !l->vconst;
        break;

    case OANDAND:
        if(typefd[l->type->etype])
            v = l->fconst && r->fconst;
        else
            v = l->vconst && r->vconst;
        break;

    case OOROR:
        if(typefd[l->type->etype])
            v = l->fconst || r->fconst;
        else
            v = l->vconst || r->vconst;
        break;
    }
    if(isf) {
        n->fconst = d;
    } else {
        n->vconst = convvtox(v, n->type->etype);
    }
    n->oldop = n->op;
    n->op = OCONST;
}
@

<<function acom>>=
void
acom(Node *n)
{
    Type *t;
    Node *l, *r;
    int i;

    switch(n->op)
    {

    case ONAME:
    case OCONST:
    case OSTRING:
    case OINDREG:
    case OREGISTER:
        return;

    case ONEG:
        l = n->left;
        if(addo(n) && addo(l))
            break;
        acom(l);
        return;

    case OADD:
    case OSUB:
    case OMUL:
        l = n->left;
        r = n->right;
        if(addo(n)) {
            if(addo(r))
                break;
            if(addo(l))
                break;
        }
        acom(l);
        acom(r);
        return;

    default:
        l = n->left;
        r = n->right;
        if(l != Z)
            acom(l);
        if(r != Z)
            acom(r);
        return;
    }

    /* bust terms out */
    t = n->type;
    term[0].mult = 0;
    term[0].node = Z;
    nterm = 1;
    acom1(1, n);
    if(debug['m'])
    for(i=0; i<nterm; i++) {
        print("%d %3lld ", i, term[i].mult);
        prtree1(term[i].node, 1, 0);
    }
    if(nterm < NTERM)
        acom2(n, t);
    n->type = t;
}
@

<<function acomcmp1>>=
int
acomcmp1(const void *a1, const void *a2)
{
    vlong c1, c2;
    Term *t1, *t2;

    t1 = (Term*)a1;
    t2 = (Term*)a2;
    c1 = t1->mult;
    if(c1 < 0)
        c1 = -c1;
    c2 = t2->mult;
    if(c2 < 0)
        c2 = -c2;
    if(c1 > c2)
        return 1;
    if(c1 < c2)
        return -1;
    c1 = 1;
    if(t1->mult < 0)
        c1 = 0;
    c2 = 1;
    if(t2->mult < 0)
        c2 = 0;
    if(c2 -= c1)
        return c2;
    if(t2 > t1)
        return 1;
    return -1;
}
@

<<function acomcmp2>>=
int
acomcmp2(const void *a1, const void *a2)
{
    vlong c1, c2;
    Term *t1, *t2;

    t1 = (Term*)a1;
    t2 = (Term*)a2;
    c1 = t1->mult;
    c2 = t2->mult;
    if(c1 > c2)
        return 1;
    if(c1 < c2)
        return -1;
    if(t2 > t1)
        return 1;
    return -1;
}
@

<<function acom2>>=
void
acom2(Node *n, Type *t)
{
    Node *l, *r;
    Term trm[NTERM];
    int et, nt, i, j;
    vlong c1, c2;

    /*
     * copy into automatic
     */
    c2 = 0;
    nt = nterm;
    for(i=0; i<nt; i++)
        trm[i] = term[i];
    /*
     * recur on subtrees
     */
    j = 0;
    for(i=1; i<nt; i++) {
        c1 = trm[i].mult;
        if(c1 == 0)
            continue;
        l = trm[i].node;
        if(l != Z) {
            j = 1;
            acom(l);
        }
    }
    c1 = trm[0].mult;
    if(j == 0) {
        n->oldop = n->op;
        n->op = OCONST;
        n->vconst = c1;
        return;
    }
    et = t->etype;

    /*
     * prepare constant term,
     * combine it with an addressing term
     */
    if(c1 != 0) {
        l = new1(OCONST, Z, Z);
        l->type = t;
        l->vconst = c1;
        trm[0].mult = 1;
        for(i=1; i<nt; i++) {
            if(trm[i].mult != 1)
                continue;
            r = trm[i].node;
            if(r->op != OADDR)
                continue;
            r->type = t;
            l = new1(OADD, r, l);
            l->type = t;
            trm[i].mult = 0;
            break;
        }
        trm[0].node = l;
    }
    /*
     * look for factorable terms
     * c1*i + c1*c2*j -> c1*(i + c2*j)
     */
    qsort(trm+1, nt-1, sizeof(trm[0]), acomcmp1);
    for(i=nt-1; i>=0; i--) {
        c1 = trm[i].mult;
        if(c1 < 0)
            c1 = -c1;
        if(c1 <= 1)
            continue;
        for(j=i+1; j<nt; j++) {
            c2 = trm[j].mult;
            if(c2 < 0)
                c2 = -c2;
            if(c2 <= 1)
                continue;
            if(c2 % c1)
                continue;
            r = trm[j].node;
            if(r->type->etype != et)
                r = acast(t, r);
            c2 = trm[j].mult/trm[i].mult;
            if(c2 != 1 && c2 != -1) {
                r = new1(OMUL, r, new(OCONST, Z, Z));
                r->type = t;
                r->right->type = t;
                r->right->vconst = c2;
            }
            l = trm[i].node;
            if(l->type->etype != et)
                l = acast(t, l);
            r = new1(OADD, l, r);
            r->type = t;
            if(c2 == -1)
                r->op = OSUB;
            trm[i].node = r;
            trm[j].mult = 0;
        }
    }
    if(debug['m']) {
        print("\n");
        for(i=0; i<nt; i++) {
            print("%d %3lld ", i, trm[i].mult);
            prtree1(trm[i].node, 1, 0);
        }
    }

    /*
     * put it all back together
     */
    qsort(trm+1, nt-1, sizeof(trm[0]), acomcmp2);
    l = Z;
    for(i=nt-1; i>=0; i--) {
        c1 = trm[i].mult;
        if(c1 == 0)
            continue;
        r = trm[i].node;
        if(r->type->etype != et || r->op == OBIT)
            r = acast(t, r);
        if(c1 != 1 && c1 != -1) {
            r = new1(OMUL, r, new(OCONST, Z, Z));
            r->type = t;
            r->right->type = t;
            if(c1 < 0) {
                r->right->vconst = -c1;
                c1 = -1;
            } else {
                r->right->vconst = c1;
                c1 = 1;
            }
        }
        if(l == Z) {
            l = r;
            c2 = c1;
            continue;
        }
        if(c1 < 0)
            if(c2 < 0)
                l = new1(OADD, l, r);
            else
                l = new1(OSUB, l, r);
        else
            if(c2 < 0) {
                l = new1(OSUB, r, l);
                c2 = 1;
            } else
                l = new1(OADD, l, r);
        l->type = t;
    }
    if(c2 < 0) {
        r = new1(OCONST, 0, 0);
        r->vconst = 0;
        r->type = t;
        l = new1(OSUB, r, l);
        l->type = t;
    }
    *n = *l;
}
@

<<function acom1>>=
void
acom1(vlong v, Node *n)
{
    Node *l, *r;

    if(v == 0 || nterm >= NTERM)
        return;
    if(!addo(n)) {
        if(n->op == OCONST)
        if(!typefd[n->type->etype]) {
            term[0].mult += v*n->vconst;
            return;
        }
        term[nterm].mult = v;
        term[nterm].node = n;
        nterm++;
        return;
    }
    switch(n->op) {

    case OCAST:
        acom1(v, n->left);
        break;

    case ONEG:
        acom1(-v, n->left);
        break;

    case OADD:
        acom1(v, n->left);
        acom1(v, n->right);
        break;

    case OSUB:
        acom1(v, n->left);
        acom1(-v, n->right);
        break;

    case OMUL:
        l = n->left;
        r = n->right;
        if(l->op == OCONST)
        if(!typefd[n->type->etype]) {
            acom1(v*l->vconst, r);
            break;
        }
        if(r->op == OCONST)
        if(!typefd[n->type->etype]) {
            acom1(v*r->vconst, l);
            break;
        }
        break;

    default:
        diag(n, "not addo");
    }
}
@

<<function addo>>=
int
addo(Node *n)
{

    if(n != Z)
    if(!typefd[n->type->etype])
    if(!typev[n->type->etype] || ewidth[TVLONG] == ewidth[TIND])
    switch(n->op) {

    case OCAST:
        if(nilcast(n->left->type, n->type))
            return 1;
        break;

    case ONEG:
    case OADD:
    case OSUB:
        return 1;

    case OMUL:
        if(n->left->op == OCONST)
            return 1;
        if(n->right->op == OCONST)
            return 1;
    }
    return 0;
}
@


%-------------------------------------------------------------

<<cc/scon.c>>=
#include "cc.h"

<<function acast>>


<<function evconst>>

<<function acom>>

<<function acomcmp1>>

<<function acomcmp2>>

<<function acom2>>

<<function acom1>>

<<function addo>>
@


\subsection*{[[cc/dpchk.c]]}

<<enum _anon_ (cc/dpchk.c)>>=
enum
{
    Fnone	= 0,
    Fl,
    Fvl,
    Fignor,
    Fstar,
    Fadj,

    Fverb	= 10,
};
@

<<struct Tprot>>=
struct	Tprot
{
    Type*	type;
    Bits	flag;
    Tprot*	link;
};
@

<<struct Tname>>=
struct	Tname
{
    char*	name;
    int	param;
    Tname*	link;
};
@

<<global indchar>>=
static	Type*	indchar;
@

<<global flagbits>>=
static	uchar	flagbits[512];
@

<<global fmtbuf>>=
static	char	fmtbuf[100];
@

<<global lastadj>>=
static	int	lastadj;
@

<<global lastverb>>=
static	int	lastverb;
@

<<global nstar>>=
static	int	nstar;
@

<<global tprot>>=
static	Tprot*	tprot;
@

<<global tname>>=
static	Tname*	tname;
@

<<function argflag>>=
void
argflag(int c, int v)
{

    switch(v) {
    case Fignor:
    case Fstar:
    case Fl:
    case Fvl:
        flagbits[c] = v;
        break;
    case Fverb:
        flagbits[c] = lastverb;
/*print("flag-v %c %d\n", c, lastadj);*/
        lastverb++;
        break;
    case Fadj:
        flagbits[c] = lastadj;
/*print("flag-l %c %d\n", c, lastadj);*/
        lastadj++;
        break;
    }
}
@

<<function getflag>>=
Bits
getflag(char *s)
{
    Bits flag;
    int f;
    char *fmt;
    Rune c;

    fmt = fmtbuf;
    flag = zbits;
    nstar = 0;
    for(;;) {
        s += chartorune(&c, s);
        fmt += runetochar(fmt, &c);
        if(c == 0 || c >= nelem(flagbits))
            break;
        f = flagbits[c];
        switch(f) {
        case Fnone:
            argflag(c, Fverb);
            f = flagbits[c];
            break;
        case Fstar:
            nstar++;
        case Fignor:
            continue;
        case Fl:
            if(bset(flag, Fl))
                flag = bor(flag, blsh(Fvl));
        }
        flag = bor(flag, blsh(f));
        if(f >= Fverb)
            break;
    }
    *fmt = 0;
    return flag;
}
@

<<function newprot>>=
void
newprot(Sym *m, Type *t, char *s)
{
    Bits flag;
    Tprot *l;

    if(t == T) {
        warn(Z, "%s: newprot: type not defined", m->name);
        return;
    }
    flag = getflag(s);
    for(l=tprot; l; l=l->link)
        if(beq(flag, l->flag) && sametype(t, l->type))
            return;
    l = alloc(sizeof(*l));
    l->type = t;
    l->flag = flag;
    l->link = tprot;
    tprot = l;
}
@

<<function newname>>=
void
newname(char *s, int p)
{
    Tname *l;

    for(l=tname; l; l=l->link)
        if(strcmp(l->name, s) == 0) {
            if(l->param != p)
                yyerror("vargck %s already defined\n", s);
            return;
        }
    l = alloc(sizeof(*l));
    l->name = s;
    l->param = p;
    l->link = tname;
    tname = l;
}
@

<<function arginit>>=
void
arginit(void)
{
    int i;

/* debug['F'] = 1;*/
/* debug['w'] = 1;*/

    lastadj = Fadj;
    lastverb = Fverb;
    indchar = typ(TIND, types[TCHAR]);

    memset(flagbits, Fnone, sizeof(flagbits));

    for(i='0'; i<='9'; i++)
        argflag(i, Fignor);
    argflag('.', Fignor);
    argflag('#', Fignor);
    argflag('u', Fignor);
    argflag('h', Fignor);
    argflag('+', Fignor);
    argflag('-', Fignor);

    argflag('*', Fstar);
    argflag('l', Fl);

    argflag('o', Fverb);
    flagbits['x'] = flagbits['o'];
    flagbits['X'] = flagbits['o'];
}
@

<<function pragvararg>>=
void
pragvararg(void)
{
    Sym *s;
    int n, c;
    char *t;
    Rune r;
    Type *ty;

    if(!debug['F'])
        goto out;
    s = getsym();
    if(s && strcmp(s->name, "argpos") == 0)
        goto ckpos;
    if(s && strcmp(s->name, "type") == 0)
        goto cktype;
    if(s && strcmp(s->name, "flag") == 0)
        goto ckflag;
    yyerror("syntax in #pragma varargck");
    goto out;

ckpos:
/*#pragma	varargck	argpos	warn	2*/
    s = getsym();
    if(s == S)
        goto bad;
    n = getnsn();
    if(n < 0)
        goto bad;
    newname(s->name, n);
    goto out;

ckflag:
/*#pragma	varargck	flag	'c'*/
    c = getnsc();
    if(c != '\'')
        goto bad;
    c = getr();
    if(c == '\\')
        c = getr();
    else if(c == '\'')
        goto bad;
    if(c == '\n')
        goto bad;
    if(getc() != '\'')
        goto bad;
    argflag(c, Fignor);
    goto out;

cktype:
/*#pragma	varargck	type	O	int*/
    c = getnsc();
    if(c != '"')
        goto bad;
    t = fmtbuf;
    for(;;) {
        r = getr();
        if(r == ' ' || r == '\n')
            goto bad;
        if(r == '"')
            break;
        t += runetochar(t, &r);
    }
    *t = 0;
    t = strdup(fmtbuf);
    s = getsym();
    if(s == S)
        goto bad;
    ty = s->type;
    while((c = getnsc()) == '*')
        ty = typ(TIND, ty);
    unget(c);
    newprot(s, ty, t);
    goto out;

bad:
    yyerror("syntax in #pragma varargck");

out:
    while(getnsc() != '\n')
        ;
}
@

<<function nextarg>>=
Node*
nextarg(Node *n, Node **a)
{
    if(n == Z) {
        *a = Z;
        return Z;
    }
    if(n->op == OLIST) {
        *a = n->left;
        return n->right;
    }
    *a = n;
    return Z;
}
@

<<function checkargs>>=
void
checkargs(Node *nn, char *s, int pos)
{
    Node *a, *n;
    Bits flag;
    Tprot *l;

    if(!debug['F'])
        return;
    n = nn;
    for(;;) {
        s = strchr(s, '%');
        if(s == 0) {
            nextarg(n, &a);
            if(a != Z)
                warn(nn, "more arguments than format %T",
                    a->type);
            return;
        }
        s++;
        flag = getflag(s);
        while(nstar > 0) {
            n = nextarg(n, &a);
            pos++;
            nstar--;
            if(a == Z) {
                warn(nn, "more format than arguments %s",
                    fmtbuf);
                return;
            }
            if(a->type == T)
                continue;
            if(!sametype(types[TINT], a->type) &&
               !sametype(types[TUINT], a->type))
                warn(nn, "format mismatch '*' in %s %T, arg %d",
                    fmtbuf, a->type, pos);
        }
        for(l=tprot; l; l=l->link)
            if(sametype(types[TVOID], l->type)) {
                if(beq(flag, l->flag)) {
                    s++;
                    goto loop;
                }
            }

        n = nextarg(n, &a);
        pos++;
        if(a == Z) {
            warn(nn, "more format than arguments %s",
                fmtbuf);
            return;
        }
        if(a->type == 0)
            continue;
        for(l=tprot; l; l=l->link)
            if(sametype(a->type, l->type)) {
/*print("checking %T/%ulx %T/%ulx\n", a->type, flag.b[0], l->type, l->flag.b[0]);*/
                if(beq(flag, l->flag))
                    goto loop;
            }
        warn(nn, "format mismatch %s %T, arg %d", fmtbuf, a->type, pos);
    loop:;
    }
}
@

<<function dpcheck>>=
void
dpcheck(Node *n)
{
    char *s;
    Node *a, *b;
    Tname *l;
    int i;

    if(n == Z)
        return;
    b = n->left;
    if(b == Z || b->op != ONAME)
        return;
    s = b->sym->name;
    for(l=tname; l; l=l->link)
        if(strcmp(s, l->name) == 0)
            break;
    if(l == 0)
        return;

    i = l->param;
    b = n->right;
    while(i > 0) {
        b = nextarg(b, &a);
        i--;
    }
    if(a == Z) {
        warn(n, "cant find format arg");
        return;
    }
    if(!sametype(indchar, a->type)) {
        warn(n, "format arg type %T", a->type);
        return;
    }
    if(a->op != OADDR || a->left->op != ONAME || a->left->sym != symstring) {
/*		warn(n, "format arg not constant string");*/
        return;
    }
    s = a->left->cstring;
    checkargs(b, s, l->param);
}
@

<<function pragpack>>=
void
pragpack(void)
{
    Sym *s;

    packflg = 0;
    s = getsym();
    if(s) {
        packflg = atoi(s->name+1);
        if(strcmp(s->name, "on") == 0 ||
           strcmp(s->name, "yes") == 0)
            packflg = 1;
    }
    while(getnsc() != '\n')
        ;
    if(debug['f'])
        if(packflg)
            print("%4ld: pack %d\n", lineno, packflg);
        else
            print("%4ld: pack off\n", lineno);
}
@

<<function pragfpround>>=
void
pragfpround(void)
{
    Sym *s;

    fproundflg = 0;
    s = getsym();
    if(s) {
        fproundflg = atoi(s->name+1);
        if(strcmp(s->name, "on") == 0 ||
           strcmp(s->name, "yes") == 0)
            fproundflg = 1;
    }
    while(getnsc() != '\n')
        ;
    if(debug['f'])
        if(fproundflg)
            print("%4ld: fproundflg %d\n", lineno, fproundflg);
        else
            print("%4ld: fproundflg off\n", lineno);
}
@

<<function pragprofile>>=
void
pragprofile(void)
{
    Sym *s;

    profileflg = 0;
    s = getsym();
    if(s) {
        profileflg = atoi(s->name+1);
        if(strcmp(s->name, "on") == 0 ||
           strcmp(s->name, "yes") == 0)
            profileflg = 1;
    }
    while(getnsc() != '\n')
        ;
    if(debug['f'])
        if(profileflg)
            print("%4ld: profileflg %d\n", lineno, profileflg);
        else
            print("%4ld: profileflg off\n", lineno);
}
@

<<function pragincomplete>>=
void
pragincomplete(void)
{
    Sym *s;
    Type *t;
    int istag, w, et;

    istag = 0;
    s = getsym();
    if(s == nil)
        goto out;
    et = 0;
    w = s->lexical;
    if(w == LSTRUCT)
        et = TSTRUCT;
    else if(w == LUNION)
        et = TUNION;
    if(et != 0){
        s = getsym();
        if(s == nil){
            yyerror("missing struct/union tag in pragma incomplete");
            goto out;
        }
        if(s->lexical != LNAME && s->lexical != LTYPE){
            yyerror("invalid struct/union tag: %s", s->name);
            goto out;
        }
        dotag(s, et, 0);
        istag = 1;
    }else if(strcmp(s->name, "_off_") == 0){
        debug['T'] = 0;
        goto out;
    }else if(strcmp(s->name, "_on_") == 0){
        debug['T'] = 1;
        goto out;
    }
    t = s->type;
    if(istag)
        t = s->suetag;
    if(t == T)
        yyerror("unknown type %s in pragma incomplete", s->name);
    else if(!typesu[t->etype])
        yyerror("not struct/union type in pragma incomplete: %s", s->name);
    else
        t->garb |= GINCOMPLETE;
out:
    while(getnsc() != '\n')
        ;
    if(debug['f'])
        print("%s incomplete\n", s->name);
}
@


%-------------------------------------------------------------

<<cc/dpchk.c>>=
#include	"cc.h"
#include	"y.tab.h"

<<enum _anon_ (cc/dpchk.c)>>

typedef	struct	Tprot	Tprot;
<<struct Tprot>>

typedef	struct	Tname	Tname;
<<struct Tname>>

<<global indchar>>
<<global flagbits>>
<<global fmtbuf>>
<<global lastadj>>
<<global lastverb>>
<<global nstar>>
<<global tprot>>
<<global tname>>

<<function argflag>>

<<function getflag>>

<<function newprot>>

<<function newname>>

<<function arginit>>

<<function pragvararg>>

<<function nextarg>>

<<function checkargs>>

<<function dpcheck>>

<<function pragpack>>

<<function pragfpround>>

<<function pragprofile>>

<<function pragincomplete>>
@


\subsection*{[[cc/com.c]]}

<<struct Com>>=
struct Com
{
    int	n;
    Node	*t[500];
};
@

<<function complex>>=
void
complex(Node *n)
{

    if(n == Z)
        return;

    nearln = n->lineno;
    if(debug['t'])
        if(n->op != OCONST)
            prtree(n, "pre complex");
    if(tcom(n))
        return;
    if(debug['y'] || 1)
        comma(n);
    if(debug['t'])
        if(n->op != OCONST)
            prtree(n, "t complex");
    ccom(n);
    if(debug['t'])
        if(n->op != OCONST)
            prtree(n, "c complex");
    acom(n);
    if(debug['t'])
        if(n->op != OCONST)
            prtree(n, "a complex");
    xcom(n);
    if(debug['t'])
        if(n->op != OCONST)
            prtree(n, "x complex");
}
@

<<enum _anon_ (cc/com.c)>>=
/*
 * evaluate types
 * evaluate lvalues (addable == 1)
 */
enum
{
    ADDROF	= 1<<0,
    CASTOF	= 1<<1,
    ADDROP	= 1<<2,
};
@

<<function tcom>>=
int
tcom(Node *n)
{

    return tcomo(n, ADDROF);
}
@

<<function tcomo>>=
int
tcomo(Node *n, int f)
{
    Node *l, *r;
    Type *t;
    int o;
    static TRune zer;

    if(n == Z) {
        diag(Z, "Z in tcom");
        errorexit();
    }
    n->addable = 0;
    l = n->left;
    r = n->right;

    switch(n->op) {
    default:
        diag(n, "unknown op in type complex: %O", n->op);
        goto bad;

    case ODOTDOT:
        /*
         * tcom has already been called on this subtree
         */
        *n = *n->left;
        if(n->type == T)
            goto bad;
        break;

    case OCAST:
        if(n->type == T)
            break;
        if(n->type->width == types[TLONG]->width) {
            if(tcomo(l, ADDROF|CASTOF))
                goto bad;
        } else
            if(tcom(l))
                goto bad;
        if(isfunct(n))
            break;
        if(tcompat(n, l->type, n->type, tcast))
            goto bad;
        break;

    case ORETURN:
        if(l == Z) {
            if(n->type->etype != TVOID)
                warn(n, "null return of a typed function");
            break;
        }
        if(tcom(l))
            goto bad;
        typeext(n->type, l);
        if(tcompat(n, n->type, l->type, tasign))
            break;
        constas(n, n->type, l->type);
        if(!sametype(n->type, l->type)) {
            l = new1(OCAST, l, Z);
            l->type = n->type;
            n->left = l;
        }
        break;

    case OASI:	/* same as as, but no test for const */
        n->op = OAS;
        o = tcom(l);
        if(o | tcom(r))
            goto bad;

        typeext(l->type, r);
        if(tlvalue(l) || tcompat(n, l->type, r->type, tasign))
            goto bad;
        if(!sametype(l->type, r->type)) {
            r = new1(OCAST, r, Z);
            r->type = l->type;
            n->right = r;
        }
        n->type = l->type;
        break;

    case OAS:
        o = tcom(l);
        if(o | tcom(r))
            goto bad;
        if(tlvalue(l))
            goto bad;
        if(isfunct(n))
            break;
        typeext(l->type, r);
        if(tcompat(n, l->type, r->type, tasign))
            goto bad;
        constas(n, l->type, r->type);
        if(!sametype(l->type, r->type)) {
            r = new1(OCAST, r, Z);
            r->type = l->type;
            n->right = r;
        }
        n->type = l->type;
        break;

    case OASADD:
    case OASSUB:
        o = tcom(l);
        if(o | tcom(r))
            goto bad;
        if(tlvalue(l))
            goto bad;
        if(isfunct(n))
            break;
        typeext1(l->type, r);
        if(tcompat(n, l->type, r->type, tasadd))
            goto bad;
        constas(n, l->type, r->type);
        t = l->type;
        arith(n, 0);
        while(n->left->op == OCAST)
            n->left = n->left->left;
        if(!sametype(t, n->type) && !mixedasop(t, n->type)) {
            r = new1(OCAST, n->right, Z);
            r->type = t;
            n->right = r;
            n->type = t;
        }
        break;

    case OASMUL:
    case OASLMUL:
    case OASDIV:
    case OASLDIV:
        o = tcom(l);
        if(o | tcom(r))
            goto bad;
        if(tlvalue(l))
            goto bad;
        if(isfunct(n))
            break;
        typeext1(l->type, r);
        if(tcompat(n, l->type, r->type, tmul))
            goto bad;
        constas(n, l->type, r->type);
        t = l->type;
        arith(n, 0);
        while(n->left->op == OCAST)
            n->left = n->left->left;
        if(!sametype(t, n->type) && !mixedasop(t, n->type)) {
            r = new1(OCAST, n->right, Z);
            r->type = t;
            n->right = r;
            n->type = t;
        }
        if(typeu[n->type->etype]) {
            if(n->op == OASDIV)
                n->op = OASLDIV;
            if(n->op == OASMUL)
                n->op = OASLMUL;
        }
        break;

    case OASLSHR:
    case OASASHR:
    case OASASHL:
        o = tcom(l);
        if(o | tcom(r))
            goto bad;
        if(tlvalue(l))
            goto bad;
        if(isfunct(n))
            break;
        if(tcompat(n, l->type, r->type, tand))
            goto bad;
        n->type = l->type;
        n->right = new1(OCAST, r, Z);
        n->right->type = types[TINT];
        if(typeu[n->type->etype]) {
            if(n->op == OASASHR)
                n->op = OASLSHR;
        }
        break;

    case OASMOD:
    case OASLMOD:
    case OASOR:
    case OASAND:
    case OASXOR:
        o = tcom(l);
        if(o | tcom(r))
            goto bad;
        if(tlvalue(l))
            goto bad;
        if(isfunct(n))
            break;
        if(tcompat(n, l->type, r->type, tand))
            goto bad;
        t = l->type;
        arith(n, 0);
        while(n->left->op == OCAST)
            n->left = n->left->left;
        if(!sametype(t, n->type) && !mixedasop(t, n->type)) {
            r = new1(OCAST, n->right, Z);
            r->type = t;
            n->right = r;
            n->type = t;
        }
        if(typeu[n->type->etype]) {
            if(n->op == OASMOD)
                n->op = OASLMOD;
        }
        break;

    case OPREINC:
    case OPREDEC:
    case OPOSTINC:
    case OPOSTDEC:
        if(tcom(l))
            goto bad;
        if(tlvalue(l))
            goto bad;
        if(isfunct(n))
            break;
        if(tcompat(n, l->type, types[TINT], tadd))
            goto bad;
        n->type = l->type;
        if(n->type->etype == TIND)
        if(n->type->link->width < 1) {
            snap(n->type->link);
            if(n->type->link->width < 1)
                diag(n, "inc/dec of a void pointer");
        }
        break;

    case OEQ:
    case ONE:
        o = tcom(l);
        if(o | tcom(r))
            goto bad;
        if(isfunct(n))
            break;
        typeext(l->type, r);
        typeext(r->type, l);
        if(tcompat(n, l->type, r->type, trel))
            goto bad;
        arith(n, 0);
        n->type = types[TINT];
        break;

    case OLT:
    case OGE:
    case OGT:
    case OLE:
        o = tcom(l);
        if(o | tcom(r))
            goto bad;
        if(isfunct(n))
            break;
        typeext1(l->type, r);
        typeext1(r->type, l);
        if(tcompat(n, l->type, r->type, trel))
            goto bad;
        arith(n, 0);
        if(typeu[n->type->etype])
            n->op = logrel[relindex(n->op)];
        n->type = types[TINT];
        break;

    case OCOND:
        o = tcom(l);
        o |= tcom(r->left);
        if(o | tcom(r->right))
            goto bad;
        if(r->right->type->etype == TIND && vconst(r->left) == 0) {
            r->left->type = r->right->type;
            r->left->vconst = 0;
        }
        if(r->left->type->etype == TIND && vconst(r->right) == 0) {
            r->right->type = r->left->type;
            r->right->vconst = 0;
        }
        if(sametype(r->right->type, r->left->type)) {
            r->type = r->right->type;
            n->type = r->type;
            break;
        }
        if(tcompat(r, r->left->type, r->right->type, trel))
            goto bad;
        arith(r, 0);
        n->type = r->type;
        break;

    case OADD:
        o = tcom(l);
        if(o | tcom(r))
            goto bad;
        if(isfunct(n))
            break;
        if(tcompat(n, l->type, r->type, tadd))
            goto bad;
        arith(n, 1);
        break;

    case OSUB:
        o = tcom(l);
        if(o | tcom(r))
            goto bad;
        if(isfunct(n))
            break;
        if(tcompat(n, l->type, r->type, tsub))
            goto bad;
        arith(n, 1);
        break;

    case OMUL:
    case OLMUL:
    case ODIV:
    case OLDIV:
        o = tcom(l);
        if(o | tcom(r))
            goto bad;
        if(isfunct(n))
            break;
        if(tcompat(n, l->type, r->type, tmul))
            goto bad;
        arith(n, 1);
        if(typeu[n->type->etype]) {
            if(n->op == ODIV)
                n->op = OLDIV;
            if(n->op == OMUL)
                n->op = OLMUL;
        }
        break;

    case OLSHR:
    case OASHL:
    case OASHR:
        o = tcom(l);
        if(o | tcom(r))
            goto bad;
        if(isfunct(n))
            break;
        if(tcompat(n, l->type, r->type, tand))
            goto bad;
        n->right = Z;
        arith(n, 1);
        n->right = new1(OCAST, r, Z);
        n->right->type = types[TINT];
        if(typeu[n->type->etype])
            if(n->op == OASHR)
                n->op = OLSHR;
        break;

    case OAND:
    case OOR:
    case OXOR:
        o = tcom(l);
        if(o | tcom(r))
            goto bad;
        if(isfunct(n))
            break;
        if(tcompat(n, l->type, r->type, tand))
            goto bad;
        arith(n, 1);
        break;

    case OMOD:
    case OLMOD:
        o = tcom(l);
        if(o | tcom(r))
            goto bad;
        if(isfunct(n))
            break;
        if(tcompat(n, l->type, r->type, tand))
            goto bad;
        arith(n, 1);
        if(typeu[n->type->etype])
            n->op = OLMOD;
        break;

    case OPOS:
        if(tcom(l))
            goto bad;
        if(isfunct(n))
            break;

        r = l;
        l = new(OCONST, Z, Z);
        l->vconst = 0;
        l->type = types[TINT];
        n->op = OADD;
        n->right = r;
        n->left = l;

        if(tcom(l))
            goto bad;
        if(tcompat(n, l->type, r->type, tsub))
            goto bad;
        arith(n, 1);
        break;

    case ONEG:
        if(tcom(l))
            goto bad;
        if(isfunct(n))
            break;

        if(!machcap(n)) {
            r = l;
            l = new(OCONST, Z, Z);
            l->vconst = 0;
            l->type = types[TINT];
            n->op = OSUB;
            n->right = r;
            n->left = l;

            if(tcom(l))
                goto bad;
            if(tcompat(n, l->type, r->type, tsub))
                goto bad;
        }
        arith(n, 1);
        break;

    case OCOM:
        if(tcom(l))
            goto bad;
        if(isfunct(n))
            break;

        if(!machcap(n)) {
            r = l;
            l = new(OCONST, Z, Z);
            l->vconst = -1;
            l->type = types[TINT];
            n->op = OXOR;
            n->right = r;
            n->left = l;

            if(tcom(l))
                goto bad;
            if(tcompat(n, l->type, r->type, tand))
                goto bad;
        }
        arith(n, 1);
        break;

    case ONOT:
        if(tcom(l))
            goto bad;
        if(isfunct(n))
            break;
        if(tcompat(n, T, l->type, tnot))
            goto bad;
        n->type = types[TINT];
        break;

    case OANDAND:
    case OOROR:
        o = tcom(l);
        if(o | tcom(r))
            goto bad;
        if(tcompat(n, T, l->type, tnot) |
           tcompat(n, T, r->type, tnot))
            goto bad;
        n->type = types[TINT];
        break;

    case OCOMMA:
        o = tcom(l);
        if(o | tcom(r))
            goto bad;
        n->type = r->type;
        break;


    case OSIGN:	/* extension signof(type) returns a hash */
        if(l != Z) {
            if(l->op != OSTRING && l->op != OLSTRING)
                if(tcomo(l, 0))
                    goto bad;
            if(l->op == OBIT) {
                diag(n, "signof bitfield");
                goto bad;
            }
            n->type = l->type;
        }
        if(n->type == T)
            goto bad;
        if(n->type->width < 0) {
            diag(n, "signof undefined type");
            goto bad;
        }
        n->op = OCONST;
        n->left = Z;
        n->right = Z;
        n->vconst = convvtox(signature(n->type), TULONG);
        n->type = types[TULONG];
        break;

    case OSIZE:
        if(l != Z) {
            if(l->op != OSTRING && l->op != OLSTRING)
                if(tcomo(l, 0))
                    goto bad;
            if(l->op == OBIT) {
                diag(n, "sizeof bitfield");
                goto bad;
            }
            n->type = l->type;
        }
        if(n->type == T)
            goto bad;
        if(n->type->width <= 0) {
            diag(n, "sizeof undefined type");
            goto bad;
        }
        if(n->type->etype == TFUNC) {
            diag(n, "sizeof function");
            goto bad;
        }
        n->op = OCONST;
        n->left = Z;
        n->right = Z;
        n->vconst = convvtox(n->type->width, TINT);
        n->type = types[TINT];
        break;

    case OFUNC:
        o = tcomo(l, 0);
        if(o)
            goto bad;
        if(l->type->etype == TIND && l->type->link->etype == TFUNC) {
            l = new1(OIND, l, Z);
            l->type = l->left->type->link;
            n->left = l;
        }
        if(tcompat(n, T, l->type, tfunct))
            goto bad;
        if(o | tcoma(l, r, l->type->down, 1))
            goto bad;
        n->type = l->type->link;
        if(!debug['B'])
            if(l->type->down == T || l->type->down->etype == TOLD) {
                nerrors--;
                diag(n, "function args not checked: %F", l);
            }
        dpcheck(n);
        break;

    case ONAME:
        if(n->type == T) {
            diag(n, "name not declared: %F", n);
            goto bad;
        }
        if(n->type->etype == TENUM) {
            n->op = OCONST;
            n->type = n->sym->tenum;
            if(!typefd[n->type->etype])
                n->vconst = n->sym->vconst;
            else
                n->fconst = n->sym->fconst;
            break;
        }
        n->addable = 1;
        if(n->class == CEXREG) {
            n->op = OREGISTER;
            if(thechar == '8')
                n->op = OEXREG;
            n->reg = n->sym->offset;
            n->xoffset = 0;
            break;
        }
        break;

    case OLSTRING:
        if(n->type->link != types[TRUNE]) {
            o = outstring(0, 0);
            while(o & 3) {
                outlstring(&zer, sizeof(TRune));
                o = outlstring(0, 0);
            }
        }
        n->op = ONAME;
        n->xoffset = outlstring(n->rstring, n->type->width);
        n->addable = 1;
        break;

    case OSTRING:
        if(n->type->link != types[TCHAR]) {
            o = outstring(0, 0);
            while(o & 3) {
                outstring("", 1);
                o = outstring(0, 0);
            }
        }
        n->op = ONAME;
        n->xoffset = outstring(n->cstring, n->type->width);
        n->addable = 1;
        break;

    case OCONST:
        break;

    case ODOT:
        if(tcom(l))
            goto bad;
        if(tcompat(n, T, l->type, tdot))
            goto bad;
        if(tcomd(n))
            goto bad;
        break;

    case OADDR:
        if(tcomo(l, ADDROP))
            goto bad;
        if(tlvalue(l))
            goto bad;
        if(l->type->nbits) {
            diag(n, "address of a bit field");
            goto bad;
        }
        if(l->op == OREGISTER) {
            diag(n, "address of a register");
            goto bad;
        }
        n->type = typ(TIND, l->type);
        n->type->width = types[TIND]->width;
        break;

    case OIND:
        if(tcom(l))
            goto bad;
        if(tcompat(n, T, l->type, tindir))
            goto bad;
        n->type = l->type->link;
        n->addable = 1;
        break;

    case OSTRUCT:
        if(tcomx(n))
            goto bad;
        break;
    }
    t = n->type;
    if(t == T)
        goto bad;
    if(t->width < 0) {
        snap(t);
        if(t->width < 0) {
            if(typesu[t->etype] && t->tag)
                diag(n, "structure not fully declared %s", t->tag->name);
            else
                diag(n, "structure not fully declared");
            goto bad;
        }
    }
    if(typeaf[t->etype]) {
        if(f & ADDROF)
            goto addaddr;
        if(f & ADDROP)
            warn(n, "address of array/func ignored");
    }
    return 0;

addaddr:
    if(tlvalue(n))
        goto bad;
    l = new1(OXXX, Z, Z);
    *l = *n;
    n->op = OADDR;
    if(l->type->etype == TARRAY)
        l->type = l->type->link;
    n->left = l;
    n->right = Z;
    n->addable = 0;
    n->type = typ(TIND, l->type);
    n->type->width = types[TIND]->width;
    return 0;

bad:
    n->type = T;
    return 1;
}
@

<<function tcoma>>=
int
tcoma(Node *l, Node *n, Type *t, int f)
{
    Node *n1;
    int o;

    if(t != T)
    if(t->etype == TOLD || t->etype == TDOT)	/* .../old in prototype */
        t = T;
    if(n == Z) {
        if(t != T && !sametype(t, types[TVOID])) {
            diag(n, "not enough function arguments: %F", l);
            return 1;
        }
        return 0;
    }
    if(n->op == OLIST) {
        o = tcoma(l, n->left, t, 0);
        if(t != T) {
            t = t->down;
            if(t == T)
                t = types[TVOID];
        }
        return o | tcoma(l, n->right, t, 1);
    }
    if(f && t != T)
        tcoma(l, Z, t->down, 0);
    if(tcom(n) || tcompat(n, T, n->type, targ))
        return 1;
    if(sametype(t, types[TVOID])) {
        diag(n, "too many function arguments: %F", l);
        return 1;
    }
    if(t != T) {
        typeext(t, n);
        if(stcompat(nodproto, t, n->type, tasign)) {
            diag(l, "argument prototype mismatch \"%T\" for \"%T\": %F",
                n->type, t, l);
            return 1;
        }
        switch(t->etype) {
        case TCHAR:
        case TSHORT:
            t = types[TINT];
            break;

        case TUCHAR:
        case TUSHORT:
            t = types[TUINT];
            break;
        }
    } else
    switch(n->type->etype)
    {
    case TCHAR:
    case TSHORT:
        t = types[TINT];
        break;

    case TUCHAR:
    case TUSHORT:
        t = types[TUINT];
        break;

    case TFLOAT:
        t = types[TDOUBLE];
    }
    if(t != T && !sametype(t, n->type)) {
        n1 = new1(OXXX, Z, Z);
        *n1 = *n;
        n->op = OCAST;
        n->left = n1;
        n->right = Z;
        n->type = t;
        n->addable = 0;
    }
    return 0;
}
@

<<function tcomd>>=
int
tcomd(Node *n)
{
    Type *t;
    long o;

    o = 0;
    t = dotsearch(n->sym, n->left->type->link, n, &o);
    if(t == T) {
        diag(n, "not a member of struct/union: %F", n);
        return 1;
    }
    makedot(n, t, o);
    return 0;
}
@

<<function tcomx>>=
int
tcomx(Node *n)
{
    Type *t;
    Node *l, *r, **ar, **al;
    int e;

    e = 0;
    if(n->type->etype != TSTRUCT) {
        diag(n, "constructor must be a structure");
        return 1;
    }
    l = invert(n->left);
    n->left = l;
    al = &n->left;
    for(t = n->type->link; t != T; t = t->down) {
        if(l == Z) {
            diag(n, "constructor list too short");
            return 1;
        }
        if(l->op == OLIST) {
            r = l->left;
            ar = &l->left;
            al = &l->right;
            l = l->right;
        } else {
            r = l;
            ar = al;
            l = Z;
        }
        if(tcom(r))
            e++;
        typeext(t, r);
        if(tcompat(n, t, r->type, tasign))
            e++;
        constas(n, t, r->type);
        if(!e && !sametype(t, r->type)) {
            r = new1(OCAST, r, Z);
            r->type = t;
            *ar = r;
        }
    }
    if(l != Z) {
        diag(n, "constructor list too long");
        return 1;
    }
    return e;
}
@

<<function tlvalue>>=
int
tlvalue(Node *n)
{

    if(!n->addable) {
        diag(n, "not an l-value");
        return 1;
    }
    return 0;
}
@

<<function comargs>>=
/*
 * hoist comma operators out of expressions
 *	(a,b) OP c => (a, b OP c)
 *	OP(a,b) =>	(a, OP b)
 *	a OP (b,c) => (b, a OP c)
 */

static Node*
comargs(Com *com, Node *n)
{
    if(n != Z && n->op == OLIST){
        n->left = comargs(com, n->left);
        n->right = comargs(com, n->right);
    }
    return commas(com, n);
}
@

<<function commas>>=
static Node*
commas(Com *com, Node *n)
{
    Node *t;

    if(n == Z)
        return n;
    switch(n->op){
    case OREGISTER:
    case OINDREG:
    case OCONST:
    case ONAME:
    case OSTRING:
        /* leaf */
        return n;

    case OCOMMA:
        t = commas(com, n->left);
        if(com->n >= nelem(com->t))
            fatal(n, "comma list overflow");
        com->t[com->n++] = t;
        return commas(com, n->right);

    case OFUNC:
        n->left = commas(com, n->left);
        n->right = comargs(com, n->right);
        return n;

    case OCOND:
        n->left = commas(com, n->left);
        comma(n->right->left);
        comma(n->right->right);
        return n;

    case OANDAND:
    case OOROR:
        n->left = commas(com, n->left);
        comma(n->right);
        return n;

    case ORETURN:
        comma(n->left);
        return n;
    }
    n->left = commas(com, n->left);
    if(n->right != Z)
        n->right = commas(com, n->right);
    return n;
}
@

<<function comma>>=
static void
comma(Node *n)
{
    Com com;
    Node *nn;

    com.n = 0;
    nn = commas(&com, n);
    if(com.n > 0){
if(debug['y'])print("n=%d\n", com.n);
if(debug['y']) prtree(nn, "res");
        if(nn != n)
            *n = *nn;
        while(com.n > 0){
if(debug['y']) prtree(com.t[com.n-1], "tree");
            nn = new1(OXXX, Z, Z);
            *nn = *n;
            n->op = OCOMMA;
            n->type = nn->type;
            n->left = com.t[--com.n];
            n->right = nn;
            n->lineno = n->left->lineno;
        }
if(debug['y']) prtree(n, "final");
    }else if(n != nn)
        fatal(n, "odd tree");
}
@

<<function ccom>>=
/*
 *	general rewrite
 *	(IND(ADDR x)) ==> x
 *	(ADDR(IND x)) ==> x
 *	remove some zero operands
 *	remove no op casts
 *	evaluate constants
 */
void
ccom(Node *n)
{
    Node *l, *r;
    int t;

loop:
    if(n == Z)
        return;
    l = n->left;
    r = n->right;
    switch(n->op) {

    case OAS:
    case OASXOR:
    case OASAND:
    case OASOR:
    case OASMOD:
    case OASLMOD:
    case OASLSHR:
    case OASASHR:
    case OASASHL:
    case OASDIV:
    case OASLDIV:
    case OASMUL:
    case OASLMUL:
    case OASSUB:
    case OASADD:
        ccom(l);
        ccom(r);
        if(n->op == OASLSHR || n->op == OASASHR || n->op == OASASHL)
        if(r->op == OCONST) {
            t = n->type->width * 8;	/* bits per byte */
            if(r->vconst >= t || r->vconst < 0)
                warn(n, "stupid shift: %lld", r->vconst);
        }
        break;

    case OCAST:
        ccom(l);
        if(l->op == OCONST) {
            evconst(n);
            if(n->op == OCONST)
                break;
        }
        if(nocast(l->type, n->type) &&
           (!typefd[l->type->etype] || typeu[l->type->etype] && typeu[n->type->etype])) {
            l->type = n->type;
            *n = *l;
        }
        break;

    case OCOND:
        ccom(l);
        ccom(r);
        if(l->op == OCONST)
            if(vconst(l) == 0)
                *n = *r->right;
            else
                *n = *r->left;
        break;

    case OREGISTER:
    case OINDREG:
    case OCONST:
    case ONAME:
        break;

    case OADDR:
        ccom(l);
        l->etype = TVOID;
        if(l->op == OIND) {
            l->left->type = n->type;
            *n = *l->left;
            break;
        }
        goto common;

    case OIND:
        ccom(l);
        if(l->op == OADDR) {
            l->left->type = n->type;
            *n = *l->left;
            break;
        }
        goto common;

    case OEQ:
    case ONE:

    case OLE:
    case OGE:
    case OLT:
    case OGT:

    case OLS:
    case OHS:
    case OLO:
    case OHI:
        ccom(l);
        ccom(r);
        if(compar(n, 0) || compar(n, 1))
            break;
        relcon(l, r);
        relcon(r, l);
        goto common;

    case OASHR:
    case OASHL:
    case OLSHR:
        ccom(l);
        if(vconst(l) == 0 && !side(r)) {
            *n = *l;
            break;
        }
        ccom(r);
        if(vconst(r) == 0) {
            *n = *l;
            break;
        }
        if(r->op == OCONST) {
            t = n->type->width * 8;	/* bits per byte */
            if(r->vconst >= t || r->vconst <= -t)
                warn(n, "stupid shift: %lld", r->vconst);
        }
        goto common;

    case OMUL:
    case OLMUL:
        ccom(l);
        t = vconst(l);
        if(t == 0 && !side(r)) {
            *n = *l;
            break;
        }
        if(t == 1) {
            *n = *r;
            goto loop;
        }
        ccom(r);
        t = vconst(r);
        if(t == 0 && !side(l)) {
            *n = *r;
            break;
        }
        if(t == 1) {
            *n = *l;
            break;
        }
        goto common;

    case ODIV:
    case OLDIV:
        ccom(l);
        if(vconst(l) == 0 && !side(r)) {
            *n = *l;
            break;
        }
        ccom(r);
        t = vconst(r);
        if(t == 0) {
            diag(n, "divide check");
            *n = *r;
            break;
        }
        if(t == 1) {
            *n = *l;
            break;
        }
        goto common;

    case OSUB:
        ccom(r);
        if(r->op == OCONST) {
            if(typefd[r->type->etype]) {
                n->op = OADD;
                r->fconst = -r->fconst;
                goto loop;
            } else {
                n->op = OADD;
                r->vconst = -r->vconst;
                goto loop;
            }
        }
        ccom(l);
        goto common;

    case OXOR:
    case OOR:
    case OADD:
        ccom(l);
        if(vconst(l) == 0) {
            *n = *r;
            goto loop;
        }
        ccom(r);
        if(vconst(r) == 0) {
            *n = *l;
            break;
        }
        goto commute;

    case OAND:
        ccom(l);
        ccom(r);
        if(vconst(l) == 0 && !side(r)) {
            *n = *l;
            break;
        }
        if(vconst(r) == 0 && !side(l)) {
            *n = *r;
            break;
        }

    commute:
        /* look for commutative constant */
        if(r->op == OCONST) {
            if(l->op == n->op) {
                if(l->left->op == OCONST) {
                    n->right = l->right;
                    l->right = r;
                    goto loop;
                }
                if(l->right->op == OCONST) {
                    n->right = l->left;
                    l->left = r;
                    goto loop;
                }
            }
        }
        if(l->op == OCONST) {
            if(r->op == n->op) {
                if(r->left->op == OCONST) {
                    n->left = r->right;
                    r->right = l;
                    goto loop;
                }
                if(r->right->op == OCONST) {
                    n->left = r->left;
                    r->left = l;
                    goto loop;
                }
            }
        }
        goto common;

    case OANDAND:
        ccom(l);
        if(vconst(l) == 0) {
            *n = *l;
            break;
        }
        ccom(r);
        goto common;

    case OOROR:
        ccom(l);
        if(l->op == OCONST && l->vconst != 0) {
            *n = *l;
            n->vconst = 1;
            break;
        }
        ccom(r);
        goto common;

    default:
        if(l != Z)
            ccom(l);
        if(r != Z)
            ccom(r);
    common:
        if(l != Z)
        if(l->op != OCONST)
            break;
        if(r != Z)
        if(r->op != OCONST)
            break;
        evconst(n);
    }
}
@

<<global cmps>>=
/*	OEQ, ONE, OLE, OLS, OLT, OLO, OGE, OHS, OGT, OHI */
static char *cmps[12] = 
{
    "==", "!=", "<=", "<=", "<", "<", ">=", ">=", ">", ">",
};
@

<<struct Big>>=
struct Big
{
    vlong a;
    uvlong b;
};
@

<<function cmp>>=
static int
cmp(Big x, Big y)
{
    if(x.a != y.a){
        if(x.a < y.a)
            return -1;
        return 1;
    }
    if(x.b != y.b){
        if(x.b < y.b)
            return -1;
        return 1;
    }
    return 0;
}
@

<<function add>>=
static Big
add(Big x, int y)
{
    uvlong ob;
    
    ob = x.b;
    x.b += y;
    if(y > 0 && x.b < ob)
        x.a++;
    if(y < 0 && x.b > ob)
        x.a--;
    return x;
} 
@

<<function big>>=
Big
big(vlong a, uvlong b)
{
    Big x;

    x.a = a;
    x.b = b;
    return x;
}
@

<<function compar>>=
int
compar(Node *n, int reverse)
{
    Big lo, hi, x;
    int op;
    char xbuf[40], cmpbuf[50];
    Node *l, *r;
    Type *lt, *rt;

    /*
     * The point of this function is to diagnose comparisons 
     * that can never be true or that look misleading because
     * of the `usual arithmetic conversions'.  As an example 
     * of the latter, if x is a ulong, then if(x <= -1) really means
     * if(x <= 0xFFFFFFFF), while if(x <= -1LL) really means
     * what it says (but 8c compiles it wrong anyway).
     */

    if(reverse){
        r = n->left;
        l = n->right;
        op = comrel[relindex(n->op)];
    }else{
        l = n->left;
        r = n->right;
        op = n->op;
    }

    /*
     * Skip over left casts to find out the original expression range.
     */
    while(l->op == OCAST)
        l = l->left;
    if(l->op == OCONST)
        return 0;
    lt = l->type;
    if(l->op == ONAME && l->sym->type){
        lt = l->sym->type;
        if(lt->etype == TARRAY)
            lt = lt->link;
    }
    if(lt == T)
        return 0;
    if(lt->etype == TXXX || lt->etype > TUVLONG)
        return 0;
    
    /*
     * Skip over the right casts to find the on-screen value.
     */
    if(r->op != OCONST)
        return 0;
    while(r->oldop == OCAST && !r->xcast)
        r = r->left;
    rt = r->type;
    if(rt == T)
        return 0;

    x.b = r->vconst;
    x.a = 0;
    if((rt->etype&1) && r->vconst < 0)	/* signed negative */
        x.a = ~0ULL;

    if((lt->etype&1)==0){
        /* unsigned */
        lo = big(0, 0);
        if(lt->width == 8)
            hi = big(0, ~0ULL);
        else
            hi = big(0, (1LL<<(l->type->width*8))-1);
    }else{
        lo = big(~0ULL, -(1LL<<(l->type->width*8-1)));
        hi = big(0, (1LL<<(l->type->width*8-1))-1);
    }

    switch(op){
    case OLT:
    case OLO:
    case OGE:
    case OHS:
        if(cmp(x, lo) <= 0)
            goto useless;
        if(cmp(x, add(hi, 1)) >= 0)
            goto useless;
        break;
    case OLE:
    case OLS:
    case OGT:
    case OHI:
        if(cmp(x, add(lo, -1)) <= 0)
            goto useless;
        if(cmp(x, hi) >= 0)
            goto useless;
        break;
    case OEQ:
    case ONE:
        /*
         * Don't warn about comparisons if the expression
         * is as wide as the value: the compiler-supplied casts
         * will make both outcomes possible.
         */
        if(lt->width >= rt->width && debug['w'] < 2)
            return 0;
        if(cmp(x, lo) < 0 || cmp(x, hi) > 0)
            goto useless;
        break;
    }
    return 0;

useless:
    if((x.a==0 && x.b<=9) || (x.a==~0LL && x.b >= -9ULL))
        snprint(xbuf, sizeof xbuf, "%lld", x.b);
    else if(x.a == 0)
        snprint(xbuf, sizeof xbuf, "%#llux", x.b);
    else
        snprint(xbuf, sizeof xbuf, "%#llx", x.b);
    if(reverse)
        snprint(cmpbuf, sizeof cmpbuf, "%s %s %T",
            xbuf, cmps[relindex(n->op)], lt);
    else
        snprint(cmpbuf, sizeof cmpbuf, "%T %s %s",
            lt, cmps[relindex(n->op)], xbuf);
if(debug['y']) prtree(n, "strange");
    warn(n, "useless or misleading comparison: %s", cmpbuf);
    return 0;
}
@


%-------------------------------------------------------------

<<cc/com.c>>=
#include "cc.h"

typedef struct Com Com;
<<struct Com>>

int compar(Node*, int);
static void comma(Node*);
static Node*	commas(Com*, Node*);

<<function complex>>

<<enum _anon_ (cc/com.c)>>

<<function tcom>>

<<function tcomo>>

<<function tcoma>>

<<function tcomd>>

<<function tcomx>>

<<function tlvalue>>

<<function comargs>>

<<function commas>>

<<function comma>>

<<function ccom>>

<<global cmps>>

/* 128-bit numbers */
typedef struct Big Big;
<<struct Big>>
<<function cmp>>
<<function add>>

<<function big>>

<<function compar>>

@


\subsection*{[[cc2/pgen.c]]}

<<function codgen>>=
void
codgen(Node *n, Node *nn)
{
    Prog *sp;
    Node *n1, nod, nod1;

    cursafe = 0;
    curarg = 0;
    maxargsafe = 0;
    hasdoubled = 0;

    /*
     * isolate name
     */
    for(n1 = nn;; n1 = n1->left) {
        if(n1 == Z) {
            diag(nn, "cant find function name");
            return;
        }
        if(n1->op == ONAME)
            break;
    }
    nearln = nn->lineno;
    gpseudo(ATEXT, n1->sym, nodconst(stkoff));
    sp = p;

    if(typecmplx[thisfn->link->etype]) {
        if(nodret == nil) {
            nodret = new(ONAME, Z, Z);
            nodret->sym = slookup(".ret");
            nodret->class = CPARAM;
            nodret->type = types[TIND];
            nodret->etype = TIND;
            nodret = new(OIND, nodret, Z);
        }
        n1 = nodret->left;
        if(n1->type == T || n1->type->link != thisfn->link) {
            n1->type = typ(TIND, thisfn->link);
            n1->etype = n1->type->etype;
            nodret = new(OIND, n1, Z);
            complex(nodret);
        }
    }

    /*
     * isolate first argument
     */
    if(REGARG >= 0) {	
        if(typecmplx[thisfn->link->etype]) {
            nod1 = *nodret->left;
            nodreg(&nod, &nod1, REGARG);
            gmove(&nod, &nod1);
        } else
        if(firstarg && typeword[firstargtype->etype]) {
            nod1 = znode;
            nod1.op = ONAME;
            nod1.sym = firstarg;
            nod1.type = firstargtype;
            nod1.class = CPARAM;
            nod1.xoffset = align(0, firstargtype, Aarg1);
            nod1.etype = firstargtype->etype;
            xcom(&nod1);
            nodreg(&nod, &nod1, REGARG);
            gmove(&nod, &nod1);
        }
    }

    canreach = 1;
    warnreach = 1;
    gen(n);
    if(canreach && thisfn->link->etype != TVOID){
        if(debug['B'])
            warn(Z, "no return at end of function: %s", n1->sym->name);
        else
            diag(Z, "no return at end of function: %s", n1->sym->name);
    }
    noretval(3);
    gbranch(ORETURN);

    if(!debug['N'] || debug['R'] || debug['P'])
        regopt(sp);
    
    if(thechar=='6' || thechar=='7' || thechar=='9' || hasdoubled)	/* [sic] */
        maxargsafe = round(maxargsafe, 8);
    sp->to.offset += maxargsafe;
}
@

<<function supgen>>=
void
supgen(Node *n)
{
    int owarn;
    long spc;
    Prog *sp;

    if(n == Z)
        return;
    suppress++;
    owarn = warnreach;
    warnreach = 0;
    spc = pc;
    sp = lastp;
    gen(n);
    lastp = sp;
    pc = spc;
    sp->link = nil;
    suppress--;
    warnreach = owarn;
}
@

<<function uncomma>>=
Node*
uncomma(Node *n)
{
    while(n != Z && n->op == OCOMMA) {
        cgen(n->left, Z);
        n = n->right;
    }
    return n;
}
@

<<function gen>>=
void
gen(Node *n)
{
    Node *l, nod, rn;
    Prog *sp, *spc, *spb;
    Case *cn;
    long sbc, scc;
    int snbreak, sncontin;
    int f, o, oldreach;

loop:
    if(n == Z)
        return;
    nearln = n->lineno;
    o = n->op;
    if(debug['G'])
        if(o != OLIST)
            print("%L %O\n", nearln, o);

    if(!canreach) {
        switch(o) {
        case OLABEL:
        case OCASE:
        case OLIST:
        case OCOMMA:
        case OBREAK:
        case OFOR:
        case OWHILE:
        case ODWHILE:
            /* all handled specially - see switch body below */
            break;
        default:
            if(warnreach) {
                warn(n, "unreachable code %O", o);
                warnreach = 0;
            }
        }
    }

    switch(o) {

    default:
        complex(n);
        cgen(n, Z);
        break;

    case OLIST:
    case OCOMMA:
        gen(n->left);

    rloop:
        n = n->right;
        goto loop;

    case ORETURN:
        canreach = 0;
        warnreach = !suppress;
        complex(n);
        if(n->type == T)
            break;
        l = uncomma(n->left);
        if(l == Z) {
            noretval(3);
            gbranch(ORETURN);
            break;
        }
        if(typecmplx[n->type->etype]) {
            nod = znode;
            nod.op = OAS;
            nod.left = nodret;
            nod.right = l;
            nod.type = n->type;
            nod.complex = l->complex;
            cgen(&nod, Z);
            noretval(3);
            gbranch(ORETURN);
            break;
        }
        if(newvlongcode && !typefd[n->type->etype]){
            regret(&rn, n);
            regfree(&rn);
            nod = znode;
            nod.op = OAS;
            nod.left = &rn;
            nod.right = l;
            nod.type = n->type;
            nod.complex = l->complex;
            cgen(&nod, Z);
            noretval(2);
            gbranch(ORETURN);
            break;
        }
        regret(&nod, n);
        cgen(l, &nod);
        regfree(&nod);
        if(typefd[n->type->etype])
            noretval(1);
        else
            noretval(2);
        gbranch(ORETURN);
        break;

    case OLABEL:
        canreach = 1;
        l = n->left;
        if(l) {
            l->pc = pc;
            if(l->label)
                patch(l->label, pc);
        }
        gbranch(OGOTO);	/* prevent self reference in reg */
        patch(p, pc);
        goto rloop;

    case OGOTO:
        canreach = 0;
        warnreach = !suppress;
        n = n->left;
        if(n == Z)
            return;
        if(n->complex == 0) {
            diag(Z, "label undefined: %s", n->sym->name);
            return;
        }
        if(suppress)
            return;
        gbranch(OGOTO);
        if(n->pc) {
            patch(p, n->pc);
            return;
        }
        if(n->label)
            patch(n->label, pc-1);
        n->label = p;
        return;

    case OCASE:
        canreach = 1;
        l = n->left;
        if(cases == C)
            diag(n, "case/default outside a switch");
        if(l == Z) {
            casf();
            cases->val = 0;
            cases->def = 1;
            cases->label = pc;
            cases->isv = 0;
            goto rloop;
        }
        complex(l);
        if(l->type == T)
            goto rloop;
        if(l->op != OCONST || !typeswitch[l->type->etype]) {
            diag(n, "case expression must be integer constant");
            goto rloop;
        }
        casf();
        cases->val = l->vconst;
        cases->def = 0;
        cases->label = pc;
        cases->isv = typev[l->type->etype];
        goto rloop;

    case OSWITCH:
        l = n->left;
        complex(l);
        if(l->type == T)
            break;
        if(!typeswitch[l->type->etype]) {
            diag(n, "switch expression must be integer");
            break;
        }

        gbranch(OGOTO);		/* entry */
        sp = p;

        cn = cases;
        cases = C;
        casf();

        sbc = breakpc;
        breakpc = pc;
        snbreak = nbreak;
        nbreak = 0;
        gbranch(OGOTO);
        spb = p;

        gen(n->right);		/* body */
        if(canreach){
            gbranch(OGOTO);
            patch(p, breakpc);
            nbreak++;
        }

        patch(sp, pc);
        regalloc(&nod, l, Z);
        /* always signed */
        if(typev[l->type->etype])
            nod.type = types[TVLONG];
        else
            nod.type = types[TLONG];
        cgen(l, &nod);
        doswit(&nod);
        regfree(&nod);
        patch(spb, pc);

        cases = cn;
        breakpc = sbc;
        canreach = nbreak!=0;
        if(canreach == 0)
            warnreach = !suppress;
        nbreak = snbreak;
        break;

    case OWHILE:
    case ODWHILE:
        l = n->left;
        gbranch(OGOTO);		/* entry */
        sp = p;

        scc = continpc;
        continpc = pc;
        gbranch(OGOTO);
        spc = p;

        sbc = breakpc;
        breakpc = pc;
        snbreak = nbreak;
        nbreak = 0;
        gbranch(OGOTO);
        spb = p;

        patch(spc, pc);
        if(n->op == OWHILE)
            patch(sp, pc);
        bcomplex(l, Z);		/* test */
        patch(p, breakpc);
        if(l->op != OCONST || vconst(l) == 0)
            nbreak++;

        if(n->op == ODWHILE)
            patch(sp, pc);
        gen(n->right);		/* body */
        gbranch(OGOTO);
        patch(p, continpc);

        patch(spb, pc);
        continpc = scc;
        breakpc = sbc;
        canreach = nbreak!=0;
        if(canreach == 0)
            warnreach = !suppress;
        nbreak = snbreak;
        break;

    case OFOR:
        l = n->left;
        if(!canreach && l->right->left && warnreach) {
            warn(n, "unreachable code FOR");
            warnreach = 0;
        }
        gen(l->right->left);	/* init */
        gbranch(OGOTO);		/* entry */
        sp = p;

        /* 
         * if there are no incoming labels in the 
         * body and the top's not reachable, warn
         */
        if(!canreach && warnreach && deadheads(n)) {
            warn(n, "unreachable code %O", o);
            warnreach = 0;
        }

        scc = continpc;
        continpc = pc;
        gbranch(OGOTO);
        spc = p;

        sbc = breakpc;
        breakpc = pc;
        snbreak = nbreak;
        nbreak = 0;
        sncontin = ncontin;
        ncontin = 0;
        gbranch(OGOTO);
        spb = p;

        patch(spc, pc);
        gen(l->right->right);	/* inc */
        patch(sp, pc);	
        if(l->left != Z) {	/* test */
            bcomplex(l->left, Z);
            patch(p, breakpc);
            if(l->left->op != OCONST || vconst(l->left) == 0)
                nbreak++;
        }
        canreach = 1;
        gen(n->right);		/* body */
        if(canreach){
            gbranch(OGOTO);
            patch(p, continpc);
            ncontin++;
        }
        if(!ncontin && l->right->right && warnreach) {
            warn(l->right->right, "unreachable FOR inc");
            warnreach = 0;
        }

        patch(spb, pc);
        continpc = scc;
        breakpc = sbc;
        canreach = nbreak!=0;
        if(canreach == 0)
            warnreach = !suppress;
        nbreak = snbreak;
        ncontin = sncontin;
        break;

    case OCONTINUE:
        if(continpc < 0) {
            diag(n, "continue not in a loop");
            break;
        }
        gbranch(OGOTO);
        patch(p, continpc);
        ncontin++;
        canreach = 0;
        warnreach = !suppress;
        break;

    case OBREAK:
        if(breakpc < 0) {
            diag(n, "break not in a loop");
            break;
        }
        /*
         * Don't complain about unreachable break statements.
         * There are breaks hidden in yacc's output and some people
         * write return; break; in their switch statements out of habit.
         * However, don't confuse the analysis by inserting an 
         * unreachable reference to breakpc either.
         */
        if(!canreach)
            break;
        gbranch(OGOTO);
        patch(p, breakpc);
        nbreak++;
        canreach = 0;
        warnreach = !suppress;
        break;

    case OIF:
        l = n->left;
        if(bcomplex(l, n->right)) {
            if(typefd[l->type->etype])
                f = !l->fconst;
            else
                f = !l->vconst;
            if(debug['c'])
                print("%L const if %s\n", nearln, f ? "false" : "true");
            if(f) {
                canreach = 1;
                supgen(n->right->left);
                oldreach = canreach;
                canreach = 1;
                gen(n->right->right);
                /*
                 * treat constant ifs as regular ifs for 
                 * reachability warnings.
                 */
                if(!canreach && oldreach && debug['w'] < 2)
                    warnreach = 0;
            }
            else {
                canreach = 1;
                gen(n->right->left);
                oldreach = canreach;
                canreach = 1;
                supgen(n->right->right);
                /*
                 * treat constant ifs as regular ifs for 
                 * reachability warnings.
                 */
                if(!oldreach && canreach && debug['w'] < 2)
                    warnreach = 0;
                canreach = oldreach;
            }
        }
        else {
            sp = p;
            canreach = 1;
            if(n->right->left != Z)
                gen(n->right->left);
            oldreach = canreach;
            canreach = 1;
            if(n->right->right != Z) {
                gbranch(OGOTO);
                patch(sp, pc);
                sp = p;
                gen(n->right->right);
            }
            patch(sp, pc);
            canreach = canreach || oldreach;
            if(canreach == 0)
                warnreach = !suppress;
        }
        break;

    case OSET:
    case OUSED:
        usedset(n->left, o);
        break;
    }
}
@

<<function usedset>>=
void
usedset(Node *n, int o)
{
    if(n->op == OLIST) {
        usedset(n->left, o);
        usedset(n->right, o);
        return;
    }
    complex(n);
    switch(n->op) {
    case OADDR:	/* volatile */
        gins(ANOP, n, Z);
        break;
    case ONAME:
        if(o == OSET)
            gins(ANOP, Z, n);
        else
            gins(ANOP, n, Z);
        break;
    }
}
@

<<function bcomplex>>=
int
bcomplex(Node *n, Node *c)
{
    Node *b, nod;


    complex(n);
    if(n->type != T)
    if(tcompat(n, T, n->type, tnot))
        n->type = T;
    if(n->type == T) {
        gbranch(OGOTO);
        return 0;
    }
    if(c != Z && n->op == OCONST && deadheads(c))
        return 1;
    /* this is not quite right yet, so ignore it for now */
    if(0 && newvlongcode && typev[n->type->etype] && machcap(Z)) {
        b = &nod;
        b->op = ONE;
        b->left = n;
        b->right = new(0, Z, Z);
        *b->right = *nodconst(0);
        b->right->type = n->type;
        b->type = types[TLONG];
        cgen(b, Z);
        return 0;
    }
    bool64(n);
    boolgen(n, 1, Z);
    return 0;
}
@


%-------------------------------------------------------------

<<c2c/pgen.c>>=
#include "gc.h"

<<function codgen>>

<<function supgen>>

<<function uncomma>>

<<function gen>>

<<function usedset>>

<<function bcomplex>>
@


















\section{[[8c/]]}

\subsection*{[[8c/enam.c]]}

<<global anames>>=
char*	anames[] =
{
    "XXX",
    "AAA",
    "AAD",
    "AAM",
    "AAS",
    "ADCB",
    "ADCL",
    "ADCW",
    "ADDB",
    "ADDL",
    "ADDW",
    "ADJSP",
    "ANDB",
    "ANDL",
    "ANDW",
    "ARPL",
    "BOUNDL",
    "BOUNDW",
    "BSFL",
    "BSFW",
    "BSRL",
    "BSRW",
    "BTL",
    "BTW",
    "BTCL",
    "BTCW",
    "BTRL",
    "BTRW",
    "BTSL",
    "BTSW",
    "BYTE",
    "CALL",
    "CLC",
    "CLD",
    "CLI",
    "CLTS",
    "CMC",
    "CMPB",
    "CMPL",
    "CMPW",
    "CMPSB",
    "CMPSL",
    "CMPSW",
    "DAA",
    "DAS",
    "DATA",
    "DECB",
    "DECL",
    "DECW",
    "DIVB",
    "DIVL",
    "DIVW",
    "ENTER",
    "GLOBL",
    "GOK",
    "HISTORY",
    "HLT",
    "IDIVB",
    "IDIVL",
    "IDIVW",
    "IMULB",
    "IMULL",
    "IMULW",
    "INB",
    "INL",
    "INW",
    "INCB",
    "INCL",
    "INCW",
    "INSB",
    "INSL",
    "INSW",
    "INT",
    "INTO",
    "IRETL",
    "IRETW",
    "JCC",
    "JCS",
    "JCXZ",
    "JEQ",
    "JGE",
    "JGT",
    "JHI",
    "JLE",
    "JLS",
    "JLT",
    "JMI",
    "JMP",
    "JNE",
    "JOC",
    "JOS",
    "JPC",
    "JPL",
    "JPS",
    "LAHF",
    "LARL",
    "LARW",
    "LEAL",
    "LEAW",
    "LEAVEL",
    "LEAVEW",
    "LOCK",
    "LODSB",
    "LODSL",
    "LODSW",
    "LONG",
    "LOOP",
    "LOOPEQ",
    "LOOPNE",
    "LSLL",
    "LSLW",
    "MOVB",
    "MOVL",
    "MOVW",
    "MOVBLSX",
    "MOVBLZX",
    "MOVBWSX",
    "MOVBWZX",
    "MOVWLSX",
    "MOVWLZX",
    "MOVSB",
    "MOVSL",
    "MOVSW",
    "MULB",
    "MULL",
    "MULW",
    "NAME",
    "NEGB",
    "NEGL",
    "NEGW",
    "NOP",
    "NOTB",
    "NOTL",
    "NOTW",
    "ORB",
    "ORL",
    "ORW",
    "OUTB",
    "OUTL",
    "OUTW",
    "OUTSB",
    "OUTSL",
    "OUTSW",
    "POPAL",
    "POPAW",
    "POPFL",
    "POPFW",
    "POPL",
    "POPW",
    "PUSHAL",
    "PUSHAW",
    "PUSHFL",
    "PUSHFW",
    "PUSHL",
    "PUSHW",
    "RCLB",
    "RCLL",
    "RCLW",
    "RCRB",
    "RCRL",
    "RCRW",
    "REP",
    "REPN",
    "RET",
    "ROLB",
    "ROLL",
    "ROLW",
    "RORB",
    "RORL",
    "RORW",
    "SAHF",
    "SALB",
    "SALL",
    "SALW",
    "SARB",
    "SARL",
    "SARW",
    "SBBB",
    "SBBL",
    "SBBW",
    "SCASB",
    "SCASL",
    "SCASW",
    "SETCC",
    "SETCS",
    "SETEQ",
    "SETGE",
    "SETGT",
    "SETHI",
    "SETLE",
    "SETLS",
    "SETLT",
    "SETMI",
    "SETNE",
    "SETOC",
    "SETOS",
    "SETPC",
    "SETPL",
    "SETPS",
    "CDQ",
    "CWD",
    "SHLB",
    "SHLL",
    "SHLW",
    "SHRB",
    "SHRL",
    "SHRW",
    "STC",
    "STD",
    "STI",
    "STOSB",
    "STOSL",
    "STOSW",
    "SUBB",
    "SUBL",
    "SUBW",
    "SYSCALL",
    "TESTB",
    "TESTL",
    "TESTW",
    "TEXT",
    "VERR",
    "VERW",
    "WAIT",
    "WORD",
    "XCHGB",
    "XCHGL",
    "XCHGW",
    "XLAT",
    "XORB",
    "XORL",
    "XORW",
    "FMOVB",
    "FMOVBP",
    "FMOVD",
    "FMOVDP",
    "FMOVF",
    "FMOVFP",
    "FMOVL",
    "FMOVLP",
    "FMOVV",
    "FMOVVP",
    "FMOVW",
    "FMOVWP",
    "FMOVX",
    "FMOVXP",
    "FCOMB",
    "FCOMBP",
    "FCOMD",
    "FCOMDP",
    "FCOMDPP",
    "FCOMF",
    "FCOMFP",
    "FCOML",
    "FCOMLP",
    "FCOMW",
    "FCOMWP",
    "FUCOM",
    "FUCOMP",
    "FUCOMPP",
    "FADDDP",
    "FADDW",
    "FADDL",
    "FADDF",
    "FADDD",
    "FMULDP",
    "FMULW",
    "FMULL",
    "FMULF",
    "FMULD",
    "FSUBDP",
    "FSUBW",
    "FSUBL",
    "FSUBF",
    "FSUBD",
    "FSUBRDP",
    "FSUBRW",
    "FSUBRL",
    "FSUBRF",
    "FSUBRD",
    "FDIVDP",
    "FDIVW",
    "FDIVL",
    "FDIVF",
    "FDIVD",
    "FDIVRDP",
    "FDIVRW",
    "FDIVRL",
    "FDIVRF",
    "FDIVRD",
    "FXCHD",
    "FFREE",
    "FLDCW",
    "FLDENV",
    "FRSTOR",
    "FSAVE",
    "FSTCW",
    "FSTENV",
    "FSTSW",
    "F2XM1",
    "FABS",
    "FCHS",
    "FCLEX",
    "FCOS",
    "FDECSTP",
    "FINCSTP",
    "FINIT",
    "FLD1",
    "FLDL2E",
    "FLDL2T",
    "FLDLG2",
    "FLDLN2",
    "FLDPI",
    "FLDZ",
    "FNOP",
    "FPATAN",
    "FPREM",
    "FPREM1",
    "FPTAN",
    "FRNDINT",
    "FSCALE",
    "FSIN",
    "FSINCOS",
    "FSQRT",
    "FTST",
    "FXAM",
    "FXTRACT",
    "FYL2X",
    "FYL2XP1",
    "END",
    "DYNT",
    "INIT",
    "SIGNAME",
    "FCOMI",
    "FCOMIP",
    "FUCOMI",
    "FUCOMIP",
    "CMPXCHGB",
    "CMPXCHGL",
    "CMPXCHGW",
    "CMOVLCC",
    "CMOVLCS",
    "CMOVLEQ",
    "CMOVLGE",
    "CMOVLGT",
    "CMOVLHI",
    "CMOVLLE",
    "CMOVLLS",
    "CMOVLLT",
    "CMOVLMI",
    "CMOVLNE",
    "CMOVLOC",
    "CMOVLOS",
    "CMOVLPC",
    "CMOVLPL",
    "CMOVLPS",
    "CMOVWCC",
    "CMOVWCS",
    "CMOVWEQ",
    "CMOVWGE",
    "CMOVWGT",
    "CMOVWHI",
    "CMOVWLE",
    "CMOVWLS",
    "CMOVWLT",
    "CMOVWMI",
    "CMOVWNE",
    "CMOVWOC",
    "CMOVWOS",
    "CMOVWPC",
    "CMOVWPL",
    "CMOVWPS",
    "FCMOVCC",
    "FCMOVCS",
    "FCMOVEQ",
    "FCMOVHI",
    "FCMOVLS",
    "FCMOVNE",
    "FCMOVNU",
    "FCMOVUN",
    "LAST",
};
@


%-------------------------------------------------------------

<<8c/enam.c>>=
<<global anames>>
@


\subsection*{[[8c/gc.h]]}

<<constant SZ_CHAR>>=
/*
 * 8c/386
 * Intel 386
 */
#define	SZ_CHAR		1
@

<<constant SZ_SHORT>>=
#define	SZ_SHORT	2
@

<<constant SZ_INT>>=
#define	SZ_INT		4
@

<<constant SZ_LONG>>=
#define	SZ_LONG		4
@

<<constant SZ_IND>>=
#define	SZ_IND		4
@

<<constant SZ_FLOAT>>=
#define	SZ_FLOAT	4
@

<<constant SZ_VLONG>>=
#define	SZ_VLONG	8
@

<<constant SZ_DOUBLE>>=
#define	SZ_DOUBLE	8
@

<<constant FNX (8c/gc.h)>>=
#define	FNX		100
@

<<struct Idx>>=
struct Idx
{
    Node*	regtree;
    Node*	basetree;
    short	scale;
    short	reg;
    short	ptr;
};
@

<<struct Adr>>=
struct	Adr
{
    long	offset;
    double	dval;
    char	sval[NSNAME];

    Sym*	sym;
    uchar	type;
    uchar	index;
    uchar	etype;
    uchar	scale;	/* doubles as width in DATA op */
};
@

<<constant A>>=
#define	A	((Adr*)0)
@

<<constant INDEXED>>=
#define	INDEXED	9
@

<<struct Prog>>=
struct	Prog
{
    Adr	from;
    Adr	to;
    Prog*	link;
    long	lineno;
    short	as;
};
@

<<constant P>>=
#define	P	((Prog*)0)
@

<<struct Case>>=
struct	Case
{
    Case*	link;
    vlong	val;
    long	label;
    char	def;
    char isv;
};
@

<<constant C>>=
#define	C	((Case*)0)
@

<<struct C1>>=
struct	C1
{
    vlong	val;
    long	label;
};
@

<<struct Var>>=
struct	Var
{
    long	offset;
    Sym*	sym;
    char	name;
    char	etype;
};
@

<<struct Reg>>=
struct	Reg
{
    long	pc;
    long	rpo;		/* reverse post ordering */

    Bits	set;
    Bits	use1;
    Bits	use2;

    Bits	refbehind;
    Bits	refahead;
    Bits	calbehind;
    Bits	calahead;
    Bits	regdiff;
    Bits	act;

    long	regu;
    long	loop;		/* could be shorter */

    Reg*	log5;
    long	active;

    Reg*	p1;
    Reg*	p2;
    Reg*	p2link;
    Reg*	s1;
    Reg*	s2;
    Reg*	link;
    Prog*	prog;
};
@

<<constant R>>=
#define	R	((Reg*)0)
@

<<struct Renv>>=
struct	Renv
{
    int	safe;
    Node	base;
    Node*	saved;
    Node*	scope;
};
@

<<constant NRGN>>=
#define	NRGN	600
@

<<struct Rgn>>=
struct	Rgn
{
    Reg*	enter;
    short	cost;
    short	varno;
    short	regno;
};
@

<<function BLOAD>>=
#define	BLOAD(r)	band(bnot(r->refbehind), r->refahead)
@

<<function BSTORE>>=
#define	BSTORE(r)	band(bnot(r->calbehind), r->calahead)
@

<<function LOAD>>=
#define	LOAD(r)		(~r->refbehind.b[z] & r->refahead.b[z])
@

<<function STORE>>=
#define	STORE(r)	(~r->calbehind.b[z] & r->calahead.b[z])
@

<<macro bset>>=
#define	bset(a,n)	((a).b[(n)/32]&(1L<<(n)%32))
@

<<constant CLOAD>>=
#define	CLOAD	5
@

<<constant CREF>>=
#define	CREF	5
@

<<constant CINF>>=
#define	CINF	1000
@

<<constant LOOP>>=
#define	LOOP	3
@

<<constant D_HI>>=
#define	D_HI	D_NONE
@

<<constant D_LO>>=
#define	D_LO	D_NONE
@

<<constant rplink>>=
/* wrecklessly steal a field */

#define	rplink	label
@


%-------------------------------------------------------------

<<8c/gc.h>>=
#include	"../cc/cc.h"
#include	<common.out.h>
#include	"386/8.out.h"

<<constant SZ_CHAR>>
<<constant SZ_SHORT>>
<<constant SZ_INT>>
<<constant SZ_LONG>>
<<constant SZ_IND>>
<<constant SZ_FLOAT>>
<<constant SZ_VLONG>>
<<constant SZ_DOUBLE>>
<<constant FNX (8c/gc.h)>>

typedef	struct	Adr	Adr;
typedef	struct	Prog	Prog;
typedef	struct	Case	Case;
typedef	struct	C1	C1;
typedef	struct	Var	Var;
typedef	struct	Reg	Reg;
typedef	struct	Rgn	Rgn;
typedef	struct	Renv	Renv;

<<struct Idx>>
extern struct Idx idx;

<<struct Adr>>
<<constant A>>

<<constant INDEXED>>
<<struct Prog>>
<<constant P>>

<<struct Case>>
<<constant C>>

<<struct C1>>

<<struct Var>>

<<struct Reg>>
<<constant R>>

<<struct Renv>>

<<constant NRGN>>
<<struct Rgn>>

extern	long	breakpc;
extern	long	nbreak;
extern	Case*	cases;
extern	Node	constnode;
extern	Node	fconstnode;
extern	long	continpc;
extern	long	curarg;
extern	long	cursafe;
extern	Prog*	firstp;
extern	Prog*	lastp;
extern	long	maxargsafe;
extern	int	mnstring;
extern	Node*	nodrat;
extern	Node*	nodret;
extern	Node*	nodsafe;
extern	long	nrathole;
extern	long	nstring;
extern	Prog*	p;
extern	long	pc;
extern	Node	regnode;
extern	Node	fregnode0;
extern	Node	fregnode1;
extern	char	string[NSNAME];
extern	Sym*	symrathole;
extern	Node	znode;
extern	Prog	zprog;
extern	int	reg[D_NONE];
extern	long	exregoffset;
extern	long	exfregoffset;

<<function BLOAD>>
<<function BSTORE>>
<<function LOAD>>
<<function STORE>>

<<macro bset>>

<<constant CLOAD>>
<<constant CREF>>
<<constant CINF>>
<<constant LOOP>>

extern	Rgn	region[NRGN];
extern	Rgn*	rgp;
extern	int	nregion;
extern	int	nvar;

extern	Bits	externs;
extern	Bits	params;
extern	Bits	consts;
extern	Bits	addrs;

extern	long	regbits;
extern	long	exregbits;

extern	int	change;
extern	int	suppress;

extern	Reg*	firstr;
extern	Reg*	lastr;
extern	Reg	zreg;
extern	Reg*	freer;
extern	Var	var[NVAR];
extern	long*	idom;
extern	Reg**	rpo2r;
extern	long	maxnr;

extern	char*	anames[];

/*
 * sgen.c
 */
void	codgen(Node*, Node*);
void	gen(Node*);
void	noretval(int);
void	usedset(Node*, int);
void	xcom(Node*);
void	indx(Node*);
int	bcomplex(Node*, Node*);

/*
 * cgen.c
 */
void	zeroregm(Node*);
void	cgen(Node*, Node*);
void	reglcgen(Node*, Node*, Node*);
void	lcgen(Node*, Node*);
void	bcgen(Node*, int);
void	boolgen(Node*, int, Node*);
void	sugen(Node*, Node*, long);
int	needreg(Node*, int);

/*
 * cgen64.c
 */
int	vaddr(Node*, int);
void	loadpair(Node*, Node*);
int	cgen64(Node*, Node*);
void	testv(Node*, int);

/*
 * txt.c
 */
void	ginit(void);
void	gclean(void);
void	nextpc(void);
void	gargs(Node*, Node*, Node*);
void	garg1(Node*, Node*, Node*, int, Node**);
Node*	nodconst(long);
int	nareg(int);
Node*	nodfconst(double);
int	nodreg(Node*, Node*, int);
int	isreg(Node*, int);
void	regret(Node*, Node*);
void	regalloc(Node*, Node*, Node*);
void	regfree(Node*);
void	regialloc(Node*, Node*, Node*);
void	regsalloc(Node*, Node*);
void	regaalloc1(Node*, Node*);
void	regaalloc(Node*, Node*);
void	regind(Node*, Node*);
void	gprep(Node*, Node*);
void	naddr(Node*, Adr*);
void	gmove(Node*, Node*);
void	gins(int a, Node*, Node*);
void	fgopcode(int, Node*, Node*, int, int);
void	gopcode(int, Type*, Node*, Node*);
int	samaddr(Node*, Node*);
void	gbranch(int);
void	patch(Prog*, long);
int	sconst(Node*);
void	gpseudo(int, Sym*, Node*);

/*
 * swt.c
 */
int	swcmp(const void*, const void*);
void	doswit(Node*);
void	swit1(C1*, int, long, Node*);
void	casf(void);
void	bitload(Node*, Node*, Node*, Node*, Node*);
void	bitstore(Node*, Node*, Node*, Node*, Node*);
long	outstring(char*, long);
void	nullwarn(Node*, Node*);
void	gextern(Sym*, Node*, long, long);
void	outcode(void);
void	ieeedtod(Ieee*, double);

/*
 * list
 */
void	listinit(void);
int	Pconv(Fmt*);
int	Aconv(Fmt*);
int	Dconv(Fmt*);
int	Sconv(Fmt*);
int	Rconv(Fmt*);
int	Xconv(Fmt*);
int	Bconv(Fmt*);

/*
 * reg.c
 */
Reg*	rega(void);
int	rcmp(const void*, const void*);
void	regopt(Prog*);
void	addmove(Reg*, int, int, int);
Bits	mkvar(Reg*, Adr*, int);
void	prop(Reg*, Bits, Bits);
void	loopit(Reg*, long);
void	synch(Reg*, Bits);
ulong	allreg(ulong, Rgn*);
void	paint1(Reg*, int);
ulong	paint2(Reg*, int);
void	paint3(Reg*, int, long, int);
void	addreg(Adr*, int);

/*
 * peep.c
 */
void	peep(void);
void	excise(Reg*);
Reg*	uniqp(Reg*);
Reg*	uniqs(Reg*);
int	regtyp(Adr*);
int	anyvar(Adr*);
int	subprop(Reg*);
int	copyprop(Reg*);
int	copy1(Adr*, Adr*, Reg*, int);
int	copyu(Prog*, Adr*, Adr*);

int	copyas(Adr*, Adr*);
int	copyau(Adr*, Adr*);
int	copysub(Adr*, Adr*, Adr*, int);
int	copysub1(Prog*, Adr*, Adr*, int);

long	RtoB(int);
long	FtoB(int);
int	BtoR(long);
int	BtoF(long);

<<constant D_HI>>
<<constant D_LO>>

/*
 * com64
 */
int	cond(int);
int	com64(Node*);
void	com64init(void);
void	bool64(Node*);
long	lo64v(Node*);
long	hi64v(Node*);
Node*	lo64(Node*);
Node*	hi64(Node*);

/*
 * div/mul
 */
void	sdivgen(Node*, Node*, Node*, Node*);
void	udivgen(Node*, Node*, Node*, Node*);
void	sdiv2(long, int, Node*, Node*);
void	smod2(long, int, Node*, Node*);
void	mulgen(Type*, Node*, Node*);
void	genmuladd(Node*, Node*, int, Node*);
void	shiftit(Type*, Node*, Node*);

#pragma	varargck	type	"A"	int
#pragma	varargck	type	"B"	Bits
#pragma	varargck	type	"D"	Adr*
#pragma	varargck	type	"P"	Prog*
#pragma	varargck	type	"R"	int
#pragma	varargck	type	"S"	char*

<<constant rplink>>
@


\subsection*{[[8c/machcap.c]]}

<<function machcap>>=
int
machcap(Node *n)
{
//	return 0;

    if(n == Z)
        return 1;	/* test */

    switch(n->op) {
    case OMUL:
    case OLMUL:
    case OASMUL:
    case OASLMUL:
        if(typechl[n->type->etype])
            return 1;
        if(typev[n->type->etype]) {
//		if(typev[n->type->etype] && n->right->op == OCONST) {
//			if(hi64v(n->right) == 0)
                return 1;
        }
        break;

    case OCOM:
    case ONEG:
    case OADD:
    case OAND:
    case OOR:
    case OSUB:
    case OXOR:
    case OASHL:
    case OLSHR:
    case OASHR:
        if(typechlv[n->left->type->etype])
            return 1;
        break;

    case OCAST:
        if(typev[n->type->etype]) {
            if(typechlp[n->left->type->etype])
                return 1;
        }
        else if(!typefd[n->type->etype]) {
            if(typev[n->left->type->etype])
                return 1;
        }
        break;

    case OCOND:
    case OCOMMA:
    case OLIST:
    case OANDAND:
    case OOROR:
    case ONOT:
    case ODOT:
        return 1;

    case OASADD:
    case OASSUB:
    case OASAND:
    case OASOR:
    case OASXOR:
        return 1;

    case OASASHL:
    case OASASHR:
    case OASLSHR:
        return 1;

    case OPOSTINC:
    case OPOSTDEC:
    case OPREINC:
    case OPREDEC:
        return 1;

    case OEQ:
    case ONE:
    case OLE:
    case OGT:
    case OLT:
    case OGE:
    case OHI:
    case OHS:
    case OLO:
    case OLS:
//print("%O\n", n->op);
        return 1;
    }
    return 0;
}
@


%-------------------------------------------------------------

<<8c/machcap.c>>=
#include "gc.h"

<<function machcap>>
@


\subsection*{[[8c/globals2.c]]}

<<global idx>>=
struct Idx idx;
@

<<global breakpc>>=
long	breakpc;
@

<<global nbreak>>=
long	nbreak;
@

<<global cases>>=
Case*	cases;
@

<<global constnode>>=
Node	constnode;
@

<<global fconstnode>>=
Node	fconstnode;
@

<<global continpc>>=
long	continpc;
@

<<global curarg>>=
long	curarg;
@

<<global cursafe>>=
long	cursafe;
@

<<global firstp>>=
Prog*	firstp;
@

<<global lastp>>=
Prog*	lastp;
@

<<global maxargsafe>>=
long	maxargsafe;
@

<<global mnstring>>=
int	mnstring;
@

<<global nodrat>>=
Node*	nodrat;
@

<<global nodret>>=
Node*	nodret;
@

<<global nodsafe>>=
Node*	nodsafe;
@

<<global nrathole>>=
long	nrathole;
@

<<global nstring>>=
long	nstring;
@

<<global p>>=
Prog*	p;
@

<<global pc>>=
long	pc;
@

<<global regnode>>=
Node	regnode;
@

<<global fregnode0>>=
Node	fregnode0;
@

<<global fregnode1>>=
Node	fregnode1;
@

<<global string>>=
char	string[NSNAME];
@

<<global symrathole>>=
Sym*	symrathole;
@

<<global znode>>=
Node	znode;
@

<<global zprog>>=
Prog	zprog;
@

<<global reg>>=
int	reg[D_NONE];
@

<<global exregoffset>>=
long	exregoffset;
@

<<global exfregoffset>>=
long	exfregoffset;
@

<<global region>>=
Rgn	region[NRGN];
@

<<global rgp>>=
Rgn*	rgp;
@

<<global nregion>>=
int	nregion;
@

<<global nvar>>=
int	nvar;
@

<<global externs>>=
Bits	externs;
@

<<global params>>=
Bits	params;
@

<<global consts>>=
Bits	consts;
@

<<global addrs>>=
Bits	addrs;
@

<<global regbits>>=
long	regbits;
@

<<global exregbits>>=
long	exregbits;
@

<<global change>>=
int	change;
@

<<global suppress>>=
int	suppress;
@

<<global firstr>>=
Reg*	firstr;
@

<<global lastr>>=
Reg*	lastr;
@

<<global zreg>>=
Reg	zreg;
@

<<global freer>>=
Reg*	freer;
@

<<global var>>=
Var	var[NVAR];
@

<<global idom>>=
long*	idom;
@

<<global rpo2r>>=
Reg**	rpo2r;
@

<<global maxnr>>=
long	maxnr;
@


%-------------------------------------------------------------

<<8c/globals2.c>>=
#include "gc.h"

<<global idx>>

<<global breakpc>>
<<global nbreak>>
<<global cases>>
<<global constnode>>
<<global fconstnode>>
<<global continpc>>
<<global curarg>>
<<global cursafe>>
<<global firstp>>
<<global lastp>>
<<global maxargsafe>>
<<global mnstring>>
<<global nodrat>>
<<global nodret>>
<<global nodsafe>>
<<global nrathole>>
<<global nstring>>
<<global p>>
<<global pc>>
<<global regnode>>
<<global fregnode0>>
<<global fregnode1>>
<<global string>>
<<global symrathole>>
<<global znode>>
<<global zprog>>
<<global reg>>
<<global exregoffset>>
<<global exfregoffset>>

<<global region>>
<<global rgp>>
<<global nregion>>
<<global nvar>>

<<global externs>>
<<global params>>
<<global consts>>
<<global addrs>>

<<global regbits>>
<<global exregbits>>

<<global change>>
<<global suppress>>

<<global firstr>>
<<global lastr>>
<<global zreg>>
<<global freer>>
<<global var>>
<<global idom>>
<<global rpo2r>>
<<global maxnr>>
@


\subsection*{[[8c/list.c]]}

<<function listinit>>=
void
listinit(void)
{

    fmtinstall('A', Aconv);
    fmtinstall('B', Bconv);
    fmtinstall('P', Pconv);
    fmtinstall('S', Sconv);
    fmtinstall('D', Dconv);
    fmtinstall('R', Rconv);
}
@

<<function Bconv>>=
int
Bconv(Fmt *fp)
{
    char str[STRINGSZ], ss[STRINGSZ], *s;
    Bits bits;
    int i;

    str[0] = 0;
    bits = va_arg(fp->args, Bits);
    while(bany(&bits)) {
        i = bnum(bits);
        if(str[0])
            strcat(str, " ");
        if(var[i].sym == S) {
            snprint(ss, sizeof(ss), "$%ld", var[i].offset);
            s = ss;
        } else
            s = var[i].sym->name;
        if(strlen(str) + strlen(s) + 1 >= STRINGSZ)
            break;
        strcat(str, s);
        bits.b[i/32] &= ~(1L << (i%32));
    }
    return fmtstrcpy(fp, str);
}
@

<<function Pconv>>=
int
Pconv(Fmt *fp)
{
    char str[STRINGSZ];
    Prog *p;

    p = va_arg(fp->args, Prog*);
    if(p->as == ADATA)
        snprint(str, sizeof(str), "	%A	%D/%d,%D",
            p->as, &p->from, p->from.scale, &p->to);
    else if(p->as == ATEXT)
        snprint(str, sizeof(str), "	%A	%D,%d,%D",
            p->as, &p->from, p->from.scale, &p->to);
    else
        snprint(str, sizeof(str), "	%A	%D,%D",
            p->as, &p->from, &p->to);
    return fmtstrcpy(fp, str);
}
@

<<function Aconv>>=
int
Aconv(Fmt *fp)
{
    int i;

    i = va_arg(fp->args, int);
    return fmtstrcpy(fp, anames[i]);
}
@

<<function Dconv>>=
int
Dconv(Fmt *fp)
{
    char str[40], s[20];
    Adr *a;
    int i;

    a = va_arg(fp->args, Adr*);
    i = a->type;
    if(i >= D_INDIR) {
        if(a->offset)
            snprint(str, sizeof(str), "%ld(%R)", a->offset, i-D_INDIR);
        else
            snprint(str, sizeof(str), "(%R)", i-D_INDIR);
        goto brk;
    }
    switch(i) {

    default:
        if(a->offset)
            snprint(str, sizeof(str), "$%ld,%R", a->offset, i);
        else
            snprint(str, sizeof(str), "%R", i);
        break;

    case D_NONE:
        str[0] = 0;
        break;

    case D_BRANCH:
        snprint(str, sizeof(str), "%ld(PC)", a->offset-pc);
        break;

    case D_EXTERN:
        snprint(str, sizeof(str), "%s+%ld(SB)", a->sym->name, a->offset);
        break;

    case D_STATIC:
        snprint(str, sizeof(str), "%s<>+%ld(SB)", a->sym->name,
            a->offset);
        break;

    case D_AUTO:
        snprint(str, sizeof(str), "%s+%ld(SP)", a->sym->name, a->offset);
        break;

    case D_PARAM:
        if(a->sym)
            snprint(str, sizeof(str), "%s+%ld(FP)", a->sym->name, a->offset);
        else
            snprint(str, sizeof(str), "%ld(FP)", a->offset);
        break;

    case D_CONST:
        snprint(str, sizeof(str), "$%ld", a->offset);
        break;

    case D_FCONST:
        snprint(str, sizeof(str), "$(%.17e)", a->dval);
        break;

    case D_SCONST:
        snprint(str, sizeof(str), "$\"%S\"", a->sval);
        break;

    case D_ADDR:
        a->type = a->index;
        a->index = D_NONE;
        snprint(str, sizeof(str), "$%D", a);
        a->index = a->type;
        a->type = D_ADDR;
        goto conv;
    }
brk:
    if(a->index != D_NONE) {
        fmtstrcpy(fp, str);
        snprint(s, sizeof(s), "(%R*%d)", (int)a->index, (int)a->scale);
        return fmtstrcpy(fp, s);
    }
conv:
    return fmtstrcpy(fp, str);
}
@

<<global regstr>>=
char*	regstr[] =
{
    "AL",	/*[D_AL]*/	
    "CL",
    "DL",
    "BL",
    "AH",
    "CH",
    "DH",
    "BH",

    "AX",	/*[D_AX]*/
    "CX",
    "DX",
    "BX",
    "SP",
    "BP",
    "SI",
    "DI",

    "F0",	/*[D_F0]*/
    "F1",
    "F2",
    "F3",
    "F4",
    "F5",
    "F6",
    "F7",

    "CS",	/*[D_CS]*/
    "SS",
    "DS",
    "ES",
    "FS",
    "GS",

    "GDTR",	/*[D_GDTR]*/
    "IDTR",	/*[D_IDTR]*/
    "LDTR",	/*[D_LDTR]*/
    "MSW",	/*[D_MSW] */
    "TASK",	/*[D_TASK]*/

    "CR0",	/*[D_CR]*/
    "CR1",
    "CR2",
    "CR3",
    "CR4",
    "CR5",
    "CR6",
    "CR7",

    "DR0",	/*[D_DR]*/
    "DR1",
    "DR2",
    "DR3",
    "DR4",
    "DR5",
    "DR6",
    "DR7",

    "TR0",	/*[D_TR]*/
    "TR1",
    "TR2",
    "TR3",
    "TR4",
    "TR5",
    "TR6",
    "TR7",

    "NONE",	/*[D_NONE]*/
};
@

<<function Rconv>>=
int
Rconv(Fmt *fp)
{
    char str[20];
    int r;

    r = va_arg(fp->args, int);
    if(r >= D_AL && r <= D_NONE)
        snprint(str, sizeof(str), "%s", regstr[r-D_AL]);
    else
        snprint(str, sizeof(str), "gok(%d)", r);

    return fmtstrcpy(fp, str);
}
@

<<function Sconv>>=
int
Sconv(Fmt *fp)
{
    int i, c;
    char str[30], *p, *a;

    a = va_arg(fp->args, char*);
    p = str;
    for(i=0; i<sizeof(double); i++) {
        c = a[i] & 0xff;
        if(c >= 'a' && c <= 'z' ||
           c >= 'A' && c <= 'Z' ||
           c >= '0' && c <= '9') {
            *p++ = c;
            continue;
        }
        *p++ = '\\';
        switch(c) {
        default:
            if(c < 040 || c >= 0177)
                break;	/* not portable */
            p[-1] = c;
            continue;
        case 0:
            *p++ = 'z';
            continue;
        case '\\':
        case '"':
            *p++ = c;
            continue;
        case '\n':
            *p++ = 'n';
            continue;
        case '\t':
            *p++ = 't';
            continue;
        }
        *p++ = (c>>6) + '0';
        *p++ = ((c>>3) & 7) + '0';
        *p++ = (c & 7) + '0';
    }
    *p = 0;
    return fmtstrcpy(fp, str);
}
@


%-------------------------------------------------------------

<<8c/list.c>>=
#include "gc.h"

<<function listinit>>

<<function Bconv>>

<<function Pconv>>

<<function Aconv>>

<<function Dconv>>

<<global regstr>>

<<function Rconv>>

<<function Sconv>>
@


\subsection*{[[8c/txt.c]]}

<<function ginit>>=
void
ginit(void)
{
    int i;
    Type *t;

    thechar = '8';
    thestring = "386";
    exregoffset = 0;
    exfregoffset = 0;
    listinit();
    nstring = 0;
    mnstring = 0;
    nrathole = 0;
    pc = 0;
    breakpc = -1;
    continpc = -1;
    cases = C;
    firstp = P;
    lastp = P;
    tfield = types[TLONG];

    typeswitch = typechlv;

    zprog.link = P;
    zprog.as = AGOK;
    zprog.from.type = D_NONE;
    zprog.from.index = D_NONE;
    zprog.from.scale = 0;
    zprog.to = zprog.from;

    regnode.op = OREGISTER;
    regnode.class = CEXREG;
    regnode.reg = REGTMP;
    regnode.complex = 0;
    regnode.addable = 11;
    regnode.type = types[TLONG];

    fregnode0 = regnode;
    fregnode0.reg = D_F0;
    fregnode0.type = types[TDOUBLE];

    fregnode1 = fregnode0;
    fregnode1.reg = D_F0+1;

    constnode.op = OCONST;
    constnode.class = CXXX;
    constnode.complex = 0;
    constnode.addable = 20;
    constnode.type = types[TLONG];

    fconstnode.op = OCONST;
    fconstnode.class = CXXX;
    fconstnode.complex = 0;
    fconstnode.addable = 20;
    fconstnode.type = types[TDOUBLE];

    nodsafe = new(ONAME, Z, Z);
    nodsafe->sym = slookup(".safe");
    nodsafe->type = types[TINT];
    nodsafe->etype = types[TINT]->etype;
    nodsafe->class = CAUTO;
    complex(nodsafe);

    t = typ(TARRAY, types[TCHAR]);
    symrathole = slookup(".rathole");
    symrathole->class = CGLOBL;
    symrathole->type = t;

    nodrat = new(ONAME, Z, Z);
    nodrat->sym = symrathole;
    nodrat->type = types[TIND];
    nodrat->etype = TVOID;
    nodrat->class = CGLOBL;
    complex(nodrat);
    nodrat->type = t;

    nodret = new(ONAME, Z, Z);
    nodret->sym = slookup(".ret");
    nodret->type = types[TIND];
    nodret->etype = TIND;
    nodret->class = CPARAM;
    nodret = new(OIND, nodret, Z);
    complex(nodret);

    com64init();

    for(i=0; i<nelem(reg); i++) {
        reg[i] = 1;
        if(i >= D_AX && i <= D_DI && i != D_SP)
            reg[i] = 0;
    }
}
@

<<function gclean>>=
void
gclean(void)
{
    int i;
    Sym *s;

    reg[D_SP]--;
    for(i=D_AX; i<=D_DI; i++)
        if(reg[i])
            diag(Z, "reg %R left allocated", i);
    while(mnstring)
        outstring("", 1L);
    symstring->type->width = nstring;
    symrathole->type->width = nrathole;
    for(i=0; i<NHASH; i++)
    for(s = hash[i]; s != S; s = s->link) {
        if(s->type == T)
            continue;
        if(s->type->width == 0)
            continue;
        if(s->class != CGLOBL && s->class != CSTATIC)
            continue;
        if(s->type == types[TENUM])
            continue;
        gpseudo(AGLOBL, s, nodconst(s->type->width));
    }
    nextpc();
    p->as = AEND;
    outcode();
}
@

<<function nextpc>>=
void
nextpc(void)
{

    p = alloc(sizeof(*p));
    *p = zprog;
    p->lineno = nearln;
    pc++;
    if(firstp == P) {
        firstp = p;
        lastp = p;
        return;
    }
    lastp->link = p;
    lastp = p;
}
@

<<function gargs>>=
void
gargs(Node *n, Node *tn1, Node *tn2)
{
    long regs;
    Node fnxargs[20], *fnxp;

    regs = cursafe;

    fnxp = fnxargs;
    garg1(n, tn1, tn2, 0, &fnxp);	/* compile fns to temps */

    curarg = 0;
    fnxp = fnxargs;
    garg1(n, tn1, tn2, 1, &fnxp);	/* compile normal args and temps */

    cursafe = regs;
}
@

<<function nareg>>=
int
nareg(int notbp)
{
    int i, n;

    n = 0;
    for(i=D_AX; i<=D_DI; i++)
        if(reg[i] == 0)
            n++;
    if(notbp && reg[D_BP] == 0)
        n--;
    return n;
}
@

<<function garg1>>=
void
garg1(Node *n, Node *tn1, Node *tn2, int f, Node **fnxp)
{
    Node nod;

    if(n == Z)
        return;
    if(n->op == OLIST) {
        garg1(n->left, tn1, tn2, f, fnxp);
        garg1(n->right, tn1, tn2, f, fnxp);
        return;
    }
    if(f == 0) {
        if(n->complex >= FNX) {
            regsalloc(*fnxp, n);
            nod = znode;
            nod.op = OAS;
            nod.left = *fnxp;
            nod.right = n;
            nod.type = n->type;
            cgen(&nod, Z);
            (*fnxp)++;
        }
        return;
    }
    if(typesu[n->type->etype] || typev[n->type->etype]) {
        regaalloc(tn2, n);
        if(n->complex >= FNX) {
            sugen(*fnxp, tn2, n->type->width);
            (*fnxp)++;
        } else
            sugen(n, tn2, n->type->width);
        return;
    }
    if(REGARG>=0 && curarg == 0 && typeilp[n->type->etype]) {
        regaalloc1(tn1, n);
        if(n->complex >= FNX) {
            cgen(*fnxp, tn1);
            (*fnxp)++;
        } else
            cgen(n, tn1);
        return;
    }
    if(vconst(n) == 0) {
        regaalloc(tn2, n);
        gmove(n, tn2);
        return;
    }
    regalloc(tn1, n, Z);
    if(n->complex >= FNX) {
        cgen(*fnxp, tn1);
        (*fnxp)++;
    } else
        cgen(n, tn1);
    regaalloc(tn2, n);
    gmove(tn1, tn2);
    regfree(tn1);
}
@

<<function nodconst>>=
Node*
nodconst(long v)
{
    constnode.vconst = v;
    return &constnode;
}
@

<<function nodfconst>>=
Node*
nodfconst(double d)
{
    fconstnode.fconst = d;
    return &fconstnode;
}
@

<<function isreg>>=
int
isreg(Node *n, int r)
{

    if(n->op == OREGISTER)
        if(n->reg == r)
            return 1;
    return 0;
}
@

<<function nodreg>>=
int
nodreg(Node *n, Node *nn, int r)
{

    *n = regnode;
    n->reg = r;
    if(reg[r] == 0)
        return 0;
    if(nn != Z) {
        n->type = nn->type;
        n->lineno = nn->lineno;
        if(nn->op == OREGISTER)
        if(nn->reg == r)
            return 0;
    }
    return 1;
}
@

<<function regret>>=
void
regret(Node *n, Node *nn)
{
    int r;

    r = REGRET;
    if(typefd[nn->type->etype])
        r = FREGRET;
    nodreg(n, nn, r);
    reg[r]++;
}
@

<<function regalloc>>=
void
regalloc(Node *n, Node *tn, Node *o)
{
    int i;

    switch(tn->type->etype) {
    case TCHAR:
    case TUCHAR:
    case TSHORT:
    case TUSHORT:
    case TINT:
    case TUINT:
    case TLONG:
    case TULONG:
    case TIND:
        if(o != Z && o->op == OREGISTER) {
            i = o->reg;
            if(i >= D_AX && i <= D_DI)
                goto out;
        }
        for(i=D_AX; i<=D_DI; i++)
            if(reg[i] == 0)
                goto out;
        diag(tn, "out of fixed registers");
abort();
        goto err;

    case TFLOAT:
    case TDOUBLE:
        i = D_F0;
        goto out;

    case TVLONG:
    case TUVLONG:
        n->op = OREGPAIR;
        n->complex = 0; /* already in registers */
        n->addable = 11;
        n->type = tn->type;
        n->lineno = nearln;
        n->left = alloc(sizeof(Node));
        n->right = alloc(sizeof(Node));
        if(o != Z && o->op == OREGPAIR) {
            regalloc(n->left, &regnode, o->left);
            regalloc(n->right, &regnode, o->right);
        } else {
            regalloc(n->left, &regnode, Z);
            regalloc(n->right, &regnode, Z);
        }
        n->right->type = types[TULONG];
        if(tn->type->etype == TUVLONG)
            n->left->type = types[TULONG];
        return;
    }
    diag(tn, "unknown type in regalloc: %T", tn->type);
err:
    i = 0;
out:
    if(i)
        reg[i]++;
    nodreg(n, tn, i);
//print("+ %R %d\n", i, reg[i]);
}
@

<<function regialloc>>=
void
regialloc(Node *n, Node *tn, Node *o)
{
    Node nod;

    nod = *tn;
    nod.type = types[TIND];
    regalloc(n, &nod, o);
}
@

<<function regfree>>=
void
regfree(Node *n)
{
    int i;

    if(n->op == OREGPAIR) {
        regfree(n->left);
        regfree(n->right);
        return;
    }

    i = 0;
    if(n->op != OREGISTER && n->op != OINDREG)
        goto err;
    i = n->reg;
    if(i < 0 || i >= sizeof(reg))
        goto err;
    if(reg[i] <= 0)
        goto err;
    reg[i]--;
//print("- %R %d\n", i, reg[i]);
    return;
err:
    diag(n, "error in regfree: %R", i);
}
@

<<function regsalloc>>=
void
regsalloc(Node *n, Node *nn)
{
    cursafe = align(cursafe, nn->type, Aaut3);
    maxargsafe = maxround(maxargsafe, cursafe+curarg);
    *n = *nodsafe;
    n->xoffset = -(stkoff + cursafe);
    n->type = nn->type;
    n->etype = nn->type->etype;
    n->lineno = nn->lineno;
}
@

<<function regaalloc1>>=
void
regaalloc1(Node *n, Node *nn)
{
    USED(nn);

    if(REGARG < 0) {
        diag(n, "regaalloc1");
        return;
    }
/* not reached 
    nodreg(n, nn, REGARG);
    reg[REGARG]++;
    curarg = align(curarg, nn->type, Aarg1);
    curarg = align(curarg, nn->type, Aarg2);
    maxargsafe = maxround(maxargsafe, cursafe+curarg);
*/
}
@

<<function regaalloc>>=
void
regaalloc(Node *n, Node *nn)
{
    curarg = align(curarg, nn->type, Aarg1);
    *n = *nn;
    n->op = OINDREG;
    n->reg = REGSP;
    n->xoffset = curarg;
    n->complex = 0;
    n->addable = 20;
    curarg = align(curarg, nn->type, Aarg2);
    maxargsafe = maxround(maxargsafe, cursafe+curarg);
}
@

<<function regind>>=
void
regind(Node *n, Node *nn)
{

    if(n->op != OREGISTER) {
        diag(n, "regind not OREGISTER");
        return;
    }
    n->op = OINDREG;
    n->type = nn->type;
}
@

<<function naddr>>=
void
naddr(Node *n, Adr *a)
{
    long v;

    a->type = D_NONE;
    if(n == Z)
        return;
    switch(n->op) {
    default:
    bad:
        diag(n, "bad in naddr: %O %D", n->op, a);
//prtree(n, "naddr");
        break;

    case OREGISTER:
        a->type = n->reg;
        a->sym = S;
        break;

    case OEXREG:
        a->type = D_INDIR + D_GS;
        a->offset = n->reg - 1;
        a->etype = n->etype;
        break;

    case OIND:
        naddr(n->left, a);
        if(a->type >= D_AX && a->type <= D_DI)
            a->type += D_INDIR;
        else
        if(a->type == D_CONST)
            a->type = D_NONE+D_INDIR;
        else
        if(a->type == D_ADDR) {
            a->type = a->index;
            a->index = D_NONE;
        } else
            goto bad;
        break;

    case OINDEX:
        a->type = idx.ptr;
        if(n->left->op == OADDR || n->left->op == OCONST)
            naddr(n->left, a);
        if(a->type >= D_AX && a->type <= D_DI)
            a->type += D_INDIR;
        else
        if(a->type == D_CONST)
            a->type = D_NONE+D_INDIR;
        else
        if(a->type == D_ADDR) {
            a->type = a->index;
            a->index = D_NONE;
        } else
            goto bad;
        a->index = idx.reg;
        a->scale = n->scale;
        a->offset += n->xoffset;
        break;

    case OINDREG:
        a->type = n->reg+D_INDIR;
        a->sym = S;
        a->offset = n->xoffset;
        break;

    case ONAME:
        a->etype = n->etype;
        a->type = D_STATIC;
        a->sym = n->sym;
        a->offset = n->xoffset;
        if(n->class == CSTATIC)
            break;
        if(n->class == CEXTERN || n->class == CGLOBL) {
            a->type = D_EXTERN;
            break;
        }
        if(n->class == CAUTO) {
            a->type = D_AUTO;
            break;
        }
        if(n->class == CPARAM) {
            a->type = D_PARAM;
            break;
        }
        goto bad;

    case OCONST:
        if(typefd[n->type->etype]) {
            a->type = D_FCONST;
            a->dval = n->fconst;
            break;
        }
        a->sym = S;
        a->type = D_CONST;
        a->offset = n->vconst;
        break;

    case OADDR:
        naddr(n->left, a);
        if(a->type >= D_INDIR) {
            a->type -= D_INDIR;
            break;
        }
        if(a->type == D_EXTERN || a->type == D_STATIC ||
           a->type == D_AUTO || a->type == D_PARAM)
            if(a->index == D_NONE) {
                a->index = a->type;
                a->type = D_ADDR;
                break;
            }
        goto bad;

    case OADD:
        if(n->right->op == OCONST) {
            v = n->right->vconst;
            naddr(n->left, a);
        } else
        if(n->left->op == OCONST) {
            v = n->left->vconst;
            naddr(n->right, a);
        } else
            goto bad;
        a->offset += v;
        break;

    }
}
@

<<function CASE>>=
#define	CASE(a,b)	((a<<8)|(b<<0))
@

<<function gmove>>=
void
gmove(Node *f, Node *t)
{
    int ft, tt, a;
    Node nod, nod1;
    Prog *p1;

    ft = f->type->etype;
    tt = t->type->etype;
    if(debug['M'])
        print("gop: %O %O[%s],%O[%s]\n", OAS,
            f->op, tnames[ft], t->op, tnames[tt]);
    if(typefd[ft] && f->op == OCONST) {
        if(f->fconst == 0)
            gins(AFLDZ, Z, Z);
        else
        if(f->fconst == 1)
            gins(AFLD1, Z, Z);
        else
            gins(AFMOVD, f, &fregnode0);
        gmove(&fregnode0, t);
        return;
    }
/*
 * load
 */
    if(f->op == ONAME || f->op == OINDREG ||
       f->op == OIND || f->op == OINDEX)
    switch(ft) {
    case TCHAR:
        a = AMOVBLSX;
        goto ld;
    case TUCHAR:
        a = AMOVBLZX;
        goto ld;
    case TSHORT:
        if(typefd[tt]) {
            gins(AFMOVW, f, &fregnode0);
            gmove(&fregnode0, t);
            return;
        }
        a = AMOVWLSX;
        goto ld;
    case TUSHORT:
        a = AMOVWLZX;
        goto ld;
    case TINT:
    case TUINT:
    case TLONG:
    case TULONG:
    case TIND:
        if(typefd[tt]) {
            gins(AFMOVL, f, &fregnode0);
            gmove(&fregnode0, t);
            return;
        }
        a = AMOVL;

    ld:
        regalloc(&nod, f, t);
        nod.type = types[TLONG];
        gins(a, f, &nod);
        gmove(&nod, t);
        regfree(&nod);
        return;

    case TFLOAT:
        gins(AFMOVF, f, t);
        return;
    case TDOUBLE:
        gins(AFMOVD, f, t);
        return;
    }

/*
 * store
 */
    if(t->op == ONAME || t->op == OINDREG ||
       t->op == OIND || t->op == OINDEX)
    switch(tt) {
    case TCHAR:
    case TUCHAR:
        a = AMOVB;	goto st;
    case TSHORT:
    case TUSHORT:
        a = AMOVW;	goto st;
    case TINT:
    case TUINT:
    case TLONG:
    case TULONG:
    case TIND:
        a = AMOVL;	goto st;

    st:
        if(f->op == OCONST) {
            gins(a, f, t);
            return;
        }
        regalloc(&nod, t, f);
        gmove(f, &nod);
        gins(a, &nod, t);
        regfree(&nod);
        return;

    case TFLOAT:
        gins(AFMOVFP, f, t);
        return;
    case TDOUBLE:
        gins(AFMOVDP, f, t);
        return;
    }

/*
 * convert
 */
    switch(CASE(ft,tt)) {
    default:
/*
 * integer to integer
 ********
        a = AGOK;	break;

    case CASE(	TCHAR,	TCHAR):
    case CASE(	TUCHAR,	TCHAR):
    case CASE(	TSHORT,	TCHAR):
    case CASE(	TUSHORT,TCHAR):
    case CASE(	TINT,	TCHAR):
    case CASE(	TUINT,	TCHAR):
    case CASE(	TLONG,	TCHAR):
    case CASE(	TULONG,	TCHAR):
    case CASE(	TIND,	TCHAR):

    case CASE(	TCHAR,	TUCHAR):
    case CASE(	TUCHAR,	TUCHAR):
    case CASE(	TSHORT,	TUCHAR):
    case CASE(	TUSHORT,TUCHAR):
    case CASE(	TINT,	TUCHAR):
    case CASE(	TUINT,	TUCHAR):
    case CASE(	TLONG,	TUCHAR):
    case CASE(	TULONG,	TUCHAR):
    case CASE(	TIND,	TUCHAR):

    case CASE(	TSHORT,	TSHORT):
    case CASE(	TUSHORT,TSHORT):
    case CASE(	TINT,	TSHORT):
    case CASE(	TUINT,	TSHORT):
    case CASE(	TLONG,	TSHORT):
    case CASE(	TULONG,	TSHORT):
    case CASE(	TIND,	TSHORT):

    case CASE(	TSHORT,	TUSHORT):
    case CASE(	TUSHORT,TUSHORT):
    case CASE(	TINT,	TUSHORT):
    case CASE(	TUINT,	TUSHORT):
    case CASE(	TLONG,	TUSHORT):
    case CASE(	TULONG,	TUSHORT):
    case CASE(	TIND,	TUSHORT):

    case CASE(	TINT,	TINT):
    case CASE(	TUINT,	TINT):
    case CASE(	TLONG,	TINT):
    case CASE(	TULONG,	TINT):
    case CASE(	TIND,	TINT):

    case CASE(	TINT,	TUINT):
    case CASE(	TUINT,	TUINT):
    case CASE(	TLONG,	TUINT):
    case CASE(	TULONG,	TUINT):
    case CASE(	TIND,	TUINT):

    case CASE(	TINT,	TLONG):
    case CASE(	TUINT,	TLONG):
    case CASE(	TLONG,	TLONG):
    case CASE(	TULONG,	TLONG):
    case CASE(	TIND,	TLONG):

    case CASE(	TINT,	TULONG):
    case CASE(	TUINT,	TULONG):
    case CASE(	TLONG,	TULONG):
    case CASE(	TULONG,	TULONG):
    case CASE(	TIND,	TULONG):

    case CASE(	TINT,	TIND):
    case CASE(	TUINT,	TIND):
    case CASE(	TLONG,	TIND):
    case CASE(	TULONG,	TIND):
    case CASE(	TIND,	TIND):
 *****/
        a = AMOVL;
        break;

    case CASE(	TSHORT,	TINT):
    case CASE(	TSHORT,	TUINT):
    case CASE(	TSHORT,	TLONG):
    case CASE(	TSHORT,	TULONG):
    case CASE(	TSHORT,	TIND):
        a = AMOVWLSX;
        if(f->op == OCONST) {
            f->vconst &= 0xffff;
            if(f->vconst & 0x8000)
                f->vconst |= 0xffff0000;
            a = AMOVL;
        }
        break;

    case CASE(	TUSHORT,TINT):
    case CASE(	TUSHORT,TUINT):
    case CASE(	TUSHORT,TLONG):
    case CASE(	TUSHORT,TULONG):
    case CASE(	TUSHORT,TIND):
        a = AMOVWLZX;
        if(f->op == OCONST) {
            f->vconst &= 0xffff;
            a = AMOVL;
        }
        break;

    case CASE(	TCHAR,	TSHORT):
    case CASE(	TCHAR,	TUSHORT):
    case CASE(	TCHAR,	TINT):
    case CASE(	TCHAR,	TUINT):
    case CASE(	TCHAR,	TLONG):
    case CASE(	TCHAR,	TULONG):
    case CASE(	TCHAR,	TIND):
        a = AMOVBLSX;
        if(f->op == OCONST) {
            f->vconst &= 0xff;
            if(f->vconst & 0x80)
                f->vconst |= 0xffffff00;
            a = AMOVL;
        }
        break;

    case CASE(	TUCHAR,	TSHORT):
    case CASE(	TUCHAR,	TUSHORT):
    case CASE(	TUCHAR,	TINT):
    case CASE(	TUCHAR,	TUINT):
    case CASE(	TUCHAR,	TLONG):
    case CASE(	TUCHAR,	TULONG):
    case CASE(	TUCHAR,	TIND):
        a = AMOVBLZX;
        if(f->op == OCONST) {
            f->vconst &= 0xff;
            a = AMOVL;
        }
        break;

/*
 * float to fix
 */
    case CASE(	TFLOAT,	TCHAR):
    case CASE(	TFLOAT,	TUCHAR):
    case CASE(	TFLOAT,	TSHORT):
    case CASE(	TFLOAT,	TUSHORT):
    case CASE(	TFLOAT,	TINT):
    case CASE(	TFLOAT,	TLONG):
    case CASE(	TFLOAT,	TIND):

    case CASE(	TDOUBLE,TCHAR):
    case CASE(	TDOUBLE,TUCHAR):
    case CASE(	TDOUBLE,TSHORT):
    case CASE(	TDOUBLE,TUSHORT):
    case CASE(	TDOUBLE,TINT):
    case CASE(	TDOUBLE,TLONG):
    case CASE(	TDOUBLE,TIND):
        if(fproundflg) {
            regsalloc(&nod, &regnode);
            gins(AFMOVLP, f, &nod);
            gmove(&nod, t);
            return;
        }
        regsalloc(&nod, &regnode);
        regsalloc(&nod1, &regnode);
        gins(AFSTCW, Z, &nod1);
        nod1.xoffset += 2;
        gins(AMOVW, nodconst(0xf7f), &nod1);
        gins(AFLDCW, &nod1, Z);
        gins(AFMOVLP, f, &nod);
        nod1.xoffset -= 2;
        gins(AFLDCW, &nod1, Z);
        gmove(&nod, t);
        return;

/*
 * float to ulong
 */
    case CASE(	TDOUBLE,	TULONG):
    case CASE(	TFLOAT,	TULONG):
    case CASE(	TDOUBLE,	TUINT):
    case CASE(	TFLOAT,	TUINT):
        regsalloc(&nod, &regnode);
        gmove(f, &fregnode0);
        gins(AFADDD, nodfconst(-2147483648.), &fregnode0);
        gins(AFMOVLP, f, &nod);
        gins(ASUBL, nodconst(-2147483648), &nod);
        gmove(&nod, t);
        return;

/*
 * ulong to float
 */
    case CASE(	TULONG,	TDOUBLE):
    case CASE(	TULONG,	TFLOAT):
    case CASE(	TUINT,	TDOUBLE):
    case CASE(	TUINT,	TFLOAT):
        regalloc(&nod, f, f);
        gmove(f, &nod);
        regsalloc(&nod1, &regnode);
        gmove(&nod, &nod1);
        gins(AFMOVL, &nod1, &fregnode0);
        gins(ACMPL, &nod, nodconst(0));
        gins(AJGE, Z, Z);
        p1 = p;
        gins(AFADDD, nodfconst(4294967296.), &fregnode0);
        patch(p1, pc);
        regfree(&nod);
        return;

/*
 * fix to float
 */
    case CASE(	TCHAR,	TFLOAT):
    case CASE(	TUCHAR,	TFLOAT):
    case CASE(	TSHORT,	TFLOAT):
    case CASE(	TUSHORT,TFLOAT):
    case CASE(	TINT,	TFLOAT):
    case CASE(	TLONG,	TFLOAT):
    case CASE(	TIND,	TFLOAT):

    case CASE(	TCHAR,	TDOUBLE):
    case CASE(	TUCHAR,	TDOUBLE):
    case CASE(	TSHORT,	TDOUBLE):
    case CASE(	TUSHORT,TDOUBLE):
    case CASE(	TINT,	TDOUBLE):
    case CASE(	TLONG,	TDOUBLE):
    case CASE(	TIND,	TDOUBLE):
        regsalloc(&nod, &regnode);
        gmove(f, &nod);
        gins(AFMOVL, &nod, &fregnode0);
        return;

/*
 * float to float
 */
    case CASE(	TFLOAT,	TFLOAT):
    case CASE(	TDOUBLE,TFLOAT):

    case CASE(	TFLOAT,	TDOUBLE):
    case CASE(	TDOUBLE,TDOUBLE):
        a = AFMOVD;	break;
    }
    if(a == AMOVL || a == AFMOVD)
    if(samaddr(f, t))
        return;
    gins(a, f, t);
}
@

<<function doindex>>=
void
doindex(Node *n)
{
    Node nod, nod1;
    long v;

if(debug['Y'])
prtree(n, "index");

if(n->left->complex >= FNX)
print("botch in doindex\n");

    regalloc(&nod, &regnode, Z);
    v = constnode.vconst;
    cgen(n->right, &nod);
    idx.ptr = D_NONE;
    if(n->left->op == OCONST)
        idx.ptr = D_CONST;
    else if(n->left->op == OREGISTER)
//	else if(n->left->op == OREGISTER && typeil[n->left->type->etype])
        idx.ptr = n->left->reg;
    else if(n->left->op != OADDR) {
        reg[D_BP]++;	// cant be used as a base
        regalloc(&nod1, &regnode, Z);
        cgen(n->left, &nod1);
        idx.ptr = nod1.reg;
        regfree(&nod1);
        reg[D_BP]--;
    }
    idx.reg = nod.reg;
    regfree(&nod);
    constnode.vconst = v;
}
@

<<function gins>>=
void
gins(int a, Node *f, Node *t)
{

    if(f != Z && f->op == OINDEX)
        doindex(f);
    if(t != Z && t->op == OINDEX)
        doindex(t);
    nextpc();
    p->as = a;
    if(f != Z)
        naddr(f, &p->from);
    if(t != Z)
        naddr(t, &p->to);
    if(debug['g'])
        print("%P\n", p);
}
@

<<function fgopcode>>=
void
fgopcode(int o, Node *f, Node *t, int pop, int rev)
{
    int a, et;
    Node nod;

    et = TLONG;
    if(f != Z && f->type != T)
        et = f->type->etype;
    if(!typefd[et]) {
        diag(f, "fop: integer %O", o);
        return;
    }
    if(debug['M']) {
        if(t != Z && t->type != T)
            print("gop: %O %O-%s Z\n", o, f->op, tnames[et]);
        else
            print("gop: %O %O-%s %O-%s\n", o,
                f->op, tnames[et], t->op, tnames[t->type->etype]);
    }
    a = AGOK;
    switch(o) {

    case OASADD:
    case OADD:
        if(et == TFLOAT)
            a = AFADDF;
        else
        if(et == TDOUBLE) {
            a = AFADDD;
            if(pop)
                a = AFADDDP;
        }
        break;

    case OASSUB:
    case OSUB:
        if(et == TFLOAT) {
            a = AFSUBF;
            if(rev)
                a = AFSUBRF;
        } else
        if(et == TDOUBLE) {
            a = AFSUBD;
            if(pop)
                a = AFSUBDP;
            if(rev) {
                a = AFSUBRD;
                if(pop)
                    a = AFSUBRDP;
            }
        }
        break;

    case OASMUL:
    case OMUL:
        if(et == TFLOAT)
            a = AFMULF;
        else
        if(et == TDOUBLE) {
            a = AFMULD;
            if(pop)
                a = AFMULDP;
        }
        break;

    case OASMOD:
    case OMOD:
    case OASDIV:
    case ODIV:
        if(et == TFLOAT) {
            a = AFDIVF;
            if(rev)
                a = AFDIVRF;
        } else
        if(et == TDOUBLE) {
            a = AFDIVD;
            if(pop)
                a = AFDIVDP;
            if(rev) {
                a = AFDIVRD;
                if(pop)
                    a = AFDIVRDP;
            }
        }
        break;

    case OEQ:
    case ONE:
    case OLT:
    case OLE:
    case OGE:
    case OGT:
        pop += rev;
        if(et == TFLOAT) {
            a = AFCOMF;
            if(pop) {
                a = AFCOMFP;
                if(pop > 1)
                    a = AGOK;
            }
        } else
        if(et == TDOUBLE) {
            a = AFCOMF;
            if(pop) {
                a = AFCOMDP;
                if(pop > 1)
                    a = AFCOMDPP;
            }
        }
        gins(a, f, t);
        regalloc(&nod, &regnode, Z);
        if(nod.reg != D_AX) {
            regfree(&nod);
            nod.reg = D_AX;
            gins(APUSHL, &nod, Z);
            gins(AWAIT, Z, Z);
            gins(AFSTSW, Z, &nod);
            gins(ASAHF, Z, Z);
            gins(APOPL, Z, &nod);
        } else {
            gins(AWAIT, Z, Z);
            gins(AFSTSW, Z, &nod);
            gins(ASAHF, Z, Z);
            regfree(&nod);
        }
        switch(o) {
        case OEQ:	a = AJEQ; break;
        case ONE:	a = AJNE; break;
        case OLT:	a = AJCS; break;
        case OLE:	a = AJLS; break;
        case OGE:	a = AJCC; break;
        case OGT:	a = AJHI; break;
        }
        gins(a, Z, Z);
        return;
    }
    if(a == AGOK)
        diag(Z, "bad in gopcode %O", o);
    gins(a, f, t);
}
@

<<function gopcode>>=
void
gopcode(int o, Type *ty, Node *f, Node *t)
{
    int a, et;

    et = TLONG;
    if(ty != T)
        et = ty->etype;
    if(typefd[et] && o != OADDR && o != OFUNC) {
        diag(f, "gop: float %O", o);
        return;
    }
    if(debug['M']) {
        if(f != Z && f->type != T)
            print("gop: %O %O[%s],", o, f->op, tnames[et]);
        else
            print("gop: %O Z,", o);
        if(t != Z && t->type != T)
            print("%O[%s]\n", t->op, tnames[t->type->etype]);
        else
            print("Z\n");
    }
    a = AGOK;
    switch(o) {
    case OCOM:
        a = ANOTL;
        if(et == TCHAR || et == TUCHAR)
            a = ANOTB;
        if(et == TSHORT || et == TUSHORT)
            a = ANOTW;
        break;

    case ONEG:
        a = ANEGL;
        if(et == TCHAR || et == TUCHAR)
            a = ANEGB;
        if(et == TSHORT || et == TUSHORT)
            a = ANEGW;
        break;

    case OADDR:
        a = ALEAL;
        break;

    case OASADD:
    case OADD:
        a = AADDL;
        if(et == TCHAR || et == TUCHAR)
            a = AADDB;
        if(et == TSHORT || et == TUSHORT)
            a = AADDW;
        break;

    case OASSUB:
    case OSUB:
        a = ASUBL;
        if(et == TCHAR || et == TUCHAR)
            a = ASUBB;
        if(et == TSHORT || et == TUSHORT)
            a = ASUBW;
        break;

    case OASOR:
    case OOR:
        a = AORL;
        if(et == TCHAR || et == TUCHAR)
            a = AORB;
        if(et == TSHORT || et == TUSHORT)
            a = AORW;
        break;

    case OASAND:
    case OAND:
        a = AANDL;
        if(et == TCHAR || et == TUCHAR)
            a = AANDB;
        if(et == TSHORT || et == TUSHORT)
            a = AANDW;
        break;

    case OASXOR:
    case OXOR:
        a = AXORL;
        if(et == TCHAR || et == TUCHAR)
            a = AXORB;
        if(et == TSHORT || et == TUSHORT)
            a = AXORW;
        break;

    case OASLSHR:
    case OLSHR:
        a = ASHRL;
        if(et == TCHAR || et == TUCHAR)
            a = ASHRB;
        if(et == TSHORT || et == TUSHORT)
            a = ASHRW;
        break;

    case OASASHR:
    case OASHR:
        a = ASARL;
        if(et == TCHAR || et == TUCHAR)
            a = ASARB;
        if(et == TSHORT || et == TUSHORT)
            a = ASARW;
        break;

    case OASASHL:
    case OASHL:
        a = ASALL;
        if(et == TCHAR || et == TUCHAR)
            a = ASALB;
        if(et == TSHORT || et == TUSHORT)
            a = ASALW;
        break;

    case OFUNC:
        a = ACALL;
        break;

    case OASMUL:
    case OMUL:
        if(f->op == OREGISTER && t != Z && isreg(t, D_AX) && reg[D_DX] == 0)
            t = Z;
        a = AIMULL;
        break;

    case OASMOD:
    case OMOD:
    case OASDIV:
    case ODIV:
        a = AIDIVL;
        break;

    case OASLMUL:
    case OLMUL:
        a = AMULL;
        break;

    case OASLMOD:
    case OLMOD:
    case OASLDIV:
    case OLDIV:
        a = ADIVL;
        break;

    case OEQ:
    case ONE:
    case OLT:
    case OLE:
    case OGE:
    case OGT:
    case OLO:
    case OLS:
    case OHS:
    case OHI:
        a = ACMPL;
        if(et == TCHAR || et == TUCHAR)
            a = ACMPB;
        if(et == TSHORT || et == TUSHORT)
            a = ACMPW;
        gins(a, f, t);
        switch(o) {
        case OEQ:	a = AJEQ; break;
        case ONE:	a = AJNE; break;
        case OLT:	a = AJLT; break;
        case OLE:	a = AJLE; break;
        case OGE:	a = AJGE; break;
        case OGT:	a = AJGT; break;
        case OLO:	a = AJCS; break;
        case OLS:	a = AJLS; break;
        case OHS:	a = AJCC; break;
        case OHI:	a = AJHI; break;
        }
        gins(a, Z, Z);
        return;
    }
    if(a == AGOK)
        diag(Z, "bad in gopcode %O", o);
    gins(a, f, t);
}
@

<<function samaddr>>=
int
samaddr(Node *f, Node *t)
{

    if(f->op != t->op)
        return 0;
    switch(f->op) {

    case OREGISTER:
        if(f->reg != t->reg)
            break;
        return 1;
    }
    return 0;
}
@

<<function gbranch>>=
void
gbranch(int o)
{
    int a;

    a = AGOK;
    switch(o) {
    case ORETURN:
        a = ARET;
        break;
    case OGOTO:
        a = AJMP;
        break;
    }
    nextpc();
    if(a == AGOK) {
        diag(Z, "bad in gbranch %O",  o);
        nextpc();
    }
    p->as = a;
}
@

<<function patch>>=
void
patch(Prog *op, long pc)
{

    op->to.offset = pc;
    op->to.type = D_BRANCH;
}
@

<<function gpseudo>>=
void
gpseudo(int a, Sym *s, Node *n)
{

    nextpc();
    p->as = a;
    p->from.type = D_EXTERN;
    p->from.sym = s;
    p->from.scale = (profileflg ? 0 : NOPROF);
    if(s->class == CSTATIC)
        p->from.type = D_STATIC;
    naddr(n, &p->to);
    if(a == ADATA || a == AGLOBL)
        pc--;
}
@

<<function sconst>>=
int
sconst(Node *n)
{
    long v;

    if(n->op == OCONST && !typefd[n->type->etype]) {
        v = n->vconst;
        if(v >= -32766L && v < 32766L)
            return 1;
    }
    return 0;
}
@

<<function exreg>>=
long
exreg(Type *t)
{

    int o;

    if(typechlp[t->etype]){
        if(exregoffset >= 32)
            return 0;
        o = exregoffset;
        exregoffset += 4;
        return o+1;	/* +1 to avoid 0 == failure; naddr case OEXREG will -1. */
    }
    return 0;
}
@

<<global ewidth>>=
schar	ewidth[NTYPE] =
{
    -1,		/*[TXXX]*/	
    SZ_CHAR,	/*[TCHAR]*/	
    SZ_CHAR,	/*[TUCHAR]*/
    SZ_SHORT,	/*[TSHORT]*/
    SZ_SHORT,	/*[TUSHORT]*/
    SZ_INT,		/*[TINT]*/
    SZ_INT,		/*[TUINT]*/
    SZ_LONG,	/*[TLONG]*/
    SZ_LONG,	/*[TULONG]*/
    SZ_VLONG,	/*[TVLONG]*/
    SZ_VLONG,	/*[TUVLONG]*/
    SZ_FLOAT,	/*[TFLOAT]*/
    SZ_DOUBLE,	/*[TDOUBLE]*/
    SZ_IND,		/*[TIND]*/
    0,		/*[TFUNC]*/
    -1,		/*[TARRAY]*/
    0,		/*[TVOID]*/
    -1,		/*[TSTRUCT]*/
    -1,		/*[TUNION]*/
    SZ_INT,		/*[TENUM]*/
};
@

<<global ncast>>=
long	ncast[NTYPE] =
{
    0,				/*[TXXX]*/
    BCHAR|BUCHAR,			/*[TCHAR]*/
    BCHAR|BUCHAR,			/*[TUCHAR]*/	
    BSHORT|BUSHORT,			/*[TSHORT]*/
    BSHORT|BUSHORT,			/*[TUSHORT]*/
    BINT|BUINT|BLONG|BULONG|BIND,	/*[TINT]*/		
    BINT|BUINT|BLONG|BULONG|BIND,	/*[TUINT]*/
    BINT|BUINT|BLONG|BULONG|BIND,	/*[TLONG]*/
    BINT|BUINT|BLONG|BULONG|BIND,	/*[TULONG]*/
    BVLONG|BUVLONG,			/*[TVLONG]*/
    BVLONG|BUVLONG,			/*[TUVLONG]*/
    BFLOAT,				/*[TFLOAT]*/
    BDOUBLE,			/*[TDOUBLE]*/
    BLONG|BULONG|BIND,		/*[TIND]*/
    0,				/*[TFUNC]*/
    0,				/*[TARRAY]*/
    0,				/*[TVOID]*/
    BSTRUCT,			/*[TSTRUCT]*/
    BUNION,				/*[TUNION]*/
    0,				/*[TENUM]*/
};
@


%-------------------------------------------------------------

<<8c/txt.c>>=
#include "gc.h"

<<function ginit>>

<<function gclean>>

<<function nextpc>>

<<function gargs>>

<<function nareg>>

<<function garg1>>

<<function nodconst>>

<<function nodfconst>>

<<function isreg>>

<<function nodreg>>

<<function regret>>

<<function regalloc>>

<<function regialloc>>

<<function regfree>>

<<function regsalloc>>

<<function regaalloc1>>

<<function regaalloc>>

<<function regind>>

<<function naddr>>

<<function CASE>>

<<function gmove>>

<<function doindex>>

<<function gins>>

<<function fgopcode>>

<<function gopcode>>

<<function samaddr>>

<<function gbranch>>

<<function patch>>

<<function gpseudo>>

<<function sconst>>

<<function exreg>>

<<global ewidth>>
<<global ncast>>
@


\subsection*{[[8c/peep.c]]}

<<function needc>>=
static int
needc(Prog *p)
{
    while(p != P) {
        switch(p->as) {
        case AADCL:
        case ASBBL:
        case ARCRL:
            return 1;
        case AADDL:
        case ASUBL:
        case AJMP:
        case ARET:
        case ACALL:
            return 0;
        default:
            if(p->to.type == D_BRANCH)
                return 0;
        }
        p = p->link;
    }
    return 0;
}
@

<<function peep>>=
void
peep(void)
{
    Reg *r, *r1, *r2;
    Prog *p, *p1;
    int t;

    /*
     * complete R structure
     */
    t = 0;
    for(r=firstr; r!=R; r=r1) {
        r1 = r->link;
        if(r1 == R)
            break;
        p = r->prog->link;
        while(p != r1->prog)
        switch(p->as) {
        default:
            r2 = rega();
            r->link = r2;
            r2->link = r1;

            r2->prog = p;
            r2->p1 = r;
            r->s1 = r2;
            r2->s1 = r1;
            r1->p1 = r2;

            r = r2;
            t++;

        case ADATA:
        case AGLOBL:
        case ANAME:
        case ASIGNAME:
            p = p->link;
        }
    }

    pc = 0;	/* speculating it won't kill */

loop1:

    t = 0;
    for(r=firstr; r!=R; r=r->link) {
        p = r->prog;
        switch(p->as) {
        case AMOVL:
            if(regtyp(&p->to))
            if(regtyp(&p->from)) {
                if(copyprop(r)) {
                    excise(r);
                    t++;
                }
                if(subprop(r) && copyprop(r)) {
                    excise(r);
                    t++;
                }
            }
            break;

        case AMOVBLSX:
        case AMOVBLZX:
        case AMOVWLSX:
        case AMOVWLZX:
            if(regtyp(&p->to)) {
                r1 = uniqs(r);
                if(r1 != R) {
                    p1 = r1->prog;
                    if(p->as == p1->as && p->to.type == p1->from.type)
                        p1->as = AMOVL;
                }
            }
            break;
        case AADDL:
        case AADDW:
            if(p->from.type != D_CONST || needc(p->link))
                break;
            if(p->from.offset == -1){
                if(p->as == AADDL)
                    p->as = ADECL;
                else
                    p->as = ADECW;
                p->from = zprog.from;
            }
            else if(p->from.offset == 1){
                if(p->as == AADDL)
                    p->as = AINCL;
                else
                    p->as = AINCW;
                p->from = zprog.from;
            }
            break;
        case ASUBL:
        case ASUBW:
            if(p->from.type != D_CONST || needc(p->link))
                break;
            if(p->from.offset == -1) {
                if(p->as == ASUBL)
                    p->as = AINCL;
                else
                    p->as = AINCW;
                p->from = zprog.from;
            }
            else if(p->from.offset == 1){
                if(p->as == ASUBL)
                    p->as = ADECL;
                else
                    p->as = ADECW;
                p->from = zprog.from;
            }
            break;
        }
    }
    if(t)
        goto loop1;
}
@

<<function excise>>=
void
excise(Reg *r)
{
    Prog *p;

    p = r->prog;
    p->as = ANOP;
    p->from = zprog.from;
    p->to = zprog.to;
}
@

<<function uniqp>>=
Reg*
uniqp(Reg *r)
{
    Reg *r1;

    r1 = r->p1;
    if(r1 == R) {
        r1 = r->p2;
        if(r1 == R || r1->p2link != R)
            return R;
    } else
        if(r->p2 != R)
            return R;
    return r1;
}
@

<<function uniqs>>=
Reg*
uniqs(Reg *r)
{
    Reg *r1;

    r1 = r->s1;
    if(r1 == R) {
        r1 = r->s2;
        if(r1 == R)
            return R;
    } else
        if(r->s2 != R)
            return R;
    return r1;
}
@

<<function regtyp>>=
int
regtyp(Adr *a)
{
    int t;

    t = a->type;
    if(t >= D_AX && t <= D_DI)
        return 1;
    return 0;
}
@

<<function subprop>>=
/*
 * the idea is to substitute
 * one register for another
 * from one MOV to another
 *	MOV	a, R0
 *	ADD	b, R0	/ no use of R1
 *	MOV	R0, R1
 * would be converted to
 *	MOV	a, R1
 *	ADD	b, R1
 *	MOV	R1, R0
 * hopefully, then the former or latter MOV
 * will be eliminated by copy propagation.
 */
int
subprop(Reg *r0)
{
    Prog *p;
    Adr *v1, *v2;
    Reg *r;
    int t;

    p = r0->prog;
    v1 = &p->from;
    if(!regtyp(v1))
        return 0;
    v2 = &p->to;
    if(!regtyp(v2))
        return 0;
    for(r=uniqp(r0); r!=R; r=uniqp(r)) {
        if(uniqs(r) == R)
            break;
        p = r->prog;
        switch(p->as) {
        case ACALL:
            return 0;

        case AIMULL:
        case AIMULW:
            if(p->to.type != D_NONE)
                break;

        case ADIVB:
        case ADIVL:
        case ADIVW:
        case AIDIVB:
        case AIDIVL:
        case AIDIVW:
        case AIMULB:
        case AMULB:
        case AMULL:
        case AMULW:

        case AROLB:
        case AROLL:
        case AROLW:
        case ARORB:
        case ARORL:
        case ARORW:
        case ASALB:
        case ASALL:
        case ASALW:
        case ASARB:
        case ASARL:
        case ASARW:
        case ASHLB:
        case ASHLL:
        case ASHLW:
        case ASHRB:
        case ASHRL:
        case ASHRW:

        case AREP:
        case AREPN:

        case ACWD:
        case ACDQ:

        case ASTOSB:
        case ASTOSL:
        case AMOVSB:
        case AMOVSL:
        case AFSTSW:
            return 0;

        case AMOVL:
            if(p->to.type == v1->type)
                goto gotit;
            break;
        }
        if(copyau(&p->from, v2) ||
           copyau(&p->to, v2))
            break;
        if(copysub(&p->from, v1, v2, 0) ||
           copysub(&p->to, v1, v2, 0))
            break;
    }
    return 0;

gotit:
    copysub(&p->to, v1, v2, 1);
    if(debug['P']) {
        print("gotit: %D->%D\n%P", v1, v2, r->prog);
        if(p->from.type == v2->type)
            print(" excise");
        print("\n");
    }
    for(r=uniqs(r); r!=r0; r=uniqs(r)) {
        p = r->prog;
        copysub(&p->from, v1, v2, 1);
        copysub(&p->to, v1, v2, 1);
        if(debug['P'])
            print("%P\n", r->prog);
    }
    t = v1->type;
    v1->type = v2->type;
    v2->type = t;
    if(debug['P'])
        print("%P last\n", r->prog);
    return 1;
}
@

<<function copyprop>>=
/*
 * The idea is to remove redundant copies.
 *	v1->v2	F=0
 *	(use v2	s/v2/v1/)*
 *	set v1	F=1
 *	use v2	return fail
 *	-----------------
 *	v1->v2	F=0
 *	(use v2	s/v2/v1/)*
 *	set v1	F=1
 *	set v2	return success
 */
int
copyprop(Reg *r0)
{
    Prog *p;
    Adr *v1, *v2;
    Reg *r;

    p = r0->prog;
    v1 = &p->from;
    v2 = &p->to;
    if(copyas(v1, v2))
        return 1;
    for(r=firstr; r!=R; r=r->link)
        r->active = 0;
    return copy1(v1, v2, r0->s1, 0);
}
@

<<function copy1>>=
int
copy1(Adr *v1, Adr *v2, Reg *r, int f)
{
    int t;
    Prog *p;

    if(r->active) {
        if(debug['P'])
            print("act set; return 1\n");
        return 1;
    }
    r->active = 1;
    if(debug['P'])
        print("copy %D->%D f=%d\n", v1, v2, f);
    for(; r != R; r = r->s1) {
        p = r->prog;
        if(debug['P'])
            print("%P", p);
        if(!f && uniqp(r) == R) {
            f = 1;
            if(debug['P'])
                print("; merge; f=%d", f);
        }
        t = copyu(p, v2, A);
        switch(t) {
        case 2:	/* rar, cant split */
            if(debug['P'])
                print("; %D rar; return 0\n", v2);
            return 0;

        case 3:	/* set */
            if(debug['P'])
                print("; %D set; return 1\n", v2);
            return 1;

        case 1:	/* used, substitute */
        case 4:	/* use and set */
            if(f) {
                if(!debug['P'])
                    return 0;
                if(t == 4)
                    print("; %D used+set and f=%d; return 0\n", v2, f);
                else
                    print("; %D used and f=%d; return 0\n", v2, f);
                return 0;
            }
            if(copyu(p, v2, v1)) {
                if(debug['P'])
                    print("; sub fail; return 0\n");
                return 0;
            }
            if(debug['P'])
                print("; sub %D/%D", v2, v1);
            if(t == 4) {
                if(debug['P'])
                    print("; %D used+set; return 1\n", v2);
                return 1;
            }
            break;
        }
        if(!f) {
            t = copyu(p, v1, A);
            if(!f && (t == 2 || t == 3 || t == 4)) {
                f = 1;
                if(debug['P'])
                    print("; %D set and !f; f=%d", v1, f);
            }
        }
        if(debug['P'])
            print("\n");
        if(r->s2)
            if(!copy1(v1, v2, r->s2, f))
                return 0;
    }
    return 1;
}
@

<<function copyu>>=
/*
 * return
 * 1 if v only used (and substitute),
 * 2 if read-alter-rewrite
 * 3 if set
 * 4 if set and used
 * 0 otherwise (not touched)
 */
int
copyu(Prog *p, Adr *v, Adr *s)
{

    switch(p->as) {

    default:
        if(debug['P'])
            print("unknown op %A\n", p->as);
        return 2;

    case ANEGB:
    case ANEGW:
    case ANEGL:
    case ANOTB:
    case ANOTW:
    case ANOTL:
        if(copyas(&p->to, v))
            return 2;
        break;

    case ALEAL:	/* lhs addr, rhs store */
        if(copyas(&p->from, v))
            return 2;


    case ANOP:	/* rhs store */
    case AMOVL:
    case AMOVBLSX:
    case AMOVBLZX:
    case AMOVWLSX:
    case AMOVWLZX:
        if(copyas(&p->to, v)) {
            if(s != A)
                return copysub(&p->from, v, s, 1);
            if(copyau(&p->from, v))
                return 4;
            return 3;
        }
        goto caseread;

    case AROLB:
    case AROLL:
    case AROLW:
    case ARORB:
    case ARORL:
    case ARORW:
    case ASALB:
    case ASALL:
    case ASALW:
    case ASARB:
    case ASARL:
    case ASARW:
    case ASHLB:
    case ASHLL:
    case ASHLW:
    case ASHRB:
    case ASHRL:
    case ASHRW:
        if(copyas(&p->to, v))
            return 2;
        if(copyas(&p->from, v))
            if(p->from.type == D_CX)
                return 2;
        goto caseread;

    case AADDB:	/* rhs rar */
    case AADDL:
    case AADDW:
    case AANDB:
    case AANDL:
    case AANDW:
    case ADECL:
    case ADECW:
    case AINCL:
    case AINCW:
    case ASUBB:
    case ASUBL:
    case ASUBW:
    case AORB:
    case AORL:
    case AORW:
    case AXORB:
    case AXORL:
    case AXORW:
    case AMOVB:
    case AMOVW:

    case AFMOVB:
    case AFMOVBP:
    case AFMOVD:
    case AFMOVDP:
    case AFMOVF:
    case AFMOVFP:
    case AFMOVL:
    case AFMOVLP:
    case AFMOVV:
    case AFMOVVP:
    case AFMOVW:
    case AFMOVWP:
    case AFMOVX:
    case AFMOVXP:
    case AFADDDP:
    case AFADDW:
    case AFADDL:
    case AFADDF:
    case AFADDD:
    case AFMULDP:
    case AFMULW:
    case AFMULL:
    case AFMULF:
    case AFMULD:
    case AFSUBDP:
    case AFSUBW:
    case AFSUBL:
    case AFSUBF:
    case AFSUBD:
    case AFSUBRDP:
    case AFSUBRW:
    case AFSUBRL:
    case AFSUBRF:
    case AFSUBRD:
    case AFDIVDP:
    case AFDIVW:
    case AFDIVL:
    case AFDIVF:
    case AFDIVD:
    case AFDIVRDP:
    case AFDIVRW:
    case AFDIVRL:
    case AFDIVRF:
    case AFDIVRD:
        if(copyas(&p->to, v))
            return 2;
        goto caseread;

    case ACMPL:	/* read only */
    case ACMPW:
    case ACMPB:

    case AFCOMB:
    case AFCOMBP:
    case AFCOMD:
    case AFCOMDP:
    case AFCOMDPP:
    case AFCOMF:
    case AFCOMFP:
    case AFCOML:
    case AFCOMLP:
    case AFCOMW:
    case AFCOMWP:
    case AFUCOM:
    case AFUCOMP:
    case AFUCOMPP:
    caseread:
        if(s != A) {
            if(copysub(&p->from, v, s, 1))
                return 1;
            return copysub(&p->to, v, s, 1);
        }
        if(copyau(&p->from, v))
            return 1;
        if(copyau(&p->to, v))
            return 1;
        break;

    case AJGE:	/* no reference */
    case AJNE:
    case AJLE:
    case AJEQ:
    case AJHI:
    case AJLS:
    case AJMI:
    case AJPL:
    case AJGT:
    case AJLT:
    case AJCC:
    case AJCS:

    case AADJSP:
    case AFLDZ:
    case AWAIT:
        break;

    case AIMULL:
    case AIMULW:
        if(p->to.type != D_NONE) {
            if(copyas(&p->to, v))
                return 2;
            goto caseread;
        }

    case ADIVB:
    case ADIVL:
    case ADIVW:
    case AIDIVB:
    case AIDIVL:
    case AIDIVW:
    case AIMULB:
    case AMULB:
    case AMULL:
    case AMULW:

    case ACWD:
    case ACDQ:
        if(v->type == D_AX || v->type == D_DX)
            return 2;
        goto caseread;

    case AREP:
    case AREPN:
        if(v->type == D_CX)
            return 2;
        goto caseread;

    case AMOVSB:
    case AMOVSL:
        if(v->type == D_DI || v->type == D_SI)
            return 2;
        goto caseread;

    case ASTOSB:
    case ASTOSL:
        if(v->type == D_AX || v->type == D_DI)
            return 2;
        goto caseread;

    case AFSTSW:
        if(v->type == D_AX)
            return 2;
        goto caseread;

    case AJMP:	/* funny */
        if(s != A) {
            if(copysub(&p->to, v, s, 1))
                return 1;
            return 0;
        }
        if(copyau(&p->to, v))
            return 1;
        return 0;

    case ARET:	/* funny */
        if(v->type == REGRET)
            return 2;
        if(s != A)
            return 1;
        return 3;

    case ACALL:	/* funny */
        if(REGARG>=0 && v->type == REGARG)
            return 2;

        if(s != A) {
            if(copysub(&p->to, v, s, 1))
                return 1;
            return 0;
        }
        if(copyau(&p->to, v))
            return 4;
        return 3;
    }
    return 0;
}
@

<<function copyas>>=
/*
 * direct reference,
 * could be set/use depending on
 * semantics
 */
int
copyas(Adr *a, Adr *v)
{
    if(a->type != v->type)
        return 0;
    if(regtyp(v))
        return 1;
    if(v->type == D_AUTO || v->type == D_PARAM)
        if(v->offset == a->offset)
            return 1;
    return 0;
}
@

<<function copyau>>=
/*
 * either direct or indirect
 */
int
copyau(Adr *a, Adr *v)
{

    if(copyas(a, v))
        return 1;
    if(regtyp(v)) {
        if(a->type-D_INDIR == v->type)
            return 1;
        if(a->index == v->type)
            return 1;
    }
    return 0;
}
@

<<function copysub>>=
/*
 * substitute s for v in a
 * return failure to substitute
 */
int
copysub(Adr *a, Adr *v, Adr *s, int f)
{
    int t;

    if(copyas(a, v)) {
        t = s->type;
        if(t >= D_AX && t <= D_DI) {
            if(f)
                a->type = t;
        }
        return 0;
    }
    if(regtyp(v)) {
        t = v->type;
        if(a->type == t+D_INDIR) {
            if(s->type == D_BP && a->index != D_NONE)
                return 1;	/* can't use BP-base with index */
            if(f)
                a->type = s->type+D_INDIR;
//			return 0;
        }
        if(a->index == t) {
            if(f)
                a->index = s->type;
            return 0;
        }
        return 0;
    }
    return 0;
}
@


%-------------------------------------------------------------

<<8c/peep.c>>=
#include "gc.h"

<<function needc>>

<<function peep>>

<<function excise>>

<<function uniqp>>

<<function uniqs>>

<<function regtyp>>

<<function subprop>>

<<function copyprop>>

<<function copy1>>

<<function copyu>>

<<function copyas>>

<<function copyau>>

<<function copysub>>
@


\subsection*{[[8c/sgen.c]]}

<<function noretval>>=
void
noretval(int n)
{

    if(n & 1) {
        gins(ANOP, Z, Z);
        p->to.type = REGRET;
    }
    if(n & 2) {
        gins(ANOP, Z, Z);
        p->to.type = FREGRET;
    }
    if((n&3) == 3)
    if(thisfn && thisfn->link && typefd[thisfn->link->etype])
        gins(AFLDZ, Z, Z);
}
@

<<function commute>>=
/* welcome to commute */
static void
commute(Node *n)
{
    Node *l, *r;

    l = n->left;
    r = n->right;
    if(r->complex > l->complex) {
        n->left = r;
        n->right = l;
    }
}
@

<<function indexshift>>=
void
indexshift(Node *n)
{
    int g;

    if(!typechlp[n->type->etype])
        return;
    simplifyshift(n);
    if(n->op == OASHL && n->right->op == OCONST){
        g = vconst(n->right);
        if(g >= 0 && g < 4)
            n->addable = 7;
    }
}
@

<<function xcom>>=
/*
 *	calculate addressability as follows
 *		NAME ==> 10/11		name+value(SB/SP)
 *		REGISTER ==> 12		register
 *		CONST ==> 20		$value
 *		*(20) ==> 21		value
 *		&(10) ==> 13		$name+value(SB)
 *		&(11) ==> 1		$name+value(SP)
 *		(13) + (20) ==> 13	fold constants
 *		(1) + (20) ==> 1	fold constants
 *		*(13) ==> 10		back to name
 *		*(1) ==> 11		back to name
 *
 *		(20) * (X) ==> 7	multiplier in indexing
 *		(X,7) + (13,1) ==> 8	adder in indexing (addresses)
 *		(8) ==> &9(OINDEX)	index, almost addressable
 *
 *	calculate complexity (number of registers)
 */
void
xcom(Node *n)
{
    Node *l, *r;
    int g;

    if(n == Z)
        return;
    l = n->left;
    r = n->right;
    n->complex = 0;
    n->addable = 0;
    switch(n->op) {
    case OCONST:
        n->addable = 20;
        break;

    case ONAME:
        n->addable = 10;
        if(n->class == CPARAM || n->class == CAUTO)
            n->addable = 11;
        break;

    case OEXREG:
        n->addable = 12;
        break;

    case OREGISTER:
        n->addable = 12;
        break;

    case OINDREG:
        n->addable = 12;
        break;

    case OADDR:
        xcom(l);
        if(l->addable == 10)
            n->addable = 13;
        else
        if(l->addable == 11)
            n->addable = 1;
        break;

    case OADD:
        xcom(l);
        xcom(r);
        if(n->type->etype != TIND)
            break;

        switch(r->addable) {
        case 20:
            switch(l->addable) {
            case 1:
            case 13:
            commadd:
                l->type = n->type;
                *n = *l;
                l = new(0, Z, Z);
                *l = *(n->left);
                l->xoffset += r->vconst;
                n->left = l;
                r = n->right;
                goto brk;
            }
            break;

        case 1:
        case 13:
        case 10:
        case 11:
            /* l is the base, r is the index */
            if(l->addable != 20)
                n->addable = 8;
            break;
        }
        switch(l->addable) {
        case 20:
            switch(r->addable) {
            case 13:
            case 1:
                r = n->left;
                l = n->right;
                n->left = l;
                n->right = r;
                goto commadd;
            }
            break;

        case 13:
        case 1:
        case 10:
        case 11:
            /* r is the base, l is the index */
            if(r->addable != 20)
                n->addable = 8;
            break;
        }
        if(n->addable == 8 && !side(n)) {
            indx(n);
            l = new1(OINDEX, idx.basetree, idx.regtree);
            l->scale = idx.scale;
            l->addable = 9;
            l->complex = l->right->complex;
            l->type = l->left->type;
            n->op = OADDR;
            n->left = l;
            n->right = Z;
            n->addable = 8;
            break;
        }
        break;

    case OINDEX:
        xcom(l);
        xcom(r);
        n->addable = 9;
        break;

    case OIND:
        xcom(l);
        if(l->op == OADDR) {
            l = l->left;
            l->type = n->type;
            *n = *l;
            return;
        }
        switch(l->addable) {
        case 20:
            n->addable = 21;
            break;
        case 1:
            n->addable = 11;
            break;
        case 13:
            n->addable = 10;
            break;
        }
        break;

    case OASHL:
        xcom(l);
        xcom(r);
        indexshift(n);
        break;

    case OMUL:
    case OLMUL:
        xcom(l);
        xcom(r);
        g = vlog(l);
        if(g >= 0) {
            n->left = r;
            n->right = l;
            l = r;
            r = n->right;
        }
        g = vlog(r);
        if(g >= 0) {
            n->op = OASHL;
            r->vconst = g;
            r->type = types[TINT];
            indexshift(n);
            break;
        }
commute(n);
        break;

    case OASLDIV:
        xcom(l);
        xcom(r);
        g = vlog(r);
        if(g >= 0) {
            n->op = OASLSHR;
            r->vconst = g;
            r->type = types[TINT];
        }
        break;

    case OLDIV:
        xcom(l);
        xcom(r);
        g = vlog(r);
        if(g >= 0) {
            n->op = OLSHR;
            r->vconst = g;
            r->type = types[TINT];
            indexshift(n);
            break;
        }
        break;

    case OASLMOD:
        xcom(l);
        xcom(r);
        g = vlog(r);
        if(g >= 0) {
            n->op = OASAND;
            r->vconst--;
        }
        break;

    case OLMOD:
        xcom(l);
        xcom(r);
        g = vlog(r);
        if(g >= 0) {
            n->op = OAND;
            r->vconst--;
        }
        break;

    case OASMUL:
    case OASLMUL:
        xcom(l);
        xcom(r);
        g = vlog(r);
        if(g >= 0) {
            n->op = OASASHL;
            r->vconst = g;
        }
        break;

    case OLSHR:
    case OASHR:
        xcom(l);
        xcom(r);
        indexshift(n);
        break;

    default:
        if(l != Z)
            xcom(l);
        if(r != Z)
            xcom(r);
        break;
    }
brk:
    if(n->addable >= 10)
        return;
    if(l != Z)
        n->complex = l->complex;
    if(r != Z) {
        if(r->complex == n->complex)
            n->complex = r->complex+1;
        else
        if(r->complex > n->complex)
            n->complex = r->complex;
    }
    if(n->complex == 0)
        n->complex++;

    if(com64(n))
        return;

    switch(n->op) {

    case OFUNC:
        n->complex = FNX;
        break;

    case OLMOD:
    case OMOD:
    case OLMUL:
    case OLDIV:
    case OMUL:
    case ODIV:
    case OASLMUL:
    case OASLDIV:
    case OASLMOD:
    case OASMUL:
    case OASDIV:
    case OASMOD:
        if(r->complex >= l->complex) {
            n->complex = l->complex + 3;
            if(r->complex > n->complex)
                n->complex = r->complex;
        } else {
            n->complex = r->complex + 3;
            if(l->complex > n->complex)
                n->complex = l->complex;
        }
        break;

    case OLSHR:
    case OASHL:
    case OASHR:
    case OASLSHR:
    case OASASHL:
    case OASASHR:
        if(r->complex >= l->complex) {
            n->complex = l->complex + 2;
            if(r->complex > n->complex)
                n->complex = r->complex;
        } else {
            n->complex = r->complex + 2;
            if(l->complex > n->complex)
                n->complex = l->complex;
        }
        break;

    case OADD:
    case OXOR:
    case OAND:
    case OOR:
        /*
         * immediate operators, make const on right
         */
        if(l->op == OCONST) {
            n->left = r;
            n->right = l;
        }
        break;

    case OEQ:
    case ONE:
    case OLE:
    case OLT:
    case OGE:
    case OGT:
    case OHI:
    case OHS:
    case OLO:
    case OLS:
        /*
         * compare operators, make const on left
         */
        if(r->op == OCONST) {
            n->left = r;
            n->right = l;
            n->op = invrel[relindex(n->op)];
        }
        break;
    }
}
@
%$

<<function indx>>=
void
indx(Node *n)
{
    Node *l, *r;

    if(debug['x'])
        prtree(n, "indx");

    l = n->left;
    r = n->right;
    if(l->addable == 1 || l->addable == 13 || r->complex > l->complex) {
        n->right = l;
        n->left = r;
        l = r;
        r = n->right;
    }
    if(l->addable != 7) {
        idx.regtree = l;
        idx.scale = 1;
    } else
    if(l->right->addable == 20) {
        idx.regtree = l->left;
        idx.scale = 1 << l->right->vconst;
    } else
    if(l->left->addable == 20) {
        idx.regtree = l->right;
        idx.scale = 1 << l->left->vconst;
    } else
        diag(n, "bad index");

    idx.basetree = r;
    if(debug['x']) {
        print("scale = %d\n", idx.scale);
        prtree(idx.regtree, "index");
        prtree(idx.basetree, "base");
    }
}
@


%-------------------------------------------------------------

<<8c/sgen.c>>=
#include "gc.h"

<<function noretval>>

<<function commute>>

<<function indexshift>>

<<function xcom>>

<<function indx>>
@


\subsection*{[[8c/swt.c]]}

<<function swit1>>=
void
swit1(C1 *q, int nc, long def, Node *n)
{
    C1 *r;
    int i;
    Prog *sp;

    if(nc < 5) {
        for(i=0; i<nc; i++) {
            if(debug['K'])
                print("case = %.8llux\n", q->val);
            gopcode(OEQ, n->type, n, nodconst(q->val));
            patch(p, q->label);
            q++;
        }
        gbranch(OGOTO);
        patch(p, def);
        return;
    }
    i = nc / 2;
    r = q+i;
    if(debug['K'])
        print("case > %.8llux\n", r->val);
    gopcode(OGT, n->type, n, nodconst(r->val));
    sp = p;
    gbranch(OGOTO);
    p->as = AJEQ;
    patch(p, r->label);
    swit1(q, i, def, n);

    if(debug['K'])
        print("case < %.8llux\n", r->val);
    patch(sp, pc);
    swit1(r+1, nc-i-1, def, n);
}
@

<<function bitload>>=
void
bitload(Node *b, Node *n1, Node *n2, Node *n3, Node *nn)
{
    int sh;
    long v;
    Node *l;

    /*
     * n1 gets adjusted/masked value
     * n2 gets address of cell
     * n3 gets contents of cell
     */
    l = b->left;
    if(n2 != Z) {
        regalloc(n1, l, nn);
        reglcgen(n2, l, Z);
        regalloc(n3, l, Z);
        gmove(n2, n3);
        gmove(n3, n1);
    } else {
        regalloc(n1, l, nn);
        cgen(l, n1);
    }
    if(b->type->shift == 0 && typeu[b->type->etype]) {
        v = ~0 + (1L << b->type->nbits);
        gopcode(OAND, types[TLONG], nodconst(v), n1);
    } else {
        sh = 32 - b->type->shift - b->type->nbits;
        if(sh > 0)
            gopcode(OASHL, types[TLONG], nodconst(sh), n1);
        sh += b->type->shift;
        if(sh > 0)
            if(typeu[b->type->etype])
                gopcode(OLSHR, types[TLONG], nodconst(sh), n1);
            else
                gopcode(OASHR, types[TLONG], nodconst(sh), n1);
    }
}
@
% >>

<<function bitstore>>=
void
bitstore(Node *b, Node *n1, Node *n2, Node *n3, Node *nn)
{
    long v;
    Node nod;
    int sh;

    regalloc(&nod, b->left, Z);
    v = ~0 + (1L << b->type->nbits);
    gopcode(OAND, types[TLONG], nodconst(v), n1);
    gmove(n1, &nod);
    if(nn != Z)
        gmove(n1, nn);
    sh = b->type->shift;
    if(sh > 0)
        gopcode(OASHL, types[TLONG], nodconst(sh), &nod);
    v <<= sh;
    gopcode(OAND, types[TLONG], nodconst(~v), n3);
    gopcode(OOR, types[TLONG], n3, &nod);
    gmove(&nod, n2);

    regfree(&nod);
    regfree(n1);
    regfree(n2);
    regfree(n3);
}
@

% >> >>

<<function outstring>>=
long
outstring(char *s, long n)
{
    long r;

    if(suppress)
        return nstring;
    r = nstring;
    while(n) {
        string[mnstring] = *s++;
        mnstring++;
        nstring++;
        if(mnstring >= NSNAME) {
            gpseudo(ADATA, symstring, nodconst(0L));
            p->from.offset += nstring - NSNAME;
            p->from.scale = NSNAME;
            p->to.type = D_SCONST;
            memmove(p->to.sval, string, NSNAME);
            mnstring = 0;
        }
        n--;
    }
    return r;
}
@

<<function gextern>>=
void
gextern(Sym *s, Node *a, long o, long w)
{
    if(a->op == OCONST && typev[a->type->etype]) {
        gpseudo(ADATA, s, lo64(a));
        p->from.offset += o;
        p->from.scale = 4;
        gpseudo(ADATA, s, hi64(a));
        p->from.offset += o + 4;
        p->from.scale = 4;
        return;
    }
    gpseudo(ADATA, s, a);
    p->from.offset += o;
    p->from.scale = w;
    switch(p->to.type) {
    default:
        p->to.index = p->to.type;
        p->to.type = D_ADDR;
    case D_CONST:
    case D_FCONST:
    case D_ADDR:
        break;
    }
}
@

<<struct Htab>>=
struct Htab { 
  Sym *sym; 
  short type; 
};
@

<<function outcode>>=
void
outcode(void)
{
    Prog *p;
    Sym *s;
    int f, sf, st, t, sym;
    Biobuf b;
    struct Htab h[NSYM];

    if(debug['S']) {
        for(p = firstp; p != P; p = p->link)
            if(p->as != ADATA && p->as != AGLOBL)
                pc--;
        for(p = firstp; p != P; p = p->link) {
            print("%P\n", p);
            if(p->as != ADATA && p->as != AGLOBL)
                pc++;
        }
    }
    f = open(outfile, OWRITE);
    if(f < 0) {
        diag(Z, "cannot open %s", outfile);
        return;
    }
    Binit(&b, f, OWRITE);
    Bseek(&b, 0L, 2);
    outhist(&b);
    for(sym=0; sym<NSYM; sym++) {
        h[sym].sym = S;
        h[sym].type = 0;
    }
    sym = 1;
    for(p = firstp; p != P; p = p->link) {
    jackpot:
        sf = 0;
        s = p->from.sym;
        while(s != S) {
            sf = s->sym;
            if(sf < 0 || sf >= NSYM)
                sf = 0;
            t = p->from.type;
            if(t == D_ADDR)
                t = p->from.index;
            if(h[sf].type == t)
            if(h[sf].sym == s)
                break;
            s->sym = sym;
            zname(&b, s, t);
            h[sym].sym = s;
            h[sym].type = t;
            sf = sym;
            sym++;
            if(sym >= NSYM)
                sym = 1;
            break;
        }
        st = 0;
        s = p->to.sym;
        while(s != S) {
            st = s->sym;
            if(st < 0 || st >= NSYM)
                st = 0;
            t = p->to.type;
            if(t == D_ADDR)
                t = p->to.index;
            if(h[st].type == t)
            if(h[st].sym == s)
                break;
            s->sym = sym;
            zname(&b, s, t);
            h[sym].sym = s;
            h[sym].type = t;
            st = sym;
            sym++;
            if(sym >= NSYM)
                sym = 1;
            if(st == sf)
                goto jackpot;
            break;
        }
        Bputc(&b, p->as);
        Bputc(&b, p->as>>8);
        Bputc(&b, p->lineno);
        Bputc(&b, p->lineno>>8);
        Bputc(&b, p->lineno>>16);
        Bputc(&b, p->lineno>>24);
        zaddr(&b, &p->from, sf);
        zaddr(&b, &p->to, st);
    }
    Bflush(&b);
    close(f);
    firstp = P;
    lastp = P;
}
@

<<function outhist>>=
void
outhist(Biobuf *b)
{
    Hist *h;
    char *p, *q, *op, c;
    Prog pg;
    int n;

    pg = zprog;
    pg.as = AHISTORY;
    c = pathchar();
    for(h = hist; h != H; h = h->link) {
        p = h->name;
        op = 0;
        /* on windows skip drive specifier in pathname */
        if(systemtype(Windows) && p && p[1] == ':'){
            p += 2;
            c = *p;
        }
        if(p && p[0] != c && h->offset == 0 && pathname){
            /* on windows skip drive specifier in pathname */
            if(systemtype(Windows) && pathname[1] == ':') {
                op = p;
                p = pathname+2;
                c = *p;
            } else if(pathname[0] == c){
                op = p;
                p = pathname;
            }
        }
        while(p) {
            q = utfrune(p, c);
            if(q) {
                n = q-p;
                if(n == 0){
                    n = 1;	/* leading "/" */
                    *p = '/';	/* don't emit "\" on windows */
                }
                q++;
            } else {
                n = strlen(p);
                q = 0;
            }
            if(n) {
                Bputc(b, ANAME);
                Bputc(b, ANAME>>8);
                Bputc(b, D_FILE);
                Bputc(b, 1);
                Bputc(b, '<');
                Bwrite(b, p, n);
                Bputc(b, 0);
            }
            p = q;
            if(p == 0 && op) {
                p = op;
                op = 0;
            }
        }
        pg.lineno = h->line;
        pg.to.type = zprog.to.type;
        pg.to.offset = h->offset;
        if(h->offset)
            pg.to.type = D_CONST;

        Bputc(b, pg.as);
        Bputc(b, pg.as>>8);
        Bputc(b, pg.lineno);
        Bputc(b, pg.lineno>>8);
        Bputc(b, pg.lineno>>16);
        Bputc(b, pg.lineno>>24);
        zaddr(b, &pg.from, 0);
        zaddr(b, &pg.to, 0);
    }
}
@

<<function zname>>=
void
zname(Biobuf *b, Sym *s, int t)
{
    char *n;
    ulong sig;

    if(debug['T'] && t == D_EXTERN && s->sig != SIGDONE && s->type != types[TENUM] && s != symrathole){
        sig = sign(s);
        Bputc(b, ASIGNAME);
        Bputc(b, ASIGNAME>>8);
        Bputc(b, sig);
        Bputc(b, sig>>8);
        Bputc(b, sig>>16);
        Bputc(b, sig>>24);
        s->sig = SIGDONE;
    }
    else{
        Bputc(b, ANAME);	/* as */
        Bputc(b, ANAME>>8);	/* as */
    }
    Bputc(b, t);			/* type */
    Bputc(b, s->sym);		/* sym */
    n = s->name;
    while(*n) {
        Bputc(b, *n);
        n++;
    }
    Bputc(b, 0);
}
@

<<function zaddr>>=
void
zaddr(Biobuf *b, Adr *a, int s)
{
    long l;
    int i, t;
    char *n;
    Ieee e;

    t = 0;
    if(a->index != D_NONE || a->scale != 0)
        t |= T_INDEX;
    if(s != 0)
        t |= T_SYM;

    switch(a->type) {
    default:
        t |= T_TYPE;
    case D_NONE:
        if(a->offset != 0)
            t |= T_OFFSET;
        break;
    case D_FCONST:
        t |= T_FCONST;
        break;
    case D_SCONST:
        t |= T_SCONST;
        break;
    }
    Bputc(b, t);

    if(t & T_INDEX) {	/* implies index, scale */
        Bputc(b, a->index);
        Bputc(b, a->scale);
    }
    if(t & T_OFFSET) {	/* implies offset */
        l = a->offset;
        Bputc(b, l);
        Bputc(b, l>>8);
        Bputc(b, l>>16);
        Bputc(b, l>>24);
    }
    if(t & T_SYM)		/* implies sym */
        Bputc(b, s);
    if(t & T_FCONST) {
        ieeedtod(&e, a->dval);
        l = e.l;
        Bputc(b, l);
        Bputc(b, l>>8);
        Bputc(b, l>>16);
        Bputc(b, l>>24);
        l = e.h;
        Bputc(b, l);
        Bputc(b, l>>8);
        Bputc(b, l>>16);
        Bputc(b, l>>24);
        return;
    }
    if(t & T_SCONST) {
        n = a->sval;
        for(i=0; i<NSNAME; i++) {
            Bputc(b, *n);
            n++;
        }
        return;
    }
    if(t & T_TYPE)
        Bputc(b, a->type);
}
@

<<function align>>=
long
align(long i, Type *t, int op)
{
    long o;
    Type *v;
    int w;

    o = i;
    w = 1;
    switch(op) {
    default:
        diag(Z, "unknown align opcode %d", op);
        break;

    case Asu2:	/* padding at end of a struct */
        w = SZ_LONG;
        if(packflg)
            w = packflg;
        break;

    case Ael1:	/* initial allign of struct element */
        for(v=t; v->etype==TARRAY; v=v->link)
            ;
        w = ewidth[v->etype];
        if(w <= 0 || w >= SZ_LONG)
            w = SZ_LONG;
        if(packflg)
            w = packflg;
        break;

    case Ael2:	/* width of a struct element */
        o += t->width;
        break;

    case Aarg0:	/* initial passbyptr argument in arg list */
        if(typesuv[t->etype]) {
            o = align(o, types[TIND], Aarg1);
            o = align(o, types[TIND], Aarg2);
        }
        break;

    case Aarg1:	/* initial allign of parameter */
        w = ewidth[t->etype];
        if(w <= 0 || w >= SZ_LONG) {
            w = SZ_LONG;
            break;
        }
        w = 1;		/* little endian no adjustment */
        break;

    case Aarg2:	/* width of a parameter */
        o += t->width;
        w = SZ_LONG;
        break;

    case Aaut3:	/* total allign of automatic */
        o = align(o, t, Ael1);
        o = align(o, t, Ael2);
        break;
    }
    o = round(o, w);
    if(debug['A'])
        print("align %s %ld %T = %ld\n", bnames[op], i, t, o);
    return o;
}
@

<<function maxround>>=
long
maxround(long max, long v)
{
    v = round(v, SZ_LONG);
    if(v > max)
        return v;
    return max;
}
@


%-------------------------------------------------------------

<<8c/swt.c>>=
#include "gc.h"

<<function swit1>>

<<function bitload>>

<<function bitstore>>

<<function outstring>>

<<function gextern>>

void	zname(Biobuf*, Sym*, int);
void	zaddr(Biobuf*, Adr*, int);
void	outhist(Biobuf*);

<<struct Htab>>

<<function outcode>>

<<function outhist>>

<<function zname>>

<<function zaddr>>

<<function align>>

<<function maxround>>
@


\subsection*{[[8c/mul.c]]}

<<struct Malg>>=
struct	Malg
{
    char	vals[10];
};
@

<<struct Mparam>>=
struct	Mparam
{
    ulong	value;
    char	alg;
    char	neg;
    char	shift;
    char	arg;
    char	off;
};
@

<<global multab>>=
static	Mparam	multab[32];
@

<<global mulptr>>=
static	int	mulptr;
@

<<global malgs>>=
static	Malg	malgs[]	=
{
    {0, 100},
    {-1, 1, 100},
    {-9, -5, -3, 3, 5, 9, 100},
    {6, 10, 12, 18, 20, 24, 36, 40, 72, 100},
    {-8, -4, -2, 2, 4, 8, 100},
};
@

<<function lowbit>>=
/*
 * return position of lowest 1
 */
int
lowbit(ulong v)
{
    int s, i;
    ulong m;

    s = 0;
    m = 0xFFFFFFFFUL;
    for(i = 16; i > 0; i >>= 1) {
        m >>= i;
        if((v & m) == 0) {
            v >>= i;
            s += i;
        }
    }
    return s;
}
@

<<function genmuladd>>=
void
genmuladd(Node *d, Node *s, int m, Node *a)
{
    Node nod;

    nod.op = OINDEX;
    nod.left = a;
    nod.right = s;
    nod.scale = m;
    nod.type = types[TIND];
    nod.xoffset = 0;
    xcom(&nod);
    gopcode(OADDR, d->type, &nod, d);
}
@

<<function mulparam>>=
void
mulparam(ulong m, Mparam *mp)
{
    int c, i, j, n, o, q, s;
    int bc, bi, bn, bo, bq, bs, bt;
    char *p;
    long u;
    ulong t;

    bc = bq = 10;
    bi = bn = bo = bs = bt = 0;
    for(i = 0; i < nelem(malgs); i++) {
        for(p = malgs[i].vals, j = 0; (o = p[j]) < 100; j++)
        for(s = 0; s < 2; s++) {
            c = 10;
            q = 10;
            u = m - o;
            if(u == 0)
                continue;
            if(s) {
                o = -o;
                if(o > 0)
                    continue;
                u = -u;
            }
            n = lowbit(u);
            t = (ulong)u >> n;
            switch(i) {
            case 0:
                if(t == 1) {
                    c = s + 1;
                    q = 0;
                    break;
                }
                switch(t) {
                case 3:
                case 5:
                case 9:
                    c = s + 1;
                    if(n)
                        c++;
                    q = 0;
                    break;
                }
                if(s)
                    break;
                switch(t) {
                case 15:
                case 25:
                case 27:
                case 45:
                case 81:
                    c = 2;
                    if(n)
                        c++;
                    q = 1;
                    break;
                }
                break;
            case 1:
                if(t == 1) {
                    c = 3;
                    q = 3;
                    break;
                }
                switch(t) {
                case 3:
                case 5:
                case 9:
                    c = 3;
                    q = 2;
                    break;
                }
                break;
            case 2:
                if(t == 1) {
                    c = 3;
                    q = 2;
                    break;
                }
                break;
            case 3:
                if(s)
                    break;
                if(t == 1) {
                    c = 3;
                    q = 1;
                    break;
                }
                break;
            case 4:
                if(t == 1) {
                    c = 3;
                    q = 0;
                    break;
                }
                break;
            }
            if(c < bc || (c == bc && q > bq)) {
                bc = c;
                bi = i;
                bn = n;
                bo = o;
                bq = q;
                bs = s;
                bt = t;
            }
        }
    }
    mp->value = m;
    if(bc <= 3) {
        mp->alg = bi;
        mp->shift = bn;
        mp->off = bo;
        mp->neg = bs;
        mp->arg = bt;
    }
    else
        mp->alg = -1;
}
@

<<function m0>>=
int
m0(int a)
{
    switch(a) {
    case -2:
    case 2:
        return 2;
    case -3:
    case 3:
        return 2;
    case -4:
    case 4:
        return 4;
    case -5:
    case 5:
        return 4;
    case 6:
        return 2;
    case -8:
    case 8:
        return 8;
    case -9:
    case 9:
        return 8;
    case 10:
        return 4;
    case 12:
        return 2;
    case 15:
        return 2;
    case 18:
        return 8;
    case 20:
        return 4;
    case 24:
        return 2;
    case 25:
        return 4;
    case 27:
        return 2;
    case 36:
        return 8;
    case 40:
        return 4;
    case 45:
        return 4;
    case 72:
        return 8;
    case 81:
        return 8;
    }
    diag(Z, "bad m0");
    return 0;
}
@

<<function m1>>=
int
m1(int a)
{
    switch(a) {
    case 15:
        return 4;
    case 25:
        return 4;
    case 27:
        return 8;
    case 45:
        return 8;
    case 81:
        return 8;
    }
    diag(Z, "bad m1");
    return 0;
}
@

<<function m2>>=
int
m2(int a)
{
    switch(a) {
    case 6:
        return 2;
    case 10:
        return 2;
    case 12:
        return 4;
    case 18:
        return 2;
    case 20:
        return 4;
    case 24:
        return 8;
    case 36:
        return 4;
    case 40:
        return 8;
    case 72:
        return 8;
    }
    diag(Z, "bad m2");
    return 0;
}
@

<<function shiftit>>=
void
shiftit(Type *t, Node *s, Node *d)
{
    long c;

    c = (long)s->vconst & 31;
    switch(c) {
    case 0:
        break;
    case 1:
        gopcode(OADD, t, d, d);
        break;
    default:
        gopcode(OASHL, t, s, d);
    }
}
@

<<function mulgen1>>=
static int
mulgen1(ulong v, Node *n)
{
    int i, o;
    Mparam *p;
    Node nod, nods;

    for(i = 0; i < nelem(multab); i++) {
        p = &multab[i];
        if(p->value == v)
            goto found;
    }

    p = &multab[mulptr];
    if(++mulptr == nelem(multab))
        mulptr = 0;

    mulparam(v, p);

found:
//	print("v=%.lx a=%d n=%d s=%d g=%d o=%d \n", p->value, p->alg, p->neg, p->shift, p->arg, p->off);
    if(p->alg < 0)
        return 0;

    nods = *nodconst(p->shift);

    o = OADD;
    if(p->alg > 0) {
        regalloc(&nod, n, Z);
        if(p->off < 0)
            o = OSUB;
    }

    switch(p->alg) {
    case 0:
        switch(p->arg) {
        case 1:
            shiftit(n->type, &nods, n);
            break;
        case 15:
        case 25:
        case 27:
        case 45:
        case 81:
            genmuladd(n, n, m1(p->arg), n);
            /* fall thru */
        case 3:
        case 5:
        case 9:
            genmuladd(n, n, m0(p->arg), n);
            shiftit(n->type, &nods, n);
            break;
        default:
            goto bad;
        }
        if(p->neg == 1)
            gins(ANEGL, Z, n);
        break;
    case 1:
        switch(p->arg) {
        case 1:
            gmove(n, &nod);
            shiftit(n->type, &nods, &nod);
            break;
        case 3:
        case 5:
        case 9:
            genmuladd(&nod, n, m0(p->arg), n);
            shiftit(n->type, &nods, &nod);
            break;
        default:
            goto bad;
        }
        if(p->neg)
            gopcode(o, n->type, &nod, n);
        else {
            gopcode(o, n->type, n, &nod);
            gmove(&nod, n);
        }
        break;
    case 2:
        genmuladd(&nod, n, m0(p->off), n);
        shiftit(n->type, &nods, n);
        goto comop;
    case 3:
        genmuladd(&nod, n, m0(p->off), n);
        shiftit(n->type, &nods, n);
        genmuladd(n, &nod, m2(p->off), n);
        break;
    case 4:
        genmuladd(&nod, n, m0(p->off), nodconst(0));
        shiftit(n->type, &nods, n);
        goto comop;
    default:
        diag(Z, "bad mul alg");
        break;
    comop:
        if(p->neg) {
            gopcode(o, n->type, n, &nod);
            gmove(&nod, n);
        }
        else
            gopcode(o, n->type, &nod, n);
    }

    if(p->alg > 0)
        regfree(&nod);

    return 1;

bad:
    diag(Z, "mulgen botch");
    return 1;
}
@

<<function mulgen>>=
void
mulgen(Type *t, Node *r, Node *n)
{
    if(!mulgen1(r->vconst, n))
        gopcode(OMUL, t, r, n);
}
@


%-------------------------------------------------------------

<<8c/mul.c>>=
#include "gc.h"

typedef struct	Malg	Malg;
typedef struct	Mparam	Mparam;

<<struct Malg>>

<<struct Mparam>>

<<global multab>>
<<global mulptr>>

<<global malgs>>

<<function lowbit>>

<<function genmuladd>>

<<function mulparam>>

<<function m0>>

<<function m1>>

<<function m2>>

<<function shiftit>>

<<function mulgen1>>

<<function mulgen>>
@


\subsection*{[[8c/reg.c]]}

<<function rega>>=
Reg*
rega(void)
{
    Reg *r;

    r = freer;
    if(r == R) {
        r = alloc(sizeof(*r));
    } else
        freer = r->link;

    *r = zreg;
    return r;
}
@

<<function rcmp>>=
int
rcmp(const void *a1, const void *a2)
{
    Rgn *p1, *p2;
    int c1, c2;

    p1 = (Rgn*)a1;
    p2 = (Rgn*)a2;
    c1 = p2->cost;
    c2 = p1->cost;
    if(c1 -= c2)
        return c1;
    return p2->varno - p1->varno;
}
@

<<struct Regopt_helper>>=
struct Regopt_helper {
        long	m;
        long	c;
        Reg*	p;
};
@

<<function regopt>>=
void
regopt(Prog *p)
{
    Reg *r, *r1, *r2;
    Prog *p1;
    int i, z;
    long initpc, val, npc;
    ulong vreg;
    Bits bit;
    struct Regopt_helper log5[6], *lp;

    firstr = R;
    lastr = R;
    nvar = 0;
    regbits = RtoB(D_SP) | RtoB(D_AX);
    for(z=0; z<BITS; z++) {
        externs.b[z] = 0;
        params.b[z] = 0;
        consts.b[z] = 0;
        addrs.b[z] = 0;
    }

    /*
     * pass 1
     * build aux data structure
     * allocate pcs
     * find use and set of variables
     */
    val = 5L * 5L * 5L * 5L * 5L;
    lp = log5;
    for(i=0; i<5; i++) {
        lp->m = val;
        lp->c = 0;
        lp->p = R;
        val /= 5L;
        lp++;
    }
    val = 0;
    for(; p != P; p = p->link) {
        switch(p->as) {
        case ADATA:
        case AGLOBL:
        case ANAME:
        case ASIGNAME:
            continue;
        }
        r = rega();
        if(firstr == R) {
            firstr = r;
            lastr = r;
        } else {
            lastr->link = r;
            r->p1 = lastr;
            lastr->s1 = r;
            lastr = r;
        }
        r->prog = p;
        r->pc = val;
        val++;

        lp = log5;
        for(i=0; i<5; i++) {
            lp->c--;
            if(lp->c <= 0) {
                lp->c = lp->m;
                if(lp->p != R)
                    lp->p->log5 = r;
                lp->p = r;
                (lp+1)->c = 0;
                break;
            }
            lp++;
        }

        r1 = r->p1;
        if(r1 != R)
        switch(r1->prog->as) {
        case ARET:
        case AJMP:
        case AIRETL:
            r->p1 = R;
            r1->s1 = R;
        }

        bit = mkvar(r, &p->from, p->as==AMOVL);
        if(bany(&bit))
        switch(p->as) {
        /*
         * funny
         */
        case ALEAL:
            for(z=0; z<BITS; z++)
                addrs.b[z] |= bit.b[z];
            break;

        /*
         * left side read
         */
        default:
            for(z=0; z<BITS; z++)
                r->use1.b[z] |= bit.b[z];
            break;
        }

        bit = mkvar(r, &p->to, 0);
        if(bany(&bit))
        switch(p->as) {
        default:
            diag(Z, "reg: unknown op: %A", p->as);
            break;

        /*
         * right side read
         */
        case ACMPB:
        case ACMPL:
        case ACMPW:
            for(z=0; z<BITS; z++)
                r->use2.b[z] |= bit.b[z];
            break;

        /*
         * right side write
         */
        case ANOP:
        case AMOVL:
        case AMOVB:
        case AMOVW:
        case AMOVBLSX:
        case AMOVBLZX:
        case AMOVWLSX:
        case AMOVWLZX:
            for(z=0; z<BITS; z++)
                r->set.b[z] |= bit.b[z];
            break;

        /*
         * right side read+write
         */
        case AADDB:
        case AADDL:
        case AADDW:
        case AANDB:
        case AANDL:
        case AANDW:
        case ASUBB:
        case ASUBL:
        case ASUBW:
        case AORB:
        case AORL:
        case AORW:
        case AXORB:
        case AXORL:
        case AXORW:
        case ASALB:
        case ASALL:
        case ASALW:
        case ASARB:
        case ASARL:
        case ASARW:
        case AROLB:
        case AROLL:
        case AROLW:
        case ARORB:
        case ARORL:
        case ARORW:
        case ASHLB:
        case ASHLL:
        case ASHLW:
        case ASHRB:
        case ASHRL:
        case ASHRW:
        case AIMULL:
        case AIMULW:
        case ANEGL:
        case ANOTL:
        case AADCL:
        case ASBBL:
            for(z=0; z<BITS; z++) {
                r->set.b[z] |= bit.b[z];
                r->use2.b[z] |= bit.b[z];
            }
            break;

        /*
         * funny
         */
        case AFMOVDP:
        case AFMOVFP:
        case AFMOVLP:
        case AFMOVVP:
        case AFMOVWP:
        case ACALL:
            for(z=0; z<BITS; z++)
                addrs.b[z] |= bit.b[z];
            break;
        }

        switch(p->as) {
        case AIMULL:
        case AIMULW:
            if(p->to.type != D_NONE)
                break;

        case AIDIVB:
        case AIDIVL:
        case AIDIVW:
        case AIMULB:
        case ADIVB:
        case ADIVL:
        case ADIVW:
        case AMULB:
        case AMULL:
        case AMULW:

        case ACWD:
        case ACDQ:
            r->regu |= RtoB(D_AX) | RtoB(D_DX);
            break;

        case AREP:
        case AREPN:
        case ALOOP:
        case ALOOPEQ:
        case ALOOPNE:
            r->regu |= RtoB(D_CX);
            break;

        case AMOVSB:
        case AMOVSL:
        case AMOVSW:
        case ACMPSB:
        case ACMPSL:
        case ACMPSW:
            r->regu |= RtoB(D_SI) | RtoB(D_DI);
            break;

        case ASTOSB:
        case ASTOSL:
        case ASTOSW:
        case ASCASB:
        case ASCASL:
        case ASCASW:
            r->regu |= RtoB(D_AX) | RtoB(D_DI);
            break;

        case AINSB:
        case AINSL:
        case AINSW:
        case AOUTSB:
        case AOUTSL:
        case AOUTSW:
            r->regu |= RtoB(D_DI) | RtoB(D_DX);
            break;

        case AFSTSW:
        case ASAHF:
            r->regu |= RtoB(D_AX);
            break;
        }
    }
    if(firstr == R)
        return;
    initpc = pc - val;
    npc = val;

    /*
     * pass 2
     * turn branch references to pointers
     * build back pointers
     */
    for(r = firstr; r != R; r = r->link) {
        p = r->prog;
        if(p->to.type == D_BRANCH) {
            val = p->to.offset - initpc;
            r1 = firstr;
            while(r1 != R) {
                r2 = r1->log5;
                if(r2 != R && val >= r2->pc) {
                    r1 = r2;
                    continue;
                }
                if(r1->pc == val)
                    break;
                r1 = r1->link;
            }
            if(r1 == R) {
                nearln = p->lineno;
                diag(Z, "ref not found\n%P", p);
                continue;
            }
            if(r1 == r) {
                nearln = p->lineno;
                diag(Z, "ref to self\n%P", p);
                continue;
            }
            r->s2 = r1;
            r->p2link = r1->p2;
            r1->p2 = r;
        }
    }
    if(debug['R']) {
        p = firstr->prog;
        print("\n%L %D\n", p->lineno, &p->from);
    }

    /*
     * pass 2.5
     * find looping structure
     */
    for(r = firstr; r != R; r = r->link)
        r->active = 0;
    change = 0;
    loopit(firstr, npc);
    if(debug['R'] && debug['v']) {
        print("\nlooping structure:\n");
        for(r = firstr; r != R; r = r->link) {
            print("%ld:%P", r->loop, r->prog);
            for(z=0; z<BITS; z++)
                bit.b[z] = r->use1.b[z] |
                       r->use2.b[z] |
                       r->set.b[z];
            if(bany(&bit)) {
                print("\t");
                if(bany(&r->use1))
                    print(" u1=%B", r->use1);
                if(bany(&r->use2))
                    print(" u2=%B", r->use2);
                if(bany(&r->set))
                    print(" st=%B", r->set);
            }
            print("\n");
        }
    }

    /*
     * pass 3
     * iterate propagating usage
     * 	back until flow graph is complete
     */
loop1:
    change = 0;
    for(r = firstr; r != R; r = r->link)
        r->active = 0;
    for(r = firstr; r != R; r = r->link)
        if(r->prog->as == ARET)
            prop(r, zbits, zbits);
loop11:
    /* pick up unreachable code */
    i = 0;
    for(r = firstr; r != R; r = r1) {
        r1 = r->link;
        if(r1 && r1->active && !r->active) {
            prop(r, zbits, zbits);
            i = 1;
        }
    }
    if(i)
        goto loop11;
    if(change)
        goto loop1;


    /*
     * pass 4
     * iterate propagating register/variable synchrony
     * 	forward until graph is complete
     */
loop2:
    change = 0;
    for(r = firstr; r != R; r = r->link)
        r->active = 0;
    synch(firstr, zbits);
    if(change)
        goto loop2;


    /*
     * pass 5
     * isolate regions
     * calculate costs (paint1)
     */
    r = firstr;
    if(r) {
        for(z=0; z<BITS; z++)
            bit.b[z] = (r->refahead.b[z] | r->calahead.b[z]) &
              ~(externs.b[z] | params.b[z] | addrs.b[z] | consts.b[z]);
        if(bany(&bit)) {
            nearln = r->prog->lineno;
            warn(Z, "used and not set: %B", bit);
            if(debug['R'] && !debug['w'])
                print("used and not set: %B\n", bit);
        }
    }
    if(debug['R'] && debug['v'])
        print("\nprop structure:\n");
    for(r = firstr; r != R; r = r->link)
        r->act = zbits;
    rgp = region;
    nregion = 0;
    for(r = firstr; r != R; r = r->link) {
        if(debug['R'] && debug['v']) {
            print("%P\t", r->prog);
            if(bany(&r->set))
                print("s:%B ", r->set);
            if(bany(&r->refahead))
                print("ra:%B ", r->refahead);
            if(bany(&r->calahead))
                print("ca:%B ", r->calahead);
            print("\n");
        }
        for(z=0; z<BITS; z++)
            bit.b[z] = r->set.b[z] &
              ~(r->refahead.b[z] | r->calahead.b[z] | addrs.b[z]);
        if(bany(&bit)) {
            nearln = r->prog->lineno;
            warn(Z, "set and not used: %B", bit);
            if(debug['R'])
                print("set and not used: %B\n", bit);
            excise(r);
        }
        for(z=0; z<BITS; z++)
            bit.b[z] = LOAD(r) & ~(r->act.b[z] | addrs.b[z]);
        while(bany(&bit)) {
            i = bnum(bit);
            rgp->enter = r;
            rgp->varno = i;
            change = 0;
            if(debug['R'] && debug['v'])
                print("\n");
            paint1(r, i);
            bit.b[i/32] &= ~(1L<<(i%32));
            if(change <= 0) {
                if(debug['R'])
                    print("%L$%d: %B\n",
                        r->prog->lineno, change, blsh(i));
                continue;
            }
            rgp->cost = change;
            nregion++;
            if(nregion >= NRGN) {
                warn(Z, "too many regions");
                goto brk;
            }
            rgp++;
        }
    }
brk:
    qsort(region, nregion, sizeof(region[0]), rcmp);

    /*
     * pass 6
     * determine used registers (paint2)
     * replace code (paint3)
     */
    rgp = region;
    for(i=0; i<nregion; i++) {
        bit = blsh(rgp->varno);
        vreg = paint2(rgp->enter, rgp->varno);
        vreg = allreg(vreg, rgp);
        if(debug['R']) {
            print("%L$%d %R: %B\n",
                rgp->enter->prog->lineno,
                rgp->cost,
                rgp->regno,
                bit);
        }
        if(rgp->regno != 0)
            paint3(rgp->enter, rgp->varno, vreg, rgp->regno);
        rgp++;
    }
    /*
     * pass 7
     * peep-hole on basic block
     */
    if(!debug['R'] || debug['P'])
        peep();

    /*
     * pass 8
     * recalculate pc
     */
    val = initpc;
    for(r = firstr; r != R; r = r1) {
        r->pc = val;
        p = r->prog;
        p1 = P;
        r1 = r->link;
        if(r1 != R)
            p1 = r1->prog;
        for(; p != p1; p = p->link) {
            switch(p->as) {
            default:
                val++;
                break;

            case ANOP:
            case ADATA:
            case AGLOBL:
            case ANAME:
            case ASIGNAME:
                break;
            }
        }
    }
    pc = val;

    /*
     * fix up branches
     */
    if(debug['R'])
        if(bany(&addrs))
            print("addrs: %B\n", addrs);

    r1 = 0; /* set */
    for(r = firstr; r != R; r = r->link) {
        p = r->prog;
        if(p->to.type == D_BRANCH)
            p->to.offset = r->s2->pc;
        r1 = r;
    }

    /*
     * last pass
     * eliminate nops
     * free aux structures
     */
    for(p = firstr->prog; p != P; p = p->link){
        while(p->link && p->link->as == ANOP)
            p->link = p->link->link;
    }
    if(r1 != R) {
        r1->link = freer;
        freer = firstr;
    }
}
@

<<function addmove>>=
/*
 * add mov b,rn
 * just after r
 */
void
addmove(Reg *r, int bn, int rn, int f)
{
    Prog *p, *p1;
    Adr *a;
    Var *v;

    p1 = alloc(sizeof(*p1));
    *p1 = zprog;
    p = r->prog;

    p1->link = p->link;
    p->link = p1;
    p1->lineno = p->lineno;

    v = var + bn;

    a = &p1->to;
    a->sym = v->sym;
    a->offset = v->offset;
    a->etype = v->etype;
    a->type = v->name;

    p1->as = AMOVL;
    if(v->etype == TCHAR || v->etype == TUCHAR)
        p1->as = AMOVB;
    if(v->etype == TSHORT || v->etype == TUSHORT)
        p1->as = AMOVW;

    p1->from.type = rn;
    if(!f) {
        p1->from = *a;
        *a = zprog.from;
        a->type = rn;
        if(v->etype == TUCHAR)
            p1->as = AMOVB;
        if(v->etype == TUSHORT)
            p1->as = AMOVW;
    }
    if(debug['R'])
        print("%P\t.a%P\n", p, p1);
}
@

<<function doregbits>>=
ulong
doregbits(int r)
{
    ulong b;

    b = 0;
    if(r >= D_INDIR)
        r -= D_INDIR;
    if(r >= D_AX && r <= D_DI)
        b |= RtoB(r);
    else
    if(r >= D_AL && r <= D_BL)
        b |= RtoB(r-D_AL+D_AX);
    else
    if(r >= D_AH && r <= D_BH)
        b |= RtoB(r-D_AH+D_AX);
    return b;
}
@

<<function mkvar>>=
Bits
mkvar(Reg *r, Adr *a, int isro)
{
    Var *v;
    int i, t, n, et, z;
    long o;
    Bits bit;
    Sym *s;

    /*
     * mark registers used
     */
    t = a->type;
    r->regu |= doregbits(t);
    r->regu |= doregbits(a->index);
    et = a->etype;

    switch(t) {
    default:
        goto none;
    case D_INDIR+D_GS:
        if(!isro || 1)
            goto none;
        n = t;
        {static Sym er; a->sym = &er;}
        a->sym->name = "$extreg";
        break;
    case D_ADDR:
        a->type = a->index;
        bit = mkvar(r, a, 0);
        for(z=0; z<BITS; z++)
            addrs.b[z] |= bit.b[z];
        a->type = t;
        goto none;
    case D_EXTERN:
    case D_STATIC:
    case D_PARAM:
    case D_AUTO:
        n = t;
        break;
    }
    s = a->sym;
    if(s == S)
        goto none;
    if(s->name[0] == '.')
        goto none;
    o = a->offset;
    v = var;
    for(i=0; i<nvar; i++) {
        if(s == v->sym)
        if(n == v->name)
        if(o == v->offset)
            goto out;
        v++;
    }
    if(nvar >= NVAR) {
        if(debug['w'] > 1 && s)
            warn(Z, "variable not optimized: %s", s->name);
        goto none;
    }
    i = nvar;
    nvar++;
    v = &var[i];
    v->sym = s;
    v->offset = o;
    v->name = n;
    v->etype = et;
    if(debug['R'])
        print("bit=%2d et=%2d %D\n", i, et, a);

out:
    bit = blsh(i);
    if(n == D_EXTERN || n == D_STATIC)
        for(z=0; z<BITS; z++)
            externs.b[z] |= bit.b[z];
    if(n == D_PARAM)
        for(z=0; z<BITS; z++)
            params.b[z] |= bit.b[z];
    if(v->etype != et || !typechlpfd[et])	/* funny punning */
        for(z=0; z<BITS; z++)
            addrs.b[z] |= bit.b[z];
    return bit;

none:
    return zbits;
}
@

<<function prop>>=
void
prop(Reg *r, Bits ref, Bits cal)
{
    Reg *r1, *r2;
    int z;

    for(r1 = r; r1 != R; r1 = r1->p1) {
        for(z=0; z<BITS; z++) {
            ref.b[z] |= r1->refahead.b[z];
            if(ref.b[z] != r1->refahead.b[z]) {
                r1->refahead.b[z] = ref.b[z];
                change++;
            }
            cal.b[z] |= r1->calahead.b[z];
            if(cal.b[z] != r1->calahead.b[z]) {
                r1->calahead.b[z] = cal.b[z];
                change++;
            }
        }
        switch(r1->prog->as) {
        case ACALL:
            for(z=0; z<BITS; z++) {
                cal.b[z] |= ref.b[z] | externs.b[z];
                ref.b[z] = 0;
            }
            break;

        case ATEXT:
            for(z=0; z<BITS; z++) {
                cal.b[z] = 0;
                ref.b[z] = 0;
            }
            break;

        case ARET:
            for(z=0; z<BITS; z++) {
                cal.b[z] = externs.b[z];
                ref.b[z] = 0;
            }
        }
        for(z=0; z<BITS; z++) {
            ref.b[z] = (ref.b[z] & ~r1->set.b[z]) |
                r1->use1.b[z] | r1->use2.b[z];
            cal.b[z] &= ~(r1->set.b[z] | r1->use1.b[z] | r1->use2.b[z]);
            r1->refbehind.b[z] = ref.b[z];
            r1->calbehind.b[z] = cal.b[z];
        }
        if(r1->active)
            break;
        r1->active = 1;
    }
    for(; r != r1; r = r->p1)
        for(r2 = r->p2; r2 != R; r2 = r2->p2link)
            prop(r2, r->refbehind, r->calbehind);
}
@
%$


<<function postorder>>=
/*
 * find looping structure
 *
 * 1) find reverse postordering
 * 2) find approximate dominators,
 *	the actual dominators if the flow graph is reducible
 *	otherwise, dominators plus some other non-dominators.
 *	See Matthew S. Hecht and Jeffrey D. Ullman,
 *	"Analysis of a Simple Algorithm for Global Data Flow Problems",
 *	Conf.  Record of ACM Symp. on Principles of Prog. Langs, Boston, Massachusetts,
 *	Oct. 1-3, 1973, pp.  207-217.
 * 3) find all nodes with a predecessor dominated by the current node.
 *	such a node is a loop head.
 *	recursively, all preds with a greater rpo number are in the loop
 */
long
postorder(Reg *r, Reg **rpo2r, long n)
{
    Reg *r1;

    r->rpo = 1;
    r1 = r->s1;
    if(r1 && !r1->rpo)
        n = postorder(r1, rpo2r, n);
    r1 = r->s2;
    if(r1 && !r1->rpo)
        n = postorder(r1, rpo2r, n);
    rpo2r[n] = r;
    n++;
    return n;
}
@

<<function rpolca>>=
long
rpolca(long *idom, long rpo1, long rpo2)
{
    long t;

    if(rpo1 == -1)
        return rpo2;
    while(rpo1 != rpo2){
        if(rpo1 > rpo2){
            t = rpo2;
            rpo2 = rpo1;
            rpo1 = t;
        }
        while(rpo1 < rpo2){
            t = idom[rpo2];
            if(t >= rpo2)
                fatal(Z, "bad idom");
            rpo2 = t;
        }
    }
    return rpo1;
}
@

<<function doms>>=
int
doms(long *idom, long r, long s)
{
    while(s > r)
        s = idom[s];
    return s == r;
}
@

<<function loophead>>=
int
loophead(long *idom, Reg *r)
{
    long src;

    src = r->rpo;
    if(r->p1 != R && doms(idom, src, r->p1->rpo))
        return 1;
    for(r = r->p2; r != R; r = r->p2link)
        if(doms(idom, src, r->rpo))
            return 1;
    return 0;
}
@

<<function loopmark>>=
void
loopmark(Reg **rpo2r, long head, Reg *r)
{
    if(r->rpo < head || r->active == head)
        return;
    r->active = head;
    r->loop += LOOP;
    if(r->p1 != R)
        loopmark(rpo2r, head, r->p1);
    for(r = r->p2; r != R; r = r->p2link)
        loopmark(rpo2r, head, r);
}
@

<<function loopit>>=
void
loopit(Reg *r, long nr)
{
    Reg *r1;
    long i, d, me;

    if(nr > maxnr) {
        rpo2r = alloc(nr * sizeof(Reg*));
        idom = alloc(nr * sizeof(long));
        maxnr = nr;
    }

    d = postorder(r, rpo2r, 0);
    if(d > nr)
        fatal(Z, "too many reg nodes");
    nr = d;
    for(i = 0; i < nr / 2; i++){
        r1 = rpo2r[i];
        rpo2r[i] = rpo2r[nr - 1 - i];
        rpo2r[nr - 1 - i] = r1;
    }
    for(i = 0; i < nr; i++)
        rpo2r[i]->rpo = i;

    idom[0] = 0;
    for(i = 0; i < nr; i++){
        r1 = rpo2r[i];
        me = r1->rpo;
        d = -1;
        if(r1->p1 != R && r1->p1->rpo < me)
            d = r1->p1->rpo;
        for(r1 = r1->p2; r1 != nil; r1 = r1->p2link)
            if(r1->rpo < me)
                d = rpolca(idom, d, r1->rpo);
        idom[i] = d;
    }

    for(i = 0; i < nr; i++){
        r1 = rpo2r[i];
        r1->loop++;
        if(r1->p2 != R && loophead(idom, r1))
            loopmark(rpo2r, i, r1);
    }
}
@

<<function synch>>=
void
synch(Reg *r, Bits dif)
{
    Reg *r1;
    int z;

    for(r1 = r; r1 != R; r1 = r1->s1) {
        for(z=0; z<BITS; z++) {
            dif.b[z] = (dif.b[z] &
                ~(~r1->refbehind.b[z] & r1->refahead.b[z])) |
                    r1->set.b[z] | r1->regdiff.b[z];
            if(dif.b[z] != r1->regdiff.b[z]) {
                r1->regdiff.b[z] = dif.b[z];
                change++;
            }
        }
        if(r1->active)
            break;
        r1->active = 1;
        for(z=0; z<BITS; z++)
            dif.b[z] &= ~(~r1->calbehind.b[z] & r1->calahead.b[z]);
        if(r1->s2 != R)
            synch(r1->s2, dif);
    }
}
@

<<function allreg>>=
ulong
allreg(ulong b, Rgn *r)
{
    Var *v;
    int i;

    v = var + r->varno;
    r->regno = 0;
    switch(v->etype) {

    default:
        diag(Z, "unknown etype %d/%d", bitno(b), v->etype);
        break;

    case TCHAR:
    case TUCHAR:
    case TSHORT:
    case TUSHORT:
    case TINT:
    case TUINT:
    case TLONG:
    case TULONG:
    case TIND:
    case TARRAY:
        i = BtoR(~b);
        if(i && r->cost > 0) {
            r->regno = i;
            return RtoB(i);
        }
        break;

    case TDOUBLE:
    case TFLOAT:
        break;
    }
    return 0;
}
@

<<function paint1>>=
void
paint1(Reg *r, int bn)
{
    Reg *r1;
    Prog *p;
    int z;
    ulong bb;

    z = bn/32;
    bb = 1L<<(bn%32);
    if(r->act.b[z] & bb)
        return;
    for(;;) {
        if(!(r->refbehind.b[z] & bb))
            break;
        r1 = r->p1;
        if(r1 == R)
            break;
        if(!(r1->refahead.b[z] & bb))
            break;
        if(r1->act.b[z] & bb)
            break;
        r = r1;
    }

    if(LOAD(r) & ~(r->set.b[z]&~(r->use1.b[z]|r->use2.b[z])) & bb) {
        change -= CLOAD * r->loop;
        if(debug['R'] && debug['v'])
            print("%ld%P\tld %B $%d\n", r->loop,
                r->prog, blsh(bn), change);
    }
    for(;;) {
        r->act.b[z] |= bb;
        p = r->prog;

        if(r->use1.b[z] & bb) {
            change += CREF * r->loop;
            if(p->as == AFMOVL || p->as == AFMOVW)
                if(BtoR(bb) != D_F0)
                    change = -CINF;
            if(debug['R'] && debug['v'])
                print("%ld%P\tu1 %B $%d\n", r->loop,
                    p, blsh(bn), change);
        }

        if((r->use2.b[z]|r->set.b[z]) & bb) {
            change += CREF * r->loop;
            if(p->as == AFMOVL || p->as == AFMOVW)
                if(BtoR(bb) != D_F0)
                    change = -CINF;
            if(debug['R'] && debug['v'])
                print("%ld%P\tu2 %B $%d\n", r->loop,
                    p, blsh(bn), change);
        }

        if(STORE(r) & r->regdiff.b[z] & bb) {
            change -= CLOAD * r->loop;
            if(p->as == AFMOVL || p->as == AFMOVW)
                if(BtoR(bb) != D_F0)
                    change = -CINF;
            if(debug['R'] && debug['v'])
                print("%ld%P\tst %B $%d\n", r->loop,
                    p, blsh(bn), change);
        }

        if(r->refbehind.b[z] & bb)
            for(r1 = r->p2; r1 != R; r1 = r1->p2link)
                if(r1->refahead.b[z] & bb)
                    paint1(r1, bn);

        if(!(r->refahead.b[z] & bb))
            break;
        r1 = r->s2;
        if(r1 != R)
            if(r1->refbehind.b[z] & bb)
                paint1(r1, bn);
        r = r->s1;
        if(r == R)
            break;
        if(r->act.b[z] & bb)
            break;
        if(!(r->refbehind.b[z] & bb))
            break;
    }
}
@

<<function regset>>=
ulong
regset(Reg *r, ulong bb)
{
    ulong b, set;
    Adr v;
    int c;

    set = 0;
    v = zprog.from;
    while(b = bb & ~(bb-1)) {
        v.type = BtoR(b);
        c = copyu(r->prog, &v, A);
        if(c == 3)
            set |= b;
        bb &= ~b;
    }
    return set;
}
@

<<function reguse>>=
ulong
reguse(Reg *r, ulong bb)
{
    ulong b, set;
    Adr v;
    int c;

    set = 0;
    v = zprog.from;
    while(b = bb & ~(bb-1)) {
        v.type = BtoR(b);
        c = copyu(r->prog, &v, A);
        if(c == 1 || c == 2 || c == 4)
            set |= b;
        bb &= ~b;
    }
    return set;
}
@

<<function paint2>>=
ulong
paint2(Reg *r, int bn)
{
    Reg *r1;
    int z;
    ulong bb, vreg, x;

    z = bn/32;
    bb = 1L << (bn%32);
    vreg = regbits;
    if(!(r->act.b[z] & bb))
        return vreg;
    for(;;) {
        if(!(r->refbehind.b[z] & bb))
            break;
        r1 = r->p1;
        if(r1 == R)
            break;
        if(!(r1->refahead.b[z] & bb))
            break;
        if(!(r1->act.b[z] & bb))
            break;
        r = r1;
    }
    for(;;) {
        r->act.b[z] &= ~bb;

        vreg |= r->regu;

        if(r->refbehind.b[z] & bb)
            for(r1 = r->p2; r1 != R; r1 = r1->p2link)
                if(r1->refahead.b[z] & bb)
                    vreg |= paint2(r1, bn);

        if(!(r->refahead.b[z] & bb))
            break;
        r1 = r->s2;
        if(r1 != R)
            if(r1->refbehind.b[z] & bb)
                vreg |= paint2(r1, bn);
        r = r->s1;
        if(r == R)
            break;
        if(!(r->act.b[z] & bb))
            break;
        if(!(r->refbehind.b[z] & bb))
            break;
    }

    bb = vreg;
    for(; r; r=r->s1) {
        x = r->regu & ~bb;
        if(x) {
            vreg |= reguse(r, x);
            bb |= regset(r, x);
        }
    }
    return vreg;
}
@

<<function paint3>>=
void
paint3(Reg *r, int bn, long rb, int rn)
{
    Reg *r1;
    Prog *p;
    int z;
    ulong bb;

    z = bn/32;
    bb = 1L << (bn%32);
    if(r->act.b[z] & bb)
        return;
    for(;;) {
        if(!(r->refbehind.b[z] & bb))
            break;
        r1 = r->p1;
        if(r1 == R)
            break;
        if(!(r1->refahead.b[z] & bb))
            break;
        if(r1->act.b[z] & bb)
            break;
        r = r1;
    }

    if(LOAD(r) & ~(r->set.b[z] & ~(r->use1.b[z]|r->use2.b[z])) & bb)
        addmove(r, bn, rn, 0);
    for(;;) {
        r->act.b[z] |= bb;
        p = r->prog;

        if(r->use1.b[z] & bb) {
            if(debug['R'])
                print("%P", p);
            addreg(&p->from, rn);
            if(debug['R'])
                print("\t.c%P\n", p);
        }
        if((r->use2.b[z]|r->set.b[z]) & bb) {
            if(debug['R'])
                print("%P", p);
            addreg(&p->to, rn);
            if(debug['R'])
                print("\t.c%P\n", p);
        }

        if(STORE(r) & r->regdiff.b[z] & bb)
            addmove(r, bn, rn, 1);
        r->regu |= rb;

        if(r->refbehind.b[z] & bb)
            for(r1 = r->p2; r1 != R; r1 = r1->p2link)
                if(r1->refahead.b[z] & bb)
                    paint3(r1, bn, rb, rn);

        if(!(r->refahead.b[z] & bb))
            break;
        r1 = r->s2;
        if(r1 != R)
            if(r1->refbehind.b[z] & bb)
                paint3(r1, bn, rb, rn);
        r = r->s1;
        if(r == R)
            break;
        if(r->act.b[z] & bb)
            break;
        if(!(r->refbehind.b[z] & bb))
            break;
    }
}
@
% >>

<<function addreg>>=
void
addreg(Adr *a, int rn)
{

    a->sym = 0;
    a->offset = 0;
    a->type = rn;
}
@

<<function RtoB>>=
long
RtoB(int r)
{

    if(r < D_AX || r > D_DI)
        return 0;
    return 1L << (r-D_AX);
}
@

% >>

<<function BtoR>>=
int
BtoR(long b)
{

    b &= 0xffL;
    if(b == 0)
        return 0;
    return bitno(b) + D_AX;
}
@


%-------------------------------------------------------------

<<8c/reg.c>>=
#include "gc.h"

<<function rega>>

<<function rcmp>>

<<struct Regopt_helper>>

<<function regopt>>

<<function addmove>>

<<function doregbits>>

<<function mkvar>>

<<function prop>>

<<function postorder>>

<<function rpolca>>

<<function doms>>

<<function loophead>>

<<function loopmark>>

<<function loopit>>

<<function synch>>

<<function allreg>>

<<function paint1>>

<<function regset>>

<<function reguse>>

<<function paint2>>

<<function paint3>>

<<function addreg>>

<<function RtoB>>

<<function BtoR>>
@
% >>

\subsection*{[[8c/cgen64.c]]}

<<function zeroregm>>=
void
zeroregm(Node *n)
{
    gins(AMOVL, nodconst(0), n);
}
@

<<function vaddr>>=
/* do we need to load the address of a vlong? */
int
vaddr(Node *n, int a)
{
    switch(n->op) {
    case ONAME:
        if(a)
            return 1;
        return !(n->class == CEXTERN || n->class == CGLOBL || n->class == CSTATIC);

    case OCONST:
    case OREGISTER:
    case OINDREG:
        return 1;
    }
    return 0;
}
@

<<function hi64v>>=
long
hi64v(Node *n)
{
    if(align(0, types[TCHAR], Aarg1))	/* isbigendian */
        return (long)(n->vconst) & ~0L;
    else
        return (long)((uvlong)n->vconst>>32) & ~0L;
}
@

<<function lo64v>>=
long
lo64v(Node *n)
{
    if(align(0, types[TCHAR], Aarg1))	/* isbigendian */
        return (long)((uvlong)n->vconst>>32) & ~0L;
    else
        return (long)(n->vconst) & ~0L;
}
@

<<function hi64>>=
Node *
hi64(Node *n)
{
    return nodconst(hi64v(n));
}
@

<<function lo64>>=
Node *
lo64(Node *n)
{
    return nodconst(lo64v(n));
}
@

<<function anonreg>>=
static Node *
anonreg(void)
{
    Node *n;

    n = new(OREGISTER, Z, Z);
    n->reg = D_NONE;
    n->type = types[TLONG];
    return n;
}
@

<<function regpair>>=
static Node *
regpair(Node *n, Node *t)
{
    Node *r;

    if(n != Z && n->op == OREGPAIR)
        return n;
    r = new(OREGPAIR, anonreg(), anonreg());
    if(n != Z)
        r->type = n->type;
    else
        r->type = t->type;
    return r;
}
@

<<function evacaxdx>>=
static void
evacaxdx(Node *r)
{
    Node nod1, nod2;

    if(r->reg == D_AX || r->reg == D_DX) {
        reg[D_AX]++;
        reg[D_DX]++;
        /*
         * this is just an optim that should
         * check for spill
         */
        r->type = types[TULONG];
        regalloc(&nod1, r, Z);
        nodreg(&nod2, Z, r->reg);
        gins(AMOVL, &nod2, &nod1);
        regfree(r);
        r->reg = nod1.reg;
        reg[D_AX]--;
        reg[D_DX]--;
    }
}
@

<<function instpair>>=
/* lazy instantiation of register pair */
static int
instpair(Node *n, Node *l)
{
    int r;

    r = 0;
    if(n->left->reg == D_NONE) {
        if(l != Z) {
            n->left->reg = l->reg;
            r = 1;
        }
        else
            regalloc(n->left, n->left, Z);
    }
    if(n->right->reg == D_NONE)
        regalloc(n->right, n->right, Z);
    return r;
}
@

<<function zapreg>>=
static void
zapreg(Node *n)
{
    if(n->reg != D_NONE) {
        //prtree(n, "zapreg");
        regfree(n);
        n->reg = D_NONE;
    }
}
@

<<function freepair>>=
static void
freepair(Node *n)
{
    regfree(n->left);
    regfree(n->right);
}
@

<<function loadpair>>=
/* n is not OREGPAIR, nn is */
void
loadpair(Node *n, Node *nn)
{
    Node nod;

    instpair(nn, Z);
    if(n->op == OCONST) {
        gins(AMOVL, lo64(n), nn->left);
        n->xoffset += SZ_LONG;
        gins(AMOVL, hi64(n), nn->right);
        n->xoffset -= SZ_LONG;
        return;
    }
    if(!vaddr(n, 0)) {
        /* steal the right register for the laddr */
        nod = regnode;
        nod.reg = nn->right->reg;
        lcgen(n, &nod);
        n = &nod;
        regind(n, n);
        n->xoffset = 0;
    }
    gins(AMOVL, n, nn->left);
    n->xoffset += SZ_LONG;
    gins(AMOVL, n, nn->right);
    n->xoffset -= SZ_LONG;
}
@

<<function storepair>>=
/* n is OREGPAIR, nn is not */
static void
storepair(Node *n, Node *nn, int f)
{
    Node nod;

    if(!vaddr(nn, 0)) {
        reglcgen(&nod, nn, Z);
        nn = &nod;
    }
    gins(AMOVL, n->left, nn);
    nn->xoffset += SZ_LONG;
    gins(AMOVL, n->right, nn);
    nn->xoffset -= SZ_LONG;
    if(nn == &nod)
        regfree(&nod);
    if(f)
        freepair(n);
}
@

<<enum _anon_ (8c/cgen64.c)>>=
enum
{
/* 4 only, see WW */
    WNONE	= 0,
    WCONST,
    WADDR,
    WHARD,
};
@

<<function whatof>>=
static int
whatof(Node *n, int a)
{
    if(n->op == OCONST)
        return WCONST;
    return !vaddr(n, a) ? WHARD : WADDR;
}
@

<<function reduxv>>=
/* can upgrade an extern to addr for AND */
static int
reduxv(Node *n)
{
    return lo64v(n) == 0 || hi64v(n) == 0;
}
@

<<function cond>>=
int
cond(int op)
{
    switch(op) {
    case OANDAND:
    case OOROR:
    case ONOT:
        return 1;

    case OEQ:
    case ONE:
    case OLE:
    case OLT:
    case OGE:
    case OGT:
    case OHI:
    case OHS:
    case OLO:
    case OLS:
        return 1;
    }
    return 0;
}
@

<<function vfunc>>=
/*
 * for a func operand call it and then return
 * the safe node
 */
static Node *
vfunc(Node *n, Node *nn)
{
    Node *t;

    if(n->op != OFUNC)
        return n;
    t = new(0, Z, Z);
    if(nn == Z || nn == nodret)
        nn = n;
    regsalloc(t, nn);
    sugen(n, t, 8);
    return t;
}
@

<<function getreg>>=
/* try to steal a reg */
static int
getreg(Node **np, Node *t, int r)
{
    Node *n, *p;

    n = *np;
    if(n->reg == r) {
        p = new(0, Z, Z);
        regalloc(p, n, Z);
        gins(AMOVL, n, p);
        *t = *n;
        *np = p;
        return 1;
    }
    return 0;
}
@

<<function snarfreg>>=
static Node *
snarfreg(Node *n, Node *t, int r, Node *d, Node *c)
{
    if(n == Z || n->op != OREGPAIR || (!getreg(&n->left, t, r) && !getreg(&n->right, t, r))) {
        if(nodreg(t, Z, r)) {
            regalloc(c, d, Z);
            gins(AMOVL, t, c);
            reg[r]++;
            return c;
        }
        reg[r]++;
    }
    return Z;
}
@

<<enum _anon_ (8c/cgen64.c)2>>=
enum
{
    Vstart	= OEND,

    Vgo,
    Vamv,
    Vmv,
    Vzero,
    Vop,
    Vopx,
    Vins,
    Vins0,
    Vinsl,
    Vinsr,
    Vinsla,
    Vinsra,
    Vinsx,
    Vmul,
    Vshll,
    VT,
    VF,
    V_l_lo_f,
    V_l_hi_f,
    V_l_lo_t,
    V_l_hi_t,
    V_l_lo_u,
    V_l_hi_u,
    V_r_lo_f,
    V_r_hi_f,
    V_r_lo_t,
    V_r_hi_t,
    V_r_lo_u,
    V_r_hi_u,
    Vspazz,
    Vend,

    V_T0,
    V_T1,
    V_F0,
    V_F1,

    V_a0,
    V_a1,
    V_f0,
    V_f1,

    V_p0,
    V_p1,
    V_p2,
    V_p3,
    V_p4,

    V_s0,
    V_s1,
    V_s2,
    V_s3,
    V_s4,

    C00,
    C01,
    C31,
    C32,

    O_l_lo,
    O_l_hi,
    O_r_lo,
    O_r_hi,
    O_t_lo,
    O_t_hi,
    O_l,
    O_r,
    O_l_rp,
    O_r_rp,
    O_t_rp,
    O_r0,
    O_r1,
    O_Zop,

    O_a0,
    O_a1,

    V_C0,
    V_C1,

    V_S0,
    V_S1,

    VOPS	= 5,
    VLEN	= 5,
    VARGS	= 2,

    S00	= 0,
    Sc0,
    Sc1,
    Sc2,
    Sac3,
    Sac4,
    S10,

    SAgen	= 0,
    SAclo,
    SAc32,
    SAchi,
    SAdgen,
    SAdclo,
    SAdc32,
    SAdchi,

    B0c	= 0,
    Bca,
    Bac,

    T0i	= 0,
    Tii,

    Bop0	= 0,
    Bop1,
};
@

<<global testi>>=
/*
 * _testv:
 * 	CMPL	lo,$0
 * 	JNE	true
 * 	CMPL	hi,$0
 * 	JNE	true
 * 	GOTO	false
 * false:
 * 	GOTO	code
 * true:
 * 	GOTO	patchme
 * code:
 */

static uchar	testi[][VLEN] =
{
    {Vop, ONE, O_l_lo, C00},
    {V_s0, Vop, ONE, O_l_hi, C00},
    {V_s1, Vgo, V_s2, Vgo, V_s3},
    {VF, V_p0, V_p1, VT, V_p2},
    {Vgo, V_p3},
    {VT, V_p0, V_p1, VF, V_p2},
    {Vend},
};
@

<<global shll00>>=
/* shift left general case */
static uchar	shll00[][VLEN] =
{
    {Vop, OGE, O_r, C32},
    {V_s0, Vinsl, ASHLL, O_r, O_l_rp},
    {Vins, ASHLL, O_r, O_l_lo, Vgo},
    {V_p0, V_s0},
    {Vins, ASHLL, O_r, O_l_lo},
    {Vins, AMOVL, O_l_lo, O_l_hi},
    {Vzero, O_l_lo, V_p0, Vend},
};
@

<<global shllc0>>=
/* shift left rp, const < 32 */
static uchar	shllc0[][VLEN] =
{
    {Vinsl, ASHLL, O_r, O_l_rp},
    {Vshll, O_r, O_l_lo, Vend},
};
@

<<global shllc1>>=
/* shift left rp, const == 32 */
static uchar	shllc1[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_l_hi},
    {Vzero, O_l_lo, Vend},
};
@

<<global shllc2>>=
/* shift left rp, const > 32 */
static uchar	shllc2[][VLEN] =
{
    {Vshll, O_r, O_l_lo},
    {Vins, AMOVL, O_l_lo, O_l_hi},
    {Vzero, O_l_lo, Vend},
};
@

<<global shllac3>>=
/* shift left addr, const == 32 */
static uchar	shllac3[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_hi},
    {Vzero, O_t_lo, Vend},
};
@

<<global shllac4>>=
/* shift left addr, const > 32 */
static uchar	shllac4[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_hi},
    {Vshll, O_r, O_t_hi},
    {Vzero, O_t_lo, Vend},
};
@

<<global shll10>>=
/* shift left of constant */
static uchar	shll10[][VLEN] =
{
    {Vop, OGE, O_r, C32},
    {V_s0, Vins, AMOVL, O_l_lo, O_t_lo},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {Vinsl, ASHLL, O_r, O_t_rp},
    {Vins, ASHLL, O_r, O_t_lo, Vgo},
    {V_p0, V_s0},
    {Vins, AMOVL, O_l_lo, O_t_hi},
    {V_l_lo_t, Vins, ASHLL, O_r, O_t_hi},
    {Vzero, O_t_lo, V_p0, Vend},
};
@

<<global shlltab>>=
static uchar	(*shlltab[])[VLEN] =
{
    shll00,
    shllc0,
    shllc1,
    shllc2,
    shllac3,
    shllac4,
    shll10,
};
@

<<global shrl00>>=
/* shift right general case */
static uchar	shrl00[][VLEN] =
{
    {Vop, OGE, O_r, C32},
    {V_s0, Vinsr, ASHRL, O_r, O_l_rp},
    {Vins, O_a0, O_r, O_l_hi, Vgo},
    {V_p0, V_s0},
    {Vins, O_a0, O_r, O_l_hi},
    {Vins, AMOVL, O_l_hi, O_l_lo},
    {V_T1, Vzero, O_l_hi},
    {V_F1, Vins, ASARL, C31, O_l_hi},
    {V_p0, Vend},
};
@

<<global shrlc0>>=
/* shift right rp, const < 32 */
static uchar	shrlc0[][VLEN] =
{
    {Vinsr, ASHRL, O_r, O_l_rp},
    {Vins, O_a0, O_r, O_l_hi, Vend},
};
@

<<global shrlc1>>=
/* shift right rp, const == 32 */
static uchar	shrlc1[][VLEN] =
{
    {Vins, AMOVL, O_l_hi, O_l_lo},
    {V_T1, Vzero, O_l_hi},
    {V_F1, Vins, ASARL, C31, O_l_hi},
    {Vend},
};
@

<<global shrlc2>>=
/* shift right rp, const > 32 */
static uchar	shrlc2[][VLEN] =
{
    {Vins, O_a0, O_r, O_l_hi},
    {Vins, AMOVL, O_l_hi, O_l_lo},
    {V_T1, Vzero, O_l_hi},
    {V_F1, Vins, ASARL, C31, O_l_hi},
    {Vend},
};
@

<<global shrlac3>>=
/* shift right addr, const == 32 */
static uchar	shrlac3[][VLEN] =
{
    {Vins, AMOVL, O_l_hi, O_t_lo},
    {V_T1, Vzero, O_t_hi},
    {V_F1, Vins, AMOVL, O_t_lo, O_t_hi},
    {V_F1, Vins, ASARL, C31, O_t_hi},
    {Vend},
};
@

<<global shrlac4>>=
/* shift right addr, const > 32 */
static uchar	shrlac4[][VLEN] =
{
    {Vins, AMOVL, O_l_hi, O_t_lo},
    {Vins, O_a0, O_r, O_t_lo},
    {V_T1, Vzero, O_t_hi},
    {V_F1, Vins, AMOVL, O_t_lo, O_t_hi},
    {V_F1, Vins, ASARL, C31, O_t_hi},
    {Vend},
};
@

<<global shrl10>>=
/* shift right of constant */
static uchar	shrl10[][VLEN] =
{
    {Vop, OGE, O_r, C32},
    {V_s0, Vins, AMOVL, O_l_lo, O_t_lo},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {Vinsr, ASHRL, O_r, O_t_rp},
    {Vins, O_a0, O_r, O_t_hi, Vgo},
    {V_p0, V_s0},
    {Vins, AMOVL, O_l_hi, O_t_lo},
    {V_l_hi_t, Vins, O_a0, O_r, O_t_lo},
    {V_l_hi_u, V_S1},
    {V_T1, Vzero, O_t_hi, V_p0},
    {V_F1, Vins, AMOVL, O_t_lo, O_t_hi},
    {V_F1, Vins, ASARL, C31, O_t_hi},
    {Vend},
};
@

<<global shrltab>>=
static uchar	(*shrltab[])[VLEN] =
{
    shrl00,
    shrlc0,
    shrlc1,
    shrlc2,
    shrlac3,
    shrlac4,
    shrl10,
};
@

<<global asshllgen>>=
/* shift asop left general case */
static uchar	asshllgen[][VLEN] =
{
    {V_a0, V_a1},
    {Vop, OGE, O_r, C32},
    {V_s0, Vins, AMOVL, O_l_lo, O_r0},
    {Vins, AMOVL, O_l_hi, O_r1},
    {Vinsla, ASHLL, O_r, O_r0},
    {Vins, ASHLL, O_r, O_r0},
    {Vins, AMOVL, O_r1, O_l_hi},
    {Vins, AMOVL, O_r0, O_l_lo, Vgo},
    {V_p0, V_s0},
    {Vins, AMOVL, O_l_lo, O_r0},
    {Vzero, O_l_lo},
    {Vins, ASHLL, O_r, O_r0},
    {Vins, AMOVL, O_r0, O_l_hi, V_p0},
    {V_f0, V_f1, Vend},
};
@

<<global asshllclo>>=
/* shift asop left, const < 32 */
static uchar	asshllclo[][VLEN] =
{
    {V_a0, V_a1},
    {Vins, AMOVL, O_l_lo, O_r0},
    {Vins, AMOVL, O_l_hi, O_r1},
    {Vinsla, ASHLL, O_r, O_r0},
    {Vshll, O_r, O_r0},
    {Vins, AMOVL, O_r1, O_l_hi},
    {Vins, AMOVL, O_r0, O_l_lo},
    {V_f0, V_f1, Vend},
};
@

<<global asshllc32>>=
/* shift asop left, const == 32 */
static uchar	asshllc32[][VLEN] =
{
    {V_a0},
    {Vins, AMOVL, O_l_lo, O_r0},
    {Vzero, O_l_lo},
    {Vins, AMOVL, O_r0, O_l_hi},
    {V_f0, Vend},
};
@

<<global asshllchi>>=
/* shift asop left, const > 32 */
static uchar	asshllchi[][VLEN] =
{
    {V_a0},
    {Vins, AMOVL, O_l_lo, O_r0},
    {Vzero, O_l_lo},
    {Vshll, O_r, O_r0},
    {Vins, AMOVL, O_r0, O_l_hi},
    {V_f0, Vend},
};
@

<<global asdshllgen>>=
/* shift asop dest left general case */
static uchar	asdshllgen[][VLEN] =
{
    {Vop, OGE, O_r, C32},
    {V_s0, Vins, AMOVL, O_l_lo, O_t_lo},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {Vinsl, ASHLL, O_r, O_t_rp},
    {Vins, ASHLL, O_r, O_t_lo},
    {Vins, AMOVL, O_t_hi, O_l_hi},
    {Vins, AMOVL, O_t_lo, O_l_lo, Vgo},
    {V_p0, V_s0},
    {Vins, AMOVL, O_l_lo, O_t_hi},
    {Vzero, O_l_lo},
    {Vins, ASHLL, O_r, O_t_hi},
    {Vzero, O_t_lo},
    {Vins, AMOVL, O_t_hi, O_l_hi, V_p0},
    {Vend},
};
@

<<global asdshllclo>>=
/* shift asop dest left, const < 32 */
static uchar	asdshllclo[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_lo},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {Vinsl, ASHLL, O_r, O_t_rp},
    {Vshll, O_r, O_t_lo},
    {Vins, AMOVL, O_t_hi, O_l_hi},
    {Vins, AMOVL, O_t_lo, O_l_lo},
    {Vend},
};
@

<<global asdshllc32>>=
/* shift asop dest left, const == 32 */
static uchar	asdshllc32[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_hi},
    {Vzero, O_t_lo},
    {Vins, AMOVL, O_t_hi, O_l_hi},
    {Vins, AMOVL, O_t_lo, O_l_lo},
    {Vend},
};
@

<<global asdshllchi>>=
/* shift asop dest, const > 32 */
static uchar	asdshllchi[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_hi},
    {Vzero, O_t_lo},
    {Vshll, O_r, O_t_hi},
    {Vins, AMOVL, O_t_lo, O_l_lo},
    {Vins, AMOVL, O_t_hi, O_l_hi},
    {Vend},
};
@

<<global asshlltab>>=
static uchar	(*asshlltab[])[VLEN] =
{
    asshllgen,
    asshllclo,
    asshllc32,
    asshllchi,
    asdshllgen,
    asdshllclo,
    asdshllc32,
    asdshllchi,
};
@

<<global asshrlgen>>=
/* shift asop right general case */
static uchar	asshrlgen[][VLEN] =
{
    {V_a0, V_a1},
    {Vop, OGE, O_r, C32},
    {V_s0, Vins, AMOVL, O_l_lo, O_r0},
    {Vins, AMOVL, O_l_hi, O_r1},
    {Vinsra, ASHRL, O_r, O_r0},
    {Vinsx, Bop0, O_r, O_r1},
    {Vins, AMOVL, O_r0, O_l_lo},
    {Vins, AMOVL, O_r1, O_l_hi, Vgo},
    {V_p0, V_s0},
    {Vins, AMOVL, O_l_hi, O_r0},
    {Vinsx, Bop0, O_r, O_r0},
    {V_T1, Vzero, O_l_hi},
    {Vins, AMOVL, O_r0, O_l_lo},
    {V_F1, Vins, ASARL, C31, O_r0},
    {V_F1, Vins, AMOVL, O_r0, O_l_hi},
    {V_p0, V_f0, V_f1, Vend},
};
@

<<global asshrlclo>>=
/* shift asop right, const < 32 */
static uchar	asshrlclo[][VLEN] =
{
    {V_a0, V_a1},
    {Vins, AMOVL, O_l_lo, O_r0},
    {Vins, AMOVL, O_l_hi, O_r1},
    {Vinsra, ASHRL, O_r, O_r0},
    {Vinsx, Bop0, O_r, O_r1},
    {Vins, AMOVL, O_r0, O_l_lo},
    {Vins, AMOVL, O_r1, O_l_hi},
    {V_f0, V_f1, Vend},
};
@

<<global asshrlc32>>=
/* shift asop right, const == 32 */
static uchar	asshrlc32[][VLEN] =
{
    {V_a0},
    {Vins, AMOVL, O_l_hi, O_r0},
    {V_T1, Vzero, O_l_hi},
    {Vins, AMOVL, O_r0, O_l_lo},
    {V_F1, Vins, ASARL, C31, O_r0},
    {V_F1, Vins, AMOVL, O_r0, O_l_hi},
    {V_f0, Vend},
};
@

<<global asshrlchi>>=
/* shift asop right, const > 32 */
static uchar	asshrlchi[][VLEN] =
{
    {V_a0},
    {Vins, AMOVL, O_l_hi, O_r0},
    {V_T1, Vzero, O_l_hi},
    {Vinsx, Bop0, O_r, O_r0},
    {Vins, AMOVL, O_r0, O_l_lo},
    {V_F1, Vins, ASARL, C31, O_r0},
    {V_F1, Vins, AMOVL, O_r0, O_l_hi},
    {V_f0, Vend},
};
@

<<global asdshrlgen>>=
/* shift asop dest right general case */
static uchar	asdshrlgen[][VLEN] =
{
    {Vop, OGE, O_r, C32},
    {V_s0, Vins, AMOVL, O_l_lo, O_t_lo},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {Vinsr, ASHRL, O_r, O_t_rp},
    {Vinsx, Bop0, O_r, O_t_hi},
    {Vins, AMOVL, O_t_lo, O_l_lo},
    {Vins, AMOVL, O_t_hi, O_l_hi, Vgo},
    {V_p0, V_s0},
    {Vins, AMOVL, O_l_hi, O_t_lo},
    {V_T1, Vzero, O_t_hi},
    {Vinsx, Bop0, O_r, O_t_lo},
    {V_F1, Vins, AMOVL, O_t_lo, O_t_hi},
    {V_F1, Vins, ASARL, C31, O_t_hi},
    {Vins, AMOVL, O_t_hi, O_l_hi, V_p0},
    {Vend},
};
@

<<global asdshrlclo>>=
/* shift asop dest right, const < 32 */
static uchar	asdshrlclo[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_lo},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {Vinsr, ASHRL, O_r, O_t_rp},
    {Vinsx, Bop0, O_r, O_t_hi},
    {Vins, AMOVL, O_t_lo, O_l_lo},
    {Vins, AMOVL, O_t_hi, O_l_hi},
    {Vend},
};
@

<<global asdshrlc32>>=
/* shift asop dest right, const == 32 */
static uchar	asdshrlc32[][VLEN] =
{
    {Vins, AMOVL, O_l_hi, O_t_lo},
    {V_T1, Vzero, O_t_hi},
    {V_F1, Vins, AMOVL, O_t_lo, O_t_hi},
    {V_F1, Vins, ASARL, C31, O_t_hi},
    {Vins, AMOVL, O_t_lo, O_l_lo},
    {Vins, AMOVL, O_t_hi, O_l_hi},
    {Vend},
};
@

<<global asdshrlchi>>=
/* shift asop dest, const > 32 */
static uchar	asdshrlchi[][VLEN] =
{
    {Vins, AMOVL, O_l_hi, O_t_lo},
    {V_T1, Vzero, O_t_hi},
    {Vinsx, Bop0, O_r, O_t_lo},
    {V_T1, Vins, AMOVL, O_t_hi, O_l_hi},
    {V_T1, Vins, AMOVL, O_t_lo, O_l_lo},
    {V_F1, Vins, AMOVL, O_t_lo, O_t_hi},
    {V_F1, Vins, ASARL, C31, O_t_hi},
    {V_F1, Vins, AMOVL, O_t_lo, O_l_lo},
    {V_F1, Vins, AMOVL, O_t_hi, O_l_hi},
    {Vend},
};
@

<<global asshrltab>>=
static uchar	(*asshrltab[])[VLEN] =
{
    asshrlgen,
    asshrlclo,
    asshrlc32,
    asshrlchi,
    asdshrlgen,
    asdshrlclo,
    asdshrlc32,
    asdshrlchi,
};
@

<<global shrlargs>>=
static uchar	shrlargs[]	= { ASHRL, 1 };
@

<<global sarlargs>>=
static uchar	sarlargs[]	= { ASARL, 0 };
@

<<global incdec>>=
/* ++ -- */
static uchar	incdec[][VLEN] =
{
    {Vinsx, Bop0, C01, O_l_lo},
    {Vinsx, Bop1, C00, O_l_hi, Vend},
};
@

<<global incdecpre>>=
/* ++ -- *p */
static uchar	incdecpre[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_lo},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {Vinsx, Bop0, C01, O_t_lo},
    {Vinsx, Bop1, C00, O_t_hi},
    {Vins, AMOVL, O_t_lo, O_l_lo},
    {Vins, AMOVL, O_t_hi, O_l_hi, Vend},
};
@

<<global incdecpost>>=
/* *p ++ -- */
static uchar	incdecpost[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_lo},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {Vinsx, Bop0, C01, O_l_lo},
    {Vinsx, Bop1, C00, O_l_hi, Vend},
};
@

<<global binop00>>=
/* binop rp, rp */
static uchar	binop00[][VLEN] =
{
    {Vinsx, Bop0, O_r_lo, O_l_lo},
    {Vinsx, Bop1, O_r_hi, O_l_hi, Vend},
    {Vend},
};
@

<<global binoptmp>>=
/* binop rp, addr */
static uchar	binoptmp[][VLEN] =
{
    {V_a0, Vins, AMOVL, O_r_lo, O_r0},
    {Vinsx, Bop0, O_r0, O_l_lo},
    {Vins, AMOVL, O_r_hi, O_r0},
    {Vinsx, Bop1, O_r0, O_l_hi},
    {V_f0, Vend},
};
@

<<global binop11>>=
/* binop t = *a op *b */
static uchar	binop11[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_lo},
    {Vinsx, Bop0, O_r_lo, O_t_lo},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {Vinsx, Bop1, O_r_hi, O_t_hi, Vend},
};
@

<<global add0c>>=
/* binop t = rp +- c */
static uchar	add0c[][VLEN] =
{
    {V_r_lo_t, Vinsx, Bop0, O_r_lo, O_l_lo},
    {V_r_lo_f, Vamv, Bop0, Bop1},
    {Vinsx, Bop1, O_r_hi, O_l_hi},
    {Vend},
};
@

<<global and0c>>=
/* binop t = rp & c */
static uchar	and0c[][VLEN] =
{
    {V_r_lo_t, Vinsx, Bop0, O_r_lo, O_l_lo},
    {V_r_lo_f, Vins, AMOVL, C00, O_l_lo},
    {V_r_hi_t, Vinsx, Bop1, O_r_hi, O_l_hi},
    {V_r_hi_f, Vins, AMOVL, C00, O_l_hi},
    {Vend},
};
@

<<global or0c>>=
/* binop t = rp | c */
static uchar	or0c[][VLEN] =
{
    {V_r_lo_t, Vinsx, Bop0, O_r_lo, O_l_lo},
    {V_r_hi_t, Vinsx, Bop1, O_r_hi, O_l_hi},
    {Vend},
};
@

<<global sub10>>=
/* binop t = c - rp */
static uchar	sub10[][VLEN] =
{
    {V_a0, Vins, AMOVL, O_l_lo, O_r0},
    {Vinsx, Bop0, O_r_lo, O_r0},
    {Vins, AMOVL, O_l_hi, O_r_lo},
    {Vinsx, Bop1, O_r_hi, O_r_lo},
    {Vspazz, V_f0, Vend},
};
@

<<global addca>>=
/* binop t = c + *b */
static uchar	addca[][VLEN] =
{
    {Vins, AMOVL, O_r_lo, O_t_lo},
    {V_l_lo_t, Vinsx, Bop0, O_l_lo, O_t_lo},
    {V_l_lo_f, Vamv, Bop0, Bop1},
    {Vins, AMOVL, O_r_hi, O_t_hi},
    {Vinsx, Bop1, O_l_hi, O_t_hi},
    {Vend},
};
@

<<global andca>>=
/* binop t = c & *b */
static uchar	andca[][VLEN] =
{
    {V_l_lo_t, Vins, AMOVL, O_r_lo, O_t_lo},
    {V_l_lo_t, Vinsx, Bop0, O_l_lo, O_t_lo},
    {V_l_lo_f, Vzero, O_t_lo},
    {V_l_hi_t, Vins, AMOVL, O_r_hi, O_t_hi},
    {V_l_hi_t, Vinsx, Bop1, O_l_hi, O_t_hi},
    {V_l_hi_f, Vzero, O_t_hi},
    {Vend},
};
@

<<global orca>>=
/* binop t = c | *b */
static uchar	orca[][VLEN] =
{
    {Vins, AMOVL, O_r_lo, O_t_lo},
    {V_l_lo_t, Vinsx, Bop0, O_l_lo, O_t_lo},
    {Vins, AMOVL, O_r_hi, O_t_hi},
    {V_l_hi_t, Vinsx, Bop1, O_l_hi, O_t_hi},
    {Vend},
};
@

<<global subca>>=
/* binop t = c - *b */
static uchar	subca[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_lo},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {Vinsx, Bop0, O_r_lo, O_t_lo},
    {Vinsx, Bop1, O_r_hi, O_t_hi},
    {Vend},
};
@

<<global addac>>=
/* binop t = *a +- c */
static uchar	addac[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_lo},
    {V_r_lo_t, Vinsx, Bop0, O_r_lo, O_t_lo},
    {V_r_lo_f, Vamv, Bop0, Bop1},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {Vinsx, Bop1, O_r_hi, O_t_hi},
    {Vend},
};
@

<<global orac>>=
/* binop t = *a | c */
static uchar	orac[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_lo},
    {V_r_lo_t, Vinsx, Bop0, O_r_lo, O_t_lo},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {V_r_hi_t, Vinsx, Bop1, O_r_hi, O_t_hi},
    {Vend},
};
@

<<global andac>>=
/* binop t = *a & c */
static uchar	andac[][VLEN] =
{
    {V_r_lo_t, Vins, AMOVL, O_l_lo, O_t_lo},
    {V_r_lo_t, Vinsx, Bop0, O_r_lo, O_t_lo},
    {V_r_lo_f, Vzero, O_t_lo},
    {V_r_hi_t, Vins, AMOVL, O_l_hi, O_t_hi},
    {V_r_hi_t, Vinsx, Bop0, O_r_hi, O_t_hi},
    {V_r_hi_f, Vzero, O_t_hi},
    {Vend},
};
@

<<global ADDargs>>=
static uchar	ADDargs[]	= { AADDL, AADCL };
@

<<global ANDargs>>=
static uchar	ANDargs[]	= { AANDL, AANDL };
@

<<global ORargs>>=
static uchar	ORargs[]	= { AORL, AORL };
@

<<global SUBargs>>=
static uchar	SUBargs[]	= { ASUBL, ASBBL };
@

<<global XORargs>>=
static uchar	XORargs[]	= { AXORL, AXORL };
@

<<global ADDtab>>=
static uchar	(*ADDtab[])[VLEN] =
{
    add0c, addca, addac,
};
@

<<global ANDtab>>=
static uchar	(*ANDtab[])[VLEN] =
{
    and0c, andca, andac,
};
@

<<global ORtab>>=
static uchar	(*ORtab[])[VLEN] =
{
    or0c, orca, orac,
};
@

<<global SUBtab>>=
static uchar	(*SUBtab[])[VLEN] =
{
    add0c, subca, addac,
};
@

<<global mulc32>>=
/* mul of const32 */
static uchar	mulc32[][VLEN] =
{
    {V_a0, Vop, ONE, O_l_hi, C00},
    {V_s0, Vins, AMOVL, O_r_lo, O_r0},
    {Vins, AMULL, O_r0, O_Zop},
    {Vgo, V_p0, V_s0},
    {Vins, AMOVL, O_l_hi, O_r0},
    {Vmul, O_r_lo, O_r0},
    {Vins, AMOVL, O_r_lo, O_l_hi},
    {Vins, AMULL, O_l_hi, O_Zop},
    {Vins, AADDL, O_r0, O_l_hi},
    {V_f0, V_p0, Vend},
};
@

<<global mulc64>>=
/* mul of const64 */
static uchar	mulc64[][VLEN] =
{
    {V_a0, Vins, AMOVL, O_r_hi, O_r0},
    {Vop, OOR, O_l_hi, O_r0},
    {Vop, ONE, O_r0, C00},
    {V_s0, Vins, AMOVL, O_r_lo, O_r0},
    {Vins, AMULL, O_r0, O_Zop},
    {Vgo, V_p0, V_s0},
    {Vmul, O_r_lo, O_l_hi},
    {Vins, AMOVL, O_l_lo, O_r0},
    {Vmul, O_r_hi, O_r0},
    {Vins, AADDL, O_l_hi, O_r0},
    {Vins, AMOVL, O_r_lo, O_l_hi},
    {Vins, AMULL, O_l_hi, O_Zop},
    {Vins, AADDL, O_r0, O_l_hi},
    {V_f0, V_p0, Vend},
};
@

<<global mull>>=
/* mul general */
static uchar	mull[][VLEN] =
{
    {V_a0, Vins, AMOVL, O_r_hi, O_r0},
    {Vop, OOR, O_l_hi, O_r0},
    {Vop, ONE, O_r0, C00},
    {V_s0, Vins, AMOVL, O_r_lo, O_r0},
    {Vins, AMULL, O_r0, O_Zop},
    {Vgo, V_p0, V_s0},
    {Vins, AIMULL, O_r_lo, O_l_hi},
    {Vins, AMOVL, O_l_lo, O_r0},
    {Vins, AIMULL, O_r_hi, O_r0},
    {Vins, AADDL, O_l_hi, O_r0},
    {Vins, AMOVL, O_r_lo, O_l_hi},
    {Vins, AMULL, O_l_hi, O_Zop},
    {Vins, AADDL, O_r0, O_l_hi},
    {V_f0, V_p0, Vend},
};
@

<<global castrp>>=
/* cast rp l to rp t */
static uchar	castrp[][VLEN] =
{
    {Vmv, O_l, O_t_lo},
    {VT, Vins, AMOVL, O_t_lo, O_t_hi},
    {VT, Vins, ASARL, C31, O_t_hi},
    {VF, Vzero, O_t_hi},
    {Vend},
};
@

<<global castrpa>>=
/* cast rp l to addr t */
static uchar	castrpa[][VLEN] =
{
    {VT, V_a0, Vmv, O_l, O_r0},
    {VT, Vins, AMOVL, O_r0, O_t_lo},
    {VT, Vins, ASARL, C31, O_r0},
    {VT, Vins, AMOVL, O_r0, O_t_hi},
    {VT, V_f0},
    {VF, Vmv, O_l, O_t_lo},
    {VF, Vzero, O_t_hi},
    {Vend},
};
@

<<global netab0i>>=
static uchar	netab0i[][VLEN] =
{
    {Vop, ONE, O_l_lo, O_r_lo},
    {V_s0, Vop, ONE, O_l_hi, O_r_hi},
    {V_s1, Vgo, V_s2, Vgo, V_s3},
    {VF, V_p0, V_p1, VT, V_p2},
    {Vgo, V_p3},
    {VT, V_p0, V_p1, VF, V_p2},
    {Vend},
};
@

<<global netabii>>=
static uchar	netabii[][VLEN] =
{
    {V_a0, Vins, AMOVL, O_l_lo, O_r0},
    {Vop, ONE, O_r0, O_r_lo},
    {V_s0, Vins, AMOVL, O_l_hi, O_r0},
    {Vop, ONE, O_r0, O_r_hi},
    {V_s1, Vgo, V_s2, Vgo, V_s3},
    {VF, V_p0, V_p1, VT, V_p2},
    {Vgo, V_p3},
    {VT, V_p0, V_p1, VF, V_p2},
    {V_f0, Vend},
};
@

<<global cmptab0i>>=
static uchar	cmptab0i[][VLEN] =
{
    {Vopx, Bop0, O_l_hi, O_r_hi},
    {V_s0, Vins0, AJNE},
    {V_s1, Vopx, Bop1, O_l_lo, O_r_lo},
    {V_s2, Vgo, V_s3, Vgo, V_s4},
    {VT, V_p1, V_p3},
    {VF, V_p0, V_p2},
    {Vgo, V_p4},
    {VT, V_p0, V_p2},
    {VF, V_p1, V_p3},
    {Vend},
};
@

<<global cmptabii>>=
static uchar	cmptabii[][VLEN] =
{
    {V_a0, Vins, AMOVL, O_l_hi, O_r0},
    {Vopx, Bop0, O_r0, O_r_hi},
    {V_s0, Vins0, AJNE},
    {V_s1, Vins, AMOVL, O_l_lo, O_r0},
    {Vopx, Bop1, O_r0, O_r_lo},
    {V_s2, Vgo, V_s3, Vgo, V_s4},
    {VT, V_p1, V_p3},
    {VF, V_p0, V_p2},
    {Vgo, V_p4},
    {VT, V_p0, V_p2},
    {VF, V_p1, V_p3},
    {V_f0, Vend},
};
@

<<global NEtab>>=
static uchar	(*NEtab[])[VLEN] =
{
    netab0i, netabii,
};
@

<<global cmptab>>=
static uchar	(*cmptab[])[VLEN] =
{
    cmptab0i, cmptabii,
};
@

<<global GEargs>>=
static uchar	GEargs[]	= { OGT, OHS };
@

<<global GTargs>>=
static uchar	GTargs[]	= { OGT, OHI };
@

<<global HIargs>>=
static uchar	HIargs[]	= { OHI, OHI };
@

<<global HSargs>>=
static uchar	HSargs[]	= { OHI, OHS };
@

<<function biggen>>=
/* Big Generator */
static void
biggen(Node *l, Node *r, Node *t, int true, uchar code[][VLEN], uchar *a)
{
    int i, j, g, oc, op, lo, ro, to, xo, *xp;
    Type *lt;
    Prog *pr[VOPS];
    Node *ot, *tl, *tr, tmps[2];
    uchar *c, (*cp)[VLEN], args[VARGS];

    if(a != nil)
        memmove(args, a, VARGS);
//print("biggen %d %d %d\n", args[0], args[1], args[2]);
//if(l) prtree(l, "l");
//if(r) prtree(r, "r");
//if(t) prtree(t, "t");
    lo = ro = to = 0;
    cp = code;

    for (;;) {
        c = *cp++;
        g = 1;
        i = 0;
//print("code %d %d %d %d %d\n", c[0], c[1], c[2], c[3], c[4]);
        for(;;) {
            switch(op = c[i]) {
            case Vgo:
                if(g)
                    gbranch(OGOTO);
                i++;
                break;

            case Vamv:
                i += 3;
                if(i > VLEN) {
                    diag(l, "bad Vop");
                    return;
                }
                if(g)
                    args[c[i - 1]] = args[c[i - 2]];
                break;

            case Vzero:
                i += 2;
                if(i > VLEN) {
                    diag(l, "bad Vop");
                    return;
                }
                j = i - 1;
                goto op;

            case Vspazz:	// nasty hack to save a reg in SUB
//print("spazz\n");
                if(g) {
//print("hi %R lo %R t %R\n", r->right->reg, r->left->reg, tmps[0].reg);
                    ot = r->right;
                    r->right = r->left;
                    tl = new(0, Z, Z);
                    *tl = tmps[0];
                    r->left = tl;
                    tmps[0] = *ot;
//print("hi %R lo %R t %R\n", r->right->reg, r->left->reg, tmps[0].reg);
                }
                i++;
                break;

            case Vmv:
            case Vmul:
            case Vshll:
                i += 3;
                if(i > VLEN) {
                    diag(l, "bad Vop");
                    return;
                }
                j = i - 2;
                goto op;

            case Vins0:
                i += 2;
                if(i > VLEN) {
                    diag(l, "bad Vop");
                    return;
                }
                gins(c[i - 1], Z, Z);
                break;

            case Vop:
            case Vopx:
            case Vins:
            case Vinsl:
            case Vinsr:
            case Vinsla:
            case Vinsra:
            case Vinsx:
                i += 4;
                if(i > VLEN) {
                    diag(l, "bad Vop");
                    return;
                }
                j = i - 2;
                goto op;

            op:
                if(!g)
                    break;
                tl = Z;
                tr = Z;
                for(; j < i; j++) {
                    switch(c[j]) {
                    case C00:
                        ot = nodconst(0);
                        break;
                    case C01:
                        ot = nodconst(1);
                        break;
                    case C31:
                        ot = nodconst(31);
                        break;
                    case C32:
                        ot = nodconst(32);
                        break;

                    case O_l:
                    case O_l_lo:
                        ot = l; xp = &lo; xo = 0;
                        goto op0;
                    case O_l_hi:
                        ot = l; xp = &lo; xo = SZ_LONG;
                        goto op0;
                    case O_r:
                    case O_r_lo:
                        ot = r; xp = &ro; xo = 0;
                        goto op0;
                    case O_r_hi:
                        ot = r; xp = &ro; xo = SZ_LONG;
                        goto op0;
                    case O_t_lo:
                        ot = t; xp = &to; xo = 0;
                        goto op0;
                    case O_t_hi:
                        ot = t; xp = &to; xo = SZ_LONG;
                        goto op0;
                    case O_l_rp:
                        ot = l;
                        break;
                    case O_r_rp:
                        ot = r;
                        break;
                    case O_t_rp:
                        ot = t;
                        break;
                    case O_r0:
                    case O_r1:
                        ot = &tmps[c[j] - O_r0];
                        break;
                    case O_Zop:
                        ot = Z;
                        break;

                    op0:
                        switch(ot->op) {
                        case OCONST:
                            if(xo)
                                ot = hi64(ot);
                            else
                                ot = lo64(ot);
                            break;
                        case OREGPAIR:
                            if(xo)
                                ot = ot->right;
                            else
                                ot = ot->left;
                            break;
                        case OREGISTER:
                            break;
                        default:
                            if(xo != *xp) {
                                ot->xoffset += xo - *xp;
                                *xp = xo;
                            }
                        }
                        break;
                    
                    default:
                        diag(l, "bad V_lop");
                        return;
                    }
                    if(tl == nil)
                        tl = ot;
                    else
                        tr = ot;
                }
                if(op == Vzero) {
                    zeroregm(tl);
                    break;
                }
                oc = c[i - 3];
                if(op == Vinsx || op == Vopx) {
//print("%d -> %d\n", oc, args[oc]);
                    oc = args[oc];
                }
                else {
                    switch(oc) {
                    case O_a0:
                    case O_a1:
                        oc = args[oc - O_a0];
                        break;
                    }
                }
                switch(op) {
                case Vmul:
                    mulgen(tr->type, tl, tr);
                    break;
                case Vmv:
                    gmove(tl, tr);
                    break;
                case Vshll:
                    shiftit(tr->type, tl, tr);
                    break;
                case Vop:
                case Vopx:
                    gopcode(oc, types[TULONG], tl, tr);
                    break;
                case Vins:
                case Vinsx:
                    gins(oc, tl, tr);
                    break;
                case Vinsl:
                    gins(oc, tl, tr->right);
                    p->from.index = tr->left->reg;
                    break;
                case Vinsr:
                    gins(oc, tl, tr->left);
                    p->from.index = tr->right->reg;
                    break;
                case Vinsla:
                    gins(oc, tl, tr + 1);
                    p->from.index = tr->reg;
                    break;
                case Vinsra:
                    gins(oc, tl, tr);
                    p->from.index = (tr + 1)->reg;
                    break;
                }
                break;

            case VT:
                g = true;
                i++;
                break;
            case VF:
                g = !true;
                i++;
                break;

            case V_T0: case V_T1:
                g = args[op - V_T0];
                i++;
                break;

            case V_F0: case V_F1:
                g = !args[op - V_F0];
                i++;
                break;

            case V_C0: case V_C1:
                if(g)
                    args[op - V_C0] = 0;
                i++;
                break;

            case V_S0: case V_S1:
                if(g)
                    args[op - V_S0] = 1;
                i++;
                break;

            case V_l_lo_f:
                g = lo64v(l) == 0;
                i++;
                break;
            case V_l_hi_f:
                g = hi64v(l) == 0;
                i++;
                break;
            case V_l_lo_t:
                g = lo64v(l) != 0;
                i++;
                break;
            case V_l_hi_t:
                g = hi64v(l) != 0;
                i++;
                break;
            case V_l_lo_u:
                g = lo64v(l) >= 0;
                i++;
                break;
            case V_l_hi_u:
                g = hi64v(l) >= 0;
                i++;
                break;
            case V_r_lo_f:
                g = lo64v(r) == 0;
                i++;
                break;
            case V_r_hi_f:
                g = hi64v(r) == 0;
                i++;
                break;
            case V_r_lo_t:
                g = lo64v(r) != 0;
                i++;
                break;
            case V_r_hi_t:
                g = hi64v(r) != 0;
                i++;
                break;
            case V_r_lo_u:
                g = lo64v(r) >= 0;
                i++;
                break;
            case V_r_hi_u:
                g = hi64v(r) >= 0;
                i++;
                break;

            case Vend:
                goto out;

            case V_a0: case V_a1:
                if(g) {
                    lt = l->type;
                    l->type = types[TULONG];
                    regalloc(&tmps[op - V_a0], l, Z);
                    l->type = lt;
                }
                i++;
                break;

            case V_f0: case V_f1:
                if(g)
                    regfree(&tmps[op - V_f0]);
                i++;
                break;

            case V_p0: case V_p1: case V_p2: case V_p3: case V_p4:
                if(g)
                    patch(pr[op - V_p0], pc);
                i++;
                break;

            case V_s0: case V_s1: case V_s2: case V_s3: case V_s4:
                if(g)
                    pr[op - V_s0] = p;
                i++;
                break;

            default:
                diag(l, "bad biggen: %d", op);
                return;
            }
            if(i == VLEN || c[i] == 0)
                break;
        }
    }
out:
    if(lo)
        l->xoffset -= lo;
    if(ro)
        r->xoffset -= ro;
    if(to)
        t->xoffset -= to;
}
@

<<function IMM>>=
#define	IMM(l, r)	((l) | ((r) << 1))
@

<<function WW>>=
#define	WW(l, r)	((l) | ((r) << 2))
@

<<function cgen64>>=
int
cgen64(Node *n, Node *nn)
{
    Type *dt;
    uchar *args, (*cp)[VLEN], (**optab)[VLEN];
    int li, ri, lri, dr, si, m, op, sh, cmp, true;
    Node *c, *d, *l, *r, *t, *s, nod1, nod2, nod3, nod4, nod5;

    if(debug['g']) {
        prtree(nn, "cgen64 lhs");
        prtree(n, "cgen64");
        print("AX = %d\n", reg[D_AX]);
    }
    cmp = 0;
    sh = 0;

    switch(n->op) {
    case ONEG:
        d = regpair(nn, n);
        sugen(n->left, d, 8);
        gins(ANOTL, Z, d->right);
        gins(ANEGL, Z, d->left);
        gins(ASBBL, nodconst(-1), d->right);
        break;

    case OCOM:
        if(!vaddr(n->left, 0) || !vaddr(nn, 0))
            d = regpair(nn, n);
        else
            return 0;
        sugen(n->left, d, 8);
        gins(ANOTL, Z, d->left);
        gins(ANOTL, Z, d->right);
        break;

    case OADD:
        optab = ADDtab;
        args = ADDargs;
        goto twoop;
    case OAND:
        optab = ANDtab;
        args = ANDargs;
        goto twoop;
    case OOR:
        optab = ORtab;
        args = ORargs;
        goto twoop;
    case OSUB:
        optab = SUBtab;
        args = SUBargs;
        goto twoop;
    case OXOR:
        optab = ORtab;
        args = XORargs;
        goto twoop;
    case OASHL:
        sh = 1;
        args = nil;
        optab = shlltab;
        goto twoop;
    case OLSHR:
        sh = 1;
        args = shrlargs;
        optab = shrltab;
        goto twoop;
    case OASHR:
        sh = 1;
        args = sarlargs;
        optab = shrltab;
        goto twoop;
    case OEQ:
        cmp = 1;
        args = nil;
        optab = nil;
        goto twoop;
    case ONE:
        cmp = 1;
        args = nil;
        optab = nil;
        goto twoop;
    case OLE:
        cmp = 1;
        args = nil;
        optab = nil;
        goto twoop;
    case OLT:
        cmp = 1;
        args = nil;
        optab = nil;
        goto twoop;
    case OGE:
        cmp = 1;
        args = nil;
        optab = nil;
        goto twoop;
    case OGT:
        cmp = 1;
        args = nil;
        optab = nil;
        goto twoop;
    case OHI:
        cmp = 1;
        args = nil;
        optab = nil;
        goto twoop;
    case OHS:
        cmp = 1;
        args = nil;
        optab = nil;
        goto twoop;
    case OLO:
        cmp = 1;
        args = nil;
        optab = nil;
        goto twoop;
    case OLS:
        cmp = 1;
        args = nil;
        optab = nil;
        goto twoop;

twoop:
        dr = nn != Z && nn->op == OREGPAIR;
        l = vfunc(n->left, nn);
        if(sh)
            r = n->right;
        else
            r = vfunc(n->right, nn);

        li = l->op == ONAME || l->op == OINDREG || l->op == OCONST;
        ri = r->op == ONAME || r->op == OINDREG || r->op == OCONST;


        lri = IMM(li, ri);

        /* find out what is so easy about some operands */
        if(li)
            li = whatof(l, sh | cmp);
        if(ri)
            ri = whatof(r, cmp);

        if(sh)
            goto shift;

        if(cmp)
            goto cmp;

        /* evaluate hard subexps, stealing nn if possible. */
        switch(lri) {
        case IMM(0, 0):
        bin00:
            if(l->complex > r->complex) {
                if(dr)
                    t = nn;
                else
                    t = regpair(Z, n);
                sugen(l, t, 8);
                l = t;
                t = regpair(Z, n);
                sugen(r, t, 8);
                r = t;
            }
            else {
                t = regpair(Z, n);
                sugen(r, t, 8);
                r = t;
                if(dr)
                    t = nn;
                else
                    t = regpair(Z, n);
                sugen(l, t, 8);
                l = t;
            }
            break;
        case IMM(0, 1):
            if(dr)
                t = nn;
            else
                t = regpair(Z, n);
            sugen(l, t, 8);
            l = t;
            break;
        case IMM(1, 0):
            if(n->op == OSUB && l->op == OCONST && hi64v(l) == 0) {
                lri = IMM(0, 0);
                goto bin00;
            }
            if(dr)
                t = nn;
            else
                t = regpair(Z, n);
            sugen(r, t, 8);
            r = t;
            break;
        case IMM(1, 1):
            break;
        }

        d = Z;
        dt = nn->type;
        nn->type = types[TLONG];

        switch(lri) {
        case IMM(0, 0):
            biggen(l, r, Z, 0, binop00, args);
            break;
        case IMM(0, 1):
            switch(ri) {
            case WNONE:
                diag(r, "bad whatof\n");
                break;
            case WCONST:
                biggen(l, r, Z, 0, optab[B0c], args);
                break;
            case WHARD:
                reglcgen(&nod2, r, Z);
                r = &nod2;
                /* fall thru */
            case WADDR:
                biggen(l, r, Z, 0, binoptmp, args);
                if(ri == WHARD)
                    regfree(r);
                break;
            }
            break;
        case IMM(1, 0):
            if(n->op == OSUB) {
                switch(li) {
                case WNONE:
                    diag(l, "bad whatof\n");
                    break;
                case WHARD:
                    reglcgen(&nod2, l, Z);
                    l = &nod2;
                    /* fall thru */
                case WADDR:
                case WCONST:
                    biggen(l, r, Z, 0, sub10, args);
                    break;
                }
                if(li == WHARD)
                    regfree(l);
            }
            else {
                switch(li) {
                case WNONE:
                    diag(l, "bad whatof\n");
                    break;
                case WCONST:
                    biggen(r, l, Z, 0, optab[B0c], args);
                    break;
                case WHARD:
                    reglcgen(&nod2, l, Z);
                    l = &nod2;
                    /* fall thru */
                case WADDR:
                    biggen(r, l, Z, 0, binoptmp, args);
                    if(li == WHARD)
                        regfree(l);
                    break;
                }
            }
            break;
        case IMM(1, 1):
            switch(WW(li, ri)) {
            case WW(WCONST, WHARD):
                if(r->op == ONAME && n->op == OAND && reduxv(l))
                    ri = WADDR;
                break;
            case WW(WHARD, WCONST):
                if(l->op == ONAME && n->op == OAND && reduxv(r))
                    li = WADDR;
                break;
            }
            if(li == WHARD) {
                reglcgen(&nod3, l, Z);
                l = &nod3;
            }
            if(ri == WHARD) {
                reglcgen(&nod2, r, Z);
                r = &nod2;
            }
            d = regpair(nn, n);
            instpair(d, Z);
            switch(WW(li, ri)) {
            case WW(WCONST, WADDR):
            case WW(WCONST, WHARD):
                biggen(l, r, d, 0, optab[Bca], args);
                break;

            case WW(WADDR, WCONST):
            case WW(WHARD, WCONST):
                biggen(l, r, d, 0, optab[Bac], args);
                break;

            case WW(WADDR, WADDR):
            case WW(WADDR, WHARD):
            case WW(WHARD, WADDR):
            case WW(WHARD, WHARD):
                biggen(l, r, d, 0, binop11, args);
                break;

            default:
                diag(r, "bad whatof pair %d %d\n", li, ri);
                break;
            }
            if(li == WHARD)
                regfree(l);
            if(ri == WHARD)
                regfree(r);
            break;
        }

        nn->type = dt;

        if(d != Z)
            goto finished;

        switch(lri) {
        case IMM(0, 0):
            freepair(r);
            /* fall thru */;
        case IMM(0, 1):
            if(!dr)
                storepair(l, nn, 1);
            break;
        case IMM(1, 0):
            if(!dr)
                storepair(r, nn, 1);
            break;
        case IMM(1, 1):
            break;
        }
        return 1;

    shift:
        c = Z;

        /* evaluate hard subexps, stealing nn if possible. */
        /* must also secure CX.  not as many optims as binop. */
        switch(lri) {
        case IMM(0, 0):
        imm00:
            if(l->complex + 1 > r->complex) {
                if(dr)
                    t = nn;
                else
                    t = regpair(Z, l);
                sugen(l, t, 8);
                l = t;
                t = &nod1;
                c = snarfreg(l, t, D_CX, r, &nod2);
                cgen(r, t);
                r = t;
            }
            else {
                t = &nod1;
                c = snarfreg(nn, t, D_CX, r, &nod2);
                cgen(r, t);
                r = t;
                if(dr)
                    t = nn;
                else
                    t = regpair(Z, l);
                sugen(l, t, 8);
                l = t;
            }
            break;
        case IMM(0, 1):
        imm01:
            if(ri != WCONST) {
                lri = IMM(0, 0);
                goto imm00;
            }
            if(dr)
                t = nn;
            else
                t = regpair(Z, n);
            sugen(l, t, 8);
            l = t;
            break;
        case IMM(1, 0):
        imm10:
            if(li != WCONST) {
                lri = IMM(0, 0);
                goto imm00;
            }
            t = &nod1;
            c = snarfreg(nn, t, D_CX, r, &nod2);
            cgen(r, t);
            r = t;
            break;
        case IMM(1, 1):
            if(ri != WCONST) {
                lri = IMM(1, 0);
                goto imm10;
            }
            if(li == WHARD) {
                lri = IMM(0, 1);
                goto imm01;
            }
            break;
        }

        d = Z;

        switch(lri) {
        case IMM(0, 0):
            biggen(l, r, Z, 0, optab[S00], args);
            break;
        case IMM(0, 1):
            switch(ri) {
            case WNONE:
            case WADDR:
            case WHARD:
                diag(r, "bad whatof\n");
                break;
            case WCONST:
                m = r->vconst & 63;
                s = nodconst(m);
                if(m < 32)
                    cp = optab[Sc0];
                else if(m == 32)
                    cp = optab[Sc1];
                else
                    cp = optab[Sc2];
                biggen(l, s, Z, 0, cp, args);
                break;
            }
            break;
        case IMM(1, 0):
            /* left is const */
            d = regpair(nn, n);
            instpair(d, Z);
            biggen(l, r, d, 0, optab[S10], args);
            regfree(r);
            break;
        case IMM(1, 1):
            d = regpair(nn, n);
            instpair(d, Z);
            switch(WW(li, ri)) {
            case WW(WADDR, WCONST):
                m = r->vconst & 63;
                s = nodconst(m);
                if(m < 32) {
                    loadpair(l, d);
                    l = d;
                    cp = optab[Sc0];
                }
                else if(m == 32)
                    cp = optab[Sac3];
                else
                    cp = optab[Sac4];
                biggen(l, s, d, 0, cp, args);
                break;

            default:
                diag(r, "bad whatof pair %d %d\n", li, ri);
                break;
            }
            break;
        }

        if(c != Z) {
            gins(AMOVL, c, r);
            regfree(c);
        }

        if(d != Z)
            goto finished;

        switch(lri) {
        case IMM(0, 0):
            regfree(r);
            /* fall thru */
        case IMM(0, 1):
            if(!dr)
                storepair(l, nn, 1);
            break;
        case IMM(1, 0):
            regfree(r);
            break;
        case IMM(1, 1):
            break;
        }
        return 1;

    cmp:
        op = n->op;
        /* evaluate hard subexps */
        switch(lri) {
        case IMM(0, 0):
            if(l->complex > r->complex) {
                t = regpair(Z, l);
                sugen(l, t, 8);
                l = t;
                t = regpair(Z, r);
                sugen(r, t, 8);
                r = t;
            }
            else {
                t = regpair(Z, r);
                sugen(r, t, 8);
                r = t;
                t = regpair(Z, l);
                sugen(l, t, 8);
                l = t;
            }
            break;
        case IMM(1, 0):
            t = r;
            r = l;
            l = t;
            ri = li;
            op = invrel[relindex(op)];
            /* fall thru */
        case IMM(0, 1):
            t = regpair(Z, l);
            sugen(l, t, 8);
            l = t;
            break;
        case IMM(1, 1):
            break;
        }

        true = 1;
        optab = cmptab;
        switch(op) {
        case OEQ:
            optab = NEtab;
            true = 0;
            break;
        case ONE:
            optab = NEtab;
            break;
        case OLE:
            args = GTargs;
            true = 0;
            break;
        case OGT:
            args = GTargs;
            break;
        case OLS:
            args = HIargs;
            true = 0;
            break;
        case OHI:
            args = HIargs;
            break;
        case OLT:
            args = GEargs;
            true = 0;
            break;
        case OGE:
            args = GEargs;
            break;
        case OLO:
            args = HSargs;
            true = 0;
            break;
        case OHS:
            args = HSargs;
            break;
        default:
            diag(n, "bad cmp\n");
            SET(optab);
        }

        switch(lri) {
        case IMM(0, 0):
            biggen(l, r, Z, true, optab[T0i], args);
            break;
        case IMM(0, 1):
        case IMM(1, 0):
            switch(ri) {
            case WNONE:
                diag(l, "bad whatof\n");
                break;
            case WCONST:
                biggen(l, r, Z, true, optab[T0i], args);
                break;
            case WHARD:
                reglcgen(&nod2, r, Z);
                r = &nod2;
                /* fall thru */
            case WADDR:
                biggen(l, r, Z, true, optab[T0i], args);
                if(ri == WHARD)
                    regfree(r);
                break;
            }
            break;
        case IMM(1, 1):
            if(li == WHARD) {
                reglcgen(&nod3, l, Z);
                l = &nod3;
            }
            if(ri == WHARD) {
                reglcgen(&nod2, r, Z);
                r = &nod2;
            }
            biggen(l, r, Z, true, optab[Tii], args);
            if(li == WHARD)
                regfree(l);
            if(ri == WHARD)
                regfree(r);
            break;
        }

        switch(lri) {
        case IMM(0, 0):
            freepair(r);
            /* fall thru */;
        case IMM(0, 1):
        case IMM(1, 0):
            freepair(l);
            break;
        case IMM(1, 1):
            break;
        }
        return 1;

    case OASMUL:
    case OASLMUL:
        m = 0;
        goto mulop;

    case OMUL:
    case OLMUL:
        m = 1;
        goto mulop;

    mulop:
        dr = nn != Z && nn->op == OREGPAIR;
        l = vfunc(n->left, nn);
        r = vfunc(n->right, nn);
        if(r->op != OCONST) {
            if(l->complex > r->complex) {
                if(m) {
                    t = l;
                    l = r;
                    r = t;
                }
                else if(!vaddr(l, 1)) {
                    reglcgen(&nod5, l, Z);
                    l = &nod5;
                    evacaxdx(l);
                }
            }
            t = regpair(Z, n);
            sugen(r, t, 8);
            r = t;
            evacaxdx(r->left);
            evacaxdx(r->right);
            if(l->complex <= r->complex && !m && !vaddr(l, 1)) {
                reglcgen(&nod5, l, Z);
                l = &nod5;
                evacaxdx(l);
            }
        }
        if(dr)
            t = nn;
        else
            t = regpair(Z, n);
        //print("dr=%d ", dr); prtree(t, "t");
        c = Z;
        d = Z;
        if(!nodreg(&nod1, t->left, D_AX)) {
            if(t->left->reg != D_AX){
                t->left->reg = D_AX;
                reg[D_AX]++;
            }else if(reg[D_AX] == 0)
                fatal(Z, "vlong mul AX botch");
        }
        if(!nodreg(&nod2, t->right, D_DX)) {
            if(t->right->reg != D_DX){
                t->right->reg = D_DX;
                reg[D_DX]++;
            }else if(reg[D_DX] == 0)
                fatal(Z, "vlong mul DX botch");
        }
        //prtree(t, "t1"); print("reg/ax = %d reg/dx = %d\n", reg[D_AX], reg[D_DX]);
        if(m)
            sugen(l, t, 8);
        else
            loadpair(l, t);
        //prtree(t, "t2"); print("reg/ax = %d reg/dx = %d\n", reg[D_AX], reg[D_DX]);
        if(t->left->reg != D_AX) {
            c = &nod3;
            regsalloc(c, t->left);
            gmove(&nod1, c);
            gmove(t->left, &nod1);
            zapreg(t->left);
        }
        //print("reg/ax = %d reg/dx = %d\n", reg[D_AX], reg[D_DX]);
        if(t->right->reg != D_DX) {
            d = &nod4;
            regsalloc(d, t->right);
            gmove(&nod2, d);
            if(t->right->reg == D_AX && c != nil){
                /* need previous value of AX in DX */
                gmove(c, &nod2);
            }else
                gmove(t->right, &nod2);
            zapreg(t->right);
        }
        if(c != Z || d != Z) {
            s = regpair(Z, n);
            s->left = &nod1;
            s->right = &nod2;
        }
        else
            s = t;
        reg[D_AX]++;	/* don't allow biggen to allocate AX or DX (smashed by MUL) as temp */
        reg[D_DX]++;
        if(r->op == OCONST) {
            if(hi64v(r) == 0)
                biggen(s, r, Z, 0, mulc32, nil);
            else
                biggen(s, r, Z, 0, mulc64, nil);
        }
        else
            biggen(s, r, Z, 0, mull, nil);
        instpair(t, Z);
        reg[D_AX]--;
        reg[D_DX]--;
        if(c != Z) {
            gmove(&nod1, t->left);
            gmove(&nod3, &nod1);
        }
        if(d != Z) {
            gmove(&nod2, t->right);
            gmove(&nod4, &nod2);
        }

        if(r->op == OREGPAIR)
            freepair(r);
        if(!m)
            storepair(t, l, 0);
        if(l == &nod5)
            regfree(l);

        if(!dr) {
            if(nn != Z)
                storepair(t, nn, 1);
            else
                freepair(t);
        }
        return 1;

    case OASADD:
        args = ADDargs;
        goto vasop;
    case OASAND:
        args = ANDargs;
        goto vasop;
    case OASOR:
        args = ORargs;
        goto vasop;
    case OASSUB:
        args = SUBargs;
        goto vasop;
    case OASXOR:
        args = XORargs;
        goto vasop;

    vasop:
        l = n->left;
        r = n->right;
        dr = nn != Z && nn->op == OREGPAIR;
        m = 0;
        if(l->complex > r->complex) {
            if(!vaddr(l, 1)) {
                reglcgen(&nod1, l, Z);
                l = &nod1;
            }
            if(!vaddr(r, 1) || nn != Z || r->op == OCONST) {
                if(dr)
                    t = nn;
                else
                    t = regpair(Z, r);
                sugen(r, t, 8);
                r = t;
                m = 1;
            }
        }
        else {
            if(!vaddr(r, 1) || nn != Z || r->op == OCONST) {
                if(dr)
                    t = nn;
                else
                    t = regpair(Z, r);
                sugen(r, t, 8);
                r = t;
                m = 1;
            }
            if(!vaddr(l, 1)) {
                reglcgen(&nod1, l, Z);
                l = &nod1;
            }
        }
        if(nn != Z) {
            if(n->op == OASSUB)
                biggen(l, r, Z, 0, sub10, args);
            else
                biggen(r, l, Z, 0, binoptmp, args);
            storepair(r, l, 0);
        }
        else {
            if(m)
                biggen(l, r, Z, 0, binop00, args);
            else
                biggen(l, r, Z, 0, binoptmp, args);
        }
        if(l == &nod1)
            regfree(&nod1);
        if(m) {
            if(nn == Z)
                freepair(r);
            else if(!dr)
                storepair(r, nn, 1);
        }
        return 1;

    case OASASHL:
        args = nil;
        optab = asshlltab;
        goto assh;
    case OASLSHR:
        args = shrlargs;
        optab = asshrltab;
        goto assh;
    case OASASHR:
        args = sarlargs;
        optab = asshrltab;
        goto assh;

    assh:
        c = Z;
        l = n->left;
        r = n->right;
        if(r->op == OCONST) {
            m = r->vconst & 63;
            if(m < 32)
                m = SAclo;
            else if(m == 32)
                m = SAc32;
            else
                m = SAchi;
        }
        else
            m = SAgen;
        if(l->complex > r->complex) {
            if(!vaddr(l, 0)) {
                reglcgen(&nod1, l, Z);
                l = &nod1;
            }
            if(m == SAgen) {
                t = &nod2;
                if(l->reg == D_CX) {
                    regalloc(t, r, Z);
                    gmove(l, t);
                    l->reg = t->reg;
                    t->reg = D_CX;
                }
                else
                    c = snarfreg(nn, t, D_CX, r, &nod3);
                cgen(r, t);
                r = t;
            }
        }
        else {
            if(m == SAgen) {
                t = &nod2;
                c = snarfreg(nn, t, D_CX, r, &nod3);
                cgen(r, t);
                r = t;
            }
            if(!vaddr(l, 0)) {
                reglcgen(&nod1, l, Z);
                l = &nod1;
            }
        }

        if(nn != Z) {
            m += SAdgen - SAgen;
            d = regpair(nn, n);
            instpair(d, Z);
            biggen(l, r, d, 0, optab[m], args);
            if(l == &nod1) {
                regfree(&nod1);
                l = Z;
            }
            if(r == &nod2 && c == Z) {
                regfree(&nod2);
                r = Z;
            }
            if(d != nn)
                storepair(d, nn, 1);
        }
        else
            biggen(l, r, Z, 0, optab[m], args);

        if(c != Z) {
            gins(AMOVL, c, r);
            regfree(c);
        }
        if(l == &nod1)
            regfree(&nod1);
        if(r == &nod2)
            regfree(&nod2);
        return 1;

    case OPOSTINC:
        args = ADDargs;
        cp = incdecpost;
        goto vinc;
    case OPOSTDEC:
        args = SUBargs;
        cp = incdecpost;
        goto vinc;
    case OPREINC:
        args = ADDargs;
        cp = incdecpre;
        goto vinc;
    case OPREDEC:
        args = SUBargs;
        cp = incdecpre;
        goto vinc;

    vinc:
        l = n->left;
        if(!vaddr(l, 1)) {
            reglcgen(&nod1, l, Z);
            l = &nod1;
        }
        
        if(nn != Z) {
            d = regpair(nn, n);
            instpair(d, Z);
            biggen(l, Z, d, 0, cp, args);
            if(l == &nod1) {
                regfree(&nod1);
                l = Z;
            }
            if(d != nn)
                storepair(d, nn, 1);
        }
        else
            biggen(l, Z, Z, 0, incdec, args);

        if(l == &nod1)
            regfree(&nod1);
        return 1;

    case OCAST:
        l = n->left;
        if(typev[l->type->etype]) {
            if(!vaddr(l, 1)) {
                if(l->complex + 1 > nn->complex) {
                    d = regpair(Z, l);
                    sugen(l, d, 8);
                    if(!vaddr(nn, 1)) {
                        reglcgen(&nod1, nn, Z);
                        r = &nod1;
                    }
                    else
                        r = nn;
                }
                else {
                    if(!vaddr(nn, 1)) {
                        reglcgen(&nod1, nn, Z);
                        r = &nod1;
                    }
                    else
                        r = nn;
                    d = regpair(Z, l);
                    sugen(l, d, 8);
                }
//				d->left->type = r->type;
                d->left->type = types[TLONG];
                gmove(d->left, r);
                freepair(d);
            }
            else {
                if(nn->op != OREGISTER && !vaddr(nn, 1)) {
                    reglcgen(&nod1, nn, Z);
                    r = &nod1;
                }
                else
                    r = nn;
//				l->type = r->type;
                l->type = types[TLONG];
                gmove(l, r);
            }
            if(r != nn)
                regfree(r);
        }
        else {
            if(typeu[l->type->etype] || cond(l->op))
                si = TUNSIGNED;
            else
                si = TSIGNED;
            regalloc(&nod1, l, Z);
            cgen(l, &nod1);
            if(nn->op == OREGPAIR) {
                m = instpair(nn, &nod1);
                biggen(&nod1, Z, nn, si == TSIGNED, castrp, nil);
            }
            else {
                m = 0;
                if(!vaddr(nn, si != TSIGNED)) {
                    dt = nn->type;
                    nn->type = types[TLONG];
                    reglcgen(&nod2, nn, Z);
                    nn->type = dt;
                    nn = &nod2;
                }
                dt = nn->type;
                nn->type = types[TLONG];
                biggen(&nod1, Z, nn, si == TSIGNED, castrpa, nil);
                nn->type = dt;
                if(nn == &nod2)
                    regfree(&nod2);
            }
            if(!m)
                regfree(&nod1);
        }
        return 1;

    default:
        if(n->op == OREGPAIR) {
            storepair(n, nn, 1);
            return 1;
        }
        if(nn->op == OREGPAIR) {
            loadpair(n, nn);
            return 1;
        }
        return 0;
    }
finished:
    if(d != nn)
        storepair(d, nn, 1);
    return 1;
}
@

<<function testv>>=
void
testv(Node *n, int true)
{
    Type *t;
    Node *nn, nod, *b;

    if(machcap(Z)) {
        b = &nod;
        b->op = true ? ONE : OEQ;
        b->left = n;
        b->right = new(0, Z, Z);
        *b->right = *nodconst(0);
        b->right->type = n->type;
        b->type = types[TLONG];
        cgen64(b, Z);
        return;
    }

    switch(n->op) {
    case OINDREG:
    case ONAME:
        biggen(n, Z, Z, true, testi, nil);
        break;

    default:
        n = vfunc(n, n);
        if(n->addable >= INDEXED) {
            t = n->type;
            n->type = types[TLONG];
            reglcgen(&nod, n, Z);
            n->type = t;
            n = &nod;
            biggen(n, Z, Z, true, testi, nil);
            if(n == &nod)
                regfree(n);
        }
        else {
            nn = regpair(Z, n);
            sugen(n, nn, 8);
            biggen(nn, Z, Z, true, testi, nil);
            freepair(nn);
        }
    }
}
@


%-------------------------------------------------------------

<<8c/cgen64.c>>=
#include "gc.h"

<<function zeroregm>>

<<function vaddr>>

<<function hi64v>>

<<function lo64v>>

<<function hi64>>

<<function lo64>>

<<function anonreg>>

<<function regpair>>

<<function evacaxdx>>

<<function instpair>>

<<function zapreg>>

<<function freepair>>

<<function loadpair>>

<<function storepair>>

<<enum _anon_ (8c/cgen64.c)>>

<<function whatof>>

<<function reduxv>>

<<function cond>>

<<function vfunc>>

<<function getreg>>

<<function snarfreg>>

<<enum _anon_ (8c/cgen64.c)2>>

<<global testi>>

<<global shll00>>

<<global shllc0>>

<<global shllc1>>

<<global shllc2>>

<<global shllac3>>

<<global shllac4>>

<<global shll10>>

<<global shlltab>>

<<global shrl00>>

<<global shrlc0>>

<<global shrlc1>>

<<global shrlc2>>

<<global shrlac3>>

<<global shrlac4>>

<<global shrl10>>

<<global shrltab>>

<<global asshllgen>>

<<global asshllclo>>

<<global asshllc32>>

<<global asshllchi>>

<<global asdshllgen>>

<<global asdshllclo>>

<<global asdshllc32>>

<<global asdshllchi>>

<<global asshlltab>>

<<global asshrlgen>>

<<global asshrlclo>>

<<global asshrlc32>>

<<global asshrlchi>>

<<global asdshrlgen>>

<<global asdshrlclo>>

<<global asdshrlc32>>

<<global asdshrlchi>>

<<global asshrltab>>

<<global shrlargs>>
<<global sarlargs>>

<<global incdec>>

<<global incdecpre>>

<<global incdecpost>>

<<global binop00>>

<<global binoptmp>>

<<global binop11>>

<<global add0c>>

<<global and0c>>

<<global or0c>>

<<global sub10>>

<<global addca>>

<<global andca>>

<<global orca>>

<<global subca>>

<<global addac>>

<<global orac>>

<<global andac>>

<<global ADDargs>>
<<global ANDargs>>
<<global ORargs>>
<<global SUBargs>>
<<global XORargs>>

<<global ADDtab>>

<<global ANDtab>>

<<global ORtab>>

<<global SUBtab>>

<<global mulc32>>

<<global mulc64>>

<<global mull>>

<<global castrp>>

<<global castrpa>>

<<global netab0i>>

<<global netabii>>

<<global cmptab0i>>

<<global cmptabii>>

<<global NEtab>>

<<global cmptab>>

<<global GEargs>>
<<global GTargs>>
<<global HIargs>>
<<global HSargs>>

<<function biggen>>

<<function IMM>>

<<function WW>>

<<function cgen64>>

<<function testv>>
@


\subsection*{[[8c/div.c]]}

<<function TN>>=
/*
 * Based on: Granlund, T.; Montgomery, P.L.
 * "Division by Invariant Integers using Multiplication".
 * SIGPLAN Notices, Vol. 29, June 1994, page 61.
 */

#define	TN(n)	((uvlong)1 << (n))
@
% >>

<<constant T31>>=
#define	T31	TN(31)
@

<<constant T32>>=
#define	T32	TN(32)
@

<<function multiplier>>=
int
multiplier(ulong d, int p, uvlong *mp)
{
    int l;
    uvlong mlo, mhi, tlo, thi;

    l = topbit(d - 1) + 1;
    mlo = (((TN(l) - d) << 32) / d) + T32;
    if(l + p == 64)
        mhi = (((TN(l) + 1 - d) << 32) / d) + T32;
    else
        mhi = (TN(32 + l) + TN(32 + l - p)) / d;
    assert(mlo < mhi);
    while(l > 0) {
        tlo = mlo >> 1;
        thi = mhi >> 1;
        if(tlo == thi)
            break;
        mlo = tlo;
        mhi = thi;
        l--;
    }
    *mp = mhi;
    return l;
}
@

<<function sdiv>>=
int
sdiv(ulong d, ulong *mp, int *sp)
{
    int s;
    uvlong m;

    s = multiplier(d, 32 - 1, &m);
    *mp = m;
    *sp = s;
    if(m >= T31)
        return 1;
    else
        return 0;
}
@

<<function udiv>>=
int
udiv(ulong d, ulong *mp, int *sp, int *pp)
{
    int p, s;
    uvlong m;

    s = multiplier(d, 32, &m);
    p = 0;
    if(m >= T32) {
        while((d & 1) == 0) {
            d >>= 1;
            p++;
        }
        s = multiplier(d, 32 - p, &m);
    }
    *mp = m;
    *pp = p;
    if(m >= T32) {
        assert(p == 0);
        *sp = s - 1;
        return 1;
    }
    else {
        *sp = s;
        return 0;
    }
}
@

<<function sdivgen>>=
void
sdivgen(Node *l, Node *r, Node *ax, Node *dx)
{
    int a, s;
    ulong m;
    vlong c;

    c = r->vconst;
    if(c < 0)
        c = -c;
    a = sdiv(c, &m, &s);
//print("a=%d i=%ld s=%d m=%lux\n", a, (long)r->vconst, s, m);
    gins(AMOVL, nodconst(m), ax);
    gins(AIMULL, l, Z);
    gins(AMOVL, l, ax);
    if(a)
        gins(AADDL, ax, dx);
    gins(ASHRL, nodconst(31), ax);
    gins(ASARL, nodconst(s), dx);
    gins(AADDL, ax, dx);
    if(r->vconst < 0)
        gins(ANEGL, Z, dx);
}
@

<<function udivgen>>=
void
udivgen(Node *l, Node *r, Node *ax, Node *dx)
{
    int a, s, t;
    ulong m;
    Node nod;

    a = udiv(r->vconst, &m, &s, &t);
//print("a=%ud i=%ld p=%d s=%d m=%lux\n", a, (long)r->vconst, t, s, m);
    if(t != 0) {
        gins(AMOVL, l, ax);
        gins(ASHRL, nodconst(t), ax);
        gins(AMOVL, nodconst(m), dx);
        gins(AMULL, dx, Z);
    }
    else if(a) {
        if(l->op != OREGISTER) {
            regalloc(&nod, l, Z);
            gins(AMOVL, l, &nod);
            l = &nod;
        }
        gins(AMOVL, nodconst(m), ax);
        gins(AMULL, l, Z);
        gins(AADDL, l, dx);
        gins(ARCRL, nodconst(1), dx);
        if(l == &nod)
            regfree(l);
    }
    else {
        gins(AMOVL, nodconst(m), ax);
        gins(AMULL, l, Z);
    }
    if(s != 0)
        gins(ASHRL, nodconst(s), dx);
}
@

<<function sext>>=
void
sext(Node *d, Node *s, Node *l)
{
    if(s->reg == D_AX && !nodreg(d, Z, D_DX)) {
        reg[D_DX]++;
        gins(ACDQ, Z, Z);
    }
    else {
        regalloc(d, l, Z);
        gins(AMOVL, s, d);
        gins(ASARL, nodconst(31), d);
    }
}
@

<<function sdiv2>>=
void
sdiv2(long c, int v, Node *l, Node *n)
{
    Node nod;

    if(v > 0) {
        if(v > 1) {
            sext(&nod, n, l);
            gins(AANDL, nodconst((1 << v) - 1), &nod);
            gins(AADDL, &nod, n);
            regfree(&nod);
        }
        else {
            gins(ACMPL, n, nodconst(0x80000000));
            gins(ASBBL, nodconst(-1), n);
        }
        gins(ASARL, nodconst(v), n);
    }
    if(c < 0)
        gins(ANEGL, Z, n);
}
@

<<function smod2>>=
void
smod2(long c, int v, Node *l, Node *n)
{
    Node nod;

    if(c == 1) {
        zeroregm(n);
        return;
    }

    sext(&nod, n, l);
    if(v == 0) {
        zeroregm(n);
        gins(AXORL, &nod, n);
        gins(ASUBL, &nod, n);
    }
    else if(v > 1) {
        gins(AANDL, nodconst((1 << v) - 1), &nod);
        gins(AADDL, &nod, n);
        gins(AANDL, nodconst((1 << v) - 1), n);
        gins(ASUBL, &nod, n);
    }
    else {
        gins(AANDL, nodconst(1), n);
        gins(AXORL, &nod, n);
        gins(ASUBL, &nod, n);
    }
    regfree(&nod);
}
@


%-------------------------------------------------------------

<<8c/div.c>>=
#include "gc.h"

<<function TN>>
<<constant T31>>
<<constant T32>>

<<function multiplier>>

<<function sdiv>>

<<function udiv>>

<<function sdivgen>>

<<function udivgen>>

<<function sext>>

<<function sdiv2>>

<<function smod2>>
@


\subsection*{[[8c/cgen.c]]}

<<function cgen>>=
/* ,x/^(print|prtree)\(/i/\/\/ */

void
cgen(Node *n, Node *nn)
{
    Node *l, *r, *t;
    Prog *p1;
    Node nod, nod1, nod2, nod3, nod4;
    int o, hardleft;
    long v, curs;
    vlong c;

    if(debug['g']) {
        prtree(nn, "cgen lhs");
        prtree(n, "cgen");
    }
    if(n == Z || n->type == T)
        return;
    if(typesuv[n->type->etype]) {
        sugen(n, nn, n->type->width);
        return;
    }
    l = n->left;
    r = n->right;
    o = n->op;
// Go's version does the following, but it's the wrong place: doesn't allow assignment
//	if(o == OEXREG || nn != Z && nn->op == OEXREG) {
//		gmove(n, nn);
//		return;
//	}

    if(n->addable >= INDEXED) {
        if(nn == Z) {
            switch(o) {
            default:
                nullwarn(Z, Z);
                break;
            case OINDEX:
                nullwarn(l, r);
                break;
            }
            return;
        }
        gmove(n, nn);
        return;
    }
    curs = cursafe;

    if(l->complex >= FNX)
    if(r != Z && r->complex >= FNX)
    switch(o) {
    default:
        if(cond(o) && typesuv[l->type->etype])
            break;

        regret(&nod, r);
        cgen(r, &nod);

        regsalloc(&nod1, r);
        gmove(&nod, &nod1);

        regfree(&nod);
        nod = *n;
        nod.right = &nod1;

        cgen(&nod, nn);
        return;

    case OFUNC:
    case OCOMMA:
    case OANDAND:
    case OOROR:
    case OCOND:
    case ODOT:
        break;
    }

    hardleft = l->addable < INDEXED || l->complex >= FNX;
    switch(o) {
    default:
        diag(n, "unknown op in cgen: %O", o);
        break;

    case ONEG:
    case OCOM:
        if(nn == Z) {
            nullwarn(l, Z);
            break;
        }
        regalloc(&nod, l, nn);
        cgen(l, &nod);
        gopcode(o, n->type, Z, &nod);
        gmove(&nod, nn);
        regfree(&nod);
        break;

    case OAS:
        if(typefd[n->type->etype]) {
            cgen(r, &fregnode0);
            if(nn != Z)
                gins(AFMOVD, &fregnode0, &fregnode0);
            if(l->addable < INDEXED) {
                reglcgen(&nod, l, Z);
                gmove(&fregnode0, &nod);
                regfree(&nod);
            } else
                gmove(&fregnode0, l);
            if(nn != Z)
                gmove(&fregnode0, nn);
            return;
        }
        if(l->op == OBIT)
            goto bitas;
        if(!hardleft) {
            if(nn != Z || r->addable < INDEXED) {
                if(r->complex >= FNX && nn == Z)
                    regret(&nod, r);
                else
                    regalloc(&nod, r, nn);
                cgen(r, &nod);
                gmove(&nod, l);
                if(nn != Z)
                    gmove(&nod, nn);
                regfree(&nod);
            } else
                gmove(r, l);
            break;
        }
        if(l->complex >= r->complex) {
            if(l->op == OINDEX && r->op == OCONST) {
                gmove(r, l);
                break;
            }
            reglcgen(&nod1, l, Z);
            if(r->addable >= INDEXED) {
                gmove(r, &nod1);
                if(nn != Z)
                    gmove(r, nn);
                regfree(&nod1);
                break;
            }
            regalloc(&nod, r, nn);
            cgen(r, &nod);
        } else {
            regalloc(&nod, r, nn);
            cgen(r, &nod);
            reglcgen(&nod1, l, Z);
        }
        gmove(&nod, &nod1);
        regfree(&nod);
        regfree(&nod1);
        break;

    bitas:
        n = l->left;
        regalloc(&nod, r, nn);
        if(l->complex >= r->complex) {
            reglcgen(&nod1, n, Z);
            cgen(r, &nod);
        } else {
            cgen(r, &nod);
            reglcgen(&nod1, n, Z);
        }
        regalloc(&nod2, n, Z);
        gmove(&nod1, &nod2);
        bitstore(l, &nod, &nod1, &nod2, nn);
        break;

    case OBIT:
        if(nn == Z) {
            nullwarn(l, Z);
            break;
        }
        bitload(n, &nod, Z, Z, nn);
        gmove(&nod, nn);
        regfree(&nod);
        break;

    case OLSHR:
    case OASHL:
    case OASHR:
        if(nn == Z) {
            nullwarn(l, r);
            break;
        }
        if(r->op == OCONST) {
            if(r->vconst == 0) {
                cgen(l, nn);
                break;
            }
            regalloc(&nod, l, nn);
            cgen(l, &nod);
            if(o == OASHL && r->vconst == 1)
                gopcode(OADD, n->type, &nod, &nod);
            else
                gopcode(o, n->type, r, &nod);
            gmove(&nod, nn);
            regfree(&nod);
            break;
        }

        /*
         * get nod to be D_CX
         */
        if(nodreg(&nod, nn, D_CX)) {
            regsalloc(&nod1, n);
            gmove(&nod, &nod1);
            cgen(n, &nod);		/* probably a bug */
            gmove(&nod, nn);
            gmove(&nod1, &nod);
            break;
        }
        reg[D_CX]++;
        if(nn->op == OREGISTER && nn->reg == D_CX)
            regalloc(&nod1, l, Z);
        else
            regalloc(&nod1, l, nn);
        if(r->complex >= l->complex) {
            cgen(r, &nod);
            cgen(l, &nod1);
        } else {
            cgen(l, &nod1);
            cgen(r, &nod);
        }
        gopcode(o, n->type, &nod, &nod1);
        gmove(&nod1, nn);
        regfree(&nod);
        regfree(&nod1);
        break;

    case OADD:
    case OSUB:
    case OOR:
    case OXOR:
    case OAND:
        if(nn == Z) {
            nullwarn(l, r);
            break;
        }
        if(typefd[n->type->etype])
            goto fop;
        if(r->op == OCONST) {
            if(r->vconst == 0 && o != OAND) {
                cgen(l, nn);
                break;
            }
        }
        if(n->op == OADD && l->op == OASHL && l->right->op == OCONST
        && (r->op != OCONST || r->vconst < -128 || r->vconst > 127)) {
            c = l->right->vconst;
            if(c > 0 && c <= 3 && nareg(1) >= 4) {
                if(l->left->complex >= r->complex) {
                    regalloc(&nod, l->left, nn);
                    cgen(l->left, &nod);
                    if(r->addable < INDEXED) {
                        regalloc(&nod1, r, Z);
                        cgen(r, &nod1);
                        genmuladd(&nod, &nod, 1 << c, &nod1);
                        regfree(&nod1);
                    }
                    else
                        genmuladd(&nod, &nod, 1 << c, r);
                }
                else {
                    regalloc(&nod, r, nn);
                    cgen(r, &nod);
                    regalloc(&nod1, l->left, Z);
                    cgen(l->left, &nod1);
                    genmuladd(&nod, &nod1, 1 << c, &nod);
                    regfree(&nod1);
                }
                gmove(&nod, nn);
                regfree(&nod);
                break;
            }
        }
        if(r->addable >= INDEXED) {
            regalloc(&nod, l, nn);
            cgen(l, &nod);
            gopcode(o, n->type, r, &nod);
            gmove(&nod, nn);
            regfree(&nod);
            break;
        }
        if(l->complex >= r->complex) {
            regalloc(&nod, l, nn);
            cgen(l, &nod);
            regalloc(&nod1, r, Z);
            cgen(r, &nod1);
            gopcode(o, n->type, &nod1, &nod);
        } else {
            regalloc(&nod1, r, nn);
            cgen(r, &nod1);
            regalloc(&nod, l, Z);
            cgen(l, &nod);
            gopcode(o, n->type, &nod1, &nod);
        }
        gmove(&nod, nn);
        regfree(&nod);
        regfree(&nod1);
        break;

    case OLMOD:
    case OMOD:
    case OLMUL:
    case OLDIV:
    case OMUL:
    case ODIV:
        if(nn == Z) {
            nullwarn(l, r);
            break;
        }
        if(typefd[n->type->etype])
            goto fop;
        if(r->op == OCONST) {
            SET(v);
            switch(o) {
            case ODIV:
            case OMOD:
                c = r->vconst;
                if(c < 0)
                    c = -c;
                v = log2(c);
                if(v < 0)
                    break;
                /* fall thru */
            case OMUL:
            case OLMUL:
                regalloc(&nod, l, nn);
                cgen(l, &nod);
                switch(o) {
                case OMUL:
                case OLMUL:
                    mulgen(n->type, r, &nod);
                    break;
                case ODIV:
                    sdiv2(r->vconst, v, l, &nod);
                    break;
                case OMOD:
                    smod2(r->vconst, v, l, &nod);
                    break;
                }
                gmove(&nod, nn);
                regfree(&nod);
                goto done;
            case OLDIV:
                c = r->vconst;
                if((c & 0x80000000) == 0)
                    break;
                regalloc(&nod1, l, Z);
                cgen(l, &nod1);
                regalloc(&nod, l, nn);
                zeroregm(&nod);
                gins(ACMPL, &nod1, nodconst(c));
                gins(ASBBL, nodconst(-1), &nod);
                regfree(&nod1);
                gmove(&nod, nn);
                regfree(&nod);
                goto done;
            }
        }

        if(o == OMUL) {
            if(l->addable >= INDEXED) {
                t = l;
                l = r;
                r = t;
                goto imula;
            }
            else if(r->addable >= INDEXED) {
            imula:
/* should favour AX */
                regalloc(&nod, l, nn);
                cgen(l, &nod);
                gopcode(OMUL, n->type, r, &nod);
            }
            else {
/* should favour AX */
                regalloc(&nod, l, nn);
                cgen(l, &nod);
                regalloc(&nod1, r, Z);
                cgen(r, &nod1);
                gopcode(OMUL, n->type, &nod1, &nod);
                regfree(&nod1);
            }
            gmove(&nod, nn);
            regfree(&nod);
            goto done;
        }

        /*
         * get nod to be D_AX
         * get nod1 to be D_DX
         */
        if(nodreg(&nod, nn, D_AX)) {
            regsalloc(&nod2, n);
            gmove(&nod, &nod2);
            v = reg[D_AX];
            reg[D_AX] = 0;

            if(isreg(l, D_AX)) {
                nod3 = *n;
                nod3.left = &nod2;
                cgen(&nod3, nn);
            } else
            if(isreg(r, D_AX)) {
                nod3 = *n;
                nod3.right = &nod2;
                cgen(&nod3, nn);
            } else
                cgen(n, nn);

            gmove(&nod2, &nod);
            reg[D_AX] = v;
            break;
        }
        if(nodreg(&nod1, nn, D_DX)) {
            regsalloc(&nod2, n);
            gmove(&nod1, &nod2);
            v = reg[D_DX];
            reg[D_DX] = 0;

            if(isreg(l, D_DX)) {
                nod3 = *n;
                nod3.left = &nod2;
                cgen(&nod3, nn);
            } else
            if(isreg(r, D_DX)) {
                nod3 = *n;
                nod3.right = &nod2;
                cgen(&nod3, nn);
            } else
                cgen(n, nn);

            gmove(&nod2, &nod1);
            reg[D_DX] = v;
            break;
        }
        reg[D_AX]++;

        if(r->op == OCONST) {
            switch(o) {
            case ODIV:
                reg[D_DX]++;
                if(l->addable < INDEXED) {
                    regalloc(&nod2, l, Z);
                    cgen(l, &nod2);
                    l = &nod2;
                }
                sdivgen(l, r, &nod, &nod1);
                gmove(&nod1, nn);
                if(l == &nod2)
                    regfree(l);
                goto freeaxdx;
            case OLDIV:
                reg[D_DX]++;
                if(l->addable < INDEXED) {
                    regalloc(&nod2, l, Z);
                    cgen(l, &nod2);
                    l = &nod2;
                }
                udivgen(l, r, &nod, &nod1);
                gmove(&nod1, nn);
                if(l == &nod2)
                    regfree(l);
                goto freeaxdx;
            }
        }

        if(l->complex >= r->complex) {
            cgen(l, &nod);
            reg[D_DX]++;
            if(o == ODIV || o == OMOD)
                gins(ACDQ, Z, Z);
            if(o == OLDIV || o == OLMOD)
                zeroregm(&nod1);
            if(r->addable < INDEXED || r->op == OCONST) {
                regsalloc(&nod3, r);
                cgen(r, &nod3);
                gopcode(o, n->type, &nod3, Z);
            } else
                gopcode(o, n->type, r, Z);
        } else {
            regsalloc(&nod3, r);
            cgen(r, &nod3);
            cgen(l, &nod);
            reg[D_DX]++;
            if(o == ODIV || o == OMOD)
                gins(ACDQ, Z, Z);
            if(o == OLDIV || o == OLMOD)
                zeroregm(&nod1);
            gopcode(o, n->type, &nod3, Z);
        }
        if(o == OMOD || o == OLMOD)
            gmove(&nod1, nn);
        else
            gmove(&nod, nn);
    freeaxdx:
        regfree(&nod);
        regfree(&nod1);
        break;

    case OASLSHR:
    case OASASHL:
    case OASASHR:
        if(r->op == OCONST)
            goto asand;
        if(l->op == OBIT)
            goto asbitop;
        if(typefd[n->type->etype])
            goto asfop;

        /*
         * get nod to be D_CX
         */
        if(nodreg(&nod, nn, D_CX)) {
            regsalloc(&nod1, n);
            gmove(&nod, &nod1);
            cgen(n, &nod);
            if(nn != Z)
                gmove(&nod, nn);
            gmove(&nod1, &nod);
            break;
        }
        reg[D_CX]++;

        if(r->complex >= l->complex) {
            cgen(r, &nod);
            if(hardleft)
                reglcgen(&nod1, l, Z);
            else
                nod1 = *l;
        } else {
            if(hardleft)
                reglcgen(&nod1, l, Z);
            else
                nod1 = *l;
            cgen(r, &nod);
        }

        gopcode(o, l->type, &nod, &nod1);
        regfree(&nod);
        if(nn != Z)
            gmove(&nod1, nn);
        if(hardleft)
            regfree(&nod1);
        break;

    case OASAND:
    case OASADD:
    case OASSUB:
    case OASXOR:
    case OASOR:
    asand:
        if(l->op == OBIT)
            goto asbitop;
        if(typefd[n->type->etype]||typefd[r->type->etype])
            goto asfop;
        if(l->complex >= r->complex) {
            if(hardleft)
                reglcgen(&nod, l, Z);
            else
                nod = *l;
            if(r->op != OCONST) {
                regalloc(&nod1, r, nn);
                cgen(r, &nod1);
                gopcode(o, l->type, &nod1, &nod);
                regfree(&nod1);
            } else
                gopcode(o, l->type, r, &nod);
        } else {
            regalloc(&nod1, r, nn);
            cgen(r, &nod1);
            if(hardleft)
                reglcgen(&nod, l, Z);
            else
                nod = *l;
            gopcode(o, l->type, &nod1, &nod);
            regfree(&nod1);
        }
        if(nn != Z)
            gmove(&nod, nn);
        if(hardleft)
            regfree(&nod);
        break;

    case OASLMUL:
    case OASLDIV:
    case OASLMOD:
    case OASMUL:
    case OASDIV:
    case OASMOD:
        if(l->op == OBIT)
            goto asbitop;
        if(typefd[n->type->etype]||typefd[r->type->etype])
            goto asfop;
        if(r->op == OCONST) {
            SET(v);
            switch(o) {
            case OASDIV:
            case OASMOD:
                c = r->vconst;
                if(c < 0)
                    c = -c;
                v = log2(c);
                if(v < 0)
                    break;
                /* fall thru */
            case OASMUL:
            case OASLMUL:
                if(hardleft)
                    reglcgen(&nod2, l, Z);
                else
                    nod2 = *l;
                regalloc(&nod, l, nn);
                cgen(&nod2, &nod);
                switch(o) {
                case OASMUL:
                case OASLMUL:
                    mulgen(n->type, r, &nod);
                    break;
                case OASDIV:
                    sdiv2(r->vconst, v, l, &nod);
                    break;
                case OASMOD:
                    smod2(r->vconst, v, l, &nod);
                    break;
                }
            havev:
                gmove(&nod, &nod2);
                if(nn != Z)
                    gmove(&nod, nn);
                if(hardleft)
                    regfree(&nod2);
                regfree(&nod);
                goto done;
            case OASLDIV:
                c = r->vconst;
                if((c & 0x80000000) == 0)
                    break;
                if(hardleft)
                    reglcgen(&nod2, l, Z);
                else
                    nod2 = *l;
                regalloc(&nod1, l, nn);
                cgen(&nod2, &nod1);
                regalloc(&nod, l, nn);
                zeroregm(&nod);
                gins(ACMPL, &nod1, nodconst(c));
                gins(ASBBL, nodconst(-1), &nod);
                regfree(&nod1);
                goto havev;
            }
        }

        if(o == OASMUL) {
/* should favour AX */
            regalloc(&nod, l, nn);
            if(r->complex >= FNX) {
                regalloc(&nod1, r, Z);
                cgen(r, &nod1);
                r = &nod1;
            }
            if(hardleft)
                reglcgen(&nod2, l, Z);
            else
                nod2 = *l;
            cgen(&nod2, &nod);
            if(r->addable < INDEXED) {
                if(r->complex < FNX) {
                    regalloc(&nod1, r, Z);
                    cgen(r, &nod1);
                }
                gopcode(OASMUL, n->type, &nod1, &nod);
                regfree(&nod1);
            }
            else
                gopcode(OASMUL, n->type, r, &nod);
            if(r == &nod1)
                regfree(r);
            gmove(&nod, &nod2);
            if(nn != Z)
                gmove(&nod, nn);
            regfree(&nod);
            if(hardleft)
                regfree(&nod2);
            goto done;
        }

        /*
         * get nod to be D_AX
         * get nod1 to be D_DX
         */
        if(nodreg(&nod, nn, D_AX)) {
            regsalloc(&nod2, n);
            gmove(&nod, &nod2);
            v = reg[D_AX];
            reg[D_AX] = 0;

            if(isreg(l, D_AX)) {
                nod3 = *n;
                nod3.left = &nod2;
                cgen(&nod3, nn);
            } else
            if(isreg(r, D_AX)) {
                nod3 = *n;
                nod3.right = &nod2;
                cgen(&nod3, nn);
            } else
                cgen(n, nn);

            gmove(&nod2, &nod);
            reg[D_AX] = v;
            break;
        }
        if(nodreg(&nod1, nn, D_DX)) {
            regsalloc(&nod2, n);
            gmove(&nod1, &nod2);
            v = reg[D_DX];
            reg[D_DX] = 0;

            if(isreg(l, D_DX)) {
                nod3 = *n;
                nod3.left = &nod2;
                cgen(&nod3, nn);
            } else
            if(isreg(r, D_DX)) {
                nod3 = *n;
                nod3.right = &nod2;
                cgen(&nod3, nn);
            } else
                cgen(n, nn);

            gmove(&nod2, &nod1);
            reg[D_DX] = v;
            break;
        }
        reg[D_AX]++;
        reg[D_DX]++;

        if(l->complex >= r->complex) {
            if(hardleft)
                reglcgen(&nod2, l, Z);
            else
                nod2 = *l;
            cgen(&nod2, &nod);
            if(r->op == OCONST) {
                switch(o) {
                case OASDIV:
                    sdivgen(&nod2, r, &nod, &nod1);
                    goto divdone;
                case OASLDIV:
                    udivgen(&nod2, r, &nod, &nod1);
                divdone:
                    gmove(&nod1, &nod2);
                    if(nn != Z)
                        gmove(&nod1, nn);
                    goto freelxaxdx;
                }
            }
            if(o == OASDIV || o == OASMOD)
                gins(ACDQ, Z, Z);
            if(o == OASLDIV || o == OASLMOD)
                zeroregm(&nod1);
            if(r->addable < INDEXED || r->op == OCONST ||
               !typeil[r->type->etype]) {
                regalloc(&nod3, r, Z);
                cgen(r, &nod3);
                gopcode(o, l->type, &nod3, Z);
                regfree(&nod3);
            } else
                gopcode(o, n->type, r, Z);
        } else {
            regalloc(&nod3, r, Z);
            cgen(r, &nod3);
            if(hardleft)
                reglcgen(&nod2, l, Z);
            else
                nod2 = *l;
            cgen(&nod2, &nod);
            if(o == OASDIV || o == OASMOD)
                gins(ACDQ, Z, Z);
            if(o == OASLDIV || o == OASLMOD)
                zeroregm(&nod1);
            gopcode(o, l->type, &nod3, Z);
            regfree(&nod3);
        }
        if(o == OASMOD || o == OASLMOD) {
            gmove(&nod1, &nod2);
            if(nn != Z)
                gmove(&nod1, nn);
        } else {
            gmove(&nod, &nod2);
            if(nn != Z)
                gmove(&nod, nn);
        }
    freelxaxdx:
        if(hardleft)
            regfree(&nod2);
        regfree(&nod);
        regfree(&nod1);
        break;

    fop:
        if(l->complex >= r->complex) {
            cgen(l, &fregnode0);
            if(r->addable < INDEXED) {
                cgen(r, &fregnode0);
                fgopcode(o, &fregnode0, &fregnode1, 1, 0);
            } else
                fgopcode(o, r, &fregnode0, 0, 0);
        } else {
            cgen(r, &fregnode0);
            if(l->addable < INDEXED) {
                cgen(l, &fregnode0);
                fgopcode(o, &fregnode0, &fregnode1, 1, 1);
            } else
                fgopcode(o, l, &fregnode0, 0, 1);
        }
        gmove(&fregnode0, nn);
        break;

    asfop:
        if(l->complex >= r->complex) {
            if(hardleft)
                reglcgen(&nod, l, Z);
            else
                nod = *l;
            cgen(r, &fregnode0);
        } else {
            cgen(r, &fregnode0);
            if(hardleft)
                reglcgen(&nod, l, Z);
            else
                nod = *l;
        }
        if(!typefd[l->type->etype]) {
            gmove(&nod, &fregnode0);
            fgopcode(o, &fregnode0, &fregnode1, 1, 1);
        } else
            fgopcode(o, &nod, &fregnode0, 0, 1);
        if(nn != Z)
            gins(AFMOVD, &fregnode0, &fregnode0);
        gmove(&fregnode0, &nod);
        if(nn != Z)
            gmove(&fregnode0, nn);
        if(hardleft)
            regfree(&nod);
        break;

    asbitop:
        regalloc(&nod4, n, nn);
        if(l->complex >= r->complex) {
            bitload(l, &nod, &nod1, &nod2, &nod4);
            regalloc(&nod3, r, Z);
            cgen(r, &nod3);
        } else {
            regalloc(&nod3, r, Z);
            cgen(r, &nod3);
            bitload(l, &nod, &nod1, &nod2, &nod4);
        }
        gmove(&nod, &nod4);

        if(typefd[nod3.type->etype])
            fgopcode(o, &fregnode0, &fregnode1, 1, 1);
        else {
            Node onod;

            /* incredible grot ... */
            onod = nod3;
            onod.op = o;
            onod.complex = 2;
            onod.addable = 0;
            onod.type = tfield;
            onod.left = &nod4;
            onod.right = &nod3;
            cgen(&onod, Z);
        }
        regfree(&nod3);
        gmove(&nod4, &nod);
        regfree(&nod4);
        bitstore(l, &nod, &nod1, &nod2, nn);
        break;

    case OADDR:
        if(nn == Z) {
            nullwarn(l, Z);
            break;
        }
        lcgen(l, nn);
        break;

    case OFUNC:
        l = uncomma(l);
        if(l->complex >= FNX) {
            if(l->op != OIND)
                diag(n, "bad function call");

            regret(&nod, l->left);
            cgen(l->left, &nod);
            regsalloc(&nod1, l->left);
            gmove(&nod, &nod1);
            regfree(&nod);

            nod = *n;
            nod.left = &nod2;
            nod2 = *l;
            nod2.left = &nod1;
            nod2.complex = 1;
            cgen(&nod, nn);

            return;
        }
        gargs(r, &nod, &nod1);
        if(l->addable < INDEXED) {
            reglcgen(&nod, l, nn);
            nod.op = OREGISTER;
            gopcode(OFUNC, n->type, Z, &nod);
            regfree(&nod);
        } else
            gopcode(OFUNC, n->type, Z, l);
        if(REGARG>=0 && reg[REGARG])
            reg[REGARG]--;
        if(nn != Z) {
            regret(&nod, n);
            gmove(&nod, nn);
            regfree(&nod);
        } else
        if(typefd[n->type->etype])
            gins(AFMOVDP, &fregnode0, &fregnode0);
        break;

    case OIND:
        if(nn == Z) {
            nullwarn(l, Z);
            break;
        }
        regialloc(&nod, n, nn);
        r = l;
        while(r->op == OADD)
            r = r->right;
        if(sconst(r)) {
            v = r->vconst;
            r->vconst = 0;
            cgen(l, &nod);
            nod.xoffset += v;
            r->vconst = v;
        } else
            cgen(l, &nod);
        regind(&nod, n);
        gmove(&nod, nn);
        regfree(&nod);
        break;

    case OEQ:
    case ONE:
    case OLE:
    case OLT:
    case OGE:
    case OGT:
    case OLO:
    case OLS:
    case OHI:
    case OHS:
        if(nn == Z) {
            nullwarn(l, r);
            break;
        }
        boolgen(n, 1, nn);
        break;

    case OANDAND:
    case OOROR:
        boolgen(n, 1, nn);
        if(nn == Z)
            patch(p, pc);
        break;

    case ONOT:
        if(nn == Z) {
            nullwarn(l, Z);
            break;
        }
        boolgen(n, 1, nn);
        break;

    case OCOMMA:
        cgen(l, Z);
        cgen(r, nn);
        break;

    case OCAST:
        if(nn == Z) {
            nullwarn(l, Z);
            break;
        }
        /*
         * convert from types l->n->nn
         */
        if(nocast(l->type, n->type) && nocast(n->type, nn->type)) {
            /* both null, gen l->nn */
            cgen(l, nn);
            break;
        }
        if(typev[l->type->etype]) {
            cgen64(n, nn);
            break;
        }
        regalloc(&nod, l, nn);
        cgen(l, &nod);
        regalloc(&nod1, n, &nod);
        gmove(&nod, &nod1);
        gmove(&nod1, nn);
        regfree(&nod1);
        regfree(&nod);
        break;

    case ODOT:
        sugen(l, nodrat, l->type->width);
        if(nn == Z)
            break;
        warn(n, "non-interruptable temporary");
        nod = *nodrat;
        if(!r || r->op != OCONST) {
            diag(n, "DOT and no offset");
            break;
        }
        nod.xoffset += (long)r->vconst;
        nod.type = n->type;
        cgen(&nod, nn);
        break;

    case OCOND:
        bcgen(l, 1);
        p1 = p;
        cgen(r->left, nn);
        gbranch(OGOTO);
        patch(p1, pc);
        p1 = p;
        cgen(r->right, nn);
        patch(p1, pc);
        break;

    case OPOSTINC:
    case OPOSTDEC:
        v = 1;
        if(l->type->etype == TIND)
            v = l->type->link->width;
        if(o == OPOSTDEC)
            v = -v;
        if(l->op == OBIT)
            goto bitinc;
        if(nn == Z)
            goto pre;

        if(hardleft)
            reglcgen(&nod, l, Z);
        else
            nod = *l;

        if(typefd[n->type->etype])
            goto fltinc;
        gmove(&nod, nn);
        gopcode(OADD, n->type, nodconst(v), &nod);
        if(hardleft)
            regfree(&nod);
        break;

    case OPREINC:
    case OPREDEC:
        v = 1;
        if(l->type->etype == TIND)
            v = l->type->link->width;
        if(o == OPREDEC)
            v = -v;
        if(l->op == OBIT)
            goto bitinc;

    pre:
        if(hardleft)
            reglcgen(&nod, l, Z);
        else
            nod = *l;
        if(typefd[n->type->etype])
            goto fltinc;
        gopcode(OADD, n->type, nodconst(v), &nod);
        if(nn != Z)
            gmove(&nod, nn);
        if(hardleft)
            regfree(&nod);
        break;

    fltinc:
        gmove(&nod, &fregnode0);
        if(nn != Z && (o == OPOSTINC || o == OPOSTDEC))
            gins(AFMOVD, &fregnode0, &fregnode0);
        gins(AFLD1, Z, Z);
        if(v < 0)
            fgopcode(OSUB, &fregnode0, &fregnode1, 1, 0);
        else
            fgopcode(OADD, &fregnode0, &fregnode1, 1, 0);
        if(nn != Z && (o == OPREINC || o == OPREDEC))
            gins(AFMOVD, &fregnode0, &fregnode0);
        gmove(&fregnode0, &nod);
        if(hardleft)
            regfree(&nod);
        break;

    bitinc:
        if(nn != Z && (o == OPOSTINC || o == OPOSTDEC)) {
            bitload(l, &nod, &nod1, &nod2, Z);
            gmove(&nod, nn);
            gopcode(OADD, tfield, nodconst(v), &nod);
            bitstore(l, &nod, &nod1, &nod2, Z);
            break;
        }
        bitload(l, &nod, &nod1, &nod2, nn);
        gopcode(OADD, tfield, nodconst(v), &nod);
        bitstore(l, &nod, &nod1, &nod2, nn);
        break;
    }
done:
    cursafe = curs;
}
@

<<function reglcgen>>=
void
reglcgen(Node *t, Node *n, Node *nn)
{
    Node *r;
    long v;

    regialloc(t, n, nn);
    if(n->op == OIND) {
        r = n->left;
        while(r->op == OADD)
            r = r->right;
        if(sconst(r)) {
            v = r->vconst;
            r->vconst = 0;
            lcgen(n, t);
            t->xoffset += v;
            r->vconst = v;
            regind(t, n);
            return;
        }
    }
    lcgen(n, t);
    regind(t, n);
}
@

<<function lcgen>>=
void
lcgen(Node *n, Node *nn)
{
    Prog *p1;
    Node nod;

    if(debug['g']) {
        prtree(nn, "lcgen lhs");
        prtree(n, "lcgen");
    }
    if(n == Z || n->type == T)
        return;
    if(nn == Z) {
        nn = &nod;
        regalloc(&nod, n, Z);
    }
    switch(n->op) {
    default:
        if(n->addable < INDEXED) {
            diag(n, "unknown op in lcgen: %O", n->op);
            break;
        }
        gopcode(OADDR, n->type, n, nn);
        break;

    case OCOMMA:
        cgen(n->left, n->left);
        lcgen(n->right, nn);
        break;

    case OIND:
        cgen(n->left, nn);
        break;

    case OCOND:
        bcgen(n->left, 1);
        p1 = p;
        lcgen(n->right->left, nn);
        gbranch(OGOTO);
        patch(p1, pc);
        p1 = p;
        lcgen(n->right->right, nn);
        patch(p1, pc);
        break;
    }
}
@

<<function bcgen>>=
void
bcgen(Node *n, int true)
{

    if(n->type == T)
        gbranch(OGOTO);
    else
        boolgen(n, true, Z);
}
@

<<function boolgen>>=
void
boolgen(Node *n, int true, Node *nn)
{
    int o;
    Prog *p1, *p2;
    Node *l, *r, nod, nod1;
    long curs;

    if(debug['g']) {
        prtree(nn, "boolgen lhs");
        prtree(n, "boolgen");
    }
    curs = cursafe;
    l = n->left;
    r = n->right;
    switch(n->op) {

    default:
        if(typev[n->type->etype]) {
            testv(n, true);
            goto com;
        }
        o = ONE;
        if(true)
            o = OEQ;
        if(typefd[n->type->etype]) {
            if(n->addable < INDEXED) {
                cgen(n, &fregnode0);
                gins(AFLDZ, Z, Z);
                fgopcode(o, &fregnode0, &fregnode1, 1, 1);
            } else {
                gins(AFLDZ, Z, Z);
                fgopcode(o, n, &fregnode0, 0, 1);
            }
            goto com;
        }
        /* bad, 13 is address of external that becomes constant */
        if(n->addable >= INDEXED && n->addable != 13) {
            gopcode(o, n->type, n, nodconst(0));
            goto com;
        }
        regalloc(&nod, n, nn);
        cgen(n, &nod);
        gopcode(o, n->type, &nod, nodconst(0));
        regfree(&nod);
        goto com;

    case OCONST:
        o = vconst(n);
        if(!true)
            o = !o;
        gbranch(OGOTO);
        if(o) {
            p1 = p;
            gbranch(OGOTO);
            patch(p1, pc);
        }
        goto com;

    case OCOMMA:
        cgen(l, Z);
        boolgen(r, true, nn);
        break;

    case ONOT:
        boolgen(l, !true, nn);
        break;

    case OCOND:
        bcgen(l, 1);
        p1 = p;
        bcgen(r->left, true);
        p2 = p;
        gbranch(OGOTO);
        patch(p1, pc);
        p1 = p;
        bcgen(r->right, !true);
        patch(p2, pc);
        p2 = p;
        gbranch(OGOTO);
        patch(p1, pc);
        patch(p2, pc);
        goto com;

    case OANDAND:
        if(!true)
            goto caseor;

    caseand:
        bcgen(l, true);
        p1 = p;
        bcgen(r, !true);
        p2 = p;
        patch(p1, pc);
        gbranch(OGOTO);
        patch(p2, pc);
        goto com;

    case OOROR:
        if(!true)
            goto caseand;

    caseor:
        bcgen(l, !true);
        p1 = p;
        bcgen(r, !true);
        p2 = p;
        gbranch(OGOTO);
        patch(p1, pc);
        patch(p2, pc);
        goto com;

    case OEQ:
    case ONE:
    case OLE:
    case OLT:
    case OGE:
    case OGT:
    case OHI:
    case OHS:
    case OLO:
    case OLS:
        o = n->op;
        if(typev[l->type->etype]) {
            if(!true)
                n->op = comrel[relindex(o)];
            cgen64(n, Z);
            goto com;
        }
        if(true)
            o = comrel[relindex(o)];
        if(l->complex >= FNX && r->complex >= FNX) {
            regret(&nod, r);
            cgen(r, &nod);
            regsalloc(&nod1, r);
            gmove(&nod, &nod1);
            regfree(&nod);
            nod = *n;
            nod.right = &nod1;
            boolgen(&nod, true, nn);
            break;
        }
        if(typefd[l->type->etype]) {
            if(l->complex >= r->complex) {
                cgen(l, &fregnode0);
                if(r->addable < INDEXED) {
                    cgen(r, &fregnode0);
                    o = invrel[relindex(o)];
                    fgopcode(o, &fregnode0, &fregnode1, 1, 1);
                } else
                    fgopcode(o, r, &fregnode0, 0, 1);
            } else {
                o = invrel[relindex(o)];
                cgen(r, &fregnode0);
                if(l->addable < INDEXED) {
                    cgen(l, &fregnode0);
                    o = invrel[relindex(o)];
                    fgopcode(o, &fregnode0, &fregnode1, 1, 1);
                } else
                    fgopcode(o, l, &fregnode0, 0, 1);
            }
            goto com;
        }
        if(l->op == OCONST) {
            o = invrel[relindex(o)];
            /* bad, 13 is address of external that becomes constant */
            if(r->addable < INDEXED || r->addable == 13) {
                regalloc(&nod, r, nn);
                cgen(r, &nod);
                gopcode(o, l->type, &nod, l);
                regfree(&nod);
            } else
                gopcode(o, l->type, r, l);
            goto com;
        }
        if(l->complex >= r->complex) {
            regalloc(&nod, l, nn);
            cgen(l, &nod);
            if(r->addable < INDEXED) {
                regalloc(&nod1, r, Z);
                cgen(r, &nod1);
                gopcode(o, l->type, &nod, &nod1);
                regfree(&nod1);
            } else
                gopcode(o, l->type, &nod, r);
            regfree(&nod);
            goto com;
        }
        regalloc(&nod, r, nn);
        cgen(r, &nod);
        if(l->addable < INDEXED || l->addable == 13) {
            regalloc(&nod1, l, Z);
            cgen(l, &nod1);
            if(typechlp[l->type->etype])
                gopcode(o, types[TINT], &nod1, &nod);
            else
                gopcode(o, l->type, &nod1, &nod);
            regfree(&nod1);
        } else
            gopcode(o, l->type, l, &nod);
        regfree(&nod);

    com:
        if(nn != Z) {
            p1 = p;
            gmove(nodconst(1L), nn);
            gbranch(OGOTO);
            p2 = p;
            patch(p1, pc);
            gmove(nodconst(0L), nn);
            patch(p2, pc);
        }
        break;
    }
    cursafe = curs;
}
@

<<function sugen>>=
void
sugen(Node *n, Node *nn, long w)
{
    Prog *p1;
    Node nod0, nod1, nod2, nod3, nod4, *h, *l, *r;
    Type *t;
    int c, v, x;

    if(n == Z || n->type == T)
        return;
    if(debug['g']) {
        prtree(nn, "sugen lhs");
        prtree(n, "sugen");
    }
    if(nn == nodrat)
        if(w > nrathole)
            nrathole = w;
    switch(n->op) {
    case OIND:
        if(nn == Z) {
            nullwarn(n->left, Z);
            break;
        }

    default:
        goto copy;

    case OCONST:
        if(n->type && typev[n->type->etype]) {
            if(nn == Z) {
                nullwarn(n->left, Z);
                break;
            }

            if(nn->op == OREGPAIR) {
                loadpair(n, nn);
                break;
            }
            else if(!vaddr(nn, 0)) {
                t = nn->type;
                nn->type = types[TLONG];
                reglcgen(&nod1, nn, Z);
                nn->type = t;

                gmove(lo64(n), &nod1);
                nod1.xoffset += SZ_LONG;
                gmove(hi64(n), &nod1);
                regfree(&nod1);
            }
            else {
                gins(AMOVL, lo64(n), nn);
                nn->xoffset += SZ_LONG;
                gins(AMOVL, hi64(n), nn);
                nn->xoffset -= SZ_LONG;
                break;
            }
            break;
        }
        goto copy;

    case ODOT:
        l = n->left;
        sugen(l, nodrat, l->type->width);
        if(nn == Z)
            break;
        warn(n, "non-interruptable temporary");
        nod1 = *nodrat;
        r = n->right;
        if(!r || r->op != OCONST) {
            diag(n, "DOT and no offset");
            break;
        }
        nod1.xoffset += (long)r->vconst;
        nod1.type = n->type;
        sugen(&nod1, nn, w);
        break;

    case OSTRUCT:
        /*
         * rewrite so lhs has no fn call
         */
        if(nn != Z && side(nn)) {
            nod1 = *n;
            nod1.type = typ(TIND, n->type);
            regret(&nod2, &nod1);
            lcgen(nn, &nod2);
            regsalloc(&nod0, &nod1);
            cgen(&nod2, &nod0);
            regfree(&nod2);

            nod1 = *n;
            nod1.op = OIND;
            nod1.left = &nod0;
            nod1.right = Z;
            nod1.complex = 1;

            sugen(n, &nod1, w);
            return;
        }

        r = n->left;
        for(t = n->type->link; t != T; t = t->down) {
            l = r;
            if(r->op == OLIST) {
                l = r->left;
                r = r->right;
            }
            if(nn == Z) {
                cgen(l, nn);
                continue;
            }
            /*
             * hand craft *(&nn + o) = l
             */
            nod0 = znode;
            nod0.op = OAS;
            nod0.type = t;
            nod0.left = &nod1;
            nod0.right = nil;

            nod1 = znode;
            nod1.op = OIND;
            nod1.type = t;
            nod1.left = &nod2;

            nod2 = znode;
            nod2.op = OADD;
            nod2.type = typ(TIND, t);
            nod2.left = &nod3;
            nod2.right = &nod4;

            nod3 = znode;
            nod3.op = OADDR;
            nod3.type = nod2.type;
            nod3.left = nn;

            nod4 = znode;
            nod4.op = OCONST;
            nod4.type = nod2.type;
            nod4.vconst = t->offset;

            ccom(&nod0);
            acom(&nod0);
            xcom(&nod0);
            nod0.addable = 0;
            nod0.right = l;

            /* prtree(&nod0, "hand craft"); /* */
            cgen(&nod0, Z);
        }
        break;

    case OAS:
        if(nn == Z) {
            if(n->addable < INDEXED)
                sugen(n->right, n->left, w);
            break;
        }

        sugen(n->right, nodrat, w);
        warn(n, "non-interruptable temporary");
        sugen(nodrat, n->left, w);
        sugen(nodrat, nn, w);
        break;

    case OFUNC:
        if(nn == Z) {
            sugen(n, nodrat, w);
            break;
        }
        h = nn;
        if(nn->op == OREGPAIR) {
            regsalloc(&nod1, nn);
            nn = &nod1;
        }
        if(nn->op != OIND) {
            nn = new1(OADDR, nn, Z);
            nn->type = types[TIND];
            nn->addable = 0;
        } else
            nn = nn->left;
        n = new(OFUNC, n->left, new(OLIST, nn, n->right));
        n->type = types[TVOID];
        n->left->type = types[TVOID];
        cgen(n, Z);
        if(h->op == OREGPAIR)
            loadpair(nn->left, h);
        break;

    case OCOND:
        bcgen(n->left, 1);
        p1 = p;
        sugen(n->right->left, nn, w);
        gbranch(OGOTO);
        patch(p1, pc);
        p1 = p;
        sugen(n->right->right, nn, w);
        patch(p1, pc);
        break;

    case OCOMMA:
        cgen(n->left, Z);
        sugen(n->right, nn, w);
        break;
    }
    return;

copy:
    if(nn == Z) {
        switch(n->op) {
        case OASADD:
        case OASSUB:
        case OASAND:
        case OASOR:
        case OASXOR:

        case OASMUL:
        case OASLMUL:

        case OASASHL:
        case OASASHR:
        case OASLSHR:
            break;

        case OPOSTINC:
        case OPOSTDEC:
        case OPREINC:
        case OPREDEC:
            break;

        default:
            return;
        }
    }

    if(n->complex >= FNX && nn != nil && nn->complex >= FNX) {
        t = nn->type;
        nn->type = types[TLONG];
        regialloc(&nod1, nn, Z);
        lcgen(nn, &nod1);
        regsalloc(&nod2, nn);
        nn->type = t;

        gins(AMOVL, &nod1, &nod2);
        regfree(&nod1);

        nod2.type = typ(TIND, t);

        nod1 = nod2;
        nod1.op = OIND;
        nod1.left = &nod2;
        nod1.right = Z;
        nod1.complex = 1;
        nod1.type = t;

        sugen(n, &nod1, w);
        return;
    }

    x = 0;
    v = w == 8;
    if(v) {
        c = cursafe;
        if(n->left != Z && n->left->complex >= FNX
        && n->right != Z && n->right->complex >= FNX) {
//			warn(n, "toughie");
            regsalloc(&nod1, n->right);
            cgen(n->right, &nod1);
            nod2 = *n;
            nod2.right = &nod1;
            cgen(&nod2, nn);
            cursafe = c;
            return;
        }
        if(cgen64(n, nn)) {
            cursafe = c;
            return;
        }
        if(n->op == OCOM) {
            n = n->left;
            x = 1;
        }
    }

    /* botch, need to save in .safe */
    c = 0;
    if(n->complex > nn->complex) {
        t = n->type;
        n->type = types[TLONG];
        if(v) {
            regalloc(&nod0, n, Z);
            if(!vaddr(n, 0)) {
                reglcgen(&nod1, n, Z);
                n->type = t;
                n = &nod1;
            }
            else
                n->type = t;
        }
        else {
            nodreg(&nod1, n, D_SI);
            if(reg[D_SI]) {
                gins(APUSHL, &nod1, Z);
                c |= 1;
                reg[D_SI]++;
            }
            lcgen(n, &nod1);
            n->type = t;
        }

        t = nn->type;
        nn->type = types[TLONG];
        if(v) {
            if(!vaddr(nn, 0)) {
                reglcgen(&nod2, nn, Z);
                nn->type = t;
                nn = &nod2;
            }
            else
                nn->type = t;
        }
        else {
            nodreg(&nod2, nn, D_DI);
            if(reg[D_DI]) {
                gins(APUSHL, &nod2, Z);
                c |= 2;
                reg[D_DI]++;
            }
            lcgen(nn, &nod2);
            nn->type = t;
        }
    } else {
        t = nn->type;
        nn->type = types[TLONG];
        if(v) {
            regalloc(&nod0, nn, Z);
            if(!vaddr(nn, 0)) {
                reglcgen(&nod2, nn, Z);
                nn->type = t;
                nn = &nod2;
            }
            else
                nn->type = t;
        }
        else {
            nodreg(&nod2, nn, D_DI);
            if(reg[D_DI]) {
                gins(APUSHL, &nod2, Z);
                c |= 2;
                reg[D_DI]++;
            }
            lcgen(nn, &nod2);
            nn->type = t;
        }

        t = n->type;
        n->type = types[TLONG];
        if(v) {
            if(!vaddr(n, 0)) {
                reglcgen(&nod1, n, Z);
                n->type = t;
                n = &nod1;
            }
            else
                n->type = t;
        }
        else {
            nodreg(&nod1, n, D_SI);
            if(reg[D_SI]) {
                gins(APUSHL, &nod1, Z);
                c |= 1;
                reg[D_SI]++;
            }
            lcgen(n, &nod1);
            n->type = t;
        }
    }
    if(v) {
        gins(AMOVL, n, &nod0);
        if(x)
            gins(ANOTL, Z, &nod0);
        gins(AMOVL, &nod0, nn);
        n->xoffset += SZ_LONG;
        nn->xoffset += SZ_LONG;
        gins(AMOVL, n, &nod0);
        if(x)
            gins(ANOTL, Z, &nod0);
        gins(AMOVL, &nod0, nn);
        n->xoffset -= SZ_LONG;
        nn->xoffset -= SZ_LONG;
        if(nn == &nod2)
            regfree(&nod2);
        if(n == &nod1)
            regfree(&nod1);
        regfree(&nod0);
        return;
    }
    nodreg(&nod3, n, D_CX);
    if(reg[D_CX]) {
        gins(APUSHL, &nod3, Z);
        c |= 4;
        reg[D_CX]++;
    }
    gins(AMOVL, nodconst(w/SZ_LONG), &nod3);
    gins(ACLD, Z, Z);
    gins(AREP, Z, Z);
    gins(AMOVSL, Z, Z);
    if(w & (SZ_LONG-1)) {
        /* odd length of packed structure */
        gins(AMOVL, nodconst(w & (SZ_LONG-1)), &nod3);
        gins(AREP, Z, Z);
        gins(AMOVSB, Z, Z);
    }
    if(c & 4) {
        gins(APOPL, Z, &nod3);
        reg[D_CX]--;
    }
    if(c & 2) {
        gins(APOPL, Z, &nod2);
        reg[nod2.reg]--;
    }
    if(c & 1) {
        gins(APOPL, Z, &nod1);
        reg[nod1.reg]--;
    }
}
@


%-------------------------------------------------------------

<<8c/cgen.c>>=
#include "gc.h"

<<function cgen>>

<<function reglcgen>>

<<function lcgen>>

<<function bcgen>>

<<function boolgen>>

<<function sugen>>
@


