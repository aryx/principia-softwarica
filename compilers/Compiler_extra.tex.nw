\section{[[cc/]]}

\subsection*{[[cc/cc.h]]}

%-------------------------------------------------------------

<<cc/cc.h>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <ctype.h>

#pragma	lib	"../cc/cc.a$O" //$

typedef	struct	Node	Node;
typedef	struct	Sym	Sym;
typedef	struct	Type	Type;
typedef	struct	Funct	Funct;
typedef	struct	Decl	Decl;
typedef	struct	Io	Io;
typedef	struct	Hist	Hist;
typedef	struct	Term	Term;
typedef	struct	Init	Init;
typedef	struct	Bits	Bits;

typedef	Rune	TRune;	/* target system type */

<<constant NHUNK>>
<<constant BUFSIZ>>
<<constant NSYMB>>
<<constant NHASH>>
<<constant STRINGSZ>>
<<constant HISTSZ>>
<<constant YYMAXDEPTH>>
<<constant NTERM>>
<<constant MAXALIGN>>

<<function SIGN>>
<<function MASK>>

<<constant BITS>>
<<constant NVAR>>
<<struct Bits>>

<<struct Node>>
<<constant Z>>

<<struct Sym>>
<<constant S>>

<<enum sigxxx>>

<<struct Decl>>
<<constant D>>

<<struct Type>>
<<constant T>>
<<constant NODECL>>

<<struct Init>>


<<struct Fi>>
extern struct Fi fi;

<<struct Io>>
<<constant I>>

<<struct Hist>>
<<constant H>>
extern Hist*	hist;

<<struct Term>>

<<enum os>>
<<enum node_kind>>
<<enum type_kind>>
<<enum axxx>>
<<enum dxxx>>
<<enum cxxx>>
<<enum gxxx>>
<<enum bxxx>>

<<struct Funct>>

<<struct En>>
extern struct En en;

extern	int	autobn;
extern	long	autoffset;
extern	int	blockno;
extern	Decl*	dclstack;
extern	char	debug[256];
extern	Hist*	ehist;
extern	long	firstbit;
extern	Sym*	firstarg;
extern	Type*	firstargtype;
extern	Decl*	firstdcl;
extern	Sym*	hash[NHASH];
extern	int	hasdoubled;
extern	char*	hunk;
extern	char**	include;
extern	Io*	iofree;
extern	Io*	ionext;
extern	Io*	iostack;
extern	long	lastbit;
extern	char	lastclass;
extern	Type*	lastdcl;
extern	long	lastfield;
extern	Type*	lasttype;
extern	long	lineno;
extern	long	nearln;
extern	int	maxinclude;
extern	int	nerrors;
extern	bool	newflag;
extern	long	nhunk;
extern	int	ninclude;
extern	Node*	nodproto;
extern	Node*	nodcast;
extern	Biobuf	outbuf;
extern	Biobuf	diagbuf;
extern	char*	outfile;
extern	char*	pathname;
extern	int	peekc;
extern	long	stkoff;
extern	Type*	strf;
extern	Type*	strl;
extern	char	symb[NSYMB];
extern	Sym*	symstring;
extern	int	taggen;
extern	Type*	tfield;
extern	Type*	tufield;
extern	int	thechar;
extern	char*	thestring;
extern	Type*	thisfn;
extern	long	thunk;
extern	Type*	types[NTYPE];

extern	Type*	fntypes[NTYPE];
extern	Node*	initlist;
extern	Term	term[NTERM];
extern	int	nterm;
extern	int	packflg;
extern	int	fproundflg;
extern	bool	profileflg;
extern	int	ncontin;
extern	bool	newvlongcode;
extern	int	canreach;
extern	int	warnreach;
extern	Bits	zbits;

extern	char	*onames[], *tnames[], *gnames[];
extern	char	*cnames[], *qnames[], *bnames[];

extern	char	comrel[], invrel[], logrel[];
extern	long	ncast[], tadd[], tand[];
extern	long	targ[], tasadd[], tasign[], tcast[];
extern	long	tdot[], tfunct[], tindir[], tmul[];
extern	long	tnot[], trel[], tsub[];

extern	char	typeaf[];
extern	char	typefd[];
extern	char	typei[];
extern	char	typesu[];
extern	char	typesuv[];
extern	char	typeu[];
extern	char	typev[];
extern	char	typeil[];
extern	char	typeilp[];
extern	char	typechl[];
extern	char	typechlv[];

extern	char	typechlp[];
extern	char	typechlpfd[];

extern	char*	typeswitch;
extern	char*	typeword;
extern	char*	typecmplx;

extern	ulong	thash1;
extern	ulong	thash2;
extern	ulong	thash3;
extern	ulong	thash[];

/*
 *	compat.c/unix.c/windows.c
 */
int	mywait(int*);
int	mycreat(char*, int);
int	myaccess(char*);
int	pathchar(void);
bool	systemtype(int);

// utils.c
void	gethunk(void);
void*	allocn(void*, long, long);
void*	alloc(long);
void	errorexit(void);
void	yyerror(char*, ...);

/*
 *	parser
 */
//@Scheck: def in y.tab.c from cc.y
int	yyparse(void);

/*
 *	lex.c
 */
int	filbuf(void);
int	getc(void);
int	getnsc(void);
Sym*	lookup(void);
void	newfile(char*, int);
void	newio(void);
void	pushio(void);
Sym*	slookup(char*);
void	unget(int);
long	yylex(void);

//!!!! (hmmm in lex.c, as well as cinit(), compile())
void	main(int, char*[]);


/*
 * mac.c
 */
void	dodefine(char*);
void	domacro(void);
void	linehist(char*, int);
void	macexpand(Sym*, char*);

/*
 * dcl.c
 */
//@Scheck: useful, used by cc.y
Type*	tcopy(Type*);
//@Scheck: useful, used by cc.y
Node*	doinit(Sym*, Type*, long, Node*);
//@Scheck: useful, used by cc.y
void	adecl(int, Type*, Sym*);
void	argmark(Node*, int);
Node*	dcllabel(Sym*, int);
Node*	dodecl(void(*)(int, Type*, Sym*), int, Type*, Node*);
//@Scheck: useful, used by cc.y
Sym*	mkstatic(Sym*);
void	doenum(Sym*, Node*);
void	snap(Type*);
Type*	dotag(Sym*, int, int);
void	edecl(int, Type*, Sym*);
void	markdcl(void);
//@Scheck: useful, used by cc.y
void	pdecl(int, Type*, Sym*);
Node*	revertdcl(void);
long	round(long, int);
int	sametype(Type*, Type*);
ulong	sign(Sym*);
ulong	signature(Type*);
void	sualign(Type*);
void	xdecl(int, Type*, Sym*);
Node*	contig(Sym*, Node*, long);

/*
 * com.c
 */
void	ccom(Node*);
void	complex(Node*);
int	tcom(Node*);
int	tcoma(Node*, Node*, Type*, int);
int	tcomo(Node*, int);
void	constas(Node*, Type*, Type*);
Node*	uncomma(Node*);

/*
 * con.c
 */
void	acom(Node*);
void	evconst(Node*);

/*
 * funct.c
 */
int	isfunct(Node*);
void	dclfunct(Type*, Sym*);

/*
 * sub.c
 */
void	arith(Node*, int);
int	deadheads(Node*);
Type*	dotsearch(Sym*, Type*, Node*, long*);
Node*	invert(Node*);
int	bitno(long);
void	makedot(Node*, Type*, long);
int	mixedasop(Type*, Type*);
Node*	new(int, Node*, Node*);
Node*	new1(int, Node*, Node*);
int	nilcast(Type*, Type*);
int	nocast(Type*, Type*);
void	prtree(Node*, char*);
void	prtree1(Node*, int, int);
void	relcon(Node*, Node*);
int	relindex(int);
//@Scheck: useful, used by cc.y
int	simpleg(long);
Type*	garbt(Type*, long);
int	simplec(long);
Type*	simplet(long);
int	stcompat(Node*, Type*, Type*, long[]);
int	tcompat(Node*, Type*, Type*, long[]);
void	tinit(void);
Type*	typ(int, Type*);
Type*	copytyp(Type*);
void	typeext(Type*, Node*);
void	typeext1(Type*, Node*);
int	side(Node*);
int	vconst(Node*);
int	log2(uvlong);
int	vlog(Node*);
int	topbit(ulong);
void	simplifyshift(Node*);
long	typebitor(long, long);
void	diag(Node*, char*, ...);
void	warn(Node*, char*, ...);
void	fatal(Node*, char*, ...);

/*
 * acid.c
 */
void	acidtype(Type*);
void	acidvar(Sym*);

/*
 * pickle.c
 */
void	pickletype(Type*);

/*
 * bits.c
 */
Bits	bor(Bits, Bits);
//Bits	band(Bits, Bits);
//Bits	bnot(Bits);
int	bany(Bits*);
int	bnum(Bits);
Bits	blsh(uint);
int	beq(Bits, Bits);
int	bset(Bits, uint);

/*
 * dpchk.c
 */
void	dpcheck(Node*);
void	arginit(void);
//void	pragvararg(void);
//void	pragpack(void);
//void	pragfpround(void);
//void  pragprofile(void);
//void	pragincomplete(void);

/*
 * calls to machine depend part
 */
//todo: could define an interface instantiated by each xc
void	codgen(Node*, Node*);
void	gclean(void);
void	gextern(Sym*, Node*, long, long);
void	ginit(void);
long	outstring(char*, long);
long	outlstring(TRune*, long);
void	xcom(Node*);
long	exreg(Type*);
long	align(long, Type*, int);
long	maxround(long, long);

extern	schar	ewidth[];

/*
 * com64
 */
int	com64(Node*);
void	com64init(void);
void	bool64(Node*);
//double	convvtof(vlong);
//vlong		convftov(double);
//double	convftox(double, int);
vlong	convvtox(vlong, int);

/*
 * machcap
 */
int	machcap(Node*);

#pragma	varargck	argpos	warn	2
#pragma	varargck	argpos	diag	2
#pragma	varargck	argpos	yyerror	1

#pragma	varargck	type	"F"	Node*
#pragma	varargck	type	"L"	long
#pragma	varargck	type	"Q"	long
#pragma	varargck	type	"O"	int
#pragma	varargck	type	"T"	Type*
#pragma	varargck	type	"|"	int
@
%$


\subsection*{[[cc/mac.c]]}

%-------------------------------------------------------------

<<cc/mac.c>>=
#include	"cc.h"

//old: #include	"macbody"
//TODO copy paste with aa/, maybe could factorize with another lib?
//

void	macdef(void);
void	macinc(void);
void	macprag(void);
void	maclin(void);
void	macif(int);
void	macend(void);
void	macund(void);

long	getnsn(void);
Sym*	getsym(void);

<<constant VARMAC>>

<<function getnsn>>

<<function getsym>>

<<function getsymdots>>

<<function getcom>>

<<function dodefine>>

<<global mactab>>

<<function domacro>>

<<function macund>>

<<constant NARG>>
<<function macdef>>

<<function macexpand>>

<<function macinc>>

<<function maclin>>

<<function macif>>

<<function macprag>>

<<function macend>>

<<function linehist>>

@


\subsection*{[[cc/omachcap.c]]}

%-------------------------------------------------------------

<<cc/omachcap.c>>=
#include	"cc.h"

/* default, like old cc */
//int
//machcap(Node*)
//{
//	return 0;
//}
@



\subsection*{[[cc/utils.c]]}

<<cc/utils.c>>=
#include "cc.h"

<<function errorexit>>

<<function gethunk>>

<<function alloc>>

<<function allocn>>

<<function yyerror>>

@

\subsection*{[[cc/globals.c]]}

%<<global fperror>>=
%//int	fperror;
%@

%-------------------------------------------------------------

<<cc/globals.c>>=
#include "cc.h"

<<global fi>>
<<global hist>>
<<global en>>

<<global autobn>>
<<global autoffset>>
<<global blockno>>
<<global dclstack>>
<<global debug>>
<<global ehist>>
<<global firstbit>>
<<global firstarg>>
<<global firstargtype>>
<<global firstdcl>>
<<global hash>>
<<global hasdoubled>>
<<global hunk>>
<<global include>>
<<global iofree>>
<<global ionext>>
<<global iostack>>
<<global lastbit>>
<<global lastclass>>
<<global lastdcl>>
<<global lastfield>>
<<global lasttype>>
<<global lineno>>
<<global nearln>>
<<global maxinclude>>
<<global nerrors>>
<<global newflag>>
<<global nhunk>>
<<global ninclude>>
<<global nodproto>>
<<global nodcast>>
<<global outbuf>>
<<global diagbuf>>
<<global outfile>>
<<global pathname>>
<<global peekc>>
<<global stkoff>>
<<global strf>>
<<global strl>>
<<global symb>>
<<global symstring>>
<<global taggen>>
<<global tfield>>
<<global tufield>>
<<global thechar>>
<<global thestring>>
<<global thisfn>>
<<global thunk>>
<<global types>>
<<global fntypes>>
<<global initlist>>
<<global term>>
<<global nterm>>
<<global packflg>>
<<global fproundflg>>
<<global profileflg>>
<<global ncontin>>
<<global newvlongcode>>
<<global canreach>>
<<global warnreach>>
<<global zbits>>

<<global typeswitch>>
<<global typeword>>
<<global typecmplx>>
@


\subsection*{[[cc/sub.c]]}

<<function stcompat>>=
bool
stcompat(Node *n, Type *t1, Type *t2, long ttab[])
{
    int i;
    ulong b;

    i = 0;
    if(t2 != T)
        i = t2->etype;
    b = 1L << i;
    i = 0;
    if(t1 != T)
        i = t1->etype;
    if(b & ttab[i]) {
        if(ttab == tasign)
            if(b == BSTRUCT || b == BUNION)
                if(!sametype(t1, t2))
                    return true;
        if(n->op != OCAST)
          if(b == BIND && i == TIND)
                if(!sametype(t1, t2))
                    return true;
        return false;
    }
    return true;
}
@

<<function tcompat>>=
bool
tcompat(Node *n, Type *t1, Type *t2, long ttab[])
{

    if(stcompat(n, t1, t2, ttab)) {
        if(t1 == T)
            diag(n, "incompatible type: \"%T\" for op \"%O\"",
                t2, n->op);
        else
            diag(n, "incompatible types: \"%T\" and \"%T\" for op \"%O\"",
                t1, t2, n->op);
        return true;
    }
    return false;
}
@

<<function makedot>>=
void
makedot(Node *n, Type *t, long o)
{
    Node *n1, *n2;

    if(t->nbits) {
        n1 = new(OXXX, Z, Z);
        *n1 = *n;
        n->op = OBIT;
        n->left = n1;
        n->right = Z;
        n->type = t;
        n->addable = n1->left->addable;
        n = n1;
    }
    n->addable = n->left->addable;
    if(n->addable == 0) {
        n1 = new1(OCONST, Z, Z);
        n1->vconst = o;
        n1->type = types[TLONG];
        n->right = n1;
        n->type = t;
        return;
    }
    n->left->type = t;
    if(o == 0) {
        *n = *n->left;
        return;
    }
    n->type = t;
    n1 = new1(OCONST, Z, Z);
    n1->vconst = o;
    t = typ(TIND, t);
    t->width = types[TIND]->width;
    n1->type = t;

    n2 = new1(OADDR, n->left, Z);
    n2->type = t;

    n1 = new1(OADD, n1, n2);
    n1->type = t;

    n->op = OIND;
    n->left = n1;
    n->right = Z;
}
@



<<function constas>>=
void
constas(Node *n, Type *il, Type *ir)
{
    Type *l, *r;

    l = il;
    r = ir;

    if(l == T)
        return;
    if(l->garb & GCONSTNT) {
        warn(n, "assignment to a constant type (%T)", il);
        return;
    }
    if(r == T)
        return;
    for(;;) {
        if(l->etype != TIND || r->etype != TIND)
            break;
        l = l->link;
        r = r->link;
        if(l == T || r == T)
            break;
        if(r->garb & GCONSTNT)
            if(!(l->garb & GCONSTNT)) {
                warn(n, "assignment of a constant pointer type (%T)", ir);
                break;
            }
    }
}
@










<<function dotoffset>>=
long
dotoffset(Type *st, Type *lt, Node *n)
{
    Type *t;
    Sym *g;
    long o, o1;

    o = -1;
    /*
     * first try matching at the top level
     * for matching tag names
     */
    g = st->tag;
    if(g != S)
        for(t=lt->link; t!=T; t=t->down)
            if(t->sym == S)
                if(g == t->tag) {
                    if(o >= 0)
                        goto ambig;
                    o = t->offset;
                }
    if(o >= 0)
        return o;

    /*
     * second try matching at the top level
     * for similar types
     */
    for(t=lt->link; t!=T; t=t->down)
        if(t->sym == S)
            if(sametype(st, t)) {
                if(o >= 0)
                    goto ambig;
                o = t->offset;
            }
    if(o >= 0)
        return o;

    /*
     * last try matching sub-levels
     */
    for(t=lt->link; t!=T; t=t->down)
        if(t->sym == S)
        if(typesu[t->etype]) {
            o1 = dotoffset(st, t, n);
            if(o1 >= 0) {
                if(o >= 0)
                    goto ambig;
                o = o1 + t->offset;
            }
        }
    return o;

ambig:
    diag(n, "ambiguous unnamed structure element");
    return o;
}
@


<<function typeext1>>=
void
typeext1(Type *st, Node *l)
{
    if(st->etype == TFLOAT && allfloat(l, 0))
        allfloat(l, 1);
}
@

<<function typeext>>=
void
typeext(Type *st, Node *l)
{
    Type *lt;
    Node *n1, *n2;
    long o;

    lt = l->type;
    if(lt == T)
        return;
    if(st->etype == TIND && vconst(l) == 0) {
        l->type = st;
        l->vconst = 0;
        return;
    }
    typeext1(st, l);

    /*
     * extension of C
     * if assign of struct containing unnamed sub-struct
     * to type of sub-struct, insert the DOT.
     * if assign of *struct containing unnamed substruct
     * to type of *sub-struct, insert the add-offset
     */
    if(typesu[st->etype] && typesu[lt->etype]) {
        o = dotoffset(st, lt, l);
        if(o >= 0) {
            n1 = new1(OXXX, Z, Z);
            *n1 = *l;
            l->op = ODOT;
            l->left = n1;
            l->right = Z;
            makedot(l, st, o);
        }
        return;
    }
    if(st->etype == TIND && typesu[st->link->etype])
    if(lt->etype == TIND && typesu[lt->link->etype]) {
        o = dotoffset(st->link, lt->link, l);
        if(o >= 0) {
            l->type = st;
            if(o == 0)
                return;
            n1 = new1(OXXX, Z, Z);
            *n1 = *l;
            n2 = new1(OCONST, Z, Z);
            n2->vconst = o;
            n2->type = st;
            l->op = OADD;
            l->left = n1;
            l->right = n2;
        }
        return;
    }
}
@

<<function nocast>>=
/*
 * a cast that generates no code
 * (same size move)
 */
bool
nocast(Type *t1, Type *t2)
{
    int i, b;

    if(t1->nbits)
        return false;
    i = 0;
    if(t2 != T)
        i = t2->etype;
    b = 1<<i;
    i = 0;
    if(t1 != T)
        i = t1->etype;
    if(b & ncast[i])
        return true;
    return false;
}
@

<<function nilcast>>=
/*
 * a cast that has a noop semantic
 * (small to large, convert)
 */
bool
nilcast(Type *t1, Type *t2)
{
    int et1, et2;

    if(t1 == T)
        return false;
    if(t1->nbits)
        return false;
    if(t2 == T)
        return false;
    et1 = t1->etype;
    et2 = t2->etype;
    if(et1 == et2)
        return true;
    if(typefd[et1] && typefd[et2]) {
        if(ewidth[et1] < ewidth[et2])
            return true;
        return false;
    }
    if(typechlp[et1] && typechlp[et2]) {
        if(ewidth[et1] < ewidth[et2])
            return true;
        return false;
    }
    return false;
}
@

<<function arith>>=
/*
 * "the usual arithmetic conversions are performed"
 */
void
arith(Node *n, int f)
{
    Type *t1, *t2;
    int i, j, k;
    Node *n1;
    long w;

    t1 = n->left->type;
    if(n->right == Z)
        t2 = t1;
    else
        t2 = n->right->type;
    i = TXXX;
    if(t1 != T)
        i = t1->etype;
    j = TXXX;
    if(t2 != T)
        j = t2->etype;
    k = tab[i][j];
    if(k == TIND) {
        if(i == TIND)
            n->type = t1;
        else
        if(j == TIND)
            n->type = t2;
    } else {
        /* convert up to at least int */
        if(f == 1)
        while(k < TINT)
            k += 2;
        n->type = types[k];
    }
    if(n->op == OSUB)
    if(i == TIND && j == TIND) {
        w = n->right->type->link->width;
        if(w < 1 || n->left->type->link == T || n->left->type->link->width < 1)
            goto bad;
        n->type = types[ewidth[TIND] <= ewidth[TLONG]? TLONG: TVLONG];
        if(1 && ewidth[TIND] > ewidth[TLONG]){
            n1 = new1(OXXX, Z, Z);
            *n1 = *n;
            n->op = OCAST;
            n->left = n1;
            n->right = Z;
            n->type = types[TLONG];
        }
        if(w > 1) {
            n1 = new1(OXXX, Z, Z);
            *n1 = *n;
            n->op = ODIV;
            n->left = n1;
            n1 = new1(OCONST, Z, Z);
            n1->vconst = w;
            n1->type = n->type;
            n->right = n1;
            w = vlog(n1);
            if(w >= 0) {
                n->op = OASHR;
                n1->vconst = w;
            }
        }
        return;
    }
    if(!sametype(n->type, n->left->type)) {
        n->left = new1(OCAST, n->left, Z);
        n->left->type = n->type;
        if(n->type->etype == TIND) {
            w = n->type->link->width;
            if(w < 1) {
                snap(n->type->link);
                w = n->type->link->width;
                if(w < 1)
                    goto bad;
            }
            if(w > 1) {
                n1 = new1(OCONST, Z, Z);
                n1->vconst = w;
                n1->type = n->type;
                n->left = new1(OMUL, n->left, n1);
                n->left->type = n->type;
            }
        }
    }
    if(n->right != Z)
    if(!sametype(n->type, n->right->type)) {
        n->right = new1(OCAST, n->right, Z);
        n->right->type = n->type;
        if(n->type->etype == TIND) {
            w = n->type->link->width;
            if(w < 1) {
                snap(n->type->link);
                w = n->type->link->width;
                if(w < 1)
                    goto bad;
            }
            if(w != 1) {
                n1 = new1(OCONST, Z, Z);
                n1->vconst = w;
                n1->type = n->type;
                n->right = new1(OMUL, n->right, n1);
                n->right->type = n->type;
            }
        }
    }
    return;
bad:
    diag(n, "pointer addition not fully declared: %T", n->type->link);
}
@


<<function side>>=
bool
side(Node *n)
{

loop:
    if(n != Z)
    switch(n->op) {
    case OCAST:
    case ONOT:
    case OADDR:
    case OIND:
        n = n->left;
        goto loop;

    case OCOND:
        if(side(n->left))
            break;
        n = n->right;

    case OEQ:
    case ONE:
    case OLT:
    case OGE:
    case OGT:
    case OLE:
    case OADD:
    case OSUB:
    case OMUL:
    case OLMUL:
    case ODIV:
    case OLDIV:
    case OLSHR:
    case OASHL:
    case OASHR:
    case OAND:
    case OOR:
    case OXOR:
    case OMOD:
    case OLMOD:
    case OANDAND:
    case OOROR:
    case OCOMMA:
    case ODOT:
        if(side(n->left))
            break;
        n = n->right;
        goto loop;

    case OSIGN:
    case OSIZE:
    case OCONST:
    case OSTRING:
    case OLSTRING:
    case ONAME:
        return false;
    }
    return true;
}
@

<<function vconst>>=
int
vconst(Node *n)
{
    int i;

    if(n == Z)
        goto no;
    if(n->op != OCONST)
        goto no;
    if(n->type == T)
        goto no;
    switch(n->type->etype)
    {
    case TFLOAT:
    case TDOUBLE:
        i = 100;
        if(n->fconst > i || n->fconst < -i)
            goto no;
        i = n->fconst;
        if(i != n->fconst)
            goto no;
        return i;

    case TVLONG:
    case TUVLONG:
        i = n->vconst;
        if(i != n->vconst)
            goto no;
        return i;

    case TCHAR:
    case TUCHAR:
    case TSHORT:
    case TUSHORT:
    case TINT:
    case TUINT:
    case TLONG:
    case TULONG:
    case TIND:
        i = n->vconst;
        if(i != n->vconst)
            goto no;
        return i;
    }
no:
    return -159;	/* first uninteresting constant */
}
@


<<function vlog>>=
int
vlog(Node *n)
{
    if(n->op != OCONST)
        goto bad;
    if(typefd[n->type->etype])
        goto bad;

    return log2(n->vconst);

bad:
    return -1;
}
@


<<function relcon>>=
/*
 * try to cast a constant down
 * rather than cast a variable up
 * example:
 *	if(c == 'a')
 */
void
relcon(Node *l, Node *r)
{
    vlong v;

    if(l->op != OCONST)
        return;
    if(r->op != OCAST)
        return;
    if(!nilcast(r->left->type, r->type))
        return;
    switch(r->type->etype) {
    default:
        return;
    case TCHAR:
    case TUCHAR:
    case TSHORT:
    case TUSHORT:
        v = convvtox(l->vconst, r->type->etype);
        if(v != l->vconst)
            return;
        break;
    }
    l->type = r->left->type;
    *r = *r->left;
}
@

<<function relindex>>=
int
relindex(int o)
{

    switch(o) {
    default:
        diag(Z, "bad in relindex: %O", o);
    case OEQ: return 0;
    case ONE: return 1;
    case OLE: return 2;
    case OLS: return 3;
    case OLT: return 4;
    case OLO: return 5;
    case OGE: return 6;
    case OHS: return 7;
    case OGT: return 8;
    case OHI: return 9;
    }
}
@




<<global comrel>>=
/*	OEQ, ONE, OLE, OLS, OLT, OLO, OGE, OHS, OGT, OHI */
char	comrel[12] =
{
    ONE, OEQ, OGT, OHI, OGE, OHS, OLT, OLO, OLE, OLS,
};
@

<<global invrel>>=
char	invrel[12] =
{
    OEQ, ONE, OGE, OHS, OGT, OHI, OLE, OLS, OLT, OLO,
};
@

<<global logrel>>=
char	logrel[12] =
{
    OEQ, ONE, OLS, OLS, OLO, OLO, OHS, OHS, OHI, OHI,
};
@
















<<global tasign>>=
long	tasign[NTYPE];
@

<<global tasigninit>>=
Init	tasigninit[] =
{
    TCHAR,		BNUMBER,	0,
    TUCHAR,		BNUMBER,	0,
    TSHORT,		BNUMBER,	0,
    TUSHORT,	BNUMBER,	0,
    TINT,		BNUMBER,	0,
    TUINT,		BNUMBER,	0,
    TLONG,		BNUMBER,	0,
    TULONG,		BNUMBER,	0,
    TVLONG,		BNUMBER,	0,
    TUVLONG,	BNUMBER,	0,
    TFLOAT,		BNUMBER,	0,
    TDOUBLE,	BNUMBER,	0,
    TIND,		BIND,		0,
    TSTRUCT,	BSTRUCT,	0,
    TUNION,		BUNION,		0,
    -1,		0,		0,
};
@

<<global tasadd>>=
long	tasadd[NTYPE];
@

<<global tasaddinit>>=
Init	tasaddinit[] =
{
    TCHAR,		BNUMBER,	0,
    TUCHAR,		BNUMBER,	0,
    TSHORT,		BNUMBER,	0,
    TUSHORT,	BNUMBER,	0,
    TINT,		BNUMBER,	0,
    TUINT,		BNUMBER,	0,
    TLONG,		BNUMBER,	0,
    TULONG,		BNUMBER,	0,
    TVLONG,		BNUMBER,	0,
    TUVLONG,	BNUMBER,	0,
    TFLOAT,		BNUMBER,	0,
    TDOUBLE,	BNUMBER,	0,
    TIND,		BINTEGER,	0,
    -1,		0,		0,
};
@

<<global tcast>>=
long	tcast[NTYPE];
@

<<global tcastinit>>=
Init	tcastinit[] =
{
    TCHAR,		BNUMBER|BIND|BVOID,	0,
    TUCHAR,		BNUMBER|BIND|BVOID,	0,
    TSHORT,		BNUMBER|BIND|BVOID,	0,
    TUSHORT,	BNUMBER|BIND|BVOID,	0,
    TINT,		BNUMBER|BIND|BVOID,	0,
    TUINT,		BNUMBER|BIND|BVOID,	0,
    TLONG,		BNUMBER|BIND|BVOID,	0,
    TULONG,		BNUMBER|BIND|BVOID,	0,
    TVLONG,		BNUMBER|BIND|BVOID,	0,
    TUVLONG,	BNUMBER|BIND|BVOID,	0,
    TFLOAT,		BNUMBER|BVOID,		0,
    TDOUBLE,	BNUMBER|BVOID,		0,
    TIND,		BINTEGER|BIND|BVOID,	0,
    TVOID,		BVOID,			0,
    TSTRUCT,	BSTRUCT|BVOID,		0,
    TUNION,		BUNION|BVOID,		0,
    -1,		0,			0,
};
@

<<global tadd>>=
long	tadd[NTYPE];
@

<<global taddinit>>=
Init	taddinit[] =
{
    TCHAR,		BNUMBER|BIND,	0,
    TUCHAR,		BNUMBER|BIND,	0,
    TSHORT,		BNUMBER|BIND,	0,
    TUSHORT,	BNUMBER|BIND,	0,
    TINT,		BNUMBER|BIND,	0,
    TUINT,		BNUMBER|BIND,	0,
    TLONG,		BNUMBER|BIND,	0,
    TULONG,		BNUMBER|BIND,	0,
    TVLONG,		BNUMBER|BIND,	0,
    TUVLONG,	BNUMBER|BIND,	0,
    TFLOAT,		BNUMBER,	0,
    TDOUBLE,	BNUMBER,	0,
    TIND,		BINTEGER,	0,
    -1,		0,		0,
};
@

<<global tsub>>=
long	tsub[NTYPE];
@

<<global tsubinit>>=
Init	tsubinit[] =
{
    TCHAR,		BNUMBER,	0,
    TUCHAR,		BNUMBER,	0,
    TSHORT,		BNUMBER,	0,
    TUSHORT,	BNUMBER,	0,
    TINT,		BNUMBER,	0,
    TUINT,		BNUMBER,	0,
    TLONG,		BNUMBER,	0,
    TULONG,		BNUMBER,	0,
    TVLONG,		BNUMBER,	0,
    TUVLONG,	BNUMBER,	0,
    TFLOAT,		BNUMBER,	0,
    TDOUBLE,	BNUMBER,	0,
    TIND,		BINTEGER|BIND,	0,
    -1,		0,		0,
};
@

<<global tmul>>=
long	tmul[NTYPE];
@

<<global tmulinit>>=
Init	tmulinit[] =
{
    TCHAR,		BNUMBER,	0,
    TUCHAR,		BNUMBER,	0,
    TSHORT,		BNUMBER,	0,
    TUSHORT,	BNUMBER,	0,
    TINT,		BNUMBER,	0,
    TUINT,		BNUMBER,	0,
    TLONG,		BNUMBER,	0,
    TULONG,		BNUMBER,	0,
    TVLONG,		BNUMBER,	0,
    TUVLONG,	BNUMBER,	0,
    TFLOAT,		BNUMBER,	0,
    TDOUBLE,	BNUMBER,	0,
    -1,		0,		0,
};
@

<<global tand>>=
long	tand[NTYPE];
@

<<global tandinit>>=
Init	tandinit[] =
{
    TCHAR,		BINTEGER,	0,
    TUCHAR,		BINTEGER,	0,
    TSHORT,		BINTEGER,	0,
    TUSHORT,	BINTEGER,	0,
    TINT,		BNUMBER,	0,
    TUINT,		BNUMBER,	0,
    TLONG,		BINTEGER,	0,
    TULONG,		BINTEGER,	0,
    TVLONG,		BINTEGER,	0,
    TUVLONG,	BINTEGER,	0,
    -1,		0,		0,
};
@

<<global trel>>=
long	trel[NTYPE];
@

<<global trelinit>>=
Init	trelinit[] =
{
    TCHAR,		BNUMBER,	0,
    TUCHAR,		BNUMBER,	0,
    TSHORT,		BNUMBER,	0,
    TUSHORT,	BNUMBER,	0,
    TINT,		BNUMBER,	0,
    TUINT,		BNUMBER,	0,
    TLONG,		BNUMBER,	0,
    TULONG,		BNUMBER,	0,
    TVLONG,		BNUMBER,	0,
    TUVLONG,	BNUMBER,	0,
    TFLOAT,		BNUMBER,	0,
    TDOUBLE,	BNUMBER,	0,
    TIND,		BIND,		0,
    -1,		0,		0,
};
@

<<global tfunct>>=
long	tfunct[1] =
{
    BFUNC,
};
@

<<global tindir>>=
long	tindir[1] =
{
    BIND,
};
@

<<global tdot>>=
long	tdot[1] =
{
    BSTRUCT|BUNION,
};
@

<<global tnot>>=
long	tnot[1] =
{
    BNUMBER|BIND,
};
@

<<global targ>>=
long	targ[1] =
{
    BNUMBER|BIND|BSTRUCT|BUNION,
};
@

<<global tab>>=
char	tab[NTYPE][NTYPE] =
{
/*TXXX*/	{ 0,
        },

/*TCHAR*/	{ 0,	TCHAR, TUCHAR, TSHORT, TUSHORT, TINT, TUINT, TLONG,
            TULONG, TVLONG, TUVLONG, TFLOAT, TDOUBLE, TIND,
        },
/*TUCHAR*/	{ 0,	TUCHAR, TUCHAR, TUSHORT, TUSHORT, TUINT, TUINT, TULONG,
            TULONG, TUVLONG, TUVLONG, TFLOAT, TDOUBLE, TIND,
        },
/*TSHORT*/	{ 0,	TSHORT, TUSHORT, TSHORT, TUSHORT, TINT, TUINT, TLONG,
            TULONG, TVLONG, TUVLONG, TFLOAT, TDOUBLE, TIND,
        },
/*TUSHORT*/	{ 0,	TUSHORT, TUSHORT, TUSHORT, TUSHORT, TUINT, TUINT, TULONG,
            TULONG, TUVLONG, TUVLONG, TFLOAT, TDOUBLE, TIND,
        },
/*TINT*/	{ 0,	TINT, TUINT, TINT, TUINT, TINT, TUINT, TLONG,
            TULONG, TVLONG, TUVLONG, TFLOAT, TDOUBLE, TIND,
        },
/*TUINT*/	{ 0,	TUINT, TUINT, TUINT, TUINT, TUINT, TUINT, TULONG,
            TULONG, TUVLONG, TUVLONG, TFLOAT, TDOUBLE, TIND,
        },
/*TLONG*/	{ 0,	TLONG, TULONG, TLONG, TULONG, TLONG, TULONG, TLONG,
            TULONG, TVLONG, TUVLONG, TFLOAT, TDOUBLE, TIND,
        },
/*TULONG*/	{ 0,	TULONG, TULONG, TULONG, TULONG, TULONG, TULONG, TULONG,
            TULONG, TUVLONG, TUVLONG, TFLOAT, TDOUBLE, TIND,
        },
/*TVLONG*/	{ 0,	TVLONG, TUVLONG, TVLONG, TUVLONG, TVLONG, TUVLONG, TVLONG,
            TUVLONG, TVLONG, TUVLONG, TFLOAT, TDOUBLE, TIND,
        },
/*TUVLONG*/	{ 0,	TUVLONG, TUVLONG, TUVLONG, TUVLONG, TUVLONG, TUVLONG, TUVLONG,
            TUVLONG, TUVLONG, TUVLONG, TFLOAT, TDOUBLE, TIND,
        },
/*TFLOAT*/	{ 0,	TFLOAT, TFLOAT, TFLOAT, TFLOAT, TFLOAT, TFLOAT, TFLOAT,
            TFLOAT, TFLOAT, TFLOAT, TFLOAT, TDOUBLE, TIND,
        },
/*TDOUBLE*/	{ 0,	TDOUBLE, TDOUBLE, TDOUBLE, TDOUBLE, TDOUBLE, TDOUBLE, TDOUBLE,
            TDOUBLE, TDOUBLE, TDOUBLE, TFLOAT, TDOUBLE, TIND,
        },
/*TIND*/	{ 0,	TIND, TIND, TIND, TIND, TIND, TIND, TIND,
             TIND, TIND, TIND, TIND, TIND, TIND,
        },
};
@

<<function urk>>=
void
urk(char *name, int max, int i)
{
    if(i >= max) {
        fprint(2, "bad tinit: %s %d>=%d\n", name, i, max);
        exits("init");
    }
}
@

<<function tinit>>=
void
tinit(void)
{
    int *ip;
    Init *p;

    for(p=thashinit; p->code >= 0; p++) {
        urk("thash", nelem(thash), p->code);
        thash[p->code] = p->value;
    }
    for(p=bnamesinit; p->code >= 0; p++) {
        urk("bnames", nelem(bnames), p->code);
        bnames[p->code] = p->s;
    }
    for(p=tnamesinit; p->code >= 0; p++) {
        urk("tnames", nelem(tnames), p->code);
        tnames[p->code] = p->s;
    }
    for(p=gnamesinit; p->code >= 0; p++) {
        urk("gnames", nelem(gnames), p->code);
        gnames[p->code] = p->s;
    }
    for(p=qnamesinit; p->code >= 0; p++) {
        urk("qnames", nelem(qnames), p->code);
        qnames[p->code] = p->s;
    }
    for(p=cnamesinit; p->code >= 0; p++) {
        urk("cnames", nelem(cnames), p->code);
        cnames[p->code] = p->s;
    }
    for(p=onamesinit; p->code >= 0; p++) {
        urk("onames", nelem(onames), p->code);
        onames[p->code] = p->s;
    }
    for(ip=typeiinit; *ip>=0; ip++) {
        urk("typei", nelem(typei), *ip);
        typei[*ip] = 1;
    }
    for(ip=typeuinit; *ip>=0; ip++) {
        urk("typeu", nelem(typeu), *ip);
        typeu[*ip] = 1;
    }
    for(ip=typesuvinit; *ip>=0; ip++) {
        urk("typesuv", nelem(typesuv), *ip);
        typesuv[*ip] = true;
    }
    for(ip=typeilpinit; *ip>=0; ip++) {
        urk("typeilp", nelem(typeilp), *ip);
        typeilp[*ip] = 1;
    }
    for(ip=typechlinit; *ip>=0; ip++) {
        urk("typechl", nelem(typechl), *ip);
        typechl[*ip] = 1;
        typechlv[*ip] = 1;
        typechlvp[*ip] = 1;
    }
    for(ip=typechlpinit; *ip>=0; ip++) {
        urk("typechlp", nelem(typechlp), *ip);
        typechlp[*ip] = 1;
        typechlvp[*ip] = 1;
    }
    for(ip=typechlpfdinit; *ip>=0; ip++) {
        urk("typechlpfd", nelem(typechlpfd), *ip);
        typechlpfd[*ip] = 1;
    }
    for(ip=typecinit; *ip>=0; ip++) {
        urk("typec", nelem(typec), *ip);
        typec[*ip] = 1;
    }
    for(ip=typehinit; *ip>=0; ip++) {
        urk("typeh", nelem(typeh), *ip);
        typeh[*ip] = 1;
    }
    for(ip=typeilinit; *ip>=0; ip++) {
        urk("typeil", nelem(typeil), *ip);
        typeil[*ip] = 1;
    }
    for(ip=typevinit; *ip>=0; ip++) {
        urk("typev", nelem(typev), *ip);
        typev[*ip] = 1;
        typechlv[*ip] = 1;
        typechlvp[*ip] = 1;
    }
    for(ip=typefdinit; *ip>=0; ip++) {
        urk("typefd", nelem(typefd), *ip);
        typefd[*ip] = 1;
    }
    for(ip=typeafinit; *ip>=0; ip++) {
        urk("typeaf", nelem(typeaf), *ip);
        typeaf[*ip] = 1;
    }
    for(ip=typesuinit; *ip >= 0; ip++) {
        urk("typesu", nelem(typesu), *ip);
        typesu[*ip] = 1;
    }
    for(p=tasigninit; p->code >= 0; p++) {
        urk("tasign", nelem(tasign), p->code);
        tasign[p->code] = p->value;
    }
    for(p=tasaddinit; p->code >= 0; p++) {
        urk("tasadd", nelem(tasadd), p->code);
        tasadd[p->code] = p->value;
    }
    for(p=tcastinit; p->code >= 0; p++) {
        urk("tcast", nelem(tcast), p->code);
        tcast[p->code] = p->value;
    }
    for(p=taddinit; p->code >= 0; p++) {
        urk("tadd", nelem(tadd), p->code);
        tadd[p->code] = p->value;
    }
    for(p=tsubinit; p->code >= 0; p++) {
        urk("tsub", nelem(tsub), p->code);
        tsub[p->code] = p->value;
    }
    for(p=tmulinit; p->code >= 0; p++) {
        urk("tmul", nelem(tmul), p->code);
        tmul[p->code] = p->value;
    }
    for(p=tandinit; p->code >= 0; p++) {
        urk("tand", nelem(tand), p->code);
        tand[p->code] = p->value;
    }
    for(p=trelinit; p->code >= 0; p++) {
        urk("trel", nelem(trel), p->code);
        trel[p->code] = p->value;
    }
    
    /* 32-bit defaults */
    typeword = typechlp;
    typeswitch = typechl;
    typecmplx = typesuv;
}
@

<<function deadhead>>=
/*
 * return 1 if it is impossible to jump into the middle of n.
 */
static int
deadhead(Node *n, int caseok)
{
loop:
    if(n == Z)
        return 1;
    switch(n->op) {
    case OLIST:
        if(!deadhead(n->left, caseok))
            return 0;
    rloop:
        n = n->right;
        goto loop;

    case ORETURN:
        break;

    case OLABEL:
        return 0;

    case OGOTO:
        break;

    case OCASE:
        if(!caseok)
            return 0;
        goto rloop;

    case OSWITCH:
        return deadhead(n->right, 1);

    case OWHILE:
    case ODWHILE:
        goto rloop;

    case OFOR:
        goto rloop;

    case OCONTINUE:
        break;

    case OBREAK:
        break;

    case OIF:
        return deadhead(n->right->left, caseok) && deadhead(n->right->right, caseok);

    case OSET:
    case OUSED:
        break;
    }
    return 1;
}
@

<<function deadheads>>=
int
deadheads(Node *c)
{
    return deadhead(c->left, 0) && deadhead(c->right, 0);
}
@

<<function mixedasop>>=
int
mixedasop(Type *l, Type *r)
{
    return !typefd[l->etype] && typefd[r->etype];
}
@


%-------------------------------------------------------------

<<cc/sub.c>>=
#include	"cc.h"

int	simpleg(long);
long	dotoffset(Type*, Type*, Node*);

extern	char	typechlvp[];
extern	char	typec[];
extern	char	typeh[];
extern	char	tab[NTYPE][NTYPE];

<<function new>>

<<function new1>>

<<function prtree>>

<<function prtree1>>

<<function typ>>

<<function copytyp>>

<<function garbt>>

<<function simpleg>>

<<function simplec>>

<<function simplet>>

<<function stcompat>>

<<function tcompat>>

<<function makedot>>

<<function dotsearch>>

<<function dotoffset>>

<<function allfloat>>

<<function constas>>

<<function typeext1>>

<<function typeext>>

<<function nocast>>

<<function nilcast>>

<<function arith>>

<<function simplifyshift>>

<<function side>>

<<function vconst>>

<<function log2>>

<<function vlog>>

<<function topbit>>

<<function relcon>>

<<function relindex>>

<<function invert>>

<<function bitno>>

<<function typebitor>>

<<function diag>>

<<function warn>>

<<function fatal>>

<<global thash1>>
<<global thash2>>
<<global thash3>>
<<global thash>>
<<global thashinit>>

<<global bnames>>
<<global bnamesinit>>

<<global tnames>>
<<global tnamesinit>>

<<global gnames>>
<<global gnamesinit>>

<<global qnames>>
<<global qnamesinit>>
<<global cnames>>
<<global cnamesinit>>

<<global onames>>
<<global onamesinit>>

<<global comrel>>
<<global invrel>>
<<global logrel>>

<<global typei>>
<<global typeiinit>>
<<global typeu>>
<<global typeuinit>>

<<global typesuv>>
<<global typesuvinit>>

<<global typeilp>>
<<global typeilpinit>>

<<global typechl>>
<<global typechlv>>
<<global typechlvp>>
<<global typechlinit>>

<<global typechlp>>
<<global typechlpinit>>

<<global typechlpfd>>
<<global typechlpfdinit>>

<<global typec>>
<<global typecinit>>

<<global typeh>>
<<global typehinit>>

<<global typeil>>
<<global typeilinit>>

<<global typev>>
<<global typevinit>>

<<global typefd>>
<<global typefdinit>>

<<global typeaf>>
<<global typeafinit>>

<<global typesu>>
<<global typesuinit>>

<<global tasign>>
<<global tasigninit>>

<<global tasadd>>
<<global tasaddinit>>

<<global tcast>>
<<global tcastinit>>

<<global tadd>>
<<global taddinit>>

<<global tsub>>
<<global tsubinit>>

<<global tmul>>
<<global tmulinit>>

<<global tand>>
<<global tandinit>>

<<global trel>>
<<global trelinit>>

<<global tfunct>>

<<global tindir>>

<<global tdot>>

<<global tnot>>

<<global targ>>

<<global tab>>

<<function urk>>

<<function tinit>>

<<function deadhead>>

<<function deadheads>>

<<function mixedasop>>
@


\subsection*{[[cc/bits.c]]}

%-------------------------------------------------------------

<<cc/bits.c>>=
#include	"cc.h"

<<function bor>>

<<function bany>>

<<function beq>>

<<function bnum>>

<<function blsh>>

<<function bset>>
@


\subsection*{[[cc/lex.c]]}

%-------------------------------------------------------------

<<cc/lex.c>>=
#include	"cc.h"
#include	"y.tab.h"

int	compile(char*, char**, int);
void	syminit(Sym*);
int	mpatov(char*, vlong*);
long	getr(void);
long	escchar(long, int, int);
void	cinit(void);

int	Oconv(Fmt*);
int	Lconv(Fmt*);
int	Tconv(Fmt*);
int	FNconv(Fmt*);
int	Qconv(Fmt*);
int	VBconv(Fmt*);

void	setinclude(char*);


#ifndef	CPP
<<constant CPP>>
#endif

<<function main>>

<<function compile>>


<<function pushio>>

<<function newio>>

<<function newfile>>


<<function slookup>>

<<function lookup>>

<<function syminit>>

<<constant EOF>>
<<constant IGN>>
<<constant ESC>>
<<function GETC>>

<<enum numxxx>>

<<function yylex>>


<<function mpatov>>

<<function getc>>

<<function getr>>

<<function getnsc>>

<<function unget>>

<<function escchar>>

<<global itab>>

<<function cinit>>

<<function filbuf>>



<<function Oconv>>

<<struct Atab>>

<<function Lconv>>

<<function Tconv>>

<<function FNconv>>

<<function Qconv>>

<<function VBconv>>

<<function setinclude>>
@


\subsection*{[[cc/compat.c]]}

%<<function calloc>>=
%//void*
%//calloc(ulong m, ulong n)
%//{
%//    return alloc(m*n);
%//}
%@
%
%<<function realloc>>=
%//void*
%//realloc(void*, ulong)
%//{
%//    fprint(2, "realloc called\n");
%//    abort();
%//    return 0;
%//}
%@
%
%<<function mallocz>>=
%/* needed when profiling */
%//void*
%//mallocz(ulong size, int clr)
%//{
%//    void *v;
%//
%//    v = alloc(size);
%//    if(clr && v != nil)
%//        memset(v, 0, size);
%//    return v;
%//}
%@


%-------------------------------------------------------------

<<cc/compat.c>>=
#include	"cc.h"

//#include	"compat"
//TODO copy paste with aa/, maybe could factorize with another lib?
//

int
myaccess(char *f)
{
 return access(f, AEXIST);
}


int
mycreat(char *n, int p)
{

 return create(n, 1, p);
}

int
mywait(int *s)
{
 int p;
 Waitmsg *w;

 if((w = wait()) == nil)
  return -1;
 else{
  p = w->pid;
  *s = 0;
  if(w->msg[0])
   *s = 1;
  free(w);
  return p;
 }
}

bool
systemtype(int sys)
{
 return sys & Plan9;
}

int
pathchar(void)
{
 return '/';
}

<<function malloc>>

<<function free>>

<<function setmalloctag>>
@


\subsection*{[[cc/acid.c]]}

%-------------------------------------------------------------

<<cc/acid.c>>=
#include "cc.h"

<<global kwd>>

<<function amap>>

<<function acidsue>>

<<function acidfun>>

<<global acidchar>>
<<global acidcinit>>

<<function acidinit>>

<<function acidmember>>

<<function acidtype>>

<<function acidvar>>
@


\subsection*{[[cc/pickle.c]]}

%-------------------------------------------------------------

<<cc/pickle.c>>=
#include "cc.h"

<<global kwd (cc/pickle.c)>>
<<global picklestr>>

<<function pmap>>

<<function picklesue>>

<<global picklechar>>
<<global picklecinit>>

<<function pickleinit>>

<<function picklemember>>

<<function pickletype>>

@


\subsection*{[[cc/com64.c]]}

%-------------------------------------------------------------

<<cc/com64.c>>=
#include "cc.h"

<<constant FNX>>

<<global nodaddv>>
<<global nodsubv>>
<<global nodmulv>>
<<global noddivv>>
<<global noddivvu>>
<<global nodmodv>>
<<global nodmodvu>>
<<global nodlshv>>
<<global nodrshav>>
<<global nodrshlv>>
<<global nodandv>>
<<global nodorv>>
<<global nodxorv>>
<<global nodnegv>>
<<global nodcomv>>

<<global nodtestv>>
<<global nodeqv>>
<<global nodnev>>
<<global nodlev>>
<<global nodltv>>
<<global nodgev>>
<<global nodgtv>>
<<global nodhiv>>
<<global nodhsv>>
<<global nodlov>>
<<global nodlsv>>

<<global nodf2v>>
<<global nodd2v>>
<<global nodp2v>>
<<global nodsi2v>>
<<global nodui2v>>
<<global nodsl2v>>
<<global nodul2v>>
<<global nodsh2v>>
<<global noduh2v>>
<<global nodsc2v>>
<<global noduc2v>>

<<global nodv2f>>
<<global nodv2d>>
<<global nodv2ui>>
<<global nodv2si>>
<<global nodv2ul>>
<<global nodv2sl>>
<<global nodv2uh>>
<<global nodv2sh>>
<<global nodv2uc>>
<<global nodv2sc>>

<<global nodvpp>>
<<global nodppv>>
<<global nodvmm>>
<<global nodmmv>>

<<global nodvasop>>

<<global etconv>>
<<global initetconv>>

<<function fvn>>

<<function com64init>>

<<function com64>>

<<function bool64>>

<<function convvtox>>
@

\subsection*{[[cc2/pswt.c]]}

%-------------------------------------------------------------

<<cc2/pswt.c>>=
#include "gc.h"

<<function swcmp>>

<<function doswit>>

<<function casf>>

<<function outlstring>>

<<function nullwarn>>

<<function ieeedtod>>
@


\subsection*{[[cc/dcl.c]]}

%-------------------------------------------------------------

<<cc/dcl.c>>=
#include "cc.h"

Sym*	mkstatic(Sym*);
Type*	tcopy(Type*);
Node*	doinit(Sym*, Type*, long, Node*);
Node*	init1(Sym*, Type*, long, int);
Node*	newlist(Node*, Node*);
void	walkparam(Node*, int);
Type*	fnproto(Node*);
Type*	fnproto1(Node*);
int	anyproto(Node*);
void	dbgdecl(Sym*);
Decl*	push(void);
Decl*	push1(Sym*);
int	rsametype(Type*, Type*, int, int);
Type*	paramconv(Type*, int);
void	adecl(int, Type*, Sym*);
void	pdecl(int, Type*, Sym*);
void	tmerge(Type*, Sym*);

<<function dodecl>>

<<function mkstatic>>

<<function tcopy>>

<<function doinit>>

<<function peekinit>>

<<function nextinit>>

<<function isstruct>>

<<function init1>>

<<function newlist>>

<<function sualign>>

<<function round>>

<<function ofnproto>>

<<constant ANSIPROTO>>
<<constant OLDPROTO>>

<<function argmark>>

<<function walkparam>>

<<function markdcl>>

<<function revertdcl>>

<<function fnproto>>

<<function anyproto>>

<<function fnproto1>>

<<function dbgdecl>>

<<function push>>

<<function push1>>

<<function sametype>>

<<function rsametype>>

typedef struct Typetab Typetab;

<<struct Typetab>>

<<function sigind>>

<<function signat>>

<<function signature>>

<<function sign>>

<<function snap>>

<<function dotag>>

<<function dcllabel>>

<<function paramconv>>

<<function adecl>>

<<function pdecl>>

<<function xdecl>>

<<function tmerge>>

<<function edecl>>

<<function maxtype>>

<<function doenum>>

<<function symadjust>>

<<function contig>>
@


\subsection*{[[cc/funct.c]]}

%-------------------------------------------------------------

<<cc/funct.c>>=
#include	"cc.h"

typedef	struct	Ftab	Ftab;
typedef	struct	Gtab	Gtab;

<<struct Ftab>>
<<struct Gtab>>

<<global gtabinit>>
<<global ftabinit>>

<<function isfunct>>
<<function dclfunct>>
@


\subsection*{[[cc/scon.c]]}

%-------------------------------------------------------------

<<cc/scon.c>>=
#include "cc.h"

void	acom1(vlong, Node*);
void	acom2(Node*, Type*);
int	acomcmp1(const void*, const void*);
int	acomcmp2(const void*, const void*);
int	addo(Node*);

<<function acast>>


<<function evconst>>

<<function acom>>

<<function acomcmp1>>

<<function acomcmp2>>

<<function acom2>>

<<function acom1>>

<<function addo>>
@


\subsection*{[[cc/dpchk.c]]}

<<enum fxxx>>=
enum fxxx
{
    Fnone	= 0,

    Fl,
    Fvl,
    Fignor,
    Fstar,
    Fadj,

    Fverb	= 10,
};
@

<<struct Tprot>>=
struct	Tprot
{
    Type*	type;
    Bits	flag;
    Tprot*	link;
};
@

<<struct Tname>>=
struct	Tname
{
    char*	name;
    int	param;
    Tname*	link;
};
@

<<global indchar>>=
static	Type*	indchar;
@

<<global flagbits>>=
static	uchar	flagbits[512];
@

<<global fmtbuf>>=
static	char	fmtbuf[100];
@

<<global lastadj>>=
static	int	lastadj;
@

<<global lastverb>>=
static	int	lastverb;
@

<<global nstar>>=
static	int	nstar;
@

<<global tprot>>=
static	Tprot*	tprot;
@

<<global tname>>=
static	Tname*	tname;
@

<<function argflag>>=
void
argflag(int c, int v)
{

    switch(v) {
    case Fignor:
    case Fstar:
    case Fl:
    case Fvl:
        flagbits[c] = v;
        break;
    case Fverb:
        flagbits[c] = lastverb;
/*print("flag-v %c %d\n", c, lastadj);*/
        lastverb++;
        break;
    case Fadj:
        flagbits[c] = lastadj;
/*print("flag-l %c %d\n", c, lastadj);*/
        lastadj++;
        break;
    }
}
@

<<function getflag>>=
Bits
getflag(char *s)
{
    Bits flag;
    int f;
    char *fmt;
    Rune c;

    fmt = fmtbuf;
    flag = zbits;
    nstar = 0;
    for(;;) {
        s += chartorune(&c, s);
        fmt += runetochar(fmt, &c);
        if(c == 0 || c >= nelem(flagbits))
            break;
        f = flagbits[c];
        switch(f) {
        case Fnone:
            argflag(c, Fverb);
            f = flagbits[c];
            break;
        case Fstar:
            nstar++;
        case Fignor:
            continue;
        case Fl:
            if(bset(flag, Fl))
                flag = bor(flag, blsh(Fvl));
        }
        flag = bor(flag, blsh(f));
        if(f >= Fverb)
            break;
    }
    *fmt = 0;
    return flag;
}
@


<<function arginit>>=
void
arginit(void)
{
    int i;

/* debug['F'] = 1;*/
/* debug['w'] = 1;*/

    lastadj = Fadj;
    lastverb = Fverb;
    indchar = typ(TIND, types[TCHAR]);

    memset(flagbits, Fnone, sizeof(flagbits));

    for(i='0'; i<='9'; i++)
        argflag(i, Fignor);
    argflag('.', Fignor);
    argflag('#', Fignor);
    argflag('u', Fignor);
    argflag('h', Fignor);
    argflag('+', Fignor);
    argflag('-', Fignor);

    argflag('*', Fstar);
    argflag('l', Fl);

    argflag('o', Fverb);
    flagbits['x'] = flagbits['o'];
    flagbits['X'] = flagbits['o'];
}
@


<<function nextarg>>=
Node*
nextarg(Node *n, Node **a)
{
    if(n == Z) {
        *a = Z;
        return Z;
    }
    if(n->op == OLIST) {
        *a = n->left;
        return n->right;
    }
    *a = n;
    return Z;
}
@

<<function checkargs>>=
void
checkargs(Node *nn, char *s, int pos)
{
    Node *a, *n;
    Bits flag;
    Tprot *l;

    if(!debug['F'])
        return;
    n = nn;
    for(;;) {
        s = strchr(s, '%');
        if(s == 0) {
            nextarg(n, &a);
            if(a != Z)
                warn(nn, "more arguments than format %T",
                    a->type);
            return;
        }
        s++;
        flag = getflag(s);
        while(nstar > 0) {
            n = nextarg(n, &a);
            pos++;
            nstar--;
            if(a == Z) {
                warn(nn, "more format than arguments %s",
                    fmtbuf);
                return;
            }
            if(a->type == T)
                continue;
            if(!sametype(types[TINT], a->type) &&
               !sametype(types[TUINT], a->type))
                warn(nn, "format mismatch '*' in %s %T, arg %d",
                    fmtbuf, a->type, pos);
        }
        for(l=tprot; l; l=l->link)
            if(sametype(types[TVOID], l->type)) {
                if(beq(flag, l->flag)) {
                    s++;
                    goto loop;
                }
            }

        n = nextarg(n, &a);
        pos++;
        if(a == Z) {
            warn(nn, "more format than arguments %s",
                fmtbuf);
            return;
        }
        if(a->type == 0)
            continue;
        for(l=tprot; l; l=l->link)
            if(sametype(a->type, l->type)) {
/*print("checking %T/%ulx %T/%ulx\n", a->type, flag.b[0], l->type, l->flag.b[0]);*/
                if(beq(flag, l->flag))
                    goto loop;
            }
        warn(nn, "format mismatch %s %T, arg %d", fmtbuf, a->type, pos);
    loop:;
    }
}
@

<<function dpcheck>>=
void
dpcheck(Node *n)
{
    char *s;
    Node *a, *b;
    Tname *l;
    int i;

    if(n == Z)
        return;
    b = n->left;
    if(b == Z || b->op != ONAME)
        return;
    s = b->sym->name;
    for(l=tname; l; l=l->link)
        if(strcmp(s, l->name) == 0)
            break;
    if(l == 0)
        return;

    i = l->param;
    b = n->right;
    while(i > 0) {
        b = nextarg(b, &a);
        i--;
    }
    if(a == Z) {
        warn(n, "cant find format arg");
        return;
    }
    if(!sametype(indchar, a->type)) {
        warn(n, "format arg type %T", a->type);
        return;
    }
    if(a->op != OADDR || a->left->op != ONAME || a->left->sym != symstring) {
/*		warn(n, "format arg not constant string");*/
        return;
    }
    s = a->left->cstring;
    checkargs(b, s, l->param);
}
@

%<<function newprot>>=
%//void
%//newprot(Sym *m, Type *t, char *s)
%//{
%//    Bits flag;
%//    Tprot *l;
%//
%//    if(t == T) {
%//        warn(Z, "%s: newprot: type not defined", m->name);
%//        return;
%//    }
%//    flag = getflag(s);
%//    for(l=tprot; l; l=l->link)
%//        if(beq(flag, l->flag) && sametype(t, l->type))
%//            return;
%//    l = alloc(sizeof(*l));
%//    l->type = t;
%//    l->flag = flag;
%//    l->link = tprot;
%//    tprot = l;
%//}
%@
%
%<<function newname>>=
%//void
%//newname(char *s, int p)
%//{
%//    Tname *l;
%//
%//    for(l=tname; l; l=l->link)
%//        if(strcmp(l->name, s) == 0) {
%//            if(l->param != p)
%//                yyerror("vargck %s already defined\n", s);
%//            return;
%//        }
%//    l = alloc(sizeof(*l));
%//    l->name = s;
%//    l->param = p;
%//    l->link = tname;
%//    tname = l;
%//}
%@
%
%<<function pragvararg>>=
%//void
%//pragvararg(void)
%//{
%//    Sym *s;
%//    int n, c;
%//    char *t;
%//    Rune r;
%//    Type *ty;
%//
%//    if(!debug['F'])
%//        goto out;
%//    s = getsym();
%//    if(s && strcmp(s->name, "argpos") == 0)
%//        goto ckpos;
%//    if(s && strcmp(s->name, "type") == 0)
%//        goto cktype;
%//    if(s && strcmp(s->name, "flag") == 0)
%//        goto ckflag;
%//    yyerror("syntax in #pragma varargck");
%//    goto out;
%//
%//ckpos:
%///*#pragma	varargck	argpos	warn	2*/
%//    s = getsym();
%//    if(s == S)
%//        goto bad;
%//    n = getnsn();
%//    if(n < 0)
%//        goto bad;
%//    newname(s->name, n);
%//    goto out;
%//
%//ckflag:
%///*#pragma	varargck	flag	'c'*/
%//    c = getnsc();
%//    if(c != '\'')
%//        goto bad;
%//    c = getr();
%//    if(c == '\\')
%//        c = getr();
%//    else if(c == '\'')
%//        goto bad;
%//    if(c == '\n')
%//        goto bad;
%//    if(getc() != '\'')
%//        goto bad;
%//    argflag(c, Fignor);
%//    goto out;
%//
%//cktype:
%///*#pragma	varargck	type	O	int*/
%//    c = getnsc();
%//    if(c != '"')
%//        goto bad;
%//    t = fmtbuf;
%//    for(;;) {
%//        r = getr();
%//        if(r == ' ' || r == '\n')
%//            goto bad;
%//        if(r == '"')
%//            break;
%//        t += runetochar(t, &r);
%//    }
%//    *t = 0;
%//    t = strdup(fmtbuf);
%//    s = getsym();
%//    if(s == S)
%//        goto bad;
%//    ty = s->type;
%//    while((c = getnsc()) == '*')
%//        ty = typ(TIND, ty);
%//    unget(c);
%//    newprot(s, ty, t);
%//    goto out;
%//
%//bad:
%//    yyerror("syntax in #pragma varargck");
%//
%//out:
%//    while(getnsc() != '\n')
%//        ;
%//}
%@
%
%<<function pragpack>>=
%//void
%//pragpack(void)
%//{
%//    Sym *s;
%//
%//    packflg = 0;
%//    s = getsym();
%//    if(s) {
%//        packflg = atoi(s->name+1);
%//        if(strcmp(s->name, "on") == 0 ||
%//           strcmp(s->name, "yes") == 0)
%//            packflg = 1;
%//    }
%//    while(getnsc() != '\n')
%//        ;
%//    if(debug['f'])
%//        if(packflg)
%//            print("%4ld: pack %d\n", lineno, packflg);
%//        else
%//            print("%4ld: pack off\n", lineno);
%//}
%@
%
%<<function pragfpround>>=
%//void
%//pragfpround(void)
%//{
%//    Sym *s;
%//
%//    fproundflg = 0;
%//    s = getsym();
%//    if(s) {
%//        fproundflg = atoi(s->name+1);
%//        if(strcmp(s->name, "on") == 0 ||
%//           strcmp(s->name, "yes") == 0)
%//            fproundflg = 1;
%//    }
%//    while(getnsc() != '\n')
%//        ;
%//    if(debug['f'])
%//        if(fproundflg)
%//            print("%4ld: fproundflg %d\n", lineno, fproundflg);
%//        else
%//            print("%4ld: fproundflg off\n", lineno);
%//}
%@
%
%<<function pragprofile>>=
%//void
%//pragprofile(void)
%//{
%//    Sym *s;
%//
%//    profileflg = false;
%//    s = getsym();
%//    if(s) {
%//        profileflg = atoi(s->name+1);
%//        if(strcmp(s->name, "on") == 0 ||
%//           strcmp(s->name, "yes") == 0)
%//            profileflg = true;
%//    }
%//    while(getnsc() != '\n')
%//        ;
%//    if(debug['f'])
%//        if(profileflg)
%//            print("%4ld: profileflg %d\n", lineno, profileflg);
%//        else
%//            print("%4ld: profileflg off\n", lineno);
%//}
%@
%
%<<function pragincomplete>>=
%//void
%//pragincomplete(void)
%//{
%//    Sym *s;
%//    Type *t;
%//    int istag, w, et;
%//
%//    istag = 0;
%//    s = getsym();
%//    if(s == nil)
%//        goto out;
%//    et = 0;
%//    w = s->lexical;
%//    if(w == LSTRUCT)
%//        et = TSTRUCT;
%//    else if(w == LUNION)
%//        et = TUNION;
%//    if(et != 0){
%//        s = getsym();
%//        if(s == nil){
%//            yyerror("missing struct/union tag in pragma incomplete");
%//            goto out;
%//        }
%//        if(s->lexical != LNAME && s->lexical != LTYPE){
%//            yyerror("invalid struct/union tag: %s", s->name);
%//            goto out;
%//        }
%//        dotag(s, et, 0);
%//        istag = 1;
%//    }else if(strcmp(s->name, "_off_") == 0){
%//        debug['T'] = 0;
%//        goto out;
%//    }else if(strcmp(s->name, "_on_") == 0){
%//        debug['T'] = 1;
%//        goto out;
%//    }
%//    t = s->type;
%//    if(istag)
%//        t = s->suetag;
%//    if(t == T)
%//        yyerror("unknown type %s in pragma incomplete", s->name);
%//    else if(!typesu[t->etype])
%//        yyerror("not struct/union type in pragma incomplete: %s", s->name);
%//    else
%//        t->garb |= GINCOMPLETE;
%//out:
%//    while(getnsc() != '\n')
%//        ;
%//    if(debug['f'])
%//        print("%s incomplete\n", s->name);
%//}
%@


%-------------------------------------------------------------

<<cc/dpchk.c>>=
#include	"cc.h"
#include	"y.tab.h"

<<enum fxxx>>

typedef	struct	Tprot	Tprot;
<<struct Tprot>>

typedef	struct	Tname	Tname;
<<struct Tname>>

<<global indchar>>
<<global flagbits>>
<<global fmtbuf>>
<<global lastadj>>
<<global lastverb>>
<<global nstar>>
<<global tprot>>
<<global tname>>

<<function argflag>>

<<function getflag>>

<<function arginit>>

<<function nextarg>>

<<function checkargs>>

<<function dpcheck>>
@


\subsection*{[[cc/com.c]]}

%-------------------------------------------------------------

<<cc/com.c>>=
#include "cc.h"

int	tcomd(Node*);
int	tcomx(Node*);
int	tlvalue(Node*);

typedef struct Com Com;
typedef struct Big Big;

<<struct Com>>

int compar(Node*, int);
static void comma(Node*);
static Node*	commas(Com*, Node*);

<<function complex>>

<<enum _anon_ (cc/com.c)>>

<<function tcom>>

<<function tcomo>>

<<function tcoma>>

<<function tcomd>>

<<function tcomx>>

<<function tlvalue>>

<<function comargs>>

<<function commas>>

<<function comma>>

<<function ccom>>

<<global cmps>>

<<struct Big>>
<<function cmp>>
<<function add>>

<<function big>>

<<function compar>>

@


\subsection*{[[cc2/pgen.c]]}


<<function supgen>>=
void
supgen(Node *n)
{
    int owarn;
    long spc;
    Prog *sp;

    if(n == Z)
        return;
    suppress++;
    owarn = warnreach;
    warnreach = 0;
    spc = pc;
    sp = lastp;
    gen(n);
    lastp = sp;
    pc = spc;
    sp->link = nil;
    suppress--;
    warnreach = owarn;
}
@

<<function uncomma>>=
Node*
uncomma(Node *n)
{
    while(n != Z && n->op == OCOMMA) {
        cgen(n->left, Z);
        n = n->right;
    }
    return n;
}
@


<<function bcomplex>>=
int
bcomplex(Node *n, Node *c)
{
//    Node *b, nod;

    complex(n);
    if(n->type != T)
    if(tcompat(n, T, n->type, tnot))
        n->type = T;
    if(n->type == T) {
        gbranch(OGOTO);
        return 0;
    }
    if(c != Z && n->op == OCONST && deadheads(c))
        return 1;

    /* this is not quite right yet, so ignore it for now */
//    if(0 && newvlongcode && typev[n->type->etype] && machcap(Z)) {
//        b = &nod;
//        b->op = ONE;
//        b->left = n;
//        b->right = new(0, Z, Z);
//        *b->right = *nodconst(0);
//        b->right->type = n->type;
//        b->type = types[TLONG];
//        cgen(b, Z);
//        return 0;
//    }

    bool64(n);
    boolgen(n, 1, Z);
    return 0;
}
@


%-------------------------------------------------------------

<<cc2/pgen.c>>=
#include "gc.h"

void	gen(Node*);
void	usedset(Node*, int);
int	bcomplex(Node*, Node*);

<<function codgen>>

<<function supgen>>

<<function uncomma>>

<<function gen>>

<<function usedset>>

<<function bcomplex>>
@


\section{[[8c/]]}

\subsection*{[[8c/enam.c]]}

%-------------------------------------------------------------

<<8c/enam.c>>=
<<global anames>>
@


\subsection*{[[8c/gc.h]]}


<<constant FNX (8c/gc.h)>>=
#define	FNX		100
@

<<struct Idx>>=
struct Idx
{
    Node*	regtree;
    Node*	basetree;
    short	scale;
    short	reg;
    short	ptr;
};
@


<<constant INDEXED>>=
#define	INDEXED	9
@



<<struct Case>>=
struct	Case
{
    Case*	link;
    vlong	val;
    long	label;
    char	def;
    char isv;
};
@

<<constant C>>=
#define	C	((Case*)nil)
@

<<struct C1>>=
struct	C1
{
    vlong	val;
    long	label;
};
@




<<constant NRGN>>=
#define	NRGN	600
@

<<struct Rgn>>=
struct	Rgn
{
    Reg*	enter;
    short	cost;
    short	varno;
    short	regno;
};
@


<<function LOAD>>=
#define	LOAD(r)		(~r->refbehind.b[z] & r->refahead.b[z])
@

<<function STORE>>=
#define	STORE(r)	(~r->calbehind.b[z] & r->calahead.b[z])
@

<<macro bset>>=
//@Scheck: maybe dead, dupe with bits.c function
#define	bset(a,n)	((a).b[(n)/32]&(1L<<(n)%32))
@

<<constant CLOAD>>=
#define	CLOAD	5
@

<<constant CREF>>=
#define	CREF	5
@

<<constant CINF>>=
#define	CINF	1000
@

<<constant LOOP>>=
#define	LOOP	3
@

<<constant D_HI>>=
//#define	D_HI	D_NONE
@

<<constant D_LO>>=
//#define	D_LO	D_NONE
@

<<constant rplink>>=
/* wrecklessly steal a field */

#define	rplink	label
@

%<<function BLOAD>>=
%//#define	BLOAD(r)	band(bnot(r->refbehind), r->refahead)
%@
%
%<<function BSTORE>>=
%//#define	BSTORE(r)	band(bnot(r->calbehind), r->calahead)
%@


%-------------------------------------------------------------

<<8c/gc.h>>=
#include	"../cc/cc.h"

#include	<common.out.h>
#include	<386/8.out.h>

<<constant SZ_CHAR>>
<<constant SZ_SHORT>>
<<constant SZ_INT>>
<<constant SZ_LONG>>
<<constant SZ_IND>>
<<constant SZ_FLOAT>>
<<constant SZ_VLONG>>
<<constant SZ_DOUBLE>>
<<constant FNX (8c/gc.h)>>

typedef	struct	Adr	Adr;
typedef	struct	Prog	Prog;
typedef	struct	Case	Case;
typedef	struct	C1	C1;
typedef	struct	Var	Var;
typedef	struct	Reg	Reg;
typedef	struct	Rgn	Rgn;

<<struct Idx>>
extern struct Idx idx;

<<struct Adr>>
<<constant A>>

<<constant INDEXED>>
<<struct Prog>>
<<constant P>>

<<struct Case>>
<<constant C>>

<<struct C1>>

<<struct Var>>

<<struct Reg>>
<<constant R>>

<<constant NRGN>>
<<struct Rgn>>

extern	long	breakpc;
extern	long	nbreak;
extern	Case*	cases;
extern	Node	constnode;
extern	Node	fconstnode;
extern	long	continpc;
extern	long	curarg;
extern	long	cursafe;
extern	Prog*	firstp;
extern	Prog*	lastp;
extern	long	maxargsafe;
extern	int	mnstring;
extern	Node*	nodrat;
extern	Node*	nodret;
extern	Node*	nodsafe;
extern	long	nrathole;
extern	long	nstring;
extern	Prog*	p;
extern	long	pc;
extern	Node	regnode;
extern	Node	fregnode0;
extern	Node	fregnode1;
extern	char	string[NSNAME];
extern	Sym*	symrathole;
extern	Node	znode;
extern	Prog	zprog;
extern	int	reg[D_NONE];
extern	long	exregoffset;
extern	long	exfregoffset;

<<function LOAD>>
<<function STORE>>

<<macro bset>>

<<constant CLOAD>>
<<constant CREF>>
<<constant CINF>>
<<constant LOOP>>

extern	Rgn	region[NRGN];
extern	Rgn*	rgp;
extern	int	nregion;
extern	int	nvar;

extern	Bits	externs;
extern	Bits	params;
extern	Bits	consts;
extern	Bits	addrs;

extern	long	regbits;
//extern	long	exregbits;

extern	int	change;
extern	int	suppress;

extern	Reg*	firstr;
extern	Reg*	lastr;
extern	Reg	zreg;
extern	Reg*	freer;
extern	Var	var[NVAR];
extern	long*	idom;
extern	Reg**	rpo2r;
extern	long	maxnr;

extern	char*	anames[];

/*
 * sgen.c
 */
void	codgen(Node*, Node*);
void	noretval(int);
void	xcom(Node*);

/*
 * cgen.c
 */
void	zeroregm(Node*);
void	cgen(Node*, Node*);
void	reglcgen(Node*, Node*, Node*);
void	lcgen(Node*, Node*);
void	boolgen(Node*, int, Node*);
void	sugen(Node*, Node*, long);
//int	needreg(Node*, int);

/*
 * cgen64.c
 */
int	vaddr(Node*, int);
void	loadpair(Node*, Node*);
int	cgen64(Node*, Node*);
void	testv(Node*, int);
Node*	hi64(Node*);
Node*	lo64(Node*);

/*
 * txt.c
 */
void	ginit(void);
void	gclean(void);
void	gargs(Node*, Node*, Node*);
Node*	nodconst(long);
int	nareg(int);
int	nodreg(Node*, Node*, int);
int	isreg(Node*, int);
void	regret(Node*, Node*);
void	regalloc(Node*, Node*, Node*);
void	regfree(Node*);
void	regialloc(Node*, Node*, Node*);
void	regsalloc(Node*, Node*);
void	regind(Node*, Node*);
void	gmove(Node*, Node*);
void	gins(int a, Node*, Node*);
void	fgopcode(int, Node*, Node*, int, int);
void	gopcode(int, Type*, Node*, Node*);
void	gbranch(int);
void	patch(Prog*, long);
int	sconst(Node*);
void	gpseudo(int, Sym*, Node*);
//void	gprep(Node*, Node*);

/*
 * swt.c
 */
void	doswit(Node*);
void	swit1(C1*, int, long, Node*);
void	casf(void);
void	bitload(Node*, Node*, Node*, Node*, Node*);
void	bitstore(Node*, Node*, Node*, Node*, Node*);
long	outstring(char*, long);
void	nullwarn(Node*, Node*);
void	gextern(Sym*, Node*, long, long);
void	outcode(void);
void	ieeedtod(Ieee*, double);

/*
 * list
 */
void	listinit(void);

/*
 * reg.c
 */
Reg*	rega(void);
void	regopt(Prog*);


/*
 * peep.c
 */
void	peep(void);
void	excise(Reg*);
int	copyu(Prog*, Adr*, Adr*);



<<constant D_HI>>
<<constant D_LO>>

/*
 * com64
 */
int	cond(int);
int	com64(Node*);
void	com64init(void);
void	bool64(Node*);

/*
 * div/mul
 */
void	sdivgen(Node*, Node*, Node*, Node*);
void	udivgen(Node*, Node*, Node*, Node*);
void	sdiv2(long, int, Node*, Node*);
void	smod2(long, int, Node*, Node*);
void	mulgen(Type*, Node*, Node*);
void	genmuladd(Node*, Node*, int, Node*);
void	shiftit(Type*, Node*, Node*);

#pragma	varargck	type	"A"	int
#pragma	varargck	type	"B"	Bits
#pragma	varargck	type	"D"	Adr*
#pragma	varargck	type	"P"	Prog*
#pragma	varargck	type	"R"	int
#pragma	varargck	type	"S"	char*

@


\subsection*{[[8c/machcap.c]]}

<<function machcap>>=
int
machcap(Node *n)
{
//	return 0;

    if(n == Z)
        return 1;	/* test */

    switch(n->op) {
    case OMUL:
    case OLMUL:
    case OASMUL:
    case OASLMUL:
        if(typechl[n->type->etype])
            return 1;
        if(typev[n->type->etype]) {
//		if(typev[n->type->etype] && n->right->op == OCONST) {
//			if(hi64v(n->right) == 0)
                return 1;
        }
        break;

    case OCOM:
    case ONEG:
    case OADD:
    case OAND:
    case OOR:
    case OSUB:
    case OXOR:
    case OASHL:
    case OLSHR:
    case OASHR:
        if(typechlv[n->left->type->etype])
            return 1;
        break;

    case OCAST:
        if(typev[n->type->etype]) {
            if(typechlp[n->left->type->etype])
                return 1;
        }
        else if(!typefd[n->type->etype]) {
            if(typev[n->left->type->etype])
                return 1;
        }
        break;

    case OCOND:
    case OCOMMA:
    case OLIST:
    case OANDAND:
    case OOROR:
    case ONOT:
    case ODOT:
        return 1;

    case OASADD:
    case OASSUB:
    case OASAND:
    case OASOR:
    case OASXOR:
        return 1;

    case OASASHL:
    case OASASHR:
    case OASLSHR:
        return 1;

    case OPOSTINC:
    case OPOSTDEC:
    case OPREINC:
    case OPREDEC:
        return 1;

    case OEQ:
    case ONE:
    case OLE:
    case OGT:
    case OLT:
    case OGE:
    case OHI:
    case OHS:
    case OLO:
    case OLS:
//print("%O\n", n->op);
        return 1;
    }
    return 0;
}
@


%-------------------------------------------------------------

<<8c/machcap.c>>=
#include "gc.h"

<<function machcap>>
@


\subsection*{[[8c/globals2.c]]}

<<global idx>>=
struct Idx idx;
@

<<global breakpc>>=
long	breakpc;
@

<<global nbreak>>=
long	nbreak;
@

<<global cases>>=
Case*	cases;
@

<<global constnode>>=
Node	constnode;
@

<<global fconstnode>>=
Node	fconstnode;
@

<<global continpc>>=
long	continpc;
@





<<global mnstring>>=
int	mnstring;
@

<<global nodrat>>=
Node*	nodrat;
@


<<global nodsafe>>=
Node*	nodsafe;
@

<<global nrathole>>=
long	nrathole;
@

<<global nstring>>=
long	nstring;
@



<<global regnode>>=
Node	regnode;
@

<<global fregnode0>>=
Node	fregnode0;
@

<<global fregnode1>>=
Node	fregnode1;
@

<<global string>>=
char	string[NSNAME];
@

<<global symrathole>>=
Sym*	symrathole;
@

<<global znode>>=
Node	znode;
@


<<global reg>>=
int	reg[D_NONE];
@

<<global exregoffset>>=
long	exregoffset;
@

<<global exfregoffset>>=
long	exfregoffset;
@

<<global region>>=
Rgn	region[NRGN];
@

<<global rgp>>=
Rgn*	rgp;
@

<<global nregion>>=
int	nregion;
@


<<global externs>>=
Bits	externs;
@

<<global params>>=
Bits	params;
@

<<global consts>>=
Bits	consts;
@

<<global addrs>>=
Bits	addrs;
@

<<global regbits>>=
long	regbits;
@

<<global exregbits>>=
//long	exregbits;
@

<<global change>>=
int	change;
@

<<global suppress>>=
int	suppress;
@

<<global firstr>>=
Reg*	firstr;
@

<<global lastr>>=
Reg*	lastr;
@

<<global zreg>>=
Reg	zreg;
@

<<global freer>>=
Reg*	freer;
@


<<global idom>>=
long*	idom;
@

<<global rpo2r>>=
Reg**	rpo2r;
@

<<global maxnr>>=
long	maxnr;
@


%-------------------------------------------------------------

<<8c/globals2.c>>=
#include "gc.h"

<<global idx>>

<<global breakpc>>
<<global nbreak>>
<<global cases>>
<<global constnode>>
<<global fconstnode>>
<<global continpc>>
<<global curarg>>
<<global cursafe>>
<<global firstp>>
<<global lastp>>
<<global maxargsafe>>
<<global mnstring>>
<<global nodrat>>
<<global nodret>>
<<global nodsafe>>
<<global nrathole>>
<<global nstring>>
<<global p>>
<<global pc>>
<<global regnode>>
<<global fregnode0>>
<<global fregnode1>>
<<global string>>
<<global symrathole>>
<<global znode>>
<<global zprog>>
<<global reg>>
<<global exregoffset>>
<<global exfregoffset>>

<<global region>>
<<global rgp>>
<<global nregion>>
<<global nvar>>

<<global externs>>
<<global params>>
<<global consts>>
<<global addrs>>

<<global regbits>>
<<global exregbits>>

<<global change>>
<<global suppress>>

<<global firstr>>
<<global lastr>>
<<global zreg>>
<<global freer>>
<<global var>>
<<global idom>>
<<global rpo2r>>
<<global maxnr>>
@


\subsection*{[[8c/list.c]]}

%-------------------------------------------------------------

<<8c/list.c>>=
#include "gc.h"

int	Pconv(Fmt*);
int	Aconv(Fmt*);
int	Dconv(Fmt*);
int	Sconv(Fmt*);
int	Rconv(Fmt*);
int	Bconv(Fmt*);

<<function listinit>>

<<function Bconv>>

<<function Pconv>>

<<function Aconv>>

<<function Dconv>>

<<global regstr>>

<<function Rconv>>

<<function Sconv>>
@


\subsection*{[[8c/txt.c]]}

<<function ginit>>=
void
ginit(void)
{
    int i;
    Type *t;

    thechar = '8';
    thestring = "386";

    exregoffset = 0;
    exfregoffset = 0;
    listinit();

    nstring = 0;
    mnstring = 0;
    nrathole = 0;
    pc = 0;
    breakpc = -1;
    continpc = -1;
    cases = C;
    firstp = P;
    lastp = P;
    tfield = types[TLONG];

    typeswitch = typechlv;

    zprog.link = P;
    zprog.as = AGOK;
    zprog.from.type = D_NONE;
    zprog.from.index = D_NONE;
    zprog.from.scale = 0;
    zprog.to = zprog.from;

    regnode.op = OREGISTER;
    regnode.class = CEXREG;
    regnode.reg = REGTMP;
    regnode.complex = 0;
    regnode.addable = 11;
    regnode.type = types[TLONG];

    fregnode0 = regnode;
    fregnode0.reg = D_F0;
    fregnode0.type = types[TDOUBLE];

    fregnode1 = fregnode0;
    fregnode1.reg = D_F0+1;

    constnode.op = OCONST;
    constnode.class = CXXX;
    constnode.complex = 0;
    constnode.addable = 20;
    constnode.type = types[TLONG];

    fconstnode.op = OCONST;
    fconstnode.class = CXXX;
    fconstnode.complex = 0;
    fconstnode.addable = 20;
    fconstnode.type = types[TDOUBLE];

    nodsafe = new(ONAME, Z, Z);
    nodsafe->sym = slookup(".safe");
    nodsafe->type = types[TINT];
    nodsafe->etype = types[TINT]->etype;
    nodsafe->class = CAUTO;
    complex(nodsafe);

    t = typ(TARRAY, types[TCHAR]);
    symrathole = slookup(".rathole");
    symrathole->class = CGLOBL;
    symrathole->type = t;

    nodrat = new(ONAME, Z, Z);
    nodrat->sym = symrathole;
    nodrat->type = types[TIND];
    nodrat->etype = TVOID;
    nodrat->class = CGLOBL;
    complex(nodrat);
    nodrat->type = t;

    nodret = new(ONAME, Z, Z);
    nodret->sym = slookup(".ret");
    nodret->type = types[TIND];
    nodret->etype = TIND;
    nodret->class = CPARAM;
    nodret = new(OIND, nodret, Z);
    complex(nodret);

    com64init();

    for(i=0; i<nelem(reg); i++) {
        reg[i] = 1;
        if(i >= D_AX && i <= D_DI && i != D_SP)
            reg[i] = 0;
    }
}
@

<<function gclean>>=
void
gclean(void)
{
    int i;
    Sym *s;

    reg[D_SP]--;
    for(i=D_AX; i<=D_DI; i++)
        if(reg[i])
            diag(Z, "reg %R left allocated", i);
    while(mnstring)
        outstring("", 1L);
    symstring->type->width = nstring;
    symrathole->type->width = nrathole;
    for(i=0; i<NHASH; i++)
    for(s = hash[i]; s != S; s = s->link) {
        if(s->type == T)
            continue;
        if(s->type->width == 0)
            continue;
        if(s->class != CGLOBL && s->class != CSTATIC)
            continue;
        if(s->type == types[TENUM])
            continue;
        gpseudo(AGLOBL, s, nodconst(s->type->width));
    }
    nextpc();
    p->as = AEND;
    outcode();
}
@


<<function gargs>>=
void
gargs(Node *n, Node *tn1, Node *tn2)
{
    long regs;
    Node fnxargs[20], *fnxp;

    regs = cursafe;

    fnxp = fnxargs;
    garg1(n, tn1, tn2, 0, &fnxp);	/* compile fns to temps */

    curarg = 0;
    fnxp = fnxargs;
    garg1(n, tn1, tn2, 1, &fnxp);	/* compile normal args and temps */

    cursafe = regs;
}
@

<<function nareg>>=
int
nareg(int notbp)
{
    int i, n;

    n = 0;
    for(i=D_AX; i<=D_DI; i++)
        if(reg[i] == 0)
            n++;
    if(notbp && reg[D_BP] == 0)
        n--;
    return n;
}
@

<<function garg1>>=
void
garg1(Node *n, Node *tn1, Node *tn2, int f, Node **fnxp)
{
    Node nod;

    if(n == Z)
        return;
    if(n->op == OLIST) {
        garg1(n->left, tn1, tn2, f, fnxp);
        garg1(n->right, tn1, tn2, f, fnxp);
        return;
    }
    if(f == 0) {
        if(n->complex >= FNX) {
            regsalloc(*fnxp, n);
            nod = znode;
            nod.op = OAS;
            nod.left = *fnxp;
            nod.right = n;
            nod.type = n->type;
            cgen(&nod, Z);
            (*fnxp)++;
        }
        return;
    }
    if(typesu[n->type->etype] || typev[n->type->etype]) {
        regaalloc(tn2, n);
        if(n->complex >= FNX) {
            sugen(*fnxp, tn2, n->type->width);
            (*fnxp)++;
        } else
            sugen(n, tn2, n->type->width);
        return;
    }
    if(REGARG>=0 && curarg == 0 && typeilp[n->type->etype]) {
        regaalloc1(tn1, n);
        if(n->complex >= FNX) {
            cgen(*fnxp, tn1);
            (*fnxp)++;
        } else
            cgen(n, tn1);
        return;
    }
    if(vconst(n) == 0) {
        regaalloc(tn2, n);
        gmove(n, tn2);
        return;
    }
    regalloc(tn1, n, Z);
    if(n->complex >= FNX) {
        cgen(*fnxp, tn1);
        (*fnxp)++;
    } else
        cgen(n, tn1);
    regaalloc(tn2, n);
    gmove(tn1, tn2);
    regfree(tn1);
}
@

<<function nodconst>>=
Node*
nodconst(long v)
{
    constnode.vconst = v;
    return &constnode;
}
@

<<function nodfconst>>=
Node*
nodfconst(double d)
{
    fconstnode.fconst = d;
    return &fconstnode;
}
@

<<function isreg>>=
int
isreg(Node *n, int r)
{

    if(n->op == OREGISTER)
        if(n->reg == r)
            return 1;
    return 0;
}
@

<<function nodreg>>=
int
nodreg(Node *n, Node *nn, int r)
{

    *n = regnode;
    n->reg = r;
    if(reg[r] == 0)
        return 0;
    if(nn != Z) {
        n->type = nn->type;
        n->lineno = nn->lineno;
        if(nn->op == OREGISTER)
        if(nn->reg == r)
            return 0;
    }
    return 1;
}
@

<<function regret>>=
void
regret(Node *n, Node *nn)
{
    int r;

    r = REGRET;
    if(typefd[nn->type->etype])
        r = FREGRET;
    nodreg(n, nn, r);
    reg[r]++;
}
@

<<function regalloc>>=
void
regalloc(Node *n, Node *tn, Node *o)
{
    int i;

    switch(tn->type->etype) {
    case TCHAR:
    case TUCHAR:
    case TSHORT:
    case TUSHORT:
    case TINT:
    case TUINT:
    case TLONG:
    case TULONG:
    case TIND:
        if(o != Z && o->op == OREGISTER) {
            i = o->reg;
            if(i >= D_AX && i <= D_DI)
                goto out;
        }
        for(i=D_AX; i<=D_DI; i++)
            if(reg[i] == 0)
                goto out;
        diag(tn, "out of fixed registers");
abort();
        goto err;

    case TFLOAT:
    case TDOUBLE:
        i = D_F0;
        goto out;

    case TVLONG:
    case TUVLONG:
        n->op = OREGPAIR;
        n->complex = 0; /* already in registers */
        n->addable = 11;
        n->type = tn->type;
        n->lineno = nearln;
        n->left = alloc(sizeof(Node));
        n->right = alloc(sizeof(Node));
        if(o != Z && o->op == OREGPAIR) {
            regalloc(n->left, &regnode, o->left);
            regalloc(n->right, &regnode, o->right);
        } else {
            regalloc(n->left, &regnode, Z);
            regalloc(n->right, &regnode, Z);
        }
        n->right->type = types[TULONG];
        if(tn->type->etype == TUVLONG)
            n->left->type = types[TULONG];
        return;
    }
    diag(tn, "unknown type in regalloc: %T", tn->type);
err:
    i = 0;
out:
    if(i)
        reg[i]++;
    nodreg(n, tn, i);
//print("+ %R %d\n", i, reg[i]);
}
@

<<function regialloc>>=
void
regialloc(Node *n, Node *tn, Node *o)
{
    Node nod;

    nod = *tn;
    nod.type = types[TIND];
    regalloc(n, &nod, o);
}
@

<<function regfree>>=
void
regfree(Node *n)
{
    int i;

    if(n->op == OREGPAIR) {
        regfree(n->left);
        regfree(n->right);
        return;
    }

    i = 0;
    if(n->op != OREGISTER && n->op != OINDREG)
        goto err;
    i = n->reg;
    if(i < 0 || i >= sizeof(reg))
        goto err;
    if(reg[i] <= 0)
        goto err;
    reg[i]--;
//print("- %R %d\n", i, reg[i]);
    return;
err:
    diag(n, "error in regfree: %R", i);
}
@

<<function regsalloc>>=
void
regsalloc(Node *n, Node *nn)
{
    cursafe = align(cursafe, nn->type, Aaut3);
    maxargsafe = maxround(maxargsafe, cursafe+curarg);
    *n = *nodsafe;
    n->xoffset = -(stkoff + cursafe);
    n->type = nn->type;
    n->etype = nn->type->etype;
    n->lineno = nn->lineno;
}
@

<<function regaalloc1>>=
void
regaalloc1(Node *n, Node *nn)
{
    USED(nn);

    if(REGARG < 0) {
        diag(n, "regaalloc1");
        return;
    }
/* not reached 
    nodreg(n, nn, REGARG);
    reg[REGARG]++;
    curarg = align(curarg, nn->type, Aarg1);
    curarg = align(curarg, nn->type, Aarg2);
    maxargsafe = maxround(maxargsafe, cursafe+curarg);
*/
}
@

<<function regaalloc>>=
void
regaalloc(Node *n, Node *nn)
{
    curarg = align(curarg, nn->type, Aarg1);
    *n = *nn;
    n->op = OINDREG;
    n->reg = REGSP;
    n->xoffset = curarg;
    n->complex = 0;
    n->addable = 20;
    curarg = align(curarg, nn->type, Aarg2);
    maxargsafe = maxround(maxargsafe, cursafe+curarg);
}
@

<<function regind>>=
void
regind(Node *n, Node *nn)
{

    if(n->op != OREGISTER) {
        diag(n, "regind not OREGISTER");
        return;
    }
    n->op = OINDREG;
    n->type = nn->type;
}
@

<<function naddr>>=
void
naddr(Node *n, Adr *a)
{
    long v;

    a->type = D_NONE;
    if(n == Z)
        return;
    switch(n->op) {
    default:
    bad:
        diag(n, "bad in naddr: %O %D", n->op, a);
//prtree(n, "naddr");
        break;

    case OREGISTER:
        a->type = n->reg;
        a->sym = S;
        break;

    case OEXREG:
        a->type = D_INDIR + D_GS;
        a->offset = n->reg - 1;
        a->etype = n->etype;
        break;

    case OIND:
        naddr(n->left, a);
        if(a->type >= D_AX && a->type <= D_DI)
            a->type += D_INDIR;
        else
        if(a->type == D_CONST)
            a->type = D_NONE+D_INDIR;
        else
        if(a->type == D_ADDR) {
            a->type = a->index;
            a->index = D_NONE;
        } else
            goto bad;
        break;

    case OINDEX:
        a->type = idx.ptr;
        if(n->left->op == OADDR || n->left->op == OCONST)
            naddr(n->left, a);
        if(a->type >= D_AX && a->type <= D_DI)
            a->type += D_INDIR;
        else
        if(a->type == D_CONST)
            a->type = D_NONE+D_INDIR;
        else
        if(a->type == D_ADDR) {
            a->type = a->index;
            a->index = D_NONE;
        } else
            goto bad;
        a->index = idx.reg;
        a->scale = n->scale;
        a->offset += n->xoffset;
        break;

    case OINDREG:
        a->type = n->reg+D_INDIR;
        a->sym = S;
        a->offset = n->xoffset;
        break;

    case ONAME:
        a->etype = n->etype;
        a->type = D_STATIC;
        a->sym = n->sym;
        a->offset = n->xoffset;
        if(n->class == CSTATIC)
            break;
        if(n->class == CEXTERN || n->class == CGLOBL) {
            a->type = D_EXTERN;
            break;
        }
        if(n->class == CAUTO) {
            a->type = D_AUTO;
            break;
        }
        if(n->class == CPARAM) {
            a->type = D_PARAM;
            break;
        }
        goto bad;

    case OCONST:
        if(typefd[n->type->etype]) {
            a->type = D_FCONST;
            a->dval = n->fconst;
            break;
        }
        a->sym = S;
        a->type = D_CONST;
        a->offset = n->vconst;
        break;

    case OADDR:
        naddr(n->left, a);
        if(a->type >= D_INDIR) {
            a->type -= D_INDIR;
            break;
        }
        if(a->type == D_EXTERN || a->type == D_STATIC ||
           a->type == D_AUTO || a->type == D_PARAM)
            if(a->index == D_NONE) {
                a->index = a->type;
                a->type = D_ADDR;
                break;
            }
        goto bad;

    case OADD:
        if(n->right->op == OCONST) {
            v = n->right->vconst;
            naddr(n->left, a);
        } else
        if(n->left->op == OCONST) {
            v = n->left->vconst;
            naddr(n->right, a);
        } else
            goto bad;
        a->offset += v;
        break;

    }
}
@

<<function CASE>>=
#define	CASE(a,b)	((a<<8)|(b<<0))
@

% set via pragma
<<global fproundflg>>=
int	fproundflg;
@



<<function gmove>>=
void
gmove(Node *f, Node *t)
{
    int ft, tt, a;
    Node nod, nod1;
    Prog *p1;

    ft = f->type->etype;
    tt = t->type->etype;
    if(debug['M'])
        print("gop: %O %O[%s],%O[%s]\n", OAS,
            f->op, tnames[ft], t->op, tnames[tt]);
    if(typefd[ft] && f->op == OCONST) {
        if(f->fconst == 0)
            gins(AFLDZ, Z, Z);
        else
        if(f->fconst == 1)
            gins(AFLD1, Z, Z);
        else
            gins(AFMOVD, f, &fregnode0);
        gmove(&fregnode0, t);
        return;
    }
/*
 * load
 */
    if(f->op == ONAME || f->op == OINDREG ||
       f->op == OIND || f->op == OINDEX)
    switch(ft) {
    case TCHAR:
        a = AMOVBLSX;
        goto ld;
    case TUCHAR:
        a = AMOVBLZX;
        goto ld;
    case TSHORT:
        if(typefd[tt]) {
            gins(AFMOVW, f, &fregnode0);
            gmove(&fregnode0, t);
            return;
        }
        a = AMOVWLSX;
        goto ld;
    case TUSHORT:
        a = AMOVWLZX;
        goto ld;
    case TINT:
    case TUINT:
    case TLONG:
    case TULONG:
    case TIND:
        if(typefd[tt]) {
            gins(AFMOVL, f, &fregnode0);
            gmove(&fregnode0, t);
            return;
        }
        a = AMOVL;

    ld:
        regalloc(&nod, f, t);
        nod.type = types[TLONG];
        gins(a, f, &nod);
        gmove(&nod, t);
        regfree(&nod);
        return;

    case TFLOAT:
        gins(AFMOVF, f, t);
        return;
    case TDOUBLE:
        gins(AFMOVD, f, t);
        return;
    }

/*
 * store
 */
    if(t->op == ONAME || t->op == OINDREG ||
       t->op == OIND || t->op == OINDEX)
    switch(tt) {
    case TCHAR:
    case TUCHAR:
        a = AMOVB;	goto st;
    case TSHORT:
    case TUSHORT:
        a = AMOVW;	goto st;
    case TINT:
    case TUINT:
    case TLONG:
    case TULONG:
    case TIND:
        a = AMOVL;	goto st;

    st:
        if(f->op == OCONST) {
            gins(a, f, t);
            return;
        }
        regalloc(&nod, t, f);
        gmove(f, &nod);
        gins(a, &nod, t);
        regfree(&nod);
        return;

    case TFLOAT:
        gins(AFMOVFP, f, t);
        return;
    case TDOUBLE:
        gins(AFMOVDP, f, t);
        return;
    }

/*
 * convert
 */
    switch(CASE(ft,tt)) {
    default:
/*
 * integer to integer
 ********
        a = AGOK;	break;

    case CASE(	TCHAR,	TCHAR):
    case CASE(	TUCHAR,	TCHAR):
    case CASE(	TSHORT,	TCHAR):
    case CASE(	TUSHORT,TCHAR):
    case CASE(	TINT,	TCHAR):
    case CASE(	TUINT,	TCHAR):
    case CASE(	TLONG,	TCHAR):
    case CASE(	TULONG,	TCHAR):
    case CASE(	TIND,	TCHAR):

    case CASE(	TCHAR,	TUCHAR):
    case CASE(	TUCHAR,	TUCHAR):
    case CASE(	TSHORT,	TUCHAR):
    case CASE(	TUSHORT,TUCHAR):
    case CASE(	TINT,	TUCHAR):
    case CASE(	TUINT,	TUCHAR):
    case CASE(	TLONG,	TUCHAR):
    case CASE(	TULONG,	TUCHAR):
    case CASE(	TIND,	TUCHAR):

    case CASE(	TSHORT,	TSHORT):
    case CASE(	TUSHORT,TSHORT):
    case CASE(	TINT,	TSHORT):
    case CASE(	TUINT,	TSHORT):
    case CASE(	TLONG,	TSHORT):
    case CASE(	TULONG,	TSHORT):
    case CASE(	TIND,	TSHORT):

    case CASE(	TSHORT,	TUSHORT):
    case CASE(	TUSHORT,TUSHORT):
    case CASE(	TINT,	TUSHORT):
    case CASE(	TUINT,	TUSHORT):
    case CASE(	TLONG,	TUSHORT):
    case CASE(	TULONG,	TUSHORT):
    case CASE(	TIND,	TUSHORT):

    case CASE(	TINT,	TINT):
    case CASE(	TUINT,	TINT):
    case CASE(	TLONG,	TINT):
    case CASE(	TULONG,	TINT):
    case CASE(	TIND,	TINT):

    case CASE(	TINT,	TUINT):
    case CASE(	TUINT,	TUINT):
    case CASE(	TLONG,	TUINT):
    case CASE(	TULONG,	TUINT):
    case CASE(	TIND,	TUINT):

    case CASE(	TINT,	TLONG):
    case CASE(	TUINT,	TLONG):
    case CASE(	TLONG,	TLONG):
    case CASE(	TULONG,	TLONG):
    case CASE(	TIND,	TLONG):

    case CASE(	TINT,	TULONG):
    case CASE(	TUINT,	TULONG):
    case CASE(	TLONG,	TULONG):
    case CASE(	TULONG,	TULONG):
    case CASE(	TIND,	TULONG):

    case CASE(	TINT,	TIND):
    case CASE(	TUINT,	TIND):
    case CASE(	TLONG,	TIND):
    case CASE(	TULONG,	TIND):
    case CASE(	TIND,	TIND):
 *****/
        a = AMOVL;
        break;

    case CASE(	TSHORT,	TINT):
    case CASE(	TSHORT,	TUINT):
    case CASE(	TSHORT,	TLONG):
    case CASE(	TSHORT,	TULONG):
    case CASE(	TSHORT,	TIND):
        a = AMOVWLSX;
        if(f->op == OCONST) {
            f->vconst &= 0xffff;
            if(f->vconst & 0x8000)
                f->vconst |= 0xffff0000;
            a = AMOVL;
        }
        break;

    case CASE(	TUSHORT,TINT):
    case CASE(	TUSHORT,TUINT):
    case CASE(	TUSHORT,TLONG):
    case CASE(	TUSHORT,TULONG):
    case CASE(	TUSHORT,TIND):
        a = AMOVWLZX;
        if(f->op == OCONST) {
            f->vconst &= 0xffff;
            a = AMOVL;
        }
        break;

    case CASE(	TCHAR,	TSHORT):
    case CASE(	TCHAR,	TUSHORT):
    case CASE(	TCHAR,	TINT):
    case CASE(	TCHAR,	TUINT):
    case CASE(	TCHAR,	TLONG):
    case CASE(	TCHAR,	TULONG):
    case CASE(	TCHAR,	TIND):
        a = AMOVBLSX;
        if(f->op == OCONST) {
            f->vconst &= 0xff;
            if(f->vconst & 0x80)
                f->vconst |= 0xffffff00;
            a = AMOVL;
        }
        break;

    case CASE(	TUCHAR,	TSHORT):
    case CASE(	TUCHAR,	TUSHORT):
    case CASE(	TUCHAR,	TINT):
    case CASE(	TUCHAR,	TUINT):
    case CASE(	TUCHAR,	TLONG):
    case CASE(	TUCHAR,	TULONG):
    case CASE(	TUCHAR,	TIND):
        a = AMOVBLZX;
        if(f->op == OCONST) {
            f->vconst &= 0xff;
            a = AMOVL;
        }
        break;

/*
 * float to fix
 */
    case CASE(	TFLOAT,	TCHAR):
    case CASE(	TFLOAT,	TUCHAR):
    case CASE(	TFLOAT,	TSHORT):
    case CASE(	TFLOAT,	TUSHORT):
    case CASE(	TFLOAT,	TINT):
    case CASE(	TFLOAT,	TLONG):
    case CASE(	TFLOAT,	TIND):

    case CASE(	TDOUBLE,TCHAR):
    case CASE(	TDOUBLE,TUCHAR):
    case CASE(	TDOUBLE,TSHORT):
    case CASE(	TDOUBLE,TUSHORT):
    case CASE(	TDOUBLE,TINT):
    case CASE(	TDOUBLE,TLONG):
    case CASE(	TDOUBLE,TIND):
        if(fproundflg) {
            regsalloc(&nod, &regnode);
            gins(AFMOVLP, f, &nod);
            gmove(&nod, t);
            return;
        }
        regsalloc(&nod, &regnode);
        regsalloc(&nod1, &regnode);
        gins(AFSTCW, Z, &nod1);
        nod1.xoffset += 2;
        gins(AMOVW, nodconst(0xf7f), &nod1);
        gins(AFLDCW, &nod1, Z);
        gins(AFMOVLP, f, &nod);
        nod1.xoffset -= 2;
        gins(AFLDCW, &nod1, Z);
        gmove(&nod, t);
        return;

/*
 * float to ulong
 */
    case CASE(	TDOUBLE,	TULONG):
    case CASE(	TFLOAT,	TULONG):
    case CASE(	TDOUBLE,	TUINT):
    case CASE(	TFLOAT,	TUINT):
        regsalloc(&nod, &regnode);
        gmove(f, &fregnode0);
        gins(AFADDD, nodfconst(-2147483648.), &fregnode0);
        gins(AFMOVLP, f, &nod);
        gins(ASUBL, nodconst(-2147483648), &nod);
        gmove(&nod, t);
        return;

/*
 * ulong to float
 */
    case CASE(	TULONG,	TDOUBLE):
    case CASE(	TULONG,	TFLOAT):
    case CASE(	TUINT,	TDOUBLE):
    case CASE(	TUINT,	TFLOAT):
        regalloc(&nod, f, f);
        gmove(f, &nod);
        regsalloc(&nod1, &regnode);
        gmove(&nod, &nod1);
        gins(AFMOVL, &nod1, &fregnode0);
        gins(ACMPL, &nod, nodconst(0));
        gins(AJGE, Z, Z);
        p1 = p;
        gins(AFADDD, nodfconst(4294967296.), &fregnode0);
        patch(p1, pc);
        regfree(&nod);
        return;

/*
 * fix to float
 */
    case CASE(	TCHAR,	TFLOAT):
    case CASE(	TUCHAR,	TFLOAT):
    case CASE(	TSHORT,	TFLOAT):
    case CASE(	TUSHORT,TFLOAT):
    case CASE(	TINT,	TFLOAT):
    case CASE(	TLONG,	TFLOAT):
    case CASE(	TIND,	TFLOAT):

    case CASE(	TCHAR,	TDOUBLE):
    case CASE(	TUCHAR,	TDOUBLE):
    case CASE(	TSHORT,	TDOUBLE):
    case CASE(	TUSHORT,TDOUBLE):
    case CASE(	TINT,	TDOUBLE):
    case CASE(	TLONG,	TDOUBLE):
    case CASE(	TIND,	TDOUBLE):
        regsalloc(&nod, &regnode);
        gmove(f, &nod);
        gins(AFMOVL, &nod, &fregnode0);
        return;

/*
 * float to float
 */
    case CASE(	TFLOAT,	TFLOAT):
    case CASE(	TDOUBLE,TFLOAT):

    case CASE(	TFLOAT,	TDOUBLE):
    case CASE(	TDOUBLE,TDOUBLE):
        a = AFMOVD;	break;
    }
    if(a == AMOVL || a == AFMOVD)
    if(samaddr(f, t))
        return;
    gins(a, f, t);
}
@

<<function doindex>>=
void
doindex(Node *n)
{
    Node nod, nod1;
    long v;

if(debug['Y'])
prtree(n, "index");

if(n->left->complex >= FNX)
print("botch in doindex\n");

    regalloc(&nod, &regnode, Z);
    v = constnode.vconst;
    cgen(n->right, &nod);
    idx.ptr = D_NONE;
    if(n->left->op == OCONST)
        idx.ptr = D_CONST;
    else if(n->left->op == OREGISTER)
//	else if(n->left->op == OREGISTER && typeil[n->left->type->etype])
        idx.ptr = n->left->reg;
    else if(n->left->op != OADDR) {
        reg[D_BP]++;	// cant be used as a base
        regalloc(&nod1, &regnode, Z);
        cgen(n->left, &nod1);
        idx.ptr = nod1.reg;
        regfree(&nod1);
        reg[D_BP]--;
    }
    idx.reg = nod.reg;
    regfree(&nod);
    constnode.vconst = v;
}
@

<<function gins>>=
void
gins(int a, Node *f, Node *t)
{

    if(f != Z && f->op == OINDEX)
        doindex(f);
    if(t != Z && t->op == OINDEX)
        doindex(t);
    nextpc();
    p->as = a;
    if(f != Z)
        naddr(f, &p->from);
    if(t != Z)
        naddr(t, &p->to);
    if(debug['g'])
        print("%P\n", p);
}
@

<<function fgopcode>>=
void
fgopcode(int o, Node *f, Node *t, int pop, int rev)
{
    int a, et;
    Node nod;

    et = TLONG;
    if(f != Z && f->type != T)
        et = f->type->etype;
    if(!typefd[et]) {
        diag(f, "fop: integer %O", o);
        return;
    }
    if(debug['M']) {
        if(t != Z && t->type != T)
            print("gop: %O %O-%s Z\n", o, f->op, tnames[et]);
        else
            print("gop: %O %O-%s %O-%s\n", o,
                f->op, tnames[et], t->op, tnames[t->type->etype]);
    }
    a = AGOK;
    switch(o) {

    case OASADD:
    case OADD:
        if(et == TFLOAT)
            a = AFADDF;
        else
        if(et == TDOUBLE) {
            a = AFADDD;
            if(pop)
                a = AFADDDP;
        }
        break;

    case OASSUB:
    case OSUB:
        if(et == TFLOAT) {
            a = AFSUBF;
            if(rev)
                a = AFSUBRF;
        } else
        if(et == TDOUBLE) {
            a = AFSUBD;
            if(pop)
                a = AFSUBDP;
            if(rev) {
                a = AFSUBRD;
                if(pop)
                    a = AFSUBRDP;
            }
        }
        break;

    case OASMUL:
    case OMUL:
        if(et == TFLOAT)
            a = AFMULF;
        else
        if(et == TDOUBLE) {
            a = AFMULD;
            if(pop)
                a = AFMULDP;
        }
        break;

    case OASMOD:
    case OMOD:
    case OASDIV:
    case ODIV:
        if(et == TFLOAT) {
            a = AFDIVF;
            if(rev)
                a = AFDIVRF;
        } else
        if(et == TDOUBLE) {
            a = AFDIVD;
            if(pop)
                a = AFDIVDP;
            if(rev) {
                a = AFDIVRD;
                if(pop)
                    a = AFDIVRDP;
            }
        }
        break;

    case OEQ:
    case ONE:
    case OLT:
    case OLE:
    case OGE:
    case OGT:
        pop += rev;
        if(et == TFLOAT) {
            a = AFCOMF;
            if(pop) {
                a = AFCOMFP;
                if(pop > 1)
                    a = AGOK;
            }
        } else
        if(et == TDOUBLE) {
            a = AFCOMF;
            if(pop) {
                a = AFCOMDP;
                if(pop > 1)
                    a = AFCOMDPP;
            }
        }
        gins(a, f, t);
        regalloc(&nod, &regnode, Z);
        if(nod.reg != D_AX) {
            regfree(&nod);
            nod.reg = D_AX;
            gins(APUSHL, &nod, Z);
            gins(AWAIT, Z, Z);
            gins(AFSTSW, Z, &nod);
            gins(ASAHF, Z, Z);
            gins(APOPL, Z, &nod);
        } else {
            gins(AWAIT, Z, Z);
            gins(AFSTSW, Z, &nod);
            gins(ASAHF, Z, Z);
            regfree(&nod);
        }
        switch(o) {
        case OEQ:	a = AJEQ; break;
        case ONE:	a = AJNE; break;
        case OLT:	a = AJCS; break;
        case OLE:	a = AJLS; break;
        case OGE:	a = AJCC; break;
        case OGT:	a = AJHI; break;
        }
        gins(a, Z, Z);
        return;
    }
    if(a == AGOK)
        diag(Z, "bad in gopcode %O", o);
    gins(a, f, t);
}
@

<<function gopcode>>=
void
gopcode(int o, Type *ty, Node *f, Node *t)
{
    int a, et;

    et = TLONG;
    if(ty != T)
        et = ty->etype;
    if(typefd[et] && o != OADDR && o != OFUNC) {
        diag(f, "gop: float %O", o);
        return;
    }
    if(debug['M']) {
        if(f != Z && f->type != T)
            print("gop: %O %O[%s],", o, f->op, tnames[et]);
        else
            print("gop: %O Z,", o);
        if(t != Z && t->type != T)
            print("%O[%s]\n", t->op, tnames[t->type->etype]);
        else
            print("Z\n");
    }
    a = AGOK;
    switch(o) {
    case OCOM:
        a = ANOTL;
        if(et == TCHAR || et == TUCHAR)
            a = ANOTB;
        if(et == TSHORT || et == TUSHORT)
            a = ANOTW;
        break;

    case ONEG:
        a = ANEGL;
        if(et == TCHAR || et == TUCHAR)
            a = ANEGB;
        if(et == TSHORT || et == TUSHORT)
            a = ANEGW;
        break;

    case OADDR:
        a = ALEAL;
        break;

    case OASADD:
    case OADD:
        a = AADDL;
        if(et == TCHAR || et == TUCHAR)
            a = AADDB;
        if(et == TSHORT || et == TUSHORT)
            a = AADDW;
        break;

    case OASSUB:
    case OSUB:
        a = ASUBL;
        if(et == TCHAR || et == TUCHAR)
            a = ASUBB;
        if(et == TSHORT || et == TUSHORT)
            a = ASUBW;
        break;

    case OASOR:
    case OOR:
        a = AORL;
        if(et == TCHAR || et == TUCHAR)
            a = AORB;
        if(et == TSHORT || et == TUSHORT)
            a = AORW;
        break;

    case OASAND:
    case OAND:
        a = AANDL;
        if(et == TCHAR || et == TUCHAR)
            a = AANDB;
        if(et == TSHORT || et == TUSHORT)
            a = AANDW;
        break;

    case OASXOR:
    case OXOR:
        a = AXORL;
        if(et == TCHAR || et == TUCHAR)
            a = AXORB;
        if(et == TSHORT || et == TUSHORT)
            a = AXORW;
        break;

    case OASLSHR:
    case OLSHR:
        a = ASHRL;
        if(et == TCHAR || et == TUCHAR)
            a = ASHRB;
        if(et == TSHORT || et == TUSHORT)
            a = ASHRW;
        break;

    case OASASHR:
    case OASHR:
        a = ASARL;
        if(et == TCHAR || et == TUCHAR)
            a = ASARB;
        if(et == TSHORT || et == TUSHORT)
            a = ASARW;
        break;

    case OASASHL:
    case OASHL:
        a = ASALL;
        if(et == TCHAR || et == TUCHAR)
            a = ASALB;
        if(et == TSHORT || et == TUSHORT)
            a = ASALW;
        break;

    case OFUNC:
        a = ACALL;
        break;

    case OASMUL:
    case OMUL:
        if(f->op == OREGISTER && t != Z && isreg(t, D_AX) && reg[D_DX] == 0)
            t = Z;
        a = AIMULL;
        break;

    case OASMOD:
    case OMOD:
    case OASDIV:
    case ODIV:
        a = AIDIVL;
        break;

    case OASLMUL:
    case OLMUL:
        a = AMULL;
        break;

    case OASLMOD:
    case OLMOD:
    case OASLDIV:
    case OLDIV:
        a = ADIVL;
        break;

    case OEQ:
    case ONE:
    case OLT:
    case OLE:
    case OGE:
    case OGT:
    case OLO:
    case OLS:
    case OHS:
    case OHI:
        a = ACMPL;
        if(et == TCHAR || et == TUCHAR)
            a = ACMPB;
        if(et == TSHORT || et == TUSHORT)
            a = ACMPW;
        gins(a, f, t);
        switch(o) {
        case OEQ:	a = AJEQ; break;
        case ONE:	a = AJNE; break;
        case OLT:	a = AJLT; break;
        case OLE:	a = AJLE; break;
        case OGE:	a = AJGE; break;
        case OGT:	a = AJGT; break;
        case OLO:	a = AJCS; break;
        case OLS:	a = AJLS; break;
        case OHS:	a = AJCC; break;
        case OHI:	a = AJHI; break;
        }
        gins(a, Z, Z);
        return;
    }
    if(a == AGOK)
        diag(Z, "bad in gopcode %O", o);
    gins(a, f, t);
}
@

<<function samaddr>>=
int
samaddr(Node *f, Node *t)
{

    if(f->op != t->op)
        return 0;
    switch(f->op) {

    case OREGISTER:
        if(f->reg != t->reg)
            break;
        return 1;
    }
    return 0;
}
@

<<function gbranch>>=
void
gbranch(int o)
{
    int a;

    a = AGOK;
    switch(o) {
    case ORETURN:
        a = ARET;
        break;
    case OGOTO:
        a = AJMP;
        break;
    }
    nextpc();
    if(a == AGOK) {
        diag(Z, "bad in gbranch %O",  o);
        nextpc();
    }
    p->as = a;
}
@

<<function patch>>=
void
patch(Prog *op, long pc)
{

    op->to.offset = pc;
    op->to.type = D_BRANCH;
}
@

<<function gpseudo>>=
void
gpseudo(int a, Sym *s, Node *n)
{

    nextpc();
    p->as = a;
    p->from.type = D_EXTERN;
    p->from.sym = s;
    p->from.scale = (profileflg ? 0 : NOPROF);
    if(s->class == CSTATIC)
        p->from.type = D_STATIC;
    naddr(n, &p->to);
    if(a == ADATA || a == AGLOBL)
        pc--;
}
@

<<function sconst>>=
int
sconst(Node *n)
{
    long v;

    if(n->op == OCONST && !typefd[n->type->etype]) {
        v = n->vconst;
        if(v >= -32766L && v < 32766L)
            return 1;
    }
    return 0;
}
@

<<function exreg>>=
long
exreg(Type *t)
{

    int o;

    if(typechlp[t->etype]){
        if(exregoffset >= 32)
            return 0;
        o = exregoffset;
        exregoffset += 4;
        return o+1;	/* +1 to avoid 0 == failure; naddr case OEXREG will -1. */
    }
    return 0;
}
@


<<global ncast>>=
long	ncast[NTYPE] =
{
    0,				/*[TXXX]*/
    BCHAR|BUCHAR,			/*[TCHAR]*/
    BCHAR|BUCHAR,			/*[TUCHAR]*/	
    BSHORT|BUSHORT,			/*[TSHORT]*/
    BSHORT|BUSHORT,			/*[TUSHORT]*/
    BINT|BUINT|BLONG|BULONG|BIND,	/*[TINT]*/		
    BINT|BUINT|BLONG|BULONG|BIND,	/*[TUINT]*/
    BINT|BUINT|BLONG|BULONG|BIND,	/*[TLONG]*/
    BINT|BUINT|BLONG|BULONG|BIND,	/*[TULONG]*/
    BVLONG|BUVLONG,			/*[TVLONG]*/
    BVLONG|BUVLONG,			/*[TUVLONG]*/
    BFLOAT,				/*[TFLOAT]*/
    BDOUBLE,			/*[TDOUBLE]*/
    BLONG|BULONG|BIND,		/*[TIND]*/
    0,				/*[TFUNC]*/
    0,				/*[TARRAY]*/
    0,				/*[TVOID]*/
    BSTRUCT,			/*[TSTRUCT]*/
    BUNION,				/*[TUNION]*/
    0,				/*[TENUM]*/
};
@


%-------------------------------------------------------------

<<8c/txt.c>>=
#include "gc.h"

void	nextpc(void);
void	garg1(Node*, Node*, Node*, int, Node**);
Node*	nodfconst(double);
void	regaalloc1(Node*, Node*);
void	regaalloc(Node*, Node*);
void	naddr(Node*, Adr*);
int	samaddr(Node*, Node*);

<<function ginit>>

<<function gclean>>

<<function nextpc>>

<<function gargs>>

<<function nareg>>

<<function garg1>>

<<function nodconst>>

<<function nodfconst>>

<<function isreg>>

<<function nodreg>>

<<function regret>>

<<function regalloc>>

<<function regialloc>>

<<function regfree>>

<<function regsalloc>>

<<function regaalloc1>>

<<function regaalloc>>

<<function regind>>

<<function naddr>>

<<function CASE>>

<<function gmove>>

<<function doindex>>

<<function gins>>

<<function fgopcode>>

<<function gopcode>>

<<function samaddr>>

<<function gbranch>>

<<function patch>>

<<function gpseudo>>

<<function sconst>>

<<function exreg>>

<<global ewidth>>
<<global ncast>>
@


\subsection*{[[8c/peep.c]]}

<<function needc>>=
static int
needc(Prog *p)
{
    while(p != P) {
        switch(p->as) {
        case AADCL:
        case ASBBL:
        case ARCRL:
            return 1;
        case AADDL:
        case ASUBL:
        case AJMP:
        case ARET:
        case ACALL:
            return 0;
        default:
            if(p->to.type == D_BRANCH)
                return 0;
        }
        p = p->link;
    }
    return 0;
}
@

<<function peep>>=
void
peep(void)
{
    Reg *r, *r1, *r2;
    Prog *p, *p1;
    int t;

    /*
     * complete R structure
     */
    t = 0;
    for(r=firstr; r!=R; r=r1) {
        r1 = r->link;
        if(r1 == R)
            break;
        p = r->prog->link;
        while(p != r1->prog)
        switch(p->as) {
        default:
            r2 = rega();
            r->link = r2;
            r2->link = r1;

            r2->prog = p;
            r2->p1 = r;
            r->s1 = r2;
            r2->s1 = r1;
            r1->p1 = r2;

            r = r2;
            t++;

        case ADATA:
        case AGLOBL:
        case ANAME:
        case ASIGNAME:
            p = p->link;
        }
    }

    pc = 0;	/* speculating it won't kill */

loop1:

    t = 0;
    for(r=firstr; r!=R; r=r->link) {
        p = r->prog;
        switch(p->as) {
        case AMOVL:
            if(regtyp(&p->to))
            if(regtyp(&p->from)) {
                if(copyprop(r)) {
                    excise(r);
                    t++;
                }
                if(subprop(r) && copyprop(r)) {
                    excise(r);
                    t++;
                }
            }
            break;

        case AMOVBLSX:
        case AMOVBLZX:
        case AMOVWLSX:
        case AMOVWLZX:
            if(regtyp(&p->to)) {
                r1 = uniqs(r);
                if(r1 != R) {
                    p1 = r1->prog;
                    if(p->as == p1->as && p->to.type == p1->from.type)
                        p1->as = AMOVL;
                }
            }
            break;
        case AADDL:
        case AADDW:
            if(p->from.type != D_CONST || needc(p->link))
                break;
            if(p->from.offset == -1){
                if(p->as == AADDL)
                    p->as = ADECL;
                else
                    p->as = ADECW;
                p->from = zprog.from;
            }
            else if(p->from.offset == 1){
                if(p->as == AADDL)
                    p->as = AINCL;
                else
                    p->as = AINCW;
                p->from = zprog.from;
            }
            break;
        case ASUBL:
        case ASUBW:
            if(p->from.type != D_CONST || needc(p->link))
                break;
            if(p->from.offset == -1) {
                if(p->as == ASUBL)
                    p->as = AINCL;
                else
                    p->as = AINCW;
                p->from = zprog.from;
            }
            else if(p->from.offset == 1){
                if(p->as == ASUBL)
                    p->as = ADECL;
                else
                    p->as = ADECW;
                p->from = zprog.from;
            }
            break;
        }
    }
    if(t)
        goto loop1;
}
@

<<function excise>>=
void
excise(Reg *r)
{
    Prog *p;

    p = r->prog;
    p->as = ANOP;
    p->from = zprog.from;
    p->to = zprog.to;
}
@

<<function uniqp>>=
Reg*
uniqp(Reg *r)
{
    Reg *r1;

    r1 = r->p1;
    if(r1 == R) {
        r1 = r->p2;
        if(r1 == R || r1->p2link != R)
            return R;
    } else
        if(r->p2 != R)
            return R;
    return r1;
}
@

<<function uniqs>>=
Reg*
uniqs(Reg *r)
{
    Reg *r1;

    r1 = r->s1;
    if(r1 == R) {
        r1 = r->s2;
        if(r1 == R)
            return R;
    } else
        if(r->s2 != R)
            return R;
    return r1;
}
@

<<function regtyp>>=
int
regtyp(Adr *a)
{
    int t;

    t = a->type;
    if(t >= D_AX && t <= D_DI)
        return 1;
    return 0;
}
@

<<function subprop>>=
/*
 * the idea is to substitute
 * one register for another
 * from one MOV to another
 *	MOV	a, R0
 *	ADD	b, R0	/ no use of R1
 *	MOV	R0, R1
 * would be converted to
 *	MOV	a, R1
 *	ADD	b, R1
 *	MOV	R1, R0
 * hopefully, then the former or latter MOV
 * will be eliminated by copy propagation.
 */
int
subprop(Reg *r0)
{
    Prog *p;
    Adr *v1, *v2;
    Reg *r;
    int t;

    p = r0->prog;
    v1 = &p->from;
    if(!regtyp(v1))
        return 0;
    v2 = &p->to;
    if(!regtyp(v2))
        return 0;
    for(r=uniqp(r0); r!=R; r=uniqp(r)) {
        if(uniqs(r) == R)
            break;
        p = r->prog;
        switch(p->as) {
        case ACALL:
            return 0;

        case AIMULL:
        case AIMULW:
            if(p->to.type != D_NONE)
                break;

        case ADIVB:
        case ADIVL:
        case ADIVW:
        case AIDIVB:
        case AIDIVL:
        case AIDIVW:
        case AIMULB:
        case AMULB:
        case AMULL:
        case AMULW:

        case AROLB:
        case AROLL:
        case AROLW:
        case ARORB:
        case ARORL:
        case ARORW:
        case ASALB:
        case ASALL:
        case ASALW:
        case ASARB:
        case ASARL:
        case ASARW:
        case ASHLB:
        case ASHLL:
        case ASHLW:
        case ASHRB:
        case ASHRL:
        case ASHRW:

        case AREP:
        case AREPN:

        case ACWD:
        case ACDQ:

        case ASTOSB:
        case ASTOSL:
        case AMOVSB:
        case AMOVSL:
        case AFSTSW:
            return 0;

        case AMOVL:
            if(p->to.type == v1->type)
                goto gotit;
            break;
        }
        if(copyau(&p->from, v2) ||
           copyau(&p->to, v2))
            break;
        if(copysub(&p->from, v1, v2, 0) ||
           copysub(&p->to, v1, v2, 0))
            break;
    }
    return 0;

gotit:
    copysub(&p->to, v1, v2, 1);
    if(debug['P']) {
        print("gotit: %D->%D\n%P", v1, v2, r->prog);
        if(p->from.type == v2->type)
            print(" excise");
        print("\n");
    }
    for(r=uniqs(r); r!=r0; r=uniqs(r)) {
        p = r->prog;
        copysub(&p->from, v1, v2, 1);
        copysub(&p->to, v1, v2, 1);
        if(debug['P'])
            print("%P\n", r->prog);
    }
    t = v1->type;
    v1->type = v2->type;
    v2->type = t;
    if(debug['P'])
        print("%P last\n", r->prog);
    return 1;
}
@

<<function copyprop>>=
/*
 * The idea is to remove redundant copies.
 *	v1->v2	F=0
 *	(use v2	s/v2/v1/)*
 *	set v1	F=1
 *	use v2	return fail
 *	-----------------
 *	v1->v2	F=0
 *	(use v2	s/v2/v1/)*
 *	set v1	F=1
 *	set v2	return success
 */
int
copyprop(Reg *r0)
{
    Prog *p;
    Adr *v1, *v2;
    Reg *r;

    p = r0->prog;
    v1 = &p->from;
    v2 = &p->to;
    if(copyas(v1, v2))
        return 1;
    for(r=firstr; r!=R; r=r->link)
        r->active = 0;
    return copy1(v1, v2, r0->s1, 0);
}
@

<<function copy1>>=
int
copy1(Adr *v1, Adr *v2, Reg *r, int f)
{
    int t;
    Prog *p;

    if(r->active) {
        if(debug['P'])
            print("act set; return 1\n");
        return 1;
    }
    r->active = 1;
    if(debug['P'])
        print("copy %D->%D f=%d\n", v1, v2, f);
    for(; r != R; r = r->s1) {
        p = r->prog;
        if(debug['P'])
            print("%P", p);
        if(!f && uniqp(r) == R) {
            f = 1;
            if(debug['P'])
                print("; merge; f=%d", f);
        }
        t = copyu(p, v2, A);
        switch(t) {
        case 2:	/* rar, cant split */
            if(debug['P'])
                print("; %D rar; return 0\n", v2);
            return 0;

        case 3:	/* set */
            if(debug['P'])
                print("; %D set; return 1\n", v2);
            return 1;

        case 1:	/* used, substitute */
        case 4:	/* use and set */
            if(f) {
                if(!debug['P'])
                    return 0;
                if(t == 4)
                    print("; %D used+set and f=%d; return 0\n", v2, f);
                else
                    print("; %D used and f=%d; return 0\n", v2, f);
                return 0;
            }
            if(copyu(p, v2, v1)) {
                if(debug['P'])
                    print("; sub fail; return 0\n");
                return 0;
            }
            if(debug['P'])
                print("; sub %D/%D", v2, v1);
            if(t == 4) {
                if(debug['P'])
                    print("; %D used+set; return 1\n", v2);
                return 1;
            }
            break;
        }
        if(!f) {
            t = copyu(p, v1, A);
            if(!f && (t == 2 || t == 3 || t == 4)) {
                f = 1;
                if(debug['P'])
                    print("; %D set and !f; f=%d", v1, f);
            }
        }
        if(debug['P'])
            print("\n");
        if(r->s2)
            if(!copy1(v1, v2, r->s2, f))
                return 0;
    }
    return 1;
}
@

<<function copyu>>=
/*
 * return
 * 1 if v only used (and substitute),
 * 2 if read-alter-rewrite
 * 3 if set
 * 4 if set and used
 * 0 otherwise (not touched)
 */
int
copyu(Prog *p, Adr *v, Adr *s)
{

    switch(p->as) {

    default:
        if(debug['P'])
            print("unknown op %A\n", p->as);
        return 2;

    case ANEGB:
    case ANEGW:
    case ANEGL:
    case ANOTB:
    case ANOTW:
    case ANOTL:
        if(copyas(&p->to, v))
            return 2;
        break;

    case ALEAL:	/* lhs addr, rhs store */
        if(copyas(&p->from, v))
            return 2;


    case ANOP:	/* rhs store */
    case AMOVL:
    case AMOVBLSX:
    case AMOVBLZX:
    case AMOVWLSX:
    case AMOVWLZX:
        if(copyas(&p->to, v)) {
            if(s != A)
                return copysub(&p->from, v, s, 1);
            if(copyau(&p->from, v))
                return 4;
            return 3;
        }
        goto caseread;

    case AROLB:
    case AROLL:
    case AROLW:
    case ARORB:
    case ARORL:
    case ARORW:
    case ASALB:
    case ASALL:
    case ASALW:
    case ASARB:
    case ASARL:
    case ASARW:
    case ASHLB:
    case ASHLL:
    case ASHLW:
    case ASHRB:
    case ASHRL:
    case ASHRW:
        if(copyas(&p->to, v))
            return 2;
        if(copyas(&p->from, v))
            if(p->from.type == D_CX)
                return 2;
        goto caseread;

    case AADDB:	/* rhs rar */
    case AADDL:
    case AADDW:
    case AANDB:
    case AANDL:
    case AANDW:
    case ADECL:
    case ADECW:
    case AINCL:
    case AINCW:
    case ASUBB:
    case ASUBL:
    case ASUBW:
    case AORB:
    case AORL:
    case AORW:
    case AXORB:
    case AXORL:
    case AXORW:
    case AMOVB:
    case AMOVW:

    case AFMOVB:
    case AFMOVBP:
    case AFMOVD:
    case AFMOVDP:
    case AFMOVF:
    case AFMOVFP:
    case AFMOVL:
    case AFMOVLP:
    case AFMOVV:
    case AFMOVVP:
    case AFMOVW:
    case AFMOVWP:
    case AFMOVX:
    case AFMOVXP:
    case AFADDDP:
    case AFADDW:
    case AFADDL:
    case AFADDF:
    case AFADDD:
    case AFMULDP:
    case AFMULW:
    case AFMULL:
    case AFMULF:
    case AFMULD:
    case AFSUBDP:
    case AFSUBW:
    case AFSUBL:
    case AFSUBF:
    case AFSUBD:
    case AFSUBRDP:
    case AFSUBRW:
    case AFSUBRL:
    case AFSUBRF:
    case AFSUBRD:
    case AFDIVDP:
    case AFDIVW:
    case AFDIVL:
    case AFDIVF:
    case AFDIVD:
    case AFDIVRDP:
    case AFDIVRW:
    case AFDIVRL:
    case AFDIVRF:
    case AFDIVRD:
        if(copyas(&p->to, v))
            return 2;
        goto caseread;

    case ACMPL:	/* read only */
    case ACMPW:
    case ACMPB:

    case AFCOMB:
    case AFCOMBP:
    case AFCOMD:
    case AFCOMDP:
    case AFCOMDPP:
    case AFCOMF:
    case AFCOMFP:
    case AFCOML:
    case AFCOMLP:
    case AFCOMW:
    case AFCOMWP:
    case AFUCOM:
    case AFUCOMP:
    case AFUCOMPP:
    caseread:
        if(s != A) {
            if(copysub(&p->from, v, s, 1))
                return 1;
            return copysub(&p->to, v, s, 1);
        }
        if(copyau(&p->from, v))
            return 1;
        if(copyau(&p->to, v))
            return 1;
        break;

    case AJGE:	/* no reference */
    case AJNE:
    case AJLE:
    case AJEQ:
    case AJHI:
    case AJLS:
    case AJMI:
    case AJPL:
    case AJGT:
    case AJLT:
    case AJCC:
    case AJCS:

    case AADJSP:
    case AFLDZ:
    case AWAIT:
        break;

    case AIMULL:
    case AIMULW:
        if(p->to.type != D_NONE) {
            if(copyas(&p->to, v))
                return 2;
            goto caseread;
        }

    case ADIVB:
    case ADIVL:
    case ADIVW:
    case AIDIVB:
    case AIDIVL:
    case AIDIVW:
    case AIMULB:
    case AMULB:
    case AMULL:
    case AMULW:

    case ACWD:
    case ACDQ:
        if(v->type == D_AX || v->type == D_DX)
            return 2;
        goto caseread;

    case AREP:
    case AREPN:
        if(v->type == D_CX)
            return 2;
        goto caseread;

    case AMOVSB:
    case AMOVSL:
        if(v->type == D_DI || v->type == D_SI)
            return 2;
        goto caseread;

    case ASTOSB:
    case ASTOSL:
        if(v->type == D_AX || v->type == D_DI)
            return 2;
        goto caseread;

    case AFSTSW:
        if(v->type == D_AX)
            return 2;
        goto caseread;

    case AJMP:	/* funny */
        if(s != A) {
            if(copysub(&p->to, v, s, 1))
                return 1;
            return 0;
        }
        if(copyau(&p->to, v))
            return 1;
        return 0;

    case ARET:	/* funny */
        if(v->type == REGRET)
            return 2;
        if(s != A)
            return 1;
        return 3;

    case ACALL:	/* funny */
        if(REGARG>=0 && v->type == REGARG)
            return 2;

        if(s != A) {
            if(copysub(&p->to, v, s, 1))
                return 1;
            return 0;
        }
        if(copyau(&p->to, v))
            return 4;
        return 3;
    }
    return 0;
}
@

<<function copyas>>=
/*
 * direct reference,
 * could be set/use depending on
 * semantics
 */
int
copyas(Adr *a, Adr *v)
{
    if(a->type != v->type)
        return 0;
    if(regtyp(v))
        return 1;
    if(v->type == D_AUTO || v->type == D_PARAM)
        if(v->offset == a->offset)
            return 1;
    return 0;
}
@

<<function copyau>>=
/*
 * either direct or indirect
 */
int
copyau(Adr *a, Adr *v)
{

    if(copyas(a, v))
        return 1;
    if(regtyp(v)) {
        if(a->type-D_INDIR == v->type)
            return 1;
        if(a->index == v->type)
            return 1;
    }
    return 0;
}
@

<<function copysub>>=
/*
 * substitute s for v in a
 * return failure to substitute
 */
int
copysub(Adr *a, Adr *v, Adr *s, int f)
{
    int t;

    if(copyas(a, v)) {
        t = s->type;
        if(t >= D_AX && t <= D_DI) {
            if(f)
                a->type = t;
        }
        return 0;
    }
    if(regtyp(v)) {
        t = v->type;
        if(a->type == t+D_INDIR) {
            if(s->type == D_BP && a->index != D_NONE)
                return 1;	/* can't use BP-base with index */
            if(f)
                a->type = s->type+D_INDIR;
//			return 0;
        }
        if(a->index == t) {
            if(f)
                a->index = s->type;
            return 0;
        }
        return 0;
    }
    return 0;
}
@


%-------------------------------------------------------------

<<8c/peep.c>>=
#include "gc.h"

Reg*	uniqp(Reg*);
Reg*	uniqs(Reg*);
int	regtyp(Adr*);
int	subprop(Reg*);
int	copyprop(Reg*);
int	copy1(Adr*, Adr*, Reg*, int);
int	copyas(Adr*, Adr*);
int	copyau(Adr*, Adr*);
int	copysub(Adr*, Adr*, Adr*, int);
//int	copysub1(Prog*, Adr*, Adr*, int);

<<function needc>>

<<function peep>>

<<function excise>>

<<function uniqp>>

<<function uniqs>>

<<function regtyp>>

<<function subprop>>

<<function copyprop>>

<<function copy1>>

<<function copyu>>

<<function copyas>>

<<function copyau>>

<<function copysub>>
@


\subsection*{[[8c/sgen.c]]}


<<function commute>>=
/* welcome to commute */
static void
commute(Node *n)
{
    Node *l, *r;

    l = n->left;
    r = n->right;
    if(r->complex > l->complex) {
        n->left = r;
        n->right = l;
    }
}
@

<<function indexshift>>=
void
indexshift(Node *n)
{
    int g;

    if(!typechlp[n->type->etype])
        return;
    simplifyshift(n);
    if(n->op == OASHL && n->right->op == OCONST){
        g = vconst(n->right);
        if(g >= 0 && g < 4)
            n->addable = 7;
    }
}
@

<<function simplifyshift>>=
/*
 * try to rewrite shift & mask
 */
void
simplifyshift(Node *n)
{
    ulong c3;
    int o, s1, s2, c1, c2;

    if(!typechlp[n->type->etype])
        return;
    switch(n->op) {
    default:
        return;
    case OASHL:
        s1 = 0;
        break;
    case OLSHR:
        s1 = 1;
        break;
    case OASHR:
        s1 = 2;
        break;
    }
    if(n->right->op != OCONST)
        return;
    if(n->left->op != OAND)
        return;
    if(n->left->right->op != OCONST)
        return;
    switch(n->left->left->op) {
    default:
        return;
    case OASHL:
        s2 = 0;
        break;
    case OLSHR:
        s2 = 1;
        break;
    case OASHR:
        s2 = 2;
        break;
    }
    if(n->left->left->right->op != OCONST)
        return;

    c1 = n->right->vconst;
    c2 = n->left->left->right->vconst;
    c3 = n->left->right->vconst;

/*
    if(debug['h'])
        print("%.3o %ld %ld %d #%.lux\n",
            (s1<<3)|s2, c1, c2, topbit(c3), c3);
*/

    o = n->op;
    switch((s1<<3)|s2) {
    case 000:	/* (((e <<u c2) & c3) <<u c1) */
        c3 >>= c2;
        c1 += c2;
        if(c1 >= 32)
            break;
        goto rewrite1;

    case 002:	/* (((e >>s c2) & c3) <<u c1) */
        if(topbit(c3) >= (32-c2))
            break;
    case 001:	/* (((e >>u c2) & c3) <<u c1) */
        if(c1 > c2) {
            c3 <<= c2;
            c1 -= c2;
            o = OASHL;
            goto rewrite1;
        }
        c3 <<= c1;
        if(c1 == c2)
            goto rewrite0;
        c1 = c2-c1;
        o = OLSHR;
        goto rewrite2;

    case 022:	/* (((e >>s c2) & c3) >>s c1) */
        if(c2 <= 0)
            break;
    case 012:	/* (((e >>s c2) & c3) >>u c1) */
        if(topbit(c3) >= (32-c2))
            break;
        goto s11;
    case 021:	/* (((e >>u c2) & c3) >>s c1) */
        if(topbit(c3) >= 31 && c2 <= 0)
            break;
        goto s11;
    case 011:	/* (((e >>u c2) & c3) >>u c1) */
    s11:
        c3 <<= c2;
        c1 += c2;
        if(c1 >= 32)
            break;
        o = OLSHR;
        goto rewrite1;

    case 020:	/* (((e <<u c2) & c3) >>s c1) */
        if(topbit(c3) >= 31)
            break;
    case 010:	/* (((e <<u c2) & c3) >>u c1) */
        c3 >>= c1;
        if(c1 == c2)
            goto rewrite0;
        if(c1 > c2) {
            c1 -= c2;
            goto rewrite2;
        }
        c1 = c2 - c1;
        o = OASHL;
        goto rewrite2;
    }
    return;

rewrite0:	/* get rid of both shifts */
if(debug['<'])prtree(n, "rewrite0");
    *n = *n->left;
    n->left = n->left->left;
    n->right->vconst = c3;
    return;
rewrite1:	/* get rid of lower shift */
if(debug['<'])prtree(n, "rewrite1");
    n->left->left = n->left->left->left;
    n->left->right->vconst = c3;
    n->right->vconst = c1;
    n->op = o;
    return;
rewrite2:	/* get rid of upper shift */
if(debug['<'])prtree(n, "rewrite2");
    *n = *n->left;
    n->right->vconst = c3;
    n->left->right->vconst = c1;
    n->left->op = o;
}
@


<<function indx>>=
void
indx(Node *n)
{
    Node *l, *r;

    if(debug['x'])
        prtree(n, "indx");

    l = n->left;
    r = n->right;
    if(l->addable == 1 || l->addable == 13 || r->complex > l->complex) {
        n->right = l;
        n->left = r;
        l = r;
        r = n->right;
    }
    if(l->addable != 7) {
        idx.regtree = l;
        idx.scale = 1;
    } else
    if(l->right->addable == 20) {
        idx.regtree = l->left;
        idx.scale = 1 << l->right->vconst;
    } else
    if(l->left->addable == 20) {
        idx.regtree = l->right;
        idx.scale = 1 << l->left->vconst;
    } else
        diag(n, "bad index");

    idx.basetree = r;
    if(debug['x']) {
        print("scale = %d\n", idx.scale);
        prtree(idx.regtree, "index");
        prtree(idx.basetree, "base");
    }
}
@


%-------------------------------------------------------------

<<8c/sgen.c>>=
#include "gc.h"

void	indx(Node*);

<<function noretval>>

<<function commute>>

<<function indexshift>>

<<function xcom>>

<<function indx>>
@


\subsection*{[[8c/swt.c]]}

<<function swit1>>=
void
swit1(C1 *q, int nc, long def, Node *n)
{
    C1 *r;
    int i;
    Prog *sp;

    if(nc < 5) {
        for(i=0; i<nc; i++) {
            if(debug['K'])
                print("case = %.8llux\n", q->val);
            gopcode(OEQ, n->type, n, nodconst(q->val));
            patch(p, q->label);
            q++;
        }
        gbranch(OGOTO);
        patch(p, def);
        return;
    }
    i = nc / 2;
    r = q+i;
    if(debug['K'])
        print("case > %.8llux\n", r->val);
    gopcode(OGT, n->type, n, nodconst(r->val));
    sp = p;
    gbranch(OGOTO);
    p->as = AJEQ;
    patch(p, r->label);
    swit1(q, i, def, n);

    if(debug['K'])
        print("case < %.8llux\n", r->val);
    patch(sp, pc);
    swit1(r+1, nc-i-1, def, n);
}
@

<<function bitload>>=
void
bitload(Node *b, Node *n1, Node *n2, Node *n3, Node *nn)
{
    int sh;
    long v;
    Node *l;

    /*
     * n1 gets adjusted/masked value
     * n2 gets address of cell
     * n3 gets contents of cell
     */
    l = b->left;
    if(n2 != Z) {
        regalloc(n1, l, nn);
        reglcgen(n2, l, Z);
        regalloc(n3, l, Z);
        gmove(n2, n3);
        gmove(n3, n1);
    } else {
        regalloc(n1, l, nn);
        cgen(l, n1);
    }
    if(b->type->shift == 0 && typeu[b->type->etype]) {
        v = ~0 + (1L << b->type->nbits);
        gopcode(OAND, types[TLONG], nodconst(v), n1);
    } else {
        sh = 32 - b->type->shift - b->type->nbits;
        if(sh > 0)
            gopcode(OASHL, types[TLONG], nodconst(sh), n1);
        sh += b->type->shift;
        if(sh > 0)
            if(typeu[b->type->etype])
                gopcode(OLSHR, types[TLONG], nodconst(sh), n1);
            else
                gopcode(OASHR, types[TLONG], nodconst(sh), n1);
    }
}
@
% >>

<<function bitstore>>=
void
bitstore(Node *b, Node *n1, Node *n2, Node *n3, Node *nn)
{
    long v;
    Node nod;
    int sh;

    regalloc(&nod, b->left, Z);
    v = ~0 + (1L << b->type->nbits);
    gopcode(OAND, types[TLONG], nodconst(v), n1);
    gmove(n1, &nod);
    if(nn != Z)
        gmove(n1, nn);
    sh = b->type->shift;
    if(sh > 0)
        gopcode(OASHL, types[TLONG], nodconst(sh), &nod);
    v <<= sh;
    gopcode(OAND, types[TLONG], nodconst(~v), n3);
    gopcode(OOR, types[TLONG], n3, &nod);
    gmove(&nod, n2);

    regfree(&nod);
    regfree(n1);
    regfree(n2);
    regfree(n3);
}
@

% >> >>

<<function outstring>>=
long
outstring(char *s, long n)
{
    long r;

    if(suppress)
        return nstring;
    r = nstring;
    while(n) {
        string[mnstring] = *s++;
        mnstring++;
        nstring++;
        if(mnstring >= NSNAME) {
            gpseudo(ADATA, symstring, nodconst(0L));
            p->from.offset += nstring - NSNAME;
            p->from.scale = NSNAME;
            p->to.type = D_SCONST;
            memmove(p->to.sval, string, NSNAME);
            mnstring = 0;
        }
        n--;
    }
    return r;
}
@

<<function gextern>>=
void
gextern(Sym *s, Node *a, long o, long w)
{
    if(a->op == OCONST && typev[a->type->etype]) {
        gpseudo(ADATA, s, lo64(a));
        p->from.offset += o;
        p->from.scale = 4;
        gpseudo(ADATA, s, hi64(a));
        p->from.offset += o + 4;
        p->from.scale = 4;
        return;
    }
    gpseudo(ADATA, s, a);
    p->from.offset += o;
    p->from.scale = w;
    switch(p->to.type) {
    default:
        p->to.index = p->to.type;
        p->to.type = D_ADDR;
    case D_CONST:
    case D_FCONST:
    case D_ADDR:
        break;
    }
}
@

% set via pragma
% seems dead, not initialized so probably 0
<<global packflg>>=
int	packflg;
@

<<function align>>=
long
align(long i, Type *t, int op)
{
    long o;
    Type *v;
    int w;

    o = i;
    w = 1;
    switch(op) {
    default:
        diag(Z, "unknown align opcode %d", op);
        break;

    case Asu2:	/* padding at end of a struct */
        w = SZ_LONG;
        if(packflg)
            w = packflg;
        break;

    case Ael1:	/* initial allign of struct element */
        for(v=t; v->etype==TARRAY; v=v->link)
            ;
        w = ewidth[v->etype];
        if(w <= 0 || w >= SZ_LONG)
            w = SZ_LONG;
        if(packflg)
            w = packflg;
        break;

    case Ael2:	/* width of a struct element */
        o += t->width;
        break;

    case Aarg0:	/* initial passbyptr argument in arg list */
        if(typesuv[t->etype]) {
            o = align(o, types[TIND], Aarg1);
            o = align(o, types[TIND], Aarg2);
        }
        break;

    case Aarg1:	/* initial allign of parameter */
        w = ewidth[t->etype];
        if(w <= 0 || w >= SZ_LONG) {
            w = SZ_LONG;
            break;
        }
        w = 1;		/* little endian no adjustment */
        break;

    case Aarg2:	/* width of a parameter */
        o += t->width;
        w = SZ_LONG;
        break;

    case Aaut3:	/* total allign of automatic */
        o = align(o, t, Ael1);
        o = align(o, t, Ael2);
        break;
    }
    o = round(o, w);
    if(debug['A'])
        print("align %s %ld %T = %ld\n", bnames[op], i, t, o);
    return o;
}
@

<<function maxround>>=
long
maxround(long max, long v)
{
    v = round(v, SZ_LONG);
    if(v > max)
        return v;
    return max;
}
@


%-------------------------------------------------------------

<<8c/swt.c>>=
#include "gc.h"

<<function swit1>>

<<function bitload>>

<<function bitstore>>

<<function outstring>>

<<function gextern>>

void	zname(Biobuf*, Sym*, int);
void	zaddr(Biobuf*, Adr*, int);
void	outhist(Biobuf*);

<<struct Htab>>

<<function outcode>>

<<function outhist>>

<<function zname>>

<<function zaddr>>

<<function align>>

<<function maxround>>
@


\subsection*{[[8c/mul.c]]}

<<struct Malg>>=
struct	Malg
{
    char	vals[10];
};
@

<<struct Mparam>>=
struct	Mparam
{
    ulong	value;
    char	alg;
    char	neg;
    char	shift;
    char	arg;
    char	off;
};
@

<<global multab>>=
static	Mparam	multab[32];
@

<<global mulptr>>=
static	int	mulptr;
@

<<global malgs>>=
static	Malg	malgs[]	=
{
    {0, 100},
    {-1, 1, 100},
    {-9, -5, -3, 3, 5, 9, 100},
    {6, 10, 12, 18, 20, 24, 36, 40, 72, 100},
    {-8, -4, -2, 2, 4, 8, 100},
};
@

<<function lowbit>>=
/*
 * return position of lowest 1
 */
int
lowbit(ulong v)
{
    int s, i;
    ulong m;

    s = 0;
    m = 0xFFFFFFFFUL;
    for(i = 16; i > 0; i >>= 1) {
        m >>= i;
        if((v & m) == 0) {
            v >>= i;
            s += i;
        }
    }
    return s;
}
@

<<function genmuladd>>=
void
genmuladd(Node *d, Node *s, int m, Node *a)
{
    Node nod;

    nod.op = OINDEX;
    nod.left = a;
    nod.right = s;
    nod.scale = m;
    nod.type = types[TIND];
    nod.xoffset = 0;
    xcom(&nod);
    gopcode(OADDR, d->type, &nod, d);
}
@

<<function mulparam>>=
void
mulparam(ulong m, Mparam *mp)
{
    int c, i, j, n, o, q, s;
    int bc, bi, bn, bo, bq, bs, bt;
    char *p;
    long u;
    ulong t;

    bc = bq = 10;
    bi = bn = bo = bs = bt = 0;
    for(i = 0; i < nelem(malgs); i++) {
        for(p = malgs[i].vals, j = 0; (o = p[j]) < 100; j++)
        for(s = 0; s < 2; s++) {
            c = 10;
            q = 10;
            u = m - o;
            if(u == 0)
                continue;
            if(s) {
                o = -o;
                if(o > 0)
                    continue;
                u = -u;
            }
            n = lowbit(u);
            t = (ulong)u >> n;
            switch(i) {
            case 0:
                if(t == 1) {
                    c = s + 1;
                    q = 0;
                    break;
                }
                switch(t) {
                case 3:
                case 5:
                case 9:
                    c = s + 1;
                    if(n)
                        c++;
                    q = 0;
                    break;
                }
                if(s)
                    break;
                switch(t) {
                case 15:
                case 25:
                case 27:
                case 45:
                case 81:
                    c = 2;
                    if(n)
                        c++;
                    q = 1;
                    break;
                }
                break;
            case 1:
                if(t == 1) {
                    c = 3;
                    q = 3;
                    break;
                }
                switch(t) {
                case 3:
                case 5:
                case 9:
                    c = 3;
                    q = 2;
                    break;
                }
                break;
            case 2:
                if(t == 1) {
                    c = 3;
                    q = 2;
                    break;
                }
                break;
            case 3:
                if(s)
                    break;
                if(t == 1) {
                    c = 3;
                    q = 1;
                    break;
                }
                break;
            case 4:
                if(t == 1) {
                    c = 3;
                    q = 0;
                    break;
                }
                break;
            }
            if(c < bc || (c == bc && q > bq)) {
                bc = c;
                bi = i;
                bn = n;
                bo = o;
                bq = q;
                bs = s;
                bt = t;
            }
        }
    }
    mp->value = m;
    if(bc <= 3) {
        mp->alg = bi;
        mp->shift = bn;
        mp->off = bo;
        mp->neg = bs;
        mp->arg = bt;
    }
    else
        mp->alg = -1;
}
@

<<function m0>>=
int
m0(int a)
{
    switch(a) {
    case -2:
    case 2:
        return 2;
    case -3:
    case 3:
        return 2;
    case -4:
    case 4:
        return 4;
    case -5:
    case 5:
        return 4;
    case 6:
        return 2;
    case -8:
    case 8:
        return 8;
    case -9:
    case 9:
        return 8;
    case 10:
        return 4;
    case 12:
        return 2;
    case 15:
        return 2;
    case 18:
        return 8;
    case 20:
        return 4;
    case 24:
        return 2;
    case 25:
        return 4;
    case 27:
        return 2;
    case 36:
        return 8;
    case 40:
        return 4;
    case 45:
        return 4;
    case 72:
        return 8;
    case 81:
        return 8;
    }
    diag(Z, "bad m0");
    return 0;
}
@

<<function m1>>=
int
m1(int a)
{
    switch(a) {
    case 15:
        return 4;
    case 25:
        return 4;
    case 27:
        return 8;
    case 45:
        return 8;
    case 81:
        return 8;
    }
    diag(Z, "bad m1");
    return 0;
}
@

<<function m2>>=
int
m2(int a)
{
    switch(a) {
    case 6:
        return 2;
    case 10:
        return 2;
    case 12:
        return 4;
    case 18:
        return 2;
    case 20:
        return 4;
    case 24:
        return 8;
    case 36:
        return 4;
    case 40:
        return 8;
    case 72:
        return 8;
    }
    diag(Z, "bad m2");
    return 0;
}
@

<<function shiftit>>=
void
shiftit(Type *t, Node *s, Node *d)
{
    long c;

    c = (long)s->vconst & 31;
    switch(c) {
    case 0:
        break;
    case 1:
        gopcode(OADD, t, d, d);
        break;
    default:
        gopcode(OASHL, t, s, d);
    }
}
@

<<function mulgen1>>=
static int
mulgen1(ulong v, Node *n)
{
    int i, o;
    Mparam *p;
    Node nod, nods;

    for(i = 0; i < nelem(multab); i++) {
        p = &multab[i];
        if(p->value == v)
            goto found;
    }

    p = &multab[mulptr];
    if(++mulptr == nelem(multab))
        mulptr = 0;

    mulparam(v, p);

found:
//	print("v=%.lx a=%d n=%d s=%d g=%d o=%d \n", p->value, p->alg, p->neg, p->shift, p->arg, p->off);
    if(p->alg < 0)
        return 0;

    nods = *nodconst(p->shift);

    o = OADD;
    if(p->alg > 0) {
        regalloc(&nod, n, Z);
        if(p->off < 0)
            o = OSUB;
    }

    switch(p->alg) {
    case 0:
        switch(p->arg) {
        case 1:
            shiftit(n->type, &nods, n);
            break;
        case 15:
        case 25:
        case 27:
        case 45:
        case 81:
            genmuladd(n, n, m1(p->arg), n);
            /* fall thru */
        case 3:
        case 5:
        case 9:
            genmuladd(n, n, m0(p->arg), n);
            shiftit(n->type, &nods, n);
            break;
        default:
            goto bad;
        }
        if(p->neg == 1)
            gins(ANEGL, Z, n);
        break;
    case 1:
        switch(p->arg) {
        case 1:
            gmove(n, &nod);
            shiftit(n->type, &nods, &nod);
            break;
        case 3:
        case 5:
        case 9:
            genmuladd(&nod, n, m0(p->arg), n);
            shiftit(n->type, &nods, &nod);
            break;
        default:
            goto bad;
        }
        if(p->neg)
            gopcode(o, n->type, &nod, n);
        else {
            gopcode(o, n->type, n, &nod);
            gmove(&nod, n);
        }
        break;
    case 2:
        genmuladd(&nod, n, m0(p->off), n);
        shiftit(n->type, &nods, n);
        goto comop;
    case 3:
        genmuladd(&nod, n, m0(p->off), n);
        shiftit(n->type, &nods, n);
        genmuladd(n, &nod, m2(p->off), n);
        break;
    case 4:
        genmuladd(&nod, n, m0(p->off), nodconst(0));
        shiftit(n->type, &nods, n);
        goto comop;
    default:
        diag(Z, "bad mul alg");
        break;
    comop:
        if(p->neg) {
            gopcode(o, n->type, n, &nod);
            gmove(&nod, n);
        }
        else
            gopcode(o, n->type, &nod, n);
    }

    if(p->alg > 0)
        regfree(&nod);

    return 1;

bad:
    diag(Z, "mulgen botch");
    return 1;
}
@

<<function mulgen>>=
void
mulgen(Type *t, Node *r, Node *n)
{
    if(!mulgen1(r->vconst, n))
        gopcode(OMUL, t, r, n);
}
@


%-------------------------------------------------------------

<<8c/mul.c>>=
#include "gc.h"

typedef struct	Malg	Malg;
typedef struct	Mparam	Mparam;

<<struct Malg>>

<<struct Mparam>>

<<global multab>>
<<global mulptr>>

<<global malgs>>

<<function lowbit>>

<<function genmuladd>>

<<function mulparam>>

<<function m0>>

<<function m1>>

<<function m2>>

<<function shiftit>>

<<function mulgen1>>

<<function mulgen>>
@


\subsection*{[[8c/reg.c]]}

<<function rega>>=
Reg*
rega(void)
{
    Reg *r;

    r = freer;
    if(r == R) {
        r = alloc(sizeof(*r));
    } else
        freer = r->link;

    *r = zreg;
    return r;
}
@

<<function rcmp>>=
int
rcmp(const void *a1, const void *a2)
{
    Rgn *p1, *p2;
    int c1, c2;

    p1 = (Rgn*)a1;
    p2 = (Rgn*)a2;
    c1 = p2->cost;
    c2 = p1->cost;
    if(c1 -= c2)
        return c1;
    return p2->varno - p1->varno;
}
@

<<struct Regopt_helper>>=
struct Regopt_helper {
        long	m;
        long	c;
        Reg*	p;
};
@

<<function regopt>>=
void
regopt(Prog *p)
{
    Reg *r, *r1, *r2;
    Prog *p1;
    int i, z;
    long initpc, val, npc;
    ulong vreg;
    Bits bit;
    struct Regopt_helper log5[6], *lp;

    firstr = R;
    lastr = R;
    nvar = 0;
    regbits = RtoB(D_SP) | RtoB(D_AX);
    for(z=0; z<BITS; z++) {
        externs.b[z] = 0;
        params.b[z] = 0;
        consts.b[z] = 0;
        addrs.b[z] = 0;
    }

    /*
     * pass 1
     * build aux data structure
     * allocate pcs
     * find use and set of variables
     */
    val = 5L * 5L * 5L * 5L * 5L;
    lp = log5;
    for(i=0; i<5; i++) {
        lp->m = val;
        lp->c = 0;
        lp->p = R;
        val /= 5L;
        lp++;
    }
    val = 0;
    for(; p != P; p = p->link) {
        switch(p->as) {
        case ADATA:
        case AGLOBL:
        case ANAME:
        case ASIGNAME:
            continue;
        }
        r = rega();
        if(firstr == R) {
            firstr = r;
            lastr = r;
        } else {
            lastr->link = r;
            r->p1 = lastr;
            lastr->s1 = r;
            lastr = r;
        }
        r->prog = p;
        r->pc = val;
        val++;

        lp = log5;
        for(i=0; i<5; i++) {
            lp->c--;
            if(lp->c <= 0) {
                lp->c = lp->m;
                if(lp->p != R)
                    lp->p->log5 = r;
                lp->p = r;
                (lp+1)->c = 0;
                break;
            }
            lp++;
        }

        r1 = r->p1;
        if(r1 != R)
        switch(r1->prog->as) {
        case ARET:
        case AJMP:
        case AIRETL:
            r->p1 = R;
            r1->s1 = R;
        }

        bit = mkvar(r, &p->from, p->as==AMOVL);
        if(bany(&bit))
        switch(p->as) {
        /*
         * funny
         */
        case ALEAL:
            for(z=0; z<BITS; z++)
                addrs.b[z] |= bit.b[z];
            break;

        /*
         * left side read
         */
        default:
            for(z=0; z<BITS; z++)
                r->use1.b[z] |= bit.b[z];
            break;
        }

        bit = mkvar(r, &p->to, 0);
        if(bany(&bit))
        switch(p->as) {
        default:
            diag(Z, "reg: unknown op: %A", p->as);
            break;

        /*
         * right side read
         */
        case ACMPB:
        case ACMPL:
        case ACMPW:
            for(z=0; z<BITS; z++)
                r->use2.b[z] |= bit.b[z];
            break;

        /*
         * right side write
         */
        case ANOP:
        case AMOVL:
        case AMOVB:
        case AMOVW:
        case AMOVBLSX:
        case AMOVBLZX:
        case AMOVWLSX:
        case AMOVWLZX:
            for(z=0; z<BITS; z++)
                r->set.b[z] |= bit.b[z];
            break;

        /*
         * right side read+write
         */
        case AADDB:
        case AADDL:
        case AADDW:
        case AANDB:
        case AANDL:
        case AANDW:
        case ASUBB:
        case ASUBL:
        case ASUBW:
        case AORB:
        case AORL:
        case AORW:
        case AXORB:
        case AXORL:
        case AXORW:
        case ASALB:
        case ASALL:
        case ASALW:
        case ASARB:
        case ASARL:
        case ASARW:
        case AROLB:
        case AROLL:
        case AROLW:
        case ARORB:
        case ARORL:
        case ARORW:
        case ASHLB:
        case ASHLL:
        case ASHLW:
        case ASHRB:
        case ASHRL:
        case ASHRW:
        case AIMULL:
        case AIMULW:
        case ANEGL:
        case ANOTL:
        case AADCL:
        case ASBBL:
            for(z=0; z<BITS; z++) {
                r->set.b[z] |= bit.b[z];
                r->use2.b[z] |= bit.b[z];
            }
            break;

        /*
         * funny
         */
        case AFMOVDP:
        case AFMOVFP:
        case AFMOVLP:
        case AFMOVVP:
        case AFMOVWP:
        case ACALL:
            for(z=0; z<BITS; z++)
                addrs.b[z] |= bit.b[z];
            break;
        }

        switch(p->as) {
        case AIMULL:
        case AIMULW:
            if(p->to.type != D_NONE)
                break;

        case AIDIVB:
        case AIDIVL:
        case AIDIVW:
        case AIMULB:
        case ADIVB:
        case ADIVL:
        case ADIVW:
        case AMULB:
        case AMULL:
        case AMULW:

        case ACWD:
        case ACDQ:
            r->regu |= RtoB(D_AX) | RtoB(D_DX);
            break;

        case AREP:
        case AREPN:
        case ALOOP:
        case ALOOPEQ:
        case ALOOPNE:
            r->regu |= RtoB(D_CX);
            break;

        case AMOVSB:
        case AMOVSL:
        case AMOVSW:
        case ACMPSB:
        case ACMPSL:
        case ACMPSW:
            r->regu |= RtoB(D_SI) | RtoB(D_DI);
            break;

        case ASTOSB:
        case ASTOSL:
        case ASTOSW:
        case ASCASB:
        case ASCASL:
        case ASCASW:
            r->regu |= RtoB(D_AX) | RtoB(D_DI);
            break;

        case AINSB:
        case AINSL:
        case AINSW:
        case AOUTSB:
        case AOUTSL:
        case AOUTSW:
            r->regu |= RtoB(D_DI) | RtoB(D_DX);
            break;

        case AFSTSW:
        case ASAHF:
            r->regu |= RtoB(D_AX);
            break;
        }
    }
    if(firstr == R)
        return;
    initpc = pc - val;
    npc = val;

    /*
     * pass 2
     * turn branch references to pointers
     * build back pointers
     */
    for(r = firstr; r != R; r = r->link) {
        p = r->prog;
        if(p->to.type == D_BRANCH) {
            val = p->to.offset - initpc;
            r1 = firstr;
            while(r1 != R) {
                r2 = r1->log5;
                if(r2 != R && val >= r2->pc) {
                    r1 = r2;
                    continue;
                }
                if(r1->pc == val)
                    break;
                r1 = r1->link;
            }
            if(r1 == R) {
                nearln = p->lineno;
                diag(Z, "ref not found\n%P", p);
                continue;
            }
            if(r1 == r) {
                nearln = p->lineno;
                diag(Z, "ref to self\n%P", p);
                continue;
            }
            r->s2 = r1;
            r->p2link = r1->p2;
            r1->p2 = r;
        }
    }
    if(debug['R']) {
        p = firstr->prog;
        print("\n%L %D\n", p->lineno, &p->from);
    }

    /*
     * pass 2.5
     * find looping structure
     */
    for(r = firstr; r != R; r = r->link)
        r->active = 0;
    change = 0;
    loopit(firstr, npc);
    if(debug['R'] && debug['v']) {
        print("\nlooping structure:\n");
        for(r = firstr; r != R; r = r->link) {
            print("%ld:%P", r->loop, r->prog);
            for(z=0; z<BITS; z++)
                bit.b[z] = r->use1.b[z] |
                       r->use2.b[z] |
                       r->set.b[z];
            if(bany(&bit)) {
                print("\t");
                if(bany(&r->use1))
                    print(" u1=%B", r->use1);
                if(bany(&r->use2))
                    print(" u2=%B", r->use2);
                if(bany(&r->set))
                    print(" st=%B", r->set);
            }
            print("\n");
        }
    }

    /*
     * pass 3
     * iterate propagating usage
     * 	back until flow graph is complete
     */
loop1:
    change = 0;
    for(r = firstr; r != R; r = r->link)
        r->active = 0;
    for(r = firstr; r != R; r = r->link)
        if(r->prog->as == ARET)
            prop(r, zbits, zbits);
loop11:
    /* pick up unreachable code */
    i = 0;
    for(r = firstr; r != R; r = r1) {
        r1 = r->link;
        if(r1 && r1->active && !r->active) {
            prop(r, zbits, zbits);
            i = 1;
        }
    }
    if(i)
        goto loop11;
    if(change)
        goto loop1;


    /*
     * pass 4
     * iterate propagating register/variable synchrony
     * 	forward until graph is complete
     */
loop2:
    change = 0;
    for(r = firstr; r != R; r = r->link)
        r->active = 0;
    synch(firstr, zbits);
    if(change)
        goto loop2;


    /*
     * pass 5
     * isolate regions
     * calculate costs (paint1)
     */
    r = firstr;
    if(r) {
        for(z=0; z<BITS; z++)
            bit.b[z] = (r->refahead.b[z] | r->calahead.b[z]) &
              ~(externs.b[z] | params.b[z] | addrs.b[z] | consts.b[z]);
        if(bany(&bit)) {
            nearln = r->prog->lineno;
            warn(Z, "used and not set: %B", bit);
            if(debug['R'] && !debug['w'])
                print("used and not set: %B\n", bit);
        }
    }
    if(debug['R'] && debug['v'])
        print("\nprop structure:\n");
    for(r = firstr; r != R; r = r->link)
        r->act = zbits;
    rgp = region;
    nregion = 0;
    for(r = firstr; r != R; r = r->link) {
        if(debug['R'] && debug['v']) {
            print("%P\t", r->prog);
            if(bany(&r->set))
                print("s:%B ", r->set);
            if(bany(&r->refahead))
                print("ra:%B ", r->refahead);
            if(bany(&r->calahead))
                print("ca:%B ", r->calahead);
            print("\n");
        }
        for(z=0; z<BITS; z++)
            bit.b[z] = r->set.b[z] &
              ~(r->refahead.b[z] | r->calahead.b[z] | addrs.b[z]);
        if(bany(&bit)) {
            nearln = r->prog->lineno;
            warn(Z, "set and not used: %B", bit);
            if(debug['R'])
                print("set and not used: %B\n", bit);
            excise(r);
        }
        for(z=0; z<BITS; z++)
            bit.b[z] = LOAD(r) & ~(r->act.b[z] | addrs.b[z]);
        while(bany(&bit)) {
            i = bnum(bit);
            rgp->enter = r;
            rgp->varno = i;
            change = 0;
            if(debug['R'] && debug['v'])
                print("\n");
            paint1(r, i);
            bit.b[i/32] &= ~(1L<<(i%32));
            if(change <= 0) {
                if(debug['R'])
                    print("%L$%d: %B\n",
                        r->prog->lineno, change, blsh(i));
                continue;
            }
            rgp->cost = change;
            nregion++;
            if(nregion >= NRGN) {
                warn(Z, "too many regions");
                goto brk;
            }
            rgp++;
        }
    }
brk:
    qsort(region, nregion, sizeof(region[0]), rcmp);

    /*
     * pass 6
     * determine used registers (paint2)
     * replace code (paint3)
     */
    rgp = region;
    for(i=0; i<nregion; i++) {
        bit = blsh(rgp->varno);
        vreg = paint2(rgp->enter, rgp->varno);
        vreg = allreg(vreg, rgp);
        if(debug['R']) {
            print("%L$%d %R: %B\n",
                rgp->enter->prog->lineno,
                rgp->cost,
                rgp->regno,
                bit);
        }
        if(rgp->regno != 0)
            paint3(rgp->enter, rgp->varno, vreg, rgp->regno);
        rgp++;
    }
    /*
     * pass 7
     * peep-hole on basic block
     */
    if(!debug['R'] || debug['P'])
        peep();

    /*
     * pass 8
     * recalculate pc
     */
    val = initpc;
    for(r = firstr; r != R; r = r1) {
        r->pc = val;
        p = r->prog;
        p1 = P;
        r1 = r->link;
        if(r1 != R)
            p1 = r1->prog;
        for(; p != p1; p = p->link) {
            switch(p->as) {
            default:
                val++;
                break;

            case ANOP:
            case ADATA:
            case AGLOBL:
            case ANAME:
            case ASIGNAME:
                break;
            }
        }
    }
    pc = val;

    /*
     * fix up branches
     */
    if(debug['R'])
        if(bany(&addrs))
            print("addrs: %B\n", addrs);

    r1 = 0; /* set */
    for(r = firstr; r != R; r = r->link) {
        p = r->prog;
        if(p->to.type == D_BRANCH)
            p->to.offset = r->s2->pc;
        r1 = r;
    }

    /*
     * last pass
     * eliminate nops
     * free aux structures
     */
    for(p = firstr->prog; p != P; p = p->link){
        while(p->link && p->link->as == ANOP)
            p->link = p->link->link;
    }
    if(r1 != R) {
        r1->link = freer;
        freer = firstr;
    }
}
@

<<function addmove>>=
/*
 * add mov b,rn
 * just after r
 */
void
addmove(Reg *r, int bn, int rn, int f)
{
    Prog *p, *p1;
    Adr *a;
    Var *v;

    p1 = alloc(sizeof(*p1));
    *p1 = zprog;
    p = r->prog;

    p1->link = p->link;
    p->link = p1;
    p1->lineno = p->lineno;

    v = var + bn;

    a = &p1->to;
    a->sym = v->sym;
    a->offset = v->offset;
    a->etype = v->etype;
    a->type = v->name;

    p1->as = AMOVL;
    if(v->etype == TCHAR || v->etype == TUCHAR)
        p1->as = AMOVB;
    if(v->etype == TSHORT || v->etype == TUSHORT)
        p1->as = AMOVW;

    p1->from.type = rn;
    if(!f) {
        p1->from = *a;
        *a = zprog.from;
        a->type = rn;
        if(v->etype == TUCHAR)
            p1->as = AMOVB;
        if(v->etype == TUSHORT)
            p1->as = AMOVW;
    }
    if(debug['R'])
        print("%P\t.a%P\n", p, p1);
}
@

<<function doregbits>>=
ulong
doregbits(int r)
{
    ulong b;

    b = 0;
    if(r >= D_INDIR)
        r -= D_INDIR;
    if(r >= D_AX && r <= D_DI)
        b |= RtoB(r);
    else
    if(r >= D_AL && r <= D_BL)
        b |= RtoB(r-D_AL+D_AX);
    else
    if(r >= D_AH && r <= D_BH)
        b |= RtoB(r-D_AH+D_AX);
    return b;
}
@

<<function mkvar>>=
Bits
mkvar(Reg *r, Adr *a, int isro)
{
    Var *v;
    int i, t, n, et, z;
    long o;
    Bits bit;
    Sym *s;

    /*
     * mark registers used
     */
    t = a->type;
    r->regu |= doregbits(t);
    r->regu |= doregbits(a->index);
    et = a->etype;

    switch(t) {
    default:
        goto none;
    case D_INDIR+D_GS:
        if(!isro || 1)
            goto none;
        n = t;
        {static Sym er; a->sym = &er;}
        a->sym->name = "$extreg"; // $
        break;
    case D_ADDR:
        a->type = a->index;
        bit = mkvar(r, a, 0);
        for(z=0; z<BITS; z++)
            addrs.b[z] |= bit.b[z];
        a->type = t;
        goto none;
    case D_EXTERN:
    case D_STATIC:
    case D_PARAM:
    case D_AUTO:
        n = t;
        break;
    }
    s = a->sym;
    if(s == S)
        goto none;
    if(s->name[0] == '.')
        goto none;
    o = a->offset;
    v = var;
    for(i=0; i<nvar; i++) {
        if(s == v->sym)
        if(n == v->name)
        if(o == v->offset)
            goto out;
        v++;
    }
    if(nvar >= NVAR) {
        if(debug['w'] > 1 && s)
            warn(Z, "variable not optimized: %s", s->name);
        goto none;
    }
    i = nvar;
    nvar++;
    v = &var[i];
    v->sym = s;
    v->offset = o;
    v->name = n;
    v->etype = et;
    if(debug['R'])
        print("bit=%2d et=%2d %D\n", i, et, a);

out:
    bit = blsh(i);
    if(n == D_EXTERN || n == D_STATIC)
        for(z=0; z<BITS; z++)
            externs.b[z] |= bit.b[z];
    if(n == D_PARAM)
        for(z=0; z<BITS; z++)
            params.b[z] |= bit.b[z];
    if(v->etype != et || !typechlpfd[et])	/* funny punning */
        for(z=0; z<BITS; z++)
            addrs.b[z] |= bit.b[z];
    return bit;

none:
    return zbits;
}
@

<<function prop>>=
void
prop(Reg *r, Bits ref, Bits cal)
{
    Reg *r1, *r2;
    int z;

    for(r1 = r; r1 != R; r1 = r1->p1) {
        for(z=0; z<BITS; z++) {
            ref.b[z] |= r1->refahead.b[z];
            if(ref.b[z] != r1->refahead.b[z]) {
                r1->refahead.b[z] = ref.b[z];
                change++;
            }
            cal.b[z] |= r1->calahead.b[z];
            if(cal.b[z] != r1->calahead.b[z]) {
                r1->calahead.b[z] = cal.b[z];
                change++;
            }
        }
        switch(r1->prog->as) {
        case ACALL:
            for(z=0; z<BITS; z++) {
                cal.b[z] |= ref.b[z] | externs.b[z];
                ref.b[z] = 0;
            }
            break;

        case ATEXT:
            for(z=0; z<BITS; z++) {
                cal.b[z] = 0;
                ref.b[z] = 0;
            }
            break;

        case ARET:
            for(z=0; z<BITS; z++) {
                cal.b[z] = externs.b[z];
                ref.b[z] = 0;
            }
        }
        for(z=0; z<BITS; z++) {
            ref.b[z] = (ref.b[z] & ~r1->set.b[z]) |
                r1->use1.b[z] | r1->use2.b[z];
            cal.b[z] &= ~(r1->set.b[z] | r1->use1.b[z] | r1->use2.b[z]);
            r1->refbehind.b[z] = ref.b[z];
            r1->calbehind.b[z] = cal.b[z];
        }
        if(r1->active)
            break;
        r1->active = 1;
    }
    for(; r != r1; r = r->p1)
        for(r2 = r->p2; r2 != R; r2 = r2->p2link)
            prop(r2, r->refbehind, r->calbehind);
}
@
%$


<<function postorder>>=
/*
 * find looping structure
 *
 * 1) find reverse postordering
 * 2) find approximate dominators,
 *	the actual dominators if the flow graph is reducible
 *	otherwise, dominators plus some other non-dominators.
 *	See Matthew S. Hecht and Jeffrey D. Ullman,
 *	"Analysis of a Simple Algorithm for Global Data Flow Problems",
 *	Conf.  Record of ACM Symp. on Principles of Prog. Langs, Boston, Massachusetts,
 *	Oct. 1-3, 1973, pp.  207-217.
 * 3) find all nodes with a predecessor dominated by the current node.
 *	such a node is a loop head.
 *	recursively, all preds with a greater rpo number are in the loop
 */
long
postorder(Reg *r, Reg **rpo2r, long n)
{
    Reg *r1;

    r->rpo = 1;
    r1 = r->s1;
    if(r1 && !r1->rpo)
        n = postorder(r1, rpo2r, n);
    r1 = r->s2;
    if(r1 && !r1->rpo)
        n = postorder(r1, rpo2r, n);
    rpo2r[n] = r;
    n++;
    return n;
}
@

<<function rpolca>>=
long
rpolca(long *idom, long rpo1, long rpo2)
{
    long t;

    if(rpo1 == -1)
        return rpo2;
    while(rpo1 != rpo2){
        if(rpo1 > rpo2){
            t = rpo2;
            rpo2 = rpo1;
            rpo1 = t;
        }
        while(rpo1 < rpo2){
            t = idom[rpo2];
            if(t >= rpo2)
                fatal(Z, "bad idom");
            rpo2 = t;
        }
    }
    return rpo1;
}
@

<<function doms>>=
int
doms(long *idom, long r, long s)
{
    while(s > r)
        s = idom[s];
    return s == r;
}
@

<<function loophead>>=
int
loophead(long *idom, Reg *r)
{
    long src;

    src = r->rpo;
    if(r->p1 != R && doms(idom, src, r->p1->rpo))
        return 1;
    for(r = r->p2; r != R; r = r->p2link)
        if(doms(idom, src, r->rpo))
            return 1;
    return 0;
}
@

<<function loopmark>>=
void
loopmark(Reg **rpo2r, long head, Reg *r)
{
    if(r->rpo < head || r->active == head)
        return;
    r->active = head;
    r->loop += LOOP;
    if(r->p1 != R)
        loopmark(rpo2r, head, r->p1);
    for(r = r->p2; r != R; r = r->p2link)
        loopmark(rpo2r, head, r);
}
@

<<function loopit>>=
void
loopit(Reg *r, long nr)
{
    Reg *r1;
    long i, d, me;

    if(nr > maxnr) {
        rpo2r = alloc(nr * sizeof(Reg*));
        idom = alloc(nr * sizeof(long));
        maxnr = nr;
    }

    d = postorder(r, rpo2r, 0);
    if(d > nr)
        fatal(Z, "too many reg nodes");
    nr = d;
    for(i = 0; i < nr / 2; i++){
        r1 = rpo2r[i];
        rpo2r[i] = rpo2r[nr - 1 - i];
        rpo2r[nr - 1 - i] = r1;
    }
    for(i = 0; i < nr; i++)
        rpo2r[i]->rpo = i;

    idom[0] = 0;
    for(i = 0; i < nr; i++){
        r1 = rpo2r[i];
        me = r1->rpo;
        d = -1;
        if(r1->p1 != R && r1->p1->rpo < me)
            d = r1->p1->rpo;
        for(r1 = r1->p2; r1 != nil; r1 = r1->p2link)
            if(r1->rpo < me)
                d = rpolca(idom, d, r1->rpo);
        idom[i] = d;
    }

    for(i = 0; i < nr; i++){
        r1 = rpo2r[i];
        r1->loop++;
        if(r1->p2 != R && loophead(idom, r1))
            loopmark(rpo2r, i, r1);
    }
}
@

<<function synch>>=
void
synch(Reg *r, Bits dif)
{
    Reg *r1;
    int z;

    for(r1 = r; r1 != R; r1 = r1->s1) {
        for(z=0; z<BITS; z++) {
            dif.b[z] = (dif.b[z] &
                ~(~r1->refbehind.b[z] & r1->refahead.b[z])) |
                    r1->set.b[z] | r1->regdiff.b[z];
            if(dif.b[z] != r1->regdiff.b[z]) {
                r1->regdiff.b[z] = dif.b[z];
                change++;
            }
        }
        if(r1->active)
            break;
        r1->active = 1;
        for(z=0; z<BITS; z++)
            dif.b[z] &= ~(~r1->calbehind.b[z] & r1->calahead.b[z]);
        if(r1->s2 != R)
            synch(r1->s2, dif);
    }
}
@

<<function allreg>>=
ulong
allreg(ulong b, Rgn *r)
{
    Var *v;
    int i;

    v = var + r->varno;
    r->regno = 0;
    switch(v->etype) {

    default:
        diag(Z, "unknown etype %d/%d", bitno(b), v->etype);
        break;

    case TCHAR:
    case TUCHAR:
    case TSHORT:
    case TUSHORT:
    case TINT:
    case TUINT:
    case TLONG:
    case TULONG:
    case TIND:
    case TARRAY:
        i = BtoR(~b);
        if(i && r->cost > 0) {
            r->regno = i;
            return RtoB(i);
        }
        break;

    case TDOUBLE:
    case TFLOAT:
        break;
    }
    return 0;
}
@

<<function paint1>>=
void
paint1(Reg *r, int bn)
{
    Reg *r1;
    Prog *p;
    int z;
    ulong bb;

    z = bn/32;
    bb = 1L<<(bn%32);
    if(r->act.b[z] & bb)
        return;
    for(;;) {
        if(!(r->refbehind.b[z] & bb))
            break;
        r1 = r->p1;
        if(r1 == R)
            break;
        if(!(r1->refahead.b[z] & bb))
            break;
        if(r1->act.b[z] & bb)
            break;
        r = r1;
    }

    if(LOAD(r) & ~(r->set.b[z]&~(r->use1.b[z]|r->use2.b[z])) & bb) {
        change -= CLOAD * r->loop;
        if(debug['R'] && debug['v'])
            print("%ld%P\tld %B $%d\n", r->loop,
                r->prog, blsh(bn), change);
    }
    for(;;) {
        r->act.b[z] |= bb;
        p = r->prog;

        if(r->use1.b[z] & bb) {
            change += CREF * r->loop;
            if(p->as == AFMOVL || p->as == AFMOVW)
                if(BtoR(bb) != D_F0)
                    change = -CINF;
            if(debug['R'] && debug['v'])
                print("%ld%P\tu1 %B $%d\n", r->loop,
                    p, blsh(bn), change);
        }

        if((r->use2.b[z]|r->set.b[z]) & bb) {
            change += CREF * r->loop;
            if(p->as == AFMOVL || p->as == AFMOVW)
                if(BtoR(bb) != D_F0)
                    change = -CINF;
            if(debug['R'] && debug['v'])
                print("%ld%P\tu2 %B $%d\n", r->loop,
                    p, blsh(bn), change);
        }

        if(STORE(r) & r->regdiff.b[z] & bb) {
            change -= CLOAD * r->loop;
            if(p->as == AFMOVL || p->as == AFMOVW)
                if(BtoR(bb) != D_F0)
                    change = -CINF;
            if(debug['R'] && debug['v'])
                print("%ld%P\tst %B $%d\n", r->loop,
                    p, blsh(bn), change);
        }

        if(r->refbehind.b[z] & bb)
            for(r1 = r->p2; r1 != R; r1 = r1->p2link)
                if(r1->refahead.b[z] & bb)
                    paint1(r1, bn);

        if(!(r->refahead.b[z] & bb))
            break;
        r1 = r->s2;
        if(r1 != R)
            if(r1->refbehind.b[z] & bb)
                paint1(r1, bn);
        r = r->s1;
        if(r == R)
            break;
        if(r->act.b[z] & bb)
            break;
        if(!(r->refbehind.b[z] & bb))
            break;
    }
}
@

<<function regset>>=
ulong
regset(Reg *r, ulong bb)
{
    ulong b, set;
    Adr v;
    int c;

    set = 0;
    v = zprog.from;
    while(b = bb & ~(bb-1)) {
        v.type = BtoR(b);
        c = copyu(r->prog, &v, A);
        if(c == 3)
            set |= b;
        bb &= ~b;
    }
    return set;
}
@

<<function reguse>>=
ulong
reguse(Reg *r, ulong bb)
{
    ulong b, set;
    Adr v;
    int c;

    set = 0;
    v = zprog.from;
    while(b = bb & ~(bb-1)) {
        v.type = BtoR(b);
        c = copyu(r->prog, &v, A);
        if(c == 1 || c == 2 || c == 4)
            set |= b;
        bb &= ~b;
    }
    return set;
}
@

<<function paint2>>=
ulong
paint2(Reg *r, int bn)
{
    Reg *r1;
    int z;
    ulong bb, vreg, x;

    z = bn/32;
    bb = 1L << (bn%32); // >>
    vreg = regbits;
    if(!(r->act.b[z] & bb))
        return vreg;
    for(;;) {
        if(!(r->refbehind.b[z] & bb))
            break;
        r1 = r->p1;
        if(r1 == R)
            break;
        if(!(r1->refahead.b[z] & bb))
            break;
        if(!(r1->act.b[z] & bb))
            break;
        r = r1;
    }
    for(;;) {
        r->act.b[z] &= ~bb;

        vreg |= r->regu;

        if(r->refbehind.b[z] & bb)
            for(r1 = r->p2; r1 != R; r1 = r1->p2link)
                if(r1->refahead.b[z] & bb)
                    vreg |= paint2(r1, bn);

        if(!(r->refahead.b[z] & bb))
            break;
        r1 = r->s2;
        if(r1 != R)
            if(r1->refbehind.b[z] & bb)
                vreg |= paint2(r1, bn);
        r = r->s1;
        if(r == R)
            break;
        if(!(r->act.b[z] & bb))
            break;
        if(!(r->refbehind.b[z] & bb))
            break;
    }

    bb = vreg;
    for(; r; r=r->s1) {
        x = r->regu & ~bb;
        if(x) {
            vreg |= reguse(r, x);
            bb |= regset(r, x);
        }
    }
    return vreg;
}
@

<<function paint3>>=
void
paint3(Reg *r, int bn, long rb, int rn)
{
    Reg *r1;
    Prog *p;
    int z;
    ulong bb;

    z = bn/32;
    bb = 1L << (bn%32); // >>
    if(r->act.b[z] & bb)
        return;
    for(;;) {
        if(!(r->refbehind.b[z] & bb))
            break;
        r1 = r->p1;
        if(r1 == R)
            break;
        if(!(r1->refahead.b[z] & bb))
            break;
        if(r1->act.b[z] & bb)
            break;
        r = r1;
    }

    if(LOAD(r) & ~(r->set.b[z] & ~(r->use1.b[z]|r->use2.b[z])) & bb)
        addmove(r, bn, rn, 0);
    for(;;) {
        r->act.b[z] |= bb;
        p = r->prog;

        if(r->use1.b[z] & bb) {
            if(debug['R'])
                print("%P", p);
            addreg(&p->from, rn);
            if(debug['R'])
                print("\t.c%P\n", p);
        }
        if((r->use2.b[z]|r->set.b[z]) & bb) {
            if(debug['R'])
                print("%P", p);
            addreg(&p->to, rn);
            if(debug['R'])
                print("\t.c%P\n", p);
        }

        if(STORE(r) & r->regdiff.b[z] & bb)
            addmove(r, bn, rn, 1);
        r->regu |= rb;

        if(r->refbehind.b[z] & bb)
            for(r1 = r->p2; r1 != R; r1 = r1->p2link)
                if(r1->refahead.b[z] & bb)
                    paint3(r1, bn, rb, rn);

        if(!(r->refahead.b[z] & bb))
            break;
        r1 = r->s2;
        if(r1 != R)
            if(r1->refbehind.b[z] & bb)
                paint3(r1, bn, rb, rn);
        r = r->s1;
        if(r == R)
            break;
        if(r->act.b[z] & bb)
            break;
        if(!(r->refbehind.b[z] & bb))
            break;
    }
}
@
% >>

<<function addreg>>=
void
addreg(Adr *a, int rn)
{

    a->sym = 0;
    a->offset = 0;
    a->type = rn;
}
@

<<function RtoB>>=
long
RtoB(int r)
{

    if(r < D_AX || r > D_DI)
        return 0;
    return 1L << (r-D_AX);
}
@

% >>

<<function BtoR>>=
int
BtoR(long b)
{

    b &= 0xffL;
    if(b == 0)
        return 0;
    return bitno(b) + D_AX;
}
@


%-------------------------------------------------------------

<<8c/reg.c>>=
#include "gc.h"

void	addreg(Adr*, int);
int	rcmp(const void*, const void*);
void	addmove(Reg*, int, int, int);
Bits	mkvar(Reg*, Adr*, int);
void	prop(Reg*, Bits, Bits);
void	loopit(Reg*, long);
void	synch(Reg*, Bits);
ulong	allreg(ulong, Rgn*);
void	paint1(Reg*, int);
ulong	paint2(Reg*, int);
void	paint3(Reg*, int, long, int);

long	RtoB(int);
//long	FtoB(int);
int	BtoR(long);
//int	BtoF(long);

<<function rega>>

<<function rcmp>>

<<struct Regopt_helper>>

<<function regopt>>

<<function addmove>>

<<function doregbits>>

<<function mkvar>>

<<function prop>>

<<function postorder>>

<<function rpolca>>

<<function doms>>

<<function loophead>>

<<function loopmark>>

<<function loopit>>

<<function synch>>

<<function allreg>>

<<function paint1>>

<<function regset>>

<<function reguse>>

<<function paint2>>

<<function paint3>>

<<function addreg>>

<<function RtoB>>

<<function BtoR>>
@
% >>

\subsection*{[[8c/cgen64.c]]}

<<function zeroregm>>=
void
zeroregm(Node *n)
{
    gins(AMOVL, nodconst(0), n);
}
@

<<function vaddr>>=
/* do we need to load the address of a vlong? */
int
vaddr(Node *n, int a)
{
    switch(n->op) {
    case ONAME:
        if(a)
            return 1;
        return !(n->class == CEXTERN || n->class == CGLOBL || n->class == CSTATIC);

    case OCONST:
    case OREGISTER:
    case OINDREG:
        return 1;
    }
    return 0;
}
@

<<function hi64v>>=
long
hi64v(Node *n)
{
    if(align(0, types[TCHAR], Aarg1))	/* isbigendian */
        return (long)(n->vconst) & ~0L;
    else
        return (long)((uvlong)n->vconst>>32) & ~0L;
}
@

<<function lo64v>>=
long
lo64v(Node *n)
{
    if(align(0, types[TCHAR], Aarg1))	/* isbigendian */
        return (long)((uvlong)n->vconst>>32) & ~0L;
    else
        return (long)(n->vconst) & ~0L;
}
@

<<function hi64>>=
Node *
hi64(Node *n)
{
    return nodconst(hi64v(n));
}
@

<<function lo64>>=
Node *
lo64(Node *n)
{
    return nodconst(lo64v(n));
}
@

<<function anonreg>>=
static Node *
anonreg(void)
{
    Node *n;

    n = new(OREGISTER, Z, Z);
    n->reg = D_NONE;
    n->type = types[TLONG];
    return n;
}
@

<<function regpair>>=
static Node *
regpair(Node *n, Node *t)
{
    Node *r;

    if(n != Z && n->op == OREGPAIR)
        return n;
    r = new(OREGPAIR, anonreg(), anonreg());
    if(n != Z)
        r->type = n->type;
    else
        r->type = t->type;
    return r;
}
@

<<function evacaxdx>>=
static void
evacaxdx(Node *r)
{
    Node nod1, nod2;

    if(r->reg == D_AX || r->reg == D_DX) {
        reg[D_AX]++;
        reg[D_DX]++;
        /*
         * this is just an optim that should
         * check for spill
         */
        r->type = types[TULONG];
        regalloc(&nod1, r, Z);
        nodreg(&nod2, Z, r->reg);
        gins(AMOVL, &nod2, &nod1);
        regfree(r);
        r->reg = nod1.reg;
        reg[D_AX]--;
        reg[D_DX]--;
    }
}
@

<<function instpair>>=
/* lazy instantiation of register pair */
static int
instpair(Node *n, Node *l)
{
    int r;

    r = 0;
    if(n->left->reg == D_NONE) {
        if(l != Z) {
            n->left->reg = l->reg;
            r = 1;
        }
        else
            regalloc(n->left, n->left, Z);
    }
    if(n->right->reg == D_NONE)
        regalloc(n->right, n->right, Z);
    return r;
}
@

<<function zapreg>>=
static void
zapreg(Node *n)
{
    if(n->reg != D_NONE) {
        //prtree(n, "zapreg");
        regfree(n);
        n->reg = D_NONE;
    }
}
@

<<function freepair>>=
static void
freepair(Node *n)
{
    regfree(n->left);
    regfree(n->right);
}
@

<<function loadpair>>=
/* n is not OREGPAIR, nn is */
void
loadpair(Node *n, Node *nn)
{
    Node nod;

    instpair(nn, Z);
    if(n->op == OCONST) {
        gins(AMOVL, lo64(n), nn->left);
        n->xoffset += SZ_LONG;
        gins(AMOVL, hi64(n), nn->right);
        n->xoffset -= SZ_LONG;
        return;
    }
    if(!vaddr(n, 0)) {
        /* steal the right register for the laddr */
        nod = regnode;
        nod.reg = nn->right->reg;
        lcgen(n, &nod);
        n = &nod;
        regind(n, n);
        n->xoffset = 0;
    }
    gins(AMOVL, n, nn->left);
    n->xoffset += SZ_LONG;
    gins(AMOVL, n, nn->right);
    n->xoffset -= SZ_LONG;
}
@

<<function storepair>>=
/* n is OREGPAIR, nn is not */
static void
storepair(Node *n, Node *nn, int f)
{
    Node nod;

    if(!vaddr(nn, 0)) {
        reglcgen(&nod, nn, Z);
        nn = &nod;
    }
    gins(AMOVL, n->left, nn);
    nn->xoffset += SZ_LONG;
    gins(AMOVL, n->right, nn);
    nn->xoffset -= SZ_LONG;
    if(nn == &nod)
        regfree(&nod);
    if(f)
        freepair(n);
}
@

<<enum _anon_ (8c/cgen64.c)>>=
enum
{
/* 4 only, see WW */
    WNONE	= 0,
    WCONST,
    WADDR,
    WHARD,
};
@

<<function whatof>>=
static int
whatof(Node *n, int a)
{
    if(n->op == OCONST)
        return WCONST;
    return !vaddr(n, a) ? WHARD : WADDR;
}
@

<<function reduxv>>=
/* can upgrade an extern to addr for AND */
static int
reduxv(Node *n)
{
    return lo64v(n) == 0 || hi64v(n) == 0;
}
@

<<function cond>>=
int
cond(int op)
{
    switch(op) {
    case OANDAND:
    case OOROR:
    case ONOT:
        return 1;

    case OEQ:
    case ONE:
    case OLE:
    case OLT:
    case OGE:
    case OGT:
    case OHI:
    case OHS:
    case OLO:
    case OLS:
        return 1;
    }
    return 0;
}
@

<<function vfunc>>=
/*
 * for a func operand call it and then return
 * the safe node
 */
static Node *
vfunc(Node *n, Node *nn)
{
    Node *t;

    if(n->op != OFUNC)
        return n;
    t = new(0, Z, Z);
    if(nn == Z || nn == nodret)
        nn = n;
    regsalloc(t, nn);
    sugen(n, t, 8);
    return t;
}
@

<<function getreg>>=
/* try to steal a reg */
static int
getreg(Node **np, Node *t, int r)
{
    Node *n, *p;

    n = *np;
    if(n->reg == r) {
        p = new(0, Z, Z);
        regalloc(p, n, Z);
        gins(AMOVL, n, p);
        *t = *n;
        *np = p;
        return 1;
    }
    return 0;
}
@

<<function snarfreg>>=
static Node *
snarfreg(Node *n, Node *t, int r, Node *d, Node *c)
{
    if(n == Z || n->op != OREGPAIR || (!getreg(&n->left, t, r) && !getreg(&n->right, t, r))) {
        if(nodreg(t, Z, r)) {
            regalloc(c, d, Z);
            gins(AMOVL, t, c);
            reg[r]++;
            return c;
        }
        reg[r]++;
    }
    return Z;
}
@

<<enum _anon_ (8c/cgen64.c)2>>=
enum
{
    Vstart	= OEND,

    Vgo,
    Vamv,
    Vmv,
    Vzero,
    Vop,
    Vopx,
    Vins,
    Vins0,
    Vinsl,
    Vinsr,
    Vinsla,
    Vinsra,
    Vinsx,
    Vmul,
    Vshll,
    VT,
    VF,
    V_l_lo_f,
    V_l_hi_f,
    V_l_lo_t,
    V_l_hi_t,
    V_l_lo_u,
    V_l_hi_u,
    V_r_lo_f,
    V_r_hi_f,
    V_r_lo_t,
    V_r_hi_t,
    V_r_lo_u,
    V_r_hi_u,
    Vspazz,
    Vend,

    V_T0,
    V_T1,
    V_F0,
    V_F1,

    V_a0,
    V_a1,
    V_f0,
    V_f1,

    V_p0,
    V_p1,
    V_p2,
    V_p3,
    V_p4,

    V_s0,
    V_s1,
    V_s2,
    V_s3,
    V_s4,

    C00,
    C01,
    C31,
    C32,

    O_l_lo,
    O_l_hi,
    O_r_lo,
    O_r_hi,
    O_t_lo,
    O_t_hi,
    O_l,
    O_r,
    O_l_rp,
    O_r_rp,
    O_t_rp,
    O_r0,
    O_r1,
    O_Zop,

    O_a0,
    O_a1,

    V_C0,
    V_C1,

    V_S0,
    V_S1,

    VOPS	= 5,
    VLEN	= 5,
    VARGS	= 2,

    S00	= 0,
    Sc0,
    Sc1,
    Sc2,
    Sac3,
    Sac4,
    S10,

    SAgen	= 0,
    SAclo,
    SAc32,
    SAchi,
    SAdgen,
    SAdclo,
    SAdc32,
    SAdchi,

    B0c	= 0,
    Bca,
    Bac,

    T0i	= 0,
    Tii,

    Bop0	= 0,
    Bop1,
};
@

<<global testi>>=
/*
 * _testv:
 * 	CMPL	lo,$0
 * 	JNE	true
 * 	CMPL	hi,$0
 * 	JNE	true
 * 	GOTO	false
 * false:
 * 	GOTO	code
 * true:
 * 	GOTO	patchme
 * code:
 */

static uchar	testi[][VLEN] =
{
    {Vop, ONE, O_l_lo, C00},
    {V_s0, Vop, ONE, O_l_hi, C00},
    {V_s1, Vgo, V_s2, Vgo, V_s3},
    {VF, V_p0, V_p1, VT, V_p2},
    {Vgo, V_p3},
    {VT, V_p0, V_p1, VF, V_p2},
    {Vend},
};
@

<<global shll00>>=
/* shift left general case */
static uchar	shll00[][VLEN] =
{
    {Vop, OGE, O_r, C32},
    {V_s0, Vinsl, ASHLL, O_r, O_l_rp},
    {Vins, ASHLL, O_r, O_l_lo, Vgo},
    {V_p0, V_s0},
    {Vins, ASHLL, O_r, O_l_lo},
    {Vins, AMOVL, O_l_lo, O_l_hi},
    {Vzero, O_l_lo, V_p0, Vend},
};
@

<<global shllc0>>=
/* shift left rp, const < 32 */
static uchar	shllc0[][VLEN] =
{
    {Vinsl, ASHLL, O_r, O_l_rp},
    {Vshll, O_r, O_l_lo, Vend},
};
@

<<global shllc1>>=
/* shift left rp, const == 32 */
static uchar	shllc1[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_l_hi},
    {Vzero, O_l_lo, Vend},
};
@

<<global shllc2>>=
/* shift left rp, const > 32 */
static uchar	shllc2[][VLEN] =
{
    {Vshll, O_r, O_l_lo},
    {Vins, AMOVL, O_l_lo, O_l_hi},
    {Vzero, O_l_lo, Vend},
};
@

<<global shllac3>>=
/* shift left addr, const == 32 */
static uchar	shllac3[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_hi},
    {Vzero, O_t_lo, Vend},
};
@

<<global shllac4>>=
/* shift left addr, const > 32 */
static uchar	shllac4[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_hi},
    {Vshll, O_r, O_t_hi},
    {Vzero, O_t_lo, Vend},
};
@

<<global shll10>>=
/* shift left of constant */
static uchar	shll10[][VLEN] =
{
    {Vop, OGE, O_r, C32},
    {V_s0, Vins, AMOVL, O_l_lo, O_t_lo},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {Vinsl, ASHLL, O_r, O_t_rp},
    {Vins, ASHLL, O_r, O_t_lo, Vgo},
    {V_p0, V_s0},
    {Vins, AMOVL, O_l_lo, O_t_hi},
    {V_l_lo_t, Vins, ASHLL, O_r, O_t_hi},
    {Vzero, O_t_lo, V_p0, Vend},
};
@

<<global shlltab>>=
static uchar	(*shlltab[])[VLEN] =
{
    shll00,
    shllc0,
    shllc1,
    shllc2,
    shllac3,
    shllac4,
    shll10,
};
@

<<global shrl00>>=
/* shift right general case */
static uchar	shrl00[][VLEN] =
{
    {Vop, OGE, O_r, C32},
    {V_s0, Vinsr, ASHRL, O_r, O_l_rp},
    {Vins, O_a0, O_r, O_l_hi, Vgo},
    {V_p0, V_s0},
    {Vins, O_a0, O_r, O_l_hi},
    {Vins, AMOVL, O_l_hi, O_l_lo},
    {V_T1, Vzero, O_l_hi},
    {V_F1, Vins, ASARL, C31, O_l_hi},
    {V_p0, Vend},
};
@

<<global shrlc0>>=
/* shift right rp, const < 32 */
static uchar	shrlc0[][VLEN] =
{
    {Vinsr, ASHRL, O_r, O_l_rp},
    {Vins, O_a0, O_r, O_l_hi, Vend},
};
@

<<global shrlc1>>=
/* shift right rp, const == 32 */
static uchar	shrlc1[][VLEN] =
{
    {Vins, AMOVL, O_l_hi, O_l_lo},
    {V_T1, Vzero, O_l_hi},
    {V_F1, Vins, ASARL, C31, O_l_hi},
    {Vend},
};
@

<<global shrlc2>>=
/* shift right rp, const > 32 */
static uchar	shrlc2[][VLEN] =
{
    {Vins, O_a0, O_r, O_l_hi},
    {Vins, AMOVL, O_l_hi, O_l_lo},
    {V_T1, Vzero, O_l_hi},
    {V_F1, Vins, ASARL, C31, O_l_hi},
    {Vend},
};
@

<<global shrlac3>>=
/* shift right addr, const == 32 */
static uchar	shrlac3[][VLEN] =
{
    {Vins, AMOVL, O_l_hi, O_t_lo},
    {V_T1, Vzero, O_t_hi},
    {V_F1, Vins, AMOVL, O_t_lo, O_t_hi},
    {V_F1, Vins, ASARL, C31, O_t_hi},
    {Vend},
};
@

<<global shrlac4>>=
/* shift right addr, const > 32 */
static uchar	shrlac4[][VLEN] =
{
    {Vins, AMOVL, O_l_hi, O_t_lo},
    {Vins, O_a0, O_r, O_t_lo},
    {V_T1, Vzero, O_t_hi},
    {V_F1, Vins, AMOVL, O_t_lo, O_t_hi},
    {V_F1, Vins, ASARL, C31, O_t_hi},
    {Vend},
};
@

<<global shrl10>>=
/* shift right of constant */
static uchar	shrl10[][VLEN] =
{
    {Vop, OGE, O_r, C32},
    {V_s0, Vins, AMOVL, O_l_lo, O_t_lo},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {Vinsr, ASHRL, O_r, O_t_rp},
    {Vins, O_a0, O_r, O_t_hi, Vgo},
    {V_p0, V_s0},
    {Vins, AMOVL, O_l_hi, O_t_lo},
    {V_l_hi_t, Vins, O_a0, O_r, O_t_lo},
    {V_l_hi_u, V_S1},
    {V_T1, Vzero, O_t_hi, V_p0},
    {V_F1, Vins, AMOVL, O_t_lo, O_t_hi},
    {V_F1, Vins, ASARL, C31, O_t_hi},
    {Vend},
};
@

<<global shrltab>>=
static uchar	(*shrltab[])[VLEN] =
{
    shrl00,
    shrlc0,
    shrlc1,
    shrlc2,
    shrlac3,
    shrlac4,
    shrl10,
};
@

<<global asshllgen>>=
/* shift asop left general case */
static uchar	asshllgen[][VLEN] =
{
    {V_a0, V_a1},
    {Vop, OGE, O_r, C32},
    {V_s0, Vins, AMOVL, O_l_lo, O_r0},
    {Vins, AMOVL, O_l_hi, O_r1},
    {Vinsla, ASHLL, O_r, O_r0},
    {Vins, ASHLL, O_r, O_r0},
    {Vins, AMOVL, O_r1, O_l_hi},
    {Vins, AMOVL, O_r0, O_l_lo, Vgo},
    {V_p0, V_s0},
    {Vins, AMOVL, O_l_lo, O_r0},
    {Vzero, O_l_lo},
    {Vins, ASHLL, O_r, O_r0},
    {Vins, AMOVL, O_r0, O_l_hi, V_p0},
    {V_f0, V_f1, Vend},
};
@

<<global asshllclo>>=
/* shift asop left, const < 32 */
static uchar	asshllclo[][VLEN] =
{
    {V_a0, V_a1},
    {Vins, AMOVL, O_l_lo, O_r0},
    {Vins, AMOVL, O_l_hi, O_r1},
    {Vinsla, ASHLL, O_r, O_r0},
    {Vshll, O_r, O_r0},
    {Vins, AMOVL, O_r1, O_l_hi},
    {Vins, AMOVL, O_r0, O_l_lo},
    {V_f0, V_f1, Vend},
};
@

<<global asshllc32>>=
/* shift asop left, const == 32 */
static uchar	asshllc32[][VLEN] =
{
    {V_a0},
    {Vins, AMOVL, O_l_lo, O_r0},
    {Vzero, O_l_lo},
    {Vins, AMOVL, O_r0, O_l_hi},
    {V_f0, Vend},
};
@

<<global asshllchi>>=
/* shift asop left, const > 32 */
static uchar	asshllchi[][VLEN] =
{
    {V_a0},
    {Vins, AMOVL, O_l_lo, O_r0},
    {Vzero, O_l_lo},
    {Vshll, O_r, O_r0},
    {Vins, AMOVL, O_r0, O_l_hi},
    {V_f0, Vend},
};
@

<<global asdshllgen>>=
/* shift asop dest left general case */
static uchar	asdshllgen[][VLEN] =
{
    {Vop, OGE, O_r, C32},
    {V_s0, Vins, AMOVL, O_l_lo, O_t_lo},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {Vinsl, ASHLL, O_r, O_t_rp},
    {Vins, ASHLL, O_r, O_t_lo},
    {Vins, AMOVL, O_t_hi, O_l_hi},
    {Vins, AMOVL, O_t_lo, O_l_lo, Vgo},
    {V_p0, V_s0},
    {Vins, AMOVL, O_l_lo, O_t_hi},
    {Vzero, O_l_lo},
    {Vins, ASHLL, O_r, O_t_hi},
    {Vzero, O_t_lo},
    {Vins, AMOVL, O_t_hi, O_l_hi, V_p0},
    {Vend},
};
@

<<global asdshllclo>>=
/* shift asop dest left, const < 32 */
static uchar	asdshllclo[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_lo},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {Vinsl, ASHLL, O_r, O_t_rp},
    {Vshll, O_r, O_t_lo},
    {Vins, AMOVL, O_t_hi, O_l_hi},
    {Vins, AMOVL, O_t_lo, O_l_lo},
    {Vend},
};
@

<<global asdshllc32>>=
/* shift asop dest left, const == 32 */
static uchar	asdshllc32[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_hi},
    {Vzero, O_t_lo},
    {Vins, AMOVL, O_t_hi, O_l_hi},
    {Vins, AMOVL, O_t_lo, O_l_lo},
    {Vend},
};
@

<<global asdshllchi>>=
/* shift asop dest, const > 32 */
static uchar	asdshllchi[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_hi},
    {Vzero, O_t_lo},
    {Vshll, O_r, O_t_hi},
    {Vins, AMOVL, O_t_lo, O_l_lo},
    {Vins, AMOVL, O_t_hi, O_l_hi},
    {Vend},
};
@

<<global asshlltab>>=
static uchar	(*asshlltab[])[VLEN] =
{
    asshllgen,
    asshllclo,
    asshllc32,
    asshllchi,
    asdshllgen,
    asdshllclo,
    asdshllc32,
    asdshllchi,
};
@

<<global asshrlgen>>=
/* shift asop right general case */
static uchar	asshrlgen[][VLEN] =
{
    {V_a0, V_a1},
    {Vop, OGE, O_r, C32},
    {V_s0, Vins, AMOVL, O_l_lo, O_r0},
    {Vins, AMOVL, O_l_hi, O_r1},
    {Vinsra, ASHRL, O_r, O_r0},
    {Vinsx, Bop0, O_r, O_r1},
    {Vins, AMOVL, O_r0, O_l_lo},
    {Vins, AMOVL, O_r1, O_l_hi, Vgo},
    {V_p0, V_s0},
    {Vins, AMOVL, O_l_hi, O_r0},
    {Vinsx, Bop0, O_r, O_r0},
    {V_T1, Vzero, O_l_hi},
    {Vins, AMOVL, O_r0, O_l_lo},
    {V_F1, Vins, ASARL, C31, O_r0},
    {V_F1, Vins, AMOVL, O_r0, O_l_hi},
    {V_p0, V_f0, V_f1, Vend},
};
@

<<global asshrlclo>>=
/* shift asop right, const < 32 */
static uchar	asshrlclo[][VLEN] =
{
    {V_a0, V_a1},
    {Vins, AMOVL, O_l_lo, O_r0},
    {Vins, AMOVL, O_l_hi, O_r1},
    {Vinsra, ASHRL, O_r, O_r0},
    {Vinsx, Bop0, O_r, O_r1},
    {Vins, AMOVL, O_r0, O_l_lo},
    {Vins, AMOVL, O_r1, O_l_hi},
    {V_f0, V_f1, Vend},
};
@

<<global asshrlc32>>=
/* shift asop right, const == 32 */
static uchar	asshrlc32[][VLEN] =
{
    {V_a0},
    {Vins, AMOVL, O_l_hi, O_r0},
    {V_T1, Vzero, O_l_hi},
    {Vins, AMOVL, O_r0, O_l_lo},
    {V_F1, Vins, ASARL, C31, O_r0},
    {V_F1, Vins, AMOVL, O_r0, O_l_hi},
    {V_f0, Vend},
};
@

<<global asshrlchi>>=
/* shift asop right, const > 32 */
static uchar	asshrlchi[][VLEN] =
{
    {V_a0},
    {Vins, AMOVL, O_l_hi, O_r0},
    {V_T1, Vzero, O_l_hi},
    {Vinsx, Bop0, O_r, O_r0},
    {Vins, AMOVL, O_r0, O_l_lo},
    {V_F1, Vins, ASARL, C31, O_r0},
    {V_F1, Vins, AMOVL, O_r0, O_l_hi},
    {V_f0, Vend},
};
@

<<global asdshrlgen>>=
/* shift asop dest right general case */
static uchar	asdshrlgen[][VLEN] =
{
    {Vop, OGE, O_r, C32},
    {V_s0, Vins, AMOVL, O_l_lo, O_t_lo},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {Vinsr, ASHRL, O_r, O_t_rp},
    {Vinsx, Bop0, O_r, O_t_hi},
    {Vins, AMOVL, O_t_lo, O_l_lo},
    {Vins, AMOVL, O_t_hi, O_l_hi, Vgo},
    {V_p0, V_s0},
    {Vins, AMOVL, O_l_hi, O_t_lo},
    {V_T1, Vzero, O_t_hi},
    {Vinsx, Bop0, O_r, O_t_lo},
    {V_F1, Vins, AMOVL, O_t_lo, O_t_hi},
    {V_F1, Vins, ASARL, C31, O_t_hi},
    {Vins, AMOVL, O_t_hi, O_l_hi, V_p0},
    {Vend},
};
@

<<global asdshrlclo>>=
/* shift asop dest right, const < 32 */
static uchar	asdshrlclo[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_lo},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {Vinsr, ASHRL, O_r, O_t_rp},
    {Vinsx, Bop0, O_r, O_t_hi},
    {Vins, AMOVL, O_t_lo, O_l_lo},
    {Vins, AMOVL, O_t_hi, O_l_hi},
    {Vend},
};
@

<<global asdshrlc32>>=
/* shift asop dest right, const == 32 */
static uchar	asdshrlc32[][VLEN] =
{
    {Vins, AMOVL, O_l_hi, O_t_lo},
    {V_T1, Vzero, O_t_hi},
    {V_F1, Vins, AMOVL, O_t_lo, O_t_hi},
    {V_F1, Vins, ASARL, C31, O_t_hi},
    {Vins, AMOVL, O_t_lo, O_l_lo},
    {Vins, AMOVL, O_t_hi, O_l_hi},
    {Vend},
};
@

<<global asdshrlchi>>=
/* shift asop dest, const > 32 */
static uchar	asdshrlchi[][VLEN] =
{
    {Vins, AMOVL, O_l_hi, O_t_lo},
    {V_T1, Vzero, O_t_hi},
    {Vinsx, Bop0, O_r, O_t_lo},
    {V_T1, Vins, AMOVL, O_t_hi, O_l_hi},
    {V_T1, Vins, AMOVL, O_t_lo, O_l_lo},
    {V_F1, Vins, AMOVL, O_t_lo, O_t_hi},
    {V_F1, Vins, ASARL, C31, O_t_hi},
    {V_F1, Vins, AMOVL, O_t_lo, O_l_lo},
    {V_F1, Vins, AMOVL, O_t_hi, O_l_hi},
    {Vend},
};
@

<<global asshrltab>>=
static uchar	(*asshrltab[])[VLEN] =
{
    asshrlgen,
    asshrlclo,
    asshrlc32,
    asshrlchi,
    asdshrlgen,
    asdshrlclo,
    asdshrlc32,
    asdshrlchi,
};
@

<<global shrlargs>>=
static uchar	shrlargs[]	= { ASHRL, 1 };
@

<<global sarlargs>>=
static uchar	sarlargs[]	= { ASARL, 0 };
@

<<global incdec>>=
/* ++ -- */
static uchar	incdec[][VLEN] =
{
    {Vinsx, Bop0, C01, O_l_lo},
    {Vinsx, Bop1, C00, O_l_hi, Vend},
};
@

<<global incdecpre>>=
/* ++ -- *p */
static uchar	incdecpre[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_lo},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {Vinsx, Bop0, C01, O_t_lo},
    {Vinsx, Bop1, C00, O_t_hi},
    {Vins, AMOVL, O_t_lo, O_l_lo},
    {Vins, AMOVL, O_t_hi, O_l_hi, Vend},
};
@

<<global incdecpost>>=
/* *p ++ -- */
static uchar	incdecpost[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_lo},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {Vinsx, Bop0, C01, O_l_lo},
    {Vinsx, Bop1, C00, O_l_hi, Vend},
};
@

<<global binop00>>=
/* binop rp, rp */
static uchar	binop00[][VLEN] =
{
    {Vinsx, Bop0, O_r_lo, O_l_lo},
    {Vinsx, Bop1, O_r_hi, O_l_hi, Vend},
    {Vend},
};
@

<<global binoptmp>>=
/* binop rp, addr */
static uchar	binoptmp[][VLEN] =
{
    {V_a0, Vins, AMOVL, O_r_lo, O_r0},
    {Vinsx, Bop0, O_r0, O_l_lo},
    {Vins, AMOVL, O_r_hi, O_r0},
    {Vinsx, Bop1, O_r0, O_l_hi},
    {V_f0, Vend},
};
@

<<global binop11>>=
/* binop t = *a op *b */
static uchar	binop11[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_lo},
    {Vinsx, Bop0, O_r_lo, O_t_lo},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {Vinsx, Bop1, O_r_hi, O_t_hi, Vend},
};
@

<<global add0c>>=
/* binop t = rp +- c */
static uchar	add0c[][VLEN] =
{
    {V_r_lo_t, Vinsx, Bop0, O_r_lo, O_l_lo},
    {V_r_lo_f, Vamv, Bop0, Bop1},
    {Vinsx, Bop1, O_r_hi, O_l_hi},
    {Vend},
};
@

<<global and0c>>=
/* binop t = rp & c */
static uchar	and0c[][VLEN] =
{
    {V_r_lo_t, Vinsx, Bop0, O_r_lo, O_l_lo},
    {V_r_lo_f, Vins, AMOVL, C00, O_l_lo},
    {V_r_hi_t, Vinsx, Bop1, O_r_hi, O_l_hi},
    {V_r_hi_f, Vins, AMOVL, C00, O_l_hi},
    {Vend},
};
@

<<global or0c>>=
/* binop t = rp | c */
static uchar	or0c[][VLEN] =
{
    {V_r_lo_t, Vinsx, Bop0, O_r_lo, O_l_lo},
    {V_r_hi_t, Vinsx, Bop1, O_r_hi, O_l_hi},
    {Vend},
};
@

<<global sub10>>=
/* binop t = c - rp */
static uchar	sub10[][VLEN] =
{
    {V_a0, Vins, AMOVL, O_l_lo, O_r0},
    {Vinsx, Bop0, O_r_lo, O_r0},
    {Vins, AMOVL, O_l_hi, O_r_lo},
    {Vinsx, Bop1, O_r_hi, O_r_lo},
    {Vspazz, V_f0, Vend},
};
@

<<global addca>>=
/* binop t = c + *b */
static uchar	addca[][VLEN] =
{
    {Vins, AMOVL, O_r_lo, O_t_lo},
    {V_l_lo_t, Vinsx, Bop0, O_l_lo, O_t_lo},
    {V_l_lo_f, Vamv, Bop0, Bop1},
    {Vins, AMOVL, O_r_hi, O_t_hi},
    {Vinsx, Bop1, O_l_hi, O_t_hi},
    {Vend},
};
@

<<global andca>>=
/* binop t = c & *b */
static uchar	andca[][VLEN] =
{
    {V_l_lo_t, Vins, AMOVL, O_r_lo, O_t_lo},
    {V_l_lo_t, Vinsx, Bop0, O_l_lo, O_t_lo},
    {V_l_lo_f, Vzero, O_t_lo},
    {V_l_hi_t, Vins, AMOVL, O_r_hi, O_t_hi},
    {V_l_hi_t, Vinsx, Bop1, O_l_hi, O_t_hi},
    {V_l_hi_f, Vzero, O_t_hi},
    {Vend},
};
@

<<global orca>>=
/* binop t = c | *b */
static uchar	orca[][VLEN] =
{
    {Vins, AMOVL, O_r_lo, O_t_lo},
    {V_l_lo_t, Vinsx, Bop0, O_l_lo, O_t_lo},
    {Vins, AMOVL, O_r_hi, O_t_hi},
    {V_l_hi_t, Vinsx, Bop1, O_l_hi, O_t_hi},
    {Vend},
};
@

<<global subca>>=
/* binop t = c - *b */
static uchar	subca[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_lo},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {Vinsx, Bop0, O_r_lo, O_t_lo},
    {Vinsx, Bop1, O_r_hi, O_t_hi},
    {Vend},
};
@

<<global addac>>=
/* binop t = *a +- c */
static uchar	addac[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_lo},
    {V_r_lo_t, Vinsx, Bop0, O_r_lo, O_t_lo},
    {V_r_lo_f, Vamv, Bop0, Bop1},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {Vinsx, Bop1, O_r_hi, O_t_hi},
    {Vend},
};
@

<<global orac>>=
/* binop t = *a | c */
static uchar	orac[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_lo},
    {V_r_lo_t, Vinsx, Bop0, O_r_lo, O_t_lo},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {V_r_hi_t, Vinsx, Bop1, O_r_hi, O_t_hi},
    {Vend},
};
@

<<global andac>>=
/* binop t = *a & c */
static uchar	andac[][VLEN] =
{
    {V_r_lo_t, Vins, AMOVL, O_l_lo, O_t_lo},
    {V_r_lo_t, Vinsx, Bop0, O_r_lo, O_t_lo},
    {V_r_lo_f, Vzero, O_t_lo},
    {V_r_hi_t, Vins, AMOVL, O_l_hi, O_t_hi},
    {V_r_hi_t, Vinsx, Bop0, O_r_hi, O_t_hi},
    {V_r_hi_f, Vzero, O_t_hi},
    {Vend},
};
@

<<global ADDargs>>=
static uchar	ADDargs[]	= { AADDL, AADCL };
@

<<global ANDargs>>=
static uchar	ANDargs[]	= { AANDL, AANDL };
@

<<global ORargs>>=
static uchar	ORargs[]	= { AORL, AORL };
@

<<global SUBargs>>=
static uchar	SUBargs[]	= { ASUBL, ASBBL };
@

<<global XORargs>>=
static uchar	XORargs[]	= { AXORL, AXORL };
@

<<global ADDtab>>=
static uchar	(*ADDtab[])[VLEN] =
{
    add0c, addca, addac,
};
@

<<global ANDtab>>=
static uchar	(*ANDtab[])[VLEN] =
{
    and0c, andca, andac,
};
@

<<global ORtab>>=
static uchar	(*ORtab[])[VLEN] =
{
    or0c, orca, orac,
};
@

<<global SUBtab>>=
static uchar	(*SUBtab[])[VLEN] =
{
    add0c, subca, addac,
};
@

<<global mulc32>>=
/* mul of const32 */
static uchar	mulc32[][VLEN] =
{
    {V_a0, Vop, ONE, O_l_hi, C00},
    {V_s0, Vins, AMOVL, O_r_lo, O_r0},
    {Vins, AMULL, O_r0, O_Zop},
    {Vgo, V_p0, V_s0},
    {Vins, AMOVL, O_l_hi, O_r0},
    {Vmul, O_r_lo, O_r0},
    {Vins, AMOVL, O_r_lo, O_l_hi},
    {Vins, AMULL, O_l_hi, O_Zop},
    {Vins, AADDL, O_r0, O_l_hi},
    {V_f0, V_p0, Vend},
};
@

<<global mulc64>>=
/* mul of const64 */
static uchar	mulc64[][VLEN] =
{
    {V_a0, Vins, AMOVL, O_r_hi, O_r0},
    {Vop, OOR, O_l_hi, O_r0},
    {Vop, ONE, O_r0, C00},
    {V_s0, Vins, AMOVL, O_r_lo, O_r0},
    {Vins, AMULL, O_r0, O_Zop},
    {Vgo, V_p0, V_s0},
    {Vmul, O_r_lo, O_l_hi},
    {Vins, AMOVL, O_l_lo, O_r0},
    {Vmul, O_r_hi, O_r0},
    {Vins, AADDL, O_l_hi, O_r0},
    {Vins, AMOVL, O_r_lo, O_l_hi},
    {Vins, AMULL, O_l_hi, O_Zop},
    {Vins, AADDL, O_r0, O_l_hi},
    {V_f0, V_p0, Vend},
};
@

<<global mull>>=
/* mul general */
static uchar	mull[][VLEN] =
{
    {V_a0, Vins, AMOVL, O_r_hi, O_r0},
    {Vop, OOR, O_l_hi, O_r0},
    {Vop, ONE, O_r0, C00},
    {V_s0, Vins, AMOVL, O_r_lo, O_r0},
    {Vins, AMULL, O_r0, O_Zop},
    {Vgo, V_p0, V_s0},
    {Vins, AIMULL, O_r_lo, O_l_hi},
    {Vins, AMOVL, O_l_lo, O_r0},
    {Vins, AIMULL, O_r_hi, O_r0},
    {Vins, AADDL, O_l_hi, O_r0},
    {Vins, AMOVL, O_r_lo, O_l_hi},
    {Vins, AMULL, O_l_hi, O_Zop},
    {Vins, AADDL, O_r0, O_l_hi},
    {V_f0, V_p0, Vend},
};
@

<<global castrp>>=
/* cast rp l to rp t */
static uchar	castrp[][VLEN] =
{
    {Vmv, O_l, O_t_lo},
    {VT, Vins, AMOVL, O_t_lo, O_t_hi},
    {VT, Vins, ASARL, C31, O_t_hi},
    {VF, Vzero, O_t_hi},
    {Vend},
};
@

<<global castrpa>>=
/* cast rp l to addr t */
static uchar	castrpa[][VLEN] =
{
    {VT, V_a0, Vmv, O_l, O_r0},
    {VT, Vins, AMOVL, O_r0, O_t_lo},
    {VT, Vins, ASARL, C31, O_r0},
    {VT, Vins, AMOVL, O_r0, O_t_hi},
    {VT, V_f0},
    {VF, Vmv, O_l, O_t_lo},
    {VF, Vzero, O_t_hi},
    {Vend},
};
@

<<global netab0i>>=
static uchar	netab0i[][VLEN] =
{
    {Vop, ONE, O_l_lo, O_r_lo},
    {V_s0, Vop, ONE, O_l_hi, O_r_hi},
    {V_s1, Vgo, V_s2, Vgo, V_s3},
    {VF, V_p0, V_p1, VT, V_p2},
    {Vgo, V_p3},
    {VT, V_p0, V_p1, VF, V_p2},
    {Vend},
};
@

<<global netabii>>=
static uchar	netabii[][VLEN] =
{
    {V_a0, Vins, AMOVL, O_l_lo, O_r0},
    {Vop, ONE, O_r0, O_r_lo},
    {V_s0, Vins, AMOVL, O_l_hi, O_r0},
    {Vop, ONE, O_r0, O_r_hi},
    {V_s1, Vgo, V_s2, Vgo, V_s3},
    {VF, V_p0, V_p1, VT, V_p2},
    {Vgo, V_p3},
    {VT, V_p0, V_p1, VF, V_p2},
    {V_f0, Vend},
};
@

<<global cmptab0i>>=
static uchar	cmptab0i[][VLEN] =
{
    {Vopx, Bop0, O_l_hi, O_r_hi},
    {V_s0, Vins0, AJNE},
    {V_s1, Vopx, Bop1, O_l_lo, O_r_lo},
    {V_s2, Vgo, V_s3, Vgo, V_s4},
    {VT, V_p1, V_p3},
    {VF, V_p0, V_p2},
    {Vgo, V_p4},
    {VT, V_p0, V_p2},
    {VF, V_p1, V_p3},
    {Vend},
};
@

<<global cmptabii>>=
static uchar	cmptabii[][VLEN] =
{
    {V_a0, Vins, AMOVL, O_l_hi, O_r0},
    {Vopx, Bop0, O_r0, O_r_hi},
    {V_s0, Vins0, AJNE},
    {V_s1, Vins, AMOVL, O_l_lo, O_r0},
    {Vopx, Bop1, O_r0, O_r_lo},
    {V_s2, Vgo, V_s3, Vgo, V_s4},
    {VT, V_p1, V_p3},
    {VF, V_p0, V_p2},
    {Vgo, V_p4},
    {VT, V_p0, V_p2},
    {VF, V_p1, V_p3},
    {V_f0, Vend},
};
@

<<global NEtab>>=
static uchar	(*NEtab[])[VLEN] =
{
    netab0i, netabii,
};
@

<<global cmptab>>=
static uchar	(*cmptab[])[VLEN] =
{
    cmptab0i, cmptabii,
};
@

<<global GEargs>>=
static uchar	GEargs[]	= { OGT, OHS };
@

<<global GTargs>>=
static uchar	GTargs[]	= { OGT, OHI };
@

<<global HIargs>>=
static uchar	HIargs[]	= { OHI, OHI };
@

<<global HSargs>>=
static uchar	HSargs[]	= { OHI, OHS };
@

<<function biggen>>=
/* Big Generator */
static void
biggen(Node *l, Node *r, Node *t, int true, uchar code[][VLEN], uchar *a)
{
    int i, j, g, oc, op, lo, ro, to, xo, *xp;
    Type *lt;
    Prog *pr[VOPS];
    Node *ot, *tl, *tr, tmps[2];
    uchar *c, (*cp)[VLEN], args[VARGS];

    if(a != nil)
        memmove(args, a, VARGS);
//print("biggen %d %d %d\n", args[0], args[1], args[2]);
//if(l) prtree(l, "l");
//if(r) prtree(r, "r");
//if(t) prtree(t, "t");
    lo = ro = to = 0;
    cp = code;

    for (;;) {
        c = *cp++;
        g = 1;
        i = 0;
//print("code %d %d %d %d %d\n", c[0], c[1], c[2], c[3], c[4]);
        for(;;) {
            switch(op = c[i]) {
            case Vgo:
                if(g)
                    gbranch(OGOTO);
                i++;
                break;

            case Vamv:
                i += 3;
                if(i > VLEN) {
                    diag(l, "bad Vop");
                    return;
                }
                if(g)
                    args[c[i - 1]] = args[c[i - 2]];
                break;

            case Vzero:
                i += 2;
                if(i > VLEN) {
                    diag(l, "bad Vop");
                    return;
                }
                j = i - 1;
                goto op;

            case Vspazz:	// nasty hack to save a reg in SUB
//print("spazz\n");
                if(g) {
//print("hi %R lo %R t %R\n", r->right->reg, r->left->reg, tmps[0].reg);
                    ot = r->right;
                    r->right = r->left;
                    tl = new(0, Z, Z);
                    *tl = tmps[0];
                    r->left = tl;
                    tmps[0] = *ot;
//print("hi %R lo %R t %R\n", r->right->reg, r->left->reg, tmps[0].reg);
                }
                i++;
                break;

            case Vmv:
            case Vmul:
            case Vshll:
                i += 3;
                if(i > VLEN) {
                    diag(l, "bad Vop");
                    return;
                }
                j = i - 2;
                goto op;

            case Vins0:
                i += 2;
                if(i > VLEN) {
                    diag(l, "bad Vop");
                    return;
                }
                gins(c[i - 1], Z, Z);
                break;

            case Vop:
            case Vopx:
            case Vins:
            case Vinsl:
            case Vinsr:
            case Vinsla:
            case Vinsra:
            case Vinsx:
                i += 4;
                if(i > VLEN) {
                    diag(l, "bad Vop");
                    return;
                }
                j = i - 2;
                goto op;

            op:
                if(!g)
                    break;
                tl = Z;
                tr = Z;
                for(; j < i; j++) {
                    switch(c[j]) {
                    case C00:
                        ot = nodconst(0);
                        break;
                    case C01:
                        ot = nodconst(1);
                        break;
                    case C31:
                        ot = nodconst(31);
                        break;
                    case C32:
                        ot = nodconst(32);
                        break;

                    case O_l:
                    case O_l_lo:
                        ot = l; xp = &lo; xo = 0;
                        goto op0;
                    case O_l_hi:
                        ot = l; xp = &lo; xo = SZ_LONG;
                        goto op0;
                    case O_r:
                    case O_r_lo:
                        ot = r; xp = &ro; xo = 0;
                        goto op0;
                    case O_r_hi:
                        ot = r; xp = &ro; xo = SZ_LONG;
                        goto op0;
                    case O_t_lo:
                        ot = t; xp = &to; xo = 0;
                        goto op0;
                    case O_t_hi:
                        ot = t; xp = &to; xo = SZ_LONG;
                        goto op0;
                    case O_l_rp:
                        ot = l;
                        break;
                    case O_r_rp:
                        ot = r;
                        break;
                    case O_t_rp:
                        ot = t;
                        break;
                    case O_r0:
                    case O_r1:
                        ot = &tmps[c[j] - O_r0];
                        break;
                    case O_Zop:
                        ot = Z;
                        break;

                    op0:
                        switch(ot->op) {
                        case OCONST:
                            if(xo)
                                ot = hi64(ot);
                            else
                                ot = lo64(ot);
                            break;
                        case OREGPAIR:
                            if(xo)
                                ot = ot->right;
                            else
                                ot = ot->left;
                            break;
                        case OREGISTER:
                            break;
                        default:
                            if(xo != *xp) {
                                ot->xoffset += xo - *xp;
                                *xp = xo;
                            }
                        }
                        break;
                    
                    default:
                        diag(l, "bad V_lop");
                        return;
                    }
                    if(tl == nil)
                        tl = ot;
                    else
                        tr = ot;
                }
                if(op == Vzero) {
                    zeroregm(tl);
                    break;
                }
                oc = c[i - 3];
                if(op == Vinsx || op == Vopx) {
//print("%d -> %d\n", oc, args[oc]);
                    oc = args[oc];
                }
                else {
                    switch(oc) {
                    case O_a0:
                    case O_a1:
                        oc = args[oc - O_a0];
                        break;
                    }
                }
                switch(op) {
                case Vmul:
                    mulgen(tr->type, tl, tr);
                    break;
                case Vmv:
                    gmove(tl, tr);
                    break;
                case Vshll:
                    shiftit(tr->type, tl, tr);
                    break;
                case Vop:
                case Vopx:
                    gopcode(oc, types[TULONG], tl, tr);
                    break;
                case Vins:
                case Vinsx:
                    gins(oc, tl, tr);
                    break;
                case Vinsl:
                    gins(oc, tl, tr->right);
                    p->from.index = tr->left->reg;
                    break;
                case Vinsr:
                    gins(oc, tl, tr->left);
                    p->from.index = tr->right->reg;
                    break;
                case Vinsla:
                    gins(oc, tl, tr + 1);
                    p->from.index = tr->reg;
                    break;
                case Vinsra:
                    gins(oc, tl, tr);
                    p->from.index = (tr + 1)->reg;
                    break;
                }
                break;

            case VT:
                g = true;
                i++;
                break;
            case VF:
                g = !true;
                i++;
                break;

            case V_T0: case V_T1:
                g = args[op - V_T0];
                i++;
                break;

            case V_F0: case V_F1:
                g = !args[op - V_F0];
                i++;
                break;

            case V_C0: case V_C1:
                if(g)
                    args[op - V_C0] = 0;
                i++;
                break;

            case V_S0: case V_S1:
                if(g)
                    args[op - V_S0] = 1;
                i++;
                break;

            case V_l_lo_f:
                g = lo64v(l) == 0;
                i++;
                break;
            case V_l_hi_f:
                g = hi64v(l) == 0;
                i++;
                break;
            case V_l_lo_t:
                g = lo64v(l) != 0;
                i++;
                break;
            case V_l_hi_t:
                g = hi64v(l) != 0;
                i++;
                break;
            case V_l_lo_u:
                g = lo64v(l) >= 0;
                i++;
                break;
            case V_l_hi_u:
                g = hi64v(l) >= 0;
                i++;
                break;
            case V_r_lo_f:
                g = lo64v(r) == 0;
                i++;
                break;
            case V_r_hi_f:
                g = hi64v(r) == 0;
                i++;
                break;
            case V_r_lo_t:
                g = lo64v(r) != 0;
                i++;
                break;
            case V_r_hi_t:
                g = hi64v(r) != 0;
                i++;
                break;
            case V_r_lo_u:
                g = lo64v(r) >= 0;
                i++;
                break;
            case V_r_hi_u:
                g = hi64v(r) >= 0;
                i++;
                break;

            case Vend:
                goto out;

            case V_a0: case V_a1:
                if(g) {
                    lt = l->type;
                    l->type = types[TULONG];
                    regalloc(&tmps[op - V_a0], l, Z);
                    l->type = lt;
                }
                i++;
                break;

            case V_f0: case V_f1:
                if(g)
                    regfree(&tmps[op - V_f0]);
                i++;
                break;

            case V_p0: case V_p1: case V_p2: case V_p3: case V_p4:
                if(g)
                    patch(pr[op - V_p0], pc);
                i++;
                break;

            case V_s0: case V_s1: case V_s2: case V_s3: case V_s4:
                if(g)
                    pr[op - V_s0] = p;
                i++;
                break;

            default:
                diag(l, "bad biggen: %d", op);
                return;
            }
            if(i == VLEN || c[i] == 0)
                break;
        }
    }
out:
    if(lo)
        l->xoffset -= lo;
    if(ro)
        r->xoffset -= ro;
    if(to)
        t->xoffset -= to;
}
@

<<function IMM>>=
#define	IMM(l, r)	((l) | ((r) << 1))
@

<<function WW>>=
#define	WW(l, r)	((l) | ((r) << 2))
@

<<function cgen64>>=
int
cgen64(Node *n, Node *nn)
{
    Type *dt;
    uchar *args, (*cp)[VLEN], (**optab)[VLEN];
    int li, ri, lri, dr, si, m, op, sh, cmp, true;
    Node *c, *d, *l, *r, *t, *s, nod1, nod2, nod3, nod4, nod5;

    if(debug['g']) {
        prtree(nn, "cgen64 lhs");
        prtree(n, "cgen64");
        print("AX = %d\n", reg[D_AX]);
    }
    cmp = 0;
    sh = 0;

    switch(n->op) {
    case ONEG:
        d = regpair(nn, n);
        sugen(n->left, d, 8);
        gins(ANOTL, Z, d->right);
        gins(ANEGL, Z, d->left);
        gins(ASBBL, nodconst(-1), d->right);
        break;

    case OCOM:
        if(!vaddr(n->left, 0) || !vaddr(nn, 0))
            d = regpair(nn, n);
        else
            return 0;
        sugen(n->left, d, 8);
        gins(ANOTL, Z, d->left);
        gins(ANOTL, Z, d->right);
        break;

    case OADD:
        optab = ADDtab;
        args = ADDargs;
        goto twoop;
    case OAND:
        optab = ANDtab;
        args = ANDargs;
        goto twoop;
    case OOR:
        optab = ORtab;
        args = ORargs;
        goto twoop;
    case OSUB:
        optab = SUBtab;
        args = SUBargs;
        goto twoop;
    case OXOR:
        optab = ORtab;
        args = XORargs;
        goto twoop;
    case OASHL:
        sh = 1;
        args = nil;
        optab = shlltab;
        goto twoop;
    case OLSHR:
        sh = 1;
        args = shrlargs;
        optab = shrltab;
        goto twoop;
    case OASHR:
        sh = 1;
        args = sarlargs;
        optab = shrltab;
        goto twoop;
    case OEQ:
        cmp = 1;
        args = nil;
        optab = nil;
        goto twoop;
    case ONE:
        cmp = 1;
        args = nil;
        optab = nil;
        goto twoop;
    case OLE:
        cmp = 1;
        args = nil;
        optab = nil;
        goto twoop;
    case OLT:
        cmp = 1;
        args = nil;
        optab = nil;
        goto twoop;
    case OGE:
        cmp = 1;
        args = nil;
        optab = nil;
        goto twoop;
    case OGT:
        cmp = 1;
        args = nil;
        optab = nil;
        goto twoop;
    case OHI:
        cmp = 1;
        args = nil;
        optab = nil;
        goto twoop;
    case OHS:
        cmp = 1;
        args = nil;
        optab = nil;
        goto twoop;
    case OLO:
        cmp = 1;
        args = nil;
        optab = nil;
        goto twoop;
    case OLS:
        cmp = 1;
        args = nil;
        optab = nil;
        goto twoop;

twoop:
        dr = nn != Z && nn->op == OREGPAIR;
        l = vfunc(n->left, nn);
        if(sh)
            r = n->right;
        else
            r = vfunc(n->right, nn);

        li = l->op == ONAME || l->op == OINDREG || l->op == OCONST;
        ri = r->op == ONAME || r->op == OINDREG || r->op == OCONST;


        lri = IMM(li, ri);

        /* find out what is so easy about some operands */
        if(li)
            li = whatof(l, sh | cmp);
        if(ri)
            ri = whatof(r, cmp);

        if(sh)
            goto shift;

        if(cmp)
            goto cmp;

        /* evaluate hard subexps, stealing nn if possible. */
        switch(lri) {
        case IMM(0, 0):
        bin00:
            if(l->complex > r->complex) {
                if(dr)
                    t = nn;
                else
                    t = regpair(Z, n);
                sugen(l, t, 8);
                l = t;
                t = regpair(Z, n);
                sugen(r, t, 8);
                r = t;
            }
            else {
                t = regpair(Z, n);
                sugen(r, t, 8);
                r = t;
                if(dr)
                    t = nn;
                else
                    t = regpair(Z, n);
                sugen(l, t, 8);
                l = t;
            }
            break;
        case IMM(0, 1):
            if(dr)
                t = nn;
            else
                t = regpair(Z, n);
            sugen(l, t, 8);
            l = t;
            break;
        case IMM(1, 0):
            if(n->op == OSUB && l->op == OCONST && hi64v(l) == 0) {
                lri = IMM(0, 0);
                goto bin00;
            }
            if(dr)
                t = nn;
            else
                t = regpair(Z, n);
            sugen(r, t, 8);
            r = t;
            break;
        case IMM(1, 1):
            break;
        }

        d = Z;
        dt = nn->type;
        nn->type = types[TLONG];

        switch(lri) {
        case IMM(0, 0):
            biggen(l, r, Z, 0, binop00, args);
            break;
        case IMM(0, 1):
            switch(ri) {
            case WNONE:
                diag(r, "bad whatof\n");
                break;
            case WCONST:
                biggen(l, r, Z, 0, optab[B0c], args);
                break;
            case WHARD:
                reglcgen(&nod2, r, Z);
                r = &nod2;
                /* fall thru */
            case WADDR:
                biggen(l, r, Z, 0, binoptmp, args);
                if(ri == WHARD)
                    regfree(r);
                break;
            }
            break;
        case IMM(1, 0):
            if(n->op == OSUB) {
                switch(li) {
                case WNONE:
                    diag(l, "bad whatof\n");
                    break;
                case WHARD:
                    reglcgen(&nod2, l, Z);
                    l = &nod2;
                    /* fall thru */
                case WADDR:
                case WCONST:
                    biggen(l, r, Z, 0, sub10, args);
                    break;
                }
                if(li == WHARD)
                    regfree(l);
            }
            else {
                switch(li) {
                case WNONE:
                    diag(l, "bad whatof\n");
                    break;
                case WCONST:
                    biggen(r, l, Z, 0, optab[B0c], args);
                    break;
                case WHARD:
                    reglcgen(&nod2, l, Z);
                    l = &nod2;
                    /* fall thru */
                case WADDR:
                    biggen(r, l, Z, 0, binoptmp, args);
                    if(li == WHARD)
                        regfree(l);
                    break;
                }
            }
            break;
        case IMM(1, 1):
            switch(WW(li, ri)) {
            case WW(WCONST, WHARD):
                if(r->op == ONAME && n->op == OAND && reduxv(l))
                    ri = WADDR;
                break;
            case WW(WHARD, WCONST):
                if(l->op == ONAME && n->op == OAND && reduxv(r))
                    li = WADDR;
                break;
            }
            if(li == WHARD) {
                reglcgen(&nod3, l, Z);
                l = &nod3;
            }
            if(ri == WHARD) {
                reglcgen(&nod2, r, Z);
                r = &nod2;
            }
            d = regpair(nn, n);
            instpair(d, Z);
            switch(WW(li, ri)) {
            case WW(WCONST, WADDR):
            case WW(WCONST, WHARD):
                biggen(l, r, d, 0, optab[Bca], args);
                break;

            case WW(WADDR, WCONST):
            case WW(WHARD, WCONST):
                biggen(l, r, d, 0, optab[Bac], args);
                break;

            case WW(WADDR, WADDR):
            case WW(WADDR, WHARD):
            case WW(WHARD, WADDR):
            case WW(WHARD, WHARD):
                biggen(l, r, d, 0, binop11, args);
                break;

            default:
                diag(r, "bad whatof pair %d %d\n", li, ri);
                break;
            }
            if(li == WHARD)
                regfree(l);
            if(ri == WHARD)
                regfree(r);
            break;
        }

        nn->type = dt;

        if(d != Z)
            goto finished;

        switch(lri) {
        case IMM(0, 0):
            freepair(r);
            /* fall thru */;
        case IMM(0, 1):
            if(!dr)
                storepair(l, nn, 1);
            break;
        case IMM(1, 0):
            if(!dr)
                storepair(r, nn, 1);
            break;
        case IMM(1, 1):
            break;
        }
        return 1;

    shift:
        c = Z;

        /* evaluate hard subexps, stealing nn if possible. */
        /* must also secure CX.  not as many optims as binop. */
        switch(lri) {
        case IMM(0, 0):
        imm00:
            if(l->complex + 1 > r->complex) {
                if(dr)
                    t = nn;
                else
                    t = regpair(Z, l);
                sugen(l, t, 8);
                l = t;
                t = &nod1;
                c = snarfreg(l, t, D_CX, r, &nod2);
                cgen(r, t);
                r = t;
            }
            else {
                t = &nod1;
                c = snarfreg(nn, t, D_CX, r, &nod2);
                cgen(r, t);
                r = t;
                if(dr)
                    t = nn;
                else
                    t = regpair(Z, l);
                sugen(l, t, 8);
                l = t;
            }
            break;
        case IMM(0, 1):
        imm01:
            if(ri != WCONST) {
                lri = IMM(0, 0);
                goto imm00;
            }
            if(dr)
                t = nn;
            else
                t = regpair(Z, n);
            sugen(l, t, 8);
            l = t;
            break;
        case IMM(1, 0):
        imm10:
            if(li != WCONST) {
                lri = IMM(0, 0);
                goto imm00;
            }
            t = &nod1;
            c = snarfreg(nn, t, D_CX, r, &nod2);
            cgen(r, t);
            r = t;
            break;
        case IMM(1, 1):
            if(ri != WCONST) {
                lri = IMM(1, 0);
                goto imm10;
            }
            if(li == WHARD) {
                lri = IMM(0, 1);
                goto imm01;
            }
            break;
        }

        d = Z;

        switch(lri) {
        case IMM(0, 0):
            biggen(l, r, Z, 0, optab[S00], args);
            break;
        case IMM(0, 1):
            switch(ri) {
            case WNONE:
            case WADDR:
            case WHARD:
                diag(r, "bad whatof\n");
                break;
            case WCONST:
                m = r->vconst & 63;
                s = nodconst(m);
                if(m < 32)
                    cp = optab[Sc0];
                else if(m == 32)
                    cp = optab[Sc1];
                else
                    cp = optab[Sc2];
                biggen(l, s, Z, 0, cp, args);
                break;
            }
            break;
        case IMM(1, 0):
            /* left is const */
            d = regpair(nn, n);
            instpair(d, Z);
            biggen(l, r, d, 0, optab[S10], args);
            regfree(r);
            break;
        case IMM(1, 1):
            d = regpair(nn, n);
            instpair(d, Z);
            switch(WW(li, ri)) {
            case WW(WADDR, WCONST):
                m = r->vconst & 63;
                s = nodconst(m);
                if(m < 32) {
                    loadpair(l, d);
                    l = d;
                    cp = optab[Sc0];
                }
                else if(m == 32)
                    cp = optab[Sac3];
                else
                    cp = optab[Sac4];
                biggen(l, s, d, 0, cp, args);
                break;

            default:
                diag(r, "bad whatof pair %d %d\n", li, ri);
                break;
            }
            break;
        }

        if(c != Z) {
            gins(AMOVL, c, r);
            regfree(c);
        }

        if(d != Z)
            goto finished;

        switch(lri) {
        case IMM(0, 0):
            regfree(r);
            /* fall thru */
        case IMM(0, 1):
            if(!dr)
                storepair(l, nn, 1);
            break;
        case IMM(1, 0):
            regfree(r);
            break;
        case IMM(1, 1):
            break;
        }
        return 1;

    cmp:
        op = n->op;
        /* evaluate hard subexps */
        switch(lri) {
        case IMM(0, 0):
            if(l->complex > r->complex) {
                t = regpair(Z, l);
                sugen(l, t, 8);
                l = t;
                t = regpair(Z, r);
                sugen(r, t, 8);
                r = t;
            }
            else {
                t = regpair(Z, r);
                sugen(r, t, 8);
                r = t;
                t = regpair(Z, l);
                sugen(l, t, 8);
                l = t;
            }
            break;
        case IMM(1, 0):
            t = r;
            r = l;
            l = t;
            ri = li;
            op = invrel[relindex(op)];
            /* fall thru */
        case IMM(0, 1):
            t = regpair(Z, l);
            sugen(l, t, 8);
            l = t;
            break;
        case IMM(1, 1):
            break;
        }

        true = 1;
        optab = cmptab;
        switch(op) {
        case OEQ:
            optab = NEtab;
            true = 0;
            break;
        case ONE:
            optab = NEtab;
            break;
        case OLE:
            args = GTargs;
            true = 0;
            break;
        case OGT:
            args = GTargs;
            break;
        case OLS:
            args = HIargs;
            true = 0;
            break;
        case OHI:
            args = HIargs;
            break;
        case OLT:
            args = GEargs;
            true = 0;
            break;
        case OGE:
            args = GEargs;
            break;
        case OLO:
            args = HSargs;
            true = 0;
            break;
        case OHS:
            args = HSargs;
            break;
        default:
            diag(n, "bad cmp\n");
            SET(optab);
        }

        switch(lri) {
        case IMM(0, 0):
            biggen(l, r, Z, true, optab[T0i], args);
            break;
        case IMM(0, 1):
        case IMM(1, 0):
            switch(ri) {
            case WNONE:
                diag(l, "bad whatof\n");
                break;
            case WCONST:
                biggen(l, r, Z, true, optab[T0i], args);
                break;
            case WHARD:
                reglcgen(&nod2, r, Z);
                r = &nod2;
                /* fall thru */
            case WADDR:
                biggen(l, r, Z, true, optab[T0i], args);
                if(ri == WHARD)
                    regfree(r);
                break;
            }
            break;
        case IMM(1, 1):
            if(li == WHARD) {
                reglcgen(&nod3, l, Z);
                l = &nod3;
            }
            if(ri == WHARD) {
                reglcgen(&nod2, r, Z);
                r = &nod2;
            }
            biggen(l, r, Z, true, optab[Tii], args);
            if(li == WHARD)
                regfree(l);
            if(ri == WHARD)
                regfree(r);
            break;
        }

        switch(lri) {
        case IMM(0, 0):
            freepair(r);
            /* fall thru */;
        case IMM(0, 1):
        case IMM(1, 0):
            freepair(l);
            break;
        case IMM(1, 1):
            break;
        }
        return 1;

    case OASMUL:
    case OASLMUL:
        m = 0;
        goto mulop;

    case OMUL:
    case OLMUL:
        m = 1;
        goto mulop;

    mulop:
        dr = nn != Z && nn->op == OREGPAIR;
        l = vfunc(n->left, nn);
        r = vfunc(n->right, nn);
        if(r->op != OCONST) {
            if(l->complex > r->complex) {
                if(m) {
                    t = l;
                    l = r;
                    r = t;
                }
                else if(!vaddr(l, 1)) {
                    reglcgen(&nod5, l, Z);
                    l = &nod5;
                    evacaxdx(l);
                }
            }
            t = regpair(Z, n);
            sugen(r, t, 8);
            r = t;
            evacaxdx(r->left);
            evacaxdx(r->right);
            if(l->complex <= r->complex && !m && !vaddr(l, 1)) {
                reglcgen(&nod5, l, Z);
                l = &nod5;
                evacaxdx(l);
            }
        }
        if(dr)
            t = nn;
        else
            t = regpair(Z, n);
        //print("dr=%d ", dr); prtree(t, "t");
        c = Z;
        d = Z;
        if(!nodreg(&nod1, t->left, D_AX)) {
            if(t->left->reg != D_AX){
                t->left->reg = D_AX;
                reg[D_AX]++;
            }else if(reg[D_AX] == 0)
                fatal(Z, "vlong mul AX botch");
        }
        if(!nodreg(&nod2, t->right, D_DX)) {
            if(t->right->reg != D_DX){
                t->right->reg = D_DX;
                reg[D_DX]++;
            }else if(reg[D_DX] == 0)
                fatal(Z, "vlong mul DX botch");
        }
        //prtree(t, "t1"); print("reg/ax = %d reg/dx = %d\n", reg[D_AX], reg[D_DX]);
        if(m)
            sugen(l, t, 8);
        else
            loadpair(l, t);
        //prtree(t, "t2"); print("reg/ax = %d reg/dx = %d\n", reg[D_AX], reg[D_DX]);
        if(t->left->reg != D_AX) {
            c = &nod3;
            regsalloc(c, t->left);
            gmove(&nod1, c);
            gmove(t->left, &nod1);
            zapreg(t->left);
        }
        //print("reg/ax = %d reg/dx = %d\n", reg[D_AX], reg[D_DX]);
        if(t->right->reg != D_DX) {
            d = &nod4;
            regsalloc(d, t->right);
            gmove(&nod2, d);
            if(t->right->reg == D_AX && c != nil){
                /* need previous value of AX in DX */
                gmove(c, &nod2);
            }else
                gmove(t->right, &nod2);
            zapreg(t->right);
        }
        if(c != Z || d != Z) {
            s = regpair(Z, n);
            s->left = &nod1;
            s->right = &nod2;
        }
        else
            s = t;
        reg[D_AX]++;	/* don't allow biggen to allocate AX or DX (smashed by MUL) as temp */
        reg[D_DX]++;
        if(r->op == OCONST) {
            if(hi64v(r) == 0)
                biggen(s, r, Z, 0, mulc32, nil);
            else
                biggen(s, r, Z, 0, mulc64, nil);
        }
        else
            biggen(s, r, Z, 0, mull, nil);
        instpair(t, Z);
        reg[D_AX]--;
        reg[D_DX]--;
        if(c != Z) {
            gmove(&nod1, t->left);
            gmove(&nod3, &nod1);
        }
        if(d != Z) {
            gmove(&nod2, t->right);
            gmove(&nod4, &nod2);
        }

        if(r->op == OREGPAIR)
            freepair(r);
        if(!m)
            storepair(t, l, 0);
        if(l == &nod5)
            regfree(l);

        if(!dr) {
            if(nn != Z)
                storepair(t, nn, 1);
            else
                freepair(t);
        }
        return 1;

    case OASADD:
        args = ADDargs;
        goto vasop;
    case OASAND:
        args = ANDargs;
        goto vasop;
    case OASOR:
        args = ORargs;
        goto vasop;
    case OASSUB:
        args = SUBargs;
        goto vasop;
    case OASXOR:
        args = XORargs;
        goto vasop;

    vasop:
        l = n->left;
        r = n->right;
        dr = nn != Z && nn->op == OREGPAIR;
        m = 0;
        if(l->complex > r->complex) {
            if(!vaddr(l, 1)) {
                reglcgen(&nod1, l, Z);
                l = &nod1;
            }
            if(!vaddr(r, 1) || nn != Z || r->op == OCONST) {
                if(dr)
                    t = nn;
                else
                    t = regpair(Z, r);
                sugen(r, t, 8);
                r = t;
                m = 1;
            }
        }
        else {
            if(!vaddr(r, 1) || nn != Z || r->op == OCONST) {
                if(dr)
                    t = nn;
                else
                    t = regpair(Z, r);
                sugen(r, t, 8);
                r = t;
                m = 1;
            }
            if(!vaddr(l, 1)) {
                reglcgen(&nod1, l, Z);
                l = &nod1;
            }
        }
        if(nn != Z) {
            if(n->op == OASSUB)
                biggen(l, r, Z, 0, sub10, args);
            else
                biggen(r, l, Z, 0, binoptmp, args);
            storepair(r, l, 0);
        }
        else {
            if(m)
                biggen(l, r, Z, 0, binop00, args);
            else
                biggen(l, r, Z, 0, binoptmp, args);
        }
        if(l == &nod1)
            regfree(&nod1);
        if(m) {
            if(nn == Z)
                freepair(r);
            else if(!dr)
                storepair(r, nn, 1);
        }
        return 1;

    case OASASHL:
        args = nil;
        optab = asshlltab;
        goto assh;
    case OASLSHR:
        args = shrlargs;
        optab = asshrltab;
        goto assh;
    case OASASHR:
        args = sarlargs;
        optab = asshrltab;
        goto assh;

    assh:
        c = Z;
        l = n->left;
        r = n->right;
        if(r->op == OCONST) {
            m = r->vconst & 63;
            if(m < 32)
                m = SAclo;
            else if(m == 32)
                m = SAc32;
            else
                m = SAchi;
        }
        else
            m = SAgen;
        if(l->complex > r->complex) {
            if(!vaddr(l, 0)) {
                reglcgen(&nod1, l, Z);
                l = &nod1;
            }
            if(m == SAgen) {
                t = &nod2;
                if(l->reg == D_CX) {
                    regalloc(t, r, Z);
                    gmove(l, t);
                    l->reg = t->reg;
                    t->reg = D_CX;
                }
                else
                    c = snarfreg(nn, t, D_CX, r, &nod3);
                cgen(r, t);
                r = t;
            }
        }
        else {
            if(m == SAgen) {
                t = &nod2;
                c = snarfreg(nn, t, D_CX, r, &nod3);
                cgen(r, t);
                r = t;
            }
            if(!vaddr(l, 0)) {
                reglcgen(&nod1, l, Z);
                l = &nod1;
            }
        }

        if(nn != Z) {
            m += SAdgen - SAgen;
            d = regpair(nn, n);
            instpair(d, Z);
            biggen(l, r, d, 0, optab[m], args);
            if(l == &nod1) {
                regfree(&nod1);
                l = Z;
            }
            if(r == &nod2 && c == Z) {
                regfree(&nod2);
                r = Z;
            }
            if(d != nn)
                storepair(d, nn, 1);
        }
        else
            biggen(l, r, Z, 0, optab[m], args);

        if(c != Z) {
            gins(AMOVL, c, r);
            regfree(c);
        }
        if(l == &nod1)
            regfree(&nod1);
        if(r == &nod2)
            regfree(&nod2);
        return 1;

    case OPOSTINC:
        args = ADDargs;
        cp = incdecpost;
        goto vinc;
    case OPOSTDEC:
        args = SUBargs;
        cp = incdecpost;
        goto vinc;
    case OPREINC:
        args = ADDargs;
        cp = incdecpre;
        goto vinc;
    case OPREDEC:
        args = SUBargs;
        cp = incdecpre;
        goto vinc;

    vinc:
        l = n->left;
        if(!vaddr(l, 1)) {
            reglcgen(&nod1, l, Z);
            l = &nod1;
        }
        
        if(nn != Z) {
            d = regpair(nn, n);
            instpair(d, Z);
            biggen(l, Z, d, 0, cp, args);
            if(l == &nod1) {
                regfree(&nod1);
                l = Z;
            }
            if(d != nn)
                storepair(d, nn, 1);
        }
        else
            biggen(l, Z, Z, 0, incdec, args);

        if(l == &nod1)
            regfree(&nod1);
        return 1;

    case OCAST:
        l = n->left;
        if(typev[l->type->etype]) {
            if(!vaddr(l, 1)) {
                if(l->complex + 1 > nn->complex) {
                    d = regpair(Z, l);
                    sugen(l, d, 8);
                    if(!vaddr(nn, 1)) {
                        reglcgen(&nod1, nn, Z);
                        r = &nod1;
                    }
                    else
                        r = nn;
                }
                else {
                    if(!vaddr(nn, 1)) {
                        reglcgen(&nod1, nn, Z);
                        r = &nod1;
                    }
                    else
                        r = nn;
                    d = regpair(Z, l);
                    sugen(l, d, 8);
                }
//				d->left->type = r->type;
                d->left->type = types[TLONG];
                gmove(d->left, r);
                freepair(d);
            }
            else {
                if(nn->op != OREGISTER && !vaddr(nn, 1)) {
                    reglcgen(&nod1, nn, Z);
                    r = &nod1;
                }
                else
                    r = nn;
//				l->type = r->type;
                l->type = types[TLONG];
                gmove(l, r);
            }
            if(r != nn)
                regfree(r);
        }
        else {
            if(typeu[l->type->etype] || cond(l->op))
                si = TUNSIGNED;
            else
                si = TSIGNED;
            regalloc(&nod1, l, Z);
            cgen(l, &nod1);
            if(nn->op == OREGPAIR) {
                m = instpair(nn, &nod1);
                biggen(&nod1, Z, nn, si == TSIGNED, castrp, nil);
            }
            else {
                m = 0;
                if(!vaddr(nn, si != TSIGNED)) {
                    dt = nn->type;
                    nn->type = types[TLONG];
                    reglcgen(&nod2, nn, Z);
                    nn->type = dt;
                    nn = &nod2;
                }
                dt = nn->type;
                nn->type = types[TLONG];
                biggen(&nod1, Z, nn, si == TSIGNED, castrpa, nil);
                nn->type = dt;
                if(nn == &nod2)
                    regfree(&nod2);
            }
            if(!m)
                regfree(&nod1);
        }
        return 1;

    default:
        if(n->op == OREGPAIR) {
            storepair(n, nn, 1);
            return 1;
        }
        if(nn->op == OREGPAIR) {
            loadpair(n, nn);
            return 1;
        }
        return 0;
    }
finished:
    if(d != nn)
        storepair(d, nn, 1);
    return 1;
}
@

<<function testv>>=
void
testv(Node *n, int true)
{
    Type *t;
    Node *nn, nod, *b;

    if(machcap(Z)) {
        b = &nod;
        b->op = true ? ONE : OEQ;
        b->left = n;
        b->right = new(0, Z, Z);
        *b->right = *nodconst(0);
        b->right->type = n->type;
        b->type = types[TLONG];
        cgen64(b, Z);
        return;
    }

    switch(n->op) {
    case OINDREG:
    case ONAME:
        biggen(n, Z, Z, true, testi, nil);
        break;

    default:
        n = vfunc(n, n);
        if(n->addable >= INDEXED) {
            t = n->type;
            n->type = types[TLONG];
            reglcgen(&nod, n, Z);
            n->type = t;
            n = &nod;
            biggen(n, Z, Z, true, testi, nil);
            if(n == &nod)
                regfree(n);
        }
        else {
            nn = regpair(Z, n);
            sugen(n, nn, 8);
            biggen(nn, Z, Z, true, testi, nil);
            freepair(nn);
        }
    }
}
@


%-------------------------------------------------------------

<<8c/cgen64.c>>=
#include "gc.h"

long	lo64v(Node*);
long	hi64v(Node*);

<<function zeroregm>>

<<function vaddr>>

<<function hi64v>>

<<function lo64v>>

<<function hi64>>

<<function lo64>>

<<function anonreg>>

<<function regpair>>

<<function evacaxdx>>

<<function instpair>>

<<function zapreg>>

<<function freepair>>

<<function loadpair>>

<<function storepair>>

<<enum _anon_ (8c/cgen64.c)>>

<<function whatof>>

<<function reduxv>>

<<function cond>>

<<function vfunc>>

<<function getreg>>

<<function snarfreg>>

<<enum _anon_ (8c/cgen64.c)2>>

<<global testi>>

<<global shll00>>

<<global shllc0>>

<<global shllc1>>

<<global shllc2>>

<<global shllac3>>

<<global shllac4>>

<<global shll10>>

<<global shlltab>>

<<global shrl00>>

<<global shrlc0>>

<<global shrlc1>>

<<global shrlc2>>

<<global shrlac3>>

<<global shrlac4>>

<<global shrl10>>

<<global shrltab>>

<<global asshllgen>>

<<global asshllclo>>

<<global asshllc32>>

<<global asshllchi>>

<<global asdshllgen>>

<<global asdshllclo>>

<<global asdshllc32>>

<<global asdshllchi>>

<<global asshlltab>>

<<global asshrlgen>>

<<global asshrlclo>>

<<global asshrlc32>>

<<global asshrlchi>>

<<global asdshrlgen>>

<<global asdshrlclo>>

<<global asdshrlc32>>

<<global asdshrlchi>>

<<global asshrltab>>

<<global shrlargs>>
<<global sarlargs>>

<<global incdec>>

<<global incdecpre>>

<<global incdecpost>>

<<global binop00>>

<<global binoptmp>>

<<global binop11>>

<<global add0c>>

<<global and0c>>

<<global or0c>>

<<global sub10>>

<<global addca>>

<<global andca>>

<<global orca>>

<<global subca>>

<<global addac>>

<<global orac>>

<<global andac>>

<<global ADDargs>>
<<global ANDargs>>
<<global ORargs>>
<<global SUBargs>>
<<global XORargs>>

<<global ADDtab>>

<<global ANDtab>>

<<global ORtab>>

<<global SUBtab>>

<<global mulc32>>

<<global mulc64>>

<<global mull>>

<<global castrp>>

<<global castrpa>>

<<global netab0i>>

<<global netabii>>

<<global cmptab0i>>

<<global cmptabii>>

<<global NEtab>>

<<global cmptab>>

<<global GEargs>>
<<global GTargs>>
<<global HIargs>>
<<global HSargs>>

<<function biggen>>

<<function IMM>>

<<function WW>>

<<function cgen64>>

<<function testv>>
@


\subsection*{[[8c/div.c]]}

<<function TN>>=
/*
 * Based on: Granlund, T.; Montgomery, P.L.
 * "Division by Invariant Integers using Multiplication".
 * SIGPLAN Notices, Vol. 29, June 1994, page 61.
 */

#define	TN(n)	((uvlong)1 << (n))
@
% >>

<<constant T31>>=
#define	T31	TN(31)
@

<<constant T32>>=
#define	T32	TN(32)
@

<<function multiplier>>=
int
multiplier(ulong d, int p, uvlong *mp)
{
    int l;
    uvlong mlo, mhi, tlo, thi;

    l = topbit(d - 1) + 1;
    mlo = (((TN(l) - d) << 32) / d) + T32;
    if(l + p == 64)
        mhi = (((TN(l) + 1 - d) << 32) / d) + T32;
    else
        mhi = (TN(32 + l) + TN(32 + l - p)) / d;
    assert(mlo < mhi);
    while(l > 0) {
        tlo = mlo >> 1;
        thi = mhi >> 1;
        if(tlo == thi)
            break;
        mlo = tlo;
        mhi = thi;
        l--;
    }
    *mp = mhi;
    return l;
}
@

<<function sdiv>>=
int
sdiv(ulong d, ulong *mp, int *sp)
{
    int s;
    uvlong m;

    s = multiplier(d, 32 - 1, &m);
    *mp = m;
    *sp = s;
    if(m >= T31)
        return 1;
    else
        return 0;
}
@

<<function udiv>>=
int
udiv(ulong d, ulong *mp, int *sp, int *pp)
{
    int p, s;
    uvlong m;

    s = multiplier(d, 32, &m);
    p = 0;
    if(m >= T32) {
        while((d & 1) == 0) {
            d >>= 1;
            p++;
        }
        s = multiplier(d, 32 - p, &m);
    }
    *mp = m;
    *pp = p;
    if(m >= T32) {
        assert(p == 0);
        *sp = s - 1;
        return 1;
    }
    else {
        *sp = s;
        return 0;
    }
}
@

<<function sdivgen>>=
void
sdivgen(Node *l, Node *r, Node *ax, Node *dx)
{
    int a, s;
    ulong m;
    vlong c;

    c = r->vconst;
    if(c < 0)
        c = -c;
    a = sdiv(c, &m, &s);
//print("a=%d i=%ld s=%d m=%lux\n", a, (long)r->vconst, s, m);
    gins(AMOVL, nodconst(m), ax);
    gins(AIMULL, l, Z);
    gins(AMOVL, l, ax);
    if(a)
        gins(AADDL, ax, dx);
    gins(ASHRL, nodconst(31), ax);
    gins(ASARL, nodconst(s), dx);
    gins(AADDL, ax, dx);
    if(r->vconst < 0)
        gins(ANEGL, Z, dx);
}
@

<<function udivgen>>=
void
udivgen(Node *l, Node *r, Node *ax, Node *dx)
{
    int a, s, t;
    ulong m;
    Node nod;

    a = udiv(r->vconst, &m, &s, &t);
//print("a=%ud i=%ld p=%d s=%d m=%lux\n", a, (long)r->vconst, t, s, m);
    if(t != 0) {
        gins(AMOVL, l, ax);
        gins(ASHRL, nodconst(t), ax);
        gins(AMOVL, nodconst(m), dx);
        gins(AMULL, dx, Z);
    }
    else if(a) {
        if(l->op != OREGISTER) {
            regalloc(&nod, l, Z);
            gins(AMOVL, l, &nod);
            l = &nod;
        }
        gins(AMOVL, nodconst(m), ax);
        gins(AMULL, l, Z);
        gins(AADDL, l, dx);
        gins(ARCRL, nodconst(1), dx);
        if(l == &nod)
            regfree(l);
    }
    else {
        gins(AMOVL, nodconst(m), ax);
        gins(AMULL, l, Z);
    }
    if(s != 0)
        gins(ASHRL, nodconst(s), dx);
}
@

<<function sext>>=
void
sext(Node *d, Node *s, Node *l)
{
    if(s->reg == D_AX && !nodreg(d, Z, D_DX)) {
        reg[D_DX]++;
        gins(ACDQ, Z, Z);
    }
    else {
        regalloc(d, l, Z);
        gins(AMOVL, s, d);
        gins(ASARL, nodconst(31), d);
    }
}
@

<<function sdiv2>>=
void
sdiv2(long c, int v, Node *l, Node *n)
{
    Node nod;

    if(v > 0) {
        if(v > 1) {
            sext(&nod, n, l);
            gins(AANDL, nodconst((1 << v) - 1), &nod);
            gins(AADDL, &nod, n);
            regfree(&nod);
        }
        else {
            gins(ACMPL, n, nodconst(0x80000000));
            gins(ASBBL, nodconst(-1), n);
        }
        gins(ASARL, nodconst(v), n);
    }
    if(c < 0)
        gins(ANEGL, Z, n);
}
@

<<function smod2>>=
void
smod2(long c, int v, Node *l, Node *n)
{
    Node nod;

    if(c == 1) {
        zeroregm(n);
        return;
    }

    sext(&nod, n, l);
    if(v == 0) {
        zeroregm(n);
        gins(AXORL, &nod, n);
        gins(ASUBL, &nod, n);
    }
    else if(v > 1) {
        gins(AANDL, nodconst((1 << v) - 1), &nod);
        gins(AADDL, &nod, n);
        gins(AANDL, nodconst((1 << v) - 1), n);
        gins(ASUBL, &nod, n);
    }
    else {
        gins(AANDL, nodconst(1), n);
        gins(AXORL, &nod, n);
        gins(ASUBL, &nod, n);
    }
    regfree(&nod);
}
@


%-------------------------------------------------------------

<<8c/div.c>>=
#include "gc.h"

<<function TN>>
<<constant T31>>
<<constant T32>>

<<function multiplier>>

<<function sdiv>>

<<function udiv>>

<<function sdivgen>>

<<function udivgen>>

<<function sext>>

<<function sdiv2>>

<<function smod2>>
@


\subsection*{[[8c/cgen.c]]}

%-------------------------------------------------------------

<<8c/cgen.c>>=
#include "gc.h"

void	bcgen(Node*, int);

<<function cgen>>

<<function reglcgen>>

<<function lcgen>>

<<function bcgen>>

<<function boolgen>>

<<function sugen>>
@
