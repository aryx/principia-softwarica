\documentclass[twocolumn, landscape]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse % see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history:
%------------------------------------------------------------------------------

%thx to LP, I changed for the better a few things:
% - removed deadcode 
%    * TFILE, OFAS/OTST/OENUM, CSELEM/CLABEL
%    * Type.lineno
%    * typeh[], typec[], typeil[], 
% - renamed more consistently things 
%   (thisfn -> thisfntype, lastdcl -> lastdcltype)
% - TODO? D_CONST -> D_ADDR

%thx to codemap/codegraph/scheck:
% - use cg to reduce backward deps, introduce globals.c, utils.c,
%   saw cc/pgen.c depends on gc.h! so not same category than cc/bits.c => cc2/
%   (harder to understand non layered code)
% - TODO use cg to reduce number of globals by moving them closer to the
%   relevant file (or even function), better cluster the code
%   (harder to understand non functional code using lots of globals)
% - use scheck to remove deadcode useless export, or mv as forward decl
%   (harder to understand big interface files)
% - saw duplication between cc.h and aa.h

%thx to this manual, better understand compilers and C:
% - TODO assignment of structures? deep copy?
% - initialisation of complex globals, e.g. znode, all fields set to 0?
%   it's a kernel loader issue, BSS is zeroe'd
% - TODO x++ and ++x in complex situations
% - TODO what happen if pass array in func? int foo(int arr[4]), pass
%   actually a pointer? see Network.nw
% - the LL UL suffix to numbers? especially unsigned?
% - SEMI the meaning of volatile, how things are not optimized to stay
%   in a register
% - what happen when do *x = y  where x: char* and y:int ? cast?
%   sign? overflow?
% - how multiple declarations get merged. If do extern int x; int x = 1;
%   what happens? If do reverse?
% - SEMI how constant strings are managed? symbol defined for them? shared?
%   can you modify them? lvalue?
% - pointer arithmetic, eend - estart ok, estart + eend no, and
%   use DIV to get number of elements between.

%thx to ocaml:
% - clarify all the things that are done at parsing time, and see that
%   many could be done later to better separate concerns
% - that parsing, naming, type checking is done by 5c in a single pass!
%   5c calls the code generation after each function.
% - understand lots of corner cases, and see that lots of checks 
%   are not done by 5c (I wrote many test cases)
% - understand need to prefix array access with '&'
% - understand need for complexity, and weird scheme for addable
% - understand so much stuff related to Assembly generation

%history LP-ization:
% - skeleton, mostly copy paste of Template.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * TODO ctor/dtor, dumper
%    * [[xxx]] other fields, [[xxx]] extra fields
% - read Extra section, identify concepts, first TOC
% - distribute parts of the Extra section in the main file
% - understand main(), LP split main, improve TOC
% - understand main functions, LP split, cluster, improve TOC
% - LP split the structures, use datalog to see what flows into fields
% - nullify, boolify, enumify,  typeify,    scheckify, plan9ify
% - aspecify advanced features! remove useless features
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% ifallcode is used for:
%  - forward decl, func decl, extern decl, #ifdef, pragmas (stuff in Extra.nw)
%  - ???

\addtolength{\topmargin}{-.850in}
\addtolength{\textheight}{1.70in}

\begin{document}
%******************************************************************************
% Title
%******************************************************************************
\title{
{\Huge 
Principia Softwarica: The Plan~9 C Compiler [[5c]]
}\\
ARM (32 bits) edition\\
{version 0.1}
}
%alt: 8c x86 (32 bits) edition, see Compiler_x86.nw

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}\\
\\
with code from\\
Ken Thompson
}

\maketitle 
\onecolumn
\hrule
\input{../docs/latex/Copyright}
\input{../docs/latex/CopyrightPlan9}
\hrule
\twocolumn


\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\endgroup

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

The goal of this book is to explain with full details the source code of
a C {compiler}.

\section{Motivations}

Why a C compiler?
Because I think you are a better programmer if
you fully understand how things work under the hood, and
understanding how a compiler translates high-level C code in low-level
assembly, and ultimately machine code, is essential.

\l all our books contain C code :) machine does not understand C :)

\t in the end Google, Microsoft, Apple, Facebook spend quite 
\t  some time making compilers 

% other languages? yes could be nice, but really you need to
% show asm and C first. That's the basis. 
% why C?
% http://damienkatz.net/2013/01/the_unreasonable_effectiveness_of_c.html ?
% even ocaml needs C :) for ocamlrun and its runtime library


Here are a few questions I hope this book will answer:
\begin{itemize}

\item How does a compiler parse a complex programming language?
\n Lexing, (preprocessing), parsing

\item How does a compiler manage the scope of variables,
structures, enumerations, or typedefs?
\l forward declaration, implicit declaration, nested scopes and shadowing, 
\n symbol table

\item How does a typechecker work?

\item How does a compiler translate 
conditionals, loops, and other control-flow constructs
in basic assembly jumps?
%codegen: labelize

\item How does a compiler translate a switch?

\item How does a compiler convert arbitrary complex expressions 
into simpler assembly instructions using a small set of registers?
%codegen: linearize

\item How does a function pass arguments to another function?
Are registers used? Is the stack used? How does a function communicate 
its return value to the caller?
%codegen: frameize

% what are common useful optimizations

% aligns, offsets, structs, size

\end{itemize}

\t put in conclusion non-trivial adv algo and data structures seen? see comment
%data-structures (beyond list/hashtbl):
% - bitsets see the Bxxx (ab) used for many things (parsing, typechecking)
% - pattern matching via bitsets (see tadd and taddinit)
% - list of lists with special mark (DMARK) and undo list.


%tags used for recurring themes:
 %ocaml: to give a hint on how rewriting C in OCaml could improve things
 %assembler: similar code in the assembler and how they relate
 %linker: similar code in the linker and how they relate
 %codegen: to give a preview of how a C construct is translated to ASM
 %corner: corner cases of C that even C expert may not know about

\section{The ARM \plan C compiler: [[5c]]}

% gonna present 5c (aka kencc), from Ken Thompson! simple (well not so simple).
% a nice bonus also is that it has some very nice lint checks
% e.g. dataflow 'variable set but not used'.

% some cons though to use 5c: no CFG, no IL ... very imperative ... harder case
% to defend than for the other software (5a, 5l, kernel, rio)
% but has good linting at least :) used/set warnings :)

% has integrated assembler in some sense. But actually
% LLVM does that too, see http://blog.llvm.org/2010/04/intro-to-llvm-mc-project.html

\section{Other compilers}

Here are a few compilers that I considered for this book, but
which I ultimately discarded:

\begin{itemize}

\item gcc
%big. Lots of input languages. Lots of output targets.

\item clang
%cleaner but still very big
% nice to have single binary that can cross compile for multiple targets, nice
% interface (cleaner than 5c/vc/...; interfaces are better!)
%good error messages.
% "A tourist guide to LLVM":
%http://blog.regehr.org/archives/1453

\item lcc 
%maybe better actually, but already a book on it, 
% 20 000 LOC according to wikipedia
% but seems to not use yacc (or lex), and copyright seems restrictive

\item compcert
% harder to understand coq :), but definitly better IL and CFG I think.

\item bcc
% bruce evans, code used by linus at the beginning?

\item fbcc and tcc
% cool maybe

\end{itemize}

%\item cminusminus
% maybe a good idea to also present c--
% just for backend.

%\item rust
% Maybe rust could replace C one day, but we are not there yet
% and Rust is more complicated than C. Actually rust uses C :)
% use SSA and MIR now (middleend intermediate IR)

%\item Tiger
% not real, not C, but more educatif and better written for teaching purpose
% (actually can maybe refer to govereau book?)

%other C 
% - http://www.compilers.de/vbcc.html also vasm and vlink
%   76 000 LOC, multi archi
% - http://sdcc.sourceforge.net/ for microcontrollers
%   also includes assembler, debugger, simulator, ...
% - http://nwcc.sourceforge.net/
% - PCC
% - small interpreter: https://github.com/zsaleeba/picoc
% - https://github.com/rui314/8cc
%   http://www.sigbus.info/how-i-wrote-a-self-hosting-c-compiler-in-40-days.html
%   but no yacc
% - https://github.com/andrewchambers/cc, seeking collaborators, inspired
%   by tcc and 8cc apparently, written in Go
% - Small-C compiler book
%   http://www.drdobbs.com/developer-network-small-c-compiler-book/184415519
%mini:
% - C in 4 functions: https://github.com/rswier/c4/blob/master/c4.c
% - mini C compiler generating code for ARM (use C4)
%   https://github.com/jserv/amacc
%other teaching pl:
% - pl/0, Wirth
% - Cool, Aiken?
% - Tiger, Appel
%modern:
% - .NET? mono? roslyn?
%    great guide to soft archi:
% http://mattwarren.org/2017/03/23/Hitchhikers-Guide-to-the-CoreCLR-Source-Code/

% TODO bench 5c vs gcc and clang and compcert on benchmarks (compcert's one)

%https://github.com/melling/ComputerLanguages/blob/master/compilers.org
% (small for now)

% SSA based compiler design
%http://ssabook.gforge.inria.fr/latest/book.pdf

% On frontend used in compiler vs frontend used in IDE (very good)
%https://channel9.msdn.com/Blogs/Seth-Juarez/Anders-Hejlsberg-on-Modern-Compiler-Construction

%with flex/bison/llvm
%http://gnuu.org/2009/09/18/writing-your-own-toy-compiler/all/1/

% more recently:
% - JIT

% some hand-made diagrams and illustation of front/back with llvm intermediates
% https://nicoleorchard.com/blog/compilers

\section{Getting started}

% need to use 5l? not like gcc where can create executable directly
% because it calls ld under the hood. But here Unix spirit! one thing only!

\section{Requirements}

% actually the code presented below is written in C so you
% need to understand C :) hmmm

% You need to have a vague idea of how works a compiler. 
% Have read Dragon book. Appel. Or other books.
% Many compiler books. Dragon, Engineering a compiler, modern compiler, ...
% so know what is an 
% Abstract syntax tree (AST), 
% lexer, 
% parser, 
% type system, 
% ...

%``the compiler assumes you've know your Aho and Ullman either by'
%reading them or by working with them.''
% - charles forsith on 9fans

% comp.ps, [8]5c man pages, etc

% Also assumes Assembler.nw or Machine.nw for ARM. Helps to understand
% the target (especially since there is no RTL so the code
% generation part directly generates concrete ASM code)

%Let's build a compiler:
%http://compilers.iecc.com/crenshaw/

% Incremental compiler in 22 steps in scheme
% http://scheme2006.cs.uchicago.edu/11-ghuloum.pdf

\section{About this document}
#include "../docs/latex/About.nw"

\section{Copyright}
\input{../docs/latex/CopyrightPlan9Text}

\section{Acknowledgments}

I would like to acknowledge of course the author of
[[5c]], Ken Thompson, 
who wrote in some sense most of this book.

% Mireille Ducasse, Marie Jo Pedrono
% Aho, Appel







\chapter{Overview}

\section{Compiler principles}

% from high level to low level (asm). 

% Many books on compiler. I will be short here.

% FIGURE with different steps.
% and group some boxes in frontend vs backend

% principles of frontend and backend.
% (We will focus mostly on the backend)

\subsection{Frontend}

% Frontend is classic and present in other books like Assembler, 
% or Make, or Shell.
% Lexing (regexps), (preprocessing), parsing (grammar), AST.
% (even though 5c does a lot in parsing; does not separate concern so well).
% Tracking position for good error reports.

\subsection{Scope resolution}
% Resolving, naming.

% C has nested blocks, and can shadow variables.
% Can also forward decls.
% C has also type aliases (typedefs). Lots of names.
% Have even ambiguity between typedef and var.
% When see an identifier, hard to know to what it refers too
% (a typedef? defined in which scope? a variable? in which scope? an enum?
% in which scope?)
% Goal of naming is to associate to the use of an entity the right
% definition.

\subsection{Use/def checking}

% For many things! related to naming.
% 3 important checks: use-of-undefined, redefined, unused. 

% for many entities: 
%  - labels
%  - locals
% could also for: 
%  - globals
%  - function defs
%  - typedefs
%  - struct defs
%  - enums.

\subsection{Type checking}

% A more unusual part of frontend is typechecking! and annotate AST
% with types. C not a dynamic language.

% - types! typechecking! (5c even adds some simple dataflow checks!)
%   so can type check arguments vs parameters, their numbers, array access,
%   field access, more restricted register indexing (xxx) -> *xxx but only 
%   if makes sense.
%   (still have lots of room to improve even more, C could be more typed!
%    see rust, and ocaml).

% type annotating also.

% lvalue/rvalue annotating here?

\subsection{Backend}

% Assembly is essentially:
%  - simple arith with registers and memory instructions 
%  - labels and jmps
%  - simple stack (when you have to manually handle locals, params, and calls)
%  - simple data structure, bytes
% The goal of the C compiler is to translate in this simpler language
% the more complex construct of C.

%interactively see the asm generated by gcc
%https://godbolt.org/

%https://kristerw.blogspot.com/2017/08/the-structure-of-gcc-back-end.html

\subsection{Labelization}

% - statements, more structured forms than jmp.

\subsection{Linearization}
% registerization

% - expression like x+y*z decomposed into multi mov, add, etc. Fortran!
% - same for data, complex decomposed into smaller bytes, with symbolic names
%   for subparts, e.g. fields.

\subsection{Frameization}

% - parameters, arguments, locals, more structured forms than just plain stack
% => see codegen: tag

\subsection{Optimizations}


\section{[[5c]] command-line interface}

% see all the flags, put here main flags

% source language: C
% implementation language: C
% target language: assembly ARM

% not put here originally: 
% -g (in genxxx()) print lhs and rhs in many contexts
%  and also print instruction generated by gins and gopcode
% -G (in gen()) 
% -Z, -f ??
% -N -R -P in regopt()
%   -N disable regopt
%   -R enable it back, print debugging info, disable peep()
%   -P reenable peep() and print debugging info
% -T in zname to generate ASIGNAME (can be disabled by some pragma apparently)
%   so can have safe linking
% -x,   pad: dump AST
% -c, if(constant) warning


%OUTOUT
% *	-o file		output file
% *	-S		print assembly
% *	-l		generate little-endian code (mips only)


%WARNINGS
% *	-w		print warnings
% *	-V		enable void* conversion warnings
% *	-X		abort on error
% *	-F		format specification check

%LANGUAGE
% *	-A		!B
% *	-B		non ANSI

%PREPROCESSOR
% *	-p		use standard cpp ANSI preprocessor (not on windows)
% *	-D name		define
% *	-I path		include
% *	-.		Inhibit search for includes in source directory

%DEBUGGER
% *	-a		acid declaration output
% *	-n		print acid to file (%.c=%.acid) (with -a or -aa)
% *	-Z		pickle output (pad: was not mentioned originally)
% *	-s		print structure offsets (with -a or -aa)

%DEBUGGING
% *	-v		verbose printing
% *	-d		print declarations
% *	-L		print every NAME symbol
% *	-m		print add/sub/mul trees
%            pad: also macro debugging??
% *	-f		line information debugging (pad: was not mentioned originally)
% *	-r		print registerization
% *	-t		print type trees
%    pad: debug the many phases in bcomplex()
% *	-i		print initialization
% * -g -G      print stuff for code gen (pad: was not mentioned originally)

% *	-M		constant multiplication

%in mkfile.proto:
%8c -FTVw -I/home/pad/plan9/include/386 -I/home/pad/plan9/include globals.c
% -F format check, -T safe linking, -V enable void* warnings, -w print warnings

\section{[[helloworld.c]]}

% show ARM assembly output for a simple program.

% (at least put an arithmetic expression? "hello world, 42 is the answer!")

\section{Input C language}

% mostly ANSI C. a few extensions.
% see K&R book.

% show tricky stuff? like scope and blockid?
% struct x; forward decl? (actually 5c does not honor this I think).
% Still can declare things before things are defined. ex:
% struct Foo x; .... struct Foo { ... };

% TODO add __LINE__? 
% TODO add check for code not using return value (e.g.
%  in xdecl rule where call dodecl() which returns a node).

% "who says C is simple"
%http://www.eecs.berkeley.edu/~necula/cil/cil016.html
% ugly C syntax
%http://blog.robertelder.org/weird-c-syntax/

%http://icube-icps.unistra.fr/img_auth.php/d/db/ModernC.pdf


% lvalue, rvalue (lvalue = location value? expression resulting into a location
% where something can be stored?)
% Stratchey introduced those terms?

% system programming language. Pointer, number to pointer,
% memory allocator in itself.
% Still, need some ASM for essential stuff like system calls :) (SWI).

\subsection{C innovations}

% innovation of C vs fortran/pascal/algol? 
%  - pointer arithmetic? (but also a bad thing to have such wild pointers)
%    in some sense compilers such as Tiger are using pointers, but internally,
%    and C exposed them to the language while also providing some form
%    of algrebra around them (pointer arithmetic)
%  - simpler?
%  - bitfields? so can match more directly hardware specifics?
%  - in the end pretty good DSL for bit manipulations, &, |, ^, &=, <<, etc
%    are quite nice. See Linker.nw, Machine.nw, Assembler.nw.
%  - overloaded arithmetic for int/float/... ? (compared to OCaml)


% Also lots of dark corners:
% https://people.eecs.berkeley.edu/~necula/cil/
% http://blog.robertelder.org/weird-c-syntax/

\section{Output object format}

% assembly ARM object code. Very close to ARM machine code.
% (can get asm generated via 5c -S)

% put code for helloworld.c generated code?

\section{The ARM architecture}

% does not really need to understand much.
% Assembler of 5a abstracts a few things which is
% convenient (FP/SP, SB, generic MOVW, full integer constant, etc)

% Maybe a few instructions so can see how some simple C can be
% translated directly into ARM.
% x=1;
% MOVW $1, R0
% MOVW R0, x(SB)
% or
% MOVW R0, x+4(FP) or x-4(SP)

% y = &x
% MOVW $x(SB), R0
% MOVW R0, y(SB)



\section{Code organization}

% use a lot include/arm/5.out.h
% and actually stuff defined in 5.out.h are used
% exclusively by 5c e.g. REGRET, REGTMP, and also ACASE, etc

% ------------

% cc.h (vs gc.h (not garbage collector, g for? nongeneric? generation? hmmm))
% no lex (handcrafted lex.c), yacc (cc.y, y.tab.h, y.tab.c)
%  (why no lex? to avoid bootstrapping issues? they don't like lex?
%   because of unicode which lex does not handle well anyway?)
%  mac.c = macro (embedded cpp)
% globals.c, utils.c, compat.c

% sub.c = subroutines, helpers to build ast (and more?)

% bits.c
% pickle.c

% acid.c = debugger support

% dpchk.c: pragma related. check also fmt string. "Directive Pragma Check"?
%  the argchk fmt printfstyle checks.

% com.c = compile (not comment), com64 for 64 bits stuff (for vlong)
%  dcl.c = declarations (dodecl, xdecl, adecl, markdcl/revertdcl, etc)
%  funct.c = ?? seems related to typestr
%  swt.c = switch? (pswt = portable part of switch handling)
%   (but then why outcode, outhist is in this file? TODO move it elsewhere!)
%  scon.c =  ? constants expr? s?

% -----------

% gc.h (g? [code] generation?)
% globals2.c (but actually many of them seems generic and could be in globals.c)
% list.c (= fmt.c) (TODO rename)
% machcap.c, omachcap.c = machine capability (attempt to have interface)
%  but for ARM it's empty.

% txt.c?
% xxxgen = sgen? cgen? (pgen.c = portable part of gen? sgen? cgen?)
% mul.c, div.c = optimized code for div/mul
% peep.c = peep optimizer, on assembly!
% reg.c = register, on assembly! but the Reg structure itself
%  seems actually generic.


\section{Software architecture}

% actually all in one program. 5c includes also cpp and assembler. Probably
%  to avoid fork to have a really fast compiler (because Pike
%  hated cpp and long compilation time, which led in the end
%  to some strong design choices for Go)
% in fact 'time 8c' vs 'time pcc' is really big on my machine.
% and true that when compare with pcc on troff/eqn/... pcc is so slow

% see lex.c#main()! have command line flags in comment

% lexer -> preprocessor -> parser -> AST -> visit and gen assembly -> opti
%  -> object ARM code.
% with optimisations done?

% no CFG :( no IL. Register allocator optimizer is done via peep?
% vs tiger book?

% main -> compile -> yyparse -> yylex -> macxxx
%                            -> codgen (portable) -> gen(stmt) -> cgen(expr)
%                                                 -> regopt -> peep
%                 -> gclean -> outcode
% toplevel globals are managed by gclean (which also adds last AEND)

% Really do things gradually, like a stream. Generate code after
% each function. Kinda a one-pass compiler.

% Key data structure is symbol table! Used to hold declarations.
% Hold the declarations in the current scope! Manage scope.
% label use/def, struct use/def, var use/def, types, offsets, 
% everything (too much in my opinion).

% AST level opti, assembly level opti

% "the compiler works by a series of tree
% transformations, informed by attributes
% attached to each node, representing
% types, notional costs, addressability,
% and other ... stuff.
% - charles forsith on 9fans

% name conventions:
% - s symbol? (todo change to sym?)
% - o Oxxx of node_kind
% - a Axxx of opcode_kind of assembly

% see also glossary, su = struct/union, sue = struct/union/enum

%\section{Bootstrapping}
% diagram en T? reference recent Go bootstrapping effort?
%http://www.cs.dartmouth.edu/~mckeeman/cs48/mxcom/gem/html/GrowingCompiler.html

\section{Book structure}





%###############################################################################


\chapter{Core Data Structures}

\section{Abstract syntax tree, [[Node]]}

% We need to represent programs in memory. A propram is essentially
% a tree of expr|stmt|... with different kinds of nodes.

%FIGURE: AST concept, tree of expression 1+2*3, with OCONST, OADD, OMUL.
% simple.

<<enum node_kind>>=
enum Node_kind
{
    OXXX,

    // ----------------------------------------------------------------------
    // Names
    // ----------------------------------------------------------------------
    ONAME, // for uses and declarations

    // ----------------------------------------------------------------------
    // Expressions
    // ----------------------------------------------------------------------
    <<expression nodes>>

    // ----------------------------------------------------------------------
    // Statements
    // ----------------------------------------------------------------------
    <<statement nodes>>

    // ----------------------------------------------------------------------
    // Declarations (parameters, initializers, bit fields)
    // ----------------------------------------------------------------------
    <<declaration nodes>>

    // ----------------------------------------------------------------------
    // Misc
    // ----------------------------------------------------------------------
    <<misc nodes>>

    // ----------------------------------------------------------------------
    // Post parsing nodes
    // ----------------------------------------------------------------------
    <<after parsing nodes>>

    OEND
};
@
%old: I reorged a lot. This type is purely internal to cc, it is not
% marshalled, so it is easy to reorder (as opposed to 5.out.h opcode type
% which is a bit more difficult)
%dead: OTST,		/* used in some compilers */
%dead: OFAS
%ocaml: use ADT, and represents also type and storage in AST (resolve later).
% I also do not abuse expressions to represent types (OIND != TIND).

% each time OXXX TXXX for start and end. Sentinel.
% But OXXX to mark as wrong value? 
% (used for labels, but just as a dumb value because what is 
%  interesting is the sym connected to the node)
%ocaml: just use precise AST. no need OXXX and OEND.

% = expr + stmt essentially.
% The type definitions and type uses are in another DS (Type).
% (and annotates some nodes)
% The storage is in another DS (Storage_class).
% (and annotates some nodes)
% The declaration is stored in another DS (the symbol table).
% The parser abuses AST constructs of expressions to represent type
% declarations. The 'declaration nodes' category above is really temporary.

<<struct Node>>=
struct	Node
{
    // enum<node_kind>
    char	op;

    // option<ref_own<Node>>
    Node*	left;
    // option<ref_own<Node>>
    Node*	right;

    // after preprocessing, global lineno
    long	lineno; 

    <<[[Node]] value fields>>

    // ----------------------------------------------------------------------
    // Post parsing annotations
    // ----------------------------------------------------------------------
    <<[[Node]] type and storage fields>>
    <<[[Node]] code generation fields>>
    <<[[Node]] origin tracking fields>>

    // ----------------------------------------------------------------------
    // Misc
    // ----------------------------------------------------------------------
    <<[[Node]] parsing helper fields>>
};
@
%less: char -> ushort? or actually char sometimes when use '+' ?
% hmm get some warnings though when do that, but maybe should fix those 
% warnings anyway
%ocaml: use ADT, and mv semantic fields to another phase.
% Precise AST has some disadvantage though: I have to duplicate lineno, and 
% have complex dumper and visitor compare to this generic binary tree
% (but at least I can autogenerate this dumper and visitor)

%see also prtree() in debugging section to dump the AST, useful
% to understand which fields make sense for which node_kind!
% all the nodes with value fields have a case in prtree().

%FIGURE AST with stmt
%FIGURE AST with func, globals.


% put value fields here?
% How things are represented for
% - OCONST: additional vconst and fconst field
% - OSTRING, OLSTRING: cstring and rstring fields
% - ONAME: additional sym field
%   (and class, xoffset when param or local name)
% - OREGISTER, OINDREG: reg and xoffset
% - ODOT/OELEM: sym field
% - blocks? left/right used for many things, for left/right branch in e.g.
%   arithmetic trees (a+b), but also for linked list (e.g. OLIST) with
%   double chaining
% - a local declaration? not in AST, in symbol table
% Most of those nodes will also get a type later.
%ocaml: ADT more precise again.

<<constant Z>>=
#define	Z	((Node*)nil)
@
%ocaml: never nil, and never have to check for nil! big win.

% put OLIST here, because it has many usages
<<misc nodes>>=
OLIST, // of stmts/labels/parameters/...  and also for pairs/triples/...
@
%ocaml: use 'a list (expr list, stmt list, etc)

% add an OPAIR alias?



% for nodes involving a symbol (global/func/variable, field, label)
<<[[Node]] value fields>>=
Sym*	sym; // for ONAME, ODOT/OELEM, OXXX of OLABEL/OGOTO
@
%ocaml: do (minimal) naming. Just handle blockid.
% rely later on external hashtbl to give more information about symbol
% so better separate concerns. 5c does too many things at the same time.

% see Sym in next section. 
% Used only temporariliy for declaration ONAME nodes (which are temporary
% nodes because they are not in the final AST). After dodecl(), Node.sym
% is useless I think.


%less: int -> char ... for op, hmmm
<<function new>>=
Node*
new(int t, Node *l, Node *r)
{
    Node *n;

    n = alloc(sizeof(Node));
    n->op = t;
    n->left = l;
    n->right = r;

    <<[[new()]] set lineno>>

    return n;
}
@
%ocaml: build directly precise (but need mk_e, mk_st, mk_t)

<<[[new()]] set lineno>>=
if(l && t != OGOTO)
    n->lineno = l->lineno;
else if(r)
    n->lineno = r->lineno;
else
    n->lineno = lineno;
@
%ocaml: difficult do that in ocaml cos not generic left/right trees, so
% easier add location info in lexer in each token. Will even get more precise
% line location then!

%why this special thing about OGOTO? because goto take a OXXX fake node
% and don't want the line of that fake node


<<global lineno>>=
long	lineno;
@
% incremented in lexer, global line number?
%assembler: same, global line number, because embedded cpp too and also #line


<<global nearln>>=
long	nearln;
@
%ocaml: no need for nearln, use more precise error location directly.

% set in codgen() to the lineno field of the function node.
% this is useful for error reporting when use warn on an empty node,
% to at least give an error location not too far away.
% we can't use lineno in those cases because the parsing has been done,
% so lineno is set to the maximum line of the expanded file, hence nearln.
%
% nearln is also very useful for nextpc()! so that the generated
% assembly instructions are tied to related C code they are generated
% from! goodsupport for the debugger!

<<function new1>>=
Node*
new1(int o, Node *l, Node *r)
{
    Node *n;

    n = new(o, l, r);
    n->lineno = nearln;
    return n;
}
@

% when needs this one? when create new intermediate node, e.g.
% in tcomo() during typechecking to make more explicit certain
% cast for instance, and when we are not sure there is something
% to base line upon (maybe l and r are empty).
% Post parsing nodes.


<<global znode>>=
Node	znode;
@
% This get its fields set to zero by default? Semantic of C?
%ocaml: build directly







\section{Type system, [[Type]]}

<<enum type_kind>>=
enum Type_kind
{
    TXXX,

    <<[[Type_kind]] integer cases>>
    <<[[Type_kind]] float cases>>
    <<[[Type_kind]] void case>>
    <<[[Type_kind]] composite cases>>
    <<[[Type_kind]] other cases>>

    NTYPE,
};
@
%ocaml: I have an ADT for the type system and another one for the AST
% of a type because I prefer to do typedef expansion, struct resolution,
% constant expression evaluation, and more after parsing.

<<[[Type_kind]] integer cases>>=
TCHAR,
TUCHAR,

TSHORT,
TUSHORT,

TINT,
TUINT,

TLONG,
TULONG,

TVLONG,
TUVLONG,
@
%coupling: with the global 'tab' which use initialisers that
% assumes a certain order
%coupling: with arith(), need to have char and short before int
% and do +2 to get corresponding upper type.
%ocaml: I factorized the Signed vs Unsigned, and I put all of that
% under a Type.I so no need BINTEGER trick during typechecking.

% C syntax for types is ugly, and allows many different schemes
% such as signed int; int; int signed; ... but in the end
% just have those 10 basic types! (and the floats below)


<<[[Type_kind]] float cases>>=
TFLOAT,
TDOUBLE,
@
% no double long as in gcc?

<<[[Type_kind]] void case>>=
TVOID,
@

<<[[Type_kind]] composite cases>>=
TIND,
TARRAY,

TFUNC,

TSTRUCT,
TUNION,

TENUM,
@

%IND for indirect probably, meaning pointer. C power!
%Note that even if array access are unsugar in pointer arithmetic access, 
% type declarations are not; we keep the array vs pointer info here.
%Note that no TYPEDEF here! expanded at parsing time!
%note that originally if you changed the order above then you 
% would get some segfaults in tests/5c and mk testall. This was
% because the code was using simple initialisers instead of array
% initialisers e.g. for the global 'tab'. I fixed it so it should
% be ok to reorder now.

% TARRAY and TENUM eventually disappear. They are used only temporariliy.

% There is no really AST for types. They are directly "resolved".
% Which is why I didn't put Type under the AST section.

<<struct Type>>=
struct	Type
{
    // enum<type_kind>
    char	etype;

    // option<ref_own<Type>, e.g. for '*int' have TIND -link-> TINT
    Type*	link;
    // option<list<ref_own<Type>>, next = Type.down, for TFUNC and TSTRUCT
    Type*	down;

    <<[[Type]] qualifier fields>>

    // ----------------------------------------------------------------------
    // Post parsing annotations
    // ----------------------------------------------------------------------
    <<[[Type]] code generation fields>>

    <<[[Type]] other fields>>
};
@
%less: char -> ushort? but get some warnings (but we should fix that too)
%dead: long lineno;
%ocaml: ADT better again here, but can not handle the incomplete
% structure via empty pointer and later mutually recursive structures directly
% via pointer. I have to use an extra tagdef environment.

% Here are how things are represented for the different composed types:
%  - TVOID, simple, should actually be in the simple case
%  - TIND: simple, via Type.link
%  - TARRAY: same? but for the size of it? not in type info?
%  - TSTRUCT/TUNION? subtle. Type.link is empty at first for variables where
%    the structure has not yet been defined. Once the structure
%    is defined (or if it was defined before), the symbol for
%    this structure will link via suetag to a TSTRUCT type
%    where the link will be set to point to the first
%    field of the struct. The other fields are then linked via Type.down?
%    Also each field is a type with its Type.sym set to a link to the
%    field name.
%  - TFUNC: the return is in the Type.link, the parameters in the Type.down
%  - TYPEDEF? they are not in enum type_kind! they are substitued
%    at use time? where?
%  - TENUM points to final type via Type.link


% when type involves a symbol, e.g. for tags in struct/union/enum
<<[[Type]] other fields>>=
Sym*	tag;
@
% How do you get the definition? At some point the Type.link
% will point to the list of fields in the struct/union.
% During parsing 5c returns an incomplete newly allocated
% Type whose ->link will be filled later.
% (The symbol table does not know about struct definition. The symbol
% table is used only for resolve the scope of structs)
% So again this thing is used really just to get the name.
\l need to use snap() if resolved later and did not share same ref
\l to same type returned by Sym.suetag.
\t but why not same ref? because of some calls to copytyp! but when?

% Each of the field of a struct will be a Type. The name of the field itself
%  is stored in another field of Type:
<<[[Type]] other fields>>=
Sym*	sym; // for fields in structures
@
%ocaml: put 'string' directly in AST, no need abuse symbol table

% have a Type.tag a Type.sym! Type.sym is for the fields 
%  (could merge, but that would be ugly)


% FIGURE where see links with simple toy program
% struct Foo { int x; int y; }; struct Foo global1;

% Note that if mutually recursive struct, then in memory you will
% have a graph of pointers! 
%ocaml: always assume have tagdef in environment, so no pointers
% in type, just keep StructName (scoped with blockid) and look in environment
% to get the fields.





% Ok now let's see the link between Node and Type
% (for expression nodes only).
% Important field! typechecking! Set in parsing when can
% (e.g. for cast where have type, for return where have also spec,
%  when have an entity use where type should be in symbol table)
% See in typechecking for every nodes later.
<<[[Node]] type and storage fields>>=
Type*	type;
@
%ocaml: could have a separate AST, or have generic AST and 'a xxx,
% but need that just for expr, so I prefer simply add a field e_type.

% Node.type is also a value field for OCAST.

% so it's more than an AST actually, there is semantic info attached to it
% by other phases.


% seems mostly inline of type->etype, except in fvn() and ccom()
<<[[Node]] type and storage fields>>=
// enum<type_kind>, inline of Node.type->etype?
char	etype;
@
%less: could remove? redundant no? annoying to maintain?
% annoying those n->etype = (s->type?): s->type->etype: TVOID;
% but without it, lots of code would need to check wether n->type != T?
% so maybe better to have Node.etype too?
%ocaml: remove, etype used to quickly write code checking highlevel
% category of a type, but with ADT of ocaml I can match conveniently
% complex type too.




<<constant T>>=
#define	T	((Type*)nil)
@
%ocaml: again, no need, and no need for nil checking everywhere; big win.

% constructor
% optional<ref_type> for d
<<function typ>>=
Type*
typ(int et, Type *d)
{
    Type *t;

    t = alloc(sizeof(Type));
    t->etype = et;
    t->link = d;

    t->down = T;
    t->garb = GXXX;
    t->sym = S;

    t->width = ewidth[et];

    t->offset = 0;
    t->shift = 0;
    t->nbits = 0;

    return t;
}
@
% see Size section for ewidth, LP split!


%Why see that global? because often used?
<<global types>>=
Type*	types[NTYPE];
@
%ocaml: no diff between enum and full type. Use ADT so get powerful
% enum directly.

<<[[cinit()]] types initialization>>=
types[TXXX] = T;

types[TCHAR]   = typ(TCHAR, T);
types[TUCHAR]  = typ(TUCHAR, T);
types[TSHORT]  = typ(TSHORT, T);
types[TUSHORT] = typ(TUSHORT, T);
types[TINT]    = typ(TINT, T);
types[TUINT]   = typ(TUINT, T);
types[TLONG]   = typ(TLONG, T);
types[TULONG]  = typ(TULONG, T);
types[TVLONG]  = typ(TVLONG, T);
types[TUVLONG] = typ(TUVLONG, T);

types[TFLOAT]  = typ(TFLOAT, T);
types[TDOUBLE] = typ(TDOUBLE, T);

types[TVOID]   = typ(TVOID, T);

types[TENUM] = typ(TENUM, T);
types[TFUNC] = typ(TFUNC, types[TINT]);
types[TIND] = typ(TIND, types[TVOID]);
@

% see also those typesets like typev[], typeint[], typesu[] etc
% that allows to quickly check if a type is part of a certain category.
% Explained more in Typechecking section.

% typxxx important conventions:
% c = char, h = short, v = vlong, fd = float/double, 
% su = struct union, af = array/func
% il = int/long
% ilp = integer long pointer
% chl = char/short/long
% chlp = char/short/long/pointer, 
% i = all integers, u = all unsigned, 
% suv = struct/union/vlong (big data)
 


%\subsection{Type qualifier}

<<[[Type]] qualifier fields>>=
// enum<qualifier>
char	garb;
@
% note that can be at different level! can have  const * const *x;
% tricky.
%less: rename qualifier

% Gxxx for 'garbage' :) but should be renamed qualifier so Qxxx
<<enum qualifier>>=
enum Qualifier
{
    GXXX		= 0, // None

    GCONSTNT	= 1<<0,
    GVOLATILE	= 1<<1,

    NGTYPES		= 1<<2,
    <<[[Qualifier]] other cases>>

};
@
% >> >> >> >>
% see also gnames in debugging section

% storage class is not there! it's an attribute of the 
% variable, not of the type of the variable, so it's
% a node field.


%\subsection{Type attributes}
% later now


\section{[[Storage_class]]}

% for declaration nodes at first, but then also when refer an entity
% in which case its class is copied from the symbol table to the node.
<<enum storage_class>>=
enum Storage_class
{
    CXXX,

    CAUTO,
    CPARAM,

    CEXTERN,
    CGLOBL,
    CSTATIC,

    <<[[Storage_class]] cases>>

    NCTYPES,
};
@
%ocaml: CXXX represented by None. no need NCTYPES, CAUTO -> CLOCAL

% CSTATIC vs LSTATIC(lexeme) TSTATIC(temporary) vs BSTATIC(bitset of TSTATIC)
% see also cnames[] in debugging section
% strings are also using CSTATIC!
% have also CTYPEDEF here, so can have typedef trick in yylex().
\l could reorder, put CGLOBL first

% Note that some symbols get assigned a storage class first, and then
%  this storage class gets adjusted.
% For instance common to have extern int x; in a header file and
% then one of the C file does int x = 1; In that file, x is a global,
% not an extern.

% for declaration nodes. Also at use-time because 5c resolve things
%  during parsing thanks to the symbol table.
<<[[Node]] type and storage fields>>=
// enum<storage_class>
char	class;
@
%ocaml: store in external hashtbl later the pair Type x Storage for
% every names.

% Also a Sym.class

\section{Node and type attributes}

%trans:
% Saw Node.type (and Node.etype), 
% Node.class
% (Saw Node.sym).
% 5c use node attributes for many things! For everything actually.
%ocaml: I prefer use separate phases and separate external hashtbl or
% temporary environment.

%\subsection{Misc attributes}

% for expression nodes?
<<[[Node]] code generation fields>>=
// address-able, used as a bool to mark lvalues, if can assign you can take
// the address of. used by xcom() to assign ``addressibility''.
// (also (ab)used as a bool to mark label uses (true = used in a goto))
char	addable;
@
\t use another field? at least a union, otherwise ugly
\t mv later?
%ocaml: attribute in extra phase? or embed in AST? like the type?

% for expression nodes?
<<[[Node]] code generation fields>>=
// complexity in number of registers. for register allocation?
// (also (ab)used as FNX special value)
// (also (ab)used as a bool to mark label definitions (true = already defined))
char	complex; 
@

% Just like for Node, attach information in type that will be useful
% for the code generation.

% mv later?? used at many places, so maybe ok to introduce early.
<<[[Type]] code generation fields>>=
long	width; // ewidth[Type.etype]
@
% semantic phase? for codegen? 
% this is adjusted later for struct when have full struct def. At first
%  it is -1 (see ewidth[TSTRUCT])
%ocaml: separate hash to go from type to width? slower? (who care)

\t maybe Node.xoffset here? used a lot. Also Sym.offset and Type.offset
\t  (and autoffset)



\section{[[Sym]]bols and [[hash]] table}
% another symbol table!

\subsection{[[Sym]]}

<<struct Sym>>=
struct	Sym
{
    // Symbolic names are used for: 
    //  - identifiers (locals/params/globals, functions, typedefs
    //    and also enum constants)
    //  - tags (struct/union/enum) 
    //  - labels (for the goto)
    // and also during parsing for:
    //  - macros (the #define)
    //  - keywords lexeme (abuse)

    // ----------------------------------------------------------------------
    // The "key"
    // ----------------------------------------------------------------------
    char	*name;

    // ----------------------------------------------------------------------
    // The "value" for the different "namespaces"
    // ----------------------------------------------------------------------
    <<[[Sym]] identifier value fields>>
    <<[[Sym]] enum value fields>>
    <<[[Sym]] tag value fields>>
    <<[[Sym]] label value fields>>

    <<[[Sym]] macro value fields>>
    <<[[Sym]] lexeme value fields>>

    // ----------------------------------------------------------------------
    // Extra
    // ----------------------------------------------------------------------
    <<[[Sym]] extra fields>>
};
@
%coupling: if add a field here, don't forget to update Decl too
% and especially its "sym copy fields" section
%ocaml: have an environment types, with different fields for the 
% different namespaces

%namespace: it's the symbol table for different kind of names
% - identifier, see s->type, s->class, etc s->xoffset? x->block?
%   and for enum constants, see s->tenum, and s->vconst, s->fconst
% - tags, see s->suetag and s->sueblock
% - labels, see s->label
% - macro, see s->macros
%note that fields are not here as they are not in the global namespace.

% note that the value fields are not in a union! because have multiple
% namespace so depending on the context you want to get different values
% for the same symbol 's'. 

%Does Sym handles well the different namespaces? What if struct and local
% with same name? It's not a union! the Decl value will determine
% which field to look for.

%Can have struct x x;
% it can be the same symbol, but in a struct context we will use
% Sym.suetag, in other context Sym.type!
% same for Sym.sueblock vs Sym.block.


% This is a key data structure. Many things are done through the symbol table
% (too much in my opinion). All decl/use links go through this symbol table.
% - identifiers (globals, locals, parameters, enum):
%   * scope (resolve to right decl, complex cos nested blocks, shadow, fwd dcl)
%     %ocaml: parsing time; ambiguity with typedef and because we lift up enums
%   * type 
%      - and type width
%      - type after typedef resolution
%      - type merging when identifier declared multiple times
%   * storage (and storage adjustments)
%   * offset in stack
%   * addable?
%   * complex
%   * use/decl checks
%   * corresponding definition location (varlineno)
%   * first argument optimization?
% - labels:
%   * use/def checks (use of undefined, unused, redefinition)
% - typedef:
%   * ambiguity resolution with lexer
%     %ocaml: parsing time; cant escape it, otherwise ambiguity
%   * scope
%     %ocaml: parsing time, cos type definitions lifted up
%   * expansion (so store definition in symbol table)
% - enum
%   * scope
%     %ocaml: have to do that at parsing time, cos lifted up
%   * evaluation and expansion
% - struct/union:
%   * scope
%     %ocaml: have to do that at parsing time, cos lifted up
%   * forward decl
%     %ocaml: have to do that at parsing time, cos lifted up
%   * type (can get a reference to the full def through the symbol table)
% - macros
%   * expansion
% - lexeme
%   * token code

% Similar to Assembler.nw and Linker.nw Sym DS. Differences?
%  - have labels, tags




\subsection{[[hash]]}

<<global hash>>=
// hash<string, ref_own?<Sym>>, (next in bucket = Sym.link)
Sym*	hash[NHASH];
@
<<constant NHASH>>=
#define	NHASH		1024
@
<<[[Sym]] extra fields>>=
// list<ref<Sym>> (next = Sym.link) bucket of hashtbl 'hash'
Sym*	link;
@
<<constant S>>=
#define	S	((Sym*)nil)
@
%ocaml: use Hashtbl

<<[[cinit()]] hash initialization>>=
for(i=0; i<NHASH; i++)
    hash[i] = S;
@
%ocaml: no need initialization, empty hashtbl correctly initialized.


\subsection{[[slookup()]] and [[lookup()]]}

<<function slookup>>=
Sym*
slookup(char *s)
{

    strcpy(symb, s);
    return lookup();
}
@
%ocaml: use Hashtbl.find


<<global symb>>=
char	symb[NSYMB];
@
<<constant NSYMB>>=
#define	NSYMB		1500
@
%assembler: similar

<<function lookup>>=
Sym*
lookup(void)
{
    Sym *s;
    ulong h;
    char *p;
    int c, n;

    // h = hash(symb)
    h = 0;
    for(p=symb; *p;) {
        h = h * 3;
        h += *p++;
    }
    n = (p - symb) + 1;
    if((long)h < 0)
        h = ~h;
    h %= NHASH;

    c = symb[0];
    for(s = hash[h]; s != S; s = s->link) {
        if(s->name[0] != c)
            continue;
        if(strcmp(s->name, symb) == 0)
            return s;
    }

    // else
    s = alloc(sizeof(Sym));
    s->name = alloc(n);
    memmove(s->name, symb, n);

    strcpy(s->name, symb);

    s->link = hash[h];
    hash[h] = s;

    syminit(s);

    return s;
}
@
%assembler: similiar
%linker: similiar
%ocaml: use Hashtbl.find and do not use a global

\subsection{Identifier symbols}

% complex sub structure :)
<<[[Sym]] identifier value fields>>=
<<[[Sym]] identifier value, type and storage fields>>
<<[[Sym]] identifier value, scope fields>>
<<[[Sym]] identifier value, checking fields>>
<<[[Sym]] identifier value, code generation fields>>
@
%ocaml: actually too many concerns at once I think, better to separate
% in different environment in different modules

% 5c can know the type, the offset, the storage,
% the kind, of the variable currently in scope thanks to the symbol table.
%All the important attributes are copied from the
% symbol back to the node. So information at the definition site
% are copied (merged sometimes) with information at the use site.

% Symbol table has a scope. After parsing, after backtrack
% on the Decl in symbol table, Sym value for an identifier are lost?
% Ok because Sym values are propagated to the Node.


<<[[Sym]] identifier value, type and storage fields>>=
// ref<Type>
Type*	type;
// enum<Storage_class>
char	class;
@
%ocaml: use only as environment when typechecking

% similar to Node.type, Decl.type (below), and now Sym.type
% note that this class field is then used by the lexer
% for the typedef trick!
% And the Sym.type of this symbol is then used to get the final resolved type!

<<[[Sym]] identifier value, scope fields>>=
ushort	block;
@
% see also Decl.block (below)
%ocaml: do naming phase or do it in parsing. embed blockid in 'fullname' type.
% and check if redeclare later in an extra check phase.

% Why need block in Sym? for sue? no there is sueblock already.
%  Anyway the symbol currently in scope in the symbol table has
%  the property set (offset, storage, type). Why need block?
% To check for redeclaration! If introduce a new variable, and last
% def was in same scope, then should issue an error (unless it was
% a global in which case it can be ok to redeclare the same variable)
% OCaml also checks whether a signature matches a definition.

<<[[Sym]] identifier value fields>>=
long	varlineno;
@
% this references the place where the symbol is defined.
% when do int x; .... return x; we can print a good error message
% if type inferered for x does not match the decl and report the
% location where x is defined.


\subsection{Tag symbols}

% if a name refers also to a tag, then here is a ref to its type def
% (which at first can have Type.link set to T, but will be defined later).
% sue = structure union enum
<<[[Sym]] tag value fields>>=
Type*	suetag;
@
%less: rename sue_tag_type?


% restored in revertdcl()
% mutual ref, s->suetag->tag = s;
% Then can go through the fields in suetag->link!


% But what about incomplete information, like if Struct Foo x; ?
% width of x not known yet! but width is stored in the type,
% and when do struct Foo x; in AST x type points to an incomplete
% type that will be filled later (t->link).

% Seen Sym.suetag before.
% depth of struct
<<[[Sym]] tag value fields>>=
ushort	sueblock;
@
% why need that? for forward decl check? 
% to know when define a struct if define a previous decl or if introduce
%  a new struct because different scope.
% To know also if redefine in same scope the same structure.

\subsection{Other symbols}

% for labels?
%  see later labels

<<[[Sym]] macro value fields>>=
char*	macro;
@
%ocaml: separate different kinds of symbols in different hash tables

<<[[Sym]] lexeme value fields>>=
// enum<lexeme>
ushort	lexical;
@
% for if, then, where value is then TIF, ...
%ocaml: dont abuse Sym for everything, use Lexing.lexeme

<<function syminit>>=
void
syminit(Sym *s)
{
    s->lexical = LNAME;
    s->block = 0;
    s->offset = 0;

    s->type = T;
    s->class = CXXX;
    s->suetag = T;

    s->sig = SIGNONE;
    <<[[syminit()]] remaining initialisations>>
}
@
% CXXX, unspecified storage when mentioned first.



\section{Declarations, namespaces, and scope, [[Decl]]}
% nested scope

% the different "namespaces"
<<enum dxxx>>=
enum Namespace
{
    DMARK, // special mark to help separate the different scopes

    DAUTO, // locals/parameters/globals/typedefs/functions identifiers
    DSUE,  // struct/union/enum tags
    DLABEL,// labels, goto
};
@
%todo: DAUTO is a bad name, DIDENT would be better no? and SUE -> DTAG?
%ocaml: DMARK is ugly; use a list of lists so clear boundaries
% between different scopes

%Lots of XAUTO:
% - DAUTO(declaration?), 
% - TAUTO(temporary), 
% - LAUTO(lexeme), 
% - CAUTO(class), 
% hmmm that's a lot.

% this type is for the different C namespaces which are
%  identifier, sue tags, and labels. See K&R book?

<<struct Decl>>=
struct	Decl
{
    Sym*	sym;
    // enum<Namespace>
    short	val;

    <<[[Decl]] sym copy fields>>

    // Extra fields
    <<[[Decl]] extra fields>>
};
@
%less: rename val? to kind? or namespace?
% this val will help to know then which 'xxx value field' makes sense
% in this context for this symbol.
%ocaml: if had cleaner ADT, you not need to overload Sym.

% have this 'sym copy fields' above, because when add an ident in a scope,
% we mask the previous one, but we want to remember the previous
% one when we exit the scope to restore it in the global symbol
% table.
%ocaml: use lists of lists in env itself.

% stack because nested scopes
<<global dclstack>>=
// list<list<ref_own<Decl>>> (next = Decl.link, nested lists via DMARK)
Decl*	dclstack;
@
%ocaml: have a list of list, and separate fields for the separate
% namespaces (id vs tags (labels are done later in check.ml))

<<[[Decl]] extra fields>>=
// list<ref_own<Decl> of dclstack
Decl*	link;
@
<<constant D>>=
#define	D	((Decl*)nil)
@

<<[[cinit()]] dclstack initialization>>=
dclstack = D;
@

<<function push>>=
Decl*
push(void)
{
    Decl *d;

    d = alloc(sizeof(Decl));
    // add_stack(d, dclstack)
    d->link = dclstack;
    dclstack = d;

    return d;
}
@
% usage is d = push(); and then adjust d (usually d->val = DMARK
% as for symbol one prefers to use push1() instead of push() directly).

% save old value of a symbol, will be restored by revertdcl()
% until the next DMARK
<<function push1>>=
Decl*
push1(Sym *s)
{
    Decl *d;

    d = push();
    d->sym = s;
    d->val = DAUTO;

    <<[[push1()]] save symbol fields in decl>>

    return d;
}
@
% usage should be d = push1(s); and adjust s fields now that
% the old values of s has been saved??
\l rename push_DAUTO?

% nested language! block number, to allow multiple blocks to use
% similar local names
<<global blockno>>=
int	blockno;
@
% blockcounter

<<global autobn>>=
int	autobn;
@
%ocaml: put in env stack like other things instead of abusing fields
% to save old value

% managed in a stack


<<[[cinit()]] namespace globals initialization>>=
blockno = 0;
autobn = blockno;
@
%old: autobn = 0;


<<function markdcl>>=
//@Scheck: used by cc.y
void markdcl(void)
{
    Decl *d;

    blockno++;

    d = push();
    d->val = DMARK;

    // saving current values
    d->block = autobn;
    d->offset = autoffset;

    autobn = blockno;
}
@
%ocaml: just introduce a new list, no need DMARK

% save current scope autobn, so can restore it when pop DMARK.

% will see autoffset later (and why also need to save/restore it)


<<[[Decl]] sym copy fields>>=
Type*	type;  // for Sym.type and Sym.suetag
ushort	block; // for Sym.block and Sym.sueblock and autobn
@
%ocaml: ugly abuse of same field for many different things

<<[[Decl]] sym copy fields>>=
long	offset; // for Sym.offset and autoffset
@
%ocaml: do in separate phase, and pass proper env in separate analysis
% so no need to save/restore it

% this are sym copy fields and also copy of autobn and autoffset
% actually.
\l rename old_type, old_block, old_offset?

% where dealloc things? 
% - end of functions all labels attached to Sym of that name should be freed?
% - end of block

% at end of a scope we need to revert the decls of all local entities.
% related: dodecl()?
<<function revertdcl>>=
//@Scheck: used by cc.y
Node* revertdcl(void)
{
    Decl *d;
    Sym *s;
    Node *n;
    <<[[revertdcl()]] other locals>>

    n = Z;
    for(;;) {
        // d = pop(dclstack)
        d = dclstack;
        <<[[revertdcl()]] sanity check d>>
        dclstack = d->link;

        s = d->sym;
        switch(d->val) {
        <<[[revertdcl()]] switch declaration type cases>>
        }
    }
    return n;
}
@
%ocaml: pop, but also need Hashtbl.remove in globals.hids for typedefs
% and for env.ids and env.tags.

% what is this Node n? why return a node? because when we revert
% a local volatile we actually generate some fake nodes USED(&local_volatile)
% so we need to return this OLIST of hidden generated nodes.

<<[[revertdcl()]] sanity check d>>=
if(d == D) {
    diag(Z, "pop off dcl stack");
    break;
}
@
%ocaml: raise Impossible, every revertdcl is paired with a markdcl

<<[[revertdcl()]] switch declaration type cases>>=
case DMARK:
    // restore info previous block
    autobn = d->block;
    autoffset = d->offset;
    // we popped everything, exit loop and return
    return n;
@
% return here! we don't want to go further
% autoffset should be in a separate phase? dont abuse Decl for everything?


<<[[revertdcl()]] switch declaration type cases>>=
case DSUE:
    <<[[revertdcl()]] debug revert DSUE>>

    // retore info from previous tag
    s->suetag = d->type;
    s->sueblock = d->block;

    break;
@
%ugly: abuse of type and block a bit
%symbol has info about block of variable but also block of tag.
% two different namespaces but use the same symbol; just use different
% fields of those symbols.

% Again why need block? anyway suetag will point to the right thing.

<<[[revertdcl()]] switch declaration type cases>>=
case DLABEL:
    <<[[revertdcl()]] debug revert DLABEL>>

    <<[[reverdcl()]] DLABEL case, warn if label not used>>
    s->label = Z;
    break;
@
%no restore? because labels are at function scope
% and there is no global labels, so safe to set to Z.
% see dcllabels(), they are not added in the current scope but in function scope
%lint: start to to do lint check at parsing time :)


<<[[revertdcl()]] switch declaration type cases>>=
case DAUTO:
    <<[[revertdcl()]] debug revert DAUTO>>

    <<[[reverdcl()]] DAUTO case, warn if auto declared but not used>>
    <<[[reverdcl()]] if volatile symbol>>
    // restore info previous identifier
    <<[[reverdcl()]] DAUTO case, restore symbol fields from decl>>

    break;
@


<<[[Decl]] sym copy fields>>=
char	class;
long	varlineno;
@
\l rename old_class, old_varlineno?
<<[[Decl]] sym copy fields>>=
bool	aused;
@
% a used for used/set checking!
% see also Sym.aused

<<[[reverdcl()]] DAUTO case, restore symbol fields from decl>>=
s->type = d->type;
s->offset = d->offset;
s->block = d->block;

s->class = d->class;
s->varlineno = d->varlineno;
s->aused = d->aused;
@


<<[[push1()]] save symbol fields in decl>>=
d->type   = s->type;
d->offset = s->offset;
d->block  = s->block;

d->class  = s->class;
d->aused  = s->aused;
d->varlineno = s->varlineno;
@



% FIGURE with simple program:
% int x;
% void foo(int y) {
%    int x;
%    x = y + 2;
%    return x;
% }
% => see Decl shadowing old decl, AST, link to sym, link from sym to type,
% etc.

\section{[[Token]]}

<<union yacc>>=
%union  {
    vlong   vval;
    double  dval;
    struct
    {
        char*   s;
        long    l;
    } sval;
    Sym*    sym;

   <<[[union yacc]] other fields>>
}
@
%ocaml: more precise token type directly in parser.mly

% from cc.y
<<token declarations>>=
%token  <sym>   LNAME LTYPE
%token  <vval>  LCONST LUCONST  LLCONST  LULCONST   LVLCONST LUVLCONST
%token  <dval>  LFCONST LDCONST
%token  <sval>  LSTRING LLSTRING
@
\l LTYPE -> LTYPENAME
%ocaml: factorize the U vs nonU and I vs L vs VL, have sign and intsize type
%ocaml: same for floats and strings

<<token declarations>>=
%token  LVOID   LCHAR LSHORT LINT LLONG   LDOUBLE LFLOAT   LSIGNED LUNSIGNED
%token  LSTRUCT LUNION LENUM
%token  LTYPEDEF  
%token  LCONSTNT LVOLATILE  LRESTRICT LINLINE
%token  LAUTO LSTATIC LEXTERN LREGISTER
%token  LIF LELSE  LWHILE LDO LFOR  LBREAK LCONTINUE  LRETURN LGOTO
%token  LSWITCH LCASE LDEFAULT 
%token  LSIZEOF
@
% L for Lexeme probably
% so have LDOUBLE and TDOUBLE (and even BDOUBLE)

% small language in the end :)



\section{Assembly output, [[Instr]]}

% see Opcode and operand_kind in Assembler.nw
% (and Aconv, Rconv, Dconv, ... in this file)

% see also enum of 5.out.h with REGRET, REGARG, REGSP, REGTMP

<<struct Prog(arm)>>=
struct	Prog
{
    // enum<Opcode>, from 5.out.h
    char	as;

    Adr	from;
    Adr	to;

    long	lineno; // of the corresponding line in the C program!

    <<[[Prog]] other fields(arm)>>

    // Extra
    <<[[Prog]] extra fields(arm)>>
};
@
%linker: same?
%ocaml: just reuse same type; use Ast_asm5.ml, precise AST.

% lineno! for debugger! so generated object file will contain
% line information of the C code.
% 'char' is enough, less than 255 ARM opcodes :)


% really ARM specific
<<[[Prog]] other fields(arm)>>=
// option<enum<registr>>, None = R_NONE, see 5.out.h
// abused also to represent TEXT or DATA attributes (e.g. NOPROF)
char	reg;
@

<<[[Prog]] other fields(arm)>>=
// bitset<?>
byte	scond;
@
%less: rename reg

<<struct Adr(arm)>>=
struct	Adr
{
    // enum<Operand_kind> (D_NONE by default)
    char	type;

    long	offset; // generic value, offset or simple constant
    char	sval[NSNAME];
    double	dval;
    Ieee	ieee;

    <<[[Adr]] other fields(arm)>>
    <<[[Adr]] type fields(arm)>>
};
@
%less: use union for the values?
%Similar to Gen in Assembler.nw and Adr in Linker.nw. Some differences?:
% - ??
%aspectize float? ieee?

% Adr for address; related to address-able later.

<<constant A>>=
#define	A	((Adr*)nil)
@


<<[[Adr]] other fields(arm)>>=
// option<enum<registr>> None = R_NONE
char	reg;
@


<<[[Adr]] other fields(arm)>>=
Sym*	sym;
// enum<Sym_kind>
char	symkind;
@
%old: was name, but symkind is less confusing (did the same in
% Assembler.nw and Linker.nw)
%todo: put in 'value fields' instead?


<<global zprog>>=
Prog	zprog;
@

<<[[ginit()]] zprog initialisation>>=
zprog.link = P;
zprog.as = AGOK;
zprog.reg = R_NONE;
zprog.from.type = D_NONE;
zprog.from.symkind = N_NONE;
zprog.from.reg = R_NONE;
zprog.to = zprog.from;
zprog.scond = COND_ALWAYS;  
@
% will do lots of p = alloc(Prog); p = zprog; and starts from there.


% short tutorial ARM assembler? with D_OREG, etc?
% or just redirect people to Assembler.nw








\chapter{[[main()]]}

<<global thechar>>=
int	thechar;
@
% '5' convenient! for multiarchi! no conflicts! mk everything power!
%less: Why 'int' and not 'char' ?

<<global thestring>>=
char*	thestring;
@
% "arm"


<<global outfile>>=
char*	outfile = nil;
@
% -o, 5.out?



<<function main>>=
//@Scheck: not dead, entry point :)
void main(int argc, char *argv[])
{
    int err;
    <<[[main()]] locals>>

    memset(debug, 0, sizeof(debug));
    <<[[main()]] xxxinit()>>
    <<[[main()]] remaining initialisation>>

    ARGBEGIN {
    <<[[main()]] command line processing>>
    } ARGEND

    if(argc < 1 && outfile == nil) {
        print("usage: %cc [-options] files\n", thechar);
        errorexit();
    }

    <<[[main()]] multiple files handling>>
    //else

    err = compile((argc == 0) ? "stdin" : argv[0], defs, ndef);

    if(err)
        errorexit();
    exits(nil);
}
@
% compile returns number of possible errors
%ocaml: be stricter

%really useful to compile stdin??
%ocaml: no compile from stdin, never used. 5c is not an interpreter.

% used above.
<<[[main()]] locals>>=
// growing_array<string>
char **defs = nil;
int ndef = 0;
@
% the -Dxxx
%less: why have not something similar for Assembler.nw?
%ocaml: use list directly



<<[[main()]] xxxinit()>>=
tinit(); // type globals initialisation
cinit(); // C lexing/parsing globals initialisation
ginit(); // arch dependent globals initialisation, 5c/8c/...
arginit(); // printf argument checking initialisation
@
%ocaml: no need, can initialize things in modules already
% and most of those things are not needed because we build things
% directly

<<[[ginit()]] thexxx initialisation>>=
thechar = '5';
thestring = "arm";
@
% gxx = arch specific? =~ hooks, gins, gout, etc.

\section{Arguments processing}

<<[[main()]] command line processing>>=
case 'o':
    outfile = ARGF();
    break;
@



<<[[main()]] locals>>=
char *p;
@
<<[[main()]] command line processing>>=
case 'D':
    p = ARGF();
    if(p) {
       <<[[main()]] when -D in command line processing, grow defs array>>
        defs[ndef++] = p;

        dodefine(p);
    }
    break;
@
% should report error if do just -D no?
%ocaml: use List, no need growing array

<<[[main()]] locals>>=
char **np;
int maxdef = 0;
@

<<[[main()]] when -D in command line processing, grow defs array>>=
 // realloc, growing array
 if(ndef >= maxdef){
     maxdef += 50;
     np = alloc(maxdef * sizeof *np);
     if(defs != nil)
         memmove(np, defs, (maxdef - 50) * sizeof *np);
     defs = np;
 }
@

% remember that p is possibly string containing XX=YY 

<<[[main()]] command line processing>>=
case 'I':
    p = ARGF();
    if(p)
        setinclude(p);
    break;
@

<<[[main()]] remaining initialisation>>=
setinclude(".");
@
% so include[0] is special! used for "" vs <>
% (will be overwritten later)
%ocaml: use a pair for the local dir and system paths, clearer


<<[[main()]] locals>>=
int c;
@
<<[[main()]] command line processing>>=
default:
    c = ARGC();
    if(c >= 0 && c < sizeof(debug))
        debug[c]++;
    break;
@


% would be nice to have a -dump flag and dump action here,
% but the AST is available only in cc.y func def action.
%ocaml: would be better if the parser was returning an AST
% instead, so we could call codegen in the main (or compile)
% instead of in cc.y.

% put -c here? There is no -c! (well there is one but for constant if check).
% 5c always generates an object file. The linker is a separate necessary
% program.

\section{[[compile()]]}

<<global outbuf>>=
Biobuf	outbuf;
@
% used by outcode()
%ocaml: dump the whole Ast_asm5.ml in one function call. No need buffer.
% just use Marshall.

<<global diagbuf>>=
Biobuf	diagbuf;
@
%ocaml: use pr2? already buffered no?

<<[[compile()]] locals>>=
char *p;
fdt ofd;
static bool first = true;
@
% first useful only because can compile multiple files with 5c,
% but useless features. mk can handle that!

% main -> <> (can be called multiple times because of multifile parallel option)
<<function compile>>=
int
compile(char *infile, char **defs, int ndef)
{
    <<[[compile()]] locals>>

    <<[[compile()]] set p to basename(infile) and adjust include>>

    if(outfile == nil) {
        <<[[compile()]] set outfile, using p, to {basename(infile)}.{thechar}>>
    }

    <<[[compile()]] setinclude("/{thestring}/include") or INCLUDE>>

    if (first)
        Binit(&diagbuf, STDOUT, OWRITE);
    first = false;

    <<[[compile()]] if writing acid to standard output>>
    else {
        ofd = mycreat(outfile, 0664);
        <<[[compile()]] sanity check ofd>>
        Binit(&outbuf, ofd, OWRITE);
    }

    <<[[compile()]] initialize IO>>

    <<[[compile()]] if use ANSI preprocessor>>
    else {
        if(strcmp(infile, "stdin") == 0)
            newfile(infile, STDIN);
        else
            newfile(infile, -1);
    }
 
    // The big call!
    yyparse();

    if(!debug['a'] && !debug['Z'])
        // Another important call, calls outcode()
        gclean();
    return nerrors;
}
@
%old: file -> infile
%old: I put the first = false; closer to code using it
%ocaml: should also pass includes, outfile, instead of using globals
% and should not support stdin, and using newio() and other globals for cpp

% main -> compile -> yyparse -> yylex -> macxxx
%                            -> codgen (portable) -> gen
%                 -> gclean -> outcode
% gclean handle code generation for toplevel globals! (at least the AGLOBL)



<<[[compile()]] sanity check ofd>>=
if(ofd < 0) {
    diag(Z, "cannot open %s - %r", outfile);
    outfile = nil;
    errorexit();
}
@
%ocaml: Sys_error exception message is clear enough

<<[[cinit()]] lexing globals initialization>>=
nerrors = 0;
@






<<[[compile()]] locals>>=
char ofile[400];
@

<<[[compile()]] set p to basename(infile) and adjust include>>=
strcpy(ofile, infile);
p = utfrrune(ofile, pathchar());
if(p) {
    *p++ = '\0';
    if(!debug['.'])
        include[0] = strdup(ofile);
} else
    p = ofile;
@
%ocaml: use Filename.dirname and regexps
\l include global? why not using setinclude?
% so overwrite include[0] here.
% (unless -. to not overwrite first entry which is current dir ("."))
% see setinclude(".") before.
%ocaml: remove this feature?


% FIGURE where p is in the middle, and replace the / by a \0
% so have two strings and strdup(ofile) works

<<[[compile()]] set outfile, using p, to {basename(infile)}.{thechar}>>=
outfile = p;
if(outfile) {
    if(p = utfrrune(outfile, '.'))
        if(p[1] == 'c' && p[2] == 0)
            p[0] = '\0';
    p = utfrune(outfile, 0);
    <<[[compile()]] adjust p for outfile if acid option>>
    <<[[compile()]] adjust p for outfile if pickle option>>
    else {
        p[0] = '.';
        p[1] = thechar;
        p[2] = '\0';
    }
} else
    outfile = "/dev/null";
@
%ocaml: use Filename.basename and regexps

<<[[compile()]] locals>>=
char incfile[20];
@


<<[[compile()]] setinclude("/{thestring}/include") or INCLUDE>>=
if(p = getenv("INCLUDE")) {
    setinclude(p);
} else {
    if(systemtype(Plan9)) {
        sprint(incfile, "/%s/include", thestring);
        setinclude(strdup(incfile));
        setinclude("/sys/include");
    }
}
@
% note that INCLUDE can contain space! and setinclude handles that


% ok now details each functions called.
% yyparse() will see in parsing section though.

\section{[[gclean()]]}
% mv earlier? just after compile?


% main -> compile -> yyparse; <>
<<function gclean(arm)>>=
void
gclean(void)
{
    <<[[gclean()]] locals>>

    <<[[gclean()]] sanity check reg>>

    <<[[gclean()]] adjust symstring width>>
    <<[[gclean()]] adjust symrathole width>>

    <<[[gclean()]] generate all AGLOBL pseudo opcodes>>
    <<[[gclean()]] generate last opcode, AEND>>

    // generate the whole output file using outbuf global
    outcode();
}
@
%ocaml: lift up outcode; not very visible inside gclean, and also
% no need for AEND

% generate AGLOBL! (the ADATA are done in doinit)
% generate AEND



\section{Initializations}

\subsection{[[tinit()]]}
% type initialisation?

% main -> <>
<<function tinit>>=
void
tinit(void)
{
    int *ip;
    Init *p;

    <<[[tinit()]] initialise thash>>
    <<[[tinit()]] initialise xxxnames debugging arrays>>
    <<[[tinit()]] initialise typexxx type sets>>
    <<[[tinit()]] initialise tcompat arrays>>
    <<[[tinit()]] initialise 32 bits defaults type sets>>
}
@
% see Init in appendix.


% put here just to show an example?
<<[[tinit()]] initialise thash>>=
for(p=thashinit; p->code >= 0; p++) {
    urk("thash", nelem(thash), p->code);
    thash[p->code] = p->value;
}
@
%less: then why not using array designator then?

<<function urk>>=
void
urk(char *name, int max, int i)
{
    if(i >= max) {
        fprint(2, "bad tinit: %s %d>=%d\n", name, i, max);
        exits("init");
    }
}
@


\subsection{[[cinit()]]}
% C lexing/parsing language initialisation?

% main -> <>
<<function cinit>>=
void
cinit(void)
{
    int i;
    <<[[cinit()]] locals>>

    <<[[cinit()]] lexing globals initialization>>
    <<[[cinit()]] memory globals initialization>>
    <<[[cinit()]] types initialization>>
    <<[[cinit()]] hash initialization>>
    <<[[cinit()]] symbol table initialization>>
    <<[[cinit()]] namespace globals initialization>>
    <<[[cinit()]] dclstack initialization>>
    <<[[cinit()]] symstring initialization>>
    <<[[cinit()]] nodproto initialization>>
    <<[[cinit()]] pathname initialisation from cwd>>
    <<[[cinit()]] fmtinstall>>
}
@
%old: dead code about 't'?
%    t = typ(TARRAY, types[TCHAR]);
%    t->width = 0;
%later: would be nice to have checks that detect those useless 
% assignments

% seen many cinit initializations in core DS. hash, declstack, etc.







% =~ cwd, for include "" to work
<<global pathname>>=
char*	pathname;
@
% 
\l rename cwd?

<<[[cinit()]] pathname initialisation from cwd>>=
pathname = allocn(pathname, 0, 100);
if(getwd(pathname, 99) == 0) {
    pathname = allocn(pathname, 100, 900);
    if(getwd(pathname, 999) == 0)
        strcpy(pathname, "/???");
}
@
% who uses that? for include "" ?

\subsection{[[ginit()]]}
% generation code initialisation

% main -> <>
<<function ginit(arm)>>=
void
ginit(void)
{
    <<[[ginit()]] locals>>

    <<[[ginit()]] thexxx initialisation>>
    <<[[ginit()]] pc initialisation>>
    <<[[ginit()]] misc initialisations>>
    <<[[ginit()]] zprog initialisation>>
    <<[[ginit()]] special nodes initialisation>>
    <<[[ginit()]] com64init initialisation>>
    <<[[ginit()]] reg and resvreg initialisation>>
}
@


\subsection{[[arginit()]]}

% see later









\chapter{Input}
%dup: similar to Assembler, could reuse

% lineno in Node section in core DS chapter.

<<[[cinit()]] lexing globals initialization>>=
lineno = 1;
@


\section{Files management, [[iostack]]}

<<struct Io>>=
struct	Io
{
    // option<fdt> (None = -1)
    short	f;
    <<[[Io]] buffer fields>>
    // Extra
    <<[[Io]] extra fields>>
};
@
%ocaml: use a stack of lexbuf (over a chan or over a string)
% and adds also in the stack an optional chan as need to close it
% (and reuse code between 5a and 5c)


<<global iostack>>=
// list<ref_own<Io> (next = Io.link)
Io*	iostack;
@
%ocaml: use list (used as a stack) directly

<<[[Io]] extra fields>>=
// list<ref_own<Io>> (from = iostack or iofree)
Io*	link;
@

<<constant I>>=
#define	I	((Io*)nil)
@



<<global ionext>>=
// option<ref<Io>>
Io*	ionext;
@


<<[[compile()]] initialize IO>>=
// for embedded cpp
newio();
@



<<function newio>>=
void
newio(void)
{
    Io *i;

    <<[[newio()]] allocate a new Io in [[i]] or find a free one>>
    i->c = 0;
    i->f = -1;
    ionext = i;
}
@


<<global iofree>>=
Io*	iofree;
@
%ocaml: just use a list and Gc

<<[[cinit()]] lexing globals initialization>>=
iostack = I;
iofree = I;
@


<<[[newio()]] allocate a new Io in [[i]] or find a free one>>=
static int pushdepth = 0;

i = iofree;
if(i == I) {
    <<[[newio()]] sanity check depth of macro expansion>>
    i = alloc(sizeof(*i));
} else
    // pop(iofree)
    iofree = i->link;
@
% note that when expand macro, we need to process expansion, which
%  may trigger further expansions!

<<[[newio()]] sanity check depth of macro expansion>>=
pushdepth++;
if(pushdepth > 1000) {
    yyerror("macro/io expansion too deep");
    errorexit();
}
@
%ocaml: should do too

% remember in compile():
%            newfile(infile, -1);

% main | macinc -> <>
<<function newfile>>=
void
newfile(char *s, int f)
{
    Io *i;

    <<[[newfile()]] debug>>

    // add_list(ionext, iostack)
    i = ionext;
    i->link = iostack;
    iostack = i;

    i->f = f;
    if(f < 0)
        i->f = open(s, 0);
    if(i->f < 0) {
        yyerror("%cc: %r: %s", thechar, s);
        errorexit();
    }
    fi.c = 0;

    <<[[newfile()]] call linehist>>
}
@





\section{Buffer management, [[fi]]}

%ocaml: IO are already buffered

<<constant BUFSIZ>>=
#define	BUFSIZ		8192
@
% used also for macro expansion!

<<[[Io]] buffer fields>>=
char	b[BUFSIZ];
@
%ocaml: store lexbuf in stack of included files

<<struct Fi>>=
struct Fi
{
    // ref<char> (target = Io.b)
    char*	p;
    // remaining characters in Io.b to read
    int	c;
};
@

<<global fi>>=
struct Fi fi;
@

\section{[[GETC()]]}

<<function GETC>>=
#define	GETC()	((--fi.c < 0)? filbuf(): (*fi.p++ & 0xff))
@

<<constant EOF>>=
#define	EOF	(-1)
@
%ocaml: ocamllex handles that already


<<function filbuf>>=
int
filbuf(void)
{
    Io *i;

loop:
    i = iostack;
    if(i == I)
        return EOF;
    if(i->f < 0)
        goto pop;
    fi.c = read(i->f, i->b, BUFSIZ) - 1;
    if(fi.c < 0) {
        close(i->f);
        <<[[filbuf()]] when close file, call linehist>>
        goto pop;
    }
    fi.p = i->b + 1;
    return i->b[0] & 0xff;

<<[[filbuf()]] pop>>
}
@

% so potentially could have a token spread on 2 files?

%dup: put FIGURE in Assembler.nw


<<[[filbuf()]] pop>>=
pop:
    // pop(iostack)
    iostack = i->link;
    // push(i, iofree)
    i->link = iofree;
    iofree = i;

    // i = top(iostack), the fresh top of the stack input file
    i = iostack;
    if(i == I)
        return EOF;
    // restore file pointers
    fi.p = i->p;
    fi.c = i->c;
    if(--fi.c < 0)
        goto loop;
    return *fi.p++ & 0xff;
@



<<[[Io]] buffer fields>>=
// like Fi, saved pointers in Io.b
char*	p;
short	c;
@





\chapter{Lexing}

% Why not using lex? Why handwritten? ...
% Because anyway have to do a few things which are easier outside
% lex like comment handling, typedefs, escape characters?
% Had with C lex? hmm but can do that with ocamllex!
% For unicode! ocamllex not great with unicode (hence ulex) ...

\section{[[yylex()]]}


<<function yylex>>=
//@Scheck: not dead, called by yyparse
long yylex(void)
{
    long c; // Rune?
    <<[[yylex()]] locals>>

    <<[[yylex()]] peekc handling, starting part>>
l0:
    c = GETC();

l1:
    <<[[yylex()]] if unicode character>>
    if(isspace(c)) {
        <<[[yylex()]] if c is newline>>
        // ignore spaces
        goto l0;
    }
    <<[[yylex()]] before switch, if isxxx>>
    switch(c) {
    <<[[yylex()]] switch c cases>>
    default:
        return c;
    }
    <<[[yylex()]] peekc handling, ending part>>
    return c;

<<[[yylex()]] labels>>
}
@

% newline part 1 (lots of code to deal with lineno)
<<[[yylex()]] if c is newline>>=
if(c == '\n')
    lineno++;
@
% this unfortunately needs to be handled at many places

\section{Peek, seek, and look ahead}

<<global peekc>>=
int	peekc;
@
%ocaml: ocamllex handles that

<<constant IGN>>=
#define	IGN	(-2)
@

<<[[cinit()]] lexing globals initialization>>=
peekc = IGN;
@
% again, a few places doing that, because cpp is factorized with 5a
%  and try to be independent.
%ocaml: ocamllex handles that automatically if share the same lexbuf
% in different "parser"


<<[[yylex()]] peekc handling, starting part>>=
if(peekc != IGN) {
    c = peekc;
    peekc = IGN;
    goto l1;
}
@
%ocaml: ocamllex handles that
<<[[yylex()]] locals>>=
long c1;
@
<<[[yylex()]] peekc handling, ending part>>=
peekc = c1;
@




<<[[yylex()]] switch c cases>>=
case EOF:
    peekc = EOF;
    return -1; // EOF
@
% why not using EOF? why use -1 explicitely? because this time
% it is the lexeme kind, not the character?



\section{Comments}

% comment part 1
<<[[yylex()]] switch c cases>>=
case '/':
    c1 = GETC();
    if(c1 == '*') {
        // '/''*' read; skip everything until next '*''/'
        for(;;) {
            c = getr();
            while(c == '*') {
                c = getr();
                if(c == '/')
                    goto l0;
            }
            if(c == EOF) {
                yyerror("eof in comment");
                errorexit();
            }
        }
    }
    if(c1 == '/') {
        // '/''/' read; skip everything until next '\n'
        for(;;) {
            c = getr();
            if(c == '\n')
                goto l0;
            if(c == EOF) {
                yyerror("eof in comment");
                errorexit();
            }
        }
    }
    if(c1 == '=')
        return LDVE;
    break;
@
% LDVE, not a comment here!!
% also will return just '/' for Div.

% getr() here, for get rune, different from GETC.


\section{Keywords and identifiers}


<<global itab>>=
struct
{
    char	*name;
    // enum<lexeme>
    ushort	lexical;
    // option<enum<Type_kind>>, None = 0 (or TXXX)
    ushort	type;
} itab[] =
{
    "auto",		LAUTO,		0,
    "static",	LSTATIC,	0,
    "extern",	LEXTERN,	0,
    "register",	LREGISTER,	0,

    "const",	LCONSTNT,	0,
    "volatile",	LVOLATILE,	0,

    "inline",	LINLINE,	0,
    "restrict",	LRESTRICT,	0,

    "void",		LVOID,		TVOID,
    "char",		LCHAR,		TCHAR,
    "int",		LINT,		TINT,
    "short",	LSHORT,		TSHORT,
    "long",		LLONG,		TLONG,
    "float",	LFLOAT,		TFLOAT,
    "double",	LDOUBLE,	TDOUBLE,

    "unsigned",	LUNSIGNED,	0,
    "signed",	LSIGNED,	0,

    "struct",	LSTRUCT,	0,
    "union",	LUNION,		0,
    "enum",		LENUM,		0,

    "typedef",	LTYPEDEF,	0,

    "if",		LIF,		0,
    "else",		LELSE,		0,
    "while",	LWHILE,		0,
    "do",		LDO,		0,
    "for",		LFOR,		0,
    "break",	LBREAK,		0,
    "continue",	LCONTINUE,	0,
    "switch",	LSWITCH,	0,
    "case",		LCASE,		0,
    "default",	LDEFAULT,	0,
    "return",	LRETURN,	0,
    "goto",		LGOTO,		0,

    "sizeof",	LSIZEOF,	0,
    <<[[itab]] entries, kencc extensions>>
    0
};
@

<<[[cinit()]] locals>>=
Sym *s;
@
<<[[cinit()]] symbol table initialization>>=
for(i=0; itab[i].name; i++) {
    s = slookup(itab[i].name);
    s->lexical = itab[i].lexical;
    if(itab[i].type != 0)
        s->type = types[itab[i].type];
}
@
%ocaml: no need abuse symbol table.


<<[[yylex()]] locals>>=
char *cp;
@



<<[[yylex()]] switch c cases>>=
case '_':
    cp = symb;
    goto talph;
@

<<[[yylex()]] before switch, if isxxx>>=
if(isalpha(c)) {
    cp = symb;
    <<[[yylex()]] if L followed by unicode strings or character>>
    goto talph;
}
@

<<[[yylex()]] locals>>=
Sym *s;
@
<<[[yylex()]] labels>>=
talph:
    /*
     * cp is set to symb and some
     * prefix has been stored
     */
    for(;;) {
        <<[[yylex()]] in talph case, if unicode character>>
        if(!isalnum(c) && c != '_')
            break;
        *cp++ = c;
        c = GETC();
    }
    *cp = '\0';
    <<[[yylex()]] in talph case, debug symbol>>
    peekc = c;

    // the important call!
    s = lookup();

    <<[[yylex()]] in talph case, if macro symbol>>

    yylval.sym = s;
    <<[[yylex()]] alpha case, return LTYPE if typedef symbol s>>
    return s->lexical;
@


% note that macro symbol case! can have macro expansion.
% complicated code, see chapter X.

\subsection{Unicode identifiers}

<<[[yylex()]] if unicode character>>=
if(c >= Runeself) {
    /*
     * extension --
     *	all multibyte runes are alpha
     */
    cp = symb;
    goto talph;
}
@

<<[[yylex()]] in talph case, if unicode character>>=
if(c >= Runeself) {
    for(c1=0;;) {
        cp[c1++] = c;
        if(fullrune(cp, c1))
            break;
        c = GETC();
    }
    cp += c1;
    c = GETC();
    continue;
}
@

\subsection{Typedef trick}

% ambiguity in C grammar. 
% ex:
% not context-free.
% need to know if identifier is a typedef.
% so need  lexer/parser/symboltable cooperation
% (a bit ugly, mutual dependency).
% The parser sets the class of the symbol.
% Is there any issue when do  xxx xxx; ? no because
% xdecor actually uses ltag with LNAME | LTYPE.
% (but no conflict????)


<<[[yylex()]] alpha case, return LTYPE if typedef symbol s>>=
if(s->class == CTYPEDEF || s->class == CTYPESTR)
    return LTYPE;
@
% CTYPEDEF class explained later, in parsing.
%ocaml: do via separate hashtbl instead of global symbol table
% for everything

% At some point dodecl will set the class of the symbol!
% (via first xdecl? adecl?)

% CTYPESTR?? seems dead, so maybe remove?
\l remove?

\section{Operators}

<<[[yylex()]] switch c cases>>=
case '*':
    c1 = GETC();
    if(c1 == '=')
        return LMLE;
    break;
@
% else return character itself, which is ok since yacc have
% a special case for single character terminals.

%ocaml: lex would be better than this code. It will handle
% internally the backtrack.

<<[[yylex()]] switch c cases>>=
case '%':
    c1 = GETC();
    if(c1 == '=')
        return LMDE;
    break;
@

<<[[yylex()]] switch c cases>>=
case '+':
    c1 = GETC();
    if(c1 == '+')
        return LPP;
    if(c1 == '=')
        return LPE;
    break;
@

<<[[yylex()]] switch c cases>>=
case '-':
    c1 = GETC();
    if(c1 == '-')
        return LMM;
    if(c1 == '=')
        return LME;
    if(c1 == '>')
        return LMG;
    break;
@

<<[[yylex()]] switch c cases>>=
case '>':
    c1 = GETC();
    if(c1 == '>') {
        c = LRSH;
        c1 = GETC();
        if(c1 == '=')
            return LRSHE;
        break;
    }
    if(c1 == '=')
        return LGE;
    break;
@

<<[[yylex()]] switch c cases>>=
case '<':
    c1 = GETC();
    if(c1 == '<') {
        c = LLSH;
        c1 = GETC();
        if(c1 == '=')
            return LLSHE;
        break;
    }
    if(c1 == '=')
        return LLE;
    break;
@

<<[[yylex()]] switch c cases>>=
case '=':
    c1 = GETC();
    if(c1 == '=')
        return LEQ;
    break;
@

<<[[yylex()]] switch c cases>>=
case '!':
    c1 = GETC();
    if(c1 == '=')
        return LNE;
    break;
@

<<[[yylex()]] switch c cases>>=
case '&':
    c1 = GETC();
    if(c1 == '&')
        return LANDAND;
    if(c1 == '=')
        return LANDE;
    break;
@

<<[[yylex()]] switch c cases>>=
case '|':
    c1 = GETC();
    if(c1 == '|')
        return LOROR;
    if(c1 == '=')
        return LORE;
    break;
@

<<[[yylex()]] switch c cases>>=
case '^':
    c1 = GETC();
    if(c1 == '=')
        return LXORE;
    break;
@



\section{Numbers}

<<[[yylex()]] before switch, if isxxx>>=
if(isdigit(c))
    goto tnum;
@

<<enum numxxx>>=
enum Numxxx
{
    Numdec		= 1<<0,
    <<[[Numxxx]] cases>>
    Numflt		= 1<<4,
};
@
% decimal, long, unsigned?, vlong, float

<<[[yylex()]] labels>>=
tnum:
    c1 = 0;
    cp = symb;
    if(c != '0') {
        // not an hexa or octal number
        c1 |= Numdec;
        for(;;) {
            *cp++ = c;
            c = GETC();
            if(isdigit(c))
                continue;
            goto dc;
        }
    }
    <<[[yylex()]] in number case, 0xxx handling>>
<<[[yylex()]] in number case, decimal dc label handling>>
@



\subsection{Decimals}

<<[[yylex()]] locals>>=
vlong vv;
// enum<Type_kind>
long t;
@


<<[[yylex()]] in number case, decimal dc label handling>>=
dc:
    <<[[yylex()]] in number case, in decimal case, float handling>>
    //Fallthrough
<<[[yylex()]] in number case, in decimal case, ncu suffix label handling>>
<<[[yylex()]] in number case, in decimal case, long suffix label handling>>
    *cp = '\0';
    peekc = c;

    if(mpatov(symb, &yylval.vval))
        yyerror("overflow in constant");

    vv = yylval.vval;
    <<[[yylex()]] in number case, in decimal case, if vlong number>>
    <<[[yylex()]] in number case, in decimal case, if long number>>
    <<[[yylex()]] in number case, in decimal case, if unsigned number>>
    c = LCONST;
    t = TINT;
    goto nret;
@
%ocaml: lex definitely better I think


<<[[yylex()]] labels>>=
nret:
    yylval.vval = convvtox(vv, t);
    if(yylval.vval != vv){
        nearln = lineno;
        warn(Z, "truncated constant: %T %s", types[t], symb);
    }
    return c;
@

\subsection{[[convvtox()]]}

<<function convvtox>>=
vlong
convvtox(vlong c, int et)
{
    int n;

    n = 8 * ewidth[et];
    c &= MASK(n);
    if(!typeu[et])
        if(c & SIGN(n))
            c |= ~MASK(n);
    return c;
}
@
% ???? used a lot later

% yylex()#ncu -> <>
<<function mpatov>>=
/*
 * convert a string, s, to vlong in *v
 * return conversion overflow.
 * required syntax is [0[x]]d*
 */
bool
mpatov(char *s, vlong *v)
{
    vlong n, nn;
    int c;

    n = 0;
    c = *s;
    if(c == '0')
        goto oct;
    while(c = *s++) {
        if(c >= '0' && c <= '9')
            nn = n*10 + c-'0';
        else
            goto bad;
        if(n < 0 && nn >= 0)
            goto bad;
        n = nn;
    }
    goto out;

oct:
    s++;
    c = *s;
    if(c == 'x' || c == 'X')
        goto hex;
    while(c = *s++) {
        if(c >= '0' || c <= '7')
            nn = n*8 + c-'0';
        else
            goto bad;
        if(n < 0 && nn >= 0)
            goto bad;
        n = nn;
    }
    goto out;

hex:
    s++;
    while(c = *s++) {
        if(c >= '0' && c <= '9')
            c += 0-'0';
        else
        if(c >= 'a' && c <= 'f')
            c += 10-'a';
        else
        if(c >= 'A' && c <= 'F')
            c += 10-'A';
        else
            goto bad;
        nn = n*16 + c;
        if(n < 0 && nn >= 0)
            goto bad;
        n = nn;
    }
out:
    *v = n;
    return false;

bad:
    *v = ~0;
    return true;
}
@
% could split
%ocaml: int_of_string? handle long stuff?



\subsection{Hexadecimals and octals}

<<[[yylex()]] in number case, 0xxx handling>>=
// else, octal or hexadecimal number
*cp++ = c;
c = GETC();
if(c == 'x' || c == 'X')
    for(;;) {
        *cp++ = c;
        c = GETC();
        if(isdigit(c))
            continue;
        if(c >= 'a' && c <= 'f')
            continue;
        if(c >= 'A' && c <= 'F')
            continue;
        if(cp == symb+2)
            yyerror("malformed hex constant");
        goto ncu;
    }
if(c < '0' || c > '7')
    goto dc;
for(;;) {
    if(c >= '0' && c <= '7') {
        *cp++ = c;
        c = GETC();
        continue;
    }
    goto ncu;
}
//Fallthrough
@


\subsection{Unsigned numbers}

% why matters? why need this suffix?

<<[[Numxxx]] cases>>=
Numuns		= 1<<2,
@

<<[[yylex()]] in number case, in decimal case, ncu suffix label handling>>=
ncu:
    if((c == 'U' || c == 'u') && !(c1 & Numuns)) {
        c = GETC();
        c1 |= Numuns;
        goto ncu;
    }
@
% if second U? generate error? or part of other token? ugly.

<<[[yylex()]] in number case, in decimal case, if unsigned number>>=
if((c1 & Numuns) || convvtox(vv, TINT) < 0) {
    c = LUCONST;
    t = TUINT;
    goto nret;
}
@

\subsection{Long numbers}

% why need this suffix?

<<[[Numxxx]] cases>>=
Numlong		= 1<<1,
Numvlong	= 1<<3,
@

<<[[yylex()]] in number case, in decimal case, long suffix label handling>>=
if((c == 'L' || c == 'l') && !(c1 & Numvlong)) {
    c = GETC();
    if(c1 & Numlong)
        c1 |= Numvlong;
    c1 |= Numlong;
    goto ncu;
}
@

<<[[yylex()]] in number case, in decimal case, if vlong number>>=
if(c1 & Numvlong) {
    if((c1 & Numuns) || convvtox(vv, TVLONG) < 0) {
        c = LUVLCONST;
        t = TUVLONG;
        goto nret;
    }
    c = LVLCONST;
    t = TVLONG;
    goto nret;
}
@

<<[[yylex()]] in number case, in decimal case, if long number>>=
if(c1 & Numlong) {
    if((c1 & Numuns) || convvtox(vv, TLONG) < 0) {
        c = LULCONST;
        t = TULONG;
        goto nret;
    }
    c = LLCONST;
    t = TLONG;
    goto nret;
}
@

\subsection{Floats}

<<[[yylex()]] in number case, in decimal case, float handling>>=
if(c == '.')
    goto casedot;
if(c == 'e' || c == 'E')
    goto casee;
@

<<[[yylex()]] switch c cases>>=
case '.':
    c1 = GETC();
    if(isdigit(c1)) {
        cp = symb;
        *cp++ = c;
        c = c1;
        c1 = 0;
        goto casedot;
    }
    break;
@
% break cos '.' is a symbol


<<[[yylex()]] labels>>=
casedot:
    for(;;) {
        *cp++ = c;
        c = GETC();
        if(!isdigit(c))
            break;
    }
    if(c != 'e' && c != 'E')
        goto caseout;
    // Fallthrough

casee:
    *cp++ = 'e';
    c = GETC();
    if(c == '+' || c == '-') {
        *cp++ = c;
        c = GETC();
    }
    if(!isdigit(c))
        yyerror("malformed fp constant exponent");
    while(isdigit(c)) {
        *cp++ = c;
        c = GETC();
    }
    // Fallthrough
caseout:
    if(c == 'L' || c == 'l') {
        c = GETC();
        c1 |= Numlong; // DEAD? used?
    } else
    if(c == 'F' || c == 'f') {
        c = GETC();
        c1 |= Numflt;
    }
    *cp = 0;
    peekc = c;
    yylval.dval = strtod(symb, nil);
    if(isInf(yylval.dval, 1) || isInf(yylval.dval, -1)) {
        yyerror("overflow in float constant");
        yylval.dval = 0;
    }
    if(c1 & Numflt)
        return LFCONST;
    // else
    return LDCONST;
@
%ocaml: lex definitely better I think

\section{Characters}
% part1

<<[[yylex()]] switch c cases>>=
case '\'':
    /* '.' */
    c = escchar('\'', false, false);
    if(c == EOF)
        c = '\'';
    c1 = escchar('\'', false, false);
    if(c1 != EOF) {
        yyerror("missing '");
        peekc = c1;
    }

    vv = c;
    yylval.vval = convvtox(vv, TUCHAR);
    if(yylval.vval != vv)
        yyerror("overflow in character constant: 0x%lx", c);
    else
    if(c & 0x80){
        nearln = lineno;
        warn(Z, "sign-extended character constant");
    }
    yylval.vval = convvtox(vv, TCHAR);
    return LCONST;
@
% type not set for this LCONST?


% supports the ''' syntax
\t but I'm not sure cpp does!

% escchar is special. it returns next char unless it
% is the char passed as parameter in which case it returns (abuses) EOF.

% chars are converted to integer constants.

\subsection{Escaping characters}

%dup: Assembler.nw except have also the longflg and escflg
<<function escchar>>=
long
escchar(long e, int longflg, bool escflg)
{
    long c, l;
    int i;

loop:
    c = getr();
    if(c == '\n') {
        yyerror("newline in string");
        return EOF;
    }
    if(c != '\\') {
        if(c == e)
            c = EOF;
        return c;
    }
    // else c is '\\'
    c = getr();

    <<[[escchar()]] if hexadecimal character>>
    <<[[escchar()]] if octal character>>
    switch(c)
    {
    case '\n':	goto loop; // escaped newline

    case 'n':	return '\n';
    case 't':	return '\t';
    case 'b':	return '\b';
    case 'r':	return '\r';

    case 'f':	return '\f';
    case 'a':	return '\a';
    case 'v':	return '\v';
    }
    return c;
}
@
% this allows escaped newline! in character or string.

<<[[escchar()]] if octal character>>=
if(c >= '0' && c <= '7') {
    /*
     * note this is not ansi,
     * supposed to only accept 3 oct
     */
    i = 2;
    if(longflg)
        i = 8;
    l = c - '0';
    for(; i>0; i--) {
        c = getc();
        if(c >= '0' && c <= '7') {
            l = l*8 + c-'0';
            continue;
        }
        unget(c);
    }
    if(escflg)
        l |= ESC;
    return l;
}
@
% who uses this ESC thing? when use escchar() to lex strings.


<<function getr>>=
long
getr(void)
{
    int c, i;
    char str[UTFmax+1];
    Rune rune;


    c = getc();
    if(c < Runeself)
        return c;
    i = 0;
    str[i++] = c;

loop:
    c = getc();
    str[i++] = c;
    if(!fullrune(str, i))
        goto loop;
    c = chartorune(&rune, str);
    if(rune == Runeerror && c == 1) {
        nearln = lineno;
        diag(Z, "illegal rune in string");
        for(c=0; c<i; c++)
            print(" %.2x", *(uchar*)(str+c));
        print("\n");
    }
    return rune;
}
@

% specific to 5c!
<<[[escchar()]] if hexadecimal character>>=
if(c == 'x') {
    /*
     * note this is not ansi,
     * supposed to only accept 2 hex
     */
    i = 2;
    if(longflg)
        i = 6;
    l = 0;
    for(; i>0; i--) {
        c = getc();
        if(c >= '0' && c <= '9') {
            l = l*16 + c-'0';
            continue;
        }
        if(c >= 'a' && c <= 'f') {
            l = l*16 + c-'a' + 10;
            continue;
        }
        if(c >= 'A' && c <= 'F') {
            l = l*16 + c-'A' + 10;
            continue;
        }
        unget(c);
        break;
    }
    if(escflg)
        l |= ESC;
    return l;
}
@

\subsection{Unicode characters}

<<[[yylex()]] if L followed by unicode strings or character>>=
if(c != 'L')
    goto talph;

*cp++ = c;
c = GETC();
if(c == '\'') {
    /* L'x' */
    c = escchar('\'', true, false);
    if(c == EOF)
        c = '\'';
    c1 = escchar('\'', true, false);
    if(c1 != EOF) {
        yyerror("missing '");
        peekc = c1;
    }
    yylval.vval = convvtox(c, TRUNE);
    return LUCONST;
}
if(c == '"') {
    goto caselq;
}
@
% pass longflag true here! to escchar

\section{Strings}

<<constant ESC>>=
#define	ESC	(Runemask+1)		/* Rune flag: a literal byte */
@

<<[[yylex()]] locals>>=
Rune rune;
@

% string part 1
<<[[yylex()]] switch c cases>>=
case '"':
    strcpy(symb, "\"<string>\""); // for error reporting
    cp = alloc(0);
    c1 = 0;

    /* "..." */
    for(;;) {
        c = escchar('"', false, true);
        if(c == EOF)
            break;
        if(c & ESC) {
            cp = allocn(cp, c1, 1);
            cp[c1++] = c;
        } else {
            rune = c;
            c = runelen(rune);
            cp = allocn(cp, c1, c);
            runetochar(cp+c1, &rune);
            c1 += c;
        }
    }
    yylval.sval.l = c1;
    do {
        cp = allocn(cp, c1, 1);
        cp[c1++] = '\0';
    } while(c1 & MAXALIGN);
    yylval.sval.s = cp;
    return LSTRING;
@

\subsection{Unicode strings}
% long strings

<<[[yylex()]] switch c cases>>=
caselq:
    /* L"..." */
    strcpy(symb, "\"L<string>\"");
    cp = alloc(0);
    c1 = 0;
    for(;;) {
        c = escchar('"', true, false);
        if(c == EOF)
            break;
        cp = allocn(cp, c1, sizeof(TRune));
        *(TRune*)(cp + c1) = c;
        c1 += sizeof(TRune);
    }
    yylval.sval.l = c1;
    do {
        cp = allocn(cp, c1, sizeof(TRune));
        *(TRune*)(cp + c1) = 0;
        c1 += sizeof(TRune);
    } while(c1 & MAXALIGN);
    yylval.sval.s = cp;
    return LLSTRING;
@




\chapter{Preprocessing}

% 5c has a builtin cpp, like 5a.
% By integrating directly cpp in the parsing process,
% compilation runs faster because there is no fork at all! 

% 5c gives also the possiblity to call an external program,
% (e.g., /bin/cpp, which is a bit different
% than the builtin cpp), which is convenient for APE (and pcc wrapper).
% See also 5c -p

% cpp not part of C really, but fundamental. C would have died
% without cpp (quote stroustrup?).
% Allowed to extend C in powerful ways. Can even add closures
% with macros! or exceptions!

% cpp is very powerful, but tricky!
%http://blog.robertelder.org/7-weird-old-things-about-the-c-preprocessor/
%https://www.iar.com/support/resources/articles/advanced-preprocessor-tips-and-tricks/
%preprocessing algorithm: 
% http://www.spinellis.gr/blog/20060626/

% clone in ocaml:
%https://github.com/mjambon/cppo

% A bit of code duplication with the assembler. Some code was originally
% factorized, but in an ugly way. 
% I should try to better factorize at some point.

\section{[[mactab]] and [[domacro()]] dispatch}

<<[[yylex()]] switch c cases>>=
case '#':
    domacro();
    goto l0;
@
\l rename domacro, so dont need to explain that
\l domacro() means "do macroprocessing", not just macro definition/expansion
\l (It covers every cpp directives (include, ifdef, etc))


<<global mactab>>=
struct
{
    char	*macname;
    void	(*macf)(void);
} mactab[] =
{
    "ifdef",    nil,    /* macif(0) */
    "ifndef",   nil,    /* macif(1) */
    "else",     nil,    /* macif(2) */
    "endif",    macend,

    "include",  macinc,
    "line",     maclin,
    "define",   macdef,
    "undef",    macund,

    "pragma",   macprag,
    0
};
@
%ocaml: use ocamllex again, instead of adhoc lexing.

% dispatcher. 
% I should rename this func because it's not just about macro =>
% less: parse_and_dispatch_cpp_directive?
<<function domacro>>=
void
domacro(void)
{
    Sym *s;
    int i;

    s = getsym();
    <<[[domacro()]] set s to endif symbol if no symbol>>

    for(i=0; mactab[i].macname; i++)
        if(strcmp(s->name, mactab[i].macname) == 0) {
            if(mactab[i].macf)
                // dispatcher!
                (*mactab[i].macf)();
            else
                macif(i);
            return;
        }
    // else
    yyerror("unknown #: %s", s->name);
    macend();
}
@
% abuse getsym just to get an ident, don't have to go through lookup really.
%ocaml: dispatch by letting ocamllex do it

<<[[domacro()]] set s to endif symbol if no symbol>>=
if(s == S)
    s = slookup("endif");
@
%ocaml: dont do that, ugly


%\section{[[getsym()]]}
% mv with Keywords and identifier section?

<<function getsym>>=
Sym*
getsym(void)
{
    int c;
    char *cp;

    c = getnsc();
    if(!isalpha(c) && c != '_' && c < Runeself) {
        unget(c);
        return S;
    }
    // else isalpha() or '_'
    for(cp = symb;;) {
        if(cp <= symb+NSYMB-4)
            *cp++ = c;
        c = getc();
        if(isalnum(c) || c == '_' || c >= Runeself)
            continue;
        unget(c);
        break;
    }
    *cp = '\0';
    if(cp > symb+NSYMB-4)
        yyerror("symbol too large: %s", symb);
    return lookup();
}
@
% 4 = sizeof Rune?
%ocaml: no symbol too large message, dynamic alloc ftw

% so define, ifdef, etc are in the symbol table too.

% get non space character (really space, newline is not considered a space here)
<<function getnsc>>=
int
getnsc(void)
{
    int c;

    <<[[getnsc()]] peekc handling>>
    else
        c = GETC();

    for(;;) {
        if(c >= Runeself || !isspace(c))
            return c;
        if(c == '\n') {
            lineno++;
            return c;
        }
        // else, was a space, so continue
        c = GETC();
    }
    return -1; // unreachable
}
@
% why call GETC here? why not getc()? which handles already peekc?
% (in fact code in 5a does that, but here it handles runes too?)

% peek part 2
<<[[getnsc()]] peekc handling>>=
if(peekc != IGN) {
    c = peekc;
    peekc = IGN;
}
@
%ocaml: ugly to have this IGN thing everywhere. Better use ocamllex.


<<function unget>>=
void
unget(int c)
{

    peekc = c;
    if(c == '\n')
        lineno--;
}
@
%ocaml: again, ocamllex can do that, and this peekc thing must be repeated
% at many places. Duplication.


% (domacro | macinc  -> yyerror; <>) | (macund -> <>)
<<function macend>>=
void
macend(void)
{
    int c;

    for(;;) {
        c = getnsc();
        if(c < 0 || c == '\n')
            return;
    }
}
@
% I don't think c can be < 0 here.
% Or it means EOF?

% it just eats everything that is until the end of line.
% so could enter garbage stuff after a #ifdef, #line, etc.


%\section{[[getc()]], [[unget()]], [[getnsc()]]}

<<function getc>>=
int
getc(void)
{
    int c;

    <<[[getc()]] peekc handling>>
    else
        c = GETC();

    if(c == '\n')
        lineno++;
    if(c == EOF) {
        yyerror("End of file");
        errorexit();
    }
    return c;
}
@
%ocaml: so much code duplication again

<<[[getc()]] peekc handling>>=
if(peekc != IGN) {
    c = peekc;
    peekc = IGN;
}
@


\section{[[#include]]}
% and [[-I]]

\subsection{Include paths, [[-I]]}

%assembler: was using fixed array in assembler
<<global include>>=
// growing_array<string>
char**	include;
@
<<global ninclude>>=
int	ninclude;
@
<<global maxinclude>>=
int	maxinclude;
@
%ocaml: just use a list

% main -> <>(".") | main -> <>
<<function setinclude>>=
void
setinclude(char *p)
{
    int i;
    char *e, **np;

    while(*p != '\0') {
        e = strchr(p, ' ');
        if(e != nil)
            *e = '\0';

        // already there?
        for(i=0; i < ninclude; i++)
            if(strcmp(p, include[i]) == 0)
                break;
        // else
        if(i >= ninclude){
            <<[[setinclude()]] grow the array if necessary>>
            include[ninclude++] = p;
        }

        if(e == nil)
            break;
        p = e+1;
    }
}
@
\l why >= ninclude? = not enough?

% accept a list of includes if separated by space, so can
% process INCLUDE environment variable directly.

<<[[setinclude()]] grow the array if necessary>>=
// grow the array
if(i >= maxinclude){
    maxinclude += 20;
    np = alloc(maxinclude * sizeof *np);
    if(include != nil)
        memmove(np, include, (maxinclude - 20) * sizeof *np);
    include = np;
}
@


\subsection{Tracing origin and [[Hist]]}

% Once you include file, you can not just give a line number for
% an error. You need also the file in which the error occur.
% We have only seen lineno in Core Ds, but in fact global line number
% after preprocessing. Then need extra DS to map global line number
% to pair of file x local_line. Enter Hist.
% Store event, so can then reconstruct history of inclusion to
% report accurately errors.

<<struct Hist>>=
struct	Hist
{
    // option<ref_own<string> (None = nil = a ``pop'')
    char*	name;

    // global line of this Hist
    long	line;
    // 0 for #include, +n for #line, -1 for #pragma lib (ugly)
    long	offset;

    // Extra
    <<[[Hist]] extra fields>>
};
@
\t rename line -> global_line, and offset, local_line
%ocaml: use ADT to separate different kinds of "event": #include, #line, eof.


<<constant H>>=
#define	H	((Hist*)nil)
@

<<[[Hist]] extra fields>>=
Hist*	link;
@

<<global hist>>=
// list<ref_own<Hist>> (next = Hist.link)
Hist*	hist;
@
<<global ehist>>=
Hist*	ehist;
@




<<[[newfile()]] call linehist>>=
linehist(s, 0);
@
<<[[filbuf()]] when close file, call linehist>>=
linehist(0, 0);
@


<<function linehist>>=
void
linehist(char *f, int offset)
{
    Hist *h;

    <<[[linehist()]] possibly overwrite last line directive>>
    <<[[linehist()]] debug>>

    h = alloc(sizeof(Hist));
    h->name = f;
    h->line = lineno;
    h->offset = offset;

    // add_list(h, hist)
    h->link = H;
    if(ehist == H) {
        hist = h;
        ehist = h;
        return;
    }
    ehist->link = h;
    ehist = h;
}
@



\subsection{[[#include]]}

<<constant STRINGSZ>>=
#define	STRINGSZ	200
@

% LP split, and factorize code with gethunk
<<function macinc>>=
void
macinc(void)
{
    char str[STRINGSZ];
    char *hp = str;
    int i;
    fdt f = -1;
    <<[[macinc()]] other locals>>

    // lexing

    <<[[macinc()]] lexing the included filename>>

    // action

    <<[[macinc()]] find and store the included filename full path in [[symb]]>>

    c = strlen(symb) + 1; 

    // hp = malloc(c);
    while(c & 3)
        c++;
    while(nhunk < c)
        gethunk();
    hp = hunk;
    nhunk -= c;
    hunk += c;

    memcpy(hp, symb, c);

    newio();
    pushio();
    newfile(hp, f);
    return;

bad:
    unget(c);
    yyerror("syntax in #include");
    macend();
}
@
%old: 'for (hp = str;;) ...' but better initialize before
%pad: I reordered code to make it easier to replace hunk stuff by malloc()
\t use malloc
\t abuse c, could use other local [[n]]
%ocaml: I separate the lexing and action in different file by using an
% intermediate AST for the cpp directives

<<[[macinc()]] other locals>>=
int c0, c;
@
<<[[macinc()]] lexing the included filename>>=
c0 = getnsc();
if(c0 != '"') {
    c = c0;
    if(c0 != '<')
        goto bad;
    c0 = '>';
}
for(;;) {
    c = getc();
    if(c == c0)
        break;
    if(c == '\n')
        goto bad;
    *hp++ = c;
}
*hp = '\0';

c = getcom();
if(c != '\n')
    goto bad;
@

% first entry is setinclude(".") so accept only
% if not system file

<<[[macinc()]] find and store the included filename full path in [[symb]]>>=
for(i=0; i<ninclude; i++) {
    if(i == 0 && c0 == '>') // do not look in '.' for system headers
        continue;

    strcpy(symb, include[i]);
    strcat(symb, "/");
    if(strcmp(symb, "./") == 0)
        symb[0] = '\0';
    strcat(symb, str);

    f = open(symb, 0);
    if(f >= 0)
        break;

}
if(f < 0)
    strcpy(symb, str);
@

% the ./ special case will also allow to handle absolute path
% by not concatenating anything in front of it
% but what about overwriting of include[0] with dirname(file)?
% if run 5c xxx/include_absolute.c vs 5c include_absolute.c will get
%  different result?

<<function pushio>>=
void
pushio(void)
{
    Io *i;

    i = iostack;
    if(i == I) {
        yyerror("botch in pushio");
        errorexit();
    }
    i->p = fi.p;
    i->c = fi.c;
}
@
%ocaml: just use another lexbuf and keep old lexbuf in the stack

%\section{[[getcom()]]}
% mv with Comments section above?

% comment part 2
<<function getcom>>=
int
getcom(void)
{
    int c;

    for(;;) {
        c = getnsc();
        if(c != '/')
            break;
        // else c == '/'
        c = getc();
        <<[[getcom()]] if [[//]] comment>>
        if(c != '*')
            break;
        // else c == '*'
        <<[[getcom()]] when [[/*]] comment>>
        if(c == '\n')
            break;
    }
    return c;
}
@

<<[[getcom()]] if [[//]] comment>>=
if(c == '/') {
    while(c != '\n')
        c = getc();
    break;
}
@

<<[[getcom()]] when [[/*]] comment>>=
c = getc();
for(;;) {
    if(c == '*') {
        c = getc();
        if(c != '/')
            continue;
        c = getc();
        break;
    }
    if(c == '\n') {
        yyerror("comment across newline");
        break;
    }
    c = getc();
}
@

\section{[[#define]]}

\subsection{[[-D]]}

% no Dlist here, instead pass the defs to compile()

% cp can be just XX or also XX=YY
<<function dodefine>>=
void
dodefine(char *cp)
{
    Sym *s;
    char *p;
    long l;

    strcpy(symb, cp);
    p = strchr(symb, '=');
    if(p) {
        *p++ = '\0';
        s = lookup();
        l = strlen(p) + 2;	/* +1 null, +1 nargs */
      
        while(l & 3)
            l++;
        while(nhunk < l)
            gethunk();

        *hunk = '\0'; // 0 nargs
        strcpy(hunk+1, p);
        s->macro = hunk;

        hunk += l;
        nhunk -= l;

    } else {
        s = lookup();
        s->macro = "\0001";	/* \000 is nargs */
    }
    <<[[dodefine()]] debug>>
}
@
% use \000 to not have ambiguity with \01 
%ocaml: use ADT for macro def, with pair or record for nargs
% also pass pair in dodefine, not a single string
%ocaml: ugly hunk thing, just use Gc
\t use malloc

% LP split macro field of Sym
% factorize hunk/

\subsection{[[#define]]}

<<constant NARG>>=
#define	NARG	25
@
% use 'a'+i to mark arguments in the string, so can have
% only up to 25 arguments (size of alphabet)
%ocaml: more than 25 args, use #1, not #a


% wow, this is complicated
<<function macdef>>=
void
macdef(void)
{
    Sym *s;
    char *args[NARG]; // parameters
    // option<int> (None = -1), size of parameters
    int n;
    bool dots;
    char *base; // body
    <<[[macdef()]] other locals>>

    // lexing 
    <<[[macdef]] lexing the macro name, set [[s]]>>
    <<[[macdef]] lexing the parameters, set [[args]], [[n]], and [[dots]]>>
    <<[[macdef]] lexing the body, set [[base]]>>

    // action

    *base = n+1; // nargs (+1 to differentiate #define foo() from #define foo)
    if(dots)
        *base |= VARMAC;
    s->macro = base;
    <<[[macdef()]] debug>>
    return;

bad:
    if(s == S)
        yyerror("syntax in #define");
    else
        yyerror("syntax in #define: %s", s->name);
    macend();
}
@
%ocaml: again I separate the lexing from the action (thx to AST of directive)

<<constant VARMAC>>=
#define VARMAC 0x80
@
% variable arity macro (extension?)
%ocaml: a boolean in the record defining a macro





<<[[macdef]] lexing the macro name, set [[s]]>>=
s = getsym();
if(s == S)
    goto bad;
if(s->macro)
    yyerror("macro redefined: %s", s->name);
@


<<[[macdef()]] other locals>>=
int c;
Sym *a;
@
\t rename a to param (it is not an argument!)

<<[[macdef]] lexing the parameters, set [[args]], [[n]], and [[dots]]>>=
c = getc();
n = -1; // no parameter (which is different than 0 argument)
dots = false;

if(c == '(') {
    n++; // at least 0 parameters now
    c = getnsc();
    if(c != ')') {
        unget(c);
        for(;;) {
            a = getsymdots(&dots);
            if(a == S)
                goto bad;
            if(n >= NARG) {
                yyerror("too many arguments in #define: %s", s->name);
                goto bad;
            }
            args[n++] = a->name;

            c = getnsc();
            if(c == ')')
                break;
            if(c != ',' || dots)
                goto bad;
        }
    }
    c = getc();
}
if(isspace(c))
    if(c != '\n')
        c = getnsc();
@




<<function getsymdots>>=
Sym*
getsymdots(bool *dots)
{
    int c;
    Sym *s;

    s = getsym();
    if(s != S)
        return s;

    c = getnsc();
    if(c != '.'){
        unget(c);
        return S;
    }
    if(getc() != '.' || getc() != '.')
        yyerror("bad dots in macro");
    *dots = true;
    return slookup("__VA_ARGS__");
}
@
\t 5c of kencc does not seem to handle those




<<[[macdef()]] other locals>>=
//option<char> (None = 0, either ' or ")
int ischr; // quote character
int len;
@

<<[[macdef]] lexing the body, set [[base]]>>=
base = hunk;
len = 1;
ischr = 0;

for(;;) {
    <<[[macdef()]] when lexing the body, if identifier>>
    <<[[macdef()]] when lexing the body, if string or character or comment>>
    <<[[macdef()]] when lexing the body, if antislash outside a string>>
    if(c == '\n')
        break;
    <<[[macdef()]] when lexing the body, if sharp character, escape it>>

    // else, a regular character (space, punctuation, etc)
    base = allocn(base, len, 1);
    base[len++] = c;

    // GETC
    c = ((--fi.c < 0)? filbuf(): (*fi.p++ & 0xff));
    if(c == '\n')
        lineno++;
    if(c == -1) {
        yyerror("eof in a macro: %s", s->name);
        break;
    }
}
do {
    base = allocn(base, len, 1);
    base[len++] = '\0';
} while(len & 3);
@
\l why not call GETC? why duplicate filbuf stuff?



<<[[macdef()]] other locals>>=
char *np;
int i;
@

<<[[macdef()]] when lexing the body, if identifier>>=
// identifier
if(isalpha(c) || c == '_') {
    np = symb;
    *np++ = c;
    c = getc();
    while(isalnum(c) || c == '_') {
        *np++ = c;
        c = getc();
    }
    *np = '\0';

    for(i=0; i<n; i++)
        if(strcmp(symb, args[i]) == 0)
            break;
    if(i >= n) {
        i = strlen(symb);
        base = allocn(base, len, i);
        memcpy(base+len, symb, i);
        len += i;
        continue;
    }
    // else
    base = allocn(base, len, 2);
    base[len++] = '#';
    base[len++] = 'a' + i;
    continue;
}
@


% process also inside of strings! so can have 
% #define	assert(x)	do{ if(x) {} else _assert("x"); }while(false)
% no need for stringify concept. just use x

% string part 2 (but does not handle ''' escape I think here)
% character part 2
<<[[macdef()]] when lexing the body, if string or character or comment>>=
if(ischr){
    // inside a string or character
    if(c == '\\'){ 
        base = allocn(base, len, 1);
        base[len++] = c;
        c = getc();
    }else if(c == ischr)
        ischr = 0;
}else{
    // string or character
    if(c == '"' || c == '\''){
        base = allocn(base, len, 1);
        base[len++] = c;
        ischr = c;
        c = getc();
        continue;
    }
    <<[[macdef()]] if comment>>
}
@

% comment part3
<<[[macdef()]] if comment>>=
// comment
if(c == '/') {
    c = getc();
    if(c == '/'){
        // // comment
        c = getc();
        for(;;) {
            if(c == '\n')
                break;
            c = getc();
        }
        continue;
    }
    if(c == '*'){
        // /* comment
        c = getc();
        for(;;) {
            if(c == '*') {
                c = getc();
                if(c != '/')
                    continue;
                c = getc();
                break;
            }
            if(c == '\n') {
                yyerror("comment and newline in define: %s", s->name);
                break;
            }
            c = getc();
        }
        continue;
    }
    base = allocn(base, len, 1);
    base[len++] = '/';
    continue;
}
@
% again last case if not a comment but just a regular '/'

<<[[macdef()]] when lexing the body, if antislash outside a string>>=
// antislash outside a string
if(c == '\\') {
    c = getc();
    if(c == '\n') {
        c = getc();
        continue;
    }
    // else
    base = allocn(base, len, 1);
    base[len++] = '\\';
    continue;
}
@
% does not replace escaped newline by space here. skip both character

%dead:
%    // windows
%    else if(c == '\r') {
%        c = getc();
%        if(c == '\n') {
%            c = getc();
%            continue;
%        }
%    }


<<[[macdef()]] when lexing the body, if sharp character, escape it>>=
if(c == '#') // escape # by adding an extra #
  if(n > 0) {
    base = allocn(base, len, 1);
    base[len++] = c;
}
@
\t handle also foo##x as as ocaml/byterun/memory.h


\subsection{Macro Expansion}

<<[[yylex()]] in talph case, if macro symbol>>=
if(s->macro) {
    newio();
    cp = ionext->b;
    macexpand(s, cp);

    pushio();
    // push_list(ionext, iostack)
    ionext->link = iostack;
    iostack = ionext;

    fi.p = cp;
    fi.c = strlen(cp);

    <<[[yylex()]] in talph case, when macro symbol, peekc handling>>
    goto l0;
}
@

% peekc part 3
<<[[yylex()]] in talph case, when macro symbol, peekc handling>>=
if(peekc != IGN) {
    cp[fi.c++] = peekc;
    cp[fi.c] = '\0';
    peekc = IGN;
}
@
% argh, again

% note that can have recursive macro expansion! if expanded code
% contains itself some macros. Can even do recursive stuff?
% => push_depth check.


\subsubsection{[[macexpand()]]}

% wow, complicated too
<<function macexpand>>=
void
macexpand(Sym *s, char *b)
{
    int  nargs;
    bool dots;
    int  c;
    <<[[macexpand()]] other locals>>

    // if macro has no parameter
    if(*s->macro == '\0') {
        strcpy(b, s->macro+1);
        <<[[macexpand()]] debug macro expansion>>
        return;
    }
    // else, macro has parameters
    
    nargs = (char)(*s->macro & ~VARMAC) - 1;
    dots = *s->macro & VARMAC;

    c = getnsc();
    if(c != '(')
        goto bad;

    <<[[macexpand()]] parsing the arguments>>

    <<[[macexpand()]] substituting the arguments>>

    <<[[macexpand()]] debug macro expansion>>

    return;

bad:
    yyerror("syntax in macro expansion: %s", s->name);
    *b = '\0';
    return;

toobig:
    yyerror("too much text in macro expansion: %s", s->name);
    *b = '\0';
}
@


\subsubsection{Extracting the arguments}

%XXX
<<[[macexpand()]] other locals>>=
char buf[2000];
int l; // depth
char *arg[NARG]; // the arguments
int n;
char *cp, *ecp;
char *ob = b;
@
% ob = old buffer, ecp = end cp
% l = depth of parenthesis

<<[[macexpand()]] parsing the arguments>>=
n = 0;
c = getc();
if(c != ')') {
    unget(c);

    l = 0;
    cp = buf;
    ecp = cp + sizeof(buf)-4;
    arg[n++] = cp;

    for(;;) {
        if(cp >= ecp)
            goto toobig;
        c = getc();

        <<[[macexpand()]] when parsing the arguments, if string>>
        <<[[macexpand()]] when parsing the arguments, if character>>
        <<[[macexpand()]] when parsing the arguments, if comment>>
        if(l == 0) {
            if(c == ',') {
                if(n == nargs && dots) {
                    *cp++ = ',';
                    continue;
                }
                *cp++ = '\0';
                arg[n++] = cp;
                if(n > nargs)
                    break;
                continue;
            }
            if(c == ')')
                break;
        }
        if(c == '\n')
            c = ' ';
        *cp++ = c;
        if(c == '(')
            l++;
        if(c == ')')
            l--;
    }
    *cp = '\0';
}
if(n != nargs) {
    yyerror("argument mismatch expanding: %s", s->name);
    *b = '\0';
    return;
}
@
%ocaml: better error message than "<eof> End of file" when could not
% find a closing ')'

% string part 3
<<[[macexpand()]] when parsing the arguments, if string>>=
// string argument
if(c == '"')
    for(;;) {
        if(cp >= ecp)
            goto toobig;
        *cp++ = c;
        c = getc();
        if(c == '\\') {
            *cp++ = c;
            c = getc();
            continue;
        }
        if(c == '\n')
            goto bad;
        if(c == '"')
            break;
    }
@

% character part 3
<<[[macexpand()]] when parsing the arguments, if character>>=
// quote argument
if(c == '\'')
    for(;;) {
        if(cp >= ecp)
            goto toobig;
        *cp++ = c;
        c = getc();
        if(c == '\\') {
            *cp++ = c;
            c = getc();
            continue;
        }
        if(c == '\n')
            goto bad;
        if(c == '\'')
            break;
    }
@
% exactly the same, except look for different end character

<<[[macexpand()]] when parsing the arguments, if comment>>=
// comment
if(c == '/') {
    c = getc();
    switch(c) {
    case '*':
        for(;;) {
            c = getc();
            if(c == '*') {
                c = getc();
                if(c == '/')
                    break;
            }
        }
        *cp++ = ' '; // ???
        continue;
    case '/':
        while((c = getc()) != '\n')
            ;
        break;
    default:
        unget(c);
        c = '/';
    }
}
@
% remember that getc() handles lineno internally


% Subst arguments!

\subsubsection{Substituting the arguments}

<<[[macexpand()]] substituting the arguments>>=
cp = s->macro+1;
for(;;) {
    c = *cp++;
    if(c == '\n') // can happen?
        c = ' ';
    if(c != '#') {
        *b++ = c;
        if(c == '\0')
            break;
        continue;
    }
    // else, a #
    c = *cp++;
    if(c == '\0')
        goto bad;
    if(c == '#') { // # are escaped as double ##
        *b++ = c;
        continue;
    }
    // else, a #a to #z
    c -= 'a';
    if(c < 0 || c >= n)
        continue;
    strcpy(b, arg[c]);
    b += strlen(arg[c]);
}
*b = '\0';
@


%jarod:
%expliquer comment il reprsente la macro avec ses
%paramtres, comment ne pas perdre la correspondance des lignes quand
%on expand les macros

% macros are always on one line! (escaped newline),
% so when expand, it does not change the line number!

\section{[[#undef]]}

<<function macund>>=
void
macund(void)
{
    Sym *s;

    // lexing
    s = getsym();
    macend();
    if(s == S) {
        yyerror("syntax in #undef");
        return;
    }

    // action
    s->macro = nil;
}
@
% ugly to do macend here.

\section{[[#ifdef]]}

% 0 = ifdef, 1 = ifndef, 2 = else, see mactab and domacro()
<<function macif>>=
void
macif(int f)
{
    Sym *s;
    <<[[macif()]] other locals>>

    if(f == 2) // else
        goto skip;

    // lexing

    <<[[macif()]] lexing the symbol>>

    if((s->macro != nil) ^ f)
        return;
    // else

    // action
    <<[[macif()]] skipping text>>

bad:
    yyerror("syntax in #if(n)def");
    macend();
}
@


<<[[macif()]] lexing the symbol>>=
s = getsym();
if(s == S)
    goto bad;
if(getcom() != '\n')
    goto bad;
@


<<[[macif()]] other locals>>=
int c;
int l; // depth
bool bol; // beginning of line
@

<<[[macif()]] skipping text>>=
skip:
    bol = true;
    l = 0;

    for(;;) {
        c = getc();
        if(c != '#') {
            if(!isspace(c))
                bol = false;
            if(c == '\n')
                bol = true;
            continue;
        }
        // else a #xxx
        if(!bol)
            continue;

        s = getsym();
        if(s == S)
            continue;
        if(strcmp(s->name, "endif") == 0) {
            if(l) {
                l--;
                continue;
            }
            // else l == 0
            macend();
            return;
        }
        if(strcmp(s->name, "ifdef") == 0 || strcmp(s->name, "ifndef") == 0) {
            l++;
            continue;
        }
        if(l == 0 && f != 2 && strcmp(s->name, "else") == 0) {
            macend();
            return;
        }
    }
@
% does not manage comment? or string? so if have comment
% with inside a # in the first line, then it gets confused?

\section{[[#pragma]]}

<<function macprag>>=
void
macprag(void)
{
    Sym *s;
    <<[[macprag()]] other locals>>

    // lexing

    s = getsym();

    <<[[macprag()]] if pragma xxx>>
     else {
        while(getnsc() != '\n')
            ;
        return;
    }
}
@
\t use malloc
%ocaml: issue error message instead of silencing passing over unknown pragmas

%chunks: different pragma explained gradually.



\section{[[#line]]}

% useful for code generator, to report error to original file, not generated
% code, e.g. for lex&yacc

<<function maclin>>=
void
maclin(void)
{
    char *cp;
    int c;
    long n;

    // lexing

    n = getnsn();
    c = getc();
    if(n < 0)
        goto bad;

    for(;;) {
        if(c == ' ' || c == '\t') {
            c = getc();
            continue;
        }
        if(c == '"')
            break;
        if(c == '\n') {
            strcpy(symb, "<noname>");
            goto nn;
        }
        goto bad;
    }
    cp = symb;
    for(;;) {
        c = getc();
        if(c == '"')
            break;
        *cp++ = c;
    }
    *cp = '\0';
    c = getcom();
    if(c != '\n')
        goto bad;

    // action

nn:
    c = strlen(symb) + 1;
    while(c & 3)
        c++;

    while(nhunk < c)
        gethunk();
    cp = hunk;
    memcpy(hunk, symb, c);
    nhunk -= c;
    hunk += c;

    linehist(cp, n);
    return;

bad:
    unget(c);
    yyerror("syntax in #line");
    macend();
}
@
\t use malloc!

% could move with the other getxxx()
<<function getnsn>>=
long
getnsn(void)
{
    long n;
    int c;

    c = getnsc();
    if(c < '0' || c > '9')
        return -1;
    n = 0;
    while(c >= '0' && c <= '9') {
        n = n*10 + c-'0';
        c = getc();
    }
    unget(c);
    return n;
}
@










\chapter{Parsing}
% and naming (struct def resolution, typedef expansion, var use/def resolution
%  and checks, ...)

\section{Overview}

% I assume you understand Yacc! if not read the O'Reilly book on Lex&Yacc
%  or docs/doc/unix/yacc.pdf (or read \book{CompilerGenerator} :) )
%(compared to ocamlyacc can have actions in the middle, and they count
% as indexable elements for the $xxx ($1, $2, etc))

% In this chapter 5c will make heavy uses of symbol table! lots of
% things going on in addition to parsing.
% Moreover the parser returns an AST with lots of annotations, where lots of 
%  things are "resolved".


<<cc/cc.y>>=
%{
#include "cc.h"
%}
<<union yacc>>
<<token declarations>>
<<priority and associativity declarations>>
<<type declarations>>
%%
<<grammar>>
%%
@

% have seen union yacc and token declarations in Core Data structures
% chapter already.

% do not LP split, order matters!
<<priority and associativity declarations>>=
%left   ';'
%left   ','
%right  '=' LPE LME LMLE LDVE LMDE LRSHE LLSHE LANDE LXORE LORE
%right  '?' ':'

%left   LOROR
%left   LANDAND
%left   '|'
%left   '^'
%left   '&'
%left   LEQ LNE
%left   '<' '>' LLE LGE
%left   LLSH LRSH
%left   '+' '-'
%left   '*' '/' '%'

%right  LMM LPP LMG '.' '[' '('
@
% LXE = L X Equal, e.g. LPE = L Plus Equal (+=)
% LMM = L Minus Minus (--), LMG = L Minux Greater (->)
% the most important: * below + so * has priority.

<<[[union yacc]] other fields>>=
Node*   node;
@
% the union is for the $x which can be token in the lexer,
% but here they will correspond also to some nonterminals,
% and so we get nodes now in the union!

% see Node also in Core data structure section, with Z, left/right, new(), etc

<<type declarations>>=
%type   <node>  name tag 
%type   <node>  stmnt   block slist ulstmnt labels label forexpr
%type   <node>  expr    cexpr lexpr  xuexpr uexpr pexpr  elist  string lstring
%type   <node>  adecl   qual init ilist  adlist qlist  arglist
%type   <node>  xdecor xdecor2 edecor  abdecor abdecor1 abdecor2 abdecor3
%type   <node>  zexpr zelist zcexpr zarglist
@
% xdecl, pdecl are not here, because do side effects on symbol table.
% ltag is a sym. 
%note that name and tag are nodes here, convenient so can use diag($xx) on
% them. 

% in what follows a few conventions: 
% zxxx means zero or more e.g. zctlist means list of ctl 0 or more
% ct means class(storage) and type(part one)
% x means external
% u means unary, ul = unary or label
% ab means abstract
% cexpr means comma expr

% note that all terminal chars like ')' are actually Node* too
% so can pass them to warn() to get accurate error location

<<grammar>>=
prog:
  /* empty */
|   prog xdecl

<<declarator rules>>
<<statements rules>>
<<expressions rules>>
<<initializers rules>>
<<types, storage classes, qualifiers rules>>
<<names rules>>

<<extra grammar rules>>
<<ebnf grammar rules>>
@
%ocaml: return AST here, do not process AST of func during yyparse.

% prog does not return anything. Do things in function body,
% in initializers, or in gclean at the very end.


%FIGURE: show peigne of prog when have multiple xdecl and the derivation
% tree.



\section{Declarations and definitions, part one}

<<declarator rules>>=
<<external declarator rules>>
<<automatic declarator rules>>
<<parameter declarator rules>>
<<abstract declarator rules>>
<<structure element declarator rules>>
@

<<external declarator rules>>=
<<xdecl rule>>
<<xdlist rule>>
<<xdecor rule>>
<<xdecor2 rule>>
@
% "external" in the sense that define entities visible externally
% so globals, functions, structures.

% will use declaration for declaration and definition sometimes.

% will use declarator, important concept.

% An important thing, types are constructed in a complex way in C.
% Types have part one, part two A, part two B. And this has some
% implications on the AST building for the identifier and the type
% of the identifier.

\subsection{No-declarator declarations}

% I originally titled "nameless" declarations, but it actually 
% can define struct, in which case they have a name ... so better title I think
% even if it's very technical, but I have to.

% prog -> <>  (list)
<<xdecl rule>>=
/*
 * external declarator
 */
xdecl:
    zctlist ';'          { dodecl(xdecl, lastclass, lasttype, Z); }
@
%ocaml: I check if got struct or enum def here, otherwise
% no sense to have no identifier here. Also I returned an AST for those defs.

\t dodecl does something if node is Z? why pass xdecl anyway
\t  it will never be called no?

% This declaration covers actually definitions as
% can have complex struct/union def, or enum, inside the t or zct_list.
% recall that ct means class_storage and type, z means zero.
% ex: 
%  - int; (not very useful)
%  - extern;
%  - typedef; even typedef int;
%  - struct x; (forward decl, but used in kencc? seems unused)
%  - struct x { ... }; (ok something kinda useful).
%todo: effect of dodecl when pass Z? xdecl will not be called anyway ...
% just to set nearln? 


<<global lastclass>>=
// enum<storage_class>
char	lastclass;
@
%ugly? do that because C sucks? 
%ocaml: my parser_c.mly was also complicated when it come to decl handling,
% but I return a quadruple instead of using globals.

<<global lasttype>>=
Type*	lasttype;
@
%ocaml: use closures to handle the typ1 vs typ2 composition

% really lastype_partone.

<<ebnf grammar rules>>=
zctlist:
 /* empty */
    {
        lastclass = CXXX;
        lasttype = types[TINT];
    }
|   ctlist
@
%ocaml: return a pair instead of modifying globals. Also forbid
% empty declaration without any type or storage.

% so no type means int by default, as in 'x;' really means 'int x;'
% can even have ';' which is not very useful (and equivalent to 'int;')

<<extra grammar rules>>=
ctlist:
    types
    {
        lastclass = $1.c;
        lasttype = $1.t;
    }
@
% it's not really 'types', it's types_and_storage really. will see types later.
%todo: why not continue that? so instead of lasttype and lastclass
% we could just do $1.t and $1.c?

%codegen: no code gen, but define schemas and offsets that
% expr generation will then use, so can have more complex
% globals or data access than arrays indexes.

\subsection{Declarator-based declarations}

%http://blog.robertelder.org/building-a-c-compiler-type-system-the-formidable-declarator/

% It's not just for globals, it can also define
% typedefs, and even struct and globals at the same time.
% also can declare prototypes.
% hmm I love C. It makes it so easy to present ...

<<xdecl rule>>=
|   zctlist xdlist ';'
@
% With xdlist can now have global declarations. It also
% includes the types part2, what are decorations (2a and 2b) around 
% the identifier.
% xd means external decl.
% ex:
%  - int x; (more useful)
%  - int x,y,z; (list)
%  - struct x { ... } y;
%  - int foo[4]; (array)
%  - int foo(int x); (prototype forward or external decl)
%  - typedef int x;

<<xdlist rule>>=
xdlist:
    xdecor  { dodecl(xdecl, lastclass, lasttype, $1); }
|   xdlist ',' xdlist
@
%$
%ocaml: return AST, do not resolve class, types, and more here.

% will see xdecor below, essentially a (decorated) name.
% x decorated with more type info (left pointer, right array and func).
% but for now xdecor =~ identifier, which is ONAME.

% We do not return an AST here. We modify instead the symbol table.

% dodecl() modify especially the lastdcltype global (and symbol table via
%  its callback)
% its main role is to possibly compose the part one (type t) and two (node n)
% of the type that is spreaded around the identifier (or abstract declarator).
% note that the node n is Z or a symbol with also the type part two info,
% so either ONAME or OIND of ONAME, etc.
% dodecl() also adjusts the parameter node, to extract the ONAME that
% can be deep, and then doing so construct the type of this ONAME
% on its way.
<<function dodecl>>=
Node*
dodecl(void (*f)(int,Type*,Sym*), int class, Type *t, Node *n)
{
    <<[[dodecl()]] locals>>

    nearln = lineno;
    <<[[dodecl()]] other initializations>>

loop:
    if(n != Z)
     switch(n->op) {
     // can adjust t using information from node n (type information part2)
     <<[[dodecl()]] switch node kind cases>>
     default:
         diag(n, "unknown declarator: %O", n->op);
         break;
     }

    lastdcltype = t;
    return n;
}
@
\l when can have unknown declarator message? impossible?

% why set nearln? we will construct some new nodes? yes, can do
% during revertdcl() for volatiles hidden instructions USED(&local_volatile)
% why return n?

%less: so for the no-declarator based declarations dodecl
% does actually nothing? it just sets lastdcltype
% with lastype, but is this useful?

<<global lastdcl>>=
Type*	lastdcltype;
@
%old: was call lastdcl, but confusing
%what this is useful for? this is the complete type!

%codegen: will generate some ADATA and AGLOBL


\subsection{Entity declarations, the declarator}
% also use for definitions

<<xdecor rule>>=
xdecor:
    xdecor2
@
% will contain the before identifier, type part 2a (pointers)

<<xdecor2 rule>>=
xdecor2:
    tag
|   '(' xdecor ')'             { $$ = $2;   }
@
% will contain the after identifier, type part 2b (array and functions)
%$

% xdecor -> xdecor2 -> tag
<<names rules>>=
tag:
    ltag
    {
        $$ = new(ONAME, Z, Z);
        $$->sym = $1;
        <<tag rule, set other fields to name node>>
    }
@
%$
% similar to name rule but here it's for decl/defs, 'name' rule is for use.
% tag! but it's really ident.
% the type will be adjusted in dodecl as goes up the chain.
%the symbol has a type? $1->type? yes if the symbol was forward declared
% before, as in  int x; ...  int x = 1;
% in which case we want to make sure those types are compatible.
% this is probably the same for the class.
%ocaml: forbid those multiple declarations? maybe not, needed for
% prototypes anyway.
%ocaml: ugly to do offset related stuff during parsing, and also tying
%todo: but same for offset?? it can have one already?

<<tag rule, set other fields to name node>>=
$$->type = $1->type;
$$->etype = ($1->type != T) ? $1->type->etype : TVOID;
$$->class = $1->class;

$$->xoffset = $1->offset;
@
%$
%dead?
\l Not sure we need here to propagate type info from sym to node.
% Those fields will be overwritten by xdecl.

% note that when symbol saw for the first time, call syminit,
% so scope will be 0.


<<type declarations>>=
%type   <sym>   ltag
@

<<names rules>>=
ltag:
    LNAME
|   LTYPE
@
% no grammar ambiguity?? so can have typedef int x; ...; x x;  
% declarations without pb?
\l why tag and ltag?

<<[[dodecl()]] locals>>=
Sym *s;
@

% dodecl(..., node n != Z) -> <>
<<[[dodecl()]] switch node kind cases>>=
case ONAME:
    <<[[dodecl()]] in ONAME case, break if empty callback>>
    s = n->sym;

    // callback! should set s->type, s->class, etc.
    (*f)(class, t, s);

    <<[[dodecl()]] case ONAME, if local static variable>>
    <<[[dodecl()]] case ONAME, other initializations>>

    // propagate symbol information to node
    n->sym = s; //?? dead?
    n->type = s->type;
    n->etype = (s->type != T) ? s->type->etype : TVOID;
    n->class = s->class;
    n->xoffset = s->offset;

    <<[[dodecl()]] debug declaration>>
    <<[[dodecl()]] case ONAME, debugging support>>

    s->varlineno = lineno;
    break;
@
% set varlineno! link from symbol to definition location! nice.

% Very important to propagate from Symbol to node! Because
% Once we backtrack and revertdcl, this information will be lost!
% Hmm, but anyway we are in dodecl, do we care about the node?
% for doinit?

% dodecl(<>, ..., node n != Z) -> <>
<<function xdecl>>=
void
xdecl(int class, Type *t, Sym *s)
{
    long o = 0; // offset

    // adjusting class (and possibly o for CEXREG)
    switch(class) {
    <<[[xdecl()]] switch class cases>>
    }
    <<[[xdecl()]] sanity check class after switch class>>
    <<[[xdecl()]] sanity check type after switch class>>
    <<[[xdecl()]] merge type declarations>>

    s->type = t;
    s->class = class;
    s->block = 0;
    s->offset = o;
}
@
% block 0, because global scope! 
% tmerge because the symbol may have been previously forward declared?
% so need to check if consistent. See typechecking section?

% for xdecl, it is global, so offset is 0. foo+0(SB) to acccess a global.
% for adecl it will be different.

% now this symbol has a type!

% need forward declarations to support mutual recursive functions
%alt: let rec ... and ... as in OCaml or Tiger
% they are also useful for foreign function interface! can write
% prototype of assembly functions (e.g., syscalls)
%alt: extern "C" in C++, 'external' in ocaml

\subsection{Function definitions}

<<global firstdcl>>=
Decl*	firstdcl;
@
% save of dclstack, to have a pointer for function scope,
% so for instance can add labels at the outer scope of the function
% (because we don't want revertdecl() to undo nested labels)
%ocaml: use only for labels, so can use a special scope in env just for that

<<global thisfn>>=
Type*	thisfntype;
@
%old: was called thisfn, but confusing.
%ocaml: replace global by extra field in typechecking environment

%this is useful to annotate the type of RETURN



<<xdecl rule>>=
|   zctlist xdecor
    {
        lastdcltype = T; //dead??
        <<xdecl rule, initializations before processing a function>>
        dodecl(xdecl, lastclass, lasttype, $2);
        <<xdecl rule, sanity check lastdcltype is a function type>>
        thisfntype = lastdcltype;
        markdcl();
        firstdcl = dclstack;
        argmark($2, 0);
    }
    pdecl
    {
        argmark($2, 1);
    }
    block
    {
        Node *n;
        n = revertdcl();
        <<xdecl rule, adjust block body with possible hidden generated nodes>>
        <<xdecl rule, debug function body>>
        if(!debug['a'] && !debug['Z'])
            codgen($6, $2); // !!!!!!!!!!!!!!!!!!!!!
    }
@
%$
% markdcl and reverdcl are for the parameters too! not just for the block
% (the 'block' does not do its own markdcl and reverdcl).
% argmark will add in scope the parameters of the function. It will
%  walk through the params and add in scope.
%ocaml: I do also a generic new_scope/pop_scope for block, so I have
% a separate scope just for the parameters

% markdcl(), revertdcl(), see next section

<<xdecl rule, sanity check lastdcltype is a function type>>=
if(lastdcltype == T || lastdcltype->etype != TFUNC) {
    diag($2, "not a function");
    lastdcltype = types[TFUNC];
}
@
%$
%ocaml: same error, but stop there, no implicit declaration

%corner: note that 5c resolve typedefs during parsing, so
% see in plan9-ml/compiler/tests/function_typedef.c weird case
% that is allowed by 5c (and not clang!)

% lots of things happen in xdecor actually as the parameters
% will be there.

%codegen: will be a TEXT



\section{Statements}
% block, labels, stmts


% seen 'block' for func def, block is a list of stmnt
<<statements rules>>=
block:
 '{' slist '}'
    {
        $$ = invert($2);
        if($$ == Z)
            $$ = new(OLIST, Z, Z);
    }

slist:
  /* empty */      { $$ = Z;    }
|   slist adecl    { $$ = new(OLIST, $1, $2); }
|   slist stmnt    { $$ = new(OLIST, $1, $2); }
@
%$
% adecl! for locals
%ocaml: I do the new_scope/pop_env here, so I factorize code related
% to hidden nodes

% Note that no reverdecl or markdecl here. done in caller!
% See also ulstmnt and Blocks below.

% invert in place
<<function invert>>=
Node*
invert(Node *n)
{
    Node *i;

    if(n == Z || n->op != OLIST)
        return n;
    i = n;
    for(n = n->left; n != Z; n = n->left) {
        if(n->op != OLIST)
            break;
        i->left = n->right;
        n->right = i;
        i = n;
    }
    i->left = n;
    return i;
}
@
%ocaml: List.rev


% can have labels before stmts
<<statements rules>>=
stmnt:
    ulstmnt
|   labels ulstmnt { $$ = new(OLIST, $1, $2); }
|   error ';'      { $$ = Z; }
@
% hmm could have a OLABELS no?

% ul = no label? unlabeled?
<<statements rules>>=
<<ulstmnt rule>>
<<label rule>>
@

<<ulstmnt rule>>=
ulstmnt:
    zcexpr ';'
@
% zero or commaexpr, will see in next chapter expressions

<<ebnf grammar rules>>=
labels:
    label
|   labels label  { $$ = new(OLIST, $1, $2); }
@
%ocaml: return nest of Label directly

% why not OLABEL instead?



%codegen: most of the stmts will turns into AB and conditional
% jmps (e.g. ABNE). There are many idioms in the use of AB/ABxxx
% that can be captured in a few general control constructs.

\subsection{Blocks}

% have seen block rule above used for example for function definitions.
% a single stmt can also be a block! nested language.

<<ulstmnt rule>>=
|   {
        markdcl();
    }
    block
    {
        Node *n;
        n = revertdcl();
        <<ulstmt rule, adjust block body with possible hidden generated nodes>>
        else
            $$ = $2;
    }
@
%$
% have explained revertdcl() in Declaration section in core DS.
%old: originally in comment //  if($2 != Z) $$ = new(OLIST, $2, $$);


%codegen: mostly sequence of instructions. Nested so can
% have different scope, but it's a typechecking issue more than
% codegeneration. The assembly just provides object/file-scope
% (via the static <> suffix), and does not provide any typechecking
% (even use of external entities are found out only at link time).

\subsection{Conditionals}

<<statement nodes>>=
OIF,
@
%ocaml: OIF(l=expr, r=OLIST(then, else))

<<ulstmnt rule>>=
|   LIF '(' cexpr ')' stmnt
    {
        $$ = new(OIF, $3, new(OLIST, $5, Z));
        if($5 == Z)
            warn($3, "empty if body");
    }
|   LIF '(' cexpr ')' stmnt LELSE stmnt
    {
        $$ = new(OIF, $3, new(OLIST, $5, $7));
        if($5 == Z)
            warn($3, "empty if body");
        if($7 == Z)
            warn($3, "empty else body");
    }
@
%$
% cexpr means  comma expr
% OLIST here could be an OPAIR

\subsection{Loops}

<<statement nodes>>=
OWHILE,
ODWHILE,
OFOR,
@

<<ulstmnt rule>>=
|   LWHILE '(' cexpr ')' stmnt          { $$ = new(OWHILE, $3, $5); }
|   LDO stmnt LWHILE '(' cexpr ')' ';'  { $$ = new(ODWHILE, $5, $2); }
@

<<ulstmnt rule>>=
|   { 
        markdcl(); 
    } 
    LFOR '(' forexpr ';' zcexpr ';' zcexpr ')' stmnt
    {
        Node *n;
        n = revertdcl();
        <<ulstmt rule, adjust forexpr with possible hidden generated nodes>>
        $$ = new(OFOR, new(OLIST, $6, new(OLIST, $4, $8)), $10);
    }
@
% markdcl() because forexpr allow local declaration ext, as in C++
%ocaml: OFOR(l=OLIST(forcond, OLIST(forinit, forend)), r=body)

% C extension for(int i; ... ?) hence the markdcl, for scope.
<<statements rules>>=
forexpr:
    zcexpr
|   ctlist adlist { $$ = $2; }
@
%$

\subsection{Control flow jumps}

<<statement nodes>>=
ORETURN,

OBREAK,
OCONTINUE,
@

<<ulstmnt rule>>=
|   LRETURN zcexpr ';'
    {
        $$ = new(ORETURN, $2, Z);
        $$->type = thisfntype->link;
    }
@
%$
%useful thisfntype.
% This will be used later when typechecking statements.
%ocaml: do that in typechecking later

<<ulstmnt rule>>=
|   LBREAK ';'     { $$ = new(OBREAK, Z, Z); }
|   LCONTINUE ';'  { $$ = new(OCONTINUE, Z, Z); }
@
%$


\subsection{Labels and goto}
% kinda control flow jump too

% seen labels rule before in Statements section header.

<<statement nodes>>=
OLABEL,
OGOTO,
@

<<label rule>>=
|   LNAME ':'       { $$ = new(OLABEL, dcllabel($1, true), Z); }
@
%$
% what? it's in label rule? with case and default??
% actually then often do  case x: talpha: ...
% could attach sym here instead of in OXXX linked to OLABEL;
%  use extra node for the unused check.

<<ulstmnt rule>>=
|   LGOTO ltag ';' { $$ = new(OGOTO, dcllabel($2, false), Z); }
@
%$
% ltag = LNAME | LTYPE, see later

% remember special case in new() about OGOTO. l is result
% of dcllabel which will be a fake OXXX node


<<[[Sym]] label value fields>>=
Node*	label;
@
% can then access pc via s->label->pc? meh, node attached
%  here seems to be an OXXX so not really useful.
% Another namespace!


% flag is true for label definition context, false for use (e.g. in goto)
<<function dcllabel>>=
//@Scheck: used by cc.y
Node* dcllabel(Sym *s, bool defcontext)
{
    Decl *d;
    Decl d1;
    Node *n;

    n = s->label;
    <<[[dcllabel()]] if n not null, mark node as declared or used>>
    // else, new label

    d = push();
    d->sym = s;
    d->val = DLABEL;

    //pop_stack(dclstack) (we add the label to the function scope instead)
    dclstack = d->link;
    //add_list(d, firstdcl)
    d1 = *firstdcl;
    *firstdcl = *d;
    *d = d1;
    firstdcl->link = d;
    firstdcl = d;

    n = new(OXXX, Z, Z);
    n->sym = s;
    <<[[dcllabel()]] when new label, set def and use fields>>
    s->label = n;

    <<[[dcllabel()]] debug declaration>>
    return n;
}
@
% The first occurence of a label (def or use) adds it to the symbol table.
%  So can do goto of a label defined later. Its label field will be set.
% We use firstdcl because we want to add label at function scope,
%  not in nested latest scope, because revertdcl() should
%  not revert nested labels.
%less: means a local var can hide a nested label? I think so :)
%  hmmm maybe not as namespace different and so label will still
%  be in the field of the symbol of the local var.

%codegen: really match assembly here, labels and AB.


\subsection{Switch}
% kinda conditional too

<<statement nodes>>=
OSWITCH,
OCASE, // for default too, in which case Node.left is null
@

<<ulstmnt rule>>=
|   LSWITCH '(' cexpr ')' stmnt
    {
       <<ulstmt rule, SWITCH case, adjust cexpr node>>
        $$ = new(OSWITCH, $3, $5);
    }
@


% note that 'labels' with an 's' before, so can have case 1: case 2: ...

<<label rule>>=
label:
    LCASE expr ':'  { $$ = new(OCASE, $2, Z); }
|   LDEFAULT ':'    { $$ = new(OCASE, Z, Z); }
@
%$
%ocaml: OCASE(l=option(expr), r=null)



\section{Expressions}

<<expressions rules>>=
<<expr rule>>
<<xuexpr rule>>
<<uexpr rule>>
<<pexpr rule>>
@
% xu = extended unary(cast), u = unary, p = primary, c = comma

<<expr rule>>=
expr:
    xuexpr
@

<<xuexpr rule>>=
xuexpr:
    uexpr
@

<<uexpr rule>>=
uexpr:
    pexpr
@

<<pexpr rule>>=
pexpr:
    '(' cexpr ')' { $$ = $2; }
@
%$

<<expressions rules>>=
cexpr:
    expr
|   cexpr ',' cexpr { $$ = new(OCOMMA, $1, $3); }
@
%$

<<expression nodes>>=
OCOMMA,
@







% e.g. in array def context, can have an int or nothing, TODO rename zlexpr?
<<expressions rules>>=
zexpr:
  /* empty */ { $$ = Z; }
|   lexpr
@


<<expressions rules>>=
lexpr:
    expr
    {
        $$ = new(OCAST, $1, Z);
        $$->type = types[TLONG];
    }
@
%$
% long expr. zexpr is a longexpr because empty means 0 which is a long.
% extra node added!




<<ebnf grammar rules>>=
zcexpr:
  /* empty */ { $$ = Z; }
|   cexpr
@
% this time for a zero it means really None.




% I used to have a "Binary expr", "Unary expr", "Primary expr" 
% but it makes more sense to structure around features
% the user can understand rather than grammar specificities

%codegen: assembly have arith/pointers/... but only restricted
% forms. Here more general formulas of arbitrary depth.
% will be decomposed in a serie of AADD, AAND, etc. And
% use of temporary registers and AMOVW.
% Also assembly handles only a few types (byte, half word, word,
% with some unsigned variants, float), here we can have also
% vlong, complex structures, etc.

\subsection{Numeric constants}

<<expression nodes>>=
OCONST,
@
% also for float
% the const keyword is actually a GCONSTNT, and LCONST

%codegen: same in assembly, $intvalue.

\subsubsection{Integers}

% the grammar section builds the AST node and assign the types.

<<[[Node]] value fields>>=
vlong	vconst; /* non fp const */ // for OCONST
@
%// abused in switch?
% could be put in a union with fpconst and rstring (but not cstring)
% take vlong to store the maximum possible value.


<<pexpr rule>>=
|   LCONST
    {
        $$ = new(OCONST, Z, Z);
        $$->type = types[TINT];
        $$->vconst = $1;
        $$->cstring = strdup(symb);
    }
|   LLCONST
    {
        $$ = new(OCONST, Z, Z);
        $$->type = types[TLONG];
        $$->vconst = $1;
        $$->cstring = strdup(symb);
    }
|   LVLCONST
    {
        $$ = new(OCONST, Z, Z);
        $$->type = types[TVLONG];
        $$->vconst = $1;
        $$->cstring = strdup(symb);
    }
@
%$
%ocaml: factorize by having size type in token constructor

<<pexpr rule>>=
|   LUCONST
    {
        $$ = new(OCONST, Z, Z);
        $$->type = types[TUINT];
        $$->vconst = $1;
        $$->cstring = strdup(symb);
    }
|   LULCONST
    {
        $$ = new(OCONST, Z, Z);
        $$->type = types[TULONG];
        $$->vconst = $1;
        $$->cstring = strdup(symb);
    }
|   LUVLCONST
    {
        $$ = new(OCONST, Z, Z);
        $$->type = types[TUVLONG];
        $$->vconst = $1;
        $$->cstring = strdup(symb);
    }
@
%$
%ocaml: factorize by having size type in token constructor and 
% by factorizing the signed vs unsigned

% but cast here to signed vlong. Pb?

\subsubsection{Floats}

<<[[Node]] value fields>>=
double	fconst;		/* fp constant */ // for OCONST
@
% again use the biggest type so can accomodate also smaller float.

% take double to store the maximum possible value.

<<pexpr rule>>=
|   LFCONST
    {
        $$ = new(OCONST, Z, Z);
        $$->type = types[TFLOAT];
        $$->fconst = $1;
        $$->cstring = strdup(symb);
    }
|   LDCONST
    {
        $$ = new(OCONST, Z, Z);
        $$->type = types[TDOUBLE];
        $$->fconst = $1;
        $$->cstring = strdup(symb);
    }
@
%$
%ocaml: factorize by having size type in token constructor

\subsection{String constants}
% char constant? unsugard in yylex?

%codegen: same in assembly except not limited to 8bytes,
% and also handle unicode here.

\subsubsection{ASCII strings}
% classic '\0' terminated "C strings"

<<expression nodes>>=
OSTRING,
@

<<pexpr rule>>=
|   string
|   lstring
@

<<[[Node]] value fields>>=
char*	cstring;	/* character string */ // for OSTRING (and OCONST)
@
% could be put in a union, except it uses both vconst and cstring
% at the same time.
% used also to remember the original string representation of the integer.

<<expressions rules>>=
string:
    LSTRING
    {
        $$ = new(OSTRING, Z, Z);
        $$->type = typ(TARRAY, types[TCHAR]);
        $$->etype = TARRAY;
        $$->type->width = $1.l + 1;
        $$->cstring = $1.s;
        <<string rule, set sym and class for OSTRING>>
    }
|   string LSTRING
    {
        char *s;
        int n;

        n = $1->type->width - 1;
        s = alloc(n+$2.l+MAXALIGN);

        memcpy(s, $1->cstring, n);
        memcpy(s+n, $2.s, $2.l);
        s[n+$2.l] = '\0';

        $$ = $1;
        $$->type->width += $2.l;
        $$->cstring = s;
    }
@
%less: C extension to concatenate strings. could be aspectized
% or even removed.
% do not free the previous one?


\subsubsection{Unicode strings}
% long strings

<<expression nodes>>=
OLSTRING,
@

<<[[Node]] value fields>>=
TRune*	rstring;	/* rune string */ // for OLSTRING
@

%in cc.h, which should include the u.h before?
%typedef	Rune	TRune;	/* target system type */

<<constant TRUNE>>=
/* adapt size of Rune to target system's size */
TRUNE = sizeof(TRune)==4? TUINT: TUSHORT,
@


% unicode
<<expressions rules>>=
lstring:
    LLSTRING
    {
        $$ = new(OLSTRING, Z, Z);
        $$->type = typ(TARRAY, types[TRUNE]);
        $$->etype = TARRAY;
        $$->type->width = $1.l + sizeof(TRune);
        $$->rstring = (TRune*)$1.s;
        <<string rule, set sym and class for OSTRING>>
    }
|   lstring LLSTRING
    {
        char *s;
        int n;

        n = $1->type->width - sizeof(TRune);
        s = alloc(n+$2.l+MAXALIGN);

        memcpy(s, $1->rstring, n);
        memcpy(s+n, $2.s, $2.l);
        *(TRune*)(s+n+$2.l) = 0;

        $$ = $1;
        $$->type->width += $2.l;
        $$->rstring = (TRune*)s;
    }
@
%$


\subsection{Entity uses}
% important!

<<pexpr rule>>=
|   name
@

% use (def of entities use 'tag' instead, in xdecor2, not 'name')
<<names rules>>=
name:
    LNAME
    {
        $$ = new(ONAME, Z, Z);
        <<name rule, if local static variable>>
        $$->sym = $1;

        // propagate symbol information to node
        $$->type = $1->type;
        $$->etype = ($1->type != T) ? $1->type->etype : TVOID;
        $$->xoffset = $1->offset;
        $$->class = $1->class;
        <<name rule, LNAME case, adjust more fields>>
    }
@
%ocaml: forbid implicit declarations of functions so can warn early.

% similar to tag rule, but no LTYPE here!
%$
% no warning if not defined here. This id done in tcomo() instead.
% We let the caller decide, so when in a funcall, it is just declared 
% implicitely


% Very important to propagate information from symbol to node!
% Because when revertdcl, information will be lost and codegen
% would have to redo this scoping resolution thing.

% Can have type that escapes? if struct Foo x; is a local
% and struct Foo defined later, then when backtrack to toplevel,
% The type annotation in the AST for x is wrong? point to what
% symbol?

% This covers also enum constants!

%codegen: name(SB), or name+-offset(FP) for params and locals
% A C symbol is an assembly symbol! It is kept as is.

\subsection{Arithmetic expressions}

% Similar to Machine.nw/Assembler.nw in some sense,
% except can compose them to form complex tree formulas.
% and also have DIV here even though the machine does not!

% also + is now overloaded! works for many integers (char/short/int/long/vlong)
% and many floats (double/float), so no need to use AADD, AADDF, AADDD

<<expression nodes>>=
OADD,
OSUB,

OMUL,
ODIV,
OMOD,
@

<<expr rule>>=
|   expr '+' expr { $$ = new(OADD, $1, $3); }
|   expr '-' expr { $$ = new(OSUB, $1, $3); }
|   expr '*' expr { $$ = new(OMUL, $1, $3); }
|   expr '/' expr { $$ = new(ODIV, $1, $3); }
|   expr '%' expr { $$ = new(OMOD, $1, $3); }
@


<<expression nodes>>=
OPOS,
ONEG,
@

<<uexpr rule>>=
|   '+' xuexpr { $$ = new(OPOS, $2, Z); }
|   '-' xuexpr { $$ = new(ONEG, $2, Z); }
@

%codegen: similar asm instructions (e.g. AADD, AAND)


%\subsection{Bit?? expressions}

<<expression nodes>>=
OAND,
OOR,
OXOR,

OASHL,
OASHR,
@
% OAS ... rename? so less confusing with the other assign nodes?

% arithmetic left. Will see later how converted to logical left
% of unsigned type.

% bitwise and


<<expr rule>>=
|   expr '&' expr  { $$ = new(OAND, $1, $3); }
|   expr '^' expr  { $$ = new(OXOR, $1, $3); }
|   expr '|' expr  { $$ = new(OOR, $1, $3); }

|   expr LRSH expr { $$ = new(OASHR, $1, $3); }
|   expr LLSH expr { $$ = new(OASHL, $1, $3); }
@




\subsection{Boolean expressions}

<<expression nodes>>=
OANDAND,
OOROR,
@

<<expr rule>>=
|   expr LANDAND expr { $$ = new(OANDAND, $1, $3); }
|   expr LOROR expr   { $$ = new(OOROR, $1, $3); }
@

% also a short-circuit operator! statement related.

<<expression nodes>>=
ONOT,
OCOM,
@
%OCOM?

<<uexpr rule>>=
|   '!' xuexpr { $$ = new(ONOT, $2, Z); }
|   '~' xuexpr { $$ = new(OCOM, $2, Z); }
@

% ~ is not really boolean expr

%\subsection{Relational? expressions}

<<expression nodes>>=
OEQ,
ONE,

OLT,
OGT,
OLE,
OGE,
@
% there are some more opcodes that are generated after
% parsing mimicing OLT/... but explicitly unsigned (OLO/OHS/...)

<<expr rule>>=
|   expr LEQ expr  { $$ = new(OEQ, $1, $3); }
|   expr LNE expr  { $$ = new(ONE, $1, $3); }

|   expr '<' expr  { $$ = new(OLT, $1, $3); }
|   expr '>' expr  { $$ = new(OGT, $1, $3); }
|   expr LLE expr  { $$ = new(OLE, $1, $3); }
|   expr LGE expr  { $$ = new(OGE, $1, $3); }
@

%codegen: similar asm instructions (e.g. AAND again?).
% OEQ?



\subsection{Assignments}
% which really should be instructions, not expressions, grrr


<<expression nodes>>=
OAS,
@

<<expr rule>>=
|   expr '=' expr  { $$ = new(OAS, $1, $3); }
@


% sugar
<<expression nodes>>=
OASADD,
OASSUB,

OASMUL,
OASMOD,
OASDIV,

OASAND,
OASOR,
OASXOR,

OASASHL,
OASASHR,
@

<<expr rule>>=
|   expr LPE expr  { $$ = new(OASADD, $1, $3); }
|   expr LME expr  { $$ = new(OASSUB, $1, $3); }
|   expr LMLE expr { $$ = new(OASMUL, $1, $3); }
|   expr LDVE expr { $$ = new(OASDIV, $1, $3); }
|   expr LMDE expr { $$ = new(OASMOD, $1, $3); }
|   expr LANDE expr { $$ = new(OASAND, $1, $3); }
|   expr LXORE expr { $$ = new(OASXOR, $1, $3); }
|   expr LORE expr  { $$ = new(OASOR, $1, $3); }
|   expr LLSHE expr { $$ = new(OASASHL, $1, $3); }
|   expr LRSHE expr { $$ = new(OASASHR, $1, $3); }
@
%$
%less: why not removing the sugar instead? and decompose
% in an OADD and OAS? easier to optimize?



%codegen: =~ AMOV in Assembler.nw

\subsection{Pointers}
% C power!

<<expression nodes>>=
OIND, // for uses (dereference) and also declarations
OADDR,
@

<<uexpr rule>>=
|   '*' xuexpr { $$ = new(OIND, $2, Z); }
|   '&' xuexpr { $$ = new(OADDR, $2, Z); }
@

%codegen: asm:  $name, (register) or name(SB).


\subsection{Array accesses}

% unsugar x[y] as *(x+y) :)
<<pexpr rule>>=
|   pexpr '[' cexpr ']' { $$ = new(OIND, new(OADD, $1, $3), Z); }
@

%codegen: operand to other op with offset  xxx+i(SB), e.g.
% x[y] = 1 -> AMOVW $1, R1; AMOVW R1, x+y(SB) (which will expand
% into a store low level ARM instruction).

% note that will be converted again in tcomo() for pointer arithmetic
% so ADD (x, 1) may become a ADD (x, 4).
% Also if x is an array type, it gets converted in a OADDR before
% to get the pointer.

\subsection{Field accesses}

<<expression nodes>>=
ODOT,
@

% unsugar x->y as (*x).y
<<pexpr rule>>=
|   pexpr '.' ltag
    {
        $$ = new(ODOT, $1, Z);
        $$->sym = $3;
    }
|   pexpr LMG ltag
    {
        $$ = new(ODOT, new(OIND, $1, Z), Z);
        $$->sym = $3;
    }
@
% unsugar x->y to (*x).y

%codegen: more structured arrays! with different size, but ultimately
% will be transformed in array access (pointer + offset).


\subsection{Function calls}

<<expression nodes>>=
OFUNC, // used for uses (calls) but also defs (and decls)
@
% should split? have a OCALL?

% funcall!
<<pexpr rule>>=
|   pexpr '(' zelist ')'
    {
        $$ = new(OFUNC, $1, Z);
        <<pexpr rule, implicit declaration of unknown function>>
        $$->right = invert($3);
    }
@

<<ebnf grammar rules>>=
zelist:
  /* empty */ { $$ = Z; }
|   elist
@

<<expressions rules>>=
elist:
    expr
|   elist ',' elist { $$ = new(OLIST, $1, $3); }
@
% elist really? should be expr no? or have a %left for ',' ?


<<pexpr rule, implicit declaration of unknown function>>=
if(($1->op == ONAME) && ($1->type == T))
    dodecl(xdecl, CXXX, types[TINT], $$);
@
%less: should be a flag honestly ...
% no forward decl of entity name, so assumes return an int? ugly.
%ocaml: forbid it. warn about undeclared symbol. cleaner
% than this implicit prototype declaration where return an int.
\t should not be a TFUNC declaration here?

% this is why later when do tmerge get a warning
% (and get varlineno for this symbol! at this place)

%codegen: ABL, but more convenient in C :) automatic
% hiding of FP and offsets, use symbolic names instead,
% and have typechecking of args vs params.


\subsection{Cast}

<<expression nodes>>=
OCAST,
@

<<xuexpr rule>>=
|   '(' tlist abdecor ')' xuexpr
    {
        $$ = new(OCAST, $5, Z);
        dodecl(NODECL, CXXX, $2, $3);
        $$->type = lastdcltype;
        $$->xcast = true;
    }
@
%$
% extended unary expr =~ cast expr
% dodecl to have lastdcltype, to reconstruct the whole type
% from the tlist (part one) and abdecor (part two).
%less: what will be the ONAME for abdecor? it's abstract
% so it should have no name ...

<<[[Node]] origin tracking fields>>=
bool 	xcast;
@
% explicit cast, to remember, as we will add some implicit
% cast during the typechecking/annotating/expliciting phase.

%codegen: a typechecking issue first, but then some conversions too?


<<constant NODECL>>=
#define	NODECL	((void(*)(int, Type*, Sym*)) nil)
@
% no decl
%less: rename NO_DECL_CALLBACK?

<<[[dodecl()]] in ONAME case, break if empty callback>>=
if(f == NODECL)
    break;
@

% still wants the visiting part of dodecl than unfolds that OIND, etc
% so will generate in lastdcltype a TIND.

\subsection{Ternary expressions}

<<expression nodes>>=
OCOND,
@
%ocaml: OCOND(l=cond,r=OLIST(then, else))
% could be an OPAIR here.

<<expr rule>>=
|   expr '?' cexpr ':' expr { $$ = new(OCOND, $1, new(OLIST, $3, $5)); }
@
%$

%codegen: ABxx and AMOV

\subsection{Prefix/postfix}

<<expression nodes>>=
OPREDEC,
OPREINC,
@

<<uexpr rule>>=
|   LPP xuexpr { $$ = new(OPREINC, $2, Z); }
|   LMM xuexpr { $$ = new(OPREDEC, $2, Z); }
@


<<expression nodes>>=
OPOSTINC,
OPOSTDEC,
@

<<pexpr rule>>=
|   pexpr LPP { $$ = new(OPOSTINC, $1, Z); }
|   pexpr LMM { $$ = new(OPOSTDEC, $1, Z); }
@

%less: why not unsugar? because it's more complicated than
% just do x = x+1; because this affectation must also be done
% at the right place when it's inside a complex expression
% (it must be moved out of the expression and put as a sequence
% before, or after)

%codegen: sequence ; and AMOV, AADD.


%old:\subsection{Primary expressions}
% call, array access, field access, sizeof, 

\subsection{[[sizeof()]]}

<<expression nodes>>=
OSIZE,
@

<<pexpr rule>>=
|   LSIZEOF '(' tlist abdecor ')'
    {
        $$ = new(OSIZE, Z, Z);
        dodecl(NODECL, CXXX, $3, $4);
        $$->type = lastdcltype;
    }
@
%ugly: abuse dodecl

<<uexpr rule>>=
|   LSIZEOF uexpr { $$ = new(OSIZE, $2, Z); }
@
%$
% not super useful this one, could be removed

%codegen: constant computation, to reflect schema of data.

\section{Initializers and designators}

% this is a sort of C extension, because you could do
% int x;  and the later in main 'x = ...' (especially if you
% support Struct and Array constructor in expressions).


<<xdlist rule>>=
|   xdecor
    {
        $1 = dodecl(xdecl, lastclass, lasttype, $1);
    }
    '=' init
    {
        doinit($1->sym, $1->type, 0L, $4);
    }
@
%$
%0L because call recursively and accumulator? seems not because
% global vs local, because passes also 0L in adlist rule.
% doinit is now in code generation part
\t why make dodecl return something? anyway it is the same thing than last param

<<declaration nodes>>=
OINIT,
@
% but just for list! otherwise it's really OASI.


<<initializers rules>>=
init:
    expr
|   '{' ilist '}' { $$ = new(OINIT, invert($2), Z); }
@
%$

<<initializers rules>>=
ilist:
    qlist
|   init
|   qlist init { $$ = new(OLIST, $1, $2); }

qlist:
    init ','
|   qlist init ','  { $$ = new(OLIST, $1, $2); }
|   qual
|   qlist qual      { $$ = new(OLIST, $1, $2); }
@
%$
% why not OLIST also for the first one?

<<declaration nodes>>=
OELEM,  // field designator
@
% for regular access it's TDOT, could have been marged
%less: rename OINITFIELD?

<<expression nodes>>=
OARRAY, // used for uses (designator) and declarations
@
%less: could be renamed no? OINITARRAY
%note that for regular uses that are not designator it does not
% use OARRAY but instead unsugar in OIND and OADD


<<initializers rules>>=
qual:
    '[' lexpr ']' { $$ = new(OARRAY, $2, Z); }
|   '.' ltag
    {
        $$ = new(OELEM, Z, Z);
        $$->sym = $2;
    }
|   qual '='
@
%$
% alternate syntax qual =




<<global initlist>>=
Node*	initlist;
@

<<function doinit>>=
Node*
doinit(Sym *s, Type *t, long o, Node *a)
{
    Node *n;

    <<[[doinit()]] sanity check t>>
    <<[[doinit()]] possibly adjust class>>
    n = initlist;

    if(a->op == OINIT)
        a = a->left;
    initlist = a;

    a = init1(s, t, o, 0);
    <<[[doinit()]] sanity check initlist after init1>>
    initlist = n;

    return a;
}
@
% init1 in code generation chapter! Do lots of things during parsing.
% return value used???

<<[[doinit()]] sanity check t>>=
if(t == T)
    return Z;
@
\t when this happens?


\section{Types and storage classes}
% Complex.

%context:
% cast:  '(' tlist abdecor ')' xuexpr
% sizeof: |   LSIZEOF '(' tlist abdecor ')'
% arguments: |   tlist abdecor
% adecl? and will see later also for adecl probably
% xdecl: zctlist, ... zctlist: ctlist ... ctlist: types

% tlist because can have a list like unsigned int, or long long
%ocaml: impose order, so no need for those set operations

% ugly in C but types decomposed in two parts, 
% before identifier, and around identifier (after and also before).

<<enum type_kind_bis>>=
enum type_kind_bis {
    // ----------------------------------------------------------------------
    // Type (see separate Type_kind)
    // ----------------------------------------------------------------------

    // ----------------------------------------------------------------------
    // Class storage (temporary, see CAUTO/CEXTERN/... for final storage)
    // ----------------------------------------------------------------------
    <<[[Type_kind_bis]] storage cases>>

    // ----------------------------------------------------------------------
    // Qualifiers (aka garbage) (temporary, see GCONSTNT/GVOLATILE)
    // ----------------------------------------------------------------------
    <<[[Type_kind_bis]] qualifier cases>>

    // ----------------------------------------------------------------------
    // Signs (temporary, see TUINT/TULONG/... for final types)
    // ----------------------------------------------------------------------
    <<[[Type_kind_bis]] sign cases>>

    // ----------------------------------------------------------------------
    // Misc
    // ----------------------------------------------------------------------
    <<[[Type_kind_bis]] misc cases>>

    NALLTYPES,

    <<constant TRUNE>>
};
@
% see also qnames[] for debugging
%note: now that we splitted fron enum type_kind, does it still work with
% enum<bxxx>?
%dead:TFILE
%ocaml: separate storage, qualifier, and type in grammar rules so
% no need for those set union operations

% enum Bxxx is used mainly in the grammar
% and is a 32 (long) bits bitset of the types above.
%  (use of 1L, not just 1)
% bitset, because need to aggregate keywords to form the final thing.
% to do 'unsigned char' -> TUCHAR
% pre: Txxx must have less than 32 cases (seems to have 30 cases right now,
%  tight)
%  1L => long => long enum
<<enum bxxx>>=
enum Bxxx
{
    BCHAR		= 1L<<TCHAR,
    BUCHAR		= 1L<<TUCHAR,
    BSHORT		= 1L<<TSHORT,
    BUSHORT		= 1L<<TUSHORT,
    BINT		= 1L<<TINT,
    BUINT		= 1L<<TUINT,
    BLONG		= 1L<<TLONG,
    BULONG		= 1L<<TULONG,
    BVLONG		= 1L<<TVLONG,
    BUVLONG		= 1L<<TUVLONG,
    BFLOAT		= 1L<<TFLOAT,
    BDOUBLE		= 1L<<TDOUBLE,

    BIND		= 1L<<TIND,
    BFUNC		= 1L<<TFUNC,
    BARRAY		= 1L<<TARRAY,
    BVOID		= 1L<<TVOID,
    BSTRUCT		= 1L<<TSTRUCT,
    BUNION		= 1L<<TUNION,
    BENUM		= 1L<<TENUM,

    BDOT		= 1L<<TDOT,

    BCONSTNT	= 1L<<TCONSTNT,
    BVOLATILE	= 1L<<TVOLATILE,

    BUNSIGNED	= 1L<<TUNSIGNED,
    BSIGNED		= 1L<<TSIGNED,

    BAUTO		= 1L<<TAUTO,
    BEXTERN		= 1L<<TEXTERN,
    BSTATIC		= 1L<<TSTATIC,
    BTYPEDEF	= 1L<<TTYPEDEF,
    BREGISTER	= 1L<<TREGISTER,
    <<[[Bxxx]] cases>>

    <<[[Bxxx]] constants>>
};
@
%dead? BARRAY?

% this will be used also later for type compatiblity checks,
% see the tcompat taxxx globals.

% see also enum<storage_class> and enum<type_kind>


% bitset<enum<bxxx> > actually
<<type declarations>>=
%type   <lval>  tname cname gname
@

<<[[union yacc]] other fields>>=
long    lval; //bitset<enum<Bxxx> >
@
% for the bitset, but could probably abuse vval.
%less: rename?

<<types, storage classes, qualifiers rules>>=
<<tname rule>>
<<cname rule>>
<<gname rule>>
@


<<type declarations>>=
%type   <lval>   gcname   gctname
@

<<types, storage classes, qualifiers rules>>=
gctname:
    tname
|   gname
|   cname

gcname:
    gname
|   cname
@
%ocaml: can simplify and remove all that




<<[[union yacc]] other fields>>=
Type*   type;
@

<<type declarations>>=
%type   <type> tlist
@

% arguments to sizeof and cast (we expect here no storage)
% tlist because can have a list like unsigned int, or long long
<<types, storage classes, qualifiers rules>>=
tlist:
    types
    {
        $$ = $1.t;
        if($1.c != CXXX)
            diag(Z, "illegal combination of class 4: %s", cnames[$1.c]);
    }
@
%ocaml: I rewrote grammar to disallow this by construction (but then
% error message is not as good?)
%less: hmmm could have done via grammar no?

% do not allow to specify storage class



% type and class
<<[[union yacc]] other fields>>=
struct
{
    Type*   t;
    // option<enum<Storage_class> >, None = CXXX
    byte   c;
} tycl;
@


<<type declarations>>=
%type   <tycl>  types
@



<<type declarations>>=
%type   <lval>  gctnlist gcnlist zgnlist
@


<<types, storage classes, qualifiers rules>>=
gctnlist:
    gctname
|   gctnlist gctname { $$ = typebitor($1, $2); }
@

<<types, storage classes, qualifiers rules>>=
gcnlist:
    gcname
|   gcnlist gcname { $$ = typebitor($1, $2); }
@


<<function typebitor>>=
//@Scheck: used by cc.y
long typebitor(long a, long b)
{
    long c;

    c = a | b;
    if(a & b)
        if((a & b) == BLONG)
            c |= BVLONG;		/* long long => vlong */
        else
            warn(Z, "once is enough: %Q", a & b);
    return c;
}
@
%ocaml: do via grammar, allow long long in basic type, rest is syntax error

\subsection{Basic types}
% types part1

<<types, storage classes, qualifiers rules>>=
<<types rule>>
@

<<types rule>>=
types:
   tname
    {
        $$.c = CXXX;
        $$.t = simplet($1);
    }
@
%$

<<tname rule>>=
tname:  /* type words */
    LCHAR     { $$ = BCHAR; }
|   LSHORT    { $$ = BSHORT; }
|   LINT      { $$ = BINT; }
|   LLONG     { $$ = BLONG; }

|   LFLOAT    { $$ = BFLOAT; }
|   LDOUBLE   { $$ = BDOUBLE; }

|   LVOID     { $$ = BVOID; }
@



<<[[Type_kind_bis]] sign cases>>=
TUNSIGNED,
TSIGNED,
@
% temporary, actually the type have the TINT vs TUINT

<<tname rule>>=
|   LSIGNED   { $$ = BSIGNED; }
|   LUNSIGNED { $$ = BUNSIGNED; }
@
%ocaml: can simplify



<<types rule>>=
|   gcnlist
    {
        $$.t = simplet($1);
        $$.c = simplec($1);
        $$.t = garbt($$.t, $1);
    }
|   tname gctnlist
    {
        $$.t = simplet(typebitor($1, $2));
        $$.c = simplec($2);
        $$.t = garbt($$.t, $2);
    }
|   gcnlist tname
    {
        $$.t = simplet($2);
        $$.c = simplec($1);
        $$.t = garbt($$.t, $1);
    }
|   gcnlist tname gctnlist
    {
        $$.t = simplet(typebitor($2, $3));
        $$.c = simplec($1|$3);
        $$.t = garbt($$.t, $1|$3);
    }
@
%ocaml: can simplify




<<[[Bxxx]] constants>>=
/* these can be overloaded with complex types */
BCLASS		= BAUTO|BEXTERN|BSTATIC|BTYPEDEF|BTYPESTR|BREGISTER,
@

<<[[Bxxx]] constants>>=
BGARB		= BCONSTNT|BVOLATILE,
@

<<function simplet>>=
Type*
simplet(long b)
{

    b &= ~BCLASS & ~BGARB;

    switch(b) {
    case BCHAR:
    case BCHAR|BSIGNED:
        return types[TCHAR];

    case BCHAR|BUNSIGNED:
        return types[TUCHAR];

    case BSHORT:
    case BSHORT|BINT:
    case BSHORT|BSIGNED:
    case BSHORT|BINT|BSIGNED:
        return types[TSHORT];

    case BUNSIGNED|BSHORT:
    case BUNSIGNED|BSHORT|BINT:
        return types[TUSHORT];

    case 0:
    case BINT:
    case BINT|BSIGNED:
    case BSIGNED:
        return types[TINT];

    case BUNSIGNED:
    case BUNSIGNED|BINT:
        return types[TUINT];

    case BLONG:
    case BLONG|BINT:
    case BLONG|BSIGNED:
    case BLONG|BINT|BSIGNED:
        return types[TLONG];

    case BUNSIGNED|BLONG:
    case BUNSIGNED|BLONG|BINT:
        return types[TULONG];

    case BVLONG|BLONG:
    case BVLONG|BLONG|BINT:
    case BVLONG|BLONG|BSIGNED:
    case BVLONG|BLONG|BINT|BSIGNED:
        return types[TVLONG];

    case BVLONG|BLONG|BUNSIGNED:
    case BVLONG|BLONG|BINT|BUNSIGNED:
        return types[TUVLONG];

    case BFLOAT:
        return types[TFLOAT];

    case BDOUBLE:
    case BDOUBLE|BLONG:
    case BFLOAT|BLONG:
        return types[TDOUBLE];

    case BVOID:
        return types[TVOID];
    }

    diag(Z, "illegal combination of types %Q", b);
    return types[TINT];
}
@
%ocaml: illegal combination done via syntax error instead.
% I do not support many of those combinations. Anyway, who uses that?

% simplet return pointers to shared basic types.
% If then you add a qualifier, then this type will be copied
% before being adjusted.



<<types, storage classes, qualifiers rules>>=
zgnlist:
 /* empty */       { $$ = 0; }
|   zgnlist gname  { $$ = typebitor($1, $2); }
@



\subsection{Storage classes}


<<[[Type_kind_bis]] storage cases>>=
TAUTO	= NTYPE,
TEXTERN,
TSTATIC,

TTYPEDEF, // ugly, not really a storage class
TREGISTER,
@
% temporary, the real one are the CAUTO, CEXTERN, etc
% TAUTO = NTYPE so different number so when do 1<<TAUTO, not in conflict
%  with 1<<TINT

% Keep after Txxx because used for Bxxx and need to be different bits.

<<cname rule>>=
cname:  /* class words */
    LAUTO     { $$ = BAUTO; }
|   LSTATIC   { $$ = BSTATIC; }
|   LEXTERN   { $$ = BEXTERN; }
|   LREGISTER { $$ = BREGISTER; }
|   LINLINE   { $$ = 0; }
@


<<function simplec>>=
//@Scheck: used by cc.y
int simplec(long b)
{

    b &= BCLASS;
    switch(b) {
    case 0: 
    case BAUTO:
        return CAUTO;
    case BEXTERN:
        return CEXTERN;
    case BSTATIC:
        return CSTATIC;

    <<[[simplec()]] cases>>
    }
    diag(Z, "illegal combination of classes %Q", b);
    return CXXX;
}
@
%ocaml: again disallow combination via grammar

% ugly that typedef if considered a storage class ...

% A few places where 5c adjusts the storage, because
% can declare the same thing multiple times (in header file and then
% separately in C file).
% See checking chapter.

<<[[simplec()]] cases>>=
// skipping register
case BREGISTER:
    return CXXX;
case BAUTO|BREGISTER:
    return CAUTO;
@
%ocaml: forbid them

\subsection{Qualifiers}

<<[[Type_kind_bis]] qualifier cases>>=
TCONSTNT,
TVOLATILE,
@
% temporary, the real one are the GCONSTNT, GVOLATILE, etc

% garbage?
<<gname rule>>=
gname:  /* garbage words */
    LCONSTNT  { $$ = BCONSTNT; }
|   LVOLATILE { $$ = BVOLATILE; }
|   LRESTRICT { $$ = 0; }
@
% restrict keyword not handled

<<function garbt>>=
//@Scheck: used by cc.y
Type* garbt(Type *t, long b)
{
    Type *t1;

    if(b & BGARB) {
        t1 = copytyp(t);
        t1->garb = simpleg(b);
        return t1;
    }
    return t;
}
@

<<function copytyp>>=
Type*
copytyp(Type *t)
{
    Type *nt;

    nt = typ(TXXX, T); // could just do alloc(sizeof(Type))
    *nt = *t;
    return nt;
}
@
%ocaml: just share

% when do you need to copy? it's not a deep copy.
% If want deep copy then will need to also call copytyp recursively
% on Type.link.
% typ will copy. actually they will share their down and link field!
%  not a deep copy.




<<function simpleg>>=
int
simpleg(long b)
{

    b &= BGARB;
    switch(b) {
    case BCONSTNT:           return GCONSTNT;
    case BVOLATILE:          return GVOLATILE;
    case BVOLATILE|BCONSTNT: return GCONSTNT|GVOLATILE;
    }
    return GXXX;
}
@


\subsection{Structures and unions}

% Not so simple when need to handle scope.

%http://blog.robertelder.org/magical-world-of-structs-typedefs-scoping/

% There is OSTRUCT and OUNION but it's for struct constructor!
% Here we will return directly a Type pointer.

% Explained Sym.suetag before, and Type.tag (and Type.sym for fields)
% And Sym.sueblock. And Type.link.

\subsubsection{Complex types}
% also for enum

<<types rule>>=
|  complex
    {
        $$.c = CXXX;
        $$.t = $1;
    }
|  complex gctnlist
    {
        $$.t = $1;
        $$.c = simplec($2);
        $$.t = garbt($$.t, $2);
        if($2 & ~BCLASS & ~BGARB)
            diag(Z, "duplicate types given: %T and %Q", $1, $2);
    }
|   gcnlist complex zgnlist
    {
        $$.t = $2;
        $$.c = simplec($1);
        $$.t = garbt($$.t, $1|$3);
    }
@
%$
%ocaml: again disallow by grammar

<<types, storage classes, qualifiers rules>>=
<<complex rule>>
@

<<type declarations>>=
%type   <type>  complex
@
% return directly an expanded resolved type!


\subsubsection{Structure/union uses}
% or forward decl?

%use
<<complex rule>>=
complex:
    LSTRUCT ltag
    {
        dotag($2, TSTRUCT, 0);
        $$ = $2->suetag;
    }
|   LUNION ltag
    {
        dotag($2, TUNION, 0);
        $$ = $2->suetag;
    }
@

% 0 for None. It means dotag will not create a new sym for it.
% If the tag was already defined, then we reuse the tag, otherwise
% we introduce a new incomplete type (that will be filled later) and
% return it.

%how represent the type of foo given this decl 'struct X { int x; } foo;'?
% TSTRUCT(link = {TINT, sym = x; down = nil?}, tag = sym X)
       



% called also for enums
<<function dotag>>=
//@Scheck: used by cc.y
Type* dotag(Sym *s, int et, int bn)
{
    <<[[dotag()]] locals>>

    <<[[dotag()]] if bn not zero and bn not sueblock>>
    // never defined before, return a newly allocated (but incomplete) Type
    if(s->suetag == T) {
        s->suetag = typ(et, T); // link is null for now
        s->sueblock = autobn;
    }
    <<[[dotag()]] sanity check tag redeclaration>>
    if(s->suetag->tag == S)
        s->suetag->tag = s;

    return s->suetag;
}
@
% It allocates a new typ here!! so scope of Sym does not matter.
% Once struct defined in the same scope, suetag will point to something
% more complete, and this is what we return!!
% This is what will be store in Node.type for the decl, def, uses, etc.
\t why not set tag of new suetag directly? when can it be S?

% so Struct Foo x; will have its Node.type pointing to a Type that
% will be filled later.

%corner:
% Code above is very subtle. Lots of corner cases of C.
% if struct was never defined before, and just use 'struct X', 
% then this struct will allocate a new type in the current scope.
% This means this type must be defined in the same scope!
% So if do
% void foo() { struct X foo; ... }
% then you must define struct X in this function! You can not define
% it at the toplevel later.
% Hence the use of struct X;  at the toplevel!!! Just to forward decl
% a structure that will be defined later.



% cant use for TSTRUCT and TUNION
<<[[dotag()]] sanity check tag redeclaration>>=
if(s->suetag->etype != et)
    diag(Z, "tag used for more than one type: %s", s->name);
@
%less: mv later in Checking?
%ocaml: do in separate phase; also give better location, not end
% of struct but start! (like in clang)


\subsubsection{Structure/union definitions}

% defs
<<complex rule>>=
|   LSTRUCT ltag
    {
        dotag($2, TSTRUCT, autobn);
    }
    sbody
    {
        $$ = $2->suetag;
        if($$->link != T)
            diag(Z, "redeclare tag: %s", $2->name);
        $$->link = $4;
        <<complex rule, when parse a structure definition, align the struct>>
    }
|   LUNION ltag
    {
        dotag($2, TUNION, autobn);
    }
    sbody
    {
        $$ = $2->suetag;
        if($$->link != T)
            diag(Z, "redeclare tag: %s", $2->name);
        $$->link = $4;
        <<complex rule, when parse a structure definition, align the struct>>
    }
@
%$
%ocaml: do check in check.ml, not parsing, and give better error message
% a la clang

% could factorize in a su: TSTRUCT { $$ = TSTRUCT } TUNION ...

% set link!!!

% sualign() explained later in code gen chapter, alignment section


% bn is autobn for actual struct defs.

<<[[dotag()]] locals>>=
Decl *d;
@
<<[[dotag()]] if bn not zero and bn not sueblock>>=
if(bn != 0 && bn != s->sueblock) {
    d = push();
    d->sym = s;
    d->val = DSUE;
    // save old values
    d->type = s->suetag;
    d->block = s->sueblock;
    // prepare for new value
    s->suetag = T;
}
@
% declaration of new struct! because different block!




<<global taggen>>=
//@Scheck: used by cc.y
int	taggen;
@
%ocaml: gensym() like

% anon defs
<<complex rule>>=
|   LSTRUCT sbody
    {
        taggen++;
        sprint(symb, "_%d_", taggen);
        $$ = dotag(lookup(), TSTRUCT, autobn);
        $$->link = $2;
        <<complex rule, when parse a structure definition, align the struct>>
    }
|   LUNION sbody
    {
        taggen++;
        sprint(symb, "_%d_", taggen);
        $$ = dotag(lookup(), TUNION, autobn);
        $$->link = $2;
        <<complex rule, when parse a structure definition, align the struct>>
    }
@




\subsubsection{Fields}
% Complex too.

<<type declarations>>=
%type   <type> sbody
@
%todo: sure? seems more tyty than type


<<global strf>>=
// list<ref_own<Type>> (next = Type.down, last = strl)
Type*	strf;
@
% structure first?
%ocaml: return list directly, no need go through a global that you then
% to save/restore

<<global strl>>=
// ref<Type> (head = strf)
Type*	strl;
@
% structure last?


<<[[union yacc]] other fields>>=
struct
{
    Type*   t1; // save strf
    Type*   t2; // save strl
    Type*   t3; // save lastype
    uchar   c;  // save lastclass
} tyty;
@
%ocaml: I do not use globals in the grammar, I return
% pairs or functions, so no need to save/restore globals.






<<types, storage classes, qualifiers rules>>=
sbody:
    '{'
    {
        // save
        $<tyty>$.t1 = strf;
        $<tyty>$.t2 = strl;
        $<tyty>$.t3 = lasttype;
        $<tyty>$.c = lastclass;

        strf = T;
        strl = T;
        <<sbody rule, initializations before parsing the fields>>
        lastclass = CXXX;
        lasttype = T;
    }
    edecl 
    '}'
    {
        $$ = strf;

        // restore
        strf = $<tyty>2.t1;
        strl = $<tyty>2.t2;
        lasttype = $<tyty>2.t3;
        lastclass = $<tyty>2.c;
    }

@
%$
%ocaml: ugly, return list directly


<<structure element declarator rules>>=
/*
 * structure element declarator
 */
edecl:
    tlist
    {
        lasttype = $1;
    }
    zedlist ';'
|   edecl tlist
    {
        lasttype = $2;
    }
    zedlist ';'

<<zedlist rule>>

edlist:
    edecor            { dodecl(edecl, CXXX, lasttype, $1); }
|   edlist ',' edlist
@
%$

% zedlist is for C kencc extension. See Advanced topics.
% For now just think of zedlist as edlist.

% pass CXXX here cos field declaration do not have storage (but they 
% can have bits)

<<structure element declarator rules>>=
<<edecor rule>>
@


<<edecor rule>>=
edecor:
    xdecor
    {
        <<edecor rule, set fields after parsed a field declarator>>
    }
@
% also stuff with bit fields in Advanced topics chapter


% dodecl(<>) -> <>
<<function edecl>>=
//@Scheck: used by cc.y
void edecl(int c, Type *t, Sym *s)
{
    Type *t1;

    <<[[edecl()]] if unnamed structure element>>
    else
        if(c != CXXX)
            diag(Z, "structure element cannot have class: %s", s->name);

    t1 = t;
    t = copytyp(t1);
    t->sym = s;
    t->down = T;

    <<[[edecl()]] if lastfield>>

    // add_list(t, strf, strl)
    if(strf == T)
        strf = t;
    else
        strl->down = t;
    strl = t;
}
@
%ocaml: syntax error instead of error message. Also I detect
% duplicate member (a la clang)

% fields are chained together through down!

% call copytyp here too, because add a sym to it and will chain
% them together with Type.down.

\subsection{Enums}

% I explained Type.TENUM, and Type.link of it point to actual type.

%dead: OENUM

% There are two different types: 
%   - the type of the enum declaration itself, when do  enum x foo;
%   - the type of the enumeration constants of the enum (and also its value)
%     which can be referenced later in an expression

\subsubsection{Enumeration type uses and definitions}

% the type of the enum is a TENUM with a Type.link pointing to the right
% type.


% same dotag than for struct/union, cos same namespace
<<complex rule>>=
|   LENUM ltag
    {
        dotag($2, TENUM, 0);
        $$ = $2->suetag;
        if($$->link == T) // default type
            $$->link = types[TINT];
        $$ = $$->link;
    }
@
% but what is returned is the link, so really an int type!
% this is why you dont need to handle TENUM later during typechecking.

% To compute type of enum, need union of all types of enumeration constants.
% TINT by default but if use floats, or if use big integers, then it can
% change.
% Sometimes use big integers, for instance in 5c itself the bxxx enum
% is a 64 bits enum!

<<struct En>>=
struct En
{
    Type*	tenum;		/* type of entire enum */
    Type*	cenum;		/* type of current enum run */
    <<[[En]] value fields>>
};
@
%less: rename En, Enuminfo
\l rename En.tenum to not confuse with Sym.tenum
\l mv later? with typechecking? but then need to aspectize a lot

<<global en>>=
struct En en;
@


<<complex rule>>=
|   LENUM ltag
    {
        dotag($2, TENUM, autobn);
    }
    '{'
    {
        en.tenum = T;
        en.cenum = T;
    }
    enum 
    '}'
    {
        $$ = $2->suetag;
        if($$->link != T)
            diag(Z, "redeclare tag: %s", $2->name);
        <<complex rule, after processed an enum, sanity check tenum>>
        $$->link = en.tenum;
        $$ = en.tenum;
    }
|   LENUM 
    '{'
    {
        en.tenum = T;
        en.cenum = T;
    }
    enum 
    '}'
    {
        $$ = en.tenum;
    }
@
%ocaml: again, better error message a la clang

<<complex rule, after processed an enum, sanity check tenum>>=
if(en.tenum == T) {
    diag(Z, "enum type ambiguous: %s", $2->name);
    en.tenum = types[TINT];
}
@
\t this can never happen? tenum always set, and grammar imposes
\t  at least one enum element. If do just enum { }; ?
%ocaml: can happen???

% So type of enum is Sym.suetag->link

\subsubsection{Enumeration constant definitions}

% for the enumeration constants, the field below contains
% the reference to the type of the enum.
<<[[Sym]] enum value fields>>=
// ref<Type>
Type*	tenum;
@
% other fields in Sym for enumeration constants with vconst and vfconst
\t Why not reuse Sym.type of identifiers? anyway same namespace.

<<types, storage classes, qualifiers rules>>=
enum:
    LNAME           { doenum($1, Z); }
|   LNAME '=' expr  { doenum($1, $3); }

|   enum ',' enum
|   enum ','
@
%$
% optional trailing ,



% n = optional expression for the value of the enum constant
<<function doenum>>=
//@Scheck: used by cc.y
void doenum(Sym *s, Node *n)
{

    if(n) {
        <<[[doenum()]] typecheck and evaluate expression>>
        if(n->op != OCONST) {
            diag(n, "enum not a constant: %s", s->name);
            return;
        }

        en.cenum = n->type; // inferred type
        en.tenum = maxtype(en.cenum, en.tenum);
        <<[[doenum()]] save current value of enumeration constant>>
    }
    if(dclstack)
        push1(s); // will be reverted once out of scope

    // check for redeclaration and set s->type to TENUM
    xdecl(CXXX, types[TENUM], s); 

    if(en.cenum == T) {
        en.cenum = types[TINT];
        en.tenum = types[TINT];
        en.lastenum = 0;
    }
    s->tenum = en.cenum; // Sym.tenum, not En.tenum here

    <<[[doenum()]] set value for symbol>>

    <<[[doenum()]] debug declaration>>
    <<[[doenum()]] debugging support>>
}
@
%ocaml: constant evaluation done in separate phase in typecheck.ml

% note that symbol constant itself as type of cenum, not tenum.
% It's if you do enum Foo x; that you will get the maximum type.

% xdecl so check if redeclaration!
%enum_redeclare.c:1 external redeclaration of: Foo
%	GLOBL ENUM enum_redeclare.c:1
%	GLOBL INT enum_redeclare.c:1

\t diff between Sym.type set by xdecl and Sym.tenum?

% how know when reference an enum constant that it's an enum?
% because it's Sym.tenum is set? because it has a Sym.vconst?
%  tcomo look for sym.type->etype, because of xdecl!!
%  abuse TENUM!

\subsection{Pointer and array types}

% types part 2a
<<xdecor rule>>=
|   '*' zgnlist xdecor
    {
        $$ = new(OIND, $3, Z);
        $$->nodegarb = simpleg($2);
    }
@
% before the identifier

% Not same than OIND we have seen before. Abuse here for declaration.

<<[[Node]] parsing helper fields>>=
// enum<qualifier>
char	nodegarb;
@
% this is ugly field, used only because of the ugly way
% types are written in C



% remember t is the type part one (or the currently adjusted type)
<<[[dodecl()]] switch node kind cases>>=
case OIND:
    t = typ(TIND, t);
    t->garb = n->nodegarb;
    n = n->left;
    goto loop;
@
% n = n->left, to go deep in dodectl and access the name.

% types part 2b
<<xdecor2 rule>>=
|   xdecor2 '[' zexpr ']'      { $$ = new(OARRAY, $1, $3); }
@
%$
% after the identifier

% see also the abstract declarator rules which are similar


<<[[dodecl()]] locals>>=
Node *n1;
@
<<[[dodecl()]] switch node kind cases>>=
case OARRAY:
    t = typ(TARRAY, t);
    n1 = n->right; // possible size
    n = n->left;
    <<[[dodecl()]] switch node kind cases, case OARRAY, if array has a size>>
    goto loop;
@

% use of n1 later


\subsection{Function types, parameter types}

% http://fuckingfunctionpointers.com/

% OFUNC used also for function calls and introduced before.
% But used temporarily here because dodecl will parse it and
% transform in a TFUNC

<<xdecor2 rule>>=
|   xdecor2 '(' zarglist ')'   { $$ = new(OFUNC, $1, $3); }
@
%$
% after the identifier agin

% xdecor -> ... -> <> ?
<<parameter declarator rules>>=
zarglist:
  /* empty */   { $$ = Z; }
|   arglist     { $$ = invert($1); }
@
%$
%ocaml: called arg ... hmmm ... should be renamed zparamlist



<<[[dodecl()]] switch node kind cases>>=
case OFUNC:
    t = typ(TFUNC, t);
    t->down = fnproto(n);
    n = n->left;
    goto loop;
@
%less: why not fnproto(n->right) instead?
% if remove old prototype style handling, maybe I can do that



<<function fnproto>>=
Type*
fnproto(Node *n)
{
    <<[[fnproto()]] old prototype style handling>>
    return fnproto1(n->right);
}
@

<<function fnproto1>>=
Type*
fnproto1(Node *n)
{
    Type *t;

    if(n == Z)
        return T;

    switch(n->op) {
    <<[[fnproto1()]] switch node kind cases>>
    }
    diag(n, "unknown op in fnproto");
    return T;
}
@
% NODECL =~ (complex function type cast) nil
%ocaml: should not get error by construction

% n = Z if no parameters.

<<parameter declarator rules>>=
<<arglist rule>>
@


<<declaration nodes>>=
OPROTO,
@
\l rename OPARAM

<<arglist rule>>=
|   tlist xdecor
    {
        $$ = new(OPROTO, $2, Z);
        $$->type = $1;
    }
|   tlist abdecor
    {
        $$ = new(OPROTO, $2, Z);
        $$->type = $1;
    }
@
% abstract declarator or regular declarator


<<[[fnproto1()]] switch node kind cases>>=
case OPROTO:
    lastdcltype = T; // dead?
    dodecl(NODECL, CXXX, n->type, n->left);
    t = typ(TXXX, T);
    <<[[fnproto1()]] when OPROTO case, adjust parameter type>>
    return t;
@



<<arglist rule>>=
|   arglist ',' arglist  { $$ = new(OLIST, $1, $3); }
@
%$

<<[[fnproto1()]] switch node kind cases>>=
case OLIST:
    t = fnproto1(n->left);
    if(t != T)
        t->down = fnproto1(n->right);
    return t;
@




<<declaration nodes>>=
ODOTDOT,
@

<<arglist rule>>=
|   '.' '.' '.'          { $$ = new(ODOTDOT, Z, Z); }
@

<<[[fnproto1()]] switch node kind cases>>=
case ODOTDOT:
    return typ(TDOT, T);
@

<<[[Type_kind]] other cases>>=
TDOT, // ... in function types
@
%ocaml: bool for Func type, not at the toplevel of Type_kind



\subsection{Typedefs}

% defs

<<cname rule>>=
|   LTYPEDEF  { $$ = BTYPEDEF; }
@
% the keyword

<<[[simplec()]] cases>>=
case BTYPEDEF:
    return CTYPEDEF;
@

<<[[Storage_class]] cases>>=
CTYPEDEF,
@
% but ugly, this should not be a storage class ...

% this storage class will be stored in the class of the
% declarator (where? in dodecl?) and yylex() will then generate LTYPE tokens
% if this symbol is referenced.

% And this typedef will have a Type! xdecl will do its job.
% Just like when you do int x; then x in the symbol table as a 
% Sym.type that point to int.  then a typedef int x; will do the same
% for x!

% uses

<<complex rule>>=
|   LTYPE { $$ = tcopy($1->type); }
@
%$
% tricky! not copytyp here, but tcopy
\t why want to tcopy?? see code tcopy
%ocaml: do typedef expansion later, and forbid ugly typedefs
% that forces the need for an ugly tcopy

\section{Declarations and definitions, part two}

\subsection{Globals, external declarator}

% have seen already before xdecl, xdlist, xdecor, xdecor2

\subsection{Function parameters}

% seen OFUNC/OPROTO/OLIST before, now need to parse this
% to add in scope when the function type was actually the start
% of a function definition, not just a prototype.

% call argmark before process body of function. See Section X.
% call argmark with node for xdecor in 'zctlist xdecor'
% but after have called dodecl on this node.
% so node should be a OFUNC(ONAME, args)

% pass is 0 for ANSI proto, 1 for old style proto
<<function argmark>>=
//@Scheck: not dead, used by cc.y
void argmark(Node *n, int pass)
{
    Type *t;

    <<[[argmark()]] initializations>>

    for(; n->left != Z; n = n->left) {
        if(n->op != OFUNC || n->left->op != ONAME)
            continue;
        // else, OFUNC with ONAME on n->left, so analyze the parameters
        walkparam(n->right, pass);
        <<[[argmark()]] if old proto style>>
        break;
    }

    <<[[argmark()]] finalizations>>
}
@
\t should be OFUNC immediately no?
\t left op != ONAME? when? if syntax error I think and it's not a function


<<function walkparam>>=
void
walkparam(Node *n, int pass)
{
    Sym *s;
    Node *n1;

    if(n != Z && n->op == OPROTO && n->left == Z && n->type == types[TVOID])
        return;

loop:
    if(n == Z)
        return;
    switch(n->op) {
    case OLIST:
        walkparam(n->left, pass);
        n = n->right;
        goto loop;

    case OPROTO:
        for(n1 = n; n1 != Z; n1=n1->left)
            if(n1->op == ONAME) {
                if(pass == 0) {
                    s = n1->sym;
                    push1(s);
                    s->offset = -1;
                    break;
                }
                dodecl(pdecl, CPARAM, n->type, n->left);
                break;
            }

        if(n1)
            break;
        // else no name found
        <<[[walkparam()]] when OPROTO case, if no name found>>
        break;

    <<[[walkparam()]] switch op cases>>
    default:
        diag(n, "argument not a name/prototype: %O", n->op);
        break;

    }
}
@
%ocaml: error can happen? by construction?

<<[[walkparam()]] switch op cases>>=
case ODOTDOT:
    break;
@


<<[[walkparam()]] when OPROTO case, if no name found>>=
if(pass == 0) {
    /*
     * extension:
     *	allow no name in argument declaration
    diag(Z, "no name in argument declaration");
     */
    break;
}
// else pass == 1
<<[[walkparam()]] when OPROTO case, if no name found and old style decl>>
@




% dodecl(<>,...) -> <> 
<<function pdecl>>=
void
pdecl(int class, Type *t, Sym *s)
{
    <<[[pdecl()]] sanity check s>>
    <<[[pdecl()]] adjust type>>
    <<[[pdecl()]] adjust class>>
    <<[[pdecl()]] sanity check type>>
    adecl(class, t, s);
}
@
% a parameter is a kind of local, hence the call to adecl


<<[[pdecl()]] sanity check s>>=
if(s && s->offset != -1) {
    diag(Z, "not a parameter: %s", s->name);
    return;
}
@
%ocaml: impossible by construction I think

% offset set to -1 in walkparam()



\subsection{Locals, automatic declarator}

% slist -> <>
<<automatic declarator rules>>=
/*
 * automatic declarator
 */
adecl:
    ctlist ';'        { $$ = dodecl(adecl, lastclass, lasttype, Z); }
|   ctlist adlist ';' { $$ = $2; }
@
%$
% this time the set of locals is returned in AST.

% dodecl can return something??

<<automatic declarator rules>>=
adlist:
    xdecor
    {
        dodecl(adecl, lastclass, lasttype, $1);
        $$ = Z;
    }
|   xdecor
    {
        $1 = dodecl(adecl, lastclass, lasttype, $1);
    }
    '=' init
    {
        long w;

        w = $1->sym->type->width;
        $$ = doinit($1->sym, $1->type, 0L, $4);
        <<adlist rule, after doinit>>
    }
|   adlist ',' adlist
    {
        $$ = $1;
        if($3 != Z) {
            $$ = $3;
            if($1 != Z)
                $$ = new(OLIST, $1, $3);
        }
    }
@
%$
%ocaml: can just factorize with xdlist as do the adecl vs xdecl
% in the caller

% return only the assignements nodes though, not the declaration themselves.

% 0L again.


% pdecl | dodecl(<>) -> <>
<<function adecl>>=
void
adecl(int c, Type *t, Sym *s)
{

    <<[[adecl()]] adjust storage to CLOCAL if static local variable>>
    <<[[adecl()]] adjust storage if function type>>
    <<[[adecl()]] adjust storage>>

    if(s) {
        <<[[adecl()]] adjust storage if symbol>>

        if(c != CPARAM)
            push1(s); // CPARAM pushed already in walkparam()

        s->block = autobn;
        s->type = t;
        s->class = c;
        s->offset = 0;
        <<[[adecl()]] initialize symbol>>
    }

    switch(c) {
    <<[[adecl()]] switch class cases>>
    }
}
@
% offset 0 for local??

\subsection{Types, abstract declarator}

% for cast, sizeof, declaration of parameters in a prototype
<<abstract declarator rules>>=
/*
 * abstract declarator
 */
abdecor:
  /* empty */ { $$ = Z; }
|   abdecor1
@

<<abstract declarator rules>>=
abdecor1:
    '*' zgnlist
    {
        $$ = new(OIND, (Z), Z);
        $$->nodegarb = simpleg($2);
    }
|   '*' zgnlist abdecor1
    {
        $$ = new(OIND, $3, Z);
        $$->nodegarb = simpleg($2);
    }
|   abdecor2
@
%$
%OIND of Z here! no ONAME

<<abstract declarator rules>>=
abdecor2:
    abdecor3
|   abdecor2 '(' zarglist ')'   { $$ = new(OFUNC, $1, $3); }
|   abdecor2 '[' zexpr ']'      { $$ = new(OARRAY, $1, $3); }

abdecor3:
    '(' ')'           { $$ = new(OFUNC, Z, Z); }
|   '[' zexpr ']'     { $$ = new(OARRAY, Z, $2); }
|   '(' abdecor1 ')'  { $$ = $2; }
@
%$

% ugly syntax ...







\chapter{Checking}

% Can have many bugs. Programmer can do many mistakes.
% Role of this chapter is to explain code that detect common mistakes.
% Type checking is a big one. 
% use of undeclared, redeclaring, unused are other one.

% Normally, a compiler does many checks
% after parsing and before code generation. 
% 5c instead does most of those checks during parsing
% and a few one during the code generation. There is not really
% a separate checking phase, thus most of the code I will present
% in this sections are chunks of functions I presented before (e.g., xdecl(),
% revertdcl(), doenum()).
\l not better software-engineering wise, maybe faster because one pass only
%ocaml: I prefer to clearly separate and have check.ml and typecheck.ml
% separate from parser.mly

\section{Overview}

% - symbol resolution, use/def matching correctly, lookup failure
%   with scoping rules, done via Decl and symbol table (and .h so have
%   all declarations in one file)
% - decl/def matching correctly by checking for wrong redeclaration in xdecl
% - typechecking rules
% - lint rules (e.g. unused vars/labels, unused param, dead code, etc)

% a few warn() seen before, 
%  - in lexer: sign-extended char? truncated constant?
%  - in grammar: 
%     * empty body of if (empty then, empty else)
%  - in ast builder helper: 
%     * CAST in initialization ignored?? 
%     * initialize pointer to an integer?
%     * duplicated keywords for storage or qualifier or type
%       overspecified class? just say static?
%     * negative (or not constant) size for an array.

% a few later:
%  - div by zero in evconst()
%  - use of undeclared label (Node.complex still 0)
%  - use of undefined identifier (Node.type still T)
%  - initializing a function
%  - stupid shift bits
% Some done later because need typed AST, and need simplified AST
% (e.g. constant evaluation done)

\section{Printing warnings, [[5c -w]], [[5c -W]]}
% also -X

% 5c -w
<<function warn>>=
void
warn(Node *n, char *fmt, ...)
{
    char buf[STRINGSZ];
    va_list arg;

    if(debug['w'] || debug['W']) {
        va_start(arg, fmt);
        vseprint(buf, buf+sizeof(buf), fmt, arg);
        va_end(arg);
        <<[[warn()]] if -W>>
        // else
        Bprint(&diagbuf, "warning: %L %s\n", (n==Z) ? nearln : n->lineno, buf);
        <<[[warn()]] if -v>>
    }
}
@
%ocaml: do not use nearln, use precise location. 

% 5c -W give full verbose diagnostic

<<[[warn()]] if -W>>=
if(debug['W']) {
    diag(n, "%s", buf);
    return;
}
@
% see Appendix for diag()

% -w -v to print AST too!

<<[[warn()]] if -v>>=
if(n != Z)
  if(debug['v'])
    prtree(n, "warning");
@
%ocaml: Do not print AST,  use -dump_ast if you want that.

% see Appendix for prtree().

\section{Symbol resolution}
% Scoping, naming

%as I said done in parsing, as C force to forward decl 
% everything and have huge .h
% (and actual linking is done in linker to find inconsistencies).
% All the information is in the global symbol table.

% Warn when function not found before and (ugly) implicitly declare it.
% Error when redeclare tag, or inconsistent declaration.

%\section{Scoping resolution}

% See Decl section and markdcl() and revertdecl().
% see also the Sym.block and Sym.sublock fields

\section{Storage resolution}

% not really checking, but can make mistake here, can have conflict,
% so simple thing to check that is not grammar related.

% C allows multiple declarations of toplevel entities.
% Not an error. Need then to check if entity declared in .h
% (but included by preprocessor) is compatible with entity
% defined in .c.
% Done in xdecl() during parsing.
% Also checks in pdecl and adecl.

\subsection{xdecl}

%corner:
% xdecl does a few adjustments to the storage class of a sym.
% In what follows, s->class is the class of the symbol before
% the decl (the symbol may have been declared before) and
% class is the class of the symbol as defined in the current decl.

% if you did not specify any storage at toplevel, then it's a global.
% (and if was defined previously as extern, now it's a global).
<<[[xdecl()]] switch class cases>>=
case CXXX:
    class = CGLOBL;
    if(s->class == CEXTERN)
        s->class = CGLOBL;
    break;
@

%semantic rules of C are fuzzy for me too.
% what happened if do extern int x; and then int x; or the reverse?
% Well you can become more precise! it's ok.

% was defined previously as a global, then extern, does not matter.
<<[[xdecl()]] switch class cases>>=
case CEXTERN:
    if(s->class == CGLOBL)
        class = CGLOBL;
    break;
@
%ocaml: should report an error

% xdecl overwrite class so the class!=s->class later will not raise an error.

<<[[xdecl()]] switch class cases>>=
case CAUTO:
    diag(Z, "overspecified class: %s %s %s", s->name, cnames[class], cnames[s->class]);
    class = CEXTERN;
    break;
@
%ocaml: should forbid (clang reports illegal storage)

% So auto is really a useless keyword.



% Now a few sanity checks done after the switch class. 

% if was declared a static and now global, then report!
<<[[xdecl()]] sanity check class after switch class>>=
if(s->class == CSTATIC)
    if(class == CEXTERN || class == CGLOBL) {
        warn(Z, "overspecified class: %s %s %s", s->name, cnames[class], cnames[s->class]);
        class = CSTATIC;
    }
@
%ocaml: more than warn, I forbid

\subsection{doinit}


<<[[doinit()]] possibly adjust class>>=
if(s->class == CEXTERN) {
    s->class = CGLOBL;
    <<[[doinit()]] debug declaration>>
}
<<[[doinit()]] debug initialization>>
@
%ocaml: should report! why would you do extern int x = 1; ?

\subsection{pdecl}

<<[[pdecl()]] adjust class>>=
if(class == CXXX)
    class = CPARAM;
if(class != CPARAM) {
    diag(Z, "parameter cannot have class: %s", s->name);
    class = CPARAM;
}
@
%ocaml: by construction I do not allow storage on parameter

% remember than pdecl calls adecl

\subsection{adecl}

%corner:

<<[[adecl()]] adjust storage if function type>>=
if(t->etype == TFUNC) {
    if(c == CXXX)
        c = CEXTERN;
    if(c == CLOCAL)
        c = CSTATIC;
    if(c == CAUTO || c == CEXREG)
        diag(Z, "function cannot be %s %s", cnames[c], s->name);
}
@
%ocaml: forbid prototype declaration inside a function.

<<[[adecl()]] adjust storage>>=
if(c == CXXX)
    c = CAUTO;
@
% simple

<<[[adecl()]] adjust storage if symbol>>=
if(s->class == CSTATIC)
    if(c == CEXTERN || c == CGLOBL) {
        warn(Z, "just say static: %s", s->name);
        c = CSTATIC;
    }
if(s->class == CAUTO || s->class == CPARAM || s->class == CLOCAL)
if(s->block == autobn)
    diag(Z, "auto redeclaration of: %s", s->name);
@
%ocaml: done in check.ml

\section{Typechecking helpers}

\subsection{Overview}

% remember Node.type!

% different kinds of type checks
%  - type equality
%  - type compatibility

% in many of the functions below, the boolean return value
% true means that there was a typechecking error.

% saw complex() for enum (and for array later).
% does lots of stuff, typechecking, simplification, constant evaluation.
% Call typechecker also tcom().


<<[[xdecl()]] sanity check type after switch class>>=
if(s->type != T)
    if(s->class != class || !sametype(t, s->type) || t->etype == TENUM) {
        diag(Z, "external redeclaration of: %s", s->name);
        Bprint(&diagbuf, "	%s %T %L\n", cnames[class], t, nearln);
        Bprint(&diagbuf, "	%s %T %L\n", cnames[s->class], s->type, s->varlineno);
    }
@
%ocaml: detect error in typecheck.ml, and no need for class comparison,
% use merge_storage_toplevel() instead.

% when can have TENUM? when abuse xdecl for setting Sym.type
% for enumeration constant. TENUM is used as type of constants.
% So if s->type != T means there was a symbol before, and if new t is
% TENUM then conflict! 
%ocaml: do that in check.ml instead



\subsection{Type equality, [[sametype()]]}

% sametype() called in xdecl() to make sure types are equals.
% xdecl -> <>
<<function sametype>>=
bool
sametype(Type *t1, Type *t2)
{

    if(t1 == t2)
        return true;
    return rsametype(t1, t2, 5, true);
}
@
%ocaml: just Pervasives.(=) . No need for depth because structures
% are not represented as pointers; I always keep the StructName.
% Also I do not struct equality by fields, but by name, so I can simply use
% (=).


<<function rsametype>>=
bool
rsametype(Type *t1, Type *t2, int n, bool f)
{
    int et;

    n--;
    for(;;) {
        if(t1 == t2)
            return true;
        if(t1 == T || t2 == T)
            return false;
        <<[[rsametype()]] if n less than zero>>

        et = t1->etype;
        if(et != t2->etype)
            return false;

        <<[[rsametype()]] check function type equality>>
        <<[[rsametype()]] check array type equality>>
        <<[[rsametype()]] check structure type equality>>

        // recurse
        t1 = t1->link;
        t2 = t2->link;

        <<[[rsametype()]] if f and not -V, allow void star>>
    }
}
@
% when can have T? because loop, so if compare pointer to int,
% then only one of the t1 or t2 will have a Type.link.

% n = depth, so equal modulo a certain depth (needed for complex chain 
% of mutually recursive structures).

<<[[rsametype()]] if n less than zero>>=
if(n <= 0)
    return true;
@


% for functions, etype is not enough, need look
% for Type.link (return type), Type.down (parameters)

<<[[rsametype()]] check function type equality>>=
if(et == TFUNC) {
    if(!rsametype(t1->link, t2->link, n, false))
        return false;
    t1 = t1->down;
    t2 = t2->down;
    while(t1 != T && t2 != T) {

        <<[[rsametype()]] continue if old style type>>

        while(t1 != T || t2 != T) {
            if(!rsametype(t1, t2, n, false))
                return false;
            t1 = t1->down;
            t2 = t2->down;
        }
        break;
    }
    return true;
}
@
%ocaml: (=) goes in depth by default

<<[[rsametype()]] check array type equality>>=
if(et == TARRAY)
    if(t1->width != t2->width && t1->width != 0 && t2->width != 0)
        return false;
@

\t it accepts int[] to be compatible with int[5] ??


<<[[rsametype()]] check structure type equality>>=
if(typesu[et]) {
    if(t1->link == T)
        snap(t1);
    if(t2->link == T)
        snap(t2);

    if(t1 != t2 && t1->link == T && t2->link == T){
        /* structs with missing or different tag names aren't considered equal */
        if(t1->tag == nil || t2->tag == nil ||
           strcmp(t1->tag->name, t2->tag->name) != 0)
            return false;
    }
    // equal if have same types (but do not care about field names)
    t1 = t1->link;
    t2 = t2->link;
    for(;;) {
        if(t1 == t2)
            return true;
        if(!rsametype(t1, t2, n, false))
            return false;
        t1 = t1->down;
        t2 = t2->down;
    }
} // end su
@
%ocaml: I use struct equality by name, so I dont care whether struct
% was defined or not.

% use of typesu[] explained later.

<<function snap>>=
void
snap(Type *t)
{
    if(typesu[t->etype])
     if(t->link == T && t->tag && t->tag->suetag) {
        t->link = t->tag->suetag->link;
        t->width = t->tag->suetag->width;
    }
}
@
%ocaml: I don't need that I think.

\t why need that? 5c does not share types returned on
\t Sym.suetag for all occurences? maybe not because of copytyp?
\t This is why useful to keep a ref to the Sym in Type.tag?




\subsection{generic [[void*]] pointer conversions, [[5c -V]]}

% I thought it was a C extension, but it is not!
% Without the code below you cant call functions like pwrite with a string
% because a char* will not match a void*

% often use 5c -FTV, -V means 'enable void* conversion warnings'
% so in fact it disables void* conversions.

<<[[rsametype()]] if f and not -V, allow void star>>=
if((f || !debug['V']) && et == TIND) {
    if(t1 != T && t1->etype == TVOID)
        return true;
    if(t2 != T && t2->etype == TVOID)
        return true;
}
@


% if not -V means disable void* conversion

% Allow void* to match int* or struct*, but only for first level. 
% When call recursively rsametype we disable it, this is what 'f'
% is for (see code of rsametype)



\subsection{Type merge, [[tmerge()]]}
%Declaration and definition types merge

<<[[xdecl()]] merge type declarations>>=
tmerge(t, s);
@
% not for adecl, or edecl, just for xdecl.

% dodectl(xdecl,...) -> xdecl -> <>
<<function tmerge>>=
void
tmerge(Type *t1, Sym *s)
{
    Type *t2 = s->type;
    Type *ta, *tb;

/*print("merge	%T; %T\n", t1, t2);/**/
    for(;;) {
        if(t1 == T || t2 == T || t1 == t2)
            break;
        if(t1->etype != t2->etype)
            break;
        switch(t1->etype) {
        <<[[tmerge()]] switch etype t1 cases>>
        case TARRAY:
            /* should we check array size change? */
            if(t2->width > t1->width)
                t1->width = t2->width;
            break;

        case TUNION:
        case TSTRUCT:
            return;
        }
        // recurse
        t1 = t1->link;
        t2 = t2->link;
    }
}
@
%ocaml: no need because does not support old style decl func,

% when can have t1 and t2 without a type, because recurse!
% but should not call tmerge with incompatible types anyway no?

\t why allow different size for array

\subsection{Set of types constants, [[typexxx[]]]}

<<global typei>>=
// set<Type_kind>
char	typei[NTYPE];
@
%less: char -> bool?

<<global typeiinit>>=
int	typeiinit[] =
{
    TCHAR, TUCHAR, TSHORT, TUSHORT, TINT, TUINT, TLONG, TULONG, TVLONG, TUVLONG, -1,
};
@
%ocaml: pattern matching, more powerful ADT, T.I of integer_type

% have seen typesu[] before

<<global typesu>>=
char	typesu[NTYPE];
@
<<global typesuinit>>=
int	typesuinit[] =
{
    TSTRUCT, TUNION, -1,
};
@


% will see often code doing different things if float or not.
% ex: for enum, if enum is float constant or int.
<<global typefd>>=
char	typefd[NTYPE];
@
<<global typefdinit>>=
int	typefdinit[] =
{
    TFLOAT, TDOUBLE, -1,
};
@



%chunks: will present gradually other typeXXX

<<[[tinit()]] initialise typexxx type sets>>=
for(ip=typeiinit; *ip>=0; ip++) {
    urk("typei", nelem(typei), *ip);
    typei[*ip] = 1;
}
for(ip=typeuinit; *ip>=0; ip++) {
    urk("typeu", nelem(typeu), *ip);
    typeu[*ip] = 1;
}
for(ip=typesuvinit; *ip>=0; ip++) {
    urk("typesuv", nelem(typesuv), *ip);
    typesuv[*ip] = true;
}
for(ip=typeilpinit; *ip>=0; ip++) {
    urk("typeilp", nelem(typeilp), *ip);
    typeilp[*ip] = 1;
}
for(ip=typechlinit; *ip>=0; ip++) {
    urk("typechl", nelem(typechl), *ip);
    typechl[*ip] = 1;
    typechlv[*ip] = 1;
    //typechlvp[*ip] = 1;
}
for(ip=typechlpinit; *ip>=0; ip++) {
    urk("typechlp", nelem(typechlp), *ip);
    typechlp[*ip] = 1;
    //typechlvp[*ip] = 1;
}
for(ip=typechlpfdinit; *ip>=0; ip++) {
    urk("typechlpfd", nelem(typechlpfd), *ip);
    typechlpfd[*ip] = 1;
}
for(ip=typevinit; *ip>=0; ip++) {
    urk("typev", nelem(typev), *ip);
    typev[*ip] = 1;
    typechlv[*ip] = 1;
    //typechlvp[*ip] = 1;
}
for(ip=typefdinit; *ip>=0; ip++) {
    urk("typefd", nelem(typefd), *ip);
    typefd[*ip] = 1;
}
for(ip=typeafinit; *ip>=0; ip++) {
    urk("typeaf", nelem(typeaf), *ip);
    typeaf[*ip] = 1;
}
for(ip=typesuinit; *ip >= 0; ip++) {
    urk("typesu", nelem(typesu), *ip);
    typesu[*ip] = 1;
}
@
%ocaml: use pattern matching directly, so no need those initialiser
% and data-structure bitset tricks

%dead:
% <<global typec>>=
% char	typec[NTYPE];
% @
% <<global typecinit>>=
% int	typecinit[] =
% {
%     TCHAR, TUCHAR, -1
% };
% @
% for(ip=typecinit; *ip>=0; ip++) {
%     urk("typec", nelem(typec), *ip);
%     typec[*ip] = 1;
% }
% <<global typeh>>=
% char	typeh[NTYPE];
% @
% <<global typehinit>>=
% int	typehinit[] =
% {
%     TSHORT, TUSHORT, -1,
% };
% @
% for(ip=typehinit; *ip>=0; ip++) {
%     urk("typeh", nelem(typeh), *ip);
%     typeh[*ip] = 1;
% }

% <<global typechlvp>>=
% char typechlvp[NTYPE];
% @



\subsection{Type compatibility, [[tcompat()]]}

% returning true means actually they are not compatible and
% there is a type error.
\l replace bool by 'error' type?

% call as 'tcompat(n, l->type, r->type, tasadd)'
% and tasadd is a compatibility policy (see next section)

% t for test-compatibility, because later have tlvalue for test-lvalue.

% (complex -> tcom -> tcomo) | bcomplex -> <>
<<function tcompat>>=
bool
tcompat(Node *n, Type *t1, Type *t2, long ttab[])
{

    if(stcompat(n, t1, t2, ttab)) {
        <<[[tcompat()]] if no T1>>
        else
            diag(n, "incompatible types: \"%T\" and \"%T\" for op \"%O\"",
                t1, t2, n->op);
        return true;
    }
    return false;
}
@

<<[[tcompat()]] if no T1>>=
if(t1 == T)
    diag(n, "incompatible type: \"%T\" for op \"%O\"",
        t2, n->op);
@
% when can have t1 == T? when call tcompat with unary operator.



% this is silent, it does not generate error if there are not compatible.
% tcompat -> <>
<<function stcompat>>=
bool
stcompat(Node *n, Type *t1, Type *t2, long ttab[])
{
    int i;
    //Type_kind (as a bit)
    ulong b;

    i = 0;
    if(t2 != T)
        i = t2->etype;
    b = 1L << i;
    i = 0;
    if(t1 != T)
        i = t1->etype;
    // type t2 part of set of types compatible with type t1
    if(b & ttab[i]) {
        <<[[stcompat()]] when t1 matches t2, if ttab is tasign>>
        <<[[stcompat()]] when t1 matches t2, if pointers and not a cast op>>
        return false; // true means error, so false means everything fine
    }
    return true;
}
@
%ocaml: use simply pattern matching, no need abuse Bxxx and special
% case for tasign and pointers.



<<[[stcompat()]] when t1 matches t2, if pointers and not a cast op>>=
if(n->op != OCAST)
  if(b == BIND && i == TIND)
        if(!sametype(t1, t2))
            return true;
@
%ocaml: use ADT for Type.t so can do that earlier when rule
% mention two pointers

% pointers must be equal type too (except in cast operation obviously)

% note that sametype will allow a void* to match a xxx*

\subsection{Compatibility policies, [[txxx]]}

% will call stcompat with different compatibilitie policies


<<[[Bxxx]] constants>>=
BINTEGER	= BCHAR|BUCHAR|BSHORT|BUSHORT|BINT|BUINT|BLONG|BULONG|BVLONG|BUVLONG,
BNUMBER		= BINTEGER | BFLOAT|BDOUBLE,
@
%ocaml: use pattern matching?


<<global tadd>>=
long	tadd[NTYPE];
@
<<global taddinit>>=
Init	taddinit[] =
{
    TCHAR,		BNUMBER|BIND,	0,
    TUCHAR,		BNUMBER|BIND,	0,
    TSHORT,		BNUMBER|BIND,	0,
    TUSHORT,	BNUMBER|BIND,	0,
    TINT,		BNUMBER|BIND,	0,
    TUINT,		BNUMBER|BIND,	0,
    TLONG,		BNUMBER|BIND,	0,
    TULONG,		BNUMBER|BIND,	0,
    TVLONG,		BNUMBER|BIND,	0,
    TUVLONG,	BNUMBER|BIND,	0,

    TFLOAT,		BNUMBER,	0,
    TDOUBLE,	BNUMBER,	0,
    TIND,		BINTEGER,	0,
    -1,		0,		0,
};
@
% see Init in appendix.

%corner:
% can not add two pointers!!! would not make sense
% (but can substract them, but then result is a long, not a pointer)
% (so can do  eend - estart)


% triple? 0? See Init type.

%chunks:
% Just gave one example of policy. Will present other
% later with code that uses it.

<<[[tinit()]] initialise tcompat arrays>>=
for(p=tasigninit; p->code >= 0; p++) {
    urk("tasign", nelem(tasign), p->code);
    tasign[p->code] = p->value;
}
for(p=tasaddinit; p->code >= 0; p++) {
    urk("tasadd", nelem(tasadd), p->code);
    tasadd[p->code] = p->value;
}
for(p=tcastinit; p->code >= 0; p++) {
    urk("tcast", nelem(tcast), p->code);
    tcast[p->code] = p->value;
}
for(p=taddinit; p->code >= 0; p++) {
    urk("tadd", nelem(tadd), p->code);
    tadd[p->code] = p->value;
}
for(p=tsubinit; p->code >= 0; p++) {
    urk("tsub", nelem(tsub), p->code);
    tsub[p->code] = p->value;
}
for(p=tmulinit; p->code >= 0; p++) {
    urk("tmul", nelem(tmul), p->code);
    tmul[p->code] = p->value;
}
for(p=tandinit; p->code >= 0; p++) {
    urk("tand", nelem(tand), p->code);
    tand[p->code] = p->value;
}
for(p=trelinit; p->code >= 0; p++) {
    urk("trel", nelem(trel), p->code);
    trel[p->code] = p->value;
}
@


\subsection{Typechecker, [[tcom()]]}
% cc/com.c

% finally!

% Again, returning true means type error!
%ocaml: use exn

% complex | tcomo | tcoma | tcomx  -> <>
<<function tcom>>=
/*
 * evaluate types
 * evaluate lvalues (addable == 1)
 */
bool
tcom(Node *n)
{

    return tcomo(n, ADDROF);
}
@
% also does a few transformations on the node:
%  - retag some nodes to be more explicit e.g. AMUL -> ALMUL
%  - add intermediate nodes for array and functions to
%    add OADDR node as passing  a function is really passing
%    the address of this function, and passing an array??
%  => make some sugar or implicits more explicits!

% for context in tcomo?
<<enum _anon_ (cc/com.c)>>=
enum
{
    ADDROF	= 1<<0,
    CASTOF	= 1<<1,
    ADDROP	= 1<<2,
};
@
% >> >> >>
%ocaml: pass as a field in environment, and better names.
% also add a CtxSizeof instead of passing 0 sometimes

% evaluate types means type checking and making cast explicits

% lvalue vs rvalue: https://www.itu.dk/courses/BPRD/E2009/fundamental-1967.pdf)
% (thx charles forsith)

% evaluate lvalue because needed to check assignements whether
% it is valid or not.

% true means error
% f = context? ADDROF at the beginning
% o for ? tcom_o ?
<<function tcomo>>=
bool
tcomo(Node *n, int f)
{
    Node *l, *r;
    Type *t;
    // bool | int
    int o; 
    <<[[tcomo()]] other locals>>

    <<[[tcomo()]] sanity check n>>
    n->addable = false;
    l = n->left;
    r = n->right;

    switch(n->op) {
    <<[[tcomo()]] switch node kind cases>>
    default:
        diag(n, "unknown op in type complex: %O", n->op);
        goto bad;

    }

    t = n->type;
    <<[[tcomo()]] sanity check t after typing>>
    <<[[tcomo()]] sanity check type width>>
    <<[[tcomo()]] special adjustments for arrays and functions>>
    return false; // everything is fine

<<[[tcomo()]] extra labels>>

bad:
    n->type = T;
    return true;
}
@
%ocaml: use exn for error.
%ocaml: how annotate expressions with type?
% - by side effect on mutable expression field?
% - by returning a new expression with a new type?
% You will need to return new expression for enum, +x, -x,
% This could be done in a later phase? Maybe, but then
% will still need to check that used in right context, with right cast.
% Also we need to add cast, so maybe better do that also during typechecking,
% after all it's type related! It's also more functional.
%ocaml: do lvalue (addable) by function, not field.

% addable here is (ab)used to indicate whether node is a lvalue.


<<[[tcomo()]] sanity check n>>=
if(n == Z) {
    diag(Z, "Z in tcom");
    errorexit();
}
@
%ocaml: never happens, by construction, no node pointers.

<<[[tcomo()]] sanity check t after typing>>=
if(t == T)
    goto bad;
@
%ocaml: never happens, by construction


<<[[tcomo()]] sanity check type width>>=
if(t->width < 0) {
    snap(t);
    if(t->width < 0) {
        if(typesu[t->etype] && t->tag)
            diag(n, "structure not fully declared %s", t->tag->name);
        else
            diag(n, "structure not fully declared");
        goto bad;
    }
}
@
%ocaml: no need, I compute the size far later during code generation

\subsection{Array to pointer conversions}


% set addable to false by default.
% lvalues are x, *x, and x[i] (which is converted in parsing in *(x+i))

<<global typeaf>>=
char	typeaf[NTYPE];
@
<<global typeafinit>>=
int	typeafinit[] =
{
    TFUNC, TARRAY, -1,
};
@

<<[[tcomo()]] special adjustments for arrays and functions>>=
if(typeaf[t->etype]) {
    if(f & ADDROF)
        goto addaddr;
    if(f & ADDROP)
        warn(n, "address of array/func ignored");
}
@
%ocaml: do it only for arrays?

% The code below is very important. It transforms a reference to an array
% type (TARRAY) in a TIND so below we can just use TIND uniformly.

<<[[tcomo()]] extra labels>>=
addaddr:
    if(tlvalue(n))
        goto bad;
    l = new1(OXXX, Z, Z);
    *l = *n;
    n->op = OADDR;
    if(l->type->etype == TARRAY)
        l->type = l->type->link;
    n->left = l;
    n->right = Z;
    n->addable = false;
    n->type = typ(TIND, l->type);
    n->type->width = types[TIND]->width;
    return false;
@

% "array is a lie in C"
%https://blog.feabhas.com/2016/12/a-convenient-untruth/

% so if declared 'int x[45];', then when you refer to 'x' in an expression,
% it first gets it full type (TARRAY(45, int)), but then this
% node 'x' gets transformed in &x : TIND(int)
% so x[10] -> *(x+10) which really becomes   *(&x + 40) (because sizeof(int)=4)
% subtle!

% Will see later than when call a function pointer, dereference
% automatically, so can treat function and function pointer in a similar way,
% as well as array and pointer in a similar way too. One get converted
% in the other and vice versa depending on context.

\section{Typechecking expressions}
\n try same order than in Parsing

<<[[tcomo()]] switch node kind cases>>=
case OCOMMA:
    o = tcom(l);
    if(o | tcom(r))
        goto bad;
    n->type = r->type;
    break;
@
%ocaml: use exceptions do no need goto bad all the time and threading 'o'

% type of a,b is type of last element!

% call tcom, not tcomo, so reset [[f]] parameter to ADDROF.

\subsection{Numeric constants}

% type annotations done already in grammar action.
% See Section X. Node.type already good.

<<[[tcomo()]] switch node kind cases>>=
case OCONST:
    break;
@

\subsection{String constants}

%\subsubsection{ASCII strings}

<<[[tcomo()]] switch node kind cases>>=
case OSTRING:
    <<[[tcomo()]] in OSTRING case, if not an array or chars>>
    <<[[tcomo()]] transform OSTRING in ONAME>>
    break;
@

% Again type annotations done during parsing.
% Transformation explained later in code generation.

%\subsubsection{Unicode strings}


\subsection{Entity uses}

<<[[tcomo()]] switch node kind cases>>=
case ONAME:
    <<[[tcomo()]] in ONAME case, check if name declared>>
    <<[[tcomo()]] in ONAME case, if enum constant>>
    // else
    n->addable = true;
    <<[[tcomo()]] in ONAME case, if extern register>>
    break;
@

% If entity referring to global, extern, param, auto, then
% Node.class, Node.type, and Node.offset are already set correctly!


<<[[tcomo()]] in ONAME case, check if name declared>>=
if(n->type == T) {
    diag(n, "name not declared: %F", n);
    goto bad;
}
@
%ocaml: I do that during parsing, because I do not allow
% implicit declaration and types

% remember xdecl in doenum() which sets to TENUM type of enumeration
% constants!


<<[[tcomo()]] in ONAME case, if enum constant>>=
if(n->type->etype == TENUM) {
    n->op = OCONST;
    if(!typefd[n->type->etype])
        n->vconst = n->sym->vconst;
    else
        n->fconst = n->sym->fconst;
    n->type = n->sym->tenum;
    break;
}
@
%ocaml: forbid enum float

% adjust type to tenum! and ONAME to OCONST!
% break so no addable set
\l mv in code generation?

\subsection{Arithmetic expressions}

% the different cases of tcomo for the different kinds of expressions
% are very similar. Mosly like the code below, but with a different
% compatibility policy.

<<[[tcomo()]] switch node kind cases>>=
case OADD:
    o = tcom(l);
    if(o | tcom(r))
        goto bad;
    <<[[tcomo()]] break if isfunct>>
    if(tcompat(n, l->type, r->type, tadd))
        goto bad;
    arith(n, true);
    break;
@
%ocaml: use exception so no need to thread those o and goto bad

% tadd shown before.


<<[[tcomo()]] switch node kind cases>>=
case OSUB:
    o = tcom(l);
    if(o | tcom(r))
        goto bad;
    <<[[tcomo()]] break if isfunct>>
    if(tcompat(n, l->type, r->type, tsub))
        goto bad;
    arith(n, true);
    break;
@

<<global tsub>>=
long	tsub[NTYPE];
@
<<global tsubinit>>=
Init	tsubinit[] =
{
    TCHAR,		BNUMBER,	0,
    TUCHAR,		BNUMBER,	0,
    TSHORT,		BNUMBER,	0,
    TUSHORT,	BNUMBER,	0,
    TINT,		BNUMBER,	0,
    TUINT,		BNUMBER,	0,
    TLONG,		BNUMBER,	0,
    TULONG,		BNUMBER,	0,
    TVLONG,		BNUMBER,	0,
    TUVLONG,	BNUMBER,	0,

    TFLOAT,		BNUMBER,	0,
    TDOUBLE,	BNUMBER,	0,
    TIND,		BINTEGER|BIND,	0,
    -1,		0,		0,
};
@
%ocaml: clearer with pattern matching, (T.I _ | T.F _), (T.I _ | T.F _) -> true
% can do better grouping

%corner:
% you can substract two pointers but not add.
% eend - estart makes sense, but estart+eend means nothing.

%corner:
% you can an int to a pointer, but not substract. 1 - estart does 
% not make sense. 1+estart (or estat+1) yes. (and eend - 1 too)


% remember that enum constant converted to ints, so no need TENUM case
% above.

<<[[tcomo()]] switch node kind cases>>=
case OMUL:
case ODIV:
case OLMUL:
case OLDIV:
    o = tcom(l);
    if(o | tcom(r))
        goto bad;
    <<[[tcomo()]] break if isfunct>>
    if(tcompat(n, l->type, r->type, tmul))
        goto bad;
    arith(n, true);
    <<[[tcomo()]] in OMUL/ODIV case, adjust opcode if unsigned type>>
    break;
@
\t OLMUL case should never happen? not generated by parser
\t or call tcomo again on the same nodes?

<<global tmul>>=
long	tmul[NTYPE];
@
<<global tmulinit>>=
Init	tmulinit[] =
{
    TCHAR,		BNUMBER,	0,
    TUCHAR,		BNUMBER,	0,
    TSHORT,		BNUMBER,	0,
    TUSHORT,	BNUMBER,	0,
    TINT,		BNUMBER,	0,
    TUINT,		BNUMBER,	0,
    TLONG,		BNUMBER,	0,
    TULONG,		BNUMBER,	0,
    TVLONG,		BNUMBER,	0,
    TUVLONG,	BNUMBER,	0,

    TFLOAT,		BNUMBER,	0,
    TDOUBLE,	BNUMBER,	0,
    -1,		0,		0,
};
@


<<[[tcomo()]] switch node kind cases>>=
case OMOD:
case OLMOD:
    o = tcom(l);
    if(o | tcom(r))
        goto bad;
    <<[[tcomo()]] break if isfunct>>
    if(tcompat(n, l->type, r->type, tand))
        goto bad;
    arith(n, true);
    <<[[tcomo()]] in OMOD case, adjust opcode if unsigned type>>
    break;
@
% tand?



% transform +x in  x+0 

<<[[tcomo()]] switch node kind cases>>=
case OPOS:
    if(tcom(l))
        goto bad;
    <<[[tcomo()]] break if isfunct>>

    r = l;
    l = new(OCONST, Z, Z);
    l->vconst = 0;
    l->type = types[TINT];
    n->op = OADD;
    n->right = r;
    n->left = l;

    if(tcom(l))
        goto bad;
    if(tcompat(n, l->type, r->type, tsub))
        goto bad;
    arith(n, true);
    break;
@
%ocaml: call recursively with new expr, so even simpler

%bug? why tsub?

\l move in code generation? anyway need to call typechecker and arith on it.

% transform -x in  0-x

<<[[tcomo()]] switch node kind cases>>=
case ONEG:
    if(tcom(l))
        goto bad;
    <<[[tcomo()]] break if isfunct>>

    if(!machcap(n)) {
        r = l;
        l = new(OCONST, Z, Z);
        l->vconst = 0;
        l->type = types[TINT];
        n->op = OSUB;
        n->right = r;
        n->left = l;

        if(tcom(l))
            goto bad;
        if(tcompat(n, l->type, r->type, tsub))
            goto bad;
    }
    arith(n, true);
    break;
@
%old: guarded by !machcap ???  necessary?

% ok this time tsub, normal.

<<function machcap(arm)>>=
/* default, like old cc */
bool
machcap(Node*)
{
    return false;
}
@
% the one in x86 is more complex





<<[[tcomo()]] switch node kind cases>>=
case OAND:
case OOR:
case OXOR:
    o = tcom(l);
    if(o | tcom(r))
        goto bad;
    <<[[tcomo()]] break if isfunct>>
    if(tcompat(n, l->type, r->type, tand))
        goto bad;
    arith(n, true);
    break;
@

<<global tand>>=
long	tand[NTYPE];
@
<<global tandinit>>=
Init	tandinit[] =
{
    TCHAR,		BINTEGER,	0,
    TUCHAR,		BINTEGER,	0,
    TSHORT,		BINTEGER,	0,
    TUSHORT,	BINTEGER,	0,

    TINT,		BNUMBER,	0,
    TUINT,		BNUMBER,	0,

    TLONG,		BINTEGER,	0,
    TULONG,		BINTEGER,	0,
    TVLONG,		BINTEGER,	0,
    TUVLONG,	BINTEGER,	0,
    -1,		0,		0,
};
@
%ocaml: do not allow int and float (clang does not)
%corner:
% can combine float and int, weird, but not long and float.




<<[[tcomo()]] switch node kind cases>>=
case OASHL:
case OASHR:
case OLSHR:
    o = tcom(l);
    if(o | tcom(r))
        goto bad;
    <<[[tcomo()]] break if isfunct>>
    if(tcompat(n, l->type, r->type, tand))
        goto bad;

    n->right = Z;
    arith(n, true);

    n->right = new1(OCAST, r, Z);
    n->right->type = types[TINT];
    <<[[tcomo()]] in OASHL/OASHR case, adjust opcode if unsigned type>>
    break;
@
\t OLSHR can appear also here? should appear after tcomo, not before

% force an int cast for right operand.
%ocaml: need that?

\l arith makes sense for OASHL without anything on the right?

% call to new1() for the first time


\subsection{Arithmetic conversions}

% tcomo -> <>
<<function arith>>=
/*
 * "the usual arithmetic conversions are performed"
 */
void
arith(Node *n, bool f)
{
    Type *t1, *t2;
    // enum<Type_kind>
    int i, j;
    // enum<Type_kind>
    int k;
    <<[[arith()]] other locals>>

    <<[[arith()]] set t1 and t2, left and right types>>
    <<[[arith()]] set i and j, etype of left and right types>>

    k = tab[i][j];

    <<[[arith()]] set node type>>

    <<[[arith()]] if substract two pointers>>
    // else
    <<[[arith()]] if left  type not sametype than node type, add OCAST>>
    <<[[arith()]] if right type not sametype than node type, add OCAST>>
    return;
bad:
    diag(n, "pointer addition not fully declared: %T", n->type->link);
}
@
% comment is a joke? probably comes from C standard or K&R and
%  underestimate the complexity of it?


<<[[arith()]] set t1 and t2, left and right types>>=
t1 = n->left->type;
if(n->right == Z)
    t2 = t1;
else
    t2 = n->right->type;
@

<<[[arith()]] set i and j, etype of left and right types>>=
i = TXXX;
if(t1 != T)
    i = t1->etype;
j = TXXX;
if(t2 != T)
    j = t2->etype;
@

% if left type is i, and right type is j, what is the result
% of arithmetic operation of i and j? tab[i][j]

% For instance if you add a char and a short, the result is a short.

%corner:
% A few notes:
%  - if one unsigned, then result is unsigned
%  - if one is pointer, then result is pointer (pointer arithmetic)
%  - if one is bigger, result is the biggest.

% some concepts:
% - balancing = make each type match for operands, so int+long => long+long
%   and so imply some form of promotion

<<global tab>>=
char	tab[NTYPE][NTYPE] =
{
  [TXXX] =	{ 0,
        },

  [TCHAR] =	{ 0,	TCHAR, TUCHAR, TSHORT, TUSHORT, TINT, TUINT, TLONG,
            TULONG, TVLONG, TUVLONG, TFLOAT, TDOUBLE, [TIND] = TIND,
        },
  [TUCHAR] =	{ 0,	TUCHAR, TUCHAR, TUSHORT, TUSHORT, TUINT, TUINT, TULONG,
            TULONG, TUVLONG, TUVLONG, TFLOAT, TDOUBLE, [TIND] = TIND,
        },
  [TSHORT] =	{ 0,	TSHORT, TUSHORT, TSHORT, TUSHORT, TINT, TUINT, TLONG,
            TULONG, TVLONG, TUVLONG, TFLOAT, TDOUBLE, [TIND] = TIND,
        },
  [TUSHORT] =	{ 0,	TUSHORT, TUSHORT, TUSHORT, TUSHORT, TUINT, TUINT, TULONG,
            TULONG, TUVLONG, TUVLONG, TFLOAT, TDOUBLE, [TIND] = TIND,
        },
  [TINT] =	{ 0,	TINT, TUINT, TINT, TUINT, TINT, TUINT, TLONG,
            TULONG, TVLONG, TUVLONG, TFLOAT, TDOUBLE, [TIND] = TIND,
        },
  [TUINT] =	{ 0,	TUINT, TUINT, TUINT, TUINT, TUINT, TUINT, TULONG,
            TULONG, TUVLONG, TUVLONG, TFLOAT, TDOUBLE, [TIND] = TIND,
        },
  [TLONG] =	{ 0,	TLONG, TULONG, TLONG, TULONG, TLONG, TULONG, TLONG,
            TULONG, TVLONG, TUVLONG, TFLOAT, TDOUBLE, [TIND] = TIND,
        },
  [TULONG] =	{ 0,	TULONG, TULONG, TULONG, TULONG, TULONG, TULONG, TULONG,
            TULONG, TUVLONG, TUVLONG, TFLOAT, TDOUBLE, [TIND] = TIND,
        },
  [TVLONG] =	{ 0,	TVLONG, TUVLONG, TVLONG, TUVLONG, TVLONG, TUVLONG, TVLONG,
            TUVLONG, TVLONG, TUVLONG, TFLOAT, TDOUBLE, [TIND] = TIND,
        },
  [TUVLONG] =	{ 0,	TUVLONG, TUVLONG, TUVLONG, TUVLONG, TUVLONG, TUVLONG, TUVLONG,
            TUVLONG, TUVLONG, TUVLONG, TFLOAT, TDOUBLE, [TIND] = TIND,
        },

  [TFLOAT] =	{ 0,	TFLOAT, TFLOAT, TFLOAT, TFLOAT, TFLOAT, TFLOAT, TFLOAT,
            TFLOAT, TFLOAT, TFLOAT, TFLOAT, TDOUBLE, [TIND] = TIND,
        },
  [TDOUBLE] =	{ 0,	TDOUBLE, TDOUBLE, TDOUBLE, TDOUBLE, TDOUBLE, TDOUBLE, TDOUBLE,
            TDOUBLE, TDOUBLE, TDOUBLE, TFLOAT, TDOUBLE, [TIND] = TIND,
        },

  [TIND] =	{ 0,	TIND, TIND, TIND, TIND, TIND, TIND, TIND,
             TIND, TIND, TIND, TIND, TIND, [TIND] = TIND,
        },
};
@
%coupling: could use designator for the nested initialiser too,
% so less depdendencies on the order of the basic types
% (I use designator for TIND only right now)
%bug? double and float should be double in TDOUBLE line.

<<[[arith()]] set node type>>=
<<[[arith()]] if result type is a pointer>>
else {
    <<[[arith()]] if [[f]], convert up to at least int>>
    n->type = types[k];
}
@


<<[[arith()]] if result type is a pointer>>=
if(k == TIND) {
    if(i == TIND)
        n->type = t1;
    else
    if(j == TIND)
        n->type = t2;
} 
@
% if one is pointer, result is pointer but want full type, with right
% Type.link, not just types[k].

%corner:
<<[[arith()]] if [[f]], convert up to at least int>>=
/* convert up to at least int */
if(f)
  while(k < TINT)
    k += 2;
@
% call arith with true for now. But we will see later
% for boolean operation we dont. In that case no up conversion for
% result.


<<[[arith()]] other locals>>=
Node *n1;
long w;
@
<<[[arith()]] if left  type not sametype than node type, add OCAST>>=
if(!sametype(n->type, n->left->type)) {
    n->left = new1(OCAST, n->left, Z);
    n->left->type = n->type;
    <<[[arith()]] pointer arithmetic with left child>>
}
@
<<[[arith()]] if right type not sametype than node type, add OCAST>>=
if(n->right != Z)
if(!sametype(n->type, n->right->type)) {
    n->right = new1(OCAST, n->right, Z);
    n->right->type = n->type;
    <<[[arith()]] pointer arithmetic with right child>>
}
@

\subsection{Pointer arithmetic}

%ocaml: do that in later phase?

% if final result is pointer, but left child was not same type,
% so not a pointer, so an integer, then must do pointer arithmetic!
\l hmm could be a pointer but with different Type.link?
\l no, would be detected before?)
% need to know the size of the pointed thing!

<<[[arith()]] pointer arithmetic with left child>>=
if(n->type->etype == TIND) {
    w = n->type->link->width;
    <<[[arith()]] if incomplete width>>
    if(w > 1) {
        n1 = new1(OCONST, Z, Z);
        n1->vconst = w;
        n1->type = n->type;
        n->left = new1(OMUL, n->left, n1);
        n->left->type = n->type;
    }
}
@

<<[[arith()]] if incomplete width>>=
if(w < 1) {
    snap(n->type->link);
    w = n->type->link->width;
    if(w < 1)
        goto bad;
}
@
% snap because incomplete structure
\t but when this happens? Type.link should be filled!

<<[[arith()]] pointer arithmetic with right child>>=
if(n->type->etype == TIND) {
    w = n->type->link->width;
    <<[[arith()]] if incomplete width>>
    if(w != 1) {
        n1 = new1(OCONST, Z, Z);
        n1->vconst = w;
        n1->type = n->type;
        n->right = new1(OMUL, n->right, n1);
        n->right->type = n->type;
    }
}
@

%corner:

% why this special code? eend - estart requires something special?
% Yes, pointer arithmetic again!
<<[[arith()]] if substract two pointers>>=
if(n->op == OSUB)
if(i == TIND && j == TIND) {
    w = n->right->type->link->width;
    if(w < 1 || n->left->type->link == T || n->left->type->link->width < 1)
        goto bad;
    n->type = types[ewidth[TIND] <= ewidth[TLONG]? TLONG: TVLONG];
    if(1 && ewidth[TIND] > ewidth[TLONG]){
        n1 = new1(OXXX, Z, Z);
        *n1 = *n;
        n->op = OCAST;
        n->left = n1;
        n->right = Z;
        n->type = types[TLONG];
    }
    if(w > 1) {
        n1 = new1(OXXX, Z, Z);
        *n1 = *n;
        n->op = ODIV;
        n->left = n1;
        n1 = new1(OCONST, Z, Z);
        n1->vconst = w;
        n1->type = n->type;
        n->right = n1;
        <<[[arith()]] when substract two pointers, convert DIV to SHR if can>>
    }
    return;
}
@
% special return type! it's a long!

\subsection{Boolean expressions}

<<[[tcomo()]] switch node kind cases>>=
case OEQ:
case ONE:
    o = tcom(l);
    if(o | tcom(r))
        goto bad;
    <<[[tcomo()]] break if isfunct>>
    <<[[tcomo()]] when OEQ/ONE, typing extensions>>
    if(tcompat(n, l->type, r->type, trel))
        goto bad;
    arith(n, false);

    n->type = types[TINT];
    break;
@
% should be TBOOL not TINT! ugly C, 

% arith(,false) here! so no up conversion to int.


<<global trel>>=
long	trel[NTYPE];
@
<<global trelinit>>=
Init	trelinit[] =
{
    TCHAR,		BNUMBER,	0,
    TUCHAR,		BNUMBER,	0,
    TSHORT,		BNUMBER,	0,
    TUSHORT,	BNUMBER,	0,
    TINT,		BNUMBER,	0,
    TUINT,		BNUMBER,	0,
    TLONG,		BNUMBER,	0,
    TULONG,		BNUMBER,	0,
    TVLONG,		BNUMBER,	0,
    TUVLONG,	BNUMBER,	0,

    TFLOAT,		BNUMBER,	0,
    TDOUBLE,	BNUMBER,	0,

    TIND,		BIND,		0,
    -1,		0,		0,
};
@




<<[[tcomo()]] switch node kind cases>>=
case OLT:
case OGE:
case OGT:
case OLE:
    o = tcom(l);
    if(o | tcom(r))
        goto bad;
    <<[[tcomo()]] break if isfunct>>
    <<[[tcomo()]] when OLT/OGE/OGT/OLE, typing extensions>>
    if(tcompat(n, l->type, r->type, trel))
        goto bad;
    arith(n, false);
    <<[[tcomo()]] when OLT/OGE/OGT/OLE, adjust opcode if unsigned type>>
    n->type = types[TINT];
    break;
@
% same code than for OEQ


% ! x
<<[[tcomo()]] switch node kind cases>>=
case ONOT:
    if(tcom(l))
        goto bad;
    <<[[tcomo()]] break if isfunct>>
    if(tcompat(n, T, l->type, tnot))
        goto bad;
    n->type = types[TINT];
    break;
@

<<global tnot>>=
long	tnot[1] =
{
    BNUMBER|BIND,
};
@
% does not look like other policy, but if you look at code
% of tcompat, if pass 'T' to first param, then just
% do b && ttab[0]

% a pointer is ok in !foo

% ~ x => xor -1 x
<<[[tcomo()]] switch node kind cases>>=
case OCOM:
    if(tcom(l))
        goto bad;
    <<[[tcomo()]] break if isfunct>>

    if(!machcap(n)) {
        r = l;
        l = new(OCONST, Z, Z);
        l->vconst = -1;
        l->type = types[TINT];
        n->op = OXOR;
        n->right = r;
        n->left = l;

        if(tcom(l))
            goto bad;
        if(tcompat(n, l->type, r->type, tand))
            goto bad;
    }
    arith(n, false);
    break;
@


<<[[tcomo()]] switch node kind cases>>=
case OANDAND:
case OOROR:
    o = tcom(l);
    if(o | tcom(r))
        goto bad;
    if(tcompat(n, T, l->type, tnot) |
       tcompat(n, T, r->type, tnot))
        goto bad;
    n->type = types[TINT];
    break;
@
%ocaml: I should impose boolean!

% does not need to have the same types. They are checked independently!

%\subsection{Unsigned adjustments}
% now in code generation chapter


\subsection{Assignments}

<<[[tcomo()]] switch node kind cases>>=
case OAS:
    o = tcom(l);
    if(o | tcom(r))
        goto bad;
    if(tlvalue(l))
        goto bad;
    <<[[tcomo()]] break if isfunct>>
    <<[[tcomo()]] when OAS, typing extension>>
    if(tcompat(n, l->type, r->type, tasign))
        goto bad;

    <<[[tcomo()]] when OAS, const checking>>
    if(!sametype(l->type, r->type)) {
        r = new1(OCAST, r, Z);
        r->type = l->type;
        n->right = r;
    }
    n->type = l->type;
    break;
@

%tlvalue, constas.

% usually called via if(tlvalue(x)) goto bad;
<<function tlvalue>>=
bool
tlvalue(Node *n)
{

    if(!n->addable) {
        diag(n, "not an l-value");
        return true;
    }
    return false;
}
@
%ocaml: just compute recursively on the fly?

% so true means not an lvalue



% passed to tcompat
<<global tasign>>=
// map<Type_kind, set<Type_kind> >
long	tasign[NTYPE];
@
\t tassign?
<<global tasigninit>>=
Init	tasigninit[] =
{
    TCHAR,		BNUMBER,	0,
    TUCHAR,		BNUMBER,	0,
    TSHORT,		BNUMBER,	0,
    TUSHORT,	BNUMBER,	0,
    TINT,		BNUMBER,	0,
    TUINT,		BNUMBER,	0,
    TLONG,		BNUMBER,	0,
    TULONG,		BNUMBER,	0,
    TVLONG,		BNUMBER,	0,
    TUVLONG,	BNUMBER,	0,

    TFLOAT,		BNUMBER,	0,
    TDOUBLE,	BNUMBER,	0,

    TIND,		BIND,		0,
    TSTRUCT,	BSTRUCT,	0,
    TUNION,		BUNION,		0,
    -1,		0,		0,
};
@
% can assign struct and union!!

<<[[stcompat()]] when t1 matches t2, if ttab is tasign>>=
if(ttab == tasign)
    if(b == BSTRUCT || b == BUNION)
        if(!sametype(t1, t2))
            return true;
@
%ocaml: have ADT for Type.t so I can do this check when I mention
% struct and unions.

% accept assigns if same types, not only if same etypes

% saw also similar thing for pointer.




<<[[tcomo()]] switch node kind cases>>=
case OASI:	/* same as as, but no test for const */
    n->op = OAS;
    o = tcom(l);
    if(o | tcom(r))
        goto bad;

    <<[[tcomo()]] when OAS, typing extension>>
    if(tlvalue(l) || tcompat(n, l->type, r->type, tasign))
        goto bad;
    if(!sametype(l->type, r->type)) {
        r = new1(OCAST, r, Z);
        r->type = l->type;
        n->right = r;
    }
    n->type = l->type;
    break;
@
% OASI is generated by doinit. assign via initializer.
% no const checking because it is not really an assign! it's the
% first time we initialize the local or global.


% for the +=, mix between OAS and OADD.
% quite regular. But policy is from tadd to tasadd.

<<[[tcomo()]] switch node kind cases>>=
case OASADD:
case OASSUB:
    o = tcom(l);
    if(o | tcom(r))
        goto bad;
    if(tlvalue(l))
        goto bad;
    <<[[tcomo()]] break if isfunct>>
    <<[[tcomo()]] when OASADD, typing extension>>
    if(tcompat(n, l->type, r->type, tasadd))
        goto bad;
    <<[[tcomo()]] when OASxxx, const checking>>
    t = l->type;
    arith(n, false);
    <<[[tcomo()]] when OASxxx, adjust node after arith>>
    break;
@

% why arith() to then undo the cast?

<<[[tcomo()]] when OASxxx, adjust node after arith>>=
<<[[tcomo()]] when OASxxx, remove casts added by arith>>
if(!sametype(t, n->type) && !mixedasop(t, n->type)) {
    r = new1(OCAST, n->right, Z);
    r->type = t;
    n->right = r;
    n->type = t;
}
@
% how it can not be the same type? because result is bigger
% than left part. 

% arith() adds some cast
<<[[tcomo()]] when OASxxx, remove casts added by arith>>=
while(n->left->op == OCAST)
    n->left = n->left->left;
@
% even if we remove the cast, the final type of n might still
% be different than the type of the left.


<<function mixedasop>>=
bool
mixedasop(Type *l, Type *r)
{
    return !typefd[l->etype] && typefd[r->etype];
}
@
%ocaml: need that?



<<global tasadd>>=
long	tasadd[NTYPE];
@
<<global tasaddinit>>=
Init	tasaddinit[] =
{
    TCHAR,		BNUMBER,	0,
    TUCHAR,		BNUMBER,	0,
    TSHORT,		BNUMBER,	0,
    TUSHORT,	BNUMBER,	0,
    TINT,		BNUMBER,	0,
    TUINT,		BNUMBER,	0,
    TLONG,		BNUMBER,	0,
    TULONG,		BNUMBER,	0,
    TVLONG,		BNUMBER,	0,
    TUVLONG,	BNUMBER,	0,

    TFLOAT,		BNUMBER,	0,
    TDOUBLE,	BNUMBER,	0,

    TIND,		BINTEGER,	0,
    -1,		0,		0,
};
@

%corner:
% not exactly the same than tadd and tsub.
% We are more restrictive here with pointers.
% you can do x - y  but not x-=y because the resulting type
% of the diff between two pointers is a long, not a pointer!




<<[[tcomo()]] switch node kind cases>>=
case OASMUL:
case OASDIV:
case OASLMUL:
case OASLDIV:
    o = tcom(l);
    if(o | tcom(r))
        goto bad;
    if(tlvalue(l))
        goto bad;
    <<[[tcomo()]] break if isfunct>>
    <<[[tcomo()]] when OASMUL/OASDIV, typing extensions>>
    if(tcompat(n, l->type, r->type, tmul))
        goto bad;
    <<[[tcomo()]] when OASxxx, const checking>>
    t = l->type;
    arith(n, false);
    <<[[tcomo()]] when OASxxx, adjust node after arith>>
    <<[[tcomo()]] when OASMUL/OASDIV, adjust opcode if unsigned type>>
    break;
@


<<[[tcomo()]] switch node kind cases>>=
case OASLSHR:
case OASASHR:
case OASASHL:
    o = tcom(l);
    if(o | tcom(r))
        goto bad;
    if(tlvalue(l))
        goto bad;
    <<[[tcomo()]] break if isfunct>>
    if(tcompat(n, l->type, r->type, tand))
        goto bad;
    n->type = l->type;
    n->right = new1(OCAST, r, Z);
    n->right->type = types[TINT];
    <<[[tcomo()]] when OASLSHR, adjust opcode if unsigned type>>
    break;
@

<<[[tcomo()]] switch node kind cases>>=
case OASMOD:
case OASLMOD:
case OASOR:
case OASAND:
case OASXOR:
    o = tcom(l);
    if(o | tcom(r))
        goto bad;
    if(tlvalue(l))
        goto bad;
    <<[[tcomo()]] break if isfunct>>
    if(tcompat(n, l->type, r->type, tand))
        goto bad;
    t = l->type;
    arith(n, false);
    <<[[tcomo()]] when OASxxx, adjust node after arith>>
    <<[[tcomo()]] when OASMOD, adjust opcode if unsigned type>>
    break;
@

\subsection{Pointers}

% call tcomo with special context, not tcom!

<<[[tcomo()]] switch node kind cases>>=
case OADDR:
    if(tcomo(l, ADDROP))
        goto bad;
    if(tlvalue(l))
        goto bad;

    <<[[tcomo()]] when OADDR, check if bitfield>>
    <<[[tcomo()]] when OADDR, check if register>>

    n->type = typ(TIND, l->type);
    n->type->width = types[TIND]->width;
    break;
@
% pass ADDROP here! but just for warning when get address of array or
%  func to say it's unnecessary
% and also because dont want the OADDR added when call tcomo with ADDROF!!


<<[[tcomo()]] switch node kind cases>>=
case OIND:
    if(tcom(l))
        goto bad;
    if(tcompat(n, T, l->type, tindir))
        goto bad;
    n->type = l->type->link;
    n->addable = true;
    break;
@
% a dereference pointer is a lvalue! you want to do *x = something

<<global tindir>>=
long	tindir[1] =
{
    BIND,
};
@




\subsection{Array accesses}

% array access are converted in pointers during parsing
% and reference to variable with a TARRAY type are converted
% in OADDR first.

\subsection{Field accesses}

<<[[tcomo()]] switch node kind cases>>=
case ODOT:
    if(tcom(l))
        goto bad;
    if(tcompat(n, T, l->type, tdot))
        goto bad;
    if(tcomd(n))
        goto bad;
    break;
@
% set addable to true in tcomd -> makedot

<<global tdot>>=
long	tdot[1] =
{
    BSTRUCT|BUNION,
};
@


% tcom DOT
<<function tcomd>>=
bool
tcomd(Node *n)
{
    Type *t;
    long o;

    o = 0;
    t = dotsearch(n->sym, n->left->type->link, n, &o);
    if(t == T) {
        diag(n, "not a member of struct/union: %F", n);
        return true;
    }
    // convert field and set n->type
    <<[[tcomd()]] convert field access in offset>>
    return false;
}
@

% tcomd -> <>
<<function dotsearch>>=
Type*
dotsearch(Sym *s, Type *t, Node *n, long *off)
{
    Type *t1, *xt, *rt;

    xt = T;

    /*
     * look it up by name
     */
    for(t1 = t; t1 != T; t1 = t1->down)
        if(t1->sym == s) {
            if(xt != T)
                goto ambig;
            xt = t1;
        }

    <<[[dotsearch()]] look by type>>

    if(xt != T) {
        *off = xt->offset;
        return xt;
    }

    <<[[dotsearch()]] if unnamed substructures>>

    return xt;

ambig:
    diag(n, "ambiguous structure element: %s", s->name);
    return xt;
}
@
%ocaml: ambiguous check done before


<<[[dotsearch()]] look by type>>=
/*
 * look it up by type
 */
if(s->class == CTYPEDEF || s->class == CTYPESTR)
    for(t1 = t; t1 != T; t1 = t1->down)
        if(t1->sym == S && typesu[t1->etype])
            if(sametype(s->type, t1)) {
                if(xt != T)
                    goto ambig;
                xt = t1;
            }
@
\t when this happens?

\subsection{Function calls}

% again here call recursively tcomo on left part without ADDROF, 
% so will not get the OADDR added automatically 
% around function (or array, but anyway obvious will not call an array)

<<[[tcomo()]] switch node kind cases>>=
case OFUNC:
    o = tcomo(l, 0);
    if(o)
        goto bad;
    <<[[tcomo()]] when OFUNC case, add OIND if pointer function call>>
    if(tcompat(n, T, l->type, tfunct))
        goto bad;
    if(o | tcoma(l, r, l->type->down, true))
        goto bad;
    n->type = l->type->link;
    <<[[tcomo()]] when OFUNC case, warn function args not checked if old proto>>
    <<[[tcomo()]] when OFUNC case, format check>>
    break;
@

<<global tfunct>>=
long	tfunct[1] =
{
    BFUNC,
};
@



% typecheck com args

% f = first?

<<function tcoma>>=
bool
tcoma(Node *l, Node *n, Type *t, bool f)
{
    Node *n1;
    int o;

    <<[[tcoma()]] start of tcoma, adjust t if TDOT>>
    <<[[tcoma()]] if no arguments>>

    // recurse over arguments and parameters
    if(n->op == OLIST) {
        o = tcoma(l, n->left, t, false);
        if(t != T) {
            t = t->down;
            if(t == T)
                t = types[TVOID];
        }
        return o | tcoma(l, n->right, t, true);
    }

    // process each argument

    if(f && t != T)
        tcoma(l, Z, t->down, false);

    if(tcom(n) || tcompat(n, T, n->type, targ))
        return true;
    <<[[tcoma()]] check if too many arguments>>
    if(t != T) {
        <<[[tcoma()]] typing extension on argument>>
        if(stcompat(nodproto, t, n->type, tasign)) {
            diag(l, "argument prototype mismatch \"%T\" for \"%T\": %F",
                n->type, t, l);
            return true;
        }
        <<[[tcoma()]] adjust type if argument with small type>>
    }
    else
        <<[[tcoma()]] adjust type when empty type>>

    if(t != T && !sametype(t, n->type)) {
        n1 = new1(OXXX, Z, Z);
        *n1 = *n;
        n->op = OCAST;
        n->left = n1;
        n->right = Z;
        n->type = t;
        n->addable = false;
    }
    return false; // everything is fine
}
@
\t f is for?

% a bit complicated. When I ported to ocaml I started from scratch
% without looking much at the code above.

<<global targ>>=
long	targ[1] =
{
    BNUMBER|BIND|BSTRUCT|BUNION,
};
@
% so you can pass everything, except a function and array
% (but this func or array will be converted to a pointer)




<<[[tcoma()]] start of tcoma, adjust t if TDOT>>=
if(t != T)
if(t->etype == TOLD || t->etype == TDOT)	/* .../old in prototype */
    t = T;
@
<<[[tcoma()]] if no arguments>>=
if(n == Z) {
    if(t != T && !sametype(t, types[TVOID])) {
        diag(n, "not enough function arguments: %F", l);
        return true;
    }
    return false;
}
@

<<[[tcoma()]] check if too many arguments>>=
if(sametype(t, types[TVOID])) {
    diag(n, "too many function arguments: %F", l);
    return true;
}
@

<<[[tcoma()]] adjust type if argument with small type>>=
switch(t->etype) {
case TCHAR:
case TSHORT:
    t = types[TINT];
    break;

case TUCHAR:
case TUSHORT:
    t = types[TUINT];
    break;
}
@
% this is why use int instead of char most of the time when char
% would be ok, because anyway they will be converted up.

<<[[tcoma()]] adjust type when empty type>>=
switch(n->type->etype)
{
case TCHAR:
case TSHORT:
    t = types[TINT];
    break;

case TUCHAR:
case TUSHORT:
    t = types[TUINT];
    break;

case TFLOAT:
    t = types[TDOUBLE];
}
@
\t what is that? pending of paramconv?

<<[[tcomo()]] switch node kind cases>>=
case ODOTDOT:
    /*
     * tcom has already been called on this subtree
     */
    *n = *n->left;
    if(n->type == T)
        goto bad;
    break;
@




<<global nodproto>>=
Node*	nodproto;
@
% dead? or just here so that error message in stcompat
%  which access n->op have a valid n->op which is OPROTO?

<<[[cinit()]] nodproto initialization>>=
nodproto = new(OPROTO, Z, Z);
@
% could be a static local of tcoma?
\t what is this for???


\subsection{Cast}

% again call tcomo with special context.

<<[[tcomo()]] switch node kind cases>>=
case OCAST:
    if(n->type == T)
        break;
    if(n->type->width == types[TLONG]->width) {
        if(tcomo(l, ADDROF|CASTOF))
            goto bad;
    } else
        if(tcom(l))
            goto bad;
    <<[[tcomo()]] break if isfunct>>
    if(tcompat(n, l->type, n->type, tcast))
        goto bad;
    break;
@
\t when can be null type??? because error?

% not an lvalue?

\t CASTOF context! but who checks it?
% nobody! so both branches are equivalent.


<<global tcast>>=
long	tcast[NTYPE];
@
<<global tcastinit>>=
Init	tcastinit[] =
{
    TCHAR,		BNUMBER|BIND|BVOID,	0,
    TUCHAR,		BNUMBER|BIND|BVOID,	0,
    TSHORT,		BNUMBER|BIND|BVOID,	0,
    TUSHORT,	BNUMBER|BIND|BVOID,	0,
    TINT,		BNUMBER|BIND|BVOID,	0,
    TUINT,		BNUMBER|BIND|BVOID,	0,
    TLONG,		BNUMBER|BIND|BVOID,	0,
    TULONG,		BNUMBER|BIND|BVOID,	0,
    TVLONG,		BNUMBER|BIND|BVOID,	0,
    TUVLONG,	BNUMBER|BIND|BVOID,	0,

    TFLOAT,		BNUMBER|BVOID,		0,
    TDOUBLE,	BNUMBER|BVOID,		0,

    TIND,		BINTEGER|BIND|BVOID,	0,
    TVOID,		BVOID,			0,
    TSTRUCT,	BSTRUCT|BVOID,		0,
    TUNION,		BUNION|BVOID,		0,
    -1,		0,			0,
};
@

% can cast a struct in a different struct?





\subsection{Ternary expressions}

% x ? (l : r) so l = r->left, r = r->right

<<[[tcomo()]] switch node kind cases>>=
case OCOND:
    o = tcom(l);
    o |= tcom(r->left);
    if(o | tcom(r->right))
        goto bad;
    <<[[tcomo()]] in OCOND, nil handling>>
    if(sametype(r->right->type, r->left->type)) {
        r->type = r->right->type;
        n->type = r->type;
        break;
    }
    if(tcompat(r, r->left->type, r->right->type, trel))
        goto bad;
    arith(r, false);
    n->type = r->type;
    break;
@
% useless code about sametype? anyway will be detected by tcompat no?
% no check compat on l?

% can not do   (x? y : z) = 3; not considered an lvalue!



<<[[tcomo()]] in OCOND, nil handling>>=
if(r->right->type->etype == TIND && vconst(r->left) == 0) {
    r->left->type = r->right->type;
    r->left->vconst = 0;
}
if(r->left->type->etype == TIND && vconst(r->right) == 0) {
    r->right->type = r->left->type;
    r->right->vconst = 0;
}
@
%ocaml: need that?
\t need that? advanced inference?


<<function vconst>>=
int
vconst(Node *n)
{
    int i;

    if(n == Z)
        goto no;
    if(n->op != OCONST)
        goto no;
    if(n->type == T)
        goto no;

    switch(n->type->etype)
    {
    case TFLOAT:
    case TDOUBLE:
        i = 100;
        if(n->fconst > i || n->fconst < -i)
            goto no;
        i = n->fconst;
        if(i != n->fconst)
            goto no;
        return i;

    case TVLONG:
    case TUVLONG:
        i = n->vconst;
        if(i != n->vconst)
            goto no;
        return i;

    case TCHAR:
    case TUCHAR:
    case TSHORT:
    case TUSHORT:
    case TINT:
    case TUINT:
    case TLONG:
    case TULONG:
    case TIND:
        i = n->vconst;
        if(i != n->vconst)
            goto no;
        return i;
    }
no:
    return -159;	/* first uninteresting constant */
}
@
% ???? wtf?
\t mv later?


\subsection{Prefix/postfix}

<<[[tcomo()]] switch node kind cases>>=
case OPREINC:
case OPREDEC:
case OPOSTINC:
case OPOSTDEC:
    if(tcom(l))
        goto bad;
    if(tlvalue(l))
        goto bad;
    <<[[tcomo()]] break if isfunct>>
    if(tcompat(n, l->type, types[TINT], tadd))
        goto bad;
    n->type = l->type;

    if(n->type->etype == TIND)
    if(n->type->link->width < 1) {
        snap(n->type->link);
        if(n->type->link->width < 1)
            diag(n, "inc/dec of a void pointer");
    }
    break;
@
% note that not converted to x = x +1; Because special opcodes?

\subsection{[[sizeof()]]}

% for osize with call tcomo with special context,
% because dont want the OADDR trick applied if ask for
% the size of an array! otherwise will get the sizeof a pointer
% instead of size of full array!

<<[[tcomo()]] switch node kind cases>>=
case OSIZE:
    if(l != Z) {
        if(l->op != OSTRING && l->op != OLSTRING)
            if(tcomo(l, 0))
                goto bad;
        <<[[tcomo()]] when OSIZE, check if sizeof bitfield>>
        n->type = l->type;
    }
    <<[[tcomo()]] when OSIZE, sanity check n>>
    n->op = OCONST;
    n->left = Z;
    n->right = Z;
    n->vconst = convvtox(n->type->width, TINT);
    n->type = types[TINT];
    break;
@
% why special code for OSTRING? because if call tcomo it will
% convert it to an ONAME and you will lose the type information?

% CIL says that result of sizeof is unsigned, but here it is signed.
% bug 5c?

<<[[tcomo()]] when OSIZE, sanity check n>>=
if(n->type == T)
    goto bad;
if(n->type->width <= 0) {
    diag(n, "sizeof undefined type");
    goto bad;
}
if(n->type->etype == TFUNC) {
    diag(n, "sizeof function");
    goto bad;
}
@


\section{Typechecking statements}


\subsection{Return}

% remember that node typed with return type during parsing.

<<[[tcomo()]] switch node kind cases>>=
case ORETURN:
    if(l == Z) {
        if(n->type->etype != TVOID)
            warn(n, "null return of a typed function");
        break;
    }
    if(tcom(l))
        goto bad;
    <<[[tcomo()]] when ORETURN, typing extensions>>
    if(tcompat(n, n->type, l->type, tasign))
        break;
    <<[[tcomo()]] when ORETURN, const checking>>
    if(!sametype(n->type, l->type)) {
        l = new1(OCAST, l, Z);
        l->type = n->type;
        n->left = l;
    }
    break;
@

\subsection{Switch}

% for if, we accept anything, but for switch
% we want to typecheck that does not pass a pointer!
% so we can abuse expression typechecker for that!

<<ulstmt rule, SWITCH case, adjust cexpr node>>=
// generate (0:int - (0:int - x))
// which will force the usual arithmetic conversions
// (and will be simplified later by some transformations)

$$ = new(OCONST, Z, Z);
$$->vconst = 0;
$$->type = types[TINT];
$3 = new(OSUB, $$, $3);

$$ = new(OCONST, Z, Z);
$$->vconst = 0;
$$->type = types[TINT];
$3 = new(OSUB, $$, $3);
@
% I originally thought there was a copy paste bug above,
% and even Rob Pike thought so, but it turned out it's not a bug :)
% why 0 - 0 - x? why not 0+x?
%"you can't subtract pointers from 0 but you can add 0 to a pointer,
%since + is commutative" forsith
%less: could use Node *n; local instead of $$.
%codegen: mv later?

% 

<<[[gen()]] when OSWITCH, typecheck condition>>=
if(!typeswitch[l->type->etype]) {
    diag(n, "switch expression must be integer");
    break;
}
@

% set of type supported for switch argument
<<global typeswitch>>=
// set<Type_kind>
char*	typeswitch;
@
% redundant since anyway do the 0 - 0 - x trick?
% no because forbid also vlong, see typechl below.

<<[[tinit()]] initialise 32 bits defaults type sets>>=
typeswitch = typechl;
@


<<global typechl>>=
char	typechl[NTYPE];
@
<<global typechlinit>>=
int	typechlinit[] =
{
    TCHAR, TUCHAR, TSHORT, TUSHORT, TINT, TUINT, TLONG, TULONG, -1,
};
@
% similar to typei[] but no vlong!






\subsection{If}

% some typecheck done in bcomplex called during code generation,
% not in tcomo().

<<[[bcomplex()]] typecheck n>>=
if(n->type != T)
   if(tcompat(n, T, n->type, tnot))
      n->type = T;
@
%ocaml: should do this check in typecheck.ml, and should raise
% error

% tnot is pointer or number

\section{Typechecking declarations and constant evaluation}

\subsection{Enumerations}

% Seen already a bit of typechecking code with En structure,
% and En.tenum and En.cenum and the call to maxtype!

% 5c also computes values of enumeration constants during parsing!

<<[[En]] value fields>>=
vlong	lastenum;	/* value of current enum */
double	floatenum;	/* value of current enum */ // for floats enums
@
%ocaml: support only integer enum (who uses float enums??)

\t can have float enumeration?? where this is used? extension? Ansi C?

% vlong! so can have 64 bitsets


<<[[doenum()]] typecheck and evaluate expression>>=
complex(n); // will call evconst()
@

<<[[doenum()]] save current value of enumeration constant>>=
if(typefd[en.cenum->etype])
    en.floatenum = n->fconst;
else
    en.lastenum = n->vconst;
@



% remember value of enum in symbol table.

<<[[Sym]] enum value fields>>=
vlong	vconst;
double	fconst;
@
% computed value for the enum, different from vconst/fconst in Node.
% Save in symbol for enumeration constant, so when reference it,
% you can get the value (used in expression evaluation!)

<<[[doenum()]] set value for symbol>>=
if(typefd[s->tenum->etype]) {
    s->fconst = en.floatenum;
    en.floatenum++;
} else {
    s->vconst = convvtox(en.lastenum, s->tenum->etype);
    en.lastenum++;
}

@

<<function maxtype>>=
/*
 * this routine is very suspect.
 * ANSI requires the enum type to
 * be represented as an 'int'
 * this means that 0x81234567
 * would be illegal. this routine
 * makes signed and unsigned go
 * to unsigned.
 */
Type*
maxtype(Type *t1, Type *t2)
{

    if(t1 == T)
        return t2;
    if(t2 == T)
        return t1;
    if(t1->etype > t2->etype)
        return t1;
    return t2;
}
@



\subsection{Arrays}


<<[[dodecl()]] locals>>=
long v;
@
<<[[dodecl()]] switch node kind cases, case OARRAY, if array has a size>>=
t->width = 0; // array[], size could be set by doinit (or specified in n1)
if(n1 != Z) {
    complex(n1); // will call evconst()
    v = (n1->op == OCONST) ? n1->vconst : -1;
    if(v <= 0) {
        diag(n, "array size must be a positive constant");
        v = 1;
    }
    t->width = v * t->link->width;
}
@
% OCONST can be a float, but code above checks not a float with -1 trick.

% Can compute the width!


\subsection{Functions}

<<[[fnproto1()]] when OPROTO case, adjust parameter type>>=
if(lastdcltype != T)
    *t = *paramconv(lastdcltype, true);
@

<<[[pdecl()]] adjust type>>=
t = paramconv(t, class==CPARAM);
@
% when class != CPARAM? never ... see code of pdecl



% fnproto1 | pdecl -> <>
% f is for parameter context (class==CPARAM)
% this transform array and function type in something simpler
<<function paramconv>>=
Type*
paramconv(Type *t, bool f)
{

    switch(t->etype) {
    <<[[paramconv()]] switch etype cases>>
    <<[[paramconv()]] switch etype, adjust type when not f cases>>
    }
    return t;
}
@



<<[[pdecl()]] sanity check type>>=
if(typesu[t->etype] && t->width <= 0)
    diag(Z, "incomplete structure: %s", t->tag->name);
@
% pass by value struct



<<[[paramconv()]] switch etype, adjust type when not f cases>>=
case TFLOAT:
    if(!f)
        t = types[TDOUBLE];
    break;

case TCHAR:
case TSHORT:
    if(!f)
        t = types[TINT];
    break;

case TUCHAR:
case TUSHORT:
    if(!f)
        t = types[TUINT];
    break;
@
\t when not f case?







\subsection{Typedef expansions}

% done at parsing time.
% Add in symbol table type value for symbol, like do when
% declare a variable.
% But when refers to it, copy the type!

%|   LTYPE { $$ = tcopy($1->type); }

<<function tcopy>>=
/*
 * make a copy of a typedef
 * the problem is to split out incomplete
 * arrays so that it is in the variable
 * rather than the typedef.
 */
Type*
tcopy(Type *t)
{
    Type *tl, *tx;
    int et;

    if(t == T)
        return t;
    et = t->etype;
    if(typesu[et])
        return t;

    tl = tcopy(t->link); // go deep

    if((et == TARRAY && t->width == 0) || tl != t->link) {
        tx = copytyp(t);
        tx->link = tl;
        return tx;
    }
    return t;
}
@
%old: I reverse order of || because that is what triggers the chain of !=
% for t->link

%ocaml: why do you allow typedef incomplete arrays?


%\section{Typing extensions}
% now in adv topics


\section{Lint checking}

% good checks :) used/set ! good warnings. gcc sucks, it does not even
% have that (or it's not by default maybe).

% 5c -V enable void* conversion warnings
% 5c -w print warnings

\subsection{Unused variables}

% the data structure

<<[[Sym]] identifier value, checking fields>>=
bool	aused;
@
%ocaml: separate analysis in check.ml, no need abuse symbol table

<<[[syminit()]] remaining initialisations>>=
s->aused = false;
@
% if shadow past variable, set aused again to false in adecl.
% (remember that field saved in push1 and restored in revertdcl)
<<[[adecl()]] initialize symbol>>=
s->aused = false;
@

<<name rule, LNAME case, adjust more fields>>=
$1->aused = true;
@
%$
% during parsing, a bit ugly.

<<[[reverdcl()]] DAUTO case, warn if auto declared but not used>>=
if(!s->aused) {
    nearln = s->varlineno;
    if(s->class == CAUTO)
        warn(Z, "auto declared and not used: %s", s->name);
    if(s->class == CPARAM)
        warn(Z, "param declared and not used: %s", s->name);
}
@
% nice!
%ocaml: I merged the error message

\subsection{Used before set}

\t which code does that?


\subsection{False positives silencing, [[SET()/USED()]]}
% like fallthrough, to remove false positives or true positives which are ok.

% Why have false positives? limitations? bugs? or normal?

% the parsing

<<token declarations>>=
%token  LUSED LSET 
@

<<[[itab]] entries, kencc extensions>>=
"SET",		LSET,		0,
"USED",		LUSED,		0,
@

<<statement nodes>>=
OUSED,
OSET,
@
% in AST!

<<ulstmnt rule>>=
|   LUSED '(' zelist ')' ';' { $$ = new(OUSED, $3, Z); }
|   LSET '(' zelist ')' ';'  { $$ = new(OSET, $3, Z); }
@


% the check?

% for USED if the local is mentionned, then there will be an LNAME
% occurrence.
% for SET?

% the code generation

<<[[gen()]] switch node kind cases>>=
case OSET:
case OUSED:
    usedset(n->left, o);
    break;
@

% gen -> <>
<<function usedset>>=
void
usedset(Node *n, int o)
{
    if(n->op == OLIST) {
        usedset(n->left, o);
        usedset(n->right, o);
        return;
    }

    complex(n);

    switch(n->op) {
    case ONAME:
        if(o == OSET)
            gins(ANOP, Z, n);
        else
            gins(ANOP, n, Z);
        break;
    <<[[usedset()]] switch node op cases>>
    }
}
@
% call complex to evaluate constants and transform them in OCONST
% so realy ONAME here.

% normal to generate ANOP for LUSED. goal is to shut
% the lint checking, but code generation should be empty.
%less: for LSET?

%those ANOP with arguments are weird,
%less: used in regopt?

\subsection{Redeclared or unused labels}

% abuse Node.complex and Node.addable to track the def and use of labels.
% Node.complex = definition
% Node.addable = use.

<<[[dcllabel()]] when new label, set def and use fields>>=
n->complex = defcontext;
n->addable = !defcontext;
@
%ocaml: ugly, I use a separate usedef type in check.ml

% either defined or used, but not both.
% When goto => pass defcontext = false, when label: => pass defcontext = true

<<[[dcllabel()]] if n not null, mark node as declared or used>>=
if(n != Z) {
    if(defcontext) {
        if(n->complex)
            diag(Z, "label reused: %s", s->name);
        n->complex = true;	// declared
    } else
        n->addable = true;	// used
    return n;
}
@
%ocaml: ugly abuses of complex and addable field here,
% I print better error message when redefine with original loc of first def
% (a la clang)

% use two fields because want to detect redeclared labels, and
% unused labels.
%less: cleanup abuse of complex/addable, do like in scheck field for used

% where check that all labels were used? in revertdcl, see
%  Check chapter.
%ocaml: mix too many concerns at the same time; In parsing we should
% just parse and name!

<<[[reverdcl()]] DLABEL case, warn if label not used>>=
if(s->label && !s->label->addable)
    warn(s->label, "label declared and not used \"%s\"", s->name);
@
% ugly this abuse of addable, why not using lblaused instead?

% the check for use of undeclared is done in cgen(), once
% parsed the whole function.
%ocaml: in check.ml

\subsection{Unreachable code}

<<global canreach>>=
bool	canreach;
@
%ocaml: Those globals crosscuts a lot the assemby generation part.
% a bit ugly. Would have been better to have an intermediate
% CFG DS and then do the unreachable code on it.
%update: probably dont even need CFG, just visit statements with environment
% about canreach and returning it

% once we processed a ORETURN in a OLIST, then for sure
% the code after is not reachable.

<<global warnreach>>=
bool	warnreach;
@
% set in codgen(), used in gen()
\t when want to disable warn reach? when already did find one?
%ocaml? use exn so no need, warn at first and stop


<<[[codgen()]] initialisation before call to gen>>=
canreach = true;
warnreach = true;
@



<<[[gen()]] if not canreach>>=
if(!canreach) {
    switch(o) {
    case OLABEL:
    case OCASE:
    case OLIST:
    case OCOMMA:
    case OBREAK:
    case OFOR:
    case OWHILE:
    case ODWHILE:
        /* all handled specially - see switch body below */
        break;
    default:
        if(warnreach) {
            warn(n, "unreachable code %O", o);
            warnreach = false;
        }
    }
}
@
% OLABEL can be accessed from a goto, so even if cant reach
% after regular sequence because there was a RETURN before, it
% does not mean it can not be reached
% (if there is no goto to this label, 5c will warn about unused label at least)
% OCASE is here for same reason.

% no OCONTINUE? because no need special handle, go through default and warning
% 'switch body below'? where is it?

\subsubsection{If}

% in gen for OIF:
%    err = bcomplex(l, n->right);
% pass boolean cond and then part.


<<[[bcomplex()]] check for deadheads>>=
if(c != Z && n->op == OCONST && deadheads(c))
    return true;
@
% what is c here? then part?


% deadheads -> <>
% return false if it is possible to jump in the middle of n
%  that is if there is a label:
% less: rewrite as a possibive form ... would be clearer?
<<function deadhead>>=
/*
 * return true if it is impossible to jump into the middle of n.
 */
static bool
deadhead(Node *n, bool caseok)
{
loop:
    if(n == Z)
        return true;

    switch(n->op) {

    case OCASE:
        if(!caseok)
            return false;
        goto rloop;
    case OLABEL:
        return false;



    case OLIST:
        if(!deadhead(n->left, caseok))
            return false;
    rloop:
        n = n->right;
        goto loop;


    case OWHILE:
    case ODWHILE:
    case OFOR:
        goto rloop;


    case OIF:
        return deadhead(n->right->left, caseok) && 
               deadhead(n->right->right, caseok);

    case OSWITCH:
        return deadhead(n->right, true);


    case ORETURN:
    case OGOTO:
    case OCONTINUE:
    case OBREAK:
        return true;

    case OSET:
    case OUSED:
        return true;
    }
    return true;
}
@

% gen | bcomplex -> <>
<<function deadheads>>=
bool
deadheads(Node *c)
{
    return deadhead(c->left, false) && deadhead(c->right, false);
}
@
% called from bcomplex with an OLIST being a OPAIR(thenst, elsest)








<<[[gen()]] locals>>=
bool f;
@
<<[[gen()]] switch node kind cases, OIF case, if bcomplex error>>=
if(err) {
    if(typefd[l->type->etype])
        f = !l->fconst;
    else
        f = !l->vconst;
    if(debug['c'])
        print("%L const if %s\n", nearln, f ? "false" : "true");

    if(f) {
        canreach = true;
        supgen(n->right->left);
        oldreach = canreach;
        canreach = true;
        gen(n->right->right);
        /*
         * treat constant ifs as regular ifs for 
         * reachability warnings.
         */
        if(!canreach && oldreach && debug['w'] < 2)
            warnreach = false;
    } else {
        canreach = true;
        gen(n->right->left);
        oldreach = canreach;
        canreach = true;
        supgen(n->right->right);
        /*
         * treat constant ifs as regular ifs for 
         * reachability warnings.
         */
        if(!oldreach && canreach && debug['w'] < 2)
            warnreach = false;
        canreach = oldreach;
    }
}
@
% what is default value for non constant node of fconst and vconst??
% zero?

\subsubsection{[[supgen()]]}

<<global suppress>>=
bool	suppress;
@
% often do warneach = !suppress. not sure why. related to supgen
\t what is that?

% wrapper around gen() that suppress reachable warning
<<function supgen>>=
void
supgen(Node *n)
{
    bool owarn;
    long opc;
    Prog *olastp;

    if(n == Z)
        return;

    suppress++;
    owarn = warnreach;
    opc = pc;
    olastp = lastp;

    warnreach = false;

    gen(n);

    lastp = olastp;
    olastp->link = nil;
    pc = opc;
    warnreach = owarn;
    suppress--;
}
@



\subsection{Missing return}
% related to unreachable code

% -B?

<<[[codgen()]] warn for possible missing return after call to gen>>=
if(canreach && thisfntype->link->etype != TVOID){
    if(debug['B'])
        warn(Z, "no return at end of function: %s", n1->sym->name);
    else
        diag(Z, "no return at end of function: %s", n1->sym->name);
}
@
% ANSI C is diag instead of warn!

% clang automatically transforms last expression as a return?

\subsection{Unused expression}

% later in cgenrel()

<<[[cgenrel()]] nullwarn check if nn is null>>=
if(nn == Z) {
    nullwarn(l, r);
    break;
}
@

% this in cc/pswt.c but should be in a cc/pcgen.c
<<function nullwarn>>=
void
nullwarn(Node *l, Node *r)
{
    warn(Z, "result of operation not used");
    if(l != Z)
        cgen(l, Z);
    if(r != Z)
        cgen(r, Z);
}
@
%less: mv also in Checking section?



<<[[cgenrel()]] warn if target node is nil>>=
if(nn == Z) {
    switch(o) {
    case OINDEX:
        nullwarn(l, r);
        break;
    default:
        nullwarn(Z, Z);
        break;
    }
    return;
}
@
% what is this OINDEX??





\subsection{Constant if, [[5c -c]]}

% print if constant value in if statement
% not printed by default because lots of people write
% if(1) { } so you have to add -c to get the warnings

\subsection{Out of range shifting}

% will see ccom later. it simplifies the AST and
% do some constant evaluation, so code below can trigger more often.

<<[[ccom()]] when OASHR/OASHL/OLSHR, check for stupid shift>>=
if(r->op == OCONST) {
    t = n->type->width * 8;	/* bits per byte */
    if(r->vconst >= t || r->vconst <= -t)
        warn(n, "stupid shift: %lld", r->vconst);
}
@



<<[[ccom()]] switch node kind cases>>=
case OAS:
case OASADD:
case OASSUB:
case OASMUL:
case OASLMUL:
case OASDIV:
case OASLDIV:
case OASMOD:
case OASLMOD:
case OASASHR:
case OASASHL:
case OASLSHR:
case OASAND:
case OASOR:
case OASXOR:
    ccom(l);
    ccom(r);
    if(n->op == OASLSHR || n->op == OASASHR || n->op == OASASHL)
      if(r->op == OCONST) {
        t = n->type->width * 8;	/* bits per byte */
        if(r->vconst >= t || r->vconst < 0)
            warn(n, "stupid shift: %lld", r->vconst);
    }
    break;
@
%pad: changed order of OAxxx, more consistent
%ocaml: ugly abuse t that is not a type here but a number of bits

\t why not separate stuff for OASLHR and let generic recursor for the other?


\subsection{Useless comparisons}

% see compar()



\section{Const checking}

<<[[tcomo()]] when OAS, const checking>>=
constas(n, l->type, r->type);
@
<<[[tcomo()]] when OASxxx, const checking>>=
constas(n, l->type, r->type);
@



% qualifiers were called garbage, so I guess ken does
% not respect that much const.

% check for const
% il = initial l, ir = initial r
<<function constas>>=
void
constas(Node *n, Type *il, Type *ir)
{
    Type *l, *r;

    l = il;
    r = ir;

    if(l == T)
        return;
    if(l->garb & GCONSTNT) {
        warn(n, "assignment to a constant type (%T)", il);
        return;
    }
    if(r == T)
        return;
    for(;;) {
        if(l->etype != TIND || r->etype != TIND)
            break;
        l = l->link;
        r = r->link;
        if(l == T || r == T)
            break;
        if(r->garb & GCONSTNT)
            if(!(l->garb & GCONSTNT)) {
                warn(n, "assignment of a constant pointer type (%T)", ir);
                break;
            }
    }
}
@

<<[[tcomo()]] when ORETURN, const checking>>=
constas(n, n->type, l->type);
@
% when RETURN? if function return a const int? possible?


%\section{Format's arguments checking}
% cool, like in ocamlc!
% now in adv topics




\chapter{Assembly Generation}
% Code Generation?

\section{Overview}

% 5c/8c/... do not use an intermediate language :( not even an RTL :(
% They generate directly (arch-specific) assembly 
% (or actually object-code, because they use PC directly, not assembly labels).
% But they have kinda factorized a few things behind some
% common interface: gpseudo(), gins(), gmove(), gbranch(), as well
% as some REGRET, REGARG.
% So at least some of the statement code generator is portable.
% (but probably lcc backend part is cleaner)
% Moreover, ARM assembly is quite simple and regular (even more
% with the few abstractions 5a provides like MOVW, big constants, etc),
% so maybe not a too bad choice. RTL could look quite similar to Asm5.

% gbranch(), gmove(), are arch-independent interfaces.
%  cc2/pgen.c include gc.h where all archi define some kinda archi independent
%  stuff like ATEXT, ANOP, etc
% gins() seems more archi dependent but can also do arch independent
%  when the opcode is quite general (e.g. ANOP)

% target language = Prog, Adr, as, etc, like in Linker and assembler.
% outcode(), like in Assembler.
% helps to understand Assembler.nw for ARM

% use 5c -N -S to disable opti and to show the simple assembly output
% for a C file (can even compare with gcc -S).
% See also http://godbolt.org/

% remember in cc.y for function definition case:
%        if(!debug['a'] && !debug['Z'])
%            codgen($6, $2); // !!!!!!!!!!!!!!!!!!!!!

% main -> compile -> yyparse -> codgen (func) -> gen (statement) -> cgen (expr)
% The code to handle toplevel globals is in gclean(). Moreover
% the code of toplevel globals defined by initializer is handled in doinit().

% will visit the AST and generate recursively the code mostly.

% Assume nodes are properly annotated, especially the one concerning
% entities. Structure are resolved, typedef expanded, enumeration values
% resolved, storage and types adjusted, etc.

% Some of the code generation is done during typechecking as tcomo
% transforms certain nodes in other nodes 
% (e.g., ONAME in OCONST for enumeration constants, OSTRING in ONAME)
% but I tried to aspectized some of those code generation code
% and so this code will be presented in this chapter (even if it
% really code from tcomo()).

%LLVM IR would be better?
%https://idea.popcount.org/2013-07-24-ir-is-better-than-assembly/
%5a does a bit too: abstract away RET, general MOVW, but still
% hardcoded register names.

\section{[[pc]], [[p]], and [[nextpc()]]}

% as we visit we will create new ASM instructions, linked
% together that will be then serialized and written to a file
% (see outcode()). So nextpc() is here to create those new instruction
% and increment the pc (virtual) global counter.

<<global pc>>=
long	pc;
@
%ocaml: use environment and mutable field (env.pc) instead of global

<<[[ginit()]] pc initialisation>>=
pc = 0;
@
% seems archi independent ... could be in a gginit() (generic globals init)?

% gins | gclean | ... -> <>
<<function nextpc>>=
void
nextpc(void)
{

    p = alloc(sizeof(Prog));
    *p = zprog;
    p->lineno = nearln; // for origin tracking in db (from assembly to C)
    pc++;

    // add_tail(p, firstp/lastp)
    if(firstp == P) {
        firstp = p;
        lastp = p;
        return;
    }
    lastp->link = p;
    lastp = p;
}
@
%ocaml: use array instead of list, and pass explicit line number not nearln,
% and call it add_instr, no fake zprog.

% pc useful for what? for jumps, see patch(),
% and spc. Note that after nextpc() the value of pc is to
% jmp just after this newly generated instruction!
%less: could do p->pc = pc; no?
%note: the use of nearln!!! so can trace back the source code that generated
%  this ASM instructions, very useful for the debugger.

% current? see nextpc()?
<<global p>>=
Prog*	p;
@
%ocaml: use instead env.pc to modify an instr, and add_fake_instr returning
% pc for this fake instr just inserted. This avoid duplicated code
% like continpc = pc; gbranch(OGOTO); sp = p.

% often have a 'sp' for save p, and do things like
% gxxx(); sp = p;   to remember what was the instruction generated
% by this gxxx()






% like in Linker.nw
<<global firstp>>=
// list<ref_own<Prog> (next = Prog.link, last = lastp)
Prog*	firstp;
@
<<[[Prog]] extra fields(arm)>>=
// list<ref<Prog>> (head = firstp)
Prog*	link;
@
%ocaml: use (growing) array of instrs

<<constant P>>=
#define	P	((Prog*)nil)
@

<<global lastp>>=
// ref<Prog> (head = firstp)
Prog*	lastp;
@

% firstp/lastp are used only by outcode() (and nextpc())

<<[[ginit()]] misc initialisations>>=
firstp = P;
lastp = P;
@



<<[[gclean()]] generate last opcode, AEND>>=
nextpc();
p->as = AEND;
@
%ocaml: no need AEND, boundary between objects in archive is clear.


\section{Functions, [[codgen()]]}

% Finally! codgen! called from yyparse.

% n = node of the blocks OLIST, nn = node of the xdecor (should be ONAME)
%  (nn = name node, sp = saved p)
% cc2/pgen.c  
% main -> compile -> yyparse -> <>
<<function codgen>>=
//@Scheck: used by cc.y
void codgen(Node *n, Node *nn)
{
    Prog *sp;
    <<[[codgen()]] locals>>

    <<[[codgen()]] initialisation>>
    <<[[codgen()]] set n1 node to node in nn where have ONAME>>
    nearln = nn->lineno;

    gpseudo(ATEXT, n1->sym, nodconst(stkoff));
    sp = p;

    <<[[codgen()]] if complex return type>>
    <<[[codgen()]] if use REGARG>>

    <<[[codgen()]] initialisation before call to gen>>
    // generate the assembly for the statements in the body
    gen(n);

    <<[[codgen()]] warn for possible missing return after call to gen>>
    <<[[codgen()]] before RET>>
    gbranch(ORETURN);

    <<[[codgen()]] register optimisation>>
    
    sp->to.offset += maxargsafe;
}
@
%ocaml: generate fake_instr first and then overwrite
%dead:
%<<[[codgen()]] initialisation>>=
%hasdoubled = false;
%@
%<<global hasdoubled>>=
%bool	hasdoubled;
%@
%    if(thechar=='6' || thechar=='7' || thechar=='9' || hasdoubled)	/* [sic] */
%        maxargsafe = round(maxargsafe, 8);
%% seems dead


% += this time because set with stkoff at first.
% but why offset can change? because introduce new hidden locals?
% the regxxalloc() apparently can modify maxargsafe
\t when stkoff is not 0 at the beginning of codegen?

%todo: for stkoff, it's size of locals, which will then be translated
% by the assembler in some final machine code! which is?



<<[[codgen()]] locals>>=
Node *n1;
@
<<[[codgen()]] set n1 node to node in nn where have ONAME>>=
/*
 * isolate name
 */
for(n1 = nn;; n1 = n1->left) {
    if(n1 == Z) {
        diag(nn, "cant find function name");
        return;
    }
    if(n1->op == ONAME)
        break;
}
@
%ocaml: use func_def.f_name, easy, no need visit list
\t in which case the ONAME is not directly there??


% gpseudo call with nodconst().

<<global constnode>>=
Node	constnode;
@
<<[[ginit()]] special nodes initialisation>>=
constnode.op = OCONST;
constnode.class = CXXX;
constnode.complex = 0;
constnode.addable = 20;
constnode.type = types[TLONG];
@
%ocaml: precise AST for object code, no need abuse naddr(); can
% pass directly simple int

% addable 20 for OCONST, see xcom()
% complexity is 0 cos very simple, no need register.
\t maybe have a typedef Node NodeReg; typedef Node NodeAdr;?
\t  so clearer interface


<<function nodconst>>=
Node*
nodconst(long v)
{
    constnode.vconst = v;
    return &constnode;
}
@
% it's because gpseudo expect a Node and call naddr(&p->to)


\subsection{[[gpseudo()]]}

% codgen(function generation) | gextern -> <>
<<function gpseudo(arm)>>=
void
gpseudo(int a, Sym *s, Node *n)
{

    nextpc();

    p->as = a;
    p->from.type = D_OREG;
    p->from.sym = s;
    p->from.symkind = (s->class == CSTATIC) ? N_INTERN : N_EXTERN;
    <<[[gpseudo()]] if TEXT, set possible TEXT attributes>>
    naddr(n, &p->to);
    if(a == ADATA || a == AGLOBL)
        pc--;
}
@
%ocaml: generate directly precise AST, no need wrapper, use entity_of_id
% (but wrapper then make code more portable?)

% pc--, like in Assembler?

% naddr()? later. For now node is mostly a constant
% so naddr() should set p->to.offset to value in Node.vconst



\subsection{[[gbranch()]]}

<<function gbranch(arm)>>=
void
gbranch(int o)
{
    int a;

    nextpc();

    switch(o) {
    case ORETURN: a = ARET; break;
    case OGOTO:   a = AB;   break;
    default:
        a = AGOK;
        diag(Z, "bad in gbranch %O",  o);
        nextpc();
    }
    p->as = a;
}
@
%ocaml: again generate directly precise AST 
% (but then less portable?)

%the p->to will be set later by patch(), see below.
%less: 386 is just AB -> JMP, should factorize!!
%what generates ABL then? gen() with case on OFUNC probably.

\subsection{[[patch()]]}
% quite important for control flow generation.

% gmove | gen | ... -> <>
<<function patch>>=
void
patch(Prog *op, long pc)
{

    op->to.type = D_BRANCH;
    op->to.offset = pc;
}
@
%ocaml: same, but check original instruction was indeed a branching instr

% usually do  gbranch(xxx); sp = p; ...; patch(sp, pc);


\subsection{Offset}

% stkoff, autoffset, Node.xoffset, lots of stuff done
% at parsing time.

<<global stkoff>>=
long	stkoff;
@
% stack offset, used for ATEXT generation in codgen()
% to compute the set of locals we need
\t not always 0?


<<global autoffset>>=
long	autoffset;
@
%ocaml: mutable field in Codegen5.env

% seen save and restored in markdcl() and revertdcl()
% Why need to restore? because can have nested locals,
% and in that case can use same space for those independent locals.
% (opti)

<<[[cinit()]] namespace globals initialization>>=
autoffset = 0;
@
%ocaml: can put in a separate environment? local to separate module?



<<[[argmark()]] initializations>>=
autoffset = align(0, thisfntype->link, Aarg0);
stkoff = 0;
@

% align later
% for each parameter, stkoff will grow, see adecl().

<<[[argmark()]] finalizations>>=
autoffset = 0;
stkoff = 0;
@
\t so stkoff always 0 when start codegen??
% put back autoffset to 0 since restart with 0 offset for locals.


<<[[Sym]] identifier value, code generation fields>>=
long	offset;
@
%ocaml: extra hashtbl in Codegen5.env.offsets

%todo: hmm seems used for CEXREG, flow fron exreg -> o -> xdecl -> offset field.

<<[[Node]] code generation fields>>=
long	xoffset;
@
%ocaml: extra hashtbl in Codegen5.env.offsets, no need store in node
% because can rely on global symbol table without name conflict (thx to blockid)


% this is for ONAME after some resolving for params and locals
% and for OREGISTER and OINDREG (in addition to reg)
\t why xoffset? already a Node.offset?

\section{Statements, [[gen()]]}
\n do not mimic parsing chapter subsections; show simple stuff first.

% codgen -> <>
% cc2/pgen.c
<<function gen>>=
void
gen(Node *n)
{
    // enum<Node_kind> of a statement
    int o;
    <<[[gen()]] locals>>

loop:
    if(n == Z)
        return;

    nearln = n->lineno;
    o = n->op;
    <<[[gen()]] debug opcode>>
    <<[[gen()]] if not canreach>>
    switch(o) {
    <<[[gen()]] switch node kind cases>>
    }
}
@
%ocaml: no need null check, empty statement in empty Block

% 'if not canreach' explained in Checking chapter.

\subsection{Blocks, sequences}

<<[[gen()]] switch node kind cases>>=
case OLIST:
case OCOMMA:
    gen(n->left);

rloop:
    n = n->right;
    goto loop;
@

% a;b is like a,b

\subsection{Conditionals}

%\subsubsection{Code generation}


% see Parsing section to remember how an OIF tree is
% represented, with what is l(the cond) and r(a pair OLIST of then and else)

% if e { thenst } else { elsest }
% ->
%   <code e>       <-- bcomplex
%   ABxx elsepc    <-- bcomplex
%   <code thenst>
%   AB endpc
%   elsepc:
%   <code elsest>
%   endpc:
%note that endpc is after the last instruction of elsest, because
% of the way nextpc() works!.

<<[[gen()]] locals>>=
Prog *sp;
Node *l;
bool err;
@
% saved prog
<<[[gen()]] switch node kind cases>>=
case OIF:
    l = n->left;
    err = bcomplex(l, n->right);
    <<[[gen()]] switch node kind cases, OIF case, if bcomplex error>>
    else {
        sp = p; // AB instr for 'else' to patch later (created by bcomplex())
        <<[[gen()]] when OIF, before gen then part, set canreach>>

        if(n->right->left != Z) // gen then part
            gen(n->right->left); 

        <<[[gen()]] when OIF, before gen else part, save and set canreach>>

        if(n->right->right != Z) { // gen else part
            gbranch(OGOTO);
            patch(sp, pc);
            sp = p;
            gen(n->right->right);
        }
        patch(sp, pc);

        <<[[gen()]] when OIF, after gen everything, set canreach>>
    }
    break;
@
%ocaml: use exn for bcomplex and return spc

% passing n->right in complex() is for deadends detection??
%ocaml? mv that later?

% bcomplex(), boolean_complex()

% bcomplex will call boolgen which will create the necessary
% instructions
% less: but where have ABNE? gbranch seems to create only
% AB instructions. and patch() only modify the pc of the
% branching opcode. Who sets ABNE? gopcode()

<<[[gen()]] locals>>=
bool oldreach;
@
% local this time! but ugly to save/restore.
%ocaml: pass in environment?

<<[[gen()]] when OIF, before gen then part, set canreach>>=
canreach = true;
@
<<[[gen()]] when OIF, before gen else part, save and set canreach>>=
oldreach = canreach;
canreach = true;
@
<<[[gen()]] when OIF, after gen everything, set canreach>>=
canreach = canreach || oldreach;
if(!canreach)
    warnreach = !suppress;
@
%ocaml: do that in separate phase, cleaner, separation of concerns

%\subsubsection{[[bcomplex()]]}
% does both the call to complex and cgen(boolgen) when it needs!

% return bool where false = 0 = 0 error.
% c = context that is code possibly conditioned to run depending
% on the value of this boolean expression (e.g. then/else part of an if)
<<function bcomplex>>=
bool
bcomplex(Node *n, Node *c)
{

    complex(n);
    <<[[bcomplex()]] typecheck n>>
    <<[[bcomplex()]] generate fake goto if type error>>
    <<[[bcomplex()]] check for deadheads>>

    <<[[bcomplex()]] possibly convert node to funcall if unsupported 64 bit op>>
    boolgen(n, true, Z);

    return false; // no error
}
@
%//    Node *b, nod;
%    /* this is not quite right yet, so ignore it for now */
%    if(0 && newvlongcode && typev[n->type->etype] && machcap(Z)) {
%        b = &nod;
%        b->op = ONE;
%        b->left = n;
%        b->right = new(0, Z, Z);
%        *b->right = *nodconst(0);
%        b->right->type = n->type;
%        b->type = types[TLONG];
%        cgen(b, Z);
%        return 0;
%    }

% boolgen pass true because look for true condition initially
% to generate ABwhenoppositeoftrue, but if do if(!x) then it will
% call boolgen recursively with false this time.
% boolgen pass Z for? to not store result anywhere?


<<[[bcomplex()]] generate fake goto if type error>>=
if(n->type == T) {
    gbranch(OGOTO);
    return false;
}
@
\t what is this GOTO? it's to handle incorrect code?


%\subsubsection{[[boolgen()]]}
% later


\subsection{Switch}

% later


\subsection{Labels and goto}

% abuse complex to represent whether the label is defined.

% Label and goto connected to the same intermediate OXXX during
% parsing (see dcllabel).

<<[[Node]] code generation fields>>=
long	pc;
@
%ocaml: use external hash in external environment, do not store it in the AST

% can be seen as a kind of value field too, for OLABEL and OGOTO

<<[[Node]] code generation fields>>=
// ref<Prog>, but use 'void*' to be archi independent
void*	label;
@
%ocaml: use external hash in external environment with list of
% instructions to update (so need ugly chaining)

\subsubsection{Labels}

<<[[gen()]] switch node kind cases>>=
case OLABEL:
    <<[[gen()]] when LABEL, set canreach>>
    l = n->left;
    if(l) {
        l->pc = pc;
        if(l->label)
            patch(l->label, pc);
    }
    gbranch(OGOTO);	/* prevent self reference in reg */
    patch(p, pc);

    goto rloop;
@
\t there should always be a left! see decllabel()?

\t comment about self-reference?? 
% to make sure we generate an instruction at least?
% we might be the last element in the function? maybe empty statement after?

% why need goto just after you? because of the ugly way gen() handle
% multiple forward reference to a label? I don't think so.


<<[[gen()]] when LABEL, set canreach>>=
canreach = true;
@
% can jump to a label. If not, then will get anyway unused label warning.

\subsubsection{Gotos}


<<[[gen()]] switch node kind cases>>=
case OGOTO:
    <<[[gen()]] when OGOTO/ORETURN/OBREAK/OCONTINUE, set canreach>>
    n = n->left;
    <<[[gen()]] when OGOTO, sanity check n>>
    gbranch(OGOTO);
    if(n->pc) {
        patch(p, n->pc);
    } else {
        if(n->label)
             patch(n->label, pc-1);
        n->label = p;
    }
    return;
@
% pc -1, so jump just before this goto, so chain the goto.

% what if 2 goto to same label before the label itself is defined?
% will patch first goto to jump to second one :) ugly. unoptimal
% (but optimized later I think)

<<[[gen()]] when OGOTO/ORETURN/OBREAK/OCONTINUE, set canreach>>=
canreach = false;
warnreach = !suppress;
@

<<[[gen()]] when OGOTO, sanity check n>>=
if(n == Z) // possible?
    return;
if(n->complex == 0) {
    diag(Z, "label undefined: %s", n->sym->name);
    return;
}
if(suppress)
    return;
@
%ocaml: check done in check.ml

\subsection{Loops}


\n mv later? but break and continue gotos used also for
\n regular algo of a loop, so maybe good keep it here.
<<global breakpc>>=
// option<pc>, None = -1
long	breakpc;
@
% for break to branch at the right place
%ocaml: environment field, not global (and use recursivity
% to handle automatically scope and save/restore).

<<global continpc>>=
// option<pc>, None = -1
long	continpc;
@
% for continue to branch at the right place

<<[[ginit()]] misc initialisations>>=
breakpc = -1;
continpc = -1;
@


\subsubsection{while/dowhile}

% while(e) { stmt }
% =>
% AB entry
%goto_continue:
% AB spcontinue
%goto_break:
% AB spbreak
%entry:
%spbcontinue:
% <e>
% ABxxx goto_break
% <stmt>
%spbreak:



<<[[gen()]] locals>>=
Prog *spc, *spb;
@
% saved prog continue, saved prog break
% Local to gen, so recursivity will provide a stack of saved continue and break

<<[[gen()]] switch node kind cases>>=
case OWHILE:
case ODWHILE:
    l = n->left;

    gbranch(OGOTO);		/* entry */
    sp = p;

    <<[[gen()]] when OWHILE/ODWHILE, set continpc to pc before goto continue>>
    gbranch(OGOTO); // goto for continue
    spc = p;

    <<[[gen()]] when OWHILE/ODWHILE, set breakpc to pc before goto break>>
    gbranch(OGOTO); // goto for break
    spb = p;

    patch(spc, pc);
    if(n->op == OWHILE)
        patch(sp, pc);

    bcomplex(l, Z);		/* test */
    patch(p, breakpc);
    <<[[gen()]] when OWHILE/ODWHILE, increment nbreak>>

    if(n->op == ODWHILE)
        patch(sp, pc);

    gen(n->right);		/* body */

    gbranch(OGOTO);
    patch(p, continpc);

    patch(spb, pc); // exit

    <<[[gen()]] when OWHILE/ODWHILE, before exit, restore continpc/breakpc>>
    break;
@
% very similar while and dowhile in the end. Just entry change.


\subsubsection{for}

<<[[gen()]] switch node kind cases>>=
case OFOR:
    l = n->left;
    <<[[gen()]] when OFOR, check canreach before gen anything>>

    gen(l->right->left);	/* init */

    gbranch(OGOTO);		/* entry */
    sp = p;

    <<[[gen()]] when OFOR, check canreach after gen init>>

    <<[[gen()]] when OFOR, set continpc to pc before goto continue>>
    gbranch(OGOTO); // goto for continue
    spc = p;

    <<[[gen()]] when OFOR, set breakpc to pc before goto break>>
    gbranch(OGOTO); // goto for break
    spb = p;

    patch(spc, pc);

    gen(l->right->right);	/* inc */

    patch(sp, pc); // entry

    if(l->left != Z) {	/* test */
        bcomplex(l->left, Z);
        patch(p, breakpc);
        <<[[gen()]] when OFOR, increment nbreak>>
    }

    <<[[gen()]] when OFOR, set canreach before gen body>>

    gen(n->right);		/* body */

    if(canreach){
        gbranch(OGOTO);
        patch(p, continpc);
        <<[[gen()]] when OFOR, increment ncontin when canreach end of body>>
    }
    <<[[gen()]] when OFOR, check can reach for inc>>

    patch(spb, pc);

    <<[[gen()]] when OFOR, before exit, restore continpc/breakpc>>
    break;
@







<<[[gen()]] when OFOR, check canreach before gen anything>>=
if(!canreach && warnreach && l->right->left) {
    warn(n, "unreachable code FOR");
    warnreach = false;
}
@

<<[[gen()]] when OFOR, check canreach after gen init>>=
/* 
 * if there are no incoming labels in the 
 * body and the top's not reachable, warn
 */
if(!canreach && warnreach && deadheads(n)) {
    warn(n, "unreachable code %O", o);
    warnreach = false;
}
@

<<[[gen()]] when OFOR, set canreach before gen body>>=
canreach = true;
@
<<[[gen()]] when OFOR, check can reach for inc>>=
if(!ncontin && l->right->right && warnreach) {
    warn(l->right->right, "unreachable FOR inc");
    warnreach = false;
}
@

<<[[gen()]] when OFOR, set canreach after gen>>=
canreach = nbreak!=0;
if(!canreach)
    warnreach = !suppress;
@
% same than for OWHILE

\subsubsection{Continue/break}

% I mentioned continpc and breakpc before, set during
% while/for. 
% then can be used!

<<[[gen()]] switch node kind cases>>=
case OCONTINUE:
    <<[[gen()]] when OCONTINUE, sanity check continpc>>
    gbranch(OGOTO);
    patch(p, continpc);
    ncontin++;
    <<[[gen()]] when OGOTO/ORETURN/OBREAK/OCONTINUE, set canreach>>
    break;
@

<<[[gen()]] when OCONTINUE, sanity check continpc>>=
if(continpc < 0) {
    diag(n, "continue not in a loop");
    break;
}
@
%<<[[gen()]] when OCONTINUE, set canreach>>=
%canreach = false;
%warnreach = !suppress;
%@


<<[[gen()]] switch node kind cases>>=
case OBREAK:
    <<[[gen()]] when OBREAK, sanity check breakpc>>
    <<[[gen()]] when OBREAK, check canreach>>
    gbranch(OGOTO);
    patch(p, breakpc);
    nbreak++;
    <<[[gen()]] when OGOTO/ORETURN/OBREAK/OCONTINUE, set canreach>>
    break;
@

<<[[gen()]] when OBREAK, sanity check breakpc>>=
if(breakpc < 0) {
    diag(n, "break not in a loop");
    break;
}
@


%<<[[gen()]] when OBREAK, set canreach>>=
%canreach = false;
%warnreach = !suppress;
%@

% setting continpc and breakpc needs some special case
% because can have nested loops! so need to keep track
% and restore when out of scope.


<<[[gen()]] locals>>=
long sbc, scc;
int snbreak, sncontin;
@
%ocaml: use recursivity! no need save old value, I do not use
% globals

<<[[gen()]] when OWHILE/ODWHILE, set continpc to pc before goto continue>>=
scc = continpc;
continpc = pc;
@
% does not save ncontinue too?

<<[[gen()]] when OWHILE/ODWHILE, set breakpc to pc before goto break>>=
sbc = breakpc;
snbreak = nbreak;
breakpc = pc;
nbreak = 0;
@




<<[[gen()]] when OFOR, set continpc to pc before goto continue>>=
scc = continpc;
continpc = pc;
@

<<[[gen()]] when OFOR, set breakpc to pc before goto break>>=
sbc = breakpc;
snbreak = nbreak;
sncontin = ncontin;
breakpc = pc;
nbreak = 0;
ncontin = 0;
@
\l why not move sve ncontinue before?

<<[[gen()]] when OWHILE/ODWHILE, increment nbreak>>=
if(l->op != OCONST || vconst(l) == 0)
    nbreak++;
@
%ocaml: already incr break? then do not care about nbreak?

% if not const then possibility that will break
% and if 0 then for sure it will break.

<<[[gen()]] when OFOR, increment nbreak>>=
if(l->left->op != OCONST || vconst(l->left) == 0)
    nbreak++;
@

<<[[gen()]] when OFOR, increment ncontin when canreach end of body>>=
ncontin++;
@


<<[[gen()]] when OWHILE/ODWHILE, before exit, restore continpc/breakpc>>=
// restore
continpc = scc;
breakpc = sbc;
<<[[gen()]] when OWHILE/ODWHILE, set canreach>>
nbreak = snbreak;
@
%bug? does not restore ncontin?

<<[[gen()]] when OWHILE/ODWHILE, set canreach>>=
canreach = nbreak!=0;
if(!canreach)
     warnreach = !suppress;
@
% nbreak almost always positif, unless infinite loop
%  because while(1)



<<[[gen()]] when OFOR, before exit, restore continpc/breakpc>>=
// restore
continpc = scc;
breakpc = sbc;
<<[[gen()]] when OFOR, set canreach after gen>>
nbreak = snbreak;
ncontin = sncontin;
@







% turn into a static local?
<<global ncontin>>=
int	ncontin;
@

<<global nbreak>>=
long nbreak;
@



<<[[gen()]] when OBREAK, check canreach>>=
/*
 * Don't complain about unreachable break statements.
 * There are breaks hidden in yacc's output and some people
 * write return; break; in their switch statements out of habit.
 * However, don't confuse the analysis by inserting an 
 * unreachable reference to breakpc either.
 */
if(!canreach)
    break;
@




\subsection{Control flow jumps}

%\subsubsection{Return}

% seen gbranch(ORETURN) already in codgen.
% here when programmer writes explicitly return in his code.

<<[[gen()]] locals>>=
Node nod;
@

<<[[gen()]] switch node kind cases>>=
case ORETURN:
    <<[[gen()]] when OGOTO/ORETURN/OBREAK/OCONTINUE, set canreach>>

    complex(n);
    <<[[gen()]] when ORETURN, after complex, if no type>>

    l = uncomma(n->left);
    if(l == Z) {
        <<[[gen()]] case ORETURN with no argument, before RET>>
        gbranch(ORETURN);
    } 
    else
    <<[[gen()]] case ORETURN, if complex type>>
    else {
        regret(&nod, n);
        cgen(l, &nod);
        regfree(&nod);
        <<[[gen()]] case ORETURN with argument, before RET>>
        gbranch(ORETURN);
    }
    break;
@
%ocaml: with_reg() instead of this couple of regret()/regfree(),
% and special separate type for register or operand_able nodes.

% cgen() is for expression generation.
% The goal is to store the result of the expressions in a
% register node.

% why pass a Node to cgen second parameter? Not always
% a register? then pass a register instead!


%<<[[gen()]] when ORETURN, set canreach>>=
%canreach = false;
%warnreach = !suppress;
%@


<<[[gen()]] when ORETURN, after complex, if no type>>=
if(n->type == T)
    break;
@
%ocaml: should be TVoid then no?
\t diff with TVoid?

\subsubsection{[[uncomma()]]}

% gen(case RETURN) -> <>
<<function uncomma>>=
Node*
uncomma(Node *n)
{
    while(n != Z && n->op == OCOMMA) {
        cgen(n->left, Z);
        n = n->right;
    }
    return n;
}
@
%ocaml: need that? cgen handle OCOMMA already.

% cgen() again
% not sure we need that.

\subsubsection{[[regret()]]}

<<function regret(arm)>>=
void
regret(Node *n/*OUT*/, Node *nn/*IN*/)
{
    int r;

    r = REGRET;
    <<[[regret()]] if float expression, adjust return register>>
    nodreg(n, nn, r);
    reg[r]++;
}
@
%pad: I added the IN OUT annotation
%ocaml: return register, do not use IN/OUT ugly interface.
% and do not abuse node to store register, separate types!

%REGRET, see \book{Assembler}

% nodreg() makes the node n a OREGISTER node with register number
% r and type and line information coming from nn.

% nodreg() ???
% regfree?


\section{Register allocation}

% seen in regret(): nodreg(), regfree() and reg[r]

% in \book{Assembler}, REGARG (R0), REGRET (R0), REGTMP (R11)
% REGMIN (R2), REGMAX (R8), REGEXT (R10)
% and of course REGSB (R12), REGSP (R13), REGLINK(R14), REGPC(R15)

\subsection{[[reg]]}

<<global reg(arm)>>=
// map<enum<registr>, int>
char	reg[NREG+NFREG];
@
% can not be a bool, because some nodes can use the same
% register, so we need to keep track and reference count them.
% (use same register because when you know you need to store
% a result in R0, that means you dont care about the current value of
% R0, so you can use R0 temporarily too)

% those REGXX constants are in 5.out.h
<<[[ginit()]] reg and resvreg initialisation>>=
memset(reg, 0, sizeof(reg));

/* don't allocate */
reg[REGTMP] = 1;
reg[REGSB] = 1;
reg[REGSP] = 1;
reg[REGLINK] = 1;
reg[REGPC] = 1;
@
%ocaml: same

<<global resvreg(arm)>>=
static	char	resvreg[nelem(reg)];
@
% save content of reg at initialization time

<<[[ginit()]] reg and resvreg initialisation>>=
memmove(resvreg, reg, sizeof(reg));
@
%ocaml: just use Array.copy instead

<<[[gclean()]] locals>>=
int i;
@

<<[[gclean()]] sanity check reg>>=
for(i=0; i<NREG; i++)
    if(reg[i] && !resvreg[i])
        diag(Z, "reg %d left allocated", i);
@

% forgot some regfree! good sanity check.

\subsection{[[OREGISTER]]}

<<after parsing nodes>>=
OREGISTER,
@
%ocaml: use separate type for operand able stuff, and even
% then for things we know are always a register

% will transform some nodes in registers!

<<[[Node]] value fields>>=
// option<enum<registr>>
int		reg; // for OREGISTER
@
% has also xoffset!
%less: rename, to avoid ambiguity with Prog.reg and Adr.reg

\subsection{[[nodreg()]]}

% n is OUT, nn is IN
% regret | ... -> <>
<<function nodreg(arm)>>=
void
nodreg(Node *n, Node *nn, int reg)
{
    *n = regnode;
    n->reg = reg;
    n->type = nn->type;
    n->lineno = nn->lineno;
}
@
%ocaml: separate type. pass type and loc explicitely, so
% less confusing why we need nn?

<<global regnode>>=
Node	regnode;
@

<<[[ginit()]] special nodes initialisation>>=
regnode.op = OREGISTER;
regnode.class = CEXREG;
regnode.reg = REGTMP;
regnode.complex = 0;
regnode.addable = 11;
regnode.type = types[TLONG];
@
% class? CEXREG? matters? abused?

% addable 11 for register, see xcom()

% REGTMP = R11, see Assembler.nw

% Why abuse node for that?  Why need a node register?
% because naddr() need to handle different situations like
% generating Adr for a const (OCONST), global (ONAME), and
% Node already have this information, so would be redundant (but clearer!)
% to have another type. So instead 5c extend Node to inject
% other thing naddr can handle.

\subsection{[[regfree()]]}

<<function regfree(arm)>>=
void
regfree(Node *n)
{
    int i;

    <<[[regfree()]] sanity checks>>

    reg[n->reg]--;
    return;

err:
    diag(n, "error in regfree: %d", i);
}
@

<<[[regfree()]] sanity checks>>=
i = 0;
if(n->op != OREGISTER && n->op != OINDREG)
    goto err;
i = n->reg;
if(i < 0 || i >= sizeof(reg))
    goto err;
if(reg[i] <= 0)
    goto err;
@
%ocaml: I do not abuse nodes to store register, so no need for
% node sanity check. 
% update: actually I have a opd_regfree that needs to check.
% Also use special type for register, and
% ocaml already has arround bound checking, so again no need those checks.

%\subsection{[[regalloc()]]}

% see soon regalloc()

\section{Typechecking, expliciting, annotating, rewriting, [[complex()]]}
% unsugaring -> expliciting?

% complex? compile lexical?
% dodecl (array size) | doenum (evconst) | codgen | bcomplex -> <>
<<function complex>>=
void
complex(Node *n)
{

    if(n == Z)
        return;

    nearln = n->lineno;

    <<[[complex()]] debug tree pre complex>>
    // typechecking, removing some sugar, lvalue annotate, bitfield annot, etc
    if(tcom(n))
        return;

    // comma hoisting
    comma(n);
    <<[[complex()]] debug tree after tcom and comma>>
    // general rewrite
    ccom(n);
    <<[[complex()]] debug tree after ccom>>
    // arithmetic rewrite
    acom(n);
    <<[[complex()]] debug tree after acom>>

    // addressability and complexity (and shl/shr optimizations)
    xcom(n);
    <<[[complex()]] debug tree after xcom>>
}
@
%ocaml: no need null check again; separate typechecking phase cleaner;
% optimisation in another phase (TODO); no xcom(), do it with
% pattern matching on the fly for now.

%    //if(debug['y'] || true)

% seen tcom() (and tcomo()) before.
% Other are optimizations I will explain later.

\section{Addressability and complexity, [[xcom()]]}

% "xcom, [...] is machine-dependent [...]. it assigns an
% index of complexity to a sub-expression, which is usually expressed
% as the number of registers needed to compute it (and good luck with
% that on an x86), but it's also a good place to look for
% machine-dependent aspects of machine addressing, such as indexing,
% double-indexing, scaling, etc and it sets values in each tree node
% to mark that." - forsith

% instruction selection. Find if pattern of expression fits
% an ARM instruction or ARM operand so no need intermediate registers.

% Can the expression fits in an ARM Adr operand!
%ocaml: address-able -> operand_able

% 5c/sgen.c?
<<function xcom(arm)>>=
/*
 *	calculate addressability as follows
 *		CONST ==> 20		$value
 *		NAME ==> 10		name
 *		REGISTER ==> 11		register
 *		INDREG ==> 12		*[(reg)+offset]
 *
 *		&10 ==> 2		$name
 *		ADD(2, 20) ==> 2	$name+offset
 *		ADD(3, 20) ==> 3	$(reg)+offset
 *		&12 ==> 3		$(reg)+offset
 *
 *		*11 ==> 11		??
 *		*2 ==> 10		name
 *		*3 ==> 12		*(reg)+offset
 *	calculate complexity (number of registers) //$
 */
void
xcom(Node *n)
{
    Node *l, *r;
    int t;

    if(n == Z)
        return;

    l = n->left;
    r = n->right;
    n->addable = 0;
    n->complex = 0;

    switch(n->op) {
    <<[[xcom()]] switch op cases to set addable>>
    default:
        if(l != Z)
            xcom(l);
        if(r != Z)
            xcom(r);
        break;
    }
    if(n->addable >= 10)
        return;
    // else
    <<[[xcom()]] set complex if addable less than 10>>
}
@
%ocaml: ugly to abuse int, should use at least enum
% (but at the same time it works)

\t 10 magic constant. should be INDEXED

\subsection{Addressable, [[INDEXED]]}

<<constant INDEXED(arm)>>=
#define	INDEXED	9
@
\l INDEXED -> ADDABLE? 
%ocaml: ugly, use special type and operand_able() return an option type


% category on top of which gmove can do stuff

\subsection{Addressability, [[addable]]}

<<[[xcom()]] switch op cases to set addable>>=
case OCONST:
    n->addable = 20;
    return;
@
% MOVW $42, ...

<<[[xcom()]] switch op cases to set addable>>=
case ONAME:
    n->addable = 10;
    return;
@
% MOVW foo(SB), ... or MOVW +4(FP), MOVW -8(SP)
% no need temp register, can use R12 and R13


<<[[xcom()]] switch op cases to set addable>>=
case OREGISTER:
    n->addable = 11;
    return;
@
% when can have OREGISTER so early from complex()?
%  - if use special 'extern register' class extension.
%  - other?
\t so mv later?

% MOVW R1, ...

<<[[xcom()]] switch op cases to set addable>>=
case OINDREG:
    n->addable = 12;
    return;
@
%OINDREG is new kind of node! 
% when can have this so early? 
%  - because deref an 'extern register'? 
%  - other?
\t mv later? can then simplify xcom by aspectizing those numbers
\t  for OADDR, OIND, and OADD

% MOVW (R1), ...



<<[[xcom()]] switch op cases to set addable>>=
case OADDR:
    xcom(l);
    if(l->addable == 10)
        n->addable = 2;

    if(l->addable == 12)
        n->addable = 3;
    break;

@
<<[[xcom()]] switch op cases to set addable>>=
case OIND:
    xcom(l);
    if(l->addable == 2)
        n->addable = 10;

    if(l->addable == 3)
        n->addable = 12;
    if(l->addable == 11)
        n->addable = 12;
    break;
@
%ocaml: do deep pattern matching so no need for this contorsion

% what is the point of that? because often code like
% *(&x + 42) for arrays and this can be converted back in 
% MOVW x+42(SB)!

% Note that &x can correspond to a single instr; 
% you can do MOVW $foo(SB), ... so OADDR is kinda addressable.
\t why not bump it then? because ok for src operand, but not for
\t dst operand? but them for OCONST in that case ...

\t OIND of OCONST should be addable > INDEXED? Can do *0xfff = 2;

% go back to > 10 because OIND of OADDR can be simplified.
% but not already done in ccom? Yes for very simple OIND (OADDR (x))
% but most of the time OIND (OADD (OADDR (x)) 42).
% Enter code below that says OADDR (x) + 42 remains an OADDR!

% note that x must be an array. it can not be a pointer. If it is
% an array then for sure the content of this array is after the address.
% If it's a pointer, you need to dereference it first, so you need
% to put its content in a register first, and then deref this register.


% MOVW (R1), ...

<<[[xcom()]] switch op cases to set addable>>=
case OADD:
    xcom(l);
    xcom(r);
    if(l->addable == 20) {
        if(r->addable == 2)
            n->addable = 2;

        if(r->addable == 3)
            n->addable = 3;
    }
    if(r->addable == 20) {
        if(l->addable == 2)
            n->addable = 2;

        if(l->addable == 3)
            n->addable = 3;
    }
    break;
@
%ocaml: via deep pattern matching, can handle in one pattern
% the 3 chunks above for OIND, OADDR, OADD.

% so &x + 20 still remains an 2, which when it will be referenced
% will become back a 10! (with an offset)

\t already normalize and reverted OADD so need handle the first if?
% or was it normalized only if was a constant?

% See code of naddr. Strong coupling with xcom().

\subsection{Complexity, [[complex]]}

<<[[xcom()]] set complex if addable less than 10>>=
if(l != Z)
    n->complex = l->complex;
if(r != Z) {
    if(r->complex == n->complex)
        n->complex = r->complex+1;
    else
       if(r->complex > n->complex)
           n->complex = r->complex;
}

if(n->complex == 0)
    n->complex++;

<<[[xcom()]] if 64 bits operation, transform and return>>
// else
switch(n->op) {
<<[[xcom()]] switch node opkind cases to set complexity>>
}
@

\t why need that? will get out-of-register error if does not do that?


\subsection{[[FNX]]}

<<[[xcom()]] switch node opkind cases to set complexity>>=
case OFUNC:
    n->complex = FNX;
    break;
@

<<constant FNX(arm)>>=
#define	FNX		100
@

<<constant FNX>>=
/*
 * this is machine dependent, but it is totally
 * common on all of the 64-bit symulating machines.
 */

#define	FNX	100	/* botch -- redefinition */
@



\section{Basic expressions}

% at some point, 5c will generate simpler expressions
% that can be converted directly into 
% assembly instructions like MOVW $42, R1

% goal of cgen() is to transform complex expression nodes
% in simpler nodes and store intermediate result of complex
% expressions in registers.

% for example
% foo(int x, int y, int z) {
%      return x + y + z;
%  }
% ==> ??

\subsection{[[gmove()]]}

% if return 1;  then transformed in MOVW $1, R0
% will call gmove with OCONST1 and OREGISTER of REGRET

% from, to
% cgenrel | ... -> <>
% from and to must be 'operand_able' nodes with simple types
<<function gmove(arm)>>=
void
gmove(Node *f, Node *t)
{
    // enum<Type_kind> // Txxx
    int ft, tt;
    // enum<Opcode_kind> // Axxx
    int a;
    <<[[gmove()]] locals>>

    ft = f->type->etype;
    tt = t->type->etype;

    /*
     * a load --
     * put it into a register then
     * worry what to do with it.
     */
    <<[[gmove()]] if from is an indirect, registerize and return>>
    /*
     * a store --
     * put it into a register then
     * store it.
     */
    <<[[gmove()]] if to is an indirect, registerize and return>>

    // at this point f and t should be simpler nodes with 
    // registers or constants

    /*
     * type x type cross table
     */
    a = AGOK;
    switch(ft) {
    <<[[gmove()]] switch from type cases>>
    }
    <<[[gmove()]] sanity check a>>
    <<[[gmove()]] if samaddr return>>
    // else

    gins(a, f, t);
}
@
%ocaml: take two operand_able types, so cleaner
%old: was at the beginning, weird
%    if(ft == TDOUBLE && f->op == OCONST) {
%    }
%    if(ft == TFLOAT && f->op == OCONST) {
%    }


<<[[gmove()]] sanity check a>>=
if(a == AGOK)
    diag(Z, "bad opcode in gmove %T -> %T", f->type, t->type);
@
%ocaml: can not happen by construction

\subsubsection{A memory load}

% if from is a name, then can use register, but then this
% register will be an INDIRECT, and they are restrictions
% on what you can do. You can either load or store, but not
% both at the same time, so you have to store this indirect
% in a register first.


<<[[gmove()]] locals>>=
Node nod;
@
<<[[gmove()]] if from is an indirect, registerize and return>>=
if(f->op == ONAME || f->op == OIND || f->op == OINDREG) {
    switch(ft) {
    <<[[gmove()]] when indirect from, set MOVxx for [[a]] depending on type>>
    default:
        a = AMOVW;
        break;
    }
    <<[[gmove()]] when indirect from, if chlp ft and ilp tt>>
    else
        regalloc(&nod, f, t);
    gins(a, f, &nod);
    gmove(&nod, t);
    regfree(&nod);
    return;
}
@
% what kind of OIND can be handled here? OINDREG I get it, but OIND?
%  OIND of OCONST? if do  *0x444 = 2 ?
%  OIND of (ADD (OADDR, x)) !! *(&x + 42) can be handled! 
%  see naddr(). Those OIND are marked as addable.

% regalloc explained later. Alloc a register with same type
% than second argument. Third argument is optional and is
% where ultimately things will go. If this argument is a register,
% then regalloc knows it can use this register, he does not need
% to alloc a new register, because ultimately the register content
% will be overwritten.
% Here we pass [[t]], so if REGRET, then can use
% this register!


<<[[gmove()]] when indirect from, if chlp ft and ilp tt>>=
if(typechlp[ft] && typeilp[tt])
    regalloc(&nod, t, t);
@
%chlp: char, short, long, pointer
% regalloc(, t, t) so conversion on from?
\t some kind of opti?

<<global typeilp>>=
char	typeilp[NTYPE];
@
<<global typeilpinit>>=
int	typeilpinit[] =
{
    TINT, TUINT, TLONG, TULONG, TIND, -1
};
@
% ilp, int long pointer



<<global typechlp>>=
char	typechlp[NTYPE];
@
<<global typechlpinit>>=
int	typechlpinit[] =
{
    TCHAR, TUCHAR, TSHORT, TUSHORT, TINT, TUINT, TLONG, TULONG, TIND, -1,
};
@
% added TIND!



\subsubsection{A memory store}

% at this point, from must be a register or a constant

<<[[gmove()]] if to is an indirect, registerize and return>>=
if(t->op == ONAME || t->op == OIND || t->op == OINDREG) {
    switch(tt) {
    <<[[gmove()]] when indirect to, set MOVxx for [[a]] depending on type>>
    default:
        a = AMOVW;
        break;
    }
    <<[[gmove()]] when indirect to, if ft equal tt>>
    else
        regalloc(&nod, t, Z);
    gmove(f, &nod);
    gins(a, &nod, t);
    regfree(&nod);
    return;
}
@

% third parameter is Z here, because can not reuse anything.
% we know t is not a register.

<<[[gmove()]] when indirect to, if ft equal tt>>=
if(ft == tt)
    regalloc(&nod, t, f);
@
% if same type, and maybe from is already a register,
% in that case this can become a null op we can
% optimize away (see sameaddr()).
\t why important same types? because no conversion so will be really a NOP

\subsubsection{A set}

<<[[gmove()]] locals>>=
Node nod1;
Prog *p1;
@

<<[[gmove()]] switch from type cases>>=
case TUINT:
case TULONG:
    <<[[gmove()]] switch from type cases, TUINT/TULONG case, if float target>>
    // fall through
case TINT:
case TLONG:
case TIND:
    switch(tt) {
    <<[[gmove()]] switch from type cases, TINT/TLONG case, if float target>>
    case TCHAR:
    case TUCHAR:
    case TSHORT:
    case TUSHORT:
    case TINT:
    case TUINT:
    case TLONG:
    case TULONG:

    case TIND:
        a = AMOVW;
        break;
    }
    break;
@
\t move from int to char is a MOVW??



\subsection{Conversions}


<<[[gmove()]] when indirect from, set MOVxx for [[a]] depending on type>>=
case TCHAR:
    a = AMOVB;
    break;
case TUCHAR:
    a = AMOVBU;
    break;
case TSHORT:
    a = AMOVH;
    break;
case TUSHORT:
    a = AMOVHU;
    break;
case TFLOAT:
    a = AMOVF;
    break;
case TDOUBLE:
    a = AMOVD;
    break;
@




<<[[gmove()]] when indirect to, set MOVxx for [[a]] depending on type>>=
case TCHAR:
    a = AMOVB;
    break;
case TUCHAR:
    a = AMOVBU;
    break;
case TSHORT:
    a = AMOVH;
    break;
case TUSHORT:
    a = AMOVHU;
    break;
case TFLOAT:
    a = AMOVF;
    break;
case TVLONG: // addon?
case TDOUBLE:
    a = AMOVD;
    break;
@






<<[[gmove()]] switch from type cases>>=
case TSHORT:
    switch(tt) {
    <<[[gmove()]] switch from type cases, TSHORT case, if float target>>
    case TUINT:
    case TINT:
    case TULONG:
    case TLONG:
    case TIND:
        a = AMOVH;
        break;
    case TCHAR:
    case TUCHAR:
    case TSHORT:
    case TUSHORT:
        a = AMOVW;
        break;
    }
    break;
@
% why more general AMOVW?

<<[[gmove()]] switch from type cases>>=
case TUSHORT:
    switch(tt) {
    <<[[gmove()]] switch from type cases, TUSHORT case, if float target>>
    case TINT:
    case TUINT:
    case TLONG:
    case TULONG:
    case TIND:
        a = AMOVHU;
        break;
    case TCHAR:
    case TUCHAR:
    case TSHORT:
    case TUSHORT:
        a = AMOVW;
        break;
    }
    break;
@

<<[[gmove()]] switch from type cases>>=
case TCHAR:
    switch(tt) {
    <<[[gmove()]] switch from type cases, TCHAR case, if float target>>
    case TINT:
    case TUINT:
    case TLONG:
    case TULONG:
    case TIND:
    case TSHORT:
    case TUSHORT:
        a = AMOVB;
        break;
    case TCHAR:
    case TUCHAR:
        a = AMOVW;
        break;
    }
    break;
@

<<[[gmove()]] switch from type cases>>=
case TUCHAR:
    switch(tt) {
    <<[[gmove()]] switch from type cases, TUCHAR case, if float target>>
    case TINT:
    case TUINT:
    case TLONG:
    case TULONG:
    case TIND:
    case TSHORT:
    case TUSHORT:
        a = AMOVBU;
        break;
    case TCHAR:
    case TUCHAR:
        a = AMOVW;
        break;
    }
    break;
@


\subsection{[[gins()]]}

% gmove | ... -> <>
% the from (f) and to (t) nodes should be very basic,
% constants, or names, or simple indirection of names or constants,
% but only one of them can be a memory reference (so store or load, but not
% both).
<<function gins(arm)>>=
void
gins(int a, Node *f, Node *t)
{

    nextpc();
    p->as = a;

    if(f != Z)
        naddr(f, &p->from);
    if(t != Z)
        naddr(t, &p->to);

    <<[[gins()]] debug>>
}
@
%ocaml: just for MOV instructions for now

% see naddr() and the goto bad.
% It must generates something that the assembler can grok, so can't
% have two indirection arguments for example. One of them
% has to be simpler.


\subsection{[[naddr()]]}

% node addressable? node to Adr ?

% IN n, OUT a
<<function naddr(arm)>>=
void
naddr(Node *n, Adr *a)
{
    <<[[naddr()]] locals>>

    a->type = D_NONE;
    if(n == Z)
        return;

    switch(n->op) {
    <<[[naddr()]] switch node kind cases>>
    default:
    bad:
        diag(n, "bad in naddr: %O", n->op);
        break;

    }
}
@
%ocaml: no need for error report, by construction call naddr only
% on operand_able nodes


<<[[naddr()]] switch node kind cases>>=
case OCONST:
    a->sym = S;
    a->reg = R_NONE;
    <<[[naddr()]] if float type>>
    else {
        a->type = D_CONST;
        a->offset = n->vconst;
    }
    break;
@
% $42

<<[[naddr()]] switch node kind cases>>=
case OREGISTER:
    a->type = D_REG;
    a->sym = S;
    a->reg = n->reg;
    <<[[naddr()]] if float register, adjust a>>
    break;
@

% R1


<<[[naddr()]] switch node kind cases>>=
case ONAME:
    a->type = D_OREG;
    a->offset = n->xoffset;
    a->sym = n->sym;
    <<[[naddr()]] when ONAME, save etype>>

    a->symkind = N_INTERN;
    switch(n->class) {
    <<[[naddr()]] when ONAME, switch class cases>>
    default:
        goto bad;
    }
    break;
@
% Node.xoffset !!

% foo(SB)

% a NAME reference is always an OREG because dereference (SB)
% to access the data section part.
%old: was a serie of switch, but cleaner to use a switch






<<[[naddr()]] switch node kind cases>>=
case OIND:
    naddr(n->left, a);
    if(a->type == D_REG || a->type == D_CONST) {
        a->type = D_OREG;
        break;
    }
    goto bad;
@
%pad: should be D_ADDR!
\t here can be D_ADDR or D_CONST (can do *0xfff = ...)

\t when can have OIND of D_REG and not be OINDREG directly?

<<[[naddr()]] switch node kind cases>>=
case OADDR:
    naddr(n->left, a);
    if(a->type == D_OREG) {
        a->type = D_CONST;
        break;
    }
    // else
    goto bad;
@
% D_CONST -> D_ADDR here (update linker then!)

% can have OADDR in naddr() only when coming from lcgen() right now
%ocaml: can have it from gmove because I consider some OADDR as operand_able

% if &x, then x is a name reference, in which case the operation
% is a $x(SB) in assembly  (which is really SB+x)

% C &x -> ASM $x
%pad: was D_CONST, but really should be D_ADDR


<<[[naddr()]] locals>>=
long v;
@

% for array and pointer arithmetic.
<<[[naddr()]] switch node kind cases>>=
case OADD:
    if(n->left->op == OCONST) {
        naddr(n->left, a);
        v = a->offset;
        naddr(n->right, a);
    } else {
        naddr(n->right, a);
        v = a->offset;
        naddr(n->left, a);
    }
    a->offset += v;
    break;
@
% see code in xcom.
% should always be OADD (CST, OADDR x)







\t mv later when it is used
<<[[naddr()]] when ONAME, save etype>>=
a->etype = n->etype;
@
<<[[Adr]] type fields(arm)>>=
// enum<Type_kind>
char	etype;
@
% copy of node->type->etype.
% seems used only so that can generate back a Var from an Adr.

\subsection{[[regalloc()]]}

% for regret we called nodreg with REGRET, we know the
% register we want to store the return expression because
% it is a convention to use R0 for return value of a function.
% Sometimes, we just want a register, any register.


% | ... -> <>
% o is the optional node target in which the allocated register
% will go into (via a mov), so if the target is a register, then
% his value will be overwritten, so we can use the same register
% (because can do ADD R1, 10, R1 in ARM!)
% n is OUT, tn is IN, o is option<IN>
<<function regalloc(arm)>>=
void
regalloc(Node *n, Node *tn, Node *o)
{
    int i, j;
    static int lasti;

    switch(tn->type->etype) {
    case TCHAR:
    case TUCHAR:
    case TSHORT:
    case TUSHORT:
    case TINT:
    case TUINT:
    case TLONG:
    case TULONG:

    case TIND:
        <<[[regalloc()]] if integer type tn and OREGISTER o>>

        j = lasti + REGRET+1;
        for(i=REGRET+1; i<NREG; i++) {
            if(j >= NREG)
                j = REGRET+1;
            if(reg[j] == 0 && resvreg[j] == 0) {
                i = j;
                goto out;
            }
            j++;
        }
        <<[[regalloc()]] if reach here, out of fixed registers>>

    <<[[regalloc()]] switch tn type, float or vlong case>>
    }
    <<[[regalloc()]] if reach here, unknown type>>
    <<[[regalloc()]] error management>>

out:
    reg[i]++;
    nodreg(n, tn, i);

    lasti++;
    if(lasti >= 5)
        lasti = 0;

}
@
% lasti is some kind of optimisations, 
% maybe can aspectize it?

\t why need check also resvreg? code will regfree reserved registers??

<<[[regalloc()]] if reach here, out of fixed registers>>=
diag(tn, "out of fixed registers");
goto err;
@
\t can this happen? or impossibly by construction thx to complexity
\t  analysis and algorithm to favor less complex first?

<<[[regalloc()]] if reach here, unknown type>>=

diag(tn, "unknown type in regalloc: %T", tn->type);
// fallthrough
@
<<[[regalloc()]] error management>>=
err:
    nodreg(n, tn, 0);
    return;
@



<<[[regalloc()]] if integer type tn and OREGISTER o>>=
if(o != Z && o->op == OREGISTER) {
    i = o->reg;
    if(i >= 0 && i < NREG)
        goto out;
}
@
% reuse same register, no need to allocate a new one


\section{Expressions, [[cgen()]]}
% mimic parsing chapter subsection?

<<[[gen()]] switch node kind cases>>=
default:
    complex(n);
    cgen(n, Z);
    break;
@

% second param of cgen is node to store result of expression into.
% for ExprSt, we dont care about result so we pass Z.

% saw calls to bcomplex() before when processing
% statements for instance for the expression in if(e), or while(e).
% Many calls to cgen too.


% codgen -> gen -> <>    for expression stuff
% nn is optional! it's the possible target of the expr, e.g.
% if do return <expr>; then will have in nn a node with REGRET
% if do expr; then nn will be Z (like above in gen()).
%pre: has called complex() on the node n before (and nn if not null?)
<<function cgen(arm)>>=
void
cgen(Node *n, Node *nn)
{
    cgenrel(n, nn, false);
}
@
% false means inrel = false
% why care whether rel context?


% nn = optional lhs?, n = rhs
<<function cgenrel(arm)>>=
void
cgenrel(Node *n, Node *nn, bool inrel)
{
    // enum<node_kind>
    int o;
    Node *l, *r;
    // enum<Type_kind>
    int t;
    long curs;
    <<[[cgenrel()]] locals>>

    <<[[cgenrel()]] debug>>
    if(n == Z || n->type == T)
        return;

    <<[[cgenrel()]] if complex type node>>
    else {

        l = n->left;
        r = n->right;
        o = n->op;
        
        <<[[cgenrel()]] if node addressable>>
        // else

        // save
        curs = cursafe;
        <<[[cgenrel()]] if all complex fields more than FNX>>
        
        switch(o) {
        <<[[cgenrel()]] switch node kind cases>>
        default:
            diag(n, "unknown op in cgen: %O", o);
            break;
        }
        // restore
        cursafe = curs;
    }
    return;
}
@

<<[[cgenrel()]] switch node kind cases>>=
case OCOMMA:
    cgen(l, Z);
    cgen(r, nn);
    break;
@
% lhs = a,b  => a; lhs = b;



<<[[cgenrel()]] locals>>=
Prog *p1;
Node nod, nod1, nod2, nod3, nod4;
long v;
@
% 5 possible registers, which is why the lasti <= 5 in regalloc?


\subsection{Numeric constants}

% because 'if addable more than INDEXED' so then get a gmove
% and OCONST is addable 20.
% Because expr is address-able Adr-able.

<<[[cgenrel()]] if node addressable>>=
if(n->addable >= INDEXED) {
    <<[[cgenrel()]] warn if target node is nil>>
    gmove(n, nn);
    return;
}
@

% if do simple  void foo() { return 1; } => 5c -S ?
% => cgenrel? 

% see code in naddr() called from gmove for OCONST!


\subsection{Entity uses}

% this is ONAME! which will not be transformed by assembly generation
% phase; a C symbol is an assembly symbol! 
% The only thing is that ONAME is decorated with xoffset
% if it's a parameter or a local.

% previous code covers also entity uses. gmove -> gins -> naddr.

\subsubsection{Parameters}

<<[[adecl()]] switch class cases>>=
case CPARAM:
    <<[[adecl()]] if first parameter>>
    autoffset = align(autoffset, t, Aarg1);
    if(s)
        s->offset = autoffset;
    autoffset = align(autoffset, t, Aarg2);
    break;
@
% not always a s.

% params are accessed as positive offset to SP

<<[[naddr()]] when ONAME, switch class cases>>=
case CPARAM:
    a->symkind = N_PARAM;
    break;
@
% offset used in generic code dealing with ONAME

\subsubsection{Locals}

<<[[adecl()]] switch class cases>>=
case CAUTO:
    autoffset = align(autoffset, t, Aaut3);
    stkoff = maxround(stkoff, autoffset);
    s->offset = -autoffset;
    break;
@
% locals are accessed as negative offset to SP.
\t why not stkoff = autoffset? and what need stkoff for? reseted
\t  anyway in argmark

<<[[naddr()]] when ONAME, switch class cases>>=
case CAUTO:
    a->symkind = N_LOCAL;
    break;
@


\subsubsection{Globals}

<<[[naddr()]] when ONAME, switch class cases>>=
case CEXTERN: case CGLOBL:
    a->symkind = N_EXTERN;
    break;
@
<<[[naddr()]] when ONAME, switch class cases>>=
case CSTATIC: 
    a->symkind = N_INTERN;
    break;
@


\subsubsection{Enumeration constants}
% replaced as OCONST during parsing



\subsection{String constants}

% String constants are transformed in ONAME in tcomo().

\subsubsection{ASCII strings}

<<[[tcomo()]] transform OSTRING in ONAME>>=
n->op = ONAME;
n->xoffset = outstring(n->cstring, n->type->width);
n->addable = true;
@
%ocaml: do that in separate phase. Not typechecking related.

% note that the TARRAY will be transformed in TIND later by
% tcomo()

% transformed as ONAME! (so become lvalue, Can do "foo"[0] = 'c'. )

<<string rule, set sym and class for OSTRING>>=
$$->sym = symstring;
$$->class = CSTATIC;
@
% could do that in tcomo instead of in string rule.
% Also why he does not do that directly in parser? Why not generate
% ONAME directly?


% rewrite AST! offset in a giant DATA string.


<<global symstring>>=
Sym*	symstring;
@


<<[[cinit()]] locals>>=
Type *t;
@
<<[[cinit()]] symstring initialization>>=
symstring = slookup(".string");
symstring->class = CSTATIC;
t = typ(TARRAY, types[TCHAR]);
t->width = 0;
symstring->type = t;
@
% growing array!
% static so each object file can have its own.

<<global nstring>>=
long	nstring;
@

<<global mnstring>>=
int	mnstring;
@


<<[[ginit()]] misc initialisations>>=
nstring = 0;
mnstring = 0;
@

<<[[gclean()]] adjust symstring width>>=
while(mnstring)
    outstring("", 1L);
symstring->type->width = nstring;
@
\l needed for? put \z between 2 strings?
\t 5c -S to see how put together, but still separate at clean boundaries
\t because need addressable at word boundaries?


<<global string>>=
char	string[NSNAME];
@
% NSNAME = 8, so print data by block of 8 characters.

<<function outstring(arm)>>=
long
outstring(char *s, long n)
{
    long r;

    <<[[outstring()]] return if suppress>>
    r = nstring;
    while(n) {
        string[mnstring] = *s++;
        mnstring++;
        nstring++;
        if(mnstring >= NSNAME) {
            gpseudo(ADATA, symstring, nodconst(0L));
            p->from.offset += nstring - NSNAME;
            p->reg = NSNAME;
            p->to.type = D_SCONST;
            memmove(p->to.sval, string, NSNAME);
            mnstring = 0;
        }
        n--;
    }
    return r;
}
@
% 386 diff is jsut p->reg -->  p->from.scale = NSNAME;

% generate some DATA in the middle, ugly.


<<[[outstring()]] return if suppress>>=
if(suppress)
    return nstring;
@
% why care about supress here?

<<[[tcomo()]] in OSTRING case, if not an array or chars>>=
if(n->type->link != types[TCHAR]) {
    o = outstring(0, 0);
    while(o & 3) {
        outstring("", 1);
        o = outstring(0, 0);
    }
}
@
\t When can this happen?

\subsubsection{Unicode strings}

<<[[tcomo()]] other locals>>=
static TRune zer;
@

<<[[tcomo()]] switch node kind cases>>=
case OLSTRING:
    if(n->type->link != types[TRUNE]) {
        o = outstring(0, 0);
        while(o & 3) {
            outlstring(&zer, sizeof(TRune));
            o = outlstring(0, 0);
        }
    }
    n->op = ONAME;
    n->xoffset = outlstring(n->rstring, n->type->width);
    n->addable = 1;
    break;
@





<<function outlstring>>=
long
outlstring(TRune *s, long n)
{
    char buf[sizeof(TRune)];
    uint c;
    int i;
    long r;

    if(suppress)
        return nstring;
    while(nstring & (sizeof(TRune)-1))
        outstring("", 1);
    r = nstring;
    while(n > 0) {
        c = *s++;
        if(align(0, types[TCHAR], Aarg1)) {
            for(i = 0; i < sizeof(TRune); i++)
                buf[i] = c>>(8*(sizeof(TRune) - i - 1));
        } else {
            for(i = 0; i < sizeof(TRune); i++)
                buf[i] = c>>(8*i);
        }
        outstring(buf, sizeof(TRune));
        n -= sizeof(TRune);
    }
    return r;
}
@


\subsection{Arithmetic expressions}

% see also acom() rewriting

% see also pointer arithmetic adjustments during typechecking


<<[[cgenrel()]] switch node kind cases>>=
case OSUB:
    <<[[cgenrel()]] when OSUB, if l is OCONST>>
    // else, Fallthrough
case OADD:
case OAND:
case OOR:
case OXOR:
case OASHL:
case OASHR:
case OLSHR:
    <<[[cgenrel()]] when OADD/OAND/etc, if r is OCONST>>
    // Fallthrough
case OMUL:
case OLMUL:
case OLDIV:
case OLMOD:
muldiv:
    <<[[cgenrel()]] nullwarn check if nn is null>>
    <<[[cgenrel()]] when OMUL/OLMUL, mulcon opportunity>>
    // else, the general case!
    <<[[cgenrel()]] when OADD/OAND/..., if l more complex than r>>
    else {
        regalloc(&nod, r, nn);
        cgen(r, &nod);
        regalloc(&nod1, l, Z);
        cgen(l, &nod1);
        gopcode(o, &nod, &nod1, &nod);
    }
    gopcode(OAS, &nod, Z, nn);
    regfree(&nod);
    regfree(&nod1);
    break;
@
\l should gopcode to nn only if non null nn no?
\l also could use gmove

<<[[cgenrel()]] switch node kind cases>>=
case ODIV:
case OMOD:
    <<[[cgenrel()]] when ODIV/OMOD, convert to SHR if possible>>
    // else
    goto muldiv;
@


\subsubsection{Complexity and register allocation}

% subtle! see plus_chain.c, or registers.c

<<[[cgenrel()]] when OADD/OAND/..., if l more complex than r>>=
if(l->complex >= r->complex) {
    regalloc(&nod, l, nn);
    cgen(l, &nod);
    regalloc(&nod1, r, Z);
    cgen(r, &nod1);
    gopcode(o, &nod1, Z, &nod);
}
@
\t why Z here? ugly? could not pass &nod? clearer?

% Note that not symetric with other case.
% In both case we store the result in nod (which one time refers to
% r and one time to l). But this saves some extra MOVW! see plus_chain.c
% because the     gopcode(OAS, &nod, Z, nn);
% can become a NOP and be removed.
% Subtle!



\subsubsection{[[gopcode()]]}

% from, to, but ARM supports arith operator with 3 operands
% as ADD R1, R2, R3, so can leverage that.

% from1, to, and f2 is for the optional middle register
% cgenrel (for arith expr) -> <>
<<function gopcode(arm)>>=
void
gopcode(int o, Node *f1, Node *f2, Node *t)
{
    // enum<opcode_kind> AXXX
    int a;
    // enum<type_kind> TXXX
    int et;
    Adr ta;
    <<[[gopcode()]] locals>>

    et = (f1 != Z && f1->type != T)? f1->type->etype : TLONG;
    <<[[gopcode()]] initialisation>>

    a = AGOK;
    switch(o) {
    <<[[gopcode()]] switch opcode cases>>
    }
    <<[[gopcode()]] sanity check a>>

    nextpc();
    p->as = a;

    if(f1 != Z)
        naddr(f1, &p->from);
    if(f2 != Z) {
        naddr(f2, &ta);
        p->reg = ta.reg;
    }
    if(t != Z)
        naddr(t, &p->to);

    <<[[gopcode()]] debug>>
}
@
%ocaml: generate directly instruction, no need wrapper.

% similar to gins(), but does some C opcode to ARM opcode translation.
% o -> a.
\t could call gins then? yes for first part, but still does special
\t  thing about p->reg and the last parameter t.
% why need et? for float adjustments.


<<[[gopcode()]] sanity check a>>=
if(a == AGOK)
    diag(Z, "bad in gopcode %O", o);
@
%ocaml: generate directly?

%<<function fop(arm)>>=
%void
%fop(int as, int f1, int f2, Node *t)
%{
%    Node nod1, nod2, nod3;
%
%    nodreg(&nod1, t, NREG+f1);
%    nodreg(&nod2, t, NREG+f2);
%    regalloc(&nod3, t, t);
%    gopcode(as, &nod1, &nod2, &nod3);
%    gmove(&nod3, t);
%    regfree(&nod3);
%}
%@



<<[[gopcode()]] switch opcode cases>>=
case OADD:
case OASADD:
    a = AADD;
    <<[[gopcode()]] when OADD, adjust a if float type>>
    break;
@
%pad: I put the OASxxx after the OAxxx
\t no need look at type? ADD works for every size?

<<[[gopcode()]] switch opcode cases>>=
case OSUB:
case OASSUB:
    a = ASUB;
    <<[[gopcode()]] when OSUB, ARSB opportunity>>
    <<[[gopcode()]] when OSUB, adjust a if float type>>
    break;
@
%pad: I put default code first instead inside else so aspectize easier

<<[[gopcode()]] switch opcode cases>>=
case OOR:
case OASOR:
    a = AORR;
    break;
@
<<[[gopcode()]] switch opcode cases>>=
case OAND:
case OASAND:
    a = AAND;
    break;
@
<<[[gopcode()]] switch opcode cases>>=
case OXOR:
case OASXOR:
    a = AEOR;
    break;
@


<<[[gopcode()]] switch opcode cases>>=
case OASHL:
case OASASHL:
    a = ASLL;
    break;
@

<<[[gopcode()]] switch opcode cases>>=
case OASHR:
case OASASHR:
    a = ASRA;
    break;
@
% arithmetic SHR!



<<[[gopcode()]] switch opcode cases>>=
case OMUL:
case OASMUL:
    a = AMUL;
    <<[[gopcode()]] when OMUL, adjust a if float type>>
    break;
@
<<[[gopcode()]] switch opcode cases>>=
case ODIV:
case OASDIV:
    a = ADIV;
    <<[[gopcode()]] when ODIV, adjust a if float type>>
    break;
@
<<[[gopcode()]] switch opcode cases>>=
case OMOD:
case OASMOD:
    a = AMOD;
    break;
@


\subsubsection{Unsigned operations}

\l Why generate special opcode? 
% Why not for OADD but for OMUL?
% Because ARM handles unsigned and signed with same opcode for addition
% but not for multiplication!!! and especially not for bit shifting!
% lsr != asr

% useful for evconst too! otherwise vconst interpreted wrongly!
% and can not do certain operations on very high unsigned integers.

<<global typeu>>=
char	typeu[NTYPE];
@
<<global typeuinit>>=
int	typeuinit[] =
{
    TUCHAR, TUSHORT, TUINT, TULONG, TUVLONG, TIND, -1,
};
@
% TIND is a pointer, so really unsigned address.



<<after parsing nodes>>=
OLSHR,
@
% L for logical (vs arithmetic)

<<[[tcomo()]] in OASHL/OASHR case, adjust opcode if unsigned type>>=
if(typeu[n->type->etype])
    if(n->op == OASHR)
        n->op = OLSHR;
@
% see Machine.nw or Assembler.nw or Linker.nw. 
% There is arithmetic shift right and logical shift right.
% Because question is how you fill the bits on the left. With 0 or 1's.
% for shift left no pb, always fill with 0.


% pb also for mul/div/mod? need special operator?

<<after parsing nodes>>=
OLMUL,
OLDIV,
@


<<[[tcomo()]] in OMUL/ODIV case, adjust opcode if unsigned type>>=
if(typeu[n->type->etype]) {
    if(n->op == OMUL)
        n->op = OLMUL;
    if(n->op == ODIV)
        n->op = OLDIV;
}
@
% see code in evconst later relying on this to know that the operation
% involved must be done in an "unsigned mode".

<<after parsing nodes>>=
OLMOD,
@

<<[[tcomo()]] in OMOD case, adjust opcode if unsigned type>>=
if(typeu[n->type->etype])
    n->op = OLMOD;
@




% same for comparisons!

<<[[tcomo()]] when OLT/OGE/OGT/OLE, adjust opcode if unsigned type>>=
if(typeu[n->type->etype])
    n->op = logrel[relindex(n->op)];
@

<<global logrel>>=
char	logrel[12] =
{
    OEQ, ONE, OLS, OLS, OLO, OLO, OHS, OHS, OHI, OHI,
};
@

<<function relindex>>=
int
relindex(int o)
{

    switch(o) {
    case OEQ: return 0;
    case ONE: return 1;
    case OLE: return 2;
    case OLS: return 3;
    case OLT: return 4;
    case OLO: return 5;
    case OGE: return 6;
    case OHS: return 7;
    case OGT: return 8;
    case OHI: return 9;
    default:
        diag(Z, "bad in relindex: %O", o);
    }
    return -1; // unreachable
}
@



<<after parsing nodes>>=
OASLSHR,
OASLMUL,
OASLDIV,
OASLMOD,
@
% typed long version?


<<[[tcomo()]] when OASLSHR, adjust opcode if unsigned type>>=
if(typeu[n->type->etype]) {
    if(n->op == OASASHR)
        n->op = OASLSHR;
}
@

<<[[tcomo()]] when OASMUL/OASDIV, adjust opcode if unsigned type>>=
if(typeu[n->type->etype]) {
    if(n->op == OASDIV)
        n->op = OASLDIV;
    if(n->op == OASMUL)
        n->op = OASLMUL;
}
@
<<[[tcomo()]] when OASMOD, adjust opcode if unsigned type>>=
if(typeu[n->type->etype]) {
    if(n->op == OASMOD)
        n->op = OASLMOD;
}
@





<<[[gopcode()]] switch opcode cases>>=
case OLSHR:
case OASLSHR:
    a = ASRL;
    break;
@


<<[[gopcode()]] switch opcode cases>>=
case OLMUL:
case OASLMUL:
    a = AMULU;
    break;
@
<<[[gopcode()]] switch opcode cases>>=
case OLMOD:
case OASLMOD:
    a = AMODU;
    break;
@
<<[[gopcode()]] switch opcode cases>>=
case OLDIV:
case OASLDIV:
    a = ADIVU;
    break;
@



\subsection{Boolean expressions}
% special because also generate ABxxx so explained later

\subsection{Assignments part 1}

<<[[cgenrel()]] switch node kind cases>>=
case OAS:
    <<[[cgenrel()]] when OAS, if bitfield assignment>>
    if(l->addable >= INDEXED && l->complex < FNX) {
        <<[[cgenrel()]] when OAS, if right node not addressable or nn>>
        else
            // both left and right are addressable and nn == Z
            gmove(r, l);
        break;
    }
    // else
    <<[[cgenrel()]] when OAS, when left node not addressable or too complex>>
@
\t how can be addressable and complex??? useless test on FNX?
\t  anyway, should then do it also for r in that case.

% so this will not handle *x = 1, because *x is not considered
% addable.

% this will not handle either x = x+y; See code below for that.

\t the code above could handle x = &y;, but it does not right now
%In the end it leads to same code, because address needs to be
% registerized before being stored in local, but still, should be handled in
% xcom by making OADDR (ONAME) an addressable node.
%ocaml: I handle it via a simple gmove, I made OADDR (ONAME)
% an addressable node.

<<[[cgenrel()]] when OAS, if right node not addressable or nn>>=
if(nn != Z || r->addable < INDEXED) {
    <<[[cgenrel()]] when OAS, if right node contain a call>>
    else
        regalloc(&nod, r, nn);
    cgen(r, &nod);
    gmove(&nod, l);
    if(nn != Z)
        gmove(&nod, nn);
    regfree(&nod);
}
@
% nn can be non Z when do  return x = 1;  or x = y = 2;
% But most of the time, it will be null because simply do x = 1;
% in an ExprSt.

% Note that x = &y; could be handled directly by a gmove (r, l).



<<[[cgenrel()]] when OAS, if right node contain a call>>=
if(r->complex >= FNX && nn == Z)
    regret(&nod, r);
@
\l mv later with Funcall stuff?
\t why this code?

\subsection{Pointers}
% mv earlier? simpler than OAS?

\subsubsection{Getting the address, [[lcgen()]]}

% return &x;

<<[[cgenrel()]] switch node kind cases>>=
case OADDR:
    <<[[cgenrel()]] nullwarn check if nn is null>>
    lcgen(l, nn);
    break;
@
%ocaml: we should not have to handle this here. an OADDR(ONAME)
% should considered operand_able, and if because do
% OADDR(OIND(x)), then this should be handled in rewrite.ml.


%\subsection{[[lcgen()]]}

% note that tcomo() ensure tlvalue(l), so does not
% have to handle every cases.

% lvalue code generator
<<function lcgen(arm)>>=
void
lcgen(Node *n, Node *nn)
{
    Node nod;
    <<[[lcgen()]] other locals>>

    <<[[lcgen()]] debug>>
    <<[[lcgen()]] sanity check n>>
    <<[[lcgen()]] if nn nil>>
    switch(n->op) {
    <<[[lcgen()]] switch node cases>>
    default:
        <<[[lcgen()]] sanity check n in default case>>
        nod = *n;
        nod.op = OADDR;
        nod.left = n;
        nod.right = Z;
        nod.type = types[TIND];
        gopcode(OAS, &nod, Z, nn);
        break;

    }
}
@
%ocaml: handled in operand_able()

% diff with 386 is that default case is just:
%        gopcode(OADDR, n->type, n, nn);
% so maybe could actually factorize

<<[[lcgen()]] sanity check n in default case>>=
if(n->addable < INDEXED) {
    diag(n, "unknown op in lcgen: %O", n->op);
    break;
}
@
% In many cases do simply things like &x.


% In some cases, do more complex things like
% & ((&x).foo)



<<[[lcgen()]] if nn nil>>=
if(nn == Z) {
    nn = &nod;
    regalloc(&nod, n, Z);
}
@
\l no warn unused result? or does accessing a pointer a side effect?
\t use when nn is Z? still want the effect of taking the address?

<<[[lcgen()]] switch node cases>>=
case OIND:
    cgen(n->left, nn);
    break;
@
%ocaml: should have been done in rewrite.ml? 

% find back that OADDR(IND(x)) -> x, where call back cgen



<<[[lcgen()]] switch node cases>>=
case OCOMMA:
    cgen(n->left, n->left);
    lcgen(n->right, nn);
    break;
@
%ocaml: stricter? forbid? anyway how can be considered an lvalue?

<<[[lcgen()]] other locals>>=
Prog *p1;
@
<<[[lcgen()]] switch node cases>>=
case OCOND:
    bcgen(n->left, 1);
    p1 = p;
    lcgen(n->right->left, nn);
    gbranch(OGOTO);
    patch(p1, pc);
    p1 = p;
    lcgen(n->right->right, nn);
    patch(p1, pc);
    break;
@
%ocaml: stricter? forbid? anyway how can be considered an lvalue?

\t when can have this? can not do return & (z? x: y) 
\t  because forbidden by tlvalue() check in tcomo.


<<[[lcgen()]] sanity check n>>=
if(n == Z || n->type == T)
    return;
@
\l when can this happen?
%ocaml: no need, assume typechecking done, assume valid nodes.


\subsubsection{Dereferencing the address}

% *x

% Note that *(&x+1) handled differently. Handled directly.
% Here is for general case, when really dereference a pointer
% variable.

<<[[cgenrel()]] switch node kind cases>>=
case OIND:
    <<[[cgenrel()]] nullwarn check if nn is null>>
    regialloc(&nod, n, nn);
    <<[[cgenrel()]] when OIND, if indirect of OADD constants>>
    else
        cgen(l, &nod);
    regind(&nod, n);
    gopcode(OAS, &nod, Z, nn);
    regfree(&nod);
    break;
@
\t why not gmove here instead of gopcode(OAS, ...)?
\t why not regalloc(&nod, l, nn) so get type of thing? no need regialloc

% register indirect alloc
<<function regialloc>>=
void
regialloc(Node *n, Node *tn, Node *o)
{
    Node nod;

    nod = *tn;
    nod.type = types[TIND];
    regalloc(n, &nod, o);
}
@
%ocaml: opd_regalloc_e generalizes this

<<function regind>>=
void
regind(Node *n, Node *nn)
{

    if(n->op != OREGISTER) {
        diag(n, "regind not OREGISTER");
        return;
    }
    n->op = OINDREG;
    n->type = nn->type;
}
@
%ocaml: do transformation of opd on the fly, functional! no by side effect.

% This is how get from OREGISTER to OINDREG

<<after parsing nodes>>=
OINDREG,
@

<<[[naddr()]] switch node kind cases>>=
case OINDREG:
    a->type = D_OREG;
    a->sym = S;
    a->offset = n->xoffset;
    a->reg = n->reg;
    break;
@



% opti?
<<[[cgenrel()]] when OIND, if indirect of OADD constants>>=
r = l;
while(r->op == OADD)
    r = r->right;
if(sconst(r) && (v = r->vconst + nod.xoffset) > -4096 && v < 4096) {
    v = r->vconst;
    r->vconst = 0;
    cgen(l, &nod);
    nod.xoffset += v;
    r->vconst = v;
}
@



\subsection{Assignments part 2}

% *x = 1;  for example.

<<[[cgenrel()]] when OAS, when left node not addressable or too complex>>=
<<[[cgenrel()]] when OAS, when l not addressable, if l more complex than r>>
else {
    regalloc(&nod, r, nn);
    cgen(r, &nod);
    reglcgen(&nod1, l, Z);
}
gmove(&nod, &nod1);
regfree(&nod);
regfree(&nod1);
break;
@

% reglcgen is really lcgen; regind

% need?
<<[[cgenrel()]] when OAS, when l not addressable, if l more complex than r>>=
if(l->complex >= r->complex) {
    reglcgen(&nod1, l, Z);
    if(r->addable >= INDEXED) {
        gmove(r, &nod1);
        if(nn != Z)
            gmove(r, nn);
        regfree(&nod1);
        break;
    }
    // else
    regalloc(&nod, r, nn);
    cgen(r, &nod);
}
@

\subsubsection{[[reglcgen()]]}

% lcgen in a reg, lvalue code generator in register

<<function reglcgen(arm)>>=
void
reglcgen(Node *t, Node *n, Node *nn)
{
    Node *r;
    long v;

    regialloc(t, n, nn);
    <<[[reglcgen()]] if OIND of OADD of constants>>
    <<[[reglcgen()]] if OINDREG with small offsets>>
    // else
    lcgen(n, t);
    regind(t, n);
}
@
% quite similar to the 386, but with some variations




<<[[reglcgen()]] if OIND of OADD of constants>>=
if(n->op == OIND) {
    r = n->left;
    while(r->op == OADD)
        r = r->right;
    if(sconst(r) && (v = r->vconst+t->xoffset) > -4096 && v < 4096) {
        v = r->vconst;
        r->vconst = 0;
        lcgen(n, t);
        t->xoffset += v;
        r->vconst = v;
        regind(t, n);
        return;
    }
}
@
% small const? opti to move later?
<<function sconst(arm)>>=
bool
sconst(Node *n)
{
    vlong vv;

    if(n->op == OCONST) {
        if(!typefd[n->type->etype]) {
            vv = n->vconst;
            if(vv >= (vlong)(-32766) && vv < (vlong)32766)
                return true;
            /*
             * should be specialised for constant values which will
             * fit in different instructionsl; for now, let 5l
             * sort it out
             */
            return true;
        }
    }
    return false;
}
@


<<[[reglcgen()]] if OINDREG with small offsets>>=
else if(n->op == OINDREG) {
    if((v = n->xoffset) > -4096 && v < 4096) {
        n->op = OREGISTER;
        cgen(n, t);
        t->xoffset += v;
        n->op = OINDREG;
        regind(t, n);
        return;
    }
}
@

\subsection{Assignments and arithmetic}

<<[[cgenrel()]] switch node kind cases>>=
case OASADD:
case OASSUB:
case OASAND:
case OASXOR:
case OASOR:
case OASASHL:
case OASASHR:
case OASLSHR:
    <<[[cgenrel()]] when OASADD/OASSUB/etc, if bitfield assignment>>
    <<[[cgenrel()]] when OASADD/OASSUB/etc, if r is OCONST>>
    // Fallthrough
case OASMUL:
case OASDIV:
case OASMOD:
case OASLMUL:
case OASLDIV:
case OASLMOD:
    <<[[cgenrel()]] when OASMUL/OASDIV/etc, if bitfield assignment>>
    <<[[cgenrel()]] when OASADD/OASUB/etc, if l more complex than r>>
     else {
        regalloc(&nod1, r, Z);
        cgen(r, &nod1);
        if(l->addable < INDEXED)
            reglcgen(&nod2, l, Z);
        else
            nod2 = *l;
    }

    regalloc(&nod, n, nn);
    gmove(&nod2, &nod);
    gopcode(o, &nod1, Z, &nod);
    gmove(&nod, &nod2);
    if(nn != Z)
        gopcode(OAS, &nod, Z, nn);
    regfree(&nod);
    regfree(&nod1);
    if(l->addable < INDEXED)
        regfree(&nod2);
    break;
@

<<[[gopcode()]] switch opcode cases>>=
case OAS:
    gmove(f1, t);
    return;
@
% it's a return here! it shortcircuit what gopcode normally does
\t when can have this?? gopcode executed only for arith stuff. or is it
\t for the OASADD?





<<[[cgenrel()]] when OASADD/OASUB/etc, if l more complex than r>>=
if(l->complex >= r->complex) {
    if(l->addable < INDEXED)
        reglcgen(&nod2, l, Z);
    else
        nod2 = *l;
    regalloc(&nod1, r, Z);
    cgen(r, &nod1);
}
@

<<[[cgenrel()]] when OASADD/OASSUB/etc, if r is OCONST>>=
if(r->op == OCONST)
 if(!typefd[r->type->etype])
  if(!typefd[n->type->etype]) {
    if(l->addable < INDEXED)
        reglcgen(&nod2, l, Z);
    else
        nod2 = *l;
    regalloc(&nod, r, nn);
    gopcode(OAS, &nod2, Z, &nod);
    gopcode(o, r, Z, &nod);
    gopcode(OAS, &nod, Z, &nod2);

    regfree(&nod);
    if(l->addable < INDEXED)
        regfree(&nod2);
    break;
}
@
% mv in AST optim? with other immediate operands opti?

\subsection{Function calls}

<<[[cgenrel()]] switch node kind cases>>=
case OFUNC:
    <<[[cgenrel()]] when OFUNC, if indirect function call>>
    // else
    <<[[cgenrel()]] OFUNC case, if use REGARG, part one>>
    gargs(r, &nod, &nod1);
    <<[[cgenrel()]] OFUNC case, if l not addressable>>
    else
        gopcode(OFUNC, Z, Z, l);
    <<[[cgenrel()]] OFUNC case, if use REGARG, part two>>
    if(nn != Z) {
        regret(&nod, n);
        gopcode(OAS, &nod, Z, nn);
        regfree(&nod);
    }
    break;
@

<<[[gopcode()]] switch opcode cases>>=
case OFUNC:
    a = ABL;
    break;
@


\subsubsection{[[gargs()]]}
%????????

<<global cursafe>>=
long	cursafe;
@
% ???

<<global curarg>>=
long	curarg;
@

<<global maxargsafe>>=
long	maxargsafe;
@



<<[[codgen()]] initialisation>>=
cursafe = 0;
curarg = 0;
maxargsafe = 0;
@



<<function gargs>>=
void
gargs(Node *n, Node *tn1, Node *tn2)
{
    long regs;
    Node fnxargs[20], *fnxp;

    regs = cursafe;

    fnxp = fnxargs;
    garg1(n, tn1, tn2, 0, &fnxp);	/* compile fns to temps */

    curarg = 0;
    fnxp = fnxargs;
    garg1(n, tn1, tn2, 1, &fnxp);	/* compile normal args and temps */

    cursafe = regs;
}
@



<<function garg1(arm)>>=
void
garg1(Node *n, Node *tn1, Node *tn2, int f, Node **fnxp)
{
    Node nod;

    if(n == Z)
        return;
    if(n->op == OLIST) {
        garg1(n->left, tn1, tn2, f, fnxp);
        garg1(n->right, tn1, tn2, f, fnxp);
        return;
    } 

    if(f == 0) {
        if(n->complex >= FNX) {
            regsalloc(*fnxp, n);
            nod = znode;
            nod.op = OAS;
            nod.left = *fnxp;
            nod.right = n;
            nod.type = n->type;
            cgen(&nod, Z);
            (*fnxp)++;
        }
    } 
    else
    <<[[garg1()]] if complex argument type>>
    else
    <<[[garg1()]] if use REGARG and curarg is zero and simple type>>
    else {
        regalloc(tn1, n, Z);
        if(n->complex >= FNX) {
            cgen(*fnxp, tn1);
            (*fnxp)++;
        } else
            cgen(n, tn1);
        regaalloc(tn2, n);
        gopcode(OAS, tn1, Z, tn2);
        regfree(tn1);
    }
}
@
% rewrite as serie of if else instead of return?

\subsubsection{Caller-save vs Callee-save}

<<global nodsafe>>=
Node*	nodsafe;
@

<<[[ginit()]] special nodes initialisation>>=
nodsafe = new(ONAME, Z, Z);
nodsafe->sym = slookup(".safe");
nodsafe->type = types[TINT];
nodsafe->etype = types[TINT]->etype; // TINT
nodsafe->class = CAUTO;
complex(nodsafe);
@

<<function regsalloc>>=
void
regsalloc(Node *n, Node *nn)
{
    cursafe = align(cursafe, nn->type, Aaut3);
    maxargsafe = maxround(maxargsafe, cursafe+curarg);
    *n = *nodsafe;
    n->xoffset = -(stkoff + cursafe);
    n->type = nn->type;
    n->etype = nn->type->etype;
    n->lineno = nn->lineno;
}
@




<<function regaalloc(arm)>>=
void
regaalloc(Node *n, Node *nn)
{
    curarg = align(curarg, nn->type, Aarg1);
    *n = *nn;
    n->op = OINDREG;
    n->reg = REGSP;
    n->xoffset = curarg + SZ_LONG;
    n->complex = 0;
    n->addable = 20;
    curarg = align(curarg, nn->type, Aarg2);
    maxargsafe = maxround(maxargsafe, cursafe+curarg);
}
@
% 386 is just    n->xoffset = curarg;




\subsubsection{Indirect function calls}

<<[[cgenrel()]] OFUNC case, if l not addressable>>=
if(l->addable < INDEXED) {
    reglcgen(&nod, l, Z);
    gopcode(OFUNC, Z, Z, &nod);
    regfree(&nod);
}
@


<<[[cgenrel()]] when OFUNC, if indirect function call>>=
if(l->complex >= FNX) {
    if(l->op != OIND)
        diag(n, "bad function call");

    regret(&nod, l->left);
    cgen(l->left, &nod);
    regsalloc(&nod1, l->left);
    gopcode(OAS, &nod, Z, &nod1);
    regfree(&nod);

    nod = *n;
    nod.left = &nod2;
    nod2 = *l;
    nod2.left = &nod1;
    nod2.complex = 1;
    cgen(&nod, nn);

    return;
}
@

\subsection{Array accesses}

% because unsugared to pointer arithmetic?

\subsection{Field accesses}

<<[[tcomd()]] convert field access in offset>>=
makedot(n, t, o);
@

% tcomd -> <>
<<function makedot>>=
void
makedot(Node *n, Type *t, long o)
{
    Node *n1, *n2;

    <<[[makedot()]] if bitfields>>
    n->addable = n->left->addable;
    if(!n->addable) {
        n1 = new1(OCONST, Z, Z);
        n1->vconst = o;
        n1->type = types[TLONG];
        n->right = n1;
        n->type = t;
        return;
    }
    // else
    n->left->type = t;
    if(o == 0) {
        *n = *n->left;
        return;
    }
    n->type = t;
    n1 = new1(OCONST, Z, Z);
    n1->vconst = o;
    t = typ(TIND, t);
    t->width = types[TIND]->width;
    n1->type = t;

    n2 = new1(OADDR, n->left, Z);
    n2->type = t;

    n1 = new1(OADD, n1, n2);
    n1->type = t;

    n->op = OIND;
    n->left = n1;
    n->right = Z;
}
@
\t when not addable? when const field?


%pre: ODOT resolving has been done, transforming fieldname
% to constant. This is done in??
<<[[cgenrel()]] switch node kind cases>>=
case ODOT:
    sugen(l, nodrat, l->type->width);
    if(nn != Z) {
        warn(n, "non-interruptable temporary");
        nod = *nodrat;
        if(!r || r->op != OCONST) {
            diag(n, "DOT and no offset");
            break;
        }
        nod.xoffset += (long)r->vconst;
        nod.type = n->type;
        cgen(&nod, nn);
    }
    break;
@

<<global nodrat>>=
Node*	nodrat;
@

<<global symrathole>>=
Sym*	symrathole;
@

<<[[ginit()]] locals>>=
Type *t;
@
<<[[ginit()]] special nodes initialisation>>=
t = typ(TARRAY, types[TCHAR]);
symrathole = slookup(".rathole");
symrathole->class = CGLOBL;
symrathole->type = t;

nodrat = new(ONAME, Z, Z);
nodrat->sym = symrathole;
nodrat->type = types[TIND];
nodrat->etype = TVOID; // not TIND?
nodrat->class = CGLOBL;
complex(nodrat);
nodrat->type = t;
@

<<[[gclean()]] adjust symrathole width>>=
symrathole->type->width = nrathole;
@

<<global nrathole>>=
long	nrathole;
@

<<[[ginit()]] misc initialisations>>=
nrathole = 0;
@


<<function sugen(arm)>>=
void
sugen(Node *n, Node *nn, long w)
{
    Prog *p1;
    Node nod0, nod1, nod2, nod3, nod4, *l, *r;
    Type *t;
    long pc1;
    int i, m, c;

    if(n == Z || n->type == T)
        return;

    <<[[sugen()]] debug>>
    if(nn == nodrat)
        if(w > nrathole)
            nrathole = w;

    switch(n->op) {
    case OIND:
        if(nn == Z) {
            nullwarn(n->left, Z);
            break;
        }
    // Fallthrough

    default:
        goto copy;

    case OCONST:
        if(n->type && typev[n->type->etype]) {
            if(nn == Z) {
                nullwarn(n->left, Z);
                break;
            }

            t = nn->type;
            nn->type = types[TLONG];
            reglcgen(&nod1, nn, Z);
            nn->type = t;

            if(align(0, types[TCHAR], Aarg1))	/* isbigendian */
                gopcode(OAS, nod32const(n->vconst>>32), Z, &nod1);
            else
                gopcode(OAS, nod32const(n->vconst), Z, &nod1);
            nod1.xoffset += SZ_LONG;
            if(align(0, types[TCHAR], Aarg1))	/* isbigendian */
                gopcode(OAS, nod32const(n->vconst), Z, &nod1);
            else
                gopcode(OAS, nod32const(n->vconst>>32), Z, &nod1);

            regfree(&nod1);
            break;
        }
        goto copy;

    case ODOT:
        l = n->left;
        sugen(l, nodrat, l->type->width);
        if(nn != Z) {
            warn(n, "non-interruptable temporary");
            nod1 = *nodrat;
            r = n->right;
            if(!r || r->op != OCONST) {
                diag(n, "DOT and no offset");
                break;
            }
            nod1.xoffset += (long)r->vconst;
            nod1.type = n->type;
            sugen(&nod1, nn, w);
        }
        break;
    <<[[sugen()]] switch op cases>>

    case OAS:
        if(nn == Z) {
            if(n->addable < INDEXED)
                sugen(n->right, n->left, w);
            break;
        }
        sugen(n->right, nodrat, w);
        warn(n, "non-interruptable temporary");
        sugen(nodrat, n->left, w);
        sugen(nodrat, nn, w);
        break;

    case OFUNC:
        if(nn == Z) {
            sugen(n, nodrat, w);
            break;
        }
        if(nn->op != OIND) {
            nn = new1(OADDR, nn, Z);
            nn->type = types[TIND];
            nn->addable = 0;
        } else
            nn = nn->left;
        n = new(OFUNC, n->left, new(OLIST, nn, n->right));
        n->type = types[TVOID];
        n->left->type = types[TVOID];
        cgen(n, Z);
        break;

    case OCOND:
        bcgen(n->left, 1);
        p1 = p;
        sugen(n->right->left, nn, w);
        gbranch(OGOTO);
        patch(p1, pc);
        p1 = p;
        sugen(n->right->right, nn, w);
        patch(p1, pc);
        break;

    case OCOMMA:
        cgen(n->left, Z);
        sugen(n->right, nn, w);
        break;
    }
    return;

copy:
    if(nn == Z)
        return;
    if(n->complex >= FNX && nn->complex >= FNX) {
        t = nn->type;
        nn->type = types[TLONG];
        regialloc(&nod1, nn, Z);
        lcgen(nn, &nod1);
        regsalloc(&nod2, nn);
        nn->type = t;

        gopcode(OAS, &nod1, Z, &nod2);
        regfree(&nod1);

        nod2.type = typ(TIND, t);

        nod1 = nod2;
        nod1.op = OIND;
        nod1.left = &nod2;
        nod1.right = Z;
        nod1.complex = 1;
        nod1.type = t;

        sugen(n, &nod1, w);
        return;
    }

    w /= SZ_LONG;
    if(w <= 2) {
        if(n->complex > nn->complex) {
            reglpcgen(&nod1, n, 1);
            reglpcgen(&nod2, nn, 1);
        } else {
            reglpcgen(&nod2, nn, 1);
            reglpcgen(&nod1, n, 1);
        }
        regalloc(&nod3, &regnode, Z);
        regalloc(&nod4, &regnode, Z);
        if(nod3.reg > nod4.reg){
            /* code below assumes nod3 loaded first */
            Node t = nod3; nod3 = nod4; nod4 = t;
        }
        nod0 = *nodconst((1<<nod3.reg)|(1<<nod4.reg));
        if(w == 2 && nod1.xoffset == 0)
            gmovm(&nod1, &nod0, 0);
        else {
            gmove(&nod1, &nod3);
            if(w == 2) {
                nod1.xoffset += SZ_LONG;
                gmove(&nod1, &nod4);
            }
        }
        if(w == 2 && nod2.xoffset == 0)
            gmovm(&nod0, &nod2, 0);
        else {
            gmove(&nod3, &nod2);
            if(w == 2) {
                nod2.xoffset += SZ_LONG;
                gmove(&nod4, &nod2);
            }
        }
        regfree(&nod1);
        regfree(&nod2);
        regfree(&nod3);
        regfree(&nod4);
        return;
    }

    if(n->complex > nn->complex) {
        reglpcgen(&nod1, n, 0);
        reglpcgen(&nod2, nn, 0);
    } else {
        reglpcgen(&nod2, nn, 0);
        reglpcgen(&nod1, n, 0);
    }

    m = 0;
    for(c = 0; c < w && c < 4; c++) {
        i = tmpreg();
        if (i == 0)
            break;
        reg[i]++;
        m |= 1<<i;
    }
    nod4 = *(nodconst(m));
    if(w < 3*c) {
        for (; w>c; w-=c) {
            gmovm(&nod1, &nod4, 1);
            gmovm(&nod4, &nod2, 1);
        }
        goto out;
    }

    regalloc(&nod3, &regnode, Z);
    gopcode(OAS, nodconst(w/c), Z, &nod3);
    w %= c;
    
    pc1 = pc;
    gmovm(&nod1, &nod4, 1);
    gmovm(&nod4, &nod2, 1);

    gopcode(OSUB, nodconst(1), Z, &nod3);
    gopcode(OEQ, nodconst(0), &nod3, Z);
    p->as = ABGT;
    patch(p, pc1);
    regfree(&nod3);

out:
    if (w) {
        i = 0;
        while (c>w) {
            while ((m&(1<<i)) == 0)
                i++;
            m &= ~(1<<i);
            reg[i] = 0;
            c--;
            i++;
        }
        nod4.vconst = m;
        gmovm(&nod1, &nod4, 0);
        gmovm(&nod4, &nod2, 0);
    }
    i = 0;
    do {
        while ((m&(1<<i)) == 0)
            i++;
        reg[i] = 0;
        c--;
        i++;
    } while (c>0);
    regfree(&nod1);
    regfree(&nod2);
}
@
% >> >> >> >> >> >> >>



<<function gmovm(arm)>>=
void
gmovm(Node *f, Node *t, int w)
{
    gins(AMOVM, f, t);
    p->scond |= C_UBIT;
    if(w)
        p->scond |= C_WBIT;
}
@



<<function tmpreg(arm)>>=
int
tmpreg(void)
{
    int i;

    for(i=REGRET+1; i<NREG; i++)
        if(reg[i] == 0)
            return i;
    diag(Z, "out of fixed registers");
    return 0;
}
@


<<function reglpcgen(arm)>>=
void
reglpcgen(Node *n, Node *nn, int f)
{
    Type *t;

    t = nn->type;
    nn->type = types[TLONG];
    if(f)
        reglcgen(n, nn, Z);
    else {
        regialloc(n, nn, Z);
        lcgen(nn, n);
        regind(n, nn);
    }
    nn->type = t;
}
@



\subsection{Cast}

<<[[cgenrel()]] switch node kind cases>>=
case OCAST:
    <<[[cgenrel()]] nullwarn check if nn is null>>
    /*
     * convert from types l->n->nn
     */
    <<[[cgenrel()]] if same types>>
    // else
    regalloc(&nod, l, nn);
    cgen(l, &nod);
    regalloc(&nod1, n, &nod);
    if(inrel)
        gmover(&nod, &nod1);
    else
        gopcode(OAS, &nod, Z, &nod1);
    gopcode(OAS, &nod1, Z, nn);
    regfree(&nod1);
    regfree(&nod);
    break;
@

<<function gmover(arm)>>=
void
gmover(Node *f, Node *t)
{
    int ft, tt, a;

    ft = f->type->etype;
    tt = t->type->etype;
    a = AGOK;
    if(typechlp[ft] && typechlp[tt] && ewidth[ft] >= ewidth[tt]){
        switch(tt){
        case TSHORT:
            a = AMOVH;
            break;
        case TUSHORT:
            a = AMOVHU;
            break;
        case TCHAR:
            a = AMOVB;
            break;
        case TUCHAR:
            a = AMOVBU;
            break;
        }
    }
    if(a == AGOK)
        gmove(f, t);
    else
        gins(a, f, t);
}
@


<<[[cgenrel()]] if same types>>=
if(nocast(l->type, n->type)) {
    if(nocast(n->type, nn->type)) {
        cgen(l, nn);
        break;
    }
}
@

% cgen -> cgenrel -> <>
<<function nocast>>=
/*
 * a cast that generates no code
 * (same size move)
 */
bool
nocast(Type *t1, Type *t2)
{
    int i, b;

    if(t1->nbits)
        return false;
    i = 0;
    if(t2 != T)
        i = t2->etype;
    b = 1<<i;
    i = 0;
    if(t1 != T)
        i = t1->etype;
    if(b & ncast[i])
        return true;
    return false;
}
@

%>>

<<global ncast>>=
long	ncast[NTYPE] =
{
    [TXXX] = 0,				
    [TCHAR] = BCHAR|BUCHAR,			
    [TUCHAR] = BCHAR|BUCHAR,			
    [TSHORT] = BSHORT|BUSHORT,			
    [TUSHORT] = BSHORT|BUSHORT,			
    [TINT] = BINT|BUINT|BLONG|BULONG|BIND,	
    [TUINT] = BINT|BUINT|BLONG|BULONG|BIND,	
    [TLONG] = BINT|BUINT|BLONG|BULONG|BIND,	
    [TULONG] = BINT|BUINT|BLONG|BULONG|BIND,	
    [TVLONG] = BVLONG|BUVLONG,			
    [TUVLONG] = BVLONG|BUVLONG,			
    [TFLOAT] = BFLOAT,				
    [TDOUBLE] = BDOUBLE,			
    [TIND] = BLONG|BULONG|BIND,		
    [TFUNC] = 0,				
    [TARRAY] = 0,				
    [TVOID] = 0,				
    [TSTRUCT] = BSTRUCT,			
    [TUNION] = BUNION,				
    [TENUM] = 0,				
};
@


\subsection{Ternary expressions}

<<[[cgenrel()]] switch node kind cases>>=
case OCOND:
    bcgen(l, true);
    p1 = p;
    cgen(r->left, nn);
    gbranch(OGOTO);
    patch(p1, pc);
    p1 = p;
    cgen(r->right, nn);
    patch(p1, pc);
    break;
@




\subsection{Prefix/postfix}

<<[[cgenrel()]] switch node kind cases>>=
case OPOSTINC:
case OPOSTDEC:
    v = 1;
    if(l->type->etype == TIND)
        v = l->type->link->width;
    if(o == OPOSTDEC)
        v = -v;
    <<[[cgenrel()]] when OPOSTINC/OPOSTDEC, if bitfield>>
    if(nn == Z)
        goto pre;

    if(l->addable < INDEXED)
        reglcgen(&nod2, l, Z);
    else
        nod2 = *l;

    regalloc(&nod, l, nn);
    gopcode(OAS, &nod2, Z, &nod);
    regalloc(&nod1, l, Z);
    if(typefd[l->type->etype]) {
        regalloc(&nod3, l, Z);
        if(v < 0) {
            gopcode(OAS, nodfconst(-v), Z, &nod3);
            gopcode(OSUB, &nod3, &nod, &nod1);
        } else {
            gopcode(OAS, nodfconst(v), Z, &nod3);
            gopcode(OADD, &nod3, &nod, &nod1);
        }
        regfree(&nod3);
    } else
        gopcode(OADD, nodconst(v), &nod, &nod1);
    gopcode(OAS, &nod1, Z, &nod2);

    regfree(&nod);
    regfree(&nod1);
    if(l->addable < INDEXED)
        regfree(&nod2);
    break;
@
<<[[cgenrel()]] switch node kind cases>>=
case OPREINC:
case OPREDEC:
    v = 1;
    if(l->type->etype == TIND)
        v = l->type->link->width;
    if(o == OPREDEC)
        v = -v;
    <<[[cgenrel()]] when OPREINC/OPREDEC, if bitfield>>

pre:
    if(l->addable < INDEXED)
        reglcgen(&nod2, l, Z);
    else
        nod2 = *l;

    regalloc(&nod, l, nn);
    gopcode(OAS, &nod2, Z, &nod);
    if(typefd[l->type->etype]) {
        regalloc(&nod3, l, Z);
        if(v < 0) {
            gopcode(OAS, nodfconst(-v), Z, &nod3);
            gopcode(OSUB, &nod3, Z, &nod);
        } else {
            gopcode(OAS, nodfconst(v), Z, &nod3);
            gopcode(OADD, &nod3, Z, &nod);
        }
        regfree(&nod3);
    } else
        gopcode(OADD, nodconst(v), Z, &nod);
    gopcode(OAS, &nod, Z, &nod2);
    if(nn && l->op == ONAME)	/* in x=++i, emit USED(i) */
        gins(ANOP, l, Z);

    regfree(&nod);
    if(l->addable < INDEXED)
        regfree(&nod2);
    break;
@



\subsection{[[sizeof()]]}

% converted to int during typechecking


\section{Boolean expressions}

% idea is to generate code to evaluate expression
% and finish by an ABxxx that can be patched to jmp
% to the code when the condition was not true.

%ex:
%  if(1) { ... }
% => 
%  MOV $1, R0
%  ABxx ??tofilllater?? by patch()

<<[[cgenrel()]] switch node kind cases>>=
case OANDAND:
case OOROR:
    boolgen(n, true, nn);
    if(nn == Z)
        patch(p, pc);
    break;
@

<<[[cgenrel()]] switch node kind cases>>=
case ONOT:
    <<[[cgenrel()]] nullwarn check if nn is null>>
    boolgen(n, true, nn);
    break;
@


% OCOM?

<<[[cgenrel()]] switch node kind cases>>=
case OEQ:
case ONE:
case OLE:
case OLT:
case OGE:
case OGT:
case OLO:
case OLS:
case OHI:
case OHS:
    <<[[cgenrel()]] nullwarn check if nn is null>>
    boolgen(n, true, nn);
    break;
@




<<constant BTRUE(arm)>>=
#define	BTRUE		0x1000
@
% ugly, need to be more than node_kind max OEND

<<[[gopcode()]] locals>>=
bool btrue;
@
<<[[gopcode()]] initialisation>>=
btrue = o & BTRUE;
o &= ~BTRUE;
@



% cgenrel | bcomplex -> <>
<<function boolgen(arm)>>=
void
boolgen(Node *n, int btrue, Node *nn)
{
    int o;
    Prog *p1, *p2;
    Node *l, *r, nod, nod1;
    long curs;

    <<[[boolgen()]] debug>>
    curs = cursafe;

    l = n->left;
    r = n->right;
    switch(n->op) {

    case OCONST:
        o = vconst(n);
        if(!btrue)
            o = !o;
        gbranch(OGOTO);
        if(o) {
            p1 = p;
            gbranch(OGOTO);
            patch(p1, pc);
        }
        goto com;

    case OCOMMA:
        cgen(l, Z);
        boolgen(r, btrue, nn);
        break;

    case ONOT:
        boolgen(l, !btrue, nn);
        break;

    case OCOND:
        bcgen(l, 1);
        p1 = p;
        bcgen(r->left, btrue);
        p2 = p;
        gbranch(OGOTO);
        patch(p1, pc);
        p1 = p;
        bcgen(r->right, !btrue);
        patch(p2, pc);
        p2 = p;
        gbranch(OGOTO);
        patch(p1, pc);
        patch(p2, pc);
        goto com;

    case OANDAND:
        if(!btrue)
            goto caseor;

    caseand:
        bcgen(l, btrue);
        p1 = p;
        bcgen(r, !btrue);
        p2 = p;
        patch(p1, pc);
        gbranch(OGOTO);
        patch(p2, pc);
        goto com;

    case OOROR:
        if(!btrue)
            goto caseand;

    caseor:
        bcgen(l, !btrue);
        p1 = p;
        bcgen(r, !btrue);
        p2 = p;
        gbranch(OGOTO);
        patch(p1, pc);
        patch(p2, pc);
        goto com;

    case OEQ:
    case ONE:
    case OLE:
    case OLT:
    case OGE:
    case OGT:
    case OHI:
    case OHS:
    case OLO:
    case OLS:
        o = n->op;
        if(btrue)
            o = comrel[relindex(o)];
        if(l->complex >= FNX && r->complex >= FNX) {
            regret(&nod, r);
            cgenrel(r, &nod, btrue);
            regsalloc(&nod1, r);
            gopcode(OAS, &nod, Z, &nod1);
            regfree(&nod);
            nod = *n;
            nod.right = &nod1;
            boolgen(&nod, btrue, nn);
            break;
        }
        if(sconst(l)) {
            regalloc(&nod, r, nn);
            cgenrel(r, &nod, btrue);
            o = invrel[relindex(o)];
            gopcode(btrue ? o | BTRUE : o, l, &nod, Z);
            regfree(&nod);
            goto com;
        }
        if(sconst(r)) {
            regalloc(&nod, l, nn);
            cgenrel(l, &nod, btrue);
            gopcode(btrue ? o | BTRUE : o, r, &nod, Z);
            regfree(&nod);
            goto com;
        }

        if(l->complex >= r->complex) {
            regalloc(&nod1, l, nn);
            cgenrel(l, &nod1, btrue);
            regalloc(&nod, r, Z);
            cgenrel(r, &nod, btrue);
        } else {
            regalloc(&nod, r, nn);
            cgenrel(r, &nod, btrue);
            regalloc(&nod1, l, Z);
            cgenrel(l, &nod1, btrue);
        }
        gopcode(btrue ? o | BTRUE : o, &nod, &nod1, Z);
        regfree(&nod);
        regfree(&nod1);

    com:
        if(nn != Z) {
            p1 = p;
            gopcode(OAS, nodconst(1), Z, nn);
            gbranch(OGOTO);
            p2 = p;
            patch(p1, pc);
            gopcode(OAS, nodconst(0), Z, nn);
            patch(p2, pc);
        }
        break;

    default:
        regalloc(&nod, n, nn);
        cgen(n, &nod);
        o = ONE;
        if(btrue)
            o = comrel[relindex(o)];
        if(typefd[n->type->etype]) {
            gopcode(btrue ? o | BTRUE : o, nodfconst(0), &nod, Z);
        } else
            gopcode(o, nodconst(0), &nod, Z);
        regfree(&nod);
        goto com;

    }
    cursafe = curs;
}
@
% >> >>


<<function bcgen>>=
void
bcgen(Node *n, bool btrue)
{

    if(n->type == T)
        gbranch(OGOTO);
    else
        boolgen(n, btrue, Z);
}
@



<<global comrel>>=
/*	OEQ, ONE, OLE, OLS, OLT, OLO, OGE, OHS, OGT, OHI */
char	comrel[12] =
{
    ONE, OEQ, OGT, OHI, OGE, OHS, OLT, OLO, OLE, OLS,
};
@

<<global invrel>>=
char	invrel[12] =
{
    OEQ, ONE, OGE, OHS, OGT, OHI, OLE, OLS, OLT, OLO,
};
@








<<[[gopcode()]] switch opcode cases>>=
case OCASE:
case OEQ:
case ONE:
case OLT:
case OLE:
case OGE:
case OGT:
case OLO:
case OLS:
case OHS:
case OHI:
    a = ACMP;
    if(et == TFLOAT)
        a = ACMPF;
    else
    if(et == TDOUBLE || et == TVLONG)
        a = ACMPD;
    nextpc();
    p->as = a;
    naddr(f1, &p->from);
    if(a == ACMP && f1->op == OCONST && p->from.offset < 0 &&
        p->from.offset != 0x80000000) {
        p->as = ACMN;
        p->from.offset = -p->from.offset;
    }
    raddr(f2, p);
    switch(o) {
    case OEQ:
        a = ABEQ;
        break;
    case ONE:
        a = ABNE;
        break;
    case OLT:
        a = ABLT;
        /* ensure NaN comparison is always false */
        if(typefd[et] && !btrue)
            a = ABMI;
        break;
    case OLE:
        a = ABLE;
        if(typefd[et] && !btrue)
            a = ABLS;
        break;
    case OGE:
        a = ABGE;
        if(typefd[et] && btrue)
            a = ABPL;
        break;
    case OGT:
        a = ABGT;
        if(typefd[et] && btrue)
            a = ABHI;
        break;
    case OLO:
        a = ABLO;
        break;
    case OLS:
        a = ABLS;
        break;
    case OHS:
        a = ABHS;
        break;
    case OHI:
        a = ABHI;
        break;

    case OCASE:
        nextpc();
        p->as = ACASE;
        p->scond = 0x9;
        naddr(f2, &p->from);
        a = ABHI;
        break;
    }
    f1 = Z;
    f2 = Z;
    break;
@



\section{Other topics}

\subsection{Sizes}

% useful for pointer arithmetic, and sizeof.
% see code that maintains Node.width everywhere.

<<global ewidth>>=
schar	ewidth[NTYPE] =
{
    [TXXX] = -1,		
    [TCHAR] = SZ_CHAR,	

    [TUCHAR] = SZ_CHAR,	
    [TSHORT] = SZ_SHORT,	
    [TUSHORT] = SZ_SHORT,	
    [TINT] = SZ_INT,		
    [TUINT] = SZ_INT,		
    [TLONG] = SZ_LONG,	
    [TULONG] = SZ_LONG,	
    [TVLONG] = SZ_VLONG,	
    [TUVLONG] = SZ_VLONG,	
    [TFLOAT] = SZ_FLOAT,	
    [TDOUBLE] = SZ_DOUBLE,	

    [TIND] = SZ_IND,		
    [TFUNC] = 0,		
    [TARRAY] = -1,		
    [TVOID] = 0,		
    [TSTRUCT] = -1,		
    [TUNION] = -1,		
    [TENUM] = SZ_INT,		
};
@
%old: the designator used to be in comment, but then there is 
% a strong coupling with the enum order, and actually I got
% some regressions when I tried to reorder things in type_kind,
% so better to use a designator.
%cons? can be more complicated to bootstrap with other C compiler, but
% I don't care
%ocaml: do it via function, no need partial size here. ugly.


<<constant SZ_CHAR(arm)>>=
#define	SZ_CHAR		1
@
%ocaml: via pattern matching on Type.t

<<constant SZ_SHORT(arm)>>=
#define	SZ_SHORT	2
@

<<constant SZ_INT(arm)>>=
#define	SZ_INT		4
@

<<constant SZ_LONG(arm)>>=
#define	SZ_LONG		4
@

<<constant SZ_IND(arm)>>=
#define	SZ_IND		4
@

<<constant SZ_FLOAT(arm)>>=
#define	SZ_FLOAT	4
@

<<constant SZ_VLONG(arm)>>=
#define	SZ_VLONG	8
@

<<constant SZ_DOUBLE(arm)>>=
#define	SZ_DOUBLE	8
@


\subsection{First argument}

<<[[adecl()]] if first parameter>>=
if(autoffset == 0) {
    firstarg = s;
    firstargtype = t;
}
@

<<global firstarg>>=
Sym*	firstarg;
@

<<xdecl rule, initializations before processing a function>>=
firstarg = S; // can mv after call to dodecl? No I think.
@

<<global firstargtype>>=
Type*	firstargtype;
@


\subsection{Alignment}

% ??? -> <>
<<function align(arm)>>=
long
align(long i, Type *t, int op)
{
    long o;
    Type *v;
    int w;

    o = i;
    w = 1;
    switch(op) {
    default:
        diag(Z, "unknown align opcode %d", op);
        break;

    case Asu2:	/* padding at end of a struct */
        w = SZ_LONG;
        <<[[align()]] if packflg override w>>
        break;

    case Ael1:	/* initial align of struct element */
        for(v=t; v->etype==TARRAY; v=v->link)
            ;
        w = ewidth[v->etype];
        if(w <= 0 || w >= SZ_LONG)
            w = SZ_LONG;
        <<[[align()]] if packflg override w>>
        break;

    case Ael2:	/* width of a struct element */
        o += t->width;
        break;

    case Aarg0:	/* initial passbyptr argument in arg list */
        if(typesuv[t->etype]) {
            o = align(o, types[TIND], Aarg1);
            o = align(o, types[TIND], Aarg2);
        }
        break;

    case Aarg1:	/* initial align of parameter */
        w = ewidth[t->etype];
        if(w <= 0 || w >= SZ_LONG) {
            w = SZ_LONG;
            break;
        }
        w = 1;		/* little endian no adjustment */
        break;

    case Aarg2:	/* width of a parameter */
        o += t->width;
        w = SZ_LONG;
        break;

    case Aaut3:	/* total align of automatic */
        o = align(o, t, Ael2);
        o = align(o, t, Ael1);
        w = SZ_LONG;	/* because of a pun in cc/dcl.c:contig() */
        break;
    }
    o = round(o, w);
    if(debug['A'])
        print("align %s %ld %T = %ld\n", bnames[op], i, t, o);
    return o;
}
@
% mostly identical to 386 except for Aaut3 case, not sure why

<<function maxround>>=
long
maxround(long max, long v)
{
    v = round(v, SZ_LONG);
    if(v > max)
        return v;
    return max;
}
@




<<enum align>>=
enum align
{
    Axxx,

    Ael1,
    Ael2,
    Asu2,
    Aarg0,
    Aarg1,
    Aarg2,
    Aaut3,

    NALIGN,
};
@

<<global bnames>>=
char*	bnames[NALIGN];
@

<<global bnamesinit>>=
Init	bnamesinit[] =
{
    Axxx,	0,	"Axxx",

    Ael1,	0,	"el1",
    Ael2,	0,	"el2",
    Asu2,	0,	"su2",
    Aarg0,	0,	"arg0",
    Aarg1,	0,	"arg1",
    Aarg2,	0,	"arg2",
    Aaut3,	0,	"aut3",
    -1,	0,	0,
};
@



% called for fields of structures/unions

<<[[Type]] code generation fields>>=
long	offset;
@


<<complex rule, when parse a structure definition, align the struct>>=
sualign($$);
@

<<[[Type]] code generation fields>>=
schar	shift;
char	nbits;
@



% complex rule for struct/union definition -> <>
<<function sualign>>=
//@Scheck: not dead, used by cc.y
void sualign(Type *t)
{
    Type *l;
    long o, w;

    o = 0;
    switch(t->etype) {

    case TSTRUCT:
        t->offset = 0;
        w = 0;
        for(l = t->link; l != T; l = l->down) {
            if(l->nbits) {
                if(l->shift <= 0) {
                    l->shift = -l->shift;
                    w = round(w, tfield->width);
                    o = w;
                    w += tfield->width;
                }
                l->offset = o;
            } else {
                if(l->width < 0 ||
                   l->width == 0 && l->down != T)
                    if(l->sym)
                        diag(Z, "incomplete structure element: %s",
                            l->sym->name);
                    else
                        diag(Z, "incomplete structure element");
                w = align(w, l, Ael1);
                l->offset = w;
                w = align(w, l, Ael2);
            }
        }
        w = align(w, t, Asu2);
        t->width = w;
        acidtype(t);
        pickletype(t);
        return;

    case TUNION:
        t->offset = 0;
        w = 0;
        for(l = t->link; l != T; l = l->down) {
            if(l->width <= 0)
                if(l->sym)
                    diag(Z, "incomplete union element: %s",
                        l->sym->name);
                else
                    diag(Z, "incomplete union element");
            l->offset = 0;
            l->shift = 0;
            o = align(align(0, l, Ael1), l, Ael2);
            if(o > w)
                w = o;
        }
        w = align(w, t, Asu2);
        t->width = w;
        acidtype(t);
        pickletype(t);
        return;

    default:
        diag(Z, "unknown type in sualign: %T", t);
        break;
    }
}
@










\subsection{Toplevel globals}

<<[[gclean()]] locals>>=
Sym *s;
@
<<[[gclean()]] generate all AGLOBL pseudo opcodes>>=
for(i=0; i<NHASH; i++)
 for(s = hash[i]; s != S; s = s->link) {
    <<[[gclean()]] when generate all AGLOBL, filter and sanity check symbol>>
    // else
    gpseudo(AGLOBL, s, nodconst(s->type->width));
}
@

% the ADATA is done when process initializer.

<<[[gclean()]] when generate all AGLOBL, filter and sanity check symbol>>=
if(s->type == T)
    continue;
if(s->type->width == 0)
    continue;
if(s->class != CGLOBL && s->class != CSTATIC)
    continue;
if(s->type == types[TENUM])
    continue;
@
% can have null type? can have null width? this should not happen
% if put the test on CGLOBL and CSTATIC earlier.

\subsection{Initializers}
\t mv in advanced topics? advanced features?

% could be made a static local of init1?
<<global nodcast>>=
Node*	nodcast;
@

% declaration and expression actually
<<expression nodes>>=
OASI, // appears during parsing
@
% assign initializer?



<<[[doinit()]] sanity check initlist after init1>>=
if(initlist != Z)
    diag(initlist, "more initializers than structure: %s",
        s->name);
@
\t when can this happen?


% doinit -> <>
<<function init1>>=
Node*
init1(Sym *s, Type *t, long o, int exflag)
{
    Node *a, *l, *r, nod;
    Type *t1;
    long e, w, so, mw;

    a = peekinit();
    if(a == Z)
        return Z;

    <<[[init1()]] debug initialization>>

    if(exflag && a->op == OINIT)
        return doinit(s, t, o, nextinit());

    switch(t->etype) {
    case TCHAR:
    case TUCHAR:
    case TINT:
    case TUINT:
    case TSHORT:
    case TUSHORT:
    case TLONG:
    case TULONG:
    case TVLONG:
    case TUVLONG:
    case TFLOAT:
    case TDOUBLE:

    case TIND:
    single:
        if(a->op == OARRAY || a->op == OELEM)
            return Z;

        a = nextinit();
        if(a == Z)
            return Z;

        <<[[init1()]] sanity check t has no bitfields>>
        if(s->class == CAUTO) {
            l = new(ONAME, Z, Z);
            l->sym = s;
            l->type = t;
            l->etype = s->type ? s->type->etype : TVOID;
            l->xoffset = s->offset + o;
            l->class = s->class;

            l = new(OASI, l, a);
            return l;
        }

        complex(a);
        if(a->type == T)
            return Z;

        if(a->op == OCONST) {
            if(vconst(a) && t->etype == TIND && a->type && a->type->etype != TIND){
                diag(a, "initialize pointer to an integer: %s", s->name);
                return Z;
            }
            if(!sametype(a->type, t)) {
                /* hoop jumping to save malloc */
                if(nodcast == Z)
                    nodcast = new(OCAST, Z, Z);
                nod = *nodcast;
                nod.left = a;
                nod.type = t;
                nod.lineno = a->lineno;
                complex(&nod);
                if(nod.type)
                    *a = nod;
            }
            if(a->op != OCONST) {
                diag(a, "initializer is not a constant: %s",
                    s->name);
                return Z;
            }
            if(vconst(a) == 0)
                return Z;
            goto gext;
        }
        if(t->etype == TIND) {
            while(a->op == OCAST) {
                warn(a, "CAST in initialization ignored");
                a = a->left;
            }
            if(!sametype(t, a->type)) {
                diag(a, "initialization of incompatible pointers: %s\n%T and %T",
                    s->name, t, a->type);
            }
            if(a->op == OADDR)
                a = a->left;
            goto gext;
        }

        while(a->op == OCAST)
            a = a->left;
        if(a->op == OADDR) {
            warn(a, "initialize pointer to an integer: %s", s->name);
            a = a->left;
            goto gext;
        }
        diag(a, "initializer is not a constant: %s", s->name);
        return Z;

    gext:
        gextern(s, a, o, t->width);

        return Z;

    case TARRAY:
        w = t->link->width;
        if(a->op == OSTRING || a->op == OLSTRING)
        if(typei[t->link->etype]) {
            /*
             * get rid of null if sizes match exactly
             */
            a = nextinit();
            mw = t->width/w;
            so = a->type->width/a->type->link->width;
            if(mw && so > mw) {
                if(so != mw+1)
                    diag(a, "string initialization larger than array");
                a->type->width -= a->type->link->width;
            }

            /*
             * arrange strings to be expanded
             * inside OINIT braces.
             */
            a = new(OUSED, a, Z);
            return doinit(s, t, o, a);
        }

        mw = -w;
        l = Z;
        for(e=0;;) {
            /*
             * peek ahead for element initializer
             */
            a = peekinit();
            if(a == Z)
                break;
            if(a->op == OELEM && t->link->etype != TSTRUCT)
                break;
            if(a->op == OARRAY) {
                if(e && exflag)
                    break;
                a = nextinit();
                r = a->left;
                complex(r);
                if(r->op != OCONST) {
                    diag(r, "initializer subscript must be constant");
                    return Z;
                }
                e = r->vconst;
                if(t->width != 0)
                    if(e < 0 || e*w >= t->width) {
                        diag(a, "initialization index out of range: %ld", e);
                        continue;
                    }
            }

            so = e*w;
            if(so > mw)
                mw = so;
            if(t->width != 0)
                if(mw >= t->width)
                    break;
            r = init1(s, t->link, o+so, 1);
            l = newlist(l, r);
            e++;
        }
        if(t->width == 0)
            t->width = mw+w;
        return l;

    case TUNION:
    case TSTRUCT:
        /*
         * peek ahead to find type of rhs.
         * if its a structure, then treat
         * this element as a variable
         * rather than an aggregate.
         */
        if(isstruct(a, t))
            goto single;

        if(t->width <= 0) {
            diag(Z, "incomplete structure: %s", s->name);
            return Z;
        }
        l = Z;

    again:
        for(t1 = t->link; t1 != T; t1 = t1->down) {
            if(a->op == OARRAY && t1->etype != TARRAY)
                break;
            if(a->op == OELEM) {
                if(t1->sym != a->sym)
                    continue;
                nextinit();
            }
            r = init1(s, t1, o+t1->offset, 1);
            l = newlist(l, r);
            a = peekinit();
            if(a == Z)
                break;
            if(a->op == OELEM)
                goto again;
        }
        if(a && a->op == OELEM)
            diag(a, "structure element not found %F", a);
        return l;

    default:
        diag(Z, "unknown type in initialization: %T to: %s", t, s->name);
        return Z;
    }
}
@
%TODO: lp split, big func
%ocaml: "unknown type in initialization" is where 5c detects 
% illegal things like void foo() = 0; I detect that earlier.






<<function newlist>>=
Node*
newlist(Node *l, Node *r)
{
    if(r == Z)
        return l;
    if(l == Z)
        return r;
    return new(OLIST, l, r);
}
@

<<function isstruct>>=
bool
isstruct(Node *a, Type *t)
{
    Node *n;

    switch(a->op) {
    case ODOTDOT:
        n = a->left;
        if(n && n->type && sametype(n->type, t))
            return true;
    case OSTRING: case OLSTRING:
    case OCONST:
    case OINIT:
    case OELEM:
        return false;
    }

    n = new(ODOTDOT, Z, Z);
    *n = *a;

    /*
     * ODOTDOT is a flag for tcom
     * a second tcom will not be performed
     */
    a->op = ODOTDOT;
    a->left = n;
    a->right = Z;

    if(tcom(n))
        return false;

    if(sametype(n->type, t))
        return true;
    return false;
}
@

<<function peekinit>>=
/*
 * get next major operator,
 * dont advance initlist.
 */
Node*
peekinit(void)
{
    Node *a;

    a = initlist;

loop:
    if(a == Z)
        return a;
    if(a->op == OLIST) {
        a = a->left;
        goto loop;
    }
    return a;
}
@

<<function nextinit>>=
/*
 * consume and return next element on
 * initlist. expand strings.
 */
Node*
nextinit(void)
{
    Node *a, *b, *n;

    a = initlist;
    n = Z;

    if(a == Z)
        return a;
    if(a->op == OLIST) {
        n = a->right;
        a = a->left;
    }
    if(a->op == OUSED) {
        a = a->left;
        b = new(OCONST, Z, Z);
        b->type = a->type->link;
        if(a->op == OSTRING) {
            b->vconst = convvtox(*a->cstring, TCHAR);
            a->cstring++;
        }
        if(a->op == OLSTRING) {
            b->vconst = convvtox(*a->rstring, TRUNE);
            a->rstring++;
        }
        a->type->width -= b->type->width;
        if(a->type->width <= 0)
            initlist = n;
        return b;
    }
    initlist = n;
    return a;
}
@

%codegen: AMOV and more complex ADATA with more complex
% layout than just array of bytes.



<<adlist rule, after doinit>>=
$$ = contig($1->sym, $$, w);
@
%$

%TODO: LP split
<<function contig>>=
//@Scheck: used by cc.y
Node* contig(Sym *s, Node *n, long v)
{
    Node *p, *r, *q, *m;
    long w;
    Type *zt;

    <<[[contig()]] debug initialization>>

    if(n == Z)
        goto no;
    w = s->type->width;

    /*
     * nightmare: an automatic array whose size
     * increases when it is initialized
     */
    if(v != w) {
        if(v != 0)
            diag(n, "automatic adjustable array: %s", s->name);
        v = s->offset;
        autoffset = align(autoffset, s->type, Aaut3);
        s->offset = -autoffset;
        stkoff = maxround(stkoff, autoffset);
        symadjust(s, n, v - s->offset);
    }
    if(w <= ewidth[TIND])
        goto no;
    if(n->op == OAS)
        diag(Z, "oops in contig");
/*ZZZ this appears incorrect
need to check if the list completely covers the data.
if not, bail
 */
    if(n->op == OLIST)
        goto no;
    if(n->op == OASI)
        if(n->left->type)
        if(n->left->type->width == w)
            goto no;
    while(w & (ewidth[TIND]-1))
        w++;
/*
 * insert the following code, where long becomes vlong if pointers are fat
 *
    *(long**)&X = (long*)((char*)X + sizeof(X));
    do {
        *(long**)&X -= 1;
        **(long**)&X = 0;
    } while(*(long**)&X);
 */

    for(q=n; q->op != ONAME; q=q->left)
        ;

    zt = ewidth[TIND] > ewidth[TLONG]? types[TVLONG]: types[TLONG];

    p = new(ONAME, Z, Z);
    *p = *q;
    p->type = typ(TIND, zt);
    p->xoffset = s->offset;

    r = new(ONAME, Z, Z);
    *r = *p;
    r = new(OPOSTDEC, r, Z);

    q = new(ONAME, Z, Z);
    *q = *p;
    q = new(OIND, q, Z);

    m = new(OCONST, Z, Z);
    m->vconst = 0;
    m->type = zt;

    q = new(OAS, q, m);

    r = new(OLIST, r, q);

    q = new(ONAME, Z, Z);
    *q = *p;
    r = new(ODWHILE, q, r);

    q = new(ONAME, Z, Z);
    *q = *p;
    q->type = q->type->link;
    q->xoffset += w;
    q = new(OADDR, q, 0);

    q = new(OASI, p, q);
    r = new(OLIST, q, r);

    n = new(OLIST, r, n);

no:
    return n;
}
@


<<function symadjust>>=
void
symadjust(Sym *s, Node *n, long del)
{

    switch(n->op) {
    case ONAME:
        if(n->sym == s)
            n->xoffset -= del;
        return;

    case OCONST:
    case OSTRING: case OLSTRING:
    case OREGISTER: case OINDREG:
        return;

    default:
        if(n->left)
            symadjust(s, n->left, del);
        if(n->right)
            symadjust(s, n->right, del);
        return;

    }
}
@


\subsection{[[gextern()]]}

%todo: be consistent, don't use 'a' for opcode (above) and for Node (below)
<<function gextern(arm)>>=
void
gextern(Sym *s, Node *a, long o, long w)
{
    <<[[gextern()]] if OCONST and a vlong type>>
    else {
        gpseudo(ADATA, s, a);
        p->from.offset += o;
        p->reg = w; // attributes
        if(p->to.type == D_OREG)
            p->to.type = D_CONST; // D_ADDR?
    }
}
@
%less: += o? why not just = o?
%pad: was D_CONST
\t what is this D_OREG special code?



\section{Advanced assembly generation}

\subsection{Function calls}


<<[[cgenrel()]] if all complex fields more than FNX>>=
if(n->complex >= FNX)
 if(l->complex >= FNX)
  if(r != Z && r->complex >= FNX)
    switch(o) {
    case OFUNC:
    case OCOMMA:
    case OANDAND:
    case OOROR:
    case OCOND:
    case ODOT:
        break;
    
    default:
        regret(&nod, r);
        cgen(r, &nod);
    
        regsalloc(&nod1, r);
        gopcode(OAS, &nod, Z, &nod1);
    
        regfree(&nod);
        nod = *n;
        nod.right = &nod1;
        cgen(&nod, nn);
        return;
    
    }
@


\subsection{Switch}


<<[[gen()]] locals>>=
Case *cn;
@
<<[[gen()]] switch node kind cases>>=
case OSWITCH:
    l = n->left;
    complex(l);
    if(l->type == T)
        break;
    <<[[gen()]] when OSWITCH, typecheck condition>>

    gbranch(OGOTO);		/* entry */
    sp = p;

    cn = cases;
    cases = C;
    casf();

    sbc = breakpc;
    breakpc = pc;
    snbreak = nbreak;
    nbreak = 0;

    gbranch(OGOTO);
    spb = p;

    gen(n->right);		/* body */
    if(canreach){
        gbranch(OGOTO);
        patch(p, breakpc);

        nbreak++;
    }

    patch(sp, pc);
    regalloc(&nod, l, Z);
    /* always signed */
    if(typev[l->type->etype])
        nod.type = types[TVLONG];
    else
        nod.type = types[TLONG];
    cgen(l, &nod);
    doswit(&nod);
    regfree(&nod);
    patch(spb, pc);

    cases = cn;
    breakpc = sbc;
    canreach = nbreak!=0;
    if(canreach == false)
        warnreach = !suppress;
    nbreak = snbreak;
    break;
@





<<global typev>>=
char	typev[NTYPE];
@
% very long
<<global typevinit>>=
int	typevinit[] =
{
    TVLONG,	TUVLONG, -1,
};
@




<<[[gen()]] switch node kind cases>>=
case OCASE:
    canreach = true;
    l = n->left;
    if(cases == C)
        diag(n, "case/default outside a switch");
    if(l == Z) {
        casf();
        cases->val = 0;
        cases->def = 1;
        cases->label = pc;
        cases->isv = 0;
        goto rloop;
    }
    complex(l);
    if(l->type == T)
        goto rloop;
    if(l->op != OCONST || !typeswitch[l->type->etype]) {
        diag(n, "case expression must be integer constant");
        goto rloop;
    }
    casf();
    cases->val = l->vconst;
    cases->def = 0;
    cases->label = pc;
    cases->isv = typev[l->type->etype];
    goto rloop;
@


% C1, Case are in 5c/
% the code below is in cc2/pswt.c


<<struct Case>>=
struct	Case
{
    vlong	val;
    long	label;
    char	def;
    char 	isv;

    Case*	link;
};
@



<<constant C>>=
#define	C	((Case*)nil)
@


<<struct C1>>=
struct	C1
{
    vlong	val;
    long	label;
};
@


<<global cases>>=
Case*	cases;
@
<<[[ginit()]] misc initialisations>>=
cases = C;
@


<<global cases>>=
Case*	cases;
@


<<function swcmp>>=
int
swcmp(const void *a1, const void *a2)
{
    C1 *p1, *p2;

    p1 = (C1*)a1;
    p2 = (C1*)a2;
    if(p1->val < p2->val)
        return -1;
    return p1->val > p2->val;
}
@

<<function doswit>>=
void
doswit(Node *n)
{
    Case *c;
    C1 *q, *iq, *iqh, *iql;
    long def, nc, i, j, isv, nh;
    Prog *hsb;
    Node *vr[2];
    int dup;

    def = 0;
    nc = 0;
    isv = 0;
    for(c = cases; c->link != C; c = c->link) {
        if(c->def) {
            if(def)
                diag(n, "more than one default in switch");
            def = c->label;
            continue;
        }
        isv |= c->isv;
        nc++;
    }
    if(typev[n->type->etype])
        isv = 1;
    else if(isv){
        warn(n, "32-bit switch expression with 64-bit case constant");
        isv = 0;
    }

    iq = alloc(nc*sizeof(C1));
    q = iq;
    for(c = cases; c->link != C; c = c->link) {
        if(c->def)
            continue;
        if(c->isv && !isv)
            continue;	/* can never match */
        q->label = c->label;
        if(isv)
            q->val = c->val;
        else
            q->val = (long)c->val;	/* cast ensures correct value for 32-bit switch on 64-bit architecture */
        q++;
    }
    qsort(iq, nc, sizeof(C1), swcmp);

    if(debug['K'])
     for(i=0; i<nc; i++)
        print("case %2ld: = %.8llux\n", i, (vlong)iq[i].val);
 
   dup = 0;
    for(i=0; i<nc-1; i++)
        if(iq[i].val == iq[i+1].val) {
            diag(n, "duplicate cases in switch %lld", (vlong)iq[i].val);
            dup = 1;
        }
    if(dup)
        return;
    if(def == 0) {
        def = breakpc;
        nbreak++;
    }
    if(!isv || ewidth[TIND] > ewidth[TLONG] || n->op == OREGISTER) {
        swit1(iq, nc, def, n);
        return;
    }

    /*
     * 64-bit case on 32-bit machine:
     * switch on high-order words, and
     * in each of those, switch on low-order words
     */
    if(n->op != OREGPAIR)
        fatal(n, "internal: expected register pair");
    if(thechar == '8'){	/* TO DO: need an enquiry function */
        vr[0] = n->left;	/* low */
        vr[1] = n->right;	/* high */
    }else{
        vr[0] = n->right;
        vr[1] = n->left;
    }
    vr[0]->type = types[TLONG];
    vr[1]->type = types[TLONG];

    gbranch(OGOTO);
    hsb = p;

    iqh = alloc(nc*sizeof(C1));
    iql = alloc(nc*sizeof(C1));
    nh = 0;
    for(i=0; i<nc;){
        iqh[nh].val = iq[i].val >> 32;
        q = iql;
        /* iq is sorted, so equal top halves are adjacent */
        for(j = i; j < nc; j++){
            if((iq[j].val>>32) != iqh[nh].val)
                break;
            q->val = (long)iq[j].val;
            q->label = iq[j].label;
            q++;
        }
        qsort(iql,  q-iql, sizeof(C1), swcmp);
                //if(0){for(int k=0; k<(q-iql); k++)print("nh=%ld k=%d h=%#llux l=%#llux lab=%ld\n", nh, k, (vlong)iqh[nh].val,  (vlong)iql[k].val, iql[k].label);}
        iqh[nh].label = pc;
        nh++;
        swit1(iql, q-iql, def, vr[0]);
        i = j;
    }
    patch(hsb, pc);
        //if(0){for(int k=0; k<nh; k++)print("k*=%d h=%#llux lab=%ld\n", k, (vlong)iqh[k].val,  iqh[k].label);}
    swit1(iqh, nh, def, vr[1]);
}
@

<<function casf>>=
void
casf(void)
{
    Case *c;

    c = alloc(sizeof(*c));
    c->link = cases;
    cases = c;
}
@

<<function swit1(arm)>>=
void
swit1(C1 *q, int nc, long def, Node *n)
{
    Node tn;
    
    regalloc(&tn, &regnode, Z);
    swit2(q, nc, def, n, &tn);
    regfree(&tn);
}
@

<<function swit2(arm)>>=
void
swit2(C1 *q, int nc, long def, Node *n, Node *tn)
{
    C1 *r;
    int i;
    long v;
    Prog *sp;

    if(nc >= 3) {
        i = (q+nc-1)->val - (q+0)->val;
        if(i > 0 && i < nc*2)
            goto direct;
    }
    if(nc < 5) {
        for(i=0; i<nc; i++) {
            if(debug['K'])
                print("case = %.8llux\n", q->val);
            gopcode(OEQ, nodconst(q->val), n, Z);
            patch(p, q->label);
            q++;
        }
        gbranch(OGOTO);
        patch(p, def);

        return;
    }

    i = nc / 2;
    r = q+i;
    if(debug['K'])
        print("case > %.8llux\n", r->val);
    gopcode(OGT, nodconst(r->val), n, Z);
    sp = p;
    gopcode(OEQ, nodconst(r->val), n, Z);	/* just gen the B.EQ */
    patch(p, r->label);
    swit2(q, i, def, n, tn);

    if(debug['K'])
        print("case < %.8llux\n", r->val);
    patch(sp, pc);
    swit2(r+1, nc-i-1, def, n, tn);
    return;

direct:
    v = q->val;
    if(v != 0)
        gopcode(OSUB, nodconst(v), Z, n);
    gopcode(OCASE, nodconst((q+nc-1)->val - v), n, Z);
    patch(p, def);
    for(i=0; i<nc; i++) {
        if(debug['K'])
            print("case = %.8llux\n", q->val);
        while(q->val != v) {
            nextpc();
            p->as = ABCASE;
            patch(p, def);
            v++;
        }
        nextpc();
        p->as = ABCASE;
        patch(p, q->label);
        q++;
        v++;
    }

    gbranch(OGOTO);		/* so that regopt() won't be confused */
    patch(p, def);
}
@




\chapter{Object File Generation}
% Dupe with Assembler.nw. Quite simple.

%runtime support also? _main and main? more?
%http://compiler-rt.llvm.org/

% see also 5c -S in appendix.

\section{Object format}

\section{Instruction output, [[outcode()]]}

<<struct Htab>>=
struct Htab { 
    Sym *sym; 
    short type; 
};
@
<<[[Sym]] identifier value, code generation fields>>=
// index in h when the Sym is really a symbol, 0 when not a symbol
char	symidx;
@
%ocaml: use Marshall


% main -> compile -> yyparse; gclean -> <>
%less: do LP split like I did in Assembler.nw
<<function outcode(arm)>>=
void
outcode(void)
{
    struct Htab h[NSYM];
    Prog *p;
    Sym *s;
    int sf, st, t, sym;

    <<[[outcode()]] debug>>
    outhist(&outbuf);
    for(sym=0; sym<NSYM; sym++) {
        h[sym].sym = S;
        h[sym].type = 0;
    }
    sym = 1;
    for(p = firstp; p != P; p = p->link) {
    jackpot:
        sf = 0;
        s = p->from.sym;
        while(s != S) {
            sf = s->symidx;
            if(sf < 0 || sf >= NSYM)
                sf = 0;
            t = p->from.symkind;
            if(h[sf].type == t)
            if(h[sf].sym == s)
                break;
            s->symidx = sym;
            zname(&outbuf, s, t);
            h[sym].sym = s;
            h[sym].type = t;
            sf = sym;
            sym++;
            if(sym >= NSYM)
                sym = 1;
            break;
        }
        st = 0;
        s = p->to.sym;
        while(s != S) {
            st = s->symidx;
            if(st < 0 || st >= NSYM)
                st = 0;
            t = p->to.symkind;
            if(h[st].type == t)
            if(h[st].sym == s)
                break;
            s->symidx = sym;
            zname(&outbuf, s, t);
            h[sym].sym = s;
            h[sym].type = t;
            st = sym;
            sym++;
            if(sym >= NSYM)
                sym = 1;
            if(st == sf)
                goto jackpot;
            break;
        }
        zwrite(&outbuf, p, sf, st);
    }
    firstp = P;
    lastp = P;
}
@
%ocaml: use Marshall

<<function zwrite(arm)>>=
void
zwrite(Biobuf *b, Prog *p, int sf, int st)
{
    char bf[100], *bp;

    bf[0] = p->as;
    bf[1] = p->scond;
    bf[2] = p->reg;
    bf[3] = p->lineno;
    bf[4] = p->lineno>>8;
    bf[5] = p->lineno>>16;
    bf[6] = p->lineno>>24;
    bp = zaddr(bf+7, &p->from, sf);
    bp = zaddr(bp, &p->to, st);
    Bwrite(b, bf, bp-bf);
}
@


\section{Operand output, [[zaddr()]]}


<<function zaddr(arm)>>=
char*
zaddr(char *bp, Adr *a, int s)
{
    long l;
    Ieee e;

    bp[0] = a->type;
    bp[1] = a->reg;
    bp[2] = s;
    bp[3] = a->symkind;
    bp += 4;

    //if(a->type == D_CONST && a->symkind != N_NONE) {
    //    diag(Z, "missing D_CONST -> D_ADDR migration");
    //}
    //if(a->type == D_ADDR && a->symkind == N_NONE) {
    //    diag(Z, "wrong D_CONST -> D_ADDR migration");
    //}

    switch(a->type) {
    case D_NONE:
    case D_REG:
    case D_FREG:
    case D_PSR:
        break;

    case D_OREG:
    case D_CONST:
    case D_ADDR:
    case D_BRANCH:
    case D_SHIFT:
        l = a->offset;
        bp[0] = l;
        bp[1] = l>>8;
        bp[2] = l>>16;
        bp[3] = l>>24;
        bp += 4;
        break;

    case D_SCONST:
        memmove(bp, a->sval, NSNAME);
        bp += NSNAME;
        break;

    case D_FCONST:
        ieeedtod(&e, a->dval);
        l = e.l;
        bp[0] = l;
        bp[1] = l>>8;
        bp[2] = l>>16;
        bp[3] = l>>24;
        bp += 4;
        l = e.h;
        bp[0] = l;
        bp[1] = l>>8;
        bp[2] = l>>16;
        bp[3] = l>>24;
        bp += 4;
        break;
    default:
        diag(Z, "unknown type %d in zaddr", a->type);

    }
    return bp;
}
@
%pad: I added D_ADDR and sanity check D_CONST
%ocaml: use Marshall



\section{Symbol table, [[zname()]], [[h]] and [[ANAME]]}
% spreaded
% and SIGNAME!




<<function zname(arm)>>=
void
zname(Biobuf *b, Sym *s, int t)
{
    char *n, bf[7];
    ulong sig;

    n = s->name;
    <<[[zname()]] if generate signature for symbol s>>
    else{
        bf[0] = ANAME;
        bf[1] = t;	/* type */
        bf[2] = s->symidx;	/* sym */
        Bwrite(b, bf, 3);
    }
    Bwrite(b, n, strlen(n)+1);
}
@
%ocaml: use Marshall


\section{File and line information, [[outhist()]]}

<<function outhist(arm)>>=
void
outhist(Biobuf *b)
{
    Hist *h;
    char *p, *q, *op, c;
    Prog pg;
    int n;

    pg = zprog;
    pg.as = AHISTORY;
    c = pathchar();
    for(h = hist; h != H; h = h->link) {
        p = h->name;
        op = 0;
        /* on windows skip drive specifier in pathname */
        //if(systemtype(Windows) && p && p[1] == ':'){
        //	p += 2;
        //	c = *p;
        //}
        if(p && p[0] != c && h->offset == 0 && pathname){
            /* on windows skip drive specifier in pathname */
            //if(systemtype(Windows) && pathname[1] == ':') {
            //	op = p;
            //	p = pathname+2;
            //	c = *p;
            //} else 
            if(pathname[0] == c){
                op = p;
                p = pathname;
            }
        }
        while(p) {
            q = utfrune(p, c);
            if(q) {
                n = q-p;
                if(n == 0){
                    n = 1;	/* leading "/" */
                    *p = '/';	/* don't emit "\" on windows */
                }
                q++;
            } else {
                n = strlen(p);
                q = 0;
            }
            if(n) {
                Bputc(b, ANAME);
                Bputc(b, N_FILE);
                Bputc(b, 1);
                Bputc(b, '<');
                Bwrite(b, p, n);
                Bputc(b, '\0');
            }
            p = q;
            if(p == 0 && op) {
                p = op;
                op = 0;
            }
        }
        pg.lineno = h->line;
        pg.to.type = zprog.to.type;
        pg.to.offset = h->offset;
        if(h->offset)
            pg.to.type = D_CONST;

        zwrite(b, &pg, 0, 0);
    }
}
@





\chapter{AST-level Optimizations}
% Typed-AST optimizations; need types for certain optimizations.
% archi independent

% see compcert list of optimisations? there are all of them here too?
% and more?


\section{AST simplifications}

% using a visitor would be better, to avoid boilerplate

\subsection{General rewrites, [[ccom()]]}

% mostly partial evaluation when have constants involved
% in operations.

% complex -> <> 
% cc/com.c
<<function ccom>>=
/*
 *	general rewrite
 *	(IND(ADDR x)) ==> x
 *	(ADDR(IND x)) ==> x
 *	remove some zero operands
 *	remove no op casts
 *	evaluate constants // important one!
 */
void
ccom(Node *n)
{
    Node *l, *r;
    int t;

loop:
    if(n == Z)
        return;

    l = n->left;
    r = n->right;
    switch(n->op) {
    <<[[ccom()]] switch node kind cases>>
    default:
        // recurse
        if(l != Z)
            ccom(l);
        if(r != Z)
            ccom(r);
        // Fallthrough
    common:
        if(((l == Z)||(l->op == OCONST)) && ((r == Z)||(r->op == OCONST)))
            evconst(n);
    }
}
@
%old: I rewrote common: to be positive rather than using 'break'
%old: I had a bug and wrote
%        if((l == Z) || (r == Z) || (l->op == OCONST) || (r->op == OCONST))
%            evconst(n);
% but on mk testall it was causing many errors.

% call recursively ccom first, so evconst can assume evconst.
% has been called on its leaves.

<<[[ccom()]] switch node kind cases>>=
case OCONST:
case ONAME:
    break;
@


<<[[ccom()]] switch node kind cases>>=
case OREGISTER:
case OINDREG:
    break;
@


\subsubsection{No op casts}

<<[[ccom()]] switch node kind cases>>=
case OCAST:
    ccom(l);
    if(l->op == OCONST) {
        evconst(n);
        if(n->op == OCONST)
            break;
    }
    if(nocast(l->type, n->type) &&
       (!typefd[l->type->etype] || 
       typeu[l->type->etype] && typeu[n->type->etype]) ) {
        l->type = n->type;
        *n = *l;
    }
    break;
@

\subsubsection{Pointers and addresses}

<<[[ccom()]] switch node kind cases>>=
case OADDR:
    ccom(l);
    l->etype = TVOID; // ????
    if(l->op == OIND) {
        l->left->type = n->type;
        *n = *l->left;
        break;
    }
    goto common;
@

<<[[ccom()]] switch node kind cases>>=
case OIND:
    ccom(l);
    if(l->op == OADDR) {
        l->left->type = n->type;
        *n = *l->left;
        break;
    }
    goto common;
@


\subsubsection{Zero operands}

<<[[ccom()]] switch node kind cases>>=
case OADD:
case OOR:
case OXOR:
    ccom(l);
    if(vconst(l) == 0) {
        *n = *r;
        goto loop;
    }
    ccom(r);
    if(vconst(r) == 0) {
        *n = *l;
        break;
    }
    goto commute;
@

<<[[ccom()]] switch node kind cases>>=
commute:
    /* look for commutative constant */
    if(r->op == OCONST) {
        if(l->op == n->op) {
            if(l->left->op == OCONST) {
                n->right = l->right;
                l->right = r;
                goto loop;
            }
            if(l->right->op == OCONST) {
                n->right = l->left;
                l->left = r;
                goto loop;
            }
        }
    }
    if(l->op == OCONST) {
        if(r->op == n->op) {
            if(r->left->op == OCONST) {
                n->left = r->right;
                r->right = l;
                goto loop;
            }
            if(r->right->op == OCONST) {
                n->left = r->left;
                r->left = l;
                goto loop;
            }
        }
    }
    goto common;
@





<<[[ccom()]] switch node kind cases>>=
case OAND:
    ccom(l);
    ccom(r);
    if(vconst(l) == 0 && !side(r)) {
        *n = *l;
        break;
    }
    if(vconst(r) == 0 && !side(l)) {
        *n = *r;
        break;
    }
    // Fallthrough, goto commute
@


% look if has side effect?
% ccom -> <>
<<function side>>=
bool
side(Node *n)
{

loop:
    if(n != Z)
    switch(n->op) {
    case OCAST:
    case ONOT:
    case OADDR:
    case OIND:
        n = n->left;
        goto loop;

    case OCOND:
        if(side(n->left))
            break;
        n = n->right;

    case OEQ:
    case ONE:
    case OLT:
    case OGE:
    case OGT:
    case OLE:
    case OADD:
    case OSUB:
    case OMUL:
    case OLMUL:
    case ODIV:
    case OLDIV:
    case OLSHR:
    case OASHL:
    case OASHR:
    case OAND:
    case OOR:
    case OXOR:
    case OMOD:
    case OLMOD:
    case OANDAND:
    case OOROR:
    case OCOMMA:
    case ODOT:
        if(side(n->left))
            break;
        n = n->right;
        goto loop;

    case OSIGN:
    case OSIZE:
    case OCONST:
    case OSTRING:
    case OLSTRING:
    case ONAME:
        return false;
    }
    // OFUNC/OAS/OASADD/...
    return true;
}
@





<<[[ccom()]] switch node kind cases>>=
case OASHR:
case OASHL:
case OLSHR:
    ccom(l);
    if(vconst(l) == 0 && !side(r)) {
        *n = *l;
        break;
    }
    ccom(r);
    if(vconst(r) == 0) {
        *n = *l;
        break;
    }
    <<[[ccom()]] when OASHR/OASHL/OLSHR, check for stupid shift>>
    goto common;
@


<<[[ccom()]] switch node kind cases>>=
case OMUL:
case OLMUL:
    ccom(l);
    t = vconst(l);
    if(t == 0 && !side(r)) {
        *n = *l;
        break;
    }
    if(t == 1) {
        *n = *r;
        goto loop;
    }
    ccom(r);
    t = vconst(r);
    if(t == 0 && !side(l)) {
        *n = *r;
        break;
    }
    if(t == 1) {
        *n = *l;
        break;
    }
    goto common;
@
% see also opti on OMUL and other in xcom() like bitshift opportunities.

<<[[ccom()]] switch node kind cases>>=
case ODIV:
case OLDIV:
    ccom(l);
    if(vconst(l) == 0 && !side(r)) {
        *n = *l;
        break;
    }
    ccom(r);
    t = vconst(r);
    if(t == 0) {
        diag(n, "divide check");
        *n = *r;
        break;
    }
    if(t == 1) {
        *n = *l;
        break;
    }
    goto common;
@



\subsubsection{Sub to Add}

% OADD more performant than OSUB? meh
% or because use more patterns with OADD than OSUB for optim opportunities?

<<[[ccom()]] switch node kind cases>>=
case OSUB:
    ccom(r);
    if(r->op == OCONST) {
        if(typefd[r->type->etype]) {
            n->op = OADD;
            r->fconst = -r->fconst;
            goto loop;
        } else {
            n->op = OADD;
            r->vconst = -r->vconst;
            goto loop;
        }
    }
    ccom(l);
    goto common;
@


\subsubsection{Comparisons}

<<[[ccom()]] switch node kind cases>>=
case OEQ:
case ONE:

case OLE:
case OGE:
case OLT:
case OGT:

case OLS:
case OHS:
case OLO:
case OHI:
    ccom(l);
    ccom(r);
    if(compar(n, 0) || compar(n, 1))
        break;
    relcon(l, r);
    relcon(r, l);
    goto common;
@


<<function relcon>>=
/*
 * try to cast a constant down
 * rather than cast a variable up
 * example:
 *	if(c == 'a')
 */
void
relcon(Node *l, Node *r)
{
    vlong v;

    if(l->op != OCONST)
        return;
    if(r->op != OCAST)
        return;
    if(!nilcast(r->left->type, r->type))
        return;
    switch(r->type->etype) {
    default:
        return;
    case TCHAR:
    case TUCHAR:
    case TSHORT:
    case TUSHORT:
        v = convvtox(l->vconst, r->type->etype);
        if(v != l->vconst)
            return;
        break;
    }
    l->type = r->left->type;
    *r = *r->left;
}
@

<<function nilcast>>=
/*
 * a cast that has a noop semantic
 * (small to large, convert)
 */
bool
nilcast(Type *t1, Type *t2)
{
    int et1, et2;

    if(t1 == T)
        return false;
    if(t1->nbits)
        return false;
    if(t2 == T)
        return false;
    et1 = t1->etype;
    et2 = t2->etype;
    if(et1 == et2)
        return true;
    if(typefd[et1] && typefd[et2]) {
        if(ewidth[et1] < ewidth[et2])
            return true;
        return false;
    }
    if(typechlp[et1] && typechlp[et2]) {
        if(ewidth[et1] < ewidth[et2])
            return true;
        return false;
    }
    return false;
}
@


%\subsubsection{[[compar()]]}

% could be moved in Checking section?

<<struct Big>>=
/* 128-bit numbers */
struct Big
{
    vlong a;
    uvlong b;
};
@

%ctor
<<function big>>=
Big
big(vlong a, uvlong b)
{
    Big x;

    x.a = a;
    x.b = b;
    return x;
}
@


<<function cmp>>=
static int
cmp(Big x, Big y)
{
    if(x.a != y.a){
        if(x.a < y.a)
            return -1;
        return 1;
    }
    if(x.b != y.b){
        if(x.b < y.b)
            return -1;
        return 1;
    }
    return 0;
}
@

<<function add>>=
static Big
add(Big x, int y)
{
    uvlong ob;
    
    ob = x.b;
    x.b += y;
    if(y > 0 && x.b < ob)
        x.a++;
    if(y < 0 && x.b > ob)
        x.a--;
    return x;
} 
@


<<after parsing nodes>>=
OHI,
OHS,
OLO,
OLS,
@
% for unsigned context, see evconst()
% I think created only via comrel, relindex, and so on

<<global cmps>>=
/*	OEQ, ONE, OLE, OLS, OLT, OLO, OGE, OHS, OGT, OHI */
static char *cmps[12] = 
{
    "==", "!=", "<=", "<=", "<", "<", ">=", ">=", ">", ">",
};
@

<<function compar>>=
int
compar(Node *n, int reverse)
{
    Big lo, hi, x;
    int op;
    char xbuf[40], cmpbuf[50];
    Node *l, *r;
    Type *lt, *rt;

    /*
     * The point of this function is to diagnose comparisons 
     * that can never be true or that look misleading because
     * of the `usual arithmetic conversions'.  As an example 
     * of the latter, if x is a ulong, then if(x <= -1) really means
     * if(x <= 0xFFFFFFFF), while if(x <= -1LL) really means
     * what it says (but 8c compiles it wrong anyway).
     */

    if(reverse){
        r = n->left;
        l = n->right;
        op = comrel[relindex(n->op)];
    }else{
        l = n->left;
        r = n->right;
        op = n->op;
    }

    /*
     * Skip over left casts to find out the original expression range.
     */
    while(l->op == OCAST)
        l = l->left;
    if(l->op == OCONST)
        return 0;

    lt = l->type;
    if(l->op == ONAME && l->sym->type){
        lt = l->sym->type;
        if(lt->etype == TARRAY)
            lt = lt->link;
    }
    if(lt == T)
        return 0;
    if(lt->etype == TXXX || lt->etype > TUVLONG)
        return 0;
    
    /*
     * Skip over the right casts to find the on-screen value.
     */
    if(r->op != OCONST)
        return 0;
    while(r->oldop == OCAST && !r->xcast)
        r = r->left;
    rt = r->type;
    if(rt == T)
        return 0;

    x.b = r->vconst;
    x.a = 0;
    if((rt->etype&1) && r->vconst < 0)	/* signed negative */
        x.a = ~0ULL;

    if((lt->etype&1)==0){
        /* unsigned */
        lo = big(0, 0);
        if(lt->width == 8)
            hi = big(0, ~0ULL);
        else
            hi = big(0, (1LL<<(l->type->width*8))-1);
    }else{
        lo = big(~0ULL, -(1LL<<(l->type->width*8-1)));
        hi = big(0, (1LL<<(l->type->width*8-1))-1);
    }

    switch(op){
    case OLT:
    case OLO:
    case OGE:
    case OHS:
        if(cmp(x, lo) <= 0)
            goto useless;
        if(cmp(x, add(hi, 1)) >= 0)
            goto useless;
        break;
    case OLE:
    case OLS:
    case OGT:
    case OHI:
        if(cmp(x, add(lo, -1)) <= 0)
            goto useless;
        if(cmp(x, hi) >= 0)
            goto useless;
        break;
    case OEQ:
    case ONE:
        /*
         * Don't warn about comparisons if the expression
         * is as wide as the value: the compiler-supplied casts
         * will make both outcomes possible.
         */
        if(lt->width >= rt->width && debug['w'] < 2)
            return 0;
        if(cmp(x, lo) < 0 || cmp(x, hi) > 0)
            goto useless;
        break;
    }
    return 0;

useless:
    if((x.a==0 && x.b<=9) || (x.a==~0LL && x.b >= -9ULL))
        snprint(xbuf, sizeof xbuf, "%lld", x.b);
    else if(x.a == 0)
        snprint(xbuf, sizeof xbuf, "%#llux", x.b);
    else
        snprint(xbuf, sizeof xbuf, "%#llx", x.b);
    if(reverse)
        snprint(cmpbuf, sizeof cmpbuf, "%s %s %T",
            xbuf, cmps[relindex(n->op)], lt);
    else
        snprint(cmpbuf, sizeof cmpbuf, "%T %s %s",
            lt, cmps[relindex(n->op)], xbuf);
    if(debug['y']) 
        prtree(n, "strange");
    warn(n, "useless or misleading comparison: %s", cmpbuf);
    return 0;
}
@
% >> >> >>




\subsubsection{Boolean expressions}

<<[[ccom()]] switch node kind cases>>=
case OANDAND:
    ccom(l);
    if(vconst(l) == 0) {
        *n = *l;
        break;
    }
    ccom(r);
    goto common;
@

<<[[ccom()]] switch node kind cases>>=
case OOROR:
    ccom(l);
    if(l->op == OCONST && l->vconst != 0) {
        *n = *l;
        n->vconst = 1;
        break;
    }
    ccom(r);
    goto common;
@


<<[[ccom()]] switch node kind cases>>=
case OCOND:
    ccom(l);
    ccom(r);
    if(l->op == OCONST)
        if(vconst(l) == 0)
            *n = *r->right;
        else
            *n = *r->left;
    break;
@
% evaluate OCOND!



\subsection{Constant evaluation, [[evconst()]]}

% Necessary also for typechecking arrays, enumeration constant resolution,
% but true that could force programmer to write simple constants
% for those things. 
% Still, not really an optimization, more like a feature.
% Still also used for optimization? a bit like partial evaluation?

% gen | ... -> complex -> ccom -> <>
% evaluate constants statically.
%pre: can expect evconst() has been called already on the leaves, see
% ccom(), and except node to satisfy
%          if(((l == Z)||(l->op == OCONST)) && ((r == Z)||(r->op == OCONST)))
% ccom() again.

% (complex -> ccom) | ?? -> <>
<<function evconst>>=
void
evconst(Node *n)
{
    Node *l, *r;
    int et;
    bool isf;
    vlong v = 0;
    double d = 0;

    if(n == Z || n->type == T)
        return;

    et = n->type->etype;
    isf = typefd[et];

    l = n->left;
    r = n->right;

    switch(n->op) {
    <<[[evconst()]] switch node kind cases>>
    default:
        return;
    }
    // reach this point if the node is indeed a candidate to "constification"
    if(isf)
        n->fconst = d;
    else
        n->vconst = convvtox(v, n->type->etype);
    n->oldop = n->op;
    n->op = OCONST;
}
@

<<[[Node]] origin tracking fields>>=
// enum<node_kind>
char	oldop;
@
% when retag a node as an OCONST, we want to remember
% what it was actually before. 
% This is used only in compar() right now.



<<[[evconst()]] switch node kind cases>>=
case OCONST:
    break;
@
% good! nothing to do

<<[[evconst()]] switch node kind cases>>=
case OCAST:
    if(et == TVOID)
        return;
    et = l->type->etype;
    if(isf) {
        if(typefd[et])
            d = l->fconst;
        else
            d = l->vconst;
    } else {
        if(typefd[et])
            v = l->fconst;
        else
            v = convvtox(l->vconst, n->type->etype);
    }
    break;
@


%// assume have done explicit cast and balancing before?
<<[[evconst()]] switch node kind cases>>=
case OADD:
    if(isf)
        d = l->fconst + r->fconst;
    else 
        v = l->vconst + r->vconst;
    break;

case OSUB:
    if(isf)
        d = l->fconst - r->fconst;
    else
        v = l->vconst - r->vconst;
    break;

case OMUL:
    if(isf)
        d = l->fconst * r->fconst;
    else
        v = l->vconst * r->vconst;
    break;

case ODIV:
    if(vconst(r) == 0) {
        warn(n, "divide by zero");
        return;
    }
    if(isf)
        d = l->fconst / r->fconst;
    else
        v = l->vconst / r->vconst;
    break;

case OMOD:
    if(vconst(r) == 0) {
        warn(n, "modulo by zero");
        return;
    }
    v = l->vconst % r->vconst;
    break;
@
% very meta :) use C operation to interpret C operations

<<[[evconst()]] switch node kind cases>>=
case OLMUL:
    v = (uvlong)l->vconst * (uvlong)r->vconst;
    break;

case OLDIV:
    if(vconst(r) == 0) {
        warn(n, "divide by zero");
        return;
    }
    v = (uvlong)l->vconst / (uvlong)r->vconst;
    break;

case OLMOD:
    if(vconst(r) == 0) {
        warn(n, "modulo by zero");
        return;
    }
    v = (uvlong)l->vconst % (uvlong)r->vconst;
    break;
@

% how knows l is a constant? no recursive call to evconst?
<<[[evconst()]] switch node kind cases>>=
case ONEG:
    if(isf)
        d = -l->fconst;
    else
        v = -l->vconst;
    break;

case OCOM:
    v = ~l->vconst;
    break;
@
% what about OPOS. Removed at typechecking time.
% ONEG and OCOM too, but guarded by a machcap()

<<[[evconst()]] switch node kind cases>>=
case OAND:
    v = l->vconst & r->vconst;
    break;

case OOR:
    v = l->vconst | r->vconst;
    break;

case OXOR:
    v = l->vconst ^ r->vconst;
    break;
@

<<[[evconst()]] switch node kind cases>>=
case OLSHR:
    v = (uvlong)l->vconst >> r->vconst;
    break;

case OASHR:
    v = l->vconst >> r->vconst;
    break;

case OASHL:
    v = l->vconst << r->vconst;
    break;
@
% need only one cast, if one is unsigned, 5c add unsigned cast
% to other one too (meta!!)

<<[[evconst()]] switch node kind cases>>=
case OLT:
    if(typefd[l->type->etype])
        v = l->fconst < r->fconst;
    else
        v = l->vconst < r->vconst;
    break;

case OGT:
    if(typefd[l->type->etype])
        v = l->fconst > r->fconst;
    else
        v = l->vconst > r->vconst;
    break;

case OLE:
    if(typefd[l->type->etype])
        v = l->fconst <= r->fconst;
    else
        v = l->vconst <= r->vconst;
    break;

case OGE:
    if(typefd[l->type->etype])
        v = l->fconst >= r->fconst;
    else
        v = l->vconst >= r->vconst;
    break;
@

% a good side effect of evconst() is that it helps
% understand the semantic of certain opcodes :)
<<[[evconst()]] switch node kind cases>>=
case OLO:
    v = (uvlong)l->vconst < (uvlong)r->vconst;
    break;

case OHI:
    v = (uvlong)l->vconst > (uvlong)r->vconst;
    break;

case OLS:
    v = (uvlong)l->vconst <= (uvlong)r->vconst;
    break;

case OHS:
    v = (uvlong)l->vconst >= (uvlong)r->vconst;
    break;
@

<<[[evconst()]] switch node kind cases>>=
case OEQ:
    if(typefd[l->type->etype])
        v = l->fconst == r->fconst;
    else
        v = l->vconst == r->vconst;
    break;

case ONE:
    if(typefd[l->type->etype])
        v = l->fconst != r->fconst;
    else
        v = l->vconst != r->vconst;
    break;
@

<<[[evconst()]] switch node kind cases>>=
case OANDAND:
    if(typefd[l->type->etype])
        v = l->fconst && r->fconst;
    else
        v = l->vconst && r->vconst;
    break;

case OOROR:
    if(typefd[l->type->etype])
        v = l->fconst || r->fconst;
    else
        v = l->vconst || r->vconst;
    break;
case ONOT:
    if(typefd[l->type->etype])
        v = !l->fconst;
    else
        v = !l->vconst;
    break;
@



\section{Comma hoisting, [[comma()]]}

% not really an optimization? needed otherwise code generator
% will fail? no, cgen() and uncomma() handles it, but
% maybe can lead to better code.

% was not in my kencc fork, so an optimization?


<<struct Com>>=
struct Com
{
    int	n;
    Node	*t[500];
};
@

% complex -> <>
<<function comma>>=
static void
comma(Node *n)
{
    Com com;
    Node *nn;

    com.n = 0;
    nn = commas(&com, n);

    if(com.n > 0){

if(debug['y'])print("n=%d\n", com.n);
if(debug['y']) prtree(nn, "res");

        if(nn != n)
            *n = *nn;
        while(com.n > 0){

if(debug['y']) prtree(com.t[com.n-1], "tree");

            nn = new1(OXXX, Z, Z);
            *nn = *n;
            n->op = OCOMMA;
            n->type = nn->type;
            n->left = com.t[--com.n];
            n->right = nn;
            n->lineno = n->left->lineno;
        }
if(debug['y']) prtree(n, "final");

    }else if(n != nn)
        fatal(n, "odd tree");
}
@


<<function commas>>=
static Node*
commas(Com *com, Node *n)
{
    Node *t;

    if(n == Z)
        return n;
    switch(n->op){
    case OREGISTER:
    case OINDREG:
    case OCONST:
    case ONAME:
    case OSTRING:
        /* leaf */
        return n;

    case OCOMMA:
        t = commas(com, n->left);
        if(com->n >= nelem(com->t))
            fatal(n, "comma list overflow");
        com->t[com->n++] = t;
        return commas(com, n->right);

    case OFUNC:
        n->left = commas(com, n->left);
        n->right = comargs(com, n->right);
        return n;

    case OCOND:
        n->left = commas(com, n->left);
        comma(n->right->left);
        comma(n->right->right);
        return n;

    case OANDAND:
    case OOROR:
        n->left = commas(com, n->left);
        comma(n->right);
        return n;

    case ORETURN:
        comma(n->left);
        return n;
    }
    n->left = commas(com, n->left);
    if(n->right != Z)
        n->right = commas(com, n->right);
    return n;
}
@


<<function comargs>>=
/*
 * hoist comma operators out of expressions
 *	(a,b) OP c => (a, b OP c)
 *	OP(a,b) =>	(a, OP b)
 *	a OP (b,c) => (b, a OP c)
 */

static Node*
comargs(Com *com, Node *n)
{
    if(n != Z && n->op == OLIST){
        n->left = comargs(com, n->left);
        n->right = comargs(com, n->right);
    }
    return commas(com, n);
}
@




\section{Bitshifting opportunities}

% arith -> <>
<<function vlog>>=
int
vlog(Node *n)
{
    if(n->op != OCONST)
        goto bad;
    if(typefd[n->type->etype])
        goto bad;

    return log2(n->vconst);

bad:
    return -1;
}
@


<<[[arith()]] when substract two pointers, convert DIV to SHR if can>>=
w = vlog(n1);
if(w >= 0) {
    n->op = OASHR;
    n1->vconst = w;
}
@


<<[[xcom()]] switch op cases to set addable>>=
case OMUL:
case OLMUL:
    xcom(l);
    xcom(r);
    t = vlog(r);
    if(t >= 0) {
        n->op = OASHL;
        r->vconst = t;
        r->type = types[TINT];
    }
    t = vlog(l);
    if(t >= 0) {
        n->op = OASHL;
        n->left = r;
        n->right = l;
        r = l;
        l = n->left;
        r->vconst = t;
        r->type = types[TINT];
    }
    break;
@
% why in xcom? why not in ccom?

<<[[xcom()]] switch op cases to set addable>>=
case OASLMUL:
case OASMUL:
    xcom(l);
    xcom(r);
    t = vlog(r);
    if(t >= 0) {
        n->op = OASASHL;
        r->vconst = t;
        r->type = types[TINT];
    }
    break;
@

<<[[xcom()]] switch op cases to set addable>>=
case OLDIV:
    xcom(l);
    xcom(r);
    t = vlog(r);
    if(t >= 0) {
        n->op = OLSHR;
        r->vconst = t;
        r->type = types[TINT];
    }
    break;
@

<<[[xcom()]] switch op cases to set addable>>=
case OASLDIV:
    xcom(l);
    xcom(r);
    t = vlog(r);
    if(t >= 0) {
        n->op = OASLSHR;
        r->vconst = t;
        r->type = types[TINT];
    }
    break;
@

% not so arch-independent transfo
<<[[cgenrel()]] when ODIV/OMOD, convert to SHR if possible>>=
if(nn != Z)
 if((t = vlog(r)) >= 0) {
    /* signed div/mod by constant power of 2 */
    cgen(l, nn);
    gopcode(OGE, nodconst(0), nn, Z);
    p1 = p;
    if(o == ODIV) {
        gopcode(OADD, nodconst((1<<t)-1), Z, nn);
        patch(p1, pc);
        gopcode(OASHR, nodconst(t), Z, nn);
    } else {
        gopcode(OSUB, nn, nodconst(0), nn);
        gopcode(OAND, nodconst((1<<t)-1), Z, nn);
        gopcode(OSUB, nn, nodconst(0), nn);
        gbranch(OGOTO);
        patch(p1, pc);
        p1 = p;
        gopcode(OAND, nodconst((1<<t)-1), Z, nn);
        patch(p1, pc);
    }
    break;
}
@

\section{And opportunities}

<<[[xcom()]] switch op cases to set addable>>=
case OLMOD:
    xcom(l);
    xcom(r);
    t = vlog(r);
    if(t >= 0) {
        n->op = OAND;
        r->vconst--;
    }
    break;
@


<<[[xcom()]] switch op cases to set addable>>=
case OASLMOD:
    xcom(l);
    xcom(r);
    t = vlog(r);
    if(t >= 0) {
        n->op = OASAND;
        r->vconst--;
    }
    break;
@

\section{Immediate operands}
% kinda Assembly-level opti?

\subsection{Substraction}

<<[[cgenrel()]] when OSUB, if l is OCONST>>=
if(nn != Z)
 if(l->op == OCONST)
  if(!typefd[n->type->etype]) {
    cgen(r, nn);
    gopcode(o, Z, l, nn);
    break;
}
@

\subsection{Addition, or, etc.}


<<[[cgenrel()]] when OADD/OAND/etc, if r is OCONST>>=
/*
 * immediate operands
 */
if(nn != Z)
 if(r->op == OCONST)
  if(!typefd[n->type->etype]) {
    cgen(l, nn);
    if((r->vconst == 0) && (o != OAND))
        break;
    if(nn != Z)
        gopcode(o, r, Z, nn);
    break;
}
@
% look on the right for constant only because normalized already
% in xcom. See below.

<<[[xcom()]] switch node opkind cases to set complexity>>=
case OADD:
case OAND:
case OOR:
case OXOR:
case OEQ:
case ONE:
    /*
     * immediate operators, make const on right
     */
    if(l->op == OCONST) {
        n->left = r;
        n->right = l;
    }
    break;
@
%ocaml: TODO should do that in rewrite.ml in separate phase;
% nothing to do with complexity really

\subsection{Multiplication}

<<[[cgenrel()]] when OMUL/OLMUL, mulcon opportunity>>=
if(o == OMUL || o == OLMUL) {
    if(mulcon(n, nn))
        break;
}
@


% cgen -> cgenrel -> <>
<<function mulcon(arm)>>=
bool
mulcon(Node *n, Node *nn)
{
    Node *l, *r, nod1, nod2;
    Multab *m;
    long v, vs;
    int o;
    char code[sizeof(m->code)+2], *p;

    if(typefd[n->type->etype])
        return false;

    l = n->left;
    r = n->right;
    if(l->op == OCONST) {
        l = r;
        r = n->left;
    }
    if(r->op != OCONST)
        return false;


    v = convvtox(r->vconst, n->type->etype);
    if(v != r->vconst) {
        if(debug['M'])
            print("%L multiply conv: %lld\n", n->lineno, r->vconst);
        return false;
    }
    m = mulcon0(v);
    if(!m) {
        if(debug['M'])
            print("%L multiply table: %lld\n", n->lineno, r->vconst);
        return false;
    }
    if(debug['M'] && debug['v'])
        print("%L multiply: %ld\n", n->lineno, v);

    memmove(code, m->code, sizeof(m->code));
    code[sizeof(m->code)] = 0;

    p = code;
    if(p[1] == 'i')
        p += 2;
    regalloc(&nod1, n, nn);
    cgen(l, &nod1);
    vs = v;
    regalloc(&nod2, n, Z);

loop:
    switch(*p) {
    case 0:
        regfree(&nod2);
        if(vs < 0) {
            gopcode(OAS, &nod1, Z, &nod1);
            gopcode(OSUB, &nod1, nodconst(0), nn);
        } else 
            gopcode(OAS, &nod1, Z, nn);
        regfree(&nod1);
        return true;
    case '+':
        o = OADD;
        goto addsub;
    case '-':
        o = OSUB;
    addsub:	/* number is r,n,l */
        v = p[1] - '0';
        r = &nod1;
        if(v&4)
            r = &nod2;
        n = &nod1;
        if(v&2)
            n = &nod2;
        l = &nod1;
        if(v&1)
            l = &nod2;
        gopcode(o, l, n, r);
        break;
    default: /* op is shiftcount, number is r,l */
        v = p[1] - '0';
        r = &nod1;
        if(v&2)
            r = &nod2;
        l = &nod1;
        if(v&1)
            l = &nod2;
        v = *p - 'a';
        if(v < 0 || v >= 32) {
            diag(n, "mulcon unknown op: %c%c", p[0], p[1]);
            break;
        }
        gopcode(OASHL, nodconst(v), l, r);
        break;
    }
    p += 2;
    goto loop;
}
@



<<struct Multab(arm)>>=
struct	Multab
{
    long	val;
    char	code[20];
};
@

<<global multab(arm)>>=
Multab	multab[20];
@
% 386 has this global too, but the type is different


% in 5c/mul.c
%/*
% * code sequences for multiply by constant.
% * [a-l][0-3]
% *	lsl	$(A-'a'),r0,r1
% * [+][0-7]
% *	add	r0,r1,r2
% * [-][0-7]
% *	sub	r0,r1,r2
% */

<<global maxmulops(arm)>>=
static  int	maxmulops = 3;	/* max # of ops to replace mul with */
@
%$

<<global multabp(arm)>>=
static	int	multabp;
@

<<global mulval(arm)>>=
static	long	mulval;
@

<<global mulcp(arm)>>=
static	char*	mulcp;
@

<<global valmax(arm)>>=
static	long	valmax;
@

<<global shmax(arm)>>=
static	int	shmax;
@

<<enum _anon_ (5c/mul.c)(arm)>>=
enum
{
    SR1	= 1<<0,		/* r1 has been shifted */
    SR0	= 1<<1,		/* r0 has been shifted */
    UR1	= 1<<2,		/* r1 has not been used */
    UR0	= 1<<3,		/* r0 has not been used */
};
@
% >> >> >> >>

<<struct Hintab(arm)>>=
struct	Hintab
{
    ushort	val;
    char	hint[10];
};
@


<<function mulcon0(arm)>>=
Multab*
mulcon0(long v)
{
    int a1, a2, g;
    Multab *m, *m1;
    char hint[10];

    if(v < 0)
        v = -v;

    /*
     * look in cache
     */
    m = multab;
    for(g=0; g<nelem(multab); g++) {
        if(m->val == v) {
            if(m->code[0] == 0)
                return 0;
            return m;
        }
        m++;
    }

    /*
     * select a spot in cache to overwrite
     */
    multabp++;
    if(multabp < 0 || multabp >= nelem(multab))
        multabp = 0;
    m = multab+multabp;
    m->val = v;
    mulval = v;

    /*
     * look in execption hint table
     */
    a1 = 0;
    a2 = hintabsize;
    for(;;) {
        if(a1 >= a2)
            goto no;
        g = (a2 + a1)/2;
        if(v < hintab[g].val) {
            a2 = g;
            continue;
        }
        if(v > hintab[g].val) {
            a1 = g+1;
            continue;
        }
        break;
    }

    if(docode(hintab[g].hint, m->code, 1, 0))
        return m;
    print("multiply table failure %ld\n", v);
    m->code[0] = 0;
    return 0;

no:
    /*
     * try to search
     */
    hint[0] = 0;
    for(g=1; g<=maxmulops; g++) {
        if(g >= maxmulops && v >= 65535)
            break;
        mulcp = hint+g;
        *mulcp = 0;
        if(gen1(g)) {
            if(docode(hint, m->code, 1, 0))
                return m;
            print("multiply table failure %ld\n", v);
            break;
        }
    }

    /*
     * try a recur followed by a shift
     */
    g = 0;
    while(!(v & 1)) {
        g++;
        v >>= 1;
    }
    if(g) {
        m1 = mulcon0(v);
        if(m1) {
            strcpy(m->code, m1->code);
            sprint(strchr(m->code, 0), "%c0", g+'a');
            return m;
        }
    }
    m->code[0] = 0;
    return 0;
}
@

<<function docode(arm)>>=
static int
docode(char *hp, char *cp, int r0, int r1)
{
    int c, i;

    c = *hp++;
    *cp = c;
    cp += 2;
    switch(c) {
    default:
        c -= 'a';
        if(c < 1 || c >= 30)
            break;
        for(i=0; i<4; i++) {
            switch(i) {
            case 0:
                if(docode(hp, cp, r0<<c, r1))
                    goto out;
                break;
            case 1:
                if(docode(hp, cp, r1<<c, r1))
                    goto out;
                break;
            case 2:
                if(docode(hp, cp, r0, r0<<c))
                    goto out;
                break;
            case 3:
                if(docode(hp, cp, r0, r1<<c))
                    goto out;
                break;
            }
        }
        break;

    case '+':
        for(i=0; i<8; i++) {
            cp[-1] = i+'0';
            switch(i) {
            case 1:
                if(docode(hp, cp, r0+r1, r1))
                    goto out;
                break;
            case 5:
                if(docode(hp, cp, r0, r0+r1))
                    goto out;
                break;
            }
        }
        break;

    case '-':
        for(i=0; i<8; i++) {
            cp[-1] = i+'0';
            switch(i) {
            case 1:
                if(docode(hp, cp, r0-r1, r1))
                    goto out;
                break;
            case 2:
                if(docode(hp, cp, r1-r0, r1))
                    goto out;
                break;
            case 5:
                if(docode(hp, cp, r0, r0-r1))
                    goto out;
                break;
            case 6:
                if(docode(hp, cp, r0, r1-r0))
                    goto out;
                break;
            }
        }
        break;

    case 0:
        if(r0 == mulval)
            return 1;
    }
    return 0;

out:
    cp[-1] = i+'0';
    return 1;
}
@

<<function gen1(arm)>>=
static int
gen1(int len)
{
    int i;

    for(shmax=1; shmax<30; shmax++) {
        valmax = 1<<shmax;
        if(valmax >= mulval)
            break;
    }
    if(mulval == 1)
        return 1;

    len--;
    for(i=1; i<=shmax; i++)
        if(gen2(len, 1<<i)) {
            *--mulcp = 'a'+i;
            return 1;
        }
    return 0;
}
@

<<function gen2(arm)>>=
static int
gen2(int len, long r1)
{
    int i;

    if(len <= 0) {
        if(r1 == mulval)
            return 1;
        return 0;
    }

    len--;
    if(len == 0)
        goto calcr0;

    if(gen3(len, r1, r1+1, UR1)) {
        i = '+';
        goto out;
    }
    if(gen3(len, r1-1, r1, UR0)) {
        i = '-';
        goto out;
    }
    if(gen3(len, 1, r1+1, UR1)) {
        i = '+';
        goto out;
    }
    if(gen3(len, 1, r1-1, UR1)) {
        i = '-';
        goto out;
    }

    return 0;

calcr0:
    if(mulval == r1+1) {
        i = '+';
        goto out;
    }
    if(mulval == r1-1) {
        i = '-';
        goto out;
    }
    return 0;

out:
    *--mulcp = i;
    return 1;
}
@

<<function gen3(arm)>>=
static int
gen3(int len, long r0, long r1, int flag)
{
    int i, f1, f2;
    long x;

    if(r0 <= 0 ||
       r0 >= r1 ||
       r1 > valmax)
        return 0;

    len--;
    if(len == 0)
        goto calcr0;

    if(!(flag & UR1)) {
        f1 = UR1|SR1;
        for(i=1; i<=shmax; i++) {
            x = r0<<i;
            if(x > valmax)
                break;
            if(gen3(len, r0, x, f1)) {
                i += 'a';
                goto out;
            }
        }
    }

    if(!(flag & UR0)) {
        f1 = UR1|SR1;
        for(i=1; i<=shmax; i++) {
            x = r1<<i;
            if(x > valmax)
                break;
            if(gen3(len, r1, x, f1)) {
                i += 'a';
                goto out;
            }
        }
    }

    if(!(flag & SR1)) {
        f1 = UR1|SR1|(flag&UR0);
        for(i=1; i<=shmax; i++) {
            x = r1<<i;
            if(x > valmax)
                break;
            if(gen3(len, r0, x, f1)) {
                i += 'a';
                goto out;
            }
        }
    }

    if(!(flag & SR0)) {
        f1 = UR0|SR0|(flag&(SR1|UR1));

        f2 = UR1|SR1;
        if(flag & UR1)
            f2 |= UR0;
        if(flag & SR1)
            f2 |= SR0;

        for(i=1; i<=shmax; i++) {
            x = r0<<i;
            if(x > valmax)
                break;
            if(x > r1) {
                if(gen3(len, r1, x, f2)) {
                    i += 'a';
                    goto out;
                }
            } else
                if(gen3(len, x, r1, f1)) {
                    i += 'a';
                    goto out;
                }
        }
    }

    x = r1+r0;
    if(gen3(len, r0, x, UR1)) {
        i = '+';
        goto out;
    }

    if(gen3(len, r1, x, UR1)) {
        i = '+';
        goto out;
    }

    x = r1-r0;
    if(gen3(len, x, r1, UR0)) {
        i = '-';
        goto out;
    }

    if(x > r0) {
        if(gen3(len, r0, x, UR1)) {
            i = '-';
            goto out;
        }
    } else
        if(gen3(len, x, r0, UR0)) {
            i = '-';
            goto out;
        }

    return 0;

calcr0:
    f1 = flag & (UR0|UR1);
    if(f1 == UR1) {
        for(i=1; i<=shmax; i++) {
            x = r1<<i;
            if(x >= mulval) {
                if(x == mulval) {
                    i += 'a';
                    goto out;
                }
                break;
            }
        }
    }

    if(mulval == r1+r0) {
        i = '+';
        goto out;
    }
    if(mulval == r1-r0) {
        i = '-';
        goto out;
    }

    return 0;

out:
    *--mulcp = i;
    return 1;
}
@

<<global hintab(arm)>>=
/*
 * hint table has numbers that
 * the search algorithm fails on.
 * <1000:
 *	all numbers
 * <5000:
 * 	 by 5
 * <10000:
 * 	 by 50
 * <65536:
 * 	 by 250
 */
Hintab	hintab[] =
{
    683,	"b++d+e+",
    687,	"b+e++e-",
    691,	"b++d+e+",
    731,	"b++d+e+",
    811,	"b++d+i+",
    821,	"b++e+e+",
    843,	"b+d++e+",
    851,	"b+f-+e-",
    853,	"b++e+e+",
    877,	"c++++g-",
    933,	"b+c++g-",
    981,	"c-+e-d+",
    1375,	"b+c+b+h-",
    1675,	"d+b++h+",
    2425,	"c++f-e+",
    2675,	"c+d++f-",
    2750,	"b+d-b+h-",
    2775,	"c-+g-e-",
    3125,	"b++e+g+",
    3275,	"b+c+g+e+",
    3350,	"c++++i+",
    3475,	"c-+e-f-",
    3525,	"c-+d+g-",
    3625,	"c-+e-j+",
    3675,	"b+d+d+e+",
    3725,	"b+d-+h+",
    3925,	"b+d+f-d-",
    4275,	"b+g++e+",
    4325,	"b+h-+d+",
    4425,	"b+b+g-j-",
    4525,	"b+d-d+f+",
    4675,	"c++d-g+",
    4775,	"b+d+b+g-",
    4825,	"c+c-+i-",
    4850,	"c++++i-",
    4925,	"b++e-g-",
    4975,	"c+f++e-",
    5500,	"b+g-c+d+",
    6700,	"d+b++i+",
    9700,	"d++++j-",
    11000,	"b+f-c-h-",
    11750,	"b+d+g+j-",
    12500,	"b+c+e-k+",
    13250,	"b+d+e-f+",
    13750,	"b+h-c-d+",
    14250,	"b+g-c+e-",
    14500,	"c+f+j-d-",
    14750,	"d-g--f+",
    16750,	"b+e-d-n+",
    17750,	"c+h-b+e+",
    18250,	"d+b+h-d+",
    18750,	"b+g-++f+",
    19250,	"b+e+b+h+",
    19750,	"b++h--f-",
    20250,	"b+e-l-c+",
    20750,	"c++bi+e-",
    21250,	"b+i+l+c+",
    22000,	"b+e+d-g-",
    22250,	"b+d-h+k-",
    22750,	"b+d-e-g+",
    23250,	"b+c+h+e-",
    23500,	"b+g-c-g-",
    23750,	"b+g-b+h-",
    24250,	"c++g+m-",
    24750,	"b+e+e+j-",
    25000,	"b++dh+g+",
    25250,	"b+e+d-g-",
    25750,	"b+e+b+j+",
    26250,	"b+h+c+e+",
    26500,	"b+h+c+g+",
    26750,	"b+d+e+g-",
    27250,	"b+e+e+f+",
    27500,	"c-i-c-d+",
    27750,	"b+bd++j+",
    28250,	"d-d-++i-",
    28500,	"c+c-h-e-",
    29000,	"b+g-d-f+",
    29500,	"c+h+++e-",
    29750,	"b+g+f-c+",
    30250,	"b+f-g-c+",
    33500,	"c-f-d-n+",
    33750,	"b+d-b+j-",
    34250,	"c+e+++i+",
    35250,	"e+b+d+k+",
    35500,	"c+e+d-g-",
    35750,	"c+i-++e+",
    36250,	"b+bh-d+e+",
    36500,	"c+c-h-e-",
    36750,	"d+e--i+",
    37250,	"b+g+g+b+",
    37500,	"b+h-b+f+",
    37750,	"c+be++j-",
    38500,	"b+e+b+i+",
    38750,	"d+i-b+d+",
    39250,	"b+g-l-+d+",
    39500,	"b+g-c+g-",
    39750,	"b+bh-c+f-",
    40250,	"b+bf+d+g-",
    40500,	"b+g-c+g+",
    40750,	"c+b+i-e+",
    41250,	"d++bf+h+",
    41500,	"b+j+c+d-",
    41750,	"c+f+b+h-",
    42500,	"c+h++g+",
    42750,	"b+g+d-f-",
    43250,	"b+l-e+d-",
    43750,	"c+bd+h+f-",
    44000,	"b+f+g-d-",
    44250,	"b+d-g--f+",
    44500,	"c+e+c+h+",
    44750,	"b+e+d-h-",
    45250,	"b++g+j-g+",
    45500,	"c+d+e-g+",
    45750,	"b+d-h-e-",
    46250,	"c+bd++j+",
    46500,	"b+d-c-j-",
    46750,	"e-e-b+g-",
    47000,	"b+c+d-j-",
    47250,	"b+e+e-g-",
    47500,	"b+g-c-h-",
    47750,	"b+f-c+h-",
    48250,	"d--h+n-",
    48500,	"b+c-g+m-",
    48750,	"b+e+e-g+",
    49500,	"c-f+e+j-",
    49750,	"c+c+g++f-",
    50000,	"b+e+e+k+",
    50250,	"b++i++g+",
    50500,	"c+g+f-i+",
    50750,	"b+e+d+k-",
    51500,	"b+i+c-f+",
    51750,	"b+bd+g-e-",
    52250,	"b+d+g-j+",
    52500,	"c+c+f+g+",
    52750,	"b+c+e+i+",
    53000,	"b+i+c+g+",
    53500,	"c+g+g-n+",
    53750,	"b+j+d-c+",
    54250,	"b+d-g-j-",
    54500,	"c-f+e+f+",
    54750,	"b+f-+c+g+",
    55000,	"b+g-d-g-",
    55250,	"b+e+e+g+",
    55500,	"b+cd++j+",
    55750,	"b+bh-d-f-",
    56250,	"c+d-b+j-",
    56500,	"c+d+c+i+",
    56750,	"b+e+d++h-",
    57000,	"b+d+g-f+",
    57250,	"b+f-m+d-",
    57750,	"b+i+c+e-",
    58000,	"b+e+d+h+",
    58250,	"c+b+g+g+",
    58750,	"d-e-j--e+",
    59000,	"d-i-+e+",
    59250,	"e--h-m+",
    59500,	"c+c-h+f-",
    59750,	"b+bh-e+i-",
    60250,	"b+bh-e-e-",
    60500,	"c+c-g-g-",
    60750,	"b+e-l-e-",
    61250,	"b+g-g-c+",
    61750,	"b+g-c+g+",
    62250,	"f--+c-i-",
    62750,	"e+f--+g+",
    64750,	"b+f+d+p-",
};
@

<<global hintabsize (5c/mul.c)(arm)>>=
int	hintabsize	= nelem(hintab);
@

% dupe?
<<global hintabsize(arm)>>=
int	hintabsize;
@












\section{Associative-commutative arithmetic optimisations}
% see also 5c -m, print add/mul/sub trees


% "acom is Aho and Ullman's acommute (with all the exercises done).
% basically it does code improvements taking advantage of
% associative-commutative operations, and extends that to look for
% further optimisations mentioned in Thompson's paper on the compiler.
% Ritchie's PDP-11 C compiler did something similar (but he called it
% acommute and distrib). comments such as "bust terms out" and "look
% for factorable terms c1*i + c1*c2*j -> c1*(i + c2*j) suggest what
% it's doing). essentially it flattens levels of an expression tree
% using associative and commutative operators into an array and
% rearranges them." - fortsith

\subsection{[[Term]]}

<<constant NTERM>>=
#define	NTERM		10
@

<<struct Term>>=
struct	Term
{
    vlong	mult;
    Node	*node;
};
@

<<global term>>=
Term	term[NTERM];
@

<<global nterm>>=
int	nterm;
@


\subsection{[[acom()]]}
% cc/scon.c ??

<<function acom>>=
void
acom(Node *n)
{
    Type *t;
    Node *l, *r;
    int i;

    switch(n->op)
    {

    case ONAME:
    case OCONST:
    case OSTRING:
    case OINDREG:
    case OREGISTER:
        return;

    case ONEG:
        l = n->left;
        if(addo(n) && addo(l))
            break;
        acom(l);
        return;

    case OADD:
    case OSUB:
    case OMUL:
        l = n->left;
        r = n->right;
        if(addo(n)) {
            if(addo(r))
                break;
            if(addo(l))
                break;
        }
        acom(l);
        acom(r);
        return;

    default:
        l = n->left;
        r = n->right;
        if(l != Z)
            acom(l);
        if(r != Z)
            acom(r);
        return;
    }

    /* bust terms out */
    t = n->type;
    term[0].mult = 0;
    term[0].node = Z;
    nterm = 1;
    acom1(1, n);

    if(debug['m'])
     for(i=0; i<nterm; i++) {
        print("%d %3lld ", i, term[i].mult);
        prtree1(term[i].node, 1, 0);
    }

    if(nterm < NTERM)
        acom2(n, t);
    n->type = t;
}
@
% hmm 'm' already used for macro debugging => use M instead? or n?

<<function addo>>=
int
addo(Node *n)
{

    if(n != Z)
    if(!typefd[n->type->etype])
    if(!typev[n->type->etype] || ewidth[TVLONG] == ewidth[TIND])
    switch(n->op) {

    case OCAST:
        if(nilcast(n->left->type, n->type))
            return 1;
        break;

    case ONEG:
    case OADD:
    case OSUB:
        return 1;

    case OMUL:
        if(n->left->op == OCONST)
            return 1;
        if(n->right->op == OCONST)
            return 1;
    }
    return 0;
}
@


<<function acom1>>=
void
acom1(vlong v, Node *n)
{
    Node *l, *r;

    if(v == 0 || nterm >= NTERM)
        return;
    if(!addo(n)) {
        if(n->op == OCONST)
        if(!typefd[n->type->etype]) {
            term[0].mult += v*n->vconst;
            return;
        }
        term[nterm].mult = v;
        term[nterm].node = n;
        nterm++;
        return;
    }
    switch(n->op) {

    case OCAST:
        acom1(v, n->left);
        break;

    case ONEG:
        acom1(-v, n->left);
        break;

    case OADD:
        acom1(v, n->left);
        acom1(v, n->right);
        break;

    case OSUB:
        acom1(v, n->left);
        acom1(-v, n->right);
        break;

    case OMUL:
        l = n->left;
        r = n->right;
        if(l->op == OCONST)
        if(!typefd[n->type->etype]) {
            acom1(v*l->vconst, r);
            break;
        }
        if(r->op == OCONST)
        if(!typefd[n->type->etype]) {
            acom1(v*r->vconst, l);
            break;
        }
        break;

    default:
        diag(n, "not addo");
    }
}
@



<<function acast>>=
static Node*
acast(Type *t, Node *n)
{
    if(n->type->etype != t->etype || n->op == OBIT) {
        n = new1(OCAST, n, Z);
        if(nocast(n->left->type, t))
            *n = *n->left;
        n->type = t;
    }
    return n;
}
@



<<function acomcmp1>>=
int
acomcmp1(const void *a1, const void *a2)
{
    vlong c1, c2;
    Term *t1, *t2;

    t1 = (Term*)a1;
    t2 = (Term*)a2;
    c1 = t1->mult;
    if(c1 < 0)
        c1 = -c1;
    c2 = t2->mult;
    if(c2 < 0)
        c2 = -c2;
    if(c1 > c2)
        return 1;
    if(c1 < c2)
        return -1;
    c1 = 1;
    if(t1->mult < 0)
        c1 = 0;
    c2 = 1;
    if(t2->mult < 0)
        c2 = 0;
    if(c2 -= c1)
        return c2;
    if(t2 > t1)
        return 1;
    return -1;
}
@

<<function acomcmp2>>=
int
acomcmp2(const void *a1, const void *a2)
{
    vlong c1, c2;
    Term *t1, *t2;

    t1 = (Term*)a1;
    t2 = (Term*)a2;
    c1 = t1->mult;
    c2 = t2->mult;
    if(c1 > c2)
        return 1;
    if(c1 < c2)
        return -1;
    if(t2 > t1)
        return 1;
    return -1;
}
@

<<function acom2>>=
void
acom2(Node *n, Type *t)
{
    Node *l, *r;
    Term trm[NTERM];
    int et, nt, i, j;
    vlong c1, c2;

    /*
     * copy into automatic
     */
    c2 = 0;
    nt = nterm;
    for(i=0; i<nt; i++)
        trm[i] = term[i];
    /*
     * recur on subtrees
     */
    j = 0;
    for(i=1; i<nt; i++) {
        c1 = trm[i].mult;
        if(c1 == 0)
            continue;
        l = trm[i].node;
        if(l != Z) {
            j = 1;
            acom(l);
        }
    }
    c1 = trm[0].mult;
    if(j == 0) {
        n->oldop = n->op;
        n->op = OCONST;
        n->vconst = c1;
        return;
    }
    et = t->etype;

    /*
     * prepare constant term,
     * combine it with an addressing term
     */
    if(c1 != 0) {
        l = new1(OCONST, Z, Z);
        l->type = t;
        l->vconst = c1;
        trm[0].mult = 1;
        for(i=1; i<nt; i++) {
            if(trm[i].mult != 1)
                continue;
            r = trm[i].node;
            if(r->op != OADDR)
                continue;
            r->type = t;
            l = new1(OADD, r, l);
            l->type = t;
            trm[i].mult = 0;
            break;
        }
        trm[0].node = l;
    }
    /*
     * look for factorable terms
     * c1*i + c1*c2*j -> c1*(i + c2*j)
     */
    qsort(trm+1, nt-1, sizeof(trm[0]), acomcmp1);
    for(i=nt-1; i>=0; i--) {
        c1 = trm[i].mult;
        if(c1 < 0)
            c1 = -c1;
        if(c1 <= 1)
            continue;
        for(j=i+1; j<nt; j++) {
            c2 = trm[j].mult;
            if(c2 < 0)
                c2 = -c2;
            if(c2 <= 1)
                continue;
            if(c2 % c1)
                continue;
            r = trm[j].node;
            if(r->type->etype != et)
                r = acast(t, r);
            c2 = trm[j].mult/trm[i].mult;
            if(c2 != 1 && c2 != -1) {
                r = new1(OMUL, r, new(OCONST, Z, Z));
                r->type = t;
                r->right->type = t;
                r->right->vconst = c2;
            }
            l = trm[i].node;
            if(l->type->etype != et)
                l = acast(t, l);
            r = new1(OADD, l, r);
            r->type = t;
            if(c2 == -1)
                r->op = OSUB;
            trm[i].node = r;
            trm[j].mult = 0;
        }
    }
    if(debug['m']) {
        print("\n");
        for(i=0; i<nt; i++) {
            print("%d %3lld ", i, trm[i].mult);
            prtree1(trm[i].node, 1, 0);
        }
    }

    /*
     * put it all back together
     */
    qsort(trm+1, nt-1, sizeof(trm[0]), acomcmp2);
    l = Z;
    for(i=nt-1; i>=0; i--) {
        c1 = trm[i].mult;
        if(c1 == 0)
            continue;
        r = trm[i].node;
        if(r->type->etype != et || r->op == OBIT)
            r = acast(t, r);
        if(c1 != 1 && c1 != -1) {
            r = new1(OMUL, r, new(OCONST, Z, Z));
            r->type = t;
            r->right->type = t;
            if(c1 < 0) {
                r->right->vconst = -c1;
                c1 = -1;
            } else {
                r->right->vconst = c1;
                c1 = 1;
            }
        }
        if(l == Z) {
            l = r;
            c2 = c1;
            continue;
        }
        if(c1 < 0)
            if(c2 < 0)
                l = new1(OADD, l, r);
            else
                l = new1(OSUB, l, r);
        else
            if(c2 < 0) {
                l = new1(OSUB, r, l);
                c2 = 1;
            } else
                l = new1(OADD, l, r);
        l->type = t;
    }
    if(c2 < 0) {
        r = new1(OCONST, 0, 0);
        r->vconst = 0;
        r->type = t;
        l = new1(OSUB, r, l);
        l->type = t;
    }
    *n = *l;
}
@


\chapter{Assembly-level Optimisations}

\section{Nop detection}

<<[[gmove()]] if samaddr return>>=
if(a == AMOVW || a == AMOVF || a == AMOVD)
 if(samaddr(f, t))
    return;
@
%When need that? if do
% foo(int x) { return x } then would generate a MOVW R0, R0
% which is useless.

<<function samaddr>>=
bool
samaddr(Node *f, Node *t)
{

    if(f->op != t->op)
        return false;
    switch(f->op) {
    case OREGISTER:
        return (f->reg == t->reg);
    }
    return false;
}
@


\section{ARM special instructions}

<<[[gopcode()]] when OSUB, ARSB opportunity>>=
if(f2 && f2->op == OCONST) {
    Node *t = f1;
    f1 = f2;
    f2 = t;
    a = ARSB;
}
@

\section{Register passing argument, [[REGARG]]}
% kind of assembly-level opti. seems generic and involves modifying the AST.

<<[[codgen()]] locals>>=
Node nod, nod1;
@

%REGARG from 5.out.h = 0 => so use R0 and the rest in the stack. 
%REGRET is also R0.


<<[[codgen()]] if use REGARG>>=
/*
 * isolate first argument
 */
if(REGARG >= 0) {	
    <<[[codegen()]] if use REGARG, if complex return type>>
    else
    if(firstarg && typeword[firstargtype->etype]) {
        nod1 = znode;
        nod1.op = ONAME;
        nod1.sym = firstarg;
        nod1.type = firstargtype;
        nod1.etype = firstargtype->etype;
        nod1.class = CPARAM;
        nod1.xoffset = align(0, firstargtype, Aarg1);
        xcom(&nod1);
        nodreg(&nod, &nod1, REGARG);
        gmove(&nod, &nod1);
    }
}
@
% xcom just to set addable and complex.

% save R0 into stack (x-4(FP)) before doing anything.


<<global typeword>>=
// set<type_kind>
char*	typeword;
@

<<[[tinit()]] initialise 32 bits defaults type sets>>=
/* 32-bit defaults */
typeword = typechlp;
@
% char, short, long, pointer =~ !typecmplx no?



<<[[cgenrel()]] OFUNC case, if use REGARG, part one>>=
if(REGARG >= 0)
    o = reg[REGARG];
@

<<[[cgenrel()]] OFUNC case, if use REGARG, part two>>=
if(REGARG >= 0)
    if(o != reg[REGARG])
        reg[REGARG]--;
@

<<[[garg1()]] if use REGARG and curarg is zero and simple type>>=
if(REGARG >= 0 && curarg == 0 && typechlp[n->type->etype]) {
    regaalloc1(tn1, n);
    if(n->complex >= FNX) {
        cgen(*fnxp, tn1);
        (*fnxp)++;
    } else
        cgen(n, tn1);
}
@
% should use typeword here.

<<function regaalloc1(arm)>>=
void
regaalloc1(Node *n, Node *nn)
{
    nodreg(n, nn, REGARG);
    reg[REGARG]++;
    curarg = align(curarg, nn->type, Aarg1);
    curarg = align(curarg, nn->type, Aarg2);
    maxargsafe = maxround(maxargsafe, cursafe+curarg);
}
@





\section{Register allocation optimisations}
% 5c -r? registerization

% big one

\subsection{[[regopt()]]}

<<[[codgen()]] register optimisation>>=
if(!debug['N'] || debug['R'] || debug['P'])
    regopt(sp);
@

% register optimization?
<<function regopt(arm)>>=
void
regopt(Prog *p)
{
    <<[[regopt()]] locals>>

    <<[[regopt()]] initialisation>>

    <<[[regopt()]] pass 1>>
    <<[[regopt()]] pass 2>>
    <<[[regopt()]] pass 2.5>>
    <<[[regopt()]] pass 3>>
    <<[[regopt()]] pass 4>>
    <<[[regopt()]] pass 5>>
    <<[[regopt()]] pass 6>>
    <<[[regopt()]] pass 7>>
    <<[[regopt()]] pass 8>>
    <<[[regopt()]] pass 9>>
}
@








<<global externs>>=
Bits	externs;
@
<<global params>>=
Bits	params;
@

<<global consts>>=
Bits	consts;
@

<<global addrs>>=
Bits	addrs;
@


<<global regbits>>=
long	regbits;
@

<<global exregbits>>=
long	exregbits;
@


<<global change>>=
int	change;
@


<<global firstr>>=
Reg*	firstr;
@

<<global lastr>>=
Reg*	lastr;
@

<<global zreg>>=
Reg	zreg;
@

<<global freer>>=
Reg*	freer;
@

<<[[regopt()]] locals>>=
Reg *r, *r1, *r2;
Prog *p1;
int i, z;
long initpc, val, npc;
ulong vreg;
Bits bit;
struct
{
    long	m;
    long	c;
    Reg*	p;
} log5[6], *lp;
@

<<[[regopt()]] initialisation>>=
firstr = R;
lastr = R;
nvar = 0;
regbits = 0;
for(z=0; z<BITS; z++) {
    externs.b[z] = 0;
    params.b[z] = 0;
    consts.b[z] = 0;
    addrs.b[z] = 0;
}
@


% gen -> <>


\subsection{[[noretval()]]}

<<[[codgen()]] before RET>>=
noretval(1 | 2);
@

% fake instr that looks like that use REGRET?
% for optimizer to have sentinel?

<<[[gen()]] case ORETURN with no argument, before RET>>=
noretval(1 | 2);
@

<<[[gen()]] case ORETURN with argument, before RET>>=
if(typefd[n->type->etype])
    noretval(1);
else
    noretval(2);
@
% if returned something, then used R0 already, so no need
% to add extra NOP ,R0

% NOP; NOP, with some arguments, weird.
% 5c/sgen.c?
<<function noretval(arm)>>=
void
noretval(int n)
{

    if(n & 1) {
        gins(ANOP, Z, Z);
        p->to.type = D_REG;
        p->to.reg = REGRET;
    }
    if(n & 2) {
        gins(ANOP, Z, Z);
        p->to.type = D_FREG;
        p->to.reg = FREGRET;
    }
}
@
%ANOP with to? what is it?

\subsection{Pass 1}

<<[[regopt()]] pass 1>>=
/*
 * pass 1
 * build aux data structure
 * allocate pcs
 * find use and set of variables
 */
val = 5L * 5L * 5L * 5L * 5L;
lp = log5;
for(i=0; i<5; i++) {
    lp->m = val;
    lp->c = 0;
    lp->p = R;
    val /= 5L;
    lp++;
}
val = 0;
for(; p != P; p = p->link) {
    switch(p->as) {
    case ADATA:
    case AGLOBL:
    case ANAME:
    case ASIGNAME:
        continue;
    }
    r = rega();
    if(firstr == R) {
        firstr = r;
        lastr = r;
    } else {
        lastr->link = r;
        r->p1 = lastr;
        lastr->s1 = r;
        lastr = r;
    }
    r->prog = p;
    r->pc = val;
    val++;

    lp = log5;
    for(i=0; i<5; i++) {
        lp->c--;
        if(lp->c <= 0) {
            lp->c = lp->m;
            if(lp->p != R)
                lp->p->log5 = r;
            lp->p = r;
            (lp+1)->c = 0;
            break;
        }
        lp++;
    }

    r1 = r->p1;
    if(r1 != R)
    switch(r1->prog->as) {
    case ARET:
    case AB:
    case ARFE:
        r->p1 = R;
        r1->s1 = R;
    }

    /*
     * left side always read
     */
    bit = mkvar(&p->from, p->as==AMOVW);
    for(z=0; z<BITS; z++)
        r->use1.b[z] |= bit.b[z];

    /*
     * right side depends on opcode
     */
    bit = mkvar(&p->to, 0);
    if(bany(&bit))
    switch(p->as) {
    default:
        diag(Z, "reg: unknown asop: %A", p->as);
        break;

    /*
     * right side write
     */
    case ANOP:
    case AMOVB:
    case AMOVBU:
    case AMOVH:
    case AMOVHU:
    case AMOVW:
    case AMOVF:
    case AMOVD:
        for(z=0; z<BITS; z++)
            r->set.b[z] |= bit.b[z];
        break;

    /*
     * funny
     */
    case ABL:
        for(z=0; z<BITS; z++)
            addrs.b[z] |= bit.b[z];
        break;
    }

    if(p->as == AMOVM) {
        if(p->from.type == D_CONST)
            z = p->from.offset;
        else
            z = p->to.offset;
        for(i=0; z; i++) {
            if(z&1)
                regbits |= RtoB(i);
            z >>= 1;
        }
    }
}
if(firstr == R)
    return;
initpc = pc - val;
npc = val;
@


\subsection{Pass 2}

<<[[regopt()]] pass 2>>=
/*
 * pass 2
 * turn branch references to pointers
 * build back pointers
 */
for(r = firstr; r != R; r = r->link) {
    p = r->prog;
    if(p->to.type == D_BRANCH) {
        val = p->to.offset - initpc;
        r1 = firstr;
        while(r1 != R) {
            r2 = r1->log5;
            if(r2 != R && val >= r2->pc) {
                r1 = r2;
                continue;
            }
            if(r1->pc == val)
                break;
            r1 = r1->link;
        }
        if(r1 == R) {
            nearln = p->lineno;
            diag(Z, "ref not found\n%P", p);
            continue;
        }
        if(r1 == r) {
            nearln = p->lineno;
            diag(Z, "ref to self\n%P", p);
            continue;
        }
        r->s2 = r1;
        r->p2link = r1->p2;
        r1->p2 = r;
    }
}
if(debug['R']) {
    p = firstr->prog;
    print("\n%L %D\n", p->lineno, &p->from);
}
@


<<[[regopt()]] pass 2.5>>=
/*
 * pass 2.5
 * find looping structure
 */
for(r = firstr; r != R; r = r->link)
    r->active = 0;
change = 0;
loopit(firstr, npc);
@


\subsection{Pass 3}

<<[[regopt()]] pass 3>>=
    /*
     * pass 3
     * iterate propagating usage
     * 	back until flow graph is complete
     */
loop1:
    change = 0;
    for(r = firstr; r != R; r = r->link)
        r->active = 0;
    for(r = firstr; r != R; r = r->link)
        if(r->prog->as == ARET)
            prop(r, zbits, zbits);
loop11:
    /* pick up unreachable code */
    i = 0;
    for(r = firstr; r != R; r = r1) {
        r1 = r->link;
        if(r1 && r1->active && !r->active) {
            prop(r, zbits, zbits);
            i = 1;
        }
    }
    if(i)
        goto loop11;
    if(change)
        goto loop1;
@


\subsection{Pass 4}

<<[[regopt()]] pass 4>>=
    /*
     * pass 4
     * iterate propagating register/variable synchrony
     * 	forward until graph is complete
     */
loop2:
    change = 0;
    for(r = firstr; r != R; r = r->link)
        r->active = 0;
    synch(firstr, zbits);
    if(change)
        goto loop2;

    addsplits();

    if(debug['R'] && debug['v']) {
        print("\nprop structure:\n");
        for(r = firstr; r != R; r = r->link) {
            print("%ld:%P", r->loop, r->prog);
            for(z=0; z<BITS; z++)
                bit.b[z] = r->set.b[z] |
                    r->refahead.b[z] | r->calahead.b[z] |
                    r->refbehind.b[z] | r->calbehind.b[z] |
                    r->use1.b[z] | r->use2.b[z];
            if(bany(&bit)) {
                print("\t");
                if(bany(&r->use1))
                    print(" u1=%B", r->use1);
                if(bany(&r->use2))
                    print(" u2=%B", r->use2);
                if(bany(&r->set))
                    print(" st=%B", r->set);
                if(bany(&r->refahead))
                    print(" ra=%B", r->refahead);
                if(bany(&r->calahead))
                    print(" ca=%B", r->calahead);
                if(bany(&r->refbehind))
                    print(" rb=%B", r->refbehind);
                if(bany(&r->calbehind))
                    print(" cb=%B", r->calbehind);
            }
            print("\n");
        }
    }
@

\subsection{pass 5}

<<[[regopt()]] pass 5>>=
    /*
     * pass 5
     * isolate regions
     * calculate costs (paint1)
     */
    r = firstr;
    if(r) {
        for(z=0; z<BITS; z++)
            bit.b[z] = (r->refahead.b[z] | r->calahead.b[z]) &
              ~(externs.b[z] | params.b[z] | addrs.b[z] | consts.b[z]);
        if(bany(&bit)) {
            nearln = r->prog->lineno;
            warn(Z, "used and not set: %B", bit);
            if(debug['R'] && !debug['w'])
                print("used and not set: %B\n", bit);
        }
    }

    for(r = firstr; r != R; r = r->link)
        r->act = zbits;
    rgp = region;
    nregion = 0;
    for(r = firstr; r != R; r = r->link) {
        for(z=0; z<BITS; z++)
            bit.b[z] = r->set.b[z] &
              ~(r->refahead.b[z] | r->calahead.b[z] | addrs.b[z]);
        if(bany(&bit)) {
            nearln = r->prog->lineno;
            warn(Z, "set and not used: %B", bit);
            if(debug['R'])
                print("set and not used: %B\n", bit);
            excise(r);
        }
        for(z=0; z<BITS; z++)
            bit.b[z] = LOAD(r) & ~(r->act.b[z] | addrs.b[z]);
        while(bany(&bit)) {
            i = bnum(bit);
            rgp->enter = r;
            rgp->varno = i;
            change = 0;
            if(debug['R'] && debug['v'])
                print("\n");
            paint1(r, i);
            bit.b[i/32] &= ~(1L<<(i%32));
            if(change <= 0) {
                if(debug['R'])
                    print("%L $%d: %B\n",
                        r->prog->lineno, change, blsh(i));
                continue;
            }
            rgp->cost = change;
            nregion++;
            if(nregion >= NRGN) {
                warn(Z, "too many regions");
                goto brk;
            }
            rgp++;
        }
    }
brk:
    qsort(region, nregion, sizeof(region[0]), rcmp);
@

\subsection{pass 6}

<<[[regopt()]] pass 6>>=
/*
 * pass 6
 * determine used registers (paint2)
 * replace code (paint3)
 */
rgp = region;
for(i=0; i<nregion; i++) {
    bit = blsh(rgp->varno);
    vreg = paint2(rgp->enter, rgp->varno);
    vreg = allreg(vreg, rgp);
    if(debug['R']) {
        if(rgp->regno >= NREG)
            print("%L $%d F%d: %B\n",
                rgp->enter->prog->lineno,
                rgp->cost,
                rgp->regno-NREG,
                bit);
        else
            print("%L $%d R%d: %B\n",
                rgp->enter->prog->lineno,
                rgp->cost,
                rgp->regno,
                bit);
    }
    if(rgp->regno != 0)
        paint3(rgp->enter, rgp->varno, vreg, rgp->regno);
    rgp++;
}
@

\subsection{pass 7, peep hole optimizations}

<<[[regopt()]] pass 7>>=
/*
 * pass 7
 * peep-hole on basic block
 */
if(!debug['R'] || debug['P'])
    peep();
@

\subsection{pass 8}

<<[[regopt()]] pass 8>>=
/*
 * pass 8
 * recalculate pc
 */
val = initpc;
for(r = firstr; r != R; r = r1) {
    r->pc = val;
    p = r->prog;
    p1 = P;
    r1 = r->link;
    if(r1 != R)
        p1 = r1->prog;
    for(; p != p1; p = p->link) {
        switch(p->as) {
        default:
            val++;
            break;

        case ANOP:
        case ADATA:
        case AGLOBL:
        case ANAME:
        case ASIGNAME:
            break;
        }
    }
}
pc = val;

/*
 * fix up branches
 */
if(debug['R'])
    if(bany(&addrs))
        print("addrs: %B\n", addrs);

r1 = 0; /* set */
for(r = firstr; r != R; r = r->link) {
    p = r->prog;
    if(p->to.type == D_BRANCH)
        p->to.offset = r->s2->pc;
    r1 = r;
}
@

\subsection{pass 9}

<<[[regopt()]] pass 9>>=
/*
 * last pass
 * eliminate nops
 * free aux structures
 */
for(p = firstr->prog; p != P; p = p->link){
    while(p->link && p->link->as == ANOP)
        p->link = p->link->link;
}
if(r1 != R) {
    r1->link = freer;
    freer = firstr;
}
@





\subsection{[[Bits]]}

<<constant BITS>>=
#define	BITS	5
@


<<struct Bits>>=
struct	Bits
{
    ulong	b[BITS];
};
@

<<global zbits>>=
Bits	zbits;
@


<<function bor>>=
Bits
bor(Bits a, Bits b)
{
    Bits c;
    int i;

    for(i=0; i<BITS; i++)
        c.b[i] = a.b[i] | b.b[i];
    return c;
}
@

<<function bany>>=
/*
Bits
bnot(Bits a)
{
    Bits c;
    int i;

    for(i=0; i<BITS; i++)
        c.b[i] = ~a.b[i];
    return c;
}
*/

int
bany(Bits *a)
{
    int i;

    for(i=0; i<BITS; i++)
        if(a->b[i])
            return 1;
    return 0;
}
@

<<function beq>>=
int
beq(Bits a, Bits b)
{
    int i;

    for(i=0; i<BITS; i++)
        if(a.b[i] != b.b[i])
            return 0;
    return 1;
}
@

<<function bnum>>=
int
bnum(Bits a)
{
    int i;
    long b;

    for(i=0; i<BITS; i++)
        if(b = a.b[i])
            return 32*i + bitno(b);
    diag(Z, "bad in bnum");
    return 0;
}
@

<<function blsh>>=
Bits
blsh(uint n)
{
    Bits c;

    c = zbits;
    c.b[n/32] = 1L << (n%32);
    return c;
}
@
% >>

<<function bset>>=
//@Scheck: also defined as a macro in gc.h, TODO fix that!
int bset(Bits a, uint n)
{
    if(a.b[n/32] & (1L << (n%32)))
        return 1;
    return 0;
}
@
%>>

<<function bset(arm)>>=
#define	bset(a,n)	((a).b[(n)/32]&(1L<<(n)%32))
@
% >> 

%<<function band>>=
%//Bits
%//band(Bits a, Bits b)
%//{
%//    Bits c;
%//    int i;
%//
%//    for(i=0; i<BITS; i++)
%//        c.b[i] = a.b[i] & b.b[i];
%//    return c;
%//}
%@

\subsection{[[Var]]}

<<constant NVAR>>=
#define	NVAR	(BITS*sizeof(ulong)*8)
@
%5 * 4 * 8

<<global nvar>>=
int	nvar;
@

<<global var>>=
Var	var[NVAR];
@


<<struct Var>>=
struct	Var
{
    Sym*	sym;
    //enum<sym_kind>
    char	symkind;
    //enum<type_kind>
    char	etype;
    long	offset;
};
@
% yet another etype

\subsection{[[Reg]]}

% for region?

<<struct Reg>>=
struct	Reg
{
    long	pc;
    long	rpo;		/* reverse post ordering */

    Bits	set;
    Bits	use1;
    Bits	use2;

    Bits	refbehind;
    Bits	refahead;
    Bits	calbehind;
    Bits	calahead;
    Bits	regdiff;
    Bits	act;

    long	regu;
    long	loop;		/* could be shorter */

    
    Reg*	log5;
    long	active;

    Reg*	p1;
    Reg*	p2;
    Reg*	p2link;
    Reg*	s1;
    Reg*	s2;
    Reg*	link;

    Prog*	prog;
};
@


<<constant R>>=
#define	R	((Reg*)nil)
@


\subsection{[[XXX]]}

<<function rega>>=
Reg*
rega(void)
{
    Reg *r;

    r = freer;
    if(r == R) {
        r = alloc(sizeof(*r));
    } else
        freer = r->link;

    *r = zreg;
    return r;
}
@

<<function rcmp>>=
int
rcmp(const void *a1, const void *a2)
{
    Rgn *p1, *p2;
    int c1, c2;

    p1 = (Rgn*)a1;
    p2 = (Rgn*)a2;
    c1 = p2->cost;
    c2 = p1->cost;
    if(c1 -= c2)
        return c1;
    return p2->varno - p1->varno;
}
@


<<function LOAD(arm)>>=
#define	LOAD(r)		(~r->refbehind.b[z] & r->refahead.b[z])
@

<<function STORE(arm)>>=
#define	STORE(r)	(~r->calbehind.b[z] & r->calahead.b[z])
@




<<constant NRGN(arm)>>=
#define	NRGN	1000		/* was 600; raised for paranoia.c */
@

<<global region>>=
Rgn	region[NRGN];
@

<<global rgp>>=
Rgn*	rgp;
@

<<struct Rgn>>=
struct	Rgn
{
    Reg*	enter;
    short	cost;
    short	varno;
    short	regno;
};
@

<<global nregion>>=
int	nregion;
@




<<function addsplits(arm)>>=
void
addsplits(void)
{
    Reg *r, *r1;
    int z, i;
    Bits bit;

    for(r = firstr; r != R; r = r->link) {
        if(r->loop > 1)
            continue;
        if(r->prog->as == ABL)
            continue;
        for(r1 = r->p2; r1 != R; r1 = r1->p2link) {
            if(r1->loop <= 1)
                continue;
            for(z=0; z<BITS; z++)
                bit.b[z] = r1->calbehind.b[z] &
                    (r->refahead.b[z] | r->use1.b[z] | r->use2.b[z]) &
                    ~(r->calahead.b[z] & addrs.b[z]);
            while(bany(&bit)) {
                i = bnum(bit);
                bit.b[i/32] &= ~(1L << (i%32));
            }
        }
    }
}
@

<<function addmove(arm)>>=
/*
 * add mov b,rn
 * just after r
 */
void
addmove(Reg *r, int bn, int rn, int f)
{
    Prog *p, *p1;
    Adr *a;
    Var *v;

    p1 = alloc(sizeof(Prog));
    *p1 = zprog;
    p = r->prog;

    p1->link = p->link;
    p->link = p1;
    p1->lineno = p->lineno;

    v = var + bn;

    a = &p1->to;
    a->sym = v->sym;
    a->symkind = v->symkind;
    a->offset = v->offset;
    a->etype = v->etype;
    a->type = D_OREG;
    if(v->etype == TARRAY || a->sym == S)
        a->type = D_CONST;

    p1->as = AMOVW;
    if(v->etype == TCHAR || v->etype == TUCHAR)
        p1->as = AMOVB;
    if(v->etype == TSHORT || v->etype == TUSHORT)
        p1->as = AMOVH;
    if(v->etype == TFLOAT)
        p1->as = AMOVF;
    if(v->etype == TDOUBLE)
        p1->as = AMOVD;

    p1->from.type = D_REG;
    p1->from.reg = rn;
    if(rn >= NREG) {
        p1->from.type = D_FREG;
        p1->from.reg = rn-NREG;
    }
    if(!f) {
        p1->from = *a;
        *a = zprog.from;
        a->type = D_REG;
        a->reg = rn;
        if(rn >= NREG) {
            a->type = D_FREG;
            a->reg = rn-NREG;
        }
        if(v->etype == TUCHAR)
            p1->as = AMOVBU;
        if(v->etype == TUSHORT)
            p1->as = AMOVHU;
    }
    if(debug['R'])
        print("%P\t.a%P\n", p, p1);
}
@




<<function mkvar(arm)>>=
Bits
mkvar(Adr *a, int docon)
{
    Var *v;
    int i, n, z;
    long o;
    Bits bit;
    Sym *s;
    //enum<operand_kind>
    int t;
    //enum<type_kind>
    int et;

    t = a->type;
    if(t == D_REG && a->reg != R_NONE)
        regbits |= RtoB(a->reg);
    if(t == D_FREG && a->reg != R_NONE)
        regbits |= FtoB(a->reg);
    s = a->sym;
    o = a->offset;
    et = a->etype;
    if(s == S) {
        if(t != D_CONST || !docon || a->reg != R_NONE)
            goto none;
        et = TLONG;
    }
    if(t == D_CONST) {
        if(s == S && sval(o))
            goto none;
    }

    n = a->symkind;
    v = var;
    for(i=0; i<nvar; i++) {
        if(s == v->sym)
        if(n == v->symkind)
        if(o == v->offset)
            goto out;
        v++;
    }
    if(s)
        if(s->name[0] == '.')
            goto none;
    if(nvar >= NVAR) {
        if(debug['w'] > 1 && s)
            warn(Z, "variable not optimized: %s", s->name);
        goto none;
    }
    i = nvar;
    nvar++;
    v = &var[i];
    v->sym = s;
    v->offset = o;
    v->etype = et;
    v->symkind = n;
    if(debug['R'])
        print("bit=%2d et=%2d %D\n", i, et, a);
out:
    bit = blsh(i);
    if(n == N_EXTERN || n == N_INTERN)
        for(z=0; z<BITS; z++)
            externs.b[z] |= bit.b[z];
    if(n == N_PARAM)
        for(z=0; z<BITS; z++)
            params.b[z] |= bit.b[z];
    if(v->etype != et || !typechlpfd[et])	/* funny punning */
        for(z=0; z<BITS; z++)
            addrs.b[z] |= bit.b[z];
    if(t == D_CONST) {
        if(s == S) {
            for(z=0; z<BITS; z++)
                consts.b[z] |= bit.b[z];
            return bit;
        }
        if(et != TARRAY)
            for(z=0; z<BITS; z++)
                addrs.b[z] |= bit.b[z];
        for(z=0; z<BITS; z++)
            params.b[z] |= bit.b[z];
        return bit;
    }
    if(t == D_OREG)
        return bit;

none:
    return zbits;
}
@



<<global typechlpfd>>=
char	typechlpfd[NTYPE];
@

<<global typechlpfdinit>>=
int	typechlpfdinit[] =
{
    TCHAR, TUCHAR, TSHORT, TUSHORT, TINT, TUINT, TLONG, TULONG, TFLOAT, TDOUBLE, TIND, -1,
};
@
\l used for??

<<function sval(arm)>>=
int
sval(long v)
{
    int i;

    for(i=0; i<16; i++) {
        if((v & ~0xff) == 0)
            return 1;
        if((~v & ~0xff) == 0)
            return 1;
        v = (v<<2) | ((ulong)v>>30);
    }
    return 0;
}
@



<<function prop(arm)>>=
void
prop(Reg *r, Bits ref, Bits cal)
{
    Reg *r1, *r2;
    int z;

    for(r1 = r; r1 != R; r1 = r1->p1) {
        for(z=0; z<BITS; z++) {
            ref.b[z] |= r1->refahead.b[z];
            if(ref.b[z] != r1->refahead.b[z]) {
                r1->refahead.b[z] = ref.b[z];
                change++;
            }
            cal.b[z] |= r1->calahead.b[z];
            if(cal.b[z] != r1->calahead.b[z]) {
                r1->calahead.b[z] = cal.b[z];
                change++;
            }
        }
        switch(r1->prog->as) {
        case ABL:
            for(z=0; z<BITS; z++) {
                cal.b[z] |= ref.b[z] | externs.b[z];
                ref.b[z] = 0;
            }
            break;

        case ATEXT:
            for(z=0; z<BITS; z++) {
                cal.b[z] = 0;
                ref.b[z] = 0;
            }
            break;

        case ARET:
            for(z=0; z<BITS; z++) {
                cal.b[z] = externs.b[z];
                ref.b[z] = 0;
            }
        }
        for(z=0; z<BITS; z++) {
            ref.b[z] = (ref.b[z] & ~r1->set.b[z]) |
                r1->use1.b[z] | r1->use2.b[z];
            cal.b[z] &= ~(r1->set.b[z] | r1->use1.b[z] | r1->use2.b[z]);
            r1->refbehind.b[z] = ref.b[z];
            r1->calbehind.b[z] = cal.b[z];
        }
        if(r1->active)
            break;
        r1->active = 1;
    }
    for(; r != r1; r = r->p1)
        for(r2 = r->p2; r2 != R; r2 = r2->p2link)
            prop(r2, r->refbehind, r->calbehind);
}
@
% 386 only diff is ABL -> ACALL

<<function rpolca>>=
long
rpolca(long *idom, long rpo1, long rpo2)
{
    long t;

    if(rpo1 == -1)
        return rpo2;
    while(rpo1 != rpo2){
        if(rpo1 > rpo2){
            t = rpo2;
            rpo2 = rpo1;
            rpo1 = t;
        }
        while(rpo1 < rpo2){
            t = idom[rpo2];
            if(t >= rpo2)
                fatal(Z, "bad idom");
            rpo2 = t;
        }
    }
    return rpo1;
}
@

<<function doms>>=
int
doms(long *idom, long r, long s)
{
    while(s > r)
        s = idom[s];
    return s == r;
}
@

<<function loophead>>=
int
loophead(long *idom, Reg *r)
{
    long src;

    src = r->rpo;
    if(r->p1 != R && doms(idom, src, r->p1->rpo))
        return 1;
    for(r = r->p2; r != R; r = r->p2link)
        if(doms(idom, src, r->rpo))
            return 1;
    return 0;
}
@

<<constant LOOP(arm)>>=
#define	LOOP	3
@


<<function loopmark>>=
void
loopmark(Reg **rpo2r, long head, Reg *r)
{
    if(r->rpo < head || r->active == head)
        return;
    r->active = head;
    r->loop += LOOP;
    if(r->p1 != R)
        loopmark(rpo2r, head, r->p1);
    for(r = r->p2; r != R; r = r->p2link)
        loopmark(rpo2r, head, r);
}
@


<<global idom>>=
long*	idom;
@

<<global rpo2r>>=
Reg**	rpo2r;
@

<<global maxnr>>=
long	maxnr;
@


<<function loopit>>=
void
loopit(Reg *r, long nr)
{
    Reg *r1;
    long i, d, me;

    if(nr > maxnr) {
        rpo2r = alloc(nr * sizeof(Reg*));
        idom = alloc(nr * sizeof(long));
        maxnr = nr;
    }

    d = postorder(r, rpo2r, 0);
    if(d > nr)
        fatal(Z, "too many reg nodes");
    nr = d;
    for(i = 0; i < nr / 2; i++){
        r1 = rpo2r[i];
        rpo2r[i] = rpo2r[nr - 1 - i];
        rpo2r[nr - 1 - i] = r1;
    }
    for(i = 0; i < nr; i++)
        rpo2r[i]->rpo = i;

    idom[0] = 0;
    for(i = 0; i < nr; i++){
        r1 = rpo2r[i];
        me = r1->rpo;
        d = -1;
        if(r1->p1 != R && r1->p1->rpo < me)
            d = r1->p1->rpo;
        for(r1 = r1->p2; r1 != nil; r1 = r1->p2link)
            if(r1->rpo < me)
                d = rpolca(idom, d, r1->rpo);
        idom[i] = d;
    }

    for(i = 0; i < nr; i++){
        r1 = rpo2r[i];
        r1->loop++;
        if(r1->p2 != R && loophead(idom, r1))
            loopmark(rpo2r, i, r1);
    }
}
@

<<function synch>>=
void
synch(Reg *r, Bits dif)
{
    Reg *r1;
    int z;

    for(r1 = r; r1 != R; r1 = r1->s1) {
        for(z=0; z<BITS; z++) {
            dif.b[z] = (dif.b[z] &
                ~(~r1->refbehind.b[z] & r1->refahead.b[z])) |
                    r1->set.b[z] | r1->regdiff.b[z];
            if(dif.b[z] != r1->regdiff.b[z]) {
                r1->regdiff.b[z] = dif.b[z];
                change++;
            }
        }
        if(r1->active)
            break;
        r1->active = 1;
        for(z=0; z<BITS; z++)
            dif.b[z] &= ~(~r1->calbehind.b[z] & r1->calahead.b[z]);
        if(r1->s2 != R)
            synch(r1->s2, dif);
    }
}
@

<<function allreg(arm)>>=
ulong
allreg(ulong b, Rgn *r)
{
    Var *v;
    int i;

    v = var + r->varno;
    r->regno = 0;
    switch(v->etype) {

    case TCHAR:
    case TUCHAR:
    case TSHORT:
    case TUSHORT:
    case TINT:
    case TUINT:
    case TLONG:
    case TULONG:
    case TIND:
    case TARRAY:
        i = BtoR(~b);
        if(i && r->cost >= 0) {
            r->regno = i;
            return RtoB(i);
        }
        break;

    case TVLONG:
    case TDOUBLE:
    case TFLOAT:
        i = BtoF(~b);
        if(i && r->cost >= 0) {
            r->regno = i+NREG;
            return FtoB(i);
        }
        break;

    default:
        diag(Z, "unknown etype %d/%d", bitno(b), v->etype);
        break;

    }
    return 0;
}
@
% some tiny difference with 386

<<constant CLOAD(arm)>>=
#define	CLOAD	4
@

<<constant CREF(arm)>>=
#define	CREF	5
@


<<function paint1(arm)>>=
void
paint1(Reg *r, int bn)
{
    Reg *r1;
    Prog *p;
    int z;
    ulong bb;

    z = bn/32;
    bb = 1L<<(bn%32);
    if(r->act.b[z] & bb)
        return;
    for(;;) {
        if(!(r->refbehind.b[z] & bb))
            break;
        r1 = r->p1;
        if(r1 == R)
            break;
        if(!(r1->refahead.b[z] & bb))
            break;
        if(r1->act.b[z] & bb)
            break;
        r = r1;
    }

    if(LOAD(r) & ~(r->set.b[z] & ~(r->use1.b[z]|r->use2.b[z])) & bb) {
        change -= CLOAD * r->loop;
        if(debug['R'] && debug['v'])
            print("%ld%P\tld %B $%d\n", r->loop,
                r->prog, blsh(bn), change);
    }
    for(;;) {
        r->act.b[z] |= bb;
        p = r->prog;

        if(r->use1.b[z] & bb) {
            change += CREF * r->loop;
            if(debug['R'] && debug['v'])
                print("%ld%P\tu1 %B $%d\n", r->loop,
                    p, blsh(bn), change);
        }

        if((r->use2.b[z]|r->set.b[z]) & bb) {
            change += CREF * r->loop;
            if(debug['R'] && debug['v'])
                print("%ld%P\tu2 %B $%d\n", r->loop,
                    p, blsh(bn), change);
        }

        if(STORE(r) & r->regdiff.b[z] & bb) {
            change -= CLOAD * r->loop;
            if(debug['R'] && debug['v'])
                print("%ld%P\tst %B $%d\n", r->loop,
                    p, blsh(bn), change);
        }

        if(r->refbehind.b[z] & bb)
            for(r1 = r->p2; r1 != R; r1 = r1->p2link)
                if(r1->refahead.b[z] & bb)
                    paint1(r1, bn);

        if(!(r->refahead.b[z] & bb))
            break;
        r1 = r->s2;
        if(r1 != R)
            if(r1->refbehind.b[z] & bb)
                paint1(r1, bn);
        r = r->s1;
        if(r == R)
            break;
        if(r->act.b[z] & bb)
            break;
        if(!(r->refbehind.b[z] & bb))
            break;
    }
}
@
% 386 has a little bit more code with special case on AFMOVL

<<function paint2(arm)>>=
ulong
paint2(Reg *r, int bn)
{
    Reg *r1;
    int z;
    ulong bb, vreg;

    z = bn/32;
    bb = 1L << (bn%32);
    vreg = regbits;
    if(!(r->act.b[z] & bb))
        return vreg;
    for(;;) {
        if(!(r->refbehind.b[z] & bb))
            break;
        r1 = r->p1;
        if(r1 == R)
            break;
        if(!(r1->refahead.b[z] & bb))
            break;
        if(!(r1->act.b[z] & bb))
            break;
        r = r1;
    }
    for(;;) {
        r->act.b[z] &= ~bb;

        vreg |= r->regu;

        if(r->refbehind.b[z] & bb)
            for(r1 = r->p2; r1 != R; r1 = r1->p2link)
                if(r1->refahead.b[z] & bb)
                    vreg |= paint2(r1, bn);

        if(!(r->refahead.b[z] & bb))
            break;
        r1 = r->s2;
        if(r1 != R)
            if(r1->refbehind.b[z] & bb)
                vreg |= paint2(r1, bn);
        r = r->s1;
        if(r == R)
            break;
        if(!(r->act.b[z] & bb))
            break;
        if(!(r->refbehind.b[z] & bb))
            break;
    }
    return vreg;
}
@
% 386 has a bit of code before the return vreg
% >>


<<function paint3>>=
void
paint3(Reg *r, int bn, long rb, int rn)
{
    Reg *r1;
    Prog *p;
    int z;
    ulong bb;

    z = bn/32;
    bb = 1L << (bn%32);
    if(r->act.b[z] & bb)
        return;
    for(;;) {
        if(!(r->refbehind.b[z] & bb))
            break;
        r1 = r->p1;
        if(r1 == R)
            break;
        if(!(r1->refahead.b[z] & bb))
            break;
        if(r1->act.b[z] & bb)
            break;
        r = r1;
    }

    if(LOAD(r) & ~(r->set.b[z] & ~(r->use1.b[z]|r->use2.b[z])) & bb)
        addmove(r, bn, rn, 0);
    for(;;) {
        r->act.b[z] |= bb;
        p = r->prog;

        if(r->use1.b[z] & bb) {
            if(debug['R'])
                print("%P", p);
            addreg(&p->from, rn);
            if(debug['R'])
                print("\t.c%P\n", p);
        }
        if((r->use2.b[z]|r->set.b[z]) & bb) {
            if(debug['R'])
                print("%P", p);
            addreg(&p->to, rn);
            if(debug['R'])
                print("\t.c%P\n", p);
        }

        if(STORE(r) & r->regdiff.b[z] & bb)
            addmove(r, bn, rn, 1);
        r->regu |= rb;

        if(r->refbehind.b[z] & bb)
            for(r1 = r->p2; r1 != R; r1 = r1->p2link)
                if(r1->refahead.b[z] & bb)
                    paint3(r1, bn, rb, rn);

        if(!(r->refahead.b[z] & bb))
            break;
        r1 = r->s2;
        if(r1 != R)
            if(r1->refbehind.b[z] & bb)
                paint3(r1, bn, rb, rn);
        r = r->s1;
        if(r == R)
            break;
        if(r->act.b[z] & bb)
            break;
        if(!(r->refbehind.b[z] & bb))
            break;
    }
}
@
% >>

<<function addreg(arm)>>=
void
addreg(Adr *a, int rn)
{

    a->sym = 0;
    a->symkind = N_NONE;
    a->type = D_REG;
    a->reg = rn;
    if(rn >= NREG) {
        a->type = D_FREG;
        a->reg = rn-NREG;
    }
}
@

<<function RtoB(arm)>>=
/*
 *	bit	reg
 *	0	R0
 *	1	R1
 *	...	...
 *	10	R10
 */
long
RtoB(int r)
{

    if(r >= REGMIN && r <= REGMAX)
        return 1L << r;
    return 0;
}
@
% >> >>

<<function BtoR(arm)>>=
int
BtoR(long b)
{
    b &= 0x01fcL;	// excluded R9 and R10 for m and g
    if(b == 0)
        return 0;
    return bitno(b);
}
@

<<function FtoB(arm)>>=
/*
 *	bit	reg
 *	18	F2
 *	19	F3
 *	...	...
 *	23	F7
 */
long
FtoB(int f)
{

    if(f < 2 || f > NFREG-1)
        return 0;
    return 1L << (f + 16);
}
@
% >> >>

<<function BtoF(arm)>>=
int
BtoF(long b)
{

    b &= 0xfc0000L;
    if(b == 0)
        return 0;
    return bitno(b) - 16;
}
@



\section{Peephole optimizer, [[peep()]]}

% local opti, looking at the code like in a peep hole

% codgen -> regopt -> <>
<<function peep(arm)>>=
void
peep(void)
{
    Reg *r, *r1, *r2;
    Prog *p, *p1;
    int t;
/*
 * complete R structure
 */
    t = 0;
    for(r=firstr; r!=R; r=r1) {
        r1 = r->link;
        if(r1 == R)
            break;
        p = r->prog->link;
        while(p != r1->prog)
        switch(p->as) {
        default:
            r2 = rega();
            r->link = r2;
            r2->link = r1;

            r2->prog = p;
            r2->p1 = r;
            r->s1 = r2;
            r2->s1 = r1;
            r1->p1 = r2;

            r = r2;
            t++;

        case ADATA:
        case AGLOBL:
        case ANAME:
        case ASIGNAME:
            p = p->link;
        }
    }

loop1:
    t = 0;
    for(r=firstr; r!=R; r=r->link) {
        p = r->prog;
        if(p->as == ASLL || p->as == ASRL || p->as == ASRA) {
            /*
             * elide shift into D_SHIFT operand of subsequent instruction
             */
            if(shiftprop(r)) {
                excise(r);
                t++;
            }
        }
        if(p->as == AMOVW || p->as == AMOVF || p->as == AMOVD)
        if(regtyp(&p->to)) {
            if(p->from.type == D_CONST)
                constprop(&p->from, &p->to, r->s1);
            else if(regtyp(&p->from))
            if(p->from.type == p->to.type) {
                if(copyprop(r)) {
                    excise(r);
                    t++;
                } else
                if(subprop(r) && copyprop(r)) {
                    excise(r);
                    t++;
                }
            }
        }
    }
    if(t)
        goto loop1;
    /*
     * look for MOVB x,R; MOVB R,R
     */
    for(r=firstr; r!=R; r=r->link) {
        p = r->prog;
        switch(p->as) {
        default:
            continue;
        case AEOR:
            /*
             * EOR -1,x,y => MVN x,y
             */
            if(p->from.type == D_CONST && p->from.offset == -1) {
                p->as = AMVN;
                p->from.type = D_REG;
                if(p->reg != R_NONE)
                    p->from.reg = p->reg;
                else
                    p->from.reg = p->to.reg;
                p->reg = R_NONE;
            }
            continue;
        case AMOVH:
        case AMOVHU:
        case AMOVB:
        case AMOVBU:
            if(p->to.type != D_REG)
                continue;
            break;
        }
        r1 = r->link;
        if(r1 == R)
            continue;
        p1 = r1->prog;
        if(p1->as != p->as)
            continue;
        if(p1->from.type != D_REG || p1->from.reg != p->to.reg)
            continue;
        if(p1->to.type != D_REG || p1->to.reg != p->to.reg)
            continue;
        excise(r1);
    }

    for(r=firstr; r!=R; r=r->link) {
        p = r->prog;
        switch(p->as) {
        case AMOVW:
        case AMOVB:
        case AMOVBU:
            if(p->from.type == D_OREG && p->from.offset == 0)
                xtramodes(r, &p->from);
            else if(p->to.type == D_OREG && p->to.offset == 0)
                xtramodes(r, &p->to);
            else
                continue;
            break;
        case ACMP:
            /*
             * elide CMP $0,x if calculation of x can set condition codes
             */
            if(p->from.type != D_CONST || p->from.offset != 0)
                continue;
            r2 = r->s1;
            if(r2 == R)
                continue;
            t = r2->prog->as;
            switch(t) {
            default:
                continue;
            case ABEQ:
            case ABNE:
            case ABMI:
            case ABPL:
                break;
            case ABGE:
                t = ABPL;
                break;
            case ABLT:
                t = ABMI;
                break;
            case ABHI:
                t = ABNE;
                break;
            case ABLS:
                t = ABEQ;
                break;
            }
            r1 = r;
            do
                r1 = uniqp(r1);
            while (r1 != R && r1->prog->as == ANOP);
            if(r1 == R)
                continue;
            p1 = r1->prog;
            if(p1->to.type != D_REG)
                continue;
            if(p1->to.reg != p->reg)
            if(!(p1->as == AMOVW && p1->from.type == D_REG && p1->from.reg == p->reg))
                continue;
            switch(p1->as) {
            default:
                continue;
            case AMOVW:
                if(p1->from.type != D_REG)
                    continue;
            case AAND:
            case AEOR:
            case AORR:
            case ABIC:
            case AMVN:
            case ASUB:
            case ARSB:
            case AADD:
            case AADC:
            case ASBC:
            case ARSC:
                break;
            }
            p1->scond |= C_SBIT;
            r2->prog->as = t;
            excise(r);
            continue;
        }
    }

    predicate();
}
@
%$


<<function excise(arm)>>=
void
excise(Reg *r)
{
    Prog *p;

    p = r->prog;
    p->as = ANOP;
    p->scond = zprog.scond;
    p->from = zprog.from;
    p->to = zprog.to;
    p->reg = zprog.reg; /**/
}
@

<<function uniqp>>=
Reg*
uniqp(Reg *r)
{
    Reg *r1;

    r1 = r->p1;
    if(r1 == R) {
        r1 = r->p2;
        if(r1 == R || r1->p2link != R)
            return R;
    } else
        if(r->p2 != R)
            return R;
    return r1;
}
@

<<function uniqs>>=
Reg*
uniqs(Reg *r)
{
    Reg *r1;

    r1 = r->s1;
    if(r1 == R) {
        r1 = r->s2;
        if(r1 == R)
            return R;
    } else
        if(r->s2 != R)
            return R;
    return r1;
}
@

<<function regtyp(arm)>>=
int
regtyp(Adr *a)
{

    if(a->type == D_REG)
        return 1;
    if(a->type == D_FREG)
        return 1;
    return 0;
}
@

<<function subprop(arm)>>=
/*
 * the idea is to substitute
 * one register for another
 * from one MOV to another
 *	MOV	a, R0
 *	ADD	b, R0	/ no use of R1
 *	MOV	R0, R1
 * would be converted to
 *	MOV	a, R1
 *	ADD	b, R1
 *	MOV	R1, R0
 * hopefully, then the former or latter MOV
 * will be eliminated by copy propagation.
 */
int
subprop(Reg *r0)
{
    Prog *p;
    Adr *v1, *v2;
    Reg *r;
    int t;

    p = r0->prog;
    v1 = &p->from;
    if(!regtyp(v1))
        return 0;
    v2 = &p->to;
    if(!regtyp(v2))
        return 0;
    for(r=uniqp(r0); r!=R; r=uniqp(r)) {
        if(uniqs(r) == R)
            break;
        p = r->prog;
        switch(p->as) {
        case ABL:
            return 0;

        case ACMP:
        case ACMN:
        case AADD:
        case ASUB:
        case ARSB:
        case ASLL:
        case ASRL:
        case ASRA:
        case AORR:
        case AAND:
        case AEOR:
        case AMUL:
        case ADIV:
        case ADIVU:

        case ACMPF:
        case ACMPD:
        case AADDD:
        case AADDF:
        case ASUBD:
        case ASUBF:
        case AMULD:
        case AMULF:
        case ADIVD:
        case ADIVF:
            if(p->to.type == v1->type)
            if(p->to.reg == v1->reg) {
                if(p->reg == R_NONE)
                    p->reg = p->to.reg;
                goto gotit;
            }
            break;

        case AMOVF:
        case AMOVD:
        case AMOVW:
            if(p->to.type == v1->type)
            if(p->to.reg == v1->reg)
                goto gotit;
            break;

        case AMOVM:
            t = 1<<v2->reg;
            if((p->from.type == D_CONST && (p->from.offset&t)) ||
               (p->to.type == D_CONST && (p->to.offset&t)))
                return 0;
            break;
        }
        if(copyau(&p->from, v2) ||
           copyau1(p, v2) ||
           copyau(&p->to, v2))
            break;
        if(copysub(&p->from, v1, v2, 0) ||
           copysub1(p, v1, v2, 0) ||
           copysub(&p->to, v1, v2, 0))
            break;
    }
    return 0;

gotit:
    copysub(&p->to, v1, v2, 1);
    if(debug['P']) {
        print("gotit: %D->%D\n%P", v1, v2, r->prog);
        if(p->from.type == v2->type)
            print(" excise");
        print("\n");
    }
    for(r=uniqs(r); r!=r0; r=uniqs(r)) {
        p = r->prog;
        copysub(&p->from, v1, v2, 1);
        copysub1(p, v1, v2, 1);
        copysub(&p->to, v1, v2, 1);
        if(debug['P'])
            print("%P\n", r->prog);
    }
    t = v1->reg;
    v1->reg = v2->reg;
    v2->reg = t;
    if(debug['P'])
        print("%P last\n", r->prog);
    return 1;
}
@

<<function copyprop>>=
/*
 * The idea is to remove redundant copies.
 *	v1->v2	F=0
 *	(use v2	s/v2/v1/)*
 *	set v1	F=1
 *	use v2	return fail
 *	-----------------
 *	v1->v2	F=0
 *	(use v2	s/v2/v1/)*
 *	set v1	F=1
 *	set v2	return success
 */
int
copyprop(Reg *r0)
{
    Prog *p;
    Adr *v1, *v2;
    Reg *r;

    p = r0->prog;
    v1 = &p->from;
    v2 = &p->to;
    if(copyas(v1, v2))
        return 1;
    for(r=firstr; r!=R; r=r->link)
        r->active = 0;
    return copy1(v1, v2, r0->s1, 0);
}
@

<<function copy1>>=
int
copy1(Adr *v1, Adr *v2, Reg *r, int f)
{
    int t;
    Prog *p;

    if(r->active) {
        if(debug['P'])
            print("act set; return 1\n");
        return 1;
    }
    r->active = 1;
    if(debug['P'])
        print("copy %D->%D f=%d\n", v1, v2, f);
    for(; r != R; r = r->s1) {
        p = r->prog;
        if(debug['P'])
            print("%P", p);
        if(!f && uniqp(r) == R) {
            f = 1;
            if(debug['P'])
                print("; merge; f=%d", f);
        }
        t = copyu(p, v2, A);
        switch(t) {
        case 2:	/* rar, cant split */
            if(debug['P'])
                print("; %Drar; return 0\n", v2);
            return 0;

        case 3:	/* set */
            if(debug['P'])
                print("; %Dset; return 1\n", v2);
            return 1;

        case 1:	/* used, substitute */
        case 4:	/* use and set */
            if(f) {
                if(!debug['P'])
                    return 0;
                if(t == 4)
                    print("; %Dused+set and f=%d; return 0\n", v2, f);
                else
                    print("; %Dused and f=%d; return 0\n", v2, f);
                return 0;
            }
            if(copyu(p, v2, v1)) {
                if(debug['P'])
                    print("; sub fail; return 0\n");
                return 0;
            }
            if(debug['P'])
                print("; sub%D/%D", v2, v1);
            if(t == 4) {
                if(debug['P'])
                    print("; %Dused+set; return 1\n", v2);
                return 1;
            }
            break;
        }
        if(!f) {
            t = copyu(p, v1, A);
            if(!f && (t == 2 || t == 3 || t == 4)) {
                f = 1;
                if(debug['P'])
                    print("; %Dset and !f; f=%d", v1, f);
            }
        }
        if(debug['P'])
            print("\n");
        if(r->s2)
            if(!copy1(v1, v2, r->s2, f))
                return 0;
    }
    return 1;
}
@

<<function constprop(arm)>>=
/*
 * The idea is to remove redundant constants.
 *	$c1->v1
 *	($c1->v2 s/$c1/v1)*
 *	set v1  return
 * The v1->v2 should be eliminated by copy propagation.
 */
void
constprop(Adr *c1, Adr *v1, Reg *r)
{
    Prog *p;

    if(debug['C'])
        print("constprop %D->%D\n", c1, v1);
    for(; r != R; r = r->s1) {
        p = r->prog;
        if(debug['C'])
            print("%P", p);
        if(uniqp(r) == R) {
            if(debug['C'])
                print("; merge; return\n");
            return;
        }
        if(p->as == AMOVW && copyas(&p->from, c1)) {
                if(debug['C'])
                    print("; sub%D/%D", &p->from, v1);
                p->from = *v1;
        } else if(copyu(p, v1, A) > 1) {
            if(debug['C'])
                print("; %Dset; return\n", v1);
            return;
        }
        if(debug['C'])
            print("\n");
        if(r->s2)
            constprop(c1, v1, r->s2);
    }
}
@
%$

<<function FAIL(arm)>>=
/*
 * ASLL x,y,w
 * .. (not use w, not set x y w)
 * AXXX w,a,b (a != w)
 * .. (not use w)
 * (set w)
 * ----------- changed to
 * ..
 * AXXX (x<<y),a,b
 * ..
 */
#define FAIL(msg) { if(debug['H']) print("\t%s; FAILURE\n", msg); return 0; }
@

<<function shiftprop(arm)>>=
int
shiftprop(Reg *r)
{
    Reg *r1;
    Prog *p, *p1, *p2;
    int n, o;
    Adr a;

    p = r->prog;
    if(p->to.type != D_REG)
        FAIL("BOTCH: result not reg");
    n = p->to.reg;
    a = zprog.from;
    if(p->reg != R_NONE && p->reg != p->to.reg) {
        a.type = D_REG;
        a.reg = p->reg;
    }
    if(debug['H'])
        print("shiftprop\n%P", p);
    r1 = r;
    for(;;) {
        /* find first use of shift result; abort if shift operands or result are changed */
        r1 = uniqs(r1);
        if(r1 == R)
            FAIL("branch");
        if(uniqp(r1) == R)
            FAIL("merge");
        p1 = r1->prog;
        if(debug['H'])
            print("\n%P", p1);
        switch(copyu(p1, &p->to, A)) {
        case 0:	/* not used or set */
            if((p->from.type == D_REG && copyu(p1, &p->from, A) > 1) ||
               (a.type == D_REG && copyu(p1, &a, A) > 1))
                FAIL("args modified");
            continue;
        case 3:	/* set, not used */
            FAIL("BOTCH: noref");
        }
        break;
    }
    /* check whether substitution can be done */
    switch(p1->as) {
    default:
        FAIL("non-dpi");
    case AAND:
    case AEOR:
    case AADD:
    case AADC:
    case AORR:
    case ASUB:
    case ARSB:
    case ASBC:
    case ARSC:
        if(p1->reg == n || (p1->reg == R_NONE && p1->to.type == D_REG && p1->to.reg == n)) {
            if(p1->from.type != D_REG)
                FAIL("can't swap");
            p1->reg = p1->from.reg;
            p1->from.reg = n;
            switch(p1->as) {
            case ASUB:
                p1->as = ARSB;
                break;
            case ARSB:
                p1->as = ASUB;
                break;
            case ASBC:
                p1->as = ARSC;
                break;
            case ARSC:
                p1->as = ASBC;
                break;
            }
            if(debug['H'])
                print("\t=>%P", p1);
        }
    case ABIC:
    case ACMP:
    case ACMN:
        if(p1->reg == n)
            FAIL("can't swap");
        if(p1->reg == R_NONE && p1->to.reg == n)
            FAIL("shift result used twice");
    case AMVN:
        if(p1->from.type == D_SHIFT)
            FAIL("shift result used in shift");
        if(p1->from.type != D_REG || p1->from.reg != n)
            FAIL("BOTCH: where is it used?");
        break;
    }
    /* check whether shift result is used subsequently */
    p2 = p1;
    if(p1->to.reg != n)
    for (;;) {
        r1 = uniqs(r1);
        if(r1 == R)
            FAIL("inconclusive");
        p1 = r1->prog;
        if(debug['H'])
            print("\n%P", p1);
        switch(copyu(p1, &p->to, A)) {
        case 0:	/* not used or set */
            continue;
        case 3: /* set, not used */
            break;
        default:/* used */
            FAIL("reused");
        }
        break;
    }
    /* make the substitution */
    p2->from.type = D_SHIFT;
    p2->from.reg = R_NONE;
    o = p->reg;
    if(o == R_NONE)
        o = p->to.reg;
    switch(p->from.type){
    case D_CONST:
        o |= (p->from.offset&0x1f)<<7;
        break;
    case D_REG:
        o |= (1<<4) | (p->from.reg<<8);
        break;
    }
    switch(p->as){
    case ASLL:
        o |= 0<<5;
        break;
    case ASRL:
        o |= 1<<5;
        break;
    case ASRA:
        o |= 2<<5;
        break;
    }
    p2->from.offset = o;
    if(debug['H'])
        print("\t=>%P\tSUCCEED\n", p2);
    return 1;
}
@

<<function findpre(arm)>>=
Reg*
findpre(Reg *r, Adr *v)
{
    Reg *r1;

    for(r1=uniqp(r); r1!=R; r=r1,r1=uniqp(r)) {
        if(uniqs(r1) != r)
            return R;
        switch(copyu(r1->prog, v, A)) {
        case 1: /* used */
        case 2: /* read-alter-rewrite */
            return R;
        case 3: /* set */
        case 4: /* set and used */
            return r1;
        }
    }
    return R;
}
@

<<function findinc(arm)>>=
Reg*
findinc(Reg *r, Reg *r2, Adr *v)
{
    Reg *r1;
    Prog *p;


    for(r1=uniqs(r); r1!=R && r1!=r2; r=r1,r1=uniqs(r)) {
        if(uniqp(r1) != r)
            return R;
        switch(copyu(r1->prog, v, A)) {
        case 0: /* not touched */
            continue;
        case 4: /* set and used */
            p = r1->prog;
            if(p->as == AADD)
            if(p->from.type == D_CONST)
            if(p->from.offset > -4096 && p->from.offset < 4096)
                return r1;
        default:
            return R;
        }
    }
    return R;
}
@

<<function nochange(arm)>>=
int
nochange(Reg *r, Reg *r2, Prog *p)
{
    Adr a[3];
    int i, n;

    if(r == r2)
        return 1;
    n = 0;
    if(p->reg != R_NONE && p->reg != p->to.reg) {
        a[n].type = D_REG;
        a[n++].reg = p->reg;
    }
    switch(p->from.type) {
    case D_SHIFT:
        a[n].type = D_REG;
        a[n++].reg = p->from.offset&0xf;
    case D_REG:
        a[n].type = D_REG;
        a[n++].reg = p->from.reg;
    }
    if(n == 0)
        return 1;
    for(; r!=R && r!=r2; r=uniqs(r)) {
        p = r->prog;
        for(i=0; i<n; i++)
            if(copyu(p, &a[i], A) > 1)
                return 0;
    }
    return 1;
}
@

<<function findu1(arm)>>=
int
findu1(Reg *r, Adr *v)
{
    for(; r != R; r = r->s1) {
        if(r->active)
            return 0;
        r->active = 1;
        switch(copyu(r->prog, v, A)) {
        case 1: /* used */
        case 2: /* read-alter-rewrite */
        case 4: /* set and used */
            return 1;
        case 3: /* set */
            return 0;
        }
        if(r->s2)
            if (findu1(r->s2, v))
                return 1;
    }
    return 0;
}
@

<<function finduse(arm)>>=
int
finduse(Reg *r, Adr *v)
{
    Reg *r1;

    for(r1=firstr; r1!=R; r1=r1->link)
        r1->active = 0;
    return findu1(r, v);
}
@

<<function xtramodes(arm)>>=
int
xtramodes(Reg *r, Adr *a)
{
    Reg *r1, *r2, *r3;
    Prog *p, *p1;
    Adr v;

    p = r->prog;
    if(debug['h'] && p->as == AMOVB && p->from.type == D_OREG)	/* byte load */
        return 0;
    v = *a;
    v.type = D_REG;
    r1 = findpre(r, &v);
    if(r1 != R) {
        p1 = r1->prog;
        if(p1->to.type == D_REG && p1->to.reg == v.reg)
        switch(p1->as) {
        case AADD:
            if(p1->from.type == D_REG ||
               (p1->from.type == D_SHIFT && (p1->from.offset&(1<<4)) == 0 &&
                (p->as != AMOVB || (a == &p->from && (p1->from.offset&~0xf) == 0))) ||
               (p1->from.type == D_CONST && 
                p1->from.offset > -4096 && p1->from.offset < 4096))
            if(nochange(uniqs(r1), r, p1)) {
                if(a != &p->from || v.reg != p->to.reg)
                if (finduse(r->s1, &v)) {
                    if(p1->reg == R_NONE || p1->reg == v.reg)
                        /* pre-indexing */
                        p->scond |= C_WBIT;
                    else return 0;	
                }
                switch (p1->from.type) {
                case D_REG:
                    /* register offset */
                    a->type = D_SHIFT;
                    a->offset = p1->from.reg;
                    break;
                case D_SHIFT:
                    /* scaled register offset */
                    a->type = D_SHIFT;
                case D_CONST:
                    /* immediate offset */
                    a->offset = p1->from.offset;
                    break;
                }
                if(p1->reg != R_NONE)
                    a->reg = p1->reg;
                excise(r1);
                return 1;
            }
            break;
        case AMOVW:
            if(p1->from.type == D_REG)
            if((r2 = findinc(r1, r, &p1->from)) != R) {
            for(r3=uniqs(r2); r3->prog->as==ANOP; r3=uniqs(r3))
                ;
            if(r3 == r) {
                /* post-indexing */
                p1 = r2->prog;
                a->reg = p1->to.reg;
                a->offset = p1->from.offset;
                p->scond |= C_PBIT;
                if(!finduse(r, &r1->prog->to))
                    excise(r1);
                excise(r2);
                return 1;
            }
            }
            break;
        }
    }
    if(a != &p->from || a->reg != p->to.reg)
    if((r1 = findinc(r, R, &v)) != R) {
        /* post-indexing */
        p1 = r1->prog;
        a->offset = p1->from.offset;
        p->scond |= C_PBIT;
        excise(r1);
        return 1;
    }
    return 0;
}
@

<<function copyu(arm)>>=
/*
 * return
 * 1 if v only used (and substitute),
 * 2 if read-alter-rewrite
 * 3 if set
 * 4 if set and used
 * 0 otherwise (not touched)
 */
int
copyu(Prog *p, Adr *v, Adr *s)
{

    switch(p->as) {

    default:
        if(debug['P'])
            print(" (???)");
        return 2;

    case AMOVM:
        if(v->type != D_REG)
            return 0;
        if(p->from.type == D_CONST) {	/* read reglist, read/rar */
            if(s != A) {
                if(p->from.offset&(1<<v->reg))
                    return 1;
                if(copysub(&p->to, v, s, 1))
                    return 1;
                return 0;
            }
            if(copyau(&p->to, v)) {
                if(p->scond&C_WBIT)
                    return 2;
                return 1;
            }
            if(p->from.offset&(1<<v->reg))
                return 1;
        } else {			/* read/rar, write reglist */
            if(s != A) {
                if(p->to.offset&(1<<v->reg))
                    return 1;
                if(copysub(&p->from, v, s, 1))
                    return 1;
                return 0;
            }
            if(copyau(&p->from, v)) {
                if(p->scond&C_WBIT)
                    return 2;
                if(p->to.offset&(1<<v->reg))
                    return 4;
                return 1;
            }
            if(p->to.offset&(1<<v->reg))
                return 3;
        }
        return 0;
        
    case ANOP:	/* read, write */
    case AMOVW:
    case AMOVF:
    case AMOVD:
    case AMOVH:
    case AMOVHU:
    case AMOVB:
    case AMOVBU:
    case AMOVDW:
    case AMOVWD:
    case AMOVFD:
    case AMOVDF:
        if(p->scond&(C_WBIT|C_PBIT))
        if(v->type == D_REG) {
            if(p->from.type == D_OREG || p->from.type == D_SHIFT) {
                if(p->from.reg == v->reg)
                    return 2;
            } else {
            if(p->to.reg == v->reg)
                return 2;
            }
        }
        if(s != A) {
            if(copysub(&p->from, v, s, 1))
                return 1;
            if(!copyas(&p->to, v))
                if(copysub(&p->to, v, s, 1))
                    return 1;
            return 0;
        }
        if(copyas(&p->to, v)) {
            if(copyau(&p->from, v))
                return 4;
            return 3;
        }
        if(copyau(&p->from, v))
            return 1;
        if(copyau(&p->to, v))
            return 1;
        return 0;


    case AADD:	/* read, read, write */
    case ASUB:
    case ARSB:
    case ASLL:
    case ASRL:
    case ASRA:
    case AORR:
    case AAND:
    case AEOR:
    case AMUL:
    case ADIV:
    case ADIVU:
    case AADDF:
    case AADDD:
    case ASUBF:
    case ASUBD:
    case AMULF:
    case AMULD:
    case ADIVF:
    case ADIVD:

    case ACMPF:
    case ACMPD:
    case ACMP:
    case ACMN:
    case ACASE:
        if(s != A) {
            if(copysub(&p->from, v, s, 1))
                return 1;
            if(copysub1(p, v, s, 1))
                return 1;
            if(!copyas(&p->to, v))
                if(copysub(&p->to, v, s, 1))
                    return 1;
            return 0;
        }
        if(copyas(&p->to, v)) {
            if(p->reg == R_NONE)
                p->reg = p->to.reg;
            if(copyau(&p->from, v))
                return 4;
            if(copyau1(p, v))
                return 4;
            return 3;
        }
        if(copyau(&p->from, v))
            return 1;
        if(copyau1(p, v))
            return 1;
        if(copyau(&p->to, v))
            return 1;
        return 0;

    case ABEQ:	/* read, read */
    case ABNE:
    case ABHS:
    case ABLO:
    case ABMI:
    case ABPL:
    case ABVS:
    case ABVC:
    case ABHI:
    case ABLS:
    case ABGE:
    case ABLT:
    case ABGT:
    case ABLE:
        if(s != A) {
            if(copysub(&p->from, v, s, 1))
                return 1;
            return copysub1(p, v, s, 1);
        }
        if(copyau(&p->from, v))
            return 1;
        if(copyau1(p, v))
            return 1;
        return 0;

    case AB:	/* funny */
        if(s != A) {
            if(copysub(&p->to, v, s, 1))
                return 1;
            return 0;
        }
        if(copyau(&p->to, v))
            return 1;
        return 0;

    case ARET:	/* funny */
        if(v->type == D_REG)
        if(v->reg == REGRET)
            return 2;
        if(v->type == D_FREG)
        if(v->reg == FREGRET)
            return 2;

    case ABL:	/* funny */
        if(v->type == D_REG) {
            if(v->reg <= REGEXT && v->reg > exregoffset)
                return 2;
            if(v->reg == (uchar)REGARG)
                return 2;
        }
        if(v->type == D_FREG)
            if(v->reg <= FREGEXT && v->reg > exfregoffset)
                return 2;

        if(s != A) {
            if(copysub(&p->to, v, s, 1))
                return 1;
            return 0;
        }
        if(copyau(&p->to, v))
            return 4;
        return 3;

    case ATEXT:	/* funny */
        if(v->type == D_REG)
            if(v->reg == (uchar)REGARG)
                return 3;
        return 0;
    }
}
@

<<function a2type(arm)>>=
int
a2type(Prog *p)
{

    switch(p->as) {

    case ACMP:
    case ACMN:

    case AADD:
    case ASUB:
    case ARSB:
    case ASLL:
    case ASRL:
    case ASRA:
    case AORR:
    case AAND:
    case AEOR:
    case AMUL:
    case ADIV:
    case ADIVU:
        return D_REG;

    case ACMPF:
    case ACMPD:

    case AADDF:
    case AADDD:
    case ASUBF:
    case ASUBD:
    case AMULF:
    case AMULD:
    case ADIVF:
    case ADIVD:
        return D_FREG;
    }
    return D_NONE;
}
@

<<function copyas(arm)>>=
/*
 * direct reference,
 * could be set/use depending on
 * semantics
 */
int
copyas(Adr *a, Adr *v)
{

    if(regtyp(v)) {
        if(a->type == v->type)
        if(a->reg == v->reg)
            return 1;
    } else if(v->type == D_CONST) {		/* for constprop */
        if(a->type == v->type)
        if(a->symkind == v->symkind)
        if(a->sym == v->sym)
        if(a->reg == v->reg)
        if(a->offset == v->offset)
            return 1;
    }
    return 0;
}
@

<<function copyau(arm)>>=
/*
 * either direct or indirect
 */
int
copyau(Adr *a, Adr *v)
{

    if(copyas(a, v))
        return 1;
    if(v->type == D_REG) {
        if(a->type == D_OREG) {
            if(v->reg == a->reg)
                return 1;
        } else if(a->type == D_SHIFT) {
            if((a->offset&0xf) == v->reg)
                return 1;
            if((a->offset&(1<<4)) && 
                (a->offset>>8) == v->reg)
                return 1;
        }
    }
    return 0;
}
@

<<function copyau1(arm)>>=
int
copyau1(Prog *p, Adr *v)
{

    if(regtyp(v)) {
        if(a2type(p) == v->type)
        if(p->reg == v->reg) {
            if(a2type(p) != v->type)
                print("botch a2type %P\n", p);
            return 1;
        }
    }
    return 0;
}
@

<<function copysub(arm)>>=
/*
 * substitute s for v in a
 * return failure to substitute
 */
int
copysub(Adr *a, Adr *v, Adr *s, int f)
{

    if(f)
    if(copyau(a, v)) {
        if(a->type == D_SHIFT) {
            if((a->offset&0xf) == v->reg)
                a->offset = (a->offset&~0xf)|s->reg;
            if((a->offset&(1<<4)) && 
                          (a->offset>>8) == v->reg)
                a->offset = (a->offset&~(0xf<<8))|(s->reg<<8);
        } else
            a->reg = s->reg;
    }
    return 0;
}
@

<<function copysub1(arm)>>=
int
copysub1(Prog *p1, Adr *v, Adr *s, int f)
{

    if(f)
    if(copyau1(p1, v))
        p1->reg = s->reg;
    return 0;
}
@

<<global predinfo(arm)>>=
struct {
    int opcode;
    int notopcode;
    int scond; 
    int notscond; 
} predinfo[]  = { 
    { ABEQ,	ABNE,	0x0,	0x1, }, 
    { ABNE,	ABEQ,	0x1,	0x0, }, 
    { ABHS,	ABLO,	0x2,	0x3, }, 
    { ABLO,	ABHS,	0x3,	0x2, }, 
    { ABMI,	ABPL,	0x4,	0x5, }, 
    { ABPL,	ABMI,	0x5,	0x4, }, 
    { ABVS,	ABVC,	0x6,	0x7, }, 
    { ABVC,	ABVS,	0x7,	0x6, }, 
    { ABHI,	ABLS,	0x8,	0x9, }, 
    { ABLS,	ABHI,	0x9,	0x8, }, 
    { ABGE,	ABLT,	0xA,	0xB, }, 
    { ABLT,	ABGE,	0xB,	0xA, }, 
    { ABGT,	ABLE,	0xC,	0xD, }, 
    { ABLE,	ABGT,	0xD,	0xC, }, 
}; 
@

<<enum _anon_(arm)>>=
enum {
    Join,
    Split,
    End,
    Branch,
    Setcond,
    Toolong
};
@

<<enum _anon_ (5c/peep.c)(arm)>>=
enum {
    Falsecond,
    Truecond,
    Delbranch,
    Keepbranch
};
@

<<function isbranch(arm)>>=
int 
isbranch(Prog *p)
{
    return (ABEQ <= p->as) && (p->as <= ABLE); 
}
@

<<function predicable(arm)>>=
int
predicable(Prog *p)
{
    if (isbranch(p)
        || p->as == ANOP
        || p->as == AXXX
        || p->as == ADATA
        || p->as == AGLOBL
        || p->as == AGOK
        || p->as == AHISTORY
        || p->as == ANAME
        || p->as == ASIGNAME
        || p->as == ATEXT
        || p->as == AWORD
//        || p->as == ADYNT
//        || p->as == AINIT
        || p->as == ABCASE
        || p->as == ACASE)
        return 0; 
    return 1; 
}
@

<<function modifiescpsr(arm)>>=
/* 
 * Depends on an analysis of the encodings performed by 5l. 
 * These seem to be all of the opcodes that lead to the "S" bit
 * being set in the instruction encodings. 
 * 
 * C_SBIT may also have been set explicitly in p->scond.
 */ 
int
modifiescpsr(Prog *p)
{
    return (p->scond&C_SBIT)
        || p->as == ATST 
        || p->as == ATEQ 
        || p->as == ACMN
        || p->as == ACMP
        || p->as == AMULU
        || p->as == ADIVU
        || p->as == AMUL
        || p->as == ADIV
        || p->as == AMOD
        || p->as == AMODU
        || p->as == ABL;
} 
@

<<struct Joininfo>>=
typedef struct Joininfo {
    Reg *start;
    Reg *last;
    Reg *end;
    int len;
} Joininfo;
@

<<function joinsplit(arm)>>=
/*
 * Find the maximal chain of instructions starting with r which could
 * be executed conditionally
 */
int
joinsplit(Reg *r, Joininfo *j)
{
    j->start = r;
    j->last = r;
    j->len = 0;
    do {
        if (r->p2 && (r->p1 || r->p2->p2link)) {
            j->end = r;
            return Join;
        }
        if (r->s1 && r->s2) {
            j->end = r;
            return Split;
        }
        j->last = r;
        if (r->prog->as != ANOP)
            j->len++;
        if (!r->s1 && !r->s2) {
            j->end = r->link;
            return End;
        }
        if (r->s2) {
            j->end = r->s2;
            return Branch;
        }
        if (modifiescpsr(r->prog)) {
            j->end = r->s1;
            return Setcond;
        }
        r = r->s1;
    } while (j->len < 4);
    j->end = r;
    return Toolong;
}
@

<<function successor(arm)>>=
Reg *
successor(Reg *r)
{
    if (r->s1)
        return r->s1; 
    else
        return r->s2; 
}
@

<<function applypred(arm)>>=
void
applypred(Reg *rstart, Joininfo *j, int cond, int branch)
{
    int pred; 
    Reg *r; 

    if(j->len == 0)
        return;
    if (cond == Truecond)
        pred = predinfo[rstart->prog->as - ABEQ].scond;
    else
        pred = predinfo[rstart->prog->as - ABEQ].notscond; 
    
    for (r = j->start; ; r = successor(r)) {
        if (r->prog->as == AB) {
            if (r != j->last || branch == Delbranch)
                excise(r);
            else {
              if (cond == Truecond)
                r->prog->as = predinfo[rstart->prog->as - ABEQ].opcode;
              else
                r->prog->as = predinfo[rstart->prog->as - ABEQ].notopcode;
            }
        }
        else if (predicable(r->prog)) 
            r->prog->scond = (r->prog->scond&~C_SCOND)|pred;
        if (r->s1 != r->link) {
            r->s1 = r->link;
            r->link->p1 = r;
        }
        if (r == j->last)
            break;
    }
}
@

<<function predicate(arm)>>=
void
predicate(void)
{	
    Reg *r;
    int t1, t2;
    Joininfo j1, j2;

    for(r=firstr; r!=R; r=r->link) {
        if (isbranch(r->prog)) {
            t1 = joinsplit(r->s1, &j1);
            t2 = joinsplit(r->s2, &j2);
            if(j1.last->link != j2.start)
                continue;
            if(j1.end == j2.end)
            if((t1 == Branch && (t2 == Join || t2 == Setcond)) ||
               (t2 == Join && (t1 == Join || t1 == Setcond))) {
                applypred(r, &j1, Falsecond, Delbranch);
                applypred(r, &j2, Truecond, Delbranch);
                excise(r);
                continue;
            }
            if(t1 == End || t1 == Branch) {
                applypred(r, &j1, Falsecond, Keepbranch);
                excise(r);
                continue;
            }
        } 
    } 
}
@


\section{Dominators}

<<function postorder>>=
/*
 * find looping structure
 *
 * 1) find reverse postordering
 * 2) find approximate dominators,
 *	the actual dominators if the flow graph is reducible
 *	otherwise, dominators plus some other non-dominators.
 *	See Matthew S. Hecht and Jeffrey D. Ullman,
 *	"Analysis of a Simple Algorithm for Global Data Flow Problems",
 *	Conf.  Record of ACM Symp. on Principles of Prog. Langs, Boston, Massachusetts,
 *	Oct. 1-3, 1973, pp.  207-217.
 * 3) find all nodes with a predecessor dominated by the current node.
 *	such a node is a loop head.
 *	recursively, all preds with a greater rpo number are in the loop
 */
long
postorder(Reg *r, Reg **rpo2r, long n)
{
    Reg *r1;

    r->rpo = 1;
    r1 = r->s1;
    if(r1 && !r1->rpo)
        n = postorder(r1, rpo2r, n);
    r1 = r->s2;
    if(r1 && !r1->rpo)
        n = postorder(r1, rpo2r, n);
    rpo2r[n] = r;
    n++;
    return n;
}
@




\chapter{Linking Support}

\section{[[#pragma lib]] and automagic linking}

% nice feature. Simple and useful (if have a standard directory
% where to put the library)

<<[[macprag()]] other locals>>=
int c0, c;
char *hp;
Hist *h;
@

<<[[macprag()]] if pragma xxx>>=
if(s && strcmp(s->name, "lib") == 0) {
    c0 = getnsc();
    if(c0 != '"') {
        c = c0;
        if(c0 != '<')
            goto bad;
        c0 = '>';
    }
    for(hp = symb;;) {
        c = getc();
        if(c == c0)
            break;
        if(c == '\n')
            goto bad;
        *hp++ = c;
    }
    *hp = '\0';
    c = getcom();
    if(c != '\n')
        goto bad;

    /*
     * put pragma-line in as a funny history 
     */
    c = strlen(symb) + 1;
    while(c & 3)
        c++;

    while(nhunk < c)
        gethunk();
    hp = hunk;
    memcpy(hunk, symb, c);
    nhunk -= c;
    hunk += c;

    h = alloc(sizeof(Hist));
    h->name = hp;
    h->line = lineno;
    h->offset = -1; // pragma

    // add_list(h, hist)
    h->link = H;
    if(ehist == H) {
        hist = h;
        ehist = h;
        return;
    }
    ehist->link = h;
    ehist = h;

    return;

bad:
    unget(c);
    yyerror("syntax in #pragma lib");
    macend();

}
@


\section{Safe linking with type signatures, [[5c -T]]}
% md5sum like in ocaml!

% signature! for safe linking
<<enum signature>>=
enum signature {
    SIGNONE = 0,
    SIGDONE = 1,
    SIGINTERN = 2,

    // ???
    SIGNINTERN = 1729*325*1729,
};
@

<<[[Sym]] identifier value, code generation fields>>=
// enum<signature>
char	sig;
@
% SIGNINTERN does not fit in a char ...



<<[[zname()]] if generate signature for symbol s>>=
if(debug['T'] && 
   t == N_EXTERN && 
   s->sig != SIGDONE && 
   s->type != types[TENUM] && 
   s != symrathole){

    sig = sign(s);
    bf[0] = ASIGNAME;
    bf[1] = sig;
    bf[2] = sig>>8;
    bf[3] = sig>>16;
    bf[4] = sig>>24;
    bf[5] = t;
    bf[6] = s->symidx;
    Bwrite(b, bf, 7);
    s->sig = SIGDONE;
}
@

\subsection{[[sign()]]}

% main -> compile -> gclean -> outcode -> zname -> <>
<<function sign>>=
ulong
sign(Sym *s)
{
    ulong v;
    Type *t;

    if(s->sig == SIGINTERN)
        return SIGNINTERN;
    if((t = s->type) == T)
        return 0;
    v = signature(t);
    if(v == 0)
        v = SIGNINTERN;
    return v;
}
@

% sign -> <>
<<function signature>>=
ulong
signature(Type *t)
{
    ulong s;
    Typetab tt;

    tt.n = 0;
    tt.a = nil;
    s = signat(t, &tt);
    free(tt.a);
    return s;
}
@

% important the GINCOMPLETE!
% see draw.h

% sign -> signature -> <>
<<function signat>>=
static ulong
signat(Type *t, Typetab *tt)
{
    int i;
    Type *t1;
    long s;

    s = 0;
    for(; t; t=t->link) {
        s = s*thash1 + thash[t->etype];
        if(t->garb&GINCOMPLETE)
            return s;
        switch(t->etype) {
        case TARRAY:
            s = s*thash2 + 0;	/* was t->width */
            break;
        case TFUNC:
            for(t1=t->down; t1; t1=t1->down)
                s = s*thash3 + signat(t1, tt);
            break;
        case TSTRUCT:
        case TUNION:
            if((i = sigind(t, tt)) >= 0){
                s = s*thash2 + i;
                return s;
            }
            for(t1=t->link; t1; t1=t1->down)
                s = s*thash3 + signat(t1, tt);
            return s;
        case TIND:
            break;
        default:
            return s;
        }
    }
    return s;
}
@



<<global thash1>>=
ulong	thash1	= 0x2edab8c9;
@

<<global thash2>>=
ulong	thash2	= 0x1dc74fb8;
@

<<global thash3>>=
ulong	thash3	= 0x1f241331;
@

<<global thash>>=
ulong	thash[NALLTYPES];
@

<<global thashinit>>=
Init	thashinit[] =
{
    TXXX,		0x17527bbd,	0,

    TCHAR,		0x5cedd32b,	0,
    TUCHAR,		0x552c4454,	0,
    TSHORT,		0x63040b4b,	0,
    TUSHORT,	0x32a45878,	0,
    TINT,		0x4151d5bd,	0,
    TUINT,		0x5ae707d6,	0,
    TLONG,		0x5ef20f47,	0,
    TULONG,		0x36d8eb8f,	0,
    TVLONG,		0x6e5e9590,	0,
    TUVLONG,	0x75910105,	0,
    TFLOAT,		0x25fd7af1,	0,
    TDOUBLE,	0x7c40a1b2,	0,

    TIND,		0x1b832357,	0,
    TFUNC,		0x6babc9cb,	0,
    TARRAY,		0x7c50986d,	0,
    TVOID,		0x44112eff,	0,
    TSTRUCT,	0x7c2da3bf,	0,
    TUNION,		0x3eb25e98,	0,
    TENUM,		0x44b54f61,	0,

    TOLD,		0x22b15988,	0,
    TDOT,		0x0204f6b3,	0,

    -1,		0,		0,
};
@

% in tinit section for now
%<<[[tinit()]] initialise thash>>=
%for(p=thashinit; p->code >= 0; p++) {
%    urk("thash", nelem(thash), p->code);
%    thash[p->code] = p->value;
%}
%@



<<struct Typetab>>=
struct Typetab {
    int n;
    Type **a;
};
@

% signat -> <>
<<function sigind>>=
static int
sigind(Type *t, Typetab *tt)
{
    int n;
    Type **a, **na, **p, **e;

    n = tt->n;
    a = tt->a;
    e = a+n;
    /* linear search seems ok */
    for(p = a ; p < e; p++)
        if(sametype(*p, t))
            return p-a;
    if((n&15) == 0){
        na = malloc((n+16)*sizeof(Type*));
        memmove(na, a, n*sizeof(Type*));
        free(a);
        a = tt->a = na;
    }
    a[tt->n++] = t;
    return -1;
}
@



\subsection{[[#pragma incomplete]]}


<<[[macprag()]] if pragma xxx>>=
if(s && strcmp(s->name, "incomplete") == 0) {
    pragincomplete();
    return;
}
@

<<function pragincomplete>>=
void
pragincomplete(void)
{
    Sym *s;
    Type *t;
    bool istag;
    int  w, et;

    istag = false;
    s = getsym();
    if(s == nil)
        goto out;
    et = 0;
    w = s->lexical;
    if(w == LSTRUCT)
        et = TSTRUCT;
    else if(w == LUNION)
        et = TUNION;
    if(et != 0){
        s = getsym();
        if(s == nil){
            yyerror("missing struct/union tag in pragma incomplete");
            goto out;
        }
        if(s->lexical != LNAME && s->lexical != LTYPE){
            yyerror("invalid struct/union tag: %s", s->name);
            goto out;
        }
        dotag(s, et, 0);
        istag = true;
    }else if(strcmp(s->name, "_off_") == 0){
        debug['T'] = false;
        goto out;
    }else if(strcmp(s->name, "_on_") == 0){
        debug['T'] = true;
        goto out;
    }

    t = s->type;
    if(istag)
        t = s->suetag;
    if(t == T)
        yyerror("unknown type %s in pragma incomplete", s->name);
    else if(!typesu[t->etype])
        yyerror("not struct/union type in pragma incomplete: %s", s->name);
    else
        t->garb |= GINCOMPLETE;
out:
    while(getnsc() != '\n')
        ;
    if(debug['f'])
        print("%s incomplete\n", s->name);
}
@

<<[[Qualifier]] other cases>>=
GINCOMPLETE	= 1<<2,
@
% >>


\chapter{Debugging Support}

% db has awesome information! thx to 8c (and 8l).
% in db doing $C  dumps the stacktrace with parameters values! and locals!
%  ex:
%  caml_main(argv=...) /home/pad/../main.c called from main+f (/home/pad/...)
%    caml_main.raise_buf/ 0x1
%    caml_main.pos/ 0x0
%    caml_main.trail/ 0x4cf2c
%    ...
%  main(argv=...) /home/pad/.../main.c called from _main+26 (.../main9.s:12)

%http://yosefk.com/blog/getting-the-call-stack-without-a-frame-pointer.html

\section{General debugging metadata}
% Instruction origin location?

% have lineno field in generated object that tracked
% back the lineno of the relevant C code.

%less: need special flags for that?

\section{Acid debugger metadata, [[5c -a]]}


% 5c -a to print acid declarations
%  -n print acid to file
%  -s print structure offsets


%from rio mkfile:
%syms:V:
%	$CC -a $CFLAGS rio.c	> syms
%	$CC -aa $CFLAGS *.c 	>>syms

% -aa ??


<<[[compile()]] if writing acid to standard output>>=
/*
 * if we're writing acid to standard output, don't keep scratching
 * outbuf.
 */
if((debug['a'] || debug['Z']) && !debug['n']) {
    if (first) {
        outfile = nil;
        Binit(&outbuf, dup(1, -1), OWRITE);
        dup(2, 1);
    }
} 
@

<<[[compile()]] adjust p for outfile if acid option>>=
if(debug['a'] && debug['n'])
    strcat(p, ".acid");
@

\subsection{Entities}

<<[[dodecl()]] case ONAME, debugging support>>=
acidvar(s);
@

<<[[doenum()]] debugging support>>=
acidvar(s);
@



% doenum? | dodecl? -> <>
% exported in cc.h
<<function acidvar>>=
void
acidvar(Sym *s)
{
    int n;
    Io *i;
    Type *t;
    Sym *s1, *s2;

    <<[[acidvar()]] return if no -a or -s>>
    <<[[acidvar()]] if -aa>>

    t = s->type;
    while(t && t->etype == TIND)
        t = t->link;
    if(t == T)
        return;
    if(t->etype == TENUM) {
        Bprint(&outbuf, "%s = ", amap(s->name));
        if(!typefd[t->etype])
            Bprint(&outbuf, "%lld;\n", s->vconst);
        else
            Bprint(&outbuf, "%f\n;", s->fconst);
        return;
    }
    if(!typesu[t->etype])
        return;
    s1 = acidsue(t->link);
    if(s1 == S)
        return;
    switch(s->class) {
    case CAUTO:
    case CPARAM:
        s2 = acidfun(thisfntype);
        if(s2)
            Bprint(&outbuf, "complex %s %s:%s;\n",
                amap(s1->name), amap(s2->name), amap(s->name));
        break;
    
    case CEXTERN:
    case CGLOBL:
    case CSTATIC: case CLOCAL:
        Bprint(&outbuf, "complex %s %s;\n",
            amap(s1->name), amap(s->name));
        break;
    }
}
@

<<[[acidvar()]] return if no -a or -s>>=
if(!debug['a'] || debug['s'])
    return;
@

<<[[acidvar()]] if -aa>>=
if(debug['a'] > 1) {
    n = 0;
    for(i=iostack; i; i=i->link)
        n++;
    if(n > 1)
        return;
}
@

% acidvar -> <>
<<function acidsue>>=
Sym*
acidsue(Type *t)
{
    int h;
    Sym *s;

    if(t != T)
    for(h=0; h<nelem(hash); h++)
        for(s = hash[h]; s != S; s = s->link)
            if(s->suetag && s->suetag->link == t)
                return s;
    return 0;
}
@

% acidvar -> <>
<<function acidfun>>=
Sym*
acidfun(Type *t)
{
    int h;
    Sym *s;

    for(h=0; h<nelem(hash); h++)
        for(s = hash[h]; s != S; s = s->link)
            if(s->type == t)
                return s;
    return 0;
}
@



<<global kwd>>=
static char *kwd[] =
{
    "$adt", "$aggr", "$append", "$builtin", "$complex", "$defn",
    "$delete", "$do", "$else", "$eval", "$head", "$if",
    "$local", "$loop", "$return", "$tail", "$then",
    "$union", "$whatis", "$while",
};
@
% compared to Pickle.kwd ? $builtin en plus?

<<function amap>>=
char*
amap(char *s)
{
    int i, bot, top, new;

    bot = 0;
    top = bot + nelem(kwd) - 1;
    while(bot <= top){
        new = bot + (top - bot)/2;
        i = strcmp(kwd[new]+1, s);
        if(i == 0)
            return kwd[new];

        if(i < 0)
            bot = new + 1;
        else
            top = new - 1;
    }
    return s;
}
@







\subsection{Structure/union definitions}

% called from sualign, so for struct and union
% exported in cc.h
<<function acidtype>>=
void
acidtype(Type *t)
{
    Sym *s;
    Type *l;
    Io *i;
    int n;
    char *an;

    <<[[acidtype()]] return if no -a>>
    <<[[acidtype()]] if -aa>>

    s = acidsue(t->link);
    if(s == S)
        return;
    switch(t->etype) {
    case TUNION:
    case TSTRUCT:
        if(debug['s'])
            goto asmstr;
        an = amap(s->name);
        Bprint(&outbuf, "sizeof%s = %ld;\n", an, t->width);
        Bprint(&outbuf, "aggr %s\n{\n", an);
        for(l = t->link; l != T; l = l->down)
            acidmember(l, 0, 1);
        Bprint(&outbuf, "};\n\n");

        Bprint(&outbuf, "defn\n%s(addr) {\n\tcomplex %s addr;\n", an, an);
        for(l = t->link; l != T; l = l->down)
            acidmember(l, 0, 0);
        Bprint(&outbuf, "};\n\n");
        break;

    asmstr:
        if(s == S)
            break;
        for(l = t->link; l != T; l = l->down)
            if(l->sym != S)
                Bprint(&outbuf, "#define\t%s.%s\t%ld\n",
                    s->name,
                    l->sym->name,
                    l->offset);
        break;

    default:
        Bprint(&outbuf, "T%d\n", t->etype);
        return;

    }
}
@

<<[[acidtype()]] return if no -a>>=
if(!debug['a'])
    return;
@
<<[[acidtype()]] if -aa>>=
if(debug['a'] > 1) {
    n = 0;
    for(i=iostack; i; i=i->link)
        n++;
    if(n > 1)
        return;
}
@
\l could factorize, seems identical to chunk for acidvar

<<global acidchar>>=
char	acidchar[NTYPE];
@

<<global acidcinit>>=
Init	acidcinit[] =
{
    TCHAR,		'C',	0,
    TUCHAR,		'b',	0,
    TSHORT,		'd',	0,
    TUSHORT,	'u',	0,
    TLONG,		'D',	0,
    TULONG,		'U',	0,
    TVLONG,		'V',	0,
    TUVLONG,	'W',	0,
    TFLOAT,		'f',	0,
    TDOUBLE,	'F',	0,
    TARRAY,		'a',	0,
    TIND,		'X',	0,
    -1,		0,	0,
};
@

<<function acidinit>>=
static void
acidinit(void)
{
    Init *p;

    for(p=acidcinit; p->code >= 0; p++)
        acidchar[p->code] = p->value;

    acidchar[TINT] = acidchar[TLONG];
    acidchar[TUINT] = acidchar[TULONG];
    if(types[TINT]->width != types[TLONG]->width) {
        acidchar[TINT] = acidchar[TSHORT];
        acidchar[TUINT] = acidchar[TUSHORT];
        if(types[TINT]->width != types[TSHORT]->width)
            warn(Z, "acidmember int not long or short");
    }
    if(types[TIND]->width == types[TUVLONG]->width)
        acidchar[TIND] = 'Y';
    
}
@

<<function acidmember>>=
void
acidmember(Type *t, long off, int flag)
{
    Sym *s, *s1;
    Type *l;
    static bool acidcharinit = false;

    if(acidcharinit == false) {
        acidinit();
        acidcharinit = true;
    }
    s = t->sym;
    switch(t->etype) {
    default:
        Bprint(&outbuf, "	T%d\n", t->etype);
        break;

    case TIND:
        if(s == S)
            break;
        if(flag) {
            for(l=t; l->etype==TIND; l=l->link)
                ;
            if(typesu[l->etype]) {
                s1 = acidsue(l->link);
                if(s1 != S) {
                    Bprint(&outbuf, "	'A' %s %ld %s;\n",
                        amap(s1->name),
                        t->offset+off, amap(s->name));
                    break;
                }
            }
        } else {
            Bprint(&outbuf,
                "\tprint(\"\t%s\t\", addr.%s\\X, \"\\n\");\n",
                amap(s->name), amap(s->name));
            break;
        }

    case TINT:
    case TUINT:
    case TCHAR:
    case TUCHAR:
    case TSHORT:
    case TUSHORT:
    case TLONG:
    case TULONG:
    case TVLONG:
    case TUVLONG:
    case TFLOAT:
    case TDOUBLE:
    case TARRAY:
        if(s == S)
            break;
        if(flag) {
            Bprint(&outbuf, "	'%c' %ld %s;\n",
            acidchar[t->etype], t->offset+off, amap(s->name));
        } else {
            Bprint(&outbuf, "\tprint(\"\t%s\t\", addr.%s, \"\\n\");\n",
                amap(s->name), amap(s->name));
        }
        break;

    case TSTRUCT:
    case TUNION:
        s1 = acidsue(t->link);
        if(s1 == S)
            break;
        if(flag) {
            if(s == S) {
                Bprint(&outbuf, "	{\n");
                for(l = t->link; l != T; l = l->down)
                    acidmember(l, t->offset+off, flag);
                Bprint(&outbuf, "	};\n");
            } else {
                Bprint(&outbuf, "	%s %ld %s;\n",
                    amap(s1->name),
                    t->offset+off, amap(s->name));
            }
        } else {
            if(s != S) {
                Bprint(&outbuf, "\tprint(\"%s %s {\\n\");\n",
                    amap(s1->name), amap(s->name));
                Bprint(&outbuf, "\t%s(addr.%s);\n",
                    amap(s1->name), amap(s->name));
                Bprint(&outbuf, "\tprint(\"}\\n\");\n");
            } else {
                Bprint(&outbuf, "\tprint(\"%s {\\n\");\n",
                    amap(s1->name));
                Bprint(&outbuf, "\t\t%s(addr+%ld);\n",
                    amap(s1->name), t->offset+off);
                Bprint(&outbuf, "\tprint(\"}\\n\");\n");
            }
        }
        break;
    }
}
@




\section{Pickle, [[5c -Z]]}

% ?? automatic marshalling? thrift?

% 5c -Z
% - add -n to create _picke.c instead of printing on stdout


<<[[compile()]] adjust p for outfile if pickle option>>=
else if(debug['Z'] && debug['n'])
    strcat(p, "_pickle.c");
@

<<global kwd (cc/pickle.c)>>=
static char *kwd[] =
{
    "$adt", "$aggr", "$append", "$complex", "$defn",
    "$delete", "$do", "$else", "$eval", "$head", "$if",
    "$local", "$loop", "$return", "$tail", "$then",
    "$union", "$whatis", "$while",
};
@
%$

<<global picklestr>>=
static char picklestr[] = "\tpickle(s, un, ";
@

<<function pmap>>=
static char*
pmap(char *s)
{
    int i, bot, top, new;

    bot = 0;
    top = bot + nelem(kwd) - 1;
    while(bot <= top){
        new = bot + (top - bot)/2;
        i = strcmp(kwd[new]+1, s);
        if(i == 0)
            return kwd[new];

        if(i < 0)
            bot = new + 1;
        else
            top = new - 1;
    }
    return s;
}
@

<<function picklesue>>=
Sym*
picklesue(Type *t)
{
    int h;
    Sym *s;

    if(t != T)
    for(h=0; h<nelem(hash); h++)
        for(s = hash[h]; s != S; s = s->link)
            if(s->suetag && s->suetag->link == t)
                return s;
    return 0;
}
@

<<global picklechar>>=
char	picklechar[NTYPE];
@

<<global picklecinit>>=
Init	picklecinit[] =
{
    TCHAR,		'C',	0,
    TUCHAR,		'b',	0,
    TSHORT,		'd',	0,
    TUSHORT,		'u',	0,
    TLONG,		'D',	0,
    TULONG,		'U',	0,
    TVLONG,		'V',	0,
    TUVLONG,	'W',	0,
    TFLOAT,		'f',	0,
    TDOUBLE,		'F',	0,
    TARRAY,		'a',	0,
    TIND,		'X',	0,
    -1,		0,	0,
};
@

<<function pickleinit>>=
static void
pickleinit(void)
{
    Init *p;

    for(p=picklecinit; p->code >= 0; p++)
        picklechar[p->code] = p->value;

    picklechar[TINT] = picklechar[TLONG];
    picklechar[TUINT] = picklechar[TULONG];
    if(types[TINT]->width != types[TLONG]->width) {
        picklechar[TINT] = picklechar[TSHORT];
        picklechar[TUINT] = picklechar[TUSHORT];
        if(types[TINT]->width != types[TSHORT]->width)
            warn(Z, "picklemember int not long or short");
    }
    
}
@

<<function picklemember>>=
void
picklemember(Type *t, long off)
{
    Sym *s, *s1;
    static int picklecharinit = 0;

    if(picklecharinit == 0) {
        pickleinit();
        picklecharinit = 1;
    }
    s = t->sym;
    switch(t->etype) {
    default:
        Bprint(&outbuf, "	T%d\n", t->etype);
        break;

    case TIND:
        if(s == S)
            Bprint(&outbuf,
                "%s\"p\", (char*)addr+%ld+_i*%ld);\n",
                picklestr, t->offset+off, t->width);
        else
            Bprint(&outbuf,
                "%s\"p\", &addr->%s);\n",
                picklestr, pmap(s->name));
        break;

    case TINT:
    case TUINT:
    case TCHAR:
    case TUCHAR:
    case TSHORT:
    case TUSHORT:
    case TLONG:
    case TULONG:
    case TVLONG:
    case TUVLONG:
    case TFLOAT:
    case TDOUBLE:
        if(s == S)
            Bprint(&outbuf, "%s\"%c\", (char*)addr+%ld+_i*%ld);\n",
                picklestr, picklechar[t->etype], t->offset+off, t->width);
        else
            Bprint(&outbuf, "%s\"%c\", &addr->%s);\n",
                picklestr, picklechar[t->etype], pmap(s->name));
        break;
    case TARRAY:
        Bprint(&outbuf, "\tfor(_i = 0; _i < %ld; _i++) {\n\t",
            t->width/t->link->width);
        picklemember(t->link, t->offset+off);
        Bprint(&outbuf, "\t}\n\t_i = 0;\n\tUSED(_i);\n");
        break;

    case TSTRUCT:
    case TUNION:
        s1 = picklesue(t->link);
        if(s1 == S)
            break;
        if(s == S) {
            Bprint(&outbuf, "\tpickle_%s(s, un, (%s*)((char*)addr+%ld+_i*%ld));\n",
                pmap(s1->name), pmap(s1->name), t->offset+off, t->width);
        } else {
            Bprint(&outbuf, "\tpickle_%s(s, un, &addr->%s);\n",
                pmap(s1->name), pmap(s->name));
        }
        break;
    }
}
@

<<function pickletype>>=
void
pickletype(Type *t)
{
    Sym *s;
    Type *l;
    Io *i;
    int n;
    char *an;

    if(!debug['P'])
        return;
    if(debug['P'] > 1) {
        n = 0;
        for(i=iostack; i; i=i->link)
            n++;
        if(n > 1)
            return;
    }
    s = picklesue(t->link);
    if(s == S)
        return;
    switch(t->etype) {
    default:
        Bprint(&outbuf, "T%d\n", t->etype);
        return;

    case TUNION:
    case TSTRUCT:
        if(debug['s'])
            goto asmstr;
        an = pmap(s->name);

        Bprint(&outbuf, "void\npickle_%s(void *s, int un, %s *addr)\n{\n\tint _i = 0;\n\n\tUSED(_i);\n", an, an);
        for(l = t->link; l != T; l = l->down)
            picklemember(l, 0);
        Bprint(&outbuf, "}\n\n");
        break;
    asmstr:
        if(s == S)
            break;
        for(l = t->link; l != T; l = l->down)
            if(l->sym != S)
                Bprint(&outbuf, "#define\t%s.%s\t%ld\n",
                    s->name,
                    l->sym->name,
                    l->offset);
        break;
    }
}
@

%<<function picklefun>>=
%//Sym*
%//picklefun(Type *t)
%//{
%//    int h;
%//    Sym *s;
%//
%//    for(h=0; h<nelem(hash); h++)
%//        for(s = hash[h]; s != S; s = s->link)
%//            if(s->type == t)
%//                return s;
%//    return 0;
%//}
%@
%
%<<function picklevar>>=
%//void
%//picklevar(Sym *s)
%//{
%//    int n;
%//    Io *i;
%//    Type *t;
%//    Sym *s1, *s2;
%//
%//    if(!debug['P'] || debug['s'])
%//        return;
%//    if(debug['P'] > 1) {
%//        n = 0;
%//        for(i=iostack; i; i=i->link)
%//            n++;
%//        if(n > 1)
%//            return;
%//    }
%//    t = s->type;
%//    while(t && t->etype == TIND)
%//        t = t->link;
%//    if(t == T)
%//        return;
%//    if(t->etype == TENUM) {
%//        Bprint(&outbuf, "%s = ", pmap(s->name));
%//        if(!typefd[t->etype])
%//            Bprint(&outbuf, "%lld;\n", s->vconst);
%//        else
%//            Bprint(&outbuf, "%f\n;", s->fconst);
%//        return;
%//    }
%//    if(!typesu[t->etype])
%//        return;
%//    s1 = picklesue(t->link);
%//    if(s1 == S)
%//        return;
%//    switch(s->class) {
%//    case CAUTO:
%//    case CPARAM:
%//        s2 = picklefun(thisfntype);
%//        if(s2)
%//            Bprint(&outbuf, "complex %s %s:%s;\n",
%//                pmap(s1->name), pmap(s2->name), pmap(s->name));
%//        break;
%//    
%//    case CEXTERN:
%//    case CGLOBL:
%//    case CSTATIC: case CLOCAL:
%//        Bprint(&outbuf, "complex %s %s;\n",
%//            pmap(s1->name), pmap(s->name));
%//        break;
%//    }
%//}
%@


\chapter{Profiling Support}

% actually always true, only way to disable it is via pragma locally
<<global profileflg>>=
bool	profileflg;
@
<<[[main()]] remaining initialisation>>=
profileflg = true;	/* #pragma can turn it off */
@


<<[[gpseudo()]] if TEXT, set possible TEXT attributes>>=
if(a == ATEXT)
    p->reg = (profileflg ? 0 : NOPROF);
@

\section{Text attributes}

% See \book{Assembler} and \book{Linker} and of course \book{Profiler}.

\section{[[#pragma profile]]}

<<[[macprag()]] if pragma xxx>>=
if(s && strcmp(s->name, "profile") == 0) {
    pragprofile();
    return;
}
@

% could factorize with other pragxxx, almost always the same style.

<<function pragprofile>>=
void
pragprofile(void)
{
    Sym *s;

    profileflg = false;
    s = getsym();
    if(s) {
        profileflg = atoi(s->name+1);
        if(strcmp(s->name, "on") == 0 ||
           strcmp(s->name, "yes") == 0)
            profileflg = true;
    }
    while(getnsc() != '\n')
        ;
    <<[[pragprofile()]] debug if [[-f]]>>
}
@


<<[[pragprofile()]] debug if [[-f]]>>=
if(debug['f'])
    if(profileflg)
        print("%4ld: profileflg %d\n", lineno, profileflg);
    else
        print("%4ld: profileflg off\n", lineno);
@


\chapter{Advanced Topics TODO}

% got some "counter too large errors for now, so I commented the whole section
\iffalse

\section{Advanced C features}

\subsection{Function and function pointer automatic conversions}

% fp(...) -> (*fp)(...)

<<[[tcomo()]] when OFUNC case, add OIND if pointer function call>>=
if(l->type->etype == TIND && l->type->link->etype == TFUNC) {
    l = new1(OIND, l, Z);
    l->type = l->left->type->link;
    n->left = l;
}
@

% Also automatically convert TFUNC in TIND TFUNC in paramconv():

<<[[paramconv()]] switch etype cases>>=
case TFUNC:
    t = typ(TIND, t);
    t->width = types[TIND]->width;
    break;
@
%ocaml: forbid, seems wrong.

% A function parameter is really a function pointer.
%can do int foo(int bar(int x)) { }. ugly.

% Also automatically add a OADDR when reference
% a function (in an argument, etc.)

\subsection{Array and pointer automatic conversions}

% An array is really a pointer when passed as a parameter
% as the size of the array information is lost.
% can do int foo(int x[45]) { }, ugly, because no typecheck done on size after.

<<[[paramconv()]] switch etype cases>>=
case TARRAY:
    t = typ(TIND, t->link);
    t->width = types[TIND]->width;
    break;
@
%ocaml: forbid
% update: allow now because used for jmp_buf in libc.h

% Also automatically add an OADDR when reference an array (to index it,
% to pass it as an argument, etc.)

\subsection{Local [[static]]}
% sugar for what could be just a scoped global.


<<[[Storage_class]] cases>>=
CLOCAL, // local static
@
%todo: rename CSTATIC_LOCAL, so can then rename CAUTO in CLOCAL

% defs

<<[[adecl()]] adjust storage to CLOCAL if static local variable>>=
if(c == CSTATIC)
    c = CLOCAL;
@
% c gets propagated to s->class (and then to Node.class)

<<[[dodecl()]] case ONAME, if local static variable>>=
if(s->class == CLOCAL)
    s = mkstatic(s);
@
% adecl callback get called before this chunk! important

% uses

<<name rule, if local static variable>>=
if($1->class == CLOCAL)
    $1 = mkstatic($1);
@
%$

% sugar

% rename locals in global symbol table so have unique name with the block
<<function mkstatic>>=
Sym*
mkstatic(Sym *s)
{
    Sym *s1;

    <<[[mkstatic()]] sanity check s>>
    snprint(symb, NSYMB, "%s$%d", s->name, s->block);
    s1 = lookup();

    if(s1->class != CSTATIC) {
        s1->type = s->type;
        s1->offset = s->offset;
        s1->block = s->block;
        s1->class = CSTATIC;
    }
    return s1;
}
@
% call mkstatic at def and use time, hence the if below to do
% the assignment only the first time.

<<[[mkstatic()]] sanity check s>>=
if(s->class != CLOCAL) // should never happen, use errorexit()?
    return s;
@

\subsection{Local [[volatile]]}

%todo: volatile means data can change outside.
% so if put a local in a register, and then read
% back from this register, this may be wrong, you
% want to read back from the address because it
% may have changed.

<<[[revertdcl()]] other locals>>=
Node *n1;
@

<<[[reverdcl()]] if volatile symbol>>=
if(s->type && (s->type->garb & GVOLATILE)) {
    // add USED(&local_volatile);
    n1 = new(ONAME, Z, Z);

    n1->sym = s;
    n1->type = s->type;
    n1->etype = (s->type != T) ? s->type->etype : TVOID;
    n1->xoffset = s->offset;
    n1->class = s->class;

    n1 = new(OADDR, n1, Z);
    n1 = new(OUSED, n1, Z);

    // add_list(n1, n)
    if(n == Z)
        n = n1;
    else
        n = new(OLIST, n1, n);
}
@

<<xdecl rule, adjust block body with possible hidden generated nodes>>=
if(n)
    $6 = new(OLIST, n, $6);
@

<<ulstmt rule, adjust block body with possible hidden generated nodes>>=
if(n)
    $$ = new(OLIST, n, $2);
@
%$

<<ulstmt rule, adjust forexpr with possible hidden generated nodes>>=
if(n){
    if($4)
        $4 = new(OLIST, n, $4);
    else
        $4 = n;
}
@

% gen -> usedset -> <>
<<[[usedset()]] switch node op cases>>=
case OADDR:	/* volatile */
    gins(ANOP, n, Z);
    break;
@

\subsection{Bitfields}

%\subsubsection{Parsing}

% struct x { int foo:1, bar:2, xxx:14; }
% bits for the same storage.
% Not the same than  struct x {int foo:1; int bar:2 }

<<global firstbit>>=
bool	firstbit;
@
%old: long -> bool

<<global lastbit>>=
long	lastbit;
@

<<[[dodecl()]] case ONAME, other initializations>>=
firstbit = false;
@
\t dead? already done in sbody anyway

<<sbody rule, initializations before parsing the fields>>=
lastbit = 0;
firstbit = true;
@

<<edecor rule, set fields after parsed a field declarator>>=
lastbit = 0;
firstbit = true;
@



<<global lastfield>>=
// option<long> None = -1 | 0
long	lastfield;
@
% set in dodecl() and ?
<<[[dodecl()]] other initializations>>=
lastfield = 0;
@





% parsing

<<declaration nodes>>=
OBIT,
@

<<edecor rule>>=
|   tag ':' lexpr   { $$ = new(OBIT, $1, $3); }
|   ':' lexpr       { $$ = new(OBIT, Z, $2); }
@
%$

<<[[dodecl()]] switch node kind cases>>=
case OBIT:
    n1 = n->right;
    complex(n1);

    lastfield = -1; // None
    if(n1->op == OCONST)
        lastfield = n1->vconst;
    if(lastfield < 0) {
        diag(n, "field width must be non-negative constant");
        lastfield = 1;
    }

    if(lastfield == 0) {
        lastbit = 0;
        firstbit = true;
        if(n->left != Z) {
            diag(n, "zero width named field");
            lastfield = 1;
        }
    }
    if(!typei[t->etype]) {
        diag(n, "field type must be int-like");
        t = types[TINT];
        lastfield = 1;
    }
    if(lastfield > tfield->width*8) {
        diag(n, "field width larger than field unit");
        lastfield = 1;
    }

    lastbit += lastfield;
    if(lastbit > tfield->width*8) {
        lastbit = lastfield;
        firstbit = true;
    }
    n = n->left;
    goto loop;
@




<<[[edecl()]] if lastfield>>=
if(lastfield) {
    t->shift = lastbit - lastfield;
    t->nbits = lastfield;
    if(firstbit)
        t->shift = -t->shift;

    if(typeu[t->etype])
        t->etype = tufield->etype;
    else
        t->etype = tfield->etype;
}
@

<<global tfield>>=
Type*	tfield;
@
% and init code in cinit or tinit

<<global tufield>>=
Type*	tufield;
@
% ??? unsigned field?

<<[[ginit()]] misc initialisations>>=
tfield = types[TLONG];
@
% in ginit which is in 5c/txt.c because arm specific

<<[[main()]] remaining initialisation>>=
tufield = simplet((1L<<tfield->etype) | BUNSIGNED);
@
% back in generic code
% >>



%\subsubsection{Typechecking}



<<[[tcomo()]] when OADDR, check if bitfield>>=
if(l->type->nbits) {
    diag(n, "address of a bit field");
    goto bad;
}
@
<<[[tcomo()]] when OSIZE, check if sizeof bitfield>>=
if(l->op == OBIT) {
    diag(n, "sizeof bitfield");
    goto bad;
}
@


<<[[init1()]] sanity check t has no bitfields>>=
if(t->nbits)
    diag(Z, "cannot initialize bitfields");
@


%\subsection{Code generation}

<<[[makedot()]] if bitfields>>=
if(t->nbits) {
    n1 = new(OXXX, Z, Z);
    *n1 = *n;
    n->op = OBIT;
    n->left = n1;
    n->right = Z;
    n->type = t;
    n->addable = n1->left->addable;
    n = n1;
}
@


% how can have this OBIT in an expression context?
% I think complex() explicitly mark expressions
% which are bitfields, e.g.  foo.x where x was a bitfield

<<[[cgenrel()]] switch node kind cases>>=
case OBIT:
    <<[[cgenrel()]] nullwarn check if nn is null>>
    bitload(n, &nod, Z, Z, nn);
    gopcode(OAS, &nod, Z, nn);
    regfree(&nod);
    break;
@


<<[[cgenrel()]] when OAS, if bitfield assignment>>=
if(l->op == OBIT)
    goto bitas;
@

<<[[cgenrel()]] when OASMUL/OASDIV/etc, if bitfield assignment>>=
if(l->op == OBIT)
    goto asbitop;
@

<<[[cgenrel()]] when OASADD/OASSUB/etc, if bitfield assignment>>=
if(l->op == OBIT)
    goto asbitop;
@


<<[[cgenrel()]] switch node kind cases>>=
asbitop:
    regalloc(&nod4, n, nn);
    if(l->complex >= r->complex) {
        bitload(l, &nod, &nod1, &nod2, &nod4);
        regalloc(&nod3, r, Z);
        cgen(r, &nod3);
    } else {
        regalloc(&nod3, r, Z);
        cgen(r, &nod3);
        bitload(l, &nod, &nod1, &nod2, &nod4);
    }
    gmove(&nod, &nod4);
    gopcode(o, &nod3, Z, &nod4);
    regfree(&nod3);
    gmove(&nod4, &nod);
    regfree(&nod4);
    bitstore(l, &nod, &nod1, &nod2, nn);
    break;
@

<<[[cgenrel()]] when OPOSTINC/OPOSTDEC, if bitfield>>=
if(l->op == OBIT)
    goto bitinc;
@

<<[[cgenrel()]] when OPREINC/OPREDEC, if bitfield>>=
if(l->op == OBIT)
    goto bitinc;
@

<<[[cgenrel()]] switch node kind cases>>=
bitinc:
    if(nn != Z && (o == OPOSTINC || o == OPOSTDEC)) {
        bitload(l, &nod, &nod1, &nod2, Z);
        gopcode(OAS, &nod, Z, nn);
        gopcode(OADD, nodconst(v), Z, &nod);
        bitstore(l, &nod, &nod1, &nod2, Z);
        break;
    }
    bitload(l, &nod, &nod1, &nod2, nn);
    gopcode(OADD, nodconst(v), Z, &nod);
    bitstore(l, &nod, &nod1, &nod2, nn);
    break;
@

<<[[cgenrel()]] switch node kind cases>>=
bitas:
    n = l->left;
    regalloc(&nod, r, nn);
    if(l->complex >= r->complex) {
        reglcgen(&nod1, n, Z);
        cgen(r, &nod);
    } else {
        cgen(r, &nod);
        reglcgen(&nod1, n, Z);
    }
    regalloc(&nod2, n, Z);
    gopcode(OAS, &nod1, Z, &nod2);
    bitstore(l, &nod, &nod1, &nod2, nn);
    break;
@



<<function bitload(arm)>>=
void
bitload(Node *b, Node *n1, Node *n2, Node *n3, Node *nn)
{
    int sh;
    long v;
    Node *l;

    /*
     * n1 gets adjusted/masked value
     * n2 gets address of cell
     * n3 gets contents of cell
     */
    l = b->left;
    if(n2 != Z) {
        regalloc(n1, l, nn);
        reglcgen(n2, l, Z);
        regalloc(n3, l, Z);
        gopcode(OAS, n2, Z, n3);
        gopcode(OAS, n3, Z, n1);
    } else {
        regalloc(n1, l, nn);
        cgen(l, n1);
    }
    if(b->type->shift == 0 && typeu[b->type->etype]) {
        v = ~0 + (1L << b->type->nbits);
        gopcode(OAND, nodconst(v), Z, n1);
    } else {
        sh = 32 - b->type->shift - b->type->nbits;
        if(sh > 0)
            gopcode(OASHL, nodconst(sh), Z, n1);
        sh += b->type->shift;
        if(sh > 0)
            if(typeu[b->type->etype])
                gopcode(OLSHR, nodconst(sh), Z, n1);
            else
                gopcode(OASHR, nodconst(sh), Z, n1);
    }
}
@
% >> >>

<<function bitstore(arm)>>=
void
bitstore(Node *b, Node *n1, Node *n2, Node *n3, Node *nn)
{
    long v;
    Node nod, *l;
    int sh;

    /*
     * n1 has adjusted/masked value
     * n2 has address of cell
     * n3 has contents of cell
     */
    l = b->left;
    regalloc(&nod, l, Z);
    v = ~0 + (1L << b->type->nbits);
    gopcode(OAND, nodconst(v), Z, n1);
    gopcode(OAS, n1, Z, &nod);
    if(nn != Z)
        gopcode(OAS, n1, Z, nn);
    sh = b->type->shift;
    if(sh > 0)
        gopcode(OASHL, nodconst(sh), Z, &nod);
    v <<= sh;
    gopcode(OAND, nodconst(~v), Z, n3);
    gopcode(OOR, n3, Z, &nod);
    gopcode(OAS, &nod, Z, n2);

    regfree(&nod);
    regfree(n1);
    regfree(n2);
    regfree(n3);
}
@
% >> >>







\subsection{Old style prototypes}
% not really an advanced features though


%\subsubsection{Parsing}

%todo: remove?
<<parameter declarator rules>>=
/*
 * parameter declarator
 */
pdecl:
  /* empty */
|   pdecl ctlist pdlist ';'

pdlist:
    xdecor              { dodecl(pdecl, lastclass, lasttype, $1); }
|   pdlist ',' pdlist
@
%$




<<arglist rule>>=
arglist:
    name
@
%less: ONAME, but should not be allowed!

<<[[fnproto1()]] switch node kind cases>>=
case ONAME:
    diag(n, "incomplete argument prototype");
    return typ(TINT, T);
@
% so forbidden?



<<constant OLDPROTO>>=
#define	OLDPROTO	2
@
% 1<<1

<<[[argmark()]] if old proto style>>=
if(pass != 0 && anyproto(n->right) == OLDPROTO) {
    t = typ(TFUNC, n->left->sym->type->link);
    t->down = typ(TOLD, T);
    t->down->down = ofnproto(n->right);
    tmerge(t, n->left->sym);
    n->left->sym->type = t;
}
@


<<[[walkparam()]] when OPROTO case, if no name found and old style decl>>=
dodecl(NODECL, CPARAM, n->type, n->left);
pdecl(CPARAM, lastdcltype, S);
@


<<function ofnproto>>=
Type*
ofnproto(Node *n)
{
    Type *tl, *tr, *t;

    if(n == Z)
        return T;
    switch(n->op) {
    case OLIST:
        tl = ofnproto(n->left);
        tr = ofnproto(n->right);
        if(tl == T)
            return tr;
        tl->down = tr;
        return tl;

    case ONAME:
        t = copytyp(n->sym->type);
        t->down = T;
        return t;
    }
    return T;
}
@
% old fn proto style?


<<constant ANSIPROTO>>=
#define	ANSIPROTO	1
@
%todo: remove, have just ANSIPROTO!

<<[[fnproto()]] old prototype style handling>>=
int r;

r = anyproto(n->right);
if(r == 0 || (r & OLDPROTO)) {
    if(r & ANSIPROTO)
        diag(n, "mixed ansi/old function declaration: %F", n->left);
    return T;
}
@

<<function anyproto>>=
bool
anyproto(Node *n)
{
    int r;

    r = false;

loop:
    if(n == Z)
        return r;
    switch(n->op) {
    case OLIST:
        r |= anyproto(n->left);
        n = n->right;
        goto loop;

    case ODOTDOT:
    case OPROTO:
        return r | ANSIPROTO;
    }
    return r | OLDPROTO;
}
@



%\subsubsection{Code gen}

<<[[walkparam()]] switch op cases>>=
case ONAME:
    s = n->sym;
    if(pass == 0) {
        push1(s);
        s->offset = -1;
        break;
    }
    if(s->offset != -1) {
        if(autoffset == 0) {
            firstarg = s;
            firstargtype = s->type;
        }
        autoffset = align(autoffset, s->type, Aarg1);
        s->offset = autoffset;
        autoffset = align(autoffset, s->type, Aarg2);
    } else
        dodecl(pdecl, CXXX, types[TINT], n);
    break;
@



%\subsubsection{Typing}

<<[[Type_kind_bis]] misc cases>>=
TOLD,
@
% old style ansi declaration?


<<[[rsametype()]] continue if old style type>>=
if(t1->etype == TOLD) {
    t1 = t1->down;
    continue;
}
if(t2->etype == TOLD) {
    t2 = t2->down;
    continue;
}
@



<<[[tmerge()]] switch etype t1 cases>>=
case TFUNC:
    ta = t1->down;
    tb = t2->down;
    if(ta == T) {
        t1->down = tb;
        break;
    }
    if(tb == T)
        break;
    while(ta != T && tb != T) {
        if(ta == tb)
            break;
        /* ignore old-style flag */
        if(ta->etype == TOLD) {
            ta = ta->down;
            continue;
        }
        if(tb->etype == TOLD) {
            tb = tb->down;
            continue;
        }
        /* checking terminated by ... */
        if(ta->etype == TDOT && tb->etype == TDOT) {
            ta = T;
            tb = T;
            break;
        }
        if(!sametype(ta, tb))
            break;
        ta = ta->down;
        tb = tb->down;
    }
    if(ta != tb)
        diag(Z, "function inconsistently declared: %s", s->name);

    /* take new-style over old-style */
    ta = t1->down;
    tb = t2->down;
    if(ta != T && ta->etype == TOLD)
        if(tb != T && tb->etype != TOLD)
            t1->down = tb;
    break;
@

<<[[tcomo()]] when OFUNC case, warn function args not checked if old proto>>=
if(!debug['B'])
    if(l->type->down == T || l->type->down->etype == TOLD) {
        nerrors--;
        diag(n, "function args not checked: %F", l);
    }
@

\subsection{[[_Noreturn()]]}

% in kencc-latest; convenient. otherwise some False positives
% in other checks and forced to write some stupid return.

\section{C extensions}

% see cc/c99.txt for list of things implemented by kencc

\subsection{Typing extensions, [[typeext()]]}

% Mostly for float and unnamed substructure.

% When you assign or compare x to y (via ==, or
% assignment, or return, or by passing argument), 
% 5c may do some automatic conversions.
% typeext() below is a hook for those conversions.

<<[[tcomo()]] when OEQ/ONE, typing extensions>>=
typeext(l->type, r);
typeext(r->type, l);
@
% compare left type with right node, to give opportunity
% to adjust right node type before the call to 
%   tcompat(n, l->type, r->type, trel).
% Then do same for right.

<<[[tcomo()]] when OAS, typing extension>>=
typeext(l->type, r);
@

<<[[tcomo()]] when OASADD, typing extension>>=
typeext(l->type, r);
@

<<[[tcomo()]] when ORETURN, typing extensions>>=
typeext(n->type, l);
@

<<[[tcoma()]] typing extension on argument>>=
typeext(t, n);
@



% | ... -> <>
<<function typeext>>=
void
typeext(Type *st, Node *l)
{
    Type *lt = l->type;
    <<[[typeext()]] other locals>>

    <<[[typeext()]] sanity check lt>>

    <<[[typeext()]] nil pointer>>
    <<[[typeext()]] float handling>>
    <<[[typeext()]] unnamed substructure handling>>
}
@
%old: lt = l->type; after
\l st?? store type?
\t st -> t, l -> n?

<<[[typeext()]] sanity check lt>>=
if(lt == T)
    return;
@
%ocaml: should never happen


<<[[typeext()]] nil pointer>>=
if(st->etype == TIND && vconst(l) == 0) {
    l->type = st;
    l->vconst = 0;
    return;
}
@
%ocaml: forbid! force to use 'nil'

% need that otherwise will get some type error when pass 0
% where they expect a pointer.
% the compatibility policy not enough? just need special case for nil?




\subsection{Unnamed structure elements}
% aka Anonymous field? Poor's man inheritance?

%ex:
% Lock;
%
% I think it also generalizes what regular C allows such as
% struct X {
%   union { ... };
%   struct { ...};
% };
% (but I think C just handles the small sugar when do x->foo, not
%  the general kenccext explained below).
%
% Unnamed struct elements have implications when do x->foo where 5c
% unsugars as x->anon_field.foo.
% This has also implications when you pass as a parameter
% the enclosing struct 'x', which can be automatically converted
% to passing 'x.anon_field' (e.g. Biobuf vs Biobufhdr)


%\subsubsection{Parsing}


<<zedlist rule>>=
zedlist:                    /* extension */
 /* empty */
    {
        lastfield = 0;
        edecl(CXXX, lasttype, S);
    }
|   edlist
@
%ocaml: gensym a fieldname instead


<<[[edecl()]] if unnamed structure element>>=
if(s == S) {
    if(!typesu[t->etype])
        diag(Z, "unnamed structure element must be struct/union");
    if(c != CXXX)
        diag(Z, "unnamed structure element cannot have class");
} 
@
%ocaml: check done later during typecheck as that's when we have
% done the typedef expansion


%\subsubsection{Typing}

% tcomo -> tcomd -> <>
<<[[dotsearch()]] if unnamed substructures>>=
/*
 * look it up in unnamed substructures
 */
for(t1 = t; t1 != T; t1 = t1->down)
    if(t1->sym == S && typesu[t1->etype]){
        // recurse!
        rt = dotsearch(s, t1->link, n, off);
        if(rt != T) {
            if(xt != T)
                goto ambig;
            xt = rt;
            *off += t1->offset;
        }
    }
@
%ocaml: do by unsugaring, add extra RecordAccess?
% but then complicated?

%\subsubsection{Transforming}

<<[[typeext()]] other locals>>=
Node *n1, *n2;
long o;
@
<<[[typeext()]] unnamed substructure handling>>=
/*
 * extension of C
 * if assign of struct containing unnamed sub-struct
 * to type of sub-struct, insert the DOT.
 * if assign of *struct containing unnamed substruct
 * to type of *sub-struct, insert the add-offset
 */
if(typesu[st->etype] && typesu[lt->etype]) {
    o = dotoffset(st, lt, l);
    if(o >= 0) {
        n1 = new1(OXXX, Z, Z);
        *n1 = *l;
        l->op = ODOT;
        l->left = n1;
        l->right = Z;
        makedot(l, st, o);
    }
    return;
}
// else

if(st->etype == TIND && typesu[st->link->etype])
if(lt->etype == TIND && typesu[lt->link->etype]) {
    o = dotoffset(st->link, lt->link, l);
    if(o >= 0) {
        l->type = st;
        if(o == 0)
            return;
        // else
        n1 = new1(OXXX, Z, Z);
        *n1 = *l;
        n2 = new1(OCONST, Z, Z);
        n2->vconst = o;
        n2->type = st;
        l->op = OADD;
        l->left = n1;
        l->right = n2;
    }
    return;
}
@


% typeext -> <>
<<function dotoffset>>=
long
dotoffset(Type *st, Type *lt, Node *n)
{
    Type *t;
    Sym *g;
    long o, o1;

    o = -1;
    /*
     * first try matching at the top level
     * for matching tag names
     */
    g = st->tag;
    if(g != S)
        for(t=lt->link; t!=T; t=t->down)
            if(t->sym == S)
                if(g == t->tag) {
                    if(o >= 0)
                        goto ambig;
                    o = t->offset;
                }
    if(o >= 0)
        return o;

    /*
     * second try matching at the top level
     * for similar types
     */
    for(t=lt->link; t!=T; t=t->down)
        if(t->sym == S)
            if(sametype(st, t)) {
                if(o >= 0)
                    goto ambig;
                o = t->offset;
            }
    if(o >= 0)
        return o;

    /*
     * last try matching sub-levels
     */
    for(t=lt->link; t!=T; t=t->down)
        if(t->sym == S)
        if(typesu[t->etype]) {
            // recurse
            o1 = dotoffset(st, t, n);
            if(o1 >= 0) {
                if(o >= 0)
                    goto ambig;
                o = o1 + t->offset;
            }
        }
    return o;

ambig:
    diag(n, "ambiguous unnamed structure element");
    return o;
}
@



\subsection{Struct constructors}

%\subsubsection{Parsing}

<<expression nodes>>=
OSTRUCT,
OUNION,
@


% kenccext and gccext, struct constructor
<<xuexpr rule>>=
|   '(' tlist abdecor ')' '{' ilist '}' /* extension */
    {
        $$ = new(OSTRUCT, $6, Z);
        dodecl(NODECL, CXXX, $2, $3);
        $$->type = lastdcltype;
    }
@
%$

%\subsubsection{Typing}

<<[[tcomo()]] switch node kind cases>>=
case OSTRUCT:
    if(tcomx(n))
        goto bad;
    break;
@

% structure
<<function tcomx>>=
bool
tcomx(Node *n)
{
    Type *t;
    Node *l, *r, **ar, **al;
    bool e;

    e = false;
    if(n->type->etype != TSTRUCT) {
        diag(n, "constructor must be a structure");
        return true;
    }
    l = invert(n->left);
    n->left = l;
    al = &n->left;
    for(t = n->type->link; t != T; t = t->down) {
        if(l == Z) {
            diag(n, "constructor list too short");
            return true;
        }
        if(l->op == OLIST) {
            r = l->left;
            ar = &l->left;
            al = &l->right;
            l = l->right;
        } else {
            r = l;
            ar = al;
            l = Z;
        }
        if(tcom(r))
            e++;
        typeext(t, r);
        if(tcompat(n, t, r->type, tasign))
            e++;
        constas(n, t, r->type);
        if(!e && !sametype(t, r->type)) {
            r = new1(OCAST, r, Z);
            r->type = t;
            *ar = r;
        }
    }
    if(l != Z) {
        diag(n, "constructor list too long");
        return true;
    }
    return e;
}
@
% hmm e++ -> e = true instead? the count matters?

%\subsubsection{Code generation}

<<[[sugen()]] switch op cases>>=
case OSTRUCT:
    /*
     * rewrite so lhs has no fn call
     */
    if(nn != Z && nn->complex >= FNX) {
        nod1 = *n;
        nod1.type = typ(TIND, n->type);
        regret(&nod2, &nod1);
        lcgen(nn, &nod2);
        regsalloc(&nod0, &nod1);
        gopcode(OAS, &nod2, Z, &nod0);
        regfree(&nod2);

        nod1 = *n;
        nod1.op = OIND;
        nod1.left = &nod0;
        nod1.right = Z;
        nod1.complex = 1;

        sugen(n, &nod1, w);
        return;
    }

    r = n->left;
    for(t = n->type->link; t != T; t = t->down) {
        l = r;
        if(r->op == OLIST) {
            l = r->left;
            r = r->right;
        }
        if(nn == Z) {
            cgen(l, nn);
            continue;
        }
        /*
         * hand craft *(&nn + o) = l
         */
        nod0 = znode;
        nod0.op = OAS;
        nod0.type = t;
        nod0.left = &nod1;
        nod0.right = l;

        nod1 = znode;
        nod1.op = OIND;
        nod1.type = t;
        nod1.left = &nod2;

        nod2 = znode;
        nod2.op = OADD;
        nod2.type = typ(TIND, t);
        nod2.left = &nod3;
        nod2.right = &nod4;

        nod3 = znode;
        nod3.op = OADDR;
        nod3.type = nod2.type;
        nod3.left = nn;

        nod4 = znode;
        nod4.op = OCONST;
        nod4.type = nod2.type;
        nod4.vconst = t->offset;

        ccom(&nod0);
        acom(&nod0);
        xcom(&nod0);
        nod0.addable = 0;

        cgen(&nod0, Z);
    }
    break;
@

\subsection{Per-processor storage, [[extern register]]}
% useful for ARM kernel (bcm/), where mach and up are in registers
%  and so are perfectly local to each processor! per-processor storage

<<[[Storage_class]] cases>>=
CEXREG, // extern register, kenccext (used in kernel for mips)
@

<<[[ginit()]] reg and resvreg initialisation>>=
/* keep two external registers */
reg[REGEXT] = 1; // R10
reg[REGEXT-1] = 1; // R9
@
\t how is it that it uses R9 for registers.c extreme case ???
%starts at R10 not R11 because R11 is used by linker?

%\subsubsection{Parsing}

<<[[simplec()]] cases>>=
case BEXTERN|BREGISTER:
    return CEXREG;
@


<<[[xdecl()]] switch class cases>>=
case CEXREG:
    o = exreg(t);
    if(o == 0)
        class = CEXTERN;
    if(s->class == CGLOBL)
        class = CGLOBL;
    break;
@
\t should warn when no more extern register available

<<global exregoffset>>=
long	exregoffset;
@
% does not look like an offset, more a register number

<<global exfregoffset>>=
long	exfregoffset;
@

<<[[ginit()]] misc initialisations>>=
exregoffset = REGEXT;
exfregoffset = FREGEXT;
@

<<function exreg(arm)>>=
long
exreg(Type *t)
{
    long o;

    if(typechlp[t->etype]) {
        if(exregoffset <= REGEXT-2)
            return 0;

        o = exregoffset;
        if(reg[o] && !resvreg[o])
            return 0;
        resvreg[o] = reg[o] = 1;
        exregoffset--;
        return o;
    }
    if(typefd[t->etype]) {
        if(exfregoffset <= NFREG-1)
            return 0;

        o = exfregoffset + NREG;
        if(reg[o] && !resvreg[o])
            return 0;
        resvreg[o] = reg[o] = 1;
        exfregoffset--;
        return o;
    }
    return 0;
}
@



%\subsubsection{Typing}


<<[[tcomo()]] in ONAME case, if extern register>>=
if(n->class == CEXREG) {
    n->op = OREGISTER;
    <<[[tcomo()]] in ONAME case, if extern register, if x86>>
    n->reg = n->sym->offset;
    n->xoffset = 0;
    break;
}
@


<<[[tcomo()]] when OADDR, check if register>>=
if(l->op == OREGISTER) {
    diag(n, "address of a register");
    goto bad;
}
@

%\subsubsection{Code generation}
% use general case of OREGISTER



\subsection{Type reflection, [[typestr()]]}
% a form of reflection too?
% seems dead. Never used, not documented.

%\subsubsection{Parsing}

<<[[itab]] entries, kencc extensions>>=
"typestr",	LTYPESTR,	0,
@

<<token declarations>>=
%token  LTYPESTR
@


<<cname rule>>=
|   LTYPESTR  { $$ = BTYPESTR; }
@

<<[[Bxxx]] cases>>=
BTYPESTR	= 1L<<TTYPESTR,
@

<<[[Type_kind_bis]] storage cases>>=
TTYPESTR,
@

<<[[Storage_class]] cases>>=
CTYPESTR,
@

<<[[simplec()]] cases>>=
case BTYPESTR:
    return CTYPESTR;
@

<<[[xdecl()]] switch class cases>>=
case CTYPESTR:
    if(!typesuv[t->etype]) {
        diag(Z, "typestr must be struct/union: %s", s->name);
        break;
    }
    dclfunct(t, s);
    break;
@
%bug? actually should be !typesu, not typesuv no?


% dodecl(xdecl, ...) ->  <>
<<function dclfunct>>=
void
dclfunct(Type *t, Sym *s)
{
    Funct *f;
    Node *n;
    Type *f1, *f2, *f3, *f4;
    int o, i, c;
    char str[100];

    if(t->funct)
        return;

    // recognize generated tag of dorm _%d_
    if(t->tag == S)
        goto bad;
    for(i=0; c = t->tag->name[i]; i++) {
        if(c == '_') {
            if(i == 0 || t->tag->name[i+1] == 0)
                continue;
            break;
        }
        if(c < '0' || c > '9')
            break;
    }
    if(c == 0)
        goto bad;

    f = alloc(sizeof(*f));
    for(o=0; o<sizeof(f->sym); o++) // bugfix?nelem(f->sym) in latest plan9
        f->sym[o] = S;

    t->funct = f;

    f1 = typ(TFUNC, t);
    f1->down = copytyp(t);
    f1->down->down = t;

    f2 = typ(TFUNC, types[TINT]);
    f2->down = copytyp(t);
    f2->down->down = t;

    f3 = typ(TFUNC, t);
    f3->down = typ(TIND, t);
    f3->down->down = t;

    f4 = typ(TFUNC, t);
    f4->down = t;

    for(i=0;; i++) {
        o = ftabinit[i].op;
        if(o == OXXX)
            break;
        sprint(str, "%s_%s_", t->tag->name, ftabinit[i].name);
        n = new(ONAME, Z, Z);
        n->sym = slookup(str);
        f->sym[o] = n->sym;

        switch(ftabinit[i].typ) {

        case 1:	// T f(T,T)	+
            dodecl(xdecl, CEXTERN, f1, n);
            break;

        case 2:	// int f(T,T)	==
            dodecl(xdecl, CEXTERN, f2, n);
            break;

        case 3:	// void f(T*,T)	+=
            dodecl(xdecl, CEXTERN, f3, n);
            break;

        case 4:	// T f(T)	~
            dodecl(xdecl, CEXTERN, f4, n);
            break;

        default:
            diag(Z, "dclfunct op missing %d\n", ftabinit[i].typ);
            break;
        }
    }
    for(i=0;; i++) {
        o = gtabinit[i].etype;
        if(o == TXXX)
            break;

        /*
         * OCAST types T1 _T2_T1_(T2)
         */
        sprint(str, "_%s%s_", gtabinit[i].name, t->tag->name);
        n = new(ONAME, Z, Z);
        n->sym = slookup(str);
        f->castto[o] = n->sym;

        f1 = typ(TFUNC, t);
        f1->down = types[o];
        dodecl(xdecl, CEXTERN, f1, n);

        sprint(str, "%s_%s_", t->tag->name, gtabinit[i].name);
        n = new(ONAME, Z, Z);
        n->sym = slookup(str);
        f->castfr[o] = n->sym;

        f1 = typ(TFUNC, types[o]);
        f1->down = t;
        dodecl(xdecl, CEXTERN, f1, n);
    }
    return;
bad:
    diag(Z, "dclfunct bad %T %s\n", t, s->name);
}
@


% why not use Init?
<<struct Ftab>>=
struct	Ftab
{
    char	op;
    char*	name;
    char	typ;
};
@

% why not use Init?
<<struct Gtab>>=
struct	Gtab
{
    char	etype;
    char*	name;
};
@

<<global gtabinit>>=
Gtab	gtabinit[NTYPE] =
{
    TCHAR,		"c",
    TUCHAR,		"uc",
    TSHORT,		"h",
    TUSHORT,	"uh",
    TINT,		"i",
    TUINT,		"ui",
    TLONG,		"l",
    TULONG,		"ul",
    TVLONG,		"v",
    TUVLONG,	"uv",
    TFLOAT,		"f",
    TDOUBLE,	"d",

    TXXX
};
@

<<global ftabinit>>=
Ftab	ftabinit[OEND] =
{
    OADD,		"add",		1,
    OAND,		"and",		1,
    OASHL,		"ashl",		1,
    OASHR,		"ashr",		1,
    ODIV,		"div",		1,
    OLDIV,		"ldiv",		1,
    OLMOD,		"lmod",		1,
    OLMUL,		"lmul",		1,
    OLSHR,		"lshr",		1,
    OMOD,		"mod",		1,
    OMUL,		"mul",		1,
    OOR,		"or",		1,
    OSUB,		"sub",		1,
    OXOR,		"xor",		1,

    OEQ,		"eq",		2,
    OGE,		"ge",		2,
    OGT,		"gt",		2,
    OHI,		"hi",		2,
    OHS,		"hs",		2,
    OLE,		"le",		2,
    OLO,		"lo",		2,
    OLS,		"ls",		2,
    OLT,		"lt",		2,
    ONE,		"ne",		2,

    OASADD,		"asadd",	3,
    OASAND,		"asand",	3,
    OASASHL,	"asashl",	3,
    OASASHR,	"asashr",	3,
    OASDIV,		"asdiv",	3,
    OASLDIV,	"asldiv",	3,
    OASLMOD,	"aslmod",	3,
    OASLMUL,	"aslmul",	3,
    OASLSHR,	"aslshr",	3,
    OASMOD,		"asmod",	3,
    OASMUL,		"asmul",	3,
    OASOR,		"asor",		3,
    OASSUB,		"assub",	3,
    OASXOR,		"asxor",	3,

    OPOS,		"pos",		4,
    ONEG,		"neg",		4,
    OCOM,		"com",		4,
    ONOT,		"not",		4,

//	OPOSTDEC,
//	OPOSTINC,
//	OPREDEC,
//	OPREINC,

    OXXX,
};
@




%\subsection{[[isfunct()]]}

<<[[tcomo()]] break if isfunct>>=
if(isfunct(n))
    break;
@


<<[[Type]] other fields>>=
Funct*	funct;
@
% ????

<<struct Funct>>=
struct	Funct
{
    Sym*	sym[OEND];
    Sym*	castto[NTYPE];
    Sym*	castfr[NTYPE];
};
@


<<function isfunct>>=
bool
isfunct(Node *n)
{
    Type *t, *t1;
    Funct *f;
    Node *l;
    Sym *s;
    int o;

    o = n->op;
    if(n->left == Z)
        goto no;
    t = n->left->type;
    if(t == T)
        goto no;
    f = t->funct;

    switch(o) {
    case OAS:	// put cast on rhs
    case OASI:
    case OASADD:
    case OASSUB:
    case OASMUL:
    case OASDIV:
    case OASMOD:
    case OASASHR:
    case OASLMUL:
    case OASLDIV:
    case OASLMOD:
    case OASLSHR:
    case OASASHL:
    case OASAND:
    case OASOR:
    case OASXOR:
        if(n->right == Z)
            goto no;
        t1 = n->right->type;
        if(t1 == T)
            goto no;
        if(t1->funct == f)
            break;

        l = new(OXXX, Z, Z);
        *l = *n->right;

        n->right->left = l;
        n->right->right = Z;
        n->right->type = t;
        n->right->op = OCAST;

        if(!isfunct(n->right))
            prtree(n, "isfunc !");
        break;

    case OCAST:	// t f(T) or T f(t)
        t1 = n->type;
        if(t1 == T)
            goto no;
        if(f != nil) {
            s = f->castfr[t1->etype];
            if(s == S)
                goto no;
            n->right = n->left;
            goto build;
        }
        f = t1->funct;
        if(f != nil) {
            s = f->castto[t->etype];
            if(s == S)
                goto no;
            n->right = n->left;
            goto build;
        }
        goto no;
    }

    if(f == nil)
        goto no;
    s = f->sym[o];
    if(s == S)
        goto no;



    /*
     * the answer is yes,
     * now we rewrite the node
     * and give diagnostics
     */
    switch(o) {
    case OADD:	// T f(T, T)
    case OAND:
    case OASHL:
    case OASHR:
    case ODIV:
    case OLDIV:
    case OLMOD:
    case OLMUL:
    case OLSHR:
    case OMOD:
    case OMUL:
    case OOR:
    case OSUB:
    case OXOR:

    case OEQ:	// int f(T, T)
    case OGE:
    case OGT:
    case OHI:
    case OHS:
    case OLE:
    case OLO:
    case OLS:
    case OLT:
    case ONE:
        if(n->right == Z)
            goto bad;
        t1 = n->right->type;
        if(t1 == T)
            goto bad;
        if(t1->funct != f)
            goto bad;
        n->right = new(OLIST, n->left, n->right);
        break;

    case OAS:	// structure copies done by the compiler
    case OASI:
        goto no;

    case OASADD:	// T f(T*, T)
    case OASAND:
    case OASASHL:
    case OASASHR:
    case OASDIV:
    case OASLDIV:
    case OASLMOD:
    case OASLMUL:
    case OASLSHR:
    case OASMOD:
    case OASMUL:
    case OASOR:
    case OASSUB:
    case OASXOR:
        if(n->right == Z)
            goto bad;
        t1 = n->right->type;
        if(t1 == T)
            goto bad;
        if(t1->funct != f)
            goto bad;
        n->right = new(OLIST, new(OADDR, n->left, Z), n->right);
        break;

    case OPOS:	// T f(T)
    case ONEG:
    case ONOT:
    case OCOM:
        n->right = n->left;
        break;

    default:
        diag(n, "isfunct op missing %O\n", o);
        goto bad;


    }

build:
    l = new(ONAME, Z, Z);
    l->sym = s;
    l->type = s->type;
    l->etype = s->type->etype;
    l->xoffset = s->offset;
    l->class = s->class;
    tcomo(l, 0);

    n->op = OFUNC;
    n->left = l;
    n->type = l->type->link;
    if(tcompat(n, T, l->type, tfunct))
        goto bad;
    if(tcoma(n->left, n->right, l->type->down, true))
        goto bad;
    return true;

no:
    return false;

bad:
    diag(n, "cant rewrite typestr for op %O\n", o);
    prtree(n, "isfunct");
    n->type = T;
    return true;
}
@




\subsection{Signature reflection, [[signof()]]}
% sign for signature, not sign of an operation

<<expression nodes>>=
OSIGN,
@

%\subsubsection{Parsing}

<<token declarations>>=
%token  LSIGNOF
@
<<[[itab]] entries, kencc extensions>>=
"signof",	LSIGNOF,	0,
@

<<uexpr rule>>=
|   LSIGNOF uexpr { $$ = new(OSIGN, $2, Z); }
@
%$

<<pexpr rule>>=
|   LSIGNOF '(' tlist abdecor ')'
    {
        $$ = new(OSIGN, Z, Z);
        dodecl(NODECL, CXXX, $3, $4);
        $$->type = lastdcltype;
    }
@

%\subsubsection{Typing and rewriting}

<<[[tcomo()]] switch node kind cases>>=
case OSIGN:	/* extension signof(type) returns a hash */
    if(l != Z) {
        if(l->op != OSTRING && l->op != OLSTRING)
            if(tcomo(l, 0))
                goto bad;
        <<[[tcomo()]] when OSIGN, sanity check no bitfield>>
        n->type = l->type;
    }
    <<[[tcomo()]] when OSIGN, typecheck and sanity check>>
    n->op = OCONST;
    n->left = Z;
    n->right = Z;
    n->vconst = convvtox(signature(n->type), TULONG);
    n->type = types[TULONG];
    break;
@


<<[[tcomo()]] when OSIGN, sanity check no bitfield>>=
if(l->op == OBIT) {
    diag(n, "signof bitfield");
    goto bad;
}
@

<<[[tcomo()]] when OSIGN, typecheck and sanity check>>=
if(n->type == T)
    goto bad;
if(n->type->width < 0) {
    diag(n, "signof undefined type");
    goto bad;
}
@




\subsection{Format's arguments checking}

<<enum fxxx>>=
enum fxxx
{
    Fnone	= 0,

    Fl,
    Fvl,
    Fignor,
    Fstar,
    Fadj,

    Fverb	= 10,
};
@

<<struct Tprot>>=
struct	Tprot
{
    Type*	type;
    Bits	flag;
    Tprot*	link;
};
@

<<struct Tname>>=
struct	Tname
{
    char*	name;
    int		param;
    Tname*	link;
};
@

<<global indchar>>=
static	Type*	indchar;
@

<<global flagbits>>=
static	uchar	flagbits[512];
@

<<global fmtbuf>>=
static	char	fmtbuf[100];
@

<<global lastadj>>=
static	int	lastadj;
@

<<global lastverb>>=
static	int	lastverb;
@

<<global nstar>>=
static	int	nstar;
@

<<global tprot>>=
static	Tprot*	tprot;
@

<<global tname>>=
static	Tname*	tname;
@

<<function argflag>>=
void
argflag(int c, int v)
{

    switch(v) {
    case Fignor:
    case Fstar:
    case Fl:
    case Fvl:
        flagbits[c] = v;
        break;
    case Fverb:
        flagbits[c] = lastverb;
/*print("flag-v %c %d\n", c, lastadj);*/
        lastverb++;
        break;
    case Fadj:
        flagbits[c] = lastadj;
/*print("flag-l %c %d\n", c, lastadj);*/
        lastadj++;
        break;
    }
}
@

<<function getflag>>=
Bits
getflag(char *s)
{
    Bits flag;
    int f;
    char *fmt;
    Rune c;

    fmt = fmtbuf;
    flag = zbits;
    nstar = 0;
    for(;;) {
        s += chartorune(&c, s);
        fmt += runetochar(fmt, &c);
        if(c == 0 || c >= nelem(flagbits))
            break;
        f = flagbits[c];
        switch(f) {
        case Fnone:
            argflag(c, Fverb);
            f = flagbits[c];
            break;
        case Fstar:
            nstar++;
        case Fignor:
            continue;
        case Fl:
            if(bset(flag, Fl))
                flag = bor(flag, blsh(Fvl));
        }
        flag = bor(flag, blsh(f));
        if(f >= Fverb)
            break;
    }
    *fmt = 0;
    return flag;
}
@


<<function arginit>>=
void
arginit(void)
{
    int i;

/* debug['F'] = 1;*/
/* debug['w'] = 1;*/

    lastadj = Fadj;
    lastverb = Fverb;
    indchar = typ(TIND, types[TCHAR]);

    memset(flagbits, Fnone, sizeof(flagbits));

    for(i='0'; i<='9'; i++)
        argflag(i, Fignor);
    argflag('.', Fignor);
    argflag('#', Fignor);
    argflag('u', Fignor);
    argflag('h', Fignor);
    argflag('+', Fignor);
    argflag('-', Fignor);

    argflag('*', Fstar);
    argflag('l', Fl);

    argflag('o', Fverb);
    flagbits['x'] = flagbits['o'];
    flagbits['X'] = flagbits['o'];
}
@


<<function nextarg>>=
Node*
nextarg(Node *n, Node **a)
{
    if(n == Z) {
        *a = Z;
        return Z;
    }
    if(n->op == OLIST) {
        *a = n->left;
        return n->right;
    }
    *a = n;
    return Z;
}
@

<<function checkargs>>=
void
checkargs(Node *nn, char *s, int pos)
{
    Node *a, *n;
    Bits flag;
    Tprot *l;

    if(!debug['F'])
        return;
    n = nn;
    for(;;) {
        s = strchr(s, '%');
        if(s == 0) {
            nextarg(n, &a);
            if(a != Z)
                warn(nn, "more arguments than format %T",
                    a->type);
            return;
        }
        s++;
        flag = getflag(s);
        while(nstar > 0) {
            n = nextarg(n, &a);
            pos++;
            nstar--;
            if(a == Z) {
                warn(nn, "more format than arguments %s",
                    fmtbuf);
                return;
            }
            if(a->type == T)
                continue;
            if(!sametype(types[TINT], a->type) &&
               !sametype(types[TUINT], a->type))
                warn(nn, "format mismatch '*' in %s %T, arg %d",
                    fmtbuf, a->type, pos);
        }
        for(l=tprot; l; l=l->link)
            if(sametype(types[TVOID], l->type)) {
                if(beq(flag, l->flag)) {
                    s++;
                    goto loop;
                }
            }

        n = nextarg(n, &a);
        pos++;
        if(a == Z) {
            warn(nn, "more format than arguments %s",
                fmtbuf);
            return;
        }
        if(a->type == 0)
            continue;
        for(l=tprot; l; l=l->link)
            if(sametype(a->type, l->type)) {
/*print("checking %T/%ulx %T/%ulx\n", a->type, flag.b[0], l->type, l->flag.b[0]);*/
                if(beq(flag, l->flag))
                    goto loop;
            }
        warn(nn, "format mismatch %s %T, arg %d", fmtbuf, a->type, pos);
    loop:;
    }
}
@

<<[[tcomo()]] when OFUNC case, format check>>=
dpcheck(n);
@


<<function dpcheck>>=
void
dpcheck(Node *n)
{
    char *s;
    Node *a, *b;
    Tname *l;
    int i;

    if(n == Z)
        return;
    b = n->left;
    if(b == Z || b->op != ONAME)
        return;
    s = b->sym->name;
    for(l=tname; l; l=l->link)
        if(strcmp(s, l->name) == 0)
            break;
    if(l == 0)
        return;

    i = l->param;
    b = n->right;
    while(i > 0) {
        b = nextarg(b, &a);
        i--;
    }
    if(a == Z) {
        warn(n, "cant find format arg");
        return;
    }
    if(!sametype(indchar, a->type)) {
        warn(n, "format arg type %T", a->type);
        return;
    }
    if(a->op != OADDR || a->left->op != ONAME || a->left->sym != symstring) {
/*		warn(n, "format arg not constant string");*/
        return;
    }
    s = a->left->cstring;
    checkargs(b, s, l->param);
}
@



\subsubsection{[[#pragma varargck xxx]]}

<<[[macprag()]] if pragma xxx>>=
if(s && strcmp(s->name, "varargck") == 0) {
    pragvararg();
    return;
}
@

<<function pragvararg>>=
void
pragvararg(void)
{
    Sym *s;
    int n, c;
    char *t;
    Rune r;
    Type *ty;

    if(!debug['F'])
        goto out;

    s = getsym();
    if(s && strcmp(s->name, "argpos") == 0)
        goto ckpos;
    if(s && strcmp(s->name, "type") == 0)
        goto cktype;
    if(s && strcmp(s->name, "flag") == 0)
        goto ckflag;
    yyerror("syntax in #pragma varargck");
    goto out;

ckpos:
/*#pragma	varargck	argpos	warn	2*/
    s = getsym();
    if(s == S)
        goto bad;
    n = getnsn();
    if(n < 0)
        goto bad;
    newname(s->name, n);
    goto out;

ckflag:
/*#pragma	varargck	flag	'c'*/
    c = getnsc();
    if(c != '\'')
        goto bad;
    c = getr();
    if(c == '\\')
        c = getr();
    else if(c == '\'')
        goto bad;
    if(c == '\n')
        goto bad;
    if(getc() != '\'')
        goto bad;
    argflag(c, Fignor);
    goto out;

cktype:
/*#pragma	varargck	type	O	int*/
    c = getnsc();
    if(c != '"')
        goto bad;
    t = fmtbuf;
    for(;;) {
        r = getr();
        if(r == ' ' || r == '\n')
            goto bad;
        if(r == '"')
            break;
        t += runetochar(t, &r);
    }
    *t = 0;
    t = strdup(fmtbuf);
    s = getsym();
    if(s == S)
        goto bad;
    ty = s->type;
    while((c = getnsc()) == '*')
        ty = typ(TIND, ty);
    unget(c);
    newprot(s, ty, t);
    goto out;

bad:
    yyerror("syntax in #pragma varargck");

out:
    while(getnsc() != '\n')
        ;
}
@

<<function newname>>=
void
newname(char *s, int p)
{
    Tname *l;

    for(l=tname; l; l=l->link)
        if(strcmp(l->name, s) == 0) {
            if(l->param != p)
                yyerror("vargck %s already defined\n", s);
            return;
        }
    l = alloc(sizeof(*l));
    l->name = s;
    l->param = p;
    l->link = tname;
    tname = l;
}
@

<<function newprot>>=
void
newprot(Sym *m, Type *t, char *s)
{
    Bits flag;
    Tprot *l;

    if(t == T) {
        warn(Z, "%s: newprot: type not defined", m->name);
        return;
    }
    flag = getflag(s);
    for(l=tprot; l; l=l->link)
        if(beq(flag, l->flag) && sametype(t, l->type))
            return;
    l = alloc(sizeof(*l));
    l->type = t;
    l->flag = flag;
    l->link = tprot;
    tprot = l;
}
@



\section{Floats}

%\subsubsection{Parsing}
% I left code to deal with float in Lexing and parsing chapter.
% I aspecitized typing code and code generation.

%\subsubsection{Typing}

<<[[typeext()]] float handling>>=
typeext1(st, l);
@

<<[[tcomo()]] when OASMUL/OASDIV, typing extensions>>=
typeext1(l->type, r);
@
% call directly typeext1 because know not structure related?

<<[[tcomo()]] when OLT/OGE/OGT/OLE, typing extensions>>=
typeext1(l->type, r);
typeext1(r->type, l);
@


<<function typeext1>>=
void
typeext1(Type *st, Node *l)
{
    if(st->etype == TFLOAT && allfloat(l, false))
        allfloat(l, true);
}
@

<<function allfloat>>=
/*
 * look into tree for floating point constant expressions
 */
bool
allfloat(Node *n, bool flag)
{

    if(n != Z) {
        if(n->type->etype != TDOUBLE)
            return true;
        switch(n->op) {
        case OCONST:
            if(flag)
                n->type = types[TFLOAT];
            return true;
        case OADD:	/* no need to get more exotic than this */
        case OSUB:
        case OMUL:
        case ODIV:
            if(!allfloat(n->right, flag))
                break;
        case OCAST:
            if(!allfloat(n->left, flag))
                break;
            if(flag)
                n->type = types[TFLOAT];
            return true;
        }
    }
    return false;
}
@


%\subsubsection{Code generation}

<<[[gopcode()]] when OADD, adjust a if float type>>=
if(et == TFLOAT)
    a = AADDF;
else
if(et == TDOUBLE || et == TVLONG)
    a = AADDD;
@

<<[[gopcode()]] when OSUB, adjust a if float type>>=
if(et == TFLOAT)
    a = ASUBF;
else
if(et == TDOUBLE || et == TVLONG)
    a = ASUBD;
@
<<[[gopcode()]] when OMUL, adjust a if float type>>=
if(et == TFLOAT)
    a = AMULF;
else
if(et == TDOUBLE || et == TVLONG)
    a = AMULD;
@
<<[[gopcode()]] when ODIV, adjust a if float type>>=
if(et == TFLOAT)
    a = ADIVF;
else
if(et == TDOUBLE || et == TVLONG)
    a = ADIVD;
@


<<[[naddr()]] if float type>>=
if(typefd[n->type->etype]) {
    a->type = D_FCONST;
    a->dval = n->fconst;
} 
@

<<[[naddr()]] if float register, adjust a>>=
if(a->reg >= NREG) {
    a->type = D_FREG;
    a->reg -= NREG;
}
@


<<[[regret()]] if float expression, adjust return register>>=
if(typefd[nn->type->etype])
    r = FREGRET+NREG;
@

<<global fconstnode>>=
Node	fconstnode;
@

<<[[ginit()]] special nodes initialisation>>=
fconstnode.op = OCONST;
fconstnode.class = CXXX;
fconstnode.complex = 0;
fconstnode.addable = 20;
fconstnode.type = types[TDOUBLE];
@


<<function nodfconst>>=
Node*
nodfconst(double d)
{
    fconstnode.fconst = d;
    return &fconstnode;
}
@



<<function ieeedtod>>=
void
ieeedtod(Ieee *ieee, double native)
{
    double fr, ho, f;
    int exp;

    if(native < 0) {
        ieeedtod(ieee, -native);
        ieee->h |= 0x80000000L;
        return;
    }
    if(native == 0) {
        ieee->l = 0;
        ieee->h = 0;
        return;
    }
    fr = frexp(native, &exp);
    f = 2097152L;		/* shouldnt use fp constants here */
    fr = modf(fr*f, &ho);
    ieee->h = ho;
    ieee->h &= 0xfffffL;
    ieee->h |= (exp+1022L) << 20;
    f = 65536L;
    fr = modf(fr*f, &ho);
    ieee->l = ho;
    ieee->l <<= 16;
    ieee->l |= (long)(fr*f);
}
@






<<[[gclean()]] sanity check reg>>=
for(i=NREG; i<NREG+NFREG; i++)
    if(reg[i] && !resvreg[i])
        diag(Z, "freg %d left allocated", i-NREG);
@


%<<constant R0ISZERO(arm)>>=
%#define	R0ISZERO	0
%@
%% was false so I removed the code
% in raddr():
%    if(R0ISZERO && a.type == D_CONST && a.offset == 0) {
%        a.type = D_REG;
%        a.reg = 0;
%    }

% gmove -> <>
<<function raddr(arm)>>=
void
raddr(Node *n, Prog *p)
{
    Adr a;

    naddr(n, &a);
    if(a.type != D_REG && a.type != D_FREG) {
        if(n)
            diag(n, "bad in raddr: %O", n->op);
        else
            diag(n, "bad in raddr: <null>");
        p->reg = R_NONE;
    } else
        p->reg = a.reg;
}
@



<<[[gmove()]] switch from type cases>>=
case TDOUBLE:
case TVLONG:
case TFLOAT:
    switch(tt) {
    case TDOUBLE:
    case TVLONG:
        a = AMOVD;
        if(ft == TFLOAT)
            a = AMOVFD;
        break;
    case TFLOAT:
        a = AMOVDF;
        if(ft == TFLOAT)
            a = AMOVF;
        break;
    case TINT:
    case TUINT:
    case TLONG:
    case TULONG:
    case TIND:
        a = AMOVDW;
        if(ft == TFLOAT)
            a = AMOVFW;
        break;
    case TSHORT:
    case TUSHORT:
    case TCHAR:
    case TUCHAR:
        a = AMOVDW;
        if(ft == TFLOAT)
            a = AMOVFW;
        break;
    }
    break;
@

<<[[gmove()]] switch from type cases, TUINT/TULONG case, if float target>>=
if(tt == TFLOAT || tt == TDOUBLE) {
    // ugly and probably longer than necessary,
    // but vfp has a single instruction for this,
    // so hopefully it won't last long.
    //
    //	tmp = f
    //	tmp1 = tmp & 0x80000000
    //	tmp ^= tmp1
    //	t = float(int32(tmp))
    //	if(tmp1)
    //		t += 2147483648.
    //
    regalloc(&nod, f, Z);
    regalloc(&nod1, f, Z);
    gins(AMOVW, f, &nod);
    gins(AMOVW, &nod, &nod1);
    gins(AAND, nodconst(0x80000000), &nod1);
    gins(AEOR, &nod1, &nod);
    if(tt == TFLOAT)
        gins(AMOVWF, &nod, t);
    else
        gins(AMOVWD, &nod, t);
    gins(ACMP, nodconst(0), Z);
    raddr(&nod1, p);
    gins(ABEQ, Z, Z);
    regfree(&nod);
    regfree(&nod1);
    p1 = p;
    regalloc(&nod, t, Z);
    if(tt == TFLOAT) {
        gins(AMOVF, nodfconst(2147483648.), &nod);
        gins(AADDF, &nod, t);
    } else {
        gins(AMOVD, nodfconst(2147483648.), &nod);
        gins(AADDD, &nod, t);
    }
    regfree(&nod);
    patch(p1, pc);
    return;
}
@

<<[[gmove()]] switch from type cases, TINT/TLONG case, if float target>>=
case TDOUBLE:
    gins(AMOVWD, f, t);
    return;
case TFLOAT:
    gins(AMOVWF, f, t);
    return;
@


<<[[gmove()]] switch from type cases, TSHORT case, if float target>>=
case TDOUBLE:
    regalloc(&nod, f, Z);
    gins(AMOVH, f, &nod);
    gins(AMOVWD, &nod, t);
    regfree(&nod);
    return;
case TFLOAT:
    regalloc(&nod, f, Z);
    gins(AMOVH, f, &nod);
    gins(AMOVWF, &nod, t);
    regfree(&nod);
    return;
@

<<[[gmove()]] switch from type cases, TUSHORT case, if float target>>=
case TDOUBLE:
    regalloc(&nod, f, Z);
    gins(AMOVHU, f, &nod);
    gins(AMOVWD, &nod, t);
    regfree(&nod);
    return;
case TFLOAT:
    regalloc(&nod, f, Z);
    gins(AMOVHU, f, &nod);
    gins(AMOVWF, &nod, t);
    regfree(&nod);
    return;
@

<<[[gmove()]] switch from type cases, TCHAR case, if float target>>=
case TDOUBLE:
    regalloc(&nod, f, Z);
    gins(AMOVB, f, &nod);
    gins(AMOVWD, &nod, t);
    regfree(&nod);
    return;
case TFLOAT:
    regalloc(&nod, f, Z);
    gins(AMOVB, f, &nod);
    gins(AMOVWF, &nod, t);
    regfree(&nod);
    return;
@

<<[[gmove()]] switch from type cases, TUCHAR case, if float target>>=
case TDOUBLE:
    regalloc(&nod, f, Z);
    gins(AMOVBU, f, &nod);
    gins(AMOVWD, &nod, t);
    regfree(&nod);
    return;
case TFLOAT:
    regalloc(&nod, f, Z);
    gins(AMOVBU, f, &nod);
    gins(AMOVWF, &nod, t);
    regfree(&nod);
    return;
@


<<[[regalloc()]] switch tn type, float or vlong case>>=
case TFLOAT:
case TDOUBLE:

case TVLONG:
    if(o != Z && o->op == OREGISTER) {
        i = o->reg;
        if(i >= NREG && i < NREG+NFREG)
            goto out;
    }
    j = 0*2 + NREG;
    for(i=NREG; i<NREG+NFREG; i++) {
        if(j >= NREG+NFREG)
            j = NREG;
        if(reg[j] == 0) {
            i = j;
            goto out;
        }
        j++;
    }
    diag(tn, "out of float registers");
    goto err;
@

\section{Big values}
\n called complex below, but not a mathematic concept
\n it is a compiler concept meaning a big value.


% 5c allows vlong, big structure. Can return such thing, but does not
% fit in R0! more than 32 bits. So How?

\subsection{Complex types}

% set of complex types
<<global typecmplx>>=
// set<type_kind>
char*	typecmplx;
@
% alias. typesuv used in another context?

<<[[tinit()]] initialise 32 bits defaults type sets>>=
typecmplx = typesuv;
@

% struct, union, vlong

<<global typesuv>>=
char	typesuv[NTYPE];
@

<<global typesuvinit>>=
int	typesuvinit[] =
{
    TVLONG, TUVLONG, TSTRUCT, TUNION, -1,
};
@
% suv is for arguments or return values that are too big to
% reside in REGRET in which case it needs some special handling


% things that can not be stored in REGRET! things that takes more
% than 32 bits, for instance a big structure (not a pointer to a struct,
% the struct itself).

\subsection{Complex return value}

% set in codegen
<<global nodret>>=
Node*	nodret;
@

<<[[ginit()]] special nodes initialisation>>=
nodret = new(ONAME, Z, Z);
nodret->sym = slookup(".ret");
nodret->type = types[TIND];
nodret->etype = TIND;
nodret->class = CPARAM;
nodret = new(OIND, nodret, Z);
complex(nodret);
@
% *<.ret>
% CPARAM? rewrite function to have an extra OUT param! :)
% hmm but added somewhere in the list of parameters? just
% CPARAM is enough?



%codgen is for function body code generation
<<[[codgen()]] if complex return type>>=
if(typecmplx[thisfntype->link->etype]) {
    n1 = nodret->left;
    if(n1->type == T || n1->type->link != thisfntype->link) {
        n1->type = typ(TIND, thisfntype->link);
        n1->etype = n1->type->etype; // TIND, dead instruction
        nodret = new(OIND, n1, Z); // useful? to force retyping?
        complex(nodret);
    }
}
@
%old: this is done in ginit() no? redundant? nodret can never be null no?
%    if(nodret == nil) {
%        nodret = new(ONAME, Z, Z);
%        nodret->sym = slookup(".ret");
%        nodret->class = CPARAM;
%        nodret->type = types[TIND];
%        nodret->etype = TIND;
%        nodret = new(OIND, nodret, Z);
%    }





% // *ret = X; RET
<<[[gen()]] case ORETURN, if complex type>>=
if(typecmplx[n->type->etype]) {
    nod = znode;
    nod.op = OAS;
    nod.left = nodret;
    nod.right = l;
    nod.type = n->type;
    nod.complex = l->complex;
    cgen(&nod, Z);
    noretval(1 | 2);
    gbranch(ORETURN);
    break;
}
@


% why talk about return type when it's REGARG?
<<[[codegen()]] if use REGARG, if complex return type>>=
if(typecmplx[thisfntype->link->etype]) {
    nod1 = *nodret->left;
    nodreg(&nod, &nod1, REGARG);
    gmove(&nod, &nod1);
}
@

\subsection{Complex argument}

% why not use typecmplx here?

<<[[garg1()]] if complex argument type>>=
if(typesuv[n->type->etype]) {
    regaalloc(tn2, n);
    if(n->complex >= FNX) {
        sugen(*fnxp, tn2, n->type->width);
        (*fnxp)++;
    } else
        sugen(n, tn2, n->type->width);
}
@
\l why not use typecmplx here??


\subsection{Complex expression}

% why not use typecmplx here?

<<[[cgenrel()]] if complex type node>>=
if(typesuv[n->type->etype]) {
    sugen(n, nn, n->type->width);
}
@

\subsection{[[vlong]] constant}

%\subsection{[[vlong]] management}

%<<global newvlongcode>>=
%bool	newvlongcode;
%@
%seems dead, never set to true or valid in other archi?
% in Gen for RETURN case:
%    if(newvlongcode && !typefd[n->type->etype]){
%        regret(&rn, n);
%        regfree(&rn);
%        nod = znode;
%        nod.op = OAS;
%        nod.left = &rn;
%        nod.right = l;
%        nod.type = n->type;
%        nod.complex = l->complex;
%        cgen(&nod, Z);
%        noretval(2);
%        gbranch(ORETURN);
%        break;
%    }


%aspectize?
<<[[gextern()]] if OCONST and a vlong type>>=
if(a->op == OCONST && typev[a->type->etype]) {
    if(align(0, types[TCHAR], Aarg1))	/* isbigendian */
        gpseudo(ADATA, s, nod32const(a->vconst>>32));
    else
        gpseudo(ADATA, s, nod32const(a->vconst));
    p->from.offset += o;
    p->reg = 4;
    if(align(0, types[TCHAR], Aarg1))	/* isbigendian */
        gpseudo(ADATA, s, nod32const(a->vconst));
    else
        gpseudo(ADATA, s, nod32const(a->vconst>>32));
    p->from.offset += o + 4;
    p->reg = 4;
}
@
% 4 -> ??

<<function nod32const(arm)>>=
Node*
nod32const(vlong v)
{
    constnode.vconst = v & MASK(32);
    return &constnode;
}
@



\section{64 bits operations}

% related to complex values

%\subsection{[[cc/com64.c]]}
% portable part, cc/com64.c
% vlong is 64 bits, so how do on 32 bits?
% do via builtins _xxxv, e.g. _addv, _mulv in lib_core/libc/xxx/vlop.c


\subsection{[[com64init()]]}

<<[[ginit()]] com64init initialisation>>=
com64init();
@

<<function com64init>>=
void
com64init(void)
{
    Init *p;

    nodaddv = fvn("_addv", TVLONG);
    nodsubv = fvn("_subv", TVLONG);
    nodmulv = fvn("_mulv", TVLONG);
    noddivv = fvn("_divv", TVLONG);
    noddivvu = fvn("_divvu", TVLONG);
    nodmodv = fvn("_modv", TVLONG);
    nodmodvu = fvn("_modvu", TVLONG);
    nodlshv = fvn("_lshv", TVLONG);
    nodrshav = fvn("_rshav", TVLONG);
    nodrshlv = fvn("_rshlv", TVLONG);
    nodandv = fvn("_andv", TVLONG);
    nodorv = fvn("_orv", TVLONG);
    nodxorv = fvn("_xorv", TVLONG);
    nodnegv = fvn("_negv", TVLONG);
    nodcomv = fvn("_comv", TVLONG);

    nodtestv = fvn("_testv", TLONG);
    nodeqv = fvn("_eqv", TLONG);
    nodnev = fvn("_nev", TLONG);
    nodlev = fvn("_lev", TLONG);
    nodltv = fvn("_ltv", TLONG);
    nodgev = fvn("_gev", TLONG);
    nodgtv = fvn("_gtv", TLONG);
    nodhiv = fvn("_hiv", TLONG);
    nodhsv = fvn("_hsv", TLONG);
    nodlov = fvn("_lov", TLONG);
    nodlsv = fvn("_lsv", TLONG);

    nodf2v = fvn("_f2v", TVLONG);
    nodd2v = fvn("_d2v", TVLONG);
    nodp2v = fvn("_p2v", TVLONG);
    nodsi2v = fvn("_si2v", TVLONG);
    nodui2v = fvn("_ui2v", TVLONG);
    nodsl2v = fvn("_sl2v", TVLONG);
    nodul2v = fvn("_ul2v", TVLONG);
    nodsh2v = fvn("_sh2v", TVLONG);
    noduh2v = fvn("_uh2v", TVLONG);
    nodsc2v = fvn("_sc2v", TVLONG);
    noduc2v = fvn("_uc2v", TVLONG);

    nodv2f = fvn("_v2f", TFLOAT);
    nodv2d = fvn("_v2d", TDOUBLE);
    nodv2sl = fvn("_v2sl", TLONG);
    nodv2ul = fvn("_v2ul", TULONG);
    nodv2si = fvn("_v2si", TINT);
    nodv2ui = fvn("_v2ui", TUINT);
    nodv2sh = fvn("_v2sh", TSHORT);
    nodv2uh = fvn("_v2ul", TUSHORT);
    nodv2sc = fvn("_v2sc", TCHAR);
    nodv2uc = fvn("_v2uc", TUCHAR);

    nodvpp = fvn("_vpp", TVLONG);
    nodppv = fvn("_ppv", TVLONG);
    nodvmm = fvn("_vmm", TVLONG);
    nodmmv = fvn("_mmv", TVLONG);

    nodvasop = fvn("_vasop", TVLONG);

    for(p = initetconv; p->code >= 0; p++)
        etconv[p->code] = p->value;
}
@




<<global nodaddv>>=
Node*	nodaddv;
@

<<global nodsubv>>=
Node*	nodsubv;
@

<<global nodmulv>>=
Node*	nodmulv;
@

<<global noddivv>>=
Node*	noddivv;
@

<<global noddivvu>>=
Node*	noddivvu;
@

<<global nodmodv>>=
Node*	nodmodv;
@

<<global nodmodvu>>=
Node*	nodmodvu;
@

<<global nodlshv>>=
Node*	nodlshv;
@

<<global nodrshav>>=
Node*	nodrshav;
@

<<global nodrshlv>>=
Node*	nodrshlv;
@

<<global nodandv>>=
Node*	nodandv;
@

<<global nodorv>>=
Node*	nodorv;
@

<<global nodxorv>>=
Node*	nodxorv;
@

<<global nodnegv>>=
Node*	nodnegv;
@

<<global nodcomv>>=
Node*	nodcomv;
@

<<global nodtestv>>=
Node*	nodtestv;
@

<<global nodeqv>>=
Node*	nodeqv;
@

<<global nodnev>>=
Node*	nodnev;
@

<<global nodlev>>=
Node*	nodlev;
@

<<global nodltv>>=
Node*	nodltv;
@

<<global nodgev>>=
Node*	nodgev;
@

<<global nodgtv>>=
Node*	nodgtv;
@

<<global nodhiv>>=
Node*	nodhiv;
@

<<global nodhsv>>=
Node*	nodhsv;
@

<<global nodlov>>=
Node*	nodlov;
@

<<global nodlsv>>=
Node*	nodlsv;
@

<<global nodf2v>>=
Node*	nodf2v;
@

<<global nodd2v>>=
Node*	nodd2v;
@

<<global nodp2v>>=
Node*	nodp2v;
@

<<global nodsi2v>>=
Node*	nodsi2v;
@

<<global nodui2v>>=
Node*	nodui2v;
@

<<global nodsl2v>>=
Node*	nodsl2v;
@

<<global nodul2v>>=
Node*	nodul2v;
@

<<global nodsh2v>>=
Node*	nodsh2v;
@

<<global noduh2v>>=
Node*	noduh2v;
@

<<global nodsc2v>>=
Node*	nodsc2v;
@

<<global noduc2v>>=
Node*	noduc2v;
@

<<global nodv2f>>=
Node*	nodv2f;
@

<<global nodv2d>>=
Node*	nodv2d;
@

<<global nodv2ui>>=
Node*	nodv2ui;
@

<<global nodv2si>>=
Node*	nodv2si;
@

<<global nodv2ul>>=
Node*	nodv2ul;
@

<<global nodv2sl>>=
Node*	nodv2sl;
@

<<global nodv2uh>>=
Node*	nodv2uh;
@

<<global nodv2sh>>=
Node*	nodv2sh;
@

<<global nodv2uc>>=
Node*	nodv2uc;
@

<<global nodv2sc>>=
Node*	nodv2sc;
@

<<global nodvpp>>=
Node*	nodvpp;
@

<<global nodppv>>=
Node*	nodppv;
@

<<global nodvmm>>=
Node*	nodvmm;
@

<<global nodmmv>>=
Node*	nodmmv;
@

<<global nodvasop>>=
Node*	nodvasop;
@

<<global etconv>>=
char	etconv[NTYPE];	/* for _vasop */
@

<<global initetconv>>=
Init	initetconv[] =
{
    TCHAR,		1,	0,
    TUCHAR,		2,	0,
    TSHORT,		3,	0,
    TUSHORT,	4,	0,
    TLONG,		5,	0,
    TULONG,		6,	0,
    TVLONG,		7,	0,
    TUVLONG,	8,	0,
    TINT,		9,	0,
    TUINT,		10,	0,
    -1,		0,	0,
};
@

<<global fntypes>>=
Type*	fntypes[NTYPE];
@

<<function fvn>>=
Node*
fvn(char *name, int type)
{
    Node *n;

    n = new(ONAME, Z, Z);
    n->sym = slookup(name);
    n->sym->sig = SIGINTERN;
    if(fntypes[type] == nil)
        fntypes[type] = typ(TFUNC, types[type]);
    n->type = fntypes[type];
    n->etype = type; // type of return?
    n->class = CGLOBL;
    n->addable = 10;
    n->complex = 0;
    return n;
}
@




\subsection{Rewriting, [[com64()]]}

<<[[xcom()]] if 64 bits operation, transform and return>>=
if(com64(n))
    return;
@

<<function com64>>=
bool
com64(Node *n)
{
    Node *l, *r; 
    Node *a, *t;
    bool lv, rv;

    if(n->type == nil)
        return false;

    l = n->left;
    r = n->right;

    lv = false;
    if(l && l->type && typev[l->type->etype])
        lv = true;
    rv = false;
    if(r && r->type && typev[r->type->etype])
        rv = true;

    if(lv) {
        switch(n->op) {
        case OEQ:
            a = nodeqv;
            goto setbool;
        case ONE:
            a = nodnev;
            goto setbool;
        case OLE:
            a = nodlev;
            goto setbool;
        case OLT:
            a = nodltv;
            goto setbool;
        case OGE:
            a = nodgev;
            goto setbool;
        case OGT:
            a = nodgtv;
            goto setbool;
        case OHI:
            a = nodhiv;
            goto setbool;
        case OHS:
            a = nodhsv;
            goto setbool;
        case OLO:
            a = nodlov;
            goto setbool;
        case OLS:
            a = nodlsv;
            goto setbool;

        case OANDAND:
        case OOROR:
            if(machcap(n))
                return true;

            if(rv) {
                r = new(OFUNC, nodtestv, r);
                n->right = r;
                r->complex = FNX;
                r->op = OFUNC;
                r->type = types[TLONG];
            }

        case OCOND:
        case ONOT:
            if(machcap(n))
                return true;

            l = new(OFUNC, nodtestv, l);
            n->left = l;
            l->complex = FNX;
            l->op = OFUNC;
            l->type = types[TLONG];
            n->complex = FNX;
            return 1;
        }
    }

    if(rv) {
        if(machcap(n))
            return true;
        switch(n->op) {
        case OANDAND:
        case OOROR:
            r = new(OFUNC, nodtestv, r);
            n->right = r;
            r->complex = FNX;
            r->op = OFUNC;
            r->type = types[TLONG];
            return 1;
        case OCOND:
            return 1;
        }
    }

    if(typev[n->type->etype]) {
        if(machcap(n))
            return true;
        switch(n->op) {
        default:
            diag(n, "unknown vlong %O", n->op);
        case OFUNC:
            n->complex = FNX;
        case ORETURN:
        case OAS:
        case OIND:
        case OLIST:
        case OCOMMA:
            return 1;
        case OADD:
            a = nodaddv;
            goto setbop;
        case OSUB:
            a = nodsubv;
            goto setbop;
        case OMUL:
        case OLMUL:
            a = nodmulv;
            goto setbop;
        case ODIV:
            a = noddivv;
            goto setbop;
        case OLDIV:
            a = noddivvu;
            goto setbop;
        case OMOD:
            a = nodmodv;
            goto setbop;
        case OLMOD:
            a = nodmodvu;
            goto setbop;
        case OASHL:
            a = nodlshv;
            goto setbop;
        case OASHR:
            a = nodrshav;
            goto setbop;
        case OLSHR:
            a = nodrshlv;
            goto setbop;
        case OAND:
            a = nodandv;
            goto setbop;
        case OOR:
            a = nodorv;
            goto setbop;
        case OXOR:
            a = nodxorv;
            goto setbop;
        case OPOSTINC:
            a = nodvpp;
            goto setvinc;
        case OPOSTDEC:
            a = nodvmm;
            goto setvinc;
        case OPREINC:
            a = nodppv;
            goto setvinc;
        case OPREDEC:
            a = nodmmv;
            goto setvinc;
        case ONEG:
            a = nodnegv;
            goto setfnx;
        case OCOM:
            a = nodcomv;
            goto setfnx;
        case OCAST:
            switch(l->type->etype) {
            case TCHAR:
                a = nodsc2v;
                goto setfnxl;
            case TUCHAR:
                a = noduc2v;
                goto setfnxl;
            case TSHORT:
                a = nodsh2v;
                goto setfnxl;
            case TUSHORT:
                a = noduh2v;
                goto setfnxl;
            case TINT:
                a = nodsi2v;
                goto setfnx;
            case TUINT:
                a = nodui2v;
                goto setfnx;
            case TLONG:
                a = nodsl2v;
                goto setfnx;
            case TULONG:
                a = nodul2v;
                goto setfnx;
            case TFLOAT:
                a = nodf2v;
                goto setfnx;
            case TDOUBLE:
                a = nodd2v;
                goto setfnx;
            case TIND:
                a = nodp2v;
                goto setfnx;
            }
            diag(n, "unknown %T->vlong cast", l->type);
            return true;
        case OASADD:
            a = nodaddv;
            goto setasop;
        case OASSUB:
            a = nodsubv;
            goto setasop;
        case OASMUL:
        case OASLMUL:
            a = nodmulv;
            goto setasop;
        case OASDIV:
            a = noddivv;
            goto setasop;
        case OASLDIV:
            a = noddivvu;
            goto setasop;
        case OASMOD:
            a = nodmodv;
            goto setasop;
        case OASLMOD:
            a = nodmodvu;
            goto setasop;
        case OASASHL:
            a = nodlshv;
            goto setasop;
        case OASASHR:
            a = nodrshav;
            goto setasop;
        case OASLSHR:
            a = nodrshlv;
            goto setasop;
        case OASAND:
            a = nodandv;
            goto setasop;
        case OASOR:
            a = nodorv;
            goto setasop;
        case OASXOR:
            a = nodxorv;
            goto setasop;
        }
    }

    if(typefd[n->type->etype] && l && l->op == OFUNC) {
        switch(n->op) {
        case OASADD:
        case OASSUB:
        case OASMUL:
        case OASLMUL:
        case OASDIV:
        case OASLDIV:
        case OASMOD:
        case OASLMOD:
        case OASASHL:
        case OASASHR:
        case OASLSHR:
        case OASAND:
        case OASOR:
        case OASXOR:
            if(l->right && typev[l->right->etype]) {
                diag(n, "sorry float <asop> vlong not implemented\n");
            }
        }
    }

    if(n->op == OCAST) {
        if(l->type && typev[l->type->etype]) {
            if(machcap(n))
                return true;
            switch(n->type->etype) {
            case TDOUBLE:
                a = nodv2d;
                goto setfnx;
            case TFLOAT:
                a = nodv2f;
                goto setfnx;
            case TLONG:
                a = nodv2sl;
                goto setfnx;
            case TULONG:
                a = nodv2ul;
                goto setfnx;
            case TINT:
                a = nodv2si;
                goto setfnx;
            case TUINT:
                a = nodv2ui;
                goto setfnx;
            case TSHORT:
                a = nodv2sh;
                goto setfnx;
            case TUSHORT:
                a = nodv2uh;
                goto setfnx;
            case TCHAR:
                a = nodv2sc;
                goto setfnx;
            case TUCHAR:
                a = nodv2uc;
                goto setfnx;
            case TIND:	// small pun here
                a = nodv2ul;
                goto setfnx;
            }
            diag(n, "unknown vlong->%T cast", n->type);
            return true;
        }
    }

    return false;

setbop:
    n->left = a;
    n->right = new(OLIST, l, r);
    n->complex = FNX;
    n->op = OFUNC;
    return true;

setfnxl:
    l = new(OCAST, l, 0);
    l->type = types[TLONG];
    l->complex = l->left->complex;

setfnx:
    n->left = a;
    n->right = l;
    n->complex = FNX;
    n->op = OFUNC;
    return true;

setvinc:
    n->left = a;
    l = new(OADDR, l, Z);
    l->type = typ(TIND, l->left->type);
    l->complex = l->left->complex;
    n->right = new(OLIST, l, r);
    n->complex = FNX;
    n->op = OFUNC;
    return true;

setbool:
    if(machcap(n))
        return true;
    n->left = a;
    n->right = new(OLIST, l, r);
    n->complex = FNX;
    n->op = OFUNC;
    n->type = types[TLONG];
    return true;

setasop:
    if(l->op == OFUNC) {
        l = l->right;
        goto setasop;
    }

    t = new(OCONST, 0, 0);
    t->vconst = etconv[l->type->etype];
    t->type = types[TLONG];
    t->addable = 20;
    r = new(OLIST, t, r);

    t = new(OADDR, a, 0);
    t->type = typ(TIND, a->type);
    r = new(OLIST, t, r);

    t = new(OADDR, l, 0);
    t->type = typ(TIND, l->type);
    t->complex = l->complex;
    r = new(OLIST, t, r);

    n->left = nodvasop;
    n->right = r;
    n->complex = FNX;
    n->op = OFUNC;

    return true;
}
@


%<<function convvtof>>=
%/*
% * more machine depend stuff.
% * this is common for 8,16,32,64 bit machines.
% * this is common for ieee machines.
% */
%//double
%//convvtof(vlong v)
%//{
%//    double d;
%//
%//    d = v;		/* BOTCH */
%//    return d;
%//}
%@
%
%<<function convftov>>=
%//vlong
%//convftov(double d)
%//{
%//    vlong v;
%//
%//
%//    v = d;		/* BOTCH */
%//    return v;
%//}
%@
%
%<<function convftox>>=
%//double
%//convftox(double d, int et)
%//{
%//
%//    if(!typefd[et])
%//        diag(Z, "bad type in castftox %s", tnames[et]);
%//    return d;
%//}
%@




%\subsection{[[8c/cgen64.c]]}

\subsection{[[bool64()]]}

<<[[bcomplex()]] possibly convert node to funcall if unsupported 64 bit op>>=
bool64(n);
@

<<function bool64>>=
void
bool64(Node *n)
{
    Node *n1;

    if(machcap(Z))
        return;

    if(typev[n->type->etype]) {
        n1 = new(OXXX, 0, 0);
        *n1 = *n;

        n->right = n1;
        n->left = nodtestv;
        n->complex = FNX;
        n->addable = 0;
        n->op = OFUNC;
        n->type = types[TLONG];
    }
}
@
% pass Z?? dead code?


\section{Endianness}

% 5c -l, just for mips => switch from vc to 0c


%    case 'l':			/* for little-endian mips */
%        if(thechar != 'v'){
%            print("can only use -l with vc");
%            errorexit();
%        }
%        thechar = '0';
%        thestring = "spim";
%        break;


\section{Using an external preprocessor, [[/bin/cpp]]}

%5c -p
%useful for pcc and APE.

<<constant CPP>>=
#define	CPP	"/bin/cpp"
@

<<[[compile()]] locals>>=
char **av, opt[256];
int i, c, fd[2];
@

<<[[compile()]] if use ANSI preprocessor>>=
/* Use an ANSI preprocessor */
if(debug['p']) {
    if(myaccess(infile) < 0) {
        diag(Z, "%s does not exist", infile);
        errorexit();
    }
    if(pipe(fd) < 0) {
        diag(Z, "pipe failed");
        errorexit();
    }
    switch(fork()) {
    case -1:
        diag(Z, "fork failed");
        errorexit();

    case 0:
        close(fd[0]);
        dup(fd[1], 1);
        close(fd[1]);
        av = alloc((3 + ndef + ninclude + 2) * sizeof *av);
        av[0] = CPP;
        i = 1;
        if(debug['.'])
            av[i++] = strdup("-.");
        /* 1999 ANSI C requires recognising // comments */
        av[i++] = strdup("-+");
        for(c = 0; c < ndef; c++) {
            sprint(opt, "-D%s", defs[c]);
            av[i++] = strdup(opt);
        }
        for(c = 0; c < ninclude; c++) {
            sprint(opt, "-I%s", include[c]);
            av[i++] = strdup(opt);
        }
        if(strcmp(infile, "stdin") != 0)
            av[i++] = infile;
        av[i] = 0;
        if(debug['p'] > 1) {
            for(c = 0; c < i; c++)
                fprint(2, "%s ", av[c]);
            fprint(2, "\n");
        }

        exec(av[0], av);
        fprint(2, "can't exec C preprocessor %s: %r\n", CPP);
        errorexit();

    default:
        close(fd[1]);
        newfile(infile, fd[0]);
        break;
    }
}
@


\section{Processing multiple files}

<<[[main()]] locals>>=
int nproc, nout, status, i;
@

<<[[main()]] multiple files handling>>=
if(argc > 1) {
    nproc = 1;
    /*
     * if we're writing acid to standard output, don't compile
     * concurrently, to avoid interleaving output.
     */
    if(((!debug['a'] && !debug['Z']) || debug['n']) &&
        (p = getenv("NPROC")) != nil)
        nproc = atol(p);	/* */
    c = 0;
    nout = 0;
    for(;;) {
        while(nout < nproc && argc > 0) {
            i = fork();
            if(i < 0) {
                i = mywait(&status);
                if(i < 0) {
                    print("cannot create a process\n");
                    errorexit();
                }
                if(status)
                    c++;
                nout--;
                continue;
            }
            if(i == 0) {
                fprint(2, "%s:\n", *argv);
                if (compile(*argv, defs, ndef))
                    errorexit();
                exits(0);
            }
            nout++;
            argc--;
            argv++;
        }
        i = mywait(&status);
        if(i < 0) {
            if(c)
                errorexit();
            exits(0);
        }
        if(status)
            c++;
        nout--;
    }
}
@

\fi

\section{Other optimizations}

\subsection{Packing, [[#pragma pack]]}

<<[[macprag()]] if pragma xxx>>=
if(s && strcmp(s->name, "pack") == 0) {
    pragpack();
    return;
}
@

% set via pragma
<<global packflg>>=
int	packflg;
@
% bool or int?

<<function pragpack>>=
void
pragpack(void)
{
    Sym *s;

    packflg = 0;
    s = getsym();
    if(s) {
        packflg = atoi(s->name+1);
        if(strcmp(s->name, "on") == 0 ||
           strcmp(s->name, "yes") == 0)
            packflg = 1;
    }
    while(getnsc() != '\n')
        ;
    <<[[pragpack()]] debug if [[-f]]>>
}
@

<<[[pragpack()]] debug if [[-f]]>>=
if(debug['f'])
    if(packflg)
        print("%4ld: pack %d\n", lineno, packflg);
    else
        print("%4ld: pack off\n", lineno);
@


<<[[align()]] if packflg override w>>=
if(packflg)
    w = packflg;
@

\subsection{Minimizing [[#line]] history}

% delete?
<<[[linehist()]] possibly overwrite last line directive>>=
/*
 * overwrite the last #line directive if
 * no alloc has happened since the last one
 */
if(!newflag && ehist != H && offset != 0 && ehist->offset != 0)
    if(f && ehist->name && strcmp(f, ehist->name) == 0) {
        ehist->line = lineno;
        ehist->offset = offset;
        return;
    }
newflag = false;
@
%ocaml: useful opti? meh

<<global newflag>>=
bool	newflag;
@

<<[[new()]] set lineno>>=
newflag = true;
@
% newflag? this is for linehist, to detect if no new nodes were allocated
%  so no lineno were set so the old #line information directive can be
%  discarded



\chapter{Conclusion}

% next books, scheme, ocaml, more advanced languages,
% higher level constructs.






\appendix



\chapter{Debugging}

<<global debug>>=
char	debug[256];
@
% bool? ushort?

\section{Dumpers}


\subsection{[[cc/]] [[Fmt]] data structures}


<<[[cinit()]] fmtinstall>>=
fmtinstall('O', Oconv);
fmtinstall('T', Tconv);
fmtinstall('F', FNconv);
fmtinstall('Q', Qconv);
fmtinstall('|', VBconv);
@

<<function Oconv>>=
// enum<Node_kind> -> unit
int Oconv(Fmt *fp)
{
    int a;

    a = va_arg(fp->args, int);
    if(a < OXXX || a > OEND)
        return fmtprint(fp, "***badO %d***", a);

    return fmtstrcpy(fp, onames[a]);
}
@

<<global onames>>=
char*	onames[OEND+1];
@
% 5c allows [0ADD] notation, so no need for onamesinit I think.

<<global onamesinit>>=
Init	onamesinit[] =
{
    OXXX,		0,	"OXXX",
    OADD,		0,	"ADD",
    OADDR,		0,	"ADDR",
    OAND,		0,	"AND",
    OANDAND,	0,	"ANDAND",
    OARRAY,		0,	"ARRAY",
    OAS,		0,	"AS",
    OASI,		0,	"ASI",
    OASADD,		0,	"ASADD",
    OASAND,		0,	"ASAND",
    OASASHL,	0,	"ASASHL",
    OASASHR,	0,	"ASASHR",
    OASDIV,		0,	"ASDIV",
    OASHL,		0,	"ASHL",
    OASHR,		0,	"ASHR",
    OASLDIV,	0,	"ASLDIV",
    OASLMOD,	0,	"ASLMOD",
    OASLMUL,	0,	"ASLMUL",
    OASLSHR,	0,	"ASLSHR",
    OASMOD,		0,	"ASMOD",
    OASMUL,		0,	"ASMUL",
    OASOR,		0,	"ASOR",
    OASSUB,		0,	"ASSUB",
    OASXOR,		0,	"ASXOR",
    OBIT,		0,	"BIT",
    OBREAK,		0,	"BREAK",
    OCASE,		0,	"CASE",
    OCAST,		0,	"CAST",
    OCOMMA,		0,	"COMMA",
    OCOND,		0,	"COND",
    OCONST,		0,	"CONST",
    OCONTINUE,	0,	"CONTINUE",
    ODIV,		0,	"DIV",
    ODOT,		0,	"DOT",
    ODOTDOT,	0,	"DOTDOT",
    ODWHILE,	0,	"DWHILE",
    OEQ,		0,	"EQ",
    OFOR,		0,	"FOR",
    OFUNC,		0,	"FUNC",
    OGE,		0,	"GE",
    OGOTO,		0,	"GOTO",
    OGT,		0,	"GT",
    OHI,		0,	"HI",
    OHS,		0,	"HS",
    OIF,		0,	"IF",
    OIND,		0,	"IND",
    OINDREG,	0,	"INDREG",
    OINIT,		0,	"INIT",
    OLABEL,		0,	"LABEL",
    OLDIV,		0,	"LDIV",
    OLE,		0,	"LE",
    OLIST,		0,	"LIST",
    OLMOD,		0,	"LMOD",
    OLMUL,		0,	"LMUL",
    OLO,		0,	"LO",
    OLS,		0,	"LS",
    OLSHR,		0,	"LSHR",
    OLT,		0,	"LT",
    OMOD,		0,	"MOD",
    OMUL,		0,	"MUL",
    ONAME,		0,	"NAME",
    ONE,		0,	"NE",
    ONOT,		0,	"NOT",
    OOR,		0,	"OR",
    OOROR,		0,	"OROR",
    OPOSTDEC,	0,	"POSTDEC",
    OPOSTINC,	0,	"POSTINC",
    OPREDEC,	0,	"PREDEC",
    OPREINC,	0,	"PREINC",
    OPROTO,		0,	"PROTO",
    OREGISTER,	0,	"REGISTER",
    ORETURN,	0,	"RETURN",
    OSET,		0,	"SET",
    OSIGN,		0,	"SIGN",
    OSIZE,		0,	"SIZE",
    OSTRING,	0,	"STRING",
    OLSTRING,	0,	"LSTRING",
    OSTRUCT,	0,	"STRUCT",
    OSUB,		0,	"SUB",
    OSWITCH,	0,	"SWITCH",
    OUNION,		0,	"UNION",
    OUSED,		0,	"USED",
    OWHILE,		0,	"WHILE",
    OXOR,		0,	"XOR",
    OPOS,		0,	"POS",
    ONEG,		0,	"NEG",
    OCOM,		0,	"COM",
    OELEM,		0,	"ELEM",
    OINDEX,		0,	"INDEX",
    OREGPAIR,	0,	"REGPAIR",
    OEXREG,		0,	"EXREG",
    OEND,		0,	"END",
    -1,		0,	0,
};
@


<<function Tconv>>=
// option<Type> -> string
int
Tconv(Fmt *fp)
{
    char str[STRINGSZ+20], s[STRINGSZ+20];
    Type *t, *t1;
    int et;
    long n;

    str[0] = '\0';
    for(t = va_arg(fp->args, Type*); t != T; t = t->link) {
        et = t->etype;
        if(str[0])
            strcat(str, " ");
        if(t->garb&~GINCOMPLETE) {
            sprint(s, "%s ", gnames[t->garb&~GINCOMPLETE]);
            if(strlen(str) + strlen(s) < STRINGSZ)
                strcat(str, s);
        }
        sprint(s, "%s", tnames[et]);
        if(strlen(str) + strlen(s) < STRINGSZ)
            strcat(str, s);
        if(et == TFUNC && (t1 = t->down)) {
            sprint(s, "(%T", t1);
            if(strlen(str) + strlen(s) < STRINGSZ)
                strcat(str, s);
            while(t1 = t1->down) {
                sprint(s, ", %T", t1);
                if(strlen(str) + strlen(s) < STRINGSZ)
                    strcat(str, s);
            }
            if(strlen(str) + strlen(s) < STRINGSZ)
                strcat(str, ")");
        }
        if(et == TARRAY) {
            n = t->width;
            if(t->link && t->link->width)
                n /= t->link->width;
            sprint(s, "[%ld]", n);
            if(strlen(str) + strlen(s) < STRINGSZ)
                strcat(str, s);
        }
        if(t->nbits) {
            sprint(s, " %d:%d", t->shift, t->nbits);
            if(strlen(str) + strlen(s) < STRINGSZ)
                strcat(str, s);
        }
        if(typesu[et]) {
            if(t->tag) {
                strcat(str, " ");
                if(strlen(str) + strlen(t->tag->name) < STRINGSZ)
                    strcat(str, t->tag->name);
            } else
                strcat(str, " {}");
            break;
        }
    }
    return fmtstrcpy(fp, str);
}
@

<<global tnames>>=
char*	tnames[NALLTYPES];
@

<<global tnamesinit>>=
Init	tnamesinit[] =
{
    TXXX,		0,	"TXXX",

    TCHAR,		0,	"CHAR",
    TUCHAR,		0,	"UCHAR",
    TSHORT,		0,	"SHORT",
    TUSHORT,	0,	"USHORT",
    TINT,		0,	"INT",
    TUINT,		0,	"UINT",
    TLONG,		0,	"LONG",
    TULONG,		0,	"ULONG",
    TVLONG,		0,	"VLONG",
    TUVLONG,	0,	"UVLONG",
    TFLOAT,		0,	"FLOAT",
    TDOUBLE,	0,	"DOUBLE",
    TIND,		0,	"IND",
    TFUNC,		0,	"FUNC",
    TARRAY,		0,	"ARRAY",
    TVOID,		0,	"VOID",
    TSTRUCT,	0,	"STRUCT",
    TUNION,		0,	"UNION",
    TENUM,		0,	"ENUM",
    TOLD,		0,	"OLD",
    TDOT,		0,	"DOT",

    -1,		0,	0,
};
@



<<function FNconv>>=
// option<Node identifier cases> -> string
int
FNconv(Fmt *fp)
{
    char *str;
    Node *n;

    n = va_arg(fp->args, Node*);
    str = "<indirect>";
    if(n != Z && (n->op == ONAME || n->op == ODOT || n->op == OELEM))
        str = n->sym->name;
    return fmtstrcpy(fp, str);
}
@

<<function Qconv>>=
// ??
int
Qconv(Fmt *fp)
{
    char str[STRINGSZ+20], *s;
    long b;
    int i;

    str[0] = 0;
    for(b = va_arg(fp->args, long); b;) {
        i = bitno(b);
        if(str[0])
            strcat(str, " ");
        s = qnames[i];
        if(strlen(str) + strlen(s) >= STRINGSZ)
            break;
        strcat(str, s);
        b &= ~(1L << i);
    }
    return fmtstrcpy(fp, str);
}
@
% >>

<<function VBconv>>=
// ??
int
VBconv(Fmt *fp)
{
    char str[STRINGSZ];
    int i, n, t, pc;

    n = va_arg(fp->args, int);
    pc = 0;	/* BUG: was printcol */
    i = 0;
    while(pc < n) {
        t = (pc+4) & ~3;
        if(t <= n) {
            str[i++] = '\t';
            pc = t;
            continue;
        }
        str[i++] = ' ';
        pc++;
    }
    str[i] = '\0';

    return fmtstrcpy(fp, str);
}
@

\subsection{[[5c/]] [[Fmt]] data structures}

% similar to Assembler.nw?


<<[[ginit()]] misc initialisations>>=
listinit();
@

<<function listinit(arm)>>=
void
listinit(void)
{

    fmtinstall('A', Aconv);
    fmtinstall('P', Pconv);
    fmtinstall('S', Sconv);
    fmtinstall('N', Nconv);
    fmtinstall('B', Bconv);
    fmtinstall('D', Dconv);
    fmtinstall('R', Rconv);
}
@


<<function Bconv>>=
// Bits -> string
int
Bconv(Fmt *fp)
{
    char str[STRINGSZ], ss[STRINGSZ], *s;
    Bits bits;
    int i;

    str[0] = 0;
    bits = va_arg(fp->args, Bits);
    while(bany(&bits)) {
        i = bnum(bits);
        if(str[0])
            strcat(str, " ");
        if(var[i].sym == S) {
            snprint(ss, sizeof(ss), "$%ld", var[i].offset);
            s = ss;
        } else
            s = var[i].sym->name;
        if(strlen(str) + strlen(s) + 1 >= STRINGSZ)
            break;
        strcat(str, s);
        bits.b[i/32] &= ~(1L << (i%32));
    }
    return fmtstrcpy(fp, str);
}
@
% >>
%$




<<function Pconv(arm)>>=
// Prog -> string
int
Pconv(Fmt *fp)
{
    char str[STRINGSZ], sc[20];
    Prog *p;
    int a, s;

    p = va_arg(fp->args, Prog*);
    a = p->as;
    s = p->scond; 
    strcpy(sc, extra[s & C_SCOND]);
    if(s & C_SBIT)
        strcat(sc, ".S");
    if(s & C_PBIT)
        strcat(sc, ".P");
    if(s & C_WBIT)
        strcat(sc, ".W");
    if(s & C_UBIT)		/* ambiguous with FBIT */
        strcat(sc, ".U");
    if(a == AMOVM) {
        if(p->from.type == D_CONST)
            snprint(str, sizeof(str), "	%A%s	%R,%D", a, sc, &p->from, &p->to);
        else
        if(p->to.type == D_CONST)
            snprint(str, sizeof(str), "	%A%s	%D,%R", a, sc, &p->from, &p->to);
        else
            snprint(str, sizeof(str), "	%A%s	%D,%D", a, sc, &p->from, &p->to);
    } else
    if(a == ADATA)
        snprint(str, sizeof(str), "	%A	%D/%d,%D", a, &p->from, p->reg, &p->to);
    else
    if(p->as == ATEXT)
        snprint(str, sizeof(str), "	%A	%D,%d,%D", a, &p->from, p->reg, &p->to);
    else
    if(p->reg == R_NONE)
        snprint(str, sizeof(str), "	%A%s	%D,%D", a, sc, &p->from, &p->to);
    else
    if(p->from.type != D_FREG)
        snprint(str, sizeof(str), "	%A%s	%D,R%d,%D", a, sc, &p->from, p->reg, &p->to);
    else
        snprint(str, sizeof(str), "	%A%s	%D,F%d,%D", a, sc, &p->from, p->reg, &p->to);
    return fmtstrcpy(fp, str);
}
@

<<global extra(arm)>>=
char *extra [] = {
    ".EQ", ".NE", ".CS", ".CC", 
    ".MI", ".PL", ".VS", ".VC", 
    ".HI", ".LS", ".GE", ".LT", 
    ".GT", ".LE", "", ".NV",
};
@



<<function Aconv>>=
// enum<opcode_kind> -> string
int
Aconv(Fmt *fp)
{
    char *s;
    int a;

    a = va_arg(fp->args, int);
    s = "???";
    if(a >= AXXX && a < ALAST)
        s = anames[a];
    return fmtstrcpy(fp, s);
}
@
% anames in Assembly section
% >>



<<function Dconv(arm)>>=
int
Dconv(Fmt *fp)
{
    char str[STRINGSZ];
    Adr *a;
    char *op;
    int v;

    a = va_arg(fp->args, Adr*);
    switch(a->type) {

    default:
        snprint(str, sizeof(str), "GOK-type(%d)", a->type);
        break;

    case D_NONE:
        str[0] = 0;
        if(a->symkind != N_NONE || a->reg != R_NONE || a->sym != S)
            snprint(str, sizeof(str), "%N(R%d)(NONE)", a, a->reg);
        break;

    case D_CONST:
        if(a->reg != R_NONE)
            snprint(str, sizeof(str), "$%N(R%d)", a, a->reg);
        else
            snprint(str, sizeof(str), "$%N", a);
        break;

    case D_SHIFT:
        v = a->offset;
        op = "<<>>->@>" + (((v>>5) & 3) << 1);
        if(v & (1<<4))
            snprint(str, sizeof(str), "R%d%c%cR%d", v&15, op[0], op[1], (v>>8)&15);
        else
            snprint(str, sizeof(str), "R%d%c%c%d", v&15, op[0], op[1], (v>>7)&31);
        if(a->reg != R_NONE)
            sprint(str+strlen(str), "(R%d)", a->reg);
        break;

    case D_OREG:
        if(a->reg != R_NONE)
            snprint(str, sizeof(str), "%N(R%d)", a, a->reg);
        else
            snprint(str, sizeof(str), "%N", a);
        break;

    case D_REG:
        snprint(str, sizeof(str), "R%d", a->reg);
        if(a->symkind != N_NONE || a->sym != S)
            snprint(str, sizeof(str), "%N(R%d)(REG)", a, a->reg);
        break;

    case D_FREG:
        snprint(str, sizeof(str), "F%d", a->reg);
        if(a->symkind != N_NONE || a->sym != S)
            snprint(str, sizeof(str), "%N(R%d)(REG)", a, a->reg);
        break;

    case D_PSR:
        snprint(str, sizeof(str), "PSR");
        if(a->symkind != N_NONE || a->sym != S)
            snprint(str, sizeof(str), "%N(PSR)(REG)", a);
        break;

    case D_BRANCH:
        snprint(str, sizeof(str), "%ld(PC)", a->offset-pc);
        break;

    case D_FCONST:
        snprint(str, sizeof(str), "$%.17e", a->dval);
        break;

    case D_SCONST:
        snprint(str, sizeof(str), "$\"%S\"", a->sval);
        break;
    }
    return fmtstrcpy(fp, str);
}
@





<<function Rconv(arm)>>=
// enum<operand_kind(register-only??)> -> string
int
Rconv(Fmt *fp)
{
    char str[STRINGSZ], *p, *e;
    Adr *a;
    int i, v;

    a = va_arg(fp->args, Adr*);
    snprint(str, sizeof(str), "GOK-reglist");
    switch(a->type) {
    case D_CONST:
        if(a->reg != R_NONE)
            break;
        if(a->sym != S)
            break;
        v = a->offset;
        p = str;
        e = str+sizeof(str);
        for(i=0; i<NREG; i++) {
            if(v & (1<<i)) {
                if(p == str)
                    p = seprint(p, e, "[R%d", i);
                else
                    p = seprint(p, e, ",R%d", i);
            }
        }
        seprint(p, e, "]");
    }
    return fmtstrcpy(fp, str);
}
@
% >> >>


<<function Sconv(arm)>>=
int
Sconv(Fmt *fp)
{
    int i, c;
    char str[STRINGSZ], *p, *a;

    a = va_arg(fp->args, char*);
    p = str;
    for(i=0; i<NSNAME; i++) {
        c = a[i] & 0xff;
        if(c >= 'a' && c <= 'z' ||
           c >= 'A' && c <= 'Z' ||
           c >= '0' && c <= '9' ||
           c == ' ' || c == '%') {
            *p++ = c;
            continue;
        }
        *p++ = '\\';
        switch(c) {
        case 0:
            *p++ = 'z';
            continue;
        case '\\':
        case '"':
            *p++ = c;
            continue;
        case '\n':
            *p++ = 'n';
            continue;
        case '\t':
            *p++ = 't';
            continue;
        case '\r':
            *p++ = 'r';
            continue;
        case '\f':
            *p++ = 'f';
            continue;
        }
        *p++ = (c>>6) + '0';
        *p++ = ((c>>3) & 7) + '0';
        *p++ = (c & 7) + '0';
    }
    *p = 0;
    return fmtstrcpy(fp, str);
}
@
% similar to 386 with additional:           c == ' ' || c == '%') {


<<function Nconv(arm)>>=
int
Nconv(Fmt *fp)
{
    char str[STRINGSZ];
    Adr *a;
    Sym *s;

    a = va_arg(fp->args, Adr*);
    s = a->sym;
    if(s == S) {
        snprint(str, sizeof(str), "%ld", a->offset);
        goto out;
    }
    switch(a->symkind) {
    case N_NONE:
        snprint(str, sizeof(str), "%ld", a->offset);
        break;

    case N_EXTERN:
        snprint(str, sizeof(str), "%s+%ld(SB)", s->name, a->offset);
        break;

    case N_INTERN:
        snprint(str, sizeof(str), "%s<>+%ld(SB)", s->name, a->offset);
        break;

    case N_LOCAL:
        snprint(str, sizeof(str), "%s-%ld(SP)", s->name, -a->offset);
        break;

    case N_PARAM:
        snprint(str, sizeof(str), "%s+%ld(FP)", s->name, a->offset);
        break;

    default:
        snprint(str, sizeof(str), "GOK-name(%d)", a->symkind);
        break;

    }
out:
    return fmtstrcpy(fp, str);
}
@

\subsection{[[xxxnames[]]]}

% already seen onames and anames before


<<global cnames>>=
char*	cnames[NCTYPES];
@

<<global cnamesinit>>=
Init	cnamesinit[] =
{
    CXXX     ,		0,	"CXXX",
    CAUTO    ,		0,	"AUTO",
    CEXTERN  ,		0,	"EXTERN",
    CGLOBL   ,		0,	"GLOBL",
    CSTATIC  ,		0,	"STATIC",
    CLOCAL   ,		0,	"LOCAL",
    CTYPEDEF ,		0,	"TYPEDEF",
    CTYPESTR ,		0,	"TYPESTR",
    CPARAM   ,		0,	"PARAM",
    CEXREG   ,		0,	"EXREG",
    -1,			0,	0,
};
@


<<global qnames>>=
char*	qnames[NALLTYPES];
@

<<global qnamesinit>>=
Init	qnamesinit[] =
{
    TXXX      ,		0,	"TXXX",

    TCHAR     ,		0,	"CHAR",
    TUCHAR    ,		0,	"UCHAR",
    TSHORT    ,		0,	"SHORT",
    TUSHORT   ,		0,	"USHORT",
    TINT      ,		0,	"INT",
    TUINT     ,		0,	"UINT",
    TLONG     ,		0,	"LONG",
    TULONG    ,		0,	"ULONG",
    TVLONG    ,		0,	"VLONG",
    TUVLONG   ,		0,	"UVLONG",
    TFLOAT    ,		0,	"FLOAT",
    TDOUBLE   ,		0,	"DOUBLE",
    TIND      ,		0,	"IND",
    TFUNC     ,		0,	"FUNC",
    TARRAY    ,		0,	"ARRAY",
    TVOID     ,		0,	"VOID",
    TSTRUCT   ,		0,	"STRUCT",
    TUNION    ,		0,	"UNION",
    TENUM     ,		0,	"ENUM",

    TAUTO     ,		0,	"AUTO",
    TEXTERN   ,		0,	"EXTERN",
    TSTATIC   ,		0,	"STATIC",
    TTYPEDEF  ,		0,	"TYPEDEF",
    TTYPESTR  ,		0,	"TYPESTR",
    TREGISTER ,		0,	"REGISTER",
    TCONSTNT  ,		0,	"CONSTNT",
    TVOLATILE ,		0,	"VOLATILE",
    TUNSIGNED ,		0,	"UNSIGNED",
    TSIGNED   ,		0,	"SIGNED",
    TDOT      ,		0,	"DOT",
    TOLD      ,		0,	"OLD",

    -1,		0,	0,
};
@




<<global gnames>>=
char*	gnames[NGTYPES];
@

<<global gnamesinit>>=
Init	gnamesinit[] =
{
    GXXX,		0,	"GXXX",
    GCONSTNT,		0,	"CONST",
    GVOLATILE,		0,	"VOLATILE",
    GVOLATILE|GCONSTNT,	0,	"CONST-VOLATILE",
    -1,			0,	0,
};
@


<<[[tinit()]] initialise xxxnames debugging arrays>>=
for(p=bnamesinit; p->code >= 0; p++) {
    urk("bnames", nelem(bnames), p->code);
    bnames[p->code] = p->s;
}
for(p=tnamesinit; p->code >= 0; p++) {
    urk("tnames", nelem(tnames), p->code);
    tnames[p->code] = p->s;
}
for(p=gnamesinit; p->code >= 0; p++) {
    urk("gnames", nelem(gnames), p->code);
    gnames[p->code] = p->s;
}
for(p=qnamesinit; p->code >= 0; p++) {
    urk("qnames", nelem(qnames), p->code);
    qnames[p->code] = p->s;
}
for(p=cnamesinit; p->code >= 0; p++) {
    urk("cnames", nelem(cnames), p->code);
    cnames[p->code] = p->s;
}
for(p=onamesinit; p->code >= 0; p++) {
    urk("onames", nelem(onames), p->code);
    onames[p->code] = p->s;
}
@


\subsection{AST dumper, [[prtree()]], [[5c -x]]}
% this is useful! gcc still have not it, and RMS is actually
% opposing adding them to gcc (but for licensing issues).
% clang has it! (and pfff has it from the beginning of course ...)

<<xdecl rule, debug function body>>=
if(debug['x']) {
    prtree($2, "func");
    prtree($6, "body");
}
@
%pad: I added that? it was not there originally?
\t implement in kencc? mv in appendix?


<<function prtree>>=
void
prtree(Node *n, char *s)
{

    print(" == %s ==\n", s);
    prtree1(n, 0, false);
    print("\n");
}
@

% d = depth, indentation level
<<function prtree1>>=
void
prtree1(Node *n, int d, bool f)
{
    //bitset<Left|Right> to decide whether to recurse left and right child
    int i;

    if(f)
      for(i=0; i<d; i++)
        print("   ");
    if(n == Z) {
        print("Z\n");
        return;
    }

    if(n->op == OLIST) {
        prtree1(n->left, d, false);
        prtree1(n->right, d, true);
        return;
    }
    d++;
    print("%O", n->op);
    i = 3; // 1 | 2

    switch(n->op) {
    case OCONST:
        if(typefd[n->type->etype])
            print(" \"%.8e\"", n->fconst);
        else
            print(" \"%lld\"", n->vconst);
        i = 0;
        break;

    case OSTRING:
        print(" \"%s\"", n->cstring);
        i = 0;
        break;
    case OLSTRING:
        if(sizeof(TRune) == sizeof(Rune))
            print(" \"%S\"", (Rune*)n->rstring);
        else
            print(" \"...\"");
        i = 0;
        break;

    case ONAME:
        print(" \"%F\"", n);
        print(" %ld", n->xoffset);
        i = 0;
        break;
    case ODOT:
    case OELEM:
        print(" \"%F\"", n);
        break;

    case OREGISTER:
        if(n->xoffset)
            print(" %ld+R%d", n->xoffset, n->reg);
        else
            print(" R%d", n->reg);
        i = 0;
        break;
    case OINDREG:
        print(" %ld(R%d)", n->xoffset, n->reg);
        i = 0;
        break;

    }

    if(n->type != T)
        print(" %T", n->type);

    if(n->addable != 0)
        print(" <%d>", n->addable);
    if(n->complex != 0)
        print(" (%d)", n->complex);

    print(" %L\n", n->lineno);

    if(i & 2)
        prtree1(n->left, d, true);
    if(i & 1)
        prtree1(n->right, d, true);
}
@


\section{[[5c -v]], verbose mode}

% see diag(), with -v it will print == diagnostic == and then the AST dump
% via prtree() when there is an error. Pretty useful to get more
% information about the error.

\section{Preprocessing debugging}

\subsection{[[5c -m]], macro debugging}
% also in Assembler.nw

<<[[dodefine()]] debug>>=
if(debug['m'])
    print("#define (-D) %s %s\n", s->name, s->macro+1);
@
% plus 1 because first byte is for nbargs.

<<[[macdef()]] debug>>=
if(debug['m'])
    print("#define %s %s\n", s->name, s->macro+1);
@



<<[[macexpand()]] debug macro expansion>>=
if(debug['m'])
    print("#expand %s %s\n", s->name, ob);
@


\subsection{[[5c -e]], file inclusion debugging}

% s is name of file (or "<stdin>")

<<[[newfile()]] debug>>=
if(debug['e'])
    print("%L: %s\n", lineno, s);
@
%ocaml: -debug_inclusion is clearer

\subsection{[[5c -f]], line information debugging}
% also in Assembler.nw

<<[[linehist()]] debug>>=
if(debug['f'])
    if(f) {
        if(offset)
            print("%4ld: %s (#line %d)\n", lineno, f, offset);
        else
            print("%4ld: %s\n", lineno, f);
    } else
        print("%4ld: <pop>\n", lineno);
@

\section{Parsing debugging}

\subsection{[[5c -L]], printing names}
%actually Lexing debugging

<<[[yylex()]] in talph case, debug symbol>>=
if(debug['L'])
    print("%L: %s\n", lineno, symb);
@


\subsection{[[5c -d]], printing declarations}
% useful to debug, potentially useful to build tools too! e.g. tags file
% also print when revert a decl in revertdcl()

% can see the result of evaluation of constant! (see const_expr.c)

<<[[dodecl()]] debug declaration>>=
if(debug['d'])
    dbgdecl(s);
@

<<[[dcllabel()]] debug declaration>>=
if(debug['d'])
    dbgdecl(s);
@

<<[[doinit()]] debug declaration>>=
if(debug['d'])
    dbgdecl(s);
@

<<[[doenum()]] debug declaration>>=
if(debug['d'])
    dbgdecl(s);
@

% labels
<<function dbgdecl>>=
void
dbgdecl(Sym *s)
{
    print("decl \"%s\": C=%s [B=%d:O=%ld] T=%T\n",
        s->name, cnames[s->class], s->block, s->offset, s->type);
}
@


<<[[revertdcl()]] debug revert DSUE>>=
if(debug['d'])
    print("revert2 \"%s\"\n", s->name);
@

<<[[revertdcl()]] debug revert DLABEL>>=
if(debug['d'])
    print("revert3 \"%s\"\n", s->name);
@

<<[[revertdcl()]] debug revert DAUTO>>=
if(debug['d'])
    print("revert1 \"%s\"\n", s->name);
@

\section{Typing debugging}

\subsection{[[5c -t]], printing expression type trees}
% before and after different phases


<<[[complex()]] debug tree pre complex>>=
if(debug['t'])
    if(n->op != OCONST)
        prtree(n, "pre complex");
@

<<[[complex()]] debug tree after tcom and comma>>=
if(debug['t'])
    if(n->op != OCONST)
        prtree(n, "t complex");
@
<<[[complex()]] debug tree after ccom>>=
if(debug['t'])
    if(n->op != OCONST)
        prtree(n, "c complex");
@
<<[[complex()]] debug tree after acom>>=
if(debug['t'])
    if(n->op != OCONST)
        prtree(n, "a complex");
@
<<[[complex()]] debug tree after xcom>>=
if(debug['t'])
    if(n->op != OCONST)
        prtree(n, "x complex");
@
\section{Code generation debugging}

\subsection{[[5c -G]], printing processed opcodes}

<<[[gen()]] debug opcode>>=
if(debug['G'] && (o != OLIST))
    print("%L %O\n", nearln, o);
@

\subsection{[[5c -g]], printing code generation information}
% for gins, gopcode, gen, cgen, sugen, ... print lhs and rhs

% print either resulting Prog (in gins, gopcode), or
% print Nodes

% can mix -G and -g to have title and the content?

<<[[cgenrel()]] debug>>=
if(debug['g']) {
    prtree(nn, "cgen lhs");
    prtree(n, "cgen");
}
@

<<[[boolgen()]] debug>>=
if(debug['g']) {
    prtree(nn, "boolgen lhs");
    prtree(n, "boolgen");
}
@

<<[[gins()]] debug>>=
if(debug['g'])
    print("%P\n", p);
@

<<[[gopcode()]] debug>>=
if(debug['g'])
    print("%P\n", p);
@

<<[[lcgen()]] debug>>=
if(debug['g']) {
    prtree(nn, "lcgen lhs");
    prtree(n, "lcgen");
}
@

<<[[sugen()]] debug>>=
if(debug['g']) {
    prtree(nn, "sugen lhs");
    prtree(n, "sugen");
}
@

\subsection{[[5c -S]], printing generated assembly}

<<[[outcode()]] debug>>=
if(debug['S']) {
    for(p = firstp; p != P; p = p->link)
        if(p->as != ADATA && p->as != AGLOBL)
            pc--;
    for(p = firstp; p != P; p = p->link) {
        print("%P\n", p);
        if(p->as != ADATA && p->as != AGLOBL)
            pc++;
    }
}
@
% %P dumper


% coupling with 5.out.h, autogenerated via mkenam script
<<global anames(arm)>>=
char*	anames[] =
{
    "XXX",
    "NOP",
    "AND",
    "ORR",
    "EOR",
    "BIC",
    "ADD",
    "SUB",
    "RSB",
    "ADC",
    "SBC",
    "RSC",
    "MVN",
    "MUL",
    "DIV",
    "MOD",
    "MULA",
    "MULL",
    "MULAL",
    "MULLU",
    "MULALU",
    "MULU",
    "DIVU",
    "MODU",
    "SLL",
    "SRL",
    "SRA",
    "MOVW",
    "MOVB",
    "MOVBU",
    "MOVH",
    "MOVHU",
    "MOVM",
    "SWPW",
    "SWPBU",
    "CMP",
    "TST",
    "TEQ",
    "CMN",
    "B",
    "BEQ",
    "BNE",
    "BHS",
    "BLO",
    "BMI",
    "BPL",
    "BVS",
    "BVC",
    "BHI",
    "BLS",
    "BGE",
    "BLT",
    "BGT",
    "BLE",
    "BL",
    "RET",
    "SWI",
    "RFE",
    "MOVWD",
    "MOVWF",
    "MOVDW",
    "MOVFW",
    "MOVFD",
    "MOVDF",
    "MOVF",
    "MOVD",
    "CMPF",
    "CMPD",
    "ADDF",
    "ADDD",
    "SUBF",
    "SUBD",
    "MULF",
    "MULD",
    "DIVF",
    "DIVD",
    "SQRTF",
    "SQRTD",
    "TEXT",
    "GLOBL",
    "DATA",
    "WORD",
    "END",
    "NAME",
    "HISTORY",
    "CASE",
    "BCASE",
    "SIGNAME",
    "GOK",
    "DYNT",
    "INIT",
    "LAST",
};
@
%ocaml: use ocamltarzan



\section{Optimization debugging}

\subsection{[[5c -m]], printing arithmetic trees}
% should choose another one!! -m is already used for debugging macros

\subsection{[[5c -r]], printing registerization}


\section{[[5c -i]], printing initializations}

<<[[doinit()]] debug initialization>>=
if(debug['i']) {
    print("t = %T; o = %ld; n = %s\n", t, o, s->name);
    prtree(a, "doinit value");
}
@

<<[[init1()]] debug initialization>>=
if(debug['i']) {
    print("t = %T; o = %ld; n = %s\n", t, o, s->name);
    prtree(a, "init1 value");
}
@

<<[[contig()]] debug initialization>>=
if(debug['i']) {
    print("contig v = %ld; s = %s\n", v, s->name);
    prtree(n, "doinit value");
}
@


\chapter{Error Management}
%assembler: very similar


<<global nerrors>>=
int	nerrors;
@

\subsection{[[errorexit()]]}

% main | compile | newio | newfile | yylex | ... -> <>
<<function errorexit>>=
void
errorexit(void)
{
    if(outfile)
        remove(outfile);
    exits("error");
}
@
% good citizen! no need for :D: in mkfile then, file is removed
% if there was an error!

\subsection{[[yyerror()]]}

% syntax error
<<function yyerror>>=
void
yyerror(char *fmt, ...)
{
    char buf[STRINGSZ];
    va_list arg;

    <<[[yyerror()]] when called from yyparse>>

    va_start(arg, fmt);
    vseprint(buf, buf+sizeof(buf), fmt, arg);
    va_end(arg);

    Bprint(&diagbuf, "%L %s\n", lineno, buf);
    nerrors++;

    if(nerrors > 10) {
        Bprint(&diagbuf, "too many errors\n");
        errorexit();
    }
}
@
%ocaml: call errorexit directly, do not do any error recovery

% %L will use Lconv!


<<[[yyerror()]] when called from yyparse>>=
/*
 * hack to intercept message from yaccpar
 */
if(strcmp(fmt, "syntax error") == 0) {
    yyerror("syntax error, last name: %s", symb);
    return;
}
@
% useful to print last symbol token.


\subsection{[[diag()]]}

% -> <>
<<function diag>>=
void
diag(Node *n, char *fmt, ...)
{
    char buf[STRINGSZ];
    va_list arg;

    va_start(arg, fmt);
    vseprint(buf, buf+sizeof(buf), fmt, arg);
    va_end(arg);

    Bprint(&diagbuf, "%L %s\n", (n==Z)? nearln: n->lineno, buf);

    <<[[fatal() or diag()]] abort if -X>>
    <<[[fatal() or diag()]] print diagnostic if -v>>
    nerrors++;
    if(nerrors > 10) {
        Bprint(&diagbuf, "too many errors\n");
        errorexit();
    }
}
@

% also warn()



\subsection{[[fatal()]]}

% code generation stuff -> <>
<<function fatal>>=
void
fatal(Node *n, char *fmt, ...)
{
    char buf[STRINGSZ];
    va_list arg;

    va_start(arg, fmt);
    vseprint(buf, buf+sizeof(buf), fmt, arg);
    va_end(arg);
    Bprint(&diagbuf, "%L %s\n", (n==Z)? nearln: n->lineno, buf);

    <<[[fatal() or diag()]] abort if -X>>
    <<[[fatal() or diag()]] print diagnostic if -v>>
    nerrors++;
    errorexit();
}
@
% %L will use Lconv to have right location

<<[[fatal() or diag()]] abort if -X>>=
if(debug['X']){
    Bflush(&diagbuf);
    abort();
}
@

<<[[fatal() or diag()]] print diagnostic if -v>>=
if(n != Z)
  if(debug['v'])
    prtree(n, "diagnostic");
@





\subsection{Error location}

<<[[cinit()]] fmtinstall>>=
fmtinstall('L', Lconv);
@


<<constant HISTSZ>>=
#define	HISTSZ		20
@

<<struct Atab>>=
struct Atab
    {
        Hist*	incl;	/* start of this include file */
        long	idel;	/* delta line number to apply to include */
        Hist*	line;	/* start of this #line directive */
        long	ldel;	/* delta line number to apply to #line */
};
@

% location!
%assembler: similar to prfile() but used via %L e.g. in yyerror
<<function Lconv>>=
// int -> string?
int
Lconv(Fmt *fp)
{
    char str[STRINGSZ], s[STRINGSZ];
    Hist *h;
    long l, d;
    int i, n;
    struct Atab  a[HISTSZ];

    l = va_arg(fp->args, long);
    n = 0;
    for(h = hist; h != H; h = h->link) {
        if(l < h->line)
            break;
        if(h->name) {
            if(h->offset != 0) {		/* #line directive, not #pragma */
                if(n > 0 && n < HISTSZ && h->offset >= 0) {
                    a[n-1].line = h;
                    a[n-1].ldel = h->line - h->offset + 1;
                }
            } else {
                if(n < HISTSZ) {	/* beginning of file */
                    a[n].incl = h;
                    a[n].idel = h->line;
                    a[n].line = 0;
                }
                n++;
            }
            continue;
        }
        n--;
        if(n > 0 && n < HISTSZ) {
            d = h->line - a[n].incl->line;
            a[n-1].ldel += d;
            a[n-1].idel += d;
        }
    }
    if(n > HISTSZ)
        n = HISTSZ;
    str[0] = 0;
    for(i=n-1; i>=0; i--) {
        if(i != n-1) {
            if(fp->flags & ~(FmtWidth|FmtPrec))	/* BUG ROB - was f3 */
                break;
            strcat(str, " ");
        }
        if(a[i].line)
            snprint(s, STRINGSZ, "%s:%ld[%s:%ld]",
                a[i].line->name, l-a[i].ldel+1,
                a[i].incl->name, l-a[i].idel+1);
        else
            snprint(s, STRINGSZ, "%s:%ld",
                a[i].incl->name, l-a[i].idel+1);
        if(strlen(s)+strlen(str) >= STRINGSZ-10)
            break;
        strcat(str, s);
        l = a[i].incl->line - 1;	/* now print out start of this file */
    }
    if(n == 0)
        strcat(str, "<eof>");

    return fmtstrcpy(fp, str);
}
@







\chapter{Libc}

\section{Memory management}
% same in Linker/assembler, not sure why they just don't use malloc?
% to avoid dependencies to libc? for bootstrapping reasons? because
% compiler anyway never frees so can optimize things?

<<constant NHUNK>>=
#define	NHUNK		50000L
@

<<global hunk>>=
char*	hunk;
@

<<global nhunk>>=
long	nhunk;
@

<<global thunk>>=
long	thunk;
@

<<[[cinit()]] memory globals initialization>>=
nhunk = 0;
@


<<function gethunk>>=
void
gethunk(void)
{
    char *h;
    long nh;

    nh = NHUNK;
    if(thunk >= 10L*NHUNK)
        nh = 10L*NHUNK;

    h = (char*)sbrk(nh);
    if(h == (char*)-1) {
        yyerror("out of memory");
        errorexit();
    }
    hunk = h;
    nhunk = nh;
    thunk += nh;
}
@
% sbrk! raw memory management

<<constant MAXALIGN>>=
#define	MAXALIGN	7
@

<<function alloc>>=
/*
 * real allocs
 */
void*
alloc(long n)
{
    void *p;

    while((uintptr)hunk & MAXALIGN) {
        hunk++;
        nhunk--;
    }
    while(nhunk < n)
        gethunk();
    p = hunk;
    nhunk -= n;
    hunk += n;
    return p;
}
@

<<function allocn>>=
void*
allocn(void *p, long on, long n)
{
    void *q;

    q = (uchar*)p + on;
    if(q != hunk || nhunk < n) {
        while(nhunk < on+n)
            gethunk();
        memmove(hunk, p, on);
        p = hunk;
        hunk += on;
        nhunk -= on;
    }
    hunk += n;
    nhunk -= n;
    return p;
}
@


<<function malloc>>=
/*
 * fake mallocs
 */
void*
malloc(ulong n)
{
    return alloc(n);
}
@

<<function free>>=
void
free(void*)
{
}
@
% hmm so no free ... maybe ok in a compiler context?

<<function setmalloctag>>=
//@Scheck: looks dead, but because we redefine malloc/free we must also redefine that
void setmalloctag(void*, ulong)
{
}
@


\section{String management}

% STRINGSZ here

\section{Bit operations}

% see also Bits structure

<<function topbit>>=
int
topbit(ulong v)
{
    int i;

    for(i = -1; v; i++)
        v >>= 1;
    return i;
}
@

<<function bitno>>=
int
bitno(long b)
{
    int i;

    for(i=0; i<32; i++)
        if(b & (1L<<i))
            return i;
    diag(Z, "bad in bitno");
    return 0;
}
@
% >>

<<function SIGN>>=
#define	SIGN(n)		(1ULL<<(n-1))
@
% >>
<<function MASK>>=
#define	MASK(n)		(SIGN(n)|(SIGN(n)-1))
@

\section{Mathematic functions}

% use diag so could not really be put in libc
<<function round>>=
long
round(long v, int w)
{
    int r;

    if(w <= 0 || w > 8) {
        diag(Z, "rounding by %d", w);
        w = 1;
    }
    r = v%w;
    if(r)
        v += w-r;
    return v;
}
@



<<function log2>>=
/*
 * return log(n) if n is a power of 2 constant
 */
int
log2(uvlong v)
{
    int s, i;
    uvlong m;

    s = 0;
    m = MASK(8*sizeof(uvlong));
    for(i=32; i; i>>=1) {
        m >>= i;
        if(!(v & m)) {
            v >>= i;
            s += i;
        }
    }
    if(v == 1)
        return s;
    return -1;
}
@

\section{Key/value data structure}

% mostly helper structure to build a  hash<enum<xxx>,string> to debug
%  enums values
% most of the time value is 0 and unused as people just want a int -> string
%less: they could use array designator though to get the same effects.
<<struct Init>>=
struct	Init			/* general purpose initialization */
{
    int		code;
    ulong	value;
    char*	s;
};
@

\section{Portability}

<<enum os>>=
enum os				/* also in ../{8a,5a,0a}.h */
{
    Plan9	= 1<<0,
    Unix	= 1<<1,
    //Windows	= 1<<2,
};
@

%%%\chapter{[[5c]] in OCaml}
% oh yeah!

\chapter{Extra Code}

\ifallcode
#include "Compiler_extra.nw"
\fi

%\chapter{Changelog}
% code via make loc = 22356 LOC
% orig Compiler.nw = 26884, just lpized and few comments, ?? pages pdf
% now: =~ ??? LOC so added ??? LOE (Lines of explanations)
% 5c in ocaml: ?? LOC 




\chapter*{Glossary}
\addcontentsline{toc}{chapter}{Glossary}
\label{sec:glossary}

\begin{verbatim}
SUE = Structure/Union/Enum
SU  = Structure/Union
\end{verbatim}



\chapter*{Indexes}
\addcontentsline{toc}{chapter}{Index}

%\chapter{References} 
\addcontentsline{toc}{chapter}{References}

\bibliography{../docs/latex/Principia}
\bibliographystyle{plain}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
