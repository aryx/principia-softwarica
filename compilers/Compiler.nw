\documentclass[twocolumn]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse % see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history:
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things:
% - deadcode (TFILE, OFAS, OTST, OENUM, CSELEM, CLABEL)
% - rename more consistently things (thisfn->thisfntype, lastdcl->lastdcltype)

%thx to codemap/codegraph/scheck:
% - use cg to reduce backward deps, introduce globals.c, utils.c,
%   saw cc/pgen.c depends on gc.h! so not same category than cc/bits.c => cc2/
%   (harder to understand non layered code)
% - TODO use cg to reduce number of globals by moving them closer to the
%   relevant file (or even function), better cluster the code
%   (harder to understand non functional code using lots of globals)
% - use scheck to remove deadcode useless export, or mv as forward decl
%   (harder to understand big interface files)
% - saw duplication between cc.h and aa.h

%thx to this manual, better understand compilers and C:
% - TODO assignment of structures?
% - TODO x++ and ++x in complex situations
% - TODO initialisation of complex globals, e.g. znode, all fields set to 0?

%history LP-ization:
% - skeleton, mostly copy paste of Template.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * TODO ctor/dtor, dumper
%    * [[xxx]] other fields, [[xxx]] extra fields
% - read Extra section, identify concepts, first TOC
% - distribute parts of the Extra section in the main file
% - understand main(), LP split main, improve TOC
% - understand main functions, LP split, cluster, improve TOC
% - SEMI LP split the structures, use datalog to see what flows into fields
% - SEMI nullify, boolify, enumify,  typeify,    scheckify, plan9ify
% - SEMI aspecify advanced features! remove useless features
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\iffinal
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\fi
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
%\usepackage{cleveref} %\cref
%\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}
 %\usepackage[margin=0.5in]{geometry}
 %  but eat the bottom when very low
 %\usepackage{fullpage} is deprecated 
 % => do the more manual below:
 \addtolength{\oddsidemargin}{-.850in}
 \addtolength{\evensidemargin}{-.850in}
 \addtolength{\textwidth}{1.70in}
 \addtolength{\topmargin}{-.850in}
 \addtolength{\textheight}{1.70in}
%\usepackage{minitoc}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% used for forward decl, pragmas, func decl, extern decl, stats, #ifdef,
% debugging macros

%\setcounter{tocdepth}{1}

%******************************************************************************
% Title
%******************************************************************************

\begin{document}

\title{
{\Huge 
Principia Softwarica: The Plan9 C Compiler [[5c]]
}\\
ARM (32 bits) edition\\
{version 0.1}
}
%alt: 8c x86 (32 bits) edition, see Compiler_x86.nw

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}
}

\maketitle 
\onecolumn
\hrule
\begin{quote}
    Copyright \copyright{} 2014, 2015 Yoann Padioleau \\
    Permission is granted to copy, distribute and/or modify this document,
    except all the source code it contains, under the terms of the GNU Free
    Documentation License, Version 1.3.
\end{quote}
\hrule

%CONFIG: \dominitoc

\iffinal
\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\twocolumn
\tableofcontents
\endgroup
\else
\tableofcontents
\fi

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

\section{Motivations}

The goal of this book is to present in full details the source code of
a C compiler.
Why? Because I think it makes you a better programmer if
you fully understand how things work under the hood.

% gonna present 5c (aka kencc), from ken thompson! simple.
% a nice bonus also is that it has some very nice lint checks
% e.g. dataflow 'variable set but not used'.

% why C?
% http://damienkatz.net/2013/01/the_unreasonable_effectiveness_of_c.html ?

% some cons though to use 5c: no CFG, no IL ... very imperative ... harder case
% to defend than for the other software (5a, 5l, kernel, rio)
% but has good linting at least :) used/set warnings :)

Here are other candidates that were considered but ultimately discarded:
\begin{itemize}
\item tiger
% not real, not C, but more educatif and better written for teaching purpose
% (actually can maybe refer to govereau book?)
\item lcc 
%maybe better actually, but already a book on it
% but seems to not use yacc (or lex)
\item compcert
% harder to understand coq :), but definitly better IL and CFG I think.
\item tinycc, fbcc
% cool maybe
\item cminusminus
% maybe a good idea to also present c--
\item gcc
%big
\item clang
%cleaner but still very big
% nice to have single binary that can cross compile for multiple targets, nice
% interface (cleaner than 5c/vc/...; interfaces are better!)
\item rust
% Maybe rust could replace C one day, but we are not there yet
% and Rust is more complicated than C. Actually rust
% uses C :)
\end{itemize}

% other languages? yes could be nice, but really you need to
% show asm and C first. That's the basis. 

% TODO bench 5c vs gcc and clang on benchmarks!

%with flex/bison/llvm
%http://gnuu.org/2009/09/18/writing-your-own-toy-compiler/all/1/

% other: 
% - http://sdcc.sourceforge.net/ for microcontrollers
%    also includes assembler, debugger, simulator, ...
% - https://github.com/rui314/8cc
%   but no yacc
% - http://nwcc.sourceforge.net/
% - PCC

% a few tags used in this file
% - codegen: to give a preview of how a C construct is translated to ASM
% - ocaml: to give a hint on how rewriting C in OCaml could improve things

\section{Getting started}

\section{Requirements}

% actually the code presented below is written in C so you
% need to understand C :)

% You need to have a vague idea of how works a compiler. 
% Have read Dragon book. Appel. Or other books.

%``the compiler assumes you've know your Aho and Ullman either by'
%reading them or by working with them.''
% - charles forsith on 9fans

% comp.ps, [8]5c man pages, etc

% Also assumes Assembler.nw for ARM. Helps to understand
% the target (especially since there is no RTL so the code
% generation part directly generates concrete ASM code)

\section{About this document}
#include "../docs/latex/About.nw"

\section{Copyright}

Most of this document is actually source code from Plan9, so
those parts are copyright by Lucent Technologies Inc.
The prose is mine and is licensed under the GNU Free Documentation
License.

\section{Acknowledgments}

% ken :)
% mireille ducasse, marie jo pedrono
% Aho, Appel

\chapter{Overview}

\section{Compiler principles}

% from high level to low level (asm). 

% expression like x+y*z decomposed into multi mov, add, etc. Fortran!
% same for data, complex decomposed into smaller bytes, with symbolic names
%  for subparts, e.g. fields.
% statements, more structured forms than jmp.
% types! typechecking! (5c even adds some simple dataflow checks!)
%  so can type check arguments vs parameters, their numbers, array access,
%  field access, more restricted register indexing (xxx) -> *xxx but only 
%  if makes sense.
%  (still have lots of room to improve even more, C could be more typed!
%   see rust, and ocaml).
% => see codegen: tag

% innovation of C vs fortran/pascal/algol? 
%  - pointer arithmetic? (but also a bad thing to have such wild pointers)
%  - simpler?
%  - bitfields? so can match more directly hardware specifics?

% will present frontend, and backend.

\section{[[5c]] services}

% see all the flags, put here main flags

% source language: C
% implementation language: C
% target language: assembly ARM

% not put here originally: 
% -g (in genxxx()) print lhs and rhs in many contexts
%  and also print instruction generated by gins and gopcode
% -G (in gen()) 
% -Z, -f ??
% -N -R -P in regopt()
%   -N disable regopt
%   -R enable it back, print debugging info, disable peep()
%   -P reenable peep() and print debugging info
% -T in zname to generate ASIGNAME (can be disabled by some pragma apparently)
%   so can have safe linking
% -x,   pad: dump AST
% -c, if(constant) warning


%OUTOUT
% *	-o file		output file
% *	-S		print assembly
% *	-l		generate little-endian code (mips only)


%WARNINGS
% *	-w		print warnings
% *	-V		enable void* conversion warnings
% *	-X		abort on error
% *	-F		format specification check

%LANGUAGE
% *	-A		!B
% *	-B		non ANSI

%PREPROCESSOR
% *	-p		use standard cpp ANSI preprocessor (not on windows)
% *	-D name		define
% *	-I path		include
% *	-.		Inhibit search for includes in source directory

%DEBUGGER
% *	-a		acid declaration output
% *	-n		print acid to file (%.c=%.acid) (with -a or -aa)
% *	-Z		pickle output (pad: was not mentioned originally)
% *	-s		print structure offsets (with -a or -aa)

%DEBUGGING
% *	-v		verbose printing
% *	-d		print declarations
% *	-L		print every NAME symbol
% *	-m		print add/sub/mul trees
%            pad: also macro debugging??
% *	-f		line information debugging (pad: was not mentioned originally)
% *	-r		print registerization
% *	-t		print type trees
%    pad: debug the many phases in bcomplex()
% *	-i		print initialization
% * -g -G      print stuff for code gen (pad: was not mentioned originally)

% *	-M		constant multiplication

%in mkfile.proto:
%8c -FTVw -I/home/pad/plan9/include/386 -I/home/pad/plan9/include globals.c
% -F format check, -T safe linking, -V enable void* warnings, -w print warnings

\section{[[helloworld.c]]}

% (at least put an arithmetic expression?)

\section{Input C language}

% mostly ANSI C. a few extensions.
% see K&R book.

% TODO add __LINE__? 
% TODO add check for code not using return value (e.g.
%  in xdecl rule where call dodecl() which returns a node).

% C vs assembly? typechecking! more structured, formulas, etc.
% see codegen: again.

% "who says C is simple"
%http://www.eecs.berkeley.edu/~necula/cil/cil016.html

\section{Output object format}

% assembly ARM object code. Very close to ARM machine code.
% (can get asm generated via 5c -S)

% put code for helloworld.c generated code?

\section{ARM}

\section{Code organization}

% use a lot include/arm/5.out.h
% and actually stuff defined in 5.out.h are used
% exclusively by 5c e.g. REGRET, REGTMP, and also ACASE, etc

% ------------

% cc.h (vs gc.h (not garbage collector, g for? nongeneric? generation? hmmm))
% no lex (handcrafted lex.c), yacc (cc.y, y.tab.h, y.tab.c)
%  (why no lex? to avoid bootstrapping issues?)
%  mac.c = macro (included cpp)
% globals.c, utils.c, compat.c

% sub.c = subroutines, helpers to build ast (and more?)

% bits.c
% pickle.c

% acid.c = debugger support

% dpchk.c? pragma related? dpchk? check something? directive pragma check?
%  the argchk fmt printfstyle checks?

% com.c = compile (not comment), com64 for 64 bits stuff (for vlong)
%  dcl.c = declarations (dodecl, xdecl, adecl, markdcl/revertdcl, etc)
%  funct.c = ?? seems related to typestr
%  swt.c = switch? (pswt = portable part of switch handling)
%   (but then why outcode, outhist is in this file? TODO move it elsewhere!)
%  scon.c =  ? constants expr? s?

% -----------

% gc.h (g? [code] generation?)
% globals2.c (but actually many of them seems generic and could be in globals.c)
% list.c = fmt.c (TODO rename)
% machcap.c, omachcap.c = machine capability (attempt to have interface)
%  but for ARM it's empty.

% txt.c?
% xxxgen = sgen? cgen? (pgen.c = portable part of gen? sgen? cgen?)
% mul.c, div.c = optimized code for div/mul
% peep.c = peep optimizer, on assembly!
% reg.c = register, on assembly! but the Reg structure itself
%  seems actually generic.

% a few conventions? see glossary!

\section{Software architecture}

% see lex.c#main()! have command line flags in comment

% lexer -> preprocessor -> parser -> ast -> visit and gen assembly -> opti
%  -> object ARM code.
% with optimisations done?
% no CFG :( no IL. Register allocator optimizer is done via peep?
% vs tiger book?

% main -> compile -> yyparse -> yylex -> macxxx
%                            -> codgen (portable) -> gen(stmt) -> cgen(expr)
%                                                 -> regopt -> peep
%                 -> gclean -> outcode

% AST level opti, assembly level opti

% "the compiler works by a series of tree
% transformations, informed by attributes
% attached to each node, representing
% types, notional costs, addressability,
% and other ... stuff.
% - charles forsith on 9fans

\section{Bootstrapping}

% diagram en T? reference recent Go bootstrapping effort?

%###############################################################################

\chapter{Core Data Structures}

\section{Abstract syntax tree, [[Node]] and [[Type]]}
% vs what I have in ast_c.ml?

% need to represent program in memory. propram is essentially
% a tree of expr|stmt|... with different kinds of nodes.

%figure: AST concept, tree of expression 1+2*3, with OCONST, OADD, OMUL.
% simple.

\subsection*{[[Node]]}
% = expr + stmt + decl + func def
% the type definitions and uses are in another DS (Type).

<<enum node_kind>>=
enum node_kind
{
    OXXX,

    // ----------------------------------------------------------------------
    // Names
    // ----------------------------------------------------------------------
    ONAME, // for defs and uses

    // ----------------------------------------------------------------------
    // Expressions
    // ----------------------------------------------------------------------
    <<expression nodes>>

    // ----------------------------------------------------------------------
    // Statements
    // ----------------------------------------------------------------------
    <<statement nodes>>

    // ----------------------------------------------------------------------
    // Variables (locals, globals, parameters)
    // ----------------------------------------------------------------------
    <<variable declaration nodes>>

    // ----------------------------------------------------------------------
    // Definitions
    // ----------------------------------------------------------------------
    <<definition nodes>>

    // ----------------------------------------------------------------------
    // Misc
    // ----------------------------------------------------------------------
    <<misc nodes>>

    // ----------------------------------------------------------------------
    // Post parsing nodes
    // ----------------------------------------------------------------------
    <<after parsing nodes>>

    OEND
};
@
%old: I reorged a lot. This type is purely internal to cc, it is not
% marshalled, so it is easy to reorder (as opposed to 5.out.h opcode type
% which is a bit more difficult)
%dead: OTST,		/* used in some compilers */
%dead: OFAS

<<struct Node>>=
struct	Node
{
    // enum<node_kind>
    char	op;

    // option<ref_own<Node>>
    Node*	left;
    // option<ref_own<Node>>
    Node*	right;

    long	lineno;

    <<[[Node]] value fields>>

    // ----------------------------------------------------------------------
    // Post parsing annotations
    // ----------------------------------------------------------------------
    <<[[Node]] type and storage fields>>

    <<[[Node]] code generation fields>>

    <<[[Node]] origin tracking fields>>

    // ----------------------------------------------------------------------
    // Misc
    // ----------------------------------------------------------------------
    <<[[Node]] parsing helper fields>>
};
@
%see also prtree() in debugging section to dump the AST, useful
% to understand which fields make sense for which node_kind!
% all the nodes with value fields have a case in prtree().
%less: char -> ushort? or actually char sometimes when use '+' ?
% hmm get some warnings though when do that, but maybe should fix those 
% warnings anyway
%still?: different split? identifier field where have sym and storage? 

% How things are represented for
% - OCONST: additional vconst and fconst field
% - OSTRING, OLSTRING: cstring and rstring fields
% - ONAME: additional sym field
%   (and xoffset later when param or local name)
% - OREGISTER, OINDREG: reg and xoffset
% - ODOT/OELEM: sym field
% - blocks? left/right used for many things, for left/right branch in e.g.
%   arithmetic trees (a+b), but also for linked list (e.g. OLIST) with
%   double chaining
%ocaml: note that ADT would be better again here.

<<constant Z>>=
#define	Z	((Node*)nil)
@

% put OLIST here, because it has many usages
<<misc nodes>>=
OLIST, // of stmts/labels/parameters/...  and also for pairs/triples/...
@
% add an OPAIR alias?
%ocaml: note that ADT would be better ...


% for nodes involving a symbol (entity used, field access)
% (and should have mutual reciproque?)
<<[[Node]] value fields>>=
Sym*	sym; // for ONAME, ODOT/OELEM, OSTRUCT/OUNION
@
% see Sym in next section







% for declaration nodes?
<<enum storage_class>>=
enum storage_class
{
    CXXX,

    CAUTO,
    CPARAM,
    CEXTERN,
    CGLOBL,
    CSTATIC,
    <<[[Storage_class]] cases>>

    NCTYPES,
};
@
% CSTATIC vs LSTATIC(lexeme) TSTATIC(temporary) vs BSTATIC(bitset of TSTATIC)
% see also cnames[] in debugging section
% strings are also using CSTATIC!
% have also CTYPEDEF here, so can have typedef trick in yylex().

% for declaration nodes?
<<[[Node]] type and storage fields>>=
// enum<storage_class>
char	class;
@




% for expression nodes?
<<[[Node]] code generation fields>>=
// address-able, used as a bool to mark lvalues, if can assign you can take
// the address of. used by xcom() to assign ``addressibility''.
// also (ab)used as a bool for to mark label uses (true = used in a goto)
char	addable;
@

% for expression nodes?
<<[[Node]] code generation fields>>=
// complexity in number of registers. for register allocation?
// also (ab)used as FNX special value
// also (ab)used as a bool to mark label definitions (true = already defined)
char	complex; 
@




% int -> char ... for op, hmmm
<<function new>>=
Node*
new(int t, Node *l, Node *r)
{
    Node *n;

    n = alloc(sizeof(Node));
    n->op = t;
    n->left = l;
    n->right = r;

    if(l && t != OGOTO)
        n->lineno = l->lineno;
    else if(r)
        n->lineno = r->lineno;
    else
        n->lineno = lineno;

    newflag = true;
    return n;
}
@
%less: newflag?
%less: why this special thing about OGOTO? becaus goto take a symbol
% and don't want the line of the symbol?

<<global lineno>>=
long	lineno;
@
% incremented in lexer


<<global nearln>>=
long	nearln;
@
% set in codgen() to the lineno field of the function node.
% this is useful for error reporting when use warn on an empty node,
% to at least give an error location not too far away.
% we can't use lineno in those cases because the parsing has been done,
% so lineno is set to the maximum line of the expanded file, hence
% nearln.
% nearln is also very useful for nextpc()! so that the generated
% assembly instructions are tied to related C code they are generated
% from! helps for the debugger!

<<function new1>>=
Node*
new1(int o, Node *l, Node *r)
{
    Node *n;

    n = new(o, l, r);
    n->lineno = nearln;
    return n;
}
@
% when needs this one? when create new intermediate node, e.g.
% in tcomo() during typechecking to make more explicit certain
% cast for instance, and when we are not sure there is something
% to base line upon (maybe l and r are empty).


<<global znode>>=
Node	znode;
@
 % set all fields to zero? why?

\subsection*{[[Type]]}

<<enum type_kind>>=
enum type_kind
{
    TXXX,

    <<type cases>>

    NTYPE,
};
@


% basic types
<<type cases>>=
TCHAR,
TUCHAR,
TSHORT,
TUSHORT,
TINT,
TUINT,
TLONG,
TULONG,
TVLONG,
TUVLONG,
TFLOAT,
TDOUBLE,
@
% C syntax for types is ugly, and allows many different schemes
% such as signed int; int; int signed; ... but in the end
% just have those 12 basic types!
%coupling: with the global 'tab' which use initialisers that
% assumes a certain order

<<type cases>>=
TVOID,
@

% composed types
<<type cases>>=
TIND,
TARRAY,
TFUNC,
TSTRUCT,
TUNION,
TENUM,
@
% IND for indirect probably, meaning pointer. C power!
% Note that even if array access are unsugar in pointer arithmetic access, 
% type declarations are not; we keep the array vs pointer info here.
% Note that no TYPEDEF!
%note that originally if you changed the order above then you 
% would get some segfaults in tests/5c and mk testall. This was
% because the code was using simple initialisers instead of array
% initialisers e.g. for the global 'tab'. I fixed it.



<<struct Type>>=
struct	Type
{
    // enum<type_kind>
    char	etype;

    // option<ref_own<Type>, e.g. for '*int' have TIND -link-> TINT
    Type*	link;
    // option<list<ref_own<Type>>, next = Type.down, just for OFUNC params
    Type*	down;

    long	lineno;

    <<[[Type]] value fields>>

    <<[[Type]] qualifier fields>>

    // ----------------------------------------------------------------------
    // Post parsing annotations
    // ----------------------------------------------------------------------
    <<[[Type]] code generation fields>>

    <<[[Type]] other fields>>
};
@
%less: char -> ushort? but get some warnings (but we should fix that too)

% Here are how things are represented for the different composed types:
%  - TVOID, simple, should actually be in the simple case
%  - TIND: simple, via link
%  - TARRAY: same? but for the size of it? not in type info?
%  - TSTRUCT/TUNION? link is empty at first for variables where
%    the structure has not yet been defined. Once the structure
%    is defined, or if it was defined before, the symbol for
%    this structure will link via suetag to a TSTRUCT type
%    where the link will have been set to the body of the struct.
%    how then represent the list of the fields? via down?
%  - TYPEDEF? they are not in enum type_kind! they are substitued
%    at use time? where?
%  - TFUNC: the return is in the link, the parameters in the down
%ocaml: note that ADT would be better again here.

% when type involves a symbol, e.g. for tags in struct/union/enum
<<[[Type]] value fields>>=
Sym*	sym; // for TSTRUCT/TUNION/TENUM
@



% for expression nodes?
% important field! typechecking! set in parsing when can
% (e.g. for cast where have type, for return where have also spec)
<<[[Node]] type and storage fields>>=
Type*	type;
@
% so it's more than an AST actually, there is semantic info attached to it
% by other phases.
% see Type in next section

% seems mostly inline of type->etype, except in fvn() and ccom()
<<[[Node]] type and storage fields>>=
// enum<type_kind>, inline of Node.type->etype?
char	etype;
@
%less: could remove? redundant no? annoying to maintain?
% annoying those n->etype = (s->type?): s->type->etype: TVOID;



% gxxx for 'garbage' but should be renamed qualifier
<<enum qualifier>>=
enum qualifier
{
    GXXX		= 0,

    GCONSTNT	= 1<<0,
    GVOLATILE	= 1<<1,

    NGTYPES		= 1<<2,

    GINCOMPLETE	= 1<<2,
};
@
% >> >> >> >>
% see also gnames in debugging section


<<[[Type]] qualifier fields>>=
// enum<qualifier>
char	garb;
@
% note that can be at different level! can have  const * const *x;
% tricky.
%less: rename qualifier

% storage class is not there! it's an attribute of the 
% variable, not of the type of the variable, so it's
% a node field.





<<constant T>>=
#define	T	((Type*)nil)
@

% constructor
% optional<ref_type> for d
<<function typ>>=
Type*
typ(int et, Type *d)
{
    Type *t;

    t = alloc(sizeof(Type));
    t->etype = et;
    t->link = d;
    t->down = T;
    t->garb = GXXX;
    t->sym = S;

    t->width = ewidth[et];

    t->offset = 0;
    t->shift = 0;
    t->nbits = 0;

    return t;
}
@
% see Size section for ewidth, LP split!

<<[[Type]] code generation fields>>=
long	width; // ewidth[Type.etype]
@
% semantic phase?


<<function copytyp>>=
Type*
copytyp(Type *t)
{
    Type *nt;

    nt = typ(TXXX, T); // could just do alloc(sizeof(Type))
    *nt = *t;
    return nt;
}
@


<<global types>>=
Type*	types[NTYPE];
@


<<[[cinit()]] types initialization>>=
types[TXXX] = T;

types[TCHAR] = typ(TCHAR, T);
types[TUCHAR] = typ(TUCHAR, T);
types[TSHORT] = typ(TSHORT, T);
types[TUSHORT] = typ(TUSHORT, T);
types[TINT] = typ(TINT, T);
types[TUINT] = typ(TUINT, T);
types[TLONG] = typ(TLONG, T);
types[TULONG] = typ(TULONG, T);
types[TVLONG] = typ(TVLONG, T);
types[TUVLONG] = typ(TUVLONG, T);
types[TFLOAT] = typ(TFLOAT, T);
types[TDOUBLE] = typ(TDOUBLE, T);
types[TVOID] = typ(TVOID, T);

types[TENUM] = typ(TENUM, T);
types[TFUNC] = typ(TFUNC, types[TINT]);
types[TIND] = typ(TIND, types[TVOID]);
@

% see also those typesets like typev[], typeint[], typesu[] etc
% that allows to quickly check if a type is part of a certain category.
% Explained more in Typechecking section.

% typxxx important conventions:
% c = char, h = short, v = vlong, fd = float/double, 
% su = struct union, af = array/func
% il = int/long
% ilp = integer long pointer
% chl = char/short/long
% chlp = char/short/long/pointer, 
% i = all integers, u = all unsigned, 
% suv = struct/union/vlong (big data)
 


\section{Symbol table, [[Sym]] and [[hash]]}
% another symbol table!

<<struct Sym>>=
struct	Sym
{
    // Symbolic names are used for: 
    //  - identifiers (locals/params/globals, functions, typedefs
    //    and also enum constants)
    //  - tags (struct/union/enum) 
    //  - labels (for the goto)
    //  - macros (the #define)
    //  - keywords lexeme (abuse)

    // ----------------------------------------------------------------------
    // The "key"
    // ----------------------------------------------------------------------
    char	*name;

    // ----------------------------------------------------------------------
    // The "value" for the different "namespaces"
    // ----------------------------------------------------------------------
    <<[[Sym]] identifier value fields>>
    <<[[Sym]] enum value fields>>
    <<[[Sym]] tag value fields>>
    <<[[Sym]] label value fields>>

    <<[[Sym]] macro value fields>>
    <<[[Sym]] lexeme value fields>>

    // ----------------------------------------------------------------------
    // Misc
    // ----------------------------------------------------------------------
    long	varlineno;

    // ----------------------------------------------------------------------
    // Extra
    // ----------------------------------------------------------------------
    <<[[Sym]] extra fields>>
};
@
%coupling: if add a field here, don't forget to update Decl too
% and especially its "sym copy fields" section

%namespace: it's the symbol table for different kind of names
% - identifier, see s->type, s->class, etc s->xoffset? x->block?
%   and for enum constants, see s->tenum, and s->vconst, s->fconst
% - tags, see s->suetag and s->sueblock
% - labels, see s->label
% - macro, see s->macros
%note that fields are not here as they are not in the global namespace.
%Does Sym handles well the different namespaces? What if struct and local
% with same name? It's not a union! the Decl value will determine
% which field to look for.
%Can have struct x x;
% it can be the same symbol, but in a struct context we will use
% Sym.suetag, in other context Sym.type!
% same for Sym.sueblock vs Sym.block.

% Similar to Assembler.nw and Linker.nw Sym DS. Differences?
%  - have labels, tags

% varlineno? why not simply lineno? To help indicate
% that it references the place where the symbol is defined?
% so for a struct xxx, it's the varlineno of the corresponding
% struct definition?





<<constant NHASH>>=
#define	NHASH		1024
@

<<global hash>>=
// hash<string, ref_own?<Sym>>, (next in bucket = Sym.link)
Sym*	hash[NHASH];
@

<<[[Sym]] extra fields>>=
// list<ref<Sym>> (next = Sym.link) bucket of hashtbl 'hash'
Sym*	link;
@

<<constant S>>=
#define	S	((Sym*)nil)
@


<<[[cinit()]] hash initialization>>=
for(i=0; i<NHASH; i++)
    hash[i] = S;
@





<<constant NSYMB>>=
#define	NSYMB		1500
@

<<global symb>>=
char	symb[NSYMB];
@


<<function lookup>>=
Sym*
lookup(void)
{
    Sym *s;
    ulong h;
    char *p;
    int c, n;

    h = 0;
    for(p=symb; *p;) {
        h = h * 3;
        h += *p++;
    }
    n = (p - symb) + 1;
    if((long)h < 0)
        h = ~h;
    h %= NHASH;

    c = symb[0];
    for(s = hash[h]; s != S; s = s->link) {
        if(s->name[0] != c)
            continue;
        if(strcmp(s->name, symb) == 0)
            return s;
    }
    s = alloc(sizeof(*s));
    s->name = alloc(n);
    memmove(s->name, symb, n);

    strcpy(s->name, symb);
    s->link = hash[h];
    hash[h] = s;
    syminit(s);

    return s;
}
@

<<function slookup>>=
Sym*
slookup(char *s)
{

    strcpy(symb, s);
    return lookup();
}
@



<<[[Sym]] identifier value fields>>=
<<[[Sym]] identifier value, type and storage fields>>
<<[[Sym]] identifier value, scope fields>>
<<[[Sym]] identifier value, checking fields>>
<<[[Sym]] identifier value, code generation fields>>
@


<<[[Sym]] identifier value, type and storage fields>>=
// ref<Type> ?
Type*	type;
// enum<storage_class>
char	class;
@
% similar to Node.type Decl.type, and now Sym.type
% note that this class field is then used by the lexer
% for the typedef trick!

<<[[Sym]] identifier value, scope fields>>=
ushort	block;
@
% see also Decl.block


<<[[Sym]] macro value fields>>=
char*	macro;
@

% for labels?
%  see later labels
% for tags?
%  see later suetag, sueblock


<<[[Sym]] lexeme value fields>>=
// enum<lexeme>
ushort	lexical;
@


<<function syminit>>=
void
syminit(Sym *s)
{
    s->lexical = LNAME;
    s->block = 0;
    s->offset = 0;

    s->type = T;
    s->class = CXXX;
    s->suetag = T;

    s->sig = SIGNONE;
    <<[[syminit()]] remaining initialisations>>
}
@




\section{Declarations, namespaces and scope, [[Decl]]}
% nested scope

% the different "namespaces"
<<enum dxxx>>=
enum namespace
{
    DMARK, // special mark to help separate the different lists

    DAUTO, // locals/parameters/globals/typedefs/functions identifiers
    DSUE,  // struct/union/enum tags
    DLABEL,// labels, goto
};
@
% this type is for the different C namespaces which are
%  identifier, sue tags, and labels. See K&R book?
% DAUTO(declaration?), TAUTO(temporary), LAUTO(lexeme), CAUTO(class), 
%  hmmm that's a lot of AUTO.
%todo: DAUTO is a bad name, DIDENT would be better no? and SUE -> DTAG?

<<struct Decl>>=
struct	Decl
{
    Sym*	sym;
    // enum<namespace>
    short	val;

    <<[[Decl]] sym copy fields>>

    // Extra fields
    <<[[Decl]] extra fields>>
};
@
%less: rename val? to kind? or namespace?

% have a sym copy fields, because when add an ident in a scope,
% we mask the previous one, but we want to remember the previous
% one when we exit the scope to restore it in the global symbol
% table.
%ocaml: should not use global symbol table maybe.

% stack because nested scopes
<<global dclstack>>=
// list<ref_own<Decl>> (next = Decl.link)
Decl*	dclstack;
@
%ocaml: but should have a list of list? ugly but do ia via DMARK
%see also firstdcl when parsing

<<[[Decl]] extra fields>>=
// list<ref_own<Decl> of dclstack
Decl*	link;
@

<<constant D>>=
#define	D	((Decl*)nil)
@

<<[[cinit()]] dclstack initialization>>=
dclstack = D;
@

<<function push>>=
Decl*
push(void)
{
    Decl *d;

    d = alloc(sizeof(Decl));
    d->link = dclstack;
    dclstack = d;
    return d;
}
@
% usage is d = push(); and then adjust d (usually d->val = DMARK
% as for symbol one prefers to use push1() instead of push() directly).

% save old value of a symbol, will be restored by revertdcl()
% until the next DMARK
<<function push1>>=
Decl*
push1(Sym *s)
{
    Decl *d;

    d = push();
    d->sym = s;
    d->val = DAUTO;

    <<[[push1()]] save symbol fields in decl>>

    return d;
}
@
% usage should be d = push1(s); and adjust s fields now that
% the old values of s has been saved??


% nested language! block number, to allow multiple blocks to use
% similar local names
<<global blockno>>=
int	blockno;
@

<<global autobn>>=
int	autobn;
@

<<[[cinit()]] namespace globals initialization>>=
blockno = 0;
autobn = 0;
autoffset = 0;
@
%what about autoffset?

<<function markdcl>>=
//@Scheck: used by cc.y
void markdcl(void)
{
    Decl *d;

    blockno++;

    d = push();
    d->val = DMARK;

    d->offset = autoffset;
    d->block = autobn;

    autobn = blockno;
}
@
% save current scope autobn, so can restore it when pop DMARK.

<<[[Decl]] sym copy fields>>=
Type*	type;  // for Sym.type and Sym.suetag
ushort	block; // for Sym.block and Sym.sueblock and autobn
long	offset; // for Sym.offset and autoffset
@
% this are sym copy fields and also copy of autobn and autooffset
% actually.

% where dealloc things? 
% - end of functions all labels attached to Sym of that name should be freed?
% - end of block

% at end of a scope we need to revert the decls of all local entities.
% related: dodecl()?
<<function revertdcl>>=
//@Scheck: used by cc.y
Node* revertdcl(void)
{
    Decl *d;
    Sym *s;
    Node *n;
    <<[[revertdcl()]] other locals>>

    n = Z;
    for(;;) {
        d = dclstack;
        if(d == D) {
            diag(Z, "pop off dcl stack");
            break;
        }
        // pop(declstack)
        dclstack = d->link;

        s = d->sym;
        switch(d->val) {
        <<[[revertdcl()]] switch declaration type cases>>
        }
    }
    return n;
}
@
% what is this Node n? why return a node? because when we revert
% a local volatile we actually generate some fake nodes USED(&local_volatile)
% so we need to return this OLIST of hidden generated nodes.

<<[[revertdcl()]] switch declaration type cases>>=
case DMARK:
    // restore info previous block
    autoffset = d->offset;
    autobn = d->block;
    // we popped everything, exit loop and return
    return n;
@
% return here! we don't want to go further


<<[[revertdcl()]] switch declaration type cases>>=
case DSUE:
    if(debug['d'])
        print("revert2 \"%s\"\n", s->name);

    // retore info previous tag
    s->suetag = d->type;
    s->sueblock = d->block;

    break;
@
%ugly: abuse of type and block a bit

<<[[revertdcl()]] switch declaration type cases>>=
case DLABEL:
    if(debug['d'])
        print("revert3 \"%s\"\n", s->name);

    <<[[reverdcl()]] DLABEL case, warn if label not used>>
    s->label = Z;
    break;
@
%less: no restore? probably because labels are at function scope
% and there is no global labels, so safe to set to Z.
% see dcllabels(), maybe they are not added in the current
% scope but the function scope?


<<[[revertdcl()]] switch declaration type cases>>=
case DAUTO:
    if(debug['d'])
        print("revert1 \"%s\"\n", s->name);

    <<[[reverdcl()]] DAUTO case, warn if auto declared but not used>>
    <<[[reverdcl()]] if volatile symbol>>
    // restore info previous identifier
    <<[[reverdcl()]] DAUTO case, restore symbol fields from decl>>

    break;
@


<<[[Decl]] sym copy fields>>=
char	class;
long	varlineno;
bool	aused;
@

<<[[reverdcl()]] DAUTO case, restore symbol fields from decl>>=
s->type = d->type;
s->offset = d->offset;
s->block = d->block;

s->class = d->class;
s->varlineno = d->varlineno;
s->aused = d->aused;
@


<<[[push1()]] save symbol fields in decl>>=
d->type = s->type;
d->offset = s->offset;
d->block = s->block;

d->class = s->class;
d->varlineno = s->varlineno;
d->aused = s->aused;
@





\section{[[Token]]}

<<union yacc>>=
%union  {
    vlong   vval;
    double  dval;
    struct
    {
        char*   s;
        long    l;
    } sval;

    Sym*    sym;

   <<[[union yacc]] other fields>>
}
@

% from cc.y
<<token declarations>>=
%token  <sym>   LNAME LTYPE
%token  <vval>  LCONST LUCONST  LLCONST  LULCONST   LVLCONST LUVLCONST
%token  <dval>  LFCONST LDCONST
%token  <sval>  LSTRING LLSTRING
@

<<token declarations>>=
%token  LVOID   LCHAR LSHORT LINT LLONG   LDOUBLE LFLOAT   LSIGNED LUNSIGNED
%token  LSTRUCT LUNION LENUM
%token  LTYPEDEF  
%token  LCONSTNT LVOLATILE  LRESTRICT LINLINE
%token  LAUTO LSTATIC LEXTERN LREGISTER
%token  LIF LELSE  LWHILE LDO LFOR  LBREAK LCONTINUE  LRETURN LGOTO
%token  LSWITCH LCASE LDEFAULT 
%token  LSIZEOF
@
% L for Lexeme probably
% so have LDOUBLE and TDOUBLE (and even BDOUBLE)




\section{Assembly output, [[Instruction]]}

% see Opcode and operand_kind in Assembler.nw
% (and Aconv, Rconv, Dconv, ... in this file)

% see also enum of 5.out.h with REGRET, REGARG, REGSP, REGTMP

<<struct Prog(arm)>>=
struct	Prog
{
    // enum<opcode>, from 5.out.h
    char	as;

    Adr	from;
    Adr	to;

    long	lineno; // of the corresponding line in the C program!

    <<[[Prog]] other fields(arm)>>

    // Extra
    <<[[Prog]] extra fields(arm)>>
};
@
% lineno! for debugger! so generated object file will contain
% line information of the C code.


% really ARM specific
<<[[Prog]] other fields(arm)>>=
// option<enum<registr>>, None = R_NONE, see 5.out.h
// abused also to represent TEXT or DATA attributes (e.g. NOPROF)
char	reg;
// bitset<?>
byte	scond;
@
%less: rename reg

<<struct Adr(arm)>>=
struct	Adr
{
    // enum<operand_kind> (D_NONE by default)
    char	type;

    long	offset; // generic value, offset or simple constant
    double	dval;
    char	sval[NSNAME];
    Ieee	ieee;

    <<[[Adr]] other fields(arm)>>
    <<[[Adr]] type fields(arm)>>
};
@
%less: use union for first 5?
%Similar to Gen in Assembler.nw and Adr in Linker.nw. Some differences?:
% - ??

<<constant A>>=
#define	A	((Adr*)nil)
@


<<[[Adr]] other fields(arm)>>=
// option<enum<registr>> None = R_NONE
char	reg;
@
%less: rename reg?


<<[[Adr]] other fields(arm)>>=
Sym*	sym;
// enum<sym_kind>
char	symkind;
@
%old: was name, but symkind is less confusing (did the same in
% Assembler.nw and Linker.nw)


<<global zprog>>=
Prog	zprog;
@

<<[[ginit()]] zprog initialisation>>=
zprog.link = P;
zprog.as = AGOK;
zprog.reg = R_NONE;
zprog.from.type = D_NONE;
zprog.from.symkind = D_NONE;
zprog.from.reg = R_NONE;
zprog.to = zprog.from;
zprog.scond = COND_ALWAYS;  
@
% will do lots of p = alloc(Prog); p = zprog; and starts from there.


% short tutorial ARM assembler? with D_OREG, etc?
% or just redirect people to Assembler.nw

%\section{[[firstp]], [[lastp]]}

%\section{[[reg]]}

\chapter{[[main()]]}

<<global thechar>>=
int	thechar;
@
% 5

<<global thestring>>=
char*	thestring;
@
% "arm"


<<global outfile>>=
char*	outfile;
@
% -o, 5.out?


<<[[main()]] locals>>=
int err;
int c;
@
%old: was called c

<<[[main()]] locals>>=
char **defs;
int ndef;
@
% the -Dxxx
%less: why have not something similar for Assembler.nw?

<<function main>>=
//@Scheck: not dead, entry point :)
void main(int argc, char *argv[])
{
    <<[[main()]] locals>>

    memset(debug, 0, sizeof(debug));

    tinit(); // type globals initialisation
    cinit(); // C lexing/parsing globals initialisation
    ginit(); // arch dependent globals initialisation, 5c/8c/...
    arginit(); // printf argument checking initialisation

    outfile = nil;

    defs = nil;
    ndef = 0;

    <<[[main()]] remaining initialisation>>

    setinclude(".");

    ARGBEGIN {
    <<[[main()]] command line processing>>
    } ARGEND

    if(argc < 1 && outfile == nil) {
        print("usage: %cc [-options] files\n", thechar);
        errorexit();
    }

    <<[[main()]] multiple files handling>>

    err = compile((argc == 0) ? "stdin" : argv[0], defs, ndef);

    if(err)
        errorexit();
    exits(nil);
}
@
% compile returns number of possible errors


<<[[ginit()]] initialisation>>=
thechar = '5';
thestring = "arm";
@




\section{Arguments processing}

<<[[main()]] command line processing>>=
case 'o':
    outfile = ARGF();
    break;
@



<<[[main()]] locals>>=
char **np;
int maxdef;
@
<<[[main()]] remaining initialisation>>=
maxdef = 0;
@

<<[[main()]] command line processing>>=
case 'D':
    p = ARGF();
    if(p) {
        // realloc, growing array
        if(ndef >= maxdef){
            maxdef += 50;
            np = alloc(maxdef * sizeof *np);
            if(defs != nil)
                memmove(np, defs, (maxdef - 50) * sizeof *np);
            defs = np;
        }
        defs[ndef++] = p;
        dodefine(p);
    }
    break;
@

<<[[main()]] locals>>=
char *p;
@
<<[[main()]] command line processing>>=
case 'I':
    p = ARGF();
    if(p)
        setinclude(p);
    break;
@


<<[[main()]] command line processing>>=
default:
    c = ARGC();
    if(c >= 0 && c < sizeof(debug))
        debug[c]++;
    break;
@


% would be nice to have a -dump flag and dump action here,
% but the AST is available only in cc.y func def action.
%ocaml: would be better if the parser was returning an AST
% instead, so we could call codegen in the main (or compile)
% instead of in cc.y.

\section{[[compile()]]}

<<global outbuf>>=
Biobuf	outbuf;
@
% used by outcode()

<<global diagbuf>>=
Biobuf	diagbuf;
@

<<[[compile()]] locals>>=
char *p;
fdt ofd;
static bool first = true;
@

% main -> <> (can be called multiple times because of multifile parallel option)
<<function compile>>=
int
compile(char *infile, char **defs, int ndef)
{
    <<[[compile()]] locals>>

    <<[[compile()]] set p to basename(infile) and adjust include>>

    if(outfile == nil) {
        <<[[compile()]] set outfile, using p, to {basename(infile)}.{thechar}>>
    }

    <<[[compile()]] setinclude("/{thestring}/include") or INCLUDE>>

    if (first)
        Binit(&diagbuf, STDOUT, OWRITE);

    <<[[compile()]] if writing acid to standard output>>
    else {
        ofd = mycreat(outfile, 0664);
        if(ofd < 0) {
            diag(Z, "cannot open %s - %r", outfile);
            outfile = nil;
            errorexit();
        }
        Binit(&outbuf, ofd, OWRITE);
    }
    newio();
    first = false;

    <<[[compile()]] use ANSI preprocessor>>
    else {
        if(strcmp(infile, "stdin") == 0)
            newfile(infile, 0);
        else
            newfile(infile, -1);
    }
 
    // The big call!
    yyparse();

    if(!debug['a'] && !debug['Z'])
        gclean();
    return nerrors;
}
@
%old: file -> infile

% main -> compile -> yyparse -> yylex -> macxxx
%                            -> codgen (portable) -> gen


<<[[cinit()]] lexing globals initialization>>=
nerrors = 0;
@






<<[[compile()]] locals>>=
char ofile[400];
@

<<[[compile()]] set p to basename(infile) and adjust include>>=
strcpy(ofile, infile);
p = utfrrune(ofile, pathchar());
if(p) {
    *p++ = 0;
    if(!debug['.'])
        include[0] = strdup(ofile);
} else
    p = ofile;
@


<<[[compile()]] set outfile, using p, to {basename(infile)}.{thechar}>>=
outfile = p;
if(outfile) {
    if(p = utfrrune(outfile, '.'))
        if(p[1] == 'c' && p[2] == 0)
            p[0] = 0;
    p = utfrune(outfile, 0);
    <<[[compile()]] adjust p for outfile if acid option>>
    <<[[compile()]] adjust p for outfile if pickle option>>
    else {
        p[0] = '.';
        p[1] = thechar;
        p[2] = '\0';
    }
} else
    outfile = "/dev/null";
@

<<[[compile()]] locals>>=
char incfile[20];
@


<<[[compile()]] setinclude("/{thestring}/include") or INCLUDE>>=
if(p = getenv("INCLUDE")) {
    setinclude(p);
} else {
    if(systemtype(Plan9)) {
        sprint(incfile, "/%s/include", thestring);
        setinclude(strdup(incfile));
        setinclude("/sys/include");
    }
}
@

%XXX
<<[[compile()]] locals>>=
char **av, opt[256];
int i, c, fd[2];
@



% ok now details each functions called.
% yyparse() will see in parsing section though.

\section{[[tinit()]]}
% type initialisation?

% main -> <>
<<function tinit>>=
void
tinit(void)
{
    int *ip;
    Init *p;

    <<[[tinit()]] initialise thash>>
    <<[[tinit()]] initialise xxxnames debugging arrays>>
    <<[[tinit()]] initialise typexxx type sets>>
    <<[[tinit()]] initialise tcompat arrays>>
    <<[[tinit()]] initialise 32 bits defaults type sets>>
}
@


% put here just to show an example?
<<[[tinit()]] initialise thash>>=
for(p=thashinit; p->code >= 0; p++) {
    urk("thash", nelem(thash), p->code);
    thash[p->code] = p->value;
}
@
%less: then why not using array designator then?

<<function urk>>=
void
urk(char *name, int max, int i)
{
    if(i >= max) {
        fprint(2, "bad tinit: %s %d>=%d\n", name, i, max);
        exits("init");
    }
}
@



\section{[[cinit()]]}
% C lexing/parsing language initialisation?

% main -> <>
<<function cinit>>=
void
cinit(void)
{
    Sym *s;
    int i;
    Type *t;

    <<[[cinit()]] lexing globals initialization>>
    <<[[cinit()]] memory globals initialization>>
    <<[[cinit()]] types initialization>>
    <<[[cinit()]] hash initialization>>
    <<[[cinit()]] symbol table initialization>>
    <<[[cinit()]] namespace globals initialization>>
    <<[[cinit()]] dclstack initialization>>
    <<[[cinit()]] symstring initialization>>
    <<[[cinit()]] nodproto initialization>>
    <<[[cinit()]] pathname initialisation from cwd>>
    <<[[cinit()]] fmtinstall>>
}
@
%old: dead code about 't'?
%    t = typ(TARRAY, types[TCHAR]);
%    t->width = 0;
%later: would be nice to have checks that detect those useless 
% assignments







% =~ cwd, for include "" to work
<<global pathname>>=
char*	pathname;
@
% 

<<[[cinit()]] pathname initialisation from cwd>>=
pathname = allocn(pathname, 0, 100);
if(getwd(pathname, 99) == 0) {
    pathname = allocn(pathname, 100, 900);
    if(getwd(pathname, 999) == 0)
        strcpy(pathname, "/???");
}
@

\section{[[ginit()]]}
% generation code initialisation

% main -> <>
<<function ginit(arm)>>=
void
ginit(void)
{
    Type *t;

    <<[[ginit()]] initialisation>>
    <<[[ginit()]] zprog initialisation>>
    <<[[ginit()]] special nodes initialisation>>
    com64init();
    <<[[ginit()]] reg and resvreg initialisation>>
}
@


\section{[[arginit()]]}

% see later

\section{[[gclean()]]}


% main -> compile -> yyparse; <>
<<function gclean(arm)>>=
void
gclean(void)
{
    int i;
    Sym *s;

    <<[[gclean()]] sanity check reg>>

    <<[[gclean()]] adjust symstring width>>
    <<[[gclean()]] adjust symrathole width>>

    <<[[gclean()]] generate all AGLOBL pseudo opcodes>>
    <<[[gclean()]] generate last opcode, AEND>>
    // generate the whole output file using outbuf global
    outcode();
}
@

\chapter{Input}
% similar to Assembler, could reuse

% lineno in Node section

<<global peekc>>=
int	peekc;
@

<<constant EOF>>=
#define	EOF	(-1)
@

<<constant IGN>>=
#define	IGN	(-2)
@


<<[[cinit()]] lexing globals initialization>>=
lineno = 1;
peekc = IGN;
@


\section{Files managment}

<<constant BUFSIZ>>=
#define	BUFSIZ		8192
@

<<struct Io>>=
struct	Io
{
    char	b[BUFSIZ];

    short	f;

    char*	p;
    short	c;

    Io*	link;
};
@

<<global iostack>>=
Io*	iostack;
@

<<global iofree>>=
Io*	iofree;
@


<<global ionext>>=
Io*	ionext;
@

<<constant I>>=
#define	I	((Io*)nil)
@


<<[[cinit()]] lexing globals initialization>>=
iostack = I;
iofree = I;
@


<<function newio>>=
void
newio(void)
{
    Io *i;
    static int pushdepth = 0;

    i = iofree;
    if(i == I) {
        pushdepth++;
        if(pushdepth > 1000) {
            yyerror("macro/io expansion too deep");
            errorexit();
        }
        i = alloc(sizeof(*i));
    } else
        iofree = i->link;
    i->c = 0;
    i->f = -1;
    ionext = i;
}
@

<<function newfile>>=
void
newfile(char *s, int f)
{
    Io *i;

    if(debug['e'])
        print("%L: %s\n", lineno, s);

    i = ionext;
    i->link = iostack;
    iostack = i;
    i->f = f;
    if(f < 0)
        i->f = open(s, 0);
    if(i->f < 0) {
        yyerror("%cc: %r: %s", thechar, s);
        errorexit();
    }
    fi.c = 0;
    linehist(s, 0);
}
@

\section{Buffer managment}

<<struct Fi>>=
struct Fi
{
    char*	p;
    int	c;
};
@

<<global fi>>=
struct Fi fi;
@

<<function GETC>>=
#define	GETC()	((--fi.c < 0)? filbuf(): (*fi.p++ & 0xff))
@

<<function filbuf>>=
int
filbuf(void)
{
    Io *i;

loop:
    i = iostack;
    if(i == I)
        return EOF;
    if(i->f < 0)
        goto pop;
    fi.c = read(i->f, i->b, BUFSIZ) - 1;
    if(fi.c < 0) {
        close(i->f);
        linehist(0, 0);
        goto pop;
    }
    fi.p = i->b + 1;
    return i->b[0] & 0xff;

pop:
    iostack = i->link;
    i->link = iofree;
    iofree = i;
    i = iostack;
    if(i == I)
        return EOF;
    fi.p = i->p;
    fi.c = i->c;
    if(--fi.c < 0)
        goto loop;
    return *fi.p++ & 0xff;
}
@


\chapter{Lexing}

% Why not using lex? Why handwritten? ...
% Because anyway have to do a few things which are easier outside
% lex like comment handling, typedefs, escape characters
% and unicode! ocamllex not great with unicode (hence ulex).

\section{[[yylex()]]}

<<[[yylex()]] locals>>=
vlong vv;
long c1, t;
char *cp;
Rune rune;
Sym *s;
@

<<function yylex>>=
//@Scheck: not dead, called by yyparse
long yylex(void)
{
    long c;
    <<[[yylex()]] locals>>

    if(peekc != IGN) {
        c = peekc;
        peekc = IGN;
        goto l1;
    }
l0:
    c = GETC();

l1:
    if(c >= Runeself) {
        /*
         * extension --
         *	all multibyte runes are alpha
         */
        cp = symb;
        goto talph;
    }
    if(isspace(c)) {
        if(c == '\n')
            lineno++;
        goto l0;
    }
    if(isalpha(c)) {
        cp = symb;
        if(c != 'L')
            goto talph;

        *cp++ = c;
        c = GETC();
        if(c == '\'') {
            /* L'x' */
            c = escchar('\'', 1, 0);
            if(c == EOF)
                c = '\'';
            c1 = escchar('\'', 1, 0);
            if(c1 != EOF) {
                yyerror("missing '");
                peekc = c1;
            }
            yylval.vval = convvtox(c, TRUNE);
            return LUCONST;
        }
        if(c == '"') {
            goto caselq;
        }
        goto talph;
    }
    if(isdigit(c))
        goto tnum;

    switch(c) {
    <<[[yylex()]] switch c cases>>
    default:
        return c;
    }
    peekc = c1;
    return c;

<<[[yylex()]] labels>>
}
@



<<[[yylex()]] switch c cases>>=
case EOF:
    peekc = EOF;
    return -1;
@

<<[[yylex()]] switch c cases>>=
case '#':
    domacro();
    goto l0;
@

<<[[yylex()]] switch c cases>>=
case '.':
    c1 = GETC();
    if(isdigit(c1)) {
        cp = symb;
        *cp++ = c;
        c = c1;
        c1 = 0;
        goto casedot;
    }
    break;
@








\section{Comments}

<<[[yylex()]] switch c cases>>=
case '/':
    c1 = GETC();
    if(c1 == '*') {
        for(;;) {
            c = getr();
            while(c == '*') {
                c = getr();
                if(c == '/')
                    goto l0;
            }
            if(c == EOF) {
                yyerror("eof in comment");
                errorexit();
            }
        }
    }
    if(c1 == '/') {
        for(;;) {
            c = getr();
            if(c == '\n')
                goto l0;
            if(c == EOF) {
                yyerror("eof in comment");
                errorexit();
            }
        }
    }
    if(c1 == '=')
        return LDVE;
    break;
@
% LDVE, not a comment here!!

\section{Keywords and identifiers}

<<global itab>>=
struct
{
    char	*name;
    // enum<lexeme>
    ushort	lexical;
    // option<enum<Type>>, None = 0 (or TXXX)
    ushort	type;
} itab[] =
{
    "auto",		LAUTO,		0,
    "static",	LSTATIC,	0,
    "extern",	LEXTERN,	0,
    "register",	LREGISTER,	0,

    "const",	LCONSTNT,	0,
    "volatile",	LVOLATILE,	0,

    "inline",	LINLINE,	0,
    "restrict",	LRESTRICT,	0,

    "void",		LVOID,		TVOID,
    "char",		LCHAR,		TCHAR,
    "int",		LINT,		TINT,
    "short",	LSHORT,		TSHORT,
    "long",		LLONG,		TLONG,
    "float",	LFLOAT,		TFLOAT,
    "double",	LDOUBLE,	TDOUBLE,

    "unsigned",	LUNSIGNED,	0,
    "signed",	LSIGNED,	0,

    "struct",	LSTRUCT,	0,
    "union",	LUNION,		0,
    "enum",		LENUM,		0,

    "typedef",	LTYPEDEF,	0,

    "if",		LIF,		0,
    "else",		LELSE,		0,
    "while",	LWHILE,		0,
    "for",		LFOR,		0,
    "do",		LDO,		0,
    "break",	LBREAK,		0,
    "continue",	LCONTINUE,	0,
    "switch",	LSWITCH,	0,
    "case",		LCASE,		0,
    "default",	LDEFAULT,	0,
    "return",	LRETURN,	0,
    "goto",		LGOTO,		0,

    "sizeof",	LSIZEOF,	0,
    <<[[itab]] entries, kencc extensions>>
    0
};
@

<<[[cinit()]] symbol table initialization>>=
for(i=0; itab[i].name; i++) {
    s = slookup(itab[i].name);
    s->lexical = itab[i].lexical;
    if(itab[i].type != 0)
        s->type = types[itab[i].type];
}
@
% abuse symbol table


<<[[yylex()]] switch c cases>>=
case '_':
    cp = symb;
    goto talph;
@



<<[[yylex()]] labels>>=
talph:
    /*
     * cp is set to symb and some
     * prefix has been stored
     */
    for(;;) {
        if(c >= Runeself) {
            for(c1=0;;) {
                cp[c1++] = c;
                if(fullrune(cp, c1))
                    break;
                c = GETC();
            }
            cp += c1;
            c = GETC();
            continue;
        }
        if(!isalnum(c) && c != '_')
            break;
        *cp++ = c;
        c = GETC();
    }
    *cp = 0;
    if(debug['L'])
        print("%L: %s\n", lineno, symb);
    peekc = c;

    // the important call!
    s = lookup();

    if(s->macro) {
        newio();
        cp = ionext->b;
        macexpand(s, cp);
        pushio();
        ionext->link = iostack;
        iostack = ionext;
        fi.p = cp;
        fi.c = strlen(cp);
        if(peekc != IGN) {
            cp[fi.c++] = peekc;
            cp[fi.c] = 0;
            peekc = IGN;
        }
        goto l0;
    }
    yylval.sym = s;
    <<[[yylex()]] alpha case, return LTYPE if typedef symbol s>>
    return s->lexical;
@




\section{Typedef trick}

% lexer/parser/symboltable cooperation. The parser sets the class
% of the symbol.
% Is there any issue when do  xxx xxx; ? no because
% xdecor actually uses ltag with LNAME | LTYPE.
% (but no conflict?)


<<[[yylex()]] alpha case, return LTYPE if typedef symbol s>>=
if(s->class == CTYPEDEF || s->class == CTYPESTR)
    return LTYPE;
@
% CTYPEDEF class explained later, in parsing.

\section{Operators}

<<[[yylex()]] switch c cases>>=
case '*':
    c1 = GETC();
    if(c1 == '=')
        return LMLE;
    break;
@
% else return character itself, which is ok since yacc have
% a special case for single character terminals.

<<[[yylex()]] switch c cases>>=
case '%':
    c1 = GETC();
    if(c1 == '=')
        return LMDE;
    break;
@

<<[[yylex()]] switch c cases>>=
case '+':
    c1 = GETC();
    if(c1 == '+')
        return LPP;
    if(c1 == '=')
        return LPE;
    break;
@

<<[[yylex()]] switch c cases>>=
case '-':
    c1 = GETC();
    if(c1 == '-')
        return LMM;
    if(c1 == '=')
        return LME;
    if(c1 == '>')
        return LMG;
    break;
@

<<[[yylex()]] switch c cases>>=
case '>':
    c1 = GETC();
    if(c1 == '>') {
        c = LRSH;
        c1 = GETC();
        if(c1 == '=')
            return LRSHE;
        break;
    }
    if(c1 == '=')
        return LGE;
    break;
@

<<[[yylex()]] switch c cases>>=
case '<':
    c1 = GETC();
    if(c1 == '<') {
        c = LLSH;
        c1 = GETC();
        if(c1 == '=')
            return LLSHE;
        break;
    }
    if(c1 == '=')
        return LLE;
    break;
@

<<[[yylex()]] switch c cases>>=
case '=':
    c1 = GETC();
    if(c1 == '=')
        return LEQ;
    break;
@

<<[[yylex()]] switch c cases>>=
case '!':
    c1 = GETC();
    if(c1 == '=')
        return LNE;
    break;
@

<<[[yylex()]] switch c cases>>=
case '&':
    c1 = GETC();
    if(c1 == '&')
        return LANDAND;
    if(c1 == '=')
        return LANDE;
    break;
@

<<[[yylex()]] switch c cases>>=
case '|':
    c1 = GETC();
    if(c1 == '|')
        return LOROR;
    if(c1 == '=')
        return LORE;
    break;
@

<<[[yylex()]] switch c cases>>=
case '^':
    c1 = GETC();
    if(c1 == '=')
        return LXORE;
    break;
@



\section{Numbers}

<<enum numxxx>>=
enum numxxx
{
    Numdec		= 1<<0,
    Numlong		= 1<<1,
    Numuns		= 1<<2,
    Numvlong	= 1<<3,
    Numflt		= 1<<4,
};
@
% decimal, long, unsigned?, vlong, float

<<[[yylex()]] labels>>=
tnum:
    c1 = 0;
    cp = symb;
    if(c != '0') {
        c1 |= Numdec;
        for(;;) {
            *cp++ = c;
            c = GETC();
            if(isdigit(c))
                continue;
            goto dc;
        }
    }
    *cp++ = c;
    c = GETC();
    if(c == 'x' || c == 'X')
        for(;;) {
            *cp++ = c;
            c = GETC();
            if(isdigit(c))
                continue;
            if(c >= 'a' && c <= 'f')
                continue;
            if(c >= 'A' && c <= 'F')
                continue;
            if(cp == symb+2)
                yyerror("malformed hex constant");
            goto ncu;
        }
    if(c < '0' || c > '7')
        goto dc;
    for(;;) {
        if(c >= '0' && c <= '7') {
            *cp++ = c;
            c = GETC();
            continue;
        }
        goto ncu;
    }
    //Fallthrough
dc:
    if(c == '.')
        goto casedot;
    if(c == 'e' || c == 'E')
        goto casee;
    //Fallthrough
ncu:
    if((c == 'U' || c == 'u') && !(c1 & Numuns)) {
        c = GETC();
        c1 |= Numuns;
        goto ncu;
    }
    if((c == 'L' || c == 'l') && !(c1 & Numvlong)) {
        c = GETC();
        if(c1 & Numlong)
            c1 |= Numvlong;
        c1 |= Numlong;
        goto ncu;
    }
    *cp = 0;
    peekc = c;
    if(mpatov(symb, &yylval.vval))
        yyerror("overflow in constant");

    vv = yylval.vval;
    if(c1 & Numvlong) {
        if((c1 & Numuns) || convvtox(vv, TVLONG) < 0) {
            c = LUVLCONST;
            t = TUVLONG;
            goto nret;
        }
        c = LVLCONST;
        t = TVLONG;
        goto nret;
    }
    if(c1 & Numlong) {
        if((c1 & Numuns) || convvtox(vv, TLONG) < 0) {
            c = LULCONST;
            t = TULONG;
            goto nret;
        }
        c = LLCONST;
        t = TLONG;
        goto nret;
    }
    if((c1 & Numuns) || convvtox(vv, TINT) < 0) {
        c = LUCONST;
        t = TUINT;
        goto nret;
    }
    c = LCONST;
    t = TINT;
    goto nret;
@

<<[[yylex()]] labels>>=
nret:
    yylval.vval = convvtox(vv, t);
    if(yylval.vval != vv){
        nearln = lineno;
        warn(Z, "truncated constant: %T %s", types[t], symb);
    }
    return c;
@





% yylex()#ncu -> <>
<<function mpatov>>=
/*
 * convert a string, s, to vlong in *v
 * return conversion overflow.
 * required syntax is [0[x]]d*
 */
bool
mpatov(char *s, vlong *v)
{
    vlong n, nn;
    int c;

    n = 0;
    c = *s;
    if(c == '0')
        goto oct;
    while(c = *s++) {
        if(c >= '0' && c <= '9')
            nn = n*10 + c-'0';
        else
            goto bad;
        if(n < 0 && nn >= 0)
            goto bad;
        n = nn;
    }
    goto out;

oct:
    s++;
    c = *s;
    if(c == 'x' || c == 'X')
        goto hex;
    while(c = *s++) {
        if(c >= '0' || c <= '7')
            nn = n*8 + c-'0';
        else
            goto bad;
        if(n < 0 && nn >= 0)
            goto bad;
        n = nn;
    }
    goto out;

hex:
    s++;
    while(c = *s++) {
        if(c >= '0' && c <= '9')
            c += 0-'0';
        else
        if(c >= 'a' && c <= 'f')
            c += 10-'a';
        else
        if(c >= 'A' && c <= 'F')
            c += 10-'A';
        else
            goto bad;
        nn = n*16 + c;
        if(n < 0 && nn >= 0)
            goto bad;
        n = nn;
    }
out:
    *v = n;
    return false;

bad:
    *v = ~0;
    return true;
}
@


\subsection{Decimals}

\subsection{Hexadecimals}

\subsection{Octadecimals}

\subsection{Floats}

<<[[yylex()]] labels>>=
casedot:
    for(;;) {
        *cp++ = c;
        c = GETC();
        if(!isdigit(c))
            break;
    }
    if(c != 'e' && c != 'E')
        goto caseout;
    // Fallthrough

casee:
    *cp++ = 'e';
    c = GETC();
    if(c == '+' || c == '-') {
        *cp++ = c;
        c = GETC();
    }
    if(!isdigit(c))
        yyerror("malformed fp constant exponent");
    while(isdigit(c)) {
        *cp++ = c;
        c = GETC();
    }
    // Fallthrough
caseout:
    if(c == 'L' || c == 'l') {
        c = GETC();
        c1 |= Numlong;
    } else
    if(c == 'F' || c == 'f') {
        c = GETC();
        c1 |= Numflt;
    }
    *cp = 0;
    peekc = c;
    yylval.dval = strtod(symb, nil);
    if(isInf(yylval.dval, 1) || isInf(yylval.dval, -1)) {
        yyerror("overflow in float constant");
        yylval.dval = 0;
    }
    if(c1 & Numflt)
        return LFCONST;
    return LDCONST;
@

\section{Characters}

<<[[yylex()]] switch c cases>>=
case '\'':
    /* '.' */
    c = escchar('\'', 0, 0);
    if(c == EOF)
        c = '\'';
    c1 = escchar('\'', 0, 0);
    if(c1 != EOF) {
        yyerror("missing '");
        peekc = c1;
    }
    vv = c;
    yylval.vval = convvtox(vv, TUCHAR);
    if(yylval.vval != vv)
        yyerror("overflow in character constant: 0x%lx", c);
    else
    if(c & 0x80){
        nearln = lineno;
        warn(Z, "sign-extended character constant");
    }
    yylval.vval = convvtox(vv, TCHAR);
    return LCONST;
@





\subsection{Escaping characters}

<<function escchar>>=
long
escchar(long e, int longflg, bool escflg)
{
    long c, l;
    int i;

loop:
    c = getr();
    if(c == '\n') {
        yyerror("newline in string");
        return EOF;
    }
    if(c != '\\') {
        if(c == e)
            c = EOF;
        return c;
    }
    c = getr();
    if(c == 'x') {
        /*
         * note this is not ansi,
         * supposed to only accept 2 hex
         */
        i = 2;
        if(longflg)
            i = 6;
        l = 0;
        for(; i>0; i--) {
            c = getc();
            if(c >= '0' && c <= '9') {
                l = l*16 + c-'0';
                continue;
            }
            if(c >= 'a' && c <= 'f') {
                l = l*16 + c-'a' + 10;
                continue;
            }
            if(c >= 'A' && c <= 'F') {
                l = l*16 + c-'A' + 10;
                continue;
            }
            unget(c);
            break;
        }
        if(escflg)
            l |= ESC;
        return l;
    }
    if(c >= '0' && c <= '7') {
        /*
         * note this is not ansi,
         * supposed to only accept 3 oct
         */
        i = 2;
        if(longflg)
            i = 8;
        l = c - '0';
        for(; i>0; i--) {
            c = getc();
            if(c >= '0' && c <= '7') {
                l = l*8 + c-'0';
                continue;
            }
            unget(c);
        }
        if(escflg)
            l |= ESC;
        return l;
    }
    switch(c)
    {
    case '\n':	goto loop;
    case 'n':	return '\n';
    case 't':	return '\t';
    case 'b':	return '\b';
    case 'r':	return '\r';
    case 'f':	return '\f';
    case 'a':	return '\a';
    case 'v':	return '\v';
    }
    return c;
}
@


<<function getr>>=
long
getr(void)
{
    int c, i;
    char str[UTFmax+1];
    Rune rune;


    c = getc();
    if(c < Runeself)
        return c;
    i = 0;
    str[i++] = c;

loop:
    c = getc();
    str[i++] = c;
    if(!fullrune(str, i))
        goto loop;
    c = chartorune(&rune, str);
    if(rune == Runeerror && c == 1) {
        nearln = lineno;
        diag(Z, "illegal rune in string");
        for(c=0; c<i; c++)
            print(" %.2x", *(uchar*)(str+c));
        print("\n");
    }
    return rune;
}
@

\section{Strings}

<<constant ESC>>=
#define	ESC	(Runemask+1)		/* Rune flag: a literal byte */
@

<<[[yylex()]] switch c cases>>=
case '"':
    strcpy(symb, "\"<string>\"");
    cp = alloc(0);
    c1 = 0;

    /* "..." */
    for(;;) {
        c = escchar('"', 0, 1);
        if(c == EOF)
            break;
        if(c & ESC) {
            cp = allocn(cp, c1, 1);
            cp[c1++] = c;
        } else {
            rune = c;
            c = runelen(rune);
            cp = allocn(cp, c1, c);
            runetochar(cp+c1, &rune);
            c1 += c;
        }
    }
    yylval.sval.l = c1;
    do {
        cp = allocn(cp, c1, 1);
        cp[c1++] = 0;
    } while(c1 & MAXALIGN);
    yylval.sval.s = cp;
    return LSTRING;
@

\subsection{Unicode}
% long strings

<<[[yylex()]] switch c cases>>=
caselq:
    /* L"..." */
    strcpy(symb, "\"L<string>\"");
    cp = alloc(0);
    c1 = 0;
    for(;;) {
        c = escchar('"', 1, 0);
        if(c == EOF)
            break;
        cp = allocn(cp, c1, sizeof(TRune));
        *(TRune*)(cp + c1) = c;
        c1 += sizeof(TRune);
    }
    yylval.sval.l = c1;
    do {
        cp = allocn(cp, c1, sizeof(TRune));
        *(TRune*)(cp + c1) = 0;
        c1 += sizeof(TRune);
    } while(c1 & MAXALIGN);
    yylval.sval.s = cp;
    return LLSTRING;
@



\section{[[getc()]], [[unget()]], [[getnsc()]]}

<<function getc>>=
int
getc(void)
{
    int c;

    if(peekc != IGN) {
        c = peekc;
        peekc = IGN;
    } else
        c = GETC();
    if(c == '\n')
        lineno++;
    if(c == EOF) {
        yyerror("End of file");
        errorexit();
    }
    return c;
}
@

<<function unget>>=
void
unget(int c)
{

    peekc = c;
    if(c == '\n')
        lineno--;
}
@

<<function getnsc>>=
int
getnsc(void)
{
    int c;

    if(peekc != IGN) {
        c = peekc;
        peekc = IGN;
    } else
        c = GETC();
    for(;;) {
        if(c >= Runeself || !isspace(c))
            return c;
        if(c == '\n') {
            lineno++;
            return c;
        }
        c = GETC();
    }
}
@


\section{[[getsym()]]}
% mv with Keywords and identifier section?

<<function getsym>>=
Sym*
getsym(void)
{
    int c;
    char *cp;

    c = getnsc();
    if(!isalpha(c) && c != '_' && c < Runeself) {
        unget(c);
        return S;
    }
    for(cp = symb;;) {
        if(cp <= symb+NSYMB-4)
            *cp++ = c;
        c = getc();
        if(isalnum(c) || c == '_' || c >= Runeself)
            continue;
        unget(c);
        break;
    }
    *cp = 0;
    if(cp > symb+NSYMB-4)
        yyerror("symbol too large: %s", symb);
    return lookup();
}
@
% 4 = sizeof Rune?

\section{[[getcom()]]}
% mv with Comments section above?

<<function getcom>>=
int
getcom(void)
{
    int c;

    for(;;) {
        c = getnsc();
        if(c != '/')
            break;
        c = getc();
        if(c == '/') {
            while(c != '\n')
                c = getc();
            break;
        }
        if(c != '*')
            break;
        c = getc();
        for(;;) {
            if(c == '*') {
                c = getc();
                if(c != '/')
                    continue;
                c = getc();
                break;
            }
            if(c == '\n') {
                yyerror("comment across newline");
                break;
            }
            c = getc();
        }
        if(c == '\n')
            break;
    }
    return c;
}
@

\chapter{Preprocessing}

% similar to Assembler.nw again, except here have the possiblity
% to also call an external program.


% Builtin in the binary. A bit of code duplication with the
% assmembler, but maybe it makes compilation faster because
% there is no fork at all!
% builtin preprocessor integrated with lexer (benefit? faster? no fork?)
% see also 5c -p

% dupe with Assembler.nw, should try to factorize at some point

<<global mactab>>=
struct
{
    char	*macname;
    void	(*macf)(void);
} mactab[] =
{
    "ifdef",	nil,	/* macif(0) */
    "ifndef",	nil,	/* macif(1) */
    "else",	nil,	/* macif(2) */

    "line",	maclin,
    "define",	macdef,
    "include",	macinc,
    "undef",	macund,

    "pragma",	macprag,
    "endif",	macend,
    0
};
@

% dispatcher, should rename because it's not just about macro =>
% less: parse_and_dispatch_pp_directive?
<<function domacro>>=
void
domacro(void)
{
    int i;
    Sym *s;

    s = getsym();
    if(s == S)
        s = slookup("endif");

    for(i=0; mactab[i].macname; i++)
        if(strcmp(s->name, mactab[i].macname) == 0) {
            if(mactab[i].macf)
                // dispatcher!
                (*mactab[i].macf)();
            else
                macif(i);
            return;
        }
    yyerror("unknown #: %s", s->name);
    macend();
}
@
% abuse getsym just to get an ident, don't have to go through
% lookup really

<<function macend>>=
void
macend(void)
{
    int c;

    for(;;) {
        c = getnsc();
        if(c < 0 || c == '\n')
            return;
    }
}
@
% I don't think c can be < 0 here.

\section{[[#include]]}
% and [[-I]]

\subsection{Include path, [[-I]]}

% was using fixed array in assembler
<<global include>>=
char**	include;
@

<<global ninclude>>=
int	ninclude;
@

<<global maxinclude>>=
int	maxinclude;
@


% main -> <>(".")
<<function setinclude>>=
void
setinclude(char *p)
{
    int i;
    char *e, **np;

    while(*p != 0) {
        e = strchr(p, ' ');
        if(e != 0)
            *e = '\0';

        for(i=0; i < ninclude; i++)
            if(strcmp(p, include[i]) == 0)
                break;

        if(i >= ninclude){
            if(i >= maxinclude){
                maxinclude += 20;
                np = alloc(maxinclude * sizeof *np);
                if(include != nil)
                    memmove(np, include, (maxinclude - 20) * sizeof *np);
                include = np;
            }
            include[ninclude++] = p;
        }

        if(e == 0)
            break;
        p = e+1;
    }
}
@

\subsection{Tracing origin and [[Hist]]}

<<struct Hist>>=
struct	Hist
{
    char*	name;

    long	line;
    long	offset;

    Hist*	link;
};
@

<<constant H>>=
#define	H	((Hist*)nil)
@

<<global hist>>=
Hist*	hist;
@

<<global ehist>>=
Hist*	ehist;
@

<<global newflag>>=
bool	newflag;
@


<<function linehist>>=
void
linehist(char *f, int offset)
{
    Hist *h;

    /*
     * overwrite the last #line directive if
     * no alloc has happened since the last one
     */
    if(newflag == false && ehist != H && offset != 0 && ehist->offset != 0)
        if(f && ehist->name && strcmp(f, ehist->name) == 0) {
            ehist->line = lineno;
            ehist->offset = offset;
            return;
        }
    <<[[linehist()]] debug>>

    newflag = false;

    h = alloc(sizeof(Hist));
    h->name = f;
    h->line = lineno;
    h->offset = offset;
    h->link = H;
    if(ehist == H) {
        hist = h;
        ehist = h;
        return;
    }
    ehist->link = h;
    ehist = h;
}
@

\subsection{[[#include]]}

<<constant STRINGSZ>>=
#define	STRINGSZ	200
@


% LP split, and factorize code with gethunk
<<function macinc>>=
void
macinc(void)
{
    int c0, c, i, f;
    char str[STRINGSZ], *hp;

    c0 = getnsc();
    if(c0 != '"') {
        c = c0;
        if(c0 != '<')
            goto bad;
        c0 = '>';
    }
    for(hp = str;;) {
        c = getc();
        if(c == c0)
            break;
        if(c == '\n')
            goto bad;
        *hp++ = c;
    }
    *hp = 0;

    c = getcom();
    if(c != '\n')
        goto bad;

    f = -1;
    for(i=0; i<ninclude; i++) {
        if(i == 0 && c0 == '>')
            continue;
        strcpy(symb, include[i]);
        strcat(symb, "/");
        if(strcmp(symb, "./") == 0)
            symb[0] = 0;
        strcat(symb, str);

        f = open(symb, 0);
        if(f >= 0)
            break;

    }
    if(f < 0)
        strcpy(symb, str);
    c = strlen(symb) + 1;
    while(c & 3)
        c++;

    while(nhunk < c)
        gethunk();
    hp = hunk;
    memcpy(hunk, symb, c);
    nhunk -= c;
    hunk += c;

    newio();
    pushio();
    newfile(hp, f);
    return;

bad:
    unget(c);
    yyerror("syntax in #include");
    macend();
}
@


<<function pushio>>=
void
pushio(void)
{
    Io *i;

    i = iostack;
    if(i == I) {
        yyerror("botch in pushio");
        errorexit();
    }
    i->p = fi.p;
    i->c = fi.c;
}
@

\section{[[#define]]}

\subsection{[[-D]]}

% no Dlist here, instead pass the defs to compile()

<<function dodefine>>=
void
dodefine(char *cp)
{
    Sym *s;
    char *p;
    long l;

    strcpy(symb, cp);
    p = strchr(symb, '=');
    if(p) {
        *p++ = 0;
        s = lookup();
        l = strlen(p) + 2;	/* +1 null, +1 nargs */
        while(l & 3)
            l++;

        while(nhunk < l)
            gethunk();
        *hunk = 0;
        strcpy(hunk+1, p);
        s->macro = hunk;
        hunk += l;
        nhunk -= l;

    } else {
        s = lookup();
        s->macro = "\0001";	/* \000 is nargs */
    }
    <<[[dodefine()]] debug>>
}
@

% LP split macro field of Sym


\subsection{[[#define]]}

<<constant NARG>>=
#define	NARG	25
@

% wow, this is complicated
<<function macdef>>=
void
macdef(void)
{
    Sym *s, *a;
    char *args[NARG], *np, *base;
    int n, i, c, len, dots;
    int ischr;

    s = getsym();
    if(s == S)
        goto bad;
    if(s->macro)
        yyerror("macro redefined: %s", s->name);
    c = getc();
    n = -1;
    dots = 0;
    if(c == '(') {
        n++;
        c = getnsc();
        if(c != ')') {
            unget(c);
            for(;;) {
                a = getsymdots(&dots);
                if(a == S)
                    goto bad;
                if(n >= NARG) {
                    yyerror("too many arguments in #define: %s", s->name);
                    goto bad;
                }
                args[n++] = a->name;
                c = getnsc();
                if(c == ')')
                    break;
                if(c != ',' || dots)
                    goto bad;
            }
        }
        c = getc();
    }
    if(isspace(c))
        if(c != '\n')
            c = getnsc();
    base = hunk;
    len = 1;
    ischr = 0;
    for(;;) {
        if(isalpha(c) || c == '_') {
            np = symb;
            *np++ = c;
            c = getc();
            while(isalnum(c) || c == '_') {
                *np++ = c;
                c = getc();
            }
            *np = 0;
            for(i=0; i<n; i++)
                if(strcmp(symb, args[i]) == 0)
                    break;
            if(i >= n) {
                i = strlen(symb);
                base = allocn(base, len, i);
                memcpy(base+len, symb, i);
                len += i;
                continue;
            }
            base = allocn(base, len, 2);
            base[len++] = '#';
            base[len++] = 'a' + i;
            continue;
        }
        if(ischr){
            if(c == '\\'){ 
                base = allocn(base, len, 1);
                base[len++] = c;
                c = getc();
            }else if(c == ischr)
                ischr = 0;
        }else{
            if(c == '"' || c == '\''){
                base = allocn(base, len, 1);
                base[len++] = c;
                ischr = c;
                c = getc();
                continue;
            }
            if(c == '/') {
                c = getc();
                if(c == '/'){
                    c = getc();
                    for(;;) {
                        if(c == '\n')
                            break;
                        c = getc();
                    }
                    continue;
                }
                if(c == '*'){
                    c = getc();
                    for(;;) {
                        if(c == '*') {
                            c = getc();
                            if(c != '/')
                                continue;
                            c = getc();
                            break;
                        }
                        if(c == '\n') {
                            yyerror("comment and newline in define: %s", s->name);
                            break;
                        }
                        c = getc();
                    }
                    continue;
                }
                base = allocn(base, len, 1);
                base[len++] = '/';
                continue;
            }
        }
        if(c == '\\') {
            c = getc();
            if(c == '\n') {
                c = getc();
                continue;
            }
            else if(c == '\r') {
                c = getc();
                if(c == '\n') {
                    c = getc();
                    continue;
                }
            }
            base = allocn(base, len, 1);
            base[len++] = '\\';
            continue;
        }
        if(c == '\n')
            break;
        if(c == '#')
        if(n > 0) {
            base = allocn(base, len, 1);
            base[len++] = c;
        }
        base = allocn(base, len, 1);
        base[len++] = c;
        c = ((--fi.c < 0)? filbuf(): (*fi.p++ & 0xff));
        if(c == '\n')
            lineno++;
        if(c == -1) {
            yyerror("eof in a macro: %s", s->name);
            break;
        }
    }
    do {
        base = allocn(base, len, 1);
        base[len++] = 0;
    } while(len & 3);

    *base = n+1;
    if(dots)
        *base |= VARMAC;
    s->macro = base;
    <<[[macdef()]] debug>>
    return;

bad:
    if(s == S)
        yyerror("syntax in #define");
    else
        yyerror("syntax in #define: %s", s->name);
    macend();
}
@

<<constant VARMAC>>=
#define VARMAC 0x80
@


<<function getsymdots>>=
Sym*
getsymdots(int *dots)
{
    int c;
    Sym *s;

    s = getsym();
    if(s != S)
        return s;

    c = getnsc();
    if(c != '.'){
        unget(c);
        return S;
    }
    if(getc() != '.' || getc() != '.')
        yyerror("bad dots in macro");
    *dots = 1;
    return slookup("__VA_ARGS__");
}
@

\subsection{Macro Expansion}

%<<[[yylex()]] if macro symbol>>=

% wow, complicated too
<<function macexpand>>=
void
macexpand(Sym *s, char *b)
{
    char buf[2000];
    int n, l, c, nargs;
    char *arg[NARG], *cp, *ob, *ecp, dots;

    ob = b;
    if(*s->macro == 0) {
        strcpy(b, s->macro+1);
        if(debug['m'])
            print("#expand %s %s\n", s->name, ob);
        return;
    }
    
    nargs = (char)(*s->macro & ~VARMAC) - 1;
    dots = *s->macro & VARMAC;

    c = getnsc();
    if(c != '(')
        goto bad;
    n = 0;
    c = getc();
    if(c != ')') {
        unget(c);
        l = 0;
        cp = buf;
        ecp = cp + sizeof(buf)-4;
        arg[n++] = cp;
        for(;;) {
            if(cp >= ecp)
                goto toobig;
            c = getc();
            if(c == '"')
                for(;;) {
                    if(cp >= ecp)
                        goto toobig;
                    *cp++ = c;
                    c = getc();
                    if(c == '\\') {
                        *cp++ = c;
                        c = getc();
                        continue;
                    }
                    if(c == '\n')
                        goto bad;
                    if(c == '"')
                        break;
                }
            if(c == '\'')
                for(;;) {
                    if(cp >= ecp)
                        goto toobig;
                    *cp++ = c;
                    c = getc();
                    if(c == '\\') {
                        *cp++ = c;
                        c = getc();
                        continue;
                    }
                    if(c == '\n')
                        goto bad;
                    if(c == '\'')
                        break;
                }
            if(c == '/') {
                c = getc();
                switch(c) {
                case '*':
                    for(;;) {
                        c = getc();
                        if(c == '*') {
                            c = getc();
                            if(c == '/')
                                break;
                        }
                    }
                    *cp++ = ' ';
                    continue;
                case '/':
                    while((c = getc()) != '\n')
                        ;
                    break;
                default:
                    unget(c);
                    c = '/';
                }
            }
            if(l == 0) {
                if(c == ',') {
                    if(n == nargs && dots) {
                        *cp++ = ',';
                        continue;
                    }
                    *cp++ = 0;
                    arg[n++] = cp;
                    if(n > nargs)
                        break;
                    continue;
                }
                if(c == ')')
                    break;
            }
            if(c == '\n')
                c = ' ';
            *cp++ = c;
            if(c == '(')
                l++;
            if(c == ')')
                l--;
        }
        *cp = 0;
    }
    if(n != nargs) {
        yyerror("argument mismatch expanding: %s", s->name);
        *b = 0;
        return;
    }
    cp = s->macro+1;
    for(;;) {
        c = *cp++;
        if(c == '\n')
            c = ' ';
        if(c != '#') {
            *b++ = c;
            if(c == 0)
                break;
            continue;
        }
        c = *cp++;
        if(c == 0)
            goto bad;
        if(c == '#') {
            *b++ = c;
            continue;
        }
        c -= 'a';
        if(c < 0 || c >= n)
            continue;
        strcpy(b, arg[c]);
        b += strlen(arg[c]);
    }
    *b = 0;
    if(debug['m'])
        print("#expand %s %s\n", s->name, ob);

    return;

bad:
    yyerror("syntax in macro expansion: %s", s->name);
    *b = 0;
    return;

toobig:
    yyerror("too much text in macro expansion: %s", s->name);
    *b = 0;
}
@

\section{[[#undef]]}

<<function macund>>=
void
macund(void)
{
    Sym *s;

    s = getsym();
    macend();
    if(s == S) {
        yyerror("syntax in #undef");
        return;
    }
    s->macro = nil;
}
@

\section{[[#ifdef]]}

% 0 = ifdef, 1 = ifndef, 2 = else, see mactab and domacro()
<<function macif>>=
void
macif(int f)
{
    int c, l;
    bool bol;
    Sym *s;

    if(f == 2)
        goto skip;
    s = getsym();
    if(s == S)
        goto bad;
    if(getcom() != '\n')
        goto bad;
    if((s->macro != nil) ^ f)
        return;

skip:
    bol = true;
    l = 0;
    for(;;) {
        c = getc();
        if(c != '#') {
            if(!isspace(c))
                bol = false;
            if(c == '\n')
                bol = true;
            continue;
        }
        if(!bol)
            continue;
        s = getsym();
        if(s == S)
            continue;
        if(strcmp(s->name, "endif") == 0) {
            if(l) {
                l--;
                continue;
            }
            macend();
            return;
        }
        if(strcmp(s->name, "ifdef") == 0 || strcmp(s->name, "ifndef") == 0) {
            l++;
            continue;
        }
        if(l == 0 && f != 2 && strcmp(s->name, "else") == 0) {
            macend();
            return;
        }
    }

bad:
    yyerror("syntax in #if(n)def");
    macend();
}
@

\section{[[#pragma]]}

% effect of #pragma lib in .s ??

<<function macprag>>=
void
macprag(void)
{
    Sym *s;
    int c0, c;
    char *hp;
    Hist *h;

    s = getsym();

    if(s && strcmp(s->name, "lib") == 0) {
        c0 = getnsc();
        if(c0 != '"') {
            c = c0;
            if(c0 != '<')
                goto bad;
            c0 = '>';
        }
        for(hp = symb;;) {
            c = getc();
            if(c == c0)
                break;
            if(c == '\n')
                goto bad;
            *hp++ = c;
        }
        *hp = '\0';
        c = getcom();
        if(c != '\n')
            goto bad;
    
        /*
         * put pragma-line in as a funny history 
         */
        c = strlen(symb) + 1;
        while(c & 3)
            c++;
    
        while(nhunk < c)
            gethunk();
        hp = hunk;
        memcpy(hunk, symb, c);
        nhunk -= c;
        hunk += c;
    
        h = alloc(sizeof(Hist));
        h->name = hp;
        h->line = lineno;
        h->offset = -1;

        h->link = H;
        if(ehist == H) {
            hist = h;
            ehist = h;
            return;
        }
        ehist->link = h;
        ehist = h;

        return;

bad:
        unget(c);
        yyerror("syntax in #pragma lib");
        macend();

    } else {
        while(getnsc() != '\n')
            ;
        return;
    }
}
@


% most pragma seems to be discarded except #pragma lib, so
% I removed it (could have aslo simplified by calling prag_do_nothing()).
% is it because code was shared with cc? or because it's in aa/
% and other archi do different things?
%
%    if(s && strcmp(s->name, "pack") == 0) {
%        pragpack();
%        return;
%    }
%    if(s && strcmp(s->name, "fpround") == 0) {
%        pragfpround();
%        return;
%    }
%    if(s && strcmp(s->name, "profile") == 0) {
%        pragprofile();
%        return;
%    }
%    if(s && strcmp(s->name, "varargck") == 0) {
%        pragvararg();
%        return;
%    }
%    if(s && strcmp(s->name, "incomplete") == 0) {
%        pragincomplete();
%        return;
%    }
%
%old:
%<<function pragpack>>=
%void
%pragpack(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@
%
%<<function pragvararg>>=
%void
%pragvararg(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@
%
%<<function pragfpround>>=
%void
%pragfpround(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@
%
%<<function pragprofile>>=
%void
%pragprofile(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@
%
%<<function pragincomplete>>=
%void
%pragincomplete(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@


\section{[[#line]]}

% useful for code generator, to report error to original file, not generated
% code, e.g. for lex&yacc

<<function maclin>>=
void
maclin(void)
{
    char *cp;
    int c;
    long n;

    n = getnsn();
    c = getc();
    if(n < 0)
        goto bad;

    for(;;) {
        if(c == ' ' || c == '\t') {
            c = getc();
            continue;
        }
        if(c == '"')
            break;
        if(c == '\n') {
            strcpy(symb, "<noname>");
            goto nn;
        }
        goto bad;
    }
    cp = symb;
    for(;;) {
        c = getc();
        if(c == '"')
            break;
        *cp++ = c;
    }
    *cp = 0;
    c = getcom();
    if(c != '\n')
        goto bad;

nn:
    c = strlen(symb) + 1;
    while(c & 3)
        c++;

    while(nhunk < c)
        gethunk();
    cp = hunk;
    memcpy(hunk, symb, c);
    nhunk -= c;
    hunk += c;

    linehist(cp, n);
    return;

bad:
    unget(c);
    yyerror("syntax in #line");
    macend();
}
@

% could move with the other getxxx()
<<function getnsn>>=
long
getnsn(void)
{
    long n;
    int c;

    c = getnsc();
    if(c < '0' || c > '9')
        return -1;
    n = 0;
    while(c >= '0' && c <= '9') {
        n = n*10 + c-'0';
        c = getc();
    }
    unget(c);
    return n;
}
@







\chapter{Parsing}

\section{Overview}

% I assume you understand Yacc! if not read the oreilly book on Lex&Yacc
%  or docs/doc/unix/yacc.pdf (or read CompilerGenerator.nw :) )
%(compared to ocamlyacc can have actions in the middle, and they count
% as indexable elements for the $xxx ($1, $2, etc))

<<cc/cc.y>>=
%{
#include "cc.h"
%}
<<union yacc>>
<<token declarations>>
<<priority and associativity declarations>>
<<type declarations>>
%%
<<grammar>>
%%
@

% have seen union yacc and token declarations in Core Data structures
% chapter already.

% do not LP split, order matters!
<<priority and associativity declarations>>=
%left   ';'
%left   ','
%right  '=' LPE LME LMLE LDVE LMDE LRSHE LLSHE LANDE LXORE LORE
%right  '?' ':'
%left   LOROR
%left   LANDAND
%left   '|'
%left   '^'
%left   '&'
%left   LEQ LNE
%left   '<' '>' LLE LGE
%left   LLSH LRSH
%left   '+' '-'
%left   '*' '/' '%'
%right  LMM LPP LMG '.' '[' '('
@
% LXE = L X Equal, e.g. LPE = L Plus Equal (+=)
% LMM = L Minus Minus (--), LMG = L Minux Greater (->)
% the most important: * below + so * has priority.

<<[[union yacc]] other fields>>=
Node*   node;
@

% see Node also in Core data structure section, with Z, left/right, new(), etc

<<type declarations>>=
%type   <node>  name tag 
%type   <node>  stmnt   block slist ulstmnt labels label forexpr
%type   <node>  expr    cexpr lexpr  xuexpr uexpr pexpr  elist  string lstring
%type   <node>  adecl   qual init ilist  adlist qlist  arglist
%type   <node>  xdecor xdecor2 edecor  abdecor abdecor1 abdecor2 abdecor3
%type   <node>  zexpr zelist zcexpr zarglist
@
% xdecl, pdecl are not here, because do side effects I think.
% ltag is a sym. 
%note that name and tag are nodes here, convenient so can use diag($xx) on
% them. 

% in what follows a few conventions: 
% zxxx means zero or more e.g. zctlist means list of ctl 0 or more
% ct means class(storage) and type(part one)
% x means external
% u means unary, ul = unary or label
% ab means abstract
% cexpr means comma expr

% note that all terminal chars like ')' are actually Node* too
% so can pass them to warn() to get accurate error location

<<grammar>>=
prog:
  /* empty */
|   prog xdecl

<<declarator rules>>
<<statements rules>>
<<expressions rules>>
<<initializers rules>>
<<types, storage classes, qualifiers rules>>
<<names rules>>

<<extra grammar rules>>
<<ebnf grammar rules>>
@



<<constant YYMAXDEPTH>>=
//@Scheck: used in t.tab.c probably
#define YYMAXDEPTH	1500
@


\section{Declarations and definitions, part one}

<<declarator rules>>=
<<external declarator rules>>
<<automatic declarator rules>>
<<parameter declarator rules>>
<<abstract declarator rules>>
<<structure element declarator rules>>
@

<<external declarator rules>>=
<<xdecl rule>>
<<xdlist rule>>
<<xdecor rule>>
<<xdecor2 rule>>
@
% "external" in the sense that define entities visible externally
% so globals, functions, structures.

% will use declaration for declaration and definition sometimes.

% will use declarator, important concept.

% An important thing, types are constructed in a complex way in C.
% Types have part one, part two A, part two B. And this has some
% implications on the AST building for the identifier and the type
% of the identifier.

\subsection{No-declarator declarations}

% was "nameless" declarations, but it actually can define struct, 
% in which case they have a name ... so better title I think
% even if it's very technical, but I have too.

% prog -> <>  (list)
<<xdecl rule>>=
/*
 * external declarator
 */
xdecl:
    zctlist ';'          { dodecl(xdecl, lastclass, lasttype, Z); }
@
% This declaration covers actually many definitions as
% can have complex struct def, typedefs, inside the t or zct_list.
% recall that ct means class_storage and type, z means zero.
% ex: 
%  - int; (not very useful)
%  - struct x; (forward decl)
%  - struct x { ... }; (ok something kinda useful).
%todo: effect of dodecl when pass Z? xdecl will not be called anyway ...
% to set nearln? 


%ugly? do that because C sucks? 
%ocaml: my parser_c.mly was also complicated when it come to decl handling ...
<<global lastclass>>=
// enum<storage_class>
//@Scheck: y.tab.c
char	lastclass;
@

<<global lasttype>>=
//@Scheck: y.tab.c
Type*	lasttype;
@
% really lastype_partone.

<<ebnf grammar rules>>=
zctlist:
 /* empty */
    {
        lastclass = CXXX;
        lasttype = types[TINT];
    }
|   ctlist
@
% so no type means int by default, as in 'x;' really means 'int x;'
% can even have ';' which is not very useful.
%ocaml: could return a pair instead of modifying globals.

<<extra grammar rules>>=
ctlist:
    types
    {
        lasttype = $1.t;
        lastclass = $1.c;
    }
@
% it's not really 'types', it's types_and_storage really. will see types later.
%todo: why not continue that? so instead of lasttype and lastclass
% we could just do $1.t and $1.c?

%codegen: no code gen, but define schemas and offsets that
% expr generation will then use, so can have more complex
% globals or data access than arrays indexes.

\subsection{Declarator-based declarations}

% It's not just for globals, it can also define
% typedefs, and even struct def and globals at the same time.
% also can declare prototypes.
% hmm I love C. It makes it so easy to present ...

<<xdecl rule>>=
|   zctlist xdlist ';'
@
% With xdlist can now have global declarations. It also
% includes the types part2, what are decorations (2a and 2b) around 
% the identifier.
% xd means external decl.
% ex:
%  - int x; (more useful)
%  - int x,y,z; (list)
%  - struct x { ... } y;
%  - int foo[4]; (array)
%  - int foo(int x); (prototype forward or external decl)

<<xdlist rule>>=
xdlist:
    xdecor  { dodecl(xdecl, lastclass, lasttype, $1); }
|   xdlist ',' xdlist
@
%$
% will see xdecor below, essentially a (decorated) name.
% x decorated with more type info (left pointer, right array and func).
% but for now xdecor =~ identifier, which is ONAME.




% dodecl() modify especially the lastdcltype global.
% its main role is to possibly compose the part one (type t) and two (node n)
% of the type that is spreaded around the identifier (or abstract declarator).
% note that the node n is Z or a symbol with also the type part two info,
% so either ONAME or OIND of ONAME, etc.
% dodecl() also adjusts the parameter node, to extract the ONAME that
% can be deep, and then doing so construct the type of this ONAME
% on its way.
<<function dodecl>>=
Node*
dodecl(void (*f)(int,Type*,Sym*), int class, Type *t, Node *n)
{
    <<[[dodecl()]] locals>>

    nearln = lineno;
    lastfield = 0;

loop:
    if(n != Z)
     switch(n->op) {
     // can adjust t using information from node n
     <<[[dodecl()]] switch node kind cases>>
     default:
         diag(n, "unknown declarator: %O", n->op);
         break;
     }

    lastdcltype = t;
    return n;
}
@
% why set nearln? we will construct some new nodes? yes, can do
% during revertdcl() for volatiles hidden instructions USED(&local_volatile)

%less: so for the no-declarator based declarations dodecl
% does actually nothing? it just sets lastdcltype
% with lastype, but is this useful?

% hmm why Type* and not Decl*? rename lastdcltype?
<<global lastdcl>>=
Type*	lastdcltype;
@
%old: was call lastdcl, but confusing


<<constant NODECL>>=
#define	NODECL	((void(*)(int, Type*, Sym*)) nil)
@
% no decl
%less: rename NO_DECL_CALLBACK?

%codegen: will generate some ADATA and AGLOBL


\subsection{Entity declarations, the declarator}
% also use for definitions

<<xdecor rule>>=
xdecor:
    xdecor2
@
% will contain the before identifier, type part 2a (pointers)

<<xdecor2 rule>>=
xdecor2:
    tag
|   '(' xdecor ')'             { $$ = $2;   }
@
% will contain the after identifier, type part 2b (array and functions)
%$

% xdecor -> xdecor2 -> tag
<<names rules>>=
tag:
    ltag
    {
        $$ = new(ONAME, Z, Z);
        $$->sym = $1;

        $$->type = $1->type;
        $$->etype = ($1->type != T) ? $1->type->etype : TVOID;

        $$->xoffset = $1->offset;
        $$->class = $1->class;
    }
@
% similar to name rule but here it's for decl/defs, 'name' rule is for use.
% tag! but it's really ident.
% the type will be adjusted in dodecl as goes up the chain.
%the symbol has a type? $1->type? yes if the symbol was forward declared
% before, as in  int x; ...  int x = 1;
% in which case we want to make sure those types are compatible.
% this is probably the same for the class.
%todo: but same for offset?? it can have one already?


<<type declarations>>=
%type   <sym>   ltag
@

<<names rules>>=
ltag:
    LNAME
|   LTYPE
@
% no grammar ambiguity?? so can have typedef int x; ...; x x;  
% declarations without pb?

<<[[dodecl()]] locals>>=
Sym *s;
@

% dodecl(..., node n != Z) -> <>
<<[[dodecl()]] switch node kind cases>>=
case ONAME:
    if(f == NODECL)
        break;
    s = n->sym;

    // callback! should set s->type
    (*f)(class, t, s);

    <<[[dodecl()]] case ONAME, if local static variable>>
    firstbit = 0;

    n->sym = s;
    n->type = s->type;
    n->etype = (s->type != T) ? s->type->etype : TVOID;
    n->xoffset = s->offset;
    n->class = s->class;

    if(debug['d'])
        dbgdecl(s);
    acidvar(s);

    s->varlineno = lineno;
    break;
@



% dodecl(<>, ..., node n != Z) -> <>
<<function xdecl>>=
void
xdecl(int class, Type *t, Sym *s)
{
    long o = 0; // offset

    // adjusting class (and possibly o for CEXREG)
    switch(class) {
    <<[[xdecl()]] switch class cases>>
    }

    <<[[xdecl()]] sanity checks>>

    tmerge(t, s);
    s->type = t;
    s->class = class;
    s->block = 0;
    s->offset = o;
}
@
% block 0, because global scope?
% tmerge because the symbol may have been previously forward declared?
% so need to check if consistent. See typechecking section?

% now this symbol has a type!

\subsection{Function definitions}

<<global firstdcl>>=
Decl*	firstdcl;
@
% save of dclstack, to have a pointer for function scope,
% so for instance can add labels at the outer scope of the function
% (because we don't want revertdecl() to undo nested labels)

<<global thisfn>>=
Type*	thisfntype;
@
%old: was called thisfn, but confusing.
%this is useful to annotate the type of RETURN



<<xdecl rule>>=
|   zctlist xdecor
    {
        lastdcltype = T;
        firstarg = S;
        dodecl(xdecl, lastclass, lasttype, $2);
        <<xdecl rule, sanity check lastdcltype is a function type>>
        thisfntype = lastdcltype;
        markdcl();
        firstdcl = dclstack;
        argmark($2, 0);
    }
    pdecl
    {
        argmark($2, 1);
    }
    block
    {
        Node *n;
        n = revertdcl();
        <<xdecl rule, adjust block body with possible hidden generated nodes>>
        if(debug['x']) {
            prtree($2, "func");
            prtree($6, "body");
        }
        if(!debug['a'] && !debug['Z'])
            codgen($6, $2); // !!!!!!!!!!!!!!!!!!!!!
    }
@
%$

% markdcl(), revertdcl(), see next section

<<xdecl rule, sanity check lastdcltype is a function type>>=
if(lastdcltype == T || lastdcltype->etype != TFUNC) {
    diag($2, "not a function");
    lastdcltype = types[TFUNC];
}
@
%$

% lots of things happen in xdecor actually as the parameters
% will be there.

%codegen: will be a TEXT



\section{Statements}
% block, labels, stmts


% seen 'block' for func def, block is a list of stmnt
<<statements rules>>=
block:
 '{' slist '}'
    {
        $$ = invert($2);
        if($$ == Z)
            $$ = new(OLIST, Z, Z);
    }

slist:
  /* empty */      { $$ = Z;    }
|   slist adecl    { $$ = new(OLIST, $1, $2); }
|   slist stmnt    { $$ = new(OLIST, $1, $2); }
@
%$
% adecl! for locals

% invert in place
<<function invert>>=
Node*
invert(Node *n)
{
    Node *i;

    if(n == Z || n->op != OLIST)
        return n;
    i = n;
    for(n = n->left; n != Z; n = n->left) {
        if(n->op != OLIST)
            break;
        i->left = n->right;
        n->right = i;
        i = n;
    }
    i->left = n;
    return i;
}
@



% can have labels before stmts
<<statements rules>>=
stmnt:
    ulstmnt
|   labels ulstmnt { $$ = new(OLIST, $1, $2); }
|   error ';'      { $$ = Z; }
@
% hmm could have a OLABELS no?

% ul = no label? unlabeled?
<<statements rules>>=
<<ulstmnt rule>>
<<label rule>>
@

<<ulstmnt rule>>=
ulstmnt:
    zcexpr ';'
@
% zero or commaexpr, will see in next chapter expressions

<<ebnf grammar rules>>=
labels:
    label
|   labels label  { $$ = new(OLIST, $1, $2); }
@
% why not OLABEL instead?


%codegen: most of the stmts will turns into AB and conditional
% jmps (e.g. ABNE). There are many idioms in the use of AB/ABxxx
% that can be captured in a few general control constructs.

\subsection{Blocks}

% have seen block rule above used for example for function definitions.
% a single stmt can also be a block! nested language.

<<ulstmnt rule>>=
|   {
        markdcl();
    }
    block
    {
        Node *n;
        n = revertdcl();
        <<ulstmt rule, adjust block body with possible hidden generated nodes>>
        else
            $$ = $2;
    }
@
%$
% have explained revertdcl() in Declaration section in core DS.
%old: originally in comment //  if($2 != Z) $$ = new(OLIST, $2, $$);


%codegen: mostly sequence of instructions. Nested so can
% have different scope, but it's a typechecking issue more than
% codegeneration. The assembly just provides object/file-scope
% (via the static <> suffix), and does not provide any typechecking
% (even use of external entities are found out only at link time).

\subsection{Conditionals}

<<statement nodes>>=
OIF,
@
%ocaml: OIF(l=expr, r=OLIST(then, else))

<<ulstmnt rule>>=
|   LIF '(' cexpr ')' stmnt
    {
        $$ = new(OIF, $3, new(OLIST, $5, Z));
        if($5 == Z)
            warn($3, "empty if body");
    }
|   LIF '(' cexpr ')' stmnt LELSE stmnt
    {
        $$ = new(OIF, $3, new(OLIST, $5, $7));
        if($5 == Z)
            warn($3, "empty if body");
        if($7 == Z)
            warn($3, "empty else body");
    }
@
%$
% cexpr means  comma expr
% OLIST here could be an OPAIR

\subsection{Loops}

<<statement nodes>>=
OWHILE,
ODWHILE,
OFOR,
@

<<ulstmnt rule>>=
|   LWHILE '(' cexpr ')' stmnt          { $$ = new(OWHILE, $3, $5); }
|   LDO stmnt LWHILE '(' cexpr ')' ';'  { $$ = new(ODWHILE, $5, $2); }
@

<<ulstmnt rule>>=
|   { 
        markdcl(); 
    } 
    LFOR '(' forexpr ';' zcexpr ';' zcexpr ')' stmnt
    {
        Node *n;
        n = revertdcl();
        <<ulstmt rule, adjust forexpr with possible hidden generated nodes>>
        $$ = new(OFOR, new(OLIST, $6, new(OLIST, $4, $8)), $10);
    }
@
% markdecl because forexpr allow local declaration ext, as in C++
%ocaml: OFOR(l=OLIST(forcond, OLIST(forinit, forend)), r=body)

% C extension for(int i; ... ?) hence the markdcl, for scope.
<<statements rules>>=
forexpr:
    zcexpr
|   ctlist adlist { $$ = $2; }
@
%$

\subsection{Control flow jumps}

<<statement nodes>>=
ORETURN,

OBREAK,
OCONTINUE,
@

<<ulstmnt rule>>=
|   LRETURN zcexpr ';'
    {
        $$ = new(ORETURN, $2, Z);
        $$->type = thisfntype->link;
    }
@
%$
%useful thisfntype

<<ulstmnt rule>>=
|   LBREAK ';'     { $$ = new(OBREAK, Z, Z); }
|   LCONTINUE ';'  { $$ = new(OCONTINUE, Z, Z); }
@
%$


\subsection{Switch}

<<statement nodes>>=
OSWITCH,
OCASE, // for default too, in which case Node.left is null
@

<<ulstmnt rule>>=
|   LSWITCH '(' cexpr ')' stmnt
    {
       <<ulstmt rule, SWITCH case, adjust cexpr node>>
        $$ = new(OSWITCH, $3, $5);
    }
@


% note that 'labels' with an 's' before, so can have case 1: case 2: ...

<<label rule>>=
label:
    LCASE expr ':'  { $$ = new(OCASE, $2, Z); }
|   LDEFAULT ':'    { $$ = new(OCASE, Z, Z); }
@
%$
%ocaml: OCASE(l=option(expr), r=null)


<<ulstmt rule, SWITCH case, adjust cexpr node>>=
// generate (0:int - (0:int - x))
// which will force the usual arithmetic conversions
// (and will be simplified later by some transformations)

$$ = new(OCONST, Z, Z);
$$->vconst = 0;
$$->type = types[TINT];
$3 = new(OSUB, $$, $3);

$$ = new(OCONST, Z, Z);
$$->vconst = 0;
$$->type = types[TINT];
$3 = new(OSUB, $$, $3);
@
% I originally thought there was a copy paste bug above,
% and even Rob Pike thought so, but it turned out it's not a bug :)
% why 0 - 0 - x? why not 0+x?
%"you can't subtract pointers from 0 but you can add 0 to a pointer,
%since + is commutative" forsith
%less: could use Node *n; local instead of $$.


\subsection{Labels and goto}

% seen labels rule before in Statements section header.

<<statement nodes>>=
OLABEL,
OGOTO,
@

<<label rule>>=
|   LNAME ':'       { $$ = new(OLABEL, dcllabel($1, true), Z); }
@
%$
% what? it's in label rule? with case and default??
% actually then often do  case x: talpha: ...

<<ulstmnt rule>>=
|   LGOTO ltag ';' { $$ = new(OGOTO, dcllabel($2, false), Z); }
@
%$
% ltag = LNAME | LTYPE, see later


<<[[Sym]] label value fields>>=
Node*	label;
@
% can then access pc via s->label->pc?

% flag is true for label definition context, false for use (e.g. in goto)
<<function dcllabel>>=
//@Scheck: used by cc.y
Node* dcllabel(Sym *s, bool defcontext)
{
    Decl *d;
    Decl d1;
    Node *n;

    n = s->label;
    <<[[dcllabel()]] if n not null, mark node as declared or used>>

    d = push();
    d->sym = s;
    d->val = DLABEL;

    //pop(dclstack)
    dclstack = d->link;

    //add_list(d, firstdcl)
    d1 = *firstdcl;
    *firstdcl = *d;
    *d = d1;
    firstdcl->link = d;
    firstdcl = d;

    n = new(OXXX, Z, Z);
    n->sym = s;
    n->complex = defcontext;
    n->addable = !defcontext;

    s->label = n;

    if(debug['d'])
        dbgdecl(s);
    return n;
}
@
% The first occurence of a label adds it to the symbol table.
% So can do goto of a label defined later. Its label field will be set. 
% We use firstdcl because we want to add label at function scope,
% not in nested latest scope, because revertdcl() should
% not revert nested labels.
%less: means a local var can hide a nested label? I think so :)
%  hmmm maybe not as namespace different and so label will still
%  be in the field of the symbol of the local var.

<<[[dcllabel()]] if n not null, mark node as declared or used>>=
if(n != Z) {
    if(defcontext) {
        if(n->complex)
            diag(Z, "label reused: %s", s->name);
        n->complex = true;	// declared
    } else
        n->addable = true;	// used
    return n;
}
@
% ugly abuses of complex and addable field here
% use two fields because want to detect redeclared labels, and
% unused labels.
%less: cleanup abuse of complex/addable, do like in scheck field for used

%codegen: really match assembly here, labels and AB.

\section{Expressions}

<<expressions rules>>=
<<expr rule>>
<<xuexpr rule>>
<<uexpr rule>>
<<pexpr rule>>
@
% xu = extended unary(cast), u = unary, p = primary expr

<<expr rule>>=
expr:
    xuexpr
@

<<xuexpr rule>>=
xuexpr:
    uexpr
@

<<uexpr rule>>=
uexpr:
    pexpr
@

<<pexpr rule>>=
pexpr:
    '(' cexpr ')' { $$ = $2; }
@
%$

<<expression nodes>>=
OCOMMA,
@

<<expressions rules>>=
cexpr:
    expr
|   cexpr ',' cexpr { $$ = new(OCOMMA, $1, $3); }
@
%$






% e.g. in array def context, can have an int or nothing, TODO rename zlexpr?
<<expressions rules>>=
zexpr:
  /* empty */ { $$ = Z; }
|   lexpr
@


<<expressions rules>>=
lexpr:
    expr
    {
        $$ = new(OCAST, $1, Z);
        $$->type = types[TLONG];
    }
@
%$
% long expr. zexpr is a longexpr because empty means 0 which is a long.





<<ebnf grammar rules>>=
zcexpr:
  /* empty */ { $$ = Z; }
|   cexpr
@
% this time for a zero it means really None.




% I used to have a "Binary expr", "Unary expr", "Primary expr" 
% but it makes more sense to structure around features
% the user can understand rather than grammar specificities

%codegen: assembly have arith/pointers/... but only restricted
% forms. Here more general formulas of arbitrary depth.
% will be decomposed in a serie of AADD, AAND, etc. And
% use of temporary registers and AMOVW.
% Also assembly handles only a few types (byte, half word, word,
% with some unsigned variants, float), here we can have also
% vlong, complex structures, etc.

\subsection{Arithmetic expressions}

% Similar to Machine.nw/Assembler.nw in some sense,
% except can compose them to form complex tree formulas.
% and also have DIV here even though the machine does not!

% also + is now overloaded! works for many integers (char/short/int/long/vlong)
% and many floats (double/float), so no need to use AADD, AADDF, AADDD

<<expression nodes>>=
OADD,
OSUB,

OMUL,
ODIV,
OMOD,
@

<<expr rule>>=
|   expr '+' expr { $$ = new(OADD, $1, $3); }
|   expr '-' expr { $$ = new(OSUB, $1, $3); }
|   expr '*' expr { $$ = new(OMUL, $1, $3); }
|   expr '/' expr { $$ = new(ODIV, $1, $3); }
|   expr '%' expr { $$ = new(OMOD, $1, $3); }
@

%\subsection{Bit?? expressions}


<<expression nodes>>=
OAND,
OOR,
OXOR,
OASHL,
OASHR,

@
% OAS ... rename? so less confusing with the other assign nodes?


<<expr rule>>=
|   expr '&' expr  { $$ = new(OAND, $1, $3); }
|   expr '^' expr  { $$ = new(OXOR, $1, $3); }
|   expr '|' expr  { $$ = new(OOR, $1, $3); }
|   expr LRSH expr { $$ = new(OASHR, $1, $3); }
|   expr LLSH expr { $$ = new(OASHL, $1, $3); }
@

% see also in unary expression POS and NEG



<<expression nodes>>=
OPOS,
ONEG,
@

<<uexpr rule>>=
|   '+' xuexpr { $$ = new(OPOS, $2, Z); }
|   '-' xuexpr { $$ = new(ONEG, $2, Z); }
@

%codegen: similar asm instructions (e.g. AADD, AAND)

\subsection{Boolean expressions}

<<expression nodes>>=
OANDAND,
OOROR,
@

<<expr rule>>=
|   expr LANDAND expr { $$ = new(OANDAND, $1, $3); }
|   expr LOROR expr   { $$ = new(OOROR, $1, $3); }
@


<<expression nodes>>=
ONOT,
OCOM,
@
%OCOM?

<<uexpr rule>>=
|   '!' xuexpr { $$ = new(ONOT, $2, Z); }
|   '~' xuexpr { $$ = new(OCOM, $2, Z); }
@

%\subsection{Relational? expressions}

<<expression nodes>>=
OEQ,
ONE,

OLT,
OGT,
OLE,
OGE,
@
% there are some more opcodes that are generated after
% parsing mimicing OLT/... but explicitly unsigned (OLO/OHS/...)

<<expr rule>>=
|   expr LEQ expr  { $$ = new(OEQ, $1, $3); }
|   expr LNE expr  { $$ = new(ONE, $1, $3); }
|   expr '<' expr  { $$ = new(OLT, $1, $3); }
|   expr '>' expr  { $$ = new(OGT, $1, $3); }
|   expr LLE expr  { $$ = new(OLE, $1, $3); }
|   expr LGE expr  { $$ = new(OGE, $1, $3); }
@

%codegen: similar asm instructions (e.g. AAND again?).
% OEQ?



\subsection{Assignments}
% which really should be instructions, not expressions, grrr


<<expression nodes>>=
OAS,
@

<<expr rule>>=
|   expr '=' expr  { $$ = new(OAS, $1, $3); }
@


% sugar
<<expression nodes>>=
OASADD,
OASSUB,

OASMUL,
OASMOD,
OASDIV,

OASAND,
OASOR,
OASXOR,

OASASHL,
OASASHR,
@

<<expr rule>>=
|   expr LPE expr  { $$ = new(OASADD, $1, $3); }
|   expr LME expr  { $$ = new(OASSUB, $1, $3); }
|   expr LMLE expr { $$ = new(OASMUL, $1, $3); }
|   expr LDVE expr { $$ = new(OASDIV, $1, $3); }
|   expr LMDE expr { $$ = new(OASMOD, $1, $3); }
|   expr LANDE expr { $$ = new(OASAND, $1, $3); }
|   expr LXORE expr { $$ = new(OASXOR, $1, $3); }
|   expr LORE expr  { $$ = new(OASOR, $1, $3); }
|   expr LLSHE expr { $$ = new(OASASHL, $1, $3); }
|   expr LRSHE expr { $$ = new(OASASHR, $1, $3); }
@
%$
%less: why not removing the sugar instead? and decompose
% in an OADD and OAS? easier to optimize?

%codegen: =~ AMOV in Assembler.nw

\subsection{Pointers}
% C power!

<<expression nodes>>=
OIND, // for uses (dereference) and also defs (and decls)
OADDR,
@
% see also OINDREG, generated after parsing

<<uexpr rule>>=
|   '*' xuexpr { $$ = new(OIND, $2, Z); }
|   '&' xuexpr { $$ = new(OADDR, $2, Z); }
@

%codegen: asm:  $name, (register) or name(SB).


\subsection{Function calls}

<<misc nodes>>=
OFUNC, // used for uses (calls) but also defs (and decls)
@
% should split? have a OCALL?

% funcall!
<<pexpr rule>>=
|   pexpr '(' zelist ')'
    {
        $$ = new(OFUNC, $1, Z);
        <<pexpr rule, implicit declaration of unknown function>>
        $$->right = invert($3);
    }
@

<<ebnf grammar rules>>=
zelist:
  /* empty */ { $$ = Z; }
|   elist
@

<<expressions rules>>=
elist:
    expr
|   elist ',' elist { $$ = new(OLIST, $1, $3); }
@
% elist really? should be expr no? or have a %left for ',' ?


<<pexpr rule, implicit declaration of unknown function>>=
if(($1->op == ONAME) && ($1->type == T))
    dodecl(xdecl, CXXX, types[TINT], $$);
@
%less: should be a flag honestly ...
% no forward decl of entity name, so assumes return an int?
% should warn instead about undeclared symbol? cleaner
% than this implicit prototype declaration where return an int



%codegen: ABL, but more convenient in C :) automatic
% hiding of FP and offsets, use symbolic names instead,
% and have typechecking of args vs params.


\subsection{Array accesses}

% unsugar x[y] as *(x+y) :)
<<pexpr rule>>=
|   pexpr '[' cexpr ']' { $$ = new(OIND, new(OADD, $1, $3), Z); }
@

%codegen: operand to other op with offset  xxx+i(SB), e.g.
% x[y] = 1 -> AMOVW $1, R1; AMOVW R1, x+y(SB) (which will expand
% into a store low level ARM instruction).

\subsection{Field accesses}

<<expression nodes>>=
ODOT,
@

% unsugar x->y as (*x).y
<<pexpr rule>>=
|   pexpr '.' ltag
    {
        $$ = new(ODOT, $1, Z);
        $$->sym = $3;
    }
|   pexpr LMG ltag
    {
        $$ = new(ODOT, new(OIND, $1, Z), Z);
        $$->sym = $3;
    }
@

%codegen: more structured arrays! with different size, but ultimately
% will be transformed in array access (pointer + offset).


\subsection{Entity uses}

<<pexpr rule>>=
|   name
@

% use (def of entities use 'tag' instead, in xdecor2, not 'name')
<<names rules>>=
name:
    LNAME
    {
        $$ = new(ONAME, Z, Z);
        <<name rule, if local static variable>>
        $$->sym = $1;
        $$->type = $1->type;
        $$->etype = ($1->type != T) ? $1->type->etype : TVOID;
        $$->xoffset = $1->offset;
        $$->class = $1->class;
         <<name rule, LNAME case, adjust more fields>>
    }
@
% similar to tag rule
%$

%codegen: name(SB), or name+-offset(FP) for params and locals
% A C symbol is an assembly symbol! It is kept as is.

\subsection{Numeric constants}

<<expression nodes>>=
OCONST,
@
% also for float
% the const keyword is actually a GCONSTNT, and LCONST

%codegen: same in assembly, $intvalue.

\subsubsection{Integers}

<<[[Node]] value fields>>=
vlong	vconst; /* non fp const */ // for OCONST
@
%// abused in switch?
% could be put in a union with fpconst and rstring (but not cstring)
% take vlong to store the maximum possible value.


<<pexpr rule>>=
|   LCONST
    {
        $$ = new(OCONST, Z, Z);
        $$->type = types[TINT];
        $$->vconst = $1;
        $$->cstring = strdup(symb);
    }
|   LLCONST
    {
        $$ = new(OCONST, Z, Z);
        $$->type = types[TLONG];
        $$->vconst = $1;
        $$->cstring = strdup(symb);
    }
|   LVLCONST
    {
        $$ = new(OCONST, Z, Z);
        $$->type = types[TVLONG];
        $$->vconst = $1;
        $$->cstring = strdup(symb);
    }
@
%$


<<pexpr rule>>=
|   LUCONST
    {
        $$ = new(OCONST, Z, Z);
        $$->type = types[TUINT];
        $$->vconst = $1;
        $$->cstring = strdup(symb);
    }
|   LULCONST
    {
        $$ = new(OCONST, Z, Z);
        $$->type = types[TULONG];
        $$->vconst = $1;
        $$->cstring = strdup(symb);
    }
|   LUVLCONST
    {
        $$ = new(OCONST, Z, Z);
        $$->type = types[TUVLONG];
        $$->vconst = $1;
        $$->cstring = strdup(symb);
    }
@
%$

\subsubsection{Floats}

<<[[Node]] value fields>>=
double	fconst;		/* fp constant */ // for OCONST
@

% take double to store the maximum possible value.

<<pexpr rule>>=
|   LFCONST
    {
        $$ = new(OCONST, Z, Z);
        $$->type = types[TFLOAT];
        $$->fconst = $1;
        $$->cstring = strdup(symb);
    }
|   LDCONST
    {
        $$ = new(OCONST, Z, Z);
        $$->type = types[TDOUBLE];
        $$->fconst = $1;
        $$->cstring = strdup(symb);
    }
@
%$

\subsection{String constants}
% char constant? unsugard in yylex?

%codegen: same in assembly except not limited to 8bytes,
% and also handle unicode here.

\subsubsection{Ascii strings}
% classic '\0' terminated "C strings"

<<expression nodes>>=
OSTRING,
@

<<pexpr rule>>=
|   string
|   lstring
@

<<[[Node]] value fields>>=
char*	cstring;	/* character string */ // for OSTRING (and OCONST)
@
% could be put in a union, except it uses both vconst and cstring
% at the same time.
% used also to remember the original string representation of the integer.

<<expressions rules>>=
string:
    LSTRING
    {
        $$ = new(OSTRING, Z, Z);
        $$->type = typ(TARRAY, types[TCHAR]);
        $$->etype = TARRAY;
        $$->type->width = $1.l + 1;
        $$->cstring = $1.s;
        $$->sym = symstring;
        $$->class = CSTATIC;
    }
|   string LSTRING
    {
        char *s;
        int n;

        n = $1->type->width - 1;
        s = alloc(n+$2.l+MAXALIGN);

        memcpy(s, $1->cstring, n);
        memcpy(s+n, $2.s, $2.l);
        s[n+$2.l] = '\0';

        $$ = $1;
        $$->type->width += $2.l;
        $$->cstring = s;
    }
@
%less: C extension to concatenate strings. could be aspectized
% or even removed.
% do not free the previous one?


% symstring? see later?

\subsubsection{Unicode strings}
% long strings

<<expression nodes>>=
OLSTRING,
@

<<[[Node]] value fields>>=
TRune*	rstring;	/* rune string */ // for OLSTRING
@

%in cc.h, which should include the u.h before?
%typedef	Rune	TRune;	/* target system type */

<<constant TRUNE>>=
/* adapt size of Rune to target system's size */
TRUNE = sizeof(TRune)==4? TUINT: TUSHORT,
@


% unicode
<<expressions rules>>=
lstring:
    LLSTRING
    {
        $$ = new(OLSTRING, Z, Z);
        $$->type = typ(TARRAY, types[TRUNE]);
        $$->etype = TARRAY;
        $$->type->width = $1.l + sizeof(TRune);
        $$->rstring = (TRune*)$1.s;
        $$->sym = symstring;
        $$->class = CSTATIC;
    }
|   lstring LLSTRING
    {
        char *s;
        int n;

        n = $1->type->width - sizeof(TRune);
        s = alloc(n+$2.l+MAXALIGN);

        memcpy(s, $1->rstring, n);
        memcpy(s+n, $2.s, $2.l);
        *(TRune*)(s+n+$2.l) = 0;

        $$ = $1;
        $$->type->width += $2.l;
        $$->rstring = (TRune*)s;
    }
@
%$


\subsection{Cast}

<<expression nodes>>=
OCAST,
@

<<xuexpr rule>>=
|   '(' tlist abdecor ')' xuexpr
    {
        $$ = new(OCAST, $5, Z);
        dodecl(NODECL, CXXX, $2, $3);
        $$->type = lastdcltype;
        $$->xcast = true;
    }
@
%$
% extended unary expr =~ cast expr
% dodecl to have lastdcltype, to reconstruct the whole type
% from the tlist (part one) and abdecor (part two).
%less: what will be the ONAME for abdecor? it's abstract
% so it should have no name ...

<<[[Node]] origin tracking fields>>=
bool 	xcast;
@
% explicit cast, to remember, as we will add some implicit
% cast during the typechecking/annotating/expliciting phase.

%codegen: a typechecking issue first, but then some conversions too?

\subsection{Ternary expressions}

<<expression nodes>>=
OCOND,
@
%ocaml: OCOND(l=cond,r=OLIST(then, else))
% could be an OPAIR here.

<<expr rule>>=
|   expr '?' cexpr ':' expr { $$ = new(OCOND, $1, new(OLIST, $3, $5)); }
@
%$

%codegen: ABxx and AMOV

\subsection{Prefix/postfix}

<<expression nodes>>=
OPREDEC,
OPREINC,
@

<<uexpr rule>>=
|   LPP xuexpr { $$ = new(OPREINC, $2, Z); }
|   LMM xuexpr { $$ = new(OPREDEC, $2, Z); }
@


<<expression nodes>>=
OPOSTINC,
OPOSTDEC,
@

<<pexpr rule>>=
|   pexpr LPP { $$ = new(OPOSTINC, $1, Z); }
|   pexpr LMM { $$ = new(OPOSTDEC, $1, Z); }
@

%less: why not unsugar? because it's more complicated than
% just do x = x+1; because this affectation must also be done
% at the right place when it's inside a complex expression
% (it must be moved out of the expression and put as a sequence
% before, or after)

%codegen: sequence ; and AMOV, AADD.


%old:\subsection{Primary expressions}
% call, array access, field access, sizeof, 

\subsection{[[sizeof()]]}

<<expression nodes>>=
OSIZE,
@

<<pexpr rule>>=
|   LSIZEOF '(' tlist abdecor ')'
    {
        $$ = new(OSIZE, Z, Z);
        dodecl(NODECL, CXXX, $3, $4);
        $$->type = lastdcltype;
    }
@


<<uexpr rule>>=
|   LSIZEOF uexpr { $$ = new(OSIZE, $2, Z); }
@
%$
% not super useful this one, could be removed

%codegen: constant computation, to reflect schema of data.

\section{Initializers and designators}


<<xdlist rule>>=
|   xdecor
    {
        $1 = dodecl(xdecl, lastclass, lasttype, $1);
    }
    '=' init
    {
        doinit($1->sym, $1->type, 0L, $4);
    }
@
%$
%0L ?

<<variable declaration nodes>>=
OINIT,
@
% but just for list! otherwise it's really OASI.


<<initializers rules>>=
init:
    expr
|   '{' ilist '}' { $$ = new(OINIT, invert($2), Z); }
@
%$

<<initializers rules>>=
ilist:
    qlist
|   init
|   qlist init { $$ = new(OLIST, $1, $2); }

qlist:
    init ','
|   qlist init ','  { $$ = new(OLIST, $1, $2); }
|   qual
|   qlist qual      { $$ = new(OLIST, $1, $2); }
@
%$
% why not OLIST also for the first one?

<<variable declaration nodes>>=
OELEM,  // field designator
@
% for regular access it's TDOT, could have been marged
%less: rename OINITFIELD?

<<misc nodes>>=
OARRAY, // used for uses (designator) and defs (and decl)
@
%less: could be renamed no? OINITARRAY
%note that for regular uses that are not designator it does not
% use OARRAY but instead unsugar in OIND and OADD


<<initializers rules>>=
qual:
    '[' lexpr ']' { $$ = new(OARRAY, $2, Z); }
|   '.' ltag
    {
        $$ = new(OELEM, Z, Z);
        $$->sym = $2;
    }
|   qual '='
@
%$
% alternate syntax qual =




<<global initlist>>=
Node*	initlist;
@

<<function doinit>>=
Node*
doinit(Sym *s, Type *t, long o, Node *a)
{
    Node *n;

    if(t == T)
        return Z;
    if(s->class == CEXTERN) {
        s->class = CGLOBL;
        if(debug['d'])
            dbgdecl(s);
    }
    if(debug['i']) {
        print("t = %T; o = %ld; n = %s\n", t, o, s->name);
        prtree(a, "doinit value");
    }


    n = initlist;
    if(a->op == OINIT)
        a = a->left;
    initlist = a;

    a = init1(s, t, o, 0);
    if(initlist != Z)
        diag(initlist, "more initializers than structure: %s",
            s->name);
    initlist = n;

    return a;
}
@
% init1 below


% could be made a static local of init1?
<<global nodcast>>=
Node*	nodcast;
@

% declaration and expression actually
<<expression nodes>>=
OASI, // appears during parsing
@
% assign initializer?

% doinit -> <>
<<function init1>>=
Node*
init1(Sym *s, Type *t, long o, int exflag)
{
    Node *a, *l, *r, nod;
    Type *t1;
    long e, w, so, mw;

    a = peekinit();
    if(a == Z)
        return Z;

    if(debug['i']) {
        print("t = %T; o = %ld; n = %s\n", t, o, s->name);
        prtree(a, "init1 value");
    }

    if(exflag && a->op == OINIT)
        return doinit(s, t, o, nextinit());

    switch(t->etype) {
    case TCHAR:
    case TUCHAR:
    case TINT:
    case TUINT:
    case TSHORT:
    case TUSHORT:
    case TLONG:
    case TULONG:
    case TVLONG:
    case TUVLONG:
    case TFLOAT:
    case TDOUBLE:

    case TIND:
    single:
        if(a->op == OARRAY || a->op == OELEM)
            return Z;

        a = nextinit();
        if(a == Z)
            return Z;

        if(t->nbits)
            diag(Z, "cannot initialize bitfields");
        if(s->class == CAUTO) {
            l = new(ONAME, Z, Z);
            l->sym = s;
            l->type = t;
            l->etype = s->type ? s->type->etype : TVOID;
            l->xoffset = s->offset + o;
            l->class = s->class;

            l = new(OASI, l, a);
            return l;
        }

        complex(a);
        if(a->type == T)
            return Z;

        if(a->op == OCONST) {
            if(vconst(a) && t->etype == TIND && a->type && a->type->etype != TIND){
                diag(a, "initialize pointer to an integer: %s", s->name);
                return Z;
            }
            if(!sametype(a->type, t)) {
                /* hoop jumping to save malloc */
                if(nodcast == Z)
                    nodcast = new(OCAST, Z, Z);
                nod = *nodcast;
                nod.left = a;
                nod.type = t;
                nod.lineno = a->lineno;
                complex(&nod);
                if(nod.type)
                    *a = nod;
            }
            if(a->op != OCONST) {
                diag(a, "initializer is not a constant: %s",
                    s->name);
                return Z;
            }
            if(vconst(a) == 0)
                return Z;
            goto gext;
        }
        if(t->etype == TIND) {
            while(a->op == OCAST) {
                warn(a, "CAST in initialization ignored");
                a = a->left;
            }
            if(!sametype(t, a->type)) {
                diag(a, "initialization of incompatible pointers: %s\n%T and %T",
                    s->name, t, a->type);
            }
            if(a->op == OADDR)
                a = a->left;
            goto gext;
        }

        while(a->op == OCAST)
            a = a->left;
        if(a->op == OADDR) {
            warn(a, "initialize pointer to an integer: %s", s->name);
            a = a->left;
            goto gext;
        }
        diag(a, "initializer is not a constant: %s", s->name);
        return Z;

    gext:
        gextern(s, a, o, t->width);

        return Z;

    case TARRAY:
        w = t->link->width;
        if(a->op == OSTRING || a->op == OLSTRING)
        if(typei[t->link->etype]) {
            /*
             * get rid of null if sizes match exactly
             */
            a = nextinit();
            mw = t->width/w;
            so = a->type->width/a->type->link->width;
            if(mw && so > mw) {
                if(so != mw+1)
                    diag(a, "string initialization larger than array");
                a->type->width -= a->type->link->width;
            }

            /*
             * arrange strings to be expanded
             * inside OINIT braces.
             */
            a = new(OUSED, a, Z);
            return doinit(s, t, o, a);
        }

        mw = -w;
        l = Z;
        for(e=0;;) {
            /*
             * peek ahead for element initializer
             */
            a = peekinit();
            if(a == Z)
                break;
            if(a->op == OELEM && t->link->etype != TSTRUCT)
                break;
            if(a->op == OARRAY) {
                if(e && exflag)
                    break;
                a = nextinit();
                r = a->left;
                complex(r);
                if(r->op != OCONST) {
                    diag(r, "initializer subscript must be constant");
                    return Z;
                }
                e = r->vconst;
                if(t->width != 0)
                    if(e < 0 || e*w >= t->width) {
                        diag(a, "initialization index out of range: %ld", e);
                        continue;
                    }
            }

            so = e*w;
            if(so > mw)
                mw = so;
            if(t->width != 0)
                if(mw >= t->width)
                    break;
            r = init1(s, t->link, o+so, 1);
            l = newlist(l, r);
            e++;
        }
        if(t->width == 0)
            t->width = mw+w;
        return l;

    case TUNION:
    case TSTRUCT:
        /*
         * peek ahead to find type of rhs.
         * if its a structure, then treat
         * this element as a variable
         * rather than an aggregate.
         */
        if(isstruct(a, t))
            goto single;

        if(t->width <= 0) {
            diag(Z, "incomplete structure: %s", s->name);
            return Z;
        }
        l = Z;

    again:
        for(t1 = t->link; t1 != T; t1 = t1->down) {
            if(a->op == OARRAY && t1->etype != TARRAY)
                break;
            if(a->op == OELEM) {
                if(t1->sym != a->sym)
                    continue;
                nextinit();
            }
            r = init1(s, t1, o+t1->offset, 1);
            l = newlist(l, r);
            a = peekinit();
            if(a == Z)
                break;
            if(a->op == OELEM)
                goto again;
        }
        if(a && a->op == OELEM)
            diag(a, "structure element not found %F", a);
        return l;

    default:
        diag(Z, "unknown type in initialization: %T to: %s", t, s->name);
        return Z;
    }
}
@



<<function newlist>>=
Node*
newlist(Node *l, Node *r)
{
    if(r == Z)
        return l;
    if(l == Z)
        return r;
    return new(OLIST, l, r);
}
@

<<function isstruct>>=
bool
isstruct(Node *a, Type *t)
{
    Node *n;

    switch(a->op) {
    case ODOTDOT:
        n = a->left;
        if(n && n->type && sametype(n->type, t))
            return true;
    case OSTRING: case OLSTRING:
    case OCONST:
    case OINIT:
    case OELEM:
        return false;
    }

    n = new(ODOTDOT, Z, Z);
    *n = *a;

    /*
     * ODOTDOT is a flag for tcom
     * a second tcom will not be performed
     */
    a->op = ODOTDOT;
    a->left = n;
    a->right = Z;

    if(tcom(n))
        return false;

    if(sametype(n->type, t))
        return true;
    return false;
}
@

<<function peekinit>>=
/*
 * get next major operator,
 * dont advance initlist.
 */
Node*
peekinit(void)
{
    Node *a;

    a = initlist;

loop:
    if(a == Z)
        return a;
    if(a->op == OLIST) {
        a = a->left;
        goto loop;
    }
    return a;
}
@

<<function nextinit>>=
/*
 * consume and return next element on
 * initlist. expand strings.
 */
Node*
nextinit(void)
{
    Node *a, *b, *n;

    a = initlist;
    n = Z;

    if(a == Z)
        return a;
    if(a->op == OLIST) {
        n = a->right;
        a = a->left;
    }
    if(a->op == OUSED) {
        a = a->left;
        b = new(OCONST, Z, Z);
        b->type = a->type->link;
        if(a->op == OSTRING) {
            b->vconst = convvtox(*a->cstring, TCHAR);
            a->cstring++;
        }
        if(a->op == OLSTRING) {
            b->vconst = convvtox(*a->rstring, TRUNE);
            a->rstring++;
        }
        a->type->width -= b->type->width;
        if(a->type->width <= 0)
            initlist = n;
        return b;
    }
    initlist = n;
    return a;
}
@

%codegen: AMOV and more complex ADATA with more complex
% layout than just array of bytes.

\section{Types and storage classes}

%context:
% cast:  '(' tlist abdecor ')' xuexpr
% sizeof: |   LSIZEOF '(' tlist abdecor ')'
% arguments: |   tlist abdecor
% adecl? and will see later also for adecl probably
% xdecl: zctlist, ... zctlist: ctlist ... ctlist: types

% tlist because can have a list like unsigned int, or long long

% ugly in C but types decomposed in two parts, 
% before identifier, and around identifier (after and also before).



<<enum type_kind_bis>>=
enum type_kind_bis {
    // ----------------------------------------------------------------------
    // Class storage (temporary, see CAUTO/CEXTERN/... for final storage)
    // ----------------------------------------------------------------------
    <<[[Type_kind_bis]] storage cases>>

    // ----------------------------------------------------------------------
    // Qualifiers (aka garbage) (temporary, see GCONSTNT/GVOLATILE)
    // ----------------------------------------------------------------------
    <<[[Type_kind_bis]] qualifier cases>>

    // ----------------------------------------------------------------------
    // Signs (temporary, see TUINT/TULONG/...)
    // ----------------------------------------------------------------------
    <<[[Type_kind_bis]] sign cases>>

    // ----------------------------------------------------------------------
    // Misc
    // ----------------------------------------------------------------------
    <<[[Type_kind_bis]] misc cases>>

    NALLTYPES,

    <<constant TRUNE>>
};
@
% see also qnames[] for debugging
%note: now that we splitted fron enum type_kind, does it still work with
% enum<bxxx>?
%dead:TFILE

% enum bxxx is used mainly in the grammar
% and is a 64 bits bitset of the types above.
% bitset, because need to aggregate keywords to form the final thing.
% to do 'unsigned char' -> TUCHAR
% pre: Txxx must have less than 64 cases? 1L => long => long enum
<<enum bxxx>>=
enum bxxx
{
    BCHAR		= 1L<<TCHAR,
    BUCHAR		= 1L<<TUCHAR,
    BSHORT		= 1L<<TSHORT,
    BUSHORT		= 1L<<TUSHORT,
    BINT		= 1L<<TINT,
    BUINT		= 1L<<TUINT,
    BLONG		= 1L<<TLONG,
    BULONG		= 1L<<TULONG,
    BVLONG		= 1L<<TVLONG,
    BUVLONG		= 1L<<TUVLONG,
    BFLOAT		= 1L<<TFLOAT,
    BDOUBLE		= 1L<<TDOUBLE,

    BIND		= 1L<<TIND,
    BFUNC		= 1L<<TFUNC,
    BARRAY		= 1L<<TARRAY,
    BVOID		= 1L<<TVOID,
    BSTRUCT		= 1L<<TSTRUCT,
    BUNION		= 1L<<TUNION,
    BENUM		= 1L<<TENUM,

    BDOT		= 1L<<TDOT,

    BCONSTNT	= 1L<<TCONSTNT,
    BVOLATILE	= 1L<<TVOLATILE,

    BUNSIGNED	= 1L<<TUNSIGNED,
    BSIGNED		= 1L<<TSIGNED,

    BAUTO		= 1L<<TAUTO,
    BEXTERN		= 1L<<TEXTERN,
    BSTATIC		= 1L<<TSTATIC,
    BTYPEDEF	= 1L<<TTYPEDEF,
    BREGISTER	= 1L<<TREGISTER,
    <<enum bxxx cases>>

    <<enum bxxx constants>>
};
@
% this will be used also later for type compatiblity checks,
% see the tcompat taxxx globals.

% see also enum<storage_class> and enum<type_kind>


% bitset<enum<bxxx> > actually
<<type declarations>>=
%type   <lval>  tname cname gname
@

<<[[union yacc]] other fields>>=
long    lval; //bitset<enum<bxxx> >
@
% for the bitset, but could probably abuse vval.
%less: rename?

<<types, storage classes, qualifiers rules>>=
<<tname rule>>
<<cname rule>>
<<gname rule>>
@


<<type declarations>>=
%type   <lval>   gcname   gctname
@

<<types, storage classes, qualifiers rules>>=
gctname:
    tname
|   gname
|   cname

gcname:
    gname
|   cname
@





<<[[union yacc]] other fields>>=
Type*   type;
@

<<type declarations>>=
%type   <type> tlist
@

% arguments to sizeof and cast
% tlist because can have a list like unsigned int, or long long
<<types, storage classes, qualifiers rules>>=
tlist:
    types
    {
        $$ = $1.t;
        if($1.c != CXXX)
            diag(Z, "illegal combination of class 4: %s", cnames[$1.c]);
    }
@
% do not allow to specify storage class
%less: hmmm could have done via grammar no?




% type and class
<<[[union yacc]] other fields>>=
struct
{
    Type*   t;
    // option<enum<storage_class> >, None = CXXX
    byte   c;
} tycl;
@


<<type declarations>>=
%type   <tycl>  types
@



<<type declarations>>=
%type   <lval>  gctnlist gcnlist zgnlist
@


<<types, storage classes, qualifiers rules>>=
gctnlist:
    gctname
|   gctnlist gctname { $$ = typebitor($1, $2); }
@

<<types, storage classes, qualifiers rules>>=
gcnlist:
    gcname
|   gcnlist gcname { $$ = typebitor($1, $2); }
@


<<function typebitor>>=
//@Scheck: used by cc.y
long typebitor(long a, long b)
{
    long c;

    c = a | b;
    if(a & b)
        if((a & b) == BLONG)
            c |= BVLONG;		/* long long => vlong */
        else
            warn(Z, "once is enough: %Q", a & b);
    return c;
}
@


\subsection{Basic types}
% types part1

<<types, storage classes, qualifiers rules>>=
<<types rule>>
@

<<types rule>>=
types:
   tname
    {
        $$.t = simplet($1);
        $$.c = CXXX;
    }
@
%$

<<tname rule>>=
tname:  /* type words */
    LCHAR     { $$ = BCHAR; }
|   LSHORT    { $$ = BSHORT; }
|   LINT      { $$ = BINT; }
|   LLONG     { $$ = BLONG; }
|   LFLOAT    { $$ = BFLOAT; }
|   LDOUBLE   { $$ = BDOUBLE; }
|   LVOID     { $$ = BVOID; }
@



<<[[Type_kind_bis]] sign cases>>=
TUNSIGNED,
TSIGNED,
@
% temporary, actually the type have the TINT vs TUINT

<<tname rule>>=
|   LSIGNED   { $$ = BSIGNED; }
|   LUNSIGNED { $$ = BUNSIGNED; }
@




<<types rule>>=
|   gcnlist
    {
        $$.t = simplet($1);
        $$.c = simplec($1);
        $$.t = garbt($$.t, $1);
    }
|   tname gctnlist
    {
        $$.t = simplet(typebitor($1, $2));
        $$.c = simplec($2);
        $$.t = garbt($$.t, $2);
    }
|   gcnlist tname
    {
        $$.t = simplet($2);
        $$.c = simplec($1);
        $$.t = garbt($$.t, $1);
    }
|   gcnlist tname gctnlist
    {
        $$.t = simplet(typebitor($2, $3));
        $$.c = simplec($1|$3);
        $$.t = garbt($$.t, $1|$3);
    }
@




<<enum bxxx constants>>=
/* these can be overloaded with complex types */
BCLASS		= BAUTO|BEXTERN|BSTATIC|BTYPEDEF|BTYPESTR|BREGISTER,
@

<<enum bxxx constants>>=
BGARB		= BCONSTNT|BVOLATILE,
@

<<function simplet>>=
Type*
simplet(long b)
{

    b &= ~BCLASS & ~BGARB;
    switch(b) {
    case BCHAR:
    case BCHAR|BSIGNED:
        return types[TCHAR];

    case BCHAR|BUNSIGNED:
        return types[TUCHAR];

    case BSHORT:
    case BSHORT|BINT:
    case BSHORT|BSIGNED:
    case BSHORT|BINT|BSIGNED:
        return types[TSHORT];

    case BUNSIGNED|BSHORT:
    case BUNSIGNED|BSHORT|BINT:
        return types[TUSHORT];

    case 0:
    case BINT:
    case BINT|BSIGNED:
    case BSIGNED:
        return types[TINT];

    case BUNSIGNED:
    case BUNSIGNED|BINT:
        return types[TUINT];

    case BLONG:
    case BLONG|BINT:
    case BLONG|BSIGNED:
    case BLONG|BINT|BSIGNED:
        return types[TLONG];

    case BUNSIGNED|BLONG:
    case BUNSIGNED|BLONG|BINT:
        return types[TULONG];

    case BVLONG|BLONG:
    case BVLONG|BLONG|BINT:
    case BVLONG|BLONG|BSIGNED:
    case BVLONG|BLONG|BINT|BSIGNED:
        return types[TVLONG];

    case BVLONG|BLONG|BUNSIGNED:
    case BVLONG|BLONG|BINT|BUNSIGNED:
        return types[TUVLONG];

    case BFLOAT:
        return types[TFLOAT];

    case BDOUBLE:
    case BDOUBLE|BLONG:
    case BFLOAT|BLONG:
        return types[TDOUBLE];

    case BVOID:
        return types[TVOID];
    }

    diag(Z, "illegal combination of types %Q", b);
    return types[TINT];
}
@




<<types, storage classes, qualifiers rules>>=
zgnlist:
 /* empty */       { $$ = 0; }
|   zgnlist gname  { $$ = typebitor($1, $2); }
@



\subsection{Storage classes}


<<[[Type_kind_bis]] storage cases>>=
TAUTO	= NTYPE,
TEXTERN,
TSTATIC,
TTYPEDEF, // ugly, not really a storage class
TREGISTER,
@
% temporary, the real one are the CAUTO, CEXTERN, etc

<<cname rule>>=
cname:  /* class words */
    LAUTO     { $$ = BAUTO; }
|   LSTATIC   { $$ = BSTATIC; }
|   LEXTERN   { $$ = BEXTERN; }
|   LREGISTER { $$ = BREGISTER; }
|   LINLINE   { $$ = 0; }
@


<<function simplec>>=
//@Scheck: used by cc.y
int simplec(long b)
{

    b &= BCLASS;
    switch(b) {
    case 0: 
    // skipping regsiter
    case BREGISTER:
        return CXXX;
    case BAUTO:
    case BAUTO|BREGISTER:
        return CAUTO;
    case BEXTERN:
        return CEXTERN;
    case BSTATIC:
        return CSTATIC;

    <<[[simplec()]] cases>>
    }
    diag(Z, "illegal combination of classes %Q", b);
    return CXXX;
}
@
% ugly that typedef if considered a storage class ...



<<[[xdecl()]] switch class cases>>=
case CXXX:
    class = CGLOBL;
    if(s->class == CEXTERN)
        s->class = CGLOBL;
    break;
@
%todo: semantic rules of C are fuzzy for me too.
% what happened if do extern int x; and then int x;
% or the reverse?

<<[[xdecl()]] switch class cases>>=
case CEXTERN:
    if(s->class == CGLOBL)
        class = CGLOBL;
    break;
@

<<[[xdecl()]] switch class cases>>=
case CAUTO:
    diag(Z, "overspecified class: %s %s %s", s->name, cnames[class], cnames[s->class]);
    class = CEXTERN;
    break;
@



<<[[xdecl()]] sanity checks>>=
if(s->class == CSTATIC)
    if(class == CEXTERN || class == CGLOBL) {
        warn(Z, "overspecified class: %s %s %s", s->name, cnames[class], cnames[s->class]);
        class = CSTATIC;
    }

if(s->type != T)
    if(s->class != class || !sametype(t, s->type) || t->etype == TENUM) {
        diag(Z, "external redeclaration of: %s", s->name);
        Bprint(&diagbuf, "	%s %T %L\n", cnames[class], t, nearln);
        Bprint(&diagbuf, "	%s %T %L\n", cnames[s->class], s->type, s->varlineno);
    }
@



\subsection{Qualifiers}

<<[[Type_kind_bis]] qualifier cases>>=
TCONSTNT,
TVOLATILE,
@
% temporary, the real one are the GCONSTNT, GVOLATILE, etc

% garbage?
<<gname rule>>=
gname:  /* garbage words */
    LCONSTNT  { $$ = BCONSTNT; }
|   LVOLATILE { $$ = BVOLATILE; }
|   LRESTRICT { $$ = 0; }
@
% restrict keyword not handled

<<function garbt>>=
//@Scheck: used by cc.y
Type* garbt(Type *t, long b)
{
    Type *t1;

    if(b & BGARB) {
        t1 = copytyp(t);
        t1->garb = simpleg(b);
        return t1;
    }
    return t;
}
@

<<function simpleg>>=
int
simpleg(long b)
{

    b &= BGARB;
    switch(b) {
    case BCONSTNT:           return GCONSTNT;
    case BVOLATILE:          return GVOLATILE;
    case BVOLATILE|BCONSTNT: return GCONSTNT|GVOLATILE;
    }
    return GXXX;
}
@


\subsection{Structures and unions}

<<definition nodes>>=
OSTRUCT, // used for defs, decls, and for struct constructors
OUNION,
@



\subsubsection{Complex types}
% also for enum

<<types rule>>=
|  complex
    {
        $$.t = $1;
        $$.c = CXXX;
    }
|  complex gctnlist
    {
        $$.t = $1;
        $$.c = simplec($2);
        $$.t = garbt($$.t, $2);
        if($2 & ~BCLASS & ~BGARB)
            diag(Z, "duplicate types given: %T and %Q", $1, $2);
    }
|   gcnlist complex zgnlist
    {
        $$.t = $2;
        $$.c = simplec($1);
        $$.t = garbt($$.t, $1|$3);
    }
@
%$

<<types, storage classes, qualifiers rules>>=
<<complex rule>>
@

<<type declarations>>=
%type   <type>  complex
@


\subsubsection{Structure/union uses}


%use
<<complex rule>>=
complex:
    LSTRUCT ltag
    {
        dotag($2, TSTRUCT, 0);
        $$ = $2->suetag;
    }
|   LUNION ltag
    {
        dotag($2, TUNION, 0);
        $$ = $2->suetag;
    }
@
%$
% 0? for block number?

%how represent the type of foo given this decl 'struct x { int x; } foo;'?
% TSTRUCT(link = ?, tag = sym x)
% where x = Sym(suetag = ?) mutual ref?
%        

% when the name refers to a tag, lookup its final def
% sue = structure union enum
<<[[Sym]] tag value fields>>=
Type*	suetag;
@
% rename sue_tag_type?
% restored in revertdcl()


<<[[Type]] other fields>>=
Sym*	tag;
@
% mutual ref, s->suetag->tag = s;
% useful, yes to recover the name of the struct which is not
% stored in the Type otherwise. 
%todo: vs sym?? have a Type.sym and a Type.tag??
% but can't use Type.sym for that?

% depth of struct
<<[[Sym]] tag value fields>>=
ushort	sueblock;
@

% LP split bn != 0
% called also for enums
<<function dotag>>=
//@Scheck: used by cc.y
Type* dotag(Sym *s, int et, int bn)
{
    <<[[dotag()]] if bn not null and bn not sueblock>>
    if(s->suetag == T) {
        s->suetag = typ(et, T); // link is null for now
        s->sueblock = autobn;
    }
    <<[[dotag()]] sanity check tag redeclaration>>
    if(s->suetag->tag == S)
        s->suetag->tag = s;

    return s->suetag;
}
@

<<[[dotag()]] sanity check tag redeclaration>>=
if(s->suetag->etype != et)
    diag(Z, "tag used for more than one type: %s",
        s->name);
@


\subsubsection{Structure/union definitions}

% defs
<<complex rule>>=
|   LSTRUCT ltag
    {
        dotag($2, TSTRUCT, autobn);
    }
    sbody
    {
        $$ = $2->suetag;
        if($$->link != T)
            diag(Z, "redeclare tag: %s", $2->name);
        $$->link = $4;
        sualign($$);
    }
|   LUNION ltag
    {
        dotag($2, TUNION, autobn);
    }
    sbody
    {
        $$ = $2->suetag;
        if($$->link != T)
            diag(Z, "redeclare tag: %s", $2->name);
        $$->link = $4;
        sualign($$);
    }
@
%$
% could factorize in a su: TSTRUCT { $$ = TSTRUCT } TUNION ...


% sualign() explained later in code gen chapter, alignment section


% bn is autobn for actual struct defs.
<<[[dotag()]] if bn not null and bn not sueblock>>=
Decl *d;

if(bn != 0 && bn != s->sueblock) {
    d = push();
    d->sym = s;
    d->val = DSUE;
    d->type = s->suetag;
    d->block = s->sueblock;
    s->suetag = T;
}
@


<<global taggen>>=
//@Scheck: used by cc.y
int	taggen;
@
% gensym() like

% anon defs
<<complex rule>>=
|   LSTRUCT sbody
    {
        taggen++;
        sprint(symb, "_%d_", taggen);
        $$ = dotag(lookup(), TSTRUCT, autobn);
        $$->link = $2;
        sualign($$);
    }
|   LUNION sbody
    {
        taggen++;
        sprint(symb, "_%d_", taggen);
        $$ = dotag(lookup(), TUNION, autobn);
        $$->link = $2;
        sualign($$);
    }
@




\subsubsection{Fields}

<<type declarations>>=
%type   <type> sbody
@
%todo: sure? seems more tyty than type

<<[[union yacc]] other fields>>=
struct
{
    Type*   t1;
    Type*   t2;
    Type*   t3;
    uchar   c;
} tyty;
@

<<global strf>>=
Type*	strf;
@

<<global strl>>=
Type*	strl;
@

<<global firstbit>>=
long	firstbit;
@

<<global lastbit>>=
long	lastbit;
@

<<types, storage classes, qualifiers rules>>=
sbody:
    '{'
    {
        $<tyty>$.t1 = strf;
        $<tyty>$.t2 = strl;
        $<tyty>$.t3 = lasttype;
        $<tyty>$.c = lastclass;
        strf = T;
        strl = T;
        lastbit = 0;
        firstbit = 1;
        lastclass = CXXX;
        lasttype = T;
    }
    edecl 
    '}'
    {
        $$ = strf;
        strf = $<tyty>2.t1;
        strl = $<tyty>2.t2;
        lasttype = $<tyty>2.t3;
        lastclass = $<tyty>2.c;
    }

@
%$
% ????



<<structure element declarator rules>>=
/*
 * structure element declarator
 */
edecl:
    tlist
    {
        lasttype = $1;
    }
    zedlist ';'
|   edecl tlist
    {
        lasttype = $2;
    }
    zedlist ';'

zedlist:                    /* extension */
 /* empty */
    {
        lastfield = 0;
        edecl(CXXX, lasttype, S);
    }
|   edlist

edlist:
    edecor            { dodecl(edecl, CXXX, lasttype, $1); }
|   edlist ',' edlist
@
%$

<<structure element declarator rules>>=
<<edecor rule>>
@


<<edecor rule>>=
edecor:
    xdecor
    {
        lastbit = 0;
        firstbit = 1;
    }
@


<<global lastfield>>=
long	lastfield;
@
% set in dodecl() and ?


<<[[Type]] code generation fields>>=
schar	shift;
char	nbits;
@
% only for fields?

% dodecl(<>) -> <>
<<function edecl>>=
//@Scheck: used by cc.y
void edecl(int c, Type *t, Sym *s)
{
    Type *t1;

    if(s == S) {
        if(!typesu[t->etype])
            diag(Z, "unnamed structure element must be struct/union");
        if(c != CXXX)
            diag(Z, "unnamed structure element cannot have class");
    } else
        if(c != CXXX)
            diag(Z, "structure element cannot have class: %s", s->name);
    t1 = t;
    t = copytyp(t1);
    t->sym = s;
    t->down = T;
    if(lastfield) {
        t->shift = lastbit - lastfield;
        t->nbits = lastfield;
        if(firstbit)
            t->shift = -t->shift;
        if(typeu[t->etype])
            t->etype = tufield->etype;
        else
            t->etype = tfield->etype;
    }
    if(strf == T)
        strf = t;
    else
        strl->down = t;
    strl = t;
}
@

<<global tfield>>=
Type*	tfield;
@
% and init code in cinit or tinit

<<global tufield>>=
Type*	tufield;
@
% ??? unsigned field?

<<[[ginit()]] initialisation>>=
tfield = types[TLONG];
@
% in ginit which is in 5c/txt.c because arm specific

<<[[main()]] remaining initialisation>>=
tufield = simplet((1L<<tfield->etype) | BUNSIGNED);
@
% back in generic code

\subsection{Enums}

%<<definition nodes>>=
%OENUM,
%@

<<struct En>>=
struct En
{
    Type*	tenum;		/* type of entire enum */
    Type*	cenum;		/* type of current enum run */

    vlong	lastenum;	/* value of current enum */
    double	floatenum;	/* value of current enum */ // for floats enums
};
@
% vlong! so can have 64 bitsets
%less: rename En, Enuminfo

<<global en>>=
struct En en;
@


% same dotag than for struct/union, cos same namespace
<<complex rule>>=
|   LENUM ltag
    {
        dotag($2, TENUM, 0);
        $$ = $2->suetag;
        if($$->link == T)
            $$->link = types[TINT];
        $$ = $$->link;
    }
|   LENUM ltag
    {
        dotag($2, TENUM, autobn);
    }
    '{'
    {
        en.tenum = T;
        en.cenum = T;
    }
    enum 
     '}'
    {
        $$ = $2->suetag;
        if($$->link != T)
            diag(Z, "redeclare tag: %s", $2->name);
        if(en.tenum == T) {
            diag(Z, "enum type ambiguous: %s", $2->name);
            en.tenum = types[TINT];
        }
        $$->link = en.tenum;
        $$ = en.tenum;
    }
|   LENUM '{'
    {
        en.tenum = T;
        en.cenum = T;
    }
    enum '}'
    {
        $$ = en.tenum;
    }
@

<<types, storage classes, qualifiers rules>>=
enum:
    LNAME           { doenum($1, Z); }
|   LNAME '=' expr  { doenum($1, $3); }
|   enum ',' enum
|   enum ','
@
%$
% optional trailing ,


<<[[Sym]] enum value fields>>=
vlong	vconst;
double	fconst;
@
% computed value for the enum, different from vconst/fconst in Node.

% ref to type of enum for each constants symbols of the enum?
<<[[Sym]] enum value fields>>=
// ref<Type>
Type*	tenum;
@




% n = optional expression for the value of the enum constant
<<function doenum>>=
//@Scheck: used by cc.y
void doenum(Sym *s, Node *n)
{

    if(n) {
        complex(n); // will call evconst()
        if(n->op != OCONST) {
            diag(n, "enum not a constant: %s", s->name);
            return;
        }

        en.cenum = n->type;
        en.tenum = maxtype(en.cenum, en.tenum);

        if(typefd[en.cenum->etype])
            en.floatenum = n->fconst;
        else
            en.lastenum = n->vconst;
    }
    if(dclstack)
        push1(s);

    xdecl(CXXX, types[TENUM], s);

    if(en.cenum == T) {
        en.tenum = types[TINT];
        en.cenum = types[TINT];
        en.lastenum = 0;
    }
    s->tenum = en.cenum;

    if(typefd[s->tenum->etype]) {
        s->fconst = en.floatenum;
        en.floatenum++;
    } else {
        s->vconst = convvtox(en.lastenum, s->tenum->etype);
        en.lastenum++;
    }

    if(debug['d'])
        dbgdecl(s);
    acidvar(s);
}
@

<<function maxtype>>=
/*
 * this routine is very suspect.
 * ANSI requires the enum type to
 * be represented as an 'int'
 * this means that 0x81234567
 * would be illegal. this routine
 * makes signed and unsigned go
 * to unsigned.
 */
Type*
maxtype(Type *t1, Type *t2)
{

    if(t1 == T)
        return t2;
    if(t2 == T)
        return t1;
    if(t1->etype > t2->etype)
        return t1;
    return t2;
}
@


\subsection{Typedefs}

% defs

<<cname rule>>=
|   LTYPEDEF  { $$ = BTYPEDEF; }
@
% the keyword

<<[[simplec()]] cases>>=
case BTYPEDEF:
    return CTYPEDEF;
@

<<[[Storage_class]] cases>>=
CTYPEDEF,
@
% but ugly, this should not be a storage class ...

% this storage class will be stored in the class of the
% declarator (where? in dodecl?) and yylex() will then generate LTYPE tokens
% if this symbol is referenced.

% uses

<<complex rule>>=
|   LTYPE { $$ = tcopy($1->type); }
@
%$
% tricky!

<<function tcopy>>=
/*
 * make a copy of a typedef
 * the problem is to split out incomplete
 * arrays so that it is in the variable
 * rather than the typedef.
 */
Type*
tcopy(Type *t)
{
    Type *tl, *tx;
    int et;

    if(t == T)
        return t;
    et = t->etype;
    if(typesu[et])
        return t;

    tl = tcopy(t->link);
    if(tl != t->link || (et == TARRAY && t->width == 0)) {
        tx = copytyp(t);
        tx->link = tl;
        return tx;
    }
    return t;
}
@



\subsection{Pointer and array types}

% types part 2a
<<xdecor rule>>=
|   '*' zgnlist xdecor
    {
        $$ = new(OIND, $3, Z);
        $$->nodegarb = simpleg($2);
    }
@
% before the identifier

<<[[Node]] parsing helper fields>>=
// enum<qualifier>
char	nodegarb;
@
% this is ugly field, used only because of the ugly way
% types are written in C


% remember t is the type part one (or the currently adjusted type)
<<[[dodecl()]] switch node kind cases>>=
case OIND:
    t = typ(TIND, t);
    t->garb = n->nodegarb;
    n = n->left;
    goto loop;
@
% n = n->left? to access the name?

% types part 2b
<<xdecor2 rule>>=
|   xdecor2 '[' zexpr ']'      { $$ = new(OARRAY, $1, $3); }
@
%$
% after the identifier

% see also the abstract declarator rules which are similar


<<[[dodecl()]] locals>>=
Node *n1;
@

<<[[dodecl()]] switch node kind cases>>=
case OARRAY:
    t = typ(TARRAY, t);
    n1 = n->right; // possible size
    n = n->left;
    t->width = 0; // array[], size could be set by doinit (or specified in n1)
    <<[[dodecl()]] switch node kind cases, case OARRAY, if array has a size>>
    goto loop;
@

<<[[dodecl()]] locals>>=
long v;
@

<<[[dodecl()]] switch node kind cases, case OARRAY, if array has a size>>=
if(n1 != Z) {
    complex(n1); // will call evconst()
    v = (n1->op == OCONST) ? n1->vconst : -1;
    if(v <= 0) {
        diag(n, "array size must be a positive constant");
        v = 1;
    }
    t->width = v * t->link->width;
}
@

\subsection{Function types, parameter types}

% OFUNC used also for function calls and introduced before.

<<xdecor2 rule>>=
|   xdecor2 '(' zarglist ')'   { $$ = new(OFUNC, $1, $3); }
@
%$
% after the identifier agin

% called arg ... hmmm ... should be renamed zparamlist
% xdecor -> ... -> <> ?
<<parameter declarator rules>>=
zarglist:
  /* empty */   { $$ = Z; }
|   arglist     { $$ = invert($1); }
@
%$



<<[[dodecl()]] switch node kind cases>>=
case OFUNC:
    t = typ(TFUNC, t);
    t->down = fnproto(n);
    n = n->left;
    goto loop;
@
%less: why not fnproto(n->right) instead?
% if remove old prototype style handling, maybe I can do that



<<function fnproto>>=
Type*
fnproto(Node *n)
{
    <<[[fnproto()]] old prototype style handling>>
    return fnproto1(n->right);
}
@

<<function fnproto1>>=
Type*
fnproto1(Node *n)
{
    Type *t;

    if(n == Z)
        return T;

    switch(n->op) {
    <<[[fnproto1()]] switch node kind cases>>
    }
    diag(n, "unknown op in fnproto");
    return T;
}
@
% NODECL =~ (complex function type cast) nil








<<parameter declarator rules>>=
<<arglist rule>>
@

<<arglist rule>>=
arglist:
    name
@
%less: ONAME, but should not be allowed!
% except when the name is actually a typedef??

<<[[fnproto1()]] switch node kind cases>>=
case ONAME:
    diag(n, "incomplete argument prototype");
    return typ(TINT, T);
@



<<variable declaration nodes>>=
OPROTO,
@
% ?? rename OPARAM?

<<arglist rule>>=
|   tlist xdecor
    {
        $$ = new(OPROTO, $2, Z);
        $$->type = $1;
    }
|   tlist abdecor
    {
        $$ = new(OPROTO, $2, Z);
        $$->type = $1;
    }
@
% abstract declarator or regular declarator


<<[[fnproto1()]] switch node kind cases>>=
case OPROTO:
    lastdcltype = T;
    dodecl(NODECL, CXXX, n->type, n->left);
    t = typ(TXXX, T);
    if(lastdcltype != T)
        *t = *paramconv(lastdcltype, true);
    return t;
@

% fnproto1 | pdecl -> <>
% f is for parameter context (class==CPARAM)
% this transform array and function type in something simpler
<<function paramconv>>=
Type*
paramconv(Type *t, bool f)
{

    switch(t->etype) {
    case TARRAY:
        t = typ(TIND, t->link);
        t->width = types[TIND]->width;
        break;
    case TFUNC:
        t = typ(TIND, t);
        t->width = types[TIND]->width;
        break;
    <<[[paramconv()]] switch etype, adjust type when not f cases>>
    }
    return t;
}
@
% A function parameter is really a function pointer.
% An array is really a pointer when passed as a parameter
% as the size of the array information is lost.

%todo: can do int foo(int x[45]) { }? 
%todo: can do int foo(int bar(int x)) { }? 







<<arglist rule>>=
|   arglist ',' arglist  { $$ = new(OLIST, $1, $3); }
@
%$

<<[[fnproto1()]] switch node kind cases>>=
case OLIST:
    t = fnproto1(n->left);
    if(t != T)
        t->down = fnproto1(n->right);
    return t;
@




<<variable declaration nodes>>=
ODOTDOT,
@

<<arglist rule>>=
|   '.' '.' '.'          { $$ = new(ODOTDOT, Z, Z); }
@

<<[[fnproto1()]] switch node kind cases>>=
case ODOTDOT:
    return typ(TDOT, T);
@

<<type cases>>=
TDOT, // ... in function types
@




\section{Declarations and definitions, part two}

\subsection{Globals, external declarator}

% have seen already before xdecl, xdlist, xdecor, xdecor2

\subsection{Function parameters}

<<global firstarg>>=
Sym*	firstarg;
@

<<global firstargtype>>=
Type*	firstargtype;
@

% ?
<<global autoffset>>=
long	autoffset;
@

% ?
<<global stkoff>>=
long	stkoff;
@
% stack offset, used for ATEXT generation in codgen()
% to compute the set of locals we need


% pass is 0 for ANSI proto or 1 for old style proto
<<function argmark>>=
//@Scheck: not dead, used by cc.y
void argmark(Node *n, int pass)
{
    Type *t;

    autoffset = align(0, thisfntype->link, Aarg0);
    stkoff = 0;
    for(; n->left != Z; n = n->left) {
        if(n->op != OFUNC || n->left->op != ONAME)
            continue;
        walkparam(n->right, pass);
        <<[[argmark()]] if old proto style>>
        break;
    }
    autoffset = 0;
    stkoff = 0;
}
@




<<[[Sym]] identifier value, code generation fields>>=
long	offset;
@
%todo: hmm seems used for CEXREG, flow fron exreg -> o -> xdecl -> offset field.

<<[[Node]] code generation fields>>=
long	xoffset;
@
% this is for ONAME after some resolving for params and locals
% and for OREGISTER and OINDREG (in addition to reg)


<<function walkparam>>=
void
walkparam(Node *n, int pass)
{
    Sym *s;
    Node *n1;

    if(n != Z && n->op == OPROTO && n->left == Z && n->type == types[TVOID])
        return;

loop:
    if(n == Z)
        return;
    switch(n->op) {
    case OLIST:
        walkparam(n->left, pass);
        n = n->right;
        goto loop;

    case OPROTO:
        for(n1 = n; n1 != Z; n1=n1->left)
            if(n1->op == ONAME) {
                if(pass == 0) {
                    s = n1->sym;
                    push1(s);
                    s->offset = -1;
                    break;
                }
                dodecl(pdecl, CPARAM, n->type, n->left);
                break;
            }
        if(n1)
            break;
        if(pass == 0) {
            /*
             * extension:
             *	allow no name in argument declaration
            diag(Z, "no name in argument declaration");
             */
            break;
        }
        dodecl(NODECL, CPARAM, n->type, n->left);
        pdecl(CPARAM, lastdcltype, S);
        break;

    case ONAME:
        s = n->sym;
        if(pass == 0) {
            push1(s);
            s->offset = -1;
            break;
        }
        if(s->offset != -1) {
            if(autoffset == 0) {
                firstarg = s;
                firstargtype = s->type;
            }
            autoffset = align(autoffset, s->type, Aarg1);
            s->offset = autoffset;
            autoffset = align(autoffset, s->type, Aarg2);
        } else
            dodecl(pdecl, CXXX, types[TINT], n);
        break;

    case ODOTDOT:
        break;
    
    default:
        diag(n, "argument not a name/prototype: %O", n->op);
        break;

    }
}
@




% dodecl(<>,...) -> <> 
<<function pdecl>>=
void
pdecl(int class, Type *t, Sym *s)
{
    if(s && s->offset != -1) {
        diag(Z, "not a parameter: %s", s->name);
        return;
    }
    t = paramconv(t, class==CPARAM);
    if(class == CXXX)
        class = CPARAM;
    if(class != CPARAM) {
        diag(Z, "parameter cannot have class: %s", s->name);
        class = CPARAM;
    }
    if(typesu[t->etype] && t->width <= 0)
        diag(Z, "incomplete structure: %s", t->tag->name);
    adecl(class, t, s);
}
@
% a parameter is a kind of local, hence the call to adecl


<<[[paramconv()]] switch etype, adjust type when not f cases>>=
case TFLOAT:
    if(!f)
        t = types[TDOUBLE];
    break;

case TCHAR:
case TSHORT:
    if(!f)
        t = types[TINT];
    break;

case TUCHAR:
case TUSHORT:
    if(!f)
        t = types[TUINT];
    break;
@




\subsection{Locals, automatic declarator}

% slist -> <>
<<automatic declarator rules>>=
/*
 * automatic declarator
 */
adecl:
    ctlist ';'        { $$ = dodecl(adecl, lastclass, lasttype, Z); }
|   ctlist adlist ';' { $$ = $2; }
@
%$

<<automatic declarator rules>>=
adlist:
    xdecor
    {
        dodecl(adecl, lastclass, lasttype, $1);
        $$ = Z;
    }
|   xdecor
    {
        $1 = dodecl(adecl, lastclass, lasttype, $1);
    }
    '=' init
    {
        long w;

        w = $1->sym->type->width;
        $$ = doinit($1->sym, $1->type, 0L, $4);
        $$ = contig($1->sym, $$, w);
    }
|   adlist ',' adlist
    {
        $$ = $1;
        if($3 != Z) {
            $$ = $3;
            if($1 != Z)
                $$ = new(OLIST, $1, $3);
        }
    }
@
%$



% pdecl | dodecl(<>) -> <>
<<function adecl>>=
void
adecl(int c, Type *t, Sym *s)
{

    <<[[adecl()]] adjust storage to CLOCAL if static local variable>>
    if(t->etype == TFUNC) {
        if(c == CXXX)
            c = CEXTERN;
        if(c == CLOCAL)
            c = CSTATIC;
        if(c == CAUTO || c == CEXREG)
            diag(Z, "function cannot be %s %s", cnames[c], s->name);
    }
    if(c == CXXX)
        c = CAUTO;
    if(s) {
        if(s->class == CSTATIC)
            if(c == CEXTERN || c == CGLOBL) {
                warn(Z, "just say static: %s", s->name);
                c = CSTATIC;
            }
        if(s->class == CAUTO || s->class == CPARAM || s->class == CLOCAL)
        if(s->block == autobn)
            diag(Z, "auto redeclaration of: %s", s->name);
        if(c != CPARAM)
            push1(s);
        s->block = autobn;
        s->offset = 0;
        s->type = t;
        s->class = c;
        s->aused = false;
    }

    switch(c) {
    case CAUTO:
        autoffset = align(autoffset, t, Aaut3);
        stkoff = maxround(stkoff, autoffset);
        s->offset = -autoffset;
        break;

    case CPARAM:
        if(autoffset == 0) {
            firstarg = s;
            firstargtype = t;
        }
        autoffset = align(autoffset, t, Aarg1);
        if(s)
            s->offset = autoffset;
        autoffset = align(autoffset, t, Aarg2);
        break;
    }
}
@


%TODO: LP split
<<function contig>>=
//@Scheck: used by cc.y
Node* contig(Sym *s, Node *n, long v)
{
    Node *p, *r, *q, *m;
    long w;
    Type *zt;

    if(debug['i']) {
        print("contig v = %ld; s = %s\n", v, s->name);
        prtree(n, "doinit value");
    }

    if(n == Z)
        goto no;
    w = s->type->width;

    /*
     * nightmare: an automatic array whose size
     * increases when it is initialized
     */
    if(v != w) {
        if(v != 0)
            diag(n, "automatic adjustable array: %s", s->name);
        v = s->offset;
        autoffset = align(autoffset, s->type, Aaut3);
        s->offset = -autoffset;
        stkoff = maxround(stkoff, autoffset);
        symadjust(s, n, v - s->offset);
    }
    if(w <= ewidth[TIND])
        goto no;
    if(n->op == OAS)
        diag(Z, "oops in contig");
/*ZZZ this appears incorrect
need to check if the list completely covers the data.
if not, bail
 */
    if(n->op == OLIST)
        goto no;
    if(n->op == OASI)
        if(n->left->type)
        if(n->left->type->width == w)
            goto no;
    while(w & (ewidth[TIND]-1))
        w++;
/*
 * insert the following code, where long becomes vlong if pointers are fat
 *
    *(long**)&X = (long*)((char*)X + sizeof(X));
    do {
        *(long**)&X -= 1;
        **(long**)&X = 0;
    } while(*(long**)&X);
 */

    for(q=n; q->op != ONAME; q=q->left)
        ;

    zt = ewidth[TIND] > ewidth[TLONG]? types[TVLONG]: types[TLONG];

    p = new(ONAME, Z, Z);
    *p = *q;
    p->type = typ(TIND, zt);
    p->xoffset = s->offset;

    r = new(ONAME, Z, Z);
    *r = *p;
    r = new(OPOSTDEC, r, Z);

    q = new(ONAME, Z, Z);
    *q = *p;
    q = new(OIND, q, Z);

    m = new(OCONST, Z, Z);
    m->vconst = 0;
    m->type = zt;

    q = new(OAS, q, m);

    r = new(OLIST, r, q);

    q = new(ONAME, Z, Z);
    *q = *p;
    r = new(ODWHILE, q, r);

    q = new(ONAME, Z, Z);
    *q = *p;
    q->type = q->type->link;
    q->xoffset += w;
    q = new(OADDR, q, 0);

    q = new(OASI, p, q);
    r = new(OLIST, q, r);

    n = new(OLIST, r, n);

no:
    return n;
}
@


<<function symadjust>>=
void
symadjust(Sym *s, Node *n, long del)
{

    switch(n->op) {
    case ONAME:
        if(n->sym == s)
            n->xoffset -= del;
        return;

    case OCONST:
    case OSTRING: case OLSTRING:
    case OREGISTER: case OINDREG:
        return;

    default:
        if(n->left)
            symadjust(s, n->left, del);
        if(n->right)
            symadjust(s, n->right, del);
        return;

    }
}
@


\subsection{Types, abstract declarator}

% for cast, sizeof, declaration of parameters in a prototype
<<abstract declarator rules>>=
/*
 * abstract declarator
 */
abdecor:
  /* empty */ { $$ = Z; }
|   abdecor1
@

<<abstract declarator rules>>=
abdecor1:
    '*' zgnlist
    {
        $$ = new(OIND, (Z), Z);
        $$->nodegarb = simpleg($2);
    }
|   '*' zgnlist abdecor1
    {
        $$ = new(OIND, $3, Z);
        $$->nodegarb = simpleg($2);
    }
|   abdecor2
@
%$
%OIND of Z here! no ONAME

<<abstract declarator rules>>=
abdecor2:
    abdecor3
|   abdecor2 '(' zarglist ')'   { $$ = new(OFUNC, $1, $3); }
|   abdecor2 '[' zexpr ']'      { $$ = new(OARRAY, $1, $3); }

abdecor3:
    '(' ')'           { $$ = new(OFUNC, Z, Z); }
|   '[' zexpr ']'     { $$ = new(OARRAY, Z, $2); }
|   '(' abdecor1 ')'  { $$ = $2; }
@
%$

% ugly syntax ...





\chapter{Assembly Generation}
% Code Generation?

\section{Overview}

% 5c/8c/... don't have an intermediate language :( not even an RTL :(
% They generate directly arch-specific assembly.
% But they have kinda factorized a few things behind some
% common interface: gpseudo(), gins(), gmove(), gbranch(), as well
% as some REGRET, REGARG
% so at least some of the statement code generator is portable.
% (but probably lcc backend part is cleaner)

% gbranch(), gmove(), are archi independent interface.
%  cc2/pgen.c include gc.h where all archi define some kinda archi independent
%  stuff like ATEXT, ANOP, etc
% gins() seems more archi dependent but can also do arch independent
%  when the opcode is quite general (e.g. ANOP)

% target language = Prog, Adr, as, etc, like in Linker and assembler.
% outcode(), like in Assembler.

% remember in cc.y for function definition case:
%        if(!debug['a'] && !debug['Z'])
%            codgen($6, $2); // !!!!!!!!!!!!!!!!!!!!!

% main -> compile -> yyparse -> codgen (func) -> gen (statement) -> cgen (expr)

% will visit the AST and generate recursively the code mostly.

% helps to understand Assembler.nw for ARM

\section{[[nextpc()]], [[p]] and [[pc]]}

% as we visit we will create new ASM instructions, linked
% together that will be then serialized and written to a file
% (see outcode). So nextpc() is here to create those new instruction
% and increment the pc global counter.

<<global pc>>=
long	pc;
@

<<[[ginit()]] initialisation>>=
pc = 0;
@
% seems archi independent ... could be in a gginit()? generic globals init.

% gins | gclean | ... -> <>
<<function nextpc>>=
void
nextpc(void)
{

    p = alloc(sizeof(Prog));
    *p = zprog;
    p->lineno = nearln;
    pc++;

    // add_end_list(p, firstp/lastp)
    if(firstp == P) {
        firstp = p;
        lastp = p;
        return;
    }
    lastp->link = p;
    lastp = p;
}
@
% pc useful for what? for jumps, see patch(),
% and spc. Note that after nextpc() the value of pc is to
% jmp just after this newly generated instruction!
%less: could do p->pc = pc; no?
%note: the use of nearln!!! so can trace back the source code that generated
%  this ASM instructions, very useful for the debugger.

% current? see nextpc()?
<<global p>>=
Prog*	p;
@
% often have a 'sp' for save p, and do things like
% gxxx(); sp = p;   to remember what was the instruction generated
% by this gxxx()






% like in Linker.nw
<<global firstp>>=
// list<ref_own<Prog>, next = Prog.link
Prog*	firstp;
@

<<[[Prog]] extra fields(arm)>>=
// list<ref<Prog>> from firstp
Prog*	link;
@

<<constant P>>=
#define	P	((Prog*)nil)
@

<<global lastp>>=
// ref<Prog>, last elt of firstp list
Prog*	lastp;
@

% firstp/lastp are used only by outcode()

<<[[ginit()]] initialisation>>=
firstp = P;
lastp = P;
@



<<[[gclean()]] generate last opcode, AEND>>=
nextpc();
p->as = AEND;
@


\section{[[gxxx()]]}

\subsection{[[gpseudo()]]}

% codgen(function generation) | gextern -> <>
<<function gpseudo(arm)>>=
void
gpseudo(int a, Sym *s, Node *n)
{

    nextpc();
    p->as = a;
    p->from.type = D_OREG;
    p->from.sym = s;
    p->from.symkind = (s->class == CSTATIC) ? D_STATIC : D_EXTERN;
    <<[[gpseudo()]] if TEXT, set possible TEXT attributes>>
    naddr(n, &p->to);
    if(a == ADATA || a == AGLOBL)
        pc--;
}
@
% pc--, like in Assembler?


\subsection{[[gextern()]]}

<<function gextern(arm)>>=
void
gextern(Sym *s, Node *a, long o, long w)
{
    <<[[gextern()]] if OCONST and a vlong type>>
    else {
        gpseudo(ADATA, s, a);
        p->from.offset += o;
        p->reg = w; // attributes
        if(p->to.type == D_OREG)
            p->to.type = D_CONST;
    }
}
@
%less: += o? why not just = o?


\subsection{[[gbranch()]]}

<<function gbranch(arm)>>=
void
gbranch(int o)
{
    int a;

    nextpc();

    switch(o) {
    case ORETURN: a = ARET; break;
    case OGOTO:   a = AB;   break;
    default:
        a = AGOK;
        diag(Z, "bad in gbranch %O",  o);
        nextpc();
    }
    p->as = a;
}
@
%the p->to will be set later by patch(), see below.
%less: 386 is just AB -> JMP, should factorize!!
%what generates ABL then? gen() with case on OFUNC probably.

% gmove | gen | ... -> <>
<<function patch>>=
void
patch(Prog *op, long pc)
{

    op->to.type = D_BRANCH;
    op->to.offset = pc;
}
@
% usually do  gbranch(xxx); sp = p; ...; patch(sp, pc);

\subsection{[[gins()]] and [[naddr()]]}

% gmove | ... -> <>
% pre: the from and to nodes should be very basic,
% constants, or names, or simple indirection of names or constants
% see naddr() and the goto bad.
% It must generates something that the assembler can grok, so can't
% have two indirection arguments for example. One of them
% has to be simpler.
<<function gins(arm)>>=
void
gins(int a, Node *f, Node *t)
{

    nextpc();
    p->as = a;

    if(f != Z)
        naddr(f, &p->from);
    if(t != Z)
        naddr(t, &p->to);

    if(debug['g'])
        print("%P\n", p);
}
@

% IN n, OUT a
<<function naddr(arm)>>=
void
naddr(Node *n, Adr *a)
{
    long v;

    a->type = D_NONE;
    if(n == Z)
        return;

    switch(n->op) {
    <<[[naddr()]] switch node kind cases>>
    default:
    bad:
        diag(n, "bad in naddr: %O", n->op);
        break;

    }
}
@


<<[[naddr()]] switch node kind cases>>=
case OCONST:
    a->sym = S;
    a->reg = R_NONE;
    if(typefd[n->type->etype]) {
        a->type = D_FCONST;
        a->dval = n->fconst;
    } else {
        a->type = D_CONST;
        a->offset = n->vconst;
    }
    break;
@

<<[[Adr]] type fields(arm)>>=
// enum<type_kind>
char	etype;
@
% copy of node->type->etype.
% seems used only so that can generate back a Var from an Adr.

<<[[naddr()]] switch node kind cases>>=
case ONAME:
    a->etype = n->etype;
    a->type = D_OREG;
    a->offset = n->xoffset;
    a->sym = n->sym;

    a->symkind = D_STATIC;
    switch(n->class) {
    case CSTATIC: 
        a->symkind = D_STATIC;
        break;
    case CEXTERN: case CGLOBL:
        a->symkind = D_EXTERN;
        break;
    case CAUTO:
        a->symkind = D_AUTO;
        break;
    case CPARAM:
        a->symkind = D_PARAM;
        break;
    default:
        goto bad;
    }
    break;
@
% a NAME reference is always an OREG because dereference (SB)
% to access the data section part.
%old: was a serie of switch, but cleaner to use a switch

<<[[naddr()]] switch node kind cases>>=
case OIND:
    naddr(n->left, a);
    if(a->type == D_REG || a->type == D_CONST) {
        a->type = D_OREG;
        break;
    }
    goto bad;
@

% if &x, then x is a name reference, in which case the operation
% is a D_OREG xxx(SB).
<<[[naddr()]] switch node kind cases>>=
case OADDR:
    naddr(n->left, a);
    if(a->type == D_OREG) {
        a->type = D_CONST;
        break;
    }
    goto bad;
@
% C &x -> ASM $x



% less important? for array? or pointer arithmetic?
<<[[naddr()]] switch node kind cases>>=
case OADD:
    if(n->left->op == OCONST) {
        naddr(n->left, a);
        v = a->offset;
        naddr(n->right, a);
    } else {
        naddr(n->right, a);
        v = a->offset;
        naddr(n->left, a);
    }
    a->offset += v;
    break;
@
% ????

\subsection{[[gmove()]]}


% from, to
% ?? -> <>
% pre: I think from and to must be nodes with simple types only (or TIND),
%  and nodes which are either register, name, or indirect.
<<function gmove(arm)>>=
void
gmove(Node *f, Node *t)
{
    // enum<type_kind> // Txxx
    int ft, tt;
    // enum<opcode_kind> // Axxx
    int a;
    <<[[gmove()]] locals>>

    ft = f->type->etype;
    tt = t->type->etype;

    /*
     * a load --
     * put it into a register then
     * worry what to do with it.
     */
    <<[[gmove()]] if from is not a register, registerize and return>>
    /*
     * a store --
     * put it into a register then
     * store it.
     */
    <<[[gmove()]] if to is not a register, registerize and return>>

    // at this point f and t should be simpler nodes with registers

    /*
     * type x type cross table
     */
    a = AGOK;
    switch(ft) {
    <<[[gmove()]] switch from type cases>>
    }
    if(a == AGOK)
        diag(Z, "bad opcode in gmove %T -> %T", f->type, t->type);
    if(a == AMOVW || a == AMOVF || a == AMOVD)
     if(samaddr(f, t))
        return;

    gins(a, f, t);
}
@

%old: was at the beginning, weird
%    if(ft == TDOUBLE && f->op == OCONST) {
%    }
%    if(ft == TFLOAT && f->op == OCONST) {
%    }

<<[[gmove()]] locals>>=
Node nod;
@



<<[[gmove()]] if from is not a register, registerize and return>>=
if(f->op == ONAME || f->op == OIND || f->op == OINDREG) {
    switch(ft) {
    case TCHAR:
        a = AMOVB;
        break;
    case TUCHAR:
        a = AMOVBU;
        break;
    case TSHORT:
        a = AMOVH;
        break;
    case TUSHORT:
        a = AMOVHU;
        break;
    case TFLOAT:
        a = AMOVF;
        break;
    case TDOUBLE:
        a = AMOVD;
        break;
    default:
        a = AMOVW;
        break;
    }
    if(typechlp[ft] && typeilp[tt])
        regalloc(&nod, t, t);
    else
        regalloc(&nod, f, t);
    gins(a, f, &nod);
    gmove(&nod, t);
    regfree(&nod);
    return;
}
@
%chlp: char, short, long, pointer
%todo: regalloc(, t, t) ??

<<[[gmove()]] if to is not a register, registerize and return>>=
if(t->op == ONAME || t->op == OIND || t->op == OINDREG) {
    switch(tt) {
    case TCHAR:
        a = AMOVB;
        break;
    case TUCHAR:
        a = AMOVBU;
        break;
    case TSHORT:
        a = AMOVH;
        break;
    case TUSHORT:
        a = AMOVHU;
        break;
    case TFLOAT:
        a = AMOVF;
        break;
    case TVLONG: // addon?
    case TDOUBLE:
        a = AMOVD;
        break;
    default:
        a = AMOVW;
        break;
    }
    if(ft == tt)
        regalloc(&nod, t, f);
    else
        regalloc(&nod, t, Z);
    gmove(f, &nod);
    gins(a, &nod, t);
    regfree(&nod);
    return;
}
@


<<[[gmove()]] locals>>=
Node nod1;
Prog *p1;
@

<<[[gmove()]] switch from type cases>>=
case TUINT:
case TULONG:
    <<[[gmove()]] switch from type cases, TUINT/TULONG case, if float target>>
    // fall through
case TINT:
case TLONG:
case TIND:
    switch(tt) {
    <<[[gmove()]] switch from type cases, TINT/TLONG case, if float target>>
    case TCHAR:
    case TUCHAR:
    case TSHORT:
    case TUSHORT:
    case TINT:
    case TUINT:
    case TLONG:
    case TULONG:

    case TIND:
        a = AMOVW;
        break;
    }
    break;
@


<<[[gmove()]] switch from type cases>>=
case TSHORT:
    switch(tt) {
    <<[[gmove()]] switch from type cases, TSHORT case, if float target>>
    case TUINT:
    case TINT:
    case TULONG:
    case TLONG:
    case TIND:
        a = AMOVH;
        break;
    case TCHAR:
    case TUCHAR:
    case TSHORT:
    case TUSHORT:
        a = AMOVW;
        break;
    }
    break;
@
% why more general AMOVW?

<<[[gmove()]] switch from type cases>>=
case TUSHORT:
    switch(tt) {
    <<[[gmove()]] switch from type cases, TUSHORT case, if float target>>
    case TINT:
    case TUINT:
    case TLONG:
    case TULONG:
    case TIND:
        a = AMOVHU;
        break;
    case TCHAR:
    case TUCHAR:
    case TSHORT:
    case TUSHORT:
        a = AMOVW;
        break;
    }
    break;
@

<<[[gmove()]] switch from type cases>>=
case TCHAR:
    switch(tt) {
    <<[[gmove()]] switch from type cases, TCHAR case, if float target>>
    case TINT:
    case TUINT:
    case TLONG:
    case TULONG:
    case TIND:
    case TSHORT:
    case TUSHORT:
        a = AMOVB;
        break;
    case TCHAR:
    case TUCHAR:
        a = AMOVW;
        break;
    }
    break;
@

<<[[gmove()]] switch from type cases>>=
case TUCHAR:
    switch(tt) {
    <<[[gmove()]] switch from type cases, TUCHAR case, if float target>>
    case TINT:
    case TUINT:
    case TLONG:
    case TULONG:
    case TIND:
    case TSHORT:
    case TUSHORT:
        a = AMOVBU;
        break;
    case TCHAR:
    case TUCHAR:
        a = AMOVW;
        break;
    }
    break;
@


<<function samaddr>>=
bool
samaddr(Node *f, Node *t)
{

    if(f->op != t->op)
        return false;
    switch(f->op) {
    case OREGISTER:
        return (f->reg == t->reg);
    }
    return false;
}
@







\subsection{[[gopcode()]]}

<<[[gopcode()]] locals>>=
Adr ta;
@

% from1, to, and f2 is for the optional middle register
<<function gopcode(arm)>>=
void
gopcode(int o, Node *f1, Node *f2, Node *t)
{
    // enum<opcode_kind> AXXX
    int a;
    // enum<type_kind> TXXX
    int et;
    <<[[gopcode()]] locals>>

    et = (f1 != Z && f1->type != T)? f1->type->etype : TLONG;

    <<[[gopcode()]] initialisation>>

    a = AGOK;
    switch(o) {
    <<[[gopcode()]] switch opcode cases>>
    }
    if(a == AGOK)
        diag(Z, "bad in gopcode %O", o);

    nextpc();
    p->as = a;

    if(f1 != Z)
        naddr(f1, &p->from);
    if(f2 != Z) {
        naddr(f2, &ta);
        p->reg = ta.reg;
    }
    if(t != Z)
        naddr(t, &p->to);

    if(debug['g'])
        print("%P\n", p);
}
@


%<<function fop(arm)>>=
%void
%fop(int as, int f1, int f2, Node *t)
%{
%    Node nod1, nod2, nod3;
%
%    nodreg(&nod1, t, NREG+f1);
%    nodreg(&nod2, t, NREG+f2);
%    regalloc(&nod3, t, t);
%    gopcode(as, &nod1, &nod2, &nod3);
%    gmove(&nod3, t);
%    regfree(&nod3);
%}
%@



%\subsection{[[gargs()]]}

\section{Register allocation}

\subsection{[[reg]]}

<<global reg(arm)>>=
// map<enum<registr>, bool>
char	reg[NREG+NFREG];
@
% could be a bool, but some nodes can use the same
% register, so we need to keep track and reference count them.

% those REGXX constants are in 5.out.h
<<[[ginit()]] reg and resvreg initialisation>>=
memset(reg, 0, sizeof(reg));

/* don't allocate */
reg[REGTMP] = 1;
reg[REGSB] = 1;
reg[REGSP] = 1;
reg[REGLINK] = 1;
reg[REGPC] = 1;
/* keep two external registers */
reg[REGEXT] = 1; // R10
reg[REGEXT-1] = 1; // R9
@


<<global resvreg(arm)>>=
static	char	resvreg[nelem(reg)];
@

<<[[ginit()]] reg and resvreg initialisation>>=
memmove(resvreg, reg, sizeof(reg));
@



<<[[gclean()]] sanity check reg>>=
for(i=0; i<NREG; i++)
    if(reg[i] && !resvreg[i])
        diag(Z, "reg %d left allocated", i);
@





\subsection{[[regalloc()]] and [[OREGISTER]]}

<<after parsing nodes>>=
OREGISTER, // via regalloc()
@
% !! fundamental, will transform some nodes in
% registers!

<<[[Node]] value fields>>=
// option<enum<registr>>
int		reg; // for OREGISTER
@
% has also xoffset!
%less: rename, to avoid ambiguity with Prog.reg and Adr.reg

% | ... -> <>
% o is the optional node target in which the allocated register
% will go into (via a mov), so if the target is a register, then
% his value will be overwritten, so we can use the same register
% (because can do ADD R1, 10, R1 in ARM!)
% n is OUT, tn is IN, o is option<IN>
<<function regalloc(arm)>>=
void
regalloc(Node *n, Node *tn, Node *o)
{
    int i, j;
    static int lasti;

    switch(tn->type->etype) {
    case TCHAR:
    case TUCHAR:
    case TSHORT:
    case TUSHORT:
    case TINT:
    case TUINT:
    case TLONG:
    case TULONG:

    case TIND:
        <<[[regalloc()]] if integer type tn and OREGISTER o>>

        j = lasti + REGRET+1;
        for(i=REGRET+1; i<NREG; i++) {
            if(j >= NREG)
                j = REGRET+1;
            if(reg[j] == 0 && resvreg[j] == 0) {
                i = j;
                goto out;
            }
            j++;
        }
        diag(tn, "out of fixed registers");
        goto err;

    <<[[regalloc()]] switch tn type, float or vlong case>>
    }

    diag(tn, "unknown type in regalloc: %T", tn->type);
    // fallthrough
err:
    nodreg(n, tn, 0);
    return;

out:
    reg[i]++;
    nodreg(n, tn, i);

    lasti++;
    if(lasti >= 5)
        lasti = 0;

}
@
% lasti is for what? some kind of optimisations, maybe can
% aspectize it?


% n is OUT, nn is IN
<<function nodreg(arm)>>=
void
nodreg(Node *n, Node *nn, int reg)
{
    *n = regnode;
    n->reg = reg;
    n->type = nn->type;
    n->lineno = nn->lineno;
}
@

<<global regnode>>=
Node	regnode;
@

<<[[ginit()]] special nodes initialisation>>=
regnode.op = OREGISTER;
regnode.class = CEXREG;
regnode.reg = REGTMP;
regnode.complex = 0;
regnode.addable = 11;
regnode.type = types[TLONG];
@
% class? CEXREG? matters? abused?



<<[[naddr()]] switch node kind cases>>=
case OREGISTER:
    a->type = D_REG;
    a->sym = S;
    a->reg = n->reg;
    if(a->reg >= NREG) {
        a->type = D_FREG;
        a->reg -= NREG;
    }
    break;
@


<<[[regalloc()]] if integer type tn and OREGISTER o>>=
if(o != Z && o->op == OREGISTER) {
    i = o->reg;
    if(i >= 0 && i < NREG)
        goto out;
}
@
% reuse same register, no need to allocate a new one

\subsection{[[regfree()]]}

<<function regfree(arm)>>=
void
regfree(Node *n)
{
    int i;

    <<[[regfree()]] sanity checks>>

    reg[n->reg]--;
    return;

err:
    diag(n, "error in regfree: %d", i);
}
@

<<[[regfree()]] sanity checks>>=
i = 0;
if(n->op != OREGISTER && n->op != OINDREG)
    goto err;

i = n->reg;
if(i < 0 || i >= sizeof(reg))
    goto err;
if(reg[i] <= 0)
    goto err;
@



\section{Typechecking, expliciting, annotating, rewriting, [[complex()]]}
% unsugaring -> expliciting?

% complex? compile lexical?
% gen | dodecl | doenum | codgen | bcomplex -> <>
<<function complex>>=
void
complex(Node *n)
{

    if(n == Z)
        return;

    nearln = n->lineno;

    if(debug['t'])
        if(n->op != OCONST)
            prtree(n, "pre complex");

    // typechecking, removing some sugar, lvalue annotate, bitfield annot, etc
    if(tcom(n))
        return;
    comma(n);
    if(debug['t'])
        if(n->op != OCONST)
            prtree(n, "t complex");

    // general rewrite
    ccom(n);
    if(debug['t'])
        if(n->op != OCONST)
            prtree(n, "c complex");

    // arithmetic rewrite
    acom(n);
    if(debug['t'])
        if(n->op != OCONST)
            prtree(n, "a complex");

    // addressability and complexity
    xcom(n);
    if(debug['t'])
        if(n->op != OCONST)
            prtree(n, "x complex");
}
@
%    //if(debug['y'] || true)




\section{Functions, [[codgen()]]}

% n = node of the blocks OLIST, nn = node of the xdecor (should be ONAME)
% cc2/pgen.c  
<<function codgen>>=
//@Scheck: used by cc.y
void codgen(Node *n, Node *nn)
{
    Prog *sp;
    <<[[codgen()]] locals>>

    <<[[codgen()]] initialisation>>

    <<[[codgen()]] set n1 node to node in nn where have ONAME>>
    nearln = nn->lineno;
    gpseudo(ATEXT, n1->sym, nodconst(stkoff));
    sp = p;

    <<[[codgen()]] if complex return type>>
    <<[[codgen()]] if use REGARG>>

    <<[[codgen()]] initialisation before call to gen>>
    // generate the assembly for the statements in the body
    gen(n);
    <<[[codgen()]] warn for possible missing return after call to gen>>

    <<[[codgen()]] before RET>>
    gbranch(ORETURN);

    <<[[codgen()]] register optimisation>>
    
    sp->to.offset += maxargsafe;
}
@
% += this time because set with stkoff at first.
% but why offset can change? because introduce new hidden locals?
% the regxxalloc() apparently can modify maxargsafe

%todo: for stkoff, it's size of locals, which will then be translated
% by the assembler in some final machine code! which is?

%dead:
%<<[[codgen()]] initialisation>>=
%hasdoubled = false;
%@
%<<global hasdoubled>>=
%bool	hasdoubled;
%@
%    if(thechar=='6' || thechar=='7' || thechar=='9' || hasdoubled)	/* [sic] */
%        maxargsafe = round(maxargsafe, 8);
%% seems dead



<<[[codgen()]] locals>>=
Node *n1;
@

<<[[codgen()]] set n1 node to node in nn where have ONAME>>=
/*
 * isolate name
 */
for(n1 = nn;; n1 = n1->left) {
    if(n1 == Z) {
        diag(nn, "cant find function name");
        return;
    }
    if(n1->op == ONAME)
        break;
}
@
% in which case the ONAME is not directly there??



<<global constnode>>=
Node	constnode;
@
<<[[ginit()]] special nodes initialisation>>=
constnode.op = OCONST;
constnode.class = CXXX;
constnode.complex = 0;
constnode.addable = 20;
constnode.type = types[TLONG];
@
<<function nodconst>>=
Node*
nodconst(long v)
{
    constnode.vconst = v;
    return &constnode;
}
@
% it's because gpseudo except a Node and call naddr(&p->to)



\section{Statements, [[gen()]]}
% mimic parsing chapter subsections

% codgen -> <>
% cc2/pgen.c
<<function gen>>=
void
gen(Node *n)
{
    // enum<node_kind> of a statement
    int o;
    <<[[gen()]] locals>>

loop:
    if(n == Z)
        return;

    nearln = n->lineno;
    o = n->op;

    if(debug['G'] && (o != OLIST))
        print("%L %O\n", nearln, o);

    <<[[gen()]] if not canreach>>

    switch(o) {
    <<[[gen()]] switch node kind cases>>
    }
}
@


\subsection{Blocks, sequences}

<<[[gen()]] switch node kind cases>>=
case OLIST:
case OCOMMA:
    gen(n->left);

rloop:
    n = n->right;
    goto loop;
@
% a;b is like a,b

\subsection{Conditionals and [[boolgen()]]}

\subsubsection{Code generation}

<<[[gen()]] locals>>=
Prog *sp;
Node *l;
bool err;
@
% saved prog

<<[[gen()]] locals>>=
bool oldreach;
@

% see Parsing section to remember how an OIF tree is
% represented, with what is l(the cond) and r(a pair OLIST of then and else)

% if e { thenst } else { elsest }
% ->
%   <code e>       <-- bcomplex
%   ABxx elsepc    <-- bcomplex
%   <code thenst>
%   AB endpc
%   elsepc:
%   <code elsest>
%   endpc:
%note that endpc is after the last instruction of elsest, because
% of the way nextpc() works!.

<<[[gen()]] switch node kind cases>>=
case OIF:
    l = n->left;
    err = bcomplex(l, n->right);
    <<[[gen()]] switch node kind cases, OIF case, if bcomplex error>>
    else {
        sp = p; // AB instr for 'else' to patch later (created by bcomplex())
        canreach = true;

        if(n->right->left != Z) // gen then part
            gen(n->right->left); 

        oldreach = canreach;
        canreach = true;

        if(n->right->right != Z) { // gen else part
            gbranch(OGOTO);
            patch(sp, pc);
            sp = p;

            gen(n->right->right);
        }
        patch(sp, pc);

        canreach = canreach || oldreach;
        if(canreach == false)
            warnreach = !suppress;
    }
    break;
@
% passing n->right in complex() is for deadends detection

% bcomplex(), boolean_complex()

% bcomplex will call boolgen which will create the necessary
% instructions
% less: but where have ABNE? gbranch seems to create only
% AB instructions. and patch() only modify the pc of the
% branching opcode. Who sets ABNE? gopcode()

\subsubsection{[[bcomplex()]]}
% does both the call to complex and cgen(boolgen) when it needs!

% return bool where false = 0 = 0 error.
% c = context that is code possibly conditioned to run depending
% on the value of this boolean expression (e.g. then/else part of an if)
<<function bcomplex>>=
bool
bcomplex(Node *n, Node *c)
{

    complex(n);

    if(n->type != T)
       if(tcompat(n, T, n->type, tnot))
          n->type = T;
    if(n->type == T) {
        gbranch(OGOTO);
        return false;
    }
    if(c != Z && n->op == OCONST && deadheads(c))
        return true;

    bool64(n);
    boolgen(n, true, Z);
    return false;
}
@
%//    Node *b, nod;
%    /* this is not quite right yet, so ignore it for now */
%    if(0 && newvlongcode && typev[n->type->etype] && machcap(Z)) {
%        b = &nod;
%        b->op = ONE;
%        b->left = n;
%        b->right = new(0, Z, Z);
%        *b->right = *nodconst(0);
%        b->right->type = n->type;
%        b->type = types[TLONG];
%        cgen(b, Z);
%        return 0;
%    }



\subsubsection{[[boolgen()]]}


\subsubsection{Conditional typing errors}

<<[[gen()]] locals>>=
bool f;
@

<<[[gen()]] switch node kind cases, OIF case, if bcomplex error>>=
if(err) {
    if(typefd[l->type->etype])
        f = !l->fconst;
    else
        f = !l->vconst;
    if(debug['c'])
        print("%L const if %s\n", nearln, f ? "false" : "true");

    if(f) {
        canreach = true;
        supgen(n->right->left);
        oldreach = canreach;
        canreach = true;
        gen(n->right->right);
        /*
         * treat constant ifs as regular ifs for 
         * reachability warnings.
         */
        if(!canreach && oldreach && debug['w'] < 2)
            warnreach = 0;
    } else {
        canreach = true;
        gen(n->right->left);
        oldreach = canreach;
        canreach = true;
        supgen(n->right->right);
        /*
         * treat constant ifs as regular ifs for 
         * reachability warnings.
         */
        if(!oldreach && canreach && debug['w'] < 2)
            warnreach = 0;
        canreach = oldreach;
    }
}
@
% what is default value for non constant node of fconst and vconst??
% zero?

<<function supgen>>=
void
supgen(Node *n)
{
    bool owarn;
    long opc;
    Prog *olastp;

    if(n == Z)
        return;

    suppress++;
    owarn = warnreach;
    opc = pc;
    olastp = lastp;

    warnreach = false;

    gen(n);

    lastp = olastp;
    olastp->link = nil;
    pc = opc;
    warnreach = owarn;
    suppress--;
}
@


\subsection{Loops}

<<global breakpc>>=
// option<pc>, None = -1
long	breakpc;
@
% for break to branch at the right place

<<global continpc>>=
// option<pc>, None = -1
long	continpc;
@
% for continue to branch at the right place

<<[[ginit()]] initialisation>>=
breakpc = -1;
continpc = -1;
@



% turn into a static local?
<<global ncontin>>=
int	ncontin;
@

<<global nbreak>>=
long nbreak;
@



<<[[gen()]] locals>>=
Prog *spc, *spb;
long sbc, scc;
int snbreak, sncontin;
@
% saved prog continue, saved prog break

<<[[gen()]] switch node kind cases>>=
case OWHILE:
case ODWHILE:
    l = n->left;

    gbranch(OGOTO);		/* entry */
    sp = p;

    scc = continpc;
    continpc = pc;

    gbranch(OGOTO);
    spc = p;

    sbc = breakpc;
    breakpc = pc;
    snbreak = nbreak;
    nbreak = 0;

    gbranch(OGOTO);
    spb = p;

    patch(spc, pc);
    if(n->op == OWHILE)
        patch(sp, pc);
    bcomplex(l, Z);		/* test */
    patch(p, breakpc);
    if(l->op != OCONST || vconst(l) == 0)
        nbreak++;

    if(n->op == ODWHILE)
        patch(sp, pc);
    gen(n->right);		/* body */

    gbranch(OGOTO);
    patch(p, continpc);

    patch(spb, pc);

    continpc = scc;
    breakpc = sbc;
    canreach = nbreak!=0;
    if(canreach == false)
        warnreach = !suppress;
    nbreak = snbreak;
    break;
@

<<[[gen()]] switch node kind cases>>=
case OFOR:
    l = n->left;
    if(!canreach && l->right->left && warnreach) {
        warn(n, "unreachable code FOR");
        warnreach = 0;
    }
    gen(l->right->left);	/* init */

    gbranch(OGOTO);		/* entry */
    sp = p;

    /* 
     * if there are no incoming labels in the 
     * body and the top's not reachable, warn
     */
    if(!canreach && warnreach && deadheads(n)) {
        warn(n, "unreachable code %O", o);
        warnreach = 0;
    }

    scc = continpc;
    continpc = pc;

    gbranch(OGOTO);
    spc = p;

    sbc = breakpc;
    breakpc = pc;
    snbreak = nbreak;
    nbreak = 0;
    sncontin = ncontin;
    ncontin = 0;

    gbranch(OGOTO);
    spb = p;

    patch(spc, pc);
    gen(l->right->right);	/* inc */
    patch(sp, pc);	
    if(l->left != Z) {	/* test */
        bcomplex(l->left, Z);
        patch(p, breakpc);
        if(l->left->op != OCONST || vconst(l->left) == 0)
            nbreak++;
    }
    canreach = true;
    gen(n->right);		/* body */
    if(canreach){
        gbranch(OGOTO);
        patch(p, continpc);

        ncontin++;
    }
    if(!ncontin && l->right->right && warnreach) {
        warn(l->right->right, "unreachable FOR inc");
        warnreach = 0;
    }

    patch(spb, pc);
    continpc = scc;
    breakpc = sbc;
    canreach = nbreak!=0;
    if(canreach == false)
        warnreach = !suppress;
    nbreak = snbreak;
    ncontin = sncontin;
    break;
@


\subsection{Control flow jumps}

\subsubsection{Return}

<<[[gen()]] locals>>=
Node nod;
@

<<[[gen()]] switch node kind cases>>=
case ORETURN:
    canreach = false;
    warnreach = !suppress;

    complex(n);
    if(n->type == T)
        break;

    l = uncomma(n->left);
    if(l == Z) {
        <<[[gen()]] case ORETURN with no argument, before RET>>
        gbranch(ORETURN);
    } 
    else
    <<[[gen()]] case ORETURN, if complex type>>
    else {
        regret(&nod, n);
        cgen(l, &nod);
        regfree(&nod);
        <<[[gen()]] case ORETURN with argument, before RET>>
        gbranch(ORETURN);
    }
    break;
@

% gen(case RETURN) -> <>
<<function uncomma>>=
Node*
uncomma(Node *n)
{
    while(n != Z && n->op == OCOMMA) {
        cgen(n->left, Z);
        n = n->right;
    }
    return n;
}
@




<<function regret(arm)>>=
void
regret(Node *n, Node *nn)
{
    int r;

    r = REGRET;
    if(typefd[nn->type->etype])
        r = FREGRET+NREG;
    nodreg(n, nn, r);
    reg[r]++;
}
@

\subsubsection{Continue/break}


<<[[gen()]] switch node kind cases>>=
case OCONTINUE:
    if(continpc < 0) {
        diag(n, "continue not in a loop");
        break;
    }
    gbranch(OGOTO);
    patch(p, continpc);

    ncontin++;
    canreach = false;
    warnreach = !suppress;
    break;
@

<<[[gen()]] switch node kind cases>>=
case OBREAK:
    if(breakpc < 0) {
        diag(n, "break not in a loop");
        break;
    }
    /*
     * Don't complain about unreachable break statements.
     * There are breaks hidden in yacc's output and some people
     * write return; break; in their switch statements out of habit.
     * However, don't confuse the analysis by inserting an 
     * unreachable reference to breakpc either.
     */
    if(!canreach)
        break;

    gbranch(OGOTO);
    patch(p, breakpc);

    nbreak++;
    canreach = false;
    warnreach = !suppress;
    break;
@


\subsection{Switch}


<<[[gen()]] locals>>=
Case *cn;
@

<<[[gen()]] switch node kind cases>>=
case OSWITCH:
    l = n->left;
    complex(l);
    if(l->type == T)
        break;
    if(!typeswitch[l->type->etype]) {
        diag(n, "switch expression must be integer");
        break;
    }

    gbranch(OGOTO);		/* entry */
    sp = p;

    cn = cases;
    cases = C;
    casf();

    sbc = breakpc;
    breakpc = pc;
    snbreak = nbreak;
    nbreak = 0;

    gbranch(OGOTO);
    spb = p;

    gen(n->right);		/* body */
    if(canreach){
        gbranch(OGOTO);
        patch(p, breakpc);

        nbreak++;
    }

    patch(sp, pc);
    regalloc(&nod, l, Z);
    /* always signed */
    if(typev[l->type->etype])
        nod.type = types[TVLONG];
    else
        nod.type = types[TLONG];
    cgen(l, &nod);
    doswit(&nod);
    regfree(&nod);
    patch(spb, pc);

    cases = cn;
    breakpc = sbc;
    canreach = nbreak!=0;
    if(canreach == false)
        warnreach = !suppress;
    nbreak = snbreak;
    break;
@




<<[[gen()]] switch node kind cases>>=
case OCASE:
    canreach = true;
    l = n->left;
    if(cases == C)
        diag(n, "case/default outside a switch");
    if(l == Z) {
        casf();
        cases->val = 0;
        cases->def = 1;
        cases->label = pc;
        cases->isv = 0;
        goto rloop;
    }
    complex(l);
    if(l->type == T)
        goto rloop;
    if(l->op != OCONST || !typeswitch[l->type->etype]) {
        diag(n, "case expression must be integer constant");
        goto rloop;
    }
    casf();
    cases->val = l->vconst;
    cases->def = 0;
    cases->label = pc;
    cases->isv = typev[l->type->etype];
    goto rloop;
@


% C1, Case are in 5c/
% the code below is in cc2/pswt.c


<<struct Case>>=
struct	Case
{
    vlong	val;
    long	label;
    char	def;
    char 	isv;

    Case*	link;
};
@



<<constant C>>=
#define	C	((Case*)nil)
@


<<struct C1>>=
struct	C1
{
    vlong	val;
    long	label;
};
@


<<global cases>>=
Case*	cases;
@
<<[[ginit()]] initialisation>>=
cases = C;
@


<<global cases>>=
Case*	cases;
@


<<function swcmp>>=
int
swcmp(const void *a1, const void *a2)
{
    C1 *p1, *p2;

    p1 = (C1*)a1;
    p2 = (C1*)a2;
    if(p1->val < p2->val)
        return -1;
    return p1->val > p2->val;
}
@

<<function doswit>>=
void
doswit(Node *n)
{
    Case *c;
    C1 *q, *iq, *iqh, *iql;
    long def, nc, i, j, isv, nh;
    Prog *hsb;
    Node *vr[2];
    int dup;

    def = 0;
    nc = 0;
    isv = 0;
    for(c = cases; c->link != C; c = c->link) {
        if(c->def) {
            if(def)
                diag(n, "more than one default in switch");
            def = c->label;
            continue;
        }
        isv |= c->isv;
        nc++;
    }
    if(typev[n->type->etype])
        isv = 1;
    else if(isv){
        warn(n, "32-bit switch expression with 64-bit case constant");
        isv = 0;
    }

    iq = alloc(nc*sizeof(C1));
    q = iq;
    for(c = cases; c->link != C; c = c->link) {
        if(c->def)
            continue;
        if(c->isv && !isv)
            continue;	/* can never match */
        q->label = c->label;
        if(isv)
            q->val = c->val;
        else
            q->val = (long)c->val;	/* cast ensures correct value for 32-bit switch on 64-bit architecture */
        q++;
    }
    qsort(iq, nc, sizeof(C1), swcmp);

    if(debug['K'])
     for(i=0; i<nc; i++)
        print("case %2ld: = %.8llux\n", i, (vlong)iq[i].val);
 
   dup = 0;
    for(i=0; i<nc-1; i++)
        if(iq[i].val == iq[i+1].val) {
            diag(n, "duplicate cases in switch %lld", (vlong)iq[i].val);
            dup = 1;
        }
    if(dup)
        return;
    if(def == 0) {
        def = breakpc;
        nbreak++;
    }
    if(!isv || ewidth[TIND] > ewidth[TLONG] || n->op == OREGISTER) {
        swit1(iq, nc, def, n);
        return;
    }

    /*
     * 64-bit case on 32-bit machine:
     * switch on high-order words, and
     * in each of those, switch on low-order words
     */
    if(n->op != OREGPAIR)
        fatal(n, "internal: expected register pair");
    if(thechar == '8'){	/* TO DO: need an enquiry function */
        vr[0] = n->left;	/* low */
        vr[1] = n->right;	/* high */
    }else{
        vr[0] = n->right;
        vr[1] = n->left;
    }
    vr[0]->type = types[TLONG];
    vr[1]->type = types[TLONG];

    gbranch(OGOTO);
    hsb = p;

    iqh = alloc(nc*sizeof(C1));
    iql = alloc(nc*sizeof(C1));
    nh = 0;
    for(i=0; i<nc;){
        iqh[nh].val = iq[i].val >> 32;
        q = iql;
        /* iq is sorted, so equal top halves are adjacent */
        for(j = i; j < nc; j++){
            if((iq[j].val>>32) != iqh[nh].val)
                break;
            q->val = (long)iq[j].val;
            q->label = iq[j].label;
            q++;
        }
        qsort(iql,  q-iql, sizeof(C1), swcmp);
                //if(0){for(int k=0; k<(q-iql); k++)print("nh=%ld k=%d h=%#llux l=%#llux lab=%ld\n", nh, k, (vlong)iqh[nh].val,  (vlong)iql[k].val, iql[k].label);}
        iqh[nh].label = pc;
        nh++;
        swit1(iql, q-iql, def, vr[0]);
        i = j;
    }
    patch(hsb, pc);
        //if(0){for(int k=0; k<nh; k++)print("k*=%d h=%#llux lab=%ld\n", k, (vlong)iqh[k].val,  iqh[k].label);}
    swit1(iqh, nh, def, vr[1]);
}
@

<<function casf>>=
void
casf(void)
{
    Case *c;

    c = alloc(sizeof(*c));
    c->link = cases;
    cases = c;
}
@

<<function swit1(arm)>>=
void
swit1(C1 *q, int nc, long def, Node *n)
{
    Node tn;
    
    regalloc(&tn, &regnode, Z);
    swit2(q, nc, def, n, &tn);
    regfree(&tn);
}
@

<<function swit2(arm)>>=
void
swit2(C1 *q, int nc, long def, Node *n, Node *tn)
{
    C1 *r;
    int i;
    long v;
    Prog *sp;

    if(nc >= 3) {
        i = (q+nc-1)->val - (q+0)->val;
        if(i > 0 && i < nc*2)
            goto direct;
    }
    if(nc < 5) {
        for(i=0; i<nc; i++) {
            if(debug['K'])
                print("case = %.8llux\n", q->val);
            gopcode(OEQ, nodconst(q->val), n, Z);
            patch(p, q->label);
            q++;
        }
        gbranch(OGOTO);
        patch(p, def);

        return;
    }

    i = nc / 2;
    r = q+i;
    if(debug['K'])
        print("case > %.8llux\n", r->val);
    gopcode(OGT, nodconst(r->val), n, Z);
    sp = p;
    gopcode(OEQ, nodconst(r->val), n, Z);	/* just gen the B.EQ */
    patch(p, r->label);
    swit2(q, i, def, n, tn);

    if(debug['K'])
        print("case < %.8llux\n", r->val);
    patch(sp, pc);
    swit2(r+1, nc-i-1, def, n, tn);
    return;

direct:
    v = q->val;
    if(v != 0)
        gopcode(OSUB, nodconst(v), Z, n);
    gopcode(OCASE, nodconst((q+nc-1)->val - v), n, Z);
    patch(p, def);
    for(i=0; i<nc; i++) {
        if(debug['K'])
            print("case = %.8llux\n", q->val);
        while(q->val != v) {
            nextpc();
            p->as = ABCASE;
            patch(p, def);
            v++;
        }
        nextpc();
        p->as = ABCASE;
        patch(p, q->label);
        q++;
        v++;
    }

    gbranch(OGOTO);		/* so that regopt() won't be confused */
    patch(p, def);
}
@

\subsection{Labels and goto}

% abuse complex to represent whether the label is defined.

<<[[Node]] code generation fields>>=
long	pc;
@
% can be seen as a kind of value field too, for OLABEL and OGOTO

<<[[Node]] code generation fields>>=
// ref<Prog>, but use void to be archi independent
void*	label;
@

<<[[gen()]] switch node kind cases>>=
case OLABEL:
    canreach = true;
    l = n->left;
    if(l) {
        l->pc = pc;
        if(l->label)
            patch(l->label, pc);
    }
    gbranch(OGOTO);	/* prevent self reference in reg */
    patch(p, pc);

    goto rloop;
@

<<[[gen()]] switch node kind cases>>=
case OGOTO:
    canreach = false;
    warnreach = !suppress;

    n = n->left;
    if(n == Z) // possible?
        return;
    if(n->complex == 0) {
        diag(Z, "label undefined: %s", n->sym->name);
        return;
    }
    if(suppress)
        return;

    gbranch(OGOTO);
    if(n->pc) {
        patch(p, n->pc);
    } else {
        if(n->label)
             patch(n->label, pc-1);
        n->label = p;
    }
    return;
@
% pc -1?

\section{Expressions, [[cgen()]]}
% mimic parsing chapter subsection

<<[[gen()]] switch node kind cases>>=
default:
    complex(n);
    cgen(n, Z);
    break;
@

% also many calls to bcomplex() before when processing
% statements for instance for the expression in if(e), or while(e).
% Many calls to cgen too.



% codgen -> gen -> <>    for expression stuff
% nn is optional! it's the possible target of the expr, e.g.
% if do return <expr>; then will have in nn a node with REGRET
%pre: has called complex() on the node n before (and nn if not null?)
<<function cgen(arm)>>=
void
cgen(Node *n, Node *nn)
{
    cgenrel(n, nn, false);
}
@
% false means inrel = false
% why care whether rel context?


% nn = optional lhs?, n = rhs
<<function cgenrel(arm)>>=
void
cgenrel(Node *n, Node *nn, bool inrel)
{
    Node *l, *r;
    // enum<node_kind>
    int o;
    // enum<type_kind>?
    int t;
    long curs;
    <<[[cgenrel()]] locals>>

    if(debug['g']) {
        prtree(nn, "cgen lhs");
        prtree(n, "cgen");
    }
    if(n == Z || n->type == T)
        return;

    <<[[cgenrel()]] if complex type node>>
    else {

        l = n->left;
        r = n->right;
        o = n->op;
        
        <<[[cgenrel()]] if addable more than INDEXED>>
        curs = cursafe;
        <<[[cgenrel()]] if all complex fields more than FNX>>
        
        switch(o) {
        <<[[cgenrel()]] switch node kind cases>>
        default:
            diag(n, "unknown op in cgen: %O", o);
            break;
        }
        cursafe = curs;
    }
    return;
}
@

<<[[cgenrel()]] switch node kind cases>>=
case OCOMMA:
    cgen(l, Z);
    cgen(r, nn);
    break;
@
% lhs = a,b  => a; lhs = b;



<<[[cgenrel()]] locals>>=
Prog *p1;
Node nod, nod1, nod2, nod3, nod4;
long v;
@
% 5 possible registers, which is why the lasti <= 5 in regalloc?


\subsection{Arithmetic expressions}

% see also acom() rewriting


<<[[cgenrel()]] switch node kind cases>>=
case OSUB:
    if(nn != Z)
     if(l->op == OCONST)
      if(!typefd[n->type->etype]) {
        cgen(r, nn);
        gopcode(o, Z, l, nn);
        break;
    }
    // Fallthrough
case OADD:
case OAND:
case OOR:
case OXOR:
case OLSHR:
case OASHL:
case OASHR:
    /*
     * immediate operands
     */
    if(nn != Z)
     if(r->op == OCONST)
      if(!typefd[n->type->etype]) {
        cgen(l, nn);
        if((r->vconst == 0) && (o != OAND))
            break;
        if(nn != Z)
            gopcode(o, r, Z, nn);
        break;
    }
    // Fallthrough
case OLMUL:
case OLDIV:
case OLMOD:
case OMUL:
muldiv:
    <<[[cgenrel()]] nullwarn check if nn is null>>
    if(o == OMUL || o == OLMUL) {
        if(mulcon(n, nn))
            break;
    }
    if(l->complex >= r->complex) {
        regalloc(&nod, l, nn);
        cgen(l, &nod);
        regalloc(&nod1, r, Z);
        cgen(r, &nod1);
        gopcode(o, &nod1, Z, &nod);
    } else {
        regalloc(&nod, r, nn);
        cgen(r, &nod);
        regalloc(&nod1, l, Z);
        cgen(l, &nod1);
        gopcode(o, &nod, &nod1, &nod);
    }
    gopcode(OAS, &nod, Z, nn);
    regfree(&nod);
    regfree(&nod1);
    break;
@

<<[[cgenrel()]] nullwarn check if nn is null>>=
if(nn == Z) {
    nullwarn(l, r);
    break;
}
@

% this in cc/pswt.c but should be in a cc/pcgen.c
<<function nullwarn>>=
void
nullwarn(Node *l, Node *r)
{
    warn(Z, "result of operation not used");
    if(l != Z)
        cgen(l, Z);
    if(r != Z)
        cgen(r, Z);
}
@
%less: mv also in Checking section?





<<[[cgenrel()]] switch node kind cases>>=
case ODIV:
case OMOD:
    if(nn != Z)
     if((t = vlog(r)) >= 0) {
        /* signed div/mod by constant power of 2 */
        cgen(l, nn);
        gopcode(OGE, nodconst(0), nn, Z);
        p1 = p;
        if(o == ODIV) {
            gopcode(OADD, nodconst((1<<t)-1), Z, nn);
            patch(p1, pc);
            gopcode(OASHR, nodconst(t), Z, nn);
        } else {
            gopcode(OSUB, nn, nodconst(0), nn);
            gopcode(OAND, nodconst((1<<t)-1), Z, nn);
            gopcode(OSUB, nn, nodconst(0), nn);
            gbranch(OGOTO);
            patch(p1, pc);
            p1 = p;
            gopcode(OAND, nodconst((1<<t)-1), Z, nn);
            patch(p1, pc);
        }
        break;
    }
    goto muldiv;
@



<<[[gopcode()]] switch opcode cases>>=
case OASADD:
case OADD:
    a = AADD;
    if(et == TFLOAT)
        a = AADDF;
    else
    if(et == TDOUBLE || et == TVLONG)
        a = AADDD;
    break;
@
<<[[gopcode()]] switch opcode cases>>=
case OASSUB:
case OSUB:
    if(f2 && f2->op == OCONST) {
        Node *t = f1;
        f1 = f2;
        f2 = t;
        a = ARSB;
    } else
        a = ASUB;
    if(et == TFLOAT)
        a = ASUBF;
    else
    if(et == TDOUBLE || et == TVLONG)
        a = ASUBD;
    break;
@
<<[[gopcode()]] switch opcode cases>>=
case OASOR:
case OOR:
    a = AORR;
    break;
@
<<[[gopcode()]] switch opcode cases>>=
case OASAND:
case OAND:
    a = AAND;
    break;
@
<<[[gopcode()]] switch opcode cases>>=
case OASXOR:
case OXOR:
    a = AEOR;
    break;
@
<<[[gopcode()]] switch opcode cases>>=
case OASLSHR:
case OLSHR:
    a = ASRL;
    break;
@
<<[[gopcode()]] switch opcode cases>>=
case OASASHR:
case OASHR:
    a = ASRA;
    break;
@
<<[[gopcode()]] switch opcode cases>>=
case OASASHL:
case OASHL:
    a = ASLL;
    break;
@



<<[[gopcode()]] switch opcode cases>>=
case OASMUL:
case OMUL:
    a = AMUL;
    if(et == TFLOAT)
        a = AMULF;
    else
    if(et == TDOUBLE || et == TVLONG)
        a = AMULD;
    break;
@
<<[[gopcode()]] switch opcode cases>>=
case OASDIV:
case ODIV:
    a = ADIV;
    if(et == TFLOAT)
        a = ADIVF;
    else
    if(et == TDOUBLE || et == TVLONG)
        a = ADIVD;
    break;
@
<<[[gopcode()]] switch opcode cases>>=
case OASMOD:
case OMOD:
    a = AMOD;
    break;
@
<<[[gopcode()]] switch opcode cases>>=
case OASLMUL:
case OLMUL:
    a = AMULU;
    break;
@
<<[[gopcode()]] switch opcode cases>>=
case OASLMOD:
case OLMOD:
    a = AMODU;
    break;
@
<<[[gopcode()]] switch opcode cases>>=
case OASLDIV:
case OLDIV:
    a = ADIVU;
    break;
@


\subsection{Boolean expressions}

% idea is to generate code to evaluate expression
% and finish by an ABxxx that can be patched to jmp
% to the code when the condition was not true.

%ex:
%  if(1) { ... }
% => 
%  MOV $1, R0
%  ABxx ??tofilllater?? by patch()

<<[[cgenrel()]] switch node kind cases>>=
case OANDAND:
case OOROR:
    boolgen(n, true, nn);
    if(nn == Z)
        patch(p, pc);
    break;
@

<<[[cgenrel()]] switch node kind cases>>=
case ONOT:
    <<[[cgenrel()]] nullwarn check if nn is null, empty right>>
    boolgen(n, true, nn);
    break;
@

<<[[cgenrel()]] nullwarn check if nn is null, empty right>>=
if(nn == Z) {
    nullwarn(l, Z);
    break;
}
@

% OCOM?

<<[[cgenrel()]] switch node kind cases>>=
case OEQ:
case ONE:
case OLE:
case OLT:
case OGE:
case OGT:
case OLO:
case OLS:
case OHI:
case OHS:
    <<[[cgenrel()]] nullwarn check if nn is null>>
    boolgen(n, true, nn);
    break;
@




<<constant BTRUE(arm)>>=
#define	BTRUE		0x1000
@
% ugly, need to be more than node_kind max OEND

<<[[gopcode()]] locals>>=
bool btrue;
@
<<[[gopcode()]] initialisation>>=
btrue = o & BTRUE;
o &= ~BTRUE;
@



% cgenrel | bcomplex -> <>
<<function boolgen(arm)>>=
void
boolgen(Node *n, int btrue, Node *nn)
{
    int o;
    Prog *p1, *p2;
    Node *l, *r, nod, nod1;
    long curs;

    if(debug['g']) {
        prtree(nn, "boolgen lhs");
        prtree(n, "boolgen");
    }
    curs = cursafe;

    l = n->left;
    r = n->right;
    switch(n->op) {

    case OCONST:
        o = vconst(n);
        if(!btrue)
            o = !o;
        gbranch(OGOTO);
        if(o) {
            p1 = p;
            gbranch(OGOTO);
            patch(p1, pc);
        }
        goto com;

    case OCOMMA:
        cgen(l, Z);
        boolgen(r, btrue, nn);
        break;

    case ONOT:
        boolgen(l, !btrue, nn);
        break;

    case OCOND:
        bcgen(l, 1);
        p1 = p;
        bcgen(r->left, btrue);
        p2 = p;
        gbranch(OGOTO);
        patch(p1, pc);
        p1 = p;
        bcgen(r->right, !btrue);
        patch(p2, pc);
        p2 = p;
        gbranch(OGOTO);
        patch(p1, pc);
        patch(p2, pc);
        goto com;

    case OANDAND:
        if(!btrue)
            goto caseor;

    caseand:
        bcgen(l, btrue);
        p1 = p;
        bcgen(r, !btrue);
        p2 = p;
        patch(p1, pc);
        gbranch(OGOTO);
        patch(p2, pc);
        goto com;

    case OOROR:
        if(!btrue)
            goto caseand;

    caseor:
        bcgen(l, !btrue);
        p1 = p;
        bcgen(r, !btrue);
        p2 = p;
        gbranch(OGOTO);
        patch(p1, pc);
        patch(p2, pc);
        goto com;

    case OEQ:
    case ONE:
    case OLE:
    case OLT:
    case OGE:
    case OGT:
    case OHI:
    case OHS:
    case OLO:
    case OLS:
        o = n->op;
        if(btrue)
            o = comrel[relindex(o)];
        if(l->complex >= FNX && r->complex >= FNX) {
            regret(&nod, r);
            cgenrel(r, &nod, btrue);
            regsalloc(&nod1, r);
            gopcode(OAS, &nod, Z, &nod1);
            regfree(&nod);
            nod = *n;
            nod.right = &nod1;
            boolgen(&nod, btrue, nn);
            break;
        }
        if(sconst(l)) {
            regalloc(&nod, r, nn);
            cgenrel(r, &nod, btrue);
            o = invrel[relindex(o)];
            gopcode(btrue ? o | BTRUE : o, l, &nod, Z);
            regfree(&nod);
            goto com;
        }
        if(sconst(r)) {
            regalloc(&nod, l, nn);
            cgenrel(l, &nod, btrue);
            gopcode(btrue ? o | BTRUE : o, r, &nod, Z);
            regfree(&nod);
            goto com;
        }

        if(l->complex >= r->complex) {
            regalloc(&nod1, l, nn);
            cgenrel(l, &nod1, btrue);
            regalloc(&nod, r, Z);
            cgenrel(r, &nod, btrue);
        } else {
            regalloc(&nod, r, nn);
            cgenrel(r, &nod, btrue);
            regalloc(&nod1, l, Z);
            cgenrel(l, &nod1, btrue);
        }
        gopcode(btrue ? o | BTRUE : o, &nod, &nod1, Z);
        regfree(&nod);
        regfree(&nod1);

    com:
        if(nn != Z) {
            p1 = p;
            gopcode(OAS, nodconst(1), Z, nn);
            gbranch(OGOTO);
            p2 = p;
            patch(p1, pc);
            gopcode(OAS, nodconst(0), Z, nn);
            patch(p2, pc);
        }
        break;

    default:
        regalloc(&nod, n, nn);
        cgen(n, &nod);
        o = ONE;
        if(btrue)
            o = comrel[relindex(o)];
        if(typefd[n->type->etype]) {
            gopcode(btrue ? o | BTRUE : o, nodfconst(0), &nod, Z);
        } else
            gopcode(o, nodconst(0), &nod, Z);
        regfree(&nod);
        goto com;

    }
    cursafe = curs;
}
@
% >> >>


<<function bcgen>>=
void
bcgen(Node *n, bool btrue)
{

    if(n->type == T)
        gbranch(OGOTO);
    else
        boolgen(n, btrue, Z);
}
@

<<function relindex>>=
int
relindex(int o)
{

    switch(o) {
    case OEQ: return 0;
    case ONE: return 1;
    case OLE: return 2;
    case OLS: return 3;
    case OLT: return 4;
    case OLO: return 5;
    case OGE: return 6;
    case OHS: return 7;
    case OGT: return 8;
    case OHI: return 9;
    default:
        diag(Z, "bad in relindex: %O", o);
    }
}
@


<<global comrel>>=
/*	OEQ, ONE, OLE, OLS, OLT, OLO, OGE, OHS, OGT, OHI */
char	comrel[12] =
{
    ONE, OEQ, OGT, OHI, OGE, OHS, OLT, OLO, OLE, OLS,
};
@

<<global invrel>>=
char	invrel[12] =
{
    OEQ, ONE, OGE, OHS, OGT, OHI, OLE, OLS, OLT, OLO,
};
@

<<global logrel>>=
char	logrel[12] =
{
    OEQ, ONE, OLS, OLS, OLO, OLO, OHS, OHS, OHI, OHI,
};
@







<<[[gopcode()]] switch opcode cases>>=
case OCASE:
case OEQ:
case ONE:
case OLT:
case OLE:
case OGE:
case OGT:
case OLO:
case OLS:
case OHS:
case OHI:
    a = ACMP;
    if(et == TFLOAT)
        a = ACMPF;
    else
    if(et == TDOUBLE || et == TVLONG)
        a = ACMPD;
    nextpc();
    p->as = a;
    naddr(f1, &p->from);
    if(a == ACMP && f1->op == OCONST && p->from.offset < 0 &&
        p->from.offset != 0x80000000) {
        p->as = ACMN;
        p->from.offset = -p->from.offset;
    }
    raddr(f2, p);
    switch(o) {
    case OEQ:
        a = ABEQ;
        break;
    case ONE:
        a = ABNE;
        break;
    case OLT:
        a = ABLT;
        /* ensure NaN comparison is always false */
        if(typefd[et] && !btrue)
            a = ABMI;
        break;
    case OLE:
        a = ABLE;
        if(typefd[et] && !btrue)
            a = ABLS;
        break;
    case OGE:
        a = ABGE;
        if(typefd[et] && btrue)
            a = ABPL;
        break;
    case OGT:
        a = ABGT;
        if(typefd[et] && btrue)
            a = ABHI;
        break;
    case OLO:
        a = ABLO;
        break;
    case OLS:
        a = ABLS;
        break;
    case OHS:
        a = ABHS;
        break;
    case OHI:
        a = ABHI;
        break;

    case OCASE:
        nextpc();
        p->as = ACASE;
        p->scond = 0x9;
        naddr(f2, &p->from);
        a = ABHI;
        break;
    }
    f1 = Z;
    f2 = Z;
    break;
@


\subsection{Assignments}

<<[[cgenrel()]] switch node kind cases>>=
case OAS:
    if(l->op == OBIT)
        goto bitas;
    if(l->addable >= INDEXED && l->complex < FNX) {
        if(nn != Z || r->addable < INDEXED) {
            if(r->complex >= FNX && nn == Z)
                regret(&nod, r);
            else
                regalloc(&nod, r, nn);
            cgen(r, &nod);
            gmove(&nod, l);
            if(nn != Z)
                gmove(&nod, nn);
            regfree(&nod);
        } else
            gmove(r, l);
        break;
    }
    if(l->complex >= r->complex) {
        reglcgen(&nod1, l, Z);
        if(r->addable >= INDEXED) {
            gmove(r, &nod1);
            if(nn != Z)
                gmove(r, nn);
            regfree(&nod1);
            break;
        }
        regalloc(&nod, r, nn);
        cgen(r, &nod);
    } else {
        regalloc(&nod, r, nn);
        cgen(r, &nod);
        reglcgen(&nod1, l, Z);
    }
    gmove(&nod, &nod1);
    regfree(&nod);
    regfree(&nod1);
    break;
@

<<[[gopcode()]] switch opcode cases>>=
case OAS:
    gmove(f1, t);
    return;
@
% it's a return here! it shortcircuit what gopcode normally does




<<function reglcgen(arm)>>=
void
reglcgen(Node *t, Node *n, Node *nn)
{
    Node *r;
    long v;

    regialloc(t, n, nn);
    if(n->op == OIND) {
        r = n->left;
        while(r->op == OADD)
            r = r->right;
        if(sconst(r) && (v = r->vconst+t->xoffset) > -4096 && v < 4096) {
            v = r->vconst;
            r->vconst = 0;
            lcgen(n, t);
            t->xoffset += v;
            r->vconst = v;
            regind(t, n);
            return;
        }
    } else if(n->op == OINDREG) {
        if((v = n->xoffset) > -4096 && v < 4096) {
            n->op = OREGISTER;
            cgen(n, t);
            t->xoffset += v;
            n->op = OINDREG;
            regind(t, n);
            return;
        }
    }
    lcgen(n, t);
    regind(t, n);
}
@
% quite similar to the 386, but with some variations





% lvalue code generator?
<<function lcgen(arm)>>=
void
lcgen(Node *n, Node *nn)
{
    Prog *p1;
    Node nod;

    if(debug['g']) {
        prtree(nn, "lcgen lhs");
        prtree(n, "lcgen");
    }
    if(n == Z || n->type == T)
        return;
    if(nn == Z) {
        nn = &nod;
        regalloc(&nod, n, Z);
    }
    switch(n->op) {
    case OCOMMA:
        cgen(n->left, n->left);
        lcgen(n->right, nn);
        break;

    case OIND:
        cgen(n->left, nn);
        break;

    case OCOND:
        bcgen(n->left, 1);
        p1 = p;
        lcgen(n->right->left, nn);
        gbranch(OGOTO);
        patch(p1, pc);
        p1 = p;
        lcgen(n->right->right, nn);
        patch(p1, pc);
        break;

    default:
        if(n->addable < INDEXED) {
            diag(n, "unknown op in lcgen: %O", n->op);
            break;
        }
        nod = *n;
        nod.op = OADDR;
        nod.left = n;
        nod.right = Z;
        nod.type = types[TIND];
        gopcode(OAS, &nod, Z, nn);
        break;

    }
}
@
% diff with 386 is that default case is just:
%        gopcode(OADDR, n->type, n, nn);
% so maybe could actually factorize



<<function sconst(arm)>>=
bool
sconst(Node *n)
{
    vlong vv;

    if(n->op == OCONST) {
        if(!typefd[n->type->etype]) {
            vv = n->vconst;
            if(vv >= (vlong)(-32766) && vv < (vlong)32766)
                return true;
            /*
             * should be specialised for constant values which will
             * fit in different instructionsl; for now, let 5l
             * sort it out
             */
            return true;
        }
    }
    return false;
}
@


%\subsection{Assignments and arithmetic}

<<[[cgenrel()]] switch node kind cases>>=
case OASLSHR:
case OASASHL:
case OASASHR:
case OASAND:
case OASADD:
case OASSUB:
case OASXOR:
case OASOR:
    if(l->op == OBIT)
        goto asbitop;
    if(r->op == OCONST)
     if(!typefd[r->type->etype])
      if(!typefd[n->type->etype]) {
        if(l->addable < INDEXED)
            reglcgen(&nod2, l, Z);
        else
            nod2 = *l;
        regalloc(&nod, r, nn);
        gopcode(OAS, &nod2, Z, &nod);
        gopcode(o, r, Z, &nod);
        gopcode(OAS, &nod, Z, &nod2);

        regfree(&nod);
        if(l->addable < INDEXED)
            regfree(&nod2);
        break;
    }
    // Fallthrough
case OASLMUL:
case OASLDIV:
case OASLMOD:
case OASMUL:
case OASDIV:
case OASMOD:
    if(l->op == OBIT)
        goto asbitop;
    if(l->complex >= r->complex) {
        if(l->addable < INDEXED)
            reglcgen(&nod2, l, Z);
        else
            nod2 = *l;
        regalloc(&nod1, r, Z);
        cgen(r, &nod1);
    } else {
        regalloc(&nod1, r, Z);
        cgen(r, &nod1);
        if(l->addable < INDEXED)
            reglcgen(&nod2, l, Z);
        else
            nod2 = *l;
    }

    regalloc(&nod, n, nn);
    gmove(&nod2, &nod);
    gopcode(o, &nod1, Z, &nod);
    gmove(&nod, &nod2);
    if(nn != Z)
        gopcode(OAS, &nod, Z, nn);
    regfree(&nod);
    regfree(&nod1);
    if(l->addable < INDEXED)
        regfree(&nod2);
    break;
@


\subsection{Pointers}

% &x
<<[[cgenrel()]] switch node kind cases>>=
case OADDR:
    <<[[cgenrel()]] nullwarn check if nn is null, empty right>>
    lcgen(l, nn);
    break;
@

% *x

<<[[cgenrel()]] switch node kind cases>>=
case OIND:
    <<[[cgenrel()]] nullwarn check if nn is null, empty right>>
    regialloc(&nod, n, nn);
    r = l;
    while(r->op == OADD)
        r = r->right;
    if(sconst(r) && (v = r->vconst+nod.xoffset) > -4096 && v < 4096) {
        v = r->vconst;
        r->vconst = 0;
        cgen(l, &nod);
        nod.xoffset += v;
        r->vconst = v;
    } else
        cgen(l, &nod);
    regind(&nod, n);
    gopcode(OAS, &nod, Z, nn);
    regfree(&nod);
    break;
@

% register indirect alloc
<<function regialloc>>=
void
regialloc(Node *n, Node *tn, Node *o)
{
    Node nod;

    nod = *tn;
    nod.type = types[TIND];
    regalloc(n, &nod, o);
}
@

<<function regind>>=
void
regind(Node *n, Node *nn)
{

    if(n->op != OREGISTER) {
        diag(n, "regind not OREGISTER");
        return;
    }
    n->op = OINDREG;
    n->type = nn->type;
}
@


\subsection{Function calls}

<<[[cgenrel()]] switch node kind cases>>=
case OFUNC:
    if(l->complex >= FNX) {
        if(l->op != OIND)
            diag(n, "bad function call");

        regret(&nod, l->left);
        cgen(l->left, &nod);
        regsalloc(&nod1, l->left);
        gopcode(OAS, &nod, Z, &nod1);
        regfree(&nod);

        nod = *n;
        nod.left = &nod2;
        nod2 = *l;
        nod2.left = &nod1;
        nod2.complex = 1;
        cgen(&nod, nn);

        return;
    }
    <<[[cgenrel()]] OFUNC case, if use REGARG, part one>>
    gargs(r, &nod, &nod1);
    if(l->addable < INDEXED) {
        reglcgen(&nod, l, Z);
        gopcode(OFUNC, Z, Z, &nod);
        regfree(&nod);
    } else
        gopcode(OFUNC, Z, Z, l);
    <<[[cgenrel()]] OFUNC case, if use REGARG, part two>>
    if(nn != Z) {
        regret(&nod, n);
        gopcode(OAS, &nod, Z, nn);
        regfree(&nod);
    }
    break;
@

<<[[gopcode()]] switch opcode cases>>=
case OFUNC:
    a = ABL;
    break;
@


<<global nodsafe>>=
Node*	nodsafe;
@

<<[[ginit()]] special nodes initialisation>>=
nodsafe = new(ONAME, Z, Z);
nodsafe->sym = slookup(".safe");
nodsafe->type = types[TINT];
nodsafe->etype = types[TINT]->etype; // TINT
nodsafe->class = CAUTO;
complex(nodsafe);
@

<<function regsalloc>>=
void
regsalloc(Node *n, Node *nn)
{
    cursafe = align(cursafe, nn->type, Aaut3);
    maxargsafe = maxround(maxargsafe, cursafe+curarg);
    *n = *nodsafe;
    n->xoffset = -(stkoff + cursafe);
    n->type = nn->type;
    n->etype = nn->type->etype;
    n->lineno = nn->lineno;
}
@

\subsubsection{[[gargs()]]}
%????????

<<global cursafe>>=
long	cursafe;
@
% ???

<<global curarg>>=
long	curarg;
@

<<global maxargsafe>>=
long	maxargsafe;
@



<<[[codgen()]] initialisation>>=
cursafe = 0;
curarg = 0;
maxargsafe = 0;
@



<<function gargs>>=
void
gargs(Node *n, Node *tn1, Node *tn2)
{
    long regs;
    Node fnxargs[20], *fnxp;

    regs = cursafe;

    fnxp = fnxargs;
    garg1(n, tn1, tn2, 0, &fnxp);	/* compile fns to temps */

    curarg = 0;
    fnxp = fnxargs;
    garg1(n, tn1, tn2, 1, &fnxp);	/* compile normal args and temps */

    cursafe = regs;
}
@



<<function garg1(arm)>>=
void
garg1(Node *n, Node *tn1, Node *tn2, int f, Node **fnxp)
{
    Node nod;

    if(n == Z)
        return;
    if(n->op == OLIST) {
        garg1(n->left, tn1, tn2, f, fnxp);
        garg1(n->right, tn1, tn2, f, fnxp);
        return;
    } 

    if(f == 0) {
        if(n->complex >= FNX) {
            regsalloc(*fnxp, n);
            nod = znode;
            nod.op = OAS;
            nod.left = *fnxp;
            nod.right = n;
            nod.type = n->type;
            cgen(&nod, Z);
            (*fnxp)++;
        }
    } 
    else
    <<[[garg1()]] if complex argument type>>
    else
    <<[[garg1()]] if use REGARG and curarg is zero and simple type>>
    else {
        regalloc(tn1, n, Z);
        if(n->complex >= FNX) {
            cgen(*fnxp, tn1);
            (*fnxp)++;
        } else
            cgen(n, tn1);
        regaalloc(tn2, n);
        gopcode(OAS, tn1, Z, tn2);
        regfree(tn1);
    }
}
@
% rewrite as serie of if else instead of return?

<<after parsing nodes>>=
OINDREG,
@

<<function regaalloc(arm)>>=
void
regaalloc(Node *n, Node *nn)
{
    curarg = align(curarg, nn->type, Aarg1);
    *n = *nn;
    n->op = OINDREG;
    n->reg = REGSP;
    n->xoffset = curarg + SZ_LONG;
    n->complex = 0;
    n->addable = 20;
    curarg = align(curarg, nn->type, Aarg2);
    maxargsafe = maxround(maxargsafe, cursafe+curarg);
}
@
% 386 is just    n->xoffset = curarg;

<<[[naddr()]] switch node kind cases>>=
case OINDREG:
    a->type = D_OREG;
    a->sym = S;
    a->offset = n->xoffset;
    a->reg = n->reg;
    break;
@


\subsection{Array accesses}

% because unsugared to pointer arithmetic?

\subsection{Field accesses}

%pre: ODOT resolving has been done, transforming fieldname
% to constant. This is done in??
<<[[cgenrel()]] switch node kind cases>>=
case ODOT:
    sugen(l, nodrat, l->type->width);
    if(nn != Z) {
        warn(n, "non-interruptable temporary");
        nod = *nodrat;
        if(!r || r->op != OCONST) {
            diag(n, "DOT and no offset");
            break;
        }
        nod.xoffset += (long)r->vconst;
        nod.type = n->type;
        cgen(&nod, nn);
    }
    break;
@

<<global nodrat>>=
Node*	nodrat;
@

<<global symrathole>>=
Sym*	symrathole;
@

<<[[ginit()]] special nodes initialisation>>=
t = typ(TARRAY, types[TCHAR]);
symrathole = slookup(".rathole");
symrathole->class = CGLOBL;
symrathole->type = t;

nodrat = new(ONAME, Z, Z);
nodrat->sym = symrathole;
nodrat->type = types[TIND];
nodrat->etype = TVOID; // not TIND?
nodrat->class = CGLOBL;
complex(nodrat);
nodrat->type = t;
@

<<[[gclean()]] adjust symrathole width>>=
symrathole->type->width = nrathole;
@

<<global nrathole>>=
long	nrathole;
@

<<[[ginit()]] initialisation>>=
nrathole = 0;
@


<<function sugen(arm)>>=
void
sugen(Node *n, Node *nn, long w)
{
    Prog *p1;
    Node nod0, nod1, nod2, nod3, nod4, *l, *r;
    Type *t;
    long pc1;
    int i, m, c;

    if(n == Z || n->type == T)
        return;

    if(debug['g']) {
        prtree(nn, "sugen lhs");
        prtree(n, "sugen");
    }
    if(nn == nodrat)
        if(w > nrathole)
            nrathole = w;

    switch(n->op) {
    case OIND:
        if(nn == Z) {
            nullwarn(n->left, Z);
            break;
        }
    // Fallthrough

    default:
        goto copy;

    case OCONST:
        if(n->type && typev[n->type->etype]) {
            if(nn == Z) {
                nullwarn(n->left, Z);
                break;
            }

            t = nn->type;
            nn->type = types[TLONG];
            reglcgen(&nod1, nn, Z);
            nn->type = t;

            if(align(0, types[TCHAR], Aarg1))	/* isbigendian */
                gopcode(OAS, nod32const(n->vconst>>32), Z, &nod1);
            else
                gopcode(OAS, nod32const(n->vconst), Z, &nod1);
            nod1.xoffset += SZ_LONG;
            if(align(0, types[TCHAR], Aarg1))	/* isbigendian */
                gopcode(OAS, nod32const(n->vconst), Z, &nod1);
            else
                gopcode(OAS, nod32const(n->vconst>>32), Z, &nod1);

            regfree(&nod1);
            break;
        }
        goto copy;

    case ODOT:
        l = n->left;
        sugen(l, nodrat, l->type->width);
        if(nn != Z) {
            warn(n, "non-interruptable temporary");
            nod1 = *nodrat;
            r = n->right;
            if(!r || r->op != OCONST) {
                diag(n, "DOT and no offset");
                break;
            }
            nod1.xoffset += (long)r->vconst;
            nod1.type = n->type;
            sugen(&nod1, nn, w);
        }
        break;

    // struct constructor extension?
    case OSTRUCT:
        /*
         * rewrite so lhs has no fn call
         */
        if(nn != Z && nn->complex >= FNX) {
            nod1 = *n;
            nod1.type = typ(TIND, n->type);
            regret(&nod2, &nod1);
            lcgen(nn, &nod2);
            regsalloc(&nod0, &nod1);
            gopcode(OAS, &nod2, Z, &nod0);
            regfree(&nod2);

            nod1 = *n;
            nod1.op = OIND;
            nod1.left = &nod0;
            nod1.right = Z;
            nod1.complex = 1;

            sugen(n, &nod1, w);
            return;
        }

        r = n->left;
        for(t = n->type->link; t != T; t = t->down) {
            l = r;
            if(r->op == OLIST) {
                l = r->left;
                r = r->right;
            }
            if(nn == Z) {
                cgen(l, nn);
                continue;
            }
            /*
             * hand craft *(&nn + o) = l
             */
            nod0 = znode;
            nod0.op = OAS;
            nod0.type = t;
            nod0.left = &nod1;
            nod0.right = l;

            nod1 = znode;
            nod1.op = OIND;
            nod1.type = t;
            nod1.left = &nod2;

            nod2 = znode;
            nod2.op = OADD;
            nod2.type = typ(TIND, t);
            nod2.left = &nod3;
            nod2.right = &nod4;

            nod3 = znode;
            nod3.op = OADDR;
            nod3.type = nod2.type;
            nod3.left = nn;

            nod4 = znode;
            nod4.op = OCONST;
            nod4.type = nod2.type;
            nod4.vconst = t->offset;

            ccom(&nod0);
            acom(&nod0);
            xcom(&nod0);
            nod0.addable = 0;

            cgen(&nod0, Z);
        }
        break;

    case OAS:
        if(nn == Z) {
            if(n->addable < INDEXED)
                sugen(n->right, n->left, w);
            break;
        }
        sugen(n->right, nodrat, w);
        warn(n, "non-interruptable temporary");
        sugen(nodrat, n->left, w);
        sugen(nodrat, nn, w);
        break;

    case OFUNC:
        if(nn == Z) {
            sugen(n, nodrat, w);
            break;
        }
        if(nn->op != OIND) {
            nn = new1(OADDR, nn, Z);
            nn->type = types[TIND];
            nn->addable = 0;
        } else
            nn = nn->left;
        n = new(OFUNC, n->left, new(OLIST, nn, n->right));
        n->type = types[TVOID];
        n->left->type = types[TVOID];
        cgen(n, Z);
        break;

    case OCOND:
        bcgen(n->left, 1);
        p1 = p;
        sugen(n->right->left, nn, w);
        gbranch(OGOTO);
        patch(p1, pc);
        p1 = p;
        sugen(n->right->right, nn, w);
        patch(p1, pc);
        break;

    case OCOMMA:
        cgen(n->left, Z);
        sugen(n->right, nn, w);
        break;
    }
    return;

copy:
    if(nn == Z)
        return;
    if(n->complex >= FNX && nn->complex >= FNX) {
        t = nn->type;
        nn->type = types[TLONG];
        regialloc(&nod1, nn, Z);
        lcgen(nn, &nod1);
        regsalloc(&nod2, nn);
        nn->type = t;

        gopcode(OAS, &nod1, Z, &nod2);
        regfree(&nod1);

        nod2.type = typ(TIND, t);

        nod1 = nod2;
        nod1.op = OIND;
        nod1.left = &nod2;
        nod1.right = Z;
        nod1.complex = 1;
        nod1.type = t;

        sugen(n, &nod1, w);
        return;
    }

    w /= SZ_LONG;
    if(w <= 2) {
        if(n->complex > nn->complex) {
            reglpcgen(&nod1, n, 1);
            reglpcgen(&nod2, nn, 1);
        } else {
            reglpcgen(&nod2, nn, 1);
            reglpcgen(&nod1, n, 1);
        }
        regalloc(&nod3, &regnode, Z);
        regalloc(&nod4, &regnode, Z);
        if(nod3.reg > nod4.reg){
            /* code below assumes nod3 loaded first */
            Node t = nod3; nod3 = nod4; nod4 = t;
        }
        nod0 = *nodconst((1<<nod3.reg)|(1<<nod4.reg));
        if(w == 2 && nod1.xoffset == 0)
            gmovm(&nod1, &nod0, 0);
        else {
            gmove(&nod1, &nod3);
            if(w == 2) {
                nod1.xoffset += SZ_LONG;
                gmove(&nod1, &nod4);
            }
        }
        if(w == 2 && nod2.xoffset == 0)
            gmovm(&nod0, &nod2, 0);
        else {
            gmove(&nod3, &nod2);
            if(w == 2) {
                nod2.xoffset += SZ_LONG;
                gmove(&nod4, &nod2);
            }
        }
        regfree(&nod1);
        regfree(&nod2);
        regfree(&nod3);
        regfree(&nod4);
        return;
    }

    if(n->complex > nn->complex) {
        reglpcgen(&nod1, n, 0);
        reglpcgen(&nod2, nn, 0);
    } else {
        reglpcgen(&nod2, nn, 0);
        reglpcgen(&nod1, n, 0);
    }

    m = 0;
    for(c = 0; c < w && c < 4; c++) {
        i = tmpreg();
        if (i == 0)
            break;
        reg[i]++;
        m |= 1<<i;
    }
    nod4 = *(nodconst(m));
    if(w < 3*c) {
        for (; w>c; w-=c) {
            gmovm(&nod1, &nod4, 1);
            gmovm(&nod4, &nod2, 1);
        }
        goto out;
    }

    regalloc(&nod3, &regnode, Z);
    gopcode(OAS, nodconst(w/c), Z, &nod3);
    w %= c;
    
    pc1 = pc;
    gmovm(&nod1, &nod4, 1);
    gmovm(&nod4, &nod2, 1);

    gopcode(OSUB, nodconst(1), Z, &nod3);
    gopcode(OEQ, nodconst(0), &nod3, Z);
    p->as = ABGT;
    patch(p, pc1);
    regfree(&nod3);

out:
    if (w) {
        i = 0;
        while (c>w) {
            while ((m&(1<<i)) == 0)
                i++;
            m &= ~(1<<i);
            reg[i] = 0;
            c--;
            i++;
        }
        nod4.vconst = m;
        gmovm(&nod1, &nod4, 0);
        gmovm(&nod4, &nod2, 0);
    }
    i = 0;
    do {
        while ((m&(1<<i)) == 0)
            i++;
        reg[i] = 0;
        c--;
        i++;
    } while (c>0);
    regfree(&nod1);
    regfree(&nod2);
}
@
% >> >> >> >> >> >> >>



<<function gmovm(arm)>>=
void
gmovm(Node *f, Node *t, int w)
{
    gins(AMOVM, f, t);
    p->scond |= C_UBIT;
    if(w)
        p->scond |= C_WBIT;
}
@



<<function tmpreg(arm)>>=
int
tmpreg(void)
{
    int i;

    for(i=REGRET+1; i<NREG; i++)
        if(reg[i] == 0)
            return i;
    diag(Z, "out of fixed registers");
    return 0;
}
@


<<function reglpcgen(arm)>>=
void
reglpcgen(Node *n, Node *nn, int f)
{
    Type *t;

    t = nn->type;
    nn->type = types[TLONG];
    if(f)
        reglcgen(n, nn, Z);
    else {
        regialloc(n, nn, Z);
        lcgen(nn, n);
        regind(n, nn);
    }
    nn->type = t;
}
@



\subsection{Entity uses}

% this is ONAME! which will not be transformed by assembly generation
% phase; a C symbol is an assembly symbol! 
% The only thing is that ONAME is decorated with xoffset
% if it's a parameter or a local.

\subsection{Numeric constants}

% same, OCONST is kept as is.

\subsection{String constants}

\subsection{Cast}

<<[[cgenrel()]] switch node kind cases>>=
case OCAST:
    <<[[cgenrel()]] nullwarn check if nn is null, empty right>>
    /*
     * convert from types l->n->nn
     */
    if(nocast(l->type, n->type)) {
        if(nocast(n->type, nn->type)) {
            cgen(l, nn);
            break;
        }
    }
    regalloc(&nod, l, nn);
    cgen(l, &nod);
    regalloc(&nod1, n, &nod);
    if(inrel)
        gmover(&nod, &nod1);
    else
        gopcode(OAS, &nod, Z, &nod1);
    gopcode(OAS, &nod1, Z, nn);
    regfree(&nod1);
    regfree(&nod);
    break;
@

<<function gmover(arm)>>=
void
gmover(Node *f, Node *t)
{
    int ft, tt, a;

    ft = f->type->etype;
    tt = t->type->etype;
    a = AGOK;
    if(typechlp[ft] && typechlp[tt] && ewidth[ft] >= ewidth[tt]){
        switch(tt){
        case TSHORT:
            a = AMOVH;
            break;
        case TUSHORT:
            a = AMOVHU;
            break;
        case TCHAR:
            a = AMOVB;
            break;
        case TUCHAR:
            a = AMOVBU;
            break;
        }
    }
    if(a == AGOK)
        gmove(f, t);
    else
        gins(a, f, t);
}
@

% cgen -> cgenrel -> <>
<<function nocast>>=
/*
 * a cast that generates no code
 * (same size move)
 */
bool
nocast(Type *t1, Type *t2)
{
    int i, b;

    if(t1->nbits)
        return false;
    i = 0;
    if(t2 != T)
        i = t2->etype;
    b = 1<<i;
    i = 0;
    if(t1 != T)
        i = t1->etype;
    if(b & ncast[i])
        return true;
    return false;
}
@

%>>

<<global ncast>>=
long	ncast[NTYPE] =
{
    [TXXX] = 0,				
    [TCHAR] = BCHAR|BUCHAR,			
    [TUCHAR] = BCHAR|BUCHAR,			
    [TSHORT] = BSHORT|BUSHORT,			
    [TUSHORT] = BSHORT|BUSHORT,			
    [TINT] = BINT|BUINT|BLONG|BULONG|BIND,	
    [TUINT] = BINT|BUINT|BLONG|BULONG|BIND,	
    [TLONG] = BINT|BUINT|BLONG|BULONG|BIND,	
    [TULONG] = BINT|BUINT|BLONG|BULONG|BIND,	
    [TVLONG] = BVLONG|BUVLONG,			
    [TUVLONG] = BVLONG|BUVLONG,			
    [TFLOAT] = BFLOAT,				
    [TDOUBLE] = BDOUBLE,			
    [TIND] = BLONG|BULONG|BIND,		
    [TFUNC] = 0,				
    [TARRAY] = 0,				
    [TVOID] = 0,				
    [TSTRUCT] = BSTRUCT,			
    [TUNION] = BUNION,				
    [TENUM] = 0,				
};
@


\subsection{Ternary expressions}

<<[[cgenrel()]] switch node kind cases>>=
case OCOND:
    bcgen(l, true);
    p1 = p;
    cgen(r->left, nn);
    gbranch(OGOTO);
    patch(p1, pc);
    p1 = p;
    cgen(r->right, nn);
    patch(p1, pc);
    break;
@
% ??

\subsection{Prefix/postfix}

<<[[cgenrel()]] switch node kind cases>>=
case OPOSTINC:
case OPOSTDEC:
    v = 1;
    if(l->type->etype == TIND)
        v = l->type->link->width;
    if(o == OPOSTDEC)
        v = -v;
    if(l->op == OBIT)
        goto bitinc;
    if(nn == Z)
        goto pre;

    if(l->addable < INDEXED)
        reglcgen(&nod2, l, Z);
    else
        nod2 = *l;

    regalloc(&nod, l, nn);
    gopcode(OAS, &nod2, Z, &nod);
    regalloc(&nod1, l, Z);
    if(typefd[l->type->etype]) {
        regalloc(&nod3, l, Z);
        if(v < 0) {
            gopcode(OAS, nodfconst(-v), Z, &nod3);
            gopcode(OSUB, &nod3, &nod, &nod1);
        } else {
            gopcode(OAS, nodfconst(v), Z, &nod3);
            gopcode(OADD, &nod3, &nod, &nod1);
        }
        regfree(&nod3);
    } else
        gopcode(OADD, nodconst(v), &nod, &nod1);
    gopcode(OAS, &nod1, Z, &nod2);

    regfree(&nod);
    regfree(&nod1);
    if(l->addable < INDEXED)
        regfree(&nod2);
    break;
@
<<[[cgenrel()]] switch node kind cases>>=
case OPREINC:
case OPREDEC:
    v = 1;
    if(l->type->etype == TIND)
        v = l->type->link->width;
    if(o == OPREDEC)
        v = -v;
    if(l->op == OBIT)
        goto bitinc;

pre:
    if(l->addable < INDEXED)
        reglcgen(&nod2, l, Z);
    else
        nod2 = *l;

    regalloc(&nod, l, nn);
    gopcode(OAS, &nod2, Z, &nod);
    if(typefd[l->type->etype]) {
        regalloc(&nod3, l, Z);
        if(v < 0) {
            gopcode(OAS, nodfconst(-v), Z, &nod3);
            gopcode(OSUB, &nod3, Z, &nod);
        } else {
            gopcode(OAS, nodfconst(v), Z, &nod3);
            gopcode(OADD, &nod3, Z, &nod);
        }
        regfree(&nod3);
    } else
        gopcode(OADD, nodconst(v), Z, &nod);
    gopcode(OAS, &nod, Z, &nod2);
    if(nn && l->op == ONAME)	/* in x=++i, emit USED(i) */
        gins(ANOP, l, Z);

    regfree(&nod);
    if(l->addable < INDEXED)
        regfree(&nod2);
    break;
@



\subsection{[[sizeof()]]}

\section{XXX}


\subsection{The globals}

<<[[gclean()]] generate all AGLOBL pseudo opcodes>>=
for(i=0; i<NHASH; i++)
 for(s = hash[i]; s != S; s = s->link) {
    if(s->type == T)
        continue;
    if(s->type->width == 0)
        continue;
    if(s->class != CGLOBL && s->class != CSTATIC)
        continue;
    if(s->type == types[TENUM])
        continue;
    gpseudo(AGLOBL, s, nodconst(s->type->width));
}
@


\subsection{Multiplication}
% is this an optimisation? move?

% cgen -> cgenrel -> <>
<<function mulcon(arm)>>=
int
mulcon(Node *n, Node *nn)
{
    Node *l, *r, nod1, nod2;
    Multab *m;
    long v, vs;
    int o;
    char code[sizeof(m->code)+2], *p;

    if(typefd[n->type->etype])
        return 0;
    l = n->left;
    r = n->right;
    if(l->op == OCONST) {
        l = r;
        r = n->left;
    }
    if(r->op != OCONST)
        return 0;
    v = convvtox(r->vconst, n->type->etype);
    if(v != r->vconst) {
        if(debug['M'])
            print("%L multiply conv: %lld\n", n->lineno, r->vconst);
        return 0;
    }
    m = mulcon0(v);
    if(!m) {
        if(debug['M'])
            print("%L multiply table: %lld\n", n->lineno, r->vconst);
        return 0;
    }
    if(debug['M'] && debug['v'])
        print("%L multiply: %ld\n", n->lineno, v);

    memmove(code, m->code, sizeof(m->code));
    code[sizeof(m->code)] = 0;

    p = code;
    if(p[1] == 'i')
        p += 2;
    regalloc(&nod1, n, nn);
    cgen(l, &nod1);
    vs = v;
    regalloc(&nod2, n, Z);

loop:
    switch(*p) {
    case 0:
        regfree(&nod2);
        if(vs < 0) {
            gopcode(OAS, &nod1, Z, &nod1);
            gopcode(OSUB, &nod1, nodconst(0), nn);
        } else 
            gopcode(OAS, &nod1, Z, nn);
        regfree(&nod1);
        return 1;
    case '+':
        o = OADD;
        goto addsub;
    case '-':
        o = OSUB;
    addsub:	/* number is r,n,l */
        v = p[1] - '0';
        r = &nod1;
        if(v&4)
            r = &nod2;
        n = &nod1;
        if(v&2)
            n = &nod2;
        l = &nod1;
        if(v&1)
            l = &nod2;
        gopcode(o, l, n, r);
        break;
    default: /* op is shiftcount, number is r,l */
        v = p[1] - '0';
        r = &nod1;
        if(v&2)
            r = &nod2;
        l = &nod1;
        if(v&1)
            l = &nod2;
        v = *p - 'a';
        if(v < 0 || v >= 32) {
            diag(n, "mulcon unknown op: %c%c", p[0], p[1]);
            break;
        }
        gopcode(OASHL, nodconst(v), l, r);
        break;
    }
    p += 2;
    goto loop;
}
@



<<struct Multab(arm)>>=
struct	Multab
{
    long	val;
    char	code[20];
};
@

<<global multab(arm)>>=
Multab	multab[20];
@
% 386 has this global too, but the type is different


% in 5c/mul.c
%/*
% * code sequences for multiply by constant.
% * [a-l][0-3]
% *	lsl	$(A-'a'),r0,r1
% * [+][0-7]
% *	add	r0,r1,r2
% * [-][0-7]
% *	sub	r0,r1,r2
% */

<<global maxmulops(arm)>>=
static  int	maxmulops = 3;	/* max # of ops to replace mul with */
@
%$

<<global multabp(arm)>>=
static	int	multabp;
@

<<global mulval(arm)>>=
static	long	mulval;
@

<<global mulcp(arm)>>=
static	char*	mulcp;
@

<<global valmax(arm)>>=
static	long	valmax;
@

<<global shmax(arm)>>=
static	int	shmax;
@

<<enum _anon_ (5c/mul.c)(arm)>>=
enum
{
    SR1	= 1<<0,		/* r1 has been shifted */
    SR0	= 1<<1,		/* r0 has been shifted */
    UR1	= 1<<2,		/* r1 has not been used */
    UR0	= 1<<3,		/* r0 has not been used */
};
@
% >> >> >> >>

<<struct Hintab(arm)>>=
struct	Hintab
{
    ushort	val;
    char	hint[10];
};
@


<<function mulcon0(arm)>>=
Multab*
mulcon0(long v)
{
    int a1, a2, g;
    Multab *m, *m1;
    char hint[10];

    if(v < 0)
        v = -v;

    /*
     * look in cache
     */
    m = multab;
    for(g=0; g<nelem(multab); g++) {
        if(m->val == v) {
            if(m->code[0] == 0)
                return 0;
            return m;
        }
        m++;
    }

    /*
     * select a spot in cache to overwrite
     */
    multabp++;
    if(multabp < 0 || multabp >= nelem(multab))
        multabp = 0;
    m = multab+multabp;
    m->val = v;
    mulval = v;

    /*
     * look in execption hint table
     */
    a1 = 0;
    a2 = hintabsize;
    for(;;) {
        if(a1 >= a2)
            goto no;
        g = (a2 + a1)/2;
        if(v < hintab[g].val) {
            a2 = g;
            continue;
        }
        if(v > hintab[g].val) {
            a1 = g+1;
            continue;
        }
        break;
    }

    if(docode(hintab[g].hint, m->code, 1, 0))
        return m;
    print("multiply table failure %ld\n", v);
    m->code[0] = 0;
    return 0;

no:
    /*
     * try to search
     */
    hint[0] = 0;
    for(g=1; g<=maxmulops; g++) {
        if(g >= maxmulops && v >= 65535)
            break;
        mulcp = hint+g;
        *mulcp = 0;
        if(gen1(g)) {
            if(docode(hint, m->code, 1, 0))
                return m;
            print("multiply table failure %ld\n", v);
            break;
        }
    }

    /*
     * try a recur followed by a shift
     */
    g = 0;
    while(!(v & 1)) {
        g++;
        v >>= 1;
    }
    if(g) {
        m1 = mulcon0(v);
        if(m1) {
            strcpy(m->code, m1->code);
            sprint(strchr(m->code, 0), "%c0", g+'a');
            return m;
        }
    }
    m->code[0] = 0;
    return 0;
}
@

<<function docode(arm)>>=
static int
docode(char *hp, char *cp, int r0, int r1)
{
    int c, i;

    c = *hp++;
    *cp = c;
    cp += 2;
    switch(c) {
    default:
        c -= 'a';
        if(c < 1 || c >= 30)
            break;
        for(i=0; i<4; i++) {
            switch(i) {
            case 0:
                if(docode(hp, cp, r0<<c, r1))
                    goto out;
                break;
            case 1:
                if(docode(hp, cp, r1<<c, r1))
                    goto out;
                break;
            case 2:
                if(docode(hp, cp, r0, r0<<c))
                    goto out;
                break;
            case 3:
                if(docode(hp, cp, r0, r1<<c))
                    goto out;
                break;
            }
        }
        break;

    case '+':
        for(i=0; i<8; i++) {
            cp[-1] = i+'0';
            switch(i) {
            case 1:
                if(docode(hp, cp, r0+r1, r1))
                    goto out;
                break;
            case 5:
                if(docode(hp, cp, r0, r0+r1))
                    goto out;
                break;
            }
        }
        break;

    case '-':
        for(i=0; i<8; i++) {
            cp[-1] = i+'0';
            switch(i) {
            case 1:
                if(docode(hp, cp, r0-r1, r1))
                    goto out;
                break;
            case 2:
                if(docode(hp, cp, r1-r0, r1))
                    goto out;
                break;
            case 5:
                if(docode(hp, cp, r0, r0-r1))
                    goto out;
                break;
            case 6:
                if(docode(hp, cp, r0, r1-r0))
                    goto out;
                break;
            }
        }
        break;

    case 0:
        if(r0 == mulval)
            return 1;
    }
    return 0;

out:
    cp[-1] = i+'0';
    return 1;
}
@

<<function gen1(arm)>>=
static int
gen1(int len)
{
    int i;

    for(shmax=1; shmax<30; shmax++) {
        valmax = 1<<shmax;
        if(valmax >= mulval)
            break;
    }
    if(mulval == 1)
        return 1;

    len--;
    for(i=1; i<=shmax; i++)
        if(gen2(len, 1<<i)) {
            *--mulcp = 'a'+i;
            return 1;
        }
    return 0;
}
@

<<function gen2(arm)>>=
static int
gen2(int len, long r1)
{
    int i;

    if(len <= 0) {
        if(r1 == mulval)
            return 1;
        return 0;
    }

    len--;
    if(len == 0)
        goto calcr0;

    if(gen3(len, r1, r1+1, UR1)) {
        i = '+';
        goto out;
    }
    if(gen3(len, r1-1, r1, UR0)) {
        i = '-';
        goto out;
    }
    if(gen3(len, 1, r1+1, UR1)) {
        i = '+';
        goto out;
    }
    if(gen3(len, 1, r1-1, UR1)) {
        i = '-';
        goto out;
    }

    return 0;

calcr0:
    if(mulval == r1+1) {
        i = '+';
        goto out;
    }
    if(mulval == r1-1) {
        i = '-';
        goto out;
    }
    return 0;

out:
    *--mulcp = i;
    return 1;
}
@

<<function gen3(arm)>>=
static int
gen3(int len, long r0, long r1, int flag)
{
    int i, f1, f2;
    long x;

    if(r0 <= 0 ||
       r0 >= r1 ||
       r1 > valmax)
        return 0;

    len--;
    if(len == 0)
        goto calcr0;

    if(!(flag & UR1)) {
        f1 = UR1|SR1;
        for(i=1; i<=shmax; i++) {
            x = r0<<i;
            if(x > valmax)
                break;
            if(gen3(len, r0, x, f1)) {
                i += 'a';
                goto out;
            }
        }
    }

    if(!(flag & UR0)) {
        f1 = UR1|SR1;
        for(i=1; i<=shmax; i++) {
            x = r1<<i;
            if(x > valmax)
                break;
            if(gen3(len, r1, x, f1)) {
                i += 'a';
                goto out;
            }
        }
    }

    if(!(flag & SR1)) {
        f1 = UR1|SR1|(flag&UR0);
        for(i=1; i<=shmax; i++) {
            x = r1<<i;
            if(x > valmax)
                break;
            if(gen3(len, r0, x, f1)) {
                i += 'a';
                goto out;
            }
        }
    }

    if(!(flag & SR0)) {
        f1 = UR0|SR0|(flag&(SR1|UR1));

        f2 = UR1|SR1;
        if(flag & UR1)
            f2 |= UR0;
        if(flag & SR1)
            f2 |= SR0;

        for(i=1; i<=shmax; i++) {
            x = r0<<i;
            if(x > valmax)
                break;
            if(x > r1) {
                if(gen3(len, r1, x, f2)) {
                    i += 'a';
                    goto out;
                }
            } else
                if(gen3(len, x, r1, f1)) {
                    i += 'a';
                    goto out;
                }
        }
    }

    x = r1+r0;
    if(gen3(len, r0, x, UR1)) {
        i = '+';
        goto out;
    }

    if(gen3(len, r1, x, UR1)) {
        i = '+';
        goto out;
    }

    x = r1-r0;
    if(gen3(len, x, r1, UR0)) {
        i = '-';
        goto out;
    }

    if(x > r0) {
        if(gen3(len, r0, x, UR1)) {
            i = '-';
            goto out;
        }
    } else
        if(gen3(len, x, r0, UR0)) {
            i = '-';
            goto out;
        }

    return 0;

calcr0:
    f1 = flag & (UR0|UR1);
    if(f1 == UR1) {
        for(i=1; i<=shmax; i++) {
            x = r1<<i;
            if(x >= mulval) {
                if(x == mulval) {
                    i += 'a';
                    goto out;
                }
                break;
            }
        }
    }

    if(mulval == r1+r0) {
        i = '+';
        goto out;
    }
    if(mulval == r1-r0) {
        i = '-';
        goto out;
    }

    return 0;

out:
    *--mulcp = i;
    return 1;
}
@

<<global hintab(arm)>>=
/*
 * hint table has numbers that
 * the search algorithm fails on.
 * <1000:
 *	all numbers
 * <5000:
 * 	÷ by 5
 * <10000:
 * 	÷ by 50
 * <65536:
 * 	÷ by 250
 */
Hintab	hintab[] =
{
    683,	"b++d+e+",
    687,	"b+e++e-",
    691,	"b++d+e+",
    731,	"b++d+e+",
    811,	"b++d+i+",
    821,	"b++e+e+",
    843,	"b+d++e+",
    851,	"b+f-+e-",
    853,	"b++e+e+",
    877,	"c++++g-",
    933,	"b+c++g-",
    981,	"c-+e-d+",
    1375,	"b+c+b+h-",
    1675,	"d+b++h+",
    2425,	"c++f-e+",
    2675,	"c+d++f-",
    2750,	"b+d-b+h-",
    2775,	"c-+g-e-",
    3125,	"b++e+g+",
    3275,	"b+c+g+e+",
    3350,	"c++++i+",
    3475,	"c-+e-f-",
    3525,	"c-+d+g-",
    3625,	"c-+e-j+",
    3675,	"b+d+d+e+",
    3725,	"b+d-+h+",
    3925,	"b+d+f-d-",
    4275,	"b+g++e+",
    4325,	"b+h-+d+",
    4425,	"b+b+g-j-",
    4525,	"b+d-d+f+",
    4675,	"c++d-g+",
    4775,	"b+d+b+g-",
    4825,	"c+c-+i-",
    4850,	"c++++i-",
    4925,	"b++e-g-",
    4975,	"c+f++e-",
    5500,	"b+g-c+d+",
    6700,	"d+b++i+",
    9700,	"d++++j-",
    11000,	"b+f-c-h-",
    11750,	"b+d+g+j-",
    12500,	"b+c+e-k+",
    13250,	"b+d+e-f+",
    13750,	"b+h-c-d+",
    14250,	"b+g-c+e-",
    14500,	"c+f+j-d-",
    14750,	"d-g--f+",
    16750,	"b+e-d-n+",
    17750,	"c+h-b+e+",
    18250,	"d+b+h-d+",
    18750,	"b+g-++f+",
    19250,	"b+e+b+h+",
    19750,	"b++h--f-",
    20250,	"b+e-l-c+",
    20750,	"c++bi+e-",
    21250,	"b+i+l+c+",
    22000,	"b+e+d-g-",
    22250,	"b+d-h+k-",
    22750,	"b+d-e-g+",
    23250,	"b+c+h+e-",
    23500,	"b+g-c-g-",
    23750,	"b+g-b+h-",
    24250,	"c++g+m-",
    24750,	"b+e+e+j-",
    25000,	"b++dh+g+",
    25250,	"b+e+d-g-",
    25750,	"b+e+b+j+",
    26250,	"b+h+c+e+",
    26500,	"b+h+c+g+",
    26750,	"b+d+e+g-",
    27250,	"b+e+e+f+",
    27500,	"c-i-c-d+",
    27750,	"b+bd++j+",
    28250,	"d-d-++i-",
    28500,	"c+c-h-e-",
    29000,	"b+g-d-f+",
    29500,	"c+h+++e-",
    29750,	"b+g+f-c+",
    30250,	"b+f-g-c+",
    33500,	"c-f-d-n+",
    33750,	"b+d-b+j-",
    34250,	"c+e+++i+",
    35250,	"e+b+d+k+",
    35500,	"c+e+d-g-",
    35750,	"c+i-++e+",
    36250,	"b+bh-d+e+",
    36500,	"c+c-h-e-",
    36750,	"d+e--i+",
    37250,	"b+g+g+b+",
    37500,	"b+h-b+f+",
    37750,	"c+be++j-",
    38500,	"b+e+b+i+",
    38750,	"d+i-b+d+",
    39250,	"b+g-l-+d+",
    39500,	"b+g-c+g-",
    39750,	"b+bh-c+f-",
    40250,	"b+bf+d+g-",
    40500,	"b+g-c+g+",
    40750,	"c+b+i-e+",
    41250,	"d++bf+h+",
    41500,	"b+j+c+d-",
    41750,	"c+f+b+h-",
    42500,	"c+h++g+",
    42750,	"b+g+d-f-",
    43250,	"b+l-e+d-",
    43750,	"c+bd+h+f-",
    44000,	"b+f+g-d-",
    44250,	"b+d-g--f+",
    44500,	"c+e+c+h+",
    44750,	"b+e+d-h-",
    45250,	"b++g+j-g+",
    45500,	"c+d+e-g+",
    45750,	"b+d-h-e-",
    46250,	"c+bd++j+",
    46500,	"b+d-c-j-",
    46750,	"e-e-b+g-",
    47000,	"b+c+d-j-",
    47250,	"b+e+e-g-",
    47500,	"b+g-c-h-",
    47750,	"b+f-c+h-",
    48250,	"d--h+n-",
    48500,	"b+c-g+m-",
    48750,	"b+e+e-g+",
    49500,	"c-f+e+j-",
    49750,	"c+c+g++f-",
    50000,	"b+e+e+k+",
    50250,	"b++i++g+",
    50500,	"c+g+f-i+",
    50750,	"b+e+d+k-",
    51500,	"b+i+c-f+",
    51750,	"b+bd+g-e-",
    52250,	"b+d+g-j+",
    52500,	"c+c+f+g+",
    52750,	"b+c+e+i+",
    53000,	"b+i+c+g+",
    53500,	"c+g+g-n+",
    53750,	"b+j+d-c+",
    54250,	"b+d-g-j-",
    54500,	"c-f+e+f+",
    54750,	"b+f-+c+g+",
    55000,	"b+g-d-g-",
    55250,	"b+e+e+g+",
    55500,	"b+cd++j+",
    55750,	"b+bh-d-f-",
    56250,	"c+d-b+j-",
    56500,	"c+d+c+i+",
    56750,	"b+e+d++h-",
    57000,	"b+d+g-f+",
    57250,	"b+f-m+d-",
    57750,	"b+i+c+e-",
    58000,	"b+e+d+h+",
    58250,	"c+b+g+g+",
    58750,	"d-e-j--e+",
    59000,	"d-i-+e+",
    59250,	"e--h-m+",
    59500,	"c+c-h+f-",
    59750,	"b+bh-e+i-",
    60250,	"b+bh-e-e-",
    60500,	"c+c-g-g-",
    60750,	"b+e-l-e-",
    61250,	"b+g-g-c+",
    61750,	"b+g-c+g+",
    62250,	"f--+c-i-",
    62750,	"e+f--+g+",
    64750,	"b+f+d+p-",
};
@

<<global hintabsize (5c/mul.c)(arm)>>=
int	hintabsize	= nelem(hintab);
@

% dupe?
<<global hintabsize(arm)>>=
int	hintabsize;
@


\subsection{[[INDEXED]]}

<<constant INDEXED(arm)>>=
#define	INDEXED	9
@
% ???


<<[[cgenrel()]] if addable more than INDEXED>>=
if(n->addable >= INDEXED) {
    if(nn == Z) {
        switch(o) {
        default:
            nullwarn(Z, Z);
            break;
        case OINDEX:
            nullwarn(l, r);
            break;
        }
        return;
    }
    gmove(n, nn);
    return;
}
@

\subsection{[[FNX]]}

<<constant FNX(arm)>>=
#define	FNX		100
@
% ???

<<constant FNX>>=
/*
 * this is machine dependent, but it is totally
 * common on all of the 64-bit symulating machines.
 */

#define	FNX	100	/* botch -- redefinition */
@

<<[[cgenrel()]] if all complex fields more than FNX>>=
if(n->complex >= FNX)
 if(l->complex >= FNX)
  if(r != Z && r->complex >= FNX)
    switch(o) {
    case OFUNC:
    case OCOMMA:
    case OANDAND:
    case OOROR:
    case OCOND:
    case ODOT:
        break;
    
    default:
        regret(&nod, r);
        cgen(r, &nod);
    
        regsalloc(&nod1, r);
        gopcode(OAS, &nod, Z, &nod1);
    
        regfree(&nod);
        nod = *n;
        nod.right = &nod1;
        cgen(&nod, nn);
        return;
    
    }
@





\section{Sizes}

<<global ewidth>>=
schar	ewidth[NTYPE] =
{
    [TXXX] = -1,		
    [TCHAR] = SZ_CHAR,	
    [TUCHAR] = SZ_CHAR,	
    [TSHORT] = SZ_SHORT,	
    [TUSHORT] = SZ_SHORT,	
    [TINT] = SZ_INT,		
    [TUINT] = SZ_INT,		
    [TLONG] = SZ_LONG,	
    [TULONG] = SZ_LONG,	
    [TVLONG] = SZ_VLONG,	
    [TUVLONG] = SZ_VLONG,	
    [TFLOAT] = SZ_FLOAT,	
    [TDOUBLE] = SZ_DOUBLE,	
    [TIND] = SZ_IND,		
    [TFUNC] = 0,		
    [TARRAY] = -1,		
    [TVOID] = 0,		
    [TSTRUCT] = -1,		
    [TUNION] = -1,		
    [TENUM] = SZ_INT,		
};
@
%old: the designator used to be in comment, but then there is 
% a strong coupling with the enum order, and actually I got
% some regressions when I tried to reorder things in type_kind,
% so better to use a designator.
%cons? can be more complicated to bootstrap with other C compiler, but
% I don't care


<<constant SZ_CHAR(arm)>>=
#define	SZ_CHAR		1
@

<<constant SZ_SHORT(arm)>>=
#define	SZ_SHORT	2
@

<<constant SZ_INT(arm)>>=
#define	SZ_INT		4
@

<<constant SZ_LONG(arm)>>=
#define	SZ_LONG		4
@

<<constant SZ_IND(arm)>>=
#define	SZ_IND		4
@

<<constant SZ_FLOAT(arm)>>=
#define	SZ_FLOAT	4
@

<<constant SZ_VLONG(arm)>>=
#define	SZ_VLONG	8
@

<<constant SZ_DOUBLE(arm)>>=
#define	SZ_DOUBLE	8
@




\section{Alignment}

<<function align(arm)>>=
long
align(long i, Type *t, int op)
{
    long o;
    Type *v;
    int w;

    o = i;
    w = 1;
    switch(op) {
    default:
        diag(Z, "unknown align opcode %d", op);
        break;

    case Asu2:	/* padding at end of a struct */
        w = SZ_LONG;
        if(packflg)
            w = packflg;
        break;

    case Ael1:	/* initial align of struct element */
        for(v=t; v->etype==TARRAY; v=v->link)
            ;
        w = ewidth[v->etype];
        if(w <= 0 || w >= SZ_LONG)
            w = SZ_LONG;
        if(packflg)
            w = packflg;
        break;

    case Ael2:	/* width of a struct element */
        o += t->width;
        break;

    case Aarg0:	/* initial passbyptr argument in arg list */
        if(typesuv[t->etype]) {
            o = align(o, types[TIND], Aarg1);
            o = align(o, types[TIND], Aarg2);
        }
        break;

    case Aarg1:	/* initial align of parameter */
        w = ewidth[t->etype];
        if(w <= 0 || w >= SZ_LONG) {
            w = SZ_LONG;
            break;
        }
        w = 1;		/* little endian no adjustment */
        break;

    case Aarg2:	/* width of a parameter */
        o += t->width;
        w = SZ_LONG;
        break;

    case Aaut3:	/* total align of automatic */
        o = align(o, t, Ael2);
        o = align(o, t, Ael1);
        w = SZ_LONG;	/* because of a pun in cc/dcl.c:contig() */
        break;
    }
    o = round(o, w);
    if(debug['A'])
        print("align %s %ld %T = %ld\n", bnames[op], i, t, o);
    return o;
}
@
% mostly identical to 386 except for Aaut3 case, not sure why

<<function maxround>>=
long
maxround(long max, long v)
{
    v = round(v, SZ_LONG);
    if(v > max)
        return v;
    return max;
}
@




<<enum align>>=
enum align
{
    Axxx,

    Ael1,
    Ael2,
    Asu2,
    Aarg0,
    Aarg1,
    Aarg2,
    Aaut3,

    NALIGN,
};
@

<<global bnames>>=
char*	bnames[NALIGN];
@

<<global bnamesinit>>=
Init	bnamesinit[] =
{
    Axxx,	0,	"Axxx",

    Ael1,	0,	"el1",
    Ael2,	0,	"el2",
    Asu2,	0,	"su2",
    Aarg0,	0,	"arg0",
    Aarg1,	0,	"arg1",
    Aarg2,	0,	"arg2",
    Aaut3,	0,	"aut3",
    -1,	0,	0,
};
@



% called for fields of structures/unions

<<[[Type]] code generation fields>>=
long	offset;
@


% complex rule for struct/union definition -> <>
<<function sualign>>=
//@Scheck: not dead, used by cc.y
void sualign(Type *t)
{
    Type *l;
    long o, w;

    o = 0;
    switch(t->etype) {

    case TSTRUCT:
        t->offset = 0;
        w = 0;
        for(l = t->link; l != T; l = l->down) {
            if(l->nbits) {
                if(l->shift <= 0) {
                    l->shift = -l->shift;
                    w = round(w, tfield->width);
                    o = w;
                    w += tfield->width;
                }
                l->offset = o;
            } else {
                if(l->width < 0 ||
                   l->width == 0 && l->down != T)
                    if(l->sym)
                        diag(Z, "incomplete structure element: %s",
                            l->sym->name);
                    else
                        diag(Z, "incomplete structure element");
                w = align(w, l, Ael1);
                l->offset = w;
                w = align(w, l, Ael2);
            }
        }
        w = align(w, t, Asu2);
        t->width = w;
        acidtype(t);
        pickletype(t);
        return;

    case TUNION:
        t->offset = 0;
        w = 0;
        for(l = t->link; l != T; l = l->down) {
            if(l->width <= 0)
                if(l->sym)
                    diag(Z, "incomplete union element: %s",
                        l->sym->name);
                else
                    diag(Z, "incomplete union element");
            l->offset = 0;
            l->shift = 0;
            o = align(align(0, l, Ael1), l, Ael2);
            if(o > w)
                w = o;
        }
        w = align(w, t, Asu2);
        t->width = w;
        acidtype(t);
        pickletype(t);
        return;

    default:
        diag(Z, "unknown type in sualign: %T", t);
        break;
    }
}
@






\chapter{Object Generation}
% Dupe with Assembler.nw. Quite simple.

% 5c -S

% coupling with 5.out.h, autogenerated via mkenam script
<<global anames(arm)>>=
char*	anames[] =
{
    "XXX",
    "NOP",
    "AND",
    "ORR",
    "EOR",
    "BIC",
    "ADD",
    "SUB",
    "RSB",
    "ADC",
    "SBC",
    "RSC",
    "MUL",
    "DIV",
    "MOD",
    "MULL",
    "MULAL",
    "MULLU",
    "MULALU",
    "MULA",
    "MULU",
    "DIVU",
    "MODU",
    "SRL",
    "SRA",
    "SLL",
    "TST",
    "TEQ",
    "CMP",
    "CMN",
    "B",
    "BL",
    "BEQ",
    "BNE",
    "BHS",
    "BLO",
    "BMI",
    "BPL",
    "BVS",
    "BVC",
    "BHI",
    "BLS",
    "BGE",
    "BLT",
    "BGT",
    "BLE",
    "RET",
    "MOVW",
    "MOVB",
    "MOVBU",
    "MOVH",
    "MOVHU",
    "MVN",
    "MOVM",
    "SWPW",
    "SWPBU",
    "SWI",
    "RFE",
    "MOVWD",
    "MOVWF",
    "MOVDW",
    "MOVFW",
    "MOVFD",
    "MOVDF",
    "MOVF",
    "MOVD",
    "CMPF",
    "CMPD",
    "ADDF",
    "ADDD",
    "SUBF",
    "SUBD",
    "MULF",
    "MULD",
    "DIVF",
    "DIVD",
    "SQRTF",
    "SQRTD",
    "TEXT",
    "GLOBL",
    "DATA",
    "WORD",
    "END",
    "NAME",
    "HISTORY",
    "CASE",
    "BCASE",
    "SIGNAME",
    "GOK",
    "DYNT",
    "INIT",
    "LAST",
};
@


\section{Object format}

\section{Instruction output, [[outcode()]]}

<<struct Htab>>=
struct Htab { 
    Sym *sym; 
    short type; 
};
@

<<[[Sym]] identifier value, code generation fields>>=
// index in h when the Sym is really a symbol, 0 when not a symbol
char	symidx;
@

% main -> compile -> yyparse; gclean -> <>
%less: do LP split like I did in Assembler.nw
<<function outcode(arm)>>=
void
outcode(void)
{
    struct Htab h[NSYM];
    Prog *p;
    Sym *s;
    int sf, st, t, sym;

    if(debug['S']) {
        for(p = firstp; p != P; p = p->link)
            if(p->as != ADATA && p->as != AGLOBL)
                pc--;
        for(p = firstp; p != P; p = p->link) {
            print("%P\n", p);
            if(p->as != ADATA && p->as != AGLOBL)
                pc++;
        }
    }
    outhist(&outbuf);
    for(sym=0; sym<NSYM; sym++) {
        h[sym].sym = S;
        h[sym].type = 0;
    }
    sym = 1;
    for(p = firstp; p != P; p = p->link) {
    jackpot:
        sf = 0;
        s = p->from.sym;
        while(s != S) {
            sf = s->symidx;
            if(sf < 0 || sf >= NSYM)
                sf = 0;
            t = p->from.symkind;
            if(h[sf].type == t)
            if(h[sf].sym == s)
                break;
            s->symidx = sym;
            zname(&outbuf, s, t);
            h[sym].sym = s;
            h[sym].type = t;
            sf = sym;
            sym++;
            if(sym >= NSYM)
                sym = 1;
            break;
        }
        st = 0;
        s = p->to.sym;
        while(s != S) {
            st = s->symidx;
            if(st < 0 || st >= NSYM)
                st = 0;
            t = p->to.symkind;
            if(h[st].type == t)
            if(h[st].sym == s)
                break;
            s->symidx = sym;
            zname(&outbuf, s, t);
            h[sym].sym = s;
            h[sym].type = t;
            st = sym;
            sym++;
            if(sym >= NSYM)
                sym = 1;
            if(st == sf)
                goto jackpot;
            break;
        }
        zwrite(&outbuf, p, sf, st);
    }
    firstp = P;
    lastp = P;
}
@

<<function zwrite(arm)>>=
void
zwrite(Biobuf *b, Prog *p, int sf, int st)
{
    char bf[100], *bp;

    bf[0] = p->as;
    bf[1] = p->scond;
    bf[2] = p->reg;
    bf[3] = p->lineno;
    bf[4] = p->lineno>>8;
    bf[5] = p->lineno>>16;
    bf[6] = p->lineno>>24;
    bp = zaddr(bf+7, &p->from, sf);
    bp = zaddr(bp, &p->to, st);
    Bwrite(b, bf, bp-bf);
}
@


\section{Operand output, [[zaddr()]]}


<<function zaddr(arm)>>=
char*
zaddr(char *bp, Adr *a, int s)
{
    long l;
    Ieee e;

    bp[0] = a->type;
    bp[1] = a->reg;
    bp[2] = s;
    bp[3] = a->symkind;
    bp += 4;
    switch(a->type) {
    default:
        diag(Z, "unknown type %d in zaddr", a->type);

    case D_NONE:
    case D_REG:
    case D_FREG:
    case D_PSR:
        break;

    case D_OREG:
    case D_CONST:
    case D_BRANCH:
    case D_SHIFT:
        l = a->offset;
        bp[0] = l;
        bp[1] = l>>8;
        bp[2] = l>>16;
        bp[3] = l>>24;
        bp += 4;
        break;

    case D_SCONST:
        memmove(bp, a->sval, NSNAME);
        bp += NSNAME;
        break;

    case D_FCONST:
        ieeedtod(&e, a->dval);
        l = e.l;
        bp[0] = l;
        bp[1] = l>>8;
        bp[2] = l>>16;
        bp[3] = l>>24;
        bp += 4;
        l = e.h;
        bp[0] = l;
        bp[1] = l>>8;
        bp[2] = l>>16;
        bp[3] = l>>24;
        bp += 4;
        break;
    }
    return bp;
}
@




\section{Symbol table, [[zname()]], [[h]] and [[ANAME]]}
% spreaded
% and SIGNAME!




<<function zname(arm)>>=
void
zname(Biobuf *b, Sym *s, int t)
{
    char *n, bf[7];
    ulong sig;

    n = s->name;
    <<[[zname()]] if generate signature for symbol s>>
    else{
        bf[0] = ANAME;
        bf[1] = t;	/* type */
        bf[2] = s->symidx;	/* sym */
        Bwrite(b, bf, 3);
    }
    Bwrite(b, n, strlen(n)+1);
}
@


\section{File and line information, [[outhist()]]}



<<function outhist(arm)>>=
void
outhist(Biobuf *b)
{
    Hist *h;
    char *p, *q, *op, c;
    Prog pg;
    int n;

    pg = zprog;
    pg.as = AHISTORY;
    c = pathchar();
    for(h = hist; h != H; h = h->link) {
        p = h->name;
        op = 0;
        /* on windows skip drive specifier in pathname */
        //if(systemtype(Windows) && p && p[1] == ':'){
        //	p += 2;
        //	c = *p;
        //}
        if(p && p[0] != c && h->offset == 0 && pathname){
            /* on windows skip drive specifier in pathname */
            //if(systemtype(Windows) && pathname[1] == ':') {
            //	op = p;
            //	p = pathname+2;
            //	c = *p;
            //} else 
            if(pathname[0] == c){
                op = p;
                p = pathname;
            }
        }
        while(p) {
            q = utfrune(p, c);
            if(q) {
                n = q-p;
                if(n == 0){
                    n = 1;	/* leading "/" */
                    *p = '/';	/* don't emit "\" on windows */
                }
                q++;
            } else {
                n = strlen(p);
                q = 0;
            }
            if(n) {
                Bputc(b, ANAME);
                Bputc(b, D_FILE);
                Bputc(b, 1);
                Bputc(b, '<');
                Bwrite(b, p, n);
                Bputc(b, 0);
            }
            p = q;
            if(p == 0 && op) {
                p = op;
                op = 0;
            }
        }
        pg.lineno = h->line;
        pg.to.type = zprog.to.type;
        pg.to.offset = h->offset;
        if(h->offset)
            pg.to.type = D_CONST;

        zwrite(b, &pg, 0, 0);
    }
}
@





\chapter{Checking}

% normally do checking just after parsing, but in 5c
% it's really the code generation that then triggers some checks
% so simpler to see Checking after code generation.

\section{Overview}

% - symbol resolution, use/def matching correctly, lookup failure
%   with scoping rules, via Decl and symbol table (and .h so have
%   all declarations in one file)
%   and also def/def matching correctly by checking for wrong
%   redeclaration in xdecl
% - typechecking rules
% - lint rules (e.g. unused vars/labels, unused param, dead code, etc)

% a few warn() seen before, 
%  - in lexer: sign-extended char? truncated constant?
%  - in grammar: 
%     * empty body of if (empty then, empty else)
%  - in ast builder helper: 
%     * CAST in initialization ignored?? 
%     * initialize pointer to an integer?
%     * duplicated keywords for storage or qualifier or type
%       overspecified class? just say static?
%     * negative (or not constant) size for an array.

% a few later:
%  - div by zero in evconst()

\section{Printing warnings, [[5c -w]], [[5c -W]]}
% also -X

% 5c -w
% 5c -W give full verbose diagnostic

<<function warn>>=
void
warn(Node *n, char *fmt, ...)
{
    char buf[STRINGSZ];
    va_list arg;

    if(debug['w'] || debug['W']) {
        va_start(arg, fmt);
        vseprint(buf, buf+sizeof(buf), fmt, arg);
        va_end(arg);

        if(debug['W']) {
            diag(n, "%s", buf);
            return;
        }

        Bprint(&diagbuf, "warning: %L %s\n", 
                 (n==Z) ? nearln : n->lineno, buf);

        if(n != Z)
          if(debug['v'])
            prtree(n, "warning");
    }
}
@

<<function fatal>>=
void
fatal(Node *n, char *fmt, ...)
{
    char buf[STRINGSZ];
    va_list arg;

    va_start(arg, fmt);
    vseprint(buf, buf+sizeof(buf), fmt, arg);
    va_end(arg);
    Bprint(&diagbuf, "%L %s\n", 
              (n==Z)? nearln: n->lineno, buf);

    if(debug['X']){
        Bflush(&diagbuf);
        abort();
    }
    if(n != Z)
      if(debug['v'])
        prtree(n, "diagnostic");

    nerrors++;
    errorexit();
}
@

\section{Symbol resolution}

% Done in parsing, as C force to forward decl everything and have huge .h
% (and actual linking is done in linker to find inconsistencies).
% All the information is in the global symbol table.

% Warn when symbol not found before, or (ugly) implicitly
% declare it.

\section{Scoping resolution}

% See Decl section and markdcl() and revertdecl().
% see also the Sym.block and Sym.sublock fields

\section{Type checking}

\subsection{Overview}

% remember type field in Node!

% some concepts:
% - balancing = make each type match for operands, so int+long => long+long
%   and so imply some form of promotion

% in many of the functions below, the boolean return value
% true means that there was a typechecking error.

\subsection{Set of types constants, [[typexxx[]]]}

<<global typei>>=
// set<type_kind>
char	typei[NTYPE];
@
%less: char -> bool?

<<global typeiinit>>=
int	typeiinit[] =
{
    TCHAR, TUCHAR, TSHORT, TUSHORT, TINT, TUINT, TLONG, TULONG, TVLONG, TUVLONG, -1,
};
@

<<global typeu>>=
char	typeu[NTYPE];
@
<<global typeuinit>>=
int	typeuinit[] =
{
    TUCHAR, TUSHORT, TUINT, TULONG, TUVLONG, TIND, -1,
};
@



<<global typeilp>>=
char	typeilp[NTYPE];
@
<<global typeilpinit>>=
int	typeilpinit[] =
{
    TINT, TUINT, TLONG, TULONG, TIND, -1
};
@
% ilp, int long pointer


<<global typechlp>>=
char	typechlp[NTYPE];
@
<<global typechlpinit>>=
int	typechlpinit[] =
{
    TCHAR, TUCHAR, TSHORT, TUSHORT, TINT, TUINT, TLONG, TULONG, TIND, -1,
};
@
% added TIND!


<<global typechlpfd>>=
char	typechlpfd[NTYPE];
@

<<global typechlpfdinit>>=
int	typechlpfdinit[] =
{
    TCHAR, TUCHAR, TSHORT, TUSHORT, TINT, TUINT, TLONG, TULONG, TFLOAT, TDOUBLE, TIND, -1,
};
@


<<global typec>>=
char	typec[NTYPE];
@
<<global typecinit>>=
int	typecinit[] =
{
    TCHAR, TUCHAR, -1
};
@

<<global typechl>>=
char	typechl[NTYPE];
@
<<global typechlinit>>=
int	typechlinit[] =
{
    TCHAR, TUCHAR, TSHORT, TUSHORT, TINT, TUINT, TLONG, TULONG, -1,
};
@


<<global typeh>>=
char	typeh[NTYPE];
@
<<global typehinit>>=
int	typehinit[] =
{
    TSHORT, TUSHORT, -1,
};
@

<<global typeil>>=
char	typeil[NTYPE];
@
<<global typeilinit>>=
int	typeilinit[] =
{
    TINT, TUINT, TLONG, TULONG, -1,
};
@



<<global typev>>=
char	typev[NTYPE];
@
% very long
<<global typevinit>>=
int	typevinit[] =
{
    TVLONG,	TUVLONG, -1,
};
@



<<global typefd>>=
char	typefd[NTYPE];
@
<<global typefdinit>>=
int	typefdinit[] =
{
    TFLOAT, TDOUBLE, -1,
};
@



<<global typeaf>>=
char	typeaf[NTYPE];
@
<<global typeafinit>>=
int	typeafinit[] =
{
    TFUNC, TARRAY, -1,
};
@




<<global typesu>>=
char	typesu[NTYPE];
@
<<global typesuinit>>=
int	typesuinit[] =
{
    TSTRUCT, TUNION, -1,
};
@

<<global typesuv>>=
char	typesuv[NTYPE];
@

<<global typesuvinit>>=
int	typesuvinit[] =
{
    TVLONG, TUVLONG, TSTRUCT, TUNION, -1,
};
@
% suv is for arguments or return values that are too big to
% reside in REGRET in which case it needs some special handling



<<global typechlv>>=
char	typechlv[NTYPE];
@
% comes from a few xxxinit,
<<global typechlvp>>=
char typechlvp[NTYPE];
@



<<[[tinit()]] initialise typexxx type sets>>=
for(ip=typeiinit; *ip>=0; ip++) {
    urk("typei", nelem(typei), *ip);
    typei[*ip] = 1;
}
for(ip=typeuinit; *ip>=0; ip++) {
    urk("typeu", nelem(typeu), *ip);
    typeu[*ip] = 1;
}
for(ip=typesuvinit; *ip>=0; ip++) {
    urk("typesuv", nelem(typesuv), *ip);
    typesuv[*ip] = true;
}
for(ip=typeilpinit; *ip>=0; ip++) {
    urk("typeilp", nelem(typeilp), *ip);
    typeilp[*ip] = 1;
}
for(ip=typechlinit; *ip>=0; ip++) {
    urk("typechl", nelem(typechl), *ip);
    typechl[*ip] = 1;
    typechlv[*ip] = 1;
    typechlvp[*ip] = 1;
}
for(ip=typechlpinit; *ip>=0; ip++) {
    urk("typechlp", nelem(typechlp), *ip);
    typechlp[*ip] = 1;
    typechlvp[*ip] = 1;
}
for(ip=typechlpfdinit; *ip>=0; ip++) {
    urk("typechlpfd", nelem(typechlpfd), *ip);
    typechlpfd[*ip] = 1;
}
for(ip=typecinit; *ip>=0; ip++) {
    urk("typec", nelem(typec), *ip);
    typec[*ip] = 1;
}
for(ip=typehinit; *ip>=0; ip++) {
    urk("typeh", nelem(typeh), *ip);
    typeh[*ip] = 1;
}
for(ip=typeilinit; *ip>=0; ip++) {
    urk("typeil", nelem(typeil), *ip);
    typeil[*ip] = 1;
}
for(ip=typevinit; *ip>=0; ip++) {
    urk("typev", nelem(typev), *ip);
    typev[*ip] = 1;
    typechlv[*ip] = 1;
    typechlvp[*ip] = 1;
}
for(ip=typefdinit; *ip>=0; ip++) {
    urk("typefd", nelem(typefd), *ip);
    typefd[*ip] = 1;
}
for(ip=typeafinit; *ip>=0; ip++) {
    urk("typeaf", nelem(typeaf), *ip);
    typeaf[*ip] = 1;
}
for(ip=typesuinit; *ip >= 0; ip++) {
    urk("typesu", nelem(typesu), *ip);
    typesu[*ip] = 1;
}
@




% set of type supported for switch argument
% todo use array of bool instead
<<global typeswitch>>=
// set<type_kind>
char*	typeswitch;
@


<<[[tinit()]] initialise 32 bits defaults type sets>>=
typeswitch = typechl;
@



\subsection{Type compatibility, [[tcompat()]]}

% again returning true means actually they are not compatible and
% there is a type error
<<function tcompat>>=
bool
tcompat(Node *n, Type *t1, Type *t2, long ttab[])
{

    if(stcompat(n, t1, t2, ttab)) {
        if(t1 == T)
            diag(n, "incompatible type: \"%T\" for op \"%O\"",
                t2, n->op);
        else
            diag(n, "incompatible types: \"%T\" and \"%T\" for op \"%O\"",
                t1, t2, n->op);
        return true;
    }
    return false;
}
@


% this is silent, it does not generate error if there are not compatible.
<<function stcompat>>=
bool
stcompat(Node *n, Type *t1, Type *t2, long ttab[])
{
    int i;
    ulong b;

    i = 0;
    if(t2 != T)
        i = t2->etype;
    b = 1L << i;
    i = 0;
    if(t1 != T)
        i = t1->etype;
    if(b & ttab[i]) {
        if(ttab == tasign)
            if(b == BSTRUCT || b == BUNION)
                if(!sametype(t1, t2))
                    return true;
        if(n->op != OCAST)
          if(b == BIND && i == TIND)
                if(!sametype(t1, t2))
                    return true;
        return false;
    }
    return true;
}
@


<<function sametype>>=
bool
sametype(Type *t1, Type *t2)
{

    if(t1 == t2)
        return true;
    return rsametype(t1, t2, 5, true);
}
@

% n = depth? so equal modulo a certain depth?? hmmm
<<function rsametype>>=
bool
rsametype(Type *t1, Type *t2, int n, bool f)
{
    int et;

    n--;
    for(;;) {
        if(t1 == t2)
            return true;
        if(t1 == T || t2 == T)
            return false;
        if(n <= 0)
            return true;

        et = t1->etype;
        if(et != t2->etype)
            return false;

        if(et == TFUNC) {
            if(!rsametype(t1->link, t2->link, n, false))
                return false;
            t1 = t1->down;
            t2 = t2->down;
            while(t1 != T && t2 != T) {

                <<[[rsametype()]] continue if old style type>>

                while(t1 != T || t2 != T) {
                    if(!rsametype(t1, t2, n, false))
                        return false;
                    t1 = t1->down;
                    t2 = t2->down;
                }
                break;
            }
            return true;
        }
        if(et == TARRAY)
            if(t1->width != t2->width && t1->width != 0 && t2->width != 0)
                return false;
        if(typesu[et]) {
            if(t1->link == T)
                snap(t1);
            if(t2->link == T)
                snap(t2);
            if(t1 != t2 && t1->link == T && t2->link == T){
                /* structs with missing or different tag names aren't considered equal */
                if(t1->tag == nil || t2->tag == nil ||
                   strcmp(t1->tag->name, t2->tag->name) != 0)
                    return false;
            }
            t1 = t1->link;
            t2 = t2->link;
            for(;;) {
                if(t1 == t2)
                    return true;
                if(!rsametype(t1, t2, n, false))
                    return false;
                t1 = t1->down;
                t2 = t2->down;
            }
        }
        t1 = t1->link;
        t2 = t2->link;

        if((f || !debug['V']) && et == TIND) {
            if(t1 != T && t1->etype == TVOID)
                return true;
            if(t2 != T && t2->etype == TVOID)
                return true;
        }
    }
}
@

<<function snap>>=
void
snap(Type *t)
{
    if(typesu[t->etype])
     if(t->link == T && t->tag && t->tag->suetag) {
        t->link = t->tag->suetag->link;
        t->width = t->tag->suetag->width;
    }
}
@



<<enum bxxx constants>>=
BINTEGER	= BCHAR|BUCHAR|BSHORT|BUSHORT|BINT|BUINT|BLONG|BULONG|BVLONG|BUVLONG,
BNUMBER		= BINTEGER|BFLOAT|BDOUBLE,
@


% passed to tcompat
<<global tasign>>=
long	tasign[NTYPE];
@
<<global tasigninit>>=
Init	tasigninit[] =
{
    TCHAR,		BNUMBER,	0,
    TUCHAR,		BNUMBER,	0,
    TSHORT,		BNUMBER,	0,
    TUSHORT,	BNUMBER,	0,
    TINT,		BNUMBER,	0,
    TUINT,		BNUMBER,	0,
    TLONG,		BNUMBER,	0,
    TULONG,		BNUMBER,	0,
    TVLONG,		BNUMBER,	0,
    TUVLONG,	BNUMBER,	0,
    TFLOAT,		BNUMBER,	0,
    TDOUBLE,	BNUMBER,	0,
    TIND,		BIND,		0,
    TSTRUCT,	BSTRUCT,	0,
    TUNION,		BUNION,		0,
    -1,		0,		0,
};
@

<<global tasadd>>=
long	tasadd[NTYPE];
@
<<global tasaddinit>>=
Init	tasaddinit[] =
{
    TCHAR,		BNUMBER,	0,
    TUCHAR,		BNUMBER,	0,
    TSHORT,		BNUMBER,	0,
    TUSHORT,	BNUMBER,	0,
    TINT,		BNUMBER,	0,
    TUINT,		BNUMBER,	0,
    TLONG,		BNUMBER,	0,
    TULONG,		BNUMBER,	0,
    TVLONG,		BNUMBER,	0,
    TUVLONG,	BNUMBER,	0,
    TFLOAT,		BNUMBER,	0,
    TDOUBLE,	BNUMBER,	0,
    TIND,		BINTEGER,	0,
    -1,		0,		0,
};
@

<<global tcast>>=
long	tcast[NTYPE];
@
<<global tcastinit>>=
Init	tcastinit[] =
{
    TCHAR,		BNUMBER|BIND|BVOID,	0,
    TUCHAR,		BNUMBER|BIND|BVOID,	0,
    TSHORT,		BNUMBER|BIND|BVOID,	0,
    TUSHORT,	BNUMBER|BIND|BVOID,	0,
    TINT,		BNUMBER|BIND|BVOID,	0,
    TUINT,		BNUMBER|BIND|BVOID,	0,
    TLONG,		BNUMBER|BIND|BVOID,	0,
    TULONG,		BNUMBER|BIND|BVOID,	0,
    TVLONG,		BNUMBER|BIND|BVOID,	0,
    TUVLONG,	BNUMBER|BIND|BVOID,	0,
    TFLOAT,		BNUMBER|BVOID,		0,
    TDOUBLE,	BNUMBER|BVOID,		0,
    TIND,		BINTEGER|BIND|BVOID,	0,
    TVOID,		BVOID,			0,
    TSTRUCT,	BSTRUCT|BVOID,		0,
    TUNION,		BUNION|BVOID,		0,
    -1,		0,			0,
};
@

<<global tadd>>=
long	tadd[NTYPE];
@
<<global taddinit>>=
Init	taddinit[] =
{
    TCHAR,		BNUMBER|BIND,	0,
    TUCHAR,		BNUMBER|BIND,	0,
    TSHORT,		BNUMBER|BIND,	0,
    TUSHORT,	BNUMBER|BIND,	0,
    TINT,		BNUMBER|BIND,	0,
    TUINT,		BNUMBER|BIND,	0,
    TLONG,		BNUMBER|BIND,	0,
    TULONG,		BNUMBER|BIND,	0,
    TVLONG,		BNUMBER|BIND,	0,
    TUVLONG,	BNUMBER|BIND,	0,
    TFLOAT,		BNUMBER,	0,
    TDOUBLE,	BNUMBER,	0,
    TIND,		BINTEGER,	0,
    -1,		0,		0,
};
@

<<global tsub>>=
long	tsub[NTYPE];
@
<<global tsubinit>>=
Init	tsubinit[] =
{
    TCHAR,		BNUMBER,	0,
    TUCHAR,		BNUMBER,	0,
    TSHORT,		BNUMBER,	0,
    TUSHORT,	BNUMBER,	0,
    TINT,		BNUMBER,	0,
    TUINT,		BNUMBER,	0,
    TLONG,		BNUMBER,	0,
    TULONG,		BNUMBER,	0,
    TVLONG,		BNUMBER,	0,
    TUVLONG,	BNUMBER,	0,
    TFLOAT,		BNUMBER,	0,
    TDOUBLE,	BNUMBER,	0,
    TIND,		BINTEGER|BIND,	0,
    -1,		0,		0,
};
@

<<global tmul>>=
long	tmul[NTYPE];
@
<<global tmulinit>>=
Init	tmulinit[] =
{
    TCHAR,		BNUMBER,	0,
    TUCHAR,		BNUMBER,	0,
    TSHORT,		BNUMBER,	0,
    TUSHORT,	BNUMBER,	0,
    TINT,		BNUMBER,	0,
    TUINT,		BNUMBER,	0,
    TLONG,		BNUMBER,	0,
    TULONG,		BNUMBER,	0,
    TVLONG,		BNUMBER,	0,
    TUVLONG,	BNUMBER,	0,
    TFLOAT,		BNUMBER,	0,
    TDOUBLE,	BNUMBER,	0,
    -1,		0,		0,
};
@

<<global tand>>=
long	tand[NTYPE];
@
<<global tandinit>>=
Init	tandinit[] =
{
    TCHAR,		BINTEGER,	0,
    TUCHAR,		BINTEGER,	0,
    TSHORT,		BINTEGER,	0,
    TUSHORT,	BINTEGER,	0,
    TINT,		BNUMBER,	0,
    TUINT,		BNUMBER,	0,
    TLONG,		BINTEGER,	0,
    TULONG,		BINTEGER,	0,
    TVLONG,		BINTEGER,	0,
    TUVLONG,	BINTEGER,	0,
    -1,		0,		0,
};
@

<<global trel>>=
long	trel[NTYPE];
@
<<global trelinit>>=
Init	trelinit[] =
{
    TCHAR,		BNUMBER,	0,
    TUCHAR,		BNUMBER,	0,
    TSHORT,		BNUMBER,	0,
    TUSHORT,	BNUMBER,	0,
    TINT,		BNUMBER,	0,
    TUINT,		BNUMBER,	0,
    TLONG,		BNUMBER,	0,
    TULONG,		BNUMBER,	0,
    TVLONG,		BNUMBER,	0,
    TUVLONG,	BNUMBER,	0,
    TFLOAT,		BNUMBER,	0,
    TDOUBLE,	BNUMBER,	0,

    TIND,		BIND,		0,
    -1,		0,		0,
};
@

<<global tfunct>>=
long	tfunct[1] =
{
    BFUNC,
};
@

<<global tindir>>=
long	tindir[1] =
{
    BIND,
};
@

<<global tdot>>=
long	tdot[1] =
{
    BSTRUCT|BUNION,
};
@

<<global tnot>>=
long	tnot[1] =
{
    BNUMBER|BIND,
};
@

<<global targ>>=
long	targ[1] =
{
    BNUMBER|BIND|BSTRUCT|BUNION,
};
@



<<[[tinit()]] initialise tcompat arrays>>=
for(p=tasigninit; p->code >= 0; p++) {
    urk("tasign", nelem(tasign), p->code);
    tasign[p->code] = p->value;
}
for(p=tasaddinit; p->code >= 0; p++) {
    urk("tasadd", nelem(tasadd), p->code);
    tasadd[p->code] = p->value;
}
for(p=tcastinit; p->code >= 0; p++) {
    urk("tcast", nelem(tcast), p->code);
    tcast[p->code] = p->value;
}
for(p=taddinit; p->code >= 0; p++) {
    urk("tadd", nelem(tadd), p->code);
    tadd[p->code] = p->value;
}
for(p=tsubinit; p->code >= 0; p++) {
    urk("tsub", nelem(tsub), p->code);
    tsub[p->code] = p->value;
}
for(p=tmulinit; p->code >= 0; p++) {
    urk("tmul", nelem(tmul), p->code);
    tmul[p->code] = p->value;
}
for(p=tandinit; p->code >= 0; p++) {
    urk("tand", nelem(tand), p->code);
    tand[p->code] = p->value;
}
for(p=trelinit; p->code >= 0; p++) {
    urk("trel", nelem(trel), p->code);
    trel[p->code] = p->value;
}
@


\subsection{Type declarations consistency, [[tmerge()]]}
%Declaration and definition types merge

% dodectl(xdecl,...) -> xdecl -> <>
<<function tmerge>>=
void
tmerge(Type *t1, Sym *s)
{
    Type *ta, *tb, *t2;

    t2 = s->type;
/*print("merge	%T; %T\n", t1, t2);/**/
    for(;;) {
        if(t1 == T || t2 == T || t1 == t2)
            break;
        if(t1->etype != t2->etype)
            break;
        switch(t1->etype) {
        case TFUNC:
            ta = t1->down;
            tb = t2->down;
            if(ta == T) {
                t1->down = tb;
                break;
            }
            if(tb == T)
                break;
            while(ta != T && tb != T) {
                if(ta == tb)
                    break;
                /* ignore old-style flag */
                if(ta->etype == TOLD) {
                    ta = ta->down;
                    continue;
                }
                if(tb->etype == TOLD) {
                    tb = tb->down;
                    continue;
                }
                /* checking terminated by ... */
                if(ta->etype == TDOT && tb->etype == TDOT) {
                    ta = T;
                    tb = T;
                    break;
                }
                if(!sametype(ta, tb))
                    break;
                ta = ta->down;
                tb = tb->down;
            }
            if(ta != tb)
                diag(Z, "function inconsistently declared: %s", s->name);

            /* take new-style over old-style */
            ta = t1->down;
            tb = t2->down;
            if(ta != T && ta->etype == TOLD)
                if(tb != T && tb->etype != TOLD)
                    t1->down = tb;
            break;

        case TARRAY:
            /* should we check array size change? */
            if(t2->width > t1->width)
                t1->width = t2->width;
            break;

        case TUNION:
        case TSTRUCT:
            return;
        }
        t1 = t1->link;
        t2 = t2->link;
    }
}
@



\subsection{Expression typechecking, [[tcom()]]}
% cc/com.c


% true means error
<<function tcom>>=
/*
 * evaluate types
 * evaluate lvalues (addable == 1)
 */
bool
tcom(Node *n)
{

    return tcomo(n, ADDROF);
}
@
% also does a few transformations on the node:
%  - retag some nodes to be more explicit e.g. AMUL -> ALMUL
%  - add intermediate nodes for array and functions to
%    add OADDR node as passing  a function is really passing
%    the address of this function, and passing an array??
%  => make some sugar or implicits more explicits!

% for context in tcomo?
<<enum _anon_ (cc/com.c)>>=
enum
{
    ADDROF	= 1<<0,
    CASTOF	= 1<<1,
    ADDROP	= 1<<2,
};
@
% evaluate types means type checking and making cast explicits
% lvalue vs rvalue: https://www.itu.dk/courses/BPRD/E2009/fundamental-1967.pdf)
% (thx charles forsith)






% true means error
% f = context? ADDROF at the beginning
<<function tcomo>>=
bool
tcomo(Node *n, int f)
{
    Node *l, *r;
    Type *t;
    int o;
    static TRune zer;

    if(n == Z) {
        diag(Z, "Z in tcom");
        errorexit();
    }
    n->addable = 0;
    l = n->left;
    r = n->right;

    switch(n->op) {
    <<[[tcomo()]] switch node kind cases>>
    default:
        diag(n, "unknown op in type complex: %O", n->op);
        goto bad;

    }


    t = n->type;
    if(t == T)
        goto bad;
    if(t->width < 0) {
        snap(t);
        if(t->width < 0) {
            if(typesu[t->etype] && t->tag)
                diag(n, "structure not fully declared %s", t->tag->name);
            else
                diag(n, "structure not fully declared");
            goto bad;
        }
    }
    if(typeaf[t->etype]) {
        if(f & ADDROF)
            goto addaddr;
        if(f & ADDROP)
            warn(n, "address of array/func ignored");
    }
    return false;

addaddr:
    if(tlvalue(n))
        goto bad;
    l = new1(OXXX, Z, Z);
    *l = *n;
    n->op = OADDR;
    if(l->type->etype == TARRAY)
        l->type = l->type->link;
    n->left = l;
    n->right = Z;
    n->addable = 0;
    n->type = typ(TIND, l->type);
    n->type->width = types[TIND]->width;
    return false;

bad:
    n->type = T;
    return true;
}
@


<<[[tcomo()]] switch node kind cases>>=
case ODOTDOT:
    /*
     * tcom has already been called on this subtree
     */
    *n = *n->left;
    if(n->type == T)
        goto bad;
    break;
@

<<[[tcomo()]] switch node kind cases>>=
case OCAST:
    if(n->type == T)
        break;
    if(n->type->width == types[TLONG]->width) {
        if(tcomo(l, ADDROF|CASTOF))
            goto bad;
    } else
        if(tcom(l))
            goto bad;
    if(isfunct(n))
        break;
    if(tcompat(n, l->type, n->type, tcast))
        goto bad;
    break;
@

<<[[tcomo()]] switch node kind cases>>=
case ORETURN:
    if(l == Z) {
        if(n->type->etype != TVOID)
            warn(n, "null return of a typed function");
        break;
    }
    if(tcom(l))
        goto bad;
    typeext(n->type, l);
    if(tcompat(n, n->type, l->type, tasign))
        break;
    constas(n, n->type, l->type);
    if(!sametype(n->type, l->type)) {
        l = new1(OCAST, l, Z);
        l->type = n->type;
        n->left = l;
    }
    break;
@

<<[[tcomo()]] switch node kind cases>>=
case OASI:	/* same as as, but no test for const */
    n->op = OAS;
    o = tcom(l);
    if(o | tcom(r))
        goto bad;

    typeext(l->type, r);
    if(tlvalue(l) || tcompat(n, l->type, r->type, tasign))
        goto bad;
    if(!sametype(l->type, r->type)) {
        r = new1(OCAST, r, Z);
        r->type = l->type;
        n->right = r;
    }
    n->type = l->type;
    break;
@

<<[[tcomo()]] switch node kind cases>>=
case OAS:
    o = tcom(l);
    if(o | tcom(r))
        goto bad;
    if(tlvalue(l))
        goto bad;
    if(isfunct(n))
        break;
    typeext(l->type, r);
    if(tcompat(n, l->type, r->type, tasign))
        goto bad;
    constas(n, l->type, r->type);
    if(!sametype(l->type, r->type)) {
        r = new1(OCAST, r, Z);
        r->type = l->type;
        n->right = r;
    }
    n->type = l->type;
    break;
@

<<[[tcomo()]] switch node kind cases>>=
case OASADD:
case OASSUB:
    o = tcom(l);
    if(o | tcom(r))
        goto bad;
    if(tlvalue(l))
        goto bad;
    if(isfunct(n))
        break;
    typeext1(l->type, r);
    if(tcompat(n, l->type, r->type, tasadd))
        goto bad;
    constas(n, l->type, r->type);
    t = l->type;
    arith(n, 0);
    while(n->left->op == OCAST)
        n->left = n->left->left;
    if(!sametype(t, n->type) && !mixedasop(t, n->type)) {
        r = new1(OCAST, n->right, Z);
        r->type = t;
        n->right = r;
        n->type = t;
    }
    break;
@


<<after parsing nodes>>=
OASLMUL,
OASLDIV,
OASLMOD,
OASLSHR,
@
% typed long version?

<<[[tcomo()]] switch node kind cases>>=
case OASMUL:
case OASDIV:
case OASLMUL:
case OASLDIV:
    o = tcom(l);
    if(o | tcom(r))
        goto bad;
    if(tlvalue(l))
        goto bad;
    if(isfunct(n))
        break;
    typeext1(l->type, r);
    if(tcompat(n, l->type, r->type, tmul))
        goto bad;
    constas(n, l->type, r->type);
    t = l->type;
    arith(n, 0);
    while(n->left->op == OCAST)
        n->left = n->left->left;
    if(!sametype(t, n->type) && !mixedasop(t, n->type)) {
        r = new1(OCAST, n->right, Z);
        r->type = t;
        n->right = r;
        n->type = t;
    }
    if(typeu[n->type->etype]) {
        if(n->op == OASDIV)
            n->op = OASLDIV;
        if(n->op == OASMUL)
            n->op = OASLMUL;
    }
    break;
@


<<[[tcomo()]] switch node kind cases>>=
case OASLSHR:
case OASASHR:
case OASASHL:
    o = tcom(l);
    if(o | tcom(r))
        goto bad;
    if(tlvalue(l))
        goto bad;
    if(isfunct(n))
        break;
    if(tcompat(n, l->type, r->type, tand))
        goto bad;
    n->type = l->type;
    n->right = new1(OCAST, r, Z);
    n->right->type = types[TINT];
    if(typeu[n->type->etype]) {
        if(n->op == OASASHR)
            n->op = OASLSHR;
    }
    break;
@

<<[[tcomo()]] switch node kind cases>>=
case OASMOD:
case OASLMOD:
case OASOR:
case OASAND:
case OASXOR:
    o = tcom(l);
    if(o | tcom(r))
        goto bad;
    if(tlvalue(l))
        goto bad;
    if(isfunct(n))
        break;
    if(tcompat(n, l->type, r->type, tand))
        goto bad;
    t = l->type;
    arith(n, 0);
    while(n->left->op == OCAST)
        n->left = n->left->left;
    if(!sametype(t, n->type) && !mixedasop(t, n->type)) {
        r = new1(OCAST, n->right, Z);
        r->type = t;
        n->right = r;
        n->type = t;
    }
    if(typeu[n->type->etype]) {
        if(n->op == OASMOD)
            n->op = OASLMOD;
    }
    break;
@

<<[[tcomo()]] switch node kind cases>>=
case OPREINC:
case OPREDEC:
case OPOSTINC:
case OPOSTDEC:
    if(tcom(l))
        goto bad;
    if(tlvalue(l))
        goto bad;
    if(isfunct(n))
        break;
    if(tcompat(n, l->type, types[TINT], tadd))
        goto bad;
    n->type = l->type;
    if(n->type->etype == TIND)
    if(n->type->link->width < 1) {
        snap(n->type->link);
        if(n->type->link->width < 1)
            diag(n, "inc/dec of a void pointer");
    }
    break;
@
<<[[tcomo()]] switch node kind cases>>=
case OEQ:
case ONE:
    o = tcom(l);
    if(o | tcom(r))
        goto bad;
    if(isfunct(n))
        break;
    typeext(l->type, r);
    typeext(r->type, l);
    if(tcompat(n, l->type, r->type, trel))
        goto bad;
    arith(n, 0);
    n->type = types[TINT];
    break;
@
<<[[tcomo()]] switch node kind cases>>=
case OLT:
case OGE:
case OGT:
case OLE:
    o = tcom(l);
    if(o | tcom(r))
        goto bad;
    if(isfunct(n))
        break;
    typeext1(l->type, r);
    typeext1(r->type, l);
    if(tcompat(n, l->type, r->type, trel))
        goto bad;
    arith(n, 0);
    if(typeu[n->type->etype])
        n->op = logrel[relindex(n->op)];
    n->type = types[TINT];
    break;
@
<<[[tcomo()]] switch node kind cases>>=
case OCOND:
    o = tcom(l);
    o |= tcom(r->left);
    if(o | tcom(r->right))
        goto bad;
    if(r->right->type->etype == TIND && vconst(r->left) == 0) {
        r->left->type = r->right->type;
        r->left->vconst = 0;
    }
    if(r->left->type->etype == TIND && vconst(r->right) == 0) {
        r->right->type = r->left->type;
        r->right->vconst = 0;
    }
    if(sametype(r->right->type, r->left->type)) {
        r->type = r->right->type;
        n->type = r->type;
        break;
    }
    if(tcompat(r, r->left->type, r->right->type, trel))
        goto bad;
    arith(r, 0);
    n->type = r->type;
    break;
@

<<[[tcomo()]] switch node kind cases>>=
case OADD:
    o = tcom(l);
    if(o | tcom(r))
        goto bad;
    if(isfunct(n))
        break;
    if(tcompat(n, l->type, r->type, tadd))
        goto bad;
    arith(n, 1);
    break;
@
<<[[tcomo()]] switch node kind cases>>=
case OSUB:
    o = tcom(l);
    if(o | tcom(r))
        goto bad;
    if(isfunct(n))
        break;
    if(tcompat(n, l->type, r->type, tsub))
        goto bad;
    arith(n, 1);
    break;
@

<<after parsing nodes>>=
OLMUL,
OLDIV,
OLMOD,
OLSHR,
@

<<[[tcomo()]] switch node kind cases>>=
case OMUL:
case ODIV:
case OLMUL:
case OLDIV:
    o = tcom(l);
    if(o | tcom(r))
        goto bad;
    if(isfunct(n))
        break;
    if(tcompat(n, l->type, r->type, tmul))
        goto bad;
    arith(n, 1);
    if(typeu[n->type->etype]) {
        if(n->op == ODIV)
            n->op = OLDIV;
        if(n->op == OMUL)
            n->op = OLMUL;
    }
    break;
@

<<[[tcomo()]] switch node kind cases>>=
case OLSHR:
case OASHL:
case OASHR:
    o = tcom(l);
    if(o | tcom(r))
        goto bad;
    if(isfunct(n))
        break;
    if(tcompat(n, l->type, r->type, tand))
        goto bad;
    n->right = Z;
    arith(n, 1);
    n->right = new1(OCAST, r, Z);
    n->right->type = types[TINT];
    if(typeu[n->type->etype])
        if(n->op == OASHR)
            n->op = OLSHR;
    break;
@
<<[[tcomo()]] switch node kind cases>>=
case OAND:
case OOR:
case OXOR:
    o = tcom(l);
    if(o | tcom(r))
        goto bad;
    if(isfunct(n))
        break;
    if(tcompat(n, l->type, r->type, tand))
        goto bad;
    arith(n, 1);
    break;
@
<<[[tcomo()]] switch node kind cases>>=
case OMOD:
case OLMOD:
    o = tcom(l);
    if(o | tcom(r))
        goto bad;
    if(isfunct(n))
        break;
    if(tcompat(n, l->type, r->type, tand))
        goto bad;
    arith(n, 1);
    if(typeu[n->type->etype])
        n->op = OLMOD;
    break;
@
<<[[tcomo()]] switch node kind cases>>=
case OPOS:
    if(tcom(l))
        goto bad;
    if(isfunct(n))
        break;

    r = l;
    l = new(OCONST, Z, Z);
    l->vconst = 0;
    l->type = types[TINT];
    n->op = OADD;
    n->right = r;
    n->left = l;

    if(tcom(l))
        goto bad;
    if(tcompat(n, l->type, r->type, tsub))
        goto bad;
    arith(n, 1);
    break;
@
<<[[tcomo()]] switch node kind cases>>=
case ONEG:
    if(tcom(l))
        goto bad;
    if(isfunct(n))
        break;

    if(!machcap(n)) {
        r = l;
        l = new(OCONST, Z, Z);
        l->vconst = 0;
        l->type = types[TINT];
        n->op = OSUB;
        n->right = r;
        n->left = l;

        if(tcom(l))
            goto bad;
        if(tcompat(n, l->type, r->type, tsub))
            goto bad;
    }
    arith(n, 1);
    break;
@
<<[[tcomo()]] switch node kind cases>>=
case OCOM:
    if(tcom(l))
        goto bad;
    if(isfunct(n))
        break;

    if(!machcap(n)) {
        r = l;
        l = new(OCONST, Z, Z);
        l->vconst = -1;
        l->type = types[TINT];
        n->op = OXOR;
        n->right = r;
        n->left = l;

        if(tcom(l))
            goto bad;
        if(tcompat(n, l->type, r->type, tand))
            goto bad;
    }
    arith(n, 1);
    break;
@
<<[[tcomo()]] switch node kind cases>>=
case ONOT:
    if(tcom(l))
        goto bad;
    if(isfunct(n))
        break;
    if(tcompat(n, T, l->type, tnot))
        goto bad;
    n->type = types[TINT];
    break;
@
<<[[tcomo()]] switch node kind cases>>=
case OANDAND:
case OOROR:
    o = tcom(l);
    if(o | tcom(r))
        goto bad;
    if(tcompat(n, T, l->type, tnot) |
       tcompat(n, T, r->type, tnot))
        goto bad;
    n->type = types[TINT];
    break;
@
<<[[tcomo()]] switch node kind cases>>=
case OCOMMA:
    o = tcom(l);
    if(o | tcom(r))
        goto bad;
    n->type = r->type;
    break;
@

<<[[tcomo()]] switch node kind cases>>=
case OSIZE:
    if(l != Z) {
        if(l->op != OSTRING && l->op != OLSTRING)
            if(tcomo(l, 0))
                goto bad;
        if(l->op == OBIT) {
            diag(n, "sizeof bitfield");
            goto bad;
        }
        n->type = l->type;
    }
    if(n->type == T)
        goto bad;
    if(n->type->width <= 0) {
        diag(n, "sizeof undefined type");
        goto bad;
    }
    if(n->type->etype == TFUNC) {
        diag(n, "sizeof function");
        goto bad;
    }
    n->op = OCONST;
    n->left = Z;
    n->right = Z;
    n->vconst = convvtox(n->type->width, TINT);
    n->type = types[TINT];
    break;
@
<<[[tcomo()]] switch node kind cases>>=
case OFUNC:
    o = tcomo(l, 0);
    if(o)
        goto bad;
    if(l->type->etype == TIND && l->type->link->etype == TFUNC) {
        l = new1(OIND, l, Z);
        l->type = l->left->type->link;
        n->left = l;
    }
    if(tcompat(n, T, l->type, tfunct))
        goto bad;
    if(o | tcoma(l, r, l->type->down, 1))
        goto bad;
    n->type = l->type->link;
    if(!debug['B'])
        if(l->type->down == T || l->type->down->etype == TOLD) {
            nerrors--;
            diag(n, "function args not checked: %F", l);
        }
    dpcheck(n);
    break;
@
<<[[tcomo()]] switch node kind cases>>=
case ONAME:
    if(n->type == T) {
        diag(n, "name not declared: %F", n);
        goto bad;
    }
    if(n->type->etype == TENUM) {
        n->op = OCONST;
        n->type = n->sym->tenum;
        if(!typefd[n->type->etype])
            n->vconst = n->sym->vconst;
        else
            n->fconst = n->sym->fconst;
        break;
    }
    n->addable = 1;
    if(n->class == CEXREG) {
        n->op = OREGISTER;
        if(thechar == '8')
            n->op = OEXREG;
        n->reg = n->sym->offset;
        n->xoffset = 0;
        break;
    }
    break;
@


<<[[tcomo()]] switch node kind cases>>=
case OLSTRING:
    if(n->type->link != types[TRUNE]) {
        o = outstring(0, 0);
        while(o & 3) {
            outlstring(&zer, sizeof(TRune));
            o = outlstring(0, 0);
        }
    }
    n->op = ONAME;
    n->xoffset = outlstring(n->rstring, n->type->width);
    n->addable = 1;
    break;
@

<<[[tcomo()]] switch node kind cases>>=
case OSTRING:
    if(n->type->link != types[TCHAR]) {
        o = outstring(0, 0);
        while(o & 3) {
            outstring("", 1);
            o = outstring(0, 0);
        }
    }
    n->op = ONAME;
    n->xoffset = outstring(n->cstring, n->type->width);
    n->addable = 1;
    break;
@


<<global symstring>>=
Sym*	symstring;
@

<<[[cinit()]] symstring initialization>>=
t = typ(TARRAY, types[TCHAR]);
t->width = 0;
symstring = slookup(".string");
symstring->class = CSTATIC;
symstring->type = t;
@


<<global nstring>>=
long	nstring;
@

<<[[ginit()]] initialisation>>=
nstring = 0;
mnstring = 0;
@

<<[[gclean()]] adjust symstring width>>=
while(mnstring)
    outstring("", 1L);
symstring->type->width = nstring;
@


<<function outlstring>>=
long
outlstring(TRune *s, long n)
{
    char buf[sizeof(TRune)];
    uint c;
    int i;
    long r;

    if(suppress)
        return nstring;
    while(nstring & (sizeof(TRune)-1))
        outstring("", 1);
    r = nstring;
    while(n > 0) {
        c = *s++;
        if(align(0, types[TCHAR], Aarg1)) {
            for(i = 0; i < sizeof(TRune); i++)
                buf[i] = c>>(8*(sizeof(TRune) - i - 1));
        } else {
            for(i = 0; i < sizeof(TRune); i++)
                buf[i] = c>>(8*i);
        }
        outstring(buf, sizeof(TRune));
        n -= sizeof(TRune);
    }
    return r;
}
@

<<global mnstring>>=
int	mnstring;
@

<<global string>>=
char	string[NSNAME];
@


<<function outstring(arm)>>=
long
outstring(char *s, long n)
{
    long r;

    if(suppress)
        return nstring;
    r = nstring;
    while(n) {
        string[mnstring] = *s++;
        mnstring++;
        nstring++;
        if(mnstring >= NSNAME) {
            gpseudo(ADATA, symstring, nodconst(0L));
            p->from.offset += nstring - NSNAME;
            p->reg = NSNAME;
            p->to.type = D_SCONST;
            memmove(p->to.sval, string, NSNAME);
            mnstring = 0;
        }
        n--;
    }
    return r;
}
@
% 386 diff is jsut p->reg -->  p->from.scale = NSNAME;



<<[[tcomo()]] switch node kind cases>>=
case OCONST:
    break;
@
<<[[tcomo()]] switch node kind cases>>=
case ODOT:
    if(tcom(l))
        goto bad;
    if(tcompat(n, T, l->type, tdot))
        goto bad;
    if(tcomd(n))
        goto bad;
    break;
@
<<[[tcomo()]] switch node kind cases>>=
case OADDR:
    if(tcomo(l, ADDROP))
        goto bad;
    if(tlvalue(l))
        goto bad;
    if(l->type->nbits) {
        diag(n, "address of a bit field");
        goto bad;
    }
    if(l->op == OREGISTER) {
        diag(n, "address of a register");
        goto bad;
    }
    n->type = typ(TIND, l->type);
    n->type->width = types[TIND]->width;
    break;
@

<<[[tcomo()]] switch node kind cases>>=
case OIND:
    if(tcom(l))
        goto bad;
    if(tcompat(n, T, l->type, tindir))
        goto bad;
    n->type = l->type->link;
    n->addable = 1;
    break;
@






<<[[Type]] other fields>>=
Funct*	funct;
@
% ????

<<struct Funct>>=
struct	Funct
{
    Sym*	sym[OEND];
    Sym*	castto[NTYPE];
    Sym*	castfr[NTYPE];
};
@

<<function isfunct>>=
bool
isfunct(Node *n)
{
    Type *t, *t1;
    Funct *f;
    Node *l;
    Sym *s;
    int o;

    o = n->op;
    if(n->left == Z)
        goto no;
    t = n->left->type;
    if(t == T)
        goto no;
    f = t->funct;

    switch(o) {
    case OAS:	// put cast on rhs
    case OASI:
    case OASADD:
    case OASSUB:
    case OASMUL:
    case OASDIV:
    case OASMOD:
    case OASASHR:
    case OASLMUL:
    case OASLDIV:
    case OASLMOD:
    case OASLSHR:
    case OASASHL:
    case OASAND:
    case OASOR:
    case OASXOR:
        if(n->right == Z)
            goto no;
        t1 = n->right->type;
        if(t1 == T)
            goto no;
        if(t1->funct == f)
            break;

        l = new(OXXX, Z, Z);
        *l = *n->right;

        n->right->left = l;
        n->right->right = Z;
        n->right->type = t;
        n->right->op = OCAST;

        if(!isfunct(n->right))
            prtree(n, "isfunc !");
        break;

    case OCAST:	// t f(T) or T f(t)
        t1 = n->type;
        if(t1 == T)
            goto no;
        if(f != nil) {
            s = f->castfr[t1->etype];
            if(s == S)
                goto no;
            n->right = n->left;
            goto build;
        }
        f = t1->funct;
        if(f != nil) {
            s = f->castto[t->etype];
            if(s == S)
                goto no;
            n->right = n->left;
            goto build;
        }
        goto no;
    }

    if(f == nil)
        goto no;
    s = f->sym[o];
    if(s == S)
        goto no;



    /*
     * the answer is yes,
     * now we rewrite the node
     * and give diagnostics
     */
    switch(o) {
    case OADD:	// T f(T, T)
    case OAND:
    case OASHL:
    case OASHR:
    case ODIV:
    case OLDIV:
    case OLMOD:
    case OLMUL:
    case OLSHR:
    case OMOD:
    case OMUL:
    case OOR:
    case OSUB:
    case OXOR:

    case OEQ:	// int f(T, T)
    case OGE:
    case OGT:
    case OHI:
    case OHS:
    case OLE:
    case OLO:
    case OLS:
    case OLT:
    case ONE:
        if(n->right == Z)
            goto bad;
        t1 = n->right->type;
        if(t1 == T)
            goto bad;
        if(t1->funct != f)
            goto bad;
        n->right = new(OLIST, n->left, n->right);
        break;

    case OAS:	// structure copies done by the compiler
    case OASI:
        goto no;

    case OASADD:	// T f(T*, T)
    case OASAND:
    case OASASHL:
    case OASASHR:
    case OASDIV:
    case OASLDIV:
    case OASLMOD:
    case OASLMUL:
    case OASLSHR:
    case OASMOD:
    case OASMUL:
    case OASOR:
    case OASSUB:
    case OASXOR:
        if(n->right == Z)
            goto bad;
        t1 = n->right->type;
        if(t1 == T)
            goto bad;
        if(t1->funct != f)
            goto bad;
        n->right = new(OLIST, new(OADDR, n->left, Z), n->right);
        break;

    case OPOS:	// T f(T)
    case ONEG:
    case ONOT:
    case OCOM:
        n->right = n->left;
        break;

    default:
        diag(n, "isfunct op missing %O\n", o);
        goto bad;


    }

build:
    l = new(ONAME, Z, Z);
    l->sym = s;
    l->type = s->type;
    l->etype = s->type->etype;
    l->xoffset = s->offset;
    l->class = s->class;
    tcomo(l, 0);

    n->op = OFUNC;
    n->left = l;
    n->type = l->type->link;
    if(tcompat(n, T, l->type, tfunct))
        goto bad;
    if(tcoma(n->left, n->right, l->type->down, 1))
        goto bad;
    return true;

no:
    return false;

bad:
    diag(n, "cant rewrite typestr for op %O\n", o);
    prtree(n, "isfunct");
    n->type = T;
    return true;
}
@





<<function machcap(arm)>>=
/* default, like old cc */
bool
machcap(Node*)
{
    return false;
}
@
% the one in x86 is more complex


<<function mixedasop>>=
int
mixedasop(Type *l, Type *r)
{
    return !typefd[l->etype] && typefd[r->etype];
}
@


% usually called via if(tlvalue(x)) goto bad;
<<function tlvalue>>=
bool
tlvalue(Node *n)
{

    if(!n->addable) {
        diag(n, "not an l-value");
        return true;
    }
    return false;
}
@


<<function vconst>>=
int
vconst(Node *n)
{
    int i;

    if(n == Z)
        goto no;
    if(n->op != OCONST)
        goto no;
    if(n->type == T)
        goto no;

    switch(n->type->etype)
    {
    case TFLOAT:
    case TDOUBLE:
        i = 100;
        if(n->fconst > i || n->fconst < -i)
            goto no;
        i = n->fconst;
        if(i != n->fconst)
            goto no;
        return i;

    case TVLONG:
    case TUVLONG:
        i = n->vconst;
        if(i != n->vconst)
            goto no;
        return i;

    case TCHAR:
    case TUCHAR:
    case TSHORT:
    case TUSHORT:
    case TINT:
    case TUINT:
    case TLONG:
    case TULONG:
    case TIND:
        i = n->vconst;
        if(i != n->vconst)
            goto no;
        return i;
    }
no:
    return -159;	/* first uninteresting constant */
}
@
% ???? wtf?



<<function constas>>=
void
constas(Node *n, Type *il, Type *ir)
{
    Type *l, *r;

    l = il;
    r = ir;

    if(l == T)
        return;
    if(l->garb & GCONSTNT) {
        warn(n, "assignment to a constant type (%T)", il);
        return;
    }
    if(r == T)
        return;
    for(;;) {
        if(l->etype != TIND || r->etype != TIND)
            break;
        l = l->link;
        r = r->link;
        if(l == T || r == T)
            break;
        if(r->garb & GCONSTNT)
            if(!(l->garb & GCONSTNT)) {
                warn(n, "assignment of a constant pointer type (%T)", ir);
                break;
            }
    }
}
@






<<global nodproto>>=
Node*	nodproto;
@
% dead? or just here so that error message in stcompat
%  which access n->op have a valid n->op which is OPROTO?

<<[[cinit()]] nodproto initialization>>=
nodproto = new(OPROTO, Z, Z);
@
% could be a static local of tcoma?

<<function tcoma>>=
bool
tcoma(Node *l, Node *n, Type *t, int f)
{
    Node *n1;
    int o;

    if(t != T)
    if(t->etype == TOLD || t->etype == TDOT)	/* .../old in prototype */
        t = T;
    if(n == Z) {
        if(t != T && !sametype(t, types[TVOID])) {
            diag(n, "not enough function arguments: %F", l);
            return true;
        }
        return false;
    }
    if(n->op == OLIST) {
        o = tcoma(l, n->left, t, 0);
        if(t != T) {
            t = t->down;
            if(t == T)
                t = types[TVOID];
        }
        return o | tcoma(l, n->right, t, 1);
    }
    if(f && t != T)
        tcoma(l, Z, t->down, 0);
    if(tcom(n) || tcompat(n, T, n->type, targ))
        return true;
    if(sametype(t, types[TVOID])) {
        diag(n, "too many function arguments: %F", l);
        return true;
    }
    if(t != T) {
        typeext(t, n);
        if(stcompat(nodproto, t, n->type, tasign)) {
            diag(l, "argument prototype mismatch \"%T\" for \"%T\": %F",
                n->type, t, l);
            return true;
        }
        switch(t->etype) {
        case TCHAR:
        case TSHORT:
            t = types[TINT];
            break;

        case TUCHAR:
        case TUSHORT:
            t = types[TUINT];
            break;
        }
    } else
    switch(n->type->etype)
    {
    case TCHAR:
    case TSHORT:
        t = types[TINT];
        break;

    case TUCHAR:
    case TUSHORT:
        t = types[TUINT];
        break;

    case TFLOAT:
        t = types[TDOUBLE];
    }
    if(t != T && !sametype(t, n->type)) {
        n1 = new1(OXXX, Z, Z);
        *n1 = *n;
        n->op = OCAST;
        n->left = n1;
        n->right = Z;
        n->type = t;
        n->addable = 0;
    }
    return false;
}
@





% tcom ODOT
<<function tcomd>>=
bool
tcomd(Node *n)
{
    Type *t;
    long o;

    o = 0;
    t = dotsearch(n->sym, n->left->type->link, n, &o);
    if(t == T) {
        diag(n, "not a member of struct/union: %F", n);
        return true;
    }
    makedot(n, t, o);
    return false;
}
@

<<function dotsearch>>=
Type*
dotsearch(Sym *s, Type *t, Node *n, long *off)
{
    Type *t1, *xt, *rt;

    xt = T;

    /*
     * look it up by name
     */
    for(t1 = t; t1 != T; t1 = t1->down)
        if(t1->sym == s) {
            if(xt != T)
                goto ambig;
            xt = t1;
        }

    /*
     * look it up by type
     */
    if(s->class == CTYPEDEF || s->class == CTYPESTR)
        for(t1 = t; t1 != T; t1 = t1->down)
            if(t1->sym == S && typesu[t1->etype])
                if(sametype(s->type, t1)) {
                    if(xt != T)
                        goto ambig;
                    xt = t1;
                }
    if(xt != T) {
        *off = xt->offset;
        return xt;
    }

    /*
     * look it up in unnamed substructures
     */
    for(t1 = t; t1 != T; t1 = t1->down)
        if(t1->sym == S && typesu[t1->etype]){
            rt = dotsearch(s, t1->link, n, off);
            if(rt != T) {
                if(xt != T)
                    goto ambig;
                xt = rt;
                *off += t1->offset;
            }
        }
    return xt;

ambig:
    diag(n, "ambiguous structure element: %s", s->name);
    return xt;
}
@


<<function makedot>>=
void
makedot(Node *n, Type *t, long o)
{
    Node *n1, *n2;

    if(t->nbits) {
        n1 = new(OXXX, Z, Z);
        *n1 = *n;
        n->op = OBIT;
        n->left = n1;
        n->right = Z;
        n->type = t;
        n->addable = n1->left->addable;
        n = n1;
    }
    n->addable = n->left->addable;
    if(n->addable == 0) {
        n1 = new1(OCONST, Z, Z);
        n1->vconst = o;
        n1->type = types[TLONG];
        n->right = n1;
        n->type = t;
        return;
    }
    n->left->type = t;
    if(o == 0) {
        *n = *n->left;
        return;
    }
    n->type = t;
    n1 = new1(OCONST, Z, Z);
    n1->vconst = o;
    t = typ(TIND, t);
    t->width = types[TIND]->width;
    n1->type = t;

    n2 = new1(OADDR, n->left, Z);
    n2->type = t;

    n1 = new1(OADD, n1, n2);
    n1->type = t;

    n->op = OIND;
    n->left = n1;
    n->right = Z;
}
@






\subsection{Arithmetic conversions}

<<function arith>>=
/*
 * "the usual arithmetic conversions are performed"
 */
void
arith(Node *n, int f)
{
    Type *t1, *t2;
    int i, j, k;
    Node *n1;
    long w;

    t1 = n->left->type;
    if(n->right == Z)
        t2 = t1;
    else
        t2 = n->right->type;
    i = TXXX;
    if(t1 != T)
        i = t1->etype;
    j = TXXX;
    if(t2 != T)
        j = t2->etype;

    k = tab[i][j];

    if(k == TIND) {
        if(i == TIND)
            n->type = t1;
        else
        if(j == TIND)
            n->type = t2;
    } else {
        /* convert up to at least int */
        if(f == 1)
        while(k < TINT)
            k += 2;
        n->type = types[k];
    }
    if(n->op == OSUB)
    if(i == TIND && j == TIND) {
        w = n->right->type->link->width;
        if(w < 1 || n->left->type->link == T || n->left->type->link->width < 1)
            goto bad;
        n->type = types[ewidth[TIND] <= ewidth[TLONG]? TLONG: TVLONG];
        if(1 && ewidth[TIND] > ewidth[TLONG]){
            n1 = new1(OXXX, Z, Z);
            *n1 = *n;
            n->op = OCAST;
            n->left = n1;
            n->right = Z;
            n->type = types[TLONG];
        }
        if(w > 1) {
            n1 = new1(OXXX, Z, Z);
            *n1 = *n;
            n->op = ODIV;
            n->left = n1;
            n1 = new1(OCONST, Z, Z);
            n1->vconst = w;
            n1->type = n->type;
            n->right = n1;
            w = vlog(n1);
            if(w >= 0) {
                n->op = OASHR;
                n1->vconst = w;
            }
        }
        return;
    }
    if(!sametype(n->type, n->left->type)) {
        n->left = new1(OCAST, n->left, Z);
        n->left->type = n->type;
        if(n->type->etype == TIND) {
            w = n->type->link->width;
            if(w < 1) {
                snap(n->type->link);
                w = n->type->link->width;
                if(w < 1)
                    goto bad;
            }
            if(w > 1) {
                n1 = new1(OCONST, Z, Z);
                n1->vconst = w;
                n1->type = n->type;
                n->left = new1(OMUL, n->left, n1);
                n->left->type = n->type;
            }
        }
    }
    if(n->right != Z)
    if(!sametype(n->type, n->right->type)) {
        n->right = new1(OCAST, n->right, Z);
        n->right->type = n->type;
        if(n->type->etype == TIND) {
            w = n->type->link->width;
            if(w < 1) {
                snap(n->type->link);
                w = n->type->link->width;
                if(w < 1)
                    goto bad;
            }
            if(w != 1) {
                n1 = new1(OCONST, Z, Z);
                n1->vconst = w;
                n1->type = n->type;
                n->right = new1(OMUL, n->right, n1);
                n->right->type = n->type;
            }
        }
    }
    return;
bad:
    diag(n, "pointer addition not fully declared: %T", n->type->link);
}
@

<<function vlog>>=
int
vlog(Node *n)
{
    if(n->op != OCONST)
        goto bad;
    if(typefd[n->type->etype])
        goto bad;

    return log2(n->vconst);

bad:
    return -1;
}
@

%coupling: could use designator for the nested initialiser too,
% so less depdendencies on the order of the basic types
% (I use designator for TIND only right now)
<<global tab>>=
char	tab[NTYPE][NTYPE] =
{
  [TXXX] =	{ 0,
        },

  [TCHAR] =	{ 0,	TCHAR, TUCHAR, TSHORT, TUSHORT, TINT, TUINT, TLONG,
            TULONG, TVLONG, TUVLONG, TFLOAT, TDOUBLE, [TIND] = TIND,
        },
  [TUCHAR] =	{ 0,	TUCHAR, TUCHAR, TUSHORT, TUSHORT, TUINT, TUINT, TULONG,
            TULONG, TUVLONG, TUVLONG, TFLOAT, TDOUBLE, [TIND] = TIND,
        },
  [TSHORT] =	{ 0,	TSHORT, TUSHORT, TSHORT, TUSHORT, TINT, TUINT, TLONG,
            TULONG, TVLONG, TUVLONG, TFLOAT, TDOUBLE, [TIND] = TIND,
        },
  [TUSHORT] =	{ 0,	TUSHORT, TUSHORT, TUSHORT, TUSHORT, TUINT, TUINT, TULONG,
            TULONG, TUVLONG, TUVLONG, TFLOAT, TDOUBLE, [TIND] = TIND,
        },
  [TINT] =	{ 0,	TINT, TUINT, TINT, TUINT, TINT, TUINT, TLONG,
            TULONG, TVLONG, TUVLONG, TFLOAT, TDOUBLE, [TIND] = TIND,
        },
  [TUINT] =	{ 0,	TUINT, TUINT, TUINT, TUINT, TUINT, TUINT, TULONG,
            TULONG, TUVLONG, TUVLONG, TFLOAT, TDOUBLE, [TIND] = TIND,
        },
  [TLONG] =	{ 0,	TLONG, TULONG, TLONG, TULONG, TLONG, TULONG, TLONG,
            TULONG, TVLONG, TUVLONG, TFLOAT, TDOUBLE, [TIND] = TIND,
        },
  [TULONG] =	{ 0,	TULONG, TULONG, TULONG, TULONG, TULONG, TULONG, TULONG,
            TULONG, TUVLONG, TUVLONG, TFLOAT, TDOUBLE, [TIND] = TIND,
        },
  [TVLONG] =	{ 0,	TVLONG, TUVLONG, TVLONG, TUVLONG, TVLONG, TUVLONG, TVLONG,
            TUVLONG, TVLONG, TUVLONG, TFLOAT, TDOUBLE, [TIND] = TIND,
        },
  [TUVLONG] =	{ 0,	TUVLONG, TUVLONG, TUVLONG, TUVLONG, TUVLONG, TUVLONG, TUVLONG,
            TUVLONG, TUVLONG, TUVLONG, TFLOAT, TDOUBLE, [TIND] = TIND,
        },
  [TFLOAT] =	{ 0,	TFLOAT, TFLOAT, TFLOAT, TFLOAT, TFLOAT, TFLOAT, TFLOAT,
            TFLOAT, TFLOAT, TFLOAT, TFLOAT, TDOUBLE, [TIND] = TIND,
        },
  [TDOUBLE] =	{ 0,	TDOUBLE, TDOUBLE, TDOUBLE, TDOUBLE, TDOUBLE, TDOUBLE, TDOUBLE,
            TDOUBLE, TDOUBLE, TDOUBLE, TFLOAT, TDOUBLE, [TIND] = TIND,
        },
  [TIND] =	{ 0,	TIND, TIND, TIND, TIND, TIND, TIND, TIND,
             TIND, TIND, TIND, TIND, TIND, [TIND] = TIND,
        },
};
@


\subsection{C typing extensions}

% | ... -> <>
<<function typeext>>=
void
typeext(Type *st, Node *l)
{
    Type *lt;
    Node *n1, *n2;
    long o;

    lt = l->type;

    if(lt == T)
        return;

    if(st->etype == TIND && vconst(l) == 0) {
        l->type = st;
        l->vconst = 0;
        return;
    }
    <<[[typeext()]] float handling>>
    <<[[typeext()]] unnamed substructure handling>>
}
@

\section{Const checking}

\section{Format arguments checking}
% cool, like in ocamlc!


<<enum fxxx>>=
enum fxxx
{
    Fnone	= 0,

    Fl,
    Fvl,
    Fignor,
    Fstar,
    Fadj,

    Fverb	= 10,
};
@

<<struct Tprot>>=
struct	Tprot
{
    Type*	type;
    Bits	flag;
    Tprot*	link;
};
@

<<struct Tname>>=
struct	Tname
{
    char*	name;
    int		param;
    Tname*	link;
};
@

<<global indchar>>=
static	Type*	indchar;
@

<<global flagbits>>=
static	uchar	flagbits[512];
@

<<global fmtbuf>>=
static	char	fmtbuf[100];
@

<<global lastadj>>=
static	int	lastadj;
@

<<global lastverb>>=
static	int	lastverb;
@

<<global nstar>>=
static	int	nstar;
@

<<global tprot>>=
static	Tprot*	tprot;
@

<<global tname>>=
static	Tname*	tname;
@

<<function argflag>>=
void
argflag(int c, int v)
{

    switch(v) {
    case Fignor:
    case Fstar:
    case Fl:
    case Fvl:
        flagbits[c] = v;
        break;
    case Fverb:
        flagbits[c] = lastverb;
/*print("flag-v %c %d\n", c, lastadj);*/
        lastverb++;
        break;
    case Fadj:
        flagbits[c] = lastadj;
/*print("flag-l %c %d\n", c, lastadj);*/
        lastadj++;
        break;
    }
}
@

<<function getflag>>=
Bits
getflag(char *s)
{
    Bits flag;
    int f;
    char *fmt;
    Rune c;

    fmt = fmtbuf;
    flag = zbits;
    nstar = 0;
    for(;;) {
        s += chartorune(&c, s);
        fmt += runetochar(fmt, &c);
        if(c == 0 || c >= nelem(flagbits))
            break;
        f = flagbits[c];
        switch(f) {
        case Fnone:
            argflag(c, Fverb);
            f = flagbits[c];
            break;
        case Fstar:
            nstar++;
        case Fignor:
            continue;
        case Fl:
            if(bset(flag, Fl))
                flag = bor(flag, blsh(Fvl));
        }
        flag = bor(flag, blsh(f));
        if(f >= Fverb)
            break;
    }
    *fmt = 0;
    return flag;
}
@


<<function arginit>>=
void
arginit(void)
{
    int i;

/* debug['F'] = 1;*/
/* debug['w'] = 1;*/

    lastadj = Fadj;
    lastverb = Fverb;
    indchar = typ(TIND, types[TCHAR]);

    memset(flagbits, Fnone, sizeof(flagbits));

    for(i='0'; i<='9'; i++)
        argflag(i, Fignor);
    argflag('.', Fignor);
    argflag('#', Fignor);
    argflag('u', Fignor);
    argflag('h', Fignor);
    argflag('+', Fignor);
    argflag('-', Fignor);

    argflag('*', Fstar);
    argflag('l', Fl);

    argflag('o', Fverb);
    flagbits['x'] = flagbits['o'];
    flagbits['X'] = flagbits['o'];
}
@


<<function nextarg>>=
Node*
nextarg(Node *n, Node **a)
{
    if(n == Z) {
        *a = Z;
        return Z;
    }
    if(n->op == OLIST) {
        *a = n->left;
        return n->right;
    }
    *a = n;
    return Z;
}
@

<<function checkargs>>=
void
checkargs(Node *nn, char *s, int pos)
{
    Node *a, *n;
    Bits flag;
    Tprot *l;

    if(!debug['F'])
        return;
    n = nn;
    for(;;) {
        s = strchr(s, '%');
        if(s == 0) {
            nextarg(n, &a);
            if(a != Z)
                warn(nn, "more arguments than format %T",
                    a->type);
            return;
        }
        s++;
        flag = getflag(s);
        while(nstar > 0) {
            n = nextarg(n, &a);
            pos++;
            nstar--;
            if(a == Z) {
                warn(nn, "more format than arguments %s",
                    fmtbuf);
                return;
            }
            if(a->type == T)
                continue;
            if(!sametype(types[TINT], a->type) &&
               !sametype(types[TUINT], a->type))
                warn(nn, "format mismatch '*' in %s %T, arg %d",
                    fmtbuf, a->type, pos);
        }
        for(l=tprot; l; l=l->link)
            if(sametype(types[TVOID], l->type)) {
                if(beq(flag, l->flag)) {
                    s++;
                    goto loop;
                }
            }

        n = nextarg(n, &a);
        pos++;
        if(a == Z) {
            warn(nn, "more format than arguments %s",
                fmtbuf);
            return;
        }
        if(a->type == 0)
            continue;
        for(l=tprot; l; l=l->link)
            if(sametype(a->type, l->type)) {
/*print("checking %T/%ulx %T/%ulx\n", a->type, flag.b[0], l->type, l->flag.b[0]);*/
                if(beq(flag, l->flag))
                    goto loop;
            }
        warn(nn, "format mismatch %s %T, arg %d", fmtbuf, a->type, pos);
    loop:;
    }
}
@

<<function dpcheck>>=
void
dpcheck(Node *n)
{
    char *s;
    Node *a, *b;
    Tname *l;
    int i;

    if(n == Z)
        return;
    b = n->left;
    if(b == Z || b->op != ONAME)
        return;
    s = b->sym->name;
    for(l=tname; l; l=l->link)
        if(strcmp(s, l->name) == 0)
            break;
    if(l == 0)
        return;

    i = l->param;
    b = n->right;
    while(i > 0) {
        b = nextarg(b, &a);
        i--;
    }
    if(a == Z) {
        warn(n, "cant find format arg");
        return;
    }
    if(!sametype(indchar, a->type)) {
        warn(n, "format arg type %T", a->type);
        return;
    }
    if(a->op != OADDR || a->left->op != ONAME || a->left->sym != symstring) {
/*		warn(n, "format arg not constant string");*/
        return;
    }
    s = a->left->cstring;
    checkargs(b, s, l->param);
}
@

%<<function newprot>>=
%//void
%//newprot(Sym *m, Type *t, char *s)
%//{
%//    Bits flag;
%//    Tprot *l;
%//
%//    if(t == T) {
%//        warn(Z, "%s: newprot: type not defined", m->name);
%//        return;
%//    }
%//    flag = getflag(s);
%//    for(l=tprot; l; l=l->link)
%//        if(beq(flag, l->flag) && sametype(t, l->type))
%//            return;
%//    l = alloc(sizeof(*l));
%//    l->type = t;
%//    l->flag = flag;
%//    l->link = tprot;
%//    tprot = l;
%//}
%@
%
%<<function newname>>=
%//void
%//newname(char *s, int p)
%//{
%//    Tname *l;
%//
%//    for(l=tname; l; l=l->link)
%//        if(strcmp(l->name, s) == 0) {
%//            if(l->param != p)
%//                yyerror("vargck %s already defined\n", s);
%//            return;
%//        }
%//    l = alloc(sizeof(*l));
%//    l->name = s;
%//    l->param = p;
%//    l->link = tname;
%//    tname = l;
%//}
%@
%
%<<function pragvararg>>=
%//void
%//pragvararg(void)
%//{
%//    Sym *s;
%//    int n, c;
%//    char *t;
%//    Rune r;
%//    Type *ty;
%//
%//    if(!debug['F'])
%//        goto out;
%//    s = getsym();
%//    if(s && strcmp(s->name, "argpos") == 0)
%//        goto ckpos;
%//    if(s && strcmp(s->name, "type") == 0)
%//        goto cktype;
%//    if(s && strcmp(s->name, "flag") == 0)
%//        goto ckflag;
%//    yyerror("syntax in #pragma varargck");
%//    goto out;
%//
%//ckpos:
%///*#pragma	varargck	argpos	warn	2*/
%//    s = getsym();
%//    if(s == S)
%//        goto bad;
%//    n = getnsn();
%//    if(n < 0)
%//        goto bad;
%//    newname(s->name, n);
%//    goto out;
%//
%//ckflag:
%///*#pragma	varargck	flag	'c'*/
%//    c = getnsc();
%//    if(c != '\'')
%//        goto bad;
%//    c = getr();
%//    if(c == '\\')
%//        c = getr();
%//    else if(c == '\'')
%//        goto bad;
%//    if(c == '\n')
%//        goto bad;
%//    if(getc() != '\'')
%//        goto bad;
%//    argflag(c, Fignor);
%//    goto out;
%//
%//cktype:
%///*#pragma	varargck	type	O	int*/
%//    c = getnsc();
%//    if(c != '"')
%//        goto bad;
%//    t = fmtbuf;
%//    for(;;) {
%//        r = getr();
%//        if(r == ' ' || r == '\n')
%//            goto bad;
%//        if(r == '"')
%//            break;
%//        t += runetochar(t, &r);
%//    }
%//    *t = 0;
%//    t = strdup(fmtbuf);
%//    s = getsym();
%//    if(s == S)
%//        goto bad;
%//    ty = s->type;
%//    while((c = getnsc()) == '*')
%//        ty = typ(TIND, ty);
%//    unget(c);
%//    newprot(s, ty, t);
%//    goto out;
%//
%//bad:
%//    yyerror("syntax in #pragma varargck");
%//
%//out:
%//    while(getnsc() != '\n')
%//        ;
%//}
%@
%
%<<function pragpack>>=
%//void
%//pragpack(void)
%//{
%//    Sym *s;
%//
%//    packflg = 0;
%//    s = getsym();
%//    if(s) {
%//        packflg = atoi(s->name+1);
%//        if(strcmp(s->name, "on") == 0 ||
%//           strcmp(s->name, "yes") == 0)
%//            packflg = 1;
%//    }
%//    while(getnsc() != '\n')
%//        ;
%//    if(debug['f'])
%//        if(packflg)
%//            print("%4ld: pack %d\n", lineno, packflg);
%//        else
%//            print("%4ld: pack off\n", lineno);
%//}
%@
%
%<<function pragfpround>>=
%//void
%//pragfpround(void)
%//{
%//    Sym *s;
%//
%//    fproundflg = 0;
%//    s = getsym();
%//    if(s) {
%//        fproundflg = atoi(s->name+1);
%//        if(strcmp(s->name, "on") == 0 ||
%//           strcmp(s->name, "yes") == 0)
%//            fproundflg = 1;
%//    }
%//    while(getnsc() != '\n')
%//        ;
%//    if(debug['f'])
%//        if(fproundflg)
%//            print("%4ld: fproundflg %d\n", lineno, fproundflg);
%//        else
%//            print("%4ld: fproundflg off\n", lineno);
%//}
%@
%
%<<function pragprofile>>=
%//void
%//pragprofile(void)
%//{
%//    Sym *s;
%//
%//    profileflg = false;
%//    s = getsym();
%//    if(s) {
%//        profileflg = atoi(s->name+1);
%//        if(strcmp(s->name, "on") == 0 ||
%//           strcmp(s->name, "yes") == 0)
%//            profileflg = true;
%//    }
%//    while(getnsc() != '\n')
%//        ;
%//    if(debug['f'])
%//        if(profileflg)
%//            print("%4ld: profileflg %d\n", lineno, profileflg);
%//        else
%//            print("%4ld: profileflg off\n", lineno);
%//}
%@
%
%<<function pragincomplete>>=
%//void
%//pragincomplete(void)
%//{
%//    Sym *s;
%//    Type *t;
%//    int istag, w, et;
%//
%//    istag = 0;
%//    s = getsym();
%//    if(s == nil)
%//        goto out;
%//    et = 0;
%//    w = s->lexical;
%//    if(w == LSTRUCT)
%//        et = TSTRUCT;
%//    else if(w == LUNION)
%//        et = TUNION;
%//    if(et != 0){
%//        s = getsym();
%//        if(s == nil){
%//            yyerror("missing struct/union tag in pragma incomplete");
%//            goto out;
%//        }
%//        if(s->lexical != LNAME && s->lexical != LTYPE){
%//            yyerror("invalid struct/union tag: %s", s->name);
%//            goto out;
%//        }
%//        dotag(s, et, 0);
%//        istag = 1;
%//    }else if(strcmp(s->name, "_off_") == 0){
%//        debug['T'] = 0;
%//        goto out;
%//    }else if(strcmp(s->name, "_on_") == 0){
%//        debug['T'] = 1;
%//        goto out;
%//    }
%//    t = s->type;
%//    if(istag)
%//        t = s->suetag;
%//    if(t == T)
%//        yyerror("unknown type %s in pragma incomplete", s->name);
%//    else if(!typesu[t->etype])
%//        yyerror("not struct/union type in pragma incomplete: %s", s->name);
%//    else
%//        t->garb |= GINCOMPLETE;
%//out:
%//    while(getnsc() != '\n')
%//        ;
%//    if(debug['f'])
%//        print("%s incomplete\n", s->name);
%//}
%@





\section{Lint checking}

% good checks :) used/set ! good warnings. gcc sucks, it does not even
% have that (or it's not by default maybe).

% 5c -V enable void* conversion warnings
% 5c -w print warnings

\subsection{Unused variables}

% the data structure

<<[[Sym]] identifier value, checking fields>>=
bool	aused;
@

<<[[syminit()]] remaining initialisations>>=
s->aused = false;
@

<<name rule, LNAME case, adjust more fields>>=
$1->aused = true;
@
%$
% during parsing, a bit ugly.

<<[[reverdcl()]] DAUTO case, warn if auto declared but not used>>=
if(!s->aused) {
    nearln = s->varlineno;
    if(s->class == CAUTO)
        warn(Z, "auto declared and not used: %s", s->name);
    if(s->class == CPARAM)
        warn(Z, "param declared and not used: %s", s->name);
}
@


\subsection{False positives silencing, [[SET()/USED()]]}
% like fallthrough, to remove false positives or true positives which are ok.

% Why have false positives? limitations? bugs? or normal?

% the parsing

<<token declarations>>=
%token  LUSED LSET 
@

<<[[itab]] entries, kencc extensions>>=
"SET",		LSET,		0,
"USED",		LUSED,		0,
@

<<statement nodes>>=
OUSED,
OSET,
@

<<ulstmnt rule>>=
|   LUSED '(' zelist ')' ';' { $$ = new(OUSED, $3, Z); }
|   LSET '(' zelist ')' ';'  { $$ = new(OSET, $3, Z); }
@


% the check?

% for USED if the local is mentionned, then there will be an LNAME
% occurrence.
% for SET?

% the code generation

<<[[gen()]] switch node kind cases>>=
case OSET:
case OUSED:
    usedset(n->left, o);
    break;
@

% gen -> <>
<<function usedset>>=
void
usedset(Node *n, int o)
{
    if(n->op == OLIST) {
        usedset(n->left, o);
        usedset(n->right, o);
        return;
    }

    complex(n);

    switch(n->op) {
    case ONAME:
        if(o == OSET)
            gins(ANOP, Z, n);
        else
            gins(ANOP, n, Z);
        break;
    case OADDR:	/* volatile */
        gins(ANOP, n, Z);
        break;
    }
}
@
% normal to generate ANOP for LUSED. goal is to shut
% the lint checking, but code generation should be empty.
%less: for LSET?

%those ANOP with arguments are weird,
%less: used in regopt?

\subsection{Unused labels}

<<[[reverdcl()]] DLABEL case, warn if label not used>>=
if(s->label && s->label->addable == 0)
    warn(s->label, "label declared and not used \"%s\"", s->name);
@
% ugly this abuse of addable, why not using lblaused instead?

\subsection{Unreachable code}

%ocaml: Those globals crosscuts a lot the assemby generation part.
% a bit ugly. Would have been better to have an intermediate
% CFG DS and then do the unreachable code on it.

<<global canreach>>=
bool	canreach;
@

<<global warnreach>>=
bool	warnreach;
@
% set in codgen(), used in gen()

<<global suppress>>=
bool	suppress;
@
% often do warneach = !suppress. not sure why.

<<[[codgen()]] initialisation before call to gen>>=
canreach = true;
warnreach = true;
@



<<[[gen()]] if not canreach>>=
if(!canreach) {
    switch(o) {
    case OLABEL:
    case OCASE:
    case OLIST:
    case OCOMMA:
    case OBREAK:
    case OFOR:
    case OWHILE:
    case ODWHILE:
        /* all handled specially - see switch body below */
        break;
    default:
        if(warnreach) {
            warn(n, "unreachable code %O", o);
            warnreach = false;
        }
    }
}
@


% deadheads -> <>
% return false if it is possible to jump in the middle of n
%  that is if there is a label:
% less: rewrite as a possibive form ... would be clearer?
<<function deadhead>>=
/*
 * return true if it is impossible to jump into the middle of n.
 */
static bool
deadhead(Node *n, bool caseok)
{
loop:
    if(n == Z)
        return true;

    switch(n->op) {

    case OCASE:
        if(!caseok)
            return false;
        goto rloop;
    case OLABEL:
        return false;



    case OLIST:
        if(!deadhead(n->left, caseok))
            return false;
    rloop:
        n = n->right;
        goto loop;


    case OWHILE:
    case ODWHILE:
    case OFOR:
        goto rloop;


    case OIF:
        return deadhead(n->right->left, caseok) && 
               deadhead(n->right->right, caseok);

    case OSWITCH:
        return deadhead(n->right, true);


    case ORETURN:
    case OGOTO:
    case OCONTINUE:
    case OBREAK:
        return true;

    case OSET:
    case OUSED:
        return true;
    }
    return true;
}
@

% gen | bcomplex -> <>
<<function deadheads>>=
bool
deadheads(Node *c)
{
    return deadhead(c->left, false) && deadhead(c->right, false);
}
@
% called from bcomplex with an OLIST being a OPAIR(thenst, elsest)





\subsection{Missing return}

<<[[codgen()]] warn for possible missing return after call to gen>>=
if(canreach && thisfntype->link->etype != TVOID){
    if(debug['B'])
        warn(Z, "no return at end of function: %s", n1->sym->name);
    else
        diag(Z, "no return at end of function: %s", n1->sym->name);
}
@
% ansi C is diag instead of warn!

\subsection{Constant if, [[5c -c]]}


\chapter{AST-level Optimisations}
% archi independent

% see compcert list of optimisations? there are all of them here too?
% and more?






\section{AST simplifications}

% using a visitor would be better, to avoid boilerplate

\subsection{General rewrites, [[ccom()]]}

% mostly partial evaluation when have constants involved
% in operations.

% tcomo; complex() -> <> ??
% cc/com.c
<<function ccom>>=
/*
 *	general rewrite
 *	(IND(ADDR x)) ==> x
 *	(ADDR(IND x)) ==> x
 *	remove some zero operands
 *	remove no op casts
 *	evaluate constants
 */
void
ccom(Node *n)
{
    Node *l, *r;
    int t;

loop:
    if(n == Z)
        return;

    l = n->left;
    r = n->right;
    switch(n->op) {
    <<[[ccom()]] switch node kind cases>>
    default:
        if(l != Z)
            ccom(l);
        if(r != Z)
            ccom(r);
        // Fallthrough
    common:
        if(((l == Z)||(l->op == OCONST)) && ((r == Z)||(r->op == OCONST)))
            evconst(n);
    }
}
@
% call recursively ccom first, so evconst can assume evconst
% has been called on its leaves.
%old: I rewrote common: to be positive rather than using 'break'
%old: I had a bug and wrote
%        if((l == Z) || (r == Z) || (l->op == OCONST) || (r->op == OCONST))
%            evconst(n);
% but on mk testall it was causing many errors.

<<[[ccom()]] switch node kind cases>>=
case OCONST:
case ONAME:
    break;
@


<<[[ccom()]] switch node kind cases>>=
case OAS:
case OASXOR:
case OASAND:
case OASOR:
case OASMOD:
case OASLMOD:
case OASLSHR:
case OASASHR:
case OASASHL:
case OASDIV:
case OASLDIV:
case OASMUL:
case OASLMUL:
case OASSUB:
case OASADD:
    ccom(l);
    ccom(r);
    if(n->op == OASLSHR || n->op == OASASHR || n->op == OASASHL)
      if(r->op == OCONST) {
        t = n->type->width * 8;	/* bits per byte */
        if(r->vconst >= t || r->vconst < 0)
            warn(n, "stupid shift: %lld", r->vconst);
    }
    break;
@

<<[[ccom()]] switch node kind cases>>=
case OCAST:
    ccom(l);
    if(l->op == OCONST) {
        evconst(n);
        if(n->op == OCONST)
            break;
    }
    if(nocast(l->type, n->type) &&
       (!typefd[l->type->etype] || typeu[l->type->etype] && 
       typeu[n->type->etype])) {
        l->type = n->type;
        *n = *l;
    }
    break;
@

<<[[ccom()]] switch node kind cases>>=
case OCOND:
    ccom(l);
    ccom(r);
    if(l->op == OCONST)
        if(vconst(l) == 0)
            *n = *r->right;
        else
            *n = *r->left;
    break;
@

<<[[ccom()]] switch node kind cases>>=
case OADDR:
    ccom(l);
    l->etype = TVOID; // ????
    if(l->op == OIND) {
        l->left->type = n->type;
        *n = *l->left;
        break;
    }
    goto common;
@

<<[[ccom()]] switch node kind cases>>=
case OIND:
    ccom(l);
    if(l->op == OADDR) {
        l->left->type = n->type;
        *n = *l->left;
        break;
    }
    goto common;
@
<<[[ccom()]] switch node kind cases>>=
case OEQ:
case ONE:

case OLE:
case OGE:
case OLT:
case OGT:

case OLS:
case OHS:
case OLO:
case OHI:
    ccom(l);
    ccom(r);
    if(compar(n, 0) || compar(n, 1))
        break;
    relcon(l, r);
    relcon(r, l);
    goto common;
@

<<[[ccom()]] switch node kind cases>>=
case OASHR:
case OASHL:
case OLSHR:
    ccom(l);
    if(vconst(l) == 0 && !side(r)) {
        *n = *l;
        break;
    }
    ccom(r);
    if(vconst(r) == 0) {
        *n = *l;
        break;
    }
    if(r->op == OCONST) {
        t = n->type->width * 8;	/* bits per byte */
        if(r->vconst >= t || r->vconst <= -t)
            warn(n, "stupid shift: %lld", r->vconst);
    }
    goto common;
@

<<[[ccom()]] switch node kind cases>>=
case OMUL:
case OLMUL:
    ccom(l);
    t = vconst(l);
    if(t == 0 && !side(r)) {
        *n = *l;
        break;
    }
    if(t == 1) {
        *n = *r;
        goto loop;
    }
    ccom(r);
    t = vconst(r);
    if(t == 0 && !side(l)) {
        *n = *r;
        break;
    }
    if(t == 1) {
        *n = *l;
        break;
    }
    goto common;
@

<<[[ccom()]] switch node kind cases>>=
case ODIV:
case OLDIV:
    ccom(l);
    if(vconst(l) == 0 && !side(r)) {
        *n = *l;
        break;
    }
    ccom(r);
    t = vconst(r);
    if(t == 0) {
        diag(n, "divide check");
        *n = *r;
        break;
    }
    if(t == 1) {
        *n = *l;
        break;
    }
    goto common;
@

<<[[ccom()]] switch node kind cases>>=
case OSUB:
    ccom(r);
    if(r->op == OCONST) {
        if(typefd[r->type->etype]) {
            n->op = OADD;
            r->fconst = -r->fconst;
            goto loop;
        } else {
            n->op = OADD;
            r->vconst = -r->vconst;
            goto loop;
        }
    }
    ccom(l);
    goto common;
@

<<[[ccom()]] switch node kind cases>>=
case OXOR:
case OOR:
case OADD:
    ccom(l);
    if(vconst(l) == 0) {
        *n = *r;
        goto loop;
    }
    ccom(r);
    if(vconst(r) == 0) {
        *n = *l;
        break;
    }
    goto commute;
@

<<[[ccom()]] switch node kind cases>>=
case OAND:
    ccom(l);
    ccom(r);
    if(vconst(l) == 0 && !side(r)) {
        *n = *l;
        break;
    }
    if(vconst(r) == 0 && !side(l)) {
        *n = *r;
        break;
    }
    // Fallthrough, goto commute
@

<<[[ccom()]] switch node kind cases>>=
commute:
    /* look for commutative constant */
    if(r->op == OCONST) {
        if(l->op == n->op) {
            if(l->left->op == OCONST) {
                n->right = l->right;
                l->right = r;
                goto loop;
            }
            if(l->right->op == OCONST) {
                n->right = l->left;
                l->left = r;
                goto loop;
            }
        }
    }
    if(l->op == OCONST) {
        if(r->op == n->op) {
            if(r->left->op == OCONST) {
                n->left = r->right;
                r->right = l;
                goto loop;
            }
            if(r->right->op == OCONST) {
                n->left = r->left;
                r->left = l;
                goto loop;
            }
        }
    }
    goto common;
@

<<[[ccom()]] switch node kind cases>>=
case OANDAND:
    ccom(l);
    if(vconst(l) == 0) {
        *n = *l;
        break;
    }
    ccom(r);
    goto common;
@
<<[[ccom()]] switch node kind cases>>=
case OOROR:
    ccom(l);
    if(l->op == OCONST && l->vconst != 0) {
        *n = *l;
        n->vconst = 1;
        break;
    }
    ccom(r);
    goto common;
@


<<[[ccom()]] switch node kind cases>>=
case OREGISTER:
case OINDREG:
    break;
@





% ??? -> <>
<<function side>>=
bool
side(Node *n)
{

loop:
    if(n != Z)
    switch(n->op) {
    case OCAST:
    case ONOT:
    case OADDR:
    case OIND:
        n = n->left;
        goto loop;

    case OCOND:
        if(side(n->left))
            break;
        n = n->right;

    case OEQ:
    case ONE:
    case OLT:
    case OGE:
    case OGT:
    case OLE:
    case OADD:
    case OSUB:
    case OMUL:
    case OLMUL:
    case ODIV:
    case OLDIV:
    case OLSHR:
    case OASHL:
    case OASHR:
    case OAND:
    case OOR:
    case OXOR:
    case OMOD:
    case OLMOD:
    case OANDAND:
    case OOROR:
    case OCOMMA:
    case ODOT:
        if(side(n->left))
            break;
        n = n->right;
        goto loop;

    case OSIGN:
    case OSIZE:
    case OCONST:
    case OSTRING:
    case OLSTRING:
    case ONAME:
        return false;
    }
    return true;
}
@





<<function relcon>>=
/*
 * try to cast a constant down
 * rather than cast a variable up
 * example:
 *	if(c == 'a')
 */
void
relcon(Node *l, Node *r)
{
    vlong v;

    if(l->op != OCONST)
        return;
    if(r->op != OCAST)
        return;
    if(!nilcast(r->left->type, r->type))
        return;
    switch(r->type->etype) {
    default:
        return;
    case TCHAR:
    case TUCHAR:
    case TSHORT:
    case TUSHORT:
        v = convvtox(l->vconst, r->type->etype);
        if(v != l->vconst)
            return;
        break;
    }
    l->type = r->left->type;
    *r = *r->left;
}
@

<<function nilcast>>=
/*
 * a cast that has a noop semantic
 * (small to large, convert)
 */
bool
nilcast(Type *t1, Type *t2)
{
    int et1, et2;

    if(t1 == T)
        return false;
    if(t1->nbits)
        return false;
    if(t2 == T)
        return false;
    et1 = t1->etype;
    et2 = t2->etype;
    if(et1 == et2)
        return true;
    if(typefd[et1] && typefd[et2]) {
        if(ewidth[et1] < ewidth[et2])
            return true;
        return false;
    }
    if(typechlp[et1] && typechlp[et2]) {
        if(ewidth[et1] < ewidth[et2])
            return true;
        return false;
    }
    return false;
}
@

\subsubsection{[[compar()]]}

% could be moved in Checking section?

<<struct Big>>=
/* 128-bit numbers */
struct Big
{
    vlong a;
    uvlong b;
};
@

%ctor
<<function big>>=
Big
big(vlong a, uvlong b)
{
    Big x;

    x.a = a;
    x.b = b;
    return x;
}
@


<<function cmp>>=
static int
cmp(Big x, Big y)
{
    if(x.a != y.a){
        if(x.a < y.a)
            return -1;
        return 1;
    }
    if(x.b != y.b){
        if(x.b < y.b)
            return -1;
        return 1;
    }
    return 0;
}
@

<<function add>>=
static Big
add(Big x, int y)
{
    uvlong ob;
    
    ob = x.b;
    x.b += y;
    if(y > 0 && x.b < ob)
        x.a++;
    if(y < 0 && x.b > ob)
        x.a--;
    return x;
} 
@


<<after parsing nodes>>=
OHI,
OHS,
OLO,
OLS,
@
% for unsigned context, see evconst()
% I think created only via comrel, relindex, and so on

<<global cmps>>=
/*	OEQ, ONE, OLE, OLS, OLT, OLO, OGE, OHS, OGT, OHI */
static char *cmps[12] = 
{
    "==", "!=", "<=", "<=", "<", "<", ">=", ">=", ">", ">",
};
@

<<function compar>>=
int
compar(Node *n, int reverse)
{
    Big lo, hi, x;
    int op;
    char xbuf[40], cmpbuf[50];
    Node *l, *r;
    Type *lt, *rt;

    /*
     * The point of this function is to diagnose comparisons 
     * that can never be true or that look misleading because
     * of the `usual arithmetic conversions'.  As an example 
     * of the latter, if x is a ulong, then if(x <= -1) really means
     * if(x <= 0xFFFFFFFF), while if(x <= -1LL) really means
     * what it says (but 8c compiles it wrong anyway).
     */

    if(reverse){
        r = n->left;
        l = n->right;
        op = comrel[relindex(n->op)];
    }else{
        l = n->left;
        r = n->right;
        op = n->op;
    }

    /*
     * Skip over left casts to find out the original expression range.
     */
    while(l->op == OCAST)
        l = l->left;
    if(l->op == OCONST)
        return 0;
    lt = l->type;
    if(l->op == ONAME && l->sym->type){
        lt = l->sym->type;
        if(lt->etype == TARRAY)
            lt = lt->link;
    }
    if(lt == T)
        return 0;
    if(lt->etype == TXXX || lt->etype > TUVLONG)
        return 0;
    
    /*
     * Skip over the right casts to find the on-screen value.
     */
    if(r->op != OCONST)
        return 0;
    while(r->oldop == OCAST && !r->xcast)
        r = r->left;
    rt = r->type;
    if(rt == T)
        return 0;

    x.b = r->vconst;
    x.a = 0;
    if((rt->etype&1) && r->vconst < 0)	/* signed negative */
        x.a = ~0ULL;

    if((lt->etype&1)==0){
        /* unsigned */
        lo = big(0, 0);
        if(lt->width == 8)
            hi = big(0, ~0ULL);
        else
            hi = big(0, (1LL<<(l->type->width*8))-1);
    }else{
        lo = big(~0ULL, -(1LL<<(l->type->width*8-1)));
        hi = big(0, (1LL<<(l->type->width*8-1))-1);
    }

    switch(op){
    case OLT:
    case OLO:
    case OGE:
    case OHS:
        if(cmp(x, lo) <= 0)
            goto useless;
        if(cmp(x, add(hi, 1)) >= 0)
            goto useless;
        break;
    case OLE:
    case OLS:
    case OGT:
    case OHI:
        if(cmp(x, add(lo, -1)) <= 0)
            goto useless;
        if(cmp(x, hi) >= 0)
            goto useless;
        break;
    case OEQ:
    case ONE:
        /*
         * Don't warn about comparisons if the expression
         * is as wide as the value: the compiler-supplied casts
         * will make both outcomes possible.
         */
        if(lt->width >= rt->width && debug['w'] < 2)
            return 0;
        if(cmp(x, lo) < 0 || cmp(x, hi) > 0)
            goto useless;
        break;
    }
    return 0;

useless:
    if((x.a==0 && x.b<=9) || (x.a==~0LL && x.b >= -9ULL))
        snprint(xbuf, sizeof xbuf, "%lld", x.b);
    else if(x.a == 0)
        snprint(xbuf, sizeof xbuf, "%#llux", x.b);
    else
        snprint(xbuf, sizeof xbuf, "%#llx", x.b);
    if(reverse)
        snprint(cmpbuf, sizeof cmpbuf, "%s %s %T",
            xbuf, cmps[relindex(n->op)], lt);
    else
        snprint(cmpbuf, sizeof cmpbuf, "%T %s %s",
            lt, cmps[relindex(n->op)], xbuf);
    if(debug['y']) 
        prtree(n, "strange");
    warn(n, "useless or misleading comparison: %s", cmpbuf);
    return 0;
}
@
% >> >> >>

\subsection{Constant evaluation, [[evconst()]]}

% gen | ... -> complex -> ccom -> <>
% evaluate constants statically.
%pre: can expect evconst() has been called already on the leaves, see
% ccom(), and except node to satisfy
%          if(((l == Z)||(l->op == OCONST)) && ((r == Z)||(r->op == OCONST)))
% ccom() again.

<<function evconst>>=
void
evconst(Node *n)
{
    Node *l, *r;
    int et;
    bool isf;
    vlong v = 0;
    double d = 0;

    if(n == Z || n->type == T)
        return;

    et = n->type->etype;
    isf = typefd[et];

    l = n->left;
    r = n->right;

    switch(n->op) {
    <<[[evconst()]] switch node kind cases>>
    default:
        return;
    }
    // reach this point if the node is indeed a candidate to "constification"
    if(isf)
        n->fconst = d;
    else
        n->vconst = convvtox(v, n->type->etype);
    n->oldop = n->op;
    n->op = OCONST;
}
@

<<[[Node]] origin tracking fields>>=
// enum<node_kind>
char	oldop;
@
% when retag a node as an OCONST, we want to remember
% what it was actually before. This is used only in compar() right now.



<<[[evconst()]] switch node kind cases>>=
case OCONST:
    break;
@

<<[[evconst()]] switch node kind cases>>=
case OCAST:
    if(et == TVOID)
        return;
    et = l->type->etype;
    if(isf) {
        if(typefd[et])
            d = l->fconst;
        else
            d = l->vconst;
    } else {
        if(typefd[et])
            v = l->fconst;
        else
            v = convvtox(l->vconst, n->type->etype);
    }
    break;
@


%// assume have done explicit cast and balancing before?
<<[[evconst()]] switch node kind cases>>=
case OADD:
    if(isf)
        d = l->fconst + r->fconst;
    else 
        v = l->vconst + r->vconst;
    break;

case OSUB:
    if(isf)
        d = l->fconst - r->fconst;
    else
        v = l->vconst - r->vconst;
    break;

case OMUL:
    if(isf)
        d = l->fconst * r->fconst;
    else
        v = l->vconst * r->vconst;
    break;

case ODIV:
    if(vconst(r) == 0) {
        warn(n, "divide by zero");
        return;
    }
    if(isf)
        d = l->fconst / r->fconst;
    else
        v = l->vconst / r->vconst;
    break;

case OMOD:
    if(vconst(r) == 0) {
        warn(n, "modulo by zero");
        return;
    }
    v = l->vconst % r->vconst;
    break;
@

<<[[evconst()]] switch node kind cases>>=
case OLMUL:
    v = (uvlong)l->vconst * (uvlong)r->vconst;
    break;

case OLDIV:
    if(vconst(r) == 0) {
        warn(n, "divide by zero");
        return;
    }
    v = (uvlong)l->vconst / (uvlong)r->vconst;
    break;

case OLMOD:
    if(vconst(r) == 0) {
        warn(n, "modulo by zero");
        return;
    }
    v = (uvlong)l->vconst % (uvlong)r->vconst;
    break;
@

% how knows l is a constant? no recursive call to evconst?
<<[[evconst()]] switch node kind cases>>=
case ONEG:
    if(isf)
        d = -l->fconst;
    else
        v = -l->vconst;
    break;

case OCOM:
    v = ~l->vconst;
    break;
@
% what about OPOS? removed at parsing time?

<<[[evconst()]] switch node kind cases>>=
case OAND:
    v = l->vconst & r->vconst;
    break;

case OOR:
    v = l->vconst | r->vconst;
    break;

case OXOR:
    v = l->vconst ^ r->vconst;
    break;

case OLSHR:
    v = (uvlong)l->vconst >> r->vconst;
    break;

case OASHR:
    v = l->vconst >> r->vconst;
    break;

case OASHL:
    v = l->vconst << r->vconst;
    break;
@

<<[[evconst()]] switch node kind cases>>=
case OLT:
    if(typefd[l->type->etype])
        v = l->fconst < r->fconst;
    else
        v = l->vconst < r->vconst;
    break;

case OGT:
    if(typefd[l->type->etype])
        v = l->fconst > r->fconst;
    else
        v = l->vconst > r->vconst;
    break;

case OLE:
    if(typefd[l->type->etype])
        v = l->fconst <= r->fconst;
    else
        v = l->vconst <= r->vconst;
    break;

case OGE:
    if(typefd[l->type->etype])
        v = l->fconst >= r->fconst;
    else
        v = l->vconst >= r->vconst;
    break;
@

% a good side effect of evconst() is that it helps
% understand the semantic of certain opcodes :)
<<[[evconst()]] switch node kind cases>>=
case OLO:
    v = (uvlong)l->vconst < (uvlong)r->vconst;
    break;

case OHI:
    v = (uvlong)l->vconst > (uvlong)r->vconst;
    break;

case OLS:
    v = (uvlong)l->vconst <= (uvlong)r->vconst;
    break;

case OHS:
    v = (uvlong)l->vconst >= (uvlong)r->vconst;
    break;
@

<<[[evconst()]] switch node kind cases>>=
case OEQ:
    if(typefd[l->type->etype])
        v = l->fconst == r->fconst;
    else
        v = l->vconst == r->vconst;
    break;

case ONE:
    if(typefd[l->type->etype])
        v = l->fconst != r->fconst;
    else
        v = l->vconst != r->vconst;
    break;
@

<<[[evconst()]] switch node kind cases>>=
case OANDAND:
    if(typefd[l->type->etype])
        v = l->fconst && r->fconst;
    else
        v = l->vconst && r->vconst;
    break;

case OOROR:
    if(typefd[l->type->etype])
        v = l->fconst || r->fconst;
    else
        v = l->vconst || r->vconst;
    break;
case ONOT:
    if(typefd[l->type->etype])
        v = !l->fconst;
    else
        v = !l->vconst;
    break;
@



\subsection{Comma hoisting, [[comma()]]}

<<struct Com>>=
struct Com
{
    int	n;
    Node	*t[500];
};
@

% called by complex()
<<function comma>>=
static void
comma(Node *n)
{
    Com com;
    Node *nn;

    com.n = 0;
    nn = commas(&com, n);

    if(com.n > 0){

if(debug['y'])print("n=%d\n", com.n);
if(debug['y']) prtree(nn, "res");

        if(nn != n)
            *n = *nn;
        while(com.n > 0){

if(debug['y']) prtree(com.t[com.n-1], "tree");

            nn = new1(OXXX, Z, Z);
            *nn = *n;
            n->op = OCOMMA;
            n->type = nn->type;
            n->left = com.t[--com.n];
            n->right = nn;
            n->lineno = n->left->lineno;
        }
if(debug['y']) prtree(n, "final");

    }else if(n != nn)
        fatal(n, "odd tree");
}
@


<<function commas>>=
static Node*
commas(Com *com, Node *n)
{
    Node *t;

    if(n == Z)
        return n;
    switch(n->op){
    case OREGISTER:
    case OINDREG:
    case OCONST:
    case ONAME:
    case OSTRING:
        /* leaf */
        return n;

    case OCOMMA:
        t = commas(com, n->left);
        if(com->n >= nelem(com->t))
            fatal(n, "comma list overflow");
        com->t[com->n++] = t;
        return commas(com, n->right);

    case OFUNC:
        n->left = commas(com, n->left);
        n->right = comargs(com, n->right);
        return n;

    case OCOND:
        n->left = commas(com, n->left);
        comma(n->right->left);
        comma(n->right->right);
        return n;

    case OANDAND:
    case OOROR:
        n->left = commas(com, n->left);
        comma(n->right);
        return n;

    case ORETURN:
        comma(n->left);
        return n;
    }
    n->left = commas(com, n->left);
    if(n->right != Z)
        n->right = commas(com, n->right);
    return n;
}
@


<<function comargs>>=
/*
 * hoist comma operators out of expressions
 *	(a,b) OP c => (a, b OP c)
 *	OP(a,b) =>	(a, OP b)
 *	a OP (b,c) => (b, a OP c)
 */

static Node*
comargs(Com *com, Node *n)
{
    if(n != Z && n->op == OLIST){
        n->left = comargs(com, n->left);
        n->right = comargs(com, n->right);
    }
    return commas(com, n);
}
@




\section{Associative-commutative arithmetic optimisations}
% see also 5c -m, print add/mul/sub trees


% "acom is Aho and Ullman's acommute (with all the exercises done).
% basically it does code improvements taking advantage of
% associative-commutative operations, and extends that to look for
% further optimisations mentioned in Thompson's paper on the compiler.
% Ritchie's PDP-11 C compiler did something similar (but he called it
% acommute and distrib). comments such as "bust terms out" and "look
% for factorable terms c1*i + c1*c2*j -> c1*(i + c2*j) suggest what
% it's doing). essentially it flattens levels of an expression tree
% using associative and commutative operators into an array and
% rearranges them." - fortsith

\subsection{[[Term]]}

<<constant NTERM>>=
#define	NTERM		10
@

<<struct Term>>=
struct	Term
{
    vlong	mult;
    Node	*node;
};
@

<<global term>>=
Term	term[NTERM];
@

<<global nterm>>=
int	nterm;
@


\subsection{[[acom()]]}
% cc/scon.c ??

<<function acom>>=
void
acom(Node *n)
{
    Type *t;
    Node *l, *r;
    int i;

    switch(n->op)
    {

    case ONAME:
    case OCONST:
    case OSTRING:
    case OINDREG:
    case OREGISTER:
        return;

    case ONEG:
        l = n->left;
        if(addo(n) && addo(l))
            break;
        acom(l);
        return;

    case OADD:
    case OSUB:
    case OMUL:
        l = n->left;
        r = n->right;
        if(addo(n)) {
            if(addo(r))
                break;
            if(addo(l))
                break;
        }
        acom(l);
        acom(r);
        return;

    default:
        l = n->left;
        r = n->right;
        if(l != Z)
            acom(l);
        if(r != Z)
            acom(r);
        return;
    }

    /* bust terms out */
    t = n->type;
    term[0].mult = 0;
    term[0].node = Z;
    nterm = 1;
    acom1(1, n);

    if(debug['m'])
     for(i=0; i<nterm; i++) {
        print("%d %3lld ", i, term[i].mult);
        prtree1(term[i].node, 1, 0);
    }

    if(nterm < NTERM)
        acom2(n, t);
    n->type = t;
}
@
% hmm 'm' already used for macro debugging => use M instead? or n?

<<function addo>>=
int
addo(Node *n)
{

    if(n != Z)
    if(!typefd[n->type->etype])
    if(!typev[n->type->etype] || ewidth[TVLONG] == ewidth[TIND])
    switch(n->op) {

    case OCAST:
        if(nilcast(n->left->type, n->type))
            return 1;
        break;

    case ONEG:
    case OADD:
    case OSUB:
        return 1;

    case OMUL:
        if(n->left->op == OCONST)
            return 1;
        if(n->right->op == OCONST)
            return 1;
    }
    return 0;
}
@


<<function acom1>>=
void
acom1(vlong v, Node *n)
{
    Node *l, *r;

    if(v == 0 || nterm >= NTERM)
        return;
    if(!addo(n)) {
        if(n->op == OCONST)
        if(!typefd[n->type->etype]) {
            term[0].mult += v*n->vconst;
            return;
        }
        term[nterm].mult = v;
        term[nterm].node = n;
        nterm++;
        return;
    }
    switch(n->op) {

    case OCAST:
        acom1(v, n->left);
        break;

    case ONEG:
        acom1(-v, n->left);
        break;

    case OADD:
        acom1(v, n->left);
        acom1(v, n->right);
        break;

    case OSUB:
        acom1(v, n->left);
        acom1(-v, n->right);
        break;

    case OMUL:
        l = n->left;
        r = n->right;
        if(l->op == OCONST)
        if(!typefd[n->type->etype]) {
            acom1(v*l->vconst, r);
            break;
        }
        if(r->op == OCONST)
        if(!typefd[n->type->etype]) {
            acom1(v*r->vconst, l);
            break;
        }
        break;

    default:
        diag(n, "not addo");
    }
}
@



<<function acast>>=
static Node*
acast(Type *t, Node *n)
{
    if(n->type->etype != t->etype || n->op == OBIT) {
        n = new1(OCAST, n, Z);
        if(nocast(n->left->type, t))
            *n = *n->left;
        n->type = t;
    }
    return n;
}
@



<<function acomcmp1>>=
int
acomcmp1(const void *a1, const void *a2)
{
    vlong c1, c2;
    Term *t1, *t2;

    t1 = (Term*)a1;
    t2 = (Term*)a2;
    c1 = t1->mult;
    if(c1 < 0)
        c1 = -c1;
    c2 = t2->mult;
    if(c2 < 0)
        c2 = -c2;
    if(c1 > c2)
        return 1;
    if(c1 < c2)
        return -1;
    c1 = 1;
    if(t1->mult < 0)
        c1 = 0;
    c2 = 1;
    if(t2->mult < 0)
        c2 = 0;
    if(c2 -= c1)
        return c2;
    if(t2 > t1)
        return 1;
    return -1;
}
@

<<function acomcmp2>>=
int
acomcmp2(const void *a1, const void *a2)
{
    vlong c1, c2;
    Term *t1, *t2;

    t1 = (Term*)a1;
    t2 = (Term*)a2;
    c1 = t1->mult;
    c2 = t2->mult;
    if(c1 > c2)
        return 1;
    if(c1 < c2)
        return -1;
    if(t2 > t1)
        return 1;
    return -1;
}
@

<<function acom2>>=
void
acom2(Node *n, Type *t)
{
    Node *l, *r;
    Term trm[NTERM];
    int et, nt, i, j;
    vlong c1, c2;

    /*
     * copy into automatic
     */
    c2 = 0;
    nt = nterm;
    for(i=0; i<nt; i++)
        trm[i] = term[i];
    /*
     * recur on subtrees
     */
    j = 0;
    for(i=1; i<nt; i++) {
        c1 = trm[i].mult;
        if(c1 == 0)
            continue;
        l = trm[i].node;
        if(l != Z) {
            j = 1;
            acom(l);
        }
    }
    c1 = trm[0].mult;
    if(j == 0) {
        n->oldop = n->op;
        n->op = OCONST;
        n->vconst = c1;
        return;
    }
    et = t->etype;

    /*
     * prepare constant term,
     * combine it with an addressing term
     */
    if(c1 != 0) {
        l = new1(OCONST, Z, Z);
        l->type = t;
        l->vconst = c1;
        trm[0].mult = 1;
        for(i=1; i<nt; i++) {
            if(trm[i].mult != 1)
                continue;
            r = trm[i].node;
            if(r->op != OADDR)
                continue;
            r->type = t;
            l = new1(OADD, r, l);
            l->type = t;
            trm[i].mult = 0;
            break;
        }
        trm[0].node = l;
    }
    /*
     * look for factorable terms
     * c1*i + c1*c2*j -> c1*(i + c2*j)
     */
    qsort(trm+1, nt-1, sizeof(trm[0]), acomcmp1);
    for(i=nt-1; i>=0; i--) {
        c1 = trm[i].mult;
        if(c1 < 0)
            c1 = -c1;
        if(c1 <= 1)
            continue;
        for(j=i+1; j<nt; j++) {
            c2 = trm[j].mult;
            if(c2 < 0)
                c2 = -c2;
            if(c2 <= 1)
                continue;
            if(c2 % c1)
                continue;
            r = trm[j].node;
            if(r->type->etype != et)
                r = acast(t, r);
            c2 = trm[j].mult/trm[i].mult;
            if(c2 != 1 && c2 != -1) {
                r = new1(OMUL, r, new(OCONST, Z, Z));
                r->type = t;
                r->right->type = t;
                r->right->vconst = c2;
            }
            l = trm[i].node;
            if(l->type->etype != et)
                l = acast(t, l);
            r = new1(OADD, l, r);
            r->type = t;
            if(c2 == -1)
                r->op = OSUB;
            trm[i].node = r;
            trm[j].mult = 0;
        }
    }
    if(debug['m']) {
        print("\n");
        for(i=0; i<nt; i++) {
            print("%d %3lld ", i, trm[i].mult);
            prtree1(trm[i].node, 1, 0);
        }
    }

    /*
     * put it all back together
     */
    qsort(trm+1, nt-1, sizeof(trm[0]), acomcmp2);
    l = Z;
    for(i=nt-1; i>=0; i--) {
        c1 = trm[i].mult;
        if(c1 == 0)
            continue;
        r = trm[i].node;
        if(r->type->etype != et || r->op == OBIT)
            r = acast(t, r);
        if(c1 != 1 && c1 != -1) {
            r = new1(OMUL, r, new(OCONST, Z, Z));
            r->type = t;
            r->right->type = t;
            if(c1 < 0) {
                r->right->vconst = -c1;
                c1 = -1;
            } else {
                r->right->vconst = c1;
                c1 = 1;
            }
        }
        if(l == Z) {
            l = r;
            c2 = c1;
            continue;
        }
        if(c1 < 0)
            if(c2 < 0)
                l = new1(OADD, l, r);
            else
                l = new1(OSUB, l, r);
        else
            if(c2 < 0) {
                l = new1(OSUB, r, l);
                c2 = 1;
            } else
                l = new1(OADD, l, r);
        l->type = t;
    }
    if(c2 < 0) {
        r = new1(OCONST, 0, 0);
        r->vconst = 0;
        r->type = t;
        l = new1(OSUB, r, l);
        l->type = t;
    }
    *n = *l;
}
@





\section{Addressability and complexity computation, [[xcom()]]}


% "xcom, [...] is machine-dependent [...]. it assigns an
% index of complexity to a sub-expression, which is usually expressed
% as the number of registers needed to compute it (and good luck with
% that on an x86), but it's also a good place to look for
% machine-dependent aspects of machine addressing, such as indexing,
% double-indexing, scaling, etc and it sets values in each tree node
% to mark that." - forsith


% 5c/sgen.c?
<<function xcom(arm)>>=
/*
 *	calculate addressability as follows
 *		CONST ==> 20		$value
 *		NAME ==> 10		name
 *		REGISTER ==> 11		register
 *		INDREG ==> 12		*[(reg)+offset]
 *		&10 ==> 2		$name
 *		ADD(2, 20) ==> 2	$name+offset
 *		ADD(3, 20) ==> 3	$(reg)+offset
 *		&12 ==> 3		$(reg)+offset
 *		*11 ==> 11		??
 *		*2 ==> 10		name
 *		*3 ==> 12		*(reg)+offset
 *	calculate complexity (number of registers) //$
 */
void
xcom(Node *n)
{
    Node *l, *r;
    int t;

    if(n == Z)
        return;
    l = n->left;
    r = n->right;
    n->addable = 0;
    n->complex = 0;
    switch(n->op) {
    case OCONST:
        n->addable = 20;
        return;

    case OREGISTER:
        n->addable = 11;
        return;

    case OINDREG:
        n->addable = 12;
        return;

    case ONAME:
        n->addable = 10;
        return;

    case OADDR:
        xcom(l);
        if(l->addable == 10)
            n->addable = 2;
        if(l->addable == 12)
            n->addable = 3;
        break;

    case OIND:
        xcom(l);
        if(l->addable == 11)
            n->addable = 12;
        if(l->addable == 3)
            n->addable = 12;
        if(l->addable == 2)
            n->addable = 10;
        break;

    case OADD:
        xcom(l);
        xcom(r);
        if(l->addable == 20) {
            if(r->addable == 2)
                n->addable = 2;
            if(r->addable == 3)
                n->addable = 3;
        }
        if(r->addable == 20) {
            if(l->addable == 2)
                n->addable = 2;
            if(l->addable == 3)
                n->addable = 3;
        }
        break;

    case OASLMUL:
    case OASMUL:
        xcom(l);
        xcom(r);
        t = vlog(r);
        if(t >= 0) {
            n->op = OASASHL;
            r->vconst = t;
            r->type = types[TINT];
        }
        break;

    case OMUL:
    case OLMUL:
        xcom(l);
        xcom(r);
        t = vlog(r);
        if(t >= 0) {
            n->op = OASHL;
            r->vconst = t;
            r->type = types[TINT];
        }
        t = vlog(l);
        if(t >= 0) {
            n->op = OASHL;
            n->left = r;
            n->right = l;
            r = l;
            l = n->left;
            r->vconst = t;
            r->type = types[TINT];
        }
        break;

    case OASLDIV:
        xcom(l);
        xcom(r);
        t = vlog(r);
        if(t >= 0) {
            n->op = OASLSHR;
            r->vconst = t;
            r->type = types[TINT];
        }
        break;

    case OLDIV:
        xcom(l);
        xcom(r);
        t = vlog(r);
        if(t >= 0) {
            n->op = OLSHR;
            r->vconst = t;
            r->type = types[TINT];
        }
        break;

    case OASLMOD:
        xcom(l);
        xcom(r);
        t = vlog(r);
        if(t >= 0) {
            n->op = OASAND;
            r->vconst--;
        }
        break;

    case OLMOD:
        xcom(l);
        xcom(r);
        t = vlog(r);
        if(t >= 0) {
            n->op = OAND;
            r->vconst--;
        }
        break;

    default:
        if(l != Z)
            xcom(l);
        if(r != Z)
            xcom(r);
        break;
    }
    if(n->addable >= 10)
        return;

    if(l != Z)
        n->complex = l->complex;
    if(r != Z) {
        if(r->complex == n->complex)
            n->complex = r->complex+1;
        else
        if(r->complex > n->complex)
            n->complex = r->complex;
    }
    if(n->complex == 0)
        n->complex++;

    if(com64(n))
        return;

    switch(n->op) {
    case OFUNC:
        n->complex = FNX;
        break;

    case OADD:
    case OXOR:
    case OAND:
    case OOR:
    case OEQ:
    case ONE:
        /*
         * immediate operators, make const on right
         */
        if(l->op == OCONST) {
            n->left = r;
            n->right = l;
        }
        break;
    }
}
@



\chapter{Assembly-level Optimisations}

\section{Register passing argument, [[REGARG]]}
% maybe not the best section, kind of assembly-level opti,
% but seems generic and involves modifying the AST

<<[[codgen()]] locals>>=
Node nod, nod1;
@

%REGARG from 5.out.h = 0 => so use R0 and the rest in the stack. 
%REGRET is also R0.


<<[[codgen()]] if use REGARG>>=
/*
 * isolate first argument
 */
if(REGARG >= 0) {	
    <<[[codegen()]] if use REGARG, if complex return type>>
    else
    if(firstarg && typeword[firstargtype->etype]) {
        nod1 = znode;
        nod1.op = ONAME;
        nod1.sym = firstarg;
        nod1.type = firstargtype;
        nod1.etype = firstargtype->etype;
        nod1.class = CPARAM;
        nod1.xoffset = align(0, firstargtype, Aarg1);
        xcom(&nod1);
        nodreg(&nod, &nod1, REGARG);
        gmove(&nod, &nod1);
    }
}
@
% xcom? why not complex()?
%todo: what's the point of allocating a nod1 to put
% the first argument passed via REGARG in? it removes
% the benefit of this optimisation no?

<<global typeword>>=
// set<type_kind>
char*	typeword;
@

<<[[tinit()]] initialise 32 bits defaults type sets>>=
/* 32-bit defaults */
typeword = typechlp;
@
% char, short, long, pointer =~ !typecmplx no?



<<[[cgenrel()]] OFUNC case, if use REGARG, part one>>=
if(REGARG >= 0)
    o = reg[REGARG];
@

<<[[cgenrel()]] OFUNC case, if use REGARG, part two>>=
if(REGARG >= 0)
    if(o != reg[REGARG])
        reg[REGARG]--;
@

<<[[garg1()]] if use REGARG and curarg is zero and simple type>>=
if(REGARG >= 0 && curarg == 0 && typechlp[n->type->etype]) {
    regaalloc1(tn1, n);
    if(n->complex >= FNX) {
        cgen(*fnxp, tn1);
        (*fnxp)++;
    } else
        cgen(n, tn1);
}
@

<<function regaalloc1(arm)>>=
void
regaalloc1(Node *n, Node *nn)
{
    nodreg(n, nn, REGARG);
    reg[REGARG]++;
    curarg = align(curarg, nn->type, Aarg1);
    curarg = align(curarg, nn->type, Aarg2);
    maxargsafe = maxround(maxargsafe, cursafe+curarg);
}
@





\section{Register allocation optimisations}
% 5c -r? registerization

\subsection{[[regopt()]]}

<<[[codgen()]] register optimisation>>=
if(!debug['N'] || debug['R'] || debug['P'])
    regopt(sp);
@

% register optimization?
<<function regopt(arm)>>=
void
regopt(Prog *p)
{
    <<[[regopt()]] locals>>

    <<[[regopt()]] initialisation>>

    <<[[regopt()]] pass 1>>
    <<[[regopt()]] pass 2>>
    <<[[regopt()]] pass 2.5>>
    <<[[regopt()]] pass 3>>
    <<[[regopt()]] pass 4>>
    <<[[regopt()]] pass 5>>
    <<[[regopt()]] pass 6>>
    <<[[regopt()]] pass 7>>
    <<[[regopt()]] pass 8>>
    <<[[regopt()]] pass 9>>
}
@








<<global externs>>=
Bits	externs;
@
<<global params>>=
Bits	params;
@

<<global consts>>=
Bits	consts;
@

<<global addrs>>=
Bits	addrs;
@


<<global regbits>>=
long	regbits;
@

<<global exregbits>>=
long	exregbits;
@


<<global change>>=
int	change;
@


<<global firstr>>=
Reg*	firstr;
@

<<global lastr>>=
Reg*	lastr;
@

<<global zreg>>=
Reg	zreg;
@

<<global freer>>=
Reg*	freer;
@

<<[[regopt()]] locals>>=
Reg *r, *r1, *r2;
Prog *p1;
int i, z;
long initpc, val, npc;
ulong vreg;
Bits bit;
struct
{
    long	m;
    long	c;
    Reg*	p;
} log5[6], *lp;
@

<<[[regopt()]] initialisation>>=
firstr = R;
lastr = R;
nvar = 0;
regbits = 0;
for(z=0; z<BITS; z++) {
    externs.b[z] = 0;
    params.b[z] = 0;
    consts.b[z] = 0;
    addrs.b[z] = 0;
}
@


% gen -> <>


\subsection{[[noretval()]]}

<<[[codgen()]] before RET>>=
noretval(1 | 2);
@

<<[[gen()]] case ORETURN with no argument, before RET>>=
noretval(1 | 2);
@

<<[[gen()]] case ORETURN with argument, before RET>>=
if(typefd[n->type->etype])
    noretval(1);
else
    noretval(2);
@

% NOP; NOP, with some arguments, weird.
% 5c/sgen.c?
<<function noretval(arm)>>=
void
noretval(int n)
{

    if(n & 1) {
        gins(ANOP, Z, Z);
        p->to.type = D_REG;
        p->to.reg = REGRET;
    }
    if(n & 2) {
        gins(ANOP, Z, Z);
        p->to.type = D_FREG;
        p->to.reg = FREGRET;
    }
}
@
%ANOP with to? what is it?

\subsection{Pass 1}

<<[[regopt()]] pass 1>>=
/*
 * pass 1
 * build aux data structure
 * allocate pcs
 * find use and set of variables
 */
val = 5L * 5L * 5L * 5L * 5L;
lp = log5;
for(i=0; i<5; i++) {
    lp->m = val;
    lp->c = 0;
    lp->p = R;
    val /= 5L;
    lp++;
}
val = 0;
for(; p != P; p = p->link) {
    switch(p->as) {
    case ADATA:
    case AGLOBL:
    case ANAME:
    case ASIGNAME:
        continue;
    }
    r = rega();
    if(firstr == R) {
        firstr = r;
        lastr = r;
    } else {
        lastr->link = r;
        r->p1 = lastr;
        lastr->s1 = r;
        lastr = r;
    }
    r->prog = p;
    r->pc = val;
    val++;

    lp = log5;
    for(i=0; i<5; i++) {
        lp->c--;
        if(lp->c <= 0) {
            lp->c = lp->m;
            if(lp->p != R)
                lp->p->log5 = r;
            lp->p = r;
            (lp+1)->c = 0;
            break;
        }
        lp++;
    }

    r1 = r->p1;
    if(r1 != R)
    switch(r1->prog->as) {
    case ARET:
    case AB:
    case ARFE:
        r->p1 = R;
        r1->s1 = R;
    }

    /*
     * left side always read
     */
    bit = mkvar(&p->from, p->as==AMOVW);
    for(z=0; z<BITS; z++)
        r->use1.b[z] |= bit.b[z];

    /*
     * right side depends on opcode
     */
    bit = mkvar(&p->to, 0);
    if(bany(&bit))
    switch(p->as) {
    default:
        diag(Z, "reg: unknown asop: %A", p->as);
        break;

    /*
     * right side write
     */
    case ANOP:
    case AMOVB:
    case AMOVBU:
    case AMOVH:
    case AMOVHU:
    case AMOVW:
    case AMOVF:
    case AMOVD:
        for(z=0; z<BITS; z++)
            r->set.b[z] |= bit.b[z];
        break;

    /*
     * funny
     */
    case ABL:
        for(z=0; z<BITS; z++)
            addrs.b[z] |= bit.b[z];
        break;
    }

    if(p->as == AMOVM) {
        if(p->from.type == D_CONST)
            z = p->from.offset;
        else
            z = p->to.offset;
        for(i=0; z; i++) {
            if(z&1)
                regbits |= RtoB(i);
            z >>= 1;
        }
    }
}
if(firstr == R)
    return;
initpc = pc - val;
npc = val;
@


\subsection{Pass 2}

<<[[regopt()]] pass 2>>=
/*
 * pass 2
 * turn branch references to pointers
 * build back pointers
 */
for(r = firstr; r != R; r = r->link) {
    p = r->prog;
    if(p->to.type == D_BRANCH) {
        val = p->to.offset - initpc;
        r1 = firstr;
        while(r1 != R) {
            r2 = r1->log5;
            if(r2 != R && val >= r2->pc) {
                r1 = r2;
                continue;
            }
            if(r1->pc == val)
                break;
            r1 = r1->link;
        }
        if(r1 == R) {
            nearln = p->lineno;
            diag(Z, "ref not found\n%P", p);
            continue;
        }
        if(r1 == r) {
            nearln = p->lineno;
            diag(Z, "ref to self\n%P", p);
            continue;
        }
        r->s2 = r1;
        r->p2link = r1->p2;
        r1->p2 = r;
    }
}
if(debug['R']) {
    p = firstr->prog;
    print("\n%L %D\n", p->lineno, &p->from);
}
@


<<[[regopt()]] pass 2.5>>=
/*
 * pass 2.5
 * find looping structure
 */
for(r = firstr; r != R; r = r->link)
    r->active = 0;
change = 0;
loopit(firstr, npc);
@


\subsection{Pass 3}

<<[[regopt()]] pass 3>>=
    /*
     * pass 3
     * iterate propagating usage
     * 	back until flow graph is complete
     */
loop1:
    change = 0;
    for(r = firstr; r != R; r = r->link)
        r->active = 0;
    for(r = firstr; r != R; r = r->link)
        if(r->prog->as == ARET)
            prop(r, zbits, zbits);
loop11:
    /* pick up unreachable code */
    i = 0;
    for(r = firstr; r != R; r = r1) {
        r1 = r->link;
        if(r1 && r1->active && !r->active) {
            prop(r, zbits, zbits);
            i = 1;
        }
    }
    if(i)
        goto loop11;
    if(change)
        goto loop1;
@


\subsection{Pass 4}

<<[[regopt()]] pass 4>>=
    /*
     * pass 4
     * iterate propagating register/variable synchrony
     * 	forward until graph is complete
     */
loop2:
    change = 0;
    for(r = firstr; r != R; r = r->link)
        r->active = 0;
    synch(firstr, zbits);
    if(change)
        goto loop2;

    addsplits();

    if(debug['R'] && debug['v']) {
        print("\nprop structure:\n");
        for(r = firstr; r != R; r = r->link) {
            print("%ld:%P", r->loop, r->prog);
            for(z=0; z<BITS; z++)
                bit.b[z] = r->set.b[z] |
                    r->refahead.b[z] | r->calahead.b[z] |
                    r->refbehind.b[z] | r->calbehind.b[z] |
                    r->use1.b[z] | r->use2.b[z];
            if(bany(&bit)) {
                print("\t");
                if(bany(&r->use1))
                    print(" u1=%B", r->use1);
                if(bany(&r->use2))
                    print(" u2=%B", r->use2);
                if(bany(&r->set))
                    print(" st=%B", r->set);
                if(bany(&r->refahead))
                    print(" ra=%B", r->refahead);
                if(bany(&r->calahead))
                    print(" ca=%B", r->calahead);
                if(bany(&r->refbehind))
                    print(" rb=%B", r->refbehind);
                if(bany(&r->calbehind))
                    print(" cb=%B", r->calbehind);
            }
            print("\n");
        }
    }
@

\subsection{pass 5}

<<[[regopt()]] pass 5>>=
    /*
     * pass 5
     * isolate regions
     * calculate costs (paint1)
     */
    r = firstr;
    if(r) {
        for(z=0; z<BITS; z++)
            bit.b[z] = (r->refahead.b[z] | r->calahead.b[z]) &
              ~(externs.b[z] | params.b[z] | addrs.b[z] | consts.b[z]);
        if(bany(&bit)) {
            nearln = r->prog->lineno;
            warn(Z, "used and not set: %B", bit);
            if(debug['R'] && !debug['w'])
                print("used and not set: %B\n", bit);
        }
    }

    for(r = firstr; r != R; r = r->link)
        r->act = zbits;
    rgp = region;
    nregion = 0;
    for(r = firstr; r != R; r = r->link) {
        for(z=0; z<BITS; z++)
            bit.b[z] = r->set.b[z] &
              ~(r->refahead.b[z] | r->calahead.b[z] | addrs.b[z]);
        if(bany(&bit)) {
            nearln = r->prog->lineno;
            warn(Z, "set and not used: %B", bit);
            if(debug['R'])
                print("set and not used: %B\n", bit);
            excise(r);
        }
        for(z=0; z<BITS; z++)
            bit.b[z] = LOAD(r) & ~(r->act.b[z] | addrs.b[z]);
        while(bany(&bit)) {
            i = bnum(bit);
            rgp->enter = r;
            rgp->varno = i;
            change = 0;
            if(debug['R'] && debug['v'])
                print("\n");
            paint1(r, i);
            bit.b[i/32] &= ~(1L<<(i%32));
            if(change <= 0) {
                if(debug['R'])
                    print("%L $%d: %B\n",
                        r->prog->lineno, change, blsh(i));
                continue;
            }
            rgp->cost = change;
            nregion++;
            if(nregion >= NRGN) {
                warn(Z, "too many regions");
                goto brk;
            }
            rgp++;
        }
    }
brk:
    qsort(region, nregion, sizeof(region[0]), rcmp);
@

\subsection{pass 6}

<<[[regopt()]] pass 6>>=
/*
 * pass 6
 * determine used registers (paint2)
 * replace code (paint3)
 */
rgp = region;
for(i=0; i<nregion; i++) {
    bit = blsh(rgp->varno);
    vreg = paint2(rgp->enter, rgp->varno);
    vreg = allreg(vreg, rgp);
    if(debug['R']) {
        if(rgp->regno >= NREG)
            print("%L $%d F%d: %B\n",
                rgp->enter->prog->lineno,
                rgp->cost,
                rgp->regno-NREG,
                bit);
        else
            print("%L $%d R%d: %B\n",
                rgp->enter->prog->lineno,
                rgp->cost,
                rgp->regno,
                bit);
    }
    if(rgp->regno != 0)
        paint3(rgp->enter, rgp->varno, vreg, rgp->regno);
    rgp++;
}
@

\subsection{pass 7}

<<[[regopt()]] pass 7>>=
/*
 * pass 7
 * peep-hole on basic block
 */
if(!debug['R'] || debug['P'])
    peep();
@

\subsection{pass 8}

<<[[regopt()]] pass 8>>=
/*
 * pass 8
 * recalculate pc
 */
val = initpc;
for(r = firstr; r != R; r = r1) {
    r->pc = val;
    p = r->prog;
    p1 = P;
    r1 = r->link;
    if(r1 != R)
        p1 = r1->prog;
    for(; p != p1; p = p->link) {
        switch(p->as) {
        default:
            val++;
            break;

        case ANOP:
        case ADATA:
        case AGLOBL:
        case ANAME:
        case ASIGNAME:
            break;
        }
    }
}
pc = val;

/*
 * fix up branches
 */
if(debug['R'])
    if(bany(&addrs))
        print("addrs: %B\n", addrs);

r1 = 0; /* set */
for(r = firstr; r != R; r = r->link) {
    p = r->prog;
    if(p->to.type == D_BRANCH)
        p->to.offset = r->s2->pc;
    r1 = r;
}
@

\subsection{pass 9}

<<[[regopt()]] pass 9>>=
/*
 * last pass
 * eliminate nops
 * free aux structures
 */
for(p = firstr->prog; p != P; p = p->link){
    while(p->link && p->link->as == ANOP)
        p->link = p->link->link;
}
if(r1 != R) {
    r1->link = freer;
    freer = firstr;
}
@





\subsection{[[Bits]]}

<<constant BITS>>=
#define	BITS	5
@


<<struct Bits>>=
struct	Bits
{
    ulong	b[BITS];
};
@

<<global zbits>>=
Bits	zbits;
@


<<function bor>>=
Bits
bor(Bits a, Bits b)
{
    Bits c;
    int i;

    for(i=0; i<BITS; i++)
        c.b[i] = a.b[i] | b.b[i];
    return c;
}
@

<<function bany>>=
/*
Bits
bnot(Bits a)
{
    Bits c;
    int i;

    for(i=0; i<BITS; i++)
        c.b[i] = ~a.b[i];
    return c;
}
*/

int
bany(Bits *a)
{
    int i;

    for(i=0; i<BITS; i++)
        if(a->b[i])
            return 1;
    return 0;
}
@

<<function beq>>=
int
beq(Bits a, Bits b)
{
    int i;

    for(i=0; i<BITS; i++)
        if(a.b[i] != b.b[i])
            return 0;
    return 1;
}
@

<<function bnum>>=
int
bnum(Bits a)
{
    int i;
    long b;

    for(i=0; i<BITS; i++)
        if(b = a.b[i])
            return 32*i + bitno(b);
    diag(Z, "bad in bnum");
    return 0;
}
@

<<function blsh>>=
Bits
blsh(uint n)
{
    Bits c;

    c = zbits;
    c.b[n/32] = 1L << (n%32);
    return c;
}
@
% >>

<<function bset>>=
//@Scheck: also defined as a macro in gc.h, TODO fix that!
int bset(Bits a, uint n)
{
    if(a.b[n/32] & (1L << (n%32)))
        return 1;
    return 0;
}
@
%>>

<<function bset(arm)>>=
#define	bset(a,n)	((a).b[(n)/32]&(1L<<(n)%32))
@
% >> 

%<<function band>>=
%//Bits
%//band(Bits a, Bits b)
%//{
%//    Bits c;
%//    int i;
%//
%//    for(i=0; i<BITS; i++)
%//        c.b[i] = a.b[i] & b.b[i];
%//    return c;
%//}
%@

\subsection{[[Var]]}

<<constant NVAR>>=
#define	NVAR	(BITS*sizeof(ulong)*8)
@
%5 * 4 * 8

<<global nvar>>=
int	nvar;
@

<<global var>>=
Var	var[NVAR];
@


<<struct Var>>=
struct	Var
{
    Sym*	sym;
    //enum<sym_kind>
    char	symkind;
    //enum<type_kind>
    char	etype;
    long	offset;
};
@
% yet another etype

\subsection{[[Reg]]}

<<struct Reg>>=
struct	Reg
{
    long	pc;
    long	rpo;		/* reverse post ordering */

    Bits	set;
    Bits	use1;
    Bits	use2;

    Bits	refbehind;
    Bits	refahead;
    Bits	calbehind;
    Bits	calahead;
    Bits	regdiff;
    Bits	act;

    long	regu;
    long	loop;		/* could be shorter */

    
    Reg*	log5;
    long	active;

    Reg*	p1;
    Reg*	p2;
    Reg*	p2link;
    Reg*	s1;
    Reg*	s2;
    Reg*	link;

    Prog*	prog;
};
@


<<constant R>>=
#define	R	((Reg*)nil)
@


\subsection{[[XXX]]}

<<function rega>>=
Reg*
rega(void)
{
    Reg *r;

    r = freer;
    if(r == R) {
        r = alloc(sizeof(*r));
    } else
        freer = r->link;

    *r = zreg;
    return r;
}
@

<<function rcmp>>=
int
rcmp(const void *a1, const void *a2)
{
    Rgn *p1, *p2;
    int c1, c2;

    p1 = (Rgn*)a1;
    p2 = (Rgn*)a2;
    c1 = p2->cost;
    c2 = p1->cost;
    if(c1 -= c2)
        return c1;
    return p2->varno - p1->varno;
}
@


<<function LOAD(arm)>>=
#define	LOAD(r)		(~r->refbehind.b[z] & r->refahead.b[z])
@

<<function STORE(arm)>>=
#define	STORE(r)	(~r->calbehind.b[z] & r->calahead.b[z])
@




<<constant NRGN(arm)>>=
#define	NRGN	1000		/* was 600; raised for paranoia.c */
@

<<global region>>=
Rgn	region[NRGN];
@

<<global rgp>>=
Rgn*	rgp;
@

<<struct Rgn>>=
struct	Rgn
{
    Reg*	enter;
    short	cost;
    short	varno;
    short	regno;
};
@

<<global nregion>>=
int	nregion;
@




<<function addsplits(arm)>>=
void
addsplits(void)
{
    Reg *r, *r1;
    int z, i;
    Bits bit;

    for(r = firstr; r != R; r = r->link) {
        if(r->loop > 1)
            continue;
        if(r->prog->as == ABL)
            continue;
        for(r1 = r->p2; r1 != R; r1 = r1->p2link) {
            if(r1->loop <= 1)
                continue;
            for(z=0; z<BITS; z++)
                bit.b[z] = r1->calbehind.b[z] &
                    (r->refahead.b[z] | r->use1.b[z] | r->use2.b[z]) &
                    ~(r->calahead.b[z] & addrs.b[z]);
            while(bany(&bit)) {
                i = bnum(bit);
                bit.b[i/32] &= ~(1L << (i%32));
            }
        }
    }
}
@

<<function addmove(arm)>>=
/*
 * add mov b,rn
 * just after r
 */
void
addmove(Reg *r, int bn, int rn, int f)
{
    Prog *p, *p1;
    Adr *a;
    Var *v;

    p1 = alloc(sizeof(Prog));
    *p1 = zprog;
    p = r->prog;

    p1->link = p->link;
    p->link = p1;
    p1->lineno = p->lineno;

    v = var + bn;

    a = &p1->to;
    a->sym = v->sym;
    a->symkind = v->symkind;
    a->offset = v->offset;
    a->etype = v->etype;
    a->type = D_OREG;
    if(v->etype == TARRAY || a->sym == S)
        a->type = D_CONST;

    p1->as = AMOVW;
    if(v->etype == TCHAR || v->etype == TUCHAR)
        p1->as = AMOVB;
    if(v->etype == TSHORT || v->etype == TUSHORT)
        p1->as = AMOVH;
    if(v->etype == TFLOAT)
        p1->as = AMOVF;
    if(v->etype == TDOUBLE)
        p1->as = AMOVD;

    p1->from.type = D_REG;
    p1->from.reg = rn;
    if(rn >= NREG) {
        p1->from.type = D_FREG;
        p1->from.reg = rn-NREG;
    }
    if(!f) {
        p1->from = *a;
        *a = zprog.from;
        a->type = D_REG;
        a->reg = rn;
        if(rn >= NREG) {
            a->type = D_FREG;
            a->reg = rn-NREG;
        }
        if(v->etype == TUCHAR)
            p1->as = AMOVBU;
        if(v->etype == TUSHORT)
            p1->as = AMOVHU;
    }
    if(debug['R'])
        print("%P\t.a%P\n", p, p1);
}
@




<<function mkvar(arm)>>=
Bits
mkvar(Adr *a, int docon)
{
    Var *v;
    int i, n, z;
    long o;
    Bits bit;
    Sym *s;
    //enum<operand_kind>
    int t;
    //enum<type_kind>
    int et;

    t = a->type;
    if(t == D_REG && a->reg != R_NONE)
        regbits |= RtoB(a->reg);
    if(t == D_FREG && a->reg != R_NONE)
        regbits |= FtoB(a->reg);
    s = a->sym;
    o = a->offset;
    et = a->etype;
    if(s == S) {
        if(t != D_CONST || !docon || a->reg != R_NONE)
            goto none;
        et = TLONG;
    }
    if(t == D_CONST) {
        if(s == S && sval(o))
            goto none;
    }

    n = a->symkind;
    v = var;
    for(i=0; i<nvar; i++) {
        if(s == v->sym)
        if(n == v->symkind)
        if(o == v->offset)
            goto out;
        v++;
    }
    if(s)
        if(s->name[0] == '.')
            goto none;
    if(nvar >= NVAR) {
        if(debug['w'] > 1 && s)
            warn(Z, "variable not optimized: %s", s->name);
        goto none;
    }
    i = nvar;
    nvar++;
    v = &var[i];
    v->sym = s;
    v->offset = o;
    v->etype = et;
    v->symkind = n;
    if(debug['R'])
        print("bit=%2d et=%2d %D\n", i, et, a);
out:
    bit = blsh(i);
    if(n == D_EXTERN || n == D_STATIC)
        for(z=0; z<BITS; z++)
            externs.b[z] |= bit.b[z];
    if(n == D_PARAM)
        for(z=0; z<BITS; z++)
            params.b[z] |= bit.b[z];
    if(v->etype != et || !typechlpfd[et])	/* funny punning */
        for(z=0; z<BITS; z++)
            addrs.b[z] |= bit.b[z];
    if(t == D_CONST) {
        if(s == S) {
            for(z=0; z<BITS; z++)
                consts.b[z] |= bit.b[z];
            return bit;
        }
        if(et != TARRAY)
            for(z=0; z<BITS; z++)
                addrs.b[z] |= bit.b[z];
        for(z=0; z<BITS; z++)
            params.b[z] |= bit.b[z];
        return bit;
    }
    if(t == D_OREG)
        return bit;

none:
    return zbits;
}
@

<<function sval(arm)>>=
int
sval(long v)
{
    int i;

    for(i=0; i<16; i++) {
        if((v & ~0xff) == 0)
            return 1;
        if((~v & ~0xff) == 0)
            return 1;
        v = (v<<2) | ((ulong)v>>30);
    }
    return 0;
}
@



<<function prop(arm)>>=
void
prop(Reg *r, Bits ref, Bits cal)
{
    Reg *r1, *r2;
    int z;

    for(r1 = r; r1 != R; r1 = r1->p1) {
        for(z=0; z<BITS; z++) {
            ref.b[z] |= r1->refahead.b[z];
            if(ref.b[z] != r1->refahead.b[z]) {
                r1->refahead.b[z] = ref.b[z];
                change++;
            }
            cal.b[z] |= r1->calahead.b[z];
            if(cal.b[z] != r1->calahead.b[z]) {
                r1->calahead.b[z] = cal.b[z];
                change++;
            }
        }
        switch(r1->prog->as) {
        case ABL:
            for(z=0; z<BITS; z++) {
                cal.b[z] |= ref.b[z] | externs.b[z];
                ref.b[z] = 0;
            }
            break;

        case ATEXT:
            for(z=0; z<BITS; z++) {
                cal.b[z] = 0;
                ref.b[z] = 0;
            }
            break;

        case ARET:
            for(z=0; z<BITS; z++) {
                cal.b[z] = externs.b[z];
                ref.b[z] = 0;
            }
        }
        for(z=0; z<BITS; z++) {
            ref.b[z] = (ref.b[z] & ~r1->set.b[z]) |
                r1->use1.b[z] | r1->use2.b[z];
            cal.b[z] &= ~(r1->set.b[z] | r1->use1.b[z] | r1->use2.b[z]);
            r1->refbehind.b[z] = ref.b[z];
            r1->calbehind.b[z] = cal.b[z];
        }
        if(r1->active)
            break;
        r1->active = 1;
    }
    for(; r != r1; r = r->p1)
        for(r2 = r->p2; r2 != R; r2 = r2->p2link)
            prop(r2, r->refbehind, r->calbehind);
}
@
% 386 only diff is ABL -> ACALL

<<function rpolca>>=
long
rpolca(long *idom, long rpo1, long rpo2)
{
    long t;

    if(rpo1 == -1)
        return rpo2;
    while(rpo1 != rpo2){
        if(rpo1 > rpo2){
            t = rpo2;
            rpo2 = rpo1;
            rpo1 = t;
        }
        while(rpo1 < rpo2){
            t = idom[rpo2];
            if(t >= rpo2)
                fatal(Z, "bad idom");
            rpo2 = t;
        }
    }
    return rpo1;
}
@

<<function doms>>=
int
doms(long *idom, long r, long s)
{
    while(s > r)
        s = idom[s];
    return s == r;
}
@

<<function loophead>>=
int
loophead(long *idom, Reg *r)
{
    long src;

    src = r->rpo;
    if(r->p1 != R && doms(idom, src, r->p1->rpo))
        return 1;
    for(r = r->p2; r != R; r = r->p2link)
        if(doms(idom, src, r->rpo))
            return 1;
    return 0;
}
@

<<constant LOOP(arm)>>=
#define	LOOP	3
@


<<function loopmark>>=
void
loopmark(Reg **rpo2r, long head, Reg *r)
{
    if(r->rpo < head || r->active == head)
        return;
    r->active = head;
    r->loop += LOOP;
    if(r->p1 != R)
        loopmark(rpo2r, head, r->p1);
    for(r = r->p2; r != R; r = r->p2link)
        loopmark(rpo2r, head, r);
}
@


<<global idom>>=
long*	idom;
@

<<global rpo2r>>=
Reg**	rpo2r;
@

<<global maxnr>>=
long	maxnr;
@


<<function loopit>>=
void
loopit(Reg *r, long nr)
{
    Reg *r1;
    long i, d, me;

    if(nr > maxnr) {
        rpo2r = alloc(nr * sizeof(Reg*));
        idom = alloc(nr * sizeof(long));
        maxnr = nr;
    }

    d = postorder(r, rpo2r, 0);
    if(d > nr)
        fatal(Z, "too many reg nodes");
    nr = d;
    for(i = 0; i < nr / 2; i++){
        r1 = rpo2r[i];
        rpo2r[i] = rpo2r[nr - 1 - i];
        rpo2r[nr - 1 - i] = r1;
    }
    for(i = 0; i < nr; i++)
        rpo2r[i]->rpo = i;

    idom[0] = 0;
    for(i = 0; i < nr; i++){
        r1 = rpo2r[i];
        me = r1->rpo;
        d = -1;
        if(r1->p1 != R && r1->p1->rpo < me)
            d = r1->p1->rpo;
        for(r1 = r1->p2; r1 != nil; r1 = r1->p2link)
            if(r1->rpo < me)
                d = rpolca(idom, d, r1->rpo);
        idom[i] = d;
    }

    for(i = 0; i < nr; i++){
        r1 = rpo2r[i];
        r1->loop++;
        if(r1->p2 != R && loophead(idom, r1))
            loopmark(rpo2r, i, r1);
    }
}
@

<<function synch>>=
void
synch(Reg *r, Bits dif)
{
    Reg *r1;
    int z;

    for(r1 = r; r1 != R; r1 = r1->s1) {
        for(z=0; z<BITS; z++) {
            dif.b[z] = (dif.b[z] &
                ~(~r1->refbehind.b[z] & r1->refahead.b[z])) |
                    r1->set.b[z] | r1->regdiff.b[z];
            if(dif.b[z] != r1->regdiff.b[z]) {
                r1->regdiff.b[z] = dif.b[z];
                change++;
            }
        }
        if(r1->active)
            break;
        r1->active = 1;
        for(z=0; z<BITS; z++)
            dif.b[z] &= ~(~r1->calbehind.b[z] & r1->calahead.b[z]);
        if(r1->s2 != R)
            synch(r1->s2, dif);
    }
}
@

<<function allreg(arm)>>=
ulong
allreg(ulong b, Rgn *r)
{
    Var *v;
    int i;

    v = var + r->varno;
    r->regno = 0;
    switch(v->etype) {

    case TCHAR:
    case TUCHAR:
    case TSHORT:
    case TUSHORT:
    case TINT:
    case TUINT:
    case TLONG:
    case TULONG:
    case TIND:
    case TARRAY:
        i = BtoR(~b);
        if(i && r->cost >= 0) {
            r->regno = i;
            return RtoB(i);
        }
        break;

    case TVLONG:
    case TDOUBLE:
    case TFLOAT:
        i = BtoF(~b);
        if(i && r->cost >= 0) {
            r->regno = i+NREG;
            return FtoB(i);
        }
        break;

    default:
        diag(Z, "unknown etype %d/%d", bitno(b), v->etype);
        break;

    }
    return 0;
}
@
% some tiny difference with 386

<<constant CLOAD(arm)>>=
#define	CLOAD	4
@

<<constant CREF(arm)>>=
#define	CREF	5
@


<<function paint1(arm)>>=
void
paint1(Reg *r, int bn)
{
    Reg *r1;
    Prog *p;
    int z;
    ulong bb;

    z = bn/32;
    bb = 1L<<(bn%32);
    if(r->act.b[z] & bb)
        return;
    for(;;) {
        if(!(r->refbehind.b[z] & bb))
            break;
        r1 = r->p1;
        if(r1 == R)
            break;
        if(!(r1->refahead.b[z] & bb))
            break;
        if(r1->act.b[z] & bb)
            break;
        r = r1;
    }

    if(LOAD(r) & ~(r->set.b[z] & ~(r->use1.b[z]|r->use2.b[z])) & bb) {
        change -= CLOAD * r->loop;
        if(debug['R'] && debug['v'])
            print("%ld%P\tld %B $%d\n", r->loop,
                r->prog, blsh(bn), change);
    }
    for(;;) {
        r->act.b[z] |= bb;
        p = r->prog;

        if(r->use1.b[z] & bb) {
            change += CREF * r->loop;
            if(debug['R'] && debug['v'])
                print("%ld%P\tu1 %B $%d\n", r->loop,
                    p, blsh(bn), change);
        }

        if((r->use2.b[z]|r->set.b[z]) & bb) {
            change += CREF * r->loop;
            if(debug['R'] && debug['v'])
                print("%ld%P\tu2 %B $%d\n", r->loop,
                    p, blsh(bn), change);
        }

        if(STORE(r) & r->regdiff.b[z] & bb) {
            change -= CLOAD * r->loop;
            if(debug['R'] && debug['v'])
                print("%ld%P\tst %B $%d\n", r->loop,
                    p, blsh(bn), change);
        }

        if(r->refbehind.b[z] & bb)
            for(r1 = r->p2; r1 != R; r1 = r1->p2link)
                if(r1->refahead.b[z] & bb)
                    paint1(r1, bn);

        if(!(r->refahead.b[z] & bb))
            break;
        r1 = r->s2;
        if(r1 != R)
            if(r1->refbehind.b[z] & bb)
                paint1(r1, bn);
        r = r->s1;
        if(r == R)
            break;
        if(r->act.b[z] & bb)
            break;
        if(!(r->refbehind.b[z] & bb))
            break;
    }
}
@
% 386 has a little bit more code with special case on AFMOVL

<<function paint2(arm)>>=
ulong
paint2(Reg *r, int bn)
{
    Reg *r1;
    int z;
    ulong bb, vreg;

    z = bn/32;
    bb = 1L << (bn%32);
    vreg = regbits;
    if(!(r->act.b[z] & bb))
        return vreg;
    for(;;) {
        if(!(r->refbehind.b[z] & bb))
            break;
        r1 = r->p1;
        if(r1 == R)
            break;
        if(!(r1->refahead.b[z] & bb))
            break;
        if(!(r1->act.b[z] & bb))
            break;
        r = r1;
    }
    for(;;) {
        r->act.b[z] &= ~bb;

        vreg |= r->regu;

        if(r->refbehind.b[z] & bb)
            for(r1 = r->p2; r1 != R; r1 = r1->p2link)
                if(r1->refahead.b[z] & bb)
                    vreg |= paint2(r1, bn);

        if(!(r->refahead.b[z] & bb))
            break;
        r1 = r->s2;
        if(r1 != R)
            if(r1->refbehind.b[z] & bb)
                vreg |= paint2(r1, bn);
        r = r->s1;
        if(r == R)
            break;
        if(!(r->act.b[z] & bb))
            break;
        if(!(r->refbehind.b[z] & bb))
            break;
    }
    return vreg;
}
@
% 386 has a bit of code before the return vreg
% >>


<<function paint3>>=
void
paint3(Reg *r, int bn, long rb, int rn)
{
    Reg *r1;
    Prog *p;
    int z;
    ulong bb;

    z = bn/32;
    bb = 1L << (bn%32);
    if(r->act.b[z] & bb)
        return;
    for(;;) {
        if(!(r->refbehind.b[z] & bb))
            break;
        r1 = r->p1;
        if(r1 == R)
            break;
        if(!(r1->refahead.b[z] & bb))
            break;
        if(r1->act.b[z] & bb)
            break;
        r = r1;
    }

    if(LOAD(r) & ~(r->set.b[z] & ~(r->use1.b[z]|r->use2.b[z])) & bb)
        addmove(r, bn, rn, 0);
    for(;;) {
        r->act.b[z] |= bb;
        p = r->prog;

        if(r->use1.b[z] & bb) {
            if(debug['R'])
                print("%P", p);
            addreg(&p->from, rn);
            if(debug['R'])
                print("\t.c%P\n", p);
        }
        if((r->use2.b[z]|r->set.b[z]) & bb) {
            if(debug['R'])
                print("%P", p);
            addreg(&p->to, rn);
            if(debug['R'])
                print("\t.c%P\n", p);
        }

        if(STORE(r) & r->regdiff.b[z] & bb)
            addmove(r, bn, rn, 1);
        r->regu |= rb;

        if(r->refbehind.b[z] & bb)
            for(r1 = r->p2; r1 != R; r1 = r1->p2link)
                if(r1->refahead.b[z] & bb)
                    paint3(r1, bn, rb, rn);

        if(!(r->refahead.b[z] & bb))
            break;
        r1 = r->s2;
        if(r1 != R)
            if(r1->refbehind.b[z] & bb)
                paint3(r1, bn, rb, rn);
        r = r->s1;
        if(r == R)
            break;
        if(r->act.b[z] & bb)
            break;
        if(!(r->refbehind.b[z] & bb))
            break;
    }
}
@
% >>

<<function addreg(arm)>>=
void
addreg(Adr *a, int rn)
{

    a->sym = 0;
    a->symkind = D_NONE;
    a->type = D_REG;
    a->reg = rn;
    if(rn >= NREG) {
        a->type = D_FREG;
        a->reg = rn-NREG;
    }
}
@

<<function RtoB(arm)>>=
/*
 *	bit	reg
 *	0	R0
 *	1	R1
 *	...	...
 *	10	R10
 */
long
RtoB(int r)
{

    if(r >= REGMIN && r <= REGMAX)
        return 1L << r;
    return 0;
}
@
% >> >>

<<function BtoR(arm)>>=
int
BtoR(long b)
{
    b &= 0x01fcL;	// excluded R9 and R10 for m and g
    if(b == 0)
        return 0;
    return bitno(b);
}
@

<<function FtoB(arm)>>=
/*
 *	bit	reg
 *	18	F2
 *	19	F3
 *	...	...
 *	23	F7
 */
long
FtoB(int f)
{

    if(f < 2 || f > NFREG-1)
        return 0;
    return 1L << (f + 16);
}
@
% >> >>

<<function BtoF(arm)>>=
int
BtoF(long b)
{

    b &= 0xfc0000L;
    if(b == 0)
        return 0;
    return bitno(b) - 16;
}
@



\section{Peephole optimizer, [[peep()]]}

% codgen -> regopt -> <>
<<function peep(arm)>>=
void
peep(void)
{
    Reg *r, *r1, *r2;
    Prog *p, *p1;
    int t;
/*
 * complete R structure
 */
    t = 0;
    for(r=firstr; r!=R; r=r1) {
        r1 = r->link;
        if(r1 == R)
            break;
        p = r->prog->link;
        while(p != r1->prog)
        switch(p->as) {
        default:
            r2 = rega();
            r->link = r2;
            r2->link = r1;

            r2->prog = p;
            r2->p1 = r;
            r->s1 = r2;
            r2->s1 = r1;
            r1->p1 = r2;

            r = r2;
            t++;

        case ADATA:
        case AGLOBL:
        case ANAME:
        case ASIGNAME:
            p = p->link;
        }
    }

loop1:
    t = 0;
    for(r=firstr; r!=R; r=r->link) {
        p = r->prog;
        if(p->as == ASLL || p->as == ASRL || p->as == ASRA) {
            /*
             * elide shift into D_SHIFT operand of subsequent instruction
             */
            if(shiftprop(r)) {
                excise(r);
                t++;
            }
        }
        if(p->as == AMOVW || p->as == AMOVF || p->as == AMOVD)
        if(regtyp(&p->to)) {
            if(p->from.type == D_CONST)
                constprop(&p->from, &p->to, r->s1);
            else if(regtyp(&p->from))
            if(p->from.type == p->to.type) {
                if(copyprop(r)) {
                    excise(r);
                    t++;
                } else
                if(subprop(r) && copyprop(r)) {
                    excise(r);
                    t++;
                }
            }
        }
    }
    if(t)
        goto loop1;
    /*
     * look for MOVB x,R; MOVB R,R
     */
    for(r=firstr; r!=R; r=r->link) {
        p = r->prog;
        switch(p->as) {
        default:
            continue;
        case AEOR:
            /*
             * EOR -1,x,y => MVN x,y
             */
            if(p->from.type == D_CONST && p->from.offset == -1) {
                p->as = AMVN;
                p->from.type = D_REG;
                if(p->reg != R_NONE)
                    p->from.reg = p->reg;
                else
                    p->from.reg = p->to.reg;
                p->reg = R_NONE;
            }
            continue;
        case AMOVH:
        case AMOVHU:
        case AMOVB:
        case AMOVBU:
            if(p->to.type != D_REG)
                continue;
            break;
        }
        r1 = r->link;
        if(r1 == R)
            continue;
        p1 = r1->prog;
        if(p1->as != p->as)
            continue;
        if(p1->from.type != D_REG || p1->from.reg != p->to.reg)
            continue;
        if(p1->to.type != D_REG || p1->to.reg != p->to.reg)
            continue;
        excise(r1);
    }

    for(r=firstr; r!=R; r=r->link) {
        p = r->prog;
        switch(p->as) {
        case AMOVW:
        case AMOVB:
        case AMOVBU:
            if(p->from.type == D_OREG && p->from.offset == 0)
                xtramodes(r, &p->from);
            else if(p->to.type == D_OREG && p->to.offset == 0)
                xtramodes(r, &p->to);
            else
                continue;
            break;
        case ACMP:
            /*
             * elide CMP $0,x if calculation of x can set condition codes
             */
            if(p->from.type != D_CONST || p->from.offset != 0)
                continue;
            r2 = r->s1;
            if(r2 == R)
                continue;
            t = r2->prog->as;
            switch(t) {
            default:
                continue;
            case ABEQ:
            case ABNE:
            case ABMI:
            case ABPL:
                break;
            case ABGE:
                t = ABPL;
                break;
            case ABLT:
                t = ABMI;
                break;
            case ABHI:
                t = ABNE;
                break;
            case ABLS:
                t = ABEQ;
                break;
            }
            r1 = r;
            do
                r1 = uniqp(r1);
            while (r1 != R && r1->prog->as == ANOP);
            if(r1 == R)
                continue;
            p1 = r1->prog;
            if(p1->to.type != D_REG)
                continue;
            if(p1->to.reg != p->reg)
            if(!(p1->as == AMOVW && p1->from.type == D_REG && p1->from.reg == p->reg))
                continue;
            switch(p1->as) {
            default:
                continue;
            case AMOVW:
                if(p1->from.type != D_REG)
                    continue;
            case AAND:
            case AEOR:
            case AORR:
            case ABIC:
            case AMVN:
            case ASUB:
            case ARSB:
            case AADD:
            case AADC:
            case ASBC:
            case ARSC:
                break;
            }
            p1->scond |= C_SBIT;
            r2->prog->as = t;
            excise(r);
            continue;
        }
    }

    predicate();
}
@
%$


<<function excise(arm)>>=
void
excise(Reg *r)
{
    Prog *p;

    p = r->prog;
    p->as = ANOP;
    p->scond = zprog.scond;
    p->from = zprog.from;
    p->to = zprog.to;
    p->reg = zprog.reg; /**/
}
@

<<function uniqp>>=
Reg*
uniqp(Reg *r)
{
    Reg *r1;

    r1 = r->p1;
    if(r1 == R) {
        r1 = r->p2;
        if(r1 == R || r1->p2link != R)
            return R;
    } else
        if(r->p2 != R)
            return R;
    return r1;
}
@

<<function uniqs>>=
Reg*
uniqs(Reg *r)
{
    Reg *r1;

    r1 = r->s1;
    if(r1 == R) {
        r1 = r->s2;
        if(r1 == R)
            return R;
    } else
        if(r->s2 != R)
            return R;
    return r1;
}
@

<<function regtyp(arm)>>=
int
regtyp(Adr *a)
{

    if(a->type == D_REG)
        return 1;
    if(a->type == D_FREG)
        return 1;
    return 0;
}
@

<<function subprop(arm)>>=
/*
 * the idea is to substitute
 * one register for another
 * from one MOV to another
 *	MOV	a, R0
 *	ADD	b, R0	/ no use of R1
 *	MOV	R0, R1
 * would be converted to
 *	MOV	a, R1
 *	ADD	b, R1
 *	MOV	R1, R0
 * hopefully, then the former or latter MOV
 * will be eliminated by copy propagation.
 */
int
subprop(Reg *r0)
{
    Prog *p;
    Adr *v1, *v2;
    Reg *r;
    int t;

    p = r0->prog;
    v1 = &p->from;
    if(!regtyp(v1))
        return 0;
    v2 = &p->to;
    if(!regtyp(v2))
        return 0;
    for(r=uniqp(r0); r!=R; r=uniqp(r)) {
        if(uniqs(r) == R)
            break;
        p = r->prog;
        switch(p->as) {
        case ABL:
            return 0;

        case ACMP:
        case ACMN:
        case AADD:
        case ASUB:
        case ARSB:
        case ASLL:
        case ASRL:
        case ASRA:
        case AORR:
        case AAND:
        case AEOR:
        case AMUL:
        case ADIV:
        case ADIVU:

        case ACMPF:
        case ACMPD:
        case AADDD:
        case AADDF:
        case ASUBD:
        case ASUBF:
        case AMULD:
        case AMULF:
        case ADIVD:
        case ADIVF:
            if(p->to.type == v1->type)
            if(p->to.reg == v1->reg) {
                if(p->reg == R_NONE)
                    p->reg = p->to.reg;
                goto gotit;
            }
            break;

        case AMOVF:
        case AMOVD:
        case AMOVW:
            if(p->to.type == v1->type)
            if(p->to.reg == v1->reg)
                goto gotit;
            break;

        case AMOVM:
            t = 1<<v2->reg;
            if((p->from.type == D_CONST && (p->from.offset&t)) ||
               (p->to.type == D_CONST && (p->to.offset&t)))
                return 0;
            break;
        }
        if(copyau(&p->from, v2) ||
           copyau1(p, v2) ||
           copyau(&p->to, v2))
            break;
        if(copysub(&p->from, v1, v2, 0) ||
           copysub1(p, v1, v2, 0) ||
           copysub(&p->to, v1, v2, 0))
            break;
    }
    return 0;

gotit:
    copysub(&p->to, v1, v2, 1);
    if(debug['P']) {
        print("gotit: %D->%D\n%P", v1, v2, r->prog);
        if(p->from.type == v2->type)
            print(" excise");
        print("\n");
    }
    for(r=uniqs(r); r!=r0; r=uniqs(r)) {
        p = r->prog;
        copysub(&p->from, v1, v2, 1);
        copysub1(p, v1, v2, 1);
        copysub(&p->to, v1, v2, 1);
        if(debug['P'])
            print("%P\n", r->prog);
    }
    t = v1->reg;
    v1->reg = v2->reg;
    v2->reg = t;
    if(debug['P'])
        print("%P last\n", r->prog);
    return 1;
}
@

<<function copyprop>>=
/*
 * The idea is to remove redundant copies.
 *	v1->v2	F=0
 *	(use v2	s/v2/v1/)*
 *	set v1	F=1
 *	use v2	return fail
 *	-----------------
 *	v1->v2	F=0
 *	(use v2	s/v2/v1/)*
 *	set v1	F=1
 *	set v2	return success
 */
int
copyprop(Reg *r0)
{
    Prog *p;
    Adr *v1, *v2;
    Reg *r;

    p = r0->prog;
    v1 = &p->from;
    v2 = &p->to;
    if(copyas(v1, v2))
        return 1;
    for(r=firstr; r!=R; r=r->link)
        r->active = 0;
    return copy1(v1, v2, r0->s1, 0);
}
@

<<function copy1>>=
int
copy1(Adr *v1, Adr *v2, Reg *r, int f)
{
    int t;
    Prog *p;

    if(r->active) {
        if(debug['P'])
            print("act set; return 1\n");
        return 1;
    }
    r->active = 1;
    if(debug['P'])
        print("copy %D->%D f=%d\n", v1, v2, f);
    for(; r != R; r = r->s1) {
        p = r->prog;
        if(debug['P'])
            print("%P", p);
        if(!f && uniqp(r) == R) {
            f = 1;
            if(debug['P'])
                print("; merge; f=%d", f);
        }
        t = copyu(p, v2, A);
        switch(t) {
        case 2:	/* rar, cant split */
            if(debug['P'])
                print("; %Drar; return 0\n", v2);
            return 0;

        case 3:	/* set */
            if(debug['P'])
                print("; %Dset; return 1\n", v2);
            return 1;

        case 1:	/* used, substitute */
        case 4:	/* use and set */
            if(f) {
                if(!debug['P'])
                    return 0;
                if(t == 4)
                    print("; %Dused+set and f=%d; return 0\n", v2, f);
                else
                    print("; %Dused and f=%d; return 0\n", v2, f);
                return 0;
            }
            if(copyu(p, v2, v1)) {
                if(debug['P'])
                    print("; sub fail; return 0\n");
                return 0;
            }
            if(debug['P'])
                print("; sub%D/%D", v2, v1);
            if(t == 4) {
                if(debug['P'])
                    print("; %Dused+set; return 1\n", v2);
                return 1;
            }
            break;
        }
        if(!f) {
            t = copyu(p, v1, A);
            if(!f && (t == 2 || t == 3 || t == 4)) {
                f = 1;
                if(debug['P'])
                    print("; %Dset and !f; f=%d", v1, f);
            }
        }
        if(debug['P'])
            print("\n");
        if(r->s2)
            if(!copy1(v1, v2, r->s2, f))
                return 0;
    }
    return 1;
}
@

<<function constprop(arm)>>=
/*
 * The idea is to remove redundant constants.
 *	$c1->v1
 *	($c1->v2 s/$c1/v1)*
 *	set v1  return
 * The v1->v2 should be eliminated by copy propagation.
 */
void
constprop(Adr *c1, Adr *v1, Reg *r)
{
    Prog *p;

    if(debug['C'])
        print("constprop %D->%D\n", c1, v1);
    for(; r != R; r = r->s1) {
        p = r->prog;
        if(debug['C'])
            print("%P", p);
        if(uniqp(r) == R) {
            if(debug['C'])
                print("; merge; return\n");
            return;
        }
        if(p->as == AMOVW && copyas(&p->from, c1)) {
                if(debug['C'])
                    print("; sub%D/%D", &p->from, v1);
                p->from = *v1;
        } else if(copyu(p, v1, A) > 1) {
            if(debug['C'])
                print("; %Dset; return\n", v1);
            return;
        }
        if(debug['C'])
            print("\n");
        if(r->s2)
            constprop(c1, v1, r->s2);
    }
}
@
%$

<<function FAIL(arm)>>=
/*
 * ASLL x,y,w
 * .. (not use w, not set x y w)
 * AXXX w,a,b (a != w)
 * .. (not use w)
 * (set w)
 * ----------- changed to
 * ..
 * AXXX (x<<y),a,b
 * ..
 */
#define FAIL(msg) { if(debug['H']) print("\t%s; FAILURE\n", msg); return 0; }
@

<<function shiftprop(arm)>>=
int
shiftprop(Reg *r)
{
    Reg *r1;
    Prog *p, *p1, *p2;
    int n, o;
    Adr a;

    p = r->prog;
    if(p->to.type != D_REG)
        FAIL("BOTCH: result not reg");
    n = p->to.reg;
    a = zprog.from;
    if(p->reg != R_NONE && p->reg != p->to.reg) {
        a.type = D_REG;
        a.reg = p->reg;
    }
    if(debug['H'])
        print("shiftprop\n%P", p);
    r1 = r;
    for(;;) {
        /* find first use of shift result; abort if shift operands or result are changed */
        r1 = uniqs(r1);
        if(r1 == R)
            FAIL("branch");
        if(uniqp(r1) == R)
            FAIL("merge");
        p1 = r1->prog;
        if(debug['H'])
            print("\n%P", p1);
        switch(copyu(p1, &p->to, A)) {
        case 0:	/* not used or set */
            if((p->from.type == D_REG && copyu(p1, &p->from, A) > 1) ||
               (a.type == D_REG && copyu(p1, &a, A) > 1))
                FAIL("args modified");
            continue;
        case 3:	/* set, not used */
            FAIL("BOTCH: noref");
        }
        break;
    }
    /* check whether substitution can be done */
    switch(p1->as) {
    default:
        FAIL("non-dpi");
    case AAND:
    case AEOR:
    case AADD:
    case AADC:
    case AORR:
    case ASUB:
    case ARSB:
    case ASBC:
    case ARSC:
        if(p1->reg == n || (p1->reg == R_NONE && p1->to.type == D_REG && p1->to.reg == n)) {
            if(p1->from.type != D_REG)
                FAIL("can't swap");
            p1->reg = p1->from.reg;
            p1->from.reg = n;
            switch(p1->as) {
            case ASUB:
                p1->as = ARSB;
                break;
            case ARSB:
                p1->as = ASUB;
                break;
            case ASBC:
                p1->as = ARSC;
                break;
            case ARSC:
                p1->as = ASBC;
                break;
            }
            if(debug['H'])
                print("\t=>%P", p1);
        }
    case ABIC:
    case ACMP:
    case ACMN:
        if(p1->reg == n)
            FAIL("can't swap");
        if(p1->reg == R_NONE && p1->to.reg == n)
            FAIL("shift result used twice");
    case AMVN:
        if(p1->from.type == D_SHIFT)
            FAIL("shift result used in shift");
        if(p1->from.type != D_REG || p1->from.reg != n)
            FAIL("BOTCH: where is it used?");
        break;
    }
    /* check whether shift result is used subsequently */
    p2 = p1;
    if(p1->to.reg != n)
    for (;;) {
        r1 = uniqs(r1);
        if(r1 == R)
            FAIL("inconclusive");
        p1 = r1->prog;
        if(debug['H'])
            print("\n%P", p1);
        switch(copyu(p1, &p->to, A)) {
        case 0:	/* not used or set */
            continue;
        case 3: /* set, not used */
            break;
        default:/* used */
            FAIL("reused");
        }
        break;
    }
    /* make the substitution */
    p2->from.type = D_SHIFT;
    p2->from.reg = R_NONE;
    o = p->reg;
    if(o == R_NONE)
        o = p->to.reg;
    switch(p->from.type){
    case D_CONST:
        o |= (p->from.offset&0x1f)<<7;
        break;
    case D_REG:
        o |= (1<<4) | (p->from.reg<<8);
        break;
    }
    switch(p->as){
    case ASLL:
        o |= 0<<5;
        break;
    case ASRL:
        o |= 1<<5;
        break;
    case ASRA:
        o |= 2<<5;
        break;
    }
    p2->from.offset = o;
    if(debug['H'])
        print("\t=>%P\tSUCCEED\n", p2);
    return 1;
}
@

<<function findpre(arm)>>=
Reg*
findpre(Reg *r, Adr *v)
{
    Reg *r1;

    for(r1=uniqp(r); r1!=R; r=r1,r1=uniqp(r)) {
        if(uniqs(r1) != r)
            return R;
        switch(copyu(r1->prog, v, A)) {
        case 1: /* used */
        case 2: /* read-alter-rewrite */
            return R;
        case 3: /* set */
        case 4: /* set and used */
            return r1;
        }
    }
    return R;
}
@

<<function findinc(arm)>>=
Reg*
findinc(Reg *r, Reg *r2, Adr *v)
{
    Reg *r1;
    Prog *p;


    for(r1=uniqs(r); r1!=R && r1!=r2; r=r1,r1=uniqs(r)) {
        if(uniqp(r1) != r)
            return R;
        switch(copyu(r1->prog, v, A)) {
        case 0: /* not touched */
            continue;
        case 4: /* set and used */
            p = r1->prog;
            if(p->as == AADD)
            if(p->from.type == D_CONST)
            if(p->from.offset > -4096 && p->from.offset < 4096)
                return r1;
        default:
            return R;
        }
    }
    return R;
}
@

<<function nochange(arm)>>=
int
nochange(Reg *r, Reg *r2, Prog *p)
{
    Adr a[3];
    int i, n;

    if(r == r2)
        return 1;
    n = 0;
    if(p->reg != R_NONE && p->reg != p->to.reg) {
        a[n].type = D_REG;
        a[n++].reg = p->reg;
    }
    switch(p->from.type) {
    case D_SHIFT:
        a[n].type = D_REG;
        a[n++].reg = p->from.offset&0xf;
    case D_REG:
        a[n].type = D_REG;
        a[n++].reg = p->from.reg;
    }
    if(n == 0)
        return 1;
    for(; r!=R && r!=r2; r=uniqs(r)) {
        p = r->prog;
        for(i=0; i<n; i++)
            if(copyu(p, &a[i], A) > 1)
                return 0;
    }
    return 1;
}
@

<<function findu1(arm)>>=
int
findu1(Reg *r, Adr *v)
{
    for(; r != R; r = r->s1) {
        if(r->active)
            return 0;
        r->active = 1;
        switch(copyu(r->prog, v, A)) {
        case 1: /* used */
        case 2: /* read-alter-rewrite */
        case 4: /* set and used */
            return 1;
        case 3: /* set */
            return 0;
        }
        if(r->s2)
            if (findu1(r->s2, v))
                return 1;
    }
    return 0;
}
@

<<function finduse(arm)>>=
int
finduse(Reg *r, Adr *v)
{
    Reg *r1;

    for(r1=firstr; r1!=R; r1=r1->link)
        r1->active = 0;
    return findu1(r, v);
}
@

<<function xtramodes(arm)>>=
int
xtramodes(Reg *r, Adr *a)
{
    Reg *r1, *r2, *r3;
    Prog *p, *p1;
    Adr v;

    p = r->prog;
    if(debug['h'] && p->as == AMOVB && p->from.type == D_OREG)	/* byte load */
        return 0;
    v = *a;
    v.type = D_REG;
    r1 = findpre(r, &v);
    if(r1 != R) {
        p1 = r1->prog;
        if(p1->to.type == D_REG && p1->to.reg == v.reg)
        switch(p1->as) {
        case AADD:
            if(p1->from.type == D_REG ||
               (p1->from.type == D_SHIFT && (p1->from.offset&(1<<4)) == 0 &&
                (p->as != AMOVB || (a == &p->from && (p1->from.offset&~0xf) == 0))) ||
               (p1->from.type == D_CONST && 
                p1->from.offset > -4096 && p1->from.offset < 4096))
            if(nochange(uniqs(r1), r, p1)) {
                if(a != &p->from || v.reg != p->to.reg)
                if (finduse(r->s1, &v)) {
                    if(p1->reg == R_NONE || p1->reg == v.reg)
                        /* pre-indexing */
                        p->scond |= C_WBIT;
                    else return 0;	
                }
                switch (p1->from.type) {
                case D_REG:
                    /* register offset */
                    a->type = D_SHIFT;
                    a->offset = p1->from.reg;
                    break;
                case D_SHIFT:
                    /* scaled register offset */
                    a->type = D_SHIFT;
                case D_CONST:
                    /* immediate offset */
                    a->offset = p1->from.offset;
                    break;
                }
                if(p1->reg != R_NONE)
                    a->reg = p1->reg;
                excise(r1);
                return 1;
            }
            break;
        case AMOVW:
            if(p1->from.type == D_REG)
            if((r2 = findinc(r1, r, &p1->from)) != R) {
            for(r3=uniqs(r2); r3->prog->as==ANOP; r3=uniqs(r3))
                ;
            if(r3 == r) {
                /* post-indexing */
                p1 = r2->prog;
                a->reg = p1->to.reg;
                a->offset = p1->from.offset;
                p->scond |= C_PBIT;
                if(!finduse(r, &r1->prog->to))
                    excise(r1);
                excise(r2);
                return 1;
            }
            }
            break;
        }
    }
    if(a != &p->from || a->reg != p->to.reg)
    if((r1 = findinc(r, R, &v)) != R) {
        /* post-indexing */
        p1 = r1->prog;
        a->offset = p1->from.offset;
        p->scond |= C_PBIT;
        excise(r1);
        return 1;
    }
    return 0;
}
@

<<function copyu(arm)>>=
/*
 * return
 * 1 if v only used (and substitute),
 * 2 if read-alter-rewrite
 * 3 if set
 * 4 if set and used
 * 0 otherwise (not touched)
 */
int
copyu(Prog *p, Adr *v, Adr *s)
{

    switch(p->as) {

    default:
        if(debug['P'])
            print(" (???)");
        return 2;

    case AMOVM:
        if(v->type != D_REG)
            return 0;
        if(p->from.type == D_CONST) {	/* read reglist, read/rar */
            if(s != A) {
                if(p->from.offset&(1<<v->reg))
                    return 1;
                if(copysub(&p->to, v, s, 1))
                    return 1;
                return 0;
            }
            if(copyau(&p->to, v)) {
                if(p->scond&C_WBIT)
                    return 2;
                return 1;
            }
            if(p->from.offset&(1<<v->reg))
                return 1;
        } else {			/* read/rar, write reglist */
            if(s != A) {
                if(p->to.offset&(1<<v->reg))
                    return 1;
                if(copysub(&p->from, v, s, 1))
                    return 1;
                return 0;
            }
            if(copyau(&p->from, v)) {
                if(p->scond&C_WBIT)
                    return 2;
                if(p->to.offset&(1<<v->reg))
                    return 4;
                return 1;
            }
            if(p->to.offset&(1<<v->reg))
                return 3;
        }
        return 0;
        
    case ANOP:	/* read, write */
    case AMOVW:
    case AMOVF:
    case AMOVD:
    case AMOVH:
    case AMOVHU:
    case AMOVB:
    case AMOVBU:
    case AMOVDW:
    case AMOVWD:
    case AMOVFD:
    case AMOVDF:
        if(p->scond&(C_WBIT|C_PBIT))
        if(v->type == D_REG) {
            if(p->from.type == D_OREG || p->from.type == D_SHIFT) {
                if(p->from.reg == v->reg)
                    return 2;
            } else {
            if(p->to.reg == v->reg)
                return 2;
            }
        }
        if(s != A) {
            if(copysub(&p->from, v, s, 1))
                return 1;
            if(!copyas(&p->to, v))
                if(copysub(&p->to, v, s, 1))
                    return 1;
            return 0;
        }
        if(copyas(&p->to, v)) {
            if(copyau(&p->from, v))
                return 4;
            return 3;
        }
        if(copyau(&p->from, v))
            return 1;
        if(copyau(&p->to, v))
            return 1;
        return 0;


    case AADD:	/* read, read, write */
    case ASUB:
    case ARSB:
    case ASLL:
    case ASRL:
    case ASRA:
    case AORR:
    case AAND:
    case AEOR:
    case AMUL:
    case ADIV:
    case ADIVU:
    case AADDF:
    case AADDD:
    case ASUBF:
    case ASUBD:
    case AMULF:
    case AMULD:
    case ADIVF:
    case ADIVD:

    case ACMPF:
    case ACMPD:
    case ACMP:
    case ACMN:
    case ACASE:
        if(s != A) {
            if(copysub(&p->from, v, s, 1))
                return 1;
            if(copysub1(p, v, s, 1))
                return 1;
            if(!copyas(&p->to, v))
                if(copysub(&p->to, v, s, 1))
                    return 1;
            return 0;
        }
        if(copyas(&p->to, v)) {
            if(p->reg == R_NONE)
                p->reg = p->to.reg;
            if(copyau(&p->from, v))
                return 4;
            if(copyau1(p, v))
                return 4;
            return 3;
        }
        if(copyau(&p->from, v))
            return 1;
        if(copyau1(p, v))
            return 1;
        if(copyau(&p->to, v))
            return 1;
        return 0;

    case ABEQ:	/* read, read */
    case ABNE:
    case ABHS:
    case ABLO:
    case ABMI:
    case ABPL:
    case ABVS:
    case ABVC:
    case ABHI:
    case ABLS:
    case ABGE:
    case ABLT:
    case ABGT:
    case ABLE:
        if(s != A) {
            if(copysub(&p->from, v, s, 1))
                return 1;
            return copysub1(p, v, s, 1);
        }
        if(copyau(&p->from, v))
            return 1;
        if(copyau1(p, v))
            return 1;
        return 0;

    case AB:	/* funny */
        if(s != A) {
            if(copysub(&p->to, v, s, 1))
                return 1;
            return 0;
        }
        if(copyau(&p->to, v))
            return 1;
        return 0;

    case ARET:	/* funny */
        if(v->type == D_REG)
        if(v->reg == REGRET)
            return 2;
        if(v->type == D_FREG)
        if(v->reg == FREGRET)
            return 2;

    case ABL:	/* funny */
        if(v->type == D_REG) {
            if(v->reg <= REGEXT && v->reg > exregoffset)
                return 2;
            if(v->reg == (uchar)REGARG)
                return 2;
        }
        if(v->type == D_FREG)
            if(v->reg <= FREGEXT && v->reg > exfregoffset)
                return 2;

        if(s != A) {
            if(copysub(&p->to, v, s, 1))
                return 1;
            return 0;
        }
        if(copyau(&p->to, v))
            return 4;
        return 3;

    case ATEXT:	/* funny */
        if(v->type == D_REG)
            if(v->reg == (uchar)REGARG)
                return 3;
        return 0;
    }
}
@

<<function a2type(arm)>>=
int
a2type(Prog *p)
{

    switch(p->as) {

    case ACMP:
    case ACMN:

    case AADD:
    case ASUB:
    case ARSB:
    case ASLL:
    case ASRL:
    case ASRA:
    case AORR:
    case AAND:
    case AEOR:
    case AMUL:
    case ADIV:
    case ADIVU:
        return D_REG;

    case ACMPF:
    case ACMPD:

    case AADDF:
    case AADDD:
    case ASUBF:
    case ASUBD:
    case AMULF:
    case AMULD:
    case ADIVF:
    case ADIVD:
        return D_FREG;
    }
    return D_NONE;
}
@

<<function copyas(arm)>>=
/*
 * direct reference,
 * could be set/use depending on
 * semantics
 */
int
copyas(Adr *a, Adr *v)
{

    if(regtyp(v)) {
        if(a->type == v->type)
        if(a->reg == v->reg)
            return 1;
    } else if(v->type == D_CONST) {		/* for constprop */
        if(a->type == v->type)
        if(a->symkind == v->symkind)
        if(a->sym == v->sym)
        if(a->reg == v->reg)
        if(a->offset == v->offset)
            return 1;
    }
    return 0;
}
@

<<function copyau(arm)>>=
/*
 * either direct or indirect
 */
int
copyau(Adr *a, Adr *v)
{

    if(copyas(a, v))
        return 1;
    if(v->type == D_REG) {
        if(a->type == D_OREG) {
            if(v->reg == a->reg)
                return 1;
        } else if(a->type == D_SHIFT) {
            if((a->offset&0xf) == v->reg)
                return 1;
            if((a->offset&(1<<4)) && (a->offset>>8) == v->reg)
                return 1;
        }
    }
    return 0;
}
@

<<function copyau1(arm)>>=
int
copyau1(Prog *p, Adr *v)
{

    if(regtyp(v)) {
        if(a2type(p) == v->type)
        if(p->reg == v->reg) {
            if(a2type(p) != v->type)
                print("botch a2type %P\n", p);
            return 1;
        }
    }
    return 0;
}
@

<<function copysub(arm)>>=
/*
 * substitute s for v in a
 * return failure to substitute
 */
int
copysub(Adr *a, Adr *v, Adr *s, int f)
{

    if(f)
    if(copyau(a, v)) {
        if(a->type == D_SHIFT) {
            if((a->offset&0xf) == v->reg)
                a->offset = (a->offset&~0xf)|s->reg;
            if((a->offset&(1<<4)) && (a->offset>>8) == v->reg)
                a->offset = (a->offset&~(0xf<<8))|(s->reg<<8);
        } else
            a->reg = s->reg;
    }
    return 0;
}
@

<<function copysub1(arm)>>=
int
copysub1(Prog *p1, Adr *v, Adr *s, int f)
{

    if(f)
    if(copyau1(p1, v))
        p1->reg = s->reg;
    return 0;
}
@

<<global predinfo(arm)>>=
struct {
    int opcode;
    int notopcode;
    int scond; 
    int notscond; 
} predinfo[]  = { 
    { ABEQ,	ABNE,	0x0,	0x1, }, 
    { ABNE,	ABEQ,	0x1,	0x0, }, 
    { ABHS,	ABLO,	0x2,	0x3, }, 
    { ABLO,	ABHS,	0x3,	0x2, }, 
    { ABMI,	ABPL,	0x4,	0x5, }, 
    { ABPL,	ABMI,	0x5,	0x4, }, 
    { ABVS,	ABVC,	0x6,	0x7, }, 
    { ABVC,	ABVS,	0x7,	0x6, }, 
    { ABHI,	ABLS,	0x8,	0x9, }, 
    { ABLS,	ABHI,	0x9,	0x8, }, 
    { ABGE,	ABLT,	0xA,	0xB, }, 
    { ABLT,	ABGE,	0xB,	0xA, }, 
    { ABGT,	ABLE,	0xC,	0xD, }, 
    { ABLE,	ABGT,	0xD,	0xC, }, 
}; 
@

<<enum _anon_(arm)>>=
enum {
    Join,
    Split,
    End,
    Branch,
    Setcond,
    Toolong
};
@

<<enum _anon_ (5c/peep.c)(arm)>>=
enum {
    Falsecond,
    Truecond,
    Delbranch,
    Keepbranch
};
@

<<function isbranch(arm)>>=
int 
isbranch(Prog *p)
{
    return (ABEQ <= p->as) && (p->as <= ABLE); 
}
@

<<function predicable(arm)>>=
int
predicable(Prog *p)
{
    if (isbranch(p)
        || p->as == ANOP
        || p->as == AXXX
        || p->as == ADATA
        || p->as == AGLOBL
        || p->as == AGOK
        || p->as == AHISTORY
        || p->as == ANAME
        || p->as == ASIGNAME
        || p->as == ATEXT
        || p->as == AWORD
        || p->as == ADYNT
        || p->as == AINIT
        || p->as == ABCASE
        || p->as == ACASE)
        return 0; 
    return 1; 
}
@

<<function modifiescpsr(arm)>>=
/* 
 * Depends on an analysis of the encodings performed by 5l. 
 * These seem to be all of the opcodes that lead to the "S" bit
 * being set in the instruction encodings. 
 * 
 * C_SBIT may also have been set explicitly in p->scond.
 */ 
int
modifiescpsr(Prog *p)
{
    return (p->scond&C_SBIT)
        || p->as == ATST 
        || p->as == ATEQ 
        || p->as == ACMN
        || p->as == ACMP
        || p->as == AMULU
        || p->as == ADIVU
        || p->as == AMUL
        || p->as == ADIV
        || p->as == AMOD
        || p->as == AMODU
        || p->as == ABL;
} 
@

<<struct Joininfo>>=
typedef struct Joininfo {
    Reg *start;
    Reg *last;
    Reg *end;
    int len;
} Joininfo;
@

<<function joinsplit(arm)>>=
/*
 * Find the maximal chain of instructions starting with r which could
 * be executed conditionally
 */
int
joinsplit(Reg *r, Joininfo *j)
{
    j->start = r;
    j->last = r;
    j->len = 0;
    do {
        if (r->p2 && (r->p1 || r->p2->p2link)) {
            j->end = r;
            return Join;
        }
        if (r->s1 && r->s2) {
            j->end = r;
            return Split;
        }
        j->last = r;
        if (r->prog->as != ANOP)
            j->len++;
        if (!r->s1 && !r->s2) {
            j->end = r->link;
            return End;
        }
        if (r->s2) {
            j->end = r->s2;
            return Branch;
        }
        if (modifiescpsr(r->prog)) {
            j->end = r->s1;
            return Setcond;
        }
        r = r->s1;
    } while (j->len < 4);
    j->end = r;
    return Toolong;
}
@

<<function successor(arm)>>=
Reg *
successor(Reg *r)
{
    if (r->s1)
        return r->s1; 
    else
        return r->s2; 
}
@

<<function applypred(arm)>>=
void
applypred(Reg *rstart, Joininfo *j, int cond, int branch)
{
    int pred; 
    Reg *r; 

    if(j->len == 0)
        return;
    if (cond == Truecond)
        pred = predinfo[rstart->prog->as - ABEQ].scond;
    else
        pred = predinfo[rstart->prog->as - ABEQ].notscond; 
    
    for (r = j->start; ; r = successor(r)) {
        if (r->prog->as == AB) {
            if (r != j->last || branch == Delbranch)
                excise(r);
            else {
              if (cond == Truecond)
                r->prog->as = predinfo[rstart->prog->as - ABEQ].opcode;
              else
                r->prog->as = predinfo[rstart->prog->as - ABEQ].notopcode;
            }
        }
        else if (predicable(r->prog)) 
            r->prog->scond = (r->prog->scond&~C_SCOND)|pred;
        if (r->s1 != r->link) {
            r->s1 = r->link;
            r->link->p1 = r;
        }
        if (r == j->last)
            break;
    }
}
@

<<function predicate(arm)>>=
void
predicate(void)
{	
    Reg *r;
    int t1, t2;
    Joininfo j1, j2;

    for(r=firstr; r!=R; r=r->link) {
        if (isbranch(r->prog)) {
            t1 = joinsplit(r->s1, &j1);
            t2 = joinsplit(r->s2, &j2);
            if(j1.last->link != j2.start)
                continue;
            if(j1.end == j2.end)
            if((t1 == Branch && (t2 == Join || t2 == Setcond)) ||
               (t2 == Join && (t1 == Join || t1 == Setcond))) {
                applypred(r, &j1, Falsecond, Delbranch);
                applypred(r, &j2, Truecond, Delbranch);
                excise(r);
                continue;
            }
            if(t1 == End || t1 == Branch) {
                applypred(r, &j1, Falsecond, Keepbranch);
                excise(r);
                continue;
            }
        } 
    } 
}
@


\section{Dominators}

<<function postorder>>=
/*
 * find looping structure
 *
 * 1) find reverse postordering
 * 2) find approximate dominators,
 *	the actual dominators if the flow graph is reducible
 *	otherwise, dominators plus some other non-dominators.
 *	See Matthew S. Hecht and Jeffrey D. Ullman,
 *	"Analysis of a Simple Algorithm for Global Data Flow Problems",
 *	Conf.  Record of ACM Symp. on Principles of Prog. Langs, Boston, Massachusetts,
 *	Oct. 1-3, 1973, pp.  207-217.
 * 3) find all nodes with a predecessor dominated by the current node.
 *	such a node is a loop head.
 *	recursively, all preds with a greater rpo number are in the loop
 */
long
postorder(Reg *r, Reg **rpo2r, long n)
{
    Reg *r1;

    r->rpo = 1;
    r1 = r->s1;
    if(r1 && !r1->rpo)
        n = postorder(r1, rpo2r, n);
    r1 = r->s2;
    if(r1 && !r1->rpo)
        n = postorder(r1, rpo2r, n);
    rpo2r[n] = r;
    n++;
    return n;
}
@




\chapter{Linking Support}

\section{[[#pragma lib]] and automagic linking}



\section{Safe linking with type signatures, [[5c -T]]}
% md5sum like in ocaml!

% signature! for safe linking
<<enum signature>>=
enum signature {
    SIGNONE = 0,
    SIGDONE = 1,
    SIGINTERN = 2,

    // ???
    SIGNINTERN = 1729*325*1729,
};
@

<<[[Sym]] identifier value, code generation fields>>=
// enum<signature>
char	sig;
@
% SIGNINTERN does not fit in a char ...



<<[[zname()]] if generate signature for symbol s>>=
if(debug['T'] && 
   t == D_EXTERN && 
   s->sig != SIGDONE && 
   s->type != types[TENUM] && 
   s != symrathole){

    sig = sign(s);
    bf[0] = ASIGNAME;
    bf[1] = sig;
    bf[2] = sig>>8;
    bf[3] = sig>>16;
    bf[4] = sig>>24;
    bf[5] = t;
    bf[6] = s->symidx;
    Bwrite(b, bf, 7);
    s->sig = SIGDONE;
}
@


% main -> compile -> gclean -> outcode -> zname -> <>
<<function sign>>=
ulong
sign(Sym *s)
{
    ulong v;
    Type *t;

    if(s->sig == SIGINTERN)
        return SIGNINTERN;
    if((t = s->type) == T)
        return 0;
    v = signature(t);
    if(v == 0)
        v = SIGNINTERN;
    return v;
}
@

% sign -> <>
<<function signature>>=
ulong
signature(Type *t)
{
    ulong s;
    Typetab tt;

    tt.n = 0;
    tt.a = nil;
    s = signat(t, &tt);
    free(tt.a);
    return s;
}
@

% sign -> signature -> <>
<<function signat>>=
static ulong
signat(Type *t, Typetab *tt)
{
    int i;
    Type *t1;
    long s;

    s = 0;
    for(; t; t=t->link) {
        s = s*thash1 + thash[t->etype];
        if(t->garb&GINCOMPLETE)
            return s;
        switch(t->etype) {
        case TARRAY:
            s = s*thash2 + 0;	/* was t->width */
            break;
        case TFUNC:
            for(t1=t->down; t1; t1=t1->down)
                s = s*thash3 + signat(t1, tt);
            break;
        case TSTRUCT:
        case TUNION:
            if((i = sigind(t, tt)) >= 0){
                s = s*thash2 + i;
                return s;
            }
            for(t1=t->link; t1; t1=t1->down)
                s = s*thash3 + signat(t1, tt);
            return s;
        case TIND:
            break;
        default:
            return s;
        }
    }
    return s;
}
@



<<global thash1>>=
ulong	thash1	= 0x2edab8c9;
@

<<global thash2>>=
ulong	thash2	= 0x1dc74fb8;
@

<<global thash3>>=
ulong	thash3	= 0x1f241331;
@

<<global thash>>=
ulong	thash[NALLTYPES];
@

<<global thashinit>>=
Init	thashinit[] =
{
    TXXX,		0x17527bbd,	0,

    TCHAR,		0x5cedd32b,	0,
    TUCHAR,		0x552c4454,	0,
    TSHORT,		0x63040b4b,	0,
    TUSHORT,	0x32a45878,	0,
    TINT,		0x4151d5bd,	0,
    TUINT,		0x5ae707d6,	0,
    TLONG,		0x5ef20f47,	0,
    TULONG,		0x36d8eb8f,	0,
    TVLONG,		0x6e5e9590,	0,
    TUVLONG,	0x75910105,	0,
    TFLOAT,		0x25fd7af1,	0,
    TDOUBLE,	0x7c40a1b2,	0,

    TIND,		0x1b832357,	0,
    TFUNC,		0x6babc9cb,	0,
    TARRAY,		0x7c50986d,	0,
    TVOID,		0x44112eff,	0,
    TSTRUCT,	0x7c2da3bf,	0,
    TUNION,		0x3eb25e98,	0,
    TENUM,		0x44b54f61,	0,

    TOLD,		0x22b15988,	0,
    TDOT,		0x0204f6b3,	0,

    -1,		0,		0,
};
@

% in tinit section for now
%<<[[tinit()]] initialise thash>>=
%for(p=thashinit; p->code >= 0; p++) {
%    urk("thash", nelem(thash), p->code);
%    thash[p->code] = p->value;
%}
%@



<<struct Typetab>>=
struct Typetab {
    int n;
    Type **a;
};
@

% signat -> <>
<<function sigind>>=
static int
sigind(Type *t, Typetab *tt)
{
    int n;
    Type **a, **na, **p, **e;

    n = tt->n;
    a = tt->a;
    e = a+n;
    /* linear search seems ok */
    for(p = a ; p < e; p++)
        if(sametype(*p, t))
            return p-a;
    if((n&15) == 0){
        na = malloc((n+16)*sizeof(Type*));
        memmove(na, a, n*sizeof(Type*));
        free(a);
        a = tt->a = na;
    }
    a[tt->n++] = t;
    return -1;
}
@





\chapter{Debugging Support}

\section{General debugging metadata}
% Instruction origin location?

% have lineno field in generated object that tracked
% back the lineno of the relevant C code.

\section{Acid debugger metadata, [[5c -a]]}

% 5c -a to print acid declarations
%  -n print acid to file
%  -s print structure offsets


%from rio mkfile:
%syms:V:
%	$CC -a $CFLAGS rio.c	> syms
%	$CC -aa $CFLAGS *.c 	>>syms


<<[[compile()]] if writing acid to standard output>>=
/*
 * if we're writing acid to standard output, don't keep scratching
 * outbuf.
 */
if((debug['a'] || debug['Z']) && !debug['n']) {
    if (first) {
        outfile = nil;
        Binit(&outbuf, dup(1, -1), OWRITE);
        dup(2, 1);
    }
} 
@

<<[[compile()]] adjust p for outfile if acid option>>=
if(debug['a'] && debug['n'])
    strcat(p, ".acid");
@

\subsection{Entities}

% doenum? | dodecl? -> <>
% exported in cc.h
<<function acidvar>>=
void
acidvar(Sym *s)
{
    int n;
    Io *i;
    Type *t;
    Sym *s1, *s2;

    if(!debug['a'] || debug['s'])
        return;
    if(debug['a'] > 1) {
        n = 0;
        for(i=iostack; i; i=i->link)
            n++;
        if(n > 1)
            return;
    }
    t = s->type;
    while(t && t->etype == TIND)
        t = t->link;
    if(t == T)
        return;
    if(t->etype == TENUM) {
        Bprint(&outbuf, "%s = ", amap(s->name));
        if(!typefd[t->etype])
            Bprint(&outbuf, "%lld;\n", s->vconst);
        else
            Bprint(&outbuf, "%f\n;", s->fconst);
        return;
    }
    if(!typesu[t->etype])
        return;
    s1 = acidsue(t->link);
    if(s1 == S)
        return;
    switch(s->class) {
    case CAUTO:
    case CPARAM:
        s2 = acidfun(thisfntype);
        if(s2)
            Bprint(&outbuf, "complex %s %s:%s;\n",
                amap(s1->name), amap(s2->name), amap(s->name));
        break;
    
    case CEXTERN:
    case CGLOBL:
    case CSTATIC: case CLOCAL:
        Bprint(&outbuf, "complex %s %s;\n",
            amap(s1->name), amap(s->name));
        break;
    }
}
@


<<function acidsue>>=
Sym*
acidsue(Type *t)
{
    int h;
    Sym *s;

    if(t != T)
    for(h=0; h<nelem(hash); h++)
        for(s = hash[h]; s != S; s = s->link)
            if(s->suetag && s->suetag->link == t)
                return s;
    return 0;
}
@

<<function acidfun>>=
Sym*
acidfun(Type *t)
{
    int h;
    Sym *s;

    for(h=0; h<nelem(hash); h++)
        for(s = hash[h]; s != S; s = s->link)
            if(s->type == t)
                return s;
    return 0;
}
@



<<global kwd>>=
static char *kwd[] =
{
    "$adt", "$aggr", "$append", "$builtin", "$complex", "$defn",
    "$delete", "$do", "$else", "$eval", "$head", "$if",
    "$local", "$loop", "$return", "$tail", "$then",
    "$union", "$whatis", "$while",
};
@
% compared to Pickle.kwd ? $builtin en plus?

<<function amap>>=
char*
amap(char *s)
{
    int i, bot, top, new;

    bot = 0;
    top = bot + nelem(kwd) - 1;
    while(bot <= top){
        new = bot + (top - bot)/2;
        i = strcmp(kwd[new]+1, s);
        if(i == 0)
            return kwd[new];

        if(i < 0)
            bot = new + 1;
        else
            top = new - 1;
    }
    return s;
}
@







\subsection{Structure/union definitions}

% called from sualign, so for struct and union
% exported in cc.h
<<function acidtype>>=
void
acidtype(Type *t)
{
    Sym *s;
    Type *l;
    Io *i;
    int n;
    char *an;

    if(!debug['a'])
        return;
    if(debug['a'] > 1) {
        n = 0;
        for(i=iostack; i; i=i->link)
            n++;
        if(n > 1)
            return;
    }
    s = acidsue(t->link);
    if(s == S)
        return;
    switch(t->etype) {
    case TUNION:
    case TSTRUCT:
        if(debug['s'])
            goto asmstr;
        an = amap(s->name);
        Bprint(&outbuf, "sizeof%s = %ld;\n", an, t->width);
        Bprint(&outbuf, "aggr %s\n{\n", an);
        for(l = t->link; l != T; l = l->down)
            acidmember(l, 0, 1);
        Bprint(&outbuf, "};\n\n");

        Bprint(&outbuf, "defn\n%s(addr) {\n\tcomplex %s addr;\n", an, an);
        for(l = t->link; l != T; l = l->down)
            acidmember(l, 0, 0);
        Bprint(&outbuf, "};\n\n");
        break;

    asmstr:
        if(s == S)
            break;
        for(l = t->link; l != T; l = l->down)
            if(l->sym != S)
                Bprint(&outbuf, "#define\t%s.%s\t%ld\n",
                    s->name,
                    l->sym->name,
                    l->offset);
        break;

    default:
        Bprint(&outbuf, "T%d\n", t->etype);
        return;

    }
}
@

<<global acidchar>>=
char	acidchar[NTYPE];
@

<<global acidcinit>>=
Init	acidcinit[] =
{
    TCHAR,		'C',	0,
    TUCHAR,		'b',	0,
    TSHORT,		'd',	0,
    TUSHORT,	'u',	0,
    TLONG,		'D',	0,
    TULONG,		'U',	0,
    TVLONG,		'V',	0,
    TUVLONG,	'W',	0,
    TFLOAT,		'f',	0,
    TDOUBLE,	'F',	0,
    TARRAY,		'a',	0,
    TIND,		'X',	0,
    -1,		0,	0,
};
@

<<function acidinit>>=
static void
acidinit(void)
{
    Init *p;

    for(p=acidcinit; p->code >= 0; p++)
        acidchar[p->code] = p->value;

    acidchar[TINT] = acidchar[TLONG];
    acidchar[TUINT] = acidchar[TULONG];
    if(types[TINT]->width != types[TLONG]->width) {
        acidchar[TINT] = acidchar[TSHORT];
        acidchar[TUINT] = acidchar[TUSHORT];
        if(types[TINT]->width != types[TSHORT]->width)
            warn(Z, "acidmember int not long or short");
    }
    if(types[TIND]->width == types[TUVLONG]->width)
        acidchar[TIND] = 'Y';
    
}
@

<<function acidmember>>=
void
acidmember(Type *t, long off, int flag)
{
    Sym *s, *s1;
    Type *l;
    static bool acidcharinit = false;

    if(acidcharinit == false) {
        acidinit();
        acidcharinit = true;
    }
    s = t->sym;
    switch(t->etype) {
    default:
        Bprint(&outbuf, "	T%d\n", t->etype);
        break;

    case TIND:
        if(s == S)
            break;
        if(flag) {
            for(l=t; l->etype==TIND; l=l->link)
                ;
            if(typesu[l->etype]) {
                s1 = acidsue(l->link);
                if(s1 != S) {
                    Bprint(&outbuf, "	'A' %s %ld %s;\n",
                        amap(s1->name),
                        t->offset+off, amap(s->name));
                    break;
                }
            }
        } else {
            Bprint(&outbuf,
                "\tprint(\"\t%s\t\", addr.%s\\X, \"\\n\");\n",
                amap(s->name), amap(s->name));
            break;
        }

    case TINT:
    case TUINT:
    case TCHAR:
    case TUCHAR:
    case TSHORT:
    case TUSHORT:
    case TLONG:
    case TULONG:
    case TVLONG:
    case TUVLONG:
    case TFLOAT:
    case TDOUBLE:
    case TARRAY:
        if(s == S)
            break;
        if(flag) {
            Bprint(&outbuf, "	'%c' %ld %s;\n",
            acidchar[t->etype], t->offset+off, amap(s->name));
        } else {
            Bprint(&outbuf, "\tprint(\"\t%s\t\", addr.%s, \"\\n\");\n",
                amap(s->name), amap(s->name));
        }
        break;

    case TSTRUCT:
    case TUNION:
        s1 = acidsue(t->link);
        if(s1 == S)
            break;
        if(flag) {
            if(s == S) {
                Bprint(&outbuf, "	{\n");
                for(l = t->link; l != T; l = l->down)
                    acidmember(l, t->offset+off, flag);
                Bprint(&outbuf, "	};\n");
            } else {
                Bprint(&outbuf, "	%s %ld %s;\n",
                    amap(s1->name),
                    t->offset+off, amap(s->name));
            }
        } else {
            if(s != S) {
                Bprint(&outbuf, "\tprint(\"%s %s {\\n\");\n",
                    amap(s1->name), amap(s->name));
                Bprint(&outbuf, "\t%s(addr.%s);\n",
                    amap(s1->name), amap(s->name));
                Bprint(&outbuf, "\tprint(\"}\\n\");\n");
            } else {
                Bprint(&outbuf, "\tprint(\"%s {\\n\");\n",
                    amap(s1->name));
                Bprint(&outbuf, "\t\t%s(addr+%ld);\n",
                    amap(s1->name), t->offset+off);
                Bprint(&outbuf, "\tprint(\"}\\n\");\n");
            }
        }
        break;
    }
}
@




\section{Pickle, [[5c -Z]]}

% 5c -Z  and -n create _picke.c


<<[[compile()]] adjust p for outfile if pickle option>>=
else if(debug['Z'] && debug['n'])
    strcat(p, "_pickle.c");
@

<<global kwd (cc/pickle.c)>>=
static char *kwd[] =
{
    "$adt", "$aggr", "$append", "$complex", "$defn",
    "$delete", "$do", "$else", "$eval", "$head", "$if",
    "$local", "$loop", "$return", "$tail", "$then",
    "$union", "$whatis", "$while",
};
@
%$

<<global picklestr>>=
static char picklestr[] = "\tpickle(s, un, ";
@

<<function pmap>>=
static char*
pmap(char *s)
{
    int i, bot, top, new;

    bot = 0;
    top = bot + nelem(kwd) - 1;
    while(bot <= top){
        new = bot + (top - bot)/2;
        i = strcmp(kwd[new]+1, s);
        if(i == 0)
            return kwd[new];

        if(i < 0)
            bot = new + 1;
        else
            top = new - 1;
    }
    return s;
}
@

<<function picklesue>>=
Sym*
picklesue(Type *t)
{
    int h;
    Sym *s;

    if(t != T)
    for(h=0; h<nelem(hash); h++)
        for(s = hash[h]; s != S; s = s->link)
            if(s->suetag && s->suetag->link == t)
                return s;
    return 0;
}
@

<<global picklechar>>=
char	picklechar[NTYPE];
@

<<global picklecinit>>=
Init	picklecinit[] =
{
    TCHAR,		'C',	0,
    TUCHAR,		'b',	0,
    TSHORT,		'd',	0,
    TUSHORT,		'u',	0,
    TLONG,		'D',	0,
    TULONG,		'U',	0,
    TVLONG,		'V',	0,
    TUVLONG,	'W',	0,
    TFLOAT,		'f',	0,
    TDOUBLE,		'F',	0,
    TARRAY,		'a',	0,
    TIND,		'X',	0,
    -1,		0,	0,
};
@

<<function pickleinit>>=
static void
pickleinit(void)
{
    Init *p;

    for(p=picklecinit; p->code >= 0; p++)
        picklechar[p->code] = p->value;

    picklechar[TINT] = picklechar[TLONG];
    picklechar[TUINT] = picklechar[TULONG];
    if(types[TINT]->width != types[TLONG]->width) {
        picklechar[TINT] = picklechar[TSHORT];
        picklechar[TUINT] = picklechar[TUSHORT];
        if(types[TINT]->width != types[TSHORT]->width)
            warn(Z, "picklemember int not long or short");
    }
    
}
@

<<function picklemember>>=
void
picklemember(Type *t, long off)
{
    Sym *s, *s1;
    static int picklecharinit = 0;

    if(picklecharinit == 0) {
        pickleinit();
        picklecharinit = 1;
    }
    s = t->sym;
    switch(t->etype) {
    default:
        Bprint(&outbuf, "	T%d\n", t->etype);
        break;

    case TIND:
        if(s == S)
            Bprint(&outbuf,
                "%s\"p\", (char*)addr+%ld+_i*%ld);\n",
                picklestr, t->offset+off, t->width);
        else
            Bprint(&outbuf,
                "%s\"p\", &addr->%s);\n",
                picklestr, pmap(s->name));
        break;

    case TINT:
    case TUINT:
    case TCHAR:
    case TUCHAR:
    case TSHORT:
    case TUSHORT:
    case TLONG:
    case TULONG:
    case TVLONG:
    case TUVLONG:
    case TFLOAT:
    case TDOUBLE:
        if(s == S)
            Bprint(&outbuf, "%s\"%c\", (char*)addr+%ld+_i*%ld);\n",
                picklestr, picklechar[t->etype], t->offset+off, t->width);
        else
            Bprint(&outbuf, "%s\"%c\", &addr->%s);\n",
                picklestr, picklechar[t->etype], pmap(s->name));
        break;
    case TARRAY:
        Bprint(&outbuf, "\tfor(_i = 0; _i < %ld; _i++) {\n\t",
            t->width/t->link->width);
        picklemember(t->link, t->offset+off);
        Bprint(&outbuf, "\t}\n\t_i = 0;\n\tUSED(_i);\n");
        break;

    case TSTRUCT:
    case TUNION:
        s1 = picklesue(t->link);
        if(s1 == S)
            break;
        if(s == S) {
            Bprint(&outbuf, "\tpickle_%s(s, un, (%s*)((char*)addr+%ld+_i*%ld));\n",
                pmap(s1->name), pmap(s1->name), t->offset+off, t->width);
        } else {
            Bprint(&outbuf, "\tpickle_%s(s, un, &addr->%s);\n",
                pmap(s1->name), pmap(s->name));
        }
        break;
    }
}
@

<<function pickletype>>=
void
pickletype(Type *t)
{
    Sym *s;
    Type *l;
    Io *i;
    int n;
    char *an;

    if(!debug['P'])
        return;
    if(debug['P'] > 1) {
        n = 0;
        for(i=iostack; i; i=i->link)
            n++;
        if(n > 1)
            return;
    }
    s = picklesue(t->link);
    if(s == S)
        return;
    switch(t->etype) {
    default:
        Bprint(&outbuf, "T%d\n", t->etype);
        return;

    case TUNION:
    case TSTRUCT:
        if(debug['s'])
            goto asmstr;
        an = pmap(s->name);

        Bprint(&outbuf, "void\npickle_%s(void *s, int un, %s *addr)\n{\n\tint _i = 0;\n\n\tUSED(_i);\n", an, an);
        for(l = t->link; l != T; l = l->down)
            picklemember(l, 0);
        Bprint(&outbuf, "}\n\n");
        break;
    asmstr:
        if(s == S)
            break;
        for(l = t->link; l != T; l = l->down)
            if(l->sym != S)
                Bprint(&outbuf, "#define\t%s.%s\t%ld\n",
                    s->name,
                    l->sym->name,
                    l->offset);
        break;
    }
}
@

%<<function picklefun>>=
%//Sym*
%//picklefun(Type *t)
%//{
%//    int h;
%//    Sym *s;
%//
%//    for(h=0; h<nelem(hash); h++)
%//        for(s = hash[h]; s != S; s = s->link)
%//            if(s->type == t)
%//                return s;
%//    return 0;
%//}
%@
%
%<<function picklevar>>=
%//void
%//picklevar(Sym *s)
%//{
%//    int n;
%//    Io *i;
%//    Type *t;
%//    Sym *s1, *s2;
%//
%//    if(!debug['P'] || debug['s'])
%//        return;
%//    if(debug['P'] > 1) {
%//        n = 0;
%//        for(i=iostack; i; i=i->link)
%//            n++;
%//        if(n > 1)
%//            return;
%//    }
%//    t = s->type;
%//    while(t && t->etype == TIND)
%//        t = t->link;
%//    if(t == T)
%//        return;
%//    if(t->etype == TENUM) {
%//        Bprint(&outbuf, "%s = ", pmap(s->name));
%//        if(!typefd[t->etype])
%//            Bprint(&outbuf, "%lld;\n", s->vconst);
%//        else
%//            Bprint(&outbuf, "%f\n;", s->fconst);
%//        return;
%//    }
%//    if(!typesu[t->etype])
%//        return;
%//    s1 = picklesue(t->link);
%//    if(s1 == S)
%//        return;
%//    switch(s->class) {
%//    case CAUTO:
%//    case CPARAM:
%//        s2 = picklefun(thisfntype);
%//        if(s2)
%//            Bprint(&outbuf, "complex %s %s:%s;\n",
%//                pmap(s1->name), pmap(s2->name), pmap(s->name));
%//        break;
%//    
%//    case CEXTERN:
%//    case CGLOBL:
%//    case CSTATIC: case CLOCAL:
%//        Bprint(&outbuf, "complex %s %s;\n",
%//            pmap(s1->name), pmap(s->name));
%//        break;
%//    }
%//}
%@


\chapter{Profiling Support}

% actually always true, only way to disable it is via pragma locally
<<global profileflg>>=
bool	profileflg;
@

<<[[main()]] remaining initialisation>>=
profileflg = true;	/* #pragma can turn it off */
@


<<[[gpseudo()]] if TEXT, set possible TEXT attributes>>=
if(a == ATEXT)
    p->reg = (profileflg ? 0 : NOPROF);
@


\chapter{Advanced Topics}

\section{Advanced C features}

\subsection{Local [[static]]}
% not really a C extension, but really sugar
% for what could be just a scoped global.


<<[[Storage_class]] cases>>=
CLOCAL, // local static
@
%todo: for static local, should be renamed?

% defs

<<[[adecl()]] adjust storage to CLOCAL if static local variable>>=
if(c == CSTATIC)
    c = CLOCAL;
@
% c gets propagated to s->class?

<<[[dodecl()]] case ONAME, if local static variable>>=
if(s->class == CLOCAL)
    s = mkstatic(s);
@
% adecl callback get called before this chunk! important

% uses

<<name rule, if local static variable>>=
if($1->class == CLOCAL)
    $1 = mkstatic($1);
@
%$

% sugar

% rename locals in global symbol table so have unique name with the block
<<function mkstatic>>=
Sym*
mkstatic(Sym *s)
{
    Sym *s1;

    if(s->class != CLOCAL) // should never happen, use errorexit()?
        return s;

    snprint(symb, NSYMB, "%s$%d", s->name, s->block);
    s1 = lookup();

    if(s1->class != CSTATIC) {
        s1->type = s->type;
        s1->offset = s->offset;
        s1->block = s->block;
        s1->class = CSTATIC;
    }
    return s1;
}
@

\subsection{Local [[volatile]]}

%todo: volatile means data can change outside.
% so if put a local in a register, and then read
% back from this register, this may be wrong, you
% want to read back from the address because it
% may have changed.

<<[[revertdcl()]] other locals>>=
Node *n1;
@

<<[[reverdcl()]] if volatile symbol>>=
if(s->type && (s->type->garb & GVOLATILE)) {
    // add USED(&local_volatile);
    n1 = new(ONAME, Z, Z);
    n1->sym = s;
    n1->type = s->type;
    n1->etype = (s->type != T) ? s->type->etype : TVOID;
    n1->xoffset = s->offset;
    n1->class = s->class;

    n1 = new(OADDR, n1, Z);
    n1 = new(OUSED, n1, Z);
    if(n == Z)
        n = n1;
    else
        n = new(OLIST, n1, n);
}
@

<<xdecl rule, adjust block body with possible hidden generated nodes>>=
if(n)
    $6 = new(OLIST, n, $6);
@

<<ulstmt rule, adjust block body with possible hidden generated nodes>>=
if(n)
    $$ = new(OLIST, n, $2);
@
%$

<<ulstmt rule, adjust forexpr with possible hidden generated nodes>>=
if(n){
    if($4)
        $4 = new(OLIST, n, $4);
    else
        $4 = n;
}
@

\subsection{Old style prototypes}
% not really an extension though


%todo: remove? old style decl?
<<parameter declarator rules>>=
/*
 * parameter declarator
 */
pdecl:
  /* empty */
|   pdecl ctlist pdlist ';'

pdlist:
    xdecor              { dodecl(pdecl, lastclass, lasttype, $1); }
|   pdlist ',' pdlist
@
%$
% this is old style? pre-ansi? can remove no?



<<[[Type_kind_bis]] misc cases>>=
TOLD,
@
% old style ansi declaration?


<<[[rsametype()]] continue if old style type>>=
if(t1->etype == TOLD) {
    t1 = t1->down;
    continue;
}
if(t2->etype == TOLD) {
    t2 = t2->down;
    continue;
}
@

<<constant OLDPROTO>>=
#define	OLDPROTO	2
@
% 1<<1

<<[[argmark()]] if old proto style>>=
if(pass != 0 && anyproto(n->right) == OLDPROTO) {
    t = typ(TFUNC, n->left->sym->type->link);
    t->down = typ(TOLD, T);
    t->down->down = ofnproto(n->right);
    tmerge(t, n->left->sym);
    n->left->sym->type = t;
}
@


<<function ofnproto>>=
Type*
ofnproto(Node *n)
{
    Type *tl, *tr, *t;

    if(n == Z)
        return T;
    switch(n->op) {
    case OLIST:
        tl = ofnproto(n->left);
        tr = ofnproto(n->right);
        if(tl == T)
            return tr;
        tl->down = tr;
        return tl;

    case ONAME:
        t = copytyp(n->sym->type);
        t->down = T;
        return t;
    }
    return T;
}
@
% old fn proto style?


<<constant ANSIPROTO>>=
#define	ANSIPROTO	1
@
%todo: remove, have just ANSIPROTO!

<<[[fnproto()]] old prototype style handling>>=
int r;

r = anyproto(n->right);
if(r == 0 || (r & OLDPROTO)) {
    if(r & ANSIPROTO)
        diag(n, "mixed ansi/old function declaration: %F", n->left);
    return T;
}
@

<<function anyproto>>=
bool
anyproto(Node *n)
{
    int r;

    r = false;

loop:
    if(n == Z)
        return r;
    switch(n->op) {
    case OLIST:
        r |= anyproto(n->left);
        n = n->right;
        goto loop;

    case ODOTDOT:
    case OPROTO:
        return r | ANSIPROTO;
    }
    return r | OLDPROTO;
}
@



\subsection{Bitfields}

% parsing

<<definition nodes>>=
OBIT,
@

<<edecor rule>>=
|   tag ':' lexpr   { $$ = new(OBIT, $1, $3); }
|   ':' lexpr       { $$ = new(OBIT, Z, $2); }
@
%$

<<[[dodecl()]] switch node kind cases>>=
case OBIT:
    n1 = n->right;
    complex(n1);
    lastfield = -1;
    if(n1->op == OCONST)
        lastfield = n1->vconst;
    if(lastfield < 0) {
        diag(n, "field width must be non-negative constant");
        lastfield = 1;
    }
    if(lastfield == 0) {
        lastbit = 0;
        firstbit = 1;
        if(n->left != Z) {
            diag(n, "zero width named field");
            lastfield = 1;
        }
    }
    if(!typei[t->etype]) {
        diag(n, "field type must be int-like");
        t = types[TINT];
        lastfield = 1;
    }
    if(lastfield > tfield->width*8) {
        diag(n, "field width larger than field unit");
        lastfield = 1;
    }
    lastbit += lastfield;
    if(lastbit > tfield->width*8) {
        lastbit = lastfield;
        firstbit = 1;
    }
    n = n->left;
    goto loop;
@



%\subsection{Bitfield access}

% how can have this OBIT in an expression context?
% I think complex() explicitly mark expressions
% which are bitfields, e.g.  foo.x where x was a bitfield

<<[[cgenrel()]] switch node kind cases>>=
case OBIT:
    <<[[cgenrel()]] nullwarn check if nn is null, empty right>>
    bitload(n, &nod, Z, Z, nn);
    gopcode(OAS, &nod, Z, nn);
    regfree(&nod);
    break;
@

<<[[cgenrel()]] switch node kind cases>>=
asbitop:
    regalloc(&nod4, n, nn);
    if(l->complex >= r->complex) {
        bitload(l, &nod, &nod1, &nod2, &nod4);
        regalloc(&nod3, r, Z);
        cgen(r, &nod3);
    } else {
        regalloc(&nod3, r, Z);
        cgen(r, &nod3);
        bitload(l, &nod, &nod1, &nod2, &nod4);
    }
    gmove(&nod, &nod4);
    gopcode(o, &nod3, Z, &nod4);
    regfree(&nod3);
    gmove(&nod4, &nod);
    regfree(&nod4);
    bitstore(l, &nod, &nod1, &nod2, nn);
    break;
@

<<[[cgenrel()]] switch node kind cases>>=
bitinc:
    if(nn != Z && (o == OPOSTINC || o == OPOSTDEC)) {
        bitload(l, &nod, &nod1, &nod2, Z);
        gopcode(OAS, &nod, Z, nn);
        gopcode(OADD, nodconst(v), Z, &nod);
        bitstore(l, &nod, &nod1, &nod2, Z);
        break;
    }
    bitload(l, &nod, &nod1, &nod2, nn);
    gopcode(OADD, nodconst(v), Z, &nod);
    bitstore(l, &nod, &nod1, &nod2, nn);
    break;
@

<<[[cgenrel()]] switch node kind cases>>=
bitas:
    n = l->left;
    regalloc(&nod, r, nn);
    if(l->complex >= r->complex) {
        reglcgen(&nod1, n, Z);
        cgen(r, &nod);
    } else {
        cgen(r, &nod);
        reglcgen(&nod1, n, Z);
    }
    regalloc(&nod2, n, Z);
    gopcode(OAS, &nod1, Z, &nod2);
    bitstore(l, &nod, &nod1, &nod2, nn);
    break;
@



<<function bitload(arm)>>=
void
bitload(Node *b, Node *n1, Node *n2, Node *n3, Node *nn)
{
    int sh;
    long v;
    Node *l;

    /*
     * n1 gets adjusted/masked value
     * n2 gets address of cell
     * n3 gets contents of cell
     */
    l = b->left;
    if(n2 != Z) {
        regalloc(n1, l, nn);
        reglcgen(n2, l, Z);
        regalloc(n3, l, Z);
        gopcode(OAS, n2, Z, n3);
        gopcode(OAS, n3, Z, n1);
    } else {
        regalloc(n1, l, nn);
        cgen(l, n1);
    }
    if(b->type->shift == 0 && typeu[b->type->etype]) {
        v = ~0 + (1L << b->type->nbits);
        gopcode(OAND, nodconst(v), Z, n1);
    } else {
        sh = 32 - b->type->shift - b->type->nbits;
        if(sh > 0)
            gopcode(OASHL, nodconst(sh), Z, n1);
        sh += b->type->shift;
        if(sh > 0)
            if(typeu[b->type->etype])
                gopcode(OLSHR, nodconst(sh), Z, n1);
            else
                gopcode(OASHR, nodconst(sh), Z, n1);
    }
}
@
% >> >>

<<function bitstore(arm)>>=
void
bitstore(Node *b, Node *n1, Node *n2, Node *n3, Node *nn)
{
    long v;
    Node nod, *l;
    int sh;

    /*
     * n1 has adjusted/masked value
     * n2 has address of cell
     * n3 has contents of cell
     */
    l = b->left;
    regalloc(&nod, l, Z);
    v = ~0 + (1L << b->type->nbits);
    gopcode(OAND, nodconst(v), Z, n1);
    gopcode(OAS, n1, Z, &nod);
    if(nn != Z)
        gopcode(OAS, n1, Z, nn);
    sh = b->type->shift;
    if(sh > 0)
        gopcode(OASHL, nodconst(sh), Z, &nod);
    v <<= sh;
    gopcode(OAND, nodconst(~v), Z, n3);
    gopcode(OOR, n3, Z, &nod);
    gopcode(OAS, &nod, Z, n2);

    regfree(&nod);
    regfree(n1);
    regfree(n2);
    regfree(n3);
}
@
% >> >>







\section{C extensions}

\subsection{Unnamed sub structure}
% aka Anonymous field? poor's man inheritance?

% Lock;



<<[[typeext()]] unnamed substructure handling>>=
/*
 * extension of C
 * if assign of struct containing unnamed sub-struct
 * to type of sub-struct, insert the DOT.
 * if assign of *struct containing unnamed substruct
 * to type of *sub-struct, insert the add-offset
 */
if(typesu[st->etype] && typesu[lt->etype]) {
    o = dotoffset(st, lt, l);
    if(o >= 0) {
        n1 = new1(OXXX, Z, Z);
        *n1 = *l;
        l->op = ODOT;
        l->left = n1;
        l->right = Z;
        makedot(l, st, o);
    }
    return;
}

if(st->etype == TIND && typesu[st->link->etype])
if(lt->etype == TIND && typesu[lt->link->etype]) {
    o = dotoffset(st->link, lt->link, l);
    if(o >= 0) {
        l->type = st;
        if(o == 0)
            return;
        n1 = new1(OXXX, Z, Z);
        *n1 = *l;
        n2 = new1(OCONST, Z, Z);
        n2->vconst = o;
        n2->type = st;
        l->op = OADD;
        l->left = n1;
        l->right = n2;
    }
    return;
}
@

% typeext -> <>
<<function dotoffset>>=
long
dotoffset(Type *st, Type *lt, Node *n)
{
    Type *t;
    Sym *g;
    long o, o1;

    o = -1;
    /*
     * first try matching at the top level
     * for matching tag names
     */
    g = st->tag;
    if(g != S)
        for(t=lt->link; t!=T; t=t->down)
            if(t->sym == S)
                if(g == t->tag) {
                    if(o >= 0)
                        goto ambig;
                    o = t->offset;
                }
    if(o >= 0)
        return o;

    /*
     * second try matching at the top level
     * for similar types
     */
    for(t=lt->link; t!=T; t=t->down)
        if(t->sym == S)
            if(sametype(st, t)) {
                if(o >= 0)
                    goto ambig;
                o = t->offset;
            }
    if(o >= 0)
        return o;

    /*
     * last try matching sub-levels
     */
    for(t=lt->link; t!=T; t=t->down)
        if(t->sym == S)
        if(typesu[t->etype]) {
            o1 = dotoffset(st, t, n);
            if(o1 >= 0) {
                if(o >= 0)
                    goto ambig;
                o = o1 + t->offset;
            }
        }
    return o;

ambig:
    diag(n, "ambiguous unnamed structure element");
    return o;
}
@


\subsection{Struct constructors}

% kenccext and gccext, struct constructor
<<xuexpr rule>>=
|   '(' tlist abdecor ')' '{' ilist '}' /* extension */
    {
        $$ = new(OSTRUCT, $6, Z);
        dodecl(NODECL, CXXX, $2, $3);
        $$->type = lastdcltype;
    }
@
%$

<<[[tcomo()]] switch node kind cases>>=
case OSTRUCT:
    if(tcomx(n))
        goto bad;
    break;
@

% structure
<<function tcomx>>=
bool
tcomx(Node *n)
{
    Type *t;
    Node *l, *r, **ar, **al;
    bool e;

    e = false;
    if(n->type->etype != TSTRUCT) {
        diag(n, "constructor must be a structure");
        return true;
    }
    l = invert(n->left);
    n->left = l;
    al = &n->left;
    for(t = n->type->link; t != T; t = t->down) {
        if(l == Z) {
            diag(n, "constructor list too short");
            return true;
        }
        if(l->op == OLIST) {
            r = l->left;
            ar = &l->left;
            al = &l->right;
            l = l->right;
        } else {
            r = l;
            ar = al;
            l = Z;
        }
        if(tcom(r))
            e++;
        typeext(t, r);
        if(tcompat(n, t, r->type, tasign))
            e++;
        constas(n, t, r->type);
        if(!e && !sametype(t, r->type)) {
            r = new1(OCAST, r, Z);
            r->type = t;
            *ar = r;
        }
    }
    if(l != Z) {
        diag(n, "constructor list too long");
        return true;
    }
    return e;
}
@
% hmm e++ -> e = true instead? the count matters?


\subsection{Signature reflection, [[signof()]]}
% sign for signature, not sign of an operation

% parsing

<<token declarations>>=
%token  LSIGNOF
@

<<[[itab]] entries, kencc extensions>>=
"signof",	LSIGNOF,	0,
@

<<expression nodes>>=
OSIGN,
@

<<uexpr rule>>=
|   LSIGNOF uexpr { $$ = new(OSIGN, $2, Z); }
@
%$

<<pexpr rule>>=
|   LSIGNOF '(' tlist abdecor ')'
    {
        $$ = new(OSIGN, Z, Z);
        dodecl(NODECL, CXXX, $3, $4);
        $$->type = lastdcltype;
    }
@

% code generation

<<[[tcomo()]] switch node kind cases>>=
case OSIGN:	/* extension signof(type) returns a hash */
    if(l != Z) {
        if(l->op != OSTRING && l->op != OLSTRING)
            if(tcomo(l, 0))
                goto bad;
        if(l->op == OBIT) {
            diag(n, "signof bitfield");
            goto bad;
        }
        n->type = l->type;
    }
    if(n->type == T)
        goto bad;
    if(n->type->width < 0) {
        diag(n, "signof undefined type");
        goto bad;
    }
    n->op = OCONST;
    n->left = Z;
    n->right = Z;
    n->vconst = convvtox(signature(n->type), TULONG);
    n->type = types[TULONG];
    break;
@


\subsection{Per-processor storage, [[extern register]]}
% useful for ARM kernel (bcm/), where mach and up are in registers
%  and so are perfectly local to each processor! per-processor storage

<<[[simplec()]] cases>>=
case BEXTERN|BREGISTER:
    return CEXREG;
@

<<[[Storage_class]] cases>>=
CEXREG, // extern register, kenccext (used in kernel for mips)
@

<<[[xdecl()]] switch class cases>>=
case CEXREG:
    o = exreg(t);
    if(o == 0)
        class = CEXTERN;
    if(s->class == CGLOBL)
        class = CGLOBL;
    break;
@



<<after parsing nodes>>=
OEXREG,
@
% for regnode


<<global exregoffset>>=
long	exregoffset;
@
% does not look like an offset, more a register number

<<global exfregoffset>>=
long	exfregoffset;
@

<<[[ginit()]] initialisation>>=
exregoffset = REGEXT;
exfregoffset = FREGEXT;
@



<<function exreg(arm)>>=
long
exreg(Type *t)
{
    long o;

    if(typechlp[t->etype]) {
        if(exregoffset <= REGEXT-2)
            return 0;

        o = exregoffset;
        if(reg[o] && !resvreg[o])
            return 0;
        resvreg[o] = reg[o] = 1;
        exregoffset--;
        return o;
    }
    if(typefd[t->etype]) {
        if(exfregoffset <= NFREG-1)
            return 0;

        o = exfregoffset + NREG;
        if(reg[o] && !resvreg[o])
            return 0;
        resvreg[o] = reg[o] = 1;
        exfregoffset--;
        return o;
    }
    return 0;
}
@

\subsection{[[typestr()]]}
% a form of reflection too?


<<[[itab]] entries, kencc extensions>>=
"typestr",	LTYPESTR,	0,
@

<<token declarations>>=
%token  LTYPESTR
@


<<cname rule>>=
|   LTYPESTR  { $$ = BTYPESTR; }
@

<<enum bxxx cases>>=
BTYPESTR	= 1L<<TTYPESTR,
@

<<[[Type_kind_bis]] storage cases>>=
TTYPESTR,
@

<<[[Storage_class]] cases>>=
CTYPESTR,
@

<<[[simplec()]] cases>>=
case BTYPESTR:
    return CTYPESTR;
@

<<[[xdecl()]] switch class cases>>=
case CTYPESTR:
    if(!typesuv[t->etype]) {
        diag(Z, "typestr must be struct/union: %s", s->name);
        break;
    }
    dclfunct(t, s);
    break;
@
% actually should be !typesu, not typesuv no?


% dodecl(xdecl, ...) ->  <>
<<function dclfunct>>=
void
dclfunct(Type *t, Sym *s)
{
    Funct *f;
    Node *n;
    Type *f1, *f2, *f3, *f4;
    int o, i, c;
    char str[100];

    if(t->funct)
        return;

    // recognize generated tag of dorm _%d_
    if(t->tag == S)
        goto bad;
    for(i=0; c = t->tag->name[i]; i++) {
        if(c == '_') {
            if(i == 0 || t->tag->name[i+1] == 0)
                continue;
            break;
        }
        if(c < '0' || c > '9')
            break;
    }
    if(c == 0)
        goto bad;

    f = alloc(sizeof(*f));
    for(o=0; o<sizeof(f->sym); o++)
        f->sym[o] = S;

    t->funct = f;

    f1 = typ(TFUNC, t);
    f1->down = copytyp(t);
    f1->down->down = t;

    f2 = typ(TFUNC, types[TINT]);
    f2->down = copytyp(t);
    f2->down->down = t;

    f3 = typ(TFUNC, t);
    f3->down = typ(TIND, t);
    f3->down->down = t;

    f4 = typ(TFUNC, t);
    f4->down = t;

    for(i=0;; i++) {
        o = ftabinit[i].op;
        if(o == OXXX)
            break;
        sprint(str, "%s_%s_", t->tag->name, ftabinit[i].name);
        n = new(ONAME, Z, Z);
        n->sym = slookup(str);
        f->sym[o] = n->sym;

        switch(ftabinit[i].typ) {

        case 1:	// T f(T,T)	+
            dodecl(xdecl, CEXTERN, f1, n);
            break;

        case 2:	// int f(T,T)	==
            dodecl(xdecl, CEXTERN, f2, n);
            break;

        case 3:	// void f(T*,T)	+=
            dodecl(xdecl, CEXTERN, f3, n);
            break;

        case 4:	// T f(T)	~
            dodecl(xdecl, CEXTERN, f4, n);
            break;

        default:
            diag(Z, "dclfunct op missing %d\n", ftabinit[i].typ);
            break;
        }
    }
    for(i=0;; i++) {
        o = gtabinit[i].etype;
        if(o == TXXX)
            break;

        /*
         * OCAST types T1 _T2_T1_(T2)
         */
        sprint(str, "_%s%s_", gtabinit[i].name, t->tag->name);
        n = new(ONAME, Z, Z);
        n->sym = slookup(str);
        f->castto[o] = n->sym;

        f1 = typ(TFUNC, t);
        f1->down = types[o];
        dodecl(xdecl, CEXTERN, f1, n);

        sprint(str, "%s_%s_", t->tag->name, gtabinit[i].name);
        n = new(ONAME, Z, Z);
        n->sym = slookup(str);
        f->castfr[o] = n->sym;

        f1 = typ(TFUNC, types[o]);
        f1->down = t;
        dodecl(xdecl, CEXTERN, f1, n);
    }
    return;
bad:
    diag(Z, "dclfunct bad %T %s\n", t, s->name);
}
@


% why not use Init?
<<struct Ftab>>=
struct	Ftab
{
    char	op;
    char*	name;
    char	typ;
};
@

% why not use Init?
<<struct Gtab>>=
struct	Gtab
{
    char	etype;
    char*	name;
};
@

<<global gtabinit>>=
Gtab	gtabinit[NTYPE] =
{
    TCHAR,		"c",
    TUCHAR,		"uc",
    TSHORT,		"h",
    TUSHORT,	"uh",
    TINT,		"i",
    TUINT,		"ui",
    TLONG,		"l",
    TULONG,		"ul",
    TVLONG,		"v",
    TUVLONG,	"uv",
    TFLOAT,		"f",
    TDOUBLE,	"d",

    TXXX
};
@

<<global ftabinit>>=
Ftab	ftabinit[OEND] =
{
    OADD,		"add",		1,
    OAND,		"and",		1,
    OASHL,		"ashl",		1,
    OASHR,		"ashr",		1,
    ODIV,		"div",		1,
    OLDIV,		"ldiv",		1,
    OLMOD,		"lmod",		1,
    OLMUL,		"lmul",		1,
    OLSHR,		"lshr",		1,
    OMOD,		"mod",		1,
    OMUL,		"mul",		1,
    OOR,		"or",		1,
    OSUB,		"sub",		1,
    OXOR,		"xor",		1,

    OEQ,		"eq",		2,
    OGE,		"ge",		2,
    OGT,		"gt",		2,
    OHI,		"hi",		2,
    OHS,		"hs",		2,
    OLE,		"le",		2,
    OLO,		"lo",		2,
    OLS,		"ls",		2,
    OLT,		"lt",		2,
    ONE,		"ne",		2,

    OASADD,		"asadd",	3,
    OASAND,		"asand",	3,
    OASASHL,	"asashl",	3,
    OASASHR,	"asashr",	3,
    OASDIV,		"asdiv",	3,
    OASLDIV,	"asldiv",	3,
    OASLMOD,	"aslmod",	3,
    OASLMUL,	"aslmul",	3,
    OASLSHR,	"aslshr",	3,
    OASMOD,		"asmod",	3,
    OASMUL,		"asmul",	3,
    OASOR,		"asor",		3,
    OASSUB,		"assub",	3,
    OASXOR,		"asxor",	3,

    OPOS,		"pos",		4,
    ONEG,		"neg",		4,
    OCOM,		"com",		4,
    ONOT,		"not",		4,

//	OPOSTDEC,
//	OPOSTINC,
//	OPREDEC,
//	OPREINC,

    OXXX,
};
@








\section{Floats}

<<global fconstnode>>=
Node	fconstnode;
@

<<[[ginit()]] special nodes initialisation>>=
fconstnode.op = OCONST;
fconstnode.class = CXXX;
fconstnode.complex = 0;
fconstnode.addable = 20;
fconstnode.type = types[TDOUBLE];
@


<<function nodfconst>>=
Node*
nodfconst(double d)
{
    fconstnode.fconst = d;
    return &fconstnode;
}
@



<<function ieeedtod>>=
void
ieeedtod(Ieee *ieee, double native)
{
    double fr, ho, f;
    int exp;

    if(native < 0) {
        ieeedtod(ieee, -native);
        ieee->h |= 0x80000000L;
        return;
    }
    if(native == 0) {
        ieee->l = 0;
        ieee->h = 0;
        return;
    }
    fr = frexp(native, &exp);
    f = 2097152L;		/* shouldnt use fp constants here */
    fr = modf(fr*f, &ho);
    ieee->h = ho;
    ieee->h &= 0xfffffL;
    ieee->h |= (exp+1022L) << 20;
    f = 65536L;
    fr = modf(fr*f, &ho);
    ieee->l = ho;
    ieee->l <<= 16;
    ieee->l |= (long)(fr*f);
}
@



<<[[typeext()]] float handling>>=
typeext1(st, l);
@

<<function typeext1>>=
void
typeext1(Type *st, Node *l)
{
    if(st->etype == TFLOAT && allfloat(l, false))
        allfloat(l, true);
}
@

<<function allfloat>>=
/*
 * look into tree for floating point constant expressions
 */
bool
allfloat(Node *n, bool flag)
{

    if(n != Z) {
        if(n->type->etype != TDOUBLE)
            return true;
        switch(n->op) {
        case OCONST:
            if(flag)
                n->type = types[TFLOAT];
            return true;
        case OADD:	/* no need to get more exotic than this */
        case OSUB:
        case OMUL:
        case ODIV:
            if(!allfloat(n->right, flag))
                break;
        case OCAST:
            if(!allfloat(n->left, flag))
                break;
            if(flag)
                n->type = types[TFLOAT];
            return true;
        }
    }
    return false;
}
@



<<[[gclean()]] sanity check reg>>=
for(i=NREG; i<NREG+NFREG; i++)
    if(reg[i] && !resvreg[i])
        diag(Z, "freg %d left allocated", i-NREG);
@


%<<constant R0ISZERO(arm)>>=
%#define	R0ISZERO	0
%@
%% was false so I removed the code
% in raddr():
%    if(R0ISZERO && a.type == D_CONST && a.offset == 0) {
%        a.type = D_REG;
%        a.reg = 0;
%    }

% gmove -> <>
<<function raddr(arm)>>=
void
raddr(Node *n, Prog *p)
{
    Adr a;

    naddr(n, &a);
    if(a.type != D_REG && a.type != D_FREG) {
        if(n)
            diag(n, "bad in raddr: %O", n->op);
        else
            diag(n, "bad in raddr: <null>");
        p->reg = R_NONE;
    } else
        p->reg = a.reg;
}
@



<<[[gmove()]] switch from type cases>>=
case TDOUBLE:
case TVLONG:
case TFLOAT:
    switch(tt) {
    case TDOUBLE:
    case TVLONG:
        a = AMOVD;
        if(ft == TFLOAT)
            a = AMOVFD;
        break;
    case TFLOAT:
        a = AMOVDF;
        if(ft == TFLOAT)
            a = AMOVF;
        break;
    case TINT:
    case TUINT:
    case TLONG:
    case TULONG:
    case TIND:
        a = AMOVDW;
        if(ft == TFLOAT)
            a = AMOVFW;
        break;
    case TSHORT:
    case TUSHORT:
    case TCHAR:
    case TUCHAR:
        a = AMOVDW;
        if(ft == TFLOAT)
            a = AMOVFW;
        break;
    }
    break;
@

<<[[gmove()]] switch from type cases, TUINT/TULONG case, if float target>>=
if(tt == TFLOAT || tt == TDOUBLE) {
    // ugly and probably longer than necessary,
    // but vfp has a single instruction for this,
    // so hopefully it won't last long.
    //
    //	tmp = f
    //	tmp1 = tmp & 0x80000000
    //	tmp ^= tmp1
    //	t = float(int32(tmp))
    //	if(tmp1)
    //		t += 2147483648.
    //
    regalloc(&nod, f, Z);
    regalloc(&nod1, f, Z);
    gins(AMOVW, f, &nod);
    gins(AMOVW, &nod, &nod1);
    gins(AAND, nodconst(0x80000000), &nod1);
    gins(AEOR, &nod1, &nod);
    if(tt == TFLOAT)
        gins(AMOVWF, &nod, t);
    else
        gins(AMOVWD, &nod, t);
    gins(ACMP, nodconst(0), Z);
    raddr(&nod1, p);
    gins(ABEQ, Z, Z);
    regfree(&nod);
    regfree(&nod1);
    p1 = p;
    regalloc(&nod, t, Z);
    if(tt == TFLOAT) {
        gins(AMOVF, nodfconst(2147483648.), &nod);
        gins(AADDF, &nod, t);
    } else {
        gins(AMOVD, nodfconst(2147483648.), &nod);
        gins(AADDD, &nod, t);
    }
    regfree(&nod);
    patch(p1, pc);
    return;
}
@

<<[[gmove()]] switch from type cases, TINT/TLONG case, if float target>>=
case TDOUBLE:
    gins(AMOVWD, f, t);
    return;
case TFLOAT:
    gins(AMOVWF, f, t);
    return;
@


<<[[gmove()]] switch from type cases, TSHORT case, if float target>>=
case TDOUBLE:
    regalloc(&nod, f, Z);
    gins(AMOVH, f, &nod);
    gins(AMOVWD, &nod, t);
    regfree(&nod);
    return;
case TFLOAT:
    regalloc(&nod, f, Z);
    gins(AMOVH, f, &nod);
    gins(AMOVWF, &nod, t);
    regfree(&nod);
    return;
@

<<[[gmove()]] switch from type cases, TUSHORT case, if float target>>=
case TDOUBLE:
    regalloc(&nod, f, Z);
    gins(AMOVHU, f, &nod);
    gins(AMOVWD, &nod, t);
    regfree(&nod);
    return;
case TFLOAT:
    regalloc(&nod, f, Z);
    gins(AMOVHU, f, &nod);
    gins(AMOVWF, &nod, t);
    regfree(&nod);
    return;
@

<<[[gmove()]] switch from type cases, TCHAR case, if float target>>=
case TDOUBLE:
    regalloc(&nod, f, Z);
    gins(AMOVB, f, &nod);
    gins(AMOVWD, &nod, t);
    regfree(&nod);
    return;
case TFLOAT:
    regalloc(&nod, f, Z);
    gins(AMOVB, f, &nod);
    gins(AMOVWF, &nod, t);
    regfree(&nod);
    return;
@

<<[[gmove()]] switch from type cases, TUCHAR case, if float target>>=
case TDOUBLE:
    regalloc(&nod, f, Z);
    gins(AMOVBU, f, &nod);
    gins(AMOVWD, &nod, t);
    regfree(&nod);
    return;
case TFLOAT:
    regalloc(&nod, f, Z);
    gins(AMOVBU, f, &nod);
    gins(AMOVWF, &nod, t);
    regfree(&nod);
    return;
@


<<[[regalloc()]] switch tn type, float or vlong case>>=
case TFLOAT:
case TDOUBLE:

case TVLONG:
    if(o != Z && o->op == OREGISTER) {
        i = o->reg;
        if(i >= NREG && i < NREG+NFREG)
            goto out;
    }
    j = 0*2 + NREG;
    for(i=NREG; i<NREG+NFREG; i++) {
        if(j >= NREG+NFREG)
            j = NREG;
        if(reg[j] == 0) {
            i = j;
            goto out;
        }
        j++;
    }
    diag(tn, "out of float registers");
    goto err;
@

\section{Complex values}

\subsection{Complex type}

% set of complex types
<<global typecmplx>>=
// set<type_kind>
char*	typecmplx;
@

<<[[tinit()]] initialise 32 bits defaults type sets>>=
typecmplx = typesuv;
@
% struct, union, vlong

\subsection{Complex return value}


% set in codegen
<<global nodret>>=
Node*	nodret;
@

<<[[ginit()]] special nodes initialisation>>=
nodret = new(ONAME, Z, Z);
nodret->sym = slookup(".ret");
nodret->type = types[TIND];
nodret->etype = TIND;
nodret->class = CPARAM;
nodret = new(OIND, nodret, Z);
complex(nodret);
@
% *<.ret>
% CPARAM? rewrite function to have an extra OUT param! :)
% hmm but added somewhere in the list of parameters? just
% CPARAM is enough?

%codgen is for function body code generation
<<[[codgen()]] if complex return type>>=
if(typecmplx[thisfntype->link->etype]) {
    n1 = nodret->left;
    if(n1->type == T || n1->type->link != thisfntype->link) {
        n1->type = typ(TIND, thisfntype->link);
        n1->etype = n1->type->etype; // TIND
        nodret = new(OIND, n1, Z); // useful? to force retyping?
        complex(nodret);
    }
}
@
%old: this is done in ginit() no? redundant? nodret can never be null no?
%    if(nodret == nil) {
%        nodret = new(ONAME, Z, Z);
%        nodret->sym = slookup(".ret");
%        nodret->class = CPARAM;
%        nodret->type = types[TIND];
%        nodret->etype = TIND;
%        nodret = new(OIND, nodret, Z);
%    }


% // *ret = X; RET
<<[[gen()]] case ORETURN, if complex type>>=
if(typecmplx[n->type->etype]) {
    nod = znode;
    nod.op = OAS;
    nod.left = nodret;
    nod.right = l;
    nod.type = n->type;
    nod.complex = l->complex;
    cgen(&nod, Z);
    noretval(1 | 2);
    gbranch(ORETURN);
    break;
}
@


% why talk about return type when it's REGARG?
<<[[codegen()]] if use REGARG, if complex return type>>=
if(typecmplx[thisfntype->link->etype]) {
    nod1 = *nodret->left;
    nodreg(&nod, &nod1, REGARG);
    gmove(&nod, &nod1);
}
@

\subsection{Complex argument}

% why not use typecmplx here?

<<[[garg1()]] if complex argument type>>=
if(typesuv[n->type->etype]) {
    regaalloc(tn2, n);
    if(n->complex >= FNX) {
        sugen(*fnxp, tn2, n->type->width);
        (*fnxp)++;
    } else
        sugen(n, tn2, n->type->width);
}
@

\subsection{Complex expression}

% why not use typecmplx here?

<<[[cgenrel()]] if complex type node>>=
if(typesuv[n->type->etype]) {
    sugen(n, nn, n->type->width);
}
@

\subsection{[[vlong]] constant}

%\subsection{[[vlong]] managment}

%<<global newvlongcode>>=
%bool	newvlongcode;
%@
%seems dead, never set to true or valid in other archi?
% in Gen for RETURN case:
%    if(newvlongcode && !typefd[n->type->etype]){
%        regret(&rn, n);
%        regfree(&rn);
%        nod = znode;
%        nod.op = OAS;
%        nod.left = &rn;
%        nod.right = l;
%        nod.type = n->type;
%        nod.complex = l->complex;
%        cgen(&nod, Z);
%        noretval(2);
%        gbranch(ORETURN);
%        break;
%    }


%aspectize?
<<[[gextern()]] if OCONST and a vlong type>>=
if(a->op == OCONST && typev[a->type->etype]) {
    if(align(0, types[TCHAR], Aarg1))	/* isbigendian */
        gpseudo(ADATA, s, nod32const(a->vconst>>32));
    else
        gpseudo(ADATA, s, nod32const(a->vconst));
    p->from.offset += o;
    p->reg = 4;
    if(align(0, types[TCHAR], Aarg1))	/* isbigendian */
        gpseudo(ADATA, s, nod32const(a->vconst));
    else
        gpseudo(ADATA, s, nod32const(a->vconst>>32));
    p->from.offset += o + 4;
    p->reg = 4;
}
@
% 4 -> ??

<<function nod32const(arm)>>=
Node*
nod32const(vlong v)
{
    constnode.vconst = v & MASK(32);
    return &constnode;
}
@



\section{64 bits operations}

%\subsection{[[cc/com64.c]]}
% portable part, cc/com64.c
% vlong is 64 bits, so how do on 32 bits?
% do via builtins _xxxv, e.g. _addv, _mulv in lib_core/libc/xxx/vlop.c


<<global nodaddv>>=
Node*	nodaddv;
@

<<global nodsubv>>=
Node*	nodsubv;
@

<<global nodmulv>>=
Node*	nodmulv;
@

<<global noddivv>>=
Node*	noddivv;
@

<<global noddivvu>>=
Node*	noddivvu;
@

<<global nodmodv>>=
Node*	nodmodv;
@

<<global nodmodvu>>=
Node*	nodmodvu;
@

<<global nodlshv>>=
Node*	nodlshv;
@

<<global nodrshav>>=
Node*	nodrshav;
@

<<global nodrshlv>>=
Node*	nodrshlv;
@

<<global nodandv>>=
Node*	nodandv;
@

<<global nodorv>>=
Node*	nodorv;
@

<<global nodxorv>>=
Node*	nodxorv;
@

<<global nodnegv>>=
Node*	nodnegv;
@

<<global nodcomv>>=
Node*	nodcomv;
@

<<global nodtestv>>=
Node*	nodtestv;
@

<<global nodeqv>>=
Node*	nodeqv;
@

<<global nodnev>>=
Node*	nodnev;
@

<<global nodlev>>=
Node*	nodlev;
@

<<global nodltv>>=
Node*	nodltv;
@

<<global nodgev>>=
Node*	nodgev;
@

<<global nodgtv>>=
Node*	nodgtv;
@

<<global nodhiv>>=
Node*	nodhiv;
@

<<global nodhsv>>=
Node*	nodhsv;
@

<<global nodlov>>=
Node*	nodlov;
@

<<global nodlsv>>=
Node*	nodlsv;
@

<<global nodf2v>>=
Node*	nodf2v;
@

<<global nodd2v>>=
Node*	nodd2v;
@

<<global nodp2v>>=
Node*	nodp2v;
@

<<global nodsi2v>>=
Node*	nodsi2v;
@

<<global nodui2v>>=
Node*	nodui2v;
@

<<global nodsl2v>>=
Node*	nodsl2v;
@

<<global nodul2v>>=
Node*	nodul2v;
@

<<global nodsh2v>>=
Node*	nodsh2v;
@

<<global noduh2v>>=
Node*	noduh2v;
@

<<global nodsc2v>>=
Node*	nodsc2v;
@

<<global noduc2v>>=
Node*	noduc2v;
@

<<global nodv2f>>=
Node*	nodv2f;
@

<<global nodv2d>>=
Node*	nodv2d;
@

<<global nodv2ui>>=
Node*	nodv2ui;
@

<<global nodv2si>>=
Node*	nodv2si;
@

<<global nodv2ul>>=
Node*	nodv2ul;
@

<<global nodv2sl>>=
Node*	nodv2sl;
@

<<global nodv2uh>>=
Node*	nodv2uh;
@

<<global nodv2sh>>=
Node*	nodv2sh;
@

<<global nodv2uc>>=
Node*	nodv2uc;
@

<<global nodv2sc>>=
Node*	nodv2sc;
@

<<global nodvpp>>=
Node*	nodvpp;
@

<<global nodppv>>=
Node*	nodppv;
@

<<global nodvmm>>=
Node*	nodvmm;
@

<<global nodmmv>>=
Node*	nodmmv;
@

<<global nodvasop>>=
Node*	nodvasop;
@

<<global etconv>>=
char	etconv[NTYPE];	/* for _vasop */
@

<<global initetconv>>=
Init	initetconv[] =
{
    TCHAR,		1,	0,
    TUCHAR,		2,	0,
    TSHORT,		3,	0,
    TUSHORT,	4,	0,
    TLONG,		5,	0,
    TULONG,		6,	0,
    TVLONG,		7,	0,
    TUVLONG,	8,	0,
    TINT,		9,	0,
    TUINT,		10,	0,
    -1,		0,	0,
};
@

<<global fntypes>>=
Type*	fntypes[NTYPE];
@

<<function fvn>>=
Node*
fvn(char *name, int type)
{
    Node *n;

    n = new(ONAME, Z, Z);
    n->sym = slookup(name);
    n->sym->sig = SIGINTERN;
    if(fntypes[type] == nil)
        fntypes[type] = typ(TFUNC, types[type]);
    n->type = fntypes[type];
    n->etype = type; // type of return?
    n->class = CGLOBL;
    n->addable = 10;
    n->complex = 0;
    return n;
}
@

<<function com64init>>=
void
com64init(void)
{
    Init *p;

    nodaddv = fvn("_addv", TVLONG);
    nodsubv = fvn("_subv", TVLONG);
    nodmulv = fvn("_mulv", TVLONG);
    noddivv = fvn("_divv", TVLONG);
    noddivvu = fvn("_divvu", TVLONG);
    nodmodv = fvn("_modv", TVLONG);
    nodmodvu = fvn("_modvu", TVLONG);
    nodlshv = fvn("_lshv", TVLONG);
    nodrshav = fvn("_rshav", TVLONG);
    nodrshlv = fvn("_rshlv", TVLONG);
    nodandv = fvn("_andv", TVLONG);
    nodorv = fvn("_orv", TVLONG);
    nodxorv = fvn("_xorv", TVLONG);
    nodnegv = fvn("_negv", TVLONG);
    nodcomv = fvn("_comv", TVLONG);

    nodtestv = fvn("_testv", TLONG);
    nodeqv = fvn("_eqv", TLONG);
    nodnev = fvn("_nev", TLONG);
    nodlev = fvn("_lev", TLONG);
    nodltv = fvn("_ltv", TLONG);
    nodgev = fvn("_gev", TLONG);
    nodgtv = fvn("_gtv", TLONG);
    nodhiv = fvn("_hiv", TLONG);
    nodhsv = fvn("_hsv", TLONG);
    nodlov = fvn("_lov", TLONG);
    nodlsv = fvn("_lsv", TLONG);

    nodf2v = fvn("_f2v", TVLONG);
    nodd2v = fvn("_d2v", TVLONG);
    nodp2v = fvn("_p2v", TVLONG);
    nodsi2v = fvn("_si2v", TVLONG);
    nodui2v = fvn("_ui2v", TVLONG);
    nodsl2v = fvn("_sl2v", TVLONG);
    nodul2v = fvn("_ul2v", TVLONG);
    nodsh2v = fvn("_sh2v", TVLONG);
    noduh2v = fvn("_uh2v", TVLONG);
    nodsc2v = fvn("_sc2v", TVLONG);
    noduc2v = fvn("_uc2v", TVLONG);

    nodv2f = fvn("_v2f", TFLOAT);
    nodv2d = fvn("_v2d", TDOUBLE);
    nodv2sl = fvn("_v2sl", TLONG);
    nodv2ul = fvn("_v2ul", TULONG);
    nodv2si = fvn("_v2si", TINT);
    nodv2ui = fvn("_v2ui", TUINT);
    nodv2sh = fvn("_v2sh", TSHORT);
    nodv2uh = fvn("_v2ul", TUSHORT);
    nodv2sc = fvn("_v2sc", TCHAR);
    nodv2uc = fvn("_v2uc", TUCHAR);

    nodvpp = fvn("_vpp", TVLONG);
    nodppv = fvn("_ppv", TVLONG);
    nodvmm = fvn("_vmm", TVLONG);
    nodmmv = fvn("_mmv", TVLONG);

    nodvasop = fvn("_vasop", TVLONG);

    for(p = initetconv; p->code >= 0; p++)
        etconv[p->code] = p->value;
}
@

<<function com64>>=
int
com64(Node *n)
{
    Node *l, *r, *a, *t;
    int lv, rv;

    if(n->type == 0)
        return 0;

    l = n->left;
    r = n->right;

    lv = 0;
    if(l && l->type && typev[l->type->etype])
        lv = 1;
    rv = 0;
    if(r && r->type && typev[r->type->etype])
        rv = 1;

    if(lv) {
        switch(n->op) {
        case OEQ:
            a = nodeqv;
            goto setbool;
        case ONE:
            a = nodnev;
            goto setbool;
        case OLE:
            a = nodlev;
            goto setbool;
        case OLT:
            a = nodltv;
            goto setbool;
        case OGE:
            a = nodgev;
            goto setbool;
        case OGT:
            a = nodgtv;
            goto setbool;
        case OHI:
            a = nodhiv;
            goto setbool;
        case OHS:
            a = nodhsv;
            goto setbool;
        case OLO:
            a = nodlov;
            goto setbool;
        case OLS:
            a = nodlsv;
            goto setbool;

        case OANDAND:
        case OOROR:
            if(machcap(n))
                return 1;

            if(rv) {
                r = new(OFUNC, nodtestv, r);
                n->right = r;
                r->complex = FNX;
                r->op = OFUNC;
                r->type = types[TLONG];
            }

        case OCOND:
        case ONOT:
            if(machcap(n))
                return 1;

            l = new(OFUNC, nodtestv, l);
            n->left = l;
            l->complex = FNX;
            l->op = OFUNC;
            l->type = types[TLONG];
            n->complex = FNX;
            return 1;
        }
    }

    if(rv) {
        if(machcap(n))
            return 1;
        switch(n->op) {
        case OANDAND:
        case OOROR:
            r = new(OFUNC, nodtestv, r);
            n->right = r;
            r->complex = FNX;
            r->op = OFUNC;
            r->type = types[TLONG];
            return 1;
        case OCOND:
            return 1;
        }
    }

    if(typev[n->type->etype]) {
        if(machcap(n))
            return 1;
        switch(n->op) {
        default:
            diag(n, "unknown vlong %O", n->op);
        case OFUNC:
            n->complex = FNX;
        case ORETURN:
        case OAS:
        case OIND:
        case OLIST:
        case OCOMMA:
            return 1;
        case OADD:
            a = nodaddv;
            goto setbop;
        case OSUB:
            a = nodsubv;
            goto setbop;
        case OMUL:
        case OLMUL:
            a = nodmulv;
            goto setbop;
        case ODIV:
            a = noddivv;
            goto setbop;
        case OLDIV:
            a = noddivvu;
            goto setbop;
        case OMOD:
            a = nodmodv;
            goto setbop;
        case OLMOD:
            a = nodmodvu;
            goto setbop;
        case OASHL:
            a = nodlshv;
            goto setbop;
        case OASHR:
            a = nodrshav;
            goto setbop;
        case OLSHR:
            a = nodrshlv;
            goto setbop;
        case OAND:
            a = nodandv;
            goto setbop;
        case OOR:
            a = nodorv;
            goto setbop;
        case OXOR:
            a = nodxorv;
            goto setbop;
        case OPOSTINC:
            a = nodvpp;
            goto setvinc;
        case OPOSTDEC:
            a = nodvmm;
            goto setvinc;
        case OPREINC:
            a = nodppv;
            goto setvinc;
        case OPREDEC:
            a = nodmmv;
            goto setvinc;
        case ONEG:
            a = nodnegv;
            goto setfnx;
        case OCOM:
            a = nodcomv;
            goto setfnx;
        case OCAST:
            switch(l->type->etype) {
            case TCHAR:
                a = nodsc2v;
                goto setfnxl;
            case TUCHAR:
                a = noduc2v;
                goto setfnxl;
            case TSHORT:
                a = nodsh2v;
                goto setfnxl;
            case TUSHORT:
                a = noduh2v;
                goto setfnxl;
            case TINT:
                a = nodsi2v;
                goto setfnx;
            case TUINT:
                a = nodui2v;
                goto setfnx;
            case TLONG:
                a = nodsl2v;
                goto setfnx;
            case TULONG:
                a = nodul2v;
                goto setfnx;
            case TFLOAT:
                a = nodf2v;
                goto setfnx;
            case TDOUBLE:
                a = nodd2v;
                goto setfnx;
            case TIND:
                a = nodp2v;
                goto setfnx;
            }
            diag(n, "unknown %T->vlong cast", l->type);
            return 1;
        case OASADD:
            a = nodaddv;
            goto setasop;
        case OASSUB:
            a = nodsubv;
            goto setasop;
        case OASMUL:
        case OASLMUL:
            a = nodmulv;
            goto setasop;
        case OASDIV:
            a = noddivv;
            goto setasop;
        case OASLDIV:
            a = noddivvu;
            goto setasop;
        case OASMOD:
            a = nodmodv;
            goto setasop;
        case OASLMOD:
            a = nodmodvu;
            goto setasop;
        case OASASHL:
            a = nodlshv;
            goto setasop;
        case OASASHR:
            a = nodrshav;
            goto setasop;
        case OASLSHR:
            a = nodrshlv;
            goto setasop;
        case OASAND:
            a = nodandv;
            goto setasop;
        case OASOR:
            a = nodorv;
            goto setasop;
        case OASXOR:
            a = nodxorv;
            goto setasop;
        }
    }

    if(typefd[n->type->etype] && l && l->op == OFUNC) {
        switch(n->op) {
        case OASADD:
        case OASSUB:
        case OASMUL:
        case OASLMUL:
        case OASDIV:
        case OASLDIV:
        case OASMOD:
        case OASLMOD:
        case OASASHL:
        case OASASHR:
        case OASLSHR:
        case OASAND:
        case OASOR:
        case OASXOR:
            if(l->right && typev[l->right->etype]) {
                diag(n, "sorry float <asop> vlong not implemented\n");
            }
        }
    }

    if(n->op == OCAST) {
        if(l->type && typev[l->type->etype]) {
            if(machcap(n))
                return 1;
            switch(n->type->etype) {
            case TDOUBLE:
                a = nodv2d;
                goto setfnx;
            case TFLOAT:
                a = nodv2f;
                goto setfnx;
            case TLONG:
                a = nodv2sl;
                goto setfnx;
            case TULONG:
                a = nodv2ul;
                goto setfnx;
            case TINT:
                a = nodv2si;
                goto setfnx;
            case TUINT:
                a = nodv2ui;
                goto setfnx;
            case TSHORT:
                a = nodv2sh;
                goto setfnx;
            case TUSHORT:
                a = nodv2uh;
                goto setfnx;
            case TCHAR:
                a = nodv2sc;
                goto setfnx;
            case TUCHAR:
                a = nodv2uc;
                goto setfnx;
            case TIND:	// small pun here
                a = nodv2ul;
                goto setfnx;
            }
            diag(n, "unknown vlong->%T cast", n->type);
            return 1;
        }
    }

    return 0;

setbop:
    n->left = a;
    n->right = new(OLIST, l, r);
    n->complex = FNX;
    n->op = OFUNC;
    return 1;

setfnxl:
    l = new(OCAST, l, 0);
    l->type = types[TLONG];
    l->complex = l->left->complex;

setfnx:
    n->left = a;
    n->right = l;
    n->complex = FNX;
    n->op = OFUNC;
    return 1;

setvinc:
    n->left = a;
    l = new(OADDR, l, Z);
    l->type = typ(TIND, l->left->type);
    l->complex = l->left->complex;
    n->right = new(OLIST, l, r);
    n->complex = FNX;
    n->op = OFUNC;
    return 1;

setbool:
    if(machcap(n))
        return 1;
    n->left = a;
    n->right = new(OLIST, l, r);
    n->complex = FNX;
    n->op = OFUNC;
    n->type = types[TLONG];
    return 1;

setasop:
    if(l->op == OFUNC) {
        l = l->right;
        goto setasop;
    }

    t = new(OCONST, 0, 0);
    t->vconst = etconv[l->type->etype];
    t->type = types[TLONG];
    t->addable = 20;
    r = new(OLIST, t, r);

    t = new(OADDR, a, 0);
    t->type = typ(TIND, a->type);
    r = new(OLIST, t, r);

    t = new(OADDR, l, 0);
    t->type = typ(TIND, l->type);
    t->complex = l->complex;
    r = new(OLIST, t, r);

    n->left = nodvasop;
    n->right = r;
    n->complex = FNX;
    n->op = OFUNC;

    return 1;
}
@

<<function bool64>>=
void
bool64(Node *n)
{
    Node *n1;

    if(machcap(Z))
        return;
    if(typev[n->type->etype]) {
        n1 = new(OXXX, 0, 0);
        *n1 = *n;

        n->right = n1;
        n->left = nodtestv;
        n->complex = FNX;
        n->addable = 0;
        n->op = OFUNC;
        n->type = types[TLONG];
    }
}
@

%<<function convvtof>>=
%/*
% * more machine depend stuff.
% * this is common for 8,16,32,64 bit machines.
% * this is common for ieee machines.
% */
%//double
%//convvtof(vlong v)
%//{
%//    double d;
%//
%//    d = v;		/* BOTCH */
%//    return d;
%//}
%@
%
%<<function convftov>>=
%//vlong
%//convftov(double d)
%//{
%//    vlong v;
%//
%//
%//    v = d;		/* BOTCH */
%//    return v;
%//}
%@
%
%<<function convftox>>=
%//double
%//convftox(double d, int et)
%//{
%//
%//    if(!typefd[et])
%//        diag(Z, "bad type in castftox %s", tnames[et]);
%//    return d;
%//}
%@



<<function convvtox>>=
vlong
convvtox(vlong c, int et)
{
    int n;

    n = 8 * ewidth[et];
    c &= MASK(n);
    if(!typeu[et])
        if(c & SIGN(n))
            c |= ~MASK(n);
    return c;
}
@

%\subsection{[[8c/cgen64.c]]}

\section{Endianness}
% 5c -l, just for mips => switch from vc to 0c


%    case 'l':			/* for little-endian mips */
%        if(thechar != 'v'){
%            print("can only use -l with vc");
%            errorexit();
%        }
%        thechar = '0';
%        thestring = "spim";
%        break;


\section{Using an external preprocessor, [[/bin/cpp]]}

<<constant CPP>>=
#define	CPP	"/bin/cpp"
@

<<[[compile()]] use ANSI preprocessor>>=
/* Use an ANSI preprocessor */
if(debug['p']) {
    if(myaccess(infile) < 0) {
        diag(Z, "%s does not exist", infile);
        errorexit();
    }
    if(pipe(fd) < 0) {
        diag(Z, "pipe failed");
        errorexit();
    }
    switch(fork()) {
    case -1:
        diag(Z, "fork failed");
        errorexit();

    case 0:
        close(fd[0]);
        dup(fd[1], 1);
        close(fd[1]);
        av = alloc((3 + ndef + ninclude + 2) * sizeof *av);
        av[0] = CPP;
        i = 1;
        if(debug['.'])
            av[i++] = strdup("-.");
        /* 1999 ANSI C requires recognising // comments */
        av[i++] = strdup("-+");
        for(c = 0; c < ndef; c++) {
            sprint(opt, "-D%s", defs[c]);
            av[i++] = strdup(opt);
        }
        for(c = 0; c < ninclude; c++) {
            sprint(opt, "-I%s", include[c]);
            av[i++] = strdup(opt);
        }
        if(strcmp(infile, "stdin") != 0)
            av[i++] = infile;
        av[i] = 0;
        if(debug['p'] > 1) {
            for(c = 0; c < i; c++)
                fprint(2, "%s ", av[c]);
            fprint(2, "\n");
        }

        exec(av[0], av);
        fprint(2, "can't exec C preprocessor %s: %r\n", CPP);
        errorexit();

    default:
        close(fd[1]);
        newfile(infile, fd[0]);
        break;
    }
}
@


\section{Processing multiple files}

<<[[main()]] locals>>=
int nproc, nout, status, i;
@

<<[[main()]] multiple files handling>>=
if(argc > 1) {
    nproc = 1;
    /*
     * if we're writing acid to standard output, don't compile
     * concurrently, to avoid interleaving output.
     */
    if(((!debug['a'] && !debug['Z']) || debug['n']) &&
        (p = getenv("NPROC")) != nil)
        nproc = atol(p);	/* */
    c = 0;
    nout = 0;
    for(;;) {
        while(nout < nproc && argc > 0) {
            i = fork();
            if(i < 0) {
                i = mywait(&status);
                if(i < 0) {
                    print("cannot create a process\n");
                    errorexit();
                }
                if(status)
                    c++;
                nout--;
                continue;
            }
            if(i == 0) {
                fprint(2, "%s:\n", *argv);
                if (compile(*argv, defs, ndef))
                    errorexit();
                exits(0);
            }
            nout++;
            argc--;
            argv++;
        }
        i = mywait(&status);
        if(i < 0) {
            if(c)
                errorexit();
            exits(0);
        }
        if(status)
            c++;
        nout--;
    }
}
@

\chapter{Conclusion}








\appendix



\chapter{Debugging}

<<global debug>>=
char	debug[256];
@
% bool? ushort?

\section{Dumpers}

\subsection{[[cc/]] [[Fmt]] data structures}

<<[[cinit()]] fmtinstall>>=
fmtinstall('O', Oconv);
fmtinstall('T', Tconv);
fmtinstall('F', FNconv);
fmtinstall('L', Lconv);
fmtinstall('Q', Qconv);
fmtinstall('|', VBconv);
@

<<function Oconv>>=
// enum<node_kind> -> string
int Oconv(Fmt *fp)
{
    int a;

    a = va_arg(fp->args, int);
    if(a < OXXX || a > OEND)
        return fmtprint(fp, "***badO %d***", a);

    return fmtstrcpy(fp, onames[a]);
}
@

<<global onames>>=
char*	onames[OEND+1];
@
% 5c allows [0ADD] notation, so no need for onamesinit I think.

<<global onamesinit>>=
Init	onamesinit[] =
{
    OXXX,		0,	"OXXX",
    OADD,		0,	"ADD",
    OADDR,		0,	"ADDR",
    OAND,		0,	"AND",
    OANDAND,	0,	"ANDAND",
    OARRAY,		0,	"ARRAY",
    OAS,		0,	"AS",
    OASI,		0,	"ASI",
    OASADD,		0,	"ASADD",
    OASAND,		0,	"ASAND",
    OASASHL,	0,	"ASASHL",
    OASASHR,	0,	"ASASHR",
    OASDIV,		0,	"ASDIV",
    OASHL,		0,	"ASHL",
    OASHR,		0,	"ASHR",
    OASLDIV,	0,	"ASLDIV",
    OASLMOD,	0,	"ASLMOD",
    OASLMUL,	0,	"ASLMUL",
    OASLSHR,	0,	"ASLSHR",
    OASMOD,		0,	"ASMOD",
    OASMUL,		0,	"ASMUL",
    OASOR,		0,	"ASOR",
    OASSUB,		0,	"ASSUB",
    OASXOR,		0,	"ASXOR",
    OBIT,		0,	"BIT",
    OBREAK,		0,	"BREAK",
    OCASE,		0,	"CASE",
    OCAST,		0,	"CAST",
    OCOMMA,		0,	"COMMA",
    OCOND,		0,	"COND",
    OCONST,		0,	"CONST",
    OCONTINUE,	0,	"CONTINUE",
    ODIV,		0,	"DIV",
    ODOT,		0,	"DOT",
    ODOTDOT,	0,	"DOTDOT",
    ODWHILE,	0,	"DWHILE",
    OEQ,		0,	"EQ",
    OFOR,		0,	"FOR",
    OFUNC,		0,	"FUNC",
    OGE,		0,	"GE",
    OGOTO,		0,	"GOTO",
    OGT,		0,	"GT",
    OHI,		0,	"HI",
    OHS,		0,	"HS",
    OIF,		0,	"IF",
    OIND,		0,	"IND",
    OINDREG,	0,	"INDREG",
    OINIT,		0,	"INIT",
    OLABEL,		0,	"LABEL",
    OLDIV,		0,	"LDIV",
    OLE,		0,	"LE",
    OLIST,		0,	"LIST",
    OLMOD,		0,	"LMOD",
    OLMUL,		0,	"LMUL",
    OLO,		0,	"LO",
    OLS,		0,	"LS",
    OLSHR,		0,	"LSHR",
    OLT,		0,	"LT",
    OMOD,		0,	"MOD",
    OMUL,		0,	"MUL",
    ONAME,		0,	"NAME",
    ONE,		0,	"NE",
    ONOT,		0,	"NOT",
    OOR,		0,	"OR",
    OOROR,		0,	"OROR",
    OPOSTDEC,	0,	"POSTDEC",
    OPOSTINC,	0,	"POSTINC",
    OPREDEC,	0,	"PREDEC",
    OPREINC,	0,	"PREINC",
    OPROTO,		0,	"PROTO",
    OREGISTER,	0,	"REGISTER",
    ORETURN,	0,	"RETURN",
    OSET,		0,	"SET",
    OSIGN,		0,	"SIGN",
    OSIZE,		0,	"SIZE",
    OSTRING,	0,	"STRING",
    OLSTRING,	0,	"LSTRING",
    OSTRUCT,	0,	"STRUCT",
    OSUB,		0,	"SUB",
    OSWITCH,	0,	"SWITCH",
    OUNION,		0,	"UNION",
    OUSED,		0,	"USED",
    OWHILE,		0,	"WHILE",
    OXOR,		0,	"XOR",
    OPOS,		0,	"POS",
    ONEG,		0,	"NEG",
    OCOM,		0,	"COM",
    OELEM,		0,	"ELEM",
    OINDEX,		0,	"INDEX",
    OREGPAIR,	0,	"REGPAIR",
    OEXREG,		0,	"EXREG",
    OEND,		0,	"END",
    -1,		0,	0,
};
@

<<constant HISTSZ>>=
#define	HISTSZ		20
@

<<struct Atab>>=
struct Atab
    {
        Hist*	incl;	/* start of this include file */
        long	idel;	/* delta line number to apply to include */
        Hist*	line;	/* start of this #line directive */
        long	ldel;	/* delta line number to apply to #line */
};
@

% location?
<<function Lconv>>=
// int -> string?
int
Lconv(Fmt *fp)
{
    char str[STRINGSZ], s[STRINGSZ];
    Hist *h;
    long l, d;
    int i, n;
    struct Atab  a[HISTSZ];

    l = va_arg(fp->args, long);
    n = 0;
    for(h = hist; h != H; h = h->link) {
        if(l < h->line)
            break;
        if(h->name) {
            if(h->offset != 0) {		/* #line directive, not #pragma */
                if(n > 0 && n < HISTSZ && h->offset >= 0) {
                    a[n-1].line = h;
                    a[n-1].ldel = h->line - h->offset + 1;
                }
            } else {
                if(n < HISTSZ) {	/* beginning of file */
                    a[n].incl = h;
                    a[n].idel = h->line;
                    a[n].line = 0;
                }
                n++;
            }
            continue;
        }
        n--;
        if(n > 0 && n < HISTSZ) {
            d = h->line - a[n].incl->line;
            a[n-1].ldel += d;
            a[n-1].idel += d;
        }
    }
    if(n > HISTSZ)
        n = HISTSZ;
    str[0] = 0;
    for(i=n-1; i>=0; i--) {
        if(i != n-1) {
            if(fp->flags & ~(FmtWidth|FmtPrec))	/* BUG ROB - was f3 */
                break;
            strcat(str, " ");
        }
        if(a[i].line)
            snprint(s, STRINGSZ, "%s:%ld[%s:%ld]",
                a[i].line->name, l-a[i].ldel+1,
                a[i].incl->name, l-a[i].idel+1);
        else
            snprint(s, STRINGSZ, "%s:%ld",
                a[i].incl->name, l-a[i].idel+1);
        if(strlen(s)+strlen(str) >= STRINGSZ-10)
            break;
        strcat(str, s);
        l = a[i].incl->line - 1;	/* now print out start of this file */
    }
    if(n == 0)
        strcat(str, "<eof>");
    return fmtstrcpy(fp, str);
}
@

<<function Tconv>>=
// option<Type> -> string
int
Tconv(Fmt *fp)
{
    char str[STRINGSZ+20], s[STRINGSZ+20];
    Type *t, *t1;
    int et;
    long n;

    str[0] = 0;
    for(t = va_arg(fp->args, Type*); t != T; t = t->link) {
        et = t->etype;
        if(str[0])
            strcat(str, " ");
        if(t->garb&~GINCOMPLETE) {
            sprint(s, "%s ", gnames[t->garb&~GINCOMPLETE]);
            if(strlen(str) + strlen(s) < STRINGSZ)
                strcat(str, s);
        }
        sprint(s, "%s", tnames[et]);
        if(strlen(str) + strlen(s) < STRINGSZ)
            strcat(str, s);
        if(et == TFUNC && (t1 = t->down)) {
            sprint(s, "(%T", t1);
            if(strlen(str) + strlen(s) < STRINGSZ)
                strcat(str, s);
            while(t1 = t1->down) {
                sprint(s, ", %T", t1);
                if(strlen(str) + strlen(s) < STRINGSZ)
                    strcat(str, s);
            }
            if(strlen(str) + strlen(s) < STRINGSZ)
                strcat(str, ")");
        }
        if(et == TARRAY) {
            n = t->width;
            if(t->link && t->link->width)
                n /= t->link->width;
            sprint(s, "[%ld]", n);
            if(strlen(str) + strlen(s) < STRINGSZ)
                strcat(str, s);
        }
        if(t->nbits) {
            sprint(s, " %d:%d", t->shift, t->nbits);
            if(strlen(str) + strlen(s) < STRINGSZ)
                strcat(str, s);
        }
        if(typesu[et]) {
            if(t->tag) {
                strcat(str, " ");
                if(strlen(str) + strlen(t->tag->name) < STRINGSZ)
                    strcat(str, t->tag->name);
            } else
                strcat(str, " {}");
            break;
        }
    }
    return fmtstrcpy(fp, str);
}
@

<<global tnames>>=
char*	tnames[NALLTYPES];
@

<<global tnamesinit>>=
Init	tnamesinit[] =
{
    TXXX,		0,	"TXXX",

    TCHAR,		0,	"CHAR",
    TUCHAR,		0,	"UCHAR",
    TSHORT,		0,	"SHORT",
    TUSHORT,	0,	"USHORT",
    TINT,		0,	"INT",
    TUINT,		0,	"UINT",
    TLONG,		0,	"LONG",
    TULONG,		0,	"ULONG",
    TVLONG,		0,	"VLONG",
    TUVLONG,	0,	"UVLONG",
    TFLOAT,		0,	"FLOAT",
    TDOUBLE,	0,	"DOUBLE",
    TIND,		0,	"IND",
    TFUNC,		0,	"FUNC",
    TARRAY,		0,	"ARRAY",
    TVOID,		0,	"VOID",
    TSTRUCT,	0,	"STRUCT",
    TUNION,		0,	"UNION",
    TENUM,		0,	"ENUM",
    TOLD,		0,	"OLD",
    TDOT,		0,	"DOT",

    -1,		0,	0,
};
@



<<function FNconv>>=
// option<Node identifier cases> -> string
int
FNconv(Fmt *fp)
{
    char *str;
    Node *n;

    n = va_arg(fp->args, Node*);
    str = "<indirect>";
    if(n != Z && (n->op == ONAME || n->op == ODOT || n->op == OELEM))
        str = n->sym->name;
    return fmtstrcpy(fp, str);
}
@

<<function Qconv>>=
// ??
int
Qconv(Fmt *fp)
{
    char str[STRINGSZ+20], *s;
    long b;
    int i;

    str[0] = 0;
    for(b = va_arg(fp->args, long); b;) {
        i = bitno(b);
        if(str[0])
            strcat(str, " ");
        s = qnames[i];
        if(strlen(str) + strlen(s) >= STRINGSZ)
            break;
        strcat(str, s);
        b &= ~(1L << i);
    }
    return fmtstrcpy(fp, str);
}
@
% >>

<<function VBconv>>=
// ??
int
VBconv(Fmt *fp)
{
    char str[STRINGSZ];
    int i, n, t, pc;

    n = va_arg(fp->args, int);
    pc = 0;	/* BUG: was printcol */
    i = 0;
    while(pc < n) {
        t = (pc+4) & ~3;
        if(t <= n) {
            str[i++] = '\t';
            pc = t;
            continue;
        }
        str[i++] = ' ';
        pc++;
    }
    str[i] = '\0';

    return fmtstrcpy(fp, str);
}
@

\subsection{[[5c/]] [[Fmt]] data structures}

% similar to Assembler.nw?


<<[[ginit()]] initialisation>>=
listinit();
@

<<function listinit(arm)>>=
void
listinit(void)
{

    fmtinstall('A', Aconv);
    fmtinstall('P', Pconv);
    fmtinstall('S', Sconv);
    fmtinstall('N', Nconv);
    fmtinstall('B', Bconv);
    fmtinstall('D', Dconv);
    fmtinstall('R', Rconv);
}
@


<<function Bconv>>=
// Bits -> string
int
Bconv(Fmt *fp)
{
    char str[STRINGSZ], ss[STRINGSZ], *s;
    Bits bits;
    int i;

    str[0] = 0;
    bits = va_arg(fp->args, Bits);
    while(bany(&bits)) {
        i = bnum(bits);
        if(str[0])
            strcat(str, " ");
        if(var[i].sym == S) {
            snprint(ss, sizeof(ss), "$%ld", var[i].offset);
            s = ss;
        } else
            s = var[i].sym->name;
        if(strlen(str) + strlen(s) + 1 >= STRINGSZ)
            break;
        strcat(str, s);
        bits.b[i/32] &= ~(1L << (i%32));
    }
    return fmtstrcpy(fp, str);
}
@
% >>
%$




<<function Pconv(arm)>>=
// Prog -> string
int
Pconv(Fmt *fp)
{
    char str[STRINGSZ], sc[20];
    Prog *p;
    int a, s;

    p = va_arg(fp->args, Prog*);
    a = p->as;
    s = p->scond; 
    strcpy(sc, extra[s & C_SCOND]);
    if(s & C_SBIT)
        strcat(sc, ".S");
    if(s & C_PBIT)
        strcat(sc, ".P");
    if(s & C_WBIT)
        strcat(sc, ".W");
    if(s & C_UBIT)		/* ambiguous with FBIT */
        strcat(sc, ".U");
    if(a == AMOVM) {
        if(p->from.type == D_CONST)
            snprint(str, sizeof(str), "	%A%s	%R,%D", a, sc, &p->from, &p->to);
        else
        if(p->to.type == D_CONST)
            snprint(str, sizeof(str), "	%A%s	%D,%R", a, sc, &p->from, &p->to);
        else
            snprint(str, sizeof(str), "	%A%s	%D,%D", a, sc, &p->from, &p->to);
    } else
    if(a == ADATA)
        snprint(str, sizeof(str), "	%A	%D/%d,%D", a, &p->from, p->reg, &p->to);
    else
    if(p->as == ATEXT)
        snprint(str, sizeof(str), "	%A	%D,%d,%D", a, &p->from, p->reg, &p->to);
    else
    if(p->reg == R_NONE)
        snprint(str, sizeof(str), "	%A%s	%D,%D", a, sc, &p->from, &p->to);
    else
    if(p->from.type != D_FREG)
        snprint(str, sizeof(str), "	%A%s	%D,R%d,%D", a, sc, &p->from, p->reg, &p->to);
    else
        snprint(str, sizeof(str), "	%A%s	%D,F%d,%D", a, sc, &p->from, p->reg, &p->to);
    return fmtstrcpy(fp, str);
}
@

<<global extra(arm)>>=
char *extra [] = {
    ".EQ", ".NE", ".CS", ".CC", 
    ".MI", ".PL", ".VS", ".VC", 
    ".HI", ".LS", ".GE", ".LT", 
    ".GT", ".LE", "", ".NV",
};
@



<<function Aconv>>=
// enum<opcode_kind> -> string
int
Aconv(Fmt *fp)
{
    char *s;
    int a;

    a = va_arg(fp->args, int);
    s = "???";
    if(a >= AXXX && a < ALAST)
        s = anames[a];
    return fmtstrcpy(fp, s);
}
@
% anames in Assembly section
% >>



<<function Dconv(arm)>>=
int
Dconv(Fmt *fp)
{
    char str[STRINGSZ];
    Adr *a;
    char *op;
    int v;

    a = va_arg(fp->args, Adr*);
    switch(a->type) {

    default:
        snprint(str, sizeof(str), "GOK-type(%d)", a->type);
        break;

    case D_NONE:
        str[0] = 0;
        if(a->symkind != D_NONE || a->reg != R_NONE || a->sym != S)
            snprint(str, sizeof(str), "%N(R%d)(NONE)", a, a->reg);
        break;

    case D_CONST:
        if(a->reg != R_NONE)
            snprint(str, sizeof(str), "$%N(R%d)", a, a->reg);
        else
            snprint(str, sizeof(str), "$%N", a);
        break;

    case D_SHIFT:
        v = a->offset;
        op = "<<>>->@>" + (((v>>5) & 3) << 1);
        if(v & (1<<4))
            snprint(str, sizeof(str), "R%d%c%cR%d", v&15, op[0], op[1], (v>>8)&15);
        else
            snprint(str, sizeof(str), "R%d%c%c%d", v&15, op[0], op[1], (v>>7)&31);
        if(a->reg != R_NONE)
            sprint(str+strlen(str), "(R%d)", a->reg);
        break;

    case D_OREG:
        if(a->reg != R_NONE)
            snprint(str, sizeof(str), "%N(R%d)", a, a->reg);
        else
            snprint(str, sizeof(str), "%N", a);
        break;

    case D_REG:
        snprint(str, sizeof(str), "R%d", a->reg);
        if(a->symkind != D_NONE || a->sym != S)
            snprint(str, sizeof(str), "%N(R%d)(REG)", a, a->reg);
        break;

    case D_FREG:
        snprint(str, sizeof(str), "F%d", a->reg);
        if(a->symkind != D_NONE || a->sym != S)
            snprint(str, sizeof(str), "%N(R%d)(REG)", a, a->reg);
        break;

    case D_PSR:
        snprint(str, sizeof(str), "PSR");
        if(a->symkind != D_NONE || a->sym != S)
            snprint(str, sizeof(str), "%N(PSR)(REG)", a);
        break;

    case D_BRANCH:
        snprint(str, sizeof(str), "%ld(PC)", a->offset-pc);
        break;

    case D_FCONST:
        snprint(str, sizeof(str), "$%.17e", a->dval);
        break;

    case D_SCONST:
        snprint(str, sizeof(str), "$\"%S\"", a->sval);
        break;
    }
    return fmtstrcpy(fp, str);
}
@





<<function Rconv(arm)>>=
// enum<operand_kind(register-only??)> -> string
int
Rconv(Fmt *fp)
{
    char str[STRINGSZ], *p, *e;
    Adr *a;
    int i, v;

    a = va_arg(fp->args, Adr*);
    snprint(str, sizeof(str), "GOK-reglist");
    switch(a->type) {
    case D_CONST:
        if(a->reg != R_NONE)
            break;
        if(a->sym != S)
            break;
        v = a->offset;
        p = str;
        e = str+sizeof(str);
        for(i=0; i<NREG; i++) {
            if(v & (1<<i)) {
                if(p == str)
                    p = seprint(p, e, "[R%d", i);
                else
                    p = seprint(p, e, ",R%d", i);
            }
        }
        seprint(p, e, "]");
    }
    return fmtstrcpy(fp, str);
}
@
% >> >>


<<function Sconv(arm)>>=
int
Sconv(Fmt *fp)
{
    int i, c;
    char str[STRINGSZ], *p, *a;

    a = va_arg(fp->args, char*);
    p = str;
    for(i=0; i<NSNAME; i++) {
        c = a[i] & 0xff;
        if(c >= 'a' && c <= 'z' ||
           c >= 'A' && c <= 'Z' ||
           c >= '0' && c <= '9' ||
           c == ' ' || c == '%') {
            *p++ = c;
            continue;
        }
        *p++ = '\\';
        switch(c) {
        case 0:
            *p++ = 'z';
            continue;
        case '\\':
        case '"':
            *p++ = c;
            continue;
        case '\n':
            *p++ = 'n';
            continue;
        case '\t':
            *p++ = 't';
            continue;
        case '\r':
            *p++ = 'r';
            continue;
        case '\f':
            *p++ = 'f';
            continue;
        }
        *p++ = (c>>6) + '0';
        *p++ = ((c>>3) & 7) + '0';
        *p++ = (c & 7) + '0';
    }
    *p = 0;
    return fmtstrcpy(fp, str);
}
@
% similar to 386 with additional:           c == ' ' || c == '%') {


<<function Nconv(arm)>>=
int
Nconv(Fmt *fp)
{
    char str[STRINGSZ];
    Adr *a;
    Sym *s;

    a = va_arg(fp->args, Adr*);
    s = a->sym;
    if(s == S) {
        snprint(str, sizeof(str), "%ld", a->offset);
        goto out;
    }
    switch(a->symkind) {
    case D_NONE:
        snprint(str, sizeof(str), "%ld", a->offset);
        break;

    case D_EXTERN:
        snprint(str, sizeof(str), "%s+%ld(SB)", s->name, a->offset);
        break;

    case D_STATIC:
        snprint(str, sizeof(str), "%s<>+%ld(SB)", s->name, a->offset);
        break;

    case D_AUTO:
        snprint(str, sizeof(str), "%s-%ld(SP)", s->name, -a->offset);
        break;

    case D_PARAM:
        snprint(str, sizeof(str), "%s+%ld(FP)", s->name, a->offset);
        break;

    default:
        snprint(str, sizeof(str), "GOK-name(%d)", a->symkind);
        break;

    }
out:
    return fmtstrcpy(fp, str);
}
@

\subsection{[[xxxnames[]]]}

% already seen onames and anames before


<<global cnames>>=
char*	cnames[NCTYPES];
@

<<global cnamesinit>>=
Init	cnamesinit[] =
{
    CXXX     ,		0,	"CXXX",
    CAUTO    ,		0,	"AUTO",
    CEXTERN  ,		0,	"EXTERN",
    CGLOBL   ,		0,	"GLOBL",
    CSTATIC  ,		0,	"STATIC",
    CLOCAL   ,		0,	"LOCAL",
    CTYPEDEF ,		0,	"TYPEDEF",
    CTYPESTR ,		0,	"TYPESTR",
    CPARAM   ,		0,	"PARAM",
    CEXREG   ,		0,	"EXREG",
    -1,			0,	0,
};
@


<<global qnames>>=
char*	qnames[NALLTYPES];
@

<<global qnamesinit>>=
Init	qnamesinit[] =
{
    TXXX      ,		0,	"TXXX",

    TCHAR     ,		0,	"CHAR",
    TUCHAR    ,		0,	"UCHAR",
    TSHORT    ,		0,	"SHORT",
    TUSHORT   ,		0,	"USHORT",
    TINT      ,		0,	"INT",
    TUINT     ,		0,	"UINT",
    TLONG     ,		0,	"LONG",
    TULONG    ,		0,	"ULONG",
    TVLONG    ,		0,	"VLONG",
    TUVLONG   ,		0,	"UVLONG",
    TFLOAT    ,		0,	"FLOAT",
    TDOUBLE   ,		0,	"DOUBLE",
    TIND      ,		0,	"IND",
    TFUNC     ,		0,	"FUNC",
    TARRAY    ,		0,	"ARRAY",
    TVOID     ,		0,	"VOID",
    TSTRUCT   ,		0,	"STRUCT",
    TUNION    ,		0,	"UNION",
    TENUM     ,		0,	"ENUM",

    TAUTO     ,		0,	"AUTO",
    TEXTERN   ,		0,	"EXTERN",
    TSTATIC   ,		0,	"STATIC",
    TTYPEDEF  ,		0,	"TYPEDEF",
    TTYPESTR  ,		0,	"TYPESTR",
    TREGISTER ,		0,	"REGISTER",
    TCONSTNT  ,		0,	"CONSTNT",
    TVOLATILE ,		0,	"VOLATILE",
    TUNSIGNED ,		0,	"UNSIGNED",
    TSIGNED   ,		0,	"SIGNED",
    TDOT      ,		0,	"DOT",
    TOLD      ,		0,	"OLD",

    -1,		0,	0,
};
@




<<global gnames>>=
char*	gnames[NGTYPES];
@

<<global gnamesinit>>=
Init	gnamesinit[] =
{
    GXXX,		0,	"GXXX",
    GCONSTNT,		0,	"CONST",
    GVOLATILE,		0,	"VOLATILE",
    GVOLATILE|GCONSTNT,	0,	"CONST-VOLATILE",
    -1,			0,	0,
};
@


<<[[tinit()]] initialise xxxnames debugging arrays>>=
for(p=bnamesinit; p->code >= 0; p++) {
    urk("bnames", nelem(bnames), p->code);
    bnames[p->code] = p->s;
}
for(p=tnamesinit; p->code >= 0; p++) {
    urk("tnames", nelem(tnames), p->code);
    tnames[p->code] = p->s;
}
for(p=gnamesinit; p->code >= 0; p++) {
    urk("gnames", nelem(gnames), p->code);
    gnames[p->code] = p->s;
}
for(p=qnamesinit; p->code >= 0; p++) {
    urk("qnames", nelem(qnames), p->code);
    qnames[p->code] = p->s;
}
for(p=cnamesinit; p->code >= 0; p++) {
    urk("cnames", nelem(cnames), p->code);
    cnames[p->code] = p->s;
}
for(p=onamesinit; p->code >= 0; p++) {
    urk("onames", nelem(onames), p->code);
    onames[p->code] = p->s;
}
@


\subsection{AST dumper, [[prtree()]], [[5c -x]]}
% this is useful! gcc still have not it, and RMS is actually
% opposing adding them to gcc (but for licensing issues).
% clang has it! (and pfff has it from the beginning of course ...)

<<function prtree>>=
void
prtree(Node *n, char *s)
{

    print(" == %s ==\n", s);
    prtree1(n, 0, false);
    print("\n");
}
@

% d = depth, indentation level
<<function prtree1>>=
void
prtree1(Node *n, int d, bool f)
{
    //bitset<Left|Right> to decide whether to recurse left and right child
    int i;

    if(f)
      for(i=0; i<d; i++)
        print("   ");
    if(n == Z) {
        print("Z\n");
        return;
    }

    if(n->op == OLIST) {
        prtree1(n->left, d, false);
        prtree1(n->right, d, true);
        return;
    }
    d++;
    print("%O", n->op);
    i = 3; // 1 | 2

    switch(n->op) {
    case OCONST:
        if(typefd[n->type->etype])
            print(" \"%.8e\"", n->fconst);
        else
            print(" \"%lld\"", n->vconst);
        i = 0;
        break;

    case OSTRING:
        print(" \"%s\"", n->cstring);
        i = 0;
        break;
    case OLSTRING:
        if(sizeof(TRune) == sizeof(Rune))
            print(" \"%S\"", (Rune*)n->rstring);
        else
            print(" \"...\"");
        i = 0;
        break;

    case ONAME:
        print(" \"%F\"", n);
        print(" %ld", n->xoffset);
        i = 0;
        break;
    case ODOT:
    case OELEM:
        print(" \"%F\"", n);
        break;

    case OREGISTER:
        if(n->xoffset)
            print(" %ld+R%d", n->xoffset, n->reg);
        else
            print(" R%d", n->reg);
        i = 0;
        break;
    case OINDREG:
        print(" %ld(R%d)", n->xoffset, n->reg);
        i = 0;
        break;

    }

    if(n->type != T)
        print(" %T", n->type);

    if(n->addable != 0)
        print(" <%d>", n->addable);
    if(n->complex != 0)
        print(" (%d)", n->complex);

    print(" %L\n", n->lineno);

    if(i & 2)
        prtree1(n->left, d, true);
    if(i & 1)
        prtree1(n->right, d, true);
}
@


\section{[[5c -v]], verbose mode}

% see diag(), with -v it will print == diagnostic == and then the AST dump
% via prtree()

\section{[[5c -m]], macro debugging}
% also in Assembler.nw

<<[[dodefine()]] debug>>=
if(debug['m'])
    print("#define (-D) %s %s\n", s->name, s->macro+1);
@

<<[[macdef()]] debug>>=
if(debug['m'])
    print("#define %s %s\n", s->name, s->macro+1);
@

\section{[[5c -f]], line information debugging}
% also in Assembler.nw

<<[[linehist()]] debug>>=
if(debug['f'])
    if(f) {
        if(offset)
            print("%4ld: %s (#line %d)\n", lineno, f, offset);
        else
            print("%4ld: %s\n", lineno, f);
    } else
        print("%4ld: <pop>\n", lineno);
@

\section{[[5c -L]], printing names}

\section{[[5c -d]], printing declarations}
% useful to debug, potentially useful to build tools too! e.g. tags file
% also print when revert a decl in revertdcl()

% labels
<<function dbgdecl>>=
void
dbgdecl(Sym *s)
{
    print("decl \"%s\": C=%s [B=%d:O=%ld] T=%T\n",
        s->name, cnames[s->class], s->block, s->offset, s->type);
}
@


\section{[[5c -t]], printing expression type trees}
% before and after different phases

\section{[[5c -g]], printing code generation information}
% for gins, gopcode, gen, cgen, sugen, ... print lhs and rhs

% print either resulting Prog (in gins, gopcode), or
% print Nodes

\section{[[5c -i]], printing initializations}

\section{[[5c -m]], printing arithmetic trees}

\section{[[5c -r]], printing registerization}

\section{[[5c -???]], ???}

\chapter{Error Managment}

<<global nerrors>>=
int	nerrors;
@

% main | compile | newio | newfile | yylex | ... -> <>
<<function errorexit>>=
void
errorexit(void)
{
    if(outfile)
        remove(outfile);
    exits("error");
}
@


<<function yyerror>>=
void
yyerror(char *fmt, ...)
{
    char buf[STRINGSZ];
    va_list arg;

    /*
     * hack to intercept message from yaccpar
     */
    if(strcmp(fmt, "syntax error") == 0) {
        yyerror("syntax error, last name: %s", symb);
        return;
    }
    va_start(arg, fmt);
    vseprint(buf, buf+sizeof(buf), fmt, arg);
    va_end(arg);
    Bprint(&diagbuf, "%L %s\n", lineno, buf);
    nerrors++;
    if(nerrors > 10) {
        Bprint(&diagbuf, "too many errors\n");
        errorexit();
    }
}
@


<<function diag>>=
void
diag(Node *n, char *fmt, ...)
{
    char buf[STRINGSZ];
    va_list arg;

    va_start(arg, fmt);
    vseprint(buf, buf+sizeof(buf), fmt, arg);
    va_end(arg);
    Bprint(&diagbuf, "%L %s\n", (n==Z)? nearln: n->lineno, buf);

    if(debug['X']){
        Bflush(&diagbuf);
        abort();
    }
    if(n != Z)
      if(debug['v'])
        prtree(n, "diagnostic");

    nerrors++;
    if(nerrors > 10) {
        Bprint(&diagbuf, "too many errors\n");
        errorexit();
    }
}
@



\chapter{Libc}

\section{Memory managment}
% same in Linker/assembler, not sure why they just don't use malloc?
% to avoid dependencies to libc? for bootstrapping reasons?

<<constant NHUNK>>=
#define	NHUNK		50000L
@

<<global hunk>>=
char*	hunk;
@

<<global nhunk>>=
long	nhunk;
@

<<global thunk>>=
long	thunk;
@

<<[[cinit()]] memory globals initialization>>=
nhunk = 0;
@


<<function gethunk>>=
void
gethunk(void)
{
    char *h;
    long nh;

    nh = NHUNK;
    if(thunk >= 10L*NHUNK)
        nh = 10L*NHUNK;

    h = (char*)sbrk(nh);
    if(h == (char*)-1) {
        yyerror("out of memory");
        errorexit();
    }
    hunk = h;
    nhunk = nh;
    thunk += nh;
}
@

<<constant MAXALIGN>>=
#define	MAXALIGN	7
@

<<function alloc>>=
/*
 * real allocs
 */
void*
alloc(long n)
{
    void *p;

    while((uintptr)hunk & MAXALIGN) {
        hunk++;
        nhunk--;
    }
    while(nhunk < n)
        gethunk();
    p = hunk;
    nhunk -= n;
    hunk += n;
    return p;
}
@

<<function allocn>>=
void*
allocn(void *p, long on, long n)
{
    void *q;

    q = (uchar*)p + on;
    if(q != hunk || nhunk < n) {
        while(nhunk < on+n)
            gethunk();
        memmove(hunk, p, on);
        p = hunk;
        hunk += on;
        nhunk -= on;
    }
    hunk += n;
    nhunk -= n;
    return p;
}
@


<<function malloc>>=
/*
 * fake mallocs
 */
void*
malloc(ulong n)
{
    return alloc(n);
}
@

% hmm so no free ... maybe ok in a compiler context?
<<function free>>=
void
free(void*)
{
}
@

<<function setmalloctag>>=
//@Scheck: looks dead, but because we redefine malloc/free we must also redefine that
void setmalloctag(void*, ulong)
{
}
@


\section{String managment}

% STRINGSZ here

\section{Bit operations}

% see also Bits structure

<<function topbit>>=
int
topbit(ulong v)
{
    int i;

    for(i = -1; v; i++)
        v >>= 1;
    return i;
}
@

<<function bitno>>=
int
bitno(long b)
{
    int i;

    for(i=0; i<32; i++)
        if(b & (1L<<i))
            return i;
    diag(Z, "bad in bitno");
    return 0;
}
@
% >>

<<function SIGN>>=
#define	SIGN(n)		(1ULL<<(n-1))
@
% >>
<<function MASK>>=
#define	MASK(n)		(SIGN(n)|(SIGN(n)-1))
@

\section{Mathematic functions}

% use diag so could not really be put in libc
<<function round>>=
long
round(long v, int w)
{
    int r;

    if(w <= 0 || w > 8) {
        diag(Z, "rounding by %d", w);
        w = 1;
    }
    r = v%w;
    if(r)
        v += w-r;
    return v;
}
@



<<function log2>>=
/*
 * return log(n) if n is a power of 2 constant
 */
int
log2(uvlong v)
{
    int s, i;
    uvlong m;

    s = 0;
    m = MASK(8*sizeof(uvlong));
    for(i=32; i; i>>=1) {
        m >>= i;
        if(!(v & m)) {
            v >>= i;
            s += i;
        }
    }
    if(v == 1)
        return s;
    return -1;
}
@

\section{Key/value data structure}

% mostly helper structure to build a  hash<enum<xxx>,string> to debug
%  enums values
% most of the time value is 0 and unused as people just want a int -> string
%less: they could use array designator though to get the same effects.
<<struct Init>>=
struct	Init			/* general purpose initialization */
{
    int		code;
    ulong	value;
    char*	s;
};
@

\section{Portability}

<<enum os>>=
enum os				/* also in ../{8a,5a,0a}.h */
{
    Plan9	= 1<<0,
    Unix	= 1<<1,
    //Windows	= 1<<2,
};
@

\chapter{Extra Code}

\ifallcode
#include "Compiler_extra.nw"
\fi

\chapter{Changelog}
\label{sec:changelog}




\chapter{Glossary}
\label{sec:glossary}

\begin{verbatim}
SUE = Structure/Union/Enum
SU  = Structure/Union
\end{verbatim}






\chapter*{Indexes}
\addcontentsline{toc}{section}{Index}

%\chapter{References} 
\addcontentsline{toc}{section}{References}

\begin{thebibliography}{99}

\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming}, 
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb}, 
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison}, 
\url{http://padator.org/software/project-syncweb/readme.txt}

\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
