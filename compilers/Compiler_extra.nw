\section{[[cc/]]}

\subsection*{[[cc/cc.h]]}

<<constant [[YYMAXDEPTH]]>>=
#define YYMAXDEPTH	1500
@

%-------------------------------------------------------------

<<cc/cc.h>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <ctype.h>

#pragma	lib	"../cc/cc.a$O" //$

typedef	struct	Node	Node;
typedef	struct	Type	Type;
typedef	struct	Sym		Sym;
typedef	struct	Decl	Decl;
typedef	struct	Funct	Funct;
typedef	struct	Io		Io;
typedef	struct	Hist	Hist;
typedef	struct	Term	Term;
typedef	struct	Init	Init;
typedef	struct	Bits	Bits;

typedef	Rune	TRune;	/* target system type */

<<constant [[NHUNK]]>>
<<constant [[BUFSIZ]]>>
<<constant [[NSYMB]]>>
<<constant [[NHASH]]>>
<<constant [[STRINGSZ]]>>
<<constant [[HISTSZ]]>>
<<constant [[YYMAXDEPTH]]>>
<<constant [[NTERM]]>>
<<constant [[MAXALIGN]]>>

<<function [[SIGN]]>>
<<function [[MASK]]>>

<<constant [[BITS]]>>
<<constant [[NVAR]]>>
<<struct [[Bits]]>>

<<struct [[Node]]>>
<<constant [[Z]]>>

<<struct [[Sym]]>>
<<constant [[S]]>>

<<enum [[signature]]>>

<<struct [[Decl]]>>
<<constant [[D]]>>

<<struct [[Type]]>>
<<constant [[T]]>>
<<constant [[NODECL]]>>

<<struct [[Init]]>>


<<struct [[Fi]]>>
extern struct Fi fi;

<<struct [[Io]]>>
<<constant [[I]]>>

<<struct [[Hist]]>>
<<constant [[H]]>>
extern Hist*	hist;

<<struct [[Term]]>>

<<enum [[os]]>>
<<enum [[node_kind]]>>
<<enum [[type_kind]]>>
<<enum [[type_kind_bis]]>>
<<enum [[align]]>>
<<enum [[dxxx]]>>
<<enum [[storage_class]]>>
<<enum [[qualifier]]>>
<<enum [[bxxx]]>>

<<struct [[Funct]]>>

<<struct [[En]]>>
extern struct En en;

extern	int	autobn;
extern	long	autoffset;
extern	int	blockno;
extern	Decl*	dclstack;
extern	char	debug[256];
extern	Hist*	ehist;
extern	bool	firstbit;
extern	Sym*	firstarg;
extern	Type*	firstargtype;
extern	Decl*	firstdcl;
extern	Sym*	hash[NHASH];
extern	char*	hunk;
extern	char**	include;
extern	Io*	iofree;
extern	Io*	ionext;
extern	Io*	iostack;
extern	long	lastbit;
extern	char	lastclass;
extern	Type*	lastdcltype;
extern	long	lastfield;
extern	Type*	lasttype;
extern	long	lineno;
extern	long	nearln;
extern	int	maxinclude;
extern	int	nerrors;
extern	bool	newflag;
extern	long	nhunk;
extern	int	ninclude;
extern	Node*	nodproto;
extern	Node*	nodcast;
extern	Biobuf	outbuf;
extern	Biobuf	diagbuf;
extern	char*	outfile;
extern	char*	pathname;
extern	int	peekc;
extern	long	stkoff;
extern	Type*	strf;
extern	Type*	strl;
extern	char	symb[NSYMB];
extern	Sym*	symstring;
extern	int	taggen;
extern	Type*	tfield;
extern	Type*	tufield;
extern	int	thechar;
extern	char*	thestring;
extern	Type*	thisfntype;
extern	long	thunk;
extern	Type*	types[NTYPE];

extern	Type*	fntypes[NTYPE];
extern	Node*	initlist;
extern	Term	term[NTERM];
extern	int	nterm;
extern	int	packflg;
extern	int	fproundflg;
extern	bool	profileflg;
extern	int	ncontin;
extern	int	canreach;
extern	int	warnreach;
extern	Bits	zbits;

extern	char	*onames[], *tnames[], *gnames[];
extern	char	*cnames[], *qnames[], *bnames[];

extern	char	comrel[], invrel[], logrel[];
extern	long	ncast[], tadd[], tand[];
extern	long	targ[], tasadd[], tasign[], tcast[];
extern	long	tdot[], tfunct[], tindir[], tmul[];
extern	long	tnot[], trel[], tsub[];

extern	char	typeaf[];
extern	char	typefd[];
extern	char	typei[];
extern	char	typesu[];
extern	char	typesuv[];
extern	char	typeu[];
extern	char	typev[];
extern	char	typeilp[];
extern	char	typechl[];

// not used on ARM
extern	char	typechlv[];
extern	char	typeil[];

extern	char	typechlp[];
extern	char	typechlpfd[];

extern	char*	typeswitch;
extern	char*	typeword;
extern	char*	typecmplx;

extern	ulong	thash1;
extern	ulong	thash2;
extern	ulong	thash3;
extern	ulong	thash[];

/*
 *	compat.c/unix.c/windows.c
 */
int	mywait(int*);
int	mycreat(char*, int);
int	myaccess(char*);
int	pathchar(void);
bool	systemtype(int);

// utils.c
void	gethunk(void);
void*	allocn(void*, long, long);
void*	alloc(long);
void	errorexit(void);
void	yyerror(char*, ...);

/*
 *	parser
 */
//@Scheck: def in y.tab.c from cc.y
int	yyparse(void);

/*
 *	lex.c
 */
long	yylex(void);

Sym*	lookup(void);
Sym*	slookup(char*);

int	filbuf(void);
int	getc(void);
int	getnsc(void);
void	newfile(char*, int);
void	newio(void);
void	pushio(void);
void	unget(int);

// used by dpchk.c
long	getr(void);

//!!!! (hmmm in lex.c, as well as cinit(), compile())
void	main(int, char*[]);


/*
 * mac.c
 */
void	dodefine(char*);
void	domacro(void);
void	linehist(char*, int);
void	macexpand(Sym*, char*);

// for dpchk.c
Sym*	getsym(void);
long	getnsn(void);

/*
 * dcl.c
 */
//@Scheck: useful, used by cc.y
Type*	tcopy(Type*);
//@Scheck: useful, used by cc.y
Node*	doinit(Sym*, Type*, long, Node*);
//@Scheck: useful, used by cc.y
void	adecl(int, Type*, Sym*);
void	argmark(Node*, int);
Node*	dcllabel(Sym*, int);
Node*	dodecl(void(*)(int, Type*, Sym*), int, Type*, Node*);
//@Scheck: useful, used by cc.y
Sym*	mkstatic(Sym*);
void	doenum(Sym*, Node*);
void	snap(Type*);
Type*	dotag(Sym*, int, int);
void	edecl(int, Type*, Sym*);
void	markdcl(void);
//@Scheck: useful, used by cc.y
void	pdecl(int, Type*, Sym*);
Node*	revertdcl(void);
long	round(long, int);
int	sametype(Type*, Type*);
ulong	sign(Sym*);
ulong	signature(Type*);
void	sualign(Type*);
void	xdecl(int, Type*, Sym*);
Node*	contig(Sym*, Node*, long);

/*
 * com.c
 */
void	ccom(Node*);
void	complex(Node*);
int	tcom(Node*);
int	tcoma(Node*, Node*, Type*, int);
int	tcomo(Node*, int);
void	constas(Node*, Type*, Type*);
Node*	uncomma(Node*);

/*
 * con.c
 */
void	acom(Node*);
void	evconst(Node*);

/*
 * funct.c
 */
int	isfunct(Node*);
void	dclfunct(Type*, Sym*);

/*
 * sub.c
 */
void	arith(Node*, int);
int	deadheads(Node*);
Type*	dotsearch(Sym*, Type*, Node*, long*);
Node*	invert(Node*);
int	bitno(long);
void	makedot(Node*, Type*, long);
int	mixedasop(Type*, Type*);
Node*	new(int, Node*, Node*);
Node*	new1(int, Node*, Node*);
int	nilcast(Type*, Type*);
int	nocast(Type*, Type*);
void	prtree(Node*, char*);
void	prtree1(Node*, int, int);
void	relcon(Node*, Node*);
int	relindex(int);
//@Scheck: useful, used by cc.y
int	simpleg(long);
Type*	garbt(Type*, long);
int	simplec(long);
Type*	simplet(long);
int	stcompat(Node*, Type*, Type*, long[]);
int	tcompat(Node*, Type*, Type*, long[]);
void	tinit(void);
Type*	typ(int, Type*);
Type*	copytyp(Type*);
void	typeext(Type*, Node*);
void	typeext1(Type*, Node*);
int	side(Node*);
int	vconst(Node*);
int	log2(uvlong);
int	vlog(Node*);
int	topbit(ulong);
void	simplifyshift(Node*);
long	typebitor(long, long);
void	diag(Node*, char*, ...);
void	warn(Node*, char*, ...);
void	fatal(Node*, char*, ...);

/*
 * acid.c
 */
void	acidtype(Type*);
void	acidvar(Sym*);

/*
 * pickle.c
 */
void	pickletype(Type*);

/*
 * bits.c
 */
Bits	bor(Bits, Bits);
int	bany(Bits*);
int	bnum(Bits);
Bits	blsh(uint);
int	beq(Bits, Bits);
int	bset(Bits, uint);
//Bits	band(Bits, Bits);
//Bits	bnot(Bits);

/*
 * dpchk.c
 */
void dpcheck(Node*);
void arginit(void);

void pragvararg(void);
void pragpack(void);
void pragfpround(void);
void pragprofile(void);
void pragincomplete(void);

/*
 * calls to machine depend part
 */
//todo: could define an interface instantiated by each xc
void	codgen(Node*, Node*);
void	gclean(void);
void	gextern(Sym*, Node*, long, long);
void	ginit(void);
long	outstring(char*, long);
long	outlstring(TRune*, long);
void	xcom(Node*);
long	exreg(Type*);
long	align(long, Type*, int);
long	maxround(long, long);

extern	schar	ewidth[];

/*
 * com64
 */
int	com64(Node*);
void	com64init(void);
void	bool64(Node*);
vlong	convvtox(vlong, int);
//double	convvtof(vlong);
//vlong		convftov(double);
//double	convftox(double, int);

/*
 * machcap
 */
int	machcap(Node*);

#pragma	varargck	argpos	warn	2
#pragma	varargck	argpos	diag	2
#pragma	varargck	argpos	yyerror	1

#pragma	varargck	type	"F"	Node*
#pragma	varargck	type	"L"	long
#pragma	varargck	type	"Q"	long
#pragma	varargck	type	"O"	int
#pragma	varargck	type	"T"	Type*
#pragma	varargck	type	"|"	int
@
%$


\subsection*{[[cc/globals.c]]}

%<<global fperror>>=
%//int	fperror;
%@

%-------------------------------------------------------------

<<cc/globals.c>>=
#include "cc.h"

<<global [[fi]]>>
<<global [[hist]]>>
<<global [[en]]>>

<<global [[autobn]]>>
<<global [[autoffset]]>>
<<global [[blockno]]>>
<<global [[dclstack]]>>
<<global [[debug]]>>
<<global [[ehist]]>>
<<global [[firstbit]]>>
<<global [[firstarg]]>>
<<global [[firstargtype]]>>
<<global [[firstdcl]]>>
<<global [[hash]]>>
<<global [[hunk]]>>
<<global [[include]]>>
<<global [[iofree]]>>
<<global [[ionext]]>>
<<global [[iostack]]>>
<<global [[lastbit]]>>
<<global [[lastclass]]>>
<<global [[lastdcl]]>>
<<global [[lastfield]]>>
<<global [[lasttype]]>>
<<global [[lineno]]>>
<<global [[nearln]]>>
<<global [[maxinclude]]>>
<<global [[nerrors]]>>
<<global [[newflag]]>>
<<global [[nhunk]]>>
<<global [[ninclude]]>>
<<global [[nodproto]]>>
<<global [[nodcast]]>>
<<global [[outbuf]]>>
<<global [[diagbuf]]>>
<<global [[outfile]]>>
<<global [[pathname]]>>
<<global [[peekc]]>>
<<global [[stkoff]]>>
<<global [[strf]]>>
<<global [[strl]]>>
<<global [[symb]]>>
<<global [[symstring]]>>
<<global [[taggen]]>>
<<global [[tfield]]>>
<<global [[tufield]]>>
<<global [[thechar]]>>
<<global [[thestring]]>>
<<global [[thisfn]]>>
<<global [[thunk]]>>
<<global [[types]]>>
<<global [[fntypes]]>>
<<global [[initlist]]>>
<<global [[term]]>>
<<global [[nterm]]>>
<<global [[packflg]]>>
<<global [[fproundflg]]>>
<<global [[profileflg]]>>
<<global [[ncontin]]>>
<<global [[canreach]]>>
<<global [[warnreach]]>>
<<global [[zbits]]>>

<<global [[typeswitch]]>>
<<global [[typeword]]>>
<<global [[typecmplx]]>>
@


\subsection*{[[cc/omachcap.c]]}

%-------------------------------------------------------------

<<cc/omachcap.c>>=
#include	"cc.h"

/* default, like old cc */
//int
//machcap(Node*)
//{
//	return 0;
//}
@



\subsection*{[[cc/compat.c]]}

%<<function calloc>>=
%//void*
%//calloc(ulong m, ulong n)
%//{
%//    return alloc(m*n);
%//}
%@
%
%<<function realloc>>=
%//void*
%//realloc(void*, ulong)
%//{
%//    fprint(2, "realloc called\n");
%//    abort();
%//    return 0;
%//}
%@
%
%<<function mallocz>>=
%/* needed when profiling */
%//void*
%//mallocz(ulong size, int clr)
%//{
%//    void *v;
%//
%//    v = alloc(size);
%//    if(clr && v != nil)
%//        memset(v, 0, size);
%//    return v;
%//}
%@


%-------------------------------------------------------------

<<cc/compat.c>>=
#include	"cc.h"

//#include	"compat"
//TODO copy paste with aa/, maybe could factorize with another lib?
//

int
myaccess(char *f)
{
 return access(f, AEXIST);
}


int
mycreat(char *n, int p)
{

 return create(n, 1, p);
}

int
mywait(int *s)
{
 int p;
 Waitmsg *w;

 if((w = wait()) == nil)
  return -1;
 else{
  p = w->pid;
  *s = 0;
  if(w->msg[0])
   *s = 1;
  free(w);
  return p;
 }
}

bool
systemtype(int sys)
{
 return sys & Plan9;
}

int
pathchar(void)
{
 return '/';
}

<<function [[malloc]]>>

<<function [[free]]>>

<<function [[setmalloctag]]>>
@

% on pathchar() :) why DOS used '\' instead of '/'
%http://blogs.msdn.com/b/larryosterman/archive/2005/06/24/432386.aspx


\subsection*{[[cc/utils.c]]}

%-------------------------------------------------------------

<<cc/utils.c>>=
#include "cc.h"

<<function [[errorexit]]>>

<<function [[gethunk]]>>

<<function [[alloc]]>>

<<function [[allocn]]>>

<<function [[yyerror]]>>

@

\subsection*{[[cc/mac.c]]}

%-------------------------------------------------------------

<<cc/mac.c>>=
#include	"cc.h"

//old: #include	"macbody"
//TODO copy paste with aa/, maybe could factorize with another lib?

void	macdef(void);
void	macinc(void);
void	macprag(void);
void	maclin(void);
void	macif(int);
void	macend(void);
void	macund(void);

long	getnsn(void);
Sym*	getsym(void);

<<constant [[VARMAC]]>>

<<function [[getnsn]]>>

<<function [[getsym]]>>

<<function [[getsymdots]]>>

<<function [[getcom]]>>

<<function [[dodefine]]>>

<<global [[mactab]]>>

<<function [[domacro]]>>

<<function [[macund]]>>

<<constant [[NARG]]>>
<<function [[macdef]]>>

<<function [[macexpand]]>>

<<function [[macinc]]>>

<<function [[maclin]]>>

<<function [[macif]]>>

<<function [[macprag]]>>

<<function [[macend]]>>

<<function [[linehist]]>>

@


\subsection*{[[cc/sub.c]]}

%dead:
%extern	char	typechlvp[];
%extern	char	typec[];
%extern	char	typeh[];

%-------------------------------------------------------------

<<cc/sub.c>>=
#include	"cc.h"

int	simpleg(long);
long	dotoffset(Type*, Type*, Node*);

extern	char	tab[NTYPE][NTYPE];

<<function [[new]]>>

<<function [[new1]]>>

<<function [[prtree]]>>

<<function [[prtree1]]>>

<<function [[typ]]>>

<<function [[copytyp]]>>

<<function [[garbt]]>>

<<function [[simpleg]]>>

<<function [[simplec]]>>

<<function [[simplet]]>>

<<function [[stcompat]]>>

<<function [[tcompat]]>>

<<function [[makedot]]>>

<<function [[dotsearch]]>>

<<function [[dotoffset]]>>

<<function [[allfloat]]>>

<<function [[constas]]>>

<<function [[typeext1]]>>

<<function [[typeext]]>>

<<function [[nocast]]>>

<<function [[nilcast]]>>

<<function [[arith]]>>

<<function [[simplifyshift]]>>

<<function [[side]]>>

<<function [[vconst]]>>

<<function [[log2]]>>

<<function [[vlog]]>>

<<function [[topbit]]>>

<<function [[relcon]]>>

<<function [[relindex]]>>

<<function [[invert]]>>

<<function [[bitno]]>>

<<function [[typebitor]]>>

<<function [[diag]]>>

<<function [[warn]]>>

<<function [[fatal]]>>

<<global [[thash1]]>>
<<global [[thash2]]>>
<<global [[thash3]]>>
<<global [[thash]]>>
<<global [[thashinit]]>>

<<global [[bnames]]>>
<<global [[bnamesinit]]>>

<<global [[tnames]]>>
<<global [[tnamesinit]]>>

<<global [[gnames]]>>
<<global [[gnamesinit]]>>

<<global [[qnames]]>>
<<global [[qnamesinit]]>>
<<global [[cnames]]>>
<<global [[cnamesinit]]>>

<<global [[onames]]>>
<<global [[onamesinit]]>>

<<global [[comrel]]>>
<<global [[invrel]]>>
<<global [[logrel]]>>

<<global [[typei]]>>
<<global [[typeiinit]]>>
<<global [[typeu]]>>
<<global [[typeuinit]]>>

<<global [[typesuv]]>>
<<global [[typesuvinit]]>>

// not used on ARM
<<global [[typechlv]]>>
<<global [[typeil]]>>
<<global [[typeilinit]]>>

<<global [[typeilp]]>>
<<global [[typeilpinit]]>>

<<global [[typechl]]>>
<<global [[typechlinit]]>>

<<global [[typechlp]]>>
<<global [[typechlpinit]]>>

<<global [[typechlpfd]]>>
<<global [[typechlpfdinit]]>>

<<global [[typev]]>>
<<global [[typevinit]]>>

<<global [[typefd]]>>
<<global [[typefdinit]]>>

<<global [[typeaf]]>>
<<global [[typeafinit]]>>

<<global [[typesu]]>>
<<global [[typesuinit]]>>

<<global [[tasign]]>>
<<global [[tasigninit]]>>

<<global [[tasadd]]>>
<<global [[tasaddinit]]>>

<<global [[tcast]]>>
<<global [[tcastinit]]>>

<<global [[tadd]]>>
<<global [[taddinit]]>>

<<global [[tsub]]>>
<<global [[tsubinit]]>>

<<global [[tmul]]>>
<<global [[tmulinit]]>>

<<global [[tand]]>>
<<global [[tandinit]]>>

<<global [[trel]]>>
<<global [[trelinit]]>>

<<global [[tfunct]]>>

<<global [[tindir]]>>

<<global [[tdot]]>>

<<global [[tnot]]>>

<<global [[targ]]>>

<<global [[tab]]>>

<<function [[urk]]>>

<<function [[tinit]]>>

<<function [[deadhead]]>>

<<function [[deadheads]]>>

<<function [[mixedasop]]>>
@


\subsection*{[[cc/bits.c]]}

%-------------------------------------------------------------

<<cc/bits.c>>=
#include	"cc.h"

<<function [[bor]]>>

<<function [[bany]]>>

<<function [[beq]]>>

<<function [[bnum]]>>

<<function [[blsh]]>>

<<function [[bset]]>>
@


\subsection*{[[cc/lex.c]]}

%-------------------------------------------------------------

<<cc/lex.c>>=
#include	"cc.h"
#include	"y.tab.h"

int	compile(char*, char**, int);
void	syminit(Sym*);
int	mpatov(char*, vlong*);
long	getr(void);
long	escchar(long, int, int);
void	cinit(void);

int	Oconv(Fmt*);
int	Lconv(Fmt*);
int	Tconv(Fmt*);
int	FNconv(Fmt*);
int	Qconv(Fmt*);
int	VBconv(Fmt*);

void	setinclude(char*);


#ifndef	CPP
<<constant [[CPP]]>>
#endif

/*
 * known debug flags
 *	-a		acid declaration output
 *	-A		!B
 *	-B		non ANSI
 *	-d		print declarations
 *	-D name		define
 *	-F		format specification check
 *	-i		print initialization
 *	-I path		include
 *	-l		generate little-endian code
 *	-L		print every NAME symbol
 *	-M		constant multiplication
 *	-m		print add/sub/mul trees
 *	-n		print acid to file (%.c=%.acid) (with -a or -aa)
 *	-o file		output file
 *	-p		use standard cpp ANSI preprocessor (not on windows)
 *	-r		print registerization
 *	-s		print structure offsets (with -a or -aa)
 *	-S		print assembly
 *	-t		print type trees
 *	-V		enable void* conversion warnings
 *	-v		verbose printing
 *	-w		print warnings
 *	-X		abort on error
 *	-.		Inhibit search for includes in source directory
 */

<<function [[main]]>>

<<function [[compile]]>>


<<function [[pushio]]>>

<<function [[newio]]>>

<<function [[newfile]]>>


<<function [[slookup]]>>

<<function [[lookup]]>>

<<function [[syminit]]>>

<<constant [[EOF]]>>
<<constant [[IGN]]>>
<<constant [[ESC]]>>
<<function [[GETC]]>>

<<enum [[numxxx]]>>

<<function [[yylex]]>>


<<function [[mpatov]]>>

<<function [[getc]]>>

<<function [[getr]]>>

<<function [[getnsc]]>>

<<function [[unget]]>>

<<function [[escchar]]>>

<<global [[itab]]>>

<<function [[cinit]]>>

<<function [[filbuf]]>>



<<function [[Oconv]]>>

<<struct [[Atab]]>>

<<function [[Lconv]]>>

<<function [[Tconv]]>>

<<function [[FNconv]]>>

<<function [[Qconv]]>>

<<function [[VBconv]]>>

<<function [[setinclude]]>>
@


\subsection*{[[cc/acid.c]]}

%-------------------------------------------------------------

<<cc/acid.c>>=
#include "cc.h"

<<global [[kwd]]>>

<<function [[amap]]>>

<<function [[acidsue]]>>

<<function [[acidfun]]>>

<<global [[acidchar]]>>
<<global [[acidcinit]]>>

<<function [[acidinit]]>>

<<function [[acidmember]]>>

<<function [[acidtype]]>>

<<function [[acidvar]]>>
@


\subsection*{[[cc/pickle.c]]}

%-------------------------------------------------------------

<<cc/pickle.c>>=
#include "cc.h"

<<global kwd (cc/pickle.c)>>
<<global [[picklestr]]>>

<<function [[pmap]]>>

<<function [[picklesue]]>>

<<global [[picklechar]]>>
<<global [[picklecinit]]>>

<<function [[pickleinit]]>>

<<function [[picklemember]]>>

<<function [[pickletype]]>>

@


\subsection*{[[cc/com64.c]]}

%-------------------------------------------------------------

<<cc/com64.c>>=
#include "cc.h"

<<constant [[FNX]]>>

<<global [[nodaddv]]>>
<<global [[nodsubv]]>>
<<global [[nodmulv]]>>
<<global [[noddivv]]>>
<<global [[noddivvu]]>>
<<global [[nodmodv]]>>
<<global [[nodmodvu]]>>
<<global [[nodlshv]]>>
<<global [[nodrshav]]>>
<<global [[nodrshlv]]>>
<<global [[nodandv]]>>
<<global [[nodorv]]>>
<<global [[nodxorv]]>>
<<global [[nodnegv]]>>
<<global [[nodcomv]]>>

<<global [[nodtestv]]>>
<<global [[nodeqv]]>>
<<global [[nodnev]]>>
<<global [[nodlev]]>>
<<global [[nodltv]]>>
<<global [[nodgev]]>>
<<global [[nodgtv]]>>
<<global [[nodhiv]]>>
<<global [[nodhsv]]>>
<<global [[nodlov]]>>
<<global [[nodlsv]]>>

<<global [[nodf2v]]>>
<<global [[nodd2v]]>>
<<global [[nodp2v]]>>
<<global [[nodsi2v]]>>
<<global [[nodui2v]]>>
<<global [[nodsl2v]]>>
<<global [[nodul2v]]>>
<<global [[nodsh2v]]>>
<<global [[noduh2v]]>>
<<global [[nodsc2v]]>>
<<global [[noduc2v]]>>

<<global [[nodv2f]]>>
<<global [[nodv2d]]>>
<<global [[nodv2ui]]>>
<<global [[nodv2si]]>>
<<global [[nodv2ul]]>>
<<global [[nodv2sl]]>>
<<global [[nodv2uh]]>>
<<global [[nodv2sh]]>>
<<global [[nodv2uc]]>>
<<global [[nodv2sc]]>>

<<global [[nodvpp]]>>
<<global [[nodppv]]>>
<<global [[nodvmm]]>>
<<global [[nodmmv]]>>

<<global [[nodvasop]]>>

<<global [[etconv]]>>
<<global [[initetconv]]>>

<<function [[fvn]]>>

<<function [[com64init]]>>

<<function [[com64]]>>

<<function [[bool64]]>>

<<function [[convvtox]]>>
@

\subsection*{[[cc/dcl.c]]}

%-------------------------------------------------------------

<<cc/dcl.c>>=
#include "cc.h"

Sym*	mkstatic(Sym*);
Type*	tcopy(Type*);
Node*	doinit(Sym*, Type*, long, Node*);
Node*	init1(Sym*, Type*, long, int);
Node*	newlist(Node*, Node*);
void	walkparam(Node*, int);
Type*	fnproto(Node*);
Type*	fnproto1(Node*);
int	anyproto(Node*);
void	dbgdecl(Sym*);
Decl*	push(void);
Decl*	push1(Sym*);
int	rsametype(Type*, Type*, int, int);
Type*	paramconv(Type*, int);
void	adecl(int, Type*, Sym*);
void	pdecl(int, Type*, Sym*);
void	tmerge(Type*, Sym*);

<<function [[dodecl]]>>

<<function [[mkstatic]]>>

<<function [[tcopy]]>>

<<function [[doinit]]>>

<<function [[peekinit]]>>

<<function [[nextinit]]>>

<<function [[isstruct]]>>

<<function [[init1]]>>

<<function [[newlist]]>>

<<function [[sualign]]>>

<<function [[round]]>>

<<function [[ofnproto]]>>

<<constant [[ANSIPROTO]]>>
<<constant [[OLDPROTO]]>>

<<function [[argmark]]>>

<<function [[walkparam]]>>

<<function [[markdcl]]>>

<<function [[revertdcl]]>>

<<function [[fnproto]]>>

<<function [[anyproto]]>>

<<function [[fnproto1]]>>

<<function [[dbgdecl]]>>

<<function [[push]]>>

<<function [[push1]]>>

<<function [[sametype]]>>

<<function [[rsametype]]>>

typedef struct Typetab Typetab;

<<struct [[Typetab]]>>

<<function [[sigind]]>>

<<function [[signat]]>>

<<function [[signature]]>>

<<function [[sign]]>>

<<function [[snap]]>>

<<function [[dotag]]>>

<<function [[dcllabel]]>>

<<function [[paramconv]]>>

<<function [[adecl]]>>

<<function [[pdecl]]>>

<<function [[xdecl]]>>

<<function [[tmerge]]>>

<<function [[edecl]]>>

<<function [[maxtype]]>>

<<function [[doenum]]>>

<<function [[symadjust]]>>

<<function [[contig]]>>
@


\subsection*{[[cc/funct.c]]}

%-------------------------------------------------------------

<<cc/funct.c>>=
#include	"cc.h"

typedef	struct	Ftab	Ftab;
typedef	struct	Gtab	Gtab;

<<struct [[Ftab]]>>
<<struct [[Gtab]]>>

<<global [[gtabinit]]>>
<<global [[ftabinit]]>>

<<function [[isfunct]]>>
<<function [[dclfunct]]>>
@


\subsection*{[[cc/scon.c]]}

%-------------------------------------------------------------

<<cc/scon.c>>=
#include "cc.h"

void	acom1(vlong, Node*);
void	acom2(Node*, Type*);
int	acomcmp1(const void*, const void*);
int	acomcmp2(const void*, const void*);
int	addo(Node*);

<<function [[acast]]>>

<<function [[evconst]]>>

<<function [[acom]]>>

<<function [[acomcmp1]]>>

<<function [[acomcmp2]]>>

<<function [[acom2]]>>

<<function [[acom1]]>>

<<function [[addo]]>>
@


\subsection*{[[cc/dpchk.c]]}

%-------------------------------------------------------------

<<cc/dpchk.c>>=
#include	"cc.h"
#include	"y.tab.h"

<<enum [[fxxx]]>>

typedef	struct	Tprot	Tprot;
<<struct [[Tprot]]>>

typedef	struct	Tname	Tname;
<<struct [[Tname]]>>

<<global [[indchar]]>>
<<global [[flagbits]]>>
<<global [[fmtbuf]]>>
<<global [[lastadj]]>>
<<global [[lastverb]]>>
<<global [[nstar]]>>
<<global [[tprot]]>>
<<global [[tname]]>>

<<function [[argflag]]>>

<<function [[getflag]]>>

<<function [[arginit]]>>

<<function [[nextarg]]>>

<<function [[checkargs]]>>

<<function [[dpcheck]]>>


<<function [[pragpack]]>>

<<function [[newname]]>>

<<function [[newprot]]>>

<<function [[pragvararg]]>>

<<function [[pragfpround]]>>

<<function [[pragprofile]]>>

<<function [[pragincomplete]]>>

@


\subsection*{[[cc/com.c]]}

%-------------------------------------------------------------

<<cc/com.c>>=
#include "cc.h"

int	tcomd(Node*);
int	tcomx(Node*);
int	tlvalue(Node*);

typedef struct Com Com;
typedef struct Big Big;

<<struct [[Com]]>>

int compar(Node*, int);
static void comma(Node*);
static Node*	commas(Com*, Node*);

<<function [[complex]]>>

<<enum [[_anon_ (cc/com.c)]]>>

<<function [[tcom]]>>

<<function [[tcomo]]>>

<<function [[tcoma]]>>

<<function [[tcomd]]>>

<<function [[tcomx]]>>

<<function [[tlvalue]]>>

<<function [[comargs]]>>

<<function [[commas]]>>

<<function [[comma]]>>

<<function [[ccom]]>>

<<global [[cmps]]>>

<<struct [[Big]]>>
<<function [[cmp]]>>
<<function [[add]]>>

<<function [[big]]>>

<<function [[compar]]>>

@

\section{[[cc2/]]}

\subsection*{[[cc2/pswt.c]]}

%-------------------------------------------------------------

<<cc2/pswt.c>>=
#include "gc.h"

<<function [[swcmp]]>>

<<function [[doswit]]>>

<<function [[casf]]>>

<<function [[outlstring]]>>

<<function [[nullwarn]]>>

<<function [[ieeedtod]]>>
@


\subsection*{[[cc2/pgen.c]]}

%-------------------------------------------------------------

<<cc2/pgen.c>>=
#include "gc.h"

void	gen(Node*);
void	usedset(Node*, int);
int		bcomplex(Node*, Node*);

<<function [[codgen]]>>

<<function [[supgen]]>>

<<function [[uncomma]]>>

<<function [[gen]]>>

<<function [[usedset]]>>

<<function [[bcomplex]]>>
@







\section{[[5c/]]}


\subsection*{[[5c/enam.c]]}


%-------------------------------------------------------------

<<5c/enam.c>>=
<<global [[anames]](arm)>>
@


\subsection*{[[5c/gc.h]]}

%<<function BLOAD(arm)>>=
%#define	BLOAD(r)	band(bnot(r->refbehind), r->refahead)
%@
%
%<<function BSTORE(arm)>>=
%#define	BSTORE(r)	band(bnot(r->calbehind), r->calahead)
%@
%
%<<constant CINF(arm)>>=
%#define	CINF	1000
%@

%-------------------------------------------------------------

<<5c/gc.h>>=
#include	"../cc/cc.h"

#include	<common.out.h>
#include	<5.out.h>

/*
 * 5c/arm
 * Arm
 */

<<constant [[SZ_CHAR]](arm)>>
<<constant [[SZ_SHORT]](arm)>>
<<constant [[SZ_INT]](arm)>>
<<constant [[SZ_LONG]](arm)>>
<<constant [[SZ_IND]](arm)>>
<<constant [[SZ_FLOAT]](arm)>>
<<constant [[SZ_VLONG]](arm)>>
<<constant [[SZ_DOUBLE]](arm)>>
<<constant [[FNX]](arm)>>
<<constant [[BTRUE]](arm)>>

typedef	struct	Adr		Adr;
typedef	struct	Prog	Prog;
typedef	struct	Case	Case;
typedef	struct	C1		C1;
typedef	struct	Multab	Multab;
typedef	struct	Hintab	Hintab;
typedef	struct	Var		Var;
typedef	struct	Reg		Reg;
typedef	struct	Rgn		Rgn;


<<struct [[Adr]](arm)>>
<<constant [[A]]>>

<<constant [[INDEXED]](arm)>>
<<struct [[Prog]](arm)>>
<<constant [[P]]>>

<<struct [[Case]]>>
<<constant [[C]]>>

<<struct [[C1]]>>

<<struct [[Multab]](arm)>>

<<struct [[Hintab]](arm)>>

<<struct [[Var]]>>

<<struct [[Reg]]>>
<<constant [[R]]>>

<<constant [[NRGN]](arm)>>
<<struct [[Rgn]]>>

extern	long	breakpc;
extern	long	nbreak;
extern	Case*	cases;
extern	Node	constnode;
extern	Node	fconstnode;
extern	long	continpc;
extern	long	curarg;
extern	long	cursafe;
extern	Prog*	firstp;
extern	Prog*	lastp;
extern	long	maxargsafe;
extern	int	mnstring;
extern	Multab	multab[20];
extern	int	hintabsize;
extern	Node*	nodrat;
extern	Node*	nodret;
extern	Node*	nodsafe;
extern	long	nrathole;
extern	long	nstring;
extern	Prog*	p;
extern	long	pc;
extern	Node	regnode;
extern	char	string[NSNAME];
extern	Sym*	symrathole;
extern	Node	znode;
extern	Prog	zprog;
extern	char	reg[NREG+NFREG];
extern	long	exregoffset;
extern	long	exfregoffset;
extern	int	suppress;

<<function [[LOAD]](arm)>>
<<function [[STORE]](arm)>>

<<function [[bset]](arm)>>

<<constant [[CLOAD]](arm)>>
<<constant [[CREF]](arm)>>
<<constant [[LOOP]](arm)>>

extern	Rgn	region[NRGN];
extern	Rgn*	rgp;
extern	int	nregion;
extern	int	nvar;

extern	Bits	externs;
extern	Bits	params;
extern	Bits	consts;
extern	Bits	addrs;

extern	long	regbits;
extern	long	exregbits;

extern	int	change;

extern	Reg*	firstr;
extern	Reg*	lastr;
extern	Reg	zreg;
extern	Reg*	freer;
extern	Var	var[NVAR];
extern	long*	idom;
extern	Reg**	rpo2r;
extern	long	maxnr;

extern	char*	anames[];
extern	Hintab	hintab[];

/*
 * sgen.c
 */
void	codgen(Node*, Node*);
void	gen(Node*);
void	noretval(int);
void	usedset(Node*, int);
void	xcom(Node*);
int	bcomplex(Node*, Node*);

/*
 * cgen.c
 */
void	cgen(Node*, Node*);
void	cgenrel(Node*, Node*, int);
void	reglcgen(Node*, Node*, Node*);
void	lcgen(Node*, Node*);
void	bcgen(Node*, int);
void	boolgen(Node*, int, Node*);
void	sugen(Node*, Node*, long);
void	layout(Node*, Node*, int, int, Node*);

/*
 * txt.c
 */
void	ginit(void);
void	gclean(void);
void	nextpc(void);
void	gargs(Node*, Node*, Node*);
void	garg1(Node*, Node*, Node*, int, Node**);
Node*	nodconst(long);
Node*	nod32const(vlong);
Node*	nodfconst(double);
void	nodreg(Node*, Node*, int);
void	regret(Node*, Node*);
int		tmpreg(void);
void	regalloc(Node*, Node*, Node*);
void	regfree(Node*);
void	regialloc(Node*, Node*, Node*);
void	regsalloc(Node*, Node*);
void	regaalloc1(Node*, Node*);
void	regaalloc(Node*, Node*);
void	regind(Node*, Node*);
void	gprep(Node*, Node*);
void	raddr(Node*, Prog*);
void	naddr(Node*, Adr*);
void	gmovm(Node*, Node*, int);
void	gmove(Node*, Node*);
void	gmover(Node*, Node*);
void	gins(int a, Node*, Node*);
void	gopcode(int, Node*, Node*, Node*);
int		samaddr(Node*, Node*);
void	gbranch(int);
void	patch(Prog*, long);
int		sconst(Node*);
int		sval(long);
void	gpseudo(int, Sym*, Node*);

/*
 * swt.c
 */
int		swcmp(const void*, const void*);
void	doswit(Node*);
void	swit1(C1*, int, long, Node*);
void	swit2(C1*, int, long, Node*, Node*);
void	casf(void);
void	bitload(Node*, Node*, Node*, Node*, Node*);
void	bitstore(Node*, Node*, Node*, Node*, Node*);
long	outstring(char*, long);
int		mulcon(Node*, Node*);
Multab*	mulcon0(long);
void	nullwarn(Node*, Node*);
void	gextern(Sym*, Node*, long, long);
void	outcode(void);
void	ieeedtod(Ieee*, double);

/*
 * list
 */
void	listinit(void);
int	Pconv(Fmt*);
int	Aconv(Fmt*);
int	Dconv(Fmt*);
int	Sconv(Fmt*);
int	Nconv(Fmt*);
int	Bconv(Fmt*);
int	Rconv(Fmt*);

/*
 * reg.c
 */
Reg*	rega(void);
int		rcmp(const void*, const void*);
void	regopt(Prog*);
void	addmove(Reg*, int, int, int);
Bits	mkvar(Adr*, int);
void	prop(Reg*, Bits, Bits);
void	loopit(Reg*, long);
void	synch(Reg*, Bits);
ulong	allreg(ulong, Rgn*);
void	paint1(Reg*, int);
ulong	paint2(Reg*, int);
void	paint3(Reg*, int, long, int);
void	addreg(Adr*, int);

/*
 * peep.c
 */
void	peep(void);
void	excise(Reg*);
Reg*	uniqp(Reg*);
Reg*	uniqs(Reg*);
int	regtyp(Adr*);
int	regzer(Adr*);
int	anyvar(Adr*);
int	subprop(Reg*);
int	copyprop(Reg*);
int	shiftprop(Reg*);
void	constprop(Adr*, Adr*, Reg*);
int	copy1(Adr*, Adr*, Reg*, int);
int	copyu(Prog*, Adr*, Adr*);

int	copyas(Adr*, Adr*);
int	copyau(Adr*, Adr*);
int	copyau1(Prog*, Adr*);
int	copysub(Adr*, Adr*, Adr*, int);
int	copysub1(Prog*, Adr*, Adr*, int);

long	RtoB(int);
long	FtoB(int);
int		BtoR(long);
int		BtoF(long);

void	predicate(void); 
int	isbranch(Prog *); 
int	predicable(Prog *p); 
int	modifiescpsr(Prog *p); 

#pragma	varargck	type	"A"	int
#pragma	varargck	type	"B"	Bits
#pragma	varargck	type	"D"	Adr*
#pragma	varargck	type	"N"	Adr*
#pragma	varargck	type	"R"	Adr*
#pragma	varargck	type	"P"	Prog*
#pragma	varargck	type	"S"	char*
@


\subsection*{[[5c/machcap.c]]}

%-------------------------------------------------------------

<<5c/machcap.c>>=
#include	"../cc/cc.h"

<<function [[machcap]](arm)>>
@


\subsection*{[[5c/globals2.c]]}


%-------------------------------------------------------------

<<5c/globals2.c>>=
#include "gc.h"

<<global [[breakpc]]>>
<<global [[nbreak]]>>
<<global [[cases]]>>
<<global [[constnode]]>>
<<global [[fconstnode]]>>
<<global [[continpc]]>>

<<global [[curarg]]>>
<<global [[cursafe]]>>

<<global [[firstp]]>>
<<global [[lastp]]>>

<<global [[maxargsafe]]>>

<<global [[mnstring]]>>
<<global [[multab]](arm)>>
<<global [[hintabsize]](arm)>>
<<global [[nodrat]]>>
<<global [[nodret]]>>
<<global [[nodsafe]]>>
<<global [[nrathole]]>>
<<global [[nstring]]>>
<<global [[p]]>>
<<global [[pc]]>>
<<global [[regnode]]>>
<<global [[string]]>>
<<global [[symrathole]]>>
<<global [[znode]]>>
<<global [[zprog]]>>
<<global [[reg]](arm)>>
<<global [[exregoffset]]>>
<<global [[exfregoffset]]>>
<<global [[suppress]]>>

<<global [[region]]>>
<<global [[rgp]]>>
<<global [[nregion]]>>

<<global [[externs]]>>
<<global [[params]]>>
<<global [[consts]]>>
<<global [[addrs]]>>

<<global [[regbits]]>>
<<global [[exregbits]]>>

<<global [[change]]>>

<<global [[firstr]]>>
<<global [[lastr]]>>
<<global [[zreg]]>>
<<global [[freer]]>>
<<global [[var]]>>
<<global [[nvar]]>>

<<global [[idom]]>>
<<global [[rpo2r]]>>
<<global [[maxnr]]>>
@


\subsection*{[[5c/list.c]]}

%-------------------------------------------------------------

<<5c/list.c>>=
#include "gc.h"

<<function [[listinit]](arm)>>

<<function [[Bconv]]>>

<<global [[extra]](arm)>>

<<function [[Pconv]](arm)>>

<<function [[Aconv]]>>

<<function [[Dconv]](arm)>>

<<function [[Rconv]](arm)>>

<<function [[Sconv]](arm)>>

<<function [[Nconv]](arm)>>
@


\subsection*{[[5c/txt.c]]}

%-------------------------------------------------------------

<<5c/txt.c>>=
#include "gc.h"

<<global [[resvreg]](arm)>>

<<function [[ginit]](arm)>>

<<function [[gclean]](arm)>>

<<function [[nextpc]]>>

<<function [[gargs]]>>

<<function [[garg1]](arm)>>

<<function [[nodconst]]>>

<<function [[nod32const]](arm)>>

<<function [[nodfconst]]>>

<<function [[nodreg]](arm)>>

<<function [[regret]](arm)>>

<<function [[tmpreg]](arm)>>

<<function [[regalloc]](arm)>>

<<function [[regialloc]]>>

<<function [[regfree]](arm)>>

<<function [[regsalloc]]>>

<<function [[regaalloc1]](arm)>>

<<function [[regaalloc]](arm)>>

<<function [[regind]]>>

<<function [[raddr]](arm)>>

<<function [[naddr]](arm)>>

<<function [[gmovm]](arm)>>

<<function [[gmove]](arm)>>

<<function [[gmover]](arm)>>

<<function [[gins]](arm)>>

<<function [[gopcode]](arm)>>

<<function [[samaddr]]>>

<<function [[gbranch]](arm)>>

<<function [[patch]]>>

<<function [[gpseudo]](arm)>>

<<function [[sconst]](arm)>>

<<function [[sval]](arm)>>

<<function [[exreg]](arm)>>

<<global [[ewidth]]>>

<<global [[ncast]]>>
@


\subsection*{[[5c/peep.c]]}


%-------------------------------------------------------------

<<5c/peep.c>>=
#include "gc.h"

int xtramodes(Reg*, Adr*);

<<function [[peep]](arm)>>

<<function [[excise]](arm)>>

<<function [[uniqp]]>>

<<function [[uniqs]]>>

<<function [[regtyp]](arm)>>

<<function [[subprop]](arm)>>

<<function [[copyprop]]>>

<<function [[copy1]]>>

<<function [[constprop]](arm)>>

<<function [[FAIL]](arm)>>
<<function [[shiftprop]](arm)>>

<<function [[findpre]](arm)>>

<<function [[findinc]](arm)>>

<<function [[nochange]](arm)>>

<<function [[findu1]](arm)>>

<<function [[finduse]](arm)>>

<<function [[xtramodes]](arm)>>

<<function [[copyu]](arm)>>

<<function [[a2type]](arm)>>

<<function [[copyas]](arm)>>

<<function [[copyau]](arm)>>

<<function [[copyau1]](arm)>>

<<function [[copysub]](arm)>>

<<function [[copysub1]](arm)>>

<<global [[predinfo]](arm)>>

<<struct [[Joininfo]]>>

<<enum [[_anon_]](arm)>>
    
<<enum [[_anon_ (5c/peep.c)]](arm)>>

<<function [[isbranch]](arm)>>

<<function [[predicable]](arm)>>

<<function [[modifiescpsr]](arm)>>

<<function [[joinsplit]](arm)>>

<<function [[successor]](arm)>>

<<function [[applypred]](arm)>>

<<function [[predicate]](arm)>>
@


\subsection*{[[5c/sgen.c]]}

%-------------------------------------------------------------

<<5c/sgen.c>>=
#include "gc.h"

<<function [[noretval]](arm)>>

<<function [[xcom]](arm)>>
@


\subsection*{[[5c/swt.c]]}

%-------------------------------------------------------------

<<5c/swt.c>>=
#include "gc.h"

<<function [[swit1]](arm)>>

<<function [[swit2]](arm)>>

<<function [[bitload]](arm)>>

<<function [[bitstore]](arm)>>

<<function [[outstring]](arm)>>

<<function [[mulcon]](arm)>>

<<function [[gextern]](arm)>>

void	zname(Biobuf*, Sym*, int);
char*	zaddr(char*, Adr*, int);
void	zwrite(Biobuf*, Prog*, int, int);
void	outhist(Biobuf*);

<<function [[zwrite]](arm)>>

<<struct [[Htab]]>>

<<function [[outcode]](arm)>>

<<function [[outhist]](arm)>>

<<function [[zname]](arm)>>

<<function [[zaddr]](arm)>>

<<function [[align]](arm)>>

<<function [[maxround]]>>
@


\subsection*{[[5c/mul.c]]}


%-------------------------------------------------------------

<<5c/mul.c>>=
#include "gc.h"

/*
 * code sequences for multiply by constant.
 * [a-l][0-3]
 *	lsl	$(A-'a'),r0,r1
 * [+][0-7]
 *	add	r0,r1,r2
 * [-][0-7]
 *	sub	r0,r1,r2
 */

<<global [[maxmulops]](arm)>>
<<global [[multabp]](arm)>>
<<global [[mulval]](arm)>>
<<global [[mulcp]](arm)>>
<<global [[valmax]](arm)>>
<<global [[shmax]](arm)>>

static int	docode(char *hp, char *cp, int r0, int r1);
static int	gen1(int len);
static int	gen2(int len, long r1);
static int	gen3(int len, long r0, long r1, int flag);
<<enum [[_anon_ (5c/mul.c)]](arm)>>

<<function [[mulcon0]](arm)>>

<<function [[docode]](arm)>>

<<function [[gen1]](arm)>>

<<function [[gen2]](arm)>>

<<function [[gen3]](arm)>>

<<global [[hintab]](arm)>>
<<global hintabsize (5c/mul.c)(arm)>>
@
% $


\subsection*{[[5c/reg.c]]}


%-------------------------------------------------------------

<<5c/reg.c>>=
#include "gc.h"

void	addsplits(void);

<<function [[rega]]>>

<<function [[rcmp]]>>

<<function [[regopt]](arm)>>

<<function [[addsplits]](arm)>>

<<function [[addmove]](arm)>>

<<function [[mkvar]](arm)>>

<<function [[prop]](arm)>>

<<function [[postorder]]>>

<<function [[rpolca]]>>

<<function [[doms]]>>

<<function [[loophead]]>>

<<function [[loopmark]]>>

<<function [[loopit]]>>

<<function [[synch]]>>

<<function [[allreg]](arm)>>

<<function [[paint1]](arm)>>

<<function [[paint2]](arm)>>

<<function [[paint3]]>>

<<function [[addreg]](arm)>>

<<function [[RtoB]](arm)>>

<<function [[BtoR]](arm)>>

<<function [[FtoB]](arm)>>

<<function [[BtoF]](arm)>>
@


\subsection*{[[5c/cgen.c]]}



%-------------------------------------------------------------

<<5c/cgen.c>>=
#include "gc.h"

<<function [[cgen]](arm)>>

<<function [[cgenrel]](arm)>>

<<function [[reglcgen]](arm)>>

<<function [[reglpcgen]](arm)>>

<<function [[lcgen]](arm)>>

<<function [[bcgen]]>>

<<function [[boolgen]](arm)>>

<<function [[sugen]](arm)>>
@



\ifallcode
\section{x86}

%REGARG from 8.out.h = -1 => no register for first argument,
% everything in the stack. AX is used for return though


<<[[tcomo()]] in ONAME case, if extern register, if x86>>=
if(thechar == '8')
    n->op = OEXREG;
@
<<after parsing nodes>>=
OEXREG,
@
% for regnode


<<misc nodes>>=
OINDEX, // x86 only
OREGPAIR, // x86 only, for 64 bits stuff
@

<<[[Node]] code generation fields>>=
char	scale; // x86 only
@


<<struct [[Prog]](x86)>>=
struct	Prog
{
    // enum<opcode>, from 8.out.h
    short	as;

    Adr	from;
    Adr	to;

    long	lineno;

    // Extra
    <<[[Prog]] extra fields(x86)>>
};
@

<<[[Prog]] extra fields(x86)>>=
Prog*	link;
@

<<struct [[Adr]](x86)>>=
struct	Adr
{
    long	offset;
    double	dval;
    char	sval[NSNAME];
    Sym*	sym;

    uchar	type;
    uchar	index;
    uchar	etype;
    uchar	scale;	/* doubles as width in DATA op */
};
@

% 8c/sgen.c
<<function [[noretval]](x86)>>=
void
noretval(int n)
{

    if(n & 1) {
        gins(ANOP, Z, Z);
        p->to.type = REGRET;
    }
    if(n & 2) {
        gins(ANOP, Z, Z);
        p->to.type = FREGRET;
    }
    if((n&3) == 3)
    if(thisfntype && thisfntype->link && typefd[thisfntype->link->etype])
        gins(AFLDZ, Z, Z);
}
@


<<global [[typeil]]>>=
char	typeil[NTYPE];
@
<<global [[typeilinit]]>>=
int	typeilinit[] =
{
    TINT, TUINT, TLONG, TULONG, -1,
};
@
<<[[tinit()]] initialise typexxx type sets>>=
for(ip=typeilinit; *ip>=0; ip++) {
    urk("typeil", nelem(typeil), *ip);
    typeil[*ip] = 1;
}
@


% 8c/cgen.c
% was in comment before the func?? /* ,x/^(print|prtree)\(/i/\/\/ */
<<function [[cgen]](x86)>>=
void
cgen(Node *n, Node *nn)
{
    Node *l, *r, *t;
    Prog *p1;
    Node nod, nod1, nod2, nod3, nod4;
    int o, hardleft;
    long v, curs;
    vlong c;

    if(debug['g']) {
        prtree(nn, "cgen lhs");
        prtree(n, "cgen");
    }

    if(n == Z || n->type == T)
        return;
    if(typesuv[n->type->etype]) {
        sugen(n, nn, n->type->width);
        return;
    }
    l = n->left;
    r = n->right;
    o = n->op;
// Go's version does the following, but it's the wrong place: doesn't allow assignment
//	if(o == OEXREG || nn != Z && nn->op == OEXREG) {
//		gmove(n, nn);
//		return;
//	}

    if(n->addable >= INDEXED) {
        if(nn == Z) {
            switch(o) {
            default:
                nullwarn(Z, Z);
                break;
            case OINDEX:
                nullwarn(l, r);
                break;
            }
            return;
        }
        gmove(n, nn);
        return;
    }
    curs = cursafe;

  if(l->complex >= FNX)
   if(r != Z && r->complex >= FNX)
    switch(o) {
    default:
        if(cond(o) && typesuv[l->type->etype])
            break;

        regret(&nod, r);
        cgen(r, &nod);

        regsalloc(&nod1, r);
        gmove(&nod, &nod1);

        regfree(&nod);
        nod = *n;
        nod.right = &nod1;

        cgen(&nod, nn);
        return;

    case OFUNC:
    case OCOMMA:
    case OANDAND:
    case OOROR:
    case OCOND:
    case ODOT:
        break;
    }

    hardleft = l->addable < INDEXED || l->complex >= FNX;
    switch(o) {
    default:
        diag(n, "unknown op in cgen: %O", o);
        break;

    case ONEG:
    case OCOM:
        if(nn == Z) {
            nullwarn(l, Z);
            break;
        }
        regalloc(&nod, l, nn);
        cgen(l, &nod);
        gopcode(o, n->type, Z, &nod);
        gmove(&nod, nn);
        regfree(&nod);
        break;

    case OAS:
        if(typefd[n->type->etype]) {
            cgen(r, &fregnode0);
            if(nn != Z)
                gins(AFMOVD, &fregnode0, &fregnode0);
            if(l->addable < INDEXED) {
                reglcgen(&nod, l, Z);
                gmove(&fregnode0, &nod);
                regfree(&nod);
            } else
                gmove(&fregnode0, l);
            if(nn != Z)
                gmove(&fregnode0, nn);
            return;
        }
        if(l->op == OBIT)
            goto bitas;
        if(!hardleft) {
            if(nn != Z || r->addable < INDEXED) {
                if(r->complex >= FNX && nn == Z)
                    regret(&nod, r);
                else
                    regalloc(&nod, r, nn);
                cgen(r, &nod);
                gmove(&nod, l);
                if(nn != Z)
                    gmove(&nod, nn);
                regfree(&nod);
            } else
                gmove(r, l);
            break;
        }
        if(l->complex >= r->complex) {
            if(l->op == OINDEX && r->op == OCONST) {
                gmove(r, l);
                break;
            }
            reglcgen(&nod1, l, Z);
            if(r->addable >= INDEXED) {
                gmove(r, &nod1);
                if(nn != Z)
                    gmove(r, nn);
                regfree(&nod1);
                break;
            }
            regalloc(&nod, r, nn);
            cgen(r, &nod);
        } else {
            regalloc(&nod, r, nn);
            cgen(r, &nod);
            reglcgen(&nod1, l, Z);
        }
        gmove(&nod, &nod1);
        regfree(&nod);
        regfree(&nod1);
        break;

    bitas:
        n = l->left;
        regalloc(&nod, r, nn);
        if(l->complex >= r->complex) {
            reglcgen(&nod1, n, Z);
            cgen(r, &nod);
        } else {
            cgen(r, &nod);
            reglcgen(&nod1, n, Z);
        }
        regalloc(&nod2, n, Z);
        gmove(&nod1, &nod2);
        bitstore(l, &nod, &nod1, &nod2, nn);
        break;

    case OBIT:
        if(nn == Z) {
            nullwarn(l, Z);
            break;
        }
        bitload(n, &nod, Z, Z, nn);
        gmove(&nod, nn);
        regfree(&nod);
        break;

    case OLSHR:
    case OASHL:
    case OASHR:
        if(nn == Z) {
            nullwarn(l, r);
            break;
        }
        if(r->op == OCONST) {
            if(r->vconst == 0) {
                cgen(l, nn);
                break;
            }
            regalloc(&nod, l, nn);
            cgen(l, &nod);
            if(o == OASHL && r->vconst == 1)
                gopcode(OADD, n->type, &nod, &nod);
            else
                gopcode(o, n->type, r, &nod);
            gmove(&nod, nn);
            regfree(&nod);
            break;
        }

        /*
         * get nod to be D_CX
         */
        if(nodreg(&nod, nn, D_CX)) {
            regsalloc(&nod1, n);
            gmove(&nod, &nod1);
            cgen(n, &nod);		/* probably a bug */
            gmove(&nod, nn);
            gmove(&nod1, &nod);
            break;
        }
        reg[D_CX]++;
        if(nn->op == OREGISTER && nn->reg == D_CX)
            regalloc(&nod1, l, Z);
        else
            regalloc(&nod1, l, nn);
        if(r->complex >= l->complex) {
            cgen(r, &nod);
            cgen(l, &nod1);
        } else {
            cgen(l, &nod1);
            cgen(r, &nod);
        }
        gopcode(o, n->type, &nod, &nod1);
        gmove(&nod1, nn);
        regfree(&nod);
        regfree(&nod1);
        break;

    case OADD:
    case OSUB:
    case OOR:
    case OXOR:
    case OAND:
        if(nn == Z) {
            nullwarn(l, r);
            break;
        }
        if(typefd[n->type->etype])
            goto fop;
        if(r->op == OCONST) {
            if(r->vconst == 0 && o != OAND) {
                cgen(l, nn);
                break;
            }
        }
        if(n->op == OADD && l->op == OASHL && l->right->op == OCONST
        && (r->op != OCONST || r->vconst < -128 || r->vconst > 127)) {
            c = l->right->vconst;
            if(c > 0 && c <= 3 && nareg(1) >= 4) {
                if(l->left->complex >= r->complex) {
                    regalloc(&nod, l->left, nn);
                    cgen(l->left, &nod);
                    if(r->addable < INDEXED) {
                        regalloc(&nod1, r, Z);
                        cgen(r, &nod1);
                        genmuladd(&nod, &nod, 1 << c, &nod1);
                        regfree(&nod1);
                    }
                    else
                        genmuladd(&nod, &nod, 1 << c, r);
                }
                else {
                    regalloc(&nod, r, nn);
                    cgen(r, &nod);
                    regalloc(&nod1, l->left, Z);
                    cgen(l->left, &nod1);
                    genmuladd(&nod, &nod1, 1 << c, &nod);
                    regfree(&nod1);
                }
                gmove(&nod, nn);
                regfree(&nod);
                break;
            }
        }
        if(r->addable >= INDEXED) {
            regalloc(&nod, l, nn);
            cgen(l, &nod);
            gopcode(o, n->type, r, &nod);
            gmove(&nod, nn);
            regfree(&nod);
            break;
        }
        if(l->complex >= r->complex) {
            regalloc(&nod, l, nn);
            cgen(l, &nod);
            regalloc(&nod1, r, Z);
            cgen(r, &nod1);
            gopcode(o, n->type, &nod1, &nod);
        } else {
            regalloc(&nod1, r, nn);
            cgen(r, &nod1);
            regalloc(&nod, l, Z);
            cgen(l, &nod);
            gopcode(o, n->type, &nod1, &nod);
        }
        gmove(&nod, nn);
        regfree(&nod);
        regfree(&nod1);
        break;

    case OLMOD:
    case OMOD:
    case OLMUL:
    case OLDIV:
    case OMUL:
    case ODIV:
        if(nn == Z) {
            nullwarn(l, r);
            break;
        }
        if(typefd[n->type->etype])
            goto fop;
        if(r->op == OCONST) {
            SET(v);
            switch(o) {
            case ODIV:
            case OMOD:
                c = r->vconst;
                if(c < 0)
                    c = -c;
                v = log2(c);
                if(v < 0)
                    break;
                /* fall thru */
            case OMUL:
            case OLMUL:
                regalloc(&nod, l, nn);
                cgen(l, &nod);
                switch(o) {
                case OMUL:
                case OLMUL:
                    mulgen(n->type, r, &nod);
                    break;
                case ODIV:
                    sdiv2(r->vconst, v, l, &nod);
                    break;
                case OMOD:
                    smod2(r->vconst, v, l, &nod);
                    break;
                }
                gmove(&nod, nn);
                regfree(&nod);
                goto done;
            case OLDIV:
                c = r->vconst;
                if((c & 0x80000000) == 0)
                    break;
                regalloc(&nod1, l, Z);
                cgen(l, &nod1);
                regalloc(&nod, l, nn);
                zeroregm(&nod);
                gins(ACMPL, &nod1, nodconst(c));
                gins(ASBBL, nodconst(-1), &nod);
                regfree(&nod1);
                gmove(&nod, nn);
                regfree(&nod);
                goto done;
            }
        }

        if(o == OMUL) {
            if(l->addable >= INDEXED) {
                t = l;
                l = r;
                r = t;
                goto imula;
            }
            else if(r->addable >= INDEXED) {
            imula:
/* should favour AX */
                regalloc(&nod, l, nn);
                cgen(l, &nod);
                gopcode(OMUL, n->type, r, &nod);
            }
            else {
/* should favour AX */
                regalloc(&nod, l, nn);
                cgen(l, &nod);
                regalloc(&nod1, r, Z);
                cgen(r, &nod1);
                gopcode(OMUL, n->type, &nod1, &nod);
                regfree(&nod1);
            }
            gmove(&nod, nn);
            regfree(&nod);
            goto done;
        }

        /*
         * get nod to be D_AX
         * get nod1 to be D_DX
         */
        if(nodreg(&nod, nn, D_AX)) {
            regsalloc(&nod2, n);
            gmove(&nod, &nod2);
            v = reg[D_AX];
            reg[D_AX] = 0;

            if(isreg(l, D_AX)) {
                nod3 = *n;
                nod3.left = &nod2;
                cgen(&nod3, nn);
            } else
            if(isreg(r, D_AX)) {
                nod3 = *n;
                nod3.right = &nod2;
                cgen(&nod3, nn);
            } else
                cgen(n, nn);

            gmove(&nod2, &nod);
            reg[D_AX] = v;
            break;
        }
        if(nodreg(&nod1, nn, D_DX)) {
            regsalloc(&nod2, n);
            gmove(&nod1, &nod2);
            v = reg[D_DX];
            reg[D_DX] = 0;

            if(isreg(l, D_DX)) {
                nod3 = *n;
                nod3.left = &nod2;
                cgen(&nod3, nn);
            } else
            if(isreg(r, D_DX)) {
                nod3 = *n;
                nod3.right = &nod2;
                cgen(&nod3, nn);
            } else
                cgen(n, nn);

            gmove(&nod2, &nod1);
            reg[D_DX] = v;
            break;
        }
        reg[D_AX]++;

        if(r->op == OCONST) {
            switch(o) {
            case ODIV:
                reg[D_DX]++;
                if(l->addable < INDEXED) {
                    regalloc(&nod2, l, Z);
                    cgen(l, &nod2);
                    l = &nod2;
                }
                sdivgen(l, r, &nod, &nod1);
                gmove(&nod1, nn);
                if(l == &nod2)
                    regfree(l);
                goto freeaxdx;
            case OLDIV:
                reg[D_DX]++;
                if(l->addable < INDEXED) {
                    regalloc(&nod2, l, Z);
                    cgen(l, &nod2);
                    l = &nod2;
                }
                udivgen(l, r, &nod, &nod1);
                gmove(&nod1, nn);
                if(l == &nod2)
                    regfree(l);
                goto freeaxdx;
            }
        }

        if(l->complex >= r->complex) {
            cgen(l, &nod);
            reg[D_DX]++;
            if(o == ODIV || o == OMOD)
                gins(ACDQ, Z, Z);
            if(o == OLDIV || o == OLMOD)
                zeroregm(&nod1);
            if(r->addable < INDEXED || r->op == OCONST) {
                regsalloc(&nod3, r);
                cgen(r, &nod3);
                gopcode(o, n->type, &nod3, Z);
            } else
                gopcode(o, n->type, r, Z);
        } else {
            regsalloc(&nod3, r);
            cgen(r, &nod3);
            cgen(l, &nod);
            reg[D_DX]++;
            if(o == ODIV || o == OMOD)
                gins(ACDQ, Z, Z);
            if(o == OLDIV || o == OLMOD)
                zeroregm(&nod1);
            gopcode(o, n->type, &nod3, Z);
        }
        if(o == OMOD || o == OLMOD)
            gmove(&nod1, nn);
        else
            gmove(&nod, nn);
    freeaxdx:
        regfree(&nod);
        regfree(&nod1);
        break;

    case OASLSHR:
    case OASASHL:
    case OASASHR:
        if(r->op == OCONST)
            goto asand;
        if(l->op == OBIT)
            goto asbitop;
        if(typefd[n->type->etype])
            goto asfop;

        /*
         * get nod to be D_CX
         */
        if(nodreg(&nod, nn, D_CX)) {
            regsalloc(&nod1, n);
            gmove(&nod, &nod1);
            cgen(n, &nod);
            if(nn != Z)
                gmove(&nod, nn);
            gmove(&nod1, &nod);
            break;
        }
        reg[D_CX]++;

        if(r->complex >= l->complex) {
            cgen(r, &nod);
            if(hardleft)
                reglcgen(&nod1, l, Z);
            else
                nod1 = *l;
        } else {
            if(hardleft)
                reglcgen(&nod1, l, Z);
            else
                nod1 = *l;
            cgen(r, &nod);
        }

        gopcode(o, l->type, &nod, &nod1);
        regfree(&nod);
        if(nn != Z)
            gmove(&nod1, nn);
        if(hardleft)
            regfree(&nod1);
        break;

    case OASAND:
    case OASADD:
    case OASSUB:
    case OASXOR:
    case OASOR:
    asand:
        if(l->op == OBIT)
            goto asbitop;
        if(typefd[n->type->etype]||typefd[r->type->etype])
            goto asfop;
        if(l->complex >= r->complex) {
            if(hardleft)
                reglcgen(&nod, l, Z);
            else
                nod = *l;
            if(r->op != OCONST) {
                regalloc(&nod1, r, nn);
                cgen(r, &nod1);
                gopcode(o, l->type, &nod1, &nod);
                regfree(&nod1);
            } else
                gopcode(o, l->type, r, &nod);
        } else {
            regalloc(&nod1, r, nn);
            cgen(r, &nod1);
            if(hardleft)
                reglcgen(&nod, l, Z);
            else
                nod = *l;
            gopcode(o, l->type, &nod1, &nod);
            regfree(&nod1);
        }
        if(nn != Z)
            gmove(&nod, nn);
        if(hardleft)
            regfree(&nod);
        break;

    case OASLMUL:
    case OASLDIV:
    case OASLMOD:
    case OASMUL:
    case OASDIV:
    case OASMOD:
        if(l->op == OBIT)
            goto asbitop;
        if(typefd[n->type->etype]||typefd[r->type->etype])
            goto asfop;
        if(r->op == OCONST) {
            SET(v);
            switch(o) {
            case OASDIV:
            case OASMOD:
                c = r->vconst;
                if(c < 0)
                    c = -c;
                v = log2(c);
                if(v < 0)
                    break;
                /* fall thru */
            case OASMUL:
            case OASLMUL:
                if(hardleft)
                    reglcgen(&nod2, l, Z);
                else
                    nod2 = *l;
                regalloc(&nod, l, nn);
                cgen(&nod2, &nod);
                switch(o) {
                case OASMUL:
                case OASLMUL:
                    mulgen(n->type, r, &nod);
                    break;
                case OASDIV:
                    sdiv2(r->vconst, v, l, &nod);
                    break;
                case OASMOD:
                    smod2(r->vconst, v, l, &nod);
                    break;
                }
            havev:
                gmove(&nod, &nod2);
                if(nn != Z)
                    gmove(&nod, nn);
                if(hardleft)
                    regfree(&nod2);
                regfree(&nod);
                goto done;
            case OASLDIV:
                c = r->vconst;
                if((c & 0x80000000) == 0)
                    break;
                if(hardleft)
                    reglcgen(&nod2, l, Z);
                else
                    nod2 = *l;
                regalloc(&nod1, l, nn);
                cgen(&nod2, &nod1);
                regalloc(&nod, l, nn);
                zeroregm(&nod);
                gins(ACMPL, &nod1, nodconst(c));
                gins(ASBBL, nodconst(-1), &nod);
                regfree(&nod1);
                goto havev;
            }
        }

        if(o == OASMUL) {
/* should favour AX */
            regalloc(&nod, l, nn);
            if(r->complex >= FNX) {
                regalloc(&nod1, r, Z);
                cgen(r, &nod1);
                r = &nod1;
            }
            if(hardleft)
                reglcgen(&nod2, l, Z);
            else
                nod2 = *l;
            cgen(&nod2, &nod);
            if(r->addable < INDEXED) {
                if(r->complex < FNX) {
                    regalloc(&nod1, r, Z);
                    cgen(r, &nod1);
                }
                gopcode(OASMUL, n->type, &nod1, &nod);
                regfree(&nod1);
            }
            else
                gopcode(OASMUL, n->type, r, &nod);
            if(r == &nod1)
                regfree(r);
            gmove(&nod, &nod2);
            if(nn != Z)
                gmove(&nod, nn);
            regfree(&nod);
            if(hardleft)
                regfree(&nod2);
            goto done;
        }

        /*
         * get nod to be D_AX
         * get nod1 to be D_DX
         */
        if(nodreg(&nod, nn, D_AX)) {
            regsalloc(&nod2, n);
            gmove(&nod, &nod2);
            v = reg[D_AX];
            reg[D_AX] = 0;

            if(isreg(l, D_AX)) {
                nod3 = *n;
                nod3.left = &nod2;
                cgen(&nod3, nn);
            } else
            if(isreg(r, D_AX)) {
                nod3 = *n;
                nod3.right = &nod2;
                cgen(&nod3, nn);
            } else
                cgen(n, nn);

            gmove(&nod2, &nod);
            reg[D_AX] = v;
            break;
        }
        if(nodreg(&nod1, nn, D_DX)) {
            regsalloc(&nod2, n);
            gmove(&nod1, &nod2);
            v = reg[D_DX];
            reg[D_DX] = 0;

            if(isreg(l, D_DX)) {
                nod3 = *n;
                nod3.left = &nod2;
                cgen(&nod3, nn);
            } else
            if(isreg(r, D_DX)) {
                nod3 = *n;
                nod3.right = &nod2;
                cgen(&nod3, nn);
            } else
                cgen(n, nn);

            gmove(&nod2, &nod1);
            reg[D_DX] = v;
            break;
        }
        reg[D_AX]++;
        reg[D_DX]++;

        if(l->complex >= r->complex) {
            if(hardleft)
                reglcgen(&nod2, l, Z);
            else
                nod2 = *l;
            cgen(&nod2, &nod);
            if(r->op == OCONST) {
                switch(o) {
                case OASDIV:
                    sdivgen(&nod2, r, &nod, &nod1);
                    goto divdone;
                case OASLDIV:
                    udivgen(&nod2, r, &nod, &nod1);
                divdone:
                    gmove(&nod1, &nod2);
                    if(nn != Z)
                        gmove(&nod1, nn);
                    goto freelxaxdx;
                }
            }
            if(o == OASDIV || o == OASMOD)
                gins(ACDQ, Z, Z);
            if(o == OASLDIV || o == OASLMOD)
                zeroregm(&nod1);
            if(r->addable < INDEXED || r->op == OCONST ||
               !typeil[r->type->etype]) {
                regalloc(&nod3, r, Z);
                cgen(r, &nod3);
                gopcode(o, l->type, &nod3, Z);
                regfree(&nod3);
            } else
                gopcode(o, n->type, r, Z);
        } else {
            regalloc(&nod3, r, Z);
            cgen(r, &nod3);
            if(hardleft)
                reglcgen(&nod2, l, Z);
            else
                nod2 = *l;
            cgen(&nod2, &nod);
            if(o == OASDIV || o == OASMOD)
                gins(ACDQ, Z, Z);
            if(o == OASLDIV || o == OASLMOD)
                zeroregm(&nod1);
            gopcode(o, l->type, &nod3, Z);
            regfree(&nod3);
        }
        if(o == OASMOD || o == OASLMOD) {
            gmove(&nod1, &nod2);
            if(nn != Z)
                gmove(&nod1, nn);
        } else {
            gmove(&nod, &nod2);
            if(nn != Z)
                gmove(&nod, nn);
        }
    freelxaxdx:
        if(hardleft)
            regfree(&nod2);
        regfree(&nod);
        regfree(&nod1);
        break;

    fop:
        if(l->complex >= r->complex) {
            cgen(l, &fregnode0);
            if(r->addable < INDEXED) {
                cgen(r, &fregnode0);
                fgopcode(o, &fregnode0, &fregnode1, 1, 0);
            } else
                fgopcode(o, r, &fregnode0, 0, 0);
        } else {
            cgen(r, &fregnode0);
            if(l->addable < INDEXED) {
                cgen(l, &fregnode0);
                fgopcode(o, &fregnode0, &fregnode1, 1, 1);
            } else
                fgopcode(o, l, &fregnode0, 0, 1);
        }
        gmove(&fregnode0, nn);
        break;

    asfop:
        if(l->complex >= r->complex) {
            if(hardleft)
                reglcgen(&nod, l, Z);
            else
                nod = *l;
            cgen(r, &fregnode0);
        } else {
            cgen(r, &fregnode0);
            if(hardleft)
                reglcgen(&nod, l, Z);
            else
                nod = *l;
        }
        if(!typefd[l->type->etype]) {
            gmove(&nod, &fregnode0);
            fgopcode(o, &fregnode0, &fregnode1, 1, 1);
        } else
            fgopcode(o, &nod, &fregnode0, 0, 1);
        if(nn != Z)
            gins(AFMOVD, &fregnode0, &fregnode0);
        gmove(&fregnode0, &nod);
        if(nn != Z)
            gmove(&fregnode0, nn);
        if(hardleft)
            regfree(&nod);
        break;

    asbitop:
        regalloc(&nod4, n, nn);
        if(l->complex >= r->complex) {
            bitload(l, &nod, &nod1, &nod2, &nod4);
            regalloc(&nod3, r, Z);
            cgen(r, &nod3);
        } else {
            regalloc(&nod3, r, Z);
            cgen(r, &nod3);
            bitload(l, &nod, &nod1, &nod2, &nod4);
        }
        gmove(&nod, &nod4);

        if(typefd[nod3.type->etype])
            fgopcode(o, &fregnode0, &fregnode1, 1, 1);
        else {
            Node onod;

            /* incredible grot ... */
            onod = nod3;
            onod.op = o;
            onod.complex = 2;
            onod.addable = 0;
            onod.type = tfield;
            onod.left = &nod4;
            onod.right = &nod3;
            cgen(&onod, Z);
        }
        regfree(&nod3);
        gmove(&nod4, &nod);
        regfree(&nod4);
        bitstore(l, &nod, &nod1, &nod2, nn);
        break;

    case OADDR:
        if(nn == Z) {
            nullwarn(l, Z);
            break;
        }
        lcgen(l, nn);
        break;

    case OFUNC:
        l = uncomma(l);
        if(l->complex >= FNX) {
            if(l->op != OIND)
                diag(n, "bad function call");

            regret(&nod, l->left);
            cgen(l->left, &nod);
            regsalloc(&nod1, l->left);
            gmove(&nod, &nod1);
            regfree(&nod);

            nod = *n;
            nod.left = &nod2;
            nod2 = *l;
            nod2.left = &nod1;
            nod2.complex = 1;
            cgen(&nod, nn);

            return;
        }
        gargs(r, &nod, &nod1);
        if(l->addable < INDEXED) {
            reglcgen(&nod, l, nn);
            nod.op = OREGISTER;
            gopcode(OFUNC, n->type, Z, &nod);
            regfree(&nod);
        } else
            gopcode(OFUNC, n->type, Z, l);
        if(REGARG>=0 && reg[REGARG])
            reg[REGARG]--;
        if(nn != Z) {
            regret(&nod, n);
            gmove(&nod, nn);
            regfree(&nod);
        } else
        if(typefd[n->type->etype])
            gins(AFMOVDP, &fregnode0, &fregnode0);
        break;

    case OIND:
        if(nn == Z) {
            nullwarn(l, Z);
            break;
        }
        regialloc(&nod, n, nn);
        r = l;
        while(r->op == OADD)
            r = r->right;
        if(sconst(r)) {
            v = r->vconst;
            r->vconst = 0;
            cgen(l, &nod);
            nod.xoffset += v;
            r->vconst = v;
        } else
            cgen(l, &nod);
        regind(&nod, n);
        gmove(&nod, nn);
        regfree(&nod);
        break;

    case OEQ:
    case ONE:
    case OLE:
    case OLT:
    case OGE:
    case OGT:
    case OLO:
    case OLS:
    case OHI:
    case OHS:
        if(nn == Z) {
            nullwarn(l, r);
            break;
        }
        boolgen(n, 1, nn);
        break;

    case OANDAND:
    case OOROR:
        boolgen(n, 1, nn);
        if(nn == Z)
            patch(p, pc);
        break;

    case ONOT:
        if(nn == Z) {
            nullwarn(l, Z);
            break;
        }
        boolgen(n, 1, nn);
        break;

    case OCOMMA:
        cgen(l, Z);
        cgen(r, nn);
        break;

    case OCAST:
        if(nn == Z) {
            nullwarn(l, Z);
            break;
        }
        /*
         * convert from types l->n->nn
         */
        if(nocast(l->type, n->type) && nocast(n->type, nn->type)) {
            /* both null, gen l->nn */
            cgen(l, nn);
            break;
        }
        if(typev[l->type->etype]) {
            cgen64(n, nn);
            break;
        }
        regalloc(&nod, l, nn);
        cgen(l, &nod);
        regalloc(&nod1, n, &nod);
        gmove(&nod, &nod1);
        gmove(&nod1, nn);
        regfree(&nod1);
        regfree(&nod);
        break;

    case ODOT:
        sugen(l, nodrat, l->type->width);
        if(nn == Z)
            break;
        warn(n, "non-interruptable temporary");
        nod = *nodrat;
        if(!r || r->op != OCONST) {
            diag(n, "DOT and no offset");
            break;
        }
        nod.xoffset += (long)r->vconst;
        nod.type = n->type;
        cgen(&nod, nn);
        break;

    case OCOND:
        bcgen(l, 1);
        p1 = p;
        cgen(r->left, nn);
        gbranch(OGOTO);
        patch(p1, pc);
        p1 = p;
        cgen(r->right, nn);
        patch(p1, pc);
        break;

    case OPOSTINC:
    case OPOSTDEC:
        v = 1;
        if(l->type->etype == TIND)
            v = l->type->link->width;
        if(o == OPOSTDEC)
            v = -v;
        if(l->op == OBIT)
            goto bitinc;
        if(nn == Z)
            goto pre;

        if(hardleft)
            reglcgen(&nod, l, Z);
        else
            nod = *l;

        if(typefd[n->type->etype])
            goto fltinc;
        gmove(&nod, nn);
        gopcode(OADD, n->type, nodconst(v), &nod);
        if(hardleft)
            regfree(&nod);
        break;

    case OPREINC:
    case OPREDEC:
        v = 1;
        if(l->type->etype == TIND)
            v = l->type->link->width;
        if(o == OPREDEC)
            v = -v;
        if(l->op == OBIT)
            goto bitinc;

    pre:
        if(hardleft)
            reglcgen(&nod, l, Z);
        else
            nod = *l;
        if(typefd[n->type->etype])
            goto fltinc;
        gopcode(OADD, n->type, nodconst(v), &nod);
        if(nn != Z)
            gmove(&nod, nn);
        if(hardleft)
            regfree(&nod);
        break;

    fltinc:
        gmove(&nod, &fregnode0);
        if(nn != Z && (o == OPOSTINC || o == OPOSTDEC))
            gins(AFMOVD, &fregnode0, &fregnode0);
        gins(AFLD1, Z, Z);
        if(v < 0)
            fgopcode(OSUB, &fregnode0, &fregnode1, 1, 0);
        else
            fgopcode(OADD, &fregnode0, &fregnode1, 1, 0);
        if(nn != Z && (o == OPREINC || o == OPREDEC))
            gins(AFMOVD, &fregnode0, &fregnode0);
        gmove(&fregnode0, &nod);
        if(hardleft)
            regfree(&nod);
        break;

    bitinc:
        if(nn != Z && (o == OPOSTINC || o == OPOSTDEC)) {
            bitload(l, &nod, &nod1, &nod2, Z);
            gmove(&nod, nn);
            gopcode(OADD, tfield, nodconst(v), &nod);
            bitstore(l, &nod, &nod1, &nod2, Z);
            break;
        }
        bitload(l, &nod, &nod1, &nod2, nn);
        gopcode(OADD, tfield, nodconst(v), &nod);
        bitstore(l, &nod, &nod1, &nod2, nn);
        break;
    }
done:
    cursafe = curs;
}
@

<<function [[reglcgen]](x86)>>=
void
reglcgen(Node *t, Node *n, Node *nn)
{
    Node *r;
    long v;

    regialloc(t, n, nn);
    if(n->op == OIND) {
        r = n->left;
        while(r->op == OADD)
            r = r->right;
        if(sconst(r)) {
            v = r->vconst;
            r->vconst = 0;
            lcgen(n, t);
            t->xoffset += v;
            r->vconst = v;
            regind(t, n);
            return;
        }
    }
    lcgen(n, t);
    regind(t, n);
}
@

<<function [[lcgen]](x86)>>=
void
lcgen(Node *n, Node *nn)
{
    Prog *p1;
    Node nod;

    if(debug['g']) {
        prtree(nn, "lcgen lhs");
        prtree(n, "lcgen");
    }
    if(n == Z || n->type == T)
        return;
    if(nn == Z) {
        nn = &nod;
        regalloc(&nod, n, Z);
    }
    switch(n->op) {
    case OCOMMA:
        cgen(n->left, n->left);
        lcgen(n->right, nn);
        break;

    case OIND:
        cgen(n->left, nn);
        break;

    case OCOND:
        bcgen(n->left, 1);
        p1 = p;
        lcgen(n->right->left, nn);
        gbranch(OGOTO);
        patch(p1, pc);
        p1 = p;
        lcgen(n->right->right, nn);
        patch(p1, pc);
        break;

    default:
        if(n->addable < INDEXED) {
            diag(n, "unknown op in lcgen: %O", n->op);
            break;
        }
        gopcode(OADDR, n->type, n, nn);
        break;

    }
}
@

<<function [[boolgen]](x86)>>=
void
boolgen(Node *n, int true, Node *nn)
{
    int o;
    Prog *p1, *p2;
    Node *l, *r, nod, nod1;
    long curs;

    if(debug['g']) {
        prtree(nn, "boolgen lhs");
        prtree(n, "boolgen");
    }

    curs = cursafe;
    l = n->left;
    r = n->right;
    switch(n->op) {

    default:
        if(typev[n->type->etype]) {
            testv(n, true);
            goto com;
        }
        o = ONE;
        if(true)
            o = OEQ;
        if(typefd[n->type->etype]) {
            if(n->addable < INDEXED) {
                cgen(n, &fregnode0);
                gins(AFLDZ, Z, Z);
                fgopcode(o, &fregnode0, &fregnode1, 1, 1);
            } else {
                gins(AFLDZ, Z, Z);
                fgopcode(o, n, &fregnode0, 0, 1);
            }
            goto com;
        }
        /* bad, 13 is address of external that becomes constant */
        if(n->addable >= INDEXED && n->addable != 13) {
            gopcode(o, n->type, n, nodconst(0));
            goto com;
        }
        regalloc(&nod, n, nn);
        cgen(n, &nod);
        gopcode(o, n->type, &nod, nodconst(0));
        regfree(&nod);
        goto com;

    case OCONST:
        o = vconst(n);
        if(!true)
            o = !o;
        gbranch(OGOTO);
        if(o) {
            p1 = p;
            gbranch(OGOTO);
            patch(p1, pc);
        }
        goto com;

    case OCOMMA:
        cgen(l, Z);
        boolgen(r, true, nn);
        break;

    case ONOT:
        boolgen(l, !true, nn);
        break;

    case OCOND:
        bcgen(l, 1);
        p1 = p;
        bcgen(r->left, true);
        p2 = p;
        gbranch(OGOTO);
        patch(p1, pc);
        p1 = p;
        bcgen(r->right, !true);
        patch(p2, pc);
        p2 = p;
        gbranch(OGOTO);
        patch(p1, pc);
        patch(p2, pc);
        goto com;

    case OANDAND:
        if(!true)
            goto caseor;

    caseand:
        bcgen(l, true);
        p1 = p;
        bcgen(r, !true);
        p2 = p;
        patch(p1, pc);
        gbranch(OGOTO);
        patch(p2, pc);
        goto com;

    case OOROR:
        if(!true)
            goto caseand;

    caseor:
        bcgen(l, !true);
        p1 = p;
        bcgen(r, !true);
        p2 = p;
        gbranch(OGOTO);
        patch(p1, pc);
        patch(p2, pc);
        goto com;

    case OEQ:
    case ONE:
    case OLE:
    case OLT:
    case OGE:
    case OGT:
    case OHI:
    case OHS:
    case OLO:
    case OLS:
        o = n->op;
        if(typev[l->type->etype]) {
            if(!true)
                n->op = comrel[relindex(o)];
            cgen64(n, Z);
            goto com;
        }
        if(true)
            o = comrel[relindex(o)];
        if(l->complex >= FNX && r->complex >= FNX) {
            regret(&nod, r);
            cgen(r, &nod);
            regsalloc(&nod1, r);
            gmove(&nod, &nod1);
            regfree(&nod);
            nod = *n;
            nod.right = &nod1;
            boolgen(&nod, true, nn);
            break;
        }
        if(typefd[l->type->etype]) {
            if(l->complex >= r->complex) {
                cgen(l, &fregnode0);
                if(r->addable < INDEXED) {
                    cgen(r, &fregnode0);
                    o = invrel[relindex(o)];
                    fgopcode(o, &fregnode0, &fregnode1, 1, 1);
                } else
                    fgopcode(o, r, &fregnode0, 0, 1);
            } else {
                o = invrel[relindex(o)];
                cgen(r, &fregnode0);
                if(l->addable < INDEXED) {
                    cgen(l, &fregnode0);
                    o = invrel[relindex(o)];
                    fgopcode(o, &fregnode0, &fregnode1, 1, 1);
                } else
                    fgopcode(o, l, &fregnode0, 0, 1);
            }
            goto com;
        }
        if(l->op == OCONST) {
            o = invrel[relindex(o)];
            /* bad, 13 is address of external that becomes constant */
            if(r->addable < INDEXED || r->addable == 13) {
                regalloc(&nod, r, nn);
                cgen(r, &nod);
                gopcode(o, l->type, &nod, l);
                regfree(&nod);
            } else
                gopcode(o, l->type, r, l);
            goto com;
        }
        if(l->complex >= r->complex) {
            regalloc(&nod, l, nn);
            cgen(l, &nod);
            if(r->addable < INDEXED) {
                regalloc(&nod1, r, Z);
                cgen(r, &nod1);
                gopcode(o, l->type, &nod, &nod1);
                regfree(&nod1);
            } else
                gopcode(o, l->type, &nod, r);
            regfree(&nod);
            goto com;
        }
        regalloc(&nod, r, nn);
        cgen(r, &nod);
        if(l->addable < INDEXED || l->addable == 13) {
            regalloc(&nod1, l, Z);
            cgen(l, &nod1);
            if(typechlp[l->type->etype])
                gopcode(o, types[TINT], &nod1, &nod);
            else
                gopcode(o, l->type, &nod1, &nod);
            regfree(&nod1);
        } else
            gopcode(o, l->type, l, &nod);
        regfree(&nod);

    com:
        if(nn != Z) {
            p1 = p;
            gmove(nodconst(1L), nn);
            gbranch(OGOTO);
            p2 = p;
            patch(p1, pc);
            gmove(nodconst(0L), nn);
            patch(p2, pc);
        }
        break;
    }
    cursafe = curs;
}
@

<<function [[sugen]](x86)>>=
void
sugen(Node *n, Node *nn, long w)
{
    Prog *p1;
    Node nod0, nod1, nod2, nod3, nod4, *h, *l, *r;
    Type *t;
    int c, v, x;

    if(n == Z || n->type == T)
        return;
    if(debug['g']) {
        prtree(nn, "sugen lhs");
        prtree(n, "sugen");
    }

    if(nn == nodrat)
        if(w > nrathole)
            nrathole = w;
    switch(n->op) {
    case OIND:
        if(nn == Z) {
            nullwarn(n->left, Z);
            break;
        }

    default:
        goto copy;

    case OCONST:
        if(n->type && typev[n->type->etype]) {
            if(nn == Z) {
                nullwarn(n->left, Z);
                break;
            }

            if(nn->op == OREGPAIR) {
                loadpair(n, nn);
                break;
            }
            else if(!vaddr(nn, 0)) {
                t = nn->type;
                nn->type = types[TLONG];
                reglcgen(&nod1, nn, Z);
                nn->type = t;

                gmove(lo64(n), &nod1);
                nod1.xoffset += SZ_LONG;
                gmove(hi64(n), &nod1);
                regfree(&nod1);
            }
            else {
                gins(AMOVL, lo64(n), nn);
                nn->xoffset += SZ_LONG;
                gins(AMOVL, hi64(n), nn);
                nn->xoffset -= SZ_LONG;
                break;
            }
            break;
        }
        goto copy;

    case ODOT:
        l = n->left;
        sugen(l, nodrat, l->type->width);
        if(nn == Z)
            break;
        warn(n, "non-interruptable temporary");
        nod1 = *nodrat;
        r = n->right;
        if(!r || r->op != OCONST) {
            diag(n, "DOT and no offset");
            break;
        }
        nod1.xoffset += (long)r->vconst;
        nod1.type = n->type;
        sugen(&nod1, nn, w);
        break;

    case OSTRUCT:
        /*
         * rewrite so lhs has no fn call
         */
        if(nn != Z && side(nn)) {
            nod1 = *n;
            nod1.type = typ(TIND, n->type);
            regret(&nod2, &nod1);
            lcgen(nn, &nod2);
            regsalloc(&nod0, &nod1);
            cgen(&nod2, &nod0);
            regfree(&nod2);

            nod1 = *n;
            nod1.op = OIND;
            nod1.left = &nod0;
            nod1.right = Z;
            nod1.complex = 1;

            sugen(n, &nod1, w);
            return;
        }

        r = n->left;
        for(t = n->type->link; t != T; t = t->down) {
            l = r;
            if(r->op == OLIST) {
                l = r->left;
                r = r->right;
            }
            if(nn == Z) {
                cgen(l, nn);
                continue;
            }
            /*
             * hand craft *(&nn + o) = l
             */
            nod0 = znode;
            nod0.op = OAS;
            nod0.type = t;
            nod0.left = &nod1;
            nod0.right = nil;

            nod1 = znode;
            nod1.op = OIND;
            nod1.type = t;
            nod1.left = &nod2;

            nod2 = znode;
            nod2.op = OADD;
            nod2.type = typ(TIND, t);
            nod2.left = &nod3;
            nod2.right = &nod4;

            nod3 = znode;
            nod3.op = OADDR;
            nod3.type = nod2.type;
            nod3.left = nn;

            nod4 = znode;
            nod4.op = OCONST;
            nod4.type = nod2.type;
            nod4.vconst = t->offset;

            ccom(&nod0);
            acom(&nod0);
            xcom(&nod0);
            nod0.addable = 0;
            nod0.right = l;

            /* prtree(&nod0, "hand craft"); /* */
            cgen(&nod0, Z);
        }
        break;

    case OAS:
        if(nn == Z) {
            if(n->addable < INDEXED)
                sugen(n->right, n->left, w);
            break;
        }

        sugen(n->right, nodrat, w);
        warn(n, "non-interruptable temporary");
        sugen(nodrat, n->left, w);
        sugen(nodrat, nn, w);
        break;

    case OFUNC:
        if(nn == Z) {
            sugen(n, nodrat, w);
            break;
        }
        h = nn;
        if(nn->op == OREGPAIR) {
            regsalloc(&nod1, nn);
            nn = &nod1;
        }
        if(nn->op != OIND) {
            nn = new1(OADDR, nn, Z);
            nn->type = types[TIND];
            nn->addable = 0;
        } else
            nn = nn->left;
        n = new(OFUNC, n->left, new(OLIST, nn, n->right));
        n->type = types[TVOID];
        n->left->type = types[TVOID];
        cgen(n, Z);
        if(h->op == OREGPAIR)
            loadpair(nn->left, h);
        break;

    case OCOND:
        bcgen(n->left, 1);
        p1 = p;
        sugen(n->right->left, nn, w);
        gbranch(OGOTO);
        patch(p1, pc);
        p1 = p;
        sugen(n->right->right, nn, w);
        patch(p1, pc);
        break;

    case OCOMMA:
        cgen(n->left, Z);
        sugen(n->right, nn, w);
        break;
    }
    return;

copy:
    if(nn == Z) {
        switch(n->op) {
        case OASADD:
        case OASSUB:
        case OASAND:
        case OASOR:
        case OASXOR:

        case OASMUL:
        case OASLMUL:

        case OASASHL:
        case OASASHR:
        case OASLSHR:
            break;

        case OPOSTINC:
        case OPOSTDEC:
        case OPREINC:
        case OPREDEC:
            break;

        default:
            return;
        }
    }

    if(n->complex >= FNX && nn != nil && nn->complex >= FNX) {
        t = nn->type;
        nn->type = types[TLONG];
        regialloc(&nod1, nn, Z);
        lcgen(nn, &nod1);
        regsalloc(&nod2, nn);
        nn->type = t;

        gins(AMOVL, &nod1, &nod2);
        regfree(&nod1);

        nod2.type = typ(TIND, t);

        nod1 = nod2;
        nod1.op = OIND;
        nod1.left = &nod2;
        nod1.right = Z;
        nod1.complex = 1;
        nod1.type = t;

        sugen(n, &nod1, w);
        return;
    }

    x = 0;
    v = w == 8;
    if(v) {
        c = cursafe;
        if(n->left != Z && n->left->complex >= FNX
        && n->right != Z && n->right->complex >= FNX) {
//			warn(n, "toughie");
            regsalloc(&nod1, n->right);
            cgen(n->right, &nod1);
            nod2 = *n;
            nod2.right = &nod1;
            cgen(&nod2, nn);
            cursafe = c;
            return;
        }
        if(cgen64(n, nn)) {
            cursafe = c;
            return;
        }
        if(n->op == OCOM) {
            n = n->left;
            x = 1;
        }
    }

    /* botch, need to save in .safe */
    c = 0;
    if(n->complex > nn->complex) {
        t = n->type;
        n->type = types[TLONG];
        if(v) {
            regalloc(&nod0, n, Z);
            if(!vaddr(n, 0)) {
                reglcgen(&nod1, n, Z);
                n->type = t;
                n = &nod1;
            }
            else
                n->type = t;
        }
        else {
            nodreg(&nod1, n, D_SI);
            if(reg[D_SI]) {
                gins(APUSHL, &nod1, Z);
                c |= 1;
                reg[D_SI]++;
            }
            lcgen(n, &nod1);
            n->type = t;
        }

        t = nn->type;
        nn->type = types[TLONG];
        if(v) {
            if(!vaddr(nn, 0)) {
                reglcgen(&nod2, nn, Z);
                nn->type = t;
                nn = &nod2;
            }
            else
                nn->type = t;
        }
        else {
            nodreg(&nod2, nn, D_DI);
            if(reg[D_DI]) {
                gins(APUSHL, &nod2, Z);
                c |= 2;
                reg[D_DI]++;
            }
            lcgen(nn, &nod2);
            nn->type = t;
        }
    } else {
        t = nn->type;
        nn->type = types[TLONG];
        if(v) {
            regalloc(&nod0, nn, Z);
            if(!vaddr(nn, 0)) {
                reglcgen(&nod2, nn, Z);
                nn->type = t;
                nn = &nod2;
            }
            else
                nn->type = t;
        }
        else {
            nodreg(&nod2, nn, D_DI);
            if(reg[D_DI]) {
                gins(APUSHL, &nod2, Z);
                c |= 2;
                reg[D_DI]++;
            }
            lcgen(nn, &nod2);
            nn->type = t;
        }

        t = n->type;
        n->type = types[TLONG];
        if(v) {
            if(!vaddr(n, 0)) {
                reglcgen(&nod1, n, Z);
                n->type = t;
                n = &nod1;
            }
            else
                n->type = t;
        }
        else {
            nodreg(&nod1, n, D_SI);
            if(reg[D_SI]) {
                gins(APUSHL, &nod1, Z);
                c |= 1;
                reg[D_SI]++;
            }
            lcgen(n, &nod1);
            n->type = t;
        }
    }
    if(v) {
        gins(AMOVL, n, &nod0);
        if(x)
            gins(ANOTL, Z, &nod0);
        gins(AMOVL, &nod0, nn);
        n->xoffset += SZ_LONG;
        nn->xoffset += SZ_LONG;
        gins(AMOVL, n, &nod0);
        if(x)
            gins(ANOTL, Z, &nod0);
        gins(AMOVL, &nod0, nn);
        n->xoffset -= SZ_LONG;
        nn->xoffset -= SZ_LONG;
        if(nn == &nod2)
            regfree(&nod2);
        if(n == &nod1)
            regfree(&nod1);
        regfree(&nod0);
        return;
    }
    nodreg(&nod3, n, D_CX);
    if(reg[D_CX]) {
        gins(APUSHL, &nod3, Z);
        c |= 4;
        reg[D_CX]++;
    }
    gins(AMOVL, nodconst(w/SZ_LONG), &nod3);
    gins(ACLD, Z, Z);
    gins(AREP, Z, Z);
    gins(AMOVSL, Z, Z);
    if(w & (SZ_LONG-1)) {
        /* odd length of packed structure */
        gins(AMOVL, nodconst(w & (SZ_LONG-1)), &nod3);
        gins(AREP, Z, Z);
        gins(AMOVSB, Z, Z);
    }
    if(c & 4) {
        gins(APOPL, Z, &nod3);
        reg[D_CX]--;
    }
    if(c & 2) {
        gins(APOPL, Z, &nod2);
        reg[nod2.reg]--;
    }
    if(c & 1) {
        gins(APOPL, Z, &nod1);
        reg[nod1.reg]--;
    }
}
@

<<function [[mulgen]](x86)>>=
void
mulgen(Type *t, Node *r, Node *n)
{
    if(!mulgen1(r->vconst, n))
        gopcode(OMUL, t, r, n);
}
@


<<struct [[Malg]](x86)>>=
struct	Malg
{
    char	vals[10];
};
@

<<struct [[Mparam]](x86)>>=
struct	Mparam
{
    ulong	value;
    char	alg;
    char	neg;
    char	shift;
    char	arg;
    char	off;
};
@

<<global [[multab]](x86)>>=
static	Mparam	multab[32];
@


<<global [[mulptr]](x86)>>=
static	int	mulptr;
@

<<global [[malgs]](x86)>>=
static	Malg	malgs[]	=
{
    {0, 100},
    {-1, 1, 100},
    {-9, -5, -3, 3, 5, 9, 100},
    {6, 10, 12, 18, 20, 24, 36, 40, 72, 100},
    {-8, -4, -2, 2, 4, 8, 100},
};
@

<<function [[lowbit]](x86)>>=
/*
 * return position of lowest 1
 */
int
lowbit(ulong v)
{
    int s, i;
    ulong m;

    s = 0;
    m = 0xFFFFFFFFUL;
    for(i = 16; i > 0; i >>= 1) {
        m >>= i;
        if((v & m) == 0) {
            v >>= i;
            s += i;
        }
    }
    return s;
}
@

<<function [[genmuladd]](x86)>>=
void
genmuladd(Node *d, Node *s, int m, Node *a)
{
    Node nod;

    nod.op = OINDEX;
    nod.left = a;
    nod.right = s;
    nod.scale = m;
    nod.type = types[TIND];
    nod.xoffset = 0;
    xcom(&nod);
    gopcode(OADDR, d->type, &nod, d);
}
@

<<function [[mulparam]](x86)>>=
void
mulparam(ulong m, Mparam *mp)
{
    int c, i, j, n, o, q, s;
    int bc, bi, bn, bo, bq, bs, bt;
    char *p;
    long u;
    ulong t;

    bc = bq = 10;
    bi = bn = bo = bs = bt = 0;
    for(i = 0; i < nelem(malgs); i++) {
        for(p = malgs[i].vals, j = 0; (o = p[j]) < 100; j++)
        for(s = 0; s < 2; s++) {
            c = 10;
            q = 10;
            u = m - o;
            if(u == 0)
                continue;
            if(s) {
                o = -o;
                if(o > 0)
                    continue;
                u = -u;
            }
            n = lowbit(u);
            t = (ulong)u >> n;
            switch(i) {
            case 0:
                if(t == 1) {
                    c = s + 1;
                    q = 0;
                    break;
                }
                switch(t) {
                case 3:
                case 5:
                case 9:
                    c = s + 1;
                    if(n)
                        c++;
                    q = 0;
                    break;
                }
                if(s)
                    break;
                switch(t) {
                case 15:
                case 25:
                case 27:
                case 45:
                case 81:
                    c = 2;
                    if(n)
                        c++;
                    q = 1;
                    break;
                }
                break;
            case 1:
                if(t == 1) {
                    c = 3;
                    q = 3;
                    break;
                }
                switch(t) {
                case 3:
                case 5:
                case 9:
                    c = 3;
                    q = 2;
                    break;
                }
                break;
            case 2:
                if(t == 1) {
                    c = 3;
                    q = 2;
                    break;
                }
                break;
            case 3:
                if(s)
                    break;
                if(t == 1) {
                    c = 3;
                    q = 1;
                    break;
                }
                break;
            case 4:
                if(t == 1) {
                    c = 3;
                    q = 0;
                    break;
                }
                break;
            }
            if(c < bc || (c == bc && q > bq)) {
                bc = c;
                bi = i;
                bn = n;
                bo = o;
                bq = q;
                bs = s;
                bt = t;
            }
        }
    }
    mp->value = m;
    if(bc <= 3) {
        mp->alg = bi;
        mp->shift = bn;
        mp->off = bo;
        mp->neg = bs;
        mp->arg = bt;
    }
    else
        mp->alg = -1;
}
@

<<function [[m0]](x86)>>=
int
m0(int a)
{
    switch(a) {
    case -2:
    case 2:
        return 2;
    case -3:
    case 3:
        return 2;
    case -4:
    case 4:
        return 4;
    case -5:
    case 5:
        return 4;
    case 6:
        return 2;
    case -8:
    case 8:
        return 8;
    case -9:
    case 9:
        return 8;
    case 10:
        return 4;
    case 12:
        return 2;
    case 15:
        return 2;
    case 18:
        return 8;
    case 20:
        return 4;
    case 24:
        return 2;
    case 25:
        return 4;
    case 27:
        return 2;
    case 36:
        return 8;
    case 40:
        return 4;
    case 45:
        return 4;
    case 72:
        return 8;
    case 81:
        return 8;
    }
    diag(Z, "bad m0");
    return 0;
}
@

<<function [[m1]](x86)>>=
int
m1(int a)
{
    switch(a) {
    case 15:
        return 4;
    case 25:
        return 4;
    case 27:
        return 8;
    case 45:
        return 8;
    case 81:
        return 8;
    }
    diag(Z, "bad m1");
    return 0;
}
@

<<function [[m2]](x86)>>=
int
m2(int a)
{
    switch(a) {
    case 6:
        return 2;
    case 10:
        return 2;
    case 12:
        return 4;
    case 18:
        return 2;
    case 20:
        return 4;
    case 24:
        return 8;
    case 36:
        return 4;
    case 40:
        return 8;
    case 72:
        return 8;
    }
    diag(Z, "bad m2");
    return 0;
}
@

<<function [[shiftit]](x86)>>=
void
shiftit(Type *t, Node *s, Node *d)
{
    long c;

    c = (long)s->vconst & 31;
    switch(c) {
    case 0:
        break;
    case 1:
        gopcode(OADD, t, d, d);
        break;
    default:
        gopcode(OASHL, t, s, d);
    }
}
@

<<function [[mulgen1]](x86)>>=
static int
mulgen1(ulong v, Node *n)
{
    int i, o;
    Mparam *p;
    Node nod, nods;

    for(i = 0; i < nelem(multab); i++) {
        p = &multab[i];
        if(p->value == v)
            goto found;
    }

    p = &multab[mulptr];
    if(++mulptr == nelem(multab))
        mulptr = 0;

    mulparam(v, p);

found:
//	print("v=%.lx a=%d n=%d s=%d g=%d o=%d \n", p->value, p->alg, p->neg, p->shift, p->arg, p->off);
    if(p->alg < 0)
        return 0;

    nods = *nodconst(p->shift);

    o = OADD;
    if(p->alg > 0) {
        regalloc(&nod, n, Z);
        if(p->off < 0)
            o = OSUB;
    }

    switch(p->alg) {
    case 0:
        switch(p->arg) {
        case 1:
            shiftit(n->type, &nods, n);
            break;
        case 15:
        case 25:
        case 27:
        case 45:
        case 81:
            genmuladd(n, n, m1(p->arg), n);
            /* fall thru */
        case 3:
        case 5:
        case 9:
            genmuladd(n, n, m0(p->arg), n);
            shiftit(n->type, &nods, n);
            break;
        default:
            goto bad;
        }
        if(p->neg == 1)
            gins(ANEGL, Z, n);
        break;
    case 1:
        switch(p->arg) {
        case 1:
            gmove(n, &nod);
            shiftit(n->type, &nods, &nod);
            break;
        case 3:
        case 5:
        case 9:
            genmuladd(&nod, n, m0(p->arg), n);
            shiftit(n->type, &nods, &nod);
            break;
        default:
            goto bad;
        }
        if(p->neg)
            gopcode(o, n->type, &nod, n);
        else {
            gopcode(o, n->type, n, &nod);
            gmove(&nod, n);
        }
        break;
    case 2:
        genmuladd(&nod, n, m0(p->off), n);
        shiftit(n->type, &nods, n);
        goto comop;
    case 3:
        genmuladd(&nod, n, m0(p->off), n);
        shiftit(n->type, &nods, n);
        genmuladd(n, &nod, m2(p->off), n);
        break;
    case 4:
        genmuladd(&nod, n, m0(p->off), nodconst(0));
        shiftit(n->type, &nods, n);
        goto comop;
    default:
        diag(Z, "bad mul alg");
        break;
    comop:
        if(p->neg) {
            gopcode(o, n->type, n, &nod);
            gmove(&nod, n);
        }
        else
            gopcode(o, n->type, &nod, n);
    }

    if(p->alg > 0)
        regfree(&nod);

    return 1;

bad:
    diag(Z, "mulgen botch");
    return 1;
}
@





% sdiv vs sdiv2, ??

<<function [[TN]](x86)>>=
/*
 * Based on: Granlund, T.; Montgomery, P.L.
 * "Division by Invariant Integers using Multiplication".
 * SIGPLAN Notices, Vol. 29, June 1994, page 61.
 */

#define	TN(n)	((uvlong)1 << (n))
@
% >>

<<constant [[T31]](x86)>>=
#define	T31	TN(31)
@

<<constant [[T32]](x86)>>=
#define	T32	TN(32)
@

<<function [[multiplier]](x86)>>=
int
multiplier(ulong d, int p, uvlong *mp)
{
    int l;
    uvlong mlo, mhi, tlo, thi;

    l = topbit(d - 1) + 1;
    mlo = (((TN(l) - d) << 32) / d) + T32;
    if(l + p == 64)
        mhi = (((TN(l) + 1 - d) << 32) / d) + T32;
    else
        mhi = (TN(32 + l) + TN(32 + l - p)) / d;
    assert(mlo < mhi);
    while(l > 0) {
        tlo = mlo >> 1;
        thi = mhi >> 1;
        if(tlo == thi)
            break;
        mlo = tlo;
        mhi = thi;
        l--;
    }
    *mp = mhi;
    return l;
}
@

<<function [[sdiv]](x86)>>=
int
sdiv(ulong d, ulong *mp, int *sp)
{
    int s;
    uvlong m;

    s = multiplier(d, 32 - 1, &m);
    *mp = m;
    *sp = s;
    if(m >= T31)
        return 1;
    else
        return 0;
}
@

<<function [[udiv]](x86)>>=
int
udiv(ulong d, ulong *mp, int *sp, int *pp)
{
    int p, s;
    uvlong m;

    s = multiplier(d, 32, &m);
    p = 0;
    if(m >= T32) {
        while((d & 1) == 0) {
            d >>= 1;
            p++;
        }
        s = multiplier(d, 32 - p, &m);
    }
    *mp = m;
    *pp = p;
    if(m >= T32) {
        assert(p == 0);
        *sp = s - 1;
        return 1;
    }
    else {
        *sp = s;
        return 0;
    }
}
@

<<function [[sdivgen]](x86)>>=
void
sdivgen(Node *l, Node *r, Node *ax, Node *dx)
{
    int a, s;
    ulong m;
    vlong c;

    c = r->vconst;
    if(c < 0)
        c = -c;
    a = sdiv(c, &m, &s);
//print("a=%d i=%ld s=%d m=%lux\n", a, (long)r->vconst, s, m);
    gins(AMOVL, nodconst(m), ax);
    gins(AIMULL, l, Z);
    gins(AMOVL, l, ax);
    if(a)
        gins(AADDL, ax, dx);
    gins(ASHRL, nodconst(31), ax);
    gins(ASARL, nodconst(s), dx);
    gins(AADDL, ax, dx);
    if(r->vconst < 0)
        gins(ANEGL, Z, dx);
}
@

<<function [[udivgen]](x86)>>=
void
udivgen(Node *l, Node *r, Node *ax, Node *dx)
{
    int a, s, t;
    ulong m;
    Node nod;

    a = udiv(r->vconst, &m, &s, &t);
//print("a=%ud i=%ld p=%d s=%d m=%lux\n", a, (long)r->vconst, t, s, m);
    if(t != 0) {
        gins(AMOVL, l, ax);
        gins(ASHRL, nodconst(t), ax);
        gins(AMOVL, nodconst(m), dx);
        gins(AMULL, dx, Z);
    }
    else if(a) {
        if(l->op != OREGISTER) {
            regalloc(&nod, l, Z);
            gins(AMOVL, l, &nod);
            l = &nod;
        }
        gins(AMOVL, nodconst(m), ax);
        gins(AMULL, l, Z);
        gins(AADDL, l, dx);
        gins(ARCRL, nodconst(1), dx);
        if(l == &nod)
            regfree(l);
    }
    else {
        gins(AMOVL, nodconst(m), ax);
        gins(AMULL, l, Z);
    }
    if(s != 0)
        gins(ASHRL, nodconst(s), dx);
}
@

<<function [[sext]](x86)>>=
void
sext(Node *d, Node *s, Node *l)
{
    if(s->reg == D_AX && !nodreg(d, Z, D_DX)) {
        reg[D_DX]++;
        gins(ACDQ, Z, Z);
    }
    else {
        regalloc(d, l, Z);
        gins(AMOVL, s, d);
        gins(ASARL, nodconst(31), d);
    }
}
@

<<function [[sdiv2]](x86)>>=
void
sdiv2(long c, int v, Node *l, Node *n)
{
    Node nod;

    if(v > 0) {
        if(v > 1) {
            sext(&nod, n, l);
            gins(AANDL, nodconst((1 << v) - 1), &nod);
            gins(AADDL, &nod, n);
            regfree(&nod);
        }
        else {
            gins(ACMPL, n, nodconst(0x80000000));
            gins(ASBBL, nodconst(-1), n);
        }
        gins(ASARL, nodconst(v), n);
    }
    if(c < 0)
        gins(ANEGL, Z, n);
}
@
% >> >>

<<function [[smod2]](x86)>>=
void
smod2(long c, int v, Node *l, Node *n)
{
    Node nod;

    if(c == 1) {
        zeroregm(n);
        return;
    }

    sext(&nod, n, l);
    if(v == 0) {
        zeroregm(n);
        gins(AXORL, &nod, n);
        gins(ASUBL, &nod, n);
    }
    else if(v > 1) {
        gins(AANDL, nodconst((1 << v) - 1), &nod);
        gins(AADDL, &nod, n);
        gins(AANDL, nodconst((1 << v) - 1), n);
        gins(ASUBL, &nod, n);
    }
    else {
        gins(AANDL, nodconst(1), n);
        gins(AXORL, &nod, n);
        gins(ASUBL, &nod, n);
    }
    regfree(&nod);
}
@
% >> >> >>



<<constant [[SZ_CHAR]](x86)>>=
#define	SZ_CHAR		1
@

<<constant [[SZ_SHORT]](x86)>>=
#define	SZ_SHORT	2
@

<<constant [[SZ_INT]](x86)>>=
#define	SZ_INT		4
@

<<constant [[SZ_LONG]](x86)>>=
#define	SZ_LONG		4
@

<<constant [[SZ_IND]](x86)>>=
#define	SZ_IND		4
@

<<constant [[SZ_FLOAT]](x86)>>=
#define	SZ_FLOAT	4
@

% 64 bits!
<<constant [[SZ_VLONG]](x86)>>=
#define	SZ_VLONG	8
@

<<constant [[SZ_DOUBLE]](x86)>>=
#define	SZ_DOUBLE	8
@



% coupling with 8.out.h, autogenerated via mkenam script
<<global [[anames]](x86)>>=
char*	anames[] =
{
    "XXX",
    "AAA",
    "AAD",
    "AAM",
    "AAS",
    "ADCB",
    "ADCL",
    "ADCW",
    "ADDB",
    "ADDL",
    "ADDW",
    "ADJSP",
    "ANDB",
    "ANDL",
    "ANDW",
    "ARPL",
    "BOUNDL",
    "BOUNDW",
    "BSFL",
    "BSFW",
    "BSRL",
    "BSRW",
    "BTL",
    "BTW",
    "BTCL",
    "BTCW",
    "BTRL",
    "BTRW",
    "BTSL",
    "BTSW",
    "BYTE",
    "CALL",
    "CLC",
    "CLD",
    "CLI",
    "CLTS",
    "CMC",
    "CMPB",
    "CMPL",
    "CMPW",
    "CMPSB",
    "CMPSL",
    "CMPSW",
    "DAA",
    "DAS",
    "DATA",
    "DECB",
    "DECL",
    "DECW",
    "DIVB",
    "DIVL",
    "DIVW",
    "ENTER",
    "GLOBL",
    "GOK",
    "HISTORY",
    "HLT",
    "IDIVB",
    "IDIVL",
    "IDIVW",
    "IMULB",
    "IMULL",
    "IMULW",
    "INB",
    "INL",
    "INW",
    "INCB",
    "INCL",
    "INCW",
    "INSB",
    "INSL",
    "INSW",
    "INT",
    "INTO",
    "IRETL",
    "IRETW",
    "JCC",
    "JCS",
    "JCXZ",
    "JEQ",
    "JGE",
    "JGT",
    "JHI",
    "JLE",
    "JLS",
    "JLT",
    "JMI",
    "JMP",
    "JNE",
    "JOC",
    "JOS",
    "JPC",
    "JPL",
    "JPS",
    "LAHF",
    "LARL",
    "LARW",
    "LEAL",
    "LEAW",
    "LEAVEL",
    "LEAVEW",
    "LOCK",
    "LODSB",
    "LODSL",
    "LODSW",
    "LONG",
    "LOOP",
    "LOOPEQ",
    "LOOPNE",
    "LSLL",
    "LSLW",
    "MOVB",
    "MOVL",
    "MOVW",
    "MOVBLSX",
    "MOVBLZX",
    "MOVBWSX",
    "MOVBWZX",
    "MOVWLSX",
    "MOVWLZX",
    "MOVSB",
    "MOVSL",
    "MOVSW",
    "MULB",
    "MULL",
    "MULW",
    "NAME",
    "NEGB",
    "NEGL",
    "NEGW",
    "NOP",
    "NOTB",
    "NOTL",
    "NOTW",
    "ORB",
    "ORL",
    "ORW",
    "OUTB",
    "OUTL",
    "OUTW",
    "OUTSB",
    "OUTSL",
    "OUTSW",
    "POPAL",
    "POPAW",
    "POPFL",
    "POPFW",
    "POPL",
    "POPW",
    "PUSHAL",
    "PUSHAW",
    "PUSHFL",
    "PUSHFW",
    "PUSHL",
    "PUSHW",
    "RCLB",
    "RCLL",
    "RCLW",
    "RCRB",
    "RCRL",
    "RCRW",
    "REP",
    "REPN",
    "RET",
    "ROLB",
    "ROLL",
    "ROLW",
    "RORB",
    "RORL",
    "RORW",
    "SAHF",
    "SALB",
    "SALL",
    "SALW",
    "SARB",
    "SARL",
    "SARW",
    "SBBB",
    "SBBL",
    "SBBW",
    "SCASB",
    "SCASL",
    "SCASW",
    "SETCC",
    "SETCS",
    "SETEQ",
    "SETGE",
    "SETGT",
    "SETHI",
    "SETLE",
    "SETLS",
    "SETLT",
    "SETMI",
    "SETNE",
    "SETOC",
    "SETOS",
    "SETPC",
    "SETPL",
    "SETPS",
    "CDQ",
    "CWD",
    "SHLB",
    "SHLL",
    "SHLW",
    "SHRB",
    "SHRL",
    "SHRW",
    "STC",
    "STD",
    "STI",
    "STOSB",
    "STOSL",
    "STOSW",
    "SUBB",
    "SUBL",
    "SUBW",
    "SYSCALL",
    "TESTB",
    "TESTL",
    "TESTW",
    "TEXT",
    "VERR",
    "VERW",
    "WAIT",
    "WORD",
    "XCHGB",
    "XCHGL",
    "XCHGW",
    "XLAT",
    "XORB",
    "XORL",
    "XORW",
    "FMOVB",
    "FMOVBP",
    "FMOVD",
    "FMOVDP",
    "FMOVF",
    "FMOVFP",
    "FMOVL",
    "FMOVLP",
    "FMOVV",
    "FMOVVP",
    "FMOVW",
    "FMOVWP",
    "FMOVX",
    "FMOVXP",
    "FCOMB",
    "FCOMBP",
    "FCOMD",
    "FCOMDP",
    "FCOMDPP",
    "FCOMF",
    "FCOMFP",
    "FCOML",
    "FCOMLP",
    "FCOMW",
    "FCOMWP",
    "FUCOM",
    "FUCOMP",
    "FUCOMPP",
    "FADDDP",
    "FADDW",
    "FADDL",
    "FADDF",
    "FADDD",
    "FMULDP",
    "FMULW",
    "FMULL",
    "FMULF",
    "FMULD",
    "FSUBDP",
    "FSUBW",
    "FSUBL",
    "FSUBF",
    "FSUBD",
    "FSUBRDP",
    "FSUBRW",
    "FSUBRL",
    "FSUBRF",
    "FSUBRD",
    "FDIVDP",
    "FDIVW",
    "FDIVL",
    "FDIVF",
    "FDIVD",
    "FDIVRDP",
    "FDIVRW",
    "FDIVRL",
    "FDIVRF",
    "FDIVRD",
    "FXCHD",
    "FFREE",
    "FLDCW",
    "FLDENV",
    "FRSTOR",
    "FSAVE",
    "FSTCW",
    "FSTENV",
    "FSTSW",
    "F2XM1",
    "FABS",
    "FCHS",
    "FCLEX",
    "FCOS",
    "FDECSTP",
    "FINCSTP",
    "FINIT",
    "FLD1",
    "FLDL2E",
    "FLDL2T",
    "FLDLG2",
    "FLDLN2",
    "FLDPI",
    "FLDZ",
    "FNOP",
    "FPATAN",
    "FPREM",
    "FPREM1",
    "FPTAN",
    "FRNDINT",
    "FSCALE",
    "FSIN",
    "FSINCOS",
    "FSQRT",
    "FTST",
    "FXAM",
    "FXTRACT",
    "FYL2X",
    "FYL2XP1",
    "END",
    "DYNT",
    "INIT",
    "SIGNAME",
    "FCOMI",
    "FCOMIP",
    "FUCOMI",
    "FUCOMIP",
    "CMPXCHGB",
    "CMPXCHGL",
    "CMPXCHGW",
    "CMOVLCC",
    "CMOVLCS",
    "CMOVLEQ",
    "CMOVLGE",
    "CMOVLGT",
    "CMOVLHI",
    "CMOVLLE",
    "CMOVLLS",
    "CMOVLLT",
    "CMOVLMI",
    "CMOVLNE",
    "CMOVLOC",
    "CMOVLOS",
    "CMOVLPC",
    "CMOVLPL",
    "CMOVLPS",
    "CMOVWCC",
    "CMOVWCS",
    "CMOVWEQ",
    "CMOVWGE",
    "CMOVWGT",
    "CMOVWHI",
    "CMOVWLE",
    "CMOVWLS",
    "CMOVWLT",
    "CMOVWMI",
    "CMOVWNE",
    "CMOVWOC",
    "CMOVWOS",
    "CMOVWPC",
    "CMOVWPL",
    "CMOVWPS",
    "FCMOVCC",
    "FCMOVCS",
    "FCMOVEQ",
    "FCMOVHI",
    "FCMOVLS",
    "FCMOVNE",
    "FCMOVNU",
    "FCMOVUN",
    "LAST",
};
@


<<function [[outcode]](x86)>>=
void
outcode(void)
{
    Prog *p;
    Sym *s;
    int f, sf, st, t, sym;
    Biobuf b;
    struct Htab h[NSYM];

    if(debug['S']) {
        for(p = firstp; p != P; p = p->link)
            if(p->as != ADATA && p->as != AGLOBL)
                pc--;
        for(p = firstp; p != P; p = p->link) {
            print("%P\n", p);
            if(p->as != ADATA && p->as != AGLOBL)
                pc++;
        }
    }
    f = open(outfile, OWRITE);
    if(f < 0) {
        diag(Z, "cannot open %s", outfile);
        return;
    }
    Binit(&b, f, OWRITE);
    Bseek(&b, 0L, 2);
    outhist(&b);
    for(sym=0; sym<NSYM; sym++) {
        h[sym].sym = S;
        h[sym].type = 0;
    }
    sym = 1;
    for(p = firstp; p != P; p = p->link) {
    jackpot:
        sf = 0;
        s = p->from.sym;
        while(s != S) {
            sf = s->symidx;
            if(sf < 0 || sf >= NSYM)
                sf = 0;
            t = p->from.type;
            if(t == D_ADDR)
                t = p->from.index;
            if(h[sf].type == t)
            if(h[sf].sym == s)
                break;
            s->symidx = sym;
            zname(&b, s, t);
            h[sym].sym = s;
            h[sym].type = t;
            sf = sym;
            sym++;
            if(sym >= NSYM)
                sym = 1;
            break;
        }
        st = 0;
        s = p->to.sym;
        while(s != S) {
            st = s->symidx;
            if(st < 0 || st >= NSYM)
                st = 0;
            t = p->to.type;
            if(t == D_ADDR)
                t = p->to.index;
            if(h[st].type == t)
            if(h[st].sym == s)
                break;
            s->symidx = sym;
            zname(&b, s, t);
            h[sym].sym = s;
            h[sym].type = t;
            st = sym;
            sym++;
            if(sym >= NSYM)
                sym = 1;
            if(st == sf)
                goto jackpot;
            break;
        }
        Bputc(&b, p->as);
        Bputc(&b, p->as>>8);
        Bputc(&b, p->lineno);
        Bputc(&b, p->lineno>>8);
        Bputc(&b, p->lineno>>16);
        Bputc(&b, p->lineno>>24);
        zaddr(&b, &p->from, sf);
        zaddr(&b, &p->to, st);
    }
    Bflush(&b);
    close(f);
    firstp = P;
    lastp = P;
}
@


<<function [[outhist]](x86)>>=
void
outhist(Biobuf *b)
{
    Hist *h;
    char *p, *q, *op, c;
    Prog pg;
    int n;

    pg = zprog;
    pg.as = AHISTORY;
    c = pathchar();
    for(h = hist; h != H; h = h->link) {
        p = h->name;
        op = 0;
        if(p && p[0] != c && h->offset == 0 && pathname){
            if(pathname[0] == c){
                op = p;
                p = pathname;
            }
        }
        while(p) {
            q = utfrune(p, c);
            if(q) {
                n = q-p;
                if(n == 0){
                    n = 1;	/* leading "/" */
                    *p = '/';	/* don't emit "\" on windows */
                }
                q++;
            } else {
                n = strlen(p);
                q = 0;
            }
            if(n) {
                Bputc(b, ANAME);
                Bputc(b, ANAME>>8);
                Bputc(b, D_FILE);
                Bputc(b, 1);
                Bputc(b, '<');
                Bwrite(b, p, n);
                Bputc(b, 0);
            }
            p = q;
            if(p == 0 && op) {
                p = op;
                op = 0;
            }
        }
        pg.lineno = h->line;
        pg.to.type = zprog.to.type;
        pg.to.offset = h->offset;
        if(h->offset)
            pg.to.type = D_CONST;

        Bputc(b, pg.as);
        Bputc(b, pg.as>>8);
        Bputc(b, pg.lineno);
        Bputc(b, pg.lineno>>8);
        Bputc(b, pg.lineno>>16);
        Bputc(b, pg.lineno>>24);
        zaddr(b, &pg.from, 0);
        zaddr(b, &pg.to, 0);
    }
}
@


<<function [[zname]](x86)>>=
void
zname(Biobuf *b, Sym *s, int t)
{
    char *n;
    ulong sig;

    if(debug['T'] && t == D_EXTERN && s->sig != SIGDONE && s->type != types[TENUM] && s != symrathole){
        sig = sign(s);
        Bputc(b, ASIGNAME);
        Bputc(b, ASIGNAME>>8);
        Bputc(b, sig);
        Bputc(b, sig>>8);
        Bputc(b, sig>>16);
        Bputc(b, sig>>24);
        s->sig = SIGDONE;
    }
    else{
        Bputc(b, ANAME);	/* as */
        Bputc(b, ANAME>>8);	/* as */
    }
    Bputc(b, t);			/* type */
    Bputc(b, s->symidx);		/* sym */
    n = s->name;
    while(*n) {
        Bputc(b, *n);
        n++;
    }
    Bputc(b, 0);
}
@


<<function [[zaddr]](x86)>>=
void
zaddr(Biobuf *b, Adr *a, int s)
{
    long l;
    int i, t;
    char *n;
    Ieee e;

    t = 0;
    if(a->index != D_NONE || a->scale != 0)
        t |= T_INDEX;
    if(s != 0)
        t |= T_SYM;

    switch(a->type) {
    default:
        t |= T_TYPE;
    case D_NONE:
        if(a->offset != 0)
            t |= T_OFFSET;
        break;
    case D_FCONST:
        t |= T_FCONST;
        break;
    case D_SCONST:
        t |= T_SCONST;
        break;
    }
    Bputc(b, t);

    if(t & T_INDEX) {	/* implies index, scale */
        Bputc(b, a->index);
        Bputc(b, a->scale);
    }
    if(t & T_OFFSET) {	/* implies offset */
        l = a->offset;
        Bputc(b, l);
        Bputc(b, l>>8);
        Bputc(b, l>>16);
        Bputc(b, l>>24);
    }
    if(t & T_SYM)		/* implies sym */
        Bputc(b, s);
    if(t & T_FCONST) {
        ieeedtod(&e, a->dval);
        l = e.l;
        Bputc(b, l);
        Bputc(b, l>>8);
        Bputc(b, l>>16);
        Bputc(b, l>>24);
        l = e.h;
        Bputc(b, l);
        Bputc(b, l>>8);
        Bputc(b, l>>16);
        Bputc(b, l>>24);
        return;
    }
    if(t & T_SCONST) {
        n = a->sval;
        for(i=0; i<NSNAME; i++) {
            Bputc(b, *n);
            n++;
        }
        return;
    }
    if(t & T_TYPE)
        Bputc(b, a->type);
}
@



% 8c/sgen.c
<<function [[xcom]](x86)>>=
/*
 *	calculate addressability as follows
 *		NAME ==> 10/11		name+value(SB/SP)
 *		REGISTER ==> 12		register
 *		CONST ==> 20		$value
 *		*(20) ==> 21		value
 *		&(10) ==> 13		$name+value(SB)
 *		&(11) ==> 1		$name+value(SP) $
 *		(13) + (20) ==> 13	fold constants
 *		(1) + (20) ==> 1	fold constants
 *		*(13) ==> 10		back to name
 *		*(1) ==> 11		back to name
 *
 *		(20) * (X) ==> 7	multiplier in indexing
 *		(X,7) + (13,1) ==> 8	adder in indexing (addresses)
 *		(8) ==> &9(OINDEX)	index, almost addressable
 *
 *	calculate complexity (number of registers)
 * 
 */
void
xcom(Node *n)
{
    Node *l, *r;
    int g;

    if(n == Z)
        return;
    l = n->left;
    r = n->right;
    n->complex = 0;
    n->addable = 0;
    switch(n->op) {
    case OCONST:
        n->addable = 20;
        break;

    case ONAME:
        n->addable = 10;
        if(n->class == CPARAM || n->class == CAUTO)
            n->addable = 11;
        break;

    case OEXREG:
        n->addable = 12;
        break;

    case OREGISTER:
        n->addable = 12;
        break;

    case OINDREG:
        n->addable = 12;
        break;

    case OADDR:
        xcom(l);
        if(l->addable == 10)
            n->addable = 13;
        else
        if(l->addable == 11)
            n->addable = 1;
        break;

    case OADD:
        xcom(l);
        xcom(r);
        if(n->type->etype != TIND)
            break;

        switch(r->addable) {
        case 20:
            switch(l->addable) {
            case 1:
            case 13:
            commadd:
                l->type = n->type;
                *n = *l;
                l = new(0, Z, Z);
                *l = *(n->left);
                l->xoffset += r->vconst;
                n->left = l;
                r = n->right;
                goto brk;
            }
            break;

        case 1:
        case 13:
        case 10:
        case 11:
            /* l is the base, r is the index */
            if(l->addable != 20)
                n->addable = 8;
            break;
        }
        switch(l->addable) {
        case 20:
            switch(r->addable) {
            case 13:
            case 1:
                r = n->left;
                l = n->right;
                n->left = l;
                n->right = r;
                goto commadd;
            }
            break;

        case 13:
        case 1:
        case 10:
        case 11:
            /* r is the base, l is the index */
            if(r->addable != 20)
                n->addable = 8;
            break;
        }
        if(n->addable == 8 && !side(n)) {
            indx(n);
            l = new1(OINDEX, idx.basetree, idx.regtree);
            l->scale = idx.scale;
            l->addable = 9;
            l->complex = l->right->complex;
            l->type = l->left->type;
            n->op = OADDR;
            n->left = l;
            n->right = Z;
            n->addable = 8;
            break;
        }
        break;

    case OINDEX:
        xcom(l);
        xcom(r);
        n->addable = 9;
        break;

    case OIND:
        xcom(l);
        if(l->op == OADDR) {
            l = l->left;
            l->type = n->type;
            *n = *l;
            return;
        }
        switch(l->addable) {
        case 20:
            n->addable = 21;
            break;
        case 1:
            n->addable = 11;
            break;
        case 13:
            n->addable = 10;
            break;
        }
        break;

    case OASHL:
        xcom(l);
        xcom(r);
        indexshift(n);
        break;

    case OMUL:
    case OLMUL:
        xcom(l);
        xcom(r);
        g = vlog(l);
        if(g >= 0) {
            n->left = r;
            n->right = l;
            l = r;
            r = n->right;
        }
        g = vlog(r);
        if(g >= 0) {
            n->op = OASHL;
            r->vconst = g;
            r->type = types[TINT];
            indexshift(n);
            break;
        }
commute(n);
        break;

    case OASLDIV:
        xcom(l);
        xcom(r);
        g = vlog(r);
        if(g >= 0) {
            n->op = OASLSHR;
            r->vconst = g;
            r->type = types[TINT];
        }
        break;

    case OLDIV:
        xcom(l);
        xcom(r);
        g = vlog(r);
        if(g >= 0) {
            n->op = OLSHR;
            r->vconst = g;
            r->type = types[TINT];
            indexshift(n);
            break;
        }
        break;

    case OASLMOD:
        xcom(l);
        xcom(r);
        g = vlog(r);
        if(g >= 0) {
            n->op = OASAND;
            r->vconst--;
        }
        break;

    case OLMOD:
        xcom(l);
        xcom(r);
        g = vlog(r);
        if(g >= 0) {
            n->op = OAND;
            r->vconst--;
        }
        break;

    case OASMUL:
    case OASLMUL:
        xcom(l);
        xcom(r);
        g = vlog(r);
        if(g >= 0) {
            n->op = OASASHL;
            r->vconst = g;
        }
        break;

    case OLSHR:
    case OASHR:
        xcom(l);
        xcom(r);
        indexshift(n);
        break;

    default:
        if(l != Z)
            xcom(l);
        if(r != Z)
            xcom(r);
        break;
    }
brk:
    if(n->addable >= 10)
        return;
    if(l != Z)
        n->complex = l->complex;
    if(r != Z) {
        if(r->complex == n->complex)
            n->complex = r->complex+1;
        else
        if(r->complex > n->complex)
            n->complex = r->complex;
    }
    if(n->complex == 0)
        n->complex++;

    if(com64(n))
        return;

    switch(n->op) {

    case OFUNC:
        n->complex = FNX;
        break;

    case OLMOD:
    case OMOD:
    case OLMUL:
    case OLDIV:
    case OMUL:
    case ODIV:
    case OASLMUL:
    case OASLDIV:
    case OASLMOD:
    case OASMUL:
    case OASDIV:
    case OASMOD:
        if(r->complex >= l->complex) {
            n->complex = l->complex + 3;
            if(r->complex > n->complex)
                n->complex = r->complex;
        } else {
            n->complex = r->complex + 3;
            if(l->complex > n->complex)
                n->complex = l->complex;
        }
        break;

    case OLSHR:
    case OASHL:
    case OASHR:
    case OASLSHR:
    case OASASHL:
    case OASASHR:
        if(r->complex >= l->complex) {
            n->complex = l->complex + 2;
            if(r->complex > n->complex)
                n->complex = r->complex;
        } else {
            n->complex = r->complex + 2;
            if(l->complex > n->complex)
                n->complex = l->complex;
        }
        break;

    case OADD:
    case OXOR:
    case OAND:
    case OOR:
        /*
         * immediate operators, make const on right
         */
        if(l->op == OCONST) {
            n->left = r;
            n->right = l;
        }
        break;

    case OEQ:
    case ONE:
    case OLE:
    case OLT:
    case OGE:
    case OGT:
    case OHI:
    case OHS:
    case OLO:
    case OLS:
        /*
         * compare operators, make const on left
         */
        if(r->op == OCONST) {
            n->left = r;
            n->right = l;
            n->op = invrel[relindex(n->op)];
        }
        break;
    }
}
@
%$




%\subsection{[[8c/cgen64.c]]}


<<function [[zeroregm]](x86)>>=
void
zeroregm(Node *n)
{
    gins(AMOVL, nodconst(0), n);
}
@

<<function [[vaddr]](x86)>>=
/* do we need to load the address of a vlong? */
int
vaddr(Node *n, int a)
{
    switch(n->op) {
    case ONAME:
        if(a)
            return 1;
        return !(n->class == CEXTERN || n->class == CGLOBL || n->class == CSTATIC);

    case OCONST:
    case OREGISTER:
    case OINDREG:
        return 1;
    }
    return 0;
}
@

<<function [[hi64v]](x86)>>=
long
hi64v(Node *n)
{
    if(align(0, types[TCHAR], Aarg1))	/* isbigendian */
        return (long)(n->vconst) & ~0L;
    else
        return (long)((uvlong)n->vconst>>32) & ~0L;
}
@

<<function [[lo64v]](x86)>>=
long
lo64v(Node *n)
{
    if(align(0, types[TCHAR], Aarg1))	/* isbigendian */
        return (long)((uvlong)n->vconst>>32) & ~0L;
    else
        return (long)(n->vconst) & ~0L;
}
@

<<function [[hi64]](x86)>>=
Node *
hi64(Node *n)
{
    return nodconst(hi64v(n));
}
@

<<function [[lo64]](x86)>>=
Node *
lo64(Node *n)
{
    return nodconst(lo64v(n));
}
@

<<function [[anonreg]](x86)>>=
static Node *
anonreg(void)
{
    Node *n;

    n = new(OREGISTER, Z, Z);
    n->reg = D_NONE;
    n->type = types[TLONG];
    return n;
}
@

<<function [[regpair]](x86)>>=
static Node *
regpair(Node *n, Node *t)
{
    Node *r;

    if(n != Z && n->op == OREGPAIR)
        return n;
    r = new(OREGPAIR, anonreg(), anonreg());
    if(n != Z)
        r->type = n->type;
    else
        r->type = t->type;
    return r;
}
@

<<function [[evacaxdx]](x86)>>=
static void
evacaxdx(Node *r)
{
    Node nod1, nod2;

    if(r->reg == D_AX || r->reg == D_DX) {
        reg[D_AX]++;
        reg[D_DX]++;
        /*
         * this is just an optim that should
         * check for spill
         */
        r->type = types[TULONG];
        regalloc(&nod1, r, Z);
        nodreg(&nod2, Z, r->reg);
        gins(AMOVL, &nod2, &nod1);
        regfree(r);
        r->reg = nod1.reg;
        reg[D_AX]--;
        reg[D_DX]--;
    }
}
@

<<function [[instpair]](x86)>>=
/* lazy instantiation of register pair */
static int
instpair(Node *n, Node *l)
{
    int r;

    r = 0;
    if(n->left->reg == D_NONE) {
        if(l != Z) {
            n->left->reg = l->reg;
            r = 1;
        }
        else
            regalloc(n->left, n->left, Z);
    }
    if(n->right->reg == D_NONE)
        regalloc(n->right, n->right, Z);
    return r;
}
@

<<function [[zapreg]](x86)>>=
static void
zapreg(Node *n)
{
    if(n->reg != D_NONE) {
        //prtree(n, "zapreg");
        regfree(n);
        n->reg = D_NONE;
    }
}
@

<<function [[freepair]](x86)>>=
static void
freepair(Node *n)
{
    regfree(n->left);
    regfree(n->right);
}
@

<<function [[loadpair]](x86)>>=
/* n is not OREGPAIR, nn is */
void
loadpair(Node *n, Node *nn)
{
    Node nod;

    instpair(nn, Z);
    if(n->op == OCONST) {
        gins(AMOVL, lo64(n), nn->left);
        n->xoffset += SZ_LONG;
        gins(AMOVL, hi64(n), nn->right);
        n->xoffset -= SZ_LONG;
        return;
    }
    if(!vaddr(n, 0)) {
        /* steal the right register for the laddr */
        nod = regnode;
        nod.reg = nn->right->reg;
        lcgen(n, &nod);
        n = &nod;
        regind(n, n);
        n->xoffset = 0;
    }
    gins(AMOVL, n, nn->left);
    n->xoffset += SZ_LONG;
    gins(AMOVL, n, nn->right);
    n->xoffset -= SZ_LONG;
}
@

<<function [[storepair]](x86)>>=
/* n is OREGPAIR, nn is not */
static void
storepair(Node *n, Node *nn, int f)
{
    Node nod;

    if(!vaddr(nn, 0)) {
        reglcgen(&nod, nn, Z);
        nn = &nod;
    }
    gins(AMOVL, n->left, nn);
    nn->xoffset += SZ_LONG;
    gins(AMOVL, n->right, nn);
    nn->xoffset -= SZ_LONG;
    if(nn == &nod)
        regfree(&nod);
    if(f)
        freepair(n);
}
@

<<enum [[_anon_ (8c/cgen64.c)]]>>=
enum
{
/* 4 only, see WW */
    WNONE	= 0,
    WCONST,
    WADDR,
    WHARD,
};
@

<<function [[whatof]](x86)>>=
static int
whatof(Node *n, int a)
{
    if(n->op == OCONST)
        return WCONST;
    return !vaddr(n, a) ? WHARD : WADDR;
}
@

<<function [[reduxv]](x86)>>=
/* can upgrade an extern to addr for AND */
static int
reduxv(Node *n)
{
    return lo64v(n) == 0 || hi64v(n) == 0;
}
@

<<function [[cond]](x86)>>=
bool
cond(int op)
{
    switch(op) {
    case OANDAND:
    case OOROR:
    case ONOT:
        return true;

    case OEQ:
    case ONE:
    case OLE:
    case OLT:
    case OGE:
    case OGT:
    case OHI:
    case OHS:
    case OLO:
    case OLS:
        return true;
    }
    return false;
}
@

<<function [[vfunc]](x86)>>=
/*
 * for a func operand call it and then return
 * the safe node
 */
static Node *
vfunc(Node *n, Node *nn)
{
    Node *t;

    if(n->op != OFUNC)
        return n;
    t = new(0, Z, Z);
    if(nn == Z || nn == nodret)
        nn = n;
    regsalloc(t, nn);
    sugen(n, t, 8);
    return t;
}
@

<<function [[getreg]](x86)>>=
/* try to steal a reg */
static int
getreg(Node **np, Node *t, int r)
{
    Node *n, *p;

    n = *np;
    if(n->reg == r) {
        p = new(0, Z, Z);
        regalloc(p, n, Z);
        gins(AMOVL, n, p);
        *t = *n;
        *np = p;
        return 1;
    }
    return 0;
}
@

<<function [[snarfreg]](x86)>>=
static Node *
snarfreg(Node *n, Node *t, int r, Node *d, Node *c)
{
    if(n == Z || n->op != OREGPAIR || (!getreg(&n->left, t, r) && !getreg(&n->right, t, r))) {
        if(nodreg(t, Z, r)) {
            regalloc(c, d, Z);
            gins(AMOVL, t, c);
            reg[r]++;
            return c;
        }
        reg[r]++;
    }
    return Z;
}
@

<<enum [[_anon_ (8c/cgen64.c)]]2>>=
enum
{
    Vstart	= OEND,

    Vgo,
    Vamv,
    Vmv,
    Vzero,
    Vop,
    Vopx,
    Vins,
    Vins0,
    Vinsl,
    Vinsr,
    Vinsla,
    Vinsra,
    Vinsx,
    Vmul,
    Vshll,
    VT,
    VF,
    V_l_lo_f,
    V_l_hi_f,
    V_l_lo_t,
    V_l_hi_t,
    V_l_lo_u,
    V_l_hi_u,
    V_r_lo_f,
    V_r_hi_f,
    V_r_lo_t,
    V_r_hi_t,
    V_r_lo_u,
    V_r_hi_u,
    Vspazz,
    Vend,

    V_T0,
    V_T1,
    V_F0,
    V_F1,

    V_a0,
    V_a1,
    V_f0,
    V_f1,

    V_p0,
    V_p1,
    V_p2,
    V_p3,
    V_p4,

    V_s0,
    V_s1,
    V_s2,
    V_s3,
    V_s4,

    C00,
    C01,
    C31,
    C32,

    O_l_lo,
    O_l_hi,
    O_r_lo,
    O_r_hi,
    O_t_lo,
    O_t_hi,
    O_l,
    O_r,
    O_l_rp,
    O_r_rp,
    O_t_rp,
    O_r0,
    O_r1,
    O_Zop,

    O_a0,
    O_a1,

    V_C0,
    V_C1,

    V_S0,
    V_S1,

    VOPS	= 5,
    VLEN	= 5,
    VARGS	= 2,

    S00	= 0,
    Sc0,
    Sc1,
    Sc2,
    Sac3,
    Sac4,
    S10,

    SAgen	= 0,
    SAclo,
    SAc32,
    SAchi,
    SAdgen,
    SAdclo,
    SAdc32,
    SAdchi,

    B0c	= 0,
    Bca,
    Bac,

    T0i	= 0,
    Tii,

    Bop0	= 0,
    Bop1,
};
@

<<global [[testi]](x86)>>=
/*
 * _testv:
 * 	CMPL	lo,$0
 * 	JNE	true
 * 	CMPL	hi,$0
 * 	JNE	true
 * 	GOTO	false
 * false:
 * 	GOTO	code
 * true:
 * 	GOTO	patchme
 * code:
 */

static uchar	testi[][VLEN] =
{
    {Vop, ONE, O_l_lo, C00},
    {V_s0, Vop, ONE, O_l_hi, C00},
    {V_s1, Vgo, V_s2, Vgo, V_s3},
    {VF, V_p0, V_p1, VT, V_p2},
    {Vgo, V_p3},
    {VT, V_p0, V_p1, VF, V_p2},
    {Vend},
};
@

<<global [[shll00]](x86)>>=
/* shift left general case */
static uchar	shll00[][VLEN] =
{
    {Vop, OGE, O_r, C32},
    {V_s0, Vinsl, ASHLL, O_r, O_l_rp},
    {Vins, ASHLL, O_r, O_l_lo, Vgo},
    {V_p0, V_s0},
    {Vins, ASHLL, O_r, O_l_lo},
    {Vins, AMOVL, O_l_lo, O_l_hi},
    {Vzero, O_l_lo, V_p0, Vend},
};
@

<<global [[shllc0]](x86)>>=
/* shift left rp, const < 32 */
static uchar	shllc0[][VLEN] =
{
    {Vinsl, ASHLL, O_r, O_l_rp},
    {Vshll, O_r, O_l_lo, Vend},
};
@

<<global [[shllc1]](x86)>>=
/* shift left rp, const == 32 */
static uchar	shllc1[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_l_hi},
    {Vzero, O_l_lo, Vend},
};
@

<<global [[shllc2]](x86)>>=
/* shift left rp, const > 32 */
static uchar	shllc2[][VLEN] =
{
    {Vshll, O_r, O_l_lo},
    {Vins, AMOVL, O_l_lo, O_l_hi},
    {Vzero, O_l_lo, Vend},
};
@

<<global [[shllac3]](x86)>>=
/* shift left addr, const == 32 */
static uchar	shllac3[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_hi},
    {Vzero, O_t_lo, Vend},
};
@

<<global [[shllac4]](x86)>>=
/* shift left addr, const > 32 */
static uchar	shllac4[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_hi},
    {Vshll, O_r, O_t_hi},
    {Vzero, O_t_lo, Vend},
};
@

<<global [[shll10]](x86)>>=
/* shift left of constant */
static uchar	shll10[][VLEN] =
{
    {Vop, OGE, O_r, C32},
    {V_s0, Vins, AMOVL, O_l_lo, O_t_lo},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {Vinsl, ASHLL, O_r, O_t_rp},
    {Vins, ASHLL, O_r, O_t_lo, Vgo},
    {V_p0, V_s0},
    {Vins, AMOVL, O_l_lo, O_t_hi},
    {V_l_lo_t, Vins, ASHLL, O_r, O_t_hi},
    {Vzero, O_t_lo, V_p0, Vend},
};
@

<<global [[shlltab]](x86)>>=
static uchar	(*shlltab[])[VLEN] =
{
    shll00,
    shllc0,
    shllc1,
    shllc2,
    shllac3,
    shllac4,
    shll10,
};
@

<<global [[shrl00]](x86)>>=
/* shift right general case */
static uchar	shrl00[][VLEN] =
{
    {Vop, OGE, O_r, C32},
    {V_s0, Vinsr, ASHRL, O_r, O_l_rp},
    {Vins, O_a0, O_r, O_l_hi, Vgo},
    {V_p0, V_s0},
    {Vins, O_a0, O_r, O_l_hi},
    {Vins, AMOVL, O_l_hi, O_l_lo},
    {V_T1, Vzero, O_l_hi},
    {V_F1, Vins, ASARL, C31, O_l_hi},
    {V_p0, Vend},
};
@

<<global [[shrlc0]](x86)>>=
/* shift right rp, const < 32 */
static uchar	shrlc0[][VLEN] =
{
    {Vinsr, ASHRL, O_r, O_l_rp},
    {Vins, O_a0, O_r, O_l_hi, Vend},
};
@

<<global [[shrlc1]](x86)>>=
/* shift right rp, const == 32 */
static uchar	shrlc1[][VLEN] =
{
    {Vins, AMOVL, O_l_hi, O_l_lo},
    {V_T1, Vzero, O_l_hi},
    {V_F1, Vins, ASARL, C31, O_l_hi},
    {Vend},
};
@

<<global [[shrlc2]](x86)>>=
/* shift right rp, const > 32 */
static uchar	shrlc2[][VLEN] =
{
    {Vins, O_a0, O_r, O_l_hi},
    {Vins, AMOVL, O_l_hi, O_l_lo},
    {V_T1, Vzero, O_l_hi},
    {V_F1, Vins, ASARL, C31, O_l_hi},
    {Vend},
};
@

<<global [[shrlac3]](x86)>>=
/* shift right addr, const == 32 */
static uchar	shrlac3[][VLEN] =
{
    {Vins, AMOVL, O_l_hi, O_t_lo},
    {V_T1, Vzero, O_t_hi},
    {V_F1, Vins, AMOVL, O_t_lo, O_t_hi},
    {V_F1, Vins, ASARL, C31, O_t_hi},
    {Vend},
};
@

<<global [[shrlac4]](x86)>>=
/* shift right addr, const > 32 */
static uchar	shrlac4[][VLEN] =
{
    {Vins, AMOVL, O_l_hi, O_t_lo},
    {Vins, O_a0, O_r, O_t_lo},
    {V_T1, Vzero, O_t_hi},
    {V_F1, Vins, AMOVL, O_t_lo, O_t_hi},
    {V_F1, Vins, ASARL, C31, O_t_hi},
    {Vend},
};
@

<<global [[shrl10]](x86)>>=
/* shift right of constant */
static uchar	shrl10[][VLEN] =
{
    {Vop, OGE, O_r, C32},
    {V_s0, Vins, AMOVL, O_l_lo, O_t_lo},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {Vinsr, ASHRL, O_r, O_t_rp},
    {Vins, O_a0, O_r, O_t_hi, Vgo},
    {V_p0, V_s0},
    {Vins, AMOVL, O_l_hi, O_t_lo},
    {V_l_hi_t, Vins, O_a0, O_r, O_t_lo},
    {V_l_hi_u, V_S1},
    {V_T1, Vzero, O_t_hi, V_p0},
    {V_F1, Vins, AMOVL, O_t_lo, O_t_hi},
    {V_F1, Vins, ASARL, C31, O_t_hi},
    {Vend},
};
@

<<global [[shrltab]](x86)>>=
static uchar	(*shrltab[])[VLEN] =
{
    shrl00,
    shrlc0,
    shrlc1,
    shrlc2,
    shrlac3,
    shrlac4,
    shrl10,
};
@

<<global [[asshllgen]](x86)>>=
/* shift asop left general case */
static uchar	asshllgen[][VLEN] =
{
    {V_a0, V_a1},
    {Vop, OGE, O_r, C32},
    {V_s0, Vins, AMOVL, O_l_lo, O_r0},
    {Vins, AMOVL, O_l_hi, O_r1},
    {Vinsla, ASHLL, O_r, O_r0},
    {Vins, ASHLL, O_r, O_r0},
    {Vins, AMOVL, O_r1, O_l_hi},
    {Vins, AMOVL, O_r0, O_l_lo, Vgo},
    {V_p0, V_s0},
    {Vins, AMOVL, O_l_lo, O_r0},
    {Vzero, O_l_lo},
    {Vins, ASHLL, O_r, O_r0},
    {Vins, AMOVL, O_r0, O_l_hi, V_p0},
    {V_f0, V_f1, Vend},
};
@

<<global [[asshllclo]](x86)>>=
/* shift asop left, const < 32 */
static uchar	asshllclo[][VLEN] =
{
    {V_a0, V_a1},
    {Vins, AMOVL, O_l_lo, O_r0},
    {Vins, AMOVL, O_l_hi, O_r1},
    {Vinsla, ASHLL, O_r, O_r0},
    {Vshll, O_r, O_r0},
    {Vins, AMOVL, O_r1, O_l_hi},
    {Vins, AMOVL, O_r0, O_l_lo},
    {V_f0, V_f1, Vend},
};
@

<<global [[asshllc32]](x86)>>=
/* shift asop left, const == 32 */
static uchar	asshllc32[][VLEN] =
{
    {V_a0},
    {Vins, AMOVL, O_l_lo, O_r0},
    {Vzero, O_l_lo},
    {Vins, AMOVL, O_r0, O_l_hi},
    {V_f0, Vend},
};
@

<<global [[asshllchi]](x86)>>=
/* shift asop left, const > 32 */
static uchar	asshllchi[][VLEN] =
{
    {V_a0},
    {Vins, AMOVL, O_l_lo, O_r0},
    {Vzero, O_l_lo},
    {Vshll, O_r, O_r0},
    {Vins, AMOVL, O_r0, O_l_hi},
    {V_f0, Vend},
};
@

<<global [[asdshllgen]](x86)>>=
/* shift asop dest left general case */
static uchar	asdshllgen[][VLEN] =
{
    {Vop, OGE, O_r, C32},
    {V_s0, Vins, AMOVL, O_l_lo, O_t_lo},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {Vinsl, ASHLL, O_r, O_t_rp},
    {Vins, ASHLL, O_r, O_t_lo},
    {Vins, AMOVL, O_t_hi, O_l_hi},
    {Vins, AMOVL, O_t_lo, O_l_lo, Vgo},
    {V_p0, V_s0},
    {Vins, AMOVL, O_l_lo, O_t_hi},
    {Vzero, O_l_lo},
    {Vins, ASHLL, O_r, O_t_hi},
    {Vzero, O_t_lo},
    {Vins, AMOVL, O_t_hi, O_l_hi, V_p0},
    {Vend},
};
@

<<global [[asdshllclo]](x86)>>=
/* shift asop dest left, const < 32 */
static uchar	asdshllclo[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_lo},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {Vinsl, ASHLL, O_r, O_t_rp},
    {Vshll, O_r, O_t_lo},
    {Vins, AMOVL, O_t_hi, O_l_hi},
    {Vins, AMOVL, O_t_lo, O_l_lo},
    {Vend},
};
@

<<global [[asdshllc32]](x86)>>=
/* shift asop dest left, const == 32 */
static uchar	asdshllc32[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_hi},
    {Vzero, O_t_lo},
    {Vins, AMOVL, O_t_hi, O_l_hi},
    {Vins, AMOVL, O_t_lo, O_l_lo},
    {Vend},
};
@

<<global [[asdshllchi]](x86)>>=
/* shift asop dest, const > 32 */
static uchar	asdshllchi[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_hi},
    {Vzero, O_t_lo},
    {Vshll, O_r, O_t_hi},
    {Vins, AMOVL, O_t_lo, O_l_lo},
    {Vins, AMOVL, O_t_hi, O_l_hi},
    {Vend},
};
@

<<global [[asshlltab]](x86)>>=
static uchar	(*asshlltab[])[VLEN] =
{
    asshllgen,
    asshllclo,
    asshllc32,
    asshllchi,
    asdshllgen,
    asdshllclo,
    asdshllc32,
    asdshllchi,
};
@

<<global [[asshrlgen]](x86)>>=
/* shift asop right general case */
static uchar	asshrlgen[][VLEN] =
{
    {V_a0, V_a1},
    {Vop, OGE, O_r, C32},
    {V_s0, Vins, AMOVL, O_l_lo, O_r0},
    {Vins, AMOVL, O_l_hi, O_r1},
    {Vinsra, ASHRL, O_r, O_r0},
    {Vinsx, Bop0, O_r, O_r1},
    {Vins, AMOVL, O_r0, O_l_lo},
    {Vins, AMOVL, O_r1, O_l_hi, Vgo},
    {V_p0, V_s0},
    {Vins, AMOVL, O_l_hi, O_r0},
    {Vinsx, Bop0, O_r, O_r0},
    {V_T1, Vzero, O_l_hi},
    {Vins, AMOVL, O_r0, O_l_lo},
    {V_F1, Vins, ASARL, C31, O_r0},
    {V_F1, Vins, AMOVL, O_r0, O_l_hi},
    {V_p0, V_f0, V_f1, Vend},
};
@

<<global [[asshrlclo]](x86)>>=
/* shift asop right, const < 32 */
static uchar	asshrlclo[][VLEN] =
{
    {V_a0, V_a1},
    {Vins, AMOVL, O_l_lo, O_r0},
    {Vins, AMOVL, O_l_hi, O_r1},
    {Vinsra, ASHRL, O_r, O_r0},
    {Vinsx, Bop0, O_r, O_r1},
    {Vins, AMOVL, O_r0, O_l_lo},
    {Vins, AMOVL, O_r1, O_l_hi},
    {V_f0, V_f1, Vend},
};
@

<<global [[asshrlc32]](x86)>>=
/* shift asop right, const == 32 */
static uchar	asshrlc32[][VLEN] =
{
    {V_a0},
    {Vins, AMOVL, O_l_hi, O_r0},
    {V_T1, Vzero, O_l_hi},
    {Vins, AMOVL, O_r0, O_l_lo},
    {V_F1, Vins, ASARL, C31, O_r0},
    {V_F1, Vins, AMOVL, O_r0, O_l_hi},
    {V_f0, Vend},
};
@

<<global [[asshrlchi]](x86)>>=
/* shift asop right, const > 32 */
static uchar	asshrlchi[][VLEN] =
{
    {V_a0},
    {Vins, AMOVL, O_l_hi, O_r0},
    {V_T1, Vzero, O_l_hi},
    {Vinsx, Bop0, O_r, O_r0},
    {Vins, AMOVL, O_r0, O_l_lo},
    {V_F1, Vins, ASARL, C31, O_r0},
    {V_F1, Vins, AMOVL, O_r0, O_l_hi},
    {V_f0, Vend},
};
@

<<global [[asdshrlgen]](x86)>>=
/* shift asop dest right general case */
static uchar	asdshrlgen[][VLEN] =
{
    {Vop, OGE, O_r, C32},
    {V_s0, Vins, AMOVL, O_l_lo, O_t_lo},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {Vinsr, ASHRL, O_r, O_t_rp},
    {Vinsx, Bop0, O_r, O_t_hi},
    {Vins, AMOVL, O_t_lo, O_l_lo},
    {Vins, AMOVL, O_t_hi, O_l_hi, Vgo},
    {V_p0, V_s0},
    {Vins, AMOVL, O_l_hi, O_t_lo},
    {V_T1, Vzero, O_t_hi},
    {Vinsx, Bop0, O_r, O_t_lo},
    {V_F1, Vins, AMOVL, O_t_lo, O_t_hi},
    {V_F1, Vins, ASARL, C31, O_t_hi},
    {Vins, AMOVL, O_t_hi, O_l_hi, V_p0},
    {Vend},
};
@

<<global [[asdshrlclo]](x86)>>=
/* shift asop dest right, const < 32 */
static uchar	asdshrlclo[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_lo},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {Vinsr, ASHRL, O_r, O_t_rp},
    {Vinsx, Bop0, O_r, O_t_hi},
    {Vins, AMOVL, O_t_lo, O_l_lo},
    {Vins, AMOVL, O_t_hi, O_l_hi},
    {Vend},
};
@

<<global [[asdshrlc32]](x86)>>=
/* shift asop dest right, const == 32 */
static uchar	asdshrlc32[][VLEN] =
{
    {Vins, AMOVL, O_l_hi, O_t_lo},
    {V_T1, Vzero, O_t_hi},
    {V_F1, Vins, AMOVL, O_t_lo, O_t_hi},
    {V_F1, Vins, ASARL, C31, O_t_hi},
    {Vins, AMOVL, O_t_lo, O_l_lo},
    {Vins, AMOVL, O_t_hi, O_l_hi},
    {Vend},
};
@

<<global [[asdshrlchi]](x86)>>=
/* shift asop dest, const > 32 */
static uchar	asdshrlchi[][VLEN] =
{
    {Vins, AMOVL, O_l_hi, O_t_lo},
    {V_T1, Vzero, O_t_hi},
    {Vinsx, Bop0, O_r, O_t_lo},
    {V_T1, Vins, AMOVL, O_t_hi, O_l_hi},
    {V_T1, Vins, AMOVL, O_t_lo, O_l_lo},
    {V_F1, Vins, AMOVL, O_t_lo, O_t_hi},
    {V_F1, Vins, ASARL, C31, O_t_hi},
    {V_F1, Vins, AMOVL, O_t_lo, O_l_lo},
    {V_F1, Vins, AMOVL, O_t_hi, O_l_hi},
    {Vend},
};
@

<<global [[asshrltab]](x86)>>=
static uchar	(*asshrltab[])[VLEN] =
{
    asshrlgen,
    asshrlclo,
    asshrlc32,
    asshrlchi,
    asdshrlgen,
    asdshrlclo,
    asdshrlc32,
    asdshrlchi,
};
@

<<global [[shrlargs]](x86)>>=
static uchar	shrlargs[]	= { ASHRL, 1 };
@

<<global [[sarlargs]](x86)>>=
static uchar	sarlargs[]	= { ASARL, 0 };
@

<<global [[incdec]](x86)>>=
/* ++ -- */
static uchar	incdec[][VLEN] =
{
    {Vinsx, Bop0, C01, O_l_lo},
    {Vinsx, Bop1, C00, O_l_hi, Vend},
};
@

<<global [[incdecpre]](x86)>>=
/* ++ -- *p */
static uchar	incdecpre[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_lo},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {Vinsx, Bop0, C01, O_t_lo},
    {Vinsx, Bop1, C00, O_t_hi},
    {Vins, AMOVL, O_t_lo, O_l_lo},
    {Vins, AMOVL, O_t_hi, O_l_hi, Vend},
};
@

<<global [[incdecpost]](x86)>>=
/* *p ++ -- */
static uchar	incdecpost[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_lo},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {Vinsx, Bop0, C01, O_l_lo},
    {Vinsx, Bop1, C00, O_l_hi, Vend},
};
@

<<global [[binop00]](x86)>>=
/* binop rp, rp */
static uchar	binop00[][VLEN] =
{
    {Vinsx, Bop0, O_r_lo, O_l_lo},
    {Vinsx, Bop1, O_r_hi, O_l_hi, Vend},
    {Vend},
};
@

<<global [[binoptmp]](x86)>>=
/* binop rp, addr */
static uchar	binoptmp[][VLEN] =
{
    {V_a0, Vins, AMOVL, O_r_lo, O_r0},
    {Vinsx, Bop0, O_r0, O_l_lo},
    {Vins, AMOVL, O_r_hi, O_r0},
    {Vinsx, Bop1, O_r0, O_l_hi},
    {V_f0, Vend},
};
@

<<global [[binop11]](x86)>>=
/* binop t = *a op *b */
static uchar	binop11[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_lo},
    {Vinsx, Bop0, O_r_lo, O_t_lo},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {Vinsx, Bop1, O_r_hi, O_t_hi, Vend},
};
@

<<global [[add0c]](x86)>>=
/* binop t = rp +- c */
static uchar	add0c[][VLEN] =
{
    {V_r_lo_t, Vinsx, Bop0, O_r_lo, O_l_lo},
    {V_r_lo_f, Vamv, Bop0, Bop1},
    {Vinsx, Bop1, O_r_hi, O_l_hi},
    {Vend},
};
@

<<global [[and0c]](x86)>>=
/* binop t = rp & c */
static uchar	and0c[][VLEN] =
{
    {V_r_lo_t, Vinsx, Bop0, O_r_lo, O_l_lo},
    {V_r_lo_f, Vins, AMOVL, C00, O_l_lo},
    {V_r_hi_t, Vinsx, Bop1, O_r_hi, O_l_hi},
    {V_r_hi_f, Vins, AMOVL, C00, O_l_hi},
    {Vend},
};
@

<<global [[or0c]](x86)>>=
/* binop t = rp | c */
static uchar	or0c[][VLEN] =
{
    {V_r_lo_t, Vinsx, Bop0, O_r_lo, O_l_lo},
    {V_r_hi_t, Vinsx, Bop1, O_r_hi, O_l_hi},
    {Vend},
};
@

<<global [[sub10]](x86)>>=
/* binop t = c - rp */
static uchar	sub10[][VLEN] =
{
    {V_a0, Vins, AMOVL, O_l_lo, O_r0},
    {Vinsx, Bop0, O_r_lo, O_r0},
    {Vins, AMOVL, O_l_hi, O_r_lo},
    {Vinsx, Bop1, O_r_hi, O_r_lo},
    {Vspazz, V_f0, Vend},
};
@

<<global [[addca]](x86)>>=
/* binop t = c + *b */
static uchar	addca[][VLEN] =
{
    {Vins, AMOVL, O_r_lo, O_t_lo},
    {V_l_lo_t, Vinsx, Bop0, O_l_lo, O_t_lo},
    {V_l_lo_f, Vamv, Bop0, Bop1},
    {Vins, AMOVL, O_r_hi, O_t_hi},
    {Vinsx, Bop1, O_l_hi, O_t_hi},
    {Vend},
};
@

<<global [[andca]](x86)>>=
/* binop t = c & *b */
static uchar	andca[][VLEN] =
{
    {V_l_lo_t, Vins, AMOVL, O_r_lo, O_t_lo},
    {V_l_lo_t, Vinsx, Bop0, O_l_lo, O_t_lo},
    {V_l_lo_f, Vzero, O_t_lo},
    {V_l_hi_t, Vins, AMOVL, O_r_hi, O_t_hi},
    {V_l_hi_t, Vinsx, Bop1, O_l_hi, O_t_hi},
    {V_l_hi_f, Vzero, O_t_hi},
    {Vend},
};
@

<<global [[orca]](x86)>>=
/* binop t = c | *b */
static uchar	orca[][VLEN] =
{
    {Vins, AMOVL, O_r_lo, O_t_lo},
    {V_l_lo_t, Vinsx, Bop0, O_l_lo, O_t_lo},
    {Vins, AMOVL, O_r_hi, O_t_hi},
    {V_l_hi_t, Vinsx, Bop1, O_l_hi, O_t_hi},
    {Vend},
};
@

<<global [[subca]](x86)>>=
/* binop t = c - *b */
static uchar	subca[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_lo},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {Vinsx, Bop0, O_r_lo, O_t_lo},
    {Vinsx, Bop1, O_r_hi, O_t_hi},
    {Vend},
};
@

<<global [[addac]](x86)>>=
/* binop t = *a +- c */
static uchar	addac[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_lo},
    {V_r_lo_t, Vinsx, Bop0, O_r_lo, O_t_lo},
    {V_r_lo_f, Vamv, Bop0, Bop1},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {Vinsx, Bop1, O_r_hi, O_t_hi},
    {Vend},
};
@

<<global [[orac]](x86)>>=
/* binop t = *a | c */
static uchar	orac[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_lo},
    {V_r_lo_t, Vinsx, Bop0, O_r_lo, O_t_lo},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {V_r_hi_t, Vinsx, Bop1, O_r_hi, O_t_hi},
    {Vend},
};
@

<<global [[andac]](x86)>>=
/* binop t = *a & c */
static uchar	andac[][VLEN] =
{
    {V_r_lo_t, Vins, AMOVL, O_l_lo, O_t_lo},
    {V_r_lo_t, Vinsx, Bop0, O_r_lo, O_t_lo},
    {V_r_lo_f, Vzero, O_t_lo},
    {V_r_hi_t, Vins, AMOVL, O_l_hi, O_t_hi},
    {V_r_hi_t, Vinsx, Bop0, O_r_hi, O_t_hi},
    {V_r_hi_f, Vzero, O_t_hi},
    {Vend},
};
@

<<global [[ADDargs]](x86)>>=
static uchar	ADDargs[]	= { AADDL, AADCL };
@

<<global [[ANDargs]](x86)>>=
static uchar	ANDargs[]	= { AANDL, AANDL };
@

<<global [[ORargs]](x86)>>=
static uchar	ORargs[]	= { AORL, AORL };
@

<<global [[SUBargs]](x86)>>=
static uchar	SUBargs[]	= { ASUBL, ASBBL };
@

<<global [[XORargs]](x86)>>=
static uchar	XORargs[]	= { AXORL, AXORL };
@

<<global [[ADDtab]](x86)>>=
static uchar	(*ADDtab[])[VLEN] =
{
    add0c, addca, addac,
};
@

<<global [[ANDtab]](x86)>>=
static uchar	(*ANDtab[])[VLEN] =
{
    and0c, andca, andac,
};
@

<<global [[ORtab]](x86)>>=
static uchar	(*ORtab[])[VLEN] =
{
    or0c, orca, orac,
};
@

<<global [[SUBtab]](x86)>>=
static uchar	(*SUBtab[])[VLEN] =
{
    add0c, subca, addac,
};
@

<<global [[mulc32]](x86)>>=
/* mul of const32 */
static uchar	mulc32[][VLEN] =
{
    {V_a0, Vop, ONE, O_l_hi, C00},
    {V_s0, Vins, AMOVL, O_r_lo, O_r0},
    {Vins, AMULL, O_r0, O_Zop},
    {Vgo, V_p0, V_s0},
    {Vins, AMOVL, O_l_hi, O_r0},
    {Vmul, O_r_lo, O_r0},
    {Vins, AMOVL, O_r_lo, O_l_hi},
    {Vins, AMULL, O_l_hi, O_Zop},
    {Vins, AADDL, O_r0, O_l_hi},
    {V_f0, V_p0, Vend},
};
@

<<global [[mulc64]](x86)>>=
/* mul of const64 */
static uchar	mulc64[][VLEN] =
{
    {V_a0, Vins, AMOVL, O_r_hi, O_r0},
    {Vop, OOR, O_l_hi, O_r0},
    {Vop, ONE, O_r0, C00},
    {V_s0, Vins, AMOVL, O_r_lo, O_r0},
    {Vins, AMULL, O_r0, O_Zop},
    {Vgo, V_p0, V_s0},
    {Vmul, O_r_lo, O_l_hi},
    {Vins, AMOVL, O_l_lo, O_r0},
    {Vmul, O_r_hi, O_r0},
    {Vins, AADDL, O_l_hi, O_r0},
    {Vins, AMOVL, O_r_lo, O_l_hi},
    {Vins, AMULL, O_l_hi, O_Zop},
    {Vins, AADDL, O_r0, O_l_hi},
    {V_f0, V_p0, Vend},
};
@

<<global [[mull]](x86)>>=
/* mul general */
static uchar	mull[][VLEN] =
{
    {V_a0, Vins, AMOVL, O_r_hi, O_r0},
    {Vop, OOR, O_l_hi, O_r0},
    {Vop, ONE, O_r0, C00},
    {V_s0, Vins, AMOVL, O_r_lo, O_r0},
    {Vins, AMULL, O_r0, O_Zop},
    {Vgo, V_p0, V_s0},
    {Vins, AIMULL, O_r_lo, O_l_hi},
    {Vins, AMOVL, O_l_lo, O_r0},
    {Vins, AIMULL, O_r_hi, O_r0},
    {Vins, AADDL, O_l_hi, O_r0},
    {Vins, AMOVL, O_r_lo, O_l_hi},
    {Vins, AMULL, O_l_hi, O_Zop},
    {Vins, AADDL, O_r0, O_l_hi},
    {V_f0, V_p0, Vend},
};
@

<<global [[castrp]](x86)>>=
/* cast rp l to rp t */
static uchar	castrp[][VLEN] =
{
    {Vmv, O_l, O_t_lo},
    {VT, Vins, AMOVL, O_t_lo, O_t_hi},
    {VT, Vins, ASARL, C31, O_t_hi},
    {VF, Vzero, O_t_hi},
    {Vend},
};
@

<<global [[castrpa]](x86)>>=
/* cast rp l to addr t */
static uchar	castrpa[][VLEN] =
{
    {VT, V_a0, Vmv, O_l, O_r0},
    {VT, Vins, AMOVL, O_r0, O_t_lo},
    {VT, Vins, ASARL, C31, O_r0},
    {VT, Vins, AMOVL, O_r0, O_t_hi},
    {VT, V_f0},
    {VF, Vmv, O_l, O_t_lo},
    {VF, Vzero, O_t_hi},
    {Vend},
};
@

<<global [[netab0i]](x86)>>=
static uchar	netab0i[][VLEN] =
{
    {Vop, ONE, O_l_lo, O_r_lo},
    {V_s0, Vop, ONE, O_l_hi, O_r_hi},
    {V_s1, Vgo, V_s2, Vgo, V_s3},
    {VF, V_p0, V_p1, VT, V_p2},
    {Vgo, V_p3},
    {VT, V_p0, V_p1, VF, V_p2},
    {Vend},
};
@

<<global [[netabii]](x86)>>=
static uchar	netabii[][VLEN] =
{
    {V_a0, Vins, AMOVL, O_l_lo, O_r0},
    {Vop, ONE, O_r0, O_r_lo},
    {V_s0, Vins, AMOVL, O_l_hi, O_r0},
    {Vop, ONE, O_r0, O_r_hi},
    {V_s1, Vgo, V_s2, Vgo, V_s3},
    {VF, V_p0, V_p1, VT, V_p2},
    {Vgo, V_p3},
    {VT, V_p0, V_p1, VF, V_p2},
    {V_f0, Vend},
};
@

<<global [[cmptab0i]](x86)>>=
static uchar	cmptab0i[][VLEN] =
{
    {Vopx, Bop0, O_l_hi, O_r_hi},
    {V_s0, Vins0, AJNE},
    {V_s1, Vopx, Bop1, O_l_lo, O_r_lo},
    {V_s2, Vgo, V_s3, Vgo, V_s4},
    {VT, V_p1, V_p3},
    {VF, V_p0, V_p2},
    {Vgo, V_p4},
    {VT, V_p0, V_p2},
    {VF, V_p1, V_p3},
    {Vend},
};
@

<<global [[cmptabii]](x86)>>=
static uchar	cmptabii[][VLEN] =
{
    {V_a0, Vins, AMOVL, O_l_hi, O_r0},
    {Vopx, Bop0, O_r0, O_r_hi},
    {V_s0, Vins0, AJNE},
    {V_s1, Vins, AMOVL, O_l_lo, O_r0},
    {Vopx, Bop1, O_r0, O_r_lo},
    {V_s2, Vgo, V_s3, Vgo, V_s4},
    {VT, V_p1, V_p3},
    {VF, V_p0, V_p2},
    {Vgo, V_p4},
    {VT, V_p0, V_p2},
    {VF, V_p1, V_p3},
    {V_f0, Vend},
};
@

<<global [[NEtab]](x86)>>=
static uchar	(*NEtab[])[VLEN] =
{
    netab0i, netabii,
};
@

<<global [[cmptab]](x86)>>=
static uchar	(*cmptab[])[VLEN] =
{
    cmptab0i, cmptabii,
};
@

<<global [[GEargs]](x86)>>=
static uchar	GEargs[]	= { OGT, OHS };
@

<<global [[GTargs]](x86)>>=
static uchar	GTargs[]	= { OGT, OHI };
@

<<global [[HIargs]](x86)>>=
static uchar	HIargs[]	= { OHI, OHI };
@

<<global [[HSargs]](x86)>>=
static uchar	HSargs[]	= { OHI, OHS };
@

<<function [[biggen]](x86)>>=
/* Big Generator */
static void
biggen(Node *l, Node *r, Node *t, int true, uchar code[][VLEN], uchar *a)
{
    int i, j, g, oc, op, lo, ro, to, xo, *xp;
    Type *lt;
    Prog *pr[VOPS];
    Node *ot, *tl, *tr, tmps[2];
    uchar *c, (*cp)[VLEN], args[VARGS];

    if(a != nil)
        memmove(args, a, VARGS);
//print("biggen %d %d %d\n", args[0], args[1], args[2]);
//if(l) prtree(l, "l");
//if(r) prtree(r, "r");
//if(t) prtree(t, "t");
    lo = ro = to = 0;
    cp = code;

    for (;;) {
        c = *cp++;
        g = 1;
        i = 0;
//print("code %d %d %d %d %d\n", c[0], c[1], c[2], c[3], c[4]);
        for(;;) {
            switch(op = c[i]) {
            case Vgo:
                if(g)
                    gbranch(OGOTO);
                i++;
                break;

            case Vamv:
                i += 3;
                if(i > VLEN) {
                    diag(l, "bad Vop");
                    return;
                }
                if(g)
                    args[c[i - 1]] = args[c[i - 2]];
                break;

            case Vzero:
                i += 2;
                if(i > VLEN) {
                    diag(l, "bad Vop");
                    return;
                }
                j = i - 1;
                goto op;

            case Vspazz:	// nasty hack to save a reg in SUB
//print("spazz\n");
                if(g) {
//print("hi %R lo %R t %R\n", r->right->reg, r->left->reg, tmps[0].reg);
                    ot = r->right;
                    r->right = r->left;
                    tl = new(0, Z, Z);
                    *tl = tmps[0];
                    r->left = tl;
                    tmps[0] = *ot;
//print("hi %R lo %R t %R\n", r->right->reg, r->left->reg, tmps[0].reg);
                }
                i++;
                break;

            case Vmv:
            case Vmul:
            case Vshll:
                i += 3;
                if(i > VLEN) {
                    diag(l, "bad Vop");
                    return;
                }
                j = i - 2;
                goto op;

            case Vins0:
                i += 2;
                if(i > VLEN) {
                    diag(l, "bad Vop");
                    return;
                }
                gins(c[i - 1], Z, Z);
                break;

            case Vop:
            case Vopx:
            case Vins:
            case Vinsl:
            case Vinsr:
            case Vinsla:
            case Vinsra:
            case Vinsx:
                i += 4;
                if(i > VLEN) {
                    diag(l, "bad Vop");
                    return;
                }
                j = i - 2;
                goto op;

            op:
                if(!g)
                    break;
                tl = Z;
                tr = Z;
                for(; j < i; j++) {
                    switch(c[j]) {
                    case C00:
                        ot = nodconst(0);
                        break;
                    case C01:
                        ot = nodconst(1);
                        break;
                    case C31:
                        ot = nodconst(31);
                        break;
                    case C32:
                        ot = nodconst(32);
                        break;

                    case O_l:
                    case O_l_lo:
                        ot = l; xp = &lo; xo = 0;
                        goto op0;
                    case O_l_hi:
                        ot = l; xp = &lo; xo = SZ_LONG;
                        goto op0;
                    case O_r:
                    case O_r_lo:
                        ot = r; xp = &ro; xo = 0;
                        goto op0;
                    case O_r_hi:
                        ot = r; xp = &ro; xo = SZ_LONG;
                        goto op0;
                    case O_t_lo:
                        ot = t; xp = &to; xo = 0;
                        goto op0;
                    case O_t_hi:
                        ot = t; xp = &to; xo = SZ_LONG;
                        goto op0;
                    case O_l_rp:
                        ot = l;
                        break;
                    case O_r_rp:
                        ot = r;
                        break;
                    case O_t_rp:
                        ot = t;
                        break;
                    case O_r0:
                    case O_r1:
                        ot = &tmps[c[j] - O_r0];
                        break;
                    case O_Zop:
                        ot = Z;
                        break;

                    op0:
                        switch(ot->op) {
                        case OCONST:
                            if(xo)
                                ot = hi64(ot);
                            else
                                ot = lo64(ot);
                            break;
                        case OREGPAIR:
                            if(xo)
                                ot = ot->right;
                            else
                                ot = ot->left;
                            break;
                        case OREGISTER:
                            break;
                        default:
                            if(xo != *xp) {
                                ot->xoffset += xo - *xp;
                                *xp = xo;
                            }
                        }
                        break;
                    
                    default:
                        diag(l, "bad V_lop");
                        return;
                    }
                    if(tl == nil)
                        tl = ot;
                    else
                        tr = ot;
                }
                if(op == Vzero) {
                    zeroregm(tl);
                    break;
                }
                oc = c[i - 3];
                if(op == Vinsx || op == Vopx) {
//print("%d -> %d\n", oc, args[oc]);
                    oc = args[oc];
                }
                else {
                    switch(oc) {
                    case O_a0:
                    case O_a1:
                        oc = args[oc - O_a0];
                        break;
                    }
                }
                switch(op) {
                case Vmul:
                    mulgen(tr->type, tl, tr);
                    break;
                case Vmv:
                    gmove(tl, tr);
                    break;
                case Vshll:
                    shiftit(tr->type, tl, tr);
                    break;
                case Vop:
                case Vopx:
                    gopcode(oc, types[TULONG], tl, tr);
                    break;
                case Vins:
                case Vinsx:
                    gins(oc, tl, tr);
                    break;
                case Vinsl:
                    gins(oc, tl, tr->right);
                    p->from.index = tr->left->reg;
                    break;
                case Vinsr:
                    gins(oc, tl, tr->left);
                    p->from.index = tr->right->reg;
                    break;
                case Vinsla:
                    gins(oc, tl, tr + 1);
                    p->from.index = tr->reg;
                    break;
                case Vinsra:
                    gins(oc, tl, tr);
                    p->from.index = (tr + 1)->reg;
                    break;
                }
                break;

            case VT:
                g = true;
                i++;
                break;
            case VF:
                g = !true;
                i++;
                break;

            case V_T0: case V_T1:
                g = args[op - V_T0];
                i++;
                break;

            case V_F0: case V_F1:
                g = !args[op - V_F0];
                i++;
                break;

            case V_C0: case V_C1:
                if(g)
                    args[op - V_C0] = 0;
                i++;
                break;

            case V_S0: case V_S1:
                if(g)
                    args[op - V_S0] = 1;
                i++;
                break;

            case V_l_lo_f:
                g = lo64v(l) == 0;
                i++;
                break;
            case V_l_hi_f:
                g = hi64v(l) == 0;
                i++;
                break;
            case V_l_lo_t:
                g = lo64v(l) != 0;
                i++;
                break;
            case V_l_hi_t:
                g = hi64v(l) != 0;
                i++;
                break;
            case V_l_lo_u:
                g = lo64v(l) >= 0;
                i++;
                break;
            case V_l_hi_u:
                g = hi64v(l) >= 0;
                i++;
                break;
            case V_r_lo_f:
                g = lo64v(r) == 0;
                i++;
                break;
            case V_r_hi_f:
                g = hi64v(r) == 0;
                i++;
                break;
            case V_r_lo_t:
                g = lo64v(r) != 0;
                i++;
                break;
            case V_r_hi_t:
                g = hi64v(r) != 0;
                i++;
                break;
            case V_r_lo_u:
                g = lo64v(r) >= 0;
                i++;
                break;
            case V_r_hi_u:
                g = hi64v(r) >= 0;
                i++;
                break;

            case Vend:
                goto out;

            case V_a0: case V_a1:
                if(g) {
                    lt = l->type;
                    l->type = types[TULONG];
                    regalloc(&tmps[op - V_a0], l, Z);
                    l->type = lt;
                }
                i++;
                break;

            case V_f0: case V_f1:
                if(g)
                    regfree(&tmps[op - V_f0]);
                i++;
                break;

            case V_p0: case V_p1: case V_p2: case V_p3: case V_p4:
                if(g)
                    patch(pr[op - V_p0], pc);
                i++;
                break;

            case V_s0: case V_s1: case V_s2: case V_s3: case V_s4:
                if(g)
                    pr[op - V_s0] = p;
                i++;
                break;

            default:
                diag(l, "bad biggen: %d", op);
                return;
            }
            if(i == VLEN || c[i] == 0)
                break;
        }
    }
out:
    if(lo)
        l->xoffset -= lo;
    if(ro)
        r->xoffset -= ro;
    if(to)
        t->xoffset -= to;
}
@

<<function [[IMM]](x86)>>=
#define	IMM(l, r)	((l) | ((r) << 1))
@

<<function [[WW]](x86)>>=
#define	WW(l, r)	((l) | ((r) << 2))
@

<<function [[cgen64]](x86)>>=
int
cgen64(Node *n, Node *nn)
{
    Type *dt;
    uchar *args, (*cp)[VLEN], (**optab)[VLEN];
    int li, ri, lri, dr, si, m, op, sh, cmp, true;
    Node *c, *d, *l, *r, *t, *s, nod1, nod2, nod3, nod4, nod5;

    if(debug['g']) {
        prtree(nn, "cgen64 lhs");
        prtree(n, "cgen64");
        print("AX = %d\n", reg[D_AX]);
    }
    cmp = 0;
    sh = 0;

    switch(n->op) {
    case ONEG:
        d = regpair(nn, n);
        sugen(n->left, d, 8);
        gins(ANOTL, Z, d->right);
        gins(ANEGL, Z, d->left);
        gins(ASBBL, nodconst(-1), d->right);
        break;

    case OCOM:
        if(!vaddr(n->left, 0) || !vaddr(nn, 0))
            d = regpair(nn, n);
        else
            return 0;
        sugen(n->left, d, 8);
        gins(ANOTL, Z, d->left);
        gins(ANOTL, Z, d->right);
        break;

    case OADD:
        optab = ADDtab;
        args = ADDargs;
        goto twoop;
    case OAND:
        optab = ANDtab;
        args = ANDargs;
        goto twoop;
    case OOR:
        optab = ORtab;
        args = ORargs;
        goto twoop;
    case OSUB:
        optab = SUBtab;
        args = SUBargs;
        goto twoop;
    case OXOR:
        optab = ORtab;
        args = XORargs;
        goto twoop;
    case OASHL:
        sh = 1;
        args = nil;
        optab = shlltab;
        goto twoop;
    case OLSHR:
        sh = 1;
        args = shrlargs;
        optab = shrltab;
        goto twoop;
    case OASHR:
        sh = 1;
        args = sarlargs;
        optab = shrltab;
        goto twoop;
    case OEQ:
        cmp = 1;
        args = nil;
        optab = nil;
        goto twoop;
    case ONE:
        cmp = 1;
        args = nil;
        optab = nil;
        goto twoop;
    case OLE:
        cmp = 1;
        args = nil;
        optab = nil;
        goto twoop;
    case OLT:
        cmp = 1;
        args = nil;
        optab = nil;
        goto twoop;
    case OGE:
        cmp = 1;
        args = nil;
        optab = nil;
        goto twoop;
    case OGT:
        cmp = 1;
        args = nil;
        optab = nil;
        goto twoop;
    case OHI:
        cmp = 1;
        args = nil;
        optab = nil;
        goto twoop;
    case OHS:
        cmp = 1;
        args = nil;
        optab = nil;
        goto twoop;
    case OLO:
        cmp = 1;
        args = nil;
        optab = nil;
        goto twoop;
    case OLS:
        cmp = 1;
        args = nil;
        optab = nil;
        goto twoop;

twoop:
        dr = nn != Z && nn->op == OREGPAIR;
        l = vfunc(n->left, nn);
        if(sh)
            r = n->right;
        else
            r = vfunc(n->right, nn);

        li = l->op == ONAME || l->op == OINDREG || l->op == OCONST;
        ri = r->op == ONAME || r->op == OINDREG || r->op == OCONST;


        lri = IMM(li, ri);

        /* find out what is so easy about some operands */
        if(li)
            li = whatof(l, sh | cmp);
        if(ri)
            ri = whatof(r, cmp);

        if(sh)
            goto shift;

        if(cmp)
            goto cmp;

        /* evaluate hard subexps, stealing nn if possible. */
        switch(lri) {
        case IMM(0, 0):
        bin00:
            if(l->complex > r->complex) {
                if(dr)
                    t = nn;
                else
                    t = regpair(Z, n);
                sugen(l, t, 8);
                l = t;
                t = regpair(Z, n);
                sugen(r, t, 8);
                r = t;
            }
            else {
                t = regpair(Z, n);
                sugen(r, t, 8);
                r = t;
                if(dr)
                    t = nn;
                else
                    t = regpair(Z, n);
                sugen(l, t, 8);
                l = t;
            }
            break;
        case IMM(0, 1):
            if(dr)
                t = nn;
            else
                t = regpair(Z, n);
            sugen(l, t, 8);
            l = t;
            break;
        case IMM(1, 0):
            if(n->op == OSUB && l->op == OCONST && hi64v(l) == 0) {
                lri = IMM(0, 0);
                goto bin00;
            }
            if(dr)
                t = nn;
            else
                t = regpair(Z, n);
            sugen(r, t, 8);
            r = t;
            break;
        case IMM(1, 1):
            break;
        }

        d = Z;
        dt = nn->type;
        nn->type = types[TLONG];

        switch(lri) {
        case IMM(0, 0):
            biggen(l, r, Z, 0, binop00, args);
            break;
        case IMM(0, 1):
            switch(ri) {
            case WNONE:
                diag(r, "bad whatof\n");
                break;
            case WCONST:
                biggen(l, r, Z, 0, optab[B0c], args);
                break;
            case WHARD:
                reglcgen(&nod2, r, Z);
                r = &nod2;
                /* fall thru */
            case WADDR:
                biggen(l, r, Z, 0, binoptmp, args);
                if(ri == WHARD)
                    regfree(r);
                break;
            }
            break;
        case IMM(1, 0):
            if(n->op == OSUB) {
                switch(li) {
                case WNONE:
                    diag(l, "bad whatof\n");
                    break;
                case WHARD:
                    reglcgen(&nod2, l, Z);
                    l = &nod2;
                    /* fall thru */
                case WADDR:
                case WCONST:
                    biggen(l, r, Z, 0, sub10, args);
                    break;
                }
                if(li == WHARD)
                    regfree(l);
            }
            else {
                switch(li) {
                case WNONE:
                    diag(l, "bad whatof\n");
                    break;
                case WCONST:
                    biggen(r, l, Z, 0, optab[B0c], args);
                    break;
                case WHARD:
                    reglcgen(&nod2, l, Z);
                    l = &nod2;
                    /* fall thru */
                case WADDR:
                    biggen(r, l, Z, 0, binoptmp, args);
                    if(li == WHARD)
                        regfree(l);
                    break;
                }
            }
            break;
        case IMM(1, 1):
            switch(WW(li, ri)) {
            case WW(WCONST, WHARD):
                if(r->op == ONAME && n->op == OAND && reduxv(l))
                    ri = WADDR;
                break;
            case WW(WHARD, WCONST):
                if(l->op == ONAME && n->op == OAND && reduxv(r))
                    li = WADDR;
                break;
            }
            if(li == WHARD) {
                reglcgen(&nod3, l, Z);
                l = &nod3;
            }
            if(ri == WHARD) {
                reglcgen(&nod2, r, Z);
                r = &nod2;
            }
            d = regpair(nn, n);
            instpair(d, Z);
            switch(WW(li, ri)) {
            case WW(WCONST, WADDR):
            case WW(WCONST, WHARD):
                biggen(l, r, d, 0, optab[Bca], args);
                break;

            case WW(WADDR, WCONST):
            case WW(WHARD, WCONST):
                biggen(l, r, d, 0, optab[Bac], args);
                break;

            case WW(WADDR, WADDR):
            case WW(WADDR, WHARD):
            case WW(WHARD, WADDR):
            case WW(WHARD, WHARD):
                biggen(l, r, d, 0, binop11, args);
                break;

            default:
                diag(r, "bad whatof pair %d %d\n", li, ri);
                break;
            }
            if(li == WHARD)
                regfree(l);
            if(ri == WHARD)
                regfree(r);
            break;
        }

        nn->type = dt;

        if(d != Z)
            goto finished;

        switch(lri) {
        case IMM(0, 0):
            freepair(r);
            /* fall thru */;
        case IMM(0, 1):
            if(!dr)
                storepair(l, nn, 1);
            break;
        case IMM(1, 0):
            if(!dr)
                storepair(r, nn, 1);
            break;
        case IMM(1, 1):
            break;
        }
        return 1;

    shift:
        c = Z;

        /* evaluate hard subexps, stealing nn if possible. */
        /* must also secure CX.  not as many optims as binop. */
        switch(lri) {
        case IMM(0, 0):
        imm00:
            if(l->complex + 1 > r->complex) {
                if(dr)
                    t = nn;
                else
                    t = regpair(Z, l);
                sugen(l, t, 8);
                l = t;
                t = &nod1;
                c = snarfreg(l, t, D_CX, r, &nod2);
                cgen(r, t);
                r = t;
            }
            else {
                t = &nod1;
                c = snarfreg(nn, t, D_CX, r, &nod2);
                cgen(r, t);
                r = t;
                if(dr)
                    t = nn;
                else
                    t = regpair(Z, l);
                sugen(l, t, 8);
                l = t;
            }
            break;
        case IMM(0, 1):
        imm01:
            if(ri != WCONST) {
                lri = IMM(0, 0);
                goto imm00;
            }
            if(dr)
                t = nn;
            else
                t = regpair(Z, n);
            sugen(l, t, 8);
            l = t;
            break;
        case IMM(1, 0):
        imm10:
            if(li != WCONST) {
                lri = IMM(0, 0);
                goto imm00;
            }
            t = &nod1;
            c = snarfreg(nn, t, D_CX, r, &nod2);
            cgen(r, t);
            r = t;
            break;
        case IMM(1, 1):
            if(ri != WCONST) {
                lri = IMM(1, 0);
                goto imm10;
            }
            if(li == WHARD) {
                lri = IMM(0, 1);
                goto imm01;
            }
            break;
        }

        d = Z;

        switch(lri) {
        case IMM(0, 0):
            biggen(l, r, Z, 0, optab[S00], args);
            break;
        case IMM(0, 1):
            switch(ri) {
            case WNONE:
            case WADDR:
            case WHARD:
                diag(r, "bad whatof\n");
                break;
            case WCONST:
                m = r->vconst & 63;
                s = nodconst(m);
                if(m < 32)
                    cp = optab[Sc0];
                else if(m == 32)
                    cp = optab[Sc1];
                else
                    cp = optab[Sc2];
                biggen(l, s, Z, 0, cp, args);
                break;
            }
            break;
        case IMM(1, 0):
            /* left is const */
            d = regpair(nn, n);
            instpair(d, Z);
            biggen(l, r, d, 0, optab[S10], args);
            regfree(r);
            break;
        case IMM(1, 1):
            d = regpair(nn, n);
            instpair(d, Z);
            switch(WW(li, ri)) {
            case WW(WADDR, WCONST):
                m = r->vconst & 63;
                s = nodconst(m);
                if(m < 32) {
                    loadpair(l, d);
                    l = d;
                    cp = optab[Sc0];
                }
                else if(m == 32)
                    cp = optab[Sac3];
                else
                    cp = optab[Sac4];
                biggen(l, s, d, 0, cp, args);
                break;

            default:
                diag(r, "bad whatof pair %d %d\n", li, ri);
                break;
            }
            break;
        }

        if(c != Z) {
            gins(AMOVL, c, r);
            regfree(c);
        }

        if(d != Z)
            goto finished;

        switch(lri) {
        case IMM(0, 0):
            regfree(r);
            /* fall thru */
        case IMM(0, 1):
            if(!dr)
                storepair(l, nn, 1);
            break;
        case IMM(1, 0):
            regfree(r);
            break;
        case IMM(1, 1):
            break;
        }
        return 1;

    cmp:
        op = n->op;
        /* evaluate hard subexps */
        switch(lri) {
        case IMM(0, 0):
            if(l->complex > r->complex) {
                t = regpair(Z, l);
                sugen(l, t, 8);
                l = t;
                t = regpair(Z, r);
                sugen(r, t, 8);
                r = t;
            }
            else {
                t = regpair(Z, r);
                sugen(r, t, 8);
                r = t;
                t = regpair(Z, l);
                sugen(l, t, 8);
                l = t;
            }
            break;
        case IMM(1, 0):
            t = r;
            r = l;
            l = t;
            ri = li;
            op = invrel[relindex(op)];
            /* fall thru */
        case IMM(0, 1):
            t = regpair(Z, l);
            sugen(l, t, 8);
            l = t;
            break;
        case IMM(1, 1):
            break;
        }

        true = 1;
        optab = cmptab;
        switch(op) {
        case OEQ:
            optab = NEtab;
            true = 0;
            break;
        case ONE:
            optab = NEtab;
            break;
        case OLE:
            args = GTargs;
            true = 0;
            break;
        case OGT:
            args = GTargs;
            break;
        case OLS:
            args = HIargs;
            true = 0;
            break;
        case OHI:
            args = HIargs;
            break;
        case OLT:
            args = GEargs;
            true = 0;
            break;
        case OGE:
            args = GEargs;
            break;
        case OLO:
            args = HSargs;
            true = 0;
            break;
        case OHS:
            args = HSargs;
            break;
        default:
            diag(n, "bad cmp\n");
            SET(optab);
        }

        switch(lri) {
        case IMM(0, 0):
            biggen(l, r, Z, true, optab[T0i], args);
            break;
        case IMM(0, 1):
        case IMM(1, 0):
            switch(ri) {
            case WNONE:
                diag(l, "bad whatof\n");
                break;
            case WCONST:
                biggen(l, r, Z, true, optab[T0i], args);
                break;
            case WHARD:
                reglcgen(&nod2, r, Z);
                r = &nod2;
                /* fall thru */
            case WADDR:
                biggen(l, r, Z, true, optab[T0i], args);
                if(ri == WHARD)
                    regfree(r);
                break;
            }
            break;
        case IMM(1, 1):
            if(li == WHARD) {
                reglcgen(&nod3, l, Z);
                l = &nod3;
            }
            if(ri == WHARD) {
                reglcgen(&nod2, r, Z);
                r = &nod2;
            }
            biggen(l, r, Z, true, optab[Tii], args);
            if(li == WHARD)
                regfree(l);
            if(ri == WHARD)
                regfree(r);
            break;
        }

        switch(lri) {
        case IMM(0, 0):
            freepair(r);
            /* fall thru */;
        case IMM(0, 1):
        case IMM(1, 0):
            freepair(l);
            break;
        case IMM(1, 1):
            break;
        }
        return 1;

    case OASMUL:
    case OASLMUL:
        m = 0;
        goto mulop;

    case OMUL:
    case OLMUL:
        m = 1;
        goto mulop;

    mulop:
        dr = nn != Z && nn->op == OREGPAIR;
        l = vfunc(n->left, nn);
        r = vfunc(n->right, nn);
        if(r->op != OCONST) {
            if(l->complex > r->complex) {
                if(m) {
                    t = l;
                    l = r;
                    r = t;
                }
                else if(!vaddr(l, 1)) {
                    reglcgen(&nod5, l, Z);
                    l = &nod5;
                    evacaxdx(l);
                }
            }
            t = regpair(Z, n);
            sugen(r, t, 8);
            r = t;
            evacaxdx(r->left);
            evacaxdx(r->right);
            if(l->complex <= r->complex && !m && !vaddr(l, 1)) {
                reglcgen(&nod5, l, Z);
                l = &nod5;
                evacaxdx(l);
            }
        }
        if(dr)
            t = nn;
        else
            t = regpair(Z, n);
        //print("dr=%d ", dr); prtree(t, "t");
        c = Z;
        d = Z;
        if(!nodreg(&nod1, t->left, D_AX)) {
            if(t->left->reg != D_AX){
                t->left->reg = D_AX;
                reg[D_AX]++;
            }else if(reg[D_AX] == 0)
                fatal(Z, "vlong mul AX botch");
        }
        if(!nodreg(&nod2, t->right, D_DX)) {
            if(t->right->reg != D_DX){
                t->right->reg = D_DX;
                reg[D_DX]++;
            }else if(reg[D_DX] == 0)
                fatal(Z, "vlong mul DX botch");
        }
        //prtree(t, "t1"); print("reg/ax = %d reg/dx = %d\n", reg[D_AX], reg[D_DX]);
        if(m)
            sugen(l, t, 8);
        else
            loadpair(l, t);
        //prtree(t, "t2"); print("reg/ax = %d reg/dx = %d\n", reg[D_AX], reg[D_DX]);
        if(t->left->reg != D_AX) {
            c = &nod3;
            regsalloc(c, t->left);
            gmove(&nod1, c);
            gmove(t->left, &nod1);
            zapreg(t->left);
        }
        //print("reg/ax = %d reg/dx = %d\n", reg[D_AX], reg[D_DX]);
        if(t->right->reg != D_DX) {
            d = &nod4;
            regsalloc(d, t->right);
            gmove(&nod2, d);
            if(t->right->reg == D_AX && c != nil){
                /* need previous value of AX in DX */
                gmove(c, &nod2);
            }else
                gmove(t->right, &nod2);
            zapreg(t->right);
        }
        if(c != Z || d != Z) {
            s = regpair(Z, n);
            s->left = &nod1;
            s->right = &nod2;
        }
        else
            s = t;
        reg[D_AX]++;	/* don't allow biggen to allocate AX or DX (smashed by MUL) as temp */
        reg[D_DX]++;
        if(r->op == OCONST) {
            if(hi64v(r) == 0)
                biggen(s, r, Z, 0, mulc32, nil);
            else
                biggen(s, r, Z, 0, mulc64, nil);
        }
        else
            biggen(s, r, Z, 0, mull, nil);
        instpair(t, Z);
        reg[D_AX]--;
        reg[D_DX]--;
        if(c != Z) {
            gmove(&nod1, t->left);
            gmove(&nod3, &nod1);
        }
        if(d != Z) {
            gmove(&nod2, t->right);
            gmove(&nod4, &nod2);
        }

        if(r->op == OREGPAIR)
            freepair(r);
        if(!m)
            storepair(t, l, 0);
        if(l == &nod5)
            regfree(l);

        if(!dr) {
            if(nn != Z)
                storepair(t, nn, 1);
            else
                freepair(t);
        }
        return 1;

    case OASADD:
        args = ADDargs;
        goto vasop;
    case OASAND:
        args = ANDargs;
        goto vasop;
    case OASOR:
        args = ORargs;
        goto vasop;
    case OASSUB:
        args = SUBargs;
        goto vasop;
    case OASXOR:
        args = XORargs;
        goto vasop;

    vasop:
        l = n->left;
        r = n->right;
        dr = nn != Z && nn->op == OREGPAIR;
        m = 0;
        if(l->complex > r->complex) {
            if(!vaddr(l, 1)) {
                reglcgen(&nod1, l, Z);
                l = &nod1;
            }
            if(!vaddr(r, 1) || nn != Z || r->op == OCONST) {
                if(dr)
                    t = nn;
                else
                    t = regpair(Z, r);
                sugen(r, t, 8);
                r = t;
                m = 1;
            }
        }
        else {
            if(!vaddr(r, 1) || nn != Z || r->op == OCONST) {
                if(dr)
                    t = nn;
                else
                    t = regpair(Z, r);
                sugen(r, t, 8);
                r = t;
                m = 1;
            }
            if(!vaddr(l, 1)) {
                reglcgen(&nod1, l, Z);
                l = &nod1;
            }
        }
        if(nn != Z) {
            if(n->op == OASSUB)
                biggen(l, r, Z, 0, sub10, args);
            else
                biggen(r, l, Z, 0, binoptmp, args);
            storepair(r, l, 0);
        }
        else {
            if(m)
                biggen(l, r, Z, 0, binop00, args);
            else
                biggen(l, r, Z, 0, binoptmp, args);
        }
        if(l == &nod1)
            regfree(&nod1);
        if(m) {
            if(nn == Z)
                freepair(r);
            else if(!dr)
                storepair(r, nn, 1);
        }
        return 1;

    case OASASHL:
        args = nil;
        optab = asshlltab;
        goto assh;
    case OASLSHR:
        args = shrlargs;
        optab = asshrltab;
        goto assh;
    case OASASHR:
        args = sarlargs;
        optab = asshrltab;
        goto assh;

    assh:
        c = Z;
        l = n->left;
        r = n->right;
        if(r->op == OCONST) {
            m = r->vconst & 63;
            if(m < 32)
                m = SAclo;
            else if(m == 32)
                m = SAc32;
            else
                m = SAchi;
        }
        else
            m = SAgen;
        if(l->complex > r->complex) {
            if(!vaddr(l, 0)) {
                reglcgen(&nod1, l, Z);
                l = &nod1;
            }
            if(m == SAgen) {
                t = &nod2;
                if(l->reg == D_CX) {
                    regalloc(t, r, Z);
                    gmove(l, t);
                    l->reg = t->reg;
                    t->reg = D_CX;
                }
                else
                    c = snarfreg(nn, t, D_CX, r, &nod3);
                cgen(r, t);
                r = t;
            }
        }
        else {
            if(m == SAgen) {
                t = &nod2;
                c = snarfreg(nn, t, D_CX, r, &nod3);
                cgen(r, t);
                r = t;
            }
            if(!vaddr(l, 0)) {
                reglcgen(&nod1, l, Z);
                l = &nod1;
            }
        }

        if(nn != Z) {
            m += SAdgen - SAgen;
            d = regpair(nn, n);
            instpair(d, Z);
            biggen(l, r, d, 0, optab[m], args);
            if(l == &nod1) {
                regfree(&nod1);
                l = Z;
            }
            if(r == &nod2 && c == Z) {
                regfree(&nod2);
                r = Z;
            }
            if(d != nn)
                storepair(d, nn, 1);
        }
        else
            biggen(l, r, Z, 0, optab[m], args);

        if(c != Z) {
            gins(AMOVL, c, r);
            regfree(c);
        }
        if(l == &nod1)
            regfree(&nod1);
        if(r == &nod2)
            regfree(&nod2);
        return 1;

    case OPOSTINC:
        args = ADDargs;
        cp = incdecpost;
        goto vinc;
    case OPOSTDEC:
        args = SUBargs;
        cp = incdecpost;
        goto vinc;
    case OPREINC:
        args = ADDargs;
        cp = incdecpre;
        goto vinc;
    case OPREDEC:
        args = SUBargs;
        cp = incdecpre;
        goto vinc;

    vinc:
        l = n->left;
        if(!vaddr(l, 1)) {
            reglcgen(&nod1, l, Z);
            l = &nod1;
        }
        
        if(nn != Z) {
            d = regpair(nn, n);
            instpair(d, Z);
            biggen(l, Z, d, 0, cp, args);
            if(l == &nod1) {
                regfree(&nod1);
                l = Z;
            }
            if(d != nn)
                storepair(d, nn, 1);
        }
        else
            biggen(l, Z, Z, 0, incdec, args);

        if(l == &nod1)
            regfree(&nod1);
        return 1;

    case OCAST:
        l = n->left;
        if(typev[l->type->etype]) {
            if(!vaddr(l, 1)) {
                if(l->complex + 1 > nn->complex) {
                    d = regpair(Z, l);
                    sugen(l, d, 8);
                    if(!vaddr(nn, 1)) {
                        reglcgen(&nod1, nn, Z);
                        r = &nod1;
                    }
                    else
                        r = nn;
                }
                else {
                    if(!vaddr(nn, 1)) {
                        reglcgen(&nod1, nn, Z);
                        r = &nod1;
                    }
                    else
                        r = nn;
                    d = regpair(Z, l);
                    sugen(l, d, 8);
                }
//				d->left->type = r->type;
                d->left->type = types[TLONG];
                gmove(d->left, r);
                freepair(d);
            }
            else {
                if(nn->op != OREGISTER && !vaddr(nn, 1)) {
                    reglcgen(&nod1, nn, Z);
                    r = &nod1;
                }
                else
                    r = nn;
//				l->type = r->type;
                l->type = types[TLONG];
                gmove(l, r);
            }
            if(r != nn)
                regfree(r);
        }
        else {
            if(typeu[l->type->etype] || cond(l->op))
                si = TUNSIGNED;
            else
                si = TSIGNED;
            regalloc(&nod1, l, Z);
            cgen(l, &nod1);
            if(nn->op == OREGPAIR) {
                m = instpair(nn, &nod1);
                biggen(&nod1, Z, nn, si == TSIGNED, castrp, nil);
            }
            else {
                m = 0;
                if(!vaddr(nn, si != TSIGNED)) {
                    dt = nn->type;
                    nn->type = types[TLONG];
                    reglcgen(&nod2, nn, Z);
                    nn->type = dt;
                    nn = &nod2;
                }
                dt = nn->type;
                nn->type = types[TLONG];
                biggen(&nod1, Z, nn, si == TSIGNED, castrpa, nil);
                nn->type = dt;
                if(nn == &nod2)
                    regfree(&nod2);
            }
            if(!m)
                regfree(&nod1);
        }
        return 1;

    default:
        if(n->op == OREGPAIR) {
            storepair(n, nn, 1);
            return 1;
        }
        if(nn->op == OREGPAIR) {
            loadpair(n, nn);
            return 1;
        }
        return 0;
    }
finished:
    if(d != nn)
        storepair(d, nn, 1);
    return 1;
}
@

<<function [[testv]](x86)>>=
void
testv(Node *n, int true)
{
    Type *t;
    Node *nn, nod, *b;

    if(machcap(Z)) {
        b = &nod;
        b->op = true ? ONE : OEQ;
        b->left = n;
        b->right = new(0, Z, Z);
        *b->right = *nodconst(0);
        b->right->type = n->type;
        b->type = types[TLONG];
        cgen64(b, Z);
        return;
    }

    switch(n->op) {
    case OINDREG:
    case ONAME:
        biggen(n, Z, Z, true, testi, nil);
        break;

    default:
        n = vfunc(n, n);
        if(n->addable >= INDEXED) {
            t = n->type;
            n->type = types[TLONG];
            reglcgen(&nod, n, Z);
            n->type = t;
            n = &nod;
            biggen(n, Z, Z, true, testi, nil);
            if(n == &nod)
                regfree(n);
        }
        else {
            nn = regpair(Z, n);
            sugen(n, nn, 8);
            biggen(nn, Z, Z, true, testi, nil);
            freepair(nn);
        }
    }
}
@



<<function [[listinit]](x86)>>=
void
listinit(void)
{

    fmtinstall('A', Aconv);
    fmtinstall('B', Bconv);
    fmtinstall('P', Pconv);
    fmtinstall('S', Sconv);
    fmtinstall('D', Dconv);
    fmtinstall('R', Rconv);
}
@

% for assembly generation?
<<function [[Pconv]](x86)>>=
// Prog -> string
int
Pconv(Fmt *fp)
{
    char str[STRINGSZ];
    Prog *p;

    p = va_arg(fp->args, Prog*);
    if(p->as == ADATA)
        snprint(str, sizeof(str), "	%A	%D/%d,%D",
            p->as, &p->from, p->from.scale, &p->to);
    else if(p->as == ATEXT)
        snprint(str, sizeof(str), "	%A	%D,%d,%D",
            p->as, &p->from, p->from.scale, &p->to);
    else
        snprint(str, sizeof(str), "	%A	%D,%D",
            p->as, &p->from, &p->to);
    return fmtstrcpy(fp, str);
}
@
% why not switch?




<<function [[Dconv]](x86)>>=
// Adr -> string
int
Dconv(Fmt *fp)
{
    char str[40], s[20];
    Adr *a;
    int i;

    a = va_arg(fp->args, Adr*);
    i = a->type;
    if(i >= D_INDIR) {
        if(a->offset)
            snprint(str, sizeof(str), "%ld(%R)", a->offset, i-D_INDIR);
        else
            snprint(str, sizeof(str), "(%R)", i-D_INDIR);
        goto brk;
    }
    switch(i) {

    default:
        if(a->offset)
            snprint(str, sizeof(str), "$%ld,%R", a->offset, i); // $
        else
            snprint(str, sizeof(str), "%R", i);
        break;

    case D_NONE:
        str[0] = '\0';
        break;

    case D_BRANCH:
        snprint(str, sizeof(str), "%ld(PC)", a->offset-pc);
        break;

    case D_EXTERN:
        snprint(str, sizeof(str), "%s+%ld(SB)", a->sym->name, a->offset);
        break;

    case D_STATIC:
        snprint(str, sizeof(str), "%s<>+%ld(SB)", a->sym->name, a->offset);
        break;

    case D_AUTO:
        snprint(str, sizeof(str), "%s+%ld(SP)", a->sym->name, a->offset);
        break;

    case D_PARAM:
        if(a->sym)
            snprint(str, sizeof(str), "%s+%ld(FP)", a->sym->name, a->offset);
        else
            snprint(str, sizeof(str), "%ld(FP)", a->offset);
        break;


    case D_CONST:
        snprint(str, sizeof(str), "$%ld", a->offset); //$
        break;

    case D_FCONST:
        snprint(str, sizeof(str), "$(%.17e)", a->dval); //$
        break;

    case D_SCONST:
        snprint(str, sizeof(str), "$\"%S\"", a->sval); //$
        break;


    case D_ADDR:
        a->type = a->index;
        a->index = D_NONE;
        snprint(str, sizeof(str), "$%D", a); //$
        a->index = a->type;
        a->type = D_ADDR;
        goto conv;
    }
brk:
    if(a->index != D_NONE) {
        fmtstrcpy(fp, str);
        snprint(s, sizeof(s), "(%R*%d)", (int)a->index, (int)a->scale);
        return fmtstrcpy(fp, s);
    }
conv:
    return fmtstrcpy(fp, str);
}
@

<<global [[regstr]](x86)>>=
char*	regstr[] =
{
    "AL",	/*[D_AL]*/	
    "CL",
    "DL",
    "BL",
    "AH",
    "CH",
    "DH",
    "BH",

    "AX",	/*[D_AX]*/
    "CX",
    "DX",
    "BX",
    "SP",
    "BP",
    "SI",
    "DI",

    "F0",	/*[D_F0]*/
    "F1",
    "F2",
    "F3",
    "F4",
    "F5",
    "F6",
    "F7",

    "CS",	/*[D_CS]*/
    "SS",
    "DS",
    "ES",
    "FS",
    "GS",

    "GDTR",	/*[D_GDTR]*/
    "IDTR",	/*[D_IDTR]*/
    "LDTR",	/*[D_LDTR]*/
    "MSW",	/*[D_MSW] */
    "TASK",	/*[D_TASK]*/

    "CR0",	/*[D_CR]*/
    "CR1",
    "CR2",
    "CR3",
    "CR4",
    "CR5",
    "CR6",
    "CR7",

    "DR0",	/*[D_DR]*/
    "DR1",
    "DR2",
    "DR3",
    "DR4",
    "DR5",
    "DR6",
    "DR7",

    "TR0",	/*[D_TR]*/
    "TR1",
    "TR2",
    "TR3",
    "TR4",
    "TR5",
    "TR6",
    "TR7",

    "NONE",	/*[D_NONE]*/
};
@

<<function [[Rconv]](x86)>>=
// enum<operand_kind(register-only)> -> string
int
Rconv(Fmt *fp)
{
    char str[20];
    int r;

    r = va_arg(fp->args, int);
    if(r >= D_AL && r <= D_NONE)
        snprint(str, sizeof(str), "%s", regstr[r-D_AL]);
    else
        snprint(str, sizeof(str), "gok(%d)", r);

    return fmtstrcpy(fp, str);
}
@

<<function [[Sconv]](x86)>>=
// ?? -> string
int
Sconv(Fmt *fp)
{
    int i, c;
    char str[30], *p, *a;

    a = va_arg(fp->args, char*);
    p = str;
    for(i=0; i<sizeof(double); i++) {
        c = a[i] & 0xff;
        if(c >= 'a' && c <= 'z' ||
           c >= 'A' && c <= 'Z' ||
           c >= '0' && c <= '9') {
            *p++ = c;
            continue;
        }
        *p++ = '\\';
        switch(c) {
        default:
            if(c < 040 || c >= 0177)
                break;	/* not portable */
            p[-1] = c;
            continue;
        case 0:
            *p++ = 'z';
            continue;
        case '\\':
        case '"':
            *p++ = c;
            continue;
        case '\n':
            *p++ = 'n';
            continue;
        case '\t':
            *p++ = 't';
            continue;
        }
        *p++ = (c>>6) + '0';
        *p++ = ((c>>3) & 7) + '0';
        *p++ = (c & 7) + '0';
    }
    *p = 0;
    return fmtstrcpy(fp, str);
}
@

<<global [[typechlv]]>>=
char	typechlv[NTYPE];
@
% comes from a few xxxinit,


<<function [[machcap]](x86)>>=
bool
machcap(Node *n)
{
//	return false;

    if(n == Z)
        return true;	/* test */

    switch(n->op) {
    case OMUL:
    case OLMUL:
    case OASMUL:
    case OASLMUL:
        if(typechl[n->type->etype])
            return true;
        if(typev[n->type->etype]) {
//		if(typev[n->type->etype] && n->right->op == OCONST) {
//			if(hi64v(n->right) == 0)
                return true;
        }
        break;

    case OCOM:
    case ONEG:
    case OADD:
    case OAND:
    case OOR:
    case OSUB:
    case OXOR:
    case OASHL:
    case OLSHR:
    case OASHR:
        if(typechlv[n->left->type->etype])
            return true;
        break;

    case OCAST:
        if(typev[n->type->etype]) {
            if(typechlp[n->left->type->etype])
                return true;
        }
        else if(!typefd[n->type->etype]) {
            if(typev[n->left->type->etype])
                return true;
        }
        break;

    case OCOND:
    case OCOMMA:
    case OLIST:
    case OANDAND:
    case OOROR:
    case ONOT:
    case ODOT:
        return true;

    case OASADD:
    case OASSUB:
    case OASAND:
    case OASOR:
    case OASXOR:
        return true;

    case OASASHL:
    case OASASHR:
    case OASLSHR:
        return true;

    case OPOSTINC:
    case OPOSTDEC:
    case OPREINC:
    case OPREDEC:
        return true;

    case OEQ:
    case ONE:
    case OLE:
    case OGT:
    case OLT:
    case OGE:
    case OHI:
    case OHS:
    case OLO:
    case OLS:
//print("%O\n", n->op);
        return true;
    }
    return false;
}
@

\section{[[8c/]]}

\subsection*{[[8c/gc.h]]}


<<constant FNX (8c/gc.h)>>=
#define	FNX		100
@

<<struct [[Idx]](x86)>>=
struct Idx
{
    Node*	regtree;
    Node*	basetree;
    short	scale;
    short	reg;
    short	ptr;
};
@


<<constant [[INDEXED]](x86)>>=
#define	INDEXED	9
@



<<constant [[NRGN]](x86)>>=
#define	NRGN	600
@



<<function [[LOAD]](x86)>>=
#define	LOAD(r)		(~r->refbehind.b[z] & r->refahead.b[z])
@

<<function [[STORE]](x86)>>=
#define	STORE(r)	(~r->calbehind.b[z] & r->calahead.b[z])
@

<<macro [[bset]](x86)>>=
//@Scheck: maybe dead, dupe with bits.c function
#define	bset(a,n)	((a).b[(n)/32]&(1L<<(n)%32))
@

<<constant [[CLOAD]](x86)>>=
#define	CLOAD	5
@

<<constant [[CREF]](x86)>>=
#define	CREF	5
@

<<constant [[CINF]](x86)>>=
#define	CINF	1000
@

<<constant [[LOOP]](x86)>>=
#define	LOOP	3
@

<<constant [[D_HI]](x86)>>=
//#define	D_HI	D_NONE
@

<<constant [[D_LO]](x86)>>=
//#define	D_LO	D_NONE
@

<<constant [[rplink]]>>=
/* wrecklessly steal a field */

#define	rplink	label
@

%<<function BLOAD>>=
%//#define	BLOAD(r)	band(bnot(r->refbehind), r->refahead)
%@
%
%<<function BSTORE>>=
%//#define	BSTORE(r)	band(bnot(r->calbehind), r->calahead)
%@


%-------------------------------------------------------------

<<8c/gc.h>>=
#include	"../cc/cc.h"

#include	<common.out.h>
#include	<386/8.out.h>

/*
 * 8c/386
 * Intel 386
 */

<<constant [[SZ_CHAR]](x86)>>
<<constant [[SZ_SHORT]](x86)>>
<<constant [[SZ_INT]](x86)>>
<<constant [[SZ_LONG]](x86)>>
<<constant [[SZ_IND]](x86)>>
<<constant [[SZ_FLOAT]](x86)>>
<<constant [[SZ_VLONG]](x86)>>
<<constant [[SZ_DOUBLE]](x86)>>
<<constant FNX (8c/gc.h)>>

typedef	struct	Adr	Adr;
typedef	struct	Prog	Prog;
typedef	struct	Case	Case;
typedef	struct	C1	C1;
typedef	struct	Var	Var;
typedef	struct	Reg	Reg;
typedef	struct	Rgn	Rgn;

<<struct [[Idx]](x86)>>
extern struct Idx idx;

<<struct [[Adr]](x86)>>
<<constant [[A]]>>

<<constant [[INDEXED]](x86)>>
<<struct [[Prog]](x86)>>
<<constant [[P]]>>

<<struct [[Case]]>>
<<constant [[C]]>>

<<struct [[C1]]>>

<<struct [[Var]]>>

<<struct [[Reg]]>>
<<constant [[R]]>>

<<constant [[NRGN]](x86)>>
<<struct [[Rgn]]>>

extern	long	breakpc;
extern	long	nbreak;
extern	Case*	cases;
extern	Node	constnode;
extern	Node	fconstnode;
extern	long	continpc;
extern	long	curarg;
extern	long	cursafe;
extern	Prog*	firstp;
extern	Prog*	lastp;
extern	long	maxargsafe;
extern	int	mnstring;
extern	Node*	nodrat;
extern	Node*	nodret;
extern	Node*	nodsafe;
extern	long	nrathole;
extern	long	nstring;
extern	Prog*	p;
extern	long	pc;
extern	Node	regnode;
extern	Node	fregnode0;
extern	Node	fregnode1;
extern	char	string[NSNAME];
extern	Sym*	symrathole;
extern	Node	znode;
extern	Prog	zprog;
extern	int	reg[D_NONE];
extern	long	exregoffset;
extern	long	exfregoffset;

<<function [[LOAD]](x86)>>
<<function [[STORE]](x86)>>

<<macro [[bset]](x86)>>

<<constant [[CLOAD]](x86)>>
<<constant [[CREF]](x86)>>
<<constant [[CINF]](x86)>>
<<constant [[LOOP]](x86)>>

extern	Rgn	region[NRGN];
extern	Rgn*	rgp;
extern	int	nregion;
extern	int	nvar;

extern	Bits	externs;
extern	Bits	params;
extern	Bits	consts;
extern	Bits	addrs;

extern	long	regbits;
//extern	long	exregbits;

extern	int	change;
extern	int	suppress;

extern	Reg*	firstr;
extern	Reg*	lastr;
extern	Reg	zreg;
extern	Reg*	freer;
extern	Var	var[NVAR];
extern	long*	idom;
extern	Reg**	rpo2r;
extern	long	maxnr;

extern	char*	anames[];

/*
 * sgen.c
 */
void	codgen(Node*, Node*);
void	noretval(int);
void	xcom(Node*);

/*
 * cgen.c
 */
void	zeroregm(Node*);
void	cgen(Node*, Node*);
void	reglcgen(Node*, Node*, Node*);
void	lcgen(Node*, Node*);
void	boolgen(Node*, int, Node*);
void	sugen(Node*, Node*, long);
//int	needreg(Node*, int);

/*
 * cgen64.c
 */
int	vaddr(Node*, int);
void	loadpair(Node*, Node*);
int	cgen64(Node*, Node*);
void	testv(Node*, int);
Node*	hi64(Node*);
Node*	lo64(Node*);

/*
 * txt.c
 */
void	ginit(void);
void	gclean(void);
void	gargs(Node*, Node*, Node*);
Node*	nodconst(long);
int	nareg(int);
int	nodreg(Node*, Node*, int);
int	isreg(Node*, int);
void	regret(Node*, Node*);
void	regalloc(Node*, Node*, Node*);
void	regfree(Node*);
void	regialloc(Node*, Node*, Node*);
void	regsalloc(Node*, Node*);
void	regind(Node*, Node*);
void	gmove(Node*, Node*);
void	gins(int a, Node*, Node*);
void	fgopcode(int, Node*, Node*, int, int);
void	gopcode(int, Type*, Node*, Node*);
void	gbranch(int);
void	patch(Prog*, long);
int	sconst(Node*);
void	gpseudo(int, Sym*, Node*);
//void	gprep(Node*, Node*);

/*
 * swt.c
 */
void	doswit(Node*);
void	swit1(C1*, int, long, Node*);
void	casf(void);
void	bitload(Node*, Node*, Node*, Node*, Node*);
void	bitstore(Node*, Node*, Node*, Node*, Node*);
long	outstring(char*, long);
void	nullwarn(Node*, Node*);
void	gextern(Sym*, Node*, long, long);
void	outcode(void);
void	ieeedtod(Ieee*, double);

/*
 * list
 */
void	listinit(void);

/*
 * reg.c
 */
Reg*	rega(void);
void	regopt(Prog*);


/*
 * peep.c
 */
void	peep(void);
void	excise(Reg*);
int	copyu(Prog*, Adr*, Adr*);



<<constant [[D_HI]](x86)>>
<<constant [[D_LO]](x86)>>

/*
 * com64
 */
int	cond(int);
int	com64(Node*);
void	com64init(void);
void	bool64(Node*);

/*
 * div/mul
 */
void	sdivgen(Node*, Node*, Node*, Node*);
void	udivgen(Node*, Node*, Node*, Node*);
void	sdiv2(long, int, Node*, Node*);
void	smod2(long, int, Node*, Node*);
void	mulgen(Type*, Node*, Node*);
void	genmuladd(Node*, Node*, int, Node*);
void	shiftit(Type*, Node*, Node*);

#pragma	varargck	type	"A"	int
#pragma	varargck	type	"B"	Bits
#pragma	varargck	type	"D"	Adr*
#pragma	varargck	type	"P"	Prog*
#pragma	varargck	type	"R"	int
#pragma	varargck	type	"S"	char*

@


\subsection*{[[8c/globals2.c]]}

<<global [[idx]](x86)>>=
struct Idx idx;
@

<<global [[fregnode0]](x86)>>=
Node	fregnode0;
@

<<global [[fregnode1]](x86)>>=
Node	fregnode1;
@


<<global [[reg]](x86)>>=
int	reg[D_NONE];
@


%-------------------------------------------------------------

<<8c/globals2.c>>=
#include "gc.h"

<<global [[idx]](x86)>>
<<global [[fregnode0]](x86)>>
<<global [[fregnode1]](x86)>>
<<global [[reg]](x86)>>

<<global [[breakpc]]>>
<<global [[nbreak]]>>
<<global [[cases]]>>
<<global [[constnode]]>>
<<global [[fconstnode]]>>
<<global [[continpc]]>>
<<global [[curarg]]>>
<<global [[cursafe]]>>
<<global [[firstp]]>>
<<global [[lastp]]>>
<<global [[maxargsafe]]>>
<<global [[mnstring]]>>
<<global [[nodrat]]>>
<<global [[nodret]]>>
<<global [[nodsafe]]>>
<<global [[nrathole]]>>
<<global [[nstring]]>>
<<global [[p]]>>
<<global [[pc]]>>
<<global [[regnode]]>>
<<global [[string]]>>
<<global [[symrathole]]>>
<<global [[znode]]>>
<<global [[zprog]]>>
<<global [[exregoffset]]>>
<<global [[exfregoffset]]>>

<<global [[region]]>>
<<global [[rgp]]>>
<<global [[nregion]]>>

<<global [[externs]]>>
<<global [[params]]>>
<<global [[consts]]>>
<<global [[addrs]]>>

<<global [[regbits]]>>
<<global [[exregbits]]>>

<<global [[change]]>>
<<global [[suppress]]>>

<<global [[firstr]]>>
<<global [[lastr]]>>
<<global [[zreg]]>>
<<global [[freer]]>>
<<global [[var]]>>
<<global [[nvar]]>>

<<global [[idom]]>>
<<global [[rpo2r]]>>
<<global [[maxnr]]>>
@


\subsection*{[[8c/machcap.c]]}


%-------------------------------------------------------------

<<8c/machcap.c>>=
#include "gc.h"

<<function [[machcap]](x86)>>
@


\subsection*{[[8c/enam.c]]}

%-------------------------------------------------------------

<<8c/enam.c>>=
<<global [[anames]](x86)>>
@


\subsection*{[[8c/list.c]]}

%-------------------------------------------------------------

<<8c/list.c>>=
#include "gc.h"

int	Pconv(Fmt*);
int	Aconv(Fmt*);
int	Dconv(Fmt*);
int	Sconv(Fmt*);
int	Rconv(Fmt*);
int	Bconv(Fmt*);

<<function [[listinit]](x86)>>

<<function [[Bconv]]>>

<<function [[Pconv]](x86)>>

<<function [[Aconv]]>>

<<function [[Dconv]](x86)>>

<<global [[regstr]](x86)>>

<<function [[Rconv]](x86)>>

<<function [[Sconv]](x86)>>
@


\subsection*{[[8c/txt.c]]}

<<function [[ginit]](x86)>>=
void
ginit(void)
{
    int i;
    Type *t;

    thechar = '8';
    thestring = "386";

    exregoffset = 0;
    exfregoffset = 0;
    listinit();

    nstring = 0;
    mnstring = 0;
    nrathole = 0;
    pc = 0;
    breakpc = -1;
    continpc = -1;
    cases = C;
    firstp = P;
    lastp = P;
    tfield = types[TLONG];

    typeswitch = typechlv;

    zprog.link = P;
    zprog.as = AGOK;
    zprog.from.type = D_NONE;
    zprog.from.index = D_NONE;
    zprog.from.scale = 0;
    zprog.to = zprog.from;

    regnode.op = OREGISTER;
    regnode.class = CEXREG;
    regnode.reg = REGTMP;
    regnode.complex = 0;
    regnode.addable = 11;
    regnode.type = types[TLONG];

    fregnode0 = regnode;
    fregnode0.reg = D_F0;
    fregnode0.type = types[TDOUBLE];

    fregnode1 = fregnode0;
    fregnode1.reg = D_F0+1;

    constnode.op = OCONST;
    constnode.class = CXXX;
    constnode.complex = 0;
    constnode.addable = 20;
    constnode.type = types[TLONG];

    fconstnode.op = OCONST;
    fconstnode.class = CXXX;
    fconstnode.complex = 0;
    fconstnode.addable = 20;
    fconstnode.type = types[TDOUBLE];

    nodsafe = new(ONAME, Z, Z);
    nodsafe->sym = slookup(".safe");
    nodsafe->type = types[TINT];
    nodsafe->etype = types[TINT]->etype;
    nodsafe->class = CAUTO;
    complex(nodsafe);

    t = typ(TARRAY, types[TCHAR]);
    symrathole = slookup(".rathole");
    symrathole->class = CGLOBL;
    symrathole->type = t;

    nodrat = new(ONAME, Z, Z);
    nodrat->sym = symrathole;
    nodrat->type = types[TIND];
    nodrat->etype = TVOID;
    nodrat->class = CGLOBL;
    complex(nodrat);
    nodrat->type = t;

    nodret = new(ONAME, Z, Z);
    nodret->sym = slookup(".ret");
    nodret->type = types[TIND];
    nodret->etype = TIND;
    nodret->class = CPARAM;
    nodret = new(OIND, nodret, Z);
    complex(nodret);

    com64init();

    for(i=0; i<nelem(reg); i++) {
        reg[i] = 1;
        if(i >= D_AX && i <= D_DI && i != D_SP)
            reg[i] = 0;
    }
}
@

<<function [[gclean]](x86)>>=
void
gclean(void)
{
    int i;
    Sym *s;

    reg[D_SP]--;
    for(i=D_AX; i<=D_DI; i++)
        if(reg[i])
            diag(Z, "reg %R left allocated", i);
    while(mnstring)
        outstring("", 1L);

    symstring->type->width = nstring;
    symrathole->type->width = nrathole;

    for(i=0; i<NHASH; i++)
     for(s = hash[i]; s != S; s = s->link) {
        if(s->type == T)
            continue;
        if(s->type->width == 0)
            continue;
        if(s->class != CGLOBL && s->class != CSTATIC)
            continue;
        if(s->type == types[TENUM])
            continue;
        gpseudo(AGLOBL, s, nodconst(s->type->width));
    }
    nextpc();
    p->as = AEND;
    outcode(); // !!!!!!
}
@



<<function [[nareg]](x86)>>=
int
nareg(int notbp)
{
    int i, n;

    n = 0;
    for(i=D_AX; i<=D_DI; i++)
        if(reg[i] == 0)
            n++;
    if(notbp && reg[D_BP] == 0)
        n--;
    return n;
}
@

<<function [[garg1]](x86)>>=
void
garg1(Node *n, Node *tn1, Node *tn2, int f, Node **fnxp)
{
    Node nod;

    if(n == Z)
        return;
    if(n->op == OLIST) {
        garg1(n->left, tn1, tn2, f, fnxp);
        garg1(n->right, tn1, tn2, f, fnxp);
        return;
    }
    if(f == 0) {
        if(n->complex >= FNX) {
            regsalloc(*fnxp, n);
            nod = znode;
            nod.op = OAS;
            nod.left = *fnxp;
            nod.right = n;
            nod.type = n->type;
            cgen(&nod, Z);
            (*fnxp)++;
        }
        return;
    }
    if(typesu[n->type->etype] || typev[n->type->etype]) {
        regaalloc(tn2, n);
        if(n->complex >= FNX) {
            sugen(*fnxp, tn2, n->type->width);
            (*fnxp)++;
        } else
            sugen(n, tn2, n->type->width);
        return;
    }
    if(REGARG>=0 && curarg == 0 && typeilp[n->type->etype]) {
        regaalloc1(tn1, n);
        if(n->complex >= FNX) {
            cgen(*fnxp, tn1);
            (*fnxp)++;
        } else
            cgen(n, tn1);
        return;
    }
    if(vconst(n) == 0) {
        regaalloc(tn2, n);
        gmove(n, tn2);
        return;
    }
    regalloc(tn1, n, Z);
    if(n->complex >= FNX) {
        cgen(*fnxp, tn1);
        (*fnxp)++;
    } else
        cgen(n, tn1);
    regaalloc(tn2, n);
    gmove(tn1, tn2);
    regfree(tn1);
}
@


<<function [[isreg]](x86)>>=
int
isreg(Node *n, int r)
{

    if(n->op == OREGISTER)
        if(n->reg == r)
            return 1;
    return 0;
}
@

<<function [[nodreg]](x86)>>=
int
nodreg(Node *n, Node *nn, int r)
{

    *n = regnode;
    n->reg = r;
    if(reg[r] == 0)
        return 0;
    if(nn != Z) {
        n->type = nn->type;
        n->lineno = nn->lineno;
        if(nn->op == OREGISTER)
        if(nn->reg == r)
            return 0;
    }
    return 1;
}
@

<<function [[regret]](x86)>>=
void
regret(Node *n, Node *nn)
{
    int r;

    r = REGRET;
    if(typefd[nn->type->etype])
        r = FREGRET;
    nodreg(n, nn, r);
    reg[r]++;
}
@

<<function [[regalloc]](x86)>>=
void
regalloc(Node *n, Node *tn, Node *o)
{
    int i;

    switch(tn->type->etype) {
    case TCHAR:
    case TUCHAR:
    case TSHORT:
    case TUSHORT:
    case TINT:
    case TUINT:
    case TLONG:
    case TULONG:
    case TIND:
        if(o != Z && o->op == OREGISTER) {
            i = o->reg;
            if(i >= D_AX && i <= D_DI)
                goto out;
        }
        for(i=D_AX; i<=D_DI; i++)
            if(reg[i] == 0)
                goto out;
        diag(tn, "out of fixed registers");
abort();
        goto err;

    case TFLOAT:
    case TDOUBLE:
        i = D_F0;
        goto out;

    case TVLONG:
    case TUVLONG:
        n->op = OREGPAIR;
        n->complex = 0; /* already in registers */
        n->addable = 11;
        n->type = tn->type;
        n->lineno = nearln;
        n->left = alloc(sizeof(Node));
        n->right = alloc(sizeof(Node));
        if(o != Z && o->op == OREGPAIR) {
            regalloc(n->left, &regnode, o->left);
            regalloc(n->right, &regnode, o->right);
        } else {
            regalloc(n->left, &regnode, Z);
            regalloc(n->right, &regnode, Z);
        }
        n->right->type = types[TULONG];
        if(tn->type->etype == TUVLONG)
            n->left->type = types[TULONG];
        return;
    }
    diag(tn, "unknown type in regalloc: %T", tn->type);
err:
    i = 0;
out:
    if(i)
        reg[i]++;
    nodreg(n, tn, i);
//print("+ %R %d\n", i, reg[i]);
}
@


<<function [[regfree]](x86)>>=
void
regfree(Node *n)
{
    int i;

    if(n->op == OREGPAIR) {
        regfree(n->left);
        regfree(n->right);
        return;
    }

    i = 0;
    if(n->op != OREGISTER && n->op != OINDREG)
        goto err;
    i = n->reg;
    if(i < 0 || i >= sizeof(reg))
        goto err;
    if(reg[i] <= 0)
        goto err;
    reg[i]--;
//print("- %R %d\n", i, reg[i]);
    return;
err:
    diag(n, "error in regfree: %R", i);
}
@


<<function [[regaalloc1]](x86)>>=
void
regaalloc1(Node *n, Node *nn)
{
    USED(nn);

    if(REGARG < 0) {
        diag(n, "regaalloc1");
        return;
    }
/* not reached 
    nodreg(n, nn, REGARG);
    reg[REGARG]++;
    curarg = align(curarg, nn->type, Aarg1);
    curarg = align(curarg, nn->type, Aarg2);
    maxargsafe = maxround(maxargsafe, cursafe+curarg);
*/
}
@

<<function [[regaalloc]](x86)>>=
void
regaalloc(Node *n, Node *nn)
{
    curarg = align(curarg, nn->type, Aarg1);
    *n = *nn;
    n->op = OINDREG;
    n->reg = REGSP;
    n->xoffset = curarg;
    n->complex = 0;
    n->addable = 20;
    curarg = align(curarg, nn->type, Aarg2);
    maxargsafe = maxround(maxargsafe, cursafe+curarg);
}
@


<<function [[naddr]](x86)>>=
void
naddr(Node *n, Adr *a)
{
    long v;

    a->type = D_NONE;
    if(n == Z)
        return;
    switch(n->op) {
    default:
    bad:
        diag(n, "bad in naddr: %O %D", n->op, a);
//prtree(n, "naddr");
        break;

    case OREGISTER:
        a->type = n->reg;
        a->sym = S;
        break;

    case OEXREG:
        a->type = D_INDIR + D_GS;
        a->offset = n->reg - 1;
        a->etype = n->etype;
        break;

    case OIND:
        naddr(n->left, a);
        if(a->type >= D_AX && a->type <= D_DI)
            a->type += D_INDIR;
        else
        if(a->type == D_CONST)
            a->type = D_NONE+D_INDIR;
        else
        if(a->type == D_ADDR) {
            a->type = a->index;
            a->index = D_NONE;
        } else
            goto bad;
        break;

    case OINDEX:
        a->type = idx.ptr;
        if(n->left->op == OADDR || n->left->op == OCONST)
            naddr(n->left, a);
        if(a->type >= D_AX && a->type <= D_DI)
            a->type += D_INDIR;
        else
        if(a->type == D_CONST)
            a->type = D_NONE+D_INDIR;
        else
        if(a->type == D_ADDR) {
            a->type = a->index;
            a->index = D_NONE;
        } else
            goto bad;
        a->index = idx.reg;
        a->scale = n->scale;
        a->offset += n->xoffset;
        break;

    case OINDREG:
        a->type = n->reg+D_INDIR;
        a->sym = S;
        a->offset = n->xoffset;
        break;

    case ONAME:
        a->etype = n->etype;
        a->type = D_STATIC;
        a->sym = n->sym;
        a->offset = n->xoffset;
        if(n->class == CSTATIC)
            break;
        if(n->class == CEXTERN || n->class == CGLOBL) {
            a->type = D_EXTERN;
            break;
        }
        if(n->class == CAUTO) {
            a->type = D_AUTO;
            break;
        }
        if(n->class == CPARAM) {
            a->type = D_PARAM;
            break;
        }
        goto bad;

    case OCONST:
        if(typefd[n->type->etype]) {
            a->type = D_FCONST;
            a->dval = n->fconst;
            break;
        }
        a->sym = S;
        a->type = D_CONST;
        a->offset = n->vconst;
        break;

    case OADDR:
        naddr(n->left, a);
        if(a->type >= D_INDIR) {
            a->type -= D_INDIR;
            break;
        }
        if(a->type == D_EXTERN || a->type == D_STATIC ||
           a->type == D_AUTO || a->type == D_PARAM)
            if(a->index == D_NONE) {
                a->index = a->type;
                a->type = D_ADDR;
                break;
            }
        goto bad;

    case OADD:
        if(n->right->op == OCONST) {
            v = n->right->vconst;
            naddr(n->left, a);
        } else
        if(n->left->op == OCONST) {
            v = n->left->vconst;
            naddr(n->right, a);
        } else
            goto bad;
        a->offset += v;
        break;

    }
}
@

<<function [[CASE]](x86)>>=
#define	CASE(a,b)	((a<<8)|(b<<0))
@

% set via pragma
<<global [[fproundflg]]>>=
int	fproundflg;
@

<<[[macprag()]] if pragma xxx>>=
if(s && strcmp(s->name, "fpround") == 0) {
    pragfpround();
    return;
}
@

% seems to be used only in x96
<<function [[pragfpround]]>>=
void
pragfpround(void)
{
    Sym *s;

    fproundflg = 0;
    s = getsym();
    if(s) {
        fproundflg = atoi(s->name+1);
        if(strcmp(s->name, "on") == 0 ||
           strcmp(s->name, "yes") == 0)
            fproundflg = 1;
    }
    while(getnsc() != '\n')
        ;
    if(debug['f'])
        if(fproundflg)
            print("%4ld: fproundflg %d\n", lineno, fproundflg);
        else
            print("%4ld: fproundflg off\n", lineno);
}
@


<<function [[gmove]](x86)>>=
void
gmove(Node *f, Node *t)
{
    int ft, tt, a;
    Node nod, nod1;
    Prog *p1;

    ft = f->type->etype;
    tt = t->type->etype;

    if(debug['M'])
        print("gop: %O %O[%s],%O[%s]\n", OAS,
            f->op, tnames[ft], t->op, tnames[tt]);

    if(typefd[ft] && f->op == OCONST) {
        if(f->fconst == 0)
            gins(AFLDZ, Z, Z);
        else
        if(f->fconst == 1)
            gins(AFLD1, Z, Z);
        else
            gins(AFMOVD, f, &fregnode0);
        gmove(&fregnode0, t);
        return;
    }
/*
 * load
 */
    if(f->op == ONAME || f->op == OINDREG ||
       f->op == OIND || f->op == OINDEX)
    switch(ft) {
    case TCHAR:
        a = AMOVBLSX;
        goto ld;
    case TUCHAR:
        a = AMOVBLZX;
        goto ld;
    case TSHORT:
        if(typefd[tt]) {
            gins(AFMOVW, f, &fregnode0);
            gmove(&fregnode0, t);
            return;
        }
        a = AMOVWLSX;
        goto ld;
    case TUSHORT:
        a = AMOVWLZX;
        goto ld;
    case TINT:
    case TUINT:
    case TLONG:
    case TULONG:
    case TIND:
        if(typefd[tt]) {
            gins(AFMOVL, f, &fregnode0);
            gmove(&fregnode0, t);
            return;
        }
        a = AMOVL;

    ld:
        regalloc(&nod, f, t);
        nod.type = types[TLONG];
        gins(a, f, &nod);
        gmove(&nod, t);
        regfree(&nod);
        return;

    case TFLOAT:
        gins(AFMOVF, f, t);
        return;
    case TDOUBLE:
        gins(AFMOVD, f, t);
        return;
    }

/*
 * store
 */
    if(t->op == ONAME || t->op == OINDREG ||
       t->op == OIND || t->op == OINDEX)
    switch(tt) {
    case TCHAR:
    case TUCHAR:
        a = AMOVB;	goto st;
    case TSHORT:
    case TUSHORT:
        a = AMOVW;	goto st;
    case TINT:
    case TUINT:
    case TLONG:
    case TULONG:
    case TIND:
        a = AMOVL;	goto st;

    st:
        if(f->op == OCONST) {
            gins(a, f, t);
            return;
        }
        regalloc(&nod, t, f);
        gmove(f, &nod);
        gins(a, &nod, t);
        regfree(&nod);
        return;

    case TFLOAT:
        gins(AFMOVFP, f, t);
        return;
    case TDOUBLE:
        gins(AFMOVDP, f, t);
        return;
    }

/*
 * convert
 */
    switch(CASE(ft,tt)) {
    default:
/*
 * integer to integer
 ********
        a = AGOK;	break;

    case CASE(	TCHAR,	TCHAR):
    case CASE(	TUCHAR,	TCHAR):
    case CASE(	TSHORT,	TCHAR):
    case CASE(	TUSHORT,TCHAR):
    case CASE(	TINT,	TCHAR):
    case CASE(	TUINT,	TCHAR):
    case CASE(	TLONG,	TCHAR):
    case CASE(	TULONG,	TCHAR):
    case CASE(	TIND,	TCHAR):

    case CASE(	TCHAR,	TUCHAR):
    case CASE(	TUCHAR,	TUCHAR):
    case CASE(	TSHORT,	TUCHAR):
    case CASE(	TUSHORT,TUCHAR):
    case CASE(	TINT,	TUCHAR):
    case CASE(	TUINT,	TUCHAR):
    case CASE(	TLONG,	TUCHAR):
    case CASE(	TULONG,	TUCHAR):
    case CASE(	TIND,	TUCHAR):

    case CASE(	TSHORT,	TSHORT):
    case CASE(	TUSHORT,TSHORT):
    case CASE(	TINT,	TSHORT):
    case CASE(	TUINT,	TSHORT):
    case CASE(	TLONG,	TSHORT):
    case CASE(	TULONG,	TSHORT):
    case CASE(	TIND,	TSHORT):

    case CASE(	TSHORT,	TUSHORT):
    case CASE(	TUSHORT,TUSHORT):
    case CASE(	TINT,	TUSHORT):
    case CASE(	TUINT,	TUSHORT):
    case CASE(	TLONG,	TUSHORT):
    case CASE(	TULONG,	TUSHORT):
    case CASE(	TIND,	TUSHORT):

    case CASE(	TINT,	TINT):
    case CASE(	TUINT,	TINT):
    case CASE(	TLONG,	TINT):
    case CASE(	TULONG,	TINT):
    case CASE(	TIND,	TINT):

    case CASE(	TINT,	TUINT):
    case CASE(	TUINT,	TUINT):
    case CASE(	TLONG,	TUINT):
    case CASE(	TULONG,	TUINT):
    case CASE(	TIND,	TUINT):

    case CASE(	TINT,	TLONG):
    case CASE(	TUINT,	TLONG):
    case CASE(	TLONG,	TLONG):
    case CASE(	TULONG,	TLONG):
    case CASE(	TIND,	TLONG):

    case CASE(	TINT,	TULONG):
    case CASE(	TUINT,	TULONG):
    case CASE(	TLONG,	TULONG):
    case CASE(	TULONG,	TULONG):
    case CASE(	TIND,	TULONG):

    case CASE(	TINT,	TIND):
    case CASE(	TUINT,	TIND):
    case CASE(	TLONG,	TIND):
    case CASE(	TULONG,	TIND):
    case CASE(	TIND,	TIND):
 *****/
        a = AMOVL;
        break;

    case CASE(	TSHORT,	TINT):
    case CASE(	TSHORT,	TUINT):
    case CASE(	TSHORT,	TLONG):
    case CASE(	TSHORT,	TULONG):
    case CASE(	TSHORT,	TIND):
        a = AMOVWLSX;
        if(f->op == OCONST) {
            f->vconst &= 0xffff;
            if(f->vconst & 0x8000)
                f->vconst |= 0xffff0000;
            a = AMOVL;
        }
        break;

    case CASE(	TUSHORT,TINT):
    case CASE(	TUSHORT,TUINT):
    case CASE(	TUSHORT,TLONG):
    case CASE(	TUSHORT,TULONG):
    case CASE(	TUSHORT,TIND):
        a = AMOVWLZX;
        if(f->op == OCONST) {
            f->vconst &= 0xffff;
            a = AMOVL;
        }
        break;

    case CASE(	TCHAR,	TSHORT):
    case CASE(	TCHAR,	TUSHORT):
    case CASE(	TCHAR,	TINT):
    case CASE(	TCHAR,	TUINT):
    case CASE(	TCHAR,	TLONG):
    case CASE(	TCHAR,	TULONG):
    case CASE(	TCHAR,	TIND):
        a = AMOVBLSX;
        if(f->op == OCONST) {
            f->vconst &= 0xff;
            if(f->vconst & 0x80)
                f->vconst |= 0xffffff00;
            a = AMOVL;
        }
        break;

    case CASE(	TUCHAR,	TSHORT):
    case CASE(	TUCHAR,	TUSHORT):
    case CASE(	TUCHAR,	TINT):
    case CASE(	TUCHAR,	TUINT):
    case CASE(	TUCHAR,	TLONG):
    case CASE(	TUCHAR,	TULONG):
    case CASE(	TUCHAR,	TIND):
        a = AMOVBLZX;
        if(f->op == OCONST) {
            f->vconst &= 0xff;
            a = AMOVL;
        }
        break;

/*
 * float to fix
 */
    case CASE(	TFLOAT,	TCHAR):
    case CASE(	TFLOAT,	TUCHAR):
    case CASE(	TFLOAT,	TSHORT):
    case CASE(	TFLOAT,	TUSHORT):
    case CASE(	TFLOAT,	TINT):
    case CASE(	TFLOAT,	TLONG):
    case CASE(	TFLOAT,	TIND):

    case CASE(	TDOUBLE,TCHAR):
    case CASE(	TDOUBLE,TUCHAR):
    case CASE(	TDOUBLE,TSHORT):
    case CASE(	TDOUBLE,TUSHORT):
    case CASE(	TDOUBLE,TINT):
    case CASE(	TDOUBLE,TLONG):
    case CASE(	TDOUBLE,TIND):
        if(fproundflg) {
            regsalloc(&nod, &regnode);
            gins(AFMOVLP, f, &nod);
            gmove(&nod, t);
            return;
        }
        regsalloc(&nod, &regnode);
        regsalloc(&nod1, &regnode);
        gins(AFSTCW, Z, &nod1);
        nod1.xoffset += 2;
        gins(AMOVW, nodconst(0xf7f), &nod1);
        gins(AFLDCW, &nod1, Z);
        gins(AFMOVLP, f, &nod);
        nod1.xoffset -= 2;
        gins(AFLDCW, &nod1, Z);
        gmove(&nod, t);
        return;

/*
 * float to ulong
 */
    case CASE(	TDOUBLE,	TULONG):
    case CASE(	TFLOAT,	TULONG):
    case CASE(	TDOUBLE,	TUINT):
    case CASE(	TFLOAT,	TUINT):
        regsalloc(&nod, &regnode);
        gmove(f, &fregnode0);
        gins(AFADDD, nodfconst(-2147483648.), &fregnode0);
        gins(AFMOVLP, f, &nod);
        gins(ASUBL, nodconst(-2147483648), &nod);
        gmove(&nod, t);
        return;

/*
 * ulong to float
 */
    case CASE(	TULONG,	TDOUBLE):
    case CASE(	TULONG,	TFLOAT):
    case CASE(	TUINT,	TDOUBLE):
    case CASE(	TUINT,	TFLOAT):
        regalloc(&nod, f, f);
        gmove(f, &nod);
        regsalloc(&nod1, &regnode);
        gmove(&nod, &nod1);
        gins(AFMOVL, &nod1, &fregnode0);
        gins(ACMPL, &nod, nodconst(0));
        gins(AJGE, Z, Z);
        p1 = p;
        gins(AFADDD, nodfconst(4294967296.), &fregnode0);
        patch(p1, pc);
        regfree(&nod);
        return;

/*
 * fix to float
 */
    case CASE(	TCHAR,	TFLOAT):
    case CASE(	TUCHAR,	TFLOAT):
    case CASE(	TSHORT,	TFLOAT):
    case CASE(	TUSHORT,TFLOAT):
    case CASE(	TINT,	TFLOAT):
    case CASE(	TLONG,	TFLOAT):
    case CASE(	TIND,	TFLOAT):

    case CASE(	TCHAR,	TDOUBLE):
    case CASE(	TUCHAR,	TDOUBLE):
    case CASE(	TSHORT,	TDOUBLE):
    case CASE(	TUSHORT,TDOUBLE):
    case CASE(	TINT,	TDOUBLE):
    case CASE(	TLONG,	TDOUBLE):
    case CASE(	TIND,	TDOUBLE):
        regsalloc(&nod, &regnode);
        gmove(f, &nod);
        gins(AFMOVL, &nod, &fregnode0);
        return;

/*
 * float to float
 */
    case CASE(	TFLOAT,	TFLOAT):
    case CASE(	TDOUBLE,TFLOAT):

    case CASE(	TFLOAT,	TDOUBLE):
    case CASE(	TDOUBLE,TDOUBLE):
        a = AFMOVD;	break;
    }
    if(a == AMOVL || a == AFMOVD)
    if(samaddr(f, t))
        return;
    gins(a, f, t);
}
@

<<function [[doindex]](x86)>>=
void
doindex(Node *n)
{
    Node nod, nod1;
    long v;

if(debug['Y'])
prtree(n, "index");

if(n->left->complex >= FNX)
print("botch in doindex\n");

    regalloc(&nod, &regnode, Z);
    v = constnode.vconst;
    cgen(n->right, &nod);
    idx.ptr = D_NONE;
    if(n->left->op == OCONST)
        idx.ptr = D_CONST;
    else if(n->left->op == OREGISTER)
//	else if(n->left->op == OREGISTER && typeil[n->left->type->etype])
        idx.ptr = n->left->reg;
    else if(n->left->op != OADDR) {
        reg[D_BP]++;	// cant be used as a base
        regalloc(&nod1, &regnode, Z);
        cgen(n->left, &nod1);
        idx.ptr = nod1.reg;
        regfree(&nod1);
        reg[D_BP]--;
    }
    idx.reg = nod.reg;
    regfree(&nod);
    constnode.vconst = v;
}
@

<<function [[gins]](x86)>>=
void
gins(int a, Node *f, Node *t)
{

    if(f != Z && f->op == OINDEX)
        doindex(f);
    if(t != Z && t->op == OINDEX)
        doindex(t);
    nextpc();
    p->as = a;
    if(f != Z)
        naddr(f, &p->from);
    if(t != Z)
        naddr(t, &p->to);
    if(debug['g'])
        print("%P\n", p);
}
@

<<function [[fgopcode]](x86)>>=
void
fgopcode(int o, Node *f, Node *t, int pop, int rev)
{
    int a, et;
    Node nod;

    et = TLONG;
    if(f != Z && f->type != T)
        et = f->type->etype;
    if(!typefd[et]) {
        diag(f, "fop: integer %O", o);
        return;
    }
    if(debug['M']) {
        if(t != Z && t->type != T)
            print("gop: %O %O-%s Z\n", o, f->op, tnames[et]);
        else
            print("gop: %O %O-%s %O-%s\n", o,
                f->op, tnames[et], t->op, tnames[t->type->etype]);
    }
    a = AGOK;
    switch(o) {

    case OASADD:
    case OADD:
        if(et == TFLOAT)
            a = AFADDF;
        else
        if(et == TDOUBLE) {
            a = AFADDD;
            if(pop)
                a = AFADDDP;
        }
        break;

    case OASSUB:
    case OSUB:
        if(et == TFLOAT) {
            a = AFSUBF;
            if(rev)
                a = AFSUBRF;
        } else
        if(et == TDOUBLE) {
            a = AFSUBD;
            if(pop)
                a = AFSUBDP;
            if(rev) {
                a = AFSUBRD;
                if(pop)
                    a = AFSUBRDP;
            }
        }
        break;

    case OASMUL:
    case OMUL:
        if(et == TFLOAT)
            a = AFMULF;
        else
        if(et == TDOUBLE) {
            a = AFMULD;
            if(pop)
                a = AFMULDP;
        }
        break;

    case OASMOD:
    case OMOD:
    case OASDIV:
    case ODIV:
        if(et == TFLOAT) {
            a = AFDIVF;
            if(rev)
                a = AFDIVRF;
        } else
        if(et == TDOUBLE) {
            a = AFDIVD;
            if(pop)
                a = AFDIVDP;
            if(rev) {
                a = AFDIVRD;
                if(pop)
                    a = AFDIVRDP;
            }
        }
        break;

    case OEQ:
    case ONE:
    case OLT:
    case OLE:
    case OGE:
    case OGT:
        pop += rev;
        if(et == TFLOAT) {
            a = AFCOMF;
            if(pop) {
                a = AFCOMFP;
                if(pop > 1)
                    a = AGOK;
            }
        } else
        if(et == TDOUBLE) {
            a = AFCOMF;
            if(pop) {
                a = AFCOMDP;
                if(pop > 1)
                    a = AFCOMDPP;
            }
        }
        gins(a, f, t);
        regalloc(&nod, &regnode, Z);
        if(nod.reg != D_AX) {
            regfree(&nod);
            nod.reg = D_AX;
            gins(APUSHL, &nod, Z);
            gins(AWAIT, Z, Z);
            gins(AFSTSW, Z, &nod);
            gins(ASAHF, Z, Z);
            gins(APOPL, Z, &nod);
        } else {
            gins(AWAIT, Z, Z);
            gins(AFSTSW, Z, &nod);
            gins(ASAHF, Z, Z);
            regfree(&nod);
        }
        switch(o) {
        case OEQ:	a = AJEQ; break;
        case ONE:	a = AJNE; break;
        case OLT:	a = AJCS; break;
        case OLE:	a = AJLS; break;
        case OGE:	a = AJCC; break;
        case OGT:	a = AJHI; break;
        }
        gins(a, Z, Z);
        return;
    }
    if(a == AGOK)
        diag(Z, "bad in gopcode %O", o);
    gins(a, f, t);
}
@

<<function [[gopcode]](x86)>>=
void
gopcode(int o, Type *ty, Node *f, Node *t)
{
    int a, et;

    et = TLONG;
    if(ty != T)
        et = ty->etype;
    if(typefd[et] && o != OADDR && o != OFUNC) {
        diag(f, "gop: float %O", o);
        return;
    }
    if(debug['M']) {
        if(f != Z && f->type != T)
            print("gop: %O %O[%s],", o, f->op, tnames[et]);
        else
            print("gop: %O Z,", o);
        if(t != Z && t->type != T)
            print("%O[%s]\n", t->op, tnames[t->type->etype]);
        else
            print("Z\n");
    }
    a = AGOK;
    switch(o) {
    case OCOM:
        a = ANOTL;
        if(et == TCHAR || et == TUCHAR)
            a = ANOTB;
        if(et == TSHORT || et == TUSHORT)
            a = ANOTW;
        break;

    case ONEG:
        a = ANEGL;
        if(et == TCHAR || et == TUCHAR)
            a = ANEGB;
        if(et == TSHORT || et == TUSHORT)
            a = ANEGW;
        break;

    case OADDR:
        a = ALEAL;
        break;

    case OASADD:
    case OADD:
        a = AADDL;
        if(et == TCHAR || et == TUCHAR)
            a = AADDB;
        if(et == TSHORT || et == TUSHORT)
            a = AADDW;
        break;

    case OASSUB:
    case OSUB:
        a = ASUBL;
        if(et == TCHAR || et == TUCHAR)
            a = ASUBB;
        if(et == TSHORT || et == TUSHORT)
            a = ASUBW;
        break;

    case OASOR:
    case OOR:
        a = AORL;
        if(et == TCHAR || et == TUCHAR)
            a = AORB;
        if(et == TSHORT || et == TUSHORT)
            a = AORW;
        break;

    case OASAND:
    case OAND:
        a = AANDL;
        if(et == TCHAR || et == TUCHAR)
            a = AANDB;
        if(et == TSHORT || et == TUSHORT)
            a = AANDW;
        break;

    case OASXOR:
    case OXOR:
        a = AXORL;
        if(et == TCHAR || et == TUCHAR)
            a = AXORB;
        if(et == TSHORT || et == TUSHORT)
            a = AXORW;
        break;

    case OASLSHR:
    case OLSHR:
        a = ASHRL;
        if(et == TCHAR || et == TUCHAR)
            a = ASHRB;
        if(et == TSHORT || et == TUSHORT)
            a = ASHRW;
        break;

    case OASASHR:
    case OASHR:
        a = ASARL;
        if(et == TCHAR || et == TUCHAR)
            a = ASARB;
        if(et == TSHORT || et == TUSHORT)
            a = ASARW;
        break;

    case OASASHL:
    case OASHL:
        a = ASALL;
        if(et == TCHAR || et == TUCHAR)
            a = ASALB;
        if(et == TSHORT || et == TUSHORT)
            a = ASALW;
        break;

    case OFUNC:
        a = ACALL;
        break;

    case OASMUL:
    case OMUL:
        if(f->op == OREGISTER && t != Z && isreg(t, D_AX) && reg[D_DX] == 0)
            t = Z;
        a = AIMULL;
        break;

    case OASMOD:
    case OMOD:
    case OASDIV:
    case ODIV:
        a = AIDIVL;
        break;

    case OASLMUL:
    case OLMUL:
        a = AMULL;
        break;

    case OASLMOD:
    case OLMOD:
    case OASLDIV:
    case OLDIV:
        a = ADIVL;
        break;

    case OEQ:
    case ONE:
    case OLT:
    case OLE:
    case OGE:
    case OGT:
    case OLO:
    case OLS:
    case OHS:
    case OHI:
        a = ACMPL;
        if(et == TCHAR || et == TUCHAR)
            a = ACMPB;
        if(et == TSHORT || et == TUSHORT)
            a = ACMPW;
        gins(a, f, t);
        switch(o) {
        case OEQ:	a = AJEQ; break;
        case ONE:	a = AJNE; break;
        case OLT:	a = AJLT; break;
        case OLE:	a = AJLE; break;
        case OGE:	a = AJGE; break;
        case OGT:	a = AJGT; break;
        case OLO:	a = AJCS; break;
        case OLS:	a = AJLS; break;
        case OHS:	a = AJCC; break;
        case OHI:	a = AJHI; break;
        }
        gins(a, Z, Z);
        return;
    }
    if(a == AGOK)
        diag(Z, "bad in gopcode %O", o);
    gins(a, f, t);
}
@


<<function [[gbranch]](x86)>>=
void
gbranch(int o)
{
    int a;

    a = AGOK;
    switch(o) {
    case ORETURN:
        a = ARET;
        break;
    case OGOTO:
        a = AJMP;
        break;
    }
    nextpc();
    if(a == AGOK) {
        diag(Z, "bad in gbranch %O",  o);
        nextpc();
    }
    p->as = a;
}
@


<<function [[gpseudo]](x86)>>=
void
gpseudo(int a, Sym *s, Node *n)
{

    nextpc();
    p->as = a;
    p->from.type = D_EXTERN;
    p->from.sym = s;
    p->from.scale = (profileflg ? 0 : NOPROF);
    if(s->class == CSTATIC)
        p->from.type = D_STATIC;
    naddr(n, &p->to);
    if(a == ADATA || a == AGLOBL)
        pc--;
}
@

<<function [[sconst]](x86)>>=
int
sconst(Node *n)
{
    long v;

    if(n->op == OCONST && !typefd[n->type->etype]) {
        v = n->vconst;
        if(v >= -32766L && v < 32766L)
            return 1;
    }
    return 0;
}
@

<<function [[exreg]](x86)>>=
long
exreg(Type *t)
{

    int o;

    if(typechlp[t->etype]){
        if(exregoffset >= 32)
            return 0;
        o = exregoffset;
        exregoffset += 4;
        return o+1;	/* +1 to avoid 0 == failure; naddr case OEXREG will -1. */
    }
    return 0;
}
@



%-------------------------------------------------------------

<<8c/txt.c>>=
#include "gc.h"

void	nextpc(void);
void	garg1(Node*, Node*, Node*, int, Node**);
Node*	nodfconst(double);
void	regaalloc1(Node*, Node*);
void	regaalloc(Node*, Node*);
void	naddr(Node*, Adr*);
int	samaddr(Node*, Node*);

<<function [[ginit]](x86)>>

<<function [[gclean]](x86)>>

<<function [[nextpc]]>>

<<function [[gargs]]>>

<<function [[nareg]](x86)>>

<<function [[garg1]](x86)>>

<<function [[nodconst]]>>

<<function [[nodfconst]]>>

<<function [[isreg]](x86)>>

<<function [[nodreg]](x86)>>

<<function [[regret]](x86)>>

<<function [[regalloc]](x86)>>

<<function [[regialloc]]>>

<<function [[regfree]](x86)>>

<<function [[regsalloc]]>>

<<function [[regaalloc1]](x86)>>

<<function [[regaalloc]](x86)>>

<<function [[regind]]>>

<<function [[naddr]](x86)>>

<<function [[CASE]](x86)>>

<<function [[gmove]](x86)>>

<<function [[doindex]](x86)>>

<<function [[gins]](x86)>>

<<function [[fgopcode]](x86)>>

<<function [[gopcode]](x86)>>

<<function [[samaddr]]>>

<<function [[gbranch]](x86)>>

<<function [[patch]]>>

<<function [[gpseudo]](x86)>>

<<function [[sconst]](x86)>>

<<function [[exreg]](x86)>>

<<global [[ewidth]]>>
<<global [[ncast]]>>
@


\subsection*{[[8c/peep.c]]}

<<function [[needc]](x86)>>=
static bool
needc(Prog *p)
{
    while(p != P) {
        switch(p->as) {
        case AADCL:
        case ASBBL:
        case ARCRL:
            return true;
        case AADDL:
        case ASUBL:
        case AJMP:
        case ARET:
        case ACALL:
            return false;
        default:
            if(p->to.type == D_BRANCH)
                return false;
        }
        p = p->link;
    }
    return false;
}
@

<<function [[peep]](x86)>>=
void
peep(void)
{
    Reg *r, *r1, *r2;
    Prog *p, *p1;
    int t;

    /*
     * complete R structure
     */
    t = 0;
    for(r=firstr; r!=R; r=r1) {
        r1 = r->link;
        if(r1 == R)
            break;
        p = r->prog->link;
        while(p != r1->prog)
        switch(p->as) {
        default:
            r2 = rega();
            r->link = r2;
            r2->link = r1;

            r2->prog = p;
            r2->p1 = r;
            r->s1 = r2;
            r2->s1 = r1;
            r1->p1 = r2;

            r = r2;
            t++;

        case ADATA:
        case AGLOBL:
        case ANAME:
        case ASIGNAME:
            p = p->link;
        }
    }

    pc = 0;	/* speculating it won't kill */

loop1:

    t = 0;
    for(r=firstr; r!=R; r=r->link) {
        p = r->prog;
        switch(p->as) {
        case AMOVL:
            if(regtyp(&p->to))
            if(regtyp(&p->from)) {
                if(copyprop(r)) {
                    excise(r);
                    t++;
                }
                if(subprop(r) && copyprop(r)) {
                    excise(r);
                    t++;
                }
            }
            break;

        case AMOVBLSX:
        case AMOVBLZX:
        case AMOVWLSX:
        case AMOVWLZX:
            if(regtyp(&p->to)) {
                r1 = uniqs(r);
                if(r1 != R) {
                    p1 = r1->prog;
                    if(p->as == p1->as && p->to.type == p1->from.type)
                        p1->as = AMOVL;
                }
            }
            break;
        case AADDL:
        case AADDW:
            if(p->from.type != D_CONST || needc(p->link))
                break;
            if(p->from.offset == -1){
                if(p->as == AADDL)
                    p->as = ADECL;
                else
                    p->as = ADECW;
                p->from = zprog.from;
            }
            else if(p->from.offset == 1){
                if(p->as == AADDL)
                    p->as = AINCL;
                else
                    p->as = AINCW;
                p->from = zprog.from;
            }
            break;
        case ASUBL:
        case ASUBW:
            if(p->from.type != D_CONST || needc(p->link))
                break;
            if(p->from.offset == -1) {
                if(p->as == ASUBL)
                    p->as = AINCL;
                else
                    p->as = AINCW;
                p->from = zprog.from;
            }
            else if(p->from.offset == 1){
                if(p->as == ASUBL)
                    p->as = ADECL;
                else
                    p->as = ADECW;
                p->from = zprog.from;
            }
            break;
        }
    }
    if(t)
        goto loop1;
}
@

<<function [[excise]](x86)>>=
void
excise(Reg *r)
{
    Prog *p;

    p = r->prog;
    p->as = ANOP;
    p->from = zprog.from;
    p->to = zprog.to;
}
@


<<function [[regtyp]](x86)>>=
int
regtyp(Adr *a)
{
    int t;

    t = a->type;
    if(t >= D_AX && t <= D_DI)
        return 1;
    return 0;
}
@

<<function [[subprop]](x86)>>=
/*
 * the idea is to substitute
 * one register for another
 * from one MOV to another
 *	MOV	a, R0
 *	ADD	b, R0	/ no use of R1
 *	MOV	R0, R1
 * would be converted to
 *	MOV	a, R1
 *	ADD	b, R1
 *	MOV	R1, R0
 * hopefully, then the former or latter MOV
 * will be eliminated by copy propagation.
 */
int
subprop(Reg *r0)
{
    Prog *p;
    Adr *v1, *v2;
    Reg *r;
    int t;

    p = r0->prog;
    v1 = &p->from;
    if(!regtyp(v1))
        return 0;
    v2 = &p->to;
    if(!regtyp(v2))
        return 0;
    for(r=uniqp(r0); r!=R; r=uniqp(r)) {
        if(uniqs(r) == R)
            break;
        p = r->prog;
        switch(p->as) {
        case ACALL:
            return 0;

        case AIMULL:
        case AIMULW:
            if(p->to.type != D_NONE)
                break;

        case ADIVB:
        case ADIVL:
        case ADIVW:
        case AIDIVB:
        case AIDIVL:
        case AIDIVW:
        case AIMULB:
        case AMULB:
        case AMULL:
        case AMULW:

        case AROLB:
        case AROLL:
        case AROLW:
        case ARORB:
        case ARORL:
        case ARORW:
        case ASALB:
        case ASALL:
        case ASALW:
        case ASARB:
        case ASARL:
        case ASARW:
        case ASHLB:
        case ASHLL:
        case ASHLW:
        case ASHRB:
        case ASHRL:
        case ASHRW:

        case AREP:
        case AREPN:

        case ACWD:
        case ACDQ:

        case ASTOSB:
        case ASTOSL:
        case AMOVSB:
        case AMOVSL:
        case AFSTSW:
            return 0;

        case AMOVL:
            if(p->to.type == v1->type)
                goto gotit;
            break;
        }
        if(copyau(&p->from, v2) ||
           copyau(&p->to, v2))
            break;
        if(copysub(&p->from, v1, v2, 0) ||
           copysub(&p->to, v1, v2, 0))
            break;
    }
    return 0;

gotit:
    copysub(&p->to, v1, v2, 1);
    if(debug['P']) {
        print("gotit: %D->%D\n%P", v1, v2, r->prog);
        if(p->from.type == v2->type)
            print(" excise");
        print("\n");
    }
    for(r=uniqs(r); r!=r0; r=uniqs(r)) {
        p = r->prog;
        copysub(&p->from, v1, v2, 1);
        copysub(&p->to, v1, v2, 1);
        if(debug['P'])
            print("%P\n", r->prog);
    }
    t = v1->type;
    v1->type = v2->type;
    v2->type = t;
    if(debug['P'])
        print("%P last\n", r->prog);
    return 1;
}
@


<<function [[copyu]](x86)>>=
/*
 * return
 * 1 if v only used (and substitute),
 * 2 if read-alter-rewrite
 * 3 if set
 * 4 if set and used
 * 0 otherwise (not touched)
 */
int
copyu(Prog *p, Adr *v, Adr *s)
{

    switch(p->as) {

    default:
        if(debug['P'])
            print("unknown op %A\n", p->as);
        return 2;

    case ANEGB:
    case ANEGW:
    case ANEGL:
    case ANOTB:
    case ANOTW:
    case ANOTL:
        if(copyas(&p->to, v))
            return 2;
        break;

    case ALEAL:	/* lhs addr, rhs store */
        if(copyas(&p->from, v))
            return 2;


    case ANOP:	/* rhs store */
    case AMOVL:
    case AMOVBLSX:
    case AMOVBLZX:
    case AMOVWLSX:
    case AMOVWLZX:
        if(copyas(&p->to, v)) {
            if(s != A)
                return copysub(&p->from, v, s, 1);
            if(copyau(&p->from, v))
                return 4;
            return 3;
        }
        goto caseread;

    case AROLB:
    case AROLL:
    case AROLW:
    case ARORB:
    case ARORL:
    case ARORW:
    case ASALB:
    case ASALL:
    case ASALW:
    case ASARB:
    case ASARL:
    case ASARW:
    case ASHLB:
    case ASHLL:
    case ASHLW:
    case ASHRB:
    case ASHRL:
    case ASHRW:
        if(copyas(&p->to, v))
            return 2;
        if(copyas(&p->from, v))
            if(p->from.type == D_CX)
                return 2;
        goto caseread;

    case AADDB:	/* rhs rar */
    case AADDL:
    case AADDW:
    case AANDB:
    case AANDL:
    case AANDW:
    case ADECL:
    case ADECW:
    case AINCL:
    case AINCW:
    case ASUBB:
    case ASUBL:
    case ASUBW:
    case AORB:
    case AORL:
    case AORW:
    case AXORB:
    case AXORL:
    case AXORW:
    case AMOVB:
    case AMOVW:

    case AFMOVB:
    case AFMOVBP:
    case AFMOVD:
    case AFMOVDP:
    case AFMOVF:
    case AFMOVFP:
    case AFMOVL:
    case AFMOVLP:
    case AFMOVV:
    case AFMOVVP:
    case AFMOVW:
    case AFMOVWP:
    case AFMOVX:
    case AFMOVXP:
    case AFADDDP:
    case AFADDW:
    case AFADDL:
    case AFADDF:
    case AFADDD:
    case AFMULDP:
    case AFMULW:
    case AFMULL:
    case AFMULF:
    case AFMULD:
    case AFSUBDP:
    case AFSUBW:
    case AFSUBL:
    case AFSUBF:
    case AFSUBD:
    case AFSUBRDP:
    case AFSUBRW:
    case AFSUBRL:
    case AFSUBRF:
    case AFSUBRD:
    case AFDIVDP:
    case AFDIVW:
    case AFDIVL:
    case AFDIVF:
    case AFDIVD:
    case AFDIVRDP:
    case AFDIVRW:
    case AFDIVRL:
    case AFDIVRF:
    case AFDIVRD:
        if(copyas(&p->to, v))
            return 2;
        goto caseread;

    case ACMPL:	/* read only */
    case ACMPW:
    case ACMPB:

    case AFCOMB:
    case AFCOMBP:
    case AFCOMD:
    case AFCOMDP:
    case AFCOMDPP:
    case AFCOMF:
    case AFCOMFP:
    case AFCOML:
    case AFCOMLP:
    case AFCOMW:
    case AFCOMWP:
    case AFUCOM:
    case AFUCOMP:
    case AFUCOMPP:
    caseread:
        if(s != A) {
            if(copysub(&p->from, v, s, 1))
                return 1;
            return copysub(&p->to, v, s, 1);
        }
        if(copyau(&p->from, v))
            return 1;
        if(copyau(&p->to, v))
            return 1;
        break;

    case AJGE:	/* no reference */
    case AJNE:
    case AJLE:
    case AJEQ:
    case AJHI:
    case AJLS:
    case AJMI:
    case AJPL:
    case AJGT:
    case AJLT:
    case AJCC:
    case AJCS:

    case AADJSP:
    case AFLDZ:
    case AWAIT:
        break;

    case AIMULL:
    case AIMULW:
        if(p->to.type != D_NONE) {
            if(copyas(&p->to, v))
                return 2;
            goto caseread;
        }

    case ADIVB:
    case ADIVL:
    case ADIVW:
    case AIDIVB:
    case AIDIVL:
    case AIDIVW:
    case AIMULB:
    case AMULB:
    case AMULL:
    case AMULW:

    case ACWD:
    case ACDQ:
        if(v->type == D_AX || v->type == D_DX)
            return 2;
        goto caseread;

    case AREP:
    case AREPN:
        if(v->type == D_CX)
            return 2;
        goto caseread;

    case AMOVSB:
    case AMOVSL:
        if(v->type == D_DI || v->type == D_SI)
            return 2;
        goto caseread;

    case ASTOSB:
    case ASTOSL:
        if(v->type == D_AX || v->type == D_DI)
            return 2;
        goto caseread;

    case AFSTSW:
        if(v->type == D_AX)
            return 2;
        goto caseread;

    case AJMP:	/* funny */
        if(s != A) {
            if(copysub(&p->to, v, s, 1))
                return 1;
            return 0;
        }
        if(copyau(&p->to, v))
            return 1;
        return 0;

    case ARET:	/* funny */
        if(v->type == REGRET)
            return 2;
        if(s != A)
            return 1;
        return 3;

    case ACALL:	/* funny */
        if(REGARG>=0 && v->type == REGARG)
            return 2;

        if(s != A) {
            if(copysub(&p->to, v, s, 1))
                return 1;
            return 0;
        }
        if(copyau(&p->to, v))
            return 4;
        return 3;
    }
    return 0;
}
@

<<function [[copyas]](x86)>>=
/*
 * direct reference,
 * could be set/use depending on
 * semantics
 */
int
copyas(Adr *a, Adr *v)
{
    if(a->type != v->type)
        return 0;
    if(regtyp(v))
        return 1;
    if(v->type == D_AUTO || v->type == D_PARAM)
        if(v->offset == a->offset)
            return 1;
    return 0;
}
@

<<function [[copyau]](x86)>>=
/*
 * either direct or indirect
 */
int
copyau(Adr *a, Adr *v)
{

    if(copyas(a, v))
        return 1;
    if(regtyp(v)) {
        if(a->type-D_INDIR == v->type)
            return 1;
        if(a->index == v->type)
            return 1;
    }
    return 0;
}
@

<<function [[copysub]](x86)>>=
/*
 * substitute s for v in a
 * return failure to substitute
 */
int
copysub(Adr *a, Adr *v, Adr *s, int f)
{
    int t;

    if(copyas(a, v)) {
        t = s->type;
        if(t >= D_AX && t <= D_DI) {
            if(f)
                a->type = t;
        }
        return 0;
    }
    if(regtyp(v)) {
        t = v->type;
        if(a->type == t+D_INDIR) {
            if(s->type == D_BP && a->index != D_NONE)
                return 1;	/* can't use BP-base with index */
            if(f)
                a->type = s->type+D_INDIR;
//			return 0;
        }
        if(a->index == t) {
            if(f)
                a->index = s->type;
            return 0;
        }
        return 0;
    }
    return 0;
}
@


%-------------------------------------------------------------

<<8c/peep.c>>=
#include "gc.h"

Reg*	uniqp(Reg*);
Reg*	uniqs(Reg*);
int	regtyp(Adr*);
int	subprop(Reg*);
int	copyprop(Reg*);
int	copy1(Adr*, Adr*, Reg*, int);
int	copyas(Adr*, Adr*);
int	copyau(Adr*, Adr*);
int	copysub(Adr*, Adr*, Adr*, int);
//int	copysub1(Prog*, Adr*, Adr*, int);

<<function [[needc]](x86)>>

<<function [[peep]](x86)>>

<<function [[excise]](x86)>>

<<function [[uniqp]]>>

<<function [[uniqs]]>>

<<function [[regtyp]](x86)>>

<<function [[subprop]](x86)>>

<<function [[copyprop]]>>

<<function [[copy1]]>>

<<function [[copyu]](x86)>>

<<function [[copyas]](x86)>>

<<function [[copyau]](x86)>>

<<function [[copysub]](x86)>>
@


\subsection*{[[8c/sgen.c]]}


<<function [[commute]](x86)>>=
/* welcome to commute */
static void
commute(Node *n)
{
    Node *l, *r;

    l = n->left;
    r = n->right;
    if(r->complex > l->complex) {
        n->left = r;
        n->right = l;
    }
}
@

<<function [[indexshift]](x86)>>=
void
indexshift(Node *n)
{
    int g;

    if(!typechlp[n->type->etype])
        return;
    simplifyshift(n);
    if(n->op == OASHL && n->right->op == OCONST){
        g = vconst(n->right);
        if(g >= 0 && g < 4)
            n->addable = 7;
    }
}
@

<<function [[simplifyshift]]>>=
/*
 * try to rewrite shift & mask
 */
void
simplifyshift(Node *n)
{
    ulong c3;
    int o, s1, s2, c1, c2;

    if(!typechlp[n->type->etype])
        return;
    switch(n->op) {
    default:
        return;
    case OASHL:
        s1 = 0;
        break;
    case OLSHR:
        s1 = 1;
        break;
    case OASHR:
        s1 = 2;
        break;
    }
    if(n->right->op != OCONST)
        return;
    if(n->left->op != OAND)
        return;
    if(n->left->right->op != OCONST)
        return;
    switch(n->left->left->op) {
    default:
        return;
    case OASHL:
        s2 = 0;
        break;
    case OLSHR:
        s2 = 1;
        break;
    case OASHR:
        s2 = 2;
        break;
    }
    if(n->left->left->right->op != OCONST)
        return;

    c1 = n->right->vconst;
    c2 = n->left->left->right->vconst;
    c3 = n->left->right->vconst;

/*
    if(debug['h'])
        print("%.3o %ld %ld %d #%.lux\n",
            (s1<<3)|s2, c1, c2, topbit(c3), c3);
*/

    o = n->op;
    switch((s1<<3)|s2) {
    case 000:	/* (((e <<u c2) & c3) <<u c1) */
        c3 >>= c2;
        c1 += c2;
        if(c1 >= 32)
            break;
        goto rewrite1;

    case 002:	/* (((e >>s c2) & c3) <<u c1) */
        if(topbit(c3) >= (32-c2))
            break;
    case 001:	/* (((e >>u c2) & c3) <<u c1) */
        if(c1 > c2) {
            c3 <<= c2;
            c1 -= c2;
            o = OASHL;
            goto rewrite1;
        }
        c3 <<= c1;
        if(c1 == c2)
            goto rewrite0;
        c1 = c2-c1;
        o = OLSHR;
        goto rewrite2;

    case 022:	/* (((e >>s c2) & c3) >>s c1) */
        if(c2 <= 0)
            break;
    case 012:	/* (((e >>s c2) & c3) >>u c1) */
        if(topbit(c3) >= (32-c2))
            break;
        goto s11;
    case 021:	/* (((e >>u c2) & c3) >>s c1) */
        if(topbit(c3) >= 31 && c2 <= 0)
            break;
        goto s11;
    case 011:	/* (((e >>u c2) & c3) >>u c1) */
    s11:
        c3 <<= c2;
        c1 += c2;
        if(c1 >= 32)
            break;
        o = OLSHR;
        goto rewrite1;

    case 020:	/* (((e <<u c2) & c3) >>s c1) */
        if(topbit(c3) >= 31)
            break;
    case 010:	/* (((e <<u c2) & c3) >>u c1) */
        c3 >>= c1;
        if(c1 == c2)
            goto rewrite0;
        if(c1 > c2) {
            c1 -= c2;
            goto rewrite2;
        }
        c1 = c2 - c1;
        o = OASHL;
        goto rewrite2;
    }
    return;

rewrite0:	/* get rid of both shifts */
if(debug['<'])prtree(n, "rewrite0");
    *n = *n->left;
    n->left = n->left->left;
    n->right->vconst = c3;
    return;
rewrite1:	/* get rid of lower shift */
if(debug['<'])prtree(n, "rewrite1");
    n->left->left = n->left->left->left;
    n->left->right->vconst = c3;
    n->right->vconst = c1;
    n->op = o;
    return;
rewrite2:	/* get rid of upper shift */
if(debug['<'])prtree(n, "rewrite2");
    *n = *n->left;
    n->right->vconst = c3;
    n->left->right->vconst = c1;
    n->left->op = o;
}
@


<<function [[indx]](x86)>>=
void
indx(Node *n)
{
    Node *l, *r;

    if(debug['x'])
        prtree(n, "indx");

    l = n->left;
    r = n->right;
    if(l->addable == 1 || l->addable == 13 || r->complex > l->complex) {
        n->right = l;
        n->left = r;
        l = r;
        r = n->right;
    }
    if(l->addable != 7) {
        idx.regtree = l;
        idx.scale = 1;
    } else
    if(l->right->addable == 20) {
        idx.regtree = l->left;
        idx.scale = 1 << l->right->vconst;
    } else
    if(l->left->addable == 20) {
        idx.regtree = l->right;
        idx.scale = 1 << l->left->vconst;
    } else
        diag(n, "bad index");

    idx.basetree = r;
    if(debug['x']) {
        print("scale = %d\n", idx.scale);
        prtree(idx.regtree, "index");
        prtree(idx.basetree, "base");
    }
}
@


%-------------------------------------------------------------

<<8c/sgen.c>>=
#include "gc.h"

void	indx(Node*);

<<function [[noretval]](x86)>>

<<function [[commute]](x86)>>

<<function [[indexshift]](x86)>>

<<function [[xcom]](x86)>>

<<function [[indx]](x86)>>
@


\subsection*{[[8c/swt.c]]}

<<function [[swit1]](x86)>>=
void
swit1(C1 *q, int nc, long def, Node *n)
{
    C1 *r;
    int i;
    Prog *sp;

    if(nc < 5) {
        for(i=0; i<nc; i++) {
            if(debug['K'])
                print("case = %.8llux\n", q->val);
            gopcode(OEQ, n->type, n, nodconst(q->val));
            patch(p, q->label);
            q++;
        }
        gbranch(OGOTO);
        patch(p, def);
        return;
    }
    i = nc / 2;
    r = q+i;
    if(debug['K'])
        print("case > %.8llux\n", r->val);
    gopcode(OGT, n->type, n, nodconst(r->val));
    sp = p;
    gbranch(OGOTO);
    p->as = AJEQ;
    patch(p, r->label);
    swit1(q, i, def, n);

    if(debug['K'])
        print("case < %.8llux\n", r->val);
    patch(sp, pc);
    swit1(r+1, nc-i-1, def, n);
}
@

<<function [[bitload]](x86)>>=
void
bitload(Node *b, Node *n1, Node *n2, Node *n3, Node *nn)
{
    int sh;
    long v;
    Node *l;

    /*
     * n1 gets adjusted/masked value
     * n2 gets address of cell
     * n3 gets contents of cell
     */
    l = b->left;
    if(n2 != Z) {
        regalloc(n1, l, nn);
        reglcgen(n2, l, Z);
        regalloc(n3, l, Z);
        gmove(n2, n3);
        gmove(n3, n1);
    } else {
        regalloc(n1, l, nn);
        cgen(l, n1);
    }
    if(b->type->shift == 0 && typeu[b->type->etype]) {
        v = ~0 + (1L << b->type->nbits);
        gopcode(OAND, types[TLONG], nodconst(v), n1);
    } else {
        sh = 32 - b->type->shift - b->type->nbits;
        if(sh > 0)
            gopcode(OASHL, types[TLONG], nodconst(sh), n1);
        sh += b->type->shift;
        if(sh > 0)
            if(typeu[b->type->etype])
                gopcode(OLSHR, types[TLONG], nodconst(sh), n1);
            else
                gopcode(OASHR, types[TLONG], nodconst(sh), n1);
    }
}
@
% >>

<<function [[bitstore]](x86)>>=
void
bitstore(Node *b, Node *n1, Node *n2, Node *n3, Node *nn)
{
    long v;
    Node nod;
    int sh;

    regalloc(&nod, b->left, Z);
    v = ~0 + (1L << b->type->nbits);
    gopcode(OAND, types[TLONG], nodconst(v), n1);
    gmove(n1, &nod);
    if(nn != Z)
        gmove(n1, nn);
    sh = b->type->shift;
    if(sh > 0)
        gopcode(OASHL, types[TLONG], nodconst(sh), &nod);
    v <<= sh;
    gopcode(OAND, types[TLONG], nodconst(~v), n3);
    gopcode(OOR, types[TLONG], n3, &nod);
    gmove(&nod, n2);

    regfree(&nod);
    regfree(n1);
    regfree(n2);
    regfree(n3);
}
@

% >> >>

<<function [[outstring]](x86)>>=
long
outstring(char *s, long n)
{
    long r;

    if(suppress)
        return nstring;
    r = nstring;
    while(n) {
        string[mnstring] = *s++;
        mnstring++;
        nstring++;
        if(mnstring >= NSNAME) {
            gpseudo(ADATA, symstring, nodconst(0L));
            p->from.offset += nstring - NSNAME;
            p->from.scale = NSNAME;
            p->to.type = D_SCONST;
            memmove(p->to.sval, string, NSNAME);
            mnstring = 0;
        }
        n--;
    }
    return r;
}
@

<<function [[gextern]](x86)>>=
void
gextern(Sym *s, Node *a, long o, long w)
{
    if(a->op == OCONST && typev[a->type->etype]) {
        gpseudo(ADATA, s, lo64(a));
        p->from.offset += o;
        p->from.scale = 4;
        gpseudo(ADATA, s, hi64(a));
        p->from.offset += o + 4;
        p->from.scale = 4;
        return;
    }
    gpseudo(ADATA, s, a);
    p->from.offset += o;
    p->from.scale = w;
    switch(p->to.type) {
    default:
        p->to.index = p->to.type;
        p->to.type = D_ADDR;
    case D_CONST:
    case D_FCONST:
    case D_ADDR:
        break;
    }
}
@


<<function [[align]](x86)>>=
long
align(long i, Type *t, int op)
{
    long o;
    Type *v;
    int w;

    o = i;
    w = 1;
    switch(op) {
    default:
        diag(Z, "unknown align opcode %d", op);
        break;

    case Asu2:	/* padding at end of a struct */
        w = SZ_LONG;
        if(packflg)
            w = packflg;
        break;

    case Ael1:	/* initial align of struct element */
        for(v=t; v->etype==TARRAY; v=v->link)
            ;
        w = ewidth[v->etype];
        if(w <= 0 || w >= SZ_LONG)
            w = SZ_LONG;
        if(packflg)
            w = packflg;
        break;

    case Ael2:	/* width of a struct element */
        o += t->width;
        break;

    case Aarg0:	/* initial passbyptr argument in arg list */
        if(typesuv[t->etype]) {
            o = align(o, types[TIND], Aarg1);
            o = align(o, types[TIND], Aarg2);
        }
        break;

    case Aarg1:	/* initial align of parameter */
        w = ewidth[t->etype];
        if(w <= 0 || w >= SZ_LONG) {
            w = SZ_LONG;
            break;
        }
        w = 1;		/* little endian no adjustment */
        break;

    case Aarg2:	/* width of a parameter */
        o += t->width;
        w = SZ_LONG;
        break;

    case Aaut3:	/* total align of automatic */
        o = align(o, t, Ael1);
        o = align(o, t, Ael2);
        break;
    }
    o = round(o, w);
    if(debug['A'])
        print("align %s %ld %T = %ld\n", bnames[op], i, t, o);
    return o;
}
@



%-------------------------------------------------------------

<<8c/swt.c>>=
#include "gc.h"

<<function [[swit1]](x86)>>

<<function [[bitload]](x86)>>

<<function [[bitstore]](x86)>>

<<function [[outstring]](x86)>>

<<function [[gextern]](x86)>>

void	zname(Biobuf*, Sym*, int);
void	zaddr(Biobuf*, Adr*, int);
void	outhist(Biobuf*);

<<struct [[Htab]]>>

<<function [[outcode]](x86)>>

<<function [[outhist]](x86)>>

<<function [[zname]](x86)>>

<<function [[zaddr]](x86)>>

<<function [[align]](x86)>>

<<function [[maxround]]>>
@


\subsection*{[[8c/mul.c]]}

%-------------------------------------------------------------

<<8c/mul.c>>=
#include "gc.h"

typedef struct	Malg	Malg;
typedef struct	Mparam	Mparam;

<<struct [[Malg]](x86)>>

<<struct [[Mparam]](x86)>>

<<global [[multab]](x86)>>
<<global [[mulptr]](x86)>>

<<global [[malgs]](x86)>>

<<function [[lowbit]](x86)>>

<<function [[genmuladd]](x86)>>

<<function [[mulparam]](x86)>>

<<function [[m0]](x86)>>

<<function [[m1]](x86)>>

<<function [[m2]](x86)>>

<<function [[shiftit]](x86)>>

<<function [[mulgen1]](x86)>>

<<function [[mulgen]](x86)>>
@


\subsection*{[[8c/div.c]]}

%-------------------------------------------------------------

<<8c/div.c>>=
#include "gc.h"

<<function [[TN]](x86)>>
<<constant [[T31]](x86)>>
<<constant [[T32]](x86)>>

<<function [[multiplier]](x86)>>

<<function [[sdiv]](x86)>>

<<function [[udiv]](x86)>>

<<function [[sdivgen]](x86)>>

<<function [[udivgen]](x86)>>

<<function [[sext]](x86)>>

<<function [[sdiv2]](x86)>>

<<function [[smod2]](x86)>>
@


\subsection*{[[8c/reg.c]]}


<<struct [[Regopt_helper]](x86)>>=
struct Regopt_helper {
        long	m;
        long	c;
        Reg*	p;
};
@

<<function [[regopt]](x86)>>=
void
regopt(Prog *p)
{
    Reg *r, *r1, *r2;
    Prog *p1;
    int i, z;
    long initpc, val, npc;
    ulong vreg;
    Bits bit;
    struct Regopt_helper log5[6], *lp;

    firstr = R;
    lastr = R;
    nvar = 0;
    regbits = RtoB(D_SP) | RtoB(D_AX);
    for(z=0; z<BITS; z++) {
        externs.b[z] = 0;
        params.b[z] = 0;
        consts.b[z] = 0;
        addrs.b[z] = 0;
    }

    /*
     * pass 1
     * build aux data structure
     * allocate pcs
     * find use and set of variables
     */
    val = 5L * 5L * 5L * 5L * 5L;
    lp = log5;
    for(i=0; i<5; i++) {
        lp->m = val;
        lp->c = 0;
        lp->p = R;
        val /= 5L;
        lp++;
    }
    val = 0;
    for(; p != P; p = p->link) {
        switch(p->as) {
        case ADATA:
        case AGLOBL:
        case ANAME:
        case ASIGNAME:
            continue;
        }
        r = rega();
        if(firstr == R) {
            firstr = r;
            lastr = r;
        } else {
            lastr->link = r;
            r->p1 = lastr;
            lastr->s1 = r;
            lastr = r;
        }
        r->prog = p;
        r->pc = val;
        val++;

        lp = log5;
        for(i=0; i<5; i++) {
            lp->c--;
            if(lp->c <= 0) {
                lp->c = lp->m;
                if(lp->p != R)
                    lp->p->log5 = r;
                lp->p = r;
                (lp+1)->c = 0;
                break;
            }
            lp++;
        }

        r1 = r->p1;
        if(r1 != R)
        switch(r1->prog->as) {
        case ARET:
        case AJMP:
        case AIRETL:
            r->p1 = R;
            r1->s1 = R;
        }

        bit = mkvar(r, &p->from, p->as==AMOVL);
        if(bany(&bit))
        switch(p->as) {
        /*
         * funny
         */
        case ALEAL:
            for(z=0; z<BITS; z++)
                addrs.b[z] |= bit.b[z];
            break;

        /*
         * left side read
         */
        default:
            for(z=0; z<BITS; z++)
                r->use1.b[z] |= bit.b[z];
            break;
        }

        bit = mkvar(r, &p->to, 0);
        if(bany(&bit))
        switch(p->as) {
        default:
            diag(Z, "reg: unknown op: %A", p->as);
            break;

        /*
         * right side read
         */
        case ACMPB:
        case ACMPL:
        case ACMPW:
            for(z=0; z<BITS; z++)
                r->use2.b[z] |= bit.b[z];
            break;

        /*
         * right side write
         */
        case ANOP:
        case AMOVL:
        case AMOVB:
        case AMOVW:
        case AMOVBLSX:
        case AMOVBLZX:
        case AMOVWLSX:
        case AMOVWLZX:
            for(z=0; z<BITS; z++)
                r->set.b[z] |= bit.b[z];
            break;

        /*
         * right side read+write
         */
        case AADDB:
        case AADDL:
        case AADDW:
        case AANDB:
        case AANDL:
        case AANDW:
        case ASUBB:
        case ASUBL:
        case ASUBW:
        case AORB:
        case AORL:
        case AORW:
        case AXORB:
        case AXORL:
        case AXORW:
        case ASALB:
        case ASALL:
        case ASALW:
        case ASARB:
        case ASARL:
        case ASARW:
        case AROLB:
        case AROLL:
        case AROLW:
        case ARORB:
        case ARORL:
        case ARORW:
        case ASHLB:
        case ASHLL:
        case ASHLW:
        case ASHRB:
        case ASHRL:
        case ASHRW:
        case AIMULL:
        case AIMULW:
        case ANEGL:
        case ANOTL:
        case AADCL:
        case ASBBL:
            for(z=0; z<BITS; z++) {
                r->set.b[z] |= bit.b[z];
                r->use2.b[z] |= bit.b[z];
            }
            break;

        /*
         * funny
         */
        case AFMOVDP:
        case AFMOVFP:
        case AFMOVLP:
        case AFMOVVP:
        case AFMOVWP:
        case ACALL:
            for(z=0; z<BITS; z++)
                addrs.b[z] |= bit.b[z];
            break;
        }

        switch(p->as) {
        case AIMULL:
        case AIMULW:
            if(p->to.type != D_NONE)
                break;

        case AIDIVB:
        case AIDIVL:
        case AIDIVW:
        case AIMULB:
        case ADIVB:
        case ADIVL:
        case ADIVW:
        case AMULB:
        case AMULL:
        case AMULW:

        case ACWD:
        case ACDQ:
            r->regu |= RtoB(D_AX) | RtoB(D_DX);
            break;

        case AREP:
        case AREPN:
        case ALOOP:
        case ALOOPEQ:
        case ALOOPNE:
            r->regu |= RtoB(D_CX);
            break;

        case AMOVSB:
        case AMOVSL:
        case AMOVSW:
        case ACMPSB:
        case ACMPSL:
        case ACMPSW:
            r->regu |= RtoB(D_SI) | RtoB(D_DI);
            break;

        case ASTOSB:
        case ASTOSL:
        case ASTOSW:
        case ASCASB:
        case ASCASL:
        case ASCASW:
            r->regu |= RtoB(D_AX) | RtoB(D_DI);
            break;

        case AINSB:
        case AINSL:
        case AINSW:
        case AOUTSB:
        case AOUTSL:
        case AOUTSW:
            r->regu |= RtoB(D_DI) | RtoB(D_DX);
            break;

        case AFSTSW:
        case ASAHF:
            r->regu |= RtoB(D_AX);
            break;
        }
    }
    if(firstr == R)
        return;
    initpc = pc - val;
    npc = val;

    /*
     * pass 2
     * turn branch references to pointers
     * build back pointers
     */
    for(r = firstr; r != R; r = r->link) {
        p = r->prog;
        if(p->to.type == D_BRANCH) {
            val = p->to.offset - initpc;
            r1 = firstr;
            while(r1 != R) {
                r2 = r1->log5;
                if(r2 != R && val >= r2->pc) {
                    r1 = r2;
                    continue;
                }
                if(r1->pc == val)
                    break;
                r1 = r1->link;
            }
            if(r1 == R) {
                nearln = p->lineno;
                diag(Z, "ref not found\n%P", p);
                continue;
            }
            if(r1 == r) {
                nearln = p->lineno;
                diag(Z, "ref to self\n%P", p);
                continue;
            }
            r->s2 = r1;
            r->p2link = r1->p2;
            r1->p2 = r;
        }
    }
    if(debug['R']) {
        p = firstr->prog;
        print("\n%L %D\n", p->lineno, &p->from);
    }

    /*
     * pass 2.5
     * find looping structure
     */
    for(r = firstr; r != R; r = r->link)
        r->active = 0;
    change = 0;
    loopit(firstr, npc);
    if(debug['R'] && debug['v']) {
        print("\nlooping structure:\n");
        for(r = firstr; r != R; r = r->link) {
            print("%ld:%P", r->loop, r->prog);
            for(z=0; z<BITS; z++)
                bit.b[z] = r->use1.b[z] |
                       r->use2.b[z] |
                       r->set.b[z];
            if(bany(&bit)) {
                print("\t");
                if(bany(&r->use1))
                    print(" u1=%B", r->use1);
                if(bany(&r->use2))
                    print(" u2=%B", r->use2);
                if(bany(&r->set))
                    print(" st=%B", r->set);
            }
            print("\n");
        }
    }

    /*
     * pass 3
     * iterate propagating usage
     * 	back until flow graph is complete
     */
loop1:
    change = 0;
    for(r = firstr; r != R; r = r->link)
        r->active = 0;
    for(r = firstr; r != R; r = r->link)
        if(r->prog->as == ARET)
            prop(r, zbits, zbits);
loop11:
    /* pick up unreachable code */
    i = 0;
    for(r = firstr; r != R; r = r1) {
        r1 = r->link;
        if(r1 && r1->active && !r->active) {
            prop(r, zbits, zbits);
            i = 1;
        }
    }
    if(i)
        goto loop11;
    if(change)
        goto loop1;


    /*
     * pass 4
     * iterate propagating register/variable synchrony
     * 	forward until graph is complete
     */
loop2:
    change = 0;
    for(r = firstr; r != R; r = r->link)
        r->active = 0;
    synch(firstr, zbits);
    if(change)
        goto loop2;


    /*
     * pass 5
     * isolate regions
     * calculate costs (paint1)
     */
    r = firstr;
    if(r) {
        for(z=0; z<BITS; z++)
            bit.b[z] = (r->refahead.b[z] | r->calahead.b[z]) &
              ~(externs.b[z] | params.b[z] | addrs.b[z] | consts.b[z]);
        if(bany(&bit)) {
            nearln = r->prog->lineno;
            warn(Z, "used and not set: %B", bit);
            if(debug['R'] && !debug['w'])
                print("used and not set: %B\n", bit);
        }
    }
    if(debug['R'] && debug['v'])
        print("\nprop structure:\n");
    for(r = firstr; r != R; r = r->link)
        r->act = zbits;
    rgp = region;
    nregion = 0;
    for(r = firstr; r != R; r = r->link) {
        if(debug['R'] && debug['v']) {
            print("%P\t", r->prog);
            if(bany(&r->set))
                print("s:%B ", r->set);
            if(bany(&r->refahead))
                print("ra:%B ", r->refahead);
            if(bany(&r->calahead))
                print("ca:%B ", r->calahead);
            print("\n");
        }
        for(z=0; z<BITS; z++)
            bit.b[z] = r->set.b[z] &
              ~(r->refahead.b[z] | r->calahead.b[z] | addrs.b[z]);
        if(bany(&bit)) {
            nearln = r->prog->lineno;
            warn(Z, "set and not used: %B", bit);
            if(debug['R'])
                print("set and not used: %B\n", bit);
            excise(r);
        }
        for(z=0; z<BITS; z++)
            bit.b[z] = LOAD(r) & ~(r->act.b[z] | addrs.b[z]);
        while(bany(&bit)) {
            i = bnum(bit);
            rgp->enter = r;
            rgp->varno = i;
            change = 0;
            if(debug['R'] && debug['v'])
                print("\n");
            paint1(r, i);
            bit.b[i/32] &= ~(1L<<(i%32));
            if(change <= 0) {
                if(debug['R'])
                    print("%L$%d: %B\n",
                        r->prog->lineno, change, blsh(i));
                continue;
            }
            rgp->cost = change;
            nregion++;
            if(nregion >= NRGN) {
                warn(Z, "too many regions");
                goto brk;
            }
            rgp++;
        }
    }
brk:
    qsort(region, nregion, sizeof(region[0]), rcmp);

    /*
     * pass 6
     * determine used registers (paint2)
     * replace code (paint3)
     */
    rgp = region;
    for(i=0; i<nregion; i++) {
        bit = blsh(rgp->varno);
        vreg = paint2(rgp->enter, rgp->varno);
        vreg = allreg(vreg, rgp);
        if(debug['R']) {
            print("%L$%d %R: %B\n",
                rgp->enter->prog->lineno,
                rgp->cost,
                rgp->regno,
                bit);
        }
        if(rgp->regno != 0)
            paint3(rgp->enter, rgp->varno, vreg, rgp->regno);
        rgp++;
    }
    /*
     * pass 7
     * peep-hole on basic block
     */
    if(!debug['R'] || debug['P'])
        peep();

    /*
     * pass 8
     * recalculate pc
     */
    val = initpc;
    for(r = firstr; r != R; r = r1) {
        r->pc = val;
        p = r->prog;
        p1 = P;
        r1 = r->link;
        if(r1 != R)
            p1 = r1->prog;
        for(; p != p1; p = p->link) {
            switch(p->as) {
            default:
                val++;
                break;

            case ANOP:
            case ADATA:
            case AGLOBL:
            case ANAME:
            case ASIGNAME:
                break;
            }
        }
    }
    pc = val;

    /*
     * fix up branches
     */
    if(debug['R'])
        if(bany(&addrs))
            print("addrs: %B\n", addrs);

    r1 = 0; /* set */
    for(r = firstr; r != R; r = r->link) {
        p = r->prog;
        if(p->to.type == D_BRANCH)
            p->to.offset = r->s2->pc;
        r1 = r;
    }

    /*
     * last pass
     * eliminate nops
     * free aux structures
     */
    for(p = firstr->prog; p != P; p = p->link){
        while(p->link && p->link->as == ANOP)
            p->link = p->link->link;
    }
    if(r1 != R) {
        r1->link = freer;
        freer = firstr;
    }
}
@

<<function [[addmove]](x86)>>=
/*
 * add mov b,rn
 * just after r
 */
void
addmove(Reg *r, int bn, int rn, int f)
{
    Prog *p, *p1;
    Adr *a;
    Var *v;

    p1 = alloc(sizeof(*p1));
    *p1 = zprog;
    p = r->prog;

    p1->link = p->link;
    p->link = p1;
    p1->lineno = p->lineno;

    v = var + bn;

    a = &p1->to;
    a->sym = v->sym;
    a->offset = v->offset;
    a->etype = v->etype;
    a->type = v->symkind;

    p1->as = AMOVL;
    if(v->etype == TCHAR || v->etype == TUCHAR)
        p1->as = AMOVB;
    if(v->etype == TSHORT || v->etype == TUSHORT)
        p1->as = AMOVW;

    p1->from.type = rn;
    if(!f) {
        p1->from = *a;
        *a = zprog.from;
        a->type = rn;
        if(v->etype == TUCHAR)
            p1->as = AMOVB;
        if(v->etype == TUSHORT)
            p1->as = AMOVW;
    }
    if(debug['R'])
        print("%P\t.a%P\n", p, p1);
}
@

<<function [[doregbits]](x86)>>=
ulong
doregbits(int r)
{
    ulong b;

    b = 0;
    if(r >= D_INDIR)
        r -= D_INDIR;
    if(r >= D_AX && r <= D_DI)
        b |= RtoB(r);
    else
    if(r >= D_AL && r <= D_BL)
        b |= RtoB(r-D_AL+D_AX);
    else
    if(r >= D_AH && r <= D_BH)
        b |= RtoB(r-D_AH+D_AX);
    return b;
}
@

<<function [[mkvar]](x86)>>=
Bits
mkvar(Reg *r, Adr *a, int isro)
{
    Var *v;
    int i, t, n, et, z;
    long o;
    Bits bit;
    Sym *s;

    /*
     * mark registers used
     */
    t = a->type;
    r->regu |= doregbits(t);
    r->regu |= doregbits(a->index);
    et = a->etype;

    switch(t) {
    default:
        goto none;
    case D_INDIR+D_GS:
        if(!isro || 1)
            goto none;
        n = t;
        {static Sym er; a->sym = &er;}
        a->sym->name = "$extreg"; // $
        break;
    case D_ADDR:
        a->type = a->index;
        bit = mkvar(r, a, 0);
        for(z=0; z<BITS; z++)
            addrs.b[z] |= bit.b[z];
        a->type = t;
        goto none;
    case D_EXTERN:
    case D_STATIC:
    case D_PARAM:
    case D_AUTO:
        n = t;
        break;
    }
    s = a->sym;
    if(s == S)
        goto none;
    if(s->name[0] == '.')
        goto none;
    o = a->offset;
    v = var;
    for(i=0; i<nvar; i++) {
        if(s == v->sym)
        if(n == v->symkind)
        if(o == v->offset)
            goto out;
        v++;
    }
    if(nvar >= NVAR) {
        if(debug['w'] > 1 && s)
            warn(Z, "variable not optimized: %s", s->name);
        goto none;
    }
    i = nvar;
    nvar++;
    v = &var[i];
    v->sym = s;
    v->offset = o;
    v->symkind = n;
    v->etype = et;
    if(debug['R'])
        print("bit=%2d et=%2d %D\n", i, et, a);

out:
    bit = blsh(i);
    if(n == D_EXTERN || n == D_STATIC)
        for(z=0; z<BITS; z++)
            externs.b[z] |= bit.b[z];
    if(n == D_PARAM)
        for(z=0; z<BITS; z++)
            params.b[z] |= bit.b[z];
    if(v->etype != et || !typechlpfd[et])	/* funny punning */
        for(z=0; z<BITS; z++)
            addrs.b[z] |= bit.b[z];
    return bit;

none:
    return zbits;
}
@

<<function [[prop]](x86)>>=
void
prop(Reg *r, Bits ref, Bits cal)
{
    Reg *r1, *r2;
    int z;

    for(r1 = r; r1 != R; r1 = r1->p1) {
        for(z=0; z<BITS; z++) {
            ref.b[z] |= r1->refahead.b[z];
            if(ref.b[z] != r1->refahead.b[z]) {
                r1->refahead.b[z] = ref.b[z];
                change++;
            }
            cal.b[z] |= r1->calahead.b[z];
            if(cal.b[z] != r1->calahead.b[z]) {
                r1->calahead.b[z] = cal.b[z];
                change++;
            }
        }
        switch(r1->prog->as) {
        case ACALL:
            for(z=0; z<BITS; z++) {
                cal.b[z] |= ref.b[z] | externs.b[z];
                ref.b[z] = 0;
            }
            break;

        case ATEXT:
            for(z=0; z<BITS; z++) {
                cal.b[z] = 0;
                ref.b[z] = 0;
            }
            break;

        case ARET:
            for(z=0; z<BITS; z++) {
                cal.b[z] = externs.b[z];
                ref.b[z] = 0;
            }
        }
        for(z=0; z<BITS; z++) {
            ref.b[z] = (ref.b[z] & ~r1->set.b[z]) |
                r1->use1.b[z] | r1->use2.b[z];
            cal.b[z] &= ~(r1->set.b[z] | r1->use1.b[z] | r1->use2.b[z]);
            r1->refbehind.b[z] = ref.b[z];
            r1->calbehind.b[z] = cal.b[z];
        }
        if(r1->active)
            break;
        r1->active = 1;
    }
    for(; r != r1; r = r->p1)
        for(r2 = r->p2; r2 != R; r2 = r2->p2link)
            prop(r2, r->refbehind, r->calbehind);
}
@
%$




<<function [[allreg]](x86)>>=
ulong
allreg(ulong b, Rgn *r)
{
    Var *v;
    int i;

    v = var + r->varno;
    r->regno = 0;
    switch(v->etype) {

    default:
        diag(Z, "unknown etype %d/%d", bitno(b), v->etype);
        break;

    case TCHAR:
    case TUCHAR:
    case TSHORT:
    case TUSHORT:
    case TINT:
    case TUINT:
    case TLONG:
    case TULONG:
    case TIND:
    case TARRAY:
        i = BtoR(~b);
        if(i && r->cost > 0) {
            r->regno = i;
            return RtoB(i);
        }
        break;

    case TDOUBLE:
    case TFLOAT:
        break;
    }
    return 0;
}
@

<<function [[paint1]](x86)>>=
void
paint1(Reg *r, int bn)
{
    Reg *r1;
    Prog *p;
    int z;
    ulong bb;

    z = bn/32;
    bb = 1L<<(bn%32);
    if(r->act.b[z] & bb)
        return;
    for(;;) {
        if(!(r->refbehind.b[z] & bb))
            break;
        r1 = r->p1;
        if(r1 == R)
            break;
        if(!(r1->refahead.b[z] & bb))
            break;
        if(r1->act.b[z] & bb)
            break;
        r = r1;
    }

    if(LOAD(r) & ~(r->set.b[z]&~(r->use1.b[z]|r->use2.b[z])) & bb) {
        change -= CLOAD * r->loop;
        if(debug['R'] && debug['v'])
            print("%ld%P\tld %B $%d\n", r->loop,
                r->prog, blsh(bn), change);
    }
    for(;;) {
        r->act.b[z] |= bb;
        p = r->prog;

        if(r->use1.b[z] & bb) {
            change += CREF * r->loop;
            if(p->as == AFMOVL || p->as == AFMOVW)
                if(BtoR(bb) != D_F0)
                    change = -CINF;
            if(debug['R'] && debug['v'])
                print("%ld%P\tu1 %B $%d\n", r->loop,
                    p, blsh(bn), change);
        }

        if((r->use2.b[z]|r->set.b[z]) & bb) {
            change += CREF * r->loop;
            if(p->as == AFMOVL || p->as == AFMOVW)
                if(BtoR(bb) != D_F0)
                    change = -CINF;
            if(debug['R'] && debug['v'])
                print("%ld%P\tu2 %B $%d\n", r->loop,
                    p, blsh(bn), change);
        }

        if(STORE(r) & r->regdiff.b[z] & bb) {
            change -= CLOAD * r->loop;
            if(p->as == AFMOVL || p->as == AFMOVW)
                if(BtoR(bb) != D_F0)
                    change = -CINF;
            if(debug['R'] && debug['v'])
                print("%ld%P\tst %B $%d\n", r->loop,
                    p, blsh(bn), change);
        }

        if(r->refbehind.b[z] & bb)
            for(r1 = r->p2; r1 != R; r1 = r1->p2link)
                if(r1->refahead.b[z] & bb)
                    paint1(r1, bn);

        if(!(r->refahead.b[z] & bb))
            break;
        r1 = r->s2;
        if(r1 != R)
            if(r1->refbehind.b[z] & bb)
                paint1(r1, bn);
        r = r->s1;
        if(r == R)
            break;
        if(r->act.b[z] & bb)
            break;
        if(!(r->refbehind.b[z] & bb))
            break;
    }
}
@

<<function [[regset]](x86)>>=
ulong
regset(Reg *r, ulong bb)
{
    ulong b, set;
    Adr v;
    int c;

    set = 0;
    v = zprog.from;
    while(b = bb & ~(bb-1)) {
        v.type = BtoR(b);
        c = copyu(r->prog, &v, A);
        if(c == 3)
            set |= b;
        bb &= ~b;
    }
    return set;
}
@

<<function [[reguse]](x86)>>=
ulong
reguse(Reg *r, ulong bb)
{
    ulong b, set;
    Adr v;
    int c;

    set = 0;
    v = zprog.from;
    while(b = bb & ~(bb-1)) {
        v.type = BtoR(b);
        c = copyu(r->prog, &v, A);
        if(c == 1 || c == 2 || c == 4)
            set |= b;
        bb &= ~b;
    }
    return set;
}
@

<<function [[paint2]](x86)>>=
ulong
paint2(Reg *r, int bn)
{
    Reg *r1;
    int z;
    ulong bb, vreg, x;

    z = bn/32;
    bb = 1L << (bn%32); // >>
    vreg = regbits;
    if(!(r->act.b[z] & bb))
        return vreg;
    for(;;) {
        if(!(r->refbehind.b[z] & bb))
            break;
        r1 = r->p1;
        if(r1 == R)
            break;
        if(!(r1->refahead.b[z] & bb))
            break;
        if(!(r1->act.b[z] & bb))
            break;
        r = r1;
    }
    for(;;) {
        r->act.b[z] &= ~bb;

        vreg |= r->regu;

        if(r->refbehind.b[z] & bb)
            for(r1 = r->p2; r1 != R; r1 = r1->p2link)
                if(r1->refahead.b[z] & bb)
                    vreg |= paint2(r1, bn);

        if(!(r->refahead.b[z] & bb))
            break;
        r1 = r->s2;
        if(r1 != R)
            if(r1->refbehind.b[z] & bb)
                vreg |= paint2(r1, bn);
        r = r->s1;
        if(r == R)
            break;
        if(!(r->act.b[z] & bb))
            break;
        if(!(r->refbehind.b[z] & bb))
            break;
    }

    bb = vreg;
    for(; r; r=r->s1) {
        x = r->regu & ~bb;
        if(x) {
            vreg |= reguse(r, x);
            bb |= regset(r, x);
        }
    }
    return vreg;
}
@


<<function [[addreg]](x86)>>=
void
addreg(Adr *a, int rn)
{

    a->sym = 0;
    a->offset = 0;
    a->type = rn;
}
@

<<function [[RtoB]](x86)>>=
long
RtoB(int r)
{

    if(r < D_AX || r > D_DI)
        return 0;
    return 1L << (r-D_AX);
}
@

% >>

<<function [[BtoR]](x86)>>=
int
BtoR(long b)
{

    b &= 0xffL;
    if(b == 0)
        return 0;
    return bitno(b) + D_AX;
}
@


%-------------------------------------------------------------

<<8c/reg.c>>=
#include "gc.h"

void	addreg(Adr*, int);
int	rcmp(const void*, const void*);
void	addmove(Reg*, int, int, int);
Bits	mkvar(Reg*, Adr*, int);
void	prop(Reg*, Bits, Bits);
void	loopit(Reg*, long);
void	synch(Reg*, Bits);
ulong	allreg(ulong, Rgn*);
void	paint1(Reg*, int);
ulong	paint2(Reg*, int);
void	paint3(Reg*, int, long, int);

long	RtoB(int);
//long	FtoB(int);
int	BtoR(long);
//int	BtoF(long);

<<function [[rega]]>>

<<function [[rcmp]]>>

<<struct [[Regopt_helper]](x86)>>

<<function [[regopt]](x86)>>

<<function [[addmove]](x86)>>

<<function [[doregbits]](x86)>>

<<function [[mkvar]](x86)>>

<<function [[prop]](x86)>>

<<function [[postorder]]>>

<<function [[rpolca]]>>

<<function [[doms]]>>

<<function [[loophead]]>>

<<function [[loopmark]]>>

<<function [[loopit]]>>

<<function [[synch]]>>

<<function [[allreg]](x86)>>

<<function [[paint1]](x86)>>

<<function [[regset]](x86)>>

<<function [[reguse]](x86)>>

<<function [[paint2]](x86)>>

<<function [[paint3]]>>

<<function [[addreg]](x86)>>

<<function [[RtoB]](x86)>>

<<function [[BtoR]](x86)>>
@
% >>

\subsection*{[[8c/cgen64.c]]}

%-------------------------------------------------------------

<<8c/cgen64.c>>=
#include "gc.h"

long	lo64v(Node*);
long	hi64v(Node*);

<<function [[zeroregm]](x86)>>

<<function [[vaddr]](x86)>>

<<function [[hi64v]](x86)>>

<<function [[lo64v]](x86)>>

<<function [[hi64]](x86)>>

<<function [[lo64]](x86)>>

<<function [[anonreg]](x86)>>

<<function [[regpair]](x86)>>

<<function [[evacaxdx]](x86)>>

<<function [[instpair]](x86)>>

<<function [[zapreg]](x86)>>

<<function [[freepair]](x86)>>

<<function [[loadpair]](x86)>>

<<function [[storepair]](x86)>>

<<enum [[_anon_ (8c/cgen64.c)]]>>

<<function [[whatof]](x86)>>

<<function [[reduxv]](x86)>>

<<function [[cond]](x86)>>

<<function [[vfunc]](x86)>>

<<function [[getreg]](x86)>>

<<function [[snarfreg]](x86)>>

<<enum [[_anon_ (8c/cgen64.c)]]2>>

<<global [[testi]](x86)>>

<<global [[shll00]](x86)>>

<<global [[shllc0]](x86)>>

<<global [[shllc1]](x86)>>

<<global [[shllc2]](x86)>>

<<global [[shllac3]](x86)>>

<<global [[shllac4]](x86)>>

<<global [[shll10]](x86)>>

<<global [[shlltab]](x86)>>

<<global [[shrl00]](x86)>>

<<global [[shrlc0]](x86)>>

<<global [[shrlc1]](x86)>>

<<global [[shrlc2]](x86)>>

<<global [[shrlac3]](x86)>>

<<global [[shrlac4]](x86)>>

<<global [[shrl10]](x86)>>

<<global [[shrltab]](x86)>>

<<global [[asshllgen]](x86)>>

<<global [[asshllclo]](x86)>>

<<global [[asshllc32]](x86)>>

<<global [[asshllchi]](x86)>>

<<global [[asdshllgen]](x86)>>

<<global [[asdshllclo]](x86)>>

<<global [[asdshllc32]](x86)>>

<<global [[asdshllchi]](x86)>>

<<global [[asshlltab]](x86)>>

<<global [[asshrlgen]](x86)>>

<<global [[asshrlclo]](x86)>>

<<global [[asshrlc32]](x86)>>

<<global [[asshrlchi]](x86)>>

<<global [[asdshrlgen]](x86)>>

<<global [[asdshrlclo]](x86)>>

<<global [[asdshrlc32]](x86)>>

<<global [[asdshrlchi]](x86)>>

<<global [[asshrltab]](x86)>>

<<global [[shrlargs]](x86)>>
<<global [[sarlargs]](x86)>>

<<global [[incdec]](x86)>>

<<global [[incdecpre]](x86)>>

<<global [[incdecpost]](x86)>>

<<global [[binop00]](x86)>>

<<global [[binoptmp]](x86)>>

<<global [[binop11]](x86)>>

<<global [[add0c]](x86)>>

<<global [[and0c]](x86)>>

<<global [[or0c]](x86)>>

<<global [[sub10]](x86)>>

<<global [[addca]](x86)>>

<<global [[andca]](x86)>>

<<global [[orca]](x86)>>

<<global [[subca]](x86)>>

<<global [[addac]](x86)>>

<<global [[orac]](x86)>>

<<global [[andac]](x86)>>

<<global [[ADDargs]](x86)>>
<<global [[ANDargs]](x86)>>
<<global [[ORargs]](x86)>>
<<global [[SUBargs]](x86)>>
<<global [[XORargs]](x86)>>

<<global [[ADDtab]](x86)>>

<<global [[ANDtab]](x86)>>

<<global [[ORtab]](x86)>>

<<global [[SUBtab]](x86)>>

<<global [[mulc32]](x86)>>

<<global [[mulc64]](x86)>>

<<global [[mull]](x86)>>

<<global [[castrp]](x86)>>

<<global [[castrpa]](x86)>>

<<global [[netab0i]](x86)>>

<<global [[netabii]](x86)>>

<<global [[cmptab0i]](x86)>>

<<global [[cmptabii]](x86)>>

<<global [[NEtab]](x86)>>

<<global [[cmptab]](x86)>>

<<global [[GEargs]](x86)>>
<<global [[GTargs]](x86)>>
<<global [[HIargs]](x86)>>
<<global [[HSargs]](x86)>>

<<function [[biggen]](x86)>>

<<function [[IMM]](x86)>>

<<function [[WW]](x86)>>

<<function [[cgen64]](x86)>>

<<function [[testv]](x86)>>
@


\subsection*{[[8c/cgen.c]]}

%-------------------------------------------------------------

<<8c/cgen.c>>=
#include "gc.h"

void	bcgen(Node*, int);

<<function [[cgen]](x86)>>

<<function [[reglcgen]](x86)>>

<<function [[lcgen]](x86)>>

<<function [[bcgen]]>>

<<function [[boolgen]](x86)>>

<<function [[sugen]](x86)>>
@

\fi % started at section x86
