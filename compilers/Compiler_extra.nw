\section{[[cc/]]}

\subsection{[[cc/cc.h]]}

<<constant [[YYMAXDEPTH]]>>=
#define YYMAXDEPTH	1500
@

%-------------------------------------------------------------

<<cc/cc.h>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <ctype.h>

#pragma	lib	"../cc/cc.a$O" //$

typedef	struct	Node	Node;
typedef	struct	Type	Type;
typedef	struct	Sym		Sym;
typedef	struct	Decl	Decl;
typedef	struct	Funct	Funct;
typedef	struct	Io		Io;
typedef	struct	Hist	Hist;
typedef	struct	Term	Term;
typedef	struct	Init	Init;
typedef	struct	Bits	Bits;

typedef	Rune	TRune;	/* target system type */

<<constant [[NHUNK]]>>
<<constant [[BUFSIZ]]>>
<<constant [[NSYMB]]>>
<<constant [[NHASH]]>>
<<constant [[STRINGSZ]]>>
<<constant [[HISTSZ]]>>
<<constant [[YYMAXDEPTH]]>>
<<constant [[NTERM]]>>
<<constant [[MAXALIGN]]>>

<<function [[SIGN]]>>
<<function [[MASK]]>>

<<constant [[BITS]]>>
<<constant [[NVAR]]>>
<<struct [[Bits]]>>

<<struct [[Node]]>>
<<constant [[Z]]>>

<<struct [[Sym]]>>
<<constant [[S]]>>

<<enum [[signature]]>>

<<struct [[Decl]]>>
<<constant [[D]]>>

<<struct [[Type]]>>
<<constant [[T]]>>
<<constant [[NODECL]]>>

<<struct [[Init]]>>


<<struct [[Fi]]>>
extern struct Fi fi;

<<struct [[Io]]>>
<<constant [[I]]>>

<<struct [[Hist]]>>
<<constant [[H]]>>
extern Hist*	hist;

<<struct [[Term]]>>

<<enum [[os]]>>
<<enum [[node_kind]]>>
<<enum [[type_kind]]>>
<<enum [[type_kind_bis]]>>
<<enum [[align]]>>
<<enum [[dxxx]]>>
<<enum [[storage_class]]>>
<<enum [[qualifier]]>>
<<enum [[bxxx]]>>

<<struct [[Funct]]>>

<<struct [[En]]>>
extern struct En en;

extern	int	autobn;
extern	long	autoffset;
extern	int	blockno;
extern	Decl*	dclstack;
extern	char	debug[256];
extern	Hist*	ehist;
extern	bool	firstbit;
extern	Sym*	firstarg;
extern	Type*	firstargtype;
extern	Decl*	firstdcl;
extern	Sym*	hash[NHASH];
extern	char*	hunk;
extern	char**	include;
extern	Io*	iofree;
extern	Io*	ionext;
extern	Io*	iostack;
extern	long	lastbit;
extern	char	lastclass;
extern	Type*	lastdcltype;
extern	long	lastfield;
extern	Type*	lasttype;
extern	long	lineno;
extern	long	nearln;
extern	int	maxinclude;
extern	int	nerrors;
extern	bool	newflag;
extern	long	nhunk;
extern	int	ninclude;
extern	Node*	nodproto;
extern	Node*	nodcast;
extern	Biobuf	outbuf;
extern	Biobuf	diagbuf;
extern	char*	outfile;
extern	char*	pathname;
extern	int	peekc;
extern	long	stkoff;
extern	Type*	strf;
extern	Type*	strl;
extern	char	symb[NSYMB];
extern	Sym*	symstring;
extern	int	taggen;
extern	Type*	tfield;
extern	Type*	tufield;
extern	int	thechar;
extern	char*	thestring;
extern	Type*	thisfntype;
extern	long	thunk;
extern	Type*	types[NTYPE];

extern	Type*	fntypes[NTYPE];
extern	Node*	initlist;
extern	Term	term[NTERM];
extern	int	nterm;
extern	int	packflg;
extern	int	fproundflg;
extern	bool	profileflg;
extern	int	ncontin;
extern	int	canreach;
extern	int	warnreach;
extern	Bits	zbits;

extern	char	*onames[], *tnames[], *gnames[];
extern	char	*cnames[], *qnames[], *bnames[];

extern	char	comrel[], invrel[], logrel[];
extern	long	ncast[], tadd[], tand[];
extern	long	targ[], tasadd[], tasign[], tcast[];
extern	long	tdot[], tfunct[], tindir[], tmul[];
extern	long	tnot[], trel[], tsub[];

extern	char	typeaf[];
extern	char	typefd[];
extern	char	typei[];
extern	char	typesu[];
extern	char	typesuv[];
extern	char	typeu[];
extern	char	typev[];
extern	char	typeilp[];
extern	char	typechl[];

// not used on ARM
extern	char	typechlv[];
extern	char	typeil[];

extern	char	typechlp[];
extern	char	typechlpfd[];

extern	char*	typeswitch;
extern	char*	typeword;
extern	char*	typecmplx;

extern	ulong	thash1;
extern	ulong	thash2;
extern	ulong	thash3;
extern	ulong	thash[];

/*
 *	compat.c/unix.c/windows.c
 */
int	mywait(int*);
int	mycreat(char*, int);
int	myaccess(char*);
int	pathchar(void);
bool	systemtype(int);

// utils.c
void	gethunk(void);
void*	allocn(void*, long, long);
void*	alloc(long);
void	errorexit(void);
void	yyerror(char*, ...);

/*
 *	parser
 */
//@Scheck: def in y.tab.c from cc.y
int	yyparse(void);

/*
 *	lex.c
 */
long	yylex(void);

Sym*	lookup(void);
Sym*	slookup(char*);

int	filbuf(void);
int	getc(void);
int	getnsc(void);
void	newfile(char*, int);
void	newio(void);
void	pushio(void);
void	unget(int);

// used by dpchk.c
long	getr(void);

//!!!! (hmmm in lex.c, as well as cinit(), compile())
void	main(int, char*[]);


/*
 * mac.c
 */
void	dodefine(char*);
void	domacro(void);
void	linehist(char*, int);
void	macexpand(Sym*, char*);

// for dpchk.c
Sym*	getsym(void);
long	getnsn(void);

/*
 * dcl.c
 */
//@Scheck: useful, used by cc.y
Type*	tcopy(Type*);
//@Scheck: useful, used by cc.y
Node*	doinit(Sym*, Type*, long, Node*);
//@Scheck: useful, used by cc.y
void	adecl(int, Type*, Sym*);
void	argmark(Node*, int);
Node*	dcllabel(Sym*, int);
Node*	dodecl(void(*)(int, Type*, Sym*), int, Type*, Node*);
//@Scheck: useful, used by cc.y
Sym*	mkstatic(Sym*);
void	doenum(Sym*, Node*);
void	snap(Type*);
Type*	dotag(Sym*, int, int);
void	edecl(int, Type*, Sym*);
void	markdcl(void);
//@Scheck: useful, used by cc.y
void	pdecl(int, Type*, Sym*);
Node*	revertdcl(void);
long	round(long, int);
int	sametype(Type*, Type*);
ulong	sign(Sym*);
ulong	signature(Type*);
void	sualign(Type*);
void	xdecl(int, Type*, Sym*);
Node*	contig(Sym*, Node*, long);

/*
 * com.c
 */
void	ccom(Node*);
void	complex(Node*);
int	tcom(Node*);
int	tcoma(Node*, Node*, Type*, int);
int	tcomo(Node*, int);
void	constas(Node*, Type*, Type*);
Node*	uncomma(Node*);

/*
 * con.c
 */
void	acom(Node*);
void	evconst(Node*);

/*
 * funct.c
 */
int	isfunct(Node*);
void	dclfunct(Type*, Sym*);

/*
 * sub.c
 */
void	arith(Node*, int);
int	deadheads(Node*);
Type*	dotsearch(Sym*, Type*, Node*, long*);
Node*	invert(Node*);
int	bitno(long);
void	makedot(Node*, Type*, long);
int	mixedasop(Type*, Type*);
Node*	new(int, Node*, Node*);
Node*	new1(int, Node*, Node*);
int	nilcast(Type*, Type*);
int	nocast(Type*, Type*);
void	prtree(Node*, char*);
void	prtree1(Node*, int, int);
void	relcon(Node*, Node*);
int	relindex(int);
//@Scheck: useful, used by cc.y
int	simpleg(long);
Type*	garbt(Type*, long);
int	simplec(long);
Type*	simplet(long);
int	stcompat(Node*, Type*, Type*, long[]);
int	tcompat(Node*, Type*, Type*, long[]);
void	tinit(void);
Type*	typ(int, Type*);
Type*	copytyp(Type*);
void	typeext(Type*, Node*);
void	typeext1(Type*, Node*);
int	side(Node*);
int	vconst(Node*);
int	log2(uvlong);
int	vlog(Node*);
int	topbit(ulong);
void	simplifyshift(Node*);
long	typebitor(long, long);
void	diag(Node*, char*, ...);
void	warn(Node*, char*, ...);
void	fatal(Node*, char*, ...);

/*
 * acid.c
 */
void	acidtype(Type*);
void	acidvar(Sym*);

/*
 * pickle.c
 */
void	pickletype(Type*);

/*
 * bits.c
 */
Bits	bor(Bits, Bits);
int	bany(Bits*);
int	bnum(Bits);
Bits	blsh(uint);
int	beq(Bits, Bits);
int	bset(Bits, uint);
//Bits	band(Bits, Bits);
//Bits	bnot(Bits);

/*
 * dpchk.c
 */
void dpcheck(Node*);
void arginit(void);

void pragvararg(void);
void pragpack(void);
void pragfpround(void);
void pragprofile(void);
void pragincomplete(void);

/*
 * calls to machine depend part
 */
//todo: could define an interface instantiated by each xc
void	codgen(Node*, Node*);
void	gclean(void);
void	gextern(Sym*, Node*, long, long);
void	ginit(void);
long	outstring(char*, long);
long	outlstring(TRune*, long);
void	xcom(Node*);
long	exreg(Type*);
long	align(long, Type*, int);
long	maxround(long, long);

extern	schar	ewidth[];

/*
 * com64
 */
int	com64(Node*);
void	com64init(void);
void	bool64(Node*);
vlong	convvtox(vlong, int);
//double	convvtof(vlong);
//vlong		convftov(double);
//double	convftox(double, int);

/*
 * machcap
 */
int	machcap(Node*);

#pragma	varargck	argpos	warn	2
#pragma	varargck	argpos	diag	2
#pragma	varargck	argpos	yyerror	1

#pragma	varargck	type	"F"	Node*
#pragma	varargck	type	"L"	long
#pragma	varargck	type	"Q"	long
#pragma	varargck	type	"O"	int
#pragma	varargck	type	"T"	Type*
#pragma	varargck	type	"|"	int
@
%$


\subsection{[[cc/globals.c]]}

%<<global fperror>>=
%//int	fperror;
%@

% was in Compiler_x86.nw but needed here

% set via pragma
<<global [[fproundflg]]>>=
int	fproundflg;
@

<<[[macprag()]] if pragma xxx>>=
if(s && strcmp(s->name, "fpround") == 0) {
    pragfpround();
    return;
}
@

% seems to be used only in x96
<<function [[pragfpround]]>>=
void
pragfpround(void)
{
    Sym *s;

    fproundflg = 0;
    s = getsym();
    if(s) {
        fproundflg = atoi(s->name+1);
        if(strcmp(s->name, "on") == 0 ||
           strcmp(s->name, "yes") == 0)
            fproundflg = 1;
    }
    while(getnsc() != '\n')
        ;
    if(debug['f'])
        if(fproundflg)
            print("%4ld: fproundflg %d\n", lineno, fproundflg);
        else
            print("%4ld: fproundflg off\n", lineno);
}
@




%-------------------------------------------------------------

<<cc/globals.c>>=
#include "cc.h"

<<global [[fi]]>>
<<global [[hist]]>>
<<global [[en]]>>

<<global [[autobn]]>>
<<global [[autoffset]]>>
<<global [[blockno]]>>
<<global [[dclstack]]>>
<<global [[debug]]>>
<<global [[ehist]]>>
<<global [[firstbit]]>>
<<global [[firstarg]]>>
<<global [[firstargtype]]>>
<<global [[firstdcl]]>>
<<global [[hash]]>>
<<global [[hunk]]>>
<<global [[include]]>>
<<global [[iofree]]>>
<<global [[ionext]]>>
<<global [[iostack]]>>
<<global [[lastbit]]>>
<<global [[lastclass]]>>
<<global [[lastdcl]]>>
<<global [[lastfield]]>>
<<global [[lasttype]]>>
<<global [[lineno]]>>
<<global [[nearln]]>>
<<global [[maxinclude]]>>
<<global [[nerrors]]>>
<<global [[newflag]]>>
<<global [[nhunk]]>>
<<global [[ninclude]]>>
<<global [[nodproto]]>>
<<global [[nodcast]]>>
<<global [[outbuf]]>>
<<global [[diagbuf]]>>
<<global [[outfile]]>>
<<global [[pathname]]>>
<<global [[peekc]]>>
<<global [[stkoff]]>>
<<global [[strf]]>>
<<global [[strl]]>>
<<global [[symb]]>>
<<global [[symstring]]>>
<<global [[taggen]]>>
<<global [[tfield]]>>
<<global [[tufield]]>>
<<global [[thechar]]>>
<<global [[thestring]]>>
<<global [[thisfn]]>>
<<global [[thunk]]>>
<<global [[types]]>>
<<global [[fntypes]]>>
<<global [[initlist]]>>
<<global [[term]]>>
<<global [[nterm]]>>
<<global [[packflg]]>>
<<global [[fproundflg]]>>
<<global [[profileflg]]>>
<<global [[ncontin]]>>
<<global [[canreach]]>>
<<global [[warnreach]]>>
<<global [[zbits]]>>

<<global [[typeswitch]]>>
<<global [[typeword]]>>
<<global [[typecmplx]]>>
@


\subsection{[[cc/omachcap.c]]}

%-------------------------------------------------------------

<<cc/omachcap.c>>=
#include	"cc.h"

/* default, like old cc */
//int
//machcap(Node*)
//{
//	return 0;
//}
@



\subsection{[[cc/compat.c]]}

%<<function calloc>>=
%//void*
%//calloc(ulong m, ulong n)
%//{
%//    return alloc(m*n);
%//}
%@
%
%<<function realloc>>=
%//void*
%//realloc(void*, ulong)
%//{
%//    fprint(2, "realloc called\n");
%//    abort();
%//    return 0;
%//}
%@
%
%<<function mallocz>>=
%/* needed when profiling */
%//void*
%//mallocz(ulong size, int clr)
%//{
%//    void *v;
%//
%//    v = alloc(size);
%//    if(clr && v != nil)
%//        memset(v, 0, size);
%//    return v;
%//}
%@


%-------------------------------------------------------------

<<cc/compat.c>>=
#include	"cc.h"

//#include	"compat"
//TODO copy paste with aa/, maybe could factorize with another lib?
//

int
myaccess(char *f)
{
 return access(f, AEXIST);
}


int
mycreat(char *n, int p)
{

 return create(n, 1, p);
}

int
mywait(int *s)
{
 int p;
 Waitmsg *w;

 if((w = wait()) == nil)
  return -1;
 else{
  p = w->pid;
  *s = 0;
  if(w->msg[0])
   *s = 1;
  free(w);
  return p;
 }
}

bool
systemtype(int sys)
{
 return sys & Plan9;
}

int
pathchar(void)
{
 return '/';
}

<<function [[malloc]]>>

<<function [[free]]>>

<<function [[setmalloctag]]>>
@

% on pathchar() :) why DOS used '\' instead of '/'
%http://blogs.msdn.com/b/larryosterman/archive/2005/06/24/432386.aspx


\subsection{[[cc/utils.c]]}

%-------------------------------------------------------------

<<cc/utils.c>>=
#include "cc.h"

<<function [[errorexit]]>>

<<function [[gethunk]]>>

<<function [[alloc]]>>

<<function [[allocn]]>>

<<function [[yyerror]]>>

@

\subsection{[[cc/mac.c]]}

%-------------------------------------------------------------

<<cc/mac.c>>=
#include	"cc.h"

//old: #include	"macbody"
//TODO copy paste with aa/, maybe could factorize with another lib?

void	macdef(void);
void	macinc(void);
void	macprag(void);
void	maclin(void);
void	macif(int);
void	macend(void);
void	macund(void);

long	getnsn(void);
Sym*	getsym(void);

<<constant [[VARMAC]]>>

<<function [[getnsn]]>>

<<function [[getsym]]>>

<<function [[getsymdots]]>>

<<function [[getcom]]>>

<<function [[dodefine]]>>

<<global [[mactab]]>>

<<function [[domacro]]>>

<<function [[macund]]>>

<<constant [[NARG]]>>
<<function [[macdef]]>>

<<function [[macexpand]]>>

<<function [[macinc]]>>

<<function [[maclin]]>>

<<function [[macif]]>>

<<function [[macprag]]>>

<<function [[macend]]>>

<<function [[linehist]]>>

@


\subsection{[[cc/sub.c]]}

%dead:
%extern	char	typechlvp[];
%extern	char	typec[];
%extern	char	typeh[];


% was in extra_x86.nw
<<function [[simplifyshift]]>>=
/*
 * try to rewrite shift & mask
 */
void
simplifyshift(Node *n)
{
    ulong c3;
    int o, s1, s2, c1, c2;

    if(!typechlp[n->type->etype])
        return;
    switch(n->op) {
    default:
        return;
    case OASHL:
        s1 = 0;
        break;
    case OLSHR:
        s1 = 1;
        break;
    case OASHR:
        s1 = 2;
        break;
    }
    if(n->right->op != OCONST)
        return;
    if(n->left->op != OAND)
        return;
    if(n->left->right->op != OCONST)
        return;
    switch(n->left->left->op) {
    default:
        return;
    case OASHL:
        s2 = 0;
        break;
    case OLSHR:
        s2 = 1;
        break;
    case OASHR:
        s2 = 2;
        break;
    }
    if(n->left->left->right->op != OCONST)
        return;

    c1 = n->right->vconst;
    c2 = n->left->left->right->vconst;
    c3 = n->left->right->vconst;

/*
    if(debug['h'])
        print("%.3o %ld %ld %d #%.lux\n",
            (s1<<3)|s2, c1, c2, topbit(c3), c3);
*/

    o = n->op;
    switch((s1<<3)|s2) {
    case 000:	/* (((e <<u c2) & c3) <<u c1) */
        c3 >>= c2;
        c1 += c2;
        if(c1 >= 32)
            break;
        goto rewrite1;

    case 002:	/* (((e >>s c2) & c3) <<u c1) */
        if(topbit(c3) >= (32-c2))
            break;
    case 001:	/* (((e >>u c2) & c3) <<u c1) */
        if(c1 > c2) {
            c3 <<= c2;
            c1 -= c2;
            o = OASHL;
            goto rewrite1;
        }
        c3 <<= c1;
        if(c1 == c2)
            goto rewrite0;
        c1 = c2-c1;
        o = OLSHR;
        goto rewrite2;

    case 022:	/* (((e >>s c2) & c3) >>s c1) */
        if(c2 <= 0)
            break;
    case 012:	/* (((e >>s c2) & c3) >>u c1) */
        if(topbit(c3) >= (32-c2))
            break;
        goto s11;
    case 021:	/* (((e >>u c2) & c3) >>s c1) */
        if(topbit(c3) >= 31 && c2 <= 0)
            break;
        goto s11;
    case 011:	/* (((e >>u c2) & c3) >>u c1) */
    s11:
        c3 <<= c2;
        c1 += c2;
        if(c1 >= 32)
            break;
        o = OLSHR;
        goto rewrite1;

    case 020:	/* (((e <<u c2) & c3) >>s c1) */
        if(topbit(c3) >= 31)
            break;
    case 010:	/* (((e <<u c2) & c3) >>u c1) */
        c3 >>= c1;
        if(c1 == c2)
            goto rewrite0;
        if(c1 > c2) {
            c1 -= c2;
            goto rewrite2;
        }
        c1 = c2 - c1;
        o = OASHL;
        goto rewrite2;
    }
    return;

rewrite0:	/* get rid of both shifts */
if(debug['<'])prtree(n, "rewrite0");
    *n = *n->left;
    n->left = n->left->left;
    n->right->vconst = c3;
    return;
rewrite1:	/* get rid of lower shift */
if(debug['<'])prtree(n, "rewrite1");
    n->left->left = n->left->left->left;
    n->left->right->vconst = c3;
    n->right->vconst = c1;
    n->op = o;
    return;
rewrite2:	/* get rid of upper shift */
if(debug['<'])prtree(n, "rewrite2");
    *n = *n->left;
    n->right->vconst = c3;
    n->left->right->vconst = c1;
    n->left->op = o;
}
@

<<global [[typechlv]]>>=
char	typechlv[NTYPE];
@
% comes from a few xxxinit,

% not used on ARM
<<global [[typeil]]>>=
char	typeil[NTYPE];
@
<<global [[typeilinit]]>>=
int	typeilinit[] =
{
    TINT, TUINT, TLONG, TULONG, -1,
};
@
<<[[tinit()]] initialise typexxx type sets>>=
for(ip=typeilinit; *ip>=0; ip++) {
    urk("typeil", nelem(typeil), *ip);
    typeil[*ip] = 1;
}
@


%-------------------------------------------------------------

<<cc/sub.c>>=
#include	"cc.h"

int	simpleg(long);
long	dotoffset(Type*, Type*, Node*);

extern	char	tab[NTYPE][NTYPE];

<<function [[new]]>>

<<function [[new1]]>>

<<function [[prtree]]>>

<<function [[prtree1]]>>

<<function [[typ]]>>

<<function [[copytyp]]>>

<<function [[garbt]]>>

<<function [[simpleg]]>>

<<function [[simplec]]>>

<<function [[simplet]]>>

<<function [[stcompat]]>>

<<function [[tcompat]]>>

<<function [[makedot]]>>

<<function [[dotsearch]]>>

<<function [[dotoffset]]>>

<<function [[allfloat]]>>

<<function [[constas]]>>

<<function [[typeext1]]>>

<<function [[typeext]]>>

<<function [[nocast]]>>

<<function [[nilcast]]>>

<<function [[arith]]>>

<<function [[simplifyshift]]>>

<<function [[side]]>>

<<function [[vconst]]>>

<<function [[log2]]>>

<<function [[vlog]]>>

<<function [[topbit]]>>

<<function [[relcon]]>>

<<function [[relindex]]>>

<<function [[invert]]>>

<<function [[bitno]]>>

<<function [[typebitor]]>>

<<function [[diag]]>>

<<function [[warn]]>>

<<function [[fatal]]>>

<<global [[thash1]]>>
<<global [[thash2]]>>
<<global [[thash3]]>>
<<global [[thash]]>>
<<global [[thashinit]]>>

<<global [[bnames]]>>
<<global [[bnamesinit]]>>

<<global [[tnames]]>>
<<global [[tnamesinit]]>>

<<global [[gnames]]>>
<<global [[gnamesinit]]>>

<<global [[qnames]]>>
<<global [[qnamesinit]]>>
<<global [[cnames]]>>
<<global [[cnamesinit]]>>

<<global [[onames]]>>
<<global [[onamesinit]]>>

<<global [[comrel]]>>
<<global [[invrel]]>>
<<global [[logrel]]>>

<<global [[typei]]>>
<<global [[typeiinit]]>>
<<global [[typeu]]>>
<<global [[typeuinit]]>>

<<global [[typesuv]]>>
<<global [[typesuvinit]]>>

// not used on ARM
<<global [[typechlv]]>>
<<global [[typeil]]>>
<<global [[typeilinit]]>>

<<global [[typeilp]]>>
<<global [[typeilpinit]]>>

<<global [[typechl]]>>
<<global [[typechlinit]]>>

<<global [[typechlp]]>>
<<global [[typechlpinit]]>>

<<global [[typechlpfd]]>>
<<global [[typechlpfdinit]]>>

<<global [[typev]]>>
<<global [[typevinit]]>>

<<global [[typefd]]>>
<<global [[typefdinit]]>>

<<global [[typeaf]]>>
<<global [[typeafinit]]>>

<<global [[typesu]]>>
<<global [[typesuinit]]>>

<<global [[tasign]]>>
<<global [[tasigninit]]>>

<<global [[tasadd]]>>
<<global [[tasaddinit]]>>

<<global [[tcast]]>>
<<global [[tcastinit]]>>

<<global [[tadd]]>>
<<global [[taddinit]]>>

<<global [[tsub]]>>
<<global [[tsubinit]]>>

<<global [[tmul]]>>
<<global [[tmulinit]]>>

<<global [[tand]]>>
<<global [[tandinit]]>>

<<global [[trel]]>>
<<global [[trelinit]]>>

<<global [[tfunct]]>>

<<global [[tindir]]>>

<<global [[tdot]]>>

<<global [[tnot]]>>

<<global [[targ]]>>

<<global [[tab]]>>

<<function [[urk]]>>

<<function [[tinit]]>>

<<function [[deadhead]]>>

<<function [[deadheads]]>>

<<function [[mixedasop]]>>
@


\subsection{[[cc/bits.c]]}

%-------------------------------------------------------------

<<cc/bits.c>>=
#include	"cc.h"

<<function [[bor]]>>

<<function [[bany]]>>

<<function [[beq]]>>

<<function [[bnum]]>>

<<function [[blsh]]>>

<<function [[bset]]>>
@


\subsection{[[cc/lex.c]]}

%-------------------------------------------------------------

<<cc/lex.c>>=
#include	"cc.h"
#include	"y.tab.h"

int	compile(char*, char**, int);
void	syminit(Sym*);
int	mpatov(char*, vlong*);
long	getr(void);
long	escchar(long, int, int);
void	cinit(void);

int	Oconv(Fmt*);
int	Lconv(Fmt*);
int	Tconv(Fmt*);
int	FNconv(Fmt*);
int	Qconv(Fmt*);
int	VBconv(Fmt*);

void	setinclude(char*);


#ifndef	CPP
<<constant [[CPP]]>>
#endif

/*
 * known debug flags
 *	-a		acid declaration output
 *	-A		!B
 *	-B		non ANSI
 *	-d		print declarations
 *	-D name		define
 *	-F		format specification check
 *	-i		print initialization
 *	-I path		include
 *	-l		generate little-endian code
 *	-L		print every NAME symbol
 *	-M		constant multiplication
 *	-m		print add/sub/mul trees
 *	-n		print acid to file (%.c=%.acid) (with -a or -aa)
 *	-o file		output file
 *	-p		use standard cpp ANSI preprocessor (not on windows)
 *	-r		print registerization
 *	-s		print structure offsets (with -a or -aa)
 *	-S		print assembly
 *	-t		print type trees
 *	-V		enable void* conversion warnings
 *	-v		verbose printing
 *	-w		print warnings
 *	-X		abort on error
 *	-.		Inhibit search for includes in source directory
 */

<<function [[main]]>>

<<function [[compile]]>>


<<function [[pushio]]>>

<<function [[newio]]>>

<<function [[newfile]]>>


<<function [[slookup]]>>

<<function [[lookup]]>>

<<function [[syminit]]>>

<<constant [[EOF]]>>
<<constant [[IGN]]>>
<<constant [[ESC]]>>
<<function [[GETC]]>>

<<enum [[numxxx]]>>

<<function [[yylex]]>>


<<function [[mpatov]]>>

<<function [[getc]]>>

<<function [[getr]]>>

<<function [[getnsc]]>>

<<function [[unget]]>>

<<function [[escchar]]>>

<<global [[itab]]>>

<<function [[cinit]]>>

<<function [[filbuf]]>>



<<function [[Oconv]]>>

<<struct [[Atab]]>>

<<function [[Lconv]]>>

<<function [[Tconv]]>>

<<function [[FNconv]]>>

<<function [[Qconv]]>>

<<function [[VBconv]]>>

<<function [[setinclude]]>>
@


\subsection{[[cc/acid.c]]}

%-------------------------------------------------------------

<<cc/acid.c>>=
#include "cc.h"

<<global [[kwd]]>>

<<function [[amap]]>>

<<function [[acidsue]]>>

<<function [[acidfun]]>>

<<global [[acidchar]]>>
<<global [[acidcinit]]>>

<<function [[acidinit]]>>

<<function [[acidmember]]>>

<<function [[acidtype]]>>

<<function [[acidvar]]>>
@


\subsection{[[cc/pickle.c]]}

%-------------------------------------------------------------

<<cc/pickle.c>>=
#include "cc.h"

<<global kwd (cc/pickle.c)>>
<<global [[picklestr]]>>

<<function [[pmap]]>>

<<function [[picklesue]]>>

<<global [[picklechar]]>>
<<global [[picklecinit]]>>

<<function [[pickleinit]]>>

<<function [[picklemember]]>>

<<function [[pickletype]]>>

@


\subsection{[[cc/com64.c]]}

%-------------------------------------------------------------

<<cc/com64.c>>=
#include "cc.h"

<<constant [[FNX]]>>

<<global [[nodaddv]]>>
<<global [[nodsubv]]>>
<<global [[nodmulv]]>>
<<global [[noddivv]]>>
<<global [[noddivvu]]>>
<<global [[nodmodv]]>>
<<global [[nodmodvu]]>>
<<global [[nodlshv]]>>
<<global [[nodrshav]]>>
<<global [[nodrshlv]]>>
<<global [[nodandv]]>>
<<global [[nodorv]]>>
<<global [[nodxorv]]>>
<<global [[nodnegv]]>>
<<global [[nodcomv]]>>

<<global [[nodtestv]]>>
<<global [[nodeqv]]>>
<<global [[nodnev]]>>
<<global [[nodlev]]>>
<<global [[nodltv]]>>
<<global [[nodgev]]>>
<<global [[nodgtv]]>>
<<global [[nodhiv]]>>
<<global [[nodhsv]]>>
<<global [[nodlov]]>>
<<global [[nodlsv]]>>

<<global [[nodf2v]]>>
<<global [[nodd2v]]>>
<<global [[nodp2v]]>>
<<global [[nodsi2v]]>>
<<global [[nodui2v]]>>
<<global [[nodsl2v]]>>
<<global [[nodul2v]]>>
<<global [[nodsh2v]]>>
<<global [[noduh2v]]>>
<<global [[nodsc2v]]>>
<<global [[noduc2v]]>>

<<global [[nodv2f]]>>
<<global [[nodv2d]]>>
<<global [[nodv2ui]]>>
<<global [[nodv2si]]>>
<<global [[nodv2ul]]>>
<<global [[nodv2sl]]>>
<<global [[nodv2uh]]>>
<<global [[nodv2sh]]>>
<<global [[nodv2uc]]>>
<<global [[nodv2sc]]>>

<<global [[nodvpp]]>>
<<global [[nodppv]]>>
<<global [[nodvmm]]>>
<<global [[nodmmv]]>>

<<global [[nodvasop]]>>

<<global [[etconv]]>>
<<global [[initetconv]]>>

<<function [[fvn]]>>

<<function [[com64init]]>>

<<function [[com64]]>>

<<function [[bool64]]>>

<<function [[convvtox]]>>
@

\subsection{[[cc/dcl.c]]}

%-------------------------------------------------------------

<<cc/dcl.c>>=
#include "cc.h"

Sym*	mkstatic(Sym*);
Type*	tcopy(Type*);
Node*	doinit(Sym*, Type*, long, Node*);
Node*	init1(Sym*, Type*, long, int);
Node*	newlist(Node*, Node*);
void	walkparam(Node*, int);
Type*	fnproto(Node*);
Type*	fnproto1(Node*);
int	anyproto(Node*);
void	dbgdecl(Sym*);
Decl*	push(void);
Decl*	push1(Sym*);
int	rsametype(Type*, Type*, int, int);
Type*	paramconv(Type*, int);
void	adecl(int, Type*, Sym*);
void	pdecl(int, Type*, Sym*);
void	tmerge(Type*, Sym*);

<<function [[dodecl]]>>

<<function [[mkstatic]]>>

<<function [[tcopy]]>>

<<function [[doinit]]>>

<<function [[peekinit]]>>

<<function [[nextinit]]>>

<<function [[isstruct]]>>

<<function [[init1]]>>

<<function [[newlist]]>>

<<function [[sualign]]>>

<<function [[round]]>>

<<function [[ofnproto]]>>

<<constant [[ANSIPROTO]]>>
<<constant [[OLDPROTO]]>>

<<function [[argmark]]>>

<<function [[walkparam]]>>

<<function [[markdcl]]>>

<<function [[revertdcl]]>>

<<function [[fnproto]]>>

<<function [[anyproto]]>>

<<function [[fnproto1]]>>

<<function [[dbgdecl]]>>

<<function [[push]]>>

<<function [[push1]]>>

<<function [[sametype]]>>

<<function [[rsametype]]>>

typedef struct Typetab Typetab;

<<struct [[Typetab]]>>

<<function [[sigind]]>>

<<function [[signat]]>>

<<function [[signature]]>>

<<function [[sign]]>>

<<function [[snap]]>>

<<function [[dotag]]>>

<<function [[dcllabel]]>>

<<function [[paramconv]]>>

<<function [[adecl]]>>

<<function [[pdecl]]>>

<<function [[xdecl]]>>

<<function [[tmerge]]>>

<<function [[edecl]]>>

<<function [[maxtype]]>>

<<function [[doenum]]>>

<<function [[symadjust]]>>

<<function [[contig]]>>
@


\subsection{[[cc/funct.c]]}

%-------------------------------------------------------------

<<cc/funct.c>>=
#include	"cc.h"

typedef	struct	Ftab	Ftab;
typedef	struct	Gtab	Gtab;

<<struct [[Ftab]]>>
<<struct [[Gtab]]>>

<<global [[gtabinit]]>>
<<global [[ftabinit]]>>

<<function [[isfunct]]>>
<<function [[dclfunct]]>>
@


\subsection{[[cc/scon.c]]}

%-------------------------------------------------------------

<<cc/scon.c>>=
#include "cc.h"

void	acom1(vlong, Node*);
void	acom2(Node*, Type*);
int	acomcmp1(const void*, const void*);
int	acomcmp2(const void*, const void*);
int	addo(Node*);

<<function [[acast]]>>

<<function [[evconst]]>>

<<function [[acom]]>>

<<function [[acomcmp1]]>>

<<function [[acomcmp2]]>>

<<function [[acom2]]>>

<<function [[acom1]]>>

<<function [[addo]]>>
@


\subsection{[[cc/dpchk.c]]}

%-------------------------------------------------------------

<<cc/dpchk.c>>=
#include	"cc.h"
#include	"y.tab.h"

<<enum [[fxxx]]>>

typedef	struct	Tprot	Tprot;
<<struct [[Tprot]]>>

typedef	struct	Tname	Tname;
<<struct [[Tname]]>>

<<global [[indchar]]>>
<<global [[flagbits]]>>
<<global [[fmtbuf]]>>
<<global [[lastadj]]>>
<<global [[lastverb]]>>
<<global [[nstar]]>>
<<global [[tprot]]>>
<<global [[tname]]>>

<<function [[argflag]]>>

<<function [[getflag]]>>

<<function [[arginit]]>>

<<function [[nextarg]]>>

<<function [[checkargs]]>>

<<function [[dpcheck]]>>


<<function [[pragpack]]>>

<<function [[newname]]>>

<<function [[newprot]]>>

<<function [[pragvararg]]>>

<<function [[pragfpround]]>>

<<function [[pragprofile]]>>

<<function [[pragincomplete]]>>

@


\subsection{[[cc/com.c]]}

%-------------------------------------------------------------

<<cc/com.c>>=
#include "cc.h"

int	tcomd(Node*);
int	tcomx(Node*);
int	tlvalue(Node*);

typedef struct Com Com;
typedef struct Big Big;

<<struct [[Com]]>>

int compar(Node*, int);
static void comma(Node*);
static Node*	commas(Com*, Node*);

<<function [[complex]]>>

<<enum [[_anon_ (cc/com.c)]]>>

<<function [[tcom]]>>

<<function [[tcomo]]>>

<<function [[tcoma]]>>

<<function [[tcomd]]>>

<<function [[tcomx]]>>

<<function [[tlvalue]]>>

<<function [[comargs]]>>

<<function [[commas]]>>

<<function [[comma]]>>

<<function [[ccom]]>>

<<global [[cmps]]>>

<<struct [[Big]]>>
<<function [[cmp]]>>
<<function [[add]]>>

<<function [[big]]>>

<<function [[compar]]>>

@

\section{[[cc2/]]}

\subsection{[[cc2/pswt.c]]}

%-------------------------------------------------------------

<<cc2/pswt.c>>=
#include "gc.h"

<<function [[swcmp]]>>

<<function [[doswit]]>>

<<function [[casf]]>>

<<function [[outlstring]]>>

<<function [[nullwarn]]>>

<<function [[ieeedtod]]>>
@


\subsection{[[cc2/pgen.c]]}

%-------------------------------------------------------------

<<cc2/pgen.c>>=
#include "gc.h"

void	gen(Node*);
void	usedset(Node*, int);
int		bcomplex(Node*, Node*);

<<function [[codgen]]>>

<<function [[supgen]]>>

<<function [[uncomma]]>>

<<function [[gen]]>>

<<function [[usedset]]>>

<<function [[bcomplex]]>>
@







\section{[[5c/]]}


\subsection{[[5c/enam.c]]}


%-------------------------------------------------------------

<<5c/enam.c>>=
<<global [[anames]](arm)>>
@


\subsection{[[5c/gc.h]]}

%<<function BLOAD(arm)>>=
%#define	BLOAD(r)	band(bnot(r->refbehind), r->refahead)
%@
%
%<<function BSTORE(arm)>>=
%#define	BSTORE(r)	band(bnot(r->calbehind), r->calahead)
%@
%
%<<constant CINF(arm)>>=
%#define	CINF	1000
%@

%-------------------------------------------------------------

<<5c/gc.h>>=
#include	"../cc/cc.h"

#include	<common.out.h>
#include	<5.out.h>

/*
 * 5c/arm
 * Arm
 */

<<constant [[SZ_CHAR]](arm)>>
<<constant [[SZ_SHORT]](arm)>>
<<constant [[SZ_INT]](arm)>>
<<constant [[SZ_LONG]](arm)>>
<<constant [[SZ_IND]](arm)>>
<<constant [[SZ_FLOAT]](arm)>>
<<constant [[SZ_VLONG]](arm)>>
<<constant [[SZ_DOUBLE]](arm)>>
<<constant [[FNX]](arm)>>
<<constant [[BTRUE]](arm)>>

typedef	struct	Adr		Adr;
typedef	struct	Prog	Prog;
typedef	struct	Case	Case;
typedef	struct	C1		C1;
typedef	struct	Multab	Multab;
typedef	struct	Hintab	Hintab;
typedef	struct	Var		Var;
typedef	struct	Reg		Reg;
typedef	struct	Rgn		Rgn;


<<struct [[Adr]](arm)>>
<<constant [[A]]>>

<<constant [[INDEXED]](arm)>>
<<struct [[Prog]](arm)>>
<<constant [[P]]>>

<<struct [[Case]]>>
<<constant [[C]]>>

<<struct [[C1]]>>

<<struct [[Multab]](arm)>>

<<struct [[Hintab]](arm)>>

<<struct [[Var]]>>

<<struct [[Reg]]>>
<<constant [[R]]>>

<<constant [[NRGN]](arm)>>
<<struct [[Rgn]]>>

extern	long	breakpc;
extern	long	nbreak;
extern	Case*	cases;
extern	Node	constnode;
extern	Node	fconstnode;
extern	long	continpc;
extern	long	curarg;
extern	long	cursafe;
extern	Prog*	firstp;
extern	Prog*	lastp;
extern	long	maxargsafe;
extern	int	mnstring;
extern	Multab	multab[20];
extern	int	hintabsize;
extern	Node*	nodrat;
extern	Node*	nodret;
extern	Node*	nodsafe;
extern	long	nrathole;
extern	long	nstring;
extern	Prog*	p;
extern	long	pc;
extern	Node	regnode;
extern	char	string[NSNAME];
extern	Sym*	symrathole;
extern	Node	znode;
extern	Prog	zprog;
extern	char	reg[NREG+NFREG];
extern	long	exregoffset;
extern	long	exfregoffset;
extern	int	suppress;

<<function [[LOAD]](arm)>>
<<function [[STORE]](arm)>>

<<function [[bset]](arm)>>

<<constant [[CLOAD]](arm)>>
<<constant [[CREF]](arm)>>
<<constant [[LOOP]](arm)>>

extern	Rgn	region[NRGN];
extern	Rgn*	rgp;
extern	int	nregion;
extern	int	nvar;

extern	Bits	externs;
extern	Bits	params;
extern	Bits	consts;
extern	Bits	addrs;

extern	long	regbits;
extern	long	exregbits;

extern	int	change;

extern	Reg*	firstr;
extern	Reg*	lastr;
extern	Reg	zreg;
extern	Reg*	freer;
extern	Var	var[NVAR];
extern	long*	idom;
extern	Reg**	rpo2r;
extern	long	maxnr;

extern	char*	anames[];
extern	Hintab	hintab[];

/*
 * sgen.c
 */
void	codgen(Node*, Node*);
void	gen(Node*);
void	noretval(int);
void	usedset(Node*, int);
void	xcom(Node*);
int	bcomplex(Node*, Node*);

/*
 * cgen.c
 */
void	cgen(Node*, Node*);
void	cgenrel(Node*, Node*, int);
void	reglcgen(Node*, Node*, Node*);
void	lcgen(Node*, Node*);
void	bcgen(Node*, int);
void	boolgen(Node*, int, Node*);
void	sugen(Node*, Node*, long);
void	layout(Node*, Node*, int, int, Node*);

/*
 * txt.c
 */
void	ginit(void);
void	gclean(void);
void	nextpc(void);
void	gargs(Node*, Node*, Node*);
void	garg1(Node*, Node*, Node*, int, Node**);
Node*	nodconst(long);
Node*	nod32const(vlong);
Node*	nodfconst(double);
void	nodreg(Node*, Node*, int);
void	regret(Node*, Node*);
int		tmpreg(void);
void	regalloc(Node*, Node*, Node*);
void	regfree(Node*);
void	regialloc(Node*, Node*, Node*);
void	regsalloc(Node*, Node*);
void	regaalloc1(Node*, Node*);
void	regaalloc(Node*, Node*);
void	regind(Node*, Node*);
void	gprep(Node*, Node*);
void	raddr(Node*, Prog*);
void	naddr(Node*, Adr*);
void	gmovm(Node*, Node*, int);
void	gmove(Node*, Node*);
void	gmover(Node*, Node*);
void	gins(int a, Node*, Node*);
void	gopcode(int, Node*, Node*, Node*);
int		samaddr(Node*, Node*);
void	gbranch(int);
void	patch(Prog*, long);
int		sconst(Node*);
int		sval(long);
void	gpseudo(int, Sym*, Node*);

/*
 * swt.c
 */
int		swcmp(const void*, const void*);
void	doswit(Node*);
void	swit1(C1*, int, long, Node*);
void	swit2(C1*, int, long, Node*, Node*);
void	casf(void);
void	bitload(Node*, Node*, Node*, Node*, Node*);
void	bitstore(Node*, Node*, Node*, Node*, Node*);
long	outstring(char*, long);
int		mulcon(Node*, Node*);
Multab*	mulcon0(long);
void	nullwarn(Node*, Node*);
void	gextern(Sym*, Node*, long, long);
void	outcode(void);
void	ieeedtod(Ieee*, double);

/*
 * list
 */
void	listinit(void);
int	Pconv(Fmt*);
int	Aconv(Fmt*);
int	Dconv(Fmt*);
int	Sconv(Fmt*);
int	Nconv(Fmt*);
int	Bconv(Fmt*);
int	Rconv(Fmt*);

/*
 * reg.c
 */
Reg*	rega(void);
int		rcmp(const void*, const void*);
void	regopt(Prog*);
void	addmove(Reg*, int, int, int);
Bits	mkvar(Adr*, int);
void	prop(Reg*, Bits, Bits);
void	loopit(Reg*, long);
void	synch(Reg*, Bits);
ulong	allreg(ulong, Rgn*);
void	paint1(Reg*, int);
ulong	paint2(Reg*, int);
void	paint3(Reg*, int, long, int);
void	addreg(Adr*, int);

/*
 * peep.c
 */
void	peep(void);
void	excise(Reg*);
Reg*	uniqp(Reg*);
Reg*	uniqs(Reg*);
int	regtyp(Adr*);
int	regzer(Adr*);
int	anyvar(Adr*);
int	subprop(Reg*);
int	copyprop(Reg*);
int	shiftprop(Reg*);
void	constprop(Adr*, Adr*, Reg*);
int	copy1(Adr*, Adr*, Reg*, int);
int	copyu(Prog*, Adr*, Adr*);

int	copyas(Adr*, Adr*);
int	copyau(Adr*, Adr*);
int	copyau1(Prog*, Adr*);
int	copysub(Adr*, Adr*, Adr*, int);
int	copysub1(Prog*, Adr*, Adr*, int);

long	RtoB(int);
long	FtoB(int);
int		BtoR(long);
int		BtoF(long);

void	predicate(void); 
int	isbranch(Prog *); 
int	predicable(Prog *p); 
int	modifiescpsr(Prog *p); 

#pragma	varargck	type	"A"	int
#pragma	varargck	type	"B"	Bits
#pragma	varargck	type	"D"	Adr*
#pragma	varargck	type	"N"	Adr*
#pragma	varargck	type	"R"	Adr*
#pragma	varargck	type	"P"	Prog*
#pragma	varargck	type	"S"	char*
@


\subsection{[[5c/machcap.c]]}

%-------------------------------------------------------------

<<5c/machcap.c>>=
#include	"../cc/cc.h"

<<function [[machcap]](arm)>>
@


\subsection{[[5c/globals2.c]]}


%-------------------------------------------------------------

<<5c/globals2.c>>=
#include "gc.h"

<<global [[breakpc]]>>
<<global [[nbreak]]>>
<<global [[cases]]>>
<<global [[constnode]]>>
<<global [[fconstnode]]>>
<<global [[continpc]]>>

<<global [[curarg]]>>
<<global [[cursafe]]>>

<<global [[firstp]]>>
<<global [[lastp]]>>

<<global [[maxargsafe]]>>

<<global [[mnstring]]>>
<<global [[multab]](arm)>>
<<global [[hintabsize]](arm)>>
<<global [[nodrat]]>>
<<global [[nodret]]>>
<<global [[nodsafe]]>>
<<global [[nrathole]]>>
<<global [[nstring]]>>
<<global [[p]]>>
<<global [[pc]]>>
<<global [[regnode]]>>
<<global [[string]]>>
<<global [[symrathole]]>>
<<global [[znode]]>>
<<global [[zprog]]>>
<<global [[reg]](arm)>>
<<global [[exregoffset]]>>
<<global [[exfregoffset]]>>
<<global [[suppress]]>>

<<global [[region]]>>
<<global [[rgp]]>>
<<global [[nregion]]>>

<<global [[externs]]>>
<<global [[params]]>>
<<global [[consts]]>>
<<global [[addrs]]>>

<<global [[regbits]]>>
<<global [[exregbits]]>>

<<global [[change]]>>

<<global [[firstr]]>>
<<global [[lastr]]>>
<<global [[zreg]]>>
<<global [[freer]]>>
<<global [[var]]>>
<<global [[nvar]]>>

<<global [[idom]]>>
<<global [[rpo2r]]>>
<<global [[maxnr]]>>
@


\subsection{[[5c/list.c]]}

%-------------------------------------------------------------

<<5c/list.c>>=
#include "gc.h"

<<function [[listinit]](arm)>>

<<function [[Bconv]]>>

<<global [[extra]](arm)>>

<<function [[Pconv]](arm)>>

<<function [[Aconv]]>>

<<function [[Dconv]](arm)>>

<<function [[Rconv]](arm)>>

<<function [[Sconv]](arm)>>

<<function [[Nconv]](arm)>>
@


\subsection{[[5c/txt.c]]}

%-------------------------------------------------------------

<<5c/txt.c>>=
#include "gc.h"

<<global [[resvreg]](arm)>>

<<function [[ginit]](arm)>>

<<function [[gclean]](arm)>>

<<function [[nextpc]]>>

<<function [[gargs]]>>

<<function [[garg1]](arm)>>

<<function [[nodconst]]>>

<<function [[nod32const]](arm)>>

<<function [[nodfconst]]>>

<<function [[nodreg]](arm)>>

<<function [[regret]](arm)>>

<<function [[tmpreg]](arm)>>

<<function [[regalloc]](arm)>>

<<function [[regialloc]]>>

<<function [[regfree]](arm)>>

<<function [[regsalloc]]>>

<<function [[regaalloc1]](arm)>>

<<function [[regaalloc]](arm)>>

<<function [[regind]]>>

<<function [[raddr]](arm)>>

<<function [[naddr]](arm)>>

<<function [[gmovm]](arm)>>

<<function [[gmove]](arm)>>

<<function [[gmover]](arm)>>

<<function [[gins]](arm)>>

<<function [[gopcode]](arm)>>

<<function [[samaddr]]>>

<<function [[gbranch]](arm)>>

<<function [[patch]]>>

<<function [[gpseudo]](arm)>>

<<function [[sconst]](arm)>>

<<function [[sval]](arm)>>

<<function [[exreg]](arm)>>

<<global [[ewidth]]>>

<<global [[ncast]]>>
@


\subsection{[[5c/peep.c]]}


%-------------------------------------------------------------

<<5c/peep.c>>=
#include "gc.h"

int xtramodes(Reg*, Adr*);

<<function [[peep]](arm)>>

<<function [[excise]](arm)>>

<<function [[uniqp]]>>

<<function [[uniqs]]>>

<<function [[regtyp]](arm)>>

<<function [[subprop]](arm)>>

<<function [[copyprop]]>>

<<function [[copy1]]>>

<<function [[constprop]](arm)>>

<<function [[FAIL]](arm)>>
<<function [[shiftprop]](arm)>>

<<function [[findpre]](arm)>>

<<function [[findinc]](arm)>>

<<function [[nochange]](arm)>>

<<function [[findu1]](arm)>>

<<function [[finduse]](arm)>>

<<function [[xtramodes]](arm)>>

<<function [[copyu]](arm)>>

<<function [[a2type]](arm)>>

<<function [[copyas]](arm)>>

<<function [[copyau]](arm)>>

<<function [[copyau1]](arm)>>

<<function [[copysub]](arm)>>

<<function [[copysub1]](arm)>>

<<global [[predinfo]](arm)>>

<<struct [[Joininfo]]>>

<<enum [[_anon_]](arm)>>
    
<<enum [[_anon_ (5c/peep.c)]](arm)>>

<<function [[isbranch]](arm)>>

<<function [[predicable]](arm)>>

<<function [[modifiescpsr]](arm)>>

<<function [[joinsplit]](arm)>>

<<function [[successor]](arm)>>

<<function [[applypred]](arm)>>

<<function [[predicate]](arm)>>
@


\subsection{[[5c/sgen.c]]}

%-------------------------------------------------------------

<<5c/sgen.c>>=
#include "gc.h"

<<function [[noretval]](arm)>>

<<function [[xcom]](arm)>>
@


\subsection{[[5c/swt.c]]}

%-------------------------------------------------------------

<<5c/swt.c>>=
#include "gc.h"

<<function [[swit1]](arm)>>

<<function [[swit2]](arm)>>

<<function [[bitload]](arm)>>

<<function [[bitstore]](arm)>>

<<function [[outstring]](arm)>>

<<function [[mulcon]](arm)>>

<<function [[gextern]](arm)>>

void	zname(Biobuf*, Sym*, int);
char*	zaddr(char*, Adr*, int);
void	zwrite(Biobuf*, Prog*, int, int);
void	outhist(Biobuf*);

<<function [[zwrite]](arm)>>

<<struct [[Htab]]>>

<<function [[outcode]](arm)>>

<<function [[outhist]](arm)>>

<<function [[zname]](arm)>>

<<function [[zaddr]](arm)>>

<<function [[align]](arm)>>

<<function [[maxround]]>>
@


\subsection{[[5c/mul.c]]}


%-------------------------------------------------------------

<<5c/mul.c>>=
#include "gc.h"

/*
 * code sequences for multiply by constant.
 * [a-l][0-3]
 *	lsl	$(A-'a'),r0,r1
 * [+][0-7]
 *	add	r0,r1,r2
 * [-][0-7]
 *	sub	r0,r1,r2
 */

<<global [[maxmulops]](arm)>>
<<global [[multabp]](arm)>>
<<global [[mulval]](arm)>>
<<global [[mulcp]](arm)>>
<<global [[valmax]](arm)>>
<<global [[shmax]](arm)>>

static int	docode(char *hp, char *cp, int r0, int r1);
static int	gen1(int len);
static int	gen2(int len, long r1);
static int	gen3(int len, long r0, long r1, int flag);
<<enum [[_anon_ (5c/mul.c)]](arm)>>

<<function [[mulcon0]](arm)>>

<<function [[docode]](arm)>>

<<function [[gen1]](arm)>>

<<function [[gen2]](arm)>>

<<function [[gen3]](arm)>>

<<global [[hintab]](arm)>>
<<global hintabsize (5c/mul.c)(arm)>>
@
% $


\subsection{[[5c/reg.c]]}


%-------------------------------------------------------------

<<5c/reg.c>>=
#include "gc.h"

void	addsplits(void);

<<function [[rega]]>>

<<function [[rcmp]]>>

<<function [[regopt]](arm)>>

<<function [[addsplits]](arm)>>

<<function [[addmove]](arm)>>

<<function [[mkvar]](arm)>>

<<function [[prop]](arm)>>

<<function [[postorder]]>>

<<function [[rpolca]]>>

<<function [[doms]]>>

<<function [[loophead]]>>

<<function [[loopmark]]>>

<<function [[loopit]]>>

<<function [[synch]]>>

<<function [[allreg]](arm)>>

<<function [[paint1]](arm)>>

<<function [[paint2]](arm)>>

<<function [[paint3]]>>

<<function [[addreg]](arm)>>

<<function [[RtoB]](arm)>>

<<function [[BtoR]](arm)>>

<<function [[FtoB]](arm)>>

<<function [[BtoF]](arm)>>
@


\subsection{[[5c/cgen.c]]}



%-------------------------------------------------------------

<<5c/cgen.c>>=
#include "gc.h"

<<function [[cgen]](arm)>>

<<function [[cgenrel]](arm)>>

<<function [[reglcgen]](arm)>>

<<function [[reglpcgen]](arm)>>

<<function [[lcgen]](arm)>>

<<function [[bcgen]]>>

<<function [[boolgen]](arm)>>

<<function [[sugen]](arm)>>
@
