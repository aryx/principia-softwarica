\section{[[cc/]]}

\subsection*{[[cc/cc.h]]}

%-------------------------------------------------------------

<<cc/cc.h>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <ctype.h>

#pragma	lib	"../cc/cc.a$O" //$

typedef	struct	Node	Node;
typedef	struct	Sym	Sym;
typedef	struct	Type	Type;
typedef	struct	Funct	Funct;
typedef	struct	Decl	Decl;
typedef	struct	Io	Io;
typedef	struct	Hist	Hist;
typedef	struct	Term	Term;
typedef	struct	Init	Init;
typedef	struct	Bits	Bits;

typedef	Rune	TRune;	/* target system type */

<<constant NHUNK>>
<<constant BUFSIZ>>
<<constant NSYMB>>
<<constant NHASH>>
<<constant STRINGSZ>>
<<constant HISTSZ>>
<<constant YYMAXDEPTH>>
<<constant NTERM>>
<<constant MAXALIGN>>

<<function SIGN>>
<<function MASK>>

<<constant BITS>>
<<constant NVAR>>
<<struct Bits>>

<<struct Node>>
<<constant Z>>

<<struct Sym>>
<<constant S>>

<<enum sigxxx>>

<<struct Decl>>
<<constant D>>

<<struct Type>>
<<constant T>>
<<constant NODECL>>

<<struct Init>>


<<struct Fi>>
extern struct Fi fi;

<<struct Io>>
<<constant I>>

<<struct Hist>>
<<constant H>>
extern Hist*	hist;

<<struct Term>>

<<enum os>>
<<enum node_kind>>
<<enum type_kind>>
<<enum axxx>>
<<enum dxxx>>
<<enum cxxx>>
<<enum gxxx>>
<<enum bxxx>>

<<struct Funct>>

<<struct En>>
extern struct En en;

extern	int	autobn;
extern	long	autoffset;
extern	int	blockno;
extern	Decl*	dclstack;
extern	char	debug[256];
extern	Hist*	ehist;
extern	long	firstbit;
extern	Sym*	firstarg;
extern	Type*	firstargtype;
extern	Decl*	firstdcl;
extern	Sym*	hash[NHASH];
extern	int	hasdoubled;
extern	char*	hunk;
extern	char**	include;
extern	Io*	iofree;
extern	Io*	ionext;
extern	Io*	iostack;
extern	long	lastbit;
extern	char	lastclass;
extern	Type*	lastdcl;
extern	long	lastfield;
extern	Type*	lasttype;
extern	long	lineno;
extern	long	nearln;
extern	int	maxinclude;
extern	int	nerrors;
extern	bool	newflag;
extern	long	nhunk;
extern	int	ninclude;
extern	Node*	nodproto;
extern	Node*	nodcast;
extern	Biobuf	outbuf;
extern	Biobuf	diagbuf;
extern	char*	outfile;
extern	char*	pathname;
extern	int	peekc;
extern	long	stkoff;
extern	Type*	strf;
extern	Type*	strl;
extern	char	symb[NSYMB];
extern	Sym*	symstring;
extern	int	taggen;
extern	Type*	tfield;
extern	Type*	tufield;
extern	int	thechar;
extern	char*	thestring;
extern	Type*	thisfn;
extern	long	thunk;
extern	Type*	types[NTYPE];

extern	Type*	fntypes[NTYPE];
extern	Node*	initlist;
extern	Term	term[NTERM];
extern	int	nterm;
extern	int	packflg;
extern	int	fproundflg;
extern	bool	profileflg;
extern	int	ncontin;
extern	bool	newvlongcode;
extern	int	canreach;
extern	int	warnreach;
extern	Bits	zbits;

extern	char	*onames[], *tnames[], *gnames[];
extern	char	*cnames[], *qnames[], *bnames[];

extern	char	comrel[], invrel[], logrel[];
extern	long	ncast[], tadd[], tand[];
extern	long	targ[], tasadd[], tasign[], tcast[];
extern	long	tdot[], tfunct[], tindir[], tmul[];
extern	long	tnot[], trel[], tsub[];

extern	char	typeaf[];
extern	char	typefd[];
extern	char	typei[];
extern	char	typesu[];
extern	char	typesuv[];
extern	char	typeu[];
extern	char	typev[];
extern	char	typeil[];
extern	char	typeilp[];
extern	char	typechl[];
extern	char	typechlv[];

extern	char	typechlp[];
extern	char	typechlpfd[];

extern	char*	typeswitch;
extern	char*	typeword;
extern	char*	typecmplx;

extern	ulong	thash1;
extern	ulong	thash2;
extern	ulong	thash3;
extern	ulong	thash[];

/*
 *	compat.c/unix.c/windows.c
 */
int	mywait(int*);
int	mycreat(char*, int);
int	myaccess(char*);
int	pathchar(void);
bool	systemtype(int);

// utils.c
void	gethunk(void);
void*	allocn(void*, long, long);
void*	alloc(long);
void	errorexit(void);
void	yyerror(char*, ...);

/*
 *	parser
 */
//@Scheck: def in y.tab.c from cc.y
int	yyparse(void);

/*
 *	lex.c
 */
int	filbuf(void);
int	getc(void);
int	getnsc(void);
Sym*	lookup(void);
void	newfile(char*, int);
void	newio(void);
void	pushio(void);
Sym*	slookup(char*);
void	unget(int);
long	yylex(void);

//!!!! (hmmm in lex.c, as well as cinit(), compile())
void	main(int, char*[]);


/*
 * mac.c
 */
void	dodefine(char*);
void	domacro(void);
void	linehist(char*, int);
void	macexpand(Sym*, char*);

/*
 * dcl.c
 */
//@Scheck: useful, used by cc.y
Type*	tcopy(Type*);
//@Scheck: useful, used by cc.y
Node*	doinit(Sym*, Type*, long, Node*);
//@Scheck: useful, used by cc.y
void	adecl(int, Type*, Sym*);
void	argmark(Node*, int);
Node*	dcllabel(Sym*, int);
Node*	dodecl(void(*)(int, Type*, Sym*), int, Type*, Node*);
//@Scheck: useful, used by cc.y
Sym*	mkstatic(Sym*);
void	doenum(Sym*, Node*);
void	snap(Type*);
Type*	dotag(Sym*, int, int);
void	edecl(int, Type*, Sym*);
void	markdcl(void);
//@Scheck: useful, used by cc.y
void	pdecl(int, Type*, Sym*);
Node*	revertdcl(void);
long	round(long, int);
int	sametype(Type*, Type*);
ulong	sign(Sym*);
ulong	signature(Type*);
void	sualign(Type*);
void	xdecl(int, Type*, Sym*);
Node*	contig(Sym*, Node*, long);

/*
 * com.c
 */
void	ccom(Node*);
void	complex(Node*);
int	tcom(Node*);
int	tcoma(Node*, Node*, Type*, int);
int	tcomo(Node*, int);
void	constas(Node*, Type*, Type*);
Node*	uncomma(Node*);

/*
 * con.c
 */
void	acom(Node*);
void	evconst(Node*);

/*
 * funct.c
 */
int	isfunct(Node*);
void	dclfunct(Type*, Sym*);

/*
 * sub.c
 */
void	arith(Node*, int);
int	deadheads(Node*);
Type*	dotsearch(Sym*, Type*, Node*, long*);
Node*	invert(Node*);
int	bitno(long);
void	makedot(Node*, Type*, long);
int	mixedasop(Type*, Type*);
Node*	new(int, Node*, Node*);
Node*	new1(int, Node*, Node*);
int	nilcast(Type*, Type*);
int	nocast(Type*, Type*);
void	prtree(Node*, char*);
void	prtree1(Node*, int, int);
void	relcon(Node*, Node*);
int	relindex(int);
//@Scheck: useful, used by cc.y
int	simpleg(long);
Type*	garbt(Type*, long);
int	simplec(long);
Type*	simplet(long);
int	stcompat(Node*, Type*, Type*, long[]);
int	tcompat(Node*, Type*, Type*, long[]);
void	tinit(void);
Type*	typ(int, Type*);
Type*	copytyp(Type*);
void	typeext(Type*, Node*);
void	typeext1(Type*, Node*);
int	side(Node*);
int	vconst(Node*);
int	log2(uvlong);
int	vlog(Node*);
int	topbit(ulong);
void	simplifyshift(Node*);
long	typebitor(long, long);
void	diag(Node*, char*, ...);
void	warn(Node*, char*, ...);
void	fatal(Node*, char*, ...);

/*
 * acid.c
 */
void	acidtype(Type*);
void	acidvar(Sym*);

/*
 * pickle.c
 */
void	pickletype(Type*);

/*
 * bits.c
 */
Bits	bor(Bits, Bits);
//Bits	band(Bits, Bits);
//Bits	bnot(Bits);
int	bany(Bits*);
int	bnum(Bits);
Bits	blsh(uint);
int	beq(Bits, Bits);
int	bset(Bits, uint);

/*
 * dpchk.c
 */
void	dpcheck(Node*);
void	arginit(void);
//void	pragvararg(void);
//void	pragpack(void);
//void	pragfpround(void);
//void  pragprofile(void);
//void	pragincomplete(void);

/*
 * calls to machine depend part
 */
//todo: could define an interface instantiated by each xc
void	codgen(Node*, Node*);
void	gclean(void);
void	gextern(Sym*, Node*, long, long);
void	ginit(void);
long	outstring(char*, long);
long	outlstring(TRune*, long);
void	xcom(Node*);
long	exreg(Type*);
long	align(long, Type*, int);
long	maxround(long, long);

extern	schar	ewidth[];

/*
 * com64
 */
int	com64(Node*);
void	com64init(void);
void	bool64(Node*);
//double	convvtof(vlong);
//vlong		convftov(double);
//double	convftox(double, int);
vlong	convvtox(vlong, int);

/*
 * machcap
 */
int	machcap(Node*);

#pragma	varargck	argpos	warn	2
#pragma	varargck	argpos	diag	2
#pragma	varargck	argpos	yyerror	1

#pragma	varargck	type	"F"	Node*
#pragma	varargck	type	"L"	long
#pragma	varargck	type	"Q"	long
#pragma	varargck	type	"O"	int
#pragma	varargck	type	"T"	Type*
#pragma	varargck	type	"|"	int
@
%$


\subsection*{[[cc/globals.c]]}

%<<global fperror>>=
%//int	fperror;
%@

%-------------------------------------------------------------

<<cc/globals.c>>=
#include "cc.h"

<<global fi>>
<<global hist>>
<<global en>>

<<global autobn>>
<<global autoffset>>
<<global blockno>>
<<global dclstack>>
<<global debug>>
<<global ehist>>
<<global firstbit>>
<<global firstarg>>
<<global firstargtype>>
<<global firstdcl>>
<<global hash>>
<<global hasdoubled>>
<<global hunk>>
<<global include>>
<<global iofree>>
<<global ionext>>
<<global iostack>>
<<global lastbit>>
<<global lastclass>>
<<global lastdcl>>
<<global lastfield>>
<<global lasttype>>
<<global lineno>>
<<global nearln>>
<<global maxinclude>>
<<global nerrors>>
<<global newflag>>
<<global nhunk>>
<<global ninclude>>
<<global nodproto>>
<<global nodcast>>
<<global outbuf>>
<<global diagbuf>>
<<global outfile>>
<<global pathname>>
<<global peekc>>
<<global stkoff>>
<<global strf>>
<<global strl>>
<<global symb>>
<<global symstring>>
<<global taggen>>
<<global tfield>>
<<global tufield>>
<<global thechar>>
<<global thestring>>
<<global thisfn>>
<<global thunk>>
<<global types>>
<<global fntypes>>
<<global initlist>>
<<global term>>
<<global nterm>>
<<global packflg>>
<<global fproundflg>>
<<global profileflg>>
<<global ncontin>>
<<global newvlongcode>>
<<global canreach>>
<<global warnreach>>
<<global zbits>>

<<global typeswitch>>
<<global typeword>>
<<global typecmplx>>
@


\subsection*{[[cc/omachcap.c]]}

%-------------------------------------------------------------

<<cc/omachcap.c>>=
#include	"cc.h"

/* default, like old cc */
//int
//machcap(Node*)
//{
//	return 0;
//}
@



\subsection*{[[cc/compat.c]]}

%<<function calloc>>=
%//void*
%//calloc(ulong m, ulong n)
%//{
%//    return alloc(m*n);
%//}
%@
%
%<<function realloc>>=
%//void*
%//realloc(void*, ulong)
%//{
%//    fprint(2, "realloc called\n");
%//    abort();
%//    return 0;
%//}
%@
%
%<<function mallocz>>=
%/* needed when profiling */
%//void*
%//mallocz(ulong size, int clr)
%//{
%//    void *v;
%//
%//    v = alloc(size);
%//    if(clr && v != nil)
%//        memset(v, 0, size);
%//    return v;
%//}
%@


%-------------------------------------------------------------

<<cc/compat.c>>=
#include	"cc.h"

//#include	"compat"
//TODO copy paste with aa/, maybe could factorize with another lib?
//

int
myaccess(char *f)
{
 return access(f, AEXIST);
}


int
mycreat(char *n, int p)
{

 return create(n, 1, p);
}

int
mywait(int *s)
{
 int p;
 Waitmsg *w;

 if((w = wait()) == nil)
  return -1;
 else{
  p = w->pid;
  *s = 0;
  if(w->msg[0])
   *s = 1;
  free(w);
  return p;
 }
}

bool
systemtype(int sys)
{
 return sys & Plan9;
}

int
pathchar(void)
{
 return '/';
}

<<function malloc>>

<<function free>>

<<function setmalloctag>>
@

% on pathchar() :) why DOS used '\' instead of '/'
%http://blogs.msdn.com/b/larryosterman/archive/2005/06/24/432386.aspx


\subsection*{[[cc/utils.c]]}

<<cc/utils.c>>=
#include "cc.h"

<<function errorexit>>

<<function gethunk>>

<<function alloc>>

<<function allocn>>

<<function yyerror>>

@

\subsection*{[[cc/mac.c]]}

%-------------------------------------------------------------

<<cc/mac.c>>=
#include	"cc.h"

//old: #include	"macbody"
//TODO copy paste with aa/, maybe could factorize with another lib?
//

void	macdef(void);
void	macinc(void);
void	macprag(void);
void	maclin(void);
void	macif(int);
void	macend(void);
void	macund(void);

long	getnsn(void);
Sym*	getsym(void);

<<constant VARMAC>>

<<function getnsn>>

<<function getsym>>

<<function getsymdots>>

<<function getcom>>

<<function dodefine>>

<<global mactab>>

<<function domacro>>

<<function macund>>

<<constant NARG>>
<<function macdef>>

<<function macexpand>>

<<function macinc>>

<<function maclin>>

<<function macif>>

<<function macprag>>

<<function macend>>

<<function linehist>>

@


\subsection*{[[cc/sub.c]]}


%-------------------------------------------------------------

<<cc/sub.c>>=
#include	"cc.h"

int	simpleg(long);
long	dotoffset(Type*, Type*, Node*);

extern	char	typechlvp[];
extern	char	typec[];
extern	char	typeh[];
extern	char	tab[NTYPE][NTYPE];

<<function new>>

<<function new1>>

<<function prtree>>

<<function prtree1>>

<<function typ>>

<<function copytyp>>

<<function garbt>>

<<function simpleg>>

<<function simplec>>

<<function simplet>>

<<function stcompat>>

<<function tcompat>>

<<function makedot>>

<<function dotsearch>>

<<function dotoffset>>

<<function allfloat>>

<<function constas>>

<<function typeext1>>

<<function typeext>>

<<function nocast>>

<<function nilcast>>

<<function arith>>

<<function simplifyshift>>

<<function side>>

<<function vconst>>

<<function log2>>

<<function vlog>>

<<function topbit>>

<<function relcon>>

<<function relindex>>

<<function invert>>

<<function bitno>>

<<function typebitor>>

<<function diag>>

<<function warn>>

<<function fatal>>

<<global thash1>>
<<global thash2>>
<<global thash3>>
<<global thash>>
<<global thashinit>>

<<global bnames>>
<<global bnamesinit>>

<<global tnames>>
<<global tnamesinit>>

<<global gnames>>
<<global gnamesinit>>

<<global qnames>>
<<global qnamesinit>>
<<global cnames>>
<<global cnamesinit>>

<<global onames>>
<<global onamesinit>>

<<global comrel>>
<<global invrel>>
<<global logrel>>

<<global typei>>
<<global typeiinit>>
<<global typeu>>
<<global typeuinit>>

<<global typesuv>>
<<global typesuvinit>>

<<global typeilp>>
<<global typeilpinit>>

<<global typechl>>
<<global typechlv>>
<<global typechlvp>>
<<global typechlinit>>

<<global typechlp>>
<<global typechlpinit>>

<<global typechlpfd>>
<<global typechlpfdinit>>

<<global typec>>
<<global typecinit>>

<<global typeh>>
<<global typehinit>>

<<global typeil>>
<<global typeilinit>>

<<global typev>>
<<global typevinit>>

<<global typefd>>
<<global typefdinit>>

<<global typeaf>>
<<global typeafinit>>

<<global typesu>>
<<global typesuinit>>

<<global tasign>>
<<global tasigninit>>

<<global tasadd>>
<<global tasaddinit>>

<<global tcast>>
<<global tcastinit>>

<<global tadd>>
<<global taddinit>>

<<global tsub>>
<<global tsubinit>>

<<global tmul>>
<<global tmulinit>>

<<global tand>>
<<global tandinit>>

<<global trel>>
<<global trelinit>>

<<global tfunct>>

<<global tindir>>

<<global tdot>>

<<global tnot>>

<<global targ>>

<<global tab>>

<<function urk>>

<<function tinit>>

<<function deadhead>>

<<function deadheads>>

<<function mixedasop>>
@


\subsection*{[[cc/bits.c]]}

%-------------------------------------------------------------

<<cc/bits.c>>=
#include	"cc.h"

<<function bor>>

<<function bany>>

<<function beq>>

<<function bnum>>

<<function blsh>>

<<function bset>>
@


\subsection*{[[cc/lex.c]]}

%-------------------------------------------------------------

<<cc/lex.c>>=
#include	"cc.h"
#include	"y.tab.h"

int	compile(char*, char**, int);
void	syminit(Sym*);
int	mpatov(char*, vlong*);
long	getr(void);
long	escchar(long, int, int);
void	cinit(void);

int	Oconv(Fmt*);
int	Lconv(Fmt*);
int	Tconv(Fmt*);
int	FNconv(Fmt*);
int	Qconv(Fmt*);
int	VBconv(Fmt*);

void	setinclude(char*);


#ifndef	CPP
<<constant CPP>>
#endif

<<function main>>

<<function compile>>


<<function pushio>>

<<function newio>>

<<function newfile>>


<<function slookup>>

<<function lookup>>

<<function syminit>>

<<constant EOF>>
<<constant IGN>>
<<constant ESC>>
<<function GETC>>

<<enum numxxx>>

<<function yylex>>


<<function mpatov>>

<<function getc>>

<<function getr>>

<<function getnsc>>

<<function unget>>

<<function escchar>>

<<global itab>>

<<function cinit>>

<<function filbuf>>



<<function Oconv>>

<<struct Atab>>

<<function Lconv>>

<<function Tconv>>

<<function FNconv>>

<<function Qconv>>

<<function VBconv>>

<<function setinclude>>
@


\subsection*{[[cc/acid.c]]}

%-------------------------------------------------------------

<<cc/acid.c>>=
#include "cc.h"

<<global kwd>>

<<function amap>>

<<function acidsue>>

<<function acidfun>>

<<global acidchar>>
<<global acidcinit>>

<<function acidinit>>

<<function acidmember>>

<<function acidtype>>

<<function acidvar>>
@


\subsection*{[[cc/pickle.c]]}

%-------------------------------------------------------------

<<cc/pickle.c>>=
#include "cc.h"

<<global kwd (cc/pickle.c)>>
<<global picklestr>>

<<function pmap>>

<<function picklesue>>

<<global picklechar>>
<<global picklecinit>>

<<function pickleinit>>

<<function picklemember>>

<<function pickletype>>

@


\subsection*{[[cc/com64.c]]}

%-------------------------------------------------------------

<<cc/com64.c>>=
#include "cc.h"

<<constant FNX>>

<<global nodaddv>>
<<global nodsubv>>
<<global nodmulv>>
<<global noddivv>>
<<global noddivvu>>
<<global nodmodv>>
<<global nodmodvu>>
<<global nodlshv>>
<<global nodrshav>>
<<global nodrshlv>>
<<global nodandv>>
<<global nodorv>>
<<global nodxorv>>
<<global nodnegv>>
<<global nodcomv>>

<<global nodtestv>>
<<global nodeqv>>
<<global nodnev>>
<<global nodlev>>
<<global nodltv>>
<<global nodgev>>
<<global nodgtv>>
<<global nodhiv>>
<<global nodhsv>>
<<global nodlov>>
<<global nodlsv>>

<<global nodf2v>>
<<global nodd2v>>
<<global nodp2v>>
<<global nodsi2v>>
<<global nodui2v>>
<<global nodsl2v>>
<<global nodul2v>>
<<global nodsh2v>>
<<global noduh2v>>
<<global nodsc2v>>
<<global noduc2v>>

<<global nodv2f>>
<<global nodv2d>>
<<global nodv2ui>>
<<global nodv2si>>
<<global nodv2ul>>
<<global nodv2sl>>
<<global nodv2uh>>
<<global nodv2sh>>
<<global nodv2uc>>
<<global nodv2sc>>

<<global nodvpp>>
<<global nodppv>>
<<global nodvmm>>
<<global nodmmv>>

<<global nodvasop>>

<<global etconv>>
<<global initetconv>>

<<function fvn>>

<<function com64init>>

<<function com64>>

<<function bool64>>

<<function convvtox>>
@

\subsection*{[[cc/dcl.c]]}

%-------------------------------------------------------------

<<cc/dcl.c>>=
#include "cc.h"

Sym*	mkstatic(Sym*);
Type*	tcopy(Type*);
Node*	doinit(Sym*, Type*, long, Node*);
Node*	init1(Sym*, Type*, long, int);
Node*	newlist(Node*, Node*);
void	walkparam(Node*, int);
Type*	fnproto(Node*);
Type*	fnproto1(Node*);
int	anyproto(Node*);
void	dbgdecl(Sym*);
Decl*	push(void);
Decl*	push1(Sym*);
int	rsametype(Type*, Type*, int, int);
Type*	paramconv(Type*, int);
void	adecl(int, Type*, Sym*);
void	pdecl(int, Type*, Sym*);
void	tmerge(Type*, Sym*);

<<function dodecl>>

<<function mkstatic>>

<<function tcopy>>

<<function doinit>>

<<function peekinit>>

<<function nextinit>>

<<function isstruct>>

<<function init1>>

<<function newlist>>

<<function sualign>>

<<function round>>

<<function ofnproto>>

<<constant ANSIPROTO>>
<<constant OLDPROTO>>

<<function argmark>>

<<function walkparam>>

<<function markdcl>>

<<function revertdcl>>

<<function fnproto>>

<<function anyproto>>

<<function fnproto1>>

<<function dbgdecl>>

<<function push>>

<<function push1>>

<<function sametype>>

<<function rsametype>>

typedef struct Typetab Typetab;

<<struct Typetab>>

<<function sigind>>

<<function signat>>

<<function signature>>

<<function sign>>

<<function snap>>

<<function dotag>>

<<function dcllabel>>

<<function paramconv>>

<<function adecl>>

<<function pdecl>>

<<function xdecl>>

<<function tmerge>>

<<function edecl>>

<<function maxtype>>

<<function doenum>>

<<function symadjust>>

<<function contig>>
@


\subsection*{[[cc/funct.c]]}

%-------------------------------------------------------------

<<cc/funct.c>>=
#include	"cc.h"

typedef	struct	Ftab	Ftab;
typedef	struct	Gtab	Gtab;

<<struct Ftab>>
<<struct Gtab>>

<<global gtabinit>>
<<global ftabinit>>

<<function isfunct>>
<<function dclfunct>>
@


\subsection*{[[cc/scon.c]]}

%-------------------------------------------------------------

<<cc/scon.c>>=
#include "cc.h"

void	acom1(vlong, Node*);
void	acom2(Node*, Type*);
int	acomcmp1(const void*, const void*);
int	acomcmp2(const void*, const void*);
int	addo(Node*);

<<function acast>>


<<function evconst>>

<<function acom>>

<<function acomcmp1>>

<<function acomcmp2>>

<<function acom2>>

<<function acom1>>

<<function addo>>
@


\subsection*{[[cc/dpchk.c]]}

<<enum fxxx>>=
enum fxxx
{
    Fnone	= 0,

    Fl,
    Fvl,
    Fignor,
    Fstar,
    Fadj,

    Fverb	= 10,
};
@

<<struct Tprot>>=
struct	Tprot
{
    Type*	type;
    Bits	flag;
    Tprot*	link;
};
@

<<struct Tname>>=
struct	Tname
{
    char*	name;
    int	param;
    Tname*	link;
};
@

<<global indchar>>=
static	Type*	indchar;
@

<<global flagbits>>=
static	uchar	flagbits[512];
@

<<global fmtbuf>>=
static	char	fmtbuf[100];
@

<<global lastadj>>=
static	int	lastadj;
@

<<global lastverb>>=
static	int	lastverb;
@

<<global nstar>>=
static	int	nstar;
@

<<global tprot>>=
static	Tprot*	tprot;
@

<<global tname>>=
static	Tname*	tname;
@

<<function argflag>>=
void
argflag(int c, int v)
{

    switch(v) {
    case Fignor:
    case Fstar:
    case Fl:
    case Fvl:
        flagbits[c] = v;
        break;
    case Fverb:
        flagbits[c] = lastverb;
/*print("flag-v %c %d\n", c, lastadj);*/
        lastverb++;
        break;
    case Fadj:
        flagbits[c] = lastadj;
/*print("flag-l %c %d\n", c, lastadj);*/
        lastadj++;
        break;
    }
}
@

<<function getflag>>=
Bits
getflag(char *s)
{
    Bits flag;
    int f;
    char *fmt;
    Rune c;

    fmt = fmtbuf;
    flag = zbits;
    nstar = 0;
    for(;;) {
        s += chartorune(&c, s);
        fmt += runetochar(fmt, &c);
        if(c == 0 || c >= nelem(flagbits))
            break;
        f = flagbits[c];
        switch(f) {
        case Fnone:
            argflag(c, Fverb);
            f = flagbits[c];
            break;
        case Fstar:
            nstar++;
        case Fignor:
            continue;
        case Fl:
            if(bset(flag, Fl))
                flag = bor(flag, blsh(Fvl));
        }
        flag = bor(flag, blsh(f));
        if(f >= Fverb)
            break;
    }
    *fmt = 0;
    return flag;
}
@


<<function arginit>>=
void
arginit(void)
{
    int i;

/* debug['F'] = 1;*/
/* debug['w'] = 1;*/

    lastadj = Fadj;
    lastverb = Fverb;
    indchar = typ(TIND, types[TCHAR]);

    memset(flagbits, Fnone, sizeof(flagbits));

    for(i='0'; i<='9'; i++)
        argflag(i, Fignor);
    argflag('.', Fignor);
    argflag('#', Fignor);
    argflag('u', Fignor);
    argflag('h', Fignor);
    argflag('+', Fignor);
    argflag('-', Fignor);

    argflag('*', Fstar);
    argflag('l', Fl);

    argflag('o', Fverb);
    flagbits['x'] = flagbits['o'];
    flagbits['X'] = flagbits['o'];
}
@


<<function nextarg>>=
Node*
nextarg(Node *n, Node **a)
{
    if(n == Z) {
        *a = Z;
        return Z;
    }
    if(n->op == OLIST) {
        *a = n->left;
        return n->right;
    }
    *a = n;
    return Z;
}
@

<<function checkargs>>=
void
checkargs(Node *nn, char *s, int pos)
{
    Node *a, *n;
    Bits flag;
    Tprot *l;

    if(!debug['F'])
        return;
    n = nn;
    for(;;) {
        s = strchr(s, '%');
        if(s == 0) {
            nextarg(n, &a);
            if(a != Z)
                warn(nn, "more arguments than format %T",
                    a->type);
            return;
        }
        s++;
        flag = getflag(s);
        while(nstar > 0) {
            n = nextarg(n, &a);
            pos++;
            nstar--;
            if(a == Z) {
                warn(nn, "more format than arguments %s",
                    fmtbuf);
                return;
            }
            if(a->type == T)
                continue;
            if(!sametype(types[TINT], a->type) &&
               !sametype(types[TUINT], a->type))
                warn(nn, "format mismatch '*' in %s %T, arg %d",
                    fmtbuf, a->type, pos);
        }
        for(l=tprot; l; l=l->link)
            if(sametype(types[TVOID], l->type)) {
                if(beq(flag, l->flag)) {
                    s++;
                    goto loop;
                }
            }

        n = nextarg(n, &a);
        pos++;
        if(a == Z) {
            warn(nn, "more format than arguments %s",
                fmtbuf);
            return;
        }
        if(a->type == 0)
            continue;
        for(l=tprot; l; l=l->link)
            if(sametype(a->type, l->type)) {
/*print("checking %T/%ulx %T/%ulx\n", a->type, flag.b[0], l->type, l->flag.b[0]);*/
                if(beq(flag, l->flag))
                    goto loop;
            }
        warn(nn, "format mismatch %s %T, arg %d", fmtbuf, a->type, pos);
    loop:;
    }
}
@

<<function dpcheck>>=
void
dpcheck(Node *n)
{
    char *s;
    Node *a, *b;
    Tname *l;
    int i;

    if(n == Z)
        return;
    b = n->left;
    if(b == Z || b->op != ONAME)
        return;
    s = b->sym->name;
    for(l=tname; l; l=l->link)
        if(strcmp(s, l->name) == 0)
            break;
    if(l == 0)
        return;

    i = l->param;
    b = n->right;
    while(i > 0) {
        b = nextarg(b, &a);
        i--;
    }
    if(a == Z) {
        warn(n, "cant find format arg");
        return;
    }
    if(!sametype(indchar, a->type)) {
        warn(n, "format arg type %T", a->type);
        return;
    }
    if(a->op != OADDR || a->left->op != ONAME || a->left->sym != symstring) {
/*		warn(n, "format arg not constant string");*/
        return;
    }
    s = a->left->cstring;
    checkargs(b, s, l->param);
}
@

%<<function newprot>>=
%//void
%//newprot(Sym *m, Type *t, char *s)
%//{
%//    Bits flag;
%//    Tprot *l;
%//
%//    if(t == T) {
%//        warn(Z, "%s: newprot: type not defined", m->name);
%//        return;
%//    }
%//    flag = getflag(s);
%//    for(l=tprot; l; l=l->link)
%//        if(beq(flag, l->flag) && sametype(t, l->type))
%//            return;
%//    l = alloc(sizeof(*l));
%//    l->type = t;
%//    l->flag = flag;
%//    l->link = tprot;
%//    tprot = l;
%//}
%@
%
%<<function newname>>=
%//void
%//newname(char *s, int p)
%//{
%//    Tname *l;
%//
%//    for(l=tname; l; l=l->link)
%//        if(strcmp(l->name, s) == 0) {
%//            if(l->param != p)
%//                yyerror("vargck %s already defined\n", s);
%//            return;
%//        }
%//    l = alloc(sizeof(*l));
%//    l->name = s;
%//    l->param = p;
%//    l->link = tname;
%//    tname = l;
%//}
%@
%
%<<function pragvararg>>=
%//void
%//pragvararg(void)
%//{
%//    Sym *s;
%//    int n, c;
%//    char *t;
%//    Rune r;
%//    Type *ty;
%//
%//    if(!debug['F'])
%//        goto out;
%//    s = getsym();
%//    if(s && strcmp(s->name, "argpos") == 0)
%//        goto ckpos;
%//    if(s && strcmp(s->name, "type") == 0)
%//        goto cktype;
%//    if(s && strcmp(s->name, "flag") == 0)
%//        goto ckflag;
%//    yyerror("syntax in #pragma varargck");
%//    goto out;
%//
%//ckpos:
%///*#pragma	varargck	argpos	warn	2*/
%//    s = getsym();
%//    if(s == S)
%//        goto bad;
%//    n = getnsn();
%//    if(n < 0)
%//        goto bad;
%//    newname(s->name, n);
%//    goto out;
%//
%//ckflag:
%///*#pragma	varargck	flag	'c'*/
%//    c = getnsc();
%//    if(c != '\'')
%//        goto bad;
%//    c = getr();
%//    if(c == '\\')
%//        c = getr();
%//    else if(c == '\'')
%//        goto bad;
%//    if(c == '\n')
%//        goto bad;
%//    if(getc() != '\'')
%//        goto bad;
%//    argflag(c, Fignor);
%//    goto out;
%//
%//cktype:
%///*#pragma	varargck	type	O	int*/
%//    c = getnsc();
%//    if(c != '"')
%//        goto bad;
%//    t = fmtbuf;
%//    for(;;) {
%//        r = getr();
%//        if(r == ' ' || r == '\n')
%//            goto bad;
%//        if(r == '"')
%//            break;
%//        t += runetochar(t, &r);
%//    }
%//    *t = 0;
%//    t = strdup(fmtbuf);
%//    s = getsym();
%//    if(s == S)
%//        goto bad;
%//    ty = s->type;
%//    while((c = getnsc()) == '*')
%//        ty = typ(TIND, ty);
%//    unget(c);
%//    newprot(s, ty, t);
%//    goto out;
%//
%//bad:
%//    yyerror("syntax in #pragma varargck");
%//
%//out:
%//    while(getnsc() != '\n')
%//        ;
%//}
%@
%
%<<function pragpack>>=
%//void
%//pragpack(void)
%//{
%//    Sym *s;
%//
%//    packflg = 0;
%//    s = getsym();
%//    if(s) {
%//        packflg = atoi(s->name+1);
%//        if(strcmp(s->name, "on") == 0 ||
%//           strcmp(s->name, "yes") == 0)
%//            packflg = 1;
%//    }
%//    while(getnsc() != '\n')
%//        ;
%//    if(debug['f'])
%//        if(packflg)
%//            print("%4ld: pack %d\n", lineno, packflg);
%//        else
%//            print("%4ld: pack off\n", lineno);
%//}
%@
%
%<<function pragfpround>>=
%//void
%//pragfpround(void)
%//{
%//    Sym *s;
%//
%//    fproundflg = 0;
%//    s = getsym();
%//    if(s) {
%//        fproundflg = atoi(s->name+1);
%//        if(strcmp(s->name, "on") == 0 ||
%//           strcmp(s->name, "yes") == 0)
%//            fproundflg = 1;
%//    }
%//    while(getnsc() != '\n')
%//        ;
%//    if(debug['f'])
%//        if(fproundflg)
%//            print("%4ld: fproundflg %d\n", lineno, fproundflg);
%//        else
%//            print("%4ld: fproundflg off\n", lineno);
%//}
%@
%
%<<function pragprofile>>=
%//void
%//pragprofile(void)
%//{
%//    Sym *s;
%//
%//    profileflg = false;
%//    s = getsym();
%//    if(s) {
%//        profileflg = atoi(s->name+1);
%//        if(strcmp(s->name, "on") == 0 ||
%//           strcmp(s->name, "yes") == 0)
%//            profileflg = true;
%//    }
%//    while(getnsc() != '\n')
%//        ;
%//    if(debug['f'])
%//        if(profileflg)
%//            print("%4ld: profileflg %d\n", lineno, profileflg);
%//        else
%//            print("%4ld: profileflg off\n", lineno);
%//}
%@
%
%<<function pragincomplete>>=
%//void
%//pragincomplete(void)
%//{
%//    Sym *s;
%//    Type *t;
%//    int istag, w, et;
%//
%//    istag = 0;
%//    s = getsym();
%//    if(s == nil)
%//        goto out;
%//    et = 0;
%//    w = s->lexical;
%//    if(w == LSTRUCT)
%//        et = TSTRUCT;
%//    else if(w == LUNION)
%//        et = TUNION;
%//    if(et != 0){
%//        s = getsym();
%//        if(s == nil){
%//            yyerror("missing struct/union tag in pragma incomplete");
%//            goto out;
%//        }
%//        if(s->lexical != LNAME && s->lexical != LTYPE){
%//            yyerror("invalid struct/union tag: %s", s->name);
%//            goto out;
%//        }
%//        dotag(s, et, 0);
%//        istag = 1;
%//    }else if(strcmp(s->name, "_off_") == 0){
%//        debug['T'] = 0;
%//        goto out;
%//    }else if(strcmp(s->name, "_on_") == 0){
%//        debug['T'] = 1;
%//        goto out;
%//    }
%//    t = s->type;
%//    if(istag)
%//        t = s->suetag;
%//    if(t == T)
%//        yyerror("unknown type %s in pragma incomplete", s->name);
%//    else if(!typesu[t->etype])
%//        yyerror("not struct/union type in pragma incomplete: %s", s->name);
%//    else
%//        t->garb |= GINCOMPLETE;
%//out:
%//    while(getnsc() != '\n')
%//        ;
%//    if(debug['f'])
%//        print("%s incomplete\n", s->name);
%//}
%@


%-------------------------------------------------------------

<<cc/dpchk.c>>=
#include	"cc.h"
#include	"y.tab.h"

<<enum fxxx>>

typedef	struct	Tprot	Tprot;
<<struct Tprot>>

typedef	struct	Tname	Tname;
<<struct Tname>>

<<global indchar>>
<<global flagbits>>
<<global fmtbuf>>
<<global lastadj>>
<<global lastverb>>
<<global nstar>>
<<global tprot>>
<<global tname>>

<<function argflag>>

<<function getflag>>

<<function arginit>>

<<function nextarg>>

<<function checkargs>>

<<function dpcheck>>
@


\subsection*{[[cc/com.c]]}

%-------------------------------------------------------------

<<cc/com.c>>=
#include "cc.h"

int	tcomd(Node*);
int	tcomx(Node*);
int	tlvalue(Node*);

typedef struct Com Com;
typedef struct Big Big;

<<struct Com>>

int compar(Node*, int);
static void comma(Node*);
static Node*	commas(Com*, Node*);

<<function complex>>

<<enum _anon_ (cc/com.c)>>

<<function tcom>>

<<function tcomo>>

<<function tcoma>>

<<function tcomd>>

<<function tcomx>>

<<function tlvalue>>

<<function comargs>>

<<function commas>>

<<function comma>>

<<function ccom>>

<<global cmps>>

<<struct Big>>
<<function cmp>>
<<function add>>

<<function big>>

<<function compar>>

@

\section{[[cc2/]]}

\subsection*{[[cc2/pswt.c]]}

%-------------------------------------------------------------

<<cc2/pswt.c>>=
#include "gc.h"

<<function swcmp>>

<<function doswit>>

<<function casf>>

<<function outlstring>>

<<function nullwarn>>

<<function ieeedtod>>
@


\subsection*{[[cc2/pgen.c]]}

%-------------------------------------------------------------

<<cc2/pgen.c>>=
#include "gc.h"

void	gen(Node*);
void	usedset(Node*, int);
int	bcomplex(Node*, Node*);

<<function codgen>>

<<function supgen>>

<<function uncomma>>

<<function gen>>

<<function usedset>>

<<function bcomplex>>
@

\section{[[5c/]]}

\subsection*{[[5c/enam.c]]}

<<global anames(arm)>>=
char*	anames[] =
{
    "XXX",
    "NOP",
    "AND",
    "ORR",
    "EOR",
    "BIC",
    "ADD",
    "SUB",
    "RSB",
    "ADC",
    "SBC",
    "RSC",
    "MUL",
    "DIV",
    "MOD",
    "MULL",
    "MULAL",
    "MULLU",
    "MULALU",
    "MULA",
    "MULU",
    "DIVU",
    "MODU",
    "SRL",
    "SRA",
    "SLL",
    "TST",
    "TEQ",
    "CMP",
    "CMN",
    "B",
    "BL",
    "BEQ",
    "BNE",
    "BHS",
    "BLO",
    "BMI",
    "BPL",
    "BVS",
    "BVC",
    "BHI",
    "BLS",
    "BGE",
    "BLT",
    "BGT",
    "BLE",
    "RET",
    "MOVW",
    "MOVB",
    "MOVBU",
    "MOVH",
    "MOVHU",
    "MVN",
    "MOVM",
    "SWPW",
    "SWPBU",
    "SWI",
    "RFE",
    "MOVWD",
    "MOVWF",
    "MOVDW",
    "MOVFW",
    "MOVFD",
    "MOVDF",
    "MOVF",
    "MOVD",
    "CMPF",
    "CMPD",
    "ADDF",
    "ADDD",
    "SUBF",
    "SUBD",
    "MULF",
    "MULD",
    "DIVF",
    "DIVD",
    "SQRTF",
    "SQRTD",
    "TEXT",
    "GLOBL",
    "DATA",
    "WORD",
    "END",
    "NAME",
    "HISTORY",
    "CASE",
    "BCASE",
    "SIGNAME",
    "GOK",
    "DYNT",
    "INIT",
    "LAST",
};
@


%-------------------------------------------------------------

<<5c/enam.c>>=
<<global anames(arm)>>
@


\subsection*{[[5c/gc.h]]}

<<constant SZ_CHAR(arm)>>=
/*
 * 5c/arm
 * Arm
 */
#define	SZ_CHAR		1
@

<<constant SZ_SHORT(arm)>>=
#define	SZ_SHORT	2
@

<<constant SZ_INT(arm)>>=
#define	SZ_INT		4
@

<<constant SZ_LONG(arm)>>=
#define	SZ_LONG		4
@

<<constant SZ_IND(arm)>>=
#define	SZ_IND		4
@

<<constant SZ_FLOAT(arm)>>=
#define	SZ_FLOAT	4
@

<<constant SZ_VLONG(arm)>>=
#define	SZ_VLONG	8
@

<<constant SZ_DOUBLE(arm)>>=
#define	SZ_DOUBLE	8
@

<<constant FNX(arm)>>=
#define	FNX		100
@

<<constant BTRUE(arm)>>=
#define	BTRUE		0x1000
@

<<constant R0ISZERO(arm)>>=
#define	R0ISZERO	0
@

<<struct Adr(arm)>>=
struct	Adr
{
    long	offset;
    double	dval;
    char	sval[NSNAME];
    Ieee	ieee;

    Sym*	sym;
    char	type;
    char	reg;
    char	name;
    char	etype;
};
@

<<constant A(arm)>>=
#define	A	((Adr*)0)
@

<<constant INDEXED(arm)>>=
#define	INDEXED	9
@

<<struct Prog(arm)>>=
struct	Prog
{
    Adr	from;
    Adr	to;
    Prog*	link;
    long	lineno;
    char	as;
    char	reg;
    uchar	scond;
};
@

<<constant P(arm)>>=
#define	P	((Prog*)0)
@

<<struct Case(arm)>>=
struct	Case
{
    Case*	link;
    vlong	val;
    long	label;
    char	def;
    char isv;
};
@

<<constant C(arm)>>=
#define	C	((Case*)0)
@

<<struct C1(arm)>>=
struct	C1
{
    vlong	val;
    long	label;
};
@

<<struct Multab(arm)>>=
struct	Multab
{
    long	val;
    char	code[20];
};
@

<<struct Hintab(arm)>>=
struct	Hintab
{
    ushort	val;
    char	hint[10];
};
@

<<struct Var(arm)>>=
struct	Var
{
    long	offset;
    Sym*	sym;
    char	name;
    char	etype;
};
@

<<struct Reg(arm)>>=
struct	Reg
{
    long	pc;
    long	rpo;		/* reverse post ordering */

    Bits	set;
    Bits	use1;
    Bits	use2;

    Bits	refbehind;
    Bits	refahead;
    Bits	calbehind;
    Bits	calahead;
    Bits	regdiff;
    Bits	act;

    long	regu;
    long	loop;		/* could be shorter */

    
    Reg*	log5;
    long	active;

    Reg*	p1;
    Reg*	p2;
    Reg*	p2link;
    Reg*	s1;
    Reg*	s2;
    Reg*	link;
    Prog*	prog;
};
@

<<constant R(arm)>>=
#define	R	((Reg*)0)
@

<<constant NRGN(arm)>>=
#define	NRGN	1000		/* was 600; raised for paranoia.c */
@

<<struct Rgn(arm)>>=
struct	Rgn
{
    Reg*	enter;
    short	cost;
    short	varno;
    short	regno;
};
@

<<function BLOAD(arm)>>=
#define	BLOAD(r)	band(bnot(r->refbehind), r->refahead)
@

<<function BSTORE(arm)>>=
#define	BSTORE(r)	band(bnot(r->calbehind), r->calahead)
@

<<function LOAD(arm)>>=
#define	LOAD(r)		(~r->refbehind.b[z] & r->refahead.b[z])
@

<<function STORE(arm)>>=
#define	STORE(r)	(~r->calbehind.b[z] & r->calahead.b[z])
@

<<function bset(arm)>>=
#define	bset(a,n)	((a).b[(n)/32]&(1L<<(n)%32))
@

<<constant CLOAD(arm)>>=
#define	CLOAD	4
@

<<constant CREF(arm)>>=
#define	CREF	5
@

<<constant CINF(arm)>>=
#define	CINF	1000
@

<<constant LOOP(arm)>>=
#define	LOOP	3
@


%-------------------------------------------------------------

<<5c/gc.h>>=
#include	"../cc/cc.h"

#include	<common.out.h>
#include	"arm/5.out.h"

<<constant SZ_CHAR(arm)>>
<<constant SZ_SHORT(arm)>>
<<constant SZ_INT(arm)>>
<<constant SZ_LONG(arm)>>
<<constant SZ_IND(arm)>>
<<constant SZ_FLOAT(arm)>>
<<constant SZ_VLONG(arm)>>
<<constant SZ_DOUBLE(arm)>>
<<constant FNX(arm)>>
<<constant BTRUE(arm)>>

typedef	struct	Adr	Adr;
typedef	struct	Prog	Prog;
typedef	struct	Case	Case;
typedef	struct	C1	C1;
typedef	struct	Multab	Multab;
typedef	struct	Hintab	Hintab;
typedef	struct	Var	Var;
typedef	struct	Reg	Reg;
typedef	struct	Rgn	Rgn;


<<constant R0ISZERO(arm)>>

<<struct Adr(arm)>>
<<constant A(arm)>>

<<constant INDEXED(arm)>>
<<struct Prog(arm)>>
<<constant P(arm)>>

<<struct Case(arm)>>
<<constant C(arm)>>

<<struct C1(arm)>>

<<struct Multab(arm)>>

<<struct Hintab(arm)>>

<<struct Var(arm)>>

<<struct Reg(arm)>>
<<constant R(arm)>>

<<constant NRGN(arm)>>
<<struct Rgn(arm)>>

extern	long	breakpc;
extern	long	nbreak;
extern	Case*	cases;
extern	Node	constnode;
extern	Node	fconstnode;
extern	long	continpc;
extern	long	curarg;
extern	long	cursafe;
extern	Prog*	firstp;
extern	Prog*	lastp;
extern	long	maxargsafe;
extern	int	mnstring;
extern	Multab	multab[20];
extern	int	hintabsize;
extern	Node*	nodrat;
extern	Node*	nodret;
extern	Node*	nodsafe;
extern	long	nrathole;
extern	long	nstring;
extern	Prog*	p;
extern	long	pc;
extern	Node	regnode;
extern	char	string[NSNAME];
extern	Sym*	symrathole;
extern	Node	znode;
extern	Prog	zprog;
extern	char	reg[NREG+NFREG];
extern	long	exregoffset;
extern	long	exfregoffset;
extern	int	suppress;

<<function BLOAD(arm)>>
<<function BSTORE(arm)>>
<<function LOAD(arm)>>
<<function STORE(arm)>>

<<function bset(arm)>>

<<constant CLOAD(arm)>>
<<constant CREF(arm)>>
<<constant CINF(arm)>>
<<constant LOOP(arm)>>

extern	Rgn	region[NRGN];
extern	Rgn*	rgp;
extern	int	nregion;
extern	int	nvar;

extern	Bits	externs;
extern	Bits	params;
extern	Bits	consts;
extern	Bits	addrs;

extern	long	regbits;
extern	long	exregbits;

extern	int	change;

extern	Reg*	firstr;
extern	Reg*	lastr;
extern	Reg	zreg;
extern	Reg*	freer;
extern	Var	var[NVAR];
extern	long*	idom;
extern	Reg**	rpo2r;
extern	long	maxnr;

extern	char*	anames[];
extern	Hintab	hintab[];

/*
 * sgen.c
 */
void	codgen(Node*, Node*);
void	gen(Node*);
void	noretval(int);
void	usedset(Node*, int);
void	xcom(Node*);
int	bcomplex(Node*, Node*);

/*
 * cgen.c
 */
void	cgen(Node*, Node*);
void	cgenrel(Node*, Node*, int);
void	reglcgen(Node*, Node*, Node*);
void	lcgen(Node*, Node*);
void	bcgen(Node*, int);
void	boolgen(Node*, int, Node*);
void	sugen(Node*, Node*, long);
void	layout(Node*, Node*, int, int, Node*);

/*
 * txt.c
 */
void	ginit(void);
void	gclean(void);
void	nextpc(void);
void	gargs(Node*, Node*, Node*);
void	garg1(Node*, Node*, Node*, int, Node**);
Node*	nodconst(long);
Node*	nod32const(vlong);
Node*	nodfconst(double);
void	nodreg(Node*, Node*, int);
void	regret(Node*, Node*);
int	tmpreg(void);
void	regalloc(Node*, Node*, Node*);
void	regfree(Node*);
void	regialloc(Node*, Node*, Node*);
void	regsalloc(Node*, Node*);
void	regaalloc1(Node*, Node*);
void	regaalloc(Node*, Node*);
void	regind(Node*, Node*);
void	gprep(Node*, Node*);
void	raddr(Node*, Prog*);
void	naddr(Node*, Adr*);
void	gmovm(Node*, Node*, int);
void	gmove(Node*, Node*);
void	gmover(Node*, Node*);
void	gins(int a, Node*, Node*);
void	gopcode(int, Node*, Node*, Node*);
int	samaddr(Node*, Node*);
void	gbranch(int);
void	patch(Prog*, long);
int	sconst(Node*);
int	sval(long);
void	gpseudo(int, Sym*, Node*);

/*
 * swt.c
 */
int	swcmp(const void*, const void*);
void	doswit(Node*);
void	swit1(C1*, int, long, Node*);
void	swit2(C1*, int, long, Node*, Node*);
void	casf(void);
void	bitload(Node*, Node*, Node*, Node*, Node*);
void	bitstore(Node*, Node*, Node*, Node*, Node*);
long	outstring(char*, long);
int	mulcon(Node*, Node*);
Multab*	mulcon0(long);
void	nullwarn(Node*, Node*);
void	gextern(Sym*, Node*, long, long);
void	outcode(void);
void	ieeedtod(Ieee*, double);

/*
 * list
 */
void	listinit(void);
int	Pconv(Fmt*);
int	Aconv(Fmt*);
int	Dconv(Fmt*);
int	Sconv(Fmt*);
int	Nconv(Fmt*);
int	Bconv(Fmt*);
int	Rconv(Fmt*);

/*
 * reg.c
 */
Reg*	rega(void);
int	rcmp(const void*, const void*);
void	regopt(Prog*);
void	addmove(Reg*, int, int, int);
Bits	mkvar(Adr*, int);
void	prop(Reg*, Bits, Bits);
void	loopit(Reg*, long);
void	synch(Reg*, Bits);
ulong	allreg(ulong, Rgn*);
void	paint1(Reg*, int);
ulong	paint2(Reg*, int);
void	paint3(Reg*, int, long, int);
void	addreg(Adr*, int);

/*
 * peep.c
 */
void	peep(void);
void	excise(Reg*);
Reg*	uniqp(Reg*);
Reg*	uniqs(Reg*);
int	regtyp(Adr*);
int	regzer(Adr*);
int	anyvar(Adr*);
int	subprop(Reg*);
int	copyprop(Reg*);
int	shiftprop(Reg*);
void	constprop(Adr*, Adr*, Reg*);
int	copy1(Adr*, Adr*, Reg*, int);
int	copyu(Prog*, Adr*, Adr*);

int	copyas(Adr*, Adr*);
int	copyau(Adr*, Adr*);
int	copyau1(Prog*, Adr*);
int	copysub(Adr*, Adr*, Adr*, int);
int	copysub1(Prog*, Adr*, Adr*, int);

long	RtoB(int);
long	FtoB(int);
int	BtoR(long);
int	BtoF(long);

void	predicate(void); 
int	isbranch(Prog *); 
int	predicable(Prog *p); 
int	modifiescpsr(Prog *p); 

#pragma	varargck	type	"A"	int
#pragma	varargck	type	"B"	Bits
#pragma	varargck	type	"D"	Adr*
#pragma	varargck	type	"N"	Adr*
#pragma	varargck	type	"R"	Adr*
#pragma	varargck	type	"P"	Prog*
#pragma	varargck	type	"S"	char*
@


\subsection*{[[5c/machcap.c]]}

<<function machcap(arm)>>=
/* default, like old cc */
int
machcap(Node*)
{
    return 0;
}
@


%-------------------------------------------------------------

<<5c/machcap.c>>=
#include	"../cc/cc.h"

<<function machcap(arm)>>
@


\subsection*{[[5c/globals2.c]]}

<<global breakpc(arm)>>=
long	breakpc;
@

<<global nbreak(arm)>>=
long	nbreak;
@

<<global cases(arm)>>=
Case*	cases;
@

<<global constnode(arm)>>=
Node	constnode;
@

<<global fconstnode(arm)>>=
Node	fconstnode;
@

<<global continpc(arm)>>=
long	continpc;
@

<<global curarg(arm)>>=
long	curarg;
@

<<global cursafe(arm)>>=
long	cursafe;
@

<<global firstp(arm)>>=
Prog*	firstp;
@

<<global lastp(arm)>>=
Prog*	lastp;
@

<<global maxargsafe(arm)>>=
long	maxargsafe;
@

<<global mnstring(arm)>>=
int	mnstring;
@

<<global multab(arm)>>=
Multab	multab[20];
@

<<global hintabsize(arm)>>=
int	hintabsize;
@

<<global nodrat(arm)>>=
Node*	nodrat;
@

<<global nodret(arm)>>=
Node*	nodret;
@

<<global nodsafe(arm)>>=
Node*	nodsafe;
@

<<global nrathole(arm)>>=
long	nrathole;
@

<<global nstring(arm)>>=
long	nstring;
@

<<global p(arm)>>=
Prog*	p;
@

<<global pc(arm)>>=
long	pc;
@

<<global regnode(arm)>>=
Node	regnode;
@

<<global string(arm)>>=
char	string[NSNAME];
@

<<global symrathole(arm)>>=
Sym*	symrathole;
@

<<global znode(arm)>>=
Node	znode;
@

<<global zprog(arm)>>=
Prog	zprog;
@

<<global reg(arm)>>=
char	reg[NREG+NFREG];
@

<<global exregoffset(arm)>>=
long	exregoffset;
@

<<global exfregoffset(arm)>>=
long	exfregoffset;
@

<<global suppress(arm)>>=
int	suppress;
@

<<global region(arm)>>=
Rgn	region[NRGN];
@

<<global rgp(arm)>>=
Rgn*	rgp;
@

<<global nregion(arm)>>=
int	nregion;
@

<<global nvar(arm)>>=
int	nvar;
@

<<global externs(arm)>>=
Bits	externs;
@

<<global params(arm)>>=
Bits	params;
@

<<global consts(arm)>>=
Bits	consts;
@

<<global addrs(arm)>>=
Bits	addrs;
@

<<global regbits(arm)>>=
long	regbits;
@

<<global exregbits(arm)>>=
long	exregbits;
@

<<global change(arm)>>=
int	change;
@

<<global firstr(arm)>>=
Reg*	firstr;
@

<<global lastr(arm)>>=
Reg*	lastr;
@

<<global zreg(arm)>>=
Reg	zreg;
@

<<global freer(arm)>>=
Reg*	freer;
@

<<global var(arm)>>=
Var	var[NVAR];
@

<<global idom(arm)>>=
long*	idom;
@

<<global rpo2r(arm)>>=
Reg**	rpo2r;
@

<<global maxnr(arm)>>=
long	maxnr;
@


%-------------------------------------------------------------

<<5c/globals2.c>>=
#include "gc.h"

<<global breakpc(arm)>>
<<global nbreak(arm)>>
<<global cases(arm)>>
<<global constnode(arm)>>
<<global fconstnode(arm)>>
<<global continpc(arm)>>
<<global curarg(arm)>>
<<global cursafe(arm)>>
<<global firstp(arm)>>
<<global lastp(arm)>>
<<global maxargsafe(arm)>>
<<global mnstring(arm)>>
<<global multab(arm)>>
<<global hintabsize(arm)>>
<<global nodrat(arm)>>
<<global nodret(arm)>>
<<global nodsafe(arm)>>
<<global nrathole(arm)>>
<<global nstring(arm)>>
<<global p(arm)>>
<<global pc(arm)>>
<<global regnode(arm)>>
<<global string(arm)>>
<<global symrathole(arm)>>
<<global znode(arm)>>
<<global zprog(arm)>>
<<global reg(arm)>>
<<global exregoffset(arm)>>
<<global exfregoffset(arm)>>
<<global suppress(arm)>>

<<global region(arm)>>
<<global rgp(arm)>>
<<global nregion(arm)>>
<<global nvar(arm)>>

<<global externs(arm)>>
<<global params(arm)>>
<<global consts(arm)>>
<<global addrs(arm)>>

<<global regbits(arm)>>
<<global exregbits(arm)>>

<<global change(arm)>>

<<global firstr(arm)>>
<<global lastr(arm)>>
<<global zreg(arm)>>
<<global freer(arm)>>
<<global var(arm)>>
<<global idom(arm)>>
<<global rpo2r(arm)>>
<<global maxnr(arm)>>
@


\subsection*{[[5c/list.c]]}

<<function listinit(arm)>>=
void
listinit(void)
{

    fmtinstall('A', Aconv);
    fmtinstall('P', Pconv);
    fmtinstall('S', Sconv);
    fmtinstall('N', Nconv);
    fmtinstall('B', Bconv);
    fmtinstall('D', Dconv);
    fmtinstall('R', Rconv);
}
@

<<function Bconv(arm)>>=
int
Bconv(Fmt *fp)
{
    char str[STRINGSZ], ss[STRINGSZ], *s;
    Bits bits;
    int i;

    str[0] = 0;
    bits = va_arg(fp->args, Bits);
    while(bany(&bits)) {
        i = bnum(bits);
        if(str[0])
            strcat(str, " ");
        if(var[i].sym == S) {
            snprint(ss, sizeof(ss), "$%ld", var[i].offset);
            s = ss;
        } else
            s = var[i].sym->name;
        if(strlen(str) + strlen(s) + 1 >= STRINGSZ)
            break;
        strcat(str, s);
        bits.b[i/32] &= ~(1L << (i%32));
    }
    return fmtstrcpy(fp, str);
}
@

<<global extra(arm)>>=
char *extra [] = {
    ".EQ", ".NE", ".CS", ".CC", 
    ".MI", ".PL", ".VS", ".VC", 
    ".HI", ".LS", ".GE", ".LT", 
    ".GT", ".LE", "", ".NV",
};
@

<<function Pconv(arm)>>=
int
Pconv(Fmt *fp)
{
    char str[STRINGSZ], sc[20];
    Prog *p;
    int a, s;

    p = va_arg(fp->args, Prog*);
    a = p->as;
    s = p->scond; 
    strcpy(sc, extra[s & C_SCOND]);
    if(s & C_SBIT)
        strcat(sc, ".S");
    if(s & C_PBIT)
        strcat(sc, ".P");
    if(s & C_WBIT)
        strcat(sc, ".W");
    if(s & C_UBIT)		/* ambiguous with FBIT */
        strcat(sc, ".U");
    if(a == AMOVM) {
        if(p->from.type == D_CONST)
            snprint(str, sizeof(str), "	%A%s	%R,%D", a, sc, &p->from, &p->to);
        else
        if(p->to.type == D_CONST)
            snprint(str, sizeof(str), "	%A%s	%D,%R", a, sc, &p->from, &p->to);
        else
            snprint(str, sizeof(str), "	%A%s	%D,%D", a, sc, &p->from, &p->to);
    } else
    if(a == ADATA)
        snprint(str, sizeof(str), "	%A	%D/%d,%D", a, &p->from, p->reg, &p->to);
    else
    if(p->as == ATEXT)
        snprint(str, sizeof(str), "	%A	%D,%d,%D", a, &p->from, p->reg, &p->to);
    else
    if(p->reg == NREG)
        snprint(str, sizeof(str), "	%A%s	%D,%D", a, sc, &p->from, &p->to);
    else
    if(p->from.type != D_FREG)
        snprint(str, sizeof(str), "	%A%s	%D,R%d,%D", a, sc, &p->from, p->reg, &p->to);
    else
        snprint(str, sizeof(str), "	%A%s	%D,F%d,%D", a, sc, &p->from, p->reg, &p->to);
    return fmtstrcpy(fp, str);
}
@

<<function Aconv(arm)>>=
int
Aconv(Fmt *fp)
{
    char *s;
    int a;

    a = va_arg(fp->args, int);
    s = "???";
    if(a >= AXXX && a < ALAST)
        s = anames[a];
    return fmtstrcpy(fp, s);
}
@

<<function Dconv(arm)>>=
int
Dconv(Fmt *fp)
{
    char str[STRINGSZ];
    Adr *a;
    char *op;
    int v;

    a = va_arg(fp->args, Adr*);
    switch(a->type) {

    default:
        snprint(str, sizeof(str), "GOK-type(%d)", a->type);
        break;

    case D_NONE:
        str[0] = 0;
        if(a->name != D_NONE || a->reg != NREG || a->sym != S)
            snprint(str, sizeof(str), "%N(R%d)(NONE)", a, a->reg);
        break;

    case D_CONST:
        if(a->reg != NREG)
            snprint(str, sizeof(str), "$%N(R%d)", a, a->reg);
        else
            snprint(str, sizeof(str), "$%N", a);
        break;

    case D_SHIFT:
        v = a->offset;
        op = "<<>>->@>" + (((v>>5) & 3) << 1);
        if(v & (1<<4))
            snprint(str, sizeof(str), "R%d%c%cR%d", v&15, op[0], op[1], (v>>8)&15);
        else
            snprint(str, sizeof(str), "R%d%c%c%d", v&15, op[0], op[1], (v>>7)&31);
        if(a->reg != NREG)
            sprint(str+strlen(str), "(R%d)", a->reg);
        break;

    case D_OREG:
        if(a->reg != NREG)
            snprint(str, sizeof(str), "%N(R%d)", a, a->reg);
        else
            snprint(str, sizeof(str), "%N", a);
        break;

    case D_REG:
        snprint(str, sizeof(str), "R%d", a->reg);
        if(a->name != D_NONE || a->sym != S)
            snprint(str, sizeof(str), "%N(R%d)(REG)", a, a->reg);
        break;

    case D_FREG:
        snprint(str, sizeof(str), "F%d", a->reg);
        if(a->name != D_NONE || a->sym != S)
            snprint(str, sizeof(str), "%N(R%d)(REG)", a, a->reg);
        break;

    case D_PSR:
        snprint(str, sizeof(str), "PSR");
        if(a->name != D_NONE || a->sym != S)
            snprint(str, sizeof(str), "%N(PSR)(REG)", a);
        break;

    case D_BRANCH:
        snprint(str, sizeof(str), "%ld(PC)", a->offset-pc);
        break;

    case D_FCONST:
        snprint(str, sizeof(str), "$%.17e", a->dval);
        break;

    case D_SCONST:
        snprint(str, sizeof(str), "$\"%S\"", a->sval);
        break;
    }
    return fmtstrcpy(fp, str);
}
@

<<function Rconv(arm)>>=
int
Rconv(Fmt *fp)
{
    char str[STRINGSZ], *p, *e;
    Adr *a;
    int i, v;

    a = va_arg(fp->args, Adr*);
    snprint(str, sizeof(str), "GOK-reglist");
    switch(a->type) {
    case D_CONST:
        if(a->reg != NREG)
            break;
        if(a->sym != S)
            break;
        v = a->offset;
        p = str;
        e = str+sizeof(str);
        for(i=0; i<NREG; i++) {
            if(v & (1<<i)) {
                if(p == str)
                    p = seprint(p, e, "[R%d", i);
                else
                    p = seprint(p, e, ",R%d", i);
            }
        }
        seprint(p, e, "]");
    }
    return fmtstrcpy(fp, str);
}
@

<<function Sconv(arm)>>=
int
Sconv(Fmt *fp)
{
    int i, c;
    char str[STRINGSZ], *p, *a;

    a = va_arg(fp->args, char*);
    p = str;
    for(i=0; i<NSNAME; i++) {
        c = a[i] & 0xff;
        if(c >= 'a' && c <= 'z' ||
           c >= 'A' && c <= 'Z' ||
           c >= '0' && c <= '9' ||
           c == ' ' || c == '%') {
            *p++ = c;
            continue;
        }
        *p++ = '\\';
        switch(c) {
        case 0:
            *p++ = 'z';
            continue;
        case '\\':
        case '"':
            *p++ = c;
            continue;
        case '\n':
            *p++ = 'n';
            continue;
        case '\t':
            *p++ = 't';
            continue;
        case '\r':
            *p++ = 'r';
            continue;
        case '\f':
            *p++ = 'f';
            continue;
        }
        *p++ = (c>>6) + '0';
        *p++ = ((c>>3) & 7) + '0';
        *p++ = (c & 7) + '0';
    }
    *p = 0;
    return fmtstrcpy(fp, str);
}
@

<<function Nconv(arm)>>=
int
Nconv(Fmt *fp)
{
    char str[STRINGSZ];
    Adr *a;
    Sym *s;

    a = va_arg(fp->args, Adr*);
    s = a->sym;
    if(s == S) {
        snprint(str, sizeof(str), "%ld", a->offset);
        goto out;
    }
    switch(a->name) {
    default:
        snprint(str, sizeof(str), "GOK-name(%d)", a->name);
        break;

    case D_NONE:
        snprint(str, sizeof(str), "%ld", a->offset);
        break;

    case D_EXTERN:
        snprint(str, sizeof(str), "%s+%ld(SB)", s->name, a->offset);
        break;

    case D_STATIC:
        snprint(str, sizeof(str), "%s<>+%ld(SB)", s->name, a->offset);
        break;

    case D_AUTO:
        snprint(str, sizeof(str), "%s-%ld(SP)", s->name, -a->offset);
        break;

    case D_PARAM:
        snprint(str, sizeof(str), "%s+%ld(FP)", s->name, a->offset);
        break;
    }
out:
    return fmtstrcpy(fp, str);
}
@


%-------------------------------------------------------------

<<5c/list.c>>=
#include "gc.h"

<<function listinit(arm)>>

<<function Bconv(arm)>>

<<global extra(arm)>>

<<function Pconv(arm)>>

<<function Aconv(arm)>>

<<function Dconv(arm)>>

<<function Rconv(arm)>>

<<function Sconv(arm)>>

<<function Nconv(arm)>>
@


\subsection*{[[5c/txt.c]]}

<<global resvreg(arm)>>=
static	char	resvreg[nelem(reg)];
@

<<function ginit(arm)>>=
void
ginit(void)
{
    Type *t;

    thechar = '5';
    thestring = "arm";
    exregoffset = REGEXT;
    exfregoffset = FREGEXT;
    listinit();
    nstring = 0;
    mnstring = 0;
    nrathole = 0;
    pc = 0;
    breakpc = -1;
    continpc = -1;
    cases = C;
    firstp = P;
    lastp = P;
    tfield = types[TLONG];

    zprog.link = P;
    zprog.as = AGOK;
    zprog.reg = NREG;
    zprog.from.type = D_NONE;
    zprog.from.name = D_NONE;
    zprog.from.reg = NREG;
    zprog.to = zprog.from;
    zprog.scond = 0xE;  

    regnode.op = OREGISTER;
    regnode.class = CEXREG;
    regnode.reg = REGTMP;
    regnode.complex = 0;
    regnode.addable = 11;
    regnode.type = types[TLONG];

    constnode.op = OCONST;
    constnode.class = CXXX;
    constnode.complex = 0;
    constnode.addable = 20;
    constnode.type = types[TLONG];

    fconstnode.op = OCONST;
    fconstnode.class = CXXX;
    fconstnode.complex = 0;
    fconstnode.addable = 20;
    fconstnode.type = types[TDOUBLE];

    nodsafe = new(ONAME, Z, Z);
    nodsafe->sym = slookup(".safe");
    nodsafe->type = types[TINT];
    nodsafe->etype = types[TINT]->etype;
    nodsafe->class = CAUTO;
    complex(nodsafe);

    t = typ(TARRAY, types[TCHAR]);
    symrathole = slookup(".rathole");
    symrathole->class = CGLOBL;
    symrathole->type = t;

    nodrat = new(ONAME, Z, Z);
    nodrat->sym = symrathole;
    nodrat->type = types[TIND];
    nodrat->etype = TVOID;
    nodrat->class = CGLOBL;
    complex(nodrat);
    nodrat->type = t;

    nodret = new(ONAME, Z, Z);
    nodret->sym = slookup(".ret");
    nodret->type = types[TIND];
    nodret->etype = TIND;
    nodret->class = CPARAM;
    nodret = new(OIND, nodret, Z);
    complex(nodret);

    com64init();

    memset(reg, 0, sizeof(reg));
    /* don't allocate */
    reg[REGTMP] = 1;
    reg[REGSB] = 1;
    reg[REGSP] = 1;
    reg[REGLINK] = 1;
    reg[REGPC] = 1;
    /* keep two external registers */
    reg[REGEXT] = 1;
    reg[REGEXT-1] = 1;
    memmove(resvreg, reg, sizeof(reg));
}
@

<<function gclean(arm)>>=
void
gclean(void)
{
    int i;
    Sym *s;

    for(i=0; i<NREG; i++)
        if(reg[i] && !resvreg[i])
            diag(Z, "reg %d left allocated", i);
    for(i=NREG; i<NREG+NFREG; i++)
        if(reg[i] && !resvreg[i])
            diag(Z, "freg %d left allocated", i-NREG);
    while(mnstring)
        outstring("", 1L);
    symstring->type->width = nstring;
    symrathole->type->width = nrathole;
    for(i=0; i<NHASH; i++)
    for(s = hash[i]; s != S; s = s->link) {
        if(s->type == T)
            continue;
        if(s->type->width == 0)
            continue;
        if(s->class != CGLOBL && s->class != CSTATIC)
            continue;
        if(s->type == types[TENUM])
            continue;
        gpseudo(AGLOBL, s, nodconst(s->type->width));
    }
    nextpc();
    p->as = AEND;
    outcode();
}
@

<<function nextpc(arm)>>=
void
nextpc(void)
{

    p = alloc(sizeof(*p));
    *p = zprog;
    p->lineno = nearln;
    pc++;
    if(firstp == P) {
        firstp = p;
        lastp = p;
        return;
    }
    lastp->link = p;
    lastp = p;
}
@

<<function gargs(arm)>>=
void
gargs(Node *n, Node *tn1, Node *tn2)
{
    long regs;
    Node fnxargs[20], *fnxp;

    regs = cursafe;

    fnxp = fnxargs;
    garg1(n, tn1, tn2, 0, &fnxp);	/* compile fns to temps */

    curarg = 0;
    fnxp = fnxargs;
    garg1(n, tn1, tn2, 1, &fnxp);	/* compile normal args and temps */

    cursafe = regs;
}
@

<<function garg1(arm)>>=
void
garg1(Node *n, Node *tn1, Node *tn2, int f, Node **fnxp)
{
    Node nod;

    if(n == Z)
        return;
    if(n->op == OLIST) {
        garg1(n->left, tn1, tn2, f, fnxp);
        garg1(n->right, tn1, tn2, f, fnxp);
        return;
    }
    if(f == 0) {
        if(n->complex >= FNX) {
            regsalloc(*fnxp, n);
            nod = znode;
            nod.op = OAS;
            nod.left = *fnxp;
            nod.right = n;
            nod.type = n->type;
            cgen(&nod, Z);
            (*fnxp)++;
        }
        return;
    }
    if(typesuv[n->type->etype]) {
        regaalloc(tn2, n);
        if(n->complex >= FNX) {
            sugen(*fnxp, tn2, n->type->width);
            (*fnxp)++;
        } else
            sugen(n, tn2, n->type->width);
        return;
    }
    if(REGARG >= 0 && curarg == 0 && typechlp[n->type->etype]) {
        regaalloc1(tn1, n);
        if(n->complex >= FNX) {
            cgen(*fnxp, tn1);
            (*fnxp)++;
        } else
            cgen(n, tn1);
        return;
    }
    regalloc(tn1, n, Z);
    if(n->complex >= FNX) {
        cgen(*fnxp, tn1);
        (*fnxp)++;
    } else
        cgen(n, tn1);
    regaalloc(tn2, n);
    gopcode(OAS, tn1, Z, tn2);
    regfree(tn1);
}
@

<<function nodconst(arm)>>=
Node*
nodconst(long v)
{
    constnode.vconst = v;
    return &constnode;
}
@

<<function nod32const(arm)>>=
Node*
nod32const(vlong v)
{
    constnode.vconst = v & MASK(32);
    return &constnode;
}
@

<<function nodfconst(arm)>>=
Node*
nodfconst(double d)
{
    fconstnode.fconst = d;
    return &fconstnode;
}
@

<<function nodreg(arm)>>=
void
nodreg(Node *n, Node *nn, int reg)
{
    *n = regnode;
    n->reg = reg;
    n->type = nn->type;
    n->lineno = nn->lineno;
}
@

<<function regret(arm)>>=
void
regret(Node *n, Node *nn)
{
    int r;

    r = REGRET;
    if(typefd[nn->type->etype])
        r = FREGRET+NREG;
    nodreg(n, nn, r);
    reg[r]++;
}
@

<<function tmpreg(arm)>>=
int
tmpreg(void)
{
    int i;

    for(i=REGRET+1; i<NREG; i++)
        if(reg[i] == 0)
            return i;
    diag(Z, "out of fixed registers");
    return 0;
}
@

<<function regalloc(arm)>>=
void
regalloc(Node *n, Node *tn, Node *o)
{
    int i, j;
    static int lasti;

    switch(tn->type->etype) {
    case TCHAR:
    case TUCHAR:
    case TSHORT:
    case TUSHORT:
    case TINT:
    case TUINT:
    case TLONG:
    case TULONG:
    case TIND:
        if(o != Z && o->op == OREGISTER) {
            i = o->reg;
            if(i >= 0 && i < NREG)
                goto out;
        }
        j = lasti + REGRET+1;
        for(i=REGRET+1; i<NREG; i++) {
            if(j >= NREG)
                j = REGRET+1;
            if(reg[j] == 0 && resvreg[j] == 0) {
                i = j;
                goto out;
            }
            j++;
        }
        diag(tn, "out of fixed registers");
        goto err;

    case TFLOAT:
    case TDOUBLE:
    case TVLONG:
        if(o != Z && o->op == OREGISTER) {
            i = o->reg;
            if(i >= NREG && i < NREG+NFREG)
                goto out;
        }
        j = 0*2 + NREG;
        for(i=NREG; i<NREG+NFREG; i++) {
            if(j >= NREG+NFREG)
                j = NREG;
            if(reg[j] == 0) {
                i = j;
                goto out;
            }
            j++;
        }
        diag(tn, "out of float registers");
        goto err;
    }
    diag(tn, "unknown type in regalloc: %T", tn->type);
err:
    nodreg(n, tn, 0);
    return;
out:
    reg[i]++;
    lasti++;
    if(lasti >= 5)
        lasti = 0;
    nodreg(n, tn, i);
}
@

<<function regialloc(arm)>>=
void
regialloc(Node *n, Node *tn, Node *o)
{
    Node nod;

    nod = *tn;
    nod.type = types[TIND];
    regalloc(n, &nod, o);
}
@

<<function regfree(arm)>>=
void
regfree(Node *n)
{
    int i;

    i = 0;
    if(n->op != OREGISTER && n->op != OINDREG)
        goto err;
    i = n->reg;
    if(i < 0 || i >= sizeof(reg))
        goto err;
    if(reg[i] <= 0)
        goto err;
    reg[i]--;
    return;
err:
    diag(n, "error in regfree: %d", i);
}
@

<<function regsalloc(arm)>>=
void
regsalloc(Node *n, Node *nn)
{
    cursafe = align(cursafe, nn->type, Aaut3);
    maxargsafe = maxround(maxargsafe, cursafe+curarg);
    *n = *nodsafe;
    n->xoffset = -(stkoff + cursafe);
    n->type = nn->type;
    n->etype = nn->type->etype;
    n->lineno = nn->lineno;
}
@

<<function regaalloc1(arm)>>=
void
regaalloc1(Node *n, Node *nn)
{
    nodreg(n, nn, REGARG);
    reg[REGARG]++;
    curarg = align(curarg, nn->type, Aarg1);
    curarg = align(curarg, nn->type, Aarg2);
    maxargsafe = maxround(maxargsafe, cursafe+curarg);
}
@

<<function regaalloc(arm)>>=
void
regaalloc(Node *n, Node *nn)
{
    curarg = align(curarg, nn->type, Aarg1);
    *n = *nn;
    n->op = OINDREG;
    n->reg = REGSP;
    n->xoffset = curarg + SZ_LONG;
    n->complex = 0;
    n->addable = 20;
    curarg = align(curarg, nn->type, Aarg2);
    maxargsafe = maxround(maxargsafe, cursafe+curarg);
}
@

<<function regind(arm)>>=
void
regind(Node *n, Node *nn)
{

    if(n->op != OREGISTER) {
        diag(n, "regind not OREGISTER");
        return;
    }
    n->op = OINDREG;
    n->type = nn->type;
}
@

<<function raddr(arm)>>=
void
raddr(Node *n, Prog *p)
{
    Adr a;

    naddr(n, &a);
    if(R0ISZERO && a.type == D_CONST && a.offset == 0) {
        a.type = D_REG;
        a.reg = 0;
    }
    if(a.type != D_REG && a.type != D_FREG) {
        if(n)
            diag(n, "bad in raddr: %O", n->op);
        else
            diag(n, "bad in raddr: <null>");
        p->reg = NREG;
    } else
        p->reg = a.reg;
}
@

<<function naddr(arm)>>=
void
naddr(Node *n, Adr *a)
{
    long v;

    a->type = D_NONE;
    if(n == Z)
        return;
    switch(n->op) {
    default:
    bad:
        diag(n, "bad in naddr: %O", n->op);
        break;

    case OREGISTER:
        a->type = D_REG;
        a->sym = S;
        a->reg = n->reg;
        if(a->reg >= NREG) {
            a->type = D_FREG;
            a->reg -= NREG;
        }
        break;

    case OIND:
        naddr(n->left, a);
        if(a->type == D_REG) {
            a->type = D_OREG;
            break;
        }
        if(a->type == D_CONST) {
            a->type = D_OREG;
            break;
        }
        goto bad;

    case OINDREG:
        a->type = D_OREG;
        a->sym = S;
        a->offset = n->xoffset;
        a->reg = n->reg;
        break;

    case ONAME:
        a->etype = n->etype;
        a->type = D_OREG;
        a->name = D_STATIC;
        a->sym = n->sym;
        a->offset = n->xoffset;
        if(n->class == CSTATIC)
            break;
        if(n->class == CEXTERN || n->class == CGLOBL) {
            a->name = D_EXTERN;
            break;
        }
        if(n->class == CAUTO) {
            a->name = D_AUTO;
            break;
        }
        if(n->class == CPARAM) {
            a->name = D_PARAM;
            break;
        }
        goto bad;

    case OCONST:
        a->sym = S;
        a->reg = NREG;
        if(typefd[n->type->etype]) {
            a->type = D_FCONST;
            a->dval = n->fconst;
        } else {
            a->type = D_CONST;
            a->offset = n->vconst;
        }
        break;

    case OADDR:
        naddr(n->left, a);
        if(a->type == D_OREG) {
            a->type = D_CONST;
            break;
        }
        goto bad;

    case OADD:
        if(n->left->op == OCONST) {
            naddr(n->left, a);
            v = a->offset;
            naddr(n->right, a);
        } else {
            naddr(n->right, a);
            v = a->offset;
            naddr(n->left, a);
        }
        a->offset += v;
        break;

    }
}
@

<<function fop(arm)>>=
void
fop(int as, int f1, int f2, Node *t)
{
    Node nod1, nod2, nod3;

    nodreg(&nod1, t, NREG+f1);
    nodreg(&nod2, t, NREG+f2);
    regalloc(&nod3, t, t);
    gopcode(as, &nod1, &nod2, &nod3);
    gmove(&nod3, t);
    regfree(&nod3);
}
@

<<function gmovm(arm)>>=
void
gmovm(Node *f, Node *t, int w)
{
    gins(AMOVM, f, t);
    p->scond |= C_UBIT;
    if(w)
        p->scond |= C_WBIT;
}
@

<<function gmove(arm)>>=
void
gmove(Node *f, Node *t)
{
    int ft, tt, a;
    Node nod, nod1;
    Prog *p1;

    ft = f->type->etype;
    tt = t->type->etype;

    if(ft == TDOUBLE && f->op == OCONST) {
    }
    if(ft == TFLOAT && f->op == OCONST) {
    }

    /*
     * a load --
     * put it into a register then
     * worry what to do with it.
     */
    if(f->op == ONAME || f->op == OINDREG || f->op == OIND) {
        switch(ft) {
        default:
            a = AMOVW;
            break;
        case TFLOAT:
            a = AMOVF;
            break;
        case TDOUBLE:
            a = AMOVD;
            break;
        case TCHAR:
            a = AMOVB;
            break;
        case TUCHAR:
            a = AMOVBU;
            break;
        case TSHORT:
            a = AMOVH;
            break;
        case TUSHORT:
            a = AMOVHU;
            break;
        }
        if(typechlp[ft] && typeilp[tt])
            regalloc(&nod, t, t);
        else
            regalloc(&nod, f, t);
        gins(a, f, &nod);
        gmove(&nod, t);
        regfree(&nod);
        return;
    }

    /*
     * a store --
     * put it into a register then
     * store it.
     */
    if(t->op == ONAME || t->op == OINDREG || t->op == OIND) {
        switch(tt) {
        default:
            a = AMOVW;
            break;
        case TUCHAR:
            a = AMOVBU;
            break;
        case TCHAR:
            a = AMOVB;
            break;
        case TUSHORT:
            a = AMOVHU;
            break;
        case TSHORT:
            a = AMOVH;
            break;
        case TFLOAT:
            a = AMOVF;
            break;
        case TVLONG:
        case TDOUBLE:
            a = AMOVD;
            break;
        }
        if(ft == tt)
            regalloc(&nod, t, f);
        else
            regalloc(&nod, t, Z);
        gmove(f, &nod);
        gins(a, &nod, t);
        regfree(&nod);
        return;
    }

    /*
     * type x type cross table
     */
    a = AGOK;
    switch(ft) {
    case TDOUBLE:
    case TVLONG:
    case TFLOAT:
        switch(tt) {
        case TDOUBLE:
        case TVLONG:
            a = AMOVD;
            if(ft == TFLOAT)
                a = AMOVFD;
            break;
        case TFLOAT:
            a = AMOVDF;
            if(ft == TFLOAT)
                a = AMOVF;
            break;
        case TINT:
        case TUINT:
        case TLONG:
        case TULONG:
        case TIND:
            a = AMOVDW;
            if(ft == TFLOAT)
                a = AMOVFW;
            break;
        case TSHORT:
        case TUSHORT:
        case TCHAR:
        case TUCHAR:
            a = AMOVDW;
            if(ft == TFLOAT)
                a = AMOVFW;
            break;
        }
        break;
    case TUINT:
    case TULONG:
        if(tt == TFLOAT || tt == TDOUBLE) {
            // ugly and probably longer than necessary,
            // but vfp has a single instruction for this,
            // so hopefully it won't last long.
            //
            //	tmp = f
            //	tmp1 = tmp & 0x80000000
            //	tmp ^= tmp1
            //	t = float(int32(tmp))
            //	if(tmp1)
            //		t += 2147483648.
            //
            regalloc(&nod, f, Z);
            regalloc(&nod1, f, Z);
            gins(AMOVW, f, &nod);
            gins(AMOVW, &nod, &nod1);
            gins(AAND, nodconst(0x80000000), &nod1);
            gins(AEOR, &nod1, &nod);
            if(tt == TFLOAT)
                gins(AMOVWF, &nod, t);
            else
                gins(AMOVWD, &nod, t);
            gins(ACMP, nodconst(0), Z);
            raddr(&nod1, p);
            gins(ABEQ, Z, Z);
            regfree(&nod);
            regfree(&nod1);
            p1 = p;
            regalloc(&nod, t, Z);
            if(tt == TFLOAT) {
                gins(AMOVF, nodfconst(2147483648.), &nod);
                gins(AADDF, &nod, t);
            } else {
                gins(AMOVD, nodfconst(2147483648.), &nod);
                gins(AADDD, &nod, t);
            }
            regfree(&nod);
            patch(p1, pc);
            return;
        }
        // fall through

    case TINT:
    case TLONG:
    case TIND:
        switch(tt) {
        case TDOUBLE:
            gins(AMOVWD, f, t);
            return;
        case TFLOAT:
            gins(AMOVWF, f, t);
            return;
        case TINT:
        case TUINT:
        case TLONG:
        case TULONG:
        case TIND:
        case TSHORT:
        case TUSHORT:
        case TCHAR:
        case TUCHAR:
            a = AMOVW;
            break;
        }
        break;
    case TSHORT:
        switch(tt) {
        case TDOUBLE:
            regalloc(&nod, f, Z);
            gins(AMOVH, f, &nod);
            gins(AMOVWD, &nod, t);
            regfree(&nod);
            return;
        case TFLOAT:
            regalloc(&nod, f, Z);
            gins(AMOVH, f, &nod);
            gins(AMOVWF, &nod, t);
            regfree(&nod);
            return;
        case TUINT:
        case TINT:
        case TULONG:
        case TLONG:
        case TIND:
            a = AMOVH;
            break;
        case TSHORT:
        case TUSHORT:
        case TCHAR:
        case TUCHAR:
            a = AMOVW;
            break;
        }
        break;
    case TUSHORT:
        switch(tt) {
        case TDOUBLE:
            regalloc(&nod, f, Z);
            gins(AMOVHU, f, &nod);
            gins(AMOVWD, &nod, t);
            regfree(&nod);
            return;
        case TFLOAT:
            regalloc(&nod, f, Z);
            gins(AMOVHU, f, &nod);
            gins(AMOVWF, &nod, t);
            regfree(&nod);
            return;
        case TINT:
        case TUINT:
        case TLONG:
        case TULONG:
        case TIND:
            a = AMOVHU;
            break;
        case TSHORT:
        case TUSHORT:
        case TCHAR:
        case TUCHAR:
            a = AMOVW;
            break;
        }
        break;
    case TCHAR:
        switch(tt) {
        case TDOUBLE:
            regalloc(&nod, f, Z);
            gins(AMOVB, f, &nod);
            gins(AMOVWD, &nod, t);
            regfree(&nod);
            return;
        case TFLOAT:
            regalloc(&nod, f, Z);
            gins(AMOVB, f, &nod);
            gins(AMOVWF, &nod, t);
            regfree(&nod);
            return;
        case TINT:
        case TUINT:
        case TLONG:
        case TULONG:
        case TIND:
        case TSHORT:
        case TUSHORT:
            a = AMOVB;
            break;
        case TCHAR:
        case TUCHAR:
            a = AMOVW;
            break;
        }
        break;
    case TUCHAR:
        switch(tt) {
        case TDOUBLE:
            regalloc(&nod, f, Z);
            gins(AMOVBU, f, &nod);
            gins(AMOVWD, &nod, t);
            regfree(&nod);
            return;
        case TFLOAT:
            regalloc(&nod, f, Z);
            gins(AMOVBU, f, &nod);
            gins(AMOVWF, &nod, t);
            regfree(&nod);
            return;
        case TINT:
        case TUINT:
        case TLONG:
        case TULONG:
        case TIND:
        case TSHORT:
        case TUSHORT:
            a = AMOVBU;
            break;
        case TCHAR:
        case TUCHAR:
            a = AMOVW;
            break;
        }
        break;
    }
    if(a == AGOK)
        diag(Z, "bad opcode in gmove %T -> %T", f->type, t->type);
    if(a == AMOVW || a == AMOVF || a == AMOVD)
    if(samaddr(f, t))
        return;
    gins(a, f, t);
}
@

<<function gmover(arm)>>=
void
gmover(Node *f, Node *t)
{
    int ft, tt, a;

    ft = f->type->etype;
    tt = t->type->etype;
    a = AGOK;
    if(typechlp[ft] && typechlp[tt] && ewidth[ft] >= ewidth[tt]){
        switch(tt){
        case TSHORT:
            a = AMOVH;
            break;
        case TUSHORT:
            a = AMOVHU;
            break;
        case TCHAR:
            a = AMOVB;
            break;
        case TUCHAR:
            a = AMOVBU;
            break;
        }
    }
    if(a == AGOK)
        gmove(f, t);
    else
        gins(a, f, t);
}
@

<<function gins(arm)>>=
void
gins(int a, Node *f, Node *t)
{

    nextpc();
    p->as = a;
    if(f != Z)
        naddr(f, &p->from);
    if(t != Z)
        naddr(t, &p->to);
    if(debug['g'])
        print("%P\n", p);
}
@

<<function gopcode(arm)>>=
void
gopcode(int o, Node *f1, Node *f2, Node *t)
{
    int a, et, true;
    Adr ta;

    et = TLONG;
    if(f1 != Z && f1->type != T)
        et = f1->type->etype;
    true = o & BTRUE;
    o &= ~BTRUE;
    a = AGOK;
    switch(o) {
    case OAS:
        gmove(f1, t);
        return;

    case OASADD:
    case OADD:
        a = AADD;
        if(et == TFLOAT)
            a = AADDF;
        else
        if(et == TDOUBLE || et == TVLONG)
            a = AADDD;
        break;

    case OASSUB:
    case OSUB:
        if(f2 && f2->op == OCONST) {
            Node *t = f1;
            f1 = f2;
            f2 = t;
            a = ARSB;
        } else
            a = ASUB;
        if(et == TFLOAT)
            a = ASUBF;
        else
        if(et == TDOUBLE || et == TVLONG)
            a = ASUBD;
        break;

    case OASOR:
    case OOR:
        a = AORR;
        break;

    case OASAND:
    case OAND:
        a = AAND;
        break;

    case OASXOR:
    case OXOR:
        a = AEOR;
        break;

    case OASLSHR:
    case OLSHR:
        a = ASRL;
        break;

    case OASASHR:
    case OASHR:
        a = ASRA;
        break;

    case OASASHL:
    case OASHL:
        a = ASLL;
        break;

    case OFUNC:
        a = ABL;
        break;

    case OASMUL:
    case OMUL:
        a = AMUL;
        if(et == TFLOAT)
            a = AMULF;
        else
        if(et == TDOUBLE || et == TVLONG)
            a = AMULD;
        break;

    case OASDIV:
    case ODIV:
        a = ADIV;
        if(et == TFLOAT)
            a = ADIVF;
        else
        if(et == TDOUBLE || et == TVLONG)
            a = ADIVD;
        break;

    case OASMOD:
    case OMOD:
        a = AMOD;
        break;

    case OASLMUL:
    case OLMUL:
        a = AMULU;
        break;

    case OASLMOD:
    case OLMOD:
        a = AMODU;
        break;

    case OASLDIV:
    case OLDIV:
        a = ADIVU;
        break;

    case OCASE:
    case OEQ:
    case ONE:
    case OLT:
    case OLE:
    case OGE:
    case OGT:
    case OLO:
    case OLS:
    case OHS:
    case OHI:
        a = ACMP;
        if(et == TFLOAT)
            a = ACMPF;
        else
        if(et == TDOUBLE || et == TVLONG)
            a = ACMPD;
        nextpc();
        p->as = a;
        naddr(f1, &p->from);
        if(a == ACMP && f1->op == OCONST && p->from.offset < 0 &&
            p->from.offset != 0x80000000) {
            p->as = ACMN;
            p->from.offset = -p->from.offset;
        }
        raddr(f2, p);
        switch(o) {
        case OEQ:
            a = ABEQ;
            break;
        case ONE:
            a = ABNE;
            break;
        case OLT:
            a = ABLT;
            /* ensure NaN comparison is always false */
            if(typefd[et] && !true)
                a = ABMI;
            break;
        case OLE:
            a = ABLE;
            if(typefd[et] && !true)
                a = ABLS;
            break;
        case OGE:
            a = ABGE;
            if(typefd[et] && true)
                a = ABPL;
            break;
        case OGT:
            a = ABGT;
            if(typefd[et] && true)
                a = ABHI;
            break;
        case OLO:
            a = ABLO;
            break;
        case OLS:
            a = ABLS;
            break;
        case OHS:
            a = ABHS;
            break;
        case OHI:
            a = ABHI;
            break;
        case OCASE:
            nextpc();
            p->as = ACASE;
            p->scond = 0x9;
            naddr(f2, &p->from);
            a = ABHI;
            break;
        }
        f1 = Z;
        f2 = Z;
        break;
    }
    if(a == AGOK)
        diag(Z, "bad in gopcode %O", o);
    nextpc();
    p->as = a;
    if(f1 != Z)
        naddr(f1, &p->from);
    if(f2 != Z) {
        naddr(f2, &ta);
        p->reg = ta.reg;
    }
    if(t != Z)
        naddr(t, &p->to);
    if(debug['g'])
        print("%P\n", p);
}
@

<<function samaddr(arm)>>=
int samaddr(Node *f, Node *t)
{

    if(f->op != t->op)
        return 0;
    switch(f->op) {

    case OREGISTER:
        if(f->reg != t->reg)
            break;
        return 1;
    }
    return 0;
}
@

<<function gbranch(arm)>>=
void
gbranch(int o)
{
    int a;

    a = AGOK;
    switch(o) {
    case ORETURN:
        a = ARET;
        break;
    case OGOTO:
        a = AB;
        break;
    }
    nextpc();
    if(a == AGOK) {
        diag(Z, "bad in gbranch %O",  o);
        nextpc();
    }
    p->as = a;
}
@

<<function patch(arm)>>=
void
patch(Prog *op, long pc)
{

    op->to.offset = pc;
    op->to.type = D_BRANCH;
}
@

<<function gpseudo(arm)>>=
void
gpseudo(int a, Sym *s, Node *n)
{

    nextpc();
    p->as = a;
    p->from.type = D_OREG;
    p->from.sym = s;
    p->from.name = D_EXTERN;
    if(a == ATEXT)
        p->reg = (profileflg ? 0 : NOPROF);
    if(s->class == CSTATIC)
        p->from.name = D_STATIC;
    naddr(n, &p->to);
    if(a == ADATA || a == AGLOBL)
        pc--;
}
@

<<function sconst(arm)>>=
int
sconst(Node *n)
{
    vlong vv;

    if(n->op == OCONST) {
        if(!typefd[n->type->etype]) {
            vv = n->vconst;
            if(vv >= (vlong)(-32766) && vv < (vlong)32766)
                return 1;
            /*
             * should be specialised for constant values which will
             * fit in different instructionsl; for now, let 5l
             * sort it out
             */
            return 1;
        }
    }
    return 0;
}
@

<<function sval(arm)>>=
int
sval(long v)
{
    int i;

    for(i=0; i<16; i++) {
        if((v & ~0xff) == 0)
            return 1;
        if((~v & ~0xff) == 0)
            return 1;
        v = (v<<2) | ((ulong)v>>30);
    }
    return 0;
}
@

<<function exreg(arm)>>=
long
exreg(Type *t)
{
    long o;

    if(typechlp[t->etype]) {
        if(exregoffset <= REGEXT-2)
            return 0;
        o = exregoffset;
        if(reg[o] && !resvreg[o])
            return 0;
        resvreg[o] = reg[o] = 1;
        exregoffset--;
        return o;
    }
    if(typefd[t->etype]) {
        if(exfregoffset <= NFREG-1)
            return 0;
        o = exfregoffset + NREG;
        if(reg[o] && !resvreg[o])
            return 0;
        resvreg[o] = reg[o] = 1;
        exfregoffset--;
        return o;
    }
    return 0;
}
@

<<global ewidth(arm)>>=
schar	ewidth[NTYPE] =
{
    -1,		/* [TXXX] */
    SZ_CHAR,	/* [TCHAR] */
    SZ_CHAR,	/* [TUCHAR] */
    SZ_SHORT,	/* [TSHORT] */
    SZ_SHORT,	/* [TUSHORT] */
    SZ_INT,		/* [TINT] */
    SZ_INT,		/* [TUINT] */
    SZ_LONG,	/* [TLONG] */
    SZ_LONG,	/* [TULONG] */
    SZ_VLONG,	/* [TVLONG] */
    SZ_VLONG,	/* [TUVLONG] */
    SZ_FLOAT,	/* [TFLOAT] */
    SZ_DOUBLE,	/* [TDOUBLE] */
    SZ_IND,		/* [TIND] */
    0,		/* [TFUNC] */
    -1,		/* [TARRAY] */
    0,		/* [TVOID] */
    -1,		/* [TSTRUCT] */
    -1,		/* [TUNION] */
    SZ_INT,		/* [TENUM] */
};
@

<<global ncast(arm)>>=
long	ncast[NTYPE] =
{
    0,				/* [TXXX] */
    BCHAR|BUCHAR,			/* [TCHAR] */
    BCHAR|BUCHAR,			/* [TUCHAR] */
    BSHORT|BUSHORT,			/* [TSHORT] */
    BSHORT|BUSHORT,			/* [TUSHORT] */
    BINT|BUINT|BLONG|BULONG|BIND,	/* [TINT] */
    BINT|BUINT|BLONG|BULONG|BIND,	/* [TUINT] */
    BINT|BUINT|BLONG|BULONG|BIND,	/* [TLONG] */
    BINT|BUINT|BLONG|BULONG|BIND,	/* [TULONG] */
    BVLONG|BUVLONG,			/* [TVLONG] */
    BVLONG|BUVLONG,			/* [TUVLONG] */
    BFLOAT,				/* [TFLOAT] */
    BDOUBLE,			/* [TDOUBLE] */
    BLONG|BULONG|BIND,		/* [TIND] */
    0,				/* [TFUNC] */
    0,				/* [TARRAY] */
    0,				/* [TVOID] */
    BSTRUCT,			/* [TSTRUCT] */
    BUNION,				/* [TUNION] */
    0,				/* [TENUM] */
};
@


%-------------------------------------------------------------

<<5c/txt.c>>=
#include "gc.h"

<<global resvreg(arm)>>

<<function ginit(arm)>>

<<function gclean(arm)>>

<<function nextpc(arm)>>

<<function gargs(arm)>>

<<function garg1(arm)>>

<<function nodconst(arm)>>

<<function nod32const(arm)>>

<<function nodfconst(arm)>>

<<function nodreg(arm)>>

<<function regret(arm)>>

<<function tmpreg(arm)>>

<<function regalloc(arm)>>

<<function regialloc(arm)>>

<<function regfree(arm)>>

<<function regsalloc(arm)>>

<<function regaalloc1(arm)>>

<<function regaalloc(arm)>>

<<function regind(arm)>>

<<function raddr(arm)>>

<<function naddr(arm)>>

<<function fop(arm)>>

<<function gmovm(arm)>>

<<function gmove(arm)>>

<<function gmover(arm)>>

<<function gins(arm)>>

<<function gopcode(arm)>>

<<function samaddr(arm)>>

<<function gbranch(arm)>>

<<function patch(arm)>>

<<function gpseudo(arm)>>

<<function sconst(arm)>>

<<function sval(arm)>>

<<function exreg(arm)>>

<<global ewidth(arm)>>

<<global ncast(arm)>>
@


\subsection*{[[5c/peep.c]]}

<<function peep(arm)>>=
void
peep(void)
{
    Reg *r, *r1, *r2;
    Prog *p, *p1;
    int t;
/*
 * complete R structure
 */
    t = 0;
    for(r=firstr; r!=R; r=r1) {
        r1 = r->link;
        if(r1 == R)
            break;
        p = r->prog->link;
        while(p != r1->prog)
        switch(p->as) {
        default:
            r2 = rega();
            r->link = r2;
            r2->link = r1;

            r2->prog = p;
            r2->p1 = r;
            r->s1 = r2;
            r2->s1 = r1;
            r1->p1 = r2;

            r = r2;
            t++;

        case ADATA:
        case AGLOBL:
        case ANAME:
        case ASIGNAME:
            p = p->link;
        }
    }

loop1:
    t = 0;
    for(r=firstr; r!=R; r=r->link) {
        p = r->prog;
        if(p->as == ASLL || p->as == ASRL || p->as == ASRA) {
            /*
             * elide shift into D_SHIFT operand of subsequent instruction
             */
            if(shiftprop(r)) {
                excise(r);
                t++;
            }
        }
        if(p->as == AMOVW || p->as == AMOVF || p->as == AMOVD)
        if(regtyp(&p->to)) {
            if(p->from.type == D_CONST)
                constprop(&p->from, &p->to, r->s1);
            else if(regtyp(&p->from))
            if(p->from.type == p->to.type) {
                if(copyprop(r)) {
                    excise(r);
                    t++;
                } else
                if(subprop(r) && copyprop(r)) {
                    excise(r);
                    t++;
                }
            }
        }
    }
    if(t)
        goto loop1;
    /*
     * look for MOVB x,R; MOVB R,R
     */
    for(r=firstr; r!=R; r=r->link) {
        p = r->prog;
        switch(p->as) {
        default:
            continue;
        case AEOR:
            /*
             * EOR -1,x,y => MVN x,y
             */
            if(p->from.type == D_CONST && p->from.offset == -1) {
                p->as = AMVN;
                p->from.type = D_REG;
                if(p->reg != NREG)
                    p->from.reg = p->reg;
                else
                    p->from.reg = p->to.reg;
                p->reg = NREG;
            }
            continue;
        case AMOVH:
        case AMOVHU:
        case AMOVB:
        case AMOVBU:
            if(p->to.type != D_REG)
                continue;
            break;
        }
        r1 = r->link;
        if(r1 == R)
            continue;
        p1 = r1->prog;
        if(p1->as != p->as)
            continue;
        if(p1->from.type != D_REG || p1->from.reg != p->to.reg)
            continue;
        if(p1->to.type != D_REG || p1->to.reg != p->to.reg)
            continue;
        excise(r1);
    }

    for(r=firstr; r!=R; r=r->link) {
        p = r->prog;
        switch(p->as) {
        case AMOVW:
        case AMOVB:
        case AMOVBU:
            if(p->from.type == D_OREG && p->from.offset == 0)
                xtramodes(r, &p->from);
            else if(p->to.type == D_OREG && p->to.offset == 0)
                xtramodes(r, &p->to);
            else
                continue;
            break;
        case ACMP:
            /*
             * elide CMP $0,x if calculation of x can set condition codes
             */
            if(p->from.type != D_CONST || p->from.offset != 0)
                continue;
            r2 = r->s1;
            if(r2 == R)
                continue;
            t = r2->prog->as;
            switch(t) {
            default:
                continue;
            case ABEQ:
            case ABNE:
            case ABMI:
            case ABPL:
                break;
            case ABGE:
                t = ABPL;
                break;
            case ABLT:
                t = ABMI;
                break;
            case ABHI:
                t = ABNE;
                break;
            case ABLS:
                t = ABEQ;
                break;
            }
            r1 = r;
            do
                r1 = uniqp(r1);
            while (r1 != R && r1->prog->as == ANOP);
            if(r1 == R)
                continue;
            p1 = r1->prog;
            if(p1->to.type != D_REG)
                continue;
            if(p1->to.reg != p->reg)
            if(!(p1->as == AMOVW && p1->from.type == D_REG && p1->from.reg == p->reg))
                continue;
            switch(p1->as) {
            default:
                continue;
            case AMOVW:
                if(p1->from.type != D_REG)
                    continue;
            case AAND:
            case AEOR:
            case AORR:
            case ABIC:
            case AMVN:
            case ASUB:
            case ARSB:
            case AADD:
            case AADC:
            case ASBC:
            case ARSC:
                break;
            }
            p1->scond |= C_SBIT;
            r2->prog->as = t;
            excise(r);
            continue;
        }
    }

    predicate();
}
@

<<function excise(arm)>>=
void
excise(Reg *r)
{
    Prog *p;

    p = r->prog;
    p->as = ANOP;
    p->scond = zprog.scond;
    p->from = zprog.from;
    p->to = zprog.to;
    p->reg = zprog.reg; /**/
}
@

<<function uniqp(arm)>>=
Reg*
uniqp(Reg *r)
{
    Reg *r1;

    r1 = r->p1;
    if(r1 == R) {
        r1 = r->p2;
        if(r1 == R || r1->p2link != R)
            return R;
    } else
        if(r->p2 != R)
            return R;
    return r1;
}
@

<<function uniqs(arm)>>=
Reg*
uniqs(Reg *r)
{
    Reg *r1;

    r1 = r->s1;
    if(r1 == R) {
        r1 = r->s2;
        if(r1 == R)
            return R;
    } else
        if(r->s2 != R)
            return R;
    return r1;
}
@

<<function regtyp(arm)>>=
int
regtyp(Adr *a)
{

    if(a->type == D_REG)
        return 1;
    if(a->type == D_FREG)
        return 1;
    return 0;
}
@

<<function subprop(arm)>>=
/*
 * the idea is to substitute
 * one register for another
 * from one MOV to another
 *	MOV	a, R0
 *	ADD	b, R0	/ no use of R1
 *	MOV	R0, R1
 * would be converted to
 *	MOV	a, R1
 *	ADD	b, R1
 *	MOV	R1, R0
 * hopefully, then the former or latter MOV
 * will be eliminated by copy propagation.
 */
int
subprop(Reg *r0)
{
    Prog *p;
    Adr *v1, *v2;
    Reg *r;
    int t;

    p = r0->prog;
    v1 = &p->from;
    if(!regtyp(v1))
        return 0;
    v2 = &p->to;
    if(!regtyp(v2))
        return 0;
    for(r=uniqp(r0); r!=R; r=uniqp(r)) {
        if(uniqs(r) == R)
            break;
        p = r->prog;
        switch(p->as) {
        case ABL:
            return 0;

        case ACMP:
        case ACMN:
        case AADD:
        case ASUB:
        case ARSB:
        case ASLL:
        case ASRL:
        case ASRA:
        case AORR:
        case AAND:
        case AEOR:
        case AMUL:
        case ADIV:
        case ADIVU:

        case ACMPF:
        case ACMPD:
        case AADDD:
        case AADDF:
        case ASUBD:
        case ASUBF:
        case AMULD:
        case AMULF:
        case ADIVD:
        case ADIVF:
            if(p->to.type == v1->type)
            if(p->to.reg == v1->reg) {
                if(p->reg == NREG)
                    p->reg = p->to.reg;
                goto gotit;
            }
            break;

        case AMOVF:
        case AMOVD:
        case AMOVW:
            if(p->to.type == v1->type)
            if(p->to.reg == v1->reg)
                goto gotit;
            break;

        case AMOVM:
            t = 1<<v2->reg;
            if((p->from.type == D_CONST && (p->from.offset&t)) ||
               (p->to.type == D_CONST && (p->to.offset&t)))
                return 0;
            break;
        }
        if(copyau(&p->from, v2) ||
           copyau1(p, v2) ||
           copyau(&p->to, v2))
            break;
        if(copysub(&p->from, v1, v2, 0) ||
           copysub1(p, v1, v2, 0) ||
           copysub(&p->to, v1, v2, 0))
            break;
    }
    return 0;

gotit:
    copysub(&p->to, v1, v2, 1);
    if(debug['P']) {
        print("gotit: %D->%D\n%P", v1, v2, r->prog);
        if(p->from.type == v2->type)
            print(" excise");
        print("\n");
    }
    for(r=uniqs(r); r!=r0; r=uniqs(r)) {
        p = r->prog;
        copysub(&p->from, v1, v2, 1);
        copysub1(p, v1, v2, 1);
        copysub(&p->to, v1, v2, 1);
        if(debug['P'])
            print("%P\n", r->prog);
    }
    t = v1->reg;
    v1->reg = v2->reg;
    v2->reg = t;
    if(debug['P'])
        print("%P last\n", r->prog);
    return 1;
}
@

<<function copyprop(arm)>>=
/*
 * The idea is to remove redundant copies.
 *	v1->v2	F=0
 *	(use v2	s/v2/v1/)*
 *	set v1	F=1
 *	use v2	return fail
 *	-----------------
 *	v1->v2	F=0
 *	(use v2	s/v2/v1/)*
 *	set v1	F=1
 *	set v2	return success
 */
int
copyprop(Reg *r0)
{
    Prog *p;
    Adr *v1, *v2;
    Reg *r;

    p = r0->prog;
    v1 = &p->from;
    v2 = &p->to;
    if(copyas(v1, v2))
        return 1;
    for(r=firstr; r!=R; r=r->link)
        r->active = 0;
    return copy1(v1, v2, r0->s1, 0);
}
@

<<function copy1(arm)>>=
int
copy1(Adr *v1, Adr *v2, Reg *r, int f)
{
    int t;
    Prog *p;

    if(r->active) {
        if(debug['P'])
            print("act set; return 1\n");
        return 1;
    }
    r->active = 1;
    if(debug['P'])
        print("copy %D->%D f=%d\n", v1, v2, f);
    for(; r != R; r = r->s1) {
        p = r->prog;
        if(debug['P'])
            print("%P", p);
        if(!f && uniqp(r) == R) {
            f = 1;
            if(debug['P'])
                print("; merge; f=%d", f);
        }
        t = copyu(p, v2, A);
        switch(t) {
        case 2:	/* rar, cant split */
            if(debug['P'])
                print("; %Drar; return 0\n", v2);
            return 0;

        case 3:	/* set */
            if(debug['P'])
                print("; %Dset; return 1\n", v2);
            return 1;

        case 1:	/* used, substitute */
        case 4:	/* use and set */
            if(f) {
                if(!debug['P'])
                    return 0;
                if(t == 4)
                    print("; %Dused+set and f=%d; return 0\n", v2, f);
                else
                    print("; %Dused and f=%d; return 0\n", v2, f);
                return 0;
            }
            if(copyu(p, v2, v1)) {
                if(debug['P'])
                    print("; sub fail; return 0\n");
                return 0;
            }
            if(debug['P'])
                print("; sub%D/%D", v2, v1);
            if(t == 4) {
                if(debug['P'])
                    print("; %Dused+set; return 1\n", v2);
                return 1;
            }
            break;
        }
        if(!f) {
            t = copyu(p, v1, A);
            if(!f && (t == 2 || t == 3 || t == 4)) {
                f = 1;
                if(debug['P'])
                    print("; %Dset and !f; f=%d", v1, f);
            }
        }
        if(debug['P'])
            print("\n");
        if(r->s2)
            if(!copy1(v1, v2, r->s2, f))
                return 0;
    }
    return 1;
}
@

<<function constprop(arm)>>=
/*
 * The idea is to remove redundant constants.
 *	$c1->v1
 *	($c1->v2 s/$c1/v1)*
 *	set v1  return
 * The v1->v2 should be eliminated by copy propagation.
 */
void
constprop(Adr *c1, Adr *v1, Reg *r)
{
    Prog *p;

    if(debug['C'])
        print("constprop %D->%D\n", c1, v1);
    for(; r != R; r = r->s1) {
        p = r->prog;
        if(debug['C'])
            print("%P", p);
        if(uniqp(r) == R) {
            if(debug['C'])
                print("; merge; return\n");
            return;
        }
        if(p->as == AMOVW && copyas(&p->from, c1)) {
                if(debug['C'])
                    print("; sub%D/%D", &p->from, v1);
                p->from = *v1;
        } else if(copyu(p, v1, A) > 1) {
            if(debug['C'])
                print("; %Dset; return\n", v1);
            return;
        }
        if(debug['C'])
            print("\n");
        if(r->s2)
            constprop(c1, v1, r->s2);
    }
}
@

<<function FAIL(arm)>>=
/*
 * ASLL x,y,w
 * .. (not use w, not set x y w)
 * AXXX w,a,b (a != w)
 * .. (not use w)
 * (set w)
 * ----------- changed to
 * ..
 * AXXX (x<<y),a,b
 * ..
 */
#define FAIL(msg) { if(debug['H']) print("\t%s; FAILURE\n", msg); return 0; }
@

<<function shiftprop(arm)>>=
int
shiftprop(Reg *r)
{
    Reg *r1;
    Prog *p, *p1, *p2;
    int n, o;
    Adr a;

    p = r->prog;
    if(p->to.type != D_REG)
        FAIL("BOTCH: result not reg");
    n = p->to.reg;
    a = zprog.from;
    if(p->reg != NREG && p->reg != p->to.reg) {
        a.type = D_REG;
        a.reg = p->reg;
    }
    if(debug['H'])
        print("shiftprop\n%P", p);
    r1 = r;
    for(;;) {
        /* find first use of shift result; abort if shift operands or result are changed */
        r1 = uniqs(r1);
        if(r1 == R)
            FAIL("branch");
        if(uniqp(r1) == R)
            FAIL("merge");
        p1 = r1->prog;
        if(debug['H'])
            print("\n%P", p1);
        switch(copyu(p1, &p->to, A)) {
        case 0:	/* not used or set */
            if((p->from.type == D_REG && copyu(p1, &p->from, A) > 1) ||
               (a.type == D_REG && copyu(p1, &a, A) > 1))
                FAIL("args modified");
            continue;
        case 3:	/* set, not used */
            FAIL("BOTCH: noref");
        }
        break;
    }
    /* check whether substitution can be done */
    switch(p1->as) {
    default:
        FAIL("non-dpi");
    case AAND:
    case AEOR:
    case AADD:
    case AADC:
    case AORR:
    case ASUB:
    case ARSB:
    case ASBC:
    case ARSC:
        if(p1->reg == n || (p1->reg == NREG && p1->to.type == D_REG && p1->to.reg == n)) {
            if(p1->from.type != D_REG)
                FAIL("can't swap");
            p1->reg = p1->from.reg;
            p1->from.reg = n;
            switch(p1->as) {
            case ASUB:
                p1->as = ARSB;
                break;
            case ARSB:
                p1->as = ASUB;
                break;
            case ASBC:
                p1->as = ARSC;
                break;
            case ARSC:
                p1->as = ASBC;
                break;
            }
            if(debug['H'])
                print("\t=>%P", p1);
        }
    case ABIC:
    case ACMP:
    case ACMN:
        if(p1->reg == n)
            FAIL("can't swap");
        if(p1->reg == NREG && p1->to.reg == n)
            FAIL("shift result used twice");
    case AMVN:
        if(p1->from.type == D_SHIFT)
            FAIL("shift result used in shift");
        if(p1->from.type != D_REG || p1->from.reg != n)
            FAIL("BOTCH: where is it used?");
        break;
    }
    /* check whether shift result is used subsequently */
    p2 = p1;
    if(p1->to.reg != n)
    for (;;) {
        r1 = uniqs(r1);
        if(r1 == R)
            FAIL("inconclusive");
        p1 = r1->prog;
        if(debug['H'])
            print("\n%P", p1);
        switch(copyu(p1, &p->to, A)) {
        case 0:	/* not used or set */
            continue;
        case 3: /* set, not used */
            break;
        default:/* used */
            FAIL("reused");
        }
        break;
    }
    /* make the substitution */
    p2->from.type = D_SHIFT;
    p2->from.reg = NREG;
    o = p->reg;
    if(o == NREG)
        o = p->to.reg;
    switch(p->from.type){
    case D_CONST:
        o |= (p->from.offset&0x1f)<<7;
        break;
    case D_REG:
        o |= (1<<4) | (p->from.reg<<8);
        break;
    }
    switch(p->as){
    case ASLL:
        o |= 0<<5;
        break;
    case ASRL:
        o |= 1<<5;
        break;
    case ASRA:
        o |= 2<<5;
        break;
    }
    p2->from.offset = o;
    if(debug['H'])
        print("\t=>%P\tSUCCEED\n", p2);
    return 1;
}
@

<<function findpre(arm)>>=
Reg*
findpre(Reg *r, Adr *v)
{
    Reg *r1;

    for(r1=uniqp(r); r1!=R; r=r1,r1=uniqp(r)) {
        if(uniqs(r1) != r)
            return R;
        switch(copyu(r1->prog, v, A)) {
        case 1: /* used */
        case 2: /* read-alter-rewrite */
            return R;
        case 3: /* set */
        case 4: /* set and used */
            return r1;
        }
    }
    return R;
}
@

<<function findinc(arm)>>=
Reg*
findinc(Reg *r, Reg *r2, Adr *v)
{
    Reg *r1;
    Prog *p;


    for(r1=uniqs(r); r1!=R && r1!=r2; r=r1,r1=uniqs(r)) {
        if(uniqp(r1) != r)
            return R;
        switch(copyu(r1->prog, v, A)) {
        case 0: /* not touched */
            continue;
        case 4: /* set and used */
            p = r1->prog;
            if(p->as == AADD)
            if(p->from.type == D_CONST)
            if(p->from.offset > -4096 && p->from.offset < 4096)
                return r1;
        default:
            return R;
        }
    }
    return R;
}
@

<<function nochange(arm)>>=
int
nochange(Reg *r, Reg *r2, Prog *p)
{
    Adr a[3];
    int i, n;

    if(r == r2)
        return 1;
    n = 0;
    if(p->reg != NREG && p->reg != p->to.reg) {
        a[n].type = D_REG;
        a[n++].reg = p->reg;
    }
    switch(p->from.type) {
    case D_SHIFT:
        a[n].type = D_REG;
        a[n++].reg = p->from.offset&0xf;
    case D_REG:
        a[n].type = D_REG;
        a[n++].reg = p->from.reg;
    }
    if(n == 0)
        return 1;
    for(; r!=R && r!=r2; r=uniqs(r)) {
        p = r->prog;
        for(i=0; i<n; i++)
            if(copyu(p, &a[i], A) > 1)
                return 0;
    }
    return 1;
}
@

<<function findu1(arm)>>=
int
findu1(Reg *r, Adr *v)
{
    for(; r != R; r = r->s1) {
        if(r->active)
            return 0;
        r->active = 1;
        switch(copyu(r->prog, v, A)) {
        case 1: /* used */
        case 2: /* read-alter-rewrite */
        case 4: /* set and used */
            return 1;
        case 3: /* set */
            return 0;
        }
        if(r->s2)
            if (findu1(r->s2, v))
                return 1;
    }
    return 0;
}
@

<<function finduse(arm)>>=
int
finduse(Reg *r, Adr *v)
{
    Reg *r1;

    for(r1=firstr; r1!=R; r1=r1->link)
        r1->active = 0;
    return findu1(r, v);
}
@

<<function xtramodes(arm)>>=
int
xtramodes(Reg *r, Adr *a)
{
    Reg *r1, *r2, *r3;
    Prog *p, *p1;
    Adr v;

    p = r->prog;
    if(debug['h'] && p->as == AMOVB && p->from.type == D_OREG)	/* byte load */
        return 0;
    v = *a;
    v.type = D_REG;
    r1 = findpre(r, &v);
    if(r1 != R) {
        p1 = r1->prog;
        if(p1->to.type == D_REG && p1->to.reg == v.reg)
        switch(p1->as) {
        case AADD:
            if(p1->from.type == D_REG ||
               (p1->from.type == D_SHIFT && (p1->from.offset&(1<<4)) == 0 &&
                (p->as != AMOVB || (a == &p->from && (p1->from.offset&~0xf) == 0))) ||
               (p1->from.type == D_CONST && 
                p1->from.offset > -4096 && p1->from.offset < 4096))
            if(nochange(uniqs(r1), r, p1)) {
                if(a != &p->from || v.reg != p->to.reg)
                if (finduse(r->s1, &v)) {
                    if(p1->reg == NREG || p1->reg == v.reg)
                        /* pre-indexing */
                        p->scond |= C_WBIT;
                    else return 0;	
                }
                switch (p1->from.type) {
                case D_REG:
                    /* register offset */
                    a->type = D_SHIFT;
                    a->offset = p1->from.reg;
                    break;
                case D_SHIFT:
                    /* scaled register offset */
                    a->type = D_SHIFT;
                case D_CONST:
                    /* immediate offset */
                    a->offset = p1->from.offset;
                    break;
                }
                if(p1->reg != NREG)
                    a->reg = p1->reg;
                excise(r1);
                return 1;
            }
            break;
        case AMOVW:
            if(p1->from.type == D_REG)
            if((r2 = findinc(r1, r, &p1->from)) != R) {
            for(r3=uniqs(r2); r3->prog->as==ANOP; r3=uniqs(r3))
                ;
            if(r3 == r) {
                /* post-indexing */
                p1 = r2->prog;
                a->reg = p1->to.reg;
                a->offset = p1->from.offset;
                p->scond |= C_PBIT;
                if(!finduse(r, &r1->prog->to))
                    excise(r1);
                excise(r2);
                return 1;
            }
            }
            break;
        }
    }
    if(a != &p->from || a->reg != p->to.reg)
    if((r1 = findinc(r, R, &v)) != R) {
        /* post-indexing */
        p1 = r1->prog;
        a->offset = p1->from.offset;
        p->scond |= C_PBIT;
        excise(r1);
        return 1;
    }
    return 0;
}
@

<<function copyu(arm)>>=
/*
 * return
 * 1 if v only used (and substitute),
 * 2 if read-alter-rewrite
 * 3 if set
 * 4 if set and used
 * 0 otherwise (not touched)
 */
int
copyu(Prog *p, Adr *v, Adr *s)
{

    switch(p->as) {

    default:
        if(debug['P'])
            print(" (???)");
        return 2;

    case AMOVM:
        if(v->type != D_REG)
            return 0;
        if(p->from.type == D_CONST) {	/* read reglist, read/rar */
            if(s != A) {
                if(p->from.offset&(1<<v->reg))
                    return 1;
                if(copysub(&p->to, v, s, 1))
                    return 1;
                return 0;
            }
            if(copyau(&p->to, v)) {
                if(p->scond&C_WBIT)
                    return 2;
                return 1;
            }
            if(p->from.offset&(1<<v->reg))
                return 1;
        } else {			/* read/rar, write reglist */
            if(s != A) {
                if(p->to.offset&(1<<v->reg))
                    return 1;
                if(copysub(&p->from, v, s, 1))
                    return 1;
                return 0;
            }
            if(copyau(&p->from, v)) {
                if(p->scond&C_WBIT)
                    return 2;
                if(p->to.offset&(1<<v->reg))
                    return 4;
                return 1;
            }
            if(p->to.offset&(1<<v->reg))
                return 3;
        }
        return 0;
        
    case ANOP:	/* read, write */
    case AMOVW:
    case AMOVF:
    case AMOVD:
    case AMOVH:
    case AMOVHU:
    case AMOVB:
    case AMOVBU:
    case AMOVDW:
    case AMOVWD:
    case AMOVFD:
    case AMOVDF:
        if(p->scond&(C_WBIT|C_PBIT))
        if(v->type == D_REG) {
            if(p->from.type == D_OREG || p->from.type == D_SHIFT) {
                if(p->from.reg == v->reg)
                    return 2;
            } else {
            if(p->to.reg == v->reg)
                return 2;
            }
        }
        if(s != A) {
            if(copysub(&p->from, v, s, 1))
                return 1;
            if(!copyas(&p->to, v))
                if(copysub(&p->to, v, s, 1))
                    return 1;
            return 0;
        }
        if(copyas(&p->to, v)) {
            if(copyau(&p->from, v))
                return 4;
            return 3;
        }
        if(copyau(&p->from, v))
            return 1;
        if(copyau(&p->to, v))
            return 1;
        return 0;


    case AADD:	/* read, read, write */
    case ASUB:
    case ARSB:
    case ASLL:
    case ASRL:
    case ASRA:
    case AORR:
    case AAND:
    case AEOR:
    case AMUL:
    case ADIV:
    case ADIVU:
    case AADDF:
    case AADDD:
    case ASUBF:
    case ASUBD:
    case AMULF:
    case AMULD:
    case ADIVF:
    case ADIVD:

    case ACMPF:
    case ACMPD:
    case ACMP:
    case ACMN:
    case ACASE:
        if(s != A) {
            if(copysub(&p->from, v, s, 1))
                return 1;
            if(copysub1(p, v, s, 1))
                return 1;
            if(!copyas(&p->to, v))
                if(copysub(&p->to, v, s, 1))
                    return 1;
            return 0;
        }
        if(copyas(&p->to, v)) {
            if(p->reg == NREG)
                p->reg = p->to.reg;
            if(copyau(&p->from, v))
                return 4;
            if(copyau1(p, v))
                return 4;
            return 3;
        }
        if(copyau(&p->from, v))
            return 1;
        if(copyau1(p, v))
            return 1;
        if(copyau(&p->to, v))
            return 1;
        return 0;

    case ABEQ:	/* read, read */
    case ABNE:
    case ABHS:
    case ABLO:
    case ABMI:
    case ABPL:
    case ABVS:
    case ABVC:
    case ABHI:
    case ABLS:
    case ABGE:
    case ABLT:
    case ABGT:
    case ABLE:
        if(s != A) {
            if(copysub(&p->from, v, s, 1))
                return 1;
            return copysub1(p, v, s, 1);
        }
        if(copyau(&p->from, v))
            return 1;
        if(copyau1(p, v))
            return 1;
        return 0;

    case AB:	/* funny */
        if(s != A) {
            if(copysub(&p->to, v, s, 1))
                return 1;
            return 0;
        }
        if(copyau(&p->to, v))
            return 1;
        return 0;

    case ARET:	/* funny */
        if(v->type == D_REG)
        if(v->reg == REGRET)
            return 2;
        if(v->type == D_FREG)
        if(v->reg == FREGRET)
            return 2;

    case ABL:	/* funny */
        if(v->type == D_REG) {
            if(v->reg <= REGEXT && v->reg > exregoffset)
                return 2;
            if(v->reg == (uchar)REGARG)
                return 2;
        }
        if(v->type == D_FREG)
            if(v->reg <= FREGEXT && v->reg > exfregoffset)
                return 2;

        if(s != A) {
            if(copysub(&p->to, v, s, 1))
                return 1;
            return 0;
        }
        if(copyau(&p->to, v))
            return 4;
        return 3;

    case ATEXT:	/* funny */
        if(v->type == D_REG)
            if(v->reg == (uchar)REGARG)
                return 3;
        return 0;
    }
}
@

<<function a2type(arm)>>=
int
a2type(Prog *p)
{

    switch(p->as) {

    case ACMP:
    case ACMN:

    case AADD:
    case ASUB:
    case ARSB:
    case ASLL:
    case ASRL:
    case ASRA:
    case AORR:
    case AAND:
    case AEOR:
    case AMUL:
    case ADIV:
    case ADIVU:
        return D_REG;

    case ACMPF:
    case ACMPD:

    case AADDF:
    case AADDD:
    case ASUBF:
    case ASUBD:
    case AMULF:
    case AMULD:
    case ADIVF:
    case ADIVD:
        return D_FREG;
    }
    return D_NONE;
}
@

<<function copyas(arm)>>=
/*
 * direct reference,
 * could be set/use depending on
 * semantics
 */
int
copyas(Adr *a, Adr *v)
{

    if(regtyp(v)) {
        if(a->type == v->type)
        if(a->reg == v->reg)
            return 1;
    } else if(v->type == D_CONST) {		/* for constprop */
        if(a->type == v->type)
        if(a->name == v->name)
        if(a->sym == v->sym)
        if(a->reg == v->reg)
        if(a->offset == v->offset)
            return 1;
    }
    return 0;
}
@

<<function copyau(arm)>>=
/*
 * either direct or indirect
 */
int
copyau(Adr *a, Adr *v)
{

    if(copyas(a, v))
        return 1;
    if(v->type == D_REG) {
        if(a->type == D_OREG) {
            if(v->reg == a->reg)
                return 1;
        } else if(a->type == D_SHIFT) {
            if((a->offset&0xf) == v->reg)
                return 1;
            if((a->offset&(1<<4)) && (a->offset>>8) == v->reg)
                return 1;
        }
    }
    return 0;
}
@

<<function copyau1(arm)>>=
int
copyau1(Prog *p, Adr *v)
{

    if(regtyp(v)) {
        if(a2type(p) == v->type)
        if(p->reg == v->reg) {
            if(a2type(p) != v->type)
                print("botch a2type %P\n", p);
            return 1;
        }
    }
    return 0;
}
@

<<function copysub(arm)>>=
/*
 * substitute s for v in a
 * return failure to substitute
 */
int
copysub(Adr *a, Adr *v, Adr *s, int f)
{

    if(f)
    if(copyau(a, v)) {
        if(a->type == D_SHIFT) {
            if((a->offset&0xf) == v->reg)
                a->offset = (a->offset&~0xf)|s->reg;
            if((a->offset&(1<<4)) && (a->offset>>8) == v->reg)
                a->offset = (a->offset&~(0xf<<8))|(s->reg<<8);
        } else
            a->reg = s->reg;
    }
    return 0;
}
@

<<function copysub1(arm)>>=
int
copysub1(Prog *p1, Adr *v, Adr *s, int f)
{

    if(f)
    if(copyau1(p1, v))
        p1->reg = s->reg;
    return 0;
}
@

<<global predinfo(arm)>>=
struct {
    int opcode;
    int notopcode;
    int scond; 
    int notscond; 
} predinfo[]  = { 
    { ABEQ,	ABNE,	0x0,	0x1, }, 
    { ABNE,	ABEQ,	0x1,	0x0, }, 
    { ABHS,	ABLO,	0x2,	0x3, }, 
    { ABLO,	ABHS,	0x3,	0x2, }, 
    { ABMI,	ABPL,	0x4,	0x5, }, 
    { ABPL,	ABMI,	0x5,	0x4, }, 
    { ABVS,	ABVC,	0x6,	0x7, }, 
    { ABVC,	ABVS,	0x7,	0x6, }, 
    { ABHI,	ABLS,	0x8,	0x9, }, 
    { ABLS,	ABHI,	0x9,	0x8, }, 
    { ABGE,	ABLT,	0xA,	0xB, }, 
    { ABLT,	ABGE,	0xB,	0xA, }, 
    { ABGT,	ABLE,	0xC,	0xD, }, 
    { ABLE,	ABGT,	0xD,	0xC, }, 
}; 
@

<<enum _anon_(arm)>>=
enum {
    Join,
    Split,
    End,
    Branch,
    Setcond,
    Toolong
};
@

<<enum _anon_ (5c/peep.c)(arm)>>=
enum {
    Falsecond,
    Truecond,
    Delbranch,
    Keepbranch
};
@

<<function isbranch(arm)>>=
int 
isbranch(Prog *p)
{
    return (ABEQ <= p->as) && (p->as <= ABLE); 
}
@

<<function predicable(arm)>>=
int
predicable(Prog *p)
{
    if (isbranch(p)
        || p->as == ANOP
        || p->as == AXXX
        || p->as == ADATA
        || p->as == AGLOBL
        || p->as == AGOK
        || p->as == AHISTORY
        || p->as == ANAME
        || p->as == ASIGNAME
        || p->as == ATEXT
        || p->as == AWORD
        || p->as == ADYNT
        || p->as == AINIT
        || p->as == ABCASE
        || p->as == ACASE)
        return 0; 
    return 1; 
}
@

<<function modifiescpsr(arm)>>=
/* 
 * Depends on an analysis of the encodings performed by 5l. 
 * These seem to be all of the opcodes that lead to the "S" bit
 * being set in the instruction encodings. 
 * 
 * C_SBIT may also have been set explicitly in p->scond.
 */ 
int
modifiescpsr(Prog *p)
{
    return (p->scond&C_SBIT)
        || p->as == ATST 
        || p->as == ATEQ 
        || p->as == ACMN
        || p->as == ACMP
        || p->as == AMULU
        || p->as == ADIVU
        || p->as == AMUL
        || p->as == ADIV
        || p->as == AMOD
        || p->as == AMODU
        || p->as == ABL;
} 
@

<<function joinsplit(arm)>>=
/*
 * Find the maximal chain of instructions starting with r which could
 * be executed conditionally
 */
int
joinsplit(Reg *r, Joininfo *j)
{
    j->start = r;
    j->last = r;
    j->len = 0;
    do {
        if (r->p2 && (r->p1 || r->p2->p2link)) {
            j->end = r;
            return Join;
        }
        if (r->s1 && r->s2) {
            j->end = r;
            return Split;
        }
        j->last = r;
        if (r->prog->as != ANOP)
            j->len++;
        if (!r->s1 && !r->s2) {
            j->end = r->link;
            return End;
        }
        if (r->s2) {
            j->end = r->s2;
            return Branch;
        }
        if (modifiescpsr(r->prog)) {
            j->end = r->s1;
            return Setcond;
        }
        r = r->s1;
    } while (j->len < 4);
    j->end = r;
    return Toolong;
}
@

<<function successor(arm)>>=
Reg *
successor(Reg *r)
{
    if (r->s1)
        return r->s1; 
    else
        return r->s2; 
}
@

<<function applypred(arm)>>=
void
applypred(Reg *rstart, Joininfo *j, int cond, int branch)
{
    int pred; 
    Reg *r; 

    if(j->len == 0)
        return;
    if (cond == Truecond)
        pred = predinfo[rstart->prog->as - ABEQ].scond;
    else
        pred = predinfo[rstart->prog->as - ABEQ].notscond; 
    
    for (r = j->start; ; r = successor(r)) {
        if (r->prog->as == AB) {
            if (r != j->last || branch == Delbranch)
                excise(r);
            else {
              if (cond == Truecond)
                r->prog->as = predinfo[rstart->prog->as - ABEQ].opcode;
              else
                r->prog->as = predinfo[rstart->prog->as - ABEQ].notopcode;
            }
        }
        else if (predicable(r->prog)) 
            r->prog->scond = (r->prog->scond&~C_SCOND)|pred;
        if (r->s1 != r->link) {
            r->s1 = r->link;
            r->link->p1 = r;
        }
        if (r == j->last)
            break;
    }
}
@

<<function predicate(arm)>>=
void
predicate(void)
{	
    Reg *r;
    int t1, t2;
    Joininfo j1, j2;

    for(r=firstr; r!=R; r=r->link) {
        if (isbranch(r->prog)) {
            t1 = joinsplit(r->s1, &j1);
            t2 = joinsplit(r->s2, &j2);
            if(j1.last->link != j2.start)
                continue;
            if(j1.end == j2.end)
            if((t1 == Branch && (t2 == Join || t2 == Setcond)) ||
               (t2 == Join && (t1 == Join || t1 == Setcond))) {
                applypred(r, &j1, Falsecond, Delbranch);
                applypred(r, &j2, Truecond, Delbranch);
                excise(r);
                continue;
            }
            if(t1 == End || t1 == Branch) {
                applypred(r, &j1, Falsecond, Keepbranch);
                excise(r);
                continue;
            }
        } 
    } 
}
@


%-------------------------------------------------------------

<<5c/peep.c>>=
#include "gc.h"

int xtramodes(Reg*, Adr*);

<<function peep(arm)>>

<<function excise(arm)>>

<<function uniqp(arm)>>

<<function uniqs(arm)>>

<<function regtyp(arm)>>

<<function subprop(arm)>>

<<function copyprop(arm)>>

<<function copy1(arm)>>

<<function constprop(arm)>>

<<function FAIL(arm)>>
<<function shiftprop(arm)>>

<<function findpre(arm)>>

<<function findinc(arm)>>

<<function nochange(arm)>>

<<function findu1(arm)>>

<<function finduse(arm)>>

<<function xtramodes(arm)>>

<<function copyu(arm)>>

<<function a2type(arm)>>

<<function copyas(arm)>>

<<function copyau(arm)>>

<<function copyau1(arm)>>

<<function copysub(arm)>>

<<function copysub1(arm)>>

<<global predinfo(arm)>>

typedef struct {
    Reg *start;
    Reg *last;
    Reg *end;
    int len;
} Joininfo;

<<enum _anon_(arm)>>
    
<<enum _anon_ (5c/peep.c)(arm)>>

<<function isbranch(arm)>>

<<function predicable(arm)>>

<<function modifiescpsr(arm)>>

<<function joinsplit(arm)>>

<<function successor(arm)>>

<<function applypred(arm)>>

<<function predicate(arm)>>
@


\subsection*{[[5c/sgen.c]]}

<<function noretval(arm)>>=
void
noretval(int n)
{

    if(n & 1) {
        gins(ANOP, Z, Z);
        p->to.type = D_REG;
        p->to.reg = REGRET;
    }
    if(n & 2) {
        gins(ANOP, Z, Z);
        p->to.type = D_FREG;
        p->to.reg = FREGRET;
    }
}
@

<<function xcom(arm)>>=
/*
 *	calculate addressability as follows
 *		CONST ==> 20		$value
 *		NAME ==> 10		name
 *		REGISTER ==> 11		register
 *		INDREG ==> 12		*[(reg)+offset]
 *		&10 ==> 2		$name
 *		ADD(2, 20) ==> 2	$name+offset
 *		ADD(3, 20) ==> 3	$(reg)+offset
 *		&12 ==> 3		$(reg)+offset
 *		*11 ==> 11		??
 *		*2 ==> 10		name
 *		*3 ==> 12		*(reg)+offset
 *	calculate complexity (number of registers)
 */
void
xcom(Node *n)
{
    Node *l, *r;
    int t;

    if(n == Z)
        return;
    l = n->left;
    r = n->right;
    n->addable = 0;
    n->complex = 0;
    switch(n->op) {
    case OCONST:
        n->addable = 20;
        return;

    case OREGISTER:
        n->addable = 11;
        return;

    case OINDREG:
        n->addable = 12;
        return;

    case ONAME:
        n->addable = 10;
        return;

    case OADDR:
        xcom(l);
        if(l->addable == 10)
            n->addable = 2;
        if(l->addable == 12)
            n->addable = 3;
        break;

    case OIND:
        xcom(l);
        if(l->addable == 11)
            n->addable = 12;
        if(l->addable == 3)
            n->addable = 12;
        if(l->addable == 2)
            n->addable = 10;
        break;

    case OADD:
        xcom(l);
        xcom(r);
        if(l->addable == 20) {
            if(r->addable == 2)
                n->addable = 2;
            if(r->addable == 3)
                n->addable = 3;
        }
        if(r->addable == 20) {
            if(l->addable == 2)
                n->addable = 2;
            if(l->addable == 3)
                n->addable = 3;
        }
        break;

    case OASLMUL:
    case OASMUL:
        xcom(l);
        xcom(r);
        t = vlog(r);
        if(t >= 0) {
            n->op = OASASHL;
            r->vconst = t;
            r->type = types[TINT];
        }
        break;

    case OMUL:
    case OLMUL:
        xcom(l);
        xcom(r);
        t = vlog(r);
        if(t >= 0) {
            n->op = OASHL;
            r->vconst = t;
            r->type = types[TINT];
        }
        t = vlog(l);
        if(t >= 0) {
            n->op = OASHL;
            n->left = r;
            n->right = l;
            r = l;
            l = n->left;
            r->vconst = t;
            r->type = types[TINT];
        }
        break;

    case OASLDIV:
        xcom(l);
        xcom(r);
        t = vlog(r);
        if(t >= 0) {
            n->op = OASLSHR;
            r->vconst = t;
            r->type = types[TINT];
        }
        break;

    case OLDIV:
        xcom(l);
        xcom(r);
        t = vlog(r);
        if(t >= 0) {
            n->op = OLSHR;
            r->vconst = t;
            r->type = types[TINT];
        }
        break;

    case OASLMOD:
        xcom(l);
        xcom(r);
        t = vlog(r);
        if(t >= 0) {
            n->op = OASAND;
            r->vconst--;
        }
        break;

    case OLMOD:
        xcom(l);
        xcom(r);
        t = vlog(r);
        if(t >= 0) {
            n->op = OAND;
            r->vconst--;
        }
        break;

    default:
        if(l != Z)
            xcom(l);
        if(r != Z)
            xcom(r);
        break;
    }
    if(n->addable >= 10)
        return;

    if(l != Z)
        n->complex = l->complex;
    if(r != Z) {
        if(r->complex == n->complex)
            n->complex = r->complex+1;
        else
        if(r->complex > n->complex)
            n->complex = r->complex;
    }
    if(n->complex == 0)
        n->complex++;

    if(com64(n))
        return;

    switch(n->op) {
    case OFUNC:
        n->complex = FNX;
        break;

    case OADD:
    case OXOR:
    case OAND:
    case OOR:
    case OEQ:
    case ONE:
        /*
         * immediate operators, make const on right
         */
        if(l->op == OCONST) {
            n->left = r;
            n->right = l;
        }
        break;
    }
}
@


%-------------------------------------------------------------

<<5c/sgen.c>>=
#include "gc.h"

<<function noretval(arm)>>

<<function xcom(arm)>>
@


\subsection*{[[5c/swt.c]]}

<<function swit1(arm)>>=
void
swit1(C1 *q, int nc, long def, Node *n)
{
    Node tn;
    
    regalloc(&tn, &regnode, Z);
    swit2(q, nc, def, n, &tn);
    regfree(&tn);
}
@

<<function swit2(arm)>>=
void
swit2(C1 *q, int nc, long def, Node *n, Node *tn)
{
    C1 *r;
    int i;
    long v;
    Prog *sp;

    if(nc >= 3) {
        i = (q+nc-1)->val - (q+0)->val;
        if(i > 0 && i < nc*2)
            goto direct;
    }
    if(nc < 5) {
        for(i=0; i<nc; i++) {
            if(debug['K'])
                print("case = %.8llux\n", q->val);
            gopcode(OEQ, nodconst(q->val), n, Z);
            patch(p, q->label);
            q++;
        }
        gbranch(OGOTO);
        patch(p, def);
        return;
    }

    i = nc / 2;
    r = q+i;
    if(debug['K'])
        print("case > %.8llux\n", r->val);
    gopcode(OGT, nodconst(r->val), n, Z);
    sp = p;
    gopcode(OEQ, nodconst(r->val), n, Z);	/* just gen the B.EQ */
    patch(p, r->label);
    swit2(q, i, def, n, tn);

    if(debug['K'])
        print("case < %.8llux\n", r->val);
    patch(sp, pc);
    swit2(r+1, nc-i-1, def, n, tn);
    return;

direct:
    v = q->val;
    if(v != 0)
        gopcode(OSUB, nodconst(v), Z, n);
    gopcode(OCASE, nodconst((q+nc-1)->val - v), n, Z);
    patch(p, def);
    for(i=0; i<nc; i++) {
        if(debug['K'])
            print("case = %.8llux\n", q->val);
        while(q->val != v) {
            nextpc();
            p->as = ABCASE;
            patch(p, def);
            v++;
        }
        nextpc();
        p->as = ABCASE;
        patch(p, q->label);
        q++;
        v++;
    }
    gbranch(OGOTO);		/* so that regopt() won't be confused */
    patch(p, def);
}
@

<<function bitload(arm)>>=
void
bitload(Node *b, Node *n1, Node *n2, Node *n3, Node *nn)
{
    int sh;
    long v;
    Node *l;

    /*
     * n1 gets adjusted/masked value
     * n2 gets address of cell
     * n3 gets contents of cell
     */
    l = b->left;
    if(n2 != Z) {
        regalloc(n1, l, nn);
        reglcgen(n2, l, Z);
        regalloc(n3, l, Z);
        gopcode(OAS, n2, Z, n3);
        gopcode(OAS, n3, Z, n1);
    } else {
        regalloc(n1, l, nn);
        cgen(l, n1);
    }
    if(b->type->shift == 0 && typeu[b->type->etype]) {
        v = ~0 + (1L << b->type->nbits);
        gopcode(OAND, nodconst(v), Z, n1);
    } else {
        sh = 32 - b->type->shift - b->type->nbits;
        if(sh > 0)
            gopcode(OASHL, nodconst(sh), Z, n1);
        sh += b->type->shift;
        if(sh > 0)
            if(typeu[b->type->etype])
                gopcode(OLSHR, nodconst(sh), Z, n1);
            else
                gopcode(OASHR, nodconst(sh), Z, n1);
    }
}
@

<<function bitstore(arm)>>=
void
bitstore(Node *b, Node *n1, Node *n2, Node *n3, Node *nn)
{
    long v;
    Node nod, *l;
    int sh;

    /*
     * n1 has adjusted/masked value
     * n2 has address of cell
     * n3 has contents of cell
     */
    l = b->left;
    regalloc(&nod, l, Z);
    v = ~0 + (1L << b->type->nbits);
    gopcode(OAND, nodconst(v), Z, n1);
    gopcode(OAS, n1, Z, &nod);
    if(nn != Z)
        gopcode(OAS, n1, Z, nn);
    sh = b->type->shift;
    if(sh > 0)
        gopcode(OASHL, nodconst(sh), Z, &nod);
    v <<= sh;
    gopcode(OAND, nodconst(~v), Z, n3);
    gopcode(OOR, n3, Z, &nod);
    gopcode(OAS, &nod, Z, n2);

    regfree(&nod);
    regfree(n1);
    regfree(n2);
    regfree(n3);
}
@

<<function outstring(arm)>>=
long
outstring(char *s, long n)
{
    long r;

    if(suppress)
        return nstring;
    r = nstring;
    while(n) {
        string[mnstring] = *s++;
        mnstring++;
        nstring++;
        if(mnstring >= NSNAME) {
            gpseudo(ADATA, symstring, nodconst(0L));
            p->from.offset += nstring - NSNAME;
            p->reg = NSNAME;
            p->to.type = D_SCONST;
            memmove(p->to.sval, string, NSNAME);
            mnstring = 0;
        }
        n--;
    }
    return r;
}
@

<<function mulcon(arm)>>=
int
mulcon(Node *n, Node *nn)
{
    Node *l, *r, nod1, nod2;
    Multab *m;
    long v, vs;
    int o;
    char code[sizeof(m->code)+2], *p;

    if(typefd[n->type->etype])
        return 0;
    l = n->left;
    r = n->right;
    if(l->op == OCONST) {
        l = r;
        r = n->left;
    }
    if(r->op != OCONST)
        return 0;
    v = convvtox(r->vconst, n->type->etype);
    if(v != r->vconst) {
        if(debug['M'])
            print("%L multiply conv: %lld\n", n->lineno, r->vconst);
        return 0;
    }
    m = mulcon0(v);
    if(!m) {
        if(debug['M'])
            print("%L multiply table: %lld\n", n->lineno, r->vconst);
        return 0;
    }
    if(debug['M'] && debug['v'])
        print("%L multiply: %ld\n", n->lineno, v);

    memmove(code, m->code, sizeof(m->code));
    code[sizeof(m->code)] = 0;

    p = code;
    if(p[1] == 'i')
        p += 2;
    regalloc(&nod1, n, nn);
    cgen(l, &nod1);
    vs = v;
    regalloc(&nod2, n, Z);

loop:
    switch(*p) {
    case 0:
        regfree(&nod2);
        if(vs < 0) {
            gopcode(OAS, &nod1, Z, &nod1);
            gopcode(OSUB, &nod1, nodconst(0), nn);
        } else 
            gopcode(OAS, &nod1, Z, nn);
        regfree(&nod1);
        return 1;
    case '+':
        o = OADD;
        goto addsub;
    case '-':
        o = OSUB;
    addsub:	/* number is r,n,l */
        v = p[1] - '0';
        r = &nod1;
        if(v&4)
            r = &nod2;
        n = &nod1;
        if(v&2)
            n = &nod2;
        l = &nod1;
        if(v&1)
            l = &nod2;
        gopcode(o, l, n, r);
        break;
    default: /* op is shiftcount, number is r,l */
        v = p[1] - '0';
        r = &nod1;
        if(v&2)
            r = &nod2;
        l = &nod1;
        if(v&1)
            l = &nod2;
        v = *p - 'a';
        if(v < 0 || v >= 32) {
            diag(n, "mulcon unknown op: %c%c", p[0], p[1]);
            break;
        }
        gopcode(OASHL, nodconst(v), l, r);
        break;
    }
    p += 2;
    goto loop;
}
@

<<function gextern(arm)>>=
void
gextern(Sym *s, Node *a, long o, long w)
{

    if(a->op == OCONST && typev[a->type->etype]) {
        if(align(0, types[TCHAR], Aarg1))	/* isbigendian */
            gpseudo(ADATA, s, nod32const(a->vconst>>32));
        else
            gpseudo(ADATA, s, nod32const(a->vconst));
        p->from.offset += o;
        p->reg = 4;
        if(align(0, types[TCHAR], Aarg1))	/* isbigendian */
            gpseudo(ADATA, s, nod32const(a->vconst));
        else
            gpseudo(ADATA, s, nod32const(a->vconst>>32));
        p->from.offset += o + 4;
        p->reg = 4;
        return;
    }
    gpseudo(ADATA, s, a);
    p->from.offset += o;
    p->reg = w;
    if(p->to.type == D_OREG)
        p->to.type = D_CONST;
}
@

<<function zwrite(arm)>>=
void
zwrite(Biobuf *b, Prog *p, int sf, int st)
{
    char bf[100], *bp;

    bf[0] = p->as;
    bf[1] = p->scond;
    bf[2] = p->reg;
    bf[3] = p->lineno;
    bf[4] = p->lineno>>8;
    bf[5] = p->lineno>>16;
    bf[6] = p->lineno>>24;
    bp = zaddr(bf+7, &p->from, sf);
    bp = zaddr(bp, &p->to, st);
    Bwrite(b, bf, bp-bf);
}
@

<<function outcode(arm)>>=
void
outcode(void)
{
    struct { Sym *sym; short type; } h[NSYM];
    Prog *p;
    Sym *s;
    int sf, st, t, sym;

    if(debug['S']) {
        for(p = firstp; p != P; p = p->link)
            if(p->as != ADATA && p->as != AGLOBL)
                pc--;
        for(p = firstp; p != P; p = p->link) {
            print("%P\n", p);
            if(p->as != ADATA && p->as != AGLOBL)
                pc++;
        }
    }
    outhist(&outbuf);
    for(sym=0; sym<NSYM; sym++) {
        h[sym].sym = S;
        h[sym].type = 0;
    }
    sym = 1;
    for(p = firstp; p != P; p = p->link) {
    jackpot:
        sf = 0;
        s = p->from.sym;
        while(s != S) {
            sf = s->sym;
            if(sf < 0 || sf >= NSYM)
                sf = 0;
            t = p->from.name;
            if(h[sf].type == t)
            if(h[sf].sym == s)
                break;
            s->sym = sym;
            zname(&outbuf, s, t);
            h[sym].sym = s;
            h[sym].type = t;
            sf = sym;
            sym++;
            if(sym >= NSYM)
                sym = 1;
            break;
        }
        st = 0;
        s = p->to.sym;
        while(s != S) {
            st = s->sym;
            if(st < 0 || st >= NSYM)
                st = 0;
            t = p->to.name;
            if(h[st].type == t)
            if(h[st].sym == s)
                break;
            s->sym = sym;
            zname(&outbuf, s, t);
            h[sym].sym = s;
            h[sym].type = t;
            st = sym;
            sym++;
            if(sym >= NSYM)
                sym = 1;
            if(st == sf)
                goto jackpot;
            break;
        }
        zwrite(&outbuf, p, sf, st);
    }
    firstp = P;
    lastp = P;
}
@

<<function outhist(arm)>>=
void
outhist(Biobuf *b)
{
    Hist *h;
    char *p, *q, *op, c;
    Prog pg;
    int n;

    pg = zprog;
    pg.as = AHISTORY;
    c = pathchar();
    for(h = hist; h != H; h = h->link) {
        p = h->name;
        op = 0;
        /* on windows skip drive specifier in pathname */
        //if(systemtype(Windows) && p && p[1] == ':'){
        //	p += 2;
        //	c = *p;
        //}
        if(p && p[0] != c && h->offset == 0 && pathname){
            /* on windows skip drive specifier in pathname */
            //if(systemtype(Windows) && pathname[1] == ':') {
            //	op = p;
            //	p = pathname+2;
            //	c = *p;
            //} else 
            if(pathname[0] == c){
                op = p;
                p = pathname;
            }
        }
        while(p) {
            q = utfrune(p, c);
            if(q) {
                n = q-p;
                if(n == 0){
                    n = 1;	/* leading "/" */
                    *p = '/';	/* don't emit "\" on windows */
                }
                q++;
            } else {
                n = strlen(p);
                q = 0;
            }
            if(n) {
                Bputc(b, ANAME);
                Bputc(b, D_FILE);
                Bputc(b, 1);
                Bputc(b, '<');
                Bwrite(b, p, n);
                Bputc(b, 0);
            }
            p = q;
            if(p == 0 && op) {
                p = op;
                op = 0;
            }
        }
        pg.lineno = h->line;
        pg.to.type = zprog.to.type;
        pg.to.offset = h->offset;
        if(h->offset)
            pg.to.type = D_CONST;

        zwrite(b, &pg, 0, 0);
    }
}
@

<<function zname(arm)>>=
void
zname(Biobuf *b, Sym *s, int t)
{
    char *n, bf[7];
    ulong sig;

    n = s->name;
    if(debug['T'] && t == D_EXTERN && s->sig != SIGDONE && s->type != types[TENUM] && s != symrathole){
        sig = sign(s);
        bf[0] = ASIGNAME;
        bf[1] = sig;
        bf[2] = sig>>8;
        bf[3] = sig>>16;
        bf[4] = sig>>24;
        bf[5] = t;
        bf[6] = s->sym;
        Bwrite(b, bf, 7);
        s->sig = SIGDONE;
    }
    else{
        bf[0] = ANAME;
        bf[1] = t;	/* type */
        bf[2] = s->sym;	/* sym */
        Bwrite(b, bf, 3);
    }
    Bwrite(b, n, strlen(n)+1);
}
@

<<function zaddr(arm)>>=
char*
zaddr(char *bp, Adr *a, int s)
{
    long l;
    Ieee e;

    bp[0] = a->type;
    bp[1] = a->reg;
    bp[2] = s;
    bp[3] = a->name;
    bp += 4;
    switch(a->type) {
    default:
        diag(Z, "unknown type %d in zaddr", a->type);

    case D_NONE:
    case D_REG:
    case D_FREG:
    case D_PSR:
        break;

    case D_OREG:
    case D_CONST:
    case D_BRANCH:
    case D_SHIFT:
        l = a->offset;
        bp[0] = l;
        bp[1] = l>>8;
        bp[2] = l>>16;
        bp[3] = l>>24;
        bp += 4;
        break;

    case D_SCONST:
        memmove(bp, a->sval, NSNAME);
        bp += NSNAME;
        break;

    case D_FCONST:
        ieeedtod(&e, a->dval);
        l = e.l;
        bp[0] = l;
        bp[1] = l>>8;
        bp[2] = l>>16;
        bp[3] = l>>24;
        bp += 4;
        l = e.h;
        bp[0] = l;
        bp[1] = l>>8;
        bp[2] = l>>16;
        bp[3] = l>>24;
        bp += 4;
        break;
    }
    return bp;
}
@

<<function align(arm)>>=
long
align(long i, Type *t, int op)
{
    long o;
    Type *v;
    int w;

    o = i;
    w = 1;
    switch(op) {
    default:
        diag(Z, "unknown align opcode %d", op);
        break;

    case Asu2:	/* padding at end of a struct */
        w = SZ_LONG;
        if(packflg)
            w = packflg;
        break;

    case Ael1:	/* initial align of struct element */
        for(v=t; v->etype==TARRAY; v=v->link)
            ;
        w = ewidth[v->etype];
        if(w <= 0 || w >= SZ_LONG)
            w = SZ_LONG;
        if(packflg)
            w = packflg;
        break;

    case Ael2:	/* width of a struct element */
        o += t->width;
        break;

    case Aarg0:	/* initial passbyptr argument in arg list */
        if(typesuv[t->etype]) {
            o = align(o, types[TIND], Aarg1);
            o = align(o, types[TIND], Aarg2);
        }
        break;

    case Aarg1:	/* initial align of parameter */
        w = ewidth[t->etype];
        if(w <= 0 || w >= SZ_LONG) {
            w = SZ_LONG;
            break;
        }
        w = 1;		/* little endian no adjustment */
        break;

    case Aarg2:	/* width of a parameter */
        o += t->width;
        w = SZ_LONG;
        break;

    case Aaut3:	/* total align of automatic */
        o = align(o, t, Ael2);
        o = align(o, t, Ael1);
        w = SZ_LONG;	/* because of a pun in cc/dcl.c:contig() */
        break;
    }
    o = round(o, w);
    if(debug['A'])
        print("align %s %ld %T = %ld\n", bnames[op], i, t, o);
    return o;
}
@

<<function maxround(arm)>>=
long
maxround(long max, long v)
{
    v = round(v, SZ_LONG);
    if(v > max)
        return v;
    return max;
}
@


%-------------------------------------------------------------

<<5c/swt.c>>=
#include "gc.h"

<<function swit1(arm)>>

<<function swit2(arm)>>

<<function bitload(arm)>>

<<function bitstore(arm)>>

<<function outstring(arm)>>

<<function mulcon(arm)>>

<<function gextern(arm)>>

void	zname(Biobuf*, Sym*, int);
char*	zaddr(char*, Adr*, int);
void	zwrite(Biobuf*, Prog*, int, int);
void	outhist(Biobuf*);

<<function zwrite(arm)>>

<<function outcode(arm)>>

<<function outhist(arm)>>

<<function zname(arm)>>

<<function zaddr(arm)>>

<<function align(arm)>>

<<function maxround(arm)>>
@


\subsection*{[[5c/mul.c]]}

<<global maxmulops(arm)>>=
/*
 * code sequences for multiply by constant.
 * [a-l][0-3]
 *	lsl	$(A-'a'),r0,r1
 * [+][0-7]
 *	add	r0,r1,r2
 * [-][0-7]
 *	sub	r0,r1,r2
 */

static  int	maxmulops = 3;	/* max # of ops to replace mul with */
@

<<global multabp(arm)>>=
static	int	multabp;
@

<<global mulval(arm)>>=
static	long	mulval;
@

<<global mulcp(arm)>>=
static	char*	mulcp;
@

<<global valmax(arm)>>=
static	long	valmax;
@

<<global shmax(arm)>>=
static	int	shmax;
@

<<enum _anon_ (5c/mul.c)(arm)>>=
enum
{
    SR1	= 1<<0,		/* r1 has been shifted */
    SR0	= 1<<1,		/* r0 has been shifted */
    UR1	= 1<<2,		/* r1 has not been used */
    UR0	= 1<<3,		/* r0 has not been used */
};
@

<<function mulcon0(arm)>>=
Multab*
mulcon0(long v)
{
    int a1, a2, g;
    Multab *m, *m1;
    char hint[10];

    if(v < 0)
        v = -v;

    /*
     * look in cache
     */
    m = multab;
    for(g=0; g<nelem(multab); g++) {
        if(m->val == v) {
            if(m->code[0] == 0)
                return 0;
            return m;
        }
        m++;
    }

    /*
     * select a spot in cache to overwrite
     */
    multabp++;
    if(multabp < 0 || multabp >= nelem(multab))
        multabp = 0;
    m = multab+multabp;
    m->val = v;
    mulval = v;

    /*
     * look in execption hint table
     */
    a1 = 0;
    a2 = hintabsize;
    for(;;) {
        if(a1 >= a2)
            goto no;
        g = (a2 + a1)/2;
        if(v < hintab[g].val) {
            a2 = g;
            continue;
        }
        if(v > hintab[g].val) {
            a1 = g+1;
            continue;
        }
        break;
    }

    if(docode(hintab[g].hint, m->code, 1, 0))
        return m;
    print("multiply table failure %ld\n", v);
    m->code[0] = 0;
    return 0;

no:
    /*
     * try to search
     */
    hint[0] = 0;
    for(g=1; g<=maxmulops; g++) {
        if(g >= maxmulops && v >= 65535)
            break;
        mulcp = hint+g;
        *mulcp = 0;
        if(gen1(g)) {
            if(docode(hint, m->code, 1, 0))
                return m;
            print("multiply table failure %ld\n", v);
            break;
        }
    }

    /*
     * try a recur followed by a shift
     */
    g = 0;
    while(!(v & 1)) {
        g++;
        v >>= 1;
    }
    if(g) {
        m1 = mulcon0(v);
        if(m1) {
            strcpy(m->code, m1->code);
            sprint(strchr(m->code, 0), "%c0", g+'a');
            return m;
        }
    }
    m->code[0] = 0;
    return 0;
}
@

<<function docode(arm)>>=
static int
docode(char *hp, char *cp, int r0, int r1)
{
    int c, i;

    c = *hp++;
    *cp = c;
    cp += 2;
    switch(c) {
    default:
        c -= 'a';
        if(c < 1 || c >= 30)
            break;
        for(i=0; i<4; i++) {
            switch(i) {
            case 0:
                if(docode(hp, cp, r0<<c, r1))
                    goto out;
                break;
            case 1:
                if(docode(hp, cp, r1<<c, r1))
                    goto out;
                break;
            case 2:
                if(docode(hp, cp, r0, r0<<c))
                    goto out;
                break;
            case 3:
                if(docode(hp, cp, r0, r1<<c))
                    goto out;
                break;
            }
        }
        break;

    case '+':
        for(i=0; i<8; i++) {
            cp[-1] = i+'0';
            switch(i) {
            case 1:
                if(docode(hp, cp, r0+r1, r1))
                    goto out;
                break;
            case 5:
                if(docode(hp, cp, r0, r0+r1))
                    goto out;
                break;
            }
        }
        break;

    case '-':
        for(i=0; i<8; i++) {
            cp[-1] = i+'0';
            switch(i) {
            case 1:
                if(docode(hp, cp, r0-r1, r1))
                    goto out;
                break;
            case 2:
                if(docode(hp, cp, r1-r0, r1))
                    goto out;
                break;
            case 5:
                if(docode(hp, cp, r0, r0-r1))
                    goto out;
                break;
            case 6:
                if(docode(hp, cp, r0, r1-r0))
                    goto out;
                break;
            }
        }
        break;

    case 0:
        if(r0 == mulval)
            return 1;
    }
    return 0;

out:
    cp[-1] = i+'0';
    return 1;
}
@

<<function gen1(arm)>>=
static int
gen1(int len)
{
    int i;

    for(shmax=1; shmax<30; shmax++) {
        valmax = 1<<shmax;
        if(valmax >= mulval)
            break;
    }
    if(mulval == 1)
        return 1;

    len--;
    for(i=1; i<=shmax; i++)
        if(gen2(len, 1<<i)) {
            *--mulcp = 'a'+i;
            return 1;
        }
    return 0;
}
@

<<function gen2(arm)>>=
static int
gen2(int len, long r1)
{
    int i;

    if(len <= 0) {
        if(r1 == mulval)
            return 1;
        return 0;
    }

    len--;
    if(len == 0)
        goto calcr0;

    if(gen3(len, r1, r1+1, UR1)) {
        i = '+';
        goto out;
    }
    if(gen3(len, r1-1, r1, UR0)) {
        i = '-';
        goto out;
    }
    if(gen3(len, 1, r1+1, UR1)) {
        i = '+';
        goto out;
    }
    if(gen3(len, 1, r1-1, UR1)) {
        i = '-';
        goto out;
    }

    return 0;

calcr0:
    if(mulval == r1+1) {
        i = '+';
        goto out;
    }
    if(mulval == r1-1) {
        i = '-';
        goto out;
    }
    return 0;

out:
    *--mulcp = i;
    return 1;
}
@

<<function gen3(arm)>>=
static int
gen3(int len, long r0, long r1, int flag)
{
    int i, f1, f2;
    long x;

    if(r0 <= 0 ||
       r0 >= r1 ||
       r1 > valmax)
        return 0;

    len--;
    if(len == 0)
        goto calcr0;

    if(!(flag & UR1)) {
        f1 = UR1|SR1;
        for(i=1; i<=shmax; i++) {
            x = r0<<i;
            if(x > valmax)
                break;
            if(gen3(len, r0, x, f1)) {
                i += 'a';
                goto out;
            }
        }
    }

    if(!(flag & UR0)) {
        f1 = UR1|SR1;
        for(i=1; i<=shmax; i++) {
            x = r1<<i;
            if(x > valmax)
                break;
            if(gen3(len, r1, x, f1)) {
                i += 'a';
                goto out;
            }
        }
    }

    if(!(flag & SR1)) {
        f1 = UR1|SR1|(flag&UR0);
        for(i=1; i<=shmax; i++) {
            x = r1<<i;
            if(x > valmax)
                break;
            if(gen3(len, r0, x, f1)) {
                i += 'a';
                goto out;
            }
        }
    }

    if(!(flag & SR0)) {
        f1 = UR0|SR0|(flag&(SR1|UR1));

        f2 = UR1|SR1;
        if(flag & UR1)
            f2 |= UR0;
        if(flag & SR1)
            f2 |= SR0;

        for(i=1; i<=shmax; i++) {
            x = r0<<i;
            if(x > valmax)
                break;
            if(x > r1) {
                if(gen3(len, r1, x, f2)) {
                    i += 'a';
                    goto out;
                }
            } else
                if(gen3(len, x, r1, f1)) {
                    i += 'a';
                    goto out;
                }
        }
    }

    x = r1+r0;
    if(gen3(len, r0, x, UR1)) {
        i = '+';
        goto out;
    }

    if(gen3(len, r1, x, UR1)) {
        i = '+';
        goto out;
    }

    x = r1-r0;
    if(gen3(len, x, r1, UR0)) {
        i = '-';
        goto out;
    }

    if(x > r0) {
        if(gen3(len, r0, x, UR1)) {
            i = '-';
            goto out;
        }
    } else
        if(gen3(len, x, r0, UR0)) {
            i = '-';
            goto out;
        }

    return 0;

calcr0:
    f1 = flag & (UR0|UR1);
    if(f1 == UR1) {
        for(i=1; i<=shmax; i++) {
            x = r1<<i;
            if(x >= mulval) {
                if(x == mulval) {
                    i += 'a';
                    goto out;
                }
                break;
            }
        }
    }

    if(mulval == r1+r0) {
        i = '+';
        goto out;
    }
    if(mulval == r1-r0) {
        i = '-';
        goto out;
    }

    return 0;

out:
    *--mulcp = i;
    return 1;
}
@

<<global hintab(arm)>>=
/*
 * hint table has numbers that
 * the search algorithm fails on.
 * <1000:
 *	all numbers
 * <5000:
 * 	 by 5
 * <10000:
 * 	 by 50
 * <65536:
 * 	 by 250
 */
Hintab	hintab[] =
{
    683,	"b++d+e+",
    687,	"b+e++e-",
    691,	"b++d+e+",
    731,	"b++d+e+",
    811,	"b++d+i+",
    821,	"b++e+e+",
    843,	"b+d++e+",
    851,	"b+f-+e-",
    853,	"b++e+e+",
    877,	"c++++g-",
    933,	"b+c++g-",
    981,	"c-+e-d+",
    1375,	"b+c+b+h-",
    1675,	"d+b++h+",
    2425,	"c++f-e+",
    2675,	"c+d++f-",
    2750,	"b+d-b+h-",
    2775,	"c-+g-e-",
    3125,	"b++e+g+",
    3275,	"b+c+g+e+",
    3350,	"c++++i+",
    3475,	"c-+e-f-",
    3525,	"c-+d+g-",
    3625,	"c-+e-j+",
    3675,	"b+d+d+e+",
    3725,	"b+d-+h+",
    3925,	"b+d+f-d-",
    4275,	"b+g++e+",
    4325,	"b+h-+d+",
    4425,	"b+b+g-j-",
    4525,	"b+d-d+f+",
    4675,	"c++d-g+",
    4775,	"b+d+b+g-",
    4825,	"c+c-+i-",
    4850,	"c++++i-",
    4925,	"b++e-g-",
    4975,	"c+f++e-",
    5500,	"b+g-c+d+",
    6700,	"d+b++i+",
    9700,	"d++++j-",
    11000,	"b+f-c-h-",
    11750,	"b+d+g+j-",
    12500,	"b+c+e-k+",
    13250,	"b+d+e-f+",
    13750,	"b+h-c-d+",
    14250,	"b+g-c+e-",
    14500,	"c+f+j-d-",
    14750,	"d-g--f+",
    16750,	"b+e-d-n+",
    17750,	"c+h-b+e+",
    18250,	"d+b+h-d+",
    18750,	"b+g-++f+",
    19250,	"b+e+b+h+",
    19750,	"b++h--f-",
    20250,	"b+e-l-c+",
    20750,	"c++bi+e-",
    21250,	"b+i+l+c+",
    22000,	"b+e+d-g-",
    22250,	"b+d-h+k-",
    22750,	"b+d-e-g+",
    23250,	"b+c+h+e-",
    23500,	"b+g-c-g-",
    23750,	"b+g-b+h-",
    24250,	"c++g+m-",
    24750,	"b+e+e+j-",
    25000,	"b++dh+g+",
    25250,	"b+e+d-g-",
    25750,	"b+e+b+j+",
    26250,	"b+h+c+e+",
    26500,	"b+h+c+g+",
    26750,	"b+d+e+g-",
    27250,	"b+e+e+f+",
    27500,	"c-i-c-d+",
    27750,	"b+bd++j+",
    28250,	"d-d-++i-",
    28500,	"c+c-h-e-",
    29000,	"b+g-d-f+",
    29500,	"c+h+++e-",
    29750,	"b+g+f-c+",
    30250,	"b+f-g-c+",
    33500,	"c-f-d-n+",
    33750,	"b+d-b+j-",
    34250,	"c+e+++i+",
    35250,	"e+b+d+k+",
    35500,	"c+e+d-g-",
    35750,	"c+i-++e+",
    36250,	"b+bh-d+e+",
    36500,	"c+c-h-e-",
    36750,	"d+e--i+",
    37250,	"b+g+g+b+",
    37500,	"b+h-b+f+",
    37750,	"c+be++j-",
    38500,	"b+e+b+i+",
    38750,	"d+i-b+d+",
    39250,	"b+g-l-+d+",
    39500,	"b+g-c+g-",
    39750,	"b+bh-c+f-",
    40250,	"b+bf+d+g-",
    40500,	"b+g-c+g+",
    40750,	"c+b+i-e+",
    41250,	"d++bf+h+",
    41500,	"b+j+c+d-",
    41750,	"c+f+b+h-",
    42500,	"c+h++g+",
    42750,	"b+g+d-f-",
    43250,	"b+l-e+d-",
    43750,	"c+bd+h+f-",
    44000,	"b+f+g-d-",
    44250,	"b+d-g--f+",
    44500,	"c+e+c+h+",
    44750,	"b+e+d-h-",
    45250,	"b++g+j-g+",
    45500,	"c+d+e-g+",
    45750,	"b+d-h-e-",
    46250,	"c+bd++j+",
    46500,	"b+d-c-j-",
    46750,	"e-e-b+g-",
    47000,	"b+c+d-j-",
    47250,	"b+e+e-g-",
    47500,	"b+g-c-h-",
    47750,	"b+f-c+h-",
    48250,	"d--h+n-",
    48500,	"b+c-g+m-",
    48750,	"b+e+e-g+",
    49500,	"c-f+e+j-",
    49750,	"c+c+g++f-",
    50000,	"b+e+e+k+",
    50250,	"b++i++g+",
    50500,	"c+g+f-i+",
    50750,	"b+e+d+k-",
    51500,	"b+i+c-f+",
    51750,	"b+bd+g-e-",
    52250,	"b+d+g-j+",
    52500,	"c+c+f+g+",
    52750,	"b+c+e+i+",
    53000,	"b+i+c+g+",
    53500,	"c+g+g-n+",
    53750,	"b+j+d-c+",
    54250,	"b+d-g-j-",
    54500,	"c-f+e+f+",
    54750,	"b+f-+c+g+",
    55000,	"b+g-d-g-",
    55250,	"b+e+e+g+",
    55500,	"b+cd++j+",
    55750,	"b+bh-d-f-",
    56250,	"c+d-b+j-",
    56500,	"c+d+c+i+",
    56750,	"b+e+d++h-",
    57000,	"b+d+g-f+",
    57250,	"b+f-m+d-",
    57750,	"b+i+c+e-",
    58000,	"b+e+d+h+",
    58250,	"c+b+g+g+",
    58750,	"d-e-j--e+",
    59000,	"d-i-+e+",
    59250,	"e--h-m+",
    59500,	"c+c-h+f-",
    59750,	"b+bh-e+i-",
    60250,	"b+bh-e-e-",
    60500,	"c+c-g-g-",
    60750,	"b+e-l-e-",
    61250,	"b+g-g-c+",
    61750,	"b+g-c+g+",
    62250,	"f--+c-i-",
    62750,	"e+f--+g+",
    64750,	"b+f+d+p-",
};
@

<<global hintabsize (5c/mul.c)(arm)>>=
int	hintabsize	= nelem(hintab);
@


%-------------------------------------------------------------

<<5c/mul.c>>=
#include "gc.h"

<<global maxmulops(arm)>>
<<global multabp(arm)>>
<<global mulval(arm)>>
<<global mulcp(arm)>>
<<global valmax(arm)>>
<<global shmax(arm)>>

static int	docode(char *hp, char *cp, int r0, int r1);
static int	gen1(int len);
static int	gen2(int len, long r1);
static int	gen3(int len, long r0, long r1, int flag);
<<enum _anon_ (5c/mul.c)(arm)>>

<<function mulcon0(arm)>>

<<function docode(arm)>>

<<function gen1(arm)>>

<<function gen2(arm)>>

<<function gen3(arm)>>

<<global hintab(arm)>>
<<global hintabsize (5c/mul.c)(arm)>>
@


\subsection*{[[5c/reg.c]]}

<<function rega(arm)>>=
Reg*
rega(void)
{
    Reg *r;

    r = freer;
    if(r == R) {
        r = alloc(sizeof(*r));
    } else
        freer = r->link;

    *r = zreg;
    return r;
}
@

<<function rcmp(arm)>>=
int
rcmp(const void *a1, const void *a2)
{
    Rgn *p1, *p2;
    int c1, c2;

    p1 = (Rgn*)a1;
    p2 = (Rgn*)a2;
    c1 = p2->cost;
    c2 = p1->cost;
    if(c1 -= c2)
        return c1;
    return p2->varno - p1->varno;
}
@

<<function regopt(arm)>>=
void
regopt(Prog *p)
{
    Reg *r, *r1, *r2;
    Prog *p1;
    int i, z;
    long initpc, val, npc;
    ulong vreg;
    Bits bit;
    struct
    {
        long	m;
        long	c;
        Reg*	p;
    } log5[6], *lp;

    firstr = R;
    lastr = R;
    nvar = 0;
    regbits = 0;
    for(z=0; z<BITS; z++) {
        externs.b[z] = 0;
        params.b[z] = 0;
        consts.b[z] = 0;
        addrs.b[z] = 0;
    }

    /*
     * pass 1
     * build aux data structure
     * allocate pcs
     * find use and set of variables
     */
    val = 5L * 5L * 5L * 5L * 5L;
    lp = log5;
    for(i=0; i<5; i++) {
        lp->m = val;
        lp->c = 0;
        lp->p = R;
        val /= 5L;
        lp++;
    }
    val = 0;
    for(; p != P; p = p->link) {
        switch(p->as) {
        case ADATA:
        case AGLOBL:
        case ANAME:
        case ASIGNAME:
            continue;
        }
        r = rega();
        if(firstr == R) {
            firstr = r;
            lastr = r;
        } else {
            lastr->link = r;
            r->p1 = lastr;
            lastr->s1 = r;
            lastr = r;
        }
        r->prog = p;
        r->pc = val;
        val++;

        lp = log5;
        for(i=0; i<5; i++) {
            lp->c--;
            if(lp->c <= 0) {
                lp->c = lp->m;
                if(lp->p != R)
                    lp->p->log5 = r;
                lp->p = r;
                (lp+1)->c = 0;
                break;
            }
            lp++;
        }

        r1 = r->p1;
        if(r1 != R)
        switch(r1->prog->as) {
        case ARET:
        case AB:
        case ARFE:
            r->p1 = R;
            r1->s1 = R;
        }

        /*
         * left side always read
         */
        bit = mkvar(&p->from, p->as==AMOVW);
        for(z=0; z<BITS; z++)
            r->use1.b[z] |= bit.b[z];

        /*
         * right side depends on opcode
         */
        bit = mkvar(&p->to, 0);
        if(bany(&bit))
        switch(p->as) {
        default:
            diag(Z, "reg: unknown asop: %A", p->as);
            break;

        /*
         * right side write
         */
        case ANOP:
        case AMOVB:
        case AMOVBU:
        case AMOVH:
        case AMOVHU:
        case AMOVW:
        case AMOVF:
        case AMOVD:
            for(z=0; z<BITS; z++)
                r->set.b[z] |= bit.b[z];
            break;

        /*
         * funny
         */
        case ABL:
            for(z=0; z<BITS; z++)
                addrs.b[z] |= bit.b[z];
            break;
        }

        if(p->as == AMOVM) {
            if(p->from.type == D_CONST)
                z = p->from.offset;
            else
                z = p->to.offset;
            for(i=0; z; i++) {
                if(z&1)
                    regbits |= RtoB(i);
                z >>= 1;
            }
        }
    }
    if(firstr == R)
        return;
    initpc = pc - val;
    npc = val;

    /*
     * pass 2
     * turn branch references to pointers
     * build back pointers
     */
    for(r = firstr; r != R; r = r->link) {
        p = r->prog;
        if(p->to.type == D_BRANCH) {
            val = p->to.offset - initpc;
            r1 = firstr;
            while(r1 != R) {
                r2 = r1->log5;
                if(r2 != R && val >= r2->pc) {
                    r1 = r2;
                    continue;
                }
                if(r1->pc == val)
                    break;
                r1 = r1->link;
            }
            if(r1 == R) {
                nearln = p->lineno;
                diag(Z, "ref not found\n%P", p);
                continue;
            }
            if(r1 == r) {
                nearln = p->lineno;
                diag(Z, "ref to self\n%P", p);
                continue;
            }
            r->s2 = r1;
            r->p2link = r1->p2;
            r1->p2 = r;
        }
    }
    if(debug['R']) {
        p = firstr->prog;
        print("\n%L %D\n", p->lineno, &p->from);
    }

    /*
     * pass 2.5
     * find looping structure
     */
    for(r = firstr; r != R; r = r->link)
        r->active = 0;
    change = 0;
    loopit(firstr, npc);

    /*
     * pass 3
     * iterate propagating usage
     * 	back until flow graph is complete
     */
loop1:
    change = 0;
    for(r = firstr; r != R; r = r->link)
        r->active = 0;
    for(r = firstr; r != R; r = r->link)
        if(r->prog->as == ARET)
            prop(r, zbits, zbits);
loop11:
    /* pick up unreachable code */
    i = 0;
    for(r = firstr; r != R; r = r1) {
        r1 = r->link;
        if(r1 && r1->active && !r->active) {
            prop(r, zbits, zbits);
            i = 1;
        }
    }
    if(i)
        goto loop11;
    if(change)
        goto loop1;


    /*
     * pass 4
     * iterate propagating register/variable synchrony
     * 	forward until graph is complete
     */
loop2:
    change = 0;
    for(r = firstr; r != R; r = r->link)
        r->active = 0;
    synch(firstr, zbits);
    if(change)
        goto loop2;

    addsplits();

    if(debug['R'] && debug['v']) {
        print("\nprop structure:\n");
        for(r = firstr; r != R; r = r->link) {
            print("%ld:%P", r->loop, r->prog);
            for(z=0; z<BITS; z++)
                bit.b[z] = r->set.b[z] |
                    r->refahead.b[z] | r->calahead.b[z] |
                    r->refbehind.b[z] | r->calbehind.b[z] |
                    r->use1.b[z] | r->use2.b[z];
            if(bany(&bit)) {
                print("\t");
                if(bany(&r->use1))
                    print(" u1=%B", r->use1);
                if(bany(&r->use2))
                    print(" u2=%B", r->use2);
                if(bany(&r->set))
                    print(" st=%B", r->set);
                if(bany(&r->refahead))
                    print(" ra=%B", r->refahead);
                if(bany(&r->calahead))
                    print(" ca=%B", r->calahead);
                if(bany(&r->refbehind))
                    print(" rb=%B", r->refbehind);
                if(bany(&r->calbehind))
                    print(" cb=%B", r->calbehind);
            }
            print("\n");
        }
    }

    /*
     * pass 5
     * isolate regions
     * calculate costs (paint1)
     */
    r = firstr;
    if(r) {
        for(z=0; z<BITS; z++)
            bit.b[z] = (r->refahead.b[z] | r->calahead.b[z]) &
              ~(externs.b[z] | params.b[z] | addrs.b[z] | consts.b[z]);
        if(bany(&bit)) {
            nearln = r->prog->lineno;
            warn(Z, "used and not set: %B", bit);
            if(debug['R'] && !debug['w'])
                print("used and not set: %B\n", bit);
        }
    }

    for(r = firstr; r != R; r = r->link)
        r->act = zbits;
    rgp = region;
    nregion = 0;
    for(r = firstr; r != R; r = r->link) {
        for(z=0; z<BITS; z++)
            bit.b[z] = r->set.b[z] &
              ~(r->refahead.b[z] | r->calahead.b[z] | addrs.b[z]);
        if(bany(&bit)) {
            nearln = r->prog->lineno;
            warn(Z, "set and not used: %B", bit);
            if(debug['R'])
                print("set and not used: %B\n", bit);
            excise(r);
        }
        for(z=0; z<BITS; z++)
            bit.b[z] = LOAD(r) & ~(r->act.b[z] | addrs.b[z]);
        while(bany(&bit)) {
            i = bnum(bit);
            rgp->enter = r;
            rgp->varno = i;
            change = 0;
            if(debug['R'] && debug['v'])
                print("\n");
            paint1(r, i);
            bit.b[i/32] &= ~(1L<<(i%32));
            if(change <= 0) {
                if(debug['R'])
                    print("%L $%d: %B\n",
                        r->prog->lineno, change, blsh(i));
                continue;
            }
            rgp->cost = change;
            nregion++;
            if(nregion >= NRGN) {
                warn(Z, "too many regions");
                goto brk;
            }
            rgp++;
        }
    }
brk:
    qsort(region, nregion, sizeof(region[0]), rcmp);

    /*
     * pass 6
     * determine used registers (paint2)
     * replace code (paint3)
     */
    rgp = region;
    for(i=0; i<nregion; i++) {
        bit = blsh(rgp->varno);
        vreg = paint2(rgp->enter, rgp->varno);
        vreg = allreg(vreg, rgp);
        if(debug['R']) {
            if(rgp->regno >= NREG)
                print("%L $%d F%d: %B\n",
                    rgp->enter->prog->lineno,
                    rgp->cost,
                    rgp->regno-NREG,
                    bit);
            else
                print("%L $%d R%d: %B\n",
                    rgp->enter->prog->lineno,
                    rgp->cost,
                    rgp->regno,
                    bit);
        }
        if(rgp->regno != 0)
            paint3(rgp->enter, rgp->varno, vreg, rgp->regno);
        rgp++;
    }
    /*
     * pass 7
     * peep-hole on basic block
     */
    if(!debug['R'] || debug['P'])
        peep();

    /*
     * pass 8
     * recalculate pc
     */
    val = initpc;
    for(r = firstr; r != R; r = r1) {
        r->pc = val;
        p = r->prog;
        p1 = P;
        r1 = r->link;
        if(r1 != R)
            p1 = r1->prog;
        for(; p != p1; p = p->link) {
            switch(p->as) {
            default:
                val++;
                break;

            case ANOP:
            case ADATA:
            case AGLOBL:
            case ANAME:
            case ASIGNAME:
                break;
            }
        }
    }
    pc = val;

    /*
     * fix up branches
     */
    if(debug['R'])
        if(bany(&addrs))
            print("addrs: %B\n", addrs);

    r1 = 0; /* set */
    for(r = firstr; r != R; r = r->link) {
        p = r->prog;
        if(p->to.type == D_BRANCH)
            p->to.offset = r->s2->pc;
        r1 = r;
    }

    /*
     * last pass
     * eliminate nops
     * free aux structures
     */
    for(p = firstr->prog; p != P; p = p->link){
        while(p->link && p->link->as == ANOP)
            p->link = p->link->link;
    }
    if(r1 != R) {
        r1->link = freer;
        freer = firstr;
    }
}
@

<<function addsplits(arm)>>=
void
addsplits(void)
{
    Reg *r, *r1;
    int z, i;
    Bits bit;

    for(r = firstr; r != R; r = r->link) {
        if(r->loop > 1)
            continue;
        if(r->prog->as == ABL)
            continue;
        for(r1 = r->p2; r1 != R; r1 = r1->p2link) {
            if(r1->loop <= 1)
                continue;
            for(z=0; z<BITS; z++)
                bit.b[z] = r1->calbehind.b[z] &
                    (r->refahead.b[z] | r->use1.b[z] | r->use2.b[z]) &
                    ~(r->calahead.b[z] & addrs.b[z]);
            while(bany(&bit)) {
                i = bnum(bit);
                bit.b[i/32] &= ~(1L << (i%32));
            }
        }
    }
}
@

<<function addmove(arm)>>=
/*
 * add mov b,rn
 * just after r
 */
void
addmove(Reg *r, int bn, int rn, int f)
{
    Prog *p, *p1;
    Adr *a;
    Var *v;

    p1 = alloc(sizeof(*p1));
    *p1 = zprog;
    p = r->prog;

    p1->link = p->link;
    p->link = p1;
    p1->lineno = p->lineno;

    v = var + bn;

    a = &p1->to;
    a->sym = v->sym;
    a->name = v->name;
    a->offset = v->offset;
    a->etype = v->etype;
    a->type = D_OREG;
    if(a->etype == TARRAY || a->sym == S)
        a->type = D_CONST;

    p1->as = AMOVW;
    if(v->etype == TCHAR || v->etype == TUCHAR)
        p1->as = AMOVB;
    if(v->etype == TSHORT || v->etype == TUSHORT)
        p1->as = AMOVH;
    if(v->etype == TFLOAT)
        p1->as = AMOVF;
    if(v->etype == TDOUBLE)
        p1->as = AMOVD;

    p1->from.type = D_REG;
    p1->from.reg = rn;
    if(rn >= NREG) {
        p1->from.type = D_FREG;
        p1->from.reg = rn-NREG;
    }
    if(!f) {
        p1->from = *a;
        *a = zprog.from;
        a->type = D_REG;
        a->reg = rn;
        if(rn >= NREG) {
            a->type = D_FREG;
            a->reg = rn-NREG;
        }
        if(v->etype == TUCHAR)
            p1->as = AMOVBU;
        if(v->etype == TUSHORT)
            p1->as = AMOVHU;
    }
    if(debug['R'])
        print("%P\t.a%P\n", p, p1);
}
@

<<function mkvar(arm)>>=
Bits
mkvar(Adr *a, int docon)
{
    Var *v;
    int i, t, n, et, z;
    long o;
    Bits bit;
    Sym *s;

    t = a->type;
    if(t == D_REG && a->reg != NREG)
        regbits |= RtoB(a->reg);
    if(t == D_FREG && a->reg != NREG)
        regbits |= FtoB(a->reg);
    s = a->sym;
    o = a->offset;
    et = a->etype;
    if(s == S) {
        if(t != D_CONST || !docon || a->reg != NREG)
            goto none;
        et = TLONG;
    }
    if(t == D_CONST) {
        if(s == S && sval(o))
            goto none;
    }

    n = a->name;
    v = var;
    for(i=0; i<nvar; i++) {
        if(s == v->sym)
        if(n == v->name)
        if(o == v->offset)
            goto out;
        v++;
    }
    if(s)
        if(s->name[0] == '.')
            goto none;
    if(nvar >= NVAR) {
        if(debug['w'] > 1 && s)
            warn(Z, "variable not optimized: %s", s->name);
        goto none;
    }
    i = nvar;
    nvar++;
    v = &var[i];
    v->sym = s;
    v->offset = o;
    v->etype = et;
    v->name = n;
    if(debug['R'])
        print("bit=%2d et=%2d %D\n", i, et, a);
out:
    bit = blsh(i);
    if(n == D_EXTERN || n == D_STATIC)
        for(z=0; z<BITS; z++)
            externs.b[z] |= bit.b[z];
    if(n == D_PARAM)
        for(z=0; z<BITS; z++)
            params.b[z] |= bit.b[z];
    if(v->etype != et || !typechlpfd[et])	/* funny punning */
        for(z=0; z<BITS; z++)
            addrs.b[z] |= bit.b[z];
    if(t == D_CONST) {
        if(s == S) {
            for(z=0; z<BITS; z++)
                consts.b[z] |= bit.b[z];
            return bit;
        }
        if(et != TARRAY)
            for(z=0; z<BITS; z++)
                addrs.b[z] |= bit.b[z];
        for(z=0; z<BITS; z++)
            params.b[z] |= bit.b[z];
        return bit;
    }
    if(t == D_OREG)
        return bit;

none:
    return zbits;
}
@

<<function prop(arm)>>=
void
prop(Reg *r, Bits ref, Bits cal)
{
    Reg *r1, *r2;
    int z;

    for(r1 = r; r1 != R; r1 = r1->p1) {
        for(z=0; z<BITS; z++) {
            ref.b[z] |= r1->refahead.b[z];
            if(ref.b[z] != r1->refahead.b[z]) {
                r1->refahead.b[z] = ref.b[z];
                change++;
            }
            cal.b[z] |= r1->calahead.b[z];
            if(cal.b[z] != r1->calahead.b[z]) {
                r1->calahead.b[z] = cal.b[z];
                change++;
            }
        }
        switch(r1->prog->as) {
        case ABL:
            for(z=0; z<BITS; z++) {
                cal.b[z] |= ref.b[z] | externs.b[z];
                ref.b[z] = 0;
            }
            break;

        case ATEXT:
            for(z=0; z<BITS; z++) {
                cal.b[z] = 0;
                ref.b[z] = 0;
            }
            break;

        case ARET:
            for(z=0; z<BITS; z++) {
                cal.b[z] = externs.b[z];
                ref.b[z] = 0;
            }
        }
        for(z=0; z<BITS; z++) {
            ref.b[z] = (ref.b[z] & ~r1->set.b[z]) |
                r1->use1.b[z] | r1->use2.b[z];
            cal.b[z] &= ~(r1->set.b[z] | r1->use1.b[z] | r1->use2.b[z]);
            r1->refbehind.b[z] = ref.b[z];
            r1->calbehind.b[z] = cal.b[z];
        }
        if(r1->active)
            break;
        r1->active = 1;
    }
    for(; r != r1; r = r->p1)
        for(r2 = r->p2; r2 != R; r2 = r2->p2link)
            prop(r2, r->refbehind, r->calbehind);
}
@

<<function postorder(arm)>>=
/*
 * find looping structure
 *
 * 1) find reverse postordering
 * 2) find approximate dominators,
 *	the actual dominators if the flow graph is reducible
 *	otherwise, dominators plus some other non-dominators.
 *	See Matthew S. Hecht and Jeffrey D. Ullman,
 *	"Analysis of a Simple Algorithm for Global Data Flow Problems",
 *	Conf.  Record of ACM Symp. on Principles of Prog. Langs, Boston, Massachusetts,
 *	Oct. 1-3, 1973, pp.  207-217.
 * 3) find all nodes with a predecessor dominated by the current node.
 *	such a node is a loop head.
 *	recursively, all preds with a greater rpo number are in the loop
 */
long
postorder(Reg *r, Reg **rpo2r, long n)
{
    Reg *r1;

    r->rpo = 1;
    r1 = r->s1;
    if(r1 && !r1->rpo)
        n = postorder(r1, rpo2r, n);
    r1 = r->s2;
    if(r1 && !r1->rpo)
        n = postorder(r1, rpo2r, n);
    rpo2r[n] = r;
    n++;
    return n;
}
@

<<function rpolca(arm)>>=
long
rpolca(long *idom, long rpo1, long rpo2)
{
    long t;

    if(rpo1 == -1)
        return rpo2;
    while(rpo1 != rpo2){
        if(rpo1 > rpo2){
            t = rpo2;
            rpo2 = rpo1;
            rpo1 = t;
        }
        while(rpo1 < rpo2){
            t = idom[rpo2];
            if(t >= rpo2)
                fatal(Z, "bad idom");
            rpo2 = t;
        }
    }
    return rpo1;
}
@

<<function doms(arm)>>=
int
doms(long *idom, long r, long s)
{
    while(s > r)
        s = idom[s];
    return s == r;
}
@

<<function loophead(arm)>>=
int
loophead(long *idom, Reg *r)
{
    long src;

    src = r->rpo;
    if(r->p1 != R && doms(idom, src, r->p1->rpo))
        return 1;
    for(r = r->p2; r != R; r = r->p2link)
        if(doms(idom, src, r->rpo))
            return 1;
    return 0;
}
@

<<function loopmark(arm)>>=
void
loopmark(Reg **rpo2r, long head, Reg *r)
{
    if(r->rpo < head || r->active == head)
        return;
    r->active = head;
    r->loop += LOOP;
    if(r->p1 != R)
        loopmark(rpo2r, head, r->p1);
    for(r = r->p2; r != R; r = r->p2link)
        loopmark(rpo2r, head, r);
}
@

<<function loopit(arm)>>=
void
loopit(Reg *r, long nr)
{
    Reg *r1;
    long i, d, me;

    if(nr > maxnr) {
        rpo2r = alloc(nr * sizeof(Reg*));
        idom = alloc(nr * sizeof(long));
        maxnr = nr;
    }

    d = postorder(r, rpo2r, 0);
    if(d > nr)
        fatal(Z, "too many reg nodes");
    nr = d;
    for(i = 0; i < nr / 2; i++){
        r1 = rpo2r[i];
        rpo2r[i] = rpo2r[nr - 1 - i];
        rpo2r[nr - 1 - i] = r1;
    }
    for(i = 0; i < nr; i++)
        rpo2r[i]->rpo = i;

    idom[0] = 0;
    for(i = 0; i < nr; i++){
        r1 = rpo2r[i];
        me = r1->rpo;
        d = -1;
        if(r1->p1 != R && r1->p1->rpo < me)
            d = r1->p1->rpo;
        for(r1 = r1->p2; r1 != nil; r1 = r1->p2link)
            if(r1->rpo < me)
                d = rpolca(idom, d, r1->rpo);
        idom[i] = d;
    }

    for(i = 0; i < nr; i++){
        r1 = rpo2r[i];
        r1->loop++;
        if(r1->p2 != R && loophead(idom, r1))
            loopmark(rpo2r, i, r1);
    }
}
@

<<function synch(arm)>>=
void
synch(Reg *r, Bits dif)
{
    Reg *r1;
    int z;

    for(r1 = r; r1 != R; r1 = r1->s1) {
        for(z=0; z<BITS; z++) {
            dif.b[z] = (dif.b[z] &
                ~(~r1->refbehind.b[z] & r1->refahead.b[z])) |
                    r1->set.b[z] | r1->regdiff.b[z];
            if(dif.b[z] != r1->regdiff.b[z]) {
                r1->regdiff.b[z] = dif.b[z];
                change++;
            }
        }
        if(r1->active)
            break;
        r1->active = 1;
        for(z=0; z<BITS; z++)
            dif.b[z] &= ~(~r1->calbehind.b[z] & r1->calahead.b[z]);
        if(r1->s2 != R)
            synch(r1->s2, dif);
    }
}
@

<<function allreg(arm)>>=
ulong
allreg(ulong b, Rgn *r)
{
    Var *v;
    int i;

    v = var + r->varno;
    r->regno = 0;
    switch(v->etype) {

    default:
        diag(Z, "unknown etype %d/%d", bitno(b), v->etype);
        break;

    case TCHAR:
    case TUCHAR:
    case TSHORT:
    case TUSHORT:
    case TINT:
    case TUINT:
    case TLONG:
    case TULONG:
    case TIND:
    case TARRAY:
        i = BtoR(~b);
        if(i && r->cost >= 0) {
            r->regno = i;
            return RtoB(i);
        }
        break;

    case TVLONG:
    case TDOUBLE:
    case TFLOAT:
        i = BtoF(~b);
        if(i && r->cost >= 0) {
            r->regno = i+NREG;
            return FtoB(i);
        }
        break;
    }
    return 0;
}
@

<<function paint1(arm)>>=
void
paint1(Reg *r, int bn)
{
    Reg *r1;
    Prog *p;
    int z;
    ulong bb;

    z = bn/32;
    bb = 1L<<(bn%32);
    if(r->act.b[z] & bb)
        return;
    for(;;) {
        if(!(r->refbehind.b[z] & bb))
            break;
        r1 = r->p1;
        if(r1 == R)
            break;
        if(!(r1->refahead.b[z] & bb))
            break;
        if(r1->act.b[z] & bb)
            break;
        r = r1;
    }

    if(LOAD(r) & ~(r->set.b[z] & ~(r->use1.b[z]|r->use2.b[z])) & bb) {
        change -= CLOAD * r->loop;
        if(debug['R'] && debug['v'])
            print("%ld%P\tld %B $%d\n", r->loop,
                r->prog, blsh(bn), change);
    }
    for(;;) {
        r->act.b[z] |= bb;
        p = r->prog;

        if(r->use1.b[z] & bb) {
            change += CREF * r->loop;
            if(debug['R'] && debug['v'])
                print("%ld%P\tu1 %B $%d\n", r->loop,
                    p, blsh(bn), change);
        }

        if((r->use2.b[z]|r->set.b[z]) & bb) {
            change += CREF * r->loop;
            if(debug['R'] && debug['v'])
                print("%ld%P\tu2 %B $%d\n", r->loop,
                    p, blsh(bn), change);
        }

        if(STORE(r) & r->regdiff.b[z] & bb) {
            change -= CLOAD * r->loop;
            if(debug['R'] && debug['v'])
                print("%ld%P\tst %B $%d\n", r->loop,
                    p, blsh(bn), change);
        }

        if(r->refbehind.b[z] & bb)
            for(r1 = r->p2; r1 != R; r1 = r1->p2link)
                if(r1->refahead.b[z] & bb)
                    paint1(r1, bn);

        if(!(r->refahead.b[z] & bb))
            break;
        r1 = r->s2;
        if(r1 != R)
            if(r1->refbehind.b[z] & bb)
                paint1(r1, bn);
        r = r->s1;
        if(r == R)
            break;
        if(r->act.b[z] & bb)
            break;
        if(!(r->refbehind.b[z] & bb))
            break;
    }
}
@

<<function paint2(arm)>>=
ulong
paint2(Reg *r, int bn)
{
    Reg *r1;
    int z;
    ulong bb, vreg;

    z = bn/32;
    bb = 1L << (bn%32);
    vreg = regbits;
    if(!(r->act.b[z] & bb))
        return vreg;
    for(;;) {
        if(!(r->refbehind.b[z] & bb))
            break;
        r1 = r->p1;
        if(r1 == R)
            break;
        if(!(r1->refahead.b[z] & bb))
            break;
        if(!(r1->act.b[z] & bb))
            break;
        r = r1;
    }
    for(;;) {
        r->act.b[z] &= ~bb;

        vreg |= r->regu;

        if(r->refbehind.b[z] & bb)
            for(r1 = r->p2; r1 != R; r1 = r1->p2link)
                if(r1->refahead.b[z] & bb)
                    vreg |= paint2(r1, bn);

        if(!(r->refahead.b[z] & bb))
            break;
        r1 = r->s2;
        if(r1 != R)
            if(r1->refbehind.b[z] & bb)
                vreg |= paint2(r1, bn);
        r = r->s1;
        if(r == R)
            break;
        if(!(r->act.b[z] & bb))
            break;
        if(!(r->refbehind.b[z] & bb))
            break;
    }
    return vreg;
}
@

<<function paint3(arm)>>=
void
paint3(Reg *r, int bn, long rb, int rn)
{
    Reg *r1;
    Prog *p;
    int z;
    ulong bb;

    z = bn/32;
    bb = 1L << (bn%32);
    if(r->act.b[z] & bb)
        return;
    for(;;) {
        if(!(r->refbehind.b[z] & bb))
            break;
        r1 = r->p1;
        if(r1 == R)
            break;
        if(!(r1->refahead.b[z] & bb))
            break;
        if(r1->act.b[z] & bb)
            break;
        r = r1;
    }

    if(LOAD(r) & ~(r->set.b[z] & ~(r->use1.b[z]|r->use2.b[z])) & bb)
        addmove(r, bn, rn, 0);
    for(;;) {
        r->act.b[z] |= bb;
        p = r->prog;

        if(r->use1.b[z] & bb) {
            if(debug['R'])
                print("%P", p);
            addreg(&p->from, rn);
            if(debug['R'])
                print("\t.c%P\n", p);
        }
        if((r->use2.b[z]|r->set.b[z]) & bb) {
            if(debug['R'])
                print("%P", p);
            addreg(&p->to, rn);
            if(debug['R'])
                print("\t.c%P\n", p);
        }

        if(STORE(r) & r->regdiff.b[z] & bb)
            addmove(r, bn, rn, 1);
        r->regu |= rb;

        if(r->refbehind.b[z] & bb)
            for(r1 = r->p2; r1 != R; r1 = r1->p2link)
                if(r1->refahead.b[z] & bb)
                    paint3(r1, bn, rb, rn);

        if(!(r->refahead.b[z] & bb))
            break;
        r1 = r->s2;
        if(r1 != R)
            if(r1->refbehind.b[z] & bb)
                paint3(r1, bn, rb, rn);
        r = r->s1;
        if(r == R)
            break;
        if(r->act.b[z] & bb)
            break;
        if(!(r->refbehind.b[z] & bb))
            break;
    }
}
@

<<function addreg(arm)>>=
void
addreg(Adr *a, int rn)
{

    a->sym = 0;
    a->name = D_NONE;
    a->type = D_REG;
    a->reg = rn;
    if(rn >= NREG) {
        a->type = D_FREG;
        a->reg = rn-NREG;
    }
}
@

<<function RtoB(arm)>>=
/*
 *	bit	reg
 *	0	R0
 *	1	R1
 *	...	...
 *	10	R10
 */
long
RtoB(int r)
{

    if(r >= REGMIN && r <= REGMAX)
        return 1L << r;
    return 0;
}
@

<<function BtoR(arm)>>=
int
BtoR(long b)
{
    b &= 0x01fcL;	// excluded R9 and R10 for m and g
    if(b == 0)
        return 0;
    return bitno(b);
}
@

<<function FtoB(arm)>>=
/*
 *	bit	reg
 *	18	F2
 *	19	F3
 *	...	...
 *	23	F7
 */
long
FtoB(int f)
{

    if(f < 2 || f > NFREG-1)
        return 0;
    return 1L << (f + 16);
}
@

<<function BtoF(arm)>>=
int
BtoF(long b)
{

    b &= 0xfc0000L;
    if(b == 0)
        return 0;
    return bitno(b) - 16;
}
@


%-------------------------------------------------------------

<<5c/reg.c>>=
#include "gc.h"

void	addsplits(void);

<<function rega(arm)>>

<<function rcmp(arm)>>

<<function regopt(arm)>>

<<function addsplits(arm)>>

<<function addmove(arm)>>

<<function mkvar(arm)>>

<<function prop(arm)>>

<<function postorder(arm)>>

<<function rpolca(arm)>>

<<function doms(arm)>>

<<function loophead(arm)>>

<<function loopmark(arm)>>

<<function loopit(arm)>>

<<function synch(arm)>>

<<function allreg(arm)>>

<<function paint1(arm)>>

<<function paint2(arm)>>

<<function paint3(arm)>>

<<function addreg(arm)>>

<<function RtoB(arm)>>

<<function BtoR(arm)>>

<<function FtoB(arm)>>

<<function BtoF(arm)>>
@


\subsection*{[[5c/cgen.c]]}

<<function cgen(arm)>>=
void
cgen(Node *n, Node *nn)
{
    cgenrel(n, nn, 0);
}
@

<<function cgenrel(arm)>>=
void
cgenrel(Node *n, Node *nn, int inrel)
{
    Node *l, *r;
    Prog *p1;
    Node nod, nod1, nod2, nod3, nod4;
    int o, t;
    long v, curs;

    if(debug['g']) {
        prtree(nn, "cgen lhs");
        prtree(n, "cgen");
    }
    if(n == Z || n->type == T)
        return;
    if(typesuv[n->type->etype]) {
        sugen(n, nn, n->type->width);
        return;
    }
    l = n->left;
    r = n->right;
    o = n->op;
    if(n->addable >= INDEXED) {
        if(nn == Z) {
            switch(o) {
            default:
                nullwarn(Z, Z);
                break;
            case OINDEX:
                nullwarn(l, r);
                break;
            }
            return;
        }
        gmove(n, nn);
        return;
    }
    curs = cursafe;

    if(n->complex >= FNX)
    if(l->complex >= FNX)
    if(r != Z && r->complex >= FNX)
    switch(o) {
    default:
        regret(&nod, r);
        cgen(r, &nod);

        regsalloc(&nod1, r);
        gopcode(OAS, &nod, Z, &nod1);

        regfree(&nod);
        nod = *n;
        nod.right = &nod1;
        cgen(&nod, nn);
        return;

    case OFUNC:
    case OCOMMA:
    case OANDAND:
    case OOROR:
    case OCOND:
    case ODOT:
        break;
    }

    switch(o) {
    default:
        diag(n, "unknown op in cgen: %O", o);
        break;

    case OAS:
        if(l->op == OBIT)
            goto bitas;
        if(l->addable >= INDEXED && l->complex < FNX) {
            if(nn != Z || r->addable < INDEXED) {
                if(r->complex >= FNX && nn == Z)
                    regret(&nod, r);
                else
                    regalloc(&nod, r, nn);
                cgen(r, &nod);
                gmove(&nod, l);
                if(nn != Z)
                    gmove(&nod, nn);
                regfree(&nod);
            } else
                gmove(r, l);
            break;
        }
        if(l->complex >= r->complex) {
            reglcgen(&nod1, l, Z);
            if(r->addable >= INDEXED) {
                gmove(r, &nod1);
                if(nn != Z)
                    gmove(r, nn);
                regfree(&nod1);
                break;
            }
            regalloc(&nod, r, nn);
            cgen(r, &nod);
        } else {
            regalloc(&nod, r, nn);
            cgen(r, &nod);
            reglcgen(&nod1, l, Z);
        }
        gmove(&nod, &nod1);
        regfree(&nod);
        regfree(&nod1);
        break;

    bitas:
        n = l->left;
        regalloc(&nod, r, nn);
        if(l->complex >= r->complex) {
            reglcgen(&nod1, n, Z);
            cgen(r, &nod);
        } else {
            cgen(r, &nod);
            reglcgen(&nod1, n, Z);
        }
        regalloc(&nod2, n, Z);
        gopcode(OAS, &nod1, Z, &nod2);
        bitstore(l, &nod, &nod1, &nod2, nn);
        break;

    case OBIT:
        if(nn == Z) {
            nullwarn(l, Z);
            break;
        }
        bitload(n, &nod, Z, Z, nn);
        gopcode(OAS, &nod, Z, nn);
        regfree(&nod);
        break;

    case ODIV:
    case OMOD:
        if(nn != Z)
        if((t = vlog(r)) >= 0) {
            /* signed div/mod by constant power of 2 */
            cgen(l, nn);
            gopcode(OGE, nodconst(0), nn, Z);
            p1 = p;
            if(o == ODIV) {
                gopcode(OADD, nodconst((1<<t)-1), Z, nn);
                patch(p1, pc);
                gopcode(OASHR, nodconst(t), Z, nn);
            } else {
                gopcode(OSUB, nn, nodconst(0), nn);
                gopcode(OAND, nodconst((1<<t)-1), Z, nn);
                gopcode(OSUB, nn, nodconst(0), nn);
                gbranch(OGOTO);
                patch(p1, pc);
                p1 = p;
                gopcode(OAND, nodconst((1<<t)-1), Z, nn);
                patch(p1, pc);
            }
            break;
        }
        goto muldiv;

    case OSUB:
        if(nn != Z)
        if(l->op == OCONST)
        if(!typefd[n->type->etype]) {
            cgen(r, nn);
            gopcode(o, Z, l, nn);
            break;
        }
    case OADD:
    case OAND:
    case OOR:
    case OXOR:
    case OLSHR:
    case OASHL:
    case OASHR:
        /*
         * immediate operands
         */
        if(nn != Z)
        if(r->op == OCONST)
        if(!typefd[n->type->etype]) {
            cgen(l, nn);
            if(r->vconst == 0)
            if(o != OAND)
                break;
            if(nn != Z)
                gopcode(o, r, Z, nn);
            break;
        }

    case OLMUL:
    case OLDIV:
    case OLMOD:
    case OMUL:
    muldiv:
        if(nn == Z) {
            nullwarn(l, r);
            break;
        }
        if(o == OMUL || o == OLMUL) {
            if(mulcon(n, nn))
                break;
        }
        if(l->complex >= r->complex) {
            regalloc(&nod, l, nn);
            cgen(l, &nod);
            regalloc(&nod1, r, Z);
            cgen(r, &nod1);
            gopcode(o, &nod1, Z, &nod);
        } else {
            regalloc(&nod, r, nn);
            cgen(r, &nod);
            regalloc(&nod1, l, Z);
            cgen(l, &nod1);
            gopcode(o, &nod, &nod1, &nod);
        }
        gopcode(OAS, &nod, Z, nn);
        regfree(&nod);
        regfree(&nod1);
        break;

    case OASLSHR:
    case OASASHL:
    case OASASHR:
    case OASAND:
    case OASADD:
    case OASSUB:
    case OASXOR:
    case OASOR:
        if(l->op == OBIT)
            goto asbitop;
        if(r->op == OCONST)
        if(!typefd[r->type->etype])
        if(!typefd[n->type->etype]) {
            if(l->addable < INDEXED)
                reglcgen(&nod2, l, Z);
            else
                nod2 = *l;
            regalloc(&nod, r, nn);
            gopcode(OAS, &nod2, Z, &nod);
            gopcode(o, r, Z, &nod);
            gopcode(OAS, &nod, Z, &nod2);
    
            regfree(&nod);
            if(l->addable < INDEXED)
                regfree(&nod2);
            break;
        }

    case OASLMUL:
    case OASLDIV:
    case OASLMOD:
    case OASMUL:
    case OASDIV:
    case OASMOD:
        if(l->op == OBIT)
            goto asbitop;
        if(l->complex >= r->complex) {
            if(l->addable < INDEXED)
                reglcgen(&nod2, l, Z);
            else
                nod2 = *l;
            regalloc(&nod1, r, Z);
            cgen(r, &nod1);
        } else {
            regalloc(&nod1, r, Z);
            cgen(r, &nod1);
            if(l->addable < INDEXED)
                reglcgen(&nod2, l, Z);
            else
                nod2 = *l;
        }

        regalloc(&nod, n, nn);
        gmove(&nod2, &nod);
        gopcode(o, &nod1, Z, &nod);
        gmove(&nod, &nod2);
        if(nn != Z)
            gopcode(OAS, &nod, Z, nn);
        regfree(&nod);
        regfree(&nod1);
        if(l->addable < INDEXED)
            regfree(&nod2);
        break;

    asbitop:
        regalloc(&nod4, n, nn);
        if(l->complex >= r->complex) {
            bitload(l, &nod, &nod1, &nod2, &nod4);
            regalloc(&nod3, r, Z);
            cgen(r, &nod3);
        } else {
            regalloc(&nod3, r, Z);
            cgen(r, &nod3);
            bitload(l, &nod, &nod1, &nod2, &nod4);
        }
        gmove(&nod, &nod4);
        gopcode(o, &nod3, Z, &nod4);
        regfree(&nod3);
        gmove(&nod4, &nod);
        regfree(&nod4);
        bitstore(l, &nod, &nod1, &nod2, nn);
        break;

    case OADDR:
        if(nn == Z) {
            nullwarn(l, Z);
            break;
        }
        lcgen(l, nn);
        break;

    case OFUNC:
        if(l->complex >= FNX) {
            if(l->op != OIND)
                diag(n, "bad function call");

            regret(&nod, l->left);
            cgen(l->left, &nod);
            regsalloc(&nod1, l->left);
            gopcode(OAS, &nod, Z, &nod1);
            regfree(&nod);

            nod = *n;
            nod.left = &nod2;
            nod2 = *l;
            nod2.left = &nod1;
            nod2.complex = 1;
            cgen(&nod, nn);

            return;
        }
        if(REGARG >= 0)
            o = reg[REGARG];
        gargs(r, &nod, &nod1);
        if(l->addable < INDEXED) {
            reglcgen(&nod, l, Z);
            gopcode(OFUNC, Z, Z, &nod);
            regfree(&nod);
        } else
            gopcode(OFUNC, Z, Z, l);
        if(REGARG >= 0)
            if(o != reg[REGARG])
                reg[REGARG]--;
        if(nn != Z) {
            regret(&nod, n);
            gopcode(OAS, &nod, Z, nn);
            regfree(&nod);
        }
        break;

    case OIND:
        if(nn == Z) {
            nullwarn(l, Z);
            break;
        }
        regialloc(&nod, n, nn);
        r = l;
        while(r->op == OADD)
            r = r->right;
        if(sconst(r) && (v = r->vconst+nod.xoffset) > -4096 && v < 4096) {
            v = r->vconst;
            r->vconst = 0;
            cgen(l, &nod);
            nod.xoffset += v;
            r->vconst = v;
        } else
            cgen(l, &nod);
        regind(&nod, n);
        gopcode(OAS, &nod, Z, nn);
        regfree(&nod);
        break;

    case OEQ:
    case ONE:
    case OLE:
    case OLT:
    case OGE:
    case OGT:
    case OLO:
    case OLS:
    case OHI:
    case OHS:
        if(nn == Z) {
            nullwarn(l, r);
            break;
        }
        boolgen(n, 1, nn);
        break;

    case OANDAND:
    case OOROR:
        boolgen(n, 1, nn);
        if(nn == Z)
            patch(p, pc);
        break;

    case ONOT:
        if(nn == Z) {
            nullwarn(l, Z);
            break;
        }
        boolgen(n, 1, nn);
        break;

    case OCOMMA:
        cgen(l, Z);
        cgen(r, nn);
        break;

    case OCAST:
        if(nn == Z) {
            nullwarn(l, Z);
            break;
        }
        /*
         * convert from types l->n->nn
         */
        if(nocast(l->type, n->type)) {
            if(nocast(n->type, nn->type)) {
                cgen(l, nn);
                break;
            }
        }
        regalloc(&nod, l, nn);
        cgen(l, &nod);
        regalloc(&nod1, n, &nod);
        if(inrel)
            gmover(&nod, &nod1);
        else
            gopcode(OAS, &nod, Z, &nod1);
        gopcode(OAS, &nod1, Z, nn);
        regfree(&nod1);
        regfree(&nod);
        break;

    case ODOT:
        sugen(l, nodrat, l->type->width);
        if(nn != Z) {
            warn(n, "non-interruptable temporary");
            nod = *nodrat;
            if(!r || r->op != OCONST) {
                diag(n, "DOT and no offset");
                break;
            }
            nod.xoffset += (long)r->vconst;
            nod.type = n->type;
            cgen(&nod, nn);
        }
        break;

    case OCOND:
        bcgen(l, 1);
        p1 = p;
        cgen(r->left, nn);
        gbranch(OGOTO);
        patch(p1, pc);
        p1 = p;
        cgen(r->right, nn);
        patch(p1, pc);
        break;

    case OPOSTINC:
    case OPOSTDEC:
        v = 1;
        if(l->type->etype == TIND)
            v = l->type->link->width;
        if(o == OPOSTDEC)
            v = -v;
        if(l->op == OBIT)
            goto bitinc;
        if(nn == Z)
            goto pre;

        if(l->addable < INDEXED)
            reglcgen(&nod2, l, Z);
        else
            nod2 = *l;

        regalloc(&nod, l, nn);
        gopcode(OAS, &nod2, Z, &nod);
        regalloc(&nod1, l, Z);
        if(typefd[l->type->etype]) {
            regalloc(&nod3, l, Z);
            if(v < 0) {
                gopcode(OAS, nodfconst(-v), Z, &nod3);
                gopcode(OSUB, &nod3, &nod, &nod1);
            } else {
                gopcode(OAS, nodfconst(v), Z, &nod3);
                gopcode(OADD, &nod3, &nod, &nod1);
            }
            regfree(&nod3);
        } else
            gopcode(OADD, nodconst(v), &nod, &nod1);
        gopcode(OAS, &nod1, Z, &nod2);

        regfree(&nod);
        regfree(&nod1);
        if(l->addable < INDEXED)
            regfree(&nod2);
        break;

    case OPREINC:
    case OPREDEC:
        v = 1;
        if(l->type->etype == TIND)
            v = l->type->link->width;
        if(o == OPREDEC)
            v = -v;
        if(l->op == OBIT)
            goto bitinc;

    pre:
        if(l->addable < INDEXED)
            reglcgen(&nod2, l, Z);
        else
            nod2 = *l;

        regalloc(&nod, l, nn);
        gopcode(OAS, &nod2, Z, &nod);
        if(typefd[l->type->etype]) {
            regalloc(&nod3, l, Z);
            if(v < 0) {
                gopcode(OAS, nodfconst(-v), Z, &nod3);
                gopcode(OSUB, &nod3, Z, &nod);
            } else {
                gopcode(OAS, nodfconst(v), Z, &nod3);
                gopcode(OADD, &nod3, Z, &nod);
            }
            regfree(&nod3);
        } else
            gopcode(OADD, nodconst(v), Z, &nod);
        gopcode(OAS, &nod, Z, &nod2);
        if(nn && l->op == ONAME)	/* in x=++i, emit USED(i) */
            gins(ANOP, l, Z);

        regfree(&nod);
        if(l->addable < INDEXED)
            regfree(&nod2);
        break;

    bitinc:
        if(nn != Z && (o == OPOSTINC || o == OPOSTDEC)) {
            bitload(l, &nod, &nod1, &nod2, Z);
            gopcode(OAS, &nod, Z, nn);
            gopcode(OADD, nodconst(v), Z, &nod);
            bitstore(l, &nod, &nod1, &nod2, Z);
            break;
        }
        bitload(l, &nod, &nod1, &nod2, nn);
        gopcode(OADD, nodconst(v), Z, &nod);
        bitstore(l, &nod, &nod1, &nod2, nn);
        break;
    }
    cursafe = curs;
    return;
}
@

<<function reglcgen(arm)>>=
void
reglcgen(Node *t, Node *n, Node *nn)
{
    Node *r;
    long v;

    regialloc(t, n, nn);
    if(n->op == OIND) {
        r = n->left;
        while(r->op == OADD)
            r = r->right;
        if(sconst(r) && (v = r->vconst+t->xoffset) > -4096 && v < 4096) {
            v = r->vconst;
            r->vconst = 0;
            lcgen(n, t);
            t->xoffset += v;
            r->vconst = v;
            regind(t, n);
            return;
        }
    } else if(n->op == OINDREG) {
        if((v = n->xoffset) > -4096 && v < 4096) {
            n->op = OREGISTER;
            cgen(n, t);
            t->xoffset += v;
            n->op = OINDREG;
            regind(t, n);
            return;
        }
    }
    lcgen(n, t);
    regind(t, n);
}
@

<<function reglpcgen(arm)>>=
void
reglpcgen(Node *n, Node *nn, int f)
{
    Type *t;

    t = nn->type;
    nn->type = types[TLONG];
    if(f)
        reglcgen(n, nn, Z);
    else {
        regialloc(n, nn, Z);
        lcgen(nn, n);
        regind(n, nn);
    }
    nn->type = t;
}
@

<<function lcgen(arm)>>=
void
lcgen(Node *n, Node *nn)
{
    Prog *p1;
    Node nod;

    if(debug['g']) {
        prtree(nn, "lcgen lhs");
        prtree(n, "lcgen");
    }
    if(n == Z || n->type == T)
        return;
    if(nn == Z) {
        nn = &nod;
        regalloc(&nod, n, Z);
    }
    switch(n->op) {
    default:
        if(n->addable < INDEXED) {
            diag(n, "unknown op in lcgen: %O", n->op);
            break;
        }
        nod = *n;
        nod.op = OADDR;
        nod.left = n;
        nod.right = Z;
        nod.type = types[TIND];
        gopcode(OAS, &nod, Z, nn);
        break;

    case OCOMMA:
        cgen(n->left, n->left);
        lcgen(n->right, nn);
        break;

    case OIND:
        cgen(n->left, nn);
        break;

    case OCOND:
        bcgen(n->left, 1);
        p1 = p;
        lcgen(n->right->left, nn);
        gbranch(OGOTO);
        patch(p1, pc);
        p1 = p;
        lcgen(n->right->right, nn);
        patch(p1, pc);
        break;
    }
}
@

<<function bcgen(arm)>>=
void
bcgen(Node *n, int true)
{

    if(n->type == T)
        gbranch(OGOTO);
    else
        boolgen(n, true, Z);
}
@

<<function boolgen(arm)>>=
void
boolgen(Node *n, int true, Node *nn)
{
    int o;
    Prog *p1, *p2;
    Node *l, *r, nod, nod1;
    long curs;

    if(debug['g']) {
        prtree(nn, "boolgen lhs");
        prtree(n, "boolgen");
    }
    curs = cursafe;
    l = n->left;
    r = n->right;
    switch(n->op) {

    default:
        regalloc(&nod, n, nn);
        cgen(n, &nod);
        o = ONE;
        if(true)
            o = comrel[relindex(o)];
        if(typefd[n->type->etype]) {
            gopcode(true ? o | BTRUE : o, nodfconst(0), &nod, Z);
        } else
            gopcode(o, nodconst(0), &nod, Z);
        regfree(&nod);
        goto com;

    case OCONST:
        o = vconst(n);
        if(!true)
            o = !o;
        gbranch(OGOTO);
        if(o) {
            p1 = p;
            gbranch(OGOTO);
            patch(p1, pc);
        }
        goto com;

    case OCOMMA:
        cgen(l, Z);
        boolgen(r, true, nn);
        break;

    case ONOT:
        boolgen(l, !true, nn);
        break;

    case OCOND:
        bcgen(l, 1);
        p1 = p;
        bcgen(r->left, true);
        p2 = p;
        gbranch(OGOTO);
        patch(p1, pc);
        p1 = p;
        bcgen(r->right, !true);
        patch(p2, pc);
        p2 = p;
        gbranch(OGOTO);
        patch(p1, pc);
        patch(p2, pc);
        goto com;

    case OANDAND:
        if(!true)
            goto caseor;

    caseand:
        bcgen(l, true);
        p1 = p;
        bcgen(r, !true);
        p2 = p;
        patch(p1, pc);
        gbranch(OGOTO);
        patch(p2, pc);
        goto com;

    case OOROR:
        if(!true)
            goto caseand;

    caseor:
        bcgen(l, !true);
        p1 = p;
        bcgen(r, !true);
        p2 = p;
        gbranch(OGOTO);
        patch(p1, pc);
        patch(p2, pc);
        goto com;

    case OEQ:
    case ONE:
    case OLE:
    case OLT:
    case OGE:
    case OGT:
    case OHI:
    case OHS:
    case OLO:
    case OLS:
        o = n->op;
        if(true)
            o = comrel[relindex(o)];
        if(l->complex >= FNX && r->complex >= FNX) {
            regret(&nod, r);
            cgenrel(r, &nod, 1);
            regsalloc(&nod1, r);
            gopcode(OAS, &nod, Z, &nod1);
            regfree(&nod);
            nod = *n;
            nod.right = &nod1;
            boolgen(&nod, true, nn);
            break;
        }
        if(sconst(l)) {
            regalloc(&nod, r, nn);
            cgenrel(r, &nod, 1);
            o = invrel[relindex(o)];
            gopcode(true ? o | BTRUE : o, l, &nod, Z);
            regfree(&nod);
            goto com;
        }
        if(sconst(r)) {
            regalloc(&nod, l, nn);
            cgenrel(l, &nod, 1);
            gopcode(true ? o | BTRUE : o, r, &nod, Z);
            regfree(&nod);
            goto com;
        }
        if(l->complex >= r->complex) {
            regalloc(&nod1, l, nn);
            cgenrel(l, &nod1, 1);
            regalloc(&nod, r, Z);
            cgenrel(r, &nod, 1);
        } else {
            regalloc(&nod, r, nn);
            cgenrel(r, &nod, 1);
            regalloc(&nod1, l, Z);
            cgenrel(l, &nod1, 1);
        }
        gopcode(true ? o | BTRUE : o, &nod, &nod1, Z);
        regfree(&nod);
        regfree(&nod1);

    com:
        if(nn != Z) {
            p1 = p;
            gopcode(OAS, nodconst(1), Z, nn);
            gbranch(OGOTO);
            p2 = p;
            patch(p1, pc);
            gopcode(OAS, nodconst(0), Z, nn);
            patch(p2, pc);
        }
        break;
    }
    cursafe = curs;
}
@

<<function sugen(arm)>>=
void
sugen(Node *n, Node *nn, long w)
{
    Prog *p1;
    Node nod0, nod1, nod2, nod3, nod4, *l, *r;
    Type *t;
    long pc1;
    int i, m, c;

    if(n == Z || n->type == T)
        return;
    if(debug['g']) {
        prtree(nn, "sugen lhs");
        prtree(n, "sugen");
    }
    if(nn == nodrat)
        if(w > nrathole)
            nrathole = w;
    switch(n->op) {
    case OIND:
        if(nn == Z) {
            nullwarn(n->left, Z);
            break;
        }

    default:
        goto copy;

    case OCONST:
        if(n->type && typev[n->type->etype]) {
            if(nn == Z) {
                nullwarn(n->left, Z);
                break;
            }

            t = nn->type;
            nn->type = types[TLONG];
            reglcgen(&nod1, nn, Z);
            nn->type = t;

            if(align(0, types[TCHAR], Aarg1))	/* isbigendian */
                gopcode(OAS, nod32const(n->vconst>>32), Z, &nod1);
            else
                gopcode(OAS, nod32const(n->vconst), Z, &nod1);
            nod1.xoffset += SZ_LONG;
            if(align(0, types[TCHAR], Aarg1))	/* isbigendian */
                gopcode(OAS, nod32const(n->vconst), Z, &nod1);
            else
                gopcode(OAS, nod32const(n->vconst>>32), Z, &nod1);

            regfree(&nod1);
            break;
        }
        goto copy;

    case ODOT:
        l = n->left;
        sugen(l, nodrat, l->type->width);
        if(nn != Z) {
            warn(n, "non-interruptable temporary");
            nod1 = *nodrat;
            r = n->right;
            if(!r || r->op != OCONST) {
                diag(n, "DOT and no offset");
                break;
            }
            nod1.xoffset += (long)r->vconst;
            nod1.type = n->type;
            sugen(&nod1, nn, w);
        }
        break;

    case OSTRUCT:
        /*
         * rewrite so lhs has no fn call
         */
        if(nn != Z && nn->complex >= FNX) {
            nod1 = *n;
            nod1.type = typ(TIND, n->type);
            regret(&nod2, &nod1);
            lcgen(nn, &nod2);
            regsalloc(&nod0, &nod1);
            gopcode(OAS, &nod2, Z, &nod0);
            regfree(&nod2);

            nod1 = *n;
            nod1.op = OIND;
            nod1.left = &nod0;
            nod1.right = Z;
            nod1.complex = 1;

            sugen(n, &nod1, w);
            return;
        }

        r = n->left;
        for(t = n->type->link; t != T; t = t->down) {
            l = r;
            if(r->op == OLIST) {
                l = r->left;
                r = r->right;
            }
            if(nn == Z) {
                cgen(l, nn);
                continue;
            }
            /*
             * hand craft *(&nn + o) = l
             */
            nod0 = znode;
            nod0.op = OAS;
            nod0.type = t;
            nod0.left = &nod1;
            nod0.right = l;

            nod1 = znode;
            nod1.op = OIND;
            nod1.type = t;
            nod1.left = &nod2;

            nod2 = znode;
            nod2.op = OADD;
            nod2.type = typ(TIND, t);
            nod2.left = &nod3;
            nod2.right = &nod4;

            nod3 = znode;
            nod3.op = OADDR;
            nod3.type = nod2.type;
            nod3.left = nn;

            nod4 = znode;
            nod4.op = OCONST;
            nod4.type = nod2.type;
            nod4.vconst = t->offset;

            ccom(&nod0);
            acom(&nod0);
            xcom(&nod0);
            nod0.addable = 0;

            cgen(&nod0, Z);
        }
        break;

    case OAS:
        if(nn == Z) {
            if(n->addable < INDEXED)
                sugen(n->right, n->left, w);
            break;
        }
        sugen(n->right, nodrat, w);
        warn(n, "non-interruptable temporary");
        sugen(nodrat, n->left, w);
        sugen(nodrat, nn, w);
        break;

    case OFUNC:
        if(nn == Z) {
            sugen(n, nodrat, w);
            break;
        }
        if(nn->op != OIND) {
            nn = new1(OADDR, nn, Z);
            nn->type = types[TIND];
            nn->addable = 0;
        } else
            nn = nn->left;
        n = new(OFUNC, n->left, new(OLIST, nn, n->right));
        n->type = types[TVOID];
        n->left->type = types[TVOID];
        cgen(n, Z);
        break;

    case OCOND:
        bcgen(n->left, 1);
        p1 = p;
        sugen(n->right->left, nn, w);
        gbranch(OGOTO);
        patch(p1, pc);
        p1 = p;
        sugen(n->right->right, nn, w);
        patch(p1, pc);
        break;

    case OCOMMA:
        cgen(n->left, Z);
        sugen(n->right, nn, w);
        break;
    }
    return;

copy:
    if(nn == Z)
        return;
    if(n->complex >= FNX && nn->complex >= FNX) {
        t = nn->type;
        nn->type = types[TLONG];
        regialloc(&nod1, nn, Z);
        lcgen(nn, &nod1);
        regsalloc(&nod2, nn);
        nn->type = t;

        gopcode(OAS, &nod1, Z, &nod2);
        regfree(&nod1);

        nod2.type = typ(TIND, t);

        nod1 = nod2;
        nod1.op = OIND;
        nod1.left = &nod2;
        nod1.right = Z;
        nod1.complex = 1;
        nod1.type = t;

        sugen(n, &nod1, w);
        return;
    }

    w /= SZ_LONG;
    if(w <= 2) {
        if(n->complex > nn->complex) {
            reglpcgen(&nod1, n, 1);
            reglpcgen(&nod2, nn, 1);
        } else {
            reglpcgen(&nod2, nn, 1);
            reglpcgen(&nod1, n, 1);
        }
        regalloc(&nod3, &regnode, Z);
        regalloc(&nod4, &regnode, Z);
        if(nod3.reg > nod4.reg){
            /* code below assumes nod3 loaded first */
            Node t = nod3; nod3 = nod4; nod4 = t;
        }
        nod0 = *nodconst((1<<nod3.reg)|(1<<nod4.reg));
        if(w == 2 && nod1.xoffset == 0)
            gmovm(&nod1, &nod0, 0);
        else {
            gmove(&nod1, &nod3);
            if(w == 2) {
                nod1.xoffset += SZ_LONG;
                gmove(&nod1, &nod4);
            }
        }
        if(w == 2 && nod2.xoffset == 0)
            gmovm(&nod0, &nod2, 0);
        else {
            gmove(&nod3, &nod2);
            if(w == 2) {
                nod2.xoffset += SZ_LONG;
                gmove(&nod4, &nod2);
            }
        }
        regfree(&nod1);
        regfree(&nod2);
        regfree(&nod3);
        regfree(&nod4);
        return;
    }

    if(n->complex > nn->complex) {
        reglpcgen(&nod1, n, 0);
        reglpcgen(&nod2, nn, 0);
    } else {
        reglpcgen(&nod2, nn, 0);
        reglpcgen(&nod1, n, 0);
    }

    m = 0;
    for(c = 0; c < w && c < 4; c++) {
        i = tmpreg();
        if (i == 0)
            break;
        reg[i]++;
        m |= 1<<i;
    }
    nod4 = *(nodconst(m));
    if(w < 3*c) {
        for (; w>c; w-=c) {
            gmovm(&nod1, &nod4, 1);
            gmovm(&nod4, &nod2, 1);
        }
        goto out;
    }

    regalloc(&nod3, &regnode, Z);
    gopcode(OAS, nodconst(w/c), Z, &nod3);
    w %= c;
    
    pc1 = pc;
    gmovm(&nod1, &nod4, 1);
    gmovm(&nod4, &nod2, 1);

    gopcode(OSUB, nodconst(1), Z, &nod3);
    gopcode(OEQ, nodconst(0), &nod3, Z);
    p->as = ABGT;
    patch(p, pc1);
    regfree(&nod3);

out:
    if (w) {
        i = 0;
        while (c>w) {
            while ((m&(1<<i)) == 0)
                i++;
            m &= ~(1<<i);
            reg[i] = 0;
            c--;
            i++;
        }
        nod4.vconst = m;
        gmovm(&nod1, &nod4, 0);
        gmovm(&nod4, &nod2, 0);
    }
    i = 0;
    do {
        while ((m&(1<<i)) == 0)
            i++;
        reg[i] = 0;
        c--;
        i++;
    } while (c>0);
    regfree(&nod1);
    regfree(&nod2);
}
@


%-------------------------------------------------------------

<<5c/cgen.c>>=
#include "gc.h"

<<function cgen(arm)>>

<<function cgenrel(arm)>>

<<function reglcgen(arm)>>

<<function reglpcgen(arm)>>

<<function lcgen(arm)>>

<<function bcgen(arm)>>

<<function boolgen(arm)>>

<<function sugen(arm)>>
@




\section{[[8c/]]}

\subsection*{[[8c/gc.h]]}


<<constant FNX (8c/gc.h)>>=
#define	FNX		100
@

<<struct Idx(x86)>>=
struct Idx
{
    Node*	regtree;
    Node*	basetree;
    short	scale;
    short	reg;
    short	ptr;
};
@


<<constant INDEXED(x86)>>=
#define	INDEXED	9
@







<<constant NRGN(x86)>>=
#define	NRGN	600
@

<<struct Rgn(x86)>>=
struct	Rgn
{
    Reg*	enter;
    short	cost;
    short	varno;
    short	regno;
};
@


<<function LOAD(x86)>>=
#define	LOAD(r)		(~r->refbehind.b[z] & r->refahead.b[z])
@

<<function STORE(x86)>>=
#define	STORE(r)	(~r->calbehind.b[z] & r->calahead.b[z])
@

<<macro bset(x86)>>=
//@Scheck: maybe dead, dupe with bits.c function
#define	bset(a,n)	((a).b[(n)/32]&(1L<<(n)%32))
@

<<constant CLOAD(x86)>>=
#define	CLOAD	5
@

<<constant CREF(x86)>>=
#define	CREF	5
@

<<constant CINF(x86)>>=
#define	CINF	1000
@

<<constant LOOP(x86)>>=
#define	LOOP	3
@

<<constant D_HI(x86)>>=
//#define	D_HI	D_NONE
@

<<constant D_LO(x86)>>=
//#define	D_LO	D_NONE
@

<<constant rplink>>=
/* wrecklessly steal a field */

#define	rplink	label
@

%<<function BLOAD>>=
%//#define	BLOAD(r)	band(bnot(r->refbehind), r->refahead)
%@
%
%<<function BSTORE>>=
%//#define	BSTORE(r)	band(bnot(r->calbehind), r->calahead)
%@


%-------------------------------------------------------------

<<8c/gc.h>>=
#include	"../cc/cc.h"

#include	<common.out.h>
#include	<386/8.out.h>

<<constant SZ_CHAR(x86)>>
<<constant SZ_SHORT(x86)>>
<<constant SZ_INT(x86)>>
<<constant SZ_LONG(x86)>>
<<constant SZ_IND(x86)>>
<<constant SZ_FLOAT(x86)>>
<<constant SZ_VLONG(x86)>>
<<constant SZ_DOUBLE(x86)>>
<<constant FNX (8c/gc.h)>>

typedef	struct	Adr	Adr;
typedef	struct	Prog	Prog;
typedef	struct	Case	Case;
typedef	struct	C1	C1;
typedef	struct	Var	Var;
typedef	struct	Reg	Reg;
typedef	struct	Rgn	Rgn;

<<struct Idx(x86)>>
extern struct Idx idx;

<<struct Adr(x86)>>
<<constant A(x86)>>

<<constant INDEXED(x86)>>
<<struct Prog(x86)>>
<<constant P(x86)>>

<<struct Case(x86)>>
<<constant C(x86)>>

<<struct C1(x86)>>

<<struct Var(x86)>>

<<struct Reg(x86)>>
<<constant R(x86)>>

<<constant NRGN(x86)>>
<<struct Rgn(x86)>>

extern	long	breakpc;
extern	long	nbreak;
extern	Case*	cases;
extern	Node	constnode;
extern	Node	fconstnode;
extern	long	continpc;
extern	long	curarg;
extern	long	cursafe;
extern	Prog*	firstp;
extern	Prog*	lastp;
extern	long	maxargsafe;
extern	int	mnstring;
extern	Node*	nodrat;
extern	Node*	nodret;
extern	Node*	nodsafe;
extern	long	nrathole;
extern	long	nstring;
extern	Prog*	p;
extern	long	pc;
extern	Node	regnode;
extern	Node	fregnode0;
extern	Node	fregnode1;
extern	char	string[NSNAME];
extern	Sym*	symrathole;
extern	Node	znode;
extern	Prog	zprog;
extern	int	reg[D_NONE];
extern	long	exregoffset;
extern	long	exfregoffset;

<<function LOAD(x86)>>
<<function STORE(x86)>>

<<macro bset(x86)>>

<<constant CLOAD(x86)>>
<<constant CREF(x86)>>
<<constant CINF(x86)>>
<<constant LOOP(x86)>>

extern	Rgn	region[NRGN];
extern	Rgn*	rgp;
extern	int	nregion;
extern	int	nvar;

extern	Bits	externs;
extern	Bits	params;
extern	Bits	consts;
extern	Bits	addrs;

extern	long	regbits;
//extern	long	exregbits;

extern	int	change;
extern	int	suppress;

extern	Reg*	firstr;
extern	Reg*	lastr;
extern	Reg	zreg;
extern	Reg*	freer;
extern	Var	var[NVAR];
extern	long*	idom;
extern	Reg**	rpo2r;
extern	long	maxnr;

extern	char*	anames[];

/*
 * sgen.c
 */
void	codgen(Node*, Node*);
void	noretval(int);
void	xcom(Node*);

/*
 * cgen.c
 */
void	zeroregm(Node*);
void	cgen(Node*, Node*);
void	reglcgen(Node*, Node*, Node*);
void	lcgen(Node*, Node*);
void	boolgen(Node*, int, Node*);
void	sugen(Node*, Node*, long);
//int	needreg(Node*, int);

/*
 * cgen64.c
 */
int	vaddr(Node*, int);
void	loadpair(Node*, Node*);
int	cgen64(Node*, Node*);
void	testv(Node*, int);
Node*	hi64(Node*);
Node*	lo64(Node*);

/*
 * txt.c
 */
void	ginit(void);
void	gclean(void);
void	gargs(Node*, Node*, Node*);
Node*	nodconst(long);
int	nareg(int);
int	nodreg(Node*, Node*, int);
int	isreg(Node*, int);
void	regret(Node*, Node*);
void	regalloc(Node*, Node*, Node*);
void	regfree(Node*);
void	regialloc(Node*, Node*, Node*);
void	regsalloc(Node*, Node*);
void	regind(Node*, Node*);
void	gmove(Node*, Node*);
void	gins(int a, Node*, Node*);
void	fgopcode(int, Node*, Node*, int, int);
void	gopcode(int, Type*, Node*, Node*);
void	gbranch(int);
void	patch(Prog*, long);
int	sconst(Node*);
void	gpseudo(int, Sym*, Node*);
//void	gprep(Node*, Node*);

/*
 * swt.c
 */
void	doswit(Node*);
void	swit1(C1*, int, long, Node*);
void	casf(void);
void	bitload(Node*, Node*, Node*, Node*, Node*);
void	bitstore(Node*, Node*, Node*, Node*, Node*);
long	outstring(char*, long);
void	nullwarn(Node*, Node*);
void	gextern(Sym*, Node*, long, long);
void	outcode(void);
void	ieeedtod(Ieee*, double);

/*
 * list
 */
void	listinit(void);

/*
 * reg.c
 */
Reg*	rega(void);
void	regopt(Prog*);


/*
 * peep.c
 */
void	peep(void);
void	excise(Reg*);
int	copyu(Prog*, Adr*, Adr*);



<<constant D_HI(x86)>>
<<constant D_LO(x86)>>

/*
 * com64
 */
int	cond(int);
int	com64(Node*);
void	com64init(void);
void	bool64(Node*);

/*
 * div/mul
 */
void	sdivgen(Node*, Node*, Node*, Node*);
void	udivgen(Node*, Node*, Node*, Node*);
void	sdiv2(long, int, Node*, Node*);
void	smod2(long, int, Node*, Node*);
void	mulgen(Type*, Node*, Node*);
void	genmuladd(Node*, Node*, int, Node*);
void	shiftit(Type*, Node*, Node*);

#pragma	varargck	type	"A"	int
#pragma	varargck	type	"B"	Bits
#pragma	varargck	type	"D"	Adr*
#pragma	varargck	type	"P"	Prog*
#pragma	varargck	type	"R"	int
#pragma	varargck	type	"S"	char*

@


\subsection*{[[8c/globals2.c]]}

<<global idx(x86)>>=
struct Idx idx;
@

<<global breakpc(x86)>>=
long	breakpc;
@

<<global nbreak(x86)>>=
long	nbreak;
@


<<global constnode(x86)>>=
Node	constnode;
@

<<global fconstnode(x86)>>=
Node	fconstnode;
@

<<global continpc(x86)>>=
long	continpc;
@





<<global mnstring(x86)>>=
int	mnstring;
@

<<global nodrat(x86)>>=
Node*	nodrat;
@


<<global nodsafe(x86)>>=
Node*	nodsafe;
@

<<global nrathole(x86)>>=
long	nrathole;
@

<<global nstring(x86)>>=
long	nstring;
@



<<global regnode(x86)>>=
Node	regnode;
@

<<global fregnode0(x86)>>=
Node	fregnode0;
@

<<global fregnode1(x86)>>=
Node	fregnode1;
@

<<global string(x86)>>=
char	string[NSNAME];
@

<<global symrathole(x86)>>=
Sym*	symrathole;
@

<<global znode(x86)>>=
Node	znode;
@


<<global reg(x86)>>=
int	reg[D_NONE];
@

<<global exregoffset(x86)>>=
long	exregoffset;
@

<<global exfregoffset(x86)>>=
long	exfregoffset;
@

<<global region(x86)>>=
Rgn	region[NRGN];
@

<<global rgp(x86)>>=
Rgn*	rgp;
@

<<global nregion(x86)>>=
int	nregion;
@


<<global externs(x86)>>=
Bits	externs;
@

<<global params(x86)>>=
Bits	params;
@

<<global consts(x86)>>=
Bits	consts;
@

<<global addrs(x86)>>=
Bits	addrs;
@

<<global regbits(x86)>>=
long	regbits;
@

<<global exregbits(x86)>>=
//long	exregbits;
@

<<global change(x86)>>=
int	change;
@

<<global suppress(x86)>>=
int	suppress;
@

<<global firstr(x86)>>=
Reg*	firstr;
@

<<global lastr(x86)>>=
Reg*	lastr;
@

<<global zreg(x86)>>=
Reg	zreg;
@

<<global freer(x86)>>=
Reg*	freer;
@


<<global idom(x86)>>=
long*	idom;
@

<<global rpo2r(x86)>>=
Reg**	rpo2r;
@

<<global maxnr(x86)>>=
long	maxnr;
@


%-------------------------------------------------------------

<<8c/globals2.c>>=
#include "gc.h"

<<global idx(x86)>>

<<global breakpc(x86)>>
<<global nbreak(x86)>>
<<global cases(x86)>>
<<global constnode(x86)>>
<<global fconstnode(x86)>>
<<global continpc(x86)>>
<<global curarg(x86)>>
<<global cursafe(x86)>>
<<global firstp(x86)>>
<<global lastp(x86)>>
<<global maxargsafe(x86)>>
<<global mnstring(x86)>>
<<global nodrat(x86)>>
<<global nodret(x86)>>
<<global nodsafe(x86)>>
<<global nrathole(x86)>>
<<global nstring(x86)>>
<<global p(x86)>>
<<global pc(x86)>>
<<global regnode(x86)>>
<<global fregnode0(x86)>>
<<global fregnode1(x86)>>
<<global string(x86)>>
<<global symrathole(x86)>>
<<global znode(x86)>>
<<global zprog(x86)>>
<<global reg(x86)>>
<<global exregoffset(x86)>>
<<global exfregoffset(x86)>>

<<global region(x86)>>
<<global rgp(x86)>>
<<global nregion(x86)>>
<<global nvar(x86)>>

<<global externs(x86)>>
<<global params(x86)>>
<<global consts(x86)>>
<<global addrs(x86)>>

<<global regbits(x86)>>
<<global exregbits(x86)>>

<<global change(x86)>>
<<global suppress(x86)>>

<<global firstr(x86)>>
<<global lastr(x86)>>
<<global zreg(x86)>>
<<global freer(x86)>>
<<global var(x86)>>
<<global idom(x86)>>
<<global rpo2r(x86)>>
<<global maxnr(x86)>>
@


\subsection*{[[8c/machcap.c]]}

<<function machcap(x86)>>=
bool
machcap(Node *n)
{
//	return false;

    if(n == Z)
        return true;	/* test */

    switch(n->op) {
    case OMUL:
    case OLMUL:
    case OASMUL:
    case OASLMUL:
        if(typechl[n->type->etype])
            return true;
        if(typev[n->type->etype]) {
//		if(typev[n->type->etype] && n->right->op == OCONST) {
//			if(hi64v(n->right) == 0)
                return true;
        }
        break;

    case OCOM:
    case ONEG:
    case OADD:
    case OAND:
    case OOR:
    case OSUB:
    case OXOR:
    case OASHL:
    case OLSHR:
    case OASHR:
        if(typechlv[n->left->type->etype])
            return true;
        break;

    case OCAST:
        if(typev[n->type->etype]) {
            if(typechlp[n->left->type->etype])
                return true;
        }
        else if(!typefd[n->type->etype]) {
            if(typev[n->left->type->etype])
                return true;
        }
        break;

    case OCOND:
    case OCOMMA:
    case OLIST:
    case OANDAND:
    case OOROR:
    case ONOT:
    case ODOT:
        return true;

    case OASADD:
    case OASSUB:
    case OASAND:
    case OASOR:
    case OASXOR:
        return true;

    case OASASHL:
    case OASASHR:
    case OASLSHR:
        return true;

    case OPOSTINC:
    case OPOSTDEC:
    case OPREINC:
    case OPREDEC:
        return true;

    case OEQ:
    case ONE:
    case OLE:
    case OGT:
    case OLT:
    case OGE:
    case OHI:
    case OHS:
    case OLO:
    case OLS:
//print("%O\n", n->op);
        return true;
    }
    return false;
}
@


%-------------------------------------------------------------

<<8c/machcap.c>>=
#include "gc.h"

<<function machcap(x86)>>
@


\subsection*{[[8c/enam.c]]}

%-------------------------------------------------------------

<<8c/enam.c>>=
<<global anames(x86)>>
@


\subsection*{[[8c/list.c]]}

%-------------------------------------------------------------

<<8c/list.c>>=
#include "gc.h"

int	Pconv(Fmt*);
int	Aconv(Fmt*);
int	Dconv(Fmt*);
int	Sconv(Fmt*);
int	Rconv(Fmt*);
int	Bconv(Fmt*);

<<function listinit(x86)>>

<<function Bconv(x86)>>

<<function Pconv(x86)>>

<<function Aconv(x86)>>

<<function Dconv(x86)>>

<<global regstr(x86)>>

<<function Rconv(x86)>>

<<function Sconv(x86)>>
@


\subsection*{[[8c/txt.c]]}

<<function ginit(x86)>>=
void
ginit(void)
{
    int i;
    Type *t;

    thechar = '8';
    thestring = "386";

    exregoffset = 0;
    exfregoffset = 0;
    listinit();

    nstring = 0;
    mnstring = 0;
    nrathole = 0;
    pc = 0;
    breakpc = -1;
    continpc = -1;
    cases = C;
    firstp = P;
    lastp = P;
    tfield = types[TLONG];

    typeswitch = typechlv;

    zprog.link = P;
    zprog.as = AGOK;
    zprog.from.type = D_NONE;
    zprog.from.index = D_NONE;
    zprog.from.scale = 0;
    zprog.to = zprog.from;

    regnode.op = OREGISTER;
    regnode.class = CEXREG;
    regnode.reg = REGTMP;
    regnode.complex = 0;
    regnode.addable = 11;
    regnode.type = types[TLONG];

    fregnode0 = regnode;
    fregnode0.reg = D_F0;
    fregnode0.type = types[TDOUBLE];

    fregnode1 = fregnode0;
    fregnode1.reg = D_F0+1;

    constnode.op = OCONST;
    constnode.class = CXXX;
    constnode.complex = 0;
    constnode.addable = 20;
    constnode.type = types[TLONG];

    fconstnode.op = OCONST;
    fconstnode.class = CXXX;
    fconstnode.complex = 0;
    fconstnode.addable = 20;
    fconstnode.type = types[TDOUBLE];

    nodsafe = new(ONAME, Z, Z);
    nodsafe->sym = slookup(".safe");
    nodsafe->type = types[TINT];
    nodsafe->etype = types[TINT]->etype;
    nodsafe->class = CAUTO;
    complex(nodsafe);

    t = typ(TARRAY, types[TCHAR]);
    symrathole = slookup(".rathole");
    symrathole->class = CGLOBL;
    symrathole->type = t;

    nodrat = new(ONAME, Z, Z);
    nodrat->sym = symrathole;
    nodrat->type = types[TIND];
    nodrat->etype = TVOID;
    nodrat->class = CGLOBL;
    complex(nodrat);
    nodrat->type = t;

    nodret = new(ONAME, Z, Z);
    nodret->sym = slookup(".ret");
    nodret->type = types[TIND];
    nodret->etype = TIND;
    nodret->class = CPARAM;
    nodret = new(OIND, nodret, Z);
    complex(nodret);

    com64init();

    for(i=0; i<nelem(reg); i++) {
        reg[i] = 1;
        if(i >= D_AX && i <= D_DI && i != D_SP)
            reg[i] = 0;
    }
}
@

<<function gclean(x86)>>=
void
gclean(void)
{
    int i;
    Sym *s;

    reg[D_SP]--;
    for(i=D_AX; i<=D_DI; i++)
        if(reg[i])
            diag(Z, "reg %R left allocated", i);
    while(mnstring)
        outstring("", 1L);

    symstring->type->width = nstring;
    symrathole->type->width = nrathole;

    for(i=0; i<NHASH; i++)
     for(s = hash[i]; s != S; s = s->link) {
        if(s->type == T)
            continue;
        if(s->type->width == 0)
            continue;
        if(s->class != CGLOBL && s->class != CSTATIC)
            continue;
        if(s->type == types[TENUM])
            continue;
        gpseudo(AGLOBL, s, nodconst(s->type->width));
    }
    nextpc();
    p->as = AEND;
    outcode(); // !!!!!!
}
@


<<function gargs(x86)>>=
void
gargs(Node *n, Node *tn1, Node *tn2)
{
    long regs;
    Node fnxargs[20], *fnxp;

    regs = cursafe;

    fnxp = fnxargs;
    garg1(n, tn1, tn2, 0, &fnxp);	/* compile fns to temps */

    curarg = 0;
    fnxp = fnxargs;
    garg1(n, tn1, tn2, 1, &fnxp);	/* compile normal args and temps */

    cursafe = regs;
}
@

<<function nareg(x86)>>=
int
nareg(int notbp)
{
    int i, n;

    n = 0;
    for(i=D_AX; i<=D_DI; i++)
        if(reg[i] == 0)
            n++;
    if(notbp && reg[D_BP] == 0)
        n--;
    return n;
}
@

<<function garg1(x86)>>=
void
garg1(Node *n, Node *tn1, Node *tn2, int f, Node **fnxp)
{
    Node nod;

    if(n == Z)
        return;
    if(n->op == OLIST) {
        garg1(n->left, tn1, tn2, f, fnxp);
        garg1(n->right, tn1, tn2, f, fnxp);
        return;
    }
    if(f == 0) {
        if(n->complex >= FNX) {
            regsalloc(*fnxp, n);
            nod = znode;
            nod.op = OAS;
            nod.left = *fnxp;
            nod.right = n;
            nod.type = n->type;
            cgen(&nod, Z);
            (*fnxp)++;
        }
        return;
    }
    if(typesu[n->type->etype] || typev[n->type->etype]) {
        regaalloc(tn2, n);
        if(n->complex >= FNX) {
            sugen(*fnxp, tn2, n->type->width);
            (*fnxp)++;
        } else
            sugen(n, tn2, n->type->width);
        return;
    }
    if(REGARG>=0 && curarg == 0 && typeilp[n->type->etype]) {
        regaalloc1(tn1, n);
        if(n->complex >= FNX) {
            cgen(*fnxp, tn1);
            (*fnxp)++;
        } else
            cgen(n, tn1);
        return;
    }
    if(vconst(n) == 0) {
        regaalloc(tn2, n);
        gmove(n, tn2);
        return;
    }
    regalloc(tn1, n, Z);
    if(n->complex >= FNX) {
        cgen(*fnxp, tn1);
        (*fnxp)++;
    } else
        cgen(n, tn1);
    regaalloc(tn2, n);
    gmove(tn1, tn2);
    regfree(tn1);
}
@

<<function nodconst(x86)>>=
Node*
nodconst(long v)
{
    constnode.vconst = v;
    return &constnode;
}
@

<<function nodfconst(x86)>>=
Node*
nodfconst(double d)
{
    fconstnode.fconst = d;
    return &fconstnode;
}
@

<<function isreg(x86)>>=
int
isreg(Node *n, int r)
{

    if(n->op == OREGISTER)
        if(n->reg == r)
            return 1;
    return 0;
}
@

<<function nodreg(x86)>>=
int
nodreg(Node *n, Node *nn, int r)
{

    *n = regnode;
    n->reg = r;
    if(reg[r] == 0)
        return 0;
    if(nn != Z) {
        n->type = nn->type;
        n->lineno = nn->lineno;
        if(nn->op == OREGISTER)
        if(nn->reg == r)
            return 0;
    }
    return 1;
}
@

<<function regret(x86)>>=
void
regret(Node *n, Node *nn)
{
    int r;

    r = REGRET;
    if(typefd[nn->type->etype])
        r = FREGRET;
    nodreg(n, nn, r);
    reg[r]++;
}
@

<<function regalloc(x86)>>=
void
regalloc(Node *n, Node *tn, Node *o)
{
    int i;

    switch(tn->type->etype) {
    case TCHAR:
    case TUCHAR:
    case TSHORT:
    case TUSHORT:
    case TINT:
    case TUINT:
    case TLONG:
    case TULONG:
    case TIND:
        if(o != Z && o->op == OREGISTER) {
            i = o->reg;
            if(i >= D_AX && i <= D_DI)
                goto out;
        }
        for(i=D_AX; i<=D_DI; i++)
            if(reg[i] == 0)
                goto out;
        diag(tn, "out of fixed registers");
abort();
        goto err;

    case TFLOAT:
    case TDOUBLE:
        i = D_F0;
        goto out;

    case TVLONG:
    case TUVLONG:
        n->op = OREGPAIR;
        n->complex = 0; /* already in registers */
        n->addable = 11;
        n->type = tn->type;
        n->lineno = nearln;
        n->left = alloc(sizeof(Node));
        n->right = alloc(sizeof(Node));
        if(o != Z && o->op == OREGPAIR) {
            regalloc(n->left, &regnode, o->left);
            regalloc(n->right, &regnode, o->right);
        } else {
            regalloc(n->left, &regnode, Z);
            regalloc(n->right, &regnode, Z);
        }
        n->right->type = types[TULONG];
        if(tn->type->etype == TUVLONG)
            n->left->type = types[TULONG];
        return;
    }
    diag(tn, "unknown type in regalloc: %T", tn->type);
err:
    i = 0;
out:
    if(i)
        reg[i]++;
    nodreg(n, tn, i);
//print("+ %R %d\n", i, reg[i]);
}
@

<<function regialloc(x86)>>=
void
regialloc(Node *n, Node *tn, Node *o)
{
    Node nod;

    nod = *tn;
    nod.type = types[TIND];
    regalloc(n, &nod, o);
}
@

<<function regfree(x86)>>=
void
regfree(Node *n)
{
    int i;

    if(n->op == OREGPAIR) {
        regfree(n->left);
        regfree(n->right);
        return;
    }

    i = 0;
    if(n->op != OREGISTER && n->op != OINDREG)
        goto err;
    i = n->reg;
    if(i < 0 || i >= sizeof(reg))
        goto err;
    if(reg[i] <= 0)
        goto err;
    reg[i]--;
//print("- %R %d\n", i, reg[i]);
    return;
err:
    diag(n, "error in regfree: %R", i);
}
@

<<function regsalloc(x86)>>=
void
regsalloc(Node *n, Node *nn)
{
    cursafe = align(cursafe, nn->type, Aaut3);
    maxargsafe = maxround(maxargsafe, cursafe+curarg);
    *n = *nodsafe;
    n->xoffset = -(stkoff + cursafe);
    n->type = nn->type;
    n->etype = nn->type->etype;
    n->lineno = nn->lineno;
}
@

<<function regaalloc1(x86)>>=
void
regaalloc1(Node *n, Node *nn)
{
    USED(nn);

    if(REGARG < 0) {
        diag(n, "regaalloc1");
        return;
    }
/* not reached 
    nodreg(n, nn, REGARG);
    reg[REGARG]++;
    curarg = align(curarg, nn->type, Aarg1);
    curarg = align(curarg, nn->type, Aarg2);
    maxargsafe = maxround(maxargsafe, cursafe+curarg);
*/
}
@

<<function regaalloc(x86)>>=
void
regaalloc(Node *n, Node *nn)
{
    curarg = align(curarg, nn->type, Aarg1);
    *n = *nn;
    n->op = OINDREG;
    n->reg = REGSP;
    n->xoffset = curarg;
    n->complex = 0;
    n->addable = 20;
    curarg = align(curarg, nn->type, Aarg2);
    maxargsafe = maxround(maxargsafe, cursafe+curarg);
}
@

<<function regind(x86)>>=
void
regind(Node *n, Node *nn)
{

    if(n->op != OREGISTER) {
        diag(n, "regind not OREGISTER");
        return;
    }
    n->op = OINDREG;
    n->type = nn->type;
}
@

<<function naddr(x86)>>=
void
naddr(Node *n, Adr *a)
{
    long v;

    a->type = D_NONE;
    if(n == Z)
        return;
    switch(n->op) {
    default:
    bad:
        diag(n, "bad in naddr: %O %D", n->op, a);
//prtree(n, "naddr");
        break;

    case OREGISTER:
        a->type = n->reg;
        a->sym = S;
        break;

    case OEXREG:
        a->type = D_INDIR + D_GS;
        a->offset = n->reg - 1;
        a->etype = n->etype;
        break;

    case OIND:
        naddr(n->left, a);
        if(a->type >= D_AX && a->type <= D_DI)
            a->type += D_INDIR;
        else
        if(a->type == D_CONST)
            a->type = D_NONE+D_INDIR;
        else
        if(a->type == D_ADDR) {
            a->type = a->index;
            a->index = D_NONE;
        } else
            goto bad;
        break;

    case OINDEX:
        a->type = idx.ptr;
        if(n->left->op == OADDR || n->left->op == OCONST)
            naddr(n->left, a);
        if(a->type >= D_AX && a->type <= D_DI)
            a->type += D_INDIR;
        else
        if(a->type == D_CONST)
            a->type = D_NONE+D_INDIR;
        else
        if(a->type == D_ADDR) {
            a->type = a->index;
            a->index = D_NONE;
        } else
            goto bad;
        a->index = idx.reg;
        a->scale = n->scale;
        a->offset += n->xoffset;
        break;

    case OINDREG:
        a->type = n->reg+D_INDIR;
        a->sym = S;
        a->offset = n->xoffset;
        break;

    case ONAME:
        a->etype = n->etype;
        a->type = D_STATIC;
        a->sym = n->sym;
        a->offset = n->xoffset;
        if(n->class == CSTATIC)
            break;
        if(n->class == CEXTERN || n->class == CGLOBL) {
            a->type = D_EXTERN;
            break;
        }
        if(n->class == CAUTO) {
            a->type = D_AUTO;
            break;
        }
        if(n->class == CPARAM) {
            a->type = D_PARAM;
            break;
        }
        goto bad;

    case OCONST:
        if(typefd[n->type->etype]) {
            a->type = D_FCONST;
            a->dval = n->fconst;
            break;
        }
        a->sym = S;
        a->type = D_CONST;
        a->offset = n->vconst;
        break;

    case OADDR:
        naddr(n->left, a);
        if(a->type >= D_INDIR) {
            a->type -= D_INDIR;
            break;
        }
        if(a->type == D_EXTERN || a->type == D_STATIC ||
           a->type == D_AUTO || a->type == D_PARAM)
            if(a->index == D_NONE) {
                a->index = a->type;
                a->type = D_ADDR;
                break;
            }
        goto bad;

    case OADD:
        if(n->right->op == OCONST) {
            v = n->right->vconst;
            naddr(n->left, a);
        } else
        if(n->left->op == OCONST) {
            v = n->left->vconst;
            naddr(n->right, a);
        } else
            goto bad;
        a->offset += v;
        break;

    }
}
@

<<function CASE(x86)>>=
#define	CASE(a,b)	((a<<8)|(b<<0))
@

% set via pragma
<<global fproundflg>>=
int	fproundflg;
@



<<function gmove(x86)>>=
void
gmove(Node *f, Node *t)
{
    int ft, tt, a;
    Node nod, nod1;
    Prog *p1;

    ft = f->type->etype;
    tt = t->type->etype;

    if(debug['M'])
        print("gop: %O %O[%s],%O[%s]\n", OAS,
            f->op, tnames[ft], t->op, tnames[tt]);

    if(typefd[ft] && f->op == OCONST) {
        if(f->fconst == 0)
            gins(AFLDZ, Z, Z);
        else
        if(f->fconst == 1)
            gins(AFLD1, Z, Z);
        else
            gins(AFMOVD, f, &fregnode0);
        gmove(&fregnode0, t);
        return;
    }
/*
 * load
 */
    if(f->op == ONAME || f->op == OINDREG ||
       f->op == OIND || f->op == OINDEX)
    switch(ft) {
    case TCHAR:
        a = AMOVBLSX;
        goto ld;
    case TUCHAR:
        a = AMOVBLZX;
        goto ld;
    case TSHORT:
        if(typefd[tt]) {
            gins(AFMOVW, f, &fregnode0);
            gmove(&fregnode0, t);
            return;
        }
        a = AMOVWLSX;
        goto ld;
    case TUSHORT:
        a = AMOVWLZX;
        goto ld;
    case TINT:
    case TUINT:
    case TLONG:
    case TULONG:
    case TIND:
        if(typefd[tt]) {
            gins(AFMOVL, f, &fregnode0);
            gmove(&fregnode0, t);
            return;
        }
        a = AMOVL;

    ld:
        regalloc(&nod, f, t);
        nod.type = types[TLONG];
        gins(a, f, &nod);
        gmove(&nod, t);
        regfree(&nod);
        return;

    case TFLOAT:
        gins(AFMOVF, f, t);
        return;
    case TDOUBLE:
        gins(AFMOVD, f, t);
        return;
    }

/*
 * store
 */
    if(t->op == ONAME || t->op == OINDREG ||
       t->op == OIND || t->op == OINDEX)
    switch(tt) {
    case TCHAR:
    case TUCHAR:
        a = AMOVB;	goto st;
    case TSHORT:
    case TUSHORT:
        a = AMOVW;	goto st;
    case TINT:
    case TUINT:
    case TLONG:
    case TULONG:
    case TIND:
        a = AMOVL;	goto st;

    st:
        if(f->op == OCONST) {
            gins(a, f, t);
            return;
        }
        regalloc(&nod, t, f);
        gmove(f, &nod);
        gins(a, &nod, t);
        regfree(&nod);
        return;

    case TFLOAT:
        gins(AFMOVFP, f, t);
        return;
    case TDOUBLE:
        gins(AFMOVDP, f, t);
        return;
    }

/*
 * convert
 */
    switch(CASE(ft,tt)) {
    default:
/*
 * integer to integer
 ********
        a = AGOK;	break;

    case CASE(	TCHAR,	TCHAR):
    case CASE(	TUCHAR,	TCHAR):
    case CASE(	TSHORT,	TCHAR):
    case CASE(	TUSHORT,TCHAR):
    case CASE(	TINT,	TCHAR):
    case CASE(	TUINT,	TCHAR):
    case CASE(	TLONG,	TCHAR):
    case CASE(	TULONG,	TCHAR):
    case CASE(	TIND,	TCHAR):

    case CASE(	TCHAR,	TUCHAR):
    case CASE(	TUCHAR,	TUCHAR):
    case CASE(	TSHORT,	TUCHAR):
    case CASE(	TUSHORT,TUCHAR):
    case CASE(	TINT,	TUCHAR):
    case CASE(	TUINT,	TUCHAR):
    case CASE(	TLONG,	TUCHAR):
    case CASE(	TULONG,	TUCHAR):
    case CASE(	TIND,	TUCHAR):

    case CASE(	TSHORT,	TSHORT):
    case CASE(	TUSHORT,TSHORT):
    case CASE(	TINT,	TSHORT):
    case CASE(	TUINT,	TSHORT):
    case CASE(	TLONG,	TSHORT):
    case CASE(	TULONG,	TSHORT):
    case CASE(	TIND,	TSHORT):

    case CASE(	TSHORT,	TUSHORT):
    case CASE(	TUSHORT,TUSHORT):
    case CASE(	TINT,	TUSHORT):
    case CASE(	TUINT,	TUSHORT):
    case CASE(	TLONG,	TUSHORT):
    case CASE(	TULONG,	TUSHORT):
    case CASE(	TIND,	TUSHORT):

    case CASE(	TINT,	TINT):
    case CASE(	TUINT,	TINT):
    case CASE(	TLONG,	TINT):
    case CASE(	TULONG,	TINT):
    case CASE(	TIND,	TINT):

    case CASE(	TINT,	TUINT):
    case CASE(	TUINT,	TUINT):
    case CASE(	TLONG,	TUINT):
    case CASE(	TULONG,	TUINT):
    case CASE(	TIND,	TUINT):

    case CASE(	TINT,	TLONG):
    case CASE(	TUINT,	TLONG):
    case CASE(	TLONG,	TLONG):
    case CASE(	TULONG,	TLONG):
    case CASE(	TIND,	TLONG):

    case CASE(	TINT,	TULONG):
    case CASE(	TUINT,	TULONG):
    case CASE(	TLONG,	TULONG):
    case CASE(	TULONG,	TULONG):
    case CASE(	TIND,	TULONG):

    case CASE(	TINT,	TIND):
    case CASE(	TUINT,	TIND):
    case CASE(	TLONG,	TIND):
    case CASE(	TULONG,	TIND):
    case CASE(	TIND,	TIND):
 *****/
        a = AMOVL;
        break;

    case CASE(	TSHORT,	TINT):
    case CASE(	TSHORT,	TUINT):
    case CASE(	TSHORT,	TLONG):
    case CASE(	TSHORT,	TULONG):
    case CASE(	TSHORT,	TIND):
        a = AMOVWLSX;
        if(f->op == OCONST) {
            f->vconst &= 0xffff;
            if(f->vconst & 0x8000)
                f->vconst |= 0xffff0000;
            a = AMOVL;
        }
        break;

    case CASE(	TUSHORT,TINT):
    case CASE(	TUSHORT,TUINT):
    case CASE(	TUSHORT,TLONG):
    case CASE(	TUSHORT,TULONG):
    case CASE(	TUSHORT,TIND):
        a = AMOVWLZX;
        if(f->op == OCONST) {
            f->vconst &= 0xffff;
            a = AMOVL;
        }
        break;

    case CASE(	TCHAR,	TSHORT):
    case CASE(	TCHAR,	TUSHORT):
    case CASE(	TCHAR,	TINT):
    case CASE(	TCHAR,	TUINT):
    case CASE(	TCHAR,	TLONG):
    case CASE(	TCHAR,	TULONG):
    case CASE(	TCHAR,	TIND):
        a = AMOVBLSX;
        if(f->op == OCONST) {
            f->vconst &= 0xff;
            if(f->vconst & 0x80)
                f->vconst |= 0xffffff00;
            a = AMOVL;
        }
        break;

    case CASE(	TUCHAR,	TSHORT):
    case CASE(	TUCHAR,	TUSHORT):
    case CASE(	TUCHAR,	TINT):
    case CASE(	TUCHAR,	TUINT):
    case CASE(	TUCHAR,	TLONG):
    case CASE(	TUCHAR,	TULONG):
    case CASE(	TUCHAR,	TIND):
        a = AMOVBLZX;
        if(f->op == OCONST) {
            f->vconst &= 0xff;
            a = AMOVL;
        }
        break;

/*
 * float to fix
 */
    case CASE(	TFLOAT,	TCHAR):
    case CASE(	TFLOAT,	TUCHAR):
    case CASE(	TFLOAT,	TSHORT):
    case CASE(	TFLOAT,	TUSHORT):
    case CASE(	TFLOAT,	TINT):
    case CASE(	TFLOAT,	TLONG):
    case CASE(	TFLOAT,	TIND):

    case CASE(	TDOUBLE,TCHAR):
    case CASE(	TDOUBLE,TUCHAR):
    case CASE(	TDOUBLE,TSHORT):
    case CASE(	TDOUBLE,TUSHORT):
    case CASE(	TDOUBLE,TINT):
    case CASE(	TDOUBLE,TLONG):
    case CASE(	TDOUBLE,TIND):
        if(fproundflg) {
            regsalloc(&nod, &regnode);
            gins(AFMOVLP, f, &nod);
            gmove(&nod, t);
            return;
        }
        regsalloc(&nod, &regnode);
        regsalloc(&nod1, &regnode);
        gins(AFSTCW, Z, &nod1);
        nod1.xoffset += 2;
        gins(AMOVW, nodconst(0xf7f), &nod1);
        gins(AFLDCW, &nod1, Z);
        gins(AFMOVLP, f, &nod);
        nod1.xoffset -= 2;
        gins(AFLDCW, &nod1, Z);
        gmove(&nod, t);
        return;

/*
 * float to ulong
 */
    case CASE(	TDOUBLE,	TULONG):
    case CASE(	TFLOAT,	TULONG):
    case CASE(	TDOUBLE,	TUINT):
    case CASE(	TFLOAT,	TUINT):
        regsalloc(&nod, &regnode);
        gmove(f, &fregnode0);
        gins(AFADDD, nodfconst(-2147483648.), &fregnode0);
        gins(AFMOVLP, f, &nod);
        gins(ASUBL, nodconst(-2147483648), &nod);
        gmove(&nod, t);
        return;

/*
 * ulong to float
 */
    case CASE(	TULONG,	TDOUBLE):
    case CASE(	TULONG,	TFLOAT):
    case CASE(	TUINT,	TDOUBLE):
    case CASE(	TUINT,	TFLOAT):
        regalloc(&nod, f, f);
        gmove(f, &nod);
        regsalloc(&nod1, &regnode);
        gmove(&nod, &nod1);
        gins(AFMOVL, &nod1, &fregnode0);
        gins(ACMPL, &nod, nodconst(0));
        gins(AJGE, Z, Z);
        p1 = p;
        gins(AFADDD, nodfconst(4294967296.), &fregnode0);
        patch(p1, pc);
        regfree(&nod);
        return;

/*
 * fix to float
 */
    case CASE(	TCHAR,	TFLOAT):
    case CASE(	TUCHAR,	TFLOAT):
    case CASE(	TSHORT,	TFLOAT):
    case CASE(	TUSHORT,TFLOAT):
    case CASE(	TINT,	TFLOAT):
    case CASE(	TLONG,	TFLOAT):
    case CASE(	TIND,	TFLOAT):

    case CASE(	TCHAR,	TDOUBLE):
    case CASE(	TUCHAR,	TDOUBLE):
    case CASE(	TSHORT,	TDOUBLE):
    case CASE(	TUSHORT,TDOUBLE):
    case CASE(	TINT,	TDOUBLE):
    case CASE(	TLONG,	TDOUBLE):
    case CASE(	TIND,	TDOUBLE):
        regsalloc(&nod, &regnode);
        gmove(f, &nod);
        gins(AFMOVL, &nod, &fregnode0);
        return;

/*
 * float to float
 */
    case CASE(	TFLOAT,	TFLOAT):
    case CASE(	TDOUBLE,TFLOAT):

    case CASE(	TFLOAT,	TDOUBLE):
    case CASE(	TDOUBLE,TDOUBLE):
        a = AFMOVD;	break;
    }
    if(a == AMOVL || a == AFMOVD)
    if(samaddr(f, t))
        return;
    gins(a, f, t);
}
@

<<function doindex(x86)>>=
void
doindex(Node *n)
{
    Node nod, nod1;
    long v;

if(debug['Y'])
prtree(n, "index");

if(n->left->complex >= FNX)
print("botch in doindex\n");

    regalloc(&nod, &regnode, Z);
    v = constnode.vconst;
    cgen(n->right, &nod);
    idx.ptr = D_NONE;
    if(n->left->op == OCONST)
        idx.ptr = D_CONST;
    else if(n->left->op == OREGISTER)
//	else if(n->left->op == OREGISTER && typeil[n->left->type->etype])
        idx.ptr = n->left->reg;
    else if(n->left->op != OADDR) {
        reg[D_BP]++;	// cant be used as a base
        regalloc(&nod1, &regnode, Z);
        cgen(n->left, &nod1);
        idx.ptr = nod1.reg;
        regfree(&nod1);
        reg[D_BP]--;
    }
    idx.reg = nod.reg;
    regfree(&nod);
    constnode.vconst = v;
}
@

<<function gins(x86)>>=
void
gins(int a, Node *f, Node *t)
{

    if(f != Z && f->op == OINDEX)
        doindex(f);
    if(t != Z && t->op == OINDEX)
        doindex(t);
    nextpc();
    p->as = a;
    if(f != Z)
        naddr(f, &p->from);
    if(t != Z)
        naddr(t, &p->to);
    if(debug['g'])
        print("%P\n", p);
}
@

<<function fgopcode(x86)>>=
void
fgopcode(int o, Node *f, Node *t, int pop, int rev)
{
    int a, et;
    Node nod;

    et = TLONG;
    if(f != Z && f->type != T)
        et = f->type->etype;
    if(!typefd[et]) {
        diag(f, "fop: integer %O", o);
        return;
    }
    if(debug['M']) {
        if(t != Z && t->type != T)
            print("gop: %O %O-%s Z\n", o, f->op, tnames[et]);
        else
            print("gop: %O %O-%s %O-%s\n", o,
                f->op, tnames[et], t->op, tnames[t->type->etype]);
    }
    a = AGOK;
    switch(o) {

    case OASADD:
    case OADD:
        if(et == TFLOAT)
            a = AFADDF;
        else
        if(et == TDOUBLE) {
            a = AFADDD;
            if(pop)
                a = AFADDDP;
        }
        break;

    case OASSUB:
    case OSUB:
        if(et == TFLOAT) {
            a = AFSUBF;
            if(rev)
                a = AFSUBRF;
        } else
        if(et == TDOUBLE) {
            a = AFSUBD;
            if(pop)
                a = AFSUBDP;
            if(rev) {
                a = AFSUBRD;
                if(pop)
                    a = AFSUBRDP;
            }
        }
        break;

    case OASMUL:
    case OMUL:
        if(et == TFLOAT)
            a = AFMULF;
        else
        if(et == TDOUBLE) {
            a = AFMULD;
            if(pop)
                a = AFMULDP;
        }
        break;

    case OASMOD:
    case OMOD:
    case OASDIV:
    case ODIV:
        if(et == TFLOAT) {
            a = AFDIVF;
            if(rev)
                a = AFDIVRF;
        } else
        if(et == TDOUBLE) {
            a = AFDIVD;
            if(pop)
                a = AFDIVDP;
            if(rev) {
                a = AFDIVRD;
                if(pop)
                    a = AFDIVRDP;
            }
        }
        break;

    case OEQ:
    case ONE:
    case OLT:
    case OLE:
    case OGE:
    case OGT:
        pop += rev;
        if(et == TFLOAT) {
            a = AFCOMF;
            if(pop) {
                a = AFCOMFP;
                if(pop > 1)
                    a = AGOK;
            }
        } else
        if(et == TDOUBLE) {
            a = AFCOMF;
            if(pop) {
                a = AFCOMDP;
                if(pop > 1)
                    a = AFCOMDPP;
            }
        }
        gins(a, f, t);
        regalloc(&nod, &regnode, Z);
        if(nod.reg != D_AX) {
            regfree(&nod);
            nod.reg = D_AX;
            gins(APUSHL, &nod, Z);
            gins(AWAIT, Z, Z);
            gins(AFSTSW, Z, &nod);
            gins(ASAHF, Z, Z);
            gins(APOPL, Z, &nod);
        } else {
            gins(AWAIT, Z, Z);
            gins(AFSTSW, Z, &nod);
            gins(ASAHF, Z, Z);
            regfree(&nod);
        }
        switch(o) {
        case OEQ:	a = AJEQ; break;
        case ONE:	a = AJNE; break;
        case OLT:	a = AJCS; break;
        case OLE:	a = AJLS; break;
        case OGE:	a = AJCC; break;
        case OGT:	a = AJHI; break;
        }
        gins(a, Z, Z);
        return;
    }
    if(a == AGOK)
        diag(Z, "bad in gopcode %O", o);
    gins(a, f, t);
}
@

<<function gopcode(x86)>>=
void
gopcode(int o, Type *ty, Node *f, Node *t)
{
    int a, et;

    et = TLONG;
    if(ty != T)
        et = ty->etype;
    if(typefd[et] && o != OADDR && o != OFUNC) {
        diag(f, "gop: float %O", o);
        return;
    }
    if(debug['M']) {
        if(f != Z && f->type != T)
            print("gop: %O %O[%s],", o, f->op, tnames[et]);
        else
            print("gop: %O Z,", o);
        if(t != Z && t->type != T)
            print("%O[%s]\n", t->op, tnames[t->type->etype]);
        else
            print("Z\n");
    }
    a = AGOK;
    switch(o) {
    case OCOM:
        a = ANOTL;
        if(et == TCHAR || et == TUCHAR)
            a = ANOTB;
        if(et == TSHORT || et == TUSHORT)
            a = ANOTW;
        break;

    case ONEG:
        a = ANEGL;
        if(et == TCHAR || et == TUCHAR)
            a = ANEGB;
        if(et == TSHORT || et == TUSHORT)
            a = ANEGW;
        break;

    case OADDR:
        a = ALEAL;
        break;

    case OASADD:
    case OADD:
        a = AADDL;
        if(et == TCHAR || et == TUCHAR)
            a = AADDB;
        if(et == TSHORT || et == TUSHORT)
            a = AADDW;
        break;

    case OASSUB:
    case OSUB:
        a = ASUBL;
        if(et == TCHAR || et == TUCHAR)
            a = ASUBB;
        if(et == TSHORT || et == TUSHORT)
            a = ASUBW;
        break;

    case OASOR:
    case OOR:
        a = AORL;
        if(et == TCHAR || et == TUCHAR)
            a = AORB;
        if(et == TSHORT || et == TUSHORT)
            a = AORW;
        break;

    case OASAND:
    case OAND:
        a = AANDL;
        if(et == TCHAR || et == TUCHAR)
            a = AANDB;
        if(et == TSHORT || et == TUSHORT)
            a = AANDW;
        break;

    case OASXOR:
    case OXOR:
        a = AXORL;
        if(et == TCHAR || et == TUCHAR)
            a = AXORB;
        if(et == TSHORT || et == TUSHORT)
            a = AXORW;
        break;

    case OASLSHR:
    case OLSHR:
        a = ASHRL;
        if(et == TCHAR || et == TUCHAR)
            a = ASHRB;
        if(et == TSHORT || et == TUSHORT)
            a = ASHRW;
        break;

    case OASASHR:
    case OASHR:
        a = ASARL;
        if(et == TCHAR || et == TUCHAR)
            a = ASARB;
        if(et == TSHORT || et == TUSHORT)
            a = ASARW;
        break;

    case OASASHL:
    case OASHL:
        a = ASALL;
        if(et == TCHAR || et == TUCHAR)
            a = ASALB;
        if(et == TSHORT || et == TUSHORT)
            a = ASALW;
        break;

    case OFUNC:
        a = ACALL;
        break;

    case OASMUL:
    case OMUL:
        if(f->op == OREGISTER && t != Z && isreg(t, D_AX) && reg[D_DX] == 0)
            t = Z;
        a = AIMULL;
        break;

    case OASMOD:
    case OMOD:
    case OASDIV:
    case ODIV:
        a = AIDIVL;
        break;

    case OASLMUL:
    case OLMUL:
        a = AMULL;
        break;

    case OASLMOD:
    case OLMOD:
    case OASLDIV:
    case OLDIV:
        a = ADIVL;
        break;

    case OEQ:
    case ONE:
    case OLT:
    case OLE:
    case OGE:
    case OGT:
    case OLO:
    case OLS:
    case OHS:
    case OHI:
        a = ACMPL;
        if(et == TCHAR || et == TUCHAR)
            a = ACMPB;
        if(et == TSHORT || et == TUSHORT)
            a = ACMPW;
        gins(a, f, t);
        switch(o) {
        case OEQ:	a = AJEQ; break;
        case ONE:	a = AJNE; break;
        case OLT:	a = AJLT; break;
        case OLE:	a = AJLE; break;
        case OGE:	a = AJGE; break;
        case OGT:	a = AJGT; break;
        case OLO:	a = AJCS; break;
        case OLS:	a = AJLS; break;
        case OHS:	a = AJCC; break;
        case OHI:	a = AJHI; break;
        }
        gins(a, Z, Z);
        return;
    }
    if(a == AGOK)
        diag(Z, "bad in gopcode %O", o);
    gins(a, f, t);
}
@

<<function samaddr(x86)>>=
int
samaddr(Node *f, Node *t)
{

    if(f->op != t->op)
        return 0;
    switch(f->op) {

    case OREGISTER:
        if(f->reg != t->reg)
            break;
        return 1;
    }
    return 0;
}
@

<<function gbranch(x86)>>=
void
gbranch(int o)
{
    int a;

    a = AGOK;
    switch(o) {
    case ORETURN:
        a = ARET;
        break;
    case OGOTO:
        a = AJMP;
        break;
    }
    nextpc();
    if(a == AGOK) {
        diag(Z, "bad in gbranch %O",  o);
        nextpc();
    }
    p->as = a;
}
@

<<function patch(x86)>>=
void
patch(Prog *op, long pc)
{

    op->to.offset = pc;
    op->to.type = D_BRANCH;
}
@

<<function gpseudo(x86)>>=
void
gpseudo(int a, Sym *s, Node *n)
{

    nextpc();
    p->as = a;
    p->from.type = D_EXTERN;
    p->from.sym = s;
    p->from.scale = (profileflg ? 0 : NOPROF);
    if(s->class == CSTATIC)
        p->from.type = D_STATIC;
    naddr(n, &p->to);
    if(a == ADATA || a == AGLOBL)
        pc--;
}
@

<<function sconst(x86)>>=
int
sconst(Node *n)
{
    long v;

    if(n->op == OCONST && !typefd[n->type->etype]) {
        v = n->vconst;
        if(v >= -32766L && v < 32766L)
            return 1;
    }
    return 0;
}
@

<<function exreg(x86)>>=
long
exreg(Type *t)
{

    int o;

    if(typechlp[t->etype]){
        if(exregoffset >= 32)
            return 0;
        o = exregoffset;
        exregoffset += 4;
        return o+1;	/* +1 to avoid 0 == failure; naddr case OEXREG will -1. */
    }
    return 0;
}
@


<<global ncast(x86)>>=
long	ncast[NTYPE] =
{
    0,				/*[TXXX]*/
    BCHAR|BUCHAR,			/*[TCHAR]*/
    BCHAR|BUCHAR,			/*[TUCHAR]*/	
    BSHORT|BUSHORT,			/*[TSHORT]*/
    BSHORT|BUSHORT,			/*[TUSHORT]*/
    BINT|BUINT|BLONG|BULONG|BIND,	/*[TINT]*/		
    BINT|BUINT|BLONG|BULONG|BIND,	/*[TUINT]*/
    BINT|BUINT|BLONG|BULONG|BIND,	/*[TLONG]*/
    BINT|BUINT|BLONG|BULONG|BIND,	/*[TULONG]*/
    BVLONG|BUVLONG,			/*[TVLONG]*/
    BVLONG|BUVLONG,			/*[TUVLONG]*/
    BFLOAT,				/*[TFLOAT]*/
    BDOUBLE,			/*[TDOUBLE]*/
    BLONG|BULONG|BIND,		/*[TIND]*/
    0,				/*[TFUNC]*/
    0,				/*[TARRAY]*/
    0,				/*[TVOID]*/
    BSTRUCT,			/*[TSTRUCT]*/
    BUNION,				/*[TUNION]*/
    0,				/*[TENUM]*/
};
@


%-------------------------------------------------------------

<<8c/txt.c>>=
#include "gc.h"

void	nextpc(void);
void	garg1(Node*, Node*, Node*, int, Node**);
Node*	nodfconst(double);
void	regaalloc1(Node*, Node*);
void	regaalloc(Node*, Node*);
void	naddr(Node*, Adr*);
int	samaddr(Node*, Node*);

<<function ginit(x86)>>

<<function gclean(x86)>>

<<function nextpc(x86)>>

<<function gargs(x86)>>

<<function nareg(x86)>>

<<function garg1(x86)>>

<<function nodconst(x86)>>

<<function nodfconst(x86)>>

<<function isreg(x86)>>

<<function nodreg(x86)>>

<<function regret(x86)>>

<<function regalloc(x86)>>

<<function regialloc(x86)>>

<<function regfree(x86)>>

<<function regsalloc(x86)>>

<<function regaalloc1(x86)>>

<<function regaalloc(x86)>>

<<function regind(x86)>>

<<function naddr(x86)>>

<<function CASE(x86)>>

<<function gmove(x86)>>

<<function doindex(x86)>>

<<function gins(x86)>>

<<function fgopcode(x86)>>

<<function gopcode(x86)>>

<<function samaddr(x86)>>

<<function gbranch(x86)>>

<<function patch(x86)>>

<<function gpseudo(x86)>>

<<function sconst(x86)>>

<<function exreg(x86)>>

<<global ewidth(x86)>>
<<global ncast(x86)>>
@


\subsection*{[[8c/peep.c]]}

<<function needc(x86)>>=
static bool
needc(Prog *p)
{
    while(p != P) {
        switch(p->as) {
        case AADCL:
        case ASBBL:
        case ARCRL:
            return true;
        case AADDL:
        case ASUBL:
        case AJMP:
        case ARET:
        case ACALL:
            return false;
        default:
            if(p->to.type == D_BRANCH)
                return false;
        }
        p = p->link;
    }
    return false;
}
@

<<function peep(x86)>>=
void
peep(void)
{
    Reg *r, *r1, *r2;
    Prog *p, *p1;
    int t;

    /*
     * complete R structure
     */
    t = 0;
    for(r=firstr; r!=R; r=r1) {
        r1 = r->link;
        if(r1 == R)
            break;
        p = r->prog->link;
        while(p != r1->prog)
        switch(p->as) {
        default:
            r2 = rega();
            r->link = r2;
            r2->link = r1;

            r2->prog = p;
            r2->p1 = r;
            r->s1 = r2;
            r2->s1 = r1;
            r1->p1 = r2;

            r = r2;
            t++;

        case ADATA:
        case AGLOBL:
        case ANAME:
        case ASIGNAME:
            p = p->link;
        }
    }

    pc = 0;	/* speculating it won't kill */

loop1:

    t = 0;
    for(r=firstr; r!=R; r=r->link) {
        p = r->prog;
        switch(p->as) {
        case AMOVL:
            if(regtyp(&p->to))
            if(regtyp(&p->from)) {
                if(copyprop(r)) {
                    excise(r);
                    t++;
                }
                if(subprop(r) && copyprop(r)) {
                    excise(r);
                    t++;
                }
            }
            break;

        case AMOVBLSX:
        case AMOVBLZX:
        case AMOVWLSX:
        case AMOVWLZX:
            if(regtyp(&p->to)) {
                r1 = uniqs(r);
                if(r1 != R) {
                    p1 = r1->prog;
                    if(p->as == p1->as && p->to.type == p1->from.type)
                        p1->as = AMOVL;
                }
            }
            break;
        case AADDL:
        case AADDW:
            if(p->from.type != D_CONST || needc(p->link))
                break;
            if(p->from.offset == -1){
                if(p->as == AADDL)
                    p->as = ADECL;
                else
                    p->as = ADECW;
                p->from = zprog.from;
            }
            else if(p->from.offset == 1){
                if(p->as == AADDL)
                    p->as = AINCL;
                else
                    p->as = AINCW;
                p->from = zprog.from;
            }
            break;
        case ASUBL:
        case ASUBW:
            if(p->from.type != D_CONST || needc(p->link))
                break;
            if(p->from.offset == -1) {
                if(p->as == ASUBL)
                    p->as = AINCL;
                else
                    p->as = AINCW;
                p->from = zprog.from;
            }
            else if(p->from.offset == 1){
                if(p->as == ASUBL)
                    p->as = ADECL;
                else
                    p->as = ADECW;
                p->from = zprog.from;
            }
            break;
        }
    }
    if(t)
        goto loop1;
}
@

<<function excise(x86)>>=
void
excise(Reg *r)
{
    Prog *p;

    p = r->prog;
    p->as = ANOP;
    p->from = zprog.from;
    p->to = zprog.to;
}
@

<<function uniqp(x86)>>=
Reg*
uniqp(Reg *r)
{
    Reg *r1;

    r1 = r->p1;
    if(r1 == R) {
        r1 = r->p2;
        if(r1 == R || r1->p2link != R)
            return R;
    } else
        if(r->p2 != R)
            return R;
    return r1;
}
@

<<function uniqs(x86)>>=
Reg*
uniqs(Reg *r)
{
    Reg *r1;

    r1 = r->s1;
    if(r1 == R) {
        r1 = r->s2;
        if(r1 == R)
            return R;
    } else
        if(r->s2 != R)
            return R;
    return r1;
}
@

<<function regtyp(x86)>>=
int
regtyp(Adr *a)
{
    int t;

    t = a->type;
    if(t >= D_AX && t <= D_DI)
        return 1;
    return 0;
}
@

<<function subprop(x86)>>=
/*
 * the idea is to substitute
 * one register for another
 * from one MOV to another
 *	MOV	a, R0
 *	ADD	b, R0	/ no use of R1
 *	MOV	R0, R1
 * would be converted to
 *	MOV	a, R1
 *	ADD	b, R1
 *	MOV	R1, R0
 * hopefully, then the former or latter MOV
 * will be eliminated by copy propagation.
 */
int
subprop(Reg *r0)
{
    Prog *p;
    Adr *v1, *v2;
    Reg *r;
    int t;

    p = r0->prog;
    v1 = &p->from;
    if(!regtyp(v1))
        return 0;
    v2 = &p->to;
    if(!regtyp(v2))
        return 0;
    for(r=uniqp(r0); r!=R; r=uniqp(r)) {
        if(uniqs(r) == R)
            break;
        p = r->prog;
        switch(p->as) {
        case ACALL:
            return 0;

        case AIMULL:
        case AIMULW:
            if(p->to.type != D_NONE)
                break;

        case ADIVB:
        case ADIVL:
        case ADIVW:
        case AIDIVB:
        case AIDIVL:
        case AIDIVW:
        case AIMULB:
        case AMULB:
        case AMULL:
        case AMULW:

        case AROLB:
        case AROLL:
        case AROLW:
        case ARORB:
        case ARORL:
        case ARORW:
        case ASALB:
        case ASALL:
        case ASALW:
        case ASARB:
        case ASARL:
        case ASARW:
        case ASHLB:
        case ASHLL:
        case ASHLW:
        case ASHRB:
        case ASHRL:
        case ASHRW:

        case AREP:
        case AREPN:

        case ACWD:
        case ACDQ:

        case ASTOSB:
        case ASTOSL:
        case AMOVSB:
        case AMOVSL:
        case AFSTSW:
            return 0;

        case AMOVL:
            if(p->to.type == v1->type)
                goto gotit;
            break;
        }
        if(copyau(&p->from, v2) ||
           copyau(&p->to, v2))
            break;
        if(copysub(&p->from, v1, v2, 0) ||
           copysub(&p->to, v1, v2, 0))
            break;
    }
    return 0;

gotit:
    copysub(&p->to, v1, v2, 1);
    if(debug['P']) {
        print("gotit: %D->%D\n%P", v1, v2, r->prog);
        if(p->from.type == v2->type)
            print(" excise");
        print("\n");
    }
    for(r=uniqs(r); r!=r0; r=uniqs(r)) {
        p = r->prog;
        copysub(&p->from, v1, v2, 1);
        copysub(&p->to, v1, v2, 1);
        if(debug['P'])
            print("%P\n", r->prog);
    }
    t = v1->type;
    v1->type = v2->type;
    v2->type = t;
    if(debug['P'])
        print("%P last\n", r->prog);
    return 1;
}
@

<<function copyprop(x86)>>=
/*
 * The idea is to remove redundant copies.
 *	v1->v2	F=0
 *	(use v2	s/v2/v1/)*
 *	set v1	F=1
 *	use v2	return fail
 *	-----------------
 *	v1->v2	F=0
 *	(use v2	s/v2/v1/)*
 *	set v1	F=1
 *	set v2	return success
 */
int
copyprop(Reg *r0)
{
    Prog *p;
    Adr *v1, *v2;
    Reg *r;

    p = r0->prog;
    v1 = &p->from;
    v2 = &p->to;
    if(copyas(v1, v2))
        return 1;
    for(r=firstr; r!=R; r=r->link)
        r->active = 0;
    return copy1(v1, v2, r0->s1, 0);
}
@

<<function copy1(x86)>>=
int
copy1(Adr *v1, Adr *v2, Reg *r, int f)
{
    int t;
    Prog *p;

    if(r->active) {
        if(debug['P'])
            print("act set; return 1\n");
        return 1;
    }
    r->active = 1;
    if(debug['P'])
        print("copy %D->%D f=%d\n", v1, v2, f);
    for(; r != R; r = r->s1) {
        p = r->prog;
        if(debug['P'])
            print("%P", p);
        if(!f && uniqp(r) == R) {
            f = 1;
            if(debug['P'])
                print("; merge; f=%d", f);
        }
        t = copyu(p, v2, A);
        switch(t) {
        case 2:	/* rar, cant split */
            if(debug['P'])
                print("; %D rar; return 0\n", v2);
            return 0;

        case 3:	/* set */
            if(debug['P'])
                print("; %D set; return 1\n", v2);
            return 1;

        case 1:	/* used, substitute */
        case 4:	/* use and set */
            if(f) {
                if(!debug['P'])
                    return 0;
                if(t == 4)
                    print("; %D used+set and f=%d; return 0\n", v2, f);
                else
                    print("; %D used and f=%d; return 0\n", v2, f);
                return 0;
            }
            if(copyu(p, v2, v1)) {
                if(debug['P'])
                    print("; sub fail; return 0\n");
                return 0;
            }
            if(debug['P'])
                print("; sub %D/%D", v2, v1);
            if(t == 4) {
                if(debug['P'])
                    print("; %D used+set; return 1\n", v2);
                return 1;
            }
            break;
        }
        if(!f) {
            t = copyu(p, v1, A);
            if(!f && (t == 2 || t == 3 || t == 4)) {
                f = 1;
                if(debug['P'])
                    print("; %D set and !f; f=%d", v1, f);
            }
        }
        if(debug['P'])
            print("\n");
        if(r->s2)
            if(!copy1(v1, v2, r->s2, f))
                return 0;
    }
    return 1;
}
@

<<function copyu(x86)>>=
/*
 * return
 * 1 if v only used (and substitute),
 * 2 if read-alter-rewrite
 * 3 if set
 * 4 if set and used
 * 0 otherwise (not touched)
 */
int
copyu(Prog *p, Adr *v, Adr *s)
{

    switch(p->as) {

    default:
        if(debug['P'])
            print("unknown op %A\n", p->as);
        return 2;

    case ANEGB:
    case ANEGW:
    case ANEGL:
    case ANOTB:
    case ANOTW:
    case ANOTL:
        if(copyas(&p->to, v))
            return 2;
        break;

    case ALEAL:	/* lhs addr, rhs store */
        if(copyas(&p->from, v))
            return 2;


    case ANOP:	/* rhs store */
    case AMOVL:
    case AMOVBLSX:
    case AMOVBLZX:
    case AMOVWLSX:
    case AMOVWLZX:
        if(copyas(&p->to, v)) {
            if(s != A)
                return copysub(&p->from, v, s, 1);
            if(copyau(&p->from, v))
                return 4;
            return 3;
        }
        goto caseread;

    case AROLB:
    case AROLL:
    case AROLW:
    case ARORB:
    case ARORL:
    case ARORW:
    case ASALB:
    case ASALL:
    case ASALW:
    case ASARB:
    case ASARL:
    case ASARW:
    case ASHLB:
    case ASHLL:
    case ASHLW:
    case ASHRB:
    case ASHRL:
    case ASHRW:
        if(copyas(&p->to, v))
            return 2;
        if(copyas(&p->from, v))
            if(p->from.type == D_CX)
                return 2;
        goto caseread;

    case AADDB:	/* rhs rar */
    case AADDL:
    case AADDW:
    case AANDB:
    case AANDL:
    case AANDW:
    case ADECL:
    case ADECW:
    case AINCL:
    case AINCW:
    case ASUBB:
    case ASUBL:
    case ASUBW:
    case AORB:
    case AORL:
    case AORW:
    case AXORB:
    case AXORL:
    case AXORW:
    case AMOVB:
    case AMOVW:

    case AFMOVB:
    case AFMOVBP:
    case AFMOVD:
    case AFMOVDP:
    case AFMOVF:
    case AFMOVFP:
    case AFMOVL:
    case AFMOVLP:
    case AFMOVV:
    case AFMOVVP:
    case AFMOVW:
    case AFMOVWP:
    case AFMOVX:
    case AFMOVXP:
    case AFADDDP:
    case AFADDW:
    case AFADDL:
    case AFADDF:
    case AFADDD:
    case AFMULDP:
    case AFMULW:
    case AFMULL:
    case AFMULF:
    case AFMULD:
    case AFSUBDP:
    case AFSUBW:
    case AFSUBL:
    case AFSUBF:
    case AFSUBD:
    case AFSUBRDP:
    case AFSUBRW:
    case AFSUBRL:
    case AFSUBRF:
    case AFSUBRD:
    case AFDIVDP:
    case AFDIVW:
    case AFDIVL:
    case AFDIVF:
    case AFDIVD:
    case AFDIVRDP:
    case AFDIVRW:
    case AFDIVRL:
    case AFDIVRF:
    case AFDIVRD:
        if(copyas(&p->to, v))
            return 2;
        goto caseread;

    case ACMPL:	/* read only */
    case ACMPW:
    case ACMPB:

    case AFCOMB:
    case AFCOMBP:
    case AFCOMD:
    case AFCOMDP:
    case AFCOMDPP:
    case AFCOMF:
    case AFCOMFP:
    case AFCOML:
    case AFCOMLP:
    case AFCOMW:
    case AFCOMWP:
    case AFUCOM:
    case AFUCOMP:
    case AFUCOMPP:
    caseread:
        if(s != A) {
            if(copysub(&p->from, v, s, 1))
                return 1;
            return copysub(&p->to, v, s, 1);
        }
        if(copyau(&p->from, v))
            return 1;
        if(copyau(&p->to, v))
            return 1;
        break;

    case AJGE:	/* no reference */
    case AJNE:
    case AJLE:
    case AJEQ:
    case AJHI:
    case AJLS:
    case AJMI:
    case AJPL:
    case AJGT:
    case AJLT:
    case AJCC:
    case AJCS:

    case AADJSP:
    case AFLDZ:
    case AWAIT:
        break;

    case AIMULL:
    case AIMULW:
        if(p->to.type != D_NONE) {
            if(copyas(&p->to, v))
                return 2;
            goto caseread;
        }

    case ADIVB:
    case ADIVL:
    case ADIVW:
    case AIDIVB:
    case AIDIVL:
    case AIDIVW:
    case AIMULB:
    case AMULB:
    case AMULL:
    case AMULW:

    case ACWD:
    case ACDQ:
        if(v->type == D_AX || v->type == D_DX)
            return 2;
        goto caseread;

    case AREP:
    case AREPN:
        if(v->type == D_CX)
            return 2;
        goto caseread;

    case AMOVSB:
    case AMOVSL:
        if(v->type == D_DI || v->type == D_SI)
            return 2;
        goto caseread;

    case ASTOSB:
    case ASTOSL:
        if(v->type == D_AX || v->type == D_DI)
            return 2;
        goto caseread;

    case AFSTSW:
        if(v->type == D_AX)
            return 2;
        goto caseread;

    case AJMP:	/* funny */
        if(s != A) {
            if(copysub(&p->to, v, s, 1))
                return 1;
            return 0;
        }
        if(copyau(&p->to, v))
            return 1;
        return 0;

    case ARET:	/* funny */
        if(v->type == REGRET)
            return 2;
        if(s != A)
            return 1;
        return 3;

    case ACALL:	/* funny */
        if(REGARG>=0 && v->type == REGARG)
            return 2;

        if(s != A) {
            if(copysub(&p->to, v, s, 1))
                return 1;
            return 0;
        }
        if(copyau(&p->to, v))
            return 4;
        return 3;
    }
    return 0;
}
@

<<function copyas(x86)>>=
/*
 * direct reference,
 * could be set/use depending on
 * semantics
 */
int
copyas(Adr *a, Adr *v)
{
    if(a->type != v->type)
        return 0;
    if(regtyp(v))
        return 1;
    if(v->type == D_AUTO || v->type == D_PARAM)
        if(v->offset == a->offset)
            return 1;
    return 0;
}
@

<<function copyau(x86)>>=
/*
 * either direct or indirect
 */
int
copyau(Adr *a, Adr *v)
{

    if(copyas(a, v))
        return 1;
    if(regtyp(v)) {
        if(a->type-D_INDIR == v->type)
            return 1;
        if(a->index == v->type)
            return 1;
    }
    return 0;
}
@

<<function copysub(x86)>>=
/*
 * substitute s for v in a
 * return failure to substitute
 */
int
copysub(Adr *a, Adr *v, Adr *s, int f)
{
    int t;

    if(copyas(a, v)) {
        t = s->type;
        if(t >= D_AX && t <= D_DI) {
            if(f)
                a->type = t;
        }
        return 0;
    }
    if(regtyp(v)) {
        t = v->type;
        if(a->type == t+D_INDIR) {
            if(s->type == D_BP && a->index != D_NONE)
                return 1;	/* can't use BP-base with index */
            if(f)
                a->type = s->type+D_INDIR;
//			return 0;
        }
        if(a->index == t) {
            if(f)
                a->index = s->type;
            return 0;
        }
        return 0;
    }
    return 0;
}
@


%-------------------------------------------------------------

<<8c/peep.c>>=
#include "gc.h"

Reg*	uniqp(Reg*);
Reg*	uniqs(Reg*);
int	regtyp(Adr*);
int	subprop(Reg*);
int	copyprop(Reg*);
int	copy1(Adr*, Adr*, Reg*, int);
int	copyas(Adr*, Adr*);
int	copyau(Adr*, Adr*);
int	copysub(Adr*, Adr*, Adr*, int);
//int	copysub1(Prog*, Adr*, Adr*, int);

<<function needc(x86)>>

<<function peep(x86)>>

<<function excise(x86)>>

<<function uniqp(x86)>>

<<function uniqs(x86)>>

<<function regtyp(x86)>>

<<function subprop(x86)>>

<<function copyprop(x86)>>

<<function copy1(x86)>>

<<function copyu(x86)>>

<<function copyas(x86)>>

<<function copyau(x86)>>

<<function copysub(x86)>>
@


\subsection*{[[8c/sgen.c]]}


<<function commute(x86)>>=
/* welcome to commute */
static void
commute(Node *n)
{
    Node *l, *r;

    l = n->left;
    r = n->right;
    if(r->complex > l->complex) {
        n->left = r;
        n->right = l;
    }
}
@

<<function indexshift(x86)>>=
void
indexshift(Node *n)
{
    int g;

    if(!typechlp[n->type->etype])
        return;
    simplifyshift(n);
    if(n->op == OASHL && n->right->op == OCONST){
        g = vconst(n->right);
        if(g >= 0 && g < 4)
            n->addable = 7;
    }
}
@

<<function simplifyshift>>=
/*
 * try to rewrite shift & mask
 */
void
simplifyshift(Node *n)
{
    ulong c3;
    int o, s1, s2, c1, c2;

    if(!typechlp[n->type->etype])
        return;
    switch(n->op) {
    default:
        return;
    case OASHL:
        s1 = 0;
        break;
    case OLSHR:
        s1 = 1;
        break;
    case OASHR:
        s1 = 2;
        break;
    }
    if(n->right->op != OCONST)
        return;
    if(n->left->op != OAND)
        return;
    if(n->left->right->op != OCONST)
        return;
    switch(n->left->left->op) {
    default:
        return;
    case OASHL:
        s2 = 0;
        break;
    case OLSHR:
        s2 = 1;
        break;
    case OASHR:
        s2 = 2;
        break;
    }
    if(n->left->left->right->op != OCONST)
        return;

    c1 = n->right->vconst;
    c2 = n->left->left->right->vconst;
    c3 = n->left->right->vconst;

/*
    if(debug['h'])
        print("%.3o %ld %ld %d #%.lux\n",
            (s1<<3)|s2, c1, c2, topbit(c3), c3);
*/

    o = n->op;
    switch((s1<<3)|s2) {
    case 000:	/* (((e <<u c2) & c3) <<u c1) */
        c3 >>= c2;
        c1 += c2;
        if(c1 >= 32)
            break;
        goto rewrite1;

    case 002:	/* (((e >>s c2) & c3) <<u c1) */
        if(topbit(c3) >= (32-c2))
            break;
    case 001:	/* (((e >>u c2) & c3) <<u c1) */
        if(c1 > c2) {
            c3 <<= c2;
            c1 -= c2;
            o = OASHL;
            goto rewrite1;
        }
        c3 <<= c1;
        if(c1 == c2)
            goto rewrite0;
        c1 = c2-c1;
        o = OLSHR;
        goto rewrite2;

    case 022:	/* (((e >>s c2) & c3) >>s c1) */
        if(c2 <= 0)
            break;
    case 012:	/* (((e >>s c2) & c3) >>u c1) */
        if(topbit(c3) >= (32-c2))
            break;
        goto s11;
    case 021:	/* (((e >>u c2) & c3) >>s c1) */
        if(topbit(c3) >= 31 && c2 <= 0)
            break;
        goto s11;
    case 011:	/* (((e >>u c2) & c3) >>u c1) */
    s11:
        c3 <<= c2;
        c1 += c2;
        if(c1 >= 32)
            break;
        o = OLSHR;
        goto rewrite1;

    case 020:	/* (((e <<u c2) & c3) >>s c1) */
        if(topbit(c3) >= 31)
            break;
    case 010:	/* (((e <<u c2) & c3) >>u c1) */
        c3 >>= c1;
        if(c1 == c2)
            goto rewrite0;
        if(c1 > c2) {
            c1 -= c2;
            goto rewrite2;
        }
        c1 = c2 - c1;
        o = OASHL;
        goto rewrite2;
    }
    return;

rewrite0:	/* get rid of both shifts */
if(debug['<'])prtree(n, "rewrite0");
    *n = *n->left;
    n->left = n->left->left;
    n->right->vconst = c3;
    return;
rewrite1:	/* get rid of lower shift */
if(debug['<'])prtree(n, "rewrite1");
    n->left->left = n->left->left->left;
    n->left->right->vconst = c3;
    n->right->vconst = c1;
    n->op = o;
    return;
rewrite2:	/* get rid of upper shift */
if(debug['<'])prtree(n, "rewrite2");
    *n = *n->left;
    n->right->vconst = c3;
    n->left->right->vconst = c1;
    n->left->op = o;
}
@


<<function indx(x86)>>=
void
indx(Node *n)
{
    Node *l, *r;

    if(debug['x'])
        prtree(n, "indx");

    l = n->left;
    r = n->right;
    if(l->addable == 1 || l->addable == 13 || r->complex > l->complex) {
        n->right = l;
        n->left = r;
        l = r;
        r = n->right;
    }
    if(l->addable != 7) {
        idx.regtree = l;
        idx.scale = 1;
    } else
    if(l->right->addable == 20) {
        idx.regtree = l->left;
        idx.scale = 1 << l->right->vconst;
    } else
    if(l->left->addable == 20) {
        idx.regtree = l->right;
        idx.scale = 1 << l->left->vconst;
    } else
        diag(n, "bad index");

    idx.basetree = r;
    if(debug['x']) {
        print("scale = %d\n", idx.scale);
        prtree(idx.regtree, "index");
        prtree(idx.basetree, "base");
    }
}
@


%-------------------------------------------------------------

<<8c/sgen.c>>=
#include "gc.h"

void	indx(Node*);

<<function noretval(x86)>>

<<function commute(x86)>>

<<function indexshift(x86)>>

<<function xcom(x86)>>

<<function indx(x86)>>
@


\subsection*{[[8c/swt.c]]}

<<function swit1(x86)>>=
void
swit1(C1 *q, int nc, long def, Node *n)
{
    C1 *r;
    int i;
    Prog *sp;

    if(nc < 5) {
        for(i=0; i<nc; i++) {
            if(debug['K'])
                print("case = %.8llux\n", q->val);
            gopcode(OEQ, n->type, n, nodconst(q->val));
            patch(p, q->label);
            q++;
        }
        gbranch(OGOTO);
        patch(p, def);
        return;
    }
    i = nc / 2;
    r = q+i;
    if(debug['K'])
        print("case > %.8llux\n", r->val);
    gopcode(OGT, n->type, n, nodconst(r->val));
    sp = p;
    gbranch(OGOTO);
    p->as = AJEQ;
    patch(p, r->label);
    swit1(q, i, def, n);

    if(debug['K'])
        print("case < %.8llux\n", r->val);
    patch(sp, pc);
    swit1(r+1, nc-i-1, def, n);
}
@

<<function bitload(x86)>>=
void
bitload(Node *b, Node *n1, Node *n2, Node *n3, Node *nn)
{
    int sh;
    long v;
    Node *l;

    /*
     * n1 gets adjusted/masked value
     * n2 gets address of cell
     * n3 gets contents of cell
     */
    l = b->left;
    if(n2 != Z) {
        regalloc(n1, l, nn);
        reglcgen(n2, l, Z);
        regalloc(n3, l, Z);
        gmove(n2, n3);
        gmove(n3, n1);
    } else {
        regalloc(n1, l, nn);
        cgen(l, n1);
    }
    if(b->type->shift == 0 && typeu[b->type->etype]) {
        v = ~0 + (1L << b->type->nbits);
        gopcode(OAND, types[TLONG], nodconst(v), n1);
    } else {
        sh = 32 - b->type->shift - b->type->nbits;
        if(sh > 0)
            gopcode(OASHL, types[TLONG], nodconst(sh), n1);
        sh += b->type->shift;
        if(sh > 0)
            if(typeu[b->type->etype])
                gopcode(OLSHR, types[TLONG], nodconst(sh), n1);
            else
                gopcode(OASHR, types[TLONG], nodconst(sh), n1);
    }
}
@
% >>

<<function bitstore(x86)>>=
void
bitstore(Node *b, Node *n1, Node *n2, Node *n3, Node *nn)
{
    long v;
    Node nod;
    int sh;

    regalloc(&nod, b->left, Z);
    v = ~0 + (1L << b->type->nbits);
    gopcode(OAND, types[TLONG], nodconst(v), n1);
    gmove(n1, &nod);
    if(nn != Z)
        gmove(n1, nn);
    sh = b->type->shift;
    if(sh > 0)
        gopcode(OASHL, types[TLONG], nodconst(sh), &nod);
    v <<= sh;
    gopcode(OAND, types[TLONG], nodconst(~v), n3);
    gopcode(OOR, types[TLONG], n3, &nod);
    gmove(&nod, n2);

    regfree(&nod);
    regfree(n1);
    regfree(n2);
    regfree(n3);
}
@

% >> >>

<<function outstring(x86)>>=
long
outstring(char *s, long n)
{
    long r;

    if(suppress)
        return nstring;
    r = nstring;
    while(n) {
        string[mnstring] = *s++;
        mnstring++;
        nstring++;
        if(mnstring >= NSNAME) {
            gpseudo(ADATA, symstring, nodconst(0L));
            p->from.offset += nstring - NSNAME;
            p->from.scale = NSNAME;
            p->to.type = D_SCONST;
            memmove(p->to.sval, string, NSNAME);
            mnstring = 0;
        }
        n--;
    }
    return r;
}
@

<<function gextern(x86)>>=
void
gextern(Sym *s, Node *a, long o, long w)
{
    if(a->op == OCONST && typev[a->type->etype]) {
        gpseudo(ADATA, s, lo64(a));
        p->from.offset += o;
        p->from.scale = 4;
        gpseudo(ADATA, s, hi64(a));
        p->from.offset += o + 4;
        p->from.scale = 4;
        return;
    }
    gpseudo(ADATA, s, a);
    p->from.offset += o;
    p->from.scale = w;
    switch(p->to.type) {
    default:
        p->to.index = p->to.type;
        p->to.type = D_ADDR;
    case D_CONST:
    case D_FCONST:
    case D_ADDR:
        break;
    }
}
@

% set via pragma
% seems dead, not initialized so probably 0
<<global packflg>>=
int	packflg;
@

<<function align(x86)>>=
long
align(long i, Type *t, int op)
{
    long o;
    Type *v;
    int w;

    o = i;
    w = 1;
    switch(op) {
    default:
        diag(Z, "unknown align opcode %d", op);
        break;

    case Asu2:	/* padding at end of a struct */
        w = SZ_LONG;
        if(packflg)
            w = packflg;
        break;

    case Ael1:	/* initial allign of struct element */
        for(v=t; v->etype==TARRAY; v=v->link)
            ;
        w = ewidth[v->etype];
        if(w <= 0 || w >= SZ_LONG)
            w = SZ_LONG;
        if(packflg)
            w = packflg;
        break;

    case Ael2:	/* width of a struct element */
        o += t->width;
        break;

    case Aarg0:	/* initial passbyptr argument in arg list */
        if(typesuv[t->etype]) {
            o = align(o, types[TIND], Aarg1);
            o = align(o, types[TIND], Aarg2);
        }
        break;

    case Aarg1:	/* initial allign of parameter */
        w = ewidth[t->etype];
        if(w <= 0 || w >= SZ_LONG) {
            w = SZ_LONG;
            break;
        }
        w = 1;		/* little endian no adjustment */
        break;

    case Aarg2:	/* width of a parameter */
        o += t->width;
        w = SZ_LONG;
        break;

    case Aaut3:	/* total allign of automatic */
        o = align(o, t, Ael1);
        o = align(o, t, Ael2);
        break;
    }
    o = round(o, w);
    if(debug['A'])
        print("align %s %ld %T = %ld\n", bnames[op], i, t, o);
    return o;
}
@

<<function maxround(x86)>>=
long
maxround(long max, long v)
{
    v = round(v, SZ_LONG);
    if(v > max)
        return v;
    return max;
}
@


%-------------------------------------------------------------

<<8c/swt.c>>=
#include "gc.h"

<<function swit1(x86)>>

<<function bitload(x86)>>

<<function bitstore(x86)>>

<<function outstring(x86)>>

<<function gextern(x86)>>

void	zname(Biobuf*, Sym*, int);
void	zaddr(Biobuf*, Adr*, int);
void	outhist(Biobuf*);

<<struct Htab(x86)>>

<<function outcode(x86)>>

<<function outhist(x86)>>

<<function zname(x86)>>

<<function zaddr(x86)>>

<<function align(x86)>>

<<function maxround(x86)>>
@


\subsection*{[[8c/mul.c]]}

%-------------------------------------------------------------

<<8c/mul.c>>=
#include "gc.h"

typedef struct	Malg	Malg;
typedef struct	Mparam	Mparam;

<<struct Malg(x86)>>

<<struct Mparam(x86)>>

<<global multab(x86)>>
<<global mulptr(x86)>>

<<global malgs(x86)>>

<<function lowbit(x86)>>

<<function genmuladd(x86)>>

<<function mulparam(x86)>>

<<function m0(x86)>>

<<function m1(x86)>>

<<function m2(x86)>>

<<function shiftit(x86)>>

<<function mulgen1(x86)>>

<<function mulgen(x86)>>
@


\subsection*{[[8c/div.c]]}

%-------------------------------------------------------------

<<8c/div.c>>=
#include "gc.h"

<<function TN(x86)>>
<<constant T31(x86)>>
<<constant T32(x86)>>

<<function multiplier(x86)>>

<<function sdiv(x86)>>

<<function udiv(x86)>>

<<function sdivgen(x86)>>

<<function udivgen(x86)>>

<<function sext(x86)>>

<<function sdiv2(x86)>>

<<function smod2(x86)>>
@


\subsection*{[[8c/reg.c]]}

<<function rega(x86)>>=
Reg*
rega(void)
{
    Reg *r;

    r = freer;
    if(r == R) {
        r = alloc(sizeof(*r));
    } else
        freer = r->link;

    *r = zreg;
    return r;
}
@

<<function rcmp(x86)>>=
int
rcmp(const void *a1, const void *a2)
{
    Rgn *p1, *p2;
    int c1, c2;

    p1 = (Rgn*)a1;
    p2 = (Rgn*)a2;
    c1 = p2->cost;
    c2 = p1->cost;
    if(c1 -= c2)
        return c1;
    return p2->varno - p1->varno;
}
@

<<struct Regopt_helper(x86)>>=
struct Regopt_helper {
        long	m;
        long	c;
        Reg*	p;
};
@

<<function regopt(x86)>>=
void
regopt(Prog *p)
{
    Reg *r, *r1, *r2;
    Prog *p1;
    int i, z;
    long initpc, val, npc;
    ulong vreg;
    Bits bit;
    struct Regopt_helper log5[6], *lp;

    firstr = R;
    lastr = R;
    nvar = 0;
    regbits = RtoB(D_SP) | RtoB(D_AX);
    for(z=0; z<BITS; z++) {
        externs.b[z] = 0;
        params.b[z] = 0;
        consts.b[z] = 0;
        addrs.b[z] = 0;
    }

    /*
     * pass 1
     * build aux data structure
     * allocate pcs
     * find use and set of variables
     */
    val = 5L * 5L * 5L * 5L * 5L;
    lp = log5;
    for(i=0; i<5; i++) {
        lp->m = val;
        lp->c = 0;
        lp->p = R;
        val /= 5L;
        lp++;
    }
    val = 0;
    for(; p != P; p = p->link) {
        switch(p->as) {
        case ADATA:
        case AGLOBL:
        case ANAME:
        case ASIGNAME:
            continue;
        }
        r = rega();
        if(firstr == R) {
            firstr = r;
            lastr = r;
        } else {
            lastr->link = r;
            r->p1 = lastr;
            lastr->s1 = r;
            lastr = r;
        }
        r->prog = p;
        r->pc = val;
        val++;

        lp = log5;
        for(i=0; i<5; i++) {
            lp->c--;
            if(lp->c <= 0) {
                lp->c = lp->m;
                if(lp->p != R)
                    lp->p->log5 = r;
                lp->p = r;
                (lp+1)->c = 0;
                break;
            }
            lp++;
        }

        r1 = r->p1;
        if(r1 != R)
        switch(r1->prog->as) {
        case ARET:
        case AJMP:
        case AIRETL:
            r->p1 = R;
            r1->s1 = R;
        }

        bit = mkvar(r, &p->from, p->as==AMOVL);
        if(bany(&bit))
        switch(p->as) {
        /*
         * funny
         */
        case ALEAL:
            for(z=0; z<BITS; z++)
                addrs.b[z] |= bit.b[z];
            break;

        /*
         * left side read
         */
        default:
            for(z=0; z<BITS; z++)
                r->use1.b[z] |= bit.b[z];
            break;
        }

        bit = mkvar(r, &p->to, 0);
        if(bany(&bit))
        switch(p->as) {
        default:
            diag(Z, "reg: unknown op: %A", p->as);
            break;

        /*
         * right side read
         */
        case ACMPB:
        case ACMPL:
        case ACMPW:
            for(z=0; z<BITS; z++)
                r->use2.b[z] |= bit.b[z];
            break;

        /*
         * right side write
         */
        case ANOP:
        case AMOVL:
        case AMOVB:
        case AMOVW:
        case AMOVBLSX:
        case AMOVBLZX:
        case AMOVWLSX:
        case AMOVWLZX:
            for(z=0; z<BITS; z++)
                r->set.b[z] |= bit.b[z];
            break;

        /*
         * right side read+write
         */
        case AADDB:
        case AADDL:
        case AADDW:
        case AANDB:
        case AANDL:
        case AANDW:
        case ASUBB:
        case ASUBL:
        case ASUBW:
        case AORB:
        case AORL:
        case AORW:
        case AXORB:
        case AXORL:
        case AXORW:
        case ASALB:
        case ASALL:
        case ASALW:
        case ASARB:
        case ASARL:
        case ASARW:
        case AROLB:
        case AROLL:
        case AROLW:
        case ARORB:
        case ARORL:
        case ARORW:
        case ASHLB:
        case ASHLL:
        case ASHLW:
        case ASHRB:
        case ASHRL:
        case ASHRW:
        case AIMULL:
        case AIMULW:
        case ANEGL:
        case ANOTL:
        case AADCL:
        case ASBBL:
            for(z=0; z<BITS; z++) {
                r->set.b[z] |= bit.b[z];
                r->use2.b[z] |= bit.b[z];
            }
            break;

        /*
         * funny
         */
        case AFMOVDP:
        case AFMOVFP:
        case AFMOVLP:
        case AFMOVVP:
        case AFMOVWP:
        case ACALL:
            for(z=0; z<BITS; z++)
                addrs.b[z] |= bit.b[z];
            break;
        }

        switch(p->as) {
        case AIMULL:
        case AIMULW:
            if(p->to.type != D_NONE)
                break;

        case AIDIVB:
        case AIDIVL:
        case AIDIVW:
        case AIMULB:
        case ADIVB:
        case ADIVL:
        case ADIVW:
        case AMULB:
        case AMULL:
        case AMULW:

        case ACWD:
        case ACDQ:
            r->regu |= RtoB(D_AX) | RtoB(D_DX);
            break;

        case AREP:
        case AREPN:
        case ALOOP:
        case ALOOPEQ:
        case ALOOPNE:
            r->regu |= RtoB(D_CX);
            break;

        case AMOVSB:
        case AMOVSL:
        case AMOVSW:
        case ACMPSB:
        case ACMPSL:
        case ACMPSW:
            r->regu |= RtoB(D_SI) | RtoB(D_DI);
            break;

        case ASTOSB:
        case ASTOSL:
        case ASTOSW:
        case ASCASB:
        case ASCASL:
        case ASCASW:
            r->regu |= RtoB(D_AX) | RtoB(D_DI);
            break;

        case AINSB:
        case AINSL:
        case AINSW:
        case AOUTSB:
        case AOUTSL:
        case AOUTSW:
            r->regu |= RtoB(D_DI) | RtoB(D_DX);
            break;

        case AFSTSW:
        case ASAHF:
            r->regu |= RtoB(D_AX);
            break;
        }
    }
    if(firstr == R)
        return;
    initpc = pc - val;
    npc = val;

    /*
     * pass 2
     * turn branch references to pointers
     * build back pointers
     */
    for(r = firstr; r != R; r = r->link) {
        p = r->prog;
        if(p->to.type == D_BRANCH) {
            val = p->to.offset - initpc;
            r1 = firstr;
            while(r1 != R) {
                r2 = r1->log5;
                if(r2 != R && val >= r2->pc) {
                    r1 = r2;
                    continue;
                }
                if(r1->pc == val)
                    break;
                r1 = r1->link;
            }
            if(r1 == R) {
                nearln = p->lineno;
                diag(Z, "ref not found\n%P", p);
                continue;
            }
            if(r1 == r) {
                nearln = p->lineno;
                diag(Z, "ref to self\n%P", p);
                continue;
            }
            r->s2 = r1;
            r->p2link = r1->p2;
            r1->p2 = r;
        }
    }
    if(debug['R']) {
        p = firstr->prog;
        print("\n%L %D\n", p->lineno, &p->from);
    }

    /*
     * pass 2.5
     * find looping structure
     */
    for(r = firstr; r != R; r = r->link)
        r->active = 0;
    change = 0;
    loopit(firstr, npc);
    if(debug['R'] && debug['v']) {
        print("\nlooping structure:\n");
        for(r = firstr; r != R; r = r->link) {
            print("%ld:%P", r->loop, r->prog);
            for(z=0; z<BITS; z++)
                bit.b[z] = r->use1.b[z] |
                       r->use2.b[z] |
                       r->set.b[z];
            if(bany(&bit)) {
                print("\t");
                if(bany(&r->use1))
                    print(" u1=%B", r->use1);
                if(bany(&r->use2))
                    print(" u2=%B", r->use2);
                if(bany(&r->set))
                    print(" st=%B", r->set);
            }
            print("\n");
        }
    }

    /*
     * pass 3
     * iterate propagating usage
     * 	back until flow graph is complete
     */
loop1:
    change = 0;
    for(r = firstr; r != R; r = r->link)
        r->active = 0;
    for(r = firstr; r != R; r = r->link)
        if(r->prog->as == ARET)
            prop(r, zbits, zbits);
loop11:
    /* pick up unreachable code */
    i = 0;
    for(r = firstr; r != R; r = r1) {
        r1 = r->link;
        if(r1 && r1->active && !r->active) {
            prop(r, zbits, zbits);
            i = 1;
        }
    }
    if(i)
        goto loop11;
    if(change)
        goto loop1;


    /*
     * pass 4
     * iterate propagating register/variable synchrony
     * 	forward until graph is complete
     */
loop2:
    change = 0;
    for(r = firstr; r != R; r = r->link)
        r->active = 0;
    synch(firstr, zbits);
    if(change)
        goto loop2;


    /*
     * pass 5
     * isolate regions
     * calculate costs (paint1)
     */
    r = firstr;
    if(r) {
        for(z=0; z<BITS; z++)
            bit.b[z] = (r->refahead.b[z] | r->calahead.b[z]) &
              ~(externs.b[z] | params.b[z] | addrs.b[z] | consts.b[z]);
        if(bany(&bit)) {
            nearln = r->prog->lineno;
            warn(Z, "used and not set: %B", bit);
            if(debug['R'] && !debug['w'])
                print("used and not set: %B\n", bit);
        }
    }
    if(debug['R'] && debug['v'])
        print("\nprop structure:\n");
    for(r = firstr; r != R; r = r->link)
        r->act = zbits;
    rgp = region;
    nregion = 0;
    for(r = firstr; r != R; r = r->link) {
        if(debug['R'] && debug['v']) {
            print("%P\t", r->prog);
            if(bany(&r->set))
                print("s:%B ", r->set);
            if(bany(&r->refahead))
                print("ra:%B ", r->refahead);
            if(bany(&r->calahead))
                print("ca:%B ", r->calahead);
            print("\n");
        }
        for(z=0; z<BITS; z++)
            bit.b[z] = r->set.b[z] &
              ~(r->refahead.b[z] | r->calahead.b[z] | addrs.b[z]);
        if(bany(&bit)) {
            nearln = r->prog->lineno;
            warn(Z, "set and not used: %B", bit);
            if(debug['R'])
                print("set and not used: %B\n", bit);
            excise(r);
        }
        for(z=0; z<BITS; z++)
            bit.b[z] = LOAD(r) & ~(r->act.b[z] | addrs.b[z]);
        while(bany(&bit)) {
            i = bnum(bit);
            rgp->enter = r;
            rgp->varno = i;
            change = 0;
            if(debug['R'] && debug['v'])
                print("\n");
            paint1(r, i);
            bit.b[i/32] &= ~(1L<<(i%32));
            if(change <= 0) {
                if(debug['R'])
                    print("%L$%d: %B\n",
                        r->prog->lineno, change, blsh(i));
                continue;
            }
            rgp->cost = change;
            nregion++;
            if(nregion >= NRGN) {
                warn(Z, "too many regions");
                goto brk;
            }
            rgp++;
        }
    }
brk:
    qsort(region, nregion, sizeof(region[0]), rcmp);

    /*
     * pass 6
     * determine used registers (paint2)
     * replace code (paint3)
     */
    rgp = region;
    for(i=0; i<nregion; i++) {
        bit = blsh(rgp->varno);
        vreg = paint2(rgp->enter, rgp->varno);
        vreg = allreg(vreg, rgp);
        if(debug['R']) {
            print("%L$%d %R: %B\n",
                rgp->enter->prog->lineno,
                rgp->cost,
                rgp->regno,
                bit);
        }
        if(rgp->regno != 0)
            paint3(rgp->enter, rgp->varno, vreg, rgp->regno);
        rgp++;
    }
    /*
     * pass 7
     * peep-hole on basic block
     */
    if(!debug['R'] || debug['P'])
        peep();

    /*
     * pass 8
     * recalculate pc
     */
    val = initpc;
    for(r = firstr; r != R; r = r1) {
        r->pc = val;
        p = r->prog;
        p1 = P;
        r1 = r->link;
        if(r1 != R)
            p1 = r1->prog;
        for(; p != p1; p = p->link) {
            switch(p->as) {
            default:
                val++;
                break;

            case ANOP:
            case ADATA:
            case AGLOBL:
            case ANAME:
            case ASIGNAME:
                break;
            }
        }
    }
    pc = val;

    /*
     * fix up branches
     */
    if(debug['R'])
        if(bany(&addrs))
            print("addrs: %B\n", addrs);

    r1 = 0; /* set */
    for(r = firstr; r != R; r = r->link) {
        p = r->prog;
        if(p->to.type == D_BRANCH)
            p->to.offset = r->s2->pc;
        r1 = r;
    }

    /*
     * last pass
     * eliminate nops
     * free aux structures
     */
    for(p = firstr->prog; p != P; p = p->link){
        while(p->link && p->link->as == ANOP)
            p->link = p->link->link;
    }
    if(r1 != R) {
        r1->link = freer;
        freer = firstr;
    }
}
@

<<function addmove(x86)>>=
/*
 * add mov b,rn
 * just after r
 */
void
addmove(Reg *r, int bn, int rn, int f)
{
    Prog *p, *p1;
    Adr *a;
    Var *v;

    p1 = alloc(sizeof(*p1));
    *p1 = zprog;
    p = r->prog;

    p1->link = p->link;
    p->link = p1;
    p1->lineno = p->lineno;

    v = var + bn;

    a = &p1->to;
    a->sym = v->sym;
    a->offset = v->offset;
    a->etype = v->etype;
    a->type = v->name;

    p1->as = AMOVL;
    if(v->etype == TCHAR || v->etype == TUCHAR)
        p1->as = AMOVB;
    if(v->etype == TSHORT || v->etype == TUSHORT)
        p1->as = AMOVW;

    p1->from.type = rn;
    if(!f) {
        p1->from = *a;
        *a = zprog.from;
        a->type = rn;
        if(v->etype == TUCHAR)
            p1->as = AMOVB;
        if(v->etype == TUSHORT)
            p1->as = AMOVW;
    }
    if(debug['R'])
        print("%P\t.a%P\n", p, p1);
}
@

<<function doregbits(x86)>>=
ulong
doregbits(int r)
{
    ulong b;

    b = 0;
    if(r >= D_INDIR)
        r -= D_INDIR;
    if(r >= D_AX && r <= D_DI)
        b |= RtoB(r);
    else
    if(r >= D_AL && r <= D_BL)
        b |= RtoB(r-D_AL+D_AX);
    else
    if(r >= D_AH && r <= D_BH)
        b |= RtoB(r-D_AH+D_AX);
    return b;
}
@

<<function mkvar(x86)>>=
Bits
mkvar(Reg *r, Adr *a, int isro)
{
    Var *v;
    int i, t, n, et, z;
    long o;
    Bits bit;
    Sym *s;

    /*
     * mark registers used
     */
    t = a->type;
    r->regu |= doregbits(t);
    r->regu |= doregbits(a->index);
    et = a->etype;

    switch(t) {
    default:
        goto none;
    case D_INDIR+D_GS:
        if(!isro || 1)
            goto none;
        n = t;
        {static Sym er; a->sym = &er;}
        a->sym->name = "$extreg"; // $
        break;
    case D_ADDR:
        a->type = a->index;
        bit = mkvar(r, a, 0);
        for(z=0; z<BITS; z++)
            addrs.b[z] |= bit.b[z];
        a->type = t;
        goto none;
    case D_EXTERN:
    case D_STATIC:
    case D_PARAM:
    case D_AUTO:
        n = t;
        break;
    }
    s = a->sym;
    if(s == S)
        goto none;
    if(s->name[0] == '.')
        goto none;
    o = a->offset;
    v = var;
    for(i=0; i<nvar; i++) {
        if(s == v->sym)
        if(n == v->name)
        if(o == v->offset)
            goto out;
        v++;
    }
    if(nvar >= NVAR) {
        if(debug['w'] > 1 && s)
            warn(Z, "variable not optimized: %s", s->name);
        goto none;
    }
    i = nvar;
    nvar++;
    v = &var[i];
    v->sym = s;
    v->offset = o;
    v->name = n;
    v->etype = et;
    if(debug['R'])
        print("bit=%2d et=%2d %D\n", i, et, a);

out:
    bit = blsh(i);
    if(n == D_EXTERN || n == D_STATIC)
        for(z=0; z<BITS; z++)
            externs.b[z] |= bit.b[z];
    if(n == D_PARAM)
        for(z=0; z<BITS; z++)
            params.b[z] |= bit.b[z];
    if(v->etype != et || !typechlpfd[et])	/* funny punning */
        for(z=0; z<BITS; z++)
            addrs.b[z] |= bit.b[z];
    return bit;

none:
    return zbits;
}
@

<<function prop(x86)>>=
void
prop(Reg *r, Bits ref, Bits cal)
{
    Reg *r1, *r2;
    int z;

    for(r1 = r; r1 != R; r1 = r1->p1) {
        for(z=0; z<BITS; z++) {
            ref.b[z] |= r1->refahead.b[z];
            if(ref.b[z] != r1->refahead.b[z]) {
                r1->refahead.b[z] = ref.b[z];
                change++;
            }
            cal.b[z] |= r1->calahead.b[z];
            if(cal.b[z] != r1->calahead.b[z]) {
                r1->calahead.b[z] = cal.b[z];
                change++;
            }
        }
        switch(r1->prog->as) {
        case ACALL:
            for(z=0; z<BITS; z++) {
                cal.b[z] |= ref.b[z] | externs.b[z];
                ref.b[z] = 0;
            }
            break;

        case ATEXT:
            for(z=0; z<BITS; z++) {
                cal.b[z] = 0;
                ref.b[z] = 0;
            }
            break;

        case ARET:
            for(z=0; z<BITS; z++) {
                cal.b[z] = externs.b[z];
                ref.b[z] = 0;
            }
        }
        for(z=0; z<BITS; z++) {
            ref.b[z] = (ref.b[z] & ~r1->set.b[z]) |
                r1->use1.b[z] | r1->use2.b[z];
            cal.b[z] &= ~(r1->set.b[z] | r1->use1.b[z] | r1->use2.b[z]);
            r1->refbehind.b[z] = ref.b[z];
            r1->calbehind.b[z] = cal.b[z];
        }
        if(r1->active)
            break;
        r1->active = 1;
    }
    for(; r != r1; r = r->p1)
        for(r2 = r->p2; r2 != R; r2 = r2->p2link)
            prop(r2, r->refbehind, r->calbehind);
}
@
%$


<<function postorder(x86)>>=
/*
 * find looping structure
 *
 * 1) find reverse postordering
 * 2) find approximate dominators,
 *	the actual dominators if the flow graph is reducible
 *	otherwise, dominators plus some other non-dominators.
 *	See Matthew S. Hecht and Jeffrey D. Ullman,
 *	"Analysis of a Simple Algorithm for Global Data Flow Problems",
 *	Conf.  Record of ACM Symp. on Principles of Prog. Langs, Boston, Massachusetts,
 *	Oct. 1-3, 1973, pp.  207-217.
 * 3) find all nodes with a predecessor dominated by the current node.
 *	such a node is a loop head.
 *	recursively, all preds with a greater rpo number are in the loop
 */
long
postorder(Reg *r, Reg **rpo2r, long n)
{
    Reg *r1;

    r->rpo = 1;
    r1 = r->s1;
    if(r1 && !r1->rpo)
        n = postorder(r1, rpo2r, n);
    r1 = r->s2;
    if(r1 && !r1->rpo)
        n = postorder(r1, rpo2r, n);
    rpo2r[n] = r;
    n++;
    return n;
}
@

<<function rpolca(x86)>>=
long
rpolca(long *idom, long rpo1, long rpo2)
{
    long t;

    if(rpo1 == -1)
        return rpo2;
    while(rpo1 != rpo2){
        if(rpo1 > rpo2){
            t = rpo2;
            rpo2 = rpo1;
            rpo1 = t;
        }
        while(rpo1 < rpo2){
            t = idom[rpo2];
            if(t >= rpo2)
                fatal(Z, "bad idom");
            rpo2 = t;
        }
    }
    return rpo1;
}
@

<<function doms(x86)>>=
int
doms(long *idom, long r, long s)
{
    while(s > r)
        s = idom[s];
    return s == r;
}
@

<<function loophead(x86)>>=
int
loophead(long *idom, Reg *r)
{
    long src;

    src = r->rpo;
    if(r->p1 != R && doms(idom, src, r->p1->rpo))
        return 1;
    for(r = r->p2; r != R; r = r->p2link)
        if(doms(idom, src, r->rpo))
            return 1;
    return 0;
}
@

<<function loopmark(x86)>>=
void
loopmark(Reg **rpo2r, long head, Reg *r)
{
    if(r->rpo < head || r->active == head)
        return;
    r->active = head;
    r->loop += LOOP;
    if(r->p1 != R)
        loopmark(rpo2r, head, r->p1);
    for(r = r->p2; r != R; r = r->p2link)
        loopmark(rpo2r, head, r);
}
@

<<function loopit(x86)>>=
void
loopit(Reg *r, long nr)
{
    Reg *r1;
    long i, d, me;

    if(nr > maxnr) {
        rpo2r = alloc(nr * sizeof(Reg*));
        idom = alloc(nr * sizeof(long));
        maxnr = nr;
    }

    d = postorder(r, rpo2r, 0);
    if(d > nr)
        fatal(Z, "too many reg nodes");
    nr = d;
    for(i = 0; i < nr / 2; i++){
        r1 = rpo2r[i];
        rpo2r[i] = rpo2r[nr - 1 - i];
        rpo2r[nr - 1 - i] = r1;
    }
    for(i = 0; i < nr; i++)
        rpo2r[i]->rpo = i;

    idom[0] = 0;
    for(i = 0; i < nr; i++){
        r1 = rpo2r[i];
        me = r1->rpo;
        d = -1;
        if(r1->p1 != R && r1->p1->rpo < me)
            d = r1->p1->rpo;
        for(r1 = r1->p2; r1 != nil; r1 = r1->p2link)
            if(r1->rpo < me)
                d = rpolca(idom, d, r1->rpo);
        idom[i] = d;
    }

    for(i = 0; i < nr; i++){
        r1 = rpo2r[i];
        r1->loop++;
        if(r1->p2 != R && loophead(idom, r1))
            loopmark(rpo2r, i, r1);
    }
}
@

<<function synch(x86)>>=
void
synch(Reg *r, Bits dif)
{
    Reg *r1;
    int z;

    for(r1 = r; r1 != R; r1 = r1->s1) {
        for(z=0; z<BITS; z++) {
            dif.b[z] = (dif.b[z] &
                ~(~r1->refbehind.b[z] & r1->refahead.b[z])) |
                    r1->set.b[z] | r1->regdiff.b[z];
            if(dif.b[z] != r1->regdiff.b[z]) {
                r1->regdiff.b[z] = dif.b[z];
                change++;
            }
        }
        if(r1->active)
            break;
        r1->active = 1;
        for(z=0; z<BITS; z++)
            dif.b[z] &= ~(~r1->calbehind.b[z] & r1->calahead.b[z]);
        if(r1->s2 != R)
            synch(r1->s2, dif);
    }
}
@

<<function allreg(x86)>>=
ulong
allreg(ulong b, Rgn *r)
{
    Var *v;
    int i;

    v = var + r->varno;
    r->regno = 0;
    switch(v->etype) {

    default:
        diag(Z, "unknown etype %d/%d", bitno(b), v->etype);
        break;

    case TCHAR:
    case TUCHAR:
    case TSHORT:
    case TUSHORT:
    case TINT:
    case TUINT:
    case TLONG:
    case TULONG:
    case TIND:
    case TARRAY:
        i = BtoR(~b);
        if(i && r->cost > 0) {
            r->regno = i;
            return RtoB(i);
        }
        break;

    case TDOUBLE:
    case TFLOAT:
        break;
    }
    return 0;
}
@

<<function paint1(x86)>>=
void
paint1(Reg *r, int bn)
{
    Reg *r1;
    Prog *p;
    int z;
    ulong bb;

    z = bn/32;
    bb = 1L<<(bn%32);
    if(r->act.b[z] & bb)
        return;
    for(;;) {
        if(!(r->refbehind.b[z] & bb))
            break;
        r1 = r->p1;
        if(r1 == R)
            break;
        if(!(r1->refahead.b[z] & bb))
            break;
        if(r1->act.b[z] & bb)
            break;
        r = r1;
    }

    if(LOAD(r) & ~(r->set.b[z]&~(r->use1.b[z]|r->use2.b[z])) & bb) {
        change -= CLOAD * r->loop;
        if(debug['R'] && debug['v'])
            print("%ld%P\tld %B $%d\n", r->loop,
                r->prog, blsh(bn), change);
    }
    for(;;) {
        r->act.b[z] |= bb;
        p = r->prog;

        if(r->use1.b[z] & bb) {
            change += CREF * r->loop;
            if(p->as == AFMOVL || p->as == AFMOVW)
                if(BtoR(bb) != D_F0)
                    change = -CINF;
            if(debug['R'] && debug['v'])
                print("%ld%P\tu1 %B $%d\n", r->loop,
                    p, blsh(bn), change);
        }

        if((r->use2.b[z]|r->set.b[z]) & bb) {
            change += CREF * r->loop;
            if(p->as == AFMOVL || p->as == AFMOVW)
                if(BtoR(bb) != D_F0)
                    change = -CINF;
            if(debug['R'] && debug['v'])
                print("%ld%P\tu2 %B $%d\n", r->loop,
                    p, blsh(bn), change);
        }

        if(STORE(r) & r->regdiff.b[z] & bb) {
            change -= CLOAD * r->loop;
            if(p->as == AFMOVL || p->as == AFMOVW)
                if(BtoR(bb) != D_F0)
                    change = -CINF;
            if(debug['R'] && debug['v'])
                print("%ld%P\tst %B $%d\n", r->loop,
                    p, blsh(bn), change);
        }

        if(r->refbehind.b[z] & bb)
            for(r1 = r->p2; r1 != R; r1 = r1->p2link)
                if(r1->refahead.b[z] & bb)
                    paint1(r1, bn);

        if(!(r->refahead.b[z] & bb))
            break;
        r1 = r->s2;
        if(r1 != R)
            if(r1->refbehind.b[z] & bb)
                paint1(r1, bn);
        r = r->s1;
        if(r == R)
            break;
        if(r->act.b[z] & bb)
            break;
        if(!(r->refbehind.b[z] & bb))
            break;
    }
}
@

<<function regset(x86)>>=
ulong
regset(Reg *r, ulong bb)
{
    ulong b, set;
    Adr v;
    int c;

    set = 0;
    v = zprog.from;
    while(b = bb & ~(bb-1)) {
        v.type = BtoR(b);
        c = copyu(r->prog, &v, A);
        if(c == 3)
            set |= b;
        bb &= ~b;
    }
    return set;
}
@

<<function reguse(x86)>>=
ulong
reguse(Reg *r, ulong bb)
{
    ulong b, set;
    Adr v;
    int c;

    set = 0;
    v = zprog.from;
    while(b = bb & ~(bb-1)) {
        v.type = BtoR(b);
        c = copyu(r->prog, &v, A);
        if(c == 1 || c == 2 || c == 4)
            set |= b;
        bb &= ~b;
    }
    return set;
}
@

<<function paint2(x86)>>=
ulong
paint2(Reg *r, int bn)
{
    Reg *r1;
    int z;
    ulong bb, vreg, x;

    z = bn/32;
    bb = 1L << (bn%32); // >>
    vreg = regbits;
    if(!(r->act.b[z] & bb))
        return vreg;
    for(;;) {
        if(!(r->refbehind.b[z] & bb))
            break;
        r1 = r->p1;
        if(r1 == R)
            break;
        if(!(r1->refahead.b[z] & bb))
            break;
        if(!(r1->act.b[z] & bb))
            break;
        r = r1;
    }
    for(;;) {
        r->act.b[z] &= ~bb;

        vreg |= r->regu;

        if(r->refbehind.b[z] & bb)
            for(r1 = r->p2; r1 != R; r1 = r1->p2link)
                if(r1->refahead.b[z] & bb)
                    vreg |= paint2(r1, bn);

        if(!(r->refahead.b[z] & bb))
            break;
        r1 = r->s2;
        if(r1 != R)
            if(r1->refbehind.b[z] & bb)
                vreg |= paint2(r1, bn);
        r = r->s1;
        if(r == R)
            break;
        if(!(r->act.b[z] & bb))
            break;
        if(!(r->refbehind.b[z] & bb))
            break;
    }

    bb = vreg;
    for(; r; r=r->s1) {
        x = r->regu & ~bb;
        if(x) {
            vreg |= reguse(r, x);
            bb |= regset(r, x);
        }
    }
    return vreg;
}
@

<<function paint3(x86)>>=
void
paint3(Reg *r, int bn, long rb, int rn)
{
    Reg *r1;
    Prog *p;
    int z;
    ulong bb;

    z = bn/32;
    bb = 1L << (bn%32); // >>
    if(r->act.b[z] & bb)
        return;
    for(;;) {
        if(!(r->refbehind.b[z] & bb))
            break;
        r1 = r->p1;
        if(r1 == R)
            break;
        if(!(r1->refahead.b[z] & bb))
            break;
        if(r1->act.b[z] & bb)
            break;
        r = r1;
    }

    if(LOAD(r) & ~(r->set.b[z] & ~(r->use1.b[z]|r->use2.b[z])) & bb)
        addmove(r, bn, rn, 0);
    for(;;) {
        r->act.b[z] |= bb;
        p = r->prog;

        if(r->use1.b[z] & bb) {
            if(debug['R'])
                print("%P", p);
            addreg(&p->from, rn);
            if(debug['R'])
                print("\t.c%P\n", p);
        }
        if((r->use2.b[z]|r->set.b[z]) & bb) {
            if(debug['R'])
                print("%P", p);
            addreg(&p->to, rn);
            if(debug['R'])
                print("\t.c%P\n", p);
        }

        if(STORE(r) & r->regdiff.b[z] & bb)
            addmove(r, bn, rn, 1);
        r->regu |= rb;

        if(r->refbehind.b[z] & bb)
            for(r1 = r->p2; r1 != R; r1 = r1->p2link)
                if(r1->refahead.b[z] & bb)
                    paint3(r1, bn, rb, rn);

        if(!(r->refahead.b[z] & bb))
            break;
        r1 = r->s2;
        if(r1 != R)
            if(r1->refbehind.b[z] & bb)
                paint3(r1, bn, rb, rn);
        r = r->s1;
        if(r == R)
            break;
        if(r->act.b[z] & bb)
            break;
        if(!(r->refbehind.b[z] & bb))
            break;
    }
}
@
% >>

<<function addreg(x86)>>=
void
addreg(Adr *a, int rn)
{

    a->sym = 0;
    a->offset = 0;
    a->type = rn;
}
@

<<function RtoB(x86)>>=
long
RtoB(int r)
{

    if(r < D_AX || r > D_DI)
        return 0;
    return 1L << (r-D_AX);
}
@

% >>

<<function BtoR(x86)>>=
int
BtoR(long b)
{

    b &= 0xffL;
    if(b == 0)
        return 0;
    return bitno(b) + D_AX;
}
@


%-------------------------------------------------------------

<<8c/reg.c>>=
#include "gc.h"

void	addreg(Adr*, int);
int	rcmp(const void*, const void*);
void	addmove(Reg*, int, int, int);
Bits	mkvar(Reg*, Adr*, int);
void	prop(Reg*, Bits, Bits);
void	loopit(Reg*, long);
void	synch(Reg*, Bits);
ulong	allreg(ulong, Rgn*);
void	paint1(Reg*, int);
ulong	paint2(Reg*, int);
void	paint3(Reg*, int, long, int);

long	RtoB(int);
//long	FtoB(int);
int	BtoR(long);
//int	BtoF(long);

<<function rega(x86)>>

<<function rcmp(x86)>>

<<struct Regopt_helper(x86)>>

<<function regopt(x86)>>

<<function addmove(x86)>>

<<function doregbits(x86)>>

<<function mkvar(x86)>>

<<function prop(x86)>>

<<function postorder(x86)>>

<<function rpolca(x86)>>

<<function doms(x86)>>

<<function loophead(x86)>>

<<function loopmark(x86)>>

<<function loopit(x86)>>

<<function synch(x86)>>

<<function allreg(x86)>>

<<function paint1(x86)>>

<<function regset(x86)>>

<<function reguse(x86)>>

<<function paint2(x86)>>

<<function paint3(x86)>>

<<function addreg(x86)>>

<<function RtoB(x86)>>

<<function BtoR(x86)>>
@
% >>

\subsection*{[[8c/cgen64.c]]}

%-------------------------------------------------------------

<<8c/cgen64.c>>=
#include "gc.h"

long	lo64v(Node*);
long	hi64v(Node*);

<<function zeroregm(x86)>>

<<function vaddr(x86)>>

<<function hi64v(x86)>>

<<function lo64v(x86)>>

<<function hi64(x86)>>

<<function lo64(x86)>>

<<function anonreg(x86)>>

<<function regpair(x86)>>

<<function evacaxdx(x86)>>

<<function instpair(x86)>>

<<function zapreg(x86)>>

<<function freepair(x86)>>

<<function loadpair(x86)>>

<<function storepair(x86)>>

<<enum _anon_ (8c/cgen64.c)>>

<<function whatof(x86)>>

<<function reduxv(x86)>>

<<function cond(x86)>>

<<function vfunc(x86)>>

<<function getreg(x86)>>

<<function snarfreg(x86)>>

<<enum _anon_ (8c/cgen64.c)2>>

<<global testi(x86)>>

<<global shll00(x86)>>

<<global shllc0(x86)>>

<<global shllc1(x86)>>

<<global shllc2(x86)>>

<<global shllac3(x86)>>

<<global shllac4(x86)>>

<<global shll10(x86)>>

<<global shlltab(x86)>>

<<global shrl00(x86)>>

<<global shrlc0(x86)>>

<<global shrlc1(x86)>>

<<global shrlc2(x86)>>

<<global shrlac3(x86)>>

<<global shrlac4(x86)>>

<<global shrl10(x86)>>

<<global shrltab(x86)>>

<<global asshllgen(x86)>>

<<global asshllclo(x86)>>

<<global asshllc32(x86)>>

<<global asshllchi(x86)>>

<<global asdshllgen(x86)>>

<<global asdshllclo(x86)>>

<<global asdshllc32(x86)>>

<<global asdshllchi(x86)>>

<<global asshlltab(x86)>>

<<global asshrlgen(x86)>>

<<global asshrlclo(x86)>>

<<global asshrlc32(x86)>>

<<global asshrlchi(x86)>>

<<global asdshrlgen(x86)>>

<<global asdshrlclo(x86)>>

<<global asdshrlc32(x86)>>

<<global asdshrlchi(x86)>>

<<global asshrltab(x86)>>

<<global shrlargs(x86)>>
<<global sarlargs(x86)>>

<<global incdec(x86)>>

<<global incdecpre(x86)>>

<<global incdecpost(x86)>>

<<global binop00(x86)>>

<<global binoptmp(x86)>>

<<global binop11(x86)>>

<<global add0c(x86)>>

<<global and0c(x86)>>

<<global or0c(x86)>>

<<global sub10(x86)>>

<<global addca(x86)>>

<<global andca(x86)>>

<<global orca(x86)>>

<<global subca(x86)>>

<<global addac(x86)>>

<<global orac(x86)>>

<<global andac(x86)>>

<<global ADDargs(x86)>>
<<global ANDargs(x86)>>
<<global ORargs(x86)>>
<<global SUBargs(x86)>>
<<global XORargs(x86)>>

<<global ADDtab(x86)>>

<<global ANDtab(x86)>>

<<global ORtab(x86)>>

<<global SUBtab(x86)>>

<<global mulc32(x86)>>

<<global mulc64(x86)>>

<<global mull(x86)>>

<<global castrp(x86)>>

<<global castrpa(x86)>>

<<global netab0i(x86)>>

<<global netabii(x86)>>

<<global cmptab0i(x86)>>

<<global cmptabii(x86)>>

<<global NEtab(x86)>>

<<global cmptab(x86)>>

<<global GEargs(x86)>>
<<global GTargs(x86)>>
<<global HIargs(x86)>>
<<global HSargs(x86)>>

<<function biggen(x86)>>

<<function IMM(x86)>>

<<function WW(x86)>>

<<function cgen64(x86)>>

<<function testv(x86)>>
@


\subsection*{[[8c/cgen.c]]}

%-------------------------------------------------------------

<<8c/cgen.c>>=
#include "gc.h"

void	bcgen(Node*, int);

<<function cgen(x86)>>

<<function reglcgen(x86)>>

<<function lcgen(x86)>>

<<function bcgen(x86)>>

<<function boolgen(x86)>>

<<function sugen(x86)>>
@
