\section{[[include/]]}

%pad: to please syncweb -to_tex checker
\ifallcode
<<libc/9syscall/sys.h>>=
@
<<libc/9syscall/codegraph.c>>=
@
<<libc/codegraph.c>>=
@
<<libc/port/runetypebody-6.2.0.h>>=
@
<<libc/port/runebase.c>>=
@
%ugly, should filter it in 'mk index'
<<pfff_macros.h>>=
@
\fi

\subsection*{[[include/arm/u.h]]}

% Most of the definitions below could be in libc.h because there is 
% no diff between arm/u.h and 386/u.h and there is no really 
% 16 vs 32 vs 64 bits material (except the uxxxint)

<<include/arch/arm/u.h>>=

<<type [[uxxx]]>>

<<type [[uxxxint]]>>

<<type [[xxxvlong]]>>

typedef signed char schar;
<<type [[usize]]>>

<<constant [[nil]]>>
<<type [[uintptr]]>>

<<type [[Rune]]>>
<<type [[mpdigit]]>>

<<type [[jmpbufxxx]]>>
<<type [[jmp_buf]]>>

<<type [[FPxxx]]>>
<<type [[FPdbleword]]>>
typedef     union FPdbleword FPdbleword;

<<type [[va_list]]>>

<<macro [[va_start]]>>
<<macro [[va_end]]>>
<<macro [[va_arg]]>>

@

\subsection*{[[include/libc.h]]}

<<include/libc.h>>=
#pragma lib "libc.a"
#pragma src "/sys/src/libc"

// --------------------------------------------
// pad's stuff
// --------------------------------------------
// More types! Types are good!
<<type [[bool]]>>

<<type [[byte]]>>

typedef uchar bool_byte;

//typedef char* string; // conflict
//typedef char* filename; // conflict in sam with function filename

<<constant [[STDxxx]]>>
<<type [[fdt]]>>

<<constant [[OKxxx]]>>
<<constant [[ERRORxxx]]>>
<<type [[errorxxx]]>>

// --------------------------------------------
// end pad's stuff
// --------------------------------------------

<<function [[nelem]]>>
<<function [[offsetof]]>>

typedef struct Fmt Fmt;
typedef struct Tm Tm;
typedef struct Lock Lock;
typedef struct QLp QLp;
typedef struct QLock QLock;
typedef struct RWLock RWLock;
typedef struct Rendez Rendez;
typedef struct NetConnInfo NetConnInfo;
typedef struct Qid Qid;
typedef struct Dir Dir;
typedef struct Waitmsg Waitmsg;
typedef struct IOchunk IOchunk;

/*
 * mem routines
 */
extern  void*   memset(void*, int, ulong);
extern  void*   memcpy(void*, void*, ulong);
extern  int     memcmp(void*, void*, ulong);
extern  void*   memchr(void*, int, ulong);

// less useful?
extern  void*   memmove(void*, void*, ulong);
extern  void*   memccpy(void*, void*, int, ulong);



/*
 * string routines
 */
// memxxx equivalent, but with special handling for '\0' (no need pass ulong)
extern  char*   strcpy(char*, char*);
extern  int     strcmp(char*, char*);
extern  char*   strchr(char*, int);
extern  char*   strrchr(char*, int);

extern  long    strlen(char*);
extern  char*   strdup(char*);
extern  char*   strcat(char*, char*);
extern  char*   strstr(char*, char*);

extern  int tolower(int);
extern  int toupper(int);

// less useful?
extern  char*   strecpy(char*, char*, char*);
extern  char*   strncat(char*, char*, long);
extern  char*   strncpy(char*, char*, long);
extern  int     strncmp(char*, char*, long);

extern  char*   strpbrk(char*, char*);

extern  long    strspn(char*, char*);
extern  long    strcspn(char*, char*);

extern  int     cistrncmp(char*, char*, int);
extern  int     cistrcmp(char*, char*);
extern  char*   cistrstr(char*, char*);

extern  char*   strtok(char*, char*);
extern  int     tokenize(char*, char**, int);

enum
{
    <<constant [[UTFmax]]>>
    <<constant [[Runesync]]>>
    <<constant [[Runeself]]>>
    <<constant [[Runeerror]]>>
    <<constant [[Runemax]]>>
    <<constant [[Runemask]]>>
};

/*
 * rune routines
 */

// char <-> rune conversion
extern  int chartorune(Rune*, char*);
extern  int runetochar(char*, Rune*);

// strxxx equivalent for rune
extern  Rune*   runestrcpy(Rune*, Rune*);
extern  int     runestrcmp(Rune*, Rune*);
extern  Rune*   runestrchr(Rune*, Rune);
extern  Rune*   runestrrchr(Rune*, Rune);

extern  long    runestrlen(Rune*);
extern  Rune*   runestrdup(Rune*);
extern  Rune*   runestrcat(Rune*, Rune*);
extern  Rune*   runestrstr(Rune*, Rune*);

// less useful
extern  Rune*   runestrecpy(Rune*, Rune*, Rune*);
extern  Rune*   runestrncpy(Rune*, Rune*, long);
extern  Rune*   runestrncat(Rune*, Rune*, long);
extern  int     runestrncmp(Rune*, Rune*, long);

extern  Rune    tolowerrune(Rune);
extern  Rune    toupperrune(Rune);

extern  int isalpharune(Rune);
extern  int isdigitrune(Rune);
extern  int islowerrune(Rune);
extern  int isupperrune(Rune);
extern  int isspacerune(Rune);

// ??
extern  Rune    totitlerune(Rune);
extern  Rune    tobaserune(Rune);
extern  int istitlerune(Rune);
extern  int isbaserune(Rune);

// ?????
extern  int runelen(long);
extern  int runenlen(Rune*, int);
extern  int fullrune(char*, int);

// strxxx equivalent for utf
extern  int utflen(char*);
extern  char*   utfrune(char*, long);

// less useful?
extern  int utfnlen(char*, long);
extern  char*   utfrrune(char*, long);
extern  char*   utfutf(char*, char*);
extern  char*   utfecpy(char*, char*, char*);

/*
 * malloc
 */
extern  void*   malloc(ulong);
extern  void    free(void*);

// less useful
extern  void*   mallocz(ulong, bool);
extern  void*   calloc(ulong, ulong);
extern  void*   realloc(void*, ulong);
extern  ulong   msize(void*);
extern  void*   mallocalign(ulong, ulong, long, ulong);

// internals
extern  void    setmalloctag(void*, ulong);
extern  void    setrealloctag(void*, ulong);
extern  ulong   getmalloctag(void*);
extern  ulong   getrealloctag(void*);
extern  void*   malloctopoolblock(void*);

/*
 * print routines
 */
<<type [[Fmt]]>>

<<type [[Fmt_flag]]>>

// pad: used to be just print()? but for cg transformed in a pointer func
extern  int     (*print)(char*, ...);
extern  int     sprint(char*, char*, ...);
extern  int     fprint(fdt, char*, ...);

extern  int     vfprint(fdt, char*, va_list);
extern  char*   vseprint(char*, char*, char*, va_list);

extern  int     runesprint(Rune*, char*, ...);

// less useful
extern  char*   seprint(char*, char*, char*, ...);
extern  int     snprint(char*, int, char*, ...);
extern  char*   smprint(char*, ...);

extern  int     vsnprint(char*, int, char*, va_list);
extern  char*   vsmprint(char*, va_list);

extern  Rune*   runeseprint(Rune*, Rune*, char*, ...);
extern  int     runesnprint(Rune*, int, char*, ...);
extern  Rune*   runesmprint(char*, ...);

extern  Rune*   runevseprint(Rune*, Rune*, char*, va_list);
extern  int     runevsnprint(Rune*, int, char*, va_list);
extern  Rune*   runevsmprint(char*, va_list);

extern  int     fmtfdinit(Fmt*, int, char*, int);

extern  int     fmtfdflush(Fmt*);
extern  int     fmtstrinit(Fmt*);
extern  char*   fmtstrflush(Fmt*);
extern  int     runefmtstrinit(Fmt*);
extern  Rune*   runefmtstrflush(Fmt*);

#pragma varargck    argpos  fmtprint    2
#pragma varargck    argpos  fprint      2
#pragma varargck    argpos  print       1
#pragma varargck    argpos  runeseprint 3
#pragma varargck    argpos  runesmprint 1
#pragma varargck    argpos  runesnprint 3
#pragma varargck    argpos  runesprint  2
#pragma varargck    argpos  seprint     3
#pragma varargck    argpos  smprint     1
#pragma varargck    argpos  snprint     3
#pragma varargck    argpos  sprint      2

// %d = decimal, o = octal, x = hexa, b = binary?
#pragma varargck    type    "d" int
#pragma varargck    type    "o" int
#pragma varargck    type    "x" int
#pragma varargck    type    "b" int
// %f
#pragma varargck    type    "f" double
#pragma varargck    type    "e" double
#pragma varargck    type    "g" double
// %s
#pragma varargck    type    "s" char*
#pragma varargck    type    "q" char*
#pragma varargck    type    "S" Rune*
#pragma varargck    type    "Q" Rune*
#pragma varargck    type    "r" void
#pragma varargck    type    "%" void
#pragma varargck    type    "n" int*
#pragma varargck    type    "p" uintptr
#pragma varargck    type    "p" void*
#pragma varargck    type    "c" int
#pragma varargck    type    "C" int
#pragma varargck    type    "d" uint
#pragma varargck    type    "x" uint
#pragma varargck    type    "b" uint
#pragma varargck    type    "c" uint
#pragma varargck    type    "C" uint
#pragma varargck    type    "<" void*
#pragma varargck    type    "[" void*
#pragma varargck    type    "H" void*
#pragma varargck    type    "lH"    void*

#pragma varargck    type    "lld"   vlong
#pragma varargck    type    "llo"   vlong
#pragma varargck    type    "llx"   vlong
#pragma varargck    type    "llb"   vlong

#pragma varargck    type    "lld"   uvlong
#pragma varargck    type    "llo"   uvlong
#pragma varargck    type    "llx"   uvlong
#pragma varargck    type    "llb"   uvlong

#pragma varargck    type    "ld"    long
#pragma varargck    type    "lo"    long
#pragma varargck    type    "lx"    long
#pragma varargck    type    "lb"    long

#pragma varargck    type    "ld"    ulong
#pragma varargck    type    "lo"    ulong
#pragma varargck    type    "lx"    ulong
#pragma varargck    type    "lb"    ulong


#pragma varargck    flag    ','
#pragma varargck    flag    ' '
#pragma varargck    flag    'h'


extern  int fmtinstall(int, int (*)(Fmt*));

extern  int dofmt(Fmt*, char*);
extern  int dorfmt(Fmt*, Rune*);
extern  int fmtprint(Fmt*, char*, ...);
extern  int fmtvprint(Fmt*, char*, va_list);
extern  int fmtrune(Fmt*, int);
extern  int fmtstrcpy(Fmt*, char*);
extern  int fmtrunestrcpy(Fmt*, Rune*);
/*
 * error string for %r
 * supplied on per os basis, not part of fmt library
 */
extern  int errfmt(Fmt *f);

/*
 * quoted strings
 */
extern  char*   unquotestrdup(char*);
extern  Rune*   unquoterunestrdup(Rune*);
extern  char*   quotestrdup(char*);
extern  Rune*   quoterunestrdup(Rune*);
extern  int     quotestrfmt(Fmt*);
extern  int     quoterunestrfmt(Fmt*);
extern  void    quotefmtinstall(void);
extern  int     (*doquote)(int);
extern  int     needsrcquote(int);

/*
 * random number
 */
extern  void    srand(long);

extern  int     rand(void);
extern  double  frand(void);
extern  int     nrand(int);
extern  ulong   truerand(void);         /* uses /dev/random */

// less useful
extern  long    lrand(void);
extern  long    lnrand(long);
extern  ulong   ntruerand(ulong);       /* uses /dev/random */

/*
 * math
 */
extern  int     abs(int);
//extern  long    labs(long);
extern  double  frexp(double, int*);
extern  double  ldexp(double, int);
extern  double  modf(double, double*);
extern  double  pow10(int);

#define HUGE    3.4028234e38

extern  double  NaN(void);
extern  double  Inf(int);
extern  int     isNaN(double);
extern  int     isInf(double, int);

extern  double  fabs(double);
extern  double  floor(double);
extern  double  ceil(double);

extern  double  pow(double, double);
extern  double  log(double);
extern  double  log10(double);
extern  double  exp(double);
extern  double  sqrt(double);
extern  double  hypot(double, double);
extern  double  fmod(double, double);

#define PIO2    1.570796326794896619231e0
#define PI  (PIO2+PIO2)

extern  double  sin(double);
extern  double  cos(double);
extern  double  tan(double);
extern  double  asin(double);
extern  double  acos(double);
extern  double  atan(double);
extern  double  atan2(double, double);
extern  double  sinh(double);
extern  double  cosh(double);
extern  double  tanh(double);


// conversion
extern  double  atof(char*);
extern  int     atoi(char*);
extern  long    atol(char*);
extern  vlong   atoll(char*);

extern  double  strtod(char*, char**);
extern  long    strtol(char*, char**, int);
extern  ulong   strtoul(char*, char**, int);
extern  vlong   strtoll(char*, char**, int);
extern  uvlong  strtoull(char*, char**, int);

// internals?
extern  ulong   getfcr(void);
extern  void    setfsr(ulong);
extern  ulong   getfsr(void);
extern  void    setfcr(ulong);

extern  ulong   umuldiv(ulong, ulong, ulong);
extern  long    muldiv(long, long, long);



/*
 * Time-of-day
 */
<<type [[Tm]]>>

extern  long    time(long*);

extern  double  cputime(void);
extern  vlong   nsec(void);

extern  Tm*     gmtime(long);
extern  Tm*     localtime(long);

extern  long    tm2sec(Tm*);

// less useful?
extern  char*   asctime(Tm*);
extern  char*   ctime(long);
extern  long    times(long*);

extern  void    cycles(uvlong*);    /* 64-bit value of the cycle counter if there is one, 0 if there isn't */



/*
 * one-of-a-kind
 */

// misc
extern  double  charstod(int(*)(void*), void*);

// modified in place, so type should really be void cleanname(INOUT char*);
extern  char*   cleanname(char*);
extern  int     encodefmt(Fmt*);

extern  int     getfields(char*, char**, int, int, char*);
extern  int     gettokens(char *, char **, int, char *);

extern  int     iounit(fdt);

// ugly redefined by user code? see statusbar.c
extern  void    qsort(void*, long, long, int (*)(void*, void*));


/*
 | debugging tools 
 */

<<macro [[assert]]>>
extern  void    (*_assert)(char*);
extern  void    perror(char*);
extern  void    sysfatal(char*, ...);
extern  void    syslog(int, char*, char*, ...);

#pragma varargck    argpos  sysfatal    1
#pragma varargck    argpos  syslog  3

extern  uintptr getcallerpc(void*);

/*
 *  profiling
 */
<<type [[Prof]]>>

extern  void    prof(void (*fn)(void*), void *arg, int entries, int what);


/*
 | concurrency
 */

extern  int     setjmp(jmp_buf);
extern  void    longjmp(jmp_buf, int);
extern  void    notejmp(void*, jmp_buf, int);

// IPC
<<type [[PostnoteKind]]>>
extern  int     postnote(int, int, char *);
extern  int     atnotify(int(*)(void*, char*), int);

extern  int     atexit(void(*)(void));
extern  void    atexitdont(void(*)(void));

/*
 * atomic
 */
extern long    ainc(long*);
extern long    adec(long*);

extern int     cas32(u32int*, u32int, u32int);
extern int     casp(void**, void*, void*);
extern int     casl(ulong*, ulong, ulong);

/*
 *  synchronization
 */
<<type [[Lock]]>>

extern int  _tas(int*);

extern  void    lock(Lock*);
extern  void    unlock(Lock*);
extern  int     canlock(Lock*);

<<type [[QLp]]>>

<<type [[QLock]]>>

extern  void    qlock(QLock*);
extern  void    qunlock(QLock*);
extern  int     canqlock(QLock*);

extern  void    _qlockinit(void* (*)(void*, void*));    /* called only by the thread library */

<<type [[RWLock]]>>


extern  void    rlock(RWLock*);
extern  void    runlock(RWLock*);
extern  int     canrlock(RWLock*);
extern  void    wlock(RWLock*);
extern  void    wunlock(RWLock*);
extern  int     canwlock(RWLock*);

<<type [[Rendez]]>>

extern  void    rsleep(Rendez*);    /* unlocks r->l, sleeps, locks r->l again */
extern  int     rwakeup(Rendez*);

extern  int     rwakeupall(Rendez*);
extern  void**  privalloc(void);
extern  void    privfree(void**);

/*
 *  network dialing
 */
#define NETPATHLEN 40
extern  int     accept(int, char*);
extern  int     announce(char*, char*);
extern  int     dial(char*, char*, char*, int*);
extern  void    setnetmtpt(char*, int, char*);
extern  int     hangup(int);
extern  int     listen(char*, char*);
extern  char*   netmkaddr(char*, char*, char*);
extern  int     reject(int, char*, char*);

/*
 *  network services
 */
<<type [[NetConnInfo]]>>
extern  NetConnInfo*    getnetconninfo(char*, int);
extern  void            freenetconninfo(NetConnInfo*);


/*
 *  encryption
 */
extern  int pushssl(int, char*, char*, char*, int*);
extern  int pushtls(int, char*, char*, int, char*, char*);

// encryption
extern  int decrypt(void*, void*, int);
extern  int encrypt(void*, void*, int);
extern  int netcrypt(void*, void*);

extern  int dec64(uchar*, int, char*, int);
extern  int enc64(char*, int, uchar*, int);
extern  int dec32(uchar*, int, char*, int);
extern  int enc32(char*, int, uchar*, int);
extern  int dec16(uchar*, int, char*, int);
extern  int enc16(char*, int, uchar*, int);


/*
 * system calls
 *
 */
#include <syscall.h>



// getopt like macros
<<signature global argv0>>
<<macro [[ARGBEGIN]]>>
<<macro [[ARGEND]]>>
<<macro [[ARGF]]>>
<<macro [[EARGF]]>>
<<macro [[ARGC]]>>


/* this is used by sbrk and brk,  it's a really bad idea to redefine it */
extern  char    end[];

@

\subsection*{[[include/ctype.h]]}

<<include/ctype.h>>=
#pragma	src	"/sys/src/libc/port"
#pragma	lib	"libc.a"

// could be merged in libc.h

<<type [[Ctype_flag]]>>

extern unsigned char	_ctype[];

<<macros isxxx>>
<<macro [[_toupper]]>>
<<macro [[_tolower]]>>
<<macro [[toascii]]>>
@

\subsection*{[[include/syscall.h]]}
%pad: I added this file, it was originally mixed in libc.h

<<include/syscall.h>>=
// you must include libc.h instead of this file

//----------------------------------------------------------------------------
// Data structures and constants
//----------------------------------------------------------------------------

<<type [[Namespace_flag]]>>

<<type [[Open_flag]]>>

<<type [[Access_flag]]>>

<<type [[Segattach_flag]]>>

<<type [[Note_flag]]>>

<<type [[Qid_type]]>>

<<type [[Dir_mode]]>>

<<type [[Rfork_flag]]>>

<<constant [[STATMAX]]>>

<<constant [[DIRMAX]]>>

<<constant [[ERRMAX]]>>

<<type [[Seek_cursor]]>>

<<type [[Qid]]>>

<<type [[DirEntry]]>>

<<type [[Waitmsg]]>>

<<type [[IOchunk]]>>

//----------------------------------------------------------------------------
// Functions
//----------------------------------------------------------------------------

// syscalls (and small wrappers around syscalls)

// process
extern	int		rfork(int);
extern	void	_exits(char*);
extern	int		exec(char*, char*[]);
extern	int		await(char*, int);

extern	int		fork(void);
extern  void    exits(char*);
extern	int		execl(char*, ...);
extern	void	abort(void);
extern	Waitmsg*	wait(void);
extern	int		waitpid(void);

extern	int		getpid(void);
extern	int		getppid(void);
extern  char*   getenv(char*);
extern  int     putenv(char*, char*);

// memory
extern	void*	sbrk(ulong);

// file
extern	fdt		open(char*, int);
extern	int		close(fdt);
extern	long	pread(fdt, void*, long, vlong);
extern	long	pwrite(fdt, void*, long, vlong);

extern	long	read(fdt, void*, long);
extern	long	write(fdt, void*, long);
extern	long	preadv(fdt, IOchunk*, int, vlong);
extern	long	pwritev(fdt, IOchunk*, int, vlong);
extern	long	readv(fdt, IOchunk*, int);
extern	long	writev(fdt, IOchunk*, int);
extern	vlong	seek(fdt, vlong, int);
// extern	int	fdflush(int);

extern	long	readn(fdt, void*, long);

// directory
extern	int		create(char*, int, ulong);
extern	int		remove(char*);
extern	int		chdir(char*);
extern	int		fd2path(fdt, char*, int);
extern	int		fstat(int, uchar*, int);
extern	int		stat(char*, uchar*, int);
extern	int		fwstat(int, uchar*, int);
extern	int		wstat(char*, uchar*, int);

extern  char*   getwd(char*, int);
extern  char*   mktemp(char*);

extern	Dir*	dirfstat(fdt);
extern	Dir*	dirstat(char*);
extern	int		dirfwstat(int, Dir*);
extern	int		dirwstat(char*, Dir*);
//
extern	long	dirread(int, Dir**);
extern	void	nulldir(Dir*);
extern	long	dirreadall(int, Dir**);
extern	int		access(char*, int); // ???

// namespace
extern	int		bind(char*, char*, int/*Mxxx*/);
extern	int		mount(fdt, int, char*, int/*Mxxx*/, char*);
extern	int		unmount(char*, char*);

// time
extern	long	alarm(ulong);
extern	int		sleep(long); //less: could be void (ulong). 0 means yield.

// IPC
extern	int		pipe(int*);
extern	int		noted(int);
extern	int		notify(void(*)(void*, char*));
extern	void*	segattach(int, char*, void*, ulong);
extern	void*	segbrk(void*, void*);
extern	int		segdetach(void*);
extern	int		segflush(void*, ulong);
extern	int		segfree(void*, ulong);

// concurrency
extern	void*	rendezvous(void*, void*);
extern	int		semacquire(long*, int);
extern	long	semrelease(long*, long);
extern	int		tsemacquire(long*, ulong);

// special files
extern	int		dup(int, int);

// security
extern	int		fauth(int, char*);
extern	int		fversion(int, int, char*, int);

extern  char*   getuser(void);

// error management
extern	int		errstr(char*, uint);

extern	void	werrstr(char*, ...);
extern	void	rerrstr(char*, uint);

#pragma	varargck	argpos	werrstr	1

//???
extern	char*	sysname(void);

@

\subsection*{[[include/regexp.h]]}

<<include/regexp.h>>=
#pragma src "/sys/src/libregexp"
#pragma lib "libregexp.a"

typedef struct Resub        Resub;
typedef struct Reclass      Reclass;
typedef struct Reinst       Reinst;
typedef struct Reprog       Reprog;

/*
 *  Sub expression matches
 */
struct Resub{
    union
    {
        char *sp;
        Rune *rsp;
    };
    union
    {
        char *ep;
        Rune *rep;
    };
};

/*
 *  character class, each pair of rune's defines a range
 */
struct Reclass{
    Rune    *end;
    Rune    spans[64];
};

/*
 *  Machine instructions
 */
struct Reinst{
    int type;
    union   {
        Reclass *cp;        /* class pointer */
        Rune    r;      /* character */
        int subid;      /* sub-expression id for RBRA and LBRA */
        Reinst  *right;     /* right child of OR */
    };
    union { /* regexp relies on these two being in the same union */
        Reinst *left;       /* left child of OR */
        Reinst *next;       /* next instruction for CAT & LBRA */
    };
};

/*
 *  Reprogram definition
 */
struct Reprog{
    Reinst  *startinst; /* start pc */
    Reclass class[16];  /* .data */
    Reinst  firstinst[5];   /* .text */
};

extern Reprog   *regcomp(char*);
extern Reprog   *regcomplit(char*);
extern Reprog   *regcompnl(char*);
extern void regerror(char*);
extern int  regexec(Reprog*, char*, Resub*, int);
extern void regsub(char*, char*, int, Resub*, int);
extern int  rregexec(Reprog*, Rune*, Resub*, int);
extern void rregsub(Rune*, Rune*, int, Resub*, int);
@


\subsection*{[[include/thread.h]]}

%dead: I think
% enum {
%     Nqwds = 2,
%     Nqshift = 5,       /* log₂ # of bits in long */
%     Nqmask =  -1,
%     Nqbits = (1 << Nqshift) * 2,
% };

%-------------------------------------------------------------

<<include/thread.h>>=
#pragma src "/sys/src/libthread"
#pragma lib "libthread.a"

#pragma varargck    argpos  chanprint   2

typedef struct Alt  Alt;
typedef struct Channel  Channel;
typedef struct Ref  Ref;
/* slave I/O processes */
typedef struct Ioproc Ioproc;
#pragma incomplete Ioproc

<<struct [[Channel]]>>

<<enum [[chanop]]>>
typedef enum chanop ChanOp;

<<struct [[Alt]]>>

<<struct [[Ref]]>>

long    decref(Ref *r);         /* returns 0 iff value is now zero */
void    incref(Ref *r);

Channel* chancreate(int elemsize, int bufsize);
int chanclose(Channel*);
int chanclosing(Channel *c);
int chaninit(Channel *c, int elemsize, int elemcnt);
void chanfree(Channel *c);
int chanprint(Channel *, char *, ...);

// blocking API
int recv(Channel *c, void *v);
void* recvp(Channel *c);
ulong recvul(Channel *c);
int send(Channel *c, void *v);
int sendp(Channel *c, void *v);
int sendul(Channel *c, ulong v);

// non blocking API
int nbrecv(Channel *c, void *v);
void* nbrecvp(Channel *c);
ulong nbrecvul(Channel *c);
int nbsend(Channel *c, void *v);
int nbsendp(Channel *c, void *v);
int nbsendul(Channel *c, ulong v);

// select
int alt(Alt alts[]);

// process
int proccreate(void (*f)(void *arg), void *arg, uint stacksize);
int procrfork(void (*f)(void *arg), void *arg, uint stacksize, int flag);
void**  procdata(void);
void    procexec(Channel *, char *, char *[]);
void    procexecl(Channel *, char *, ...);

// threads
int threadcreate(void (*f)(void *arg), void *arg, uint stacksize);
void**  threaddata(void);
void    threadexits(char *);
void    threadexitsall(char *);
void    threadmain(int argc, char *argv[]);
int threadid(void);

int threadgetgrp(void); /* return thread group of current thread */
int threadsetgrp(int);      /* set thread group, return old */
char*   threadgetname(void);
void    threadsetname(char *fmt, ...);
void    threadint(int);     /* interrupt thread */
void    threadintgrp(int);  /* interrupt threads in grp */
void    threadkill(int);    /* kill thread */
void    threadkillgrp(int); /* kill threads in group */
void    threadnonotes(void);
int threadnotify(int (*f)(void*, char*), int in);
int threadpid(int);
Channel*threadwaitchan(void);

// Io proc
Ioproc* ioproc(void);
void    closeioproc(Ioproc*);
void    iointerrupt(Ioproc*);

int ioopen(Ioproc*, char*, int);
int ioclose(Ioproc*, int);
long    ioread(Ioproc*, int, void*, long);
long    ioreadn(Ioproc*, int, void*, long);
long    iowrite(Ioproc*, int, void*, long);
int iosleep(Ioproc*, long);
int iodial(Ioproc*, char*, char*, char*, int*);

long    iocall(Ioproc*, long (*)(va_list*), ...);
void    ioret(Ioproc*, int);

// misc
void    needstack(int);
int tprivalloc(void);
void    tprivfree(int);
void    **tprivaddr(int);
void    yield(void);

extern  int mainstacksize;
@

\subsection*{[[include/core/internals/pool.h]]}

<<include/core/internals/pool.h>>=
typedef struct Pool Pool;

<<type [[Pool]]>>

extern void*	poolalloc(Pool*, ulong);
extern void	poolfree(Pool*, void*);

extern void*	poolallocalign(Pool*, ulong, ulong, long, ulong);
extern ulong	poolmsize(Pool*, void*);
extern void*	poolrealloc(Pool*, void*, ulong);
extern void	poolcheck(Pool*);
extern int	poolcompact(Pool*);
extern void	poolblockcheck(Pool*, void*);

// those globals are initialized in libc but also in the kernel itself
// so that the kernel can reuse the pool allocation code
extern Pool*	mainmem;
extern Pool*	imagmem;

<<type [[Pool_flag]]>>
@

\subsection{[[include/pool.h]]}

<<include/fcall.h>>=
#pragma src "/sys/src/libc/9sys"
#pragma lib "libc.a"

#define VERSION9P   "9P2000"

<<constant [[MAXWELEM]]>>

typedef struct  Fcall Fcall;

<<type [[Fcall]]>>

<<macros GBITxxx>>

<<macros PBITxxx>>

<<macros BITxxx>>

<<constant [[QIDSZ]]>>

<<constant [[STATFIXLEN]]>>


#define NOTAG       (ushort)~0U /* Dummy tag */
#define NOFID       (u32int)~0U /* Dummy fid */

<<constant [[IOHDRSZ]]>>

<<type [[FcallType]]>>


error0    convM2S(uchar*, uint, Fcall*);
error0    convS2M(Fcall*, uchar*, uint);
uint    sizeS2M(Fcall*);

int     statcheck(uchar *abuf, uint nbuf);
uint    convM2D(uchar*, uint, Dir*, char*);
uint    convD2M(Dir*, uchar*, uint);
uint    sizeD2M(Dir*);

// dumpers
int fcallfmt(Fmt*);
int dirfmt(Fmt*);
int dirmodefmt(Fmt*);

int read9pmsg(fdt, void*, uint);

#pragma varargck    type    "F" Fcall*
#pragma varargck    type    "M" ulong
#pragma varargck    type    "D" Dir*
@


\section{[[lib_core/libc/port]]}

\subsection*{[[libc/port/_assert.c]]}


%-------------------------------------------------------------

<<libc/port/_assert.c>>=
#include <u.h>
#include <libc.h>

<<global [[__assert]]>>


<<function [[default_assert]]>>

<<global [[_assert]]>>
@


\subsection*{[[libc/port/abs.c]]}

%dead: labs()

%-------------------------------------------------------------

<<libc/port/abs.c>>=
#include <u.h>
#include <libc.h>

<<function [[abs]]>>

@


\subsection*{[[libc/port/asin.c]]}


%-------------------------------------------------------------

<<libc/port/asin.c>>=
/*
 * asin(arg) and acos(arg) return the arcsin, arccos,
 * respectively of their arguments.
 *
 * Arctan is called after appropriate range reduction.
 */

#include <u.h>
#include <libc.h>

<<function [[asin]]>>

<<function [[acos]]>>
@


\subsection*{[[libc/port/atan.c]]}

<<constant [[sq2p1]]>>=
#define sq2p1 2.414213562373095048802e0
@

<<constant [[sq2m1]]>>=
#define sq2m1  .414213562373095048802e0
@

<<constant [[p4]]>>=
#define p4  .161536412982230228262e2
@

<<constant [[p3]]>>=
#define p3  .26842548195503973794141e3
@

<<constant [[p2]]>>=
#define p2  .11530293515404850115428136e4
@

<<constant [[p1]]>>=
#define p1  .178040631643319697105464587e4
@

<<constant [[p0]]>>=
#define p0  .89678597403663861959987488e3
@

<<constant [[q4]]>>=
#define q4  .5895697050844462222791e2
@

<<constant [[q3]]>>=
#define q3  .536265374031215315104235e3
@

<<constant [[q2]]>>=
#define q2  .16667838148816337184521798e4
@

<<constant [[q1]]>>=
#define q1  .207933497444540981287275926e4
@

<<constant [[q0]]>>=
#define q0  .89678597403663861962481162e3
@

<<function [[xatan]]>>=
/*
    xatan evaluates a series valid in the
    range [-0.414...,+0.414...]. (tan(pi/8))
 */

static
double
xatan(double arg)
{
    double argsq, value;

    argsq = arg*arg;
    value = ((((p4*argsq + p3)*argsq + p2)*argsq + p1)*argsq + p0);
    value = value/(((((argsq + q4)*argsq + q3)*argsq + q2)*argsq + q1)*argsq + q0);
    return value*arg;
}
@

<<function [[satan]]>>=
/*
    satan reduces its argument (known to be positive)
    to the range [0,0.414...] and calls xatan.
 */

static
double
satan(double arg)
{

    if(arg < sq2m1)
        return xatan(arg);
    if(arg > sq2p1)
        return PIO2 - xatan(1/arg);
    return PIO2/2 + xatan((arg-1)/(arg+1));
}
@



%-------------------------------------------------------------

<<libc/port/atan.c>>=
/*
    floating-point arctangent

    atan returns the value of the arctangent of its
    argument in the range [-pi/2,pi/2].

    atan2 returns the arctangent of arg1/arg2
    in the range [-pi,pi].

    there are no error returns.

    coefficients are #5077 from Hart & Cheney. (19.56D)
*/

#include <u.h>
#include <libc.h>

<<constant [[sq2p1]]>>
<<constant [[sq2m1]]>>
<<constant [[p4]]>>
<<constant [[p3]]>>
<<constant [[p2]]>>
<<constant [[p1]]>>
<<constant [[p0]]>>
<<constant [[q4]]>>
<<constant [[q3]]>>
<<constant [[q2]]>>
<<constant [[q1]]>>
<<constant [[q0]]>>


<<function [[xatan]]>>

<<function [[satan]]>>

<<function [[atan]]>>
@


\subsection*{[[libc/port/atan2.c]]}

<<function [[atan2]]>>=
/*
    atan2 discovers what quadrant the angle
    is in and calls atan.
*/

double
atan2(double arg1, double arg2)
{

    if(arg1+arg2 == arg1) {
        if(arg1 >= 0)
            return PIO2;
        return -PIO2;
    }
    arg1 = atan(arg1/arg2);
    if(arg2 < 0) {
        if(arg1 <= 0)
            return arg1 + PI;
        return arg1 - PI;
    }
    return arg1;
}
@


%-------------------------------------------------------------

<<libc/port/atan2.c>>=
#include <u.h>
#include <libc.h>

<<function [[atan2]]>>
@


\subsection*{[[libc/port/atexit.c]]}

%dead: <<function atexitdont>>

%-------------------------------------------------------------

<<libc/port/atexit.c>>=
#include <u.h>
#include <libc.h>

<<constant [[NEXIT]]>>

typedef struct Onex Onex;
<<struct [[Onex]]>>

<<global [[onexlock]]>>
<<global [[onex]]>>

<<function [[atexit]]>>

#pragma profile off
<<function [[exits]]>>
#pragma profile on
@


\subsection*{[[libc/port/atnotify.c]]}


%-------------------------------------------------------------

<<libc/port/atnotify.c>>=
#include <u.h>
#include <libc.h>

<<constant NFN (port/atnotify.c)>>
<<global [[onnot]]>>
<<global [[onnotlock]]>>

<<function [[notifier]]>>

<<function [[atnotify]]>>
@


\subsection*{[[libc/port/atof.c]]}

%-------------------------------------------------------------

<<libc/port/atof.c>>=
#include <u.h>
#include <libc.h>

<<function [[atof]]>>
@


\subsection*{[[libc/port/atol.c]]}

%-------------------------------------------------------------

<<libc/port/atol.c>>=
#include <u.h>
#include <libc.h>

<<function [[atol]]>>

<<function [[atoi]]>>
@


\subsection*{[[libc/port/atoll.c]]}

<<function [[atoll]]>>=
vlong
atoll(char *s)
{
    return strtoll(s, nil, 0);
}
@


%-------------------------------------------------------------

<<libc/port/atoll.c>>=
#include <u.h>
#include <libc.h>

<<function [[atoll]]>>
@


\subsection*{[[libc/port/charstod.c]]}

<<constant [[ADVANCE]]>>=
/*
 * Reads a floating-point number by interpreting successive characters
 * returned by (*f)(vp).  The last call it makes to f terminates the
 * scan, so is not a character in the number.  It may therefore be
 * necessary to back up the input stream up one byte after calling charstod.
 */

#define ADVANCE do{*s++ = c; if(s>=e) return NaN(); c = (*f)(vp);}while(0)
@

<<function [[charstod]]>>=
double
charstod(int(*f)(void*), void *vp)
{
    char str[400], *s, *e, *start;
    int c;

    s = str;
    e = str + sizeof str - 1;
    c = (*f)(vp);
    while(c == ' ' || c == '\t')
        c = (*f)(vp);
    if(c == '-' || c == '+'){
        ADVANCE;
    }
    start = s;
    while(c >= '0' && c <= '9'){
        ADVANCE;
    }
    if(c == '.'){
        ADVANCE;
        while(c >= '0' && c <= '9'){
            ADVANCE;
        }
    }
    if(s > start && (c == 'e' || c == 'E')){
        ADVANCE;
        if(c == '-' || c == '+'){
            ADVANCE;
        }
        while(c >= '0' && c <= '9'){
            ADVANCE;
        }
    }else if(s == start && (c == 'i' || c == 'I')){
        ADVANCE;
        if(c != 'n' && c != 'N')
            return NaN();
        ADVANCE;
        if(c != 'f' && c != 'F')
            return NaN();
        ADVANCE;
        if(c != 'i' && c != 'I')
            return NaN();
        ADVANCE;
        if(c != 'n' && c != 'N')
            return NaN();
        ADVANCE;
        if(c != 'i' && c != 'I')
            return NaN();
        ADVANCE;
        if(c != 't' && c != 'T')
            return NaN();
        ADVANCE;
        if(c != 'y' && c != 'Y')
            return NaN();
        ADVANCE;  /* so caller can back up uniformly */
        USED(c);
    }else if(s == str && (c == 'n' || c == 'N')){
        ADVANCE;
        if(c != 'a' && c != 'A')
            return NaN();
        ADVANCE;
        if(c != 'n' && c != 'N')
            return NaN();
        ADVANCE;  /* so caller can back up uniformly */
        USED(c);
    }
    *s = 0;
    return strtod(str, &s);
}
@


%-------------------------------------------------------------

<<libc/port/charstod.c>>=
#include <u.h>
#include <libc.h>

<<constant [[ADVANCE]]>>

<<function [[charstod]]>>
@


\subsection*{[[libc/port/cistrcmp.c]]}

<<function [[cistrcmp]]>>=
int
cistrcmp(char *s1, char *s2)
{
    int c1, c2;

    while(*s1){
        c1 = *(uchar*)s1++;
        c2 = *(uchar*)s2++;

        if(c1 == c2)
            continue;

        if(c1 >= 'A' && c1 <= 'Z')
            c1 -= 'A' - 'a';

        if(c2 >= 'A' && c2 <= 'Z')
            c2 -= 'A' - 'a';

        if(c1 != c2)
            return c1 - c2;
    }
    return -*s2;
}
@


%-------------------------------------------------------------

<<libc/port/cistrcmp.c>>=
#include <u.h>
#include <libc.h>

<<function [[cistrcmp]]>>
@


\subsection*{[[libc/port/cistrncmp.c]]}

<<function [[cistrncmp]]>>=
int
cistrncmp(char *s1, char *s2, int n)
{
    int c1, c2;

    while(*s1 && n-- > 0){
        c1 = *(uchar*)s1++;
        c2 = *(uchar*)s2++;

        if(c1 == c2)
            continue;

        if(c1 >= 'A' && c1 <= 'Z')
            c1 -= 'A' - 'a';

        if(c2 >= 'A' && c2 <= 'Z')
            c2 -= 'A' - 'a';

        if(c1 != c2)
            return c1 - c2;
    }
    if(n <= 0)
        return 0;
    return -*s2;
}
@


%-------------------------------------------------------------

<<libc/port/cistrncmp.c>>=
#include <u.h>
#include <libc.h>

<<function [[cistrncmp]]>>
@


\subsection*{[[libc/port/cistrstr.c]]}

<<function [[cistrstr]]>>=
char*
cistrstr(char *s, char *sub)
{
    int c, csub, n;

    csub = *sub;
    if(csub == '\0')
        return s;
    if(csub >= 'A' && csub <= 'Z')
        csub -= 'A' - 'a';
    sub++;
    n = strlen(sub);
    for(; c = *s; s++){
        if(c >= 'A' && c <= 'Z')
            c -= 'A' - 'a';
        if(c == csub && cistrncmp(s+1, sub, n) == 0)
            return s;
    }
    return nil;
}
@


%-------------------------------------------------------------

<<libc/port/cistrstr.c>>=
#include <u.h>
#include <libc.h>

<<function [[cistrstr]]>>
@


\subsection*{[[libc/port/cleanname.c]]}


%-------------------------------------------------------------

<<libc/port/cleanname.c>>=
#include <u.h>
#include <libc.h>

<<macro [[SEP]]>>
<<function [[cleanname]]>>
@


\subsection*{[[libc/port/crypt.c]]}



%-------------------------------------------------------------

<<libc/port/crypt.c>>=
/*
 *  Data Encryption Standard
 *  D.P.Mitchell  83/06/08.
 *
 *  block_cipher(key, block, decrypting)
 *
 *  these routines use the non-standard 7 byte format
 *  for DES keys.
 */
#include <u.h>
#include <libc.h>
#include <auth.h>
#include <libsec.h>

<<function [[encrypt]]>>

<<function [[decrypt]]>>
@


\subsection*{[[libc/port/ctype.c]]}



%-------------------------------------------------------------

<<libc/port/ctype.c>>=
#include <u.h>
#include <libc.h>
#include <ctype.h>

<<global [[_ctype]]>>
@


\subsection*{[[libc/port/encodefmt.c]]}

<<function [[encodefmt]]>>=
int
encodefmt(Fmt *f)
{
    char *out;
    char *buf;
    int len;
    int ilen;
    int rv;
    uchar *b;
    char *p;
    char obuf[64];  // rsc optimization

    if(!(f->flags&FmtPrec) || f->prec < 1)
        goto error;

    b = va_arg(f->args, uchar*);
    if(b == 0)
        return fmtstrcpy(f, "<nil>");

    ilen = f->prec;
    f->prec = 0;
    f->flags &= ~FmtPrec;
    switch(f->r){
    case '<':
        len = (8*ilen+4)/5 + 3;
        break;
    case '[':
        len = (8*ilen+5)/6 + 4;
        break;
    case 'H':
        len = 2*ilen + 1;
        break;
    default:
        goto error;
    }

    if(len > sizeof(obuf)){
        buf = malloc(len);
        if(buf == nil)
            goto error;
    } else
        buf = obuf;

    // convert
    out = buf;
    switch(f->r){
    case '<':
        rv = enc32(out, len, b, ilen);
        break;
    case '[':
        rv = enc64(out, len, b, ilen);
        break;
    case 'H':
        rv = enc16(out, len, b, ilen);
        if(rv >= 0 && (f->flags & FmtLong))
            for(p = buf; *p; p++)
                *p = tolower(*p);
        break;
    default:
        rv = -1;
        break;
    }
    if(rv < 0)
        goto error;

    fmtstrcpy(f, buf);
    if(buf != obuf)
        free(buf);
    return 0;

error:
    return fmtstrcpy(f, "<encodefmt>");
}
@


%-------------------------------------------------------------

<<libc/port/encodefmt.c>>=
#include <u.h>
#include <libc.h>
#include <ctype.h>

<<function [[encodefmt]]>>
@


\subsection*{[[libc/port/execl.c]]}



%-------------------------------------------------------------

<<libc/port/execl.c>>=
#include <u.h>
#include <libc.h>

<<function [[execl]]>>
@


\subsection*{[[libc/port/exp.c]]}



%-------------------------------------------------------------

<<libc/port/exp.c>>=
/*
    exp returns the exponential function of its
    floating-point argument.

    The coefficients are #1069 from Hart and Cheney. (22.35D)
*/

#include <u.h>
#include <libc.h>

<<constant p0 (port/exp.c)>>
<<constant p1 (port/exp.c)>>
<<constant p2 (port/exp.c)>>
<<constant q0 (port/exp.c)>>
<<constant q1 (port/exp.c)>>
<<constant q2 (port/exp.c)>>
<<constant [[log2e]]>>
<<constant [[sqrt2]]>>
<<constant [[maxf]]>>

<<function [[exp]]>>
@


\subsection*{[[libc/port/fabs.c]]}

%-------------------------------------------------------------

<<libc/port/fabs.c>>=
#include <u.h>
#include <libc.h>

<<function [[fabs]]>>
@


\subsection*{[[libc/port/floor.c]]}


%-------------------------------------------------------------

<<libc/port/floor.c>>=
#include <u.h>
#include <libc.h>
<<function [[floor]]>>

<<function [[ceil]]>>
@


\subsection*{[[libc/port/fmod.c]]}


%-------------------------------------------------------------

<<libc/port/fmod.c>>=
#include <u.h>
#include <libc.h>

<<function [[fmod]]>>
@


\subsection*{[[libc/port/frand.c]]}

<<constant [[MASK]]>>=
#define MASK    0x7fffffffL
@

<<constant [[NORM]]>>=
#define NORM    (1.0/(1.0+MASK))
@

<<function [[frand]]>>=
double
frand(void)
{
    double x;

    do {
        x = lrand() * NORM;
        x = (x + lrand()) * NORM;
    } while(x >= 1);
    return x;
}
@


%-------------------------------------------------------------

<<libc/port/frand.c>>=
#include    <u.h>
#include    <libc.h>

<<constant [[MASK]]>>
<<constant [[NORM]]>>

<<function [[frand]]>>
@


\subsection*{[[libc/port/frexp.c]]}



%-------------------------------------------------------------

<<libc/port/frexp.c>>=
#include <u.h>
#include <libc.h>

<<constant MASK (port/frexp.c)>>
<<constant [[SHIFT]]>>
<<constant [[BIAS]]>>
<<constant [[SIG]]>>

<<function [[frexp]]>>

<<function [[ldexp]]>>

<<function [[modf]]>>
@


\subsection*{[[libc/port/getcallerpc.c]]}

% implemented in assembly
<<function [[getcallerpc]]>>=
uintptr
getcallerpc(void*)
{
    return 0;
}
@


%-------------------------------------------------------------

<<libc/port/getcallerpc.c>>=
#include <u.h>
#include <libc.h>

<<function [[getcallerpc]]>>
@


\subsection*{[[libc/port/getfields.c]]}


%-------------------------------------------------------------

<<libc/port/getfields.c>>=
#include <u.h>
#include <libc.h>

<<function [[getfields]]>>
@


\subsection*{[[libc/port/getuser.c]]}



%-------------------------------------------------------------

<<libc/port/getuser.c>>=
#include <u.h>
#include <libc.h>

<<function [[getuser]]>>
@


\subsection*{[[libc/port/hangup.c]]}

<<function [[hangup]]>>=
/*
 *  force a connection to hangup
 */
int
hangup(int ctl)
{
    return write(ctl, "hangup", sizeof("hangup")-1) != sizeof("hangup")-1;
}
@


%-------------------------------------------------------------

<<libc/port/hangup.c>>=
#include <u.h>
#include <libc.h>
#include <ctype.h>

<<function [[hangup]]>>
@


\subsection*{[[libc/port/hypot.c]]}

<<function [[hypot]]>>=
double
hypot(double p, double q)
{
    double r, s, pfac;

    if(p < 0)
        p = -p;
    if(q < 0)
        q = -q;
    if(p < q) {
        r = p;
        p = q;
        q = r;
    }
    if(p == 0)
        return 0;
    pfac = p;
    r = q = q/p;
    p = 1;
    for(;;) {
        r *= r;
        s = r+4;
        if(s == 4)
            return p*pfac;
        r /= s;
        p += 2*r*p;
        q *= r;
        r = q/p;
    }
}
@


%-------------------------------------------------------------

<<libc/port/hypot.c>>=
/*
 * hypot -- sqrt(p*p+q*q), but overflows only if the result does.
 * See Cleve Moler and Donald Morrison,
 * ``Replacing Square Roots by Pythagorean Sums,''
 * IBM Journal of Research and Development,
 * Vol. 27, Number 6, pp. 577-581, Nov. 1983
 */

#include <u.h>
#include <libc.h>

<<function [[hypot]]>>
@


\subsection*{[[libc/port/lnrand.c]]}

<<constant MASK (port/lnrand.c)>>=
#define MASK    0x7fffffffL
@

<<function [[lnrand]]>>=
long
lnrand(long n)
{
    long slop, v;

    if(n < 0)
        return n;
    slop = MASK % n;
    do
        v = lrand();
    while(v <= slop);
    return v % n;
}
@


%-------------------------------------------------------------

<<libc/port/lnrand.c>>=
#include    <u.h>
#include    <libc.h>

<<constant MASK (port/lnrand.c)>>

<<function [[lnrand]]>>
@


\subsection*{[[libc/port/lock.c]]}


%-------------------------------------------------------------

<<libc/port/lock.c>>=
#include <u.h>
#include <libc.h>

<<function [[lock]]>>

<<function [[unlock]]>>

<<function [[canlock]]>>
@


\subsection*{[[libc/port/log.c]]}

%-------------------------------------------------------------

<<libc/port/log.c>>=
/*
    log returns the natural logarithm of its floating
    point argument.

    The coefficients are #2705 from Hart & Cheney. (19.38D)

    It calls frexp.
*/

#include <u.h>
#include <libc.h>

<<constant [[log2]]>>
<<constant [[ln10o1]]>>
<<constant [[sqrto2]]>>
<<constant p0 (port/log.c)>>
<<constant p1 (port/log.c)>>
<<constant p2 (port/log.c)>>
<<constant p3 (port/log.c)>>
<<constant q0 (port/log.c)>>
<<constant q1 (port/log.c)>>
<<constant q2 (port/log.c)>>

<<function [[log]]>>

<<function [[log10]]>>
@


\subsection*{[[libc/port/lrand.c]]}

<<constant [[LEN]]>>=
#define LEN 607
@

<<constant [[TAP]]>>=
#define TAP 273
@

<<constant MASK (port/lrand.c)>>=
#define MASK    0x7fffffffL
@

<<constant [[A]]>>=
#define A   48271
@

<<constant [[M]]>>=
#define M   2147483647
@

<<constant [[Q]]>>=
#define Q   44488
@

<<constant [[R]]>>=
#define R   3399
@

<<constant NORM (port/lrand.c)>>=
#define NORM    (1.0/(1.0+MASK))
@



<<function [[isrand]]>>=
static void
isrand(long seed)
{
    long lo, hi, x;
    int i;

    rng_tap = rng_vec;
    rng_feed = rng_vec+LEN-TAP;
    seed = seed%M;
    if(seed < 0)
        seed += M;
    if(seed == 0)
        seed = 89482311;
    x = seed;
    /*
     *  Initialize by x[n+1] = 48271 * x[n] mod (2**31 - 1)
     */
    for(i = -20; i < LEN; i++) {
        hi = x / Q;
        lo = x % Q;
        x = A*lo - R*hi;
        if(x < 0)
            x += M;
        if(i >= 0)
            rng_vec[i] = x;
    }
}
@

<<function [[srand]]>>=
void
srand(long seed)
{
    lock(&lk);
    isrand(seed);
    unlock(&lk);
}
@



%-------------------------------------------------------------

<<libc/port/lrand.c>>=
#include    <u.h>
#include    <libc.h>

/*
 *  algorithm by
 *  D. P. Mitchell & J. A. Reeds
 */

<<constant [[LEN]]>>
<<constant [[TAP]]>>
<<constant MASK (port/lrand.c)>>
<<constant [[A]]>>
<<constant [[M]]>>
<<constant [[Q]]>>
<<constant [[R]]>>
<<constant NORM (port/lrand.c)>>

<<global [[rng_vec]]>>
<<global [[rng_tap]]>>
<<global [[rng_feed]]>>
<<global [[lk]]>>

<<function [[isrand]]>>

<<function [[srand]]>>

<<function [[lrand]]>>
@


\subsection*{[[libc/port/malloc.c]]}


<<function [[sbrkalloc]]>>=
/*
 * we do minimal bookkeeping so we can tell pool
 * whether two blocks are adjacent and thus mergeable.
 */
static void*
sbrkalloc(ulong n)
{
    ulong *x;

    n += 2*sizeof(ulong);   /* two longs for us */
    x = sbrk(n);
    if(x == (void*)-1)
        return nil;
    x[0] = (n+7)&~7;    /* sbrk rounds size up to mult. of 8 */
    x[1] = 0xDeadBeef;
    return x+2;
}
@

<<function [[sbrkmerge]]>>=
static int
sbrkmerge(void *x, void *y)
{
    ulong *lx, *ly;

    lx = x;
    if(lx[-1] != 0xDeadBeef)
        abort();

    if((uchar*)lx+lx[-2] == (uchar*)y) {
        ly = y;
        lx[-2] += ly[-2];
        return 1;
    }
    return 0;
}
@

<<function [[plock]]>>=
static void
plock(Pool *p)
{
    Private *pv;
    pv = p->private;
    lock(&pv->lk);
    if(pv->pid != 0)
        abort();
    pv->pid = _tos->pid;
}
@

<<function [[punlock]]>>=
static void
punlock(Pool *p)
{
    Private *pv;
    pv = p->private;
    if(pv->pid != _tos->pid)
        abort();
    pv->pid = 0;
    unlock(&pv->lk);
}
@

<<function [[checkenv]]>>=
static int
checkenv(void)
{
    int n, fd;
    char buf[20];
    fd = open("/env/MALLOCFD", OREAD);
    if(fd < 0)
        return -1;
    if((n = read(fd, buf, sizeof buf)) < 0) {
        close(fd);
        return -1;
    }
    if(n >= sizeof buf)
        n = sizeof(buf)-1;
    buf[n] = 0;
    n = atoi(buf);
    if(n == 0)
        n = -1;
    return n;
}
@

<<function [[pprint]]>>=
static void
pprint(Pool *p, char *fmt, ...)
{
    va_list v;
    Private *pv;

    pv = p->private;
    if(pv->printfd == 0)
        pv->printfd = checkenv();

    if(pv->printfd <= 0)
        pv->printfd = 2;

    va_start(v, fmt);
    vfprint(pv->printfd, fmt, v);
    va_end(v);
}
@

<<global [[panicbuf]]>>=
static char panicbuf[256];
@

<<function [[ppanic]]>>=
static void
ppanic(Pool *p, char *fmt, ...) 
{
    va_list v;
    int n;
    char *msg;
    Private *pv;

    pv = p->private;
    assert(canlock(&pv->lk)==0);

    if(pv->printfd == 0)
        pv->printfd = checkenv();
    if(pv->printfd <= 0)
        pv->printfd = 2;

    msg = panicbuf;
    va_start(v, fmt);
    n = vseprint(msg, msg+sizeof panicbuf, fmt, v) - msg;
    write(2, "panic: ", 7);
    write(2, msg, n);
    write(2, "\n", 1);
    if(pv->printfd != 2){
        write(pv->printfd, "panic: ", 7);
        write(pv->printfd, msg, n);
        write(pv->printfd, "\n", 1);
    }
    va_end(v);
//  unlock(&pv->lk);
    abort();
}
@

<<enum [[_anon_]]>>=
/* tracing */
enum {
    Npadlong    = 2,
    MallocOffset = 0,
    ReallocOffset = 1
};
@


<<function [[mallocz]]>>=
void*
mallocz(ulong size, int clr)
{
    void *v;

    v = poolalloc(mainmem, size+Npadlong*sizeof(ulong));
    if(Npadlong && v != nil){
        v = (ulong*)v+Npadlong;
        setmalloctag(v, getcallerpc(&size));
        setrealloctag(v, 0);
    }
    if(clr && v != nil)
        memset(v, 0, size);
    return v;
}
@

<<function [[mallocalign]]>>=
void*
mallocalign(ulong size, ulong align, long offset, ulong span)
{
    void *v;

    v = poolallocalign(mainmem, size+Npadlong*sizeof(ulong), align, offset-Npadlong*sizeof(ulong), span);
    if(Npadlong && v != nil){
        v = (ulong*)v+Npadlong;
        setmalloctag(v, getcallerpc(&size));
        setrealloctag(v, 0);
    }
    return v;
}
@


<<function [[realloc]]>>=
void*
realloc(void *v, ulong size)
{
    void *nv;

    if(size == 0){
        free(v);
        return nil;
    }

    if(v)
        v = (ulong*)v-Npadlong;
    size += Npadlong*sizeof(ulong);

    if(nv = poolrealloc(mainmem, v, size)){
        nv = (ulong*)nv+Npadlong;
        setrealloctag(nv, getcallerpc(&v));
        if(v == nil)
            setmalloctag(nv, getcallerpc(&v));
    }       
    return nv;
}
@

<<function [[msize]]>>=
ulong
msize(void *v)
{
    return poolmsize(mainmem, (ulong*)v-Npadlong)-Npadlong*sizeof(ulong);
}
@

<<function [[calloc]]>>=
void*
calloc(ulong n, ulong szelem)
{
    void *v;
    if(v = mallocz(n*szelem, 1))
        setmalloctag(v, getcallerpc(&n));
    return v;
}
@

<<function [[setmalloctag]]>>=
void
setmalloctag(void *v, ulong pc)
{
    ulong *u;
    USED(v, pc);
    if(Npadlong <= MallocOffset || v == nil)
        return;
    u = v;
    u[-Npadlong+MallocOffset] = pc;
}
@

<<function [[setrealloctag]]>>=
void
setrealloctag(void *v, ulong pc)
{
    ulong *u;
    USED(v, pc);
    if(Npadlong <= ReallocOffset || v == nil)
        return;
    u = v;
    u[-Npadlong+ReallocOffset] = pc;
}
@

<<function [[getmalloctag]]>>=
ulong
getmalloctag(void *v)
{
    USED(v);
    if(Npadlong <= MallocOffset)
        return ~0;
    return ((ulong*)v)[-Npadlong+MallocOffset];
}
@

<<function [[getrealloctag]]>>=
ulong
getrealloctag(void *v)
{
    USED(v);
    if(Npadlong <= ReallocOffset)
        return ((ulong*)v)[-Npadlong+ReallocOffset];
    return ~0;
}
@

<<function [[malloctopoolblock]]>>=
void*
malloctopoolblock(void *v)
{
    if(v == nil)
        return nil;

    return &((ulong*)v)[-Npadlong];
}
@


%-------------------------------------------------------------

<<libc/port/malloc.c>>=
#include <u.h>
#include <libc.h>
#include <pool.h>
#include <tos.h>

static void*    sbrkalloc(ulong);
static int      sbrkmerge(void*, void*);
static void     plock(Pool*);
static void     punlock(Pool*);
static void     pprint(Pool*, char*, ...);
static void     ppanic(Pool*, char*, ...);

typedef struct Private Private;
<<struct [[Private]]>>

<<global [[sbrkmempriv]]>>

<<global [[sbrkmem]]>>
<<global [[mainmem]]>>
<<global [[imagmem]]>>

<<function [[sbrkalloc]]>>

<<function [[sbrkmerge]]>>

<<function [[plock]]>>

<<function [[punlock]]>>

<<function [[checkenv]]>>

<<function [[pprint]]>>

<<global [[panicbuf]]>>
<<function [[ppanic]]>>

/* - everything from here down should be the same in libc, libdebugmalloc, and the kernel - */
/* - except the code for malloc(), which alternately doesn't clear or does. - */

/*
 * Npadlong is the number of 32-bit longs to leave at the beginning of 
 * each allocated buffer for our own bookkeeping.  We return to the callers
 * a pointer that points immediately after our bookkeeping area.  Incoming pointers
 * must be decremented by that much, and outgoing pointers incremented.
 * The malloc tag is stored at MallocOffset from the beginning of the block,
 * and the realloc tag at ReallocOffset.  The offsets are from the true beginning
 * of the block, not the beginning the caller sees.
 *
 * The extra if(Npadlong != 0) in various places is a hint for the compiler to
 * compile out function calls that would otherwise be no-ops.
 */

/*  non tracing
 *
enum {
    Npadlong    = 0,
    MallocOffset = 0,
    ReallocOffset = 0,
};
 *
 */

<<enum [[_anon_]]>>

<<function [[malloc]]>>

<<function [[mallocz]]>>

<<function [[mallocalign]]>>

<<function [[free]]>>

<<function [[realloc]]>>

<<function [[msize]]>>

<<function [[calloc]]>>

<<function [[setmalloctag]]>>

<<function [[setrealloctag]]>>

<<function [[getmalloctag]]>>

<<function [[getrealloctag]]>>

<<function [[malloctopoolblock]]>>
@


\subsection*{[[libc/port/memccpy.c]]}


%-------------------------------------------------------------

<<libc/port/memccpy.c>>=
#include    <u.h>
#include    <libc.h>

<<function [[memccpy]]>>
@


\subsection*{[[libc/port/memchr.c]]}


%-------------------------------------------------------------

<<libc/port/memchr.c>>=
#include    <u.h>
#include    <libc.h>

<<function [[memchr]]>>
@


\subsection*{[[libc/port/memcmp.c]]}


%-------------------------------------------------------------

<<libc/port/memcmp.c>>=
#include    <u.h>
#include    <libc.h>

<<function [[memcmp]]>>
@


\subsection*{[[libc/port/memmove.c]]}


%-------------------------------------------------------------

<<libc/port/memmove.c>>=
#include    <u.h>
#include    <libc.h>

<<function [[memmove]]>>

<<function [[memcpy]]>>
@


\subsection*{[[libc/port/memset.c]]}


%-------------------------------------------------------------

<<libc/port/memset.c>>=
#include    <u.h>
#include    <libc.h>

<<function [[memset]]>>
@


\subsection*{[[libc/port/mktemp.c]]}



%-------------------------------------------------------------

<<libc/port/mktemp.c>>=
#include <u.h>
#include <libc.h>

<<function [[mktemp]]>>
@


\subsection*{[[libc/port/muldiv.c]]}



%-------------------------------------------------------------

<<libc/port/muldiv.c>>=
#include <u.h>
#include <libc.h>

<<function [[umuldiv]]>>

<<function [[muldiv]]>>
@


\subsection*{[[libc/port/nan.c]]}



%-------------------------------------------------------------

<<libc/port/nan.c>>=
#include <u.h>
#include <libc.h>

<<constant [[NANEXP]]>>
<<constant [[NANMASK]]>>
<<constant [[NANSIGN]]>>

<<function [[NaN]]>>

<<function [[isNaN]]>>

<<function [[Inf]]>>

<<function [[isInf]]>>
@


\subsection*{[[libc/port/needsrcquote.c]]}

<<function [[needsrcquote]]>>=
int
needsrcquote(int c)
{
    if(c <= ' ')
        return 1;
    if(utfrune("`^#*[]=|\\?${}()'<>&;", c))
        return 1;
    return 0;
}
@
%$


%-------------------------------------------------------------

<<libc/port/needsrcquote.c>>=
#include <u.h>
#include <libc.h>

<<function [[needsrcquote]]>>
@


\subsection*{[[libc/port/netcrypt.c]]}



%-------------------------------------------------------------

<<libc/port/netcrypt.c>>=
#include <u.h>
#include <libc.h>
#include <auth.h>

<<function [[netcrypt]]>>
@


\subsection*{[[libc/port/netmkaddr.c]]}


%-------------------------------------------------------------

<<libc/port/netmkaddr.c>>=
#include <u.h>
#include <libc.h>
#include <ctype.h>

<<function [[netmkaddr]]>>
@


\subsection*{[[libc/port/nrand.c]]}

<<constant MASK (port/nrand.c)>>=
#define MASK    0x7fffffffL
@

<<function [[nrand]]>>=
int
nrand(int n)
{
    long slop, v;

    if(n < 0)
        return n;
    if(n == 1)
        return 0;
    /* and if n == 0, you deserve what you get */
    slop = MASK % n;
    do
        v = lrand();
    while(v <= slop);
    return v % n;
}
@


%-------------------------------------------------------------

<<libc/port/nrand.c>>=
#include    <u.h>
#include    <libc.h>

<<constant MASK (port/nrand.c)>>

<<function [[nrand]]>>
@


\subsection*{[[libc/port/ntruerand.c]]}

<<function [[ntruerand]]>>=
ulong
ntruerand(ulong n)
{
    ulong m, r;

    /*
     * set m to the one less than the maximum multiple of n <= 2^32,
     * so we want a random number <= m.
     */
    if(n > (1UL<<31))
        m = n-1;
    else
        /* 2^32 - 2^32%n - 1 = (2^32 - 1) - (2*(2^31%n))%n */
        m = 0xFFFFFFFFUL - (2*((1UL<<31)%n))%n;

    while((r = truerand()) > m)
        ;

    return r%n;
}
@


%-------------------------------------------------------------

<<libc/port/ntruerand.c>>=
#include <u.h>
#include <libc.h>

<<function [[ntruerand]]>>
@


\subsection*{[[libc/port/perror.c]]}



%-------------------------------------------------------------

<<libc/port/perror.c>>=
#include <u.h>
#include <libc.h>

<<function [[perror]]>>
@


\subsection*{[[libc/port/pool.c]]}


<<function [[checklist]]>>=
/*
 * Tree walking
 */

static void
checklist(Free *t)
{
    Free *q;

    for(q=t->next; q!=t; q=q->next){
        assert(q->size == t->size);
        assert(q->next==nil || q->next->prev==q);
        assert(q->prev==nil || q->prev->next==q);
    //  assert(q->left==nil);
    //  assert(q->right==nil);
        assert(q->magic==FREE_MAGIC);
    }
}
@

<<function [[checktree]]>>=
static void
checktree(Free *t, int a, int b)
{
    assert(t->magic==FREE_MAGIC);
    assert(a < t->size && t->size < b);
    assert(t->next==nil || t->next->prev==t);
    assert(t->prev==nil || t->prev->next==t);
    checklist(t);
    if(t->left)
        checktree(t->left, a, t->size);
    if(t->right)
        checktree(t->right, t->size, b);
    
}
@

<<function [[ltreewalk]]>>=
/* ltreewalk: return address of pointer to node of size == size */
static Free**
ltreewalk(Free **t, ulong size)
{
    assert(t != nil /* ltreewalk */);

    for(;;) {
        if(*t == nil)
            return t;

        assert((*t)->magic == FREE_MAGIC);

        if(size == (*t)->size)
            return t;
        if(size < (*t)->size)
            t = &(*t)->left;
        else
            t = &(*t)->right;
    }
}
@

<<function [[treelookup]]>>=
/* treelookup: find node in tree with size == size */
static Free*
treelookup(Free *t, ulong size)
{
    return *ltreewalk(&t, size);
}
@

<<function [[treeinsert]]>>=
/* treeinsert: insert node into tree */
static Free*
treeinsert(Free *tree, Free *node)
{
    Free **loc, *repl;

    assert(node != nil /* treeinsert */);

    loc = ltreewalk(&tree, node->size);
    if(*loc == nil) {
        node->left = nil;
        node->right = nil;
    } else {    /* replace existing node */
        repl = *loc;
        node->left = repl->left;
        node->right = repl->right;
    }
    *loc = node;
    return tree;
}
@

<<function [[treedelete]]>>=
/* treedelete: remove node from tree */
static Free*
treedelete(Free *tree, Free *node)
{
    Free **loc, **lsucc, *succ;

    assert(node != nil /* treedelete */);

    loc = ltreewalk(&tree, node->size);
    assert(*loc == node);

    if(node->left == nil)
        *loc = node->right;
    else if(node->right == nil)
        *loc = node->left;
    else {
        /* have two children, use inorder successor as replacement */
        for(lsucc = &node->right; (*lsucc)->left; lsucc = &(*lsucc)->left)
            ;
        succ = *lsucc;
        *lsucc = succ->right;
        succ->left = node->left;
        succ->right = node->right;
        *loc = succ;
    }

    node->left = node->right = Poison;
    return tree;
}
@

<<function [[treelookupgt]]>>=
/* treelookupgt: find smallest node in tree with size >= size */
static Free*
treelookupgt(Free *t, ulong size)
{
    Free *lastgood; /* last node we saw that was big enough */

    lastgood = nil;
    for(;;) {
        if(t == nil)
            return lastgood;
        if(size == t->size)
            return t;
        if(size < t->size) {
            lastgood = t;
            t = t->left;
        } else
            t = t->right;
    }
}
@

<<function [[listadd]]>>=
/* listadd: add a node to a doubly linked list */
static Free*
listadd(Free *list, Free *node)
{
    if(list == nil) {
        node->next = node;
        node->prev = node;
        return node;
    }

    node->prev = list->prev;
    node->next = list;

    node->prev->next = node;
    node->next->prev = node;

    return list;
}
@

<<function [[listdelete]]>>=
/* listdelete: remove node from a doubly linked list */
static Free*
listdelete(Pool *p, Free *list, Free *node)
{
    if(node->next == node) {    /* singular list */
        node->prev = node->next = Poison;
        return nil;
    }
    if(node->next == nil)
        p->panic(p, "pool->next");
    if(node->prev == nil)
        p->panic(p, "pool->prev");
    node->next->prev = node->prev;
    node->prev->next = node->next;

    if(list == node)
        list = node->next;

    node->prev = node->next = Poison;
    return list;
}
@

<<function [[pooladd]]>>=
/* pooladd: add anode to the free pool */
static Free*
pooladd(Pool *p, Alloc *anode)
{
    Free *lst, *olst;
    Free *node;
    Free **parent;

    antagonism {
        memmark(_B2D(anode), 0xF7, anode->size-sizeof(Bhdr)-sizeof(Btail));
    }

    node = (Free*)anode;
    node->magic = FREE_MAGIC;
    parent = ltreewalk(&p->freeroot, node->size);
    olst = *parent;
    lst = listadd(olst, node);
    if(olst != lst) /* need to update tree */
        *parent = treeinsert(*parent, lst);
    p->curfree += node->size;
    return node;
}
@

<<function [[pooldel]]>>=
/* pooldel: remove node from the free pool */
static Alloc*
pooldel(Pool *p, Free *node)
{
    Free *lst, *olst;
    Free **parent;

    parent = ltreewalk(&p->freeroot, node->size);
    olst = *parent;
    assert(olst != nil /* pooldel */);

    lst = listdelete(p, olst, node);
    if(lst == nil)
        *parent = treedelete(*parent, olst);
    else if(lst != olst)
        *parent = treeinsert(*parent, lst);

    node->left = node->right = Poison;
    p->curfree -= node->size;

    antagonism {
        memmark(_B2D(node), 0xF9, node->size-sizeof(Bhdr)-sizeof(Btail));
    }

    node->magic = UNALLOC_MAGIC;
    return (Alloc*)node;
}
@

<<function [[dsize2bsize]]>>=
/* block allocation */
static ulong
dsize2bsize(Pool *p, ulong sz)
{
    sz += sizeof(Bhdr)+sizeof(Btail);
    if(sz < p->minblock)
        sz = p->minblock;
    if(sz < MINBLOCKSIZE)
        sz = MINBLOCKSIZE;
    sz = (sz+p->quantum-1)&~(p->quantum-1);
    return sz;
}
@

<<function [[bsize2asize]]>>=
static ulong
bsize2asize(Pool *p, ulong sz)
{
    sz += sizeof(Arena)+sizeof(Btail);
    if(sz < p->minarena)
        sz = p->minarena;
    sz = (sz+p->quantum)&~(p->quantum-1);
    return sz;
}
@

<<function [[blockmerge]]>>=
/* both are removed from pool if necessary. */
static Alloc*
blockmerge(Pool *pool, Bhdr *a, Bhdr *b)
{
    Btail *t;

    assert(B2NB(a) == b);

    if(a->magic == FREE_MAGIC)
        pooldel(pool, (Free*)a);
    if(b->magic == FREE_MAGIC)
        pooldel(pool, (Free*)b);

    t = B2T(a);
    t->size = (ulong)Poison;
    t->magic0 = NOT_MAGIC;
    t->magic1 = NOT_MAGIC;
    PSHORT(t->datasize, NOT_MAGIC);

    a->size += b->size;
    t = B2T(a);
    t->size = a->size;
    PSHORT(t->datasize, 0xFFFF);

    b->size = NOT_MAGIC;
    b->magic = NOT_MAGIC;

    a->magic = UNALLOC_MAGIC;
    return (Alloc*)a;
}
@

<<function [[blocksetsize]]>>=
/* blocksetsize: set the total size of a block, fixing tail pointers */
static Bhdr*
blocksetsize(Bhdr *b, ulong bsize)
{
    Btail *t;

    assert(b->magic != FREE_MAGIC /* blocksetsize */);

    b->size = bsize;
    t = B2T(b);
    t->size = b->size;
    t->magic0 = TAIL_MAGIC0;
    t->magic1 = TAIL_MAGIC1;
    return b;
}
@

<<function [[getdsize]]>>=
/* getdsize: return the requested data size for an allocated block */
static ulong
getdsize(Alloc *b)
{
    Btail *t;
    t = B2T(b);
    return b->size - SHORT(t->datasize);
}
@

<<function [[trim]]>>=
/* trim: trim a block down to what is needed to hold dsize bytes of user data */
Alloc*
trim(Pool *p, Alloc *b, ulong dsize)
{
    ulong extra, bsize;
    Alloc *frag;

    bsize = dsize2bsize(p, dsize);
    extra = b->size - bsize;
    if(b->size - dsize >= 0x10000 ||
      (extra >= bsize>>2 && extra >= MINBLOCKSIZE && extra >= p->minblock)) {
        blocksetsize(b, bsize);
        frag = (Alloc*) B2NB(b);

        antagonism {
            memmark(frag, 0xF1, extra);
        }

        frag->magic = UNALLOC_MAGIC;
        blocksetsize(frag, extra);
        pooladd(p, frag);
    }

    b->magic = ALLOC_MAGIC;
    blocksetdsize(p, b, dsize);
    return b;
}
@

<<function [[freefromfront]]>>=
static Alloc*
freefromfront(Pool *p, Alloc *b, ulong skip)
{
    Alloc *bb;

    skip = skip&~(p->quantum-1);
    if(skip >= 0x1000 || (skip >= b->size>>2 && skip >= MINBLOCKSIZE && skip >= p->minblock)){
        bb = (Alloc*)((uchar*)b+skip);
        blocksetsize(bb, b->size-skip);
        bb->magic = UNALLOC_MAGIC;
        blocksetsize(b, skip);
        b->magic = UNALLOC_MAGIC;
        pooladd(p, b);
        return bb;
    }
    return b;   
}
@

<<function [[arenasetsize]]>>=
/* arenasetsize: set arena size, updating tail */
static void
arenasetsize(Arena *a, ulong asize)
{
    Bhdr *atail;

    a->asize = asize;
    atail = A2TB(a);
    atail->magic = ARENATAIL_MAGIC;
    atail->size = 0;
}
@

<<function [[poolnewarena]]>>=
/* poolnewarena: allocate new arena */
static void
poolnewarena(Pool *p, ulong asize)
{
    Arena *a;
    Arena *ap, *lastap;
    Alloc *b;

    LOG(p, "newarena %lud\n", asize);
    if(p->cursize+asize > p->maxsize) {
        if(poolcompactl(p) == 0){
            LOG(p, "pool too big: %lud+%lud > %lud\n",
                p->cursize, asize, p->maxsize);
            werrstr("memory pool too large");
        }
        return;
    }

    if((a = p->alloc(asize)) == nil) {
        /* assume errstr set by p->alloc */
        return;
    }

    p->cursize += asize;

    /* arena hdr */
    a->magic = ARENA_MAGIC;
    blocksetsize(a, sizeof(Arena));
    arenasetsize(a, asize);
    blockcheck(p, a);

    /* create one large block in arena */
    b = (Alloc*)A2B(a);
    b->magic = UNALLOC_MAGIC;
    blocksetsize(b, (uchar*)A2TB(a)-(uchar*)b);
    blockcheck(p, b);
    pooladd(p, b);
    blockcheck(p, b);

    /* sort arena into descending sorted arena list */
    for(lastap=nil, ap=p->arenalist; ap > a; lastap=ap, ap=ap->down)
        ;

    if(a->down = ap)    /* assign = */
        a->down->aup = a;

    if(a->aup = lastap) /* assign = */
        a->aup->down = a;
    else
        p->arenalist = a;

    /* merge with surrounding arenas if possible */
    /* must do a with up before down with a (think about it) */
    if(a->aup)
        arenamerge(p, a, a->aup);
    if(a->down)
        arenamerge(p, a->down, a);
}
@

<<function [[blockgrow]]>>=
/* trimming it into two different blocks. */
static void
blockgrow(Pool *p, Bhdr *b, ulong nsize)
{
    if(b->magic == FREE_MAGIC) {
        Alloc *a;
        Bhdr *bnxt;
        a = pooldel(p, (Free*)b);
        blockcheck(p, a);
        blocksetsize(a, nsize);
        blockcheck(p, a);
        bnxt = B2NB(a);
        if(bnxt->magic == FREE_MAGIC)
            a = blockmerge(p, a, bnxt);
        blockcheck(p, a);
        pooladd(p, a);
    } else {
        Alloc *a;
        ulong dsize;

        a = (Alloc*)b;
        dsize = getdsize(a);
        blocksetsize(a, nsize);
        trim(p, a, dsize);
    }
}
@

<<function [[arenamerge]]>>=
/* arenamerge: attempt to coalesce to arenas that might be adjacent */
static Arena*
arenamerge(Pool *p, Arena *bot, Arena *top)
{
    Bhdr *bbot, *btop;
    Btail *t;

    blockcheck(p, bot);
    blockcheck(p, top);
    assert(bot->aup == top && top > bot);

    if(p->merge == nil || p->merge(bot, top) == 0)
        return nil;

    /* remove top from list */
    if(bot->aup = top->aup) /* assign = */
        bot->aup->down = bot;
    else
        p->arenalist = bot;
    
    /* save ptrs to last block in bot, first block in top */
    t = B2PT(A2TB(bot));
    bbot = T2HDR(t);
    btop = A2B(top);
    blockcheck(p, bbot);
    blockcheck(p, btop);

    /* grow bottom arena to encompass top */
    arenasetsize(bot, top->asize + ((uchar*)top - (uchar*)bot));

    /* grow bottom block to encompass space between arenas */
    blockgrow(p, bbot, (uchar*)btop-(uchar*)bbot);
    blockcheck(p, bbot);
    return bot;
}
@

<<function [[dumpblock]]>>=
/* dumpblock: print block's vital stats */
static void
dumpblock(Pool *p, Bhdr *b)
{
    ulong *dp;
    ulong dsize;
    uchar *cp;

    dp = (ulong*)b;
    p->print(p, "pool %s block %p\nhdr %.8lux %.8lux %.8lux %.8lux %.8lux %.8lux\n",
        p->name, b, dp[0], dp[1], dp[2], dp[3], dp[4], dp[5], dp[6]);

    dp = (ulong*)B2T(b);
    p->print(p, "tail %.8lux %.8lux %.8lux %.8lux %.8lux %.8lux | %.8lux %.8lux\n",
        dp[-6], dp[-5], dp[-4], dp[-3], dp[-2], dp[-1], dp[0], dp[1]);

    if(b->magic == ALLOC_MAGIC){
        dsize = getdsize((Alloc*)b);
        if(dsize >= b->size)    /* user data size corrupt */
            return;

        cp = (uchar*)_B2D(b)+dsize;
        p->print(p, "user data ");
        p->print(p, "%.2ux %.2ux %.2ux %.2ux  %.2ux %.2ux %.2ux %.2ux",
            cp[-8], cp[-7], cp[-6], cp[-5], cp[-4], cp[-3], cp[-2], cp[-1]);
        p->print(p, " | %.2ux %.2ux %.2ux %.2ux  %.2ux %.2ux %.2ux %.2ux\n",
            cp[0], cp[1], cp[2], cp[3], cp[4], cp[5], cp[6], cp[7]);
    }
}
@

<<function [[printblock]]>>=
static void
printblock(Pool *p, Bhdr *b, char *msg)
{
    p->print(p, "%s\n", msg);
    dumpblock(p, b);
}
@

<<function [[panicblock]]>>=
static void
panicblock(Pool *p, Bhdr *b, char *msg)
{
    p->print(p, "%s\n", msg);
    dumpblock(p, b);
    p->panic(p, "pool panic");
}
@

<<function [[blockcheck]]>>=
/* should only be called when holding pool lock */
static void
blockcheck(Pool *p, Bhdr *b)
{
    Alloc *a;
    Btail *t;
    int i, n;
    uchar *q, *bq, *eq;
    ulong dsize;

    switch(b->magic) {
    default:
        panicblock(p, b, "bad magic");
    case FREE_MAGIC:
    case UNALLOC_MAGIC:
        t = B2T(b);
        if(t->magic0 != TAIL_MAGIC0 || t->magic1 != TAIL_MAGIC1)
            panicblock(p, b, "corrupt tail magic");
        if(T2HDR(t) != b)
            panicblock(p, b, "corrupt tail ptr");
        break;
    case DEAD_MAGIC:
        t = B2T(b);
        if(t->magic0 != TAIL_MAGIC0 || t->magic1 != TAIL_MAGIC1)
            panicblock(p, b, "corrupt tail magic");
        if(T2HDR(t) != b)
            panicblock(p, b, "corrupt tail ptr");
        n = getdsize((Alloc*)b);
        q = _B2D(b);
        q += 8;
        for(i=8; i<n; i++)
            if(*q++ != 0xDA)
                panicblock(p, b, "dangling pointer write");
        break;
    case ARENA_MAGIC:
        b = A2TB((Arena*)b);
        if(b->magic != ARENATAIL_MAGIC)
            panicblock(p, b, "bad arena size");
        /* fall through */
    case ARENATAIL_MAGIC:
        if(b->size != 0)
            panicblock(p, b, "bad arena tail size");
        break;
    case ALLOC_MAGIC:
        a = (Alloc*)b;
        t = B2T(b);
        dsize = getdsize(a);
        bq = (uchar*)_B2D(a)+dsize;
        eq = (uchar*)t;

        if(t->magic0 != TAIL_MAGIC0){
            /* if someone wrote exactly one byte over and it was a NUL, we sometimes only complain. */
            if((p->flags & POOL_TOLERANCE) && bq == eq && t->magic0 == 0)
                printblock(p, b, "mem user overflow (magic0)");
            else
                panicblock(p, b, "corrupt tail magic0");
        }

        if(t->magic1 != TAIL_MAGIC1)
            panicblock(p, b, "corrupt tail magic1");
        if(T2HDR(t) != b)
            panicblock(p, b, "corrupt tail ptr");

        if(dsize2bsize(p, dsize)  > a->size)
            panicblock(p, b, "too much block data");

        if(eq > bq+4)
            eq = bq+4;
        for(q=bq; q<eq; q++){
            if(*q != datamagic[((uintptr)q)%nelem(datamagic)]){
                if(q == bq && *q == 0 && (p->flags & POOL_TOLERANCE)){
                    printblock(p, b, "mem user overflow");
                    continue;
                }
                panicblock(p, b, "mem user overflow");
            }
        }
        break;
    }
}
@

<<enum [[_anon_ (port/pool.c)]]8>>=
/*
 * compact an arena by shifting all the free blocks to the end.
 * assumes pool lock is held.
 */
enum {
    FLOATING_MAGIC = 0xCBCBCBCB,    /* temporarily neither allocated nor in the free tree */
};
@

<<function [[arenacompact]]>>=
static int
arenacompact(Pool *p, Arena *a)
{
    Bhdr *b, *wb, *eb, *nxt;
    int compacted;

    if(p->move == nil)
        p->panic(p, "don't call me when pool->move is nil\n");

    poolcheckarena(p, a);
    eb = A2TB(a);
    compacted = 0;
    for(b=wb=A2B(a); b && b < eb; b=nxt) {
        nxt = B2NB(b);
        switch(b->magic) {
        case FREE_MAGIC:
            pooldel(p, (Free*)b);
            b->magic = FLOATING_MAGIC;
            break;
        case ALLOC_MAGIC:
            if(wb != b) {
                memmove(wb, b, b->size);
                p->move(_B2D(b), _B2D(wb));
                compacted = 1;
            }
            wb = B2NB(wb);
            break;
        }
    }

    /*
     * the only free data is now at the end of the arena, pointed
     * at by wb.  all we need to do is set its size and get out.
     */
    if(wb < eb) {
        wb->magic = UNALLOC_MAGIC;
        blocksetsize(wb, (uchar*)eb-(uchar*)wb);
        pooladd(p, (Alloc*)wb);
    }

    return compacted;       
}
@

<<function [[poolcompactl]]>>=
/*
 * compact a pool by compacting each individual arena.
 * 'twould be nice to shift blocks from one arena to the
 * next but it's a pain to code.
 */
static int
poolcompactl(Pool *pool)
{
    Arena *a;
    int compacted;

    if(pool->move == nil || pool->lastcompact == pool->nfree)
        return 0;

    pool->lastcompact = pool->nfree;
    compacted = 0;
    for(a=pool->arenalist; a; a=a->down)
        compacted |= arenacompact(pool, a);
    return compacted;
}
@

<<function [[B2D]]>>=
/*
static void*
_B2D(void *a)
{
    return (uchar*)a+sizeof(Bhdr);
}
*/

static void*
B2D(Pool *p, Alloc *a)
{
    if(a->magic != ALLOC_MAGIC)
        p->panic(p, "B2D called on unworthy block");
    return _B2D(a);
}
@

<<function [[D2B]]>>=
/*
static void*
_D2B(void *v)
{
    Alloc *a;
    a = (Alloc*)((uchar*)v-sizeof(Bhdr));
    return a;
}
*/

static Alloc*
D2B(Pool *p, void *v)
{
    Alloc *a;
    ulong *u;

    if((uintptr)v&(sizeof(ulong)-1))
        v = (char*)v - ((uintptr)v&(sizeof(ulong)-1));
    u = v;
    while(u[-1] == ALIGN_MAGIC)
        u--;
    a = _D2B(u);
    if(a->magic != ALLOC_MAGIC)
        p->panic(p, "D2B called on non-block %p (double-free?)", v);
    return a;
}
@

<<function [[poolallocl]]>>=
/* poolallocl: attempt to allocate block to hold dsize user bytes; assumes lock held */
static void*
poolallocl(Pool *p, ulong dsize)
{
    ulong bsize;
    Free *fb;
    Alloc *ab;

    if(dsize >= 0x80000000UL){  /* for sanity, overflow */
        werrstr("invalid allocation size");
        return nil;
    }

    bsize = dsize2bsize(p, dsize);

    fb = treelookupgt(p->freeroot, bsize);
    if(fb == nil) {
        poolnewarena(p, bsize2asize(p, bsize));
        if((fb = treelookupgt(p->freeroot, bsize)) == nil) {
            /* assume poolnewarena failed and set %r */
            return nil;
        }
    }

    ab = trim(p, pooldel(p, fb), dsize);
    p->curalloc += ab->size;
    antagonism {
        memset(B2D(p, ab), 0xDF, dsize);
    }
    return B2D(p, ab);
}
@

<<function [[poolreallocl]]>>=
/* poolreallocl: attempt to grow v to ndsize bytes; assumes lock held */
static void*
poolreallocl(Pool *p, void *v, ulong ndsize)
{
    Alloc *a;
    Bhdr *left, *right, *newb;
    Btail *t;
    ulong nbsize;
    ulong odsize;
    ulong obsize;
    void *nv;

    if(v == nil)    /* for ANSI */
        return poolallocl(p, ndsize);
    if(ndsize == 0) {
        poolfreel(p, v);
        return nil;
    }
    a = D2B(p, v);
    blockcheck(p, a);
    odsize = getdsize(a);
    obsize = a->size;

    /* can reuse the same block? */
    nbsize = dsize2bsize(p, ndsize);
    if(nbsize <= a->size) {
    Returnblock:
        if(v != _B2D(a))
            memmove(_B2D(a), v, odsize);
        a = trim(p, a, ndsize);
        p->curalloc -= obsize;
        p->curalloc += a->size;
        v = B2D(p, a);
        return v;
    }

    /* can merge with surrounding blocks? */
    right = B2NB(a);
    if(right->magic == FREE_MAGIC && a->size+right->size >= nbsize) {
        a = blockmerge(p, a, right);
        goto Returnblock;
    }

    t = B2PT(a);
    left = T2HDR(t);
    if(left->magic == FREE_MAGIC && left->size+a->size >= nbsize) {
        a = blockmerge(p, left, a);
        goto Returnblock;
    }

    if(left->magic == FREE_MAGIC && right->magic == FREE_MAGIC
    && left->size+a->size+right->size >= nbsize) {
        a = blockmerge(p, blockmerge(p, left, a), right);
        goto Returnblock;
    }

    if((nv = poolallocl(p, ndsize)) == nil)
        return nil;

    /* maybe the new block is next to us; if so, merge */
    left = T2HDR(B2PT(a));
    right = B2NB(a);
    newb = D2B(p, nv);
    if(left == newb || right == newb) {
        if(left == newb || left->magic == FREE_MAGIC)
            a = blockmerge(p, left, a);
        if(right == newb || right->magic == FREE_MAGIC)
            a = blockmerge(p, a, right);
        assert(a->size >= nbsize);
        goto Returnblock;
    }

    /* enough cleverness */
    memmove(nv, v, odsize);
    antagonism { 
        memset((char*)nv+odsize, 0xDE, ndsize-odsize);
    }
    poolfreel(p, v);
    return nv;
}
@

<<function [[alignptr]]>>=
static void*
alignptr(void *v, ulong align, long offset)
{
    char *c;
    ulong off;

    c = v;
    if(align){
        off = (uintptr)c%align;
        if(off != offset){
            c += offset - off;
            if(off > offset)
                c += align;
        }
    }
    return c;
}
@

<<function [[poolallocalignl]]>>=
/* poolallocalignl: allocate as described below; assumes pool locked */
static void*
poolallocalignl(Pool *p, ulong dsize, ulong align, long offset, ulong span)
{
    ulong asize;
    void *v;
    char *c;
    ulong *u;
    int skip;
    Alloc *b;

    /*
     * allocate block
     *  dsize bytes
     *  addr == offset (modulo align)
     *  does not cross span-byte block boundary
     *
     * to satisfy alignment, just allocate an extra
     * align bytes and then shift appropriately.
     * 
     * to satisfy span, try once and see if we're
     * lucky.  the second time, allocate 2x asize
     * so that we definitely get one not crossing
     * the boundary.
     */
    if(align){
        if(offset < 0)
            offset = align - ((-offset)%align);
        else
            offset %= align;
    }
    asize = dsize+align;
    v = poolallocl(p, asize);
    if(v == nil)
        return nil;
    if(span && (uintptr)v/span != ((uintptr)v+asize)/span){
        /* try again */
        poolfreel(p, v);
        v = poolallocl(p, 2*asize);
        if(v == nil)
            return nil;
    }

    /*
     * figure out what pointer we want to return
     */
    c = alignptr(v, align, offset);
    if(span && (uintptr)c/span != (uintptr)(c+dsize-1)/span){
        c += span - (uintptr)c%span;
        c = alignptr(c, align, offset);
        if((uintptr)c/span != (uintptr)(c+dsize-1)/span){
            poolfreel(p, v);
            werrstr("cannot satisfy dsize %lud span %lud with align %lud+%ld", dsize, span, align, offset);
            return nil;
        }
    }
    skip = c - (char*)v;

    /*
     * free up the skip bytes before that pointer
     * or mark it as unavailable.
     */
    b = _D2B(v);
    b = freefromfront(p, b, skip);
    v = _B2D(b);
    skip = c - (char*)v;
    if(c > (char*)v){
        u = v;
        while(c >= (char*)u+sizeof(ulong))
            *u++ = ALIGN_MAGIC;
    }
    trim(p, b, skip+dsize);
    assert(D2B(p, c) == b);
    antagonism { 
        memset(c, 0xDD, dsize);
    }
    return c;
}
@

<<function [[poolfreel]]>>=
/* poolfree: free block obtained from poolalloc; assumes lock held */
static void
poolfreel(Pool *p, void *v)
{
    Alloc *ab;
    Bhdr *back, *fwd;

    if(v == nil)    /* for ANSI */
        return;

    ab = D2B(p, v);
    blockcheck(p, ab);

    if(p->flags&POOL_NOREUSE){
        int n;

        ab->magic = DEAD_MAGIC;
        n = getdsize(ab)-8;
        if(n > 0)
            memset((uchar*)v+8, 0xDA, n);
        return; 
    }

    p->nfree++;
    p->curalloc -= ab->size;
    back = T2HDR(B2PT(ab));
    if(back->magic == FREE_MAGIC)
        ab = blockmerge(p, back, ab);

    fwd = B2NB(ab);
    if(fwd->magic == FREE_MAGIC)
        ab = blockmerge(p, ab, fwd);

    pooladd(p, ab);
}
@

<<function [[poolalloc]]>>=
void*
poolalloc(Pool *p, ulong n)
{
    void *v;

    p->lock(p);
    paranoia {
        poolcheckl(p);
    }
    verbosity {
        pooldumpl(p);
    }
    v = poolallocl(p, n);
    paranoia {
        poolcheckl(p);
    }
    verbosity {
        pooldumpl(p);
    }
    if(p->logstack && (p->flags & POOL_LOGGING)) p->logstack(p);
    LOG(p, "poolalloc %p %lud = %p\n", p, n, v);
    p->unlock(p);
    return v;
}
@

<<function [[poolallocalign]]>>=
void*
poolallocalign(Pool *p, ulong n, ulong align, long offset, ulong span)
{
    void *v;

    p->lock(p);
    paranoia {
        poolcheckl(p);
    }
    verbosity {
        pooldumpl(p);
    }
    v = poolallocalignl(p, n, align, offset, span);
    paranoia {
        poolcheckl(p);
    }
    verbosity {
        pooldumpl(p);
    }
    if(p->logstack && (p->flags & POOL_LOGGING)) p->logstack(p);
    LOG(p, "poolalignspanalloc %p %lud %lud %lud %ld = %p\n", p, n, align, span, offset, v);
    p->unlock(p);
    return v;
}
@

<<function [[poolcompact]]>>=
int
poolcompact(Pool *p)
{
    int rv;

    p->lock(p);
    paranoia {
        poolcheckl(p);
    }
    verbosity {
        pooldumpl(p);
    }
    rv = poolcompactl(p);
    paranoia {
        poolcheckl(p);
    }
    verbosity {
        pooldumpl(p);
    }
    LOG(p, "poolcompact %p\n", p);
    p->unlock(p);
    return rv;
}
@

<<function [[poolrealloc]]>>=
void*
poolrealloc(Pool *p, void *v, ulong n)
{
    void *nv;

    p->lock(p);
    paranoia {
        poolcheckl(p);
    }
    verbosity {
        pooldumpl(p);
    }
    nv = poolreallocl(p, v, n);
    paranoia {
        poolcheckl(p);
    }
    verbosity {
        pooldumpl(p);
    }
    if(p->logstack && (p->flags & POOL_LOGGING)) p->logstack(p);
    LOG(p, "poolrealloc %p %p %ld = %p\n", p, v, n, nv);
    p->unlock(p);
    return nv;
}
@

<<function [[poolfree]]>>=
void
poolfree(Pool *p, void *v)
{
    p->lock(p);
    paranoia {
        poolcheckl(p);
    }
    verbosity {
        pooldumpl(p);
    }
    poolfreel(p, v);
    paranoia {
        poolcheckl(p);
    }
    verbosity {
        pooldumpl(p);
    }
    if(p->logstack && (p->flags & POOL_LOGGING)) p->logstack(p);
    LOG(p, "poolfree %p %p\n", p, v);
    p->unlock(p);
}
@

<<function [[poolmsize]]>>=
/*
 * Return the real size of a block, and let the user use it. 
 */
ulong
poolmsize(Pool *p, void *v)
{
    Alloc *b;
    ulong dsize;

    p->lock(p);
    paranoia {
        poolcheckl(p);
    }
    verbosity {
        pooldumpl(p);
    }
    if(v == nil)    /* consistency with other braindead ANSI-ness */
        dsize = 0;
    else {
        b = D2B(p, v);
        dsize = (b->size&~(p->quantum-1)) - sizeof(Bhdr) - sizeof(Btail);
        assert(dsize >= getdsize(b));
        blocksetdsize(p, b, dsize);
    }
    paranoia {
        poolcheckl(p);
    }
    verbosity {
        pooldumpl(p);
    }
    if(p->logstack && (p->flags & POOL_LOGGING)) p->logstack(p);
    LOG(p, "poolmsize %p %p = %ld\n", p, v, dsize);
    p->unlock(p);
    return dsize;
}
@

<<function [[poolcheckarena]]>>=
/*
 * Debugging 
 */

static void
poolcheckarena(Pool *p, Arena *a)
{
    Bhdr *b;
    Bhdr *atail;

    atail = A2TB(a);
    for(b=a; b->magic != ARENATAIL_MAGIC && b<atail; b=B2NB(b))
        blockcheck(p, b);
    blockcheck(p, b);
    if(b != atail)
        p->panic(p, "found wrong tail");
}
@

<<function [[poolcheckl]]>>=
static void
poolcheckl(Pool *p)
{
    Arena *a;

    for(a=p->arenalist; a; a=a->down)
        poolcheckarena(p, a);
    if(p->freeroot)
        checktree(p->freeroot, 0, 1<<30);
}
@

<<function [[poolcheck]]>>=
void
poolcheck(Pool *p)
{
    p->lock(p);
    poolcheckl(p);
    p->unlock(p);
}
@

<<function [[poolblockcheck]]>>=
void
poolblockcheck(Pool *p, void *v)
{
    if(v == nil)
        return;

    p->lock(p);
    blockcheck(p, D2B(p, v));
    p->unlock(p);
}
@

<<function [[pooldumpl]]>>=
static void
pooldumpl(Pool *p)
{
    Arena *a;

    p->print(p, "pool %p %s\n", p, p->name);
    for(a=p->arenalist; a; a=a->down)
        pooldumparena(p, a);
}
@

<<function [[pooldump]]>>=
void
pooldump(Pool *p)
{
    p->lock(p);
    pooldumpl(p);
    p->unlock(p);
}
@

<<function [[pooldumparena]]>>=
static void
pooldumparena(Pool *p, Arena *a)
{
    Bhdr *b;

    for(b=a; b->magic != ARENATAIL_MAGIC; b=B2NB(b))
        p->print(p, "(%p %.8lux %lud)", b, b->magic, b->size);
    p->print(p, "\n");
}
@

<<function [[memmark]]>>=
/*
 * mark the memory in such a way that we know who marked it
 * (via the signature) and we know where the marking started.
 */
static void
memmark(void *v, int sig, ulong size)
{
    uchar *p, *ep;
    ulong *lp, *elp;
    lp = v;
    elp = lp+size/4;
    while(lp < elp)
        *lp++ = (sig<<24) ^ ((uintptr)lp-(uintptr)v);
    p = (uchar*)lp;
    ep = (uchar*)v+size;
    while(p<ep)
        *p++ = sig;
}
@


%-------------------------------------------------------------

<<libc/port/pool.c>>=
/*
 * This allocator takes blocks from a coarser allocator (p->alloc) and
 * uses them as arenas.
 * 
 * An arena is split into a sequence of blocks of variable size.  The
 * blocks begin with a Bhdr that denotes the length (including the Bhdr)
 * of the block.  An arena begins with an Arena header block (Arena,
 * ARENA_MAGIC) and ends with a Bhdr block with magic ARENATAIL_MAGIC and
 * size 0.  Intermediate blocks are either allocated or free.  At the end
 * of each intermediate block is a Btail, which contains information
 * about where the block starts.  This is useful for walking backwards.
 * 
 * Free blocks (Free*) have a magic value of FREE_MAGIC in their Bhdr
 * headers.  They are kept in a binary tree (p->freeroot) traversible by
 * walking ->left and ->right.  Each node of the binary tree is a pointer
 * to a circular doubly-linked list (next, prev) of blocks of identical
 * size.  Blocks are added to this ``tree of lists'' by pooladd(), and
 * removed by pooldel().
 * 
 * When freed, adjacent blocks are coalesced to create larger blocks when
 * possible.
 * 
 * Allocated blocks (Alloc*) have one of two magic values: ALLOC_MAGIC or
 * UNALLOC_MAGIC.  When blocks are released from the pool, they have
 * magic value UNALLOC_MAGIC.  Once the block has been trimmed by trim()
 * and the amount of user-requested data has been recorded in the
 * datasize field of the tail, the magic value is changed to ALLOC_MAGIC.
 * All blocks returned to callers should be of type ALLOC_MAGIC, as
 * should all blocks passed to us by callers.  The amount of data the user
 * asked us for can be found by subtracting the short in tail->datasize 
 * from header->size.  Further, the up to at most four bytes between the
 * end of the user-requested data block and the actual Btail structure are
 * marked with a magic value, which is checked to detect user overflow.
 * 
 * The arenas returned by p->alloc are kept in a doubly-linked list
 * (p->arenalist) running through the arena headers, sorted by descending
 * base address (prev, next).  When a new arena is allocated, we attempt
 * to merge it with its two neighbors via p->merge.
 */

#include <u.h>
#include <libc.h>
#include <pool.h>

typedef struct Alloc    Alloc;
typedef struct Arena    Arena;
typedef struct Bhdr Bhdr;
typedef struct Btail    Btail;
typedef struct Free Free;

<<struct [[Bhdr]]>>
<<enum [[_anon_ (port/pool.c)]]>>
<<macro [[B2NB]]>>

<<macro [[SHORT]]>>
<<macro [[PSHORT]]>>

<<enum [[_anon_ (port/pool.c)]]2>>
<<struct [[Btail]]>>
<<macro [[B2T]]>>
<<macro [[B2PT]]>>
<<macro [[T2HDR]]>>
<<struct [[Free]]>>
<<enum [[_anon_ (port/pool.c)]]3>>

<<struct [[Alloc]]>>
<<enum [[_anon_ (port/pool.c)]]4>>

<<struct [[Arena]]>>
<<enum [[_anon_ (port/pool.c)]]5>>
<<macro [[A2TB]]>>
<<macro [[A2B]]>>

<<enum [[_anon_ (port/pool.c)]]6>>

<<enum [[_anon_ (port/pool.c)]]7>>

<<global [[datamagic]]>>

<<constant [[Poison]]>>

<<macro [[_B2D]]>>
<<macro [[_D2B]]>>

// static void* _B2D(void*);
// static void* _D2B(void*);
static void*    B2D(Pool*, Alloc*);
static Alloc*   D2B(Pool*, void*);
static Arena*   arenamerge(Pool*, Arena*, Arena*);
static void     blockcheck(Pool*, Bhdr*);
static Alloc*   blockmerge(Pool*, Bhdr*, Bhdr*);
static Alloc*   blocksetdsize(Pool*, Alloc*, ulong);
static Bhdr*    blocksetsize(Bhdr*, ulong);
static ulong    bsize2asize(Pool*, ulong);
static ulong    dsize2bsize(Pool*, ulong);
static ulong    getdsize(Alloc*);
static Alloc*   trim(Pool*, Alloc*, ulong);
static Free*    listadd(Free*, Free*);
static void     logstack(Pool*);
static Free**   ltreewalk(Free**, ulong);
static void     memmark(void*, int, ulong);
static Free*    pooladd(Pool*, Alloc*);
static void*    poolallocl(Pool*, ulong);
static void     poolcheckl(Pool*);
static void     poolcheckarena(Pool*, Arena*);
static int      poolcompactl(Pool*);
static Alloc*   pooldel(Pool*, Free*);
static void     pooldumpl(Pool*);
static void     pooldumparena(Pool*, Arena*);
static void     poolfreel(Pool*, void*);
static void     poolnewarena(Pool*, ulong);
static void*    poolreallocl(Pool*, void*, ulong);
static Free*    treedelete(Free*, Free*);
static Free*    treeinsert(Free*, Free*);
static Free*    treelookup(Free*, ulong);
static Free*    treelookupgt(Free*, ulong);

/*
 * Debugging
 * 
 * Antagonism causes blocks to always be filled with garbage if their
 * contents are undefined.  This tickles both programs and the library.
 * It's a linear time hit but not so noticeable during nondegenerate use.
 * It would be worth leaving in except that it negates the benefits of the
 * kernel's demand-paging.  The tail magic and end-of-data magic 
 * provide most of the user-visible benefit that antagonism does anyway.
 *
 * Paranoia causes the library to recheck the entire pool on each lock
 * or unlock.  A failed check on unlock means we tripped over ourselves,
 * while a failed check on lock tends to implicate the user.  Paranoia has
 * the potential to slow things down a fair amount for pools with large
 * numbers of allocated blocks.  It completely negates all benefits won
 * by the binary tree.  Turning on paranoia in the kernel makes it painfully
 * slow.
 *
 * Verbosity induces the dumping of the pool via p->print at each lock operation.
 * By default, only one line is logged for each alloc, free, and realloc.
 */

/* the if(!x);else avoids ``dangling else'' problems */
#define antagonism  if(!(p->flags & POOL_ANTAGONISM)){}else
#define paranoia    if(!(p->flags & POOL_PARANOIA)){}else
#define verbosity   if(!(p->flags & POOL_VERBOSITY)){}else

#define DPRINT  if(!(p->flags & POOL_DEBUGGING)){}else p->print
#define LOG     if(!(p->flags & POOL_LOGGING)){}else p->print

<<function [[checklist]]>>

<<function [[checktree]]>>

<<function [[ltreewalk]]>>

<<function [[treelookup]]>>

<<function [[treeinsert]]>>

<<function [[treedelete]]>>

<<function [[treelookupgt]]>>

/* 
 * List maintenance
 */

<<function [[listadd]]>>

<<function [[listdelete]]>>

/*
 * Pool maintenance
 */

<<function [[pooladd]]>>

<<function [[pooldel]]>>

/*
 * Block maintenance 
 */
<<function [[dsize2bsize]]>>

<<function [[bsize2asize]]>>

/* blockmerge: merge a and b, known to be adjacent */
<<function [[blockmerge]]>>

<<function [[blocksetsize]]>>

<<function [[getdsize]]>>

/* blocksetdsize: set the user data size of a block */
static Alloc*
blocksetdsize(Pool *p, Alloc *b, ulong dsize)
{
    Btail *t;
    uchar *q, *eq;

    assert(b->size >= dsize2bsize(p, dsize));
    assert(b->size - dsize < 0x10000);

    t = B2T(b);
    PSHORT(t->datasize, b->size - dsize);

    q=(uchar*)_B2D(b)+dsize;
    eq = (uchar*)t;
    if(eq > q+4)
        eq = q+4;
    for(; q<eq; q++)
        *q = datamagic[((ulong)(uintptr)q)%nelem(datamagic)];

    return b;
}

<<function [[trim]]>>

<<function [[freefromfront]]>>

/*
 * Arena maintenance
 */

<<function [[arenasetsize]]>>

<<function [[poolnewarena]]>>

/* blockresize: grow a block to encompass space past its end, possibly by */
<<function [[blockgrow]]>>

<<function [[arenamerge]]>>

<<function [[dumpblock]]>>

<<function [[printblock]]>>

<<function [[panicblock]]>>

/* blockcheck: ensure a block consistent with our expectations */
<<function [[blockcheck]]>>

<<enum [[_anon_ (port/pool.c)]]8>>

<<function [[arenacompact]]>>

<<function [[poolcompactl]]>>

/*
static int
poolcompactl(Pool*)
{
    return 0;
}
*/

/*
 * Actual allocators
 */

<<function [[B2D]]>>

<<function [[D2B]]>>

<<function [[poolallocl]]>>

<<function [[poolreallocl]]>>

<<function [[alignptr]]>>

<<function [[poolallocalignl]]>>

<<function [[poolfreel]]>>

<<function [[poolalloc]]>>

<<function [[poolallocalign]]>>

<<function [[poolcompact]]>>

<<function [[poolrealloc]]>>

<<function [[poolfree]]>>

<<function [[poolmsize]]>>

<<function [[poolcheckarena]]>>

<<function [[poolcheckl]]>>

<<function [[poolcheck]]>>

<<function [[poolblockcheck]]>>

<<function [[pooldumpl]]>>

<<function [[pooldump]]>>

<<function [[pooldumparena]]>>

<<function [[memmark]]>>
@


\subsection*{[[libc/port/pow.c]]}


%-------------------------------------------------------------

<<libc/port/pow.c>>=
#include <u.h>
#include <libc.h>

<<function [[pow]]>>
@


\subsection*{[[libc/port/pow10.c]]}


%-------------------------------------------------------------

<<libc/port/pow10.c>>=
#include    <u.h>
#include    <libc.h>

<<global [[tab]]>>

<<function [[pow10]]>>
@


\subsection*{[[libc/port/profile.c]]}



<<function [[_profdump]]>>=
// called by??
void
_profdump(void)
{
    int f;
    long n;
    Plink *p;
    char *vp;
    char filename[64];

    if (_tos->prof.what == 0)
        return; /* No profiling */
    if (_tos->prof.pid != 0 && _tos->pid != _tos->prof.pid)
        return; /* Not our process */
    if(perr)
        fprint(2, "%lud Prof errors\n", perr);
    _tos->prof.pp = nil;
    if (_tos->prof.pid)
        snprint(filename, sizeof filename - 1, "prof.%ld", _tos->prof.pid);
    else
        snprint(filename, sizeof filename - 1, "prof.out");
    f = create(filename, 1, 0666);
    if(f < 0) {
        perror("create prof.out");
        return;
    }
    _tos->prof.pid = ~0;    /* make sure data gets dumped once */
    switch(_tos->prof.what){
    case Profkernel:
        cycles((uvlong*)&_tos->prof.first->time);
        _tos->prof.first->time = _tos->prof.first->time + _tos->pcycles;
        break;
    case Profuser:
        cycles((uvlong*)&_tos->prof.first->time);
        _tos->prof.first->time = _tos->prof.first->time - _tos->kcycles;
        break;
    case Proftime:
        cycles((uvlong*)&_tos->prof.first->time);
        break;
    case Profsample:
        _tos->prof.first->time = _tos->clock;
        break;
    }
    vp = (char*)_tos->prof.first;

    for(p = _tos->prof.first; p <= _tos->prof.next; p++) {

        /*
         * short down
         */
        n = 0xffff;
        if(p->down)
            n = p->down - _tos->prof.first;
        vp[0] = n>>8;
        vp[1] = n;

        /*
         * short right
         */
        n = 0xffff;
        if(p->link)
            n = p->link - _tos->prof.first;
        vp[2] = n>>8;
        vp[3] = n;
        vp += 4;

        /*
         * long pc
         */
        n = p->pc;
        vp[0] = n>>24;
        vp[1] = n>>16;
        vp[2] = n>>8;
        vp[3] = n;
        vp += 4;

        /*
         * long count
         */
        n = p->count;
        vp[0] = n>>24;
        vp[1] = n>>16;
        vp[2] = n>>8;
        vp[3] = n;
        vp += 4;

        /*
         * vlong time
         */
        if (havecycles){
            n = (vlong)(p->time / (vlong)khz);
        }else
            n = p->time;

        vp[0] = n>>24;
        vp[1] = n>>16;
        vp[2] = n>>8;
        vp[3] = n;
        vp += 4;
    }
    write(f, (char*)_tos->prof.first, vp - (char*)_tos->prof.first);
    close(f);
}
@




%-------------------------------------------------------------

<<libc/port/profile.c>>=
#include    <u.h>
#include    <libc.h>
#include    <tos.h>

extern  long    _callpc(void**);
extern  long    _savearg(void);

<<global [[khz]]>>
<<global [[perr]]>>
<<global [[havecycles]]>>

typedef struct  Plink   Plink;
<<struct [[Plink]]>>

#pragma profile off

<<function [[_profin]]>>

<<function [[_profout]]>>

<<function [[_profdump]]>>

<<function [[_profinit]]>>

<<function [[_profmain]]>>

<<function [[prof]]>>

#pragma profile on

@


\subsection*{[[libc/port/qsort.c]]}


%-------------------------------------------------------------

<<libc/port/qsort.c>>=
/*
 * qsort -- simple quicksort
 */

#include <u.h>

<<type [[Sort]]>>

<<function [[swapb]]>>

<<function [[swapi]]>>

<<function [[pivot]]>>

<<function [[qsorts]]>>

<<function [[qsort]]>>
@


\subsection*{[[libc/port/quote.c]]}

<<global [[doquote]]>>=
int (*doquote)(int);
@

<<function [[unquotestrdup]]>>=
char*
unquotestrdup(char *s)
{
    char *t, *ret;
    int quoting;

    ret = s = strdup(s);    /* return unquoted copy */
    if(ret == nil)
        return ret;
    quoting = 0;
    t = s;  /* s is output string, t is input string */
    while(*t!='\0' && (quoting || (*t!=' ' && *t!='\t'))){
        if(*t != '\''){
            *s++ = *t++;
            continue;
        }
        /* *t is a quote */
        if(!quoting){
            quoting = 1;
            t++;
            continue;
        }
        /* quoting and we're on a quote */
        if(t[1] != '\''){
            /* end of quoted section; absorb closing quote */
            t++;
            quoting = 0;
            continue;
        }
        /* doubled quote; fold one quote into two */
        t++;
        *s++ = *t++;
    }
    if(t != s)
        memmove(s, t, strlen(t)+1);
    return ret;
}
@

<<function [[unquoterunestrdup]]>>=
Rune*
unquoterunestrdup(Rune *s)
{
    Rune *t, *ret;
    int quoting;

    ret = s = runestrdup(s);    /* return unquoted copy */
    if(ret == nil)
        return ret;
    quoting = 0;
    t = s;  /* s is output string, t is input string */
    while(*t!='\0' && (quoting || (*t!=' ' && *t!='\t'))){
        if(*t != '\''){
            *s++ = *t++;
            continue;
        }
        /* *t is a quote */
        if(!quoting){
            quoting = 1;
            t++;
            continue;
        }
        /* quoting and we're on a quote */
        if(t[1] != '\''){
            /* end of quoted section; absorb closing quote */
            t++;
            quoting = 0;
            continue;
        }
        /* doubled quote; fold one quote into two */
        t++;
        *s++ = *t++;
    }
    if(t != s)
        memmove(s, t, (runestrlen(t)+1)*sizeof(Rune));
    return ret;
}
@

<<function [[quotestrdup]]>>=
char*
quotestrdup(char *s)
{
    char *t, *u, *ret;
    int quotelen;
    Rune r;

    if(_needsquotes(s, &quotelen) == 0)
        return strdup(s);
    
    ret = malloc(quotelen+1);
    if(ret == nil)
        return nil;
    u = ret;
    *u++ = '\'';
    for(t=s; *t; t++){
        r = *t;
        if(r == L'\'')
            *u++ = r;   /* double the quote */
        *u++ = r;
    }
    *u++ = '\'';
    *u = '\0';
    return ret;
}
@

<<function [[quoterunestrdup]]>>=
Rune*
quoterunestrdup(Rune *s)
{
    Rune *t, *u, *ret;
    int quotelen;
    Rune r;

    if(_runeneedsquotes(s, &quotelen) == 0)
        return runestrdup(s);
    
    ret = malloc((quotelen+1)*sizeof(Rune));
    if(ret == nil)
        return nil;
    u = ret;
    *u++ = '\'';
    for(t=s; *t; t++){
        r = *t;
        if(r == L'\'')
            *u++ = r;   /* double the quote */
        *u++ = r;
    }
    *u++ = '\'';
    *u = '\0';
    return ret;
}
@


%-------------------------------------------------------------

<<libc/port/quote.c>>=
#include <u.h>
#include <libc.h>

<<global [[doquote]]>>

extern int _needsquotes(char*, int*);
extern int _runeneedsquotes(Rune*, int*);

<<function [[unquotestrdup]]>>

<<function [[unquoterunestrdup]]>>

<<function [[quotestrdup]]>>

<<function [[quoterunestrdup]]>>
@


\subsection*{[[libc/port/rand.c]]}


%-------------------------------------------------------------

<<libc/port/rand.c>>=
#include    <u.h>
#include    <libc.h>

<<function [[rand]]>>
@


\subsection*{[[libc/port/readn.c]]}



%-------------------------------------------------------------

<<libc/port/readn.c>>=
#include <u.h>
#include <libc.h>

<<function [[readn]]>>
@


\subsection*{[[libc/port/rune.c]]}


<<enum [[_anon_ (port/rune.c)]]>>=
enum
{
    Bitx    = Bit(1),

    Tx  = T(1),         /* 1000 0000 */
    Rune1 = (1<<(Bit(0)+0*Bitx))-1, /* 0000 0000 0000 0000 0111 1111 */

    Maskx   = (1<<Bitx)-1,      /* 0011 1111 */
    Testx   = Maskx ^ 0xFF,     /* 1100 0000 */

    SurrogateMin    = 0xD800,
    SurrogateMax    = 0xDFFF,

    Bad = Runeerror,
};
@


<<function [[runelen]]>>=
int
runelen(long c)
{
    Rune rune;
    char str[10];

    rune = c;
    return runetochar(str, &rune);
}
@

<<function [[runenlen]]>>=
int
runenlen(Rune *r, int nrune)
{
    int nb, i;
    Rune c;

    nb = 0;
    while(nrune--) {
        c = *r++;
        if(c <= Rune1){
            nb++;
        } else {
            for(i = 2; i < UTFmax + 1; i++)
                if(c <= RuneX(i) || i == UTFmax){
                    nb += i;
                    break;
                }
        }
    }
    return nb;
}
@

<<function [[fullrune]]>>=
int
fullrune(char *str, int n)
{
    int  i;
    Rune c;

    if(n <= 0)
        return 0;
    c = *(uchar*)str;
    if(c < Tx)
        return 1;
    for(i = 3; i < UTFmax + 1; i++)
        if(c < T(i))
            return n >= i - 1;
    return n >= UTFmax;
}
@


%-------------------------------------------------------------

<<libc/port/rune.c>>=
#include    <u.h>
#include    <libc.h>

<<macro [[Bit]]>>
<<macro [[T]]>>
<<macro [[RuneX]]>>

<<enum [[_anon_ (port/rune.c)]]>>

<<function [[chartorune]]>>

<<function [[runetochar]]>>

<<function [[runelen]]>>

<<function [[runenlen]]>>

<<function [[fullrune]]>>
@

\subsection*{[[libc/port/runebase.c]]}
% in Libcore_big.nw now

\subsection*{[[libc/port/runebsearch.c]]}


%-------------------------------------------------------------

<<libc/port/runebsearch.c>>=
#include <u.h>
#include <libc.h>

<<function [[_runebsearch]]>>
@


\subsection*{[[libc/port/runestrcat.c]]}



%-------------------------------------------------------------

<<libc/port/runestrcat.c>>=
#include <u.h>
#include <libc.h>

<<function [[runestrcat]]>>
@


\subsection*{[[libc/port/runestrchr.c]]}


%-------------------------------------------------------------

<<libc/port/runestrchr.c>>=
#include <u.h>
#include <libc.h>

<<function [[runestrchr]]>>
@


\subsection*{[[libc/port/runestrcmp.c]]}


%-------------------------------------------------------------

<<libc/port/runestrcmp.c>>=
#include <u.h>
#include <libc.h>

<<function [[runestrcmp]]>>
@


\subsection*{[[libc/port/runestrcpy.c]]}


%-------------------------------------------------------------

<<libc/port/runestrcpy.c>>=
#include <u.h>
#include <libc.h>

<<function [[runestrcpy]]>>
@


\subsection*{[[libc/port/runestrdup.c]]}


%-------------------------------------------------------------

<<libc/port/runestrdup.c>>=
#include <u.h>
#include <libc.h>

<<function [[runestrdup]]>>
@



\subsection*{[[libc/port/runestrecpy.c]]}

<<function [[runestrecpy]]>>=
Rune*
runestrecpy(Rune *s1, Rune *es1, Rune *s2)
{
    if(s1 >= es1)
        return s1;

    while(*s1++ = *s2++){
        if(s1 == es1){
            *--s1 = '\0';
            break;
        }
    }
    return s1;
}
@


%-------------------------------------------------------------

<<libc/port/runestrecpy.c>>=
#include <u.h>
#include <libc.h>

<<function [[runestrecpy]]>>
@


\subsection*{[[libc/port/runestrlen.c]]}


%-------------------------------------------------------------

<<libc/port/runestrlen.c>>=
#include <u.h>
#include <libc.h>

<<function [[runestrlen]]>>
@


\subsection*{[[libc/port/runestrncat.c]]}

<<function [[runestrncat]]>>=
Rune*
runestrncat(Rune *s1, Rune *s2, long n)
{
    Rune *os1;

    os1 = s1;
    s1 = runestrchr(s1, 0);
    while(*s1++ = *s2++)
        if(--n < 0) {
            s1[-1] = 0;
            break;
        }
    return os1;
}
@


%-------------------------------------------------------------

<<libc/port/runestrncat.c>>=
#include <u.h>
#include <libc.h>

<<function [[runestrncat]]>>
@


\subsection*{[[libc/port/runestrncmp.c]]}

<<function [[runestrncmp]]>>=
int
runestrncmp(Rune *s1, Rune *s2, long n)
{
    Rune c1, c2;

    while(n > 0) {
        c1 = *s1++;
        c2 = *s2++;
        n--;
        if(c1 != c2) {
            if(c1 > c2)
                return 1;
            return -1;
        }
        if(c1 == 0)
            break;
    }
    return 0;
}
@


%-------------------------------------------------------------

<<libc/port/runestrncmp.c>>=
#include <u.h>
#include <libc.h>

<<function [[runestrncmp]]>>
@


\subsection*{[[libc/port/runestrncpy.c]]}

<<function [[runestrncpy]]>>=
Rune*
runestrncpy(Rune *s1, Rune *s2, long n)
{
    int i;
    Rune *os1;

    os1 = s1;
    for(i = 0; i < n; i++)
        if((*s1++ = *s2++) == 0) {
            while(++i < n)
                *s1++ = 0;
            return os1;
        }
    return os1;
}
@


%-------------------------------------------------------------

<<libc/port/runestrncpy.c>>=
#include <u.h>
#include <libc.h>

<<function [[runestrncpy]]>>
@


\subsection*{[[libc/port/runestrrchr.c]]}



%-------------------------------------------------------------

<<libc/port/runestrrchr.c>>=
#include <u.h>
#include <libc.h>

<<function [[runestrrchr]]>>
@


\subsection*{[[libc/port/runestrstr.c]]}



%-------------------------------------------------------------

<<libc/port/runestrstr.c>>=
#include <u.h>
#include <libc.h>

<<function [[runestrstr]]>>
@


\subsection*{[[libc/port/runetype.c]]}


%-------------------------------------------------------------

<<libc/port/runetype.c>>=
#include    <u.h>
#include    <libc.h>

Rune*_runebsearch(Rune c, Rune *t, int n, int ne);

#include "runetypebody-6.2.0.h"
@


\subsection*{[[libc/port/sin.c]]}


%-------------------------------------------------------------

<<libc/port/sin.c>>=
/*
    C program for floating point sin/cos.
    Calls modf.
    There are no error exits.
    Coefficients are #3370 from Hart & Cheney (18.80D).
*/

#include <u.h>
#include <libc.h>

<<constant p0 (port/sin.c)>>
<<constant p1 (port/sin.c)>>
<<constant p2 (port/sin.c)>>
<<constant p3 (port/sin.c)>>
<<constant p4 (port/sin.c)>>
<<constant q0 (port/sin.c)>>
<<constant q1 (port/sin.c)>>
<<constant q2 (port/sin.c)>>
<<constant q3 (port/sin.c)>>

<<function [[sinus]]>>

<<function [[cos]]>>

<<function [[sin]]>>
@


\subsection*{[[libc/port/sinh.c]]}

<<global [[p0]]>>=
/*
 * sinh(arg) returns the hyperbolic sine of its floating-
 * point argument.
 *
 * The exponential function is called for arguments
 * greater in magnitude than 0.5.
 *
 * A series is used for arguments smaller in magnitude than 0.5.
 * The coefficients are #2029 from Hart & Cheney. (20.36D)
 *
 * cosh(arg) is computed from the exponential function for
 * all arguments.
 */

static  double  p0  = -0.6307673640497716991184787251e+6;
@

<<global [[p1]]>>=
static  double  p1  = -0.8991272022039509355398013511e+5;
@

<<global [[p2]]>>=
static  double  p2  = -0.2894211355989563807284660366e+4;
@

<<global [[p3]]>>=
static  double  p3  = -0.2630563213397497062819489e+2;
@

<<global [[q0]]>>=
static  double  q0  = -0.6307673640497716991212077277e+6;
@

<<global [[q1]]>>=
static  double  q1   = 0.1521517378790019070696485176e+5;
@

<<global [[q2]]>>=
static  double  q2  = -0.173678953558233699533450911e+3;
@

<<function [[sinh]]>>=
double
sinh(double arg)
{
    double temp, argsq;
    int sign;

    sign = 0;
    if(arg < 0) {
        arg = -arg;
        sign++;
    }
    if(arg > 21) {
        temp = exp(arg)/2;
        goto out;
    }
    if(arg > 0.5) {
        temp = (exp(arg) - exp(-arg))/2;
        goto out;
    }
    argsq = arg*arg;
    temp = (((p3*argsq+p2)*argsq+p1)*argsq+p0)*arg;
    temp /= (((argsq+q2)*argsq+q1)*argsq+q0);
out:
    if(sign)
        temp = -temp;
    return temp;
}
@

<<function [[cosh]]>>=
double
cosh(double arg)
{
    if(arg < 0)
        arg = - arg;
    if(arg > 21)
        return exp(arg)/2;
    return (exp(arg) + exp(-arg))/2;
}
@


%-------------------------------------------------------------

<<libc/port/sinh.c>>=
#include <u.h>
#include <libc.h>

<<global [[p0]]>>
<<global [[p1]]>>
<<global [[p2]]>>
<<global [[p3]]>>
<<global [[q0]]>>
<<global [[q1]]>>
<<global [[q2]]>>

<<function [[sinh]]>>

<<function [[cosh]]>>
@


\subsection*{[[libc/port/sqrt.c]]}


%-------------------------------------------------------------

<<libc/port/sqrt.c>>=
/*
    sqrt returns the square root of its floating
    point argument. Newton's method.

    calls frexp
*/

#include <u.h>
#include <libc.h>

<<function [[sqrt]]>>
@


\subsection*{[[libc/port/strcat.c]]}


%-------------------------------------------------------------

<<libc/port/strcat.c>>=
#include <u.h>
#include <libc.h>

<<function [[strcat]]>>
@


\subsection*{[[libc/port/strchr.c]]}


%-------------------------------------------------------------

<<libc/port/strchr.c>>=
#include <u.h>
#include <libc.h>

<<function [[strchr]]>>
@


\subsection*{[[libc/port/strcmp.c]]}


%-------------------------------------------------------------

<<libc/port/strcmp.c>>=
#include <u.h>
#include <libc.h>

<<function [[strcmp]]>>
@


\subsection*{[[libc/port/strcpy.c]]}


%-------------------------------------------------------------

<<libc/port/strcpy.c>>=
#include <u.h>
#include <libc.h>
<<constant [[N]]>>

<<function [[strcpy]]>>
@


\subsection*{[[libc/port/strcspn.c]]}

<<constant N (port/strcspn.c)>>=
#define N   256
@

<<function [[strcspn]]>>=
long
strcspn(char *s, char *b)
{
    char map[N], *os;

    memset(map, 0, N);
    for(;;) {
        map[*(uchar*)b] = 1;
        if(*b++ == 0)
            break;
    }
    os = s;
    while(map[*(uchar*)s++] == 0)
        ;
    return s - os - 1;
}
@


%-------------------------------------------------------------

<<libc/port/strcspn.c>>=
#include <u.h>
#include <libc.h>

<<constant N (port/strcspn.c)>>

<<function [[strcspn]]>>
@


\subsection*{[[libc/port/strdup.c]]}



%-------------------------------------------------------------

<<libc/port/strdup.c>>=
#include <u.h>
#include <libc.h>

<<function [[strdup]]>>
@


\subsection*{[[libc/port/strecpy.c]]}

<<function [[strecpy]]>>=
char*
strecpy(char *to, char *e, char *from)
{
    if(to >= e)
        return to;
    to = memccpy(to, from, '\0', e - to);
    if(to == nil){
        to = e - 1;
        *to = '\0';
    }else{
        to--;
    }
    return to;
}
@


%-------------------------------------------------------------

<<libc/port/strecpy.c>>=
#include <u.h>
#include <libc.h>

<<function [[strecpy]]>>
@


\subsection*{[[libc/port/strlen.c]]}


%-------------------------------------------------------------

<<libc/port/strlen.c>>=
#include <u.h>
#include <libc.h>

<<function [[strlen]]>>
@


\subsection*{[[libc/port/strncat.c]]}

<<function [[strncat]]>>=
char*
strncat(char *s1, char *s2, long n)
{
    char *os1;

    os1 = s1;
    while(*s1++)
        ;
    s1--;
    while(*s1++ = *s2++)
        if(--n < 0) {
            s1[-1] = 0;
            break;
        }
    return os1;
}
@


%-------------------------------------------------------------

<<libc/port/strncat.c>>=
#include <u.h>
#include <libc.h>

<<function [[strncat]]>>
@


\subsection*{[[libc/port/strncmp.c]]}

<<function [[strncmp]]>>=
int
strncmp(char *s1, char *s2, long n)
{
    unsigned c1, c2;

    while(n > 0) {
        c1 = *s1++;
        c2 = *s2++;
        n--;
        if(c1 != c2) {
            if(c1 > c2)
                return 1;
            return -1;
        }
        if(c1 == 0)
            break;
    }
    return 0;
}
@


%-------------------------------------------------------------

<<libc/port/strncmp.c>>=
#include <u.h>
#include <libc.h>

<<function [[strncmp]]>>
@


\subsection*{[[libc/port/strncpy.c]]}

<<function [[strncpy]]>>=
char*
strncpy(char *s1, char *s2, long n)
{
    int i;
    char *os1;

    os1 = s1;
    for(i = 0; i < n; i++)
        if((*s1++ = *s2++) == 0) {
            while(++i < n)
                *s1++ = 0;
            return os1;
        }
    return os1;
}
@


%-------------------------------------------------------------

<<libc/port/strncpy.c>>=
#include <u.h>
#include <libc.h>

<<function [[strncpy]]>>
@


\subsection*{[[libc/port/strpbrk.c]]}

<<constant N (port/strpbrk.c)>>=
#define N   256
@

<<function [[strpbrk]]>>=
char*
strpbrk(char *cs, char *cb)
{
    char map[N];
    uchar *s=(uchar*)cs, *b=(uchar*)cb;

    memset(map, 0, N);
    for(;;) {
        map[*b] = 1;
        if(*b++ == 0)
            break;
    }
    while(map[*s++] == 0)
        ;
    if(*--s)
        return (char*)s;
    return 0;
}
@


%-------------------------------------------------------------

<<libc/port/strpbrk.c>>=
#include <u.h>
#include <libc.h>
<<constant N (port/strpbrk.c)>>

<<function [[strpbrk]]>>
@


\subsection*{[[libc/port/strrchr.c]]}



%-------------------------------------------------------------

<<libc/port/strrchr.c>>=
#include <u.h>
#include <libc.h>

<<function [[strrchr]]>>
@


\subsection*{[[libc/port/strspn.c]]}

<<constant N (port/strspn.c)>>=
#define N   256
@

<<function [[strspn]]>>=
long
strspn(char *s, char *b)
{
    char map[N], *os;

    memset(map, 0, N);
    while(*b)
        map[*(uchar *)b++] = 1;
    os = s;
    while(map[*(uchar *)s++])
        ;
    return s - os - 1;
}
@


%-------------------------------------------------------------

<<libc/port/strspn.c>>=
#include <u.h>
#include <libc.h>

<<constant N (port/strspn.c)>>

<<function [[strspn]]>>
@


\subsection*{[[libc/port/strstr.c]]}



%-------------------------------------------------------------

<<libc/port/strstr.c>>=
#include <u.h>
#include <libc.h>

<<function [[strstr]]>>
@


\subsection*{[[libc/port/strtod.c]]}




%-------------------------------------------------------------

<<libc/port/strtod.c>>=
#include <u.h>
#include <libc.h>
#include <ctype.h>

<<enum [[_anon_ (port/strtod.c)]]>>

static  int xcmp(char*, char*);
static  int fpcmp(char*, ulong*);
static  void    frnorm(ulong*);
static  void    divascii(char*, int*, int*, int*);
static  void    mulascii(char*, int*, int*, int*);
static  void    divby(char*, int*, int);

typedef struct  Tab Tab;
<<struct [[Tab]]>>

<<function [[strtod]]>>

<<function [[frnorm]]>>

<<function [[fpcmp]]>>

<<function [[_divby]]>>

<<function [[divby]]>>

<<global [[tab1]]>>

<<function [[divascii]]>>

<<function [[mulby]]>>

<<global [[tab2]]>>

<<function [[mulascii]]>>

<<function [[xcmp]]>>
@


\subsection*{[[libc/port/strtok.c]]}

<<constant N (port/strtok.c)>>=
#define N   256
@

<<function [[strtok]]>>=
char*
strtok(char *s, char *b)
{
    static char *under_rock;
    char map[N], *os;

    memset(map, 0, N);
    while(*b)
        map[*(uchar*)b++] = 1;
    if(s == 0)
        s = under_rock;
    while(map[*(uchar*)s++])
        ;
    if(*--s == 0)
        return 0;
    os = s;
    while(map[*(uchar*)s] == 0)
        if(*s++ == 0) {
            under_rock = s-1;
            return os;
        }
    *s++ = 0;
    under_rock = s;
    return os;
}
@


%-------------------------------------------------------------

<<libc/port/strtok.c>>=
#include <u.h>
#include <libc.h>

<<constant N (port/strtok.c)>>

<<function [[strtok]]>>
@


\subsection*{[[libc/port/strtol.c]]}


%-------------------------------------------------------------

<<libc/port/strtol.c>>=
#include <u.h>
#include <libc.h>

<<constant [[LONG_MAX]]>>
<<constant [[LONG_MIN]]>>

<<function [[strtol]]>>
@


\subsection*{[[libc/port/strtoll.c]]}

<<constant [[VLONG_MAX]]>>=
#define VLONG_MAX   ~(1LL<<63)
@

<<constant [[VLONG_MIN]]>>=
#define VLONG_MIN   (1LL<<63)
@

<<function [[strtoll]]>>=
vlong
strtoll(char *nptr, char **endptr, int base)
{
    char *p;
    vlong n, nn, m;
    int c, ovfl, v, neg, ndig;

    p = nptr;
    neg = 0;
    n = 0;
    ndig = 0;
    ovfl = 0;

    /*
     * White space
     */
    for(;; p++) {
        switch(*p) {
        case ' ':
        case '\t':
        case '\n':
        case '\f':
        case '\r':
        case '\v':
            continue;
        }
        break;
    }

    /*
     * Sign
     */
    if(*p=='-' || *p=='+')
        if(*p++ == '-')
            neg = 1;

    /*
     * Base
     */
    if(base==0){
        base = 10;
        if(*p == '0') {
            base = 8;
            if(p[1]=='x' || p[1]=='X') {
                p += 2;
                base = 16;
            }
        }
    } else
    if(base==16 && *p=='0') {
        if(p[1]=='x' || p[1]=='X')
            p += 2;
    } else
    if(base<0 || 36<base)
        goto Return;

    /*
     * Non-empty sequence of digits
     */
    m = VLONG_MAX/base;
    for(;; p++,ndig++) {
        c = *p;
        v = base;
        if('0'<=c && c<='9')
            v = c - '0';
        else
        if('a'<=c && c<='z')
            v = c - 'a' + 10;
        else
        if('A'<=c && c<='Z')
            v = c - 'A' + 10;
        if(v >= base)
            break;
        if(n > m)
            ovfl = 1;
        nn = n*base + v;
        if(nn < n)
            ovfl = 1;
        n = nn;
    }

Return:
    if(ndig == 0)
        p = nptr;
    if(endptr)
        *endptr = p;
    if(ovfl){
        if(neg)
            return VLONG_MIN;
        return VLONG_MAX;
    }
    if(neg)
        return -n;
    return n;
}
@


%-------------------------------------------------------------

<<libc/port/strtoll.c>>=
#include <u.h>
#include <libc.h>

<<constant [[VLONG_MAX]]>>
<<constant [[VLONG_MIN]]>>

<<function [[strtoll]]>>
@


\subsection*{[[libc/port/strtoul.c]]}

<<constant [[ULONG_MAX]]>>=
#define ULONG_MAX   4294967295UL
@

<<function [[strtoul]]>>=
ulong
strtoul(char *nptr, char **endptr, int base)
{
    char *p;
    ulong n, nn, m;
    int c, ovfl, neg, v, ndig;

    p = nptr;
    neg = 0;
    n = 0;
    ndig = 0;
    ovfl = 0;

    /*
     * White space
     */
    for(;;p++){
        switch(*p){
        case ' ':
        case '\t':
        case '\n':
        case '\f':
        case '\r':
        case '\v':
            continue;
        }
        break;
    }

    /*
     * Sign
     */
    if(*p=='-' || *p=='+')
        if(*p++ == '-')
            neg = 1;

    /*
     * Base
     */
    if(base==0){
        if(*p != '0')
            base = 10;
        else{
            base = 8;
            if(p[1]=='x' || p[1]=='X')
                base = 16;
        }
    }
    if(base<2 || 36<base)
        goto Return;
    if(base==16 && *p=='0'){
        if(p[1]=='x' || p[1]=='X')
            if(('0' <= p[2] && p[2] <= '9')
             ||('a' <= p[2] && p[2] <= 'f')
             ||('A' <= p[2] && p[2] <= 'F'))
                p += 2;
    }
    /*
     * Non-empty sequence of digits
     */
    n = 0;
    m = ULONG_MAX/base;
    for(;; p++,ndig++){
        c = *p;
        v = base;
        if('0'<=c && c<='9')
            v = c - '0';
        else if('a'<=c && c<='z')
            v = c - 'a' + 10;
        else if('A'<=c && c<='Z')
            v = c - 'A' + 10;
        if(v >= base)
            break;
        if(n > m)
            ovfl = 1;
        nn = n*base + v;
        if(nn < n)
            ovfl = 1;
        n = nn;
    }

    Return:
    if(ndig == 0)
        p = nptr;
    if(endptr)
        *endptr = p;
    if(ovfl)
        return ULONG_MAX;
    if(neg)
        return -n;
    return n;
}
@


%-------------------------------------------------------------

<<libc/port/strtoul.c>>=
#include <u.h>
#include <libc.h>

<<constant [[ULONG_MAX]]>>

<<function [[strtoul]]>>
@


\subsection*{[[libc/port/strtoull.c]]}

<<constant [[UVLONG_MAX]]>>=
#define UVLONG_MAX  (1LL<<63)
@

<<function [[strtoull]]>>=
uvlong
strtoull(char *nptr, char **endptr, int base)
{
    char *p;
    uvlong n, nn, m;
    int c, ovfl, v, neg, ndig;

    p = nptr;
    neg = 0;
    n = 0;
    ndig = 0;
    ovfl = 0;

    /*
     * White space
     */
    for(;; p++) {
        switch(*p) {
        case ' ':
        case '\t':
        case '\n':
        case '\f':
        case '\r':
        case '\v':
            continue;
        }
        break;
    }

    /*
     * Sign
     */
    if(*p == '-' || *p == '+')
        if(*p++ == '-')
            neg = 1;

    /*
     * Base
     */
    if(base == 0) {
        base = 10;
        if(*p == '0') {
            base = 8;
            if(p[1] == 'x' || p[1] == 'X'){
                p += 2;
                base = 16;
            }
        }
    } else
    if(base == 16 && *p == '0') {
        if(p[1] == 'x' || p[1] == 'X')
            p += 2;
    } else
    if(base < 0 || 36 < base)
        goto Return;

    /*
     * Non-empty sequence of digits
     */
    m = UVLONG_MAX/base;
    for(;; p++,ndig++) {
        c = *p;
        v = base;
        if('0' <= c && c <= '9')
            v = c - '0';
        else
        if('a' <= c && c <= 'z')
            v = c - 'a' + 10;
        else
        if('A' <= c && c <= 'Z')
            v = c - 'A' + 10;
        if(v >= base)
            break;
        if(n > m)
            ovfl = 1;
        nn = n*base + v;
        if(nn < n)
            ovfl = 1;
        n = nn;
    }

Return:
    if(ndig == 0)
        p = nptr;
    if(endptr)
        *endptr = p;
    if(ovfl)
        return UVLONG_MAX;
    if(neg)
        return -n;
    return n;
}
@


%-------------------------------------------------------------

<<libc/port/strtoull.c>>=
#include <u.h>
#include <libc.h>

<<constant [[UVLONG_MAX]]>>

<<function [[strtoull]]>>
@


\subsection*{[[libc/port/tan.c]]}




%-------------------------------------------------------------

<<libc/port/tan.c>>=
/*
    floating point tangent

    A series is used after range reduction.
    Coefficients are #4285 from Hart & Cheney. (19.74D)
 */

#include <u.h>
#include <libc.h>

<<global p0 (port/tan.c)>>
<<global p1 (port/tan.c)>>
<<global p2 (port/tan.c)>>
<<global p3 (port/tan.c)>>
<<global [[p4]]>>
<<global q0 (port/tan.c)>>
<<global q1 (port/tan.c)>>
<<global q2 (port/tan.c)>>

<<function [[tan]]>>
@


\subsection*{[[libc/port/tanh.c]]}

<<function [[tanh]]>>=
/*
    tanh(arg) computes the hyperbolic tangent of its floating
    point argument.

    sinh and cosh are called except for large arguments, which
    would cause overflow improperly.
 */

double
tanh(double arg)
{

    if(arg < 0) {
        arg = -arg;
        if(arg > 21)
            return -1;
        return -sinh(arg)/cosh(arg);
    }
    if(arg > 21)
        return 1;
    return sinh(arg)/cosh(arg);
}
@


%-------------------------------------------------------------

<<libc/port/tanh.c>>=
#include <u.h>
#include <libc.h>

<<function [[tanh]]>>
@


\subsection*{[[libc/port/tokenize.c]]}

<<global [[qsep]]>>=
static char qsep[] = " \t\r\n";
@

<<function [[qtoken]]>>=
static char*
qtoken(char *s, char *sep)
{
    int quoting;
    char *t;

    quoting = 0;
    t = s;  /* s is output string, t is input string */
    while(*t!='\0' && (quoting || utfrune(sep, *t)==nil)){
        if(*t != '\''){
            *s++ = *t++;
            continue;
        }
        /* *t is a quote */
        if(!quoting){
            quoting = 1;
            t++;
            continue;
        }
        /* quoting and we're on a quote */
        if(t[1] != '\''){
            /* end of quoted section; absorb closing quote */
            t++;
            quoting = 0;
            continue;
        }
        /* doubled quote; fold one quote into two */
        t++;
        *s++ = *t++;
    }
    if(*s != '\0'){
        *s = '\0';
        if(t == s)
            t++;
    }
    return t;
}
@

<<function [[etoken]]>>=
static char*
etoken(char *t, char *sep)
{
    int quoting;

    /* move to end of next token */
    quoting = 0;
    while(*t!='\0' && (quoting || utfrune(sep, *t)==nil)){
        if(*t != '\''){
            t++;
            continue;
        }
        /* *t is a quote */
        if(!quoting){
            quoting = 1;
            t++;
            continue;
        }
        /* quoting and we're on a quote */
        if(t[1] != '\''){
            /* end of quoted section; absorb closing quote */
            t++;
            quoting = 0;
            continue;
        }
        /* doubled quote; fold one quote into two */
        t += 2;
    }
    return t;
}
@

<<function [[gettokens]]>>=
int
gettokens(char *s, char **args, int maxargs, char *sep)
{
    int nargs;

    for(nargs=0; nargs<maxargs; nargs++){
        while(*s!='\0' && utfrune(sep, *s)!=nil)
            *s++ = '\0';
        if(*s == '\0')
            break;
        args[nargs] = s;
        s = etoken(s, sep);
    }

    return nargs;
}
@

<<function [[tokenize]]>>=
int
tokenize(char *s, char **args, int maxargs)
{
    int nargs;

    for(nargs=0; nargs<maxargs; nargs++){
        while(*s!='\0' && utfrune(qsep, *s)!=nil)
            s++;
        if(*s == '\0')
            break;
        args[nargs] = s;
        s = qtoken(s, qsep);
    }

    return nargs;
}
@


%-------------------------------------------------------------

<<libc/port/tokenize.c>>=
#include <u.h>
#include <libc.h>

<<global [[qsep]]>>

<<function [[qtoken]]>>

<<function [[etoken]]>>

<<function [[gettokens]]>>

<<function [[tokenize]]>>
@


\subsection*{[[libc/port/toupper.c]]}



%-------------------------------------------------------------

<<libc/port/toupper.c>>=
#include    <ctype.h>

<<function [[toupper]]>>

<<function [[tolower]]>>
@


\subsection*{[[libc/port/u16.c]]}

<<global [[t16e]]>>=
static char t16e[] = "0123456789ABCDEF";
@

<<function [[dec16]]>>=
int
dec16(uchar *out, int lim, char *in, int n)
{
    int c, w = 0, i = 0;
    uchar *start = out;
    uchar *eout = out + lim;

    while(n-- > 0){
        c = *in++;
        if('0' <= c && c <= '9')
            c = c - '0';
        else if('a' <= c && c <= 'z')
            c = c - 'a' + 10;
        else if('A' <= c && c <= 'Z')
            c = c - 'A' + 10;
        else
            continue;
        w = (w<<4) + c;
        i++;
        if(i == 2){
            if(out + 1 > eout)
                goto exhausted;
            *out++ = w;
            w = 0;
            i = 0;
        }
    }
exhausted:
    return out - start;
}
@

<<function [[enc16]]>>=
int
enc16(char *out, int lim, uchar *in, int n)
{
    uint c;
    char *eout = out + lim;
    char *start = out;

    while(n-- > 0){
        c = *in++;
        if(out + 2 >= eout)
            goto exhausted;
        *out++ = t16e[c>>4];
        *out++ = t16e[c&0xf];
    }
exhausted:
    *out = 0;
    return out - start;
}
@


%-------------------------------------------------------------

<<libc/port/u16.c>>=
#include <u.h>
#include <libc.h>
<<global [[t16e]]>>

<<function [[dec16]]>>

<<function [[enc16]]>>
@


\subsection*{[[libc/port/u32.c]]}

<<function [[dec32]]>>=
int
dec32(uchar *dest, int ndest, char *src, int nsrc)
{
    char *s, *tab;
    uchar *start;
    int i, u[8];

    if(ndest+1 < (5*nsrc+7)/8)
        return -1;
    start = dest;
    tab = "23456789abcdefghijkmnpqrstuvwxyz";
    while(nsrc>=8){
        for(i=0; i<8; i++){
            s = strchr(tab,(int)src[i]);
            u[i] = s ? s-tab : 0;
        }
        *dest++ = (u[0]<<3) | (0x7 & (u[1]>>2));
        *dest++ = ((0x3 & u[1])<<6) | (u[2]<<1) | (0x1 & (u[3]>>4));
        *dest++ = ((0xf & u[3])<<4) | (0xf & (u[4]>>1));
        *dest++ = ((0x1 & u[4])<<7) | (u[5]<<2) | (0x3 & (u[6]>>3));
        *dest++ = ((0x7 & u[6])<<5) | u[7];
        src  += 8;
        nsrc -= 8;
    }
    if(nsrc > 0){
        if(nsrc == 1 || nsrc == 3 || nsrc == 6)
            return -1;
        for(i=0; i<nsrc; i++){
            s = strchr(tab,(int)src[i]);
            u[i] = s ? s-tab : 0;
        }
        *dest++ = (u[0]<<3) | (0x7 & (u[1]>>2));
        if(nsrc == 2)
            goto out;
        *dest++ = ((0x3 & u[1])<<6) | (u[2]<<1) | (0x1 & (u[3]>>4));
        if(nsrc == 4)
            goto out;
        *dest++ = ((0xf & u[3])<<4) | (0xf & (u[4]>>1));
        if(nsrc == 5)
            goto out;
        *dest++ = ((0x1 & u[4])<<7) | (u[5]<<2) | (0x3 & (u[6]>>3));
    }
out:
    return dest-start;
}
@

<<function [[enc32]]>>=
int
enc32(char *dest, int ndest, uchar *src, int nsrc)
{
    char *tab, *start;
    int j;

    if(ndest <= (8*nsrc+4)/5 )
        return -1;
    start = dest;
    tab = "23456789abcdefghijkmnpqrstuvwxyz";
    while(nsrc>=5){
        j = (0x1f & (src[0]>>3));
        *dest++ = tab[j];
        j = (0x1c & (src[0]<<2)) | (0x03 & (src[1]>>6));
        *dest++ = tab[j];
        j = (0x1f & (src[1]>>1));
        *dest++ = tab[j];
        j = (0x10 & (src[1]<<4)) | (0x0f & (src[2]>>4));
        *dest++ = tab[j];
        j = (0x1e & (src[2]<<1)) | (0x01 & (src[3]>>7));
        *dest++ = tab[j];
        j = (0x1f & (src[3]>>2));
        *dest++ = tab[j];
        j = (0x18 & (src[3]<<3)) | (0x07 & (src[4]>>5));
        *dest++ = tab[j];
        j = (0x1f & (src[4]));
        *dest++ = tab[j];
        src  += 5;
        nsrc -= 5;
    }
    if(nsrc){
        j = (0x1f & (src[0]>>3));
        *dest++ = tab[j];
        j = (0x1c & (src[0]<<2));
        if(nsrc == 1)
            goto out;
        j |= (0x03 & (src[1]>>6));
        *dest++ = tab[j];
        j = (0x1f & (src[1]>>1));
        if(nsrc == 2)
            goto out;
        *dest++ = tab[j];
        j = (0x10 & (src[1]<<4));
        if(nsrc == 3)
            goto out;
        j |= (0x0f & (src[2]>>4));
        *dest++ = tab[j];
        j = (0x1e & (src[2]<<1));
        if(nsrc == 4)
            goto out;
        j |= (0x01 & (src[3]>>7));
        *dest++ = tab[j];
        j = (0x1f & (src[3]>>2));
        *dest++ = tab[j];
        j = (0x18 & (src[3]<<3));
out:
        *dest++ = tab[j];
    }
    *dest = 0;
    return dest-start;
}
@
% >>

%-------------------------------------------------------------

<<libc/port/u32.c>>=
#include <u.h>
#include <libc.h>

<<function [[dec32]]>>

<<function [[enc32]]>>
@


\subsection*{[[libc/port/u64.c]]}

<<enum [[_anon_ (port/u64.c)]]>>=
enum {
    INVAL=  255
};
@

<<global [[t64d]]>>=
static uchar t64d[256] = {
   INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,
   INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,
   INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,   62,INVAL,INVAL,INVAL,   63,
      52,   53,   54,   55,   56,   57,   58,   59,   60,   61,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,
   INVAL,    0,    1,    2,    3,    4,    5,    6,    7,    8,    9,   10,   11,   12,   13,   14,
      15,   16,   17,   18,   19,   20,   21,   22,   23,   24,   25,INVAL,INVAL,INVAL,INVAL,INVAL,
   INVAL,   26,   27,   28,   29,   30,   31,   32,   33,   34,   35,   36,   37,   38,   39,   40,
      41,   42,   43,   44,   45,   46,   47,   48,   49,   50,   51,INVAL,INVAL,INVAL,INVAL,INVAL,
   INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,
   INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,
   INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,
   INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,
   INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,
   INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,
   INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,
   INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL
};
@

<<global [[t64e]]>>=
static char t64e[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
@

<<function [[dec64]]>>=
int
dec64(uchar *out, int lim, char *in, int n)
{
    ulong b24;
    uchar *start = out;
    uchar *e = out + lim;
    int i, c;

    b24 = 0;
    i = 0;
    while(n-- > 0){
 
        c = t64d[*(uchar*)in++];
        if(c == INVAL)
            continue;
        switch(i){
        case 0:
            b24 = c<<18;
            break;
        case 1:
            b24 |= c<<12;
            break;
        case 2:
            b24 |= c<<6;
            break;
        case 3:
            if(out + 3 > e)
                goto exhausted;

            b24 |= c;
            *out++ = b24>>16;
            *out++ = b24>>8;
            *out++ = b24;
            i = -1;
            break;
        }
        i++;
    }
    switch(i){
    case 2:
        if(out + 1 > e)
            goto exhausted;
        *out++ = b24>>16;
        break;
    case 3:
        if(out + 2 > e)
            goto exhausted;
        *out++ = b24>>16;
        *out++ = b24>>8;
        break;
    }
exhausted:
    return out - start;
}
@

<<function [[enc64]]>>=
int
enc64(char *out, int lim, uchar *in, int n)
{
    int i;
    ulong b24;
    char *start = out;
    char *e = out + lim;

    for(i = n/3; i > 0; i--){
        b24 = (*in++)<<16;
        b24 |= (*in++)<<8;
        b24 |= *in++;
        if(out + 4 >= e)
            goto exhausted;
        *out++ = t64e[(b24>>18)];
        *out++ = t64e[(b24>>12)&0x3f];
        *out++ = t64e[(b24>>6)&0x3f];
        *out++ = t64e[(b24)&0x3f];
    }

    switch(n%3){
    case 2:
        b24 = (*in++)<<16;
        b24 |= (*in)<<8;
        if(out + 4 >= e)
            goto exhausted;
        *out++ = t64e[(b24>>18)];
        *out++ = t64e[(b24>>12)&0x3f];
        *out++ = t64e[(b24>>6)&0x3f];
        *out++ = '=';
        break;
    case 1:
        b24 = (*in)<<16;
        if(out + 4 >= e)
            goto exhausted;
        *out++ = t64e[(b24>>18)];
        *out++ = t64e[(b24>>12)&0x3f];
        *out++ = '=';
        *out++ = '=';
        break;
    }
exhausted:
    *out = 0;
    return out - start;
}
@


%-------------------------------------------------------------

<<libc/port/u64.c>>=
#include <u.h>
#include <libc.h>

<<enum [[_anon_ (port/u64.c)]]>>

<<global [[t64d]]>>
<<global [[t64e]]>>

<<function [[dec64]]>>

<<function [[enc64]]>>
@


\subsection*{[[libc/port/utfecpy.c]]}

<<function [[utfecpy]]>>=
char*
utfecpy(char *to, char *e, char *from)
{
    char *end;

    if(to >= e)
        return to;
    end = memccpy(to, from, '\0', e - to);
    if(end == nil){
        end = e;
        while(end>to && (*--end&0xC0)==0x80)
            ;
        *end = '\0';
    }else{
        end--;
    }
    return end;
}
@


%-------------------------------------------------------------

<<libc/port/utfecpy.c>>=
#include <u.h>
#include <libc.h>

<<function [[utfecpy]]>>
@


\subsection*{[[libc/port/utflen.c]]}



%-------------------------------------------------------------

<<libc/port/utflen.c>>=
#include <u.h>
#include <libc.h>

<<function [[utflen]]>>
@


\subsection*{[[libc/port/utfnlen.c]]}

<<function [[utfnlen]]>>=
int
utfnlen(char *s, long m)
{
    int c;
    long n;
    Rune rune;
    char *es;

    es = s + m;
    for(n = 0; s < es; n++) {
        c = *(uchar*)s;
        if(c < Runeself){
            if(c == '\0')
                break;
            s++;
            continue;
        }
        if(!fullrune(s, es-s))
            break;
        s += chartorune(&rune, s);
    }
    return n;
}
@


%-------------------------------------------------------------

<<libc/port/utfnlen.c>>=
#include <u.h>
#include <libc.h>

<<function [[utfnlen]]>>
@


\subsection*{[[libc/port/utfrrune.c]]}



%-------------------------------------------------------------

<<libc/port/utfrrune.c>>=
#include <u.h>
#include <libc.h>

<<function [[utfrrune]]>>
@


\subsection*{[[libc/port/utfrune.c]]}



%-------------------------------------------------------------

<<libc/port/utfrune.c>>=
#include <u.h>
#include <libc.h>

<<function [[utfrune]]>>
@


\subsection*{[[libc/port/utfutf.c]]}



%-------------------------------------------------------------

<<libc/port/utfutf.c>>=
#include <u.h>
#include <libc.h>


<<function [[utfutf]]>>
@


\section{[[lib_core/libc/9sys/]]}

\subsection*{[[libc/9sys/abort.c]]}



%-------------------------------------------------------------

<<libc/9sys/abort.c>>=
#include <u.h>
#include <libc.h>

<<function [[abort]]>>
@


\subsection*{[[libc/9sys/access.c]]}


%-------------------------------------------------------------

<<libc/9sys/access.c>>=
#include <u.h>
#include <libc.h>

<<function [[access]]>>
@


\subsection*{[[libc/9sys/announce.c]]}

<<enum [[_anon_ (9sys/announce.c)]]>>=
enum
{
    Maxpath=    256,
};
@


<<function [[identtrans]]>>=
/*
 *  perform the identity translation (in case we can't reach cs)
 */
static int
identtrans(char *netdir, char *addr, char *naddr, int na, char *file, int nf)
{
    char proto[Maxpath];
    char *p;

    USED(nf);

    /* parse the protocol */
    strncpy(proto, addr, sizeof(proto));
    proto[sizeof(proto)-1] = 0;
    p = strchr(proto, '!');
    if(p)
        *p++ = 0;

    snprint(file, nf, "%s/%s/clone", netdir, proto);
    strncpy(naddr, p, na);
    naddr[na-1] = 0;

    return 1;
}
@

<<function [[nettrans]]>>=
/*
 *  call up the connection server and get a translation
 */
static int
nettrans(char *addr, char *naddr, int na, char *file, int nf)
{
    int i, fd;
    char buf[Maxpath];
    char netdir[Maxpath];
    char *p, *p2;
    long n;

    /*
     *  parse, get network directory
     */
    p = strchr(addr, '!');
    if(p == 0){
        werrstr("bad dial string: %s", addr);
        return -1;
    }
    if(*addr != '/'){
        strncpy(netdir, "/net", sizeof(netdir));
        netdir[sizeof(netdir) - 1] = 0;
    } else {
        for(p2 = p; *p2 != '/'; p2--)
            ;
        i = p2 - addr;
        if(i == 0 || i >= sizeof(netdir)){
            werrstr("bad dial string: %s", addr);
            return -1;
        }
        strncpy(netdir, addr, i);
        netdir[i] = 0;
        addr = p2 + 1;
    }

    /*
     *  ask the connection server
     */
    snprint(buf, sizeof(buf), "%s/cs", netdir);
    fd = open(buf, ORDWR);
    if(fd < 0)
        return identtrans(netdir, addr, naddr, na, file, nf);
    if(write(fd, addr, strlen(addr)) < 0){
        close(fd);
        return -1;
    }
    seek(fd, 0, 0);
    n = read(fd, buf, sizeof(buf)-1);
    close(fd);
    if(n <= 0)
        return -1;
    buf[n] = 0;

    /*
     *  parse the reply
     */
    p = strchr(buf, ' ');
    if(p == 0)
        return -1;
    *p++ = 0;
    strncpy(naddr, p, na);
    naddr[na-1] = 0;

    if(buf[0] == '/'){
        p = strchr(buf+1, '/');
        if(p == nil)
            p = buf;
        else 
            p++;
    }
    snprint(file, nf, "%s/%s", netdir, p);
    return 0;
}
@


%-------------------------------------------------------------

<<libc/9sys/announce.c>>=
#include <u.h>
#include <libc.h>
#include <ctype.h>

static int  nettrans(char*, char*, int na, char*, int);

<<enum [[_anon_ (9sys/announce.c)]]>>

<<function [[announce]]>>

<<function [[listen]]>>

<<function [[accept]]>>

<<function [[reject]]>>

<<function [[identtrans]]>>

<<function [[nettrans]]>>
@


\subsection*{[[libc/9sys/convD2M.c]]}

<<function [[sizeD2M]]>>=
uint
sizeD2M(Dir *d)
{
    char *sv[4];
    int i, ns;

    sv[0] = d->name;
    sv[1] = d->uid;
    sv[2] = d->gid;
    sv[3] = d->muid;

    ns = 0;
    for(i = 0; i < 4; i++)
        if(sv[i])
            ns += strlen(sv[i]);

    return STATFIXLEN + ns;
}
@


%-------------------------------------------------------------

<<libc/9sys/convD2M.c>>=
#include    <u.h>
#include    <libc.h>
#include    <fcall.h>

<<function [[sizeD2M]]>>

<<function [[convD2M]]>>
@


\subsection*{[[libc/9sys/convM2D.c]]}

<<function [[statcheck]]>>=
int
statcheck(uchar *buf, uint nbuf)
{
    uchar *ebuf;
    int i;

    ebuf = buf + nbuf;

    if(nbuf < STATFIXLEN || nbuf != BIT16SZ + GBIT16(buf))
        return -1;

    buf += STATFIXLEN - 4 * BIT16SZ;

    for(i = 0; i < 4; i++){
        if(buf + BIT16SZ > ebuf)
            return -1;
        buf += BIT16SZ + GBIT16(buf);
    }

    if(buf != ebuf)
        return -1;

    return 0;
}
@

<<global [[nullstring]]>>=
static char nullstring[] = "";
@


%-------------------------------------------------------------

<<libc/9sys/convM2D.c>>=
#include    <u.h>
#include    <libc.h>
#include    <fcall.h>

<<function [[statcheck]]>>

<<global [[nullstring]]>>

<<function [[convM2D]]>>
@


\subsection*{[[libc/9sys/convM2S.c]]}


%-------------------------------------------------------------

<<libc/9sys/convM2S.c>>=
#include    <u.h>
#include    <libc.h>
#include    <fcall.h>

<<function [[gstring]]>>

<<function [[gqid]]>>

<<function [[convM2S]]>>
@


\subsection*{[[libc/9sys/convS2M.c]]}




%-------------------------------------------------------------

<<libc/9sys/convS2M.c>>=
#include    <u.h>
#include    <libc.h>
#include    <fcall.h>

<<function [[pstring]]>>

<<function [[pqid]]>>

<<function [[stringsz]]>>

<<function [[sizeS2M]]>>

<<function [[convS2M]]>>
@


\subsection*{[[libc/9sys/cputime.c]]}



%-------------------------------------------------------------

<<libc/9sys/cputime.c>>=
#include <u.h>
#include <libc.h>

<<constant [[HZ]]>>

<<function [[cputime]]>>
@


\subsection*{[[libc/9sys/ctime.c]]}

<<global [[dmsize]]>>=
static  char    dmsize[12] =
{
    31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
};
@

<<constant [[TZSIZE]]>>=
#define TZSIZE  150
@

<<global [[timezone]]>>=
static
struct
{
    char    stname[4];
    char    dlname[4];
    long    stdiff;
    long    dldiff;
    long    dlpairs[TZSIZE];
} timezone;
@

<<function [[ctime]]>>=
char*
ctime(long t)
{
    return asctime(localtime(t));
}
@


<<function [[gmtime]]>>=
Tm*
gmtime(long tim)
{
    int d0, d1;
    long hms, day;
    static Tm xtime;

    /*
     * break initial number into days
     */
    hms = (ulong)tim % 86400L;
    day = (ulong)tim / 86400L;
    if(hms < 0) {
        hms += 86400L;
        day -= 1;
    }

    /*
     * generate hours:minutes:seconds
     */
    xtime.sec = hms % 60;
    d1 = hms / 60;
    xtime.min = d1 % 60;
    d1 /= 60;
    xtime.hour = d1;

    /*
     * day is the day number.
     * generate day of the week.
     * The addend is 4 mod 7 (1/1/1970 was Thursday)
     */

    xtime.wday = (day + 7340036L) % 7;

    /*
     * year number
     */
    if(day >= 0)
        for(d1 = 1970; day >= dysize(d1); d1++)
            day -= dysize(d1);
    else
        for (d1 = 1970; day < 0; d1--)
            day += dysize(d1-1);
    xtime.year = d1-1900;
    xtime.yday = d0 = day;

    /*
     * generate month
     */

    if(dysize(d1) == 366)
        dmsize[1] = 29;
    for(d1 = 0; d0 >= dmsize[d1]; d1++)
        d0 -= dmsize[d1];
    dmsize[1] = 28;
    xtime.mday = d0 + 1;
    xtime.mon = d1;
    strcpy(xtime.zone, "GMT");
    return &xtime;
}
@


<<function [[dysize]]>>=
static int
dysize(int y)
{

    if(y%4 == 0 && (y%100 != 0 || y%400 == 0))
        return 366;
    return 365;
}
@

<<function [[ct_numb]]>>=
static
void
ct_numb(char *cp, int n)
{

    cp[0] = ' ';
    if(n >= 10)
        cp[0] = (n/10)%10 + '0';
    cp[1] = n%10 + '0';
}
@

<<function [[readtimezone]]>>=
static
void
readtimezone(void)
{
    char buf[TZSIZE*11+30], *p;
    int i;

    memset(buf, 0, sizeof(buf));
    i = open("/env/timezone", 0);
    if(i < 0)
        goto error;
    if(read(i, buf, sizeof(buf)) >= sizeof(buf)){
        close(i);
        goto error;
    }
    close(i);
    p = buf;
    if(rd_name(&p, timezone.stname))
        goto error;
    if(rd_long(&p, &timezone.stdiff))
        goto error;
    if(rd_name(&p, timezone.dlname))
        goto error;
    if(rd_long(&p, &timezone.dldiff))
        goto error;
    for(i=0; i<TZSIZE; i++) {
        if(rd_long(&p, &timezone.dlpairs[i]))
            goto error;
        if(timezone.dlpairs[i] == 0)
            return;
    }

error:
    timezone.stdiff = 0;
    strcpy(timezone.stname, "GMT");
    timezone.dlpairs[0] = 0;
}
@

<<function [[rd_name]]>>=
static int
rd_name(char **f, char *p)
{
    int c, i;

    for(;;) {
        c = *(*f)++;
        if(c != ' ' && c != '\n')
            break;
    }
    for(i=0; i<3; i++) {
        if(c == ' ' || c == '\n')
            return 1;
        *p++ = c;
        c = *(*f)++;
    }
    if(c != ' ' && c != '\n')
        return 1;
    *p = 0;
    return 0;
}
@

<<function [[rd_long]]>>=
static int
rd_long(char **f, long *p)
{
    int c, s;
    long l;

    s = 0;
    for(;;) {
        c = *(*f)++;
        if(c == '-') {
            s++;
            continue;
        }
        if(c != ' ' && c != '\n')
            break;
    }
    if(c == 0) {
        *p = 0;
        return 0;
    }
    l = 0;
    for(;;) {
        if(c == ' ' || c == '\n')
            break;
        if(c < '0' || c > '9')
            return 1;
        l = l*10 + c-'0';
        c = *(*f)++;
    }
    if(s)
        l = -l;
    *p = l;
    return 0;
}
@


%-------------------------------------------------------------

<<libc/9sys/ctime.c>>=
/*
 * This routine converts time as follows.
 * The epoch is 0000 Jan 1 1970 GMT.
 * The argument time is in seconds since then.
 * The localtime(t) entry returns a pointer to an array
 * containing
 *
 *  seconds (0-59)
 *  minutes (0-59)
 *  hours (0-23)
 *  day of month (1-31)
 *  month (0-11)
 *  year-1970
 *  weekday (0-6, Sun is 0)
 *  day of the year
 *  daylight savings flag
 *
 * The routine gets the daylight savings time from the environment.
 *
 * asctime(tvec))
 * where tvec is produced by localtime
 * returns a ptr to a character string
 * that has the ascii time in the form
 *
 *                              \\
 *  Thu Jan 01 00:00:00 GMT 1970n0
 *  012345678901234567890123456789
 *  0     1     2
 *
 * ctime(t) just calls localtime, then asctime.
 */

#include <u.h>
#include <libc.h>

<<global [[dmsize]]>>

/*
 * The following table is used for 1974 and 1975 and
 * gives the day number of the first day after the Sunday of the
 * change.
 */

static  int dysize(int);
static  void    ct_numb(char*, int);

<<constant [[TZSIZE]]>>
static  void    readtimezone(void);
static  int rd_name(char**, char*);
static  int rd_long(char**, long*);
<<global [[timezone]]>>

<<function [[ctime]]>>

<<function [[localtime]]>>

<<function [[gmtime]]>>

<<function [[asctime]]>>

<<function [[dysize]]>>

<<function [[ct_numb]]>>

<<function [[readtimezone]]>>

<<function [[rd_name]]>>

<<function [[rd_long]]>>
@


\subsection*{[[libc/9sys/dial.c]]}

<<enum [[_anon_ (9sys/dial.c)]]>>=
enum
{
    Maxstring   = 128,
    Maxpath     = 256,

    Maxcsreply  = 64*80,    /* this is probably overly generous */
    /*
     * this should be a plausible slight overestimate for non-interactive
     * use even if it's ridiculously long for interactive use.
     */
    Maxconnms   = 2*60*1000,    /* 2 minutes */
};
@

<<struct [[DS]](9sys/dial.c)>>=
struct DS {
    /* dist string */
    char    buf[Maxstring];
    char    *netdir;
    char    *proto;
    char    *rem;

    /* other args */
    char    *local;
    char    *dir;
    int *cfdp;
};
@

<<struct [[Conn]]>>=
/*
 * malloc these; they need to be writable by this proc & all children.
 * the stack is private to each proc, and static allocation in the data
 * segment would not permit concurrent dials within a multi-process program.
 */
struct Conn {
    int pid;
    int dead;

    int dfd;
    int cfd;
    char    dir[NETPATHLEN+1];
    char    err[ERRMAX];
};
@

<<struct [[Dest]]>>=
struct Dest {
    Conn    *conn;          /* allocated array */
    Conn    *connend;
    int nkid;

    long    oalarm;
    int naddrs;

    QLock   winlck;
    int winner;         /* index into conn[] */

    char    *nextaddr;
    char    addrlist[Maxcsreply];
};
@




<<function [[connsalloc]]>>=
static int
connsalloc(Dest *dp, int addrs)
{
    Conn *conn;

    free(dp->conn);
    dp->connend = nil;
    assert(addrs > 0);

    dp->conn = mallocz(addrs * sizeof *dp->conn, 1);
    if(dp->conn == nil)
        return -1;
    dp->connend = dp->conn + addrs;
    for(conn = dp->conn; conn < dp->connend; conn++)
        conn->cfd = conn->dfd = -1;
    return 0;
}
@

<<function [[freedest]]>>=
static void
freedest(Dest *dp)
{
    long oalarm;

    if (dp == nil)
        return;
    oalarm = dp->oalarm;
    free(dp->conn);
    free(dp);
    if (oalarm >= 0)
        alarm(oalarm);
}
@

<<function [[closeopenfd]]>>=
static void
closeopenfd(int *fdp)
{
    if (*fdp >= 0) {
        close(*fdp);
        *fdp = -1;
    }
}
@

<<function [[notedeath]]>>=
static void
notedeath(Dest *dp, char *exitsts)
{
    int i, n, pid;
    char *fields[5];            /* pid + 3 times + error */
    Conn *conn;

    for (i = 0; i < nelem(fields); i++)
        fields[i] = "";
    n = tokenize(exitsts, fields, nelem(fields));
    if (n < 4)
        return;
    pid = atoi(fields[0]);
    if (pid <= 0)
        return;
    for (conn = dp->conn; conn < dp->connend; conn++)
        if (conn->pid == pid && !conn->dead) {  /* it's one we know? */
            if (conn - dp->conn != dp->winner) {
                closeopenfd(&conn->dfd);
                closeopenfd(&conn->cfd);
            }
            strncpy(conn->err, fields[4], sizeof conn->err - 1);
            conn->err[sizeof conn->err - 1] = '\0';
            conn->dead = 1;
            return;
        }
    /* not a proc that we forked */
}
@

<<function [[outstandingprocs]]>>=
static int
outstandingprocs(Dest *dp)
{
    Conn *conn;

    for (conn = dp->conn; conn < dp->connend; conn++)
        if (!conn->dead)
            return 1;
    return 0;
}
@

<<function [[reap]]>>=
static int
reap(Dest *dp)
{
    char exitsts[2*ERRMAX];

    if (outstandingprocs(dp) && await(exitsts, sizeof exitsts) >= 0) {
        notedeath(dp, exitsts);
        return 0;
    }
    return -1;
}
@

<<function [[fillinds]]>>=
static int
fillinds(DS *ds, Dest *dp)
{
    Conn *conn;

    if (dp->winner < 0)
        return -1;
    conn = &dp->conn[dp->winner];
    if (ds->cfdp)
        *ds->cfdp = conn->cfd;
    if (ds->dir) {
        strncpy(ds->dir, conn->dir, NETPATHLEN);
        ds->dir[NETPATHLEN-1] = '\0';
    }
    return conn->dfd;
}
@

<<function [[connectwait]]>>=
static int
connectwait(Dest *dp, char *besterr)
{
    Conn *conn;

    /* wait for a winner or all attempts to time out */
    while (dp->winner < 0 && reap(dp) >= 0)
        ;

    /* kill all of our still-live kids & reap them */
    for (conn = dp->conn; conn < dp->connend; conn++)
        if (!conn->dead)
            postnote(PNPROC, conn->pid, "alarm");
    while (reap(dp) >= 0)
        ;

    /* rummage about and report some error string */
    for (conn = dp->conn; conn < dp->connend; conn++)
        if (conn - dp->conn != dp->winner && conn->dead &&
            conn->err[0]) {
            strncpy(besterr, conn->err, ERRMAX-1);
            besterr[ERRMAX-1] = '\0';
            break;
        }
    return dp->winner;
}
@

<<function [[parsecs]]>>=
static int
parsecs(Dest *dp, char **clonep, char **destp)
{
    char *dest, *p;

    dest = strchr(dp->nextaddr, ' ');
    if(dest == nil) {
        p = strchr(dp->nextaddr, '\n');
        if(p)
            *p = '\0';
        werrstr("malformed clone cmd from cs `%s'", dp->nextaddr);
        if(p)
            *p = '\n';
        return -1;
    }
    *dest++ = '\0';
    p = strchr(dest, '\n');
    if(p == nil)
        return -1;
    *p++ = '\0';
    *clonep = dp->nextaddr;
    *destp = dest;
    dp->nextaddr = p;       /* advance to next line */
    return 0;
}
@

<<function [[pickuperr]]>>=
static void
pickuperr(char *besterr, char *err)
{
    err[0] = '\0';
    errstr(err, ERRMAX);
    if(strstr(err, "does not exist") == 0)
        strcpy(besterr, err);
}
@

<<function [[catcher]]>>=
static int
catcher(void *, char *s)
{
    return strstr(s, "alarm") != nil;
}
@

<<function [[dialmulti]]>>=
/*
 * try all addresses in parallel and take the first one that answers;
 * this helps when systems have ip v4 and v6 addresses but are
 * only reachable from here on one (or some) of them.
 */
static int
dialmulti(DS *ds, Dest *dp)
{
    int rv, kid, kidme;
    char *clone, *dest;
    char besterr[ERRMAX];

    dp->winner = -1;
    dp->nkid = 0;
    while(dp->winner < 0 && *dp->nextaddr != '\0' &&
        parsecs(dp, &clone, &dest) >= 0) {
        kidme = dp->nkid++;     /* make private copy on stack */
        kid = rfork(RFPROC|RFMEM);  /* spin off a call attempt */
        if (kid < 0)
            --dp->nkid;
        else if (kid == 0) {
            char err[ERRMAX];

            /* only in kid, to avoid atnotify callbacks in parent */
            atnotify(catcher, 1);

            *besterr = '\0';
            rv = call(clone, dest, ds, dp, &dp->conn[kidme]);
            if(rv < 0)
                pickuperr(besterr, err);
            _exits(besterr);    /* avoid atexit callbacks */
        }
    }
    *besterr = '\0';
    rv = connectwait(dp, besterr);
    if(rv < 0)
        werrstr("%s", (*besterr? besterr: "unknown error"));
    return rv;
}
@

<<function [[csdial]](9sys/dial.c)>>=
static int
csdial(DS *ds)
{
    int n, fd, rv, addrs, bleft;
    char c;
    char *addrp, *clone2, *dest;
    char buf[Maxstring], clone[Maxpath], err[ERRMAX], besterr[ERRMAX];
    Dest *dp;

    werrstr("");
    dp = mallocz(sizeof *dp, 1);
    if(dp == nil)
        return -1;
    dp->winner = -1;
    dp->oalarm = alarm(0);
    if (connsalloc(dp, 1) < 0) {        /* room for a single conn. */
        freedest(dp);
        return -1;
    }

    /*
     *  open connection server
     */
    snprint(buf, sizeof(buf), "%s/cs", ds->netdir);
    fd = open(buf, ORDWR);
    if(fd < 0){
        /* no connection server, don't translate */
        snprint(clone, sizeof(clone), "%s/%s/clone", ds->netdir, ds->proto);
        rv = call(clone, ds->rem, ds, dp, &dp->conn[0]);
        fillinds(ds, dp);
        freedest(dp);
        return rv;
    }

    /*
     *  ask connection server to translate
     *  e.g., net!cs.bell-labs.com!smtp
     */
    snprint(buf, sizeof(buf), "%s!%s", ds->proto, ds->rem);
    if(write(fd, buf, strlen(buf)) < 0){
        close(fd);
        freedest(dp);
        return -1;
    }

    /*
     *  read all addresses from the connection server:
     *  /net/tcp/clone 135.104.9.78!25
     *  /net/tcp/clone 2620:0:dc0:1805::29!25
     *
     *  assumes that we'll get one record per read.
     */
    seek(fd, 0, 0);
    addrs = 0;
    addrp = dp->nextaddr = dp->addrlist;
    bleft = sizeof dp->addrlist - 2;    /* 2 is room for \n\0 */
    while(bleft > 0 && (n = read(fd, addrp, bleft)) > 0) {
        if (addrp[n-1] != '\n')
            addrp[n++] = '\n';
        addrs++;
        addrp += n;
        bleft -= n;
    }
    *addrp = '\0';

    /*
     * if we haven't read all of cs's output, assume the last line might
     * have been truncated and ignore it.  we really don't expect this
     * to happen.
     */
    if (addrs > 0 && bleft <= 0 && read(fd, &c, 1) == 1)
        addrs--;
    close(fd);

    *besterr = 0;
    rv = -1;                /* pessimistic default */
    dp->naddrs = addrs;
    if (addrs == 0)
        werrstr("no address to dial");
    else if (addrs == 1) {
        /* common case: dial one address without forking */
        if (parsecs(dp, &clone2, &dest) >= 0 &&
            (rv = call(clone2, dest, ds, dp, &dp->conn[0])) < 0) {
            pickuperr(besterr, err);
            werrstr("%s", besterr);
        }
    } else if (connsalloc(dp, addrs) >= 0)
        rv = dialmulti(ds, dp);

    /* fill in results */
    if (rv >= 0 && dp->winner >= 0)
        rv = fillinds(ds, dp);

    freedest(dp);
    return rv;
}
@

<<function [[call]](9sys/dial.c)>>=
static int
call(char *clone, char *dest, DS *ds, Dest *dp, Conn *conn)
{
    int fd, cfd, n, calleralarm, oalarm;
    char cname[Maxpath], name[Maxpath], data[Maxpath], *p;

    /* because cs is in a different name space, replace the mount point */
    if(*clone == '/'){
        p = strchr(clone+1, '/');
        if(p == nil)
            p = clone;
        else 
            p++;
    } else
        p = clone;
    snprint(cname, sizeof cname, "%s/%s", ds->netdir, p);

    conn->pid = getpid();
    conn->cfd = cfd = open(cname, ORDWR);
    if(cfd < 0)
        return -1;

    /* get directory name */
    n = read(cfd, name, sizeof(name)-1);
    if(n < 0){
        closeopenfd(&conn->cfd);
        return -1;
    }
    name[n] = 0;
    for(p = name; *p == ' '; p++)
        ;
    snprint(name, sizeof(name), "%ld", strtoul(p, 0, 0));
    p = strrchr(cname, '/');
    *p = 0;
    if(ds->dir)
        snprint(conn->dir, NETPATHLEN, "%s/%s", cname, name);
    snprint(data, sizeof(data), "%s/%s/data", cname, name);

    /* should be no alarm pending now; re-instate caller's alarm, if any */
    calleralarm = dp->oalarm > 0;
    if (calleralarm)
        alarm(dp->oalarm);
    else if (dp->naddrs > 1)    /* in a sub-process? */
        alarm(Maxconnms);

    /* connect */
    if(ds->local)
        snprint(name, sizeof(name), "connect %s %s", dest, ds->local);
    else
        snprint(name, sizeof(name), "connect %s", dest);
    if(write(cfd, name, strlen(name)) < 0){
        closeopenfd(&conn->cfd);
        return -1;
    }

    oalarm = alarm(0);  /* don't let alarm interrupt critical section */
    if (calleralarm)
        dp->oalarm = oalarm;    /* time has passed, so update user's */

    /* open data connection */
    conn->dfd = fd = open(data, ORDWR);
    if(fd < 0){
        closeopenfd(&conn->cfd);
        alarm(dp->oalarm);
        return -1;
    }
    if(ds->cfdp == nil)
        closeopenfd(&conn->cfd);

    n = conn - dp->conn;
    if (dp->winner < 0) {
        qlock(&dp->winlck);
        if (dp->winner < 0 && conn < dp->connend)
            dp->winner = n;
        qunlock(&dp->winlck);
    }
    alarm(calleralarm? dp->oalarm: 0);
    return fd;
}
@

<<function [[_dial_string_parse]](9sys/dial.c)>>=
/*
 *  parse a dial string
 */
static void
_dial_string_parse(char *str, DS *ds)
{
    char *p, *p2;

    strncpy(ds->buf, str, Maxstring);
    ds->buf[Maxstring-1] = 0;

    p = strchr(ds->buf, '!');
    if(p == 0) {
        ds->netdir = 0;
        ds->proto = "net";
        ds->rem = ds->buf;
    } else {
        if(*ds->buf != '/' && *ds->buf != '#'){
            ds->netdir = 0;
            ds->proto = ds->buf;
        } else {
            /* expecting /net.alt/tcp!foo or #I1/tcp!foo */
            for(p2 = p; p2 > ds->buf && *p2 != '/'; p2--)
                ;
            *p2++ = 0;
            ds->netdir = ds->buf;
            ds->proto = p2;
        }
        *p = 0;
        ds->rem = p + 1;
    }
}
@


%-------------------------------------------------------------

<<libc/9sys/dial.c>>=
/*
 * dial - connect to a service (parallel version)
 */
#include <u.h>
#include <libc.h>

typedef struct Conn Conn;
typedef struct Dest Dest;
typedef struct DS DS;

<<enum [[_anon_ (9sys/dial.c)]]>>

<<struct [[DS]](9sys/dial.c)>>

<<struct [[Conn]]>>
<<struct [[Dest]]>>

static int  call(char*, char*, DS*, Dest*, Conn*);
static int  csdial(DS*);
static void _dial_string_parse(char*, DS*);


<<function [[dialimpl]]>>

<<global [[_dial]]>>

<<function [[dial]]>>

<<function [[connsalloc]]>>

<<function [[freedest]]>>

<<function [[closeopenfd]]>>

<<function [[notedeath]]>>

<<function [[outstandingprocs]]>>

<<function [[reap]]>>

<<function [[fillinds]]>>

<<function [[connectwait]]>>

<<function [[parsecs]]>>

<<function [[pickuperr]]>>

<<function [[catcher]]>>

<<function [[dialmulti]]>>

<<function [[csdial]](9sys/dial.c)>>

<<function [[call]](9sys/dial.c)>>

<<function [[_dial_string_parse]](9sys/dial.c)>>
@


\subsection*{[[libc/9sys/dirfstat.c]]}



%-------------------------------------------------------------

<<libc/9sys/dirfstat.c>>=
#include <u.h>
#include <libc.h>
#include <fcall.h>

<<enum [[_anon_ (9sys/dirfstat.c)]]>>

<<function [[dirfstat]]>>
@


\subsection*{[[libc/9sys/dirfwstat.c]]}



%-------------------------------------------------------------

<<libc/9sys/dirfwstat.c>>=
#include <u.h>
#include <libc.h>
#include <fcall.h>

<<function [[dirfwstat]]>>
@


\subsection*{[[libc/9sys/dirmodefmt.c]]}

<<global [[modes]]>>=
static char *modes[] =
{
    "---",
    "--x",
    "-w-",
    "-wx",
    "r--",
    "r-x",
    "rw-",
    "rwx",
};
@

<<function [[rwx]]>>=
static void
rwx(long m, char *s)
{
    strncpy(s, modes[m], 3);
}
@

<<function [[dirmodefmt]]>>=
int
dirmodefmt(Fmt *f)
{
    static char buf[16];
    ulong m;

    m = va_arg(f->args, ulong);

    if(m & DMDIR)
        buf[0]='d';
    else if(m & DMAPPEND)
        buf[0]='a';
    else if(m & DMAUTH)
        buf[0]='A';
    else
        buf[0]='-';
    if(m & DMEXCL)
        buf[1]='l';
    else
        buf[1]='-';
    rwx((m>>6)&7, buf+2);
    rwx((m>>3)&7, buf+5);
    rwx((m>>0)&7, buf+8);
    buf[11] = 0;
    return fmtstrcpy(f, buf);
}
@


%-------------------------------------------------------------

<<libc/9sys/dirmodefmt.c>>=
#include <u.h>
#include <libc.h>
#include <fcall.h>

<<global [[modes]]>>

<<function [[rwx]]>>

<<function [[dirmodefmt]]>>
@


\subsection*{[[libc/9sys/dirread.c]]}

<<function [[dirpackage]]>>=
static
long
dirpackage(uchar *buf, long ts, Dir **d)
{
    char *s;
    long ss, i, n, nn, m;

    *d = nil;
    if(ts <= 0)
        return 0;

    /*
     * first find number of all stats, check they look like stats, & size all associated strings
     */
    ss = 0;
    n = 0;
    for(i = 0; i < ts; i += m){
        m = BIT16SZ + GBIT16(&buf[i]);
        if(statcheck(&buf[i], m) < 0)
            break;
        ss += m;
        n++;
    }

    if(i != ts)
        return -1;

    *d = malloc(n * sizeof(Dir) + ss);
    if(*d == nil)
        return -1;

    /*
     * then convert all buffers
     */
    s = (char*)*d + n * sizeof(Dir);
    nn = 0;
    for(i = 0; i < ts; i += m){
        m = BIT16SZ + GBIT16((uchar*)&buf[i]);
        if(nn >= n || convM2D(&buf[i], m, *d + nn, s) != m){
            free(*d);
            *d = nil;
            return -1;
        }
        nn++;
        s += m;
    }

    return nn;
}
@

<<function [[dirread]]>>=
long
dirread(int fd, Dir **d)
{
    uchar *buf;
    long ts;

    buf = malloc(DIRMAX);
    if(buf == nil)
        return -1;
    ts = read(fd, buf, DIRMAX);
    if(ts >= 0)
        ts = dirpackage(buf, ts, d);
    free(buf);
    return ts;
}
@

<<function [[dirreadall]]>>=
long
dirreadall(int fd, Dir **d)
{
    uchar *buf, *nbuf;
    long n, ts;

    buf = nil;
    ts = 0;
    for(;;){
        nbuf = realloc(buf, ts+DIRMAX);
        if(nbuf == nil){
            free(buf);
            return -1;
        }
        buf = nbuf;
        n = read(fd, buf+ts, DIRMAX);
        if(n <= 0)
            break;
        ts += n;
    }
    if(ts >= 0)
        ts = dirpackage(buf, ts, d);
    free(buf);
    if(ts == 0 && n < 0)
        return -1;
    return ts;
}
@


%-------------------------------------------------------------

<<libc/9sys/dirread.c>>=
#include <u.h>
#include <libc.h>
#include <fcall.h>

<<function [[dirpackage]]>>

<<function [[dirread]]>>

<<function [[dirreadall]]>>
@


\subsection*{[[libc/9sys/dirstat.c]]}



%-------------------------------------------------------------

<<libc/9sys/dirstat.c>>=
#include <u.h>
#include <libc.h>
#include <fcall.h>

<<enum [[_anon_ (9sys/dirstat.c)]]>>

<<function [[dirstat]]>>
@


\subsection*{[[libc/9sys/dirwstat.c]]}


%-------------------------------------------------------------

<<libc/9sys/dirwstat.c>>=
#include <u.h>
#include <libc.h>
#include <fcall.h>

<<function [[dirwstat]]>>
@


\subsection*{[[libc/9sys/fcallfmt.c]]}


<<function [[dirfmt]]>>=
int
dirfmt(Fmt *fmt)
{
    char buf[160];

    fdirconv(buf, buf+sizeof buf, va_arg(fmt->args, Dir*));
    return fmtstrcpy(fmt, buf);
}
@

<<function [[fdirconv]]>>=
static void
fdirconv(char *buf, char *e, Dir *d)
{
    char tmp[16];

    seprint(buf, e, "'%s' '%s' '%s' '%s' "
        "q " QIDFMT " m %#luo "
        "at %ld mt %ld l %lld "
        "t %d d %d",
            d->name, d->uid, d->gid, d->muid,
            d->qid.path, d->qid.vers, qidtype(tmp, d->qid.type), d->mode,
            d->atime, d->mtime, d->length,
            d->type, d->dev);
}
@

<<constant [[DUMPL]]>>=
/*
 * dump out count (or DUMPL, if count is bigger) bytes from
 * buf to ans, as a string if they are all printable,
 * else as a series of hex bytes
 */
#define DUMPL 64
@

<<function [[dumpsome]]>>=
static uint
dumpsome(char *ans, char *e, char *buf, long count)
{
    int i, printable;
    char *p;

    if(buf == nil){
        seprint(ans, e, "<no data>");
        return strlen(ans);
    }
    printable = 1;
    if(count > DUMPL)
        count = DUMPL;
    for(i=0; i<count && printable; i++)
        if((buf[i]<32 && buf[i] !='\n' && buf[i] !='\t') || (uchar)buf[i]>127)
            printable = 0;
    p = ans;
    *p++ = '\'';
    if(printable){
        if(count > e-p-2)
            count = e-p-2;
        memmove(p, buf, count);
        p += count;
    }else{
        if(2*count > e-p-2)
            count = (e-p-2)/2;
        for(i=0; i<count; i++){
            if(i>0 && i%4==0)
                *p++ = ' ';
            sprint(p, "%2.2ux", (uchar)buf[i]);
            p += 2;
        }
    }
    *p++ = '\'';
    *p = 0;
    return p - ans;
}
@


%-------------------------------------------------------------

<<libc/9sys/fcallfmt.c>>=
#include <u.h>
#include <libc.h>
#include <fcall.h>

static uint dumpsome(char*, char*, char*, long);
static void fdirconv(char*, char*, Dir*);
static char *qidtype(char*, uchar);

<<constant [[QIDFMT]]>>

<<function [[fcallfmt]]>>

<<function [[qidtype]]>>

<<function [[dirfmt]]>>

<<function [[fdirconv]]>>

<<constant [[DUMPL]]>>

<<function [[dumpsome]]>>
@


\subsection*{[[libc/9sys/fork.c]]}



%-------------------------------------------------------------

<<libc/9sys/fork.c>>=
#include <u.h>
#include <libc.h>

<<function [[fork]]>>
@


\subsection*{[[libc/9sys/getenv.c]]}



%-------------------------------------------------------------

<<libc/9sys/getenv.c>>=
#include <u.h>
#include <libc.h>

<<function [[getenv]]>>
@


\subsection*{[[libc/9sys/getnetconninfo.c]]}

<<global [[unknown]]>>=
static char *unknown = "???";
@

<<function [[getendpoint]]>>=
static void
getendpoint(char *dir, char *file, char **sysp, char **servp)
{
    int fd, n;
    char buf[128];
    char *sys, *serv;

    sys = serv = 0;

    snprint(buf, sizeof buf, "%s/%s", dir, file);
    fd = open(buf, OREAD);
    if(fd >= 0){
        n = read(fd, buf, sizeof(buf)-1);
        if(n>0){
            buf[n-1] = 0;
            serv = strchr(buf, '!');
            if(serv){
                *serv++ = 0;
                serv = strdup(serv);
            }
            sys = strdup(buf);
        }
        close(fd);
    }
    if(serv == 0)
        serv = unknown;
    if(sys == 0)
        sys = unknown;
    *servp = serv;
    *sysp = sys;
}
@

<<function [[getnetconninfo]]>>=
NetConnInfo*
getnetconninfo(char *dir, int fd)
{
    NetConnInfo *nci;
    char *cp;
    Dir *d;
    char spec[10];
    char path[128];
    char netname[128], *p;

    /* get a directory address via fd */
    if(dir == nil || *dir == 0){
        if(fd2path(fd, path, sizeof(path)) < 0)
            return nil;
        cp = strrchr(path, '/');
        if(cp == nil)
            return nil;
        *cp = 0;
        dir = path;
    }

    nci = mallocz(sizeof *nci, 1);
    if(nci == nil)
        return nil;

    /* copy connection directory */
    nci->dir = strdup(dir);
    if(nci->dir == nil)
        goto err;

    /* get netroot */
    nci->root = strdup(dir);
    if(nci->root == nil)
        goto err;
    cp = strchr(nci->root+1, '/');
    if(cp == nil)
        goto err;
    *cp = 0;

    /* figure out bind spec */
    d = dirstat(nci->dir);
    if(d != nil){
        sprint(spec, "#%C%d", d->type, d->dev);
        nci->spec = strdup(spec);
    }
    if(nci->spec == nil)
        nci->spec = unknown;
    free(d);

    /* get the two end points */
    getendpoint(nci->dir, "local", &nci->lsys, &nci->lserv);
    if(nci->lsys == nil || nci->lserv == nil)
        goto err;
    getendpoint(nci->dir, "remote", &nci->rsys, &nci->rserv);
    if(nci->rsys == nil || nci->rserv == nil)
        goto err;

    strecpy(netname, netname+sizeof netname, nci->dir);
    if((p = strrchr(netname, '/')) != nil)
        *p = 0;
    if(strncmp(netname, "/net/", 5) == 0)
        memmove(netname, netname+5, strlen(netname+5)+1);
    nci->laddr = smprint("%s!%s!%s", netname, nci->lsys, nci->lserv);
    nci->raddr = smprint("%s!%s!%s", netname, nci->rsys, nci->rserv);
    if(nci->laddr == nil || nci->raddr == nil)
        goto err;
    return nci;
err:
    freenetconninfo(nci);
    return nil;
}
@

<<function [[xfree]]>>=
static void
xfree(char *x)
{
    if(x == nil || x == unknown)
        return;
    free(x);
}
@

<<function [[freenetconninfo]]>>=
void
freenetconninfo(NetConnInfo *nci)
{
    if(nci == nil)
        return;
    xfree(nci->root);
    xfree(nci->dir);
    xfree(nci->spec);
    xfree(nci->lsys);
    xfree(nci->lserv);
    xfree(nci->rsys);
    xfree(nci->rserv);
    xfree(nci->laddr);
    xfree(nci->raddr);
    free(nci);
}
@


%-------------------------------------------------------------

<<libc/9sys/getnetconninfo.c>>=
#include <u.h>
#include <libc.h>

<<global [[unknown]]>>

<<function [[getendpoint]]>>

<<function [[getnetconninfo]]>>

<<function [[xfree]]>>

<<function [[freenetconninfo]]>>
@


\subsection*{[[libc/9sys/getpid.c]]}



%-------------------------------------------------------------

<<libc/9sys/getpid.c>>=
#include    <u.h>
#include    <libc.h>

<<function [[getpid]]>>
@


\subsection*{[[libc/9sys/getppid.c]]}



%-------------------------------------------------------------

<<libc/9sys/getppid.c>>=
#include    <u.h>
#include    <libc.h>

<<function [[getppid]]>>
@


\subsection*{[[libc/9sys/getwd.c]]}


%-------------------------------------------------------------

<<libc/9sys/getwd.c>>=
#include <u.h>
#include <libc.h>

static char *nsgetwd(char*, int);

<<function [[getwd]]>>
@


\subsection*{[[libc/9sys/iounit.c]]}

<<function [[iounit]]>>=
/*
 * Format:
  3 r  M    4 (0000000000457def 11 00)   8192      512 /rc/lib/rcmain
 */

int
iounit(int fd)
{
    int i, cfd;
    char buf[128], *args[10];

    snprint(buf, sizeof buf, "#d/%dctl", fd);
    cfd = open(buf, OREAD);
    if(cfd < 0)
        return 0;
    i = read(cfd, buf, sizeof buf-1);
    close(cfd);
    if(i <= 0)
        return 0;
    buf[i] = '\0';
    if(tokenize(buf, args, nelem(args)) != nelem(args))
        return 0;
    return atoi(args[7]);
}
@


%-------------------------------------------------------------

<<libc/9sys/iounit.c>>=
#include <u.h>
#include <libc.h>

<<function [[iounit]]>>
@


\subsection*{[[libc/9sys/nsec.c]]}

<<global [[order]]>>=
static uvlong order = 0x0001020304050607ULL;
@

<<function [[be2vlong]]>>=
static void
be2vlong(vlong *to, uchar *f)
{
    uchar *t, *o;
    int i;

    t = (uchar*)to;
    o = (uchar*)&order;
    for(i = 0; i < sizeof order; i++)
        t[o[i]] = f[i];
}
@

<<global [[fd]]>>=
static int fd = -1;
@

<<global [[fds]]>>=
static struct {
    int pid;
    int fd;
} fds[64];
@

<<function [[nsec]]>>=
vlong
nsec(void)
{
    uchar b[8];
    vlong t;
    int pid, i, f, tries;

    /*
     * Threaded programs may have multiple procs
     * with different fd tables, so we may need to open
     * /dev/bintime on a per-pid basis
     */

    /* First, look if we've opened it for this particular pid */
    if((pid = _tos->pid) == 0)      /* 9vx bug, perhaps? */
        _tos->pid = pid = getpid();
    do{
        f = -1;
        for(i = 0; i < nelem(fds); i++)
            if(fds[i].pid == pid){
                f = fds[i].fd;
                break;
            }
        tries = 0;
        if(f < 0){
            /* If it's not open for this pid, try the global pid */
            if(fd >= 0)
                f = fd;
            else{
                /* must open */
                if((f = open("/dev/bintime", OREAD|OCEXEC)) < 0)
                    return 0;
                fd = f;
                for(i = 0; i < nelem(fds); i++)
                    if(fds[i].pid == pid || fds[i].pid == 0){
                        fds[i].pid = pid;
                        fds[i].fd = f;
                        break;
                    }
            }
        }
        if(pread(f, b, sizeof b, 0) == sizeof b){
            be2vlong(&t, b);
            return t;
        }
        close(f);
        if(i < nelem(fds))
            fds[i].fd = -1;
    }while(tries++ == 0);   /* retry once */
    USED(tries);
    return 0;
}
@


%-------------------------------------------------------------

<<libc/9sys/nsec.c>>=
#include <u.h>
#include <libc.h>
#include <tos.h>

<<global [[order]]>>

<<function [[be2vlong]]>>

<<global [[fd]]>>
<<global [[fds]]>>

<<function [[nsec]]>>
@


\subsection*{[[libc/9sys/nulldir.c]]}



%-------------------------------------------------------------

<<libc/9sys/nulldir.c>>=
#include <u.h>
#include <libc.h>

<<function [[nulldir]]>>
@


\subsection*{[[libc/9sys/postnote.c]]}



%-------------------------------------------------------------

<<libc/9sys/postnote.c>>=
#include <u.h>
#include <libc.h>

<<function [[postnote]]>>
@


\subsection*{[[libc/9sys/privalloc.c]]}

% used by??

<<global privlock (9sys/privalloc.c)>>=
static Lock privlock;
@

<<global [[privinit]]>>=
static int  privinit;
@

<<global [[privs]]>>=
static void **privs;
@

<<function [[privalloc]]>>=
void **
privalloc(void)
{
    void **p;
    int i;

    lock(&privlock);
    if(!privinit){
        privinit = 1;
        if(_nprivates){
            _privates[0] = 0;
            for(i = 1; i < _nprivates; i++)
                _privates[i] = &_privates[i - 1];
            privs = &_privates[i - 1];
        }
    }
    p = privs;
    if(p != nil){
        privs = *p;
        *p = nil;
    }
    unlock(&privlock);
    return p;
}
@

<<function [[privfree]]>>=
void
privfree(void **p)
{
    lock(&privlock);
    if(p != nil && privinit){
        *p = privs;
        privs = p;
    }
    unlock(&privlock);
}
@


%-------------------------------------------------------------

<<libc/9sys/privalloc.c>>=
#include <u.h>
#include <libc.h>

<<global privlock (9sys/privalloc.c)>>
<<global [[privinit]]>>
<<global [[privs]]>>

extern void **_privates;
extern int  _nprivates;

<<function [[privalloc]]>>

<<function [[privfree]]>>
@


\subsection*{[[libc/9sys/pushssl.c]]}



%-------------------------------------------------------------

<<libc/9sys/pushssl.c>>=
#include <u.h>
#include <libc.h>

<<function [[pushssl]]>>
@


\subsection*{[[libc/9sys/pushtls.c]]}

<<enum [[_anon_ (9sys/pushtls.c)]]>>=
enum {
    TLSFinishedLen = 12,
    HFinished = 20,
};
@

<<function [[finished]]>>=
static int
finished(int hand, int isclient)
{
    int i, n;
    uchar buf[500], buf2[500];

    buf[0] = HFinished;
    buf[1] = TLSFinishedLen>>16;
    buf[2] = TLSFinishedLen>>8;
    buf[3] = TLSFinishedLen;
    n = TLSFinishedLen+4;

    for(i=0; i<2; i++){
        if(i==0)
            memmove(buf+4, "client finished", TLSFinishedLen);
        else
            memmove(buf+4, "server finished", TLSFinishedLen);
        if(isclient == 1-i){
            if(write(hand, buf, n) != n)
                return -1;
        }else{
            if(readn(hand, buf2, n) != n || memcmp(buf,buf2,n) != 0)
                return -1;
        }
    }
    return 1;
}
@


%-------------------------------------------------------------

<<libc/9sys/pushtls.c>>=
#include <u.h>
#include <libc.h>
#include <mp.h>
#include <libsec.h>

<<enum [[_anon_ (9sys/pushtls.c)]]>>

<<function [[finished]]>>


<<function [[pushtls]]>>
@


\subsection*{[[libc/9sys/putenv.c]]}



%-------------------------------------------------------------

<<libc/9sys/putenv.c>>=
#include <u.h>
#include <libc.h>

<<function [[putenv]]>>
@


\subsection*{[[libc/9sys/qlock.c]]}

<<global [[ql]]>>=
static struct {
    QLp *p;
    QLp x[1024];
} ql = {
    ql.x
};
@

<<enum [[_anon_ (9sys/qlock.c)]]>>=
enum
{
    Queuing,
    QueuingR,
    QueuingW,
    Sleeping,
};
@

<<global [[_rendezvousp]]>>=
static void*    (*_rendezvousp)(void*, void*) = rendezvous;
@

<<function [[_qlockinit]]>>=
/* this gets called by the thread library ONLY to get us to use its rendezvous */
void
_qlockinit(void* (*r)(void*, void*))
{
    _rendezvousp = r;
}
@

<<function [[getqlp]]>>=
/* find a free shared memory location to queue ourselves in */
static QLp*
getqlp(void)
{
    QLp *p, *op;

    op = ql.p;
    for(p = op+1; ; p++){
        if(p == &ql.x[nelem(ql.x)])
            p = ql.x;
        if(p == op)
            abort();
        if(_tas(&(p->inuse)) == 0){
            ql.p = p;
            p->next = nil;
            break;
        }
    }
    return p;
}
@




%-------------------------------------------------------------

<<libc/9sys/qlock.c>>=
#include <u.h>
#include <libc.h>

<<global [[ql]]>>

<<enum [[_anon_ (9sys/qlock.c)]]>>

<<global [[_rendezvousp]]>>

<<function [[_qlockinit]]>>

<<function [[getqlp]]>>

<<function [[qlock]]>>

<<function [[qunlock]]>>

<<function [[canqlock]]>>

<<function [[rlock]]>>

<<function [[canrlock]]>>

<<function [[runlock]]>>

<<function [[wlock]]>>

<<function [[canwlock]]>>

<<function [[wunlock]]>>

<<function [[rsleep]]>>

<<function [[rwakeup]]>>

<<function [[rwakeupall]]>>

@


\subsection*{[[libc/9sys/read.c]]}



%-------------------------------------------------------------

<<libc/9sys/read.c>>=
#include    <u.h>
#include    <libc.h>

<<function [[read]]>>
@


\subsection*{[[libc/9sys/read9pmsg.c]]}



%-------------------------------------------------------------

<<libc/9sys/read9pmsg.c>>=
#include <u.h>
#include <libc.h>
#include <fcall.h>

<<function [[read9pmsg]]>>
@


\subsection*{[[libc/9sys/readv.c]]}

<<function [[ioreadv]]>>=
static
long
ioreadv(int fd, IOchunk *io, int nio, vlong offset)
{
    int i;
    long m, n, tot;
    char *buf, *p;

    tot = 0;
    for(i=0; i<nio; i++)
        tot += io[i].len;
    buf = malloc(tot);
    if(buf == nil)
        return -1;

    tot = pread(fd, buf, tot, offset);

    p = buf;
    n = tot;
    for(i=0; i<nio; i++){
        if(n <= 0)
            break;
        m = io->len;
        if(m > n)
            m = n;
        memmove(io->addr, p, m);
        n -= m;
        p += m;
        io++;
    }

    free(buf);
    return tot;
}
@

<<function [[readv]]>>=
long
readv(int fd, IOchunk *io, int nio)
{
    return ioreadv(fd, io, nio, -1LL);
}
@

<<function [[preadv]]>>=
long
preadv(int fd, IOchunk *io, int nio, vlong off)
{
    return ioreadv(fd, io, nio, off);
}
@


%-------------------------------------------------------------

<<libc/9sys/readv.c>>=
#include <u.h>
#include <libc.h>

<<function [[ioreadv]]>>

<<function [[readv]]>>

<<function [[preadv]]>>
@


\subsection*{[[libc/9sys/rerrstr.c]]}



%-------------------------------------------------------------

<<libc/9sys/rerrstr.c>>=
#include <u.h>
#include <libc.h>

<<function [[rerrstr]]>>
@


\subsection*{[[libc/9sys/sbrk.c]]}


%-------------------------------------------------------------

<<libc/9sys/sbrk.c>>=
#include <u.h>
#include <libc.h>

extern  char    end[];

<<global [[bloc]]>>

// the syscall
extern  int brk(void*);

<<enum [[_anon_ (9sys/sbrk.c)]]>>

<<function [[sbrk]]>>
@


\subsection*{[[libc/9sys/setnetmtpt.c]]}

<<function [[setnetmtpt]]>>=
void
setnetmtpt(char *net, int n, char *x)
{
    if(x == nil)
        x = "/net";

    if(*x == '/'){
        strncpy(net, x, n);
        net[n-1] = 0;
    } else {
        snprint(net, n, "/net%s", x);
    }
}
@


%-------------------------------------------------------------

<<libc/9sys/setnetmtpt.c>>=
#include <u.h>
#include <libc.h>

<<function [[setnetmtpt]]>>
@


\subsection*{[[libc/9sys/sysfatal.c]]}



%-------------------------------------------------------------

<<libc/9sys/sysfatal.c>>=
#include <u.h>
#include <libc.h>


<<function [[_sysfatalimpl]]>>

<<global [[_sysfatal]]>>

<<function [[sysfatal]]>>
@


\subsection*{[[libc/9sys/syslog.c]]}




%-------------------------------------------------------------

<<libc/9sys/syslog.c>>=
#include <u.h>
#include <libc.h>

<<global [[sl]]>>

<<function [[_syslogopen]]>>

<<function [[eqdirdev]]>>

<<function [[syslog]]>>
@


\subsection*{[[libc/9sys/sysname.c]]}

<<function [[sysname]]>>=
char*
sysname(void)
{
    int f, n;
    static char b[128];

    if(b[0])
        return b;

    f = open("#c/sysname", 0);
    if(f >= 0) {
        n = read(f, b, sizeof(b)-1);
        if(n > 0)
            b[n] = 0;
        close(f);
    }
    return b;
}
@


%-------------------------------------------------------------

<<libc/9sys/sysname.c>>=
#include    <u.h>
#include    <libc.h>

<<function [[sysname]]>>
@


\subsection*{[[libc/9sys/time.c]]}




%-------------------------------------------------------------

<<libc/9sys/time.c>>=
#include <u.h>
#include <libc.h>


<<function [[oldtime]]>>

<<function [[time]]>>
@


\subsection*{[[libc/9sys/times.c]]}

<<function skip (9sys/times.c)>>=
static
char*
skip(char *p)
{

    while(*p == ' ')
        p++;
    while(*p != ' ' && *p != 0)
        p++;
    return p;
}
@

<<function [[times]]>>=
/*
 *  after a fork with fd's copied, both fd's are pointing to
 *  the same Chan structure.  Since the offset is kept in the Chan
 *  structure, the seek's and read's in the two processes can be
 *  are competing moving the offset around.  Hence the unusual loop
 *  in the middle of this routine.
 */
long
times(long *t)
{
    char b[200], *p;
    static int f = -1;
    int i, retries;
    ulong r;

    memset(b, 0, sizeof(b));
    for(retries = 0; retries < 100; retries++){
        if(f < 0)
            f = open("/dev/cputime", OREAD|OCEXEC);
        if(f < 0)
            break;
        if(seek(f, 0, 0) < 0 || (i = read(f, b, sizeof(b))) < 0){
            close(f);
            f = -1;
        } else {
            if(i != 0)
                break;
        }
    }
    p = b;
    if(t)
        t[0] = atol(p);
    p = skip(p);
    if(t)
        t[1] = atol(p);
    p = skip(p);
    r = atol(p);
    if(t){
        p = skip(p);
        t[2] = atol(p);
        p = skip(p);
        t[3] = atol(p);
    }
    return r;
}
@


%-------------------------------------------------------------

<<libc/9sys/times.c>>=
#include <u.h>
#include <libc.h>

<<function skip (9sys/times.c)>>

<<function [[times]]>>
@


\subsection*{[[libc/9sys/tm2sec.c]]}

<<constant [[TZSIZE]](9sys/tm2sec.c)>>=
#define TZSIZE  150
@

<<global [[timezone]](9sys/tm2sec.c)>>=
static
struct
{
    char    stname[4];
    char    dlname[4];
    long    stdiff;
    long    dldiff;
    long    dlpairs[TZSIZE];
} timezone;
@

<<constant [[SEC2MIN]]>>=
#define SEC2MIN 60L
@

<<constant [[SEC2HOUR]]>>=
#define SEC2HOUR (60L*SEC2MIN)
@

<<constant [[SEC2DAY]]>>=
#define SEC2DAY (24L*SEC2HOUR)
@

<<global [[dmsize]](9sys/tm2sec.c)>>=
/*
 *  days per month plus days/year
 */
static  int dmsize[] =
{
    365, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
};
@

<<global [[ldmsize]]>>=
static  int ldmsize[] =
{
    366, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
};
@

<<function [[yrsize]]>>=
/*
 *  return the days/month for the given year
 */
static int *
yrsize(int y)
{
    if((y%4) == 0 && ((y%100) != 0 || (y%400) == 0))
        return ldmsize;
    else
        return dmsize;
}
@


<<function [[readtimezone]](9sys/tm2sec.c)>>=
static
void
readtimezone(void)
{
    char buf[TZSIZE*11+30], *p;
    int i;

    memset(buf, 0, sizeof(buf));
    i = open("/env/timezone", 0);
    if(i < 0)
        goto error;
    if(read(i, buf, sizeof(buf)) >= sizeof(buf))
        goto error;
    close(i);
    p = buf;
    if(rd_name(&p, timezone.stname))
        goto error;
    if(rd_long(&p, &timezone.stdiff))
        goto error;
    if(rd_name(&p, timezone.dlname))
        goto error;
    if(rd_long(&p, &timezone.dldiff))
        goto error;
    for(i=0; i<TZSIZE; i++) {
        if(rd_long(&p, &timezone.dlpairs[i]))
            goto error;
        if(timezone.dlpairs[i] == 0)
            return;
    }

error:
    timezone.stdiff = 0;
    strcpy(timezone.stname, "GMT");
    timezone.dlpairs[0] = 0;
}
@

<<function [[rd_name]](9sys/tm2sec.c)>>=
static int
rd_name(char **f, char *p)
{
    int c, i;

    for(;;) {
        c = *(*f)++;
        if(c != ' ' && c != '\n')
            break;
    }
    for(i=0; i<3; i++) {
        if(c == ' ' || c == '\n')
            return 1;
        *p++ = c;
        c = *(*f)++;
    }
    if(c != ' ' && c != '\n')
        return 1;
    *p = 0;
    return 0;
}
@

<<function [[rd_long]](9sys/tm2sec.c)>>=
static int
rd_long(char **f, long *p)
{
    int c, s;
    long l;

    s = 0;
    for(;;) {
        c = *(*f)++;
        if(c == '-') {
            s++;
            continue;
        }
        if(c != ' ' && c != '\n')
            break;
    }
    if(c == 0) {
        *p = 0;
        return 0;
    }
    l = 0;
    for(;;) {
        if(c == ' ' || c == '\n')
            break;
        if(c < '0' || c > '9')
            return 1;
        l = l*10 + c-'0';
        c = *(*f)++;
    }
    if(s)
        l = -l;
    *p = l;
    return 0;
}
@


%-------------------------------------------------------------

<<libc/9sys/tm2sec.c>>=
#include <u.h>
#include <libc.h>

<<constant [[TZSIZE]](9sys/tm2sec.c)>>
static  void    readtimezone(void);
static  int rd_name(char**, char*);
static  int rd_long(char**, long*);
<<global [[timezone]](9sys/tm2sec.c)>>

<<constant [[SEC2MIN]]>>
<<constant [[SEC2HOUR]]>>
<<constant [[SEC2DAY]]>>

<<global [[dmsize]](9sys/tm2sec.c)>>
<<global [[ldmsize]]>>

<<function [[yrsize]]>>

<<function [[tm2sec]]>>

<<function [[readtimezone]](9sys/tm2sec.c)>>

<<function [[rd_name]](9sys/tm2sec.c)>>

<<function [[rd_long]](9sys/tm2sec.c)>>
@


\subsection*{[[libc/9sys/truerand.c]]}


%-------------------------------------------------------------

<<libc/9sys/truerand.c>>=
#include <u.h>
#include <libc.h>

<<function [[truerand]]>>
@


\subsection*{[[libc/9sys/wait.c]]}


%-------------------------------------------------------------

<<libc/9sys/wait.c>>=
#include <u.h>
#include <libc.h>
#include <fcall.h>

<<function [[wait]]>>

@


\subsection*{[[libc/9sys/waitpid.c]]}


%-------------------------------------------------------------

<<libc/9sys/waitpid.c>>=
#include <u.h>
#include <libc.h>
#include <fcall.h>

<<function [[waitpid]]>>

@


\subsection*{[[libc/9sys/werrstr.c]]}



%-------------------------------------------------------------

<<libc/9sys/werrstr.c>>=
#include <u.h>
#include <libc.h>

<<function [[werrstr]]>>
@


\subsection*{[[libc/9sys/write.c]]}



%-------------------------------------------------------------

<<libc/9sys/write.c>>=
#include    <u.h>
#include    <libc.h>

<<function [[write]]>>
@


\subsection*{[[libc/9sys/writev.c]]}

<<function [[iowritev]]>>=
static
long
iowritev(int fd, IOchunk *io, int nio, vlong offset)
{
    int i;
    long tot;
    char *buf, *p;

    tot = 0;
    for(i=0; i<nio; i++)
        tot += io[i].len;
    buf = malloc(tot);
    if(buf == nil)
        return -1;

    p = buf;
    for(i=0; i<nio; i++){
        memmove(p, io->addr, io->len);
        p += io->len;
        io++;
    }

    tot = pwrite(fd, buf, tot, offset);

    free(buf);
    return tot;
}
@

<<function [[writev]]>>=
long
writev(int fd, IOchunk *io, int nio)
{
    return iowritev(fd, io, nio, -1LL);
}
@

<<function [[pwritev]]>>=
long
pwritev(int fd, IOchunk *io, int nio, vlong off)
{
    return iowritev(fd, io, nio, off);
}
@


%-------------------------------------------------------------

<<libc/9sys/writev.c>>=
#include <u.h>
#include <libc.h>

<<function [[iowritev]]>>

<<function [[writev]]>>

<<function [[pwritev]]>>
@


\section{[[lib_core/libc/fmt/]]}

\subsection*{[[libc/fmt/fmtdef.h]]}

<<libc/fmt/fmtdef.h>>=
/*
 * dofmt -- format to a buffer
 * the number of characters formatted is returned,
 * or -1 if there was an error.
 * if the buffer is ever filled, flush is called.
 * it should reset the buffer and return whether formatting should continue.
 */

typedef int (*Fmts)(Fmt*);

typedef struct Quoteinfo Quoteinfo;
struct Quoteinfo
{
    int quoted;     /* if set, string must be quoted */
    int nrunesin;   /* number of input runes that can be accepted */
    int nbytesin;   /* number of input bytes that can be accepted */
    int nrunesout;  /* number of runes that will be generated */
    int nbytesout;  /* number of bytes that will be generated */
};

void    *_fmtflush(Fmt*, void*, int);
void    *_fmtdispatch(Fmt*, void*, int);
int _floatfmt(Fmt*, double);
int _fmtpad(Fmt*, int);
int _rfmtpad(Fmt*, int);
int _fmtFdFlush(Fmt*);

int _efgfmt(Fmt*);
int _charfmt(Fmt*);
int _countfmt(Fmt*);
int _flagfmt(Fmt*);
int _percentfmt(Fmt*);
int _ifmt(Fmt*);
int _runefmt(Fmt*);
int _runesfmt(Fmt*);
int _strfmt(Fmt*);
int _badfmt(Fmt*);
int _fmtcpy(Fmt*, void*, int, int);
int _fmtrcpy(Fmt*, void*, int n);

void    _fmtlock(void);
void    _fmtunlock(void);

#define FMTCHAR(f, t, s, c)\
    do{\
    if(t + 1 > (char*)s){\
        t = _fmtflush(f, t, 1);\
        if(t != nil)\
            s = f->stop;\
        else\
            return -1;\
    }\
    *t++ = c;\
    }while(0)

#define FMTRCHAR(f, t, s, c)\
    do{\
    if(t + 1 > (Rune*)s){\
        t = _fmtflush(f, t, sizeof(Rune));\
        if(t != nil)\
            s = f->stop;\
        else\
            return -1;\
    }\
    *t++ = c;\
    }while(0)

#define FMTRUNE(f, t, s, r)\
    do{\
    Rune _rune;\
    int _runelen;\
    if(t + UTFmax > (char*)s && t + (_runelen = runelen(r)) > (char*)s){\
        t = _fmtflush(f, t, _runelen);\
        if(t != nil)\
            s = f->stop;\
        else\
            return -1;\
    }\
    if(r < Runeself)\
        *t++ = r;\
    else{\
        _rune = r;\
        t += runetochar(t, &_rune);\
    }\
    }while(0)
@


\subsection*{[[libc/fmt/dofmt.c]]}

<<function [[dofmt]]>>=
/* format the output into f->to and return the number of characters fmted  */
int
dofmt(Fmt *f, char *fmt)
{
    Rune rune, *rt, *rs;
    int r;
    char *t, *s;
    int n, nfmt;

    nfmt = f->nfmt;
    for(;;){
        if(f->runes){
            rt = f->to;
            rs = f->stop;
            while((r = *(uchar*)fmt) && r != '%'){
                if(r < Runeself)
                    fmt++;
                else{
                    fmt += chartorune(&rune, fmt);
                    r = rune;
                }
                FMTRCHAR(f, rt, rs, r);
            }
            fmt++;
            f->nfmt += rt - (Rune *)f->to;
            f->to = rt;
            if(!r)
                return f->nfmt - nfmt;
            f->stop = rs;
        }else{
            t = f->to;
            s = f->stop;
            while((r = *(uchar*)fmt) && r != '%'){
                if(r < Runeself){
                    FMTCHAR(f, t, s, r);
                    fmt++;
                }else{
                    n = chartorune(&rune, fmt);
                    if(t + n > s){
                        t = _fmtflush(f, t, n);
                        if(t != nil)
                            s = f->stop;
                        else
                            return -1;
                    }
                    while(n--)
                        *t++ = *fmt++;
                }
            }
            fmt++;
            f->nfmt += t - (char *)f->to;
            f->to = t;
            if(!r)
                return f->nfmt - nfmt;
            f->stop = s;
        }

        fmt = _fmtdispatch(f, fmt, 0);
        if(fmt == nil)
            return -1;
    }
}
@

<<function [[_fmtflush]]>>=
void *
_fmtflush(Fmt *f, void *t, int len)
{
    if(f->runes)
        f->nfmt += (Rune*)t - (Rune*)f->to;
    else
        f->nfmt += (char*)t - (char *)f->to;
    f->to = t;
    if(f->flush == 0 || (*f->flush)(f) == 0 || (char*)f->to + len > (char*)f->stop){
        f->stop = f->to;
        return nil;
    }
    return f->to;
}
@

<<function [[_fmtpad]]>>=
/*
 * put a formatted block of memory sz bytes long of n runes into the output buffer,
 * left/right justified in a field of at least f->width charactes
 */
int
_fmtpad(Fmt *f, int n)
{
    char *t, *s;
    int i;

    t = f->to;
    s = f->stop;
    for(i = 0; i < n; i++)
        FMTCHAR(f, t, s, ' ');
    f->nfmt += t - (char *)f->to;
    f->to = t;
    return 0;
}
@

<<function [[_rfmtpad]]>>=
int
_rfmtpad(Fmt *f, int n)
{
    Rune *t, *s;
    int i;

    t = f->to;
    s = f->stop;
    for(i = 0; i < n; i++)
        FMTRCHAR(f, t, s, ' ');
    f->nfmt += t - (Rune *)f->to;
    f->to = t;
    return 0;
}
@

<<function [[_fmtcpy]]>>=
int
_fmtcpy(Fmt *f, void *vm, int n, int sz)
{
    Rune *rt, *rs, r;
    char *t, *s, *m, *me;
    ulong fl;
    int nc, w;

    m = vm;
    me = m + sz;
    w = f->width;
    fl = f->flags;
    if((fl & FmtPrec) && n > f->prec)
        n = f->prec;
    if(f->runes){
        if(!(fl & FmtLeft) && _rfmtpad(f, w - n) < 0)
            return -1;
        rt = f->to;
        rs = f->stop;
        for(nc = n; nc > 0; nc--){
            r = *(uchar*)m;
            if(r < Runeself)
                m++;
            else if((me - m) >= UTFmax || fullrune(m, me-m))
                m += chartorune(&r, m);
            else
                break;
            FMTRCHAR(f, rt, rs, r);
        }
        f->nfmt += rt - (Rune *)f->to;
        f->to = rt;
        if(fl & FmtLeft && _rfmtpad(f, w - n) < 0)
            return -1;
    }else{
        if(!(fl & FmtLeft) && _fmtpad(f, w - n) < 0)
            return -1;
        t = f->to;
        s = f->stop;
        for(nc = n; nc > 0; nc--){
            r = *(uchar*)m;
            if(r < Runeself)
                m++;
            else if((me - m) >= UTFmax || fullrune(m, me-m))
                m += chartorune(&r, m);
            else
                break;
            FMTRUNE(f, t, s, r);
        }
        f->nfmt += t - (char *)f->to;
        f->to = t;
        if(fl & FmtLeft && _fmtpad(f, w - n) < 0)
            return -1;
    }
    return 0;
}
@

<<function [[_fmtrcpy]]>>=
int
_fmtrcpy(Fmt *f, void *vm, int n)
{
    Rune r, *m, *me, *rt, *rs;
    char *t, *s;
    ulong fl;
    int w;

    m = vm;
    w = f->width;
    fl = f->flags;
    if((fl & FmtPrec) && n > f->prec)
        n = f->prec;
    if(f->runes){
        if(!(fl & FmtLeft) && _rfmtpad(f, w - n) < 0)
            return -1;
        rt = f->to;
        rs = f->stop;
        for(me = m + n; m < me; m++)
            FMTRCHAR(f, rt, rs, *m);
        f->nfmt += rt - (Rune *)f->to;
        f->to = rt;
        if(fl & FmtLeft && _rfmtpad(f, w - n) < 0)
            return -1;
    }else{
        if(!(fl & FmtLeft) && _fmtpad(f, w - n) < 0)
            return -1;
        t = f->to;
        s = f->stop;
        for(me = m + n; m < me; m++){
            r = *m;
            FMTRUNE(f, t, s, r);
        }
        f->nfmt += t - (char *)f->to;
        f->to = t;
        if(fl & FmtLeft && _fmtpad(f, w - n) < 0)
            return -1;
    }
    return 0;
}
@

<<function [[_charfmt]]>>=
/* fmt out one character */
int
_charfmt(Fmt *f)
{
    char x[1];

    x[0] = va_arg(f->args, int);
    f->prec = 1;
    return _fmtcpy(f, x, 1, 1);
}
@

<<function [[_runefmt]]>>=
/* fmt out one rune */
int
_runefmt(Fmt *f)
{
    Rune x[1];

    x[0] = va_arg(f->args, int);
    return _fmtrcpy(f, x, 1);
}
@

<<function [[fmtstrcpy]]>>=
/* public helper routine: fmt out a null terminated string already in hand */
int
fmtstrcpy(Fmt *f, char *s)
{
    int i, j;
    Rune r;

    if(!s)
        return _fmtcpy(f, "<nil>", 5, 5);
    /* if precision is specified, make sure we don't wander off the end */
    if(f->flags & FmtPrec){
        i = 0;
        for(j=0; j<f->prec && s[i]; j++)
            i += chartorune(&r, s+i);
        return _fmtcpy(f, s, j, i);
    }
    return _fmtcpy(f, s, utflen(s), strlen(s));
}
@

<<function [[_strfmt]]>>=
/* fmt out a null terminated utf string */
int
_strfmt(Fmt *f)
{
    char *s;

    s = va_arg(f->args, char *);
    return fmtstrcpy(f, s);
}
@

<<function [[fmtrunestrcpy]]>>=
/* public helper routine: fmt out a null terminated rune string already in hand */
int
fmtrunestrcpy(Fmt *f, Rune *s)
{
    Rune *e;
    int n, p;

    if(!s)
        return _fmtcpy(f, "<nil>", 5, 5);
    /* if precision is specified, make sure we don't wander off the end */
    if(f->flags & FmtPrec){
        p = f->prec;
        for(n = 0; n < p; n++)
            if(s[n] == 0)
                break;
    }else{
        for(e = s; *e; e++)
            ;
        n = e - s;
    }
    return _fmtrcpy(f, s, n);
}
@

<<function [[_runesfmt]]>>=
/* fmt out a null terminated rune string */
int
_runesfmt(Fmt *f)
{
    Rune *s;

    s = va_arg(f->args, Rune *);
    return fmtrunestrcpy(f, s);
}
@

<<function [[_percentfmt]]>>=
/* fmt a % */
int
_percentfmt(Fmt *f)
{
    Rune x[1];

    x[0] = f->r;
    f->prec = 1;
    return _fmtrcpy(f, x, 1);
}
@

<<enum [[_anon_ (fmt/dofmt.c)]]>>=
enum {
    /* %,#llb could emit a sign, "0b" and 64 digits with 21 commas */
    Maxintwidth = 1 + 2 + 64 + 64/3,
};
@

<<function [[_ifmt]]>>=
/* fmt an integer */
int
_ifmt(Fmt *f)
{
    char buf[Maxintwidth + 1], *p, *conv;
    uvlong vu;
    ulong u;
    uintptr pu;
    int neg, base, i, n, fl, w, isv;

    neg = 0;
    fl = f->flags;
    isv = 0;
    vu = 0;
    u = 0;
    if(f->r == 'p'){
        pu = va_arg(f->args, uintptr);
        if(sizeof(uintptr) == sizeof(uvlong)){
            vu = pu;
            isv = 1;
        }else
            u = pu;
        f->r = 'x';
        fl |= FmtUnsigned;
    }else if(fl & FmtVLong){
        isv = 1;
        if(fl & FmtUnsigned)
            vu = va_arg(f->args, uvlong);
        else
            vu = va_arg(f->args, vlong);
    }else if(fl & FmtLong){
        if(fl & FmtUnsigned)
            u = va_arg(f->args, ulong);
        else
            u = va_arg(f->args, long);
    }else if(fl & FmtByte){
        if(fl & FmtUnsigned)
            u = (uchar)va_arg(f->args, int);
        else
            u = (char)va_arg(f->args, int);
    }else if(fl & FmtShort){
        if(fl & FmtUnsigned)
            u = (ushort)va_arg(f->args, int);
        else
            u = (short)va_arg(f->args, int);
    }else{
        if(fl & FmtUnsigned)
            u = va_arg(f->args, uint);
        else
            u = va_arg(f->args, int);
    }
    conv = "0123456789abcdef";
    switch(f->r){
    case 'd':
        base = 10;
        break;
    case 'x':
        base = 16;
        break;
    case 'X':
        base = 16;
        conv = "0123456789ABCDEF";
        break;
    case 'b':
        base = 2;
        break;
    case 'o':
        base = 8;
        break;
    default:
        return -1;
    }
    if(!(fl & FmtUnsigned)){
        if(isv && (vlong)vu < 0){
            vu = -(vlong)vu;
            neg = 1;
        }else if(!isv && (long)u < 0){
            u = -(long)u;
            neg = 1;
        }
    }
    p = buf + sizeof buf - 1;
    n = 0;
    if(isv){
        while(vu){
            i = vu % base;
            vu /= base;
            if((fl & FmtComma) && n % 4 == 3){
                *p-- = ',';
                n++;
            }
            *p-- = conv[i];
            n++;
        }
    }else{
        while(u){
            i = u % base;
            u /= base;
            if((fl & FmtComma) && n % 4 == 3){
                *p-- = ',';
                n++;
            }
            *p-- = conv[i];
            n++;
        }
    }
    if(n == 0){
        *p-- = '0';
        n = 1;
    }
    for(w = f->prec; n < w && p > buf+3; n++)
        *p-- = '0';
    if(neg || (fl & (FmtSign|FmtSpace)))
        n++;
    if(fl & FmtSharp){
        if(base == 16)
            n += 2;
        else if(base == 8){
            if(p[1] == '0')
                fl &= ~FmtSharp;
            else
                n++;
        }
    }
    if((fl & FmtZero) && !(fl & (FmtLeft|FmtPrec))){
        for(w = f->width; n < w && p > buf+3; n++)
            *p-- = '0';
        f->width = 0;
    }
    if(fl & FmtSharp){
        if(base == 16)
            *p-- = f->r;
        if(base == 16 || base == 8)
            *p-- = '0';
    }
    if(neg)
        *p-- = '-';
    else if(fl & FmtSign)
        *p-- = '+';
    else if(fl & FmtSpace)
        *p-- = ' ';
    f->flags &= ~FmtPrec;
    return _fmtcpy(f, p + 1, n, n);
}
@

<<function [[_countfmt]]>>=
int
_countfmt(Fmt *f)
{
    void *p;
    ulong fl;

    fl = f->flags;
    p = va_arg(f->args, void*);
    if(fl & FmtVLong){
        *(vlong*)p = f->nfmt;
    }else if(fl & FmtLong){
        *(long*)p = f->nfmt;
    }else if(fl & FmtByte){
        *(char*)p = f->nfmt;
    }else if(fl & FmtShort){
        *(short*)p = f->nfmt;
    }else{
        *(int*)p = f->nfmt;
    }
    return 0;
}
@

<<function [[_flagfmt]]>>=
int
_flagfmt(Fmt *f)
{
    switch(f->r){
    case ',':
        f->flags |= FmtComma;
        break;
    case '-':
        f->flags |= FmtLeft;
        break;
    case '+':
        f->flags |= FmtSign;
        break;
    case '#':
        f->flags |= FmtSharp;
        break;
    case ' ':
        f->flags |= FmtSpace;
        break;
    case 'u':
        f->flags |= FmtUnsigned;
        break;
    case 'h':
        if(f->flags & FmtShort)
            f->flags |= FmtByte;
        f->flags |= FmtShort;
        break;
    case 'l':
        if(f->flags & FmtLong)
            f->flags |= FmtVLong;
        f->flags |= FmtLong;
        break;
    }
    return 1;
}
@

<<function [[_badfmt]]>>=
/* default error format */
int
_badfmt(Fmt *f)
{
    Rune x[3];

    x[0] = '%';
    x[1] = f->r;
    x[2] = '%';
    f->prec = 3;
    _fmtrcpy(f, x, 3);
    return 0;
}
@


%-------------------------------------------------------------

<<libc/fmt/dofmt.c>>=
#include <u.h>
#include <libc.h>
#include "fmtdef.h"

<<function [[dofmt]]>>

<<function [[_fmtflush]]>>

<<function [[_fmtpad]]>>

<<function [[_rfmtpad]]>>

<<function [[_fmtcpy]]>>

<<function [[_fmtrcpy]]>>

<<function [[_charfmt]]>>

<<function [[_runefmt]]>>

<<function [[fmtstrcpy]]>>

<<function [[_strfmt]]>>

<<function [[fmtrunestrcpy]]>>

<<function [[_runesfmt]]>>

<<function [[_percentfmt]]>>

<<enum [[_anon_ (fmt/dofmt.c)]]>>

<<function [[_ifmt]]>>

<<function [[_countfmt]]>>

<<function [[_flagfmt]]>>

<<function [[_badfmt]]>>
@


\subsection*{[[libc/fmt/dorfmt.c]]}

<<function [[dorfmt]]>>=
/* format the output into f->to and return the number of characters fmted  */

int
dorfmt(Fmt *f, Rune *fmt)
{
    Rune *rt, *rs;
    int r;
    char *t, *s;
    int nfmt;

    nfmt = f->nfmt;
    for(;;){
        if(f->runes){
            rt = f->to;
            rs = f->stop;
            while((r = *fmt++) && r != '%'){
                FMTRCHAR(f, rt, rs, r);
            }
            f->nfmt += rt - (Rune *)f->to;
            f->to = rt;
            if(!r)
                return f->nfmt - nfmt;
            f->stop = rs;
        }else{
            t = f->to;
            s = f->stop;
            while((r = *fmt++) && r != '%'){
                FMTRUNE(f, t, f->stop, r);
            }
            f->nfmt += t - (char *)f->to;
            f->to = t;
            if(!r)
                return f->nfmt - nfmt;
            f->stop = s;
        }

        fmt = _fmtdispatch(f, fmt, 1);
        if(fmt == nil)
            return -1;
    }
}
@


%-------------------------------------------------------------

<<libc/fmt/dorfmt.c>>=
#include <u.h>
#include <libc.h>
#include "fmtdef.h"

<<function [[dorfmt]]>>
@


\subsection*{[[libc/fmt/errfmt.c]]}

<<function [[errfmt]]>>=
int
errfmt(Fmt *f)
{
    char buf[ERRMAX];

    rerrstr(buf, sizeof buf);
    return _fmtcpy(f, buf, utflen(buf), strlen(buf));
}
@


%-------------------------------------------------------------

<<libc/fmt/errfmt.c>>=
#include <u.h>
#include <libc.h>
#include "fmtdef.h"

<<function [[errfmt]]>>
@


\subsection*{[[libc/fmt/fltfmt.c]]}

<<enum [[_anon_ (fmt/fltfmt.c)]]>>=
enum
{
    FDIGIT  = 30,
    FDEFLT  = 6,
    NSIGNIF = 17,
    NEXP10  = 308,
};
@

<<function [[xadd]]>>=
static int
xadd(char *a, int n, int v)
{
    char *b;
    int c;

    if(n < 0 || n >= NSIGNIF)
        return 0;
    for(b = a+n; b >= a; b--) {
        c = *b + v;
        if(c <= '9') {
            *b = c;
            return 0;
        }
        *b = '0';
        v = 1;
    }
    *a = '1';   // overflow adding
    return 1;
}
@

<<function [[xsub]]>>=
static int
xsub(char *a, int n, int v)
{
    char *b;
    int c;

    for(b = a+n; b >= a; b--) {
        c = *b - v;
        if(c >= '0') {
            *b = c;
            return 0;
        }
        *b = '9';
        v = 1;
    }
    *a = '9';   // underflow subtracting
    return 1;
}
@

<<function [[xdtoa]]>>=
static void
xdtoa(Fmt *fmt, char *s2, double f)
{
    char s1[NSIGNIF+10];
    double g, h;
    int e, d, i, n;
    int c1, c2, c3, c4, ucase, sign, chr, prec;

    prec = FDEFLT;
    if(fmt->flags & FmtPrec)
        prec = fmt->prec;
    if(prec > FDIGIT)
        prec = FDIGIT;
    if(isNaN(f)) {
        strcpy(s2, "NaN");
        return;
    }
    if(isInf(f, 1)) {
        strcpy(s2, "+Inf");
        return;
    }
    if(isInf(f, -1)) {
        strcpy(s2, "-Inf");
        return;
    }
    sign = 0;
    if(f < 0) {
        f = -f;
        sign++;
    }
    ucase = 0;
    chr = fmt->r;
    if(isupper(chr)) {
        ucase = 1;
        chr = tolower(chr);
    }

    e = 0;
    g = f;
    if(g != 0) {
        frexp(f, &e);
        e = e * .301029995664;
        if(e >= -150 && e <= +150) {
            d = 0;
            h = f;
        } else {
            d = e/2;
            h = f * pow10(-d);
        }
        g = h * pow10(d-e);
        while(g < 1) {
            e--;
            g = h * pow10(d-e);
        }
        while(g >= 10) {
            e++;
            g = h * pow10(d-e);
        }
    }

    /*
     * convert NSIGNIF digits and convert
     * back to get accuracy.
     */
    for(i=0; i<NSIGNIF; i++) {
        d = g;
        s1[i] = d + '0';
        g = (g - d) * 10;
    }
    s1[i] = 0;

    /*
     * try decimal rounding to eliminate 9s
     */
    c2 = prec + 1;
    if(chr == 'f')
        c2 += e;
    if(c2 >= NSIGNIF-2) {
        strcpy(s2, s1);
        d = e;
        s1[NSIGNIF-2] = '0';
        s1[NSIGNIF-1] = '0';
        sprint(s1+NSIGNIF, "e%d", e-NSIGNIF+1);
        g = strtod(s1, nil);
        if(g == f)
            goto found;
        if(xadd(s1, NSIGNIF-3, 1)) {
            e++;
            sprint(s1+NSIGNIF, "e%d", e-NSIGNIF+1);
        }
        g = strtod(s1, nil);
        if(g == f)
            goto found;
        strcpy(s1, s2);
        e = d;
    }

    /*
     * convert back so s1 gets exact answer
     */
    for(;;) {
        sprint(s1+NSIGNIF, "e%d", e-NSIGNIF+1);
        g = strtod(s1, nil);
        if(f > g) {
            if(xadd(s1, NSIGNIF-1, 1))
                e--;
            continue;
        }
        if(f < g) {
            if(xsub(s1, NSIGNIF-1, 1))
                e++;
            continue;
        }
        break;
    }

found:
    /*
     * sign
     */
    d = 0;
    i = 0;
    if(sign)
        s2[d++] = '-';
    else if(fmt->flags & FmtSign)
        s2[d++] = '+';
    else if(fmt->flags & FmtSpace)
        s2[d++] = ' ';

    /*
     * copy into final place
     * c1 digits of leading '0'
     * c2 digits from conversion
     * c3 digits of trailing '0'
     * c4 digits after '.'
     */
    c1 = 0;
    c2 = prec + 1;
    c3 = 0;
    c4 = prec;
    switch(chr) {
    default:
        if(xadd(s1, c2, 5))
            e++;
        break;
    case 'g':
        /*
         * decide on 'e' of 'f' style convers
         */
        if(xadd(s1, c2, 5))
            e++;
        if(e >= -5 && e <= prec) {
            c1 = -e - 1;
            c4 = prec - e;
            chr = 'h';  // flag for 'f' style
        }
        break;
    case 'f':
        if(xadd(s1, c2+e, 5))
            e++;
        c1 = -e;
        if(c1 > prec)
            c1 = c2;
        c2 += e;
        break;
    }

    /*
     * clean up c1 c2 and c3
     */
    if(c1 < 0)
        c1 = 0;
    if(c2 < 0)
        c2 = 0;
    if(c2 > NSIGNIF) {
        c3 = c2-NSIGNIF;
        c2 = NSIGNIF;
    }

    /*
     * copy digits
     */
    while(c1 > 0) {
        if(c1+c2+c3 == c4)
            s2[d++] = '.';
        s2[d++] = '0';
        c1--;
    }
    while(c2 > 0) {
        if(c2+c3 == c4)
            s2[d++] = '.';
        s2[d++] = s1[i++];
        c2--;
    }
    while(c3 > 0) {
        if(c3 == c4)
            s2[d++] = '.';
        s2[d++] = '0';
        c3--;
    }

    /*
     * strip trailing '0' on g conv
     */
    if(fmt->flags & FmtSharp) {
        if(0 == c4)
            s2[d++] = '.';
    } else
    if(chr == 'g' || chr == 'h') {
        for(n=d-1; n>=0; n--)
            if(s2[n] != '0')
                break;
        for(i=n; i>=0; i--)
            if(s2[i] == '.') {
                d = n;
                if(i != n)
                    d++;
                break;
            }
    }
    if(chr == 'e' || chr == 'g') {
        if(ucase)
            s2[d++] = 'E';
        else
            s2[d++] = 'e';
        c1 = e;
        if(c1 < 0) {
            s2[d++] = '-';
            c1 = -c1;
        } else
            s2[d++] = '+';
        if(c1 >= 100) {
            s2[d++] = c1/100 + '0';
            c1 = c1%100;
        }
        s2[d++] = c1/10 + '0';
        s2[d++] = c1%10 + '0';
    }
    s2[d] = 0;
}
@

<<function [[_floatfmt]]>>=
int
_floatfmt(Fmt *fmt, double f)
{
    char s[1+NEXP10+1+FDIGIT+1];

    /*
     * The max length of a %f string is
     *  '[+-]'+"max exponent"+'.'+"max precision"+'\0'
     * which is 341 currently.
     */ 
    xdtoa(fmt, s, f);
    fmt->flags &= FmtWidth|FmtLeft;
    _fmtcpy(fmt, s, strlen(s), strlen(s));
    return 0;
}
@

<<function [[_efgfmt]]>>=
int
_efgfmt(Fmt *f)
{
    double d;

    d = va_arg(f->args, double);
    return _floatfmt(f, d);
}
@


%-------------------------------------------------------------

<<libc/fmt/fltfmt.c>>=
#include <u.h>
#include <libc.h>
#include <ctype.h>
#include "fmtdef.h"

<<enum [[_anon_ (fmt/fltfmt.c)]]>>

<<function [[xadd]]>>

<<function [[xsub]]>>

<<function [[xdtoa]]>>

<<function [[_floatfmt]]>>

<<function [[_efgfmt]]>>
@


\subsection*{[[libc/fmt/fmt.c]]}

<<enum [[_anon_ (fmt/fmt.c)]]>>=
enum
{
    Maxfmt = 64
};
@

<<struct [[Convfmt]]>>=
struct Convfmt
{
    int c;
    volatile    Fmts    fmt;    /* for spin lock in fmtfmt; avoids race due to write order */
};
@

<<global [[fmtalloc]]>>=
struct
{
    /* lock by calling _fmtlock, _fmtunlock */
    int nfmt;
    Convfmt fmt[Maxfmt];
} fmtalloc;
@

<<global [[knownfmt]]>>=
static Convfmt knownfmt[] = {
    ' ',    _flagfmt,
    '#',    _flagfmt,
    '%',    _percentfmt,
    '+',    _flagfmt,
    ',',    _flagfmt,
    '-',    _flagfmt,
    'C',    _runefmt,
    'E',    _efgfmt,
    'G',    _efgfmt,
    'S',    _runesfmt,
    'X',    _ifmt,
    'b',    _ifmt,
    'c',    _charfmt,
    'd',    _ifmt,
    'e',    _efgfmt,
    'f',    _efgfmt,
    'g',    _efgfmt,
    'h',    _flagfmt,
    'l',    _flagfmt,
    'n',    _countfmt,
    'o',    _ifmt,
    'p',    _ifmt,
    'r',    errfmt,
    's',    _strfmt,
    'u',    _flagfmt,
    'x',    _ifmt,
    0,  nil,
};
@

<<global doquote (fmt/fmt.c)>>=
int (*doquote)(int);
@

<<function [[_fmtinstall]]>>=
/*
 * _fmtlock() must be set
 */
static int
_fmtinstall(int c, Fmts f)
{
    Convfmt *p, *ep;

    if(c<=0 || c>=65536)
        return -1;
    if(!f)
        f = _badfmt;

    ep = &fmtalloc.fmt[fmtalloc.nfmt];
    for(p=fmtalloc.fmt; p<ep; p++)
        if(p->c == c)
            break;

    if(p == &fmtalloc.fmt[Maxfmt])
        return -1;

    p->fmt = f;
    if(p == ep){    /* installing a new format character */
        fmtalloc.nfmt++;
        p->c = c;
    }

    return 0;
}
@

<<function [[fmtinstall]]>>=
int
fmtinstall(int c, Fmts f)
{
    int ret;

    _fmtlock();
    ret = _fmtinstall(c, f);
    _fmtunlock();
    return ret;
}
@

<<function [[fmtfmt]]>>=
static Fmts
fmtfmt(int c)
{
    Convfmt *p, *ep;

    ep = &fmtalloc.fmt[fmtalloc.nfmt];
    for(p=fmtalloc.fmt; p<ep; p++)
        if(p->c == c){
            while(p->fmt == nil)    /* loop until value is updated */
                ;
            return p->fmt;
        }

    /* is this a predefined format char? */
    _fmtlock();
    for(p=knownfmt; p->c; p++)
        if(p->c == c){
            _fmtinstall(p->c, p->fmt);
            _fmtunlock();
            return p->fmt;
        }
    _fmtunlock();

    return _badfmt;
}
@

<<function [[_fmtdispatch]]>>=
void*
_fmtdispatch(Fmt *f, void *fmt, int isrunes)
{
    Rune rune, r;
    int i, n, w, p;
    ulong fl;
    void *ret;

    w = f->width;
    p = f->prec;
    fl = f->flags;

    f->flags = 0;
    f->width = f->prec = 0;

    for(;;){
        if(isrunes){
            r = *(Rune*)fmt;
            fmt = (Rune*)fmt + 1;
        }else{
            fmt = (char*)fmt + chartorune(&rune, fmt);
            r = rune;
        }
        f->r = r;
        switch(r){
        case '\0':
            ret = nil;
            goto end;
        case '.':
            f->flags |= FmtWidth|FmtPrec;
            continue;
        case '0':
            if(!(f->flags & FmtWidth)){
                f->flags |= FmtZero;
                continue;
            }
            /* fall through */
        case '1': case '2': case '3': case '4':
        case '5': case '6': case '7': case '8': case '9':
            i = 0;
            while(r >= '0' && r <= '9'){
                i = i * 10 + r - '0';
                if(isrunes){
                    r = *(Rune*)fmt;
                    fmt = (Rune*)fmt + 1;
                }else{
                    r = *(char*)fmt;
                    fmt = (char*)fmt + 1;
                }
            }
            if(isrunes)
                fmt = (Rune*)fmt - 1;
            else
                fmt = (char*)fmt - 1;
        numflag:
            if(f->flags & FmtWidth){
                f->flags |= FmtPrec;
                f->prec = i;
            }else{
                f->flags |= FmtWidth;
                f->width = i;
            }
            continue;
        case '*':
            i = va_arg(f->args, int);
            if(i < 0){
                /*
                 * negative precision =>
                 * ignore the precision.
                 */
                if(f->flags & FmtPrec){
                    f->flags &= ~FmtPrec;
                    f->prec = 0;
                    continue;
                }
                i = -i;
                f->flags |= FmtLeft;
            }
            goto numflag;
        }
        n = (*fmtfmt(r))(f);
        if(n < 0){
            ret = nil;
            break;
        }
        if(n == 0){
            ret = fmt;
            break;
        }
    }
end:
    f->width = w;
    f->prec = p;
    f->flags = fl;
    return ret;
}
@


%-------------------------------------------------------------

<<libc/fmt/fmt.c>>=
#include <u.h>
#include <libc.h>
#include "fmtdef.h"

<<enum [[_anon_ (fmt/fmt.c)]]>>

typedef struct Convfmt Convfmt;
<<struct [[Convfmt]]>>

<<global [[fmtalloc]]>>

<<global [[knownfmt]]>>

<<global doquote (fmt/fmt.c)>>

<<function [[_fmtinstall]]>>

<<function [[fmtinstall]]>>

<<function [[fmtfmt]]>>

<<function [[_fmtdispatch]]>>
@


\subsection*{[[libc/fmt/fmtfd.c]]}

<<function [[fmtfdflush]]>>=
/*
 * public routine for final flush of a formatting buffer
 * to a file descriptor; returns total char count.
 */
int
fmtfdflush(Fmt *f)
{
    if(_fmtFdFlush(f) <= 0)
        return -1;
    return f->nfmt;
}
@

<<function [[fmtfdinit]]>>=
/*
 * initialize an output buffer for buffered printing
 */
int
fmtfdinit(Fmt *f, int fd, char *buf, int size)
{
    f->runes = 0;
    f->start = buf;
    f->to = buf;
    f->stop = buf + size;
    f->flush = _fmtFdFlush;
    f->farg = (void*)fd;
    f->nfmt = 0;
    return 0;
}
@


%-------------------------------------------------------------

<<libc/fmt/fmtfd.c>>=
#include <u.h>
#include <libc.h>
#include "fmtdef.h"

<<function [[fmtfdflush]]>>

<<function [[fmtfdinit]]>>
@


\subsection*{[[libc/fmt/fmtlock.c]]}

<<global [[fmtl]]>>=
static Lock fmtl;
@

<<function [[_fmtlock]]>>=
void
_fmtlock(void)
{
    lock(&fmtl);
}
@

<<function [[_fmtunlock]]>>=
void
_fmtunlock(void)
{
    unlock(&fmtl);
}
@


%-------------------------------------------------------------

<<libc/fmt/fmtlock.c>>=
#include <u.h>
#include <libc.h>

<<global [[fmtl]]>>

<<function [[_fmtlock]]>>

<<function [[_fmtunlock]]>>
@


\subsection*{[[libc/fmt/fmtprint.c]]}

<<function [[fmtprint]]>>=
/*
 * format a string into the output buffer
 * designed for formats which themselves call fmt
 */
int
fmtprint(Fmt *f, char *fmt, ...)
{
    va_list va;
    int n;

    va_start(va, fmt);
    n = fmtvprint(f, fmt, va);
    va_end(va);
    return n;
}
@


%-------------------------------------------------------------

<<libc/fmt/fmtprint.c>>=
#include <u.h>
#include <libc.h>
#include "fmtdef.h"


<<function [[fmtprint]]>>

@


\subsection*{[[libc/fmt/fmtquote.c]]}

<<function [[_quotesetup]]>>=
/*
 * How many bytes of output UTF will be produced by quoting (if necessary) this string?
 * How many runes? How much of the input will be consumed?
 * The parameter q is filled in by _quotesetup.
 * The string may be UTF or Runes (s or r).
 * Return count does not include NUL.
 * Terminate the scan at the first of:
 *  NUL in input
 *  count exceeded in input
 *  count exceeded on output
 * *ninp is set to number of input bytes accepted.
 * nin may be <0 initially, to avoid checking input by count.
 */
void
_quotesetup(char *s, Rune *r, int nin, int nout, Quoteinfo *q, int sharp, int runesout)
{
    int w;
    Rune c;

    q->quoted = 0;
    q->nbytesout = 0;
    q->nrunesout = 0;
    q->nbytesin = 0;
    q->nrunesin = 0;
    if(sharp || nin==0 || (s && *s=='\0') || (r && *r=='\0')){
        if(nout < 2)
            return;
        q->quoted = 1;
        q->nbytesout = 2;
        q->nrunesout = 2;
    }
    for(; nin!=0; nin--){
        if(s)
            w = chartorune(&c, s);
        else{
            c = *r;
            w = runelen(c);
        }

        if(c == '\0')
            break;
        if(runesout){
            if(q->nrunesout+1 > nout)
                break;
        }else{
            if(q->nbytesout+w > nout)
                break;
        }

        if((c <= L' ') || (c == L'\'') || (doquote!=nil && doquote(c))){
            if(!q->quoted){
                if(runesout){
                    if(1+q->nrunesout+1+1 > nout)   /* no room for quotes */
                        break;
                }else{
                    if(1+q->nbytesout+w+1 > nout)   /* no room for quotes */
                        break;
                }
                q->nrunesout += 2;  /* include quotes */
                q->nbytesout += 2;  /* include quotes */
                q->quoted = 1;
            }
            if(c == '\'')   {
                if(runesout){
                    if(1+q->nrunesout+1 > nout) /* no room for quotes */
                        break;
                }else{
                    if(1+q->nbytesout+w > nout) /* no room for quotes */
                        break;
                }
                q->nbytesout++;
                q->nrunesout++; /* quotes reproduce as two characters */
            }
        }

        /* advance input */
        if(s)
            s += w;
        else
            r++;
        q->nbytesin += w;
        q->nrunesin++;

        /* advance output */
        q->nbytesout += w;
        q->nrunesout++;
    }
}
@

<<function [[qstrfmt]]>>=
static int
qstrfmt(char *sin, Rune *rin, Quoteinfo *q, Fmt *f)
{
    Rune r, *rm, *rme;
    char *t, *s, *m, *me;
    Rune *rt, *rs;
    ulong fl;
    int nc, w;

    m = sin;
    me = m + q->nbytesin;
    rm = rin;
    rme = rm + q->nrunesin;

    w = f->width;
    fl = f->flags;
    if(f->runes){
        if(!(fl & FmtLeft) && _rfmtpad(f, w - q->nrunesout) < 0)
            return -1;
    }else{
        if(!(fl & FmtLeft) && _fmtpad(f, w - q->nbytesout) < 0)
            return -1;
    }
    t = f->to;
    s = f->stop;
    rt = f->to;
    rs = f->stop;
    if(f->runes)
        FMTRCHAR(f, rt, rs, '\'');
    else
        FMTRUNE(f, t, s, '\'');
    for(nc = q->nrunesin; nc > 0; nc--){
        if(sin){
            r = *(uchar*)m;
            if(r < Runeself)
                m++;
            else if((me - m) >= UTFmax || fullrune(m, me-m))
                m += chartorune(&r, m);
            else
                break;
        }else{
            if(rm >= rme)
                break;
            r = *(uchar*)rm++;
        }
        if(f->runes){
            FMTRCHAR(f, rt, rs, r);
            if(r == '\'')
                FMTRCHAR(f, rt, rs, r);
        }else{
            FMTRUNE(f, t, s, r);
            if(r == '\'')
                FMTRUNE(f, t, s, r);
        }
    }

    if(f->runes){
        FMTRCHAR(f, rt, rs, '\'');
        USED(rs);
        f->nfmt += rt - (Rune *)f->to;
        f->to = rt;
        if(fl & FmtLeft && _rfmtpad(f, w - q->nrunesout) < 0)
            return -1;
    }else{
        FMTRUNE(f, t, s, '\'');
        USED(s);
        f->nfmt += t - (char *)f->to;
        f->to = t;
        if(fl & FmtLeft && _fmtpad(f, w - q->nbytesout) < 0)
            return -1;
    }
    return 0;
}
@

<<function [[_quotestrfmt]]>>=
int
_quotestrfmt(int runesin, Fmt *f)
{
    int nin, outlen;
    Rune *r;
    char *s;
    Quoteinfo q;

    nin = -1;
    if(f->flags&FmtPrec)
        nin = f->prec;
    if(runesin){
        r = va_arg(f->args, Rune *);
        s = nil;
    }else{
        s = va_arg(f->args, char *);
        r = nil;
    }
    if(!s && !r)
        return _fmtcpy(f, "<nil>", 5, 5);

    if(f->flush)
        outlen = 0x7FFFFFFF;    /* if we can flush, no output limit */
    else if(f->runes)
        outlen = (Rune*)f->stop - (Rune*)f->to;
    else
        outlen = (char*)f->stop - (char*)f->to;

    _quotesetup(s, r, nin, outlen, &q, f->flags&FmtSharp, f->runes);
//print("bytes in %d bytes out %d runes in %d runesout %d\n", q.nbytesin, q.nbytesout, q.nrunesin, q.nrunesout);

    if(runesin){
        if(!q.quoted)
            return _fmtrcpy(f, r, q.nrunesin);
        return qstrfmt(nil, r, &q, f);
    }

    if(!q.quoted)
        return _fmtcpy(f, s, q.nrunesin, q.nbytesin);
    return qstrfmt(s, nil, &q, f);
}
@

<<function [[quotestrfmt]]>>=
int
quotestrfmt(Fmt *f)
{
    return _quotestrfmt(0, f);
}
@

<<function [[quoterunestrfmt]]>>=
int
quoterunestrfmt(Fmt *f)
{
    return _quotestrfmt(1, f);
}
@

<<function [[quotefmtinstall]]>>=
void
quotefmtinstall(void)
{
    fmtinstall('q', quotestrfmt);
    fmtinstall('Q', quoterunestrfmt);
}
@

<<function [[_needsquotes]]>>=
int
_needsquotes(char *s, int *quotelenp)
{
    Quoteinfo q;

    _quotesetup(s, nil, -1, 0x7FFFFFFF, &q, 0, 0);
    *quotelenp = q.nbytesout;

    return q.quoted;
}
@

<<function [[_runeneedsquotes]]>>=
int
_runeneedsquotes(Rune *r, int *quotelenp)
{
    Quoteinfo q;

    _quotesetup(nil, r, -1, 0x7FFFFFFF, &q, 0, 0);
    *quotelenp = q.nrunesout;

    return q.quoted;
}
@


%-------------------------------------------------------------

<<libc/fmt/fmtquote.c>>=
#include <u.h>
#include <libc.h>
#include "fmtdef.h"

<<function [[_quotesetup]]>>

<<function [[qstrfmt]]>>

<<function [[_quotestrfmt]]>>

<<function [[quotestrfmt]]>>

<<function [[quoterunestrfmt]]>>

<<function [[quotefmtinstall]]>>

<<function [[_needsquotes]]>>

<<function [[_runeneedsquotes]]>>
@


\subsection*{[[libc/fmt/fmtrune.c]]}

<<function [[fmtrune]]>>=
int
fmtrune(Fmt *f, int r)
{
    Rune *rt;
    char *t;
    int n;

    if(f->runes){
        rt = f->to;
        FMTRCHAR(f, rt, f->stop, r);
        f->to = rt;
        n = 1;
    }else{
        t = f->to;
        FMTRUNE(f, t, f->stop, r);
        n = t - (char*)f->to;
        f->to = t;
    }
    f->nfmt += n;
    return 0;
}
@


%-------------------------------------------------------------

<<libc/fmt/fmtrune.c>>=
#include <u.h>
#include <libc.h>
#include "fmtdef.h"

<<function [[fmtrune]]>>
@


\subsection*{[[libc/fmt/fmtstr.c]]}

<<function [[fmtstrflush]]>>=
char*
fmtstrflush(Fmt *f)
{
    if(f->start == nil)
        return nil;
    *(char*)f->to = '\0';
    return f->start;
}
@


%-------------------------------------------------------------

<<libc/fmt/fmtstr.c>>=
#include <u.h>
#include <libc.h>

<<function [[fmtstrflush]]>>
@


\subsection*{[[libc/fmt/fmtvprint.c]]}

<<function [[fmtvprint]]>>=
/*
 * format a string into the output buffer
 * designed for formats which themselves call fmt
 */
int
fmtvprint(Fmt *f, char *fmt, va_list args)
{
    va_list va;
    int n;

    va = f->args;
    f->args = args;
    n = dofmt(f, fmt);
    f->args = va;
    if(n >= 0)
        return 0;
    return n;
}
@


%-------------------------------------------------------------

<<libc/fmt/fmtvprint.c>>=
#include <u.h>
#include <libc.h>
#include "fmtdef.h"


<<function [[fmtvprint]]>>

@


\subsection*{[[libc/fmt/fprint.c]]}

<<function [[fprint]]>>=
int
fprint(int fd, char *fmt, ...)
{
    int n;
    va_list args;

    va_start(args, fmt);
    n = vfprint(fd, fmt, args);
    va_end(args);
    return n;
}
@


%-------------------------------------------------------------

<<libc/fmt/fprint.c>>=
#include    <u.h>
#include    <libc.h>

<<function [[fprint]]>>
@


\subsection*{[[libc/fmt/print.c]]}

<<function [[libc_print]]>>=
int
libc_print(char *fmt, ...)
{
    int n;
    va_list args;

    va_start(args, fmt);
    n = vfprint(1, fmt, args);
    va_end(args);
    return n;
}
@

<<global [[print]]>>=
int (*print)(char *fmt, ...) = &libc_print;
@


%-------------------------------------------------------------

<<libc/fmt/print.c>>=
#include    <u.h>
#include    <libc.h>

<<function [[libc_print]]>>

<<global [[print]]>>
@


\subsection*{[[libc/fmt/runefmtstr.c]]}

<<function [[runefmtstrflush]]>>=
Rune*
runefmtstrflush(Fmt *f)
{
    if(f->start == nil)
        return nil;
    *(Rune*)f->to = '\0';
    return f->start;
}
@


%-------------------------------------------------------------

<<libc/fmt/runefmtstr.c>>=
#include <u.h>
#include <libc.h>

<<function [[runefmtstrflush]]>>
@


\subsection*{[[libc/fmt/runeseprint.c]]}

<<function [[runeseprint]]>>=
Rune*
runeseprint(Rune *buf, Rune *e, char *fmt, ...)
{
    Rune *p;
    va_list args;

    va_start(args, fmt);
    p = runevseprint(buf, e, fmt, args);
    va_end(args);
    return p;
}
@


%-------------------------------------------------------------

<<libc/fmt/runeseprint.c>>=
#include <u.h>
#include <libc.h>

<<function [[runeseprint]]>>
@


\subsection*{[[libc/fmt/runesmprint.c]]}

<<function [[runesmprint]]>>=
Rune*
runesmprint(char *fmt, ...)
{
    va_list args;
    Rune *p;

    va_start(args, fmt);
    p = runevsmprint(fmt, args);
    va_end(args);
    return p;
}
@


%-------------------------------------------------------------

<<libc/fmt/runesmprint.c>>=
#include <u.h>
#include <libc.h>

<<function [[runesmprint]]>>
@


\subsection*{[[libc/fmt/runesnprint.c]]}

<<function [[runesnprint]]>>=
int
runesnprint(Rune *buf, int len, char *fmt, ...)
{
    int n;
    va_list args;

    va_start(args, fmt);
    n = runevsnprint(buf, len, fmt, args);
    va_end(args);
    return n;
}
@


%-------------------------------------------------------------

<<libc/fmt/runesnprint.c>>=
#include <u.h>
#include <libc.h>

<<function [[runesnprint]]>>

@


\subsection*{[[libc/fmt/runesprint.c]]}

<<function [[runesprint]]>>=
int
runesprint(Rune *buf, char *fmt, ...)
{
    int n;
    va_list args;

    va_start(args, fmt);
    n = runevsnprint(buf, 256, fmt, args);
    va_end(args);
    return n;
}
@


%-------------------------------------------------------------

<<libc/fmt/runesprint.c>>=
#include <u.h>
#include <libc.h>

<<function [[runesprint]]>>
@


\subsection*{[[libc/fmt/runevseprint.c]]}

<<function [[runevseprint]]>>=
Rune*
runevseprint(Rune *buf, Rune *e, char *fmt, va_list args)
{
    Fmt f;

    if(e <= buf)
        return nil;
    f.runes = 1;
    f.start = buf;
    f.to = buf;
    f.stop = e - 1;
    f.flush = nil;
    f.farg = nil;
    f.nfmt = 0;
    f.args = args;
    dofmt(&f, fmt);
    *(Rune*)f.to = '\0';
    return f.to;
}
@


%-------------------------------------------------------------

<<libc/fmt/runevseprint.c>>=
#include <u.h>
#include <libc.h>

<<function [[runevseprint]]>>

@


\subsection*{[[libc/fmt/runevsmprint.c]]}

<<function [[runeFmtStrFlush]]>>=
static int
runeFmtStrFlush(Fmt *f)
{
    Rune *s;
    int n;

    if(f->start == nil)
        return 0;
    n = (int)(uintptr)f->farg;
    n *= 2;
    s = f->start;
    f->start = realloc(s, sizeof(Rune)*n);
    if(f->start == nil){
        f->farg = nil;
        f->to = nil;
        f->stop = nil;
        free(s);
        return 0;
    }
    f->farg = (void*)n;
    f->to = (Rune*)f->start + ((Rune*)f->to - s);
    f->stop = (Rune*)f->start + n - 1;
    return 1;
}
@

<<function [[runefmtstrinit]]>>=
int
runefmtstrinit(Fmt *f)
{
    int n;

    memset(f, 0, sizeof *f);
    f->runes = 1;
    n = 32;
    f->start = malloc(sizeof(Rune)*n);
    if(f->start == nil)
        return -1;
    setmalloctag(f->start, getcallerpc(&f));
    f->to = f->start;
    f->stop = (Rune*)f->start + n - 1;
    f->flush = runeFmtStrFlush;
    f->farg = (void*)n;
    f->nfmt = 0;
    return 0;
}
@

<<function [[runevsmprint]]>>=
/*
 * print into an allocated string buffer
 */
Rune*
runevsmprint(char *fmt, va_list args)
{
    Fmt f;
    int n;

    if(runefmtstrinit(&f) < 0)
        return nil;
    f.args = args;
    n = dofmt(&f, fmt);
    if(f.start == nil)      /* realloc failed? */
        return nil;
    if(n < 0){
        free(f.start);
        return nil;
    }
    setmalloctag(f.start, getcallerpc(&fmt));
    *(Rune*)f.to = '\0';
    return f.start;
}
@


%-------------------------------------------------------------

<<libc/fmt/runevsmprint.c>>=
#include <u.h>
#include <libc.h>
#include "fmtdef.h"

<<function [[runeFmtStrFlush]]>>

<<function [[runefmtstrinit]]>>

<<function [[runevsmprint]]>>
@


\subsection*{[[libc/fmt/runevsnprint.c]]}

<<function [[runevsnprint]]>>=
int
runevsnprint(Rune *buf, int len, char *fmt, va_list args)
{
    Fmt f;

    if(len <= 0)
        return -1;
    f.runes = 1;
    f.start = buf;
    f.to = buf;
    f.stop = buf + len - 1;
    f.flush = nil;
    f.farg = nil;
    f.nfmt = 0;
    f.args = args;
    dofmt(&f, fmt);
    *(Rune*)f.to = '\0';
    return (Rune*)f.to - buf;
}
@


%-------------------------------------------------------------

<<libc/fmt/runevsnprint.c>>=
#include <u.h>
#include <libc.h>

<<function [[runevsnprint]]>>
@


\subsection*{[[libc/fmt/seprint.c]]}

<<function [[seprint]]>>=
char*
seprint(char *buf, char *e, char *fmt, ...)
{
    char *p;
    va_list args;

    va_start(args, fmt);
    p = vseprint(buf, e, fmt, args);
    va_end(args);
    return p;
}
@


%-------------------------------------------------------------

<<libc/fmt/seprint.c>>=
#include <u.h>
#include <libc.h>

<<function [[seprint]]>>
@


\subsection*{[[libc/fmt/smprint.c]]}

<<function [[smprint]]>>=
char*
smprint(char *fmt, ...)
{
    va_list args;
    char *p;

    va_start(args, fmt);
    p = vsmprint(fmt, args);
    va_end(args);
    setmalloctag(p, getcallerpc(&fmt));
    return p;
}
@


%-------------------------------------------------------------

<<libc/fmt/smprint.c>>=
#include <u.h>
#include <libc.h>

<<function [[smprint]]>>
@


\subsection*{[[libc/fmt/snprint.c]]}

<<function [[snprint]]>>=
int
snprint(char *buf, int len, char *fmt, ...)
{
    int n;
    va_list args;

    va_start(args, fmt);
    n = vsnprint(buf, len, fmt, args);
    va_end(args);
    return n;
}
@


%-------------------------------------------------------------

<<libc/fmt/snprint.c>>=
#include <u.h>
#include <libc.h>

<<function [[snprint]]>>

@


\subsection*{[[libc/fmt/sprint.c]]}

<<function [[sprint]]>>=
int
sprint(char *buf, char *fmt, ...)
{
    int n;
    va_list args;

    va_start(args, fmt);
    n = vsnprint(buf, 65536, fmt, args);    /* big number, but sprint is deprecated anyway */
    va_end(args);
    return n;
}
@


%-------------------------------------------------------------

<<libc/fmt/sprint.c>>=
#include <u.h>
#include <libc.h>

<<function [[sprint]]>>
@


\subsection*{[[libc/fmt/vfprint.c]]}

<<function [[_fmtFdFlush]]>>=
/*
 * generic routine for flushing a formatting buffer
 * to a file descriptor
 */
int
_fmtFdFlush(Fmt *f)
{
    int n;

    n = (char*)f->to - (char*)f->start;
    if(n && write((int)(uintptr)f->farg, f->start, n) != n)
        return 0;
    f->to = f->start;
    return 1;
}
@

<<function [[vfprint]]>>=
int
vfprint(int fd, char *fmt, va_list args)
{
    Fmt f;
    char buf[256];
    int n;

    fmtfdinit(&f, fd, buf, sizeof(buf));
    f.args = args;
    n = dofmt(&f, fmt);
    if(n > 0 && _fmtFdFlush(&f) == 0)
        return -1;
    return n;
}
@


%-------------------------------------------------------------

<<libc/fmt/vfprint.c>>=
#include <u.h>
#include <libc.h>
#include "fmtdef.h"

<<function [[_fmtFdFlush]]>>

<<function [[vfprint]]>>
@


\subsection*{[[libc/fmt/vseprint.c]]}

<<function [[vseprint]]>>=
char*
vseprint(char *buf, char *e, char *fmt, va_list args)
{
    Fmt f;

    if(e <= buf)
        return nil;
    f.runes = 0;
    f.start = buf;
    f.to = buf;
    f.stop = e - 1;
    f.flush = nil;
    f.farg = nil;
    f.nfmt = 0;
    f.args = args;
    dofmt(&f, fmt);
    *(char*)f.to = '\0';
    return f.to;
}
@


%-------------------------------------------------------------

<<libc/fmt/vseprint.c>>=
#include <u.h>
#include <libc.h>

<<function [[vseprint]]>>

@


\subsection*{[[libc/fmt/vsmprint.c]]}

<<function [[fmtStrFlush]]>>=
static int
fmtStrFlush(Fmt *f)
{
    char *s;
    int n;

    if(f->start == nil)
        return 0;
    n = (int)(uintptr)f->farg;
    n *= 2;
    s = f->start;
    f->start = realloc(s, n);
    if(f->start == nil){
        f->farg = nil;
        f->to = nil;
        f->stop = nil;
        free(s);
        return 0;
    }
    f->farg = (void*)n;
    f->to = (char*)f->start + ((char*)f->to - s);
    f->stop = (char*)f->start + n - 1;
    return 1;
}
@

<<function [[fmtstrinit]]>>=
int
fmtstrinit(Fmt *f)
{
    int n;

    memset(f, 0, sizeof *f);
    f->runes = 0;
    n = 32;
    f->start = malloc(n);
    if(f->start == nil)
        return -1;
    setmalloctag(f->start, getcallerpc(&f));
    f->to = f->start;
    f->stop = (char*)f->start + n - 1;
    f->flush = fmtStrFlush;
    f->farg = (void*)n;
    f->nfmt = 0;
    return 0;
}
@

<<function [[vsmprint]]>>=
/*
 * print into an allocated string buffer
 */
char*
vsmprint(char *fmt, va_list args)
{
    Fmt f;
    int n;

    if(fmtstrinit(&f) < 0)
        return nil;
    f.args = args;
    n = dofmt(&f, fmt);
    if(f.start == nil)      /* realloc failed? */
        return nil;
    if(n < 0){
        free(f.start);
        return nil;
    }
    setmalloctag(f.start, getcallerpc(&fmt));
    *(char*)f.to = '\0';
    return f.start;
}
@


%-------------------------------------------------------------

<<libc/fmt/vsmprint.c>>=
#include <u.h>
#include <libc.h>
#include "fmtdef.h"

<<function [[fmtStrFlush]]>>

<<function [[fmtstrinit]]>>

<<function [[vsmprint]]>>
@


\subsection*{[[libc/fmt/vsnprint.c]]}

<<function [[vsnprint]]>>=
int
vsnprint(char *buf, int len, char *fmt, va_list args)
{
    Fmt f;

    if(len <= 0)
        return -1;
    f.runes = 0;
    f.start = buf;
    f.to = buf;
    f.stop = buf + len - 1;
    f.flush = nil;
    f.farg = nil;
    f.nfmt = 0;
    f.args = args;
    dofmt(&f, fmt);
    *(char*)f.to = '\0';
    return (char*)f.to - buf;
}
@


%-------------------------------------------------------------

<<libc/fmt/vsnprint.c>>=
#include <u.h>
#include <libc.h>

<<function [[vsnprint]]>>
@



\section{[[lib_core/libc/arm/]]}

\subsection*{[[libc/arm/cycles.c]]}

<<function [[cycles]](arm)>>=
void
cycles(uvlong* u)
{
    *u = 0LL;
}
@


%-------------------------------------------------------------

<<libc/arm/cycles.c>>=
#include <u.h>
#include <libc.h>

#pragma profile off

<<function [[cycles]](arm)>>
@


\subsection*{[[libc/arm/notejmp.c]]}

<<function [[notejmp]](arm)>>=
void
notejmp(void *vr, jmp_buf j, int ret)
{
    struct Ureg *r = vr;

    r->r0 = ret;
    if(ret == 0)
        r->r0 = 1;
    r->pc = j[JMPBUFPC];
    r->r13 = j[JMPBUFSP];
    noted(NCONT);
}
@


%-------------------------------------------------------------

<<libc/arm/notejmp.c>>=
#include <u.h>
#include <libc.h>
#include <ureg.h>

<<function [[notejmp]](arm)>>
@


\subsection*{[[libc/arm/vlrt.c]]}

<<macro [[SIGN]](arm)>>=
#define SIGN(n) (1UL<<(n-1))
@

<<struct [[Vlong]](arm)>>=
struct  Vlong
{
    ulong   lo;
    ulong   hi;
};
@

<<function [[_addv]](arm)>>=
void
_addv(Vlong *r, Vlong a, Vlong b)
{
    ulong lo, hi;

    lo = a.lo + b.lo;
    hi = a.hi + b.hi;
    if(lo < a.lo)
        hi++;
    r->lo = lo;
    r->hi = hi;
}
@

<<function [[_subv]](arm)>>=
void
_subv(Vlong *r, Vlong a, Vlong b)
{
    ulong lo, hi;

    lo = a.lo - b.lo;
    hi = a.hi - b.hi;
    if(lo > a.lo)
        hi--;
    r->lo = lo;
    r->hi = hi;
}
@

<<function [[_d2v]](arm)>>=
void
_d2v(Vlong *y, double d)
{
    union { double d; struct Vlong; } x;
    ulong xhi, xlo, ylo, yhi;
    int sh;

    x.d = d;

    xhi = (x.hi & 0xfffff) | 0x100000;
    xlo = x.lo;
    sh = 1075 - ((x.hi >> 20) & 0x7ff);

    ylo = 0;
    yhi = 0;
    if(sh >= 0) {
        /* v = (hi||lo) >> sh */
        if(sh < 32) {
            if(sh == 0) {
                ylo = xlo;
                yhi = xhi;
            } else {
                ylo = (xlo >> sh) | (xhi << (32-sh));
                yhi = xhi >> sh;
            }
        } else {
            if(sh == 32) {
                ylo = xhi;
            } else
            if(sh < 64) {
                ylo = xhi >> (sh-32);
            }
        }
    } else {
        /* v = (hi||lo) << -sh */
        sh = -sh;
        if(sh <= 10) {
            ylo = xlo << sh;
            yhi = (xhi << sh) | (xlo >> (32-sh));
        } else {
            /* overflow */
            yhi = d;    /* causes something awful */
        }
    }
    if(x.hi & SIGN(32)) {
        if(ylo != 0) {
            ylo = -ylo;
            yhi = ~yhi;
        } else
            yhi = -yhi;
    }

    y->hi = yhi;
    y->lo = ylo;
}
@

<<function [[_f2v]](arm)>>=
void
_f2v(Vlong *y, float f)
{
    _d2v(y, f);
}
@

<<function [[_v2d]](arm)>>=
double
_v2d(Vlong x)
{
    if(x.hi & SIGN(32)) {
        if(x.lo) {
            x.lo = -x.lo;
            x.hi = ~x.hi;
        } else
            x.hi = -x.hi;
        return -((long)x.hi*4294967296. + x.lo);
    }
    return (long)x.hi*4294967296. + x.lo;
}
@

<<function [[_v2f]](arm)>>=
float
_v2f(Vlong x)
{
    return _v2d(x);
}
@

<<function [[dodiv]](arm)>>=
static void
dodiv(Vlong num, Vlong den, Vlong *q, Vlong *r)
{
    ulong numlo, numhi, denhi, denlo, quohi, quolo, t;
    int i;

    numhi = num.hi;
    numlo = num.lo;
    denhi = den.hi;
    denlo = den.lo;
    /*
     * get a divide by zero
     */
    if(denlo==0 && denhi==0) {
        numlo = numlo / denlo;
    }

    /*
     * set up the divisor and find the number of iterations needed
     */
    if(numhi >= SIGN(32)) {
        quohi = SIGN(32);
        quolo = 0;
    } else {
        quohi = numhi;
        quolo = numlo;
    }
    i = 0;
    while(denhi < quohi || (denhi == quohi && denlo < quolo)) {
        denhi = (denhi<<1) | (denlo>>31);
        denlo <<= 1;
        i++;
    }

    quohi = 0;
    quolo = 0;
    for(; i >= 0; i--) {
        quohi = (quohi<<1) | (quolo>>31);
        quolo <<= 1;
        if(numhi > denhi || (numhi == denhi && numlo >= denlo)) {
            t = numlo;
            numlo -= denlo;
            if(numlo > t)
                numhi--;
            numhi -= denhi;
            quolo |= 1;
        }
        denlo = (denlo>>1) | (denhi<<31);
        denhi >>= 1;
    }

    if(q) {
        q->lo = quolo;
        q->hi = quohi;
    }
    if(r) {
        r->lo = numlo;
        r->hi = numhi;
    }
}
@

<<function [[_divvu]](arm)>>=
void
_divvu(Vlong *q, Vlong n, Vlong d)
{
    if(n.hi == 0 && d.hi == 0) {
        q->hi = 0;
        q->lo = n.lo / d.lo;
        return;
    }
    dodiv(n, d, q, 0);
}
@

<<function [[_modvu]](arm)>>=
void
_modvu(Vlong *r, Vlong n, Vlong d)
{

    if(n.hi == 0 && d.hi == 0) {
        r->hi = 0;
        r->lo = n.lo % d.lo;
        return;
    }
    dodiv(n, d, 0, r);
}
@

<<function [[vneg]](arm)>>=
static void
vneg(Vlong *v)
{

    if(v->lo == 0) {
        v->hi = -v->hi;
        return;
    }
    v->lo = -v->lo;
    v->hi = ~v->hi;
}
@

<<function [[_divv]](arm)>>=
void
_divv(Vlong *q, Vlong n, Vlong d)
{
    long nneg, dneg;

    if(n.hi == (((long)n.lo)>>31) && d.hi == (((long)d.lo)>>31)) {
        q->lo = (long)n.lo / (long)d.lo;
        q->hi = ((long)q->lo) >> 31;
        return;
    }
    nneg = n.hi >> 31;
    if(nneg)
        vneg(&n);
    dneg = d.hi >> 31;
    if(dneg)
        vneg(&d);
    dodiv(n, d, q, 0);
    if(nneg != dneg)
        vneg(q);
}
@

<<function [[_modv]](arm)>>=
void
_modv(Vlong *r, Vlong n, Vlong d)
{
    long nneg, dneg;

    if(n.hi == (((long)n.lo)>>31) && d.hi == (((long)d.lo)>>31)) {
        r->lo = (long)n.lo % (long)d.lo;
        r->hi = ((long)r->lo) >> 31;
        return;
    }
    nneg = n.hi >> 31;
    if(nneg)
        vneg(&n);
    dneg = d.hi >> 31;
    if(dneg)
        vneg(&d);
    dodiv(n, d, 0, r);
    if(nneg)
        vneg(r);
}
@

<<function [[_rshav]](arm)>>=
void
_rshav(Vlong *r, Vlong a, int b)
{
    long t;

    t = a.hi;
    if(b >= 32) {
        r->hi = t>>31;
        if(b >= 64) {
            /* this is illegal re C standard */
            r->lo = t>>31;
            return;
        }
        r->lo = t >> (b-32);
        return;
    }
    if(b <= 0) {
        r->hi = t;
        r->lo = a.lo;
        return;
    }
    r->hi = t >> b;
    r->lo = (t << (32-b)) | (a.lo >> b);
}
@

<<function [[_rshlv]](arm)>>=
void
_rshlv(Vlong *r, Vlong a, int b)
{
    ulong t;

    t = a.hi;
    if(b >= 32) {
        r->hi = 0;
        if(b >= 64) {
            /* this is illegal re C standard */
            r->lo = 0;
            return;
        }
        r->lo = t >> (b-32);
        return;
    }
    if(b <= 0) {
        r->hi = t;
        r->lo = a.lo;
        return;
    }
    r->hi = t >> b;
    r->lo = (t << (32-b)) | (a.lo >> b);
}
@

<<function [[_lshv]](arm)>>=
void
_lshv(Vlong *r, Vlong a, int b)
{
    ulong t;

    t = a.lo;
    if(b >= 32) {
        r->lo = 0;
        if(b >= 64) {
            /* this is illegal re C standard */
            r->hi = 0;
            return;
        }
        r->hi = t << (b-32);
        return;
    }
    if(b <= 0) {
        r->lo = t;
        r->hi = a.hi;
        return;
    }
    r->lo = t << b;
    r->hi = (t >> (32-b)) | (a.hi << b);
}
@

<<function [[_andv]](arm)>>=
void
_andv(Vlong *r, Vlong a, Vlong b)
{
    r->hi = a.hi & b.hi;
    r->lo = a.lo & b.lo;
}
@

<<function [[_orv]](arm)>>=
void
_orv(Vlong *r, Vlong a, Vlong b)
{
    r->hi = a.hi | b.hi;
    r->lo = a.lo | b.lo;
}
@

<<function [[_xorv]](arm)>>=
void
_xorv(Vlong *r, Vlong a, Vlong b)
{
    r->hi = a.hi ^ b.hi;
    r->lo = a.lo ^ b.lo;
}
@

<<function [[_vpp]](arm)>>=
void
_vpp(Vlong *l, Vlong *r)
{

    l->hi = r->hi;
    l->lo = r->lo;
    r->lo++;
    if(r->lo == 0)
        r->hi++;
}
@

<<function [[_vmm]](arm)>>=
void
_vmm(Vlong *l, Vlong *r)
{

    l->hi = r->hi;
    l->lo = r->lo;
    if(r->lo == 0)
        r->hi--;
    r->lo--;
}
@

<<function [[_ppv]](arm)>>=
void
_ppv(Vlong *l, Vlong *r)
{

    r->lo++;
    if(r->lo == 0)
        r->hi++;
    l->hi = r->hi;
    l->lo = r->lo;
}
@

<<function [[_mmv]](arm)>>=
void
_mmv(Vlong *l, Vlong *r)
{

    if(r->lo == 0)
        r->hi--;
    r->lo--;
    l->hi = r->hi;
    l->lo = r->lo;
}
@

<<function [[_vasop]](arm)>>=
void
_vasop(Vlong *ret, void *lv, void fn(Vlong*, Vlong, Vlong), int type, Vlong rv)
{
    Vlong t, u;

    u = *ret;
    switch(type) {
    default:
        abort();
        break;

    case 1: /* schar */
        t.lo = *(schar*)lv;
        t.hi = t.lo >> 31;
        fn(&u, t, rv);
        *(schar*)lv = u.lo;
        break;

    case 2: /* uchar */
        t.lo = *(uchar*)lv;
        t.hi = 0;
        fn(&u, t, rv);
        *(uchar*)lv = u.lo;
        break;

    case 3: /* short */
        t.lo = *(short*)lv;
        t.hi = t.lo >> 31;
        fn(&u, t, rv);
        *(short*)lv = u.lo;
        break;

    case 4: /* ushort */
        t.lo = *(ushort*)lv;
        t.hi = 0;
        fn(&u, t, rv);
        *(ushort*)lv = u.lo;
        break;

    case 9: /* int */
        t.lo = *(int*)lv;
        t.hi = t.lo >> 31;
        fn(&u, t, rv);
        *(int*)lv = u.lo;
        break;

    case 10:    /* uint */
        t.lo = *(uint*)lv;
        t.hi = 0;
        fn(&u, t, rv);
        *(uint*)lv = u.lo;
        break;

    case 5: /* long */
        t.lo = *(long*)lv;
        t.hi = t.lo >> 31;
        fn(&u, t, rv);
        *(long*)lv = u.lo;
        break;

    case 6: /* ulong */
        t.lo = *(ulong*)lv;
        t.hi = 0;
        fn(&u, t, rv);
        *(ulong*)lv = u.lo;
        break;

    case 7: /* vlong */
    case 8: /* uvlong */
        fn(&u, *(Vlong*)lv, rv);
        *(Vlong*)lv = u;
        break;
    }
    *ret = u;
}
@

<<function [[_p2v]](arm)>>=
void
_p2v(Vlong *ret, void *p)
{
    long t;

    t = (ulong)p;
    ret->lo = t;
    ret->hi = 0;
}
@

<<function [[_sl2v]](arm)>>=
void
_sl2v(Vlong *ret, long sl)
{
    long t;

    t = sl;
    ret->lo = t;
    ret->hi = t >> 31;
}
@

<<function [[_ul2v]](arm)>>=
void
_ul2v(Vlong *ret, ulong ul)
{
    long t;

    t = ul;
    ret->lo = t;
    ret->hi = 0;
}
@

<<function [[_si2v]](arm)>>=
void
_si2v(Vlong *ret, int si)
{
    long t;

    t = si;
    ret->lo = t;
    ret->hi = t >> 31;
}
@

<<function [[_ui2v]](arm)>>=
void
_ui2v(Vlong *ret, uint ui)
{
    long t;

    t = ui;
    ret->lo = t;
    ret->hi = 0;
}
@

<<function [[_sh2v]](arm)>>=
void
_sh2v(Vlong *ret, long sh)
{
    long t;

    t = (sh << 16) >> 16;
    ret->lo = t;
    ret->hi = t >> 31;
}
@

<<function [[_uh2v]](arm)>>=
void
_uh2v(Vlong *ret, ulong ul)
{
    long t;

    t = ul & 0xffff;
    ret->lo = t;
    ret->hi = 0;
}
@

<<function [[_sc2v]](arm)>>=
void
_sc2v(Vlong *ret, long uc)
{
    long t;

    t = (uc << 24) >> 24;
    ret->lo = t;
    ret->hi = t >> 31;
}
@

<<function [[_uc2v]](arm)>>=
void
_uc2v(Vlong *ret, ulong ul)
{
    long t;

    t = ul & 0xff;
    ret->lo = t;
    ret->hi = 0;
}
@

<<function [[_v2sc]](arm)>>=
long
_v2sc(Vlong rv)
{
    long t;

    t = rv.lo & 0xff;
    return (t << 24) >> 24;
}
@

<<function [[_v2uc]](arm)>>=
long
_v2uc(Vlong rv)
{

    return rv.lo & 0xff;
}
@

<<function [[_v2sh]](arm)>>=
long
_v2sh(Vlong rv)
{
    long t;

    t = rv.lo & 0xffff;
    return (t << 16) >> 16;
}
@

<<function [[_v2uh]](arm)>>=
long
_v2uh(Vlong rv)
{

    return rv.lo & 0xffff;
}
@

<<function [[_v2sl]](arm)>>=
long
_v2sl(Vlong rv)
{

    return rv.lo;
}
@

<<function [[_v2ul]](arm)>>=
long
_v2ul(Vlong rv)
{

    return rv.lo;
}
@

<<function [[_v2si]](arm)>>=
long
_v2si(Vlong rv)
{

    return rv.lo;
}
@

<<function [[_v2ui]](arm)>>=
long
_v2ui(Vlong rv)
{

    return rv.lo;
}
@

<<function [[_testv]](arm)>>=
int
_testv(Vlong rv)
{
    return rv.lo || rv.hi;
}
@

<<function [[_eqv]](arm)>>=
int
_eqv(Vlong lv, Vlong rv)
{
    return lv.lo == rv.lo && lv.hi == rv.hi;
}
@

<<function [[_nev]](arm)>>=
int
_nev(Vlong lv, Vlong rv)
{
    return lv.lo != rv.lo || lv.hi != rv.hi;
}
@

<<function [[_ltv]](arm)>>=
int
_ltv(Vlong lv, Vlong rv)
{
    return (long)lv.hi < (long)rv.hi || 
        (lv.hi == rv.hi && lv.lo < rv.lo);
}
@

<<function [[_lev]](arm)>>=
int
_lev(Vlong lv, Vlong rv)
{
    return (long)lv.hi < (long)rv.hi || 
        (lv.hi == rv.hi && lv.lo <= rv.lo);
}
@

<<function [[_gtv]](arm)>>=
int
_gtv(Vlong lv, Vlong rv)
{
    return (long)lv.hi > (long)rv.hi || 
        (lv.hi == rv.hi && lv.lo > rv.lo);
}
@

<<function [[_gev]](arm)>>=
int
_gev(Vlong lv, Vlong rv)
{
    return (long)lv.hi > (long)rv.hi || 
        (lv.hi == rv.hi && lv.lo >= rv.lo);
}
@

<<function [[_lov]](arm)>>=
int
_lov(Vlong lv, Vlong rv)
{
    return lv.hi < rv.hi || 
        (lv.hi == rv.hi && lv.lo < rv.lo);
}
@

<<function [[_lsv]](arm)>>=
int
_lsv(Vlong lv, Vlong rv)
{
    return lv.hi < rv.hi || 
        (lv.hi == rv.hi && lv.lo <= rv.lo);
}
@

<<function [[_hiv]](arm)>>=
int
_hiv(Vlong lv, Vlong rv)
{
    return lv.hi > rv.hi || 
        (lv.hi == rv.hi && lv.lo > rv.lo);
}
@

<<function [[_hsv]](arm)>>=
int
_hsv(Vlong lv, Vlong rv)
{
    return lv.hi > rv.hi || 
        (lv.hi == rv.hi && lv.lo >= rv.lo);
}
@


%-------------------------------------------------------------

<<libc/arm/vlrt.c>>=
typedef unsigned long   ulong;
typedef unsigned int    uint;
typedef unsigned short  ushort;
typedef unsigned char   uchar;
typedef signed char schar;

<<macro [[SIGN]](arm)>>

typedef struct  Vlong   Vlong;
<<struct [[Vlong]](arm)>>

void    abort(void);

/* needed by profiler; can't be profiled */
#pragma profile off

<<function [[_addv]](arm)>>

<<function [[_subv]](arm)>>

#pragma profile on

<<function [[_d2v]](arm)>>

<<function [[_f2v]](arm)>>

<<function [[_v2d]](arm)>>

<<function [[_v2f]](arm)>>

/* too many of these are also needed by profiler; leave them out */
#pragma profile off

<<function [[dodiv]](arm)>>

<<function [[_divvu]](arm)>>

<<function [[_modvu]](arm)>>

<<function [[vneg]](arm)>>

<<function [[_divv]](arm)>>

<<function [[_modv]](arm)>>

<<function [[_rshav]](arm)>>

<<function [[_rshlv]](arm)>>

<<function [[_lshv]](arm)>>

<<function [[_andv]](arm)>>

<<function [[_orv]](arm)>>

<<function [[_xorv]](arm)>>

<<function [[_vpp]](arm)>>

<<function [[_vmm]](arm)>>

<<function [[_ppv]](arm)>>

<<function [[_mmv]](arm)>>

<<function [[_vasop]](arm)>>

<<function [[_p2v]](arm)>>

<<function [[_sl2v]](arm)>>


<<function [[_ul2v]](arm)>>

<<function [[_si2v]](arm)>>

<<function [[_ui2v]](arm)>>

<<function [[_sh2v]](arm)>>

<<function [[_uh2v]](arm)>>

<<function [[_sc2v]](arm)>>

<<function [[_uc2v]](arm)>>

<<function [[_v2sc]](arm)>>

<<function [[_v2uc]](arm)>>

<<function [[_v2sh]](arm)>>

<<function [[_v2uh]](arm)>>

<<function [[_v2sl]](arm)>>

<<function [[_v2ul]](arm)>>

<<function [[_v2si]](arm)>>

<<function [[_v2ui]](arm)>>

<<function [[_testv]](arm)>>

<<function [[_eqv]](arm)>>

<<function [[_nev]](arm)>>

<<function [[_ltv]](arm)>>

<<function [[_lev]](arm)>>

<<function [[_gtv]](arm)>>

<<function [[_gev]](arm)>>

<<function [[_lov]](arm)>>

<<function [[_lsv]](arm)>>

<<function [[_hiv]](arm)>>

<<function [[_hsv]](arm)>>
@



\section{[[libregexp/]]}

\subsection*{[[libregexp/regcomp.h]]}

<<libregexp/regcomp.h>>=
/*
 *  substitution list
 */
#define NSUBEXP 32
typedef struct Resublist	Resublist;
struct	Resublist
{
 Resub	m[NSUBEXP];
};

/*
 * Actions and Tokens (Reinst types)
 *
 *	02xx are operators, value == precedence
 *	03xx are tokens, i.e. operands for operators
 */
#define RUNE		0177
#define	OPERATOR	0200	/* Bitmask of all operators */
#define	START		0200	/* Start, used for marker on stack */
#define	RBRA		0201	/* Right bracket, ) */
#define	LBRA		0202	/* Left bracket, ( */
#define	OR		0203	/* Alternation, | */
#define	CAT		0204	/* Concatentation, implicit operator */
#define	STAR		0205	/* Closure, * */
#define	PLUS		0206	/* a+ == aa* */
#define	QUEST		0207	/* a? == a|nothing, i.e. 0 or 1 a's */
#define	ANY		0300	/* Any character except newline, . */
#define	ANYNL		0301	/* Any character including newline, . */
#define	NOP		0302	/* No operation, internal use only */
#define	BOL		0303	/* Beginning of line, ^ */
#define	EOL		0304	/* End of line, $ */
#define	CCLASS		0305	/* Character class, [] */
#define	NCCLASS		0306	/* Negated character class, [] */
#define	END		0377	/* Terminate: match found */

/*
 *  regexec execution lists
 */
#define LISTSIZE	10
#define BIGLISTSIZE	(25*LISTSIZE)
typedef struct Relist	Relist;
struct Relist
{
 Reinst*		inst;		/* Reinstruction of the thread */
 Resublist	se;		/* matched subexpressions in this thread */
};
typedef struct Reljunk	Reljunk;
struct	Reljunk
{
 Relist*	relist[2];
 Relist*	reliste[2];
 int	starttype;
 Rune	startchar;
 char*	starts;
 char*	eol;
 Rune*	rstarts;
 Rune*	reol;
};

extern Relist*	_renewthread(Relist*, Reinst*, int, Resublist*);
extern void	_renewmatch(Resub*, int, Resublist*);
extern Relist*	_renewemptythread(Relist*, Reinst*, int, char*);
extern Relist*	_rrenewemptythread(Relist*, Reinst*, int, Rune*);
@
%$

\subsection*{[[libregexp/regaux.c]]}

<<function [[_renewmatch]]>>=
/*
 *  save a new match in mp
 */
extern void
_renewmatch(Resub *mp, int ms, Resublist *sp)
{
    int i;

    if(mp==0 || ms<=0)
        return;
    if(mp[0].sp==0 || sp->m[0].sp<mp[0].sp ||
       (sp->m[0].sp==mp[0].sp && sp->m[0].ep>mp[0].ep)){
        for(i=0; i<ms && i<NSUBEXP; i++)
            mp[i] = sp->m[i];
        for(; i<ms; i++)
            mp[i].sp = mp[i].ep = 0;
    }
}
@

<<function [[_renewthread]]>>=
/*
 * Note optimization in _renewthread:
 * 	*lp must be pending when _renewthread called; if *l has been looked
 *		at already, the optimization is a bug.
 */
extern Relist*
_renewthread(Relist *lp,	/* _relist to add to */
    Reinst *ip,		/* instruction to add */
    int ms,
    Resublist *sep)		/* pointers to subexpressions */
{
    Relist *p;

    for(p=lp; p->inst; p++){
        if(p->inst == ip){
            if(sep->m[0].sp < p->se.m[0].sp){
                if(ms > 1)
                    p->se = *sep;
                else
                    p->se.m[0] = sep->m[0];
            }
            return 0;
        }
    }
    p->inst = ip;
    if(ms > 1)
        p->se = *sep;
    else
        p->se.m[0] = sep->m[0];
    (++p)->inst = 0;
    return p;
}
@

<<function [[_renewemptythread]]>>=
/*
 * same as renewthread, but called with
 * initial empty start pointer.
 */
extern Relist*
_renewemptythread(Relist *lp,	/* _relist to add to */
    Reinst *ip,		/* instruction to add */
    int ms,
    char *sp)		/* pointers to subexpressions */
{
    Relist *p;

    for(p=lp; p->inst; p++){
        if(p->inst == ip){
            if(sp < p->se.m[0].sp) {
                if(ms > 1)
                    memset(&p->se, 0, sizeof(p->se));
                p->se.m[0].sp = sp;
            }
            return 0;
        }
    }
    p->inst = ip;
    if(ms > 1)
        memset(&p->se, 0, sizeof(p->se));
    p->se.m[0].sp = sp;
    (++p)->inst = 0;
    return p;
}
@

<<function [[_rrenewemptythread]]>>=
extern Relist*
_rrenewemptythread(Relist *lp,	/* _relist to add to */
    Reinst *ip,		/* instruction to add */
    int ms,
    Rune *rsp)		/* pointers to subexpressions */
{
    Relist *p;

    for(p=lp; p->inst; p++){
        if(p->inst == ip){
            if(rsp < p->se.m[0].rsp) {
                if(ms > 1)
                    memset(&p->se, 0, sizeof(p->se));
                p->se.m[0].rsp = rsp;
            }
            return 0;
        }
    }
    p->inst = ip;
    if(ms > 1)
        memset(&p->se, 0, sizeof(p->se));
    p->se.m[0].rsp = rsp;
    (++p)->inst = 0;
    return p;
}
@


%-------------------------------------------------------------

<<libregexp/regaux.c>>=
#include <u.h>
#include <libc.h>
#include "regexp.h"
#include "regcomp.h"


<<function [[_renewmatch]]>>

<<function [[_renewthread]]>>

<<function [[_renewemptythread]]>>

<<function [[_rrenewemptythread]]>>
@


\subsection*{[[libregexp/regcomp.c]]}

<<constant [[TRUE]]>>=
#define	TRUE	1
@

<<constant [[FALSE]]>>=
#define	FALSE	0
@

<<struct [[Node]]>>=
/*
 * Parser Information
 */
typedef
struct Node
{
    Reinst*	first;
    Reinst*	last;
}Node;
@

<<global [[reprog]]>>=
/* max character classes per program is nelem(reprog->class) */
static Reprog	*reprog;
@

<<constant [[NCCRUNE]]>>=
/* max rune ranges per character class is nelem(classp->spans)/2 */
#define NCCRUNE	nelem(classp->spans)
@

<<constant [[NSTACK]]>>=
#define	NSTACK	20
@

<<global [[andstack]]>>=
static	Node	andstack[NSTACK];
@

<<global [[andp]]>>=
static	Node	*andp;
@

<<global [[atorstack]]>>=
static	int	atorstack[NSTACK];
@

<<global [[atorp]]>>=
static	int*	atorp;
@

<<global [[cursubid]]>>=
static	int	cursubid;		/* id of current subexpression */
@

<<global [[subidstack]]>>=
static	int	subidstack[NSTACK];	/* parallel to atorstack */
@

<<global [[subidp]]>>=
static	int*	subidp;
@

<<global [[lastwasand]]>>=
static	int	lastwasand;	/* Last token was operand */
@

<<global [[nbra]]>>=
static	int	nbra;
@

<<global [[exprp]]>>=
static	char*	exprp;		/* pointer to next character in source expression */
@

<<global [[lexdone]]>>=
static	int	lexdone;
@

<<global [[nclass]]>>=
static	int	nclass;
@

<<global [[classp]]>>=
static	Reclass*classp;
@

<<global [[freep]]>>=
static	Reinst*	freep;
@

<<global [[errors]]>>=
static	int	errors;
@

<<global [[yyrune]]>>=
static	Rune	yyrune;		/* last lex'd rune */
@

<<global [[yyclassp]]>>=
static	Reclass*yyclassp;	/* last lex'd class */
@

<<global [[regkaboom]]>>=
static jmp_buf regkaboom;
@

<<function [[rcerror]]>>=
static	void
rcerror(char *s)
{
    errors++;
    regerror(s);
    longjmp(regkaboom, 1);
}
@

<<function [[newinst]]>>=
static	Reinst*
newinst(int t)
{
    freep->type = t;
    freep->left = 0;
    freep->right = 0;
    return freep++;
}
@

<<function [[operand]]>>=
static	void
operand(int t)
{
    Reinst *i;

    if(lastwasand)
        operator(CAT);	/* catenate is implicit */
    i = newinst(t);

    if(t == CCLASS || t == NCCLASS)
        i->cp = yyclassp;
    if(t == RUNE)
        i->r = yyrune;

    pushand(i, i);
    lastwasand = TRUE;
}
@

<<function [[operator]]>>=
static	void
operator(int t)
{
    if(t==RBRA && --nbra<0)
        rcerror("unmatched right paren");
    if(t==LBRA){
        if(++cursubid >= NSUBEXP)
            rcerror ("too many subexpressions");
        nbra++;
        if(lastwasand)
            operator(CAT);
    } else
        evaluntil(t);
    if(t != RBRA)
        pushator(t);
    lastwasand = FALSE;
    if(t==STAR || t==QUEST || t==PLUS || t==RBRA)
        lastwasand = TRUE;	/* these look like operands */
}
@

<<function [[regerr2]]>>=
static	void
regerr2(char *s, int c)
{
    char buf[100];
    char *cp = buf;
    while(*s)
        *cp++ = *s++;
    *cp++ = c;
    *cp = '\0'; 
    rcerror(buf);
}
@

<<function [[cant]]>>=
static	void
cant(char *s)
{
    char buf[100];
    strcpy(buf, "can't happen: ");
    strcat(buf, s);
    rcerror(buf);
}
@

<<function [[pushand]]>>=
static	void
pushand(Reinst *f, Reinst *l)
{
    if(andp >= &andstack[NSTACK])
        cant("operand stack overflow");
    andp->first = f;
    andp->last = l;
    andp++;
}
@

<<function [[pushator]]>>=
static	void
pushator(int t)
{
    if(atorp >= &atorstack[NSTACK])
        cant("operator stack overflow");
    *atorp++ = t;
    *subidp++ = cursubid;
}
@

<<function [[popand]]>>=
static	Node*
popand(int op)
{
    Reinst *inst;

    if(andp <= &andstack[0]){
        regerr2("missing operand for ", op);
        inst = newinst(NOP);
        pushand(inst,inst);
    }
    return --andp;
}
@

<<function [[popator]]>>=
static	int
popator(void)
{
    if(atorp <= &atorstack[0])
        cant("operator stack underflow");
    --subidp;
    return *--atorp;
}
@

<<function [[evaluntil]]>>=
static	void
evaluntil(int pri)
{
    Node *op1, *op2;
    Reinst *inst1, *inst2;

    while(pri==RBRA || atorp[-1]>=pri){
        switch(popator()){
        default:
            rcerror("unknown operator in evaluntil");
            break;
        case LBRA:		/* must have been RBRA */
            op1 = popand('(');
            inst2 = newinst(RBRA);
            inst2->subid = *subidp;
            op1->last->next = inst2;
            inst1 = newinst(LBRA);
            inst1->subid = *subidp;
            inst1->next = op1->first;
            pushand(inst1, inst2);
            return;
        case OR:
            op2 = popand('|');
            op1 = popand('|');
            inst2 = newinst(NOP);
            op2->last->next = inst2;
            op1->last->next = inst2;
            inst1 = newinst(OR);
            inst1->right = op1->first;
            inst1->left = op2->first;
            pushand(inst1, inst2);
            break;
        case CAT:
            op2 = popand(0);
            op1 = popand(0);
            op1->last->next = op2->first;
            pushand(op1->first, op2->last);
            break;
        case STAR:
            op2 = popand('*');
            inst1 = newinst(OR);
            op2->last->next = inst1;
            inst1->right = op2->first;
            pushand(inst1, inst1);
            break;
        case PLUS:
            op2 = popand('+');
            inst1 = newinst(OR);
            op2->last->next = inst1;
            inst1->right = op2->first;
            pushand(op2->first, inst1);
            break;
        case QUEST:
            op2 = popand('?');
            inst1 = newinst(OR);
            inst2 = newinst(NOP);
            inst1->left = inst2;
            inst1->right = op2->first;
            op2->last->next = inst2;
            pushand(inst1, inst2);
            break;
        }
    }
}
@

<<function [[optimize]]>>=
static	Reprog*
optimize(Reprog *pp)
{
    Reinst *inst, *target;
    int size;
    Reprog *npp;
    Reclass *cl;
    int diff;

    /*
     *  get rid of NOOP chains
     */
    for(inst=pp->firstinst; inst->type!=END; inst++){
        target = inst->next;
        while(target->type == NOP)
            target = target->next;
        inst->next = target;
    }

    /*
     *  The original allocation is for an area larger than
     *  necessary.  Reallocate to the actual space used
     *  and then relocate the code.
     */
    size = sizeof(Reprog) + (freep - pp->firstinst)*sizeof(Reinst);
    npp = realloc(pp, size);
    if(npp==0 || npp==pp)
        return pp;
    diff = (char *)npp - (char *)pp;
    freep = (Reinst *)((char *)freep + diff);
    for(inst=npp->firstinst; inst<freep; inst++){
        switch(inst->type){
        case OR:
        case STAR:
        case PLUS:
        case QUEST:
            *(char **)&inst->right += diff;
            break;
        case CCLASS:
        case NCCLASS:
            *(char **)&inst->right += diff;
            cl = inst->cp;
            *(char **)&cl->end += diff;
            break;
        }
        *(char **)&inst->left += diff;
    }
    *(char **)&npp->startinst += diff;
    return npp;
}
@

<<function [[dumpstack]]>>=
static	void
dumpstack(void){
    Node *stk;
    int *ip;

    print("operators\n");
    for(ip=atorstack; ip<atorp; ip++)
        print("0%o\n", *ip);
    print("operands\n");
    for(stk=andstack; stk<andp; stk++)
        print("0%o\t0%o\n", stk->first->type, stk->last->type);
}
@

<<function [[dump]]>>=
static	void
dump(Reprog *pp)
{
    Reinst *l;
    Rune *p;

    l = pp->firstinst;
    do{
        print("%d:\t0%o\t%d\t%d", l-pp->firstinst, l->type,
            l->left-pp->firstinst, l->right-pp->firstinst);
        if(l->type == RUNE)
            print("\t%C\n", l->r);
        else if(l->type == CCLASS || l->type == NCCLASS){
            print("\t[");
            if(l->type == NCCLASS)
                print("^");
            for(p = l->cp->spans; p < l->cp->end; p += 2)
                if(p[0] == p[1])
                    print("%C", p[0]);
                else
                    print("%C-%C", p[0], p[1]);
            print("]\n");
        } else
            print("\n");
    }while(l++->type);
}
@

<<function [[newclass]]>>=
static	Reclass*
newclass(void)
{
    if(nclass >= nelem(reprog->class))
        rcerror("too many character classes; increase Reprog.class size");
    return &(classp[nclass++]);
}
@

<<function [[nextc]]>>=
static	int
nextc(Rune *rp)
{
    if(lexdone){
        *rp = 0;
        return 1;
    }
    exprp += chartorune(rp, exprp);
    if(*rp == L'\\'){
        exprp += chartorune(rp, exprp);
        return 1;
    }
    if(*rp == 0)
        lexdone = 1;
    return 0;
}
@

<<function [[lex]]>>=
static	int
lex(int literal, int dot_type)
{
    int quoted;

    quoted = nextc(&yyrune);
    if(literal || quoted){
        if(yyrune == 0)
            return END;
        return RUNE;
    }

    switch(yyrune){
    case 0:
        return END;
    case L'*':
        return STAR;
    case L'?':
        return QUEST;
    case L'+':
        return PLUS;
    case L'|':
        return OR;
    case L'.':
        return dot_type;
    case L'(':
        return LBRA;
    case L')':
        return RBRA;
    case L'^':
        return BOL;
    case L'$':
        return EOL;
    case L'[':
        return bldcclass();
    }
    return RUNE;
}
@
%$

<<function [[bldcclass]]>>=
static int
bldcclass(void)
{
    int type;
    Rune r[NCCRUNE];
    Rune *p, *ep, *np;
    Rune rune;
    int quoted;

    /* we have already seen the '[' */
    type = CCLASS;
    yyclassp = newclass();

    /* look ahead for negation */
    /* SPECIAL CASE!!! negated classes don't match \n */
    ep = r;
    quoted = nextc(&rune);
    if(!quoted && rune == L'^'){
        type = NCCLASS;
        quoted = nextc(&rune);
        *ep++ = L'\n';
        *ep++ = L'\n';
    }

    /* parse class into a set of spans */
    while(ep < &r[NCCRUNE-1]){
        if(rune == 0){
            rcerror("malformed '[]'");
            return 0;
        }
        if(!quoted && rune == L']')
            break;
        if(!quoted && rune == L'-'){
            if(ep == r){
                rcerror("malformed '[]'");
                return 0;
            }
            quoted = nextc(&rune);
            if((!quoted && rune == L']') || rune == 0){
                rcerror("malformed '[]'");
                return 0;
            }
            *(ep-1) = rune;
        } else {
            *ep++ = rune;
            *ep++ = rune;
        }
        quoted = nextc(&rune);
    }
    if(ep >= &r[NCCRUNE-1]) {
        rcerror("char class too large; increase Reclass.spans size");
        return 0;
    }

    /* sort on span start */
    for(p = r; p < ep; p += 2){
        for(np = p; np < ep; np += 2)
            if(*np < *p){
                rune = np[0];
                np[0] = p[0];
                p[0] = rune;
                rune = np[1];
                np[1] = p[1];
                p[1] = rune;
            }
    }

    /* merge spans */
    np = yyclassp->spans;
    p = r;
    if(r == ep)
        yyclassp->end = np;
    else {
        np[0] = *p++;
        np[1] = *p++;
        for(; p < ep; p += 2)
            /* overlapping or adjacent ranges? */
            if(p[0] <= np[1] + 1){
                if(p[1] >= np[1])
                    np[1] = p[1];	/* coalesce */
            } else {
                np += 2;
                np[0] = p[0];
                np[1] = p[1];
            }
        yyclassp->end = np+2;
    }

    return type;
}
@

<<function [[regcomp1]]>>=
static	Reprog*
regcomp1(char *s, int literal, int dot_type)
{
    int token;
    Reprog *pp;

    /* get memory for the program */
    pp = malloc(sizeof(Reprog) + 6*sizeof(Reinst)*strlen(s));
    if(pp == 0){
        regerror("out of memory");
        return 0;
    }
    freep = pp->firstinst;
    classp = pp->class;
    errors = 0;

    if(setjmp(regkaboom))
        goto out;

    /* go compile the sucker */
    lexdone = 0;
    exprp = s;
    nclass = 0;
    nbra = 0;
    atorp = atorstack;
    andp = andstack;
    subidp = subidstack;
    lastwasand = FALSE;
    cursubid = 0;

    /* Start with a low priority operator to prime parser */
    pushator(START-1);
    while((token = lex(literal, dot_type)) != END){
        if((token&0300) == OPERATOR)
            operator(token);
        else
            operand(token);
    }

    /* Close with a low priority operator */
    evaluntil(START);

    /* Force END */
    operand(END);
    evaluntil(START);
#ifdef DEBUG
    dumpstack();
#endif
    if(nbra)
        rcerror("unmatched left paren");
    --andp;	/* points to first and only operand */
    pp->startinst = andp->first;
#ifdef DEBUG
    dump(pp);
#endif
    pp = optimize(pp);
#ifdef DEBUG
    print("start: %d\n", andp->first-pp->firstinst);
    dump(pp);
#endif
out:
    if(errors){
        free(pp);
        pp = 0;
    }
    return pp;
}
@

<<function [[regcomp]]>>=
extern	Reprog*
regcomp(char *s)
{
    return regcomp1(s, 0, ANY);
}
@

<<function [[regcomplit]]>>=
extern	Reprog*
regcomplit(char *s)
{
    return regcomp1(s, 1, ANY);
}
@

<<function [[regcompnl]]>>=
extern	Reprog*
regcompnl(char *s)
{
    return regcomp1(s, 0, ANYNL);
}
@


%-------------------------------------------------------------

<<libregexp/regcomp.c>>=
#include <u.h>
#include <libc.h>
#include "regexp.h"
#include "regcomp.h"

<<constant [[TRUE]]>>
<<constant [[FALSE]]>>

<<struct [[Node]]>>

<<global [[reprog]]>>

<<constant [[NCCRUNE]]>>

<<constant [[NSTACK]]>>
<<global [[andstack]]>>
<<global [[andp]]>>
<<global [[atorstack]]>>
<<global [[atorp]]>>
<<global [[cursubid]]>>
<<global [[subidstack]]>>
<<global [[subidp]]>>
<<global [[lastwasand]]>>
<<global [[nbra]]>>
<<global [[exprp]]>>
<<global [[lexdone]]>>
<<global [[nclass]]>>
<<global [[classp]]>>
<<global [[freep]]>>
<<global [[errors]]>>
<<global [[yyrune]]>>
<<global [[yyclassp]]>>

/* predeclared crap */
static	void	operator(int);
static	void	pushand(Reinst*, Reinst*);
static	void	pushator(int);
static	void	evaluntil(int);
static	int	bldcclass(void);

<<global [[regkaboom]]>>

<<function [[rcerror]]>>

<<function [[newinst]]>>

<<function [[operand]]>>

<<function [[operator]]>>

<<function [[regerr2]]>>

<<function [[cant]]>>

<<function [[pushand]]>>

<<function [[pushator]]>>

<<function [[popand]]>>

<<function [[popator]]>>

<<function [[evaluntil]]>>

<<function [[optimize]]>>

#ifdef	DEBUG
<<function [[dumpstack]]>>

<<function [[dump]]>>
#endif

<<function [[newclass]]>>

<<function [[nextc]]>>

<<function [[lex]]>>

<<function [[bldcclass]]>>

<<function [[regcomp1]]>>

<<function [[regcomp]]>>

<<function [[regcomplit]]>>

<<function [[regcompnl]]>>
@


\subsection*{[[libregexp/regerror.c]]}

<<function [[regerror]]>>=
void
regerror(char *s)
{
    char buf[132];

    strcpy(buf, "regerror: ");
    strcat(buf, s);
    strcat(buf, "\n");
    write(2, buf, strlen(buf));
    exits("regerr");
}
@


%-------------------------------------------------------------

<<libregexp/regerror.c>>=
#include <u.h>
#include <libc.h>
#include "regexp.h"

<<function [[regerror]]>>
@


\subsection*{[[libregexp/regexec.c]]}

<<function [[regexec1]]>>=
/*
 *  return	0 if no match
 *		>0 if a match
 *		<0 if we ran out of _relist space
 */
static int
regexec1(Reprog *progp,	/* program to run */
    char *bol,	/* string to run machine on */
    Resub *mp,	/* subexpression elements */
    int ms,		/* number of elements at mp */
    Reljunk *j
)
{
    int flag=0;
    Reinst *inst;
    Relist *tlp;
    char *s;
    int i, checkstart;
    Rune r, *rp, *ep;
    int n;
    Relist* tl;		/* This list, next list */
    Relist* nl;
    Relist* tle;		/* ends of this and next list */
    Relist* nle;
    int match;
    char *p;

    match = 0;
    checkstart = j->starttype;
    if(mp)
        for(i=0; i<ms; i++) {
            mp[i].sp = 0;
            mp[i].ep = 0;
        }
    j->relist[0][0].inst = 0;
    j->relist[1][0].inst = 0;

    /* Execute machine once for each character, including terminal NUL */
    s = j->starts;
    do{
        /* fast check for first char */
        if(checkstart) {
            switch(j->starttype) {
            case RUNE:
                p = utfrune(s, j->startchar);
                if(p == 0 || s == j->eol)
                    return match;
                s = p;
                break;
            case BOL:
                if(s == bol)
                    break;
                p = utfrune(s, '\n');
                if(p == 0 || s == j->eol)
                    return match;
                s = p+1;
                break;
            }
        }
        r = *(uchar*)s;
        if(r < Runeself)
            n = 1;
        else
            n = chartorune(&r, s);

        /* switch run lists */
        tl = j->relist[flag];
        tle = j->reliste[flag];
        nl = j->relist[flag^=1];
        nle = j->reliste[flag];
        nl->inst = 0;

        /* Add first instruction to current list */
        if(match == 0)
            _renewemptythread(tl, progp->startinst, ms, s);

        /* Execute machine until current list is empty */
        for(tlp=tl; tlp->inst; tlp++){	/* assignment = */
            for(inst = tlp->inst; ; inst = inst->next){
                switch(inst->type){
                case RUNE:	/* regular character */
                    if(inst->r == r){
                        if(_renewthread(nl, inst->next, ms, &tlp->se)==nle)
                            return -1;
                    }
                    break;
                case LBRA:
                    tlp->se.m[inst->subid].sp = s;
                    continue;
                case RBRA:
                    tlp->se.m[inst->subid].ep = s;
                    continue;
                case ANY:
                    if(r != '\n')
                        if(_renewthread(nl, inst->next, ms, &tlp->se)==nle)
                            return -1;
                    break;
                case ANYNL:
                    if(_renewthread(nl, inst->next, ms, &tlp->se)==nle)
                            return -1;
                    break;
                case BOL:
                    if(s == bol || *(s-1) == '\n')
                        continue;
                    break;
                case EOL:
                    if(s == j->eol || r == 0 || r == '\n')
                        continue;
                    break;
                case CCLASS:
                    ep = inst->cp->end;
                    for(rp = inst->cp->spans; rp < ep; rp += 2)
                        if(r >= rp[0] && r <= rp[1]){
                            if(_renewthread(nl, inst->next, ms, &tlp->se)==nle)
                                return -1;
                            break;
                        }
                    break;
                case NCCLASS:
                    ep = inst->cp->end;
                    for(rp = inst->cp->spans; rp < ep; rp += 2)
                        if(r >= rp[0] && r <= rp[1])
                            break;
                    if(rp == ep)
                        if(_renewthread(nl, inst->next, ms, &tlp->se)==nle)
                            return -1;
                    break;
                case OR:
                    /* evaluate right choice later */
                    if(_renewthread(tlp, inst->right, ms, &tlp->se) == tle)
                        return -1;
                    /* efficiency: advance and re-evaluate */
                    continue;
                case END:	/* Match! */
                    match = 1;
                    tlp->se.m[0].ep = s;
                    if(mp != 0)
                        _renewmatch(mp, ms, &tlp->se);
                    break;
                }
                break;
            }
        }
        if(s == j->eol)
            break;
        checkstart = j->starttype && nl->inst==0;
        s += n;
    }while(r);
    return match;
}
@

<<function [[regexec2]]>>=
static int
regexec2(Reprog *progp,	/* program to run */
    char *bol,	/* string to run machine on */
    Resub *mp,	/* subexpression elements */
    int ms,		/* number of elements at mp */
    Reljunk *j
)
{
    int rv;
    Relist *relist0, *relist1;

    /* mark space */
    relist0 = malloc(BIGLISTSIZE*sizeof(Relist));
    if(relist0 == nil)
        return -1;
    relist1 = malloc(BIGLISTSIZE*sizeof(Relist));
    if(relist1 == nil){
        free(relist1);
        return -1;
    }
    j->relist[0] = relist0;
    j->relist[1] = relist1;
    j->reliste[0] = relist0 + BIGLISTSIZE - 2;
    j->reliste[1] = relist1 + BIGLISTSIZE - 2;

    rv = regexec1(progp, bol, mp, ms, j);
    free(relist0);
    free(relist1);
    return rv;
}
@

<<function [[regexec]]>>=
extern int
regexec(Reprog *progp,	/* program to run */
    char *bol,	/* string to run machine on */
    Resub *mp,	/* subexpression elements */
    int ms)		/* number of elements at mp */
{
    Reljunk j;
    Relist relist0[LISTSIZE], relist1[LISTSIZE];
    int rv;

    /*
   *  use user-specified starting/ending location if specified
     */
    j.starts = bol;
    j.eol = 0;
    if(mp && ms>0){
        if(mp->sp)
            j.starts = mp->sp;
        if(mp->ep)
            j.eol = mp->ep;
    }
    j.starttype = 0;
    j.startchar = 0;
    if(progp->startinst->type == RUNE && progp->startinst->r < Runeself) {
        j.starttype = RUNE;
        j.startchar = progp->startinst->r;
    }
    if(progp->startinst->type == BOL)
        j.starttype = BOL;

    /* mark space */
    j.relist[0] = relist0;
    j.relist[1] = relist1;
    j.reliste[0] = relist0 + nelem(relist0) - 2;
    j.reliste[1] = relist1 + nelem(relist1) - 2;

    rv = regexec1(progp, bol, mp, ms, &j);
    if(rv >= 0)
        return rv;
    rv = regexec2(progp, bol, mp, ms, &j);
    if(rv >= 0)
        return rv;
    return -1;
}
@


%-------------------------------------------------------------

<<libregexp/regexec.c>>=
#include <u.h>
#include <libc.h>
#include "regexp.h"
#include "regcomp.h"


<<function [[regexec1]]>>

<<function [[regexec2]]>>

<<function [[regexec]]>>
@


\subsection*{[[libregexp/regsub.c]]}

<<function [[regsub]]>>=
/* substitute into one string using the matches from the last regexec() */
extern	void
regsub(char *sp,	/* source string */
    char *dp,	/* destination string */
    int dlen,
    Resub *mp,	/* subexpression elements */
    int ms)		/* number of elements pointed to by mp */
{
    char *ssp, *ep;
    int i;

    ep = dp+dlen-1;
    while(*sp != '\0'){
        if(*sp == '\\'){
            switch(*++sp){
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
                i = *sp-'0';
                if(mp!=0 && mp[i].sp != 0 && ms>i)
                    for(ssp = mp[i].sp;
                         ssp < mp[i].ep;
                         ssp++)
                        if(dp < ep)
                            *dp++ = *ssp;
                break;
            case '\\':
                if(dp < ep)
                    *dp++ = '\\';
                break;
            case '\0':
                sp--;
                break;
            default:
                if(dp < ep)
                    *dp++ = *sp;
                break;
            }
        }else if(*sp == '&'){
            if(mp!=0 && mp[0].sp != 0 && ms>0)
                for(ssp = mp[0].sp;
                     ssp < mp[0].ep; ssp++)
                    if(dp < ep)
                        *dp++ = *ssp;
        }else{
            if(dp < ep)
                *dp++ = *sp;
        }
        sp++;
    }
    *dp = '\0';
}
@


%-------------------------------------------------------------

<<libregexp/regsub.c>>=
#include <u.h>
#include <libc.h>
#include "regexp.h"

<<function [[regsub]]>>
@


\subsection*{[[libregexp/rregexec.c]]}

<<function [[rregexec1]]>>=
/*
 *  return	0 if no match
 *		>0 if a match
 *		<0 if we ran out of _relist space
 */
static int
rregexec1(Reprog *progp,	/* program to run */
    Rune *bol,		/* string to run machine on */
    Resub *mp,		/* subexpression elements */
    int ms,			/* number of elements at mp */
    Reljunk *j)
{
    int flag=0;
    Reinst *inst;
    Relist *tlp;
    Rune *s;
    int i, checkstart;
    Rune r, *rp, *ep;
    Relist* tl;		/* This list, next list */
    Relist* nl;
    Relist* tle;		/* ends of this and next list */
    Relist* nle;
    int match;
    Rune *p;

    match = 0;
    checkstart = j->startchar;
    if(mp)
        for(i=0; i<ms; i++) {
            mp[i].rsp = 0;
            mp[i].rep = 0;
        }
    j->relist[0][0].inst = 0;
    j->relist[1][0].inst = 0;

    /* Execute machine once for each character, including terminal NUL */
    s = j->rstarts;
    do{
        /* fast check for first char */
        if(checkstart) {
            switch(j->starttype) {
            case RUNE:
                p = runestrchr(s, j->startchar);
                if(p == 0 || s == j->reol)
                    return match;
                s = p;
                break;
            case BOL:
                if(s == bol)
                    break;
                p = runestrchr(s, '\n');
                if(p == 0 || s == j->reol)
                    return match;
                s = p+1;
                break;
            }
        }

        r = *s;

        /* switch run lists */
        tl = j->relist[flag];
        tle = j->reliste[flag];
        nl = j->relist[flag^=1];
        nle = j->reliste[flag];
        nl->inst = 0;

        /* Add first instruction to current list */
        _rrenewemptythread(tl, progp->startinst, ms, s);

        /* Execute machine until current list is empty */
        for(tlp=tl; tlp->inst; tlp++){
            for(inst=tlp->inst; ; inst = inst->next){
                switch(inst->type){
                case RUNE:	/* regular character */
                    if(inst->r == r)
                        if(_renewthread(nl, inst->next, ms, &tlp->se)==nle)
                            return -1;
                    break;
                case LBRA:
                    tlp->se.m[inst->subid].rsp = s;
                    continue;
                case RBRA:
                    tlp->se.m[inst->subid].rep = s;
                    continue;
                case ANY:
                    if(r != '\n')
                        if(_renewthread(nl, inst->next, ms, &tlp->se)==nle)
                            return -1;
                    break;
                case ANYNL:
                    if(_renewthread(nl, inst->next, ms, &tlp->se)==nle)
                            return -1;
                    break;
                case BOL:
                    if(s == bol || *(s-1) == '\n')
                        continue;
                    break;
                case EOL:
                    if(s == j->reol || r == 0 || r == '\n')
                        continue;
                    break;
                case CCLASS:
                    ep = inst->cp->end;
                    for(rp = inst->cp->spans; rp < ep; rp += 2)
                        if(r >= rp[0] && r <= rp[1]){
                            if(_renewthread(nl, inst->next, ms, &tlp->se)==nle)
                                return -1;
                            break;
                        }
                    break;
                case NCCLASS:
                    ep = inst->cp->end;
                    for(rp = inst->cp->spans; rp < ep; rp += 2)
                        if(r >= rp[0] && r <= rp[1])
                            break;
                    if(rp == ep)
                        if(_renewthread(nl, inst->next, ms, &tlp->se)==nle)
                            return -1;
                    break;
                case OR:
                    /* evaluate right choice later */
                    if(_renewthread(tlp, inst->right, ms, &tlp->se) == tle)
                        return -1;
                    /* efficiency: advance and re-evaluate */
                    continue;
                case END:	/* Match! */
                    match = 1;
                    tlp->se.m[0].rep = s;
                    if(mp != 0)
                        _renewmatch(mp, ms, &tlp->se);
                    break;
                }
                break;
            }
        }
        if(s == j->reol)
            break;
        checkstart = j->startchar && nl->inst==0;
        s++;
    }while(r);
    return match;
}
@

<<function [[rregexec2]]>>=
static int
rregexec2(Reprog *progp,	/* program to run */
    Rune *bol,	/* string to run machine on */
    Resub *mp,	/* subexpression elements */
    int ms,		/* number of elements at mp */
    Reljunk *j
)
{
    Relist relist0[5*LISTSIZE], relist1[5*LISTSIZE];

    /* mark space */
    j->relist[0] = relist0;
    j->relist[1] = relist1;
    j->reliste[0] = relist0 + nelem(relist0) - 2;
    j->reliste[1] = relist1 + nelem(relist1) - 2;

    return rregexec1(progp, bol, mp, ms, j);
}
@

<<function [[rregexec]]>>=
extern int
rregexec(Reprog *progp,	/* program to run */
    Rune *bol,	/* string to run machine on */
    Resub *mp,	/* subexpression elements */
    int ms)		/* number of elements at mp */
{
    Reljunk j;
    Relist relist0[LISTSIZE], relist1[LISTSIZE];
    int rv;

    /*
   *  use user-specified starting/ending location if specified
     */
    j.rstarts = bol;
    j.reol = 0;
    if(mp && ms>0){
        if(mp->sp)
            j.rstarts = mp->rsp;
        if(mp->ep)
            j.reol = mp->rep;
    }
    j.starttype = 0;
    j.startchar = 0;
    if(progp->startinst->type == RUNE && progp->startinst->r < Runeself) {
        j.starttype = RUNE;
        j.startchar = progp->startinst->r;
    }
    if(progp->startinst->type == BOL)
        j.starttype = BOL;

    /* mark space */
    j.relist[0] = relist0;
    j.relist[1] = relist1;
    j.reliste[0] = relist0 + nelem(relist0) - 2;
    j.reliste[1] = relist1 + nelem(relist1) - 2;

    rv = rregexec1(progp, bol, mp, ms, &j);
    if(rv >= 0)
        return rv;
    rv = rregexec2(progp, bol, mp, ms, &j);
    if(rv >= 0)
        return rv;
    return -1;
}
@


%-------------------------------------------------------------

<<libregexp/rregexec.c>>=
#include <u.h>
#include <libc.h>
#include "regexp.h"
#include "regcomp.h"

<<function [[rregexec1]]>>

<<function [[rregexec2]]>>

<<function [[rregexec]]>>
@


\subsection*{[[libregexp/rregsub.c]]}

<<function [[rregsub]]>>=
/* substitute into one string using the matches from the last regexec() */
extern	void
rregsub(Rune *sp,	/* source string */
    Rune *dp,	/* destination string */
    int dlen,
    Resub *mp,	/* subexpression elements */
    int ms)		/* number of elements pointed to by mp */
{
    Rune *ssp, *ep;
    int i;

    ep = dp+(dlen/sizeof(Rune))-1;
    while(*sp != '\0'){
        if(*sp == '\\'){
            switch(*++sp){
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
                i = *sp-'0';
                if(mp[i].rsp != 0 && mp!=0 && ms>i)
                    for(ssp = mp[i].rsp;
                         ssp < mp[i].rep;
                         ssp++)
                        if(dp < ep)
                            *dp++ = *ssp;
                break;
            case '\\':
                if(dp < ep)
                    *dp++ = '\\';
                break;
            case '\0':
                sp--;
                break;
            default:
                if(dp < ep)
                    *dp++ = *sp;
                break;
            }
        }else if(*sp == '&'){				
            if(mp[0].rsp != 0 && mp!=0 && ms>0)
            if(mp[0].rsp != 0)
                for(ssp = mp[0].rsp;
                     ssp < mp[0].rep; ssp++)
                    if(dp < ep)
                        *dp++ = *ssp;
        }else{
            if(dp < ep)
                *dp++ = *sp;
        }
        sp++;
    }
    *dp = '\0';
}
@


%-------------------------------------------------------------

<<libregexp/rregsub.c>>=
#include <u.h>
#include <libc.h>
#include "regexp.h"

<<function [[rregsub]]>>
@


\section{[[lib_core/libthread/arm]]}

<<libthread/arm.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

/* first argument goes in a register; simplest just to ignore it */
static void
launcherarm(int, void (*f)(void *arg), void *arg)
{
	(*f)(arg);
	threadexits(nil);
}

void
_threadinitstack(Thread *t, void (*f)(void*), void *arg)
{
	ulong *tos;

	tos = (ulong*)&t->stk[t->stksize&~7];
	*--tos = (ulong)arg;
	*--tos = (ulong)f;
	*--tos = 0;	/* first arg to launchermips */
	*--tos = 0;	/* place to store return PC */

	t->sched[JMPBUFPC] = (ulong)launcherarm+JMPBUFDPC;
	t->sched[JMPBUFSP] = (ulong)tos;
}
@

\section{[[lib_core/libthread/x86]]}

\subsection*{[[libthread/386.c]]}

%-------------------------------------------------------------

<<libthread/386.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>

#include "threadimpl.h"

<<function [[launcher386]]>>

<<function [[_threadinitstack]]>>

@


\section{[[lib_core/libthread/]]}

\subsection*{[[libthread/ref.c]]}

%-------------------------------------------------------------

<<libthread/ref.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<function [[incref]]>>

<<function [[decref]]>>
@


\subsection*{[[libthread/threadimpl.h]]}

<<enum [[_anon_ (libthread/threadimpl.h)]]>>=
enum
{
<<constant [[RENDHASH]]>>
<<constant [[Printsize]]>>
<<constant [[NPRIV]]>>
};
@

%-------------------------------------------------------------


<<libthread/threadimpl.h>>=
/* 
 * Some notes on locking:
 *
 *  All the locking woes come from implementing
 *  threadinterrupt (and threadkill).
 *
 *  _threadgetproc()->thread is always a live pointer.
 *  p->threads, p->ready, and _threadrgrp also contain
 *  live thread pointers.  These may only be consulted
 *  while holding p->lock or _threadrgrp.lock; in procs
 *  other than p, the pointers are only guaranteed to be live
 *  while the lock is still being held.
 *
 *  Thread structures can only be freed by the proc
 *  they belong to.  Threads marked with t->inrendez
 *  need to be extracted from the _threadrgrp before
 *  being freed.
 *
 *  _threadrgrp.lock cannot be acquired while holding p->lock.
 */

typedef struct Pqueue   Pqueue;
typedef struct Rgrp Rgrp;
typedef struct Tqueue   Tqueue;
typedef struct Thread   Thread;
typedef struct Execargs Execargs;
typedef struct Proc Proc;


/* must match list in sched.c */
<<enum [[state]]>>
typedef enum state State;
    
<<enum [[chanstate]]>>
typedef enum chanstate Chanstate;

<<enum [[_anon_ (libthread/threadimpl.h)]]>>

<<struct [[Rgrp]]>>

<<struct [[Tqueue]]>>

<<struct [[Thread]]>>

<<struct [[Execargs]]>>

<<struct [[Proc]]>>

<<struct [[Pqueue]]>>

<<struct [[Ioproc]]>>

void    _freeproc(Proc*);
void    _freethread(Thread*);
Proc*   _newproc(void(*)(void*), void*, uint, char*, int, int);
int _procsplhi(void);
void    _procsplx(int);
void    _sched(void);
int _schedexec(Execargs*);
void    _schedexecwait(void);
void    _schedexit(Proc*);
int _schedfork(Proc*);
void    _schedinit(void*);
void    _systhreadinit(void);
void    _threadassert(char*);
void    _threadbreakrendez(void);
void    _threaddebug(ulong, char*, ...);
void    _threadexitsall(char*);
void    _threadflagrendez(Thread*);
Proc*   _threadgetproc(void);
void    _threadsetproc(Proc*);
void    _threadinitstack(Thread*, void(*)(void*), void*);
void*   _threadmalloc(long, int);
void    _threadnote(void*, char*);
void    _threadready(Thread*);
void*   _threadrendezvous(void*, void*);
void    _threadsignal(void);
void    _threadsysfatal(char*, va_list);
void**  _workerdata(void);
void    _xinc(long*);
long    _xdec(long*);

extern int      _threaddebuglevel;
extern char*        _threadexitsallstatus;
extern Pqueue       _threadpq;
extern Channel*     _threadwaitchan;
extern Rgrp     _threadrgrp;

<<constant [[DBGAPPL]]>>
<<constant [[DBGSCHED]]>>
<<constant [[DBGCHAN]]>>
<<constant [[DBGREND]]>>
<<constant [[DBGNOTE]]>>
<<constant [[DBGEXEC]]>>

<<function [[ioproc_arg]]>>
@


\subsection*{[[libthread/xincarm.c]]}

%-------------------------------------------------------------

<<libthread/xincarm.c>>=
#include "xincport.h"
@


\subsection*{[[libthread/xincport.h]]}

%-------------------------------------------------------------

<<libthread/xincport.h>>=
#include <u.h>
#include <libc.h>
#include <thread.h>

<<global [[xincport_lock]]>>

<<function [[_xinc]]>>

<<function [[_xdec]]>>
@


\subsection*{[[libthread/globals.c]]}

%-------------------------------------------------------------

<<libthread/globals.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<global [[_threadpq]]>>

<<global [[procp]]>>

<<function [[_systhreadinit]]>>

<<function [[_threadgetproc]]>>

<<function [[_threadsetproc]]>>
@


\subsection*{[[libthread/debug.c]]}


%-------------------------------------------------------------

<<libthread/debug.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<global [[_threaddebuglevel]]>>

<<function [[_threaddebug]]>>

<<function [[_threadassert]]>>
@


\subsection*{[[libthread/id.c]]}

%-------------------------------------------------------------

<<libthread/id.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"
#include <tos.h>

<<function [[threadid]]>>

<<function [[threadpid]]>>

<<function [[threadsetgrp]]>>

<<function [[threadgetgrp]]>>

<<function [[threadsetname]]>>

<<function [[threadgetname]]>>

<<function [[threaddata]]>>

<<function [[_workerdata]]>>

<<function [[procdata]]>>

<<global privlock (libthread/id.c)>>
<<global [[privmask]]>>

<<function [[tprivalloc]]>>

<<function [[tprivfree]]>>

<<function [[tprivaddr]]>>
@


\subsection*{[[libthread/exit.c]]}

%-------------------------------------------------------------

<<libthread/exit.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"
#include <tos.h>

<<global [[_threadexitsallstatus]]>>
<<global [[_threadwaitchan]]>>

<<function [[threadexits]]>>

<<function [[threadexitsall]]>>

<<function [[threadwaitchan]]>>
@


\subsection*{[[libthread/lib.c]]}


%-------------------------------------------------------------

<<libthread/lib.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<global [[totalmalloc]]>>

<<function [[_threadmalloc]]>>

<<function [[_threadsysfatal]]>>
@


\subsection*{[[libthread/note.c]]}

%-------------------------------------------------------------

<<libthread/note.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

typedef struct Note Note;

<<global [[_threadnopasser]]>>

<<constant NFN (libthread/note.c)>>
<<constant [[ERRLEN]]>>
<<struct [[Note]]>>

<<global [[notes]]>>
<<global [[enotes]]>>
<<global [[onnote]]>>
<<global [[onnotepid]]>>
<<global [[onnotelock]]>>

<<function [[threadnotify]]>>

<<function [[delayednotes]]>>

<<function [[_threadnote]]>>

<<function [[_procsplhi]]>>

<<function [[_procsplx]]>>

@

\subsection*{[[libthread/rendez.c]]}

%-------------------------------------------------------------

<<libthread/rendez.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<global [[_threadrgrp]]>>
<<global [[isdirty]]>>

<<function [[finish]]>>

<<function [[_threadrendezvous]]>>

<<function [[_threadflagrendez]]>>

<<function [[_threadbreakrendez]]>>
@


\subsection*{[[libthread/sched.c]]}


%-------------------------------------------------------------

<<libthread/sched.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"
#include <tos.h>

static Thread   *runthread(Proc*);

<<global [[_psstate]]>>

<<function [[psstate]]>>

<<function [[_schedinit]]>>

<<function [[needstack]]>>

<<function [[_sched]]>>

<<function [[runthread]]>>

<<function [[_threadready]]>>

<<function [[yield]]>>

@


\subsection*{[[libthread/create.c]]}

%-------------------------------------------------------------

<<libthread/create.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<function [[nextID]]>>
    
<<function [[newthread]]>>

<<function [[threadcreate]]>>

<<function [[_newproc]]>>

<<function [[procrfork]]>>

<<function [[proccreate]]>>

<<function [[_freeproc]]>>

<<function [[_freethread]]>>

@


\subsection*{[[libthread/channel.c]]}

%-------------------------------------------------------------

<<libthread/channel.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<enum [[_anon_ (libthread/channel.c)]]>>

<<global [[errcl]]>>
<<global [[chanlock]]>>

static void enqueue(Alt*, Channel**);
static void dequeue(Alt*);
static int canexec(Alt*);
static int altexec(Alt*, int);

<<constant [[Closed]]>>
<<constant [[Intred]]>>

<<function [[_chanfree]]>>

<<function [[chanfree]]>>

<<function [[chaninit]]>>

<<function [[chancreate]]>>

<<function [[isopenfor]]>>

<<function [[alt]]>>

<<function [[chanclose]]>>

<<function [[chanclosing]]>>

<<function [[runop]]>>

<<function [[recv]]>>

<<function [[nbrecv]]>>

<<function [[send]]>>

<<function [[nbsend]]>>

<<function [[channelsize]]>>

<<function [[sendul]]>>

<<function [[recvul]]>>

<<function [[sendp]]>>

<<function [[recvp]]>>

<<function [[nbsendul]]>>

<<function [[nbrecvul]]>>

<<function [[nbsendp]]>>

<<function [[nbrecvp]]>>

<<function [[emptyentry]]>>

<<function [[enqueue]]>>

<<function [[dequeue]]>>

<<function [[canexec]]>>

<<function [[altexecbuffered]]>>

<<function [[altcopy]]>>

<<function [[altexec]]>>
@


\subsection*{[[libthread/main.c]]}

%-------------------------------------------------------------

<<libthread/main.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

typedef struct Mainarg Mainarg;

<<struct [[Mainarg]]>>

<<global [[mainstacksize]]>>
<<global [[_threadnotefd]]>>
<<global [[_threadpasserpid]]>>

<<global [[_mainjmp]]>>

static void mainlauncher(void*);
extern void (*_sysfatal)(char*, va_list);
extern void (*__assert)(char*);
extern int (*_dial)(char*, char*, char*, int*);

extern int _threaddial(char*, char*, char*, int*);

<<global [[mainp]]>>

<<function [[main]]>>

<<function [[mainlauncher]]>>

<<function skip (libthread/main.c)>>

<<function [[_times]]>>

<<function [[efork]]>>

<<function [[_schedexec]]>>

<<function [[_schedfork]]>>

<<function [[_schedexit]]>>

<<function [[_schedexecwait]]>>

@


\subsection*{[[libthread/kill.c]]}

%-------------------------------------------------------------

<<libthread/kill.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

static void tinterrupt(Proc*, Thread*);

<<function [[threadxxxgrp]]>>

<<function [[threadxxx]]>>

<<function [[threadkillgrp]]>>

<<function [[threadkill]]>>

<<function [[threadintgrp]]>>

<<function [[threadint]]>>

<<function [[tinterrupt]]>>
@


\subsection*{[[libthread/ioproc.c]]}

<<enum [[_anon_ (libthread/ioproc.c)]]>>=
enum
{
    <<constant [[STACK]]>>
};
@

%-------------------------------------------------------------

<<libthread/ioproc.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<enum [[_anon_ (libthread/ioproc.c)]]>>

<<function [[iointerrupt]]>>

<<function [[xioproc]]>>

<<function [[ioproc]]>>

<<function [[closeioproc]]>>
@


\subsection*{[[libthread/iocall.c]]}


%-------------------------------------------------------------

<<libthread/iocall.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<function [[iocall]]>>
@


\subsection*{[[libthread/chanprint.c]]}


%-------------------------------------------------------------

<<libthread/chanprint.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>

<<function [[chanprint]]>>
@


\subsection*{[[libthread/ioclose.c]]}

%-------------------------------------------------------------

<<libthread/ioclose.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<function [[_ioclose]]>>

<<function [[ioclose]]>>
@


\subsection*{[[libthread/iodial.c]]}

%-------------------------------------------------------------

<<libthread/iodial.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<function [[_iodial]]>>

<<function [[iodial]]>>
@


\subsection*{[[libthread/ioopen.c]]}



%-------------------------------------------------------------

<<libthread/ioopen.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<function [[_ioopen]]>>

<<function [[ioopen]]>>
@


\subsection*{[[libthread/ioread.c]]}


%-------------------------------------------------------------

<<libthread/ioread.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<function [[_ioread]]>>

<<function [[ioread]]>>
@


\subsection*{[[libthread/ioreadn.c]]}


%-------------------------------------------------------------

<<libthread/ioreadn.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<function [[_ioreadn]]>>

<<function [[ioreadn]]>>
@


\subsection*{[[libthread/iosleep.c]]}

%-------------------------------------------------------------

<<libthread/iosleep.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<function [[_iosleep]]>>

<<function [[iosleep]]>>
@


\subsection*{[[libthread/iowrite.c]]}


%-------------------------------------------------------------

<<libthread/iowrite.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<function [[_iowrite]]>>

<<function [[iowrite]]>>
@


\subsection*{[[libthread/dial.c]]}

%-------------------------------------------------------------

<<libthread/dial.c>>=
/*
 * old single-process version of dial that libthread can cope with
 */
#include <u.h>
#include <libc.h>

typedef struct DS DS;

static int  call(char*, char*, DS*);
static int  csdial(DS*);
static void _dial_string_parse(char*, DS*);

<<enum [[_anon_ (libthread/dial.c)]]>>

<<struct [[DS]](libthread/dial.c)>>


<<function [[_threaddial]]>>

<<function [[csdial]](libthread/dial.c)>>

<<function [[call]](libthread/dial.c)>>

<<function [[_dial_string_parse]](libthread/dial.c)>>
@


\subsection*{[[libthread/exec.c]]}

%-------------------------------------------------------------

<<libthread/exec.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<constant [[PIPEMNT]]>>

<<function [[procexec]]>>

<<function [[procexecl]]>>

@
