\section{[[include/]]}

\subsection*{[[include/arm/u.h]]}

<<include/arch/arm/u.h>>=
#define nil     ((void*)0)

typedef unsigned short  ushort;
typedef unsigned char   uchar;
typedef unsigned long   ulong;
typedef unsigned int    uint;

typedef signed char schar;
typedef long long   vlong;
typedef unsigned long long uvlong;
typedef unsigned long   uintptr;
typedef unsigned long   usize;
typedef uint        Rune;
typedef     union FPdbleword FPdbleword;
typedef long    jmp_buf[2];
#define JMPBUFSP    0
#define JMPBUFPC    1
#define JMPBUFDPC   0

typedef unsigned int    mpdigit;    /* for /sys/include/mp.h */

typedef unsigned char u8int;
typedef unsigned short u16int;
typedef unsigned int    u32int;
typedef unsigned long long u64int;

/* VFP FCR */
#define FPINEX  (1<<12)         /* trap enables for exceptions */
#define FPUNFL  (1<<11)
#define FPOVFL  (1<<10)
#define FPZDIV  (1<<9)
#define FPINVAL (1<<8)
#define FPRNR   (0<<22)
#define FPRZ    (1<<22)
#define FPRPINF (2<<22)
#define FPRNINF (3<<22)
#define FPRMASK (3<<22)
#define FPPEXT  0
#define FPPSGL  0
#define FPPDBL  0
#define FPPMASK 0
/* FSR */
#define FPAINEX (1<<4)          /* accrued exceptions */
#define FPAUNFL (1<<3)
#define FPAOVFL (1<<2)
#define FPAZDIV (1<<1)
#define FPAINVAL    (1<<0)
union FPdbleword
{
    double  x;
    struct {    /* little endian */
        ulong lo;
        ulong hi;
    };
};

typedef char*   va_list;
#define va_start(list, start) list =\
    (sizeof(start) < 4?\
        (char*)((int*)&(start)+1):\
        (char*)(&(start)+1))
#define va_end(list)\
    USED(list)
#define va_arg(list, mode)\
    ((sizeof(mode) == 1)?\
        ((list += 4), (mode*)list)[-4]:\
    (sizeof(mode) == 2)?\
        ((list += 4), (mode*)list)[-2]:\
        ((list += sizeof(mode)), (mode*)list)[-1])

@

\subsection*{[[include/libc.h]]}

<<include/libc.h>>=
#pragma lib "libc.a"
#pragma src "/sys/src/libc"

// --------------------------------------------
// pad's stuff
// --------------------------------------------
// Could also be in u.h. More types! Types are good!
typedef int bool;
enum _bool {
  false = 0,
  true = 1
};
typedef uchar bool_byte;

typedef uchar byte;

//typedef char* string; // conflict
//typedef char* filename; // conflict in sam with function filename

#define STDIN 0
#define STDOUT 1
#define STDERR 2
typedef int fdt; // file descriptor type

#define OK_0 0
#define OK_1 1
#define ERROR_0 0
#define ERROR_1 1
#define ERROR_NEG1 (-1)
// later: unify all of that to be more consistent!
typedef int error0; // 0 is the error value
typedef int error1; // 1 is the error value
typedef int errorneg1; // -1 is the error value

// --------------------------------------------
// end pad's stuff
// --------------------------------------------


#define nelem(x)    (sizeof(x)/sizeof((x)[0]))
#define offsetof(s, m)  (ulong)(&(((s*)nil)->m))
#define assert(x)   do{ if(x) {} else _assert("x"); }while(false)

typedef struct Fmt Fmt;
typedef struct Tm Tm;
typedef struct Lock Lock;
typedef struct QLp QLp;
typedef struct QLock QLock;
typedef struct RWLock RWLock;
typedef struct Rendez Rendez;
typedef struct NetConnInfo NetConnInfo;
typedef struct Qid Qid;
typedef struct Dir Dir;
typedef struct Waitmsg Waitmsg;
typedef struct IOchunk IOchunk;

/*
 * mem routines
 */
extern  void*   memccpy(void*, void*, int, ulong);
extern  void*   memset(void*, int, ulong);
extern  int     memcmp(void*, void*, ulong);
extern  void*   memcpy(void*, void*, ulong);
extern  void*   memmove(void*, void*, ulong);
extern  void*   memchr(void*, int, ulong);

/*
 * string routines
 */
extern  char*   strcat(char*, char*);
extern  char*   strchr(char*, int);
//todo: rename to _strcmp and have a string_equal wrapper 
// (and refactor code using spatch)
extern  int     strcmp(char*, char*);
extern  char*   strcpy(char*, char*);
extern  char*   strecpy(char*, char*, char*);
extern  char*   strdup(char*);
extern  char*   strncat(char*, char*, long);
extern  char*   strncpy(char*, char*, long);
extern  int     strncmp(char*, char*, long);
extern  char*   strpbrk(char*, char*);
extern  char*   strrchr(char*, int);
extern  char*   strtok(char*, char*);
extern  long    strlen(char*);
extern  long    strspn(char*, char*);
extern  long    strcspn(char*, char*);
extern  char*   strstr(char*, char*);

extern  int     cistrncmp(char*, char*, int);
extern  int     cistrcmp(char*, char*);
extern  char*   cistrstr(char*, char*);

extern  int     tokenize(char*, char**, int);

enum
{
    UTFmax      = 4,        /* maximum bytes per rune */
    Runesync    = 0x80,     /* cannot represent part of a UTF sequence (<) */
    Runeself    = 0x80,     /* rune and UTF sequences are the same (<) */
    Runeerror   = 0xFFFD,   /* decoding error in UTF */
    Runemax     = 0x10FFFF, /* 21-bit rune */
    Runemask    = 0x1FFFFF, /* bits used by runes (see grep) */
};

/*
 * rune routines
 */
extern  int runetochar(char*, Rune*);
extern  int chartorune(Rune*, char*);
extern  int runelen(long);
extern  int runenlen(Rune*, int);
extern  int fullrune(char*, int);
extern  int utflen(char*);
extern  int utfnlen(char*, long);
extern  char*   utfrune(char*, long);
extern  char*   utfrrune(char*, long);
extern  char*   utfutf(char*, char*);
extern  char*   utfecpy(char*, char*, char*);

extern  Rune*   runestrcat(Rune*, Rune*);
extern  Rune*   runestrchr(Rune*, Rune);
extern  int     runestrcmp(Rune*, Rune*);
extern  Rune*   runestrcpy(Rune*, Rune*);
extern  Rune*   runestrncpy(Rune*, Rune*, long);
extern  Rune*   runestrecpy(Rune*, Rune*, Rune*);
extern  Rune*   runestrdup(Rune*);
extern  Rune*   runestrncat(Rune*, Rune*, long);
extern  int     runestrncmp(Rune*, Rune*, long);
extern  Rune*   runestrrchr(Rune*, Rune);
extern  long    runestrlen(Rune*);
extern  Rune*   runestrstr(Rune*, Rune*);

extern  Rune    tolowerrune(Rune);
extern  Rune    totitlerune(Rune);
extern  Rune    toupperrune(Rune);
extern  Rune    tobaserune(Rune);
extern  int isalpharune(Rune);
extern  int isbaserune(Rune);
extern  int isdigitrune(Rune);
extern  int islowerrune(Rune);
extern  int isspacerune(Rune);
extern  int istitlerune(Rune);
extern  int isupperrune(Rune);

/*
 * malloc
 */
extern  void*   malloc(ulong);
extern  void*   mallocz(ulong, bool);
extern  void    free(void*);
extern  ulong   msize(void*);
extern  void*   mallocalign(ulong, ulong, long, ulong);
extern  void*   calloc(ulong, ulong);
extern  void*   realloc(void*, ulong);

extern  void    setmalloctag(void*, ulong);
extern  void    setrealloctag(void*, ulong);
extern  ulong   getmalloctag(void*);
extern  ulong   getrealloctag(void*);
extern  void*   malloctopoolblock(void*);

/*
 * print routines
 */
struct Fmt {
    uchar   runes;          /* output buffer is runes or chars? */
    void    *start;         /* of buffer */
    void    *to;            /* current place in the buffer */
    void    *stop;          /* end of the buffer; overwritten if flush fails */
    int     (*flush)(Fmt *);    /* called when to == stop */
    void    *farg;          /* to make flush a closure */
    int     nfmt;           /* num chars formatted so far */
    va_list args;           /* args passed to dofmt */
    int     r;          /* % format Rune */
    int     width;
    int     prec;
    ulong   flags;
};

enum{
    FmtWidth    = 1,
    FmtLeft     = FmtWidth << 1,
    FmtPrec     = FmtLeft << 1,
    FmtSharp    = FmtPrec << 1,
    FmtSpace    = FmtSharp << 1,
    FmtSign     = FmtSpace << 1,
    FmtZero     = FmtSign << 1,
    FmtUnsigned = FmtZero << 1,
    FmtShort    = FmtUnsigned << 1,
    FmtLong     = FmtShort << 1,
    FmtVLong    = FmtLong << 1,
    FmtComma    = FmtVLong << 1,
    FmtByte     = FmtComma << 1,

    FmtFlag     = FmtByte << 1
};

// pad: used to be just print()? but for cg transformed in a pointer func?
extern  int     (*print)(char*, ...);
extern  char*   seprint(char*, char*, char*, ...);
extern  char*   vseprint(char*, char*, char*, va_list);
extern  int     snprint(char*, int, char*, ...);
extern  int     vsnprint(char*, int, char*, va_list);
extern  char*   smprint(char*, ...);
extern  char*   vsmprint(char*, va_list);
extern  int     sprint(char*, char*, ...);
extern  int     fprint(int, char*, ...);
extern  int     vfprint(int, char*, va_list);

extern  int     runesprint(Rune*, char*, ...);
extern  int     runesnprint(Rune*, int, char*, ...);
extern  int     runevsnprint(Rune*, int, char*, va_list);
extern  Rune*   runeseprint(Rune*, Rune*, char*, ...);
extern  Rune*   runevseprint(Rune*, Rune*, char*, va_list);
extern  Rune*   runesmprint(char*, ...);
extern  Rune*   runevsmprint(char*, va_list);

extern  int     fmtfdinit(Fmt*, int, char*, int);
extern  int     fmtfdflush(Fmt*);
extern  int     fmtstrinit(Fmt*);
extern  char*   fmtstrflush(Fmt*);
extern  int     runefmtstrinit(Fmt*);
extern  Rune*   runefmtstrflush(Fmt*);

#pragma varargck    argpos  fmtprint    2
#pragma varargck    argpos  fprint      2
#pragma varargck    argpos  print       1
#pragma varargck    argpos  runeseprint 3
#pragma varargck    argpos  runesmprint 1
#pragma varargck    argpos  runesnprint 3
#pragma varargck    argpos  runesprint  2
#pragma varargck    argpos  seprint     3
#pragma varargck    argpos  smprint     1
#pragma varargck    argpos  snprint     3
#pragma varargck    argpos  sprint      2

// %d = decimal, o = octal, x = hexa, b = binary?
#pragma varargck    type    "d" int
#pragma varargck    type    "o" int
#pragma varargck    type    "x" int
#pragma varargck    type    "b" int
// %f
#pragma varargck    type    "f" double
#pragma varargck    type    "e" double
#pragma varargck    type    "g" double
// %s
#pragma varargck    type    "s" char*
#pragma varargck    type    "q" char*
#pragma varargck    type    "S" Rune*
#pragma varargck    type    "Q" Rune*
#pragma varargck    type    "r" void
#pragma varargck    type    "%" void
#pragma varargck    type    "n" int*
#pragma varargck    type    "p" uintptr
#pragma varargck    type    "p" void*
#pragma varargck    type    "c" int
#pragma varargck    type    "C" int
#pragma varargck    type    "d" uint
#pragma varargck    type    "x" uint
#pragma varargck    type    "b" uint
#pragma varargck    type    "c" uint
#pragma varargck    type    "C" uint
#pragma varargck    type    "<" void*
#pragma varargck    type    "[" void*
#pragma varargck    type    "H" void*
#pragma varargck    type    "lH"    void*

#pragma varargck    type    "lld"   vlong
#pragma varargck    type    "llo"   vlong
#pragma varargck    type    "llx"   vlong
#pragma varargck    type    "llb"   vlong

#pragma varargck    type    "lld"   uvlong
#pragma varargck    type    "llo"   uvlong
#pragma varargck    type    "llx"   uvlong
#pragma varargck    type    "llb"   uvlong

#pragma varargck    type    "ld"    long
#pragma varargck    type    "lo"    long
#pragma varargck    type    "lx"    long
#pragma varargck    type    "lb"    long

#pragma varargck    type    "ld"    ulong
#pragma varargck    type    "lo"    ulong
#pragma varargck    type    "lx"    ulong
#pragma varargck    type    "lb"    ulong


#pragma varargck    flag    ','
#pragma varargck    flag    ' '
#pragma varargck    flag    'h'


extern  int fmtinstall(int, int (*)(Fmt*));
extern  int dofmt(Fmt*, char*);
extern  int dorfmt(Fmt*, Rune*);
extern  int fmtprint(Fmt*, char*, ...);
extern  int fmtvprint(Fmt*, char*, va_list);
extern  int fmtrune(Fmt*, int);
extern  int fmtstrcpy(Fmt*, char*);
extern  int fmtrunestrcpy(Fmt*, Rune*);
/*
 * error string for %r
 * supplied on per os basis, not part of fmt library
 */
extern  int errfmt(Fmt *f);

/*
 * quoted strings
 */
extern  char*   unquotestrdup(char*);
extern  Rune*   unquoterunestrdup(Rune*);
extern  char*   quotestrdup(char*);
extern  Rune*   quoterunestrdup(Rune*);
extern  int     quotestrfmt(Fmt*);
extern  int     quoterunestrfmt(Fmt*);
extern  void    quotefmtinstall(void);
extern  int     (*doquote)(int);
extern  int     needsrcquote(int);

/*
 * random number
 */
extern  void    srand(long);
extern  int     rand(void);
extern  int     nrand(int);
extern  long    lrand(void);
extern  long    lnrand(long);
extern  double  frand(void);
extern  ulong   truerand(void);         /* uses /dev/random */
extern  ulong   ntruerand(ulong);       /* uses /dev/random */

/*
 * math
 */
extern  ulong   getfcr(void);
extern  void    setfsr(ulong);
extern  ulong   getfsr(void);
extern  void    setfcr(ulong);

extern  double  NaN(void);
extern  double  Inf(int);
extern  int     isNaN(double);
extern  int     isInf(double, int);

extern  ulong   umuldiv(ulong, ulong, ulong);
extern  long    muldiv(long, long, long);

extern  double  pow(double, double);
extern  double  fabs(double);
extern  double  log(double);
extern  double  log10(double);
extern  double  exp(double);
extern  double  floor(double);
extern  double  ceil(double);
extern  double  hypot(double, double);
extern  double  sqrt(double);
extern  double  fmod(double, double);

extern  double  atan(double);
extern  double  atan2(double, double);
extern  double  sin(double);
extern  double  cos(double);
extern  double  tan(double);
extern  double  asin(double);
extern  double  acos(double);
extern  double  sinh(double);
extern  double  cosh(double);
extern  double  tanh(double);


#define HUGE    3.4028234e38
#define PIO2    1.570796326794896619231e0
#define PI  (PIO2+PIO2)

/*
 * Time-of-day
 */

struct Tm {
    int sec;
    int min;
    int hour;
    int mday;
    int mon;
    int year;
    int wday;
    int yday;
    char    zone[4];
    int     tzoff;
};

extern  Tm*     gmtime(long);
extern  Tm*     localtime(long);
extern  char*   asctime(Tm*);
extern  char*   ctime(long);
extern  double  cputime(void);
extern  long    times(long*);
extern  long    tm2sec(Tm*);
extern  vlong   nsec(void);

extern  void    cycles(uvlong*);    /* 64-bit value of the cycle counter if there is one, 0 if there isn't */

/*
 * one-of-a-kind
 */
enum
{
    PNPROC      = 1,
    PNGROUP     = 2,
};

// debugging tools
extern  void    (*_assert)(char*);
extern  uintptr getcallerpc(void*);
extern  void    perror(char*);
extern  void    sysfatal(char*, ...);
#pragma varargck    argpos  sysfatal    1
extern  void    syslog(int, char*, char*, ...);
#pragma varargck    argpos  syslog  3

// close to syscalls
extern  void    exits(char*);
extern  char*   getwd(char*, int);
extern  char*   getenv(char*);
extern  int     putenv(char*, char*);
extern  char*   getuser(void);
extern  char*   mktemp(char*);

extern  int     setjmp(jmp_buf);
extern  void    longjmp(jmp_buf, int);
extern  void    notejmp(void*, jmp_buf, int);

extern  int     postnote(int, int, char *);
extern  int     atexit(void(*)(void));
extern  void    atexitdont(void(*)(void));
extern  int     atnotify(int(*)(void*, char*), int);

extern  int     abs(int);
extern  long    labs(long);
extern  double  frexp(double, int*);
extern  double  ldexp(double, int);
extern  double  modf(double, double*);
extern  double  pow10(int);

extern  double  atof(char*);
extern  int     atoi(char*);
extern  long    atol(char*);
extern  vlong   atoll(char*);
extern  double  strtod(char*, char**);
extern  long    strtol(char*, char**, int);
extern  ulong   strtoul(char*, char**, int);
extern  vlong   strtoll(char*, char**, int);
extern  uvlong  strtoull(char*, char**, int);

extern  int decrypt(void*, void*, int);
extern  int encrypt(void*, void*, int);
extern  int netcrypt(void*, void*);

extern  int dec64(uchar*, int, char*, int);
extern  int enc64(char*, int, uchar*, int);
extern  int dec32(uchar*, int, char*, int);
extern  int enc32(char*, int, uchar*, int);
extern  int dec16(uchar*, int, char*, int);
extern  int enc16(char*, int, uchar*, int);


extern  long    time(long*);

extern  int tolower(int);
extern  int toupper(int);

// misc
extern  double  charstod(int(*)(void*), void*);
// modified in place, so type should really be void cleanname(INOUT char*);
extern  char*   cleanname(char*);
extern  int     encodefmt(Fmt*);
extern  int     getfields(char*, char**, int, int, char*);
extern  int     gettokens(char *, char **, int, char *);
extern  int     iounit(fdt);
// ugly redefined by user code? see statusbar.c
extern  void    qsort(void*, long, long, int (*)(void*, void*));


/*
 *  profiling
 */
enum prof {
    Profoff,        /* No profiling */

    Profuser,       /* Measure user time only (default) */
    Profkernel,     /* Measure user + kernel time */
    Proftime,       /* Measure total time */
    Profsample,     /* Use clock interrupt to sample (default when there is no cycle counter) */
}; /* what */
extern  void    prof(void (*fn)(void*), void *arg, int entries, int what);

/*
 * atomic
 */
long    ainc(long*);
long    adec(long*);
int     cas32(u32int*, u32int, u32int);
int     casp(void**, void*, void*);
int     casl(ulong*, ulong, ulong);

/*
 *  synchronization
 */
struct Lock {
    long    key;
    long    sem;
};

extern int  _tas(int*);

extern  void    lock(Lock*);
extern  void    unlock(Lock*);
extern  int     canlock(Lock*);

struct QLp {
    int inuse;
    QLp *next;
    char    state;
};

struct QLock {
    Lock    lock;
    int locked;
    QLp *head;
    QLp     *tail;
};

extern  void    qlock(QLock*);
extern  void    qunlock(QLock*);
extern  int     canqlock(QLock*);
extern  void    _qlockinit(void* (*)(void*, void*));    /* called only by the thread library */

struct RWLock {
    Lock    lock;
    int readers;    /* number of readers */
    int writer;     /* number of writers */
    QLp *head;      /* list of waiting processes */
    QLp *tail;
};

extern  void    rlock(RWLock*);
extern  void    runlock(RWLock*);
extern  int     canrlock(RWLock*);
extern  void    wlock(RWLock*);
extern  void    wunlock(RWLock*);
extern  int     canwlock(RWLock*);

struct Rendez {
    QLock   *l;
    QLp *head;
    QLp *tail;
};

extern  void    rsleep(Rendez*);    /* unlocks r->l, sleeps, locks r->l again */
extern  int     rwakeup(Rendez*);
extern  int     rwakeupall(Rendez*);
extern  void**  privalloc(void);
extern  void    privfree(void**);

/*
 *  network dialing
 */
#define NETPATHLEN 40
extern  int     accept(int, char*);
extern  int     announce(char*, char*);
extern  int     dial(char*, char*, char*, int*);
extern  void    setnetmtpt(char*, int, char*);
extern  int     hangup(int);
extern  int     listen(char*, char*);
extern  char*   netmkaddr(char*, char*, char*);
extern  int     reject(int, char*, char*);

/*
 *  encryption
 */
extern  int pushssl(int, char*, char*, char*, int*);
extern  int pushtls(int, char*, char*, int, char*, char*);

/*
 *  network services
 */
struct NetConnInfo {
    char    *dir;       /* connection directory */
    char    *root;      /* network root */
    char    *spec;      /* binding spec */
    char    *lsys;      /* local system */
    char    *lserv;     /* local service */
    char    *rsys;      /* remote system */
    char    *rserv;     /* remote service */
    char    *laddr;     /* local address */
    char    *raddr;     /* remote address */
};
extern  NetConnInfo*    getnetconninfo(char*, int);
extern  void            freenetconninfo(NetConnInfo*);

/*
 * system calls
 *
 */
#include <syscall.h>



// getopt like macros
extern char *argv0;
#define ARGBEGIN    for((argv0||(argv0=*argv)),argv++,argc--;\
                argv[0] && argv[0][0]=='-' && argv[0][1];\
                argc--, argv++) {\
                char *_args, *_argt;\
                Rune _argc;\
                _args = &argv[0][1];\
                if(_args[0]=='-' && _args[1]==0){\
                    argc--; argv++; break;\
                }\
                _argc = 0;\
                while(*_args && (_args += chartorune(&_argc, _args)))\
                switch(_argc)
#define ARGEND      SET(_argt);USED(_argt,_argc,_args);}USED(argv, argc);

#define ARGF()      (_argt=_args, _args="",\
                (*_argt? _argt: argv[1]? (argc--, *++argv): 0))
#define EARGF(x)    (_argt=_args, _args="",\
                (*_argt? _argt: argv[1]? (argc--, *++argv): ((x), abort(), (char*)0)))

#define ARGC()      _argc

/* this is used by sbrk and brk,  it's a really bad idea to redefine it */
extern  char    end[];

@

\subsection*{[[include/regexp.h]]}

<<include/regexp.h>>=
#pragma src "/sys/src/libregexp"
#pragma lib "libregexp.a"

typedef struct Resub        Resub;
typedef struct Reclass      Reclass;
typedef struct Reinst       Reinst;
typedef struct Reprog       Reprog;

/*
 *  Sub expression matches
 */
struct Resub{
    union
    {
        char *sp;
        Rune *rsp;
    };
    union
    {
        char *ep;
        Rune *rep;
    };
};

/*
 *  character class, each pair of rune's defines a range
 */
struct Reclass{
    Rune    *end;
    Rune    spans[64];
};

/*
 *  Machine instructions
 */
struct Reinst{
    int type;
    union   {
        Reclass *cp;        /* class pointer */
        Rune    r;      /* character */
        int subid;      /* sub-expression id for RBRA and LBRA */
        Reinst  *right;     /* right child of OR */
    };
    union { /* regexp relies on these two being in the same union */
        Reinst *left;       /* left child of OR */
        Reinst *next;       /* next instruction for CAT & LBRA */
    };
};

/*
 *  Reprogram definition
 */
struct Reprog{
    Reinst  *startinst; /* start pc */
    Reclass class[16];  /* .data */
    Reinst  firstinst[5];   /* .text */
};

extern Reprog   *regcomp(char*);
extern Reprog   *regcomplit(char*);
extern Reprog   *regcompnl(char*);
extern void regerror(char*);
extern int  regexec(Reprog*, char*, Resub*, int);
extern void regsub(char*, char*, int, Resub*, int);
extern int  rregexec(Reprog*, Rune*, Resub*, int);
extern void rregsub(Rune*, Rune*, int, Resub*, int);
@


\subsection*{[[include/thread.h]]}

%dead I think
%enum {
%    Nqwds = 2,
%    Nqshift = 5,       /* log₂ # of bits in long */
%    Nqmask =  -1,
%    Nqbits = (1 << Nqshift) * 2,
%};

%-------------------------------------------------------------

<<include/thread.h>>=
#pragma src "/sys/src/libthread"
#pragma lib "libthread.a"

#pragma varargck    argpos  chanprint   2

typedef struct Alt  Alt;
typedef struct Channel  Channel;
typedef struct Ref  Ref;
/* slave I/O processes */
typedef struct Ioproc Ioproc;
#pragma incomplete Ioproc

<<struct Channel>>

/* Channel operations for alt: */
<<enum chanop>>
typedef enum chanop ChanOp;

<<struct Alt>>

<<struct Ref>>

long    decref(Ref *r);         /* returns 0 iff value is now zero */
void    incref(Ref *r);

Channel* chancreate(int elemsize, int bufsize);
int chanclose(Channel*);
int chanclosing(Channel *c);
int chaninit(Channel *c, int elemsize, int elemcnt);
void    chanfree(Channel *c);
int chanprint(Channel *, char *, ...);

// blocking API
int recv(Channel *c, void *v);
void*   recvp(Channel *c);
ulong   recvul(Channel *c);
int send(Channel *c, void *v);
int sendp(Channel *c, void *v);
int sendul(Channel *c, ulong v);

// non blocking API
int nbrecv(Channel *c, void *v);
void*   nbrecvp(Channel *c);
ulong   nbrecvul(Channel *c);
int nbsend(Channel *c, void *v);
int nbsendp(Channel *c, void *v);
int nbsendul(Channel *c, ulong v);

// select
int alt(Alt alts[]);

// process
int proccreate(void (*f)(void *arg), void *arg, uint stacksize);
int procrfork(void (*f)(void *arg), void *arg, uint stacksize, int flag);
void**  procdata(void);
void    procexec(Channel *, char *, char *[]);
void    procexecl(Channel *, char *, ...);

// threads
int threadcreate(void (*f)(void *arg), void *arg, uint stacksize);
void**  threaddata(void);
void    threadexits(char *);
void    threadexitsall(char *);
void    threadmain(int argc, char *argv[]);
int threadid(void);

int threadgetgrp(void); /* return thread group of current thread */
int threadsetgrp(int);      /* set thread group, return old */
char*   threadgetname(void);
void    threadsetname(char *fmt, ...);
void    threadint(int);     /* interrupt thread */
void    threadintgrp(int);  /* interrupt threads in grp */
void    threadkill(int);    /* kill thread */
void    threadkillgrp(int); /* kill threads in group */
void    threadnonotes(void);
int threadnotify(int (*f)(void*, char*), int in);
int threadpid(int);
Channel*threadwaitchan(void);

// Io proc
Ioproc* ioproc(void);
void    closeioproc(Ioproc*);
void    iointerrupt(Ioproc*);

int ioopen(Ioproc*, char*, int);
int ioclose(Ioproc*, int);
long    ioread(Ioproc*, int, void*, long);
long    ioreadn(Ioproc*, int, void*, long);
long    iowrite(Ioproc*, int, void*, long);
int iosleep(Ioproc*, long);
int iodial(Ioproc*, char*, char*, char*, int*);

long    iocall(Ioproc*, long (*)(va_list*), ...);
void    ioret(Ioproc*, int);

// misc
void    needstack(int);
int tprivalloc(void);
void    tprivfree(int);
void    **tprivaddr(int);
void    yield(void);

extern  int mainstacksize;
@

\section{[[lib_core/libc/port]]}

\subsection*{[[port/_assert.c]]}

<<global __assert>>=
void (*__assert)(char*);
@

<<function default_assert>>=
void
default_assert(char *s)
{
    if(__assert)
        (*__assert)(s);
    fprint(2, "assert failed: %s\n", s);
    abort();
}
@

<<global _assert>>=
void (*_assert)(char*) = default_assert;
@


%-------------------------------------------------------------

<<port/_assert.c>>=
#include <u.h>
#include <libc.h>

<<global __assert>>


<<function default_assert>>

<<global _assert>>
@


\subsection*{[[port/abs.c]]}

<<function abs>>=
int
abs(int a)
{
    if(a < 0)
        return -a;
    return a;
}
@

<<function labs>>=
long
labs(long a)
{
    if(a < 0)
        return -a;
    return a;
}
@


%-------------------------------------------------------------

<<port/abs.c>>=
#include <u.h>
#include <libc.h>

<<function abs>>

<<function labs>>
@


\subsection*{[[port/asin.c]]}

<<function asin>>=
double
asin(double arg)
{
    double temp;
    int sign;

    sign = 0;
    if(arg < 0) {
        arg = -arg;
        sign++;
    }
    if(arg > 1)
        return NaN();
    temp = sqrt(1 - arg*arg);
    if(arg > 0.7)
        temp = PIO2 - atan(temp/arg);
    else
        temp = atan(arg/temp);
    if(sign)
        temp = -temp;
    return temp;
}
@

<<function acos>>=
double
acos(double arg)
{
    if(arg > 1 || arg < -1)
        return NaN();
    return PIO2 - asin(arg);
}
@


%-------------------------------------------------------------

<<port/asin.c>>=
/*
 * asin(arg) and acos(arg) return the arcsin, arccos,
 * respectively of their arguments.
 *
 * Arctan is called after appropriate range reduction.
 */

#include <u.h>
#include <libc.h>

<<function asin>>

<<function acos>>
@


\subsection*{[[port/atan.c]]}

<<constant sq2p1>>=
#define sq2p1 2.414213562373095048802e0
@

<<constant sq2m1>>=
#define sq2m1  .414213562373095048802e0
@

<<constant p4>>=
#define p4  .161536412982230228262e2
@

<<constant p3>>=
#define p3  .26842548195503973794141e3
@

<<constant p2>>=
#define p2  .11530293515404850115428136e4
@

<<constant p1>>=
#define p1  .178040631643319697105464587e4
@

<<constant p0>>=
#define p0  .89678597403663861959987488e3
@

<<constant q4>>=
#define q4  .5895697050844462222791e2
@

<<constant q3>>=
#define q3  .536265374031215315104235e3
@

<<constant q2>>=
#define q2  .16667838148816337184521798e4
@

<<constant q1>>=
#define q1  .207933497444540981287275926e4
@

<<constant q0>>=
#define q0  .89678597403663861962481162e3
@

<<function xatan>>=
/*
    xatan evaluates a series valid in the
    range [-0.414...,+0.414...]. (tan(pi/8))
 */

static
double
xatan(double arg)
{
    double argsq, value;

    argsq = arg*arg;
    value = ((((p4*argsq + p3)*argsq + p2)*argsq + p1)*argsq + p0);
    value = value/(((((argsq + q4)*argsq + q3)*argsq + q2)*argsq + q1)*argsq + q0);
    return value*arg;
}
@

<<function satan>>=
/*
    satan reduces its argument (known to be positive)
    to the range [0,0.414...] and calls xatan.
 */

static
double
satan(double arg)
{

    if(arg < sq2m1)
        return xatan(arg);
    if(arg > sq2p1)
        return PIO2 - xatan(1/arg);
    return PIO2/2 + xatan((arg-1)/(arg+1));
}
@

<<function atan>>=
/*
    atan makes its argument positive and
    calls the inner routine satan.
 */

double
atan(double arg)
{

    if(arg > 0)
        return satan(arg);
    return -satan(-arg);
}
@


%-------------------------------------------------------------

<<port/atan.c>>=
/*
    floating-point arctangent

    atan returns the value of the arctangent of its
    argument in the range [-pi/2,pi/2].

    atan2 returns the arctangent of arg1/arg2
    in the range [-pi,pi].

    there are no error returns.

    coefficients are #5077 from Hart & Cheney. (19.56D)
*/

#include <u.h>
#include <libc.h>

<<constant sq2p1>>
<<constant sq2m1>>
<<constant p4>>
<<constant p3>>
<<constant p2>>
<<constant p1>>
<<constant p0>>
<<constant q4>>
<<constant q3>>
<<constant q2>>
<<constant q1>>
<<constant q0>>


<<function xatan>>

<<function satan>>

<<function atan>>
@


\subsection*{[[port/atan2.c]]}

<<function atan2>>=
/*
    atan2 discovers what quadrant the angle
    is in and calls atan.
*/

double
atan2(double arg1, double arg2)
{

    if(arg1+arg2 == arg1) {
        if(arg1 >= 0)
            return PIO2;
        return -PIO2;
    }
    arg1 = atan(arg1/arg2);
    if(arg2 < 0) {
        if(arg1 <= 0)
            return arg1 + PI;
        return arg1 - PI;
    }
    return arg1;
}
@


%-------------------------------------------------------------

<<port/atan2.c>>=
#include <u.h>
#include <libc.h>
<<function atan2>>
@


\subsection*{[[port/atexit.c]]}

<<constant NEXIT>>=
#define NEXIT   33
@

<<struct Onex>>=
struct Onex{
    void    (*f)(void);
    int pid;
};
@

<<global onexlock>>=
static Lock onexlock;
@

<<global onex>>=
Onex onex[NEXIT];
@

<<function atexit>>=
int
atexit(void (*f)(void))
{
    int i;

    lock(&onexlock);
    for(i=0; i<NEXIT; i++)
        if(onex[i].f == 0) {
            onex[i].pid = getpid();
            onex[i].f = f;
            unlock(&onexlock);
            return 1;
        }
    unlock(&onexlock);
    return 0;
}
@

<<function atexitdont>>=
void
atexitdont(void (*f)(void))
{
    int i, pid;

    pid = getpid();
    for(i=0; i<NEXIT; i++)
        if(onex[i].f == f && onex[i].pid == pid)
            onex[i].f = 0;
}
@

<<function exits>>=
void
exits(char *s)
{
    int i, pid;
    void (*f)(void);

    pid = getpid();
    for(i = NEXIT-1; i >= 0; i--)
        if((f = onex[i].f) && pid == onex[i].pid) {
            onex[i].f = 0;
            (*f)();
        }
    _exits(s);
}
@


%-------------------------------------------------------------

<<port/atexit.c>>=
#include <u.h>
#include <libc.h>

<<constant NEXIT>>

typedef struct Onex Onex;
<<struct Onex>>

<<global onexlock>>
<<global onex>>

<<function atexit>>

<<function atexitdont>>

#pragma profile off

<<function exits>>

#pragma profile on
@


\subsection*{[[port/atnotify.c]]}

<<constant NFN (port/atnotify.c)>>=
#define NFN 33
@

<<global onnot>>=
static  int (*onnot[NFN])(void*, char*);
@

<<global onnotlock>>=
static  Lock    onnotlock;
@

<<function notifier>>=
static
void
notifier(void *v, char *s)
{
    int i;

    for(i=0; i<NFN; i++)
        if(onnot[i] && ((*onnot[i])(v, s))){
            noted(NCONT);
            return;
        }
    noted(NDFLT);
}
@

<<function atnotify>>=
int
atnotify(int (*f)(void*, char*), int in)
{
    int i, n, ret;
    static int init;

    if(!init){
        notify(notifier);
        init = 1;       /* assign = */
    }
    ret = 0;
    lock(&onnotlock);
    if(in){
        for(i=0; i<NFN; i++)
            if(onnot[i] == 0) {
                onnot[i] = f;
                ret = 1;
                break;
            }
    }else{
        n = 0;
        for(i=0; i<NFN; i++)
            if(onnot[i]){
                if(ret==0 && onnot[i]==f){
                    onnot[i] = 0;
                    ret = 1;
                }else
                    n++;
            }
        if(n == 0){
            init = 0;
            notify(0);
        }
    }
    unlock(&onnotlock);
    return ret;
}
@


%-------------------------------------------------------------

<<port/atnotify.c>>=
#include <u.h>
#include <libc.h>

<<constant NFN (port/atnotify.c)>>
<<global onnot>>
<<global onnotlock>>

<<function notifier>>

<<function atnotify>>
@


\subsection*{[[port/atof.c]]}

<<function atof>>=
double
atof(char *cp)
{
    return strtod(cp, 0);
}
@


%-------------------------------------------------------------

<<port/atof.c>>=
#include <u.h>
#include <libc.h>

<<function atof>>
@


\subsection*{[[port/atol.c]]}

<<function atol>>=
long
atol(char *s)
{
    long n;
    int f, c;

    n = 0;
    f = 0;
    while(*s == ' ' || *s == '\t')
        s++;
    if(*s == '-' || *s == '+') {
        if(*s++ == '-')
            f = 1;
        while(*s == ' ' || *s == '\t')
            s++;
    }
    if(s[0]=='0' && s[1]) {
        if(s[1]=='x' || s[1]=='X'){
            s += 2;
            for(;;) {
                c = *s;
                if(c >= '0' && c <= '9')
                    n = n*16 + c - '0';
                else
                if(c >= 'a' && c <= 'f')
                    n = n*16 + c - 'a' + 10;
                else
                if(c >= 'A' && c <= 'F')
                    n = n*16 + c - 'A' + 10;
                else
                    break;
                s++;
            }
        } else
            while(*s >= '0' && *s <= '7')
                n = n*8 + *s++ - '0';
    } else
        while(*s >= '0' && *s <= '9')
            n = n*10 + *s++ - '0';
    if(f)
        n = -n;
    return n;
}
@

<<function atoi>>=
int
atoi(char *s)
{

    return atol(s);
}
@


%-------------------------------------------------------------

<<port/atol.c>>=
#include <u.h>
#include <libc.h>

<<function atol>>

<<function atoi>>
@


\subsection*{[[port/atoll.c]]}

<<function atoll>>=
vlong
atoll(char *s)
{
    return strtoll(s, nil, 0);
}
@


%-------------------------------------------------------------

<<port/atoll.c>>=
#include <u.h>
#include <libc.h>

<<function atoll>>
@


\subsection*{[[port/charstod.c]]}

<<constant ADVANCE>>=
/*
 * Reads a floating-point number by interpreting successive characters
 * returned by (*f)(vp).  The last call it makes to f terminates the
 * scan, so is not a character in the number.  It may therefore be
 * necessary to back up the input stream up one byte after calling charstod.
 */

#define ADVANCE do{*s++ = c; if(s>=e) return NaN(); c = (*f)(vp);}while(0)
@

<<function charstod>>=
double
charstod(int(*f)(void*), void *vp)
{
    char str[400], *s, *e, *start;
    int c;

    s = str;
    e = str + sizeof str - 1;
    c = (*f)(vp);
    while(c == ' ' || c == '\t')
        c = (*f)(vp);
    if(c == '-' || c == '+'){
        ADVANCE;
    }
    start = s;
    while(c >= '0' && c <= '9'){
        ADVANCE;
    }
    if(c == '.'){
        ADVANCE;
        while(c >= '0' && c <= '9'){
            ADVANCE;
        }
    }
    if(s > start && (c == 'e' || c == 'E')){
        ADVANCE;
        if(c == '-' || c == '+'){
            ADVANCE;
        }
        while(c >= '0' && c <= '9'){
            ADVANCE;
        }
    }else if(s == start && (c == 'i' || c == 'I')){
        ADVANCE;
        if(c != 'n' && c != 'N')
            return NaN();
        ADVANCE;
        if(c != 'f' && c != 'F')
            return NaN();
        ADVANCE;
        if(c != 'i' && c != 'I')
            return NaN();
        ADVANCE;
        if(c != 'n' && c != 'N')
            return NaN();
        ADVANCE;
        if(c != 'i' && c != 'I')
            return NaN();
        ADVANCE;
        if(c != 't' && c != 'T')
            return NaN();
        ADVANCE;
        if(c != 'y' && c != 'Y')
            return NaN();
        ADVANCE;  /* so caller can back up uniformly */
        USED(c);
    }else if(s == str && (c == 'n' || c == 'N')){
        ADVANCE;
        if(c != 'a' && c != 'A')
            return NaN();
        ADVANCE;
        if(c != 'n' && c != 'N')
            return NaN();
        ADVANCE;  /* so caller can back up uniformly */
        USED(c);
    }
    *s = 0;
    return strtod(str, &s);
}
@


%-------------------------------------------------------------

<<port/charstod.c>>=
#include <u.h>
#include <libc.h>

<<constant ADVANCE>>

<<function charstod>>
@


\subsection*{[[port/cistrcmp.c]]}

<<function cistrcmp>>=
int
cistrcmp(char *s1, char *s2)
{
    int c1, c2;

    while(*s1){
        c1 = *(uchar*)s1++;
        c2 = *(uchar*)s2++;

        if(c1 == c2)
            continue;

        if(c1 >= 'A' && c1 <= 'Z')
            c1 -= 'A' - 'a';

        if(c2 >= 'A' && c2 <= 'Z')
            c2 -= 'A' - 'a';

        if(c1 != c2)
            return c1 - c2;
    }
    return -*s2;
}
@


%-------------------------------------------------------------

<<port/cistrcmp.c>>=
#include <u.h>
#include <libc.h>

<<function cistrcmp>>
@


\subsection*{[[port/cistrncmp.c]]}

<<function cistrncmp>>=
int
cistrncmp(char *s1, char *s2, int n)
{
    int c1, c2;

    while(*s1 && n-- > 0){
        c1 = *(uchar*)s1++;
        c2 = *(uchar*)s2++;

        if(c1 == c2)
            continue;

        if(c1 >= 'A' && c1 <= 'Z')
            c1 -= 'A' - 'a';

        if(c2 >= 'A' && c2 <= 'Z')
            c2 -= 'A' - 'a';

        if(c1 != c2)
            return c1 - c2;
    }
    if(n <= 0)
        return 0;
    return -*s2;
}
@


%-------------------------------------------------------------

<<port/cistrncmp.c>>=
#include <u.h>
#include <libc.h>

<<function cistrncmp>>
@


\subsection*{[[port/cistrstr.c]]}

<<function cistrstr>>=
char*
cistrstr(char *s, char *sub)
{
    int c, csub, n;

    csub = *sub;
    if(csub == '\0')
        return s;
    if(csub >= 'A' && csub <= 'Z')
        csub -= 'A' - 'a';
    sub++;
    n = strlen(sub);
    for(; c = *s; s++){
        if(c >= 'A' && c <= 'Z')
            c -= 'A' - 'a';
        if(c == csub && cistrncmp(s+1, sub, n) == 0)
            return s;
    }
    return nil;
}
@


%-------------------------------------------------------------

<<port/cistrstr.c>>=
#include <u.h>
#include <libc.h>

<<function cistrstr>>
@


\subsection*{[[port/cleanname.c]]}

<<macro SEP>>=
/*
 * In place, rewrite name to compress multiple /, eliminate ., and process ..
 */
#define SEP(x)  ((x)=='/' || (x) == 0)
@

<<function cleanname>>=
char*
cleanname(char *name)
{
    char *s;    /* source of copy */
    char *d;    /* destination of copy */
    char *d0;   /* start of path afer the root name */
    Rune r;
    bool rooted;

    if(name[0] == '\0')
        return strcpy(name, ".");
    rooted = false;
    d0 = name;
    if(d0[0] == '#'){
        if(d0[1] == '\0')
            return d0;
        d0  += 1 + chartorune(&r, d0+1); /* ignore slash: #/ */
        while(!SEP(*d0))
            d0 += chartorune(&r, d0);
        if(d0 == '\0')
            return name;
        d0++;   /* keep / after #<name> */
        rooted = true;
    }else if(d0[0] == '/'){
        rooted = true;
        d0++;
    }

    s = d0;
    if(rooted){
        /* skip extra '/' at root name */
        for(; *s == '/'; s++)
            ;
    }
    /* remove dup slashes */
    for(d = d0; *s != '\0'; s++){
        *d++ = *s;
        if(*s == '/')
            while(s[1] == '/')
                s++;
    }
    *d = '\0';

    d = d0;
    s = d0;
    while(*s != '\0'){
        if(s[0] == '.' && SEP(s[1])){
            if(s[1] == '\0')
                break;
            s+= 2;
            continue;
        }
        if(s[0] == '.' && s[1] == '.' && SEP(s[2])){
            if(d == d0){
                if(rooted){
                    /* /../x -> /x */
                    if(s[2] == '\0')
                        break;
                    s += 3;
                    continue;
                }else{
                    /* ../x -> ../x; and never collect ../ */
                    d0 += 3;
                }
            }
            if(d > d0){
                /* a/../x -> x */
                assert(d-2 >= d0 && d[-1] == '/');
                for(d -= 2; d > d0 && d[-1] != '/'; d--)
                        ;
                if(s[2] == '\0')
                    break;
                s += 3;
                continue;
            }
        }
        while(!SEP(*s))
            *d++ = *s++;
        if(*s == '\0')
            break;
        
        *d++ = *s++;
    }
    *d = '\0';
    if(d-1 > name && d[-1] == '/')  /* thanks to #/ */
        *--d = '\0';
    if(name[0] == '\0')
        strcpy(name, ".");
    return name;
}
@


%-------------------------------------------------------------

<<port/cleanname.c>>=
#include <u.h>
#include <libc.h>

<<macro SEP>>
<<function cleanname>>
@


\subsection*{[[port/crypt.c]]}

<<function encrypt>>=
/*
 * destructively encrypt the buffer, which
 * must be at least 8 characters long.
 */
int
encrypt(void *key, void *vbuf, int n)
{
    ulong ekey[32];
    uchar *buf;
    int i, r;

    if(n < 8)
        return 0;
    key_setup(key, ekey);
    buf = vbuf;
    n--;
    r = n % 7;
    n /= 7;
    for(i = 0; i < n; i++){
        block_cipher(ekey, buf, 0);
        buf += 7;
    }
    if(r)
        block_cipher(ekey, buf - 7 + r, 0);
    return 1;
}
@

<<function decrypt>>=
/*
 * destructively decrypt the buffer, which
 * must be at least 8 characters long.
 */
int
decrypt(void *key, void *vbuf, int n)
{
    ulong ekey[128];
    uchar *buf;
    int i, r;

    if(n < 8)
        return 0;
    key_setup(key, ekey);
    buf = vbuf;
    n--;
    r = n % 7;
    n /= 7;
    buf += n * 7;
    if(r)
        block_cipher(ekey, buf - 7 + r, 1);
    for(i = 0; i < n; i++){
        buf -= 7;
        block_cipher(ekey, buf, 1);
    }
    return 1;
}
@


%-------------------------------------------------------------

<<port/crypt.c>>=
/*
 *  Data Encryption Standard
 *  D.P.Mitchell  83/06/08.
 *
 *  block_cipher(key, block, decrypting)
 *
 *  these routines use the non-standard 7 byte format
 *  for DES keys.
 */
#include <u.h>
#include <libc.h>
#include <auth.h>
#include <libsec.h>

<<function encrypt>>

<<function decrypt>>
@


\subsection*{[[port/ctype.c]]}

<<global _ctype>>=
uchar   _ctype[256] =
{
/*   0   1   2   3   4   5   6   7  */

/*  0*/ _C, _C, _C, _C, _C, _C, _C, _C,
/* 10*/ _C, _S|_C,  _S|_C,  _S|_C,  _S|_C,  _S|_C,  _C, _C,
/* 20*/ _C, _C, _C, _C, _C, _C, _C, _C,
/* 30*/ _C, _C, _C, _C, _C, _C, _C, _C,
/* 40*/ _S|_B,  _P, _P, _P, _P, _P, _P, _P,
/* 50*/ _P, _P, _P, _P, _P, _P, _P, _P,
/* 60*/ _N|_X,  _N|_X,  _N|_X,  _N|_X,  _N|_X,  _N|_X,  _N|_X,  _N|_X,
/* 70*/ _N|_X,  _N|_X,  _P, _P, _P, _P, _P, _P,
/*100*/ _P, _U|_X,  _U|_X,  _U|_X,  _U|_X,  _U|_X,  _U|_X,  _U,
/*110*/ _U, _U, _U, _U, _U, _U, _U, _U,
/*120*/ _U, _U, _U, _U, _U, _U, _U, _U,
/*130*/ _U, _U, _U, _P, _P, _P, _P, _P,
/*140*/ _P, _L|_X,  _L|_X,  _L|_X,  _L|_X,  _L|_X,  _L|_X,  _L,
/*150*/ _L, _L, _L, _L, _L, _L, _L, _L,
/*160*/ _L, _L, _L, _L, _L, _L, _L, _L,
/*170*/ _L, _L, _L, _P, _P, _P, _P, _C,
};
@


%-------------------------------------------------------------

<<port/ctype.c>>=
#include <u.h>
#include <libc.h>
#include <ctype.h>

<<global _ctype>>
@


\subsection*{[[port/encodefmt.c]]}

<<function encodefmt>>=
int
encodefmt(Fmt *f)
{
    char *out;
    char *buf;
    int len;
    int ilen;
    int rv;
    uchar *b;
    char *p;
    char obuf[64];  // rsc optimization

    if(!(f->flags&FmtPrec) || f->prec < 1)
        goto error;

    b = va_arg(f->args, uchar*);
    if(b == 0)
        return fmtstrcpy(f, "<nil>");

    ilen = f->prec;
    f->prec = 0;
    f->flags &= ~FmtPrec;
    switch(f->r){
    case '<':
        len = (8*ilen+4)/5 + 3;
        break;
    case '[':
        len = (8*ilen+5)/6 + 4;
        break;
    case 'H':
        len = 2*ilen + 1;
        break;
    default:
        goto error;
    }

    if(len > sizeof(obuf)){
        buf = malloc(len);
        if(buf == nil)
            goto error;
    } else
        buf = obuf;

    // convert
    out = buf;
    switch(f->r){
    case '<':
        rv = enc32(out, len, b, ilen);
        break;
    case '[':
        rv = enc64(out, len, b, ilen);
        break;
    case 'H':
        rv = enc16(out, len, b, ilen);
        if(rv >= 0 && (f->flags & FmtLong))
            for(p = buf; *p; p++)
                *p = tolower(*p);
        break;
    default:
        rv = -1;
        break;
    }
    if(rv < 0)
        goto error;

    fmtstrcpy(f, buf);
    if(buf != obuf)
        free(buf);
    return 0;

error:
    return fmtstrcpy(f, "<encodefmt>");
}
@


%-------------------------------------------------------------

<<port/encodefmt.c>>=
#include <u.h>
#include <libc.h>
#include <ctype.h>

<<function encodefmt>>
@


\subsection*{[[port/execl.c]]}

<<function execl>>=
int
execl(char *f, ...)
{

    return exec(f, &f+1);
}
@


%-------------------------------------------------------------

<<port/execl.c>>=
#include <u.h>
#include <libc.h>

<<function execl>>
@


\subsection*{[[port/exp.c]]}

<<constant p0 (port/exp.c)>>=
#define p0  .2080384346694663001443843411e7
@

<<constant p1 (port/exp.c)>>=
#define p1  .3028697169744036299076048876e5
@

<<constant p2 (port/exp.c)>>=
#define p2  .6061485330061080841615584556e2
@

<<constant q0 (port/exp.c)>>=
#define q0  .6002720360238832528230907598e7
@

<<constant q1 (port/exp.c)>>=
#define q1  .3277251518082914423057964422e6
@

<<constant q2 (port/exp.c)>>=
#define q2  .1749287689093076403844945335e4
@

<<constant log2e>>=
#define log2e  1.4426950408889634073599247
@

<<constant sqrt2>>=
#define sqrt2  1.4142135623730950488016887
@

<<constant maxf>>=
#define maxf  10000
@

<<function exp>>=
double
exp(double arg)
{
    double fract, temp1, temp2, xsq;
    int ent;

    if(arg == 0)
        return 1;
    if(arg < -maxf)
        return 0;
    if(arg > maxf)
        return Inf(1);
    arg *= log2e;
    ent = floor(arg);
    fract = (arg-ent) - 0.5;
    xsq = fract*fract;
    temp1 = ((p2*xsq+p1)*xsq+p0)*fract;
    temp2 = ((xsq+q2)*xsq+q1)*xsq + q0;
    return ldexp(sqrt2*(temp2+temp1)/(temp2-temp1), ent);
}
@


%-------------------------------------------------------------

<<port/exp.c>>=
/*
    exp returns the exponential function of its
    floating-point argument.

    The coefficients are #1069 from Hart and Cheney. (22.35D)
*/

#include <u.h>
#include <libc.h>

<<constant p0 (port/exp.c)>>
<<constant p1 (port/exp.c)>>
<<constant p2 (port/exp.c)>>
<<constant q0 (port/exp.c)>>
<<constant q1 (port/exp.c)>>
<<constant q2 (port/exp.c)>>
<<constant log2e>>
<<constant sqrt2>>
<<constant maxf>>

<<function exp>>
@


\subsection*{[[port/fabs.c]]}

<<function fabs>>=
double
fabs(double arg)
{

    if(arg < 0)
        return -arg;
    return arg;
}
@


%-------------------------------------------------------------

<<port/fabs.c>>=
#include <u.h>
#include <libc.h>

<<function fabs>>
@


\subsection*{[[port/floor.c]]}

<<function floor>>=
/*
 * floor and ceil-- greatest integer <= arg
 * (resp least >=)
 */

double
floor(double d)
{
    double fract;

    if(d < 0) {
        fract = modf(-d, &d);
        if(fract != 0.0)
            d += 1;
        d = -d;
    } else
        modf(d, &d);
    return d;
}
@

<<function ceil>>=
double
ceil(double d)
{
    return -floor(-d);
}
@


%-------------------------------------------------------------

<<port/floor.c>>=
#include <u.h>
#include <libc.h>
<<function floor>>

<<function ceil>>
@


\subsection*{[[port/fmod.c]]}

<<function fmod>>=
/*
 * floating-point mod function without infinity or NaN checking
 */
double
fmod (double x, double y)
{
    int sign, yexp, rexp;
    double r, yfr, rfr;

    if (y == 0)
        return x;
    if (y < 0)
        y = -y;
    yfr = frexp(y, &yexp);
    sign = 0;
    if(x < 0) {
        r = -x;
        sign++;
    } else
        r = x;
    while(r >= y) {
        rfr = frexp(r, &rexp);
        r -= ldexp(y, rexp - yexp - (rfr < yfr));
    }
    if(sign)
        r = -r;
    return r;
}
@


%-------------------------------------------------------------

<<port/fmod.c>>=
#include <u.h>
#include <libc.h>

<<function fmod>>
@


\subsection*{[[port/frand.c]]}

<<constant MASK>>=
#define MASK    0x7fffffffL
@

<<constant NORM>>=
#define NORM    (1.0/(1.0+MASK))
@

<<function frand>>=
double
frand(void)
{
    double x;

    do {
        x = lrand() * NORM;
        x = (x + lrand()) * NORM;
    } while(x >= 1);
    return x;
}
@


%-------------------------------------------------------------

<<port/frand.c>>=
#include    <u.h>
#include    <libc.h>

<<constant MASK>>
<<constant NORM>>

<<function frand>>
@


\subsection*{[[port/frexp.c]]}

<<constant MASK (port/frexp.c)>>=
/*
 * this is big/little endian non-portable
 * it gets the endian from the FPdbleword
 * union in u.h.
 */
#define MASK    0x7ffL
@

<<constant SHIFT>>=
#define SHIFT   20
@

<<constant BIAS>>=
#define BIAS    1022L
@

<<constant SIG>>=
#define SIG 52
@

<<function frexp>>=
double
frexp(double d, int *ep)
{
    FPdbleword x, a;

    *ep = 0;
    /* order matters: only isNaN can operate on NaN */
    if(isNaN(d) || isInf(d, 0) || d == 0)
        return d;
    x.x = d;
    a.x = fabs(d);
    if((a.hi >> SHIFT) == 0){   /* normalize subnormal numbers */
        x.x = (double)(1ULL<<SIG) * d;
        *ep = -SIG;
    }
    *ep += ((x.hi >> SHIFT) & MASK) - BIAS;
    x.hi &= ~(MASK << SHIFT);
    x.hi |= BIAS << SHIFT;
    return x.x;
}
@

<<function ldexp>>=
double
ldexp(double d, int deltae)
{
    int e, bits;
    FPdbleword x;
    ulong z;

    if(d == 0)
        return 0;
    x.x = d;
    e = (x.hi >> SHIFT) & MASK;
    if(deltae >= 0 || e+deltae >= 1){   /* no underflow */
        e += deltae;
        if(e >= MASK){      /* overflow */
            if(d < 0)
                return Inf(-1);
            return Inf(1);
        }
    }else{  /* underflow gracefully */
        deltae = -deltae;
        /* need to shift d right deltae */
        if(e > 1){      /* shift e-1 by exponent manipulation */
            deltae -= e-1;
            e = 1;
        }
        if(deltae > 0 && e==1){ /* shift 1 by switch from 1.fff to 0.1ff */
            deltae--;
            e = 0;
            x.lo >>= 1;
            x.lo |= (x.hi&1)<<31;
            z = x.hi & ((1<<SHIFT)-1);
            x.hi &= ~((1<<SHIFT)-1);
            x.hi |= (1<<(SHIFT-1)) | (z>>1);
        }
        while(deltae > 0){      /* shift bits down */
            bits = deltae;
            if(bits > SHIFT)
                bits = SHIFT;
            x.lo >>= bits;
            x.lo |= (x.hi&((1<<bits)-1)) << (32-bits);
            z = x.hi & ((1<<SHIFT)-1);
            x.hi &= ~((1<<SHIFT)-1);
            x.hi |= z>>bits;
            deltae -= bits;
        }
    }
    x.hi &= ~(MASK << SHIFT);
    x.hi |= (long)e << SHIFT;
    return x.x;
}
@

<<function modf>>=
double
modf(double d, double *ip)
{
    FPdbleword x;
    int e;

    x.x = d;
    e = (x.hi >> SHIFT) & MASK;
    if(e == MASK){
        *ip = d;
        if(x.lo != 0 || (x.hi & 0xfffffL) != 0) /* NaN */
            return d;
        /* ±Inf */
        x.hi &= 0x80000000L;
        return x.x;
    }
    if(d < 1) {
        if(d < 0) {
            x.x = modf(-d, ip);
            *ip = -*ip;
            return -x.x;
        }
        *ip = 0;
        return d;
    }
    e -= BIAS;
    if(e <= SHIFT+1) {
        x.hi &= ~(0x1fffffL >> e);
        x.lo = 0;
    } else
    if(e <= SHIFT+33)
        x.lo &= ~(0x7fffffffL >> (e-SHIFT-2));
    *ip = x.x;
    return d - x.x;
}
@


%-------------------------------------------------------------

<<port/frexp.c>>=
#include <u.h>
#include <libc.h>

<<constant MASK (port/frexp.c)>>
<<constant SHIFT>>
<<constant BIAS>>
<<constant SIG>>

<<function frexp>>

<<function ldexp>>

<<function modf>>
@


\subsection*{[[port/getcallerpc.c]]}

<<function getcallerpc>>=
uintptr
getcallerpc(void*)
{
    return 0;
}
@


%-------------------------------------------------------------

<<port/getcallerpc.c>>=
#include <u.h>
#include <libc.h>

<<function getcallerpc>>
@


\subsection*{[[port/getfields.c]]}

<<function getfields>>=
int
getfields(char *str, char **args, int max, int mflag, char *set)
{
    Rune r;
    int nr, intok, narg;

    if(max <= 0)
        return 0;

    narg = 0;
    args[narg] = str;
    if(!mflag)
        narg++;
    intok = 0;
    for(;; str += nr) {
        nr = chartorune(&r, str);
        if(r == 0)
            break;
        if(utfrune(set, r)) {
            if(narg >= max)
                break;
            *str = 0;
            intok = 0;
            args[narg] = str + nr;
            if(!mflag)
                narg++;
        } else {
            if(!intok && mflag)
                narg++;
            intok = 1;
        }
    }
    return narg;
}
@


%-------------------------------------------------------------

<<port/getfields.c>>=
#include <u.h>
#include <libc.h>

<<function getfields>>
@


\subsection*{[[port/getuser.c]]}

<<function getuser>>=
char *
getuser(void)
{
    static char user[64];
    int fd;
    int n;

    fd = open("/dev/user", OREAD);
    if(fd < 0)
        return "none";
    n = read(fd, user, (sizeof user)-1);
    close(fd);
    if(n <= 0)
        strcpy(user, "none");
    else
        user[n] = 0;
    return user;
}
@


%-------------------------------------------------------------

<<port/getuser.c>>=
#include <u.h>
#include <libc.h>

<<function getuser>>
@


\subsection*{[[port/hangup.c]]}

<<function hangup>>=
/*
 *  force a connection to hangup
 */
int
hangup(int ctl)
{
    return write(ctl, "hangup", sizeof("hangup")-1) != sizeof("hangup")-1;
}
@


%-------------------------------------------------------------

<<port/hangup.c>>=
#include <u.h>
#include <libc.h>
#include <ctype.h>

<<function hangup>>
@


\subsection*{[[port/hypot.c]]}

<<function hypot>>=
double
hypot(double p, double q)
{
    double r, s, pfac;

    if(p < 0)
        p = -p;
    if(q < 0)
        q = -q;
    if(p < q) {
        r = p;
        p = q;
        q = r;
    }
    if(p == 0)
        return 0;
    pfac = p;
    r = q = q/p;
    p = 1;
    for(;;) {
        r *= r;
        s = r+4;
        if(s == 4)
            return p*pfac;
        r /= s;
        p += 2*r*p;
        q *= r;
        r = q/p;
    }
}
@


%-------------------------------------------------------------

<<port/hypot.c>>=
/*
 * hypot -- sqrt(p*p+q*q), but overflows only if the result does.
 * See Cleve Moler and Donald Morrison,
 * ``Replacing Square Roots by Pythagorean Sums,''
 * IBM Journal of Research and Development,
 * Vol. 27, Number 6, pp. 577-581, Nov. 1983
 */

#include <u.h>
#include <libc.h>

<<function hypot>>
@


\subsection*{[[port/lnrand.c]]}

<<constant MASK (port/lnrand.c)>>=
#define MASK    0x7fffffffL
@

<<function lnrand>>=
long
lnrand(long n)
{
    long slop, v;

    if(n < 0)
        return n;
    slop = MASK % n;
    do
        v = lrand();
    while(v <= slop);
    return v % n;
}
@


%-------------------------------------------------------------

<<port/lnrand.c>>=
#include    <u.h>
#include    <libc.h>

<<constant MASK (port/lnrand.c)>>

<<function lnrand>>
@


\subsection*{[[port/lock.c]]}

<<function lock>>=
void
lock(Lock *l)
{
    if(ainc(&l->key) == 1)
        return; /* changed from 0 -> 1: we hold lock */
    /* otherwise wait in kernel */
    while(semacquire(&l->sem, 1) < 0){
        /* interrupted; try again */
    }
}
@

<<function unlock>>=
void
unlock(Lock *l)
{
    if(adec(&l->key) == 0)
        return; /* changed from 1 -> 0: no contention */
    semrelease(&l->sem, 1);
}
@

<<function canlock>>=
int
canlock(Lock *l)
{
    if(ainc(&l->key) == 1)
        return 1;   /* changed from 0 -> 1: success */
    /* Undo increment (but don't miss wakeup) */
    if(adec(&l->key) == 0)
        return 0;   /* changed from 1 -> 0: no contention */
    semrelease(&l->sem, 1);
    return 0;
}
@


%-------------------------------------------------------------

<<port/lock.c>>=
#include <u.h>
#include <libc.h>

<<function lock>>

<<function unlock>>

<<function canlock>>
@


\subsection*{[[port/log.c]]}

<<constant log2>>=
#define log2    0.693147180559945309e0
@

<<constant ln10o1>>=
#define ln10o1  .4342944819032518276511
@

<<constant sqrto2>>=
#define sqrto2  0.707106781186547524e0
@

<<constant p0 (port/log.c)>>=
#define p0      -.240139179559210510e2
@

<<constant p1 (port/log.c)>>=
#define p1      0.309572928215376501e2
@

<<constant p2 (port/log.c)>>=
#define p2      -.963769093377840513e1
@

<<constant p3 (port/log.c)>>=
#define p3      0.421087371217979714e0
@

<<constant q0 (port/log.c)>>=
#define q0      -.120069589779605255e2
@

<<constant q1 (port/log.c)>>=
#define q1      0.194809660700889731e2
@

<<constant q2 (port/log.c)>>=
#define q2      -.891110902798312337e1
@

<<function log>>=
double
log(double arg)
{
    double x, z, zsq, temp;
    int exp;

    if(arg <= 0)
        return NaN();
    x = frexp(arg, &exp);
    while(x < 0.5) {
        x *= 2;
        exp--;
    }
    if(x < sqrto2) {
        x *= 2;
        exp--;
    }

    z = (x-1) / (x+1);
    zsq = z*z;

    temp = ((p3*zsq + p2)*zsq + p1)*zsq + p0;
    temp = temp/(((zsq + q2)*zsq + q1)*zsq + q0);
    temp = temp*z + exp*log2;
    return temp;
}
@

<<function log10>>=
double
log10(double arg)
{

    if(arg <= 0)
        return NaN();
    return log(arg) * ln10o1;
}
@


%-------------------------------------------------------------

<<port/log.c>>=
/*
    log returns the natural logarithm of its floating
    point argument.

    The coefficients are #2705 from Hart & Cheney. (19.38D)

    It calls frexp.
*/

#include <u.h>
#include <libc.h>

<<constant log2>>
<<constant ln10o1>>
<<constant sqrto2>>
<<constant p0 (port/log.c)>>
<<constant p1 (port/log.c)>>
<<constant p2 (port/log.c)>>
<<constant p3 (port/log.c)>>
<<constant q0 (port/log.c)>>
<<constant q1 (port/log.c)>>
<<constant q2 (port/log.c)>>

<<function log>>

<<function log10>>
@


\subsection*{[[port/lrand.c]]}

<<constant LEN>>=
/*
 *  algorithm by
 *  D. P. Mitchell & J. A. Reeds
 */

#define LEN 607
@

<<constant TAP>>=
#define TAP 273
@

<<constant MASK (port/lrand.c)>>=
#define MASK    0x7fffffffL
@

<<constant A>>=
#define A   48271
@

<<constant M>>=
#define M   2147483647
@

<<constant Q>>=
#define Q   44488
@

<<constant R>>=
#define R   3399
@

<<constant NORM (port/lrand.c)>>=
#define NORM    (1.0/(1.0+MASK))
@

<<global rng_vec>>=
static  ulong   rng_vec[LEN];
@

<<global rng_tap>>=
static  ulong*  rng_tap = rng_vec;
@

<<global rng_feed>>=
static  ulong*  rng_feed = 0;
@

<<global lk>>=
static  Lock    lk;
@

<<function isrand>>=
static void
isrand(long seed)
{
    long lo, hi, x;
    int i;

    rng_tap = rng_vec;
    rng_feed = rng_vec+LEN-TAP;
    seed = seed%M;
    if(seed < 0)
        seed += M;
    if(seed == 0)
        seed = 89482311;
    x = seed;
    /*
     *  Initialize by x[n+1] = 48271 * x[n] mod (2**31 - 1)
     */
    for(i = -20; i < LEN; i++) {
        hi = x / Q;
        lo = x % Q;
        x = A*lo - R*hi;
        if(x < 0)
            x += M;
        if(i >= 0)
            rng_vec[i] = x;
    }
}
@

<<function srand>>=
void
srand(long seed)
{
    lock(&lk);
    isrand(seed);
    unlock(&lk);
}
@

<<function lrand>>=
long
lrand(void)
{
    ulong x;

    lock(&lk);

    rng_tap--;
    if(rng_tap < rng_vec) {
        if(rng_feed == 0) {
            isrand(1);
            rng_tap--;
        }
        rng_tap += LEN;
    }
    rng_feed--;
    if(rng_feed < rng_vec)
        rng_feed += LEN;
    x = (*rng_feed + *rng_tap) & MASK;
    *rng_feed = x;

    unlock(&lk);

    return x;
}
@


%-------------------------------------------------------------

<<port/lrand.c>>=
#include    <u.h>
#include    <libc.h>

<<constant LEN>>
<<constant TAP>>
<<constant MASK (port/lrand.c)>>
<<constant A>>
<<constant M>>
<<constant Q>>
<<constant R>>
<<constant NORM (port/lrand.c)>>

<<global rng_vec>>
<<global rng_tap>>
<<global rng_feed>>
<<global lk>>

<<function isrand>>

<<function srand>>

<<function lrand>>
@


\subsection*{[[port/malloc.c]]}

<<struct Private>>=
struct Private {
    Lock        lk;
    int     pid;
    int     printfd;    /* gets debugging output if set */
};
@

<<global sbrkmempriv>>=
Private sbrkmempriv;
@

<<global sbrkmem>>=
static Pool sbrkmem = {
    .name=      "sbrkmem",
    .maxsize=   (3840UL-1)*1024*1024,   /* up to ~0xf0000000 */
    .minarena=  4*1024,
    .quantum=   32,
    .alloc=     sbrkalloc,
    .merge=     sbrkmerge,
    .flags=     0,

    .lock=      plock,
    .unlock=        punlock,
    .print=     pprint,
    .panic=     ppanic,
    .private=       &sbrkmempriv,
};
@

<<global mainmem>>=
Pool *mainmem = &sbrkmem;
@

<<global imagmem>>=
Pool *imagmem = &sbrkmem;
@

<<function sbrkalloc>>=
/*
 * we do minimal bookkeeping so we can tell pool
 * whether two blocks are adjacent and thus mergeable.
 */
static void*
sbrkalloc(ulong n)
{
    ulong *x;

    n += 2*sizeof(ulong);   /* two longs for us */
    x = sbrk(n);
    if(x == (void*)-1)
        return nil;
    x[0] = (n+7)&~7;    /* sbrk rounds size up to mult. of 8 */
    x[1] = 0xDeadBeef;
    return x+2;
}
@

<<function sbrkmerge>>=
static int
sbrkmerge(void *x, void *y)
{
    ulong *lx, *ly;

    lx = x;
    if(lx[-1] != 0xDeadBeef)
        abort();

    if((uchar*)lx+lx[-2] == (uchar*)y) {
        ly = y;
        lx[-2] += ly[-2];
        return 1;
    }
    return 0;
}
@

<<function plock>>=
static void
plock(Pool *p)
{
    Private *pv;
    pv = p->private;
    lock(&pv->lk);
    if(pv->pid != 0)
        abort();
    pv->pid = _tos->pid;
}
@

<<function punlock>>=
static void
punlock(Pool *p)
{
    Private *pv;
    pv = p->private;
    if(pv->pid != _tos->pid)
        abort();
    pv->pid = 0;
    unlock(&pv->lk);
}
@

<<function checkenv>>=
static int
checkenv(void)
{
    int n, fd;
    char buf[20];
    fd = open("/env/MALLOCFD", OREAD);
    if(fd < 0)
        return -1;
    if((n = read(fd, buf, sizeof buf)) < 0) {
        close(fd);
        return -1;
    }
    if(n >= sizeof buf)
        n = sizeof(buf)-1;
    buf[n] = 0;
    n = atoi(buf);
    if(n == 0)
        n = -1;
    return n;
}
@

<<function pprint>>=
static void
pprint(Pool *p, char *fmt, ...)
{
    va_list v;
    Private *pv;

    pv = p->private;
    if(pv->printfd == 0)
        pv->printfd = checkenv();

    if(pv->printfd <= 0)
        pv->printfd = 2;

    va_start(v, fmt);
    vfprint(pv->printfd, fmt, v);
    va_end(v);
}
@

<<global panicbuf>>=
static char panicbuf[256];
@

<<function ppanic>>=
static void
ppanic(Pool *p, char *fmt, ...) 
{
    va_list v;
    int n;
    char *msg;
    Private *pv;

    pv = p->private;
    assert(canlock(&pv->lk)==0);

    if(pv->printfd == 0)
        pv->printfd = checkenv();
    if(pv->printfd <= 0)
        pv->printfd = 2;

    msg = panicbuf;
    va_start(v, fmt);
    n = vseprint(msg, msg+sizeof panicbuf, fmt, v) - msg;
    write(2, "panic: ", 7);
    write(2, msg, n);
    write(2, "\n", 1);
    if(pv->printfd != 2){
        write(pv->printfd, "panic: ", 7);
        write(pv->printfd, msg, n);
        write(pv->printfd, "\n", 1);
    }
    va_end(v);
//  unlock(&pv->lk);
    abort();
}
@

<<enum _anon_>>=
/* tracing */
enum {
    Npadlong    = 2,
    MallocOffset = 0,
    ReallocOffset = 1
};
@

<<function malloc>>=
void*
malloc(ulong size)
{
    void *v;

    v = poolalloc(mainmem, size+Npadlong*sizeof(ulong));
    if(Npadlong && v != nil) {
        v = (ulong*)v+Npadlong;
        setmalloctag(v, getcallerpc(&size));
        setrealloctag(v, 0);
    }
    return v;
}
@

<<function mallocz>>=
void*
mallocz(ulong size, int clr)
{
    void *v;

    v = poolalloc(mainmem, size+Npadlong*sizeof(ulong));
    if(Npadlong && v != nil){
        v = (ulong*)v+Npadlong;
        setmalloctag(v, getcallerpc(&size));
        setrealloctag(v, 0);
    }
    if(clr && v != nil)
        memset(v, 0, size);
    return v;
}
@

<<function mallocalign>>=
void*
mallocalign(ulong size, ulong align, long offset, ulong span)
{
    void *v;

    v = poolallocalign(mainmem, size+Npadlong*sizeof(ulong), align, offset-Npadlong*sizeof(ulong), span);
    if(Npadlong && v != nil){
        v = (ulong*)v+Npadlong;
        setmalloctag(v, getcallerpc(&size));
        setrealloctag(v, 0);
    }
    return v;
}
@

<<function free>>=
void
free(void *v)
{
    if(v != nil)
        poolfree(mainmem, (ulong*)v-Npadlong);
}
@

<<function realloc>>=
void*
realloc(void *v, ulong size)
{
    void *nv;

    if(size == 0){
        free(v);
        return nil;
    }

    if(v)
        v = (ulong*)v-Npadlong;
    size += Npadlong*sizeof(ulong);

    if(nv = poolrealloc(mainmem, v, size)){
        nv = (ulong*)nv+Npadlong;
        setrealloctag(nv, getcallerpc(&v));
        if(v == nil)
            setmalloctag(nv, getcallerpc(&v));
    }       
    return nv;
}
@

<<function msize>>=
ulong
msize(void *v)
{
    return poolmsize(mainmem, (ulong*)v-Npadlong)-Npadlong*sizeof(ulong);
}
@

<<function calloc>>=
void*
calloc(ulong n, ulong szelem)
{
    void *v;
    if(v = mallocz(n*szelem, 1))
        setmalloctag(v, getcallerpc(&n));
    return v;
}
@

<<function setmalloctag>>=
void
setmalloctag(void *v, ulong pc)
{
    ulong *u;
    USED(v, pc);
    if(Npadlong <= MallocOffset || v == nil)
        return;
    u = v;
    u[-Npadlong+MallocOffset] = pc;
}
@

<<function setrealloctag>>=
void
setrealloctag(void *v, ulong pc)
{
    ulong *u;
    USED(v, pc);
    if(Npadlong <= ReallocOffset || v == nil)
        return;
    u = v;
    u[-Npadlong+ReallocOffset] = pc;
}
@

<<function getmalloctag>>=
ulong
getmalloctag(void *v)
{
    USED(v);
    if(Npadlong <= MallocOffset)
        return ~0;
    return ((ulong*)v)[-Npadlong+MallocOffset];
}
@

<<function getrealloctag>>=
ulong
getrealloctag(void *v)
{
    USED(v);
    if(Npadlong <= ReallocOffset)
        return ((ulong*)v)[-Npadlong+ReallocOffset];
    return ~0;
}
@

<<function malloctopoolblock>>=
void*
malloctopoolblock(void *v)
{
    if(v == nil)
        return nil;

    return &((ulong*)v)[-Npadlong];
}
@


%-------------------------------------------------------------

<<port/malloc.c>>=
#include <u.h>
#include <libc.h>
#include <pool.h>
#include <tos.h>

static void*    sbrkalloc(ulong);
static int      sbrkmerge(void*, void*);
static void     plock(Pool*);
static void     punlock(Pool*);
static void     pprint(Pool*, char*, ...);
static void     ppanic(Pool*, char*, ...);

typedef struct Private Private;
<<struct Private>>

<<global sbrkmempriv>>

<<global sbrkmem>>
<<global mainmem>>
<<global imagmem>>

<<function sbrkalloc>>

<<function sbrkmerge>>

<<function plock>>

<<function punlock>>

<<function checkenv>>

<<function pprint>>

<<global panicbuf>>
<<function ppanic>>

/* - everything from here down should be the same in libc, libdebugmalloc, and the kernel - */
/* - except the code for malloc(), which alternately doesn't clear or does. - */

/*
 * Npadlong is the number of 32-bit longs to leave at the beginning of 
 * each allocated buffer for our own bookkeeping.  We return to the callers
 * a pointer that points immediately after our bookkeeping area.  Incoming pointers
 * must be decremented by that much, and outgoing pointers incremented.
 * The malloc tag is stored at MallocOffset from the beginning of the block,
 * and the realloc tag at ReallocOffset.  The offsets are from the true beginning
 * of the block, not the beginning the caller sees.
 *
 * The extra if(Npadlong != 0) in various places is a hint for the compiler to
 * compile out function calls that would otherwise be no-ops.
 */

/*  non tracing
 *
enum {
    Npadlong    = 0,
    MallocOffset = 0,
    ReallocOffset = 0,
};
 *
 */

<<enum _anon_>>

<<function malloc>>

<<function mallocz>>

<<function mallocalign>>

<<function free>>

<<function realloc>>

<<function msize>>

<<function calloc>>

<<function setmalloctag>>

<<function setrealloctag>>

<<function getmalloctag>>

<<function getrealloctag>>

<<function malloctopoolblock>>
@


\subsection*{[[port/memccpy.c]]}

<<function memccpy>>=
void*
memccpy(void *a1, void *a2, int c, ulong n)
{
    uchar *s1, *s2;

    s1 = a1;
    s2 = a2;
    c &= 0xFF;
    while(n > 0) {
        if((*s1++ = *s2++) == c)
            return s1;
        n--;
    }
    return 0;
}
@


%-------------------------------------------------------------

<<port/memccpy.c>>=
#include    <u.h>
#include    <libc.h>

<<function memccpy>>
@


\subsection*{[[port/memchr.c]]}

<<function memchr>>=
void*
memchr(void *ap, int c, ulong n)
{
    uchar *sp;

    sp = ap;
    c &= 0xFF;
    while(n > 0) {
        if(*sp++ == c)
            return sp-1;
        n--;
    }
    return 0;
}
@


%-------------------------------------------------------------

<<port/memchr.c>>=
#include    <u.h>
#include    <libc.h>

<<function memchr>>
@


\subsection*{[[port/memcmp.c]]}

<<function memcmp>>=
int
memcmp(void *a1, void *a2, ulong n)
{
    uchar *s1, *s2;
    uint c1, c2;

    s1 = a1;
    s2 = a2;
    while(n > 0) {
        c1 = *s1++;
        c2 = *s2++;
        if(c1 != c2) {
            if(c1 > c2)
                return 1;
            return -1;
        }
        n--;
    }
    return 0;
}
@


%-------------------------------------------------------------

<<port/memcmp.c>>=
#include    <u.h>
#include    <libc.h>

<<function memcmp>>
@


\subsection*{[[port/memmove.c]]}

<<function memmove>>=
void*
memmove(void *a1, void *a2, ulong n)
{
    char *s1, *s2;

    if((long)n < 0)
        abort();
    s1 = a1;
    s2 = a2;
    if((s2 < s1) && (s2+n > s1))
        goto back;
    while(n > 0) {
        *s1++ = *s2++;
        n--;
    }
    return a1;

back:
    s1 += n;
    s2 += n;
    while(n > 0) {
        *--s1 = *--s2;
        n--;
    }
    return a1;
}
@

<<function memcpy>>=
void*
memcpy(void *a1, void *a2, ulong n)
{
    return memmove(a1, a2, n);
}
@


%-------------------------------------------------------------

<<port/memmove.c>>=
#include    <u.h>
#include    <libc.h>

<<function memmove>>

<<function memcpy>>
@


\subsection*{[[port/memset.c]]}

<<function memset>>=
void*
memset(void *ap, int c, ulong n)
{
    char *p;

    p = ap;
    while(n > 0) {
        *p++ = c;
        n--;
    }
    return ap;
}
@


%-------------------------------------------------------------

<<port/memset.c>>=
#include    <u.h>
#include    <libc.h>

<<function memset>>
@


\subsection*{[[port/mktemp.c]]}

<<function mktemp>>=
char*
mktemp(char *as)
{
    char *s;
    unsigned pid;
    int i;
    char err[ERRMAX];

    pid = getpid();
    s = as;
    while(*s++)
        ;
    s--;
    while(*--s == 'X') {
        *s = pid % 10 + '0';
        pid = pid/10;
    }
    s++;
    i = 'a';
    while(access(as, 0) != -1) {
        if (i == 'z')
            return "/";
        *s = i++;
    }
    err[0] = '\0';
    errstr(err, sizeof err);    /* clear the error */
    return as;
}
@


%-------------------------------------------------------------

<<port/mktemp.c>>=
#include <u.h>
#include <libc.h>

<<function mktemp>>
@


\subsection*{[[port/muldiv.c]]}

<<function umuldiv>>=
ulong
umuldiv(ulong a, ulong b, ulong c)
{
    double d;

    d = ((double)a * (double)b) / (double)c;
    if(d >= 4294967296.)
        abort();
    return d;
}
@

<<function muldiv>>=
long
muldiv(long a, long b, long c)
{
    int s;
    long v;

    s = 0;
    if(a < 0) {
        s = !s;
        a = -a;
    }
    if(b < 0) {
        s = !s;
        b = -b;
    }
    if(c < 0) {
        s = !s;
        c = -c;
    }
    v = umuldiv(a, b, c);
    if(s)
        v = -v;
    return v;
}
@


%-------------------------------------------------------------

<<port/muldiv.c>>=
#include <u.h>
#include <libc.h>

<<function umuldiv>>

<<function muldiv>>
@


\subsection*{[[port/nan.c]]}

<<constant NANEXP>>=
#define NANEXP  (2047<<20)
@

<<constant NANMASK>>=
#define NANMASK (2047<<20)
@

<<constant NANSIGN>>=
#define NANSIGN (1<<31)
@

<<function NaN>>=
double
NaN(void)
{
    FPdbleword a;

    a.hi = NANEXP;
    a.lo = 1;
    return a.x;
}
@

<<function isNaN>>=
int
isNaN(double d)
{
    FPdbleword a;

    a.x = d;
    if((a.hi & NANMASK) != NANEXP)
        return 0;
    return !isInf(d, 0);
}
@

<<function Inf>>=
double
Inf(int sign)
{
    FPdbleword a;

    a.hi = NANEXP;
    a.lo = 0;
    if(sign < 0)
        a.hi |= NANSIGN;
    return a.x;
}
@

<<function isInf>>=
int
isInf(double d, int sign)
{
    FPdbleword a;

    a.x = d;
    if(a.lo != 0)
        return 0;
    if(a.hi == NANEXP)
        return sign >= 0;
    if(a.hi == (NANEXP|NANSIGN))
        return sign <= 0;
    return 0;
}
@


%-------------------------------------------------------------

<<port/nan.c>>=
#include <u.h>
#include <libc.h>

<<constant NANEXP>>
<<constant NANMASK>>
<<constant NANSIGN>>

<<function NaN>>

<<function isNaN>>

<<function Inf>>

<<function isInf>>
@


\subsection*{[[port/needsrcquote.c]]}

<<function needsrcquote>>=
int
needsrcquote(int c)
{
    if(c <= ' ')
        return 1;
    if(utfrune("`^#*[]=|\\?${}()'<>&;", c))
        return 1;
    return 0;
}
@
%$


%-------------------------------------------------------------

<<port/needsrcquote.c>>=
#include <u.h>
#include <libc.h>

<<function needsrcquote>>
@


\subsection*{[[port/netcrypt.c]]}

<<function netcrypt>>=
int
netcrypt(void *key, void *chal)
{
    uchar buf[8], *p;

    strncpy((char*)buf, chal, 7);
    buf[7] = '\0';
    for(p = buf; *p && *p != '\n'; p++)
        ;
    *p = '\0';
    encrypt(key, buf, 8);
    sprint(chal, "%.2ux%.2ux%.2ux%.2ux", buf[0], buf[1], buf[2], buf[3]);
    return 1;
}
@


%-------------------------------------------------------------

<<port/netcrypt.c>>=
#include <u.h>
#include <libc.h>
#include <auth.h>

<<function netcrypt>>
@


\subsection*{[[port/netmkaddr.c]]}

<<function netmkaddr>>=
/*
 *  make an address, add the defaults
 */
char *
netmkaddr(char *linear, char *defnet, char *defsrv)
{
    static char addr[256];
    char *cp;

    /*
     *  dump network name
     */
    cp = strchr(linear, '!');
    if(cp == 0){
        if(defnet==0){
            if(defsrv)
                snprint(addr, sizeof(addr), "net!%s!%s",
                    linear, defsrv);
            else
                snprint(addr, sizeof(addr), "net!%s", linear);
        }
        else {
            if(defsrv)
                snprint(addr, sizeof(addr), "%s!%s!%s", defnet,
                    linear, defsrv);
            else
                snprint(addr, sizeof(addr), "%s!%s", defnet,
                    linear);
        }
        return addr;
    }

    /*
     *  if there is already a service, use it
     */
    cp = strchr(cp+1, '!');
    if(cp)
        return linear;

    /*
     *  add default service
     */
    if(defsrv == 0)
        return linear;
    snprint(addr, sizeof(addr), "%s!%s", linear, defsrv);

    return addr;
}
@


%-------------------------------------------------------------

<<port/netmkaddr.c>>=
#include <u.h>
#include <libc.h>
#include <ctype.h>

<<function netmkaddr>>
@


\subsection*{[[port/nrand.c]]}

<<constant MASK (port/nrand.c)>>=
#define MASK    0x7fffffffL
@

<<function nrand>>=
int
nrand(int n)
{
    long slop, v;

    if(n < 0)
        return n;
    if(n == 1)
        return 0;
    /* and if n == 0, you deserve what you get */
    slop = MASK % n;
    do
        v = lrand();
    while(v <= slop);
    return v % n;
}
@


%-------------------------------------------------------------

<<port/nrand.c>>=
#include    <u.h>
#include    <libc.h>

<<constant MASK (port/nrand.c)>>

<<function nrand>>
@


\subsection*{[[port/ntruerand.c]]}

<<function ntruerand>>=
ulong
ntruerand(ulong n)
{
    ulong m, r;

    /*
     * set m to the one less than the maximum multiple of n <= 2^32,
     * so we want a random number <= m.
     */
    if(n > (1UL<<31))
        m = n-1;
    else
        /* 2^32 - 2^32%n - 1 = (2^32 - 1) - (2*(2^31%n))%n */
        m = 0xFFFFFFFFUL - (2*((1UL<<31)%n))%n;

    while((r = truerand()) > m)
        ;

    return r%n;
}
@


%-------------------------------------------------------------

<<port/ntruerand.c>>=
#include <u.h>
#include <libc.h>

<<function ntruerand>>
@


\subsection*{[[port/perror.c]]}

<<function perror>>=
void
perror(char *s)
{
    char buf[ERRMAX];

    buf[0] = '\0';
    errstr(buf, sizeof buf);
    if(s && *s)
        fprint(2, "%s: %s\n", s, buf);
    else
        fprint(2, "%s\n", buf);
}
@


%-------------------------------------------------------------

<<port/perror.c>>=
#include <u.h>
#include <libc.h>

<<function perror>>
@


\subsection*{[[port/pool.c]]}

<<struct Bhdr>>=
struct Bhdr {
    ulong   magic;
    ulong   size;
};
@

<<enum _anon_ (port/pool.c)>>=
enum {
    NOT_MAGIC = 0xdeadfa11,
    DEAD_MAGIC = 0xdeaddead,
};
@

<<macro B2NB>>=
#define B2NB(b) ((Bhdr*)((uchar*)(b)+(b)->size))
@

<<macro SHORT>>=
#define SHORT(x) (((x)[0] << 8) | (x)[1])
@

<<macro PSHORT>>=
#define PSHORT(p, x) \
    (((uchar*)(p))[0] = ((x)>>8)&0xFF, \
    ((uchar*)(p))[1] = (x)&0xFF)
@

<<enum _anon_ (port/pool.c)2>>=
enum {
    TAIL_MAGIC0 = 0xBE,
    TAIL_MAGIC1 = 0xEF
};
@

<<struct Btail>>=
struct Btail {
    uchar   magic0;
    uchar   datasize[2];
    uchar   magic1;
    ulong   size;   /* same as Bhdr->size */
};
@

<<macro B2T>>=
#define B2T(b)  ((Btail*)((uchar*)(b)+(b)->size-sizeof(Btail)))
@

<<macro B2PT>>=
#define B2PT(b) ((Btail*)((uchar*)(b)-sizeof(Btail)))
@

<<macro T2HDR>>=
#define T2HDR(t) ((Bhdr*)((uchar*)(t)+sizeof(Btail)-(t)->size))
@

<<struct Free>>=
struct Free {
            Bhdr;
    Free*   left;
    Free*   right;
    Free*   next;
    Free*   prev;
};
@

<<enum _anon_ (port/pool.c)3>>=
enum {
    FREE_MAGIC = 0xBA5EBA11,
};
@

<<struct Alloc>>=
/*
 * the point of the notused fields is to make 8c differentiate
 * between Bhdr and Allocblk, and between Kempt and Unkempt.
 */
struct Alloc {
            Bhdr;
};
@

<<enum _anon_ (port/pool.c)4>>=
enum {
    ALLOC_MAGIC = 0x0A110C09,
    UNALLOC_MAGIC = 0xCAB00D1E+1,
};
@

<<struct Arena>>=
struct Arena {
            Bhdr;
    Arena*  aup;
    Arena*  down;
    ulong   asize;
    ulong   pad;    /* to a multiple of 8 bytes */
};
@

<<enum _anon_ (port/pool.c)5>>=
enum {
    ARENA_MAGIC = 0xC0A1E5CE+1,
    ARENATAIL_MAGIC = 0xEC5E1A0C+1,
};
@

<<macro A2TB>>=
#define A2TB(a) ((Bhdr*)((uchar*)(a)+(a)->asize-sizeof(Bhdr)))
@

<<macro A2B>>=
#define A2B(a)  B2NB(a)
@

<<enum _anon_ (port/pool.c)6>>=
enum {
    ALIGN_MAGIC = 0xA1F1D1C1,
};
@

<<enum _anon_ (port/pool.c)7>>=
enum {
    MINBLOCKSIZE = sizeof(Free)+sizeof(Btail)
};
@

<<global datamagic>>=
static uchar datamagic[] = { 0xFE, 0xF1, 0xF0, 0xFA };
@

<<constant Poison>>=
#define Poison  (void*)0xCafeBabe
@

<<macro _B2D>>=
#define _B2D(a) ((void*)((uchar*)a+sizeof(Bhdr)))
@

<<macro _D2B>>=
#define _D2B(v) ((Alloc*)((uchar*)v-sizeof(Bhdr)))
@

<<function checklist>>=
/*
 * Tree walking
 */

static void
checklist(Free *t)
{
    Free *q;

    for(q=t->next; q!=t; q=q->next){
        assert(q->size == t->size);
        assert(q->next==nil || q->next->prev==q);
        assert(q->prev==nil || q->prev->next==q);
    //  assert(q->left==nil);
    //  assert(q->right==nil);
        assert(q->magic==FREE_MAGIC);
    }
}
@

<<function checktree>>=
static void
checktree(Free *t, int a, int b)
{
    assert(t->magic==FREE_MAGIC);
    assert(a < t->size && t->size < b);
    assert(t->next==nil || t->next->prev==t);
    assert(t->prev==nil || t->prev->next==t);
    checklist(t);
    if(t->left)
        checktree(t->left, a, t->size);
    if(t->right)
        checktree(t->right, t->size, b);
    
}
@

<<function ltreewalk>>=
/* ltreewalk: return address of pointer to node of size == size */
static Free**
ltreewalk(Free **t, ulong size)
{
    assert(t != nil /* ltreewalk */);

    for(;;) {
        if(*t == nil)
            return t;

        assert((*t)->magic == FREE_MAGIC);

        if(size == (*t)->size)
            return t;
        if(size < (*t)->size)
            t = &(*t)->left;
        else
            t = &(*t)->right;
    }
}
@

<<function treelookup>>=
/* treelookup: find node in tree with size == size */
static Free*
treelookup(Free *t, ulong size)
{
    return *ltreewalk(&t, size);
}
@

<<function treeinsert>>=
/* treeinsert: insert node into tree */
static Free*
treeinsert(Free *tree, Free *node)
{
    Free **loc, *repl;

    assert(node != nil /* treeinsert */);

    loc = ltreewalk(&tree, node->size);
    if(*loc == nil) {
        node->left = nil;
        node->right = nil;
    } else {    /* replace existing node */
        repl = *loc;
        node->left = repl->left;
        node->right = repl->right;
    }
    *loc = node;
    return tree;
}
@

<<function treedelete>>=
/* treedelete: remove node from tree */
static Free*
treedelete(Free *tree, Free *node)
{
    Free **loc, **lsucc, *succ;

    assert(node != nil /* treedelete */);

    loc = ltreewalk(&tree, node->size);
    assert(*loc == node);

    if(node->left == nil)
        *loc = node->right;
    else if(node->right == nil)
        *loc = node->left;
    else {
        /* have two children, use inorder successor as replacement */
        for(lsucc = &node->right; (*lsucc)->left; lsucc = &(*lsucc)->left)
            ;
        succ = *lsucc;
        *lsucc = succ->right;
        succ->left = node->left;
        succ->right = node->right;
        *loc = succ;
    }

    node->left = node->right = Poison;
    return tree;
}
@

<<function treelookupgt>>=
/* treelookupgt: find smallest node in tree with size >= size */
static Free*
treelookupgt(Free *t, ulong size)
{
    Free *lastgood; /* last node we saw that was big enough */

    lastgood = nil;
    for(;;) {
        if(t == nil)
            return lastgood;
        if(size == t->size)
            return t;
        if(size < t->size) {
            lastgood = t;
            t = t->left;
        } else
            t = t->right;
    }
}
@

<<function listadd>>=
/* listadd: add a node to a doubly linked list */
static Free*
listadd(Free *list, Free *node)
{
    if(list == nil) {
        node->next = node;
        node->prev = node;
        return node;
    }

    node->prev = list->prev;
    node->next = list;

    node->prev->next = node;
    node->next->prev = node;

    return list;
}
@

<<function listdelete>>=
/* listdelete: remove node from a doubly linked list */
static Free*
listdelete(Pool *p, Free *list, Free *node)
{
    if(node->next == node) {    /* singular list */
        node->prev = node->next = Poison;
        return nil;
    }
    if(node->next == nil)
        p->panic(p, "pool->next");
    if(node->prev == nil)
        p->panic(p, "pool->prev");
    node->next->prev = node->prev;
    node->prev->next = node->next;

    if(list == node)
        list = node->next;

    node->prev = node->next = Poison;
    return list;
}
@

<<function pooladd>>=
/* pooladd: add anode to the free pool */
static Free*
pooladd(Pool *p, Alloc *anode)
{
    Free *lst, *olst;
    Free *node;
    Free **parent;

    antagonism {
        memmark(_B2D(anode), 0xF7, anode->size-sizeof(Bhdr)-sizeof(Btail));
    }

    node = (Free*)anode;
    node->magic = FREE_MAGIC;
    parent = ltreewalk(&p->freeroot, node->size);
    olst = *parent;
    lst = listadd(olst, node);
    if(olst != lst) /* need to update tree */
        *parent = treeinsert(*parent, lst);
    p->curfree += node->size;
    return node;
}
@

<<function pooldel>>=
/* pooldel: remove node from the free pool */
static Alloc*
pooldel(Pool *p, Free *node)
{
    Free *lst, *olst;
    Free **parent;

    parent = ltreewalk(&p->freeroot, node->size);
    olst = *parent;
    assert(olst != nil /* pooldel */);

    lst = listdelete(p, olst, node);
    if(lst == nil)
        *parent = treedelete(*parent, olst);
    else if(lst != olst)
        *parent = treeinsert(*parent, lst);

    node->left = node->right = Poison;
    p->curfree -= node->size;

    antagonism {
        memmark(_B2D(node), 0xF9, node->size-sizeof(Bhdr)-sizeof(Btail));
    }

    node->magic = UNALLOC_MAGIC;
    return (Alloc*)node;
}
@

<<function dsize2bsize>>=
/* block allocation */
static ulong
dsize2bsize(Pool *p, ulong sz)
{
    sz += sizeof(Bhdr)+sizeof(Btail);
    if(sz < p->minblock)
        sz = p->minblock;
    if(sz < MINBLOCKSIZE)
        sz = MINBLOCKSIZE;
    sz = (sz+p->quantum-1)&~(p->quantum-1);
    return sz;
}
@

<<function bsize2asize>>=
static ulong
bsize2asize(Pool *p, ulong sz)
{
    sz += sizeof(Arena)+sizeof(Btail);
    if(sz < p->minarena)
        sz = p->minarena;
    sz = (sz+p->quantum)&~(p->quantum-1);
    return sz;
}
@

<<function blockmerge>>=
/* both are removed from pool if necessary. */
static Alloc*
blockmerge(Pool *pool, Bhdr *a, Bhdr *b)
{
    Btail *t;

    assert(B2NB(a) == b);

    if(a->magic == FREE_MAGIC)
        pooldel(pool, (Free*)a);
    if(b->magic == FREE_MAGIC)
        pooldel(pool, (Free*)b);

    t = B2T(a);
    t->size = (ulong)Poison;
    t->magic0 = NOT_MAGIC;
    t->magic1 = NOT_MAGIC;
    PSHORT(t->datasize, NOT_MAGIC);

    a->size += b->size;
    t = B2T(a);
    t->size = a->size;
    PSHORT(t->datasize, 0xFFFF);

    b->size = NOT_MAGIC;
    b->magic = NOT_MAGIC;

    a->magic = UNALLOC_MAGIC;
    return (Alloc*)a;
}
@

<<function blocksetsize>>=
/* blocksetsize: set the total size of a block, fixing tail pointers */
static Bhdr*
blocksetsize(Bhdr *b, ulong bsize)
{
    Btail *t;

    assert(b->magic != FREE_MAGIC /* blocksetsize */);

    b->size = bsize;
    t = B2T(b);
    t->size = b->size;
    t->magic0 = TAIL_MAGIC0;
    t->magic1 = TAIL_MAGIC1;
    return b;
}
@

<<function getdsize>>=
/* getdsize: return the requested data size for an allocated block */
static ulong
getdsize(Alloc *b)
{
    Btail *t;
    t = B2T(b);
    return b->size - SHORT(t->datasize);
}
@

<<function trim>>=
/* trim: trim a block down to what is needed to hold dsize bytes of user data */
Alloc*
trim(Pool *p, Alloc *b, ulong dsize)
{
    ulong extra, bsize;
    Alloc *frag;

    bsize = dsize2bsize(p, dsize);
    extra = b->size - bsize;
    if(b->size - dsize >= 0x10000 ||
      (extra >= bsize>>2 && extra >= MINBLOCKSIZE && extra >= p->minblock)) {
        blocksetsize(b, bsize);
        frag = (Alloc*) B2NB(b);

        antagonism {
            memmark(frag, 0xF1, extra);
        }

        frag->magic = UNALLOC_MAGIC;
        blocksetsize(frag, extra);
        pooladd(p, frag);
    }

    b->magic = ALLOC_MAGIC;
    blocksetdsize(p, b, dsize);
    return b;
}
@

<<function freefromfront>>=
static Alloc*
freefromfront(Pool *p, Alloc *b, ulong skip)
{
    Alloc *bb;

    skip = skip&~(p->quantum-1);
    if(skip >= 0x1000 || (skip >= b->size>>2 && skip >= MINBLOCKSIZE && skip >= p->minblock)){
        bb = (Alloc*)((uchar*)b+skip);
        blocksetsize(bb, b->size-skip);
        bb->magic = UNALLOC_MAGIC;
        blocksetsize(b, skip);
        b->magic = UNALLOC_MAGIC;
        pooladd(p, b);
        return bb;
    }
    return b;   
}
@

<<function arenasetsize>>=
/* arenasetsize: set arena size, updating tail */
static void
arenasetsize(Arena *a, ulong asize)
{
    Bhdr *atail;

    a->asize = asize;
    atail = A2TB(a);
    atail->magic = ARENATAIL_MAGIC;
    atail->size = 0;
}
@

<<function poolnewarena>>=
/* poolnewarena: allocate new arena */
static void
poolnewarena(Pool *p, ulong asize)
{
    Arena *a;
    Arena *ap, *lastap;
    Alloc *b;

    LOG(p, "newarena %lud\n", asize);
    if(p->cursize+asize > p->maxsize) {
        if(poolcompactl(p) == 0){
            LOG(p, "pool too big: %lud+%lud > %lud\n",
                p->cursize, asize, p->maxsize);
            werrstr("memory pool too large");
        }
        return;
    }

    if((a = p->alloc(asize)) == nil) {
        /* assume errstr set by p->alloc */
        return;
    }

    p->cursize += asize;

    /* arena hdr */
    a->magic = ARENA_MAGIC;
    blocksetsize(a, sizeof(Arena));
    arenasetsize(a, asize);
    blockcheck(p, a);

    /* create one large block in arena */
    b = (Alloc*)A2B(a);
    b->magic = UNALLOC_MAGIC;
    blocksetsize(b, (uchar*)A2TB(a)-(uchar*)b);
    blockcheck(p, b);
    pooladd(p, b);
    blockcheck(p, b);

    /* sort arena into descending sorted arena list */
    for(lastap=nil, ap=p->arenalist; ap > a; lastap=ap, ap=ap->down)
        ;

    if(a->down = ap)    /* assign = */
        a->down->aup = a;

    if(a->aup = lastap) /* assign = */
        a->aup->down = a;
    else
        p->arenalist = a;

    /* merge with surrounding arenas if possible */
    /* must do a with up before down with a (think about it) */
    if(a->aup)
        arenamerge(p, a, a->aup);
    if(a->down)
        arenamerge(p, a->down, a);
}
@

<<function blockgrow>>=
/* trimming it into two different blocks. */
static void
blockgrow(Pool *p, Bhdr *b, ulong nsize)
{
    if(b->magic == FREE_MAGIC) {
        Alloc *a;
        Bhdr *bnxt;
        a = pooldel(p, (Free*)b);
        blockcheck(p, a);
        blocksetsize(a, nsize);
        blockcheck(p, a);
        bnxt = B2NB(a);
        if(bnxt->magic == FREE_MAGIC)
            a = blockmerge(p, a, bnxt);
        blockcheck(p, a);
        pooladd(p, a);
    } else {
        Alloc *a;
        ulong dsize;

        a = (Alloc*)b;
        dsize = getdsize(a);
        blocksetsize(a, nsize);
        trim(p, a, dsize);
    }
}
@

<<function arenamerge>>=
/* arenamerge: attempt to coalesce to arenas that might be adjacent */
static Arena*
arenamerge(Pool *p, Arena *bot, Arena *top)
{
    Bhdr *bbot, *btop;
    Btail *t;

    blockcheck(p, bot);
    blockcheck(p, top);
    assert(bot->aup == top && top > bot);

    if(p->merge == nil || p->merge(bot, top) == 0)
        return nil;

    /* remove top from list */
    if(bot->aup = top->aup) /* assign = */
        bot->aup->down = bot;
    else
        p->arenalist = bot;
    
    /* save ptrs to last block in bot, first block in top */
    t = B2PT(A2TB(bot));
    bbot = T2HDR(t);
    btop = A2B(top);
    blockcheck(p, bbot);
    blockcheck(p, btop);

    /* grow bottom arena to encompass top */
    arenasetsize(bot, top->asize + ((uchar*)top - (uchar*)bot));

    /* grow bottom block to encompass space between arenas */
    blockgrow(p, bbot, (uchar*)btop-(uchar*)bbot);
    blockcheck(p, bbot);
    return bot;
}
@

<<function dumpblock>>=
/* dumpblock: print block's vital stats */
static void
dumpblock(Pool *p, Bhdr *b)
{
    ulong *dp;
    ulong dsize;
    uchar *cp;

    dp = (ulong*)b;
    p->print(p, "pool %s block %p\nhdr %.8lux %.8lux %.8lux %.8lux %.8lux %.8lux\n",
        p->name, b, dp[0], dp[1], dp[2], dp[3], dp[4], dp[5], dp[6]);

    dp = (ulong*)B2T(b);
    p->print(p, "tail %.8lux %.8lux %.8lux %.8lux %.8lux %.8lux | %.8lux %.8lux\n",
        dp[-6], dp[-5], dp[-4], dp[-3], dp[-2], dp[-1], dp[0], dp[1]);

    if(b->magic == ALLOC_MAGIC){
        dsize = getdsize((Alloc*)b);
        if(dsize >= b->size)    /* user data size corrupt */
            return;

        cp = (uchar*)_B2D(b)+dsize;
        p->print(p, "user data ");
        p->print(p, "%.2ux %.2ux %.2ux %.2ux  %.2ux %.2ux %.2ux %.2ux",
            cp[-8], cp[-7], cp[-6], cp[-5], cp[-4], cp[-3], cp[-2], cp[-1]);
        p->print(p, " | %.2ux %.2ux %.2ux %.2ux  %.2ux %.2ux %.2ux %.2ux\n",
            cp[0], cp[1], cp[2], cp[3], cp[4], cp[5], cp[6], cp[7]);
    }
}
@

<<function printblock>>=
static void
printblock(Pool *p, Bhdr *b, char *msg)
{
    p->print(p, "%s\n", msg);
    dumpblock(p, b);
}
@

<<function panicblock>>=
static void
panicblock(Pool *p, Bhdr *b, char *msg)
{
    p->print(p, "%s\n", msg);
    dumpblock(p, b);
    p->panic(p, "pool panic");
}
@

<<function blockcheck>>=
/* should only be called when holding pool lock */
static void
blockcheck(Pool *p, Bhdr *b)
{
    Alloc *a;
    Btail *t;
    int i, n;
    uchar *q, *bq, *eq;
    ulong dsize;

    switch(b->magic) {
    default:
        panicblock(p, b, "bad magic");
    case FREE_MAGIC:
    case UNALLOC_MAGIC:
        t = B2T(b);
        if(t->magic0 != TAIL_MAGIC0 || t->magic1 != TAIL_MAGIC1)
            panicblock(p, b, "corrupt tail magic");
        if(T2HDR(t) != b)
            panicblock(p, b, "corrupt tail ptr");
        break;
    case DEAD_MAGIC:
        t = B2T(b);
        if(t->magic0 != TAIL_MAGIC0 || t->magic1 != TAIL_MAGIC1)
            panicblock(p, b, "corrupt tail magic");
        if(T2HDR(t) != b)
            panicblock(p, b, "corrupt tail ptr");
        n = getdsize((Alloc*)b);
        q = _B2D(b);
        q += 8;
        for(i=8; i<n; i++)
            if(*q++ != 0xDA)
                panicblock(p, b, "dangling pointer write");
        break;
    case ARENA_MAGIC:
        b = A2TB((Arena*)b);
        if(b->magic != ARENATAIL_MAGIC)
            panicblock(p, b, "bad arena size");
        /* fall through */
    case ARENATAIL_MAGIC:
        if(b->size != 0)
            panicblock(p, b, "bad arena tail size");
        break;
    case ALLOC_MAGIC:
        a = (Alloc*)b;
        t = B2T(b);
        dsize = getdsize(a);
        bq = (uchar*)_B2D(a)+dsize;
        eq = (uchar*)t;

        if(t->magic0 != TAIL_MAGIC0){
            /* if someone wrote exactly one byte over and it was a NUL, we sometimes only complain. */
            if((p->flags & POOL_TOLERANCE) && bq == eq && t->magic0 == 0)
                printblock(p, b, "mem user overflow (magic0)");
            else
                panicblock(p, b, "corrupt tail magic0");
        }

        if(t->magic1 != TAIL_MAGIC1)
            panicblock(p, b, "corrupt tail magic1");
        if(T2HDR(t) != b)
            panicblock(p, b, "corrupt tail ptr");

        if(dsize2bsize(p, dsize)  > a->size)
            panicblock(p, b, "too much block data");

        if(eq > bq+4)
            eq = bq+4;
        for(q=bq; q<eq; q++){
            if(*q != datamagic[((uintptr)q)%nelem(datamagic)]){
                if(q == bq && *q == 0 && (p->flags & POOL_TOLERANCE)){
                    printblock(p, b, "mem user overflow");
                    continue;
                }
                panicblock(p, b, "mem user overflow");
            }
        }
        break;
    }
}
@

<<enum _anon_ (port/pool.c)8>>=
/*
 * compact an arena by shifting all the free blocks to the end.
 * assumes pool lock is held.
 */
enum {
    FLOATING_MAGIC = 0xCBCBCBCB,    /* temporarily neither allocated nor in the free tree */
};
@

<<function arenacompact>>=
static int
arenacompact(Pool *p, Arena *a)
{
    Bhdr *b, *wb, *eb, *nxt;
    int compacted;

    if(p->move == nil)
        p->panic(p, "don't call me when pool->move is nil\n");

    poolcheckarena(p, a);
    eb = A2TB(a);
    compacted = 0;
    for(b=wb=A2B(a); b && b < eb; b=nxt) {
        nxt = B2NB(b);
        switch(b->magic) {
        case FREE_MAGIC:
            pooldel(p, (Free*)b);
            b->magic = FLOATING_MAGIC;
            break;
        case ALLOC_MAGIC:
            if(wb != b) {
                memmove(wb, b, b->size);
                p->move(_B2D(b), _B2D(wb));
                compacted = 1;
            }
            wb = B2NB(wb);
            break;
        }
    }

    /*
     * the only free data is now at the end of the arena, pointed
     * at by wb.  all we need to do is set its size and get out.
     */
    if(wb < eb) {
        wb->magic = UNALLOC_MAGIC;
        blocksetsize(wb, (uchar*)eb-(uchar*)wb);
        pooladd(p, (Alloc*)wb);
    }

    return compacted;       
}
@

<<function poolcompactl>>=
/*
 * compact a pool by compacting each individual arena.
 * 'twould be nice to shift blocks from one arena to the
 * next but it's a pain to code.
 */
static int
poolcompactl(Pool *pool)
{
    Arena *a;
    int compacted;

    if(pool->move == nil || pool->lastcompact == pool->nfree)
        return 0;

    pool->lastcompact = pool->nfree;
    compacted = 0;
    for(a=pool->arenalist; a; a=a->down)
        compacted |= arenacompact(pool, a);
    return compacted;
}
@

<<function B2D>>=
/*
static void*
_B2D(void *a)
{
    return (uchar*)a+sizeof(Bhdr);
}
*/

static void*
B2D(Pool *p, Alloc *a)
{
    if(a->magic != ALLOC_MAGIC)
        p->panic(p, "B2D called on unworthy block");
    return _B2D(a);
}
@

<<function D2B>>=
/*
static void*
_D2B(void *v)
{
    Alloc *a;
    a = (Alloc*)((uchar*)v-sizeof(Bhdr));
    return a;
}
*/

static Alloc*
D2B(Pool *p, void *v)
{
    Alloc *a;
    ulong *u;

    if((uintptr)v&(sizeof(ulong)-1))
        v = (char*)v - ((uintptr)v&(sizeof(ulong)-1));
    u = v;
    while(u[-1] == ALIGN_MAGIC)
        u--;
    a = _D2B(u);
    if(a->magic != ALLOC_MAGIC)
        p->panic(p, "D2B called on non-block %p (double-free?)", v);
    return a;
}
@

<<function poolallocl>>=
/* poolallocl: attempt to allocate block to hold dsize user bytes; assumes lock held */
static void*
poolallocl(Pool *p, ulong dsize)
{
    ulong bsize;
    Free *fb;
    Alloc *ab;

    if(dsize >= 0x80000000UL){  /* for sanity, overflow */
        werrstr("invalid allocation size");
        return nil;
    }

    bsize = dsize2bsize(p, dsize);

    fb = treelookupgt(p->freeroot, bsize);
    if(fb == nil) {
        poolnewarena(p, bsize2asize(p, bsize));
        if((fb = treelookupgt(p->freeroot, bsize)) == nil) {
            /* assume poolnewarena failed and set %r */
            return nil;
        }
    }

    ab = trim(p, pooldel(p, fb), dsize);
    p->curalloc += ab->size;
    antagonism {
        memset(B2D(p, ab), 0xDF, dsize);
    }
    return B2D(p, ab);
}
@

<<function poolreallocl>>=
/* poolreallocl: attempt to grow v to ndsize bytes; assumes lock held */
static void*
poolreallocl(Pool *p, void *v, ulong ndsize)
{
    Alloc *a;
    Bhdr *left, *right, *newb;
    Btail *t;
    ulong nbsize;
    ulong odsize;
    ulong obsize;
    void *nv;

    if(v == nil)    /* for ANSI */
        return poolallocl(p, ndsize);
    if(ndsize == 0) {
        poolfreel(p, v);
        return nil;
    }
    a = D2B(p, v);
    blockcheck(p, a);
    odsize = getdsize(a);
    obsize = a->size;

    /* can reuse the same block? */
    nbsize = dsize2bsize(p, ndsize);
    if(nbsize <= a->size) {
    Returnblock:
        if(v != _B2D(a))
            memmove(_B2D(a), v, odsize);
        a = trim(p, a, ndsize);
        p->curalloc -= obsize;
        p->curalloc += a->size;
        v = B2D(p, a);
        return v;
    }

    /* can merge with surrounding blocks? */
    right = B2NB(a);
    if(right->magic == FREE_MAGIC && a->size+right->size >= nbsize) {
        a = blockmerge(p, a, right);
        goto Returnblock;
    }

    t = B2PT(a);
    left = T2HDR(t);
    if(left->magic == FREE_MAGIC && left->size+a->size >= nbsize) {
        a = blockmerge(p, left, a);
        goto Returnblock;
    }

    if(left->magic == FREE_MAGIC && right->magic == FREE_MAGIC
    && left->size+a->size+right->size >= nbsize) {
        a = blockmerge(p, blockmerge(p, left, a), right);
        goto Returnblock;
    }

    if((nv = poolallocl(p, ndsize)) == nil)
        return nil;

    /* maybe the new block is next to us; if so, merge */
    left = T2HDR(B2PT(a));
    right = B2NB(a);
    newb = D2B(p, nv);
    if(left == newb || right == newb) {
        if(left == newb || left->magic == FREE_MAGIC)
            a = blockmerge(p, left, a);
        if(right == newb || right->magic == FREE_MAGIC)
            a = blockmerge(p, a, right);
        assert(a->size >= nbsize);
        goto Returnblock;
    }

    /* enough cleverness */
    memmove(nv, v, odsize);
    antagonism { 
        memset((char*)nv+odsize, 0xDE, ndsize-odsize);
    }
    poolfreel(p, v);
    return nv;
}
@

<<function alignptr>>=
static void*
alignptr(void *v, ulong align, long offset)
{
    char *c;
    ulong off;

    c = v;
    if(align){
        off = (uintptr)c%align;
        if(off != offset){
            c += offset - off;
            if(off > offset)
                c += align;
        }
    }
    return c;
}
@

<<function poolallocalignl>>=
/* poolallocalignl: allocate as described below; assumes pool locked */
static void*
poolallocalignl(Pool *p, ulong dsize, ulong align, long offset, ulong span)
{
    ulong asize;
    void *v;
    char *c;
    ulong *u;
    int skip;
    Alloc *b;

    /*
     * allocate block
     *  dsize bytes
     *  addr == offset (modulo align)
     *  does not cross span-byte block boundary
     *
     * to satisfy alignment, just allocate an extra
     * align bytes and then shift appropriately.
     * 
     * to satisfy span, try once and see if we're
     * lucky.  the second time, allocate 2x asize
     * so that we definitely get one not crossing
     * the boundary.
     */
    if(align){
        if(offset < 0)
            offset = align - ((-offset)%align);
        else
            offset %= align;
    }
    asize = dsize+align;
    v = poolallocl(p, asize);
    if(v == nil)
        return nil;
    if(span && (uintptr)v/span != ((uintptr)v+asize)/span){
        /* try again */
        poolfreel(p, v);
        v = poolallocl(p, 2*asize);
        if(v == nil)
            return nil;
    }

    /*
     * figure out what pointer we want to return
     */
    c = alignptr(v, align, offset);
    if(span && (uintptr)c/span != (uintptr)(c+dsize-1)/span){
        c += span - (uintptr)c%span;
        c = alignptr(c, align, offset);
        if((uintptr)c/span != (uintptr)(c+dsize-1)/span){
            poolfreel(p, v);
            werrstr("cannot satisfy dsize %lud span %lud with align %lud+%ld", dsize, span, align, offset);
            return nil;
        }
    }
    skip = c - (char*)v;

    /*
     * free up the skip bytes before that pointer
     * or mark it as unavailable.
     */
    b = _D2B(v);
    b = freefromfront(p, b, skip);
    v = _B2D(b);
    skip = c - (char*)v;
    if(c > (char*)v){
        u = v;
        while(c >= (char*)u+sizeof(ulong))
            *u++ = ALIGN_MAGIC;
    }
    trim(p, b, skip+dsize);
    assert(D2B(p, c) == b);
    antagonism { 
        memset(c, 0xDD, dsize);
    }
    return c;
}
@

<<function poolfreel>>=
/* poolfree: free block obtained from poolalloc; assumes lock held */
static void
poolfreel(Pool *p, void *v)
{
    Alloc *ab;
    Bhdr *back, *fwd;

    if(v == nil)    /* for ANSI */
        return;

    ab = D2B(p, v);
    blockcheck(p, ab);

    if(p->flags&POOL_NOREUSE){
        int n;

        ab->magic = DEAD_MAGIC;
        n = getdsize(ab)-8;
        if(n > 0)
            memset((uchar*)v+8, 0xDA, n);
        return; 
    }

    p->nfree++;
    p->curalloc -= ab->size;
    back = T2HDR(B2PT(ab));
    if(back->magic == FREE_MAGIC)
        ab = blockmerge(p, back, ab);

    fwd = B2NB(ab);
    if(fwd->magic == FREE_MAGIC)
        ab = blockmerge(p, ab, fwd);

    pooladd(p, ab);
}
@

<<function poolalloc>>=
void*
poolalloc(Pool *p, ulong n)
{
    void *v;

    p->lock(p);
    paranoia {
        poolcheckl(p);
    }
    verbosity {
        pooldumpl(p);
    }
    v = poolallocl(p, n);
    paranoia {
        poolcheckl(p);
    }
    verbosity {
        pooldumpl(p);
    }
    if(p->logstack && (p->flags & POOL_LOGGING)) p->logstack(p);
    LOG(p, "poolalloc %p %lud = %p\n", p, n, v);
    p->unlock(p);
    return v;
}
@

<<function poolallocalign>>=
void*
poolallocalign(Pool *p, ulong n, ulong align, long offset, ulong span)
{
    void *v;

    p->lock(p);
    paranoia {
        poolcheckl(p);
    }
    verbosity {
        pooldumpl(p);
    }
    v = poolallocalignl(p, n, align, offset, span);
    paranoia {
        poolcheckl(p);
    }
    verbosity {
        pooldumpl(p);
    }
    if(p->logstack && (p->flags & POOL_LOGGING)) p->logstack(p);
    LOG(p, "poolalignspanalloc %p %lud %lud %lud %ld = %p\n", p, n, align, span, offset, v);
    p->unlock(p);
    return v;
}
@

<<function poolcompact>>=
int
poolcompact(Pool *p)
{
    int rv;

    p->lock(p);
    paranoia {
        poolcheckl(p);
    }
    verbosity {
        pooldumpl(p);
    }
    rv = poolcompactl(p);
    paranoia {
        poolcheckl(p);
    }
    verbosity {
        pooldumpl(p);
    }
    LOG(p, "poolcompact %p\n", p);
    p->unlock(p);
    return rv;
}
@

<<function poolrealloc>>=
void*
poolrealloc(Pool *p, void *v, ulong n)
{
    void *nv;

    p->lock(p);
    paranoia {
        poolcheckl(p);
    }
    verbosity {
        pooldumpl(p);
    }
    nv = poolreallocl(p, v, n);
    paranoia {
        poolcheckl(p);
    }
    verbosity {
        pooldumpl(p);
    }
    if(p->logstack && (p->flags & POOL_LOGGING)) p->logstack(p);
    LOG(p, "poolrealloc %p %p %ld = %p\n", p, v, n, nv);
    p->unlock(p);
    return nv;
}
@

<<function poolfree>>=
void
poolfree(Pool *p, void *v)
{
    p->lock(p);
    paranoia {
        poolcheckl(p);
    }
    verbosity {
        pooldumpl(p);
    }
    poolfreel(p, v);
    paranoia {
        poolcheckl(p);
    }
    verbosity {
        pooldumpl(p);
    }
    if(p->logstack && (p->flags & POOL_LOGGING)) p->logstack(p);
    LOG(p, "poolfree %p %p\n", p, v);
    p->unlock(p);
}
@

<<function poolmsize>>=
/*
 * Return the real size of a block, and let the user use it. 
 */
ulong
poolmsize(Pool *p, void *v)
{
    Alloc *b;
    ulong dsize;

    p->lock(p);
    paranoia {
        poolcheckl(p);
    }
    verbosity {
        pooldumpl(p);
    }
    if(v == nil)    /* consistency with other braindead ANSI-ness */
        dsize = 0;
    else {
        b = D2B(p, v);
        dsize = (b->size&~(p->quantum-1)) - sizeof(Bhdr) - sizeof(Btail);
        assert(dsize >= getdsize(b));
        blocksetdsize(p, b, dsize);
    }
    paranoia {
        poolcheckl(p);
    }
    verbosity {
        pooldumpl(p);
    }
    if(p->logstack && (p->flags & POOL_LOGGING)) p->logstack(p);
    LOG(p, "poolmsize %p %p = %ld\n", p, v, dsize);
    p->unlock(p);
    return dsize;
}
@

<<function poolcheckarena>>=
/*
 * Debugging 
 */

static void
poolcheckarena(Pool *p, Arena *a)
{
    Bhdr *b;
    Bhdr *atail;

    atail = A2TB(a);
    for(b=a; b->magic != ARENATAIL_MAGIC && b<atail; b=B2NB(b))
        blockcheck(p, b);
    blockcheck(p, b);
    if(b != atail)
        p->panic(p, "found wrong tail");
}
@

<<function poolcheckl>>=
static void
poolcheckl(Pool *p)
{
    Arena *a;

    for(a=p->arenalist; a; a=a->down)
        poolcheckarena(p, a);
    if(p->freeroot)
        checktree(p->freeroot, 0, 1<<30);
}
@

<<function poolcheck>>=
void
poolcheck(Pool *p)
{
    p->lock(p);
    poolcheckl(p);
    p->unlock(p);
}
@

<<function poolblockcheck>>=
void
poolblockcheck(Pool *p, void *v)
{
    if(v == nil)
        return;

    p->lock(p);
    blockcheck(p, D2B(p, v));
    p->unlock(p);
}
@

<<function pooldumpl>>=
static void
pooldumpl(Pool *p)
{
    Arena *a;

    p->print(p, "pool %p %s\n", p, p->name);
    for(a=p->arenalist; a; a=a->down)
        pooldumparena(p, a);
}
@

<<function pooldump>>=
void
pooldump(Pool *p)
{
    p->lock(p);
    pooldumpl(p);
    p->unlock(p);
}
@

<<function pooldumparena>>=
static void
pooldumparena(Pool *p, Arena *a)
{
    Bhdr *b;

    for(b=a; b->magic != ARENATAIL_MAGIC; b=B2NB(b))
        p->print(p, "(%p %.8lux %lud)", b, b->magic, b->size);
    p->print(p, "\n");
}
@

<<function memmark>>=
/*
 * mark the memory in such a way that we know who marked it
 * (via the signature) and we know where the marking started.
 */
static void
memmark(void *v, int sig, ulong size)
{
    uchar *p, *ep;
    ulong *lp, *elp;
    lp = v;
    elp = lp+size/4;
    while(lp < elp)
        *lp++ = (sig<<24) ^ ((uintptr)lp-(uintptr)v);
    p = (uchar*)lp;
    ep = (uchar*)v+size;
    while(p<ep)
        *p++ = sig;
}
@


%-------------------------------------------------------------

<<port/pool.c>>=
/*
 * This allocator takes blocks from a coarser allocator (p->alloc) and
 * uses them as arenas.
 * 
 * An arena is split into a sequence of blocks of variable size.  The
 * blocks begin with a Bhdr that denotes the length (including the Bhdr)
 * of the block.  An arena begins with an Arena header block (Arena,
 * ARENA_MAGIC) and ends with a Bhdr block with magic ARENATAIL_MAGIC and
 * size 0.  Intermediate blocks are either allocated or free.  At the end
 * of each intermediate block is a Btail, which contains information
 * about where the block starts.  This is useful for walking backwards.
 * 
 * Free blocks (Free*) have a magic value of FREE_MAGIC in their Bhdr
 * headers.  They are kept in a binary tree (p->freeroot) traversible by
 * walking ->left and ->right.  Each node of the binary tree is a pointer
 * to a circular doubly-linked list (next, prev) of blocks of identical
 * size.  Blocks are added to this ``tree of lists'' by pooladd(), and
 * removed by pooldel().
 * 
 * When freed, adjacent blocks are coalesced to create larger blocks when
 * possible.
 * 
 * Allocated blocks (Alloc*) have one of two magic values: ALLOC_MAGIC or
 * UNALLOC_MAGIC.  When blocks are released from the pool, they have
 * magic value UNALLOC_MAGIC.  Once the block has been trimmed by trim()
 * and the amount of user-requested data has been recorded in the
 * datasize field of the tail, the magic value is changed to ALLOC_MAGIC.
 * All blocks returned to callers should be of type ALLOC_MAGIC, as
 * should all blocks passed to us by callers.  The amount of data the user
 * asked us for can be found by subtracting the short in tail->datasize 
 * from header->size.  Further, the up to at most four bytes between the
 * end of the user-requested data block and the actual Btail structure are
 * marked with a magic value, which is checked to detect user overflow.
 * 
 * The arenas returned by p->alloc are kept in a doubly-linked list
 * (p->arenalist) running through the arena headers, sorted by descending
 * base address (prev, next).  When a new arena is allocated, we attempt
 * to merge it with its two neighbors via p->merge.
 */

#include <u.h>
#include <libc.h>
#include <pool.h>

typedef struct Alloc    Alloc;
typedef struct Arena    Arena;
typedef struct Bhdr Bhdr;
typedef struct Btail    Btail;
typedef struct Free Free;

<<struct Bhdr>>
<<enum _anon_ (port/pool.c)>>
<<macro B2NB>>

<<macro SHORT>>
<<macro PSHORT>>

<<enum _anon_ (port/pool.c)2>>
<<struct Btail>>
<<macro B2T>>
<<macro B2PT>>
<<macro T2HDR>>
<<struct Free>>
<<enum _anon_ (port/pool.c)3>>

<<struct Alloc>>
<<enum _anon_ (port/pool.c)4>>

<<struct Arena>>
<<enum _anon_ (port/pool.c)5>>
<<macro A2TB>>
<<macro A2B>>

<<enum _anon_ (port/pool.c)6>>

<<enum _anon_ (port/pool.c)7>>

<<global datamagic>>

<<constant Poison>>

<<macro _B2D>>
<<macro _D2B>>

// static void* _B2D(void*);
// static void* _D2B(void*);
static void*    B2D(Pool*, Alloc*);
static Alloc*   D2B(Pool*, void*);
static Arena*   arenamerge(Pool*, Arena*, Arena*);
static void     blockcheck(Pool*, Bhdr*);
static Alloc*   blockmerge(Pool*, Bhdr*, Bhdr*);
static Alloc*   blocksetdsize(Pool*, Alloc*, ulong);
static Bhdr*    blocksetsize(Bhdr*, ulong);
static ulong    bsize2asize(Pool*, ulong);
static ulong    dsize2bsize(Pool*, ulong);
static ulong    getdsize(Alloc*);
static Alloc*   trim(Pool*, Alloc*, ulong);
static Free*    listadd(Free*, Free*);
static void     logstack(Pool*);
static Free**   ltreewalk(Free**, ulong);
static void     memmark(void*, int, ulong);
static Free*    pooladd(Pool*, Alloc*);
static void*    poolallocl(Pool*, ulong);
static void     poolcheckl(Pool*);
static void     poolcheckarena(Pool*, Arena*);
static int      poolcompactl(Pool*);
static Alloc*   pooldel(Pool*, Free*);
static void     pooldumpl(Pool*);
static void     pooldumparena(Pool*, Arena*);
static void     poolfreel(Pool*, void*);
static void     poolnewarena(Pool*, ulong);
static void*    poolreallocl(Pool*, void*, ulong);
static Free*    treedelete(Free*, Free*);
static Free*    treeinsert(Free*, Free*);
static Free*    treelookup(Free*, ulong);
static Free*    treelookupgt(Free*, ulong);

/*
 * Debugging
 * 
 * Antagonism causes blocks to always be filled with garbage if their
 * contents are undefined.  This tickles both programs and the library.
 * It's a linear time hit but not so noticeable during nondegenerate use.
 * It would be worth leaving in except that it negates the benefits of the
 * kernel's demand-paging.  The tail magic and end-of-data magic 
 * provide most of the user-visible benefit that antagonism does anyway.
 *
 * Paranoia causes the library to recheck the entire pool on each lock
 * or unlock.  A failed check on unlock means we tripped over ourselves,
 * while a failed check on lock tends to implicate the user.  Paranoia has
 * the potential to slow things down a fair amount for pools with large
 * numbers of allocated blocks.  It completely negates all benefits won
 * by the binary tree.  Turning on paranoia in the kernel makes it painfully
 * slow.
 *
 * Verbosity induces the dumping of the pool via p->print at each lock operation.
 * By default, only one line is logged for each alloc, free, and realloc.
 */

/* the if(!x);else avoids ``dangling else'' problems */
#define antagonism  if(!(p->flags & POOL_ANTAGONISM)){}else
#define paranoia    if(!(p->flags & POOL_PARANOIA)){}else
#define verbosity   if(!(p->flags & POOL_VERBOSITY)){}else

#define DPRINT  if(!(p->flags & POOL_DEBUGGING)){}else p->print
#define LOG     if(!(p->flags & POOL_LOGGING)){}else p->print

<<function checklist>>

<<function checktree>>

<<function ltreewalk>>

<<function treelookup>>

<<function treeinsert>>

<<function treedelete>>

<<function treelookupgt>>

/* 
 * List maintenance
 */

<<function listadd>>

<<function listdelete>>

/*
 * Pool maintenance
 */

<<function pooladd>>

<<function pooldel>>

/*
 * Block maintenance 
 */
<<function dsize2bsize>>

<<function bsize2asize>>

/* blockmerge: merge a and b, known to be adjacent */
<<function blockmerge>>

<<function blocksetsize>>

<<function getdsize>>

/* blocksetdsize: set the user data size of a block */
static Alloc*
blocksetdsize(Pool *p, Alloc *b, ulong dsize)
{
    Btail *t;
    uchar *q, *eq;

    assert(b->size >= dsize2bsize(p, dsize));
    assert(b->size - dsize < 0x10000);

    t = B2T(b);
    PSHORT(t->datasize, b->size - dsize);

    q=(uchar*)_B2D(b)+dsize;
    eq = (uchar*)t;
    if(eq > q+4)
        eq = q+4;
    for(; q<eq; q++)
        *q = datamagic[((ulong)(uintptr)q)%nelem(datamagic)];

    return b;
}

<<function trim>>

<<function freefromfront>>

/*
 * Arena maintenance
 */

<<function arenasetsize>>

<<function poolnewarena>>

/* blockresize: grow a block to encompass space past its end, possibly by */
<<function blockgrow>>

<<function arenamerge>>

<<function dumpblock>>

<<function printblock>>

<<function panicblock>>

/* blockcheck: ensure a block consistent with our expectations */
<<function blockcheck>>

<<enum _anon_ (port/pool.c)8>>

<<function arenacompact>>

<<function poolcompactl>>

/*
static int
poolcompactl(Pool*)
{
    return 0;
}
*/

/*
 * Actual allocators
 */

<<function B2D>>

<<function D2B>>

<<function poolallocl>>

<<function poolreallocl>>

<<function alignptr>>

<<function poolallocalignl>>

<<function poolfreel>>

<<function poolalloc>>

<<function poolallocalign>>

<<function poolcompact>>

<<function poolrealloc>>

<<function poolfree>>

<<function poolmsize>>

<<function poolcheckarena>>

<<function poolcheckl>>

<<function poolcheck>>

<<function poolblockcheck>>

<<function pooldumpl>>

<<function pooldump>>

<<function pooldumparena>>

<<function memmark>>
@


\subsection*{[[port/pow.c]]}

<<function pow>>=
double
pow(double x, double y) /* return x ^ y (exponentiation) */
{
    double xy, y1, ye;
    long i;
    int ex, ey, flip;

    if(y == 0.0)
        return 1.0;

    flip = 0;
    if(y < 0.){
        y = -y;
        flip = 1;
    }
    y1 = modf(y, &ye);
    if(y1 != 0.0){
        if(x <= 0.)
            goto zreturn;
        if(y1 > 0.5) {
            y1 -= 1.;
            ye += 1.;
        }
        xy = exp(y1 * log(x));
    }else
        xy = 1.0;
    if(ye > 0x7FFFFFFF){    /* should be ~0UL but compiler can't convert double to ulong */
        if(x <= 0.){
 zreturn:
            if(x==0. && !flip)
                return 0.;
            return NaN();
        }
        if(flip){
            if(y == .5)
                return 1./sqrt(x);
            y = -y;
        }else if(y == .5)
            return sqrt(x);
        return exp(y * log(x));
    }
    x = frexp(x, &ex);
    ey = 0;
    i = ye;
    if(i)
        for(;;){
            if(i & 1){
                xy *= x;
                ey += ex;
            }
            i >>= 1;
            if(i == 0)
                break;
            x *= x;
            ex <<= 1;
            if(x < .5){
                x += x;
                ex -= 1;
            }
        }
    if(flip){
        xy = 1. / xy;
        ey = -ey;
    }
    return ldexp(xy, ey);
}
@


%-------------------------------------------------------------

<<port/pow.c>>=
#include <u.h>
#include <libc.h>

<<function pow>>
@


\subsection*{[[port/pow10.c]]}

<<global tab>>=
/*
 * this table might overflow 127-bit exponent representations.
 * in that case, truncate it after 1.0e38.
 * it is important to get all one can from this
 * routine since it is used in atof to scale numbers.
 * the presumption is that C converts fp numbers better
 * than multipication of lower powers of 10.
 */
static
double  tab[] =
{
    1.0e0,  1.0e1,  1.0e2,  1.0e3,  1.0e4,  1.0e5,  1.0e6,  1.0e7,  1.0e8,  1.0e9, 
    1.0e10, 1.0e11, 1.0e12, 1.0e13, 1.0e14, 1.0e15, 1.0e16, 1.0e17, 1.0e18, 1.0e19, 
    1.0e20, 1.0e21, 1.0e22, 1.0e23, 1.0e24, 1.0e25, 1.0e26, 1.0e27, 1.0e28, 1.0e29, 
    1.0e30, 1.0e31, 1.0e32, 1.0e33, 1.0e34, 1.0e35, 1.0e36, 1.0e37, 1.0e38, 1.0e39, 
    1.0e40, 1.0e41, 1.0e42, 1.0e43, 1.0e44, 1.0e45, 1.0e46, 1.0e47, 1.0e48, 1.0e49, 
    1.0e50, 1.0e51, 1.0e52, 1.0e53, 1.0e54, 1.0e55, 1.0e56, 1.0e57, 1.0e58, 1.0e59, 
    1.0e60, 1.0e61, 1.0e62, 1.0e63, 1.0e64, 1.0e65, 1.0e66, 1.0e67, 1.0e68, 1.0e69, 
    1.0e70, 1.0e71, 1.0e72, 1.0e73, 1.0e74, 1.0e75, 1.0e76, 1.0e77, 1.0e78, 1.0e79, 
    1.0e80, 1.0e81, 1.0e82, 1.0e83, 1.0e84, 1.0e85, 1.0e86, 1.0e87, 1.0e88, 1.0e89, 
    1.0e90, 1.0e91, 1.0e92, 1.0e93, 1.0e94, 1.0e95, 1.0e96, 1.0e97, 1.0e98, 1.0e99, 
    1.0e100,1.0e101,1.0e102,1.0e103,1.0e104,1.0e105,1.0e106,1.0e107,1.0e108,1.0e109,
    1.0e110,1.0e111,1.0e112,1.0e113,1.0e114,1.0e115,1.0e116,1.0e117,1.0e118,1.0e119,
    1.0e120,1.0e121,1.0e122,1.0e123,1.0e124,1.0e125,1.0e126,1.0e127,1.0e128,1.0e129,
    1.0e130,1.0e131,1.0e132,1.0e133,1.0e134,1.0e135,1.0e136,1.0e137,1.0e138,1.0e139,
    1.0e140,1.0e141,1.0e142,1.0e143,1.0e144,1.0e145,1.0e146,1.0e147,1.0e148,1.0e149,
    1.0e150,1.0e151,1.0e152,1.0e153,1.0e154,1.0e155,1.0e156,1.0e157,1.0e158,1.0e159,
};
@

<<function pow10>>=
double
pow10(int n)
{
    int m;

    if(n < 0) {
        n = -n;
        if(n < sizeof(tab)/sizeof(tab[0]))
            return 1/tab[n];
        m = n/2;
        return 1/(pow10(m) * pow10(n-m));
    }
    if(n < sizeof(tab)/sizeof(tab[0]))
        return tab[n];
    m = n/2;
    return pow10(m) * pow10(n-m);
}
@


%-------------------------------------------------------------

<<port/pow10.c>>=
#include    <u.h>
#include    <libc.h>

<<global tab>>

<<function pow10>>
@


\subsection*{[[port/profile.c]]}

<<global khz>>=
static  ulong   khz;
@

<<global perr>>=
static  ulong   perr;
@

<<global havecycles>>=
static  int havecycles;
@

<<struct Plink>>=
struct  Plink
{
    Plink   *old;
    Plink   *down;
    Plink   *link;
    long    pc;
    long    count;
    vlong time;
};
@

<<function _profin>>=
// Called at every procedure entry when use 5l -p, see Linker.nw
ulong
_profin(void)
{
    void *dummy;
    long pc;
    Plink *pp, *p;
    ulong arg;
    vlong t;

    arg = _savearg();
    pc = _callpc(&dummy);
    pp = _tos->prof.pp;
    if(pp == 0 || (_tos->prof.pid && _tos->pid != _tos->prof.pid))
        return arg;

    for(p=pp->down; p; p=p->link)
        if(p->pc == pc)
            goto out;
    p = _tos->prof.next + 1;
    if(p >= _tos->prof.last) {
        _tos->prof.pp = 0;
        perr++;
        return arg;
    }
    _tos->prof.next = p;
    p->link = pp->down;
    pp->down = p;
    p->pc = pc;
    p->old = pp;
    p->down = 0;
    p->count = 0;
    p->time = 0LL;

out:
    _tos->prof.pp = p;
    p->count++;
    switch(_tos->prof.what){
    case Profkernel:
        p->time = p->time - _tos->pcycles;
        goto proftime;
    case Profuser:
        /* Add kernel cycles on proc entry */
        p->time = p->time + _tos->kcycles;
        /* fall through */
    case Proftime:  
    proftime:       /* Subtract cycle counter on proc entry */
        cycles((uvlong*)&t);
        p->time = p->time - t;
        break;
    case Profsample:
        p->time = p->time - _tos->clock;
        break;
    }
    return arg;     /* disgusting linkage */
}
@

<<function _profout>>=
// Called at every procedure return when use 5l -p, see Linker.nw
ulong
_profout(void)
{
    Plink *p;
    ulong arg;
    vlong t;

    arg = _savearg();
    p = _tos->prof.pp;
    if (p == nil || (_tos->prof.pid != 0 && _tos->pid != _tos->prof.pid))
        return arg; /* Not our process */
    switch(_tos->prof.what){
    case Profkernel:        /* Add proc cycles on proc entry */
        p->time = p->time + _tos->pcycles;
        goto proftime;
    case Profuser:          /* Subtract kernel cycles on proc entry */
        p->time = p->time - _tos->kcycles;
        /* fall through */
    case Proftime:  
    proftime:               /* Add cycle counter on proc entry */
        cycles((uvlong*)&t);
        p->time = p->time + t;
        break;
    case Profsample:
        p->time = p->time + _tos->clock;
        break;
    }
    _tos->prof.pp = p->old;
    return arg;
}
@

<<function _profdump>>=
// called by??
void
_profdump(void)
{
    int f;
    long n;
    Plink *p;
    char *vp;
    char filename[64];

    if (_tos->prof.what == 0)
        return; /* No profiling */
    if (_tos->prof.pid != 0 && _tos->pid != _tos->prof.pid)
        return; /* Not our process */
    if(perr)
        fprint(2, "%lud Prof errors\n", perr);
    _tos->prof.pp = nil;
    if (_tos->prof.pid)
        snprint(filename, sizeof filename - 1, "prof.%ld", _tos->prof.pid);
    else
        snprint(filename, sizeof filename - 1, "prof.out");
    f = create(filename, 1, 0666);
    if(f < 0) {
        perror("create prof.out");
        return;
    }
    _tos->prof.pid = ~0;    /* make sure data gets dumped once */
    switch(_tos->prof.what){
    case Profkernel:
        cycles((uvlong*)&_tos->prof.first->time);
        _tos->prof.first->time = _tos->prof.first->time + _tos->pcycles;
        break;
    case Profuser:
        cycles((uvlong*)&_tos->prof.first->time);
        _tos->prof.first->time = _tos->prof.first->time - _tos->kcycles;
        break;
    case Proftime:
        cycles((uvlong*)&_tos->prof.first->time);
        break;
    case Profsample:
        _tos->prof.first->time = _tos->clock;
        break;
    }
    vp = (char*)_tos->prof.first;

    for(p = _tos->prof.first; p <= _tos->prof.next; p++) {

        /*
         * short down
         */
        n = 0xffff;
        if(p->down)
            n = p->down - _tos->prof.first;
        vp[0] = n>>8;
        vp[1] = n;

        /*
         * short right
         */
        n = 0xffff;
        if(p->link)
            n = p->link - _tos->prof.first;
        vp[2] = n>>8;
        vp[3] = n;
        vp += 4;

        /*
         * long pc
         */
        n = p->pc;
        vp[0] = n>>24;
        vp[1] = n>>16;
        vp[2] = n>>8;
        vp[3] = n;
        vp += 4;

        /*
         * long count
         */
        n = p->count;
        vp[0] = n>>24;
        vp[1] = n>>16;
        vp[2] = n>>8;
        vp[3] = n;
        vp += 4;

        /*
         * vlong time
         */
        if (havecycles){
            n = (vlong)(p->time / (vlong)khz);
        }else
            n = p->time;

        vp[0] = n>>24;
        vp[1] = n>>16;
        vp[2] = n>>8;
        vp[3] = n;
        vp += 4;
    }
    write(f, (char*)_tos->prof.first, vp - (char*)_tos->prof.first);
    close(f);
}
@

<<function _profinit>>=
void
_profinit(int entries, int what)
{
    if (_tos->prof.what == 0)
        return; /* Profiling not linked in */
    _tos->prof.pp = nil;
    _tos->prof.first = mallocz(entries*sizeof(Plink),1);
    _tos->prof.last = _tos->prof.first + entries;
    _tos->prof.next = _tos->prof.first;
    _tos->prof.pid = _tos->pid;
    _tos->prof.what = what;
    _tos->clock = 1;
}
@

<<function _profmain>>=
// called by _mainp in _main9p.s when 5l -p, see Linker
void
_profmain(void)
{
    char ename[50];
    int n, f;

    n = 2000;
    if (_tos->cyclefreq != 0LL){
        khz = _tos->cyclefreq / 1000;   /* Report times in milliseconds */
        havecycles = 1;
    }
    f = open("/env/profsize", OREAD);
    if(f >= 0) {
        memset(ename, 0, sizeof(ename));
        read(f, ename, sizeof(ename)-1);
        close(f);
        n = atol(ename);
    }
    _tos->prof.what = Profuser;
    f = open("/env/proftype", OREAD);
    if(f >= 0) {
        memset(ename, 0, sizeof(ename));
        read(f, ename, sizeof(ename)-1);
        close(f);
        if (strcmp(ename, "user") == 0)
            _tos->prof.what = Profuser;
        else if (strcmp(ename, "kernel") == 0)
            _tos->prof.what = Profkernel;
        else if (strcmp(ename, "elapsed") == 0 || strcmp(ename, "time") == 0)
            _tos->prof.what = Proftime;
        else if (strcmp(ename, "sample") == 0)
            _tos->prof.what = Profsample;
    }
    _tos->prof.first = sbrk(n*sizeof(Plink));
    _tos->prof.last = sbrk(0);
    _tos->prof.next = _tos->prof.first;
    _tos->prof.pp = nil;
    _tos->prof.pid = _tos->pid;
    atexit(_profdump);
    _tos->clock = 1;
}
@

<<function prof>>=
void
prof(void (*fn)(void*), void *arg, int entries, int what)
{
    _profinit(entries, what);
    _tos->prof.pp = _tos->prof.next;
    fn(arg);
    _profdump();
}
@


%-------------------------------------------------------------

<<port/profile.c>>=
#include    <u.h>
#include    <libc.h>
#include    <tos.h>

extern  long    _callpc(void**);
extern  long    _savearg(void);

<<global khz>>
<<global perr>>
<<global havecycles>>

typedef struct  Plink   Plink;
<<struct Plink>>

#pragma profile off

<<function _profin>>

<<function _profout>>

<<function _profdump>>

<<function _profinit>>

<<function _profmain>>

<<function prof>>

#pragma profile on

@


\subsection*{[[port/qsort.c]]}

<<function swapb>>=
static  void
swapb(char *i, char *j, long es)
{
    char c;

    do {
        c = *i;
        *i++ = *j;
        *j++ = c;
        es--;
    } while(es != 0);

}
@

<<function swapi>>=
static  void
swapi(char *ii, char *ij, long es)
{
    long *i, *j, c;

    i = (long*)ii;
    j = (long*)ij;
    do {
        c = *i;
        *i++ = *j;
        *j++ = c;
        es -= sizeof(long);
    } while(es != 0);
}
@

<<function pivot>>=
static  char*
pivot(char *a, long n, Sort *p)
{
    long j;
    char *pi, *pj, *pk;

    j = n/6 * p->es;
    pi = a + j; /* 1/6 */
    j += j;
    pj = pi + j;    /* 1/2 */
    pk = pj + j;    /* 5/6 */
    if(p->cmp(pi, pj) < 0) {
        if(p->cmp(pi, pk) < 0) {
            if(p->cmp(pj, pk) < 0)
                return pj;
            return pk;
        }
        return pi;
    }
    if(p->cmp(pj, pk) < 0) {
        if(p->cmp(pi, pk) < 0)
            return pi;
        return pk;
    }
    return pj;
}
@

<<function qsorts>>=
static  void
qsorts(char *a, long n, Sort *p)
{
    long j, es;
    char *pi, *pj, *pn;

    es = p->es;
    while(n > 1) {
        if(n > 10) {
            pi = pivot(a, n, p);
        } else
            pi = a + (n>>1)*es;

        p->swap(a, pi, es);
        pi = a;
        pn = a + n*es;
        pj = pn;
        for(;;) {
            do
                pi += es;
            while(pi < pn && p->cmp(pi, a) < 0);
            do
                pj -= es;
            while(pj > a && p->cmp(pj, a) > 0);
            if(pj < pi)
                break;
            p->swap(pi, pj, es);
        }
        p->swap(a, pj, es);
        j = (pj - a) / es;

        n = n-j-1;
        if(j >= n) {
            qsorts(a, j, p);
            a += (j+1)*es;
        } else {
            qsorts(a + (j+1)*es, n, p);
            n = j;
        }
    }
}
@

<<function qsort>>=
void
qsort(void *va, long n, long es, int (*cmp)(void*, void*))
{
    Sort s;

    s.cmp = cmp;
    s.es = es;
    s.swap = swapi;
    if(((uintptr)va | es) % sizeof(long))
        s.swap = swapb;
    qsorts((char*)va, n, &s);
}
@


%-------------------------------------------------------------

<<port/qsort.c>>=
/*
 * qsort -- simple quicksort
 */

#include <u.h>

typedef
struct
{
    int (*cmp)(void*, void*);
    void    (*swap)(char*, char*, long);
    long    es;
} Sort;

<<function swapb>>

<<function swapi>>

<<function pivot>>

<<function qsorts>>

<<function qsort>>
@


\subsection*{[[port/quote.c]]}

<<global doquote>>=
int (*doquote)(int);
@

<<function unquotestrdup>>=
char*
unquotestrdup(char *s)
{
    char *t, *ret;
    int quoting;

    ret = s = strdup(s);    /* return unquoted copy */
    if(ret == nil)
        return ret;
    quoting = 0;
    t = s;  /* s is output string, t is input string */
    while(*t!='\0' && (quoting || (*t!=' ' && *t!='\t'))){
        if(*t != '\''){
            *s++ = *t++;
            continue;
        }
        /* *t is a quote */
        if(!quoting){
            quoting = 1;
            t++;
            continue;
        }
        /* quoting and we're on a quote */
        if(t[1] != '\''){
            /* end of quoted section; absorb closing quote */
            t++;
            quoting = 0;
            continue;
        }
        /* doubled quote; fold one quote into two */
        t++;
        *s++ = *t++;
    }
    if(t != s)
        memmove(s, t, strlen(t)+1);
    return ret;
}
@

<<function unquoterunestrdup>>=
Rune*
unquoterunestrdup(Rune *s)
{
    Rune *t, *ret;
    int quoting;

    ret = s = runestrdup(s);    /* return unquoted copy */
    if(ret == nil)
        return ret;
    quoting = 0;
    t = s;  /* s is output string, t is input string */
    while(*t!='\0' && (quoting || (*t!=' ' && *t!='\t'))){
        if(*t != '\''){
            *s++ = *t++;
            continue;
        }
        /* *t is a quote */
        if(!quoting){
            quoting = 1;
            t++;
            continue;
        }
        /* quoting and we're on a quote */
        if(t[1] != '\''){
            /* end of quoted section; absorb closing quote */
            t++;
            quoting = 0;
            continue;
        }
        /* doubled quote; fold one quote into two */
        t++;
        *s++ = *t++;
    }
    if(t != s)
        memmove(s, t, (runestrlen(t)+1)*sizeof(Rune));
    return ret;
}
@

<<function quotestrdup>>=
char*
quotestrdup(char *s)
{
    char *t, *u, *ret;
    int quotelen;
    Rune r;

    if(_needsquotes(s, &quotelen) == 0)
        return strdup(s);
    
    ret = malloc(quotelen+1);
    if(ret == nil)
        return nil;
    u = ret;
    *u++ = '\'';
    for(t=s; *t; t++){
        r = *t;
        if(r == L'\'')
            *u++ = r;   /* double the quote */
        *u++ = r;
    }
    *u++ = '\'';
    *u = '\0';
    return ret;
}
@

<<function quoterunestrdup>>=
Rune*
quoterunestrdup(Rune *s)
{
    Rune *t, *u, *ret;
    int quotelen;
    Rune r;

    if(_runeneedsquotes(s, &quotelen) == 0)
        return runestrdup(s);
    
    ret = malloc((quotelen+1)*sizeof(Rune));
    if(ret == nil)
        return nil;
    u = ret;
    *u++ = '\'';
    for(t=s; *t; t++){
        r = *t;
        if(r == L'\'')
            *u++ = r;   /* double the quote */
        *u++ = r;
    }
    *u++ = '\'';
    *u = '\0';
    return ret;
}
@


%-------------------------------------------------------------

<<port/quote.c>>=
#include <u.h>
#include <libc.h>

<<global doquote>>

extern int _needsquotes(char*, int*);
extern int _runeneedsquotes(Rune*, int*);

<<function unquotestrdup>>

<<function unquoterunestrdup>>

<<function quotestrdup>>

<<function quoterunestrdup>>
@


\subsection*{[[port/rand.c]]}

<<function rand>>=
int
rand(void)
{
    return lrand() & 0x7fff;
}
@


%-------------------------------------------------------------

<<port/rand.c>>=
#include    <u.h>
#include    <libc.h>

<<function rand>>
@


\subsection*{[[port/readn.c]]}

<<function readn>>=
long
readn(int f, void *av, long n)
{
    char *a;
    long m, t;

    a = av;
    t = 0;
    while(t < n){
        m = read(f, a+t, n-t);
        if(m <= 0){
            if(t == 0)
                return m;
            break;
        }
        t += m;
    }
    return t;
}
@


%-------------------------------------------------------------

<<port/readn.c>>=
#include <u.h>
#include <libc.h>

<<function readn>>
@


\subsection*{[[port/rune.c]]}

<<macro Bit>>=
#define Bit(i) (7-(i))
@

<<macro T>>=
/* N 0's preceded by i 1's, T(Bit(2)) is 1100 0000 */
#define T(i) (((1 << (Bit(i)+1))-1) ^ 0xFF)
@

<<macro RuneX>>=
/* 0000 0000 0000 0111 1111 1111 */
#define RuneX(i) ((1 << (Bit(i) + ((i)-1)*Bitx))-1)
@

<<enum _anon_ (port/rune.c)>>=
enum
{
    Bitx    = Bit(1),

    Tx  = T(1),         /* 1000 0000 */
    Rune1 = (1<<(Bit(0)+0*Bitx))-1, /* 0000 0000 0000 0000 0111 1111 */

    Maskx   = (1<<Bitx)-1,      /* 0011 1111 */
    Testx   = Maskx ^ 0xFF,     /* 1100 0000 */

    SurrogateMin    = 0xD800,
    SurrogateMax    = 0xDFFF,

    Bad = Runeerror,
};
@

<<function chartorune>>=
int
chartorune(Rune *rune, char *str)
{
    int c[UTFmax], i;
    Rune l;

    /*
     * N character sequence
     *  00000-0007F => T1
     *  00080-007FF => T2 Tx
     *  00800-0FFFF => T3 Tx Tx
     *  10000-10FFFF => T4 Tx Tx Tx
     */

    c[0] = *(uchar*)(str);
    if(c[0] < Tx){
        *rune = c[0];
        return 1;
    }
    l = c[0];

    for(i = 1; i < UTFmax; i++) {
        c[i] = *(uchar*)(str+i);
        c[i] ^= Tx;
        if(c[i] & Testx)
            goto bad;
        l = (l << Bitx) | c[i];
        if(c[0] < T(i + 2)) {
            l &= RuneX(i + 1);
            if(i == 1) {
                if(c[0] < T(2) || l <= Rune1)
                    goto bad;
            } else if(l <= RuneX(i) || l > Runemax)
                goto bad;
            if (i == 2 && SurrogateMin <= l && l <= SurrogateMax)
                goto bad;
            *rune = l;
            return i + 1;
        }
    }

    /*
     * bad decoding
     */
bad:
    *rune = Bad;
    return 1;
}
@

<<function runetochar>>=
int
runetochar(char *str, Rune *rune)
{
    int i, j;
    Rune c;

    c = *rune;
    if(c <= Rune1) {
        str[0] = c;
        return 1;
    }

    /*
     * one character sequence
     *  00000-0007F => 00-7F
     * two character sequence
     *  0080-07FF => T2 Tx
     * three character sequence
     *  0800-FFFF => T3 Tx Tx
     * four character sequence (21-bit value)
     *     10000-1FFFFF => T4 Tx Tx Tx
     * If the Rune is out of range or a surrogate half,
     * convert it to the error rune.
     * Do this test when i==3 because the error rune encodes to three bytes.
     * Doing it earlier would duplicate work, since an out of range
     * Rune wouldn't have fit in one or two bytes.
     */
    for(i = 2; i < UTFmax + 1; i++){
        if(i == 3){
            if(c > Runemax)
                c = Runeerror;
            if(SurrogateMin <= c && c <= SurrogateMax)
                c = Runeerror;
        }
        if (c <= RuneX(i) || i == UTFmax ) {
            str[0] = T(i) |  (c >> (i - 1)*Bitx);
            for(j = 1; j < i; j++)
                str[j] = Tx | ((c >> (i - j - 1)*Bitx) & Maskx);
            return i;
        }
    }
    return UTFmax;
}
@

<<function runelen>>=
int
runelen(long c)
{
    Rune rune;
    char str[10];

    rune = c;
    return runetochar(str, &rune);
}
@

<<function runenlen>>=
int
runenlen(Rune *r, int nrune)
{
    int nb, i;
    Rune c;

    nb = 0;
    while(nrune--) {
        c = *r++;
        if(c <= Rune1){
            nb++;
        } else {
            for(i = 2; i < UTFmax + 1; i++)
                if(c <= RuneX(i) || i == UTFmax){
                    nb += i;
                    break;
                }
        }
    }
    return nb;
}
@

<<function fullrune>>=
int
fullrune(char *str, int n)
{
    int  i;
    Rune c;

    if(n <= 0)
        return 0;
    c = *(uchar*)str;
    if(c < Tx)
        return 1;
    for(i = 3; i < UTFmax + 1; i++)
        if(c < T(i))
            return n >= i - 1;
    return n >= UTFmax;
}
@


%-------------------------------------------------------------

<<port/rune.c>>=
#include    <u.h>
#include    <libc.h>

<<macro Bit>>
<<macro T>>
<<macro RuneX>>

<<enum _anon_ (port/rune.c)>>

<<function chartorune>>

<<function runetochar>>

<<function runelen>>

<<function runenlen>>

<<function fullrune>>
@


\subsection*{[[port/runebase.c]]}

<<global _base2>>=
static Rune _base2[] =
{
    0x00c0, 0x0041, /* À A */
    0x00c1, 0x0041, /* Á A */
    0x00c2, 0x0041, /* Â A */
    0x00c3, 0x0041, /* Ã A */
    0x00c4, 0x0041, /* Ä A */
    0x00c5, 0x0041, /* Å A */
    0x00c7, 0x0043, /* Ç C */
    0x00c8, 0x0045, /* È E */
    0x00c9, 0x0045, /* É E */
    0x00ca, 0x0045, /* Ê E */
    0x00cb, 0x0045, /* Ë E */
    0x00cc, 0x0049, /* Ì I */
    0x00cd, 0x0049, /* Í I */
    0x00ce, 0x0049, /* Î I */
    0x00cf, 0x0049, /* Ï I */
    0x00d1, 0x004e, /* Ñ N */
    0x00d2, 0x004f, /* Ò O */
    0x00d3, 0x004f, /* Ó O */
    0x00d4, 0x004f, /* Ô O */
    0x00d5, 0x004f, /* Õ O */
    0x00d6, 0x004f, /* Ö O */
    0x00d9, 0x0055, /* Ù U */
    0x00da, 0x0055, /* Ú U */
    0x00db, 0x0055, /* Û U */
    0x00dc, 0x0055, /* Ü U */
    0x00dd, 0x0059, /* Ý Y */
    0x00e0, 0x0061, /* à a */
    0x00e1, 0x0061, /* á a */
    0x00e2, 0x0061, /* â a */
    0x00e3, 0x0061, /* ã a */
    0x00e4, 0x0061, /* ä a */
    0x00e5, 0x0061, /* å a */
    0x00e7, 0x0063, /* ç c */
    0x00e8, 0x0065, /* è e */
    0x00e9, 0x0065, /* é e */
    0x00ea, 0x0065, /* ê e */
    0x00eb, 0x0065, /* ë e */
    0x00ec, 0x0069, /* ì i */
    0x00ed, 0x0069, /* í i */
    0x00ee, 0x0069, /* î i */
    0x00ef, 0x0069, /* ï i */
    0x00f1, 0x006e, /* ñ n */
    0x00f2, 0x006f, /* ò o */
    0x00f3, 0x006f, /* ó o */
    0x00f4, 0x006f, /* ô o */
    0x00f5, 0x006f, /* õ o */
    0x00f6, 0x006f, /* ö o */
    0x00f9, 0x0075, /* ù u */
    0x00fa, 0x0075, /* ú u */
    0x00fb, 0x0075, /* û u */
    0x00fc, 0x0075, /* ü u */
    0x00fd, 0x0079, /* ý y */
    0x00ff, 0x0079, /* ÿ y */
    0x0100, 0x0041, /* Ā A */
    0x0101, 0x0061, /* ā a */
    0x0102, 0x0041, /* Ă A */
    0x0103, 0x0061, /* ă a */
    0x0104, 0x0041, /* Ą A */
    0x0105, 0x0061, /* ą a */
    0x0106, 0x0043, /* Ć C */
    0x0107, 0x0063, /* ć c */
    0x0108, 0x0043, /* Ĉ C */
    0x0109, 0x0063, /* ĉ c */
    0x010a, 0x0043, /* Ċ C */
    0x010b, 0x0063, /* ċ c */
    0x010c, 0x0043, /* Č C */
    0x010d, 0x0063, /* č c */
    0x010e, 0x0044, /* Ď D */
    0x010f, 0x0064, /* ď d */
    0x0112, 0x0045, /* Ē E */
    0x0113, 0x0065, /* ē e */
    0x0114, 0x0045, /* Ĕ E */
    0x0115, 0x0065, /* ĕ e */
    0x0116, 0x0045, /* Ė E */
    0x0117, 0x0065, /* ė e */
    0x0118, 0x0045, /* Ę E */
    0x0119, 0x0065, /* ę e */
    0x011a, 0x0045, /* Ě E */
    0x011b, 0x0065, /* ě e */
    0x011c, 0x0047, /* Ĝ G */
    0x011d, 0x0067, /* ĝ g */
    0x011e, 0x0047, /* Ğ G */
    0x011f, 0x0067, /* ğ g */
    0x0120, 0x0047, /* Ġ G */
    0x0121, 0x0067, /* ġ g */
    0x0122, 0x0047, /* Ģ G */
    0x0123, 0x0067, /* ģ g */
    0x0124, 0x0048, /* Ĥ H */
    0x0125, 0x0068, /* ĥ h */
    0x0128, 0x0049, /* Ĩ I */
    0x0129, 0x0069, /* ĩ i */
    0x012a, 0x0049, /* Ī I */
    0x012b, 0x0069, /* ī i */
    0x012c, 0x0049, /* Ĭ I */
    0x012d, 0x0069, /* ĭ i */
    0x012e, 0x0049, /* Į I */
    0x012f, 0x0069, /* į i */
    0x0130, 0x0049, /* İ I */
    0x0134, 0x004a, /* Ĵ J */
    0x0135, 0x006a, /* ĵ j */
    0x0136, 0x004b, /* Ķ K */
    0x0137, 0x006b, /* ķ k */
    0x0139, 0x004c, /* Ĺ L */
    0x013a, 0x006c, /* ĺ l */
    0x013b, 0x004c, /* Ļ L */
    0x013c, 0x006c, /* ļ l */
    0x013d, 0x004c, /* Ľ L */
    0x013e, 0x006c, /* ľ l */
    0x0143, 0x004e, /* Ń N */
    0x0144, 0x006e, /* ń n */
    0x0145, 0x004e, /* Ņ N */
    0x0146, 0x006e, /* ņ n */
    0x0147, 0x004e, /* Ň N */
    0x0148, 0x006e, /* ň n */
    0x014c, 0x004f, /* Ō O */
    0x014d, 0x006f, /* ō o */
    0x014e, 0x004f, /* Ŏ O */
    0x014f, 0x006f, /* ŏ o */
    0x0150, 0x004f, /* Ő O */
    0x0151, 0x006f, /* ő o */
    0x0154, 0x0052, /* Ŕ R */
    0x0155, 0x0072, /* ŕ r */
    0x0156, 0x0052, /* Ŗ R */
    0x0157, 0x0072, /* ŗ r */
    0x0158, 0x0052, /* Ř R */
    0x0159, 0x0072, /* ř r */
    0x015a, 0x0053, /* Ś S */
    0x015b, 0x0073, /* ś s */
    0x015c, 0x0053, /* Ŝ S */
    0x015d, 0x0073, /* ŝ s */
    0x015e, 0x0053, /* Ş S */
    0x015f, 0x0073, /* ş s */
    0x0160, 0x0053, /* Š S */
    0x0161, 0x0073, /* š s */
    0x0162, 0x0054, /* Ţ T */
    0x0163, 0x0074, /* ţ t */
    0x0164, 0x0054, /* Ť T */
    0x0165, 0x0074, /* ť t */
    0x0168, 0x0055, /* Ũ U */
    0x0169, 0x0075, /* ũ u */
    0x016a, 0x0055, /* Ū U */
    0x016b, 0x0075, /* ū u */
    0x016c, 0x0055, /* Ŭ U */
    0x016d, 0x0075, /* ŭ u */
    0x016e, 0x0055, /* Ů U */
    0x016f, 0x0075, /* ů u */
    0x0170, 0x0055, /* Ű U */
    0x0171, 0x0075, /* ű u */
    0x0172, 0x0055, /* Ų U */
    0x0173, 0x0075, /* ų u */
    0x0174, 0x0057, /* Ŵ W */
    0x0175, 0x0077, /* ŵ w */
    0x0176, 0x0059, /* Ŷ Y */
    0x0177, 0x0079, /* ŷ y */
    0x0178, 0x0059, /* Ÿ Y */
    0x0179, 0x005a, /* Ź Z */
    0x017a, 0x007a, /* ź z */
    0x017b, 0x005a, /* Ż Z */
    0x017c, 0x007a, /* ż z */
    0x017d, 0x005a, /* Ž Z */
    0x017e, 0x007a, /* ž z */
    0x01a0, 0x004f, /* Ơ O */
    0x01a1, 0x006f, /* ơ o */
    0x01af, 0x0055, /* Ư U */
    0x01b0, 0x0075, /* ư u */
    0x01cd, 0x0041, /* Ǎ A */
    0x01ce, 0x0061, /* ǎ a */
    0x01cf, 0x0049, /* Ǐ I */
    0x01d0, 0x0069, /* ǐ i */
    0x01d1, 0x004f, /* Ǒ O */
    0x01d2, 0x006f, /* ǒ o */
    0x01d3, 0x0055, /* Ǔ U */
    0x01d4, 0x0075, /* ǔ u */
    0x01d5, 0x0055, /* Ǖ U */
    0x01d6, 0x0075, /* ǖ u */
    0x01d7, 0x0055, /* Ǘ U */
    0x01d8, 0x0075, /* ǘ u */
    0x01d9, 0x0055, /* Ǚ U */
    0x01da, 0x0075, /* ǚ u */
    0x01db, 0x0055, /* Ǜ U */
    0x01dc, 0x0075, /* ǜ u */
    0x01de, 0x0041, /* Ǟ A */
    0x01df, 0x0061, /* ǟ a */
    0x01e0, 0x0041, /* Ǡ A */
    0x01e1, 0x0061, /* ǡ a */
    0x01e2, 0x00c6, /* Ǣ Æ */
    0x01e3, 0x00e6, /* ǣ æ */
    0x01e6, 0x0047, /* Ǧ G */
    0x01e7, 0x0067, /* ǧ g */
    0x01e8, 0x004b, /* Ǩ K */
    0x01e9, 0x006b, /* ǩ k */
    0x01ea, 0x004f, /* Ǫ O */
    0x01eb, 0x006f, /* ǫ o */
    0x01ec, 0x004f, /* Ǭ O */
    0x01ed, 0x006f, /* ǭ o */
    0x01ee, 0x01b7, /* Ǯ Ʒ */
    0x01ef, 0x0292, /* ǯ ʒ */
    0x01f0, 0x006a, /* ǰ j */
    0x01f4, 0x0047, /* Ǵ G */
    0x01f5, 0x0067, /* ǵ g */
    0x01f8, 0x004e, /* Ǹ N */
    0x01f9, 0x006e, /* ǹ n */
    0x01fa, 0x0041, /* Ǻ A */
    0x01fb, 0x0061, /* ǻ a */
    0x01fc, 0x00c6, /* Ǽ Æ */
    0x01fd, 0x00e6, /* ǽ æ */
    0x01fe, 0x00d8, /* Ǿ Ø */
    0x01ff, 0x00f8, /* ǿ ø */
    0x0200, 0x0041, /* Ȁ A */
    0x0201, 0x0061, /* ȁ a */
    0x0202, 0x0041, /* Ȃ A */
    0x0203, 0x0061, /* ȃ a */
    0x0204, 0x0045, /* Ȅ E */
    0x0205, 0x0065, /* ȅ e */
    0x0206, 0x0045, /* Ȇ E */
    0x0207, 0x0065, /* ȇ e */
    0x0208, 0x0049, /* Ȉ I */
    0x0209, 0x0069, /* ȉ i */
    0x020a, 0x0049, /* Ȋ I */
    0x020b, 0x0069, /* ȋ i */
    0x020c, 0x004f, /* Ȍ O */
    0x020d, 0x006f, /* ȍ o */
    0x020e, 0x004f, /* Ȏ O */
    0x020f, 0x006f, /* ȏ o */
    0x0210, 0x0052, /* Ȑ R */
    0x0211, 0x0072, /* ȑ r */
    0x0212, 0x0052, /* Ȓ R */
    0x0213, 0x0072, /* ȓ r */
    0x0214, 0x0055, /* Ȕ U */
    0x0215, 0x0075, /* ȕ u */
    0x0216, 0x0055, /* Ȗ U */
    0x0217, 0x0075, /* ȗ u */
    0x0218, 0x0053, /* Ș S */
    0x0219, 0x0073, /* ș s */
    0x021a, 0x0054, /* Ț T */
    0x021b, 0x0074, /* ț t */
    0x021e, 0x0048, /* Ȟ H */
    0x021f, 0x0068, /* ȟ h */
    0x0226, 0x0041, /* Ȧ A */
    0x0227, 0x0061, /* ȧ a */
    0x0228, 0x0045, /* Ȩ E */
    0x0229, 0x0065, /* ȩ e */
    0x022a, 0x004f, /* Ȫ O */
    0x022b, 0x006f, /* ȫ o */
    0x022c, 0x004f, /* Ȭ O */
    0x022d, 0x006f, /* ȭ o */
    0x022e, 0x004f, /* Ȯ O */
    0x022f, 0x006f, /* ȯ o */
    0x0230, 0x004f, /* Ȱ O */
    0x0231, 0x006f, /* ȱ o */
    0x0232, 0x0059, /* Ȳ Y */
    0x0233, 0x0079, /* ȳ y */
    0x0374, 0x02b9, /* ʹ ʹ */
    0x0386, 0x0391, /* Ά Α */
    0x0388, 0x0395, /* Έ Ε */
    0x0389, 0x0397, /* Ή Η */
    0x038a, 0x0399, /* Ί Ι */
    0x038c, 0x039f, /* Ό Ο */
    0x038e, 0x03a5, /* Ύ Υ */
    0x038f, 0x03a9, /* Ώ Ω */
    0x0390, 0x03b9, /* ΐ ι */
    0x03aa, 0x0399, /* Ϊ Ι */
    0x03ab, 0x03a5, /* Ϋ Υ */
    0x03ac, 0x03b1, /* ά α */
    0x03ad, 0x03b5, /* έ ε */
    0x03ae, 0x03b7, /* ή η */
    0x03af, 0x03b9, /* ί ι */
    0x03b0, 0x03c5, /* ΰ υ */
    0x03ca, 0x03b9, /* ϊ ι */
    0x03cb, 0x03c5, /* ϋ υ */
    0x03cc, 0x03bf, /* ό ο */
    0x03cd, 0x03c5, /* ύ υ */
    0x03ce, 0x03c9, /* ώ ω */
    0x03d3, 0x03d2, /* ϓ ϒ */
    0x03d4, 0x03d2, /* ϔ ϒ */
    0x0400, 0x0415, /* Ѐ Е */
    0x0401, 0x0415, /* Ё Е */
    0x0403, 0x0413, /* Ѓ Г */
    0x0407, 0x0406, /* Ї І */
    0x040c, 0x041a, /* Ќ К */
    0x040d, 0x0418, /* Ѝ И */
    0x040e, 0x0423, /* Ў У */
    0x0419, 0x0418, /* Й И */
    0x0439, 0x0438, /* й и */
    0x0450, 0x0435, /* ѐ е */
    0x0451, 0x0435, /* ё е */
    0x0453, 0x0433, /* ѓ г */
    0x0457, 0x0456, /* ї і */
    0x045c, 0x043a, /* ќ к */
    0x045d, 0x0438, /* ѝ и */
    0x045e, 0x0443, /* ў у */
    0x0476, 0x0474, /* Ѷ Ѵ */
    0x0477, 0x0475, /* ѷ ѵ */
    0x04c1, 0x0416, /* Ӂ Ж */
    0x04c2, 0x0436, /* ӂ ж */
    0x04d0, 0x0410, /* Ӑ А */
    0x04d1, 0x0430, /* ӑ а */
    0x04d2, 0x0410, /* Ӓ А */
    0x04d3, 0x0430, /* ӓ а */
    0x04d6, 0x0415, /* Ӗ Е */
    0x04d7, 0x0435, /* ӗ е */
    0x04da, 0x04d8, /* Ӛ Ә */
    0x04db, 0x04d9, /* ӛ ә */
    0x04dc, 0x0416, /* Ӝ Ж */
    0x04dd, 0x0436, /* ӝ ж */
    0x04de, 0x0417, /* Ӟ З */
    0x04df, 0x0437, /* ӟ з */
    0x04e2, 0x0418, /* Ӣ И */
    0x04e3, 0x0438, /* ӣ и */
    0x04e4, 0x0418, /* Ӥ И */
    0x04e5, 0x0438, /* ӥ и */
    0x04e6, 0x041e, /* Ӧ О */
    0x04e7, 0x043e, /* ӧ о */
    0x04ea, 0x04e8, /* Ӫ Ө */
    0x04eb, 0x04e9, /* ӫ ө */
    0x04ec, 0x042d, /* Ӭ Э */
    0x04ed, 0x044d, /* ӭ э */
    0x04ee, 0x0423, /* Ӯ У */
    0x04ef, 0x0443, /* ӯ у */
    0x04f0, 0x0423, /* Ӱ У */
    0x04f1, 0x0443, /* ӱ у */
    0x04f2, 0x0423, /* Ӳ У */
    0x04f3, 0x0443, /* ӳ у */
    0x04f4, 0x0427, /* Ӵ Ч */
    0x04f5, 0x0447, /* ӵ ч */
    0x04f8, 0x042b, /* Ӹ Ы */
    0x04f9, 0x044b, /* ӹ ы */
    0x0622, 0x0627, /* آ ا */
    0x0623, 0x0627, /* أ ا */
    0x0624, 0x0648, /* ؤ و */
    0x0625, 0x0627, /* إ ا */
    0x0626, 0x064a, /* ئ ي */
    0x06c0, 0x06d5, /* ۀ ە */
    0x06c2, 0x06c1, /* ۂ ہ */
    0x06d3, 0x06d2, /* ۓ ے */
    0x0929, 0x0928, /* ऩ न */
    0x0931, 0x0930, /* ऱ र */
    0x0934, 0x0933, /* ऴ ळ */
    0x0958, 0x0915, /* क़ क */
    0x0959, 0x0916, /* ख़ ख */
    0x095a, 0x0917, /* ग़ ग */
    0x095b, 0x091c, /* ज़ ज */
    0x095c, 0x0921, /* ड़ ड */
    0x095d, 0x0922, /* ढ़ ढ */
    0x095e, 0x092b, /* फ़ फ */
    0x095f, 0x092f, /* य़ य */
    0x09dc, 0x09a1, /* ড় ড */
    0x09dd, 0x09a2, /* ঢ় ঢ */
    0x09df, 0x09af, /* য় য */
    0x0a33, 0x0a32, /* ਲ਼ ਲ */
    0x0a36, 0x0a38, /* ਸ਼ ਸ */
    0x0a59, 0x0a16, /* ਖ਼ ਖ */
    0x0a5a, 0x0a17, /* ਗ਼ ਗ */
    0x0a5b, 0x0a1c, /* ਜ਼ ਜ */
    0x0a5e, 0x0a2b, /* ਫ਼ ਫ */
    0x0b5c, 0x0b21, /* ଡ଼ ଡ */
    0x0b5d, 0x0b22, /* ଢ଼ ଢ */
    0x0b94, 0x0b92, /* ஔ ஒ */
    0x0f43, 0x0f42, /* གྷ ག */
    0x0f4d, 0x0f4c, /* ཌྷ ཌ */
    0x0f52, 0x0f51, /* དྷ ད */
    0x0f57, 0x0f56, /* བྷ བ */
    0x0f5c, 0x0f5b, /* ཛྷ ཛ */
    0x0f69, 0x0f40, /* ཀྵ ཀ */
    0x1026, 0x1025, /* ဦ ဥ */
    0x1b06, 0x1b05, /* ᬆ ᬅ */
    0x1b08, 0x1b07, /* ᬈ ᬇ */
    0x1b0a, 0x1b09, /* ᬊ ᬉ */
    0x1b0c, 0x1b0b, /* ᬌ ᬋ */
    0x1b0e, 0x1b0d, /* ᬎ ᬍ */
    0x1b12, 0x1b11, /* ᬒ ᬑ */
    0x1e00, 0x0041, /* Ḁ A */
    0x1e01, 0x0061, /* ḁ a */
    0x1e02, 0x0042, /* Ḃ B */
    0x1e03, 0x0062, /* ḃ b */
    0x1e04, 0x0042, /* Ḅ B */
    0x1e05, 0x0062, /* ḅ b */
    0x1e06, 0x0042, /* Ḇ B */
    0x1e07, 0x0062, /* ḇ b */
    0x1e08, 0x0043, /* Ḉ C */
    0x1e09, 0x0063, /* ḉ c */
    0x1e0a, 0x0044, /* Ḋ D */
    0x1e0b, 0x0064, /* ḋ d */
    0x1e0c, 0x0044, /* Ḍ D */
    0x1e0d, 0x0064, /* ḍ d */
    0x1e0e, 0x0044, /* Ḏ D */
    0x1e0f, 0x0064, /* ḏ d */
    0x1e10, 0x0044, /* Ḑ D */
    0x1e11, 0x0064, /* ḑ d */
    0x1e12, 0x0044, /* Ḓ D */
    0x1e13, 0x0064, /* ḓ d */
    0x1e14, 0x0045, /* Ḕ E */
    0x1e15, 0x0065, /* ḕ e */
    0x1e16, 0x0045, /* Ḗ E */
    0x1e17, 0x0065, /* ḗ e */
    0x1e18, 0x0045, /* Ḙ E */
    0x1e19, 0x0065, /* ḙ e */
    0x1e1a, 0x0045, /* Ḛ E */
    0x1e1b, 0x0065, /* ḛ e */
    0x1e1c, 0x0045, /* Ḝ E */
    0x1e1d, 0x0065, /* ḝ e */
    0x1e1e, 0x0046, /* Ḟ F */
    0x1e1f, 0x0066, /* ḟ f */
    0x1e20, 0x0047, /* Ḡ G */
    0x1e21, 0x0067, /* ḡ g */
    0x1e22, 0x0048, /* Ḣ H */
    0x1e23, 0x0068, /* ḣ h */
    0x1e24, 0x0048, /* Ḥ H */
    0x1e25, 0x0068, /* ḥ h */
    0x1e26, 0x0048, /* Ḧ H */
    0x1e27, 0x0068, /* ḧ h */
    0x1e28, 0x0048, /* Ḩ H */
    0x1e29, 0x0068, /* ḩ h */
    0x1e2a, 0x0048, /* Ḫ H */
    0x1e2b, 0x0068, /* ḫ h */
    0x1e2c, 0x0049, /* Ḭ I */
    0x1e2d, 0x0069, /* ḭ i */
    0x1e2e, 0x0049, /* Ḯ I */
    0x1e2f, 0x0069, /* ḯ i */
    0x1e30, 0x004b, /* Ḱ K */
    0x1e31, 0x006b, /* ḱ k */
    0x1e32, 0x004b, /* Ḳ K */
    0x1e33, 0x006b, /* ḳ k */
    0x1e34, 0x004b, /* Ḵ K */
    0x1e35, 0x006b, /* ḵ k */
    0x1e36, 0x004c, /* Ḷ L */
    0x1e37, 0x006c, /* ḷ l */
    0x1e38, 0x004c, /* Ḹ L */
    0x1e39, 0x006c, /* ḹ l */
    0x1e3a, 0x004c, /* Ḻ L */
    0x1e3b, 0x006c, /* ḻ l */
    0x1e3c, 0x004c, /* Ḽ L */
    0x1e3d, 0x006c, /* ḽ l */
    0x1e3e, 0x004d, /* Ḿ M */
    0x1e3f, 0x006d, /* ḿ m */
    0x1e40, 0x004d, /* Ṁ M */
    0x1e41, 0x006d, /* ṁ m */
    0x1e42, 0x004d, /* Ṃ M */
    0x1e43, 0x006d, /* ṃ m */
    0x1e44, 0x004e, /* Ṅ N */
    0x1e45, 0x006e, /* ṅ n */
    0x1e46, 0x004e, /* Ṇ N */
    0x1e47, 0x006e, /* ṇ n */
    0x1e48, 0x004e, /* Ṉ N */
    0x1e49, 0x006e, /* ṉ n */
    0x1e4a, 0x004e, /* Ṋ N */
    0x1e4b, 0x006e, /* ṋ n */
    0x1e4c, 0x004f, /* Ṍ O */
    0x1e4d, 0x006f, /* ṍ o */
    0x1e4e, 0x004f, /* Ṏ O */
    0x1e4f, 0x006f, /* ṏ o */
    0x1e50, 0x004f, /* Ṑ O */
    0x1e51, 0x006f, /* ṑ o */
    0x1e52, 0x004f, /* Ṓ O */
    0x1e53, 0x006f, /* ṓ o */
    0x1e54, 0x0050, /* Ṕ P */
    0x1e55, 0x0070, /* ṕ p */
    0x1e56, 0x0050, /* Ṗ P */
    0x1e57, 0x0070, /* ṗ p */
    0x1e58, 0x0052, /* Ṙ R */
    0x1e59, 0x0072, /* ṙ r */
    0x1e5a, 0x0052, /* Ṛ R */
    0x1e5b, 0x0072, /* ṛ r */
    0x1e5c, 0x0052, /* Ṝ R */
    0x1e5d, 0x0072, /* ṝ r */
    0x1e5e, 0x0052, /* Ṟ R */
    0x1e5f, 0x0072, /* ṟ r */
    0x1e60, 0x0053, /* Ṡ S */
    0x1e61, 0x0073, /* ṡ s */
    0x1e62, 0x0053, /* Ṣ S */
    0x1e63, 0x0073, /* ṣ s */
    0x1e64, 0x0053, /* Ṥ S */
    0x1e65, 0x0073, /* ṥ s */
    0x1e66, 0x0053, /* Ṧ S */
    0x1e67, 0x0073, /* ṧ s */
    0x1e68, 0x0053, /* Ṩ S */
    0x1e69, 0x0073, /* ṩ s */
    0x1e6a, 0x0054, /* Ṫ T */
    0x1e6b, 0x0074, /* ṫ t */
    0x1e6c, 0x0054, /* Ṭ T */
    0x1e6d, 0x0074, /* ṭ t */
    0x1e6e, 0x0054, /* Ṯ T */
    0x1e6f, 0x0074, /* ṯ t */
    0x1e70, 0x0054, /* Ṱ T */
    0x1e71, 0x0074, /* ṱ t */
    0x1e72, 0x0055, /* Ṳ U */
    0x1e73, 0x0075, /* ṳ u */
    0x1e74, 0x0055, /* Ṵ U */
    0x1e75, 0x0075, /* ṵ u */
    0x1e76, 0x0055, /* Ṷ U */
    0x1e77, 0x0075, /* ṷ u */
    0x1e78, 0x0055, /* Ṹ U */
    0x1e79, 0x0075, /* ṹ u */
    0x1e7a, 0x0055, /* Ṻ U */
    0x1e7b, 0x0075, /* ṻ u */
    0x1e7c, 0x0056, /* Ṽ V */
    0x1e7d, 0x0076, /* ṽ v */
    0x1e7e, 0x0056, /* Ṿ V */
    0x1e7f, 0x0076, /* ṿ v */
    0x1e80, 0x0057, /* Ẁ W */
    0x1e81, 0x0077, /* ẁ w */
    0x1e82, 0x0057, /* Ẃ W */
    0x1e83, 0x0077, /* ẃ w */
    0x1e84, 0x0057, /* Ẅ W */
    0x1e85, 0x0077, /* ẅ w */
    0x1e86, 0x0057, /* Ẇ W */
    0x1e87, 0x0077, /* ẇ w */
    0x1e88, 0x0057, /* Ẉ W */
    0x1e89, 0x0077, /* ẉ w */
    0x1e8a, 0x0058, /* Ẋ X */
    0x1e8b, 0x0078, /* ẋ x */
    0x1e8c, 0x0058, /* Ẍ X */
    0x1e8d, 0x0078, /* ẍ x */
    0x1e8e, 0x0059, /* Ẏ Y */
    0x1e8f, 0x0079, /* ẏ y */
    0x1e90, 0x005a, /* Ẑ Z */
    0x1e91, 0x007a, /* ẑ z */
    0x1e92, 0x005a, /* Ẓ Z */
    0x1e93, 0x007a, /* ẓ z */
    0x1e94, 0x005a, /* Ẕ Z */
    0x1e95, 0x007a, /* ẕ z */
    0x1e96, 0x0068, /* ẖ h */
    0x1e97, 0x0074, /* ẗ t */
    0x1e98, 0x0077, /* ẘ w */
    0x1e99, 0x0079, /* ẙ y */
    0x1e9b, 0x017f, /* ẛ ſ */
    0x1ea0, 0x0041, /* Ạ A */
    0x1ea1, 0x0061, /* ạ a */
    0x1ea2, 0x0041, /* Ả A */
    0x1ea3, 0x0061, /* ả a */
    0x1ea4, 0x0041, /* Ấ A */
    0x1ea5, 0x0061, /* ấ a */
    0x1ea6, 0x0041, /* Ầ A */
    0x1ea7, 0x0061, /* ầ a */
    0x1ea8, 0x0041, /* Ẩ A */
    0x1ea9, 0x0061, /* ẩ a */
    0x1eaa, 0x0041, /* Ẫ A */
    0x1eab, 0x0061, /* ẫ a */
    0x1eac, 0x0041, /* Ậ A */
    0x1ead, 0x0061, /* ậ a */
    0x1eae, 0x0041, /* Ắ A */
    0x1eaf, 0x0061, /* ắ a */
    0x1eb0, 0x0041, /* Ằ A */
    0x1eb1, 0x0061, /* ằ a */
    0x1eb2, 0x0041, /* Ẳ A */
    0x1eb3, 0x0061, /* ẳ a */
    0x1eb4, 0x0041, /* Ẵ A */
    0x1eb5, 0x0061, /* ẵ a */
    0x1eb6, 0x0041, /* Ặ A */
    0x1eb7, 0x0061, /* ặ a */
    0x1eb8, 0x0045, /* Ẹ E */
    0x1eb9, 0x0065, /* ẹ e */
    0x1eba, 0x0045, /* Ẻ E */
    0x1ebb, 0x0065, /* ẻ e */
    0x1ebc, 0x0045, /* Ẽ E */
    0x1ebd, 0x0065, /* ẽ e */
    0x1ebe, 0x0045, /* Ế E */
    0x1ebf, 0x0065, /* ế e */
    0x1ec0, 0x0045, /* Ề E */
    0x1ec1, 0x0065, /* ề e */
    0x1ec2, 0x0045, /* Ể E */
    0x1ec3, 0x0065, /* ể e */
    0x1ec4, 0x0045, /* Ễ E */
    0x1ec5, 0x0065, /* ễ e */
    0x1ec6, 0x0045, /* Ệ E */
    0x1ec7, 0x0065, /* ệ e */
    0x1ec8, 0x0049, /* Ỉ I */
    0x1ec9, 0x0069, /* ỉ i */
    0x1eca, 0x0049, /* Ị I */
    0x1ecb, 0x0069, /* ị i */
    0x1ecc, 0x004f, /* Ọ O */
    0x1ecd, 0x006f, /* ọ o */
    0x1ece, 0x004f, /* Ỏ O */
    0x1ecf, 0x006f, /* ỏ o */
    0x1ed0, 0x004f, /* Ố O */
    0x1ed1, 0x006f, /* ố o */
    0x1ed2, 0x004f, /* Ồ O */
    0x1ed3, 0x006f, /* ồ o */
    0x1ed4, 0x004f, /* Ổ O */
    0x1ed5, 0x006f, /* ổ o */
    0x1ed6, 0x004f, /* Ỗ O */
    0x1ed7, 0x006f, /* ỗ o */
    0x1ed8, 0x004f, /* Ộ O */
    0x1ed9, 0x006f, /* ộ o */
    0x1eda, 0x004f, /* Ớ O */
    0x1edb, 0x006f, /* ớ o */
    0x1edc, 0x004f, /* Ờ O */
    0x1edd, 0x006f, /* ờ o */
    0x1ede, 0x004f, /* Ở O */
    0x1edf, 0x006f, /* ở o */
    0x1ee0, 0x004f, /* Ỡ O */
    0x1ee1, 0x006f, /* ỡ o */
    0x1ee2, 0x004f, /* Ợ O */
    0x1ee3, 0x006f, /* ợ o */
    0x1ee4, 0x0055, /* Ụ U */
    0x1ee5, 0x0075, /* ụ u */
    0x1ee6, 0x0055, /* Ủ U */
    0x1ee7, 0x0075, /* ủ u */
    0x1ee8, 0x0055, /* Ứ U */
    0x1ee9, 0x0075, /* ứ u */
    0x1eea, 0x0055, /* Ừ U */
    0x1eeb, 0x0075, /* ừ u */
    0x1eec, 0x0055, /* Ử U */
    0x1eed, 0x0075, /* ử u */
    0x1eee, 0x0055, /* Ữ U */
    0x1eef, 0x0075, /* ữ u */
    0x1ef0, 0x0055, /* Ự U */
    0x1ef1, 0x0075, /* ự u */
    0x1ef2, 0x0059, /* Ỳ Y */
    0x1ef3, 0x0079, /* ỳ y */
    0x1ef4, 0x0059, /* Ỵ Y */
    0x1ef5, 0x0079, /* ỵ y */
    0x1ef6, 0x0059, /* Ỷ Y */
    0x1ef7, 0x0079, /* ỷ y */
    0x1ef8, 0x0059, /* Ỹ Y */
    0x1ef9, 0x0079, /* ỹ y */
    0x1f00, 0x03b1, /* ἀ α */
    0x1f01, 0x03b1, /* ἁ α */
    0x1f02, 0x03b1, /* ἂ α */
    0x1f03, 0x03b1, /* ἃ α */
    0x1f04, 0x03b1, /* ἄ α */
    0x1f05, 0x03b1, /* ἅ α */
    0x1f06, 0x03b1, /* ἆ α */
    0x1f07, 0x03b1, /* ἇ α */
    0x1f08, 0x0391, /* Ἀ Α */
    0x1f09, 0x0391, /* Ἁ Α */
    0x1f0a, 0x0391, /* Ἂ Α */
    0x1f0b, 0x0391, /* Ἃ Α */
    0x1f0c, 0x0391, /* Ἄ Α */
    0x1f0d, 0x0391, /* Ἅ Α */
    0x1f0e, 0x0391, /* Ἆ Α */
    0x1f0f, 0x0391, /* Ἇ Α */
    0x1f10, 0x03b5, /* ἐ ε */
    0x1f11, 0x03b5, /* ἑ ε */
    0x1f12, 0x03b5, /* ἒ ε */
    0x1f13, 0x03b5, /* ἓ ε */
    0x1f14, 0x03b5, /* ἔ ε */
    0x1f15, 0x03b5, /* ἕ ε */
    0x1f18, 0x0395, /* Ἐ Ε */
    0x1f19, 0x0395, /* Ἑ Ε */
    0x1f1a, 0x0395, /* Ἒ Ε */
    0x1f1b, 0x0395, /* Ἓ Ε */
    0x1f1c, 0x0395, /* Ἔ Ε */
    0x1f1d, 0x0395, /* Ἕ Ε */
    0x1f20, 0x03b7, /* ἠ η */
    0x1f21, 0x03b7, /* ἡ η */
    0x1f22, 0x03b7, /* ἢ η */
    0x1f23, 0x03b7, /* ἣ η */
    0x1f24, 0x03b7, /* ἤ η */
    0x1f25, 0x03b7, /* ἥ η */
    0x1f26, 0x03b7, /* ἦ η */
    0x1f27, 0x03b7, /* ἧ η */
    0x1f28, 0x0397, /* Ἠ Η */
    0x1f29, 0x0397, /* Ἡ Η */
    0x1f2a, 0x0397, /* Ἢ Η */
    0x1f2b, 0x0397, /* Ἣ Η */
    0x1f2c, 0x0397, /* Ἤ Η */
    0x1f2d, 0x0397, /* Ἥ Η */
    0x1f2e, 0x0397, /* Ἦ Η */
    0x1f2f, 0x0397, /* Ἧ Η */
    0x1f30, 0x03b9, /* ἰ ι */
    0x1f31, 0x03b9, /* ἱ ι */
    0x1f32, 0x03b9, /* ἲ ι */
    0x1f33, 0x03b9, /* ἳ ι */
    0x1f34, 0x03b9, /* ἴ ι */
    0x1f35, 0x03b9, /* ἵ ι */
    0x1f36, 0x03b9, /* ἶ ι */
    0x1f37, 0x03b9, /* ἷ ι */
    0x1f38, 0x0399, /* Ἰ Ι */
    0x1f39, 0x0399, /* Ἱ Ι */
    0x1f3a, 0x0399, /* Ἲ Ι */
    0x1f3b, 0x0399, /* Ἳ Ι */
    0x1f3c, 0x0399, /* Ἴ Ι */
    0x1f3d, 0x0399, /* Ἵ Ι */
    0x1f3e, 0x0399, /* Ἶ Ι */
    0x1f3f, 0x0399, /* Ἷ Ι */
    0x1f40, 0x03bf, /* ὀ ο */
    0x1f41, 0x03bf, /* ὁ ο */
    0x1f42, 0x03bf, /* ὂ ο */
    0x1f43, 0x03bf, /* ὃ ο */
    0x1f44, 0x03bf, /* ὄ ο */
    0x1f45, 0x03bf, /* ὅ ο */
    0x1f48, 0x039f, /* Ὀ Ο */
    0x1f49, 0x039f, /* Ὁ Ο */
    0x1f4a, 0x039f, /* Ὂ Ο */
    0x1f4b, 0x039f, /* Ὃ Ο */
    0x1f4c, 0x039f, /* Ὄ Ο */
    0x1f4d, 0x039f, /* Ὅ Ο */
    0x1f50, 0x03c5, /* ὐ υ */
    0x1f51, 0x03c5, /* ὑ υ */
    0x1f52, 0x03c5, /* ὒ υ */
    0x1f53, 0x03c5, /* ὓ υ */
    0x1f54, 0x03c5, /* ὔ υ */
    0x1f55, 0x03c5, /* ὕ υ */
    0x1f56, 0x03c5, /* ὖ υ */
    0x1f57, 0x03c5, /* ὗ υ */
    0x1f59, 0x03a5, /* Ὑ Υ */
    0x1f5b, 0x03a5, /* Ὓ Υ */
    0x1f5d, 0x03a5, /* Ὕ Υ */
    0x1f5f, 0x03a5, /* Ὗ Υ */
    0x1f60, 0x03c9, /* ὠ ω */
    0x1f61, 0x03c9, /* ὡ ω */
    0x1f62, 0x03c9, /* ὢ ω */
    0x1f63, 0x03c9, /* ὣ ω */
    0x1f64, 0x03c9, /* ὤ ω */
    0x1f65, 0x03c9, /* ὥ ω */
    0x1f66, 0x03c9, /* ὦ ω */
    0x1f67, 0x03c9, /* ὧ ω */
    0x1f68, 0x03a9, /* Ὠ Ω */
    0x1f69, 0x03a9, /* Ὡ Ω */
    0x1f6a, 0x03a9, /* Ὢ Ω */
    0x1f6b, 0x03a9, /* Ὣ Ω */
    0x1f6c, 0x03a9, /* Ὤ Ω */
    0x1f6d, 0x03a9, /* Ὥ Ω */
    0x1f6e, 0x03a9, /* Ὦ Ω */
    0x1f6f, 0x03a9, /* Ὧ Ω */
    0x1f70, 0x03b1, /* ὰ α */
    0x1f71, 0x03b1, /* ά α */
    0x1f72, 0x03b5, /* ὲ ε */
    0x1f73, 0x03b5, /* έ ε */
    0x1f74, 0x03b7, /* ὴ η */
    0x1f75, 0x03b7, /* ή η */
    0x1f76, 0x03b9, /* ὶ ι */
    0x1f77, 0x03b9, /* ί ι */
    0x1f78, 0x03bf, /* ὸ ο */
    0x1f79, 0x03bf, /* ό ο */
    0x1f7a, 0x03c5, /* ὺ υ */
    0x1f7b, 0x03c5, /* ύ υ */
    0x1f7c, 0x03c9, /* ὼ ω */
    0x1f7d, 0x03c9, /* ώ ω */
    0x1f80, 0x03b1, /* ᾀ α */
    0x1f81, 0x03b1, /* ᾁ α */
    0x1f82, 0x03b1, /* ᾂ α */
    0x1f83, 0x03b1, /* ᾃ α */
    0x1f84, 0x03b1, /* ᾄ α */
    0x1f85, 0x03b1, /* ᾅ α */
    0x1f86, 0x03b1, /* ᾆ α */
    0x1f87, 0x03b1, /* ᾇ α */
    0x1f88, 0x0391, /* ᾈ Α */
    0x1f89, 0x0391, /* ᾉ Α */
    0x1f8a, 0x0391, /* ᾊ Α */
    0x1f8b, 0x0391, /* ᾋ Α */
    0x1f8c, 0x0391, /* ᾌ Α */
    0x1f8d, 0x0391, /* ᾍ Α */
    0x1f8e, 0x0391, /* ᾎ Α */
    0x1f8f, 0x0391, /* ᾏ Α */
    0x1f90, 0x03b7, /* ᾐ η */
    0x1f91, 0x03b7, /* ᾑ η */
    0x1f92, 0x03b7, /* ᾒ η */
    0x1f93, 0x03b7, /* ᾓ η */
    0x1f94, 0x03b7, /* ᾔ η */
    0x1f95, 0x03b7, /* ᾕ η */
    0x1f96, 0x03b7, /* ᾖ η */
    0x1f97, 0x03b7, /* ᾗ η */
    0x1f98, 0x0397, /* ᾘ Η */
    0x1f99, 0x0397, /* ᾙ Η */
    0x1f9a, 0x0397, /* ᾚ Η */
    0x1f9b, 0x0397, /* ᾛ Η */
    0x1f9c, 0x0397, /* ᾜ Η */
    0x1f9d, 0x0397, /* ᾝ Η */
    0x1f9e, 0x0397, /* ᾞ Η */
    0x1f9f, 0x0397, /* ᾟ Η */
    0x1fa0, 0x03c9, /* ᾠ ω */
    0x1fa1, 0x03c9, /* ᾡ ω */
    0x1fa2, 0x03c9, /* ᾢ ω */
    0x1fa3, 0x03c9, /* ᾣ ω */
    0x1fa4, 0x03c9, /* ᾤ ω */
    0x1fa5, 0x03c9, /* ᾥ ω */
    0x1fa6, 0x03c9, /* ᾦ ω */
    0x1fa7, 0x03c9, /* ᾧ ω */
    0x1fa8, 0x03a9, /* ᾨ Ω */
    0x1fa9, 0x03a9, /* ᾩ Ω */
    0x1faa, 0x03a9, /* ᾪ Ω */
    0x1fab, 0x03a9, /* ᾫ Ω */
    0x1fac, 0x03a9, /* ᾬ Ω */
    0x1fad, 0x03a9, /* ᾭ Ω */
    0x1fae, 0x03a9, /* ᾮ Ω */
    0x1faf, 0x03a9, /* ᾯ Ω */
    0x1fb0, 0x03b1, /* ᾰ α */
    0x1fb1, 0x03b1, /* ᾱ α */
    0x1fb2, 0x03b1, /* ᾲ α */
    0x1fb3, 0x03b1, /* ᾳ α */
    0x1fb4, 0x03b1, /* ᾴ α */
    0x1fb6, 0x03b1, /* ᾶ α */
    0x1fb7, 0x03b1, /* ᾷ α */
    0x1fb8, 0x0391, /* Ᾰ Α */
    0x1fb9, 0x0391, /* Ᾱ Α */
    0x1fba, 0x0391, /* Ὰ Α */
    0x1fbb, 0x0391, /* Ά Α */
    0x1fbc, 0x0391, /* ᾼ Α */
    0x1fbe, 0x03b9, /* ι ι */
    0x1fc2, 0x03b7, /* ῂ η */
    0x1fc3, 0x03b7, /* ῃ η */
    0x1fc4, 0x03b7, /* ῄ η */
    0x1fc6, 0x03b7, /* ῆ η */
    0x1fc7, 0x03b7, /* ῇ η */
    0x1fc8, 0x0395, /* Ὲ Ε */
    0x1fc9, 0x0395, /* Έ Ε */
    0x1fca, 0x0397, /* Ὴ Η */
    0x1fcb, 0x0397, /* Ή Η */
    0x1fcc, 0x0397, /* ῌ Η */
    0x1fd0, 0x03b9, /* ῐ ι */
    0x1fd1, 0x03b9, /* ῑ ι */
    0x1fd2, 0x03b9, /* ῒ ι */
    0x1fd3, 0x03b9, /* ΐ ι */
    0x1fd6, 0x03b9, /* ῖ ι */
    0x1fd7, 0x03b9, /* ῗ ι */
    0x1fd8, 0x0399, /* Ῐ Ι */
    0x1fd9, 0x0399, /* Ῑ Ι */
    0x1fda, 0x0399, /* Ὶ Ι */
    0x1fdb, 0x0399, /* Ί Ι */
    0x1fe0, 0x03c5, /* ῠ υ */
    0x1fe1, 0x03c5, /* ῡ υ */
    0x1fe2, 0x03c5, /* ῢ υ */
    0x1fe3, 0x03c5, /* ΰ υ */
    0x1fe4, 0x03c1, /* ῤ ρ */
    0x1fe5, 0x03c1, /* ῥ ρ */
    0x1fe6, 0x03c5, /* ῦ υ */
    0x1fe7, 0x03c5, /* ῧ υ */
    0x1fe8, 0x03a5, /* Ῠ Υ */
    0x1fe9, 0x03a5, /* Ῡ Υ */
    0x1fea, 0x03a5, /* Ὺ Υ */
    0x1feb, 0x03a5, /* Ύ Υ */
    0x1fec, 0x03a1, /* Ῥ Ρ */
    0x1ff2, 0x03c9, /* ῲ ω */
    0x1ff3, 0x03c9, /* ῳ ω */
    0x1ff4, 0x03c9, /* ῴ ω */
    0x1ff6, 0x03c9, /* ῶ ω */
    0x1ff7, 0x03c9, /* ῷ ω */
    0x1ff8, 0x039f, /* Ὸ Ο */
    0x1ff9, 0x039f, /* Ό Ο */
    0x1ffa, 0x03a9, /* Ὼ Ω */
    0x1ffb, 0x03a9, /* Ώ Ω */
    0x1ffc, 0x03a9, /* ῼ Ω */
    0x2126, 0x03a9, /* Ω Ω */
    0x212a, 0x004b, /* K K */
    0x212b, 0x0041, /* Å A */
    0x304c, 0x304b, /* が か */
    0x304e, 0x304d, /* ぎ き */
    0x3050, 0x304f, /* ぐ く */
    0x3052, 0x3051, /* げ け */
    0x3054, 0x3053, /* ご こ */
    0x3056, 0x3055, /* ざ さ */
    0x3058, 0x3057, /* じ し */
    0x305a, 0x3059, /* ず す */
    0x305c, 0x305b, /* ぜ せ */
    0x305e, 0x305d, /* ぞ そ */
    0x3060, 0x305f, /* だ た */
    0x3062, 0x3061, /* ぢ ち */
    0x3065, 0x3064, /* づ つ */
    0x3067, 0x3066, /* で て */
    0x3069, 0x3068, /* ど と */
    0x3070, 0x306f, /* ば は */
    0x3071, 0x306f, /* ぱ は */
    0x3073, 0x3072, /* び ひ */
    0x3074, 0x3072, /* ぴ ひ */
    0x3076, 0x3075, /* ぶ ふ */
    0x3077, 0x3075, /* ぷ ふ */
    0x3079, 0x3078, /* べ へ */
    0x307a, 0x3078, /* ぺ へ */
    0x307c, 0x307b, /* ぼ ほ */
    0x307d, 0x307b, /* ぽ ほ */
    0x3094, 0x3046, /* ゔ う */
    0x309e, 0x309d, /* ゞ ゝ */
    0x30ac, 0x30ab, /* ガ カ */
    0x30ae, 0x30ad, /* ギ キ */
    0x30b0, 0x30af, /* グ ク */
    0x30b2, 0x30b1, /* ゲ ケ */
    0x30b4, 0x30b3, /* ゴ コ */
    0x30b6, 0x30b5, /* ザ サ */
    0x30b8, 0x30b7, /* ジ シ */
    0x30ba, 0x30b9, /* ズ ス */
    0x30bc, 0x30bb, /* ゼ セ */
    0x30be, 0x30bd, /* ゾ ソ */
    0x30c0, 0x30bf, /* ダ タ */
    0x30c2, 0x30c1, /* ヂ チ */
    0x30c5, 0x30c4, /* ヅ ツ */
    0x30c7, 0x30c6, /* デ テ */
    0x30c9, 0x30c8, /* ド ト */
    0x30d0, 0x30cf, /* バ ハ */
    0x30d1, 0x30cf, /* パ ハ */
    0x30d3, 0x30d2, /* ビ ヒ */
    0x30d4, 0x30d2, /* ピ ヒ */
    0x30d6, 0x30d5, /* ブ フ */
    0x30d7, 0x30d5, /* プ フ */
    0x30d9, 0x30d8, /* ベ ヘ */
    0x30da, 0x30d8, /* ペ ヘ */
    0x30dc, 0x30db, /* ボ ホ */
    0x30dd, 0x30db, /* ポ ホ */
    0x30f4, 0x30a6, /* ヴ ウ */
    0x30f7, 0x30ef, /* ヷ ワ */
    0x30f8, 0x30f0, /* ヸ ヰ */
    0x30f9, 0x30f1, /* ヹ ヱ */
    0x30fa, 0x30f2, /* ヺ ヲ */
    0x30fe, 0x30fd, /* ヾ ヽ */
    0xf900, 0x8c48, /* 豈 豈 */
    0xf901, 0x66f4, /* 更 更 */
    0xf902, 0x8eca, /* 車 車 */
    0xf903, 0x8cc8, /* 賈 賈 */
    0xf904, 0x6ed1, /* 滑 滑 */
    0xf905, 0x4e32, /* 串 串 */
    0xf906, 0x53e5, /* 句 句 */
    0xf907, 0x9f9c, /* 龜 龜 */
    0xf908, 0x9f9c, /* 龜 龜 */
    0xf909, 0x5951, /* 契 契 */
    0xf90a, 0x91d1, /* 金 金 */
    0xf90b, 0x5587, /* 喇 喇 */
    0xf90c, 0x5948, /* 奈 奈 */
    0xf90d, 0x61f6, /* 懶 懶 */
    0xf90e, 0x7669, /* 癩 癩 */
    0xf90f, 0x7f85, /* 羅 羅 */
    0xf910, 0x863f, /* 蘿 蘿 */
    0xf911, 0x87ba, /* 螺 螺 */
    0xf912, 0x88f8, /* 裸 裸 */
    0xf913, 0x908f, /* 邏 邏 */
    0xf914, 0x6a02, /* 樂 樂 */
    0xf915, 0x6d1b, /* 洛 洛 */
    0xf916, 0x70d9, /* 烙 烙 */
    0xf917, 0x73de, /* 珞 珞 */
    0xf918, 0x843d, /* 落 落 */
    0xf919, 0x916a, /* 酪 酪 */
    0xf91a, 0x99f1, /* 駱 駱 */
    0xf91b, 0x4e82, /* 亂 亂 */
    0xf91c, 0x5375, /* 卵 卵 */
    0xf91d, 0x6b04, /* 欄 欄 */
    0xf91e, 0x721b, /* 爛 爛 */
    0xf91f, 0x862d, /* 蘭 蘭 */
    0xf920, 0x9e1e, /* 鸞 鸞 */
    0xf921, 0x5d50, /* 嵐 嵐 */
    0xf922, 0x6feb, /* 濫 濫 */
    0xf923, 0x85cd, /* 藍 藍 */
    0xf924, 0x8964, /* 襤 襤 */
    0xf925, 0x62c9, /* 拉 拉 */
    0xf926, 0x81d8, /* 臘 臘 */
    0xf927, 0x881f, /* 蠟 蠟 */
    0xf928, 0x5eca, /* 廊 廊 */
    0xf929, 0x6717, /* 朗 朗 */
    0xf92a, 0x6d6a, /* 浪 浪 */
    0xf92b, 0x72fc, /* 狼 狼 */
    0xf92c, 0x90ce, /* 郎 郎 */
    0xf92d, 0x4f86, /* 來 來 */
    0xf92e, 0x51b7, /* 冷 冷 */
    0xf92f, 0x52de, /* 勞 勞 */
    0xf930, 0x64c4, /* 擄 擄 */
    0xf931, 0x6ad3, /* 櫓 櫓 */
    0xf932, 0x7210, /* 爐 爐 */
    0xf933, 0x76e7, /* 盧 盧 */
    0xf934, 0x8001, /* 老 老 */
    0xf935, 0x8606, /* 蘆 蘆 */
    0xf936, 0x865c, /* 虜 虜 */
    0xf937, 0x8def, /* 路 路 */
    0xf938, 0x9732, /* 露 露 */
    0xf939, 0x9b6f, /* 魯 魯 */
    0xf93a, 0x9dfa, /* 鷺 鷺 */
    0xf93b, 0x788c, /* 碌 碌 */
    0xf93c, 0x797f, /* 祿 祿 */
    0xf93d, 0x7da0, /* 綠 綠 */
    0xf93e, 0x83c9, /* 菉 菉 */
    0xf93f, 0x9304, /* 錄 錄 */
    0xf940, 0x9e7f, /* 鹿 鹿 */
    0xf941, 0x8ad6, /* 論 論 */
    0xf942, 0x58df, /* 壟 壟 */
    0xf943, 0x5f04, /* 弄 弄 */
    0xf944, 0x7c60, /* 籠 籠 */
    0xf945, 0x807e, /* 聾 聾 */
    0xf946, 0x7262, /* 牢 牢 */
    0xf947, 0x78ca, /* 磊 磊 */
    0xf948, 0x8cc2, /* 賂 賂 */
    0xf949, 0x96f7, /* 雷 雷 */
    0xf94a, 0x58d8, /* 壘 壘 */
    0xf94b, 0x5c62, /* 屢 屢 */
    0xf94c, 0x6a13, /* 樓 樓 */
    0xf94d, 0x6dda, /* 淚 淚 */
    0xf94e, 0x6f0f, /* 漏 漏 */
    0xf94f, 0x7d2f, /* 累 累 */
    0xf950, 0x7e37, /* 縷 縷 */
    0xf951, 0x964b, /* 陋 陋 */
    0xf952, 0x52d2, /* 勒 勒 */
    0xf953, 0x808b, /* 肋 肋 */
    0xf954, 0x51dc, /* 凜 凜 */
    0xf955, 0x51cc, /* 凌 凌 */
    0xf956, 0x7a1c, /* 稜 稜 */
    0xf957, 0x7dbe, /* 綾 綾 */
    0xf958, 0x83f1, /* 菱 菱 */
    0xf959, 0x9675, /* 陵 陵 */
    0xf95a, 0x8b80, /* 讀 讀 */
    0xf95b, 0x62cf, /* 拏 拏 */
    0xf95c, 0x6a02, /* 樂 樂 */
    0xf95d, 0x8afe, /* 諾 諾 */
    0xf95e, 0x4e39, /* 丹 丹 */
    0xf95f, 0x5be7, /* 寧 寧 */
    0xf960, 0x6012, /* 怒 怒 */
    0xf961, 0x7387, /* 率 率 */
    0xf962, 0x7570, /* 異 異 */
    0xf963, 0x5317, /* 北 北 */
    0xf964, 0x78fb, /* 磻 磻 */
    0xf965, 0x4fbf, /* 便 便 */
    0xf966, 0x5fa9, /* 復 復 */
    0xf967, 0x4e0d, /* 不 不 */
    0xf968, 0x6ccc, /* 泌 泌 */
    0xf969, 0x6578, /* 數 數 */
    0xf96a, 0x7d22, /* 索 索 */
    0xf96b, 0x53c3, /* 參 參 */
    0xf96c, 0x585e, /* 塞 塞 */
    0xf96d, 0x7701, /* 省 省 */
    0xf96e, 0x8449, /* 葉 葉 */
    0xf96f, 0x8aaa, /* 說 說 */
    0xf970, 0x6bba, /* 殺 殺 */
    0xf971, 0x8fb0, /* 辰 辰 */
    0xf972, 0x6c88, /* 沈 沈 */
    0xf973, 0x62fe, /* 拾 拾 */
    0xf974, 0x82e5, /* 若 若 */
    0xf975, 0x63a0, /* 掠 掠 */
    0xf976, 0x7565, /* 略 略 */
    0xf977, 0x4eae, /* 亮 亮 */
    0xf978, 0x5169, /* 兩 兩 */
    0xf979, 0x51c9, /* 凉 凉 */
    0xf97a, 0x6881, /* 梁 梁 */
    0xf97b, 0x7ce7, /* 糧 糧 */
    0xf97c, 0x826f, /* 良 良 */
    0xf97d, 0x8ad2, /* 諒 諒 */
    0xf97e, 0x91cf, /* 量 量 */
    0xf97f, 0x52f5, /* 勵 勵 */
    0xf980, 0x5442, /* 呂 呂 */
    0xf981, 0x5973, /* 女 女 */
    0xf982, 0x5eec, /* 廬 廬 */
    0xf983, 0x65c5, /* 旅 旅 */
    0xf984, 0x6ffe, /* 濾 濾 */
    0xf985, 0x792a, /* 礪 礪 */
    0xf986, 0x95ad, /* 閭 閭 */
    0xf987, 0x9a6a, /* 驪 驪 */
    0xf988, 0x9e97, /* 麗 麗 */
    0xf989, 0x9ece, /* 黎 黎 */
    0xf98a, 0x529b, /* 力 力 */
    0xf98b, 0x66c6, /* 曆 曆 */
    0xf98c, 0x6b77, /* 歷 歷 */
    0xf98d, 0x8f62, /* 轢 轢 */
    0xf98e, 0x5e74, /* 年 年 */
    0xf98f, 0x6190, /* 憐 憐 */
    0xf990, 0x6200, /* 戀 戀 */
    0xf991, 0x649a, /* 撚 撚 */
    0xf992, 0x6f23, /* 漣 漣 */
    0xf993, 0x7149, /* 煉 煉 */
    0xf994, 0x7489, /* 璉 璉 */
    0xf995, 0x79ca, /* 秊 秊 */
    0xf996, 0x7df4, /* 練 練 */
    0xf997, 0x806f, /* 聯 聯 */
    0xf998, 0x8f26, /* 輦 輦 */
    0xf999, 0x84ee, /* 蓮 蓮 */
    0xf99a, 0x9023, /* 連 連 */
    0xf99b, 0x934a, /* 鍊 鍊 */
    0xf99c, 0x5217, /* 列 列 */
    0xf99d, 0x52a3, /* 劣 劣 */
    0xf99e, 0x54bd, /* 咽 咽 */
    0xf99f, 0x70c8, /* 烈 烈 */
    0xf9a0, 0x88c2, /* 裂 裂 */
    0xf9a1, 0x8aaa, /* 說 說 */
    0xf9a2, 0x5ec9, /* 廉 廉 */
    0xf9a3, 0x5ff5, /* 念 念 */
    0xf9a4, 0x637b, /* 捻 捻 */
    0xf9a5, 0x6bae, /* 殮 殮 */
    0xf9a6, 0x7c3e, /* 簾 簾 */
    0xf9a7, 0x7375, /* 獵 獵 */
    0xf9a8, 0x4ee4, /* 令 令 */
    0xf9a9, 0x56f9, /* 囹 囹 */
    0xf9aa, 0x5be7, /* 寧 寧 */
    0xf9ab, 0x5dba, /* 嶺 嶺 */
    0xf9ac, 0x601c, /* 怜 怜 */
    0xf9ad, 0x73b2, /* 玲 玲 */
    0xf9ae, 0x7469, /* 瑩 瑩 */
    0xf9af, 0x7f9a, /* 羚 羚 */
    0xf9b0, 0x8046, /* 聆 聆 */
    0xf9b1, 0x9234, /* 鈴 鈴 */
    0xf9b2, 0x96f6, /* 零 零 */
    0xf9b3, 0x9748, /* 靈 靈 */
    0xf9b4, 0x9818, /* 領 領 */
    0xf9b5, 0x4f8b, /* 例 例 */
    0xf9b6, 0x79ae, /* 禮 禮 */
    0xf9b7, 0x91b4, /* 醴 醴 */
    0xf9b8, 0x96b8, /* 隸 隸 */
    0xf9b9, 0x60e1, /* 惡 惡 */
    0xf9ba, 0x4e86, /* 了 了 */
    0xf9bb, 0x50da, /* 僚 僚 */
    0xf9bc, 0x5bee, /* 寮 寮 */
    0xf9bd, 0x5c3f, /* 尿 尿 */
    0xf9be, 0x6599, /* 料 料 */
    0xf9bf, 0x6a02, /* 樂 樂 */
    0xf9c0, 0x71ce, /* 燎 燎 */
    0xf9c1, 0x7642, /* 療 療 */
    0xf9c2, 0x84fc, /* 蓼 蓼 */
    0xf9c3, 0x907c, /* 遼 遼 */
    0xf9c4, 0x9f8d, /* 龍 龍 */
    0xf9c5, 0x6688, /* 暈 暈 */
    0xf9c6, 0x962e, /* 阮 阮 */
    0xf9c7, 0x5289, /* 劉 劉 */
    0xf9c8, 0x677b, /* 杻 杻 */
    0xf9c9, 0x67f3, /* 柳 柳 */
    0xf9ca, 0x6d41, /* 流 流 */
    0xf9cb, 0x6e9c, /* 溜 溜 */
    0xf9cc, 0x7409, /* 琉 琉 */
    0xf9cd, 0x7559, /* 留 留 */
    0xf9ce, 0x786b, /* 硫 硫 */
    0xf9cf, 0x7d10, /* 紐 紐 */
    0xf9d0, 0x985e, /* 類 類 */
    0xf9d1, 0x516d, /* 六 六 */
    0xf9d2, 0x622e, /* 戮 戮 */
    0xf9d3, 0x9678, /* 陸 陸 */
    0xf9d4, 0x502b, /* 倫 倫 */
    0xf9d5, 0x5d19, /* 崙 崙 */
    0xf9d6, 0x6dea, /* 淪 淪 */
    0xf9d7, 0x8f2a, /* 輪 輪 */
    0xf9d8, 0x5f8b, /* 律 律 */
    0xf9d9, 0x6144, /* 慄 慄 */
    0xf9da, 0x6817, /* 栗 栗 */
    0xf9db, 0x7387, /* 率 率 */
    0xf9dc, 0x9686, /* 隆 隆 */
    0xf9dd, 0x5229, /* 利 利 */
    0xf9de, 0x540f, /* 吏 吏 */
    0xf9df, 0x5c65, /* 履 履 */
    0xf9e0, 0x6613, /* 易 易 */
    0xf9e1, 0x674e, /* 李 李 */
    0xf9e2, 0x68a8, /* 梨 梨 */
    0xf9e3, 0x6ce5, /* 泥 泥 */
    0xf9e4, 0x7406, /* 理 理 */
    0xf9e5, 0x75e2, /* 痢 痢 */
    0xf9e6, 0x7f79, /* 罹 罹 */
    0xf9e7, 0x88cf, /* 裏 裏 */
    0xf9e8, 0x88e1, /* 裡 裡 */
    0xf9e9, 0x91cc, /* 里 里 */
    0xf9ea, 0x96e2, /* 離 離 */
    0xf9eb, 0x533f, /* 匿 匿 */
    0xf9ec, 0x6eba, /* 溺 溺 */
    0xf9ed, 0x541d, /* 吝 吝 */
    0xf9ee, 0x71d0, /* 燐 燐 */
    0xf9ef, 0x7498, /* 璘 璘 */
    0xf9f0, 0x85fa, /* 藺 藺 */
    0xf9f1, 0x96a3, /* 隣 隣 */
    0xf9f2, 0x9c57, /* 鱗 鱗 */
    0xf9f3, 0x9e9f, /* 麟 麟 */
    0xf9f4, 0x6797, /* 林 林 */
    0xf9f5, 0x6dcb, /* 淋 淋 */
    0xf9f6, 0x81e8, /* 臨 臨 */
    0xf9f7, 0x7acb, /* 立 立 */
    0xf9f8, 0x7b20, /* 笠 笠 */
    0xf9f9, 0x7c92, /* 粒 粒 */
    0xf9fa, 0x72c0, /* 狀 狀 */
    0xf9fb, 0x7099, /* 炙 炙 */
    0xf9fc, 0x8b58, /* 識 識 */
    0xf9fd, 0x4ec0, /* 什 什 */
    0xf9fe, 0x8336, /* 茶 茶 */
    0xf9ff, 0x523a, /* 刺 刺 */
    0xfa00, 0x5207, /* 切 切 */
    0xfa01, 0x5ea6, /* 度 度 */
    0xfa02, 0x62d3, /* 拓 拓 */
    0xfa03, 0x7cd6, /* 糖 糖 */
    0xfa04, 0x5b85, /* 宅 宅 */
    0xfa05, 0x6d1e, /* 洞 洞 */
    0xfa06, 0x66b4, /* 暴 暴 */
    0xfa07, 0x8f3b, /* 輻 輻 */
    0xfa08, 0x884c, /* 行 行 */
    0xfa09, 0x964d, /* 降 降 */
    0xfa0a, 0x898b, /* 見 見 */
    0xfa0b, 0x5ed3, /* 廓 廓 */
    0xfa0c, 0x5140, /* 兀 兀 */
    0xfa0d, 0x55c0, /* 嗀 嗀 */
    0xfa10, 0x585a, /* 塚 塚 */
    0xfa12, 0x6674, /* 晴 晴 */
    0xfa15, 0x51de, /* 凞 凞 */
    0xfa16, 0x732a, /* 猪 猪 */
    0xfa17, 0x76ca, /* 益 益 */
    0xfa18, 0x793c, /* 礼 礼 */
    0xfa19, 0x795e, /* 神 神 */
    0xfa1a, 0x7965, /* 祥 祥 */
    0xfa1b, 0x798f, /* 福 福 */
    0xfa1c, 0x9756, /* 靖 靖 */
    0xfa1d, 0x7cbe, /* 精 精 */
    0xfa1e, 0x7fbd, /* 羽 羽 */
    0xfa20, 0x8612, /* 蘒 蘒 */
    0xfa22, 0x8af8, /* 諸 諸 */
    0xfa25, 0x9038, /* 逸 逸 */
    0xfa26, 0x90fd, /* 都 都 */
    0xfa2a, 0x98ef, /* 飯 飯 */
    0xfa2b, 0x98fc, /* 飼 飼 */
    0xfa2c, 0x9928, /* 館 館 */
    0xfa2d, 0x9db4, /* 鶴 鶴 */
    0xfa2e, 0x90de, /* 郞 郞 */
    0xfa2f, 0x96b7, /* 隷 隷 */
    0xfa30, 0x4fae, /* 侮 侮 */
    0xfa31, 0x50e7, /* 僧 僧 */
    0xfa32, 0x514d, /* 免 免 */
    0xfa33, 0x52c9, /* 勉 勉 */
    0xfa34, 0x52e4, /* 勤 勤 */
    0xfa35, 0x5351, /* 卑 卑 */
    0xfa36, 0x559d, /* 喝 喝 */
    0xfa37, 0x5606, /* 嘆 嘆 */
    0xfa38, 0x5668, /* 器 器 */
    0xfa39, 0x5840, /* 塀 塀 */
    0xfa3a, 0x58a8, /* 墨 墨 */
    0xfa3b, 0x5c64, /* 層 層 */
    0xfa3c, 0x5c6e, /* 屮 屮 */
    0xfa3d, 0x6094, /* 悔 悔 */
    0xfa3e, 0x6168, /* 慨 慨 */
    0xfa3f, 0x618e, /* 憎 憎 */
    0xfa40, 0x61f2, /* 懲 懲 */
    0xfa41, 0x654f, /* 敏 敏 */
    0xfa42, 0x65e2, /* 既 既 */
    0xfa43, 0x6691, /* 暑 暑 */
    0xfa44, 0x6885, /* 梅 梅 */
    0xfa45, 0x6d77, /* 海 海 */
    0xfa46, 0x6e1a, /* 渚 渚 */
    0xfa47, 0x6f22, /* 漢 漢 */
    0xfa48, 0x716e, /* 煮 煮 */
    0xfa49, 0x722b, /* 爫 爫 */
    0xfa4a, 0x7422, /* 琢 琢 */
    0xfa4b, 0x7891, /* 碑 碑 */
    0xfa4c, 0x793e, /* 社 社 */
    0xfa4d, 0x7949, /* 祉 祉 */
    0xfa4e, 0x7948, /* 祈 祈 */
    0xfa4f, 0x7950, /* 祐 祐 */
    0xfa50, 0x7956, /* 祖 祖 */
    0xfa51, 0x795d, /* 祝 祝 */
    0xfa52, 0x798d, /* 禍 禍 */
    0xfa53, 0x798e, /* 禎 禎 */
    0xfa54, 0x7a40, /* 穀 穀 */
    0xfa55, 0x7a81, /* 突 突 */
    0xfa56, 0x7bc0, /* 節 節 */
    0xfa57, 0x7df4, /* 練 練 */
    0xfa58, 0x7e09, /* 縉 縉 */
    0xfa59, 0x7e41, /* 繁 繁 */
    0xfa5a, 0x7f72, /* 署 署 */
    0xfa5b, 0x8005, /* 者 者 */
    0xfa5c, 0x81ed, /* 臭 臭 */
    0xfa5d, 0x8279, /* 艹 艹 */
    0xfa5e, 0x8279, /* 艹 艹 */
    0xfa5f, 0x8457, /* 著 著 */
    0xfa60, 0x8910, /* 褐 褐 */
    0xfa61, 0x8996, /* 視 視 */
    0xfa62, 0x8b01, /* 謁 謁 */
    0xfa63, 0x8b39, /* 謹 謹 */
    0xfa64, 0x8cd3, /* 賓 賓 */
    0xfa65, 0x8d08, /* 贈 贈 */
    0xfa66, 0x8fb6, /* 辶 辶 */
    0xfa67, 0x9038, /* 逸 逸 */
    0xfa68, 0x96e3, /* 難 難 */
    0xfa69, 0x97ff, /* 響 響 */
    0xfa6a, 0x983b, /* 頻 頻 */
    0xfa6b, 0x6075, /* 恵 恵 */
    0xfa6c, 0x242ee,    /* 𤋮 𤋮 */
    0xfa6d, 0x8218, /* 舘 舘 */
    0xfa70, 0x4e26, /* 並 並 */
    0xfa71, 0x51b5, /* 况 况 */
    0xfa72, 0x5168, /* 全 全 */
    0xfa73, 0x4f80, /* 侀 侀 */
    0xfa74, 0x5145, /* 充 充 */
    0xfa75, 0x5180, /* 冀 冀 */
    0xfa76, 0x52c7, /* 勇 勇 */
    0xfa77, 0x52fa, /* 勺 勺 */
    0xfa78, 0x559d, /* 喝 喝 */
    0xfa79, 0x5555, /* 啕 啕 */
    0xfa7a, 0x5599, /* 喙 喙 */
    0xfa7b, 0x55e2, /* 嗢 嗢 */
    0xfa7c, 0x585a, /* 塚 塚 */
    0xfa7d, 0x58b3, /* 墳 墳 */
    0xfa7e, 0x5944, /* 奄 奄 */
    0xfa7f, 0x5954, /* 奔 奔 */
    0xfa80, 0x5a62, /* 婢 婢 */
    0xfa81, 0x5b28, /* 嬨 嬨 */
    0xfa82, 0x5ed2, /* 廒 廒 */
    0xfa83, 0x5ed9, /* 廙 廙 */
    0xfa84, 0x5f69, /* 彩 彩 */
    0xfa85, 0x5fad, /* 徭 徭 */
    0xfa86, 0x60d8, /* 惘 惘 */
    0xfa87, 0x614e, /* 慎 慎 */
    0xfa88, 0x6108, /* 愈 愈 */
    0xfa89, 0x618e, /* 憎 憎 */
    0xfa8a, 0x6160, /* 慠 慠 */
    0xfa8b, 0x61f2, /* 懲 懲 */
    0xfa8c, 0x6234, /* 戴 戴 */
    0xfa8d, 0x63c4, /* 揄 揄 */
    0xfa8e, 0x641c, /* 搜 搜 */
    0xfa8f, 0x6452, /* 摒 摒 */
    0xfa90, 0x6556, /* 敖 敖 */
    0xfa91, 0x6674, /* 晴 晴 */
    0xfa92, 0x6717, /* 朗 朗 */
    0xfa93, 0x671b, /* 望 望 */
    0xfa94, 0x6756, /* 杖 杖 */
    0xfa95, 0x6b79, /* 歹 歹 */
    0xfa96, 0x6bba, /* 殺 殺 */
    0xfa97, 0x6d41, /* 流 流 */
    0xfa98, 0x6edb, /* 滛 滛 */
    0xfa99, 0x6ecb, /* 滋 滋 */
    0xfa9a, 0x6f22, /* 漢 漢 */
    0xfa9b, 0x701e, /* 瀞 瀞 */
    0xfa9c, 0x716e, /* 煮 煮 */
    0xfa9d, 0x77a7, /* 瞧 瞧 */
    0xfa9e, 0x7235, /* 爵 爵 */
    0xfa9f, 0x72af, /* 犯 犯 */
    0xfaa0, 0x732a, /* 猪 猪 */
    0xfaa1, 0x7471, /* 瑱 瑱 */
    0xfaa2, 0x7506, /* 甆 甆 */
    0xfaa3, 0x753b, /* 画 画 */
    0xfaa4, 0x761d, /* 瘝 瘝 */
    0xfaa5, 0x761f, /* 瘟 瘟 */
    0xfaa6, 0x76ca, /* 益 益 */
    0xfaa7, 0x76db, /* 盛 盛 */
    0xfaa8, 0x76f4, /* 直 直 */
    0xfaa9, 0x774a, /* 睊 睊 */
    0xfaaa, 0x7740, /* 着 着 */
    0xfaab, 0x78cc, /* 磌 磌 */
    0xfaac, 0x7ab1, /* 窱 窱 */
    0xfaad, 0x7bc0, /* 節 節 */
    0xfaae, 0x7c7b, /* 类 类 */
    0xfaaf, 0x7d5b, /* 絛 絛 */
    0xfab0, 0x7df4, /* 練 練 */
    0xfab1, 0x7f3e, /* 缾 缾 */
    0xfab2, 0x8005, /* 者 者 */
    0xfab3, 0x8352, /* 荒 荒 */
    0xfab4, 0x83ef, /* 華 華 */
    0xfab5, 0x8779, /* 蝹 蝹 */
    0xfab6, 0x8941, /* 襁 襁 */
    0xfab7, 0x8986, /* 覆 覆 */
    0xfab8, 0x8996, /* 視 視 */
    0xfab9, 0x8abf, /* 調 調 */
    0xfaba, 0x8af8, /* 諸 諸 */
    0xfabb, 0x8acb, /* 請 請 */
    0xfabc, 0x8b01, /* 謁 謁 */
    0xfabd, 0x8afe, /* 諾 諾 */
    0xfabe, 0x8aed, /* 諭 諭 */
    0xfabf, 0x8b39, /* 謹 謹 */
    0xfac0, 0x8b8a, /* 變 變 */
    0xfac1, 0x8d08, /* 贈 贈 */
    0xfac2, 0x8f38, /* 輸 輸 */
    0xfac3, 0x9072, /* 遲 遲 */
    0xfac4, 0x9199, /* 醙 醙 */
    0xfac5, 0x9276, /* 鉶 鉶 */
    0xfac6, 0x967c, /* 陼 陼 */
    0xfac7, 0x96e3, /* 難 難 */
    0xfac8, 0x9756, /* 靖 靖 */
    0xfac9, 0x97db, /* 韛 韛 */
    0xfaca, 0x97ff, /* 響 響 */
    0xfacb, 0x980b, /* 頋 頋 */
    0xfacc, 0x983b, /* 頻 頻 */
    0xfacd, 0x9b12, /* 鬒 鬒 */
    0xface, 0x9f9c, /* 龜 龜 */
    0xfacf, 0x2284a,    /* 𢡊 𢡊 */
    0xfad0, 0x22844,    /* 𢡄 𢡄 */
    0xfad1, 0x233d5,    /* 𣏕 𣏕 */
    0xfad2, 0x3b9d, /* 㮝 㮝 */
    0xfad3, 0x4018, /* 䀘 䀘 */
    0xfad4, 0x4039, /* 䀹 䀹 */
    0xfad5, 0x25249,    /* 𥉉 𥉉 */
    0xfad6, 0x25cd0,    /* 𥳐 𥳐 */
    0xfad7, 0x27ed3,    /* 𧻓 𧻓 */
    0xfad8, 0x9f43, /* 齃 齃 */
    0xfad9, 0x9f8e, /* 龎 龎 */
    0xfb1d, 0x05d9, /* יִ י */
    0xfb1f, 0x05f2, /* ײַ ײ */
    0xfb2a, 0x05e9, /* שׁ ש */
    0xfb2b, 0x05e9, /* שׂ ש */
    0xfb2c, 0x05e9, /* שּׁ ש */
    0xfb2d, 0x05e9, /* שּׂ ש */
    0xfb2e, 0x05d0, /* אַ א */
    0xfb2f, 0x05d0, /* אָ א */
    0xfb30, 0x05d0, /* אּ א */
    0xfb31, 0x05d1, /* בּ ב */
    0xfb32, 0x05d2, /* גּ ג */
    0xfb33, 0x05d3, /* דּ ד */
    0xfb34, 0x05d4, /* הּ ה */
    0xfb35, 0x05d5, /* וּ ו */
    0xfb36, 0x05d6, /* זּ ז */
    0xfb38, 0x05d8, /* טּ ט */
    0xfb39, 0x05d9, /* יּ י */
    0xfb3a, 0x05da, /* ךּ ך */
    0xfb3b, 0x05db, /* כּ כ */
    0xfb3c, 0x05dc, /* לּ ל */
    0xfb3e, 0x05de, /* מּ מ */
    0xfb40, 0x05e0, /* נּ נ */
    0xfb41, 0x05e1, /* סּ ס */
    0xfb43, 0x05e3, /* ףּ ף */
    0xfb44, 0x05e4, /* פּ פ */
    0xfb46, 0x05e6, /* צּ צ */
    0xfb47, 0x05e7, /* קּ ק */
    0xfb48, 0x05e8, /* רּ ר */
    0xfb49, 0x05e9, /* שּ ש */
    0xfb4a, 0x05ea, /* תּ ת */
    0xfb4b, 0x05d5, /* וֹ ו */
    0xfb4c, 0x05d1, /* בֿ ב */
    0xfb4d, 0x05db, /* כֿ כ */
    0xfb4e, 0x05e4, /* פֿ פ */
    0x1109a,    0x11099,    /* 𑂚 𑂙 */
    0x1109c,    0x1109b,    /* 𑂜 𑂛 */
    0x110ab,    0x110a5,    /* 𑂫 𑂥 */
    0x2f800,    0x4e3d, /* 丽 丽 */
    0x2f801,    0x4e38, /* 丸 丸 */
    0x2f802,    0x4e41, /* 乁 乁 */
    0x2f803,    0x20122,    /* 𠄢 𠄢 */
    0x2f804,    0x4f60, /* 你 你 */
    0x2f805,    0x4fae, /* 侮 侮 */
    0x2f806,    0x4fbb, /* 侻 侻 */
    0x2f807,    0x5002, /* 倂 倂 */
    0x2f808,    0x507a, /* 偺 偺 */
    0x2f809,    0x5099, /* 備 備 */
    0x2f80a,    0x50e7, /* 僧 僧 */
    0x2f80b,    0x50cf, /* 像 像 */
    0x2f80c,    0x349e, /* 㒞 㒞 */
    0x2f80d,    0x2063a,    /* 𠘺 𠘺 */
    0x2f80e,    0x514d, /* 免 免 */
    0x2f80f,    0x5154, /* 兔 兔 */
    0x2f810,    0x5164, /* 兤 兤 */
    0x2f811,    0x5177, /* 具 具 */
    0x2f812,    0x2051c,    /* 𠔜 𠔜 */
    0x2f813,    0x34b9, /* 㒹 㒹 */
    0x2f814,    0x5167, /* 內 內 */
    0x2f815,    0x518d, /* 再 再 */
    0x2f816,    0x2054b,    /* 𠕋 𠕋 */
    0x2f817,    0x5197, /* 冗 冗 */
    0x2f818,    0x51a4, /* 冤 冤 */
    0x2f819,    0x4ecc, /* 仌 仌 */
    0x2f81a,    0x51ac, /* 冬 冬 */
    0x2f81b,    0x51b5, /* 况 况 */
    0x2f81c,    0x291df,    /* 𩇟 𩇟 */
    0x2f81d,    0x51f5, /* 凵 凵 */
    0x2f81e,    0x5203, /* 刃 刃 */
    0x2f81f,    0x34df, /* 㓟 㓟 */
    0x2f820,    0x523b, /* 刻 刻 */
    0x2f821,    0x5246, /* 剆 剆 */
    0x2f822,    0x5272, /* 割 割 */
    0x2f823,    0x5277, /* 剷 剷 */
    0x2f824,    0x3515, /* 㔕 㔕 */
    0x2f825,    0x52c7, /* 勇 勇 */
    0x2f826,    0x52c9, /* 勉 勉 */
    0x2f827,    0x52e4, /* 勤 勤 */
    0x2f828,    0x52fa, /* 勺 勺 */
    0x2f829,    0x5305, /* 包 包 */
    0x2f82a,    0x5306, /* 匆 匆 */
    0x2f82b,    0x5317, /* 北 北 */
    0x2f82c,    0x5349, /* 卉 卉 */
    0x2f82d,    0x5351, /* 卑 卑 */
    0x2f82e,    0x535a, /* 博 博 */
    0x2f82f,    0x5373, /* 即 即 */
    0x2f830,    0x537d, /* 卽 卽 */
    0x2f831,    0x537f, /* 卿 卿 */
    0x2f832,    0x537f, /* 卿 卿 */
    0x2f833,    0x537f, /* 卿 卿 */
    0x2f834,    0x20a2c,    /* 𠨬 𠨬 */
    0x2f835,    0x7070, /* 灰 灰 */
    0x2f836,    0x53ca, /* 及 及 */
    0x2f837,    0x53df, /* 叟 叟 */
    0x2f838,    0x20b63,    /* 𠭣 𠭣 */
    0x2f839,    0x53eb, /* 叫 叫 */
    0x2f83a,    0x53f1, /* 叱 叱 */
    0x2f83b,    0x5406, /* 吆 吆 */
    0x2f83c,    0x549e, /* 咞 咞 */
    0x2f83d,    0x5438, /* 吸 吸 */
    0x2f83e,    0x5448, /* 呈 呈 */
    0x2f83f,    0x5468, /* 周 周 */
    0x2f840,    0x54a2, /* 咢 咢 */
    0x2f841,    0x54f6, /* 哶 哶 */
    0x2f842,    0x5510, /* 唐 唐 */
    0x2f843,    0x5553, /* 啓 啓 */
    0x2f844,    0x5563, /* 啣 啣 */
    0x2f845,    0x5584, /* 善 善 */
    0x2f846,    0x5584, /* 善 善 */
    0x2f847,    0x5599, /* 喙 喙 */
    0x2f848,    0x55ab, /* 喫 喫 */
    0x2f849,    0x55b3, /* 喳 喳 */
    0x2f84a,    0x55c2, /* 嗂 嗂 */
    0x2f84b,    0x5716, /* 圖 圖 */
    0x2f84c,    0x5606, /* 嘆 嘆 */
    0x2f84d,    0x5717, /* 圗 圗 */
    0x2f84e,    0x5651, /* 噑 噑 */
    0x2f84f,    0x5674, /* 噴 噴 */
    0x2f850,    0x5207, /* 切 切 */
    0x2f851,    0x58ee, /* 壮 壮 */
    0x2f852,    0x57ce, /* 城 城 */
    0x2f853,    0x57f4, /* 埴 埴 */
    0x2f854,    0x580d, /* 堍 堍 */
    0x2f855,    0x578b, /* 型 型 */
    0x2f856,    0x5832, /* 堲 堲 */
    0x2f857,    0x5831, /* 報 報 */
    0x2f858,    0x58ac, /* 墬 墬 */
    0x2f859,    0x214e4,    /* 𡓤 𡓤 */
    0x2f85a,    0x58f2, /* 売 売 */
    0x2f85b,    0x58f7, /* 壷 壷 */
    0x2f85c,    0x5906, /* 夆 夆 */
    0x2f85d,    0x591a, /* 多 多 */
    0x2f85e,    0x5922, /* 夢 夢 */
    0x2f85f,    0x5962, /* 奢 奢 */
    0x2f860,    0x216a8,    /* 𡚨 𡚨 */
    0x2f861,    0x216ea,    /* 𡛪 𡛪 */
    0x2f862,    0x59ec, /* 姬 姬 */
    0x2f863,    0x5a1b, /* 娛 娛 */
    0x2f864,    0x5a27, /* 娧 娧 */
    0x2f865,    0x59d8, /* 姘 姘 */
    0x2f866,    0x5a66, /* 婦 婦 */
    0x2f867,    0x36ee, /* 㛮 㛮 */
    0x2f868,    0x36fc, /* 㛼 㛼 */
    0x2f869,    0x5b08, /* 嬈 嬈 */
    0x2f86a,    0x5b3e, /* 嬾 嬾 */
    0x2f86b,    0x5b3e, /* 嬾 嬾 */
    0x2f86c,    0x219c8,    /* 𡧈 𡧈 */
    0x2f86d,    0x5bc3, /* 寃 寃 */
    0x2f86e,    0x5bd8, /* 寘 寘 */
    0x2f86f,    0x5be7, /* 寧 寧 */
    0x2f870,    0x5bf3, /* 寳 寳 */
    0x2f871,    0x21b18,    /* 𡬘 𡬘 */
    0x2f872,    0x5bff, /* 寿 寿 */
    0x2f873,    0x5c06, /* 将 将 */
    0x2f874,    0x5f53, /* 当 当 */
    0x2f875,    0x5c22, /* 尢 尢 */
    0x2f876,    0x3781, /* 㞁 㞁 */
    0x2f877,    0x5c60, /* 屠 屠 */
    0x2f878,    0x5c6e, /* 屮 屮 */
    0x2f879,    0x5cc0, /* 峀 峀 */
    0x2f87a,    0x5c8d, /* 岍 岍 */
    0x2f87b,    0x21de4,    /* 𡷤 𡷤 */
    0x2f87c,    0x5d43, /* 嵃 嵃 */
    0x2f87d,    0x21de6,    /* 𡷦 𡷦 */
    0x2f87e,    0x5d6e, /* 嵮 嵮 */
    0x2f87f,    0x5d6b, /* 嵫 嵫 */
    0x2f880,    0x5d7c, /* 嵼 嵼 */
    0x2f881,    0x5de1, /* 巡 巡 */
    0x2f882,    0x5de2, /* 巢 巢 */
    0x2f883,    0x382f, /* 㠯 㠯 */
    0x2f884,    0x5dfd, /* 巽 巽 */
    0x2f885,    0x5e28, /* 帨 帨 */
    0x2f886,    0x5e3d, /* 帽 帽 */
    0x2f887,    0x5e69, /* 幩 幩 */
    0x2f888,    0x3862, /* 㡢 㡢 */
    0x2f889,    0x22183,    /* 𢆃 𢆃 */
    0x2f88a,    0x387c, /* 㡼 㡼 */
    0x2f88b,    0x5eb0, /* 庰 庰 */
    0x2f88c,    0x5eb3, /* 庳 庳 */
    0x2f88d,    0x5eb6, /* 庶 庶 */
    0x2f88e,    0x5eca, /* 廊 廊 */
    0x2f88f,    0x2a392,    /* 𪎒 𪎒 */
    0x2f890,    0x5efe, /* 廾 廾 */
    0x2f891,    0x22331,    /* 𢌱 𢌱 */
    0x2f892,    0x22331,    /* 𢌱 𢌱 */
    0x2f893,    0x8201, /* 舁 舁 */
    0x2f894,    0x5f22, /* 弢 弢 */
    0x2f895,    0x5f22, /* 弢 弢 */
    0x2f896,    0x38c7, /* 㣇 㣇 */
    0x2f897,    0x232b8,    /* 𣊸 𣊸 */
    0x2f898,    0x261da,    /* 𦇚 𦇚 */
    0x2f899,    0x5f62, /* 形 形 */
    0x2f89a,    0x5f6b, /* 彫 彫 */
    0x2f89b,    0x38e3, /* 㣣 㣣 */
    0x2f89c,    0x5f9a, /* 徚 徚 */
    0x2f89d,    0x5fcd, /* 忍 忍 */
    0x2f89e,    0x5fd7, /* 志 志 */
    0x2f89f,    0x5ff9, /* 忹 忹 */
    0x2f8a0,    0x6081, /* 悁 悁 */
    0x2f8a1,    0x393a, /* 㤺 㤺 */
    0x2f8a2,    0x391c, /* 㤜 㤜 */
    0x2f8a3,    0x6094, /* 悔 悔 */
    0x2f8a4,    0x226d4,    /* 𢛔 𢛔 */
    0x2f8a5,    0x60c7, /* 惇 惇 */
    0x2f8a6,    0x6148, /* 慈 慈 */
    0x2f8a7,    0x614c, /* 慌 慌 */
    0x2f8a8,    0x614e, /* 慎 慎 */
    0x2f8a9,    0x614c, /* 慌 慌 */
    0x2f8aa,    0x617a, /* 慺 慺 */
    0x2f8ab,    0x618e, /* 憎 憎 */
    0x2f8ac,    0x61b2, /* 憲 憲 */
    0x2f8ad,    0x61a4, /* 憤 憤 */
    0x2f8ae,    0x61af, /* 憯 憯 */
    0x2f8af,    0x61de, /* 懞 懞 */
    0x2f8b0,    0x61f2, /* 懲 懲 */
    0x2f8b1,    0x61f6, /* 懶 懶 */
    0x2f8b2,    0x6210, /* 成 成 */
    0x2f8b3,    0x621b, /* 戛 戛 */
    0x2f8b4,    0x625d, /* 扝 扝 */
    0x2f8b5,    0x62b1, /* 抱 抱 */
    0x2f8b6,    0x62d4, /* 拔 拔 */
    0x2f8b7,    0x6350, /* 捐 捐 */
    0x2f8b8,    0x22b0c,    /* 𢬌 𢬌 */
    0x2f8b9,    0x633d, /* 挽 挽 */
    0x2f8ba,    0x62fc, /* 拼 拼 */
    0x2f8bb,    0x6368, /* 捨 捨 */
    0x2f8bc,    0x6383, /* 掃 掃 */
    0x2f8bd,    0x63e4, /* 揤 揤 */
    0x2f8be,    0x22bf1,    /* 𢯱 𢯱 */
    0x2f8bf,    0x6422, /* 搢 搢 */
    0x2f8c0,    0x63c5, /* 揅 揅 */
    0x2f8c1,    0x63a9, /* 掩 掩 */
    0x2f8c2,    0x3a2e, /* 㨮 㨮 */
    0x2f8c3,    0x6469, /* 摩 摩 */
    0x2f8c4,    0x647e, /* 摾 摾 */
    0x2f8c5,    0x649d, /* 撝 撝 */
    0x2f8c6,    0x6477, /* 摷 摷 */
    0x2f8c7,    0x3a6c, /* 㩬 㩬 */
    0x2f8c8,    0x654f, /* 敏 敏 */
    0x2f8c9,    0x656c, /* 敬 敬 */
    0x2f8ca,    0x2300a,    /* 𣀊 𣀊 */
    0x2f8cb,    0x65e3, /* 旣 旣 */
    0x2f8cc,    0x66f8, /* 書 書 */
    0x2f8cd,    0x6649, /* 晉 晉 */
    0x2f8ce,    0x3b19, /* 㬙 㬙 */
    0x2f8cf,    0x6691, /* 暑 暑 */
    0x2f8d0,    0x3b08, /* 㬈 㬈 */
    0x2f8d1,    0x3ae4, /* 㫤 㫤 */
    0x2f8d2,    0x5192, /* 冒 冒 */
    0x2f8d3,    0x5195, /* 冕 冕 */
    0x2f8d4,    0x6700, /* 最 最 */
    0x2f8d5,    0x669c, /* 暜 暜 */
    0x2f8d6,    0x80ad, /* 肭 肭 */
    0x2f8d7,    0x43d9, /* 䏙 䏙 */
    0x2f8d8,    0x6717, /* 朗 朗 */
    0x2f8d9,    0x671b, /* 望 望 */
    0x2f8da,    0x6721, /* 朡 朡 */
    0x2f8db,    0x675e, /* 杞 杞 */
    0x2f8dc,    0x6753, /* 杓 杓 */
    0x2f8dd,    0x233c3,    /* 𣏃 𣏃 */
    0x2f8de,    0x3b49, /* 㭉 㭉 */
    0x2f8df,    0x67fa, /* 柺 柺 */
    0x2f8e0,    0x6785, /* 枅 枅 */
    0x2f8e1,    0x6852, /* 桒 桒 */
    0x2f8e2,    0x6885, /* 梅 梅 */
    0x2f8e3,    0x2346d,    /* 𣑭 𣑭 */
    0x2f8e4,    0x688e, /* 梎 梎 */
    0x2f8e5,    0x681f, /* 栟 栟 */
    0x2f8e6,    0x6914, /* 椔 椔 */
    0x2f8e7,    0x3b9d, /* 㮝 㮝 */
    0x2f8e8,    0x6942, /* 楂 楂 */
    0x2f8e9,    0x69a3, /* 榣 榣 */
    0x2f8ea,    0x69ea, /* 槪 槪 */
    0x2f8eb,    0x6aa8, /* 檨 檨 */
    0x2f8ec,    0x236a3,    /* 𣚣 𣚣 */
    0x2f8ed,    0x6adb, /* 櫛 櫛 */
    0x2f8ee,    0x3c18, /* 㰘 㰘 */
    0x2f8ef,    0x6b21, /* 次 次 */
    0x2f8f0,    0x238a7,    /* 𣢧 𣢧 */
    0x2f8f1,    0x6b54, /* 歔 歔 */
    0x2f8f2,    0x3c4e, /* 㱎 㱎 */
    0x2f8f3,    0x6b72, /* 歲 歲 */
    0x2f8f4,    0x6b9f, /* 殟 殟 */
    0x2f8f5,    0x6bba, /* 殺 殺 */
    0x2f8f6,    0x6bbb, /* 殻 殻 */
    0x2f8f7,    0x23a8d,    /* 𣪍 𣪍 */
    0x2f8f8,    0x21d0b,    /* 𡴋 𡴋 */
    0x2f8f9,    0x23afa,    /* 𣫺 𣫺 */
    0x2f8fa,    0x6c4e, /* 汎 汎 */
    0x2f8fb,    0x23cbc,    /* 𣲼 𣲼 */
    0x2f8fc,    0x6cbf, /* 沿 沿 */
    0x2f8fd,    0x6ccd, /* 泍 泍 */
    0x2f8fe,    0x6c67, /* 汧 汧 */
    0x2f8ff,    0x6d16, /* 洖 洖 */
    0x2f900,    0x6d3e, /* 派 派 */
    0x2f901,    0x6d77, /* 海 海 */
    0x2f902,    0x6d41, /* 流 流 */
    0x2f903,    0x6d69, /* 浩 浩 */
    0x2f904,    0x6d78, /* 浸 浸 */
    0x2f905,    0x6d85, /* 涅 涅 */
    0x2f906,    0x23d1e,    /* 𣴞 𣴞 */
    0x2f907,    0x6d34, /* 洴 洴 */
    0x2f908,    0x6e2f, /* 港 港 */
    0x2f909,    0x6e6e, /* 湮 湮 */
    0x2f90a,    0x3d33, /* 㴳 㴳 */
    0x2f90b,    0x6ecb, /* 滋 滋 */
    0x2f90c,    0x6ec7, /* 滇 滇 */
    0x2f90d,    0x23ed1,    /* 𣻑 𣻑 */
    0x2f90e,    0x6df9, /* 淹 淹 */
    0x2f90f,    0x6f6e, /* 潮 潮 */
    0x2f910,    0x23f5e,    /* 𣽞 𣽞 */
    0x2f911,    0x23f8e,    /* 𣾎 𣾎 */
    0x2f912,    0x6fc6, /* 濆 濆 */
    0x2f913,    0x7039, /* 瀹 瀹 */
    0x2f914,    0x701e, /* 瀞 瀞 */
    0x2f915,    0x701b, /* 瀛 瀛 */
    0x2f916,    0x3d96, /* 㶖 㶖 */
    0x2f917,    0x704a, /* 灊 灊 */
    0x2f918,    0x707d, /* 災 災 */
    0x2f919,    0x7077, /* 灷 灷 */
    0x2f91a,    0x70ad, /* 炭 炭 */
    0x2f91b,    0x20525,    /* 𠔥 𠔥 */
    0x2f91c,    0x7145, /* 煅 煅 */
    0x2f91d,    0x24263,    /* 𤉣 𤉣 */
    0x2f91e,    0x719c, /* 熜 熜 */
    0x2f91f,    0x243ab,    /* 𤎫 𤎫 */
    0x2f920,    0x7228, /* 爨 爨 */
    0x2f921,    0x7235, /* 爵 爵 */
    0x2f922,    0x7250, /* 牐 牐 */
    0x2f923,    0x24608,    /* 𤘈 𤘈 */
    0x2f924,    0x7280, /* 犀 犀 */
    0x2f925,    0x7295, /* 犕 犕 */
    0x2f926,    0x24735,    /* 𤜵 𤜵 */
    0x2f927,    0x24814,    /* 𤠔 𤠔 */
    0x2f928,    0x737a, /* 獺 獺 */
    0x2f929,    0x738b, /* 王 王 */
    0x2f92a,    0x3eac, /* 㺬 㺬 */
    0x2f92b,    0x73a5, /* 玥 玥 */
    0x2f92c,    0x3eb8, /* 㺸 㺸 */
    0x2f92d,    0x3eb8, /* 㺸 㺸 */
    0x2f92e,    0x7447, /* 瑇 瑇 */
    0x2f92f,    0x745c, /* 瑜 瑜 */
    0x2f930,    0x7471, /* 瑱 瑱 */
    0x2f931,    0x7485, /* 璅 璅 */
    0x2f932,    0x74ca, /* 瓊 瓊 */
    0x2f933,    0x3f1b, /* 㼛 㼛 */
    0x2f934,    0x7524, /* 甤 甤 */
    0x2f935,    0x24c36,    /* 𤰶 𤰶 */
    0x2f936,    0x753e, /* 甾 甾 */
    0x2f937,    0x24c92,    /* 𤲒 𤲒 */
    0x2f938,    0x7570, /* 異 異 */
    0x2f939,    0x2219f,    /* 𢆟 𢆟 */
    0x2f93a,    0x7610, /* 瘐 瘐 */
    0x2f93b,    0x24fa1,    /* 𤾡 𤾡 */
    0x2f93c,    0x24fb8,    /* 𤾸 𤾸 */
    0x2f93d,    0x25044,    /* 𥁄 𥁄 */
    0x2f93e,    0x3ffc, /* 㿼 㿼 */
    0x2f93f,    0x4008, /* 䀈 䀈 */
    0x2f940,    0x76f4, /* 直 直 */
    0x2f941,    0x250f3,    /* 𥃳 𥃳 */
    0x2f942,    0x250f2,    /* 𥃲 𥃲 */
    0x2f943,    0x25119,    /* 𥄙 𥄙 */
    0x2f944,    0x25133,    /* 𥄳 𥄳 */
    0x2f945,    0x771e, /* 眞 眞 */
    0x2f946,    0x771f, /* 真 真 */
    0x2f947,    0x771f, /* 真 真 */
    0x2f948,    0x774a, /* 睊 睊 */
    0x2f949,    0x4039, /* 䀹 䀹 */
    0x2f94a,    0x778b, /* 瞋 瞋 */
    0x2f94b,    0x4046, /* 䁆 䁆 */
    0x2f94c,    0x4096, /* 䂖 䂖 */
    0x2f94d,    0x2541d,    /* 𥐝 𥐝 */
    0x2f94e,    0x784e, /* 硎 硎 */
    0x2f94f,    0x788c, /* 碌 碌 */
    0x2f950,    0x78cc, /* 磌 磌 */
    0x2f951,    0x40e3, /* 䃣 䃣 */
    0x2f952,    0x25626,    /* 𥘦 𥘦 */
    0x2f953,    0x7956, /* 祖 祖 */
    0x2f954,    0x2569a,    /* 𥚚 𥚚 */
    0x2f955,    0x256c5,    /* 𥛅 𥛅 */
    0x2f956,    0x798f, /* 福 福 */
    0x2f957,    0x79eb, /* 秫 秫 */
    0x2f958,    0x412f, /* 䄯 䄯 */
    0x2f959,    0x7a40, /* 穀 穀 */
    0x2f95a,    0x7a4a, /* 穊 穊 */
    0x2f95b,    0x7a4f, /* 穏 穏 */
    0x2f95c,    0x2597c,    /* 𥥼 𥥼 */
    0x2f95d,    0x25aa7,    /* 𥪧 𥪧 */
    0x2f95e,    0x25aa7,    /* 𥪧 𥪧 */
    0x2f95f,    0x7aee, /* 竮 竮 */
    0x2f960,    0x4202, /* 䈂 䈂 */
    0x2f961,    0x25bab,    /* 𥮫 𥮫 */
    0x2f962,    0x7bc6, /* 篆 篆 */
    0x2f963,    0x7bc9, /* 築 築 */
    0x2f964,    0x4227, /* 䈧 䈧 */
    0x2f965,    0x25c80,    /* 𥲀 𥲀 */
    0x2f966,    0x7cd2, /* 糒 糒 */
    0x2f967,    0x42a0, /* 䊠 䊠 */
    0x2f968,    0x7ce8, /* 糨 糨 */
    0x2f969,    0x7ce3, /* 糣 糣 */
    0x2f96a,    0x7d00, /* 紀 紀 */
    0x2f96b,    0x25f86,    /* 𥾆 𥾆 */
    0x2f96c,    0x7d63, /* 絣 絣 */
    0x2f96d,    0x4301, /* 䌁 䌁 */
    0x2f96e,    0x7dc7, /* 緇 緇 */
    0x2f96f,    0x7e02, /* 縂 縂 */
    0x2f970,    0x7e45, /* 繅 繅 */
    0x2f971,    0x4334, /* 䌴 䌴 */
    0x2f972,    0x26228,    /* 𦈨 𦈨 */
    0x2f973,    0x26247,    /* 𦉇 𦉇 */
    0x2f974,    0x4359, /* 䍙 䍙 */
    0x2f975,    0x262d9,    /* 𦋙 𦋙 */
    0x2f976,    0x7f7a, /* 罺 罺 */
    0x2f977,    0x2633e,    /* 𦌾 𦌾 */
    0x2f978,    0x7f95, /* 羕 羕 */
    0x2f979,    0x7ffa, /* 翺 翺 */
    0x2f97a,    0x8005, /* 者 者 */
    0x2f97b,    0x264da,    /* 𦓚 𦓚 */
    0x2f97c,    0x26523,    /* 𦔣 𦔣 */
    0x2f97d,    0x8060, /* 聠 聠 */
    0x2f97e,    0x265a8,    /* 𦖨 𦖨 */
    0x2f97f,    0x8070, /* 聰 聰 */
    0x2f980,    0x2335f,    /* 𣍟 𣍟 */
    0x2f981,    0x43d5, /* 䏕 䏕 */
    0x2f982,    0x80b2, /* 育 育 */
    0x2f983,    0x8103, /* 脃 脃 */
    0x2f984,    0x440b, /* 䐋 䐋 */
    0x2f985,    0x813e, /* 脾 脾 */
    0x2f986,    0x5ab5, /* 媵 媵 */
    0x2f987,    0x267a7,    /* 𦞧 𦞧 */
    0x2f988,    0x267b5,    /* 𦞵 𦞵 */
    0x2f989,    0x23393,    /* 𣎓 𣎓 */
    0x2f98a,    0x2339c,    /* 𣎜 𣎜 */
    0x2f98b,    0x8201, /* 舁 舁 */
    0x2f98c,    0x8204, /* 舄 舄 */
    0x2f98d,    0x8f9e, /* 辞 辞 */
    0x2f98e,    0x446b, /* 䑫 䑫 */
    0x2f98f,    0x8291, /* 芑 芑 */
    0x2f990,    0x828b, /* 芋 芋 */
    0x2f991,    0x829d, /* 芝 芝 */
    0x2f992,    0x52b3, /* 劳 劳 */
    0x2f993,    0x82b1, /* 花 花 */
    0x2f994,    0x82b3, /* 芳 芳 */
    0x2f995,    0x82bd, /* 芽 芽 */
    0x2f996,    0x82e6, /* 苦 苦 */
    0x2f997,    0x26b3c,    /* 𦬼 𦬼 */
    0x2f998,    0x82e5, /* 若 若 */
    0x2f999,    0x831d, /* 茝 茝 */
    0x2f99a,    0x8363, /* 荣 荣 */
    0x2f99b,    0x83ad, /* 莭 莭 */
    0x2f99c,    0x8323, /* 茣 茣 */
    0x2f99d,    0x83bd, /* 莽 莽 */
    0x2f99e,    0x83e7, /* 菧 菧 */
    0x2f99f,    0x8457, /* 著 著 */
    0x2f9a0,    0x8353, /* 荓 荓 */
    0x2f9a1,    0x83ca, /* 菊 菊 */
    0x2f9a2,    0x83cc, /* 菌 菌 */
    0x2f9a3,    0x83dc, /* 菜 菜 */
    0x2f9a4,    0x26c36,    /* 𦰶 𦰶 */
    0x2f9a5,    0x26d6b,    /* 𦵫 𦵫 */
    0x2f9a6,    0x26cd5,    /* 𦳕 𦳕 */
    0x2f9a7,    0x452b, /* 䔫 䔫 */
    0x2f9a8,    0x84f1, /* 蓱 蓱 */
    0x2f9a9,    0x84f3, /* 蓳 蓳 */
    0x2f9aa,    0x8516, /* 蔖 蔖 */
    0x2f9ab,    0x273ca,    /* 𧏊 𧏊 */
    0x2f9ac,    0x8564, /* 蕤 蕤 */
    0x2f9ad,    0x26f2c,    /* 𦼬 𦼬 */
    0x2f9ae,    0x455d, /* 䕝 䕝 */
    0x2f9af,    0x4561, /* 䕡 䕡 */
    0x2f9b0,    0x26fb1,    /* 𦾱 𦾱 */
    0x2f9b1,    0x270d2,    /* 𧃒 𧃒 */
    0x2f9b2,    0x456b, /* 䕫 䕫 */
    0x2f9b3,    0x8650, /* 虐 虐 */
    0x2f9b4,    0x865c, /* 虜 虜 */
    0x2f9b5,    0x8667, /* 虧 虧 */
    0x2f9b6,    0x8669, /* 虩 虩 */
    0x2f9b7,    0x86a9, /* 蚩 蚩 */
    0x2f9b8,    0x8688, /* 蚈 蚈 */
    0x2f9b9,    0x870e, /* 蜎 蜎 */
    0x2f9ba,    0x86e2, /* 蛢 蛢 */
    0x2f9bb,    0x8779, /* 蝹 蝹 */
    0x2f9bc,    0x8728, /* 蜨 蜨 */
    0x2f9bd,    0x876b, /* 蝫 蝫 */
    0x2f9be,    0x8786, /* 螆 螆 */
    0x2f9bf,    0x45d7, /* 䗗 䗗 */
    0x2f9c0,    0x87e1, /* 蟡 蟡 */
    0x2f9c1,    0x8801, /* 蠁 蠁 */
    0x2f9c2,    0x45f9, /* 䗹 䗹 */
    0x2f9c3,    0x8860, /* 衠 衠 */
    0x2f9c4,    0x8863, /* 衣 衣 */
    0x2f9c5,    0x27667,    /* 𧙧 𧙧 */
    0x2f9c6,    0x88d7, /* 裗 裗 */
    0x2f9c7,    0x88de, /* 裞 裞 */
    0x2f9c8,    0x4635, /* 䘵 䘵 */
    0x2f9c9,    0x88fa, /* 裺 裺 */
    0x2f9ca,    0x34bb, /* 㒻 㒻 */
    0x2f9cb,    0x278ae,    /* 𧢮 𧢮 */
    0x2f9cc,    0x27966,    /* 𧥦 𧥦 */
    0x2f9cd,    0x46be, /* 䚾 䚾 */
    0x2f9ce,    0x46c7, /* 䛇 䛇 */
    0x2f9cf,    0x8aa0, /* 誠 誠 */
    0x2f9d0,    0x8aed, /* 諭 諭 */
    0x2f9d1,    0x8b8a, /* 變 變 */
    0x2f9d2,    0x8c55, /* 豕 豕 */
    0x2f9d3,    0x27ca8,    /* 𧲨 𧲨 */
    0x2f9d4,    0x8cab, /* 貫 貫 */
    0x2f9d5,    0x8cc1, /* 賁 賁 */
    0x2f9d6,    0x8d1b, /* 贛 贛 */
    0x2f9d7,    0x8d77, /* 起 起 */
    0x2f9d8,    0x27f2f,    /* 𧼯 𧼯 */
    0x2f9d9,    0x20804,    /* 𠠄 𠠄 */
    0x2f9da,    0x8dcb, /* 跋 跋 */
    0x2f9db,    0x8dbc, /* 趼 趼 */
    0x2f9dc,    0x8df0, /* 跰 跰 */
    0x2f9dd,    0x208de,    /* 𠣞 𠣞 */
    0x2f9de,    0x8ed4, /* 軔 軔 */
    0x2f9df,    0x8f38, /* 輸 輸 */
    0x2f9e0,    0x285d2,    /* 𨗒 𨗒 */
    0x2f9e1,    0x285ed,    /* 𨗭 𨗭 */
    0x2f9e2,    0x9094, /* 邔 邔 */
    0x2f9e3,    0x90f1, /* 郱 郱 */
    0x2f9e4,    0x9111, /* 鄑 鄑 */
    0x2f9e5,    0x2872e,    /* 𨜮 𨜮 */
    0x2f9e6,    0x911b, /* 鄛 鄛 */
    0x2f9e7,    0x9238, /* 鈸 鈸 */
    0x2f9e8,    0x92d7, /* 鋗 鋗 */
    0x2f9e9,    0x92d8, /* 鋘 鋘 */
    0x2f9ea,    0x927c, /* 鉼 鉼 */
    0x2f9eb,    0x93f9, /* 鏹 鏹 */
    0x2f9ec,    0x9415, /* 鐕 鐕 */
    0x2f9ed,    0x28bfa,    /* 𨯺 𨯺 */
    0x2f9ee,    0x958b, /* 開 開 */
    0x2f9ef,    0x4995, /* 䦕 䦕 */
    0x2f9f0,    0x95b7, /* 閷 閷 */
    0x2f9f1,    0x28d77,    /* 𨵷 𨵷 */
    0x2f9f2,    0x49e6, /* 䧦 䧦 */
    0x2f9f3,    0x96c3, /* 雃 雃 */
    0x2f9f4,    0x5db2, /* 嶲 嶲 */
    0x2f9f5,    0x9723, /* 霣 霣 */
    0x2f9f6,    0x29145,    /* 𩅅 𩅅 */
    0x2f9f7,    0x2921a,    /* 𩈚 𩈚 */
    0x2f9f8,    0x4a6e, /* 䩮 䩮 */
    0x2f9f9,    0x4a76, /* 䩶 䩶 */
    0x2f9fa,    0x97e0, /* 韠 韠 */
    0x2f9fb,    0x2940a,    /* 𩐊 𩐊 */
    0x2f9fc,    0x4ab2, /* 䪲 䪲 */
    0x2f9fd,    0x29496,    /* 𩒖 𩒖 */
    0x2f9fe,    0x980b, /* 頋 頋 */
    0x2f9ff,    0x980b, /* 頋 頋 */
    0x2fa00,    0x9829, /* 頩 頩 */
    0x2fa01,    0x295b6,    /* 𩖶 𩖶 */
    0x2fa02,    0x98e2, /* 飢 飢 */
    0x2fa03,    0x4b33, /* 䬳 䬳 */
    0x2fa04,    0x9929, /* 餩 餩 */
    0x2fa05,    0x99a7, /* 馧 馧 */
    0x2fa06,    0x99c2, /* 駂 駂 */
    0x2fa07,    0x99fe, /* 駾 駾 */
    0x2fa08,    0x4bce, /* 䯎 䯎 */
    0x2fa09,    0x29b30,    /* 𩬰 𩬰 */
    0x2fa0a,    0x9b12, /* 鬒 鬒 */
    0x2fa0b,    0x9c40, /* 鱀 鱀 */
    0x2fa0c,    0x9cfd, /* 鳽 鳽 */
    0x2fa0d,    0x4cce, /* 䳎 䳎 */
    0x2fa0e,    0x4ced, /* 䳭 䳭 */
    0x2fa0f,    0x9d67, /* 鵧 鵧 */
    0x2fa10,    0x2a0ce,    /* 𪃎 𪃎 */
    0x2fa11,    0x4cf8, /* 䳸 䳸 */
    0x2fa12,    0x2a105,    /* 𪄅 𪄅 */
    0x2fa13,    0x2a20e,    /* 𪈎 𪈎 */
    0x2fa14,    0x2a291,    /* 𪊑 𪊑 */
    0x2fa15,    0x9ebb, /* 麻 麻 */
    0x2fa16,    0x4d56, /* 䵖 䵖 */
    0x2fa17,    0x9ef9, /* 黹 黹 */
    0x2fa18,    0x9efe, /* 黾 黾 */
    0x2fa19,    0x9f05, /* 鼅 鼅 */
    0x2fa1a,    0x9f0f, /* 鼏 鼏 */
    0x2fa1b,    0x9f16, /* 鼖 鼖 */
    0x2fa1c,    0x9f3b, /* 鼻 鼻 */
};
@

<<function tobaserune>>=
Rune
tobaserune(Rune c)
{
    Rune *p;

    p = _runebsearch(c, _base2, nelem(_base2)/2, 2);
    if(p && c == p[0])
        c = p[1];
    return c;
}
@

<<function isbaserune>>=
int
isbaserune(Rune c)
{
    return tobaserune(c) == c;
}
@


%-------------------------------------------------------------

<<port/runebase.c>>=
#include <u.h>
#include <libc.h>

Rune*_runebsearch(Rune c, Rune *t, int n, int ne);

<<global _base2>>

<<function tobaserune>>

<<function isbaserune>>
@


\subsection*{[[port/runebsearch.c]]}

<<function _runebsearch>>=
Rune*
_runebsearch(Rune c, Rune *t, int n, int ne)
{
    Rune *p;
    int m;

    while(n > 1) {
        m = n/2;
        p = t + m*ne;
        if(c >= p[0]) {
            t = p;
            n = n-m;
        } else
            n = m;
    }
    if(n && c >= t[0])
        return t;
    return 0;
}
@


%-------------------------------------------------------------

<<port/runebsearch.c>>=
#include <u.h>
#include <libc.h>

<<function _runebsearch>>
@


\subsection*{[[port/runestrcat.c]]}

<<function runestrcat>>=
Rune*
runestrcat(Rune *s1, Rune *s2)
{

    runestrcpy(runestrchr(s1, 0), s2);
    return s1;
}
@


%-------------------------------------------------------------

<<port/runestrcat.c>>=
#include <u.h>
#include <libc.h>

<<function runestrcat>>
@


\subsection*{[[port/runestrchr.c]]}

<<function runestrchr>>=
Rune*
runestrchr(Rune *s, Rune c)
{
    Rune c0 = c;
    Rune c1;

    if(c == 0) {
        while(*s++)
            ;
        return s-1;
    }

    while(c1 = *s++)
        if(c1 == c0)
            return s-1;
    return 0;
}
@


%-------------------------------------------------------------

<<port/runestrchr.c>>=
#include <u.h>
#include <libc.h>

<<function runestrchr>>
@


\subsection*{[[port/runestrcmp.c]]}

<<function runestrcmp>>=
int
runestrcmp(Rune *s1, Rune *s2)
{
    Rune c1, c2;

    for(;;) {
        c1 = *s1++;
        c2 = *s2++;
        if(c1 != c2) {
            if(c1 > c2)
                return 1;
            return -1;
        }
        if(c1 == 0)
            return 0;
    }
}
@


%-------------------------------------------------------------

<<port/runestrcmp.c>>=
#include <u.h>
#include <libc.h>

<<function runestrcmp>>
@


\subsection*{[[port/runestrcpy.c]]}

<<function runestrcpy>>=
Rune*
runestrcpy(Rune *s1, Rune *s2)
{
    Rune *os1;

    os1 = s1;
    while(*s1++ = *s2++)
        ;
    return os1;
}
@


%-------------------------------------------------------------

<<port/runestrcpy.c>>=
#include <u.h>
#include <libc.h>

<<function runestrcpy>>
@


\subsection*{[[port/runestrdup.c]]}

<<function runestrdup>>=
Rune*
runestrdup(Rune *s) 
{  
    Rune *ns;

    ns = malloc(sizeof(Rune)*(runestrlen(s) + 1));
    if(ns == 0)
        return 0;
    setmalloctag(ns, getcallerpc(&s));

    return runestrcpy(ns, s);
}
@


%-------------------------------------------------------------

<<port/runestrdup.c>>=
#include <u.h>
#include <libc.h>

<<function runestrdup>>
@


\subsection*{[[port/runestrecpy.c]]}

<<function runestrecpy>>=
Rune*
runestrecpy(Rune *s1, Rune *es1, Rune *s2)
{
    if(s1 >= es1)
        return s1;

    while(*s1++ = *s2++){
        if(s1 == es1){
            *--s1 = '\0';
            break;
        }
    }
    return s1;
}
@


%-------------------------------------------------------------

<<port/runestrecpy.c>>=
#include <u.h>
#include <libc.h>

<<function runestrecpy>>
@


\subsection*{[[port/runestrlen.c]]}

<<function runestrlen>>=
long
runestrlen(Rune *s)
{

    return runestrchr(s, 0) - s;
}
@


%-------------------------------------------------------------

<<port/runestrlen.c>>=
#include <u.h>
#include <libc.h>

<<function runestrlen>>
@


\subsection*{[[port/runestrncat.c]]}

<<function runestrncat>>=
Rune*
runestrncat(Rune *s1, Rune *s2, long n)
{
    Rune *os1;

    os1 = s1;
    s1 = runestrchr(s1, 0);
    while(*s1++ = *s2++)
        if(--n < 0) {
            s1[-1] = 0;
            break;
        }
    return os1;
}
@


%-------------------------------------------------------------

<<port/runestrncat.c>>=
#include <u.h>
#include <libc.h>

<<function runestrncat>>
@


\subsection*{[[port/runestrncmp.c]]}

<<function runestrncmp>>=
int
runestrncmp(Rune *s1, Rune *s2, long n)
{
    Rune c1, c2;

    while(n > 0) {
        c1 = *s1++;
        c2 = *s2++;
        n--;
        if(c1 != c2) {
            if(c1 > c2)
                return 1;
            return -1;
        }
        if(c1 == 0)
            break;
    }
    return 0;
}
@


%-------------------------------------------------------------

<<port/runestrncmp.c>>=
#include <u.h>
#include <libc.h>

<<function runestrncmp>>
@


\subsection*{[[port/runestrncpy.c]]}

<<function runestrncpy>>=
Rune*
runestrncpy(Rune *s1, Rune *s2, long n)
{
    int i;
    Rune *os1;

    os1 = s1;
    for(i = 0; i < n; i++)
        if((*s1++ = *s2++) == 0) {
            while(++i < n)
                *s1++ = 0;
            return os1;
        }
    return os1;
}
@


%-------------------------------------------------------------

<<port/runestrncpy.c>>=
#include <u.h>
#include <libc.h>

<<function runestrncpy>>
@


\subsection*{[[port/runestrrchr.c]]}

<<function runestrrchr>>=
Rune*
runestrrchr(Rune *s, Rune c)
{
    Rune *r;

    if(c == 0)
        return runestrchr(s, 0);
    r = 0;
    while(s = runestrchr(s, c))
        r = s++;
    return r;
}
@


%-------------------------------------------------------------

<<port/runestrrchr.c>>=
#include <u.h>
#include <libc.h>

<<function runestrrchr>>
@


\subsection*{[[port/runestrstr.c]]}

<<function runestrstr>>=
/*
 * Return pointer to first occurrence of s2 in s1,
 * 0 if none
 */
Rune*
runestrstr(Rune *s1, Rune *s2)
{
    Rune *p, *pa, *pb;
    int c0, c;

    c0 = *s2;
    if(c0 == 0)
        return s1;
    s2++;
    for(p=runestrchr(s1, c0); p; p=runestrchr(p+1, c0)) {
        pa = p;
        for(pb=s2;; pb++) {
            c = *pb;
            if(c == 0)
                return p;
            if(c != *++pa)
                break;
        }
    }
    return 0;
}
@


%-------------------------------------------------------------

<<port/runestrstr.c>>=
#include <u.h>
#include <libc.h>

<<function runestrstr>>
@


\subsection*{[[port/runetype.c]]}


%-------------------------------------------------------------

<<port/runetype.c>>=
#include    <u.h>
#include    <libc.h>

Rune*_runebsearch(Rune c, Rune *t, int n, int ne);

#include "runetypebody-6.2.0.h"
@


\subsection*{[[port/sin.c]]}

<<constant p0 (port/sin.c)>>=
#define p0      .1357884097877375669092680e8
@

<<constant p1 (port/sin.c)>>=
#define p1     -.4942908100902844161158627e7
@

<<constant p2 (port/sin.c)>>=
#define p2      .4401030535375266501944918e6
@

<<constant p3 (port/sin.c)>>=
#define p3     -.1384727249982452873054457e5
@

<<constant p4 (port/sin.c)>>=
#define p4      .1459688406665768722226959e3
@

<<constant q0 (port/sin.c)>>=
#define q0      .8644558652922534429915149e7
@

<<constant q1 (port/sin.c)>>=
#define q1      .4081792252343299749395779e6
@

<<constant q2 (port/sin.c)>>=
#define q2      .9463096101538208180571257e4
@

<<constant q3 (port/sin.c)>>=
#define q3      .1326534908786136358911494e3
@

<<function sinus>>=
static
double
sinus(double arg, int quad)
{
    double e, f, ysq, x, y, temp1, temp2;
    int k;

    x = arg;
    if(x < 0) {
        x = -x;
        quad += 2;
    }
    x *= 1/PIO2;    /* underflow? */
    if(x > 32764) {
        y = modf(x, &e);
        e += quad;
        modf(0.25*e, &f);
        quad = e - 4*f;
    } else {
        k = x;
        y = x - k;
        quad += k;
        quad &= 3;
    }
    if(quad & 1)
        y = 1-y;
    if(quad > 1)
        y = -y;

    ysq = y*y;
    temp1 = ((((p4*ysq+p3)*ysq+p2)*ysq+p1)*ysq+p0)*y;
    temp2 = ((((ysq+q3)*ysq+q2)*ysq+q1)*ysq+q0);
    return temp1/temp2;
}
@

<<function cos>>=
double
cos(double arg)
{
    if(arg < 0)
        arg = -arg;
    return sinus(arg, 1);
}
@

<<function sin>>=
double
sin(double arg)
{
    return sinus(arg, 0);
}
@


%-------------------------------------------------------------

<<port/sin.c>>=
/*
    C program for floating point sin/cos.
    Calls modf.
    There are no error exits.
    Coefficients are #3370 from Hart & Cheney (18.80D).
*/

#include <u.h>
#include <libc.h>

<<constant p0 (port/sin.c)>>
<<constant p1 (port/sin.c)>>
<<constant p2 (port/sin.c)>>
<<constant p3 (port/sin.c)>>
<<constant p4 (port/sin.c)>>
<<constant q0 (port/sin.c)>>
<<constant q1 (port/sin.c)>>
<<constant q2 (port/sin.c)>>
<<constant q3 (port/sin.c)>>

<<function sinus>>

<<function cos>>

<<function sin>>
@


\subsection*{[[port/sinh.c]]}

<<global p0>>=
/*
 * sinh(arg) returns the hyperbolic sine of its floating-
 * point argument.
 *
 * The exponential function is called for arguments
 * greater in magnitude than 0.5.
 *
 * A series is used for arguments smaller in magnitude than 0.5.
 * The coefficients are #2029 from Hart & Cheney. (20.36D)
 *
 * cosh(arg) is computed from the exponential function for
 * all arguments.
 */

static  double  p0  = -0.6307673640497716991184787251e+6;
@

<<global p1>>=
static  double  p1  = -0.8991272022039509355398013511e+5;
@

<<global p2>>=
static  double  p2  = -0.2894211355989563807284660366e+4;
@

<<global p3>>=
static  double  p3  = -0.2630563213397497062819489e+2;
@

<<global q0>>=
static  double  q0  = -0.6307673640497716991212077277e+6;
@

<<global q1>>=
static  double  q1   = 0.1521517378790019070696485176e+5;
@

<<global q2>>=
static  double  q2  = -0.173678953558233699533450911e+3;
@

<<function sinh>>=
double
sinh(double arg)
{
    double temp, argsq;
    int sign;

    sign = 0;
    if(arg < 0) {
        arg = -arg;
        sign++;
    }
    if(arg > 21) {
        temp = exp(arg)/2;
        goto out;
    }
    if(arg > 0.5) {
        temp = (exp(arg) - exp(-arg))/2;
        goto out;
    }
    argsq = arg*arg;
    temp = (((p3*argsq+p2)*argsq+p1)*argsq+p0)*arg;
    temp /= (((argsq+q2)*argsq+q1)*argsq+q0);
out:
    if(sign)
        temp = -temp;
    return temp;
}
@

<<function cosh>>=
double
cosh(double arg)
{
    if(arg < 0)
        arg = - arg;
    if(arg > 21)
        return exp(arg)/2;
    return (exp(arg) + exp(-arg))/2;
}
@


%-------------------------------------------------------------

<<port/sinh.c>>=
#include <u.h>
#include <libc.h>

<<global p0>>
<<global p1>>
<<global p2>>
<<global p3>>
<<global q0>>
<<global q1>>
<<global q2>>

<<function sinh>>

<<function cosh>>
@


\subsection*{[[port/sqrt.c]]}

<<function sqrt>>=
double
sqrt(double arg)
{
    double x, temp;
    int exp, i;

    if(arg <= 0) {
        if(arg < 0)
            return NaN();
        return 0;
    }
    if(isInf(arg, 1))
        return arg;
    x = frexp(arg, &exp);
    while(x < 0.5) {
        x *= 2;
        exp--;
    }
    /*
     * NOTE
     * this wont work on 1's comp
     */
    if(exp & 1) {
        x *= 2;
        exp--;
    }
    temp = 0.5 * (1.0+x);

    while(exp > 60) {
        temp *= (1L<<30);
        exp -= 60;
    }
    while(exp < -60) {
        temp /= (1L<<30);
        exp += 60;
    }
    if(exp >= 0)
        temp *= 1L << (exp/2);
    else
        temp /= 1L << (-exp/2);
    for(i=0; i<=4; i++)
        temp = 0.5*(temp + arg/temp);
    return temp;
}
@


%-------------------------------------------------------------

<<port/sqrt.c>>=
/*
    sqrt returns the square root of its floating
    point argument. Newton's method.

    calls frexp
*/

#include <u.h>
#include <libc.h>

<<function sqrt>>
@


\subsection*{[[port/strcat.c]]}

<<function strcat>>=
char*
strcat(char *s1, char *s2)
{

    strcpy(strchr(s1, 0), s2);
    return s1;
}
@


%-------------------------------------------------------------

<<port/strcat.c>>=
#include <u.h>
#include <libc.h>

<<function strcat>>
@


\subsection*{[[port/strchr.c]]}

<<function strchr>>=
char*
strchr(char *s, int c)
{
    char c0 = c;
    char c1;

    if(c == 0) {
        while(*s++)
            ;
        return s-1;
    }

    while(c1 = *s++)
        if(c1 == c0)
            return s-1;
    return 0;
}
@


%-------------------------------------------------------------

<<port/strchr.c>>=
#include <u.h>
#include <libc.h>

<<function strchr>>
@


\subsection*{[[port/strcmp.c]]}

<<function strcmp>>=
int
strcmp(char *s1, char *s2)
{
    unsigned c1, c2;

    for(;;) {
        c1 = *s1++;
        c2 = *s2++;
        if(c1 != c2) {
            if(c1 > c2)
                return 1;
            return -1;
        }
        if(c1 == 0)
            return 0;
    }
}
@


%-------------------------------------------------------------

<<port/strcmp.c>>=
#include <u.h>
#include <libc.h>

<<function strcmp>>
@


\subsection*{[[port/strcpy.c]]}

<<constant N>>=
#define N   10000
@

<<function strcpy>>=
char*
strcpy(char *s1, char *s2)
{
    char *os1;

    os1 = s1;
    while(!memccpy(s1, s2, 0, N)) {
        s1 += N;
        s2 += N;
    }
    return os1;
}
@


%-------------------------------------------------------------

<<port/strcpy.c>>=
#include <u.h>
#include <libc.h>
<<constant N>>

<<function strcpy>>
@


\subsection*{[[port/strcspn.c]]}

<<constant N (port/strcspn.c)>>=
#define N   256
@

<<function strcspn>>=
long
strcspn(char *s, char *b)
{
    char map[N], *os;

    memset(map, 0, N);
    for(;;) {
        map[*(uchar*)b] = 1;
        if(*b++ == 0)
            break;
    }
    os = s;
    while(map[*(uchar*)s++] == 0)
        ;
    return s - os - 1;
}
@


%-------------------------------------------------------------

<<port/strcspn.c>>=
#include <u.h>
#include <libc.h>

<<constant N (port/strcspn.c)>>

<<function strcspn>>
@


\subsection*{[[port/strdup.c]]}

<<function strdup>>=
char*
strdup(char *s) 
{  
    char *ns;

    ns = malloc(strlen(s) + 1);
    if(ns == 0)
        return 0;
    setmalloctag(ns, getcallerpc(&s));

    return strcpy(ns, s);
}
@


%-------------------------------------------------------------

<<port/strdup.c>>=
#include <u.h>
#include <libc.h>

<<function strdup>>
@


\subsection*{[[port/strecpy.c]]}

<<function strecpy>>=
char*
strecpy(char *to, char *e, char *from)
{
    if(to >= e)
        return to;
    to = memccpy(to, from, '\0', e - to);
    if(to == nil){
        to = e - 1;
        *to = '\0';
    }else{
        to--;
    }
    return to;
}
@


%-------------------------------------------------------------

<<port/strecpy.c>>=
#include <u.h>
#include <libc.h>

<<function strecpy>>
@


\subsection*{[[port/strlen.c]]}

<<function strlen>>=
long
strlen(char *s)
{

    return strchr(s, 0) - s;
}
@


%-------------------------------------------------------------

<<port/strlen.c>>=
#include <u.h>
#include <libc.h>

<<function strlen>>
@


\subsection*{[[port/strncat.c]]}

<<function strncat>>=
char*
strncat(char *s1, char *s2, long n)
{
    char *os1;

    os1 = s1;
    while(*s1++)
        ;
    s1--;
    while(*s1++ = *s2++)
        if(--n < 0) {
            s1[-1] = 0;
            break;
        }
    return os1;
}
@


%-------------------------------------------------------------

<<port/strncat.c>>=
#include <u.h>
#include <libc.h>

<<function strncat>>
@


\subsection*{[[port/strncmp.c]]}

<<function strncmp>>=
int
strncmp(char *s1, char *s2, long n)
{
    unsigned c1, c2;

    while(n > 0) {
        c1 = *s1++;
        c2 = *s2++;
        n--;
        if(c1 != c2) {
            if(c1 > c2)
                return 1;
            return -1;
        }
        if(c1 == 0)
            break;
    }
    return 0;
}
@


%-------------------------------------------------------------

<<port/strncmp.c>>=
#include <u.h>
#include <libc.h>

<<function strncmp>>
@


\subsection*{[[port/strncpy.c]]}

<<function strncpy>>=
char*
strncpy(char *s1, char *s2, long n)
{
    int i;
    char *os1;

    os1 = s1;
    for(i = 0; i < n; i++)
        if((*s1++ = *s2++) == 0) {
            while(++i < n)
                *s1++ = 0;
            return os1;
        }
    return os1;
}
@


%-------------------------------------------------------------

<<port/strncpy.c>>=
#include <u.h>
#include <libc.h>

<<function strncpy>>
@


\subsection*{[[port/strpbrk.c]]}

<<constant N (port/strpbrk.c)>>=
#define N   256
@

<<function strpbrk>>=
char*
strpbrk(char *cs, char *cb)
{
    char map[N];
    uchar *s=(uchar*)cs, *b=(uchar*)cb;

    memset(map, 0, N);
    for(;;) {
        map[*b] = 1;
        if(*b++ == 0)
            break;
    }
    while(map[*s++] == 0)
        ;
    if(*--s)
        return (char*)s;
    return 0;
}
@


%-------------------------------------------------------------

<<port/strpbrk.c>>=
#include <u.h>
#include <libc.h>
<<constant N (port/strpbrk.c)>>

<<function strpbrk>>
@


\subsection*{[[port/strrchr.c]]}

<<function strrchr>>=
char*
strrchr(char *s, int c)
{
    char *r;

    if(c == 0)
        return strchr(s, 0);
    r = 0;
    while(s = strchr(s, c))
        r = s++;
    return r;
}
@


%-------------------------------------------------------------

<<port/strrchr.c>>=
#include <u.h>
#include <libc.h>

<<function strrchr>>
@


\subsection*{[[port/strspn.c]]}

<<constant N (port/strspn.c)>>=
#define N   256
@

<<function strspn>>=
long
strspn(char *s, char *b)
{
    char map[N], *os;

    memset(map, 0, N);
    while(*b)
        map[*(uchar *)b++] = 1;
    os = s;
    while(map[*(uchar *)s++])
        ;
    return s - os - 1;
}
@


%-------------------------------------------------------------

<<port/strspn.c>>=
#include <u.h>
#include <libc.h>

<<constant N (port/strspn.c)>>

<<function strspn>>
@


\subsection*{[[port/strstr.c]]}

<<function strstr>>=
/*
 * Return pointer to first occurrence of s2 in s1,
 * 0 if none
 */
char*
strstr(char *s1, char *s2)
{
    char *p, *pa, *pb;
    int c0, c;

    c0 = *s2;
    if(c0 == 0)
        return s1;
    s2++;
    for(p=strchr(s1, c0); p; p=strchr(p+1, c0)) {
        pa = p;
        for(pb=s2;; pb++) {
            c = *pb;
            if(c == 0)
                return p;
            if(c != *++pa)
                break;
        }
    }
    return 0;
}
@


%-------------------------------------------------------------

<<port/strstr.c>>=
#include <u.h>
#include <libc.h>

<<function strstr>>
@


\subsection*{[[port/strtod.c]]}

<<enum _anon_ (port/strtod.c)>>=
/*
 * This routine will convert to arbitrary precision
 * floating point entirely in multi-precision fixed.
 * The answer is the closest floating point number to
 * the given decimal number. Exactly half way are
 * rounded ala ieee rules.
 * Method is to scale input decimal between .500 and .999...
 * with external power of 2, then binary search for the
 * closest mantissa to this decimal number.
 * Nmant is is the required precision. (53 for ieee dp)
 * Nbits is the max number of bits/word. (must be <= 28)
 * Prec is calculated - the number of words of fixed mantissa.
 */
enum
{
    Nbits   = 28,               // bits safely represented in a ulong
    Nmant   = 53,               // bits of precision required
    Bias        = 1022,
    Prec    = (Nmant+Nbits+1)/Nbits,    // words of Nbits each to represent mantissa
    Sigbit  = 1<<(Prec*Nbits-Nmant),    // first significant bit of Prec-th word
    Ndig    = 1500,
    One = (ulong)(1<<Nbits),
    Half    = (ulong)(One>>1),
    Maxe    = 310,
    Fsign   = 1<<0,     // found -
    Fesign  = 1<<1,     // found e-
    Fdpoint = 1<<2,     // found .

    S0  = 0,        // _        _S0 +S1 #S2 .S3
    S1,         // _+       #S2 .S3
    S2,         // _+#      #S2 .S4 eS5
    S3,         // _+.      #S4
    S4,         // _+#.#    #S4 eS5
    S5,         // _+#.#e   +S6 #S7
    S6,         // _+#.#e+  #S7
    S7,         // _+#.#e+# #S7
};
@

<<struct Tab>>=
struct  Tab
{
    int bp;
    int siz;
    char*   cmp;
};
@

<<function strtod>>=
double
strtod(char *as, char **aas)
{
    int na, ona, ex, dp, bp, c, i, flag, state;
    ulong low[Prec], hig[Prec], mid[Prec], num, den;
    double d;
    char *s, a[Ndig];

    flag = 0;   // Fsign, Fesign, Fdpoint
    na = 0;     // number of digits of a[]
    dp = 0;     // na of decimal point
    ex = 0;     // exonent

    state = S0;
    for(s=as;; s++) {
        c = *s;
        if(c >= '0' && c <= '9') {
            switch(state) {
            case S0:
            case S1:
            case S2:
                state = S2;
                break;
            case S3:
            case S4:
                state = S4;
                break;

            case S5:
            case S6:
            case S7:
                state = S7;
                ex = ex*10 + (c-'0');
                continue;
            }
            if(na == 0 && c == '0') {
                dp--;
                continue;
            }
            if(na < Ndig-50)
                a[na++] = c;
            continue;
        }
        switch(c) {
        case '\t':
        case '\n':
        case '\v':
        case '\f':
        case '\r':
        case ' ':
            if(state == S0)
                continue;
            break;
        case '-':
            if(state == S0)
                flag |= Fsign;
            else
                flag |= Fesign;
        case '+':
            if(state == S0)
                state = S1;
            else
            if(state == S5)
                state = S6;
            else
                break;  // syntax
            continue;
        case '.':
            flag |= Fdpoint;
            dp = na;
            if(state == S0 || state == S1) {
                state = S3;
                continue;
            }
            if(state == S2) {
                state = S4;
                continue;
            }
            break;
        case 'e':
        case 'E':
            if(state == S2 || state == S4) {
                state = S5;
                continue;
            }
            break;
        }
        break;
    }

    /*
     * clean up return char-pointer
     */
    switch(state) {
    case S0:
        if(xcmp(s, "nan") == 0) {
            if(aas != nil)
                *aas = s+3;
            goto retnan;
        }
    case S1:
        if(xcmp(s, "infinity") == 0) {
            if(aas != nil)
                *aas = s+8;
            goto retinf;
        }
        if(xcmp(s, "inf") == 0) {
            if(aas != nil)
                *aas = s+3;
            goto retinf;
        }
    case S3:
        if(aas != nil)
            *aas = as;
        goto ret0;  // no digits found
    case S6:
        s--;        // back over +-
    case S5:
        s--;        // back over e
        break;
    }
    if(aas != nil)
        *aas = s;

    if(flag & Fdpoint)
    while(na > 0 && a[na-1] == '0')
        na--;
    if(na == 0)
        goto ret0;  // zero
    a[na] = 0;
    if(!(flag & Fdpoint))
        dp = na;
    if(flag & Fesign)
        ex = -ex;
    dp += ex;
    if(dp < -Maxe-Nmant/3)  /* actually -Nmant*log(2)/log(10), but Nmant/3 close enough */
        goto ret0;  // underflow by exp
    else
    if(dp > +Maxe)
        goto retinf;    // overflow by exp

    /*
     * normalize the decimal ascii number
     * to range .[5-9][0-9]* e0
     */
    bp = 0;     // binary exponent
    while(dp > 0)
        divascii(a, &na, &dp, &bp);
    while(dp < 0 || a[0] < '5')
        mulascii(a, &na, &dp, &bp);
    a[na] = 0;

    /*
     * very small numbers are represented using
     * bp = -Bias+1.  adjust accordingly.
     */
    if(bp < -Bias+1){
        ona = na;
        divby(a, &na, -bp-Bias+1);
        if(na < ona){
            memmove(a+ona-na, a, na);
            memset(a, '0', ona-na);
            na = ona;
        }
        a[na] = 0;
        bp = -Bias+1;
    }

    /* close approx by naive conversion */
    num = 0;
    den = 1;
    for(i=0; i<9 && (c=a[i]); i++) {
        num = num*10 + (c-'0');
        den *= 10;
    }
    low[0] = umuldiv(num, One, den);
    hig[0] = umuldiv(num+1, One, den);
    for(i=1; i<Prec; i++) {
        low[i] = 0;
        hig[i] = One-1;
    }

    /* binary search for closest mantissa */
    for(;;) {
        /* mid = (hig + low) / 2 */
        c = 0;
        for(i=0; i<Prec; i++) {
            mid[i] = hig[i] + low[i];
            if(c)
                mid[i] += One;
            c = mid[i] & 1;
            mid[i] >>= 1;
        }
        frnorm(mid);

        /* compare */
        c = fpcmp(a, mid);
        if(c > 0) {
            c = 1;
            for(i=0; i<Prec; i++)
                if(low[i] != mid[i]) {
                    c = 0;
                    low[i] = mid[i];
                }
            if(c)
                break;  // between mid and hig
            continue;
        }
        if(c < 0) {
            for(i=0; i<Prec; i++)
                hig[i] = mid[i];
            continue;
        }

        /* only hard part is if even/odd roundings wants to go up */
        c = mid[Prec-1] & (Sigbit-1);
        if(c == Sigbit/2 && (mid[Prec-1]&Sigbit) == 0)
            mid[Prec-1] -= c;
        break;  // exactly mid
    }

    /* normal rounding applies */
    c = mid[Prec-1] & (Sigbit-1);
    mid[Prec-1] -= c;
    if(c >= Sigbit/2) {
        mid[Prec-1] += Sigbit;
        frnorm(mid);
    }
    d = 0;
    for(i=0; i<Prec; i++)
        d = d*One + mid[i];
    if(flag & Fsign)
        d = -d;
    d = ldexp(d, bp - Prec*Nbits);
    return d;

ret0:
    return 0;

retnan:
    return NaN();

retinf:
    if(flag & Fsign)
        return Inf(-1);
    return Inf(+1);
}
@

<<function frnorm>>=
static void
frnorm(ulong *f)
{
    int i, c;

    c = 0;
    for(i=Prec-1; i>0; i--) {
        f[i] += c;
        c = f[i] >> Nbits;
        f[i] &= One-1;
    }
    f[0] += c;
}
@

<<function fpcmp>>=
static int
fpcmp(char *a, ulong* f)
{
    ulong tf[Prec];
    int i, d, c;

    for(i=0; i<Prec; i++)
        tf[i] = f[i];

    for(;;) {
        /* tf *= 10 */
        for(i=0; i<Prec; i++)
            tf[i] = tf[i]*10;
        frnorm(tf);
        d = (tf[0] >> Nbits) + '0';
        tf[0] &= One-1;

        /* compare next digit */
        c = *a;
        if(c == 0) {
            if('0' < d)
                return -1;
            if(tf[0] != 0)
                goto cont;
            for(i=1; i<Prec; i++)
                if(tf[i] != 0)
                    goto cont;
            return 0;
        }
        if(c > d)
            return +1;
        if(c < d)
            return -1;
        a++;
    cont:;
    }
}
@

<<function _divby>>=
static void
_divby(char *a, int *na, int b)
{
    int n, c;
    char *p;

    p = a;
    n = 0;
    while(n>>b == 0) {
        c = *a++;
        if(c == 0) {
            while(n) {
                c = n*10;
                if(c>>b)
                    break;
                n = c;
            }
            goto xx;
        }
        n = n*10 + c-'0';
        (*na)--;
    }
    for(;;) {
        c = n>>b;
        n -= c<<b;
        *p++ = c + '0';
        c = *a++;
        if(c == 0)
            break;
        n = n*10 + c-'0';
    }
    (*na)++;
xx:
    while(n) {
        n = n*10;
        c = n>>b;
        n -= c<<b;
        *p++ = c + '0';
        (*na)++;
    }
    *p = 0;
}
@

<<function divby>>=
static void
divby(char *a, int *na, int b)
{
    while(b > 9){
        _divby(a, na, 9);
        a[*na] = 0;
        b -= 9;
    }
    if(b > 0)
        _divby(a, na, b);
}
@

<<global tab1>>=
static  Tab tab1[] =
{
     1,  0, "",
     3,  1, "7",
     6,  2, "63",
     9,  3, "511",
    13,  4, "8191",
    16,  5, "65535",
    19,  6, "524287",
    23,  7, "8388607",
    26,  8, "67108863",
    27,  9, "134217727",
};
@

<<function divascii>>=
static void
divascii(char *a, int *na, int *dp, int *bp)
{
    int b, d;
    Tab *t;

    d = *dp;
    if(d >= nelem(tab1))
        d = nelem(tab1)-1;
    t = tab1 + d;
    b = t->bp;
    if(memcmp(a, t->cmp, t->siz) > 0)
        d--;
    *dp -= d;
    *bp += b;
    divby(a, na, b);
}
@

<<function mulby>>=
static void
mulby(char *a, char *p, char *q, int b)
{
    int n, c;

    n = 0;
    *p = 0;
    for(;;) {
        q--;
        if(q < a)
            break;
        c = *q - '0';
        c = (c<<b) + n;
        n = c/10;
        c -= n*10;
        p--;
        *p = c + '0';
    }
    while(n) {
        c = n;
        n = c/10;
        c -= n*10;
        p--;
        *p = c + '0';
    }
}
@

<<global tab2>>=
static  Tab tab2[] =
{
     1,  1, "",             // dp = 0-0
     3,  3, "125",
     6,  5, "15625",
     9,  7, "1953125",
    13, 10, "1220703125",
    16, 12, "152587890625",
    19, 14, "19073486328125",
    23, 17, "11920928955078125",
    26, 19, "1490116119384765625",
    27, 19, "7450580596923828125",      // dp 8-9
};
@

<<function mulascii>>=
static void
mulascii(char *a, int *na, int *dp, int *bp)
{
    char *p;
    int d, b;
    Tab *t;

    d = -*dp;
    if(d >= nelem(tab2))
        d = nelem(tab2)-1;
    t = tab2 + d;
    b = t->bp;
    if(memcmp(a, t->cmp, t->siz) < 0)
        d--;
    p = a + *na;
    *bp -= b;
    *dp += d;
    *na += d;
    mulby(a, p+d, p, b);
}
@

<<function xcmp>>=
static int
xcmp(char *a, char *b)
{
    int c1, c2;

    while(c1 = *b++) {
        c2 = *a++;
        if(isupper(c2))
            c2 = tolower(c2);
        if(c1 != c2)
            return 1;
    }
    return 0;
}
@


%-------------------------------------------------------------

<<port/strtod.c>>=
#include <u.h>
#include <libc.h>
#include <ctype.h>

<<enum _anon_ (port/strtod.c)>>

static  int xcmp(char*, char*);
static  int fpcmp(char*, ulong*);
static  void    frnorm(ulong*);
static  void    divascii(char*, int*, int*, int*);
static  void    mulascii(char*, int*, int*, int*);
static  void    divby(char*, int*, int);

typedef struct  Tab Tab;
<<struct Tab>>

<<function strtod>>

<<function frnorm>>

<<function fpcmp>>

<<function _divby>>

<<function divby>>

<<global tab1>>

<<function divascii>>

<<function mulby>>

<<global tab2>>

<<function mulascii>>

<<function xcmp>>
@


\subsection*{[[port/strtok.c]]}

<<constant N (port/strtok.c)>>=
#define N   256
@

<<function strtok>>=
char*
strtok(char *s, char *b)
{
    static char *under_rock;
    char map[N], *os;

    memset(map, 0, N);
    while(*b)
        map[*(uchar*)b++] = 1;
    if(s == 0)
        s = under_rock;
    while(map[*(uchar*)s++])
        ;
    if(*--s == 0)
        return 0;
    os = s;
    while(map[*(uchar*)s] == 0)
        if(*s++ == 0) {
            under_rock = s-1;
            return os;
        }
    *s++ = 0;
    under_rock = s;
    return os;
}
@


%-------------------------------------------------------------

<<port/strtok.c>>=
#include <u.h>
#include <libc.h>

<<constant N (port/strtok.c)>>

<<function strtok>>
@


\subsection*{[[port/strtol.c]]}

<<constant LONG_MAX>>=
#define LONG_MAX    2147483647L
@

<<constant LONG_MIN>>=
#define LONG_MIN    -2147483648L
@

<<function strtol>>=
long
strtol(char *nptr, char **endptr, int base)
{
    char *p;
    long n, nn, m;
    int c, ovfl, v, neg, ndig;

    p = nptr;
    neg = 0;
    n = 0;
    ndig = 0;
    ovfl = 0;

    /*
     * White space
     */
    for(;; p++) {
        switch(*p) {
        case ' ':
        case '\t':
        case '\n':
        case '\f':
        case '\r':
        case '\v':
            continue;
        }
        break;
    }

    /*
     * Sign
     */
    if(*p=='-' || *p=='+')
        if(*p++ == '-')
            neg = 1;

    /*
     * Base
     */
    if(base==0) {
        base = 10;
        if(*p == '0') {
            base = 8;
            if(p[1]=='x' || p[1]=='X') {
                p += 2;
                base = 16;
            }
        }
    } else
    if(base==16 && *p=='0'){
        if(p[1]=='x' || p[1]=='X')
            p += 2;
    } else
    if(base<0 || 36<base)
        goto Return;

    /*
     * Non-empty sequence of digits
     */
    m = LONG_MAX/base;
    for(;; p++,ndig++){
        c = *p;
        v = base;
        if('0'<=c && c<='9')
            v = c - '0';
        else
        if('a'<=c && c<='z')
            v = c - 'a' + 10;
        else
        if('A'<=c && c<='Z')
            v = c - 'A' + 10;
        if(v >= base)
            break;
        if(n > m)
            ovfl = 1;
        nn = n*base + v;
        if(nn < n)
            ovfl = 1;
        n = nn;
    }

Return:
    if(ndig == 0)
        p = nptr;
    if(endptr)
        *endptr = p;
    if(ovfl){
        if(neg)
            return LONG_MIN;
        return LONG_MAX;
    }
    if(neg)
        return -n;
    return n;
}
@


%-------------------------------------------------------------

<<port/strtol.c>>=
#include <u.h>
#include <libc.h>

<<constant LONG_MAX>>
<<constant LONG_MIN>>

<<function strtol>>
@


\subsection*{[[port/strtoll.c]]}

<<constant VLONG_MAX>>=
#define VLONG_MAX   ~(1LL<<63)
@

<<constant VLONG_MIN>>=
#define VLONG_MIN   (1LL<<63)
@

<<function strtoll>>=
vlong
strtoll(char *nptr, char **endptr, int base)
{
    char *p;
    vlong n, nn, m;
    int c, ovfl, v, neg, ndig;

    p = nptr;
    neg = 0;
    n = 0;
    ndig = 0;
    ovfl = 0;

    /*
     * White space
     */
    for(;; p++) {
        switch(*p) {
        case ' ':
        case '\t':
        case '\n':
        case '\f':
        case '\r':
        case '\v':
            continue;
        }
        break;
    }

    /*
     * Sign
     */
    if(*p=='-' || *p=='+')
        if(*p++ == '-')
            neg = 1;

    /*
     * Base
     */
    if(base==0){
        base = 10;
        if(*p == '0') {
            base = 8;
            if(p[1]=='x' || p[1]=='X') {
                p += 2;
                base = 16;
            }
        }
    } else
    if(base==16 && *p=='0') {
        if(p[1]=='x' || p[1]=='X')
            p += 2;
    } else
    if(base<0 || 36<base)
        goto Return;

    /*
     * Non-empty sequence of digits
     */
    m = VLONG_MAX/base;
    for(;; p++,ndig++) {
        c = *p;
        v = base;
        if('0'<=c && c<='9')
            v = c - '0';
        else
        if('a'<=c && c<='z')
            v = c - 'a' + 10;
        else
        if('A'<=c && c<='Z')
            v = c - 'A' + 10;
        if(v >= base)
            break;
        if(n > m)
            ovfl = 1;
        nn = n*base + v;
        if(nn < n)
            ovfl = 1;
        n = nn;
    }

Return:
    if(ndig == 0)
        p = nptr;
    if(endptr)
        *endptr = p;
    if(ovfl){
        if(neg)
            return VLONG_MIN;
        return VLONG_MAX;
    }
    if(neg)
        return -n;
    return n;
}
@


%-------------------------------------------------------------

<<port/strtoll.c>>=
#include <u.h>
#include <libc.h>

<<constant VLONG_MAX>>
<<constant VLONG_MIN>>

<<function strtoll>>
@


\subsection*{[[port/strtoul.c]]}

<<constant ULONG_MAX>>=
#define ULONG_MAX   4294967295UL
@

<<function strtoul>>=
ulong
strtoul(char *nptr, char **endptr, int base)
{
    char *p;
    ulong n, nn, m;
    int c, ovfl, neg, v, ndig;

    p = nptr;
    neg = 0;
    n = 0;
    ndig = 0;
    ovfl = 0;

    /*
     * White space
     */
    for(;;p++){
        switch(*p){
        case ' ':
        case '\t':
        case '\n':
        case '\f':
        case '\r':
        case '\v':
            continue;
        }
        break;
    }

    /*
     * Sign
     */
    if(*p=='-' || *p=='+')
        if(*p++ == '-')
            neg = 1;

    /*
     * Base
     */
    if(base==0){
        if(*p != '0')
            base = 10;
        else{
            base = 8;
            if(p[1]=='x' || p[1]=='X')
                base = 16;
        }
    }
    if(base<2 || 36<base)
        goto Return;
    if(base==16 && *p=='0'){
        if(p[1]=='x' || p[1]=='X')
            if(('0' <= p[2] && p[2] <= '9')
             ||('a' <= p[2] && p[2] <= 'f')
             ||('A' <= p[2] && p[2] <= 'F'))
                p += 2;
    }
    /*
     * Non-empty sequence of digits
     */
    n = 0;
    m = ULONG_MAX/base;
    for(;; p++,ndig++){
        c = *p;
        v = base;
        if('0'<=c && c<='9')
            v = c - '0';
        else if('a'<=c && c<='z')
            v = c - 'a' + 10;
        else if('A'<=c && c<='Z')
            v = c - 'A' + 10;
        if(v >= base)
            break;
        if(n > m)
            ovfl = 1;
        nn = n*base + v;
        if(nn < n)
            ovfl = 1;
        n = nn;
    }

    Return:
    if(ndig == 0)
        p = nptr;
    if(endptr)
        *endptr = p;
    if(ovfl)
        return ULONG_MAX;
    if(neg)
        return -n;
    return n;
}
@


%-------------------------------------------------------------

<<port/strtoul.c>>=
#include <u.h>
#include <libc.h>

<<constant ULONG_MAX>>

<<function strtoul>>
@


\subsection*{[[port/strtoull.c]]}

<<constant UVLONG_MAX>>=
#define UVLONG_MAX  (1LL<<63)
@

<<function strtoull>>=
uvlong
strtoull(char *nptr, char **endptr, int base)
{
    char *p;
    uvlong n, nn, m;
    int c, ovfl, v, neg, ndig;

    p = nptr;
    neg = 0;
    n = 0;
    ndig = 0;
    ovfl = 0;

    /*
     * White space
     */
    for(;; p++) {
        switch(*p) {
        case ' ':
        case '\t':
        case '\n':
        case '\f':
        case '\r':
        case '\v':
            continue;
        }
        break;
    }

    /*
     * Sign
     */
    if(*p == '-' || *p == '+')
        if(*p++ == '-')
            neg = 1;

    /*
     * Base
     */
    if(base == 0) {
        base = 10;
        if(*p == '0') {
            base = 8;
            if(p[1] == 'x' || p[1] == 'X'){
                p += 2;
                base = 16;
            }
        }
    } else
    if(base == 16 && *p == '0') {
        if(p[1] == 'x' || p[1] == 'X')
            p += 2;
    } else
    if(base < 0 || 36 < base)
        goto Return;

    /*
     * Non-empty sequence of digits
     */
    m = UVLONG_MAX/base;
    for(;; p++,ndig++) {
        c = *p;
        v = base;
        if('0' <= c && c <= '9')
            v = c - '0';
        else
        if('a' <= c && c <= 'z')
            v = c - 'a' + 10;
        else
        if('A' <= c && c <= 'Z')
            v = c - 'A' + 10;
        if(v >= base)
            break;
        if(n > m)
            ovfl = 1;
        nn = n*base + v;
        if(nn < n)
            ovfl = 1;
        n = nn;
    }

Return:
    if(ndig == 0)
        p = nptr;
    if(endptr)
        *endptr = p;
    if(ovfl)
        return UVLONG_MAX;
    if(neg)
        return -n;
    return n;
}
@


%-------------------------------------------------------------

<<port/strtoull.c>>=
#include <u.h>
#include <libc.h>

<<constant UVLONG_MAX>>

<<function strtoull>>
@


\subsection*{[[port/tan.c]]}

<<global p0 (port/tan.c)>>=
static double p0     = -0.1306820264754825668269611177e+5;
@

<<global p1 (port/tan.c)>>=
static double p1      = 0.1055970901714953193602353981e+4;
@

<<global p2 (port/tan.c)>>=
static double p2     = -0.1550685653483266376941705728e+2;
@

<<global p3 (port/tan.c)>>=
static double p3      = 0.3422554387241003435328470489e-1;
@

<<global p4>>=
static double p4      = 0.3386638642677172096076369e-4;
@

<<global q0 (port/tan.c)>>=
static double q0     = -0.1663895238947119001851464661e+5;
@

<<global q1 (port/tan.c)>>=
static double q1      = 0.4765751362916483698926655581e+4;
@

<<global q2 (port/tan.c)>>=
static double q2     = -0.1555033164031709966900124574e+3;
@

<<function tan>>=
double
tan(double arg)
{
    double temp, e, x, xsq;
    int flag, sign, i;

    flag = 0;
    sign = 0;
    if(arg < 0){
        arg = -arg;
        sign++;
    }
    arg = 2*arg/PIO2;   /* overflow? */
    x = modf(arg, &e);
    i = e;
    switch(i%4) {
    case 1:
        x = 1 - x;
        flag = 1;
        break;

    case 2:
        sign = !sign;
        flag = 1;
        break;

    case 3:
        x = 1 - x;
        sign = !sign;
        break;

    case 0:
        break;
    }

    xsq = x*x;
    temp = ((((p4*xsq+p3)*xsq+p2)*xsq+p1)*xsq+p0)*x;
    temp = temp/(((xsq+q2)*xsq+q1)*xsq+q0);

    if(flag) {
        if(temp == 0)
            return NaN();
        temp = 1/temp;
    }
    if(sign)
        temp = -temp;
    return temp;
}
@


%-------------------------------------------------------------

<<port/tan.c>>=
/*
    floating point tangent

    A series is used after range reduction.
    Coefficients are #4285 from Hart & Cheney. (19.74D)
 */

#include <u.h>
#include <libc.h>

<<global p0 (port/tan.c)>>
<<global p1 (port/tan.c)>>
<<global p2 (port/tan.c)>>
<<global p3 (port/tan.c)>>
<<global p4>>
<<global q0 (port/tan.c)>>
<<global q1 (port/tan.c)>>
<<global q2 (port/tan.c)>>

<<function tan>>
@


\subsection*{[[port/tanh.c]]}

<<function tanh>>=
/*
    tanh(arg) computes the hyperbolic tangent of its floating
    point argument.

    sinh and cosh are called except for large arguments, which
    would cause overflow improperly.
 */

double
tanh(double arg)
{

    if(arg < 0) {
        arg = -arg;
        if(arg > 21)
            return -1;
        return -sinh(arg)/cosh(arg);
    }
    if(arg > 21)
        return 1;
    return sinh(arg)/cosh(arg);
}
@


%-------------------------------------------------------------

<<port/tanh.c>>=
#include <u.h>
#include <libc.h>

<<function tanh>>
@


\subsection*{[[port/tokenize.c]]}

<<global qsep>>=
static char qsep[] = " \t\r\n";
@

<<function qtoken>>=
static char*
qtoken(char *s, char *sep)
{
    int quoting;
    char *t;

    quoting = 0;
    t = s;  /* s is output string, t is input string */
    while(*t!='\0' && (quoting || utfrune(sep, *t)==nil)){
        if(*t != '\''){
            *s++ = *t++;
            continue;
        }
        /* *t is a quote */
        if(!quoting){
            quoting = 1;
            t++;
            continue;
        }
        /* quoting and we're on a quote */
        if(t[1] != '\''){
            /* end of quoted section; absorb closing quote */
            t++;
            quoting = 0;
            continue;
        }
        /* doubled quote; fold one quote into two */
        t++;
        *s++ = *t++;
    }
    if(*s != '\0'){
        *s = '\0';
        if(t == s)
            t++;
    }
    return t;
}
@

<<function etoken>>=
static char*
etoken(char *t, char *sep)
{
    int quoting;

    /* move to end of next token */
    quoting = 0;
    while(*t!='\0' && (quoting || utfrune(sep, *t)==nil)){
        if(*t != '\''){
            t++;
            continue;
        }
        /* *t is a quote */
        if(!quoting){
            quoting = 1;
            t++;
            continue;
        }
        /* quoting and we're on a quote */
        if(t[1] != '\''){
            /* end of quoted section; absorb closing quote */
            t++;
            quoting = 0;
            continue;
        }
        /* doubled quote; fold one quote into two */
        t += 2;
    }
    return t;
}
@

<<function gettokens>>=
int
gettokens(char *s, char **args, int maxargs, char *sep)
{
    int nargs;

    for(nargs=0; nargs<maxargs; nargs++){
        while(*s!='\0' && utfrune(sep, *s)!=nil)
            *s++ = '\0';
        if(*s == '\0')
            break;
        args[nargs] = s;
        s = etoken(s, sep);
    }

    return nargs;
}
@

<<function tokenize>>=
int
tokenize(char *s, char **args, int maxargs)
{
    int nargs;

    for(nargs=0; nargs<maxargs; nargs++){
        while(*s!='\0' && utfrune(qsep, *s)!=nil)
            s++;
        if(*s == '\0')
            break;
        args[nargs] = s;
        s = qtoken(s, qsep);
    }

    return nargs;
}
@


%-------------------------------------------------------------

<<port/tokenize.c>>=
#include <u.h>
#include <libc.h>

<<global qsep>>

<<function qtoken>>

<<function etoken>>

<<function gettokens>>

<<function tokenize>>
@


\subsection*{[[port/toupper.c]]}

<<function toupper>>=
int
toupper(int c)
{

    if(c < 'a' || c > 'z')
        return c;
    return _toupper(c);
}
@

<<function tolower>>=
int
tolower(int c)
{

    if(c < 'A' || c > 'Z')
        return c;
    return _tolower(c);
}
@


%-------------------------------------------------------------

<<port/toupper.c>>=
#include    <ctype.h>

<<function toupper>>

<<function tolower>>
@


\subsection*{[[port/u16.c]]}

<<global t16e>>=
static char t16e[] = "0123456789ABCDEF";
@

<<function dec16>>=
int
dec16(uchar *out, int lim, char *in, int n)
{
    int c, w = 0, i = 0;
    uchar *start = out;
    uchar *eout = out + lim;

    while(n-- > 0){
        c = *in++;
        if('0' <= c && c <= '9')
            c = c - '0';
        else if('a' <= c && c <= 'z')
            c = c - 'a' + 10;
        else if('A' <= c && c <= 'Z')
            c = c - 'A' + 10;
        else
            continue;
        w = (w<<4) + c;
        i++;
        if(i == 2){
            if(out + 1 > eout)
                goto exhausted;
            *out++ = w;
            w = 0;
            i = 0;
        }
    }
exhausted:
    return out - start;
}
@

<<function enc16>>=
int
enc16(char *out, int lim, uchar *in, int n)
{
    uint c;
    char *eout = out + lim;
    char *start = out;

    while(n-- > 0){
        c = *in++;
        if(out + 2 >= eout)
            goto exhausted;
        *out++ = t16e[c>>4];
        *out++ = t16e[c&0xf];
    }
exhausted:
    *out = 0;
    return out - start;
}
@


%-------------------------------------------------------------

<<port/u16.c>>=
#include <u.h>
#include <libc.h>
<<global t16e>>

<<function dec16>>

<<function enc16>>
@


\subsection*{[[port/u32.c]]}

<<function dec32>>=
int
dec32(uchar *dest, int ndest, char *src, int nsrc)
{
    char *s, *tab;
    uchar *start;
    int i, u[8];

    if(ndest+1 < (5*nsrc+7)/8)
        return -1;
    start = dest;
    tab = "23456789abcdefghijkmnpqrstuvwxyz";
    while(nsrc>=8){
        for(i=0; i<8; i++){
            s = strchr(tab,(int)src[i]);
            u[i] = s ? s-tab : 0;
        }
        *dest++ = (u[0]<<3) | (0x7 & (u[1]>>2));
        *dest++ = ((0x3 & u[1])<<6) | (u[2]<<1) | (0x1 & (u[3]>>4));
        *dest++ = ((0xf & u[3])<<4) | (0xf & (u[4]>>1));
        *dest++ = ((0x1 & u[4])<<7) | (u[5]<<2) | (0x3 & (u[6]>>3));
        *dest++ = ((0x7 & u[6])<<5) | u[7];
        src  += 8;
        nsrc -= 8;
    }
    if(nsrc > 0){
        if(nsrc == 1 || nsrc == 3 || nsrc == 6)
            return -1;
        for(i=0; i<nsrc; i++){
            s = strchr(tab,(int)src[i]);
            u[i] = s ? s-tab : 0;
        }
        *dest++ = (u[0]<<3) | (0x7 & (u[1]>>2));
        if(nsrc == 2)
            goto out;
        *dest++ = ((0x3 & u[1])<<6) | (u[2]<<1) | (0x1 & (u[3]>>4));
        if(nsrc == 4)
            goto out;
        *dest++ = ((0xf & u[3])<<4) | (0xf & (u[4]>>1));
        if(nsrc == 5)
            goto out;
        *dest++ = ((0x1 & u[4])<<7) | (u[5]<<2) | (0x3 & (u[6]>>3));
    }
out:
    return dest-start;
}
@

<<function enc32>>=
int
enc32(char *dest, int ndest, uchar *src, int nsrc)
{
    char *tab, *start;
    int j;

    if(ndest <= (8*nsrc+4)/5 )
        return -1;
    start = dest;
    tab = "23456789abcdefghijkmnpqrstuvwxyz";
    while(nsrc>=5){
        j = (0x1f & (src[0]>>3));
        *dest++ = tab[j];
        j = (0x1c & (src[0]<<2)) | (0x03 & (src[1]>>6));
        *dest++ = tab[j];
        j = (0x1f & (src[1]>>1));
        *dest++ = tab[j];
        j = (0x10 & (src[1]<<4)) | (0x0f & (src[2]>>4));
        *dest++ = tab[j];
        j = (0x1e & (src[2]<<1)) | (0x01 & (src[3]>>7));
        *dest++ = tab[j];
        j = (0x1f & (src[3]>>2));
        *dest++ = tab[j];
        j = (0x18 & (src[3]<<3)) | (0x07 & (src[4]>>5));
        *dest++ = tab[j];
        j = (0x1f & (src[4]));
        *dest++ = tab[j];
        src  += 5;
        nsrc -= 5;
    }
    if(nsrc){
        j = (0x1f & (src[0]>>3));
        *dest++ = tab[j];
        j = (0x1c & (src[0]<<2));
        if(nsrc == 1)
            goto out;
        j |= (0x03 & (src[1]>>6));
        *dest++ = tab[j];
        j = (0x1f & (src[1]>>1));
        if(nsrc == 2)
            goto out;
        *dest++ = tab[j];
        j = (0x10 & (src[1]<<4));
        if(nsrc == 3)
            goto out;
        j |= (0x0f & (src[2]>>4));
        *dest++ = tab[j];
        j = (0x1e & (src[2]<<1));
        if(nsrc == 4)
            goto out;
        j |= (0x01 & (src[3]>>7));
        *dest++ = tab[j];
        j = (0x1f & (src[3]>>2));
        *dest++ = tab[j];
        j = (0x18 & (src[3]<<3));
out:
        *dest++ = tab[j];
    }
    *dest = 0;
    return dest-start;
}
@


%-------------------------------------------------------------

<<port/u32.c>>=
#include <u.h>
#include <libc.h>

<<function dec32>>

<<function enc32>>
@


\subsection*{[[port/u64.c]]}

<<enum _anon_ (port/u64.c)>>=
enum {
    INVAL=  255
};
@

<<global t64d>>=
static uchar t64d[256] = {
   INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,
   INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,
   INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,   62,INVAL,INVAL,INVAL,   63,
      52,   53,   54,   55,   56,   57,   58,   59,   60,   61,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,
   INVAL,    0,    1,    2,    3,    4,    5,    6,    7,    8,    9,   10,   11,   12,   13,   14,
      15,   16,   17,   18,   19,   20,   21,   22,   23,   24,   25,INVAL,INVAL,INVAL,INVAL,INVAL,
   INVAL,   26,   27,   28,   29,   30,   31,   32,   33,   34,   35,   36,   37,   38,   39,   40,
      41,   42,   43,   44,   45,   46,   47,   48,   49,   50,   51,INVAL,INVAL,INVAL,INVAL,INVAL,
   INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,
   INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,
   INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,
   INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,
   INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,
   INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,
   INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,
   INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL,INVAL
};
@

<<global t64e>>=
static char t64e[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
@

<<function dec64>>=
int
dec64(uchar *out, int lim, char *in, int n)
{
    ulong b24;
    uchar *start = out;
    uchar *e = out + lim;
    int i, c;

    b24 = 0;
    i = 0;
    while(n-- > 0){
 
        c = t64d[*(uchar*)in++];
        if(c == INVAL)
            continue;
        switch(i){
        case 0:
            b24 = c<<18;
            break;
        case 1:
            b24 |= c<<12;
            break;
        case 2:
            b24 |= c<<6;
            break;
        case 3:
            if(out + 3 > e)
                goto exhausted;

            b24 |= c;
            *out++ = b24>>16;
            *out++ = b24>>8;
            *out++ = b24;
            i = -1;
            break;
        }
        i++;
    }
    switch(i){
    case 2:
        if(out + 1 > e)
            goto exhausted;
        *out++ = b24>>16;
        break;
    case 3:
        if(out + 2 > e)
            goto exhausted;
        *out++ = b24>>16;
        *out++ = b24>>8;
        break;
    }
exhausted:
    return out - start;
}
@

<<function enc64>>=
int
enc64(char *out, int lim, uchar *in, int n)
{
    int i;
    ulong b24;
    char *start = out;
    char *e = out + lim;

    for(i = n/3; i > 0; i--){
        b24 = (*in++)<<16;
        b24 |= (*in++)<<8;
        b24 |= *in++;
        if(out + 4 >= e)
            goto exhausted;
        *out++ = t64e[(b24>>18)];
        *out++ = t64e[(b24>>12)&0x3f];
        *out++ = t64e[(b24>>6)&0x3f];
        *out++ = t64e[(b24)&0x3f];
    }

    switch(n%3){
    case 2:
        b24 = (*in++)<<16;
        b24 |= (*in)<<8;
        if(out + 4 >= e)
            goto exhausted;
        *out++ = t64e[(b24>>18)];
        *out++ = t64e[(b24>>12)&0x3f];
        *out++ = t64e[(b24>>6)&0x3f];
        *out++ = '=';
        break;
    case 1:
        b24 = (*in)<<16;
        if(out + 4 >= e)
            goto exhausted;
        *out++ = t64e[(b24>>18)];
        *out++ = t64e[(b24>>12)&0x3f];
        *out++ = '=';
        *out++ = '=';
        break;
    }
exhausted:
    *out = 0;
    return out - start;
}
@


%-------------------------------------------------------------

<<port/u64.c>>=
#include <u.h>
#include <libc.h>

<<enum _anon_ (port/u64.c)>>

<<global t64d>>
<<global t64e>>

<<function dec64>>

<<function enc64>>
@


\subsection*{[[port/utfecpy.c]]}

<<function utfecpy>>=
char*
utfecpy(char *to, char *e, char *from)
{
    char *end;

    if(to >= e)
        return to;
    end = memccpy(to, from, '\0', e - to);
    if(end == nil){
        end = e;
        while(end>to && (*--end&0xC0)==0x80)
            ;
        *end = '\0';
    }else{
        end--;
    }
    return end;
}
@


%-------------------------------------------------------------

<<port/utfecpy.c>>=
#include <u.h>
#include <libc.h>

<<function utfecpy>>
@


\subsection*{[[port/utflen.c]]}

<<function utflen>>=
int
utflen(char *s)
{
    int c;
    long n;
    Rune rune;

    n = 0;
    for(;;) {
        c = *(uchar*)s;
        if(c < Runeself) {
            if(c == 0)
                return n;
            s++;
        } else
            s += chartorune(&rune, s);
        n++;
    }
}
@


%-------------------------------------------------------------

<<port/utflen.c>>=
#include <u.h>
#include <libc.h>

<<function utflen>>
@


\subsection*{[[port/utfnlen.c]]}

<<function utfnlen>>=
int
utfnlen(char *s, long m)
{
    int c;
    long n;
    Rune rune;
    char *es;

    es = s + m;
    for(n = 0; s < es; n++) {
        c = *(uchar*)s;
        if(c < Runeself){
            if(c == '\0')
                break;
            s++;
            continue;
        }
        if(!fullrune(s, es-s))
            break;
        s += chartorune(&rune, s);
    }
    return n;
}
@


%-------------------------------------------------------------

<<port/utfnlen.c>>=
#include <u.h>
#include <libc.h>

<<function utfnlen>>
@


\subsection*{[[port/utfrrune.c]]}

<<function utfrrune>>=
char*
utfrrune(char *s, long c)
{
    long c1;
    Rune r;
    char *s1;

    if(c < Runesync)        /* not part of utf sequence */
        return strrchr(s, c);

    s1 = 0;
    for(;;) {
        c1 = *(uchar*)s;
        if(c1 < Runeself) { /* one byte rune */
            if(c1 == 0)
                return s1;
            if(c1 == c)
                s1 = s;
            s++;
            continue;
        }
        c1 = chartorune(&r, s);
        if(r == c)
            s1 = s;
        s += c1;
    }
}
@


%-------------------------------------------------------------

<<port/utfrrune.c>>=
#include <u.h>
#include <libc.h>

<<function utfrrune>>
@


\subsection*{[[port/utfrune.c]]}

<<function utfrune>>=
char*
utfrune(char *s, long c)
{
    long c1;
    Rune r;
    int n;

    if(c < Runesync)        /* not part of utf sequence */
        return strchr(s, c);

    for(;;) {
        c1 = *(uchar*)s;
        if(c1 < Runeself) { /* one byte rune */
            if(c1 == 0)
                return 0;
            if(c1 == c)
                return s;
            s++;
            continue;
        }
        n = chartorune(&r, s);
        if(r == c)
            return s;
        s += n;
    }
}
@


%-------------------------------------------------------------

<<port/utfrune.c>>=
#include <u.h>
#include <libc.h>

<<function utfrune>>
@


\subsection*{[[port/utfutf.c]]}

<<function utfutf>>=
/*
 * Return pointer to first occurrence of s2 in s1,
 * 0 if none
 */
char*
utfutf(char *s1, char *s2)
{
    char *p;
    long f, n1, n2;
    Rune r;

    n1 = chartorune(&r, s2);
    f = r;
    if(f <= Runesync)       /* represents self */
        return strstr(s1, s2);

    n2 = strlen(s2);
    for(p=s1; p=utfrune(p, f); p+=n1)
        if(strncmp(p, s2, n2) == 0)
            return p;
    return 0;
}
@


%-------------------------------------------------------------

<<port/utfutf.c>>=
#include <u.h>
#include <libc.h>


<<function utfutf>>
@


\section{[[lib_core/libc/9sys/]]}

\subsection*{[[9sys/abort.c]]}

<<function abort>>=
void
abort(void)
{
    while(*(int*)0)
        ;
}
@


%-------------------------------------------------------------

<<9sys/abort.c>>=
#include <u.h>
#include <libc.h>
<<function abort>>
@


\subsection*{[[9sys/access.c]]}

<<function access>>=
int
access(char *name, int mode)
{
    int fd;
    Dir *db;
    static char omode[] = {
        0,
        OEXEC,
        OWRITE,
        ORDWR,
        OREAD,
        OEXEC,  /* only approximate */
        ORDWR,
        ORDWR   /* only approximate */
    };

    if(mode == AEXIST){
        db = dirstat(name);
        free(db);
        if(db != nil)
            return 0;
        return -1;
    }
    fd = open(name, omode[mode&7]);
    if(fd >= 0){
        close(fd);
        return 0;
    }
    return -1;
}
@


%-------------------------------------------------------------

<<9sys/access.c>>=
#include <u.h>
#include <libc.h>

<<function access>>
@


\subsection*{[[9sys/announce.c]]}

<<enum _anon_ (9sys/announce.c)>>=
enum
{
    Maxpath=    256,
};
@

<<function announce>>=
/*
 *  announce a network service.
 */
int
announce(char *addr, char *dir)
{
    int ctl, n, m;
    char buf[Maxpath];
    char buf2[Maxpath];
    char netdir[Maxpath];
    char naddr[Maxpath];
    char *cp;

    /*
     *  translate the address
     */
    if(nettrans(addr, naddr, sizeof(naddr), netdir, sizeof(netdir)) < 0)
        return -1;

    /*
     * get a control channel
     */
    ctl = open(netdir, ORDWR);
    if(ctl<0){
        werrstr("announce opening %s: %r", netdir);
        return -1;
    }
    cp = strrchr(netdir, '/');
    if(cp == nil){
        werrstr("announce arg format %s", netdir);
        close(ctl);
        return -1;
    }
    *cp = 0;

    /*
     *  find out which line we have
     */
    n = snprint(buf, sizeof(buf), "%s/", netdir);
    m = read(ctl, &buf[n], sizeof(buf)-n-1);
    if(m <= 0){
        werrstr("announce reading %s: %r", netdir);
        close(ctl);
        return -1;
    }
    buf[n+m] = 0;

    /*
     *  make the call
     */
    n = snprint(buf2, sizeof(buf2), "announce %s", naddr);
    if(write(ctl, buf2, n)!=n){
        werrstr("announce writing %s: %r", netdir);
        close(ctl);
        return -1;
    }

    /*
     *  return directory etc.
     */
    if(dir){
        strncpy(dir, buf, NETPATHLEN);
        dir[NETPATHLEN-1] = 0;
    }
    return ctl;
}
@

<<function listen>>=
/*
 *  listen for an incoming call
 */
int
listen(char *dir, char *newdir)
{
    int ctl, n, m;
    char buf[Maxpath];
    char *cp;

    /*
     *  open listen, wait for a call
     */
    snprint(buf, sizeof(buf), "%s/listen", dir);
    ctl = open(buf, ORDWR);
    if(ctl < 0){
        werrstr("listen opening %s: %r", buf);
        return -1;
    }

    /*
     *  find out which line we have
     */
    strncpy(buf, dir, sizeof(buf) - 1);
    buf[sizeof(buf) - 1] = 0;
    cp = strrchr(buf, '/');
    if(cp == nil){
        close(ctl);
        werrstr("listen arg format %s", dir);
        return -1;
    }
    *++cp = 0;
    n = cp-buf;
    m = read(ctl, cp, sizeof(buf) - n - 1);
    if(m <= 0){
        close(ctl);
        werrstr("listen reading %s/listen: %r", dir);
        return -1;
    }
    buf[n+m] = 0;

    /*
     *  return directory etc.
     */
    if(newdir){
        strncpy(newdir, buf, NETPATHLEN);
        newdir[NETPATHLEN-1] = 0;
    }
    return ctl;

}
@

<<function accept>>=
/*
 *  accept a call, return an fd to the open data file
 */
int
accept(int ctl, char *dir)
{
    char buf[Maxpath];
    char *num;
    long n;

    num = strrchr(dir, '/');
    if(num == nil)
        num = dir;
    else
        num++;

    n = snprint(buf, sizeof(buf), "accept %s", num);
    write(ctl, buf, n); /* ignore return value, network might not need accepts */

    snprint(buf, sizeof(buf), "%s/data", dir);
    return open(buf, ORDWR);
}
@

<<function reject>>=
/*
 *  reject a call, tell device the reason for the rejection
 */
int
reject(int ctl, char *dir, char *cause)
{
    char buf[Maxpath];
    char *num;
    long n;

    num = strrchr(dir, '/');
    if(num == 0)
        num = dir;
    else
        num++;
    snprint(buf, sizeof(buf), "reject %s %s", num, cause);
    n = strlen(buf);
    if(write(ctl, buf, n) != n)
        return -1;
    return 0;
}
@

<<function identtrans>>=
/*
 *  perform the identity translation (in case we can't reach cs)
 */
static int
identtrans(char *netdir, char *addr, char *naddr, int na, char *file, int nf)
{
    char proto[Maxpath];
    char *p;

    USED(nf);

    /* parse the protocol */
    strncpy(proto, addr, sizeof(proto));
    proto[sizeof(proto)-1] = 0;
    p = strchr(proto, '!');
    if(p)
        *p++ = 0;

    snprint(file, nf, "%s/%s/clone", netdir, proto);
    strncpy(naddr, p, na);
    naddr[na-1] = 0;

    return 1;
}
@

<<function nettrans>>=
/*
 *  call up the connection server and get a translation
 */
static int
nettrans(char *addr, char *naddr, int na, char *file, int nf)
{
    int i, fd;
    char buf[Maxpath];
    char netdir[Maxpath];
    char *p, *p2;
    long n;

    /*
     *  parse, get network directory
     */
    p = strchr(addr, '!');
    if(p == 0){
        werrstr("bad dial string: %s", addr);
        return -1;
    }
    if(*addr != '/'){
        strncpy(netdir, "/net", sizeof(netdir));
        netdir[sizeof(netdir) - 1] = 0;
    } else {
        for(p2 = p; *p2 != '/'; p2--)
            ;
        i = p2 - addr;
        if(i == 0 || i >= sizeof(netdir)){
            werrstr("bad dial string: %s", addr);
            return -1;
        }
        strncpy(netdir, addr, i);
        netdir[i] = 0;
        addr = p2 + 1;
    }

    /*
     *  ask the connection server
     */
    snprint(buf, sizeof(buf), "%s/cs", netdir);
    fd = open(buf, ORDWR);
    if(fd < 0)
        return identtrans(netdir, addr, naddr, na, file, nf);
    if(write(fd, addr, strlen(addr)) < 0){
        close(fd);
        return -1;
    }
    seek(fd, 0, 0);
    n = read(fd, buf, sizeof(buf)-1);
    close(fd);
    if(n <= 0)
        return -1;
    buf[n] = 0;

    /*
     *  parse the reply
     */
    p = strchr(buf, ' ');
    if(p == 0)
        return -1;
    *p++ = 0;
    strncpy(naddr, p, na);
    naddr[na-1] = 0;

    if(buf[0] == '/'){
        p = strchr(buf+1, '/');
        if(p == nil)
            p = buf;
        else 
            p++;
    }
    snprint(file, nf, "%s/%s", netdir, p);
    return 0;
}
@


%-------------------------------------------------------------

<<9sys/announce.c>>=
#include <u.h>
#include <libc.h>
#include <ctype.h>

static int  nettrans(char*, char*, int na, char*, int);

<<enum _anon_ (9sys/announce.c)>>

<<function announce>>

<<function listen>>

<<function accept>>

<<function reject>>

<<function identtrans>>

<<function nettrans>>
@


\subsection*{[[9sys/convD2M.c]]}

<<function sizeD2M>>=
uint
sizeD2M(Dir *d)
{
    char *sv[4];
    int i, ns;

    sv[0] = d->name;
    sv[1] = d->uid;
    sv[2] = d->gid;
    sv[3] = d->muid;

    ns = 0;
    for(i = 0; i < 4; i++)
        if(sv[i])
            ns += strlen(sv[i]);

    return STATFIXLEN + ns;
}
@

<<function convD2M>>=
uint
convD2M(Dir *d, uchar *buf, uint nbuf)
{
    uchar *p, *ebuf;
    char *sv[4];
    int i, ns, nsv[4], ss;

    if(nbuf < BIT16SZ)
        return 0;

    p = buf;
    ebuf = buf + nbuf;

    sv[0] = d->name;
    sv[1] = d->uid;
    sv[2] = d->gid;
    sv[3] = d->muid;

    ns = 0;
    for(i = 0; i < 4; i++){
        if(sv[i])
            nsv[i] = strlen(sv[i]);
        else
            nsv[i] = 0;
        ns += nsv[i];
    }

    ss = STATFIXLEN + ns;

    /* set size before erroring, so user can know how much is needed */
    /* note that length excludes count field itself */
    PBIT16(p, ss-BIT16SZ);
    p += BIT16SZ;

    if(ss > nbuf)
        return BIT16SZ;

    PBIT16(p, d->type);
    p += BIT16SZ;
    PBIT32(p, d->dev);
    p += BIT32SZ;
    PBIT8(p, d->qid.type);
    p += BIT8SZ;
    PBIT32(p, d->qid.vers);
    p += BIT32SZ;
    PBIT64(p, d->qid.path);
    p += BIT64SZ;
    PBIT32(p, d->mode);
    p += BIT32SZ;
    PBIT32(p, d->atime);
    p += BIT32SZ;
    PBIT32(p, d->mtime);
    p += BIT32SZ;
    PBIT64(p, d->length);
    p += BIT64SZ;

    for(i = 0; i < 4; i++){
        ns = nsv[i];
        if(p + ns + BIT16SZ > ebuf)
            return 0;
        PBIT16(p, ns);
        p += BIT16SZ;
        if(ns)
            memmove(p, sv[i], ns);
        p += ns;
    }

    if(ss != p - buf)
        return 0;

    return p - buf;
}
@


%-------------------------------------------------------------

<<9sys/convD2M.c>>=
#include    <u.h>
#include    <libc.h>
#include    <fcall.h>

<<function sizeD2M>>

<<function convD2M>>
@


\subsection*{[[9sys/convM2D.c]]}

<<function statcheck>>=
int
statcheck(uchar *buf, uint nbuf)
{
    uchar *ebuf;
    int i;

    ebuf = buf + nbuf;

    if(nbuf < STATFIXLEN || nbuf != BIT16SZ + GBIT16(buf))
        return -1;

    buf += STATFIXLEN - 4 * BIT16SZ;

    for(i = 0; i < 4; i++){
        if(buf + BIT16SZ > ebuf)
            return -1;
        buf += BIT16SZ + GBIT16(buf);
    }

    if(buf != ebuf)
        return -1;

    return 0;
}
@

<<global nullstring>>=
static char nullstring[] = "";
@

<<function convM2D>>=
uint
convM2D(uchar *buf, uint nbuf, Dir *d, char *strs)
{
    uchar *p, *ebuf;
    char *sv[4];
    int i, ns;

    if(nbuf < STATFIXLEN)
        return 0; 

    p = buf;
    ebuf = buf + nbuf;

    p += BIT16SZ;   /* ignore size */
    d->type = GBIT16(p);
    p += BIT16SZ;
    d->dev = GBIT32(p);
    p += BIT32SZ;
    d->qid.type = GBIT8(p);
    p += BIT8SZ;
    d->qid.vers = GBIT32(p);
    p += BIT32SZ;
    d->qid.path = GBIT64(p);
    p += BIT64SZ;
    d->mode = GBIT32(p);
    p += BIT32SZ;
    d->atime = GBIT32(p);
    p += BIT32SZ;
    d->mtime = GBIT32(p);
    p += BIT32SZ;
    d->length = GBIT64(p);
    p += BIT64SZ;

    for(i = 0; i < 4; i++){
        if(p + BIT16SZ > ebuf)
            return 0;
        ns = GBIT16(p);
        p += BIT16SZ;
        if(p + ns > ebuf)
            return 0;
        if(strs){
            sv[i] = strs;
            memmove(strs, p, ns);
            strs += ns;
            *strs++ = '\0';
        }
        p += ns;
    }

    if(strs){
        d->name = sv[0];
        d->uid = sv[1];
        d->gid = sv[2];
        d->muid = sv[3];
    }else{
        d->name = nullstring;
        d->uid = nullstring;
        d->gid = nullstring;
        d->muid = nullstring;
    }
    
    return p - buf;
}
@


%-------------------------------------------------------------

<<9sys/convM2D.c>>=
#include    <u.h>
#include    <libc.h>
#include    <fcall.h>

<<function statcheck>>

<<global nullstring>>

<<function convM2D>>
@


\subsection*{[[9sys/convM2S.c]]}

<<function gstring>>=
static
uchar*
gstring(uchar *p, uchar *ep, char **s)
{
    uint n;

    if(p+BIT16SZ > ep)
        return nil;
    n = GBIT16(p);
    p += BIT16SZ - 1;
    if(p+n+1 > ep)
        return nil;
    /* move it down, on top of count, to make room for '\0' */
    memmove(p, p + 1, n);
    p[n] = '\0';
    *s = (char*)p;
    p += n+1;
    return p;
}
@

<<function gqid>>=
static
uchar*
gqid(uchar *p, uchar *ep, Qid *q)
{
    if(p+QIDSZ > ep)
        return nil;
    q->type = GBIT8(p);
    p += BIT8SZ;
    q->vers = GBIT32(p);
    p += BIT32SZ;
    q->path = GBIT64(p);
    p += BIT64SZ;
    return p;
}
@

<<function convM2S>>=
/*
 * no syntactic checks.
 * three causes for error:
 *  1. message size field is incorrect
 *  2. input buffer too short for its own data (counts too long, etc.)
 *  3. too many names or qids
 * gqid() and gstring() return nil if they would reach beyond buffer.
 * main switch statement checks range and also can fall through
 * to test at end of routine.
 */
uint
convM2S(uchar *ap, uint nap, Fcall *f)
{
    uchar *p, *ep;
    uint i, size;

    p = ap;
    ep = p + nap;

    if(p+BIT32SZ+BIT8SZ+BIT16SZ > ep)
        return 0;
    size = GBIT32(p);
    p += BIT32SZ;

    if(size < BIT32SZ+BIT8SZ+BIT16SZ)
        return 0;

    f->type = GBIT8(p);
    p += BIT8SZ;
    f->tag = GBIT16(p);
    p += BIT16SZ;

    switch(f->type)
    {
    default:
        return 0;

    case Tversion:
        if(p+BIT32SZ > ep)
            return 0;
        f->msize = GBIT32(p);
        p += BIT32SZ;
        p = gstring(p, ep, &f->version);
        break;

    case Tflush:
        if(p+BIT16SZ > ep)
            return 0;
        f->oldtag = GBIT16(p);
        p += BIT16SZ;
        break;

    case Tauth:
        if(p+BIT32SZ > ep)
            return 0;
        f->afid = GBIT32(p);
        p += BIT32SZ;
        p = gstring(p, ep, &f->uname);
        if(p == nil)
            break;
        p = gstring(p, ep, &f->aname);
        if(p == nil)
            break;
        break;

    case Tattach:
        if(p+BIT32SZ > ep)
            return 0;
        f->fid = GBIT32(p);
        p += BIT32SZ;
        if(p+BIT32SZ > ep)
            return 0;
        f->afid = GBIT32(p);
        p += BIT32SZ;
        p = gstring(p, ep, &f->uname);
        if(p == nil)
            break;
        p = gstring(p, ep, &f->aname);
        if(p == nil)
            break;
        break;

    case Twalk:
        if(p+BIT32SZ+BIT32SZ+BIT16SZ > ep)
            return 0;
        f->fid = GBIT32(p);
        p += BIT32SZ;
        f->newfid = GBIT32(p);
        p += BIT32SZ;
        f->nwname = GBIT16(p);
        p += BIT16SZ;
        if(f->nwname > MAXWELEM)
            return 0;
        for(i=0; i<f->nwname; i++){
            p = gstring(p, ep, &f->wname[i]);
            if(p == nil)
                break;
        }
        break;

    case Topen:
        if(p+BIT32SZ+BIT8SZ > ep)
            return 0;
        f->fid = GBIT32(p);
        p += BIT32SZ;
        f->mode = GBIT8(p);
        p += BIT8SZ;
        break;

    case Tcreate:
        if(p+BIT32SZ > ep)
            return 0;
        f->fid = GBIT32(p);
        p += BIT32SZ;
        p = gstring(p, ep, &f->name);
        if(p == nil)
            break;
        if(p+BIT32SZ+BIT8SZ > ep)
            return 0;
        f->perm = GBIT32(p);
        p += BIT32SZ;
        f->mode = GBIT8(p);
        p += BIT8SZ;
        break;

    case Tread:
        if(p+BIT32SZ+BIT64SZ+BIT32SZ > ep)
            return 0;
        f->fid = GBIT32(p);
        p += BIT32SZ;
        f->offset = GBIT64(p);
        p += BIT64SZ;
        f->count = GBIT32(p);
        p += BIT32SZ;
        break;

    case Twrite:
        if(p+BIT32SZ+BIT64SZ+BIT32SZ > ep)
            return 0;
        f->fid = GBIT32(p);
        p += BIT32SZ;
        f->offset = GBIT64(p);
        p += BIT64SZ;
        f->count = GBIT32(p);
        p += BIT32SZ;
        if(p+f->count > ep)
            return 0;
        f->data = (char*)p;
        p += f->count;
        break;

    case Tclunk:
    case Tremove:
        if(p+BIT32SZ > ep)
            return 0;
        f->fid = GBIT32(p);
        p += BIT32SZ;
        break;

    case Tstat:
        if(p+BIT32SZ > ep)
            return 0;
        f->fid = GBIT32(p);
        p += BIT32SZ;
        break;

    case Twstat:
        if(p+BIT32SZ+BIT16SZ > ep)
            return 0;
        f->fid = GBIT32(p);
        p += BIT32SZ;
        f->nstat = GBIT16(p);
        p += BIT16SZ;
        if(p+f->nstat > ep)
            return 0;
        f->stat = p;
        p += f->nstat;
        break;

/*
 */
    case Rversion:
        if(p+BIT32SZ > ep)
            return 0;
        f->msize = GBIT32(p);
        p += BIT32SZ;
        p = gstring(p, ep, &f->version);
        break;

    case Rerror:
        p = gstring(p, ep, &f->ename);
        break;

    case Rflush:
        break;

    case Rauth:
        p = gqid(p, ep, &f->aqid);
        if(p == nil)
            break;
        break;

    case Rattach:
        p = gqid(p, ep, &f->qid);
        if(p == nil)
            break;
        break;

    case Rwalk:
        if(p+BIT16SZ > ep)
            return 0;
        f->nwqid = GBIT16(p);
        p += BIT16SZ;
        if(f->nwqid > MAXWELEM)
            return 0;
        for(i=0; i<f->nwqid; i++){
            p = gqid(p, ep, &f->wqid[i]);
            if(p == nil)
                break;
        }
        break;

    case Ropen:
    case Rcreate:
        p = gqid(p, ep, &f->qid);
        if(p == nil)
            break;
        if(p+BIT32SZ > ep)
            return 0;
        f->iounit = GBIT32(p);
        p += BIT32SZ;
        break;

    case Rread:
        if(p+BIT32SZ > ep)
            return 0;
        f->count = GBIT32(p);
        p += BIT32SZ;
        if(p+f->count > ep)
            return 0;
        f->data = (char*)p;
        p += f->count;
        break;

    case Rwrite:
        if(p+BIT32SZ > ep)
            return 0;
        f->count = GBIT32(p);
        p += BIT32SZ;
        break;

    case Rclunk:
    case Rremove:
        break;

    case Rstat:
        if(p+BIT16SZ > ep)
            return 0;
        f->nstat = GBIT16(p);
        p += BIT16SZ;
        if(p+f->nstat > ep)
            return 0;
        f->stat = p;
        p += f->nstat;
        break;

    case Rwstat:
        break;
    }

    if(p==nil || p>ep)
        return 0;
    if(ap+size == p)
        return size;
    return 0;
}
@


%-------------------------------------------------------------

<<9sys/convM2S.c>>=
#include    <u.h>
#include    <libc.h>
#include    <fcall.h>

<<function gstring>>

<<function gqid>>

<<function convM2S>>
@


\subsection*{[[9sys/convS2M.c]]}

<<function pstring>>=
static
uchar*
pstring(uchar *p, char *s)
{
    uint n;

    if(s == nil){
        PBIT16(p, 0);
        p += BIT16SZ;
        return p;
    }

    n = strlen(s);
    /*
     * We are moving the string before the length,
     * so you can S2M a struct into an existing message
     */
    memmove(p + BIT16SZ, s, n);
    PBIT16(p, n);
    p += n + BIT16SZ;
    return p;
}
@

<<function pqid>>=
static
uchar*
pqid(uchar *p, Qid *q)
{
    PBIT8(p, q->type);
    p += BIT8SZ;
    PBIT32(p, q->vers);
    p += BIT32SZ;
    PBIT64(p, q->path);
    p += BIT64SZ;
    return p;
}
@

<<function stringsz>>=
static
uint
stringsz(char *s)
{
    if(s == nil)
        return BIT16SZ;

    return BIT16SZ+strlen(s);
}
@

<<function sizeS2M>>=
uint
sizeS2M(Fcall *f)
{
    uint n;
    int i;

    n = 0;
    n += BIT32SZ;   /* size */
    n += BIT8SZ;    /* type */
    n += BIT16SZ;   /* tag */

    switch(f->type)
    {
    default:
        return 0;

    case Tversion:
        n += BIT32SZ;
        n += stringsz(f->version);
        break;

    case Tflush:
        n += BIT16SZ;
        break;

    case Tauth:
        n += BIT32SZ;
        n += stringsz(f->uname);
        n += stringsz(f->aname);
        break;

    case Tattach:
        n += BIT32SZ;
        n += BIT32SZ;
        n += stringsz(f->uname);
        n += stringsz(f->aname);
        break;

    case Twalk:
        n += BIT32SZ;
        n += BIT32SZ;
        n += BIT16SZ;
        for(i=0; i<f->nwname; i++)
            n += stringsz(f->wname[i]);
        break;

    case Topen:
        n += BIT32SZ;
        n += BIT8SZ;
        break;

    case Tcreate:
        n += BIT32SZ;
        n += stringsz(f->name);
        n += BIT32SZ;
        n += BIT8SZ;
        break;

    case Tread:
        n += BIT32SZ;
        n += BIT64SZ;
        n += BIT32SZ;
        break;

    case Twrite:
        n += BIT32SZ;
        n += BIT64SZ;
        n += BIT32SZ;
        n += f->count;
        break;

    case Tclunk:
    case Tremove:
        n += BIT32SZ;
        break;

    case Tstat:
        n += BIT32SZ;
        break;

    case Twstat:
        n += BIT32SZ;
        n += BIT16SZ;
        n += f->nstat;
        break;
/*
 */

    case Rversion:
        n += BIT32SZ;
        n += stringsz(f->version);
        break;

    case Rerror:
        n += stringsz(f->ename);
        break;

    case Rflush:
        break;

    case Rauth:
        n += QIDSZ;
        break;

    case Rattach:
        n += QIDSZ;
        break;

    case Rwalk:
        n += BIT16SZ;
        n += f->nwqid*QIDSZ;
        break;

    case Ropen:
    case Rcreate:
        n += QIDSZ;
        n += BIT32SZ;
        break;

    case Rread:
        n += BIT32SZ;
        n += f->count;
        break;

    case Rwrite:
        n += BIT32SZ;
        break;

    case Rclunk:
        break;

    case Rremove:
        break;

    case Rstat:
        n += BIT16SZ;
        n += f->nstat;
        break;

    case Rwstat:
        break;
    }
    return n;
}
@

<<function convS2M>>=
uint
convS2M(Fcall *f, uchar *ap, uint nap)
{
    uchar *p;
    uint i, size;

    size = sizeS2M(f);
    if(size == 0)
        return 0;
    if(size > nap)
        return 0;

    p = (uchar*)ap;

    PBIT32(p, size);
    p += BIT32SZ;
    PBIT8(p, f->type);
    p += BIT8SZ;
    PBIT16(p, f->tag);
    p += BIT16SZ;

    switch(f->type)
    {
    default:
        return 0;

    case Tversion:
        PBIT32(p, f->msize);
        p += BIT32SZ;
        p = pstring(p, f->version);
        break;

    case Tflush:
        PBIT16(p, f->oldtag);
        p += BIT16SZ;
        break;

    case Tauth:
        PBIT32(p, f->afid);
        p += BIT32SZ;
        p  = pstring(p, f->uname);
        p  = pstring(p, f->aname);
        break;

    case Tattach:
        PBIT32(p, f->fid);
        p += BIT32SZ;
        PBIT32(p, f->afid);
        p += BIT32SZ;
        p  = pstring(p, f->uname);
        p  = pstring(p, f->aname);
        break;

    case Twalk:
        PBIT32(p, f->fid);
        p += BIT32SZ;
        PBIT32(p, f->newfid);
        p += BIT32SZ;
        PBIT16(p, f->nwname);
        p += BIT16SZ;
        if(f->nwname > MAXWELEM)
            return 0;
        for(i=0; i<f->nwname; i++)
            p = pstring(p, f->wname[i]);
        break;

    case Topen:
        PBIT32(p, f->fid);
        p += BIT32SZ;
        PBIT8(p, f->mode);
        p += BIT8SZ;
        break;

    case Tcreate:
        PBIT32(p, f->fid);
        p += BIT32SZ;
        p = pstring(p, f->name);
        PBIT32(p, f->perm);
        p += BIT32SZ;
        PBIT8(p, f->mode);
        p += BIT8SZ;
        break;

    case Tread:
        PBIT32(p, f->fid);
        p += BIT32SZ;
        PBIT64(p, f->offset);
        p += BIT64SZ;
        PBIT32(p, f->count);
        p += BIT32SZ;
        break;

    case Twrite:
        PBIT32(p, f->fid);
        p += BIT32SZ;
        PBIT64(p, f->offset);
        p += BIT64SZ;
        PBIT32(p, f->count);
        p += BIT32SZ;
        memmove(p, f->data, f->count);
        p += f->count;
        break;

    case Tclunk:
    case Tremove:
        PBIT32(p, f->fid);
        p += BIT32SZ;
        break;

    case Tstat:
        PBIT32(p, f->fid);
        p += BIT32SZ;
        break;

    case Twstat:
        PBIT32(p, f->fid);
        p += BIT32SZ;
        PBIT16(p, f->nstat);
        p += BIT16SZ;
        memmove(p, f->stat, f->nstat);
        p += f->nstat;
        break;
/*
 */

    case Rversion:
        PBIT32(p, f->msize);
        p += BIT32SZ;
        p = pstring(p, f->version);
        break;

    case Rerror:
        p = pstring(p, f->ename);
        break;

    case Rflush:
        break;

    case Rauth:
        p = pqid(p, &f->aqid);
        break;

    case Rattach:
        p = pqid(p, &f->qid);
        break;

    case Rwalk:
        PBIT16(p, f->nwqid);
        p += BIT16SZ;
        if(f->nwqid > MAXWELEM)
            return 0;
        for(i=0; i<f->nwqid; i++)
            p = pqid(p, &f->wqid[i]);
        break;

    case Ropen:
    case Rcreate:
        p = pqid(p, &f->qid);
        PBIT32(p, f->iounit);
        p += BIT32SZ;
        break;

    case Rread:
        PBIT32(p, f->count);
        p += BIT32SZ;
        memmove(p, f->data, f->count);
        p += f->count;
        break;

    case Rwrite:
        PBIT32(p, f->count);
        p += BIT32SZ;
        break;

    case Rclunk:
        break;

    case Rremove:
        break;

    case Rstat:
        PBIT16(p, f->nstat);
        p += BIT16SZ;
        memmove(p, f->stat, f->nstat);
        p += f->nstat;
        break;

    case Rwstat:
        break;
    }
    if(size != p-ap)
        return 0;
    return size;
}
@


%-------------------------------------------------------------

<<9sys/convS2M.c>>=
#include    <u.h>
#include    <libc.h>
#include    <fcall.h>

<<function pstring>>

<<function pqid>>

<<function stringsz>>

<<function sizeS2M>>

<<function convS2M>>
@


\subsection*{[[9sys/cputime.c]]}

<<constant HZ>>=
#define HZ  1000
@

<<function cputime>>=
double
cputime(void)
{
    long t[4];
    int i;

    times(t);
    for(i=1; i<4; i++)
        t[0] += t[i];
    return t[0] / (double)HZ;
}
@


%-------------------------------------------------------------

<<9sys/cputime.c>>=
#include <u.h>
#include <libc.h>

<<constant HZ>>

<<function cputime>>
@


\subsection*{[[9sys/ctime.c]]}

<<global dmsize>>=
static  char    dmsize[12] =
{
    31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
};
@

<<constant TZSIZE>>=
#define TZSIZE  150
@

<<global timezone>>=
static
struct
{
    char    stname[4];
    char    dlname[4];
    long    stdiff;
    long    dldiff;
    long    dlpairs[TZSIZE];
} timezone;
@

<<function ctime>>=
char*
ctime(long t)
{
    return asctime(localtime(t));
}
@

<<function localtime>>=
Tm*
localtime(long tim)
{
    Tm *ct;
    long t, *p;
    int dlflag;

    if(timezone.stname[0] == 0)
        readtimezone();
    t = tim + timezone.stdiff;
    dlflag = 0;
    for(p = timezone.dlpairs; *p; p += 2)
        if(t >= p[0])
        if(t < p[1]) {
            t = tim + timezone.dldiff;
            dlflag++;
            break;
        }
    ct = gmtime(t);
    if(dlflag){
        strcpy(ct->zone, timezone.dlname);
        ct->tzoff = timezone.dldiff;
    } else {
        strcpy(ct->zone, timezone.stname);
        ct->tzoff = timezone.stdiff;
    }
    return ct;
}
@

<<function gmtime>>=
Tm*
gmtime(long tim)
{
    int d0, d1;
    long hms, day;
    static Tm xtime;

    /*
     * break initial number into days
     */
    hms = (ulong)tim % 86400L;
    day = (ulong)tim / 86400L;
    if(hms < 0) {
        hms += 86400L;
        day -= 1;
    }

    /*
     * generate hours:minutes:seconds
     */
    xtime.sec = hms % 60;
    d1 = hms / 60;
    xtime.min = d1 % 60;
    d1 /= 60;
    xtime.hour = d1;

    /*
     * day is the day number.
     * generate day of the week.
     * The addend is 4 mod 7 (1/1/1970 was Thursday)
     */

    xtime.wday = (day + 7340036L) % 7;

    /*
     * year number
     */
    if(day >= 0)
        for(d1 = 1970; day >= dysize(d1); d1++)
            day -= dysize(d1);
    else
        for (d1 = 1970; day < 0; d1--)
            day += dysize(d1-1);
    xtime.year = d1-1900;
    xtime.yday = d0 = day;

    /*
     * generate month
     */

    if(dysize(d1) == 366)
        dmsize[1] = 29;
    for(d1 = 0; d0 >= dmsize[d1]; d1++)
        d0 -= dmsize[d1];
    dmsize[1] = 28;
    xtime.mday = d0 + 1;
    xtime.mon = d1;
    strcpy(xtime.zone, "GMT");
    return &xtime;
}
@

<<function asctime>>=
char*
asctime(Tm *t)
{
    char *ncp;
    static char cbuf[30];

    strcpy(cbuf, "Thu Jan 01 00:00:00 GMT 1970\n");
    ncp = &"SunMonTueWedThuFriSat"[t->wday*3];
    cbuf[0] = *ncp++;
    cbuf[1] = *ncp++;
    cbuf[2] = *ncp;
    ncp = &"JanFebMarAprMayJunJulAugSepOctNovDec"[t->mon*3];
    cbuf[4] = *ncp++;
    cbuf[5] = *ncp++;
    cbuf[6] = *ncp;
    ct_numb(cbuf+8, t->mday);
    ct_numb(cbuf+11, t->hour+100);
    ct_numb(cbuf+14, t->min+100);
    ct_numb(cbuf+17, t->sec+100);
    ncp = t->zone;
    cbuf[20] = *ncp++;
    cbuf[21] = *ncp++;
    cbuf[22] = *ncp;
    if(t->year >= 100) {
        cbuf[24] = '2';
        cbuf[25] = '0';
    }
    ct_numb(cbuf+26, t->year+100);
    return cbuf;
}
@

<<function dysize>>=
static int
dysize(int y)
{

    if(y%4 == 0 && (y%100 != 0 || y%400 == 0))
        return 366;
    return 365;
}
@

<<function ct_numb>>=
static
void
ct_numb(char *cp, int n)
{

    cp[0] = ' ';
    if(n >= 10)
        cp[0] = (n/10)%10 + '0';
    cp[1] = n%10 + '0';
}
@

<<function readtimezone>>=
static
void
readtimezone(void)
{
    char buf[TZSIZE*11+30], *p;
    int i;

    memset(buf, 0, sizeof(buf));
    i = open("/env/timezone", 0);
    if(i < 0)
        goto error;
    if(read(i, buf, sizeof(buf)) >= sizeof(buf)){
        close(i);
        goto error;
    }
    close(i);
    p = buf;
    if(rd_name(&p, timezone.stname))
        goto error;
    if(rd_long(&p, &timezone.stdiff))
        goto error;
    if(rd_name(&p, timezone.dlname))
        goto error;
    if(rd_long(&p, &timezone.dldiff))
        goto error;
    for(i=0; i<TZSIZE; i++) {
        if(rd_long(&p, &timezone.dlpairs[i]))
            goto error;
        if(timezone.dlpairs[i] == 0)
            return;
    }

error:
    timezone.stdiff = 0;
    strcpy(timezone.stname, "GMT");
    timezone.dlpairs[0] = 0;
}
@

<<function rd_name>>=
static int
rd_name(char **f, char *p)
{
    int c, i;

    for(;;) {
        c = *(*f)++;
        if(c != ' ' && c != '\n')
            break;
    }
    for(i=0; i<3; i++) {
        if(c == ' ' || c == '\n')
            return 1;
        *p++ = c;
        c = *(*f)++;
    }
    if(c != ' ' && c != '\n')
        return 1;
    *p = 0;
    return 0;
}
@

<<function rd_long>>=
static int
rd_long(char **f, long *p)
{
    int c, s;
    long l;

    s = 0;
    for(;;) {
        c = *(*f)++;
        if(c == '-') {
            s++;
            continue;
        }
        if(c != ' ' && c != '\n')
            break;
    }
    if(c == 0) {
        *p = 0;
        return 0;
    }
    l = 0;
    for(;;) {
        if(c == ' ' || c == '\n')
            break;
        if(c < '0' || c > '9')
            return 1;
        l = l*10 + c-'0';
        c = *(*f)++;
    }
    if(s)
        l = -l;
    *p = l;
    return 0;
}
@


%-------------------------------------------------------------

<<9sys/ctime.c>>=
/*
 * This routine converts time as follows.
 * The epoch is 0000 Jan 1 1970 GMT.
 * The argument time is in seconds since then.
 * The localtime(t) entry returns a pointer to an array
 * containing
 *
 *  seconds (0-59)
 *  minutes (0-59)
 *  hours (0-23)
 *  day of month (1-31)
 *  month (0-11)
 *  year-1970
 *  weekday (0-6, Sun is 0)
 *  day of the year
 *  daylight savings flag
 *
 * The routine gets the daylight savings time from the environment.
 *
 * asctime(tvec))
 * where tvec is produced by localtime
 * returns a ptr to a character string
 * that has the ascii time in the form
 *
 *                              \\
 *  Thu Jan 01 00:00:00 GMT 1970n0
 *  012345678901234567890123456789
 *  0     1     2
 *
 * ctime(t) just calls localtime, then asctime.
 */

#include <u.h>
#include <libc.h>

<<global dmsize>>

/*
 * The following table is used for 1974 and 1975 and
 * gives the day number of the first day after the Sunday of the
 * change.
 */

static  int dysize(int);
static  void    ct_numb(char*, int);

<<constant TZSIZE>>
static  void    readtimezone(void);
static  int rd_name(char**, char*);
static  int rd_long(char**, long*);
<<global timezone>>

<<function ctime>>

<<function localtime>>

<<function gmtime>>

<<function asctime>>

<<function dysize>>

<<function ct_numb>>

<<function readtimezone>>

<<function rd_name>>

<<function rd_long>>
@


\subsection*{[[9sys/dial.c]]}

<<enum _anon_ (9sys/dial.c)>>=
enum
{
    Maxstring   = 128,
    Maxpath     = 256,

    Maxcsreply  = 64*80,    /* this is probably overly generous */
    /*
     * this should be a plausible slight overestimate for non-interactive
     * use even if it's ridiculously long for interactive use.
     */
    Maxconnms   = 2*60*1000,    /* 2 minutes */
};
@

<<struct DS (9sys/dial.c)>>=
struct DS {
    /* dist string */
    char    buf[Maxstring];
    char    *netdir;
    char    *proto;
    char    *rem;

    /* other args */
    char    *local;
    char    *dir;
    int *cfdp;
};
@

<<struct Conn>>=
/*
 * malloc these; they need to be writable by this proc & all children.
 * the stack is private to each proc, and static allocation in the data
 * segment would not permit concurrent dials within a multi-process program.
 */
struct Conn {
    int pid;
    int dead;

    int dfd;
    int cfd;
    char    dir[NETPATHLEN+1];
    char    err[ERRMAX];
};
@

<<struct Dest>>=
struct Dest {
    Conn    *conn;          /* allocated array */
    Conn    *connend;
    int nkid;

    long    oalarm;
    int naddrs;

    QLock   winlck;
    int winner;         /* index into conn[] */

    char    *nextaddr;
    char    addrlist[Maxcsreply];
};
@

<<function dialimpl>>=
/*
 *  the dialstring is of the form '[/net/]proto!dest'
 */
static int
dialimpl(char *dest, char *local, char *dir, int *cfdp)
{
    DS ds;
    int rv;
    char err[ERRMAX], alterr[ERRMAX];

    ds.local = local;
    ds.dir = dir;
    ds.cfdp = cfdp;

    _dial_string_parse(dest, &ds);
    if(ds.netdir)
        return csdial(&ds);

    ds.netdir = "/net";
    rv = csdial(&ds);
    if(rv >= 0)
        return rv;
    err[0] = '\0';
    errstr(err, sizeof err);
    if(strstr(err, "refused") != 0){
        werrstr("%s", err);
        return rv;
    }
    ds.netdir = "/net.alt";
    rv = csdial(&ds);
    if(rv >= 0)
        return rv;

    alterr[0] = 0;
    errstr(alterr, sizeof alterr);
    if(strstr(alterr, "translate") || strstr(alterr, "does not exist"))
        werrstr("%s", err);
    else
        werrstr("%s", alterr);
    return rv;
}
@

<<global _dial>>=
/*
 * the thread library can't cope with rfork(RFMEM|RFPROC),
 * so it must override this with a private version of dial.
 */
int (*_dial)(char *, char *, char *, int *) = dialimpl;
@

<<function dial>>=
int
dial(char *dest, char *local, char *dir, int *cfdp)
{
    return (*_dial)(dest, local, dir, cfdp);
}
@

<<function connsalloc>>=
static int
connsalloc(Dest *dp, int addrs)
{
    Conn *conn;

    free(dp->conn);
    dp->connend = nil;
    assert(addrs > 0);

    dp->conn = mallocz(addrs * sizeof *dp->conn, 1);
    if(dp->conn == nil)
        return -1;
    dp->connend = dp->conn + addrs;
    for(conn = dp->conn; conn < dp->connend; conn++)
        conn->cfd = conn->dfd = -1;
    return 0;
}
@

<<function freedest>>=
static void
freedest(Dest *dp)
{
    long oalarm;

    if (dp == nil)
        return;
    oalarm = dp->oalarm;
    free(dp->conn);
    free(dp);
    if (oalarm >= 0)
        alarm(oalarm);
}
@

<<function closeopenfd>>=
static void
closeopenfd(int *fdp)
{
    if (*fdp >= 0) {
        close(*fdp);
        *fdp = -1;
    }
}
@

<<function notedeath>>=
static void
notedeath(Dest *dp, char *exitsts)
{
    int i, n, pid;
    char *fields[5];            /* pid + 3 times + error */
    Conn *conn;

    for (i = 0; i < nelem(fields); i++)
        fields[i] = "";
    n = tokenize(exitsts, fields, nelem(fields));
    if (n < 4)
        return;
    pid = atoi(fields[0]);
    if (pid <= 0)
        return;
    for (conn = dp->conn; conn < dp->connend; conn++)
        if (conn->pid == pid && !conn->dead) {  /* it's one we know? */
            if (conn - dp->conn != dp->winner) {
                closeopenfd(&conn->dfd);
                closeopenfd(&conn->cfd);
            }
            strncpy(conn->err, fields[4], sizeof conn->err - 1);
            conn->err[sizeof conn->err - 1] = '\0';
            conn->dead = 1;
            return;
        }
    /* not a proc that we forked */
}
@

<<function outstandingprocs>>=
static int
outstandingprocs(Dest *dp)
{
    Conn *conn;

    for (conn = dp->conn; conn < dp->connend; conn++)
        if (!conn->dead)
            return 1;
    return 0;
}
@

<<function reap>>=
static int
reap(Dest *dp)
{
    char exitsts[2*ERRMAX];

    if (outstandingprocs(dp) && await(exitsts, sizeof exitsts) >= 0) {
        notedeath(dp, exitsts);
        return 0;
    }
    return -1;
}
@

<<function fillinds>>=
static int
fillinds(DS *ds, Dest *dp)
{
    Conn *conn;

    if (dp->winner < 0)
        return -1;
    conn = &dp->conn[dp->winner];
    if (ds->cfdp)
        *ds->cfdp = conn->cfd;
    if (ds->dir) {
        strncpy(ds->dir, conn->dir, NETPATHLEN);
        ds->dir[NETPATHLEN-1] = '\0';
    }
    return conn->dfd;
}
@

<<function connectwait>>=
static int
connectwait(Dest *dp, char *besterr)
{
    Conn *conn;

    /* wait for a winner or all attempts to time out */
    while (dp->winner < 0 && reap(dp) >= 0)
        ;

    /* kill all of our still-live kids & reap them */
    for (conn = dp->conn; conn < dp->connend; conn++)
        if (!conn->dead)
            postnote(PNPROC, conn->pid, "alarm");
    while (reap(dp) >= 0)
        ;

    /* rummage about and report some error string */
    for (conn = dp->conn; conn < dp->connend; conn++)
        if (conn - dp->conn != dp->winner && conn->dead &&
            conn->err[0]) {
            strncpy(besterr, conn->err, ERRMAX-1);
            besterr[ERRMAX-1] = '\0';
            break;
        }
    return dp->winner;
}
@

<<function parsecs>>=
static int
parsecs(Dest *dp, char **clonep, char **destp)
{
    char *dest, *p;

    dest = strchr(dp->nextaddr, ' ');
    if(dest == nil) {
        p = strchr(dp->nextaddr, '\n');
        if(p)
            *p = '\0';
        werrstr("malformed clone cmd from cs `%s'", dp->nextaddr);
        if(p)
            *p = '\n';
        return -1;
    }
    *dest++ = '\0';
    p = strchr(dest, '\n');
    if(p == nil)
        return -1;
    *p++ = '\0';
    *clonep = dp->nextaddr;
    *destp = dest;
    dp->nextaddr = p;       /* advance to next line */
    return 0;
}
@

<<function pickuperr>>=
static void
pickuperr(char *besterr, char *err)
{
    err[0] = '\0';
    errstr(err, ERRMAX);
    if(strstr(err, "does not exist") == 0)
        strcpy(besterr, err);
}
@

<<function catcher>>=
static int
catcher(void *, char *s)
{
    return strstr(s, "alarm") != nil;
}
@

<<function dialmulti>>=
/*
 * try all addresses in parallel and take the first one that answers;
 * this helps when systems have ip v4 and v6 addresses but are
 * only reachable from here on one (or some) of them.
 */
static int
dialmulti(DS *ds, Dest *dp)
{
    int rv, kid, kidme;
    char *clone, *dest;
    char besterr[ERRMAX];

    dp->winner = -1;
    dp->nkid = 0;
    while(dp->winner < 0 && *dp->nextaddr != '\0' &&
        parsecs(dp, &clone, &dest) >= 0) {
        kidme = dp->nkid++;     /* make private copy on stack */
        kid = rfork(RFPROC|RFMEM);  /* spin off a call attempt */
        if (kid < 0)
            --dp->nkid;
        else if (kid == 0) {
            char err[ERRMAX];

            /* only in kid, to avoid atnotify callbacks in parent */
            atnotify(catcher, 1);

            *besterr = '\0';
            rv = call(clone, dest, ds, dp, &dp->conn[kidme]);
            if(rv < 0)
                pickuperr(besterr, err);
            _exits(besterr);    /* avoid atexit callbacks */
        }
    }
    *besterr = '\0';
    rv = connectwait(dp, besterr);
    if(rv < 0)
        werrstr("%s", (*besterr? besterr: "unknown error"));
    return rv;
}
@

<<function csdial (9sys/dial.c)>>=
static int
csdial(DS *ds)
{
    int n, fd, rv, addrs, bleft;
    char c;
    char *addrp, *clone2, *dest;
    char buf[Maxstring], clone[Maxpath], err[ERRMAX], besterr[ERRMAX];
    Dest *dp;

    werrstr("");
    dp = mallocz(sizeof *dp, 1);
    if(dp == nil)
        return -1;
    dp->winner = -1;
    dp->oalarm = alarm(0);
    if (connsalloc(dp, 1) < 0) {        /* room for a single conn. */
        freedest(dp);
        return -1;
    }

    /*
     *  open connection server
     */
    snprint(buf, sizeof(buf), "%s/cs", ds->netdir);
    fd = open(buf, ORDWR);
    if(fd < 0){
        /* no connection server, don't translate */
        snprint(clone, sizeof(clone), "%s/%s/clone", ds->netdir, ds->proto);
        rv = call(clone, ds->rem, ds, dp, &dp->conn[0]);
        fillinds(ds, dp);
        freedest(dp);
        return rv;
    }

    /*
     *  ask connection server to translate
     *  e.g., net!cs.bell-labs.com!smtp
     */
    snprint(buf, sizeof(buf), "%s!%s", ds->proto, ds->rem);
    if(write(fd, buf, strlen(buf)) < 0){
        close(fd);
        freedest(dp);
        return -1;
    }

    /*
     *  read all addresses from the connection server:
     *  /net/tcp/clone 135.104.9.78!25
     *  /net/tcp/clone 2620:0:dc0:1805::29!25
     *
     *  assumes that we'll get one record per read.
     */
    seek(fd, 0, 0);
    addrs = 0;
    addrp = dp->nextaddr = dp->addrlist;
    bleft = sizeof dp->addrlist - 2;    /* 2 is room for \n\0 */
    while(bleft > 0 && (n = read(fd, addrp, bleft)) > 0) {
        if (addrp[n-1] != '\n')
            addrp[n++] = '\n';
        addrs++;
        addrp += n;
        bleft -= n;
    }
    *addrp = '\0';

    /*
     * if we haven't read all of cs's output, assume the last line might
     * have been truncated and ignore it.  we really don't expect this
     * to happen.
     */
    if (addrs > 0 && bleft <= 0 && read(fd, &c, 1) == 1)
        addrs--;
    close(fd);

    *besterr = 0;
    rv = -1;                /* pessimistic default */
    dp->naddrs = addrs;
    if (addrs == 0)
        werrstr("no address to dial");
    else if (addrs == 1) {
        /* common case: dial one address without forking */
        if (parsecs(dp, &clone2, &dest) >= 0 &&
            (rv = call(clone2, dest, ds, dp, &dp->conn[0])) < 0) {
            pickuperr(besterr, err);
            werrstr("%s", besterr);
        }
    } else if (connsalloc(dp, addrs) >= 0)
        rv = dialmulti(ds, dp);

    /* fill in results */
    if (rv >= 0 && dp->winner >= 0)
        rv = fillinds(ds, dp);

    freedest(dp);
    return rv;
}
@

<<function call (9sys/dial.c)>>=
static int
call(char *clone, char *dest, DS *ds, Dest *dp, Conn *conn)
{
    int fd, cfd, n, calleralarm, oalarm;
    char cname[Maxpath], name[Maxpath], data[Maxpath], *p;

    /* because cs is in a different name space, replace the mount point */
    if(*clone == '/'){
        p = strchr(clone+1, '/');
        if(p == nil)
            p = clone;
        else 
            p++;
    } else
        p = clone;
    snprint(cname, sizeof cname, "%s/%s", ds->netdir, p);

    conn->pid = getpid();
    conn->cfd = cfd = open(cname, ORDWR);
    if(cfd < 0)
        return -1;

    /* get directory name */
    n = read(cfd, name, sizeof(name)-1);
    if(n < 0){
        closeopenfd(&conn->cfd);
        return -1;
    }
    name[n] = 0;
    for(p = name; *p == ' '; p++)
        ;
    snprint(name, sizeof(name), "%ld", strtoul(p, 0, 0));
    p = strrchr(cname, '/');
    *p = 0;
    if(ds->dir)
        snprint(conn->dir, NETPATHLEN, "%s/%s", cname, name);
    snprint(data, sizeof(data), "%s/%s/data", cname, name);

    /* should be no alarm pending now; re-instate caller's alarm, if any */
    calleralarm = dp->oalarm > 0;
    if (calleralarm)
        alarm(dp->oalarm);
    else if (dp->naddrs > 1)    /* in a sub-process? */
        alarm(Maxconnms);

    /* connect */
    if(ds->local)
        snprint(name, sizeof(name), "connect %s %s", dest, ds->local);
    else
        snprint(name, sizeof(name), "connect %s", dest);
    if(write(cfd, name, strlen(name)) < 0){
        closeopenfd(&conn->cfd);
        return -1;
    }

    oalarm = alarm(0);  /* don't let alarm interrupt critical section */
    if (calleralarm)
        dp->oalarm = oalarm;    /* time has passed, so update user's */

    /* open data connection */
    conn->dfd = fd = open(data, ORDWR);
    if(fd < 0){
        closeopenfd(&conn->cfd);
        alarm(dp->oalarm);
        return -1;
    }
    if(ds->cfdp == nil)
        closeopenfd(&conn->cfd);

    n = conn - dp->conn;
    if (dp->winner < 0) {
        qlock(&dp->winlck);
        if (dp->winner < 0 && conn < dp->connend)
            dp->winner = n;
        qunlock(&dp->winlck);
    }
    alarm(calleralarm? dp->oalarm: 0);
    return fd;
}
@

<<function _dial_string_parse (9sys/dial.c)>>=
/*
 *  parse a dial string
 */
static void
_dial_string_parse(char *str, DS *ds)
{
    char *p, *p2;

    strncpy(ds->buf, str, Maxstring);
    ds->buf[Maxstring-1] = 0;

    p = strchr(ds->buf, '!');
    if(p == 0) {
        ds->netdir = 0;
        ds->proto = "net";
        ds->rem = ds->buf;
    } else {
        if(*ds->buf != '/' && *ds->buf != '#'){
            ds->netdir = 0;
            ds->proto = ds->buf;
        } else {
            /* expecting /net.alt/tcp!foo or #I1/tcp!foo */
            for(p2 = p; p2 > ds->buf && *p2 != '/'; p2--)
                ;
            *p2++ = 0;
            ds->netdir = ds->buf;
            ds->proto = p2;
        }
        *p = 0;
        ds->rem = p + 1;
    }
}
@


%-------------------------------------------------------------

<<9sys/dial.c>>=
/*
 * dial - connect to a service (parallel version)
 */
#include <u.h>
#include <libc.h>

typedef struct Conn Conn;
typedef struct Dest Dest;
typedef struct DS DS;

<<enum _anon_ (9sys/dial.c)>>

<<struct DS (9sys/dial.c)>>

<<struct Conn>>
<<struct Dest>>

static int  call(char*, char*, DS*, Dest*, Conn*);
static int  csdial(DS*);
static void _dial_string_parse(char*, DS*);


<<function dialimpl>>

<<global _dial>>

<<function dial>>

<<function connsalloc>>

<<function freedest>>

<<function closeopenfd>>

<<function notedeath>>

<<function outstandingprocs>>

<<function reap>>

<<function fillinds>>

<<function connectwait>>

<<function parsecs>>

<<function pickuperr>>

<<function catcher>>

<<function dialmulti>>

<<function csdial (9sys/dial.c)>>

<<function call (9sys/dial.c)>>

<<function _dial_string_parse (9sys/dial.c)>>
@


\subsection*{[[9sys/dirfstat.c]]}

<<enum _anon_ (9sys/dirfstat.c)>>=
enum
{
    DIRSIZE = STATFIXLEN + 16 * 4       /* enough for encoded stat buf + some reasonable strings */
};
@

<<function dirfstat>>=
Dir*
dirfstat(int fd)
{
    Dir *d;
    uchar *buf;
    int n, nd, i;

    nd = DIRSIZE;
    for(i=0; i<2; i++){ /* should work by the second try */
        d = malloc(sizeof(Dir) + BIT16SZ + nd);
        if(d == nil)
            return nil;
        buf = (uchar*)&d[1];
        n = fstat(fd, buf, BIT16SZ+nd);
        if(n < BIT16SZ){
            free(d);
            return nil;
        }
        nd = GBIT16(buf);   /* upper bound on size of Dir + strings */
        if(nd <= n){
            convM2D(buf, n, d, (char*)&d[1]);
            return d;
        }
        /* else sizeof(Dir)+BIT16SZ+nd is plenty */
        free(d);
    }
    return nil;
}
@


%-------------------------------------------------------------

<<9sys/dirfstat.c>>=
#include <u.h>
#include <libc.h>
#include <fcall.h>

<<enum _anon_ (9sys/dirfstat.c)>>

<<function dirfstat>>
@


\subsection*{[[9sys/dirfwstat.c]]}

<<function dirfwstat>>=
int
dirfwstat(int fd, Dir *d)
{
    uchar *buf;
    int r;

    r = sizeD2M(d);
    buf = malloc(r);
    if(buf == nil)
        return -1;
    convD2M(d, buf, r);
    r = fwstat(fd, buf, r);
    free(buf);
    return r;
}
@


%-------------------------------------------------------------

<<9sys/dirfwstat.c>>=
#include <u.h>
#include <libc.h>
#include <fcall.h>

<<function dirfwstat>>
@


\subsection*{[[9sys/dirmodefmt.c]]}

<<global modes>>=
static char *modes[] =
{
    "---",
    "--x",
    "-w-",
    "-wx",
    "r--",
    "r-x",
    "rw-",
    "rwx",
};
@

<<function rwx>>=
static void
rwx(long m, char *s)
{
    strncpy(s, modes[m], 3);
}
@

<<function dirmodefmt>>=
int
dirmodefmt(Fmt *f)
{
    static char buf[16];
    ulong m;

    m = va_arg(f->args, ulong);

    if(m & DMDIR)
        buf[0]='d';
    else if(m & DMAPPEND)
        buf[0]='a';
    else if(m & DMAUTH)
        buf[0]='A';
    else
        buf[0]='-';
    if(m & DMEXCL)
        buf[1]='l';
    else
        buf[1]='-';
    rwx((m>>6)&7, buf+2);
    rwx((m>>3)&7, buf+5);
    rwx((m>>0)&7, buf+8);
    buf[11] = 0;
    return fmtstrcpy(f, buf);
}
@


%-------------------------------------------------------------

<<9sys/dirmodefmt.c>>=
#include <u.h>
#include <libc.h>
#include <fcall.h>

<<global modes>>

<<function rwx>>

<<function dirmodefmt>>
@


\subsection*{[[9sys/dirread.c]]}

<<function dirpackage>>=
static
long
dirpackage(uchar *buf, long ts, Dir **d)
{
    char *s;
    long ss, i, n, nn, m;

    *d = nil;
    if(ts <= 0)
        return 0;

    /*
     * first find number of all stats, check they look like stats, & size all associated strings
     */
    ss = 0;
    n = 0;
    for(i = 0; i < ts; i += m){
        m = BIT16SZ + GBIT16(&buf[i]);
        if(statcheck(&buf[i], m) < 0)
            break;
        ss += m;
        n++;
    }

    if(i != ts)
        return -1;

    *d = malloc(n * sizeof(Dir) + ss);
    if(*d == nil)
        return -1;

    /*
     * then convert all buffers
     */
    s = (char*)*d + n * sizeof(Dir);
    nn = 0;
    for(i = 0; i < ts; i += m){
        m = BIT16SZ + GBIT16((uchar*)&buf[i]);
        if(nn >= n || convM2D(&buf[i], m, *d + nn, s) != m){
            free(*d);
            *d = nil;
            return -1;
        }
        nn++;
        s += m;
    }

    return nn;
}
@

<<function dirread>>=
long
dirread(int fd, Dir **d)
{
    uchar *buf;
    long ts;

    buf = malloc(DIRMAX);
    if(buf == nil)
        return -1;
    ts = read(fd, buf, DIRMAX);
    if(ts >= 0)
        ts = dirpackage(buf, ts, d);
    free(buf);
    return ts;
}
@

<<function dirreadall>>=
long
dirreadall(int fd, Dir **d)
{
    uchar *buf, *nbuf;
    long n, ts;

    buf = nil;
    ts = 0;
    for(;;){
        nbuf = realloc(buf, ts+DIRMAX);
        if(nbuf == nil){
            free(buf);
            return -1;
        }
        buf = nbuf;
        n = read(fd, buf+ts, DIRMAX);
        if(n <= 0)
            break;
        ts += n;
    }
    if(ts >= 0)
        ts = dirpackage(buf, ts, d);
    free(buf);
    if(ts == 0 && n < 0)
        return -1;
    return ts;
}
@


%-------------------------------------------------------------

<<9sys/dirread.c>>=
#include <u.h>
#include <libc.h>
#include <fcall.h>

<<function dirpackage>>

<<function dirread>>

<<function dirreadall>>
@


\subsection*{[[9sys/dirstat.c]]}

<<enum _anon_ (9sys/dirstat.c)>>=
enum
{
    DIRSIZE = STATFIXLEN + 16 * 4       /* enough for encoded stat buf + some reasonable strings */
};
@

<<function dirstat>>=
Dir*
dirstat(char *name)
{
    Dir *d;
    uchar *buf;
    int n, nd, i;

    nd = DIRSIZE;
    for(i=0; i<2; i++){ /* should work by the second try */
        d = malloc(sizeof(Dir) + BIT16SZ + nd);
        if(d == nil)
            return nil;
        buf = (uchar*)&d[1];
        n = stat(name, buf, BIT16SZ+nd);
        if(n < BIT16SZ){
            free(d);
            return nil;
        }
        nd = GBIT16((uchar*)buf);   /* upper bound on size of Dir + strings */
        if(nd <= n){
            convM2D(buf, n, d, (char*)&d[1]);
            return d;
        }
        /* else sizeof(Dir)+BIT16SZ+nd is plenty */
        free(d);
    }
    return nil;
}
@


%-------------------------------------------------------------

<<9sys/dirstat.c>>=
#include <u.h>
#include <libc.h>
#include <fcall.h>

<<enum _anon_ (9sys/dirstat.c)>>

<<function dirstat>>
@


\subsection*{[[9sys/dirwstat.c]]}

<<function dirwstat>>=
int
dirwstat(char *name, Dir *d)
{
    uchar *buf;
    int r;

    r = sizeD2M(d);
    buf = malloc(r);
    if(buf == nil)
        return -1;
    convD2M(d, buf, r);
    r = wstat(name, buf, r);
    free(buf);
    return r;
}
@


%-------------------------------------------------------------

<<9sys/dirwstat.c>>=
#include <u.h>
#include <libc.h>
#include <fcall.h>

<<function dirwstat>>
@


\subsection*{[[9sys/fcallfmt.c]]}

<<constant QIDFMT>>=
#define QIDFMT  "(%.16llux %lud %s)"
@

<<function fcallfmt>>=
int
fcallfmt(Fmt *fmt)
{
    Fcall *f;
    int fid, type, tag, i;
    char buf[512], tmp[200];
    char *p, *e;
    Dir *d;
    Qid *q;

    e = buf+sizeof(buf);
    f = va_arg(fmt->args, Fcall*);
    type = f->type;
    fid = f->fid;
    tag = f->tag;
    switch(type){
    case Tversion:  /* 100 */
        seprint(buf, e, "Tversion tag %ud msize %ud version '%s'", tag, f->msize, f->version);
        break;
    case Rversion:
        seprint(buf, e, "Rversion tag %ud msize %ud version '%s'", tag, f->msize, f->version);
        break;
    case Tauth: /* 102 */
        seprint(buf, e, "Tauth tag %ud afid %d uname %s aname %s", tag,
            f->afid, f->uname, f->aname);
        break;
    case Rauth:
        seprint(buf, e, "Rauth tag %ud qid " QIDFMT, tag,
            f->aqid.path, f->aqid.vers, qidtype(tmp, f->aqid.type));
        break;
    case Tattach:   /* 104 */
        seprint(buf, e, "Tattach tag %ud fid %d afid %d uname %s aname %s", tag,
            fid, f->afid, f->uname, f->aname);
        break;
    case Rattach:
        seprint(buf, e, "Rattach tag %ud qid " QIDFMT, tag,
            f->qid.path, f->qid.vers, qidtype(tmp, f->qid.type));
        break;
    case Rerror:    /* 107; 106 (Terror) illegal */
        seprint(buf, e, "Rerror tag %ud ename %s", tag, f->ename);
        break;
    case Tflush:    /* 108 */
        seprint(buf, e, "Tflush tag %ud oldtag %ud", tag, f->oldtag);
        break;
    case Rflush:
        seprint(buf, e, "Rflush tag %ud", tag);
        break;
    case Twalk: /* 110 */
        p = seprint(buf, e, "Twalk tag %ud fid %d newfid %d nwname %d ", tag, fid, f->newfid, f->nwname);
        if(f->nwname <= MAXWELEM)
            for(i=0; i<f->nwname; i++)
                p = seprint(p, e, "%d:%s ", i, f->wname[i]);
        break;
    case Rwalk:
        p = seprint(buf, e, "Rwalk tag %ud nwqid %ud ", tag, f->nwqid);
        if(f->nwqid <= MAXWELEM)
            for(i=0; i<f->nwqid; i++){
                q = &f->wqid[i];
                p = seprint(p, e, "%d:" QIDFMT " ", i,
                    q->path, q->vers, qidtype(tmp, q->type));
            }
        break;
    case Topen: /* 112 */
        seprint(buf, e, "Topen tag %ud fid %ud mode %d", tag, fid, f->mode);
        break;
    case Ropen:
        seprint(buf, e, "Ropen tag %ud qid " QIDFMT " iounit %ud ", tag,
            f->qid.path, f->qid.vers, qidtype(tmp, f->qid.type), f->iounit);
        break;
    case Tcreate:   /* 114 */
        seprint(buf, e, "Tcreate tag %ud fid %ud name %s perm %M mode %d", tag, fid, f->name, (ulong)f->perm, f->mode);
        break;
    case Rcreate:
        seprint(buf, e, "Rcreate tag %ud qid " QIDFMT " iounit %ud ", tag,
            f->qid.path, f->qid.vers, qidtype(tmp, f->qid.type), f->iounit);
        break;
    case Tread: /* 116 */
        seprint(buf, e, "Tread tag %ud fid %d offset %lld count %ud",
            tag, fid, f->offset, f->count);
        break;
    case Rread:
        p = seprint(buf, e, "Rread tag %ud count %ud ", tag, f->count);
            dumpsome(p, e, f->data, f->count);
        break;
    case Twrite:    /* 118 */
        p = seprint(buf, e, "Twrite tag %ud fid %d offset %lld count %ud ",
            tag, fid, f->offset, f->count);
        dumpsome(p, e, f->data, f->count);
        break;
    case Rwrite:
        seprint(buf, e, "Rwrite tag %ud count %ud", tag, f->count);
        break;
    case Tclunk:    /* 120 */
        seprint(buf, e, "Tclunk tag %ud fid %ud", tag, fid);
        break;
    case Rclunk:
        seprint(buf, e, "Rclunk tag %ud", tag);
        break;
    case Tremove:   /* 122 */
        seprint(buf, e, "Tremove tag %ud fid %ud", tag, fid);
        break;
    case Rremove:
        seprint(buf, e, "Rremove tag %ud", tag);
        break;
    case Tstat: /* 124 */
        seprint(buf, e, "Tstat tag %ud fid %ud", tag, fid);
        break;
    case Rstat:
        p = seprint(buf, e, "Rstat tag %ud ", tag);
        if(f->nstat > sizeof tmp)
            seprint(p, e, " stat(%d bytes)", f->nstat);
        else{
            d = (Dir*)tmp;
            convM2D(f->stat, f->nstat, d, (char*)(d+1));
            seprint(p, e, " stat ");
            fdirconv(p+6, e, d);
        }
        break;
    case Twstat:    /* 126 */
        p = seprint(buf, e, "Twstat tag %ud fid %ud", tag, fid);
        if(f->nstat > sizeof tmp)
            seprint(p, e, " stat(%d bytes)", f->nstat);
        else{
            d = (Dir*)tmp;
            convM2D(f->stat, f->nstat, d, (char*)(d+1));
            seprint(p, e, " stat ");
            fdirconv(p+6, e, d);
        }
        break;
    case Rwstat:
        seprint(buf, e, "Rwstat tag %ud", tag);
        break;
    default:
        seprint(buf, e,  "unknown type %d", type);
    }
    return fmtstrcpy(fmt, buf);
}
@

<<function qidtype>>=
static char*
qidtype(char *s, uchar t)
{
    char *p;

    p = s;
    if(t & QTDIR)
        *p++ = 'd';
    if(t & QTAPPEND)
        *p++ = 'a';
    if(t & QTEXCL)
        *p++ = 'l';
    if(t & QTAUTH)
        *p++ = 'A';
    *p = '\0';
    return s;
}
@

<<function dirfmt>>=
int
dirfmt(Fmt *fmt)
{
    char buf[160];

    fdirconv(buf, buf+sizeof buf, va_arg(fmt->args, Dir*));
    return fmtstrcpy(fmt, buf);
}
@

<<function fdirconv>>=
static void
fdirconv(char *buf, char *e, Dir *d)
{
    char tmp[16];

    seprint(buf, e, "'%s' '%s' '%s' '%s' "
        "q " QIDFMT " m %#luo "
        "at %ld mt %ld l %lld "
        "t %d d %d",
            d->name, d->uid, d->gid, d->muid,
            d->qid.path, d->qid.vers, qidtype(tmp, d->qid.type), d->mode,
            d->atime, d->mtime, d->length,
            d->type, d->dev);
}
@

<<constant DUMPL>>=
/*
 * dump out count (or DUMPL, if count is bigger) bytes from
 * buf to ans, as a string if they are all printable,
 * else as a series of hex bytes
 */
#define DUMPL 64
@

<<function dumpsome>>=
static uint
dumpsome(char *ans, char *e, char *buf, long count)
{
    int i, printable;
    char *p;

    if(buf == nil){
        seprint(ans, e, "<no data>");
        return strlen(ans);
    }
    printable = 1;
    if(count > DUMPL)
        count = DUMPL;
    for(i=0; i<count && printable; i++)
        if((buf[i]<32 && buf[i] !='\n' && buf[i] !='\t') || (uchar)buf[i]>127)
            printable = 0;
    p = ans;
    *p++ = '\'';
    if(printable){
        if(count > e-p-2)
            count = e-p-2;
        memmove(p, buf, count);
        p += count;
    }else{
        if(2*count > e-p-2)
            count = (e-p-2)/2;
        for(i=0; i<count; i++){
            if(i>0 && i%4==0)
                *p++ = ' ';
            sprint(p, "%2.2ux", (uchar)buf[i]);
            p += 2;
        }
    }
    *p++ = '\'';
    *p = 0;
    return p - ans;
}
@


%-------------------------------------------------------------

<<9sys/fcallfmt.c>>=
#include <u.h>
#include <libc.h>
#include <fcall.h>

static uint dumpsome(char*, char*, char*, long);
static void fdirconv(char*, char*, Dir*);
static char *qidtype(char*, uchar);

<<constant QIDFMT>>

<<function fcallfmt>>

<<function qidtype>>

<<function dirfmt>>

<<function fdirconv>>

<<constant DUMPL>>

<<function dumpsome>>
@


\subsection*{[[9sys/fork.c]]}

<<function fork>>=
int
fork(void)
{
    return rfork(RFPROC|RFFDG|RFREND);
}
@


%-------------------------------------------------------------

<<9sys/fork.c>>=
#include <u.h>
#include <libc.h>

<<function fork>>
@


\subsection*{[[9sys/getenv.c]]}

<<function getenv>>=
char*
getenv(char *name)
{
    int r, f;
    long s;
    char *ans;
    char *p, *ep, ename[100];

    if(strchr(name, '/') != nil)
        return nil;
    snprint(ename, sizeof ename, "/env/%s", name);
    if(strcmp(ename+5, name) != 0)
        return nil;
    f = open(ename, OREAD);
    if(f < 0)
        return 0;
    s = seek(f, 0, 2);
    ans = malloc(s+1);
    if(ans) {
        setmalloctag(ans, getcallerpc(&name));
        seek(f, 0, 0);
        r = read(f, ans, s);
        if(r >= 0) {
            ep = ans + s - 1;
            for(p = ans; p < ep; p++)
                if(*p == '\0')
                    *p = ' ';
            ans[s] = '\0';
        }
    }
    close(f);
    return ans;
}
@


%-------------------------------------------------------------

<<9sys/getenv.c>>=
#include <u.h>
#include <libc.h>

<<function getenv>>
@


\subsection*{[[9sys/getnetconninfo.c]]}

<<global unknown>>=
static char *unknown = "???";
@

<<function getendpoint>>=
static void
getendpoint(char *dir, char *file, char **sysp, char **servp)
{
    int fd, n;
    char buf[128];
    char *sys, *serv;

    sys = serv = 0;

    snprint(buf, sizeof buf, "%s/%s", dir, file);
    fd = open(buf, OREAD);
    if(fd >= 0){
        n = read(fd, buf, sizeof(buf)-1);
        if(n>0){
            buf[n-1] = 0;
            serv = strchr(buf, '!');
            if(serv){
                *serv++ = 0;
                serv = strdup(serv);
            }
            sys = strdup(buf);
        }
        close(fd);
    }
    if(serv == 0)
        serv = unknown;
    if(sys == 0)
        sys = unknown;
    *servp = serv;
    *sysp = sys;
}
@

<<function getnetconninfo>>=
NetConnInfo*
getnetconninfo(char *dir, int fd)
{
    NetConnInfo *nci;
    char *cp;
    Dir *d;
    char spec[10];
    char path[128];
    char netname[128], *p;

    /* get a directory address via fd */
    if(dir == nil || *dir == 0){
        if(fd2path(fd, path, sizeof(path)) < 0)
            return nil;
        cp = strrchr(path, '/');
        if(cp == nil)
            return nil;
        *cp = 0;
        dir = path;
    }

    nci = mallocz(sizeof *nci, 1);
    if(nci == nil)
        return nil;

    /* copy connection directory */
    nci->dir = strdup(dir);
    if(nci->dir == nil)
        goto err;

    /* get netroot */
    nci->root = strdup(dir);
    if(nci->root == nil)
        goto err;
    cp = strchr(nci->root+1, '/');
    if(cp == nil)
        goto err;
    *cp = 0;

    /* figure out bind spec */
    d = dirstat(nci->dir);
    if(d != nil){
        sprint(spec, "#%C%d", d->type, d->dev);
        nci->spec = strdup(spec);
    }
    if(nci->spec == nil)
        nci->spec = unknown;
    free(d);

    /* get the two end points */
    getendpoint(nci->dir, "local", &nci->lsys, &nci->lserv);
    if(nci->lsys == nil || nci->lserv == nil)
        goto err;
    getendpoint(nci->dir, "remote", &nci->rsys, &nci->rserv);
    if(nci->rsys == nil || nci->rserv == nil)
        goto err;

    strecpy(netname, netname+sizeof netname, nci->dir);
    if((p = strrchr(netname, '/')) != nil)
        *p = 0;
    if(strncmp(netname, "/net/", 5) == 0)
        memmove(netname, netname+5, strlen(netname+5)+1);
    nci->laddr = smprint("%s!%s!%s", netname, nci->lsys, nci->lserv);
    nci->raddr = smprint("%s!%s!%s", netname, nci->rsys, nci->rserv);
    if(nci->laddr == nil || nci->raddr == nil)
        goto err;
    return nci;
err:
    freenetconninfo(nci);
    return nil;
}
@

<<function xfree>>=
static void
xfree(char *x)
{
    if(x == nil || x == unknown)
        return;
    free(x);
}
@

<<function freenetconninfo>>=
void
freenetconninfo(NetConnInfo *nci)
{
    if(nci == nil)
        return;
    xfree(nci->root);
    xfree(nci->dir);
    xfree(nci->spec);
    xfree(nci->lsys);
    xfree(nci->lserv);
    xfree(nci->rsys);
    xfree(nci->rserv);
    xfree(nci->laddr);
    xfree(nci->raddr);
    free(nci);
}
@


%-------------------------------------------------------------

<<9sys/getnetconninfo.c>>=
#include <u.h>
#include <libc.h>

<<global unknown>>

<<function getendpoint>>

<<function getnetconninfo>>

<<function xfree>>

<<function freenetconninfo>>
@


\subsection*{[[9sys/getpid.c]]}

<<function getpid>>=
int
getpid(void)
{
    char b[20];
    int f;

    memset(b, 0, sizeof(b));
    f = open("#c/pid", 0);
    if(f >= 0) {
        read(f, b, sizeof(b));
        close(f);
    }
    return atol(b);
}
@


%-------------------------------------------------------------

<<9sys/getpid.c>>=
#include    <u.h>
#include    <libc.h>

<<function getpid>>
@


\subsection*{[[9sys/getppid.c]]}

<<function getppid>>=
int
getppid(void)
{
    char b[20];
    int f;

    memset(b, 0, sizeof(b));
    f = open("/dev/ppid", 0);
    if(f >= 0) {
        read(f, b, sizeof(b));
        close(f);
    }
    return atol(b);
}
@


%-------------------------------------------------------------

<<9sys/getppid.c>>=
#include    <u.h>
#include    <libc.h>

<<function getppid>>
@


\subsection*{[[9sys/getwd.c]]}

<<function getwd>>=
char*
getwd(char *buf, int nbuf)
{
    int n, fd;

    fd = open(".", OREAD);
    if(fd < 0)
        return nil;
    n = fd2path(fd, buf, nbuf);
    close(fd);
    if(n < 0)
        return nil;
    return buf;
}
@


%-------------------------------------------------------------

<<9sys/getwd.c>>=
#include <u.h>
#include <libc.h>

static char *nsgetwd(char*, int);

<<function getwd>>
@


\subsection*{[[9sys/iounit.c]]}

<<function iounit>>=
/*
 * Format:
  3 r  M    4 (0000000000457def 11 00)   8192      512 /rc/lib/rcmain
 */

int
iounit(int fd)
{
    int i, cfd;
    char buf[128], *args[10];

    snprint(buf, sizeof buf, "#d/%dctl", fd);
    cfd = open(buf, OREAD);
    if(cfd < 0)
        return 0;
    i = read(cfd, buf, sizeof buf-1);
    close(cfd);
    if(i <= 0)
        return 0;
    buf[i] = '\0';
    if(tokenize(buf, args, nelem(args)) != nelem(args))
        return 0;
    return atoi(args[7]);
}
@


%-------------------------------------------------------------

<<9sys/iounit.c>>=
#include <u.h>
#include <libc.h>

<<function iounit>>
@


\subsection*{[[9sys/nsec.c]]}

<<global order>>=
static uvlong order = 0x0001020304050607ULL;
@

<<function be2vlong>>=
static void
be2vlong(vlong *to, uchar *f)
{
    uchar *t, *o;
    int i;

    t = (uchar*)to;
    o = (uchar*)&order;
    for(i = 0; i < sizeof order; i++)
        t[o[i]] = f[i];
}
@

<<global fd>>=
static int fd = -1;
@

<<global fds>>=
static struct {
    int pid;
    int fd;
} fds[64];
@

<<function nsec>>=
vlong
nsec(void)
{
    uchar b[8];
    vlong t;
    int pid, i, f, tries;

    /*
     * Threaded programs may have multiple procs
     * with different fd tables, so we may need to open
     * /dev/bintime on a per-pid basis
     */

    /* First, look if we've opened it for this particular pid */
    if((pid = _tos->pid) == 0)      /* 9vx bug, perhaps? */
        _tos->pid = pid = getpid();
    do{
        f = -1;
        for(i = 0; i < nelem(fds); i++)
            if(fds[i].pid == pid){
                f = fds[i].fd;
                break;
            }
        tries = 0;
        if(f < 0){
            /* If it's not open for this pid, try the global pid */
            if(fd >= 0)
                f = fd;
            else{
                /* must open */
                if((f = open("/dev/bintime", OREAD|OCEXEC)) < 0)
                    return 0;
                fd = f;
                for(i = 0; i < nelem(fds); i++)
                    if(fds[i].pid == pid || fds[i].pid == 0){
                        fds[i].pid = pid;
                        fds[i].fd = f;
                        break;
                    }
            }
        }
        if(pread(f, b, sizeof b, 0) == sizeof b){
            be2vlong(&t, b);
            return t;
        }
        close(f);
        if(i < nelem(fds))
            fds[i].fd = -1;
    }while(tries++ == 0);   /* retry once */
    USED(tries);
    return 0;
}
@


%-------------------------------------------------------------

<<9sys/nsec.c>>=
#include <u.h>
#include <libc.h>
#include <tos.h>

<<global order>>

<<function be2vlong>>

<<global fd>>
<<global fds>>

<<function nsec>>
@


\subsection*{[[9sys/nulldir.c]]}

<<function nulldir>>=
void
nulldir(Dir *d)
{
    memset(d, ~0, sizeof(Dir));
    d->name = d->uid = d->gid = d->muid = "";
}
@


%-------------------------------------------------------------

<<9sys/nulldir.c>>=
#include <u.h>
#include <libc.h>

<<function nulldir>>
@


\subsection*{[[9sys/postnote.c]]}

<<function postnote>>=
int
postnote(int group, int pid, char *note)
{
    char file[128];
    int f, r;

    switch(group) {
    case PNPROC:
        sprint(file, "/proc/%d/note", pid);
        break;
    case PNGROUP:
        sprint(file, "/proc/%d/notepg", pid);
        break;
    default:
        return -1;
    }

    f = open(file, OWRITE);
    if(f < 0)
        return -1;

    r = strlen(note);
    if(write(f, note, r) != r) {
        close(f);
        return -1;
    }
    close(f);
    return 0;
}
@


%-------------------------------------------------------------

<<9sys/postnote.c>>=
#include <u.h>
#include <libc.h>

<<function postnote>>
@


\subsection*{[[9sys/privalloc.c]]}

<<global privlock (9sys/privalloc.c)>>=
static Lock privlock;
@

<<global privinit>>=
static int  privinit;
@

<<global privs>>=
static void **privs;
@

<<function privalloc>>=
void **
privalloc(void)
{
    void **p;
    int i;

    lock(&privlock);
    if(!privinit){
        privinit = 1;
        if(_nprivates){
            _privates[0] = 0;
            for(i = 1; i < _nprivates; i++)
                _privates[i] = &_privates[i - 1];
            privs = &_privates[i - 1];
        }
    }
    p = privs;
    if(p != nil){
        privs = *p;
        *p = nil;
    }
    unlock(&privlock);
    return p;
}
@

<<function privfree>>=
void
privfree(void **p)
{
    lock(&privlock);
    if(p != nil && privinit){
        *p = privs;
        privs = p;
    }
    unlock(&privlock);
}
@


%-------------------------------------------------------------

<<9sys/privalloc.c>>=
#include <u.h>
#include <libc.h>

<<global privlock (9sys/privalloc.c)>>
<<global privinit>>
<<global privs>>

extern void **_privates;
extern int  _nprivates;

<<function privalloc>>

<<function privfree>>
@


\subsection*{[[9sys/pushssl.c]]}

<<function pushssl>>=
/*
 * Since the SSL device uses decimal file descriptors to name channels,
 * it is impossible for a user-level file server to stand in for the kernel device.
 * Thus we hard-code #D rather than use /net/ssl.
 */

int
pushssl(int fd, char *alg, char *secin, char *secout, int *cfd)
{
    char buf[8];
    char dname[64];
    int n, data, ctl;

    ctl = open("#D/ssl/clone", ORDWR);
    if(ctl < 0)
        return -1;
    n = read(ctl, buf, sizeof(buf)-1);
    if(n < 0)
        goto error;
    buf[n] = 0;
    sprint(dname, "#D/ssl/%s/data", buf);
    data = open(dname, ORDWR);
    if(data < 0)
        goto error;
    if(fprint(ctl, "fd %d", fd) < 0 ||
       fprint(ctl, "secretin %s", secin) < 0 ||
       fprint(ctl, "secretout %s", secout) < 0 ||
       fprint(ctl, "alg %s", alg) < 0){
        close(data);
        goto error;
    }
    close(fd);
    if(cfd != 0)
        *cfd = ctl;
    else
        close(ctl);
    return data;
error:
    close(ctl);
    return -1;
}
@


%-------------------------------------------------------------

<<9sys/pushssl.c>>=
#include <u.h>
#include <libc.h>

<<function pushssl>>
@


\subsection*{[[9sys/pushtls.c]]}

<<enum _anon_ (9sys/pushtls.c)>>=
enum {
    TLSFinishedLen = 12,
    HFinished = 20,
};
@

<<function finished>>=
static int
finished(int hand, int isclient)
{
    int i, n;
    uchar buf[500], buf2[500];

    buf[0] = HFinished;
    buf[1] = TLSFinishedLen>>16;
    buf[2] = TLSFinishedLen>>8;
    buf[3] = TLSFinishedLen;
    n = TLSFinishedLen+4;

    for(i=0; i<2; i++){
        if(i==0)
            memmove(buf+4, "client finished", TLSFinishedLen);
        else
            memmove(buf+4, "server finished", TLSFinishedLen);
        if(isclient == 1-i){
            if(write(hand, buf, n) != n)
                return -1;
        }else{
            if(readn(hand, buf2, n) != n || memcmp(buf,buf2,n) != 0)
                return -1;
        }
    }
    return 1;
}
@

<<function pushtls>>=
// given a plain fd and secrets established beforehand, return encrypted connection
int
pushtls(int fd, char *hashalg, char *encalg, int isclient, char *secret, char *dir)
{
    char buf[8];
    char dname[64];
    int n, data, ctl, hand;

    // open a new filter; get ctl fd
    data = hand = -1;
    // /net/tls uses decimal file descriptors to name channels, hence a
    // user-level file server can't stand in for #a; may as well hard-code it.
    ctl = open("#a/tls/clone", ORDWR);
    if(ctl < 0)
        goto error;
    n = read(ctl, buf, sizeof(buf)-1);
    if(n < 0)
        goto error;
    buf[n] = 0;
    if(dir)
        sprint(dir, "#a/tls/%s", buf);

    // get application fd
    sprint(dname, "#a/tls/%s/data", buf);
    data = open(dname, ORDWR);
    if(data < 0)
        goto error;

    // get handshake fd
    sprint(dname, "#a/tls/%s/hand", buf);
    hand = open(dname, ORDWR);
    if(hand < 0)
        goto error;

    // speak a minimal handshake
    if(fprint(ctl, "fd %d 0x301", fd) < 0 ||
       fprint(ctl, "version 0x301") < 0 ||
       fprint(ctl, "secret %s %s %d %s", hashalg, encalg, isclient, secret) < 0 ||
       fprint(ctl, "changecipher") < 0 ||
       finished(hand, isclient) < 0 ||
       fprint(ctl, "opened") < 0){
        close(hand);
        hand = -1;
        goto error;
    }
    close(ctl);
    close(hand);
    close(fd);
    return data;

error:
    if(data>=0)
        close(data);
    if(ctl>=0)
        close(ctl);
    if(hand>=0)
        close(hand);
    return -1;
}
@


%-------------------------------------------------------------

<<9sys/pushtls.c>>=
#include <u.h>
#include <libc.h>
#include <mp.h>
#include <libsec.h>

<<enum _anon_ (9sys/pushtls.c)>>

<<function finished>>


<<function pushtls>>
@


\subsection*{[[9sys/putenv.c]]}

<<function putenv>>=
int
putenv(char *name, char *val)
{
    int f;
    char ename[100];
    long s;

    if(strchr(name, '/') != nil)
        return -1;
    snprint(ename, sizeof ename, "/env/%s", name);
    if(strcmp(ename+5, name) != 0)
        return -1;
    f = create(ename, OWRITE, 0664);
    if(f < 0)
        return -1;
    s = strlen(val);
    if(write(f, val, s) != s){
        close(f);
        return -1;
    }
    close(f);
    return 0;
}
@


%-------------------------------------------------------------

<<9sys/putenv.c>>=
#include <u.h>
#include <libc.h>

<<function putenv>>
@


\subsection*{[[9sys/qlock.c]]}

<<global ql>>=
static struct {
    QLp *p;
    QLp x[1024];
} ql = {
    ql.x
};
@

<<enum _anon_ (9sys/qlock.c)>>=
enum
{
    Queuing,
    QueuingR,
    QueuingW,
    Sleeping,
};
@

<<global _rendezvousp>>=
static void*    (*_rendezvousp)(void*, void*) = rendezvous;
@

<<function _qlockinit>>=
/* this gets called by the thread library ONLY to get us to use its rendezvous */
void
_qlockinit(void* (*r)(void*, void*))
{
    _rendezvousp = r;
}
@

<<function getqlp>>=
/* find a free shared memory location to queue ourselves in */
static QLp*
getqlp(void)
{
    QLp *p, *op;

    op = ql.p;
    for(p = op+1; ; p++){
        if(p == &ql.x[nelem(ql.x)])
            p = ql.x;
        if(p == op)
            abort();
        if(_tas(&(p->inuse)) == 0){
            ql.p = p;
            p->next = nil;
            break;
        }
    }
    return p;
}
@

<<function qlock>>=
void
qlock(QLock *q)
{
    QLp *p, *mp;

    lock(&q->lock);
    if(!q->locked){
        q->locked = 1;
        unlock(&q->lock);
        return;
    }


    /* chain into waiting list */
    mp = getqlp();
    p = q->tail;
    if(p == nil)
        q->head = mp;
    else
        p->next = mp;
    q->tail = mp;
    mp->state = Queuing;
    unlock(&q->lock);

    /* wait */
    while((*_rendezvousp)(mp, (void*)1) == (void*)~0)
        ;
    mp->inuse = 0;
}
@

<<function qunlock>>=
void
qunlock(QLock *q)
{
    QLp *p;

    lock(&q->lock);
    if (q->locked == 0)
        fprint(2, "qunlock called with qlock not held, from %#p\n",
            getcallerpc(&q));
    p = q->head;
    if(p != nil){
        /* wakeup head waiting process */
        q->head = p->next;
        if(q->head == nil)
            q->tail = nil;
        unlock(&q->lock);
        while((*_rendezvousp)(p, (void*)0x12345) == (void*)~0)
            ;
        return;
    }
    q->locked = 0;
    unlock(&q->lock);
}
@

<<function canqlock>>=
int
canqlock(QLock *q)
{
    if(!canlock(&q->lock))
        return 0;
    if(!q->locked){
        q->locked = 1;
        unlock(&q->lock);
        return 1;
    }
    unlock(&q->lock);
    return 0;
}
@

<<function rlock>>=
void
rlock(RWLock *q)
{
    QLp *p, *mp;

    lock(&q->lock);
    if(q->writer == 0 && q->head == nil){
        /* no writer, go for it */
        q->readers++;
        unlock(&q->lock);
        return;
    }

    mp = getqlp();
    p = q->tail;
    if(p == 0)
        q->head = mp;
    else
        p->next = mp;
    q->tail = mp;
    mp->next = nil;
    mp->state = QueuingR;
    unlock(&q->lock);

    /* wait in kernel */
    while((*_rendezvousp)(mp, (void*)1) == (void*)~0)
        ;
    mp->inuse = 0;
}
@

<<function canrlock>>=
int
canrlock(RWLock *q)
{
    lock(&q->lock);
    if (q->writer == 0 && q->head == nil) {
        /* no writer; go for it */
        q->readers++;
        unlock(&q->lock);
        return 1;
    }
    unlock(&q->lock);
    return 0;
}
@

<<function runlock>>=
void
runlock(RWLock *q)
{
    QLp *p;

    lock(&q->lock);
    if(q->readers <= 0)
        abort();
    p = q->head;
    if(--(q->readers) > 0 || p == nil){
        unlock(&q->lock);
        return;
    }

    /* start waiting writer */
    if(p->state != QueuingW)
        abort();
    q->head = p->next;
    if(q->head == 0)
        q->tail = 0;
    q->writer = 1;
    unlock(&q->lock);

    /* wakeup waiter */
    while((*_rendezvousp)(p, 0) == (void*)~0)
        ;
}
@

<<function wlock>>=
void
wlock(RWLock *q)
{
    QLp *p, *mp;

    lock(&q->lock);
    if(q->readers == 0 && q->writer == 0){
        /* noone waiting, go for it */
        q->writer = 1;
        unlock(&q->lock);
        return;
    }

    /* wait */
    p = q->tail;
    mp = getqlp();
    if(p == nil)
        q->head = mp;
    else
        p->next = mp;
    q->tail = mp;
    mp->next = nil;
    mp->state = QueuingW;
    unlock(&q->lock);

    /* wait in kernel */
    while((*_rendezvousp)(mp, (void*)1) == (void*)~0)
        ;
    mp->inuse = 0;
}
@

<<function canwlock>>=
int
canwlock(RWLock *q)
{
    lock(&q->lock);
    if (q->readers == 0 && q->writer == 0) {
        /* no one waiting; go for it */
        q->writer = 1;
        unlock(&q->lock);
        return 1;
    }
    unlock(&q->lock);
    return 0;
}
@

<<function wunlock>>=
void
wunlock(RWLock *q)
{
    QLp *p;

    lock(&q->lock);
    if(q->writer == 0)
        abort();
    p = q->head;
    if(p == nil){
        q->writer = 0;
        unlock(&q->lock);
        return;
    }
    if(p->state == QueuingW){
        /* start waiting writer */
        q->head = p->next;
        if(q->head == nil)
            q->tail = nil;
        unlock(&q->lock);
        while((*_rendezvousp)(p, 0) == (void*)~0)
            ;
        return;
    }

    if(p->state != QueuingR)
        abort();

    /* wake waiting readers */
    while(q->head != nil && q->head->state == QueuingR){
        p = q->head;
        q->head = p->next;
        q->readers++;
        while((*_rendezvousp)(p, 0) == (void*)~0)
            ;
    }
    if(q->head == nil)
        q->tail = nil;
    q->writer = 0;
    unlock(&q->lock);
}
@

<<function rsleep>>=
void
rsleep(Rendez *r)
{
    QLp *t, *me;

    if(!r->l)
        abort();
    lock(&r->l->lock);
    /* we should hold the qlock */
    if(!r->l->locked)
        abort();

    /* add ourselves to the wait list */
    me = getqlp();
    me->state = Sleeping;
    if(r->head == nil)
        r->head = me;
    else
        r->tail->next = me;
    me->next = nil;
    r->tail = me;

    /* pass the qlock to the next guy */
    t = r->l->head;
    if(t){
        r->l->head = t->next;
        if(r->l->head == nil)
            r->l->tail = nil;
        unlock(&r->l->lock);
        while((*_rendezvousp)(t, (void*)0x12345) == (void*)~0)
            ;
    }else{
        r->l->locked = 0;
        unlock(&r->l->lock);
    }

    /* wait for a wakeup */
    while((*_rendezvousp)(me, (void*)1) == (void*)~0)
        ;
    me->inuse = 0;
}
@

<<function rwakeup>>=
int
rwakeup(Rendez *r)
{
    QLp *t;

    /*
     * take off wait and put on front of queue
     * put on front so guys that have been waiting will not get starved
     */
    
    if(!r->l)
        abort();
    lock(&r->l->lock);
    if(!r->l->locked)
        abort();

    t = r->head;
    if(t == nil){
        unlock(&r->l->lock);
        return 0;
    }

    r->head = t->next;
    if(r->head == nil)
        r->tail = nil;

    t->next = r->l->head;
    r->l->head = t;
    if(r->l->tail == nil)
        r->l->tail = t;

    t->state = Queuing;
    unlock(&r->l->lock);
    return 1;
}
@

<<function rwakeupall>>=
int
rwakeupall(Rendez *r)
{
    int i;

    for(i=0; rwakeup(r); i++)
        ;
    return i;
}
@


%-------------------------------------------------------------

<<9sys/qlock.c>>=
#include <u.h>
#include <libc.h>

<<global ql>>

<<enum _anon_ (9sys/qlock.c)>>

<<global _rendezvousp>>

<<function _qlockinit>>

<<function getqlp>>

<<function qlock>>

<<function qunlock>>

<<function canqlock>>

<<function rlock>>

<<function canrlock>>

<<function runlock>>

<<function wlock>>

<<function canwlock>>

<<function wunlock>>

<<function rsleep>>

<<function rwakeup>>

<<function rwakeupall>>

@


\subsection*{[[9sys/read.c]]}

<<function read>>=
long
read(int fd, void *buf, long n)
{
    return pread(fd, buf, n, -1LL);
}
@


%-------------------------------------------------------------

<<9sys/read.c>>=
#include    <u.h>
#include    <libc.h>

<<function read>>
@


\subsection*{[[9sys/read9pmsg.c]]}

<<function read9pmsg>>=
int
read9pmsg(int fd, void *abuf, uint n)
{
    int m, len;
    uchar *buf;

    buf = abuf;

    /* read count */
    m = readn(fd, buf, BIT32SZ);
    if(m != BIT32SZ){
        if(m < 0)
            return -1;
        return 0;
    }

    len = GBIT32(buf);
    if(len <= BIT32SZ || len > n){
        werrstr("bad length in 9P2000 message header");
        return -1;
    }
    len -= BIT32SZ;
    m = readn(fd, buf+BIT32SZ, len);
    if(m < len)
        return 0;
    return BIT32SZ+m;
}
@


%-------------------------------------------------------------

<<9sys/read9pmsg.c>>=
#include <u.h>
#include <libc.h>
#include <fcall.h>

<<function read9pmsg>>
@


\subsection*{[[9sys/readv.c]]}

<<function ioreadv>>=
static
long
ioreadv(int fd, IOchunk *io, int nio, vlong offset)
{
    int i;
    long m, n, tot;
    char *buf, *p;

    tot = 0;
    for(i=0; i<nio; i++)
        tot += io[i].len;
    buf = malloc(tot);
    if(buf == nil)
        return -1;

    tot = pread(fd, buf, tot, offset);

    p = buf;
    n = tot;
    for(i=0; i<nio; i++){
        if(n <= 0)
            break;
        m = io->len;
        if(m > n)
            m = n;
        memmove(io->addr, p, m);
        n -= m;
        p += m;
        io++;
    }

    free(buf);
    return tot;
}
@

<<function readv>>=
long
readv(int fd, IOchunk *io, int nio)
{
    return ioreadv(fd, io, nio, -1LL);
}
@

<<function preadv>>=
long
preadv(int fd, IOchunk *io, int nio, vlong off)
{
    return ioreadv(fd, io, nio, off);
}
@


%-------------------------------------------------------------

<<9sys/readv.c>>=
#include <u.h>
#include <libc.h>

<<function ioreadv>>

<<function readv>>

<<function preadv>>
@


\subsection*{[[9sys/rerrstr.c]]}

<<function rerrstr>>=
void
rerrstr(char *buf, uint nbuf)
{
    char tmp[ERRMAX];

    tmp[0] = 0;
    errstr(tmp, sizeof tmp);
    utfecpy(buf, buf+nbuf, tmp);
    errstr(tmp, sizeof tmp);
}
@


%-------------------------------------------------------------

<<9sys/rerrstr.c>>=
#include <u.h>
#include <libc.h>

<<function rerrstr>>
@


\subsection*{[[9sys/sbrk.c]]}

<<global bloc>>=
// starting point for the heap, after the text, data, and bss.
static  char    *bloc = { end };
@

<<enum _anon_ (9sys/sbrk.c)>>=
enum
{
    Round   = 7
};
@

<<function sbrk>>=
void*
sbrk(ulong n)
{
    uintptr bl;

    bl = ((uintptr)bloc + Round) & ~Round;
    if(brk((void*)(bl+n)) < 0)
        return (void*)-1;
    bloc = (char*)bl + n;
    return (void*)bl;
}
@


%-------------------------------------------------------------

<<9sys/sbrk.c>>=
#include <u.h>
#include <libc.h>

extern  char    end[];

<<global bloc>>

// the syscall
extern  int brk(void*);

<<enum _anon_ (9sys/sbrk.c)>>

<<function sbrk>>
@


\subsection*{[[9sys/setnetmtpt.c]]}

<<function setnetmtpt>>=
void
setnetmtpt(char *net, int n, char *x)
{
    if(x == nil)
        x = "/net";

    if(*x == '/'){
        strncpy(net, x, n);
        net[n-1] = 0;
    } else {
        snprint(net, n, "/net%s", x);
    }
}
@


%-------------------------------------------------------------

<<9sys/setnetmtpt.c>>=
#include <u.h>
#include <libc.h>

<<function setnetmtpt>>
@


\subsection*{[[9sys/sysfatal.c]]}

<<function _sysfatalimpl>>=
static void
_sysfatalimpl(char *fmt, va_list arg)
{
    char buf[1024];

    vseprint(buf, buf+sizeof(buf), fmt, arg);
    if(argv0)
        fprint(2, "%s: %s\n", argv0, buf);
    else
        fprint(2, "%s\n", buf);
    exits(buf);
}
@

<<global _sysfatal>>=
void (*_sysfatal)(char *fmt, va_list arg) = _sysfatalimpl;
@

<<function sysfatal>>=
void
sysfatal(char *fmt, ...)
{
    va_list arg;

    va_start(arg, fmt);
    (*_sysfatal)(fmt, arg);
    va_end(arg);
}
@


%-------------------------------------------------------------

<<9sys/sysfatal.c>>=
#include <u.h>
#include <libc.h>


<<function _sysfatalimpl>>

<<global _sysfatal>>

<<function sysfatal>>
@


\subsection*{[[9sys/syslog.c]]}

<<global sl>>=
static struct
{
    int fd;
    int consfd;
    char    *name;
    Dir *d;
    Dir *consd;
    Lock;
} sl =
{
    -1, -1,
};
@

<<function _syslogopen>>=
static void
_syslogopen(void)
{
    char buf[1024];

    if(sl.fd >= 0)
        close(sl.fd);
    snprint(buf, sizeof(buf), "/sys/log/%s", sl.name);
    sl.fd = open(buf, OWRITE|OCEXEC);
}
@

<<function eqdirdev>>=
static int
eqdirdev(Dir *a, Dir *b)
{
    return a != nil && b != nil &&
        a->dev == b->dev && a->type == b->type &&
        a->qid.path == b->qid.path;
}
@

<<function syslog>>=
/*
 * Print
 *  sysname: time: mesg
 * on /sys/log/logname.
 * If cons or log file can't be opened, print on the system console, too.
 */
void
syslog(int cons, char *logname, char *fmt, ...)
{
    char buf[1024];
    char *ctim, *p;
    va_list arg;
    int n;
    Dir *d;
    char err[ERRMAX];

    err[0] = '\0';
    errstr(err, sizeof err);
    lock(&sl);

    /*
     *  paranoia makes us stat to make sure a fork+close
     *  hasn't broken our fd's
     */
    d = dirfstat(sl.fd);
    if(sl.fd < 0 || sl.name == nil || strcmp(sl.name, logname) != 0 ||
       !eqdirdev(d, sl.d)){
        free(sl.name);
        sl.name = strdup(logname);
        if(sl.name == nil)
            cons = 1;
        else{
            free(sl.d);
            sl.d = nil;
            _syslogopen();
            if(sl.fd < 0)
                cons = 1;
            else
                sl.d = dirfstat(sl.fd);
        }
    }
    free(d);
    if(cons){
        d = dirfstat(sl.consfd);
        if(sl.consfd < 0 || !eqdirdev(d, sl.consd)){
            free(sl.consd);
            sl.consd = nil;
            sl.consfd = open("#c/cons", OWRITE|OCEXEC);
            if(sl.consfd >= 0)
                sl.consd = dirfstat(sl.consfd);
        }
        free(d);
    }

    if(fmt == nil){
        unlock(&sl);
        return;
    }

    ctim = ctime(time(0));
    p = buf + snprint(buf, sizeof(buf)-1, "%s ", sysname());
    strncpy(p, ctim+4, 15);
    p += 15;
    *p++ = ' ';
    errstr(err, sizeof err);
    va_start(arg, fmt);
    p = vseprint(p, buf+sizeof(buf)-1, fmt, arg);
    va_end(arg);
    *p++ = '\n';
    n = p - buf;

    if(sl.fd >= 0){
        seek(sl.fd, 0, 2);
        write(sl.fd, buf, n);
    }

    if(cons && sl.consfd >=0)
        write(sl.consfd, buf, n);

    unlock(&sl);
}
@


%-------------------------------------------------------------

<<9sys/syslog.c>>=
#include <u.h>
#include <libc.h>

<<global sl>>

<<function _syslogopen>>

<<function eqdirdev>>

<<function syslog>>
@


\subsection*{[[9sys/sysname.c]]}

<<function sysname>>=
char*
sysname(void)
{
    int f, n;
    static char b[128];

    if(b[0])
        return b;

    f = open("#c/sysname", 0);
    if(f >= 0) {
        n = read(f, b, sizeof(b)-1);
        if(n > 0)
            b[n] = 0;
        close(f);
    }
    return b;
}
@


%-------------------------------------------------------------

<<9sys/sysname.c>>=
#include    <u.h>
#include    <libc.h>

<<function sysname>>
@


\subsection*{[[9sys/time.c]]}

<<function oldtime>>=
/*
 *  After a fork with fd's copied, both fd's are pointing to
 *  the same Chan structure.  Since the offset is kept in the Chan
 *  structure, the seek's and read's in the two processes can
 *  compete at moving the offset around.  Hence the unusual loop
 *  in the middle of this routine.
 */
static long
oldtime(long *tp)
{
    char b[20];
    static int f = -1;
    int i, retries;
    long t;

    memset(b, 0, sizeof(b));
    for(retries = 0; retries < 100; retries++){
        if(f < 0)
            f = open("/dev/time", OREAD|OCEXEC);
        if(f < 0)
            break;
        if(seek(f, 0, 0) < 0 || (i = read(f, b, sizeof(b))) < 0){
            close(f);
            f = -1;
        } else {
            if(i != 0)
                break;
        }
    }
    t = atol(b);
    if(tp)
        *tp = t;
    return t;
}
@

<<function time>>=
long
time(long *tp)
{
    vlong t;

    t = nsec()/1000000000LL;
    if(t == 0)
        t = oldtime(0);
    if(tp != nil)
        *tp = t;
    return t;
}
@


%-------------------------------------------------------------

<<9sys/time.c>>=
#include <u.h>
#include <libc.h>


<<function oldtime>>

<<function time>>
@


\subsection*{[[9sys/times.c]]}

<<function skip (9sys/times.c)>>=
static
char*
skip(char *p)
{

    while(*p == ' ')
        p++;
    while(*p != ' ' && *p != 0)
        p++;
    return p;
}
@

<<function times>>=
/*
 *  after a fork with fd's copied, both fd's are pointing to
 *  the same Chan structure.  Since the offset is kept in the Chan
 *  structure, the seek's and read's in the two processes can be
 *  are competing moving the offset around.  Hence the unusual loop
 *  in the middle of this routine.
 */
long
times(long *t)
{
    char b[200], *p;
    static int f = -1;
    int i, retries;
    ulong r;

    memset(b, 0, sizeof(b));
    for(retries = 0; retries < 100; retries++){
        if(f < 0)
            f = open("/dev/cputime", OREAD|OCEXEC);
        if(f < 0)
            break;
        if(seek(f, 0, 0) < 0 || (i = read(f, b, sizeof(b))) < 0){
            close(f);
            f = -1;
        } else {
            if(i != 0)
                break;
        }
    }
    p = b;
    if(t)
        t[0] = atol(p);
    p = skip(p);
    if(t)
        t[1] = atol(p);
    p = skip(p);
    r = atol(p);
    if(t){
        p = skip(p);
        t[2] = atol(p);
        p = skip(p);
        t[3] = atol(p);
    }
    return r;
}
@


%-------------------------------------------------------------

<<9sys/times.c>>=
#include <u.h>
#include <libc.h>

<<function skip (9sys/times.c)>>

<<function times>>
@


\subsection*{[[9sys/tm2sec.c]]}

<<constant TZSIZE (9sys/tm2sec.c)>>=
#define TZSIZE  150
@

<<global timezone (9sys/tm2sec.c)>>=
static
struct
{
    char    stname[4];
    char    dlname[4];
    long    stdiff;
    long    dldiff;
    long    dlpairs[TZSIZE];
} timezone;
@

<<constant SEC2MIN>>=
#define SEC2MIN 60L
@

<<constant SEC2HOUR>>=
#define SEC2HOUR (60L*SEC2MIN)
@

<<constant SEC2DAY>>=
#define SEC2DAY (24L*SEC2HOUR)
@

<<global dmsize (9sys/tm2sec.c)>>=
/*
 *  days per month plus days/year
 */
static  int dmsize[] =
{
    365, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
};
@

<<global ldmsize>>=
static  int ldmsize[] =
{
    366, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
};
@

<<function yrsize>>=
/*
 *  return the days/month for the given year
 */
static int *
yrsize(int y)
{
    if((y%4) == 0 && ((y%100) != 0 || (y%400) == 0))
        return ldmsize;
    else
        return dmsize;
}
@

<<function tm2sec>>=
/*
 * compute seconds since Jan 1 1970 GMT
 * and convert to our timezone.
 */
long
tm2sec(Tm *tm)
{
    long secs;
    int i, yday, year, *d2m;

    if(strcmp(tm->zone, "GMT") != 0 && timezone.stname[0] == 0)
        readtimezone();
    secs = 0;

    /*
     *  seconds per year
     */
    year = tm->year + 1900;
    for(i = 1970; i < year; i++){
        d2m = yrsize(i);
        secs += d2m[0] * SEC2DAY;
    }

    /*
     *  if mday is set, use mon and mday to compute yday
     */
    if(tm->mday){
        yday = 0;
        d2m = yrsize(year);
        for(i=0; i<tm->mon; i++)
            yday += d2m[i+1];
        yday += tm->mday-1;
    }else{
        yday = tm->yday;
    }
    secs += yday * SEC2DAY;

    /*
     * hours, minutes, seconds
     */
    secs += tm->hour * SEC2HOUR;
    secs += tm->min * SEC2MIN;
    secs += tm->sec;

    /*
     * Only handles zones mentioned in /env/timezone,
     * but things get too ambiguous otherwise.
     */
    if(strcmp(tm->zone, timezone.stname) == 0)
        secs -= timezone.stdiff;
    else if(strcmp(tm->zone, timezone.dlname) == 0)
        secs -= timezone.dldiff;
    if(secs < 0)
        secs = 0;
    return secs;
}
@

<<function readtimezone (9sys/tm2sec.c)>>=
static
void
readtimezone(void)
{
    char buf[TZSIZE*11+30], *p;
    int i;

    memset(buf, 0, sizeof(buf));
    i = open("/env/timezone", 0);
    if(i < 0)
        goto error;
    if(read(i, buf, sizeof(buf)) >= sizeof(buf))
        goto error;
    close(i);
    p = buf;
    if(rd_name(&p, timezone.stname))
        goto error;
    if(rd_long(&p, &timezone.stdiff))
        goto error;
    if(rd_name(&p, timezone.dlname))
        goto error;
    if(rd_long(&p, &timezone.dldiff))
        goto error;
    for(i=0; i<TZSIZE; i++) {
        if(rd_long(&p, &timezone.dlpairs[i]))
            goto error;
        if(timezone.dlpairs[i] == 0)
            return;
    }

error:
    timezone.stdiff = 0;
    strcpy(timezone.stname, "GMT");
    timezone.dlpairs[0] = 0;
}
@

<<function rd_name (9sys/tm2sec.c)>>=
static int
rd_name(char **f, char *p)
{
    int c, i;

    for(;;) {
        c = *(*f)++;
        if(c != ' ' && c != '\n')
            break;
    }
    for(i=0; i<3; i++) {
        if(c == ' ' || c == '\n')
            return 1;
        *p++ = c;
        c = *(*f)++;
    }
    if(c != ' ' && c != '\n')
        return 1;
    *p = 0;
    return 0;
}
@

<<function rd_long (9sys/tm2sec.c)>>=
static int
rd_long(char **f, long *p)
{
    int c, s;
    long l;

    s = 0;
    for(;;) {
        c = *(*f)++;
        if(c == '-') {
            s++;
            continue;
        }
        if(c != ' ' && c != '\n')
            break;
    }
    if(c == 0) {
        *p = 0;
        return 0;
    }
    l = 0;
    for(;;) {
        if(c == ' ' || c == '\n')
            break;
        if(c < '0' || c > '9')
            return 1;
        l = l*10 + c-'0';
        c = *(*f)++;
    }
    if(s)
        l = -l;
    *p = l;
    return 0;
}
@


%-------------------------------------------------------------

<<9sys/tm2sec.c>>=
#include <u.h>
#include <libc.h>

<<constant TZSIZE (9sys/tm2sec.c)>>
static  void    readtimezone(void);
static  int rd_name(char**, char*);
static  int rd_long(char**, long*);
<<global timezone (9sys/tm2sec.c)>>

<<constant SEC2MIN>>
<<constant SEC2HOUR>>
<<constant SEC2DAY>>

<<global dmsize (9sys/tm2sec.c)>>
<<global ldmsize>>

<<function yrsize>>

<<function tm2sec>>

<<function readtimezone (9sys/tm2sec.c)>>

<<function rd_name (9sys/tm2sec.c)>>

<<function rd_long (9sys/tm2sec.c)>>
@


\subsection*{[[9sys/truerand.c]]}

<<function truerand>>=
ulong
truerand(void)
{
    ulong x;
    static int randfd = -1;

    if(randfd < 0)
        randfd = open("/dev/random", OREAD|OCEXEC);
    if(randfd < 0)
        sysfatal("can't open /dev/random");
    if(read(randfd, &x, sizeof(x)) != sizeof(x))
        sysfatal("can't read /dev/random");
    return x;
}
@


%-------------------------------------------------------------

<<9sys/truerand.c>>=
#include <u.h>
#include <libc.h>

<<function truerand>>
@


\subsection*{[[9sys/wait.c]]}

<<function wait>>=
Waitmsg*
wait(void)
{
    int n, l;
    char buf[512], *fld[5];
    Waitmsg *w;

    n = await(buf, sizeof buf-1);
    if(n < 0)
        return nil;
    buf[n] = '\0';
    if(tokenize(buf, fld, nelem(fld)) != nelem(fld)){
        werrstr("couldn't parse wait message");
        return nil;
    }
    l = strlen(fld[4])+1;
    w = malloc(sizeof(Waitmsg)+l);
    if(w == nil)
        return nil;
    w->pid = atoi(fld[0]);
    w->time[0] = atoi(fld[1]);
    w->time[1] = atoi(fld[2]);
    w->time[2] = atoi(fld[3]);
    w->msg = (char*)&w[1];
    memmove(w->msg, fld[4], l);
    return w;
}
@


%-------------------------------------------------------------

<<9sys/wait.c>>=
#include <u.h>
#include <libc.h>
#include <fcall.h>

<<function wait>>

@


\subsection*{[[9sys/waitpid.c]]}

<<function waitpid>>=
int
waitpid(void)
{
    int n;
    char buf[512], *fld[5];

    n = await(buf, sizeof buf-1);
    if(n <= 0)
        return -1;
    buf[n] = '\0';
    if(tokenize(buf, fld, nelem(fld)) != nelem(fld)){
        werrstr("couldn't parse wait message");
        return -1;
    }
    return atoi(fld[0]);
}
@


%-------------------------------------------------------------

<<9sys/waitpid.c>>=
#include <u.h>
#include <libc.h>
#include <fcall.h>

<<function waitpid>>

@


\subsection*{[[9sys/werrstr.c]]}

<<function werrstr>>=
void
werrstr(char *fmt, ...)
{
    va_list arg;
    char buf[ERRMAX];

    va_start(arg, fmt);
    vseprint(buf, buf+ERRMAX, fmt, arg);
    va_end(arg);
    errstr(buf, ERRMAX);
}
@


%-------------------------------------------------------------

<<9sys/werrstr.c>>=
#include <u.h>
#include <libc.h>

<<function werrstr>>
@


\subsection*{[[9sys/write.c]]}

<<function write>>=
long
write(int fd, void *buf, long n)
{
    return pwrite(fd, buf, n, -1LL);
}
@


%-------------------------------------------------------------

<<9sys/write.c>>=
#include    <u.h>
#include    <libc.h>

<<function write>>
@


\subsection*{[[9sys/writev.c]]}

<<function iowritev>>=
static
long
iowritev(int fd, IOchunk *io, int nio, vlong offset)
{
    int i;
    long tot;
    char *buf, *p;

    tot = 0;
    for(i=0; i<nio; i++)
        tot += io[i].len;
    buf = malloc(tot);
    if(buf == nil)
        return -1;

    p = buf;
    for(i=0; i<nio; i++){
        memmove(p, io->addr, io->len);
        p += io->len;
        io++;
    }

    tot = pwrite(fd, buf, tot, offset);

    free(buf);
    return tot;
}
@

<<function writev>>=
long
writev(int fd, IOchunk *io, int nio)
{
    return iowritev(fd, io, nio, -1LL);
}
@

<<function pwritev>>=
long
pwritev(int fd, IOchunk *io, int nio, vlong off)
{
    return iowritev(fd, io, nio, off);
}
@


%-------------------------------------------------------------

<<9sys/writev.c>>=
#include <u.h>
#include <libc.h>

<<function iowritev>>

<<function writev>>

<<function pwritev>>
@


\section{[[lib_core/libc/fmt/]]}

\subsection*{[[fmt/fmtdef.h]]}

<<lib_core/libc/fmt/fmtdef.h>>=
/*
 * dofmt -- format to a buffer
 * the number of characters formatted is returned,
 * or -1 if there was an error.
 * if the buffer is ever filled, flush is called.
 * it should reset the buffer and return whether formatting should continue.
 */

typedef int (*Fmts)(Fmt*);

typedef struct Quoteinfo Quoteinfo;
struct Quoteinfo
{
    int quoted;     /* if set, string must be quoted */
    int nrunesin;   /* number of input runes that can be accepted */
    int nbytesin;   /* number of input bytes that can be accepted */
    int nrunesout;  /* number of runes that will be generated */
    int nbytesout;  /* number of bytes that will be generated */
};

void    *_fmtflush(Fmt*, void*, int);
void    *_fmtdispatch(Fmt*, void*, int);
int _floatfmt(Fmt*, double);
int _fmtpad(Fmt*, int);
int _rfmtpad(Fmt*, int);
int _fmtFdFlush(Fmt*);

int _efgfmt(Fmt*);
int _charfmt(Fmt*);
int _countfmt(Fmt*);
int _flagfmt(Fmt*);
int _percentfmt(Fmt*);
int _ifmt(Fmt*);
int _runefmt(Fmt*);
int _runesfmt(Fmt*);
int _strfmt(Fmt*);
int _badfmt(Fmt*);
int _fmtcpy(Fmt*, void*, int, int);
int _fmtrcpy(Fmt*, void*, int n);

void    _fmtlock(void);
void    _fmtunlock(void);

#define FMTCHAR(f, t, s, c)\
    do{\
    if(t + 1 > (char*)s){\
        t = _fmtflush(f, t, 1);\
        if(t != nil)\
            s = f->stop;\
        else\
            return -1;\
    }\
    *t++ = c;\
    }while(0)

#define FMTRCHAR(f, t, s, c)\
    do{\
    if(t + 1 > (Rune*)s){\
        t = _fmtflush(f, t, sizeof(Rune));\
        if(t != nil)\
            s = f->stop;\
        else\
            return -1;\
    }\
    *t++ = c;\
    }while(0)

#define FMTRUNE(f, t, s, r)\
    do{\
    Rune _rune;\
    int _runelen;\
    if(t + UTFmax > (char*)s && t + (_runelen = runelen(r)) > (char*)s){\
        t = _fmtflush(f, t, _runelen);\
        if(t != nil)\
            s = f->stop;\
        else\
            return -1;\
    }\
    if(r < Runeself)\
        *t++ = r;\
    else{\
        _rune = r;\
        t += runetochar(t, &_rune);\
    }\
    }while(0)
@


\subsection*{[[fmt/dofmt.c]]}

<<function dofmt>>=
/* format the output into f->to and return the number of characters fmted  */
int
dofmt(Fmt *f, char *fmt)
{
    Rune rune, *rt, *rs;
    int r;
    char *t, *s;
    int n, nfmt;

    nfmt = f->nfmt;
    for(;;){
        if(f->runes){
            rt = f->to;
            rs = f->stop;
            while((r = *(uchar*)fmt) && r != '%'){
                if(r < Runeself)
                    fmt++;
                else{
                    fmt += chartorune(&rune, fmt);
                    r = rune;
                }
                FMTRCHAR(f, rt, rs, r);
            }
            fmt++;
            f->nfmt += rt - (Rune *)f->to;
            f->to = rt;
            if(!r)
                return f->nfmt - nfmt;
            f->stop = rs;
        }else{
            t = f->to;
            s = f->stop;
            while((r = *(uchar*)fmt) && r != '%'){
                if(r < Runeself){
                    FMTCHAR(f, t, s, r);
                    fmt++;
                }else{
                    n = chartorune(&rune, fmt);
                    if(t + n > s){
                        t = _fmtflush(f, t, n);
                        if(t != nil)
                            s = f->stop;
                        else
                            return -1;
                    }
                    while(n--)
                        *t++ = *fmt++;
                }
            }
            fmt++;
            f->nfmt += t - (char *)f->to;
            f->to = t;
            if(!r)
                return f->nfmt - nfmt;
            f->stop = s;
        }

        fmt = _fmtdispatch(f, fmt, 0);
        if(fmt == nil)
            return -1;
    }
}
@

<<function _fmtflush>>=
void *
_fmtflush(Fmt *f, void *t, int len)
{
    if(f->runes)
        f->nfmt += (Rune*)t - (Rune*)f->to;
    else
        f->nfmt += (char*)t - (char *)f->to;
    f->to = t;
    if(f->flush == 0 || (*f->flush)(f) == 0 || (char*)f->to + len > (char*)f->stop){
        f->stop = f->to;
        return nil;
    }
    return f->to;
}
@

<<function _fmtpad>>=
/*
 * put a formatted block of memory sz bytes long of n runes into the output buffer,
 * left/right justified in a field of at least f->width charactes
 */
int
_fmtpad(Fmt *f, int n)
{
    char *t, *s;
    int i;

    t = f->to;
    s = f->stop;
    for(i = 0; i < n; i++)
        FMTCHAR(f, t, s, ' ');
    f->nfmt += t - (char *)f->to;
    f->to = t;
    return 0;
}
@

<<function _rfmtpad>>=
int
_rfmtpad(Fmt *f, int n)
{
    Rune *t, *s;
    int i;

    t = f->to;
    s = f->stop;
    for(i = 0; i < n; i++)
        FMTRCHAR(f, t, s, ' ');
    f->nfmt += t - (Rune *)f->to;
    f->to = t;
    return 0;
}
@

<<function _fmtcpy>>=
int
_fmtcpy(Fmt *f, void *vm, int n, int sz)
{
    Rune *rt, *rs, r;
    char *t, *s, *m, *me;
    ulong fl;
    int nc, w;

    m = vm;
    me = m + sz;
    w = f->width;
    fl = f->flags;
    if((fl & FmtPrec) && n > f->prec)
        n = f->prec;
    if(f->runes){
        if(!(fl & FmtLeft) && _rfmtpad(f, w - n) < 0)
            return -1;
        rt = f->to;
        rs = f->stop;
        for(nc = n; nc > 0; nc--){
            r = *(uchar*)m;
            if(r < Runeself)
                m++;
            else if((me - m) >= UTFmax || fullrune(m, me-m))
                m += chartorune(&r, m);
            else
                break;
            FMTRCHAR(f, rt, rs, r);
        }
        f->nfmt += rt - (Rune *)f->to;
        f->to = rt;
        if(fl & FmtLeft && _rfmtpad(f, w - n) < 0)
            return -1;
    }else{
        if(!(fl & FmtLeft) && _fmtpad(f, w - n) < 0)
            return -1;
        t = f->to;
        s = f->stop;
        for(nc = n; nc > 0; nc--){
            r = *(uchar*)m;
            if(r < Runeself)
                m++;
            else if((me - m) >= UTFmax || fullrune(m, me-m))
                m += chartorune(&r, m);
            else
                break;
            FMTRUNE(f, t, s, r);
        }
        f->nfmt += t - (char *)f->to;
        f->to = t;
        if(fl & FmtLeft && _fmtpad(f, w - n) < 0)
            return -1;
    }
    return 0;
}
@

<<function _fmtrcpy>>=
int
_fmtrcpy(Fmt *f, void *vm, int n)
{
    Rune r, *m, *me, *rt, *rs;
    char *t, *s;
    ulong fl;
    int w;

    m = vm;
    w = f->width;
    fl = f->flags;
    if((fl & FmtPrec) && n > f->prec)
        n = f->prec;
    if(f->runes){
        if(!(fl & FmtLeft) && _rfmtpad(f, w - n) < 0)
            return -1;
        rt = f->to;
        rs = f->stop;
        for(me = m + n; m < me; m++)
            FMTRCHAR(f, rt, rs, *m);
        f->nfmt += rt - (Rune *)f->to;
        f->to = rt;
        if(fl & FmtLeft && _rfmtpad(f, w - n) < 0)
            return -1;
    }else{
        if(!(fl & FmtLeft) && _fmtpad(f, w - n) < 0)
            return -1;
        t = f->to;
        s = f->stop;
        for(me = m + n; m < me; m++){
            r = *m;
            FMTRUNE(f, t, s, r);
        }
        f->nfmt += t - (char *)f->to;
        f->to = t;
        if(fl & FmtLeft && _fmtpad(f, w - n) < 0)
            return -1;
    }
    return 0;
}
@

<<function _charfmt>>=
/* fmt out one character */
int
_charfmt(Fmt *f)
{
    char x[1];

    x[0] = va_arg(f->args, int);
    f->prec = 1;
    return _fmtcpy(f, x, 1, 1);
}
@

<<function _runefmt>>=
/* fmt out one rune */
int
_runefmt(Fmt *f)
{
    Rune x[1];

    x[0] = va_arg(f->args, int);
    return _fmtrcpy(f, x, 1);
}
@

<<function fmtstrcpy>>=
/* public helper routine: fmt out a null terminated string already in hand */
int
fmtstrcpy(Fmt *f, char *s)
{
    int i, j;
    Rune r;

    if(!s)
        return _fmtcpy(f, "<nil>", 5, 5);
    /* if precision is specified, make sure we don't wander off the end */
    if(f->flags & FmtPrec){
        i = 0;
        for(j=0; j<f->prec && s[i]; j++)
            i += chartorune(&r, s+i);
        return _fmtcpy(f, s, j, i);
    }
    return _fmtcpy(f, s, utflen(s), strlen(s));
}
@

<<function _strfmt>>=
/* fmt out a null terminated utf string */
int
_strfmt(Fmt *f)
{
    char *s;

    s = va_arg(f->args, char *);
    return fmtstrcpy(f, s);
}
@

<<function fmtrunestrcpy>>=
/* public helper routine: fmt out a null terminated rune string already in hand */
int
fmtrunestrcpy(Fmt *f, Rune *s)
{
    Rune *e;
    int n, p;

    if(!s)
        return _fmtcpy(f, "<nil>", 5, 5);
    /* if precision is specified, make sure we don't wander off the end */
    if(f->flags & FmtPrec){
        p = f->prec;
        for(n = 0; n < p; n++)
            if(s[n] == 0)
                break;
    }else{
        for(e = s; *e; e++)
            ;
        n = e - s;
    }
    return _fmtrcpy(f, s, n);
}
@

<<function _runesfmt>>=
/* fmt out a null terminated rune string */
int
_runesfmt(Fmt *f)
{
    Rune *s;

    s = va_arg(f->args, Rune *);
    return fmtrunestrcpy(f, s);
}
@

<<function _percentfmt>>=
/* fmt a % */
int
_percentfmt(Fmt *f)
{
    Rune x[1];

    x[0] = f->r;
    f->prec = 1;
    return _fmtrcpy(f, x, 1);
}
@

<<enum _anon_ (fmt/dofmt.c)>>=
enum {
    /* %,#llb could emit a sign, "0b" and 64 digits with 21 commas */
    Maxintwidth = 1 + 2 + 64 + 64/3,
};
@

<<function _ifmt>>=
/* fmt an integer */
int
_ifmt(Fmt *f)
{
    char buf[Maxintwidth + 1], *p, *conv;
    uvlong vu;
    ulong u;
    uintptr pu;
    int neg, base, i, n, fl, w, isv;

    neg = 0;
    fl = f->flags;
    isv = 0;
    vu = 0;
    u = 0;
    if(f->r == 'p'){
        pu = va_arg(f->args, uintptr);
        if(sizeof(uintptr) == sizeof(uvlong)){
            vu = pu;
            isv = 1;
        }else
            u = pu;
        f->r = 'x';
        fl |= FmtUnsigned;
    }else if(fl & FmtVLong){
        isv = 1;
        if(fl & FmtUnsigned)
            vu = va_arg(f->args, uvlong);
        else
            vu = va_arg(f->args, vlong);
    }else if(fl & FmtLong){
        if(fl & FmtUnsigned)
            u = va_arg(f->args, ulong);
        else
            u = va_arg(f->args, long);
    }else if(fl & FmtByte){
        if(fl & FmtUnsigned)
            u = (uchar)va_arg(f->args, int);
        else
            u = (char)va_arg(f->args, int);
    }else if(fl & FmtShort){
        if(fl & FmtUnsigned)
            u = (ushort)va_arg(f->args, int);
        else
            u = (short)va_arg(f->args, int);
    }else{
        if(fl & FmtUnsigned)
            u = va_arg(f->args, uint);
        else
            u = va_arg(f->args, int);
    }
    conv = "0123456789abcdef";
    switch(f->r){
    case 'd':
        base = 10;
        break;
    case 'x':
        base = 16;
        break;
    case 'X':
        base = 16;
        conv = "0123456789ABCDEF";
        break;
    case 'b':
        base = 2;
        break;
    case 'o':
        base = 8;
        break;
    default:
        return -1;
    }
    if(!(fl & FmtUnsigned)){
        if(isv && (vlong)vu < 0){
            vu = -(vlong)vu;
            neg = 1;
        }else if(!isv && (long)u < 0){
            u = -(long)u;
            neg = 1;
        }
    }
    p = buf + sizeof buf - 1;
    n = 0;
    if(isv){
        while(vu){
            i = vu % base;
            vu /= base;
            if((fl & FmtComma) && n % 4 == 3){
                *p-- = ',';
                n++;
            }
            *p-- = conv[i];
            n++;
        }
    }else{
        while(u){
            i = u % base;
            u /= base;
            if((fl & FmtComma) && n % 4 == 3){
                *p-- = ',';
                n++;
            }
            *p-- = conv[i];
            n++;
        }
    }
    if(n == 0){
        *p-- = '0';
        n = 1;
    }
    for(w = f->prec; n < w && p > buf+3; n++)
        *p-- = '0';
    if(neg || (fl & (FmtSign|FmtSpace)))
        n++;
    if(fl & FmtSharp){
        if(base == 16)
            n += 2;
        else if(base == 8){
            if(p[1] == '0')
                fl &= ~FmtSharp;
            else
                n++;
        }
    }
    if((fl & FmtZero) && !(fl & (FmtLeft|FmtPrec))){
        for(w = f->width; n < w && p > buf+3; n++)
            *p-- = '0';
        f->width = 0;
    }
    if(fl & FmtSharp){
        if(base == 16)
            *p-- = f->r;
        if(base == 16 || base == 8)
            *p-- = '0';
    }
    if(neg)
        *p-- = '-';
    else if(fl & FmtSign)
        *p-- = '+';
    else if(fl & FmtSpace)
        *p-- = ' ';
    f->flags &= ~FmtPrec;
    return _fmtcpy(f, p + 1, n, n);
}
@

<<function _countfmt>>=
int
_countfmt(Fmt *f)
{
    void *p;
    ulong fl;

    fl = f->flags;
    p = va_arg(f->args, void*);
    if(fl & FmtVLong){
        *(vlong*)p = f->nfmt;
    }else if(fl & FmtLong){
        *(long*)p = f->nfmt;
    }else if(fl & FmtByte){
        *(char*)p = f->nfmt;
    }else if(fl & FmtShort){
        *(short*)p = f->nfmt;
    }else{
        *(int*)p = f->nfmt;
    }
    return 0;
}
@

<<function _flagfmt>>=
int
_flagfmt(Fmt *f)
{
    switch(f->r){
    case ',':
        f->flags |= FmtComma;
        break;
    case '-':
        f->flags |= FmtLeft;
        break;
    case '+':
        f->flags |= FmtSign;
        break;
    case '#':
        f->flags |= FmtSharp;
        break;
    case ' ':
        f->flags |= FmtSpace;
        break;
    case 'u':
        f->flags |= FmtUnsigned;
        break;
    case 'h':
        if(f->flags & FmtShort)
            f->flags |= FmtByte;
        f->flags |= FmtShort;
        break;
    case 'l':
        if(f->flags & FmtLong)
            f->flags |= FmtVLong;
        f->flags |= FmtLong;
        break;
    }
    return 1;
}
@

<<function _badfmt>>=
/* default error format */
int
_badfmt(Fmt *f)
{
    Rune x[3];

    x[0] = '%';
    x[1] = f->r;
    x[2] = '%';
    f->prec = 3;
    _fmtrcpy(f, x, 3);
    return 0;
}
@


%-------------------------------------------------------------

<<fmt/dofmt.c>>=
#include <u.h>
#include <libc.h>
#include "fmtdef.h"

<<function dofmt>>

<<function _fmtflush>>

<<function _fmtpad>>

<<function _rfmtpad>>

<<function _fmtcpy>>

<<function _fmtrcpy>>

<<function _charfmt>>

<<function _runefmt>>

<<function fmtstrcpy>>

<<function _strfmt>>

<<function fmtrunestrcpy>>

<<function _runesfmt>>

<<function _percentfmt>>

<<enum _anon_ (fmt/dofmt.c)>>

<<function _ifmt>>

<<function _countfmt>>

<<function _flagfmt>>

<<function _badfmt>>
@


\subsection*{[[fmt/dorfmt.c]]}

<<function dorfmt>>=
/* format the output into f->to and return the number of characters fmted  */

int
dorfmt(Fmt *f, Rune *fmt)
{
    Rune *rt, *rs;
    int r;
    char *t, *s;
    int nfmt;

    nfmt = f->nfmt;
    for(;;){
        if(f->runes){
            rt = f->to;
            rs = f->stop;
            while((r = *fmt++) && r != '%'){
                FMTRCHAR(f, rt, rs, r);
            }
            f->nfmt += rt - (Rune *)f->to;
            f->to = rt;
            if(!r)
                return f->nfmt - nfmt;
            f->stop = rs;
        }else{
            t = f->to;
            s = f->stop;
            while((r = *fmt++) && r != '%'){
                FMTRUNE(f, t, f->stop, r);
            }
            f->nfmt += t - (char *)f->to;
            f->to = t;
            if(!r)
                return f->nfmt - nfmt;
            f->stop = s;
        }

        fmt = _fmtdispatch(f, fmt, 1);
        if(fmt == nil)
            return -1;
    }
}
@


%-------------------------------------------------------------

<<fmt/dorfmt.c>>=
#include <u.h>
#include <libc.h>
#include "fmtdef.h"

<<function dorfmt>>
@


\subsection*{[[fmt/errfmt.c]]}

<<function errfmt>>=
int
errfmt(Fmt *f)
{
    char buf[ERRMAX];

    rerrstr(buf, sizeof buf);
    return _fmtcpy(f, buf, utflen(buf), strlen(buf));
}
@


%-------------------------------------------------------------

<<fmt/errfmt.c>>=
#include <u.h>
#include <libc.h>
#include "fmtdef.h"

<<function errfmt>>
@


\subsection*{[[fmt/fltfmt.c]]}

<<enum _anon_ (fmt/fltfmt.c)>>=
enum
{
    FDIGIT  = 30,
    FDEFLT  = 6,
    NSIGNIF = 17,
    NEXP10  = 308,
};
@

<<function xadd>>=
static int
xadd(char *a, int n, int v)
{
    char *b;
    int c;

    if(n < 0 || n >= NSIGNIF)
        return 0;
    for(b = a+n; b >= a; b--) {
        c = *b + v;
        if(c <= '9') {
            *b = c;
            return 0;
        }
        *b = '0';
        v = 1;
    }
    *a = '1';   // overflow adding
    return 1;
}
@

<<function xsub>>=
static int
xsub(char *a, int n, int v)
{
    char *b;
    int c;

    for(b = a+n; b >= a; b--) {
        c = *b - v;
        if(c >= '0') {
            *b = c;
            return 0;
        }
        *b = '9';
        v = 1;
    }
    *a = '9';   // underflow subtracting
    return 1;
}
@

<<function xdtoa>>=
static void
xdtoa(Fmt *fmt, char *s2, double f)
{
    char s1[NSIGNIF+10];
    double g, h;
    int e, d, i, n;
    int c1, c2, c3, c4, ucase, sign, chr, prec;

    prec = FDEFLT;
    if(fmt->flags & FmtPrec)
        prec = fmt->prec;
    if(prec > FDIGIT)
        prec = FDIGIT;
    if(isNaN(f)) {
        strcpy(s2, "NaN");
        return;
    }
    if(isInf(f, 1)) {
        strcpy(s2, "+Inf");
        return;
    }
    if(isInf(f, -1)) {
        strcpy(s2, "-Inf");
        return;
    }
    sign = 0;
    if(f < 0) {
        f = -f;
        sign++;
    }
    ucase = 0;
    chr = fmt->r;
    if(isupper(chr)) {
        ucase = 1;
        chr = tolower(chr);
    }

    e = 0;
    g = f;
    if(g != 0) {
        frexp(f, &e);
        e = e * .301029995664;
        if(e >= -150 && e <= +150) {
            d = 0;
            h = f;
        } else {
            d = e/2;
            h = f * pow10(-d);
        }
        g = h * pow10(d-e);
        while(g < 1) {
            e--;
            g = h * pow10(d-e);
        }
        while(g >= 10) {
            e++;
            g = h * pow10(d-e);
        }
    }

    /*
     * convert NSIGNIF digits and convert
     * back to get accuracy.
     */
    for(i=0; i<NSIGNIF; i++) {
        d = g;
        s1[i] = d + '0';
        g = (g - d) * 10;
    }
    s1[i] = 0;

    /*
     * try decimal rounding to eliminate 9s
     */
    c2 = prec + 1;
    if(chr == 'f')
        c2 += e;
    if(c2 >= NSIGNIF-2) {
        strcpy(s2, s1);
        d = e;
        s1[NSIGNIF-2] = '0';
        s1[NSIGNIF-1] = '0';
        sprint(s1+NSIGNIF, "e%d", e-NSIGNIF+1);
        g = strtod(s1, nil);
        if(g == f)
            goto found;
        if(xadd(s1, NSIGNIF-3, 1)) {
            e++;
            sprint(s1+NSIGNIF, "e%d", e-NSIGNIF+1);
        }
        g = strtod(s1, nil);
        if(g == f)
            goto found;
        strcpy(s1, s2);
        e = d;
    }

    /*
     * convert back so s1 gets exact answer
     */
    for(;;) {
        sprint(s1+NSIGNIF, "e%d", e-NSIGNIF+1);
        g = strtod(s1, nil);
        if(f > g) {
            if(xadd(s1, NSIGNIF-1, 1))
                e--;
            continue;
        }
        if(f < g) {
            if(xsub(s1, NSIGNIF-1, 1))
                e++;
            continue;
        }
        break;
    }

found:
    /*
     * sign
     */
    d = 0;
    i = 0;
    if(sign)
        s2[d++] = '-';
    else if(fmt->flags & FmtSign)
        s2[d++] = '+';
    else if(fmt->flags & FmtSpace)
        s2[d++] = ' ';

    /*
     * copy into final place
     * c1 digits of leading '0'
     * c2 digits from conversion
     * c3 digits of trailing '0'
     * c4 digits after '.'
     */
    c1 = 0;
    c2 = prec + 1;
    c3 = 0;
    c4 = prec;
    switch(chr) {
    default:
        if(xadd(s1, c2, 5))
            e++;
        break;
    case 'g':
        /*
         * decide on 'e' of 'f' style convers
         */
        if(xadd(s1, c2, 5))
            e++;
        if(e >= -5 && e <= prec) {
            c1 = -e - 1;
            c4 = prec - e;
            chr = 'h';  // flag for 'f' style
        }
        break;
    case 'f':
        if(xadd(s1, c2+e, 5))
            e++;
        c1 = -e;
        if(c1 > prec)
            c1 = c2;
        c2 += e;
        break;
    }

    /*
     * clean up c1 c2 and c3
     */
    if(c1 < 0)
        c1 = 0;
    if(c2 < 0)
        c2 = 0;
    if(c2 > NSIGNIF) {
        c3 = c2-NSIGNIF;
        c2 = NSIGNIF;
    }

    /*
     * copy digits
     */
    while(c1 > 0) {
        if(c1+c2+c3 == c4)
            s2[d++] = '.';
        s2[d++] = '0';
        c1--;
    }
    while(c2 > 0) {
        if(c2+c3 == c4)
            s2[d++] = '.';
        s2[d++] = s1[i++];
        c2--;
    }
    while(c3 > 0) {
        if(c3 == c4)
            s2[d++] = '.';
        s2[d++] = '0';
        c3--;
    }

    /*
     * strip trailing '0' on g conv
     */
    if(fmt->flags & FmtSharp) {
        if(0 == c4)
            s2[d++] = '.';
    } else
    if(chr == 'g' || chr == 'h') {
        for(n=d-1; n>=0; n--)
            if(s2[n] != '0')
                break;
        for(i=n; i>=0; i--)
            if(s2[i] == '.') {
                d = n;
                if(i != n)
                    d++;
                break;
            }
    }
    if(chr == 'e' || chr == 'g') {
        if(ucase)
            s2[d++] = 'E';
        else
            s2[d++] = 'e';
        c1 = e;
        if(c1 < 0) {
            s2[d++] = '-';
            c1 = -c1;
        } else
            s2[d++] = '+';
        if(c1 >= 100) {
            s2[d++] = c1/100 + '0';
            c1 = c1%100;
        }
        s2[d++] = c1/10 + '0';
        s2[d++] = c1%10 + '0';
    }
    s2[d] = 0;
}
@

<<function _floatfmt>>=
int
_floatfmt(Fmt *fmt, double f)
{
    char s[1+NEXP10+1+FDIGIT+1];

    /*
     * The max length of a %f string is
     *  '[+-]'+"max exponent"+'.'+"max precision"+'\0'
     * which is 341 currently.
     */ 
    xdtoa(fmt, s, f);
    fmt->flags &= FmtWidth|FmtLeft;
    _fmtcpy(fmt, s, strlen(s), strlen(s));
    return 0;
}
@

<<function _efgfmt>>=
int
_efgfmt(Fmt *f)
{
    double d;

    d = va_arg(f->args, double);
    return _floatfmt(f, d);
}
@


%-------------------------------------------------------------

<<fmt/fltfmt.c>>=
#include <u.h>
#include <libc.h>
#include <ctype.h>
#include "fmtdef.h"

<<enum _anon_ (fmt/fltfmt.c)>>

<<function xadd>>

<<function xsub>>

<<function xdtoa>>

<<function _floatfmt>>

<<function _efgfmt>>
@


\subsection*{[[fmt/fmt.c]]}

<<enum _anon_ (fmt/fmt.c)>>=
enum
{
    Maxfmt = 64
};
@

<<struct Convfmt>>=
struct Convfmt
{
    int c;
    volatile    Fmts    fmt;    /* for spin lock in fmtfmt; avoids race due to write order */
};
@

<<global fmtalloc>>=
struct
{
    /* lock by calling _fmtlock, _fmtunlock */
    int nfmt;
    Convfmt fmt[Maxfmt];
} fmtalloc;
@

<<global knownfmt>>=
static Convfmt knownfmt[] = {
    ' ',    _flagfmt,
    '#',    _flagfmt,
    '%',    _percentfmt,
    '+',    _flagfmt,
    ',',    _flagfmt,
    '-',    _flagfmt,
    'C',    _runefmt,
    'E',    _efgfmt,
    'G',    _efgfmt,
    'S',    _runesfmt,
    'X',    _ifmt,
    'b',    _ifmt,
    'c',    _charfmt,
    'd',    _ifmt,
    'e',    _efgfmt,
    'f',    _efgfmt,
    'g',    _efgfmt,
    'h',    _flagfmt,
    'l',    _flagfmt,
    'n',    _countfmt,
    'o',    _ifmt,
    'p',    _ifmt,
    'r',    errfmt,
    's',    _strfmt,
    'u',    _flagfmt,
    'x',    _ifmt,
    0,  nil,
};
@

<<global doquote (fmt/fmt.c)>>=
int (*doquote)(int);
@

<<function _fmtinstall>>=
/*
 * _fmtlock() must be set
 */
static int
_fmtinstall(int c, Fmts f)
{
    Convfmt *p, *ep;

    if(c<=0 || c>=65536)
        return -1;
    if(!f)
        f = _badfmt;

    ep = &fmtalloc.fmt[fmtalloc.nfmt];
    for(p=fmtalloc.fmt; p<ep; p++)
        if(p->c == c)
            break;

    if(p == &fmtalloc.fmt[Maxfmt])
        return -1;

    p->fmt = f;
    if(p == ep){    /* installing a new format character */
        fmtalloc.nfmt++;
        p->c = c;
    }

    return 0;
}
@

<<function fmtinstall>>=
int
fmtinstall(int c, Fmts f)
{
    int ret;

    _fmtlock();
    ret = _fmtinstall(c, f);
    _fmtunlock();
    return ret;
}
@

<<function fmtfmt>>=
static Fmts
fmtfmt(int c)
{
    Convfmt *p, *ep;

    ep = &fmtalloc.fmt[fmtalloc.nfmt];
    for(p=fmtalloc.fmt; p<ep; p++)
        if(p->c == c){
            while(p->fmt == nil)    /* loop until value is updated */
                ;
            return p->fmt;
        }

    /* is this a predefined format char? */
    _fmtlock();
    for(p=knownfmt; p->c; p++)
        if(p->c == c){
            _fmtinstall(p->c, p->fmt);
            _fmtunlock();
            return p->fmt;
        }
    _fmtunlock();

    return _badfmt;
}
@

<<function _fmtdispatch>>=
void*
_fmtdispatch(Fmt *f, void *fmt, int isrunes)
{
    Rune rune, r;
    int i, n, w, p;
    ulong fl;
    void *ret;

    w = f->width;
    p = f->prec;
    fl = f->flags;

    f->flags = 0;
    f->width = f->prec = 0;

    for(;;){
        if(isrunes){
            r = *(Rune*)fmt;
            fmt = (Rune*)fmt + 1;
        }else{
            fmt = (char*)fmt + chartorune(&rune, fmt);
            r = rune;
        }
        f->r = r;
        switch(r){
        case '\0':
            ret = nil;
            goto end;
        case '.':
            f->flags |= FmtWidth|FmtPrec;
            continue;
        case '0':
            if(!(f->flags & FmtWidth)){
                f->flags |= FmtZero;
                continue;
            }
            /* fall through */
        case '1': case '2': case '3': case '4':
        case '5': case '6': case '7': case '8': case '9':
            i = 0;
            while(r >= '0' && r <= '9'){
                i = i * 10 + r - '0';
                if(isrunes){
                    r = *(Rune*)fmt;
                    fmt = (Rune*)fmt + 1;
                }else{
                    r = *(char*)fmt;
                    fmt = (char*)fmt + 1;
                }
            }
            if(isrunes)
                fmt = (Rune*)fmt - 1;
            else
                fmt = (char*)fmt - 1;
        numflag:
            if(f->flags & FmtWidth){
                f->flags |= FmtPrec;
                f->prec = i;
            }else{
                f->flags |= FmtWidth;
                f->width = i;
            }
            continue;
        case '*':
            i = va_arg(f->args, int);
            if(i < 0){
                /*
                 * negative precision =>
                 * ignore the precision.
                 */
                if(f->flags & FmtPrec){
                    f->flags &= ~FmtPrec;
                    f->prec = 0;
                    continue;
                }
                i = -i;
                f->flags |= FmtLeft;
            }
            goto numflag;
        }
        n = (*fmtfmt(r))(f);
        if(n < 0){
            ret = nil;
            break;
        }
        if(n == 0){
            ret = fmt;
            break;
        }
    }
end:
    f->width = w;
    f->prec = p;
    f->flags = fl;
    return ret;
}
@


%-------------------------------------------------------------

<<fmt/fmt.c>>=
#include <u.h>
#include <libc.h>
#include "fmtdef.h"

<<enum _anon_ (fmt/fmt.c)>>

typedef struct Convfmt Convfmt;
<<struct Convfmt>>

<<global fmtalloc>>

<<global knownfmt>>

<<global doquote (fmt/fmt.c)>>

<<function _fmtinstall>>

<<function fmtinstall>>

<<function fmtfmt>>

<<function _fmtdispatch>>
@


\subsection*{[[fmt/fmtfd.c]]}

<<function fmtfdflush>>=
/*
 * public routine for final flush of a formatting buffer
 * to a file descriptor; returns total char count.
 */
int
fmtfdflush(Fmt *f)
{
    if(_fmtFdFlush(f) <= 0)
        return -1;
    return f->nfmt;
}
@

<<function fmtfdinit>>=
/*
 * initialize an output buffer for buffered printing
 */
int
fmtfdinit(Fmt *f, int fd, char *buf, int size)
{
    f->runes = 0;
    f->start = buf;
    f->to = buf;
    f->stop = buf + size;
    f->flush = _fmtFdFlush;
    f->farg = (void*)fd;
    f->nfmt = 0;
    return 0;
}
@


%-------------------------------------------------------------

<<fmt/fmtfd.c>>=
#include <u.h>
#include <libc.h>
#include "fmtdef.h"

<<function fmtfdflush>>

<<function fmtfdinit>>
@


\subsection*{[[fmt/fmtlock.c]]}

<<global fmtl>>=
static Lock fmtl;
@

<<function _fmtlock>>=
void
_fmtlock(void)
{
    lock(&fmtl);
}
@

<<function _fmtunlock>>=
void
_fmtunlock(void)
{
    unlock(&fmtl);
}
@


%-------------------------------------------------------------

<<fmt/fmtlock.c>>=
#include <u.h>
#include <libc.h>

<<global fmtl>>

<<function _fmtlock>>

<<function _fmtunlock>>
@


\subsection*{[[fmt/fmtprint.c]]}

<<function fmtprint>>=
/*
 * format a string into the output buffer
 * designed for formats which themselves call fmt
 */
int
fmtprint(Fmt *f, char *fmt, ...)
{
    va_list va;
    int n;

    va_start(va, fmt);
    n = fmtvprint(f, fmt, va);
    va_end(va);
    return n;
}
@


%-------------------------------------------------------------

<<fmt/fmtprint.c>>=
#include <u.h>
#include <libc.h>
#include "fmtdef.h"


<<function fmtprint>>

@


\subsection*{[[fmt/fmtquote.c]]}

<<function _quotesetup>>=
/*
 * How many bytes of output UTF will be produced by quoting (if necessary) this string?
 * How many runes? How much of the input will be consumed?
 * The parameter q is filled in by _quotesetup.
 * The string may be UTF or Runes (s or r).
 * Return count does not include NUL.
 * Terminate the scan at the first of:
 *  NUL in input
 *  count exceeded in input
 *  count exceeded on output
 * *ninp is set to number of input bytes accepted.
 * nin may be <0 initially, to avoid checking input by count.
 */
void
_quotesetup(char *s, Rune *r, int nin, int nout, Quoteinfo *q, int sharp, int runesout)
{
    int w;
    Rune c;

    q->quoted = 0;
    q->nbytesout = 0;
    q->nrunesout = 0;
    q->nbytesin = 0;
    q->nrunesin = 0;
    if(sharp || nin==0 || (s && *s=='\0') || (r && *r=='\0')){
        if(nout < 2)
            return;
        q->quoted = 1;
        q->nbytesout = 2;
        q->nrunesout = 2;
    }
    for(; nin!=0; nin--){
        if(s)
            w = chartorune(&c, s);
        else{
            c = *r;
            w = runelen(c);
        }

        if(c == '\0')
            break;
        if(runesout){
            if(q->nrunesout+1 > nout)
                break;
        }else{
            if(q->nbytesout+w > nout)
                break;
        }

        if((c <= L' ') || (c == L'\'') || (doquote!=nil && doquote(c))){
            if(!q->quoted){
                if(runesout){
                    if(1+q->nrunesout+1+1 > nout)   /* no room for quotes */
                        break;
                }else{
                    if(1+q->nbytesout+w+1 > nout)   /* no room for quotes */
                        break;
                }
                q->nrunesout += 2;  /* include quotes */
                q->nbytesout += 2;  /* include quotes */
                q->quoted = 1;
            }
            if(c == '\'')   {
                if(runesout){
                    if(1+q->nrunesout+1 > nout) /* no room for quotes */
                        break;
                }else{
                    if(1+q->nbytesout+w > nout) /* no room for quotes */
                        break;
                }
                q->nbytesout++;
                q->nrunesout++; /* quotes reproduce as two characters */
            }
        }

        /* advance input */
        if(s)
            s += w;
        else
            r++;
        q->nbytesin += w;
        q->nrunesin++;

        /* advance output */
        q->nbytesout += w;
        q->nrunesout++;
    }
}
@

<<function qstrfmt>>=
static int
qstrfmt(char *sin, Rune *rin, Quoteinfo *q, Fmt *f)
{
    Rune r, *rm, *rme;
    char *t, *s, *m, *me;
    Rune *rt, *rs;
    ulong fl;
    int nc, w;

    m = sin;
    me = m + q->nbytesin;
    rm = rin;
    rme = rm + q->nrunesin;

    w = f->width;
    fl = f->flags;
    if(f->runes){
        if(!(fl & FmtLeft) && _rfmtpad(f, w - q->nrunesout) < 0)
            return -1;
    }else{
        if(!(fl & FmtLeft) && _fmtpad(f, w - q->nbytesout) < 0)
            return -1;
    }
    t = f->to;
    s = f->stop;
    rt = f->to;
    rs = f->stop;
    if(f->runes)
        FMTRCHAR(f, rt, rs, '\'');
    else
        FMTRUNE(f, t, s, '\'');
    for(nc = q->nrunesin; nc > 0; nc--){
        if(sin){
            r = *(uchar*)m;
            if(r < Runeself)
                m++;
            else if((me - m) >= UTFmax || fullrune(m, me-m))
                m += chartorune(&r, m);
            else
                break;
        }else{
            if(rm >= rme)
                break;
            r = *(uchar*)rm++;
        }
        if(f->runes){
            FMTRCHAR(f, rt, rs, r);
            if(r == '\'')
                FMTRCHAR(f, rt, rs, r);
        }else{
            FMTRUNE(f, t, s, r);
            if(r == '\'')
                FMTRUNE(f, t, s, r);
        }
    }

    if(f->runes){
        FMTRCHAR(f, rt, rs, '\'');
        USED(rs);
        f->nfmt += rt - (Rune *)f->to;
        f->to = rt;
        if(fl & FmtLeft && _rfmtpad(f, w - q->nrunesout) < 0)
            return -1;
    }else{
        FMTRUNE(f, t, s, '\'');
        USED(s);
        f->nfmt += t - (char *)f->to;
        f->to = t;
        if(fl & FmtLeft && _fmtpad(f, w - q->nbytesout) < 0)
            return -1;
    }
    return 0;
}
@

<<function _quotestrfmt>>=
int
_quotestrfmt(int runesin, Fmt *f)
{
    int nin, outlen;
    Rune *r;
    char *s;
    Quoteinfo q;

    nin = -1;
    if(f->flags&FmtPrec)
        nin = f->prec;
    if(runesin){
        r = va_arg(f->args, Rune *);
        s = nil;
    }else{
        s = va_arg(f->args, char *);
        r = nil;
    }
    if(!s && !r)
        return _fmtcpy(f, "<nil>", 5, 5);

    if(f->flush)
        outlen = 0x7FFFFFFF;    /* if we can flush, no output limit */
    else if(f->runes)
        outlen = (Rune*)f->stop - (Rune*)f->to;
    else
        outlen = (char*)f->stop - (char*)f->to;

    _quotesetup(s, r, nin, outlen, &q, f->flags&FmtSharp, f->runes);
//print("bytes in %d bytes out %d runes in %d runesout %d\n", q.nbytesin, q.nbytesout, q.nrunesin, q.nrunesout);

    if(runesin){
        if(!q.quoted)
            return _fmtrcpy(f, r, q.nrunesin);
        return qstrfmt(nil, r, &q, f);
    }

    if(!q.quoted)
        return _fmtcpy(f, s, q.nrunesin, q.nbytesin);
    return qstrfmt(s, nil, &q, f);
}
@

<<function quotestrfmt>>=
int
quotestrfmt(Fmt *f)
{
    return _quotestrfmt(0, f);
}
@

<<function quoterunestrfmt>>=
int
quoterunestrfmt(Fmt *f)
{
    return _quotestrfmt(1, f);
}
@

<<function quotefmtinstall>>=
void
quotefmtinstall(void)
{
    fmtinstall('q', quotestrfmt);
    fmtinstall('Q', quoterunestrfmt);
}
@

<<function _needsquotes>>=
int
_needsquotes(char *s, int *quotelenp)
{
    Quoteinfo q;

    _quotesetup(s, nil, -1, 0x7FFFFFFF, &q, 0, 0);
    *quotelenp = q.nbytesout;

    return q.quoted;
}
@

<<function _runeneedsquotes>>=
int
_runeneedsquotes(Rune *r, int *quotelenp)
{
    Quoteinfo q;

    _quotesetup(nil, r, -1, 0x7FFFFFFF, &q, 0, 0);
    *quotelenp = q.nrunesout;

    return q.quoted;
}
@


%-------------------------------------------------------------

<<fmt/fmtquote.c>>=
#include <u.h>
#include <libc.h>
#include "fmtdef.h"

<<function _quotesetup>>

<<function qstrfmt>>

<<function _quotestrfmt>>

<<function quotestrfmt>>

<<function quoterunestrfmt>>

<<function quotefmtinstall>>

<<function _needsquotes>>

<<function _runeneedsquotes>>
@


\subsection*{[[fmt/fmtrune.c]]}

<<function fmtrune>>=
int
fmtrune(Fmt *f, int r)
{
    Rune *rt;
    char *t;
    int n;

    if(f->runes){
        rt = f->to;
        FMTRCHAR(f, rt, f->stop, r);
        f->to = rt;
        n = 1;
    }else{
        t = f->to;
        FMTRUNE(f, t, f->stop, r);
        n = t - (char*)f->to;
        f->to = t;
    }
    f->nfmt += n;
    return 0;
}
@


%-------------------------------------------------------------

<<fmt/fmtrune.c>>=
#include <u.h>
#include <libc.h>
#include "fmtdef.h"

<<function fmtrune>>
@


\subsection*{[[fmt/fmtstr.c]]}

<<function fmtstrflush>>=
char*
fmtstrflush(Fmt *f)
{
    if(f->start == nil)
        return nil;
    *(char*)f->to = '\0';
    return f->start;
}
@


%-------------------------------------------------------------

<<fmt/fmtstr.c>>=
#include <u.h>
#include <libc.h>

<<function fmtstrflush>>
@


\subsection*{[[fmt/fmtvprint.c]]}

<<function fmtvprint>>=
/*
 * format a string into the output buffer
 * designed for formats which themselves call fmt
 */
int
fmtvprint(Fmt *f, char *fmt, va_list args)
{
    va_list va;
    int n;

    va = f->args;
    f->args = args;
    n = dofmt(f, fmt);
    f->args = va;
    if(n >= 0)
        return 0;
    return n;
}
@


%-------------------------------------------------------------

<<fmt/fmtvprint.c>>=
#include <u.h>
#include <libc.h>
#include "fmtdef.h"


<<function fmtvprint>>

@


\subsection*{[[fmt/fprint.c]]}

<<function fprint>>=
int
fprint(int fd, char *fmt, ...)
{
    int n;
    va_list args;

    va_start(args, fmt);
    n = vfprint(fd, fmt, args);
    va_end(args);
    return n;
}
@


%-------------------------------------------------------------

<<fmt/fprint.c>>=
#include    <u.h>
#include    <libc.h>

<<function fprint>>
@


\subsection*{[[fmt/print.c]]}

<<function libc_print>>=
int
libc_print(char *fmt, ...)
{
    int n;
    va_list args;

    va_start(args, fmt);
    n = vfprint(1, fmt, args);
    va_end(args);
    return n;
}
@

<<global print>>=
int (*print)(char *fmt, ...) = &libc_print;
@


%-------------------------------------------------------------

<<fmt/print.c>>=
#include    <u.h>
#include    <libc.h>

<<function libc_print>>

<<global print>>
@


\subsection*{[[fmt/runefmtstr.c]]}

<<function runefmtstrflush>>=
Rune*
runefmtstrflush(Fmt *f)
{
    if(f->start == nil)
        return nil;
    *(Rune*)f->to = '\0';
    return f->start;
}
@


%-------------------------------------------------------------

<<fmt/runefmtstr.c>>=
#include <u.h>
#include <libc.h>

<<function runefmtstrflush>>
@


\subsection*{[[fmt/runeseprint.c]]}

<<function runeseprint>>=
Rune*
runeseprint(Rune *buf, Rune *e, char *fmt, ...)
{
    Rune *p;
    va_list args;

    va_start(args, fmt);
    p = runevseprint(buf, e, fmt, args);
    va_end(args);
    return p;
}
@


%-------------------------------------------------------------

<<fmt/runeseprint.c>>=
#include <u.h>
#include <libc.h>

<<function runeseprint>>
@


\subsection*{[[fmt/runesmprint.c]]}

<<function runesmprint>>=
Rune*
runesmprint(char *fmt, ...)
{
    va_list args;
    Rune *p;

    va_start(args, fmt);
    p = runevsmprint(fmt, args);
    va_end(args);
    return p;
}
@


%-------------------------------------------------------------

<<fmt/runesmprint.c>>=
#include <u.h>
#include <libc.h>

<<function runesmprint>>
@


\subsection*{[[fmt/runesnprint.c]]}

<<function runesnprint>>=
int
runesnprint(Rune *buf, int len, char *fmt, ...)
{
    int n;
    va_list args;

    va_start(args, fmt);
    n = runevsnprint(buf, len, fmt, args);
    va_end(args);
    return n;
}
@


%-------------------------------------------------------------

<<fmt/runesnprint.c>>=
#include <u.h>
#include <libc.h>

<<function runesnprint>>

@


\subsection*{[[fmt/runesprint.c]]}

<<function runesprint>>=
int
runesprint(Rune *buf, char *fmt, ...)
{
    int n;
    va_list args;

    va_start(args, fmt);
    n = runevsnprint(buf, 256, fmt, args);
    va_end(args);
    return n;
}
@


%-------------------------------------------------------------

<<fmt/runesprint.c>>=
#include <u.h>
#include <libc.h>

<<function runesprint>>
@


\subsection*{[[fmt/runevseprint.c]]}

<<function runevseprint>>=
Rune*
runevseprint(Rune *buf, Rune *e, char *fmt, va_list args)
{
    Fmt f;

    if(e <= buf)
        return nil;
    f.runes = 1;
    f.start = buf;
    f.to = buf;
    f.stop = e - 1;
    f.flush = nil;
    f.farg = nil;
    f.nfmt = 0;
    f.args = args;
    dofmt(&f, fmt);
    *(Rune*)f.to = '\0';
    return f.to;
}
@


%-------------------------------------------------------------

<<fmt/runevseprint.c>>=
#include <u.h>
#include <libc.h>

<<function runevseprint>>

@


\subsection*{[[fmt/runevsmprint.c]]}

<<function runeFmtStrFlush>>=
static int
runeFmtStrFlush(Fmt *f)
{
    Rune *s;
    int n;

    if(f->start == nil)
        return 0;
    n = (int)(uintptr)f->farg;
    n *= 2;
    s = f->start;
    f->start = realloc(s, sizeof(Rune)*n);
    if(f->start == nil){
        f->farg = nil;
        f->to = nil;
        f->stop = nil;
        free(s);
        return 0;
    }
    f->farg = (void*)n;
    f->to = (Rune*)f->start + ((Rune*)f->to - s);
    f->stop = (Rune*)f->start + n - 1;
    return 1;
}
@

<<function runefmtstrinit>>=
int
runefmtstrinit(Fmt *f)
{
    int n;

    memset(f, 0, sizeof *f);
    f->runes = 1;
    n = 32;
    f->start = malloc(sizeof(Rune)*n);
    if(f->start == nil)
        return -1;
    setmalloctag(f->start, getcallerpc(&f));
    f->to = f->start;
    f->stop = (Rune*)f->start + n - 1;
    f->flush = runeFmtStrFlush;
    f->farg = (void*)n;
    f->nfmt = 0;
    return 0;
}
@

<<function runevsmprint>>=
/*
 * print into an allocated string buffer
 */
Rune*
runevsmprint(char *fmt, va_list args)
{
    Fmt f;
    int n;

    if(runefmtstrinit(&f) < 0)
        return nil;
    f.args = args;
    n = dofmt(&f, fmt);
    if(f.start == nil)      /* realloc failed? */
        return nil;
    if(n < 0){
        free(f.start);
        return nil;
    }
    setmalloctag(f.start, getcallerpc(&fmt));
    *(Rune*)f.to = '\0';
    return f.start;
}
@


%-------------------------------------------------------------

<<fmt/runevsmprint.c>>=
#include <u.h>
#include <libc.h>
#include "fmtdef.h"

<<function runeFmtStrFlush>>

<<function runefmtstrinit>>

<<function runevsmprint>>
@


\subsection*{[[fmt/runevsnprint.c]]}

<<function runevsnprint>>=
int
runevsnprint(Rune *buf, int len, char *fmt, va_list args)
{
    Fmt f;

    if(len <= 0)
        return -1;
    f.runes = 1;
    f.start = buf;
    f.to = buf;
    f.stop = buf + len - 1;
    f.flush = nil;
    f.farg = nil;
    f.nfmt = 0;
    f.args = args;
    dofmt(&f, fmt);
    *(Rune*)f.to = '\0';
    return (Rune*)f.to - buf;
}
@


%-------------------------------------------------------------

<<fmt/runevsnprint.c>>=
#include <u.h>
#include <libc.h>

<<function runevsnprint>>
@


\subsection*{[[fmt/seprint.c]]}

<<function seprint>>=
char*
seprint(char *buf, char *e, char *fmt, ...)
{
    char *p;
    va_list args;

    va_start(args, fmt);
    p = vseprint(buf, e, fmt, args);
    va_end(args);
    return p;
}
@


%-------------------------------------------------------------

<<fmt/seprint.c>>=
#include <u.h>
#include <libc.h>

<<function seprint>>
@


\subsection*{[[fmt/smprint.c]]}

<<function smprint>>=
char*
smprint(char *fmt, ...)
{
    va_list args;
    char *p;

    va_start(args, fmt);
    p = vsmprint(fmt, args);
    va_end(args);
    setmalloctag(p, getcallerpc(&fmt));
    return p;
}
@


%-------------------------------------------------------------

<<fmt/smprint.c>>=
#include <u.h>
#include <libc.h>

<<function smprint>>
@


\subsection*{[[fmt/snprint.c]]}

<<function snprint>>=
int
snprint(char *buf, int len, char *fmt, ...)
{
    int n;
    va_list args;

    va_start(args, fmt);
    n = vsnprint(buf, len, fmt, args);
    va_end(args);
    return n;
}
@


%-------------------------------------------------------------

<<fmt/snprint.c>>=
#include <u.h>
#include <libc.h>

<<function snprint>>

@


\subsection*{[[fmt/sprint.c]]}

<<function sprint>>=
int
sprint(char *buf, char *fmt, ...)
{
    int n;
    va_list args;

    va_start(args, fmt);
    n = vsnprint(buf, 65536, fmt, args);    /* big number, but sprint is deprecated anyway */
    va_end(args);
    return n;
}
@


%-------------------------------------------------------------

<<fmt/sprint.c>>=
#include <u.h>
#include <libc.h>

<<function sprint>>
@


\subsection*{[[fmt/vfprint.c]]}

<<function _fmtFdFlush>>=
/*
 * generic routine for flushing a formatting buffer
 * to a file descriptor
 */
int
_fmtFdFlush(Fmt *f)
{
    int n;

    n = (char*)f->to - (char*)f->start;
    if(n && write((int)(uintptr)f->farg, f->start, n) != n)
        return 0;
    f->to = f->start;
    return 1;
}
@

<<function vfprint>>=
int
vfprint(int fd, char *fmt, va_list args)
{
    Fmt f;
    char buf[256];
    int n;

    fmtfdinit(&f, fd, buf, sizeof(buf));
    f.args = args;
    n = dofmt(&f, fmt);
    if(n > 0 && _fmtFdFlush(&f) == 0)
        return -1;
    return n;
}
@


%-------------------------------------------------------------

<<fmt/vfprint.c>>=
#include <u.h>
#include <libc.h>
#include "fmtdef.h"

<<function _fmtFdFlush>>

<<function vfprint>>
@


\subsection*{[[fmt/vseprint.c]]}

<<function vseprint>>=
char*
vseprint(char *buf, char *e, char *fmt, va_list args)
{
    Fmt f;

    if(e <= buf)
        return nil;
    f.runes = 0;
    f.start = buf;
    f.to = buf;
    f.stop = e - 1;
    f.flush = nil;
    f.farg = nil;
    f.nfmt = 0;
    f.args = args;
    dofmt(&f, fmt);
    *(char*)f.to = '\0';
    return f.to;
}
@


%-------------------------------------------------------------

<<fmt/vseprint.c>>=
#include <u.h>
#include <libc.h>

<<function vseprint>>

@


\subsection*{[[fmt/vsmprint.c]]}

<<function fmtStrFlush>>=
static int
fmtStrFlush(Fmt *f)
{
    char *s;
    int n;

    if(f->start == nil)
        return 0;
    n = (int)(uintptr)f->farg;
    n *= 2;
    s = f->start;
    f->start = realloc(s, n);
    if(f->start == nil){
        f->farg = nil;
        f->to = nil;
        f->stop = nil;
        free(s);
        return 0;
    }
    f->farg = (void*)n;
    f->to = (char*)f->start + ((char*)f->to - s);
    f->stop = (char*)f->start + n - 1;
    return 1;
}
@

<<function fmtstrinit>>=
int
fmtstrinit(Fmt *f)
{
    int n;

    memset(f, 0, sizeof *f);
    f->runes = 0;
    n = 32;
    f->start = malloc(n);
    if(f->start == nil)
        return -1;
    setmalloctag(f->start, getcallerpc(&f));
    f->to = f->start;
    f->stop = (char*)f->start + n - 1;
    f->flush = fmtStrFlush;
    f->farg = (void*)n;
    f->nfmt = 0;
    return 0;
}
@

<<function vsmprint>>=
/*
 * print into an allocated string buffer
 */
char*
vsmprint(char *fmt, va_list args)
{
    Fmt f;
    int n;

    if(fmtstrinit(&f) < 0)
        return nil;
    f.args = args;
    n = dofmt(&f, fmt);
    if(f.start == nil)      /* realloc failed? */
        return nil;
    if(n < 0){
        free(f.start);
        return nil;
    }
    setmalloctag(f.start, getcallerpc(&fmt));
    *(char*)f.to = '\0';
    return f.start;
}
@


%-------------------------------------------------------------

<<fmt/vsmprint.c>>=
#include <u.h>
#include <libc.h>
#include "fmtdef.h"

<<function fmtStrFlush>>

<<function fmtstrinit>>

<<function vsmprint>>
@


\subsection*{[[fmt/vsnprint.c]]}

<<function vsnprint>>=
int
vsnprint(char *buf, int len, char *fmt, va_list args)
{
    Fmt f;

    if(len <= 0)
        return -1;
    f.runes = 0;
    f.start = buf;
    f.to = buf;
    f.stop = buf + len - 1;
    f.flush = nil;
    f.farg = nil;
    f.nfmt = 0;
    f.args = args;
    dofmt(&f, fmt);
    *(char*)f.to = '\0';
    return (char*)f.to - buf;
}
@


%-------------------------------------------------------------

<<fmt/vsnprint.c>>=
#include <u.h>
#include <libc.h>

<<function vsnprint>>
@



\section{[[lib_core/libc/arm/]]}

\subsection*{[[arm/cycles.c]]}

<<function cycles>>=
void
cycles(uvlong* u)
{
    *u = 0LL;
}
@


%-------------------------------------------------------------

<<arm/cycles.c>>=
#include <u.h>
#include <libc.h>

#pragma profile off

<<function cycles>>
@


\subsection*{[[arm/notejmp.c]]}

<<function notejmp>>=
void
notejmp(void *vr, jmp_buf j, int ret)
{
    struct Ureg *r = vr;

    r->r0 = ret;
    if(ret == 0)
        r->r0 = 1;
    r->pc = j[JMPBUFPC];
    r->r13 = j[JMPBUFSP];
    noted(NCONT);
}
@


%-------------------------------------------------------------

<<arm/notejmp.c>>=
#include <u.h>
#include <libc.h>
#include <ureg.h>

<<function notejmp>>
@


\subsection*{[[arm/vlrt.c]]}

<<macro SIGN>>=
#define SIGN(n) (1UL<<(n-1))
@

<<struct Vlong>>=
struct  Vlong
{
    ulong   lo;
    ulong   hi;
};
@

<<function _addv>>=
void
_addv(Vlong *r, Vlong a, Vlong b)
{
    ulong lo, hi;

    lo = a.lo + b.lo;
    hi = a.hi + b.hi;
    if(lo < a.lo)
        hi++;
    r->lo = lo;
    r->hi = hi;
}
@

<<function _subv>>=
void
_subv(Vlong *r, Vlong a, Vlong b)
{
    ulong lo, hi;

    lo = a.lo - b.lo;
    hi = a.hi - b.hi;
    if(lo > a.lo)
        hi--;
    r->lo = lo;
    r->hi = hi;
}
@

<<function _d2v>>=
void
_d2v(Vlong *y, double d)
{
    union { double d; struct Vlong; } x;
    ulong xhi, xlo, ylo, yhi;
    int sh;

    x.d = d;

    xhi = (x.hi & 0xfffff) | 0x100000;
    xlo = x.lo;
    sh = 1075 - ((x.hi >> 20) & 0x7ff);

    ylo = 0;
    yhi = 0;
    if(sh >= 0) {
        /* v = (hi||lo) >> sh */
        if(sh < 32) {
            if(sh == 0) {
                ylo = xlo;
                yhi = xhi;
            } else {
                ylo = (xlo >> sh) | (xhi << (32-sh));
                yhi = xhi >> sh;
            }
        } else {
            if(sh == 32) {
                ylo = xhi;
            } else
            if(sh < 64) {
                ylo = xhi >> (sh-32);
            }
        }
    } else {
        /* v = (hi||lo) << -sh */
        sh = -sh;
        if(sh <= 10) {
            ylo = xlo << sh;
            yhi = (xhi << sh) | (xlo >> (32-sh));
        } else {
            /* overflow */
            yhi = d;    /* causes something awful */
        }
    }
    if(x.hi & SIGN(32)) {
        if(ylo != 0) {
            ylo = -ylo;
            yhi = ~yhi;
        } else
            yhi = -yhi;
    }

    y->hi = yhi;
    y->lo = ylo;
}
@

<<function _f2v>>=
void
_f2v(Vlong *y, float f)
{
    _d2v(y, f);
}
@

<<function _v2d>>=
double
_v2d(Vlong x)
{
    if(x.hi & SIGN(32)) {
        if(x.lo) {
            x.lo = -x.lo;
            x.hi = ~x.hi;
        } else
            x.hi = -x.hi;
        return -((long)x.hi*4294967296. + x.lo);
    }
    return (long)x.hi*4294967296. + x.lo;
}
@

<<function _v2f>>=
float
_v2f(Vlong x)
{
    return _v2d(x);
}
@

<<function dodiv>>=
static void
dodiv(Vlong num, Vlong den, Vlong *q, Vlong *r)
{
    ulong numlo, numhi, denhi, denlo, quohi, quolo, t;
    int i;

    numhi = num.hi;
    numlo = num.lo;
    denhi = den.hi;
    denlo = den.lo;
    /*
     * get a divide by zero
     */
    if(denlo==0 && denhi==0) {
        numlo = numlo / denlo;
    }

    /*
     * set up the divisor and find the number of iterations needed
     */
    if(numhi >= SIGN(32)) {
        quohi = SIGN(32);
        quolo = 0;
    } else {
        quohi = numhi;
        quolo = numlo;
    }
    i = 0;
    while(denhi < quohi || (denhi == quohi && denlo < quolo)) {
        denhi = (denhi<<1) | (denlo>>31);
        denlo <<= 1;
        i++;
    }

    quohi = 0;
    quolo = 0;
    for(; i >= 0; i--) {
        quohi = (quohi<<1) | (quolo>>31);
        quolo <<= 1;
        if(numhi > denhi || (numhi == denhi && numlo >= denlo)) {
            t = numlo;
            numlo -= denlo;
            if(numlo > t)
                numhi--;
            numhi -= denhi;
            quolo |= 1;
        }
        denlo = (denlo>>1) | (denhi<<31);
        denhi >>= 1;
    }

    if(q) {
        q->lo = quolo;
        q->hi = quohi;
    }
    if(r) {
        r->lo = numlo;
        r->hi = numhi;
    }
}
@

<<function _divvu>>=
void
_divvu(Vlong *q, Vlong n, Vlong d)
{
    if(n.hi == 0 && d.hi == 0) {
        q->hi = 0;
        q->lo = n.lo / d.lo;
        return;
    }
    dodiv(n, d, q, 0);
}
@

<<function _modvu>>=
void
_modvu(Vlong *r, Vlong n, Vlong d)
{

    if(n.hi == 0 && d.hi == 0) {
        r->hi = 0;
        r->lo = n.lo % d.lo;
        return;
    }
    dodiv(n, d, 0, r);
}
@

<<function vneg>>=
static void
vneg(Vlong *v)
{

    if(v->lo == 0) {
        v->hi = -v->hi;
        return;
    }
    v->lo = -v->lo;
    v->hi = ~v->hi;
}
@

<<function _divv>>=
void
_divv(Vlong *q, Vlong n, Vlong d)
{
    long nneg, dneg;

    if(n.hi == (((long)n.lo)>>31) && d.hi == (((long)d.lo)>>31)) {
        q->lo = (long)n.lo / (long)d.lo;
        q->hi = ((long)q->lo) >> 31;
        return;
    }
    nneg = n.hi >> 31;
    if(nneg)
        vneg(&n);
    dneg = d.hi >> 31;
    if(dneg)
        vneg(&d);
    dodiv(n, d, q, 0);
    if(nneg != dneg)
        vneg(q);
}
@

<<function _modv>>=
void
_modv(Vlong *r, Vlong n, Vlong d)
{
    long nneg, dneg;

    if(n.hi == (((long)n.lo)>>31) && d.hi == (((long)d.lo)>>31)) {
        r->lo = (long)n.lo % (long)d.lo;
        r->hi = ((long)r->lo) >> 31;
        return;
    }
    nneg = n.hi >> 31;
    if(nneg)
        vneg(&n);
    dneg = d.hi >> 31;
    if(dneg)
        vneg(&d);
    dodiv(n, d, 0, r);
    if(nneg)
        vneg(r);
}
@

<<function _rshav>>=
void
_rshav(Vlong *r, Vlong a, int b)
{
    long t;

    t = a.hi;
    if(b >= 32) {
        r->hi = t>>31;
        if(b >= 64) {
            /* this is illegal re C standard */
            r->lo = t>>31;
            return;
        }
        r->lo = t >> (b-32);
        return;
    }
    if(b <= 0) {
        r->hi = t;
        r->lo = a.lo;
        return;
    }
    r->hi = t >> b;
    r->lo = (t << (32-b)) | (a.lo >> b);
}
@

<<function _rshlv>>=
void
_rshlv(Vlong *r, Vlong a, int b)
{
    ulong t;

    t = a.hi;
    if(b >= 32) {
        r->hi = 0;
        if(b >= 64) {
            /* this is illegal re C standard */
            r->lo = 0;
            return;
        }
        r->lo = t >> (b-32);
        return;
    }
    if(b <= 0) {
        r->hi = t;
        r->lo = a.lo;
        return;
    }
    r->hi = t >> b;
    r->lo = (t << (32-b)) | (a.lo >> b);
}
@

<<function _lshv>>=
void
_lshv(Vlong *r, Vlong a, int b)
{
    ulong t;

    t = a.lo;
    if(b >= 32) {
        r->lo = 0;
        if(b >= 64) {
            /* this is illegal re C standard */
            r->hi = 0;
            return;
        }
        r->hi = t << (b-32);
        return;
    }
    if(b <= 0) {
        r->lo = t;
        r->hi = a.hi;
        return;
    }
    r->lo = t << b;
    r->hi = (t >> (32-b)) | (a.hi << b);
}
@

<<function _andv>>=
void
_andv(Vlong *r, Vlong a, Vlong b)
{
    r->hi = a.hi & b.hi;
    r->lo = a.lo & b.lo;
}
@

<<function _orv>>=
void
_orv(Vlong *r, Vlong a, Vlong b)
{
    r->hi = a.hi | b.hi;
    r->lo = a.lo | b.lo;
}
@

<<function _xorv>>=
void
_xorv(Vlong *r, Vlong a, Vlong b)
{
    r->hi = a.hi ^ b.hi;
    r->lo = a.lo ^ b.lo;
}
@

<<function _vpp>>=
void
_vpp(Vlong *l, Vlong *r)
{

    l->hi = r->hi;
    l->lo = r->lo;
    r->lo++;
    if(r->lo == 0)
        r->hi++;
}
@

<<function _vmm>>=
void
_vmm(Vlong *l, Vlong *r)
{

    l->hi = r->hi;
    l->lo = r->lo;
    if(r->lo == 0)
        r->hi--;
    r->lo--;
}
@

<<function _ppv>>=
void
_ppv(Vlong *l, Vlong *r)
{

    r->lo++;
    if(r->lo == 0)
        r->hi++;
    l->hi = r->hi;
    l->lo = r->lo;
}
@

<<function _mmv>>=
void
_mmv(Vlong *l, Vlong *r)
{

    if(r->lo == 0)
        r->hi--;
    r->lo--;
    l->hi = r->hi;
    l->lo = r->lo;
}
@

<<function _vasop>>=
void
_vasop(Vlong *ret, void *lv, void fn(Vlong*, Vlong, Vlong), int type, Vlong rv)
{
    Vlong t, u;

    u = *ret;
    switch(type) {
    default:
        abort();
        break;

    case 1: /* schar */
        t.lo = *(schar*)lv;
        t.hi = t.lo >> 31;
        fn(&u, t, rv);
        *(schar*)lv = u.lo;
        break;

    case 2: /* uchar */
        t.lo = *(uchar*)lv;
        t.hi = 0;
        fn(&u, t, rv);
        *(uchar*)lv = u.lo;
        break;

    case 3: /* short */
        t.lo = *(short*)lv;
        t.hi = t.lo >> 31;
        fn(&u, t, rv);
        *(short*)lv = u.lo;
        break;

    case 4: /* ushort */
        t.lo = *(ushort*)lv;
        t.hi = 0;
        fn(&u, t, rv);
        *(ushort*)lv = u.lo;
        break;

    case 9: /* int */
        t.lo = *(int*)lv;
        t.hi = t.lo >> 31;
        fn(&u, t, rv);
        *(int*)lv = u.lo;
        break;

    case 10:    /* uint */
        t.lo = *(uint*)lv;
        t.hi = 0;
        fn(&u, t, rv);
        *(uint*)lv = u.lo;
        break;

    case 5: /* long */
        t.lo = *(long*)lv;
        t.hi = t.lo >> 31;
        fn(&u, t, rv);
        *(long*)lv = u.lo;
        break;

    case 6: /* ulong */
        t.lo = *(ulong*)lv;
        t.hi = 0;
        fn(&u, t, rv);
        *(ulong*)lv = u.lo;
        break;

    case 7: /* vlong */
    case 8: /* uvlong */
        fn(&u, *(Vlong*)lv, rv);
        *(Vlong*)lv = u;
        break;
    }
    *ret = u;
}
@

<<function _p2v>>=
void
_p2v(Vlong *ret, void *p)
{
    long t;

    t = (ulong)p;
    ret->lo = t;
    ret->hi = 0;
}
@

<<function _sl2v>>=
void
_sl2v(Vlong *ret, long sl)
{
    long t;

    t = sl;
    ret->lo = t;
    ret->hi = t >> 31;
}
@

<<function _ul2v>>=
void
_ul2v(Vlong *ret, ulong ul)
{
    long t;

    t = ul;
    ret->lo = t;
    ret->hi = 0;
}
@

<<function _si2v>>=
void
_si2v(Vlong *ret, int si)
{
    long t;

    t = si;
    ret->lo = t;
    ret->hi = t >> 31;
}
@

<<function _ui2v>>=
void
_ui2v(Vlong *ret, uint ui)
{
    long t;

    t = ui;
    ret->lo = t;
    ret->hi = 0;
}
@

<<function _sh2v>>=
void
_sh2v(Vlong *ret, long sh)
{
    long t;

    t = (sh << 16) >> 16;
    ret->lo = t;
    ret->hi = t >> 31;
}
@

<<function _uh2v>>=
void
_uh2v(Vlong *ret, ulong ul)
{
    long t;

    t = ul & 0xffff;
    ret->lo = t;
    ret->hi = 0;
}
@

<<function _sc2v>>=
void
_sc2v(Vlong *ret, long uc)
{
    long t;

    t = (uc << 24) >> 24;
    ret->lo = t;
    ret->hi = t >> 31;
}
@

<<function _uc2v>>=
void
_uc2v(Vlong *ret, ulong ul)
{
    long t;

    t = ul & 0xff;
    ret->lo = t;
    ret->hi = 0;
}
@

<<function _v2sc>>=
long
_v2sc(Vlong rv)
{
    long t;

    t = rv.lo & 0xff;
    return (t << 24) >> 24;
}
@

<<function _v2uc>>=
long
_v2uc(Vlong rv)
{

    return rv.lo & 0xff;
}
@

<<function _v2sh>>=
long
_v2sh(Vlong rv)
{
    long t;

    t = rv.lo & 0xffff;
    return (t << 16) >> 16;
}
@

<<function _v2uh>>=
long
_v2uh(Vlong rv)
{

    return rv.lo & 0xffff;
}
@

<<function _v2sl>>=
long
_v2sl(Vlong rv)
{

    return rv.lo;
}
@

<<function _v2ul>>=
long
_v2ul(Vlong rv)
{

    return rv.lo;
}
@

<<function _v2si>>=
long
_v2si(Vlong rv)
{

    return rv.lo;
}
@

<<function _v2ui>>=
long
_v2ui(Vlong rv)
{

    return rv.lo;
}
@

<<function _testv>>=
int
_testv(Vlong rv)
{
    return rv.lo || rv.hi;
}
@

<<function _eqv>>=
int
_eqv(Vlong lv, Vlong rv)
{
    return lv.lo == rv.lo && lv.hi == rv.hi;
}
@

<<function _nev>>=
int
_nev(Vlong lv, Vlong rv)
{
    return lv.lo != rv.lo || lv.hi != rv.hi;
}
@

<<function _ltv>>=
int
_ltv(Vlong lv, Vlong rv)
{
    return (long)lv.hi < (long)rv.hi || 
        (lv.hi == rv.hi && lv.lo < rv.lo);
}
@

<<function _lev>>=
int
_lev(Vlong lv, Vlong rv)
{
    return (long)lv.hi < (long)rv.hi || 
        (lv.hi == rv.hi && lv.lo <= rv.lo);
}
@

<<function _gtv>>=
int
_gtv(Vlong lv, Vlong rv)
{
    return (long)lv.hi > (long)rv.hi || 
        (lv.hi == rv.hi && lv.lo > rv.lo);
}
@

<<function _gev>>=
int
_gev(Vlong lv, Vlong rv)
{
    return (long)lv.hi > (long)rv.hi || 
        (lv.hi == rv.hi && lv.lo >= rv.lo);
}
@

<<function _lov>>=
int
_lov(Vlong lv, Vlong rv)
{
    return lv.hi < rv.hi || 
        (lv.hi == rv.hi && lv.lo < rv.lo);
}
@

<<function _lsv>>=
int
_lsv(Vlong lv, Vlong rv)
{
    return lv.hi < rv.hi || 
        (lv.hi == rv.hi && lv.lo <= rv.lo);
}
@

<<function _hiv>>=
int
_hiv(Vlong lv, Vlong rv)
{
    return lv.hi > rv.hi || 
        (lv.hi == rv.hi && lv.lo > rv.lo);
}
@

<<function _hsv>>=
int
_hsv(Vlong lv, Vlong rv)
{
    return lv.hi > rv.hi || 
        (lv.hi == rv.hi && lv.lo >= rv.lo);
}
@


%-------------------------------------------------------------

<<arm/vlrt.c>>=
typedef unsigned long   ulong;
typedef unsigned int    uint;
typedef unsigned short  ushort;
typedef unsigned char   uchar;
typedef signed char schar;

<<macro SIGN>>

typedef struct  Vlong   Vlong;
<<struct Vlong>>

void    abort(void);

/* needed by profiler; can't be profiled */
#pragma profile off

<<function _addv>>

<<function _subv>>

#pragma profile on

<<function _d2v>>

<<function _f2v>>

<<function _v2d>>

<<function _v2f>>

/* too many of these are also needed by profiler; leave them out */
#pragma profile off

<<function dodiv>>

<<function _divvu>>

<<function _modvu>>

<<function vneg>>

<<function _divv>>

<<function _modv>>

<<function _rshav>>

<<function _rshlv>>

<<function _lshv>>

<<function _andv>>

<<function _orv>>

<<function _xorv>>

<<function _vpp>>

<<function _vmm>>

<<function _ppv>>

<<function _mmv>>

<<function _vasop>>

<<function _p2v>>

<<function _sl2v>>


<<function _ul2v>>

<<function _si2v>>

<<function _ui2v>>

<<function _sh2v>>

<<function _uh2v>>

<<function _sc2v>>

<<function _uc2v>>

<<function _v2sc>>

<<function _v2uc>>

<<function _v2sh>>

<<function _v2uh>>

<<function _v2sl>>

<<function _v2ul>>

<<function _v2si>>

<<function _v2ui>>

<<function _testv>>

<<function _eqv>>

<<function _nev>>

<<function _ltv>>

<<function _lev>>

<<function _gtv>>

<<function _gev>>

<<function _lov>>

<<function _lsv>>

<<function _hiv>>

<<function _hsv>>
@



\section{[[lib_core/libthread/]]}

\subsection*{[[lib_core/libthread/ref.c]]}

%-------------------------------------------------------------

<<lib_core/libthread/ref.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<function incref>>

<<function decref>>
@


\subsection*{[[lib_core/libthread/threadimpl.h]]}

<<enum _anon_ (lib_core/libthread/threadimpl.h)>>=
enum
{
<<constant RENDHASH>>
<<constant Printsize>>
<<constant NPRIV>>
};
@

%-------------------------------------------------------------


<<lib_core/libthread/threadimpl.h>>=
/* 
 * Some notes on locking:
 *
 *  All the locking woes come from implementing
 *  threadinterrupt (and threadkill).
 *
 *  _threadgetproc()->thread is always a live pointer.
 *  p->threads, p->ready, and _threadrgrp also contain
 *  live thread pointers.  These may only be consulted
 *  while holding p->lock or _threadrgrp.lock; in procs
 *  other than p, the pointers are only guaranteed to be live
 *  while the lock is still being held.
 *
 *  Thread structures can only be freed by the proc
 *  they belong to.  Threads marked with t->inrendez
 *  need to be extracted from the _threadrgrp before
 *  being freed.
 *
 *  _threadrgrp.lock cannot be acquired while holding p->lock.
 */

typedef struct Pqueue   Pqueue;
typedef struct Rgrp Rgrp;
typedef struct Tqueue   Tqueue;
typedef struct Thread   Thread;
typedef struct Execargs Execargs;
typedef struct Proc Proc;


/* must match list in sched.c */
<<enum state>>
typedef enum state State;
    
<<enum chanstate>>
typedef enum chanstate Chanstate;

<<enum _anon_ (lib_core/libthread/threadimpl.h)>>

<<struct Rgrp>>

<<struct Tqueue>>

<<struct Thread>>

<<struct Execargs>>

<<struct Proc>>

<<struct Pqueue>>

<<struct Ioproc>>

void    _freeproc(Proc*);
void    _freethread(Thread*);
Proc*   _newproc(void(*)(void*), void*, uint, char*, int, int);
int _procsplhi(void);
void    _procsplx(int);
void    _sched(void);
int _schedexec(Execargs*);
void    _schedexecwait(void);
void    _schedexit(Proc*);
int _schedfork(Proc*);
void    _schedinit(void*);
void    _systhreadinit(void);
void    _threadassert(char*);
void    _threadbreakrendez(void);
void    _threaddebug(ulong, char*, ...);
void    _threadexitsall(char*);
void    _threadflagrendez(Thread*);
Proc*   _threadgetproc(void);
void    _threadsetproc(Proc*);
void    _threadinitstack(Thread*, void(*)(void*), void*);
void*   _threadmalloc(long, int);
void    _threadnote(void*, char*);
void    _threadready(Thread*);
void*   _threadrendezvous(void*, void*);
void    _threadsignal(void);
void    _threadsysfatal(char*, va_list);
void**  _workerdata(void);
void    _xinc(long*);
long    _xdec(long*);

extern int      _threaddebuglevel;
extern char*        _threadexitsallstatus;
extern Pqueue       _threadpq;
extern Channel*     _threadwaitchan;
extern Rgrp     _threadrgrp;

<<constant DBGAPPL>>
<<constant DBGSCHED>>
<<constant DBGCHAN>>
<<constant DBGREND>>
<<constant DBGNOTE>>
<<constant DBGEXEC>>

<<function ioproc_arg>>
@


\subsection*{[[lib_core/libthread/xincarm.c]]}

%-------------------------------------------------------------

<<lib_core/libthread/xincarm.c>>=
#include "xincport.h"
@


\subsection*{[[lib_core/libthread/xincport.h]]}

%-------------------------------------------------------------

<<lib_core/libthread/xincport.h>>=
#include <u.h>
#include <libc.h>
#include <thread.h>

<<global xincport_lock>>

<<function _xinc>>

<<function _xdec>>
@


\subsection*{[[lib_core/libthread/globals.c]]}

%-------------------------------------------------------------

<<lib_core/libthread/globals.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<global _threadpq>>

<<global procp>>

<<function _systhreadinit>>

<<function _threadgetproc>>

<<function _threadsetproc>>
@


\subsection*{[[lib_core/libthread/debug.c]]}


%-------------------------------------------------------------

<<lib_core/libthread/debug.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<global _threaddebuglevel>>

<<function _threaddebug>>

<<function _threadassert>>
@


\subsection*{[[lib_core/libthread/id.c]]}

%-------------------------------------------------------------

<<lib_core/libthread/id.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"
#include <tos.h>

<<function threadid>>

<<function threadpid>>

<<function threadsetgrp>>

<<function threadgetgrp>>

<<function threadsetname>>

<<function threadgetname>>

<<function threaddata>>

<<function _workerdata>>

<<function procdata>>

<<global privlock (libthread/id.c)>>
<<global privmask>>

<<function tprivalloc>>

<<function tprivfree>>

<<function tprivaddr>>
@


\subsection*{[[lib_core/libthread/exit.c]]}

%-------------------------------------------------------------

<<lib_core/libthread/exit.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"
#include <tos.h>

<<global _threadexitsallstatus>>
<<global _threadwaitchan>>

<<function threadexits>>

<<function threadexitsall>>

<<function threadwaitchan>>
@


\subsection*{[[lib_core/libthread/lib.c]]}


%-------------------------------------------------------------

<<lib_core/libthread/lib.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<global totalmalloc>>

<<function _threadmalloc>>

<<function _threadsysfatal>>
@


\subsection*{[[lib_core/libthread/note.c]]}

%-------------------------------------------------------------

<<lib_core/libthread/note.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

typedef struct Note Note;

<<global _threadnopasser>>

<<constant NFN (libthread/note.c)>>
<<constant ERRLEN>>
<<struct Note>>

<<global notes>>
<<global enotes>>
<<global onnote>>
<<global onnotepid>>
<<global onnotelock>>

<<function threadnotify>>

<<function delayednotes>>

<<function _threadnote>>

<<function _procsplhi>>

<<function _procsplx>>

@

\subsection*{[[lib_core/libthread/rendez.c]]}

%-------------------------------------------------------------

<<lib_core/libthread/rendez.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<global _threadrgrp>>
<<global isdirty>>

<<function finish>>

<<function _threadrendezvous>>

<<function _threadflagrendez>>

<<function _threadbreakrendez>>
@


\subsection*{[[lib_core/libthread/386.c]]}

%-------------------------------------------------------------

<<lib_core/libthread/386.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>

#include "threadimpl.h"

<<function launcher386>>

<<function _threadinitstack>>

@


\subsection*{[[lib_core/libthread/sched.c]]}


%-------------------------------------------------------------

<<lib_core/libthread/sched.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"
#include <tos.h>

static Thread   *runthread(Proc*);

<<global _psstate>>

<<function psstate>>

<<function _schedinit>>

<<function needstack>>

<<function _sched>>

<<function runthread>>

<<function _threadready>>

<<function yield>>

@


\subsection*{[[lib_core/libthread/create.c]]}

%-------------------------------------------------------------

<<lib_core/libthread/create.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<function nextID>>
    
<<function newthread>>

<<function threadcreate>>

<<function _newproc>>

<<function procrfork>>

<<function proccreate>>

<<function _freeproc>>

<<function _freethread>>

@


\subsection*{[[lib_core/libthread/channel.c]]}

%-------------------------------------------------------------

<<lib_core/libthread/channel.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<enum _anon_ (lib_core/libthread/channel.c)>>

<<global errcl>>
<<global chanlock>>

static void enqueue(Alt*, Channel**);
static void dequeue(Alt*);
static int canexec(Alt*);
static int altexec(Alt*, int);

<<constant Closed>>
<<constant Intred>>

<<function _chanfree>>

<<function chanfree>>

<<function chaninit>>

<<function chancreate>>

<<function isopenfor>>

<<function alt>>

<<function chanclose>>

<<function chanclosing>>

<<function runop>>

<<function recv>>

<<function nbrecv>>

<<function send>>

<<function nbsend>>

<<function channelsize>>

<<function sendul>>

<<function recvul>>

<<function sendp>>

<<function recvp>>

<<function nbsendul>>

<<function nbrecvul>>

<<function nbsendp>>

<<function nbrecvp>>

<<function emptyentry>>

<<function enqueue>>

<<function dequeue>>

<<function canexec>>

<<function altexecbuffered>>

<<function altcopy>>

<<function altexec>>
@


\subsection*{[[lib_core/libthread/main.c]]}

%-------------------------------------------------------------

<<lib_core/libthread/main.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

typedef struct Mainarg Mainarg;

<<struct Mainarg>>

<<global mainstacksize>>
<<global _threadnotefd>>
<<global _threadpasserpid>>

<<global _mainjmp>>

static void mainlauncher(void*);
extern void (*_sysfatal)(char*, va_list);
extern void (*__assert)(char*);
extern int (*_dial)(char*, char*, char*, int*);

extern int _threaddial(char*, char*, char*, int*);

<<global mainp>>

<<function main>>

<<function mainlauncher>>

<<function skip (libthread/main.c)>>

<<function _times>>

<<function efork>>

<<function _schedexec>>

<<function _schedfork>>

<<function _schedexit>>

<<function _schedexecwait>>

@


\subsection*{[[lib_core/libthread/kill.c]]}

%-------------------------------------------------------------

<<lib_core/libthread/kill.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

static void tinterrupt(Proc*, Thread*);

<<function threadxxxgrp>>

<<function threadxxx>>

<<function threadkillgrp>>

<<function threadkill>>

<<function threadintgrp>>

<<function threadint>>

<<function tinterrupt>>
@


\subsection*{[[lib_core/libthread/ioproc.c]]}

<<enum _anon_ (lib_core/libthread/ioproc.c)>>=
enum
{
    <<constant STACK>>
};
@

%-------------------------------------------------------------

<<lib_core/libthread/ioproc.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<enum _anon_ (lib_core/libthread/ioproc.c)>>

<<function iointerrupt>>

<<function xioproc>>

<<function ioproc>>

<<function closeioproc>>
@


\subsection*{[[lib_core/libthread/iocall.c]]}


%-------------------------------------------------------------

<<lib_core/libthread/iocall.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<function iocall>>
@


\subsection*{[[lib_core/libthread/chanprint.c]]}


%-------------------------------------------------------------

<<lib_core/libthread/chanprint.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>

<<function chanprint>>
@


\subsection*{[[lib_core/libthread/ioclose.c]]}

%-------------------------------------------------------------

<<lib_core/libthread/ioclose.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<function _ioclose>>

<<function ioclose>>
@


\subsection*{[[lib_core/libthread/iodial.c]]}

%-------------------------------------------------------------

<<lib_core/libthread/iodial.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<function _iodial>>

<<function iodial>>
@


\subsection*{[[lib_core/libthread/ioopen.c]]}



%-------------------------------------------------------------

<<lib_core/libthread/ioopen.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<function _ioopen>>

<<function ioopen>>
@


\subsection*{[[lib_core/libthread/ioread.c]]}


%-------------------------------------------------------------

<<lib_core/libthread/ioread.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<function _ioread>>

<<function ioread>>
@


\subsection*{[[lib_core/libthread/ioreadn.c]]}


%-------------------------------------------------------------

<<lib_core/libthread/ioreadn.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<function _ioreadn>>

<<function ioreadn>>
@


\subsection*{[[lib_core/libthread/iosleep.c]]}

%-------------------------------------------------------------

<<lib_core/libthread/iosleep.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<function _iosleep>>

<<function iosleep>>
@


\subsection*{[[lib_core/libthread/iowrite.c]]}


%-------------------------------------------------------------

<<lib_core/libthread/iowrite.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<function _iowrite>>

<<function iowrite>>
@


\subsection*{[[lib_core/libthread/dial.c]]}

%-------------------------------------------------------------

<<lib_core/libthread/dial.c>>=
/*
 * old single-process version of dial that libthread can cope with
 */
#include <u.h>
#include <libc.h>

typedef struct DS DS;

static int  call(char*, char*, DS*);
static int  csdial(DS*);
static void _dial_string_parse(char*, DS*);

<<enum _anon_ (lib_core/libthread/dial.c)>>

<<struct DS (libthread/dial.c)>>


<<function _threaddial>>

<<function csdial (libthread/dial.c)>>

<<function call (libthread/dial.c)>>

<<function _dial_string_parse (libthread/dial.c)>>
@


\subsection*{[[lib_core/libthread/exec.c]]}

%-------------------------------------------------------------

<<lib_core/libthread/exec.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<constant PIPEMNT>>

<<function procexec>>

<<function procexecl>>

@
