\section{[[include/]]}

\subsection*{[[include/thread.h]]}

%dead I think
%enum {
%    Nqwds = 2,
%    Nqshift = 5,		/* logâ‚‚ # of bits in long */
%    Nqmask =  -1,
%    Nqbits = (1 << Nqshift) * 2,
%};

%-------------------------------------------------------------

<<include/thread.h>>=
#pragma src "/sys/src/libthread"
#pragma lib "libthread.a"

#pragma	varargck	argpos	chanprint	2

typedef struct Alt	Alt;
typedef struct Channel	Channel;
typedef struct Ref	Ref;
/* slave I/O processes */
typedef struct Ioproc Ioproc;
#pragma incomplete Ioproc

<<struct Channel>>

/* Channel operations for alt: */
<<enum chanop>>
typedef enum chanop ChanOp;

<<struct Alt>>

<<struct Ref>>

long	decref(Ref *r);			/* returns 0 iff value is now zero */
void	incref(Ref *r);

Channel* chancreate(int elemsize, int bufsize);
int	chanclose(Channel*);
int	chanclosing(Channel *c);
int	chaninit(Channel *c, int elemsize, int elemcnt);
void	chanfree(Channel *c);
int	chanprint(Channel *, char *, ...);

// blocking API
int	recv(Channel *c, void *v);
void*	recvp(Channel *c);
ulong	recvul(Channel *c);
int	send(Channel *c, void *v);
int	sendp(Channel *c, void *v);
int	sendul(Channel *c, ulong v);

// non blocking API
int	nbrecv(Channel *c, void *v);
void*	nbrecvp(Channel *c);
ulong	nbrecvul(Channel *c);
int	nbsend(Channel *c, void *v);
int	nbsendp(Channel *c, void *v);
int	nbsendul(Channel *c, ulong v);

// select
int	alt(Alt alts[]);

// process
int	proccreate(void (*f)(void *arg), void *arg, uint stacksize);
int	procrfork(void (*f)(void *arg), void *arg, uint stacksize, int flag);
void**	procdata(void);
void	procexec(Channel *, char *, char *[]);
void	procexecl(Channel *, char *, ...);

// threads
int	threadcreate(void (*f)(void *arg), void *arg, uint stacksize);
void**	threaddata(void);
void	threadexits(char *);
void	threadexitsall(char *);
void	threadmain(int argc, char *argv[]);
int	threadid(void);

int	threadgetgrp(void);	/* return thread group of current thread */
int	threadsetgrp(int);		/* set thread group, return old */
char*	threadgetname(void);
void	threadsetname(char *fmt, ...);
void	threadint(int);		/* interrupt thread */
void	threadintgrp(int);	/* interrupt threads in grp */
void	threadkill(int);	/* kill thread */
void	threadkillgrp(int);	/* kill threads in group */
void	threadnonotes(void);
int	threadnotify(int (*f)(void*, char*), int in);
int	threadpid(int);
Channel*threadwaitchan(void);

// Io proc
Ioproc*	ioproc(void);
void	closeioproc(Ioproc*);
void	iointerrupt(Ioproc*);

int	ioopen(Ioproc*, char*, int);
int	ioclose(Ioproc*, int);
long	ioread(Ioproc*, int, void*, long);
long	ioreadn(Ioproc*, int, void*, long);
long	iowrite(Ioproc*, int, void*, long);
int	iosleep(Ioproc*, long);
int	iodial(Ioproc*, char*, char*, char*, int*);

long	iocall(Ioproc*, long (*)(va_list*), ...);
void	ioret(Ioproc*, int);

// misc
void	needstack(int);
int	tprivalloc(void);
void	tprivfree(int);
void	**tprivaddr(int);
void	yield(void);

extern	int	mainstacksize;
@


\section{[[lib_core/libthread/]]}

\subsection*{[[lib_core/libthread/ref.c]]}

%-------------------------------------------------------------

<<lib_core/libthread/ref.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<function incref>>

<<function decref>>
@


\subsection*{[[lib_core/libthread/threadimpl.h]]}

<<enum _anon_ (lib_core/libthread/threadimpl.h)>>=
enum
{
<<constant RENDHASH>>
<<constant Printsize>>
<<constant NPRIV>>
};
@

%-------------------------------------------------------------


<<lib_core/libthread/threadimpl.h>>=
/* 
 * Some notes on locking:
 *
 *	All the locking woes come from implementing
 *	threadinterrupt (and threadkill).
 *
 *	_threadgetproc()->thread is always a live pointer.
 *	p->threads, p->ready, and _threadrgrp also contain
 * 	live thread pointers.  These may only be consulted
 *	while holding p->lock or _threadrgrp.lock; in procs
 *	other than p, the pointers are only guaranteed to be live
 *	while the lock is still being held.
 *
 *	Thread structures can only be freed by the proc
 *	they belong to.  Threads marked with t->inrendez
 * 	need to be extracted from the _threadrgrp before
 *	being freed.
 *
 *	_threadrgrp.lock cannot be acquired while holding p->lock.
 */

typedef struct Pqueue	Pqueue;
typedef struct Rgrp	Rgrp;
typedef struct Tqueue	Tqueue;
typedef struct Thread	Thread;
typedef struct Execargs	Execargs;
typedef struct Proc	Proc;


/* must match list in sched.c */
<<enum state>>
typedef enum state State;
    
<<enum chanstate>>
typedef enum chanstate Chanstate;

<<enum _anon_ (lib_core/libthread/threadimpl.h)>>

<<struct Rgrp>>

<<struct Tqueue>>

<<struct Thread>>

<<struct Execargs>>

<<struct Proc>>

<<struct Pqueue>>

<<struct Ioproc>>

void	_freeproc(Proc*);
void	_freethread(Thread*);
Proc*	_newproc(void(*)(void*), void*, uint, char*, int, int);
int	_procsplhi(void);
void	_procsplx(int);
void	_sched(void);
int	_schedexec(Execargs*);
void	_schedexecwait(void);
void	_schedexit(Proc*);
int	_schedfork(Proc*);
void	_schedinit(void*);
void	_systhreadinit(void);
void	_threadassert(char*);
void	_threadbreakrendez(void);
void	_threaddebug(ulong, char*, ...);
void	_threadexitsall(char*);
void	_threadflagrendez(Thread*);
Proc*	_threadgetproc(void);
void	_threadsetproc(Proc*);
void	_threadinitstack(Thread*, void(*)(void*), void*);
void*	_threadmalloc(long, int);
void	_threadnote(void*, char*);
void	_threadready(Thread*);
void*	_threadrendezvous(void*, void*);
void	_threadsignal(void);
void	_threadsysfatal(char*, va_list);
void**	_workerdata(void);
void	_xinc(long*);
long	_xdec(long*);

extern int		_threaddebuglevel;
extern char*		_threadexitsallstatus;
extern Pqueue		_threadpq;
extern Channel*		_threadwaitchan;
extern Rgrp		_threadrgrp;

<<constant DBGAPPL>>
<<constant DBGSCHED>>
<<constant DBGCHAN>>
<<constant DBGREND>>
<<constant DBGNOTE>>
<<constant DBGEXEC>>

<<function ioproc_arg>>
@


\subsection*{[[lib_core/libthread/xincarm.c]]}

%-------------------------------------------------------------

<<lib_core/libthread/xincarm.c>>=
#include "xincport.h"
@


\subsection*{[[lib_core/libthread/xincport.h]]}

%-------------------------------------------------------------

<<lib_core/libthread/xincport.h>>=
#include <u.h>
#include <libc.h>
#include <thread.h>

<<global xincport_lock>>

<<function _xinc>>

<<function _xdec>>
@


\subsection*{[[lib_core/libthread/globals.c]]}

%-------------------------------------------------------------

<<lib_core/libthread/globals.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<global _threadpq>>

<<global procp>>

<<function _systhreadinit>>

<<function _threadgetproc>>

<<function _threadsetproc>>
@


\subsection*{[[lib_core/libthread/debug.c]]}


%-------------------------------------------------------------

<<lib_core/libthread/debug.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<global _threaddebuglevel>>

<<function _threaddebug>>

<<function _threadassert>>
@


\subsection*{[[lib_core/libthread/id.c]]}

%-------------------------------------------------------------

<<lib_core/libthread/id.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"
#include <tos.h>

<<function threadid>>

<<function threadpid>>

<<function threadsetgrp>>

<<function threadgetgrp>>

<<function threadsetname>>

<<function threadgetname>>

<<function threaddata>>

<<function _workerdata>>

<<function procdata>>

<<global privlock>>
<<global privmask>>

<<function tprivalloc>>

<<function tprivfree>>

<<function tprivaddr>>
@


\subsection*{[[lib_core/libthread/exit.c]]}

%-------------------------------------------------------------

<<lib_core/libthread/exit.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"
#include <tos.h>

<<global _threadexitsallstatus>>
<<global _threadwaitchan>>

<<function threadexits>>

<<function threadexitsall>>

<<function threadwaitchan>>
@


\subsection*{[[lib_core/libthread/lib.c]]}


%-------------------------------------------------------------

<<lib_core/libthread/lib.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<global totalmalloc>>

<<function _threadmalloc>>

<<function _threadsysfatal>>
@


\subsection*{[[lib_core/libthread/note.c]]}

%-------------------------------------------------------------

<<lib_core/libthread/note.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

typedef struct Note Note;

<<global _threadnopasser>>

<<constant NFN>>
<<constant ERRLEN>>
<<struct Note>>

<<global notes>>
<<global enotes>>
<<global onnote>>
<<global onnotepid>>
<<global onnotelock>>

<<function threadnotify>>

<<function delayednotes>>

<<function _threadnote>>

<<function _procsplhi>>

<<function _procsplx>>

@

\subsection*{[[lib_core/libthread/rendez.c]]}

%-------------------------------------------------------------

<<lib_core/libthread/rendez.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<global _threadrgrp>>
<<global isdirty>>

<<function finish>>

<<function _threadrendezvous>>

<<function _threadflagrendez>>

<<function _threadbreakrendez>>
@


\subsection*{[[lib_core/libthread/386.c]]}

%-------------------------------------------------------------

<<lib_core/libthread/386.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>

#include "threadimpl.h"

<<function launcher386>>

<<function _threadinitstack>>

@


\subsection*{[[lib_core/libthread/sched.c]]}


%-------------------------------------------------------------

<<lib_core/libthread/sched.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"
#include <tos.h>

static Thread	*runthread(Proc*);

<<global _psstate>>

<<function psstate>>

<<function _schedinit>>

<<function needstack>>

<<function _sched>>

<<function runthread>>

<<function _threadready>>

<<function yield>>

@


\subsection*{[[lib_core/libthread/create.c]]}

%-------------------------------------------------------------

<<lib_core/libthread/create.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<function nextID>>
    
<<function newthread>>

<<function threadcreate>>

<<function _newproc>>

<<function procrfork>>

<<function proccreate>>

<<function _freeproc>>

<<function _freethread>>

@


\subsection*{[[lib_core/libthread/channel.c]]}

%-------------------------------------------------------------

<<lib_core/libthread/channel.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<enum _anon_ (lib_core/libthread/channel.c)>>

<<global errcl>>
<<global chanlock>>

static void enqueue(Alt*, Channel**);
static void dequeue(Alt*);
static int canexec(Alt*);
static int altexec(Alt*, int);

<<constant Closed>>
<<constant Intred>>

<<function _chanfree>>

<<function chanfree>>

<<function chaninit>>

<<function chancreate>>

<<function isopenfor>>

<<function alt>>

<<function chanclose>>

<<function chanclosing>>

<<function runop>>

<<function recv>>

<<function nbrecv>>

<<function send>>

<<function nbsend>>

<<function channelsize>>

<<function sendul>>

<<function recvul>>

<<function sendp>>

<<function recvp>>

<<function nbsendul>>

<<function nbrecvul>>

<<function nbsendp>>

<<function nbrecvp>>

<<function emptyentry>>

<<function enqueue>>

<<function dequeue>>

<<function canexec>>

<<function altexecbuffered>>

<<function altcopy>>

<<function altexec>>
@


\subsection*{[[lib_core/libthread/main.c]]}

%-------------------------------------------------------------

<<lib_core/libthread/main.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

typedef struct Mainarg Mainarg;

<<struct Mainarg>>

<<global mainstacksize>>
<<global _threadnotefd>>
<<global _threadpasserpid>>

<<global _mainjmp>>

static void mainlauncher(void*);
extern void (*_sysfatal)(char*, va_list);
extern void (*__assert)(char*);
extern int (*_dial)(char*, char*, char*, int*);

extern int _threaddial(char*, char*, char*, int*);

<<global mainp>>

<<function main>>

<<function mainlauncher>>

<<function skip>>

<<function _times>>

<<function efork>>

<<function _schedexec>>

<<function _schedfork>>

<<function _schedexit>>

<<function _schedexecwait>>

@


\subsection*{[[lib_core/libthread/kill.c]]}

%-------------------------------------------------------------

<<lib_core/libthread/kill.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

static void tinterrupt(Proc*, Thread*);

<<function threadxxxgrp>>

<<function threadxxx>>

<<function threadkillgrp>>

<<function threadkill>>

<<function threadintgrp>>

<<function threadint>>

<<function tinterrupt>>
@


\subsection*{[[lib_core/libthread/ioproc.c]]}

<<enum _anon_ (lib_core/libthread/ioproc.c)>>=
enum
{
    <<constant STACK>>
};
@

%-------------------------------------------------------------

<<lib_core/libthread/ioproc.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<enum _anon_ (lib_core/libthread/ioproc.c)>>

<<function iointerrupt>>

<<function xioproc>>

<<function ioproc>>

<<function closeioproc>>
@


\subsection*{[[lib_core/libthread/iocall.c]]}


%-------------------------------------------------------------

<<lib_core/libthread/iocall.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<function iocall>>
@


\subsection*{[[lib_core/libthread/chanprint.c]]}


%-------------------------------------------------------------

<<lib_core/libthread/chanprint.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>

<<function chanprint>>
@


\subsection*{[[lib_core/libthread/ioclose.c]]}

%-------------------------------------------------------------

<<lib_core/libthread/ioclose.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<function _ioclose>>

<<function ioclose>>
@


\subsection*{[[lib_core/libthread/iodial.c]]}

%-------------------------------------------------------------

<<lib_core/libthread/iodial.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<function _iodial>>

<<function iodial>>
@


\subsection*{[[lib_core/libthread/ioopen.c]]}



%-------------------------------------------------------------

<<lib_core/libthread/ioopen.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<function _ioopen>>

<<function ioopen>>
@


\subsection*{[[lib_core/libthread/ioread.c]]}


%-------------------------------------------------------------

<<lib_core/libthread/ioread.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<function _ioread>>

<<function ioread>>
@


\subsection*{[[lib_core/libthread/ioreadn.c]]}


%-------------------------------------------------------------

<<lib_core/libthread/ioreadn.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<function _ioreadn>>

<<function ioreadn>>
@


\subsection*{[[lib_core/libthread/iosleep.c]]}

%-------------------------------------------------------------

<<lib_core/libthread/iosleep.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<function _iosleep>>

<<function iosleep>>
@


\subsection*{[[lib_core/libthread/iowrite.c]]}


%-------------------------------------------------------------

<<lib_core/libthread/iowrite.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<function _iowrite>>

<<function iowrite>>
@


\subsection*{[[lib_core/libthread/dial.c]]}

%-------------------------------------------------------------

<<lib_core/libthread/dial.c>>=
/*
 * old single-process version of dial that libthread can cope with
 */
#include <u.h>
#include <libc.h>

typedef struct DS DS;

static int	call(char*, char*, DS*);
static int	csdial(DS*);
static void	_dial_string_parse(char*, DS*);

<<enum _anon_ (lib_core/libthread/dial.c)>>

<<struct DS>>


<<function _threaddial>>

<<function csdial>>

<<function call>>

<<function _dial_string_parse>>
@


\subsection*{[[lib_core/libthread/exec.c]]}

%-------------------------------------------------------------

<<lib_core/libthread/exec.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<constant PIPEMNT>>

<<function procexec>>

<<function procexecl>>

@
