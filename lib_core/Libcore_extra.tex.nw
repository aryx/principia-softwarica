\section{[[include/]]}

\subsection*{[[include/thread.h]]}

%dead I think
%enum {
%    Nqwds = 2,
%    Nqshift = 5,		/* logâ‚‚ # of bits in long */
%    Nqmask =  -1,
%    Nqbits = (1 << Nqshift) * 2,
%};

%-------------------------------------------------------------

<<include/thread.h>>=
#pragma src "/sys/src/libthread"
#pragma lib "libthread.a"

#pragma	varargck	argpos	chanprint	2

typedef struct Alt	Alt;
typedef struct Channel	Channel;
typedef struct Ref	Ref;
/* slave I/O processes */
typedef struct Ioproc Ioproc;
#pragma incomplete Ioproc

<<struct Channel>>

/* Channel operations for alt: */
<<enum chanop>>
typedef enum chanop ChanOp;

<<struct Alt>>

<<struct Ref>>

long	decref(Ref *r);			/* returns 0 iff value is now zero */
void	incref(Ref *r);

Channel* chancreate(int elemsize, int bufsize);
int	chanclose(Channel*);
int	chanclosing(Channel *c);
int	chaninit(Channel *c, int elemsize, int elemcnt);
void	chanfree(Channel *c);
int	chanprint(Channel *, char *, ...);

// blocking API
int	recv(Channel *c, void *v);
void*	recvp(Channel *c);
ulong	recvul(Channel *c);
int	send(Channel *c, void *v);
int	sendp(Channel *c, void *v);
int	sendul(Channel *c, ulong v);

// non blocking API
int	nbrecv(Channel *c, void *v);
void*	nbrecvp(Channel *c);
ulong	nbrecvul(Channel *c);
int	nbsend(Channel *c, void *v);
int	nbsendp(Channel *c, void *v);
int	nbsendul(Channel *c, ulong v);

// select
int	alt(Alt alts[]);

// process
int	proccreate(void (*f)(void *arg), void *arg, uint stacksize);
int	procrfork(void (*f)(void *arg), void *arg, uint stacksize, int flag);
void**	procdata(void);
void	procexec(Channel *, char *, char *[]);
void	procexecl(Channel *, char *, ...);

// threads
int	threadcreate(void (*f)(void *arg), void *arg, uint stacksize);
void**	threaddata(void);
void	threadexits(char *);
void	threadexitsall(char *);
void	threadmain(int argc, char *argv[]);
int	threadid(void);

int	threadgetgrp(void);	/* return thread group of current thread */
int	threadsetgrp(int);		/* set thread group, return old */
char*	threadgetname(void);
void	threadsetname(char *fmt, ...);
void	threadint(int);		/* interrupt thread */
void	threadintgrp(int);	/* interrupt threads in grp */
void	threadkill(int);	/* kill thread */
void	threadkillgrp(int);	/* kill threads in group */
void	threadnonotes(void);
int	threadnotify(int (*f)(void*, char*), int in);
int	threadpid(int);
Channel*threadwaitchan(void);

// Io proc
Ioproc*	ioproc(void);
void	closeioproc(Ioproc*);
void	iointerrupt(Ioproc*);

int	ioopen(Ioproc*, char*, int);
int	ioclose(Ioproc*, int);
long	ioread(Ioproc*, int, void*, long);
long	ioreadn(Ioproc*, int, void*, long);
long	iowrite(Ioproc*, int, void*, long);
int	iosleep(Ioproc*, long);
int	iodial(Ioproc*, char*, char*, char*, int*);

long	iocall(Ioproc*, long (*)(va_list*), ...);
void	ioret(Ioproc*, int);

// misc
void	needstack(int);
int	tprivalloc(void);
void	tprivfree(int);
void	**tprivaddr(int);
void	yield(void);

extern	int	mainstacksize;
@


\section{[[lib_core/libthread/]]}

\subsection*{[[lib_core/libthread/ref.c]]}

%-------------------------------------------------------------

<<lib_core/libthread/ref.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<function incref>>

<<function decref>>
@


\subsection*{[[lib_core/libthread/threadimpl.h]]}


<<enum _anon_ (lib_core/libthread/threadimpl.h)>>=
enum
{
<<constant RENDHASH>>
<<constant Printsize>>
<<constant NPRIV>>
};
@

<<constant RENDHASH>>=
RENDHASH = 13,
@

<<struct Rgrp>>=
struct Rgrp
{
    Lock	lock;
    Thread	*hash[RENDHASH];
};
@



<<struct Execargs>>=
struct Execargs
{
    char	*prog;
    char	**args;
    int		fd[2];
};
@



<<function ioproc_arg>>=
#define ioproc_arg(io, type)	(va_arg((io)->arg, type))
@


%-------------------------------------------------------------


<<lib_core/libthread/threadimpl.h>>=
/* 
 * Some notes on locking:
 *
 *	All the locking woes come from implementing
 *	threadinterrupt (and threadkill).
 *
 *	_threadgetproc()->thread is always a live pointer.
 *	p->threads, p->ready, and _threadrgrp also contain
 * 	live thread pointers.  These may only be consulted
 *	while holding p->lock or _threadrgrp.lock; in procs
 *	other than p, the pointers are only guaranteed to be live
 *	while the lock is still being held.
 *
 *	Thread structures can only be freed by the proc
 *	they belong to.  Threads marked with t->inrendez
 * 	need to be extracted from the _threadrgrp before
 *	being freed.
 *
 *	_threadrgrp.lock cannot be acquired while holding p->lock.
 */

typedef struct Pqueue	Pqueue;
typedef struct Rgrp	Rgrp;
typedef struct Tqueue	Tqueue;
typedef struct Thread	Thread;
typedef struct Execargs	Execargs;
typedef struct Proc	Proc;


/* must match list in sched.c */
<<enum state>>
typedef enum state State;
    
<<enum chanstate>>
typedef enum chanstate Chanstate;

<<enum _anon_ (lib_core/libthread/threadimpl.h)>>

<<struct Rgrp>>

<<struct Tqueue>>

<<struct Thread>>

<<struct Execargs>>

<<struct Proc>>

<<struct Pqueue>>

<<struct Ioproc>>

void	_freeproc(Proc*);
void	_freethread(Thread*);
Proc*	_newproc(void(*)(void*), void*, uint, char*, int, int);
int	_procsplhi(void);
void	_procsplx(int);
void	_sched(void);
int	_schedexec(Execargs*);
void	_schedexecwait(void);
void	_schedexit(Proc*);
int	_schedfork(Proc*);
void	_schedinit(void*);
void	_systhreadinit(void);
void	_threadassert(char*);
void	_threadbreakrendez(void);
void	_threaddebug(ulong, char*, ...);
void	_threadexitsall(char*);
void	_threadflagrendez(Thread*);
Proc*	_threadgetproc(void);
void	_threadsetproc(Proc*);
void	_threadinitstack(Thread*, void(*)(void*), void*);
void*	_threadmalloc(long, int);
void	_threadnote(void*, char*);
void	_threadready(Thread*);
void*	_threadrendezvous(void*, void*);
void	_threadsignal(void);
void	_threadsysfatal(char*, va_list);
void**	_workerdata(void);
void	_xinc(long*);
long	_xdec(long*);

extern int		_threaddebuglevel;
extern char*		_threadexitsallstatus;
extern Pqueue		_threadpq;
extern Channel*		_threadwaitchan;
extern Rgrp		_threadrgrp;

<<constant DBGAPPL>>
<<constant DBGSCHED>>
<<constant DBGCHAN>>
<<constant DBGREND>>
<<constant DBGNOTE>>
<<constant DBGEXEC>>

<<function ioproc_arg>>
@


\subsection*{[[lib_core/libthread/xincarm.c]]}

%-------------------------------------------------------------

<<lib_core/libthread/xincarm.c>>=
#include "xincport.h"
@


\subsection*{[[lib_core/libthread/xincport.h]]}

%-------------------------------------------------------------

<<lib_core/libthread/xincport.h>>=
#include <u.h>
#include <libc.h>
#include <thread.h>

<<global xincport_lock>>

<<function _xinc>>

<<function _xdec>>
@


\subsection*{[[lib_core/libthread/globals.c]]}



%-------------------------------------------------------------

<<lib_core/libthread/globals.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<global _threadpq>>

<<global procp>>

<<function _systhreadinit>>

<<function _threadgetproc>>

<<function _threadsetproc>>
@


\subsection*{[[lib_core/libthread/debug.c]]}


%-------------------------------------------------------------

<<lib_core/libthread/debug.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<global _threaddebuglevel>>

<<function _threaddebug>>

<<function _threadassert>>
@


\subsection*{[[lib_core/libthread/id.c]]}


<<function threadsetgrp>>=
int
threadsetgrp(int ng)
{
    int og;
    Thread *t;

    t = _threadgetproc()->thread;
    og = t->grp;
    t->grp = ng;
    return og;
}
@

<<function threadgetgrp>>=
int
threadgetgrp(void)
{
    return _threadgetproc()->thread->grp;
}
@


<<function threadsetname>>=
void
threadsetname(char *fmt, ...)
{
    int fd;
    char buf[128];
    va_list arg;
    Proc *p;
    Thread *t;

    p = _threadgetproc();
    t = p->thread;
    if (t->cmdname)
        free(t->cmdname);
    va_start(arg, fmt);
    t->cmdname = vsmprint(fmt, arg);
    va_end(arg);
    if(t->cmdname && p->nthreads == 1){
        snprint(buf, sizeof buf, "#p/%lud/args", _tos->pid); //getpid());
        if((fd = open(buf, OWRITE)) >= 0){
            write(fd, t->cmdname, strlen(t->cmdname)+1);
            close(fd);
        }
    }
}
@

<<function threadgetname>>=
char*
threadgetname(void)
{
    Proc *p;

    if((p = _threadgetproc()) && p->thread)
        return p->thread->cmdname;
    return nil;
}
@

<<function threaddata>>=
void**
threaddata(void)
{
    return &_threadgetproc()->thread->udata[0];
}
@

<<function _workerdata>>=
void**
_workerdata(void)
{
    return &_threadgetproc()->wdata;
}
@

<<function procdata>>=
void**
procdata(void)
{
    return &_threadgetproc()->udata;
}
@


<<global privlock>>=
static Lock privlock;
@

<<global privmask>>=
//array<bool> NPRIV at least
static int privmask = 1;
@

<<function tprivalloc>>=
int
tprivalloc(void)
{
    int i;

    lock(&privlock);
    for(i=0; i<NPRIV; i++)
        if(!(privmask&(1<<i))){
            privmask |= 1<<i;
            unlock(&privlock);
            return i;
        }
    unlock(&privlock);
    return -1;
}
@

<<function tprivfree>>=
void
tprivfree(int i)
{
    if(i < 0 || i >= NPRIV)
        abort();
    lock(&privlock);
    privmask &= ~(1<<i);
}
@

<<function tprivaddr>>=
void**
tprivaddr(int i)
{
    return &_threadgetproc()->thread->udata[i];
}
@


%-------------------------------------------------------------

<<lib_core/libthread/id.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"
#include <tos.h>

<<function threadid>>

<<function threadpid>>

<<function threadsetgrp>>

<<function threadgetgrp>>

<<function threadsetname>>

<<function threadgetname>>

<<function threaddata>>

<<function _workerdata>>

<<function procdata>>

<<global privlock>>
<<global privmask>>

<<function tprivalloc>>

<<function tprivfree>>

<<function tprivaddr>>
@


\subsection*{[[lib_core/libthread/exit.c]]}

<<global _threadexitsallstatus>>=
char *_threadexitsallstatus;
@

<<global _threadwaitchan>>=
Channel *_threadwaitchan;
@

<<function threadexits>>=
void
threadexits(char *exitstr)
{
    Proc *p;
    Thread *t;

    p = _threadgetproc();
    t = p->thread;
    t->moribund = 1;
    if(exitstr==nil)
        exitstr="";
    utfecpy(p->exitstr, p->exitstr+ERRMAX, exitstr);
    _sched();
}
@

<<function threadexitsall>>=
void
threadexitsall(char *exitstr)
{
    Proc *p;
    int pid[64];
    int i, npid, mypid;

    if(exitstr == nil)
        exitstr = "";
    _threadexitsallstatus = exitstr;
    _threaddebug(DBGSCHED, "_threadexitsallstatus set to %p", _threadexitsallstatus);
    mypid = _tos->pid; //getpid();

    /*
     * signal others.
     * copying all the pids first avoids other threads
     * teardown procedures getting in the way.
     *
     * avoid mallocs since malloc can post a note which can
     * call threadexitsall...
     */
    for(;;){
        lock(&_threadpq.lock);
        npid = 0;
        for(p = _threadpq.head; p && npid < nelem(pid); p=p->next){
            if(p->threadint == 0 && p->pid != mypid){
                pid[npid++] = p->pid;
                p->threadint = 1;
            }
        }
        unlock(&_threadpq.lock);
        if(npid == 0)
            break;
        for(i=0; i<npid; i++)
            postnote(PNPROC, pid[i], "threadint");
    }

    /* leave */
    exits(exitstr);
}
@

<<function threadwaitchan>>=
Channel*
threadwaitchan(void)
{
    if(_threadwaitchan==nil)
        _threadwaitchan = chancreate(sizeof(Waitmsg*), 16);
    return _threadwaitchan;
}
@


%-------------------------------------------------------------

<<lib_core/libthread/exit.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"
#include <tos.h>

<<global _threadexitsallstatus>>
<<global _threadwaitchan>>

<<function threadexits>>

<<function threadexitsall>>

<<function threadwaitchan>>
@


\subsection*{[[lib_core/libthread/lib.c]]}


%-------------------------------------------------------------

<<lib_core/libthread/lib.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<global totalmalloc>>

<<function _threadmalloc>>

<<function _threadsysfatal>>
@


\subsection*{[[lib_core/libthread/note.c]]}

<<global _threadnopasser>>=
int	_threadnopasser;
@

<<constant NFN>>=
#define	NFN		33
@

<<constant ERRLEN>>=
#define	ERRLEN	48
@

<<struct Note>>=
struct Note
{
    Lock		inuse;
    Proc		*proc;		/* recipient */
    char		s[ERRMAX];	/* arg2 */
};
@

<<global notes>>=
static Note	notes[128];
@

<<global enotes>>=
static Note	*enotes = notes+nelem(notes);
@

<<global onnote>>=
static int		(*onnote[NFN])(void*, char*);
@

<<global onnotepid>>=
static int		onnotepid[NFN];
@

<<global onnotelock>>=
static Lock	onnotelock;
@

<<function threadnotify>>=
int
threadnotify(int (*f)(void*, char*), int in)
{
    int i, topid;
    int (*from)(void*, char*), (*to)(void*, char*);

    if(in){
        from = nil;
        to = f;
        topid = _threadgetproc()->pid;
    }else{
        from = f;
        to = nil;
        topid = 0;
    }
    lock(&onnotelock);
    for(i=0; i<NFN; i++)
        if(onnote[i]==from){
            onnote[i] = to;
            onnotepid[i] = topid;
            break;
        }
    unlock(&onnotelock);
    return i<NFN;
}
@

<<function delayednotes>>=
static void
delayednotes(Proc *p, void *v)
{
    int i;
    Note *n;
    int (*fn)(void*, char*);

    if(!p->pending)
        return;

    p->pending = 0;
    for(n=notes; n<enotes; n++){
        if(n->proc == p){
            for(i=0; i<NFN; i++){
                if(onnotepid[i]!=p->pid || (fn = onnote[i])==nil)
                    continue;
                if((*fn)(v, n->s))
                    break;
            }
            if(i==NFN){
                _threaddebug(DBGNOTE, "Unhandled note %s, proc %p\n", n->s, p);
                if(v != nil)
                    noted(NDFLT);
                else if(strncmp(n->s, "sys:", 4)==0)
                    abort();
                threadexitsall(n->s);
            }
            n->proc = nil;
            unlock(&n->inuse);
        }
    }
}
@

<<function _threadnote>>=
void
_threadnote(void *v, char *s)
{
    Proc *p;
    Note *n;

    _threaddebug(DBGNOTE, "Got note %s", s);
    if(strncmp(s, "sys:", 4) == 0)
        noted(NDFLT);

    if(_threadexitsallstatus){
        _threaddebug(DBGNOTE, "Threadexitsallstatus = '%s'\n", _threadexitsallstatus);
        _exits(_threadexitsallstatus);
    }

    if(strcmp(s, "threadint")==0)
        noted(NCONT);

    p = _threadgetproc();
    if(p == nil)
        noted(NDFLT);

    for(n=notes; n<enotes; n++)
        if(canlock(&n->inuse))
            break;
    if(n==enotes)
        sysfatal("libthread: too many delayed notes");
    utfecpy(n->s, n->s+ERRMAX, s);
    n->proc = p;
    p->pending = 1;
    if(!p->splhi)
        delayednotes(p, v);
    noted(NCONT);
}
@

<<function _procsplhi>>=
int
_procsplhi(void)
{
    int s;
    Proc *p;

    p = _threadgetproc();
    s = p->splhi;
    p->splhi = 1;
    return s;
}
@

<<function _procsplx>>=
void
_procsplx(int s)
{
    Proc *p;

    p = _threadgetproc();
    p->splhi = s;
    if(s)
        return;
    if(p->pending)
        delayednotes(p, nil);
}
@


%-------------------------------------------------------------

<<lib_core/libthread/note.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

typedef struct Note Note;

<<global _threadnopasser>>

<<constant NFN>>
<<constant ERRLEN>>
<<struct Note>>

<<global notes>>
<<global enotes>>
<<global onnote>>
<<global onnotepid>>
<<global onnotelock>>

<<function threadnotify>>

<<function delayednotes>>

<<function _threadnote>>

<<function _procsplhi>>

<<function _procsplx>>

@


\subsection*{[[lib_core/libthread/rendez.c]]}

<<global _threadrgrp>>=
Rgrp _threadrgrp;
@

<<global isdirty>>=
static int isdirty;
@

<<function finish>>=
static void*
finish(Thread *t, void *val)
{
    void *ret;

    ret = t->rendval;
    t->rendval = val;
    while(t->state == Running)
        sleep(0);
    lock(&t->proc->lock);
    if(t->state == Rendezvous){	/* not always true: might be Dead */
        t->state = Ready;
        _threadready(t);
    }
    unlock(&t->proc->lock);
    return ret;
}
@

<<function _threadrendezvous>>=
void*
_threadrendezvous(void *tag, void *val)
{
    void *ret;
    Thread *t, **l;

    lock(&_threadrgrp.lock);
    l = &_threadrgrp.hash[((uintptr)tag)%nelem(_threadrgrp.hash)];
    for(t=*l; t; l=&t->rendhash, t=*l){
        if(t->rendtag==tag){
            _threaddebug(DBGREND, "Rendezvous with thread %d.%d", t->proc->pid, t->id);
            *l = t->rendhash;
            ret = finish(t, val);
            unlock(&_threadrgrp.lock);
            return ret;
        }
    }

    /* Going to sleep here. */
    t = _threadgetproc()->thread;
    t->rendbreak = 0;
    t->inrendez = 1;
    t->rendtag = tag;
    t->rendval = val;
    t->rendhash = *l;
    *l = t;
    t->nextstate = Rendezvous;
    _threaddebug(DBGREND, "Rendezvous for tag %p", t->rendtag);
    unlock(&_threadrgrp.lock);
    _sched();
    t->inrendez = 0;
    _threaddebug(DBGREND, "Woke after rendezvous; val is %p", t->rendval);
    return t->rendval;
}
@

<<function _threadflagrendez>>=
/*
 * This is called while holding _threadpq.lock and p->lock,
 * so we can't lock _threadrgrp.lock.  Instead our caller has 
 * to call _threadbreakrendez after dropping those locks.
 */
void
_threadflagrendez(Thread *t)
{
    t->rendbreak = 1;
    isdirty = 1;
}
@

<<function _threadbreakrendez>>=
void
_threadbreakrendez(void)
{
    int i;
    Thread *t, **l;

    if(isdirty == 0)
        return;
    lock(&_threadrgrp.lock);
    if(isdirty == 0){
        unlock(&_threadrgrp.lock);
        return;
    }
    isdirty = 0;
    for(i=0; i<nelem(_threadrgrp.hash); i++){
        l = &_threadrgrp.hash[i];
        for(t=*l; t; t=*l){
            if(t->rendbreak){
                *l = t->rendhash;
                finish(t, (void*)~0);
            }else
                 l=&t->rendhash;
        }
    }
    unlock(&_threadrgrp.lock);
}
@


%-------------------------------------------------------------

<<lib_core/libthread/rendez.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<global _threadrgrp>>
<<global isdirty>>

<<function finish>>

<<function _threadrendezvous>>

<<function _threadflagrendez>>

<<function _threadbreakrendez>>
@


\subsection*{[[lib_core/libthread/386.c]]}

<<function launcher386>>=
static void
launcher386(void (*f)(void *arg), void *arg)
{
    (*f)(arg);
    threadexits(nil);
}
@

<<function _threadinitstack>>=
void
_threadinitstack(Thread *t, void (*f)(void*), void *arg)
{
    ulong *tos;

    tos = (ulong*)&t->stk[t->stksize&~7];
    *--tos = (ulong)arg;
    *--tos = (ulong)f;
    t->sched[JMPBUFPC] = (ulong)launcher386+JMPBUFDPC;
    t->sched[JMPBUFSP] = (ulong)tos - 8;		/* old PC and new PC */
}
@


%-------------------------------------------------------------

<<lib_core/libthread/386.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>

#include "threadimpl.h"

<<function launcher386>>

<<function _threadinitstack>>

@


\subsection*{[[lib_core/libthread/sched.c]]}

<<function _schedinit>>=
void
_schedinit(void *arg)
{
    Proc *p;
    Thread *t, **l;

    p = arg;
    _threadsetproc(p);
    p->pid = _tos->pid; //getpid();

    while(setjmp(p->sched))
        ;

    _threaddebug(DBGSCHED, "top of schedinit, _threadexitsallstatus=%p", 
                 _threadexitsallstatus);
    if(_threadexitsallstatus)
        exits(_threadexitsallstatus);

    lock(&p->lock);
    t = p->thread;
    if(t != nil){
        p->thread = nil;

        if(t->moribund){
            t->state = Dead;
            for(l=&p->threads.head; *l; l=&(*l)->nextt)
                if(*l == t){
                    *l = t->nextt;
                    if(*l==nil)
                        p->threads.tail = l;
                    p->nthreads--;
                    break;
                }
            unlock(&p->lock);
            if(t->inrendez){
                _threadflagrendez(t);
                _threadbreakrendez();
            }
            free(t->stk);
            free(t->cmdname);
            free(t);	/* XXX how do we know there are no references? */
            t = nil;
            _sched();
        }
        if(p->needexec){
            t->ret = _schedexec(&p->exec);
            p->needexec = 0;
        }
        if(p->newproc){
            t->ret = _schedfork(p->newproc);
            p->newproc = nil;
        }
        t->state = t->nextstate;
        if(t->state == Ready)
            _threadready(t);
    }
    unlock(&p->lock);
    _sched();
}
@

% _sched() -> <>
<<function needstack>>=
void
needstack(int n)
{
    int x;
    Proc *p;
    Thread *t;
    
    p = _threadgetproc();
    t = p->thread;
    
    if((uchar*)&x - n < (uchar*)t->stk){
        fprint(2, "%s %lud: &x=%p n=%d t->stk=%p\n",
            argv0, _tos->pid, &x, n, t->stk);
        fprint(2, "%s %lud: stack overflow\n", argv0, _tos->pid);
        abort();
    }
}
@

<<function _sched>>=
void
_sched(void)
{
    Proc *p;
    Thread *t;

Resched:
    p = _threadgetproc();
    t = p->thread;
    if(t != nil){
        needstack(128);
        _threaddebug(DBGSCHED, "pausing, state=%s", psstate(t->state));
        if(setjmp(t->sched)==0)
            longjmp(p->sched, 1);
        return;
    }else{
        t = runthread(p);
        if(t == nil){
            _threaddebug(DBGSCHED, "all threads gone; exiting");
            _schedexit(p);
        }
        _threaddebug(DBGSCHED, "running %d.%d", t->proc->pid, t->id);
        p->thread = t;
        if(t->moribund){
            _threaddebug(DBGSCHED, "%d.%d marked to die");
            goto Resched;
        }
        t->state = Running;
        t->nextstate = Ready;
        longjmp(t->sched, 1);
    }
}
@

<<function runthread>>=
static Thread*
runthread(Proc *p)
{
    Thread *t;
    Tqueue *q;

    if(p->nthreads==0)
        return nil;
    q = &p->ready;
    lock(&p->readylock);
    if(q->head == nil){
        q->asleep = 1;
        _threaddebug(DBGSCHED, "sleeping for more work");
        unlock(&p->readylock);
        while(rendezvous(q, 0) == (void*)~0){
            if(_threadexitsallstatus)
                exits(_threadexitsallstatus);
        }
        /* lock picked up from _threadready */
    }
    t = q->head;
    q->head = t->next;
    unlock(&p->readylock);
    return t;
}
@

<<function _threadready>>=
void
_threadready(Thread *t)
{
    Tqueue *q;

    assert(t->state == Ready);
    _threaddebug(DBGSCHED, "readying %d.%d", t->proc->pid, t->id);

    q = &t->proc->ready;
    lock(&t->proc->readylock);
    t->next = nil;
    if(q->head==nil)
        q->head = t;
    else
        *q->tail = t;
    q->tail = &t->next;
    if(q->asleep){
        q->asleep = 0;
        /* lock passes to runthread */
        _threaddebug(DBGSCHED, "waking process %d", t->proc->pid);
        while(rendezvous(q, 0) == (void*)~0){
            if(_threadexitsallstatus)
                exits(_threadexitsallstatus);
        }
    }else
        unlock(&t->proc->readylock);
}
@

<<function yield>>=
void
yield(void)
{
    _sched();
}
@


%-------------------------------------------------------------

<<lib_core/libthread/sched.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"
#include <tos.h>

static Thread	*runthread(Proc*);

<<global _psstate>>

<<function psstate>>

<<function _schedinit>>

<<function needstack>>

<<function _sched>>

<<function runthread>>

<<function _threadready>>

<<function yield>>

@


\subsection*{[[lib_core/libthread/create.c]]}

%-------------------------------------------------------------

<<lib_core/libthread/create.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<function nextID>>
    
<<function newthread>>

<<function threadcreate>>

<<function _newproc>>

<<function procrfork>>

<<function proccreate>>

<<function _freeproc>>

<<function _freethread>>

@


\subsection*{[[lib_core/libthread/channel.c]]}

<<global errcl>>=
static char errcl[] = "channel was closed";
@


<<constant Intred>>=
#define Intred	((void*)~0)		/* interrupted */
@

<<function isopenfor>>=
static int
isopenfor(Channel *c, int op)
{
    return c->closed == 0 || (op == CHANRCV && c->n > 0);
}
@

% !!!
<<function alt>>=
int
alt(Alt *alts)
{
    Alt *a, *xa, *ca;
    Channel volatile *c;
    int n, s, waiting, allreadycl;
    void* r;
    Thread *t;

    /*
     * The point of going splhi here is that note handlers
     * might reasonably want to use channel operations,
     * but that will hang if the note comes while we hold the
     * chanlock.  Instead, we delay the note until we've dropped
     * the lock.
     */
    t = _threadgetproc()->thread;
    if(t->moribund || _threadexitsallstatus)
        yield();	/* won't return */
    s = _procsplhi();

    lock(&chanlock);
    t->alt = alts;
    t->chan = Chanalt;

    /* test whether any channels can proceed */
    n = 0;
    a = nil;

    for(xa=alts; xa->op!=CHANEND && xa->op!=CHANNOBLK; xa++){
        xa->entryno = -1;
        if(xa->op == CHANNOP)
            continue;

        c = xa->c;
        if(c==nil){
            unlock(&chanlock);
            _procsplx(s);
            t->chan = Channone;
            return -1;
        }

        if(isopenfor(c, xa->op) && canexec(xa))
            if(nrand(++n) == 0)
                a = xa;
    }


    if(a==nil){
        /* nothing can proceed */
        if(xa->op == CHANNOBLK){
            unlock(&chanlock);
            _procsplx(s);
            t->chan = Channone;
            if(xa->op == CHANNOBLK)
                return xa - alts;
        }

        /* enqueue on all channels open for us. */
        c = nil;
        ca = nil;
        waiting = 0;
        allreadycl = 0;
        for(xa=alts; xa->op!=CHANEND; xa++)
            if(xa->op==CHANNOP)
                continue;
            else if(isopenfor(xa->c, xa->op)){
                waiting = 1;
                enqueue(xa, &c);
            } else if(xa->err != errcl)
                ca = xa;
            else
                allreadycl = 1;

        if(waiting == 0)
            if(ca != nil){
                /* everything was closed, select last channel */
                ca->err = errcl;
                unlock(&chanlock);
                _procsplx(s);
                t->chan = Channone;
                return ca - alts;
            } else if(allreadycl){
                /* everything was already closed */
                unlock(&chanlock);
                _procsplx(s);
                t->chan = Channone;
                return -1;
            }
        /*
         * wait for successful rendezvous.
         * we can't just give up if the rendezvous
         * is interrupted -- someone else might come
         * along and try to rendezvous with us, so
         * we need to be here.
         * if the channel was closed, the op is done
         * and we flag an error for the entry.
         */
        Again:
        unlock(&chanlock);
        _procsplx(s);
        r = _threadrendezvous(&c, 0);
        s = _procsplhi();
        lock(&chanlock);

        if(r==Intred){		/* interrupted */
            if(c!=nil)	/* someone will meet us; go back */
                goto Again;
            c = (Channel*)~0;	/* so no one tries to meet us */
        }

        /* dequeue from channels, find selected one */
        a = nil;
        for(xa=alts; xa->op!=CHANEND; xa++){
            if(xa->op==CHANNOP)
                continue;
            if(xa->c == c){
                a = xa;
                a->err = nil;
                if(r == Closed)
                    a->err = errcl;
            }
            dequeue(xa);
        }
        unlock(&chanlock);
        _procsplx(s);
        if(a == nil){	/* we were interrupted */
            assert(c==(Channel*)~0);
            return -1;
        }
    }else
        altexec(a, s);	/* unlocks chanlock, does splx */
    _sched();
    t->chan = Channone;
    return a - alts;
}
@

<<function chanclose>>=
int
chanclose(Channel *c)
{
    Alt *a;
    int i, s;

    s = _procsplhi();	/* note handlers; see :/^alt */
    lock(&chanlock);
    if(c->closed){
        /* Already close; we fail but it's ok. don't print */
        unlock(&chanlock);
        _procsplx(s);
        return -1;
    }
    c->closed = 1;		/* Being closed */
    /*
     * Locate entries that will fail due to close
     * (send, and receive if nothing buffered) and wake them up.
     * the situation cannot change because all queries
     * should be committed by now and new ones will find the channel
     * closed.  We still need to take the lock during the iteration
     * because we can wake threads on qentrys we have not seen yet
     * as in alt and there would be a race in the access to *a.
     */
    for(i = 0; i < c->nentry; i++){
        if((a = c->qentry[i]) == nil || *a->tag != nil)
            continue;

        if(a->op != CHANSND && (a->op != CHANRCV || c->n != 0))
            continue;
        *a->tag = c;
        unlock(&chanlock);
        _procsplx(s);
        while(_threadrendezvous(a->tag, Closed) == Intred)
            ;
        s = _procsplhi();
        lock(&chanlock);
    }

    c->closed = 2;		/* Fully closed */
    if(c->freed)
        _chanfree(c);
    unlock(&chanlock);
    _procsplx(s);
    return 0;
}
@

<<function chanclosing>>=
int
chanclosing(Channel *c)
{
    int n, s;

    s = _procsplhi();	/* note handlers; see :/^alt */
    lock(&chanlock);
    if(c->closed == 0)
        n = -1;
    else
        n = c->n;
    unlock(&chanlock);
    _procsplx(s);
    return n;
}
@

%/*
% * superseded by chanclosing
%int
%chanisclosed(Channel *c)
%{
%    return chanisclosing(c) >= 0;
%}
% */




<<function runop>>=
static int
runop(int op, Channel *c, void *v, int nb)
{
    int r;
    Alt a[2];

    /*
     * we could do this without calling alt,
     * but the only reason would be performance,
     * and i'm not convinced it matters.
     */
    a[0].op = op;
    a[0].c = c;
    a[0].v = v;
    a[0].err = nil;
    a[1].op = CHANEND;
    if(nb)
        a[1].op = CHANNOBLK;

    switch(r=alt(a)){
    case -1:	/* interrupted */
        return -1;
    case 1:	/* nonblocking, didn't accomplish anything */
        assert(nb);
        return 0;
    case 0:
        /*
         * Okay, but return -1 if the op is done because of a close.
         */
        if(a[0].err != nil)
            return -1;
        return 1;
    default:
        fprint(2, "ERROR: channel alt returned %d\n", r);
        abort();
        return -1;
    }
}
@

<<function recv>>=
int
recv(Channel *c, void *v)
{
    return runop(CHANRCV, c, v, 0);
}
@

<<function nbrecv>>=
int
nbrecv(Channel *c, void *v)
{
    return runop(CHANRCV, c, v, 1);
}
@

<<function send>>=
int
send(Channel *c, void *v)
{
    return runop(CHANSND, c, v, 0);
}
@

<<function nbsend>>=
int
nbsend(Channel *c, void *v)
{
    return runop(CHANSND, c, v, 1);
}
@

<<function channelsize>>=
static void
channelsize(Channel *c, int sz)
{
    if(c->e != sz){
        fprint(2, "expected channel with elements of size %d, got size %d\n",
            sz, c->e);
        abort();
    }
}
@

<<function sendul>>=
int
sendul(Channel *c, ulong v)
{
    channelsize(c, sizeof(ulong));
    return send(c, &v);
}
@

<<function recvul>>=
ulong
recvul(Channel *c)
{
    ulong v;

    channelsize(c, sizeof(ulong));
    if(recv(c, &v) < 0)
        return ~0;
    return v;
}
@

<<function sendp>>=
int
sendp(Channel *c, void *v)
{
    channelsize(c, sizeof(void*));
    return send(c, &v);
}
@

<<function recvp>>=
void*
recvp(Channel *c)
{
    void *v;

    channelsize(c, sizeof(void*));
    if(recv(c, &v) < 0)
        return nil;
    return v;
}
@

<<function nbsendul>>=
int
nbsendul(Channel *c, ulong v)
{
    channelsize(c, sizeof(ulong));
    return nbsend(c, &v);
}
@

<<function nbrecvul>>=
ulong
nbrecvul(Channel *c)
{
    ulong v;

    channelsize(c, sizeof(ulong));
    if(nbrecv(c, &v) == 0)
        return 0;
    return v;
}
@

<<function nbsendp>>=
int
nbsendp(Channel *c, void *v)
{
    channelsize(c, sizeof(void*));
    return nbsend(c, &v);
}
@

<<function nbrecvp>>=
void*
nbrecvp(Channel *c)
{
    void *v;

    channelsize(c, sizeof(void*));
    if(nbrecv(c, &v) == 0)
        return nil;
    return v;
}
@

<<function emptyentry>>=
static int
emptyentry(Channel *c)
{
    int i, extra;

    assert((c->nentry==0 && c->qentry==nil) || (c->nentry && c->qentry));

    for(i=0; i<c->nentry; i++)
        if(c->qentry[i]==nil)
            return i;

    extra = 16;
    c->nentry += extra;
    c->qentry = realloc((void*)c->qentry, c->nentry*sizeof(c->qentry[0]));
    if(c->qentry == nil)
        sysfatal("realloc channel entries: %r");
    memset(&c->qentry[i], 0, extra*sizeof(c->qentry[0]));
    return i;
}
@




<<function enqueue>>=
static void
enqueue(Alt *a, Channel **c)
{
    int i;

    _threaddebug(DBGCHAN, "Queuing alt %p on channel %p", a, a->c);
    a->tag = c;
    i = emptyentry(a->c);
    a->c->qentry[i] = a;
}
@

<<function dequeue>>=
static void
dequeue(Alt *a)
{
    int i;
    Channel *c;

    c = a->c;
    for(i=0; i<c->nentry; i++)
        if(c->qentry[i]==a){
            _threaddebug(DBGCHAN, "Dequeuing alt %p from channel %p", a, a->c);
            c->qentry[i] = nil;
            /* release if freed and not closing */
            if(c->freed && c->closed != 1)
                _chanfree(c);
            return;
        }
}
@

<<function canexec>>=
static int
canexec(Alt *a)
{
    int i, otherop;
    Channel *c;

    c = a->c;
    /* are there senders or receivers blocked? */
    otherop = (CHANSND+CHANRCV) - a->op;
    for(i=0; i<c->nentry; i++)
        if(c->qentry[i] && c->qentry[i]->op==otherop && *c->qentry[i]->tag==nil){
            _threaddebug(DBGCHAN, "can rendez alt %p chan %p", a, c);
            return 1;
        }

    /* is there room in the channel? */
    if((a->op==CHANSND && c->n < c->s)
    || (a->op==CHANRCV && c->n > 0)){
        _threaddebug(DBGCHAN, "can buffer alt %p chan %p", a, c);
        return 1;
    }

    return 0;
}
@

<<function altexecbuffered>>=
static void*
altexecbuffered(Alt *a, int willreplace)
{
    uchar *v;
    Channel *c;

    c = a->c;
    /* use buffered channel queue */
    if(a->op==CHANRCV && c->n > 0){
        _threaddebug(DBGCHAN, "buffer recv alt %p chan %p", a, c);
        v = c->v + c->e*(c->f%c->s);
        if(!willreplace)
            c->n--;
        c->f++;
        return v;
    }
    if(a->op==CHANSND && c->n < c->s){
        _threaddebug(DBGCHAN, "buffer send alt %p chan %p", a, c);
        v = c->v + c->e*((c->f+c->n)%c->s);
        if(!willreplace)
            c->n++;
        return v;
    }
    abort();
    return nil;
}
@

<<function altcopy>>=
static void
altcopy(void *dst, void *src, int sz)
{
    if(dst){
        if(src)
            memmove(dst, src, sz);
        else
            memset(dst, 0, sz);
    }
}
@

<<function altexec>>=
static int
altexec(Alt *a, int spl)
{
    volatile Alt *b;
    int i, n, otherop;
    Channel *c;
    void *me, *waiter, *buf;

    c = a->c;

    /* rendezvous with others */
    otherop = (CHANSND+CHANRCV) - a->op;
    n = 0;
    b = nil;
    me = a->v;
    for(i=0; i<c->nentry; i++)
        if(c->qentry[i] && c->qentry[i]->op==otherop && *c->qentry[i]->tag==nil)
            if(nrand(++n) == 0)
                b = c->qentry[i];
    if(b != nil){
        _threaddebug(DBGCHAN, "rendez %s alt %p chan %p alt %p", a->op==CHANRCV?"recv":"send", a, c, b);
        waiter = b->v;
        if(c->s && c->n){
            /*
             * if buffer is full and there are waiters
             * and we're meeting a waiter,
             * we must be receiving.
             *
             * we use the value in the channel buffer,
             * copy the waiter's value into the channel buffer
             * on behalf of the waiter, and then wake the waiter.
             */
            if(a->op!=CHANRCV)
                abort();
            buf = altexecbuffered(a, 1);
            altcopy(me, buf, c->e);
            altcopy(buf, waiter, c->e);
        }else{
            if(a->op==CHANRCV)
                altcopy(me, waiter, c->e);
            else
                altcopy(waiter, me, c->e);
        }
        *b->tag = c;	/* commits us to rendezvous */
        _threaddebug(DBGCHAN, "unlocking the chanlock");
        unlock(&chanlock);
        _procsplx(spl);
        _threaddebug(DBGCHAN, "chanlock is %lud", *(ulong*)&chanlock);
        while(_threadrendezvous(b->tag, 0) == Intred)
            ;
        return 1;
    }

    buf = altexecbuffered(a, 0);
    if(a->op==CHANRCV)
        altcopy(me, buf, c->e);
    else
        altcopy(buf, me, c->e);

    unlock(&chanlock);
    _procsplx(spl);
    return 1;
}
@


%-------------------------------------------------------------

<<lib_core/libthread/channel.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<enum _anon_ (lib_core/libthread/channel.c)>>

<<global errcl>>
<<global chanlock>>

static void enqueue(Alt*, Channel**);
static void dequeue(Alt*);
static int canexec(Alt*);
static int altexec(Alt*, int);

<<constant Closed>>
<<constant Intred>>

<<function _chanfree>>

<<function chanfree>>

<<function chaninit>>

<<function chancreate>>

<<function isopenfor>>

<<function alt>>

<<function chanclose>>

<<function chanclosing>>

<<function runop>>

<<function recv>>

<<function nbrecv>>

<<function send>>

<<function nbsend>>

<<function channelsize>>

<<function sendul>>

<<function recvul>>

<<function sendp>>

<<function recvp>>

<<function nbsendul>>

<<function nbrecvul>>

<<function nbsendp>>

<<function nbrecvp>>

<<function emptyentry>>

<<function enqueue>>

<<function dequeue>>

<<function canexec>>

<<function altexecbuffered>>

<<function altcopy>>

<<function altexec>>
@


\subsection*{[[lib_core/libthread/main.c]]}



<<global _threadnotefd>>=
int	_threadnotefd;
@

<<global _threadpasserpid>>=
int	_threadpasserpid;
@



<<function skip>>=
static char*
skip(char *p)
{
    while(*p == ' ')
        p++;
    while(*p != ' ' && *p != 0)
        p++;
    return p;
}
@

<<function _times>>=
static long
_times(long *t)
{
    char b[200], *p;
    int f;
    ulong r;

    memset(b, 0, sizeof(b));
    f = open("/dev/cputime", OREAD|OCEXEC);
    if(f < 0)
        return 0;
    if(read(f, b, sizeof(b)) <= 0){
        close(f);
        return 0;
    }
    p = b;
    if(t)
        t[0] = atol(p);
    p = skip(p);
    if(t)
        t[1] = atol(p);
    p = skip(p);
    r = atol(p);
    if(t){
        p = skip(p);
        t[2] = atol(p);
        p = skip(p);
        t[3] = atol(p);
    }
    return r;
}
@

<<function efork>>=
static void
efork(Execargs *e)
{
    char buf[ERRMAX];

    _threaddebug(DBGEXEC, "_schedexec %s", e->prog);
    close(e->fd[0]);
    exec(e->prog, e->args);
    _threaddebug(DBGEXEC, "_schedexec failed: %r");
    rerrstr(buf, sizeof buf);
    if(buf[0]=='\0')
        strcpy(buf, "exec failed");
    write(e->fd[1], buf, strlen(buf));
    close(e->fd[1]);
    _exits(buf);
}
@

<<function _schedexec>>=
int
_schedexec(Execargs *e)
{
    int pid;

    switch(pid = rfork(RFREND|RFNOTEG|RFFDG|RFMEM|RFPROC)){
    case 0:
        efork(e);
    default:
        return pid;
    }
}
@

<<function _schedfork>>=
int
_schedfork(Proc *p)
{
    int pid;

    switch(pid = rfork(RFPROC|RFMEM|RFNOWAIT|p->rforkflag)){
    case 0:
        *mainp = p;	/* write to stack, so local to proc */
        longjmp(_mainjmp, 1);
    default:
        return pid;
    }
}
@

<<function _schedexit>>=
void
_schedexit(Proc *p)
{
    char ex[ERRMAX];
    Proc **l;

    lock(&_threadpq.lock);
    for(l=&_threadpq.head; *l; l=&(*l)->next){
        if(*l == p){
            *l = p->next;
            if(*l == nil)
                _threadpq.tail = l;
            break;
        }
    }
    unlock(&_threadpq.lock);

    utfecpy(ex, ex+sizeof ex, p->exitstr);
    free(p);
    _exits(ex);
}
@

<<function _schedexecwait>>=
void
_schedexecwait(void)
{
    int pid;
    Channel *c;
    Proc *p;
    Thread *t;
    Waitmsg *w;

    p = _threadgetproc();
    t = p->thread;
    pid = t->ret;
    _threaddebug(DBGEXEC, "_schedexecwait %d", t->ret);

    rfork(RFCFDG);
    for(;;){
        w = wait();
        if(w == nil)
            break;
        if(w->pid == pid)
            break;
        free(w);
    }
    if(w != nil){
        if((c = _threadwaitchan) != nil)
            sendp(c, w);
        else
            free(w);
    }
    threadexits("procexec");
}
@

%-------------------------------------------------------------

<<lib_core/libthread/main.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

typedef struct Mainarg Mainarg;

<<struct Mainarg>>

<<global mainstacksize>>
<<global _threadnotefd>>
<<global _threadpasserpid>>

<<global _mainjmp>>

static void mainlauncher(void*);
extern void (*_sysfatal)(char*, va_list);
extern void (*__assert)(char*);
extern int (*_dial)(char*, char*, char*, int*);

extern int _threaddial(char*, char*, char*, int*);

<<global mainp>>

<<function main>>

<<function mainlauncher>>

<<function skip>>

<<function _times>>

<<function efork>>

<<function _schedexec>>

<<function _schedfork>>

<<function _schedexit>>

<<function _schedexecwait>>

@


\subsection*{[[lib_core/libthread/kill.c]]}

<<function threadxxxgrp>>=
static void
threadxxxgrp(int grp, int dokill)
{
    Proc *p;
    Thread *t;

    lock(&_threadpq.lock);
    for(p=_threadpq.head; p; p=p->next){
        lock(&p->lock);
        for(t=p->threads.head; t; t=t->nextt)
            if(t->grp == grp){
                if(dokill)
                    t->moribund = 1;
                tinterrupt(p, t);
            }
        unlock(&p->lock);
    }
    unlock(&_threadpq.lock);
    _threadbreakrendez();
}
@

<<function threadxxx>>=
static void
threadxxx(int id, int dokill)
{
    Proc *p;
    Thread *t;

    lock(&_threadpq.lock);
    for(p=_threadpq.head; p; p=p->next){
        lock(&p->lock);
        for(t=p->threads.head; t; t=t->nextt)
            if(t->id == id){
                if(dokill)
                    t->moribund = 1;
                tinterrupt(p, t);
                unlock(&p->lock);
                unlock(&_threadpq.lock);
                _threadbreakrendez();
                return;
            }
        unlock(&p->lock);
    }
    unlock(&_threadpq.lock);
    _threaddebug(DBGNOTE, "Can't find thread to kill");
    return;
}
@

<<function threadkillgrp>>=
void
threadkillgrp(int grp)
{
    threadxxxgrp(grp, 1);
}
@

<<function threadkill>>=
void
threadkill(int id)
{
    threadxxx(id, 1);
}
@

<<function threadintgrp>>=
void
threadintgrp(int grp)
{
    threadxxxgrp(grp, 0);
}
@

<<function threadint>>=
void
threadint(int id)
{
    threadxxx(id, 0);
}
@

<<function tinterrupt>>=
static void
tinterrupt(Proc *p, Thread *t)
{
    switch(t->state){
    case Running:
        postnote(PNPROC, p->pid, "threadint");
        break;
    case Rendezvous:
        _threadflagrendez(t);
        break;
    }
}
@

%-------------------------------------------------------------

<<lib_core/libthread/kill.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

static void tinterrupt(Proc*, Thread*);

<<function threadxxxgrp>>

<<function threadxxx>>

<<function threadkillgrp>>

<<function threadkill>>

<<function threadintgrp>>

<<function threadint>>

<<function tinterrupt>>
@


\subsection*{[[lib_core/libthread/ioproc.c]]}

<<enum _anon_ (lib_core/libthread/ioproc.c)>>=
enum
{
    STACK = 8192,
};
@

<<function iointerrupt>>=
void
iointerrupt(Ioproc *io)
{
    if(!io->inuse)
        return;
    threadint(io->tid);
}
@

<<function xioproc>>=
static void
xioproc(void *a)
{
    Ioproc *io, *x;
    io = a;
    /*
     * first recvp acquires the ioproc.
     * second tells us that the data is ready.
     */
    for(;;){
        while(recv(io->c, &x) == -1)
            ;
        if(x == 0)	/* our cue to leave */
            break;
        assert(x == io);

        /* caller is now committed -- even if interrupted he'll return */
        while(recv(io->creply, &x) == -1)
            ;
        if(x == 0)	/* caller backed out */
            continue;
        assert(x == io);

        io->ret = io->op(&io->arg);
        if(io->ret < 0)
            rerrstr(io->err, sizeof io->err);
        while(send(io->creply, &io) == -1)
            ;
        while(recv(io->creply, &x) == -1)
            ;
    }
}
@


<<function closeioproc>>=
void
closeioproc(Ioproc *io)
{
    if(io == nil)
        return;
    iointerrupt(io);
    while(send(io->c, 0) == -1)
        ;
    chanfree(io->c);
    chanfree(io->creply);
    free(io);
}
@


%-------------------------------------------------------------

<<lib_core/libthread/ioproc.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<enum _anon_ (lib_core/libthread/ioproc.c)>>

<<function iointerrupt>>

<<function xioproc>>

<<function ioproc>>

<<function closeioproc>>
@


\subsection*{[[lib_core/libthread/iocall.c]]}

<<function iocall>>=
long
iocall(Ioproc *io, long (*op)(va_list*), ...)
{
    int ret, inted;
    Ioproc *msg;

    if(send(io->c, &io) == -1){
        werrstr("interrupted");
        return -1;
    }
    assert(!io->inuse);
    io->inuse = 1;
    io->op = op;
    va_start(io->arg, op);
    msg = io;
    inted = 0;
    while(send(io->creply, &msg) == -1){
        msg = nil;
        inted = 1;
    }
    if(inted){
        werrstr("interrupted");
        return -1;
    }

    /*
     * If we get interrupted, we have to stick around so that
     * the IO proc has someone to talk to.  Send it an interrupt
     * and try again.
     */
    inted = 0;
    while(recv(io->creply, nil) == -1){
        inted = 1;
        iointerrupt(io);
    }
    USED(inted);
    va_end(io->arg);
    ret = io->ret;
    if(ret < 0)
        errstr(io->err, sizeof io->err);
    io->inuse = 0;

    /* release resources */
    while(send(io->creply, &io) == -1)
        ;
    return ret;
}
@


%-------------------------------------------------------------

<<lib_core/libthread/iocall.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<function iocall>>
@


\subsection*{[[lib_core/libthread/chanprint.c]]}

<<function chanprint>>=
int
chanprint(Channel *c, char *fmt, ...)
{
    va_list arg;
    char *p;
    int n;

    va_start(arg, fmt);
    p = vsmprint(fmt, arg);
    va_end(arg);
    if(p == nil)
        sysfatal("vsmprint failed: %r");
    n = sendp(c, p);
    yield();	/* let recipient handle message immediately */
    return n;
}
@


%-------------------------------------------------------------

<<lib_core/libthread/chanprint.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>

<<function chanprint>>
@


\subsection*{[[lib_core/libthread/ioclose.c]]}

<<function _ioclose>>=
static long
_ioclose(va_list *arg)
{
    int fd;

    fd = va_arg(*arg, int);
    return close(fd);
}
@

<<function ioclose>>=
int
ioclose(Ioproc *io, int fd)
{
    return iocall(io, _ioclose, fd);
}
@


%-------------------------------------------------------------

<<lib_core/libthread/ioclose.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<function _ioclose>>

<<function ioclose>>
@


\subsection*{[[lib_core/libthread/iodial.c]]}

<<function _iodial>>=
static long
_iodial(va_list *arg)
{
    char *addr, *local, *dir;
    int *cdfp;

    addr = va_arg(*arg, char*);
    local = va_arg(*arg, char*);
    dir = va_arg(*arg, char*);
    cdfp = va_arg(*arg, int*);

    return dial(addr, local, dir, cdfp);
}
@

<<function iodial>>=
int
iodial(Ioproc *io, char *addr, char *local, char *dir, int *cdfp)
{
    return iocall(io, _iodial, addr, local, dir, cdfp);
}
@


%-------------------------------------------------------------

<<lib_core/libthread/iodial.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<function _iodial>>

<<function iodial>>
@


\subsection*{[[lib_core/libthread/ioopen.c]]}

<<function _ioopen>>=
static long
_ioopen(va_list *arg)
{
    char *path;
    int mode;

    path = va_arg(*arg, char*);
    mode = va_arg(*arg, int);
    return open(path, mode);
}
@

<<function ioopen>>=
int
ioopen(Ioproc *io, char *path, int mode)
{
    return iocall(io, _ioopen, path, mode);
}
@


%-------------------------------------------------------------

<<lib_core/libthread/ioopen.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<function _ioopen>>

<<function ioopen>>
@


\subsection*{[[lib_core/libthread/ioread.c]]}

<<function _ioread>>=
static long
_ioread(va_list *arg)
{
    int fd;
    void *a;
    long n;

    fd = va_arg(*arg, int);
    a = va_arg(*arg, void*);
    n = va_arg(*arg, long);
    return read(fd, a, n);
}
@

<<function ioread>>=
long
ioread(Ioproc *io, int fd, void *a, long n)
{
    return iocall(io, _ioread, fd, a, n);
}
@


%-------------------------------------------------------------

<<lib_core/libthread/ioread.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<function _ioread>>

<<function ioread>>
@


\subsection*{[[lib_core/libthread/ioreadn.c]]}

<<function _ioreadn>>=
static long
_ioreadn(va_list *arg)
{
    int fd;
    void *a;
    long n;

    fd = va_arg(*arg, int);
    a = va_arg(*arg, void*);
    n = va_arg(*arg, long);
    return readn(fd, a, n);
}
@

<<function ioreadn>>=
long
ioreadn(Ioproc *io, int fd, void *a, long n)
{
    return iocall(io, _ioreadn, fd, a, n);
}
@


%-------------------------------------------------------------

<<lib_core/libthread/ioreadn.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<function _ioreadn>>

<<function ioreadn>>
@


\subsection*{[[lib_core/libthread/iosleep.c]]}

<<function _iosleep>>=
static long
_iosleep(va_list *arg)
{
    long n;

    n = va_arg(*arg, long);
    return sleep(n);
}
@

<<function iosleep>>=
int
iosleep(Ioproc *io, long n)
{
    return iocall(io, _iosleep, n);
}
@


%-------------------------------------------------------------

<<lib_core/libthread/iosleep.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<function _iosleep>>

<<function iosleep>>
@


\subsection*{[[lib_core/libthread/iowrite.c]]}

<<function _iowrite>>=
static long
_iowrite(va_list *arg)
{
    int fd;
    void *a;
    long n;

    fd = va_arg(*arg, int);
    a = va_arg(*arg, void*);
    n = va_arg(*arg, long);
    return write(fd, a, n);
}
@

<<function iowrite>>=
long
iowrite(Ioproc *io, int fd, void *a, long n)
{
    return iocall(io, _iowrite, fd, a, n);
}
@


%-------------------------------------------------------------

<<lib_core/libthread/iowrite.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<function _iowrite>>

<<function iowrite>>
@


\subsection*{[[lib_core/libthread/dial.c]]}

<<enum _anon_ (lib_core/libthread/dial.c)>>=
enum
{
    Maxstring	= 128,
    Maxpath		= 256,
};
@

<<struct DS>>=
struct DS {
    /* dist string */
    char	buf[Maxstring];
    char	*netdir;
    char	*proto;
    char	*rem;

    /* other args */
    char	*local;
    char	*dir;
    int	*cfdp;
};
@

<<function _threaddial>>=
/*
 *  the dialstring is of the form '[/net/]proto!dest'
 */
int
_threaddial(char *dest, char *local, char *dir, int *cfdp)
{
    DS ds;
    int rv;
    char err[ERRMAX], alterr[ERRMAX];

    ds.local = local;
    ds.dir = dir;
    ds.cfdp = cfdp;

    _dial_string_parse(dest, &ds);
    if(ds.netdir)
        return csdial(&ds);

    ds.netdir = "/net";
    rv = csdial(&ds);
    if(rv >= 0)
        return rv;
    err[0] = '\0';
    errstr(err, sizeof err);
    if(strstr(err, "refused") != 0){
        werrstr("%s", err);
        return rv;
    }
    ds.netdir = "/net.alt";
    rv = csdial(&ds);
    if(rv >= 0)
        return rv;

    alterr[0] = 0;
    errstr(alterr, sizeof alterr);
    if(strstr(alterr, "translate") || strstr(alterr, "does not exist"))
        werrstr("%s", err);
    else
        werrstr("%s", alterr);
    return rv;
}
@

<<function csdial>>=
static int
csdial(DS *ds)
{
    int n, fd, rv;
    char *p, buf[Maxstring], clone[Maxpath], err[ERRMAX], besterr[ERRMAX];

    /*
     *  open connection server
     */
    snprint(buf, sizeof(buf), "%s/cs", ds->netdir);
    fd = open(buf, ORDWR);
    if(fd < 0){
        /* no connection server, don't translate */
        snprint(clone, sizeof(clone), "%s/%s/clone", ds->netdir, ds->proto);
        return call(clone, ds->rem, ds);
    }

    /*
     *  ask connection server to translate
     */
    snprint(buf, sizeof(buf), "%s!%s", ds->proto, ds->rem);
    if(write(fd, buf, strlen(buf)) < 0){
        close(fd);
        return -1;
    }

    /*
     *  loop through each address from the connection server till
     *  we get one that works.
     */
    *besterr = 0;
    rv = -1;
    seek(fd, 0, 0);
    while((n = read(fd, buf, sizeof(buf) - 1)) > 0){
        buf[n] = 0;
        p = strchr(buf, ' ');
        if(p == 0)
            continue;
        *p++ = 0;
        rv = call(buf, p, ds);
        if(rv >= 0)
            break;
        err[0] = '\0';
        errstr(err, sizeof err);
        if(strstr(err, "does not exist") == 0)
            strcpy(besterr, err);
    }
    close(fd);

    if(rv < 0 && *besterr)
        werrstr("%s", besterr);
    else
        werrstr("%s", err);
    return rv;
}
@

<<function call>>=
static int
call(char *clone, char *dest, DS *ds)
{
    int fd, cfd, n;
    char cname[Maxpath], name[Maxpath], data[Maxpath], *p;

    /* because cs is in a different name space, replace the mount point */
    if(*clone == '/'){
        p = strchr(clone+1, '/');
        if(p == nil)
            p = clone;
        else 
            p++;
    } else
        p = clone;
    snprint(cname, sizeof cname, "%s/%s", ds->netdir, p);

    cfd = open(cname, ORDWR);
    if(cfd < 0)
        return -1;

    /* get directory name */
    n = read(cfd, name, sizeof(name)-1);
    if(n < 0){
        close(cfd);
        return -1;
    }
    name[n] = 0;
    for(p = name; *p == ' '; p++)
        ;
    snprint(name, sizeof(name), "%ld", strtoul(p, 0, 0));
    p = strrchr(cname, '/');
    *p = 0;
    if(ds->dir)
        snprint(ds->dir, NETPATHLEN, "%s/%s", cname, name);
    snprint(data, sizeof(data), "%s/%s/data", cname, name);

    /* connect */
    if(ds->local)
        snprint(name, sizeof(name), "connect %s %s", dest, ds->local);
    else
        snprint(name, sizeof(name), "connect %s", dest);
    if(write(cfd, name, strlen(name)) < 0){
        close(cfd);
        return -1;
    }

    /* open data connection */
    fd = open(data, ORDWR);
    if(fd < 0){
        close(cfd);
        return -1;
    }
    if(ds->cfdp)
        *ds->cfdp = cfd;
    else
        close(cfd);
    return fd;
}
@

<<function _dial_string_parse>>=
/*
 *  parse a dial string
 */
static void
_dial_string_parse(char *str, DS *ds)
{
    char *p, *p2;

    strncpy(ds->buf, str, Maxstring);
    ds->buf[Maxstring-1] = 0;

    p = strchr(ds->buf, '!');
    if(p == 0) {
        ds->netdir = 0;
        ds->proto = "net";
        ds->rem = ds->buf;
    } else {
        if(*ds->buf != '/' && *ds->buf != '#'){
            ds->netdir = 0;
            ds->proto = ds->buf;
        } else {
            for(p2 = p; *p2 != '/'; p2--)
                ;
            *p2++ = 0;
            ds->netdir = ds->buf;
            ds->proto = p2;
        }
        *p = 0;
        ds->rem = p + 1;
    }
}
@


%-------------------------------------------------------------

<<lib_core/libthread/dial.c>>=
/*
 * old single-process version of dial that libthread can cope with
 */
#include <u.h>
#include <libc.h>

typedef struct DS DS;

static int	call(char*, char*, DS*);
static int	csdial(DS*);
static void	_dial_string_parse(char*, DS*);

<<enum _anon_ (lib_core/libthread/dial.c)>>

<<struct DS>>


<<function _threaddial>>

<<function csdial>>

<<function call>>

<<function _dial_string_parse>>
@


\subsection*{[[lib_core/libthread/exec.c]]}

<<constant PIPEMNT>>=
#define PIPEMNT	"/mnt/temp"
@

<<function procexec>>=
void
procexec(Channel *pidc, char *prog, char *args[])
{
    int n;
    Proc *p;
    Thread *t;

    _threaddebug(DBGEXEC, "procexec %s", prog);
    /* must be only thread in proc */
    p = _threadgetproc();
    t = p->thread;
    if(p->threads.head != t || p->threads.head->nextt != nil){
        werrstr("not only thread in proc");
    Bad:
        if(pidc)
            sendul(pidc, ~0);
        return;
    }

    /*
     * We want procexec to behave like exec; if exec succeeds,
     * never return, and if it fails, return with errstr set.
     * Unfortunately, the exec happens in another proc since
     * we have to wait for the exec'ed process to finish.
     * To provide the semantics, we open a pipe with the 
     * write end close-on-exec and hand it to the proc that
     * is doing the exec.  If the exec succeeds, the pipe will
     * close so that our read below fails.  If the exec fails,
     * then the proc doing the exec sends the errstr down the
     * pipe to us.
     */
    if(bind("#|", PIPEMNT, MREPL) < 0)
        goto Bad;
    if((p->exec.fd[0] = open(PIPEMNT "/data", OREAD)) < 0){
        unmount(nil, PIPEMNT);
        goto Bad;
    }
    if((p->exec.fd[1] = open(PIPEMNT "/data1", OWRITE|OCEXEC)) < 0){
        close(p->exec.fd[0]);
        unmount(nil, PIPEMNT);
        goto Bad;
    }
    unmount(nil, PIPEMNT);

    /* exec in parallel via the scheduler */
    assert(p->needexec==0);
    p->exec.prog = prog;
    p->exec.args = args;
    p->needexec = 1;
    _sched();

    close(p->exec.fd[1]);
    if((n = read(p->exec.fd[0], p->exitstr, ERRMAX-1)) > 0){	/* exec failed */
        p->exitstr[n] = '\0';
        errstr(p->exitstr, ERRMAX);
        close(p->exec.fd[0]);
        goto Bad;
    }
    close(p->exec.fd[0]);

    if(pidc)
        sendul(pidc, t->ret);

    /* wait for exec'ed program, then exit */
    _schedexecwait();
}
@

<<function procexecl>>=
void
procexecl(Channel *pidc, char *f, ...)
{
    procexec(pidc, f, &f+1);
}
@


%-------------------------------------------------------------

<<lib_core/libthread/exec.c>>=
#include <u.h>
#include <libc.h>
#include <thread.h>
#include "threadimpl.h"

<<constant PIPEMNT>>

<<function procexec>>

<<function procexecl>>

@
