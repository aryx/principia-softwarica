\documentclass[twocolumn, landscape]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse % see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, I changed for the better a few things:
% - ??

%thx to codemap/codegraph/scheck:
% - TODO use cg to reduce backward deps, introduce globals.c, utils.c,
%   (harder to understand non layered code)
% - TODO use scheck to remove deadcode, dead prototypes, useless export
%   or mv as forward decl
%   (harder to understand big interface files)
% - TODO use cg to reduce number of globals by moving them closer to the
%   relevant file (or even function), better cluster the code
%   (harder to understand non functional code using lots of globals)

%thx to this manual, better understand libc:
% - TODO errno global
% - SEMI malloc vs brk internals

%history LP-ization:
% - skeleton, mostly copy paste of Template.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * TODO ctor/dtor, dumper
%    * TODO [[xxx]] other fields, [[xxx]] extra fields
% - read Extra section, identify concepts, first TOC
% - SEMI distribute parts of the Extra section in the main file
% - TODO understand main(), LP split main, improve TOC
% - TODO understand main functions, LP split, cluster, improve TOC
% - TODO LP split the structures, use datalog for flow to field info
% - SEMI nullify, boolify, errorify, enumify,  typeify,    scheckify, plan9ify
% - TODO aspecify advanced features! remove useless features
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% ifallcode is used for:
%  - forward decl, func decl, extern decl, #ifdef, pragmas (stuff in Extra.nw)
%  - ??

\addtolength{\topmargin}{-.850in}
\addtolength{\textheight}{1.70in}


\begin{document}
%******************************************************************************
% Title
%******************************************************************************
\title{
{\Huge 
Principia Softwarica: The Plan~9 Core Libraries
}\\
{version 0.1}
}
% ARM edition? for very few code so maybe not that needed to put in title?

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}
}

\maketitle 
\onecolumn
\hrule
\input{../docs/latex/Copyright}
\input{../docs/latex/CopyrightPlan9}
\hrule
\twocolumn


\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\tableofcontents
\endgroup

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

The goal of this book is to explain with full details the source code of
{core libraries}.

\section{Motivations}

Why core libraries? Because I think you are a better programmer if
you fully understand how things work under the hood.
% and code in those libs underly everything.
% even kernel!

% interested mostly C libraries. Also some Asm.
% Linked in all programs.

% Some core components like malloc/free. Essential. Surprisingly
% most people dont know how it works internally.
% Again Google. Facebook have people designing new memory allocator
% (jmealloc, tcmalloc). Core component!

% Unicode also, more recent, again most people dont know. Learn by
% implementation here.

% Finally Thread scheduler. Again if implement lang, and not unusual,
% Erlang, Elixir, Clojure, etc need know very well this stuff.

Here are a few questions I hope this book will answer:
\begin{itemize}

\item Is there any code executed before [[main()]] in a C program?

\item Which program does memory allocation? The kernel? The C library? 
How [[malloc()]] is implemented? 
How it relates to the [[sbrk()]] system call?

\item How does a thread scheduler work? 
How is implemented [[alt()]] without [[select()]] in the kernel?

\end{itemize}
\l sinus, cosinus, how when no hardware support?

\section{The \plan core libraries: [[libc]], [[libregexp]], and [[libthread]]}

% gonna present core libs of plan9, its libc of course, 
% but also its thread libraries,
% regexp, memory managment, unicode, etc.
% most of the generally useful and generic building blocks for regular
% applications!
% X LOC of C and Y LOC of ARM assembly (same amount for other archi).

%see soft archi in Principia and all the boxes for the libc

% also libbio/ (used by a few programs), libstring/ (but seems unused)

\section{Other core libraries}

Here are a few core libraries that I considered for this book but
which I ultimately discarded:
\begin{itemize}

\item GNU Libc
% huge, can't be linked statically

\item dietlibc

\item microlibc

\end{itemize}

%other:
%#other libc
% - libc in dev86
% - muslc
%#other core libs
% - .NET Core, small set of APIs (primitives, collections, reflection, interop)
% - .NET Standard, bigger set of APIs
%   https://blogs.msdn.microsoft.com/dotnet/2016/09/26/introducing-net-standard/
%   (before was .NET Core, and .NET framework, and Windows Foundation)
%   with Core, Threading, Io, Networking, Serialization, XML
% - Core in MacOSX? 
%mini:
% - libcii, from Hanson book
%misc:
% - kencc/libmach/ is using netlib/fdlibm

% comparison: http://www.etalabs.net/compare_libcs.html
% musl seems good in this comparison (but they are the author of the comparison)
% https://gist.github.com/cl91/bb927df2525738502131#file-static-linking-against-musl-md

\section{Getting started}

% cd /src/libc
% objtype=arm
%  (if not under ARM archi already)
%  (so we will cross compile ARM libc)
% mk all
% cd /test/5c
% 5l 


\section{Requirements}

% see intro(2), overview of many libs
% (just like intro(1) is overview of utilities)

\section{About this document}
#include "../docs/latex/About.nw"

\section{Copyright}
\input{../docs/latex/CopyrightPlan9Text}

\section{Acknowledgments}





\chapter{Overview}

%TODO: errno
%    if(getwd(pathname, sizeof(pathname)) == 0) {
%        fprint(2, "pwd: %r\n");
%        exits("getwd");
%    }
% what is %r? last error code from libc function? a bit ugly
% those == 0 are also ugly.

\section{Principles}
%\section{Core components}

\subsection{Core versus non-core}
% what is core?

\subsection{User/kernel bridge, system calls}

% each chapter has first section syscall and then build utilities
%  on top of it
%missing syscalls not covered yet: exec, dup, fversion, fauth

\subsection{Memory allocator}

\subsection{Zero-cost abstractions}
% if slow, everything is slow



\section{[[libc.h]]}
% in \plan no hundreds of header files (stdio.h, unistd.h, stdlib.h...)
% mostly just libc.h (and u.h).
% other header files are for other libraries: thread.h, regexp.h, draw.h, etc.


\section{Code organization}

% lib_core/libc/9sys/sys.h (part of Kernel.nw)
% include/core/libc.h (and syscall.h I created)


\section{Software architecture}

% note that libc should be thread-safe, malloc use locks!

% take common.ml structure for the TOC of this document?

\section{Book structure}

%###############################################################################

\chapter{Core Types and Data Structures}

\section{Basic types}

% void, int, double, 
% pointer, void*!
% signed vs unsigned, different int size, etc.
% All defined in Compiler.nw but libcore define a few aliases.

\subsection{Booleans}

<<type bool>>=
typedef int bool;
enum _bool {
  false = 0,
  true = 1
};
@
%pad: I added that


\subsection{Integers}

<<type uxxx>>=
typedef unsigned short  ushort;
typedef unsigned char   uchar;
typedef unsigned long   ulong;
typedef unsigned int    uint;
@

<<type uxxxint>>=
typedef unsigned char u8int;
typedef unsigned short u16int;
typedef unsigned int    u32int;
typedef unsigned long long u64int;
@
% ok this deserves to be in arm/u.h


<<type xxxvlong>>=
typedef long long   vlong;
typedef unsigned long long uvlong;
@


% A few convenient aliases
<<type usize>>=
typedef unsigned long   usize;
@


\subsection{Floats}

% in arm/u.h so probably arch specific
<<type FPdbleword>>=
union FPdbleword
{
    double  x;

    struct {    /* little endian */
        ulong lo;
        ulong hi;
    };
};
@

\subsection{Strings and characters}


<<type Ctype_flag>>=
#define	_U	01 // upper
#define	_L	02 // lower
#define	_N	04 // number
#define	_S	010 // space
#define	_P	020 // punctuation
#define	_C	040 // ctlr
#define	_B	0100 // ??
#define	_X	0200 // ??
@


<<global _ctype>>=
uchar   _ctype[256] =
{
/*   0   1   2   3   4   5   6   7  */

/*  0*/ _C, _C, _C, _C, _C, _C, _C, _C,
/* 10*/ _C, _S|_C,  _S|_C,  _S|_C,  _S|_C,  _S|_C,  _C, _C,
/* 20*/ _C, _C, _C, _C, _C, _C, _C, _C,
/* 30*/ _C, _C, _C, _C, _C, _C, _C, _C,
/* 40*/ _S|_B,  _P, _P, _P, _P, _P, _P, _P,
/* 50*/ _P, _P, _P, _P, _P, _P, _P, _P,
/* 60*/ _N|_X,  _N|_X,  _N|_X,  _N|_X,  _N|_X,  _N|_X,  _N|_X,  _N|_X,
/* 70*/ _N|_X,  _N|_X,  _P, _P, _P, _P, _P, _P,
/*100*/ _P, _U|_X,  _U|_X,  _U|_X,  _U|_X,  _U|_X,  _U|_X,  _U,
/*110*/ _U, _U, _U, _U, _U, _U, _U, _U,
/*120*/ _U, _U, _U, _U, _U, _U, _U, _U,
/*130*/ _U, _U, _U, _P, _P, _P, _P, _P,
/*140*/ _P, _L|_X,  _L|_X,  _L|_X,  _L|_X,  _L|_X,  _L|_X,  _L,
/*150*/ _L, _L, _L, _L, _L, _L, _L, _L,
/*160*/ _L, _L, _L, _L, _L, _L, _L, _L,
/*170*/ _L, _L, _L, _P, _P, _P, _P, _C,
};
@




% ugly that take an int, because that way compatible with Rune??
<<function toupper>>=
int
toupper(int c)
{

    if(c < 'a' || c > 'z')
        return c;
    return _toupper(c);
}
@

<<function tolower>>=
int
tolower(int c)
{

    if(c < 'A' || c > 'Z')
        return c;
    return _tolower(c);
}
@




% char =~ byte

<<type Rune>>=
typedef uint        Rune;
@

<<constant UTFmax>>=
UTFmax      = 4,        /* maximum bytes per rune */
@
<<constant Runesync>>=
Runesync    = 0x80,     /* cannot represent part of a UTF sequence (<) */
@
<<constant Runeself>>=
Runeself    = 0x80,     /* rune and UTF sequences are the same (<) */
@
<<constant Runeerror>>=
Runeerror   = 0xFFFD,   /* decoding error in UTF */
@
<<constant Runemax>>=
Runemax     = 0x10FFFF, /* 21-bit rune */
@
<<constant Runemask>>=
Runemask    = 0x1FFFFF, /* bits used by runes (see grep) */
@

\section{Complex types}

\subsection{Pointers}

<<constant nil>>=
#define nil     ((void*)0)
@
% why in u.h? could be in libc.h no?

<<type uintptr>>=
typedef unsigned long   uintptr;
@

<<type byte>>=
typedef uchar byte;
@

\subsection{Arrays}

<<function nelem>>=
#define nelem(x)    (sizeof(x)/sizeof((x)[0]))
@

\subsection{Structures}

<<function offsetof>>=
#define offsetof(s, m)  (ulong)(&(((s*)nil)->m))
@

\subsection{Functions}

<<type va_list>>=
typedef char*   va_list;
@

<<macro va_start>>=
#define va_start(list, start) list =\
    (sizeof(start) < 4?\
        (char*)((int*)&(start)+1):\
        (char*)(&(start)+1))
@

<<macro va_end>>=
#define va_end(list)\
    USED(list)
@
<<macro va_arg>>=
#define va_arg(list, mode)\
    ((sizeof(mode) == 1)?\
        ((list += 4), (mode*)list)[-4]:\
    (sizeof(mode) == 2)?\
        ((list += 4), (mode*)list)[-2]:\
        ((list += sizeof(mode)), (mode*)list)[-1])
@

%related: getcallerpc

%\section{Memory pool}
% More in memory management chapter

\section{Regular expression}
% more in Regexp chapter

% string, see special chapter

%\section{Fmt}
% regexp =~ for structured input
% fmt =~ for structured output

\section{IO}

<<type fdt>>=
typedef int fdt; // file descriptor type
@
%pad: I added that. More explicit, better signatures. abusing int is bad.

<<constant STDxxx>>=
#define STDIN 0
#define STDOUT 1
#define STDERR 2
@
%pad: I added that, but is in APE also

\section{Time}
% Tm

<<type Tm>>=
struct Tm {
    int sec;
    int min;
    int hour;

    int mday;
    int mon;
    int year;
    int wday;
    int yday;

    char    zone[4];
    int     tzoff;
};
@

\section{Concurrency data structures}

%\subsection{Locks}
% normal, read-write

%\subsection{Queues}

%\subsection{Rendez-vous}

%\subsection{Waitmsg}

%\subsection{Channels}


\section{Collections}

% collection types (not really :( ) but
% can provide template on how they encode lists, hashs, queues,
% double linked lists, trees, etc. See kernel.nw for instance,
% many example of collections.

%\section{Misc}
% lots of small enums for Open_flag, Dir_flag, Rfork_flag, profiling
% which are presented later


\chapter{[[_main()]]}

% arm/main9.s (and main9p.s)

%related: minimal C runtime for Linux
%https://github.com/lpsantil/rt0
%https://blogs.oracle.com/ksplice/entry/hello_from_a_libc_free

%real-world: crt0 for "C runtime 0"?

\section{Command-line arguments: [[ARGBEGIN()]], [[ARGEND()]]}

<<signature global argv0>>=
extern char *argv0;
@

<<macro ARGBEGIN>>=
#define ARGBEGIN    for((argv0||(argv0=*argv)),argv++,argc--;\
                argv[0] && argv[0][0]=='-' && argv[0][1];\
                argc--, argv++) {\
                char *_args, *_argt;\
                Rune _argc;\
                _args = &argv[0][1];\
                if(_args[0]=='-' && _args[1]==0){\
                    argc--; argv++; break;\
                }\
                _argc = 0;\
                while(*_args && (_args += chartorune(&_argc, _args)))\
                switch(_argc)
@

<<macro ARGEND>>=
#define ARGEND      SET(_argt);USED(_argt,_argc,_args);}USED(argv, argc);
@


<<macro ARGF>>=
#define ARGF()      (_argt=_args, _args="",\
                (*_argt? _argt: argv[1]? (argc--, *++argv): 0))
@

<<macro EARGF>>=
#define EARGF(x)    (_argt=_args, _args="",\
                (*_argt? _argt: argv[1]? (argc--, *++argv): ((x), abort(), (char*)0)))
@

<<macro ARGC>>=
#define ARGC()      _argc
@

\section{syscall: [[_exits()]]}
% ugly but special code in 9syscall/mkfile to rename call to 
% EXITS syscall to _exits instead of exits because probably wanted to
% add special code around _exits after and wanted to be backward
% compatible with previous programs already using exits() in their code.

\section{[[exits()]]}

% profile is turned off around this function
<<function exits>>=
void
exits(char *s)
{
    int i, pid;
    void (*f)(void);

    pid = getpid();
    for(i = NEXIT-1; i >= 0; i--)
        if((f = onex[i].f) && pid == onex[i].pid) {
            onex[i].f = nil;
            (*f)();
        }
    _exits(s);
}
@

<<global onex>>=
Onex onex[NEXIT];
@
<<constant NEXIT>>=
#define NEXIT   33
@

<<struct Onex>>=
struct Onex{
    void    (*f)(void);
    int pid;
};
@
% Onex.pid because some fork can still share memory
% but we want each fork to run separate callbacks when really
% exits.

<<global onexlock>>=
static Lock onexlock;
@
% See Section X for concurrency primitives.


<<function atexit>>=
int
atexit(void (*f)(void))
{
    int i;

    lock(&onexlock);
    for(i=0; i<NEXIT; i++)
        if(onex[i].f == nil) {
            onex[i].pid = getpid();
            onex[i].f = f;
            unlock(&onexlock);
            return 1;
        }
    unlock(&onexlock);
    return 0;
}
@

%dead:
%<<function atexitdont>>=
%void
%atexitdont(void (*f)(void))
%{
%    int i, pid;
%
%    pid = getpid();
%    for(i=0; i<NEXIT; i++)
%        if(onex[i].f == f && onex[i].pid == pid)
%            onex[i].f = 0;
%}
%@

\chapter{User/Kernel Bridge}

% sys.h, syscall.h
% lib_core/libc/9syscall/*.s and dispatcher in kernel for the sysxxx().
% FIGURE copy one in Principia.nw?


\chapter{Memory Area Operations}

% Lots of functions defined in assembly, so maximal control, maximal opti.
% Important cos used a lot.
% But also many portable (slower) implem in libc/port/

<<function memset>>=
void*
memset(void *ap, int c, ulong n)
{
    char *p;

    p = ap;
    while(n > 0) {
        *p++ = c;
        n--;
    }
    return ap;
}
@
% typing issue in *p++ = c? int vs char*? if set -1, it will work.


<<function memcpy>>=
void*
memcpy(void *a1, void *a2, ulong n)
{
    return memmove(a1, a2, n);
}
@


<<function memmove>>=
void*
memmove(void *a1, void *a2, ulong n)
{
    char *s1, *s2;

    if((long)n < 0)
        abort();
    s1 = a1;
    s2 = a2;
    if((s2 < s1) && (s2+n > s1))
        goto back;
    while(n > 0) {
        *s1++ = *s2++;
        n--;
    }
    return a1;

back:
    s1 += n;
    s2 += n;
    while(n > 0) {
        *--s1 = *--s2;
        n--;
    }
    return a1;
}
@
% really bad name
\t replace every call to memmove to memcpy!


<<function memcmp>>=
int
memcmp(void *a1, void *a2, ulong n)
{
    uchar *s1, *s2;
    uint c1, c2;

    s1 = a1;
    s2 = a2;
    while(n > 0) {
        c1 = *s1++;
        c2 = *s2++;
        if(c1 != c2) {
            if(c1 > c2)
                return 1;
            return -1;
        }
        n--;
    }
    return 0;
}
@

<<function memchr>>=
void*
memchr(void *ap, int c, ulong n)
{
    uchar *sp;

    sp = ap;
    c &= 0xFF;
    while(n > 0) {
        if(*sp++ == c)
            return sp-1;
        n--;
    }
    return nil;
}
@



\chapter{Memory Management}

%https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/

% http://jamesgolick.com/2013/5/15/memory-allocators-101.html
% http://jamesgolick.com/2013/5/19/how-tcmalloc-works.html

% http://danluu.com/malloc-tutorial/

%http://blog.httrack.com/blog/2014/04/05/a-story-of-realloc-and-laziness/

%http://bitsquid.blogspot.com/2015/08/allocation-adventures-3-buddy-allocator.html

% many more allocators:
% - jmalloc
% - the one from google
% - http://swapped.cc/#!/halloc
% -talloc (in petitboot) from Samba

% mallo.c and pool.c!

\section{Syscall: [[brk()]]}
% sysbrk()

% in 9sys/

<<global bloc>>=
// starting point for the heap, after the text, data, and bss.
static  char    *bloc = { end };
@

<<function sbrk>>=
void*
sbrk(ulong n)
{
    uintptr bl;

    bl = ((uintptr)bloc + Round) & ~Round;
    if(brk((void*)(bl+n)) < 0)
        return (void*)-1;
    bloc = (char*)bl + n;
    return (void*)bl;
}
@

<<enum _anon_ (9sys/sbrk.c)>>=
enum
{
    Round   = 7
};
@


\section{Data structures}

\subsection{[[Pool]]}

<<type Pool>>=
struct Pool {
 char*	name;
 ulong	maxsize;

 ulong	cursize;
 ulong	curfree;
 ulong	curalloc;

 ulong	minarena;	/* smallest size of new arena */
 ulong	quantum;	/* allocated blocks should be multiple of */
 ulong	minblock;	/* smallest newly allocated block */

 void*	freeroot;	/* actually Free* */
 void*	arenalist;	/* actually Arena* */

 void*	(*alloc)(ulong);
 int	    (*merge)(void*, void*);
 void	(*move)(void* from, void* to);

 int	flags;
 int	nfree;
 int	lastcompact;

 void	(*lock)(Pool*);
 void	(*unlock)(Pool*);
 void	(*print)(Pool*, char*, ...);
 void	(*panic)(Pool*, char*, ...);
 void	(*logstack)(Pool*);

 void*	private;
};
@

<<type Pool_flag>>=
enum Pool_flag {	/* flags */
 POOL_ANTAGONISM	= 1<<0,
 POOL_PARANOIA	= 1<<1,
 POOL_VERBOSITY	= 1<<2,
 POOL_DEBUGGING	= 1<<3,
 POOL_LOGGING	= 1<<4,
 POOL_TOLERANCE	= 1<<5,
 POOL_NOREUSE	= 1<<6,
};
@


<<struct Private>>=
struct Private {
    Lock    lk;
    int     pid;
    int     printfd;    /* gets debugging output if set */
};
@

<<global sbrkmempriv>>=
Private sbrkmempriv;
@

\subsection{[[sbrkmem]]}

% in malloc.c
<<global sbrkmem>>=
static Pool sbrkmem = {
    .name=      "sbrkmem",
    .maxsize=   (3840UL-1)*1024*1024,   /* up to ~0xf0000000 */
    .minarena=  4*1024,
    .quantum=   32,
    .alloc=     sbrkalloc,
    .merge=     sbrkmerge,
    .flags=     0,

    .lock=      plock,
    .unlock=        punlock,
    .print=     pprint,
    .panic=     ppanic,
    .private=       &sbrkmempriv,
};
@

<<global mainmem>>=
Pool *mainmem = &sbrkmem;
@

<<global imagmem>>=
Pool *imagmem = &sbrkmem;
@

\subsection{XXX}

% in pool.c

<<struct Bhdr>>=
struct Bhdr {
    ulong   magic;
    ulong   size;
};
@

<<enum _anon_ (port/pool.c)>>=
enum {
    NOT_MAGIC = 0xdeadfa11,
    DEAD_MAGIC = 0xdeaddead,
};
@

<<macro B2NB>>=
#define B2NB(b) ((Bhdr*)((uchar*)(b)+(b)->size))
@

<<macro SHORT>>=
#define SHORT(x) (((x)[0] << 8) | (x)[1])
@

<<macro PSHORT>>=
#define PSHORT(p, x) \
    (((uchar*)(p))[0] = ((x)>>8)&0xFF, \
    ((uchar*)(p))[1] = (x)&0xFF)
@

<<enum _anon_ (port/pool.c)2>>=
enum {
    TAIL_MAGIC0 = 0xBE,
    TAIL_MAGIC1 = 0xEF
};
@

<<struct Btail>>=
struct Btail {
    uchar   magic0;
    uchar   datasize[2];
    uchar   magic1;
    ulong   size;   /* same as Bhdr->size */
};
@

<<macro B2T>>=
#define B2T(b)  ((Btail*)((uchar*)(b)+(b)->size-sizeof(Btail)))
@

<<macro B2PT>>=
#define B2PT(b) ((Btail*)((uchar*)(b)-sizeof(Btail)))
@

<<macro T2HDR>>=
#define T2HDR(t) ((Bhdr*)((uchar*)(t)+sizeof(Btail)-(t)->size))
@

<<struct Free>>=
struct Free {
            Bhdr;
    Free*   left;
    Free*   right;
    Free*   next;
    Free*   prev;
};
@

<<enum _anon_ (port/pool.c)3>>=
enum {
    FREE_MAGIC = 0xBA5EBA11,
};
@

<<struct Alloc>>=
/*
 * the point of the notused fields is to make 8c differentiate
 * between Bhdr and Allocblk, and between Kempt and Unkempt.
 */
struct Alloc {
            Bhdr;
};
@

<<enum _anon_ (port/pool.c)4>>=
enum {
    ALLOC_MAGIC = 0x0A110C09,
    UNALLOC_MAGIC = 0xCAB00D1E+1,
};
@

<<struct Arena>>=
struct Arena {
            Bhdr;
    Arena*  aup;
    Arena*  down;
    ulong   asize;
    ulong   pad;    /* to a multiple of 8 bytes */
};
@

<<enum _anon_ (port/pool.c)5>>=
enum {
    ARENA_MAGIC = 0xC0A1E5CE+1,
    ARENATAIL_MAGIC = 0xEC5E1A0C+1,
};
@

<<macro A2TB>>=
#define A2TB(a) ((Bhdr*)((uchar*)(a)+(a)->asize-sizeof(Bhdr)))
@

<<macro A2B>>=
#define A2B(a)  B2NB(a)
@

<<enum _anon_ (port/pool.c)6>>=
enum {
    ALIGN_MAGIC = 0xA1F1D1C1,
};
@

<<enum _anon_ (port/pool.c)7>>=
enum {
    MINBLOCKSIZE = sizeof(Free)+sizeof(Btail)
};
@

<<global datamagic>>=
static uchar datamagic[] = { 0xFE, 0xF1, 0xF0, 0xFA };
@

<<constant Poison>>=
#define Poison  (void*)0xCafeBabe
@

<<macro _B2D>>=
#define _B2D(a) ((void*)((uchar*)a+sizeof(Bhdr)))
@

<<macro _D2B>>=
#define _D2B(v) ((Alloc*)((uchar*)v-sizeof(Bhdr)))
@


\section{[[malloc()]]}

<<function malloc>>=
void*
malloc(ulong size)
{
    void *v;

    v = poolalloc(mainmem, size+Npadlong*sizeof(ulong));
    if(Npadlong && v != nil) {
        v = (ulong*)v+Npadlong;
        setmalloctag(v, getcallerpc(&size));
        setrealloctag(v, 0);
    }
    return v;
}
@

\section{[[free()]]}

<<function free>>=
void
free(void *v)
{
    if(v != nil)
        poolfree(mainmem, (ulong*)v-Npadlong);
}
@

\section{Debugging support}

\section{Advanced topics}


\chapter{Strings}

%todo: rename strcmp, or at least have
% a string_equal, and most of the time rewrite
% strncmp as !string_equal, far more readable.
% look at go or rust stdlibs

% there is also a libstring/ but seems unused.

%\section{Conversions}
% see Mathematics section and Parsing subsections

\section{Basics}

% copy, search, len, etc.



<<function strlen>>=
long
strlen(char *s)
{

    return strchr(s, 0) - s;
}
@


<<function strcat>>=
char*
strcat(char *s1, char *s2)
{

    strcpy(strchr(s1, 0), s2);
    return s1;
}
@

<<function strchr>>=
char*
strchr(char *s, int c)
{
    char c0 = c;
    char c1;

    if(c == 0) {
        while(*s++)
            ;
        return s-1;
    }

    while(c1 = *s++)
        if(c1 == c0)
            return s-1;
    return 0;
}
@

%todo: rename temporarily to _strcmp and have a string_equal wrapper 
% and refactor code using spatch!

<<function strcmp>>=
int
strcmp(char *s1, char *s2)
{
    unsigned c1, c2;

    for(;;) {
        c1 = *s1++;
        c2 = *s2++;
        if(c1 != c2) {
            if(c1 > c2)
                return 1;
            return -1;
        }
        if(c1 == 0)
            return 0;
    }
}
@


<<constant N>>=
#define N   10000
@

<<function strcpy>>=
char*
strcpy(char *s1, char *s2)
{
    char *os1;

    os1 = s1;
    while(!memccpy(s1, s2, 0, N)) {
        s1 += N;
        s2 += N;
    }
    return os1;
}
@


<<function strdup>>=
char*
strdup(char *s) 
{  
    char *ns;

    ns = malloc(strlen(s) + 1);
    if(ns == 0)
        return 0;
    setmalloctag(ns, getcallerpc(&s));

    return strcpy(ns, s);
}
@



<<function strstr>>=
/*
 * Return pointer to first occurrence of s2 in s1,
 * 0 if none
 */
char*
strstr(char *s1, char *s2)
{
    char *p, *pa, *pb;
    int c0, c;

    c0 = *s2;
    if(c0 == 0)
        return s1;
    s2++;
    for(p=strchr(s1, c0); p; p=strchr(p+1, c0)) {
        pa = p;
        for(pb=s2;; pb++) {
            c = *pb;
            if(c == 0)
                return p;
            if(c != *++pa)
                break;
        }
    }
    return 0;
}
@


\section{Unicode}

%see utf.ps

\section{Formatted Output}

<<type Fmt>>=
struct Fmt {
    uchar   runes;          /* output buffer is runes or chars? */
    void    *start;         /* of buffer */
    void    *to;            /* current place in the buffer */
    void    *stop;          /* end of the buffer; overwritten if flush fails */
    int     (*flush)(Fmt *);    /* called when to == stop */
    void    *farg;          /* to make flush a closure */
    int     nfmt;           /* num chars formatted so far */
    va_list args;           /* args passed to dofmt */
    int     r;          /* % format Rune */
    int     width;
    int     prec;
    ulong   flags;
};
@

<<type Fmt_flag>>=
enum Fmt_flag {
    FmtWidth    = 1,
    FmtLeft     = FmtWidth << 1,
    FmtPrec     = FmtLeft << 1,
    FmtSharp    = FmtPrec << 1,
    FmtSpace    = FmtSharp << 1,
    FmtSign     = FmtSpace << 1,
    FmtZero     = FmtSign << 1,
    FmtUnsigned = FmtZero << 1,
    FmtShort    = FmtUnsigned << 1,
    FmtLong     = FmtShort << 1,
    FmtVLong    = FmtLong << 1,
    FmtComma    = FmtVLong << 1,
    FmtByte     = FmtComma << 1,

    FmtFlag     = FmtByte << 1
};
@

% printf
%https://github.com/wkoszek/mini_printf

\section{Quoted strings}
% adv topics?

\chapter{Regular Expressions}
% libregexp/

\chapter{IO}

% file descriptor type in core DS.

<<type Open_flag>>=
// enum Open_flag, open parameter
#define	OREAD	0	/* open for read */
#define	OWRITE	1	/* write */
#define	ORDWR	2	/* read and write */
#define	OEXEC	3	/* execute, == read but check execute permission */
// advanced stuff
#define	OTRUNC	16	/* or'ed in (except for exec), truncate file first */
#define	OCEXEC	32	/* or'ed in, close on exec */
#define	ORCLOSE	64	/* or'ed in, remove on close */
#define	OEXCL	0x1000	/* or'ed in, exclusive use (create only) */
@
%dead:// #define	OBEHIND	0x2000	/* use write behind for writes [for 9n] */

<<type Access_flag>>=
// enum Access_flag
#define	AEXIST	0	/* accessible: exists */
#define	AEXEC	1	/* execute access */
#define	AWRITE	2	/* write access */
#define	AREAD	4	/* read access */
@

<<type Qid>>=
// Qid as in uniQue id
struct Qid {
 uvlong	path;
 ulong	vers;
    // bitset<Qidtype>
 uchar	type;
};
@


<<type Qid_type>>=
/* bits in Qid.type */
#define QTFILE		0x00		/* plain file */
#define QTDIR		0x80		/* type bit for directories */
// advanced stuff
#define QTAPPEND	0x40		/* type bit for append only files */
#define QTEXCL		0x20		/* type bit for exclusive use files */
#define QTMOUNT		0x10		/* type bit for mounted channel */
#define QTAUTH		0x08		/* type bit for authentication file */
#define QTTMP		0x04		/* type bit for not-backed-up file */
@

<<type Seek_cursor>>=
// pad's stuff (but it is actually also in stdio.h)
enum Seek_cursor {
    SEEK__START = 0,
    SEEK__CUR = 1,
    SEEK__END = 2,
};
@
%pad: I added that

\section{Syscalls: [[open()]], [[read()]], etc}

% sysopen(), sysclose(), sysread(), syswrite(), sysseek(), etc
% file, directory, namespace


<<function read>>=
long
read(int fd, void *buf, long n)
{
    return pread(fd, buf, n, -1LL);
}
@

<<function write>>=
long
write(int fd, void *buf, long n)
{
    return pwrite(fd, buf, n, -1LL);
}
@

\chapter{Directory}

<<type DirEntry>>=
// TODO should be renamed DirEntry really
// a similar structure is defined in the kernel!
struct Dir {
 /* system-modified data */
 ushort	type;	/* server type */
 uint	dev;	/* server subtype */

 /* file data */
 Qid	qid;	/* unique id from server */

 ulong	mode;	/* permissions */
 ulong	atime;	/* last read time */
 ulong	mtime;	/* last write time */
 vlong	length;	/* file length */
 char	*name;	/* last element of path */
 char	*uid;	/* owner name */
 char	*gid;	/* group name */
 char	*muid;	/* last modifier name */
};
@

<<type Dir_mode>>=
/* bits in Dir.mode */
#define DMDIR		0x80000000	/* mode bit for directories */
#define DMREAD		0x4		/* mode bit for read permission */
#define DMWRITE		0x2		/* mode bit for write permission */
#define DMEXEC		0x1		/* mode bit for execute permission */
// advanced stuff
#define DMAPPEND	0x40000000	/* mode bit for append only files */
#define DMEXCL		0x20000000	/* mode bit for exclusive use files */
#define DMMOUNT		0x10000000	/* mode bit for mounted channel */
#define DMAUTH		0x08000000	/* mode bit for authentication file */
#define DMTMP		0x04000000	/* mode bit for non-backed-up files */
@

<<constant DIRMAX>>=
#define	DIRMAX	(sizeof(Dir)+STATMAX)	/* max length of Dir structure */
@

<<constant STATMAX>>=
#define	STATMAX	65535U	/* max length of machine-independent stat structure */
@

\section{Syscalls: [[create()]], [[chdir()]], etc}


<<function getwd>>=
char*
getwd(char *buf, int nbuf)
{
    int n, fd;

    fd = open(".", OREAD);
    if(fd < 0)
        return nil;
    n = fd2path(fd, buf, nbuf);
    close(fd);
    if(n < 0)
        return nil;
    return buf;
}
@

\section{Path manipulation}

\chapter{Namespace}

<<type Namespace_flag>>=
// enum Namespace_flag, mount/bind parameter
#define	MREPL	0x0000	/* mount replaces object */
#define	MBEFORE	0x0001	/* mount goes before others in union directory */
#define	MAFTER	0x0002	/* mount goes after others in union directory */

#define	MCREATE	0x0004	/* permit creation in mounted directory */
#define	MCACHE	0x0010	/* cache some data */
// bitset<Namespace_flag>
#define	MORDER	0x0003	/* mask for bits defining order of mounting */

#define	MMASK	0x0017	/* all bits on */
@

\section{Syscalls: [[bind()]], [[mount()]], etc}

\chapter{Time}

% see TM in core DS


\section{Syscalls: [[sleep()]], [[alarm()]], etc}

\section{Time and day}
% called Time-of-day, not sure  why


\chapter{Concurrency}

<<type Rfork_flag>>=
/* rfork */
enum Rfork_flags
{
 RFNAMEG		= (1<<0),
 RFENVG		= (1<<1),
 RFFDG		= (1<<2),
 RFNOTEG		= (1<<3),
 RFPROC		= (1<<4),
 RFMEM		= (1<<5),
 RFNOWAIT	= (1<<6),
 RFCNAMEG	= (1<<10),
 RFCENVG		= (1<<11),
 RFCFDG		= (1<<12),
 RFREND		= (1<<13),
 RFNOMNT		= (1<<14)
};
@


\section{Syscalls: [[rfork()]], [[await()]], [[rendezvous()]], etc}

% sysfork(), sysexit(), sysawait(), sysexec()
% want to run external command? need fork+exec! classic pattern.

% plan9 has shared memory processes. rfork(RFMEM)
% has then locking function to coordinate. qlock, lock, etc.
% has also a few syscalls like rendezvous!

% see also thread chapter, that build on top of this to
% provide more convenient abstractions (channels, alt(), cooperative
% threads with less needs for locking, etc)

% see lock(2), rendezvous(2)
% sleep/wakeup


<<function fork>>=
int
fork(void)
{
    return rfork(RFPROC|RFFDG|RFREND);
}
@

<<function getpid>>=
int
getpid(void)
{
    char b[20];
    int f;

    memset(b, 0, sizeof(b));
    f = open("#c/pid", 0);
    if(f >= 0) {
        read(f, b, sizeof(b));
        close(f);
    }
    return atol(b);
}
@

<<function getppid>>=
int
getppid(void)
{
    char b[20];
    int f;

    memset(b, 0, sizeof(b));
    f = open("/dev/ppid", 0);
    if(f >= 0) {
        read(f, b, sizeof(b));
        close(f);
    }
    return atol(b);
}
@

\section{Locks}

<<type Lock>>=
struct Lock {
    long    key;
    long    sem;
};
@

<<function lock>>=
void
lock(Lock *l)
{
    if(ainc(&l->key) == 1)
        return; /* changed from 0 -> 1: we hold lock */
    /* otherwise wait in kernel */
    while(semacquire(&l->sem, 1) < 0){
        /* interrupted; try again */
    }
}
@

<<function unlock>>=
void
unlock(Lock *l)
{
    if(adec(&l->key) == 0)
        return; /* changed from 1 -> 0: no contention */
    semrelease(&l->sem, 1);
}
@

<<function canlock>>=
int
canlock(Lock *l)
{
    if(ainc(&l->key) == 1)
        return 1;   /* changed from 0 -> 1: success */
    /* Undo increment (but don't miss wakeup) */
    if(adec(&l->key) == 0)
        return 0;   /* changed from 1 -> 0: no contention */
    semrelease(&l->sem, 1);
    return 0;
}
@


\section{Queues}

<<type QLock>>=
struct QLock {
    Lock    lock;
    int locked;
    QLp *head;
    QLp     *tail;
};
@

<<type QLp>>=
struct QLp {
    int inuse;
    QLp *next;
    char    state;
};
@

\section{Read-write locks}

<<type RWLock>>=
struct RWLock {
    Lock    lock;
    int readers;    /* number of readers */
    int writer;     /* number of writers */
    QLp *head;      /* list of waiting processes */
    QLp *tail;
};
@

\section{Rendez-vous}

<<type Rendez>>=
struct Rendez {
    QLock   *l;
    QLp *head;
    QLp *tail;
};
@

\section{Coroutines}

<<type jmp_buf>>=
typedef long    jmp_buf[2];
@

<<type jmpbufxxx>>=
#define JMPBUFSP    0
#define JMPBUFPC    1
#define JMPBUFDPC   0
@

\chapter{IPC}
% 9P and RPC? fcall.h


\section{Syscalls: [[pipe()]], [[notify()]], [[segattach()]]}

\section{Parent-child IPC}
% can pass from parent to child via env, 
% and from child to parent via wait message

\subsection{Wait message}

<<type Waitmsg>>=
/* keep /sys/src/ape/lib/ap/plan9/sys9.h in sync with this -rsc */
struct Waitmsg {
 int	pid;		/* of loved one */
 ulong	time[3];	/* of loved one & descendants */
 char	*msg;
};
@

% in 9sys/
<<function wait>>=
Waitmsg*
wait(void)
{
    int n, l;
    char buf[512], *fld[5];
    Waitmsg *w;

    n = await(buf, sizeof buf-1);
    if(n < 0)
        return nil;
    buf[n] = '\0';
    if(tokenize(buf, fld, nelem(fld)) != nelem(fld)){
        werrstr("couldn't parse wait message");
        return nil;
    }
    l = strlen(fld[4])+1;
    w = malloc(sizeof(Waitmsg)+l);
    if(w == nil)
        return nil;
    w->pid = atoi(fld[0]);
    w->time[0] = atoi(fld[1]);
    w->time[1] = atoi(fld[2]);
    w->time[2] = atoi(fld[3]);
    w->msg = (char*)&w[1];
    memmove(w->msg, fld[4], l);
    return w;
}
@

<<function waitpid>>=
int
waitpid(void)
{
    int n;
    char buf[512], *fld[5];

    n = await(buf, sizeof buf-1);
    if(n <= 0)
        return -1;
    buf[n] = '\0';
    if(tokenize(buf, fld, nelem(fld)) != nelem(fld)){
        werrstr("couldn't parse wait message");
        return -1;
    }
    return atoi(fld[0]);
}
@


\subsection{Environment}

<<function getenv>>=
char*
getenv(char *name)
{
    int r, f;
    long s;
    char *ans;
    char *p, *ep, ename[100];

    if(strchr(name, '/') != nil)
        return nil;
    snprint(ename, sizeof ename, "/env/%s", name);
    if(strcmp(ename+5, name) != 0)
        return nil;
    f = open(ename, OREAD);
    if(f < 0)
        return 0;
    s = seek(f, 0, 2);
    ans = malloc(s+1);
    if(ans) {
        setmalloctag(ans, getcallerpc(&name));
        seek(f, 0, 0);
        r = read(f, ans, s);
        if(r >= 0) {
            ep = ans + s - 1;
            for(p = ans; p < ep; p++)
                if(*p == '\0')
                    *p = ' ';
            ans[s] = '\0';
        }
    }
    close(f);
    return ans;
}
@

<<function putenv>>=
int
putenv(char *name, char *val)
{
    int f;
    char ename[100];
    long s;

    if(strchr(name, '/') != nil)
        return -1;
    snprint(ename, sizeof ename, "/env/%s", name);
    if(strcmp(ename+5, name) != 0)
        return -1;
    f = create(ename, OWRITE, 0664);
    if(f < 0)
        return -1;
    s = strlen(val);
    if(write(f, val, s) != s){
        close(f);
        return -1;
    }
    close(f);
    return 0;
}
@


\section{Notes}

<<type Note_flag>>=
#define	NCONT	0	/* continue after note */
#define	NDFLT	1	/* terminate after note */
#define	NSAVE	2	/* clear note but hold state */
#define	NRSTR	3	/* restore saved state */
@

<<function postnote>>=
int
postnote(int group, int pid, char *note)
{
    char file[128];
    int f, r;

    switch(group) {
    case PNPROC:
        sprint(file, "/proc/%d/note", pid);
        break;
    case PNGROUP:
        sprint(file, "/proc/%d/notepg", pid);
        break;
    default:
        return -1;
    }

    f = open(file, OWRITE);
    if(f < 0)
        return -1;

    r = strlen(note);
    if(write(f, note, r) != r) {
        close(f);
        return -1;
    }
    close(f);
    return 0;
}
@


\section{Pipes}

\section{Shared segments}

<<type Segattach_flag>>=
/* Segattch */
#define	SG_RONLY	0040	/* read only */
#define	SG_CEXEC	0100	/* detach on exec */
@

\chapter{Channels and Cooperative Threads}

\section{Overview}

% thread OS vs thread lib OS! already have "threads" rfork with shared memory!
% see http://swtch.com/~rsc/thread/
% plan9 libthread model is based on Alef. Procs in terminology
% below are actually shared
% memory processes, and threads cooperatively scheduled coroutines.
% different than what most people agrees about threads/

% Why need that? why system threads not enough? not convenient enough?
% green threads vs system threads, a classic.
% Having cooperative threads simplify lots of things, no race, less
% need for locks! Other reasons? (xleroy did the same)

% alternatives? posix threads? xleroy thread lib? new thread linux lib?
% other forms of concurrency? erlang model? see 7 concurrency in 7 weeks?

% see thread(2), definitive reference. maybe see alef article
% for design discussions. See acme and rio articles/slides for
% examples of use and discussions too.
% see ioproc(2), and lock(2)
% see rendezvous(2)

\subsection{Code organization}

%include/thread.h: public API
%threadimpl.h: private DS

%ref.c: atomic counter (could be in libc.h)
%xincarm.c
%xincport.h

%globals.c: globals
%debug.c: debugging support (threadebug(), threadassert())

%lib.c: threadmalloc wrapper, threadsysfatal()
%386.c: thread stack initialization arch specific managment

%create.c: create/free process/threads
%id.c: thread identification
%sched.c: the thread scheduler

%note.c: thread-aware notes
%exit.c: thread-aware exits
%exec.c: thread-aware exec

%rendez.c: rendez vous API for the threads
%kill.c: thread killing each other
%channel.c:

%chanprint.c

%ioproc.c: IO proc creation/deletion and handler (xioproc)
%iocall.c: the io proc helper bridge for all the syscalls below

%ioxxx.c: 
% (ioopen.c, %ioclose.c, %ioread.c, %iowrite.c, %ioreadn.c, %iosleep.c)

%dial.c: thread friendly version of network dial
%iodial.c


%main.c: !!!

\subsection{Software architecture}

% _xxx = private

% rely on shared memory and futex for synchro.
% ainc, adec. (atomic inc, atomic dec)

% channels are structured in shared memory between processes and
% threads. Used concurrently.

\section{A toy example}

% lib_thread/tests/!! example.c! include early

\section{Core data structures}

\subsection{Concurrency buiding blocks}

<<struct Ref>>=
struct Ref {
    long	ref;
};
@

<<function incref>>=
void
incref(Ref *r)
{
    ainc(&r->ref);
}
@

<<function decref>>=
long
decref(Ref *r)
{
    return adec(&r->ref);
}
@


<<global xincport_lock>>=
static Lock xincport_lock;
@
% port for portable?

<<function _xinc>>=
void
_xinc(long *p)
{

    lock(&xincport_lock);
    (*p)++;
    unlock(&xincport_lock);
}
@
% who calls _xinc?? ainc?

<<function _xdec>>=
long
_xdec(long *p)
{
    long r;

    lock(&xincport_lock);
    r = --(*p);
    unlock(&xincport_lock);
    return r;
}
@


% see Lock, QLock, Rendez!! 
% see also lock(); unlock() functions in libc.h

% can produce producer/consumer synchronization queue
% with lock and rendezvous (kind of condition variables)

\subsection{[[Channel]]}
% public API!

%A Channel is a buffered or unbuffered queue for fixed size messages
% Procs and threads send messages into the channel and recv messages 
% from the channel

% so really a form of generalized producer/consumer queue!
% an effective and general concurrency mechanism

<<struct Channel>>=
/*
 * Channel structure.  s is the size of the buffer.  For unbuffered channels
 * s is zero.  v is an array of s values.  If s is zero, v is unused.
 * f and n represent the state of the queue pointed to by v.
 */
struct Channel {
    int	s;		/* Size of the channel (may be zero) */

    uint	f;		/* Extraction point (insertion pt: (f+n) % s) */
    uint	n;		/* Number of values in the channel */
    int	e;		/* Element size */
    int	freed;		/* Set when channel is being deleted */

    volatile Alt **qentry;	/* Receivers/senders waiting (malloc) */
    volatile int nentry;	/* # of entries malloc-ed */
    volatile int closed;	/* channel is closed */

    // must be at the end of the struct! 
    byte	v[1];		/* Array of s values in the channel */
};
@
% no Lock?
% volatile?

<<global chanlock>>=
static Lock chanlock;		/* central channel access lock */
@


<<function chancreate>>=
Channel*
chancreate(int elemsize, int elemcnt)
{
    Channel *c;

    if(elemcnt < 0 || elemsize <= 0)
        return nil;
    c = _threadmalloc(sizeof(Channel) + elemsize*elemcnt, 1);
    c->e = elemsize;
    c->s = elemcnt;
    _threaddebug(DBGCHAN, "chancreate %p", c);
    return c;
}
@
% _threadmalloc ?

% have to be called by user? could do that in chancreate no?
<<function chaninit>>=
int
chaninit(Channel *c, int elemsize, int elemcnt)
{
    if(elemcnt < 0 || elemsize <= 0 || c == nil)
        return -1;
    c->f = 0;
    c->n = 0;
    c->closed = 0;
    c->freed = 0;
    c->e = elemsize;
    c->s = elemcnt;
    _threaddebug(DBGCHAN, "chaninit %p", c);
    return 1;
}
@


<<function chanfree>>=
void
chanfree(Channel *c)
{
    lock(&chanlock);
    _chanfree(c);
    unlock(&chanlock);
}
@


<<function _chanfree>>=
static void
_chanfree(Channel *c)
{
    int i, inuse;

    if(c->closed == 1)			/* chanclose is ongoing */
        inuse = 1;
    else{
        inuse = 0;
        for(i = 0; i < c->nentry; i++)	/* alt ongoing */
            if(c->qentry[i])
                inuse = 1;
    }
    if(inuse)
        c->freed = 1;
    else{
        if(c->qentry)
            free(c->qentry);
        free(c);
    }
}
@




<<enum _anon_ (lib_core/libthread/channel.c)>>=
/* Value to indicate the channel is closed */
enum {
    CHANCLOSD = 0xc105ed,
};
@
<<constant Closed>>=
#define Closed	((void*)CHANCLOSD)
@






% public API
<<function chanclose>>=
int
chanclose(Channel *c)
{
    Alt *a;
    int i, s;

    s = _procsplhi();	/* note handlers; see :/^alt */
    lock(&chanlock);
    if(c->closed){
        /* Already close; we fail but it's ok. don't print */
        unlock(&chanlock);
        _procsplx(s);
        return -1;
    }
    c->closed = 1;		/* Being closed */
    /*
     * Locate entries that will fail due to close
     * (send, and receive if nothing buffered) and wake them up.
     * the situation cannot change because all queries
     * should be committed by now and new ones will find the channel
     * closed.  We still need to take the lock during the iteration
     * because we can wake threads on qentrys we have not seen yet
     * as in alt and there would be a race in the access to *a.
     */
    for(i = 0; i < c->nentry; i++){
        if((a = c->qentry[i]) == nil || *a->tag != nil)
            continue;

        if(a->op != CHANSND && (a->op != CHANRCV || c->n != 0))
            continue;
        *a->tag = c;
        unlock(&chanlock);
        _procsplx(s);
        while(_threadrendezvous(a->tag, Closed) == Intred)
            ;
        s = _procsplhi();
        lock(&chanlock);
    }

    c->closed = 2;		/* Fully closed */
    if(c->freed)
        _chanfree(c);
    unlock(&chanlock);
    _procsplx(s);
    return 0;
}
@

<<function chanclosing>>=
int
chanclosing(Channel *c)
{
    int n, s;

    s = _procsplhi();	/* note handlers; see :/^alt */
    lock(&chanlock);
    if(c->closed == 0)
        n = -1;
    else
        n = c->n;
    unlock(&chanlock);
    _procsplx(s);
    return n;
}
@

%/*
% * superseded by chanclosing
%int
%chanisclosed(Channel *c)
%{
%    return chanisclosing(c) >= 0;
%}
% */





\subsection{[[Proc]] and [[Pqueue]]}

% cooperative scheduler building blocks = coroutines = setjmp()!
% (actually the kernel does the same)

<<struct Proc>>=
struct Proc
{
    int		pid;			/* process id */

    jmp_buf	sched;			/* for context switches */

    Thread	*thread;		/* running thread */




    bool		splhi;			/* delay notes */

    int		needexec;
    Execargs	exec;			/* exec argument */
    Proc	*newproc;		/* fork argument */
    char	exitstr[ERRMAX];	/* exit status */

    int		rforkflag;

    Tqueue	threads;		/* All threads of this proc */
    int		nthreads;

    Tqueue	ready;			/* Runnable threads */
    Lock	readylock;

    char	printbuf[Printsize];
    int		blocked;		/* In a rendezvous */
    int		pending;		/* delayed note pending */
    int		nonotes;		/* delay notes */
    uint	nextID;			/* ID of most recently created thread */


    void	*arg;			/* passed between shared and unshared stk */
    char	str[ERRMAX];		/* used by threadexits to avoid malloc */

    void*	wdata;			/* Lib(worker) per-proc data pointer */
    void*	udata;			/* User per-proc data pointer */
    char	threadint;		/* tag for threadexitsall() */

    // Extra
    Proc	*next;			/* linked list of Procs */

    Lock	lock;
};
@

% jmp_buf is in u.h and is just long[2] (sp, pc) for x86

<<constant Printsize>>=
Printsize = 2048,
@


% shared memory, but need also per process private memory.
% how? stack? each process has its own stack normally.


<<global procp>>=
// used to be in main.c
static Proc **procp;
@
% set in threadsysinit(), privalloc()

<<function _threadgetproc>>=
Proc*
_threadgetproc(void)
{
    return *procp;
}
@

<<function _threadsetproc>>=
void
_threadsetproc(Proc *p)
{
    *procp = p;
}
@





% all processes, all threads?
<<global _threadpq>>=
// used to be in create.c
Pqueue _threadpq;
@
% it's not a pointer! so it should be set to nil by default

<<struct Pqueue>>=
struct Pqueue {		/* Proc queue */
    Proc		*head;
    Proc		**tail;

    // Extra
    Lock		lock;
};
@


<<function proccreate>>=
int
proccreate(void (*f)(void*), void *arg, uint stacksize)
{
    return procrfork(f, arg, stacksize, 0);
}
@

<<function procrfork>>=
int
procrfork(void (*f)(void *), void *arg, uint stacksize, int rforkflag)
{
    Proc *p;
    int id;

    p = _threadgetproc();
    assert(p->newproc == nil);
    p->newproc = _newproc(f, arg, stacksize, nil, p->thread->grp, rforkflag);
    id = p->newproc->threads.head->id;
    _sched();
    return id;
}
@



<<function _newproc>>=
/*
 * Create and initialize a new Proc structure with a single Thread
 * running inside it.  Add the Proc to the global process list.
 */
Proc*
_newproc(void (*f)(void *arg), void *arg, uint stacksize, char *name, int grp, int rforkflag)
{
    Proc *p;

    p = _threadmalloc(sizeof *p, 1);
    p->pid = -1;
    p->rforkflag = rforkflag;
    newthread(p, f, arg, stacksize, name, grp);

    lock(&_threadpq.lock);
    if(_threadpq.head == nil)
        _threadpq.head = p;
    else
        *_threadpq.tail = p;
    _threadpq.tail = &p->next;
    unlock(&_threadpq.lock);

    return p;
}
@





<<function _freeproc>>=
void
_freeproc(Proc *p)
{
    Thread *t, *nextt;

    for(t = p->threads.head; t; t = nextt){
        if(t->cmdname)
            free(t->cmdname);
        assert(t->stk != nil);
        free(t->stk);
        nextt = t->nextt;
        free(t);
    }
    free(p);
}
@


<<struct Execargs>>=
struct Execargs
{
    char	*prog;
    char	**args;
    int		fd[2];
};
@



\subsection{[[Thread]] and [[Tqueue]]}
% private DS, threadimpl.h


<<struct Thread>>=
struct Thread
{
    int		id;		/* thread id */
    char	*cmdname;	/* ptr to name of thread */

    jmp_buf	sched;		/* for context switches */

    Proc	*proc;		/* proc of this thread */

    uint	stksize;	/* stack size */
    uchar	*stk;		/* top of stack (lowest address of stack) */

    State	state;		/* run state */
    State	nextstate;	/* next run state */

    Chanstate	chan;		/* which channel operation is current */
    Alt		*alt;		/* pointer to current alt structure (debugging) */



    int 	grp;		/* thread group */
    int		moribund;	/* thread needs to die */

    int		ret;		/* return value for Exec, Fork */


    int		inrendez;
    Thread	*rendhash;	/* Trgrp linked list */
    void*	rendtag;	/* rendezvous tag */
    void*	rendval;	/* rendezvous value */
    int		rendbreak;	/* rendezvous has been taken */


    void*	udata[NPRIV];	/* User per-thread data pointer */

    // Extra
    Lock	lock;		/* protects thread data structure */

    Thread	*next;		/* next on ready queue */

    Thread	*nextt;		/* next on list of threads in this proc*/


};
@

% advanced topic?
<<constant NPRIV>>=
NPRIV = 8,
@






<<function threadid>>=
int
threadid(void)
{
    return _threadgetproc()->thread->id;
}
@

% newthread() -> <>
<<function nextID>>=
static int
nextID(void)
{
    static Lock l;
    static int id;
    int i;

    lock(&l);
    i = ++id;
    unlock(&l);
    return i;
}
@


<<function threadcreate>>=
/* 
 * Create a new thread and schedule it to run.
 * The thread grp is inherited from the currently running thread.
 */
int
threadcreate(void (*f)(void *arg), void *arg, uint stacksize)
{
    return newthread(_threadgetproc(), f, arg, stacksize, nil, threadgetgrp());
}
@


% ctor
<<function newthread>>=
/*
 * Create and initialize a new Thread structure attached to a given proc.
 */
static int
newthread(Proc *p, void (*f)(void *arg), void *arg, uint stacksize, char *name, int grp)
{
    int id;
    Thread *t;

    if(stacksize < 32)
        sysfatal("bad stacksize %d", stacksize);
    t = _threadmalloc(sizeof(Thread), 1);

    t->stksize = stacksize;
    t->stk = _threadmalloc(stacksize, 0);
    memset(t->stk, 0xFE, stacksize);
    _threadinitstack(t, f, arg);

    t->grp = grp;
    if(name)
        t->cmdname = strdup(name);
    t->id = nextID();
    id = t->id;
    t->next = (Thread*)~0;
    t->proc = p;
    _threaddebug(DBGSCHED, "create thread %d.%d name %s", p->pid, t->id, name);

    lock(&p->lock);
    p->nthreads++;
    if(p->threads.head == nil)
        p->threads.head = t;
    else
        *p->threads.tail = t;
    p->threads.tail = &t->nextt;

    t->nextt = nil;
    t->state = Ready;
    _threadready(t);
    unlock(&p->lock);

    return id;
}
@

% 386.c
<<function launcher386>>=
static void
launcher386(void (*f)(void *arg), void *arg)
{
    (*f)(arg);
    threadexits(nil);
}
@

% 386.c
<<function _threadinitstack>>=
void
_threadinitstack(Thread *t, void (*f)(void*), void *arg)
{
    ulong *tos;

    tos = (ulong*)&t->stk[t->stksize&~7];
    *--tos = (ulong)arg;
    *--tos = (ulong)f;
    t->sched[JMPBUFPC] = (ulong)launcher386+JMPBUFDPC;
    t->sched[JMPBUFSP] = (ulong)tos - 8;		/* old PC and new PC */
}
@





<<function _freethread>>=
void
_freethread(Thread *t)
{
    Proc *p;
    Thread **l;

    p = t->proc;
    lock(&p->lock);
    for(l=&p->threads.head; *l; l=&(*l)->nextt){
        if(*l == t){
            *l = t->nextt;
            if(*l == nil)
                p->threads.tail = l;
            break;
        }
    }
    unlock(&p->lock);
    if (t->cmdname)
        free(t->cmdname);
    assert(t->stk != nil);
    free(t->stk);
    free(t);
}
@




<<function threadpid>>=
int
threadpid(int id)
{
    int pid;
    Proc *p;
    Thread *t;

    if (id < 0)
        return -1;
    if (id == 0)
        return _threadgetproc()->pid;
    lock(&_threadpq.lock);
    for (p = _threadpq.head; p; p = p->next){
        lock(&p->lock);
        for (t = p->threads.head; t; t = t->nextt)
            if (t->id == id){
                pid = p->pid;
                unlock(&p->lock);
                unlock(&_threadpq.lock);
                return pid;
            }
        unlock(&p->lock);
    }
    unlock(&_threadpq.lock);
    return -1;
}
@



<<struct Tqueue>>=
struct Tqueue		/* Thread queue */
{
    Thread	*head;
    Thread	**tail;

    int		asleep;
};
@




<<enum state>>=
enum state
{
    Dead,
    Running,
    Ready,
    Rendezvous,
};
@
% hmm does not much psstate string array, normal??

<<enum chanstate>>=
enum chanstate
{
    Channone,

    Chansend,
    Chanrecv,

    Chanalt,
};
@



<<function threadsetname>>=
void
threadsetname(char *fmt, ...)
{
    int fd;
    char buf[128];
    va_list arg;
    Proc *p;
    Thread *t;

    p = _threadgetproc();
    t = p->thread;
    if (t->cmdname)
        free(t->cmdname);
    va_start(arg, fmt);
    t->cmdname = vsmprint(fmt, arg);
    va_end(arg);
    if(t->cmdname && p->nthreads == 1){
        snprint(buf, sizeof buf, "#p/%lud/args", _tos->pid); //getpid());
        if((fd = open(buf, OWRITE)) >= 0){
            write(fd, t->cmdname, strlen(t->cmdname)+1);
            close(fd);
        }
    }
}
@

<<function threadgetname>>=
char*
threadgetname(void)
{
    Proc *p;

    if((p = _threadgetproc()) && p->thread)
        return p->thread->cmdname;
    return nil;
}
@


\subsection{[[Alt]]}

% "Plan9 has no select call"

% But in libdraw/event.c they use an event pipe; a pipe between
% a master and a set of slaves, and master can listen to multiple
% slaves at the same time and get the next event from those slaves.
% Here is alternative model to event, threads and channels and alt().

<<enum chanop>>=
/* Channel operations for alt: */
enum chanop {
    CHANEND,

    CHANSND,
    CHANRCV,
    CHANNOP,

    CHANNOBLK,
};
@

<<struct Alt>>=
struct Alt {
    Channel	*c;		/* channel */
    void	*v;		/* pointer to value */
    ChanOp	op;		/* operation */

    char	*err;		/* did the op fail? */
    /*
     * the next variables are used internally to alt
     * they need not be initialized
     */
    Channel	**tag;		/* pointer to rendez-vous tag */
    int	entryno;	/* entry number */
};
@


\section{[[main()]]}
% and threadmain()

<<global mainp>>=
// ref<ref<Proc>
static Proc **mainp;
@
% address of ref of proc in stack

<<global _mainjmp>>=
static jmp_buf _mainjmp;
@

<<global mainstacksize>>=
int	mainstacksize;
@


<<function main>>=
void
main(int argc, char **argv)
{
    Mainarg *a;
    Proc *p;

    rfork(RFREND);
    mainp = &p;

    if(setjmp(_mainjmp))
        _schedinit(p);

    //_threaddebuglevel = (DBGSCHED|DBGCHAN|DBGREND)^~0;
    _systhreadinit();
    _qlockinit(_threadrendezvous);

    _sysfatal = _threadsysfatal;
    _dial     = _threaddial;
    __assert  = _threadassert;

    notify(_threadnote);

    if(mainstacksize == 0)
        mainstacksize = 8*1024;

    a = _threadmalloc(sizeof *a, 1);
    a->argc = argc;
    a->argv = argv;

    p = _newproc(mainlauncher, a, mainstacksize, "threadmain", 0, 0);
    _schedinit(p);

    abort();	/* not reached */
}
@


<<function _systhreadinit>>=
void
_systhreadinit(void)
{
    procp = privalloc();
}
@

<<struct Mainarg>>=
struct Mainarg
{
    int		argc;
    char	**argv;
};
@

<<function mainlauncher>>=
static void
mainlauncher(void *arg)
{
    Mainarg *a;

    a = arg;

    // user defined threadmain()!!
    threadmain(a->argc, a->argv);

    threadexits("threadmain");
}
@



\section{Threads scheduler}
% similar to Kernel Scheduling chapter

<<global _psstate>>=
static char *_psstate[] = {
    "Moribund",
    "Dead",
    "Exec",
    "Fork",
    "Running",
    "Ready",
    "Rendezvous",
};
@
% superset of enum state, normal?

<<function psstate>>=
static char*
psstate(int s)
{
    if(s < 0 || s >= nelem(_psstate))
        return "unknown";
    return _psstate[s];
}
@


<<function _schedinit>>=
void
_schedinit(void *arg)
{
    Proc *p;
    Thread *t, **l;

    p = arg;
    _threadsetproc(p);
    p->pid = _tos->pid; //getpid();

    while(setjmp(p->sched))
        ;

    _threaddebug(DBGSCHED, "top of schedinit, _threadexitsallstatus=%p", 
                 _threadexitsallstatus);
    if(_threadexitsallstatus)
        exits(_threadexitsallstatus);

    lock(&p->lock);
    t = p->thread;
    if(t != nil){
        p->thread = nil;

        if(t->moribund){
            t->state = Dead;
            for(l=&p->threads.head; *l; l=&(*l)->nextt)
                if(*l == t){
                    *l = t->nextt;
                    if(*l==nil)
                        p->threads.tail = l;
                    p->nthreads--;
                    break;
                }
            unlock(&p->lock);
            if(t->inrendez){
                _threadflagrendez(t);
                _threadbreakrendez();
            }
            free(t->stk);
            free(t->cmdname);
            free(t);	/* XXX how do we know there are no references? */
            t = nil;
            _sched();
        }
        if(p->needexec){
            t->ret = _schedexec(&p->exec);
            p->needexec = 0;
        }
        if(p->newproc){
            t->ret = _schedfork(p->newproc);
            p->newproc = nil;
        }
        t->state = t->nextstate;
        if(t->state == Ready)
            _threadready(t);
    }
    unlock(&p->lock);
    _sched();
}
@

% _sched() -> <>
<<function needstack>>=
void
needstack(int n)
{
    int x;
    Proc *p;
    Thread *t;
    
    p = _threadgetproc();
    t = p->thread;
    
    if((uchar*)&x - n < (uchar*)t->stk){
        fprint(2, "%s %lud: &x=%p n=%d t->stk=%p\n",
            argv0, _tos->pid, &x, n, t->stk);
        fprint(2, "%s %lud: stack overflow\n", argv0, _tos->pid);
        abort();
    }
}
@

<<function _sched>>=
void
_sched(void)
{
    Proc *p;
    Thread *t;

Resched:
    p = _threadgetproc();
    t = p->thread;
    if(t != nil){
        needstack(128);
        _threaddebug(DBGSCHED, "pausing, state=%s", psstate(t->state));
        if(setjmp(t->sched)==0)
            longjmp(p->sched, 1);
        return;
    }else{
        t = runthread(p);
        if(t == nil){
            _threaddebug(DBGSCHED, "all threads gone; exiting");
            _schedexit(p);
        }
        _threaddebug(DBGSCHED, "running %d.%d", t->proc->pid, t->id);
        p->thread = t;
        if(t->moribund){
            _threaddebug(DBGSCHED, "%d.%d marked to die");
            goto Resched;
        }
        t->state = Running;
        t->nextstate = Ready;
        longjmp(t->sched, 1);
    }
}
@

<<function runthread>>=
static Thread*
runthread(Proc *p)
{
    Thread *t;
    Tqueue *q;

    if(p->nthreads==0)
        return nil;
    q = &p->ready;
    lock(&p->readylock);
    if(q->head == nil){
        q->asleep = 1;
        _threaddebug(DBGSCHED, "sleeping for more work");
        unlock(&p->readylock);
        while(rendezvous(q, 0) == (void*)~0){
            if(_threadexitsallstatus)
                exits(_threadexitsallstatus);
        }
        /* lock picked up from _threadready */
    }
    t = q->head;
    q->head = t->next;
    unlock(&p->readylock);
    return t;
}
@

<<function _threadready>>=
void
_threadready(Thread *t)
{
    Tqueue *q;

    assert(t->state == Ready);
    _threaddebug(DBGSCHED, "readying %d.%d", t->proc->pid, t->id);

    q = &t->proc->ready;
    lock(&t->proc->readylock);
    t->next = nil;
    if(q->head==nil)
        q->head = t;
    else
        *q->tail = t;
    q->tail = &t->next;
    if(q->asleep){
        q->asleep = 0;
        /* lock passes to runthread */
        _threaddebug(DBGSCHED, "waking process %d", t->proc->pid);
        while(rendezvous(q, 0) == (void*)~0){
            if(_threadexitsallstatus)
                exits(_threadexitsallstatus);
        }
    }else
        unlock(&t->proc->readylock);
}
@

<<function yield>>=
void
yield(void)
{
    _sched();
}
@


<<function _schedexit>>=
void
_schedexit(Proc *p)
{
    char ex[ERRMAX];
    Proc **l;

    lock(&_threadpq.lock);
    for(l=&_threadpq.head; *l; l=&(*l)->next){
        if(*l == p){
            *l = p->next;
            if(*l == nil)
                _threadpq.tail = l;
            break;
        }
    }
    unlock(&_threadpq.lock);

    utfecpy(ex, ex+sizeof ex, p->exitstr);
    free(p);
    _exits(ex);
}
@



\section{[[alt()]]}

% send()/recv() use alt(), so better see alt() first.

% !!!
<<function alt>>=
int
alt(Alt *alts)
{
    Alt *a, *xa, *ca;
    Channel volatile *c;
    int n, s, waiting, allreadycl;
    void* r;
    Thread *t;

    /*
     * The point of going splhi here is that note handlers
     * might reasonably want to use channel operations,
     * but that will hang if the note comes while we hold the
     * chanlock.  Instead, we delay the note until we've dropped
     * the lock.
     */
    t = _threadgetproc()->thread;
    if(t->moribund || _threadexitsallstatus)
        yield();	/* won't return */
    s = _procsplhi();

    lock(&chanlock);
    t->alt = alts;
    t->chan = Chanalt;

    /* test whether any channels can proceed */
    n = 0;
    a = nil;

    for(xa=alts; xa->op!=CHANEND && xa->op!=CHANNOBLK; xa++){
        xa->entryno = -1;
        if(xa->op == CHANNOP)
            continue;

        c = xa->c;
        if(c==nil){
            unlock(&chanlock);
            _procsplx(s);
            t->chan = Channone;
            return -1;
        }

        if(isopenfor(c, xa->op) && canexec(xa))
            if(nrand(++n) == 0)
                a = xa;
    }


    if(a==nil){
        /* nothing can proceed */
        if(xa->op == CHANNOBLK){
            unlock(&chanlock);
            _procsplx(s);
            t->chan = Channone;
            if(xa->op == CHANNOBLK)
                return xa - alts;
        }

        /* enqueue on all channels open for us. */
        c = nil;
        ca = nil;
        waiting = 0;
        allreadycl = 0;
        for(xa=alts; xa->op!=CHANEND; xa++)
            if(xa->op==CHANNOP)
                continue;
            else if(isopenfor(xa->c, xa->op)){
                waiting = 1;
                enqueue(xa, &c);
            } else if(xa->err != errcl)
                ca = xa;
            else
                allreadycl = 1;

        if(waiting == 0)
            if(ca != nil){
                /* everything was closed, select last channel */
                ca->err = errcl;
                unlock(&chanlock);
                _procsplx(s);
                t->chan = Channone;
                return ca - alts;
            } else if(allreadycl){
                /* everything was already closed */
                unlock(&chanlock);
                _procsplx(s);
                t->chan = Channone;
                return -1;
            }
        /*
         * wait for successful rendezvous.
         * we can't just give up if the rendezvous
         * is interrupted -- someone else might come
         * along and try to rendezvous with us, so
         * we need to be here.
         * if the channel was closed, the op is done
         * and we flag an error for the entry.
         */
        Again:
        unlock(&chanlock);
        _procsplx(s);
        r = _threadrendezvous(&c, 0);
        s = _procsplhi();
        lock(&chanlock);

        if(r==Intred){		/* interrupted */
            if(c!=nil)	/* someone will meet us; go back */
                goto Again;
            c = (Channel*)~0;	/* so no one tries to meet us */
        }

        /* dequeue from channels, find selected one */
        a = nil;
        for(xa=alts; xa->op!=CHANEND; xa++){
            if(xa->op==CHANNOP)
                continue;
            if(xa->c == c){
                a = xa;
                a->err = nil;
                if(r == Closed)
                    a->err = errcl;
            }
            dequeue(xa);
        }
        unlock(&chanlock);
        _procsplx(s);
        if(a == nil){	/* we were interrupted */
            assert(c==(Channel*)~0);
            return -1;
        }
    }else
        altexec(a, s);	/* unlocks chanlock, does splx */
    _sched();
    t->chan = Channone;
    return a - alts;
}
@

<<function isopenfor>>=
static bool
isopenfor(Channel *c, int op)
{
    return c->closed == 0 || (op == CHANRCV && c->n > 0);
}
@


<<function canexec>>=
static int
canexec(Alt *a)
{
    int i, otherop;
    Channel *c;

    c = a->c;
    /* are there senders or receivers blocked? */
    otherop = (CHANSND+CHANRCV) - a->op;
    for(i=0; i<c->nentry; i++)
        if(c->qentry[i] && c->qentry[i]->op==otherop && *c->qentry[i]->tag==nil){
            _threaddebug(DBGCHAN, "can rendez alt %p chan %p", a, c);
            return 1;
        }

    /* is there room in the channel? */
    if((a->op==CHANSND && c->n < c->s)
    || (a->op==CHANRCV && c->n > 0)){
        _threaddebug(DBGCHAN, "can buffer alt %p chan %p", a, c);
        return 1;
    }

    return 0;
}
@








<<global errcl>>=
static char errcl[] = "channel was closed";
@


<<function enqueue>>=
static void
enqueue(Alt *a, Channel **c)
{
    int i;

    _threaddebug(DBGCHAN, "Queuing alt %p on channel %p", a, a->c);
    a->tag = c;
    i = emptyentry(a->c);
    a->c->qentry[i] = a;
}
@


<<function dequeue>>=
static void
dequeue(Alt *a)
{
    int i;
    Channel *c;

    c = a->c;
    for(i=0; i<c->nentry; i++)
        if(c->qentry[i]==a){
            _threaddebug(DBGCHAN, "Dequeuing alt %p from channel %p", a, a->c);
            c->qentry[i] = nil;
            /* release if freed and not closing */
            if(c->freed && c->closed != 1)
                _chanfree(c);
            return;
        }
}
@


% enqueue -> <>
<<function emptyentry>>=
static int
emptyentry(Channel *c)
{
    int i, extra;

    assert((c->nentry==0 && c->qentry==nil) || (c->nentry && c->qentry));

    for(i=0; i<c->nentry; i++)
        if(c->qentry[i]==nil)
            return i;

    extra = 16;
    c->nentry += extra;
    c->qentry = realloc((void*)c->qentry, c->nentry*sizeof(c->qentry[0]));
    if(c->qentry == nil)
        sysfatal("realloc channel entries: %r");
    memset(&c->qentry[i], 0, extra*sizeof(c->qentry[0]));
    return i;
}
@



<<function altexec>>=
static int
altexec(Alt *a, int spl)
{
    volatile Alt *b;
    int i, n, otherop;
    Channel *c;
    void *me, *waiter, *buf;

    c = a->c;

    /* rendezvous with others */
    otherop = (CHANSND+CHANRCV) - a->op;
    n = 0;
    b = nil;
    me = a->v;
    for(i=0; i<c->nentry; i++)
        if(c->qentry[i] && c->qentry[i]->op==otherop && *c->qentry[i]->tag==nil)
            if(nrand(++n) == 0)
                b = c->qentry[i];
    if(b != nil){
        _threaddebug(DBGCHAN, "rendez %s alt %p chan %p alt %p", a->op==CHANRCV?"recv":"send", a, c, b);
        waiter = b->v;
        if(c->s && c->n){
            /*
             * if buffer is full and there are waiters
             * and we're meeting a waiter,
             * we must be receiving.
             *
             * we use the value in the channel buffer,
             * copy the waiter's value into the channel buffer
             * on behalf of the waiter, and then wake the waiter.
             */
            if(a->op!=CHANRCV)
                abort();
            buf = altexecbuffered(a, 1);
            altcopy(me, buf, c->e);
            altcopy(buf, waiter, c->e);
        }else{
            if(a->op==CHANRCV)
                altcopy(me, waiter, c->e);
            else
                altcopy(waiter, me, c->e);
        }
        *b->tag = c;	/* commits us to rendezvous */
        _threaddebug(DBGCHAN, "unlocking the chanlock");
        unlock(&chanlock);
        _procsplx(spl);
        _threaddebug(DBGCHAN, "chanlock is %lud", *(ulong*)&chanlock);
        while(_threadrendezvous(b->tag, 0) == Intred)
            ;
        return 1;
    }

    buf = altexecbuffered(a, 0);
    if(a->op==CHANRCV)
        altcopy(me, buf, c->e);
    else
        altcopy(buf, me, c->e);

    unlock(&chanlock);
    _procsplx(spl);
    return 1;
}
@


% altexec -> <>
<<function altexecbuffered>>=
static void*
altexecbuffered(Alt *a, int willreplace)
{
    uchar *v;
    Channel *c;

    c = a->c;
    /* use buffered channel queue */
    if(a->op==CHANRCV && c->n > 0){
        _threaddebug(DBGCHAN, "buffer recv alt %p chan %p", a, c);
        v = c->v + c->e*(c->f%c->s);
        if(!willreplace)
            c->n--;
        c->f++;
        return v;
    }
    if(a->op==CHANSND && c->n < c->s){
        _threaddebug(DBGCHAN, "buffer send alt %p chan %p", a, c);
        v = c->v + c->e*((c->f+c->n)%c->s);
        if(!willreplace)
            c->n++;
        return v;
    }
    abort();
    return nil;
}
@

% altexec -> <>
<<function altcopy>>=
static void
altcopy(void *dst, void *src, int sz)
{
    if(dst){
        if(src)
            memmove(dst, src, sz);
        else
            memset(dst, 0, sz);
    }
}
@


\section{Send/Receive}
% actually they all rely on alt()

% it provides a first form of synchro! you block
% when the other is not ready to receive if have
% no more space in the queue

\subsection{[[runop]]}

<<function runop>>=
static int
runop(int op, Channel *c, void *v, bool nb)
{
    int r;
    Alt a[2];

    /*
     * we could do this without calling alt,
     * but the only reason would be performance,
     * and i'm not convinced it matters.
     */
    a[0].op = op;
    a[0].c = c;
    a[0].v = v;
    a[0].err = nil;
    a[1].op = CHANEND;
    if(nb)
        a[1].op = CHANNOBLK;

    switch(r=alt(a)){
    case -1:	/* interrupted */
        return -1;
    case 1:	/* nonblocking, didn't accomplish anything */
        assert(nb);
        return 0;
    case 0:
        /*
         * Okay, but return -1 if the op is done because of a close.
         */
        if(a[0].err != nil)
            return -1;
        return 1;
    default:
        fprint(2, "ERROR: channel alt returned %d\n", r);
        abort();
        return -1;
    }
}
@

\subsection{[[send()]]/[[recv()]]}

<<function send>>=
int
send(Channel *c, void *v)
{
    return runop(CHANSND, c, v, 0);
}
@

<<function recv>>=
int
recv(Channel *c, void *v)
{
    return runop(CHANRCV, c, v, 0);
}
@

\subsection{Non blocking operations, [[nbxxx()]]}

<<function nbrecv>>=
int
nbrecv(Channel *c, void *v)
{
    return runop(CHANRCV, c, v, 1);
}
@

<<function nbsend>>=
int
nbsend(Channel *c, void *v)
{
    return runop(CHANSND, c, v, 1);
}
@

\subsection{Typed send and receive}

<<function channelsize>>=
static void
channelsize(Channel *c, int sz)
{
    if(c->e != sz){
        fprint(2, "expected channel with elements of size %d, got size %d\n",
            sz, c->e);
        abort();
    }
}
@


<<function sendul>>=
int
sendul(Channel *c, ulong v)
{
    channelsize(c, sizeof(ulong));
    return send(c, &v);
}
@

<<function recvul>>=
ulong
recvul(Channel *c)
{
    ulong v;

    channelsize(c, sizeof(ulong));
    if(recv(c, &v) < 0)
        return ~0;
    return v;
}
@


<<function sendp>>=
int
sendp(Channel *c, void *v)
{
    channelsize(c, sizeof(void*));
    return send(c, &v);
}
@

<<function recvp>>=
void*
recvp(Channel *c)
{
    void *v;

    channelsize(c, sizeof(void*));
    if(recv(c, &v) < 0)
        return nil;
    return v;
}
@


<<function nbsendul>>=
int
nbsendul(Channel *c, ulong v)
{
    channelsize(c, sizeof(ulong));
    return nbsend(c, &v);
}
@

<<function nbrecvul>>=
ulong
nbrecvul(Channel *c)
{
    ulong v;

    channelsize(c, sizeof(ulong));
    if(nbrecv(c, &v) == 0)
        return 0;
    return v;
}
@

<<function nbsendp>>=
int
nbsendp(Channel *c, void *v)
{
    channelsize(c, sizeof(void*));
    return nbsend(c, &v);
}
@

<<function nbrecvp>>=
void*
nbrecvp(Channel *c)
{
    void *v;

    channelsize(c, sizeof(void*));
    if(nbrecv(c, &v) == 0)
        return nil;
    return v;
}
@



\section{IO processus}

% threads are cooperative. If one does a syscall such as reading
% then it hangs the whole process ... so have to put such calls
% in another process, hence the idea of IO slace processes.

<<function ioproc_arg>>=
#define ioproc_arg(io, type)	(va_arg((io)->arg, type))
@

\subsection{[[Ioproc]]}

% private structure! #pragma incomplete in thread.h (and implemented in
% threadimpl.h)
<<struct Ioproc>>=
struct Ioproc
{
    int tid;

    Channel *c;
    Channel *creply;

    int inuse;

    long (*op)(va_list*);

    va_list arg;
    long ret;
    char err[ERRMAX];

    Ioproc *next;
};
@

<<constant STACK>>=
STACK = 8192,
@

% ctor
<<function ioproc>>=
Ioproc*
ioproc(void)
{
    Ioproc *io;

    io = mallocz(sizeof(Ioproc), 1);
    if(io == nil)
        sysfatal("ioproc malloc: %r");
    io->c = chancreate(sizeof(void*), 0);
    io->creply = chancreate(sizeof(void*), 0);
    io->tid = proccreate(xioproc, io, STACK);
    return io;
}
@

% dtor
<<function closeioproc>>=
void
closeioproc(Ioproc *io)
{
    if(io == nil)
        return;
    iointerrupt(io);
    while(send(io->c, 0) == -1)
        ;
    chanfree(io->c);
    chanfree(io->creply);
    free(io);
}
@

% closeioproc | iocall -> <>
<<function iointerrupt>>=
void
iointerrupt(Ioproc *io)
{
    if(!io->inuse)
        return;
    threadint(io->tid);
}
@





\subsection{[[xiproc()]]}

<<function xioproc>>=
static void
xioproc(void *a)
{
    Ioproc *io, *x;
    io = a;
    /*
     * first recvp acquires the ioproc.
     * second tells us that the data is ready.
     */
    for(;;){
        while(recv(io->c, &x) == -1)
            ;
        if(x == 0)	/* our cue to leave */
            break;
        assert(x == io);

        /* caller is now committed -- even if interrupted he'll return */
        while(recv(io->creply, &x) == -1)
            ;
        if(x == 0)	/* caller backed out */
            continue;
        assert(x == io);

        io->ret = io->op(&io->arg);
        if(io->ret < 0)
            rerrstr(io->err, sizeof io->err);
        while(send(io->creply, &io) == -1)
            ;
        while(recv(io->creply, &x) == -1)
            ;
    }
}
@



\subsection{[[iocall()]]}

<<function iocall>>=
long
iocall(Ioproc *io, long (*op)(va_list*), ...)
{
    int ret, inted;
    Ioproc *msg;

    if(send(io->c, &io) == -1){
        werrstr("interrupted");
        return -1;
    }
    assert(!io->inuse);
    io->inuse = 1;
    io->op = op;
    va_start(io->arg, op);
    msg = io;
    inted = 0;
    while(send(io->creply, &msg) == -1){
        msg = nil;
        inted = 1;
    }
    if(inted){
        werrstr("interrupted");
        return -1;
    }

    /*
     * If we get interrupted, we have to stick around so that
     * the IO proc has someone to talk to.  Send it an interrupt
     * and try again.
     */
    inted = 0;
    while(recv(io->creply, nil) == -1){
        inted = 1;
        iointerrupt(io);
    }
    USED(inted);
    va_end(io->arg);
    ret = io->ret;
    if(ret < 0)
        errstr(io->err, sizeof io->err);
    io->inuse = 0;

    /* release resources */
    while(send(io->creply, &io) == -1)
        ;
    return ret;
}
@


\subsection{IO wrappers}


<<function ioopen>>=
int
ioopen(Ioproc *io, char *path, int mode)
{
    return iocall(io, _ioopen, path, mode);
}
@

<<function _ioopen>>=
static long
_ioopen(va_list *arg)
{
    char *path;
    int mode;

    path = va_arg(*arg, char*);
    mode = va_arg(*arg, int);
    return open(path, mode);
}
@



<<function ioclose>>=
int
ioclose(Ioproc *io, int fd)
{
    return iocall(io, _ioclose, fd);
}
@

<<function _ioclose>>=
static long
_ioclose(va_list *arg)
{
    int fd;

    fd = va_arg(*arg, int);
    return close(fd);
}
@


<<function ioread>>=
long
ioread(Ioproc *io, int fd, void *a, long n)
{
    return iocall(io, _ioread, fd, a, n);
}
@

<<function _ioread>>=
static long
_ioread(va_list *arg)
{
    int fd;
    void *a;
    long n;

    fd = va_arg(*arg, int);
    a = va_arg(*arg, void*);
    n = va_arg(*arg, long);
    return read(fd, a, n);
}
@

<<function ioreadn>>=
long
ioreadn(Ioproc *io, int fd, void *a, long n)
{
    return iocall(io, _ioreadn, fd, a, n);
}
@


<<function _ioreadn>>=
static long
_ioreadn(va_list *arg)
{
    int fd;
    void *a;
    long n;

    fd = va_arg(*arg, int);
    a = va_arg(*arg, void*);
    n = va_arg(*arg, long);
    return readn(fd, a, n);
}
@

<<function iowrite>>=
long
iowrite(Ioproc *io, int fd, void *a, long n)
{
    return iocall(io, _iowrite, fd, a, n);
}
@

<<function _iowrite>>=
static long
_iowrite(va_list *arg)
{
    int fd;
    void *a;
    long n;

    fd = va_arg(*arg, int);
    a = va_arg(*arg, void*);
    n = va_arg(*arg, long);
    return write(fd, a, n);
}
@

<<function iosleep>>=
int
iosleep(Ioproc *io, long n)
{
    return iocall(io, _iosleep, n);
}
@


<<function _iosleep>>=
static long
_iosleep(va_list *arg)
{
    long n;

    n = va_arg(*arg, long);
    return sleep(n);
}
@



\section{Thread-aware libc}

\subsection{Memory}

% actually malloc already shared-memory safe as it uses locks.
% but have a small malloc wrapper not doing that much more,
% just a bit more error safe:

<<global totalmalloc>>=
static long totalmalloc;
@

<<function _threadmalloc>>=
void*
_threadmalloc(long size, int z)
{
    void *m;

    m = malloc(size);
    if (m == nil)
        sysfatal("Malloc of size %ld failed: %r", size);
    setmalloctag(m, getcallerpc(&size));
    totalmalloc += size;
    if (size > 100000000) {
        fprint(2, "Malloc of size %ld, total %ld\n", size, totalmalloc);
        abort();
    }
    if (z)
        memset(m, 0, size);
    return m;
}
@


\subsection{Exit}
% need to terminate all of those things.
% I remember it was tricky in ocaml to get things right
% when have worker, when use MPI, etc.

<<global _threadexitsallstatus>>=
char *_threadexitsallstatus;
@

<<function threadexits>>=
void
threadexits(char *exitstr)
{
    Proc *p;
    Thread *t;

    p = _threadgetproc();
    t = p->thread;
    t->moribund = 1;
    if(exitstr==nil)
        exitstr="";
    utfecpy(p->exitstr, p->exitstr+ERRMAX, exitstr);
    _sched();
}
@


<<function threadexitsall>>=
void
threadexitsall(char *exitstr)
{
    Proc *p;
    int pid[64];
    int i, npid, mypid;

    if(exitstr == nil)
        exitstr = "";
    _threadexitsallstatus = exitstr;
    _threaddebug(DBGSCHED, "_threadexitsallstatus set to %p", _threadexitsallstatus);
    mypid = _tos->pid; //getpid();

    /*
     * signal others.
     * copying all the pids first avoids other threads
     * teardown procedures getting in the way.
     *
     * avoid mallocs since malloc can post a note which can
     * call threadexitsall...
     */
    for(;;){
        lock(&_threadpq.lock);
        npid = 0;
        for(p = _threadpq.head; p && npid < nelem(pid); p=p->next){
            if(p->threadint == 0 && p->pid != mypid){
                pid[npid++] = p->pid;
                p->threadint = 1;
            }
        }
        unlock(&_threadpq.lock);
        if(npid == 0)
            break;
        for(i=0; i<npid; i++)
            postnote(PNPROC, pid[i], "threadint");
    }

    /* leave */
    exits(exitstr);
}
@


<<global _threadwaitchan>>=
Channel *_threadwaitchan;
@

<<function threadwaitchan>>=
Channel*
threadwaitchan(void)
{
    if(_threadwaitchan==nil)
        _threadwaitchan = chancreate(sizeof(Waitmsg*), 16);
    return _threadwaitchan;
}
@

\subsection{Fork}

<<function _schedfork>>=
int
_schedfork(Proc *p)
{
    int pid;

    switch(pid = rfork(RFPROC|RFMEM|RFNOWAIT|p->rforkflag)){
    case 0:
        *mainp = p;	/* write to stack, so local to proc */
        longjmp(_mainjmp, 1);
    default:
        return pid;
    }
}
@

\subsection{Exec}

% in main.c, not sure why, could be in a exec.c
<<function _schedexec>>=
int
_schedexec(Execargs *e)
{
    int pid;

    switch(pid = rfork(RFREND|RFNOTEG|RFFDG|RFMEM|RFPROC)){
    case 0:
        efork(e);
    default:
        return pid;
    }
}
@

% _schedexec -> <>
<<function efork>>=
static void
efork(Execargs *e)
{
    char buf[ERRMAX];

    _threaddebug(DBGEXEC, "_schedexec %s", e->prog);
    close(e->fd[0]);
    exec(e->prog, e->args);
    _threaddebug(DBGEXEC, "_schedexec failed: %r");
    rerrstr(buf, sizeof buf);
    if(buf[0]=='\0')
        strcpy(buf, "exec failed");
    write(e->fd[1], buf, strlen(buf));
    close(e->fd[1]);
    _exits(buf);
}
@


% procexec -> <>
<<function _schedexecwait>>=
void
_schedexecwait(void)
{
    int pid;
    Channel *c;
    Proc *p;
    Thread *t;
    Waitmsg *w;

    p = _threadgetproc();
    t = p->thread;
    pid = t->ret;
    _threaddebug(DBGEXEC, "_schedexecwait %d", t->ret);

    rfork(RFCFDG);
    for(;;){
        w = wait();
        if(w == nil)
            break;
        if(w->pid == pid)
            break;
        free(w);
    }
    if(w != nil){
        if((c = _threadwaitchan) != nil)
            sendp(c, w);
        else
            free(w);
    }
    threadexits("procexec");
}
@




<<constant PIPEMNT>>=
#define PIPEMNT	"/mnt/temp"
@

<<function procexec>>=
void
procexec(Channel *pidc, char *prog, char *args[])
{
    int n;
    Proc *p;
    Thread *t;

    _threaddebug(DBGEXEC, "procexec %s", prog);
    /* must be only thread in proc */
    p = _threadgetproc();
    t = p->thread;
    if(p->threads.head != t || p->threads.head->nextt != nil){
        werrstr("not only thread in proc");
    Bad:
        if(pidc)
            sendul(pidc, ~0);
        return;
    }

    /*
     * We want procexec to behave like exec; if exec succeeds,
     * never return, and if it fails, return with errstr set.
     * Unfortunately, the exec happens in another proc since
     * we have to wait for the exec'ed process to finish.
     * To provide the semantics, we open a pipe with the 
     * write end close-on-exec and hand it to the proc that
     * is doing the exec.  If the exec succeeds, the pipe will
     * close so that our read below fails.  If the exec fails,
     * then the proc doing the exec sends the errstr down the
     * pipe to us.
     */
    if(bind("#|", PIPEMNT, MREPL) < 0)
        goto Bad;
    if((p->exec.fd[0] = open(PIPEMNT "/data", OREAD)) < 0){
        unmount(nil, PIPEMNT);
        goto Bad;
    }
    if((p->exec.fd[1] = open(PIPEMNT "/data1", OWRITE|OCEXEC)) < 0){
        close(p->exec.fd[0]);
        unmount(nil, PIPEMNT);
        goto Bad;
    }
    unmount(nil, PIPEMNT);

    /* exec in parallel via the scheduler */
    assert(p->needexec==0);
    p->exec.prog = prog;
    p->exec.args = args;
    p->needexec = 1;
    _sched();

    close(p->exec.fd[1]);
    if((n = read(p->exec.fd[0], p->exitstr, ERRMAX-1)) > 0){	/* exec failed */
        p->exitstr[n] = '\0';
        errstr(p->exitstr, ERRMAX);
        close(p->exec.fd[0]);
        goto Bad;
    }
    close(p->exec.fd[0]);

    if(pidc)
        sendul(pidc, t->ret);

    /* wait for exec'ed program, then exit */
    _schedexecwait();
}
@

<<function procexecl>>=
void
procexecl(Channel *pidc, char *f, ...)
{
    procexec(pidc, f, &f+1);
}
@




\subsection{Interruptions}

<<constant Intred>>=
#define Intred	((void*)~0)		/* interrupted */
@


\subsection{Notes}








<<global _threadnopasser>>=
int	_threadnopasser;
@

<<constant NFN (libthread/note.c)>>=
#define	NFN		33
@

<<constant ERRLEN>>=
#define	ERRLEN	48
@

<<struct Note>>=
struct Note
{
    Lock		inuse;
    Proc		*proc;		/* recipient */
    char		s[ERRMAX];	/* arg2 */
};
@

<<global notes>>=
static Note	notes[128];
@

<<global enotes>>=
static Note	*enotes = notes+nelem(notes);
@

<<global onnote>>=
static int		(*onnote[NFN])(void*, char*);
@

<<global onnotepid>>=
static int		onnotepid[NFN];
@

<<global onnotelock>>=
static Lock	onnotelock;
@

<<function threadnotify>>=
int
threadnotify(int (*f)(void*, char*), int in)
{
    int i, topid;
    int (*from)(void*, char*), (*to)(void*, char*);

    if(in){
        from = nil;
        to = f;
        topid = _threadgetproc()->pid;
    }else{
        from = f;
        to = nil;
        topid = 0;
    }
    lock(&onnotelock);
    for(i=0; i<NFN; i++)
        if(onnote[i]==from){
            onnote[i] = to;
            onnotepid[i] = topid;
            break;
        }
    unlock(&onnotelock);
    return i<NFN;
}
@

<<function delayednotes>>=
static void
delayednotes(Proc *p, void *v)
{
    int i;
    Note *n;
    int (*fn)(void*, char*);

    if(!p->pending)
        return;

    p->pending = 0;
    for(n=notes; n<enotes; n++){
        if(n->proc == p){
            for(i=0; i<NFN; i++){
                if(onnotepid[i]!=p->pid || (fn = onnote[i])==nil)
                    continue;
                if((*fn)(v, n->s))
                    break;
            }
            if(i==NFN){
                _threaddebug(DBGNOTE, "Unhandled note %s, proc %p\n", n->s, p);
                if(v != nil)
                    noted(NDFLT);
                else if(strncmp(n->s, "sys:", 4)==0)
                    abort();
                threadexitsall(n->s);
            }
            n->proc = nil;
            unlock(&n->inuse);
        }
    }
}
@

<<function _threadnote>>=
void
_threadnote(void *v, char *s)
{
    Proc *p;
    Note *n;

    _threaddebug(DBGNOTE, "Got note %s", s);
    if(strncmp(s, "sys:", 4) == 0)
        noted(NDFLT);

    if(_threadexitsallstatus){
        _threaddebug(DBGNOTE, "Threadexitsallstatus = '%s'\n", _threadexitsallstatus);
        _exits(_threadexitsallstatus);
    }

    if(strcmp(s, "threadint")==0)
        noted(NCONT);

    p = _threadgetproc();
    if(p == nil)
        noted(NDFLT);

    for(n=notes; n<enotes; n++)
        if(canlock(&n->inuse))
            break;
    if(n==enotes)
        sysfatal("libthread: too many delayed notes");
    utfecpy(n->s, n->s+ERRMAX, s);
    n->proc = p;
    p->pending = 1;
    if(!p->splhi)
        delayednotes(p, v);
    noted(NCONT);
}
@

<<function _procsplhi>>=
int
_procsplhi(void)
{
    int s;
    Proc *p;

    p = _threadgetproc();
    s = p->splhi;
    p->splhi = 1;
    return s;
}
@

<<function _procsplx>>=
void
_procsplx(int s)
{
    Proc *p;

    p = _threadgetproc();
    p->splhi = s;
    if(s)
        return;
    if(p->pending)
        delayednotes(p, nil);
}
@




\subsection{Dialing}

<<function _iodial>>=
static long
_iodial(va_list *arg)
{
    char *addr, *local, *dir;
    int *cdfp;

    addr = va_arg(*arg, char*);
    local = va_arg(*arg, char*);
    dir = va_arg(*arg, char*);
    cdfp = va_arg(*arg, int*);

    return dial(addr, local, dir, cdfp);
}
@

<<function iodial>>=
int
iodial(Ioproc *io, char *addr, char *local, char *dir, int *cdfp)
{
    return iocall(io, _iodial, addr, local, dir, cdfp);
}
@




<<enum _anon_ (lib_core/libthread/dial.c)>>=
enum
{
    Maxstring	= 128,
    Maxpath		= 256,
};
@

<<struct DS (libthread/dial.c)>>=
struct DS {
    /* dist string */
    char	buf[Maxstring];
    char	*netdir;
    char	*proto;
    char	*rem;

    /* other args */
    char	*local;
    char	*dir;
    int	*cfdp;
};
@

<<function _threaddial>>=
/*
 *  the dialstring is of the form '[/net/]proto!dest'
 */
int
_threaddial(char *dest, char *local, char *dir, int *cfdp)
{
    DS ds;
    int rv;
    char err[ERRMAX], alterr[ERRMAX];

    ds.local = local;
    ds.dir = dir;
    ds.cfdp = cfdp;

    _dial_string_parse(dest, &ds);
    if(ds.netdir)
        return csdial(&ds);

    ds.netdir = "/net";
    rv = csdial(&ds);
    if(rv >= 0)
        return rv;
    err[0] = '\0';
    errstr(err, sizeof err);
    if(strstr(err, "refused") != 0){
        werrstr("%s", err);
        return rv;
    }
    ds.netdir = "/net.alt";
    rv = csdial(&ds);
    if(rv >= 0)
        return rv;

    alterr[0] = 0;
    errstr(alterr, sizeof alterr);
    if(strstr(alterr, "translate") || strstr(alterr, "does not exist"))
        werrstr("%s", err);
    else
        werrstr("%s", alterr);
    return rv;
}
@

<<function csdial (libthread/dial.c)>>=
static int
csdial(DS *ds)
{
    int n, fd, rv;
    char *p, buf[Maxstring], clone[Maxpath], err[ERRMAX], besterr[ERRMAX];

    /*
     *  open connection server
     */
    snprint(buf, sizeof(buf), "%s/cs", ds->netdir);
    fd = open(buf, ORDWR);
    if(fd < 0){
        /* no connection server, don't translate */
        snprint(clone, sizeof(clone), "%s/%s/clone", ds->netdir, ds->proto);
        return call(clone, ds->rem, ds);
    }

    /*
     *  ask connection server to translate
     */
    snprint(buf, sizeof(buf), "%s!%s", ds->proto, ds->rem);
    if(write(fd, buf, strlen(buf)) < 0){
        close(fd);
        return -1;
    }

    /*
     *  loop through each address from the connection server till
     *  we get one that works.
     */
    *besterr = 0;
    rv = -1;
    seek(fd, 0, 0);
    while((n = read(fd, buf, sizeof(buf) - 1)) > 0){
        buf[n] = 0;
        p = strchr(buf, ' ');
        if(p == 0)
            continue;
        *p++ = 0;
        rv = call(buf, p, ds);
        if(rv >= 0)
            break;
        err[0] = '\0';
        errstr(err, sizeof err);
        if(strstr(err, "does not exist") == 0)
            strcpy(besterr, err);
    }
    close(fd);

    if(rv < 0 && *besterr)
        werrstr("%s", besterr);
    else
        werrstr("%s", err);
    return rv;
}
@

<<function call (libthread/dial.c)>>=
static int
call(char *clone, char *dest, DS *ds)
{
    int fd, cfd, n;
    char cname[Maxpath], name[Maxpath], data[Maxpath], *p;

    /* because cs is in a different name space, replace the mount point */
    if(*clone == '/'){
        p = strchr(clone+1, '/');
        if(p == nil)
            p = clone;
        else 
            p++;
    } else
        p = clone;
    snprint(cname, sizeof cname, "%s/%s", ds->netdir, p);

    cfd = open(cname, ORDWR);
    if(cfd < 0)
        return -1;

    /* get directory name */
    n = read(cfd, name, sizeof(name)-1);
    if(n < 0){
        close(cfd);
        return -1;
    }
    name[n] = 0;
    for(p = name; *p == ' '; p++)
        ;
    snprint(name, sizeof(name), "%ld", strtoul(p, 0, 0));
    p = strrchr(cname, '/');
    *p = 0;
    if(ds->dir)
        snprint(ds->dir, NETPATHLEN, "%s/%s", cname, name);
    snprint(data, sizeof(data), "%s/%s/data", cname, name);

    /* connect */
    if(ds->local)
        snprint(name, sizeof(name), "connect %s %s", dest, ds->local);
    else
        snprint(name, sizeof(name), "connect %s", dest);
    if(write(cfd, name, strlen(name)) < 0){
        close(cfd);
        return -1;
    }

    /* open data connection */
    fd = open(data, ORDWR);
    if(fd < 0){
        close(cfd);
        return -1;
    }
    if(ds->cfdp)
        *ds->cfdp = cfd;
    else
        close(cfd);
    return fd;
}
@

<<function _dial_string_parse (libthread/dial.c)>>=
/*
 *  parse a dial string
 */
static void
_dial_string_parse(char *str, DS *ds)
{
    char *p, *p2;

    strncpy(ds->buf, str, Maxstring);
    ds->buf[Maxstring-1] = 0;

    p = strchr(ds->buf, '!');
    if(p == 0) {
        ds->netdir = 0;
        ds->proto = "net";
        ds->rem = ds->buf;
    } else {
        if(*ds->buf != '/' && *ds->buf != '#'){
            ds->netdir = 0;
            ds->proto = ds->buf;
        } else {
            for(p2 = p; *p2 != '/'; p2--)
                ;
            *p2++ = 0;
            ds->netdir = ds->buf;
            ds->proto = p2;
        }
        *p = 0;
        ds->rem = p + 1;
    }
}
@



\section{Error management}

%"Thread library functions do not return on failure; if errors occur, the entire program is aborted."


% call abort() which enter broken state I think by causing a fault


<<function _threadsysfatal>>=
void
_threadsysfatal(char *fmt, va_list arg)
{
    char buf[1024];	/* size doesn't matter; we're about to exit */

    vseprint(buf, buf+sizeof(buf), fmt, arg);
    if(argv0)
        fprint(2, "%s: %s\n", argv0, buf);
    else
        fprint(2, "%s\n", buf);
    threadexitsall(buf);
}
@

<<function _threadassert>>=
void
_threadassert(char *s)
{
    char buf[256];
    int n;
    Proc *p;

    p = _threadgetproc();
    if(p && p->thread)
        n = sprint(buf, "%d.%d ", p->pid, p->thread->id);
    else
        n = 0;
    snprint(buf+n, sizeof(buf)-n, "%s: assertion failed\n", s);
    write(2, buf, strlen(buf));
    abort();
}
@


\section{Debugging}


<<global _threaddebuglevel>>=
// biset<enum<dbgxxx>>
int _threaddebuglevel;
@

% could use enum dbgxxx
<<constant DBGAPPL>>=
#define DBGAPPL	(1 << 0)
@

<<constant DBGSCHED>>=
#define DBGSCHED	(1 << 16)
@

<<constant DBGCHAN>>=
#define DBGCHAN	(1 << 17)
@

<<constant DBGREND>>=
#define DBGREND	(1 << 18)
@

<<constant DBGNOTE>>=
#define DBGNOTE	(1 << 20)
@
%/* #define DBGKILL	(1 << 19) */

<<constant DBGEXEC>>=
#define DBGEXEC	(1 << 21)
@



<<function _threaddebug>>=
void
_threaddebug(ulong flag, char *fmt, ...)
{
    char buf[128];
    va_list arg;
    Fmt f;
    Proc *p;

    if((_threaddebuglevel&flag) == 0)
        return;

    fmtfdinit(&f, 2, buf, sizeof buf);

    p = _threadgetproc();
    if(p==nil)
        fmtprint(&f, "noproc ");
    else if(p->thread)
        fmtprint(&f, "%d.%d ", p->pid, p->thread->id);
    else
        fmtprint(&f, "%d._ ", p->pid);

    va_start(arg, fmt);
    fmtvprint(&f, fmt, arg);
    va_end(arg);
    fmtprint(&f, "\n");
    fmtfdflush(&f);
}
@



\section{Advanced topics}

% dead?
<<global _threadnotefd>>=
int	_threadnotefd;
@

% dead?
<<global _threadpasserpid>>=
int	_threadpasserpid;
@


% dead?
<<function _times>>=
static long
_times(long *t)
{
    char b[200], *p;
    int f;
    ulong r;

    memset(b, 0, sizeof(b));
    f = open("/dev/cputime", OREAD|OCEXEC);
    if(f < 0)
        return 0;
    if(read(f, b, sizeof(b)) <= 0){
        close(f);
        return 0;
    }
    p = b;
    if(t)
        t[0] = atol(p);
    p = skip(p);
    if(t)
        t[1] = atol(p);
    p = skip(p);
    r = atol(p);
    if(t){
        p = skip(p);
        t[2] = atol(p);
        p = skip(p);
        t[3] = atol(p);
    }
    return r;
}
@

% _times -> <>
<<function skip (libthread/main.c)>>=
static char*
skip(char *p)
{
    while(*p == ' ')
        p++;
    while(*p != ' ' && *p != 0)
        p++;
    return p;
}
@


\subsection{Per  thread private data}

<<global privlock (libthread/id.c)>>=
static Lock privlock;
@

<<global privmask>>=
//array<bool> NPRIV at least
static int privmask = 1;
@

<<function tprivalloc>>=
int
tprivalloc(void)
{
    int i;

    lock(&privlock);
    for(i=0; i<NPRIV; i++)
        if(!(privmask&(1<<i))){
            privmask |= 1<<i;
            unlock(&privlock);
            return i;
        }
    unlock(&privlock);
    return -1;
}
@

<<function tprivfree>>=
void
tprivfree(int i)
{
    if(i < 0 || i >= NPRIV)
        abort();
    lock(&privlock);
    privmask &= ~(1<<i);
}
@

<<function tprivaddr>>=
void**
tprivaddr(int i)
{
    return &_threadgetproc()->thread->udata[i];
}
@




<<function threaddata>>=
void**
threaddata(void)
{
    return &_threadgetproc()->thread->udata[0];
}
@

<<function _workerdata>>=
void**
_workerdata(void)
{
    return &_threadgetproc()->wdata;
}
@

<<function procdata>>=
void**
procdata(void)
{
    return &_threadgetproc()->udata;
}
@

\subsection{Thread groups}

<<function threadsetgrp>>=
int
threadsetgrp(int ng)
{
    int og;
    Thread *t;

    t = _threadgetproc()->thread;
    og = t->grp;
    t->grp = ng;
    return og;
}
@

<<function threadgetgrp>>=
int
threadgetgrp(void)
{
    return _threadgetproc()->thread->grp;
}
@

\subsection{Thread kills}


<<function tinterrupt>>=
static void
tinterrupt(Proc *p, Thread *t)
{
    switch(t->state){
    case Running:
        postnote(PNPROC, p->pid, "threadint");
        break;
    case Rendezvous:
        _threadflagrendez(t);
        break;
    }
}
@


<<function threadkillgrp>>=
void
threadkillgrp(int grp)
{
    threadxxxgrp(grp, 1);
}
@

<<function threadkill>>=
void
threadkill(int id)
{
    threadxxx(id, 1);
}
@


<<function threadxxxgrp>>=
static void
threadxxxgrp(int grp, int dokill)
{
    Proc *p;
    Thread *t;

    lock(&_threadpq.lock);
    for(p=_threadpq.head; p; p=p->next){
        lock(&p->lock);
        for(t=p->threads.head; t; t=t->nextt)
            if(t->grp == grp){
                if(dokill)
                    t->moribund = 1;
                tinterrupt(p, t);
            }
        unlock(&p->lock);
    }
    unlock(&_threadpq.lock);
    _threadbreakrendez();
}
@

<<function threadxxx>>=
static void
threadxxx(int id, int dokill)
{
    Proc *p;
    Thread *t;

    lock(&_threadpq.lock);
    for(p=_threadpq.head; p; p=p->next){
        lock(&p->lock);
        for(t=p->threads.head; t; t=t->nextt)
            if(t->id == id){
                if(dokill)
                    t->moribund = 1;
                tinterrupt(p, t);
                unlock(&p->lock);
                unlock(&_threadpq.lock);
                _threadbreakrendez();
                return;
            }
        unlock(&p->lock);
    }
    unlock(&_threadpq.lock);
    _threaddebug(DBGNOTE, "Can't find thread to kill");
    return;
}
@



<<function threadintgrp>>=
void
threadintgrp(int grp)
{
    threadxxxgrp(grp, 0);
}
@

<<function threadint>>=
void
threadint(int id)
{
    threadxxx(id, 0);
}
@


\subsection{Rendez vous}

<<constant RENDHASH>>=
RENDHASH = 13,
@

<<struct Rgrp>>=
struct Rgrp
{
    Lock	lock;
    Thread	*hash[RENDHASH];
};
@

<<global _threadrgrp>>=
Rgrp _threadrgrp;
@

<<function _threadrendezvous>>=
void*
_threadrendezvous(void *tag, void *val)
{
    void *ret;
    Thread *t, **l;

    lock(&_threadrgrp.lock);
    l = &_threadrgrp.hash[((uintptr)tag)%nelem(_threadrgrp.hash)];
    for(t=*l; t; l=&t->rendhash, t=*l){
        if(t->rendtag==tag){
            _threaddebug(DBGREND, "Rendezvous with thread %d.%d", t->proc->pid, t->id);
            *l = t->rendhash;
            ret = finish(t, val);
            unlock(&_threadrgrp.lock);
            return ret;
        }
    }

    /* Going to sleep here. */
    t = _threadgetproc()->thread;
    t->rendbreak = 0;
    t->inrendez = 1;
    t->rendtag = tag;
    t->rendval = val;
    t->rendhash = *l;
    *l = t;
    t->nextstate = Rendezvous;
    _threaddebug(DBGREND, "Rendezvous for tag %p", t->rendtag);
    unlock(&_threadrgrp.lock);
    _sched();
    t->inrendez = 0;
    _threaddebug(DBGREND, "Woke after rendezvous; val is %p", t->rendval);
    return t->rendval;
}
@


<<global isdirty>>=
static int isdirty;
@

<<function finish>>=
static void*
finish(Thread *t, void *val)
{
    void *ret;

    ret = t->rendval;
    t->rendval = val;
    while(t->state == Running)
        sleep(0);
    lock(&t->proc->lock);
    if(t->state == Rendezvous){	/* not always true: might be Dead */
        t->state = Ready;
        _threadready(t);
    }
    unlock(&t->proc->lock);
    return ret;
}
@


<<function _threadflagrendez>>=
/*
 * This is called while holding _threadpq.lock and p->lock,
 * so we can't lock _threadrgrp.lock.  Instead our caller has 
 * to call _threadbreakrendez after dropping those locks.
 */
void
_threadflagrendez(Thread *t)
{
    t->rendbreak = 1;
    isdirty = 1;
}
@

<<function _threadbreakrendez>>=
void
_threadbreakrendez(void)
{
    int i;
    Thread *t, **l;

    if(isdirty == 0)
        return;
    lock(&_threadrgrp.lock);
    if(isdirty == 0){
        unlock(&_threadrgrp.lock);
        return;
    }
    isdirty = 0;
    for(i=0; i<nelem(_threadrgrp.hash); i++){
        l = &_threadrgrp.hash[i];
        for(t=*l; t; t=*l){
            if(t->rendbreak){
                *l = t->rendhash;
                finish(t, (void*)~0);
            }else
                 l=&t->rendhash;
        }
    }
    unlock(&_threadrgrp.lock);
}
@



\subsection{[[chanprint()]]}

<<function chanprint>>=
int
chanprint(Channel *c, char *fmt, ...)
{
    va_list arg;
    char *p;
    int n;

    va_start(arg, fmt);
    p = vsmprint(fmt, arg);
    va_end(arg);
    if(p == nil)
        sysfatal("vsmprint failed: %r");
    n = sendp(c, p);
    yield();	/* let recipient handle message immediately */
    return n;
}
@
\chapter{Network}

% More in Network.nw, here just wrappers.

<<type NetConnInfo>>=
struct NetConnInfo {
    char    *dir;       /* connection directory */
    char    *root;      /* network root */
    char    *spec;      /* binding spec */
    char    *lsys;      /* local system */
    char    *lserv;     /* local service */
    char    *rsys;      /* remote system */
    char    *rserv;     /* remote service */
    char    *laddr;     /* local address */
    char    *raddr;     /* remote address */
};
@

\chapter{Mathematics}
%http://developerblog.redhat.com/2015/01/02/improving-math-performance-in-glibc/

% _div and _mod are in Assembler.nw appendix

% "Computer Approximations, by Hart, Chenney, Lawson, ...

\section{Basics}

<<function abs>>=
int
abs(int a)
{
    if(a < 0)
        return -a;
    return a;
}
@

<<function fabs>>=
double
fabs(double arg)
{

    if(arg < 0)
        return -arg;
    return arg;
}
@

%dead:
%<<function labs>>=
%long
%labs(long a)
%{
%    if(a < 0)
%        return -a;
%    return a;
%}
%@


<<function floor>>=
/*
 * floor and ceil-- greatest integer <= arg
 * (resp least >=)
 */

double
floor(double d)
{
    double fract;

    if(d < 0) {
        fract = modf(-d, &d);
        if(fract != 0.0)
            d += 1;
        d = -d;
    } else
        modf(d, &d);
    return d;
}
@

<<function ceil>>=
double
ceil(double d)
{
    return -floor(-d);
}
@





\section{Integers}

\subsection{Parsing}

<<function atoi>>=
int
atoi(char *s)
{

    return atol(s);
}
@

<<function atol>>=
long
atol(char *s)
{
    long n;
    int f, c;

    n = 0;
    f = 0;
    while(*s == ' ' || *s == '\t')
        s++;
    if(*s == '-' || *s == '+') {
        if(*s++ == '-')
            f = 1;
        while(*s == ' ' || *s == '\t')
            s++;
    }
    if(s[0]=='0' && s[1]) {
        if(s[1]=='x' || s[1]=='X'){
            s += 2;
            for(;;) {
                c = *s;
                if(c >= '0' && c <= '9')
                    n = n*16 + c - '0';
                else
                if(c >= 'a' && c <= 'f')
                    n = n*16 + c - 'a' + 10;
                else
                if(c >= 'A' && c <= 'F')
                    n = n*16 + c - 'A' + 10;
                else
                    break;
                s++;
            }
        } else
            while(*s >= '0' && *s <= '7')
                n = n*8 + *s++ - '0';
    } else
        while(*s >= '0' && *s <= '9')
            n = n*10 + *s++ - '0';
    if(f)
        n = -n;
    return n;
}
@




<<constant LONG_MAX>>=
#define LONG_MAX    2147483647L
@

<<constant LONG_MIN>>=
#define LONG_MIN    -2147483648L
@

% more flexible than atol, can accept stuff after numbers
% and return pointer after. 
% Can also use different base?? use? to not force to prefix with 0x or 0o?
<<function strtol>>=
long
strtol(char *nptr, char **endptr, int base)
{
    char *p;
    long n, nn, m;
    int c, ovfl, v, neg, ndig;

    p = nptr;
    neg = 0;
    n = 0;
    ndig = 0;
    ovfl = 0;

    /*
     * White space
     */
    for(;; p++) {
        switch(*p) {
        case ' ':
        case '\t':
        case '\n':
        case '\f':
        case '\r':
        case '\v':
            continue;
        }
        break;
    }

    /*
     * Sign
     */
    if(*p=='-' || *p=='+')
        if(*p++ == '-')
            neg = 1;

    /*
     * Base
     */
    if(base==0) {
        base = 10;
        if(*p == '0') {
            base = 8;
            if(p[1]=='x' || p[1]=='X') {
                p += 2;
                base = 16;
            }
        }
    } else
    if(base==16 && *p=='0'){
        if(p[1]=='x' || p[1]=='X')
            p += 2;
    } else
    if(base<0 || 36<base)
        goto Return;

    /*
     * Non-empty sequence of digits
     */
    m = LONG_MAX/base;
    for(;; p++,ndig++){
        c = *p;
        v = base;
        if('0'<=c && c<='9')
            v = c - '0';
        else
        if('a'<=c && c<='z')
            v = c - 'a' + 10;
        else
        if('A'<=c && c<='Z')
            v = c - 'A' + 10;
        if(v >= base)
            break;
        if(n > m)
            ovfl = 1;
        nn = n*base + v;
        if(nn < n)
            ovfl = 1;
        n = nn;
    }

Return:
    if(ndig == 0)
        p = nptr;
    if(endptr)
        *endptr = p;
    if(ovfl){
        if(neg)
            return LONG_MIN;
        return LONG_MAX;
    }
    if(neg)
        return -n;
    return n;
}
@


\section{Floats}

\subsection{Special numbers}

<<constant NANEXP>>=
#define NANEXP  (2047<<20)
@
% >>


<<function NaN>>=
double
NaN(void)
{
    FPdbleword a;

    a.hi = NANEXP;
    a.lo = 1;
    return a.x;
}
@

<<constant NANMASK>>=
#define NANMASK (2047<<20)
@
% >>

<<function isNaN>>=
int
isNaN(double d)
{
    FPdbleword a;

    a.x = d;
    if((a.hi & NANMASK) != NANEXP)
        return 0;
    return !isInf(d, 0);
}
@


<<constant NANSIGN>>=
#define NANSIGN (1<<31)
@
% >>

<<function Inf>>=
double
Inf(int sign)
{
    FPdbleword a;

    a.hi = NANEXP;
    a.lo = 0;
    if(sign < 0)
        a.hi |= NANSIGN;
    return a.x;
}
@

<<function isInf>>=
int
isInf(double d, int sign)
{
    FPdbleword a;

    a.x = d;
    if(a.lo != 0)
        return 0;
    if(a.hi == NANEXP)
        return sign >= 0;
    if(a.hi == (NANEXP|NANSIGN))
        return sign <= 0;
    return 0;
}
@



<<type FPxxx>>=
/* VFP FCR */
#define FPINEX  (1<<12)         /* trap enables for exceptions */
#define FPUNFL  (1<<11)
#define FPOVFL  (1<<10)
#define FPZDIV  (1<<9)
#define FPINVAL (1<<8)
#define FPRNR   (0<<22)
#define FPRZ    (1<<22)
#define FPRPINF (2<<22)
#define FPRNINF (3<<22)
#define FPRMASK (3<<22)
#define FPPEXT  0
#define FPPSGL  0
#define FPPDBL  0
#define FPPMASK 0
/* FSR */
#define FPAINEX (1<<4)          /* accrued exceptions */
#define FPAUNFL (1<<3)
#define FPAOVFL (1<<2)
#define FPAZDIV (1<<1)
#define FPAINVAL    (1<<0)
@
% >> >> >> >> >> >> >>
% >> >> >> >> >> >> >>
% >> >> >> >> >> >> >>


\subsection{[[sqrt()]]}

<<function sqrt>>=
double
sqrt(double arg)
{
    double x, temp;
    int exp, i;

    if(arg <= 0) {
        if(arg < 0)
            return NaN();
        return 0;
    }
    if(isInf(arg, 1))
        return arg;
    x = frexp(arg, &exp);
    while(x < 0.5) {
        x *= 2;
        exp--;
    }
    /*
     * NOTE
     * this wont work on 1's comp
     */
    if(exp & 1) {
        x *= 2;
        exp--;
    }
    temp = 0.5 * (1.0+x);

    while(exp > 60) {
        temp *= (1L<<30);
        exp -= 60;
    }
    while(exp < -60) {
        temp /= (1L<<30);
        exp += 60;
    }
    if(exp >= 0)
        temp *= 1L << (exp/2);
    else
        temp /= 1L << (-exp/2);
    for(i=0; i<=4; i++)
        temp = 0.5*(temp + arg/temp);
    return temp;
}
@
% >> >> >> >> >> >>

\subsection{Parsing}

<<function atof>>=
double
atof(char *cp)
{
    return strtod(cp, 0);
}
@

<<function strtod>>=
double
strtod(char *as, char **aas)
{
    int na, ona, ex, dp, bp, c, i, flag, state;
    ulong low[Prec], hig[Prec], mid[Prec], num, den;
    double d;
    char *s, a[Ndig];

    flag = 0;   // Fsign, Fesign, Fdpoint
    na = 0;     // number of digits of a[]
    dp = 0;     // na of decimal point
    ex = 0;     // exonent

    state = S0;
    for(s=as;; s++) {
        c = *s;
        if(c >= '0' && c <= '9') {
            switch(state) {
            case S0:
            case S1:
            case S2:
                state = S2;
                break;
            case S3:
            case S4:
                state = S4;
                break;

            case S5:
            case S6:
            case S7:
                state = S7;
                ex = ex*10 + (c-'0');
                continue;
            }
            if(na == 0 && c == '0') {
                dp--;
                continue;
            }
            if(na < Ndig-50)
                a[na++] = c;
            continue;
        }
        switch(c) {
        case '\t':
        case '\n':
        case '\v':
        case '\f':
        case '\r':
        case ' ':
            if(state == S0)
                continue;
            break;
        case '-':
            if(state == S0)
                flag |= Fsign;
            else
                flag |= Fesign;
        case '+':
            if(state == S0)
                state = S1;
            else
            if(state == S5)
                state = S6;
            else
                break;  // syntax
            continue;
        case '.':
            flag |= Fdpoint;
            dp = na;
            if(state == S0 || state == S1) {
                state = S3;
                continue;
            }
            if(state == S2) {
                state = S4;
                continue;
            }
            break;
        case 'e':
        case 'E':
            if(state == S2 || state == S4) {
                state = S5;
                continue;
            }
            break;
        }
        break;
    }

    /*
     * clean up return char-pointer
     */
    switch(state) {
    case S0:
        if(xcmp(s, "nan") == 0) {
            if(aas != nil)
                *aas = s+3;
            goto retnan;
        }
    case S1:
        if(xcmp(s, "infinity") == 0) {
            if(aas != nil)
                *aas = s+8;
            goto retinf;
        }
        if(xcmp(s, "inf") == 0) {
            if(aas != nil)
                *aas = s+3;
            goto retinf;
        }
    case S3:
        if(aas != nil)
            *aas = as;
        goto ret0;  // no digits found
    case S6:
        s--;        // back over +-
    case S5:
        s--;        // back over e
        break;
    }
    if(aas != nil)
        *aas = s;

    if(flag & Fdpoint)
    while(na > 0 && a[na-1] == '0')
        na--;
    if(na == 0)
        goto ret0;  // zero
    a[na] = 0;
    if(!(flag & Fdpoint))
        dp = na;
    if(flag & Fesign)
        ex = -ex;
    dp += ex;
    if(dp < -Maxe-Nmant/3)  /* actually -Nmant*log(2)/log(10), but Nmant/3 close enough */
        goto ret0;  // underflow by exp
    else
    if(dp > +Maxe)
        goto retinf;    // overflow by exp

    /*
     * normalize the decimal ascii number
     * to range .[5-9][0-9]* e0
     */
    bp = 0;     // binary exponent
    while(dp > 0)
        divascii(a, &na, &dp, &bp);
    while(dp < 0 || a[0] < '5')
        mulascii(a, &na, &dp, &bp);
    a[na] = 0;

    /*
     * very small numbers are represented using
     * bp = -Bias+1.  adjust accordingly.
     */
    if(bp < -Bias+1){
        ona = na;
        divby(a, &na, -bp-Bias+1);
        if(na < ona){
            memmove(a+ona-na, a, na);
            memset(a, '0', ona-na);
            na = ona;
        }
        a[na] = 0;
        bp = -Bias+1;
    }

    /* close approx by naive conversion */
    num = 0;
    den = 1;
    for(i=0; i<9 && (c=a[i]); i++) {
        num = num*10 + (c-'0');
        den *= 10;
    }
    low[0] = umuldiv(num, One, den);
    hig[0] = umuldiv(num+1, One, den);
    for(i=1; i<Prec; i++) {
        low[i] = 0;
        hig[i] = One-1;
    }

    /* binary search for closest mantissa */
    for(;;) {
        /* mid = (hig + low) / 2 */
        c = 0;
        for(i=0; i<Prec; i++) {
            mid[i] = hig[i] + low[i];
            if(c)
                mid[i] += One;
            c = mid[i] & 1;
            mid[i] >>= 1;
        }
        frnorm(mid);

        /* compare */
        c = fpcmp(a, mid);
        if(c > 0) {
            c = 1;
            for(i=0; i<Prec; i++)
                if(low[i] != mid[i]) {
                    c = 0;
                    low[i] = mid[i];
                }
            if(c)
                break;  // between mid and hig
            continue;
        }
        if(c < 0) {
            for(i=0; i<Prec; i++)
                hig[i] = mid[i];
            continue;
        }

        /* only hard part is if even/odd roundings wants to go up */
        c = mid[Prec-1] & (Sigbit-1);
        if(c == Sigbit/2 && (mid[Prec-1]&Sigbit) == 0)
            mid[Prec-1] -= c;
        break;  // exactly mid
    }

    /* normal rounding applies */
    c = mid[Prec-1] & (Sigbit-1);
    mid[Prec-1] -= c;
    if(c >= Sigbit/2) {
        mid[Prec-1] += Sigbit;
        frnorm(mid);
    }
    d = 0;
    for(i=0; i<Prec; i++)
        d = d*One + mid[i];
    if(flag & Fsign)
        d = -d;
    d = ldexp(d, bp - Prec*Nbits);
    return d;

ret0:
    return 0;

retnan:
    return NaN();

retinf:
    if(flag & Fsign)
        return Inf(-1);
    return Inf(+1);
}
@


<<enum _anon_ (port/strtod.c)>>=
/*
 * This routine will convert to arbitrary precision
 * floating point entirely in multi-precision fixed.
 * The answer is the closest floating point number to
 * the given decimal number. Exactly half way are
 * rounded ala ieee rules.
 * Method is to scale input decimal between .500 and .999...
 * with external power of 2, then binary search for the
 * closest mantissa to this decimal number.
 * Nmant is is the required precision. (53 for ieee dp)
 * Nbits is the max number of bits/word. (must be <= 28)
 * Prec is calculated - the number of words of fixed mantissa.
 */
enum
{
    Nbits   = 28,               // bits safely represented in a ulong
    Nmant   = 53,               // bits of precision required
    Bias        = 1022,
    Prec    = (Nmant+Nbits+1)/Nbits,    // words of Nbits each to represent mantissa
    Sigbit  = 1<<(Prec*Nbits-Nmant),    // first significant bit of Prec-th word
    Ndig    = 1500,
    One = (ulong)(1<<Nbits),
    Half    = (ulong)(One>>1),
    Maxe    = 310,
    Fsign   = 1<<0,     // found -
    Fesign  = 1<<1,     // found e-
    Fdpoint = 1<<2,     // found .

    S0  = 0,        // _        _S0 +S1 #S2 .S3
    S1,         // _+       #S2 .S3
    S2,         // _+#      #S2 .S4 eS5
    S3,         // _+.      #S4
    S4,         // _+#.#    #S4 eS5
    S5,         // _+#.#e   +S6 #S7
    S6,         // _+#.#e+  #S7
    S7,         // _+#.#e+# #S7
};
@
% >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >>

<<struct Tab>>=
struct  Tab
{
    int bp;
    int siz;
    char*   cmp;
};
@


<<function frnorm>>=
static void
frnorm(ulong *f)
{
    int i, c;

    c = 0;
    for(i=Prec-1; i>0; i--) {
        f[i] += c;
        c = f[i] >> Nbits;
        f[i] &= One-1;
    }
    f[0] += c;
}
@

<<function fpcmp>>=
static int
fpcmp(char *a, ulong* f)
{
    ulong tf[Prec];
    int i, d, c;

    for(i=0; i<Prec; i++)
        tf[i] = f[i];

    for(;;) {
        /* tf *= 10 */
        for(i=0; i<Prec; i++)
            tf[i] = tf[i]*10;
        frnorm(tf);
        d = (tf[0] >> Nbits) + '0';
        tf[0] &= One-1;

        /* compare next digit */
        c = *a;
        if(c == 0) {
            if('0' < d)
                return -1;
            if(tf[0] != 0)
                goto cont;
            for(i=1; i<Prec; i++)
                if(tf[i] != 0)
                    goto cont;
            return 0;
        }
        if(c > d)
            return +1;
        if(c < d)
            return -1;
        a++;
    cont:;
    }
}
@



<<function _divby>>=
static void
_divby(char *a, int *na, int b)
{
    int n, c;
    char *p;

    p = a;
    n = 0;
    while(n>>b == 0) {
        c = *a++;
        if(c == 0) {
            while(n) {
                c = n*10;
                if(c>>b)
                    break;
                n = c;
            }
            goto xx;
        }
        n = n*10 + c-'0';
        (*na)--;
    }
    for(;;) {
        c = n>>b;
        n -= c<<b;
        *p++ = c + '0';
        c = *a++;
        if(c == 0)
            break;
        n = n*10 + c-'0';
    }
    (*na)++;
xx:
    while(n) {
        n = n*10;
        c = n>>b;
        n -= c<<b;
        *p++ = c + '0';
        (*na)++;
    }
    *p = 0;
}
@

<<function divby>>=
static void
divby(char *a, int *na, int b)
{
    while(b > 9){
        _divby(a, na, 9);
        a[*na] = 0;
        b -= 9;
    }
    if(b > 0)
        _divby(a, na, b);
}
@

<<global tab1>>=
static  Tab tab1[] =
{
     1,  0, "",
     3,  1, "7",
     6,  2, "63",
     9,  3, "511",
    13,  4, "8191",
    16,  5, "65535",
    19,  6, "524287",
    23,  7, "8388607",
    26,  8, "67108863",
    27,  9, "134217727",
};
@

<<function divascii>>=
static void
divascii(char *a, int *na, int *dp, int *bp)
{
    int b, d;
    Tab *t;

    d = *dp;
    if(d >= nelem(tab1))
        d = nelem(tab1)-1;
    t = tab1 + d;
    b = t->bp;
    if(memcmp(a, t->cmp, t->siz) > 0)
        d--;
    *dp -= d;
    *bp += b;
    divby(a, na, b);
}
@

<<function mulby>>=
static void
mulby(char *a, char *p, char *q, int b)
{
    int n, c;

    n = 0;
    *p = 0;
    for(;;) {
        q--;
        if(q < a)
            break;
        c = *q - '0';
        c = (c<<b) + n;
        n = c/10;
        c -= n*10;
        p--;
        *p = c + '0';
    }
    while(n) {
        c = n;
        n = c/10;
        c -= n*10;
        p--;
        *p = c + '0';
    }
}
@

<<global tab2>>=
static  Tab tab2[] =
{
     1,  1, "",             // dp = 0-0
     3,  3, "125",
     6,  5, "15625",
     9,  7, "1953125",
    13, 10, "1220703125",
    16, 12, "152587890625",
    19, 14, "19073486328125",
    23, 17, "11920928955078125",
    26, 19, "1490116119384765625",
    27, 19, "7450580596923828125",      // dp 8-9
};
@

<<function mulascii>>=
static void
mulascii(char *a, int *na, int *dp, int *bp)
{
    char *p;
    int d, b;
    Tab *t;

    d = -*dp;
    if(d >= nelem(tab2))
        d = nelem(tab2)-1;
    t = tab2 + d;
    b = t->bp;
    if(memcmp(a, t->cmp, t->siz) < 0)
        d--;
    p = a + *na;
    *bp -= b;
    *dp += d;
    *na += d;
    mulby(a, p+d, p, b);
}
@

<<function xcmp>>=
static int
xcmp(char *a, char *b)
{
    int c1, c2;

    while(c1 = *b++) {
        c2 = *a++;
        if(isupper(c2))
            c2 = tolower(c2);
        if(c1 != c2)
            return 1;
    }
    return 0;
}
@



\section{Trigonometry}

\section{Logarithms and exponentials}


\section{Random numbers}
% see also Cryptography section later


\chapter{Error Management}

<<constant ERRMAX>>=
#define	ERRMAX	128	/* max length of error string */
@

\section{syscall: [[errstr()]]}

<<function rerrstr>>=
void
rerrstr(char *buf, uint nbuf)
{
    char tmp[ERRMAX];

    tmp[0] = 0;
    errstr(tmp, sizeof tmp);
    utfecpy(buf, buf+nbuf, tmp);
    errstr(tmp, sizeof tmp);
}
@

<<function werrstr>>=
void
werrstr(char *fmt, ...)
{
    va_list arg;
    char buf[ERRMAX];

    va_start(arg, fmt);
    vseprint(buf, buf+ERRMAX, fmt, arg);
    va_end(arg);
    errstr(buf, ERRMAX);
}
@


\section{[[perror()]]}

% perror? errno

<<function perror>>=
void
perror(char *s)
{
    char buf[ERRMAX];

    buf[0] = '\0';
    errstr(buf, sizeof buf);
    if(s && *s)
        fprint(2, "%s: %s\n", s, buf);
    else
        fprint(2, "%s\n", buf);
}
@

\section{Error return values}

<<type errorxxx>>=
// later: unify all of that to be more consistent!
typedef int error0; // 0 is the error value
typedef int error1; // 1 is the error value
typedef int errorneg1; // -1 is the error value
typedef int errorn; // 1 or more means error
@
%pad: I added that

<<constant OKxxx>>=
#define OK_0 0
#define OK_1 1
@
%pad: I added that

<<constant ERRORxxx>>=
#define ERROR_0 0
#define ERROR_1 1
#define ERROR_NEG1 (-1)
@
%pad: I added that

\section{[[assert()]]}

<<macro assert>>=
#define assert(x)   do{ if(x) {} else _assert("x"); }while(0)
@
% note that use x inside a string so implicity strinfify in plan9 cpp
% (see Compiler.nw)


<<global _assert>>=
void (*_assert)(char*) = default_assert;
@

<<function default_assert>>=
void
default_assert(char *s)
{
    if(__assert)
        (*__assert)(s);
    fprint(2, "assert failed: %s\n", s);
    abort();
}
@

<<global __assert>>=
void (*__assert)(char*);
@
% used by libthread to point to _theadassert that does ???



<<function abort>>=
void
abort(void)
{
    while(*(int*)0)
        ;
}
@
% generate segfault


\section{[[sysfatal()]]}

<<function sysfatal>>=
void
sysfatal(char *fmt, ...)
{
    va_list arg;

    va_start(arg, fmt);
    (*_sysfatal)(fmt, arg);
    va_end(arg);
}
@


<<global _sysfatal>>=
void (*_sysfatal)(char *fmt, va_list arg) = _sysfatalimpl;
@
% who changes that?

<<function _sysfatalimpl>>=
static void
_sysfatalimpl(char *fmt, va_list arg)
{
    char buf[1024];

    vseprint(buf, buf+sizeof(buf), fmt, arg);
    if(argv0)
        fprint(2, "%s: %s\n", argv0, buf);
    else
        fprint(2, "%s\n", buf);
    exits(buf);
}
@


\chapter{Debugging Support}

% Seen some debugging support before, for memory pool.

\section{Logging}

<<function syslog>>=
/*
 * Print
 *  sysname: time: mesg
 * on /sys/log/logname.
 * If cons or log file can't be opened, print on the system console, too.
 */
void
syslog(int cons, char *logname, char *fmt, ...)
{
    char buf[1024];
    char *ctim, *p;
    va_list arg;
    int n;
    Dir *d;
    char err[ERRMAX];

    err[0] = '\0';
    errstr(err, sizeof err);
    lock(&sl);

    /*
     *  paranoia makes us stat to make sure a fork+close
     *  hasn't broken our fd's
     */
    d = dirfstat(sl.fd);
    if(sl.fd < 0 || sl.name == nil || strcmp(sl.name, logname) != 0 ||
       !eqdirdev(d, sl.d)){
        free(sl.name);
        sl.name = strdup(logname);
        if(sl.name == nil)
            cons = 1;
        else{
            free(sl.d);
            sl.d = nil;
            _syslogopen();
            if(sl.fd < 0)
                cons = 1;
            else
                sl.d = dirfstat(sl.fd);
        }
    }
    free(d);
    if(cons){
        d = dirfstat(sl.consfd);
        if(sl.consfd < 0 || !eqdirdev(d, sl.consd)){
            free(sl.consd);
            sl.consd = nil;
            sl.consfd = open("#c/cons", OWRITE|OCEXEC);
            if(sl.consfd >= 0)
                sl.consd = dirfstat(sl.consfd);
        }
        free(d);
    }

    if(fmt == nil){
        unlock(&sl);
        return;
    }

    ctim = ctime(time(0));
    p = buf + snprint(buf, sizeof(buf)-1, "%s ", sysname());
    strncpy(p, ctim+4, 15);
    p += 15;
    *p++ = ' ';
    errstr(err, sizeof err);
    va_start(arg, fmt);
    p = vseprint(p, buf+sizeof(buf)-1, fmt, arg);
    va_end(arg);
    *p++ = '\n';
    n = p - buf;

    if(sl.fd >= 0){
        seek(sl.fd, 0, 2);
        write(sl.fd, buf, n);
    }

    if(cons && sl.consfd >=0)
        write(sl.consfd, buf, n);

    unlock(&sl);
}
@


<<global sl>>=
static struct
{
    int fd;
    int consfd;
    char    *name;
    Dir *d;
    Dir *consd;
    Lock;
} sl =
{
    -1, -1,
};
@

<<function _syslogopen>>=
static void
_syslogopen(void)
{
    char buf[1024];

    if(sl.fd >= 0)
        close(sl.fd);
    snprint(buf, sizeof(buf), "/sys/log/%s", sl.name);
    sl.fd = open(buf, OWRITE|OCEXEC);
}
@

<<function eqdirdev>>=
static int
eqdirdev(Dir *a, Dir *b)
{
    return a != nil && b != nil &&
        a->dev == b->dev && a->type == b->type &&
        a->qid.path == b->qid.path;
}
@

\chapter{Profiling Support}

% arm/main9p.s

<<type Prof>>=
enum Prof {
    Profoff,        /* No profiling */

    Profuser,       /* Measure user time only (default) */
    Profkernel,     /* Measure user + kernel time */
    Proftime,       /* Measure total time */
    Profsample,     /* Use clock interrupt to sample (default when there is no cycle counter) */
}; /* what */
@

<<struct Plink>>=
struct  Plink
{
    Plink   *old;
    Plink   *down;
    Plink   *link;
    long    pc;
    long    count;
    vlong time;
};
@


<<function prof>>=
void
prof(void (*fn)(void*), void *arg, int entries, int what)
{
    _profinit(entries, what);
    _tos->prof.pp = _tos->prof.next;
    fn(arg);
    _profdump();
}
@




<<global khz>>=
static  ulong   khz;
@

<<global perr>>=
static  ulong   perr;
@

<<global havecycles>>=
static  int havecycles;
@

\section{[[_profin()]]}
% see \book{Linker}

% pragma profile turned off for those functins
<<function _profin>>=
// Called at every procedure entry when use 5l -p, see Linker.nw
ulong
_profin(void)
{
    void *dummy;
    long pc;
    Plink *pp, *p;
    ulong arg;
    vlong t;

    arg = _savearg();
    pc = _callpc(&dummy);
    pp = _tos->prof.pp;
    if(pp == 0 || (_tos->prof.pid && _tos->pid != _tos->prof.pid))
        return arg;

    for(p=pp->down; p; p=p->link)
        if(p->pc == pc)
            goto out;
    p = _tos->prof.next + 1;
    if(p >= _tos->prof.last) {
        _tos->prof.pp = 0;
        perr++;
        return arg;
    }
    _tos->prof.next = p;
    p->link = pp->down;
    pp->down = p;
    p->pc = pc;
    p->old = pp;
    p->down = 0;
    p->count = 0;
    p->time = 0LL;

out:
    _tos->prof.pp = p;
    p->count++;
    switch(_tos->prof.what){
    case Profkernel:
        p->time = p->time - _tos->pcycles;
        goto proftime;
    case Profuser:
        /* Add kernel cycles on proc entry */
        p->time = p->time + _tos->kcycles;
        /* fall through */
    case Proftime:  
    proftime:       /* Subtract cycle counter on proc entry */
        cycles((uvlong*)&t);
        p->time = p->time - t;
        break;
    case Profsample:
        p->time = p->time - _tos->clock;
        break;
    }
    return arg;     /* disgusting linkage */
}
@

\section{[[_profout()]]}

<<function _profout>>=
// Called at every procedure return when use 5l -p, see Linker.nw
ulong
_profout(void)
{
    Plink *p;
    ulong arg;
    vlong t;

    arg = _savearg();
    p = _tos->prof.pp;
    if (p == nil || (_tos->prof.pid != 0 && _tos->pid != _tos->prof.pid))
        return arg; /* Not our process */
    switch(_tos->prof.what){
    case Profkernel:        /* Add proc cycles on proc entry */
        p->time = p->time + _tos->pcycles;
        goto proftime;
    case Profuser:          /* Subtract kernel cycles on proc entry */
        p->time = p->time - _tos->kcycles;
        /* fall through */
    case Proftime:  
    proftime:               /* Add cycle counter on proc entry */
        cycles((uvlong*)&t);
        p->time = p->time + t;
        break;
    case Profsample:
        p->time = p->time + _tos->clock;
        break;
    }
    _tos->prof.pp = p->old;
    return arg;
}
@

\section{[[cputime()]]}

% in 9sys/
<<constant HZ>>=
#define HZ  1000
@

<<function cputime>>=
double
cputime(void)
{
    long t[4];
    int i;

    times(t);
    for(i=1; i<4; i++)
        t[0] += t[i];
    return t[0] / (double)HZ;
}
@


\chapter{Security}

<<function getuser>>=
char *
getuser(void)
{
    static char user[64];
    int fd;
    int n;

    fd = open("/dev/user", OREAD);
    if(fd < 0)
        return "none";
    n = read(fd, user, (sizeof user)-1);
    close(fd);
    if(n <= 0)
        strcpy(user, "none");
    else
        user[n] = 0;
    return user;
}
@


\section{Cryptography}



\chapter{Advanced Topics}

% Seen advanced topics before, for memory pool, thread and channels
% in their respective chapters.

\section{Arbitrary precision arithmetics}

<<type mpdigit>>=
typedef unsigned int    mpdigit;    /* for /sys/include/mp.h */
@

\section{IO chunks}

<<type IOchunk>>=
struct IOchunk {
 void	*addr;
 ulong	len;
};
@



\chapter{Conclusion}





\appendix

\chapter{Extra Code}

\ifallcode
#include "Libcore_extra.nw"
#include "Libcore_big.nw"
\fi

%\chapter{Changelog}
%\label{sec:changelog}

\chapter*{Glossary}
\label{sec:glossary}
\addcontentsline{toc}{chapter}{Glossary}

\begin{verbatim}
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{chapter}{Index}

%\chapter{References} 
\addcontentsline{toc}{chapter}{References}

\bibliography{../docs/latex/Principia}
\bibliographystyle{alpha}


%******************************************************************************
% Postlude
%******************************************************************************

\end{document}

