\documentclass[twocolumn, landscape]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse % see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things:
% - ??

%thx to codemap/codegraph/scheck:
% - TODO use cg to reduce backward deps, introduce globals.c, utils.c,
%   (harder to understand non layered code)
% - TODO use scheck to remove deadcode, dead prototypes, useless export
%   or mv as forward decl
%   (harder to understand big interface files)
% - TODO use cg to reduce number of globals by moving them closer to the
%   relevant file (or even function), better cluster the code
%   (harder to understand non functional code using lots of globals)

%thx to this manual, better understand XXX?:

%history LP-ization:
% - skeleton, mostly copy paste of Template.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * TODO ctor/dtor, dumper
%    * TODO [[xxx]] other fields, [[xxx]] extra fields
% - TODO read Extra section, identify concepts, first TOC
% - TODO distribute parts of the Extra section in the main file
% - TODO understand main(), LP split main, improve TOC
% - TODO understand main functions, LP split, cluster, improve TOC
% - TODO LP split the structures, use datalog for flow to field info
% - TODO nullify, boolify, errorify, enumify,  typeify,    scheckify, plan9ify
% - TODO aspecify advanced features! remove useless features
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% ifallcode is used for:
%  - forward decl, func decl, extern decl, #ifdef, pragmas (stuff in Extra.nw)
%  - ??

\addtolength{\topmargin}{-.850in}
\addtolength{\textheight}{1.70in}


\begin{document}
%******************************************************************************
% Title
%******************************************************************************
\title{
{\Huge 
Principia Softwarica: The Plan9 Core Libraries
}\\
{version 0.1}
}
% ARM edition? for very few code so maybe not that needed to put in title?

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}
}

\maketitle 
\onecolumn
\hrule
\input{../docs/latex/Copyright}
\input{../docs/latex/CopyrightPlan9}
\hrule
\twocolumn


\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\tableofcontents
\endgroup

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

The goal of this book is to present in full details the source code of
a few {core libraries}.

\section{Motivations}

Why core libraries? Because we think you are a better programmer if
you fully understand how things work under the hood.
% and code in those libs underly everything.

Here are a few questions we hope this book will answer:
\begin{itemize}
\item Which software does memory allocation? The kernel?
The C library? How [[malloc()]] is implemented? How it
relates to the [[sbrk()]] system call?

\item How a thread scheduler works? How [[alt()]] is implemented
without [[select()]] in the kernel?

\end{itemize}

\section{\plan [[libc]], [[libthread]], [[libregexp]]}

% gonna present core libs of plan9, its libc of course, 
% but also its thread libraries,
% regexp, memory managment, unicode, etc.
% most of the generally useful and generic building blocks for regular
% applications!
%see soft archi in Principia and all the boxes for the libc

\section{Other core libraries}

Here are a few core libraries that were considered for this book but
which were ultimately discarded:
\begin{itemize}
\item glibc
% huge, can't be linked statically

\item dietlibc

\item microlibc

\end{itemize}

%other:
%#other libc
% - libc in dev86
%#other core libs
% - windows foundation in .NET?
% - Core in MacOSX? 
% - libcii, from Hanson book
% - kencc/libmach/ is using netlib/fdlibm

% musl?
% https://gist.github.com/cl91/bb927df2525738502131#file-static-linking-against-musl-md

\section{Getting started}

% to cross compiler libc for another archi:
% objtype=arm
% mk

\section{Requirements}

% see intro(2), overview of many libs
% (just like intro(1) is overview of utilities)

\section{About this document}
#include "../docs/latex/About.nw"

\section{Copyright}

Most of this document is actually source code from Plan9, so
those parts are copyright by Lucent Technologies Inc.
The prose is mine and is licensed under the GNU Free Documentation
License.

\section{Acknowledgments}


\chapter{Overview}

%TODO: errno
%    if(getwd(pathname, sizeof(pathname)) == 0) {
%        fprint(2, "pwd: %r\n");
%        exits("getwd");
%    }
% what is %r? last error code from libc function? a bit ugly
% those == 0 are also ugly.

\section{Core libraries principles}
% syscall!
% each chapter has first section syscall and then build utilities
%  on top of it
%missing syscalls not covered yet: exec, dup, fversion, fauth


\section{Code organization}


\section{Software architecture}

% note that libc should be thread-safe, malloc use locks!

% take common.ml structure for the TOC of this document?

\section{Book structure}

%###############################################################################

\chapter{Core Types and Data Structures}

% void

% basic types, bool pad's addon!

% pointer, void*!

% string, see special chapter

% collection types (not really :( ) but
% can provide template on how they encode lists, hashs, queues,
% double linked lists, trees, etc. See kernel.nw for instance,
% many example of collections.


\chapter{[[_main()]]}

%related: minimal C runtime for Linux
%https://github.com/lpsantil/rt0
%https://blogs.oracle.com/ksplice/entry/hello_from_a_libc_free

\chapter{User/Kernel Bridge}

\chapter{Memory Area Operations}

\chapter{Memory Managment}

% http://jamesgolick.com/2013/5/15/memory-allocators-101.html
% http://jamesgolick.com/2013/5/19/how-tcmalloc-works.html

% http://danluu.com/malloc-tutorial/

%http://blog.httrack.com/blog/2014/04/05/a-story-of-realloc-and-laziness/

%http://bitsquid.blogspot.com/2015/08/allocation-adventures-3-buddy-allocator.html

\section{Syscall, [[brk()]]}
% sysbrk()


\section{[[malloc()]]}

\section{[[free()]]}

\chapter{Strings}

%todo: rename strcmp, or at least have
% a string_equal, and most of the time rewrite
% strncmp as !string_equal, far more readable.
% look at go or rust stdlibs

\section{Conversions}

\section{Formatted Output}
% Fmt

% printf
%https://github.com/wkoszek/mini_printf

\section{Unicode}

%see utf.ps

\chapter{IO}

% file descriptor

\section{Syscalls, [[open()]], [[read()]], etc}

% sysopen(), sysclose(), sysread(), syswrite(), sysseek(), etc
% file, directory, namespace

\chapter{Directory}

\section{Syscalls, [[create()]], [[chdir()]], etc}

\chapter{Namespace}

\section{Syscalls, [[bind()]], [[mount()]], etc}

\chapter{Time}

\section{Syscalls, [[sleep()]], [[alarm()]], etc}

\chapter{Network}

\chapter{Concurrency}

\section{Syscalls, [[rfork()]], [[await()]], [[rendezvous()]], etc}

% sysfork(), sysexit(), sysawait(), sysexec()
% want to run external command? need fork+exec! classic pattern.

% plan9 has shared memory processes. rfork(RFMEM)
% has then locking function to coordinate. qlock, lock, etc.
% has also a few syscalls like rendezvous!

% see also thread chapter, that build on top of this to
% provide more convenient abstractions (channels, alt(), cooperative
% threads with less needs for locking, etc)

% see lock(2), rendezvous(2)
% sleep/wakeup

\chapter{IPC}

\section{Syscalls, [[pipe()]], [[notify()]], [[segattach()]]}

\chapter{Channels and Cooperative Threads}
% should be a last chapter, but put here for now

\section{Overview}

% thread OS vs thread lib OS! already have "threads" rfork with shared memory!
% see http://swtch.com/~rsc/thread/
% plan9 libthread model is based on Alef. Procs in terminology
% below are actually shared
% memory processes, and threads cooperatively scheduled coroutines.
% different than what most people agrees about threads/

% Why need that? why system threads not enough? not convenient enough?
% green threads vs system threads, a classic.
% Having cooperative threads simplify lots of things, no race, less
% need for locks! Other reasons? (xleroy did the same)

% alternatives? posix threads? xleroy thread lib? new thread linux lib?
% other forms of concurrency? erlang model? see 7 concurrency in 7 weeks?

% see thread(2), definitive reference. maybe see alef article
% for design discussions. See acme and rio articles/slides for
% examples of use and discussions too.
% see ioproc(2), and lock(2)
% see rendezvous(2)

\subsection{Code organization}

%include/thread.h: public API
%threadimpl.h: private DS

%ref.c: atomic counter (could be in libc.h)
%xincarm.c
%xincport.h

%globals.c: globals
%debug.c: debugging support (threadebug(), threadassert())

%lib.c: threadmalloc wrapper, threadsysfatal()
%386.c: thread stack initialization arch specific managment

%create.c: create/free process/threads
%id.c: thread identification
%sched.c: the thread scheduler

%note.c: thread-aware notes
%exit.c: thread-aware exits
%exec.c: thread-aware exec

%rendez.c: rendez vous API for the threads
%kill.c: thread killing each other
%channel.c:

%chanprint.c

%ioproc.c: IO proc creation/deletion and handler (xioproc)
%iocall.c: the io proc helper bridge for all the syscalls below

%ioxxx.c: 
% (ioopen.c, %ioclose.c, %ioread.c, %iowrite.c, %ioreadn.c, %iosleep.c)

%dial.c: thread friendly version of network dial
%iodial.c


%main.c: !!!

\subsection{Architecture overview}

% _xxx = private

\section{A toy example}

% lib_thread/tests/!! example.c! include early

\section{Core data structures}

\subsection{Concurrency buiding blocks}

<<struct Ref>>=
struct Ref {
    long	ref;
};
@

<<function incref>>=
void
incref(Ref *r)
{
    ainc(&r->ref);
}
@

<<function decref>>=
long
decref(Ref *r)
{
    return adec(&r->ref);
}
@


<<global xincport_lock>>=
static Lock xincport_lock;
@

<<function _xinc>>=
void
_xinc(long *p)
{

    lock(&xincport_lock);
    (*p)++;
    unlock(&xincport_lock);
}
@
% who calls _xinc?? ainc?

<<function _xdec>>=
long
_xdec(long *p)
{
    long r;

    lock(&xincport_lock);
    r = --(*p);
    unlock(&xincport_lock);
    return r;
}
@




% see Lock, QLock, Rendez!! 
% see also lock(); unlock() functions in libc.h

% can produce producer/consumer synchronization queue
% with lock and rendezvous (kind of condition variables)

\subsection{[[Channel]]}
% public API!

%A Channel is a buffered or unbuffered queue for fixed size messages
% Procs and threads send messages into the channel and recv messages 
% from the channel

% so really a form of generalized producer/consumer queue!
% an effective and general concurrency mechanism

<<struct Channel>>=
/*
 * Channel structure.  s is the size of the buffer.  For unbuffered channels
 * s is zero.  v is an array of s values.  If s is zero, v is unused.
 * f and n represent the state of the queue pointed to by v.
 */
struct Channel {
    int	s;		/* Size of the channel (may be zero) */

    uint	f;		/* Extraction point (insertion pt: (f+n) % s) */
    uint	n;		/* Number of values in the channel */
    int	e;		/* Element size */
    int	freed;		/* Set when channel is being deleted */

    volatile Alt **qentry;	/* Receivers/senders waiting (malloc) */
    volatile int nentry;	/* # of entries malloc-ed */
    volatile int closed;	/* channel is closed */

    // must be at the end of the struct! 
    uchar	v[1];		/* Array of s values in the channel */
};
@
% no Lock?
% volatile?

<<function chancreate>>=
Channel*
chancreate(int elemsize, int elemcnt)
{
    Channel *c;

    if(elemcnt < 0 || elemsize <= 0)
        return nil;
    c = _threadmalloc(sizeof(Channel)+elemsize*elemcnt, 1);
    c->e = elemsize;
    c->s = elemcnt;
    _threaddebug(DBGCHAN, "chancreate %p", c);
    return c;
}
@

% have to be called by user? could do that in chancreate no?
<<function chaninit>>=
int
chaninit(Channel *c, int elemsize, int elemcnt)
{
    if(elemcnt < 0 || elemsize <= 0 || c == nil)
        return -1;
    c->f = 0;
    c->n = 0;
    c->closed = 0;
    c->freed = 0;
    c->e = elemsize;
    c->s = elemcnt;
    _threaddebug(DBGCHAN, "chaninit %p", c);
    return 1;
}
@


<<function chanfree>>=
void
chanfree(Channel *c)
{
    lock(&chanlock);
    _chanfree(c);
    unlock(&chanlock);
}
@


<<function _chanfree>>=
static void
_chanfree(Channel *c)
{
    int i, inuse;

    if(c->closed == 1)			/* chanclose is ongoing */
        inuse = 1;
    else{
        inuse = 0;
        for(i = 0; i < c->nentry; i++)	/* alt ongoing */
            if(c->qentry[i])
                inuse = 1;
    }
    if(inuse)
        c->freed = 1;
    else{
        if(c->qentry)
            free(c->qentry);
        free(c);
    }
}
@




<<enum _anon_ (lib_core/libthread/channel.c)>>=
/* Value to indicate the channel is closed */
enum {
    CHANCLOSD = 0xc105ed,
};
@
<<constant Closed>>=
#define Closed	((void*)CHANCLOSD)
@

<<global chanlock>>=
static Lock chanlock;		/* central channel access lock */
@





% public API
<<function chanclose>>=
int
chanclose(Channel *c)
{
    Alt *a;
    int i, s;

    s = _procsplhi();	/* note handlers; see :/^alt */
    lock(&chanlock);
    if(c->closed){
        /* Already close; we fail but it's ok. don't print */
        unlock(&chanlock);
        _procsplx(s);
        return -1;
    }
    c->closed = 1;		/* Being closed */
    /*
     * Locate entries that will fail due to close
     * (send, and receive if nothing buffered) and wake them up.
     * the situation cannot change because all queries
     * should be committed by now and new ones will find the channel
     * closed.  We still need to take the lock during the iteration
     * because we can wake threads on qentrys we have not seen yet
     * as in alt and there would be a race in the access to *a.
     */
    for(i = 0; i < c->nentry; i++){
        if((a = c->qentry[i]) == nil || *a->tag != nil)
            continue;

        if(a->op != CHANSND && (a->op != CHANRCV || c->n != 0))
            continue;
        *a->tag = c;
        unlock(&chanlock);
        _procsplx(s);
        while(_threadrendezvous(a->tag, Closed) == Intred)
            ;
        s = _procsplhi();
        lock(&chanlock);
    }

    c->closed = 2;		/* Fully closed */
    if(c->freed)
        _chanfree(c);
    unlock(&chanlock);
    _procsplx(s);
    return 0;
}
@

<<function chanclosing>>=
int
chanclosing(Channel *c)
{
    int n, s;

    s = _procsplhi();	/* note handlers; see :/^alt */
    lock(&chanlock);
    if(c->closed == 0)
        n = -1;
    else
        n = c->n;
    unlock(&chanlock);
    _procsplx(s);
    return n;
}
@

%/*
% * superseded by chanclosing
%int
%chanisclosed(Channel *c)
%{
%    return chanisclosing(c) >= 0;
%}
% */





\subsection{[[Proc]] and [[Pqueue]]}

% cooperative scheduler building blocks = coroutines = setjmp()!
% (actually the kernel does the same)

<<struct Proc>>=
struct Proc
{
    int		pid;			/* process id */

    jmp_buf	sched;			/* for context switches */

    Thread	*thread;		/* running thread */




    int		splhi;			/* delay notes */

    int		needexec;
    Execargs	exec;			/* exec argument */
    Proc	*newproc;		/* fork argument */
    char	exitstr[ERRMAX];	/* exit status */

    int		rforkflag;

    Tqueue	threads;		/* All threads of this proc */
    int		nthreads;

    Tqueue	ready;			/* Runnable threads */
    Lock	readylock;

    char	printbuf[Printsize];
    int		blocked;		/* In a rendezvous */
    int		pending;		/* delayed note pending */
    int		nonotes;		/* delay notes */
    uint	nextID;			/* ID of most recently created thread */


    void	*arg;			/* passed between shared and unshared stk */
    char	str[ERRMAX];		/* used by threadexits to avoid malloc */

    void*	wdata;			/* Lib(worker) per-proc data pointer */
    void*	udata;			/* User per-proc data pointer */
    char	threadint;		/* tag for threadexitsall() */

    // Extra
    Proc	*next;			/* linked list of Procs */

    Lock	lock;
};
@

% jmp_buf is in u.h and is just long[2] (sp, pc) for x86

<<constant Printsize>>=
Printsize = 2048,
@


% shared memory, but need also per process private memory.
% how? stack? each process has its own stack normally.


<<global procp>>=
// used to be in main.c
static Proc **procp;
@
% set in threadsysinit(), privalloc()

<<function _threadgetproc>>=
Proc*
_threadgetproc(void)
{
    return *procp;
}
@

<<function _threadsetproc>>=
void
_threadsetproc(Proc *p)
{
    *procp = p;
}
@





% all processes, all threads?
<<global _threadpq>>=
// used to be in create.c
Pqueue _threadpq;
@
% it's not a pointer! so it should be set to nil by default

<<struct Pqueue>>=
struct Pqueue {		/* Proc queue */
    Proc		*head;
    Proc		**tail;

    // Extra
    Lock		lock;
};
@



<<function _newproc>>=
/*
 * Create and initialize a new Proc structure with a single Thread
 * running inside it.  Add the Proc to the global process list.
 */
Proc*
_newproc(void (*f)(void *arg), void *arg, uint stacksize, char *name, int grp, int rforkflag)
{
    Proc *p;

    p = _threadmalloc(sizeof *p, 1);
    p->pid = -1;
    p->rforkflag = rforkflag;
    newthread(p, f, arg, stacksize, name, grp);

    lock(&_threadpq.lock);
    if(_threadpq.head == nil)
        _threadpq.head = p;
    else
        *_threadpq.tail = p;
    _threadpq.tail = &p->next;
    unlock(&_threadpq.lock);

    return p;
}
@


<<function procrfork>>=
int
procrfork(void (*f)(void *), void *arg, uint stacksize, int rforkflag)
{
    Proc *p;
    int id;

    p = _threadgetproc();
    assert(p->newproc == nil);
    p->newproc = _newproc(f, arg, stacksize, nil, p->thread->grp, rforkflag);
    id = p->newproc->threads.head->id;
    _sched();
    return id;
}
@

<<function proccreate>>=
int
proccreate(void (*f)(void*), void *arg, uint stacksize)
{
    return procrfork(f, arg, stacksize, 0);
}
@


<<function _freeproc>>=
void
_freeproc(Proc *p)
{
    Thread *t, *nextt;

    for(t = p->threads.head; t; t = nextt){
        if(t->cmdname)
            free(t->cmdname);
        assert(t->stk != nil);
        free(t->stk);
        nextt = t->nextt;
        free(t);
    }
    free(p);
}
@


<<struct Execargs>>=
struct Execargs
{
    char	*prog;
    char	**args;
    int		fd[2];
};
@



\subsection{[[Thread]] and [[Tqueue]]}
% private DS, threadimpl.h


<<struct Thread>>=
struct Thread
{
    int		id;		/* thread id */
    char	*cmdname;	/* ptr to name of thread */

    jmp_buf	sched;		/* for context switches */

    Proc	*proc;		/* proc of this thread */

    uint	stksize;	/* stack size */
    uchar	*stk;		/* top of stack (lowest address of stack) */

    State	state;		/* run state */
    State	nextstate;	/* next run state */

    Chanstate	chan;		/* which channel operation is current */
    Alt		*alt;		/* pointer to current alt structure (debugging) */



    int 	grp;		/* thread group */
    int		moribund;	/* thread needs to die */

    int		ret;		/* return value for Exec, Fork */


    int		inrendez;
    Thread	*rendhash;	/* Trgrp linked list */
    void*	rendtag;	/* rendezvous tag */
    void*	rendval;	/* rendezvous value */
    int		rendbreak;	/* rendezvous has been taken */


    void*	udata[NPRIV];	/* User per-thread data pointer */

    // Extra
    Lock	lock;		/* protects thread data structure */

    Thread	*next;		/* next on ready queue */

    Thread	*nextt;		/* next on list of threads in this proc*/


};
@

% advanced topic?
<<constant NPRIV>>=
NPRIV = 8,
@






<<function threadid>>=
int
threadid(void)
{
    return _threadgetproc()->thread->id;
}
@

% newthread() -> <>
<<function nextID>>=
static int
nextID(void)
{
    static Lock l;
    static int id;
    int i;

    lock(&l);
    i = ++id;
    unlock(&l);
    return i;
}
@

% ctor
<<function newthread>>=
/*
 * Create and initialize a new Thread structure attached to a given proc.
 */
static int
newthread(Proc *p, void (*f)(void *arg), void *arg, uint stacksize, char *name, int grp)
{
    int id;
    Thread *t;

    if(stacksize < 32)
        sysfatal("bad stacksize %d", stacksize);
    t = _threadmalloc(sizeof(Thread), 1);

    t->stksize = stacksize;
    t->stk = _threadmalloc(stacksize, 0);
    memset(t->stk, 0xFE, stacksize);
    _threadinitstack(t, f, arg);

    t->grp = grp;
    if(name)
        t->cmdname = strdup(name);
    t->id = nextID();
    id = t->id;
    t->next = (Thread*)~0;
    t->proc = p;
    _threaddebug(DBGSCHED, "create thread %d.%d name %s", p->pid, t->id, name);

    lock(&p->lock);
    p->nthreads++;
    if(p->threads.head == nil)
        p->threads.head = t;
    else
        *p->threads.tail = t;
    p->threads.tail = &t->nextt;

    t->nextt = nil;
    t->state = Ready;
    _threadready(t);
    unlock(&p->lock);

    return id;
}
@

% 386.c
<<function launcher386>>=
static void
launcher386(void (*f)(void *arg), void *arg)
{
    (*f)(arg);
    threadexits(nil);
}
@

% 386.c
<<function _threadinitstack>>=
void
_threadinitstack(Thread *t, void (*f)(void*), void *arg)
{
    ulong *tos;

    tos = (ulong*)&t->stk[t->stksize&~7];
    *--tos = (ulong)arg;
    *--tos = (ulong)f;
    t->sched[JMPBUFPC] = (ulong)launcher386+JMPBUFDPC;
    t->sched[JMPBUFSP] = (ulong)tos - 8;		/* old PC and new PC */
}
@



<<function threadcreate>>=
/* 
 * Create a new thread and schedule it to run.
 * The thread grp is inherited from the currently running thread.
 */
int
threadcreate(void (*f)(void *arg), void *arg, uint stacksize)
{
    return newthread(_threadgetproc(), f, arg, stacksize, nil, threadgetgrp());
}
@


<<function _freethread>>=
void
_freethread(Thread *t)
{
    Proc *p;
    Thread **l;

    p = t->proc;
    lock(&p->lock);
    for(l=&p->threads.head; *l; l=&(*l)->nextt){
        if(*l == t){
            *l = t->nextt;
            if(*l == nil)
                p->threads.tail = l;
            break;
        }
    }
    unlock(&p->lock);
    if (t->cmdname)
        free(t->cmdname);
    assert(t->stk != nil);
    free(t->stk);
    free(t);
}
@




<<function threadpid>>=
int
threadpid(int id)
{
    int pid;
    Proc *p;
    Thread *t;

    if (id < 0)
        return -1;
    if (id == 0)
        return _threadgetproc()->pid;
    lock(&_threadpq.lock);
    for (p = _threadpq.head; p; p = p->next){
        lock(&p->lock);
        for (t = p->threads.head; t; t = t->nextt)
            if (t->id == id){
                pid = p->pid;
                unlock(&p->lock);
                unlock(&_threadpq.lock);
                return pid;
            }
        unlock(&p->lock);
    }
    unlock(&_threadpq.lock);
    return -1;
}
@



<<struct Tqueue>>=
struct Tqueue		/* Thread queue */
{
    Thread	*head;
    Thread	**tail;

    int		asleep;
};
@




<<enum state>>=
enum state
{
    Dead,
    Running,
    Ready,
    Rendezvous,
};
@
% hmm does not much psstate string array, normal??

<<enum chanstate>>=
enum chanstate
{
    Channone,
    Chansend,
    Chanrecv,
    Chanalt,
};
@



<<function threadsetname>>=
void
threadsetname(char *fmt, ...)
{
    int fd;
    char buf[128];
    va_list arg;
    Proc *p;
    Thread *t;

    p = _threadgetproc();
    t = p->thread;
    if (t->cmdname)
        free(t->cmdname);
    va_start(arg, fmt);
    t->cmdname = vsmprint(fmt, arg);
    va_end(arg);
    if(t->cmdname && p->nthreads == 1){
        snprint(buf, sizeof buf, "#p/%lud/args", _tos->pid); //getpid());
        if((fd = open(buf, OWRITE)) >= 0){
            write(fd, t->cmdname, strlen(t->cmdname)+1);
            close(fd);
        }
    }
}
@

<<function threadgetname>>=
char*
threadgetname(void)
{
    Proc *p;

    if((p = _threadgetproc()) && p->thread)
        return p->thread->cmdname;
    return nil;
}
@


\subsection{[[Alt]]}

% "Plan9 has no select call"

<<enum chanop>>=
enum chanop {
    CHANEND,

    CHANSND,
    CHANRCV,
    CHANNOP,

    CHANNOBLK,
};
@

<<struct Alt>>=
struct Alt {
    Channel	*c;		/* channel */
    void	*v;		/* pointer to value */
    ChanOp	op;		/* operation */

    char	*err;		/* did the op fail? */
    /*
     * the next variables are used internally to alt
     * they need not be initialized
     */
    Channel	**tag;		/* pointer to rendez-vous tag */
    int	entryno;	/* entry number */
};
@


\section{[[main()]]}

<<global mainp>>=
// ref<ref<Proc>
static Proc **mainp;
@
% address of ref of proc in stack

<<global _mainjmp>>=
static jmp_buf _mainjmp;
@

<<global mainstacksize>>=
int	mainstacksize;
@


<<function main>>=
void
main(int argc, char **argv)
{
    Mainarg *a;
    Proc *p;

    rfork(RFREND);
    mainp = &p;

    if(setjmp(_mainjmp))
        _schedinit(p);

    //_threaddebuglevel = (DBGSCHED|DBGCHAN|DBGREND)^~0;
    _systhreadinit();
    _qlockinit(_threadrendezvous);

    _sysfatal = _threadsysfatal;
    _dial     = _threaddial;
    __assert  = _threadassert;

    notify(_threadnote);

    if(mainstacksize == 0)
        mainstacksize = 8*1024;

    a = _threadmalloc(sizeof *a, 1);
    a->argc = argc;
    a->argv = argv;

    p = _newproc(mainlauncher, a, mainstacksize, "threadmain", 0, 0);
    _schedinit(p);

    abort();	/* not reached */
}
@


<<function _systhreadinit>>=
void
_systhreadinit(void)
{
    procp = privalloc();
}
@

<<struct Mainarg>>=
struct Mainarg
{
    int		argc;
    char	**argv;
};
@

<<function mainlauncher>>=
static void
mainlauncher(void *arg)
{
    Mainarg *a;

    a = arg;
    // user defined threadmain()!!
    threadmain(a->argc, a->argv);

    threadexits("threadmain");
}
@



\section{Threads scheduler}
% similar to Kernel Scheduling chapter

<<global _psstate>>=
static char *_psstate[] = {
    "Moribund",
    "Dead",
    "Exec",
    "Fork",
    "Running",
    "Ready",
    "Rendezvous",
};
@
% superset of enum state, normal?

<<function psstate>>=
static char*
psstate(int s)
{
    if(s < 0 || s >= nelem(_psstate))
        return "unknown";
    return _psstate[s];
}
@


<<function _schedinit>>=
void
_schedinit(void *arg)
{
    Proc *p;
    Thread *t, **l;

    p = arg;
    _threadsetproc(p);
    p->pid = _tos->pid; //getpid();

    while(setjmp(p->sched))
        ;

    _threaddebug(DBGSCHED, "top of schedinit, _threadexitsallstatus=%p", 
                 _threadexitsallstatus);
    if(_threadexitsallstatus)
        exits(_threadexitsallstatus);

    lock(&p->lock);
    t = p->thread;
    if(t != nil){
        p->thread = nil;

        if(t->moribund){
            t->state = Dead;
            for(l=&p->threads.head; *l; l=&(*l)->nextt)
                if(*l == t){
                    *l = t->nextt;
                    if(*l==nil)
                        p->threads.tail = l;
                    p->nthreads--;
                    break;
                }
            unlock(&p->lock);
            if(t->inrendez){
                _threadflagrendez(t);
                _threadbreakrendez();
            }
            free(t->stk);
            free(t->cmdname);
            free(t);	/* XXX how do we know there are no references? */
            t = nil;
            _sched();
        }
        if(p->needexec){
            t->ret = _schedexec(&p->exec);
            p->needexec = 0;
        }
        if(p->newproc){
            t->ret = _schedfork(p->newproc);
            p->newproc = nil;
        }
        t->state = t->nextstate;
        if(t->state == Ready)
            _threadready(t);
    }
    unlock(&p->lock);
    _sched();
}
@

% _sched() -> <>
<<function needstack>>=
void
needstack(int n)
{
    int x;
    Proc *p;
    Thread *t;
    
    p = _threadgetproc();
    t = p->thread;
    
    if((uchar*)&x - n < (uchar*)t->stk){
        fprint(2, "%s %lud: &x=%p n=%d t->stk=%p\n",
            argv0, _tos->pid, &x, n, t->stk);
        fprint(2, "%s %lud: stack overflow\n", argv0, _tos->pid);
        abort();
    }
}
@

<<function _sched>>=
void
_sched(void)
{
    Proc *p;
    Thread *t;

Resched:
    p = _threadgetproc();
    t = p->thread;
    if(t != nil){
        needstack(128);
        _threaddebug(DBGSCHED, "pausing, state=%s", psstate(t->state));
        if(setjmp(t->sched)==0)
            longjmp(p->sched, 1);
        return;
    }else{
        t = runthread(p);
        if(t == nil){
            _threaddebug(DBGSCHED, "all threads gone; exiting");
            _schedexit(p);
        }
        _threaddebug(DBGSCHED, "running %d.%d", t->proc->pid, t->id);
        p->thread = t;
        if(t->moribund){
            _threaddebug(DBGSCHED, "%d.%d marked to die");
            goto Resched;
        }
        t->state = Running;
        t->nextstate = Ready;
        longjmp(t->sched, 1);
    }
}
@

<<function runthread>>=
static Thread*
runthread(Proc *p)
{
    Thread *t;
    Tqueue *q;

    if(p->nthreads==0)
        return nil;
    q = &p->ready;
    lock(&p->readylock);
    if(q->head == nil){
        q->asleep = 1;
        _threaddebug(DBGSCHED, "sleeping for more work");
        unlock(&p->readylock);
        while(rendezvous(q, 0) == (void*)~0){
            if(_threadexitsallstatus)
                exits(_threadexitsallstatus);
        }
        /* lock picked up from _threadready */
    }
    t = q->head;
    q->head = t->next;
    unlock(&p->readylock);
    return t;
}
@

<<function _threadready>>=
void
_threadready(Thread *t)
{
    Tqueue *q;

    assert(t->state == Ready);
    _threaddebug(DBGSCHED, "readying %d.%d", t->proc->pid, t->id);

    q = &t->proc->ready;
    lock(&t->proc->readylock);
    t->next = nil;
    if(q->head==nil)
        q->head = t;
    else
        *q->tail = t;
    q->tail = &t->next;
    if(q->asleep){
        q->asleep = 0;
        /* lock passes to runthread */
        _threaddebug(DBGSCHED, "waking process %d", t->proc->pid);
        while(rendezvous(q, 0) == (void*)~0){
            if(_threadexitsallstatus)
                exits(_threadexitsallstatus);
        }
    }else
        unlock(&t->proc->readylock);
}
@

<<function yield>>=
void
yield(void)
{
    _sched();
}
@


<<function _schedexit>>=
void
_schedexit(Proc *p)
{
    char ex[ERRMAX];
    Proc **l;

    lock(&_threadpq.lock);
    for(l=&_threadpq.head; *l; l=&(*l)->next){
        if(*l == p){
            *l = p->next;
            if(*l == nil)
                _threadpq.tail = l;
            break;
        }
    }
    unlock(&_threadpq.lock);

    utfecpy(ex, ex+sizeof ex, p->exitstr);
    free(p);
    _exits(ex);
}
@



\section{[[alt()]]}

% !!!
<<function alt>>=
int
alt(Alt *alts)
{
    Alt *a, *xa, *ca;
    Channel volatile *c;
    int n, s, waiting, allreadycl;
    void* r;
    Thread *t;

    /*
     * The point of going splhi here is that note handlers
     * might reasonably want to use channel operations,
     * but that will hang if the note comes while we hold the
     * chanlock.  Instead, we delay the note until we've dropped
     * the lock.
     */
    t = _threadgetproc()->thread;
    if(t->moribund || _threadexitsallstatus)
        yield();	/* won't return */
    s = _procsplhi();

    lock(&chanlock);
    t->alt = alts;
    t->chan = Chanalt;

    /* test whether any channels can proceed */
    n = 0;
    a = nil;

    for(xa=alts; xa->op!=CHANEND && xa->op!=CHANNOBLK; xa++){
        xa->entryno = -1;
        if(xa->op == CHANNOP)
            continue;

        c = xa->c;
        if(c==nil){
            unlock(&chanlock);
            _procsplx(s);
            t->chan = Channone;
            return -1;
        }

        if(isopenfor(c, xa->op) && canexec(xa))
            if(nrand(++n) == 0)
                a = xa;
    }


    if(a==nil){
        /* nothing can proceed */
        if(xa->op == CHANNOBLK){
            unlock(&chanlock);
            _procsplx(s);
            t->chan = Channone;
            if(xa->op == CHANNOBLK)
                return xa - alts;
        }

        /* enqueue on all channels open for us. */
        c = nil;
        ca = nil;
        waiting = 0;
        allreadycl = 0;
        for(xa=alts; xa->op!=CHANEND; xa++)
            if(xa->op==CHANNOP)
                continue;
            else if(isopenfor(xa->c, xa->op)){
                waiting = 1;
                enqueue(xa, &c);
            } else if(xa->err != errcl)
                ca = xa;
            else
                allreadycl = 1;

        if(waiting == 0)
            if(ca != nil){
                /* everything was closed, select last channel */
                ca->err = errcl;
                unlock(&chanlock);
                _procsplx(s);
                t->chan = Channone;
                return ca - alts;
            } else if(allreadycl){
                /* everything was already closed */
                unlock(&chanlock);
                _procsplx(s);
                t->chan = Channone;
                return -1;
            }
        /*
         * wait for successful rendezvous.
         * we can't just give up if the rendezvous
         * is interrupted -- someone else might come
         * along and try to rendezvous with us, so
         * we need to be here.
         * if the channel was closed, the op is done
         * and we flag an error for the entry.
         */
        Again:
        unlock(&chanlock);
        _procsplx(s);
        r = _threadrendezvous(&c, 0);
        s = _procsplhi();
        lock(&chanlock);

        if(r==Intred){		/* interrupted */
            if(c!=nil)	/* someone will meet us; go back */
                goto Again;
            c = (Channel*)~0;	/* so no one tries to meet us */
        }

        /* dequeue from channels, find selected one */
        a = nil;
        for(xa=alts; xa->op!=CHANEND; xa++){
            if(xa->op==CHANNOP)
                continue;
            if(xa->c == c){
                a = xa;
                a->err = nil;
                if(r == Closed)
                    a->err = errcl;
            }
            dequeue(xa);
        }
        unlock(&chanlock);
        _procsplx(s);
        if(a == nil){	/* we were interrupted */
            assert(c==(Channel*)~0);
            return -1;
        }
    }else
        altexec(a, s);	/* unlocks chanlock, does splx */
    _sched();
    t->chan = Channone;
    return a - alts;
}
@

<<function isopenfor>>=
static int
isopenfor(Channel *c, int op)
{
    return c->closed == 0 || (op == CHANRCV && c->n > 0);
}
@


<<function canexec>>=
static int
canexec(Alt *a)
{
    int i, otherop;
    Channel *c;

    c = a->c;
    /* are there senders or receivers blocked? */
    otherop = (CHANSND+CHANRCV) - a->op;
    for(i=0; i<c->nentry; i++)
        if(c->qentry[i] && c->qentry[i]->op==otherop && *c->qentry[i]->tag==nil){
            _threaddebug(DBGCHAN, "can rendez alt %p chan %p", a, c);
            return 1;
        }

    /* is there room in the channel? */
    if((a->op==CHANSND && c->n < c->s)
    || (a->op==CHANRCV && c->n > 0)){
        _threaddebug(DBGCHAN, "can buffer alt %p chan %p", a, c);
        return 1;
    }

    return 0;
}
@








<<global errcl>>=
static char errcl[] = "channel was closed";
@


<<function enqueue>>=
static void
enqueue(Alt *a, Channel **c)
{
    int i;

    _threaddebug(DBGCHAN, "Queuing alt %p on channel %p", a, a->c);
    a->tag = c;
    i = emptyentry(a->c);
    a->c->qentry[i] = a;
}
@


<<function dequeue>>=
static void
dequeue(Alt *a)
{
    int i;
    Channel *c;

    c = a->c;
    for(i=0; i<c->nentry; i++)
        if(c->qentry[i]==a){
            _threaddebug(DBGCHAN, "Dequeuing alt %p from channel %p", a, a->c);
            c->qentry[i] = nil;
            /* release if freed and not closing */
            if(c->freed && c->closed != 1)
                _chanfree(c);
            return;
        }
}
@


% enqueue -> <>
<<function emptyentry>>=
static int
emptyentry(Channel *c)
{
    int i, extra;

    assert((c->nentry==0 && c->qentry==nil) || (c->nentry && c->qentry));

    for(i=0; i<c->nentry; i++)
        if(c->qentry[i]==nil)
            return i;

    extra = 16;
    c->nentry += extra;
    c->qentry = realloc((void*)c->qentry, c->nentry*sizeof(c->qentry[0]));
    if(c->qentry == nil)
        sysfatal("realloc channel entries: %r");
    memset(&c->qentry[i], 0, extra*sizeof(c->qentry[0]));
    return i;
}
@



<<function altexec>>=
static int
altexec(Alt *a, int spl)
{
    volatile Alt *b;
    int i, n, otherop;
    Channel *c;
    void *me, *waiter, *buf;

    c = a->c;

    /* rendezvous with others */
    otherop = (CHANSND+CHANRCV) - a->op;
    n = 0;
    b = nil;
    me = a->v;
    for(i=0; i<c->nentry; i++)
        if(c->qentry[i] && c->qentry[i]->op==otherop && *c->qentry[i]->tag==nil)
            if(nrand(++n) == 0)
                b = c->qentry[i];
    if(b != nil){
        _threaddebug(DBGCHAN, "rendez %s alt %p chan %p alt %p", a->op==CHANRCV?"recv":"send", a, c, b);
        waiter = b->v;
        if(c->s && c->n){
            /*
             * if buffer is full and there are waiters
             * and we're meeting a waiter,
             * we must be receiving.
             *
             * we use the value in the channel buffer,
             * copy the waiter's value into the channel buffer
             * on behalf of the waiter, and then wake the waiter.
             */
            if(a->op!=CHANRCV)
                abort();
            buf = altexecbuffered(a, 1);
            altcopy(me, buf, c->e);
            altcopy(buf, waiter, c->e);
        }else{
            if(a->op==CHANRCV)
                altcopy(me, waiter, c->e);
            else
                altcopy(waiter, me, c->e);
        }
        *b->tag = c;	/* commits us to rendezvous */
        _threaddebug(DBGCHAN, "unlocking the chanlock");
        unlock(&chanlock);
        _procsplx(spl);
        _threaddebug(DBGCHAN, "chanlock is %lud", *(ulong*)&chanlock);
        while(_threadrendezvous(b->tag, 0) == Intred)
            ;
        return 1;
    }

    buf = altexecbuffered(a, 0);
    if(a->op==CHANRCV)
        altcopy(me, buf, c->e);
    else
        altcopy(buf, me, c->e);

    unlock(&chanlock);
    _procsplx(spl);
    return 1;
}
@


% altexec -> <>
<<function altexecbuffered>>=
static void*
altexecbuffered(Alt *a, int willreplace)
{
    uchar *v;
    Channel *c;

    c = a->c;
    /* use buffered channel queue */
    if(a->op==CHANRCV && c->n > 0){
        _threaddebug(DBGCHAN, "buffer recv alt %p chan %p", a, c);
        v = c->v + c->e*(c->f%c->s);
        if(!willreplace)
            c->n--;
        c->f++;
        return v;
    }
    if(a->op==CHANSND && c->n < c->s){
        _threaddebug(DBGCHAN, "buffer send alt %p chan %p", a, c);
        v = c->v + c->e*((c->f+c->n)%c->s);
        if(!willreplace)
            c->n++;
        return v;
    }
    abort();
    return nil;
}
@

% altexec -> <>
<<function altcopy>>=
static void
altcopy(void *dst, void *src, int sz)
{
    if(dst){
        if(src)
            memmove(dst, src, sz);
        else
            memset(dst, 0, sz);
    }
}
@


\section{Send/Receive}
% actually they all rely on alt()

% it provides a first form of synchro! you block
% when the other is not ready to receive if have
% no more space in the queue

\subsection{[[runop]]}

<<function runop>>=
static int
runop(int op, Channel *c, void *v, bool nb)
{
    int r;
    Alt a[2];

    /*
     * we could do this without calling alt,
     * but the only reason would be performance,
     * and i'm not convinced it matters.
     */
    a[0].op = op;
    a[0].c = c;
    a[0].v = v;
    a[0].err = nil;
    a[1].op = CHANEND;
    if(nb)
        a[1].op = CHANNOBLK;

    switch(r=alt(a)){
    case -1:	/* interrupted */
        return -1;
    case 1:	/* nonblocking, didn't accomplish anything */
        assert(nb);
        return 0;
    case 0:
        /*
         * Okay, but return -1 if the op is done because of a close.
         */
        if(a[0].err != nil)
            return -1;
        return 1;
    default:
        fprint(2, "ERROR: channel alt returned %d\n", r);
        abort();
        return -1;
    }
}
@

\subsection{[[send()]]/[[recv()]]}

<<function send>>=
int
send(Channel *c, void *v)
{
    return runop(CHANSND, c, v, 0);
}
@

<<function recv>>=
int
recv(Channel *c, void *v)
{
    return runop(CHANRCV, c, v, 0);
}
@

\subsection{Non blocking operations, [[nbxxx()]]}

<<function nbrecv>>=
int
nbrecv(Channel *c, void *v)
{
    return runop(CHANRCV, c, v, 1);
}
@

<<function nbsend>>=
int
nbsend(Channel *c, void *v)
{
    return runop(CHANSND, c, v, 1);
}
@

\subsection{Typed send and receive}

<<function channelsize>>=
static void
channelsize(Channel *c, int sz)
{
    if(c->e != sz){
        fprint(2, "expected channel with elements of size %d, got size %d\n",
            sz, c->e);
        abort();
    }
}
@


<<function sendul>>=
int
sendul(Channel *c, ulong v)
{
    channelsize(c, sizeof(ulong));
    return send(c, &v);
}
@

<<function recvul>>=
ulong
recvul(Channel *c)
{
    ulong v;

    channelsize(c, sizeof(ulong));
    if(recv(c, &v) < 0)
        return ~0;
    return v;
}
@


<<function sendp>>=
int
sendp(Channel *c, void *v)
{
    channelsize(c, sizeof(void*));
    return send(c, &v);
}
@

<<function recvp>>=
void*
recvp(Channel *c)
{
    void *v;

    channelsize(c, sizeof(void*));
    if(recv(c, &v) < 0)
        return nil;
    return v;
}
@


<<function nbsendul>>=
int
nbsendul(Channel *c, ulong v)
{
    channelsize(c, sizeof(ulong));
    return nbsend(c, &v);
}
@

<<function nbrecvul>>=
ulong
nbrecvul(Channel *c)
{
    ulong v;

    channelsize(c, sizeof(ulong));
    if(nbrecv(c, &v) == 0)
        return 0;
    return v;
}
@

<<function nbsendp>>=
int
nbsendp(Channel *c, void *v)
{
    channelsize(c, sizeof(void*));
    return nbsend(c, &v);
}
@

<<function nbrecvp>>=
void*
nbrecvp(Channel *c)
{
    void *v;

    channelsize(c, sizeof(void*));
    if(nbrecv(c, &v) == 0)
        return nil;
    return v;
}
@



\section{IO processus}

% threads are cooperative. If one does a syscall such as reading
% then it hangs the whole process ... so have to put such calls
% in another process, hence the idea of IO slace processes.

<<function ioproc_arg>>=
#define ioproc_arg(io, type)	(va_arg((io)->arg, type))
@

\subsection{[[Ioproc]]}

% private structure! #pragma incomplete in thread.h (and implemented in
% threadimpl.h)
<<struct Ioproc>>=
struct Ioproc
{
    int tid;

    Channel *c;
    Channel *creply;

    int inuse;

    long (*op)(va_list*);

    va_list arg;
    long ret;
    char err[ERRMAX];

    Ioproc *next;
};
@

<<constant STACK>>=
STACK = 8192,
@

% ctor
<<function ioproc>>=
Ioproc*
ioproc(void)
{
    Ioproc *io;

    io = mallocz(sizeof(Ioproc), 1);
    if(io == nil)
        sysfatal("ioproc malloc: %r");
    io->c = chancreate(sizeof(void*), 0);
    io->creply = chancreate(sizeof(void*), 0);
    io->tid = proccreate(xioproc, io, STACK);
    return io;
}
@

% dtor
<<function closeioproc>>=
void
closeioproc(Ioproc *io)
{
    if(io == nil)
        return;
    iointerrupt(io);
    while(send(io->c, 0) == -1)
        ;
    chanfree(io->c);
    chanfree(io->creply);
    free(io);
}
@

% closeioproc | iocall -> <>
<<function iointerrupt>>=
void
iointerrupt(Ioproc *io)
{
    if(!io->inuse)
        return;
    threadint(io->tid);
}
@





\subsection{[[xiproc()]]}

<<function xioproc>>=
static void
xioproc(void *a)
{
    Ioproc *io, *x;
    io = a;
    /*
     * first recvp acquires the ioproc.
     * second tells us that the data is ready.
     */
    for(;;){
        while(recv(io->c, &x) == -1)
            ;
        if(x == 0)	/* our cue to leave */
            break;
        assert(x == io);

        /* caller is now committed -- even if interrupted he'll return */
        while(recv(io->creply, &x) == -1)
            ;
        if(x == 0)	/* caller backed out */
            continue;
        assert(x == io);

        io->ret = io->op(&io->arg);
        if(io->ret < 0)
            rerrstr(io->err, sizeof io->err);
        while(send(io->creply, &io) == -1)
            ;
        while(recv(io->creply, &x) == -1)
            ;
    }
}
@



\subsection{[[iocall()]]}

<<function iocall>>=
long
iocall(Ioproc *io, long (*op)(va_list*), ...)
{
    int ret, inted;
    Ioproc *msg;

    if(send(io->c, &io) == -1){
        werrstr("interrupted");
        return -1;
    }
    assert(!io->inuse);
    io->inuse = 1;
    io->op = op;
    va_start(io->arg, op);
    msg = io;
    inted = 0;
    while(send(io->creply, &msg) == -1){
        msg = nil;
        inted = 1;
    }
    if(inted){
        werrstr("interrupted");
        return -1;
    }

    /*
     * If we get interrupted, we have to stick around so that
     * the IO proc has someone to talk to.  Send it an interrupt
     * and try again.
     */
    inted = 0;
    while(recv(io->creply, nil) == -1){
        inted = 1;
        iointerrupt(io);
    }
    USED(inted);
    va_end(io->arg);
    ret = io->ret;
    if(ret < 0)
        errstr(io->err, sizeof io->err);
    io->inuse = 0;

    /* release resources */
    while(send(io->creply, &io) == -1)
        ;
    return ret;
}
@


\subsection{IO wrappers}


<<function ioopen>>=
int
ioopen(Ioproc *io, char *path, int mode)
{
    return iocall(io, _ioopen, path, mode);
}
@

<<function _ioopen>>=
static long
_ioopen(va_list *arg)
{
    char *path;
    int mode;

    path = va_arg(*arg, char*);
    mode = va_arg(*arg, int);
    return open(path, mode);
}
@



<<function ioclose>>=
int
ioclose(Ioproc *io, int fd)
{
    return iocall(io, _ioclose, fd);
}
@

<<function _ioclose>>=
static long
_ioclose(va_list *arg)
{
    int fd;

    fd = va_arg(*arg, int);
    return close(fd);
}
@


<<function ioread>>=
long
ioread(Ioproc *io, int fd, void *a, long n)
{
    return iocall(io, _ioread, fd, a, n);
}
@

<<function _ioread>>=
static long
_ioread(va_list *arg)
{
    int fd;
    void *a;
    long n;

    fd = va_arg(*arg, int);
    a = va_arg(*arg, void*);
    n = va_arg(*arg, long);
    return read(fd, a, n);
}
@

<<function ioreadn>>=
long
ioreadn(Ioproc *io, int fd, void *a, long n)
{
    return iocall(io, _ioreadn, fd, a, n);
}
@


<<function _ioreadn>>=
static long
_ioreadn(va_list *arg)
{
    int fd;
    void *a;
    long n;

    fd = va_arg(*arg, int);
    a = va_arg(*arg, void*);
    n = va_arg(*arg, long);
    return readn(fd, a, n);
}
@

<<function iowrite>>=
long
iowrite(Ioproc *io, int fd, void *a, long n)
{
    return iocall(io, _iowrite, fd, a, n);
}
@

<<function _iowrite>>=
static long
_iowrite(va_list *arg)
{
    int fd;
    void *a;
    long n;

    fd = va_arg(*arg, int);
    a = va_arg(*arg, void*);
    n = va_arg(*arg, long);
    return write(fd, a, n);
}
@

<<function iosleep>>=
int
iosleep(Ioproc *io, long n)
{
    return iocall(io, _iosleep, n);
}
@


<<function _iosleep>>=
static long
_iosleep(va_list *arg)
{
    long n;

    n = va_arg(*arg, long);
    return sleep(n);
}
@



\section{Thread-aware libc}

\subsection{Memory}

% actually malloc already shared-memory safe as it uses locks.
% but have a small malloc wrapper not doing that much more,
% just a bit more error safe:

<<global totalmalloc>>=
static long totalmalloc;
@

<<function _threadmalloc>>=
void*
_threadmalloc(long size, int z)
{
    void *m;

    m = malloc(size);
    if (m == nil)
        sysfatal("Malloc of size %ld failed: %r", size);
    setmalloctag(m, getcallerpc(&size));
    totalmalloc += size;
    if (size > 100000000) {
        fprint(2, "Malloc of size %ld, total %ld\n", size, totalmalloc);
        abort();
    }
    if (z)
        memset(m, 0, size);
    return m;
}
@


\subsection{Exit}
% need to terminate all of those things.
% I remember it was tricky in ocaml to get things right
% when have worker, when use MPI, etc.

<<global _threadexitsallstatus>>=
char *_threadexitsallstatus;
@

<<function threadexits>>=
void
threadexits(char *exitstr)
{
    Proc *p;
    Thread *t;

    p = _threadgetproc();
    t = p->thread;
    t->moribund = 1;
    if(exitstr==nil)
        exitstr="";
    utfecpy(p->exitstr, p->exitstr+ERRMAX, exitstr);
    _sched();
}
@


<<function threadexitsall>>=
void
threadexitsall(char *exitstr)
{
    Proc *p;
    int pid[64];
    int i, npid, mypid;

    if(exitstr == nil)
        exitstr = "";
    _threadexitsallstatus = exitstr;
    _threaddebug(DBGSCHED, "_threadexitsallstatus set to %p", _threadexitsallstatus);
    mypid = _tos->pid; //getpid();

    /*
     * signal others.
     * copying all the pids first avoids other threads
     * teardown procedures getting in the way.
     *
     * avoid mallocs since malloc can post a note which can
     * call threadexitsall...
     */
    for(;;){
        lock(&_threadpq.lock);
        npid = 0;
        for(p = _threadpq.head; p && npid < nelem(pid); p=p->next){
            if(p->threadint == 0 && p->pid != mypid){
                pid[npid++] = p->pid;
                p->threadint = 1;
            }
        }
        unlock(&_threadpq.lock);
        if(npid == 0)
            break;
        for(i=0; i<npid; i++)
            postnote(PNPROC, pid[i], "threadint");
    }

    /* leave */
    exits(exitstr);
}
@


<<global _threadwaitchan>>=
Channel *_threadwaitchan;
@

<<function threadwaitchan>>=
Channel*
threadwaitchan(void)
{
    if(_threadwaitchan==nil)
        _threadwaitchan = chancreate(sizeof(Waitmsg*), 16);
    return _threadwaitchan;
}
@

\subsection{Fork}

<<function _schedfork>>=
int
_schedfork(Proc *p)
{
    int pid;

    switch(pid = rfork(RFPROC|RFMEM|RFNOWAIT|p->rforkflag)){
    case 0:
        *mainp = p;	/* write to stack, so local to proc */
        longjmp(_mainjmp, 1);
    default:
        return pid;
    }
}
@

\subsection{Exec}

% in main.c, not sure why, could be in a exec.c
<<function _schedexec>>=
int
_schedexec(Execargs *e)
{
    int pid;

    switch(pid = rfork(RFREND|RFNOTEG|RFFDG|RFMEM|RFPROC)){
    case 0:
        efork(e);
    default:
        return pid;
    }
}
@

% _schedexec -> <>
<<function efork>>=
static void
efork(Execargs *e)
{
    char buf[ERRMAX];

    _threaddebug(DBGEXEC, "_schedexec %s", e->prog);
    close(e->fd[0]);
    exec(e->prog, e->args);
    _threaddebug(DBGEXEC, "_schedexec failed: %r");
    rerrstr(buf, sizeof buf);
    if(buf[0]=='\0')
        strcpy(buf, "exec failed");
    write(e->fd[1], buf, strlen(buf));
    close(e->fd[1]);
    _exits(buf);
}
@


% procexec -> <>
<<function _schedexecwait>>=
void
_schedexecwait(void)
{
    int pid;
    Channel *c;
    Proc *p;
    Thread *t;
    Waitmsg *w;

    p = _threadgetproc();
    t = p->thread;
    pid = t->ret;
    _threaddebug(DBGEXEC, "_schedexecwait %d", t->ret);

    rfork(RFCFDG);
    for(;;){
        w = wait();
        if(w == nil)
            break;
        if(w->pid == pid)
            break;
        free(w);
    }
    if(w != nil){
        if((c = _threadwaitchan) != nil)
            sendp(c, w);
        else
            free(w);
    }
    threadexits("procexec");
}
@




<<constant PIPEMNT>>=
#define PIPEMNT	"/mnt/temp"
@

<<function procexec>>=
void
procexec(Channel *pidc, char *prog, char *args[])
{
    int n;
    Proc *p;
    Thread *t;

    _threaddebug(DBGEXEC, "procexec %s", prog);
    /* must be only thread in proc */
    p = _threadgetproc();
    t = p->thread;
    if(p->threads.head != t || p->threads.head->nextt != nil){
        werrstr("not only thread in proc");
    Bad:
        if(pidc)
            sendul(pidc, ~0);
        return;
    }

    /*
     * We want procexec to behave like exec; if exec succeeds,
     * never return, and if it fails, return with errstr set.
     * Unfortunately, the exec happens in another proc since
     * we have to wait for the exec'ed process to finish.
     * To provide the semantics, we open a pipe with the 
     * write end close-on-exec and hand it to the proc that
     * is doing the exec.  If the exec succeeds, the pipe will
     * close so that our read below fails.  If the exec fails,
     * then the proc doing the exec sends the errstr down the
     * pipe to us.
     */
    if(bind("#|", PIPEMNT, MREPL) < 0)
        goto Bad;
    if((p->exec.fd[0] = open(PIPEMNT "/data", OREAD)) < 0){
        unmount(nil, PIPEMNT);
        goto Bad;
    }
    if((p->exec.fd[1] = open(PIPEMNT "/data1", OWRITE|OCEXEC)) < 0){
        close(p->exec.fd[0]);
        unmount(nil, PIPEMNT);
        goto Bad;
    }
    unmount(nil, PIPEMNT);

    /* exec in parallel via the scheduler */
    assert(p->needexec==0);
    p->exec.prog = prog;
    p->exec.args = args;
    p->needexec = 1;
    _sched();

    close(p->exec.fd[1]);
    if((n = read(p->exec.fd[0], p->exitstr, ERRMAX-1)) > 0){	/* exec failed */
        p->exitstr[n] = '\0';
        errstr(p->exitstr, ERRMAX);
        close(p->exec.fd[0]);
        goto Bad;
    }
    close(p->exec.fd[0]);

    if(pidc)
        sendul(pidc, t->ret);

    /* wait for exec'ed program, then exit */
    _schedexecwait();
}
@

<<function procexecl>>=
void
procexecl(Channel *pidc, char *f, ...)
{
    procexec(pidc, f, &f+1);
}
@




\subsection{Interruptions}

<<constant Intred>>=
#define Intred	((void*)~0)		/* interrupted */
@


\subsection{Notes}








<<global _threadnopasser>>=
int	_threadnopasser;
@

<<constant NFN>>=
#define	NFN		33
@

<<constant ERRLEN>>=
#define	ERRLEN	48
@

<<struct Note>>=
struct Note
{
    Lock		inuse;
    Proc		*proc;		/* recipient */
    char		s[ERRMAX];	/* arg2 */
};
@

<<global notes>>=
static Note	notes[128];
@

<<global enotes>>=
static Note	*enotes = notes+nelem(notes);
@

<<global onnote>>=
static int		(*onnote[NFN])(void*, char*);
@

<<global onnotepid>>=
static int		onnotepid[NFN];
@

<<global onnotelock>>=
static Lock	onnotelock;
@

<<function threadnotify>>=
int
threadnotify(int (*f)(void*, char*), int in)
{
    int i, topid;
    int (*from)(void*, char*), (*to)(void*, char*);

    if(in){
        from = nil;
        to = f;
        topid = _threadgetproc()->pid;
    }else{
        from = f;
        to = nil;
        topid = 0;
    }
    lock(&onnotelock);
    for(i=0; i<NFN; i++)
        if(onnote[i]==from){
            onnote[i] = to;
            onnotepid[i] = topid;
            break;
        }
    unlock(&onnotelock);
    return i<NFN;
}
@

<<function delayednotes>>=
static void
delayednotes(Proc *p, void *v)
{
    int i;
    Note *n;
    int (*fn)(void*, char*);

    if(!p->pending)
        return;

    p->pending = 0;
    for(n=notes; n<enotes; n++){
        if(n->proc == p){
            for(i=0; i<NFN; i++){
                if(onnotepid[i]!=p->pid || (fn = onnote[i])==nil)
                    continue;
                if((*fn)(v, n->s))
                    break;
            }
            if(i==NFN){
                _threaddebug(DBGNOTE, "Unhandled note %s, proc %p\n", n->s, p);
                if(v != nil)
                    noted(NDFLT);
                else if(strncmp(n->s, "sys:", 4)==0)
                    abort();
                threadexitsall(n->s);
            }
            n->proc = nil;
            unlock(&n->inuse);
        }
    }
}
@

<<function _threadnote>>=
void
_threadnote(void *v, char *s)
{
    Proc *p;
    Note *n;

    _threaddebug(DBGNOTE, "Got note %s", s);
    if(strncmp(s, "sys:", 4) == 0)
        noted(NDFLT);

    if(_threadexitsallstatus){
        _threaddebug(DBGNOTE, "Threadexitsallstatus = '%s'\n", _threadexitsallstatus);
        _exits(_threadexitsallstatus);
    }

    if(strcmp(s, "threadint")==0)
        noted(NCONT);

    p = _threadgetproc();
    if(p == nil)
        noted(NDFLT);

    for(n=notes; n<enotes; n++)
        if(canlock(&n->inuse))
            break;
    if(n==enotes)
        sysfatal("libthread: too many delayed notes");
    utfecpy(n->s, n->s+ERRMAX, s);
    n->proc = p;
    p->pending = 1;
    if(!p->splhi)
        delayednotes(p, v);
    noted(NCONT);
}
@

<<function _procsplhi>>=
int
_procsplhi(void)
{
    int s;
    Proc *p;

    p = _threadgetproc();
    s = p->splhi;
    p->splhi = 1;
    return s;
}
@

<<function _procsplx>>=
void
_procsplx(int s)
{
    Proc *p;

    p = _threadgetproc();
    p->splhi = s;
    if(s)
        return;
    if(p->pending)
        delayednotes(p, nil);
}
@




\subsection{Dialing}

<<function _iodial>>=
static long
_iodial(va_list *arg)
{
    char *addr, *local, *dir;
    int *cdfp;

    addr = va_arg(*arg, char*);
    local = va_arg(*arg, char*);
    dir = va_arg(*arg, char*);
    cdfp = va_arg(*arg, int*);

    return dial(addr, local, dir, cdfp);
}
@

<<function iodial>>=
int
iodial(Ioproc *io, char *addr, char *local, char *dir, int *cdfp)
{
    return iocall(io, _iodial, addr, local, dir, cdfp);
}
@




<<enum _anon_ (lib_core/libthread/dial.c)>>=
enum
{
    Maxstring	= 128,
    Maxpath		= 256,
};
@

<<struct DS>>=
struct DS {
    /* dist string */
    char	buf[Maxstring];
    char	*netdir;
    char	*proto;
    char	*rem;

    /* other args */
    char	*local;
    char	*dir;
    int	*cfdp;
};
@

<<function _threaddial>>=
/*
 *  the dialstring is of the form '[/net/]proto!dest'
 */
int
_threaddial(char *dest, char *local, char *dir, int *cfdp)
{
    DS ds;
    int rv;
    char err[ERRMAX], alterr[ERRMAX];

    ds.local = local;
    ds.dir = dir;
    ds.cfdp = cfdp;

    _dial_string_parse(dest, &ds);
    if(ds.netdir)
        return csdial(&ds);

    ds.netdir = "/net";
    rv = csdial(&ds);
    if(rv >= 0)
        return rv;
    err[0] = '\0';
    errstr(err, sizeof err);
    if(strstr(err, "refused") != 0){
        werrstr("%s", err);
        return rv;
    }
    ds.netdir = "/net.alt";
    rv = csdial(&ds);
    if(rv >= 0)
        return rv;

    alterr[0] = 0;
    errstr(alterr, sizeof alterr);
    if(strstr(alterr, "translate") || strstr(alterr, "does not exist"))
        werrstr("%s", err);
    else
        werrstr("%s", alterr);
    return rv;
}
@

<<function csdial>>=
static int
csdial(DS *ds)
{
    int n, fd, rv;
    char *p, buf[Maxstring], clone[Maxpath], err[ERRMAX], besterr[ERRMAX];

    /*
     *  open connection server
     */
    snprint(buf, sizeof(buf), "%s/cs", ds->netdir);
    fd = open(buf, ORDWR);
    if(fd < 0){
        /* no connection server, don't translate */
        snprint(clone, sizeof(clone), "%s/%s/clone", ds->netdir, ds->proto);
        return call(clone, ds->rem, ds);
    }

    /*
     *  ask connection server to translate
     */
    snprint(buf, sizeof(buf), "%s!%s", ds->proto, ds->rem);
    if(write(fd, buf, strlen(buf)) < 0){
        close(fd);
        return -1;
    }

    /*
     *  loop through each address from the connection server till
     *  we get one that works.
     */
    *besterr = 0;
    rv = -1;
    seek(fd, 0, 0);
    while((n = read(fd, buf, sizeof(buf) - 1)) > 0){
        buf[n] = 0;
        p = strchr(buf, ' ');
        if(p == 0)
            continue;
        *p++ = 0;
        rv = call(buf, p, ds);
        if(rv >= 0)
            break;
        err[0] = '\0';
        errstr(err, sizeof err);
        if(strstr(err, "does not exist") == 0)
            strcpy(besterr, err);
    }
    close(fd);

    if(rv < 0 && *besterr)
        werrstr("%s", besterr);
    else
        werrstr("%s", err);
    return rv;
}
@

<<function call>>=
static int
call(char *clone, char *dest, DS *ds)
{
    int fd, cfd, n;
    char cname[Maxpath], name[Maxpath], data[Maxpath], *p;

    /* because cs is in a different name space, replace the mount point */
    if(*clone == '/'){
        p = strchr(clone+1, '/');
        if(p == nil)
            p = clone;
        else 
            p++;
    } else
        p = clone;
    snprint(cname, sizeof cname, "%s/%s", ds->netdir, p);

    cfd = open(cname, ORDWR);
    if(cfd < 0)
        return -1;

    /* get directory name */
    n = read(cfd, name, sizeof(name)-1);
    if(n < 0){
        close(cfd);
        return -1;
    }
    name[n] = 0;
    for(p = name; *p == ' '; p++)
        ;
    snprint(name, sizeof(name), "%ld", strtoul(p, 0, 0));
    p = strrchr(cname, '/');
    *p = 0;
    if(ds->dir)
        snprint(ds->dir, NETPATHLEN, "%s/%s", cname, name);
    snprint(data, sizeof(data), "%s/%s/data", cname, name);

    /* connect */
    if(ds->local)
        snprint(name, sizeof(name), "connect %s %s", dest, ds->local);
    else
        snprint(name, sizeof(name), "connect %s", dest);
    if(write(cfd, name, strlen(name)) < 0){
        close(cfd);
        return -1;
    }

    /* open data connection */
    fd = open(data, ORDWR);
    if(fd < 0){
        close(cfd);
        return -1;
    }
    if(ds->cfdp)
        *ds->cfdp = cfd;
    else
        close(cfd);
    return fd;
}
@

<<function _dial_string_parse>>=
/*
 *  parse a dial string
 */
static void
_dial_string_parse(char *str, DS *ds)
{
    char *p, *p2;

    strncpy(ds->buf, str, Maxstring);
    ds->buf[Maxstring-1] = 0;

    p = strchr(ds->buf, '!');
    if(p == 0) {
        ds->netdir = 0;
        ds->proto = "net";
        ds->rem = ds->buf;
    } else {
        if(*ds->buf != '/' && *ds->buf != '#'){
            ds->netdir = 0;
            ds->proto = ds->buf;
        } else {
            for(p2 = p; *p2 != '/'; p2--)
                ;
            *p2++ = 0;
            ds->netdir = ds->buf;
            ds->proto = p2;
        }
        *p = 0;
        ds->rem = p + 1;
    }
}
@



\section{Error managment}

%"Thread library functions do not return on failure; if errors occur, the entire program is aborted."


% call abort() which enter broken state I think by causing a fault


<<function _threadsysfatal>>=
void
_threadsysfatal(char *fmt, va_list arg)
{
    char buf[1024];	/* size doesn't matter; we're about to exit */

    vseprint(buf, buf+sizeof(buf), fmt, arg);
    if(argv0)
        fprint(2, "%s: %s\n", argv0, buf);
    else
        fprint(2, "%s\n", buf);
    threadexitsall(buf);
}
@

<<function _threadassert>>=
void
_threadassert(char *s)
{
    char buf[256];
    int n;
    Proc *p;

    p = _threadgetproc();
    if(p && p->thread)
        n = sprint(buf, "%d.%d ", p->pid, p->thread->id);
    else
        n = 0;
    snprint(buf+n, sizeof(buf)-n, "%s: assertion failed\n", s);
    write(2, buf, strlen(buf));
    abort();
}
@


\section{Debugging}


<<global _threaddebuglevel>>=
// biset<enum<dbgxxx>>
int _threaddebuglevel;
@

% could use enum dbgxxx
<<constant DBGAPPL>>=
#define DBGAPPL	(1 << 0)
@

<<constant DBGSCHED>>=
#define DBGSCHED	(1 << 16)
@

<<constant DBGCHAN>>=
#define DBGCHAN	(1 << 17)
@

<<constant DBGREND>>=
#define DBGREND	(1 << 18)
@

<<constant DBGNOTE>>=
#define DBGNOTE	(1 << 20)
@
%/* #define DBGKILL	(1 << 19) */

<<constant DBGEXEC>>=
#define DBGEXEC	(1 << 21)
@



<<function _threaddebug>>=
void
_threaddebug(ulong flag, char *fmt, ...)
{
    char buf[128];
    va_list arg;
    Fmt f;
    Proc *p;

    if((_threaddebuglevel&flag) == 0)
        return;

    fmtfdinit(&f, 2, buf, sizeof buf);

    p = _threadgetproc();
    if(p==nil)
        fmtprint(&f, "noproc ");
    else if(p->thread)
        fmtprint(&f, "%d.%d ", p->pid, p->thread->id);
    else
        fmtprint(&f, "%d._ ", p->pid);

    va_start(arg, fmt);
    fmtvprint(&f, fmt, arg);
    va_end(arg);
    fmtprint(&f, "\n");
    fmtfdflush(&f);
}
@



\section{Advanced topics}

% dead?
<<global _threadnotefd>>=
int	_threadnotefd;
@

% dead?
<<global _threadpasserpid>>=
int	_threadpasserpid;
@


% dead?
<<function _times>>=
static long
_times(long *t)
{
    char b[200], *p;
    int f;
    ulong r;

    memset(b, 0, sizeof(b));
    f = open("/dev/cputime", OREAD|OCEXEC);
    if(f < 0)
        return 0;
    if(read(f, b, sizeof(b)) <= 0){
        close(f);
        return 0;
    }
    p = b;
    if(t)
        t[0] = atol(p);
    p = skip(p);
    if(t)
        t[1] = atol(p);
    p = skip(p);
    r = atol(p);
    if(t){
        p = skip(p);
        t[2] = atol(p);
        p = skip(p);
        t[3] = atol(p);
    }
    return r;
}
@

% _times -> <>
<<function skip>>=
static char*
skip(char *p)
{
    while(*p == ' ')
        p++;
    while(*p != ' ' && *p != 0)
        p++;
    return p;
}
@


\subsection{Per  thread private data}

<<global privlock>>=
static Lock privlock;
@

<<global privmask>>=
//array<bool> NPRIV at least
static int privmask = 1;
@

<<function tprivalloc>>=
int
tprivalloc(void)
{
    int i;

    lock(&privlock);
    for(i=0; i<NPRIV; i++)
        if(!(privmask&(1<<i))){
            privmask |= 1<<i;
            unlock(&privlock);
            return i;
        }
    unlock(&privlock);
    return -1;
}
@

<<function tprivfree>>=
void
tprivfree(int i)
{
    if(i < 0 || i >= NPRIV)
        abort();
    lock(&privlock);
    privmask &= ~(1<<i);
}
@

<<function tprivaddr>>=
void**
tprivaddr(int i)
{
    return &_threadgetproc()->thread->udata[i];
}
@




<<function threaddata>>=
void**
threaddata(void)
{
    return &_threadgetproc()->thread->udata[0];
}
@

<<function _workerdata>>=
void**
_workerdata(void)
{
    return &_threadgetproc()->wdata;
}
@

<<function procdata>>=
void**
procdata(void)
{
    return &_threadgetproc()->udata;
}
@

\subsection{Thread groups}

<<function threadsetgrp>>=
int
threadsetgrp(int ng)
{
    int og;
    Thread *t;

    t = _threadgetproc()->thread;
    og = t->grp;
    t->grp = ng;
    return og;
}
@

<<function threadgetgrp>>=
int
threadgetgrp(void)
{
    return _threadgetproc()->thread->grp;
}
@

\subsection{Thread kills}


<<function tinterrupt>>=
static void
tinterrupt(Proc *p, Thread *t)
{
    switch(t->state){
    case Running:
        postnote(PNPROC, p->pid, "threadint");
        break;
    case Rendezvous:
        _threadflagrendez(t);
        break;
    }
}
@


<<function threadkillgrp>>=
void
threadkillgrp(int grp)
{
    threadxxxgrp(grp, 1);
}
@

<<function threadkill>>=
void
threadkill(int id)
{
    threadxxx(id, 1);
}
@


<<function threadxxxgrp>>=
static void
threadxxxgrp(int grp, int dokill)
{
    Proc *p;
    Thread *t;

    lock(&_threadpq.lock);
    for(p=_threadpq.head; p; p=p->next){
        lock(&p->lock);
        for(t=p->threads.head; t; t=t->nextt)
            if(t->grp == grp){
                if(dokill)
                    t->moribund = 1;
                tinterrupt(p, t);
            }
        unlock(&p->lock);
    }
    unlock(&_threadpq.lock);
    _threadbreakrendez();
}
@

<<function threadxxx>>=
static void
threadxxx(int id, int dokill)
{
    Proc *p;
    Thread *t;

    lock(&_threadpq.lock);
    for(p=_threadpq.head; p; p=p->next){
        lock(&p->lock);
        for(t=p->threads.head; t; t=t->nextt)
            if(t->id == id){
                if(dokill)
                    t->moribund = 1;
                tinterrupt(p, t);
                unlock(&p->lock);
                unlock(&_threadpq.lock);
                _threadbreakrendez();
                return;
            }
        unlock(&p->lock);
    }
    unlock(&_threadpq.lock);
    _threaddebug(DBGNOTE, "Can't find thread to kill");
    return;
}
@



<<function threadintgrp>>=
void
threadintgrp(int grp)
{
    threadxxxgrp(grp, 0);
}
@

<<function threadint>>=
void
threadint(int id)
{
    threadxxx(id, 0);
}
@


\subsection{Rendez vous}

<<constant RENDHASH>>=
RENDHASH = 13,
@

<<struct Rgrp>>=
struct Rgrp
{
    Lock	lock;
    Thread	*hash[RENDHASH];
};
@

<<global _threadrgrp>>=
Rgrp _threadrgrp;
@

<<function _threadrendezvous>>=
void*
_threadrendezvous(void *tag, void *val)
{
    void *ret;
    Thread *t, **l;

    lock(&_threadrgrp.lock);
    l = &_threadrgrp.hash[((uintptr)tag)%nelem(_threadrgrp.hash)];
    for(t=*l; t; l=&t->rendhash, t=*l){
        if(t->rendtag==tag){
            _threaddebug(DBGREND, "Rendezvous with thread %d.%d", t->proc->pid, t->id);
            *l = t->rendhash;
            ret = finish(t, val);
            unlock(&_threadrgrp.lock);
            return ret;
        }
    }

    /* Going to sleep here. */
    t = _threadgetproc()->thread;
    t->rendbreak = 0;
    t->inrendez = 1;
    t->rendtag = tag;
    t->rendval = val;
    t->rendhash = *l;
    *l = t;
    t->nextstate = Rendezvous;
    _threaddebug(DBGREND, "Rendezvous for tag %p", t->rendtag);
    unlock(&_threadrgrp.lock);
    _sched();
    t->inrendez = 0;
    _threaddebug(DBGREND, "Woke after rendezvous; val is %p", t->rendval);
    return t->rendval;
}
@


<<global isdirty>>=
static int isdirty;
@

<<function finish>>=
static void*
finish(Thread *t, void *val)
{
    void *ret;

    ret = t->rendval;
    t->rendval = val;
    while(t->state == Running)
        sleep(0);
    lock(&t->proc->lock);
    if(t->state == Rendezvous){	/* not always true: might be Dead */
        t->state = Ready;
        _threadready(t);
    }
    unlock(&t->proc->lock);
    return ret;
}
@


<<function _threadflagrendez>>=
/*
 * This is called while holding _threadpq.lock and p->lock,
 * so we can't lock _threadrgrp.lock.  Instead our caller has 
 * to call _threadbreakrendez after dropping those locks.
 */
void
_threadflagrendez(Thread *t)
{
    t->rendbreak = 1;
    isdirty = 1;
}
@

<<function _threadbreakrendez>>=
void
_threadbreakrendez(void)
{
    int i;
    Thread *t, **l;

    if(isdirty == 0)
        return;
    lock(&_threadrgrp.lock);
    if(isdirty == 0){
        unlock(&_threadrgrp.lock);
        return;
    }
    isdirty = 0;
    for(i=0; i<nelem(_threadrgrp.hash); i++){
        l = &_threadrgrp.hash[i];
        for(t=*l; t; t=*l){
            if(t->rendbreak){
                *l = t->rendhash;
                finish(t, (void*)~0);
            }else
                 l=&t->rendhash;
        }
    }
    unlock(&_threadrgrp.lock);
}
@



\subsection{[[chanprint()]]}

<<function chanprint>>=
int
chanprint(Channel *c, char *fmt, ...)
{
    va_list arg;
    char *p;
    int n;

    va_start(arg, fmt);
    p = vsmprint(fmt, arg);
    va_end(arg);
    if(p == nil)
        sysfatal("vsmprint failed: %r");
    n = sendp(c, p);
    yield();	/* let recipient handle message immediately */
    return n;
}
@
\chapter{Mathematics}
%http://developerblog.redhat.com/2015/01/02/improving-math-performance-in-glibc/

% _div and _mod are in Assembler.nw appendix

\chapter{Error Managment}

% perror?

\chapter{Debugging Support}

\chapter{Profiling Support}

\chapter{Security}

\chapter{Advanced Topics}

\chapter{Conclusion}





\appendix

\chapter{Extra Code}

\ifallcode
#include "Libcore_extra.nw"
\fi

\chapter{Changelog}
\label{sec:changelog}

\chapter*{Glossary}
\label{sec:glossary}
\addcontentsline{toc}{chapter}{Glossary}

\begin{verbatim}
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{chapter}{Index}

%\chapter{References} 
\addcontentsline{toc}{chapter}{References}

\bibliography{../docs/latex/Principia}
\bibliographystyle{plain}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}

