\documentclass[twocolumn, landscape]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse % see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, I changed for the better a few things:
% - ??

%thx to codemap/codegraph/scheck:
% - TODO use cg to reduce backward deps, introduce globals.c, utils.c,
%   (harder to understand non layered code)
% - TODO use scheck to remove deadcode, dead prototypes, useless export
%   or mv as forward decl
%   (harder to understand big interface files)
% - TODO use cg to reduce number of globals by moving them closer to the
%   relevant file (or even function), better cluster the code
%   (harder to understand non functional code using lots of globals)

%thx to this manual, better understand libc:
% - TODO errno global
% - SEMI malloc vs brk internals
% - floor and ceil :) I never remembered

%history LP-ization:
% - skeleton, mostly copy paste of Template.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * TODO ctor/dtor, dumper
%    * TODO [[xxx]] other fields, [[xxx]] extra fields
% - read Extra section, identify concepts, first TOC
% - SEMI distribute parts of the Extra section in the main file
% - TODO understand main(), LP split main, improve TOC
% - TODO understand main functions, LP split, cluster, improve TOC
% - TODO LP split the structures, use datalog for flow to field info
% - SEMI nullify, boolify, errorify, enumify,  typeify,    scheckify, plan9ify
% - TODO aspecify advanced features! remove useless features
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% ifallcode is used for:
%  - forward decl, func decl, extern decl, #ifdef, pragmas (stuff in Extra.nw)
%  - ??

\addtolength{\topmargin}{-.850in}
\addtolength{\textheight}{1.70in}


\begin{document}
%******************************************************************************
% Title
%******************************************************************************
\title{
{\Huge 
Principia Softwarica: The Plan~9 Core Libraries
}\\
{version 0.1}
}
% ARM edition? for very few code so maybe not that needed to put in title?

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}
}

\maketitle 
\onecolumn
\hrule
\input{../docs/latex/Copyright}
\input{../docs/latex/CopyrightPlan9}
\hrule
\twocolumn


\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\tableofcontents
\endgroup

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

The goal of this book is to explain with full details the source code of
a few {core libraries}.

\section{Motivations}

Why core libraries? Because I think you are a better programmer if
you fully understand how things work under the hood.
% and code in those libs underly everything.
% even sometimes kernel!

% interested mostly C libraries. Also some Asm.
% Linked in all programs.

% Some core components like malloc/free. Essential. Surprisingly
% most people dont know how it works internally.
% Again Google. Facebook have people designing new memory allocator
% (jmealloc, tcmalloc). Core component!

% Unicode also, more recent, again most people dont know. Learn by
% implementation here.

% Finally Thread scheduler. Again if implement lang, and not unusual,
% Erlang, Elixir, Clojure, etc need know very well this stuff.

Here are a few questions I hope this book will answer:
\begin{itemize}

\item Is there any code executed before [[main()]] in a C program?

\item Which program does memory allocation? The kernel? The C library? 
How is [[malloc()]] implemented? 
How it relates to the [[sbrk()]] system call?

\item How does a thread scheduler work? 
How is implemented [[alt()]] without [[select()]] in the kernel?

\end{itemize}
\l sinus, cosinus, how when no hardware support?

\section{The \plan core libraries: [[libc]], [[libregexp]], and [[libthread]]}

% gonna present core libs of plan9, its libc of course, 
% but also its thread libraries,
% regexp, memory managment, unicode, etc.
% most of the generally useful and generic building blocks for regular
% applications!
% X LOC of C and Y LOC of ARM assembly (same amount for other archi).

%see soft archi in Principia and all the boxes for the libc

% also libbio/ (used by a few programs), libstring/ (but seems unused)

\section{Other core libraries}

Here are a few core libraries that I considered for this book but
which I ultimately discarded:
\begin{itemize}

\item GNU Libc
% huge, can't be linked statically

\item dietlibc

\item microlibc

\end{itemize}

% The one from Plauger's book "The Standard C Library"? Full implem?

%other:
% - .NET Core, small set of APIs (primitives, collections, reflection, interop)
% - .NET Standard, bigger set of APIs
%   https://blogs.msdn.microsoft.com/dotnet/2016/09/26/introducing-net-standard/
%   (before was .NET Core, and .NET framework, and Windows Foundation)
%   with Core, Threading, Io, Networking, Serialization, XML
% - Core in MacOSX? 
%mini:
% - libc in dev86
% - muslc
%   
% - libcii, from Hanson book
% - https://github.com/nothings/single_file_libs
%misc:
% - kencc/libmach/ is using netlib/fdlibm
% - public domain C library http://pdclib.e43.eu/

% comparison: http://www.etalabs.net/compare_libcs.html
% musl seems good in this comparison (but they are the author of the comparison)
% https://gist.github.com/cl91/bb927df2525738502131#file-static-linking-against-musl-md


\section{Getting started}

% cd /src/libc
% objtype=arm
%  (if not under ARM archi already)
%  (so we will cross compile ARM libc)
% mk all
% cd /test/5c
% 5l explictly linking C library?


\section{Requirements}

% see intro(2), overview of many libs
% (just like intro(1) is overview of utilities)

\section{About this document}
#include "../docs/latex/About.nw"

\section{Copyright}
\input{../docs/latex/CopyrightPlan9Text}

\section{Acknowledgments}





\chapter{Overview}


\section{Principles}
%\section{Core components}

\subsection{Core versus non-core}
% what is core?

\subsection{User/kernel bridge, system calls}

% each chapter has first section syscall and then build utilities
%  on top of it
%missing syscalls not covered yet: exec, dup, fversion, fauth

\subsection{Memory allocator}
% some parts of code are not allowed to call malloc because calls
% from kernel!

\subsection{Zero-cost abstractions}
% if slow, everything is slow



\section{[[libc.h]] interface}
% in \plan no hundreds of header files (stdio.h, unistd.h, stdlib.h...)
% mostly just libc.h (and u.h).
% other header files are for other libraries: thread.h, regexp.h, draw.h, etc.


\section{Code organization}

% lib_core/libc/9sys/sys.h (part of Kernel.nw)
% include/core/libc.h (and syscall.h I created)


\section{Software architecture}

% note that libc should be thread-safe, malloc use locks!

% take common.ml structure for the TOC of this document?

\section{Book structure}

%###############################################################################

\chapter{Core Types and Data Structures}

\section{Basic types}

% void, int, double, 
% pointer, void*!
% signed vs unsigned, different int size, etc.
% All defined in Compiler.nw but libcore define a few aliases in u.h.

\subsection{Booleans}

<<type bool>>=
typedef int bool;
enum _bool {
  false = 0,
  true = 1
};
@
%pad: I added that. But Pike must agree because they have bools in Go.


\subsection{Integers}

<<type uxxx>>=
typedef unsigned short  ushort;
typedef unsigned char   uchar;
typedef unsigned long   ulong;
typedef unsigned int    uint;
@

<<type uxxxint>>=
typedef unsigned char u8int;
typedef unsigned short u16int;
typedef unsigned int    u32int;
typedef unsigned long long u64int;
@
% ok this deserves to be in arm/u.h


<<type xxxvlong>>=
typedef long long   vlong;
typedef unsigned long long uvlong;
@


% A few convenient aliases
<<type usize>>=
typedef unsigned long   usize;
@


\subsection{Floats}

% in arm/u.h so probably arch specific
<<type FPdbleword>>=
union FPdbleword
{
    double  x;

    struct {    /* little endian */
        ulong lo;
        ulong hi;
    };
};
@

\subsection{Strings and characters}

%http://reedbeta.com/blog/programmers-intro-to-unicode/

\subsubsection{ASCII characters}

% type (unsigned) char

<<type Ctype_flag>>=
#define	_U	01 // upper
#define	_L	02 // lower
#define	_N	04 // number
#define	_S	010 // space
#define	_P	020 // punctuation
#define	_C	040 // ctlr
#define	_B	0100 // ??
#define	_X	0200 // ??
@


<<global _ctype>>=
uchar   _ctype[256] =
{
/*   0   1   2   3   4   5   6   7  */

/*  0*/ _C, _C, _C, _C, _C, _C, _C, _C,
/* 10*/ _C, _S|_C,  _S|_C,  _S|_C,  _S|_C,  _S|_C,  _C, _C,
/* 20*/ _C, _C, _C, _C, _C, _C, _C, _C,
/* 30*/ _C, _C, _C, _C, _C, _C, _C, _C,
/* 40*/ _S|_B,  _P, _P, _P, _P, _P, _P, _P,
/* 50*/ _P, _P, _P, _P, _P, _P, _P, _P,
/* 60*/ _N|_X,  _N|_X,  _N|_X,  _N|_X,  _N|_X,  _N|_X,  _N|_X,  _N|_X,
/* 70*/ _N|_X,  _N|_X,  _P, _P, _P, _P, _P, _P,
/*100*/ _P, _U|_X,  _U|_X,  _U|_X,  _U|_X,  _U|_X,  _U|_X,  _U,
/*110*/ _U, _U, _U, _U, _U, _U, _U, _U,
/*120*/ _U, _U, _U, _U, _U, _U, _U, _U,
/*130*/ _U, _U, _U, _P, _P, _P, _P, _P,
/*140*/ _P, _L|_X,  _L|_X,  _L|_X,  _L|_X,  _L|_X,  _L|_X,  _L,
/*150*/ _L, _L, _L, _L, _L, _L, _L, _L,
/*160*/ _L, _L, _L, _L, _L, _L, _L, _L,
/*170*/ _L, _L, _L, _P, _P, _P, _P, _C,
};
@


<<macros isxxx>>=
#define	isalpha(c)	(_ctype[(unsigned char)(c)]&(_U|_L))
#define	isupper(c)	(_ctype[(unsigned char)(c)]&_U)
#define	islower(c)	(_ctype[(unsigned char)(c)]&_L)
#define	isdigit(c)	(_ctype[(unsigned char)(c)]&_N)
#define	isxdigit(c)	(_ctype[(unsigned char)(c)]&_X)
#define	isspace(c)	(_ctype[(unsigned char)(c)]&_S)
#define	ispunct(c)	(_ctype[(unsigned char)(c)]&_P)
#define	isalnum(c)	(_ctype[(unsigned char)(c)]&(_U|_L|_N))
#define	isprint(c)	(_ctype[(unsigned char)(c)]&(_P|_U|_L|_N|_B))
#define	isgraph(c)	(_ctype[(unsigned char)(c)]&(_P|_U|_L|_N))
#define	iscntrl(c)	(_ctype[(unsigned char)(c)]&_C)
#define	isascii(c)	((unsigned char)(c)<=0177)
@


% ugly that take an int, because that way compatible with Rune??
<<function toupper>>=
int
toupper(int c)
{

    if(c < 'a' || c > 'z')
        return c;
    return _toupper(c);
}
@

<<macro _toupper>>=
#define	_toupper(c)	((c)-'a'+'A')
@

<<function tolower>>=
int
tolower(int c)
{

    if(c < 'A' || c > 'Z')
        return c;
    return _tolower(c);
}
@

<<macro _tolower>>=
#define	_tolower(c)	((c)-'A'+'a')
@


% ???
<<macro toascii>>=
#define	toascii(c)	((c)&0177)
@

\subsubsection{Runes}

% aka code points in unicode terminology? 32 bits integers.
% or rune is already smaller?

% char =~ byte

<<type Rune>>=
typedef uint        Rune;
@

<<constant Runemax>>=
Runemax     = 0x10FFFF, /* 21-bit rune */
@
% see limit at https://en.wikipedia.org/wiki/Code_point

<<constant Runemask>>=
Runemask    = 0x1FFFFF, /* bits used by runes (see grep) */
@

\subsubsection{UTF8}

% utf(6)
% rune(2)

% typedef char* utf; ?

% diff with Rune? why we have some utfxxx and runexxx functions/?
% utf-8 is compact encoding of unicode characters (runes).


<<constant UTFmax>>=
UTFmax      = 4,        /* maximum bytes per rune */
@
<<constant Runesync>>=
Runesync    = 0x80,     /* cannot represent part of a UTF sequence (<) */
@
<<constant Runeself>>=
Runeself    = 0x80,     /* rune and UTF sequences are the same (<) */
@

<<constant Runeerror>>=
Runeerror   = 0xFFFD,   /* decoding error in UTF */
@

\section{Complex types}

\subsection{Pointers}

<<constant nil>>=
#define nil     ((void*)0)
@
% why in u.h? could be in libc.h no?

<<type uintptr>>=
typedef unsigned long   uintptr;
@

<<type byte>>=
typedef uchar byte;
@
% and byte*

\subsection{Arrays}

<<function nelem>>=
#define nelem(x)    (sizeof(x)/sizeof((x)[0]))
@


<<type Sort>>=
typedef
struct
{
    int (*cmp)(void*, void*);
    void    (*swap)(char*, char*, long);
    long    es;
} Sort;
@

<<function qsort>>=
void
qsort(void *va, long n, long es, int (*cmp)(void*, void*))
{
    Sort s;

    s.cmp = cmp;
    s.es = es;
    s.swap = swapi;
    if(((uintptr)va | es) % sizeof(long))
        s.swap = swapb;
    qsorts((char*)va, n, &s);
}
@

<<function swapb>>=
static  void
swapb(char *i, char *j, long es)
{
    char c;

    do {
        c = *i;
        *i++ = *j;
        *j++ = c;
        es--;
    } while(es != 0);

}
@

<<function swapi>>=
static  void
swapi(char *ii, char *ij, long es)
{
    long *i, *j, c;

    i = (long*)ii;
    j = (long*)ij;
    do {
        c = *i;
        *i++ = *j;
        *j++ = c;
        es -= sizeof(long);
    } while(es != 0);
}
@

<<function pivot>>=
static  char*
pivot(char *a, long n, Sort *p)
{
    long j;
    char *pi, *pj, *pk;

    j = n/6 * p->es;
    pi = a + j; /* 1/6 */
    j += j;
    pj = pi + j;    /* 1/2 */
    pk = pj + j;    /* 5/6 */
    if(p->cmp(pi, pj) < 0) {
        if(p->cmp(pi, pk) < 0) {
            if(p->cmp(pj, pk) < 0)
                return pj;
            return pk;
        }
        return pi;
    }
    if(p->cmp(pj, pk) < 0) {
        if(p->cmp(pi, pk) < 0)
            return pi;
        return pk;
    }
    return pj;
}
@

<<function qsorts>>=
static  void
qsorts(char *a, long n, Sort *p)
{
    long j, es;
    char *pi, *pj, *pn;

    es = p->es;
    while(n > 1) {
        if(n > 10) {
            pi = pivot(a, n, p);
        } else
            pi = a + (n>>1)*es;

        p->swap(a, pi, es);
        pi = a;
        pn = a + n*es;
        pj = pn;
        for(;;) {
            do
                pi += es;
            while(pi < pn && p->cmp(pi, a) < 0);
            do
                pj -= es;
            while(pj > a && p->cmp(pj, a) > 0);
            if(pj < pi)
                break;
            p->swap(pi, pj, es);
        }
        p->swap(a, pj, es);
        j = (pj - a) / es;

        n = n-j-1;
        if(j >= n) {
            qsorts(a, j, p);
            a += (j+1)*es;
        } else {
            qsorts(a + (j+1)*es, n, p);
            n = j;
        }
    }
}
@


\subsection{Structures}

<<function offsetof>>=
#define offsetof(s, m)  (ulong)(&(((s*)nil)->m))
@

\subsection{Functions}

<<type va_list>>=
typedef char*   va_list;
@

<<macro va_start>>=
#define va_start(list, start) list =\
    (sizeof(start) < 4?\
        (char*)((int*)&(start)+1):\
        (char*)(&(start)+1))
@

<<macro va_end>>=
#define va_end(list)\
    USED(list)
@
<<macro va_arg>>=
#define va_arg(list, mode)\
    ((sizeof(mode) == 1)?\
        ((list += 4), (mode*)list)[-4]:\
    (sizeof(mode) == 2)?\
        ((list += 4), (mode*)list)[-2]:\
        ((list += sizeof(mode)), (mode*)list)[-1])
@

%related: getcallerpc

% Fcall here?

%\section{Memory pool}
% More in memory management chapter

\section{Regular expression}
% more in Regexp chapter

% string, see special chapter

%\section{Fmt}
% regexp =~ for structured input
% fmt =~ for structured output

\section{Files}

<<type fdt>>=
typedef int fdt; // file descriptor type
@
%pad: I added that. More explicit, better signatures. abusing int is bad.

<<constant STDxxx>>=
#define STDIN 0
#define STDOUT 1
#define STDERR 2
@
%pad: I added that, but is in APE also

\section{Time}
% Tm

<<type Tm>>=
struct Tm {
    int sec;
    int min;
    int hour;

    int mday;
    int mon;
    int year;
    int wday;
    int yday;

    char    zone[4];
    int     tzoff;
};
@
% some redundant stuff above?

\section{Concurrency}

%\subsection{Locks}
% normal, read-write

%\subsection{Queues}

%\subsection{Rendez-vous}

%\subsection{Waitmsg}

%\subsection{Channels}

\section{[[Fcall]]}

% related to concurrency.

\section{Collections}

% collection types (not really :( ) 

% Surprisingly libc does not prescribe any collection Ds.
% This is why lots of \plan programs have duplicate code to
% represent hash table, growing arrays, lists, queues, etc.

% array and pointers are enough to encode most things
% (but because array is a form of pointer, really it's pointers)

% No collection but with arrays, pointers, structures, and union, flexible,
% can do a lot.

% % can provide template on how they encode lists, hashs, queues,
% double linked lists, trees, etc. 
% See kernel.nw for instance, many example of collections.

%\section{Misc}
% lots of small enums for Open_flag, Dir_flag, Rfork_flag, profiling
% which are presented later


\chapter{[[_main()]]}

% arm/main9.s (and main9p.s)

%related: minimal C runtime for Linux
%https://github.com/lpsantil/rt0
%https://blogs.oracle.com/ksplice/entry/hello_from_a_libc_free

%real-world: crt0 for "C runtime 0"?

\section{Command-line arguments: [[ARGBEGIN()]], [[ARGEND()]]}

<<signature global argv0>>=
extern char *argv0;
@

<<macro ARGBEGIN>>=
#define ARGBEGIN    for((argv0||(argv0=*argv)),argv++,argc--;\
                argv[0] && argv[0][0]=='-' && argv[0][1];\
                argc--, argv++) {\
                char *_args, *_argt;\
                Rune _argc;\
                _args = &argv[0][1];\
                if(_args[0]=='-' && _args[1]==0){\
                    argc--; argv++; break;\
                }\
                _argc = 0;\
                while(*_args && (_args += chartorune(&_argc, _args)))\
                switch(_argc)
@
% unicode handling!

<<macro ARGEND>>=
#define ARGEND      SET(_argt);USED(_argt,_argc,_args);}USED(argv, argc);
@


<<macro ARGF>>=
#define ARGF()      (_argt=_args, _args="",\
                (*_argt? _argt: argv[1]? (argc--, *++argv): 0))
@

<<macro EARGF>>=
#define EARGF(x)    (_argt=_args, _args="",\
                (*_argt? _argt: argv[1]? (argc--, *++argv): ((x), abort(), (char*)0)))
@
% Error-aware ARGF

<<macro ARGC>>=
#define ARGC()      _argc
@

\section{syscall: [[_exits()]]}

% ugly but special code in 9syscall/mkfile to rename call to 
% EXITS syscall to _exits instead of exits because probably wanted to
% add special code around _exits after and wanted to be backward
% compatible with previous programs already using exits() in their code.

\section{[[exits()]]}

% profile is turned off around this function
<<function exits>>=
void
exits(char *s)
{
    int i, pid;
    void (*f)(void);

    pid = getpid();
    for(i = NEXIT-1; i >= 0; i--)
        if((f = onex[i].f) && pid == onex[i].pid) {
            onex[i].f = nil;
            (*f)();
        }
    _exits(s);
}
@

<<global onex>>=
Onex onex[NEXIT];
@
<<constant NEXIT>>=
#define NEXIT   33
@

<<struct Onex>>=
struct Onex{
    void    (*f)(void);
    int pid;
};
@
% Onex.pid because some fork can still share memory
% but we want each fork to run separate callbacks when really
% exits.

<<global onexlock>>=
static Lock onexlock;
@
% See Section X for concurrency primitives.


<<function atexit>>=
int
atexit(void (*f)(void))
{
    int i;

    lock(&onexlock);
    for(i=0; i<NEXIT; i++)
        if(onex[i].f == nil) {
            onex[i].pid = getpid();
            onex[i].f = f;
            unlock(&onexlock);
            return 1;
        }
    unlock(&onexlock);
    return 0;
}
@

%dead:
%<<function atexitdont>>=
%void
%atexitdont(void (*f)(void))
%{
%    int i, pid;
%
%    pid = getpid();
%    for(i=0; i<NEXIT; i++)
%        if(onex[i].f == f && onex[i].pid == pid)
%            onex[i].f = 0;
%}
%@

\chapter{User/Kernel Bridge}

% sys.h, syscall.h
% lib_core/libc/9syscall/*.s and dispatcher in kernel for the sysxxx().
% FIGURE copy one in Principia.nw?


\chapter{Memory Area Operations}

% Lots of functions defined in assembly, so maximal control, maximal opti.
% Important cos used a lot.
% But also many portable (slower) implem in libc/port/

<<function memset>>=
void*
memset(void *ap, int c, ulong n)
{
    char *p;

    p = ap;
    while(n > 0) {
        *p++ = c;
        n--;
    }
    return ap;
}
@
% typing issue in *p++ = c? int vs char*? if set -1, it will work.
% memset(,255,) and memset(,-1,) should be equivalent.
% Why pass an int and not a char? Because passing 32 bits arguments
% is faster! Accessing full words is faster.

% This is why not optimal code above, and real memset is written in
% assembly and tries to move by blocks of 32 bits chunk, not 
% 8 bits.


<<function memcpy>>=
void*
memcpy(void *a1, void *a2, ulong n)
{
    return memmove(a1, a2, n);
}
@


<<function memmove>>=
void*
memmove(void *a1, void *a2, ulong n)
{
    char *s1, *s2;

    if((long)n < 0)
        abort();
    s1 = a1;
    s2 = a2;
    if((s2 < s1) && (s2+n > s1))
        goto back;
    while(n > 0) {
        *s1++ = *s2++;
        n--;
    }
    return a1;

back:
    s1 += n;
    s2 += n;
    while(n > 0) {
        *--s1 = *--s2;
        n--;
    }
    return a1;
}
@
% really bad name
\t replace every call to memmove to memcpy!


<<function memcmp>>=
int
memcmp(void *a1, void *a2, ulong n)
{
    uchar *s1, *s2;
    uint c1, c2;

    s1 = a1;
    s2 = a2;
    while(n > 0) {
        c1 = *s1++;
        c2 = *s2++;
        if(c1 != c2) {
            if(c1 > c2)
                return 1;
            return -1;
        }
        n--;
    }
    return 0;
}
@

<<function memchr>>=
void*
memchr(void *ap, int c, ulong n)
{
    uchar *sp;

    sp = ap;
    c &= 0xFF;
    while(n > 0) {
        if(*sp++ == c)
            return sp-1;
        n--;
    }
    return nil;
}
@



\chapter{Memory Management}

%http://marek.vavrusa.com/c/memory/2015/02/20/memory/

%https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/

% http://jamesgolick.com/2013/5/15/memory-allocators-101.html
% http://jamesgolick.com/2013/5/19/how-tcmalloc-works.html

% http://danluu.com/malloc-tutorial/

%http://blog.httrack.com/blog/2014/04/05/a-story-of-realloc-and-laziness/

%http://bitsquid.blogspot.com/2015/08/allocation-adventures-3-buddy-allocator.html

% 4 basic allocators:
%http://vicsydev.blogspot.com/2016/11/the-malloc-challenge.html

%survey of allocators literature:
%http://www.cs.northwestern.edu/~pdinda/ics-s05/doc/dsa.pdf

% many more allocators:
% - jmalloc
% - the one from google
% - http://swapped.cc/#!/halloc
% - talloc (in petitboot) from Samba
% - rpmalloc a lock free allocator
%   https://github.com/rampantpixels/rpmalloc
% mallo.c and pool.c!

\section{Syscall: [[brk()]]}
% sysbrk()

\section{[[sbrk()]]}

% in 9sys/

<<global bloc>>=
// starting point for the heap, after the text, data, and bss.
static  char    *bloc = { end };
@
% [[end]], see \book{Linker}

<<function sbrk>>=
void*
sbrk(ulong n)
{
    uintptr bl;

    bl = ((uintptr)bloc + Round) & ~Round;
    if(brk((void*)(bl+n)) < 0)
        return (void*)-1;
    bloc = (char*)bl + n;
    return (void*)bl;
}
@
% classic idiom x + Y & ~Y.
% use macro? roundup?

<<enum _anon_ (9sys/sbrk.c)>>=
enum
{
    Round   = 7
};
@


\section{Data structures}

\subsection{[[Pool]]}

<<type Pool>>=
struct Pool {
 char*	name;
 ulong	maxsize;

 ulong	cursize;
 ulong	curfree;
 ulong	curalloc;

 ulong	minarena;	/* smallest size of new arena */
 ulong	quantum;	/* allocated blocks should be multiple of */
 ulong	minblock;	/* smallest newly allocated block */

 void*	freeroot;	/* actually Free* */
 void*	arenalist;	/* actually Arena* */

 void*	(*alloc)(ulong);
 int	    (*merge)(void*, void*);
 void	(*move)(void* from, void* to);

 int	flags;
 int	nfree;
 int	lastcompact;

 void	(*lock)(Pool*);
 void	(*unlock)(Pool*);
 void	(*print)(Pool*, char*, ...);
 void	(*panic)(Pool*, char*, ...);
 void	(*logstack)(Pool*);

 void*	private;
};
@

<<type Pool_flag>>=
enum Pool_flag {	/* flags */
 POOL_ANTAGONISM	= 1<<0,
 POOL_PARANOIA	= 1<<1,
 POOL_VERBOSITY	= 1<<2,
 POOL_DEBUGGING	= 1<<3,
 POOL_LOGGING	= 1<<4,
 POOL_TOLERANCE	= 1<<5,
 POOL_NOREUSE	= 1<<6,
};
@


<<struct Private>>=
struct Private {
    Lock    lk;
    int     pid;
    int     printfd;    /* gets debugging output if set */
};
@

<<global sbrkmempriv>>=
Private sbrkmempriv;
@

\subsection{[[sbrkmem]]}

% in malloc.c
<<global sbrkmem>>=
static Pool sbrkmem = {
    .name=      "sbrkmem",
    .maxsize=   (3840UL-1)*1024*1024,   /* up to ~0xf0000000 */
    .minarena=  4*1024,
    .quantum=   32,
    .alloc=     sbrkalloc,
    .merge=     sbrkmerge,
    .flags=     0,

    .lock=      plock,
    .unlock=        punlock,
    .print=     pprint,
    .panic=     ppanic,
    .private=       &sbrkmempriv,
};
@

<<global mainmem>>=
Pool *mainmem = &sbrkmem;
@

<<global imagmem>>=
Pool *imagmem = &sbrkmem;
@

\subsection{XXX}

% in pool.c

<<struct Bhdr>>=
struct Bhdr {
    ulong   magic;
    ulong   size;
};
@

<<enum _anon_ (port/pool.c)>>=
enum {
    NOT_MAGIC = 0xdeadfa11,
    DEAD_MAGIC = 0xdeaddead,
};
@

<<macro B2NB>>=
#define B2NB(b) ((Bhdr*)((uchar*)(b)+(b)->size))
@

<<macro SHORT>>=
#define SHORT(x) (((x)[0] << 8) | (x)[1])
@

<<macro PSHORT>>=
#define PSHORT(p, x) \
    (((uchar*)(p))[0] = ((x)>>8)&0xFF, \
    ((uchar*)(p))[1] = (x)&0xFF)
@

<<enum _anon_ (port/pool.c)2>>=
enum {
    TAIL_MAGIC0 = 0xBE,
    TAIL_MAGIC1 = 0xEF
};
@

<<struct Btail>>=
struct Btail {
    uchar   magic0;
    uchar   datasize[2];
    uchar   magic1;
    ulong   size;   /* same as Bhdr->size */
};
@

<<macro B2T>>=
#define B2T(b)  ((Btail*)((uchar*)(b)+(b)->size-sizeof(Btail)))
@

<<macro B2PT>>=
#define B2PT(b) ((Btail*)((uchar*)(b)-sizeof(Btail)))
@

<<macro T2HDR>>=
#define T2HDR(t) ((Bhdr*)((uchar*)(t)+sizeof(Btail)-(t)->size))
@

<<struct Free>>=
struct Free {
            Bhdr;
    Free*   left;
    Free*   right;
    Free*   next;
    Free*   prev;
};
@

<<enum _anon_ (port/pool.c)3>>=
enum {
    FREE_MAGIC = 0xBA5EBA11,
};
@

<<struct Alloc>>=
/*
 * the point of the notused fields is to make 8c differentiate
 * between Bhdr and Allocblk, and between Kempt and Unkempt.
 */
struct Alloc {
            Bhdr;
};
@

<<enum _anon_ (port/pool.c)4>>=
enum {
    ALLOC_MAGIC = 0x0A110C09,
    UNALLOC_MAGIC = 0xCAB00D1E+1,
};
@

<<struct Arena>>=
struct Arena {
            Bhdr;
    Arena*  aup;
    Arena*  down;
    ulong   asize;
    ulong   pad;    /* to a multiple of 8 bytes */
};
@

<<enum _anon_ (port/pool.c)5>>=
enum {
    ARENA_MAGIC = 0xC0A1E5CE+1,
    ARENATAIL_MAGIC = 0xEC5E1A0C+1,
};
@

<<macro A2TB>>=
#define A2TB(a) ((Bhdr*)((uchar*)(a)+(a)->asize-sizeof(Bhdr)))
@

<<macro A2B>>=
#define A2B(a)  B2NB(a)
@

<<enum _anon_ (port/pool.c)6>>=
enum {
    ALIGN_MAGIC = 0xA1F1D1C1,
};
@

<<enum _anon_ (port/pool.c)7>>=
enum {
    MINBLOCKSIZE = sizeof(Free)+sizeof(Btail)
};
@

<<global datamagic>>=
static uchar datamagic[] = { 0xFE, 0xF1, 0xF0, 0xFA };
@

<<constant Poison>>=
#define Poison  (void*)0xCafeBabe
@

<<macro _B2D>>=
#define _B2D(a) ((void*)((uchar*)a+sizeof(Bhdr)))
@

<<macro _D2B>>=
#define _D2B(v) ((Alloc*)((uchar*)v-sizeof(Bhdr)))
@


\section{[[malloc()]]}

<<function malloc>>=
void*
malloc(ulong size)
{
    void *v;

    v = poolalloc(mainmem, size+Npadlong*sizeof(ulong));
    if(Npadlong && v != nil) {
        v = (ulong*)v+Npadlong;
        setmalloctag(v, getcallerpc(&size));
        setrealloctag(v, 0);
    }
    return v;
}
@

\section{[[free()]]}

<<function free>>=
void
free(void *v)
{
    if(v != nil)
        poolfree(mainmem, (ulong*)v-Npadlong);
}
@

\section{Debugging support}

\section{Advanced topics}


\chapter{Strings}

%todo: introduce a string_equal, and most of the time rewrite
% strcmp as !string_equal; far more readable!
% look at go or rust stdlibs for inspiration for good names.

% Note that there is also a libstring/ but seems unused.

%\section{Conversions}
% see Mathematics section and Parsing subsections

\section{Plain C strings}

% C strings. end of string marked with null character.

% copy, search, len, etc.

<<function strlen>>=
long
strlen(char *s)
{

    return strchr(s, '\0') - s;
}
@
%pad: I prefer '\0' to 0


<<function strcat>>=
char*
strcat(char *s1, char *s2)
{

    strcpy(strchr(s1, '\0'), s2);
    return s1;
}
@

<<function strchr>>=
char*
strchr(char *s, int c)
{
    char c0 = c;
    char c1;

    if(c == '\0') {
        while(*s++)
            ;
        return s-1;
    }

    while(c1 = *s++)
        if(c1 == c0)
            return s-1;
    return nil;
}
@

<<function strrchr>>=
char*
strrchr(char *s, int c)
{
    char *r;

    if(c == '\0')
        return strchr(s, '\0');

    r = 0;
    while(s = strchr(s, c))
        r = s++;
    return r;
}
@


%todo: rename temporarily to _strcmp and have a string_equal wrapper 
% and refactor code using spatch!

<<function strcmp>>=
int
strcmp(char *s1, char *s2)
{
    unsigned c1, c2;

    for(;;) {
        c1 = *s1++;
        c2 = *s2++;
        if(c1 != c2) {
            if(c1 > c2)
                return 1;
            return -1;
        }
        if(c1 == 0)
            return 0;
    }
}
@


<<constant N>>=
#define N   10000
@

<<function strcpy>>=
char*
strcpy(char *s1, char *s2)
{
    char *os1;

    os1 = s1;
    while(!memccpy(s1, s2, 0, N)) {
        s1 += N;
        s2 += N;
    }
    return os1;
}
@
% ???

% used by strcpy and clones
<<function memccpy>>=
void*
memccpy(void *a1, void *a2, int c, ulong n)
{
    uchar *s1, *s2;

    s1 = a1;
    s2 = a2;
    c &= 0xFF;
    while(n > 0) {
        if((*s1++ = *s2++) == c)
            return s1;
        n--;
    }
    return nil;
}
@




<<function strdup>>=
char*
strdup(char *s) 
{  
    char *ns;

    ns = malloc(strlen(s) + 1);
    if(ns == nil)
        return nil;
    setmalloctag(ns, getcallerpc(&s));

    return strcpy(ns, s);
}
@



<<function strstr>>=
/*
 * Return pointer to first occurrence of s2 in s1,
 * 0 if none
 */
char*
strstr(char *s1, char *s2)
{
    char *p, *pa, *pb;
    int c0, c;

    c0 = *s2;
    if(c0 == 0)
        return s1;
    s2++;
    for(p=strchr(s1, c0); p; p=strchr(p+1, c0)) {
        pa = p;
        for(pb=s2;; pb++) {
            c = *pb;
            if(c == 0)
                return p;
            if(c != *++pa)
                break;
        }
    }
    return 0;
}
@
% a classic interview question :)

\section{Runes}

%see utf.ps

% _base2 in Libcore_big.nw

<<function tobaserune>>=
Rune
tobaserune(Rune c)
{
    Rune *p;

    p = _runebsearch(c, _base2, nelem(_base2)/2, 2);
    if(p && c == p[0])
        c = p[1];
    return c;
}
@
% ?? baserune?

<<function isbaserune>>=
int
isbaserune(Rune c)
{
    return tobaserune(c) == c;
}
@


% port/runetype.c

%Rune*_runebsearch(Rune c, Rune *t, int n, int ne);
%
%#include "runetypebody-6.2.0.h"


<<function _runebsearch>>=
Rune*
_runebsearch(Rune c, Rune *t, int n, int ne)
{
    Rune *p;
    int m;

    while(n > 1) {
        m = n/2;
        p = t + m*ne;
        if(c >= p[0]) {
            t = p;
            n = n-m;
        } else
            n = m;
    }
    if(n && c >= t[0])
        return t;
    return 0;
}
@



\subsection{Conversion}


<<macro Bit>>=
#define Bit(i) (7-(i))
@

<<macro T>>=
/* N 0's preceded by i 1's, T(Bit(2)) is 1100 0000 */
#define T(i) (((1 << (Bit(i)+1))-1) ^ 0xFF)
@
% >> 

<<macro RuneX>>=
/* 0000 0000 0000 0111 1111 1111 */
#define RuneX(i) ((1 << (Bit(i) + ((i)-1)*Bitx))-1)
@
% >> >> 

% assume str can be utf string!
% so it is really more utftorune

<<function chartorune>>=
int
chartorune(Rune *rune, char *str)
{
    int c[UTFmax], i;
    Rune l;

    /*
     * N character sequence
     *  00000-0007F => T1
     *  00080-007FF => T2 Tx
     *  00800-0FFFF => T3 Tx Tx
     *  10000-10FFFF => T4 Tx Tx Tx
     */

    c[0] = *(uchar*)(str);
    if(c[0] < Tx){
        *rune = c[0];
        return 1;
    }
    l = c[0];

    for(i = 1; i < UTFmax; i++) {
        c[i] = *(uchar*)(str+i);
        c[i] ^= Tx;
        if(c[i] & Testx)
            goto bad;
        l = (l << Bitx) | c[i];
        if(c[0] < T(i + 2)) {
            l &= RuneX(i + 1);
            if(i == 1) {
                if(c[0] < T(2) || l <= Rune1)
                    goto bad;
            } else if(l <= RuneX(i) || l > Runemax)
                goto bad;
            if (i == 2 && SurrogateMin <= l && l <= SurrogateMax)
                goto bad;
            *rune = l;
            return i + 1;
        }
    }

    /*
     * bad decoding
     */
bad:
    *rune = Bad;
    return 1;
}
@
% >> >> >> >> >>

% should rename runetobytes or runetoutf
<<function runetochar>>=
int
runetochar(char *str, Rune *rune)
{
    int i, j;
    Rune c;

    c = *rune;
    if(c <= Rune1) {
        str[0] = c;
        return 1;
    }

    /*
     * one character sequence
     *  00000-0007F => 00-7F
     * two character sequence
     *  0080-07FF => T2 Tx
     * three character sequence
     *  0800-FFFF => T3 Tx Tx
     * four character sequence (21-bit value)
     *     10000-1FFFFF => T4 Tx Tx Tx
     * If the Rune is out of range or a surrogate half,
     * convert it to the error rune.
     * Do this test when i==3 because the error rune encodes to three bytes.
     * Doing it earlier would duplicate work, since an out of range
     * Rune wouldn't have fit in one or two bytes.
     */
    for(i = 2; i < UTFmax + 1; i++){
        if(i == 3){
            if(c > Runemax)
                c = Runeerror;
            if(SurrogateMin <= c && c <= SurrogateMax)
                c = Runeerror;
        }
        if (c <= RuneX(i) || i == UTFmax ) {
            str[0] = T(i) |  (c >> (i - 1)*Bitx);
            for(j = 1; j < i; j++)
                str[j] = Tx | ((c >> (i - j - 1)*Bitx) & Maskx);
            return i;
        }
    }
    return UTFmax;
}
@

\subsection{Basics}

<<function runestrlen>>=
long
runestrlen(Rune *s)
{

    return runestrchr(s, 0) - s;
}
@
% this time I prefer 0 not '\0' because runes are really an
% array of integers (not chars)

<<function runestrcpy>>=
Rune*
runestrcpy(Rune *s1, Rune *s2)
{
    Rune *os1;

    os1 = s1;
    while(*s1++ = *s2++)
        ;
    return os1;
}
@

<<function runestrcmp>>=
int
runestrcmp(Rune *s1, Rune *s2)
{
    Rune c1, c2;

    for(;;) {
        c1 = *s1++;
        c2 = *s2++;
        if(c1 != c2) {
            if(c1 > c2)
                return 1;
            return -1;
        }
        if(c1 == 0)
            return 0;
    }
}
@


<<function runestrchr>>=
Rune*
runestrchr(Rune *s, Rune c)
{
    Rune c0 = c;
    Rune c1;

    if(c == 0) {
        while(*s++)
            ;
        return s-1;
    }

    while(c1 = *s++)
        if(c1 == c0)
            return s-1;
    return nil;
}
@

<<function runestrrchr>>=
Rune*
runestrrchr(Rune *s, Rune c)
{
    Rune *r;

    if(c == 0)
        return runestrchr(s, 0);
    r = 0;
    while(s = runestrchr(s, c))
        r = s++;
    return r;
}
@




<<function runestrdup>>=
Rune*
runestrdup(Rune *s) 
{  
    Rune *ns;

    ns = malloc(sizeof(Rune)*(runestrlen(s) + 1));
    if(ns == nil)
        return nil;
    setmalloctag(ns, getcallerpc(&s));

    return runestrcpy(ns, s);
}
@

<<function runestrcat>>=
Rune*
runestrcat(Rune *s1, Rune *s2)
{

    runestrcpy(runestrchr(s1, 0), s2);
    return s1;
}
@



<<function runestrstr>>=
/*
 * Return pointer to first occurrence of s2 in s1,
 * 0 if none
 */
Rune*
runestrstr(Rune *s1, Rune *s2)
{
    Rune *p, *pa, *pb;
    int c0, c;

    c0 = *s2;
    if(c0 == 0)
        return s1;
    s2++;
    for(p=runestrchr(s1, c0); p; p=runestrchr(p+1, c0)) {
        pa = p;
        for(pb=s2;; pb++) {
            c = *pb;
            if(c == 0)
                return p;
            if(c != *++pa)
                break;
        }
    }
    return nil;
}
@


\section{UTF}

% use typedef utf here? utf* s?
<<function utflen>>=
int
utflen(char *s)
{
    int c;
    long n;
    Rune rune;

    n = 0;
    for(;;) {
        c = *(uchar*)s;
        if(c < Runeself) {
            if(c == '\0')
                return n;
            s++;
        } else
            s += chartorune(&rune, s);
        n++;
    }
}
@
% strlen will not work on utf char?

% look if a character in a set of chars in s (can be utf chars)
% is equal to the rune C.
% Or look if rune C is part of utf sequence s.

<<function utfrune>>=
char*
utfrune(char *s, long c)
{
    long c1;
    Rune r;
    int n;

    if(c < Runesync)        /* not part of utf sequence */
        return strchr(s, c);

    for(;;) {
        c1 = *(uchar*)s;
        if(c1 < Runeself) { /* one byte rune */
            if(c1 == 0)
                return nil;
            if(c1 == c)
                return s;
            s++;
            continue;
        }
        n = chartorune(&r, s);
        if(r == c)
            return s;
        s += n;
    }
}
@
\t long c -> Rune c? why long?

% look if rune C is inside utf sequence s, in reverse (hence strrchr below)
<<function utfrrune>>=
char*
utfrrune(char *s, long c)
{
    long c1;
    Rune r;
    char *s1;

    if(c < Runesync)        /* not part of utf sequence */
        return strrchr(s, c);

    s1 = 0;
    for(;;) {
        c1 = *(uchar*)s;
        if(c1 < Runeself) { /* one byte rune */
            if(c1 == 0)
                return s1;
            if(c1 == c)
                s1 = s;
            s++;
            continue;
        }
        c1 = chartorune(&r, s);
        if(r == c)
            s1 = s;
        s += c1;
    }
}
@



<<function utfutf>>=
/*
 * Return pointer to first occurrence of s2 in s1,
 * 0 if none
 */
char*
utfutf(char *s1, char *s2)
{
    char *p;
    long f, n1, n2;
    Rune r;

    n1 = chartorune(&r, s2);
    f = r;
    if(f <= Runesync)       /* represents self */
        return strstr(s1, s2);

    n2 = strlen(s2);
    for(p=s1; p=utfrune(p, f); p+=n1)
        if(strncmp(p, s2, n2) == 0)
            return p;
    return 0;
}
@

\section{Formatted Output}
% printf style output

%printf
% https://github.com/wkoszek/mini_printf

%alt: overloading and show as in haskell

<<type Fmt>>=
struct Fmt {
    uchar   runes;          /* output buffer is runes or chars? */

    void    *start;         /* of buffer */
    void    *to;            /* current place in the buffer */
    void    *stop;          /* end of the buffer; overwritten if flush fails */

    int     (*flush)(Fmt *);    /* called when to == stop */
    void    *farg;          /* to make flush a closure */
    int     nfmt;           /* num chars formatted so far */

    va_list args;           /* args passed to dofmt */

    int     r;          /* % format Rune */
    int     width;
    int     prec;
    ulong   flags;
};
@

<<type Fmt_flag>>=
enum Fmt_flag {
    FmtWidth    = 1,
    FmtLeft     = FmtWidth << 1,
    FmtPrec     = FmtLeft << 1,
    FmtSharp    = FmtPrec << 1,
    FmtSpace    = FmtSharp << 1,
    FmtSign     = FmtSpace << 1,
    FmtZero     = FmtSign << 1,
    FmtUnsigned = FmtZero << 1,
    FmtShort    = FmtUnsigned << 1,
    FmtLong     = FmtShort << 1,
    FmtVLong    = FmtLong << 1,
    FmtComma    = FmtVLong << 1,
    FmtByte     = FmtComma << 1,

    FmtFlag     = FmtByte << 1
};
@


\section{Quoted strings}
% put in advcanced topics?

\chapter{Regular Expressions}
% libregexp/



\chapter{IO}

% See file descriptor type in core DS.

\section{Data structures}

<<type Open_flag>>=
// enum Open_flag, open parameter
#define	OREAD	0	/* open for read */
#define	OWRITE	1	/* write */
#define	ORDWR	2	/* read and write */
#define	OEXEC	3	/* execute, == read but check execute permission */
// advanced stuff
#define	OTRUNC	16	/* or'ed in (except for exec), truncate file first */
#define	OCEXEC	32	/* or'ed in, close on exec */
#define	ORCLOSE	64	/* or'ed in, remove on close */
#define	OEXCL	0x1000	/* or'ed in, exclusive use (create only) */
@
%dead:// #define	OBEHIND	0x2000	/* use write behind for writes [for 9n] */

<<type Access_flag>>=
// enum Access_flag
#define	AEXIST	0	/* accessible: exists */
#define	AEXEC	1	/* execute access */
#define	AWRITE	2	/* write access */
#define	AREAD	4	/* read access */
@

<<type Qid>>=
// Qid as in uniQue id
struct Qid {
 uvlong	path;
 ulong	vers;
    // bitset<Qidtype>
 uchar	type;
};
@


<<type Qid_type>>=
/* bits in Qid.type */
#define QTFILE		0x00		/* plain file */
#define QTDIR		0x80		/* type bit for directories */
// advanced stuff
#define QTAPPEND	0x40		/* type bit for append only files */
#define QTEXCL		0x20		/* type bit for exclusive use files */
#define QTMOUNT		0x10		/* type bit for mounted channel */
#define QTAUTH		0x08		/* type bit for authentication file */
#define QTTMP		0x04		/* type bit for not-backed-up file */
@

<<type Seek_cursor>>=
// pad's stuff (but it is actually also in stdio.h)
enum Seek_cursor {
    SEEK__START = 0,
    SEEK__CUR = 1,
    SEEK__END = 2,
};
@
%pad: I added that

\section{Syscalls: [[open()]], [[pread()]], etc}

% sysopen(), sysclose(), sysread(), syswrite(), sysseek(), etc
% file, directory, namespace

% why pread? does seek and read at the same time, so atomic,
% which is useful for servers.

\section{[[read()]], [[write()]]}

<<function read>>=
long
read(fdt fd, void *buf, long n)
{
    return pread(fd, buf, n, -1LL);
}
@

<<function write>>=
long
write(fdt fd, void *buf, long n)
{
    return pwrite(fd, buf, n, -1LL);
}
@

\section{[[readn()]], [[writen()]]}

<<function readn>>=
long
readn(fdt f, void *av, long n)
{
    char *a;
    long m, t;

    a = av;
    t = 0;
    while(t < n){
        m = read(f, a+t, n-t);
        if(m <= 0){
            if(t == 0)
                return m;
            break;
        }
        t += m;
    }
    return t;
}
@

\t why need that? read not good?

\chapter{Directory}

\section{Data structures, [[Dir]]}

<<type DirEntry>>=
// a similar structure is defined in the kernel!
struct Dir {
 /* system-modified data */
 ushort	type;	/* server type */
 uint	dev;	/* server subtype */

 /* file data */
 Qid	qid;	/* unique id from server */

 ulong	mode;	/* permissions */
 ulong	atime;	/* last read time */
 ulong	mtime;	/* last write time */
 vlong	length;	/* file length */
 char	*name;	/* last element of path */

 char	*uid;	/* owner name */
 char	*gid;	/* group name */
 char	*muid;	/* last modifier name */
};
@
\t TODO should be renamed DirEntry really

<<type Dir_mode>>=
/* bits in Dir.mode */
#define DMDIR		0x80000000	/* mode bit for directories */
#define DMREAD		0x4		/* mode bit for read permission */
#define DMWRITE		0x2		/* mode bit for write permission */
#define DMEXEC		0x1		/* mode bit for execute permission */
// advanced stuff
#define DMAPPEND	0x40000000	/* mode bit for append only files */
#define DMEXCL		0x20000000	/* mode bit for exclusive use files */
#define DMMOUNT		0x10000000	/* mode bit for mounted channel */
#define DMAUTH		0x08000000	/* mode bit for authentication file */
#define DMTMP		0x04000000	/* mode bit for non-backed-up files */
@

<<constant DIRMAX>>=
#define	DIRMAX	(sizeof(Dir)+STATMAX)	/* max length of Dir structure */
@

<<constant STATMAX>>=
#define	STATMAX	65535U	/* max length of machine-independent stat structure */
@


<<function nulldir>>=
void
nulldir(Dir *d)
{
    memset(d, ~0, sizeof(Dir));
    d->name = d->uid = d->gid = d->muid = "";
}
@

\section{Syscalls: [[create()]], [[chdir()]], etc}

\section{[[xxxfstat()]]}

<<enum _anon_ (9sys/dirfstat.c)>>=
enum
{
    DIRSIZE = STATFIXLEN + 16 * 4       /* enough for encoded stat buf + some reasonable strings */
};
@

<<function dirfstat>>=
Dir*
dirfstat(int fd)
{
    Dir *d;
    uchar *buf;
    int n, nd, i;

    nd = DIRSIZE;
    for(i=0; i<2; i++){ /* should work by the second try */
        d = malloc(sizeof(Dir) + BIT16SZ + nd);
        if(d == nil)
            return nil;
        buf = (uchar*)&d[1];
        n = fstat(fd, buf, BIT16SZ+nd);
        if(n < BIT16SZ){
            free(d);
            return nil;
        }
        nd = GBIT16(buf);   /* upper bound on size of Dir + strings */
        if(nd <= n){
            convM2D(buf, n, d, (char*)&d[1]);
            return d;
        }
        /* else sizeof(Dir)+BIT16SZ+nd is plenty */
        free(d);
    }
    return nil;
}
@


<<function dirfwstat>>=
int
dirfwstat(int fd, Dir *d)
{
    uchar *buf;
    int r;

    r = sizeD2M(d);
    buf = malloc(r);
    if(buf == nil)
        return -1;
    convD2M(d, buf, r);
    r = fwstat(fd, buf, r);
    free(buf);
    return r;
}
@

\section{[[xxxstat()]]}

% those one take a name, not a fd
% seems a bit redundant.

<<enum _anon_ (9sys/dirstat.c)>>=
enum
{
    DIRSIZE = STATFIXLEN + 16 * 4       /* enough for encoded stat buf + some reasonable strings */
};
@

<<function dirstat>>=
Dir*
dirstat(char *name)
{
    Dir *d;
    uchar *buf;
    int n, nd, i;

    nd = DIRSIZE;
    for(i=0; i<2; i++){ /* should work by the second try */
        d = malloc(sizeof(Dir) + BIT16SZ + nd);
        if(d == nil)
            return nil;
        buf = (uchar*)&d[1];
        n = stat(name, buf, BIT16SZ+nd);
        if(n < BIT16SZ){
            free(d);
            return nil;
        }
        nd = GBIT16((uchar*)buf);   /* upper bound on size of Dir + strings */
        if(nd <= n){
            convM2D(buf, n, d, (char*)&d[1]);
            return d;
        }
        /* else sizeof(Dir)+BIT16SZ+nd is plenty */
        free(d);
    }
    return nil;
}
@


<<function dirwstat>>=
int
dirwstat(char *name, Dir *d)
{
    uchar *buf;
    int r;

    r = sizeD2M(d);
    buf = malloc(r);
    if(buf == nil)
        return -1;
    convD2M(d, buf, r);
    r = wstat(name, buf, r);
    free(buf);
    return r;
}
@

\section{[[getwd()]]}

<<function getwd>>=
char*
getwd(char *buf, int nbuf)
{
    int n;
    fdt fd;

    fd = open(".", OREAD);
    if(fd < 0)
        return nil;
    n = fd2path(fd, buf, nbuf);
    close(fd);
    if(n < 0)
        return nil;
    return buf;
}
@
% how can be nil?

\section{[[mktemp()]]}

<<function mktemp>>=
char*
mktemp(char *as)
{
    char *s;
    unsigned pid;
    int i;
    char err[ERRMAX];

    pid = getpid();
    s = as;
    while(*s++)
        ;
    s--;
    while(*--s == 'X') {
        *s = pid % 10 + '0';
        pid = pid/10;
    }
    s++;
    i = 'a';
    while(access(as, 0) != -1) {
        if (i == 'z')
            return "/";
        *s = i++;
    }
    err[0] = '\0';
    errstr(err, sizeof err);    /* clear the error */
    return as;
}
@


\section{Normalizing a filename, [[cleanname()]]}

%real-world: realpath()

% cite \plan paper on dotdot?


<<macro SEP>>=
#define SEP(x)  ((x)=='/' || (x) == '\0')
@

% called also from kernel! in fixdotdotname
<<function cleanname>>=
/*
 * In place, rewrite name to compress multiple /, eliminate ., and process ..
 */
char*
cleanname(char *name)
{
    char *s;    /* source of copy */
    char *d;    /* destination of copy */
    char *d0;   /* start of path afer the root name */
    Rune r;
    bool rooted;

    if(name[0] == '\0')
        return strcpy(name, ".");

    rooted = false;
    d0 = name;
    if(d0[0] == '#'){
        if(d0[1] == '\0')
            return d0;
        d0  += 1 + chartorune(&r, d0+1); /* ignore slash: #/ */
        while(!SEP(*d0))
            d0 += chartorune(&r, d0);
        if(d0 == '\0')
            return name;
        d0++;   /* keep / after #<name> */
        rooted = true;
    }else if(d0[0] == '/'){
        rooted = true;
        d0++;
    }

    s = d0;
    if(rooted){
        /* skip extra '/' at root name */
        for(; *s == '/'; s++)
            ;
    }
    /* remove dup slashes */
    for(d = d0; *s != '\0'; s++){
        *d++ = *s;
        if(*s == '/')
            while(s[1] == '/')
                s++;
    }
    *d = '\0';

    d = d0;
    s = d0;
    while(*s != '\0'){
        if(s[0] == '.' && SEP(s[1])){
            if(s[1] == '\0')
                break;
            s+= 2;
            continue;
        }
        if(s[0] == '.' && s[1] == '.' && SEP(s[2])){
            if(d == d0){
                if(rooted){
                    /* /../x -> /x */
                    if(s[2] == '\0')
                        break;
                    s += 3;
                    continue;
                }else{
                    /* ../x -> ../x; and never collect ../ */
                    d0 += 3;
                }
            }
            if(d > d0){
                /* a/../x -> x */
                assert(d-2 >= d0 && d[-1] == '/');
                for(d -= 2; d > d0 && d[-1] != '/'; d--)
                        ;
                if(s[2] == '\0')
                    break;
                s += 3;
                continue;
            }
        }
        while(!SEP(*s))
            *d++ = *s++;
        if(*s == '\0')
            break;
        
        *d++ = *s++;
    }
    *d = '\0';
    if(d-1 > name && d[-1] == '/')  /* thanks to #/ */
        *--d = '\0';
    if(name[0] == '\0')
        strcpy(name, ".");
    return name;
}
@



\section{[[access()]]}

<<function access>>=
int
access(char *name, int mode)
{
    fdt fd;
    Dir *db;
    static char omode[] = {
        0,
        OEXEC,
        OWRITE,
        ORDWR,
        OREAD,
        OEXEC,  /* only approximate */
        ORDWR,
        ORDWR   /* only approximate */
    };

    if(mode == AEXIST){
        db = dirstat(name);
        free(db);
        if(db != nil)
            return 0;
        return -1;
    }
    fd = open(name, omode[mode&7]);
    if(fd >= 0){
        close(fd);
        return 0;
    }
    return -1;
}
@
\t bad to return 0 when can actually access.
\t at least put errorneg1 type
\t but really should return a bool

\section{Path manipulation}



\chapter{Namespace}

<<type Namespace_flag>>=
// enum Namespace_flag, mount/bind parameter
#define	MREPL	0x0000	/* mount replaces object */
#define	MBEFORE	0x0001	/* mount goes before others in union directory */
#define	MAFTER	0x0002	/* mount goes after others in union directory */

#define	MCREATE	0x0004	/* permit creation in mounted directory */
#define	MCACHE	0x0010	/* cache some data */
// bitset<Namespace_flag>
#define	MORDER	0x0003	/* mask for bits defining order of mounting */

#define	MMASK	0x0017	/* all bits on */
@

\section{Syscalls: [[bind()]], [[mount()]], etc}

\chapter{Time}

% see TM in core DS now

\section{Syscalls: [[sleep()]], [[alarm()]], etc}

\section{Time and day}
% called Time-of-day, not sure  why


\section{Time zones and [[localtime()]]}

<<function localtime>>=
Tm*
localtime(long tim)
{
    Tm *ct;
    long t, *p;
    int dlflag;

    if(timezone.stname[0] == 0)
        readtimezone();
    t = tim + timezone.stdiff;
    dlflag = 0;
    for(p = timezone.dlpairs; *p; p += 2)
        if(t >= p[0])
        if(t < p[1]) {
            t = tim + timezone.dldiff;
            dlflag++;
            break;
        }
    ct = gmtime(t);
    if(dlflag){
        strcpy(ct->zone, timezone.dlname);
        ct->tzoff = timezone.dldiff;
    } else {
        strcpy(ct->zone, timezone.stname);
        ct->tzoff = timezone.stdiff;
    }
    return ct;
}
@


% to output time string

<<function asctime>>=
char*
asctime(Tm *t)
{
    char *ncp;
    static char cbuf[30];

    strcpy(cbuf, "Thu Jan 01 00:00:00 GMT 1970\n");
    ncp = &"SunMonTueWedThuFriSat"[t->wday*3];
    cbuf[0] = *ncp++;
    cbuf[1] = *ncp++;
    cbuf[2] = *ncp;
    ncp = &"JanFebMarAprMayJunJulAugSepOctNovDec"[t->mon*3];
    cbuf[4] = *ncp++;
    cbuf[5] = *ncp++;
    cbuf[6] = *ncp;
    ct_numb(cbuf+8, t->mday);
    ct_numb(cbuf+11, t->hour+100);
    ct_numb(cbuf+14, t->min+100);
    ct_numb(cbuf+17, t->sec+100);
    ncp = t->zone;
    cbuf[20] = *ncp++;
    cbuf[21] = *ncp++;
    cbuf[22] = *ncp;
    if(t->year >= 100) {
        cbuf[24] = '2';
        cbuf[25] = '0';
    }
    ct_numb(cbuf+26, t->year+100);
    return cbuf;
}
@

\section{[[time()]]}

<<function time>>=
long
time(long *tp)
{
    vlong t;

    t = nsec()/1000000000LL;
    if(t == 0)
        t = oldtime(0);
    if(tp != nil)
        *tp = t;
    return t;
}
@
% nsec is recent syscalls?

<<function oldtime>>=
/*
 *  After a fork with fd's copied, both fd's are pointing to
 *  the same Chan structure.  Since the offset is kept in the Chan
 *  structure, the seek's and read's in the two processes can
 *  compete at moving the offset around.  Hence the unusual loop
 *  in the middle of this routine.
 */
static long
oldtime(long *tp)
{
    char b[20];
    static int f = -1;
    int i, retries;
    long t;

    memset(b, 0, sizeof(b));
    for(retries = 0; retries < 100; retries++){
        if(f < 0)
            f = open("/dev/time", OREAD|OCEXEC);
        if(f < 0)
            break;
        if(seek(f, 0, 0) < 0 || (i = read(f, b, sizeof(b))) < 0){
            close(f);
            f = -1;
        } else {
            if(i != 0)
                break;
        }
    }
    t = atol(b);
    if(tp)
        *tp = t;
    return t;
}
@

\section{Conversions}

<<function tm2sec>>=
/*
 * compute seconds since Jan 1 1970 GMT
 * and convert to our timezone.
 */
long
tm2sec(Tm *tm)
{
    long secs;
    int i, yday, year, *d2m;

    if(strcmp(tm->zone, "GMT") != 0 && timezone.stname[0] == 0)
        readtimezone();
    secs = 0;

    /*
     *  seconds per year
     */
    year = tm->year + 1900;
    for(i = 1970; i < year; i++){
        d2m = yrsize(i);
        secs += d2m[0] * SEC2DAY;
    }

    /*
     *  if mday is set, use mon and mday to compute yday
     */
    if(tm->mday){
        yday = 0;
        d2m = yrsize(year);
        for(i=0; i<tm->mon; i++)
            yday += d2m[i+1];
        yday += tm->mday-1;
    }else{
        yday = tm->yday;
    }
    secs += yday * SEC2DAY;

    /*
     * hours, minutes, seconds
     */
    secs += tm->hour * SEC2HOUR;
    secs += tm->min * SEC2MIN;
    secs += tm->sec;

    /*
     * Only handles zones mentioned in /env/timezone,
     * but things get too ambiguous otherwise.
     */
    if(strcmp(tm->zone, timezone.stname) == 0)
        secs -= timezone.stdiff;
    else if(strcmp(tm->zone, timezone.dlname) == 0)
        secs -= timezone.dldiff;
    if(secs < 0)
        secs = 0;
    return secs;
}
@


\chapter{Concurrency}

<<type Rfork_flag>>=
/* rfork */
enum Rfork_flags
{
    RFNAMEG  = (1<<0),
    RFENVG   = (1<<1),
    RFFDG    = (1<<2),
    RFNOTEG  = (1<<3),
    RFPROC   = (1<<4),
    RFMEM    = (1<<5),
    RFNOWAIT = (1<<6),
    RFCNAMEG = (1<<10),
    RFCENVG  = (1<<11),
    RFCFDG   = (1<<12),
    RFREND   = (1<<13),
    RFNOMNT  = (1<<14)
};
@


\section{Syscalls: [[rfork()]], [[await()]], [[rendezvous()]], etc}

% sysfork(), sysexit(), sysawait(), sysexec()
% want to run external command? need fork+exec! classic pattern.

% plan9 has shared memory processes. rfork(RFMEM)
% has then locking function to coordinate. qlock, lock, etc.
% has also a few syscalls like rendezvous!

% see also thread chapter, that build on top of this to
% provide more convenient abstractions (channels, alt(), cooperative
% threads with less needs for locking, etc)

% see lock(2), rendezvous(2)
% sleep/wakeup

\section{[[fork()]]}

<<function fork>>=
int
fork(void)
{
    return rfork(RFPROC|RFFDG|RFREND);
}
@
% no RFENVG?
% REFREND?

\section{[[execl()]]}

<<function execl>>=
int
execl(char *f, ...)
{

    return exec(f, &f+1);
}
@

\section{[[getpid()]]}

<<function getpid>>=
int
getpid(void)
{
    char b[20];
    fdt f;

    memset(b, 0, sizeof(b));
    f = open("#c/pid", OREAD);
    if(f >= 0) {
        read(f, b, sizeof(b));
        close(f);
    }
    return atol(b);
}
@

<<function getppid>>=
int
getppid(void)
{
    char b[20];
    int f;

    memset(b, 0, sizeof(b));
    f = open("/dev/ppid", OREAD);
    if(f >= 0) {
        read(f, b, sizeof(b));
        close(f);
    }
    return atol(b);
}
@

\section{Locks}

<<type Lock>>=
struct Lock {
    long    key;
    long    sem;
};
@

<<function lock>>=
void
lock(Lock *l)
{
    if(ainc(&l->key) == 1)
        return; /* changed from 0 -> 1: we hold lock */

    /* otherwise wait in kernel */
    while(semacquire(&l->sem, 1) < 0){
        /* interrupted; try again */
    }
}
@
% ainc: atomic inc.
% so futex? use kernel only when necessary?

<<function unlock>>=
void
unlock(Lock *l)
{
    if(adec(&l->key) == 0)
        return; /* changed from 1 -> 0: no contention */
    semrelease(&l->sem, 1);
}
@

<<function canlock>>=
bool
canlock(Lock *l)
{
    if(ainc(&l->key) == 1)
        return true;   /* changed from 0 -> 1: success */

    /* Undo increment (but don't miss wakeup) */
    if(adec(&l->key) == 0)
        return false;   /* changed from 1 -> 0: no contention */
    semrelease(&l->sem, 1);
    return false;
}
@

\section{Atomic operations, [[ainc()]] (ARM)}

% see atom.s

\section{Waiting queues}
% But Lock is already a waiting lock no? with semacquire?
% But at least here let access/manipulate the queue?

<<type QLock>>=
struct QLock {
    Lock    lock;
    int locked;

    QLp *head;
    QLp     *tail;
};
@

<<type QLp>>=
struct QLp {
    char    state;
    int inuse;
    // Extra
    QLp *next;
};
@


<<function qlock>>=
void
qlock(QLock *q)
{
    QLp *p, *mp;

    lock(&q->lock);
    if(!q->locked){
        q->locked = 1;
        unlock(&q->lock);
        return;
    }


    /* chain into waiting list */
    mp = getqlp();
    p = q->tail;
    if(p == nil)
        q->head = mp;
    else
        p->next = mp;
    q->tail = mp;
    mp->state = Queuing;
    unlock(&q->lock);

    /* wait */
    while((*_rendezvousp)(mp, (void*)1) == (void*)~0)
        ;
    mp->inuse = 0;
}
@

%_rendezvousp?

<<function qunlock>>=
void
qunlock(QLock *q)
{
    QLp *p;

    lock(&q->lock);
    if (q->locked == 0)
        fprint(2, "qunlock called with qlock not held, from %#p\n",
            getcallerpc(&q));
    p = q->head;
    if(p != nil){
        /* wakeup head waiting process */
        q->head = p->next;
        if(q->head == nil)
            q->tail = nil;
        unlock(&q->lock);
        while((*_rendezvousp)(p, (void*)0x12345) == (void*)~0)
            ;
        return;
    }
    q->locked = 0;
    unlock(&q->lock);
}
@

<<function canqlock>>=
int
canqlock(QLock *q)
{
    if(!canlock(&q->lock))
        return 0;
    if(!q->locked){
        q->locked = 1;
        unlock(&q->lock);
        return 1;
    }
    unlock(&q->lock);
    return 0;
}
@



\section{Read-write locks}

<<type RWLock>>=
struct RWLock {
    Lock    lock;
    int readers;    /* number of readers */
    int writer;     /* number of writers */

    QLp *head;      /* list of waiting processes */
    QLp *tail;
};
@

<<function rlock>>=
void
rlock(RWLock *q)
{
    QLp *p, *mp;

    lock(&q->lock);
    if(q->writer == 0 && q->head == nil){
        /* no writer, go for it */
        q->readers++;
        unlock(&q->lock);
        return;
    }

    mp = getqlp();
    p = q->tail;
    if(p == 0)
        q->head = mp;
    else
        p->next = mp;
    q->tail = mp;
    mp->next = nil;
    mp->state = QueuingR;
    unlock(&q->lock);

    /* wait in kernel */
    while((*_rendezvousp)(mp, (void*)1) == (void*)~0)
        ;
    mp->inuse = 0;
}
@

<<function canrlock>>=
int
canrlock(RWLock *q)
{
    lock(&q->lock);
    if (q->writer == 0 && q->head == nil) {
        /* no writer; go for it */
        q->readers++;
        unlock(&q->lock);
        return 1;
    }
    unlock(&q->lock);
    return 0;
}
@

<<function runlock>>=
void
runlock(RWLock *q)
{
    QLp *p;

    lock(&q->lock);
    if(q->readers <= 0)
        abort();
    p = q->head;
    if(--(q->readers) > 0 || p == nil){
        unlock(&q->lock);
        return;
    }

    /* start waiting writer */
    if(p->state != QueuingW)
        abort();
    q->head = p->next;
    if(q->head == 0)
        q->tail = 0;
    q->writer = 1;
    unlock(&q->lock);

    /* wakeup waiter */
    while((*_rendezvousp)(p, 0) == (void*)~0)
        ;
}
@

<<function wlock>>=
void
wlock(RWLock *q)
{
    QLp *p, *mp;

    lock(&q->lock);
    if(q->readers == 0 && q->writer == 0){
        /* noone waiting, go for it */
        q->writer = 1;
        unlock(&q->lock);
        return;
    }

    /* wait */
    p = q->tail;
    mp = getqlp();
    if(p == nil)
        q->head = mp;
    else
        p->next = mp;
    q->tail = mp;
    mp->next = nil;
    mp->state = QueuingW;
    unlock(&q->lock);

    /* wait in kernel */
    while((*_rendezvousp)(mp, (void*)1) == (void*)~0)
        ;
    mp->inuse = 0;
}
@

<<function canwlock>>=
int
canwlock(RWLock *q)
{
    lock(&q->lock);
    if (q->readers == 0 && q->writer == 0) {
        /* no one waiting; go for it */
        q->writer = 1;
        unlock(&q->lock);
        return 1;
    }
    unlock(&q->lock);
    return 0;
}
@

<<function wunlock>>=
void
wunlock(RWLock *q)
{
    QLp *p;

    lock(&q->lock);
    if(q->writer == 0)
        abort();
    p = q->head;
    if(p == nil){
        q->writer = 0;
        unlock(&q->lock);
        return;
    }
    if(p->state == QueuingW){
        /* start waiting writer */
        q->head = p->next;
        if(q->head == nil)
            q->tail = nil;
        unlock(&q->lock);
        while((*_rendezvousp)(p, 0) == (void*)~0)
            ;
        return;
    }

    if(p->state != QueuingR)
        abort();

    /* wake waiting readers */
    while(q->head != nil && q->head->state == QueuingR){
        p = q->head;
        q->head = p->next;
        q->readers++;
        while((*_rendezvousp)(p, 0) == (void*)~0)
            ;
    }
    if(q->head == nil)
        q->tail = nil;
    q->writer = 0;
    unlock(&q->lock);
}
@


\section{Rendez-vous}

<<type Rendez>>=
struct Rendez {
    QLock   *l;

    QLp *head;
    QLp *tail;
};
@

<<function rsleep>>=
void
rsleep(Rendez *r)
{
    QLp *t, *me;

    if(!r->l)
        abort();
    lock(&r->l->lock);
    /* we should hold the qlock */
    if(!r->l->locked)
        abort();

    /* add ourselves to the wait list */
    me = getqlp();
    me->state = Sleeping;
    if(r->head == nil)
        r->head = me;
    else
        r->tail->next = me;
    me->next = nil;
    r->tail = me;

    /* pass the qlock to the next guy */
    t = r->l->head;
    if(t){
        r->l->head = t->next;
        if(r->l->head == nil)
            r->l->tail = nil;
        unlock(&r->l->lock);
        while((*_rendezvousp)(t, (void*)0x12345) == (void*)~0)
            ;
    }else{
        r->l->locked = 0;
        unlock(&r->l->lock);
    }

    /* wait for a wakeup */
    while((*_rendezvousp)(me, (void*)1) == (void*)~0)
        ;
    me->inuse = 0;
}
@

<<function rwakeup>>=
int
rwakeup(Rendez *r)
{
    QLp *t;

    /*
     * take off wait and put on front of queue
     * put on front so guys that have been waiting will not get starved
     */
    
    if(!r->l)
        abort();
    lock(&r->l->lock);
    if(!r->l->locked)
        abort();

    t = r->head;
    if(t == nil){
        unlock(&r->l->lock);
        return 0;
    }

    r->head = t->next;
    if(r->head == nil)
        r->tail = nil;

    t->next = r->l->head;
    r->l->head = t;
    if(r->l->tail == nil)
        r->l->tail = t;

    t->state = Queuing;
    unlock(&r->l->lock);
    return 1;
}
@

<<function rwakeupall>>=
int
rwakeupall(Rendez *r)
{
    int i;

    for(i=0; rwakeup(r); i++)
        ;
    return i;
}
@



\section{Coroutines}

<<type jmp_buf>>=
typedef long    jmp_buf[2];
@

<<type jmpbufxxx>>=
#define JMPBUFSP    0
#define JMPBUFPC    1
#define JMPBUFDPC   0
@

\chapter{IPC}
% 9P and RPC? fcall.h

\section{Syscalls: [[pipe()]], [[notify()]], [[await()]], [[segattach()]]}

\section{Helpers}

% use string to communicate between processes. strings can encode
% a protocol. So need functions that decode a string.
<<function getfields>>=
int
getfields(char *str, char **args, int max, int mflag, char *set)
{
    Rune r;
    int nr, intok, narg;

    if(max <= 0)
        return 0;

    narg = 0;
    args[narg] = str;
    if(!mflag)
        narg++;
    intok = 0;
    for(;; str += nr) {
        nr = chartorune(&r, str);
        if(r == 0)
            break;
        if(utfrune(set, r)) {
            if(narg >= max)
                break;
            *str = 0;
            intok = 0;
            args[narg] = str + nr;
            if(!mflag)
                narg++;
        } else {
            if(!intok && mflag)
                narg++;
            intok = 1;
        }
    }
    return narg;
}
@


\section{Parent-child IPC}
% can pass from parent to child via env, 
% and from child to parent via wait message

\subsection{Wait message}

<<type Waitmsg>>=
/* keep /sys/src/ape/lib/ap/plan9/sys9.h in sync with this -rsc */
struct Waitmsg {
 int	pid;		/* of loved one */
 ulong	time[3];	/* of loved one & descendants */
 // ref_own?<string>?
 char	*msg;
};
@

% in 9sys/
<<function wait>>=
Waitmsg*
wait(void)
{
    int n, l;
    char buf[512];
    char *fld[5];
    Waitmsg *w;

    n = await(buf, sizeof buf-1);
    if(n < 0)
        return nil;
    buf[n] = '\0';
    if(tokenize(buf, fld, nelem(fld)) != nelem(fld)){
        werrstr("couldn't parse wait message");
        return nil;
    }
    l = strlen(fld[4])+1;
    w = malloc(sizeof(Waitmsg)+l);
    if(w == nil)
        return nil;
    w->pid = atoi(fld[0]);
    w->time[0] = atoi(fld[1]);
    w->time[1] = atoi(fld[2]);
    w->time[2] = atoi(fld[3]);
    w->msg = (char*)&w[1];
    memmove(w->msg, fld[4], l);
    return w;
}
@

<<function waitpid>>=
int
waitpid(void)
{
    int n;
    char buf[512];
    char *fld[5];

    n = await(buf, sizeof buf-1);
    if(n <= 0)
        return -1;
    buf[n] = '\0';
    if(tokenize(buf, fld, nelem(fld)) != nelem(fld)){
        werrstr("couldn't parse wait message");
        return -1;
    }
    return atoi(fld[0]);
}
@


\subsection{Environment}

<<function getenv>>=
char*
getenv(char *name)
{
    int r;
    fdt f;
    long s;
    char *ans;
    char *p, *ep, ename[100];

    if(strchr(name, '/') != nil)
        return nil;
    snprint(ename, sizeof ename, "/env/%s", name);
    if(strcmp(ename+5, name) != 0)
        return nil;
    f = open(ename, OREAD);
    if(f < 0)
        return 0;
    s = seek(f, 0, 2);
    ans = malloc(s+1);
    if(ans) {
        setmalloctag(ans, getcallerpc(&name));
        seek(f, 0, 0);
        r = read(f, ans, s);
        if(r >= 0) {
            ep = ans + s - 1;
            for(p = ans; p < ep; p++)
                if(*p == '\0')
                    *p = ' ';
            ans[s] = '\0';
        }
    }
    close(f);
    return ans;
}
@

<<function putenv>>=
int
putenv(char *name, char *val)
{
    fdt f;
    char ename[100];
    long s;

    if(strchr(name, '/') != nil)
        return -1;
    snprint(ename, sizeof ename, "/env/%s", name);
    if(strcmp(ename+5, name) != 0)
        return -1;
    f = create(ename, OWRITE, 0664);
    if(f < 0)
        return -1;
    s = strlen(val);
    if(write(f, val, s) != s){
        close(f);
        return -1;
    }
    close(f);
    return 0;
}
@


\section{Notes}

<<type Note_flag>>=
#define	NCONT	0	/* continue after note */
#define	NDFLT	1	/* terminate after note */
#define	NSAVE	2	/* clear note but hold state */
#define	NRSTR	3	/* restore saved state */
@

\subsection{Posting}

<<type PostnoteKind>>=
enum
{
    PNPROC      = 1,
    PNGROUP     = 2,
};
@

<<function postnote>>=
int
postnote(int group, int pid, char *note)
{
    char file[128];
    fdt f;
    int r;

    switch(group) {
    case PNPROC:
        sprint(file, "/proc/%d/note", pid);
        break;
    case PNGROUP:
        sprint(file, "/proc/%d/notepg", pid);
        break;
    default:
        return -1;
    }

    f = open(file, OWRITE);
    if(f < 0)
        return -1;

    r = strlen(note);
    if(write(f, note, r) != r) {
        close(f);
        return -1;
    }
    close(f);
    return 0;
}
@

\subsection{Notified}

<<function atnotify>>=
int
atnotify(int (*f)(void*, char*), int in)
{
    int i, n, ret;
    static bool init;

    if(!init){
        notify(notifier);
        init = true;       /* assign = */
    }
    ret = 0;
    lock(&onnotlock);
    if(in){
        for(i=0; i<NFN; i++)
            if(onnot[i] == 0) {
                onnot[i] = f;
                ret = 1;
                break;
            }
    }else{
        n = 0;
        for(i=0; i<NFN; i++)
            if(onnot[i]){
                if(ret==0 && onnot[i]==f){
                    onnot[i] = nil;
                    ret = 1;
                }else
                    n++;
            }
        if(n == 0){
            init = false;
            notify(0);
        }
    }
    unlock(&onnotlock);
    return ret;
}
@

<<constant NFN (port/atnotify.c)>>=
#define NFN 33
@

<<global onnot>>=
static  int (*onnot[NFN])(void*, char*);
@

<<global onnotlock>>=
static  Lock    onnotlock;
@

<<function notifier>>=
static
void
notifier(void *v, char *s)
{
    int i;

    for(i=0; i<NFN; i++)
        if(onnot[i] && ((*onnot[i])(v, s))){
            noted(NCONT);
            return;
        }
    noted(NDFLT);
}
@



\section{Pipes}

\section{Shared segments}

<<type Segattach_flag>>=
/* Segattch */
#define	SG_RONLY	0040	/* read only */
#define	SG_CEXEC	0100	/* detach on exec */
@


\section{Fileserver}

\subsection{Dumping}
% in appendix?


<<constant QIDFMT>>=
#define QIDFMT  "(%.16llux %lud %s)"
@

<<function fcallfmt>>=
int
fcallfmt(Fmt *fmt)
{
    Fcall *f;
    int fid, type, tag, i;
    char buf[512], tmp[200];
    char *p, *e;
    Dir *d;
    Qid *q;

    e = buf+sizeof(buf);
    f = va_arg(fmt->args, Fcall*);
    type = f->type;
    fid = f->fid;
    tag = f->tag;
    switch(type){
    case Tversion:  /* 100 */
        seprint(buf, e, "Tversion tag %ud msize %ud version '%s'", tag, f->msize, f->version);
        break;
    case Rversion:
        seprint(buf, e, "Rversion tag %ud msize %ud version '%s'", tag, f->msize, f->version);
        break;
    case Tauth: /* 102 */
        seprint(buf, e, "Tauth tag %ud afid %d uname %s aname %s", tag,
            f->afid, f->uname, f->aname);
        break;
    case Rauth:
        seprint(buf, e, "Rauth tag %ud qid " QIDFMT, tag,
            f->aqid.path, f->aqid.vers, qidtype(tmp, f->aqid.type));
        break;
    case Tattach:   /* 104 */
        seprint(buf, e, "Tattach tag %ud fid %d afid %d uname %s aname %s", tag,
            fid, f->afid, f->uname, f->aname);
        break;
    case Rattach:
        seprint(buf, e, "Rattach tag %ud qid " QIDFMT, tag,
            f->qid.path, f->qid.vers, qidtype(tmp, f->qid.type));
        break;
    case Rerror:    /* 107; 106 (Terror) illegal */
        seprint(buf, e, "Rerror tag %ud ename %s", tag, f->ename);
        break;
    case Tflush:    /* 108 */
        seprint(buf, e, "Tflush tag %ud oldtag %ud", tag, f->oldtag);
        break;
    case Rflush:
        seprint(buf, e, "Rflush tag %ud", tag);
        break;
    case Twalk: /* 110 */
        p = seprint(buf, e, "Twalk tag %ud fid %d newfid %d nwname %d ", tag, fid, f->newfid, f->nwname);
        if(f->nwname <= MAXWELEM)
            for(i=0; i<f->nwname; i++)
                p = seprint(p, e, "%d:%s ", i, f->wname[i]);
        break;
    case Rwalk:
        p = seprint(buf, e, "Rwalk tag %ud nwqid %ud ", tag, f->nwqid);
        if(f->nwqid <= MAXWELEM)
            for(i=0; i<f->nwqid; i++){
                q = &f->wqid[i];
                p = seprint(p, e, "%d:" QIDFMT " ", i,
                    q->path, q->vers, qidtype(tmp, q->type));
            }
        break;
    case Topen: /* 112 */
        seprint(buf, e, "Topen tag %ud fid %ud mode %d", tag, fid, f->mode);
        break;
    case Ropen:
        seprint(buf, e, "Ropen tag %ud qid " QIDFMT " iounit %ud ", tag,
            f->qid.path, f->qid.vers, qidtype(tmp, f->qid.type), f->iounit);
        break;
    case Tcreate:   /* 114 */
        seprint(buf, e, "Tcreate tag %ud fid %ud name %s perm %M mode %d", tag, fid, f->name, (ulong)f->perm, f->mode);
        break;
    case Rcreate:
        seprint(buf, e, "Rcreate tag %ud qid " QIDFMT " iounit %ud ", tag,
            f->qid.path, f->qid.vers, qidtype(tmp, f->qid.type), f->iounit);
        break;
    case Tread: /* 116 */
        seprint(buf, e, "Tread tag %ud fid %d offset %lld count %ud",
            tag, fid, f->offset, f->count);
        break;
    case Rread:
        p = seprint(buf, e, "Rread tag %ud count %ud ", tag, f->count);
            dumpsome(p, e, f->data, f->count);
        break;
    case Twrite:    /* 118 */
        p = seprint(buf, e, "Twrite tag %ud fid %d offset %lld count %ud ",
            tag, fid, f->offset, f->count);
        dumpsome(p, e, f->data, f->count);
        break;
    case Rwrite:
        seprint(buf, e, "Rwrite tag %ud count %ud", tag, f->count);
        break;
    case Tclunk:    /* 120 */
        seprint(buf, e, "Tclunk tag %ud fid %ud", tag, fid);
        break;
    case Rclunk:
        seprint(buf, e, "Rclunk tag %ud", tag);
        break;
    case Tremove:   /* 122 */
        seprint(buf, e, "Tremove tag %ud fid %ud", tag, fid);
        break;
    case Rremove:
        seprint(buf, e, "Rremove tag %ud", tag);
        break;
    case Tstat: /* 124 */
        seprint(buf, e, "Tstat tag %ud fid %ud", tag, fid);
        break;
    case Rstat:
        p = seprint(buf, e, "Rstat tag %ud ", tag);
        if(f->nstat > sizeof tmp)
            seprint(p, e, " stat(%d bytes)", f->nstat);
        else{
            d = (Dir*)tmp;
            convM2D(f->stat, f->nstat, d, (char*)(d+1));
            seprint(p, e, " stat ");
            fdirconv(p+6, e, d);
        }
        break;
    case Twstat:    /* 126 */
        p = seprint(buf, e, "Twstat tag %ud fid %ud", tag, fid);
        if(f->nstat > sizeof tmp)
            seprint(p, e, " stat(%d bytes)", f->nstat);
        else{
            d = (Dir*)tmp;
            convM2D(f->stat, f->nstat, d, (char*)(d+1));
            seprint(p, e, " stat ");
            fdirconv(p+6, e, d);
        }
        break;
    case Rwstat:
        seprint(buf, e, "Rwstat tag %ud", tag);
        break;
    default:
        seprint(buf, e,  "unknown type %d", type);
    }
    return fmtstrcpy(fmt, buf);
}
@

<<function qidtype>>=
static char*
qidtype(char *s, uchar t)
{
    char *p;

    p = s;
    if(t & QTDIR)
        *p++ = 'd';
    if(t & QTAPPEND)
        *p++ = 'a';
    if(t & QTEXCL)
        *p++ = 'l';
    if(t & QTAUTH)
        *p++ = 'A';
    *p = '\0';
    return s;
}
@

\subsection{P9msg}

% called from rio

<<function read9pmsg>>=
int
read9pmsg(fdt fd, void *abuf, uint n)
{
    int m, len;
    uchar *buf;

    buf = abuf;

    /* read count */
    m = readn(fd, buf, BIT32SZ);
    if(m != BIT32SZ){
        if(m < 0)
            return -1;
        return 0;
    }

    len = GBIT32(buf);
    if(len <= BIT32SZ || len > n){
        werrstr("bad length in 9P2000 message header");
        return -1;
    }
    len -= BIT32SZ;
    m = readn(fd, buf+BIT32SZ, len);
    if(m < len)
        return 0;
    return BIT32SZ+m;
}
@

\subsection{Conversion}

% ConvD2M stuff


<<function convM2S>>=
/*
 * no syntactic checks.
 * three causes for error:
 *  1. message size field is incorrect
 *  2. input buffer too short for its own data (counts too long, etc.)
 *  3. too many names or qids
 * gqid() and gstring() return nil if they would reach beyond buffer.
 * main switch statement checks range and also can fall through
 * to test at end of routine.
 */
uint
convM2S(uchar *ap, uint nap, Fcall *f)
{
    uchar *p, *ep;
    uint i, size;

    p = ap;
    ep = p + nap;

    if(p+BIT32SZ+BIT8SZ+BIT16SZ > ep)
        return 0;
    size = GBIT32(p);
    p += BIT32SZ;

    if(size < BIT32SZ+BIT8SZ+BIT16SZ)
        return 0;

    f->type = GBIT8(p);
    p += BIT8SZ;
    f->tag = GBIT16(p);
    p += BIT16SZ;

    switch(f->type)
    {
    default:
        return 0;

    case Tversion:
        if(p+BIT32SZ > ep)
            return 0;
        f->msize = GBIT32(p);
        p += BIT32SZ;
        p = gstring(p, ep, &f->version);
        break;

    case Tflush:
        if(p+BIT16SZ > ep)
            return 0;
        f->oldtag = GBIT16(p);
        p += BIT16SZ;
        break;

    case Tauth:
        if(p+BIT32SZ > ep)
            return 0;
        f->afid = GBIT32(p);
        p += BIT32SZ;
        p = gstring(p, ep, &f->uname);
        if(p == nil)
            break;
        p = gstring(p, ep, &f->aname);
        if(p == nil)
            break;
        break;

    case Tattach:
        if(p+BIT32SZ > ep)
            return 0;
        f->fid = GBIT32(p);
        p += BIT32SZ;
        if(p+BIT32SZ > ep)
            return 0;
        f->afid = GBIT32(p);
        p += BIT32SZ;
        p = gstring(p, ep, &f->uname);
        if(p == nil)
            break;
        p = gstring(p, ep, &f->aname);
        if(p == nil)
            break;
        break;

    case Twalk:
        if(p+BIT32SZ+BIT32SZ+BIT16SZ > ep)
            return 0;
        f->fid = GBIT32(p);
        p += BIT32SZ;
        f->newfid = GBIT32(p);
        p += BIT32SZ;
        f->nwname = GBIT16(p);
        p += BIT16SZ;
        if(f->nwname > MAXWELEM)
            return 0;
        for(i=0; i<f->nwname; i++){
            p = gstring(p, ep, &f->wname[i]);
            if(p == nil)
                break;
        }
        break;

    case Topen:
        if(p+BIT32SZ+BIT8SZ > ep)
            return 0;
        f->fid = GBIT32(p);
        p += BIT32SZ;
        f->mode = GBIT8(p);
        p += BIT8SZ;
        break;

    case Tcreate:
        if(p+BIT32SZ > ep)
            return 0;
        f->fid = GBIT32(p);
        p += BIT32SZ;
        p = gstring(p, ep, &f->name);
        if(p == nil)
            break;
        if(p+BIT32SZ+BIT8SZ > ep)
            return 0;
        f->perm = GBIT32(p);
        p += BIT32SZ;
        f->mode = GBIT8(p);
        p += BIT8SZ;
        break;

    case Tread:
        if(p+BIT32SZ+BIT64SZ+BIT32SZ > ep)
            return 0;
        f->fid = GBIT32(p);
        p += BIT32SZ;
        f->offset = GBIT64(p);
        p += BIT64SZ;
        f->count = GBIT32(p);
        p += BIT32SZ;
        break;

    case Twrite:
        if(p+BIT32SZ+BIT64SZ+BIT32SZ > ep)
            return 0;
        f->fid = GBIT32(p);
        p += BIT32SZ;
        f->offset = GBIT64(p);
        p += BIT64SZ;
        f->count = GBIT32(p);
        p += BIT32SZ;
        if(p+f->count > ep)
            return 0;
        f->data = (char*)p;
        p += f->count;
        break;

    case Tclunk:
    case Tremove:
        if(p+BIT32SZ > ep)
            return 0;
        f->fid = GBIT32(p);
        p += BIT32SZ;
        break;

    case Tstat:
        if(p+BIT32SZ > ep)
            return 0;
        f->fid = GBIT32(p);
        p += BIT32SZ;
        break;

    case Twstat:
        if(p+BIT32SZ+BIT16SZ > ep)
            return 0;
        f->fid = GBIT32(p);
        p += BIT32SZ;
        f->nstat = GBIT16(p);
        p += BIT16SZ;
        if(p+f->nstat > ep)
            return 0;
        f->stat = p;
        p += f->nstat;
        break;

/*
 */
    case Rversion:
        if(p+BIT32SZ > ep)
            return 0;
        f->msize = GBIT32(p);
        p += BIT32SZ;
        p = gstring(p, ep, &f->version);
        break;

    case Rerror:
        p = gstring(p, ep, &f->ename);
        break;

    case Rflush:
        break;

    case Rauth:
        p = gqid(p, ep, &f->aqid);
        if(p == nil)
            break;
        break;

    case Rattach:
        p = gqid(p, ep, &f->qid);
        if(p == nil)
            break;
        break;

    case Rwalk:
        if(p+BIT16SZ > ep)
            return 0;
        f->nwqid = GBIT16(p);
        p += BIT16SZ;
        if(f->nwqid > MAXWELEM)
            return 0;
        for(i=0; i<f->nwqid; i++){
            p = gqid(p, ep, &f->wqid[i]);
            if(p == nil)
                break;
        }
        break;

    case Ropen:
    case Rcreate:
        p = gqid(p, ep, &f->qid);
        if(p == nil)
            break;
        if(p+BIT32SZ > ep)
            return 0;
        f->iounit = GBIT32(p);
        p += BIT32SZ;
        break;

    case Rread:
        if(p+BIT32SZ > ep)
            return 0;
        f->count = GBIT32(p);
        p += BIT32SZ;
        if(p+f->count > ep)
            return 0;
        f->data = (char*)p;
        p += f->count;
        break;

    case Rwrite:
        if(p+BIT32SZ > ep)
            return 0;
        f->count = GBIT32(p);
        p += BIT32SZ;
        break;

    case Rclunk:
    case Rremove:
        break;

    case Rstat:
        if(p+BIT16SZ > ep)
            return 0;
        f->nstat = GBIT16(p);
        p += BIT16SZ;
        if(p+f->nstat > ep)
            return 0;
        f->stat = p;
        p += f->nstat;
        break;

    case Rwstat:
        break;
    }

    if(p==nil || p>ep)
        return 0;
    if(ap+size == p)
        return size;
    return 0;
}
@



<<function convS2M>>=
uint
convS2M(Fcall *f, uchar *ap, uint nap)
{
    uchar *p;
    uint i, size;

    size = sizeS2M(f);
    if(size == 0)
        return 0;
    if(size > nap)
        return 0;

    p = (uchar*)ap;

    PBIT32(p, size);
    p += BIT32SZ;
    PBIT8(p, f->type);
    p += BIT8SZ;
    PBIT16(p, f->tag);
    p += BIT16SZ;

    switch(f->type)
    {
    default:
        return 0;

    case Tversion:
        PBIT32(p, f->msize);
        p += BIT32SZ;
        p = pstring(p, f->version);
        break;

    case Tflush:
        PBIT16(p, f->oldtag);
        p += BIT16SZ;
        break;

    case Tauth:
        PBIT32(p, f->afid);
        p += BIT32SZ;
        p  = pstring(p, f->uname);
        p  = pstring(p, f->aname);
        break;

    case Tattach:
        PBIT32(p, f->fid);
        p += BIT32SZ;
        PBIT32(p, f->afid);
        p += BIT32SZ;
        p  = pstring(p, f->uname);
        p  = pstring(p, f->aname);
        break;

    case Twalk:
        PBIT32(p, f->fid);
        p += BIT32SZ;
        PBIT32(p, f->newfid);
        p += BIT32SZ;
        PBIT16(p, f->nwname);
        p += BIT16SZ;
        if(f->nwname > MAXWELEM)
            return 0;
        for(i=0; i<f->nwname; i++)
            p = pstring(p, f->wname[i]);
        break;

    case Topen:
        PBIT32(p, f->fid);
        p += BIT32SZ;
        PBIT8(p, f->mode);
        p += BIT8SZ;
        break;

    case Tcreate:
        PBIT32(p, f->fid);
        p += BIT32SZ;
        p = pstring(p, f->name);
        PBIT32(p, f->perm);
        p += BIT32SZ;
        PBIT8(p, f->mode);
        p += BIT8SZ;
        break;

    case Tread:
        PBIT32(p, f->fid);
        p += BIT32SZ;
        PBIT64(p, f->offset);
        p += BIT64SZ;
        PBIT32(p, f->count);
        p += BIT32SZ;
        break;

    case Twrite:
        PBIT32(p, f->fid);
        p += BIT32SZ;
        PBIT64(p, f->offset);
        p += BIT64SZ;
        PBIT32(p, f->count);
        p += BIT32SZ;
        memmove(p, f->data, f->count);
        p += f->count;
        break;

    case Tclunk:
    case Tremove:
        PBIT32(p, f->fid);
        p += BIT32SZ;
        break;

    case Tstat:
        PBIT32(p, f->fid);
        p += BIT32SZ;
        break;

    case Twstat:
        PBIT32(p, f->fid);
        p += BIT32SZ;
        PBIT16(p, f->nstat);
        p += BIT16SZ;
        memmove(p, f->stat, f->nstat);
        p += f->nstat;
        break;
/*
 */

    case Rversion:
        PBIT32(p, f->msize);
        p += BIT32SZ;
        p = pstring(p, f->version);
        break;

    case Rerror:
        p = pstring(p, f->ename);
        break;

    case Rflush:
        break;

    case Rauth:
        p = pqid(p, &f->aqid);
        break;

    case Rattach:
        p = pqid(p, &f->qid);
        break;

    case Rwalk:
        PBIT16(p, f->nwqid);
        p += BIT16SZ;
        if(f->nwqid > MAXWELEM)
            return 0;
        for(i=0; i<f->nwqid; i++)
            p = pqid(p, &f->wqid[i]);
        break;

    case Ropen:
    case Rcreate:
        p = pqid(p, &f->qid);
        PBIT32(p, f->iounit);
        p += BIT32SZ;
        break;

    case Rread:
        PBIT32(p, f->count);
        p += BIT32SZ;
        memmove(p, f->data, f->count);
        p += f->count;
        break;

    case Rwrite:
        PBIT32(p, f->count);
        p += BIT32SZ;
        break;

    case Rclunk:
        break;

    case Rremove:
        break;

    case Rstat:
        PBIT16(p, f->nstat);
        p += BIT16SZ;
        memmove(p, f->stat, f->nstat);
        p += f->nstat;
        break;

    case Rwstat:
        break;
    }
    if(size != p-ap)
        return 0;
    return size;
}
@




\chapter{Channels and Cooperative Threads}

%https://idea.popcount.org/2017-01-06-select-is-fundamentally-broken/

\section{Overview}

% thread OS vs thread lib OS! already have "threads" rfork with shared memory!
% see http://swtch.com/~rsc/thread/
% plan9 libthread model is based on Alef. Procs in terminology
% below are actually shared
% memory processes, and threads cooperatively scheduled coroutines.
% different than what most people agrees about threads/

% Why need that? why system threads not enough? not convenient enough?
% green threads vs system threads, a classic.
% Having cooperative threads simplify lots of things, no race, less
% need for locks! Other reasons? (xleroy did the same)

% alternatives? posix threads? xleroy thread lib? new thread linux lib?
% other forms of concurrency? erlang model? see 7 concurrency in 7 weeks?

% see thread(2), definitive reference. maybe see alef article
% for design discussions. See acme and rio articles/slides for
% examples of use and discussions too.
% see ioproc(2), and lock(2)
% see rendezvous(2)

\subsection{Code organization}

%include/thread.h: public API
%threadimpl.h: private DS

%ref.c: atomic counter (could be in libc.h)
%xincarm.c
%xincport.h

%globals.c: globals
%debug.c: debugging support (threadebug(), threadassert())

%lib.c: threadmalloc wrapper, threadsysfatal()
%386.c: thread stack initialization arch specific managment

%create.c: create/free process/threads
%id.c: thread identification
%sched.c: the thread scheduler

%note.c: thread-aware notes
%exit.c: thread-aware exits
%exec.c: thread-aware exec

%rendez.c: rendez vous API for the threads
%kill.c: thread killing each other
%channel.c:

%chanprint.c

%ioproc.c: IO proc creation/deletion and handler (xioproc)
%iocall.c: the io proc helper bridge for all the syscalls below

%ioxxx.c: 
% (ioopen.c, %ioclose.c, %ioread.c, %iowrite.c, %ioreadn.c, %iosleep.c)

%dial.c: thread friendly version of network dial
%iodial.c


%main.c: !!!

\subsection{Software architecture}

% _xxx = private

% rely on shared memory and futex for synchro.
% ainc, adec. (atomic inc, atomic dec)

% channels are structured in shared memory between processes and
% threads. Used concurrently.

\section{A toy example}

% lib_thread/tests/!! example.c! include early

\section{Core data structures}

\subsection{Concurrency buiding blocks}

<<struct Ref>>=
struct Ref {
    long	ref;
};
@

<<function incref>>=
void
incref(Ref *r)
{
    ainc(&r->ref);
}
@

<<function decref>>=
long
decref(Ref *r)
{
    return adec(&r->ref);
}
@


<<global xincport_lock>>=
static Lock xincport_lock;
@
% port for portable?

<<function _xinc>>=
void
_xinc(long *p)
{

    lock(&xincport_lock);
    (*p)++;
    unlock(&xincport_lock);
}
@
% who calls _xinc?? ainc?
% atom.s defines _xinc and _ainc as the same function

<<function _xdec>>=
long
_xdec(long *p)
{
    long r;

    lock(&xincport_lock);
    r = --(*p);
    unlock(&xincport_lock);
    return r;
}
@


% see Lock, QLock, Rendez!! 
% see also lock(); unlock() functions in libc.h

% can produce producer/consumer synchronization queue
% with lock and rendezvous (kind of condition variables)

\subsection{[[Channel]]}
% public API!

%A Channel is a buffered or unbuffered queue for fixed size messages
% Procs and threads send messages into the channel and recv messages 
% from the channel

% so really a form of generalized producer/consumer queue!
% an effective and general concurrency mechanism

<<struct Channel>>=
/*
 * Channel structure.  s is the size of the buffer.  For unbuffered channels
 * s is zero.  v is an array of s values.  If s is zero, v is unused.
 * f and n represent the state of the queue pointed to by v.
 */
struct Channel {
    int	s;		/* Size of the channel (may be zero) */

    uint	f;		/* Extraction point (insertion pt: (f+n) % s) */
    uint	n;		/* Number of values in the channel */
    int	e;		/* Element size */
    int	freed;		/* Set when channel is being deleted */

    volatile Alt **qentry;	/* Receivers/senders waiting (malloc) */
    volatile int nentry;	/* # of entries malloc-ed */
    volatile int closed;	/* channel is closed */

    // must be at the end of the struct! 
    byte	v[1];		/* Array of s values in the channel */
};
@
% no Lock?
% volatile?

<<global chanlock>>=
static Lock chanlock;		/* central channel access lock */
@


<<function chancreate>>=
Channel*
chancreate(int elemsize, int elemcnt)
{
    Channel *c;

    if(elemcnt < 0 || elemsize <= 0)
        return nil;
    c = _threadmalloc(sizeof(Channel) + elemsize*elemcnt, 1);
    c->e = elemsize;
    c->s = elemcnt;
    _threaddebug(DBGCHAN, "chancreate %p", c);
    return c;
}
@
% _threadmalloc ?

% have to be called by user? could do that in chancreate no?
<<function chaninit>>=
int
chaninit(Channel *c, int elemsize, int elemcnt)
{
    if(elemcnt < 0 || elemsize <= 0 || c == nil)
        return -1;
    c->f = 0;
    c->n = 0;
    c->closed = 0;
    c->freed = 0;
    c->e = elemsize;
    c->s = elemcnt;
    _threaddebug(DBGCHAN, "chaninit %p", c);
    return 1;
}
@


<<function chanfree>>=
void
chanfree(Channel *c)
{
    lock(&chanlock);
    _chanfree(c);
    unlock(&chanlock);
}
@


<<function _chanfree>>=
static void
_chanfree(Channel *c)
{
    int i, inuse;

    if(c->closed == 1)			/* chanclose is ongoing */
        inuse = 1;
    else{
        inuse = 0;
        for(i = 0; i < c->nentry; i++)	/* alt ongoing */
            if(c->qentry[i])
                inuse = 1;
    }
    if(inuse)
        c->freed = 1;
    else{
        if(c->qentry)
            free(c->qentry);
        free(c);
    }
}
@




<<enum _anon_ (lib_core/libthread/channel.c)>>=
/* Value to indicate the channel is closed */
enum {
    CHANCLOSD = 0xc105ed,
};
@
<<constant Closed>>=
#define Closed	((void*)CHANCLOSD)
@






% public API
<<function chanclose>>=
int
chanclose(Channel *c)
{
    Alt *a;
    int i, s;

    s = _procsplhi();	/* note handlers; see :/^alt */
    lock(&chanlock);
    if(c->closed){
        /* Already close; we fail but it's ok. don't print */
        unlock(&chanlock);
        _procsplx(s);
        return -1;
    }
    c->closed = 1;		/* Being closed */
    /*
     * Locate entries that will fail due to close
     * (send, and receive if nothing buffered) and wake them up.
     * the situation cannot change because all queries
     * should be committed by now and new ones will find the channel
     * closed.  We still need to take the lock during the iteration
     * because we can wake threads on qentrys we have not seen yet
     * as in alt and there would be a race in the access to *a.
     */
    for(i = 0; i < c->nentry; i++){
        if((a = c->qentry[i]) == nil || *a->tag != nil)
            continue;

        if(a->op != CHANSND && (a->op != CHANRCV || c->n != 0))
            continue;
        *a->tag = c;
        unlock(&chanlock);
        _procsplx(s);
        while(_threadrendezvous(a->tag, Closed) == Intred)
            ;
        s = _procsplhi();
        lock(&chanlock);
    }

    c->closed = 2;		/* Fully closed */
    if(c->freed)
        _chanfree(c);
    unlock(&chanlock);
    _procsplx(s);
    return 0;
}
@

<<function chanclosing>>=
int
chanclosing(Channel *c)
{
    int n, s;

    s = _procsplhi();	/* note handlers; see :/^alt */
    lock(&chanlock);
    if(c->closed == 0)
        n = -1;
    else
        n = c->n;
    unlock(&chanlock);
    _procsplx(s);
    return n;
}
@

%/*
% * superseded by chanclosing
%int
%chanisclosed(Channel *c)
%{
%    return chanisclosing(c) >= 0;
%}
% */





\subsection{[[Proc]] and [[Pqueue]]}

% cooperative scheduler building blocks = coroutines = setjmp()!
% (actually the kernel does the same)

<<struct Proc>>=
struct Proc
{
    int		pid;			/* process id */

    jmp_buf	sched;			/* for context switches */

    Thread	*thread;		/* running thread */




    bool		splhi;			/* delay notes */

    int		needexec;
    Execargs	exec;			/* exec argument */
    Proc	*newproc;		/* fork argument */
    char	exitstr[ERRMAX];	/* exit status */

    int		rforkflag;

    Tqueue	threads;		/* All threads of this proc */
    int		nthreads;

    Tqueue	ready;			/* Runnable threads */
    Lock	readylock;

    char	printbuf[Printsize];
    int		blocked;		/* In a rendezvous */
    int		pending;		/* delayed note pending */
    int		nonotes;		/* delay notes */
    uint	nextID;			/* ID of most recently created thread */


    void	*arg;			/* passed between shared and unshared stk */
    char	str[ERRMAX];		/* used by threadexits to avoid malloc */

    void*	wdata;			/* Lib(worker) per-proc data pointer */
    void*	udata;			/* User per-proc data pointer */
    char	threadint;		/* tag for threadexitsall() */

    // Extra
    Proc	*next;			/* linked list of Procs */

    Lock	lock;
};
@

% jmp_buf is in u.h and is just long[2] (sp, pc) for x86

<<constant Printsize>>=
Printsize = 2048,
@


% shared memory, but need also per process private memory.
% how? stack? each process has its own stack normally.


<<global procp>>=
// used to be in main.c
static Proc **procp;
@
% set in threadsysinit(), privalloc()

<<function _threadgetproc>>=
Proc*
_threadgetproc(void)
{
    return *procp;
}
@

<<function _threadsetproc>>=
void
_threadsetproc(Proc *p)
{
    *procp = p;
}
@





% all processes, all threads?
<<global _threadpq>>=
// used to be in create.c
Pqueue _threadpq;
@
% it's not a pointer! so it should be set to nil by default

<<struct Pqueue>>=
struct Pqueue {		/* Proc queue */
    Proc		*head;
    Proc		**tail;

    // Extra
    Lock		lock;
};
@


<<function proccreate>>=
int
proccreate(void (*f)(void*), void *arg, uint stacksize)
{
    return procrfork(f, arg, stacksize, 0);
}
@

<<function procrfork>>=
int
procrfork(void (*f)(void *), void *arg, uint stacksize, int rforkflag)
{
    Proc *p;
    int id;

    p = _threadgetproc();
    assert(p->newproc == nil);
    p->newproc = _newproc(f, arg, stacksize, nil, p->thread->grp, rforkflag);
    id = p->newproc->threads.head->id;
    _sched();
    return id;
}
@



<<function _newproc>>=
/*
 * Create and initialize a new Proc structure with a single Thread
 * running inside it.  Add the Proc to the global process list.
 */
Proc*
_newproc(void (*f)(void *arg), void *arg, uint stacksize, char *name, int grp, int rforkflag)
{
    Proc *p;

    p = _threadmalloc(sizeof *p, 1);
    p->pid = -1;
    p->rforkflag = rforkflag;
    newthread(p, f, arg, stacksize, name, grp);

    lock(&_threadpq.lock);
    if(_threadpq.head == nil)
        _threadpq.head = p;
    else
        *_threadpq.tail = p;
    _threadpq.tail = &p->next;
    unlock(&_threadpq.lock);

    return p;
}
@





<<function _freeproc>>=
void
_freeproc(Proc *p)
{
    Thread *t, *nextt;

    for(t = p->threads.head; t; t = nextt){
        if(t->cmdname)
            free(t->cmdname);
        assert(t->stk != nil);
        free(t->stk);
        nextt = t->nextt;
        free(t);
    }
    free(p);
}
@


<<struct Execargs>>=
struct Execargs
{
    char	*prog;
    char	**args;
    int		fd[2];
};
@



\subsection{[[Thread]] and [[Tqueue]]}
% private DS, threadimpl.h


<<struct Thread>>=
struct Thread
{
    int		id;		/* thread id */
    char	*cmdname;	/* ptr to name of thread */

    jmp_buf	sched;		/* for context switches */

    Proc	*proc;		/* proc of this thread */

    uint	stksize;	/* stack size */
    uchar	*stk;		/* top of stack (lowest address of stack) */

    State	state;		/* run state */
    State	nextstate;	/* next run state */

    Chanstate	chan;		/* which channel operation is current */
    Alt		*alt;		/* pointer to current alt structure (debugging) */



    int 	grp;		/* thread group */
    int		moribund;	/* thread needs to die */

    int		ret;		/* return value for Exec, Fork */


    int		inrendez;
    Thread	*rendhash;	/* Trgrp linked list */
    void*	rendtag;	/* rendezvous tag */
    void*	rendval;	/* rendezvous value */
    int		rendbreak;	/* rendezvous has been taken */


    void*	udata[NPRIV];	/* User per-thread data pointer */

    // Extra
    Lock	lock;		/* protects thread data structure */

    Thread	*next;		/* next on ready queue */

    Thread	*nextt;		/* next on list of threads in this proc*/


};
@

% advanced topic?
<<constant NPRIV>>=
NPRIV = 8,
@






<<function threadid>>=
int
threadid(void)
{
    return _threadgetproc()->thread->id;
}
@

% newthread() -> <>
<<function nextID>>=
static int
nextID(void)
{
    static Lock l;
    static int id;
    int i;

    lock(&l);
    i = ++id;
    unlock(&l);
    return i;
}
@


<<function threadcreate>>=
/* 
 * Create a new thread and schedule it to run.
 * The thread grp is inherited from the currently running thread.
 */
int
threadcreate(void (*f)(void *arg), void *arg, uint stacksize)
{
    return newthread(_threadgetproc(), f, arg, stacksize, nil, threadgetgrp());
}
@


% ctor
<<function newthread>>=
/*
 * Create and initialize a new Thread structure attached to a given proc.
 */
static int
newthread(Proc *p, void (*f)(void *arg), void *arg, uint stacksize, char *name, int grp)
{
    int id;
    Thread *t;

    if(stacksize < 32)
        sysfatal("bad stacksize %d", stacksize);
    t = _threadmalloc(sizeof(Thread), 1);

    t->stksize = stacksize;
    t->stk = _threadmalloc(stacksize, 0);
    memset(t->stk, 0xFE, stacksize);
    _threadinitstack(t, f, arg);

    t->grp = grp;
    if(name)
        t->cmdname = strdup(name);
    t->id = nextID();
    id = t->id;
    t->next = (Thread*)~0;
    t->proc = p;
    _threaddebug(DBGSCHED, "create thread %d.%d name %s", p->pid, t->id, name);

    lock(&p->lock);
    p->nthreads++;
    if(p->threads.head == nil)
        p->threads.head = t;
    else
        *p->threads.tail = t;
    p->threads.tail = &t->nextt;

    t->nextt = nil;
    t->state = Ready;
    _threadready(t);
    unlock(&p->lock);

    return id;
}
@

% 386.c
<<function launcher386>>=
static void
launcher386(void (*f)(void *arg), void *arg)
{
    (*f)(arg);
    threadexits(nil);
}
@

% 386.c
<<function _threadinitstack>>=
void
_threadinitstack(Thread *t, void (*f)(void*), void *arg)
{
    ulong *tos;

    tos = (ulong*)&t->stk[t->stksize&~7];
    *--tos = (ulong)arg;
    *--tos = (ulong)f;
    t->sched[JMPBUFPC] = (ulong)launcher386+JMPBUFDPC;
    t->sched[JMPBUFSP] = (ulong)tos - 8;		/* old PC and new PC */
}
@





<<function _freethread>>=
void
_freethread(Thread *t)
{
    Proc *p;
    Thread **l;

    p = t->proc;
    lock(&p->lock);
    for(l=&p->threads.head; *l; l=&(*l)->nextt){
        if(*l == t){
            *l = t->nextt;
            if(*l == nil)
                p->threads.tail = l;
            break;
        }
    }
    unlock(&p->lock);
    if (t->cmdname)
        free(t->cmdname);
    assert(t->stk != nil);
    free(t->stk);
    free(t);
}
@




<<function threadpid>>=
int
threadpid(int id)
{
    int pid;
    Proc *p;
    Thread *t;

    if (id < 0)
        return -1;
    if (id == 0)
        return _threadgetproc()->pid;
    lock(&_threadpq.lock);
    for (p = _threadpq.head; p; p = p->next){
        lock(&p->lock);
        for (t = p->threads.head; t; t = t->nextt)
            if (t->id == id){
                pid = p->pid;
                unlock(&p->lock);
                unlock(&_threadpq.lock);
                return pid;
            }
        unlock(&p->lock);
    }
    unlock(&_threadpq.lock);
    return -1;
}
@



<<struct Tqueue>>=
struct Tqueue		/* Thread queue */
{
    Thread	*head;
    Thread	**tail;

    int		asleep;
};
@




<<enum state>>=
enum state
{
    Dead,
    Running,
    Ready,
    Rendezvous,
};
@
% hmm does not much psstate string array, normal??

<<enum chanstate>>=
enum chanstate
{
    Channone,

    Chansend,
    Chanrecv,

    Chanalt,
};
@



<<function threadsetname>>=
void
threadsetname(char *fmt, ...)
{
    int fd;
    char buf[128];
    va_list arg;
    Proc *p;
    Thread *t;

    p = _threadgetproc();
    t = p->thread;
    if (t->cmdname)
        free(t->cmdname);
    va_start(arg, fmt);
    t->cmdname = vsmprint(fmt, arg);
    va_end(arg);
    if(t->cmdname && p->nthreads == 1){
        snprint(buf, sizeof buf, "#p/%lud/args", _tos->pid); //getpid());
        if((fd = open(buf, OWRITE)) >= 0){
            write(fd, t->cmdname, strlen(t->cmdname)+1);
            close(fd);
        }
    }
}
@

<<function threadgetname>>=
char*
threadgetname(void)
{
    Proc *p;

    if((p = _threadgetproc()) && p->thread)
        return p->thread->cmdname;
    return nil;
}
@


\subsection{[[Alt]]}

% "Plan9 has no select call"

% But in libdraw/event.c they use an event pipe; a pipe between
% a master and a set of slaves, and master can listen to multiple
% slaves at the same time and get the next event from those slaves.
% Here is alternative model to event, threads and channels and alt().

<<enum chanop>>=
/* Channel operations for alt: */
enum chanop {
    CHANEND,

    CHANSND,
    CHANRCV,
    CHANNOP,

    CHANNOBLK,
};
@

<<struct Alt>>=
struct Alt {
    Channel	*c;		/* channel */
    void	*v;		/* pointer to value */
    ChanOp	op;		/* operation */

    char	*err;		/* did the op fail? */
    /*
     * the next variables are used internally to alt
     * they need not be initialized
     */
    Channel	**tag;		/* pointer to rendez-vous tag */
    int	entryno;	/* entry number */
};
@


\section{[[main()]]}
% and threadmain()

<<global mainp>>=
// ref<ref<Proc>
static Proc **mainp;
@
% address of ref of proc in stack

<<global _mainjmp>>=
static jmp_buf _mainjmp;
@

<<global mainstacksize>>=
int	mainstacksize;
@


<<function main>>=
void
main(int argc, char **argv)
{
    Mainarg *a;
    Proc *p;

    rfork(RFREND);
    mainp = &p;

    if(setjmp(_mainjmp))
        _schedinit(p);

    //_threaddebuglevel = (DBGSCHED|DBGCHAN|DBGREND)^~0;
    _systhreadinit();
    _qlockinit(_threadrendezvous);

    _sysfatal = _threadsysfatal;
    _dial     = _threaddial;
    __assert  = _threadassert;

    notify(_threadnote);

    if(mainstacksize == 0)
        mainstacksize = 8*1024;

    a = _threadmalloc(sizeof *a, 1);
    a->argc = argc;
    a->argv = argv;

    p = _newproc(mainlauncher, a, mainstacksize, "threadmain", 0, 0);
    _schedinit(p);

    abort();	/* not reached */
}
@


<<function _systhreadinit>>=
void
_systhreadinit(void)
{
    procp = privalloc();
}
@

<<struct Mainarg>>=
struct Mainarg
{
    int		argc;
    char	**argv;
};
@

<<function mainlauncher>>=
static void
mainlauncher(void *arg)
{
    Mainarg *a;

    a = arg;

    // user defined threadmain()!!
    threadmain(a->argc, a->argv);

    threadexits("threadmain");
}
@



\section{Threads scheduler}
% similar to Kernel Scheduling chapter

<<global _psstate>>=
static char *_psstate[] = {
    "Moribund",
    "Dead",
    "Exec",
    "Fork",
    "Running",
    "Ready",
    "Rendezvous",
};
@
% superset of enum state, normal?

<<function psstate>>=
static char*
psstate(int s)
{
    if(s < 0 || s >= nelem(_psstate))
        return "unknown";
    return _psstate[s];
}
@


<<function _schedinit>>=
void
_schedinit(void *arg)
{
    Proc *p;
    Thread *t, **l;

    p = arg;
    _threadsetproc(p);
    p->pid = _tos->pid; //getpid();

    while(setjmp(p->sched))
        ;

    _threaddebug(DBGSCHED, "top of schedinit, _threadexitsallstatus=%p", 
                 _threadexitsallstatus);
    if(_threadexitsallstatus)
        exits(_threadexitsallstatus);

    lock(&p->lock);
    t = p->thread;
    if(t != nil){
        p->thread = nil;

        if(t->moribund){
            t->state = Dead;
            for(l=&p->threads.head; *l; l=&(*l)->nextt)
                if(*l == t){
                    *l = t->nextt;
                    if(*l==nil)
                        p->threads.tail = l;
                    p->nthreads--;
                    break;
                }
            unlock(&p->lock);
            if(t->inrendez){
                _threadflagrendez(t);
                _threadbreakrendez();
            }
            free(t->stk);
            free(t->cmdname);
            free(t);	/* XXX how do we know there are no references? */
            t = nil;
            _sched();
        }
        if(p->needexec){
            t->ret = _schedexec(&p->exec);
            p->needexec = 0;
        }
        if(p->newproc){
            t->ret = _schedfork(p->newproc);
            p->newproc = nil;
        }
        t->state = t->nextstate;
        if(t->state == Ready)
            _threadready(t);
    }
    unlock(&p->lock);
    _sched();
}
@

% _sched() -> <>
<<function needstack>>=
void
needstack(int n)
{
    int x;
    Proc *p;
    Thread *t;
    
    p = _threadgetproc();
    t = p->thread;
    
    if((uchar*)&x - n < (uchar*)t->stk){
        fprint(2, "%s %lud: &x=%p n=%d t->stk=%p\n",
            argv0, _tos->pid, &x, n, t->stk);
        fprint(2, "%s %lud: stack overflow\n", argv0, _tos->pid);
        abort();
    }
}
@

<<function _sched>>=
void
_sched(void)
{
    Proc *p;
    Thread *t;

Resched:
    p = _threadgetproc();
    t = p->thread;
    if(t != nil){
        needstack(128);
        _threaddebug(DBGSCHED, "pausing, state=%s", psstate(t->state));
        if(setjmp(t->sched)==0)
            longjmp(p->sched, 1);
        return;
    }else{
        t = runthread(p);
        if(t == nil){
            _threaddebug(DBGSCHED, "all threads gone; exiting");
            _schedexit(p);
        }
        _threaddebug(DBGSCHED, "running %d.%d", t->proc->pid, t->id);
        p->thread = t;
        if(t->moribund){
            _threaddebug(DBGSCHED, "%d.%d marked to die");
            goto Resched;
        }
        t->state = Running;
        t->nextstate = Ready;
        longjmp(t->sched, 1);
    }
}
@

<<function runthread>>=
static Thread*
runthread(Proc *p)
{
    Thread *t;
    Tqueue *q;

    if(p->nthreads==0)
        return nil;
    q = &p->ready;
    lock(&p->readylock);
    if(q->head == nil){
        q->asleep = 1;
        _threaddebug(DBGSCHED, "sleeping for more work");
        unlock(&p->readylock);
        while(rendezvous(q, 0) == (void*)~0){
            if(_threadexitsallstatus)
                exits(_threadexitsallstatus);
        }
        /* lock picked up from _threadready */
    }
    t = q->head;
    q->head = t->next;
    unlock(&p->readylock);
    return t;
}
@

<<function _threadready>>=
void
_threadready(Thread *t)
{
    Tqueue *q;

    assert(t->state == Ready);
    _threaddebug(DBGSCHED, "readying %d.%d", t->proc->pid, t->id);

    q = &t->proc->ready;
    lock(&t->proc->readylock);
    t->next = nil;
    if(q->head==nil)
        q->head = t;
    else
        *q->tail = t;
    q->tail = &t->next;
    if(q->asleep){
        q->asleep = 0;
        /* lock passes to runthread */
        _threaddebug(DBGSCHED, "waking process %d", t->proc->pid);
        while(rendezvous(q, 0) == (void*)~0){
            if(_threadexitsallstatus)
                exits(_threadexitsallstatus);
        }
    }else
        unlock(&t->proc->readylock);
}
@

<<function yield>>=
void
yield(void)
{
    _sched();
}
@


<<function _schedexit>>=
void
_schedexit(Proc *p)
{
    char ex[ERRMAX];
    Proc **l;

    lock(&_threadpq.lock);
    for(l=&_threadpq.head; *l; l=&(*l)->next){
        if(*l == p){
            *l = p->next;
            if(*l == nil)
                _threadpq.tail = l;
            break;
        }
    }
    unlock(&_threadpq.lock);

    utfecpy(ex, ex+sizeof ex, p->exitstr);
    free(p);
    _exits(ex);
}
@



\section{[[alt()]]}

% send()/recv() use alt(), so better see alt() first.

% !!!
<<function alt>>=
int
alt(Alt *alts)
{
    Alt *a, *xa, *ca;
    Channel volatile *c;
    int n, s, waiting, allreadycl;
    void* r;
    Thread *t;

    /*
     * The point of going splhi here is that note handlers
     * might reasonably want to use channel operations,
     * but that will hang if the note comes while we hold the
     * chanlock.  Instead, we delay the note until we've dropped
     * the lock.
     */
    t = _threadgetproc()->thread;
    if(t->moribund || _threadexitsallstatus)
        yield();	/* won't return */
    s = _procsplhi();

    lock(&chanlock);
    t->alt = alts;
    t->chan = Chanalt;

    /* test whether any channels can proceed */
    n = 0;
    a = nil;

    for(xa=alts; xa->op!=CHANEND && xa->op!=CHANNOBLK; xa++){
        xa->entryno = -1;
        if(xa->op == CHANNOP)
            continue;

        c = xa->c;
        if(c==nil){
            unlock(&chanlock);
            _procsplx(s);
            t->chan = Channone;
            return -1;
        }

        if(isopenfor(c, xa->op) && canexec(xa))
            if(nrand(++n) == 0)
                a = xa;
    }


    if(a==nil){
        /* nothing can proceed */
        if(xa->op == CHANNOBLK){
            unlock(&chanlock);
            _procsplx(s);
            t->chan = Channone;
            if(xa->op == CHANNOBLK)
                return xa - alts;
        }

        /* enqueue on all channels open for us. */
        c = nil;
        ca = nil;
        waiting = 0;
        allreadycl = 0;
        for(xa=alts; xa->op!=CHANEND; xa++)
            if(xa->op==CHANNOP)
                continue;
            else if(isopenfor(xa->c, xa->op)){
                waiting = 1;
                enqueue(xa, &c);
            } else if(xa->err != errcl)
                ca = xa;
            else
                allreadycl = 1;

        if(waiting == 0)
            if(ca != nil){
                /* everything was closed, select last channel */
                ca->err = errcl;
                unlock(&chanlock);
                _procsplx(s);
                t->chan = Channone;
                return ca - alts;
            } else if(allreadycl){
                /* everything was already closed */
                unlock(&chanlock);
                _procsplx(s);
                t->chan = Channone;
                return -1;
            }
        /*
         * wait for successful rendezvous.
         * we can't just give up if the rendezvous
         * is interrupted -- someone else might come
         * along and try to rendezvous with us, so
         * we need to be here.
         * if the channel was closed, the op is done
         * and we flag an error for the entry.
         */
        Again:
        unlock(&chanlock);
        _procsplx(s);
        r = _threadrendezvous(&c, 0);
        s = _procsplhi();
        lock(&chanlock);

        if(r==Intred){		/* interrupted */
            if(c!=nil)	/* someone will meet us; go back */
                goto Again;
            c = (Channel*)~0;	/* so no one tries to meet us */
        }

        /* dequeue from channels, find selected one */
        a = nil;
        for(xa=alts; xa->op!=CHANEND; xa++){
            if(xa->op==CHANNOP)
                continue;
            if(xa->c == c){
                a = xa;
                a->err = nil;
                if(r == Closed)
                    a->err = errcl;
            }
            dequeue(xa);
        }
        unlock(&chanlock);
        _procsplx(s);
        if(a == nil){	/* we were interrupted */
            assert(c==(Channel*)~0);
            return -1;
        }
    }else
        altexec(a, s);	/* unlocks chanlock, does splx */
    _sched();
    t->chan = Channone;
    return a - alts;
}
@

<<function isopenfor>>=
static bool
isopenfor(Channel *c, int op)
{
    return c->closed == 0 || (op == CHANRCV && c->n > 0);
}
@


<<function canexec>>=
static int
canexec(Alt *a)
{
    int i, otherop;
    Channel *c;

    c = a->c;
    /* are there senders or receivers blocked? */
    otherop = (CHANSND+CHANRCV) - a->op;
    for(i=0; i<c->nentry; i++)
        if(c->qentry[i] && c->qentry[i]->op==otherop && *c->qentry[i]->tag==nil){
            _threaddebug(DBGCHAN, "can rendez alt %p chan %p", a, c);
            return 1;
        }

    /* is there room in the channel? */
    if((a->op==CHANSND && c->n < c->s)
    || (a->op==CHANRCV && c->n > 0)){
        _threaddebug(DBGCHAN, "can buffer alt %p chan %p", a, c);
        return 1;
    }

    return 0;
}
@








<<global errcl>>=
static char errcl[] = "channel was closed";
@


<<function enqueue>>=
static void
enqueue(Alt *a, Channel **c)
{
    int i;

    _threaddebug(DBGCHAN, "Queuing alt %p on channel %p", a, a->c);
    a->tag = c;
    i = emptyentry(a->c);
    a->c->qentry[i] = a;
}
@


<<function dequeue>>=
static void
dequeue(Alt *a)
{
    int i;
    Channel *c;

    c = a->c;
    for(i=0; i<c->nentry; i++)
        if(c->qentry[i]==a){
            _threaddebug(DBGCHAN, "Dequeuing alt %p from channel %p", a, a->c);
            c->qentry[i] = nil;
            /* release if freed and not closing */
            if(c->freed && c->closed != 1)
                _chanfree(c);
            return;
        }
}
@


% enqueue -> <>
<<function emptyentry>>=
static int
emptyentry(Channel *c)
{
    int i, extra;

    assert((c->nentry==0 && c->qentry==nil) || (c->nentry && c->qentry));

    for(i=0; i<c->nentry; i++)
        if(c->qentry[i]==nil)
            return i;

    extra = 16;
    c->nentry += extra;
    c->qentry = realloc((void*)c->qentry, c->nentry*sizeof(c->qentry[0]));
    if(c->qentry == nil)
        sysfatal("realloc channel entries: %r");
    memset(&c->qentry[i], 0, extra*sizeof(c->qentry[0]));
    return i;
}
@



<<function altexec>>=
static int
altexec(Alt *a, int spl)
{
    volatile Alt *b;
    int i, n, otherop;
    Channel *c;
    void *me, *waiter, *buf;

    c = a->c;

    /* rendezvous with others */
    otherop = (CHANSND+CHANRCV) - a->op;
    n = 0;
    b = nil;
    me = a->v;
    for(i=0; i<c->nentry; i++)
        if(c->qentry[i] && c->qentry[i]->op==otherop && *c->qentry[i]->tag==nil)
            if(nrand(++n) == 0)
                b = c->qentry[i];
    if(b != nil){
        _threaddebug(DBGCHAN, "rendez %s alt %p chan %p alt %p", a->op==CHANRCV?"recv":"send", a, c, b);
        waiter = b->v;
        if(c->s && c->n){
            /*
             * if buffer is full and there are waiters
             * and we're meeting a waiter,
             * we must be receiving.
             *
             * we use the value in the channel buffer,
             * copy the waiter's value into the channel buffer
             * on behalf of the waiter, and then wake the waiter.
             */
            if(a->op!=CHANRCV)
                abort();
            buf = altexecbuffered(a, 1);
            altcopy(me, buf, c->e);
            altcopy(buf, waiter, c->e);
        }else{
            if(a->op==CHANRCV)
                altcopy(me, waiter, c->e);
            else
                altcopy(waiter, me, c->e);
        }
        *b->tag = c;	/* commits us to rendezvous */
        _threaddebug(DBGCHAN, "unlocking the chanlock");
        unlock(&chanlock);
        _procsplx(spl);
        _threaddebug(DBGCHAN, "chanlock is %lud", *(ulong*)&chanlock);
        while(_threadrendezvous(b->tag, 0) == Intred)
            ;
        return 1;
    }

    buf = altexecbuffered(a, 0);
    if(a->op==CHANRCV)
        altcopy(me, buf, c->e);
    else
        altcopy(buf, me, c->e);

    unlock(&chanlock);
    _procsplx(spl);
    return 1;
}
@


% altexec -> <>
<<function altexecbuffered>>=
static void*
altexecbuffered(Alt *a, int willreplace)
{
    uchar *v;
    Channel *c;

    c = a->c;
    /* use buffered channel queue */
    if(a->op==CHANRCV && c->n > 0){
        _threaddebug(DBGCHAN, "buffer recv alt %p chan %p", a, c);
        v = c->v + c->e*(c->f%c->s);
        if(!willreplace)
            c->n--;
        c->f++;
        return v;
    }
    if(a->op==CHANSND && c->n < c->s){
        _threaddebug(DBGCHAN, "buffer send alt %p chan %p", a, c);
        v = c->v + c->e*((c->f+c->n)%c->s);
        if(!willreplace)
            c->n++;
        return v;
    }
    abort();
    return nil;
}
@

% altexec -> <>
<<function altcopy>>=
static void
altcopy(void *dst, void *src, int sz)
{
    if(dst){
        if(src)
            memmove(dst, src, sz);
        else
            memset(dst, 0, sz);
    }
}
@


\section{Send/Receive}
% actually they all rely on alt()

% it provides a first form of synchro! you block
% when the other is not ready to receive if have
% no more space in the queue

\subsection{[[runop]]}

<<function runop>>=
static int
runop(int op, Channel *c, void *v, bool nb)
{
    int r;
    Alt a[2];

    /*
     * we could do this without calling alt,
     * but the only reason would be performance,
     * and i'm not convinced it matters.
     */
    a[0].op = op;
    a[0].c = c;
    a[0].v = v;
    a[0].err = nil;
    a[1].op = CHANEND;
    if(nb)
        a[1].op = CHANNOBLK;

    switch(r=alt(a)){
    case -1:	/* interrupted */
        return -1;
    case 1:	/* nonblocking, didn't accomplish anything */
        assert(nb);
        return 0;
    case 0:
        /*
         * Okay, but return -1 if the op is done because of a close.
         */
        if(a[0].err != nil)
            return -1;
        return 1;
    default:
        fprint(2, "ERROR: channel alt returned %d\n", r);
        abort();
        return -1;
    }
}
@

\subsection{[[send()]]/[[recv()]]}

<<function send>>=
int
send(Channel *c, void *v)
{
    return runop(CHANSND, c, v, 0);
}
@

<<function recv>>=
int
recv(Channel *c, void *v)
{
    return runop(CHANRCV, c, v, 0);
}
@

\subsection{Non blocking operations, [[nbxxx()]]}

<<function nbrecv>>=
int
nbrecv(Channel *c, void *v)
{
    return runop(CHANRCV, c, v, 1);
}
@

<<function nbsend>>=
int
nbsend(Channel *c, void *v)
{
    return runop(CHANSND, c, v, 1);
}
@

\subsection{Typed send and receive}

<<function channelsize>>=
static void
channelsize(Channel *c, int sz)
{
    if(c->e != sz){
        fprint(2, "expected channel with elements of size %d, got size %d\n",
            sz, c->e);
        abort();
    }
}
@


<<function sendul>>=
int
sendul(Channel *c, ulong v)
{
    channelsize(c, sizeof(ulong));
    return send(c, &v);
}
@

<<function recvul>>=
ulong
recvul(Channel *c)
{
    ulong v;

    channelsize(c, sizeof(ulong));
    if(recv(c, &v) < 0)
        return ~0;
    return v;
}
@


<<function sendp>>=
int
sendp(Channel *c, void *v)
{
    channelsize(c, sizeof(void*));
    return send(c, &v);
}
@

<<function recvp>>=
void*
recvp(Channel *c)
{
    void *v;

    channelsize(c, sizeof(void*));
    if(recv(c, &v) < 0)
        return nil;
    return v;
}
@


<<function nbsendul>>=
int
nbsendul(Channel *c, ulong v)
{
    channelsize(c, sizeof(ulong));
    return nbsend(c, &v);
}
@

<<function nbrecvul>>=
ulong
nbrecvul(Channel *c)
{
    ulong v;

    channelsize(c, sizeof(ulong));
    if(nbrecv(c, &v) == 0)
        return 0;
    return v;
}
@

<<function nbsendp>>=
int
nbsendp(Channel *c, void *v)
{
    channelsize(c, sizeof(void*));
    return nbsend(c, &v);
}
@

<<function nbrecvp>>=
void*
nbrecvp(Channel *c)
{
    void *v;

    channelsize(c, sizeof(void*));
    if(nbrecv(c, &v) == 0)
        return nil;
    return v;
}
@



\section{IO processus}

% threads are cooperative. If one does a syscall such as reading
% then it hangs the whole process ... so have to put such calls
% in another process, hence the idea of IO slace processes.

<<function ioproc_arg>>=
#define ioproc_arg(io, type)	(va_arg((io)->arg, type))
@

\subsection{[[Ioproc]]}

% private structure! #pragma incomplete in thread.h (and implemented in
% threadimpl.h)
<<struct Ioproc>>=
struct Ioproc
{
    int tid;

    Channel *c;
    Channel *creply;

    int inuse;

    long (*op)(va_list*);

    va_list arg;
    long ret;
    char err[ERRMAX];

    Ioproc *next;
};
@

<<constant STACK>>=
STACK = 8192,
@

% ctor
<<function ioproc>>=
Ioproc*
ioproc(void)
{
    Ioproc *io;

    io = mallocz(sizeof(Ioproc), 1);
    if(io == nil)
        sysfatal("ioproc malloc: %r");
    io->c = chancreate(sizeof(void*), 0);
    io->creply = chancreate(sizeof(void*), 0);
    io->tid = proccreate(xioproc, io, STACK);
    return io;
}
@

% dtor
<<function closeioproc>>=
void
closeioproc(Ioproc *io)
{
    if(io == nil)
        return;
    iointerrupt(io);
    while(send(io->c, 0) == -1)
        ;
    chanfree(io->c);
    chanfree(io->creply);
    free(io);
}
@

% closeioproc | iocall -> <>
<<function iointerrupt>>=
void
iointerrupt(Ioproc *io)
{
    if(!io->inuse)
        return;
    threadint(io->tid);
}
@





\subsection{[[xiproc()]]}

<<function xioproc>>=
static void
xioproc(void *a)
{
    Ioproc *io, *x;
    io = a;
    /*
     * first recvp acquires the ioproc.
     * second tells us that the data is ready.
     */
    for(;;){
        while(recv(io->c, &x) == -1)
            ;
        if(x == 0)	/* our cue to leave */
            break;
        assert(x == io);

        /* caller is now committed -- even if interrupted he'll return */
        while(recv(io->creply, &x) == -1)
            ;
        if(x == 0)	/* caller backed out */
            continue;
        assert(x == io);

        io->ret = io->op(&io->arg);
        if(io->ret < 0)
            rerrstr(io->err, sizeof io->err);
        while(send(io->creply, &io) == -1)
            ;
        while(recv(io->creply, &x) == -1)
            ;
    }
}
@



\subsection{[[iocall()]]}

<<function iocall>>=
long
iocall(Ioproc *io, long (*op)(va_list*), ...)
{
    int ret, inted;
    Ioproc *msg;

    if(send(io->c, &io) == -1){
        werrstr("interrupted");
        return -1;
    }
    assert(!io->inuse);
    io->inuse = 1;
    io->op = op;
    va_start(io->arg, op);
    msg = io;
    inted = 0;
    while(send(io->creply, &msg) == -1){
        msg = nil;
        inted = 1;
    }
    if(inted){
        werrstr("interrupted");
        return -1;
    }

    /*
     * If we get interrupted, we have to stick around so that
     * the IO proc has someone to talk to.  Send it an interrupt
     * and try again.
     */
    inted = 0;
    while(recv(io->creply, nil) == -1){
        inted = 1;
        iointerrupt(io);
    }
    USED(inted);
    va_end(io->arg);
    ret = io->ret;
    if(ret < 0)
        errstr(io->err, sizeof io->err);
    io->inuse = 0;

    /* release resources */
    while(send(io->creply, &io) == -1)
        ;
    return ret;
}
@


\subsection{IO wrappers}


<<function ioopen>>=
int
ioopen(Ioproc *io, char *path, int mode)
{
    return iocall(io, _ioopen, path, mode);
}
@

<<function _ioopen>>=
static long
_ioopen(va_list *arg)
{
    char *path;
    int mode;

    path = va_arg(*arg, char*);
    mode = va_arg(*arg, int);
    return open(path, mode);
}
@



<<function ioclose>>=
int
ioclose(Ioproc *io, int fd)
{
    return iocall(io, _ioclose, fd);
}
@

<<function _ioclose>>=
static long
_ioclose(va_list *arg)
{
    int fd;

    fd = va_arg(*arg, int);
    return close(fd);
}
@


<<function ioread>>=
long
ioread(Ioproc *io, int fd, void *a, long n)
{
    return iocall(io, _ioread, fd, a, n);
}
@

<<function _ioread>>=
static long
_ioread(va_list *arg)
{
    int fd;
    void *a;
    long n;

    fd = va_arg(*arg, int);
    a = va_arg(*arg, void*);
    n = va_arg(*arg, long);
    return read(fd, a, n);
}
@

<<function ioreadn>>=
long
ioreadn(Ioproc *io, int fd, void *a, long n)
{
    return iocall(io, _ioreadn, fd, a, n);
}
@


<<function _ioreadn>>=
static long
_ioreadn(va_list *arg)
{
    int fd;
    void *a;
    long n;

    fd = va_arg(*arg, int);
    a = va_arg(*arg, void*);
    n = va_arg(*arg, long);
    return readn(fd, a, n);
}
@

<<function iowrite>>=
long
iowrite(Ioproc *io, int fd, void *a, long n)
{
    return iocall(io, _iowrite, fd, a, n);
}
@

<<function _iowrite>>=
static long
_iowrite(va_list *arg)
{
    int fd;
    void *a;
    long n;

    fd = va_arg(*arg, int);
    a = va_arg(*arg, void*);
    n = va_arg(*arg, long);
    return write(fd, a, n);
}
@

<<function iosleep>>=
int
iosleep(Ioproc *io, long n)
{
    return iocall(io, _iosleep, n);
}
@


<<function _iosleep>>=
static long
_iosleep(va_list *arg)
{
    long n;

    n = va_arg(*arg, long);
    return sleep(n);
}
@



\section{Thread-aware libc}

\subsection{Memory}

% actually malloc already shared-memory safe as it uses locks.
% but have a small malloc wrapper not doing that much more,
% just a bit more error safe:

<<global totalmalloc>>=
static long totalmalloc;
@

<<function _threadmalloc>>=
void*
_threadmalloc(long size, int z)
{
    void *m;

    m = malloc(size);
    if (m == nil)
        sysfatal("Malloc of size %ld failed: %r", size);
    setmalloctag(m, getcallerpc(&size));
    totalmalloc += size;
    if (size > 100000000) {
        fprint(2, "Malloc of size %ld, total %ld\n", size, totalmalloc);
        abort();
    }
    if (z)
        memset(m, 0, size);
    return m;
}
@


\subsection{Exit}
% need to terminate all of those things.
% I remember it was tricky in ocaml to get things right
% when have worker, when use MPI, etc.

<<global _threadexitsallstatus>>=
char *_threadexitsallstatus;
@

<<function threadexits>>=
void
threadexits(char *exitstr)
{
    Proc *p;
    Thread *t;

    p = _threadgetproc();
    t = p->thread;
    t->moribund = 1;
    if(exitstr==nil)
        exitstr="";
    utfecpy(p->exitstr, p->exitstr+ERRMAX, exitstr);
    _sched();
}
@


<<function threadexitsall>>=
void
threadexitsall(char *exitstr)
{
    Proc *p;
    int pid[64];
    int i, npid, mypid;

    if(exitstr == nil)
        exitstr = "";
    _threadexitsallstatus = exitstr;
    _threaddebug(DBGSCHED, "_threadexitsallstatus set to %p", _threadexitsallstatus);
    mypid = _tos->pid; //getpid();

    /*
     * signal others.
     * copying all the pids first avoids other threads
     * teardown procedures getting in the way.
     *
     * avoid mallocs since malloc can post a note which can
     * call threadexitsall...
     */
    for(;;){
        lock(&_threadpq.lock);
        npid = 0;
        for(p = _threadpq.head; p && npid < nelem(pid); p=p->next){
            if(p->threadint == 0 && p->pid != mypid){
                pid[npid++] = p->pid;
                p->threadint = 1;
            }
        }
        unlock(&_threadpq.lock);
        if(npid == 0)
            break;
        for(i=0; i<npid; i++)
            postnote(PNPROC, pid[i], "threadint");
    }

    /* leave */
    exits(exitstr);
}
@


<<global _threadwaitchan>>=
Channel *_threadwaitchan;
@

<<function threadwaitchan>>=
Channel*
threadwaitchan(void)
{
    if(_threadwaitchan==nil)
        _threadwaitchan = chancreate(sizeof(Waitmsg*), 16);
    return _threadwaitchan;
}
@

\subsection{Fork}

<<function _schedfork>>=
int
_schedfork(Proc *p)
{
    int pid;

    switch(pid = rfork(RFPROC|RFMEM|RFNOWAIT|p->rforkflag)){
    case 0:
        *mainp = p;	/* write to stack, so local to proc */
        longjmp(_mainjmp, 1);
    default:
        return pid;
    }
}
@

\subsection{Exec}

% in main.c, not sure why, could be in a exec.c
<<function _schedexec>>=
int
_schedexec(Execargs *e)
{
    int pid;

    switch(pid = rfork(RFREND|RFNOTEG|RFFDG|RFMEM|RFPROC)){
    case 0:
        efork(e);
    default:
        return pid;
    }
}
@

% _schedexec -> <>
<<function efork>>=
static void
efork(Execargs *e)
{
    char buf[ERRMAX];

    _threaddebug(DBGEXEC, "_schedexec %s", e->prog);
    close(e->fd[0]);
    exec(e->prog, e->args);
    _threaddebug(DBGEXEC, "_schedexec failed: %r");
    rerrstr(buf, sizeof buf);
    if(buf[0]=='\0')
        strcpy(buf, "exec failed");
    write(e->fd[1], buf, strlen(buf));
    close(e->fd[1]);
    _exits(buf);
}
@


% procexec -> <>
<<function _schedexecwait>>=
void
_schedexecwait(void)
{
    int pid;
    Channel *c;
    Proc *p;
    Thread *t;
    Waitmsg *w;

    p = _threadgetproc();
    t = p->thread;
    pid = t->ret;
    _threaddebug(DBGEXEC, "_schedexecwait %d", t->ret);

    rfork(RFCFDG);
    for(;;){
        w = wait();
        if(w == nil)
            break;
        if(w->pid == pid)
            break;
        free(w);
    }
    if(w != nil){
        if((c = _threadwaitchan) != nil)
            sendp(c, w);
        else
            free(w);
    }
    threadexits("procexec");
}
@




<<constant PIPEMNT>>=
#define PIPEMNT	"/mnt/temp"
@

<<function procexec>>=
void
procexec(Channel *pidc, char *prog, char *args[])
{
    int n;
    Proc *p;
    Thread *t;

    _threaddebug(DBGEXEC, "procexec %s", prog);
    /* must be only thread in proc */
    p = _threadgetproc();
    t = p->thread;
    if(p->threads.head != t || p->threads.head->nextt != nil){
        werrstr("not only thread in proc");
    Bad:
        if(pidc)
            sendul(pidc, ~0);
        return;
    }

    /*
     * We want procexec to behave like exec; if exec succeeds,
     * never return, and if it fails, return with errstr set.
     * Unfortunately, the exec happens in another proc since
     * we have to wait for the exec'ed process to finish.
     * To provide the semantics, we open a pipe with the 
     * write end close-on-exec and hand it to the proc that
     * is doing the exec.  If the exec succeeds, the pipe will
     * close so that our read below fails.  If the exec fails,
     * then the proc doing the exec sends the errstr down the
     * pipe to us.
     */
    if(bind("#|", PIPEMNT, MREPL) < 0)
        goto Bad;
    if((p->exec.fd[0] = open(PIPEMNT "/data", OREAD)) < 0){
        unmount(nil, PIPEMNT);
        goto Bad;
    }
    if((p->exec.fd[1] = open(PIPEMNT "/data1", OWRITE|OCEXEC)) < 0){
        close(p->exec.fd[0]);
        unmount(nil, PIPEMNT);
        goto Bad;
    }
    unmount(nil, PIPEMNT);

    /* exec in parallel via the scheduler */
    assert(p->needexec==0);
    p->exec.prog = prog;
    p->exec.args = args;
    p->needexec = 1;
    _sched();

    close(p->exec.fd[1]);
    if((n = read(p->exec.fd[0], p->exitstr, ERRMAX-1)) > 0){	/* exec failed */
        p->exitstr[n] = '\0';
        errstr(p->exitstr, ERRMAX);
        close(p->exec.fd[0]);
        goto Bad;
    }
    close(p->exec.fd[0]);

    if(pidc)
        sendul(pidc, t->ret);

    /* wait for exec'ed program, then exit */
    _schedexecwait();
}
@

<<function procexecl>>=
void
procexecl(Channel *pidc, char *f, ...)
{
    procexec(pidc, f, &f+1);
}
@




\subsection{Interruptions}

<<constant Intred>>=
#define Intred	((void*)~0)		/* interrupted */
@


\subsection{Notes}








<<global _threadnopasser>>=
int	_threadnopasser;
@

<<constant NFN (libthread/note.c)>>=
#define	NFN		33
@

<<constant ERRLEN>>=
#define	ERRLEN	48
@

<<struct Note>>=
struct Note
{
    Lock		inuse;
    Proc		*proc;		/* recipient */
    char		s[ERRMAX];	/* arg2 */
};
@

<<global notes>>=
static Note	notes[128];
@

<<global enotes>>=
static Note	*enotes = notes+nelem(notes);
@

<<global onnote>>=
static int		(*onnote[NFN])(void*, char*);
@

<<global onnotepid>>=
static int		onnotepid[NFN];
@

<<global onnotelock>>=
static Lock	onnotelock;
@

<<function threadnotify>>=
int
threadnotify(int (*f)(void*, char*), int in)
{
    int i, topid;
    int (*from)(void*, char*), (*to)(void*, char*);

    if(in){
        from = nil;
        to = f;
        topid = _threadgetproc()->pid;
    }else{
        from = f;
        to = nil;
        topid = 0;
    }
    lock(&onnotelock);
    for(i=0; i<NFN; i++)
        if(onnote[i]==from){
            onnote[i] = to;
            onnotepid[i] = topid;
            break;
        }
    unlock(&onnotelock);
    return i<NFN;
}
@

<<function delayednotes>>=
static void
delayednotes(Proc *p, void *v)
{
    int i;
    Note *n;
    int (*fn)(void*, char*);

    if(!p->pending)
        return;

    p->pending = 0;
    for(n=notes; n<enotes; n++){
        if(n->proc == p){
            for(i=0; i<NFN; i++){
                if(onnotepid[i]!=p->pid || (fn = onnote[i])==nil)
                    continue;
                if((*fn)(v, n->s))
                    break;
            }
            if(i==NFN){
                _threaddebug(DBGNOTE, "Unhandled note %s, proc %p\n", n->s, p);
                if(v != nil)
                    noted(NDFLT);
                else if(strncmp(n->s, "sys:", 4)==0)
                    abort();
                threadexitsall(n->s);
            }
            n->proc = nil;
            unlock(&n->inuse);
        }
    }
}
@

<<function _threadnote>>=
void
_threadnote(void *v, char *s)
{
    Proc *p;
    Note *n;

    _threaddebug(DBGNOTE, "Got note %s", s);
    if(strncmp(s, "sys:", 4) == 0)
        noted(NDFLT);

    if(_threadexitsallstatus){
        _threaddebug(DBGNOTE, "Threadexitsallstatus = '%s'\n", _threadexitsallstatus);
        _exits(_threadexitsallstatus);
    }

    if(strcmp(s, "threadint")==0)
        noted(NCONT);

    p = _threadgetproc();
    if(p == nil)
        noted(NDFLT);

    for(n=notes; n<enotes; n++)
        if(canlock(&n->inuse))
            break;
    if(n==enotes)
        sysfatal("libthread: too many delayed notes");
    utfecpy(n->s, n->s+ERRMAX, s);
    n->proc = p;
    p->pending = 1;
    if(!p->splhi)
        delayednotes(p, v);
    noted(NCONT);
}
@

<<function _procsplhi>>=
int
_procsplhi(void)
{
    int s;
    Proc *p;

    p = _threadgetproc();
    s = p->splhi;
    p->splhi = 1;
    return s;
}
@

<<function _procsplx>>=
void
_procsplx(int s)
{
    Proc *p;

    p = _threadgetproc();
    p->splhi = s;
    if(s)
        return;
    if(p->pending)
        delayednotes(p, nil);
}
@




\subsection{Dialing}

<<function _iodial>>=
static long
_iodial(va_list *arg)
{
    char *addr, *local, *dir;
    int *cdfp;

    addr = va_arg(*arg, char*);
    local = va_arg(*arg, char*);
    dir = va_arg(*arg, char*);
    cdfp = va_arg(*arg, int*);

    return dial(addr, local, dir, cdfp);
}
@

<<function iodial>>=
int
iodial(Ioproc *io, char *addr, char *local, char *dir, int *cdfp)
{
    return iocall(io, _iodial, addr, local, dir, cdfp);
}
@




<<enum _anon_ (lib_core/libthread/dial.c)>>=
enum
{
    Maxstring	= 128,
    Maxpath		= 256,
};
@

<<struct DS (libthread/dial.c)>>=
struct DS {
    /* dist string */
    char	buf[Maxstring];
    char	*netdir;
    char	*proto;
    char	*rem;

    /* other args */
    char	*local;
    char	*dir;
    int	*cfdp;
};
@

<<function _threaddial>>=
/*
 *  the dialstring is of the form '[/net/]proto!dest'
 */
int
_threaddial(char *dest, char *local, char *dir, int *cfdp)
{
    DS ds;
    int rv;
    char err[ERRMAX], alterr[ERRMAX];

    ds.local = local;
    ds.dir = dir;
    ds.cfdp = cfdp;

    _dial_string_parse(dest, &ds);
    if(ds.netdir)
        return csdial(&ds);

    ds.netdir = "/net";
    rv = csdial(&ds);
    if(rv >= 0)
        return rv;
    err[0] = '\0';
    errstr(err, sizeof err);
    if(strstr(err, "refused") != 0){
        werrstr("%s", err);
        return rv;
    }
    ds.netdir = "/net.alt";
    rv = csdial(&ds);
    if(rv >= 0)
        return rv;

    alterr[0] = 0;
    errstr(alterr, sizeof alterr);
    if(strstr(alterr, "translate") || strstr(alterr, "does not exist"))
        werrstr("%s", err);
    else
        werrstr("%s", alterr);
    return rv;
}
@

<<function csdial (libthread/dial.c)>>=
static int
csdial(DS *ds)
{
    int n, fd, rv;
    char *p, buf[Maxstring], clone[Maxpath], err[ERRMAX], besterr[ERRMAX];

    /*
     *  open connection server
     */
    snprint(buf, sizeof(buf), "%s/cs", ds->netdir);
    fd = open(buf, ORDWR);
    if(fd < 0){
        /* no connection server, don't translate */
        snprint(clone, sizeof(clone), "%s/%s/clone", ds->netdir, ds->proto);
        return call(clone, ds->rem, ds);
    }

    /*
     *  ask connection server to translate
     */
    snprint(buf, sizeof(buf), "%s!%s", ds->proto, ds->rem);
    if(write(fd, buf, strlen(buf)) < 0){
        close(fd);
        return -1;
    }

    /*
     *  loop through each address from the connection server till
     *  we get one that works.
     */
    *besterr = 0;
    rv = -1;
    seek(fd, 0, 0);
    while((n = read(fd, buf, sizeof(buf) - 1)) > 0){
        buf[n] = 0;
        p = strchr(buf, ' ');
        if(p == 0)
            continue;
        *p++ = 0;
        rv = call(buf, p, ds);
        if(rv >= 0)
            break;
        err[0] = '\0';
        errstr(err, sizeof err);
        if(strstr(err, "does not exist") == 0)
            strcpy(besterr, err);
    }
    close(fd);

    if(rv < 0 && *besterr)
        werrstr("%s", besterr);
    else
        werrstr("%s", err);
    return rv;
}
@

<<function call (libthread/dial.c)>>=
static int
call(char *clone, char *dest, DS *ds)
{
    int fd, cfd, n;
    char cname[Maxpath], name[Maxpath], data[Maxpath], *p;

    /* because cs is in a different name space, replace the mount point */
    if(*clone == '/'){
        p = strchr(clone+1, '/');
        if(p == nil)
            p = clone;
        else 
            p++;
    } else
        p = clone;
    snprint(cname, sizeof cname, "%s/%s", ds->netdir, p);

    cfd = open(cname, ORDWR);
    if(cfd < 0)
        return -1;

    /* get directory name */
    n = read(cfd, name, sizeof(name)-1);
    if(n < 0){
        close(cfd);
        return -1;
    }
    name[n] = 0;
    for(p = name; *p == ' '; p++)
        ;
    snprint(name, sizeof(name), "%ld", strtoul(p, 0, 0));
    p = strrchr(cname, '/');
    *p = 0;
    if(ds->dir)
        snprint(ds->dir, NETPATHLEN, "%s/%s", cname, name);
    snprint(data, sizeof(data), "%s/%s/data", cname, name);

    /* connect */
    if(ds->local)
        snprint(name, sizeof(name), "connect %s %s", dest, ds->local);
    else
        snprint(name, sizeof(name), "connect %s", dest);
    if(write(cfd, name, strlen(name)) < 0){
        close(cfd);
        return -1;
    }

    /* open data connection */
    fd = open(data, ORDWR);
    if(fd < 0){
        close(cfd);
        return -1;
    }
    if(ds->cfdp)
        *ds->cfdp = cfd;
    else
        close(cfd);
    return fd;
}
@

<<function _dial_string_parse (libthread/dial.c)>>=
/*
 *  parse a dial string
 */
static void
_dial_string_parse(char *str, DS *ds)
{
    char *p, *p2;

    strncpy(ds->buf, str, Maxstring);
    ds->buf[Maxstring-1] = 0;

    p = strchr(ds->buf, '!');
    if(p == 0) {
        ds->netdir = 0;
        ds->proto = "net";
        ds->rem = ds->buf;
    } else {
        if(*ds->buf != '/' && *ds->buf != '#'){
            ds->netdir = 0;
            ds->proto = ds->buf;
        } else {
            for(p2 = p; *p2 != '/'; p2--)
                ;
            *p2++ = 0;
            ds->netdir = ds->buf;
            ds->proto = p2;
        }
        *p = 0;
        ds->rem = p + 1;
    }
}
@



\section{Error management}

%"Thread library functions do not return on failure; if errors occur, the entire program is aborted."


% call abort() which enter broken state I think by causing a fault


<<function _threadsysfatal>>=
void
_threadsysfatal(char *fmt, va_list arg)
{
    char buf[1024];	/* size doesn't matter; we're about to exit */

    vseprint(buf, buf+sizeof(buf), fmt, arg);
    if(argv0)
        fprint(2, "%s: %s\n", argv0, buf);
    else
        fprint(2, "%s\n", buf);
    threadexitsall(buf);
}
@

<<function _threadassert>>=
void
_threadassert(char *s)
{
    char buf[256];
    int n;
    Proc *p;

    p = _threadgetproc();
    if(p && p->thread)
        n = sprint(buf, "%d.%d ", p->pid, p->thread->id);
    else
        n = 0;
    snprint(buf+n, sizeof(buf)-n, "%s: assertion failed\n", s);
    write(2, buf, strlen(buf));
    abort();
}
@


\section{Debugging}


<<global _threaddebuglevel>>=
// biset<enum<dbgxxx>>
int _threaddebuglevel;
@

% could use enum dbgxxx
<<constant DBGAPPL>>=
#define DBGAPPL	(1 << 0)
@

<<constant DBGSCHED>>=
#define DBGSCHED	(1 << 16)
@

<<constant DBGCHAN>>=
#define DBGCHAN	(1 << 17)
@

<<constant DBGREND>>=
#define DBGREND	(1 << 18)
@

<<constant DBGNOTE>>=
#define DBGNOTE	(1 << 20)
@
%/* #define DBGKILL	(1 << 19) */

<<constant DBGEXEC>>=
#define DBGEXEC	(1 << 21)
@



<<function _threaddebug>>=
void
_threaddebug(ulong flag, char *fmt, ...)
{
    char buf[128];
    va_list arg;
    Fmt f;
    Proc *p;

    if((_threaddebuglevel&flag) == 0)
        return;

    fmtfdinit(&f, 2, buf, sizeof buf);

    p = _threadgetproc();
    if(p==nil)
        fmtprint(&f, "noproc ");
    else if(p->thread)
        fmtprint(&f, "%d.%d ", p->pid, p->thread->id);
    else
        fmtprint(&f, "%d._ ", p->pid);

    va_start(arg, fmt);
    fmtvprint(&f, fmt, arg);
    va_end(arg);
    fmtprint(&f, "\n");
    fmtfdflush(&f);
}
@



\section{Advanced topics}

% dead?
<<global _threadnotefd>>=
int	_threadnotefd;
@

% dead?
<<global _threadpasserpid>>=
int	_threadpasserpid;
@


% dead?
<<function _times>>=
static long
_times(long *t)
{
    char b[200], *p;
    int f;
    ulong r;

    memset(b, 0, sizeof(b));
    f = open("/dev/cputime", OREAD|OCEXEC);
    if(f < 0)
        return 0;
    if(read(f, b, sizeof(b)) <= 0){
        close(f);
        return 0;
    }
    p = b;
    if(t)
        t[0] = atol(p);
    p = skip(p);
    if(t)
        t[1] = atol(p);
    p = skip(p);
    r = atol(p);
    if(t){
        p = skip(p);
        t[2] = atol(p);
        p = skip(p);
        t[3] = atol(p);
    }
    return r;
}
@

% _times -> <>
<<function skip (libthread/main.c)>>=
static char*
skip(char *p)
{
    while(*p == ' ')
        p++;
    while(*p != ' ' && *p != 0)
        p++;
    return p;
}
@


\subsection{Per  thread private data}

<<global privlock (libthread/id.c)>>=
static Lock privlock;
@

<<global privmask>>=
//array<bool> NPRIV at least
static int privmask = 1;
@

<<function tprivalloc>>=
int
tprivalloc(void)
{
    int i;

    lock(&privlock);
    for(i=0; i<NPRIV; i++)
        if(!(privmask&(1<<i))){
            privmask |= 1<<i;
            unlock(&privlock);
            return i;
        }
    unlock(&privlock);
    return -1;
}
@

<<function tprivfree>>=
void
tprivfree(int i)
{
    if(i < 0 || i >= NPRIV)
        abort();
    lock(&privlock);
    privmask &= ~(1<<i);
}
@

<<function tprivaddr>>=
void**
tprivaddr(int i)
{
    return &_threadgetproc()->thread->udata[i];
}
@




<<function threaddata>>=
void**
threaddata(void)
{
    return &_threadgetproc()->thread->udata[0];
}
@

<<function _workerdata>>=
void**
_workerdata(void)
{
    return &_threadgetproc()->wdata;
}
@

<<function procdata>>=
void**
procdata(void)
{
    return &_threadgetproc()->udata;
}
@

\subsection{Thread groups}

<<function threadsetgrp>>=
int
threadsetgrp(int ng)
{
    int og;
    Thread *t;

    t = _threadgetproc()->thread;
    og = t->grp;
    t->grp = ng;
    return og;
}
@

<<function threadgetgrp>>=
int
threadgetgrp(void)
{
    return _threadgetproc()->thread->grp;
}
@

\subsection{Thread kills}


<<function tinterrupt>>=
static void
tinterrupt(Proc *p, Thread *t)
{
    switch(t->state){
    case Running:
        postnote(PNPROC, p->pid, "threadint");
        break;
    case Rendezvous:
        _threadflagrendez(t);
        break;
    }
}
@


<<function threadkillgrp>>=
void
threadkillgrp(int grp)
{
    threadxxxgrp(grp, 1);
}
@

<<function threadkill>>=
void
threadkill(int id)
{
    threadxxx(id, 1);
}
@


<<function threadxxxgrp>>=
static void
threadxxxgrp(int grp, int dokill)
{
    Proc *p;
    Thread *t;

    lock(&_threadpq.lock);
    for(p=_threadpq.head; p; p=p->next){
        lock(&p->lock);
        for(t=p->threads.head; t; t=t->nextt)
            if(t->grp == grp){
                if(dokill)
                    t->moribund = 1;
                tinterrupt(p, t);
            }
        unlock(&p->lock);
    }
    unlock(&_threadpq.lock);
    _threadbreakrendez();
}
@

<<function threadxxx>>=
static void
threadxxx(int id, int dokill)
{
    Proc *p;
    Thread *t;

    lock(&_threadpq.lock);
    for(p=_threadpq.head; p; p=p->next){
        lock(&p->lock);
        for(t=p->threads.head; t; t=t->nextt)
            if(t->id == id){
                if(dokill)
                    t->moribund = 1;
                tinterrupt(p, t);
                unlock(&p->lock);
                unlock(&_threadpq.lock);
                _threadbreakrendez();
                return;
            }
        unlock(&p->lock);
    }
    unlock(&_threadpq.lock);
    _threaddebug(DBGNOTE, "Can't find thread to kill");
    return;
}
@



<<function threadintgrp>>=
void
threadintgrp(int grp)
{
    threadxxxgrp(grp, 0);
}
@

<<function threadint>>=
void
threadint(int id)
{
    threadxxx(id, 0);
}
@


\subsection{Rendez vous}

<<constant RENDHASH>>=
RENDHASH = 13,
@

<<struct Rgrp>>=
struct Rgrp
{
    Lock	lock;
    Thread	*hash[RENDHASH];
};
@

<<global _threadrgrp>>=
Rgrp _threadrgrp;
@

<<function _threadrendezvous>>=
void*
_threadrendezvous(void *tag, void *val)
{
    void *ret;
    Thread *t, **l;

    lock(&_threadrgrp.lock);
    l = &_threadrgrp.hash[((uintptr)tag)%nelem(_threadrgrp.hash)];
    for(t=*l; t; l=&t->rendhash, t=*l){
        if(t->rendtag==tag){
            _threaddebug(DBGREND, "Rendezvous with thread %d.%d", t->proc->pid, t->id);
            *l = t->rendhash;
            ret = finish(t, val);
            unlock(&_threadrgrp.lock);
            return ret;
        }
    }

    /* Going to sleep here. */
    t = _threadgetproc()->thread;
    t->rendbreak = 0;
    t->inrendez = 1;
    t->rendtag = tag;
    t->rendval = val;
    t->rendhash = *l;
    *l = t;
    t->nextstate = Rendezvous;
    _threaddebug(DBGREND, "Rendezvous for tag %p", t->rendtag);
    unlock(&_threadrgrp.lock);
    _sched();
    t->inrendez = 0;
    _threaddebug(DBGREND, "Woke after rendezvous; val is %p", t->rendval);
    return t->rendval;
}
@


<<global isdirty>>=
static int isdirty;
@

<<function finish>>=
static void*
finish(Thread *t, void *val)
{
    void *ret;

    ret = t->rendval;
    t->rendval = val;
    while(t->state == Running)
        sleep(0);
    lock(&t->proc->lock);
    if(t->state == Rendezvous){	/* not always true: might be Dead */
        t->state = Ready;
        _threadready(t);
    }
    unlock(&t->proc->lock);
    return ret;
}
@


<<function _threadflagrendez>>=
/*
 * This is called while holding _threadpq.lock and p->lock,
 * so we can't lock _threadrgrp.lock.  Instead our caller has 
 * to call _threadbreakrendez after dropping those locks.
 */
void
_threadflagrendez(Thread *t)
{
    t->rendbreak = 1;
    isdirty = 1;
}
@

<<function _threadbreakrendez>>=
void
_threadbreakrendez(void)
{
    int i;
    Thread *t, **l;

    if(isdirty == 0)
        return;
    lock(&_threadrgrp.lock);
    if(isdirty == 0){
        unlock(&_threadrgrp.lock);
        return;
    }
    isdirty = 0;
    for(i=0; i<nelem(_threadrgrp.hash); i++){
        l = &_threadrgrp.hash[i];
        for(t=*l; t; t=*l){
            if(t->rendbreak){
                *l = t->rendhash;
                finish(t, (void*)~0);
            }else
                 l=&t->rendhash;
        }
    }
    unlock(&_threadrgrp.lock);
}
@



\subsection{[[chanprint()]]}

<<function chanprint>>=
int
chanprint(Channel *c, char *fmt, ...)
{
    va_list arg;
    char *p;
    int n;

    va_start(arg, fmt);
    p = vsmprint(fmt, arg);
    va_end(arg);
    if(p == nil)
        sysfatal("vsmprint failed: %r");
    n = sendp(c, p);
    yield();	/* let recipient handle message immediately */
    return n;
}
@



\chapter{Network}

% More in Network.nw, here just wrappers.

<<type NetConnInfo>>=
struct NetConnInfo {
    char    *dir;       /* connection directory */
    char    *root;      /* network root */
    char    *spec;      /* binding spec */
    char    *lsys;      /* local system */
    char    *lserv;     /* local service */
    char    *rsys;      /* remote system */
    char    *rserv;     /* remote service */
    char    *laddr;     /* local address */
    char    *raddr;     /* remote address */
};
@

\section{[[netmkaddr()]]}

<<function netmkaddr>>=
/*
 *  make an address, add the defaults
 */
char *
netmkaddr(char *linear, char *defnet, char *defsrv)
{
    static char addr[256];
    char *cp;

    /*
     *  dump network name
     */
    cp = strchr(linear, '!');
    if(cp == 0){
        if(defnet==0){
            if(defsrv)
                snprint(addr, sizeof(addr), "net!%s!%s",
                    linear, defsrv);
            else
                snprint(addr, sizeof(addr), "net!%s", linear);
        }
        else {
            if(defsrv)
                snprint(addr, sizeof(addr), "%s!%s!%s", defnet,
                    linear, defsrv);
            else
                snprint(addr, sizeof(addr), "%s!%s", defnet,
                    linear);
        }
        return addr;
    }

    /*
     *  if there is already a service, use it
     */
    cp = strchr(cp+1, '!');
    if(cp)
        return linear;

    /*
     *  add default service
     */
    if(defsrv == 0)
        return linear;
    snprint(addr, sizeof(addr), "%s!%s", linear, defsrv);

    return addr;
}
@
\section{[[announce()]], [[accept()]], [[listen()]], [[reject()]]}

<<function announce>>=
/*
 *  announce a network service.
 */
int
announce(char *addr, char *dir)
{
    int ctl, n, m;
    char buf[Maxpath];
    char buf2[Maxpath];
    char netdir[Maxpath];
    char naddr[Maxpath];
    char *cp;

    /*
     *  translate the address
     */
    if(nettrans(addr, naddr, sizeof(naddr), netdir, sizeof(netdir)) < 0)
        return -1;

    /*
     * get a control channel
     */
    ctl = open(netdir, ORDWR);
    if(ctl<0){
        werrstr("announce opening %s: %r", netdir);
        return -1;
    }
    cp = strrchr(netdir, '/');
    if(cp == nil){
        werrstr("announce arg format %s", netdir);
        close(ctl);
        return -1;
    }
    *cp = 0;

    /*
     *  find out which line we have
     */
    n = snprint(buf, sizeof(buf), "%s/", netdir);
    m = read(ctl, &buf[n], sizeof(buf)-n-1);
    if(m <= 0){
        werrstr("announce reading %s: %r", netdir);
        close(ctl);
        return -1;
    }
    buf[n+m] = 0;

    /*
     *  make the call
     */
    n = snprint(buf2, sizeof(buf2), "announce %s", naddr);
    if(write(ctl, buf2, n)!=n){
        werrstr("announce writing %s: %r", netdir);
        close(ctl);
        return -1;
    }

    /*
     *  return directory etc.
     */
    if(dir){
        strncpy(dir, buf, NETPATHLEN);
        dir[NETPATHLEN-1] = 0;
    }
    return ctl;
}
@

<<function listen>>=
/*
 *  listen for an incoming call
 */
int
listen(char *dir, char *newdir)
{
    int ctl, n, m;
    char buf[Maxpath];
    char *cp;

    /*
     *  open listen, wait for a call
     */
    snprint(buf, sizeof(buf), "%s/listen", dir);
    ctl = open(buf, ORDWR);
    if(ctl < 0){
        werrstr("listen opening %s: %r", buf);
        return -1;
    }

    /*
     *  find out which line we have
     */
    strncpy(buf, dir, sizeof(buf) - 1);
    buf[sizeof(buf) - 1] = 0;
    cp = strrchr(buf, '/');
    if(cp == nil){
        close(ctl);
        werrstr("listen arg format %s", dir);
        return -1;
    }
    *++cp = 0;
    n = cp-buf;
    m = read(ctl, cp, sizeof(buf) - n - 1);
    if(m <= 0){
        close(ctl);
        werrstr("listen reading %s/listen: %r", dir);
        return -1;
    }
    buf[n+m] = 0;

    /*
     *  return directory etc.
     */
    if(newdir){
        strncpy(newdir, buf, NETPATHLEN);
        newdir[NETPATHLEN-1] = 0;
    }
    return ctl;

}
@

<<function accept>>=
/*
 *  accept a call, return an fd to the open data file
 */
int
accept(int ctl, char *dir)
{
    char buf[Maxpath];
    char *num;
    long n;

    num = strrchr(dir, '/');
    if(num == nil)
        num = dir;
    else
        num++;

    n = snprint(buf, sizeof(buf), "accept %s", num);
    write(ctl, buf, n); /* ignore return value, network might not need accepts */

    snprint(buf, sizeof(buf), "%s/data", dir);
    return open(buf, ORDWR);
}
@

<<function reject>>=
/*
 *  reject a call, tell device the reason for the rejection
 */
int
reject(int ctl, char *dir, char *cause)
{
    char buf[Maxpath];
    char *num;
    long n;

    num = strrchr(dir, '/');
    if(num == 0)
        num = dir;
    else
        num++;
    snprint(buf, sizeof(buf), "reject %s %s", num, cause);
    n = strlen(buf);
    if(write(ctl, buf, n) != n)
        return -1;
    return 0;
}
@


\section{[[dial()]]}

<<function dial>>=
int
dial(char *dest, char *local, char *dir, int *cfdp)
{
    return (*_dial)(dest, local, dir, cfdp);
}
@

<<global _dial>>=
/*
 * the thread library can't cope with rfork(RFMEM|RFPROC),
 * so it must override this with a private version of dial.
 */
int (*_dial)(char *, char *, char *, int *) = dialimpl;
@


<<function dialimpl>>=
/*
 *  the dialstring is of the form '[/net/]proto!dest'
 */
static int
dialimpl(char *dest, char *local, char *dir, int *cfdp)
{
    DS ds;
    int rv;
    char err[ERRMAX], alterr[ERRMAX];

    ds.local = local;
    ds.dir = dir;
    ds.cfdp = cfdp;

    _dial_string_parse(dest, &ds);
    if(ds.netdir)
        return csdial(&ds);

    ds.netdir = "/net";
    rv = csdial(&ds);
    if(rv >= 0)
        return rv;
    err[0] = '\0';
    errstr(err, sizeof err);
    if(strstr(err, "refused") != 0){
        werrstr("%s", err);
        return rv;
    }
    ds.netdir = "/net.alt";
    rv = csdial(&ds);
    if(rv >= 0)
        return rv;

    alterr[0] = 0;
    errstr(alterr, sizeof alterr);
    if(strstr(alterr, "translate") || strstr(alterr, "does not exist"))
        werrstr("%s", err);
    else
        werrstr("%s", alterr);
    return rv;
}
@


\chapter{Mathematics}
%http://developerblog.redhat.com/2015/01/02/improving-math-performance-in-glibc/

% _div and _mod are in Assembler.nw appendix

% "Computer Approximations, by Hart, Chenney, Lawson, ...
% lib by Sun with all those s_xxx.c, w_xxx.c (see kernel-snowflake/lib/m/)

\section{Basics}

<<function abs>>=
int
abs(int a)
{
    if(a < 0)
        return -a;
    return a;
}
@

<<function fabs>>=
double
fabs(double arg)
{

    if(arg < 0)
        return -arg;
    return arg;
}
@

%dead:
%<<function labs>>=
%long
%labs(long a)
%{
%    if(a < 0)
%        return -a;
%    return a;
%}
%@

% floor and ceiling in an appartment :)

<<function floor>>=
/*
 * floor and ceil-- greatest integer <= arg
 * (resp least >=)
 */
double
floor(double d)
{
    double fract;

    if(d < 0) {
        fract = modf(-d, &d);
        if(fract != 0.0)
            d += 1;
        d = -d;
    } else
        modf(d, &d);
    return d;
}
@

<<function ceil>>=
double
ceil(double d)
{
    return -floor(-d);
}
@





\section{Integers}

\subsection{Parsing}

<<function atoi>>=
int
atoi(char *s)
{

    return atol(s);
}
@

% support hexa, octal, decimal notations! handle whitespace,
% handle signs!
<<function atol>>=
long
atol(char *s)
{
    long n;
    int f, c;

    n = 0;
    f = 0;
    while(*s == ' ' || *s == '\t')
        s++;
    if(*s == '-' || *s == '+') {
        if(*s++ == '-')
            f = 1;
        while(*s == ' ' || *s == '\t')
            s++;
    }
    if(s[0]=='0' && s[1]) {
        if(s[1]=='x' || s[1]=='X'){
            s += 2;
            for(;;) {
                c = *s;
                if(c >= '0' && c <= '9')
                    n = n*16 + c - '0';
                else
                if(c >= 'a' && c <= 'f')
                    n = n*16 + c - 'a' + 10;
                else
                if(c >= 'A' && c <= 'F')
                    n = n*16 + c - 'A' + 10;
                else
                    break;
                s++;
            }
        } else
            while(*s >= '0' && *s <= '7')
                n = n*8 + *s++ - '0';
    } else
        while(*s >= '0' && *s <= '9')
            n = n*10 + *s++ - '0';
    if(f)
        n = -n;
    return n;
}
@




<<constant LONG_MAX>>=
#define LONG_MAX    2147483647L
@

<<constant LONG_MIN>>=
#define LONG_MIN    -2147483648L
@

% more flexible than atol, can accept stuff after numbers
% and return pointer after. 
% Can also use different base?? use? to not force to prefix with 0x or 0o?
<<function strtol>>=
long
strtol(char *nptr, char **endptr, int base)
{
    char *p;
    long n, nn, m;
    int c, ovfl, v, neg, ndig;

    p = nptr;
    neg = 0;
    n = 0;
    ndig = 0;
    ovfl = 0;

    /*
     * White space
     */
    for(;; p++) {
        switch(*p) {
        case ' ':
        case '\t':
        case '\n':
        case '\f':
        case '\r':
        case '\v':
            continue;
        }
        break;
    }

    /*
     * Sign
     */
    if(*p=='-' || *p=='+')
        if(*p++ == '-')
            neg = 1;

    /*
     * Base
     */
    if(base==0) {
        base = 10;
        if(*p == '0') {
            base = 8;
            if(p[1]=='x' || p[1]=='X') {
                p += 2;
                base = 16;
            }
        }
    } else
    if(base==16 && *p=='0'){
        if(p[1]=='x' || p[1]=='X')
            p += 2;
    } else
    if(base<0 || 36<base)
        goto Return;

    /*
     * Non-empty sequence of digits
     */
    m = LONG_MAX/base;
    for(;; p++,ndig++){
        c = *p;
        v = base;
        if('0'<=c && c<='9')
            v = c - '0';
        else
        if('a'<=c && c<='z')
            v = c - 'a' + 10;
        else
        if('A'<=c && c<='Z')
            v = c - 'A' + 10;
        if(v >= base)
            break;
        if(n > m)
            ovfl = 1;
        nn = n*base + v;
        if(nn < n)
            ovfl = 1;
        n = nn;
    }

Return:
    if(ndig == 0)
        p = nptr;
    if(endptr)
        *endptr = p;
    if(ovfl){
        if(neg)
            return LONG_MIN;
        return LONG_MAX;
    }
    if(neg)
        return -n;
    return n;
}
@


\section{Floats}

\subsection{Special numbers}


<<function NaN>>=
double
NaN(void)
{
    FPdbleword a;

    a.hi = NANEXP;
    a.lo = 1;
    return a.x;
}
@

<<constant NANEXP>>=
#define NANEXP  (2047<<20)
@
% >>
% what is the meaning of those numbers? wikipedia?

<<constant NANMASK>>=
#define NANMASK (2047<<20)
@
% >>

<<function isNaN>>=
bool
isNaN(double d)
{
    FPdbleword a;

    a.x = d;
    if((a.hi & NANMASK) != NANEXP)
        return false;
    return !isInf(d, 0);
}
@


<<constant NANSIGN>>=
#define NANSIGN (1<<31)
@
% >>

<<function Inf>>=
double
Inf(int sign)
{
    FPdbleword a;

    a.hi = NANEXP;
    a.lo = 0;
    if(sign < 0)
        a.hi |= NANSIGN;
    return a.x;
}
@

<<function isInf>>=
bool
isInf(double d, int sign)
{
    FPdbleword a;

    a.x = d;
    if(a.lo != 0)
        return false;
    if(a.hi == NANEXP)
        return sign >= 0;
    if(a.hi == (NANEXP|NANSIGN))
        return sign <= 0;
    return false;
}
@



<<type FPxxx>>=
/* VFP FCR */
#define FPINEX  (1<<12)         /* trap enables for exceptions */
#define FPUNFL  (1<<11)
#define FPOVFL  (1<<10)
#define FPZDIV  (1<<9)
#define FPINVAL (1<<8)
#define FPRNR   (0<<22)
#define FPRZ    (1<<22)
#define FPRPINF (2<<22)
#define FPRNINF (3<<22)
#define FPRMASK (3<<22)
#define FPPEXT  0
#define FPPSGL  0
#define FPPDBL  0
#define FPPMASK 0
/* FSR */
#define FPAINEX (1<<4)          /* accrued exceptions */
#define FPAUNFL (1<<3)
#define FPAOVFL (1<<2)
#define FPAZDIV (1<<1)
#define FPAINVAL    (1<<0)
@
% >> >> >> >> >> >> >>
% >> >> >> >> >> >> >>
% >> >> >> >> >> >> >>


\subsection{Parsing}

<<function atof>>=
double
atof(char *cp)
{
    return strtod(cp, nil);
}
@

<<function strtod>>=
double
strtod(char *as, char **aas)
{
    int na, ona, ex, dp, bp, c, i, flag, state;
    ulong low[Prec], hig[Prec], mid[Prec], num, den;
    double d;
    char *s, a[Ndig];

    flag = 0;   // Fsign, Fesign, Fdpoint
    na = 0;     // number of digits of a[]
    dp = 0;     // na of decimal point
    ex = 0;     // exonent

    state = S0;
    for(s=as;; s++) {
        c = *s;
        if(c >= '0' && c <= '9') {
            switch(state) {
            case S0:
            case S1:
            case S2:
                state = S2;
                break;
            case S3:
            case S4:
                state = S4;
                break;

            case S5:
            case S6:
            case S7:
                state = S7;
                ex = ex*10 + (c-'0');
                continue;
            }
            if(na == 0 && c == '0') {
                dp--;
                continue;
            }
            if(na < Ndig-50)
                a[na++] = c;
            continue;
        }
        switch(c) {
        case '\t':
        case '\n':
        case '\v':
        case '\f':
        case '\r':
        case ' ':
            if(state == S0)
                continue;
            break;
        case '-':
            if(state == S0)
                flag |= Fsign;
            else
                flag |= Fesign;
        case '+':
            if(state == S0)
                state = S1;
            else
            if(state == S5)
                state = S6;
            else
                break;  // syntax
            continue;
        case '.':
            flag |= Fdpoint;
            dp = na;
            if(state == S0 || state == S1) {
                state = S3;
                continue;
            }
            if(state == S2) {
                state = S4;
                continue;
            }
            break;
        case 'e':
        case 'E':
            if(state == S2 || state == S4) {
                state = S5;
                continue;
            }
            break;
        }
        break;
    }

    /*
     * clean up return char-pointer
     */
    switch(state) {
    case S0:
        if(xcmp(s, "nan") == 0) {
            if(aas != nil)
                *aas = s+3;
            goto retnan;
        }
    case S1:
        if(xcmp(s, "infinity") == 0) {
            if(aas != nil)
                *aas = s+8;
            goto retinf;
        }
        if(xcmp(s, "inf") == 0) {
            if(aas != nil)
                *aas = s+3;
            goto retinf;
        }
    case S3:
        if(aas != nil)
            *aas = as;
        goto ret0;  // no digits found
    case S6:
        s--;        // back over +-
    case S5:
        s--;        // back over e
        break;
    }
    if(aas != nil)
        *aas = s;

    if(flag & Fdpoint)
    while(na > 0 && a[na-1] == '0')
        na--;
    if(na == 0)
        goto ret0;  // zero
    a[na] = 0;
    if(!(flag & Fdpoint))
        dp = na;
    if(flag & Fesign)
        ex = -ex;
    dp += ex;
    if(dp < -Maxe-Nmant/3)  /* actually -Nmant*log(2)/log(10), but Nmant/3 close enough */
        goto ret0;  // underflow by exp
    else
    if(dp > +Maxe)
        goto retinf;    // overflow by exp

    /*
     * normalize the decimal ascii number
     * to range .[5-9][0-9]* e0
     */
    bp = 0;     // binary exponent
    while(dp > 0)
        divascii(a, &na, &dp, &bp);
    while(dp < 0 || a[0] < '5')
        mulascii(a, &na, &dp, &bp);
    a[na] = 0;

    /*
     * very small numbers are represented using
     * bp = -Bias+1.  adjust accordingly.
     */
    if(bp < -Bias+1){
        ona = na;
        divby(a, &na, -bp-Bias+1);
        if(na < ona){
            memmove(a+ona-na, a, na);
            memset(a, '0', ona-na);
            na = ona;
        }
        a[na] = 0;
        bp = -Bias+1;
    }

    /* close approx by naive conversion */
    num = 0;
    den = 1;
    for(i=0; i<9 && (c=a[i]); i++) {
        num = num*10 + (c-'0');
        den *= 10;
    }
    low[0] = umuldiv(num, One, den);
    hig[0] = umuldiv(num+1, One, den);
    for(i=1; i<Prec; i++) {
        low[i] = 0;
        hig[i] = One-1;
    }

    /* binary search for closest mantissa */
    for(;;) {
        /* mid = (hig + low) / 2 */
        c = 0;
        for(i=0; i<Prec; i++) {
            mid[i] = hig[i] + low[i];
            if(c)
                mid[i] += One;
            c = mid[i] & 1;
            mid[i] >>= 1;
        }
        frnorm(mid);

        /* compare */
        c = fpcmp(a, mid);
        if(c > 0) {
            c = 1;
            for(i=0; i<Prec; i++)
                if(low[i] != mid[i]) {
                    c = 0;
                    low[i] = mid[i];
                }
            if(c)
                break;  // between mid and hig
            continue;
        }
        if(c < 0) {
            for(i=0; i<Prec; i++)
                hig[i] = mid[i];
            continue;
        }

        /* only hard part is if even/odd roundings wants to go up */
        c = mid[Prec-1] & (Sigbit-1);
        if(c == Sigbit/2 && (mid[Prec-1]&Sigbit) == 0)
            mid[Prec-1] -= c;
        break;  // exactly mid
    }

    /* normal rounding applies */
    c = mid[Prec-1] & (Sigbit-1);
    mid[Prec-1] -= c;
    if(c >= Sigbit/2) {
        mid[Prec-1] += Sigbit;
        frnorm(mid);
    }
    d = 0;
    for(i=0; i<Prec; i++)
        d = d*One + mid[i];
    if(flag & Fsign)
        d = -d;
    d = ldexp(d, bp - Prec*Nbits);
    return d;

ret0:
    return 0;

retnan:
    return NaN();

retinf:
    if(flag & Fsign)
        return Inf(-1);
    return Inf(+1);
}
@


<<enum _anon_ (port/strtod.c)>>=
/*
 * This routine will convert to arbitrary precision
 * floating point entirely in multi-precision fixed.
 * The answer is the closest floating point number to
 * the given decimal number. Exactly half way are
 * rounded ala ieee rules.
 * Method is to scale input decimal between .500 and .999...
 * with external power of 2, then binary search for the
 * closest mantissa to this decimal number.
 * Nmant is is the required precision. (53 for ieee dp)
 * Nbits is the max number of bits/word. (must be <= 28)
 * Prec is calculated - the number of words of fixed mantissa.
 */
enum
{
    Nbits   = 28,               // bits safely represented in a ulong
    Nmant   = 53,               // bits of precision required
    Bias        = 1022,
    Prec    = (Nmant+Nbits+1)/Nbits,    // words of Nbits each to represent mantissa
    Sigbit  = 1<<(Prec*Nbits-Nmant),    // first significant bit of Prec-th word
    Ndig    = 1500,
    One = (ulong)(1<<Nbits),
    Half    = (ulong)(One>>1),
    Maxe    = 310,
    Fsign   = 1<<0,     // found -
    Fesign  = 1<<1,     // found e-
    Fdpoint = 1<<2,     // found .

    S0  = 0,        // _        _S0 +S1 #S2 .S3
    S1,         // _+       #S2 .S3
    S2,         // _+#      #S2 .S4 eS5
    S3,         // _+.      #S4
    S4,         // _+#.#    #S4 eS5
    S5,         // _+#.#e   +S6 #S7
    S6,         // _+#.#e+  #S7
    S7,         // _+#.#e+# #S7
};
@
% >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >>

<<struct Tab>>=
struct  Tab
{
    int bp;
    int siz;
    char*   cmp;
};
@


<<function frnorm>>=
static void
frnorm(ulong *f)
{
    int i, c;

    c = 0;
    for(i=Prec-1; i>0; i--) {
        f[i] += c;
        c = f[i] >> Nbits;
        f[i] &= One-1;
    }
    f[0] += c;
}
@

<<function fpcmp>>=
static int
fpcmp(char *a, ulong* f)
{
    ulong tf[Prec];
    int i, d, c;

    for(i=0; i<Prec; i++)
        tf[i] = f[i];

    for(;;) {
        /* tf *= 10 */
        for(i=0; i<Prec; i++)
            tf[i] = tf[i]*10;
        frnorm(tf);
        d = (tf[0] >> Nbits) + '0';
        tf[0] &= One-1;

        /* compare next digit */
        c = *a;
        if(c == 0) {
            if('0' < d)
                return -1;
            if(tf[0] != 0)
                goto cont;
            for(i=1; i<Prec; i++)
                if(tf[i] != 0)
                    goto cont;
            return 0;
        }
        if(c > d)
            return +1;
        if(c < d)
            return -1;
        a++;
    cont:;
    }
}
@



<<function _divby>>=
static void
_divby(char *a, int *na, int b)
{
    int n, c;
    char *p;

    p = a;
    n = 0;
    while(n>>b == 0) {
        c = *a++;
        if(c == 0) {
            while(n) {
                c = n*10;
                if(c>>b)
                    break;
                n = c;
            }
            goto xx;
        }
        n = n*10 + c-'0';
        (*na)--;
    }
    for(;;) {
        c = n>>b;
        n -= c<<b;
        *p++ = c + '0';
        c = *a++;
        if(c == 0)
            break;
        n = n*10 + c-'0';
    }
    (*na)++;
xx:
    while(n) {
        n = n*10;
        c = n>>b;
        n -= c<<b;
        *p++ = c + '0';
        (*na)++;
    }
    *p = 0;
}
@
% >> >>

<<function divby>>=
static void
divby(char *a, int *na, int b)
{
    while(b > 9){
        _divby(a, na, 9);
        a[*na] = 0;
        b -= 9;
    }
    if(b > 0)
        _divby(a, na, b);
}
@

<<global tab1>>=
static  Tab tab1[] =
{
     1,  0, "",
     3,  1, "7",
     6,  2, "63",
     9,  3, "511",
    13,  4, "8191",
    16,  5, "65535",
    19,  6, "524287",
    23,  7, "8388607",
    26,  8, "67108863",
    27,  9, "134217727",
};
@

<<function divascii>>=
static void
divascii(char *a, int *na, int *dp, int *bp)
{
    int b, d;
    Tab *t;

    d = *dp;
    if(d >= nelem(tab1))
        d = nelem(tab1)-1;
    t = tab1 + d;
    b = t->bp;
    if(memcmp(a, t->cmp, t->siz) > 0)
        d--;
    *dp -= d;
    *bp += b;
    divby(a, na, b);
}
@

<<function mulby>>=
static void
mulby(char *a, char *p, char *q, int b)
{
    int n, c;

    n = 0;
    *p = 0;
    for(;;) {
        q--;
        if(q < a)
            break;
        c = *q - '0';
        c = (c<<b) + n;
        n = c/10;
        c -= n*10;
        p--;
        *p = c + '0';
    }
    while(n) {
        c = n;
        n = c/10;
        c -= n*10;
        p--;
        *p = c + '0';
    }
}
@
% >>

<<global tab2>>=
static  Tab tab2[] =
{
     1,  1, "",             // dp = 0-0
     3,  3, "125",
     6,  5, "15625",
     9,  7, "1953125",
    13, 10, "1220703125",
    16, 12, "152587890625",
    19, 14, "19073486328125",
    23, 17, "11920928955078125",
    26, 19, "1490116119384765625",
    27, 19, "7450580596923828125",      // dp 8-9
};
@

<<function mulascii>>=
static void
mulascii(char *a, int *na, int *dp, int *bp)
{
    char *p;
    int d, b;
    Tab *t;

    d = -*dp;
    if(d >= nelem(tab2))
        d = nelem(tab2)-1;
    t = tab2 + d;
    b = t->bp;
    if(memcmp(a, t->cmp, t->siz) < 0)
        d--;
    p = a + *na;
    *bp -= b;
    *dp += d;
    *na += d;
    mulby(a, p+d, p, b);
}
@

<<function xcmp>>=
static int
xcmp(char *a, char *b)
{
    int c1, c2;

    while(c1 = *b++) {
        c2 = *a++;
        if(isupper(c2))
            c2 = tolower(c2);
        if(c1 != c2)
            return 1;
    }
    return 0;
}
@



\subsection{[[sqrt()]]}

<<function sqrt>>=
double
sqrt(double arg)
{
    double x, temp;
    int exp, i;

    if(arg <= 0) {
        if(arg < 0)
            return NaN();
        return 0;
    }
    if(isInf(arg, 1))
        return arg;
    x = frexp(arg, &exp);
    while(x < 0.5) {
        x *= 2;
        exp--;
    }
    /*
     * NOTE
     * this wont work on 1's comp
     */
    if(exp & 1) {
        x *= 2;
        exp--;
    }
    temp = 0.5 * (1.0+x);

    while(exp > 60) {
        temp *= (1L<<30);
        exp -= 60;
    }
    while(exp < -60) {
        temp /= (1L<<30);
        exp += 60;
    }
    if(exp >= 0)
        temp *= 1L << (exp/2);
    else
        temp /= 1L << (-exp/2);
    for(i=0; i<=4; i++)
        temp = 0.5*(temp + arg/temp);
    return temp;
}
@
% >> >> >> >> >> >>

\subsection{[[modf()]]}


% used by floor, ceil

<<function modf>>=
double
modf(double d, double *ip)
{
    FPdbleword x;
    int e;

    x.x = d;
    e = (x.hi >> SHIFT) & MASK;
    if(e == MASK){
        *ip = d;
        if(x.lo != 0 || (x.hi & 0xfffffL) != 0) /* NaN */
            return d;
        /* Inf */
        x.hi &= 0x80000000L;
        return x.x;
    }
    if(d < 1) {
        if(d < 0) {
            x.x = modf(-d, ip);
            *ip = -*ip;
            return -x.x;
        }
        *ip = 0;
        return d;
    }
    e -= BIAS;
    if(e <= SHIFT+1) {
        x.hi &= ~(0x1fffffL >> e);
        x.lo = 0;
    } else
    if(e <= SHIFT+33)
        x.lo &= ~(0x7fffffffL >> (e-SHIFT-2));
    *ip = x.x;
    return d - x.x;
}
@
\subsection{[[fmod()]]}


<<function fmod>>=
/*
 * floating-point mod function without infinity or NaN checking
 */
double
fmod (double x, double y)
{
    int sign, yexp, rexp;
    double r, yfr, rfr;

    if (y == 0)
        return x;
    if (y < 0)
        y = -y;
    yfr = frexp(y, &yexp);
    sign = 0;
    if(x < 0) {
        r = -x;
        sign++;
    } else
        r = x;
    while(r >= y) {
        rfr = frexp(r, &rexp);
        r -= ldexp(y, rexp - yexp - (rfr < yfr));
    }
    if(sign)
        r = -r;
    return r;
}
@

\subsection{[[pow()]]}

<<function pow>>=
double
pow(double x, double y) /* return x ^ y (exponentiation) */
{
    double xy, y1, ye;
    long i;
    int ex, ey, flip;

    if(y == 0.0)
        return 1.0;

    flip = 0;
    if(y < 0.){
        y = -y;
        flip = 1;
    }
    y1 = modf(y, &ye);
    if(y1 != 0.0){
        if(x <= 0.)
            goto zreturn;
        if(y1 > 0.5) {
            y1 -= 1.;
            ye += 1.;
        }
        xy = exp(y1 * log(x));
    }else
        xy = 1.0;
    if(ye > 0x7FFFFFFF){    /* should be ~0UL but compiler can't convert double to ulong */
        if(x <= 0.){
 zreturn:
            if(x==0. && !flip)
                return 0.;
            return NaN();
        }
        if(flip){
            if(y == .5)
                return 1./sqrt(x);
            y = -y;
        }else if(y == .5)
            return sqrt(x);
        return exp(y * log(x));
    }
    x = frexp(x, &ex);
    ey = 0;
    i = ye;
    if(i)
        for(;;){
            if(i & 1){
                xy *= x;
                ey += ex;
            }
            i >>= 1;
            if(i == 0)
                break;
            x *= x;
            ex <<= 1;
            if(x < .5){
                x += x;
                ex -= 1;
            }
        }
    if(flip){
        xy = 1. / xy;
        ey = -ey;
    }
    return ldexp(xy, ey);
}
@

% >> >> >> >> 

<<function pow10>>=
double
pow10(int n)
{
    int m;

    if(n < 0) {
        n = -n;
        if(n < sizeof(tab)/sizeof(tab[0]))
            return 1/tab[n];
        m = n/2;
        return 1/(pow10(m) * pow10(n-m));
    }
    if(n < sizeof(tab)/sizeof(tab[0]))
        return tab[n];
    m = n/2;
    return pow10(m) * pow10(n-m);
}
@

<<global tab>>=
/*
 * this table might overflow 127-bit exponent representations.
 * in that case, truncate it after 1.0e38.
 * it is important to get all one can from this
 * routine since it is used in atof to scale numbers.
 * the presumption is that C converts fp numbers better
 * than multipication of lower powers of 10.
 */
static
double  tab[] =
{
    1.0e0,  1.0e1,  1.0e2,  1.0e3,  1.0e4,  1.0e5,  1.0e6,  1.0e7,  1.0e8,  1.0e9, 
    1.0e10, 1.0e11, 1.0e12, 1.0e13, 1.0e14, 1.0e15, 1.0e16, 1.0e17, 1.0e18, 1.0e19, 
    1.0e20, 1.0e21, 1.0e22, 1.0e23, 1.0e24, 1.0e25, 1.0e26, 1.0e27, 1.0e28, 1.0e29, 
    1.0e30, 1.0e31, 1.0e32, 1.0e33, 1.0e34, 1.0e35, 1.0e36, 1.0e37, 1.0e38, 1.0e39, 
    1.0e40, 1.0e41, 1.0e42, 1.0e43, 1.0e44, 1.0e45, 1.0e46, 1.0e47, 1.0e48, 1.0e49, 
    1.0e50, 1.0e51, 1.0e52, 1.0e53, 1.0e54, 1.0e55, 1.0e56, 1.0e57, 1.0e58, 1.0e59, 
    1.0e60, 1.0e61, 1.0e62, 1.0e63, 1.0e64, 1.0e65, 1.0e66, 1.0e67, 1.0e68, 1.0e69, 
    1.0e70, 1.0e71, 1.0e72, 1.0e73, 1.0e74, 1.0e75, 1.0e76, 1.0e77, 1.0e78, 1.0e79, 
    1.0e80, 1.0e81, 1.0e82, 1.0e83, 1.0e84, 1.0e85, 1.0e86, 1.0e87, 1.0e88, 1.0e89, 
    1.0e90, 1.0e91, 1.0e92, 1.0e93, 1.0e94, 1.0e95, 1.0e96, 1.0e97, 1.0e98, 1.0e99, 
    1.0e100,1.0e101,1.0e102,1.0e103,1.0e104,1.0e105,1.0e106,1.0e107,1.0e108,1.0e109,
    1.0e110,1.0e111,1.0e112,1.0e113,1.0e114,1.0e115,1.0e116,1.0e117,1.0e118,1.0e119,
    1.0e120,1.0e121,1.0e122,1.0e123,1.0e124,1.0e125,1.0e126,1.0e127,1.0e128,1.0e129,
    1.0e130,1.0e131,1.0e132,1.0e133,1.0e134,1.0e135,1.0e136,1.0e137,1.0e138,1.0e139,
    1.0e140,1.0e141,1.0e142,1.0e143,1.0e144,1.0e145,1.0e146,1.0e147,1.0e148,1.0e149,
    1.0e150,1.0e151,1.0e152,1.0e153,1.0e154,1.0e155,1.0e156,1.0e157,1.0e158,1.0e159,
};
@



\section{Trigonometry}


<<function cos>>=
double
cos(double arg)
{
    if(arg < 0)
        arg = -arg;
    return sinus(arg, 1);
}
@

<<function sin>>=
double
sin(double arg)
{
    return sinus(arg, 0);
}
@




<<constant p0 (port/sin.c)>>=
#define p0      .1357884097877375669092680e8
@

<<constant p1 (port/sin.c)>>=
#define p1     -.4942908100902844161158627e7
@

<<constant p2 (port/sin.c)>>=
#define p2      .4401030535375266501944918e6
@

<<constant p3 (port/sin.c)>>=
#define p3     -.1384727249982452873054457e5
@

<<constant p4 (port/sin.c)>>=
#define p4      .1459688406665768722226959e3
@

<<constant q0 (port/sin.c)>>=
#define q0      .8644558652922534429915149e7
@

<<constant q1 (port/sin.c)>>=
#define q1      .4081792252343299749395779e6
@

<<constant q2 (port/sin.c)>>=
#define q2      .9463096101538208180571257e4
@

<<constant q3 (port/sin.c)>>=
#define q3      .1326534908786136358911494e3
@

% calls modf
<<function sinus>>=
static
double
sinus(double arg, int quad)
{
    double e, f, ysq, x, y, temp1, temp2;
    int k;

    x = arg;
    if(x < 0) {
        x = -x;
        quad += 2;
    }
    x *= 1/PIO2;    /* underflow? */
    if(x > 32764) {
        y = modf(x, &e);
        e += quad;
        modf(0.25*e, &f);
        quad = e - 4*f;
    } else {
        k = x;
        y = x - k;
        quad += k;
        quad &= 3;
    }
    if(quad & 1)
        y = 1-y;
    if(quad > 1)
        y = -y;

    ysq = y*y;
    temp1 = ((((p4*ysq+p3)*ysq+p2)*ysq+p1)*ysq+p0)*y;
    temp2 = ((((ysq+q3)*ysq+q2)*ysq+q1)*ysq+q0);
    return temp1/temp2;
}
@

%http://mooooo.ooo/chebyshev-sine-approximation/



<<global p0 (port/tan.c)>>=
static double p0     = -0.1306820264754825668269611177e+5;
@

<<global p1 (port/tan.c)>>=
static double p1      = 0.1055970901714953193602353981e+4;
@

<<global p2 (port/tan.c)>>=
static double p2     = -0.1550685653483266376941705728e+2;
@

<<global p3 (port/tan.c)>>=
static double p3      = 0.3422554387241003435328470489e-1;
@

<<global p4>>=
static double p4      = 0.3386638642677172096076369e-4;
@

<<global q0 (port/tan.c)>>=
static double q0     = -0.1663895238947119001851464661e+5;
@

<<global q1 (port/tan.c)>>=
static double q1      = 0.4765751362916483698926655581e+4;
@

<<global q2 (port/tan.c)>>=
static double q2     = -0.1555033164031709966900124574e+3;
@

<<function tan>>=
double
tan(double arg)
{
    double temp, e, x, xsq;
    int flag, sign, i;

    flag = 0;
    sign = 0;
    if(arg < 0){
        arg = -arg;
        sign++;
    }
    arg = 2*arg/PIO2;   /* overflow? */
    x = modf(arg, &e);
    i = e;
    switch(i%4) {
    case 1:
        x = 1 - x;
        flag = 1;
        break;

    case 2:
        sign = !sign;
        flag = 1;
        break;

    case 3:
        x = 1 - x;
        sign = !sign;
        break;

    case 0:
        break;
    }

    xsq = x*x;
    temp = ((((p4*xsq+p3)*xsq+p2)*xsq+p1)*xsq+p0)*x;
    temp = temp/(((xsq+q2)*xsq+q1)*xsq+q0);

    if(flag) {
        if(temp == 0)
            return NaN();
        temp = 1/temp;
    }
    if(sign)
        temp = -temp;
    return temp;
}
@




<<function asin>>=
double
asin(double arg)
{
    double temp;
    int sign;

    sign = 0;
    if(arg < 0) {
        arg = -arg;
        sign++;
    }
    if(arg > 1)
        return NaN();
    temp = sqrt(1 - arg*arg);
    if(arg > 0.7)
        temp = PIO2 - atan(temp/arg);
    else
        temp = atan(arg/temp);
    if(sign)
        temp = -temp;
    return temp;
}
@

<<function acos>>=
double
acos(double arg)
{
    if(arg > 1 || arg < -1)
        return NaN();
    return PIO2 - asin(arg);
}
@


<<function atan>>=
/*
    atan makes its argument positive and
    calls the inner routine satan.
 */

double
atan(double arg)
{

    if(arg > 0)
        return satan(arg);
    return -satan(-arg);
}
@



\section{Logarithms and exponentials}

\subsection{[[exp()]]}

<<function exp>>=
double
exp(double arg)
{
    double fract, temp1, temp2, xsq;
    int ent;

    if(arg == 0)
        return 1;
    if(arg < -maxf)
        return 0;
    if(arg > maxf)
        return Inf(1);

    arg *= log2e;
    ent = floor(arg);
    fract = (arg-ent) - 0.5;
    xsq = fract*fract;
    temp1 = ((p2*xsq+p1)*xsq+p0)*fract;
    temp2 = ((xsq+q2)*xsq+q1)*xsq + q0;
    return ldexp(sqrt2*(temp2+temp1)/(temp2-temp1), ent);
}
@

<<constant maxf>>=
#define maxf  10000
@

<<constant log2e>>=
#define log2e  1.4426950408889634073599247
@


<<constant p0 (port/exp.c)>>=
#define p0  .2080384346694663001443843411e7
@

<<constant p1 (port/exp.c)>>=
#define p1  .3028697169744036299076048876e5
@

<<constant p2 (port/exp.c)>>=
#define p2  .6061485330061080841615584556e2
@

<<constant q0 (port/exp.c)>>=
#define q0  .6002720360238832528230907598e7
@

<<constant q1 (port/exp.c)>>=
#define q1  .3277251518082914423057964422e6
@

<<constant q2 (port/exp.c)>>=
#define q2  .1749287689093076403844945335e4
@


<<constant sqrt2>>=
#define sqrt2  1.4142135623730950488016887
@

\subsection{[[ldexp()]]}


<<constant MASK (port/frexp.c)>>=
/*
 * this is big/little endian non-portable
 * it gets the endian from the FPdbleword
 * union in u.h.
 */
#define MASK    0x7ffL
@

<<constant SHIFT>>=
#define SHIFT   20
@

<<constant BIAS>>=
#define BIAS    1022L
@

<<constant SIG>>=
#define SIG 52
@


% called by fmod

<<function ldexp>>=
double
ldexp(double d, int deltae)
{
    int e, bits;
    FPdbleword x;
    ulong z;

    if(d == 0)
        return 0;
    x.x = d;
    e = (x.hi >> SHIFT) & MASK;
    if(deltae >= 0 || e+deltae >= 1){   /* no underflow */
        e += deltae;
        if(e >= MASK){      /* overflow */
            if(d < 0)
                return Inf(-1);
            return Inf(1);
        }
    }else{  /* underflow gracefully */
        deltae = -deltae;
        /* need to shift d right deltae */
        if(e > 1){      /* shift e-1 by exponent manipulation */
            deltae -= e-1;
            e = 1;
        }
        if(deltae > 0 && e==1){ /* shift 1 by switch from 1.fff to 0.1ff */
            deltae--;
            e = 0;
            x.lo >>= 1;
            x.lo |= (x.hi&1)<<31;
            z = x.hi & ((1<<SHIFT)-1);
            x.hi &= ~((1<<SHIFT)-1);
            x.hi |= (1<<(SHIFT-1)) | (z>>1);
        }
        while(deltae > 0){      /* shift bits down */
            bits = deltae;
            if(bits > SHIFT)
                bits = SHIFT;
            x.lo >>= bits;
            x.lo |= (x.hi&((1<<bits)-1)) << (32-bits);
            z = x.hi & ((1<<SHIFT)-1);
            x.hi &= ~((1<<SHIFT)-1);
            x.hi |= z>>bits;
            deltae -= bits;
        }
    }
    x.hi &= ~(MASK << SHIFT);
    x.hi |= (long)e << SHIFT;
    return x.x;
}
@
% >> >> >> >> >> >> >> >> 

\subsection{[[frexp()]]}

<<function frexp>>=
double
frexp(double d, int *ep)
{
    FPdbleword x, a;

    *ep = 0;
    /* order matters: only isNaN can operate on NaN */
    if(isNaN(d) || isInf(d, 0) || d == 0)
        return d;
    x.x = d;
    a.x = fabs(d);
    if((a.hi >> SHIFT) == 0){   /* normalize subnormal numbers */
        x.x = (double)(1ULL<<SIG) * d;
        *ep = -SIG;
    }
    *ep += ((x.hi >> SHIFT) & MASK) - BIAS;
    x.hi &= ~(MASK << SHIFT);
    x.hi |= BIAS << SHIFT;
    return x.x;
}
@

\subsection{[[log()]]}


<<function log>>=
double
log(double arg)
{
    double x, z, zsq, temp;
    int exp;

    if(arg <= 0)
        return NaN();
    x = frexp(arg, &exp);
    while(x < 0.5) {
        x *= 2;
        exp--;
    }
    if(x < sqrto2) {
        x *= 2;
        exp--;
    }

    z = (x-1) / (x+1);
    zsq = z*z;

    temp = ((p3*zsq + p2)*zsq + p1)*zsq + p0;
    temp = temp/(((zsq + q2)*zsq + q1)*zsq + q0);
    temp = temp*z + exp*log2;
    return temp;
}
@

<<constant log2>>=
#define log2    0.693147180559945309e0
@

<<constant ln10o1>>=
#define ln10o1  .4342944819032518276511
@

<<constant sqrto2>>=
#define sqrto2  0.707106781186547524e0
@

<<constant p0 (port/log.c)>>=
#define p0      -.240139179559210510e2
@

<<constant p1 (port/log.c)>>=
#define p1      0.309572928215376501e2
@

<<constant p2 (port/log.c)>>=
#define p2      -.963769093377840513e1
@

<<constant p3 (port/log.c)>>=
#define p3      0.421087371217979714e0
@

<<constant q0 (port/log.c)>>=
#define q0      -.120069589779605255e2
@

<<constant q1 (port/log.c)>>=
#define q1      0.194809660700889731e2
@

<<constant q2 (port/log.c)>>=
#define q2      -.891110902798312337e1
@


<<function log10>>=
double
log10(double arg)
{

    if(arg <= 0)
        return NaN();
    return log(arg) * ln10o1;
}
@


\section{Random numbers}
% see also Cryptography section later


<<function rand>>=
int
rand(void)
{
    return lrand() & 0x7fff;
}
@


<<function lrand>>=
long
lrand(void)
{
    ulong x;

    lock(&lk);

    rng_tap--;
    if(rng_tap < rng_vec) {
        if(rng_feed == 0) {
            isrand(1);
            rng_tap--;
        }
        rng_tap += LEN;
    }
    rng_feed--;
    if(rng_feed < rng_vec)
        rng_feed += LEN;
    x = (*rng_feed + *rng_tap) & MASK;
    *rng_feed = x;

    unlock(&lk);

    return x;
}
@

<<global lk>>=
static  Lock    lk;
@

<<global rng_vec>>=
static  ulong   rng_vec[LEN];
@

<<global rng_tap>>=
static  ulong*  rng_tap = rng_vec;
@

<<global rng_feed>>=
static  ulong*  rng_feed = 0;
@


<<function truerand>>=
ulong
truerand(void)
{
    ulong x;
    static fdt randfd = -1;

    if(randfd < 0)
        randfd = open("/dev/random", OREAD|OCEXEC);
    if(randfd < 0)
        sysfatal("can't open /dev/random");
    if(read(randfd, &x, sizeof(x)) != sizeof(x))
        sysfatal("can't read /dev/random");

    return x;
}
@





\section{muldiv}

<<function umuldiv>>=
ulong
umuldiv(ulong a, ulong b, ulong c)
{
    double d;

    d = ((double)a * (double)b) / (double)c;
    if(d >= 4294967296.)
        abort();
    return d;
}
@

<<function muldiv>>=
long
muldiv(long a, long b, long c)
{
    int s;
    long v;

    s = 0;
    if(a < 0) {
        s = !s;
        a = -a;
    }
    if(b < 0) {
        s = !s;
        b = -b;
    }
    if(c < 0) {
        s = !s;
        c = -c;
    }
    v = umuldiv(a, b, c);
    if(s)
        v = -v;
    return v;
}
@


\chapter{Error Management}


%TODO: errno
%    if(getwd(pathname, sizeof(pathname)) == 0) {
%        fprint(2, "pwd: %r\n");
%        exits("getwd");
%    }
% what is %r? last error code from libc function? a bit ugly
% those == 0 are also ugly.


<<constant ERRMAX>>=
#define	ERRMAX	128	/* max length of error string */
@

\section{syscall: [[errstr()]]}

% error code of last system call.
% but why not return error information from system call directly?
% because can not use pairs in C ... and return value sometimes already
% used? not always ...

\section{[[rerrstr()]], [[werrstr()]]}

<<function rerrstr>>=
void
rerrstr(char *buf, uint nbuf)
{
    char tmp[ERRMAX];

    tmp[0] = '\0';
    errstr(tmp, sizeof tmp);

    utfecpy(buf, buf+nbuf, tmp);
    errstr(tmp, sizeof tmp);
}
@

<<function werrstr>>=
void
werrstr(char *fmt, ...)
{
    va_list arg;
    char buf[ERRMAX];

    va_start(arg, fmt);
    vseprint(buf, buf+ERRMAX, fmt, arg);
    va_end(arg);
    errstr(buf, sizeof buf);
}
@
%old: ERRMAX -> sizeof tmp so more consistent with rerrstr

\section{[[perror()]]}

% to print last error code of last system call

% perror? errno

<<function perror>>=
void
perror(char *s)
{
    char buf[ERRMAX];

    buf[0] = '\0';
    errstr(buf, sizeof buf);
    if(s && *s)
        fprint(2, "%s: %s\n", s, buf);
    else
        fprint(2, "%s\n", buf);
}
@

\section{Error return values}

<<type errorxxx>>=
// later: unify all of that to be more consistent!
typedef int error0; // 0 is the error value
typedef int error1; // 1 is the error value
typedef int errorneg1; // -1 is the error value
typedef int errorn; // 1 or more means error
@
%pad: I added that

<<constant OKxxx>>=
#define OK_0 0
#define OK_1 1
@
%pad: I added that

<<constant ERRORxxx>>=
#define ERROR_0 0
#define ERROR_1 1
#define ERROR_NEG1 (-1)
@
%pad: I added that

\section{[[assert()]]}

<<macro assert>>=
#define assert(x)   do{ if(x) {} else _assert("x"); }while(0)
@
% note that use x inside a string so implicity strinfify in plan9 cpp
% (see Compiler.nw)


<<global _assert>>=
void (*_assert)(char*) = default_assert;
@

<<function default_assert>>=
void
default_assert(char *s)
{
    if(__assert)
        (*__assert)(s);
    fprint(2, "assert failed: %s\n", s);
    abort();
}
@

<<global __assert>>=
void (*__assert)(char*);
@
% used by libthread to point to _theadassert that does ???



<<function abort>>=
void
abort(void)
{
    while(*(int*)0)
        ;
}
@
% generate segfault


\section{[[sysfatal()]]}

% wrapper around exits that can format; also use argv0 in output
<<function sysfatal>>=
void
sysfatal(char *fmt, ...)
{
    va_list arg;

    va_start(arg, fmt);
    (*_sysfatal)(fmt, arg);
    va_end(arg);
}
@


<<global _sysfatal>>=
void (*_sysfatal)(char *fmt, va_list arg) = _sysfatalimpl;
@
% who changes that?

<<function _sysfatalimpl>>=
static void
_sysfatalimpl(char *fmt, va_list arg)
{
    char buf[1024];

    vseprint(buf, buf+sizeof(buf), fmt, arg);
    if(argv0)
        fprint(2, "%s: %s\n", argv0, buf);
    else
        fprint(2, "%s\n", buf);
    exits(buf);
}
@


\chapter{Debugging Support}

% Seen some debugging support before, for memory pool.

\section{Logging}

<<function syslog>>=
/*
 * Print
 *  sysname: time: mesg
 * on /sys/log/logname.
 * If cons or log file can't be opened, print on the system console, too.
 */
void
syslog(int cons, char *logname, char *fmt, ...)
{
    char buf[1024];
    char *ctim, *p;
    va_list arg;
    int n;
    Dir *d;
    char err[ERRMAX];

    err[0] = '\0';
    errstr(err, sizeof err);
    lock(&sl);

    /*
     *  paranoia makes us stat to make sure a fork+close
     *  hasn't broken our fd's
     */
    d = dirfstat(sl.fd);
    if(sl.fd < 0 || sl.name == nil || strcmp(sl.name, logname) != 0 ||
       !eqdirdev(d, sl.d)){
        free(sl.name);
        sl.name = strdup(logname);
        if(sl.name == nil)
            cons = 1;
        else{
            free(sl.d);
            sl.d = nil;
            _syslogopen();
            if(sl.fd < 0)
                cons = 1;
            else
                sl.d = dirfstat(sl.fd);
        }
    }
    free(d);
    if(cons){
        d = dirfstat(sl.consfd);
        if(sl.consfd < 0 || !eqdirdev(d, sl.consd)){
            free(sl.consd);
            sl.consd = nil;
            sl.consfd = open("#c/cons", OWRITE|OCEXEC);
            if(sl.consfd >= 0)
                sl.consd = dirfstat(sl.consfd);
        }
        free(d);
    }

    if(fmt == nil){
        unlock(&sl);
        return;
    }

    ctim = ctime(time(0));
    p = buf + snprint(buf, sizeof(buf)-1, "%s ", sysname());
    strncpy(p, ctim+4, 15);
    p += 15;
    *p++ = ' ';
    errstr(err, sizeof err);
    va_start(arg, fmt);
    p = vseprint(p, buf+sizeof(buf)-1, fmt, arg);
    va_end(arg);
    *p++ = '\n';
    n = p - buf;

    if(sl.fd >= 0){
        seek(sl.fd, 0, 2);
        write(sl.fd, buf, n);
    }

    if(cons && sl.consfd >=0)
        write(sl.consfd, buf, n);

    unlock(&sl);
}
@


<<global sl>>=
static struct
{
    int fd;
    int consfd;
    char    *name;
    Dir *d;
    Dir *consd;
    Lock;
} sl =
{
    -1, -1,
};
@

<<function _syslogopen>>=
static void
_syslogopen(void)
{
    char buf[1024];

    if(sl.fd >= 0)
        close(sl.fd);
    snprint(buf, sizeof(buf), "/sys/log/%s", sl.name);
    sl.fd = open(buf, OWRITE|OCEXEC);
}
@

<<function eqdirdev>>=
static int
eqdirdev(Dir *a, Dir *b)
{
    return a != nil && b != nil &&
        a->dev == b->dev && a->type == b->type &&
        a->qid.path == b->qid.path;
}
@

\chapter{Profiling Support}

% see 5l -p -1 -2! See \book{Linker}

% arm/main9p.s

<<type Prof>>=
enum Prof {
    Profoff,        /* No profiling */

    Profuser,       /* Measure user time only (default) */
    Profkernel,     /* Measure user + kernel time */
    Proftime,       /* Measure total time */
    Profsample,     /* Use clock interrupt to sample (default when there is no cycle counter) */
}; /* what */
@
%old: didnt have enum name, so no conflict with struct Prof in 5i

<<struct Plink>>=
struct  Plink
{
    Plink   *old;
    Plink   *down;
    Plink   *link;
    long    pc;
    long    count;
    vlong time;
};
@


<<function prof>>=
void
prof(void (*fn)(void*), void *arg, int entries, int what)
{
    _profinit(entries, what);
    _tos->prof.pp = _tos->prof.next;
    fn(arg);
    _profdump();
}
@




<<global khz>>=
static  ulong   khz;
@

<<global perr>>=
static  ulong   perr;
@

<<global havecycles>>=
static  int havecycles;
@

\section{[[_profin()]]}
% see \book{Linker}

% pragma profile turned off for those functins
<<function _profin>>=
// Called at every procedure entry when use 5l -p, see Linker.nw
ulong
_profin(void)
{
    void *dummy;
    long pc;
    Plink *pp, *p;
    ulong arg;
    vlong t;

    arg = _savearg();
    pc = _callpc(&dummy);
    pp = _tos->prof.pp;
    if(pp == 0 || (_tos->prof.pid && _tos->pid != _tos->prof.pid))
        return arg;

    for(p=pp->down; p; p=p->link)
        if(p->pc == pc)
            goto out;
    p = _tos->prof.next + 1;
    if(p >= _tos->prof.last) {
        _tos->prof.pp = 0;
        perr++;
        return arg;
    }
    _tos->prof.next = p;
    p->link = pp->down;
    pp->down = p;
    p->pc = pc;
    p->old = pp;
    p->down = 0;
    p->count = 0;
    p->time = 0LL;

out:
    _tos->prof.pp = p;
    p->count++;
    switch(_tos->prof.what){
    case Profkernel:
        p->time = p->time - _tos->pcycles;
        goto proftime;
    case Profuser:
        /* Add kernel cycles on proc entry */
        p->time = p->time + _tos->kcycles;
        /* fall through */
    case Proftime:  
    proftime:       /* Subtract cycle counter on proc entry */
        cycles((uvlong*)&t);
        p->time = p->time - t;
        break;
    case Profsample:
        p->time = p->time - _tos->clock;
        break;
    }
    return arg;     /* disgusting linkage */
}
@

\section{[[_profout()]]}

<<function _profout>>=
// Called at every procedure return when use 5l -p, see Linker.nw
ulong
_profout(void)
{
    Plink *p;
    ulong arg;
    vlong t;

    arg = _savearg();
    p = _tos->prof.pp;
    if (p == nil || (_tos->prof.pid != 0 && _tos->pid != _tos->prof.pid))
        return arg; /* Not our process */
    switch(_tos->prof.what){
    case Profkernel:        /* Add proc cycles on proc entry */
        p->time = p->time + _tos->pcycles;
        goto proftime;
    case Profuser:          /* Subtract kernel cycles on proc entry */
        p->time = p->time - _tos->kcycles;
        /* fall through */
    case Proftime:  
    proftime:               /* Add cycle counter on proc entry */
        cycles((uvlong*)&t);
        p->time = p->time + t;
        break;
    case Profsample:
        p->time = p->time + _tos->clock;
        break;
    }
    _tos->prof.pp = p->old;
    return arg;
}
@

\section{[[_profinit()]]}

<<function _profinit>>=
void
_profinit(int entries, int what)
{
    if (_tos->prof.what == 0)
        return; /* Profiling not linked in */
    _tos->prof.pp = nil;
    _tos->prof.first = mallocz(entries*sizeof(Plink),1);
    _tos->prof.last = _tos->prof.first + entries;
    _tos->prof.next = _tos->prof.first;
    _tos->prof.pid = _tos->pid;
    _tos->prof.what = what;
    _tos->clock = 1;
}
@

\section{[[_profmain()]]}

<<function _profmain>>=
// called by _mainp in _main9p.s when 5l -p, see Linker
void
_profmain(void)
{
    char ename[50];
    int n, f;

    n = 2000;
    if (_tos->cyclefreq != 0LL){
        khz = _tos->cyclefreq / 1000;   /* Report times in milliseconds */
        havecycles = 1;
    }
    f = open("/env/profsize", OREAD);
    if(f >= 0) {
        memset(ename, 0, sizeof(ename));
        read(f, ename, sizeof(ename)-1);
        close(f);
        n = atol(ename);
    }
    _tos->prof.what = Profuser;
    f = open("/env/proftype", OREAD);
    if(f >= 0) {
        memset(ename, 0, sizeof(ename));
        read(f, ename, sizeof(ename)-1);
        close(f);
        if (strcmp(ename, "user") == 0)
            _tos->prof.what = Profuser;
        else if (strcmp(ename, "kernel") == 0)
            _tos->prof.what = Profkernel;
        else if (strcmp(ename, "elapsed") == 0 || strcmp(ename, "time") == 0)
            _tos->prof.what = Proftime;
        else if (strcmp(ename, "sample") == 0)
            _tos->prof.what = Profsample;
    }
    _tos->prof.first = sbrk(n*sizeof(Plink));
    _tos->prof.last = sbrk(0);
    _tos->prof.next = _tos->prof.first;
    _tos->prof.pp = nil;
    _tos->prof.pid = _tos->pid;
    atexit(_profdump);
    _tos->clock = 1;
}
@


\section{[[cputime()]]}

% in 9sys/
<<constant HZ>>=
#define HZ  1000
@

<<function cputime>>=
double
cputime(void)
{
    long t[4];
    int i;

    times(t);
    for(i=1; i<4; i++)
        t[0] += t[i];
    return t[0] / (double)HZ;
}
@


\chapter{Security}

% ref_own<string> returned

\section{[[getuser()]]}

<<function getuser>>=
char*
getuser(void)
{
    static char user[64];
    fdt fd;
    int n;

    fd = open("/dev/user", OREAD);
    if(fd < 0)
        return "none";
    n = read(fd, user, (sizeof user)-1);
    close(fd);
    if(n <= 0)
        strcpy(user, "none");
    else
        user[n] = '\0';
    return user;
}
@


\section{Cryptography}


<<function encrypt>>=
/*
 * destructively encrypt the buffer, which
 * must be at least 8 characters long.
 */
int
encrypt(void *key, void *vbuf, int n)
{
    ulong ekey[32];
    uchar *buf;
    int i, r;

    if(n < 8)
        return 0;
    key_setup(key, ekey);
    buf = vbuf;
    n--;
    r = n % 7;
    n /= 7;
    for(i = 0; i < n; i++){
        block_cipher(ekey, buf, 0);
        buf += 7;
    }
    if(r)
        block_cipher(ekey, buf - 7 + r, 0);
    return 1;
}
@

<<function decrypt>>=
/*
 * destructively decrypt the buffer, which
 * must be at least 8 characters long.
 */
int
decrypt(void *key, void *vbuf, int n)
{
    ulong ekey[128];
    uchar *buf;
    int i, r;

    if(n < 8)
        return 0;
    key_setup(key, ekey);
    buf = vbuf;
    n--;
    r = n % 7;
    n /= 7;
    buf += n * 7;
    if(r)
        block_cipher(ekey, buf - 7 + r, 1);
    for(i = 0; i < n; i++){
        buf -= 7;
        block_cipher(ekey, buf, 1);
    }
    return 1;
}
@



<<function netcrypt>>=
int
netcrypt(void *key, void *chal)
{
    uchar buf[8], *p;

    strncpy((char*)buf, chal, 7);
    buf[7] = '\0';
    for(p = buf; *p && *p != '\n'; p++)
        ;
    *p = '\0';
    encrypt(key, buf, 8);
    sprint(chal, "%.2ux%.2ux%.2ux%.2ux", buf[0], buf[1], buf[2], buf[3]);
    return 1;
}
@

\section{SSL/TLS}

<<function pushssl>>=
/*
 * Since the SSL device uses decimal file descriptors to name channels,
 * it is impossible for a user-level file server to stand in for the kernel device.
 * Thus we hard-code #D rather than use /net/ssl.
 */

int
pushssl(int fd, char *alg, char *secin, char *secout, int *cfd)
{
    char buf[8];
    char dname[64];
    int n, data, ctl;

    ctl = open("#D/ssl/clone", ORDWR);
    if(ctl < 0)
        return -1;
    n = read(ctl, buf, sizeof(buf)-1);
    if(n < 0)
        goto error;
    buf[n] = 0;
    sprint(dname, "#D/ssl/%s/data", buf);
    data = open(dname, ORDWR);
    if(data < 0)
        goto error;
    if(fprint(ctl, "fd %d", fd) < 0 ||
       fprint(ctl, "secretin %s", secin) < 0 ||
       fprint(ctl, "secretout %s", secout) < 0 ||
       fprint(ctl, "alg %s", alg) < 0){
        close(data);
        goto error;
    }
    close(fd);
    if(cfd != 0)
        *cfd = ctl;
    else
        close(ctl);
    return data;
error:
    close(ctl);
    return -1;
}
@

<<function pushtls>>=
// given a plain fd and secrets established beforehand, return encrypted connection
int
pushtls(int fd, char *hashalg, char *encalg, int isclient, char *secret, char *dir)
{
    char buf[8];
    char dname[64];
    int n, data, ctl, hand;

    // open a new filter; get ctl fd
    data = hand = -1;
    // /net/tls uses decimal file descriptors to name channels, hence a
    // user-level file server can't stand in for #a; may as well hard-code it.
    ctl = open("#a/tls/clone", ORDWR);
    if(ctl < 0)
        goto error;
    n = read(ctl, buf, sizeof(buf)-1);
    if(n < 0)
        goto error;
    buf[n] = 0;
    if(dir)
        sprint(dir, "#a/tls/%s", buf);

    // get application fd
    sprint(dname, "#a/tls/%s/data", buf);
    data = open(dname, ORDWR);
    if(data < 0)
        goto error;

    // get handshake fd
    sprint(dname, "#a/tls/%s/hand", buf);
    hand = open(dname, ORDWR);
    if(hand < 0)
        goto error;

    // speak a minimal handshake
    if(fprint(ctl, "fd %d 0x301", fd) < 0 ||
       fprint(ctl, "version 0x301") < 0 ||
       fprint(ctl, "secret %s %s %d %s", hashalg, encalg, isclient, secret) < 0 ||
       fprint(ctl, "changecipher") < 0 ||
       finished(hand, isclient) < 0 ||
       fprint(ctl, "opened") < 0){
        close(hand);
        hand = -1;
        goto error;
    }
    close(ctl);
    close(hand);
    close(fd);
    return data;

error:
    if(data>=0)
        close(data);
    if(ctl>=0)
        close(ctl);
    if(hand>=0)
        close(hand);
    return -1;
}
@



\chapter{Advanced Topics}

% Seen advanced topics before, for memory pool, thread and channels
% in their respective chapters.

\section{Arbitrary precision arithmetics}

<<type mpdigit>>=
typedef unsigned int    mpdigit;    /* for /sys/include/mp.h */
@

\section{IO chunks}

<<type IOchunk>>=
struct IOchunk {
 void	*addr;
 ulong	len;
};
@

\section{Extra functions}

\subsection{Strings}



\chapter{Conclusion}





\appendix

\chapter{Extra Code}

\ifallcode
#include "Libcore_extra.nw"
#include "Libcore_big.nw"
#include "Libcore_arm.nw"
\fi

%\chapter{Changelog}
%\label{sec:changelog}

\chapter*{Glossary}
\label{sec:glossary}
\addcontentsline{toc}{chapter}{Glossary}

\begin{verbatim}
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{chapter}{Index}

%\chapter{References} 
\addcontentsline{toc}{chapter}{References}

\bibliography{../docs/latex/Principia}
\bibliographystyle{alpha}


%******************************************************************************
% Postlude
%******************************************************************************

\end{document}

