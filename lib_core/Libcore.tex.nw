\documentclass[twocolumn]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse
% see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things:

%thx to codemap/codegraph/scheck:
% - TODO use cg to reduce backward deps, introduce globals.c, utils.c,
%   (harder to understand non layered code)
% - TODO use scheck to remove deadcode, dead prototypes, useless export
%   or mv as forward decl
%   (harder to understand big interface files)
% - TODO use cg to reduce number of globals by moving them closer to the
%   relevant file (or even function), better cluster the code
%   (harder to understand non functional code using lots of globals)

%thx to this manual, better understand XXX?:

%history LP-ization:
% - skeleton, mostly copy paste of Template.tex.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * TODO ctor/dtor, dumper
%    * TODO [[xxx]] other fields, [[xxx]] extra fields
% - TODO read Extra section, identify concepts, first TOC
% - TODO distribute parts of the Extra section in the main file
% - TODO understand main(), LP split main, improve TOC
% - TODO understand main functions, LP split, cluster, improve TOC
% - TODO LP split the structures, use datalog for flow to field info
% - TODO nullify, boolify, errorify, enumify,  typeify,    scheckify, plan9ify
% - TODO aspecify advanced features! remove useless features
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\iffinal
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\fi
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
%\usepackage{cleveref} %\cref
%\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}
 %\usepackage[margin=0.5in]{geometry}
 %  but eat the bottom when very low
 %\usepackage{fullpage} is deprecated 
 % => do the more manual below:
 \addtolength{\oddsidemargin}{-.850in}
 \addtolength{\evensidemargin}{-.850in}
 \addtolength{\textwidth}{1.70in}
 \addtolength{\topmargin}{-.850in}
 \addtolength{\textheight}{1.70in}
%\usepackage{minitoc}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% used for forward decl, pragmas, func decl, extern decl, stats, #ifdef,
% debugging macros

%\setcounter{tocdepth}{1}

%******************************************************************************
% Title
%******************************************************************************

\begin{document}

\title{
{\Huge 
Principia Softwarica: Plan9 Core Libraries
}\\
{version 0.1}
}
% x86 edition? for very few code so maybe not that needed to put
% in title

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}
}

\maketitle 
\onecolumn
\hrule
\begin{quote}
    Copyright \copyright{} 2014 Yoann Padioleau \\
    Permission is granted to copy, distribute and/or modify this document,
    except all the source code it contains, under the terms of the GNU Free
    Documentation License, Version 1.3.
\end{quote}
\hrule

%CONFIG: \dominitoc

\iffinal
\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\twocolumn
\tableofcontents
\endgroup
\else
\tableofcontents
\fi

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

\section{Motivations}

The goal of this book is to present in full details the source code of
a few core libraries.
Why? Because I think it makes you a better programmer if
you fully understand how things work under the hood.

% gonna present core libs of plan9, its libc of course, 
% but also its thread libraries,
% regexp, memory managment, unicode, etc.
% most of the generally useful and generic building blocks for regular
% applications!

Here are other candidates that were considered but ultimately discarded:
\begin{itemize}
\item glibc
\item dietlibc
\item microlibc
\end{itemize}

% kencc/libmach/ is using netlib/fdlibm


\section{Getting started}

\section{Requirements}

% see intro(2), overview of many libs
% (just like intro(1) is overview of utilities)

\section{About this document}
#include "../docs/latex/About.tex.nw"

\section{Copyright}

Most of this document is actually source code from Plan9, so
those parts are copyright by Lucent Technologies Inc.
The prose is mine and is licensed under the GNU Free Documentation
License.

\section{Acknowledgments}


\chapter{Overview}

\section{Code organization}


\section{Architecture overview}

% note that libc should be thread-safe, malloc use locks!

% take common.ml structure for the TOC of this document?

%###############################################################################

\chapter{Channels and Cooperative Threads}
% should be a last chapter, but put here for now

\section{Overview}

% thread OS vs thread lib OS! already have "threads" rfork with shared memory!
% see http://swtch.com/~rsc/thread/
% plan9 libthread model is based on Alef. Procs in terminology
% below are actually shared
% memory processes, and threads cooperatively scheduled coroutines.
% different than what most people agrees about threads/

% Why need that? why system threads not enough? not convenient enough?
% green threads vs system threads, a classic.
% Having cooperative threads simplify lots of things, no race, less
% need for locks! Other reasons? (xleroy did the same)

% alternatives? posix threads? xleroy thread lib? new thread linux lib?
% other forms of concurrency? erlang model? see 7 concurrency in 7 weeks?

% see thread(2), definitive reference. maybe see alef article
% for design discussions. See acme and rio articles/slides for
% examples of use and discussions too.
% see ioproc(2), and lock(2)
% see rendezvous(2)

\subsection{Code organization}

%include/thread.h: public API
%threadimpl.h: private DS


%ref.c: atomic counter (could be in libc.h)
%xincarm.c
%xincport.h

%globals.c: globals
%debug.c: debugging support (threadebug(), threadassert())

%lib.c: threadmalloc wrapper, threadsysfatal()
%386.c: ??

%id.c
%exit.c
%note.c
%rendez.c: !!
%sched.c: the thread scheduler
%create.c: create/free process/threads
%channel.c:
%kill.c

%chanprint.c

%ioproc.c: IO proc creation and handler (xioproc)
%iocall.c: the io proc helper bridge for all the syscalls below

%ioxxx.c: 
% (ioopen.c, %ioclose.c, %ioread.c, %iowrite.c, %ioreadn.c, %iosleep.c)

%dial.c: thread friendly version of network dial
%iodial.c

%exec.c:

%main.c: !!!

\subsection{Architecture overview}

% _xxx = private

\section{A toy example}

% lib_thread/tests/!! example.c! include early

\section{Core data structures}

\subsection{Concurrency buiding blocks}

<<struct Ref>>=
struct Ref {
    long	ref;
};
@

<<function incref>>=
void
incref(Ref *r)
{
    ainc(&r->ref);
}
@

<<function decref>>=
long
decref(Ref *r)
{
    return adec(&r->ref);
}
@


<<global xincport_lock>>=
static Lock xincport_lock;
@

<<function _xinc>>=
void
_xinc(long *p)
{

    lock(&xincport_lock);
    (*p)++;
    unlock(&xincport_lock);
}
@
% who calls _xinc?? ainc?

<<function _xdec>>=
long
_xdec(long *p)
{
    long r;

    lock(&xincport_lock);
    r = --(*p);
    unlock(&xincport_lock);
    return r;
}
@




% see Lock, QLock, Rendez!! 
% see also lock(); unlock() functions in libc.h

% can produce producer/consumer synchronization queue
% with lock and rendezvous (kind of condition variables)

\subsection{[[Channel]]}
% public API!

%A Channel is a buffered or unbuffered queue for fixed size messages
% Procs and threads send messages into the channel and recv messages 
% from the channel

<<struct Channel>>=
/*
 * Channel structure.  s is the size of the buffer.  For unbuffered channels
 * s is zero.  v is an array of s values.  If s is zero, v is unused.
 * f and n represent the state of the queue pointed to by v.
 */
struct Channel {
    int	s;		/* Size of the channel (may be zero) */

    uint	f;		/* Extraction point (insertion pt: (f+n) % s) */
    uint	n;		/* Number of values in the channel */
    int	e;		/* Element size */
    int	freed;		/* Set when channel is being deleted */

    volatile Alt **qentry;	/* Receivers/senders waiting (malloc) */
    volatile int nentry;	/* # of entries malloc-ed */
    volatile int closed;	/* channel is closed */

    // must be at the end of the struct! 
    uchar	v[1];		/* Array of s values in the channel */
};
@
% no Lock?
% volatile?

<<function chancreate>>=
Channel*
chancreate(int elemsize, int elemcnt)
{
    Channel *c;

    if(elemcnt < 0 || elemsize <= 0)
        return nil;
    c = _threadmalloc(sizeof(Channel)+elemsize*elemcnt, 1);
    c->e = elemsize;
    c->s = elemcnt;
    _threaddebug(DBGCHAN, "chancreate %p", c);
    return c;
}
@

% have to be called by user? could do that in chancreate no?
<<function chaninit>>=
int
chaninit(Channel *c, int elemsize, int elemcnt)
{
    if(elemcnt < 0 || elemsize <= 0 || c == nil)
        return -1;
    c->f = 0;
    c->n = 0;
    c->closed = 0;
    c->freed = 0;
    c->e = elemsize;
    c->s = elemcnt;
    _threaddebug(DBGCHAN, "chaninit %p", c);
    return 1;
}
@


<<function chanfree>>=
void
chanfree(Channel *c)
{
    lock(&chanlock);
    _chanfree(c);
    unlock(&chanlock);
}
@


<<function _chanfree>>=
static void
_chanfree(Channel *c)
{
    int i, inuse;

    if(c->closed == 1)			/* chanclose is ongoing */
        inuse = 1;
    else{
        inuse = 0;
        for(i = 0; i < c->nentry; i++)	/* alt ongoing */
            if(c->qentry[i])
                inuse = 1;
    }
    if(inuse)
        c->freed = 1;
    else{
        if(c->qentry)
            free(c->qentry);
        free(c);
    }
}
@




<<enum _anon_ (lib_core/libthread/channel.c)>>=
/* Value to indicate the channel is closed */
enum {
    CHANCLOSD = 0xc105ed,
};
@
<<constant Closed>>=
#define Closed	((void*)CHANCLOSD)
@

<<global chanlock>>=
static Lock chanlock;		/* central channel access lock */
@



\subsection{[[Proc]] and [[Pqueue]]}

% cooperative scheduler building blocks = coroutines = setjmp()!
% (actually the kernel does the same)

<<struct Proc>>=
struct Proc
{
    int		pid;			/* process id */

    jmp_buf	sched;			/* for context switches */

    Thread	*thread;		/* running thread */




    int		splhi;			/* delay notes */

    int		needexec;
    Execargs	exec;			/* exec argument */
    Proc	*newproc;		/* fork argument */
    char	exitstr[ERRMAX];	/* exit status */

    int		rforkflag;

    Tqueue	threads;		/* All threads of this proc */
    int		nthreads;

    Tqueue	ready;			/* Runnable threads */
    Lock	readylock;

    char	printbuf[Printsize];
    int		blocked;		/* In a rendezvous */
    int		pending;		/* delayed note pending */
    int		nonotes;		/* delay notes */
    uint	nextID;			/* ID of most recently created thread */


    void	*arg;			/* passed between shared and unshared stk */
    char	str[ERRMAX];		/* used by threadexits to avoid malloc */

    void*	wdata;			/* Lib(worker) per-proc data pointer */
    void*	udata;			/* User per-proc data pointer */
    char	threadint;		/* tag for threadexitsall() */

    // Extra
    Proc	*next;			/* linked list of Procs */

    Lock	lock;
};
@

% jmp_buf is in u.h and is just long[2] (sp, pc) for x86

<<constant Printsize>>=
Printsize = 2048,
@


% shared memory, but need also per process private memory.
% how? stack? each process has its own stack normally.


<<global procp>>=
// used to be in main.c
static Proc **procp;
@
% set in threadsysinit(), privalloc()

<<function _threadgetproc>>=
Proc*
_threadgetproc(void)
{
    return *procp;
}
@

<<function _threadsetproc>>=
void
_threadsetproc(Proc *p)
{
    *procp = p;
}
@





% all processes, all threads?
<<global _threadpq>>=
// used to be in create.c
Pqueue _threadpq;
@
% it's not a pointer! so it should be set to nil by default

<<struct Pqueue>>=
struct Pqueue {		/* Proc queue */
    Proc		*head;
    Proc		**tail;

    // Extra
    Lock		lock;
};
@



<<function _newproc>>=
/*
 * Create and initialize a new Proc structure with a single Thread
 * running inside it.  Add the Proc to the global process list.
 */
Proc*
_newproc(void (*f)(void *arg), void *arg, uint stacksize, char *name, int grp, int rforkflag)
{
    Proc *p;

    p = _threadmalloc(sizeof *p, 1);
    p->pid = -1;
    p->rforkflag = rforkflag;
    newthread(p, f, arg, stacksize, name, grp);

    lock(&_threadpq.lock);
    if(_threadpq.head == nil)
        _threadpq.head = p;
    else
        *_threadpq.tail = p;
    _threadpq.tail = &p->next;
    unlock(&_threadpq.lock);

    return p;
}
@


<<function procrfork>>=
int
procrfork(void (*f)(void *), void *arg, uint stacksize, int rforkflag)
{
    Proc *p;
    int id;

    p = _threadgetproc();
    assert(p->newproc == nil);
    p->newproc = _newproc(f, arg, stacksize, nil, p->thread->grp, rforkflag);
    id = p->newproc->threads.head->id;
    _sched();
    return id;
}
@

<<function proccreate>>=
int
proccreate(void (*f)(void*), void *arg, uint stacksize)
{
    return procrfork(f, arg, stacksize, 0);
}
@


<<function _freeproc>>=
void
_freeproc(Proc *p)
{
    Thread *t, *nextt;

    for(t = p->threads.head; t; t = nextt){
        if(t->cmdname)
            free(t->cmdname);
        assert(t->stk != nil);
        free(t->stk);
        nextt = t->nextt;
        free(t);
    }
    free(p);
}
@



\subsection{[[Thread]] and [[Tqueue]]}
% private DS, threadimpl.h


<<struct Thread>>=
struct Thread
{
    int		id;		/* thread id */
    char	*cmdname;	/* ptr to name of thread */

    jmp_buf	sched;		/* for context switches */

    Proc	*proc;		/* proc of this thread */

    uint	stksize;	/* stack size */
    uchar	*stk;		/* top of stack (lowest address of stack) */

    State	state;		/* run state */
    State	nextstate;	/* next run state */

    Chanstate	chan;		/* which channel operation is current */
    Alt		*alt;		/* pointer to current alt structure (debugging) */



    int 	grp;		/* thread group */
    int		moribund;	/* thread needs to die */

    int		ret;		/* return value for Exec, Fork */


    int		inrendez;
    Thread	*rendhash;	/* Trgrp linked list */
    void*	rendtag;	/* rendezvous tag */
    void*	rendval;	/* rendezvous value */
    int		rendbreak;	/* rendezvous has been taken */


    void*	udata[NPRIV];	/* User per-thread data pointer */

    // Extra
    Lock	lock;		/* protects thread data structure */

    Thread	*next;		/* next on ready queue */

    Thread	*nextt;		/* next on list of threads in this proc*/


};
@

% advanced topic?
<<constant NPRIV>>=
NPRIV = 8,
@






<<function threadid>>=
int
threadid(void)
{
    return _threadgetproc()->thread->id;
}
@

% newthread() -> <>
<<function nextID>>=
static int
nextID(void)
{
    static Lock l;
    static int id;
    int i;

    lock(&l);
    i = ++id;
    unlock(&l);
    return i;
}
@

% ctor
<<function newthread>>=
/*
 * Create and initialize a new Thread structure attached to a given proc.
 */
static int
newthread(Proc *p, void (*f)(void *arg), void *arg, uint stacksize, char *name, int grp)
{
    int id;
    Thread *t;

    if(stacksize < 32)
        sysfatal("bad stacksize %d", stacksize);
    t = _threadmalloc(sizeof(Thread), 1);

    t->stksize = stacksize;
    t->stk = _threadmalloc(stacksize, 0);
    memset(t->stk, 0xFE, stacksize);
    _threadinitstack(t, f, arg);

    t->grp = grp;
    if(name)
        t->cmdname = strdup(name);
    t->id = nextID();
    id = t->id;
    t->next = (Thread*)~0;
    t->proc = p;
    _threaddebug(DBGSCHED, "create thread %d.%d name %s", p->pid, t->id, name);

    lock(&p->lock);
    p->nthreads++;
    if(p->threads.head == nil)
        p->threads.head = t;
    else
        *p->threads.tail = t;
    p->threads.tail = &t->nextt;

    t->nextt = nil;
    t->state = Ready;
    _threadready(t);
    unlock(&p->lock);

    return id;
}
@

<<function threadcreate>>=
/* 
 * Create a new thread and schedule it to run.
 * The thread grp is inherited from the currently running thread.
 */
int
threadcreate(void (*f)(void *arg), void *arg, uint stacksize)
{
    return newthread(_threadgetproc(), f, arg, stacksize, nil, threadgetgrp());
}
@


<<function _freethread>>=
void
_freethread(Thread *t)
{
    Proc *p;
    Thread **l;

    p = t->proc;
    lock(&p->lock);
    for(l=&p->threads.head; *l; l=&(*l)->nextt){
        if(*l == t){
            *l = t->nextt;
            if(*l == nil)
                p->threads.tail = l;
            break;
        }
    }
    unlock(&p->lock);
    if (t->cmdname)
        free(t->cmdname);
    assert(t->stk != nil);
    free(t->stk);
    free(t);
}
@




<<function threadpid>>=
int
threadpid(int id)
{
    int pid;
    Proc *p;
    Thread *t;

    if (id < 0)
        return -1;
    if (id == 0)
        return _threadgetproc()->pid;
    lock(&_threadpq.lock);
    for (p = _threadpq.head; p; p = p->next){
        lock(&p->lock);
        for (t = p->threads.head; t; t = t->nextt)
            if (t->id == id){
                pid = p->pid;
                unlock(&p->lock);
                unlock(&_threadpq.lock);
                return pid;
            }
        unlock(&p->lock);
    }
    unlock(&_threadpq.lock);
    return -1;
}
@



<<struct Tqueue>>=
struct Tqueue		/* Thread queue */
{
    Thread	*head;
    Thread	**tail;

    int		asleep;
};
@




<<enum state>>=
enum state
{
    Dead,
    Running,
    Ready,
    Rendezvous,
};
@
% hmm does not much psstate string array, normal??

<<enum chanstate>>=
enum chanstate
{
    Channone,
    Chansend,
    Chanrecv,
    Chanalt,
};
@


\subsection{[[Alt]]}

% "Plan9 has no select call"

<<enum chanop>>=
enum chanop {
    CHANEND,

    CHANSND,
    CHANRCV,
    CHANNOP,

    CHANNOBLK,
};
@

<<struct Alt>>=
struct Alt {
    Channel	*c;		/* channel */
    void	*v;		/* pointer to value */
    ChanOp	op;		/* operation */

    char	*err;		/* did the op fail? */
    /*
     * the next variables are used internally to alt
     * they need not be initialized
     */
    Channel	**tag;		/* pointer to rendez-vous tag */
    int	entryno;	/* entry number */
};
@

\subsection{[[Ioproc]]}

% private structure! #pragma incomplete in thread.h (and implemented in
% threadimpl.h)
<<struct Ioproc>>=
struct Ioproc
{
    int tid;

    Channel *c;
    Channel *creply;

    int inuse;

    long (*op)(va_list*);

    va_list arg;
    long ret;
    char err[ERRMAX];

    Ioproc *next;
};
@

<<function ioproc>>=
Ioproc*
ioproc(void)
{
    Ioproc *io;

    io = mallocz(sizeof(Ioproc), 1);
    if(io == nil)
        sysfatal("ioproc malloc: %r");
    io->c = chancreate(sizeof(void*), 0);
    io->creply = chancreate(sizeof(void*), 0);
    io->tid = proccreate(xioproc, io, STACK);
    return io;
}
@

\section{[[main()]]}

<<global mainp>>=
// ref<ref<Proc>
static Proc **mainp;
@
% address of ref of proc in stack

<<global _mainjmp>>=
static jmp_buf _mainjmp;
@

<<global mainstacksize>>=
int	mainstacksize;
@


<<function main>>=
void
main(int argc, char **argv)
{
    Mainarg *a;
    Proc *p;

    rfork(RFREND);
    mainp = &p;

    if(setjmp(_mainjmp))
        _schedinit(p);

    //_threaddebuglevel = (DBGSCHED|DBGCHAN|DBGREND)^~0;
    _systhreadinit();
    _qlockinit(_threadrendezvous);

    _sysfatal = _threadsysfatal;
    _dial     = _threaddial;
    __assert  = _threadassert;

    notify(_threadnote);

    if(mainstacksize == 0)
        mainstacksize = 8*1024;

    a = _threadmalloc(sizeof *a, 1);
    a->argc = argc;
    a->argv = argv;

    p = _newproc(mainlauncher, a, mainstacksize, "threadmain", 0, 0);
    _schedinit(p);

    abort();	/* not reached */
}
@


<<function _systhreadinit>>=
void
_systhreadinit(void)
{
    procp = privalloc();
}
@

<<struct Mainarg>>=
struct Mainarg
{
    int		argc;
    char	**argv;
};
@

<<function mainlauncher>>=
static void
mainlauncher(void *arg)
{
    Mainarg *a;

    a = arg;
    // user defined threadmain()!!
    threadmain(a->argc, a->argv);

    threadexits("threadmain");
}
@



\section{Threads scheduler}
% similar to Kernel Scheduling chapter

<<global _psstate>>=
static char *_psstate[] = {
    "Moribund",
    "Dead",
    "Exec",
    "Fork",
    "Running",
    "Ready",
    "Rendezvous",
};
@
% superset of enum state, normal?

<<function psstate>>=
static char*
psstate(int s)
{
    if(s < 0 || s >= nelem(_psstate))
        return "unknown";
    return _psstate[s];
}
@


\section{[[alt()]]}

\section{Send/Receive}
% actually they all rely on alt()

\section{IO processus}

\subsection{[[xiproc()]]}

\subsection{[[iocall()]]}

\subsection{IO wrappers}

\section{Thread-aware libc}

\subsection{Memory}

% actually malloc already shared-memory safe as it uses locks.
% but have a small malloc wrapper not doing that much more,
% just a bit more error safe:

<<global totalmalloc>>=
static long totalmalloc;
@

<<function _threadmalloc>>=
void*
_threadmalloc(long size, int z)
{
    void *m;

    m = malloc(size);
    if (m == nil)
        sysfatal("Malloc of size %ld failed: %r", size);
    setmalloctag(m, getcallerpc(&size));
    totalmalloc += size;
    if (size > 100000000) {
        fprint(2, "Malloc of size %ld, total %ld\n", size, totalmalloc);
        abort();
    }
    if (z)
        memset(m, 0, size);
    return m;
}
@


\subsection{Exec}

\subsection{Notes}

\section{Exit}
% need to terminate all of those things.
% I remember it was tricky in ocaml to get things right
% when have worker, when use MPI, etc.

\section{Error managment}

%"Thread library functions do not return on failure; if errors occur, the entire program is aborted."


% call abort() which enter broken state I think by causing a fault


<<function _threadsysfatal>>=
void
_threadsysfatal(char *fmt, va_list arg)
{
    char buf[1024];	/* size doesn't matter; we're about to exit */

    vseprint(buf, buf+sizeof(buf), fmt, arg);
    if(argv0)
        fprint(2, "%s: %s\n", argv0, buf);
    else
        fprint(2, "%s\n", buf);
    threadexitsall(buf);
}
@

<<function _threadassert>>=
void
_threadassert(char *s)
{
    char buf[256];
    int n;
    Proc *p;

    p = _threadgetproc();
    if(p && p->thread)
        n = sprint(buf, "%d.%d ", p->pid, p->thread->id);
    else
        n = 0;
    snprint(buf+n, sizeof(buf)-n, "%s: assertion failed\n", s);
    write(2, buf, strlen(buf));
    abort();
}
@


\section{Debugging}


<<global _threaddebuglevel>>=
// biset<enum<dbgxxx>>
int _threaddebuglevel;
@

% could use enum dbgxxx
<<constant DBGAPPL>>=
#define DBGAPPL	(1 << 0)
@

<<constant DBGSCHED>>=
#define DBGSCHED	(1 << 16)
@

<<constant DBGCHAN>>=
#define DBGCHAN	(1 << 17)
@

<<constant DBGREND>>=
#define DBGREND	(1 << 18)
@

<<constant DBGNOTE>>=
#define DBGNOTE	(1 << 20)
@
%/* #define DBGKILL	(1 << 19) */

<<constant DBGEXEC>>=
#define DBGEXEC	(1 << 21)
@



<<function _threaddebug>>=
void
_threaddebug(ulong flag, char *fmt, ...)
{
    char buf[128];
    va_list arg;
    Fmt f;
    Proc *p;

    if((_threaddebuglevel&flag) == 0)
        return;

    fmtfdinit(&f, 2, buf, sizeof buf);

    p = _threadgetproc();
    if(p==nil)
        fmtprint(&f, "noproc ");
    else if(p->thread)
        fmtprint(&f, "%d.%d ", p->pid, p->thread->id);
    else
        fmtprint(&f, "%d._ ", p->pid);

    va_start(arg, fmt);
    fmtvprint(&f, fmt, arg);
    va_end(arg);
    fmtprint(&f, "\n");
    fmtfdflush(&f);
}
@



\section{Advanced topics}

\subsection{Thread groups}

\subsection{Thread kills}

\subsection{Dialing}

\chapter{Core Data Structures}

% void

% basic types

% pointer, void*!

% string, see special chapter

% collection types (not really :( ) but
% can provide template on how they encode lists, hashs, queues,
% double linked lists, trees, etc. See kernel.tex.nw for instance,
% many example of collections.


\chapter{[[_main()]]}

\chapter{Kernel Bridge}

\chapter{Memory Area Operations}

\chapter{Memory Managment}
% sysbrk()

% http://jamesgolick.com/2013/5/15/memory-allocators-101.html
% http://jamesgolick.com/2013/5/19/how-tcmalloc-works.html

\chapter{Strings}

\section{Conversions}

\section{Formatted Output}
% Fmt

% printf

\section{Unicode}

%see utf.ps

\chapter{IO}
% sysopen(), sysclose(), sysread(), syswrite(), sysseek(), etc
% file, directory, namespace

% file descriptor

\chapter{Network}

\chapter{Concurrency}
% sysfork(), sysexit(), sysawait(), sysexec()
% want to run external command? need fork+exec! classic pattern.

% plan9 has shared memory processes. rfork(RFMEM)
% has then locking function to coordinate. qlock, lock, etc.
% has also a few syscalls like rendezvous!

% see also thread chapter, that build on top of this to
% provide more convenient abstractions (channels, alt(), cooperative
% threads with less needs for locking, etc)

% see lock(2), rendezvous(2)
% sleep/wakeup

\chapter{Error Managment}

% perror?

\chapter{Debugging Support}

\chapter{Profiling Support}

\chapter{Advanced Topics}

\chapter{Conclusion}

\appendix

\chapter{Extra Code}

\ifallcode
#include "Libcore_extra.tex.nw"
\fi

\chapter{Changelog}
\label{sec:changelog}

\chapter{Glossary}
\label{sec:glossary}

\begin{verbatim}
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{section}{Index}

%\chapter{References} 
\addcontentsline{toc}{section}{References}

\begin{thebibliography}{99}

\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming}, 
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb}, 
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison}, 
\url{http://padator.org/software/project-syncweb/readme.txt}

\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}

