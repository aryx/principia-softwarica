\section{Introduction}

% 'ed', for editor (they do like 2 letters acronyms), is an old editor
% originally written by Ken Thompson in the 1970's for Unix.
%% (part of the special "3 weeks" where he wrote editor, assembler, kernel?)

% It is a *line editor*, as opposed to *screen editor* like vi or emacs,
% or stream editor like sed.
% ed is very different from emacs, or vi (or sam or acme).
% edit just one file at a time.
% Most editors nowaday are screen editors, but still useful to know ed!
% especially good for scripting
%said-later: see mkenam in plan9 code.
% Also if need quick and dirty write a file with a few lines => ed!
% See also \book{Editor} for screen editor.

% s/re/g
% g/re/p comes from ed!
% 'wq', 'a', 'i', modes, lots of things in vi coming from ed
%later: g global re regexp p print

% Can already create file content with echo and shell redirection
% (>, >> for append); can do a lot, but still not as powerful as ed.

% For tutorial and motivations for the study of ed!
% see appendix 1 of "Unix programming environment" 
\cite{unix-pike}
% see also its man page for documentation.
% see also vol72a with 2 tutorials on ed by Brian Kernighan.
% Quite complex command ...

\n could cite "Formalizing text editors in Coq" 2020 :) but meh actually


\section{Motivations: [[mkenam]]}

% ex of powerful ed command used in principia/goken mkenam:
\begin{verbatim}
ed - ../5l/5.out.h <<'!'
v/^	A/d
1,$s/^	A/	"/
g/ .*$/s///
,s/,*$/",/
1i
char*	anames[] =
{
.
$a
};
.
w enam.c
Q
!
\end{verbatim}
%alt: could be simplified, see my simpler xix/tests/ed/mkenam.sh
% no need 'g/ .*$/s///',   I replaced some  ',s/.../' by clearer '1,$s/.../',
% the last 'Q' could be a 'q'

% by end of chapter you will understand this script :)

% show part of 5.out.h and part of enam.c so can understand goal
% FIGURE

% also how to do that with other tools? can do with sed? can do with vi/emacs?
% via a script that can run each time you modify 5.out.h and can be called
% from a mkfile (show mkfile part of 5c/)
% try this in vim/emacs? no need to learn lisp
% to program this "edit script", just need to know the
% key command (actually with emacs you could program macro but
% how to specify it in script with M-x and other special key combinations!)
% power of text and of script!

% '-' suppress the printing of character counts by e/r/w
%  remove verbose/interactive mode (default)

% Note that use <<'!' Here doc feature from shell
% but could store ed script in separate file

% Note that unicode-ready editor!
% (but complexify quite a lot the code unfortunately).


%\section{[[ed]] clones}

%clones:
% - go: https://github.com/thimc/ed and https://git.mills.io/prologic/ed
% - rust: https://github.com/sidju/add-ed
% - in OCaml? yes mine! see next appendix :)


\section{Core data structures}

% ed core DS is very different from other editors: no Line, Text, Buffer, ...
% no rope, gap buffer, or other fancy structure to represent set of lines.
% The content of the file edited is not even in memory!
% no list of lines! instead everything stored in temp file
% and in memory just have line offsets in temp file. 
% So 2 main DS are temp file and array of file offsets
% representing current state of buffer.
% FIGURE.

\subsection{The backing store: [[tfname]], [[tfile]], and [[tline]]}

<<globals ed.c>>=
char*   tfname; // temporary filename (/tmp/eXXXX)
@
% fundamental! many operations will append to this temporary
% file (and adjust zero line indices).
% tfile is kinda of ed's backing store.

<<globals ed.c>>=
fdt tfile   = -1;
@
% tfile for temporary file, again fundamental!

<<globals ed.c>>=
// current write file offset in tfile; 
int tline;
@

\subsection{The target file: [[savedfile]]}

%trans: at some point some lines from the temporary file will be copied
% in a specific file.
<<constants ed.c>>=
FNSIZE  = 128,      /* file name */
@
<<globals ed.c>>=
// for w, r, f
char    savedfile[FNSIZE];
@

%said-later: will see also file[FNSIZE] later

\subsection{The lines as file offsets: [[zero]]}
%$

% main data structure, an array of file offset in temp file for lines
<<globals ed.c>>=
ulong   nlall = 128;
// growing_array<int>, initial size = (nlall+ 2+margin)*sizeof(int)
// where the ints are file offsets in tfname corresponding to different lines
int*    zero; 
@

% see chatGPT explanation of full ed.nw.
% zero is an array of line offsets.
% The +5 is just for sentinel and safe margin; it should really be +2 at max.
% The lines are not stored in memory; ed just stores lines offsets
% in the temporary file corresponding to "the buffer" with possibly the
% content of the file being edited.

% so when you do 'ed foo.txt', it will actually read the content of foo.txt,
% append its content in temporary file, and zero will have indices as
% cursor in temporary file. if do 'r foo.txt' again to read again,
% it will append another copy of foo.txt in this temporary file and further
% modify zero.

% So when
% do operating like deleting or moving lines, actually you modify
% line offsets entries but not actually deleting lines.
% The temp file only grows. it contains lines, but when you
% use 'd' to delete line in the editor, it does not delete it
% in the temp file, only in zero. 
% temp file just grows during an ed session.

% It is a line editor! actually more line file offset editor :)
% line is string with ending \n! that's what ed manipulates, set of lines.



% note that line is 1-indexed, so zero[0] is unused
% (maybe why it's called zero?) and actually the code rely on zero
% as special value.

% lots of pointer idioms then

% was '... * sizeof(int*)' ?? should be sizeof(int) no?
% yes! BUG! even Ken Thompson wrote buggy C code :)

% called zero because zero itself points to zero[0] which
% is not line1, it's 0.

\subsection{Cursors: [[dot]] and [[dol]]}
%alt: Addresses? Line Pointers?

<<globals ed.c>>=
// ref<int> in zero array, current line pointer
int*    dot;
// ref<int> in zero array, last line pointer
int*    dol;
@
% those are called dot and dol, which seems cryptic, but
% they match the symbol used to describe those entities in the editor
% itself with $ (dollar) marking end of file and dot the current line.
% The user will enter '$' and '.' in commands.

%Classic ed addresses include:
%- 0 (before first line)
%- 1
%- .
%- $

% note that dol is zero when empty file (not even a single line)

%TODO: Figure with all those data structures?

\subsection{Line input and output buffers: [[line]] and [[linebuf]]}
%alt: move linebuf later? which is with Rune ... confusing

% line input from user? or line output buffer for user?
% used in putchr() so definitely used for output
<<globals ed.c>>=
char    line[70];
// ref<char> in line (mark end of line usually)
char*   linp    = line;
@
% why 70? 80 seems better to match number of columns in classic editors/terminals.

<<constants ed.c>>=
LBSIZE  = 4096,     /* max line size */
@
<<globals ed.c>>=
Rune    linebuf[LBSIZE];
@
% different from line[], here we have Rune[] not char[]


%TODO: Figure with all those data structures?

\subsection{Other globals: [[count]], [[col]], etc.}

<<globals ed.c>>=
long count;
@
% used by putd to display #chars read for instance

<<globals ed.c>>=
int col;
@
%??



\section{[[main()]]}
% main, init, quit


<<globals ed.c>>=
// console buffered input
Biobuf  bcons;
@


<<function [[main]](ed.c)>>=
void
main(int argc, char *argv[])
{
    char *p1, *p2;

    Binit(&bcons, STDIN, OREAD);
    notify(notifyf);

    ARGBEGIN {
    <<[[main()]](ed.c) flags processing cases>>
    } ARGEND

    USED(argc);
    <<[[main()]](ed.c) if [[-]] flag>>
    <<[[main()]](ed.c) if [[oflag]]>>
    else if(*argv) {
        p1 = *argv;
        p2 = savedfile;
        while(*p2++ = *p1++)
            if(p2 >= &savedfile[sizeof(savedfile)])
                p2--;
        globp = L"r";
    }
    zero = malloc((nlall+5)*sizeof(int*)); // BUG should be sizeof(int)
    tfname = mktemp(template);

    init();
    <<[[main()]](ed.c) before [[commands()]]>>
    commands();
    quit();
}
@
% init(), commands(), quit()

% globp = "r" = automatic command to do first = read file! important command
%  rarely called explicitely, but important nonetheless

% so when do 'ed foo.txt' -> savedfile = "foo.txt" and start "r" command
% interpretation, similar to 'ed, and then r foo.txt' as will see soon.

\subsection{[[ed -]] and [[vflag]]}

<<globals ed.c>>=
// verbose (a.k.a. interactive) mode
bool vflag   = true;
@
% vflag =~ verbose flag, to print char numbers in operations (e.g., in write)
%  when passing '-' means disable verbose and be quiet, like I did above
% in the motivations section for mkenam

<<[[main()]](ed.c) if [[-]] flag>>=
if(*argv && (strcmp(*argv, "-") == ORD__EQ)) {
    argv++;
    vflag = false;
}
@

\subsection{[[ed -o]] and [[oflag]]}

<<globals ed.c>>=
// output to standard output (instead of editing a file). Useful
// when ed is used as a filter
bool oflag;
@
% oflag =~ open flag? mean create if not exist?

<<[[main()]](ed.c) flags processing cases>>=
case 'o':
    oflag = true;
    vflag = false;
    break;
@

% remove verbose/interactive when using -o automatically
% since we plan to save the temporary file content to stdout! so
% definitely don't want to pass with stdout

<<[[main()]](ed.c) if [[oflag]]>>=
if(oflag) {
    p1 = "/fd/1";
    p2 = savedfile;
    while(*p2++ = *p1++)
        ;
    globp = L"a";
}
@
% globp = automatic command to do first. so here 'a'ppend mode by default.
% because will append to stdout

% saved file is fd/1 = stdout
% so 'w' for writing file will have for effect to write on /fd/1 so
% output on stdout

\subsection{[[mktemp()]]}

%mktemp(template)
<<globals ed.c>>=
// in Linux pid can be very long, so better to have at least 6 X (was 5 before)
// the mkstemp man page recommends 6 X
char template[] = "/tmp/eXXXXXX";
@

%ex: mktemp("/tmp/eXXXXXX") -> "/tmp/e000042" pid number
<<function [[mktemp]](ed.c)>>=
/// main -> <>
char*
mktemp(char *as)
{
    char *s;
    unsigned pid;
    int i;

    pid = getpid();
    s = as;
    while(*s++)
        ;
    s--;

    while(*--s == 'X') {
        *s = pid % 10 + '0';
        pid /= 10;
    }
    s++;

    i = 'a';
    while(access(as, 0) != -1) {
        if(i == 'z')
            return "/";
        *s = i++;
    }
    return as;
}
@

% so /tmp/e000042 then /tmp/ek0042
% so can have max 26 tmp files per process?

% note that we could delete as part of libc, and also
% we should delete because unsafe because race condition
% for code using it. See goken/include/libc.h note about mkstemp()
% for more info.

\subsection{[[init()]]}
%alt: and [[tfile]]? or just [[init()]]?

% continue init work done in main around zero and tfname

<<function [[init]](ed.c)>>=
/// main | commands('e') -> <>
void
init(void)
{
    <<[[init()]](ed.c) locals>>

    close(tfile);
    <<[[init()]](ed.c) initializing globals>>
    if((tfile = create(tfname, ORDWR, 0600)) < 0){
        error_1(T);
        exits(nil);
    }
    dot = dol = zero;
}
@
% use tfname set just before in main()
% dot = dol = zero! important too. zero malloced just before in main()

% close tfile because init can be called not only from main in which
% case it must closed the previous tmp file and create new one

<<[[init()]](ed.c) initializing globals>>=
tline = 2;
@
% sentinel ... so never line offset in zero have the 0 or 1 value, hmmm
% but means first 2 bytes of tfile are 0 (first seek will do that)
% also 2 because 1 is used to represent a mark! Too clever! Too smart
% for its own good.

<<globals ed.c>>=
char    T[] = "TMP";
@


\subsection{[[quit()]]}

<<globals ed.c>>=
bool fchange;
@
<<globals ed.c>>=
char    Q[] = "";
@
% I introduced this []? because rodata pb otherwise?
% but why need to modify the string?

<<function [[quit]](ed.c)>>=
/// main | commands('q') | ... -> <>
void
quit(void)
{
    if(vflag && fchange && dol!=zero) {
        fchange = false;
        error(Q);
    }
    remove(tfname);
    exits(nil);
}
@
% why error? because forgot to save and so tell it to the user?
% dol == zero when didn't do anything
% reset fchange to false so second quit will actually quit.


\section{Displaying and reading text}
% buffered output

\subsection{Displaying text}

% put string
% sp =? string pointer?
<<function [[putstr]](ed.c)>>=
/// commands | getfile | error_1 | ... -> <> 
void
putst(char *sp)
{
    Rune r;

    col = 0;
    for(;;) {
        sp += chartorune(&r, sp);
        if(r == 0)
            break;
        putchr(r);
    }
    putchr(L'\n');
}
@
% chartorune

% col? could reset it at the end instead? more logical
% after putchr the \n


% grrr int vs Rune. ac means?
<<function [[putchr]](ed.c)>>=
/// error | putst | ... -> <>
void
putchr(int ac)
{
    char *lp;
    int c;
    Rune rune;

    lp = linp;
    c = ac;
    <<[[putchr()]] if [[listf]]>>

    rune = c;
    lp += runetochar(lp, &rune);

    if(c == '\n' || lp >= &line[sizeof(line)-5]) {
        linp = line;
        write(oflag? STDERR: STDOUT, line, lp-line);
        return;
    }
    // else
    linp = lp;
}
@
% and this time runetochar, argh
% why int ac -> int c -> Rune r ... grrrr

% buffered output, display only when newline (or when > 65 and close
% to reach line[] limit) -5 because rune can be 4 chars

% oflag here because if -o then save on STDOUT edited data, but
% putchr is really used for display, not for editing

\subsection{Reading text}
%alt: Readinc characters

<<globals ed.c>>=
//option<char> (0 = None)
int lastc;
//option<char> (0 = None)
int peekc;
@
% classic lexer vars you need when not using lex

<<globals ed.c>>=
// optional programmed command (e.g., "r", "a")
//option<Rune> or list<Rune> when used from global() ?
Rune*   globp;
@
%alt: move to later and aspectize it below? but
% need to understand it early for the globp = "r" ?

% int vs char vs rune, grrr
<<function [[getchr]](ed.c)>>=
int
getchr(void)
{
    if(lastc = peekc) {
        peekc = 0;
        return lastc;
    }
    // else
    if(globp) {
        if((lastc=*globp++) != 0)
            return lastc;
        // else
        globp = nil;
        return EOF;
    }
    // else
    lastc = Bgetrune(&bcons);
    return lastc;
}
@
% EOF once finished globp?

%alt: move linebuf[] here as it's first time used?

% called when can enter text until '.\n'

% get line from tty (terminal). small wrapper over the raw gety
<<function [[gettty]](ed.c)>>=
/// main -> commands('a') -> add -> <>
int
gettty(void)
{
    int rc;

    rc = gety();
    if(rc)
        return rc;
    // else
    if(linebuf[0] == '.' && linebuf[1] == '\0')
        return EOF;
    return 0; // OK_0 ?
}
@

% special ".\n" here to finish the text entry.
% OK_0 means you can read more lines
% positive means error

% gety and gettty, will modify linebuf for the caller
<<function [[gety]](ed.c)>>=
/// gettty -> <>
int
gety(void)
{
    int c;
    Rune *p = linebuf;
    <<[[gety()]] other locals>>
    for(;;) {
        c = getchr();
        if(c == '\n') {
            *p = 0;
            return 0;
        }
        // else
        if(c == EOF) {
            <<[[<<get()]] if [[gf]]>>
            return c;
        }
        // else
        if(c == 0)
            continue;
        // else
        *p++ = c;
        if(p >= &linebuf[LBSIZE-sizeof(Rune)])
            error(Q);
    }
}
@
% sometimes need to under a line, or multiple for certain commands,
% like 'a' or 'i'

% How return line read to caller? Via global linebuf? but how end of line?
% via 0 marker rune in it?

% globp?? aspectize and move later?
<<[[gety()]] other locals>>=
Rune *gf = globp;
@

<<[[<<get()]] if [[gf]]>>=
if(gf)
    peekc = c;
@

\section{[[commands()]] interpreter loop}

%trans: ok, finally commands!

<<globals ed.c>>=
// ref<int>
int*    addr1;
// ref<int>
int*    addr2;
@
% optional line numbers for start/end of command 1,3p
% but let's ignore for now and see basis commands like p, a, etc.
% note that some commands like 'r' (and setwide) will set those too,
% not just interactive.

<<function [[commands]](ed.c)>>=
void
commands(void)
{
    int c;
    <<[[commands()]] other locals>>

    for(;;) {
        <<[[commands()]] in for loop, if [[pflag]]>>
        <<[[commands()]] read [[addr1]] and [[c]] via [[getchr]]>>
        switch(c) {
        <<[[commands()]] switch [[c]] cases (ed.c)>>
        }
        error(Q);
    }
}
@
% error(Q) show later, but essentially just jump to before commands() ?
% but why we need error? for(;;) not enough? because the commands
% are using 'continue' so the error is the default when not continue
% (but bad I think)

% int c, but char really.

% will see read [[addr1]] and more important [[c]] later, but
% essentially getchr() call

<<[[commands()]] switch [[c]] cases (ed.c)>>=
case EOF:
    return;
@
% return so will leave commands() leading to the execution of quit()
% in main()


\section{[[r]]eading a file: [[r]]}

% quite tricky, quite long, lots of subsections here.

<<globals ed.c>>=
char    file[FNSIZE];
@
% seen savedfile[] before, initialized when running ed foo.txt
% but here it's not really a global; it's something returned really
% by filename() and then used in getfile()

<<globals ed.c>>=
fdt io;
Biobuf  iobuf;
@

% globp = "r" = automatic command to do first = read file! important command
%  rarely called explicitely, but important nonetheless

% can also call 'ed', then 'r env.sh'
% in which case add (append) content of env.sh to current "buffer"

<<[[commands()]] switch [[c]] cases (ed.c)>>=
case 'r':
    // will set file[]
    filename(c);
caseread:
    if((io=open(file, OREAD)) < 0) {
        lastc = '\n';
        error(file);
    }
    <<[[commands()]] in [[r]] case if append only file>>
    Binit(&iobuf, io, OREAD);
    setwide();
    squeeze(0);
    c = (zero != dol);
    // getfile() will use iobuf
    append(getfile, addr2);
    exfile(OREAD); // will close io

    fchange = c;
    continue;
@
% setwide() set addr1/addr2 to full start/end so operation on whole file
% squeeze(0) ??
% append(getfile, addr2) ??
% exfile() finalize access to the file, will close io, "exit file"

% fchange = c ?
% ugly: abuse c, instead of using bool. and why not set fchange
% just after setting 'c' ? because reading a file actually does
% not trigger fchange = true; in fact fchange = false when read first file.
% but if read a file after having inserted a few things in the buffer, then
% still marked as changed? (but in that case means fchange was already
% at false so why changing it again to false?)

\subsection{Reading a [[filename()]]}

% 'int comm' but really char actually, grrrr

% will modify file[FNSIZE], that can then be further used
% in commands('r')

<<function [[filename]](ed.c)>>=
/// main -> commands('r') -> <>
void
filename(int comm)
{
    char *p1, *p2;
    Rune rune;
    int c;

    count = 0;
    c = getchr();
    <<[[filename()]] if [[c]] is newline or EOF>>
    // else
    <<[[filename()]] read a space and skip extra spaces>>
    p1 = file;
    do {
        if(p1 >= &file[sizeof(file)-6] || c == ' ' || c == EOF)
            error(Q);
        rune = c;
        p1 += runetochar(p1, &rune);
    } while((c=getchr()) != '\n');
    *p1 = '\0';
    
    <<[[filename()]] set [[savedfile]] depending on commands>>
}
@

<<[[filename()]] read a space and skip extra spaces>>=
if(c != ' ')
    error(Q);
while((c=getchr()) == ' ')
    ;
if(c == '\n')
    error(Q);
@

% this happens when do 'ed foo.c' with globl="r"
% then the file to read is actually in savedfile set in main() from argv
<<[[filename()]] if [[c]] is newline or EOF>>=
if(c == '\n' || c == EOF) {
    p1 = savedfile;
    if(*p1 == '\0' && comm != 'f')
        error(Q);
    p2 = file;
    while(*p2++ = *p1++)
        ;
    return;
}
@

<<[[filename()]] set [[savedfile]] depending on commands>>=
if(savedfile[0] == '\0' || comm == 'e' || comm == 'f') {
    p1 = savedfile;
    p2 = file;
    while(*p1++ = *p2++)
        ;
}
@

\subsection{[[setwide()]] and [[squeeze()]]}

<<function [[setwide]](ed.c)>>=
/// main -> commands('r') -> <>
void
setwide(void)
{
    if(!given) {
        addr1 = zero + (dol>zero);
        addr2 = dol;
    }
}
@
% given = whether the user explicitly typed an address or not.

% setwide mean set addr1/addr2 to start/end of the fil
% so that commands operate on the whole file (wide)

% + (dol>zero) means zero + 1  when non empty file, so line 1.

<<function [[squeeze]](ed.c)>>=
/// main -> commands('r') -> <>
void
squeeze(int i)
{
    if(addr1 < zero+i || addr2 > dol || addr1 > addr2)
        error(Q);
}
@
% called with squeeze(0) and squeeze(1)
% squeeze(1) when want at least one line in the buffer, otherwise
% commands like 'p' will fail that assumes at least one line


\subsection{[[append()]] and [[getfile()]]}

% append(getfile, addr2)
% and addr2 set to dol

% f can be getfile but also gettty as we will see later.
% this will add the content of the file after address a

<<function [[append]](ed.c)>>=
/// main -> commands('r') -> <>
int
append(int (*f)(void), int *a)
{
    //ref<int> in zero[]
    int *a1, *a2, *rdot;
    int nline = 0;
    // file offset in tfile for temporary line just added by putline()
    int tl;

    dot = a;
    // f() (e.g., getfile()) will modify linebuf
    while((*f)() == 0) {
        <<[[append()]] grow [[zero]] if [[zero]] too small>>
        // putline() will use linebuf
        tl = putline();
        nline++;

        // set zero[] indices
        a1 = ++dol;
        a2 = a1+1;
        rdot = ++dot;
        // shift existing line references up by one
        while(a1 > rdot)
            *--a2 = *--a1;
        // insert the new line reference in zero
        *rdot = tl;
    }
    return nline;
}
@

<<[[append()]] grow [[zero]] if [[zero]] too small>>=
if((dol-zero) >= nlall) {

    nlall += 512;
    a1 = realloc(zero, (nlall+5)*sizeof(int*)); // BUG: sizeof(int)
    if(a1 == nil) {
        error("MEM?");
        rescue();
    }
    tl = a1 - zero; /* relocate pointers */

    zero += tl;
    addr1 += tl;
    addr2 += tl;
    dol += tl;
    dot += tl;
}
@
% so append() is the only func growing zero?

%alt: \subsection{[[getfile()]]}

%    append(getfile, addr2);

% read a line from iobuf and set linebuf
<<function [[getfile]](ed.c)>>=
/// main -> commands(c = 'r') -> append(<>, ...) -> <>
int
getfile(void)
{
    int c;
    Rune *lp;

    lp = linebuf;
    do {
        c = Bgetrune(&iobuf);
        <<[[getfile()]] if [[c]] negative, possibly return [[EOF]]>>
        // else
        <<[[getfile()]] if overflow [[linebuf]]>>
        // else
        *lp++ = c;
        count++;
    } while(c != '\n');
    lp[-1] = 0;
    return 0; // OK_0
}
@

<<[[getfile()]] if [[c]] negative, possibly return [[EOF]]>>=
if(c < 0) {
    if(lp > linebuf) {
        putst("'\\n' appended");
        c = '\n';
    } else
        return EOF;
}
@
% bad file with missing \n, grrr so ed adds it :)

<<[[getfile()]] if overflow [[linebuf]]>>=
if(lp >= &linebuf[LBSIZE]) {
    lastc = '\n';
    error(Q);
}
@


\subsection{[[putline()]] (simplified)}

% put first simpler version without blocks? the one from chatGPT?

%NOT IN ed.c
<<[[putline()]] simplified>>=
int
putline(void)
{
    int n;
    long tl;

    tl = tline;                 // current temp-file write offset
    n = strlen(linebuf) + 1;    // include terminating '\0'

    if(tline + n >= ENDCORE)
        error("temp file overflow");

    seek(tfile, tline, 0);
    write(tfile, linebuf, n);

    tline += n;
    return tl;
}
@



\subsection{[[exfile()]]}

% "exit" file
% om = open mode

<<function [[exfile]](ed.c)>>=
/// main -> commands('r') -> <>
void
exfile(int om)
{

    if(om == OWRITE)
        if(Bflush(&iobuf) < 0)
            error(Q);
    close(io);
    io = -1;
    if(vflag) {
        putd();
        putchr(L'\n');
    }
}
@

<<function [[putd]](ex.c)>>=
void
putd(void)
{
    int r;

    r = count%10;
    count /= 10;
    if(count)
        putd();
    putchr(r + L'0');
}
@

%putd = put dots = print info derived from dot
% = current line number

% but actually putd() really just print the count global, which
% can be different things.



\section{[[w]]riting a file: [[w]]}


<<globals ed.c>>=
// write append
bool wrapp;
@

<<[[commands()]] switch [[c]] cases (ed.c)>>=
case 'W':
    wrapp = true;
    // Fallthrough
case 'w':
    setwide();
    squeeze(dol>zero);

    <<[[commands()]] when [['w']] check for [['q']] part1>>
    filename(c);

    if(!wrapp ||
      ((io = open(file, OWRITE)) == -1) ||
      ((seek(io, 0L, SEEK__END)) == -1))

        if((io = create(file, OWRITE, 0666)) < 0)
            error(file);

    Binit(&iobuf, io, OWRITE);
    wrapp = false;
    if(dol > zero)
        putfile();

    exfile(OWRITE);

    if(addr1<=zero+1 && addr2==dol)
        fchange = false;
    <<[[commands()]] when [['w']] check for [['q']] part2>>
    continue;
@



\subsection{[[putfile()]]}

% dual of getfile, write in iobuf, but all the lines, not just one
% like in getfile().
% Key to understand tfile! very simple code actually once understand
%  what getline() is doing
<<function [[putfile]](ed.c)>>=
void
putfile(void)
{
    int *a1;
    Rune *lp;
    long c;

    a1 = addr1;
    do {
        lp = getline(*a1++);
        for(;;) {
            count++;
            c = *lp++;
            if(c == 0) {
                if(Bputrune(&iobuf, '\n') < 0)
                    error(Q);
                break;
            }
            if(Bputrune(&iobuf, c) < 0)
                error(Q);
        }
    } while(a1 <= addr2);
    if(Bflush(&iobuf) < 0)
        error(Q);
}
@



\subsection{[[getline()]] (simplified)}

% again, simpler version (thx chatGPT again):
%

%NOT in ed.c
<<[[getline()]] simplified>>=
char *
getline(int tl)
{
    int n;

    // seek to the line's offset in the temp file
    seek(tfile, tl, 0);

    // read bytes up to the next NUL
    n = 0;
    while (read(tfile, &linebuf[n], 1) == 1 && linebuf[n] != '\0')
        n++;

    linebuf[n] = '\0';
    return linebuf;
}
@


\subsection{Write and quit: [[wq]]}

<<[[commands()]] other locals>>=
int temp;
@
<<[[commands()]] when [['w']] check for [['q']] part1>>=
temp = getchr();
if(temp != 'q' && temp != 'Q') {
    peekc = temp;
    temp = 0;
}
@
<<[[commands()]] when [['w']] check for [['q']] part2>>=
if(temp == 'Q')
    fchange = false;
if(temp)
    quit();
@






\section{Main commands}

%toc:
% classic tutorial on 'ed' is to use commands 'a', 'w', and 'q'
% so we will do that
% update: first 'p' which helps to understand

\subsection{[[p]]rinting lines: [[p]]}

% printing 3p   1,$p
% maybe can show address() powerful args for [[p]]

% see also g/re/p later

<<[[commands()]] switch [[c]] cases (ed.c)>>=
<<[[commands]] before [['p']] case>>
case 'p':
case 'P':
    newline();
    printcom();
    continue;
@
% 'continue' to get to next for(;;) because otherwise fallthrough error(Q)
% but could be simpler and just break out of switch

<<function [[newline]](ed.c)>>=
void
newline(void)
{
    int c;

    c = getchr();
    if(c == '\n' || c == EOF)
        return;
    <<[[newline()]] if special chars [[pln]]>>
    // else
    error(Q);
}
@


<<function [[printcom]](ed.c)>>=
void
printcom(void)
{
    int *a1;

    nonzero();
    a1 = addr1;
    do {
        <<[[printcom()]] if [[listn]]>>
        putshst(getline(*a1++));
    } while(a1 <= addr2);
    dot = addr2;
    <<[[printcom()]] reset flags>>
}
@
% but until now nothing really set addr1 and addr2, so it will be 0 0 ?
% I think no because commands() parsing will set addr1/addr2 to better
% defaults, often addr1 = addr2 = dot = dol, that is end of buffer

<<function [[nonzero]](ed.c)>>=
void
nonzero(void)
{
    squeeze(1);
}
@

% put sh st ?? similar to putst, but not char, Rune this time
<<function [[putshst]](ed.c)>>=
void
putshst(Rune *sp)
{
    col = 0;
    while(*sp)
        putchr(*sp++);
    putchr(L'\n');
}
@




% print also when no command specified? like 1\n ? default to print?
<<[[commands()]] switch [[c]] cases (ed.c)>>=
case '\n':
    if(a1==nil) {
        a1 = dot+1;
        addr2 = a1;
        addr1 = a1;
    }
    if(lastsep==';')
        addr1 = a1;

    printcom();
    continue;
@
% where this a1 comes from? set in commands() for advanced
% commands
%ocaml: I use [[not given]] instead of [[a1==nil]]

\subsection{printing remembered [[f]]ile: [[f]]}
% "remembered" either by [[r]] or [[w]]

<<[[commands()]] switch [[c]] cases (ed.c)>>=
case 'f':
    setnoaddr();
    filename(c);
    putst(savedfile);
    continue;
@

% can also change savedfile with 'f newfile.txt' I think.


\subsection{printing line number: [[=]]}

<<[[commands()]] switch [[c]] cases (ed.c)>>=
case '=':
    setwide();
    squeeze(0);
    newline();
    count = addr2 - zero;
    putd();
    putchr(L'\n');
    continue;
@


\subsection{[[a]]ppend and [[i]]nsert: [[a]], [[i]]}

<<[[commands()]] switch [[c]] cases (ed.c)>>=
case 'a':
    add(0);
    continue;
@

<<[[commands()]] switch [[c]] cases (ed.c)>>=
case 'i':
    add(-1);
    continue;
@
% ?? why -1 ? seems used like a bool so why not pass 1 simply?


<<function [[add]](ed.c)>>=
void
add(int i)
{
    if(i && (given || dol > zero)) {
        addr1--;
        addr2--;
    }
    squeeze(0);
    newline();
    append(gettty, addr2);
}
@

% f can be gettty(), a can be addr2


\subsection{[[q]]uitting: [[q]]}

<<[[commands()]] switch [[c]] cases (ed.c)>>=
case 'Q':
    fchange = false;
    // fallthrough:
case 'q':
    setnoaddr();
    newline();
    quit();
@


<<function [[setnoaddr]](ed.c)>>=
void
setnoaddr(void)
{
    if(given)
        error(Q);
}
@
% command that does not accept addresses!


\subsection{[[d]]eleting lines: [[d]]}
% delete

<<[[commands()]] switch [[c]] cases (ed.c)>>=
case 'd':
    nonzero();
    newline();
    rdelete(addr1, addr2);
    continue;
@

% r ? vs gdelete? global delete, right delete? range delete?
<<function [[rdelete]](ed.c)>>=
void
rdelete(int *ad1, int *ad2)
{
    int *a1, *a2, *a3;

    a1 = ad1;
    a2 = ad2+1;
    a3 = dol;
    dol -= a2 - a1;
    do {
        *a1++ = *a2++;
    } while(a2 <= a3);
    a1 = ad1;
    if(a1 > dol)
        a1 = dol;
    dot = a1;
    fchange = true;
}
@
% note that it does not change tfile! just indices are modified

% a bit like append(), shift zero entries but in other direction

\subsection{[[c]]hanging lines: [[c]]}
% change

<<[[commands()]] switch [[c]] cases (ed.c)>>=
case 'c':
    nonzero();
    newline();
    rdelete(addr1, addr2);
    append(gettty, addr1-1);
    continue;
@

\subsection{[[m]]oving and copying lines: [[m]] and [[t]]}
% 't' because 'c' was already used for change

<<[[commands()]] switch [[c]] cases (ed.c)>>=
case 'm':
    move(0);
    continue;
@

<<[[commands()]] switch [[c]] cases (ed.c)>>=
case 't':
    move(1);
    continue;
@

<<function [[move]](ed.c)>>=
void
move(int cflag)
{
    int *adt, *ad1, *ad2;

    nonzero();
    if((adt = address())==0)    /* address() guarantees addr is in range */
        error(Q);
    newline();

    if(cflag) {
        int *ozero, delta;
        ad1 = dol;
        ozero = zero;
        append(getcopy, ad1++);
        ad2 = dol;
        delta = zero - ozero;
        ad1 += delta;
        adt += delta;
    } else {
        ad2 = addr2;
        for(ad1 = addr1; ad1 <= ad2;)
            *ad1++ &= ~01;
        ad1 = addr1;
    }
    ad2++;
    if(adt<ad1) {
        dot = adt + (ad2-ad1);
        if((++adt)==ad1)
            return;
        reverse(adt, ad1);
        reverse(ad1, ad2);
        reverse(adt, ad2);
    } else
    if(adt >= ad2) {
        dot = adt++;
        reverse(ad1, ad2);
        reverse(ad2, adt);
        reverse(ad1, adt);
    } else
        error(Q);
    fchange = true;
}
@

<<function [[getcopy]](ed.c)>>=
int
getcopy(void)
{
    if(addr1 > addr2)
        return EOF;
    getline(*addr1++);
    return 0;
}
@

<<function [[reverse]](ed.c)>>=
void
reverse(int *a1, int *a2)
{
    int t;

    for(;;) {
        t = *--a2;
        if(a2 <= a1)
            return;
        *a2 = *a1;
        *a1++ = t;
    }
}
@



\section{Command addresses}

%trans: until now assume simple commands like a, i, q, etc.
% but ed actually quite powerful and can give addresses before
% the command as 1i or $a (see mkenam.sh) or even 1,3p
% "each command can be preceded by one or two line numbers ..."

\subsection{Reading [[addr1]] and [[addr2]]}

<<globals ed.c>>=
bool given;
@
% whether the user explicitly typed an address or not.

<<[[commands()]] other locals>>=
int *a1;
@

<<[[commands()]] other locals>>=
char lastsep; // '\n' or ',' or ';'
@

% let's go
<<[[commands()]] read [[addr1]] and [[c]] via [[getchr]]>>=
c = '\n';
addr1 = nil;

for(;;) {
    lastsep = c;
    a1 = address();
    c = getchr();
 
   if(c != ',' && c != ';')
        break;

    // else
    if(lastsep == ',')
        error(Q);
    if(a1 == nil) {
        a1 = zero+1; // line 1
        if(a1 > dol)
            a1--;
    }
    addr1 = a1;
    <<[[commands()]] in address parsing, if separator is [[';']]>>
}
<<[[commands()]] after address parsing, use defaults if missing addresses>>
@

<<[[commands()]] in address parsing, if separator is [[';']]>>=
if(c == ';')
    dot = a1;
@
% so allow to set dot as part of the address,  like 3;5p
% means after this command dot will be 3.


<<[[commands()]] after address parsing, use defaults if missing addresses>>=
if(lastsep != '\n' && a1 == nil)
    a1 = dol;

if((addr2=a1) == nil) {
    given = false;
    addr2 = dot;    
} else
    given = true;

if(addr1 == nil)
    addr1 = addr2;
@


\subsection{[[address()]]}

<<function [[address]](ed.c)>>=
int*
address(void)
{
    int sign, *a, opcnt, nextopand, *b, c;

    nextopand = -1;
    sign = 1;
    opcnt = 0;
    a = dot;
    do {
        do {
            c = getchr();
        } while(c == ' ' || c == '\t');

        if(c >= '0' && c <= '9') {
            peekc = c;
            if(!opcnt)
                a = zero;
            a += sign*getnum();
        } else

        switch(c) {
        // will return in default: case
        <<[[address()]](ed.c) switch [[c]] cases>>
        }

        sign = 1;
        opcnt++;
    } while(zero <= a && a <= dol);

    error(Q);
    return nil;
}
@

<<[[address()]](ed.c) switch [[c]] cases>>=
default:
    if(nextopand == opcnt) {
        a += sign;
        if(a < zero || dol < a)
            continue;       /* error(Q); */
    }

    if(c != '+' && c != '-' && c != '^') {
        peekc = c;
        if(opcnt == 0)
            a = nil;

        // finally returning!
        return a;
    }
    sign = 1;
    if(c != '+')
        sign = -sign;
    nextopand = ++opcnt;
    continue;
@

% get number
<<function [[getnum]](ed.c)>>=
int
getnum(void)
{
    int r = 0;
    int c;

    for(;;) {
        c = getchr();
        if(c < '0' || c > '9')
            break;
        r = r*10 + (c-'0');
    }
    peekc = c;
    return r;
}
@



\subsection{Basic addresses: [[.]] and [[$]]}

<<[[address()]](ed.c) switch [[c]] cases>>=
case '$':
    a = dol;
    // Fallthrough
case '.':
    if(opcnt)
        error(Q);
    break;
@




\section{Search and replace}
% regexp, regular expressions


\subsection{Search as addresses: [[/re/]] and [[?re?]]}

<<[[address()]](ed.c) switch [[c]] cases>>=
case '?':
    sign = -sign;
    // Fallthrough
case '/':
    compile(c);
    b = a;
    for(;;) {
        // direction
        a += sign;
        // wrap around
        if(a <= zero)
            a = dol;
        if(a > dol)
            a = zero;

        if(match(a))
            break;
        // reached back where we were without finding anything
        if(a == b)
            error(Q);
    }
    break;
@


\subsection{Reading and compiling a regexp: [[compile()]]}

<<globals ed.c>>=
Reprog  *pattern;
@

<<constants ed.c>>=
ESIZE   = 256,      /* max size of reg exp */
@

% will set pattern
% eof should be '/' or '?'
<<function [[compile]](ed.c)>>=
/// commands('g' | 'v') -> global -> <>
void
compile(int eof)
{
    Rune c;
    char *ep;
    char expbuf[ESIZE];

    if((c = getchr()) == '\n') {
        peekc = c;
        c = eof;
    }
    if(c == eof) {
        if(!pattern)
            error(Q);
        return;
    }
    // else
    if(pattern) {
        free(pattern);
        pattern = nil;
    }
    ep = expbuf;
    do {
        if(c == '\\') {
            <<[[compile()]](ed.c) sanity check [[ep]] inside [[expbuf]]>>
            // else
            ep += runetochar(ep, &c);
            if((c = getchr()) == '\n') {
                error(Q);
                return;
            }
        }
        <<[[compile()]](ed.c) sanity check [[ep]] inside [[expbuf]]>>
        // else
        ep += runetochar(ep, &c);
    } while((c = getchr()) != eof && c != '\n');
    if(c == '\n')
        peekc = c;
    *ep = '\0';

    // lib_regexp call
    pattern = regcomp(expbuf);
}
@
% see libregexp book

<<[[compile()]](ed.c) sanity check [[ep]] inside [[expbuf]]>>=
if(ep >= expbuf+sizeof(expbuf)) {
    error(Q);
    return;
}
@

\subsection{[[match()]]}

<<constants ed.c>>=
MAXSUB  = 9,        /* max number of sub reg exp */
@
<<globals ed.c>>=
Resub   subexp[MAXSUB];
@
% see \book{Libcore}

<<function [[match]](ed.c)>>=
bool
match(int *addr)
{
    <<[[match()]](ed.c) return if no [[pattern]]>>
    if(addr){
        <<[[match()]](ed.c) return if [[addr]] is [[zero]]>>
        subexp[0].s.rsp = getline(*addr);
    } else
        <<[[match()]](ed.c) when null [[addr]] use [[loc2]] not [[getline]]>>
    subexp[0].e.rep = nil;

    if(rregexec(pattern, linebuf, subexp, MAXSUB)) {
        <<[[match()]](ed.c) set [[loc1]] and [[loc2]] with matched string>>
        return true;
    }
    // else
    <<[[match()]](ed.c) reset [[loc1]] and [[loc2]]>>
    return false;
}
@
% getline() will also modify linebuf!

<<[[match()]](ed.c) return if no [[pattern]]>>=
if(!pattern)
    return false;
@
<<[[match()]](ed.c) return if [[addr]] is [[zero]]>>=
if(addr == zero)
    return false;
@



<<globals ed.c>>=
Rune*   loc1;
Rune*   loc2;
@
<<[[match()]](ed.c) set [[loc1]] and [[loc2]] with matched string>>=
loc1 = subexp[0].s.rsp;
loc2 = subexp[0].e.rep;
@
<<[[match()]](ed.c) reset [[loc1]] and [[loc2]]>>=
loc1 = loc2 = nil;
@

<<[[match()]](ed.c) when null [[addr]] use [[loc2]] not [[getline]]>>=
subexp[0].s.rsp = loc2;
@
% see soon match(nil) to redo search on same line from end of last match



\subsection{Reading and compiling a substitution: [[compsub()]]}

% will be called after 's' as in s/foo/bar/

<<globals ed.c>>=
Rune    rhsbuf[LBSIZE/sizeof(Rune)];
@

<<constants ed.c>>=
ESCFLG  = Runemax,  /* escape Rune - user defined code */
@

% return true if s/.../.../g global subst
<<function [[compsub]](ed.c)>>=
bool
compsub(void)
{
    int seof, c;
    Rune *p;

    seof = getchr();
    if(seof == '\n' || seof == ' ')
        error(Q);

    // read (and compile) the regexp (left hand side)
    compile(seof);

    // read the subst (right hand side)
    p = rhsbuf;
    for(;;) {
        c = getchr();
        <<[[compsub()]](ed.c) if match group>>
        else
        <<[[compsub()]](ed.c) if newline and no [[globp]]>>
        else
          if(c == seof)
              break;
        // else
        *p++ = c;
        <<[[compsub()]](ed.c) sanity check [[p]] inside [[rhsbuf]]>>=
    }
    *p = 0;
    <<[[compsub()]](ed.c) peek to check for [['g']]>>
    // else
    newline();
    return false;
}
@


<<[[compsub()]](ed.c) sanity check [[p]] inside [[rhsbuf]]>>=
if(p >= &rhsbuf[LBSIZE/sizeof(Rune)])
    error(Q);
@

% ?? pflag??
<<[[compsub()]](ed.c) if newline and no [[globp]]>>=
if(c == '\n' && (!globp || !globp[0])) {
    peekc = c;
    pflag = true;
    break;
}
@

\subsection{[[s]]ubstitute: [[s]]}
% s//g like sed!

<<[[commands()]] switch [[c]] cases (ed.c)>>=
case 's':
    nonzero();
    substitute(globp != nil);
    continue;
@

% compsub(); match(); dosub()
<<function [[substitute]](ed.c)>>=
void
substitute(int inglob)
{
    int *a1;
    bool gsubf; // s/.../.../g  global subst
    int n = 0;
    <<[[substitute()]](ed.c) other locals>>

    <<[[substitute()]](ed.c) read optional [[n]]>>

    gsubf = compsub();

    for(a1 = addr1; a1 <= addr2; a1++) {
        // will internally set linebuf[]
        if(match(a1)){

            int *ozero;
            int m = n;

            do {
                int span = loc2-loc1;

                if(--m <= 0) {
                    // will modify linebuf[]
                    dosub();

                    if(!gsubf)
                        break;
                    // else
                    if(span == 0) { /* null RE match */
                        if(*loc2 == 0)
                            break;
                        loc2++;
                    }
                }
            } while(match(nil));

            if(m <= 0) {
                inglob |= 01;
                // will use linebuf[]
                subnewa = putline();
                *a1 &= ~01;
                <<[[substitute()]](ed.c) after [[putline()]] if [[anymarks]]>>
                <<[[substitute()]](ed.c) after [[putline()]] set [[subolda]]>>
                *a1 = subnewa;

                <<[[substitute()]](ed.c) after [[putline()]] call [[append()]]>>
            }
        }
    }
    if(inglob == 0)
        error(Q);
}
@

<<globals ed.c>>=
int subnewa;
@
<<[[init()]](ed.c) initializing globals>>=
subnewa = 0;
@


<<globals ed.c>>=
Rune    genbuf[LBSIZE];
@

<<function [[dosub]](ed.c)>>=
void
dosub(void)
{
    Rune *lp, *sp, *rp;
    int c, n;

    lp = linebuf;
    sp = genbuf;
    rp = rhsbuf;
    while(lp < loc1)
        *sp++ = *lp++;
    while(c = *rp++) {
        <<[[dosub()]](ed.c) if [[c == '&']]>>
        <<[[dosub()]](ed.c) if match group>>
        // else
        *sp++ = c;
        if(sp >= &genbuf[LBSIZE])
            error(Q);
    }
    lp = loc2;
    loc2 = sp - genbuf + linebuf;
    while(*sp++ = *lp++)
        if(sp >= &genbuf[LBSIZE])
            error(Q);
    lp = linebuf;
    sp = genbuf;
    while(*lp++ = *sp++)
        ;
}
@




\subsection{Advanced substitutions}

\subsubsection{Matched string reference: [[s/.../...&.../]]}

<<[[dosub()]](ed.c) if [[c == '&']]>>=
if(c == '&'){
    sp = place(sp, loc1, loc2);
    continue;
}
@

<<function [[place]](ed.c)>>=
Rune*
place(Rune *sp, Rune *l1, Rune *l2)
{

    while(l1 < l2) {
        *sp++ = *l1++;
        if(sp >= &genbuf[LBSIZE])
            error(Q);
    }
    return sp;
}
@


\subsubsection{Matched groups: [[s/.../...\1.../]]}

<<[[compsub()]](ed.c) if match group>>=
if(c == '\\') {
    c = getchr();
    *p++ = ESCFLG;
    <<[[compsub()]](ed.c) sanity check [[p]] inside [[rhsbuf]]>>
} 
@

<<[[dosub()]](ed.c) if match group>>=
if(c == ESCFLG && (c = *rp++) >= '1' && c < MAXSUB+'0') {
    n = c-'0';
    if(subexp[n].s.rsp && subexp[n].e.rep) {
        sp = place(sp, subexp[n].s.rsp, subexp[n].e.rep);
        continue;
    }
    error(Q);
}
@



\subsubsection{[[u]]ndo substitution: [[u]]}

<<globals ed.c>>=
int subolda;
@

<<[[substitute()]](ed.c) after [[putline()]] set [[subolda]]>>=
subolda = *a1;
@


<<[[commands()]] switch [[c]] cases (ed.c)>>=
case 'u':
    nonzero();
    newline();
    if((*addr2&~01) != subnewa)
        error(Q);
    *addr2 = subolda;
    dot = addr2;
    continue;
@
% but will just undo the last one?


\subsubsection{[[g]]lobal subst: [[s/.../.../g]]}
% different (but related) to [[g/re/cmd]] we will see later


<<[[compsub()]](ed.c) peek to check for [['g']]>>=
peekc = getchr();
if(peekc == 'g') {
    peekc = 0;
    newline();
    return true;
}
@

% then more complicated code for substitute() with do { ... } while(match(nil))

\subsubsection{Skipped matches: [[s3/.../.../]]}

<<[[substitute()]](ed.c) read optional [[n]]>>=
n = getnum();   /* OK even if n==0 */
@

% again more complicated code for substitute()

\subsubsection{Append and subst}

<<[[substitute()]](ed.c) other locals>>=
int *mp, nl;
@
%TODO: dead? int *mp;

<<[[substitute()]](ed.c) after [[putline()]] call [[append()]]>>=
ozero = zero;
nl = append(getsub, a1);
addr2 += nl;
nl += zero-ozero;
a1 += nl;
@
%TODO: dosub() and getsub() ?? when the subst contain multiple lines?
% in which case need to append them?

% need ozero because append may modify zero and realloc

% linebp is set by putline()

<<function [[getsub]](ed.c)>>=
int
getsub(void)
{
    Rune *p1, *p2;

    p1 = linebuf;
    if((p2 = linebp) == 0)
        return EOF;
    while(*p1++ = *p2++)
        ;
    linebp = 0;
    return 0;
}
@


\subsubsection{mar[[k]]: [[k]]}

% mark something
<<[[commands()]] switch [[c]] cases (ed.c)>>=
case 'k':
    nonzero();
    c = getchr();
    if(c < 'a' || c > 'z')
        error(Q);
    newline();
    names[c-'a'] = *addr2 & ~01;
    anymarks |= 01;
    continue;
@

<<globals ed.c>>=
int names[26];
@

<<globals ed.c>>=
int anymarks;
@
<<[[init()]](ed.c) initializing globals>>=
anymarks = 0;
@

% marks address ??? move in advanced?
<<[[address()]](ed.c) switch [[c]] cases>>=
case '\'':
    c = getchr();
    if(opcnt || c < 'a' || c > 'z')
        error(Q);
    a = zero;
    do {
        a++;
    } while(a <= dol && names[c-'a'] != (*a & ~01));
    break;

@

<<[[substitute()]](ed.c) after [[putline()]] if [[anymarks]]>>=
if(anymarks) {
    for(mp=names; mp<&names[26]; mp++)
        if(*mp == *a1)
            *mp = subnewa;
}
@

<<[[init()]](ed.c) locals>>=
int *markp;
@
<<[[init()]](ed.c) initializing globals>>=
for(markp = names; markp < &names[26]; )
    *markp++ = 0;
@



\subsection{[[g]]lobal commands: [[g/re/cmd]] and [[v/re/cmd]]}

%g/re/cmd
% => g/re/p => grep :)


<<[[commands()]] switch [[c]] cases (ed.c)>>=
case 'g':
    global(1);
    continue;
@

% negative of pattern (hence grep -v)
<<[[commands()]] switch [[c]] cases (ed.c)>>=
case 'v':
    global(0);
    continue;
@

<<constants ed.c>>=
GBSIZE  = 256,      /* max size of global command */
@

<<function [[global]](ed.c)>>=
void
global(int k)
{
    Rune *gp, globuf[GBSIZE];
    int c, *a1;

    if(globp)
        error(Q);

    setwide();
    squeeze(dol > zero);

    // readding a '/' or '?'
    c = getchr();
    if(c == '\n')
        error(Q);

    // reading the whole pattern until corresponding ending '/' or '?'
    compile(c);

    gp = globuf;
    while((c=getchr()) != '\n') {
        if(c == EOF)
            error(Q);
        if(c == '\\') {
            c = getchr();
            if(c != '\n')
                *gp++ = '\\';
        }
        *gp++ = c;
        if(gp >= &globuf[GBSIZE-2])
            error(Q);
    }
    if(gp == globuf)
        *gp++ = 'p';
    *gp++ = '\n';
    *gp = 0;

    for(a1=zero; a1<=dol; a1++) {
        *a1 &= ~01;
        if(a1 >= addr1 && a1 <= addr2 && match(a1) == k)
            *a1 |= 01;
    }

    <<[[global()]](ed.c) if [[g/.../d]] command, call optimized [[gdelete()]]>>

    for(a1=zero; a1<=dol; a1++) {
        if(*a1 & 01) {
            *a1 &= ~01;
            dot = a1;
            globp = globuf;
            // recurse!
            commands();
            a1 = zero; // zero may have grown and move, need update a1
        }
    }
}
@

% note that commands () will modify addr1, addr2, zero, etc.
% so that's also why we use the mark and do the matching in phase1
% separate from phase2.
% Can't just store list of lineno in phase1, because they will be invalid
% if the command is g/re/d, to delete, hence the use of marks attached
% to line offset in zero itself. So that delete and move keep the mark

% Same way see the subtle a1 = zero, so we restart from the start
% after each commands() because zero may have changed so we must
% restart from zero but hopefully with one less marked line this time.





\section{Advanced features}

\subsection{Running a shell command: [[!]]}
% still M-! on Emacs? 
% not that GNU ed has a 'red' variant restricted to not support !
% (and read files only in current dir)

% not so needed when have multiple windows

<<[[commands()]] switch [[c]] cases (ed.c)>>=
case '!':
    callunix();
    continue;
@

<<globals ed.c>>=
bool waiting;
@

<<function [[callunix]](ed.c)>>=
void
callunix(void)
{
    int c, pid;
    Rune rune;
    char buf[512];
    char *p;

    setnoaddr();

    p = buf;
    while((c=getchr()) != EOF && c != '\n')
        if(p < &buf[sizeof(buf) - 6]) {
            rune = c;
            p += runetochar(p, &rune);
        }
    *p = '\0';

    pid = fork();
    if(pid == 0) {
        // child
        execl("/bin/rc", "rc", "-c", buf, nil);
        // should not be reached
        exits("execl failed");
    }
    // else, parent
    waiting = true;
    while(waitpid() != pid)
        ;
    waiting = false;
    if(vflag)
        putst("!");
}
@

\subsection{Advanced [[l]]isting: [[l]]}

<<globals ed.c>>=
// for displaying special chars, 'l' list flag
bool listf;
@


<<[[commands]] before [['p']] case>>=
case 'l':
    listf = true;
    // fallthrough:
@

% display special chars like newline and tabs
<<[[putchr()]] if [[listf]]>>=
if(listf) {
    if(c == '\n') {
        if(linp != line && linp[-1] == ' ') {
            *lp++ = '\\';
            *lp++ = 'n';
        }
    } else {
        if(col > (72-6-2)) {
            col = 8;
            *lp++ = '\\';
            *lp++ = '\n';
            *lp++ = '\t';
        }
        col++;
        if(c=='\b' || c=='\t' || c=='\\') {
            *lp++ = '\\';
            if(c == '\b')
                c = 'b';
            else
            if(c == '\t')
                c = 't';
            col++;
        } else
        if(c<' ' || c>='\177') {
            *lp++ = '\\';
            *lp++ = 'x';
            *lp++ =  hex[c>>12];
            *lp++ =  hex[c>>8&0xF];
            *lp++ =  hex[c>>4&0xF];
            c     =  hex[c&0xF];
            col += 5;
        }
    }
}
@

<<globals ed.c>>=
char    hex[]   = "0123456789abcdef";
@


<<globals ed.c>>=
bool pflag;
@
% ????
<<[[commands()]] in for loop, if [[pflag]]>>=
if(pflag) {
    pflag = false;
    addr1 = addr2 = dot;
    printcom();
}
@
% some commands trigger automatic implicit 'p' to print the current line



<<[[newline()]] if special chars [[pln]]>>=
if(c == 'p' || c == 'l' || c == 'n') {
    pflag = true;
    if(c == 'l')
        listf = true;
    else
    if(c == 'n')
        listn = true;
    c = getchr();
    if(c == '\n')
        return;
}
@


<<[[printcom()]] reset flags>>=
listf = false;
listn = false;
pflag = false;
@



\subsection{Advanced listing: [[n]]}

<<globals ed.c>>=
// 'n' flag
bool listn;
@

<<[[commands()]] switch [[c]] cases (ed.c)>>=
case 'n':
    listn = true;
    newline();
    printcom();
    continue;
@
% ??

<<[[printcom()]] if [[listn]]>>=
if(listn) {
    count = a1-zero;
    putd();
    putchr(L'\t');
}
@

\subsection{[[j]]oining lines: [[j]]}

<<[[commands()]] switch [[c]] cases (ed.c)>>=
case 'j':
    if(!given)
        addr2++;
    newline();
    join();
    continue;
@

<<function [[join]](ed.c)>>=
void
join(void)
{
    Rune *gp, *lp;
    int *a1;

    nonzero();
    gp = genbuf;
    for(a1=addr1; a1<=addr2; a1++) {
        lp = getline(*a1);
        while(*gp = *lp++)
            if(gp++ >= &genbuf[LBSIZE-sizeof(Rune)])
                error(Q);
    }
    lp = linebuf;
    gp = genbuf;
    while(*lp++ = *gp++)
        ;
    *addr1 = putline();
    if(addr1 < addr2)
        rdelete(addr1+1, addr2);
    dot = addr1;
}
@


\subsection{[[b]]rowse: [[b]]}

<<[[commands()]] switch [[c]] cases (ed.c)>>=
case 'b':
    nonzero();
    browse();
    continue;
@
% ???

% seems used only by browse, "browse pagesize", useful in global?
% could be a static local
<<globals ed.c>>=
int bpagesize = 20;
@

<<function [[browse]](ed.c)>>=
void
browse(void)
{
    int forward, n;
    static int bformat, bnum; /* 0 */

    forward = 1;
    peekc = getchr();
    if(peekc != '\n'){
        if(peekc == '-' || peekc == '+') {
            if(peekc == '-')
                forward = 0;
            getchr();
        }
        n = getnum();
        if(n > 0)
            bpagesize = n;
    }
    newline();
    if(pflag) {
        bformat = listf;
        bnum = listn;
    } else {
        listf = bformat;
        listn = bnum;
    }
    if(forward) {
        addr1 = addr2;
        addr2 += bpagesize;
        if(addr2 > dol)
            addr2 = dol;
    } else {
        addr1 = addr2-bpagesize;
        if(addr1 <= zero)
            addr1 = zero+1;
    }
    printcom();
}
@

\subsection{[[e]]dit remembered file: [[e]]}

% edit, reset savedfile and reset tmpfile and reread
<<[[commands()]] switch [[c]] cases (ed.c)>>=
case 'E':
    fchange = false;
    c = 'e';
    // Fallthrough
case 'e':
    setnoaddr();
    if(vflag && fchange) {
        fchange = false;
        error(Q);
    }
    filename(c);
    init();
    addr2 = zero;
    goto caseread;
@


\subsection{Append-only files}

% move to advanced topics. seems very plan9 specific feature
<<[[commands()]] other locals>>=
Dir *d;
@
<<[[commands()]] in [[r]] case if append only file>>=
if((d = dirfstat(io)) != nil){
    if(d->mode & DMAPPEND)
        print("warning: %s is append only\n", file);
    free(d);
}
@
% what are append-only files? a plan9 thing?

% bug? not guarded by vflag?

\section{Optimizations}

% needed? because when ken thompson wrote it there was no buffer cache in
% the kernel? So he kinda reimplement one in userland for ed?
% Also did input and output buffer, which are part of default
% impleme of standard IO in OCaml no?

\subsection{Optimized [[putline()]]}

<<globals ed.c>>=
int nleft;
@
<<globals ed.c>>=
Rune*   linebp;
@

<<constants ed.c>>=
BLKSIZE = 4096,     /* block size in temp file */
@

% put a line in tfile using linebuf (set by getfile above)
% quite complicated because do block IO instead of simply seek and write
% returns ?? tline ??
<<function [[putline]](ed.c)>>=
/// main -> commands('r') -> append -> <>
int
putline(void)
{
    Rune *lp, *bp;
    int nl, tl;

    fchange = true;
    lp = linebuf;
    tl = tline;

    bp = getblock(tl, OWRITE);
    nl = nleft;
    tl &= ~((BLKSIZE/sizeof(Rune))-1);
    while(*bp = *lp++) {
        if(*bp++ == '\n') {
            bp[-1] = 0;
            linebp = lp;
            break;
        }
        nl -= sizeof(Rune);
        if(nl == 0) {
            tl += BLKSIZE/sizeof(Rune);
            bp = getblock(tl, OWRITE);
            nl = nleft;
        }
    }

    nl = tline;
    tline += ((lp-linebuf) + 03) & 077776;
    return nl;
}
@


\subsection{[[getblock()]]}

<<constants ed.c>>=
NBLK    = 8191,     /* max size of temp file */
@

% read/write per block, probably because faster granularity for IO?

% static ibuff/obuff to avoid some IO sometimes? do batched IO
% for lines when we needed instead of each time?

<<globals ed.c>>=
int iblock;
int oblock;
int ichanged;
@
<<[[init()]](ed.c) initializing globals>>=
iblock = -1;
oblock = -1;
ichanged = 0;
@

<<function [[getblock]](ed.c)>>=
/// putline | getline -> <>
Rune*
getblock(int atl, int iof)
{
    int bno; // block number
    int off; // offset
    
    static uchar ibuff[BLKSIZE];
    static uchar obuff[BLKSIZE];

    bno = atl / (BLKSIZE/sizeof(Rune));
    /* &~3 so the ptr is aligned to 4 (?) */
    off = (atl*sizeof(Rune)) & (BLKSIZE-1) & ~3;
    if(bno >= NBLK) {
        lastc = '\n';
        error(T);
    }
    nleft = BLKSIZE - off;
    if(bno == iblock) {
        ichanged |= iof;
        return (Rune*)(ibuff+off);
    }
    if(bno == oblock)
        return (Rune*)(obuff+off);
    if(iof == OREAD) {
        if(ichanged)
            blkio(iblock, ibuff, write);
        ichanged = 0;
        iblock = bno;
        blkio(bno, ibuff, read);
        return (Rune*)(ibuff+off);
    }
    if(oblock >= 0)
        blkio(oblock, obuff, write);
    oblock = bno;
    return (Rune*)(obuff+off);
}
@

% finally tfile!
<<function [[blkio]](ed.c)>>=
void
blkio(int b, uchar *buf, long (*iofcn)(int, void *, long))
{
    seek(tfile, b*BLKSIZE, SEEK__START);
    if((*iofcn)(tfile, buf, BLKSIZE) != BLKSIZE) {
        error(T);
    }
}
@


\subsection{Optimized [[getline()]]}
% tl for temporary line (file offset in tfile)
<<function [[getline]](ed.c)>>=
/// printcom | putfile -> <>
Rune*
getline(int tl)
{
    Rune *lp, *bp;
    int nl;

    lp = linebuf;
    bp = getblock(tl, OREAD);
    nl = nleft;
    tl &= ~((BLKSIZE/sizeof(Rune)) - 1);
    while(*lp++ = *bp++) {
        nl -= sizeof(Rune);
        if(nl == 0) {
            tl += BLKSIZE/sizeof(Rune);
            bp = getblock(tl, OREAD);
            nl = nleft;
        }
    }
    return linebuf;
}
@

\subsection{[[gdelete()]]}

<<[[global()]](ed.c) if [[g/.../d]] command, call optimized [[gdelete()]]>>=
/*
 * Special case: g/.../d (avoid n^2 algorithm)
 */
if(globuf[0] == 'd' && globuf[1] == '\n' && globuf[2] == 0) {
    gdelete();
    return;
}
@

<<function [[gdelete]](ed.c)>>=
void
gdelete(void)
{
    int *a1, *a2, *a3;

    a3 = dol;
    for(a1=zero; (*a1&01)==0; a1++)
        if(a1>=a3)
            return;
    for(a2=a1+1; a2<=a3;) {
        if(*a2 & 01) {
            a2++;
            dot = a1;
        } else
            *a1++ = *a2++;
    }
    dol = a1-1;
    if(dot > dol)
        dot = dol;
    fchange = true;
}
@



\section{Error management}

\subsection{[[error()]]}

<<[[main()]](ed.c) before [[commands()]]>>=
setjmp(savej);
@

<<globals ed.c>>=
jmp_buf savej;
@
% kinda like poor's man exception mechanism. Simple but effective.

<<function [[error]](ed.c)>>=
void
error(char *s)
{
    error_1(s);
    longjmp(savej, 1);
}
@
% longtmp =~ exn to jump just before commands() to reread commands!


<<function [[error_1]](ed.c)>>=
void
error_1(char *s)
{
    int c;

    <<[[error_1()]](ed.c)) reset globals>>
    putchr(L'?');
    putst(s);
}
@
% show '?' to display problem and then possible error message

% why so cryptic? why error message so bad? Even kernighan in
% his tutorial mentions it.




% error recovery on input, reset what was read essentially?
<<[[error_1()]](ed.c)) reset globals>>=
wrapp = false;
listf = false;
listn = false;
count = 0;

seek(STDIN, 0, SEEK__END);
pflag = false;

if(globp)
    lastc = '\n';
globp = nil;

peekc = lastc;
if(lastc)
    for(;;) {
        c = getchr();
        if(c == '\n' || c == EOF)
            break;
    }

if(io > 0) {
    close(io);
    io = -1;
}
@

<<constants ed.c>>=
EOF = -1,
@

\subsection{Notes/signals management}


<<globals ed.c>>=
bool rescuing;
@

<<function [[notifyf]](ed.c)>>=
void
notifyf(void *a, char *s)
{
    if(strcmp(s, "interrupt") == ORD__EQ){
        if(rescuing || waiting)
            noted(NCONT);
        putchr(L'\n');
        lastc = '\n';
        error_1(Q);
        notejmp(a, savej, 0);
    }
    if(strcmp(s, "hangup") == ORD__EQ){
        if(rescuing)
            noted(NDFLT);
        rescue();
    }
    fprint(STDERR, "ed: note: %s\n", s);
    abort();
}
@
% notejmp??

<<function [[rescue]](ed.c)>>=
void
rescue(void)
{
    rescuing = true;
    if(dol > zero) {
        addr1 = zero+1;
        addr2 = dol;
        io = create("ed.hup", OWRITE, 0666);
        if(io > 0){
            Binit(&iobuf, io, OWRITE);
            putfile();
        }
    }
    fchange = false;
    quit();
}
@

% ??? seems unused. Callback when libregexp fails?
<<function [[regerror]](ed.c)>>=
void
regerror(char *s)
{
    USED(s);
    error(Q);
}
@

% ?? seems dead, called by? like regerror weird
<<function [[onquit]](ed.c)>>=
void
onquit(int sig)
{
    USED(sig);
    quit();
}
@



\section{Extra code}

<<plan9 includes>>=
#include <u.h>
#include <libc.h>
@


%dead:
%<<globals ed.c>>=
%char    WRERR[] = "WRITE ERROR"; // dead?
%@


%-------------------------------------------------------------
<<editors/misc/ed.c>>=
/*
 * Editor
 */
<<plan9 includes>>
#include <bio.h>
#include <regexp.h>

enum
{
    <<constants ed.c>>
};

// ??? seems dead
void    (*oldhup)(int);
void    (*oldquit)(int);

<<globals ed.c>>

// forward declarations
void    add(int);
int*    address(void);
int     append(int(*)(void), int*);
void    browse(void);
void    callunix(void);
void    commands(void);
void    compile(int);
int     compsub(void);
void    dosub(void);
void    error(char*);
int     match(int*);
void    exfile(int);
void    filename(int);
Rune*   getblock(int, int);
int     getchr(void);
int     getcopy(void);
int     getfile(void);
Rune*   getline(int);
int     getnum(void);
int     getsub(void);
int     gettty(void);
void    global(int);
void    init(void);
void    join(void);
void    move(int);
void    newline(void);
void    nonzero(void);
void    notifyf(void*, char*);
Rune*   place(Rune*, Rune*, Rune*);
void    printcom(void);
void    putchr(int);
void    putd(void);
void    putfile(void);
int     putline(void);
void    putshst(Rune*);
void    putst(char*);
void    quit(void);
void    rdelete(int*, int*);
void    regerror(char *);
void    reverse(int*, int*);
void    setnoaddr(void);
void    setwide(void);
void    squeeze(int);
void    substitute(int);

<<function [[main]](ed.c)>>

<<function [[commands]](ed.c)>>

// Command helpers
<<function [[printcom]](ed.c)>>

<<function [[address]](ed.c)>>
<<function [[getnum]](ed.c)>>

// ???
<<function [[setwide]](ed.c)>>
<<function [[setnoaddr]](ed.c)>>
<<function [[nonzero]](ed.c)>>
<<function [[squeeze]](ed.c)>>
<<function [[newline]](ed.c)>>
<<function [[filename]](ed.c)>>

// Writing files
<<function [[exfile]](ed.c)>>

// Error management
<<function [[error_1]](ed.c)>>
<<function [[error]](ed.c)>>
<<function [[rescue]](ed.c)>>

// Note management
<<function [[notifyf]](ed.c)>>

// Reading characters
<<function [[getchr]](ed.c)>>
<<function [[gety]](ed.c)>>
<<function [[gettty]](ed.c)>>

// Reading and writing files
<<function [[getfile]](ed.c)>>
<<function [[putfile]](ed.c)>>

<<function [[append]](ed.c)>>
<<function [[add]](ed.c)>>

<<function [[browse]](ed.c)>>

<<function [[callunix]](ed.c)>>

<<function [[quit]](ed.c)>>
<<function [[onquit]](ed.c)>>

// Delete
<<function [[rdelete]](ed.c)>>
<<function [[gdelete]](ed.c)>>

// Get/Put lines
<<function [[getline]](ed.c)>>
<<function [[putline]](ed.c)>>
<<function [[blkio]](ed.c)>>
<<function [[getblock]](ed.c)>>

<<function [[init]](ed.c)>>

<<function [[global]](ed.c)>>

<<function [[join]](ed.c)>>

// Search and replace
<<function [[substitute]](ed.c)>>
<<function [[compsub]](ed.c)>>
<<function [[getsub]](ed.c)>>
<<function [[dosub]](ed.c)>>
<<function [[place]](ed.c)>>

<<function [[move]](ed.c)>>
<<function [[reverse]](ed.c)>>
<<function [[getcopy]](ed.c)>>

<<function [[compile]](ed.c)>>
<<function [[match]](ed.c)>>

// Printing text
<<function [[putd]](ex.c)>>
<<function [[putstr]](ed.c)>>
<<function [[putshst]](ed.c)>>
<<function [[putchr]](ed.c)>>

<<function [[mktemp]](ed.c)>>

<<function [[regerror]](ed.c)>>
@

\section{Index}
