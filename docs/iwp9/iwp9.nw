\documentclass{article}

\input{../latex/Packages}

%alt: \input{../latex/Noweb}
% but pb with relative path so inlined here
\usepackage{../latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{../latex/syncweb}

%alt: \input{../latex/Config}
% but we actually dont want the width setting of Config so inlined
% here just is requires by Macros below
\newif\iffinal
\newif\ifverbose
\newif\ifallcode

\input{../latex/Macros}

\title{
Principia Softwarica: Plan9 code explained
}
\author{
Yoann Padioleau\\
yoann.padioleau@gmail.com
}

\begin{document}
\maketitle

\begin{abstract}
%dup: Principia.nw and Introduction section
{\em \principia} is a series of books explaining how things work in a
{computer} by describing with full details all the {source code} of all
the essential Plan9 {programs} used by a {programmer}: 
the kernel, the shell, the assembler, the linker, the C compiler, the editor,
the windowing system, the build system, etc.
Each program is covered by a separate book and explained using
the {\em literate programming} technique.
\end{abstract}

\section{Introduction}

Plan9 didn't have the success it deserved. 
% sad
It was
innovative,
elegant,
small,
and designed by great programmers.
%
Those great minds didn't just rethink the kernel, they rethinked
the whole operating system (OS) in a holistic manner with 
a kernel pushing the ``everything is a file'' motto to its limit,
an integrated graphic and network stack,
a windowing system that could even run under itself,
a compact cross-compiling toolchain 
(with assemblers, linkers, C compilers, debuggers, and profilers
for most architectures),
minimalist C libraries,
a simpler build system and
shell,
and more.
% just missed browser :( and being OSS from day one before 1991, and VCS


What is even more impressive is that those powerful programs
contain only in the order of thousands lines of code (LOC).
%
Rio for example, the Plan9 windowing system, contains just 8 800 LOC
and is arguably more poweful than XOrg (an implementation of XWindow)
which contains millions LOC. The Xwindow program xterm, which
is just a terminal, not the windowing system, contains already 80 000 LOC
while Rio contains a built-in terminal in less than 1000 LOC.
% that's a 80x reduction!
% (cite plan9 classic paper, cite rio or predecessor).
% possible because of elegance of plan9 namespace, /dev/cons, etc.
%
%said-later:
In fact, with only 350 000 LOC, Plan9 implemented from scratch all
the major components of an OS. 
%% sad it failed; Rob Pike then sad wrote "software research is irrelevant"


Instead, the Linux/GNU/Xorg OS won, partly because it
was the first open-source (OSS) system available.
% Arguably not as innovative, not as elegant, not as simple, but it won.
% Plan9 was Open source too, but a bit late.
%%History repeat itself ... 
%%Unix v6 was closed by AT&T Freebsd in prison for a long time.
%% Plan9 was closed, then inferno, then open source but late, and
%% really open sourced far later by plan9 foundation.
% Linux/GNU/Xfree86 nice to have robust open source Unix
Unfortuntately, even if the source code is open, it is very hard to understand
most of this code because each component (e.g., the Linux kernel,
the Bash shell, the GNU C library, gcc, binutils, gdb) contains 
multiple orders of magnitude more code than Plan9 with millions LOC.
% Compare LOC rc bs bash, LOC rio vs xterm. lol.
%see-later: TABLE
This situation is sad, and potentially dangerous, because most
programmers rely on a giant software stack that very few people (if any)
fully understand.
The situation is even worse for students who don't have any path
to understand deeply this software stack.

Enter {\em \principia}, a new project to repurpose Plan9
from an old research OS to a fresh teaching OS,
with OS in a general sense: not just the kernel but the whole
software stack.

%dup: Principia.nw intro
Concretely, \principia is a series of books explaining how things work in a
{computer} by describing with full details all the {source code} of all
the essential Plan9 {programs} used by a {programmer}.
Each program will be covered by a separate book. 

%dup: Principia.nw intro
The books not only describe the implementations of essential programs,
{\em they are} the implementations of those programs. Indeed,
each program in \principia comes from a 
{\em literate program}~\cite{lp-book}, 
which is a document containing both source code and documentation
and where the code is organized and presented in a way 
to facilitate its comprehension
(see Section~\ref{sec:lp}).
The actual code and the book are derived both automatically from this literate
program.
% AS explained later in Section Y
%They form together the foundation on top of which all applications can
%be built.

%Understand essence, useful for many things.
%Hopefully give the right place to show hidden gem that is Plan9 code!
%and code of those great programmers.

The rest of the article is organized as follows:
% TOC:
% - Principia softwarica book set:
%   20 books! Each a literate system essential program for a developer!
% - Literate programming intro
% - Yet another plan9 repo. 
% - Yet another distribution
% - Modern software engineering practice
% - Future and related work.

\section{The bookset}

%dup: Principia.nw intro
Similar to {\em Principia Mathematica}~\cite{principia}, 
which is a series of books
covering the foundations of mathematics, the goal of \principia
is to cover the fundamental programs.
%
Those programs are mostly all {\em meta programs}, which are
programs in which the input and/or output are other programs.
For instance, the kernel is a program that {manages} other programs;
the compiler is a program that {generates} other programs.
%
Those programs are also sometimes referred as {\em system software},
in opposition to {\em application software} (e.g., spreadsheets,
word processors, email clients), which is not covered by \principia.

Table~\ref{tab:books} present the list of books in \principia
and the corresponding Plan9 programs or libraries they document.

\begin{table}[htbp]
\centering
\begin{tabular}{p{2.2cm} l p{2.5cm} r r r}
\hline
\textbf{Category} & \textbf{Book} & \textbf{Program(s)} & \textbf{LOC} & \textbf{LOE} & \textbf{Pages} \\
\hline
\multirow{3}{*}{Core system}
  & Kernel
  & \texttt{9pi}
  & 60 000 & 0 & 42  \\ %\cline{2-6}

  & Core libraries
  & \texttt{libc libregexp libthread}
  & 21 500 & 0 & 42 \\ %\cline{2-6}

  & Shell
  & \texttt{rc}
  & 7 500 & 0 & 42 \\
\hline
\multirow{3}{=}{Development\\ toolchain}
  & C compiler
  & \texttt{5c}
  & 25 000 & 0 & 42 \\ %\cline{2-6}

  & Assembler
  & \texttt{5a}
  & 4 100 & 0 & 42 \\ %\cline{2-6}

  & Linker
  & \texttt{5l}
  & 7 900 & 0 & 42 \\ %\cline{2-6}
%skipped:
%  & Emulator
%  & \texttt{5i}
%  & 4 400 \\
%skipped: ocamlc, ocamlopt
%skipped: olex, oyacc
\hline
\multirow{4}{=}{Developer\\tools}
  & Editor
  & \texttt{ed}
  & 25 000 & 0 & 42 \\ %\cline{2-6}
%skipped: editor efuns

  & Build system
  & \texttt{mk}
  & 25 000 & 0 & 42 \\ %\cline{2-6}

  & Debugger
  & \texttt{db acid}
  & 4 100 & 0 & 42 \\ %\cline{2-6}

  & Profiler
  & \texttt{prof}
  & 7 900 & 0 & 42 \\
%skipped: ogit
%skipped: troff
\hline
\multirow{2}{=}{Graphics}
  & Graphics stack
  & \texttt{/dev/draw lib\_graphics}
  & 26 000 & 0 & 42 \\ %\cline{2-6}
% 10k+ (kernel) + 16k

  & Windowing system
  & \texttt{rio}
  & 10 500 & 0 & 42 \\
%skipped: libpanel
\hline
\multirow{1}{=}{Networking}
  & Network stack
  & \texttt{/dev/net lib\_networking}
  & 23 000 & 0 & 42 \\ %\cline{2-6}
% 23k+ (kernel) + 51k
%skipped: mmm
\hline
\multirow{1}{=}{Utilities}
  & CLI utilities
  & \texttt{cat ls grep sed diff tar gzip \ldots}
  & 23 000 & 0 & 42 \\ %\cline{2-6}
% also bc, hoc, awk, etc
\hline
\textbf{Total: } & & & 0 & 0 & 0 \\
\hline
\end{tabular}
\caption{\principia books}
\label{tab:books}
\end{table}

% ARM (and raspberry pi) focus. simpler than 86, and goal is understand essence,
% not useless detail. But still real arch! not toy arch!

% ARM in most phones today and in raspberry pi!
% in fact kernel 9pi. Great work by Richard Miller not in original plan9.
% Raspberri pi great for teaching context.

%10 000 LOC is explainable in a book of a reasonable size!
%bash for example? vs rc ?
%millions LOC would require 400 books of 300 pages, just for bash :)

% As can see, unfinished, still lots of work.
% I started in 2014 but was on pause between 2019 and 2024,
% and resume almost full-time on it mid 2025.



\section{Literate programming introduction}
\label{sec:lp}

%dup: Principia.nw
Source code is the ultimate explanation for what a program does.
%
However, showing pages and pages of listings in an appendix, 
as done for instance in the Minix book~\cite{minix},
even when this appendix is preceded by documentation chapters, is arguably not
the best way to explain code. The code and its documentation
should be mixed together, as done for instance in the Xinu book~\cite{xinu},
so one does not have to switch back and forth between
an appendix and multiple chapters.

{\em Literate programming}~\cite{lp-book} is a technique invented by
Donald Knuth to make it easy to mix code and documentation
in a document in order to better develop and better explain programs. 
Such documents are called {\em literate programs}. All \principia
programs are literate programs.

% PUT EXAMPLE HERE. multicolumn.

Note that literate programming is different from using 
{API documentation generators} such as 
javadoc\furl{http://www.oracle.com/technetwork/articles/java/index-jsp-135444.html} or 
doxygen\furl{http://www.stack.nl/~dimitri/doxygen/}.
%
Noweb\furl{http://www.cs.tufts.edu/~nr/noweb/}, the literate
%TODO: really syncweb now
programming tool used for \principia, does not provide the same kind
of services. 
%
Indeed, literate programming allows programmers to explain their
code in the order they think the flow of their thoughts and their code would
be best understood, rather than the order imposed by the compiler.

Literate programming
allows, among other things, to explain the code piece by piece, with the
possibility to present a high-level view first of the code,
to switch between {top-down} and {bottom-up} explanations, and to
separate {concerns}.
%
For instance, the [[Proc]] data structure --- which you will
see in the \book{Kernel} is a data structure that
represents some information about a process --- is a huge structure
with more than 90 fields. Many of those fields are used only
for advanced features of the kernel. The C compiler imposes
to define this structure in one place.
Noweb
% which can be seen as a macro-processing language, 
allows to present this structure piece by piece, gradually, in different
chapters. I can show first the code of the structure with 
the most important fields,
and delay the exposition of other fields to advanced chapters.
This greatly facilitates the understanding of the code, by not
submerging you with too much details first.
\t see appendix example

In the same way, the [[main()]] function in most
programs is rather large and mixes together many concerns:
command line processing, error management, debugging output,
optimizations, and usually a call to the main algorithm.
Showing in one listing the whole function would hide behind
noise this call to the main algorithm. The main flow
of the program though is arguably the most important thing to understand
first. Using literate programming,
I can show code where the most important parts are highlighted, and where
other concerns are hidden and presented later. 

In fact, I spent lots of time during the writing of the \principia books
in transforming the \plan programs in literate
programs, and in reorganizing again and again the \plan code to find
the best way, the best order, the best separation of concerns
to more easily understand the code.




%   noweb.
%   ex of book? or of ed.nw?
%   also syncweb! (also nice index, nice -lpizer)

\section{Yet another Plan9 fork}

% git URL. Yet another fork. 
%said-later: git is good

% literate programs. Subset of plan9.

%   Diff with 9front, plan9port, etc. is focus on code explanations!

%   code reorg, more easily "discoverable" dirs (5a cryptic, it's
%   an assembler/). Show output of tree command in 3 columns.

%   Actually simplified the code a bit sometimes, so easier to explain!
%   Some nice improvments IMHO. Found also bugs! as I was explaining
%   and could not explain :)


\section{A new Plan9 distribution}

% - cross compiled from Linux/macOS/Windows! quite different from other
%   (thx to goken)
% - build vfat (DOS) images for x86 (QEMU) and arm (Raspberri pi) that
%   can be easily explored and tweaked
% - no CDs. no .iso

% Cross compiled from goken (see WIP) from Linux/macOS/Windows (and also Docker)
%said-later: docker stuff
% gcc-binutils or clang-LLVM.
% Not trivial, 64bits new arch, long vs int, but separate paper.
% Share code with principia but
% separate package because as its own use.

% why not plan9port? no compiler in it!
% why not inferno-os kencc? well yes, that's what I did, but needed an update.


%   make new distrib easily. Easy to experiment. Got trouble 10 years ago
%   to test, with ISO CDs, qemu pbs. slow down adoption.
%   now qemu friendly, and raspberry pi friendly! great for teaching context!
%   cheap to buy. Greak work by Richard Miller (but again not easy to test
%   currently).
%   Incredible ease and speed! modify syscall order, recompile
%   everything, test GHA, it works! and can do that from Linux/macOS/Windows,
%   so easier to experiment and adopt! especially in teaching context

\section{Modern practice}
%alt: Quality of life improvements:
%alt: A modern distribution

% Modern does not always mean better, and very often old plan9
% was better than modern tools, still there are a few things
% that are convenient nowadays, even if arguably not most elegant:

% git and github! easy collaboration (9front too).
% docker build infra.
% GHA (just run docker build)

% C ref_xxx, error1, abuse int/string.
% less globals, better split files, less mutual deps (thx codegraph)

\section{Future work}
%said-before: current status in table section 2 now

% not self-hosted yet, build principia from other OS (which has
% its advantage in teaching context), and with separate goken.

\section{Related work}

% Xv6 (and Unix v6 before) great for kernel, but limited.
% STEPS project, rethink full in far less LOC. goal was 10k, but failed,

%TODO: copy Principia.nw section

\section{Conclusion}

%dup: Principia.nw
I hope the \principia books will greatly consolidate
student computer science knowledge and give students a better and
more complete picture of what is going on in a computer.

%dup: Principia.nw
The \principia programs form together the minimal foundation
on top of which all applications can be built. Even though there are
many books in the series, I still think it is the
minimal foundation. Indeed, it is hard to remove any of those programs
because they depend on each other.
%
First, you need to rely on a kernel (hence the name), but
the shell and the C library are also essential. 
However, because those programs
are coded in C and assembly, you also need a C compiler and
an assembler, and because source code is usually split in many
files you also need a linker.
%The C compiler itself usually uses DSLs like Lex and Yacc.
%\l which are themselves written in C and actually use also lex and yacc themselves
To write all this code in the first place you need an editor.
Then, with so many source files you need
a build system to automate and optimize the compilation process.
Because the programs I just mentioned inevitably have bugs
or non optimal parts, you will need a debugger and a profiler.
Finally, nowadays
it is inconceivable to not use a graphical user interface
and to not work with multiple windows opened at the same time.
In the same way it is also not conceivable to work
in isolation; programmers collaborate with each other,
especially via the Web.
This means you need a graphical and networking stack as well
as a windowing system.
% and a Web browser.
As I said earlier, it is hard to remove any of the programs
from the series.

%dup: Principia.nw
I hope those books will answer many students questions, 
even those that seem very simple at first
such as ``What happens when the user type [[ls]] in a terminal window?''.
The answer to this question
involves many software layers (the shell,
the C library, the kernel, the graphics stack, and the windowing system)
and actually a non-trivial amount of code.
% still, doable, but on Linux would be super complicated with pty, tty,

\bibliography{../latex/Principia}
\bibliographystyle{alpha}

\end{document}
