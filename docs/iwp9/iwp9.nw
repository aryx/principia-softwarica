\documentclass{article}
%CONFIG:
%\usepackage{fullpage}

\input{../latex/Packages}
\usepackage{caption}
\captionsetup{
  justification=centering,
  singlelinecheck=false
}

%alt: \input{../latex/Noweb}
% but pb with relative path so inlined here
\usepackage{../latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{../latex/syncweb}

%alt: \input{../latex/Config}
% but we actually dont want the width setting of Config so inlined
% here just is requires by Macros below
\newif\iffinal
\newif\ifverbose
\newif\ifallcode

\input{../latex/Macros}

\title{
Principia Softwarica: \plan code explained
}
\author{
Yoann Padioleau\\
yoann.padioleau@gmail.com
}

\begin{document}
\date{}
\maketitle

\begin{abstract}
%dup: Principia.nw (Introduction)
{\em \principia} is a series of books explaining how things work in a
computer by describing with full details all the source code of all
the essential \plan programs used by a programmer: 
the kernel, the shell, the assembler, the linker, the C compiler, the editor,
the windowing system, the build system, etc.
Each program is covered by a separate book and explained using
the {\em literate programming} technique.
%
\plan thus becomes a teaching OS for students to learn deeply
about programming.

\principia is also another fork of \plan as well as a new distribution
that can be easily cloned, compiled, modified, and tested from Linux, macOS,
as well as Windows, which removes friction for students.
% QEMU 386 and Raspberry pi arm
% but can cross compile from amd64 or arm64 machines as hosts

\end{abstract}

\section{Introduction}

\plan didn't have the success it deserved. 
It was
innovative,
elegant,
powerful,
small,
and designed by great programmers.
%
Those great minds didn't just rethink the kernel, they rethinked
the whole operating system (OS) in a holistic manner with 
a kernel pushing the ``everything is a file'' \unix motto to
its limit~\cite{namespaces-plan9},
an integrated graphic and network stack,
a windowing system that could even run under itself,
a compact cross-compiling toolchain 
(with assemblers, linkers, C compilers, and debuggers
%and profilers
for most architectures),
minimalist C libraries,
a simpler build system and
shell,
and more.
% just missed browser :( and being OSS from day one before 1991, and VCS
%% sad it failed; Rob Pike then sad wrote "software research is irrelevant"


What is even more impressive is that those programs
contain only in the order of thousands lines of code (LOC).
%
[[rio]] for example, the \plan windowing system~\cite{rio-slides},
contains just 8 800 LOC and is arguably more poweful than
XOrg (an implementation of X~Window~\cite{x-window})
which contains millions LOC.
%
The X~Window program [[xterm]], which is just a terminal, not the
windowing system, contains already 80 000 LOC while [[rio]] contains
a built-in terminal in less than 1000 LOC.
% that's a 80x reduction! possible thx to namespace, /dev/cons, etc.
%coupling: Table 1 Total entry
In fact, with only 183 000 LOC, \plan implemented from scratch all
the major components of an OS. 


However, the Linux/GNU/Xorg OS won over \plan, partly because it
was the first open-source (OSS) system available.
% Arguably not as innovative, not as elegant, not as simple, but it won.
% Plan9 was Open source too, but a bit late.
%%History repeat itself ... 
%%Unix v6 was closed by AT&T Freebsd in prison for a long time.
%% Plan9 was closed, then inferno, then open source but late, and
%% really open sourced far later by plan9 foundation.
% Linux/GNU/Xfree86 nice to have robust open source Unix still
Unfortuntately, even if the source code is open, it is very hard to understand
most of this code because each component (e.g., the Linux kernel,
the [[bash]] shell, the GNU C library, [[gcc]], binutils, [[gdb]]) contains 
multiple orders of magnitude more code than \plan with millions LOC.
% Compare LOC rc vs bash. actually bash not millions but 180 000 LOC
%see-later: TABLE
This situation is sad, and potentially dangerous, because most
programmers rely on a giant software stack that very few people (if any)
fully understand.
The situation is even worse for students who don't have any path
to understand deeply this software stack.

Enter {\em \principia}, a new project to repurpose \plan
from an old research OS to a new teaching OS
(OS in a general sense: not just the kernel but the whole
software stack).
%
%dup: Principia.nw (intro)
Concretely, \principia is a series of books explaining how things work in a
{computer} by describing with full details all the source code of all
the essential \plan programs used by a programmer.
Each program will be covered by a separate book. 

%dup: Principia.nw (intro)
The books not only describe the implementations of those programs,
{\em they are} the implementations of those programs. Indeed,
each program in \principia comes from a 
{\em literate program}~\cite{lp-book}, 
which is a document containing both source code and documentation
and where the code is organized and presented in a way 
to facilitate its comprehension.
The actual code and the book are derived both automatically from this literate
program.
% AS explained later in Section Y

%Understand essence, useful for many things.

The rest of the article is organized as follows.
First, I present the full list of \principia books in Section~\ref{sec:bookset}
and give a brief overview of literate programming in Section~\ref{sec:lp}.
Then, in Section~\ref{sec:new-fork} I explain the motivation for a new \plan fork 
and describes its content and key features. Section~\ref{sec:new-distribution}
introduces the associated new distribution and highlights its main characteristics.
Finally, I discuss future work in Section~\ref{sec:future-work}
and related work in Section~\ref{sec:related-work}.

% TOC:
% - Principia softwarica book set:
% - Literate programming intro
% - Yet another plan9 repo. 
% - Yet another distribution
% - Modern software engineering practice
% - Future and related work.

\section{The bookset}
\label{sec:bookset}

%dup: Principia.nw intro
Similar to {\em Principia Mathematica}~\cite{principia}, 
which is a series of books
covering the foundations of mathematics, the goal of \principia
is to cover the fundamental programs.
%
Those programs are mostly all {\em meta programs}, which are
programs in which the input and/or output are other programs.
For instance, the kernel is a program that {manages} other programs;
the compiler is a program that {generates} other programs.
%
Those programs are also sometimes referred as {\em system software},
in opposition to {\em application software} (e.g., spreadsheets,
word processors, email clients), which is not covered by \principia.

Table~\ref{tab:books} presents the full list of books in \principia
and the corresponding \plan programs or libraries they document.

\begin{table}[htbp]
\centering
\begin{tabular}{p{2.2cm} l p{2.5cm} r r r}
\hline
\textbf{Category} & \textbf{Book} & \textbf{Program(s)} & \textbf{LOC} & \textbf{LOE} & \textbf{Pages} \\
\hline

\multirow{3}{=}{\\Core system}
  & Kernel
  & \texttt{9pi}
  & 35000 & 3200 & 732 \\

  & Core libraries
  & \texttt{libc libregexp libthread}
  & 19000 & 1600 & 438 \\
%TODO: libbio? libstring? 
%TODO: libmp?
%TODO? add libflate? or add in Utilities.nw next to gzip?

  & Shell
  & \texttt{rc}
  & 6500 & 1700 & 166 \\
\hline

\multirow{3}{=}{Development\\ toolchain}
  & C compiler
  & \texttt{5c libcc}
% there is no libcc really, but just cc
  & 18500 & 1900 & 471 \\

  & Assembler
  & \texttt{5a}
  & 3600 & 4400 & 176 \\

  & Linker
  & \texttt{5l}
  & 7500 & 5400 & 296 \\
%skipped: 5i
%skipped: ocamlc, ocamlopt
%skipped: olex, oyacc
\hline

\multirow{4}{=}{\\Developer\\tools}
  & Editor
  & \texttt{ed}
  & 1600 & 200 & 45 \\
%skipped: editor efuns

  & Build system
  & \texttt{mk}
  & 4350 & 4050 & 197 \\

  & Debuggers
  & \texttt{db acid strace libmach}
  & 13100 & 1000 & 321 \\

  & Profilers
  & \texttt{prof time kprof stats iostats}
  & 3900 & 350 & 102 \\
%TODO? maybe skip profilers?
%skipped: ogit
%skipped: troff
\hline

\multirow{2}{=}{\\Graphics}
  & Graphics stack
  & \texttt{/dev/draw libdraw libmemdraw libmemlayer}
  & 18500 & 3400 & 507 \\
% 10k+ (kernel) + 16k
% also kernel/devices/screen/ and some windows/apps/
% add libimg?

  & Windowing system
  & \texttt{rio libframe libcomplete libplumb}
  & 8800 & 4000 & 289 \\
%skipped: libpanel
\hline

\multirow{1}{=}{Networking}
  & Network stack
  & \texttt{/dev/net libip lib9p}
  & 18300 & 4800 & 457 \\
% 23k+ (kernel) + 51k
% skipped Network_apps.nw which is additional 60000 LOC, hmm
%skipped: mmm
\hline

\multirow{1}{=}{Utilities}
  & CLI utilities
  & \texttt{cat ls grep sed diff tar gzip \ldots}
  & 23900 & 650 & 493 \\
% also bc, hoc, awk, etc

\hline
\textbf{Total: } & & & 182550 & 36650 & 4690 \\
%origin: the total was computed by chatGPT by copy pasting table
% and asking to compute total
\hline

\end{tabular}
\caption{%
\principia Books and Their Statistics.\\
{\footnotesize
(\textbf{LOC} = lines of code;
 \textbf{LOE} = lines of explanation;
 \textbf{Pages} = number of typeset pages)
}
}
\label{tab:books}
\end{table}

% explain LOE

% ARM (and raspberry pi) focus. simpler than 86, and goal is understand essence,
% not useless detail. But still real arch! not toy arch!

% ARM in most phones today and in raspberry pi!
% in fact kernel 9pi. Great work by Richard Miller not in original plan9.
% Raspberri pi great for teaching context.

%10 000 LOC is explainable in a book of a reasonable size!
%bash for example? vs rc ? gcc vs 5c? 9pi vs Linux?
%millions LOC would require 400 books of 300 pages, just for bash :)

%say later? in Future work?
% As can see, unfinished, still lots of work.
% I started in 2014 but was on pause between 2019 and 2024,
% and resume almost full-time on it mid 2025.

%dup: Principia.nw
The \principia programs form together the minimal foundation
on top of which all applications can be built. Even though there are
many books in the series, I still think it is the
minimal foundation. Indeed, it is hard to remove any of those programs
because they depend on each other.
%
First, you need to rely on a kernel (hence the name), but
the shell and the C library are also essential. 
However, because those programs
are coded in C and assembly, you also need a C compiler and
an assembler, and because source code is usually split in many
files you also need a linker.
%The C compiler itself usually uses DSLs like Lex and Yacc.
%\l which are themselves written in C and actually use also lex and yacc themselves
To write all this code in the first place you need an editor.
Then, with so many source files you need
a build system to automate and optimize the compilation process.
Because the programs I just mentioned inevitably have bugs
or non optimal parts, you will need a debugger and a profiler.
\l maybe skip profiler
Finally, nowadays
it is inconceivable to not use a graphical user interface
and to not work with multiple windows opened at the same time.
In the same way it is also not conceivable to work
in isolation; programmers collaborate with each other,
especially via the Web.
This means you need a graphical and networking stack as well
as a windowing system.
% and a Web browser.
As I said earlier, it is hard to remove any of the programs
from the series.


\section{Literate programming crash course}
\label{sec:lp}

%dup: Principia.nw
Source code is the ultimate explanation for what a program does.
%
However, showing pages and pages of listings in an appendix, 
as done for instance in the Minix book~\cite{minix},
even when this appendix is preceded by documentation chapters, is arguably not
the best way to explain code. The code and its documentation
should be mixed together, as done for instance in the Xinu book~\cite{xinu},
so one does not have to switch back and forth between
an appendix and multiple chapters.


%dup: Principia.nw
{\em Literate programming}~\cite{lp-book} is a technique invented by
Donald Knuth to make it easy to mix code and documentation
in a document in order to better explain programs (and arguably also
to better develop programs). 
Such documents are called {\em literate programs}. All \principia
programs are literate programs.

Table~\ref{tab:foo.nw} presents a toy literate program on the
left and its rendered output on the right to illustrate the
main features of Noweb~\cite{noweb-ieee}\furl{http://www.cs.tufts.edu/~nr/noweb/},
the literate programming tool used for \principia.
%said-later: really syncweb now
% Web comes from original Knuth terminology, "a web of chunks" and original program
% for C was called cweb.
% Main feature of Noweb is not lang-specific and work for many programming
% languages hence noweb.
% Then tangle/weave terminology because web of chunks

\begin{table}[htbp]
\centering
%old: 0.48\textwidth
\begin{tabular}{|p{7cm}|p{7cm}|}
\hline
[[ToyKernel.nw]] excerpt & \textbf{\LaTeX~output} \\
\hline
\begin{minipage}[t]{\linewidth}
\VerbatimInput{ToyKernel.nw}
\end{minipage}
&
\begin{minipage}[t]{\linewidth}
#include "ToyKernel.nw"
\end{minipage}
\\
\hline
\end{tabular}
\caption{Noweb Source and Rendered Output.}
\label{tab:foo.nw}
\end{table}
% not shown, [<foo()>] syncweb refs, but let's keep it simpler

Note that literate programming is different from using 
{API documentation generators} such as 
javadoc\furl{http://www.oracle.com/technetwork/articles/java/index-jsp-135444.html} or 
doxygen\furl{http://www.stack.nl/~dimitri/doxygen/}.
%
Noweb does not provide the same kind of services. 
%
Indeed, literate programming allows programmers to explain their
code in the order they think the flow of their thoughts and their code would
be best understood, rather than the order imposed by the compiler.

Literate programming
allows, among other things, to explain the code piece by piece, with the
possibility to present a high-level view first of the code,
to switch between {top-down} and {bottom-up} explanations, and to
separate {concerns}.
%
For instance, the [[Proc]] data structure of the \plan kernel, which
represents some information about a process, is a huge structure
with more than 90 fields. Many of those fields are used only
for advanced features of the kernel. The C compiler imposes
to define this structure in one place, however
Noweb allows to present this structure piece by piece, gradually, in different
chapters. One can show first the code of the structure with 
the most important fields,
and delay the exposition of other fields to advanced chapters.
This greatly facilitates the understanding of the code, by not
submerging you with too much details first.

In the same way, the [[main()]] function in most
programs is rather large and mixes together many concerns:
command line processing,
error management,
debugging output,
optimizations,
and usually a call to the main algorithm.
%
Showing in one listing the whole function would hide behind
noise this call to the main algorithm. The main flow of the program though
is arguably the most important thing to understand first.
Using literate programming,
one can show code where the most important parts are highlighted, and where
other concerns are hidden and presented later. 

In fact, I spent lots of time during the writing of the \principia books
in transforming the \plan programs in literate
programs, and in reorganizing again and again the \plan code to find
the best way, the best order, the best separation of concerns
to make it easier for the reader to understand the code.

%tangle and weave
Here are the Noweb commands illustrating how to automatically generate the code
from the literate program:

\begin{verbatim}
$ notangle -Rproc.h ToyKernel.nw > proc.h
$ notangle -Rkernel.c ToyKernel.nw > kernel.c
$ cat proc.h
struct Proc {
  int pid;
  Lock l;
  int cnt;
} 
\end{verbatim}
%said-later:
% actually syncweb! so some extra marks in the code (and also nice index, and nice -lpizer)
% syncweb -lang C -md5sum_in_auxfile -less_marks ToyKernel.nw proc.h

\section{Yet another \plan fork}
\label{sec:new-fork}


% had to modify plan9 code, to "lpize" it
% create literate program out of the code
%said-later? used tool lpizer for that but no time to explain 
%So fork.
\url{https://github.com/aryx/principia-softwarica}

% git URL. Yet another fork. 
%said-later: git is good

% did lots of small modifs actually to make it easier to explain it
% (easier to fix and simplify that keep old code that require complicated
% explanations sometimes).
% (even found bugs as I was explaining it, see 9fans old email :) )

%   Actually simplified the code a bit sometimes, so easier to explain!
%   Some nice improvments IMHO. Found also bugs! as I was explaining
%   and could not explain :)


%trans:
% reordered also dirs, files, even functions sometimes.
%   code reorg, more easily "discoverable" dirs (5a cryptic, it's
%   an assembler/). Show output of tree command in 3 columns.

% literate programs. Subset of plan9.


\begin{figure}
\centering
{\footnotesize
\begin{verbatim}
.
|-- assemblers/            |-- kernel/                  |-- mkfiles/
|   |-- 5a/                |   |-- arch/                |   |-- 386/
|   |-- 8a/                |   |-- concurrency/         |   |-- arm/
|   |-- data2s.c           |   |-- console/             |   |-- mkdirs
|   |-- Assembler.nw       |   |-- devices/             |   |-- mkfile.proto
|   `-- mkfile             |   |-- files/               |   |-- mklib
|-- builders/              |   |-- filesystems/         |   `-- mkone
|   |-- Builder.nw         |   |-- init/                |-- mkfile-target-pc
|   |-- mk/                |   |-- interrupts/          |-- mkfile-target-pi
|   `-- mkfile             |   |-- Kernel.nw            |-- networking/
|-- compilers/             |   |-- mkfile               |   |-- arp/
|   |-- 5c/                |   |-- network/             |   |-- dhcp/
|   |-- 8c/                |   |-- processes/           |   |-- ftp/
|   |-- cc/                |   `-- syscalls/            |   |-- http/
|   |-- Compiler.nw        |-- lib_core/                |   |-- ip/
|   |-- cpp/               |   |-- libbio/              |   |-- mkfile
|   `-- mkfile             |   |-- libc/                |   |-- ndb/
|-- debuggers/             |   |-- Libcore.nw           |   |-- Network.nw
|   |-- acid/              |   |-- libthread/           |   |-- snoopy/
|   |-- db/                |   `-- mkfile               |   `-- telnet/
|   |-- Debugger.nw        |-- lib_graphics/            |-- profilers/
|   |-- libmach/           |   |-- Graphics.nw          |   |-- iostats/
|   `-- mkfile             |   |-- libdraw/             |   |-- mkfile
|-- Dockerfile             |   |-- libimg/              |   `-- Profiler.nw
|-- docs/                  |   |-- libmemdraw/          |-- shells/         
|   |-- articles/          |   |-- libmemlayer/         |   |-- mkfile      
|   `-- iwp9/              |   `-- mkfile               |   |-- rc/         
|-- dosdisk.img            |-- lib_networking/          |   `-- Shell.nw    
|-- editors/               |   |-- lib9p/               |-- utilities/      
|   |-- ed/                |   |-- libip/               |   |-- archive/    
|   `-- mkfile             |   `-- mkfile               |   |-- byte/       
|-- include/               |-- lib_strings/             |   |-- calc/       
|   |-- libc.h             |   |-- libflate/            |   |-- compare/    
|   |-- ...                |   |-- libregexp/           |   |-- files/      
|   `-- u.h                |   |-- libstring/           |   |-- mkfile      
|-- linkers/               |   `-- mkfile               |   |-- pipe/       
|   |-- 5l/                |-- Makefile                 |   |-- process/    
|   |-- 8l/                |-- mkconfig.pc              |   |-- text/       
|   |-- Linker.nw          |-- mkconfig.pi              |   |-- time/       
|   `-- mkfile             |-- mkfile                   |   `-- Utilities.nw
|-- readme.txt             |-- mkfile-host-Cygwin       `-- ROOT/       
`-- windows/               |-- mkfile-host-Linux            |-- 386/    
    |-- libcomplete/       |-- mkfile-host-macOS            |-- arm/    
    |-- libplumb/          `-- mkfile-host-Plan9            |-- lib/    
    |-- mkfile                                              |-- rc/     
    |-- rio/                                                |-- tests/  
    `-- Windows.nw                                          `-- usr/    
\end{verbatim}










%origin: the content above was generated by chatGPT using some copy-pasted
% output from tree -L 2 and asking to re-layout in 3 columns
}
\caption{%
\url{https://github.com/aryx/principia-softwarica} Layout.\\
(as generated by [[tree -L 2 -F]])
}
\end{figure}

% show generated code by noweb on previous example.
% actually syncweb!! so can edit both generated code and propagate
% back to .nw file, or modify .nw and "weave" to regenerate the code.
% syncweb also lpizer, so could first draft out of code.

%   Diff with 9front, plan9port, etc. is focus on code explanations!


\section{A new \plan distribution}
\label{sec:new-distribution}

% Teaching context imposed to create a new plan9 distrib easier
% to install and play with.
% What is the problem with current situation and classic plan9 distros?

% - cross compiled from Linux/macOS/Windows! quite different from other
%   (thx to goken)
% - build vfat (DOS) images for x86 (QEMU) and arm (Raspberri pi) that
%   can be easily explored and tweaked
%So no CDs. no .iso
%one command to rule them all! mk; mk all; mk kernel; mk run! 
% compile, package, make distrib, run with qemu\cite{}\furl{qemu.org}

% put Dockerfile? talk about docker, say actually would be trivial
% to implement docker-like in plan9 thx to namespace, more elegant
% but what we have in the cloud, in github, infra is Linux
% and macOS and Windows, and they all can talk docker and it's
% quite convenient to have reproducible builds and tests!

% Cross compiled from goken (see WIP, can't talk too much about it,
% but essentially kencc, and yet another plan9 fork, lol)
% from Linux/macOS/Windows (and also Docker)
%said-later: docker stuff
% gcc-binutils or clang-LLVM.
% Not trivial, 64bits new arch, long vs int, but separate paper.
% Share code with principia but
% separate package because as its own use.

% why not plan9port? can also build on Linux/macOS/Windows
% but no compiler in it!
% why not inferno-os kencc? well yes, that's what I did, but needed an update.

%   make new distrib easily. Easy to experiment. Got trouble 10 years ago
%   to test, with ISO CDs, qemu pbs. slow down adoption.
%   now qemu friendly, and raspberry pi friendly! great for teaching context!
%   cheap to buy. Greak work by Richard Miller (but again not easy to test
%   currently).
%   Incredible ease and speed! modify syscall order, recompile
%   everything, test GHA, it works! and can do that from Linux/macOS/Windows,
%   so easier to experiment and adopt! especially in teaching context

%\section{Modern practice}
%alt: Quality of life improvements:
%alt: A modern distribution

% Modern does not always mean better, and very often old plan9
% was better than modern tools, still there are a few things
% that are convenient nowadays, even if arguably not most elegant:

% git and github! easy collaboration (9front too).
% docker build infra.
% GHA (just run docker build)

% C ref_xxx, error1, abuse int/string.
% less globals, better split files, less mutual deps (thx codegraph)

\section{Future work}
\label{sec:future-work}

%dup?: sec:bookset?
%current status in table 2 in section 2 show still lots of work.
% many books have very few LOE so ongoing work.

% not self-hosted yet, build principia from other OS (which has
% its advantage in teaching context), and with separate goken.

\section{Related work}
\label{sec:related-work}

%dup: Principia.nw
There are already lots of books explaining how computers work, explaining
the concepts, theories, and algorithms behind programs such as
kernels or compilers. There are also a few books about debuggers. However,
all those books rarely explain everything with full details, which
is what source code is all about. 
%
There are a few books that
include the whole source code of the program
described, for instance, the books about 
Minix~\cite{minix}, XINU~\cite{xinu}, or LCC~\cite{lcc}.
%said-later: Oberon, Software Tools, with LP: Tex the program, mmixware, 
However, those books cover only
a few essential programs, and mostly always either
the kernel or the compiler. Moreover, they do not form a coherent set.


Here are a few teaching operating systems that I originally considered
possible candidates for \principia, but which I ultimately discarded:
\n helps to appreciate even more how good our plan9 choice is


%dup: Principia.nw
\begin{itemize}

%history:
\item \unix V6 (Ken Thompson et al.)
\furl{http://minnie.tuhs.org/cgi-bin/utree.pl},
\n tuhs = the unix heritage society
fully commented in the infamous book by John Lions~\cite{lions},
or its modern incarnation xv6
\furl{http://pdos.csail.mit.edu/6.828/2014/xv6.html},
are great resources to fully understand a \unix kernel.
However, this kernel is too simple; there is no support for graphics
or networking for instance.
\l it's a full OS, see unix-history-repo, 165 000 LOC for V7 in /sys/src

\item XINU (Douglas Comer)
\furl{http://minnie.tuhs.org/cgi-bin/utree.pl?file=Xinu7},
fully documented in two books~\cite{xinu,xinu2},
has a network stack, but the kernel
is still too simple with no virtual memory for instance.
\l and has multi processor support?
\t new edition in 2015! seems to have virtual memory now

\item Minix (Andrew Tannenbaum et al.)
\furl{http://minnie.tuhs.org/cgi-bin/utree.pl?file=Minix1.1},
also fully documented~\cite{minix},
is fairly small, but it is just a kernel. Minix does not provide
for instance its own windowing system; it relies instead on X Window,
which is far more complicated than the \plan windowing system.
\l it has a compiler though, ack, but was open sourced only in 2003

\item Hack (Noam Nisan and Shimon Shocken)
\furl{http://www.nand2tetris.org/}
is a toy computer introduced in the excellent
book {\em The Elements of Computing Systems}~\cite{tecs}.
This book is great for understanding processors, assemblers,
and even compilers, but the kernel part is really too simple.
\n and actually no code, only code is the different emulators and debuggers

\item MMIX (Donald Knuth)
\furl{http://www-cs-faculty.stanford.edu/~uno/mmix-news.html}
and its ancestor MIX
are computers designed by Donald Knuth
and used in his classic book series 
{\em The Art of Computer Programming}~\cite{taocp}.
Donald Knuth also wrote a book using literate programming, 
{\em MMIXware}~\cite{mmixware},
to explain the full code of the MMIX simulator and assembler.
%
However, similar to Hack, very few programs have been written for
this machine. For instance, the book assumes the presence of a kernel
called NNIX, but nobody has ever written it.
\n but as Knuth told me, gcc has been ported to mmix as well as Linux

\item STEPS (Alan Kay et al.)
%TODO: \cite{} the first and last paper
\furl{http://vpri.org/html/writings.php}
was a project to reinvent from scratch programming.
It had a far more ambitious goal than \principia:
write a full OS in 20 000 LOC. It was
unfortunately never finished.
\l our kernel book is 30 000 LOC, and it's just the kernel (and actually not all of it), so hmmm
\l seems more oriented to apps though, minimal OS, and single lang I think
%\item Squeak (Alan Kay et al.),%\furl{http://squeak.org/}


\item Oberon (Niklaus Wirth et al.)
\furl{http://www.projectoberon.com/} 
is a kernel,
compiler, 
and windowing system 
designed from scratch. It is
a great OS, very compact, and fully documented in a 
book~\cite{project-oberon}.
%
However, it imposes strong restrictions on the programmer:
only applications written in the Oberon programming language
can be run. 
This simplifies many things, 
\n singularity was a bit like that too
but OS like
\unix (and \plan) are more universal; they
can run any program in any language, as long as the program 
can be interpreted or compiled into a binary.
\l  javascript emulator: http://schierlm.github.io/OberonEmulator/
\n new edition in 2014!
\t see recent articles about SmallTalk/Unix reunion in my Download

\item TempleOS (Terry A. Davis)
\furl{http://www.templeos.org/} is an OS
single handedly created over a decade. It contains a kernel,
a windowing system, a compiler for a dialect of C, and
even some games.
It has graphics capabilities but there is no network support.

\end{itemize}

Another candidate for \principia was the combination of
the GNU system\furl{http://www.gnu.org/}, 
\l (Richard Stallman et al.)
the Linux kernel\furl{http://www.kernel.org/}, and
the X Window graphical user interface Xorg\furl{http://www.freedesktop.org}.
%
However, GNU/Linux/Xorg together is far bigger than \plan.
If you take the source code of 
the Linux kernel, 
the GNU C library ([[glibc]]),
the [[bash]] shell,
the GNU C compiler ([[gcc]]),
the GNU assembler ([[gas]]) and linker ([[ld]]) part of the [[binutils]] package,
%the GNU Lex and Yacc clones ([[flex]] and [[bison]]),
the Emacs editor, 
GNU [[make]],
the GNU debugger ([[gdb]]), 
the GNU profiler ([[gprof]]),
and the X Window system ([[Xorg]]), you will get
orders of magnitude more source code than \plan, even though
\plan provides in essence the same core services.
\l see Linux From Scratch excellent book showing how to install from
\l  source all those packages (and also Beyond Linux From Scratch)
%
In fact, almost all of the programs above use {\em individually}
more source code than the {\em whole} \plan system.
% bash maybe smallest? or make? bash already 180 000 LOC I think

Of course,
the Linux kernel contains thousands of specific device drivers,
[[gcc]] handles a multitude of different architectures, and 
[[Xorg]] supports lots of graphic cards.
%
All of those things could be discarded when
presenting the {\em core} of those programs. However, their core is still far
bigger than the equivalent core in \plan programs.
\n Linux 1991, Plan9 1992 (but open source only in 2000), paper in 1990
%TODO: show gcc for instance with arm- part already 50 000 LOC!
% same for clang/llvm

% too many other to list here, see the comment in Principia.nw
% in Related work section



\section{Conclusion}
\label{sec:conclusion}

%dup: Principia.nw
I hope the \principia books will greatly consolidate
student computer science knowledge and give students a better and
more complete picture of what is going on in a computer.
%
Hopefully, it will also give more exposure to the hidden gem
that is \plan code; this code is small, elegant, powerful, open source, and
was written by incredible programmers who deserve to have
their art pieces (their programs) fully exposed.

%dup: Principia.nw
I hope those books will answer many students questions, 
even those that seem very simple at first
such as ``What happens when the user type [[ls]] in a terminal window?''.
% or what happens when type C-d in program reading stdin (e.g., ocaml interpreter)
The answer to this question
involves many software layers (the shell,
the C library, the kernel, the graphics stack, and the windowing system)
and involves actually a non-trivial amount of code.
% still, doable! On Linux would be super complicated with pty, tty
%TODO: copy discussion of Principia.nw on pty and elegance of plan9!
% or too big for conclusion?

\bibliography{../latex/Principia}
\bibliographystyle{alpha}

\end{document}
