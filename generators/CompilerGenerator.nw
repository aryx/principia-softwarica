\documentclass[twocolumn]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse % see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things:

%thx to codemap/codegraph:

%thx to this manual, better understand lex/yacc:

%history LP-ization:
% - skeleton, mostly copy paste of Template.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
% - TODO read Extra section, identify concepts, first TOC
% - TODO distribute parts of the file before
% - TODO nullify, boolify, typeify,    scheckify
% - TODO aspecify advanced features!
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\iffinal
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\fi
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
\usepackage{cleveref} %\cref
\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}
 %\usepackage[margin=0.5in]{geometry}
 %  but eat the bottom when very low
 %\usepackage{fullpage} is deprecated 
 % => do the more manual below:
 \addtolength{\oddsidemargin}{-.850in}
 \addtolength{\evensidemargin}{-.850in}
 \addtolength{\textwidth}{1.70in}
 \addtolength{\topmargin}{-.850in}
 \addtolength{\textheight}{1.70in}
%\usepackage{minitoc}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% used for forward decl, pragmas, func decl, extern decl, stats, #ifdef,
% debugging macros

%\setcounter{tocdepth}{1}

%******************************************************************************
% Title
%******************************************************************************

\begin{document}

\title{
{\Huge 
Principia Softwarica: Lex and Yacc
}\\
{version 0.1}
}
% for once it's not really Plan9, the lex and yacc seems really to
% come from unix with a small port to plan9, as opposed to the other
% document I've already written which are really Plan9 software

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}\\
\\
with code from\\
Someone
}
% Erik scmidt, xavier leroy
% jonhson, corbett

\maketitle 
\onecolumn
\hrule
\begin{quote}
    Copyright \copyright{} 2015 Yoann Padioleau \\
    Permission is granted to copy, distribute and/or modify this document,
    except all the source code it contains, under the terms of the GNU Free
    Documentation License, Version 1.3.
\end{quote}
\hrule

%CONFIG: \dominitoc

\iffinal
\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\twocolumn
\tableofcontents
\endgroup
\else
\tableofcontents
\fi

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

\section{Motivations}

The goal of this book is to present in full details the source code of
Lex and Yacc.
Why? Because I think it makes you a better programmer if
you fully understand how things work under the hood.

Here are other candidates that were considered but ultimately discarded:
\begin{itemize}
\item Flex and Bison
\item Antlr
\end{itemize}

% Berkeley Yacc
% Unix Lex?
% go yacc! a port of yacc.c to go by go authors, might be interesting
% to contrast C and Go

% ocamllex: 1000 LOC vs the 3000 of plan9 lex
% ocamlyacc: 6000 LOC, vs the 3000 of plan9 yacc
% menhir? 21 000 LOC of ocaml, hmm bigger than my fork-ocaml, lol

% see also sed/awk? 

\section{Getting started}

\section{Requirements}

% you need to know about lex & yacc :) because we gonne use
% lex and yacc to explain the code of lex and yacc. hmm.

%(* To generate directly a NFA from a regular expression.
%   Confer Aho-Sethi-Ullman, dragon book, chap. 3 *)

\section{About this document}
#include "../docs/latex/About.nw"

\section{Copyright}

Most of this document is actually source code from Plan9, so
those parts are copyright by Lucent Technologies Inc.
The prose is mine and is licensed under the GNU Free Documentation
License.

<<copyright ocamllex>>=
(***********************************************************************)
(*                                                                     *)
(*                           Objective Caml                            *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)
@

\section{Acknowledgments}


\chapter{Overview}

\section{Lex and yacc principles}

% DSL! The first ones!

% there is usually a lex/yacc interface they need to agree on,
% but actually lex can also work without yacc, and yacc without lex.

\section{[[lex]] services}

<<[[Main.main()]] print lex usage if wrong number of arguments>>=
if Array.length Sys.argv != 2 then begin
  prerr_endline "Usage: ocamllex <input file>";
  exit 2
end;
@

\section{[[yacc]] services}

\section{Code organization}

\section{Software architecture}

\section{Bootstrapping}

%###############################################################################

\chapter{Lex}

\section{Core data structures}

\subsection{Regular expression}

<<type Syntax.regular_expression>>=
type regular_expression =
    Epsilon
  | Characters of int list
  | Sequence of regular_expression * regular_expression
  | Alternative of regular_expression * regular_expression
  | Repetition of regular_expression
@


\subsection{Abstract syntax tree}

<<type Syntax.location>>=
type location =
    Location of int * int
@
% header/trailer/action slice, int = charpos

<<type Syntax.lexer_definition>>=
type lexer_definition =
    { header: location;
      entrypoints: (string * (regular_expression * location) list) list;
      trailer: location 
    }
@

\subsection{Intermediate regexp format}

<<type Lexgen.regexp>>=
(* Deep abstract syntax for regular expressions *)

type regexp =
    Empty
  | Chars of int
  | Action of int
  | Seq of regexp * regexp
  | Alt of regexp * regexp
  | Star of regexp
@

<<type Lexgen.lexer_entry>>=
type lexer_entry =
  { lex_name: string;
    lex_regexp: regexp;
    lex_actions: (int * Syntax.location) list }
@

\subsection{Automata}

<<type Lexgen.automata_entry>>=
(* Representation of entry points *)

type automata_entry =
  { auto_name: string;
    auto_initial_state: int;
    auto_actions: (int * Syntax.location) list }
@

<<type Lexgen.automata>>=
type automata =
    Perform of int
  | Shift of automata_trans * automata_move array
@
% usually automata array!
%val make_dfa: Syntax.lexer_definition -> automata_entry list * automata array

<<type Lexgen.automata_trans>>=
and automata_trans =
    No_remember
  | Remember of int
@

<<type Lexgen.automata_move>>=
and automata_move =
    Backtrack
  | Goto of int
@

\subsection{Optimised compacted automata}

<<type Compact.lex_tables>>=
(* Compaction of an automata *)

type lex_tables =
  { tbl_base: int array;                 (* Perform / Shift *)
    tbl_backtrk: int array;              (* No_remember / Remember *)
    tbl_default: int array;              (* Default transition *)
    tbl_trans: int array;                (* Transitions (compacted) *)
    tbl_check: int array }               (* Check (compacted) *)
@
%val compact_tables: Lexgen.automata array -> lex_tables

\subsection{Runtime lexbuf}


<<type Lexing.lexbuf>>=
(* The run-time library for lexers generated by camllex *)
(* The type of lexer buffers. A lexer buffer is the argument passed
   to the scanning functions defined by the generated scanners.
   The lexer buffer holds the current state of the scanner, plus
   a function to refill the buffer from the input. *)
type lexbuf =
  { refill_buff : lexbuf -> unit;

    mutable lex_buffer : string;
    mutable lex_buffer_len : int;

    mutable lex_abs_pos : int;
    mutable lex_start_pos : int;
    mutable lex_curr_pos : int;
    mutable lex_last_pos : int;

    mutable lex_last_action : int;
    mutable lex_eof_reached : bool 
  }
@


\section{[[main()]]}

<<toplevel Main._1>>=
let _ = Printexc.catch main (); exit 0
@


<<function Main.main>>=
let main () =
  <<[[Main.main()]] print lex usage if wrong number of arguments>>
  let source_name = Sys.argv.(1) in
  let dest_name =
    if Filename.check_suffix source_name ".mll" 
    then Filename.chop_suffix source_name ".mll" ^ ".ml"
    else source_name ^ ".ml" 
  in
  let ic = open_in source_name in
  let oc = open_out dest_name in
  let lexbuf = Lexing.from_channel ic in
  let def =
    try
      Parser.lexer_definition Lexer.main lexbuf
    with exn ->
      close_out oc;
      Sys.remove dest_name;
       <<[[Main.main()]] report error exn>>
      exit 2 in
  let (entries, transitions) = Lexgen.make_dfa def in
  let tables = Compact.compact_tables transitions in
  Output.output_lexdef ic oc def.header tables entries def.trailer;
  close_in ic;
  close_out oc
@


<<signature Lexgen.make_dfa>>=
(* The entry point *)

val make_dfa: Syntax.lexer_definition -> automata_entry list * automata array
@

<<signature Compact.compact_tables>>=
val compact_tables: Lexgen.automata array -> lex_tables
@


<<signature Output.output_lexdef>>=
(* Output the DFA tables and its entry points *)

val output_lexdef:
      in_channel -> out_channel ->
      Syntax.location (* header *) ->
      Compact.lex_tables ->
      Lexgen.automata_entry list ->
      Syntax.location (* trailer *) ->
      unit
@


\section{Lexing}
% :) self-reference

\section{Parsing}

\section{Compiling}

% make_dfa

\section{Optimizing}

% compact_tables

\section{Generating}

% output_lexdef

\section{Running}

\chapter{Yacc}

\chapter{Conclusion}

\appendix

\chapter{Debugging}

\chapter{Error Managment}

<<[[Main.main()]] report error exn>>=
(match exn with
  Parsing.Parse_error ->
    prerr_string "Syntax error around char ";
    prerr_int (Lexing.lexeme_start lexbuf);
    prerr_endline "."
| Lexer.Lexical_error s ->
    prerr_string "Lexical error around char ";
    prerr_int (Lexing.lexeme_start lexbuf);
    prerr_string ": ";
    prerr_string s;
    prerr_endline "."
| _ -> raise exn
);
@

\chapter{Libc}

\chapter{Extra Code}

\ifallcode
#include "CompilerGenerator_extra.nw"
\fi

\chapter{Changelog}
\label{sec:changelog}

\chapter{Glossary}
\label{sec:glossary}

\begin{verbatim}
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{section}{Index}

%\chapter{References} 
\addcontentsline{toc}{section}{References}

\begin{thebibliography}{99}

\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming}, 
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb}, 
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison}, 
\url{http://padator.org/software/project-syncweb/readme.txt}

\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
