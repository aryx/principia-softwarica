# -*- org -*-
# motivations: Knuth page! HN entries showing interest! GoT books! STEPS video? 
# motivations: at least I was able to make xix and goken from all those books

* TODO in changes.txt

- pi2 (and qemu?), pi4 (arm64)
- riscv support orange pi (and tinyemu?)
- latte pc (amd64?)

** test infra
- add shell.nix
- add test infra to check for regressions

* Last

** Big plan
# testinfra, compile plan9 under plan9, move/merge with goken, pi2, RISCV support
# and later try get 9k kernel and more recent code from 9front

** Last1

*** pi2 target and finish bcm port to raspberry pi 2
test on real hardware so then can try and hope to use qemu -M raspi2b
and then run test infra for ARM too!

*** test_386.rc test infra v0
special End of test mark and script watchdog

*** test_arm.rc test infra v0
can run manually at first on raspberry pi1
and later can try qemu -M raspi2b


*** less: add libflate to Libcore.nw (fix 'lpizer -lang c' first)
and regenerate Libcore.pdf

*** mk sync for builders/ shows some weird "Not consumed" warning
probably worth fixing!

*** why error in regexec.c didn't trigger its recompilation?
why it did still generate a regexec.8 ??

pb with goken mk/rc or kencc mk/9base-rc ? or both?

*** test network for plan9 under qemu
ip/ipconfig
ndb/dns -r

cat /net/ndb
ndb/dnsquery
> www.google.com
works!!

need special qemu flags? -inet??

see archive.org C-s on ndb/dns

*** compile plan9 under plan9
try go back in time for 8a/8c/8l to point where it was still working!
(and same for 5a/5c/5l)

maybe only pb is 5a/5c/5l? that's the one I actually heavily modified.
8a/8c/8l should be better?

*** -----------------------------------------------------

*** RELAX principia: skip_list.txt -> .codemapignore

*** RELAX read past colbert reports of 2017
mention of regressions in 5a/5c/5l?

I saw the regression mentioned in reports in 2018 and 2019 but no work
on actually fixing it.

*** LATER run it basic tests in GHA to check for regressions
(e.g., regressions in compiler, in rio, in rc/mk, etc.)

*** still? get toolchain working again under plan9
or restart from kencc or even better goken! but need re-lpize then ...
maybe better do both, get toolchain working under plan9, and
work from goken too

*** LATER: riscv, raspberry pi 2, raspberry pi 4 (arm64)


* Big plans

** 2025 updated plans

# Big plan:
#   * xix (principia in OCaml):
#     Originality announcement on discuss.ocaml.org and OPAM:
#     (1) education purpose: small LOC, LP syncweb, and principia-ml!
#     (2) capabilities: types, TCB?, and semgrep rules to enforce things
#     - RELAX SEMI mk/rc OCaml version (and C versions on principia-softwarica.org)
#     - lex/yacc OCaml version (need to finish yacc)
#     - FUN tiger and target asmcomp cmm (nice intermediate step to ocaml-light)
#     - FUN mincaml? (nice intermediate too?)
#     - ocaml-light
#         * LPized first bytecode compiler and runner
#         * LPIzed native and its cmm backend
#         * RELAX integrate and LPize zamcov as alternative to C bytecode runner
#       => full loop; we can understand all of mk/rc (lex, yacc, ocaml compiler)
#     - efuns minimal version (no tree-sitter), need repro/fix weird array bugs first
#     - RELAX ogit (and new LP) 
#     - games: elm-playground + physics 2D, 3D engine, doom, quake, rolling moon
#     ...
#     - gopad9cc: assembler/linker/compiler(macroprocessor) (5a/5l/5c and also amd64/arm64/riscv?)
#       use chatGPT more to transpile C original goken9cc code to OCaml? and follow
#       Rob/Russ strategy of exact byte matching with C code for generated objs/bins
#       (but first must deoptimize 5c while still got tests to pass so easier
#       then to port and compare to ocaml versions)
#     - ocaml-light for plan9, graphics bindings for plan9 draw, and rio in ocaml!
#     - kernel in ocaml (xv6 inspired first? and then plan9 inspired?)
#   * syncweb! need make it releasable on OPAM (maybe not lipizer/indexer but
#     at least the syncer at first)
#   * release efuns (full version and its LP)
#   * release codemap (and its LP), codegraph (and new LP)
#     - need remove semgrep-libs deps or release on OPAM semgrep-libs parts
#   * FUN xv6 x86/arm/riscv and tiger x86/arm/riscv (intermediate step to plan9 system)
#   * principia (in C):
#     - RELAX goken9cc: assembler, linker, compiler also arm64/riscv/wasm(?)
#     - builder, shell (now in goken9cc)
#     - debugger (ocamldebug too?), profiler (or move to plan9?)
#     ---- split goken vs fork-plan9 ----
#     - kernel, graphics, windows, widget
#     - networking, browser (mmm or browser engineering book port? js engine?)
#     - Database? internet servers? internet clients?
#     - games: doom
#     - troff, latex

# give principia books in 2025 more impact than in 2018 by:
#  - being available, installable, testable outside plan9
#    (even if complicates a bit the code; tradeoff worth it in the end)
#  - being useful outside plan9
#  - have OCaml ports (that are also installable, testable, readable, and useful):
# for example:
# - goken can target Linux, macOS, windows! and be better than gcc/clang toolchain!
#   can be used for xv6-riscv cross compiling! (and needed anyway for principia)
#   => retarget Linker.nw, Assembler.nw, Compiler.nw, Libcore.nw
# - mk/rc outside Plan9 (and needed anyway again for principia cross-compiling)
#   => Builder.nw, Shell.nw  and OCaml variant Mk.nw, Rc.nw
# - ocaml-light, simpler than ocaml (and needed anyway for efuns/lex/yacc/ogit)
# - efuns, with cool pfff/semgrep tree-sitter based language modes and LSP extensions!
# - draw in X11? (see go draw/x11?), so can also test graphical programs
#   outside plan9
# - utilities (a la plan9port), grep, sed, diff, gzip, tar
# - rio in ocaml, kernel in ocaml, kencc in ocaml, mk/rc in ocaml, ogit
#   so not just C code that is often harder to understand (A la Andrew Appel,
#   multi versions)

** priority 1: get a working version out! so I can get more people to help

*** fix bugs in C compiler, linker, etc. and/or switch to goken9cc
#for 8xx and 5xx versions (but especially 5xx versions)

**** try basic assembler

**** try basic linker

**** try basic C program

*** compiling mk under plan9 does not work

**** error about stupid shift in 8c

**** page fault when linking
pb incompatible libc.a? 
modify 8.out.h on kencc?

*** => can compile some plan9 programs under plan9
libc?

*** fix pdfs, fix indexes
at least get some basic english

*** => can put out first version of books

*** fix network so can take better screenshot with web browser (mothra?)
and editor (efuns?)

*** make website

** priority 2: write!
#focus: use remarkable! annotate! and work on new chapters, don't look back!
# get first a full draft! no procrastinating on non-important stuff (ex:lineage)
#update: use chatGPT to refine

finish 4 pairs? 5a/5l, rc/mk, lex/yacc, draw/rio, efuns/ocamlgit (ocaml books)

** priority 3: find publisher?

Emma?

Or this cool italian editor with nice process?
https://news.ycombinator.com/item?id=27490988

** compile plan9 under plan9
#so can see if regressions; bad to explain code that does not work anymore!

*** strace does not work
pb with '/proc/0' does not exist ???
because not right way to invoke?
then adjust Debugger.nw

** RELAX go through all .nw %history notes on related work and
extend lineage.txt accordingly 

** RELAX go through software-src/ again
or go through different lineage.pdf

** RELAX start intro of remaining books?

*** Editor.nw? 
nice program. and anyway I plan to put it on OPAM soon.
#ocaml stuff! again! so will have VCS.nw and Efuns.nw, 2 books in OCaml.

*** CompilerGenerator.nw? 
only 87 pages

*** Debugger.nw? 
lots of Extra code right now, and useful to
understand this program

*** Profiler.nw? 
only 115 pages

*** Widgets.nw?
only 126 pages
interesting; maybe alok would like

* see also mkfile.todo

* Infra

** Build infra

** Test infra

*** add GHA check for all the commands, 5a, 8a, etc.
at least make sure they don't segfault like rc currently does

*** try make principia work with qemu-system-arm with 9pi and dosdisk.img
pb of size of dosdisk.img at 513 instead of 512 because of bootsector


** Dev infra

*** less: fix warnings in kencc
clang is stricter


* Books

** status
% of code understood (if forget a bit about advanced topics and extensions)
19 books ... hmm

**** 80% kernel (without network, without graphics)

**** 95% shell

**** 50% graphics system (can expose vga in kernel, memdraw)

**** 80% windowing system

**** 40% network system (including devmnt? rpc, etc?)

**** 10% libc (memory allocator, threads, unicode, ??)

**** utilities


**** 80% machine

**** 95% assembler

**** 95% linker

**** 70% C compiler

**** 50% ocaml compiler

**** 70% generator, lex/yacc



**** 90% editor

**** 50% debugger

**** profiler

**** 95% make

**** 15% browser


**** 10% game soldat


** Principia.nw

*** reduce number of books? so easier to sell to publishers? or make bundles?
with 10 I already have something solid:
 - toolchain (5a, 5l, 5c)
 - kernel (9, libcore)
 - windowing system (draw, rio)
 - network (net)
 - tools (mk, rc)

*** table footnote on LOC in principia, so cleaner ARM and x86 mess
also add explanation in the text.

*** still? Turing machine section

*** terminal sessions for bootstrap programs, e.g interaction
in assembler0-M-card, or boot loader which ask boot cards
or tape

*** ascii kernel/shell/libc
hardware, kernel, libc, shell

*** ascii compiler pipeline
with .c on arrow

*** represent all books on one diagram?
could also have a screenshot of plan9 are link to books
in the screenshot?

*** other ascii diagrams for bootstrapping section?
for virtual memory? fs?

** *.nw

*** Quick read TOC and fix small stuff like use of :, 

*** quick read and remove useless labels,
annotate some %crossref, by reading PDF on laptop and fixing directly.

*** Put more examples of data next to the data definition, see THIH how he did.
Or even better unit tests!

*** Try also to have simpler version and debugging code in it, for instance simpler
ocamllex version, simpler SLR backend for ocamlyacc, no opti for C compiler,
etc.

*** less: fix bibtex and uppercase for titles for inproceeding stuff

** Remaining Xxx.nw (template of procedure to follow)
profiler
utilities

*** make graph
so can get order of files for the list_xx to be the basis
of pfff -lpizer

*** make check, scheckify, remove deadcode, useless export, or mv as forward decl
in .c

*** syncweb/lpizer
does more than just lp split!

what about inferring core DS? and their order?
and LP split fields? and find main? and LP split main?

*** mk index

*** mk pdf

** -------------------------

** Assembler.nw
mostly done

*** full pass, crossref, trans-dull, for Assembler.mw
now that have code indexing, less needed

*** style: get rid of all those (virtual) or clarify
for code address, for memory address, for program counter

maybe use pseudo code address! less confusing with virtual code
address and virtual memory (but use virtual pc in asm.pdf)

similar issue with local vs private

*** learn

**** use of R15 instead of SB for hello? 

**** 5l opti with string -> code section? disable it?

**** R12? why need that? cant have static value for address of things?
need to pass though a content? is it because anyway there
is a symbol table?

**** look initstk, how R14 is set

**** look linker, look machine, learn about what BL actually
do regarding the registers


*** toy.s! helloworld.s with just interrupt
easier if can learn to use sam ... so can edit
from plan9 and refine

*** assembler: more output code generation part

*** assembler: lp split Sym and typeify fields
hmm but take care because 5a and va must define Sym in the same way
otherwise get some conflicts with aa/ when linking

*** assembler: LP split Gen?

*** reread manual assembler again, note concepts and explain better
things

*** less: xix-assembler.ml?

** Linker.nw

*** full pass, crossref, trans-dull for Linker.nw?
now that have code indexing, less needed

*** revise whole book, annotate, fill TODOs, and fix

*** program counter line table section

*** offset_to_r12, absolute_address
final_auto_size()

*** more WORDS rule, instead of ugly cases in switch
for LEXT, for all Lxxx

*** ARM architecture section in overview and overview/principles
can delay? Resolving needs that to make things clearer.

*** ARM format in codegen chapter, and finish the C_xXXX and immaddr()

*** datblk and endianess explanations

*** core DS big figure? list of Xxx, cond vs link, sym table link,
Adr, etc.

*** style: ambiguous to use "instruction"? use "object instruction"? 
or Asm5 instruction?

*** understand

**** SP? where is it saved? caller is responsible to restore?
see save and rest procedure with div?
what the compiler generates? 5c -S ?

**** immrot, look machine.nw semantic vs immrot() code

**** pool? immaddr? immhalf?

**** comment profiling section and the code that generate instructions,
can help also understand Assembler.nw

****  asmsym()

**** D_FILE1??

*** when used multiple times the same [xxx] = yyy entry
in 5i:
(1770)	DATA	itab+2040(SB)/4,$Ilsm+0(SB)
memchr: multiple initialization

*** errorcodeify linker

*** linker: debugging support section, can help understand
different kinds of entities

*** linker: lp split fields Prog, put closer to the functions that are using
them

*** linker: factorize the ugly gethunk


** Compiler.nw

*** intro+overview, so match the other books
may be easier to write, I can assume more, and I know more compilers
than other programs.

*** SEMI can remove the opti? check if can remove code and still
get a working compiler? or mv into its own file this opti
so more guarantees no interference with the rest.

*** try modify nodretval to disable ANOP
so that can test if can compile with -N to disable
regopt and see if it still work


*** understand

**** understand deadheads()?

*** LP split

**** LP split bcomplex()

**** LP split part of boolgen()
so can see the AB generated at the end

**** LP arrange tcomo() split

*** rename

**** rename reg field for Node, Prog, and Adr
overloaded

**** rename offset fields, too many of them

**** rename OPROTO -> OPARAM?

*** remove

**** remove old style proto, and non ANSI stuff?
TOLD, OLDPROTO
so no need tmerge

**** remove -B (non ANSI) so transform some warn in diag

*** LP aspectize?

*** read 

**** read articles on making compiler in 22 steps


**** read article again by ken thompson, will help to
understand for example the handling of complex returned values

**** read dragon book, lots of references to this book apparently,
will help understand acom()?

**** read johnson and ritchie paper (and latest thompson)
read aho?

**** read plan9 C compiler manual


*** errorcodeify compiler
so many different error conventions there ...

*** elements OYYY that appears after parsing?

*** restore the packxxx? dpchck?
was dead in assembler but live in compiler no?
look at kencc/?

*** change order AST? closer to my ast_c.ml?

*** Xconv study

*** cg on Node, see stuff unused, or stuff used only after parsing

*** move xnames in debugging section

*** !!!!bench it!!!! like compcert, evaluate how fast it is compared to
gcc ... use the benchmark of compcert? need backport the macos
binary to kencc? or try compile on linux? (would be good to compile
on linux anyway plan9 at some point anyway)

see ~/bench_c/

can bench on leroy's examples?
at least can bench between unoptimized version of 5c
and optimized one. See if worth the complexity.


*** mv code out of pswt.c, nullwarn, etc portable but not related to switch

*** look at all the debugging options
(and maybe try on tests/helloc.c)
and add relevant sections in TOC?

*** remove 64bit stuff?

*** move globals closer to their module?
look what I did for the assembler


** Make.mw
mostly done

*** mk objtype=arm does not work when run under plan9 :( rc issue apparently

*** finish chapter in Concurrent Programming in ML?

*** implement concurrent version of builder in mk-in-ocaml? for fun. faster?
(see concurrent ML book by Reppy on my remarkable)

** Shell.nw

*** boot.rc explanations

*** finish soft archi CUI and trace ls

*** => finished intro and overview chapter

*** core DS chapter Shell

*** main() chapter Shell

*** EASY more consistent type capitalized, and consistent use of typedefs
Code, Tree, etc

*** EASY aspectize error management at more places

*** -------------------------------------

*** EASY ctor, builtin, opcode
=> rename execxxx that are not builtins!

*** shell control? how kill process? C-c ?
HOW INTERRUPT process?? see mk, I tried C-d, C-c, but could not stop
Windows.nw talks about Interrupt key, but I could not produced it.
It's Alt-gr and Delete?

*** read 

**** read code of Bourne original sh?
written in "BourneGol"

**** look bash source code?

*** bug: rc2 C-d => panic
use acid? need a /sys/lib/acid/port and /sys/lib/acid/386/
because remove some code?

rc2 is my own variant of rc with a simplified bootstrapcode,
so this is probably why C-d have some errors, because my bootstrap
is not correct.

*** function via emit(fnstr), nice :) fn are actually local variables? :)
and then eval?

** Graphics.nw
Lots of things I don't know codewise and algorithmic wise, so interesting!

http://blog.golang.org/go-imagedraw-package

*** refactoring books for Raspberry Pi

*** start explaining code! Core Data Structures chapter

*** use arctest.c and other tests to illustrate APIs?

*** svgalib? LOC? mgr? twin? draw from plan9port?

*** rename chunks with "layer" to "window"? or overlapping windows?
called layer originally in Blit paper by Pike,

*** still lots of special code when have no alpha
in src, or mask, or dest

*** still lots of special code when grey
in src, or mask, or dest

*** memfillpoly, split, mv opti in adv topics,
understand the sort and div and xscan and yscan

*** mention dtor too next to DS too?

*** understand Screen, screenimage in Display, etc

*** move more generic stuff that now just depends on gscreen to screen.c
like software cursor, graphical text mode

*** merge screenimage and gscreen in a screen.c?

*** remove hwdraw.c and iprint.c?


*** can get rid of vgavesa now? just put in BIG/?

*** apps/clock.c, try to understand main APIs, feel
 
*** Extra libmemdraw/draw.c, lots of stuff still
memimagedraw()? hwdraw?

*** memdrawtest.c? run?

*** follow one op until the end, full trace of a draw
rectangle!

*** EASY reorg initdisplay to better error managment style a la Linux style

*** EASY the drawxxx unmarshaller

*** LP split initdisplay
depends on previous item

*** LPize windows/layers/screens
in many places arguments can take an additional screenid
that complicate a lot things

** Window.nw

*** how lc knows width of window?
read /dev/window? and if nothing then assumes 80?

*** LP split frinsert()
hard to understand

*** LP split frdelete()

*** ---------------------------

*** fix annotations on Windows.pdf

*** still? grammarly, send pdf!!
use pandoc to convert to docx?

remove grammarly recurrent subscription?

*** could have each thread section start with a zoom of the
big process archi, with more details with channel names,
DS

*** DS diagram? not sure; maybe too overwhelming. maybe later
or as summary of core DS chapter.

mousectl, keyboardctl, windows (with a set of rectangles
with window[0], window[1], etc?)
and the channels!

*** SEMI see my notes on history of windowing systems printed chapter

*** less: need ramfs for /mnt/ ??? because ugly DOS?
anyway, virtual FS mostly

*** look code of mgr? nanoX? similarities?
similar concepts? thread/process architecture?

*** split WCwrite

*** wbacknl()

*** EASY aspectize more sanity checking code

*** put core DS of textual window content
see wcontent, put that earlier in core DS chapter

*** aspectize scrolling


*** wmousectl can be called with middle click or right click??
I think it's intercepted before

*** put file server before? will need to fully explain
graphical and textual windows anyway, with their /dev/xxx

*** understand mousethread drag and bandsize, what are the conditions?
winborder!! so LP split it to put in right section!

*** LP split window creation, mv stuff from new() and wmk()
below

*** debug rio? can have list of threads?

*** thread xxx, all places where threadname()


** Kernel.nw

*** fix mk index

*** less: Kernel.nw, mk index when process arm
right now parse error in arm/fns.h

*** try make kernel work on Raspberry Pi under QEMU

look at ocaml code, I think one interrupt or timer does not work
under QEMU so you need to use another!

need ot port what I've done for the kernel in ocaml to 
bcm/

*** refactoring kernel for Raspberry Pi

**** bcm/ reorg

***** get rid of coproc.c? define always routines in assembler instead?
or remove assembly routines and use consistently coproc.c?
why need? because can't do C(R0) in Asm5?

***** codegraph on kernel but with arm/ files
fix parse errors, empty define, etc

***** factorize some functions in devether.c?

***** mv plan9l.s outside syscalls/386/ to processes/386/?
true that related to syscalls

***** kernel can work without the cache? will get
simpler code!
Far slower?
But then at least aspectize all of that!

**** other

***** issue with getconf? can not factorize?

***** can factorize vgascreenputc for pc/? can use graphical_screenputc?
vgascreenwin -> screeninit?

***** can factorize software cursor for pc/? WEIRD
does not work :( cant even link with a swcursor object file
you do not use. WEIRD! pb in 8l??
It does work now!

***** still? put interface for macros

***** port to pad types bcm/
cankaddr -> phys_addr (pa)

***** mv floating point stuff in dat_arch.h
instead of dat_processes.h?

***** factorize PTEVALID in port/?

**** still regressions? like colors application?
for x86 and arm

**** ----------------------------------------------

**** automate procedure to compile from scratch ARM libs and programs
and to make a Raspberry Pi distribution on SD card

**** port more features?
sp bootargs

long
sysnsec(ulong *arg)
{
	validaddr(arg[0], sizeof(vlong), 1);
	validalign(arg[0], sizeof(vlong));

	*(vlong*)arg[0] = todget(nil);
	return 0;
}

**** less: fix fossil with bcm2 and bcm
usb works, but pb with fossil

**** less: WEIRD pb with generating channel.acid with kencc-updated?
try with kencc-latest? same pb?

**** try smaller programs
https://github.com/dwelch67/raspberrypi
https://bitbucket.org/infpi/inferno-rpi

**** notes raspberry pi
https://github.com/dwelch67/raspberrypi
https://thekandyancode.wordpress.com/2013/09/21/how-the-raspberry-pi-boots-up/

http://fqa.9front.org/appendixj.html raspberry pi notes
https://github.com/sirnewton01/rpi-9front

https://github.com/puppeh/vc4-toolchain
for open firmware

patch done by miller on his 9pi.img (email on 9fans on june 2016)
armv7-atomic
 http://9legacy.org/9legacy/patch/libc-arm-atom.diff
libsec-x509-sha256rsa
maybe/usb-short-desc
pread-offset
proc-smp-fixes
ramfs-fixes
segment-overlap
usbether-rpi
usbserial-ftdi-writelen

http://9legacy.org/patch.html
http://9legacy.org/www.9legacy.org/9legacy/build/dist/9legacy
https://github.com/0intro/plan9-contrib

*****
Plan 9 from Bell Labs
firmware: rev 346337
cpu0: 700MHz ARM1176JZF-S
fp: 16 registers,  simd
fp: arm arch VFPv2; rev 5
eMMC external clock 100 Mhz
#l0: usb: 100Mbps port 0x0 irq -1: 000000000000
#u/usb/ep1.0: dwcotg: port 0X0 irq 9
128M memory: 28M kernel data, 100M user, 479M swap
usb/hub... usb/ether... 
etherusb smsc: b827eb754565
version...time...

init: starting /bin/rc

**** support for more devices under QEMU
how do keyboard/mouse under QEMU? USB keyboard?

**** try inferno-rpi?
https://bitbucket.org/infpi/inferno-rpi
https://code.google.com/p/inferno-rpi/

seems mostly a copy of miller stuff but ported to inferno?

**** try ls compiled by 5c and run via 5i :)
hihihi

need 5c -f richard miller says, to compile with floating point hardware
or something. See plan9 mailing list answer by richard miller to my post.

**** port latest allocb.c?
block stuff?

*** EASY split more devcons.c
LP split consread, conswrite

*** EASY split more devproc.c
LP split /proc
setkernur
cleaner


*** EASY cleanup those _xinc vs xinc, _tas and tas
choose one! and indicate if override libc stuff!
test x86 and arm

_xinc, _xdec, cas, remove from libc/?
code using it? ok to use arch_xinc in kernel? will
subvert code from libc too?

*** EASY split more proc.c
split proc.c in scheduler.c and proc.c? 
use codegraph?

*** EASY factorize KiB, MiB
KB MB defined in many places

*** -----------------------

*** 
% - put some "lemma/theorem" in the code, which are prolog/datalog queries
%   explaining some invariants :)

*** resume, cleanup those proc_error, etc,
use regular names and put a special comment in the .tex.nw

*** plan9: filesystem

**** use the fs of xv6?
need to port to 9p though

is compatible also with mac, in the sense that can build distrib
from my mac I think, via their scripts/mkfs.c :)

**** simplefs? dosfs? instead of dossrv?
make my own? include dossrv core in kernel directly?

vfat is a bit ugly ... with the 8.3 original limitation and verrue
on top of it to handle longer filenames. but fat is compatible
easily with mac so easy to mount/inspect and make a distribution.

look paqfs, flashfs?
devtinyfs (from 9atom): hmm looks really a toy

*** plan9: understand stuff
start Windows.tex.nw? I would like to understand how xterm works with the
buffered input and redirection! but will need to understand lib_graphics and
lib_thread?

**** proctext, Qtext, put where?
nice redirection :) useful to have open indeed!

**** Qns, use of mountid?

**** umh = mount head when have union (that is at least 2)
if have just one then just use channel gqid itself, that is mh->mount-to
first Mount stuff.

**** pgrpid?

**** newfgrp(), just call duppgrp
and generalizes this?

**** have a type for type + dev + qid?
gqid? globally unique id?

**** consistent put vs close vs free, new vs dup vs alloc, dup vs cpy
cclose vs putmhead? newchan vs duppgrp?
put is a bad name I think.

**** 2 chans parameters of walk()? look at devwalk()?

**** have a typedef for permission and openmode, and use PERM_EMPTY instead of 0

**** -----------------------------------------------

**** serial? 8250 controller? qemu special console?
minicom?

**** include devmouse.c? in device?
even though not really used
cat /dev/mouse and do stuff?
also explain that actually draws the cursor somewhere?

**** remove Kmouse, seems not executed

**** try produce ^P that reboots?
need that when want to reboot at distance? hmm could just
run /bin/reboot no?

**** try produce ^U?

**** --------------------------------------------------------

**** lp split fault(), split error checking, split pagetable walk

**** lp split pio()
with demand load or swapping in case

**** lp split page fault
with demand load, copy on write, swapping in

**** lp split sysrfork()

**** lp split sysexec()

**** cachedel

**** -----------------------------------------------

**** how setup serial console! i8250console, rdb, etc?
C-Alt-3 on qemu?

**** more on meminit()?

**** assign dbgreg to the right section, try understand the debugger?
what about Trace_me too?

**** perfticks, fastticks, ??

**** implement a 'strace pid' that attach to existing process that works!
need write stop I think, and then not do the waitstop

**** understand ps and pstree

**** can emulate C-z? C-c? ask to 9fans? what about ulimit?

*** plan9: emails 9fans

**** report deadcode about OTRUNC?
because if put special logic for this special flag, should do the
same with the other like OCEXEC, etc no?

**** Ref for Mount? ugly cafebeef

*** plan9: add comments

**** keyboard comment
job of Keyboard section lead to adjust Conskbd things and
also echo back on the screen running the hooks

but then buffered input! when do \b then go back don't add in kbdq
for programs that read, and also block them until \n, and
in turn those programs can output stuff (but note that
it's the job of kernel to output keyboard typed key! not the program!)

**** add notes about simplified memory model

***** typedef page_or_swap?
and add note that pagedir/pagetable are in mmused, so not swappable.
only pages from process segments are considered for swapping.
PageOrSwap is used only at one place!

***** imitate more other archi so that don't need kmap thing?
if give less virtual space to process, and make kernel start earlier,
and that import limitations on DRAM, then far easier!

try first with changing KZERO and see if it compiles!

then add a check in memory detection that panic if too much memory!

maybe then can move this discussion in advanced chapter? like SMP
but called BIG MEMORY system?

***** rename CPU0PTE to CPU0KZEROPAGETABLE
and CPU0PDB to CPU0MMUPAGEDIR?

*****
Note that far less efficient that Intel way to represent things no?
but here we want to store the reverse information too? and free list.
and want
to be portable so have to store this info. Compute
sizeof info when use mmu and when use portable stuff?
for mmu:  1 mmupd (= 4KB), 1024 mmupt (= 1024 x 4KB) => 1025 Pages = 4Mo.
for plan9: 1 Segment (= x?), 1984 Pagetable* (= 1984 x 4B),
 1984 Pagetable (= 1984 x ?) + 1984 x 256 Page* (=? x 4B),
 = 1984 x 256 x Page (=? x ??) => ?? Mo?
 except can't have more Page than physical memory (+swap?)

sizeof Page? sizeof Pte?
will have enough of space to store meta data about all physical pages?
need it? could do without?

***** MAXKPA
can help to explain that when turn on segment+pagination (which we want,
it's a too nice hardware feature),
then every memory access involve the MMU. There is no way to do a 
MOV_WITH_DISABLED_MMU PHYSICAL_ADDRESS, AX.
MMU configured so that from KZERO up to 0xFFFFFFFF it's simple
mapping 1 to 1 to physical memory. Very simple. Convenient. so never fault
when access kernel data (and chicken and egg issues).
if kernel need access physical memory < maxkpa, great, easy.

But if machine has more than that ... then it needs
to adjust VPT to point to the right place ...
VPT itself is in virtual memory? chicken and egg?

    /*
     * can't go past the end of virtual memory
     * (ulong)-KZERO is 2^32 - KZERO
     */


***** understand the double map of kzero thing. Mentioned in balestero?
like in bcm, you can't enable pagniation if there is no identity mapping
for the first MB? it's like a pre condition?

***** can have fixfault from kernel? if don't use the VPT,
tmpmap, kmap, etc, can have a fault while in kernel code?

YES, for instance if process ask to write at certain va,
and do a syscall that for instance try to read /proc/self/mem
then procread could cause a fault addr when writing in va
if it's not allocated. It's ok.

***** more types?
Page* is abused for speaking about the page that can contain
many things, a page directory, a page table, user content, 
kernel content, other? introduce extra type?
typedef Page PageDirectory;?
typedef Page PageTable;?
typedef Page ??PageTable;

and also have the PortablePageTable vs MMUPageTable ...
and PortablePageDirectory vs MMUPageDirectory.

hmm but the name of the local pdb, pt, ... or field
should help find what kind of Page it is about.

***** mmuwalk, LEVEL1, LEVEL2 instead of 1 and 2, define enum!
so clearly explain data structure


*** plan9: kernel
spirit:
- use (and improve) codemap/codegraph to understand the code
- remove as much stuff as possible, especially optimizations (e.g. cache.c)
  but not too much, for instance support for SMP is important but can aspectize
  it and mv in in an Extra section

http://www.tldp.org/LDP/tlk/tlk-toc.html

**** keyboard issue: kencc bug? wrong compilation of unicode?
I only updated partially kencc/lib9 with UTFmax from 3 to 4, but
probably I have to port more code.

Alt-w-k does not generate the good character, how produce e cute?
I think kencc generates wrong things. 

**** halt works?
print when resume from halt?

put in power managment section?

**** typedef int error; !! OK0, OK1, ERROR1, ERRORNEG1
replace some of the int to error?

and make more consistent? some places where they do if(xx() < 0)
and where xx clearly does not return a count, then can
switch to a better error scheme.

count_or_error?

**** put back exit(1) in panic()
Also why so many Broken processes in ps?

panic because removed mtrrclock?

**** ----------------------------------------------------------


**** split some .c based on LP new TOC
(but use cg to make sure it does not depend on fancy stuff before doing the mv)

each time there is a newxxx there should be a file xxx.c and
if possible only the core stuff about this xxx in it
(so path.c, etc)

proc.c: 
 - scheduler.c
 - sleep_wakuep.c? or put in rendez?
 - notes.c
pgrp.c:
 - rendez.c? why in pgrp.c rendez vous stuff?
sysproc.c:
 - fork.c
 - exec.c

file.c:
 - path.c
 - block.c (mv stuff from iallocb.c and qio.c)
 - queue.c
 - fd.c? 

console.c:
 - cons_input.c
 - cons_output.c

files/env.c mv? in process/?

introduce ipc/ directory?

**** still? now that smaller kernel, can put on floppy? can do with
pbs? still this 'pbs' code is very ugly too

**** ------------------------------------------------------

**** still? disable SMP? easier to understand boot kmesgs?

**** less: remove in paddr() and kaddr() the ugly kern_addr2 and so on
hard to do

**** typedef enum xxx Xxx; ?

**** use foreach instead of those emap, end, etc
or at least be consistent and use nelem
or is it to avoid races? nah.

**** less: remove cpuserver?

**** again? remove vesa and realmode?
used by vga, vesa, can remove vesa support? cirrus logic not enough?
seems not enough last time I tried but maybe I did a mistake

**** still? try merge sched() and schedinit() and so remove need for Label
in cpu? can abuse the per-process kernel stack of another process
for more time?

Maybe can also try make sched() less defensive and panic earlier. I'm scared
we actually call sched() expecting the process would go to sleep
but it actually returns! like in qlock() ...

look balestero's notes!

**** lock return type? useless? send email?

**** semi: get rid of cache.c? or mv it closer to devmnt?

**** less: mv some err into error.h?

**** cleanup portdat_files.h, remove mnt stuff in devmnt?
or put more mnt stuff in devmnt? like mntrpc, etc.
Mnthead can stay in portdat_files.h though, for pgrp, but
specifics on mount and rpc not.

**** mv mpinit() in main.c?

**** get rid of some x86 cruft, like cmpswap386, etc?

**** get rid of ipv6? maybe better to understand first well
enough what is done in kernel/network/ in general

**** less: kerndate, cpuserver, do assign of kerndate = conf_kerndate; ?

**** make an alterative boot/ that is just boot.rc, no need boot/*.c

**** replace all those arenas by a more generic slab allocator?

*** plan9: lp

**** SEMI EASY more split LP devcons, put in the /dev/ section

**** SEMI EASY split LP /proc

**** less: LP split error.c?

**** -----------------------------------------------

**** less: rename more rendez vous r in something better
pager, clunq?

**** TVal -> Ttk?

**** kstack, kkstack?

**** ticks? = Hz per second clock interrupt?

**** syscall fd2path try to understand (in the end it's namec())

**** SEMI different forms of use of waserror, tricky
(but I start to get used to it, not so many ways)

**** do pathological case for xalloc, many
xalloc, free in the middle => fucked because too many holes

**** hzclock! and limited timerintr

**** split struct I8253, macro split FREQ and HZ, tod

**** i8253 with its field for timer

**** less: dumper category?

**** reread balestero's notes, should better understand more subtle things

** Libcore.nw

*** continue mv from Extra to Libcore.nw

*** Thread.nw (via Libcore.tex.nw)

**** understand alts()?
how listen to mouse and keyboard at the same time?
I didn't see any select syscall in plan9

** Network.nw

*** refactoring books for Raspberry Pi
 => no more x86 in the books!
woohoo!

*** ---------------------------------

*** etheriq, etheroq
call pktin? or something else?

*** understand broadcast, how find route for ip out of range?

*** need self cache? /net/ipselftab is needed?

*** continue distribute for ipifc.c

*** reorg Route and Routetree?  simplify allocroute?
at the same time it's a nice opti, a clever C trick.

sizeof(Route) - sizeof(V6Route) + sizeof(V4Route)?
C compiler will honor that? no tricky padding?

*** EASY DP_DF aspectize

*** Qlisten?
comes with announce? does not use data?

*** import more stuff from snoopy?
the headers are cleans

*** continue understand IL

*** who calls pktin?

*** LP split ipifcadd, big, complex

*** netif? works with /net/ether/?

*** user initialization?

*** EASY factorize IPaddrelen kernel and user

*** EASY factorize hnputs stuff?
or even remove, the kernel is linked with libip anyway

*** try telnet? on google?

** -----------------------------

** Editor.nw

*** understanding, lpize

**** pass on Extra for features/ to move stuff to Efuns.nw

**** put more of mli files in Efuns.nw; they help to understand
redundant sometimes, but redundancy is good
but actually need to split things first, so can actually
have some .mli. There is no efuns.mli for instance now.

**** less: ctor xxx, action xxx
can maybe make clearer that API vs helper

*** cover at least basic features?

**** http://tuhdo.github.io/emacs-tutor.html

**** look at the 7 habits of effective editing talk,
can implement all the necessary features!

**** there is similar video for sublime!

** VCS.nw

*** fix VCS-8.pdf
but I think just annotation p14

*** too many trans:dull? get inspiration from nice LP books, like
David Hanson books? (C libs or C compiler)

*** EASY? go through VCS.nw, address some of the comments, 
or transform them in \t or \l

*** overview/principles? 

*** algo chapter

**** LP split diff more simplified Myers

**** lpize diff3.ml and LP split
or wait more robust?

*** quick read Pro git book
available online
as well at git reference cheat for his sections

*** read other VCS books? on CVS, on Git (see Downloads/Principia/VCS/)

** Debugger.nw

*** mv from libmach Extra to Debugger

*** LP split Mach, Machdata

*** include ARM stuff

** Profiler.nw

** Machine.nw
#good to get closure after Assembler/Linker, full circle, also still
#remaining issues.

*** intro+overview, so match the other books
nice lineage, 

*** code 5i: make a real prompt 5i>, more readable

*** EASY aspectize more Imem1 and Imem2, too complex right now

*** EASY core DS

*** EASY code orga?

*** soft archi

*** EASY command-line interface
few examples

*** start with overview chapter, principles of machines
just simple description of a computer
or start with code orga?

*** look vi/, simpler?

*** LP split dpex()

*** add opcode_ir, opcode_class, opcode_cond
`so clearer what is derived from opcode and what is runtime

*** dodge the bullet, have a cleaner opcode enum?
with AND_0, AND_1, etc
but then arm_class code is less short ...

*** need machdata = armmach?

*** LPize the -=4 or make it cleaner,
like actually do the REGPC+=4 instead?

*** less: Instr -> InstrDecoder? InstrInfo?

** Widgets.nw
#step towards better mmm?

*** understand and LP split menu

** Browser.nw (mmm)
see also mmm/todo.txt

*** refactor (to help understanding)

**** have display_html and display_machine, which is confusing
=> better to have display_html, and then machine_html
so rename! or even interpret_html! or html_interpreter

**** more types? or better chapters?
type retriever?
type viewer?
type formatter?
type interpreter?
type cacher?

so Http.req has type retriever, more readable? factorize also
same for File.req, or a requester?

*** LPize

**** LP split stdctx

**** Plink.make
mv closer to parsing? or in core DS?
P for ?

*** aspectize 

**** aspectize frames, not in html5 anyway

**** aspectize more img and embedded

*** look at Form display :)
could learn stuff for my rsvp form :)

*** add "frame" and head_hook

*** test dumpers
URI?
URL?
link
request, headers
html
diff?

*** less: run scheck, remove deadcode?

*** later: CSS, JS, etc
implement enough for this examples:
https://khanacademy.org/html-css-js

** CompilerGenerator.nw
ocaml stuff! so 3 books in OCaml

** Compiler HLL (OCaml.nw)
see also ocaml/todo.start

*** relocation section in OCaml.nw
and also aspectize debugging in link_compunit

*** section Linking with C

*** -custom, generate special ocamlrun, with special
primitive prim.c!
Add in OCaml.nw the code

*** interpreter and dynamic linking?
load libcamlrun.so ?? or need -custom then!
not until ocaml 3.03?


*** --------------------------------------------

*** remove more of Obj_val, Oid_val, etc, which mean
aspectize more also generic compare, hash, and marshall

*** lpize

**** caml_main LP split

**** aspectize exception mechanism
setjmp, from ocaml, from C

*** migrate from Extra to OCaml.nw for byterun/ stuff

**** gc DS

**** gc major

**** gc minor

*** later: last touch forward port threads

@@ -80,8 +80,9 @@ struct thread_struct {
   value * stack_threshold;
   value * sp;
   value * trapsp;
-  value backtrace_pos;          /* The backtrace buffer for this thread */
+  value backtrace_pos;          /* The backtrace info for this thread */
   code_t * backtrace_buffer;
+  value backtrace_last_exn;
   value status;                 /* RUNNABLE, KILLED. etc (see below) */

@@ -170,6 +171,7 @@ value thread_initialize(value unit)       /* ML */
   curr_thread->trapsp = trapsp;
   curr_thread->backtrace_pos = Val_int(backtrace_pos);
   curr_thread->backtrace_buffer = backtrace_buffer;
+  curr_thread->backtrace_last_exn = backtrace_last_exn;

@@ -232,6 +234,7 @@ value thread_new(value clos)          /* ML */
   /* Finish initialization of th */
   th->backtrace_pos = Val_int(0);
   th->backtrace_buffer = NULL;
+  th->backtrace_last_exn = Val_unit;

@@ -296,6 +299,7 @@ static value schedule_thread(void)
   curr_thread->trapsp = trapsp;
   curr_thread->backtrace_pos = Val_int(backtrace_pos);
   curr_thread->backtrace_buffer = backtrace_buffer;
+  curr_thread->backtrace_last_exn = backtrace_last_exn;

 try_again:
   /* Find if a thread is runnable.
@@ -488,6 +492,7 @@ try_again:
   trapsp = curr_thread->trapsp;
   backtrace_pos = Int_val(curr_thread->backtrace_pos);
   backtrace_buffer = curr_thread->backtrace_buffer;
+  backtrace_last_exn = curr_thread->backtrace_last_exn;


*** later: ocaml features to add for fork-efuns and other

**** later: fix Str to allow [xxx-] and also [xxx.-]

**** later: port the stuff from ocaml 2.?? that include info
in .cma so just need to add unix.cma and it will also add
the -cclib -lunix! useful! hide complexity

**** later: more backtrace support

1ca0e80c73759ff22c33660cd166af1095c2a835
Ameliore backtrace dans le cas ou l'exception est levee par une primitive C
 (PR#654)
was important indeed :) partially implemented to fix segfault in efuns

736d2cfe14b025da924c0c1aa3ebd293433edd63
47d37cc125e5650ec14d156e1c1eef74f0eb9871
64666f7de7af6e194cd147fd5a038196856c684f
PR#3809 wrong line numbers in backtrace (partial)

4b5512c74cda289652ff53c01098c53a6c4b0c7a
Stack backtraces on uncaught exceptions in native code (merge of the opt_backtrace branch)

5902603b2ca505299f141d33b891166e9b9a31d7
PR#4308 (partial fix): improve backtraces for 'spontaneous' exceptions such as Stack_overflow or Out_of_memory


*** fix compiler warnings

*** code organisation, I have a better picture now

*** lpize ml stuff part 2, tools/debugger!, tools/profiler?

*** later: typeclass, deriving, etc
woohoo

* Code

** plan9

*** purge a bit more networking/?, so can maybe get less than 300 000 LOC!!

*** now that have troff, can make 'man' to work?
need more fonts?

*** BUG!! if click with mouse on windows before it finish the kernel
then pb :(

git bisect? fault seems easy to reproduce determinstically
error message has a a i8042

*** BUG!! clock error

** 5l

*** look at the recent D_ADDR TODO I added in comment
in principia/linkers/5l/ source. might had bugs when I
added D_ADDR? I handle all the cases correctly?
but this is in principia/, not goken, so should be fine


*** figure out why lineno seems wrong in overview/hello.5 world.5
tutorial
maybe because wrong in object file too no? seems bug which I solved
via TSEMICOLON in 5a-in-ocaml
further

*** report bugs found detected by 5a/5l ocaml but not 5a/5l,
see tests/5a/cant_*.s

*** create pb crashing 5l when pool for C_LEXT?
no rule found? WORD rule matching?
then simplify code to use rules insted of ugly switch

*** create pb crashing 5l when etext becomes an LCON
and was a RECON first.

*** bug 5l things not initialized? email 9fans?
lucky that redefined alloc

*** MOVW foo(SB), R1 ??? meaning? cant_move_code.s
correct addressing? s->value of that?
real pc but then treated like an offset to R12??

*** rewrite code calling datblk, remove the -100
so simpler code, do that in callee,  pass offset start and end

*** need $-4? and why need leaf and no locals?

*** linker: rename Prog -> Instr?


*** rename

**** rename Gen -> Operand?

**** rename Adr -> Operand?

**** rename Prog -> Instruction?

**** disambiguate Prog.reg and Adr.reg, choose different names
add some unions for abuse of same field?


*** refactor

**** better orga symbol table with different namespace,
like in compiler! and now assembler

**** easy: designator for Mach fields


** 5a

*** bug 5a should report when BL foo+4(SB) because 5l overwrites it!

*** lineno right? not read too soon newline tok?
this is why 5l -W was wrong?

*** bug 5a with symidx not initialized? email 9fans?

*** bug 5a wrong prfile(), wrong line number. email 9fans?
port correct code from 5c in Lconv()?

*** EASY Always -> C_ALWAYS

*** Gen -> Operand, registr -> Register, zaddr -> outoperand
enum Registr (can Register?)
also Token chunk name -> token union

itab -> ttab
genval -> oval
cinit -> init
pinit -> pass_init
Sym -> Symbol
Sym_kind -> Symbol_kind



*** delete compat.c, inline the code mycreat, etc.

*** disambiguate Prog.reg and Adr.reg, choose different names
add some unions for abuse of same field?

*** use SYMIDX_NONE?

*** less: understand AHISTORY

*** introduce a D_ADDR? they abuse D_CONST I Think
for $ oreg



** draw

*** EASY screen -> desktop, or base layer? or root?
Baselayer!

*** EASY start renaming screen globals? draw_screen? screen_screen?
vga_screen?

**** big renames!! x_screen, screen -> layer, ...

*** lots of time they introduce local variable which alias
a field, but it leads to lots of boilerplate initializations.

*** comment all the opti, still works?
get rid of flushing opti
get rid of draw and windows opti, just draw on save everytime
get rid of windows stack opti, just draw in a painting fashion

** rio

*** EASY input -> winput? or current? or topw?
need save old value?

*** typedef uint text_cursor; or tcursor?
mcursor vs tcursor

** mk

*** rename files? word.c -> words.c

*** refactor did in a global!
(and check still no bugs!)

** 5c

*** use malloc instead of gethunk in cpp of 5c?
copy what I did for 5a?

*** put back full #pragma handling for 5c?

** Plan9

*** get rid of elf.h? (at least move it out of include/)
I don't have macho.h anyway
hmm but to bench 8c it might be good at one point to
generate elf

*** try compile with lib9.h on mac?
lib9.h -> libc.h and have a -Include that puts it first!
in CROSS/MacOSX ?

** Kencc

*** compare with otool -h

*** make inm work for macho binaries?
still does not work :(

** libcore

*** strcmp is really ugly
strcmp(s->name, mactab[i].macname) == 0)
bool string__equal()!
macro? would like inline function ... hmm would like ocamlopt that does
this for you!

what is string_equal in Go? They use strcmp too?

** ocaml in plan9 

*** compile ocaml stuff for plan9
so can test rio-in-ocaml!
which actually works!


** efuns

*** resume efuns under plan9!

**** resume compile ocaml under plan9

**** try compile efuns after all the recent modifs to efuns I made
maybe can add poor's man labels (just consider them as comment;
let recent ocaml do the checks)

* Runtime Problems
#see-also: regressions.txt

** kernel has pb if you touch the mouse during the boot

** kernel oops:
ctrl shift P ==> suice invalid address 0x0/0 in sys call pc= ...
what is that?

* Getting feedback, getting published

https://blog.datascienceheroes.com/how-to-self-publish-a-book/

** contact other publishers?
but need more books, and in a better state I think

*** MIT press? marie lee https://mitpress.mit.edu/content/marie-lee
cite TECS as major inspiration?

*** Michael K. Loukides <mikel@oreilly.com> (50% to famous author) Chetan?
 Bryan O'sullivan? Andrei?

*** other
cambridge univerisity press!
morgan kaufman
mcgraw hill

manning editions
no starch press

CRC press?
Springer? (last resort)

** self publish? 

*** read "Self-Publishing For Dummies" book

*** go with lulu.com? 
http://www.lulu.com/sell

*** kickstarter/indiegogo?

*** ex to follow for distribution?
http://dev.stephendiehl.com/fun/
self published?

*** See HN story about "Interpreter in Go"
createspace for printed stuff
gumroad for digital
https://www.nateberkopec.com/blog/2017/03/10/how-i-made-self-publishing-about-ruby-on-rails.html
https://news.ycombinator.com/item?id=13876514
  kickstarted, indiegogo, gumroad

*** advice on advertising self-publishing book:
http://arthur-johnston.com/hacker_writes_a_childrens_book/

** send to people?

Erling?
katrik?

Alan Kay? HARC?

Julia to Cosmo of Software heritage?

send to the guy who did "whole new world" video
https://www.destroyallsoftware.com/talks/a-whole-new-world

pichardie, ridoux, fradet, banatre
jarod, alok, julien
pike, russ, knuth
csapp authors

https://news.ycombinator.com/item?id=10572976

** contact HARC? via patrick saciglia? via linked-in friend? via carolina?

** prepare more things to discuss with publisher:

 - copyright issues?
   * copyright owner? 
   * if dont do full series? can I get back the copyright?
 - money issues
   * if series do good, augment percentage?
 - grouping of books? 1 with asm+linker+compiler? so not 18 but
   maybe 6 in total? fascicle a la Knuth?
 - english editors?
 - reviewers?
 - marketing?

 - contact Brian Kernighan? Part of the professional series?
   (like Hanson book, software tools, etc)

*** arguments for publisher

**** pro assembler/linker book

Not a toy. Powered plan9 used for years at Bell Labs.
And found new place in Go and Google.
So production-quality toolchain!

companies like Google/Facebook/Apple got pbs with assembler/linker toolchain.
Linker very slow. New machines, new infrastructure. binutils huge.
They invested money to make new one!

even llvm/clang decided finally to replace binutils. Sponsored by Apple,
made their own linker! lld.

Go used 5a/5l/5c internally. So google internally used binaries
produces by this toolchain (now Go switch to rewrite of those tools
in Go in 2015, but very similar code).
And Go powers an incrinsing numbers of services at Google,
but also in startups (e.g., Docker). .

Popular topic on HN. Many blog posts on ELF, toy hello world.

Trendy in research, see Oopsla paper on verified linking
(Xavier Leroy too formalized linking I think).

I could even generate code for Linux or mac OS or Windows (copy code
 in old version of Go).
Explain ELF! PE! Mach-O!

learn machine, for real! also float, mul64, shift.

I could also speak about how to make helloworld.s on Linux,
with a Real Stuff section! Same for linker. Like Hennessy and Patterson.
%real-world:

Also would be nice to have Further readings like in lcc book.

Can learn compiler a bit. Use more output of 5c -S so do
like in CSPP book, good insight in how compiler works.

By learning to write an assembler, you'll learn general techniques
useful in many programs. For instance, writing a lexer and parser,
error location, error management. Also debugging information
in output to precicely point back to original code, even when
code preprocessed. 
Learn also data structures: Lists, stacks, hash table.
And general algorithms: symbol table, def/use two-passes.
arith expression evaluator.

**** pro ARM

complicated x86, but now new opporunity, ARM! fundamental in phones,
become pervasive. So also learn about ARM!

Raspberry Pi! quite popular, including in publishing industry (many books).

A few classic books cover ARM now: hennessy patterson, in 2016!
 other book in 2014 about ARM assembly.
14 billions processors shipped in 2015.


**** argument pro plan9 or more generally pro non-mainsteam OSes

plan9 is quite popular on HN

plan9 programs, but many work on Linux, macos, windows, see plan9port!

Go used 5a/5l/5c internally! so Google!

xv6 is popular at MIT and all around! it's Unix, not even plan9!
 It's not Linux either, but it works.

**** arguments pro principia in general
code! master! fully understand!

learn from the master! software architecture for real!

learn data structures (hash table, lists, queues, graph, growing arrays)
algorithms (graph DFS, compression), 
parsing, 
lexing, 
error management,
debugging techniques.

Facebook, Google, they do those stuff: their own build system, compiler,
 debugger, network stack, kernel modifications, editors (well reuse
 open source components), database, etc.

education program: add exercises, nice extensions to the linker,
 assembler, nice projects for the students?

**** argument pro LP

more and more articles and blogs posted on HN where people use kinda
LP to explain quite some code.

A few books already in Addison-Wesley like that by Hanson
(C interfaces and implem and lcc book)

Software tools: 1976
 also John Lions classic comments on Unix v6? kernel 
Lcc: 1996
Principia: 2016 :)
=> every 20 years new wave :)

Also recent book about rendering that got an Oscar!

*** bundles

assembler + linker (+ machine | compiler)
graphics system + windowing system

compiler (including the macroprocessor)
libcore

kernel
network stack

builder + shell
debugger + profiler

editor
browser (great, but needs work)

ocaml
lex + yacc

utilities

** blog post?
Can finally trace and explain fully what happens when you type 'ls'! 

** Questions to Plan 9 people?

- plan 9? because unix v9? chapter 9 in programmer's manual? Section 9 in man?
- who are the authors of 5i? 5a? 5l? draw?
- why called rio? and 8-1/2?

- AEND?? reading syntax?
- symidx and symkind in ANAME entry? useful? redundant?
- why $ for constants in 5a? ok for $foo(SB) but why for all constants?
- why LPOOL?

- draw, Tom Duff coded parts?

also need discuss licensing issues, GPL compatible with creative commons?

** license: http://creativecommons.org/licenses/by-sa/4.0/
this one seems simple and good

use creative commons? like in llc.pdf? and atom manual?
 or bsd license; the bsd is so much shorter. Keep xix spirit, KISS
 even for the license.

* Literate programming

** less: cweb
seems nice, but not very compatible with latex, and automatic indexing
 seems fragile (but nice pretty printing!)

try also cweb.el?

*** try cweb-latex with figure verbatim, array, and gradually
add more complex stuff towards Make.nw

*** try cweb on toy example
split multi files @()@
special TOC @***
generate index?
good pretty printing of code? too much? help to read?

*** try on Make.nw? do a converter?

** less: spiderweb

*** use it for ocaml? so derive a tangle/weave for ocaml?
https://www.ctan.org/tex-archive/web/spiderweb?lang=en
or just use codegraph to generate the indexes by generating
appropriate .tex file? rewrite noweblatex?


* Extra books

** Compiler frontend (tiger)

*** understand linearization
LP split it

*** continue moving out code from Extra to Tiger.nw,

**** c-- generation chapter

*** change backend to 5a asm :) so can run under plan9 with 5i

**** register allocation

**** runtime support

**** gc

*** need uid? look in appel's book?

*** EASY fix the conflicts in the grammar

*** EASY get rid of all those mkXXX

** Intepreter.nw

*** switch to 2014 version? file not that much longer,
but better organized, more efficient,
and support call/cc

now that distributed first version, can now switch to other one
with same split, so also interesting to see evolution.

also maybe can do bench!

** Compiler backend (c--)
good to vary a bit, not always C code written by the same people :)
and also different language!

*** start migrate code from Cminusmins_extra.nw to Cminusminus.nw

*** weird: can not update to latests commons/ of pfff
get some linking errors

** Doom
see fabien sanglard sucess with game engine black book for wolfenstein

make it work on my Raspberry Pi :)
fast enough?

** Soldat

* Misc

** xv6: look at deps, cleanup? remove backward deps?
compile again? argh, cant use kencc

** Sam/acme? 
or rely more on efuns?

*** learn to use sam
