\section{[[include/]]}

\subsection*{[[include/common.out.h]]}

<<constant NSYM>>=
#define	NSYM	50
@

<<struct ieee>>=
struct	ieee
{
    long	l;	/* contains ls-man	0xffffffff */
    long	h;	/* contains sign	0x80000000
                    exp		0x7ff00000
                    ms-man	0x000fffff */
};
@


%-------------------------------------------------------------

<<include/common.out.h>>=

<<constant NSYM>>

// was originally in a xxx/y.out.h (and was always the same in all archi)
/*
 * this is the simulated IEEE floating point
 */
typedef	struct	ieee	Ieee;
<<struct ieee>>
@


\section{[[include/386/]]}

\subsection*{[[include/386/8.out.h]]}

<<constant NSNAME>>=
#define	NSNAME	8
@

<<constant NOPROF>>=
#define NOPROF	(1<<0)
@

<<constant DUPOK>>=
#define DUPOK	(1<<1)
@

<<constant NOSPLIT>>=
#define NOSPLIT	(1<<2)
@

<<enum as>>=
enum	as
{
    AXXX,
    AAAA,
    AAAD,
    AAAM,
    AAAS,
    AADCB,
    AADCL,
    AADCW,
    AADDB,
    AADDL,
    AADDW,
    AADJSP,
    AANDB,
    AANDL,
    AANDW,
    AARPL,
    ABOUNDL,
    ABOUNDW,
    ABSFL,
    ABSFW,
    ABSRL,
    ABSRW,
    ABTL,
    ABTW,
    ABTCL,
    ABTCW,
    ABTRL,
    ABTRW,
    ABTSL,
    ABTSW,
    ABYTE,
    ACALL,
    ACLC,
    ACLD,
    ACLI,
    ACLTS,
    ACMC,
    ACMPB,
    ACMPL,
    ACMPW,
    ACMPSB,
    ACMPSL,
    ACMPSW,
    ADAA,
    ADAS,
    ADATA,
    ADECB,
    ADECL,
    ADECW,
    ADIVB,
    ADIVL,
    ADIVW,
    AENTER,
    AGLOBL,
    AGOK,
    AHISTORY,
    AHLT,
    AIDIVB,
    AIDIVL,
    AIDIVW,
    AIMULB,
    AIMULL,
    AIMULW,
    AINB,
    AINL,
    AINW,
    AINCB,
    AINCL,
    AINCW,
    AINSB,
    AINSL,
    AINSW,
    AINT,
    AINTO,
    AIRETL,
    AIRETW,
    AJCC,
    AJCS,
    AJCXZ,
    AJEQ,
    AJGE,
    AJGT,
    AJHI,
    AJLE,
    AJLS,
    AJLT,
    AJMI,
    AJMP,
    AJNE,
    AJOC,
    AJOS,
    AJPC,
    AJPL,
    AJPS,
    ALAHF,
    ALARL,
    ALARW,
    ALEAL,
    ALEAW,
    ALEAVEL,
    ALEAVEW,
    ALOCK,
    ALODSB,
    ALODSL,
    ALODSW,
    ALONG,
    ALOOP,
    ALOOPEQ,
    ALOOPNE,
    ALSLL,
    ALSLW,
    AMOVB,
    AMOVL,
    AMOVW,
    AMOVBLSX,
    AMOVBLZX,
    AMOVBWSX,
    AMOVBWZX,
    AMOVWLSX,
    AMOVWLZX,
    AMOVSB,
    AMOVSL,
    AMOVSW,
    AMULB,
    AMULL,
    AMULW,
    ANAME,
    ANEGB,
    ANEGL,
    ANEGW,
    ANOP,
    ANOTB,
    ANOTL,
    ANOTW,
    AORB,
    AORL,
    AORW,
    AOUTB,
    AOUTL,
    AOUTW,
    AOUTSB,
    AOUTSL,
    AOUTSW,
    APOPAL,
    APOPAW,
    APOPFL,
    APOPFW,
    APOPL,
    APOPW,
    APUSHAL,
    APUSHAW,
    APUSHFL,
    APUSHFW,
    APUSHL,
    APUSHW,
    ARCLB,
    ARCLL,
    ARCLW,
    ARCRB,
    ARCRL,
    ARCRW,
    AREP,
    AREPN,
    ARET,
    AROLB,
    AROLL,
    AROLW,
    ARORB,
    ARORL,
    ARORW,
    ASAHF,
    ASALB,
    ASALL,
    ASALW,
    ASARB,
    ASARL,
    ASARW,
    ASBBB,
    ASBBL,
    ASBBW,
    ASCASB,
    ASCASL,
    ASCASW,
    ASETCC,
    ASETCS,
    ASETEQ,
    ASETGE,
    ASETGT,
    ASETHI,
    ASETLE,
    ASETLS,
    ASETLT,
    ASETMI,
    ASETNE,
    ASETOC,
    ASETOS,
    ASETPC,
    ASETPL,
    ASETPS,
    ACDQ,
    ACWD,
    ASHLB,
    ASHLL,
    ASHLW,
    ASHRB,
    ASHRL,
    ASHRW,
    ASTC,
    ASTD,
    ASTI,
    ASTOSB,
    ASTOSL,
    ASTOSW,
    ASUBB,
    ASUBL,
    ASUBW,
    ASYSCALL,
    ATESTB,
    ATESTL,
    ATESTW,
    ATEXT,
    AVERR,
    AVERW,
    AWAIT,
    AWORD,
    AXCHGB,
    AXCHGL,
    AXCHGW,
    AXLAT,
    AXORB,
    AXORL,
    AXORW,

    AFMOVB,
    AFMOVBP,
    AFMOVD,
    AFMOVDP,
    AFMOVF,
    AFMOVFP,
    AFMOVL,
    AFMOVLP,
    AFMOVV,
    AFMOVVP,
    AFMOVW,
    AFMOVWP,
    AFMOVX,
    AFMOVXP,

    AFCOMB,
    AFCOMBP,
    AFCOMD,
    AFCOMDP,
    AFCOMDPP,
    AFCOMF,
    AFCOMFP,
    AFCOML,
    AFCOMLP,
    AFCOMW,
    AFCOMWP,
    AFUCOM,
    AFUCOMP,
    AFUCOMPP,

    AFADDDP,
    AFADDW,
    AFADDL,
    AFADDF,
    AFADDD,

    AFMULDP,
    AFMULW,
    AFMULL,
    AFMULF,
    AFMULD,

    AFSUBDP,
    AFSUBW,
    AFSUBL,
    AFSUBF,
    AFSUBD,

    AFSUBRDP,
    AFSUBRW,
    AFSUBRL,
    AFSUBRF,
    AFSUBRD,

    AFDIVDP,
    AFDIVW,
    AFDIVL,
    AFDIVF,
    AFDIVD,

    AFDIVRDP,
    AFDIVRW,
    AFDIVRL,
    AFDIVRF,
    AFDIVRD,

    AFXCHD,
    AFFREE,

    AFLDCW,
    AFLDENV,
    AFRSTOR,
    AFSAVE,
    AFSTCW,
    AFSTENV,
    AFSTSW,

    AF2XM1,
    AFABS,
    AFCHS,
    AFCLEX,
    AFCOS,
    AFDECSTP,
    AFINCSTP,
    AFINIT,
    AFLD1,
    AFLDL2E,
    AFLDL2T,
    AFLDLG2,
    AFLDLN2,
    AFLDPI,
    AFLDZ,
    AFNOP,
    AFPATAN,
    AFPREM,
    AFPREM1,
    AFPTAN,
    AFRNDINT,
    AFSCALE,
    AFSIN,
    AFSINCOS,
    AFSQRT,
    AFTST,
    AFXAM,
    AFXTRACT,
    AFYL2X,
    AFYL2XP1,

    AEND,

    ADYNT,
    AINIT,

    ASIGNAME,

    AFCOMI,
    AFCOMIP,
    AFUCOMI,
    AFUCOMIP,
    ACMPXCHGB,
    ACMPXCHGL,
    ACMPXCHGW,

    /* conditional move */
    ACMOVLCC,
    ACMOVLCS,
    ACMOVLEQ,
    ACMOVLGE,
    ACMOVLGT,
    ACMOVLHI,
    ACMOVLLE,
    ACMOVLLS,
    ACMOVLLT,
    ACMOVLMI,
    ACMOVLNE,
    ACMOVLOC,
    ACMOVLOS,
    ACMOVLPC,
    ACMOVLPL,
    ACMOVLPS,
    ACMOVWCC,
    ACMOVWCS,
    ACMOVWEQ,
    ACMOVWGE,
    ACMOVWGT,
    ACMOVWHI,
    ACMOVWLE,
    ACMOVWLS,
    ACMOVWLT,
    ACMOVWMI,
    ACMOVWNE,
    ACMOVWOC,
    ACMOVWOS,
    ACMOVWPC,
    ACMOVWPL,
    ACMOVWPS,

    AFCMOVCC,
    AFCMOVCS,
    AFCMOVEQ,
    AFCMOVHI,
    AFCMOVLS,
    AFCMOVNE,
    AFCMOVNU,
    AFCMOVUN,

    /* add new operations here. nowhere else. here. */
    ALAST
};
@

<<enum _anon_>>=
enum
{
    D_AL		= 0,
    D_CL,
    D_DL,
    D_BL,

    D_AH		= 4,
    D_CH,
    D_DH,
    D_BH,

    D_AX		= 8,
    D_CX,
    D_DX,
    D_BX,
    D_SP,
    D_BP,
    D_SI,
    D_DI,

    D_F0		= 16,
    D_F7		= D_F0 + 7,

    D_CS		= 24,
    D_SS,
    D_DS,
    D_ES,
    D_FS,
    D_GS,

    D_GDTR,		/* global descriptor table register */
    D_IDTR,		/* interrupt descriptor table register */
    D_LDTR,		/* local descriptor table register */
    D_MSW,		/* machine status word */
    D_TASK,		/* task register */

    D_CR		= 35,
    D_DR		= 43,
    D_TR		= 51,

    D_NONE		= 59,

    D_BRANCH	= 60,
    D_EXTERN	= 61,
    D_STATIC	= 62,
    D_AUTO		= 63,
    D_PARAM		= 64,
    D_CONST		= 65,
    D_FCONST	= 66,
    D_SCONST	= 67,
    D_ADDR		= 68,

    D_FILE,
    D_FILE1,

    D_INDIR,	/* additive */

    D_CONST2 = D_INDIR+D_INDIR,

    D_SIZE,	/* 8l internal */

    T_TYPE		= 1<<0,
    T_INDEX		= 1<<1,
    T_OFFSET	= 1<<2,
    T_FCONST	= 1<<3,
    T_SYM		= 1<<4,
    T_SCONST	= 1<<5,
    T_OFFSET2	= 1<<6,
    T_GOTYPE	= 1<<7,

    REGARG		= -1,
    REGRET		= D_AX,
    FREGRET		= D_F0,
    REGSP		= D_SP,
    REGTMP		= D_DI,
};
@

<<constant SYMDEF>>=
/*
 * this is the ranlib header
 */
#define	SYMDEF	"__.SYMDEF"
@


%-------------------------------------------------------------

<<include/386/8.out.h>>=

<<constant NSNAME>>
<<constant NOPROF>>
<<constant DUPOK>>
<<constant NOSPLIT>>

<<enum as>>

<<enum _anon_>>

<<constant SYMDEF>>
@


\section{[[assemblers/misc/]]}

\subsection*{[[assemblers/misc/data2s.c]]}

<<function main>>=
void
main(int argc, char *argv[])
{
    Biobuf bin, bout;
    long len, slen;
    int c;

    if(argc != 2){
        fprint(2, "usage: data2s name\n");
        exits("usage");
    }
    Binit(&bin, 0, OREAD);
    Binit(&bout, 1, OWRITE);
    for(len=0; (c=Bgetc(&bin))!=Beof; len++){
        if((len&7) == 0)
            Bprint(&bout, "DATA %scode+%ld(SB)/8, $\"", argv[1], len);
        if(c)
            Bprint(&bout, "\\%uo", c);
        else
            Bprint(&bout, "\\z");
        if((len&7) == 7)
            Bprint(&bout, "\"\n");
    }
    slen = len;
    if(len & 7){
        while(len & 7){
            Bprint(&bout, "\\z");
            len++;
        }
        Bprint(&bout, "\"\n");
    }
    Bprint(&bout, "GLOBL %scode+0(SB), $%ld\n", argv[1], len);
    Bprint(&bout, "GLOBL %slen+0(SB), $4\n", argv[1]);
    Bprint(&bout, "DATA %slen+0(SB)/4, $%ld\n", argv[1], slen);
    exits(0);
}
@


%-------------------------------------------------------------

<<assemblers/misc/data2s.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>

<<function main>>
@


\section{[[assemblers/aa/]]}

\subsection*{[[assemblers/aa/aa.h]]}

<<constant MAXALIGN>>=
#define MAXALIGN 7
@

<<constant NSYMB>>=
#define	NSYMB		500
@

<<constant BUFSIZ>>=
#define	BUFSIZ		8192
@

<<constant HISTSZ>>=
#define	HISTSZ		20
@

<<constant NINCLUDE>>=
#define	NINCLUDE	10
@

<<constant NHUNK>>=
#define	NHUNK		10000
@

<<constant EOF>>=
#define	EOF		(-1)
@

<<constant IGN>>=
#define	IGN		(-2)
@

<<function GETC>>=
#define	GETC()		((--fi.c < 0)? filbuf(): *fi.p++ & 0xff)
@

<<constant NHASH>>=
#define	NHASH		503
@

<<constant STRINGSZ>>=
#define	STRINGSZ	200
@

<<struct Sym>>=
struct	Sym
{
    Sym*	link;

    Ref*	ref; // unused for 5a, matters?

    char*	macro;
    long	value; // vlong in va!!
    ushort	type;
    char	*name;
    char	sym;
};
@

<<constant S>>=
#define	S	((Sym*)0)
@

<<struct Ref>>=
// only for 8a actually
struct	Ref
{
    int	class;
};
@

<<struct Fi>>=
struct Fi
{
    char*	p;
    int	c;
};
@

<<struct Io>>=
struct	Io
{
    Io*	link;
    char	b[BUFSIZ];
    char*	p;
    short	c;
    short	f;
};
@

<<constant I>>=
#define	I	((Io*)0)
@

<<struct Htab>>=
struct Htab
{
    Sym*	sym;
    short	type;
};
@

<<struct Hist>>=
// Gen, Gen2?

struct	Hist
{
    Hist*	link;
    char*	name;
    long	line;
    long	offset;
};
@

<<constant H>>=
#define	H	((Hist*)0)
@

<<enum _anon_ (assemblers/aa/aa.h)>>=
/*
 *	system-dependent stuff from ../cc/compat.c
 */
enum	/* keep in synch with ../cc/cc.h */
{
    Plan9	= 1<<0,
    Unix	= 1<<1,
    Windows	= 1<<2
};
@


%-------------------------------------------------------------

<<assemblers/aa/aa.h>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <ctype.h>

// aa.h  is the generic part, the specific #include XXX/Y.out.h is done
// in Ya/a.h, e.g.:
//#include "386/8.out.h"
//#include "mips/v.out.h"
//#include "arm/5.out.h"
#include <common.out.h>

#pragma	lib	"../aa/aa.a$O"

// was originally in a XXX/Y.out.h (and was always the same in all archi)
// most of the content below was originally copy pasted in 8a/a.h, 5a/a.h, etc

typedef	struct	Sym	Sym;
typedef	struct	Ref	Ref;
typedef struct  Io Io;
typedef	struct	Hist	Hist;

<<constant MAXALIGN>>
<<constant NSYMB>>
<<constant BUFSIZ>>
<<constant HISTSZ>>
<<constant NINCLUDE>>
<<constant NHUNK>>
<<constant EOF>>
<<constant IGN>>
<<function GETC>>
<<constant NHASH>>
<<constant STRINGSZ>>


<<struct Sym>>
<<constant S>>

<<struct Ref>>

<<struct Fi>>
extern struct Fi fi;

<<struct Io>>
<<constant I>>

<<struct Htab>>
extern struct Htab h[NSYM];

<<struct Hist>>
<<constant H>>



// was in a.h
extern	Sym*	hash[NHASH];
extern	Hist*	hist;
extern	char*	hunk;
extern	char*	include[NINCLUDE];
extern	Io*	iofree;
extern	Io*	ionext;
extern	Io*	iostack;
extern	long	lineno;
extern	int	nerrors;
extern	long	nhunk;
extern	int	ninclude;
extern	char*	outfile;
extern	long	pc;
extern	int	peekc;
extern	int	sym;
extern	char	symb[NSYMB];
extern	int	thechar;

// for macbody, was in a.h
extern	char	debug[256];
extern	Hist*	ehist;
extern	int	newflag;
extern	long	thunk;

// for lexbody, was in a.h
int	getnsc(void);
void	gethunk(void);
void	yyerror(char*, ...);
void	linehist(char*, int);
Sym*	lookup(void);
void	syminit(Sym*);
int	filbuf(void);
void	domacro(void);
void	macexpand(Sym*, char*);
void	prfile(long);

// for macbody, was in a.h
int	getc(void);
void	unget(int);
Sym*	slookup(char*);
void	macund(void);
void	macdef(void);
void	macinc(void);
void	macprag(void);
void	maclin(void);
void	macif(int);
void	macend(void);
void*	mysbrk(ulong);

// for macbody, was in lexbody
void pragpack(void);
void pragfpround(void);
void pragprofile(void);
void pragvararg(void);
void* alloc(long n);
void pragincomplete(void);
void* allocn(void *p, long on, long n);
void	pushio(void);
void	newio(void);
void	newfile(char*, int);
void	errorexit(void);

// from lexbody.c
void ieeedtod(Ieee *ieee, double native);

<<enum _anon_ (assemblers/aa/aa.h)>>
@
%$


\subsection*{[[assemblers/aa/compat.c]]}

<<function myaccess>>=
int
myaccess(char *f)
{
    return access(f, AEXIST);
}
@

<<function mysbrk>>=
void*
mysbrk(ulong size)
{
    return sbrk(size);
}
@

<<function mycreat>>=
int
mycreat(char *n, int p)
{

    return create(n, 1, p);
}
@

<<function mywait>>=
int
mywait(int *s)
{
    int p;
    Waitmsg *w;

    if((w = wait()) == nil)
        return -1;
    else{
        p = w->pid;
        *s = 0;
        if(w->msg[0])
            *s = 1;
        free(w);
        return p;
    }
}
@

<<function mydup>>=
int
mydup(int f1, int f2)
{
    return dup(f1,f2);
}
@

<<function mypipe>>=
int
mypipe(int *fd)
{
    return pipe(fd);
}
@

<<function systemtype>>=
int
systemtype(int sys)
{
    return sys & Plan9;
}
@

<<function pathchar>>=
int
pathchar(void)
{
    return '/';
}
@

<<function mygetwd>>=
char*
mygetwd(char *path, int len)
{
    return getwd(path, len);
}
@

<<function myexec>>=
int
myexec(char *path, char *argv[])
{
    return exec(path, argv);
}
@

<<function myfork>>=
int
myfork(void)
{
    return fork();
}
@


%-------------------------------------------------------------

<<assemblers/aa/compat.c>>=
#include "aa.h"

<<function myaccess>>

<<function mysbrk>>

<<function mycreat>>

<<function mywait>>

<<function mydup>>

<<function mypipe>>

<<function systemtype>>

<<function pathchar>>

<<function mygetwd>>

<<function myexec>>

<<function myfork>>
@


\subsection*{[[assemblers/aa/globals.c]]}

<<global fi>>=
struct Fi fi;
@

<<global h>>=
struct Htab h[NSYM];
@

<<global debug>>=
char	debug[256];
@

<<global hash>>=
Sym*	hash[NHASH];
@

<<global Dlist>>=
char*	Dlist[30];
@

<<global nDlist>>=
int	nDlist;
@

<<global ehist>>=
Hist*	ehist;
@

<<global newflag>>=
int	newflag;
@

<<global hist>>=
Hist*	hist;
@

<<global hunk>>=
char*	hunk;
@

<<global include>>=
char*	include[NINCLUDE];
@

<<global iofree>>=
Io*	iofree;
@

<<global ionext>>=
Io*	ionext;
@

<<global iostack>>=
Io*	iostack;
@

<<global lineno>>=
long	lineno;
@

<<global nerrors>>=
int	nerrors;
@

<<global nhunk>>=
long	nhunk;
@

<<global ninclude>>=
int	ninclude;
@

<<global outfile>>=
char*	outfile;
@

<<global pass>>=
int	pass;
@

<<global pathname>>=
char*	pathname;
@

<<global pc>>=
long	pc;
@

<<global peekc>>=
int	peekc;
@

<<global sym>>=
int	sym;
@

<<global symb>>=
char	symb[NSYMB];
@

<<global thechar>>=
int	thechar;
@

<<global thestring>>=
char*	thestring;
@

<<global thunk>>=
long	thunk;
@

<<global obuf>>=
Biobuf	obuf;
@


%-------------------------------------------------------------

<<assemblers/aa/globals.c>>=
#include "aa.h"

<<global fi>>
<<global h>>

<<global debug>>
<<global hash>>
<<global Dlist>>
<<global nDlist>>
<<global ehist>>
<<global newflag>>
<<global hist>>
<<global hunk>>
<<global include>>
<<global iofree>>
<<global ionext>>
<<global iostack>>
<<global lineno>>
<<global nerrors>>
<<global nhunk>>
<<global ninclude>>
<<global outfile>>
<<global pass>>
<<global pathname>>
<<global pc>>
<<global peekc>>
<<global sym>>
<<global symb>>
<<global thechar>>
<<global thestring>>
<<global thunk>>
<<global obuf>>
@


\subsection*{[[assemblers/aa/lexbody.c]]}

<<function pragpack>>=
/*
 * common code for all the assemblers
 */

void
pragpack(void)
{
    while(getnsc() != '\n')
        ;
}
@

<<function pragvararg>>=
void
pragvararg(void)
{
    while(getnsc() != '\n')
        ;
}
@

<<function pragfpround>>=
void
pragfpround(void)
{
    while(getnsc() != '\n')
        ;
}
@

<<function pragprofile>>=
void
pragprofile(void)
{
    while(getnsc() != '\n')
        ;
}
@

<<function pragincomplete>>=
void
pragincomplete(void)
{
    while(getnsc() != '\n')
        ;
}
@

<<function alloc>>=
/*
 * real allocs
 */
void*
alloc(long n)
{
    void *p;

    while((uintptr)hunk & MAXALIGN) {
        hunk++;
        nhunk--;
    }
    while(nhunk < n)
        gethunk();
    p = hunk;
    nhunk -= n;
    hunk += n;
    return p;
}
@

<<function allocn>>=
void*
allocn(void *p, long on, long n)
{
    void *q;

    q = (uchar*)p + on;
    if(q != hunk || nhunk < n) {
        while(nhunk < on+n)
            gethunk();
        memmove(hunk, p, on);
        p = hunk;
        hunk += on;
        nhunk -= on;
    }
    hunk += n;
    nhunk -= n;
    return p;
}
@

<<function setinclude>>=
void
setinclude(char *p)
{
    int i;

    if(p == 0)
        return;
    for(i=1; i < ninclude; i++)
        if(strcmp(p, include[i]) == 0)
            return;

    if(ninclude >= nelem(include)) {
        yyerror("ninclude too small %d", nelem(include));
        exits("ninclude");
    }
    include[ninclude++] = p;
}
@

<<function errorexit>>=
void
errorexit(void)
{

    if(outfile)
        remove(outfile);
    exits("error");
}
@

<<function pushio>>=
void
pushio(void)
{
    Io *i;

    i = iostack;
    if(i == I) {
        yyerror("botch in pushio");
        errorexit();
    }
    i->p = fi.p;
    i->c = fi.c;
}
@

<<function newio>>=
void
newio(void)
{
    Io *i;
    static int pushdepth = 0;

    i = iofree;
    if(i == I) {
        pushdepth++;
        if(pushdepth > 1000) {
            yyerror("macro/io expansion too deep");
            errorexit();
        }
        i = alloc(sizeof(*i));
    } else
        iofree = i->link;
    i->c = 0;
    i->f = -1;
    ionext = i;
}
@

<<function newfile>>=
void
newfile(char *s, int f)
{
    Io *i;

    i = ionext;
    i->link = iostack;
    iostack = i;
    i->f = f;
    if(f < 0)
        i->f = open(s, 0);
    if(i->f < 0) {
        yyerror("%ca: %r: %s", thechar, s);
        errorexit();
    }
    fi.c = 0;
    linehist(s, 0);
}
@

<<function slookup>>=
Sym*
slookup(char *s)
{

    strcpy(symb, s);
    return lookup();
}
@

<<function lookup>>=
Sym*
lookup(void)
{
    Sym *s;
    long h;
    char *p;
    int c, l;

    h = 0;
    for(p=symb; c = *p; p++)
        h = h+h+h + c;
    l = (p - symb) + 1;
    if(h < 0)
        h = ~h;
    h %= NHASH;
    c = symb[0];
    for(s = hash[h]; s != S; s = s->link) {
        if(s->name[0] != c)
            continue;
        if(memcmp(s->name, symb, l) == 0)
            return s;
    }
    s = alloc(sizeof(*s));
    s->name = alloc(l);
    memmove(s->name, symb, l);

    s->link = hash[h];
    hash[h] = s;
    syminit(s);
    return s;
}
@

<<function getc>>=
//}

int
getc(void)
{
    int c;

    c = peekc;
    if(c != IGN) {
        peekc = IGN;
        return c;
    }
    c = GETC();
    if(c == '\n')
        lineno++;
    if(c == EOF) {
        yyerror("End of file");
        errorexit();
    }
    return c;
}
@

<<function getnsc>>=
int
getnsc(void)
{
    int c;

    for(;;) {
        c = getc();
        if(!isspace(c) || c == '\n')
            return c;
    }
}
@

<<function unget>>=
void
unget(int c)
{

    peekc = c;
    if(c == '\n')
        lineno--;
}
@

<<function escchar>>=
int
escchar(int e)
{
    int c, l;

loop:
    c = getc();
    if(c == '\n') {
        yyerror("newline in string");
        return EOF;
    }
    if(c != '\\') {
        if(c == e)
            return EOF;
        return c;
    }
    c = getc();
    if(c >= '0' && c <= '7') {
        l = c - '0';
        c = getc();
        if(c >= '0' && c <= '7') {
            l = l*8 + c-'0';
            c = getc();
            if(c >= '0' && c <= '7') {
                l = l*8 + c-'0';
                return l;
            }
        }
        peekc = c;
        return l;
    }
    switch(c)
    {
    case '\n':	goto loop;
    case 'n':	return '\n';
    case 't':	return '\t';
    case 'b':	return '\b';
    case 'r':	return '\r';
    case 'f':	return '\f';
    case 'a':	return 0x07;
    case 'v':	return 0x0b;
    case 'z':	return 0x00;
    }
    return c;
}
@

<<function pinit>>=
void
pinit(char *f)
{
    int i;
    Sym *s;

    lineno = 1;
    newio();
    newfile(f, -1);
    pc = 0;
    peekc = IGN;
    sym = 1;
    for(i=0; i<NSYM; i++) {
        h[i].type = 0;
        h[i].sym = S;
    }
    for(i=0; i<NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            s->macro = 0;
}
@

<<function filbuf>>=
int
filbuf(void)
{
    Io *i;

loop:
    i = iostack;
    if(i == I)
        return EOF;
    if(i->f < 0)
        goto pop;
    fi.c = read(i->f, i->b, BUFSIZ) - 1;
    if(fi.c < 0) {
        close(i->f);
        linehist(0, 0);
        goto pop;
    }
    fi.p = i->b + 1;
    return i->b[0];

pop:
    iostack = i->link;
    i->link = iofree;
    iofree = i;
    i = iostack;
    if(i == I)
        return EOF;
    fi.p = i->p;
    fi.c = i->c;
    if(--fi.c < 0)
        goto loop;
    return *fi.p++;
}
@

<<function yyerror>>=
void
yyerror(char *a, ...)
{
    char buf[200];
    va_list arg;

    /*
     * hack to intercept message from yaccpar
     */
    if(strcmp(a, "syntax error") == 0) {
        yyerror("syntax error, last name: %s", symb);
        return;
    }
    prfile(lineno);
    va_start(arg, a);
    vseprint(buf, buf+sizeof(buf), a, arg);
    va_end(arg);
    print("%s\n", buf);
    nerrors++;
    if(nerrors > 10) {
        print("too many errors\n");
        errorexit();
    }
}
@

<<function prfile>>=
void
prfile(long l)
{
    int i, n;
    Hist a[HISTSZ], *h;
    long d;

    n = 0;
    for(h = hist; h != H; h = h->link) {
        if(l < h->line)
            break;
        if(h->name) {
            if(h->offset == 0) {
                if(n >= 0 && n < HISTSZ)
                    a[n] = *h;
                n++;
                continue;
            }
            if(n > 0 && n < HISTSZ)
                if(a[n-1].offset == 0) {
                    a[n] = *h;
                    n++;
                } else
                    a[n-1] = *h;
            continue;
        }
        n--;
        if(n >= 0 && n < HISTSZ) {
            d = h->line - a[n].line;
            for(i=0; i<n; i++)
                a[i].line += d;
        }
    }
    if(n > HISTSZ)
        n = HISTSZ;
    for(i=0; i<n; i++)
        print("%s:%ld ", a[i].name, (long)(l-a[i].line+a[i].offset+1));
}
@

<<function ieeedtod>>=
void
ieeedtod(Ieee *ieee, double native)
{
    double fr, ho, f;
    int exp;

    if(native < 0) {
        ieeedtod(ieee, -native);
        ieee->h |= 0x80000000L;
        return;
    }
    if(native == 0) {
        ieee->l = 0;
        ieee->h = 0;
        return;
    }
    fr = frexp(native, &exp);
    f = 2097152L;		/* shouldnt use fp constants here */
    fr = modf(fr*f, &ho);
    ieee->h = ho;
    ieee->h &= 0xfffffL;
    ieee->h |= (exp+1022L) << 20;
    f = 65536L;
    fr = modf(fr*f, &ho);
    ieee->l = ho;
    ieee->l <<= 16;
    ieee->l |= (long)(fr*f);
}
@


%-------------------------------------------------------------

<<assemblers/aa/lexbody.c>>=
#include "aa.h"

<<function pragpack>>

<<function pragvararg>>

<<function pragfpround>>

<<function pragprofile>>

<<function pragincomplete>>

<<function alloc>>

<<function allocn>>

<<function setinclude>>

<<function errorexit>>

<<function pushio>>

<<function newio>>

<<function newfile>>

<<function slookup>>

<<function lookup>>

//long
//yylex(void)
//{
//	int c, c1;
//	char *cp;
//	Sym *s;
//
//	c = peekc;
//	if(c != IGN) {
//		peekc = IGN;
//		goto l1;
//	}
//l0:
//	c = GETC();
//
//l1:
//	if(c == EOF) {
//		peekc = EOF;
//		return -1;
//	}
//	if(isspace(c)) {
//		if(c == '\n') {
//			lineno++;
//			return ';';
//		}
//		goto l0;
//	}
//	if(isalpha(c))
//		goto talph;
//	if(isdigit(c))
//		goto tnum;
//	switch(c)
//	{
//	case '\n':
//		lineno++;
//		return ';';
//
//	case '#':
//		domacro();
//		goto l0;
//
//	case '.':
//		c = GETC();
//		if(isalpha(c)) {
//			cp = symb;
//			*cp++ = '.';
//			goto aloop;
//		}
//		if(isdigit(c)) {
//			cp = symb;
//			*cp++ = '.';
//			goto casedot;
//		}
//		peekc = c;
//		return '.';
//
//	talph:
//	case '_':
//	case '@':
//		cp = symb;
//
//	aloop:
//		*cp++ = c;
//		c = GETC();
//		if(isalpha(c) || isdigit(c) || c == '_' || c == '$')
//			goto aloop;
//		*cp = 0;
//		peekc = c;
//		s = lookup();
//		if(s->macro) {
//			newio();
//			cp = ionext->b;
//			macexpand(s, cp);
//			pushio();
//			ionext->link = iostack;
//			iostack = ionext;
//			fi.p = cp;
//			fi.c = strlen(cp);
//			if(peekc != IGN) {
//				cp[fi.c++] = peekc;
//				cp[fi.c] = 0;
//				peekc = IGN;
//			}
//			goto l0;
//		}
//		if(s->type == 0)
//			s->type = LNAME;
//		if(s->type == LNAME ||
//		   s->type == LVAR ||
//		   s->type == LLAB) {
//			yylval.sym = s;
//			return s->type;
//		}
//		yylval.lval = s->value;
//		return s->type;
//
//	tnum:
//		cp = symb;
//		if(c != '0')
//			goto dc;
//		*cp++ = c;
//		c = GETC();
//		c1 = 3;
//		if(c == 'x' || c == 'X') {
//			c1 = 4;
//			c = GETC();
//		} else
//		if(c < '0' || c > '7')
//			goto dc;
//		yylval.lval = 0;
//		for(;;) {
//			if(c >= '0' && c <= '9') {
//				if(c > '7' && c1 == 3)
//					break;
//				yylval.lval <<= c1;
//				yylval.lval += c - '0';
//				c = GETC();
//				continue;
//			}
//			if(c1 == 3)
//				break;
//			if(c >= 'A' && c <= 'F')
//				c += 'a' - 'A';
//			if(c >= 'a' && c <= 'f') {
//				yylval.lval <<= c1;
//				yylval.lval += c - 'a' + 10;
//				c = GETC();
//				continue;
//			}
//			break;
//		}
//		goto ncu;
//
//	dc:
//		for(;;) {
//			if(!isdigit(c))
//				break;
//			*cp++ = c;
//			c = GETC();
//		}
//		if(c == '.')
//			goto casedot;
//		if(c == 'e' || c == 'E')
//			goto casee;
//		*cp = 0;
//		if(sizeof(yylval.lval) == sizeof(vlong))
//			yylval.lval = strtoll(symb, nil, 10);
//		else
//			yylval.lval = strtol(symb, nil, 10);
//
//	ncu:
//		while(c == 'U' || c == 'u' || c == 'l' || c == 'L')
//			c = GETC();
//		peekc = c;
//		return LCONST;
//
//	casedot:
//		for(;;) {
//			*cp++ = c;
//			c = GETC();
//			if(!isdigit(c))
//				break;
//		}
//		if(c == 'e' || c == 'E')
//			goto casee;
//		goto caseout;
//
//	casee:
//		*cp++ = 'e';
//		c = GETC();
//		if(c == '+' || c == '-') {
//			*cp++ = c;
//			c = GETC();
//		}
//		while(isdigit(c)) {
//			*cp++ = c;
//			c = GETC();
//		}
//
//	caseout:
//		*cp = 0;
//		peekc = c;
//		if(FPCHIP) {
//			yylval.dval = atof(symb);
//			return LFCONST;
//		}
//		yyerror("assembler cannot interpret fp constants");
//		yylval.lval = 1L;
//		return LCONST;
//
//	case '"':
//		memcpy(yylval.sval, nullgen.sval, sizeof(yylval.sval));
//		cp = yylval.sval;
//		c1 = 0;
//		for(;;) {
//			c = escchar('"');
//			if(c == EOF)
//				break;
//			if(c1 < sizeof(yylval.sval))
//				*cp++ = c;
//			c1++;
//		}
//		if(c1 > sizeof(yylval.sval))
//			yyerror("string constant too long");
//		return LSCONST;
//
//	case '\'':
//		c = escchar('\'');
//		if(c == EOF)
//			c = '\'';
//		if(escchar('\'') != EOF)
//			yyerror("missing '");
//		yylval.lval = c;
//		return LCONST;
//
//	case '/':
//		c1 = GETC();
//		if(c1 == '/') {
//			for(;;) {
//				c = GETC();
//				if(c == '\n')
//					goto l1;
//				if(c == EOF) {
//					yyerror("eof in comment");
//					errorexit();
//				}
//			}
//		}
//		if(c1 == '*') {
//			for(;;) {
//				c = GETC();
//				while(c == '*') {
//					c = GETC();
//					if(c == '/')
//						goto l0;
//				}
//				if(c == EOF) {
//					yyerror("eof in comment");
//					errorexit();
//				}
//				if(c == '\n')
//					lineno++;
//			}
//		}
//		break;
//
//	default:
//		return c;
//	}
//	peekc = c1;
//	return c;
<<function getc>>

<<function getnsc>>

<<function unget>>

<<function escchar>>

<<function pinit>>

<<function filbuf>>

<<function yyerror>>

<<function prfile>>

<<function ieeedtod>>
@
%$

\subsection*{[[assemblers/aa/macbody.c]]}

<<constant VARMAC>>=
#define VARMAC 0x80
@

<<function getnsn>>=
long
getnsn(void)
{
    long n;
    int c;

    c = getnsc();
    if(c < '0' || c > '9')
        return -1;
    n = 0;
    while(c >= '0' && c <= '9') {
        n = n*10 + c-'0';
        c = getc();
    }
    unget(c);
    return n;
}
@

<<function getsym>>=
Sym*
getsym(void)
{
    int c;
    char *cp;

    c = getnsc();
    if(!isalpha(c) && c != '_' && c < Runeself) {
        unget(c);
        return S;
    }
    for(cp = symb;;) {
        if(cp <= symb+NSYMB-4)
            *cp++ = c;
        c = getc();
        if(isalnum(c) || c == '_' || c >= Runeself)
            continue;
        unget(c);
        break;
    }
    *cp = 0;
    if(cp > symb+NSYMB-4)
        yyerror("symbol too large: %s", symb);
    return lookup();
}
@

<<function getsymdots>>=
Sym*
getsymdots(int *dots)
{
    int c;
    Sym *s;

    s = getsym();
    if(s != S)
        return s;

    c = getnsc();
    if(c != '.'){
        unget(c);
        return S;
    }
    if(getc() != '.' || getc() != '.')
        yyerror("bad dots in macro");
    *dots = 1;
    return slookup("__VA_ARGS__");
}
@

<<function getcom>>=
int
getcom(void)
{
    int c;

    for(;;) {
        c = getnsc();
        if(c != '/')
            break;
        c = getc();
        if(c == '/') {
            while(c != '\n')
                c = getc();
            break;
        }
        if(c != '*')
            break;
        c = getc();
        for(;;) {
            if(c == '*') {
                c = getc();
                if(c != '/')
                    continue;
                c = getc();
                break;
            }
            if(c == '\n') {
                yyerror("comment across newline");
                break;
            }
            c = getc();
        }
        if(c == '\n')
            break;
    }
    return c;
}
@

<<function dodefine>>=
void
dodefine(char *cp)
{
    Sym *s;
    char *p;
    long l;

    strcpy(symb, cp);
    p = strchr(symb, '=');
    if(p) {
        *p++ = 0;
        s = lookup();
        l = strlen(p) + 2;	/* +1 null, +1 nargs */
        while(l & 3)
            l++;
        while(nhunk < l)
            gethunk();
        *hunk = 0;
        strcpy(hunk+1, p);
        s->macro = hunk;
        hunk += l;
        nhunk -= l;
    } else {
        s = lookup();
        s->macro = "\0001";	/* \000 is nargs */
    }
    if(debug['m'])
        print("#define (-D) %s %s\n", s->name, s->macro+1);
}
@

<<global mactab>>=
struct
{
    char	*macname;
    void	(*macf)(void);
} mactab[] =
{
    "ifdef",	0,	/* macif(0) */
    "ifndef",	0,	/* macif(1) */
    "else",		0,	/* macif(2) */

    "line",		maclin,
    "define",	macdef,
    "include",	macinc,
    "undef",	macund,

    "pragma",	macprag,
    "endif",	macend,
    0
};
@

<<function domacro>>=
void
domacro(void)
{
    int i;
    Sym *s;

    s = getsym();
    if(s == S)
        s = slookup("endif");
    for(i=0; mactab[i].macname; i++)
        if(strcmp(s->name, mactab[i].macname) == 0) {
            if(mactab[i].macf)
                (*mactab[i].macf)();
            else
                macif(i);
            return;
        }
    yyerror("unknown #: %s", s->name);
    macend();
}
@

<<function macund>>=
void
macund(void)
{
    Sym *s;

    s = getsym();
    macend();
    if(s == S) {
        yyerror("syntax in #undef");
        return;
    }
    s->macro = 0;
}
@

<<constant NARG>>=
#define	NARG	25
@

<<function macdef>>=
void
macdef(void)
{
    Sym *s, *a;
    char *args[NARG], *np, *base;
    int n, i, c, len, dots;
    int ischr;

    s = getsym();
    if(s == S)
        goto bad;
    if(s->macro)
        yyerror("macro redefined: %s", s->name);
    c = getc();
    n = -1;
    dots = 0;
    if(c == '(') {
        n++;
        c = getnsc();
        if(c != ')') {
            unget(c);
            for(;;) {
                a = getsymdots(&dots);
                if(a == S)
                    goto bad;
                if(n >= NARG) {
                    yyerror("too many arguments in #define: %s", s->name);
                    goto bad;
                }
                args[n++] = a->name;
                c = getnsc();
                if(c == ')')
                    break;
                if(c != ',' || dots)
                    goto bad;
            }
        }
        c = getc();
    }
    if(isspace(c))
        if(c != '\n')
            c = getnsc();
    base = hunk;
    len = 1;
    ischr = 0;
    for(;;) {
        if(isalpha(c) || c == '_') {
            np = symb;
            *np++ = c;
            c = getc();
            while(isalnum(c) || c == '_') {
                *np++ = c;
                c = getc();
            }
            *np = 0;
            for(i=0; i<n; i++)
                if(strcmp(symb, args[i]) == 0)
                    break;
            if(i >= n) {
                i = strlen(symb);
                base = allocn(base, len, i);
                memcpy(base+len, symb, i);
                len += i;
                continue;
            }
            base = allocn(base, len, 2);
            base[len++] = '#';
            base[len++] = 'a' + i;
            continue;
        }
        if(ischr){
            if(c == '\\'){ 
                base = allocn(base, len, 1);
                base[len++] = c;
                c = getc();
            }else if(c == ischr)
                ischr = 0;
        }else{
            if(c == '"' || c == '\''){
                base = allocn(base, len, 1);
                base[len++] = c;
                ischr = c;
                c = getc();
                continue;
            }
            if(c == '/') {
                c = getc();
                if(c == '/'){
                    c = getc();
                    for(;;) {
                        if(c == '\n')
                            break;
                        c = getc();
                    }
                    continue;
                }
                if(c == '*'){
                    c = getc();
                    for(;;) {
                        if(c == '*') {
                            c = getc();
                            if(c != '/')
                                continue;
                            c = getc();
                            break;
                        }
                        if(c == '\n') {
                            yyerror("comment and newline in define: %s", s->name);
                            break;
                        }
                        c = getc();
                    }
                    continue;
                }
                base = allocn(base, len, 1);
                base[len++] = '/';
                continue;
            }
        }
        if(c == '\\') {
            c = getc();
            if(c == '\n') {
                c = getc();
                continue;
            }
            else if(c == '\r') {
                c = getc();
                if(c == '\n') {
                    c = getc();
                    continue;
                }
            }
            base = allocn(base, len, 1);
            base[len++] = '\\';
            continue;
        }
        if(c == '\n')
            break;
        if(c == '#')
        if(n > 0) {
            base = allocn(base, len, 1);
            base[len++] = c;
        }
        base = allocn(base, len, 1);
        base[len++] = c;
        c = ((--fi.c < 0)? filbuf(): (*fi.p++ & 0xff));
        if(c == '\n')
            lineno++;
        if(c == -1) {
            yyerror("eof in a macro: %s", s->name);
            break;
        }
    }
    do {
        base = allocn(base, len, 1);
        base[len++] = 0;
    } while(len & 3);

    *base = n+1;
    if(dots)
        *base |= VARMAC;
    s->macro = base;
    if(debug['m'])
        print("#define %s %s\n", s->name, s->macro+1);
    return;

bad:
    if(s == S)
        yyerror("syntax in #define");
    else
        yyerror("syntax in #define: %s", s->name);
    macend();
}
@

<<function macexpand>>=
void
macexpand(Sym *s, char *b)
{
    char buf[2000];
    int n, l, c, nargs;
    char *arg[NARG], *cp, *ob, *ecp, dots;

    ob = b;
    if(*s->macro == 0) {
        strcpy(b, s->macro+1);
        if(debug['m'])
            print("#expand %s %s\n", s->name, ob);
        return;
    }
    
    nargs = (char)(*s->macro & ~VARMAC) - 1;
    dots = *s->macro & VARMAC;

    c = getnsc();
    if(c != '(')
        goto bad;
    n = 0;
    c = getc();
    if(c != ')') {
        unget(c);
        l = 0;
        cp = buf;
        ecp = cp + sizeof(buf)-4;
        arg[n++] = cp;
        for(;;) {
            if(cp >= ecp)
                goto toobig;
            c = getc();
            if(c == '"')
                for(;;) {
                    if(cp >= ecp)
                        goto toobig;
                    *cp++ = c;
                    c = getc();
                    if(c == '\\') {
                        *cp++ = c;
                        c = getc();
                        continue;
                    }
                    if(c == '\n')
                        goto bad;
                    if(c == '"')
                        break;
                }
            if(c == '\'')
                for(;;) {
                    if(cp >= ecp)
                        goto toobig;
                    *cp++ = c;
                    c = getc();
                    if(c == '\\') {
                        *cp++ = c;
                        c = getc();
                        continue;
                    }
                    if(c == '\n')
                        goto bad;
                    if(c == '\'')
                        break;
                }
            if(c == '/') {
                c = getc();
                switch(c) {
                case '*':
                    for(;;) {
                        c = getc();
                        if(c == '*') {
                            c = getc();
                            if(c == '/')
                                break;
                        }
                    }
                    *cp++ = ' ';
                    continue;
                case '/':
                    while((c = getc()) != '\n')
                        ;
                    break;
                default:
                    unget(c);
                    c = '/';
                }
            }
            if(l == 0) {
                if(c == ',') {
                    if(n == nargs && dots) {
                        *cp++ = ',';
                        continue;
                    }
                    *cp++ = 0;
                    arg[n++] = cp;
                    if(n > nargs)
                        break;
                    continue;
                }
                if(c == ')')
                    break;
            }
            if(c == '\n')
                c = ' ';
            *cp++ = c;
            if(c == '(')
                l++;
            if(c == ')')
                l--;
        }
        *cp = 0;
    }
    if(n != nargs) {
        yyerror("argument mismatch expanding: %s", s->name);
        *b = 0;
        return;
    }
    cp = s->macro+1;
    for(;;) {
        c = *cp++;
        if(c == '\n')
            c = ' ';
        if(c != '#') {
            *b++ = c;
            if(c == 0)
                break;
            continue;
        }
        c = *cp++;
        if(c == 0)
            goto bad;
        if(c == '#') {
            *b++ = c;
            continue;
        }
        c -= 'a';
        if(c < 0 || c >= n)
            continue;
        strcpy(b, arg[c]);
        b += strlen(arg[c]);
    }
    *b = 0;
    if(debug['m'])
        print("#expand %s %s\n", s->name, ob);
    return;

bad:
    yyerror("syntax in macro expansion: %s", s->name);
    *b = 0;
    return;

toobig:
    yyerror("too much text in macro expansion: %s", s->name);
    *b = 0;
}
@

<<function macinc>>=
void
macinc(void)
{
    int c0, c, i, f;
    char str[STRINGSZ], *hp;

    c0 = getnsc();
    if(c0 != '"') {
        c = c0;
        if(c0 != '<')
            goto bad;
        c0 = '>';
    }
    for(hp = str;;) {
        c = getc();
        if(c == c0)
            break;
        if(c == '\n')
            goto bad;
        *hp++ = c;
    }
    *hp = 0;

    c = getcom();
    if(c != '\n')
        goto bad;

    f = -1;
    for(i=0; i<ninclude; i++) {
        if(i == 0 && c0 == '>')
            continue;
        strcpy(symb, include[i]);
        strcat(symb, "/");
        if(strcmp(symb, "./") == 0)
            symb[0] = 0;
        strcat(symb, str);
        f = open(symb, 0);
        if(f >= 0)
            break;
    }
    if(f < 0)
        strcpy(symb, str);
    c = strlen(symb) + 1;
    while(c & 3)
        c++;
    while(nhunk < c)
        gethunk();
    hp = hunk;
    memcpy(hunk, symb, c);
    nhunk -= c;
    hunk += c;
    newio();
    pushio();
    newfile(hp, f);
    return;

bad:
    unget(c);
    yyerror("syntax in #include");
    macend();
}
@

<<function maclin>>=
void
maclin(void)
{
    char *cp;
    int c;
    long n;

    n = getnsn();
    c = getc();
    if(n < 0)
        goto bad;

    for(;;) {
        if(c == ' ' || c == '\t') {
            c = getc();
            continue;
        }
        if(c == '"')
            break;
        if(c == '\n') {
            strcpy(symb, "<noname>");
            goto nn;
        }
        goto bad;
    }
    cp = symb;
    for(;;) {
        c = getc();
        if(c == '"')
            break;
        *cp++ = c;
    }
    *cp = 0;
    c = getcom();
    if(c != '\n')
        goto bad;

nn:
    c = strlen(symb) + 1;
    while(c & 3)
        c++;
    while(nhunk < c)
        gethunk();
    cp = hunk;
    memcpy(hunk, symb, c);
    nhunk -= c;
    hunk += c;
    linehist(cp, n);
    return;

bad:
    unget(c);
    yyerror("syntax in #line");
    macend();
}
@

<<function macif>>=
void
macif(int f)
{
    int c, l, bol;
    Sym *s;

    if(f == 2)
        goto skip;
    s = getsym();
    if(s == S)
        goto bad;
    if(getcom() != '\n')
        goto bad;
    if((s->macro != 0) ^ f)
        return;

skip:
    bol = 1;
    l = 0;
    for(;;) {
        c = getc();
        if(c != '#') {
            if(!isspace(c))
                bol = 0;
            if(c == '\n')
                bol = 1;
            continue;
        }
        if(!bol)
            continue;
        s = getsym();
        if(s == S)
            continue;
        if(strcmp(s->name, "endif") == 0) {
            if(l) {
                l--;
                continue;
            }
            macend();
            return;
        }
        if(strcmp(s->name, "ifdef") == 0 || strcmp(s->name, "ifndef") == 0) {
            l++;
            continue;
        }
        if(l == 0 && f != 2 && strcmp(s->name, "else") == 0) {
            macend();
            return;
        }
    }

bad:
    yyerror("syntax in #if(n)def");
    macend();
}
@

<<function macprag>>=
void
macprag(void)
{
    Sym *s;
    int c0, c;
    char *hp;
    Hist *h;

    s = getsym();

    if(s && strcmp(s->name, "lib") == 0)
        goto praglib;
    if(s && strcmp(s->name, "pack") == 0) {
        pragpack();
        return;
    }
    if(s && strcmp(s->name, "fpround") == 0) {
        pragfpround();
        return;
    }
    if(s && strcmp(s->name, "profile") == 0) {
        pragprofile();
        return;
    }
    if(s && strcmp(s->name, "varargck") == 0) {
        pragvararg();
        return;
    }
    if(s && strcmp(s->name, "incomplete") == 0) {
        pragincomplete();
        return;
    }
    while(getnsc() != '\n')
        ;
    return;

praglib:
    c0 = getnsc();
    if(c0 != '"') {
        c = c0;
        if(c0 != '<')
            goto bad;
        c0 = '>';
    }
    for(hp = symb;;) {
        c = getc();
        if(c == c0)
            break;
        if(c == '\n')
            goto bad;
        *hp++ = c;
    }
    *hp = 0;
    c = getcom();
    if(c != '\n')
        goto bad;

    /*
     * put pragma-line in as a funny history 
     */
    c = strlen(symb) + 1;
    while(c & 3)
        c++;
    while(nhunk < c)
        gethunk();
    hp = hunk;
    memcpy(hunk, symb, c);
    nhunk -= c;
    hunk += c;

    h = alloc(sizeof(Hist));
    h->name = hp;
    h->line = lineno;
    h->offset = -1;
    h->link = H;
    if(ehist == H) {
        hist = h;
        ehist = h;
        return;
    }
    ehist->link = h;
    ehist = h;
    return;

bad:
    unget(c);
    yyerror("syntax in #pragma lib");
    macend();
}
@

<<function macend>>=
void
macend(void)
{
    int c;

    for(;;) {
        c = getnsc();
        if(c < 0 || c == '\n')
            return;
    }
}
@

<<function linehist>>=
void
linehist(char *f, int offset)
{
    Hist *h;

    /*
     * overwrite the last #line directive if
     * no alloc has happened since the last one
     */
    if(newflag == 0 && ehist != H && offset != 0 && ehist->offset != 0)
        if(f && ehist->name && strcmp(f, ehist->name) == 0) {
            ehist->line = lineno;
            ehist->offset = offset;
            return;
        }

    if(debug['f'])
        if(f) {
            if(offset)
                print("%4ld: %s (#line %d)\n", lineno, f, offset);
            else
                print("%4ld: %s\n", lineno, f);
        } else
            print("%4ld: <pop>\n", lineno);
    newflag = 0;

    h = alloc(sizeof(Hist));
    h->name = f;
    h->line = lineno;
    h->offset = offset;
    h->link = H;
    if(ehist == H) {
        hist = h;
        ehist = h;
        return;
    }
    ehist->link = h;
    ehist = h;
}
@

<<function gethunk>>=
void
gethunk(void)
{
    char *h;
    long nh;

    nh = NHUNK;
    if(thunk >= 10L*NHUNK)
        nh = 10L*NHUNK;
    h = (char*)mysbrk(nh);
    if(h == (char*)-1) {
        yyerror("out of memory");
        errorexit();
    }
    hunk = h;
    nhunk = nh;
    thunk += nh;
}
@


%-------------------------------------------------------------

<<assemblers/aa/macbody.c>>=
#include "aa.h"

<<constant VARMAC>>

<<function getnsn>>

<<function getsym>>

<<function getsymdots>>

<<function getcom>>

<<function dodefine>>

<<global mactab>>

<<function domacro>>

<<function macund>>

<<constant NARG>>
<<function macdef>>

<<function macexpand>>

<<function macinc>>

<<function maclin>>

<<function macif>>

<<function macprag>>

<<function macend>>

<<function linehist>>

<<function gethunk>>
@


\section{[[assemblers/8a/]]}

\subsection*{[[assemblers/8a/a.h]]}

<<constant FPCHIP>>=
#define	FPCHIP		1
@

<<constant NMACRO>>=
#define	NMACRO		10
@

<<struct Gen>>=
struct	Gen
{
    double	dval;
    char	sval[8];
    long	offset;
    long	offset2;
    Sym*	sym;
    short	type;
    short	index;
    short	scale;
};
@

<<struct Gen2>>=
struct	Gen2
{
    Gen	from;
    Gen	to;
};
@

<<enum _anon_ (assemblers/8a/a.h)>>=
enum
{
    CLAST,
    CMACARG,
    CMACRO,
    CPREPROC,
};
@


%-------------------------------------------------------------

<<assemblers/8a/a.h>>=
#include "../aa/aa.h"
#include "386/8.out.h"

typedef	struct	Gen	Gen;
typedef	struct	Gen2 	Gen2;

<<constant FPCHIP>>
<<constant NMACRO>>


<<struct Gen>>
<<struct Gen2>>


<<enum _anon_ (assemblers/8a/a.h)>>


extern	char*	Dlist[30];
extern	int	nDlist;
extern	Gen	nullgen;
extern	int	pass;
extern	char*	pathname;
extern	char*	thestring;
extern	Biobuf	obuf;

long	yylex(void);
int	escchar(int);
void	cinit(void);
void	checkscale(int);
void	cclean(void);
int	isreg(Gen*);
void	outcode(int, Gen2*);
void	outhist(void);
void	zaddr(Gen*, int);
void	zname(char*, int, int);
Sym*	getsym(void);
int	assemble(char*);

// for lexbody
void	setinclude(char*);
void*	allocn(void*, long, long);
void	errorexit(void);
Sym*	slookup(char*);
void	pinit(char*);
void	ieeedtod(Ieee*, double);
void	dodefine(char*);
void	yyerror(char*, ...);
int	yyparse(void);

// for macbody
int	getc(void);
void	unget(int);
void	macund(void);
void	macdef(void);
void	macinc(void);
void	macprag(void);
void	maclin(void);
void	macif(int);
void	macend(void);
void	pushio(void);
void	newio(void);
void	newfile(char*, int);

// for macbody, was in lexbody

int	mywait(int*);
int	mycreat(char*, int);
int	systemtype(int);
int	pathchar(void);
char*	mygetwd(char*, int);
int	myexec(char*, char*[]);
int	mydup(int, int);
int	myfork(void);
int	mypipe(int*);
void*	mysbrk(ulong);
@


\subsection*{[[assemblers/8a/globals.c]]}

<<global nullgen>>=
Gen	nullgen;
@


%-------------------------------------------------------------

<<assemblers/8a/globals.c>>=
#include "a.h"

<<global nullgen>>
@


\subsection*{[[assemblers/8a/lex.c]]}

<<function main (assemblers/8a/lex.c)>>=
void
main(int argc, char *argv[])
{
    char *p;
    int nout, nproc, status, i, c;

    thechar = '8';
    thestring = "386";
    memset(debug, 0, sizeof(debug));
    cinit();
    outfile = 0;
    include[ninclude++] = ".";
    ARGBEGIN {
    default:
        c = ARGC();
        if(c >= 0 || c < sizeof(debug))
            debug[c] = 1;
        break;

    case 'o':
        outfile = ARGF();
        break;

    case 'D':
        p = ARGF();
        if(p)
            Dlist[nDlist++] = p;
        break;

    case 'I':
        p = ARGF();
        setinclude(p);
        break;
    } ARGEND
    if(*argv == 0) {
        print("usage: %ca [-options] file.s\n", thechar);
        errorexit();
    }
    if(argc > 1 && systemtype(Windows)){
        print("can't assemble multiple files on windows\n");
        errorexit();
    }
    if(argc > 1 && !systemtype(Windows)) {
        nproc = 1;
        if(p = getenv("NPROC"))
            nproc = atol(p);	/* */
        c = 0;
        nout = 0;
        for(;;) {
            while(nout < nproc && argc > 0) {
                i = myfork();
                if(i < 0) {
                    i = mywait(&status);
                    if(i < 0)
                        errorexit();
                    if(status)
                        c++;
                    nout--;
                    continue;
                }
                if(i == 0) {
                    print("%s:\n", *argv);
                    if(assemble(*argv))
                        errorexit();
                    exits(0);
                }
                nout++;
                argc--;
                argv++;
            }
            i = mywait(&status);
            if(i < 0) {
                if(c)
                    errorexit();
                exits(0);
            }
            if(status)
                c++;
            nout--;
        }
    }
    if(assemble(argv[0]))
        errorexit();
    exits(0);
}
@

<<function assemble>>=
int
assemble(char *file)
{
    char ofile[100], incfile[20], *p;
    int i, of;

    strcpy(ofile, file);
    p = utfrrune(ofile, pathchar());
    if(p) {
        include[0] = ofile;
        *p++ = 0;
    } else
        p = ofile;
    if(outfile == 0) {
        outfile = p;
        if(outfile){
            p = utfrrune(outfile, '.');
            if(p)
                if(p[1] == 's' && p[2] == 0)
                    p[0] = 0;
            p = utfrune(outfile, 0);
            p[0] = '.';
            p[1] = thechar;
            p[2] = 0;
        } else
            outfile = "/dev/null";
    }
    p = getenv("INCLUDE");
    if(p) {
        setinclude(p);
    } else {
        if(systemtype(Plan9)) {
            sprint(incfile,"/%s/include", thestring);
            setinclude(strdup(incfile));
        }
    }

    of = mycreat(outfile, 0664);
    if(of < 0) {
        yyerror("%ca: cannot create %s", thechar, outfile);
        errorexit();
    }
    Binit(&obuf, of, OWRITE);

    pass = 1;
    pinit(file);
    for(i=0; i<nDlist; i++)
        dodefine(Dlist[i]);
    yyparse();
    if(nerrors) {
        cclean();
        return nerrors;
    }

    pass = 2;
    outhist();
    pinit(file);
    for(i=0; i<nDlist; i++)
        dodefine(Dlist[i]);
    yyparse();
    cclean();
    return nerrors;
}
@

<<global itab>>=
struct
{
    char	*name;
    ushort	type;
    ushort	value;
} itab[] =
{
    "SP",		LSP,	D_AUTO,
    "SB",		LSB,	D_EXTERN,
    "FP",		LFP,	D_PARAM,
    "PC",		LPC,	D_BRANCH,

    "AL",		LBREG,	D_AL,
    "CL",		LBREG,	D_CL,
    "DL",		LBREG,	D_DL,
    "BL",		LBREG,	D_BL,
    "AH",		LBREG,	D_AH,
    "CH",		LBREG,	D_CH,
    "DH",		LBREG,	D_DH,
    "BH",		LBREG,	D_BH,

    "AX",		LLREG,	D_AX,
    "CX",		LLREG,	D_CX,
    "DX",		LLREG,	D_DX,
    "BX",		LLREG,	D_BX,
/*	"SP",		LLREG,	D_SP,	*/
    "BP",		LLREG,	D_BP,
    "SI",		LLREG,	D_SI,
    "DI",		LLREG,	D_DI,

    "F0",		LFREG,	D_F0+0,
    "F1",		LFREG,	D_F0+1,
    "F2",		LFREG,	D_F0+2,
    "F3",		LFREG,	D_F0+3,
    "F4",		LFREG,	D_F0+4,
    "F5",		LFREG,	D_F0+5,
    "F6",		LFREG,	D_F0+6,
    "F7",		LFREG,	D_F0+7,

    "CS",		LSREG,	D_CS,
    "SS",		LSREG,	D_SS,
    "DS",		LSREG,	D_DS,
    "ES",		LSREG,	D_ES,
    "FS",		LSREG,	D_FS,
    "GS",		LSREG,	D_GS,

    "GDTR",		LBREG,	D_GDTR,
    "IDTR",		LBREG,	D_IDTR,
    "LDTR",		LBREG,	D_LDTR,
    "MSW",		LBREG,	D_MSW,
    "TASK",		LBREG,	D_TASK,

    "CR0",		LBREG,	D_CR+0,
    "CR1",		LBREG,	D_CR+1,
    "CR2",		LBREG,	D_CR+2,
    "CR3",		LBREG,	D_CR+3,
    "CR4",		LBREG,	D_CR+4,
    "CR5",		LBREG,	D_CR+5,
    "CR6",		LBREG,	D_CR+6,
    "CR7",		LBREG,	D_CR+7,

    "DR0",		LBREG,	D_DR+0,
    "DR1",		LBREG,	D_DR+1,
    "DR2",		LBREG,	D_DR+2,
    "DR3",		LBREG,	D_DR+3,
    "DR4",		LBREG,	D_DR+4,
    "DR5",		LBREG,	D_DR+5,
    "DR6",		LBREG,	D_DR+6,
    "DR7",		LBREG,	D_DR+7,

    "TR0",		LBREG,	D_TR+0,
    "TR1",		LBREG,	D_TR+1,
    "TR2",		LBREG,	D_TR+2,
    "TR3",		LBREG,	D_TR+3,
    "TR4",		LBREG,	D_TR+4,
    "TR5",		LBREG,	D_TR+5,
    "TR6",		LBREG,	D_TR+6,
    "TR7",		LBREG,	D_TR+7,

    "AAA",		LTYPE0,	AAAA,
    "AAD",		LTYPE0,	AAAD,
    "AAM",		LTYPE0,	AAAM,
    "AAS",		LTYPE0,	AAAS,
    "ADCB",		LTYPE3,	AADCB,
    "ADCL",		LTYPE3,	AADCL,
    "ADCW",		LTYPE3,	AADCW,
    "ADDB",		LTYPE3,	AADDB,
    "ADDL",		LTYPE3,	AADDL,
    "ADDW",		LTYPE3,	AADDW,
    "ADJSP",	LTYPE2,	AADJSP,
    "ANDB",		LTYPE3,	AANDB,
    "ANDL",		LTYPE3,	AANDL,
    "ANDW",		LTYPE3,	AANDW,
    "ARPL",		LTYPE3,	AARPL,
    "BOUNDL",	LTYPE3,	ABOUNDL,
    "BOUNDW",	LTYPE3,	ABOUNDW,
    "BSFL",		LTYPE3,	ABSFL,
    "BSFW",		LTYPE3,	ABSFW,
    "BSRL",		LTYPE3,	ABSRL,
    "BSRW",		LTYPE3,	ABSRW,
    "BTCL",		LTYPE3,	ABTCL,
    "BTCW",		LTYPE3,	ABTCW,
    "BTL",		LTYPE3,	ABTL,
    "BTRL",		LTYPE3,	ABTRL,
    "BTRW",		LTYPE3,	ABTRW,
    "BTSL",		LTYPE3,	ABTSL,
    "BTSW",		LTYPE3,	ABTSW,
    "BTW",		LTYPE3,	ABTW,
    "BYTE",		LTYPE2,	ABYTE,
    "CALL",		LTYPEC,	ACALL,
    "CLC",		LTYPE0,	ACLC,
    "CLD",		LTYPE0,	ACLD,
    "CLI",		LTYPE0,	ACLI,
    "CLTS",		LTYPE0,	ACLTS,
    "CMC",		LTYPE0,	ACMC,
    "CMPB",		LTYPE4,	ACMPB,
    "CMPL",		LTYPE4,	ACMPL,
    "CMPW",		LTYPE4,	ACMPW,
    "CMPSB",	LTYPE0,	ACMPSB,
    "CMPSL",	LTYPE0,	ACMPSL,
    "CMPSW",	LTYPE0,	ACMPSW,
    "CMPXCHGB",	LTYPE3,	ACMPXCHGB,
    "CMPXCHGL",	LTYPE3,	ACMPXCHGL,
    "CMPXCHGW",	LTYPE3,	ACMPXCHGW,
    "DAA",		LTYPE0,	ADAA,
    "DAS",		LTYPE0,	ADAS,
    "DATA",		LTYPED,	ADATA,
    "DECB",		LTYPE1,	ADECB,
    "DECL",		LTYPE1,	ADECL,
    "DECW",		LTYPE1,	ADECW,
    "DIVB",		LTYPE2,	ADIVB,
    "DIVL",		LTYPE2,	ADIVL,
    "DIVW",		LTYPE2,	ADIVW,
    "END",		LTYPE0,	AEND,
    "ENTER",	LTYPE2,	AENTER,
    "GLOBL",	LTYPEG,	AGLOBL,
    "HLT",		LTYPE0,	AHLT,
    "IDIVB",	LTYPE2,	AIDIVB,
    "IDIVL",	LTYPE2,	AIDIVL,
    "IDIVW",	LTYPE2,	AIDIVW,
    "IMULB",	LTYPEI,	AIMULB,
    "IMULL",	LTYPEI,	AIMULL,
    "IMULW",	LTYPEI,	AIMULW,
    "INB",		LTYPE0,	AINB,
    "INL",		LTYPE0,	AINL,
    "INW",		LTYPE0,	AINW,
    "INCB",		LTYPE1,	AINCB,
    "INCL",		LTYPE1,	AINCL,
    "INCW",		LTYPE1,	AINCW,
    "INSB",		LTYPE0,	AINSB,
    "INSL",		LTYPE0,	AINSL,
    "INSW",		LTYPE0,	AINSW,
    "INT",		LTYPE2,	AINT,
    "INTO",		LTYPE0,	AINTO,
    "IRETL",	LTYPE0,	AIRETL,
    "IRETW",	LTYPE0,	AIRETW,

    "JOS",		LTYPER,	AJOS,
    "JO",		LTYPER,	AJOS,	/* alternate */
    "JOC",		LTYPER,	AJOC,
    "JNO",		LTYPER,	AJOC,	/* alternate */
    "JCS",		LTYPER,	AJCS,
    "JB",		LTYPER,	AJCS,	/* alternate */
    "JC",		LTYPER,	AJCS,	/* alternate */
    "JNAE",		LTYPER,	AJCS,	/* alternate */
    "JLO",		LTYPER,	AJCS,	/* alternate */
    "JCC",		LTYPER,	AJCC,
    "JAE",		LTYPER,	AJCC,	/* alternate */
    "JNB",		LTYPER,	AJCC,	/* alternate */
    "JNC",		LTYPER,	AJCC,	/* alternate */
    "JHS",		LTYPER,	AJCC,	/* alternate */
    "JEQ",		LTYPER,	AJEQ,
    "JE",		LTYPER,	AJEQ,	/* alternate */
    "JZ",		LTYPER,	AJEQ,	/* alternate */
    "JNE",		LTYPER,	AJNE,
    "JNZ",		LTYPER,	AJNE,	/* alternate */
    "JLS",		LTYPER,	AJLS,
    "JBE",		LTYPER,	AJLS,	/* alternate */
    "JNA",		LTYPER,	AJLS,	/* alternate */
    "JHI",		LTYPER,	AJHI,
    "JA",		LTYPER,	AJHI,	/* alternate */
    "JNBE",		LTYPER,	AJHI,	/* alternate */
    "JMI",		LTYPER,	AJMI,
    "JS",		LTYPER,	AJMI,	/* alternate */
    "JPL",		LTYPER,	AJPL,
    "JNS",		LTYPER,	AJPL,	/* alternate */
    "JPS",		LTYPER,	AJPS,
    "JP",		LTYPER,	AJPS,	/* alternate */
    "JPE",		LTYPER,	AJPS,	/* alternate */
    "JPC",		LTYPER,	AJPC,
    "JNP",		LTYPER,	AJPC,	/* alternate */
    "JPO",		LTYPER,	AJPC,	/* alternate */
    "JLT",		LTYPER,	AJLT,
    "JL",		LTYPER,	AJLT,	/* alternate */
    "JNGE",		LTYPER,	AJLT,	/* alternate */
    "JGE",		LTYPER,	AJGE,
    "JNL",		LTYPER,	AJGE,	/* alternate */
    "JLE",		LTYPER,	AJLE,
    "JNG",		LTYPER,	AJLE,	/* alternate */
    "JGT",		LTYPER,	AJGT,
    "JG",		LTYPER,	AJGT,	/* alternate */
    "JNLE",		LTYPER,	AJGT,	/* alternate */

    "JCXZ",		LTYPER,	AJCXZ,
    "JMP",		LTYPEC,	AJMP,
    "LAHF",		LTYPE0,	ALAHF,
    "LARL",		LTYPE3,	ALARL,
    "LARW",		LTYPE3,	ALARW,
    "LEAL",		LTYPE3,	ALEAL,
    "LEAW",		LTYPE3,	ALEAW,
    "LEAVEL",	LTYPE0,	ALEAVEL,
    "LEAVEW",	LTYPE0,	ALEAVEW,
    "LOCK",		LTYPE0,	ALOCK,
    "LODSB",	LTYPE0,	ALODSB,
    "LODSL",	LTYPE0,	ALODSL,
    "LODSW",	LTYPE0,	ALODSW,
    "LONG",		LTYPE2,	ALONG,
    "LOOP",		LTYPER,	ALOOP,
    "LOOPEQ",	LTYPER,	ALOOPEQ,
    "LOOPNE",	LTYPER,	ALOOPNE,
    "LSLL",		LTYPE3,	ALSLL,
    "LSLW",		LTYPE3,	ALSLW,
    "MOVB",		LTYPE3,	AMOVB,
    "MOVL",		LTYPEM,	AMOVL,
    "MOVW",		LTYPEM,	AMOVW,
    "MOVBLSX",	LTYPE3, AMOVBLSX,
    "MOVBLZX",	LTYPE3, AMOVBLZX,
    "MOVBWSX",	LTYPE3, AMOVBWSX,
    "MOVBWZX",	LTYPE3, AMOVBWZX,
    "MOVWLSX",	LTYPE3, AMOVWLSX,
    "MOVWLZX",	LTYPE3, AMOVWLZX,
    "MOVSB",	LTYPE0,	AMOVSB,
    "MOVSL",	LTYPE0,	AMOVSL,
    "MOVSW",	LTYPE0,	AMOVSW,
    "MULB",		LTYPE2,	AMULB,
    "MULL",		LTYPE2,	AMULL,
    "MULW",		LTYPE2,	AMULW,
    "NEGB",		LTYPE1,	ANEGB,
    "NEGL",		LTYPE1,	ANEGL,
    "NEGW",		LTYPE1,	ANEGW,
    "NOP",		LTYPEN,	ANOP,
    "NOTB",		LTYPE1,	ANOTB,
    "NOTL",		LTYPE1,	ANOTL,
    "NOTW",		LTYPE1,	ANOTW,
    "ORB",		LTYPE3,	AORB,
    "ORL",		LTYPE3,	AORL,
    "ORW",		LTYPE3,	AORW,
    "OUTB",		LTYPE0,	AOUTB,
    "OUTL",		LTYPE0,	AOUTL,
    "OUTW",		LTYPE0,	AOUTW,
    "OUTSB",	LTYPE0,	AOUTSB,
    "OUTSL",	LTYPE0,	AOUTSL,
    "OUTSW",	LTYPE0,	AOUTSW,
    "POPAL",	LTYPE0,	APOPAL,
    "POPAW",	LTYPE0,	APOPAW,
    "POPFL",	LTYPE0,	APOPFL,
    "POPFW",	LTYPE0,	APOPFW,
    "POPL",		LTYPE1,	APOPL,
    "POPW",		LTYPE1,	APOPW,
    "PUSHAL",	LTYPE0,	APUSHAL,
    "PUSHAW",	LTYPE0,	APUSHAW,
    "PUSHFL",	LTYPE0,	APUSHFL,
    "PUSHFW",	LTYPE0,	APUSHFW,
    "PUSHL",	LTYPE2,	APUSHL,
    "PUSHW",	LTYPE2,	APUSHW,
    "RCLB",		LTYPE3,	ARCLB,
    "RCLL",		LTYPE3,	ARCLL,
    "RCLW",		LTYPE3,	ARCLW,
    "RCRB",		LTYPE3,	ARCRB,
    "RCRL",		LTYPE3,	ARCRL,
    "RCRW",		LTYPE3,	ARCRW,
    "REP",		LTYPE0,	AREP,
    "REPN",		LTYPE0,	AREPN,
    "RET",		LTYPE0,	ARET,
    "ROLB",		LTYPE3,	AROLB,
    "ROLL",		LTYPE3,	AROLL,
    "ROLW",		LTYPE3,	AROLW,
    "RORB",		LTYPE3,	ARORB,
    "RORL",		LTYPE3,	ARORL,
    "RORW",		LTYPE3,	ARORW,
    "SAHF",		LTYPE0,	ASAHF,
    "SALB",		LTYPE3,	ASALB,
    "SALL",		LTYPE3,	ASALL,
    "SALW",		LTYPE3,	ASALW,
    "SARB",		LTYPE3,	ASARB,
    "SARL",		LTYPE3,	ASARL,
    "SARW",		LTYPE3,	ASARW,
    "SBBB",		LTYPE3,	ASBBB,
    "SBBL",		LTYPE3,	ASBBL,
    "SBBW",		LTYPE3,	ASBBW,
    "SCASB",	LTYPE0,	ASCASB,
    "SCASL",	LTYPE0,	ASCASL,
    "SCASW",	LTYPE0,	ASCASW,
    "SETCC",	LTYPE1,	ASETCC,
    "SETCS",	LTYPE1,	ASETCS,
    "SETEQ",	LTYPE1,	ASETEQ,
    "SETGE",	LTYPE1,	ASETGE,
    "SETGT",	LTYPE1,	ASETGT,
    "SETHI",	LTYPE1,	ASETHI,
    "SETLE",	LTYPE1,	ASETLE,
    "SETLS",	LTYPE1,	ASETLS,
    "SETLT",	LTYPE1,	ASETLT,
    "SETMI",	LTYPE1,	ASETMI,
    "SETNE",	LTYPE1,	ASETNE,
    "SETOC",	LTYPE1,	ASETOC,
    "SETOS",	LTYPE1,	ASETOS,
    "SETPC",	LTYPE1,	ASETPC,
    "SETPL",	LTYPE1,	ASETPL,
    "SETPS",	LTYPE1,	ASETPS,
    "CDQ",		LTYPE0,	ACDQ,
    "CWD",		LTYPE0,	ACWD,
    "SHLB",		LTYPE3,	ASHLB,
    "SHLL",		LTYPES,	ASHLL,
    "SHLW",		LTYPES,	ASHLW,
    "SHRB",		LTYPE3,	ASHRB,
    "SHRL",		LTYPES,	ASHRL,
    "SHRW",		LTYPES,	ASHRW,
    "STC",		LTYPE0,	ASTC,
    "STD",		LTYPE0,	ASTD,
    "STI",		LTYPE0,	ASTI,
    "STOSB",	LTYPE0,	ASTOSB,
    "STOSL",	LTYPE0,	ASTOSL,
    "STOSW",	LTYPE0,	ASTOSW,
    "SUBB",		LTYPE3,	ASUBB,
    "SUBL",		LTYPE3,	ASUBL,
    "SUBW",		LTYPE3,	ASUBW,
    "SYSCALL",	LTYPE0,	ASYSCALL,
    "TESTB",	LTYPE3,	ATESTB,
    "TESTL",	LTYPE3,	ATESTL,
    "TESTW",	LTYPE3,	ATESTW,
    "TEXT",		LTYPET,	ATEXT,
    "VERR",		LTYPE2,	AVERR,
    "VERW",		LTYPE2,	AVERW,
    "WAIT",		LTYPE0,	AWAIT,
    "WORD",		LTYPE2,	AWORD,
    "XCHGB",	LTYPE3,	AXCHGB,
    "XCHGL",	LTYPE3,	AXCHGL,
    "XCHGW",	LTYPE3,	AXCHGW,
    "XLAT",		LTYPE2,	AXLAT,
    "XORB",		LTYPE3,	AXORB,
    "XORL",		LTYPE3,	AXORL,
    "XORW",		LTYPE3,	AXORW,

    "CMOVLCC",	LTYPE3,	ACMOVLCC,
    "CMOVLCS",	LTYPE3,	ACMOVLCS,
    "CMOVLEQ",	LTYPE3,	ACMOVLEQ,
    "CMOVLGE",	LTYPE3,	ACMOVLGE,
    "CMOVLGT",	LTYPE3,	ACMOVLGT,
    "CMOVLHI",	LTYPE3,	ACMOVLHI,
    "CMOVLLE",	LTYPE3,	ACMOVLLE,
    "CMOVLLS",	LTYPE3,	ACMOVLLS,
    "CMOVLLT",	LTYPE3,	ACMOVLLT,
    "CMOVLMI",	LTYPE3,	ACMOVLMI,
    "CMOVLNE",	LTYPE3,	ACMOVLNE,
    "CMOVLOC",	LTYPE3,	ACMOVLOC,
    "CMOVLOS",	LTYPE3,	ACMOVLOS,
    "CMOVLPC",	LTYPE3,	ACMOVLPC,
    "CMOVLPL",	LTYPE3,	ACMOVLPL,
    "CMOVLPS",	LTYPE3,	ACMOVLPS,
    "CMOVWCC",	LTYPE3,	ACMOVWCC,
    "CMOVWCS",	LTYPE3,	ACMOVWCS,
    "CMOVWEQ",	LTYPE3,	ACMOVWEQ,
    "CMOVWGE",	LTYPE3,	ACMOVWGE,
    "CMOVWGT",	LTYPE3,	ACMOVWGT,
    "CMOVWHI",	LTYPE3,	ACMOVWHI,
    "CMOVWLE",	LTYPE3,	ACMOVWLE,
    "CMOVWLS",	LTYPE3,	ACMOVWLS,
    "CMOVWLT",	LTYPE3,	ACMOVWLT,
    "CMOVWMI",	LTYPE3,	ACMOVWMI,
    "CMOVWNE",	LTYPE3,	ACMOVWNE,
    "CMOVWOC",	LTYPE3,	ACMOVWOC,
    "CMOVWOS",	LTYPE3,	ACMOVWOS,
    "CMOVWPC",	LTYPE3,	ACMOVWPC,
    "CMOVWPL",	LTYPE3,	ACMOVWPL,
    "CMOVWPS",	LTYPE3,	ACMOVWPS,

    "FMOVB",	LTYPE3, AFMOVB,
    "FMOVBP",	LTYPE3, AFMOVBP,
    "FMOVD",	LTYPE3, AFMOVD,
    "FMOVDP",	LTYPE3, AFMOVDP,
    "FMOVF",	LTYPE3, AFMOVF,
    "FMOVFP",	LTYPE3, AFMOVFP,
    "FMOVL",	LTYPE3, AFMOVL,
    "FMOVLP",	LTYPE3, AFMOVLP,
    "FMOVV",	LTYPE3, AFMOVV,
    "FMOVVP",	LTYPE3, AFMOVVP,
    "FMOVW",	LTYPE3, AFMOVW,
    "FMOVWP",	LTYPE3, AFMOVWP,
    "FMOVX",	LTYPE3, AFMOVX,
    "FMOVXP",	LTYPE3, AFMOVXP,
    "FCMOVCC",	LTYPE3, AFCMOVCC,
    "FCMOVCS",	LTYPE3, AFCMOVCS,
    "FCMOVEQ",	LTYPE3, AFCMOVEQ,
    "FCMOVHI",	LTYPE3, AFCMOVHI,
    "FCMOVLS",	LTYPE3, AFCMOVLS,
    "FCMOVNE",	LTYPE3, AFCMOVNE,
    "FCMOVNU",	LTYPE3, AFCMOVNU,
    "FCMOVUN",	LTYPE3, AFCMOVUN,
    "FCOMB",	LTYPE3, AFCOMB,
    "FCOMBP",	LTYPE3, AFCOMBP,
    "FCOMD",	LTYPE3, AFCOMD,
    "FCOMDP",	LTYPE3, AFCOMDP,
    "FCOMDPP",	LTYPE3, AFCOMDPP,
    "FCOMF",	LTYPE3, AFCOMF,
    "FCOMFP",	LTYPE3, AFCOMFP,
    "FCOMI",	LTYPE3, AFCOMI,
    "FCOMIP",	LTYPE3, AFCOMIP,
    "FCOML",	LTYPE3, AFCOML,
    "FCOMLP",	LTYPE3, AFCOMLP,
    "FCOMW",	LTYPE3, AFCOMW,
    "FCOMWP",	LTYPE3, AFCOMWP,
    "FUCOM",	LTYPE3, AFUCOM,
    "FUCOMI",	LTYPE3, AFUCOMI,
    "FUCOMIP",	LTYPE3, AFUCOMIP,
    "FUCOMP",	LTYPE3, AFUCOMP,
    "FUCOMPP",	LTYPE3, AFUCOMPP,
    "FADDW",	LTYPE3, AFADDW,
    "FADDL",	LTYPE3, AFADDL,
    "FADDF",	LTYPE3, AFADDF,
    "FADDD",	LTYPE3, AFADDD,
    "FADDDP",	LTYPE3, AFADDDP,
    "FSUBDP",	LTYPE3, AFSUBDP,
    "FSUBW",	LTYPE3, AFSUBW,
    "FSUBL",	LTYPE3, AFSUBL,
    "FSUBF",	LTYPE3, AFSUBF,
    "FSUBD",	LTYPE3, AFSUBD,
    "FSUBRDP",	LTYPE3, AFSUBRDP,
    "FSUBRW",	LTYPE3, AFSUBRW,
    "FSUBRL",	LTYPE3, AFSUBRL,
    "FSUBRF",	LTYPE3, AFSUBRF,
    "FSUBRD",	LTYPE3, AFSUBRD,
    "FMULDP",	LTYPE3, AFMULDP,
    "FMULW",	LTYPE3, AFMULW,
    "FMULL",	LTYPE3, AFMULL,
    "FMULF",	LTYPE3, AFMULF,
    "FMULD",	LTYPE3, AFMULD,
    "FDIVDP",	LTYPE3, AFDIVDP,
    "FDIVW",	LTYPE3, AFDIVW,
    "FDIVL",	LTYPE3, AFDIVL,
    "FDIVF",	LTYPE3, AFDIVF,
    "FDIVD",	LTYPE3, AFDIVD,
    "FDIVRDP",	LTYPE3, AFDIVRDP,
    "FDIVRW",	LTYPE3, AFDIVRW,
    "FDIVRL",	LTYPE3, AFDIVRL,
    "FDIVRF",	LTYPE3, AFDIVRF,
    "FDIVRD",	LTYPE3, AFDIVRD,
    "FXCHD",	LTYPE3, AFXCHD,
    "FFREE",	LTYPE1, AFFREE,
    "FLDCW",	LTYPE2, AFLDCW,
    "FLDENV",	LTYPE1, AFLDENV,
    "FRSTOR",	LTYPE2, AFRSTOR,
    "FSAVE",	LTYPE1, AFSAVE,
    "FSTCW",	LTYPE1, AFSTCW,
    "FSTENV",	LTYPE1, AFSTENV,
    "FSTSW",	LTYPE1, AFSTSW,
    "F2XM1",	LTYPE0, AF2XM1,
    "FABS",		LTYPE0, AFABS,
    "FCHS",		LTYPE0, AFCHS,
    "FCLEX",	LTYPE0, AFCLEX,
    "FCOS",		LTYPE0, AFCOS,
    "FDECSTP",	LTYPE0, AFDECSTP,
    "FINCSTP",	LTYPE0, AFINCSTP,
    "FINIT",	LTYPE0, AFINIT,
    "FLD1",		LTYPE0, AFLD1,
    "FLDL2E",	LTYPE0, AFLDL2E,
    "FLDL2T",	LTYPE0, AFLDL2T,
    "FLDLG2",	LTYPE0, AFLDLG2,
    "FLDLN2",	LTYPE0, AFLDLN2,
    "FLDPI",	LTYPE0, AFLDPI,
    "FLDZ",		LTYPE0, AFLDZ,
    "FNOP",		LTYPE0, AFNOP,
    "FPATAN",	LTYPE0, AFPATAN,
    "FPREM",	LTYPE0, AFPREM,
    "FPREM1",	LTYPE0, AFPREM1,
    "FPTAN",	LTYPE0, AFPTAN,
    "FRNDINT",	LTYPE0, AFRNDINT,
    "FSCALE",	LTYPE0, AFSCALE,
    "FSIN",		LTYPE0, AFSIN,
    "FSINCOS",	LTYPE0, AFSINCOS,
    "FSQRT",	LTYPE0, AFSQRT,
    "FTST",		LTYPE0, AFTST,
    "FXAM",		LTYPE0, AFXAM,
    "FXTRACT",	LTYPE0, AFXTRACT,
    "FYL2X",	LTYPE0, AFYL2X,
    "FYL2XP1",	LTYPE0, AFYL2XP1,

    0
};
@

<<function cinit>>=
void
cinit(void)
{
    Sym *s;
    int i;

    nullgen.sym = S;
    nullgen.offset = 0;
    if(FPCHIP)
        nullgen.dval = 0;
    for(i=0; i<sizeof(nullgen.sval); i++)
        nullgen.sval[i] = 0;
    nullgen.type = D_NONE;
    nullgen.index = D_NONE;
    nullgen.scale = 0;

    nerrors = 0;
    iostack = I;
    iofree = I;
    peekc = IGN;
    nhunk = 0;
    for(i=0; i<NHASH; i++)
        hash[i] = S;
    for(i=0; itab[i].name; i++) {
        s = slookup(itab[i].name);
        if(s->type != LNAME)
            yyerror("double initialization %s", itab[i].name);
        s->type = itab[i].type;
        s->value = itab[i].value;
    }

    pathname = allocn(pathname, 0, 100);
    if(mygetwd(pathname, 99) == 0) {
        pathname = allocn(pathname, 100, 900);
        if(mygetwd(pathname, 999) == 0)
            strcpy(pathname, "/???");
    }
}
@

<<function checkscale>>=
void
checkscale(int scale)
{

    switch(scale) {
    case 1:
    case 2:
    case 4:
    case 8:
        return;
    }
    yyerror("scale must be 1248: %d", scale);
}
@

<<function syminit>>=
void
syminit(Sym *s)
{

    s->type = LNAME;
    s->value = 0;
}
@

<<function cclean>>=
void
cclean(void)
{
    Gen2 g2;

    g2.from = nullgen;
    g2.to = nullgen;
    outcode(AEND, &g2);
    Bflush(&obuf);
}
@

<<function zname>>=
void
zname(char *n, int t, int s)
{

    Bputc(&obuf, ANAME);		/* as(2) */
    Bputc(&obuf, ANAME>>8);
    Bputc(&obuf, t);		/* type */
    Bputc(&obuf, s);		/* sym */
    while(*n) {
        Bputc(&obuf, *n);
        n++;
    }
    Bputc(&obuf, 0);
}
@

<<function zaddr>>=
void
zaddr(Gen *a, int s)
{
    long l;
    int i, t;
    char *n;
    Ieee e;

    t = 0;
    if(a->index != D_NONE || a->scale != 0)
        t |= T_INDEX;
    if(a->offset != 0)
        t |= T_OFFSET;
    if(s != 0)
        t |= T_SYM;

    switch(a->type) {
    default:
        t |= T_TYPE;
        break;
    case D_FCONST:
        t |= T_FCONST;
        break;
    case D_CONST2:
        t |= T_OFFSET|T_OFFSET2;
        break;
    case D_SCONST:
        t |= T_SCONST;
        break;
    case D_NONE:
        break;
    }
    Bputc(&obuf, t);

    if(t & T_INDEX) {	/* implies index, scale */
        Bputc(&obuf, a->index);
        Bputc(&obuf, a->scale);
    }
    if(t & T_OFFSET) {	/* implies offset */
        l = a->offset;
        Bputc(&obuf, l);
        Bputc(&obuf, l>>8);
        Bputc(&obuf, l>>16);
        Bputc(&obuf, l>>24);
    }
    if(t & T_OFFSET2) {
        l = a->offset2;
        Bputc(&obuf, l);
        Bputc(&obuf, l>>8);
        Bputc(&obuf, l>>16);
        Bputc(&obuf, l>>24);
    }
    if(t & T_SYM)		/* implies sym */
        Bputc(&obuf, s);
    if(t & T_FCONST) {
        ieeedtod(&e, a->dval);
        l = e.l;
        Bputc(&obuf, l);
        Bputc(&obuf, l>>8);
        Bputc(&obuf, l>>16);
        Bputc(&obuf, l>>24);
        l = e.h;
        Bputc(&obuf, l);
        Bputc(&obuf, l>>8);
        Bputc(&obuf, l>>16);
        Bputc(&obuf, l>>24);
        return;
    }
    if(t & T_SCONST) {
        n = a->sval;
        for(i=0; i<NSNAME; i++) {
            Bputc(&obuf, *n);
            n++;
        }
        return;
    }
    if(t & T_TYPE)
        Bputc(&obuf, a->type);
}
@

<<function outcode>>=
void
outcode(int a, Gen2 *g2)
{
    int sf, st, t;
    Sym *s;

    if(pass == 1)
        goto out;

jackpot:
    sf = 0;
    s = g2->from.sym;
    while(s != S) {
        sf = s->sym;
        if(sf < 0 || sf >= NSYM)
            sf = 0;
        t = g2->from.type;
        if(t == D_ADDR)
            t = g2->from.index;
        if(h[sf].type == t)
        if(h[sf].sym == s)
            break;
        zname(s->name, t, sym);
        s->sym = sym;
        h[sym].sym = s;
        h[sym].type = t;
        sf = sym;
        sym++;
        if(sym >= NSYM)
            sym = 1;
        break;
    }
    st = 0;
    s = g2->to.sym;
    while(s != S) {
        st = s->sym;
        if(st < 0 || st >= NSYM)
            st = 0;
        t = g2->to.type;
        if(t == D_ADDR)
            t = g2->to.index;
        if(h[st].type == t)
        if(h[st].sym == s)
            break;
        zname(s->name, t, sym);
        s->sym = sym;
        h[sym].sym = s;
        h[sym].type = t;
        st = sym;
        sym++;
        if(sym >= NSYM)
            sym = 1;
        if(st == sf)
            goto jackpot;
        break;
    }
    Bputc(&obuf, a);
    Bputc(&obuf, a>>8);
    Bputc(&obuf, lineno);
    Bputc(&obuf, lineno>>8);
    Bputc(&obuf, lineno>>16);
    Bputc(&obuf, lineno>>24);
    zaddr(&g2->from, sf);
    zaddr(&g2->to, st);

out:
    if(a != AGLOBL && a != ADATA)
        pc++;
}
@

<<function outhist>>=
void
outhist(void)
{
    Gen g;
    Hist *h;
    char *p, *q, *op, c;
    int n;

    g = nullgen;
    c = pathchar();
    for(h = hist; h != H; h = h->link) {
        p = h->name;
        op = 0;
        /* on windows skip drive specifier in pathname */
        if(systemtype(Windows) && p && p[1] == ':'){
            p += 2;
            c = *p;
        }
        if(p && p[0] != c && h->offset == 0 && pathname){
            /* on windows skip drive specifier in pathname */
            if(systemtype(Windows) && pathname[1] == ':') {
                op = p;
                p = pathname+2;
                c = *p;
            } else if(pathname[0] == c){
                op = p;
                p = pathname;
            }
        }
        while(p) {
            q = strchr(p, c);
            if(q) {
                n = q-p;
                if(n == 0){
                    n = 1;	/* leading "/" */
                    *p = '/';	/* don't emit "\" on windows */
                }
                q++;
            } else {
                n = strlen(p);
                q = 0;
            }
            if(n) {
                Bputc(&obuf, ANAME);
                Bputc(&obuf, ANAME>>8);
                Bputc(&obuf, D_FILE);	/* type */
                Bputc(&obuf, 1);	/* sym */
                Bputc(&obuf, '<');
                Bwrite(&obuf, p, n);
                Bputc(&obuf, 0);
            }
            p = q;
            if(p == 0 && op) {
                p = op;
                op = 0;
            }
        }
        g.offset = h->offset;

        Bputc(&obuf, AHISTORY);
        Bputc(&obuf, AHISTORY>>8);
        Bputc(&obuf, h->line);
        Bputc(&obuf, h->line>>8);
        Bputc(&obuf, h->line>>16);
        Bputc(&obuf, h->line>>24);
        zaddr(&nullgen, 0);
        zaddr(&g, 0);
    }
}
@

<<function yylex>>=
//
long
yylex(void)
{
    int c, c1;
    char *cp;
    Sym *s;

    c = peekc;
    if(c != IGN) {
        peekc = IGN;
        goto l1;
    }
l0:
    c = GETC();

l1:
    if(c == EOF) {
        peekc = EOF;
        return -1;
    }
    if(isspace(c)) {
        if(c == '\n') {
            lineno++;
            return ';';
        }
        goto l0;
    }
    if(isalpha(c))
        goto talph;
    if(isdigit(c))
        goto tnum;
    switch(c)
    {
    case '\n':
        lineno++;
        return ';';

    case '#':
        domacro();
        goto l0;

    case '.':
        c = GETC();
        if(isalpha(c)) {
            cp = symb;
            *cp++ = '.';
            goto aloop;
        }
        if(isdigit(c)) {
            cp = symb;
            *cp++ = '.';
            goto casedot;
        }
        peekc = c;
        return '.';

    case '_':
    case '@':
    talph:
        cp = symb;

    aloop:
        *cp++ = c;
        c = GETC();
        if(isalpha(c) || isdigit(c) || c == '_' || c == '$')
            goto aloop;
        *cp = 0;
        peekc = c;
        s = lookup();
        if(s->macro) {
            newio();
            cp = ionext->b;
            macexpand(s, cp);
            pushio();
            ionext->link = iostack;
            iostack = ionext;
            fi.p = cp;
            fi.c = strlen(cp);
            if(peekc != IGN) {
                cp[fi.c++] = peekc;
                cp[fi.c] = 0;
                peekc = IGN;
            }
            goto l0;
        }
        if(s->type == 0)
            s->type = LNAME;
        if(s->type == LNAME ||
           s->type == LVAR ||
           s->type == LLAB) {
            yylval.sym = s;
            return s->type;
        }
        yylval.lval = s->value;
        return s->type;

    tnum:
        cp = symb;
        if(c != '0')
            goto dc;
        *cp++ = c;
        c = GETC();
        c1 = 3;
        if(c == 'x' || c == 'X') {
            c1 = 4;
            c = GETC();
        } else
        if(c < '0' || c > '7')
            goto dc;
        yylval.lval = 0;
        for(;;) {
            if(c >= '0' && c <= '9') {
                if(c > '7' && c1 == 3)
                    break;
                yylval.lval <<= c1;
                yylval.lval += c - '0';
                c = GETC();
                continue;
            }
            if(c1 == 3)
                break;
            if(c >= 'A' && c <= 'F')
                c += 'a' - 'A';
            if(c >= 'a' && c <= 'f') {
                yylval.lval <<= c1;
                yylval.lval += c - 'a' + 10;
                c = GETC();
                continue;
            }
            break;
        }
        goto ncu;

    dc:
        for(;;) {
            if(!isdigit(c))
                break;
            *cp++ = c;
            c = GETC();
        }
        if(c == '.')
            goto casedot;
        if(c == 'e' || c == 'E')
            goto casee;
        *cp = 0;
        if(sizeof(yylval.lval) == sizeof(vlong))
            yylval.lval = strtoll(symb, nil, 10);
        else
            yylval.lval = strtol(symb, nil, 10);

    ncu:
        while(c == 'U' || c == 'u' || c == 'l' || c == 'L')
            c = GETC();
        peekc = c;
        return LCONST;

    casedot:
        for(;;) {
            *cp++ = c;
            c = GETC();
            if(!isdigit(c))
                break;
        }
        if(c == 'e' || c == 'E')
            goto casee;
        goto caseout;

    casee:
        *cp++ = 'e';
        c = GETC();
        if(c == '+' || c == '-') {
            *cp++ = c;
            c = GETC();
        }
        while(isdigit(c)) {
            *cp++ = c;
            c = GETC();
        }

    caseout:
        *cp = 0;
        peekc = c;
        if(FPCHIP) {
            yylval.dval = atof(symb);
            return LFCONST;
        }
        yyerror("assembler cannot interpret fp constants");
        yylval.lval = 1L;
        return LCONST;

    case '"':
        memcpy(yylval.sval, nullgen.sval, sizeof(yylval.sval));
        cp = yylval.sval;
        c1 = 0;
        for(;;) {
            c = escchar('"');
            if(c == EOF)
                break;
            if(c1 < sizeof(yylval.sval))
                *cp++ = c;
            c1++;
        }
        if(c1 > sizeof(yylval.sval))
            yyerror("string constant too long");
        return LSCONST;

    case '\'':
        c = escchar('\'');
        if(c == EOF)
            c = '\'';
        if(escchar('\'') != EOF)
            yyerror("missing '");
        yylval.lval = c;
        return LCONST;

    case '/':
        c1 = GETC();
        if(c1 == '/') {
            for(;;) {
                c = GETC();
                if(c == '\n')
                    goto l1;
                if(c == EOF) {
                    yyerror("eof in comment");
                    errorexit();
                }
            }
        }
        if(c1 == '*') {
            for(;;) {
                c = GETC();
                while(c == '*') {
                    c = GETC();
                    if(c == '/')
                        goto l0;
                }
                if(c == EOF) {
                    yyerror("eof in comment");
                    errorexit();
                }
                if(c == '\n')
                    lineno++;
            }
        }
        break;

    default:
        return c;
    }
    peekc = c1;
    return c;
}
@
%$


%-------------------------------------------------------------

<<assemblers/8a/lex.c>>=
#include "a.h"
#include "y.tab.h"

<<function main (assemblers/8a/lex.c)>>

<<function assemble>>

<<global itab>>

<<function cinit>>

<<function checkscale>>

<<function syminit>>

<<function cclean>>

<<function zname>>

<<function zaddr>>

<<function outcode>>

<<function outhist>>

// now use aa.a8
//#include "../cc/lexbody"
//#include "../cc/compat"

// used to be in ../cc/lexbody and factorized between assemblers by
// using #include, but ugly, so I copy pasted the function for now
<<function yylex>>

// #include "../cc/macbody"
@


