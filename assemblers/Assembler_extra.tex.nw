\section{[[include/]]}

\subsection*{[[include/common.out.h]]}

%-------------------------------------------------------------

<<include/common.out.h>>=

<<constant NSYM>>

// was originally in a xxx/y.out.h (and was always the same in all archi)
/*
 * this is the simulated IEEE floating point
 */
typedef	struct	ieee	Ieee;
<<struct ieee>>
@


\section{[[include/386/]]}

\subsection*{[[include/386/8.out.h]]}

<<constant NSNAME>>=
#define	NSNAME	8
@

% todo: enum, not used by 8a by 8c
<<constant NOPROF>>=
#define NOPROF	(1<<0)
@

<<constant DUPOK>>=
#define DUPOK	(1<<1)
@

<<constant NOSPLIT>>=
#define NOSPLIT	(1<<2)
@


% used by ar?
<<constant SYMDEF>>=
/*
 * this is the ranlib header
 */
#define	SYMDEF	"__.SYMDEF"
@


%-------------------------------------------------------------

<<include/386/8.out.h>>=

<<constant NSNAME>>
<<constant NOPROF>>
<<constant DUPOK>>
<<constant NOSPLIT>>

<<enum as>>

<<enum _anon_>>

<<constant SYMDEF>>
@


\section{[[assemblers/misc/]]}

\subsection*{[[assemblers/misc/data2s.c]]}

<<function main>>=
void
main(int argc, char *argv[])
{
    Biobuf bin, bout;
    long len, slen;
    int c;

    if(argc != 2){
        fprint(2, "usage: data2s name\n");
        exits("usage");
    }
    Binit(&bin, 0, OREAD);
    Binit(&bout, 1, OWRITE);
    for(len=0; (c=Bgetc(&bin))!=Beof; len++){
        if((len&7) == 0)
            Bprint(&bout, "DATA %scode+%ld(SB)/8, $\"", argv[1], len);
        if(c)
            Bprint(&bout, "\\%uo", c);
        else
            Bprint(&bout, "\\z");
        if((len&7) == 7)
            Bprint(&bout, "\"\n");
    }
    slen = len;
    if(len & 7){
        while(len & 7){
            Bprint(&bout, "\\z");
            len++;
        }
        Bprint(&bout, "\"\n");
    }
    Bprint(&bout, "GLOBL %scode+0(SB), $%ld\n", argv[1], len);
    Bprint(&bout, "GLOBL %slen+0(SB), $4\n", argv[1]);
    Bprint(&bout, "DATA %slen+0(SB)/4, $%ld\n", argv[1], slen);
    exits(0);
}
@


%-------------------------------------------------------------

<<assemblers/misc/data2s.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>

<<function main>>
@


\section{[[assemblers/aa/]]}

\subsection*{[[assemblers/aa/aa.h]]}

<<constant MAXALIGN>>=
#define MAXALIGN 7
@

<<constant NSYMB>>=
#define	NSYMB		500
@

<<constant BUFSIZ>>=
#define	BUFSIZ		8192
@

<<constant HISTSZ>>=
#define	HISTSZ		20
@

<<constant NHUNK>>=
#define	NHUNK		10000
@



<<constant NHASH>>=
#define	NHASH		503
@

<<constant STRINGSZ>>=
#define	STRINGSZ	200
@


<<enum _anon_ (assemblers/aa/aa.h)>>=
/*
 *	system-dependent stuff from ../cc/compat.c
 */
enum	/* keep in synch with ../cc/cc.h */
{
    Plan9	= 1<<0,
    Unix	= 1<<1,
};
@


%-------------------------------------------------------------

<<assemblers/aa/aa.h>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <ctype.h>

// aa.h  is the generic part, the specific #include XXX/Y.out.h is done
// in Ya/a.h, e.g.:
//#include "386/8.out.h"
//#include "mips/v.out.h"
//#include "arm/5.out.h"
#include <common.out.h>

#pragma	lib	"../aa/aa.a$O"

// was originally in a XXX/Y.out.h (and was always the same in all archi)
// most of the content below was originally copy pasted in 8a/a.h, 5a/a.h, etc

typedef	struct	Sym	Sym;
typedef	struct	Ref	Ref;
typedef struct  Io Io;
typedef	struct	Hist	Hist;

<<constant MAXALIGN>>
<<constant NSYMB>>
<<constant BUFSIZ>>
<<constant HISTSZ>>
<<constant NINCLUDE>>
<<constant NHUNK>>
<<constant EOF>>
<<constant IGN>>
<<function GETC>>
<<constant NHASH>>
<<constant STRINGSZ>>


<<struct Sym>>
<<constant S>>

<<struct Ref>>

<<struct Fi>>
extern struct Fi fi;

<<struct Io>>
<<constant I>>

<<struct Htab>>
extern struct Htab h[NSYM];

// Gen, Gen2?

<<struct Hist>>
<<constant H>>



// was in a.h
extern	Sym*	hash[NHASH];
extern	Hist*	hist;
extern	char*	hunk;
extern	char*	include[NINCLUDE];
extern	Io*	iofree;
extern	Io*	ionext;
extern	Io*	iostack;
extern	long	lineno;
extern	int	nerrors;
extern	long	nhunk;
extern	int	ninclude;
extern	char*	outfile;
extern	long	pc;
extern	int	peekc;
extern	int	sym;
extern	char	symb[NSYMB];
extern	int	thechar;

// for macbody, was in a.h
extern	char	debug[256];
extern	Hist*	ehist;
extern	int	newflag;
extern	long	thunk;

// for lexbody, was in a.h
int	getnsc(void);
void	gethunk(void);
void	yyerror(char*, ...);
void	linehist(char*, int);
Sym*	lookup(void);
void	syminit(Sym*);
int	filbuf(void);
void	domacro(void);
void	macexpand(Sym*, char*);

// for macbody, was in a.h
int	getc(void);
void	unget(int);
Sym*	slookup(char*);
void*	mysbrk(ulong);

// for macbody, was in lexbody
void pragpack(void);
void pragfpround(void);
void pragprofile(void);
void pragvararg(void);
void* alloc(long n);
void pragincomplete(void);
void* allocn(void *p, long on, long n);
void	pushio(void);
void	newio(void);
void	newfile(char*, int);
void	errorexit(void);

// from lexbody.c
void ieeedtod(Ieee *ieee, double native);

<<enum _anon_ (assemblers/aa/aa.h)>>
@
%$


\subsection*{[[assemblers/aa/compat.c]]}

% TODO: delete useless wrapper, we don't care about compatibility in XIX!
<<function mysbrk>>=
void*
mysbrk(ulong size)
{
    return sbrk(size);
}
@

<<function mycreat>>=
int
mycreat(char *n, int p)
{

    return create(n, 1, p);
}
@

<<function mywait>>=
int
mywait(int *s)
{
    int p;
    Waitmsg *w;

    if((w = wait()) == nil)
        return -1;
    else{
        p = w->pid;
        *s = 0;
        if(w->msg[0])
            *s = 1;
        free(w);
        return p;
    }
}
@


<<function systemtype>>=
int
systemtype(int sys)
{
    return sys & Plan9;
}
@

<<function pathchar>>=
int
pathchar(void)
{
    return '/';
}
@

<<function mygetwd>>=
char*
mygetwd(char *path, int len)
{
    return getwd(path, len);
}
@


<<function myfork>>=
int
myfork(void)
{
    return fork();
}
@


%-------------------------------------------------------------

<<assemblers/aa/compat.c>>=
#include "aa.h"


<<function mysbrk>>

<<function mycreat>>

<<function mywait>>

<<function systemtype>>

<<function pathchar>>

<<function mygetwd>>

<<function myfork>>
@


\subsection*{[[assemblers/aa/globals.c]]}


<<global newflag>>=
int	newflag;
@


<<global hunk>>=
char*	hunk;
@





<<global nhunk>>=
long	nhunk;
@



<<global pass>>=
int	pass;
@

<<global pathname>>=
char*	pathname;
@



<<global sym>>=
int	sym;
@

<<global symb>>=
char	symb[NSYMB];
@




<<global thunk>>=
long	thunk;
@



%-------------------------------------------------------------

<<assemblers/aa/globals.c>>=
#include "aa.h"

<<global fi>>
<<global h>>

<<global debug>>
<<global hash>>
<<global Dlist>>
<<global nDlist>>
<<global ehist>>
<<global newflag>>
<<global hist>>
<<global hunk>>
<<global include>>
<<global iofree>>
<<global ionext>>
<<global iostack>>
<<global lineno>>
<<global nerrors>>
<<global nhunk>>
<<global ninclude>>
<<global outfile>>
<<global pass>>
<<global pathname>>
<<global pc>>
<<global peekc>>
<<global sym>>
<<global symb>>
<<global thechar>>
<<global thestring>>
<<global thunk>>
<<global obuf>>
@


\subsection*{[[assemblers/aa/lexbody.c]]}


<<function alloc>>=
/*
 * real allocs
 */
void*
alloc(long n)
{
    void *p;

    while((uintptr)hunk & MAXALIGN) {
        hunk++;
        nhunk--;
    }
    while(nhunk < n)
        gethunk();
    p = hunk;
    nhunk -= n;
    hunk += n;
    return p;
}
@

<<function allocn>>=
void*
allocn(void *p, long on, long n)
{
    void *q;

    q = (uchar*)p + on;
    if(q != hunk || nhunk < n) {
        while(nhunk < on+n)
            gethunk();
        memmove(hunk, p, on);
        p = hunk;
        hunk += on;
        nhunk -= on;
    }
    hunk += n;
    nhunk -= n;
    return p;
}
@



<<function pushio>>=
void
pushio(void)
{
    Io *i;

    i = iostack;
    if(i == I) {
        yyerror("botch in pushio");
        errorexit();
    }
    i->p = fi.p;
    i->c = fi.c;
}
@

<<function newio>>=
void
newio(void)
{
    Io *i;
    static int pushdepth = 0;

    i = iofree;
    if(i == I) {
        pushdepth++;
        if(pushdepth > 1000) {
            yyerror("macro/io expansion too deep");
            errorexit();
        }
        i = alloc(sizeof(*i));
    } else
        iofree = i->link;
    i->c = 0;
    i->f = -1;
    ionext = i;
}
@


<<function slookup>>=
Sym*
slookup(char *s)
{

    strcpy(symb, s);
    return lookup();
}
@

<<function lookup>>=
Sym*
lookup(void)
{
    Sym *s;
    long h;
    char *p;
    int c, l;

    h = 0;
    for(p=symb; c = *p; p++)
        h = h+h+h + c;
    l = (p - symb) + 1;
    if(h < 0)
        h = ~h;
    h %= NHASH;
    c = symb[0];
    for(s = hash[h]; s != S; s = s->link) {
        if(s->name[0] != c)
            continue;
        if(memcmp(s->name, symb, l) == 0)
            return s;
    }
    s = alloc(sizeof(*s));
    s->name = alloc(l);
    memmove(s->name, symb, l);

    s->link = hash[h];
    hash[h] = s;
    syminit(s);
    return s;
}
@










%-------------------------------------------------------------

<<assemblers/aa/lexbody.c>>=
#include "aa.h"

void prfile(long l);

/*
 * common code for all the assemblers
 */

<<function pragpack>>

<<function pragvararg>>

<<function pragfpround>>

<<function pragprofile>>

<<function pragincomplete>>

<<function alloc>>

<<function allocn>>

<<function setinclude>>

<<function errorexit>>

<<function pushio>>

<<function newio>>

<<function newfile>>

<<function slookup>>

<<function lookup>>

//long
//yylex(void)
//{
//	int c, c1;
//	char *cp;
//	Sym *s;
//
//	c = peekc;
//	if(c != IGN) {
//		peekc = IGN;
//		goto l1;
//	}
//l0:
//	c = GETC();
//
//l1:
//	if(c == EOF) {
//		peekc = EOF;
//		return -1;
//	}
//	if(isspace(c)) {
//		if(c == '\n') {
//			lineno++;
//			return ';';
//		}
//		goto l0;
//	}
//	if(isalpha(c))
//		goto talph;
//	if(isdigit(c))
//		goto tnum;
//	switch(c)
//	{
//	case '\n':
//		lineno++;
//		return ';';
//
//	case '#':
//		domacro();
//		goto l0;
//
//	case '.':
//		c = GETC();
//		if(isalpha(c)) {
//			cp = symb;
//			*cp++ = '.';
//			goto aloop;
//		}
//		if(isdigit(c)) {
//			cp = symb;
//			*cp++ = '.';
//			goto casedot;
//		}
//		peekc = c;
//		return '.';
//
//	talph:
//	case '_':
//	case '@':
//		cp = symb;
//
//	aloop:
//		*cp++ = c;
//		c = GETC();
//		if(isalpha(c) || isdigit(c) || c == '_' || c == '$')
//			goto aloop;
//		*cp = 0;
//		peekc = c;
//		s = lookup();
//		if(s->macro) {
//			newio();
//			cp = ionext->b;
//			macexpand(s, cp);
//			pushio();
//			ionext->link = iostack;
//			iostack = ionext;
//			fi.p = cp;
//			fi.c = strlen(cp);
//			if(peekc != IGN) {
//				cp[fi.c++] = peekc;
//				cp[fi.c] = 0;
//				peekc = IGN;
//			}
//			goto l0;
//		}
//		if(s->type == 0)
//			s->type = LNAME;
//		if(s->type == LNAME ||
//		   s->type == LVAR ||
//		   s->type == LLAB) {
//			yylval.sym = s;
//			return s->type;
//		}
//		yylval.lval = s->value;
//		return s->type;
//
//	tnum:
//		cp = symb;
//		if(c != '0')
//			goto dc;
//		*cp++ = c;
//		c = GETC();
//		c1 = 3;
//		if(c == 'x' || c == 'X') {
//			c1 = 4;
//			c = GETC();
//		} else
//		if(c < '0' || c > '7')
//			goto dc;
//		yylval.lval = 0;
//		for(;;) {
//			if(c >= '0' && c <= '9') {
//				if(c > '7' && c1 == 3)
//					break;
//				yylval.lval <<= c1;
//				yylval.lval += c - '0';
//				c = GETC();
//				continue;
//			}
//			if(c1 == 3)
//				break;
//			if(c >= 'A' && c <= 'F')
//				c += 'a' - 'A';
//			if(c >= 'a' && c <= 'f') {
//				yylval.lval <<= c1;
//				yylval.lval += c - 'a' + 10;
//				c = GETC();
//				continue;
//			}
//			break;
//		}
//		goto ncu;
//
//	dc:
//		for(;;) {
//			if(!isdigit(c))
//				break;
//			*cp++ = c;
//			c = GETC();
//		}
//		if(c == '.')
//			goto casedot;
//		if(c == 'e' || c == 'E')
//			goto casee;
//		*cp = 0;
//		if(sizeof(yylval.lval) == sizeof(vlong))
//			yylval.lval = strtoll(symb, nil, 10);
//		else
//			yylval.lval = strtol(symb, nil, 10);
//
//	ncu:
//		while(c == 'U' || c == 'u' || c == 'l' || c == 'L')
//			c = GETC();
//		peekc = c;
//		return LCONST;
//
//	casedot:
//		for(;;) {
//			*cp++ = c;
//			c = GETC();
//			if(!isdigit(c))
//				break;
//		}
//		if(c == 'e' || c == 'E')
//			goto casee;
//		goto caseout;
//
//	casee:
//		*cp++ = 'e';
//		c = GETC();
//		if(c == '+' || c == '-') {
//			*cp++ = c;
//			c = GETC();
//		}
//		while(isdigit(c)) {
//			*cp++ = c;
//			c = GETC();
//		}
//
//	caseout:
//		*cp = 0;
//		peekc = c;
//		if(FPCHIP) {
//			yylval.dval = atof(symb);
//			return LFCONST;
//		}
//		yyerror("assembler cannot interpret fp constants");
//		yylval.lval = 1L;
//		return LCONST;
//
//	case '"':
//		memcpy(yylval.sval, nullgen.sval, sizeof(yylval.sval));
//		cp = yylval.sval;
//		c1 = 0;
//		for(;;) {
//			c = escchar('"');
//			if(c == EOF)
//				break;
//			if(c1 < sizeof(yylval.sval))
//				*cp++ = c;
//			c1++;
//		}
//		if(c1 > sizeof(yylval.sval))
//			yyerror("string constant too long");
//		return LSCONST;
//
//	case '\'':
//		c = escchar('\'');
//		if(c == EOF)
//			c = '\'';
//		if(escchar('\'') != EOF)
//			yyerror("missing '");
//		yylval.lval = c;
//		return LCONST;
//
//	case '/':
//		c1 = GETC();
//		if(c1 == '/') {
//			for(;;) {
//				c = GETC();
//				if(c == '\n')
//					goto l1;
//				if(c == EOF) {
//					yyerror("eof in comment");
//					errorexit();
//				}
//			}
//		}
//		if(c1 == '*') {
//			for(;;) {
//				c = GETC();
//				while(c == '*') {
//					c = GETC();
//					if(c == '/')
//						goto l0;
//				}
//				if(c == EOF) {
//					yyerror("eof in comment");
//					errorexit();
//				}
//				if(c == '\n')
//					lineno++;
//			}
//		}
//		break;
//
//	default:
//		return c;
//	}
//	peekc = c1;
//	return c;
//}



<<function getc>>

<<function getnsc>>

<<function unget>>

<<function escchar>>

<<function pinit>>

<<function filbuf>>

<<function yyerror>>

<<function prfile>>

<<function ieeedtod>>
@
%$

\subsection*{[[assemblers/aa/macbody.c]]}

<<constant VARMAC>>=
#define VARMAC 0x80
@

<<function getnsn>>=
long
getnsn(void)
{
    long n;
    int c;

    c = getnsc();
    if(c < '0' || c > '9')
        return -1;
    n = 0;
    while(c >= '0' && c <= '9') {
        n = n*10 + c-'0';
        c = getc();
    }
    unget(c);
    return n;
}
@

<<function getsym>>=
Sym*
getsym(void)
{
    int c;
    char *cp;

    c = getnsc();
    if(!isalpha(c) && c != '_' && c < Runeself) {
        unget(c);
        return S;
    }
    for(cp = symb;;) {
        if(cp <= symb+NSYMB-4)
            *cp++ = c;
        c = getc();
        if(isalnum(c) || c == '_' || c >= Runeself)
            continue;
        unget(c);
        break;
    }
    *cp = 0;
    if(cp > symb+NSYMB-4)
        yyerror("symbol too large: %s", symb);
    return lookup();
}
@

<<function getsymdots>>=
Sym*
getsymdots(int *dots)
{
    int c;
    Sym *s;

    s = getsym();
    if(s != S)
        return s;

    c = getnsc();
    if(c != '.'){
        unget(c);
        return S;
    }
    if(getc() != '.' || getc() != '.')
        yyerror("bad dots in macro");
    *dots = 1;
    return slookup("__VA_ARGS__");
}
@

<<function getcom>>=
int
getcom(void)
{
    int c;

    for(;;) {
        c = getnsc();
        if(c != '/')
            break;
        c = getc();
        if(c == '/') {
            while(c != '\n')
                c = getc();
            break;
        }
        if(c != '*')
            break;
        c = getc();
        for(;;) {
            if(c == '*') {
                c = getc();
                if(c != '/')
                    continue;
                c = getc();
                break;
            }
            if(c == '\n') {
                yyerror("comment across newline");
                break;
            }
            c = getc();
        }
        if(c == '\n')
            break;
    }
    return c;
}
@

<<function dodefine>>=
void
dodefine(char *cp)
{
    Sym *s;
    char *p;
    long l;

    strcpy(symb, cp);
    p = strchr(symb, '=');
    if(p) {
        *p++ = 0;
        s = lookup();
        l = strlen(p) + 2;	/* +1 null, +1 nargs */
        while(l & 3)
            l++;
        while(nhunk < l)
            gethunk();
        *hunk = 0;
        strcpy(hunk+1, p);
        s->macro = hunk;
        hunk += l;
        nhunk -= l;
    } else {
        s = lookup();
        s->macro = "\0001";	/* \000 is nargs */
    }
    if(debug['m'])
        print("#define (-D) %s %s\n", s->name, s->macro+1);
}
@


<<function domacro>>=
void
domacro(void)
{
    int i;
    Sym *s;

    s = getsym();
    if(s == S)
        s = slookup("endif");
    for(i=0; mactab[i].macname; i++)
        if(strcmp(s->name, mactab[i].macname) == 0) {
            if(mactab[i].macf)
                (*mactab[i].macf)();
            else
                macif(i);
            return;
        }
    yyerror("unknown #: %s", s->name);
    macend();
}
@



<<function macexpand>>=
void
macexpand(Sym *s, char *b)
{
    char buf[2000];
    int n, l, c, nargs;
    char *arg[NARG], *cp, *ob, *ecp, dots;

    ob = b;
    if(*s->macro == 0) {
        strcpy(b, s->macro+1);
        if(debug['m'])
            print("#expand %s %s\n", s->name, ob);
        return;
    }
    
    nargs = (char)(*s->macro & ~VARMAC) - 1;
    dots = *s->macro & VARMAC;

    c = getnsc();
    if(c != '(')
        goto bad;
    n = 0;
    c = getc();
    if(c != ')') {
        unget(c);
        l = 0;
        cp = buf;
        ecp = cp + sizeof(buf)-4;
        arg[n++] = cp;
        for(;;) {
            if(cp >= ecp)
                goto toobig;
            c = getc();
            if(c == '"')
                for(;;) {
                    if(cp >= ecp)
                        goto toobig;
                    *cp++ = c;
                    c = getc();
                    if(c == '\\') {
                        *cp++ = c;
                        c = getc();
                        continue;
                    }
                    if(c == '\n')
                        goto bad;
                    if(c == '"')
                        break;
                }
            if(c == '\'')
                for(;;) {
                    if(cp >= ecp)
                        goto toobig;
                    *cp++ = c;
                    c = getc();
                    if(c == '\\') {
                        *cp++ = c;
                        c = getc();
                        continue;
                    }
                    if(c == '\n')
                        goto bad;
                    if(c == '\'')
                        break;
                }
            if(c == '/') {
                c = getc();
                switch(c) {
                case '*':
                    for(;;) {
                        c = getc();
                        if(c == '*') {
                            c = getc();
                            if(c == '/')
                                break;
                        }
                    }
                    *cp++ = ' ';
                    continue;
                case '/':
                    while((c = getc()) != '\n')
                        ;
                    break;
                default:
                    unget(c);
                    c = '/';
                }
            }
            if(l == 0) {
                if(c == ',') {
                    if(n == nargs && dots) {
                        *cp++ = ',';
                        continue;
                    }
                    *cp++ = 0;
                    arg[n++] = cp;
                    if(n > nargs)
                        break;
                    continue;
                }
                if(c == ')')
                    break;
            }
            if(c == '\n')
                c = ' ';
            *cp++ = c;
            if(c == '(')
                l++;
            if(c == ')')
                l--;
        }
        *cp = 0;
    }
    if(n != nargs) {
        yyerror("argument mismatch expanding: %s", s->name);
        *b = 0;
        return;
    }
    cp = s->macro+1;
    for(;;) {
        c = *cp++;
        if(c == '\n')
            c = ' ';
        if(c != '#') {
            *b++ = c;
            if(c == 0)
                break;
            continue;
        }
        c = *cp++;
        if(c == 0)
            goto bad;
        if(c == '#') {
            *b++ = c;
            continue;
        }
        c -= 'a';
        if(c < 0 || c >= n)
            continue;
        strcpy(b, arg[c]);
        b += strlen(arg[c]);
    }
    *b = 0;
    if(debug['m'])
        print("#expand %s %s\n", s->name, ob);
    return;

bad:
    yyerror("syntax in macro expansion: %s", s->name);
    *b = 0;
    return;

toobig:
    yyerror("too much text in macro expansion: %s", s->name);
    *b = 0;
}
@







<<function gethunk>>=
void
gethunk(void)
{
    char *h;
    long nh;

    nh = NHUNK;
    if(thunk >= 10L*NHUNK)
        nh = 10L*NHUNK;
    h = (char*)mysbrk(nh);
    if(h == (char*)-1) {
        yyerror("out of memory");
        errorexit();
    }
    hunk = h;
    nhunk = nh;
    thunk += nh;
}
@


%-------------------------------------------------------------

<<assemblers/aa/macbody.c>>=
#include "aa.h"

void	macund(void);
void	macdef(void);
void	macinc(void);
void	macprag(void);
void	maclin(void);
void	macif(int);
void	macend(void);

<<constant VARMAC>>

<<function getnsn>>

<<function getsym>>

<<function getsymdots>>

<<function getcom>>

<<function dodefine>>

<<global mactab>>

<<function domacro>>

<<function macund>>

<<constant NARG>>
<<function macdef>>

<<function macexpand>>

<<function macinc>>

<<function maclin>>

<<function macif>>

<<function macprag>>

<<function macend>>

<<function linehist>>

<<function gethunk>>
@


\section{[[assemblers/8a/]]}

\subsection*{[[assemblers/8a/a.h]]}

%-------------------------------------------------------------

<<assemblers/8a/a.h>>=
#include "../aa/aa.h"
#include "386/8.out.h"

typedef	struct	Gen	Gen;
typedef	struct	Gen2 	Gen2;

<<constant FPCHIP>>

<<struct Gen>>
<<struct Gen2>>

extern	char*	Dlist[30];
extern	int	nDlist;
extern	Gen	nullgen;
extern	int	pass;
extern	char*	pathname;
extern	char*	thestring;
extern	Biobuf	obuf;

// for a.y
long	yylex(void);
void	checkscale(int);
void	outcode(int, Gen2*);

int	escchar(int);
//void	zaddr(Gen*, int);
//void	zname(char*, int, int);
//Sym*	getsym(void);

// for lexbody
void	setinclude(char*);
void*	allocn(void*, long, long);
void	errorexit(void);
Sym*	slookup(char*);
void	pinit(char*);
void	ieeedtod(Ieee*, double);
void	dodefine(char*);
void	yyerror(char*, ...);
int	yyparse(void);

// for macbody
int	getc(void);
void	unget(int);
void	pushio(void);
void	newio(void);
void	newfile(char*, int);

// for macbody, was in lexbody

int	mywait(int*);
int	mycreat(char*, int);
int	systemtype(int);
int	pathchar(void);
char*	mygetwd(char*, int);
int	myfork(void);
void*	mysbrk(ulong);
@


\subsection*{[[assemblers/8a/globals.c]]}

%-------------------------------------------------------------

<<assemblers/8a/globals.c>>=
#include "a.h"

<<global nullgen>>
@


\subsection*{[[assemblers/8a/lex.c]]}

<<function checkscale>>=
void
checkscale(int scale)
{

    switch(scale) {
    case 1:
    case 2:
    case 4:
    case 8:
        return;
    }
    yyerror("scale must be 1248: %d", scale);
}
@

<<function syminit>>=
void
syminit(Sym *s)
{

    s->type = LNAME;
    s->value = 0;
}
@

<<function cclean>>=
void
cclean(void)
{
    Gen2 g2;

    g2.from = nullgen;
    g2.to = nullgen;
    outcode(AEND, &g2);
    Bflush(&obuf);
}
@

<<function zname>>=
void
zname(char *n, int t, int s)
{

    Bputc(&obuf, ANAME);		/* as(2) */
    Bputc(&obuf, ANAME>>8);
    Bputc(&obuf, t);		/* type */
    Bputc(&obuf, s);		/* sym */
    while(*n) {
        Bputc(&obuf, *n);
        n++;
    }
    Bputc(&obuf, 0);
}
@

<<function zaddr>>=
void
zaddr(Gen *a, int s)
{
    long l;
    int i, t;
    char *n;
    Ieee e;

    t = 0;
    if(a->index != D_NONE || a->scale != 0)
        t |= T_INDEX;
    if(a->offset != 0)
        t |= T_OFFSET;
    if(s != 0)
        t |= T_SYM;

    switch(a->type) {
    default:
        t |= T_TYPE;
        break;
    case D_FCONST:
        t |= T_FCONST;
        break;
    case D_CONST2:
        t |= T_OFFSET|T_OFFSET2;
        break;
    case D_SCONST:
        t |= T_SCONST;
        break;
    case D_NONE:
        break;
    }
    Bputc(&obuf, t);

    if(t & T_INDEX) {	/* implies index, scale */
        Bputc(&obuf, a->index);
        Bputc(&obuf, a->scale);
    }
    if(t & T_OFFSET) {	/* implies offset */
        l = a->offset;
        Bputc(&obuf, l);
        Bputc(&obuf, l>>8);
        Bputc(&obuf, l>>16);
        Bputc(&obuf, l>>24);
    }
    if(t & T_OFFSET2) {
        l = a->offset2;
        Bputc(&obuf, l);
        Bputc(&obuf, l>>8);
        Bputc(&obuf, l>>16);
        Bputc(&obuf, l>>24);
    }
    if(t & T_SYM)		/* implies sym */
        Bputc(&obuf, s);
    if(t & T_FCONST) {
        ieeedtod(&e, a->dval);
        l = e.l;
        Bputc(&obuf, l);
        Bputc(&obuf, l>>8);
        Bputc(&obuf, l>>16);
        Bputc(&obuf, l>>24);
        l = e.h;
        Bputc(&obuf, l);
        Bputc(&obuf, l>>8);
        Bputc(&obuf, l>>16);
        Bputc(&obuf, l>>24);
        return;
    }
    if(t & T_SCONST) {
        n = a->sval;
        for(i=0; i<NSNAME; i++) {
            Bputc(&obuf, *n);
            n++;
        }
        return;
    }
    if(t & T_TYPE)
        Bputc(&obuf, a->type);
}
@

<<function outcode>>=
void
outcode(int a, Gen2 *g2)
{
    int sf, st, t;
    Sym *s;

    if(pass == 1)
        goto out;

jackpot:
    sf = 0;
    s = g2->from.sym;
    while(s != S) {
        sf = s->sym;
        if(sf < 0 || sf >= NSYM)
            sf = 0;
        t = g2->from.type;
        if(t == D_ADDR)
            t = g2->from.index;
        if(h[sf].type == t)
        if(h[sf].sym == s)
            break;
        zname(s->name, t, sym);
        s->sym = sym;
        h[sym].sym = s;
        h[sym].type = t;
        sf = sym;
        sym++;
        if(sym >= NSYM)
            sym = 1;
        break;
    }
    st = 0;
    s = g2->to.sym;
    while(s != S) {
        st = s->sym;
        if(st < 0 || st >= NSYM)
            st = 0;
        t = g2->to.type;
        if(t == D_ADDR)
            t = g2->to.index;
        if(h[st].type == t)
        if(h[st].sym == s)
            break;
        zname(s->name, t, sym);
        s->sym = sym;
        h[sym].sym = s;
        h[sym].type = t;
        st = sym;
        sym++;
        if(sym >= NSYM)
            sym = 1;
        if(st == sf)
            goto jackpot;
        break;
    }
    Bputc(&obuf, a);
    Bputc(&obuf, a>>8);
    Bputc(&obuf, lineno);
    Bputc(&obuf, lineno>>8);
    Bputc(&obuf, lineno>>16);
    Bputc(&obuf, lineno>>24);
    zaddr(&g2->from, sf);
    zaddr(&g2->to, st);

out:
    if(a != AGLOBL && a != ADATA)
        pc++;
}
@

<<function outhist>>=
void
outhist(void)
{
    Gen g;
    Hist *h;
    char *p, *q, *op, c;
    int n;

    g = nullgen;
    c = pathchar();
    for(h = hist; h != H; h = h->link) {
        p = h->name;
        op = 0;
        if(p && p[0] != c && h->offset == 0 && pathname){
            if(pathname[0] == c){
                op = p;
                p = pathname;
            }
        }
        while(p) {
            q = strchr(p, c);
            if(q) {
                n = q-p;
                if(n == 0){
                    n = 1;	/* leading "/" */
                    *p = '/';	/* don't emit "\" on windows */
                }
                q++;
            } else {
                n = strlen(p);
                q = 0;
            }
            if(n) {
                Bputc(&obuf, ANAME);
                Bputc(&obuf, ANAME>>8);
                Bputc(&obuf, D_FILE);	/* type */
                Bputc(&obuf, 1);	/* sym */
                Bputc(&obuf, '<');
                Bwrite(&obuf, p, n);
                Bputc(&obuf, 0);
            }
            p = q;
            if(p == 0 && op) {
                p = op;
                op = 0;
            }
        }
        g.offset = h->offset;

        Bputc(&obuf, AHISTORY);
        Bputc(&obuf, AHISTORY>>8);
        Bputc(&obuf, h->line);
        Bputc(&obuf, h->line>>8);
        Bputc(&obuf, h->line>>16);
        Bputc(&obuf, h->line>>24);
        zaddr(&nullgen, 0);
        zaddr(&g, 0);
    }
}
@


%-------------------------------------------------------------

<<assemblers/8a/lex.c>>=
#include "a.h"
#include "y.tab.h"

void	cinit(void);
int	assemble(char*);
void	cclean(void);
void	outhist(void);

<<function main (assemblers/8a/lex.c)>>

<<function assemble>>

<<global itab>>

<<function cinit>>

<<function checkscale>>

<<function syminit>>

<<function cclean>>

<<function zname>>

<<function zaddr>>

<<function outcode>>

<<function outhist>>

// now use aa.a8
//#include "../cc/lexbody"
//#include "../cc/compat"

// used to be in ../cc/lexbody and factorized between assemblers by
// using #include, but ugly, so I copy pasted the function for now
<<function yylex>>

// #include "../cc/macbody"
@


