\documentclass[twocolumn]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse
% see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things:

%thx to codemap/codegraph:

%thx to this manual, better understand assembly?:

%history LP-ization:
% - skeleton, mostly copy paste of Template.tex.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * TODO ctor/dtor, dumper
% - read Extra section, identify concepts, first TOC
% - distribute parts of the file before
% - TODO nullify, boolify, typeify,    scheckify
% - TODO aspecify advanced features!
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\iffinal
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\fi
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
\usepackage{cleveref} %\cref
\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}
 %\usepackage[margin=0.5in]{geometry}
 %  but eat the bottom when very low
 %\usepackage{fullpage} is deprecated 
 % => do the more manual below:
 \addtolength{\oddsidemargin}{-.850in}
 \addtolength{\evensidemargin}{-.850in}
 \addtolength{\textwidth}{1.70in}
 \addtolength{\topmargin}{-.850in}
 \addtolength{\textheight}{1.70in}
%\usepackage{minitoc}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% used for forward decl, pragmas, func decl, extern decl, stats, #ifdef,
% debugging macros

%\setcounter{tocdepth}{1}

%******************************************************************************
% Title
%******************************************************************************

\begin{document}

\title{
{\Huge 
Plan9 Assembler
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}
}

\maketitle 
\onecolumn
\hrule
\begin{quote}
    Copyright \copyright{} 2014 Yoann Padioleau \\
    Permission is granted to copy, distribute and/or modify this document,
    except all the source code it contains, under the terms of the GNU Free
    Documentation License, Version 1.3.
\end{quote}
\hrule

%CONFIG: \dominitoc

\iffinal
\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\twocolumn
\tableofcontents
\endgroup
\else
\tableofcontents
\fi

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

\section{Motivations}

The goal of this book is to present in full details the source code of
an assembler.
Why? Because I think it makes you a better programmer if
you fully understand how things work under the hood.

Here are other candidates that were considered but ultimately discarded:
\begin{itemize}
\item gas
\item nasm
\item dev86
\end{itemize}

% there is also one in subc-2014

\section{Getting started}

\section{Requirements}

% asm.ps
% know an assembler

\section{About this document}
#include "../docs/latex/About.tex.nw"

\section{Copyright}

Most of this document is actually source code from Plan9, so
those parts are copyright by Lucent Technologies Inc.
The prose is mine and is licensed under the GNU Free Documentation
License.

\section{Acknowledgments}


\chapter{Overview}

\section{Assembler principles}

% symbolic names -> machine code

% before assembler, binary ... then opcode then symbolic!

% usually 2 passes as can reference stuff coming later
% pretty simple.

\section{[[8a]] services}

% command line interface?

% important -TText, see Kernel.tex.nw

\section{A toy [[hello.s]]}

% print hello world with mv, call, int, etc?

\section{Code organization}

\section{Architecture overview}

%need 386/8.out.h!

%actually lots of assembler related stuff is in libmach/
%and even maybe some in the linker.

% mac.x = macro :) non macos ...

%###############################################################################

\chapter{Core Data Structures}

% text -> AST -> symbols -> codegen 

\section{[[Instruction]] and [[Register]]}


%TODO: rename, and reorder to have first a set of mostly useful instr
% e.g. MOV, MOVB, etc. Could maybe analyze *.s in plan9 and do some
% stats?
<<enum as>>=
enum	as
{
    AXXX,
    AAAA,
    AAAD,
    AAAM,
    AAAS,
    AADCB,
    AADCL,
    AADCW,
    AADDB,
    AADDL,
    AADDW,
    AADJSP,
    AANDB,
    AANDL,
    AANDW,
    AARPL,
    ABOUNDL,
    ABOUNDW,
    ABSFL,
    ABSFW,
    ABSRL,
    ABSRW,
    ABTL,
    ABTW,
    ABTCL,
    ABTCW,
    ABTRL,
    ABTRW,
    ABTSL,
    ABTSW,
    ABYTE,
    ACALL,
    ACLC,
    ACLD,
    ACLI,
    ACLTS,
    ACMC,
    ACMPB,
    ACMPL,
    ACMPW,
    ACMPSB,
    ACMPSL,
    ACMPSW,
    ADAA,
    ADAS,
    ADATA,
    ADECB,
    ADECL,
    ADECW,
    ADIVB,
    ADIVL,
    ADIVW,
    AENTER,
    AGLOBL,
    AGOK,
    AHISTORY, // for header
    AHLT,
    AIDIVB,
    AIDIVL,
    AIDIVW,
    AIMULB,
    AIMULL,
    AIMULW,
    AINB,
    AINL,
    AINW,
    AINCB,
    AINCL,
    AINCW,
    AINSB,
    AINSL,
    AINSW,
    AINT,
    AINTO,
    AIRETL,
    AIRETW,
    AJCC,
    AJCS,
    AJCXZ,
    AJEQ,
    AJGE,
    AJGT,
    AJHI,
    AJLE,
    AJLS,
    AJLT,
    AJMI,
    AJMP,
    AJNE,
    AJOC,
    AJOS,
    AJPC,
    AJPL,
    AJPS,
    ALAHF,
    ALARL,
    ALARW,
    ALEAL,
    ALEAW,
    ALEAVEL,
    ALEAVEW,
    ALOCK,
    ALODSB,
    ALODSL,
    ALODSW,
    ALONG,
    ALOOP,
    ALOOPEQ,
    ALOOPNE,
    ALSLL,
    ALSLW,
    AMOVB,
    AMOVL,
    AMOVW,
    AMOVBLSX,
    AMOVBLZX,
    AMOVBWSX,
    AMOVBWZX,
    AMOVWLSX,
    AMOVWLZX,
    AMOVSB,
    AMOVSL,
    AMOVSW,
    AMULB,
    AMULL,
    AMULW,
    ANAME, // seems important
    ANEGB,
    ANEGL,
    ANEGW,
    ANOP,
    ANOTB,
    ANOTL,
    ANOTW,
    AORB,
    AORL,
    AORW,
    AOUTB,
    AOUTL,
    AOUTW,
    AOUTSB,
    AOUTSL,
    AOUTSW,
    APOPAL,
    APOPAW,
    APOPFL,
    APOPFW,
    APOPL,
    APOPW,
    APUSHAL,
    APUSHAW,
    APUSHFL,
    APUSHFW,
    APUSHL,
    APUSHW,
    ARCLB,
    ARCLL,
    ARCLW,
    ARCRB,
    ARCRL,
    ARCRW,
    AREP,
    AREPN,
    ARET,
    AROLB,
    AROLL,
    AROLW,
    ARORB,
    ARORL,
    ARORW,
    ASAHF,
    ASALB,
    ASALL,
    ASALW,
    ASARB,
    ASARL,
    ASARW,
    ASBBB,
    ASBBL,
    ASBBW,
    ASCASB,
    ASCASL,
    ASCASW,
    ASETCC,
    ASETCS,
    ASETEQ,
    ASETGE,
    ASETGT,
    ASETHI,
    ASETLE,
    ASETLS,
    ASETLT,
    ASETMI,
    ASETNE,
    ASETOC,
    ASETOS,
    ASETPC,
    ASETPL,
    ASETPS,
    ACDQ,
    ACWD,
    ASHLB,
    ASHLL,
    ASHLW,
    ASHRB,
    ASHRL,
    ASHRW,
    ASTC,
    ASTD,
    ASTI,
    ASTOSB,
    ASTOSL,
    ASTOSW,
    ASUBB,
    ASUBL,
    ASUBW,
    ASYSCALL,
    ATESTB,
    ATESTL,
    ATESTW,
    ATEXT,
    AVERR,
    AVERW,
    AWAIT,
    AWORD,
    AXCHGB,
    AXCHGL,
    AXCHGW,
    AXLAT,
    AXORB,
    AXORL,
    AXORW,

    AFMOVB,
    AFMOVBP,
    AFMOVD,
    AFMOVDP,
    AFMOVF,
    AFMOVFP,
    AFMOVL,
    AFMOVLP,
    AFMOVV,
    AFMOVVP,
    AFMOVW,
    AFMOVWP,
    AFMOVX,
    AFMOVXP,

    AFCOMB,
    AFCOMBP,
    AFCOMD,
    AFCOMDP,
    AFCOMDPP,
    AFCOMF,
    AFCOMFP,
    AFCOML,
    AFCOMLP,
    AFCOMW,
    AFCOMWP,
    AFUCOM,
    AFUCOMP,
    AFUCOMPP,

    AFADDDP,
    AFADDW,
    AFADDL,
    AFADDF,
    AFADDD,

    AFMULDP,
    AFMULW,
    AFMULL,
    AFMULF,
    AFMULD,

    AFSUBDP,
    AFSUBW,
    AFSUBL,
    AFSUBF,
    AFSUBD,

    AFSUBRDP,
    AFSUBRW,
    AFSUBRL,
    AFSUBRF,
    AFSUBRD,

    AFDIVDP,
    AFDIVW,
    AFDIVL,
    AFDIVF,
    AFDIVD,

    AFDIVRDP,
    AFDIVRW,
    AFDIVRL,
    AFDIVRF,
    AFDIVRD,

    AFXCHD,
    AFFREE,

    AFLDCW,
    AFLDENV,
    AFRSTOR,
    AFSAVE,
    AFSTCW,
    AFSTENV,
    AFSTSW,

    AF2XM1,
    AFABS,
    AFCHS,
    AFCLEX,
    AFCOS,
    AFDECSTP,
    AFINCSTP,
    AFINIT,
    AFLD1,
    AFLDL2E,
    AFLDL2T,
    AFLDLG2,
    AFLDLN2,
    AFLDPI,
    AFLDZ,
    AFNOP,
    AFPATAN,
    AFPREM,
    AFPREM1,
    AFPTAN,
    AFRNDINT,
    AFSCALE,
    AFSIN,
    AFSINCOS,
    AFSQRT,
    AFTST,
    AFXAM,
    AFXTRACT,
    AFYL2X,
    AFYL2XP1,

    AEND,

    ADYNT,
    AINIT,

    ASIGNAME,

    AFCOMI,
    AFCOMIP,
    AFUCOMI,
    AFUCOMIP,
    ACMPXCHGB,
    ACMPXCHGL,
    ACMPXCHGW,

    /* conditional move */
    ACMOVLCC,
    ACMOVLCS,
    ACMOVLEQ,
    ACMOVLGE,
    ACMOVLGT,
    ACMOVLHI,
    ACMOVLLE,
    ACMOVLLS,
    ACMOVLLT,
    ACMOVLMI,
    ACMOVLNE,
    ACMOVLOC,
    ACMOVLOS,
    ACMOVLPC,
    ACMOVLPL,
    ACMOVLPS,
    ACMOVWCC,
    ACMOVWCS,
    ACMOVWEQ,
    ACMOVWGE,
    ACMOVWGT,
    ACMOVWHI,
    ACMOVWLE,
    ACMOVWLS,
    ACMOVWLT,
    ACMOVWMI,
    ACMOVWNE,
    ACMOVWOC,
    ACMOVWOS,
    ACMOVWPC,
    ACMOVWPL,
    ACMOVWPS,

    AFCMOVCC,
    AFCMOVCS,
    AFCMOVEQ,
    AFCMOVHI,
    AFCMOVLS,
    AFCMOVNE,
    AFCMOVNU,
    AFCMOVUN,

    /* add new operations here. nowhere else. here. */
    ALAST
};
@

%\section{[[Register]]}

% split, stuff are not really registers
<<enum _anon_>>=
enum register
{
    D_AL		= 0,
    D_CL,
    D_DL,
    D_BL,

    D_AH		= 4,
    D_CH,
    D_DH,
    D_BH,

    D_AX		= 8,
    D_CX,
    D_DX,
    D_BX,
    D_SP,
    D_BP,
    D_SI,
    D_DI,

    D_F0		= 16,
    D_F7		= D_F0 + 7,

    D_CS		= 24,
    D_SS,
    D_DS,
    D_ES,
    D_FS,
    D_GS,

    D_GDTR,		/* global descriptor table register */
    D_IDTR,		/* interrupt descriptor table register */
    D_LDTR,		/* local descriptor table register */
    D_MSW,		/* machine status word */
    D_TASK,		/* task register */

    D_CR		= 35,
    D_DR		= 43,
    D_TR		= 51,
};

// must start after enum register?
// Gen.type?
enum misc {
    D_NONE		= 59,

    D_BRANCH	= 60,
    D_EXTERN	= 61,
    D_STATIC	= 62,
    D_AUTO		= 63,
    D_PARAM		= 64,
    D_CONST		= 65,
    D_FCONST	= 66,
    D_SCONST	= 67,
    D_ADDR		= 68,

    D_FILE,
    D_FILE1,

    D_INDIR,	/* additive */

    D_CONST2 = D_INDIR+D_INDIR,

    D_SIZE,	/* 8l internal */
};

enum misc2 {
    T_TYPE		= 1<<0,
    T_INDEX		= 1<<1,
    T_OFFSET	= 1<<2,
    T_FCONST	= 1<<3,
    T_SYM		= 1<<4,
    T_SCONST	= 1<<5,
    T_OFFSET2	= 1<<6,
    T_GOTYPE	= 1<<7,
};

enum misc3 {
    REGARG		= -1,
    REGRET		= D_AX,
    FREGRET		= D_F0,
    REGSP		= D_SP,
    REGTMP		= D_DI,
};
@

% LTYPE0 et is defined in a.y, tokens with value 
% instruction table conversion, string -> token
<<global itab>>=
struct Itab
{
    char	*name;
    ushort	type;
    ushort	value;
};

struct Itab itab[] =
{
    "SP",		LSP,	D_AUTO,
    "SB",		LSB,	D_EXTERN,
    "FP",		LFP,	D_PARAM,
    "PC",		LPC,	D_BRANCH,

    "AL",		LBREG,	D_AL,
    "CL",		LBREG,	D_CL,
    "DL",		LBREG,	D_DL,
    "BL",		LBREG,	D_BL,
    "AH",		LBREG,	D_AH,
    "CH",		LBREG,	D_CH,
    "DH",		LBREG,	D_DH,
    "BH",		LBREG,	D_BH,

    "AX",		LLREG,	D_AX,
    "CX",		LLREG,	D_CX,
    "DX",		LLREG,	D_DX,
    "BX",		LLREG,	D_BX,
/*	"SP",		LLREG,	D_SP,	*/
    "BP",		LLREG,	D_BP,
    "SI",		LLREG,	D_SI,
    "DI",		LLREG,	D_DI,

    "F0",		LFREG,	D_F0+0,
    "F1",		LFREG,	D_F0+1,
    "F2",		LFREG,	D_F0+2,
    "F3",		LFREG,	D_F0+3,
    "F4",		LFREG,	D_F0+4,
    "F5",		LFREG,	D_F0+5,
    "F6",		LFREG,	D_F0+6,
    "F7",		LFREG,	D_F0+7,

    "CS",		LSREG,	D_CS,
    "SS",		LSREG,	D_SS,
    "DS",		LSREG,	D_DS,
    "ES",		LSREG,	D_ES,
    "FS",		LSREG,	D_FS,
    "GS",		LSREG,	D_GS,

    "GDTR",		LBREG,	D_GDTR,
    "IDTR",		LBREG,	D_IDTR,
    "LDTR",		LBREG,	D_LDTR,
    "MSW",		LBREG,	D_MSW,
    "TASK",		LBREG,	D_TASK,

    "CR0",		LBREG,	D_CR+0,
    "CR1",		LBREG,	D_CR+1,
    "CR2",		LBREG,	D_CR+2,
    "CR3",		LBREG,	D_CR+3,
    "CR4",		LBREG,	D_CR+4,
    "CR5",		LBREG,	D_CR+5,
    "CR6",		LBREG,	D_CR+6,
    "CR7",		LBREG,	D_CR+7,

    "DR0",		LBREG,	D_DR+0,
    "DR1",		LBREG,	D_DR+1,
    "DR2",		LBREG,	D_DR+2,
    "DR3",		LBREG,	D_DR+3,
    "DR4",		LBREG,	D_DR+4,
    "DR5",		LBREG,	D_DR+5,
    "DR6",		LBREG,	D_DR+6,
    "DR7",		LBREG,	D_DR+7,

    "TR0",		LBREG,	D_TR+0,
    "TR1",		LBREG,	D_TR+1,
    "TR2",		LBREG,	D_TR+2,
    "TR3",		LBREG,	D_TR+3,
    "TR4",		LBREG,	D_TR+4,
    "TR5",		LBREG,	D_TR+5,
    "TR6",		LBREG,	D_TR+6,
    "TR7",		LBREG,	D_TR+7,

    "AAA",		LTYPE0,	AAAA,
    "AAD",		LTYPE0,	AAAD,
    "AAM",		LTYPE0,	AAAM,
    "AAS",		LTYPE0,	AAAS,
    "ADCB",		LTYPE3,	AADCB,
    "ADCL",		LTYPE3,	AADCL,
    "ADCW",		LTYPE3,	AADCW,
    "ADDB",		LTYPE3,	AADDB,
    "ADDL",		LTYPE3,	AADDL,
    "ADDW",		LTYPE3,	AADDW,
    "ADJSP",	LTYPE2,	AADJSP,
    "ANDB",		LTYPE3,	AANDB,
    "ANDL",		LTYPE3,	AANDL,
    "ANDW",		LTYPE3,	AANDW,
    "ARPL",		LTYPE3,	AARPL,
    "BOUNDL",	LTYPE3,	ABOUNDL,
    "BOUNDW",	LTYPE3,	ABOUNDW,
    "BSFL",		LTYPE3,	ABSFL,
    "BSFW",		LTYPE3,	ABSFW,
    "BSRL",		LTYPE3,	ABSRL,
    "BSRW",		LTYPE3,	ABSRW,
    "BTCL",		LTYPE3,	ABTCL,
    "BTCW",		LTYPE3,	ABTCW,
    "BTL",		LTYPE3,	ABTL,
    "BTRL",		LTYPE3,	ABTRL,
    "BTRW",		LTYPE3,	ABTRW,
    "BTSL",		LTYPE3,	ABTSL,
    "BTSW",		LTYPE3,	ABTSW,
    "BTW",		LTYPE3,	ABTW,
    "BYTE",		LTYPE2,	ABYTE,
    "CALL",		LTYPEC,	ACALL,
    "CLC",		LTYPE0,	ACLC,
    "CLD",		LTYPE0,	ACLD,
    "CLI",		LTYPE0,	ACLI,
    "CLTS",		LTYPE0,	ACLTS,
    "CMC",		LTYPE0,	ACMC,
    "CMPB",		LTYPE4,	ACMPB,
    "CMPL",		LTYPE4,	ACMPL,
    "CMPW",		LTYPE4,	ACMPW,
    "CMPSB",	LTYPE0,	ACMPSB,
    "CMPSL",	LTYPE0,	ACMPSL,
    "CMPSW",	LTYPE0,	ACMPSW,
    "CMPXCHGB",	LTYPE3,	ACMPXCHGB,
    "CMPXCHGL",	LTYPE3,	ACMPXCHGL,
    "CMPXCHGW",	LTYPE3,	ACMPXCHGW,
    "DAA",		LTYPE0,	ADAA,
    "DAS",		LTYPE0,	ADAS,
    "DATA",		LTYPED,	ADATA,
    "DECB",		LTYPE1,	ADECB,
    "DECL",		LTYPE1,	ADECL,
    "DECW",		LTYPE1,	ADECW,
    "DIVB",		LTYPE2,	ADIVB,
    "DIVL",		LTYPE2,	ADIVL,
    "DIVW",		LTYPE2,	ADIVW,
    "END",		LTYPE0,	AEND,
    "ENTER",	LTYPE2,	AENTER,
    "GLOBL",	LTYPEG,	AGLOBL,
    "HLT",		LTYPE0,	AHLT,
    "IDIVB",	LTYPE2,	AIDIVB,
    "IDIVL",	LTYPE2,	AIDIVL,
    "IDIVW",	LTYPE2,	AIDIVW,
    "IMULB",	LTYPEI,	AIMULB,
    "IMULL",	LTYPEI,	AIMULL,
    "IMULW",	LTYPEI,	AIMULW,
    "INB",		LTYPE0,	AINB,
    "INL",		LTYPE0,	AINL,
    "INW",		LTYPE0,	AINW,
    "INCB",		LTYPE1,	AINCB,
    "INCL",		LTYPE1,	AINCL,
    "INCW",		LTYPE1,	AINCW,
    "INSB",		LTYPE0,	AINSB,
    "INSL",		LTYPE0,	AINSL,
    "INSW",		LTYPE0,	AINSW,
    "INT",		LTYPE2,	AINT,
    "INTO",		LTYPE0,	AINTO,
    "IRETL",	LTYPE0,	AIRETL,
    "IRETW",	LTYPE0,	AIRETW,

    "JOS",		LTYPER,	AJOS,
    "JO",		LTYPER,	AJOS,	/* alternate */
    "JOC",		LTYPER,	AJOC,
    "JNO",		LTYPER,	AJOC,	/* alternate */
    "JCS",		LTYPER,	AJCS,
    "JB",		LTYPER,	AJCS,	/* alternate */
    "JC",		LTYPER,	AJCS,	/* alternate */
    "JNAE",		LTYPER,	AJCS,	/* alternate */
    "JLO",		LTYPER,	AJCS,	/* alternate */
    "JCC",		LTYPER,	AJCC,
    "JAE",		LTYPER,	AJCC,	/* alternate */
    "JNB",		LTYPER,	AJCC,	/* alternate */
    "JNC",		LTYPER,	AJCC,	/* alternate */
    "JHS",		LTYPER,	AJCC,	/* alternate */
    "JEQ",		LTYPER,	AJEQ,
    "JE",		LTYPER,	AJEQ,	/* alternate */
    "JZ",		LTYPER,	AJEQ,	/* alternate */
    "JNE",		LTYPER,	AJNE,
    "JNZ",		LTYPER,	AJNE,	/* alternate */
    "JLS",		LTYPER,	AJLS,
    "JBE",		LTYPER,	AJLS,	/* alternate */
    "JNA",		LTYPER,	AJLS,	/* alternate */
    "JHI",		LTYPER,	AJHI,
    "JA",		LTYPER,	AJHI,	/* alternate */
    "JNBE",		LTYPER,	AJHI,	/* alternate */
    "JMI",		LTYPER,	AJMI,
    "JS",		LTYPER,	AJMI,	/* alternate */
    "JPL",		LTYPER,	AJPL,
    "JNS",		LTYPER,	AJPL,	/* alternate */
    "JPS",		LTYPER,	AJPS,
    "JP",		LTYPER,	AJPS,	/* alternate */
    "JPE",		LTYPER,	AJPS,	/* alternate */
    "JPC",		LTYPER,	AJPC,
    "JNP",		LTYPER,	AJPC,	/* alternate */
    "JPO",		LTYPER,	AJPC,	/* alternate */
    "JLT",		LTYPER,	AJLT,
    "JL",		LTYPER,	AJLT,	/* alternate */
    "JNGE",		LTYPER,	AJLT,	/* alternate */
    "JGE",		LTYPER,	AJGE,
    "JNL",		LTYPER,	AJGE,	/* alternate */
    "JLE",		LTYPER,	AJLE,
    "JNG",		LTYPER,	AJLE,	/* alternate */
    "JGT",		LTYPER,	AJGT,
    "JG",		LTYPER,	AJGT,	/* alternate */
    "JNLE",		LTYPER,	AJGT,	/* alternate */

    "JCXZ",		LTYPER,	AJCXZ,
    "JMP",		LTYPEC,	AJMP,
    "LAHF",		LTYPE0,	ALAHF,
    "LARL",		LTYPE3,	ALARL,
    "LARW",		LTYPE3,	ALARW,
    "LEAL",		LTYPE3,	ALEAL,
    "LEAW",		LTYPE3,	ALEAW,
    "LEAVEL",	LTYPE0,	ALEAVEL,
    "LEAVEW",	LTYPE0,	ALEAVEW,
    "LOCK",		LTYPE0,	ALOCK,
    "LODSB",	LTYPE0,	ALODSB,
    "LODSL",	LTYPE0,	ALODSL,
    "LODSW",	LTYPE0,	ALODSW,
    "LONG",		LTYPE2,	ALONG,
    "LOOP",		LTYPER,	ALOOP,
    "LOOPEQ",	LTYPER,	ALOOPEQ,
    "LOOPNE",	LTYPER,	ALOOPNE,
    "LSLL",		LTYPE3,	ALSLL,
    "LSLW",		LTYPE3,	ALSLW,
    "MOVB",		LTYPE3,	AMOVB,
    "MOVL",		LTYPEM,	AMOVL,
    "MOVW",		LTYPEM,	AMOVW,
    "MOVBLSX",	LTYPE3, AMOVBLSX,
    "MOVBLZX",	LTYPE3, AMOVBLZX,
    "MOVBWSX",	LTYPE3, AMOVBWSX,
    "MOVBWZX",	LTYPE3, AMOVBWZX,
    "MOVWLSX",	LTYPE3, AMOVWLSX,
    "MOVWLZX",	LTYPE3, AMOVWLZX,
    "MOVSB",	LTYPE0,	AMOVSB,
    "MOVSL",	LTYPE0,	AMOVSL,
    "MOVSW",	LTYPE0,	AMOVSW,
    "MULB",		LTYPE2,	AMULB,
    "MULL",		LTYPE2,	AMULL,
    "MULW",		LTYPE2,	AMULW,
    "NEGB",		LTYPE1,	ANEGB,
    "NEGL",		LTYPE1,	ANEGL,
    "NEGW",		LTYPE1,	ANEGW,
    "NOP",		LTYPEN,	ANOP,
    "NOTB",		LTYPE1,	ANOTB,
    "NOTL",		LTYPE1,	ANOTL,
    "NOTW",		LTYPE1,	ANOTW,
    "ORB",		LTYPE3,	AORB,
    "ORL",		LTYPE3,	AORL,
    "ORW",		LTYPE3,	AORW,
    "OUTB",		LTYPE0,	AOUTB,
    "OUTL",		LTYPE0,	AOUTL,
    "OUTW",		LTYPE0,	AOUTW,
    "OUTSB",	LTYPE0,	AOUTSB,
    "OUTSL",	LTYPE0,	AOUTSL,
    "OUTSW",	LTYPE0,	AOUTSW,
    "POPAL",	LTYPE0,	APOPAL,
    "POPAW",	LTYPE0,	APOPAW,
    "POPFL",	LTYPE0,	APOPFL,
    "POPFW",	LTYPE0,	APOPFW,
    "POPL",		LTYPE1,	APOPL,
    "POPW",		LTYPE1,	APOPW,
    "PUSHAL",	LTYPE0,	APUSHAL,
    "PUSHAW",	LTYPE0,	APUSHAW,
    "PUSHFL",	LTYPE0,	APUSHFL,
    "PUSHFW",	LTYPE0,	APUSHFW,
    "PUSHL",	LTYPE2,	APUSHL,
    "PUSHW",	LTYPE2,	APUSHW,
    "RCLB",		LTYPE3,	ARCLB,
    "RCLL",		LTYPE3,	ARCLL,
    "RCLW",		LTYPE3,	ARCLW,
    "RCRB",		LTYPE3,	ARCRB,
    "RCRL",		LTYPE3,	ARCRL,
    "RCRW",		LTYPE3,	ARCRW,
    "REP",		LTYPE0,	AREP,
    "REPN",		LTYPE0,	AREPN,
    "RET",		LTYPE0,	ARET,
    "ROLB",		LTYPE3,	AROLB,
    "ROLL",		LTYPE3,	AROLL,
    "ROLW",		LTYPE3,	AROLW,
    "RORB",		LTYPE3,	ARORB,
    "RORL",		LTYPE3,	ARORL,
    "RORW",		LTYPE3,	ARORW,
    "SAHF",		LTYPE0,	ASAHF,
    "SALB",		LTYPE3,	ASALB,
    "SALL",		LTYPE3,	ASALL,
    "SALW",		LTYPE3,	ASALW,
    "SARB",		LTYPE3,	ASARB,
    "SARL",		LTYPE3,	ASARL,
    "SARW",		LTYPE3,	ASARW,
    "SBBB",		LTYPE3,	ASBBB,
    "SBBL",		LTYPE3,	ASBBL,
    "SBBW",		LTYPE3,	ASBBW,
    "SCASB",	LTYPE0,	ASCASB,
    "SCASL",	LTYPE0,	ASCASL,
    "SCASW",	LTYPE0,	ASCASW,
    "SETCC",	LTYPE1,	ASETCC,
    "SETCS",	LTYPE1,	ASETCS,
    "SETEQ",	LTYPE1,	ASETEQ,
    "SETGE",	LTYPE1,	ASETGE,
    "SETGT",	LTYPE1,	ASETGT,
    "SETHI",	LTYPE1,	ASETHI,
    "SETLE",	LTYPE1,	ASETLE,
    "SETLS",	LTYPE1,	ASETLS,
    "SETLT",	LTYPE1,	ASETLT,
    "SETMI",	LTYPE1,	ASETMI,
    "SETNE",	LTYPE1,	ASETNE,
    "SETOC",	LTYPE1,	ASETOC,
    "SETOS",	LTYPE1,	ASETOS,
    "SETPC",	LTYPE1,	ASETPC,
    "SETPL",	LTYPE1,	ASETPL,
    "SETPS",	LTYPE1,	ASETPS,
    "CDQ",		LTYPE0,	ACDQ,
    "CWD",		LTYPE0,	ACWD,
    "SHLB",		LTYPE3,	ASHLB,
    "SHLL",		LTYPES,	ASHLL,
    "SHLW",		LTYPES,	ASHLW,
    "SHRB",		LTYPE3,	ASHRB,
    "SHRL",		LTYPES,	ASHRL,
    "SHRW",		LTYPES,	ASHRW,
    "STC",		LTYPE0,	ASTC,
    "STD",		LTYPE0,	ASTD,
    "STI",		LTYPE0,	ASTI,
    "STOSB",	LTYPE0,	ASTOSB,
    "STOSL",	LTYPE0,	ASTOSL,
    "STOSW",	LTYPE0,	ASTOSW,
    "SUBB",		LTYPE3,	ASUBB,
    "SUBL",		LTYPE3,	ASUBL,
    "SUBW",		LTYPE3,	ASUBW,
    "SYSCALL",	LTYPE0,	ASYSCALL,
    "TESTB",	LTYPE3,	ATESTB,
    "TESTL",	LTYPE3,	ATESTL,
    "TESTW",	LTYPE3,	ATESTW,
    "TEXT",		LTYPET,	ATEXT,
    "VERR",		LTYPE2,	AVERR,
    "VERW",		LTYPE2,	AVERW,
    "WAIT",		LTYPE0,	AWAIT,
    "WORD",		LTYPE2,	AWORD,
    "XCHGB",	LTYPE3,	AXCHGB,
    "XCHGL",	LTYPE3,	AXCHGL,
    "XCHGW",	LTYPE3,	AXCHGW,
    "XLAT",		LTYPE2,	AXLAT,
    "XORB",		LTYPE3,	AXORB,
    "XORL",		LTYPE3,	AXORL,
    "XORW",		LTYPE3,	AXORW,

    "CMOVLCC",	LTYPE3,	ACMOVLCC,
    "CMOVLCS",	LTYPE3,	ACMOVLCS,
    "CMOVLEQ",	LTYPE3,	ACMOVLEQ,
    "CMOVLGE",	LTYPE3,	ACMOVLGE,
    "CMOVLGT",	LTYPE3,	ACMOVLGT,
    "CMOVLHI",	LTYPE3,	ACMOVLHI,
    "CMOVLLE",	LTYPE3,	ACMOVLLE,
    "CMOVLLS",	LTYPE3,	ACMOVLLS,
    "CMOVLLT",	LTYPE3,	ACMOVLLT,
    "CMOVLMI",	LTYPE3,	ACMOVLMI,
    "CMOVLNE",	LTYPE3,	ACMOVLNE,
    "CMOVLOC",	LTYPE3,	ACMOVLOC,
    "CMOVLOS",	LTYPE3,	ACMOVLOS,
    "CMOVLPC",	LTYPE3,	ACMOVLPC,
    "CMOVLPL",	LTYPE3,	ACMOVLPL,
    "CMOVLPS",	LTYPE3,	ACMOVLPS,
    "CMOVWCC",	LTYPE3,	ACMOVWCC,
    "CMOVWCS",	LTYPE3,	ACMOVWCS,
    "CMOVWEQ",	LTYPE3,	ACMOVWEQ,
    "CMOVWGE",	LTYPE3,	ACMOVWGE,
    "CMOVWGT",	LTYPE3,	ACMOVWGT,
    "CMOVWHI",	LTYPE3,	ACMOVWHI,
    "CMOVWLE",	LTYPE3,	ACMOVWLE,
    "CMOVWLS",	LTYPE3,	ACMOVWLS,
    "CMOVWLT",	LTYPE3,	ACMOVWLT,
    "CMOVWMI",	LTYPE3,	ACMOVWMI,
    "CMOVWNE",	LTYPE3,	ACMOVWNE,
    "CMOVWOC",	LTYPE3,	ACMOVWOC,
    "CMOVWOS",	LTYPE3,	ACMOVWOS,
    "CMOVWPC",	LTYPE3,	ACMOVWPC,
    "CMOVWPL",	LTYPE3,	ACMOVWPL,
    "CMOVWPS",	LTYPE3,	ACMOVWPS,

    "FMOVB",	LTYPE3, AFMOVB,
    "FMOVBP",	LTYPE3, AFMOVBP,
    "FMOVD",	LTYPE3, AFMOVD,
    "FMOVDP",	LTYPE3, AFMOVDP,
    "FMOVF",	LTYPE3, AFMOVF,
    "FMOVFP",	LTYPE3, AFMOVFP,
    "FMOVL",	LTYPE3, AFMOVL,
    "FMOVLP",	LTYPE3, AFMOVLP,
    "FMOVV",	LTYPE3, AFMOVV,
    "FMOVVP",	LTYPE3, AFMOVVP,
    "FMOVW",	LTYPE3, AFMOVW,
    "FMOVWP",	LTYPE3, AFMOVWP,
    "FMOVX",	LTYPE3, AFMOVX,
    "FMOVXP",	LTYPE3, AFMOVXP,
    "FCMOVCC",	LTYPE3, AFCMOVCC,
    "FCMOVCS",	LTYPE3, AFCMOVCS,
    "FCMOVEQ",	LTYPE3, AFCMOVEQ,
    "FCMOVHI",	LTYPE3, AFCMOVHI,
    "FCMOVLS",	LTYPE3, AFCMOVLS,
    "FCMOVNE",	LTYPE3, AFCMOVNE,
    "FCMOVNU",	LTYPE3, AFCMOVNU,
    "FCMOVUN",	LTYPE3, AFCMOVUN,
    "FCOMB",	LTYPE3, AFCOMB,
    "FCOMBP",	LTYPE3, AFCOMBP,
    "FCOMD",	LTYPE3, AFCOMD,
    "FCOMDP",	LTYPE3, AFCOMDP,
    "FCOMDPP",	LTYPE3, AFCOMDPP,
    "FCOMF",	LTYPE3, AFCOMF,
    "FCOMFP",	LTYPE3, AFCOMFP,
    "FCOMI",	LTYPE3, AFCOMI,
    "FCOMIP",	LTYPE3, AFCOMIP,
    "FCOML",	LTYPE3, AFCOML,
    "FCOMLP",	LTYPE3, AFCOMLP,
    "FCOMW",	LTYPE3, AFCOMW,
    "FCOMWP",	LTYPE3, AFCOMWP,
    "FUCOM",	LTYPE3, AFUCOM,
    "FUCOMI",	LTYPE3, AFUCOMI,
    "FUCOMIP",	LTYPE3, AFUCOMIP,
    "FUCOMP",	LTYPE3, AFUCOMP,
    "FUCOMPP",	LTYPE3, AFUCOMPP,
    "FADDW",	LTYPE3, AFADDW,
    "FADDL",	LTYPE3, AFADDL,
    "FADDF",	LTYPE3, AFADDF,
    "FADDD",	LTYPE3, AFADDD,
    "FADDDP",	LTYPE3, AFADDDP,
    "FSUBDP",	LTYPE3, AFSUBDP,
    "FSUBW",	LTYPE3, AFSUBW,
    "FSUBL",	LTYPE3, AFSUBL,
    "FSUBF",	LTYPE3, AFSUBF,
    "FSUBD",	LTYPE3, AFSUBD,
    "FSUBRDP",	LTYPE3, AFSUBRDP,
    "FSUBRW",	LTYPE3, AFSUBRW,
    "FSUBRL",	LTYPE3, AFSUBRL,
    "FSUBRF",	LTYPE3, AFSUBRF,
    "FSUBRD",	LTYPE3, AFSUBRD,
    "FMULDP",	LTYPE3, AFMULDP,
    "FMULW",	LTYPE3, AFMULW,
    "FMULL",	LTYPE3, AFMULL,
    "FMULF",	LTYPE3, AFMULF,
    "FMULD",	LTYPE3, AFMULD,
    "FDIVDP",	LTYPE3, AFDIVDP,
    "FDIVW",	LTYPE3, AFDIVW,
    "FDIVL",	LTYPE3, AFDIVL,
    "FDIVF",	LTYPE3, AFDIVF,
    "FDIVD",	LTYPE3, AFDIVD,
    "FDIVRDP",	LTYPE3, AFDIVRDP,
    "FDIVRW",	LTYPE3, AFDIVRW,
    "FDIVRL",	LTYPE3, AFDIVRL,
    "FDIVRF",	LTYPE3, AFDIVRF,
    "FDIVRD",	LTYPE3, AFDIVRD,
    "FXCHD",	LTYPE3, AFXCHD,
    "FFREE",	LTYPE1, AFFREE,
    "FLDCW",	LTYPE2, AFLDCW,
    "FLDENV",	LTYPE1, AFLDENV,
    "FRSTOR",	LTYPE2, AFRSTOR,
    "FSAVE",	LTYPE1, AFSAVE,
    "FSTCW",	LTYPE1, AFSTCW,
    "FSTENV",	LTYPE1, AFSTENV,
    "FSTSW",	LTYPE1, AFSTSW,
    "F2XM1",	LTYPE0, AF2XM1,
    "FABS",		LTYPE0, AFABS,
    "FCHS",		LTYPE0, AFCHS,
    "FCLEX",	LTYPE0, AFCLEX,
    "FCOS",		LTYPE0, AFCOS,
    "FDECSTP",	LTYPE0, AFDECSTP,
    "FINCSTP",	LTYPE0, AFINCSTP,
    "FINIT",	LTYPE0, AFINIT,
    "FLD1",		LTYPE0, AFLD1,
    "FLDL2E",	LTYPE0, AFLDL2E,
    "FLDL2T",	LTYPE0, AFLDL2T,
    "FLDLG2",	LTYPE0, AFLDLG2,
    "FLDLN2",	LTYPE0, AFLDLN2,
    "FLDPI",	LTYPE0, AFLDPI,
    "FLDZ",		LTYPE0, AFLDZ,
    "FNOP",		LTYPE0, AFNOP,
    "FPATAN",	LTYPE0, AFPATAN,
    "FPREM",	LTYPE0, AFPREM,
    "FPREM1",	LTYPE0, AFPREM1,
    "FPTAN",	LTYPE0, AFPTAN,
    "FRNDINT",	LTYPE0, AFRNDINT,
    "FSCALE",	LTYPE0, AFSCALE,
    "FSIN",		LTYPE0, AFSIN,
    "FSINCOS",	LTYPE0, AFSINCOS,
    "FSQRT",	LTYPE0, AFSQRT,
    "FTST",		LTYPE0, AFTST,
    "FXAM",		LTYPE0, AFXAM,
    "FXTRACT",	LTYPE0, AFXTRACT,
    "FYL2X",	LTYPE0, AFYL2X,
    "FYL2XP1",	LTYPE0, AFYL2XP1,

    0
};
@

\section{[[Sym]], [[h]] and [[hash]]}

% assembling is all about symbolic name processing!

<<struct Sym>>=
struct	Sym
{
    // see also itab[i].type and itab[i].value
    ushort	type;
    long	value; // vlong in va!!

    char	*name;
    char	sym;

    char*	macro;

    Ref*	ref; // unused for 5a, matters?

    // Extra
    Sym*	link;
};
@

<<constant S>>=
#define	S	((Sym*)0)
@


<<struct Ref>>=
// only for 8a actually
struct	Ref
{
    int	class;
};
@



<<struct Htab>>=
struct Htab
{
    Sym*	sym;
    short	type;
};
@

<<constant NSYM>>=
#define	NSYM	50
@

<<global h>>=
struct Htab h[NSYM];
@


<<global hash>>=
Sym*	hash[NHASH];
@

\section{[[Gen]], [[Gen2]]}


<<struct Gen>>=
struct	Gen
{
    //??
    Sym*	sym;

    char	sval[8];
    long	offset;
    long	offset2;

    // enum?
    short	type;
    short	index;

    short	scale;

    // float
    double	dval;
};
@

<<struct Gen2>>=
struct	Gen2
{
    Gen	from;
    Gen	to;
};
@

<<global nullgen>>=
Gen	nullgen;
@


\chapter{[[main()]]}

% e.g. "8"
<<global thechar>>=
int	thechar;
@

% e.g. "386"
<<global thestring>>=
char*	thestring;
@

% -o
<<global outfile>>=
char*	outfile;
@

<<global obuf>>=
Biobuf	obuf;
@

<<function main (assemblers/8a/lex.c)>>=
void
main(int argc, char *argv[])
{
    char *p;
    int nout, nproc, status, i, c;

    thechar = '8';
    thestring = "386";

    memset(debug, false, sizeof(debug));
    cinit();

    outfile = nil;
    include[ninclude++] = ".";

    ARGBEGIN {
    case 'o':
        outfile = ARGF();
        break;

    case 'D':
        p = ARGF();
        if(p)
            Dlist[nDlist++] = p;
        break;

    case 'I':
        p = ARGF();
        setinclude(p);
        break;

    default:
        c = ARGC();
        if(c >= 0 || c < sizeof(debug))
            debug[c] = true;
        break;

    } ARGEND

    if(*argv == 0) {
        print("usage: %ca [-options] file.s\n", thechar);
        errorexit();
    }

    if(argc > 1) {
        nproc = 1;
        if(p = getenv("NPROC"))
            nproc = atol(p);	/* */
        c = 0;
        nout = 0;
        for(;;) {
            while(nout < nproc && argc > 0) {
                i = myfork();
                if(i < 0) {
                    i = mywait(&status);
                    if(i < 0)
                        errorexit();
                    if(status)
                        c++;
                    nout--;
                    continue;
                }
                if(i == 0) {
                    print("%s:\n", *argv);
                    if(assemble(*argv))
                        errorexit();
                    exits(0);
                }
                nout++;
                argc--;
                argv++;
            }
            i = mywait(&status);
            if(i < 0) {
                if(c)
                    errorexit();
                exits(0);
            }
            if(status)
                c++;
            nout--;
        }
    }

    if(assemble(argv[0]))
        errorexit();
    exits(0);
}
@

% on windows would be different, but we don't care
% int -> Rune?
<<function pathchar>>=
int
pathchar(void)
{
    return '/';
}
@

% 2
<<global pass>>=
int	pass;
@

<<function assemble>>=
int
assemble(char *file)
{
    char ofile[100], incfile[20], *p;
    int i;
    fdt of;

    strcpy(ofile, file);

    p = utfrrune(ofile, pathchar());
    if(p) {
        include[0] = ofile;
        *p++ = 0;
    } else
        p = ofile;

    if(outfile == nil) {
        outfile = p;
        if(outfile){
            p = utfrrune(outfile, '.');
            if(p)
                if(p[1] == 's' && p[2] == 0)
                    p[0] = 0;
            p = utfrune(outfile, 0);
            p[0] = '.';
            p[1] = thechar;
            p[2] = 0;
        } else
            outfile = "/dev/null";
    }

    p = getenv("INCLUDE");
    if(p) {
        setinclude(p);
    } else {
        if(systemtype(Plan9)) {
            sprint(incfile,"/%s/include", thestring);
            setinclude(strdup(incfile));
        }
    }

    of = mycreat(outfile, 0664);
    if(of < 0) {
        yyerror("%ca: cannot create %s", thechar, outfile);
        errorexit();
    }
    Binit(&obuf, of, OWRITE);

    pass = 1;
    pinit(file);
    for(i=0; i<nDlist; i++)
        dodefine(Dlist[i]);
    yyparse(); //!
    if(nerrors) {
        cclean();
        return nerrors;
    }

    pass = 2;
    outhist();
    pinit(file);
    for(i=0; i<nDlist; i++)
        dodefine(Dlist[i]);
    yyparse();
    cclean();
    return nerrors;
}
@

% cwd, for #include
<<global pathname>>=
char*	pathname;
@

<<function cinit>>=
void
cinit(void)
{
    Sym *s;
    int i;

    nullgen.sym = S;
    nullgen.offset = 0;
    if(FPCHIP)
        nullgen.dval = 0;
    for(i=0; i<sizeof(nullgen.sval); i++)
        nullgen.sval[i] = 0;
    nullgen.type = D_NONE;
    nullgen.index = D_NONE;
    nullgen.scale = 0;

    nerrors = 0;
    iostack = I;
    iofree = I;
    peekc = IGN;
    nhunk = 0;
    for(i=0; i<NHASH; i++)
        hash[i] = S;

    for(i=0; itab[i].name; i++) {
        s = slookup(itab[i].name);
        if(s->type != LNAME)
            yyerror("double initialization %s", itab[i].name);
        s->type = itab[i].type;
        s->value = itab[i].value;
    }

    pathname = allocn(pathname, 0, 100);

    if(getwd(pathname, 99) == nil) {
        pathname = allocn(pathname, 100, 900);
        if(getwd(pathname, 999) == nil)
            strcpy(pathname, "/???");
    }
}
@


\chapter{Lexing}

% buffered IO
<<struct Fi>>=
struct Fi
{
    char*	p;
    int	c;
};
@

<<global fi>>=
struct Fi fi;
@


<<struct Io>>=
struct	Io
{
    Io*	link;
    char	b[BUFSIZ];
    char*	p;
    short	c;
    short	f;
};
@

<<global iofree>>=
Io*	iofree;
@

<<global ionext>>=
Io*	ionext;
@

<<global iostack>>=
Io*	iostack;
@

<<constant I>>=
#define	I	((Io*)0)
@



<<global lineno>>=
long	lineno;
@

<<global peekc>>=
int	peekc;
@


<<global pc>>=
long	pc;
@


<<function pinit>>=
void
pinit(char *f)
{
    int i;
    Sym *s;

    lineno = 1;
    newio();
    newfile(f, -1);
    pc = 0;
    peekc = IGN;
    sym = 1;
    for(i=0; i<NSYM; i++) {
        h[i].type = 0;
        h[i].sym = S;
    }
    for(i=0; i<NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            s->macro = 0;
}
@

<<function newfile>>=
void
newfile(char *s, int f)
{
    Io *i;

    i = ionext;
    i->link = iostack;
    iostack = i;
    i->f = f;
    if(f < 0)
        i->f = open(s, 0);
    if(i->f < 0) {
        yyerror("%ca: %r: %s", thechar, s);
        errorexit();
    }
    fi.c = 0;
    linehist(s, 0);
}
@



<<constant EOF>>=
#define	EOF		(-1)
@

<<constant IGN>>=
#define	IGN		(-2)
@

<<function GETC>>=
#define	GETC()		((--fi.c < 0)? filbuf(): *fi.p++ & 0xff)
@

<<function getc>>=

int
getc(void)
{
    int c;

    c = peekc;
    if(c != IGN) {
        peekc = IGN;
        return c;
    }
    c = GETC();
    if(c == '\n')
        lineno++;
    if(c == EOF) {
        yyerror("End of file");
        errorexit();
    }
    return c;
}
@


<<function filbuf>>=
int
filbuf(void)
{
    Io *i;

loop:
    i = iostack;
    if(i == I)
        return EOF;
    if(i->f < 0)
        goto pop;
    fi.c = read(i->f, i->b, BUFSIZ) - 1;
    if(fi.c < 0) {
        close(i->f);
        linehist(0, 0);
        goto pop;
    }
    fi.p = i->b + 1;
    return i->b[0];

pop:
    iostack = i->link;
    i->link = iofree;
    iofree = i;
    i = iostack;
    if(i == I)
        return EOF;
    fi.p = i->p;
    fi.c = i->c;
    if(--fi.c < 0)
        goto loop;
    return *fi.p++;
}
@



% get non space char
<<function getnsc>>=
int
getnsc(void)
{
    int c;

    for(;;) {
        c = getc();
        if(!isspace(c) || c == '\n')
            return c;
    }
}
@

<<function unget>>=
void
unget(int c)
{

    peekc = c;
    if(c == '\n')
        lineno--;
}
@


<<function escchar>>=
int
escchar(int e)
{
    int c, l;

loop:
    c = getc();
    if(c == '\n') {
        yyerror("newline in string");
        return EOF;
    }
    if(c != '\\') {
        if(c == e)
            return EOF;
        return c;
    }
    c = getc();
    if(c >= '0' && c <= '7') {
        l = c - '0';
        c = getc();
        if(c >= '0' && c <= '7') {
            l = l*8 + c-'0';
            c = getc();
            if(c >= '0' && c <= '7') {
                l = l*8 + c-'0';
                return l;
            }
        }
        peekc = c;
        return l;
    }
    switch(c)
    {
    case '\n':	goto loop;
    case 'n':	return '\n';
    case 't':	return '\t';
    case 'b':	return '\b';
    case 'r':	return '\r';
    case 'f':	return '\f';
    case 'a':	return 0x07;
    case 'v':	return 0x0b;
    case 'z':	return 0x00;
    }
    return c;
}
@


<<function yylex>>=
//
long
yylex(void)
{
    int c, c1;
    char *cp;
    Sym *s;

    c = peekc;
    if(c != IGN) {
        peekc = IGN;
        goto l1;
    }
l0:
    c = GETC();

l1:
    if(c == EOF) {
        peekc = EOF;
        return -1;
    }
    if(isspace(c)) {
        if(c == '\n') {
            lineno++;
            return ';';
        }
        goto l0;
    }
    if(isalpha(c))
        goto talph;
    if(isdigit(c))
        goto tnum;
    switch(c)
    {
    case '\n':
        lineno++;
        return ';';

    case '#':
        domacro();
        goto l0;

    case '.':
        c = GETC();
        if(isalpha(c)) {
            cp = symb;
            *cp++ = '.';
            goto aloop;
        }
        if(isdigit(c)) {
            cp = symb;
            *cp++ = '.';
            goto casedot;
        }
        peekc = c;
        return '.';

    case '_':
    case '@':
    talph:
        cp = symb;

    aloop:
        *cp++ = c;
        c = GETC();
        if(isalpha(c) || isdigit(c) || c == '_' || c == '$')
            goto aloop;
        *cp = 0;
        peekc = c;
        s = lookup();
        if(s->macro) {
            newio();
            cp = ionext->b;
            macexpand(s, cp);
            pushio();
            ionext->link = iostack;
            iostack = ionext;
            fi.p = cp;
            fi.c = strlen(cp);
            if(peekc != IGN) {
                cp[fi.c++] = peekc;
                cp[fi.c] = 0;
                peekc = IGN;
            }
            goto l0;
        }
        if(s->type == 0)
            s->type = LNAME;
        if(s->type == LNAME ||
           s->type == LVAR ||
           s->type == LLAB) {
            yylval.sym = s;
            return s->type;
        }
        yylval.lval = s->value;
        return s->type;

    tnum:
        cp = symb;
        if(c != '0')
            goto dc;
        *cp++ = c;
        c = GETC();
        c1 = 3;
        if(c == 'x' || c == 'X') {
            c1 = 4;
            c = GETC();
        } else
        if(c < '0' || c > '7')
            goto dc;
        yylval.lval = 0;
        for(;;) {
            if(c >= '0' && c <= '9') {
                if(c > '7' && c1 == 3)
                    break;
                yylval.lval <<= c1;
                yylval.lval += c - '0';
                c = GETC();
                continue;
            }
            if(c1 == 3)
                break;
            if(c >= 'A' && c <= 'F')
                c += 'a' - 'A';
            if(c >= 'a' && c <= 'f') {
                yylval.lval <<= c1;
                yylval.lval += c - 'a' + 10;
                c = GETC();
                continue;
            }
            break;
        }
        goto ncu;

    dc:
        for(;;) {
            if(!isdigit(c))
                break;
            *cp++ = c;
            c = GETC();
        }
        if(c == '.')
            goto casedot;
        if(c == 'e' || c == 'E')
            goto casee;
        *cp = 0;
        if(sizeof(yylval.lval) == sizeof(vlong))
            yylval.lval = strtoll(symb, nil, 10);
        else
            yylval.lval = strtol(symb, nil, 10);

    ncu:
        while(c == 'U' || c == 'u' || c == 'l' || c == 'L')
            c = GETC();
        peekc = c;
        return LCONST;

    casedot:
        for(;;) {
            *cp++ = c;
            c = GETC();
            if(!isdigit(c))
                break;
        }
        if(c == 'e' || c == 'E')
            goto casee;
        goto caseout;

    casee:
        *cp++ = 'e';
        c = GETC();
        if(c == '+' || c == '-') {
            *cp++ = c;
            c = GETC();
        }
        while(isdigit(c)) {
            *cp++ = c;
            c = GETC();
        }

    caseout:
        *cp = 0;
        peekc = c;
        if(FPCHIP) {
            yylval.dval = atof(symb);
            return LFCONST;
        }
        yyerror("assembler cannot interpret fp constants");
        yylval.lval = 1L;
        return LCONST;

    case '"':
        memcpy(yylval.sval, nullgen.sval, sizeof(yylval.sval));
        cp = yylval.sval;
        c1 = 0;
        for(;;) {
            c = escchar('"');
            if(c == EOF)
                break;
            if(c1 < sizeof(yylval.sval))
                *cp++ = c;
            c1++;
        }
        if(c1 > sizeof(yylval.sval))
            yyerror("string constant too long");
        return LSCONST;

    case '\'':
        c = escchar('\'');
        if(c == EOF)
            c = '\'';
        if(escchar('\'') != EOF)
            yyerror("missing '");
        yylval.lval = c;
        return LCONST;

    case '/':
        c1 = GETC();
        if(c1 == '/') {
            for(;;) {
                c = GETC();
                if(c == '\n')
                    goto l1;
                if(c == EOF) {
                    yyerror("eof in comment");
                    errorexit();
                }
            }
        }
        if(c1 == '*') {
            for(;;) {
                c = GETC();
                while(c == '*') {
                    c = GETC();
                    if(c == '/')
                        goto l0;
                }
                if(c == EOF) {
                    yyerror("eof in comment");
                    errorexit();
                }
                if(c == '\n')
                    lineno++;
            }
        }
        break;

    default:
        return c;
    }
    peekc = c1;
    return c;
}
@
%$


\chapter{Preprocessing}

<<global mactab>>=
struct
{
    char	*macname;
    void	(*macf)(void);
} mactab[] =
{
    "ifdef",	nil,	/* macif(0) */
    "ifndef",	nil,	/* macif(1) */
    "else",	nil,	/* macif(2) */

    "line",	maclin,
    "define",	macdef,
    "include",	macinc,
    "undef",	macund,

    "pragma",	macprag,
    "endif",	macend,
    0
};
@

<<function macend>>=
void
macend(void)
{
    int c;

    for(;;) {
        c = getnsc();
        if(c < 0 || c == '\n')
            return;
    }
}
@

<<struct Hist>>=
struct	Hist
{
    Hist*	link;
    char*	name;
    long	line;
    long	offset;
};
@

<<global ehist>>=
Hist*	ehist;
@

<<global hist>>=
Hist*	hist;
@

<<constant H>>=
#define	H	((Hist*)0)
@

\section{[[#include]] and [[-I]]}

<<constant NINCLUDE>>=
#define	NINCLUDE	10
@

<<global include>>=
char*	include[NINCLUDE];
@

<<global ninclude>>=
int	ninclude;
@

% -I 
<<function setinclude>>=
void
setinclude(char *p)
{
    int i;

    if(p == nil)
        return;
    for(i=1; i < ninclude; i++)
        if(strcmp(p, include[i]) == 0)
            return;

    if(ninclude >= nelem(include)) {
        yyerror("ninclude too small %d", nelem(include));
        exits("ninclude");
    }
    include[ninclude++] = p;
}
@


<<function macinc>>=
void
macinc(void)
{
    int c0, c, i, f;
    char str[STRINGSZ], *hp;

    c0 = getnsc();
    if(c0 != '"') {
        c = c0;
        if(c0 != '<')
            goto bad;
        c0 = '>';
    }
    for(hp = str;;) {
        c = getc();
        if(c == c0)
            break;
        if(c == '\n')
            goto bad;
        *hp++ = c;
    }
    *hp = 0;

    c = getcom();
    if(c != '\n')
        goto bad;

    f = -1;
    for(i=0; i<ninclude; i++) {
        if(i == 0 && c0 == '>')
            continue;
        strcpy(symb, include[i]);
        strcat(symb, "/");
        if(strcmp(symb, "./") == 0)
            symb[0] = 0;
        strcat(symb, str);
        f = open(symb, 0);
        if(f >= 0)
            break;
    }
    if(f < 0)
        strcpy(symb, str);
    c = strlen(symb) + 1;
    while(c & 3)
        c++;
    while(nhunk < c)
        gethunk();
    hp = hunk;
    memcpy(hunk, symb, c);
    nhunk -= c;
    hunk += c;
    newio();
    pushio();
    newfile(hp, f);
    return;

bad:
    unget(c);
    yyerror("syntax in #include");
    macend();
}
@

\section{[[#define]] and [[-D]]}

% -D
<<global Dlist>>=
char*	Dlist[30];
@

<<global nDlist>>=
int	nDlist;
@


<<function dodefine>>=
void
dodefine(char *cp)
{
    Sym *s;
    char *p;
    long l;

    strcpy(symb, cp);
    p = strchr(symb, '=');
    if(p) {
        *p++ = 0;
        s = lookup();
        l = strlen(p) + 2;	/* +1 null, +1 nargs */
        while(l & 3)
            l++;
        while(nhunk < l)
            gethunk();
        *hunk = 0;
        strcpy(hunk+1, p);
        s->macro = hunk;
        hunk += l;
        nhunk -= l;
    } else {
        s = lookup();
        s->macro = "\0001";	/* \000 is nargs */
    }
    if(debug['m'])
        print("#define (-D) %s %s\n", s->name, s->macro+1);
}
@




<<constant NARG>>=
#define	NARG	25
@

<<function macdef>>=
void
macdef(void)
{
    Sym *s, *a;
    char *args[NARG], *np, *base;
    int n, i, c, len, dots;
    int ischr;

    s = getsym();
    if(s == S)
        goto bad;
    if(s->macro)
        yyerror("macro redefined: %s", s->name);
    c = getc();
    n = -1;
    dots = 0;
    if(c == '(') {
        n++;
        c = getnsc();
        if(c != ')') {
            unget(c);
            for(;;) {
                a = getsymdots(&dots);
                if(a == S)
                    goto bad;
                if(n >= NARG) {
                    yyerror("too many arguments in #define: %s", s->name);
                    goto bad;
                }
                args[n++] = a->name;
                c = getnsc();
                if(c == ')')
                    break;
                if(c != ',' || dots)
                    goto bad;
            }
        }
        c = getc();
    }
    if(isspace(c))
        if(c != '\n')
            c = getnsc();
    base = hunk;
    len = 1;
    ischr = 0;
    for(;;) {
        if(isalpha(c) || c == '_') {
            np = symb;
            *np++ = c;
            c = getc();
            while(isalnum(c) || c == '_') {
                *np++ = c;
                c = getc();
            }
            *np = 0;
            for(i=0; i<n; i++)
                if(strcmp(symb, args[i]) == 0)
                    break;
            if(i >= n) {
                i = strlen(symb);
                base = allocn(base, len, i);
                memcpy(base+len, symb, i);
                len += i;
                continue;
            }
            base = allocn(base, len, 2);
            base[len++] = '#';
            base[len++] = 'a' + i;
            continue;
        }
        if(ischr){
            if(c == '\\'){ 
                base = allocn(base, len, 1);
                base[len++] = c;
                c = getc();
            }else if(c == ischr)
                ischr = 0;
        }else{
            if(c == '"' || c == '\''){
                base = allocn(base, len, 1);
                base[len++] = c;
                ischr = c;
                c = getc();
                continue;
            }
            if(c == '/') {
                c = getc();
                if(c == '/'){
                    c = getc();
                    for(;;) {
                        if(c == '\n')
                            break;
                        c = getc();
                    }
                    continue;
                }
                if(c == '*'){
                    c = getc();
                    for(;;) {
                        if(c == '*') {
                            c = getc();
                            if(c != '/')
                                continue;
                            c = getc();
                            break;
                        }
                        if(c == '\n') {
                            yyerror("comment and newline in define: %s", s->name);
                            break;
                        }
                        c = getc();
                    }
                    continue;
                }
                base = allocn(base, len, 1);
                base[len++] = '/';
                continue;
            }
        }
        if(c == '\\') {
            c = getc();
            if(c == '\n') {
                c = getc();
                continue;
            }
            else if(c == '\r') {
                c = getc();
                if(c == '\n') {
                    c = getc();
                    continue;
                }
            }
            base = allocn(base, len, 1);
            base[len++] = '\\';
            continue;
        }
        if(c == '\n')
            break;
        if(c == '#')
        if(n > 0) {
            base = allocn(base, len, 1);
            base[len++] = c;
        }
        base = allocn(base, len, 1);
        base[len++] = c;
        c = ((--fi.c < 0)? filbuf(): (*fi.p++ & 0xff));
        if(c == '\n')
            lineno++;
        if(c == -1) {
            yyerror("eof in a macro: %s", s->name);
            break;
        }
    }
    do {
        base = allocn(base, len, 1);
        base[len++] = 0;
    } while(len & 3);

    *base = n+1;
    if(dots)
        *base |= VARMAC;
    s->macro = base;
    if(debug['m'])
        print("#define %s %s\n", s->name, s->macro+1);
    return;

bad:
    if(s == S)
        yyerror("syntax in #define");
    else
        yyerror("syntax in #define: %s", s->name);
    macend();
}
@



\section{[[#undef]]}

<<function macund>>=
void
macund(void)
{
    Sym *s;

    s = getsym();
    macend();
    if(s == S) {
        yyerror("syntax in #undef");
        return;
    }
    s->macro = 0;
}
@

\section{[[#ifdef]]}

<<function macif>>=
void
macif(int f)
{
    int c, l, bol;
    Sym *s;

    if(f == 2)
        goto skip;
    s = getsym();
    if(s == S)
        goto bad;
    if(getcom() != '\n')
        goto bad;
    if((s->macro != 0) ^ f)
        return;

skip:
    bol = 1;
    l = 0;
    for(;;) {
        c = getc();
        if(c != '#') {
            if(!isspace(c))
                bol = 0;
            if(c == '\n')
                bol = 1;
            continue;
        }
        if(!bol)
            continue;
        s = getsym();
        if(s == S)
            continue;
        if(strcmp(s->name, "endif") == 0) {
            if(l) {
                l--;
                continue;
            }
            macend();
            return;
        }
        if(strcmp(s->name, "ifdef") == 0 || strcmp(s->name, "ifndef") == 0) {
            l++;
            continue;
        }
        if(l == 0 && f != 2 && strcmp(s->name, "else") == 0) {
            macend();
            return;
        }
    }

bad:
    yyerror("syntax in #if(n)def");
    macend();
}
@

\section{[[#pragma]]}

<<function pragpack>>=
void
pragpack(void)
{
    while(getnsc() != '\n')
        ;
}
@

<<function pragvararg>>=
void
pragvararg(void)
{
    while(getnsc() != '\n')
        ;
}
@

<<function pragfpround>>=
void
pragfpround(void)
{
    while(getnsc() != '\n')
        ;
}
@

<<function pragprofile>>=
void
pragprofile(void)
{
    while(getnsc() != '\n')
        ;
}
@

<<function pragincomplete>>=
void
pragincomplete(void)
{
    while(getnsc() != '\n')
        ;
}
@

<<function macprag>>=
void
macprag(void)
{
    Sym *s;
    int c0, c;
    char *hp;
    Hist *h;

    s = getsym();

    if(s && strcmp(s->name, "lib") == 0)
        goto praglib;
    if(s && strcmp(s->name, "pack") == 0) {
        pragpack();
        return;
    }
    if(s && strcmp(s->name, "fpround") == 0) {
        pragfpround();
        return;
    }
    if(s && strcmp(s->name, "profile") == 0) {
        pragprofile();
        return;
    }
    if(s && strcmp(s->name, "varargck") == 0) {
        pragvararg();
        return;
    }
    if(s && strcmp(s->name, "incomplete") == 0) {
        pragincomplete();
        return;
    }
    while(getnsc() != '\n')
        ;
    return;

praglib:
    c0 = getnsc();
    if(c0 != '"') {
        c = c0;
        if(c0 != '<')
            goto bad;
        c0 = '>';
    }
    for(hp = symb;;) {
        c = getc();
        if(c == c0)
            break;
        if(c == '\n')
            goto bad;
        *hp++ = c;
    }
    *hp = 0;
    c = getcom();
    if(c != '\n')
        goto bad;

    /*
     * put pragma-line in as a funny history 
     */
    c = strlen(symb) + 1;
    while(c & 3)
        c++;
    while(nhunk < c)
        gethunk();
    hp = hunk;
    memcpy(hunk, symb, c);
    nhunk -= c;
    hunk += c;

    h = alloc(sizeof(Hist));
    h->name = hp;
    h->line = lineno;
    h->offset = -1;
    h->link = H;
    if(ehist == H) {
        hist = h;
        ehist = h;
        return;
    }
    ehist->link = h;
    ehist = h;
    return;

bad:
    unget(c);
    yyerror("syntax in #pragma lib");
    macend();
}
@


\section{[[#line]]}

<<function maclin>>=
void
maclin(void)
{
    char *cp;
    int c;
    long n;

    n = getnsn();
    c = getc();
    if(n < 0)
        goto bad;

    for(;;) {
        if(c == ' ' || c == '\t') {
            c = getc();
            continue;
        }
        if(c == '"')
            break;
        if(c == '\n') {
            strcpy(symb, "<noname>");
            goto nn;
        }
        goto bad;
    }
    cp = symb;
    for(;;) {
        c = getc();
        if(c == '"')
            break;
        *cp++ = c;
    }
    *cp = 0;
    c = getcom();
    if(c != '\n')
        goto bad;

nn:
    c = strlen(symb) + 1;
    while(c & 3)
        c++;
    while(nhunk < c)
        gethunk();
    cp = hunk;
    memcpy(hunk, symb, c);
    nhunk -= c;
    hunk += c;
    linehist(cp, n);
    return;

bad:
    unget(c);
    yyerror("syntax in #line");
    macend();
}
@


<<function linehist>>=
void
linehist(char *f, int offset)
{
    Hist *h;

    /*
     * overwrite the last #line directive if
     * no alloc has happened since the last one
     */
    if(newflag == 0 && ehist != H && offset != 0 && ehist->offset != 0)
        if(f && ehist->name && strcmp(f, ehist->name) == 0) {
            ehist->line = lineno;
            ehist->offset = offset;
            return;
        }

    if(debug['f'])
        if(f) {
            if(offset)
                print("%4ld: %s (#line %d)\n", lineno, f, offset);
            else
                print("%4ld: %s\n", lineno, f);
        } else
            print("%4ld: <pop>\n", lineno);
    newflag = 0;

    h = alloc(sizeof(Hist));
    h->name = f;
    h->line = lineno;
    h->offset = offset;
    h->link = H;
    if(ehist == H) {
        hist = h;
        ehist = h;
        return;
    }
    ehist->link = h;
    ehist = h;
}
@

\chapter{Parsing}

<<8a/a.y>>=
%{
#include "a.h"
%}
%union	{
 Sym	*sym;
 long	lval;
 struct {
  long v1;
  long v2;
 } con2;
 double	dval;
 char	sval[8];
 Gen	gen;
 Gen2	gen2;
}
%left	'|'
%left	'^'
%left	'&'
%left	'<' '>'
%left	'+' '-'
%left	'*' '/' '%'
%token	<lval>	LTYPE0 LTYPE1 LTYPE2 LTYPE3 LTYPE4
%token	<lval>	LTYPEC LTYPED LTYPEN LTYPER LTYPET LTYPES LTYPEM LTYPEI LTYPEG
%token	<lval>	LCONST LFP LPC LSB
%token	<lval>	LBREG LLREG LSREG LFREG
%token	<dval>	LFCONST
%token	<sval>	LSCONST LSP
%token	<sym>	LNAME LLAB LVAR
%type	<lval>	con expr pointer offset
%type	<con2>	con2
%type	<gen>	mem imm imm2 reg nam rel rem rim rom omem nmem
%type	<gen2>	nonnon nonrel nonrem rimnon rimrem remrim
%type	<gen2>	spec1 spec2 spec3 spec4 spec5 spec6 spec7 spec8
%%
prog:
|	prog line

line:
 LLAB ':'
 {
  if($1->value != pc)
   yyerror("redeclaration of %s", $1->name);
  $1->value = pc;
 }
 line
|	LNAME ':'
 {
  $1->type = LLAB;
  $1->value = pc;
 }
 line
|	';'
|	inst ';'
|	error ';'

inst:
 LNAME '=' expr
 {
  $1->type = LVAR;
  $1->value = $3;
 }
|	LVAR '=' expr
 {
  if($1->value != $3)
   yyerror("redeclaration of %s", $1->name);
  $1->value = $3;
 }
|	LTYPE0 nonnon	{ outcode($1, &$2); }
|	LTYPE1 nonrem	{ outcode($1, &$2); }
|	LTYPE2 rimnon	{ outcode($1, &$2); }
|	LTYPE3 rimrem	{ outcode($1, &$2); }
|	LTYPE4 remrim	{ outcode($1, &$2); }
|	LTYPER nonrel	{ outcode($1, &$2); }
|	LTYPED spec1	{ outcode($1, &$2); }
|	LTYPET spec2	{ outcode($1, &$2); }
|	LTYPEC spec3	{ outcode($1, &$2); }
|	LTYPEN spec4	{ outcode($1, &$2); }
|	LTYPES spec5	{ outcode($1, &$2); }
|	LTYPEM spec6	{ outcode($1, &$2); }
|	LTYPEI spec7	{ outcode($1, &$2); }
|	LTYPEG spec8	{ outcode($1, &$2); }

nonnon:
 {
  $$.from = nullgen;
  $$.to = nullgen;
 }
|	','
 {
  $$.from = nullgen;
  $$.to = nullgen;
 }

rimrem:
 rim ',' rem
 {
  $$.from = $1;
  $$.to = $3;
 }

remrim:
 rem ',' rim
 {
  $$.from = $1;
  $$.to = $3;
 }

rimnon:
 rim ','
 {
  $$.from = $1;
  $$.to = nullgen;
 }
|	rim
 {
  $$.from = $1;
  $$.to = nullgen;
 }

nonrem:
 ',' rem
 {
  $$.from = nullgen;
  $$.to = $2;
 }
|	rem
 {
  $$.from = nullgen;
  $$.to = $1;
 }

nonrel:
 ',' rel
 {
  $$.from = nullgen;
  $$.to = $2;
 }
|	rel
 {
  $$.from = nullgen;
  $$.to = $1;
 }





spec1:	/* DATA */
 nam '/' con ',' imm
 {
  $$.from = $1;
  $$.from.scale = $3;
  $$.to = $5;
 }

spec2:	/* TEXT */
 mem ',' imm
 {
  $$.from = $1;
  $$.to = $3;
 }
|	mem ',' con ',' imm
 {
  $$.from = $1;
  $$.from.scale = $3;
  $$.to = $5;
 }

spec3:	/* JMP/CALL */
 ',' rom
 {
  $$.from = nullgen;
  $$.to = $2;
 }
|	rom
 {
  $$.from = nullgen;
  $$.to = $1;
 }

spec4:	/* NOP */
 nonnon
|	nonrem

spec5:	/* SHL/SHR */
 rim ',' rem
 {
  $$.from = $1;
  $$.to = $3;
 }
|	rim ',' rem ':' LLREG
 {
  $$.from = $1;
  $$.to = $3;
  if($$.from.index != D_NONE)
   yyerror("dp shift with lhs index");
  $$.from.index = $5;
 }

spec6:	/* MOVW/MOVL */
 rim ',' rem
 {
  $$.from = $1;
  $$.to = $3;
 }
|	rim ',' rem ':' LSREG
 {
  $$.from = $1;
  $$.to = $3;
  if($$.to.index != D_NONE)
   yyerror("dp move with lhs index");
  $$.to.index = $5;
 }

spec7:
 rim ','
 {
  $$.from = $1;
  $$.to = nullgen;
 }
|	rim
 {
  $$.from = $1;
  $$.to = nullgen;
 }
|	rim ',' rem
 {
  $$.from = $1;
  $$.to = $3;
 }

spec8:	/* GLOBL */
 mem ',' imm
 {
  $$.from = $1;
  $$.to = $3;
 }
|	mem ',' con ',' imm
 {
  $$.from = $1;
  $$.from.scale = $3;
  $$.to = $5;
 }






rem:
 reg
|	mem

rom:
 rel
|	nmem
|	'*' reg
 {
  $$ = $2;
 }
|	'*' omem
 {
  $$ = $2;
 }
|	reg
|	omem
|	imm

rim:
 rem
|	imm

rel:
 con '(' LPC ')'
 {
  $$ = nullgen;
  $$.type = D_BRANCH;
  $$.offset = $1 + pc;
 }
|	LNAME offset
 {
  $$ = nullgen;
  if(pass == 2)
   yyerror("undefined label: %s", $1->name);
  $$.type = D_BRANCH;
  $$.sym = $1;
  $$.offset = $2;
 }
|	LLAB offset
 {
  $$ = nullgen;
  $$.type = D_BRANCH;
  $$.sym = $1;
  $$.offset = $1->value + $2;
 }

reg:
 LBREG
 {
  $$ = nullgen;
  $$.type = $1;
 }
|	LFREG
 {
  $$ = nullgen;
  $$.type = $1;
 }
|	LLREG
 {
  $$ = nullgen;
  $$.type = $1;
 }
|	LSP
 {
  $$ = nullgen;
  $$.type = D_SP;
 }
|	LSREG
 {
  $$ = nullgen;
  $$.type = $1;
 }

imm:
 '$' con
 {
  $$ = nullgen;
  $$.type = D_CONST;
  $$.offset = $2;
 }
|	'$' nam
 {
  $$ = $2;
  $$.index = $2.type;
  $$.type = D_ADDR;
  /*
  if($2.type == D_AUTO || $2.type == D_PARAM)
   yyerror("constant cannot be automatic: %s",
    $2.sym->name);
   */
 }
|	'$' LSCONST
 {
  $$ = nullgen;
  $$.type = D_SCONST;
  memcpy($$.sval, $2, sizeof($$.sval));
 }
|	'$' LFCONST
 {
  $$ = nullgen;
  $$.type = D_FCONST;
  $$.dval = $2;
 }
|	'$' '(' LFCONST ')'
 {
  $$ = nullgen;
  $$.type = D_FCONST;
  $$.dval = $3;
 }
|	'$' '-' LFCONST
 {
  $$ = nullgen;
  $$.type = D_FCONST;
  $$.dval = -$3;
 }

imm2:
 '$' con2
 {
  $$ = nullgen;
  $$.type = D_CONST2;
  $$.offset = $2.v1;
  $$.offset2 = $2.v2;
 }

con2:
 LCONST
 {
  $$.v1 = $1;
  $$.v2 = 0;
 }
|	'-' LCONST
 {
  $$.v1 = -$2;
  $$.v2 = 0;
 }
|	LCONST '-' LCONST
 {
  $$.v1 = $1;
  $$.v2 = $3;
 }
|	'-' LCONST '-' LCONST
 {
  $$.v1 = -$2;
  $$.v2 = $4;
 }

mem:
 omem
|	nmem

omem:
 con
 {
  $$ = nullgen;
  $$.type = D_INDIR+D_NONE;
  $$.offset = $1;
 }
|	con '(' LLREG ')'
 {
  $$ = nullgen;
  $$.type = D_INDIR+$3;
  $$.offset = $1;
 }
|	con '(' LSP ')'
 {
  $$ = nullgen;
  $$.type = D_INDIR+D_SP;
  $$.offset = $1;
 }
|	con '(' LLREG '*' con ')'
 {
  $$ = nullgen;
  $$.type = D_INDIR+D_NONE;
  $$.offset = $1;
  $$.index = $3;
  $$.scale = $5;
  checkscale($$.scale);
 }
|	con '(' LLREG ')' '(' LLREG '*' con ')'
 {
  $$ = nullgen;
  $$.type = D_INDIR+$3;
  $$.offset = $1;
  $$.index = $6;
  $$.scale = $8;
  checkscale($$.scale);
 }
|	'(' LLREG ')'
 {
  $$ = nullgen;
  $$.type = D_INDIR+$2;
 }
|	'(' LSP ')'
 {
  $$ = nullgen;
  $$.type = D_INDIR+D_SP;
 }
|	con '(' LSREG ')'
 {
  $$ = nullgen;
  $$.type = D_INDIR+$3;
  $$.offset = $1;
 }
|	'(' LLREG '*' con ')'
 {
  $$ = nullgen;
  $$.type = D_INDIR+D_NONE;
  $$.index = $2;
  $$.scale = $4;
  checkscale($$.scale);
 }
|	'(' LLREG ')' '(' LLREG '*' con ')'
 {
  $$ = nullgen;
  $$.type = D_INDIR+$2;
  $$.index = $5;
  $$.scale = $7;
  checkscale($$.scale);
 }

nmem:
 nam
 {
  $$ = $1;
 }
|	nam '(' LLREG '*' con ')'
 {
  $$ = $1;
  $$.index = $3;
  $$.scale = $5;
  checkscale($$.scale);
 }

nam:
 LNAME offset '(' pointer ')'
 {
  $$ = nullgen;
  $$.type = $4;
  $$.sym = $1;
  $$.offset = $2;
 }
|	LNAME '<' '>' offset '(' LSB ')'
 {
  $$ = nullgen;
  $$.type = D_STATIC;
  $$.sym = $1;
  $$.offset = $4;
 }

offset:
 {
  $$ = 0;
 }
|	'+' con
 {
  $$ = $2;
 }
|	'-' con
 {
  $$ = -$2;
 }

pointer:
 LSB
|	LSP
 {
  $$ = D_AUTO;
 }
|	LFP

con:
 LCONST
|	LVAR
 {
  $$ = $1->value;
 }
|	'-' con
 {
  $$ = -$2;
 }
|	'+' con
 {
  $$ = $2;
 }
|	'~' con
 {
  $$ = ~$2;
 }
|	'(' expr ')'
 {
  $$ = $2;
 }

expr:
 con
|	expr '+' expr
 {
  $$ = $1 + $3;
 }
|	expr '-' expr
 {
  $$ = $1 - $3;
 }
|	expr '*' expr
 {
  $$ = $1 * $3;
 }
|	expr '/' expr
 {
  $$ = $1 / $3;
 }
|	expr '%' expr
 {
  $$ = $1 % $3;
 }
|	expr '<' '<' expr
 {
  $$ = $1 << $4;
 }
|	expr '>' '>' expr
 {
  $$ = $1 >> $4;
 }
|	expr '&' expr
 {
  $$ = $1 & $3;
 }
|	expr '^' expr
 {
  $$ = $1 ^ $3;
 }
|	expr '|' expr
 {
  $$ = $1 | $3;
 }

@

\chapter{Machine code generation}


% ? out hist??
<<function outhist>>=
void
outhist(void)
{
    Gen g;
    Hist *h;
    char *p, *q, *op, c;
    int n;

    g = nullgen;
    c = pathchar();
    for(h = hist; h != H; h = h->link) {
        p = h->name;
        op = nil;
        if(p && p[0] != c && h->offset == 0 && pathname){
            if(pathname[0] == c){
                op = p;
                p = pathname;
            }
        }
        while(p) {
            q = strchr(p, c);
            if(q) {
                n = q-p;
                if(n == 0){
                    n = 1;	/* leading "/" */
                    *p = '/';	/* don't emit "\" on windows */
                }
                q++;
            } else {
                n = strlen(p);
                q = 0;
            }
            if(n) {
                Bputc(&obuf, ANAME);
                Bputc(&obuf, ANAME>>8);
                Bputc(&obuf, D_FILE);	/* type */
                Bputc(&obuf, 1);	/* sym */
                Bputc(&obuf, '<');
                Bwrite(&obuf, p, n);
                Bputc(&obuf, 0);
            }
            p = q;
            if(p == 0 && op) {
                p = op;
                op = 0;
            }
        }
        g.offset = h->offset;

        Bputc(&obuf, AHISTORY);
        Bputc(&obuf, AHISTORY>>8);
        Bputc(&obuf, h->line);
        Bputc(&obuf, h->line>>8);
        Bputc(&obuf, h->line>>16);
        Bputc(&obuf, h->line>>24);
        zaddr(&nullgen, 0);
        zaddr(&g, 0);
    }
}
@



<<function zname>>=
void
zname(char *n, int t, int s)
{

    Bputc(&obuf, ANAME);		/* as(2) */
    Bputc(&obuf, ANAME>>8);
    Bputc(&obuf, t);		/* type */
    Bputc(&obuf, s);		/* sym */
    while(*n) {
        Bputc(&obuf, *n);
        n++;
    }
    Bputc(&obuf, 0);
}
@

<<function zaddr>>=
void
zaddr(Gen *a, int s)
{
    long l;
    int i, t;
    char *n;
    Ieee e;

    t = 0;
    if(a->index != D_NONE || a->scale != 0)
        t |= T_INDEX;
    if(a->offset != 0)
        t |= T_OFFSET;
    if(s != 0)
        t |= T_SYM;

    switch(a->type) {
    default:
        t |= T_TYPE;
        break;
    case D_FCONST:
        t |= T_FCONST;
        break;
    case D_CONST2:
        t |= T_OFFSET|T_OFFSET2;
        break;
    case D_SCONST:
        t |= T_SCONST;
        break;
    case D_NONE:
        break;
    }
    Bputc(&obuf, t);

    if(t & T_INDEX) {	/* implies index, scale */
        Bputc(&obuf, a->index);
        Bputc(&obuf, a->scale);
    }
    if(t & T_OFFSET) {	/* implies offset */
        l = a->offset;
        Bputc(&obuf, l);
        Bputc(&obuf, l>>8);
        Bputc(&obuf, l>>16);
        Bputc(&obuf, l>>24);
    }
    if(t & T_OFFSET2) {
        l = a->offset2;
        Bputc(&obuf, l);
        Bputc(&obuf, l>>8);
        Bputc(&obuf, l>>16);
        Bputc(&obuf, l>>24);
    }
    if(t & T_SYM)		/* implies sym */
        Bputc(&obuf, s);
    if(t & T_FCONST) {
        ieeedtod(&e, a->dval);
        l = e.l;
        Bputc(&obuf, l);
        Bputc(&obuf, l>>8);
        Bputc(&obuf, l>>16);
        Bputc(&obuf, l>>24);
        l = e.h;
        Bputc(&obuf, l);
        Bputc(&obuf, l>>8);
        Bputc(&obuf, l>>16);
        Bputc(&obuf, l>>24);
        return;
    }
    if(t & T_SCONST) {
        n = a->sval;
        for(i=0; i<NSNAME; i++) {
            Bputc(&obuf, *n);
            n++;
        }
        return;
    }
    if(t & T_TYPE)
        Bputc(&obuf, a->type);
}
@

<<function outcode>>=
void
outcode(int a, Gen2 *g2)
{
    int sf, st, t;
    Sym *s;

    if(pass == 1)
        goto out;

jackpot:
    sf = 0;
    s = g2->from.sym;
    while(s != S) {
        sf = s->sym;
        if(sf < 0 || sf >= NSYM)
            sf = 0;
        t = g2->from.type;
        if(t == D_ADDR)
            t = g2->from.index;
        if(h[sf].type == t)
        if(h[sf].sym == s)
            break;
        zname(s->name, t, sym);
        s->sym = sym;
        h[sym].sym = s;
        h[sym].type = t;
        sf = sym;
        sym++;
        if(sym >= NSYM)
            sym = 1;
        break;
    }
    st = 0;
    s = g2->to.sym;
    while(s != S) {
        st = s->sym;
        if(st < 0 || st >= NSYM)
            st = 0;
        t = g2->to.type;
        if(t == D_ADDR)
            t = g2->to.index;
        if(h[st].type == t)
        if(h[st].sym == s)
            break;
        zname(s->name, t, sym);
        s->sym = sym;
        h[sym].sym = s;
        h[sym].type = t;
        st = sym;
        sym++;
        if(sym >= NSYM)
            sym = 1;
        if(st == sf)
            goto jackpot;
        break;
    }
    Bputc(&obuf, a);
    Bputc(&obuf, a>>8);
    Bputc(&obuf, lineno);
    Bputc(&obuf, lineno>>8);
    Bputc(&obuf, lineno>>16);
    Bputc(&obuf, lineno>>24);
    zaddr(&g2->from, sf);
    zaddr(&g2->to, st);

out:
    if(a != AGLOBL && a != ADATA)
        pc++;
}
@

\chapter{Advanced Topics}

\section{Float}

<<struct ieee>>=
struct	ieee
{
    long	l;	/* contains ls-man	0xffffffff */
    long	h;	/* contains sign	0x80000000
                    exp		0x7ff00000
                    ms-man	0x000fffff */
};
@


<<function ieeedtod>>=
void
ieeedtod(Ieee *ieee, double native)
{
    double fr, ho, f;
    int exp;

    if(native < 0) {
        ieeedtod(ieee, -native);
        ieee->h |= 0x80000000L;
        return;
    }
    if(native == 0) {
        ieee->l = 0;
        ieee->h = 0;
        return;
    }
    fr = frexp(native, &exp);
    f = 2097152L;		/* shouldnt use fp constants here */
    fr = modf(fr*f, &ho);
    ieee->h = ho;
    ieee->h &= 0xfffffL;
    ieee->h |= (exp+1022L) << 20;
    f = 65536L;
    fr = modf(fr*f, &ho);
    ieee->l = ho;
    ieee->l <<= 16;
    ieee->l |= (long)(fr*f);
}
@

<<constant FPCHIP>>=
#define	FPCHIP		1
@


\section{Processing multiple files}

% why need that?

\chapter{Conclusion}

\appendix

\chapter{Debugging}


% 'm', 'f', 256 so can have for each character a boolean value
<<global debug>>=
bool	debug[256];
@

\chapter{Error Managment}

<<function errorexit>>=
void
errorexit(void)
{

    if(outfile)
        remove(outfile);
    exits("error");
}
@

<<global nerrors>>=
int	nerrors;
@

<<function yyerror>>=
void
yyerror(char *a, ...)
{
    char buf[200];
    va_list arg;

    /*
     * hack to intercept message from yaccpar
     */
    if(strcmp(a, "syntax error") == 0) {
        yyerror("syntax error, last name: %s", symb);
        return;
    }
    prfile(lineno);
    va_start(arg, a);
    vseprint(buf, buf+sizeof(buf), a, arg);
    va_end(arg);
    print("%s\n", buf);
    nerrors++;
    if(nerrors > 10) {
        print("too many errors\n");
        errorexit();
    }
}
@

<<function prfile>>=
void
prfile(long l)
{
    int i, n;
    Hist a[HISTSZ], *h;
    long d;

    n = 0;
    for(h = hist; h != H; h = h->link) {
        if(l < h->line)
            break;
        if(h->name) {
            if(h->offset == 0) {
                if(n >= 0 && n < HISTSZ)
                    a[n] = *h;
                n++;
                continue;
            }
            if(n > 0 && n < HISTSZ)
                if(a[n-1].offset == 0) {
                    a[n] = *h;
                    n++;
                } else
                    a[n-1] = *h;
            continue;
        }
        n--;
        if(n >= 0 && n < HISTSZ) {
            d = h->line - a[n].line;
            for(i=0; i<n; i++)
                a[i].line += d;
        }
    }
    if(n > HISTSZ)
        n = HISTSZ;
    for(i=0; i<n; i++)
        print("%s:%ld ", a[i].name, (long)(l-a[i].line+a[i].offset+1));
}
@

\chapter{Libc}

\chapter{Extra Code}

\ifallcode
#include "Assembler_extra.tex.nw"
\fi

\chapter{Changelog}
\label{sec:changelog}

\chapter{Glossary}
\label{sec:glossary}

\begin{verbatim}
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{section}{Index}

%\chapter{References} 
\addcontentsline{toc}{section}{References}

\begin{thebibliography}{99}

\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming}, 
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb}, 
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison}, 
\url{http://padator.org/software/project-syncweb/readme.txt}

\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
