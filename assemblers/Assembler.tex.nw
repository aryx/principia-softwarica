\documentclass[twocolumn]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse
% see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things:
%  - better organisation of the code, TOC better than the few existing
%    files (that didn't have very good names)
%  - removed deadcode (Ref, imm2, con2)
%  - TODO rename types, clearer, Gen? Gen2? as? Adr and Prog?

%thx to codemap/codegraph/scheck:
% - factorized code in aa/
% - TODO mv errorexit, alloc, in utils.c instead of lexbody.c, same for gethunk
% - TODO main.c

%thx to this manual, better understand assembly?:
% - TODO can actually understand the assembly code in Kernel.tex.nw :)
% - DATA vs GLOBL?
% - fpic?

%history LP-ization:
% - skeleton, mostly copy paste of Template.tex.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * TODO ctor/dtor, dumper
%    * SEMI [[xxx]] other fields, [[xxx]] extra fields
% - read Extra section, identify concepts, first TOC
% - distribute parts of the file before
% - SEMI nullify, boolify, typeify,    scheckify
% - SEMI aspecify advanced features!
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\iffinal
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\fi
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
%\usepackage{cleveref} %\cref
%\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}
 %\usepackage[margin=0.5in]{geometry}
 %  but eat the bottom when very low
 %\usepackage{fullpage} is deprecated 
 % => do the more manual below:
 \addtolength{\oddsidemargin}{-.850in}
 \addtolength{\evensidemargin}{-.850in}
 \addtolength{\textwidth}{1.70in}
 \addtolength{\topmargin}{-.850in}
 \addtolength{\textheight}{1.70in}
%\usepackage{minitoc}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% used for forward decl, pragmas, func decl, extern decl, stats, #ifdef,
% debugging macros

%\setcounter{tocdepth}{1}

%******************************************************************************
% Title
%******************************************************************************

\begin{document}

\title{
{\Huge 
Plan9 Assembler
}\\
x86 (32 bits) edition\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}
}

\maketitle 
\onecolumn
\hrule
\begin{quote}
    Copyright \copyright{} 2014 Yoann Padioleau \\
    Permission is granted to copy, distribute and/or modify this document,
    except all the source code it contains, under the terms of the GNU Free
    Documentation License, Version 1.3.
\end{quote}
\hrule

%CONFIG: \dominitoc

\iffinal
\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\twocolumn
\tableofcontents
\endgroup
\else
\tableofcontents
\fi

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

\section{Motivations}

The goal of this book is to present in full details the source code of
an assembler.
Why? Because I think it makes you a better programmer if
you fully understand how things work under the hood.

% we gonna focus on plan9's assembler 8a because ... because
% it's simple, short code, and consistent with the rest of my
% endeavour :)

Here are other candidates that were considered but ultimately discarded:
\begin{itemize}
\item gas
\item nasm
\item dev86
\end{itemize}

% hex2c

%todo? there is also one in subc-2014

\section{Getting started}

% see Kernel.tex.nw section?

\section{Requirements}

% know at least one assembler

% asm.ps

\section{About this document}
#include "../docs/latex/About.tex.nw"

\section{Copyright}

Most of this document is actually source code from Plan9, so
those parts are copyright by Lucent Technologies Inc.
The prose is mine and is licensed under the GNU Free Documentation
License.

\section{Acknowledgments}


\chapter{Overview}

\section{Assembler principles}

% mnemonic and symbolic addresses -> object/machine code

% before was writing binary, then mnemonic but still hardcoded
% address, and then finally symbolic addresses

% usually 2 passes as can reference stuff coming later.
% pretty simple.

% can also have some simple constant expressions, macros, to be more
% convenient.

% TODO: look at TECS section on assembler?

\section{[[8a]] services}

% command line interface? -o outfile,   -D -I (cpp),  -f -m for debug

% env: INCLUDE (for cpp, similar to -I), NPROC (when multi files?)

\section{[[helloworld.s]]}

% print "hello world" with mv, call, int, etc? with no libc!
% (and a _main (or even just _start?))

% show commands, 8a, ld, ./xxx

% show binary format? hexdump? 
% (actually not x86 binary instruction format! see section below)


% try show code using TEXT, DATA, GLOBL, different addressing modes,
% etc

% can also maybe show one that use libc, use 8c -S hello.c

\section{x86}

% opcode format, see my assembler in ml I wrote a long time ago! in xix-assembler/?
% hmm actually it's more the job of 8l and optab to do that

\section{Input assembly language}

% specifics of 8a? like left to right or right to left for mv, intel
% or AT&T syntax (I guess AT&T :) )

% the many different addressing modes. Actually I think 8a allows
% more than what is allowed (optab handles the ugly restrictions
% of Intel?)


% 8 bytes limit for strings (so if longer have to split manually,
% a bit annoying but can use data2s too)

%concepts: 
% - labels suffixed with :
% - constants, prefixed with $ (why? to avoid ambiguity with what?)
%   otherwise regular numbers are offset like 32(SP)
% - external symbols = fully unresolved! will be resolved at linking time
%   but needs to keep the name in the symbol table and the place where it
%   was referenced

%        LONG    $-(0x1BADB002 + 0x00010003)     /* checksum */
%vs
%        LONG    $_start-KZERO(SB)          /* load_addr */
%why need SB in second case? because it refers to symbol in certain section?

% special registers for addressing: PC, SB, FP, SP
% for text, data, param, locals

\section{Output object format}

% .8 format? a kind of .o, but 8l does actually the job to turn into x86 ISA
% so it's really more a marshalled file of simple data structures that is
% x86 specific only because of the set of opcode and registers really.

%note: should really simplify the code at some point and use Ocaml/Rust
% and just marshall the ADT, and do same in linker => shorter code!

\section{Code organization}

\section{Architecture overview}

% arch generic: aa/, arch specific: xa/
% same for header, common.out.h and 386/8.out.h!

%actually lots of assembler related stuff is in libmach/
%and lots in the linker.

% mac.c = macro (not macos)

% relation with other tools? 8c, 8l? easy, do for instance:
% git grep AADDB
%assemblers/8a/lex.c:    "ADDB",		LTYPE3,	AADDB,
%compilers/8c/peep.c:    case AADDB:	/* rhs rar */
%compilers/8c/reg.c:        case AADDB:
%compilers/8c/txt.c:            a = AADDB;
%include/386/8.out.h:    AADDB,
%linkers/8l/optab.c:    { AADDB,	yxorb,	Px, 0x04,0x80,(00),0x00,0x02 },

% assembler actually generate a binary that is x86 specific, but not 
% matching the x86 instruction set! optab.c is doing the real conversion
% (why? because 8l does some inter-lib optimizations? a la llvm? nice design!)
% it generates an "object", a kind of .o except it's really not a .o like
% in Linux :)

% text -> grammar -> symbols -> codegen 
% does not really use an AST, abuse tokens and the grammar to
% do some computations (the classic old way to do things)

% main -> assemble -> yyparse -> yylex
%                             -> outcode that increments pc and in pass2 output

%###############################################################################

\chapter{Core Data Structures}


\section{[[Opcode]] and [[Operand_kind]]}

%TODO: reorder to have first a set of mostly useful instructions
% e.g. MOV, MOVB, etc. Could maybe analyze *.s in plan9 and do some
% stats? or use cg on the whole plan9 and see how much AXXX is used
% hmmm but can reorder? the opcode generation rely on an order? or 
% just 'ld' and 'as' need to agree with each other; the actual binary code
% generation is done in the linker. Hmm but can have some issues
% if want to play with what is cross-compiled!

% TODO maybe by playing with Literate Programming I can reproduce a kind of ADT?
% e.g. by introducing LSREG, and then the part of the enum register related
% to LSREG?
% type instr = 
%   ...
% type reg = 
%   ...


<<enum as>>=
// coupling: with 8c/enam.c, 8l/obj.c#optab
enum opcode
{
    AXXX,

    AAAA,
    AAAD,
    AAAM,
    AAAS,
    AADCB,
    AADCL,
    AADCW,
    AADDB,
    AADDL,
    AADDW,
    AADJSP,
    AANDB,
    AANDL,
    AANDW,
    AARPL,
    ABOUNDL,
    ABOUNDW,
    ABSFL,
    ABSFW,
    ABSRL,
    ABSRW,
    ABTL,
    ABTW,
    ABTCL,
    ABTCW,
    ABTRL,
    ABTRW,
    ABTSL,
    ABTSW,

    ABYTE, //

    ACALL, //

    ACLC,
    ACLD,

    ACLI, //

    ACLTS,
    ACMC,

    ACMPB, //
    ACMPL,
    ACMPW,

    ACMPSB,
    ACMPSL,
    ACMPSW,
    ADAA,
    ADAS,

    ADATA, //


    ADECB, //
    ADECL,
    ADECW,

    ADIVB, //
    ADIVL,
    ADIVW,

    AENTER, //

    AGLOBL, //

    AGOK, //?

    AHISTORY, // for ?

    AHLT, //

    AIDIVB,
    AIDIVL,
    AIDIVW,
    AIMULB,
    AIMULL,
    AIMULW,

    AINB, //
    AINL,
    AINW,

    AINCB, //
    AINCL,
    AINCW,

    AINSB,
    AINSL,
    AINSW,
    AINT,
    AINTO,
    AIRETL,
    AIRETW,

    AJCC, //
    AJCS,
    AJCXZ,
    AJEQ,
    AJGE,
    AJGT,
    AJHI,
    AJLE,
    AJLS,
    AJLT,
    AJMI,

    AJMP, //

    AJNE,

    AJOC,
    AJOS,
    AJPC,
    AJPL,
    AJPS,
    ALAHF,
    ALARL,
    ALARW,
    ALEAL,
    ALEAW,
    ALEAVEL,
    ALEAVEW,

    ALOCK, //

    ALODSB, //
    ALODSL,
    ALODSW,

    ALONG, //

    ALOOP,
    ALOOPEQ,
    ALOOPNE,
    ALSLL,
    ALSLW,

    AMOVB, //
    AMOVL,
    AMOVW,

    AMOVBLSX,
    AMOVBLZX,
    AMOVBWSX,
    AMOVBWZX,
    AMOVWLSX,
    AMOVWLZX,
    AMOVSB,
    AMOVSL,
    AMOVSW,

    AMULB, //
    AMULL,
    AMULW,

    ANAME, // seems important

    ANEGB, //
    ANEGL,
    ANEGW,

    ANOP, //

    ANOTB, //
    ANOTL,
    ANOTW,

    AORB, //
    AORL,
    AORW,

    AOUTB, //
    AOUTL,
    AOUTW,

    AOUTSB,
    AOUTSL,
    AOUTSW,

    APOPAL,
    APOPAW,
    APOPFL,
    APOPFW,
    APOPL,
    APOPW,
    APUSHAL,
    APUSHAW,
    APUSHFL,
    APUSHFW,
    APUSHL,
    APUSHW,
    ARCLB,
    ARCLL,
    ARCLW,
    ARCRB,
    ARCRL,
    ARCRW,

    AREP,

    AREPN,

    ARET, //

    AROLB,
    AROLL,
    AROLW,
    ARORB,
    ARORL,
    ARORW,
    ASAHF,
    ASALB,
    ASALL,
    ASALW,
    ASARB,
    ASARL,
    ASARW,
    ASBBB,
    ASBBL,
    ASBBW,
    ASCASB,
    ASCASL,
    ASCASW,
    ASETCC,
    ASETCS,
    ASETEQ,
    ASETGE,
    ASETGT,
    ASETHI,
    ASETLE,
    ASETLS,
    ASETLT,
    ASETMI,
    ASETNE,
    ASETOC,
    ASETOS,
    ASETPC,
    ASETPL,
    ASETPS,
    ACDQ,
    ACWD,
    ASHLB,
    ASHLL,
    ASHLW,
    ASHRB,
    ASHRL,
    ASHRW,
    ASTC,
    ASTD,
    ASTI,

    ASTOSB, //
    ASTOSL,
    ASTOSW,

    ASUBB, //
    ASUBL,
    ASUBW,

    ASYSCALL, // !!!!!!

    ATESTB,
    ATESTL,
    ATESTW,

    ATEXT, // procedure/function TODO rename to AFUNC?

    AVERR,
    AVERW,
    AWAIT,
    AWORD,

    AXCHGB, //
    AXCHGL,
    AXCHGW,

    AXLAT,
    AXORB,
    AXORL,
    AXORW,

    AFMOVB,
    AFMOVBP,
    AFMOVD,
    AFMOVDP,
    AFMOVF,
    AFMOVFP,
    AFMOVL,
    AFMOVLP,
    AFMOVV,
    AFMOVVP,
    AFMOVW,
    AFMOVWP,
    AFMOVX,
    AFMOVXP,

    AFCOMB,
    AFCOMBP,
    AFCOMD,
    AFCOMDP,
    AFCOMDPP,
    AFCOMF,
    AFCOMFP,
    AFCOML,
    AFCOMLP,
    AFCOMW,
    AFCOMWP,
    AFUCOM,
    AFUCOMP,
    AFUCOMPP,

    AFADDDP,
    AFADDW,
    AFADDL,
    AFADDF,
    AFADDD,

    AFMULDP,
    AFMULW,
    AFMULL,
    AFMULF,
    AFMULD,

    AFSUBDP,
    AFSUBW,
    AFSUBL,
    AFSUBF,
    AFSUBD,

    AFSUBRDP,
    AFSUBRW,
    AFSUBRL,
    AFSUBRF,
    AFSUBRD,

    AFDIVDP,
    AFDIVW,
    AFDIVL,
    AFDIVF,
    AFDIVD,

    AFDIVRDP,
    AFDIVRW,
    AFDIVRL,
    AFDIVRF,
    AFDIVRD,

    AFXCHD,
    AFFREE,

    AFLDCW,
    AFLDENV,
    AFRSTOR,
    AFSAVE,
    AFSTCW,
    AFSTENV,
    AFSTSW,

    AF2XM1,
    AFABS,
    AFCHS,
    AFCLEX,
    AFCOS,
    AFDECSTP,
    AFINCSTP,
    AFINIT,
    AFLD1,
    AFLDL2E,
    AFLDL2T,
    AFLDLG2,
    AFLDLN2,
    AFLDPI,
    AFLDZ,
    AFNOP,
    AFPATAN,
    AFPREM,
    AFPREM1,
    AFPTAN,
    AFRNDINT,
    AFSCALE,
    AFSIN,
    AFSINCOS,
    AFSQRT,
    AFTST,
    AFXAM,
    AFXTRACT,
    AFYL2X,
    AFYL2XP1,

    AEND, // ??

    ADYNT,
    AINIT,

    ASIGNAME,

    AFCOMI,
    AFCOMIP,
    AFUCOMI,
    AFUCOMIP,
    ACMPXCHGB,
    ACMPXCHGL,
    ACMPXCHGW,

    /* conditional move */
    ACMOVLCC,
    ACMOVLCS,
    ACMOVLEQ,
    ACMOVLGE,
    ACMOVLGT,
    ACMOVLHI,
    ACMOVLLE,
    ACMOVLLS,
    ACMOVLLT,
    ACMOVLMI,
    ACMOVLNE,
    ACMOVLOC,
    ACMOVLOS,
    ACMOVLPC,
    ACMOVLPL,
    ACMOVLPS,
    ACMOVWCC,
    ACMOVWCS,
    ACMOVWEQ,
    ACMOVWGE,
    ACMOVWGT,
    ACMOVWHI,
    ACMOVWLE,
    ACMOVWLS,
    ACMOVWLT,
    ACMOVWMI,
    ACMOVWNE,
    ACMOVWOC,
    ACMOVWOS,
    ACMOVWPC,
    ACMOVWPL,
    ACMOVWPS,

    AFCMOVCC,
    AFCMOVCS,
    AFCMOVEQ,
    AFCMOVHI,
    AFCMOVLS,
    AFCMOVNE,
    AFCMOVNU,
    AFCMOVUN,

    /* add new operations here. nowhere else. here. */
    ALAST
};
@
% was called 'enum as'

%\section{[[Register]]}

% ADT would be far better than this enum and separate Sym.
% less: rename operand_part1, to show that need another part
% to be a complete operand (which is Gen =~ Adr)
<<enum reg>>=
enum operand_kind
{
<<[[operand_kind]] register cases>>
    D_NONE		= 59,
<<[[operand_kind]] non register cases>>
};
@

%less: could have start at 1 here so could have D_NONE = 0
<<[[operand_kind]] register cases>>=
    D_AL		= 0,
    D_CL,
    D_DL,
    D_BL,

    D_AH		= 4,
    D_CH,
    D_DH,
    D_BH,

    D_AX		= 8,
    D_CX,
    D_DX,
    D_BX,
    D_SP,
    D_BP,
    D_SI,
    D_DI,

    D_F0		= 16,
    D_F7		= D_F0 + 7,

    D_CS		= 24,
    D_SS,
    D_DS,
    D_ES,
    D_FS,
    D_GS,

    D_GDTR,		/* global descriptor table register */
    D_IDTR,		/* interrupt descriptor table register */
    D_LDTR,		/* local descriptor table register */
    D_MSW,		/* machine status word */
    D_TASK,		/* task register */

    D_CR		= 35, // D_CR0 .. D_CR7
    D_DR		= 43, // D_DR0 .. D_DR7
    D_TR		= 51, // D_TR0 .. D_TR7
@

% how get the remaining info? e.g. for D_BRANCH to get the symbol or int 
% you'll have too look in Gen.value
<<[[operand_kind]] non register cases>>=
    // for ACALL, AJMP (from PC)
    D_BRANCH	= 60, 

    // For ADATA
    D_EXTERN	= 61, // data/bss values (from SB)
    D_STATIC	= 62, // data static variables (from SB)
    D_AUTO	= 63, // stack values (from SP)
    D_PARAM	= 64, // parameter (from FP)

    D_CONST	= 65,
    D_FCONST	= 66,
    D_SCONST	= 67,

    D_ADDR	= 68,
@

% ???
<<[[operand_kind]] non register cases>>=
    D_FILE,
    D_FILE1, // used by linker only

    D_INDIR,	/* additive */

    D_CONST2 = D_INDIR+D_INDIR,

    D_SIZE,	/* 8l internal */
@


%INDIR? faux ami avec previous D_FILE ... it's not about a directory 
% it's INDIRECT, (AX) => =~ *AX, = deref
%  D_INDIR + D_AX (D_INDIR only with register cases, hence safe D_CONST2)
%  ugly ... we really need ADT and simple recursive types ...
% see Dconv in Compiler.tex.nw, seems only for D_INDIR of register

% works with Gen (aka Adr) so it's really
% type operand = 
%  | R of register
%  | Indir of register
%  | Branch of offset (PC)
%  | Extern of name * offset (SB) ?
%  | ...
% see Dconv in Compiler.tex.nw, seems only for D_INDIR of register



% for 8c! conventions! (not used at all by 8a, but in 8.out.h for other tools)
<<enum misc3>>=
enum misc3 {
    REGARG		= -1,
    REGRET		= D_AX,
    FREGRET		= D_F0,
    REGSP		= D_SP,
    REGTMP		= D_DI,
};
@

\section{[[Token]] and [[itab]]}

% the first part is essentially for keywords
<<token declarations>>=
%token  <lval>  LTYPE0 LTYPE1 LTYPE2 LTYPE3 LTYPE4
%token  <lval>  LTYPEC LTYPED LTYPEN LTYPER LTYPET LTYPES LTYPEM LTYPEI LTYPEG
%token  <lval>  LFP LPC LSB LSP
%token  <lval>  LBREG LLREG LSREG LFREG

%token  <lval>  LCONST 
%token  <dval>  LFCONST
%token  <sval>  LSCONST
%token  <sym>   LNAME LLAB LVAR
@
%pad's bugfix? LSP was was LFCONST, does not make sense


<<union token>>=
%union  {
 //   enum<opcode> (for LTYPE/...) 
 // | enum<operand_kind> (for LBREG/...) 
 // | long (for LCONST)
 long   lval;

 double dval;
 char   sval[8];
 Sym    *sym;

 <<[[Token]] other fields>>
}
@
% sval[8]?? can't have string more than 8 bytes? hence the data2c
% ugly list?
% note: mutual ref with sym here where sym has itself a type that is 
% the token code

% could use NSNAME here instead of char sval[8] ? and at a few other places?
% from 8.out.h
<<constant NSNAME>>=
#define	NSNAME	8
@



% LTYPE0 etc are defined in a.y, tokens with value 
% instruction table conversion, string -> token
<<struct Itab>>=
struct Itab
{
    char	*name;

    //token code
    ushort	type;
    //enum<opcode> | enum<operand_kind>
    ushort	value;
};
@

% TODO: just put a subset with most relevant instr and registers
% hmm ADT would be better than union and this
%    // could put D_NONE as a.y actually redo the job of setting Gen.value
%    // appropriately
<<global itab>>=
struct Itab itab[] =
{
    "SP",		LSP,	D_AUTO,
    "SB",		LSB,	D_EXTERN,
    "FP",		LFP,	D_PARAM,
    "PC",		LPC,	D_BRANCH,

    "AL",		LBREG,	D_AL,
    "CL",		LBREG,	D_CL,
    "DL",		LBREG,	D_DL,
    "BL",		LBREG,	D_BL,
    "AH",		LBREG,	D_AH,
    "CH",		LBREG,	D_CH,
    "DH",		LBREG,	D_DH,
    "BH",		LBREG,	D_BH,

    "AX",		LLREG,	D_AX,
    "CX",		LLREG,	D_CX,
    "DX",		LLREG,	D_DX,
    "BX",		LLREG,	D_BX,
/*	"SP",		LLREG,	D_SP,	*/
    "BP",		LLREG,	D_BP,
    "SI",		LLREG,	D_SI,
    "DI",		LLREG,	D_DI,

    "F0",		LFREG,	D_F0+0,
    "F1",		LFREG,	D_F0+1,
    "F2",		LFREG,	D_F0+2,
    "F3",		LFREG,	D_F0+3,
    "F4",		LFREG,	D_F0+4,
    "F5",		LFREG,	D_F0+5,
    "F6",		LFREG,	D_F0+6,
    "F7",		LFREG,	D_F0+7,

    "CS",		LSREG,	D_CS,
    "SS",		LSREG,	D_SS,
    "DS",		LSREG,	D_DS,
    "ES",		LSREG,	D_ES,
    "FS",		LSREG,	D_FS,
    "GS",		LSREG,	D_GS,

    "GDTR",		LBREG,	D_GDTR,
    "IDTR",		LBREG,	D_IDTR,
    "LDTR",		LBREG,	D_LDTR,
    "MSW",		LBREG,	D_MSW,
    "TASK",		LBREG,	D_TASK,

    "CR0",		LBREG,	D_CR+0,
    "CR1",		LBREG,	D_CR+1,
    "CR2",		LBREG,	D_CR+2,
    "CR3",		LBREG,	D_CR+3,
    "CR4",		LBREG,	D_CR+4,
    "CR5",		LBREG,	D_CR+5,
    "CR6",		LBREG,	D_CR+6,
    "CR7",		LBREG,	D_CR+7,

    "DR0",		LBREG,	D_DR+0,
    "DR1",		LBREG,	D_DR+1,
    "DR2",		LBREG,	D_DR+2,
    "DR3",		LBREG,	D_DR+3,
    "DR4",		LBREG,	D_DR+4,
    "DR5",		LBREG,	D_DR+5,
    "DR6",		LBREG,	D_DR+6,
    "DR7",		LBREG,	D_DR+7,

    "TR0",		LBREG,	D_TR+0,
    "TR1",		LBREG,	D_TR+1,
    "TR2",		LBREG,	D_TR+2,
    "TR3",		LBREG,	D_TR+3,
    "TR4",		LBREG,	D_TR+4,
    "TR5",		LBREG,	D_TR+5,
    "TR6",		LBREG,	D_TR+6,
    "TR7",		LBREG,	D_TR+7,



    "AAA",		LTYPE0,	AAAA,
    "AAD",		LTYPE0,	AAAD,
    "AAM",		LTYPE0,	AAAM,
    "AAS",		LTYPE0,	AAAS,
    "ADCB",		LTYPE3,	AADCB,
    "ADCL",		LTYPE3,	AADCL,
    "ADCW",		LTYPE3,	AADCW,
    "ADDB",		LTYPE3,	AADDB,
    "ADDL",		LTYPE3,	AADDL,
    "ADDW",		LTYPE3,	AADDW,
    "ADJSP",		LTYPE2,	AADJSP,
    "ANDB",		LTYPE3,	AANDB,
    "ANDL",		LTYPE3,	AANDL,
    "ANDW",		LTYPE3,	AANDW,
    "ARPL",		LTYPE3,	AARPL,
    "BOUNDL",		LTYPE3,	ABOUNDL,
    "BOUNDW",		LTYPE3,	ABOUNDW,
    "BSFL",		LTYPE3,	ABSFL,
    "BSFW",		LTYPE3,	ABSFW,
    "BSRL",		LTYPE3,	ABSRL,
    "BSRW",		LTYPE3,	ABSRW,
    "BTCL",		LTYPE3,	ABTCL,
    "BTCW",		LTYPE3,	ABTCW,
    "BTL",		LTYPE3,	ABTL,
    "BTRL",		LTYPE3,	ABTRL,
    "BTRW",		LTYPE3,	ABTRW,
    "BTSL",		LTYPE3,	ABTSL,
    "BTSW",		LTYPE3,	ABTSW,
    "BTW",		LTYPE3,	ABTW,
    "BYTE",		LTYPE2,	ABYTE,
    "CALL",		LTYPEC,	ACALL,
    "CLC",		LTYPE0,	ACLC,
    "CLD",		LTYPE0,	ACLD,
    "CLI",		LTYPE0,	ACLI,
    "CLTS",		LTYPE0,	ACLTS,
    "CMC",		LTYPE0,	ACMC,
    "CMPB",		LTYPE4,	ACMPB,
    "CMPL",		LTYPE4,	ACMPL,
    "CMPW",		LTYPE4,	ACMPW,
    "CMPSB",		LTYPE0,	ACMPSB,
    "CMPSL",		LTYPE0,	ACMPSL,
    "CMPSW",		LTYPE0,	ACMPSW,
    "CMPXCHGB",		LTYPE3,	ACMPXCHGB,
    "CMPXCHGL",		LTYPE3,	ACMPXCHGL,
    "CMPXCHGW",		LTYPE3,	ACMPXCHGW,
    "DAA",		LTYPE0,	ADAA,
    "DAS",		LTYPE0,	ADAS,
    "DATA",		LTYPED,	ADATA,
    "DECB",		LTYPE1,	ADECB,
    "DECL",		LTYPE1,	ADECL,
    "DECW",		LTYPE1,	ADECW,
    "DIVB",		LTYPE2,	ADIVB,
    "DIVL",		LTYPE2,	ADIVL,
    "DIVW",		LTYPE2,	ADIVW,
    "END",		LTYPE0,	AEND,
    "ENTER",		LTYPE2,	AENTER,
    "GLOBL",		LTYPEG,	AGLOBL,
    "HLT",		LTYPE0,	AHLT,
    "IDIVB",		LTYPE2,	AIDIVB,
    "IDIVL",		LTYPE2,	AIDIVL,
    "IDIVW",		LTYPE2,	AIDIVW,
    "IMULB",		LTYPEI,	AIMULB,
    "IMULL",		LTYPEI,	AIMULL,
    "IMULW",		LTYPEI,	AIMULW,
    "INB",		LTYPE0,	AINB,
    "INL",		LTYPE0,	AINL,
    "INW",		LTYPE0,	AINW,
    "INCB",		LTYPE1,	AINCB,
    "INCL",		LTYPE1,	AINCL,
    "INCW",		LTYPE1,	AINCW,
    "INSB",		LTYPE0,	AINSB,
    "INSL",		LTYPE0,	AINSL,
    "INSW",		LTYPE0,	AINSW,
    "INT",		LTYPE2,	AINT,
    "INTO",		LTYPE0,	AINTO,
    "IRETL",		LTYPE0,	AIRETL,
    "IRETW",		LTYPE0,	AIRETW,

    "JOS",		LTYPER,	AJOS,
    "JO",		LTYPER,	AJOS,	/* alternate */
    "JOC",		LTYPER,	AJOC,
    "JNO",		LTYPER,	AJOC,	/* alternate */
    "JCS",		LTYPER,	AJCS,
    "JB",		LTYPER,	AJCS,	/* alternate */
    "JC",		LTYPER,	AJCS,	/* alternate */
    "JNAE",		LTYPER,	AJCS,	/* alternate */
    "JLO",		LTYPER,	AJCS,	/* alternate */
    "JCC",		LTYPER,	AJCC,
    "JAE",		LTYPER,	AJCC,	/* alternate */
    "JNB",		LTYPER,	AJCC,	/* alternate */
    "JNC",		LTYPER,	AJCC,	/* alternate */
    "JHS",		LTYPER,	AJCC,	/* alternate */
    "JEQ",		LTYPER,	AJEQ,
    "JE",		LTYPER,	AJEQ,	/* alternate */
    "JZ",		LTYPER,	AJEQ,	/* alternate */
    "JNE",		LTYPER,	AJNE,
    "JNZ",		LTYPER,	AJNE,	/* alternate */
    "JLS",		LTYPER,	AJLS,
    "JBE",		LTYPER,	AJLS,	/* alternate */
    "JNA",		LTYPER,	AJLS,	/* alternate */
    "JHI",		LTYPER,	AJHI,
    "JA",		LTYPER,	AJHI,	/* alternate */
    "JNBE",		LTYPER,	AJHI,	/* alternate */
    "JMI",		LTYPER,	AJMI,
    "JS",		LTYPER,	AJMI,	/* alternate */
    "JPL",		LTYPER,	AJPL,
    "JNS",		LTYPER,	AJPL,	/* alternate */
    "JPS",		LTYPER,	AJPS,
    "JP",		LTYPER,	AJPS,	/* alternate */
    "JPE",		LTYPER,	AJPS,	/* alternate */
    "JPC",		LTYPER,	AJPC,
    "JNP",		LTYPER,	AJPC,	/* alternate */
    "JPO",		LTYPER,	AJPC,	/* alternate */
    "JLT",		LTYPER,	AJLT,
    "JL",		LTYPER,	AJLT,	/* alternate */
    "JNGE",		LTYPER,	AJLT,	/* alternate */
    "JGE",		LTYPER,	AJGE,
    "JNL",		LTYPER,	AJGE,	/* alternate */
    "JLE",		LTYPER,	AJLE,
    "JNG",		LTYPER,	AJLE,	/* alternate */
    "JGT",		LTYPER,	AJGT,
    "JG",		LTYPER,	AJGT,	/* alternate */
    "JNLE",		LTYPER,	AJGT,	/* alternate */

    "JCXZ",		LTYPER,	AJCXZ,
    "JMP",		LTYPEC,	AJMP,
    "LAHF",		LTYPE0,	ALAHF,
    "LARL",		LTYPE3,	ALARL,
    "LARW",		LTYPE3,	ALARW,
    "LEAL",		LTYPE3,	ALEAL,
    "LEAW",		LTYPE3,	ALEAW,
    "LEAVEL",		LTYPE0,	ALEAVEL,
    "LEAVEW",		LTYPE0,	ALEAVEW,
    "LOCK",		LTYPE0,	ALOCK,
    "LODSB",		LTYPE0,	ALODSB,
    "LODSL",		LTYPE0,	ALODSL,
    "LODSW",		LTYPE0,	ALODSW,
    "LONG",		LTYPE2,	ALONG,
    "LOOP",		LTYPER,	ALOOP,
    "LOOPEQ",		LTYPER,	ALOOPEQ,
    "LOOPNE",		LTYPER,	ALOOPNE,
    "LSLL",		LTYPE3,	ALSLL,
    "LSLW",		LTYPE3,	ALSLW,
    "MOVB",		LTYPE3,	AMOVB,
    "MOVL",		LTYPEM,	AMOVL,
    "MOVW",		LTYPEM,	AMOVW,
    "MOVBLSX",		LTYPE3, AMOVBLSX,
    "MOVBLZX",		LTYPE3, AMOVBLZX,
    "MOVBWSX",		LTYPE3, AMOVBWSX,
    "MOVBWZX",		LTYPE3, AMOVBWZX,
    "MOVWLSX",		LTYPE3, AMOVWLSX,
    "MOVWLZX",		LTYPE3, AMOVWLZX,
    "MOVSB",		LTYPE0,	AMOVSB,
    "MOVSL",		LTYPE0,	AMOVSL,
    "MOVSW",		LTYPE0,	AMOVSW,
    "MULB",		LTYPE2,	AMULB,
    "MULL",		LTYPE2,	AMULL,
    "MULW",		LTYPE2,	AMULW,
    "NEGB",		LTYPE1,	ANEGB,
    "NEGL",		LTYPE1,	ANEGL,
    "NEGW",		LTYPE1,	ANEGW,
    "NOP",		LTYPEN,	ANOP,
    "NOTB",		LTYPE1,	ANOTB,
    "NOTL",		LTYPE1,	ANOTL,
    "NOTW",		LTYPE1,	ANOTW,
    "ORB",		LTYPE3,	AORB,
    "ORL",		LTYPE3,	AORL,
    "ORW",		LTYPE3,	AORW,
    "OUTB",		LTYPE0,	AOUTB,
    "OUTL",		LTYPE0,	AOUTL,
    "OUTW",		LTYPE0,	AOUTW,
    "OUTSB",		LTYPE0,	AOUTSB,
    "OUTSL",		LTYPE0,	AOUTSL,
    "OUTSW",		LTYPE0,	AOUTSW,
    "POPAL",		LTYPE0,	APOPAL,
    "POPAW",		LTYPE0,	APOPAW,
    "POPFL",		LTYPE0,	APOPFL,
    "POPFW",		LTYPE0,	APOPFW,
    "POPL",		LTYPE1,	APOPL,
    "POPW",		LTYPE1,	APOPW,
    "PUSHAL",		LTYPE0,	APUSHAL,
    "PUSHAW",		LTYPE0,	APUSHAW,
    "PUSHFL",		LTYPE0,	APUSHFL,
    "PUSHFW",		LTYPE0,	APUSHFW,
    "PUSHL",		LTYPE2,	APUSHL,
    "PUSHW",		LTYPE2,	APUSHW,
    "RCLB",		LTYPE3,	ARCLB,
    "RCLL",		LTYPE3,	ARCLL,
    "RCLW",		LTYPE3,	ARCLW,
    "RCRB",		LTYPE3,	ARCRB,
    "RCRL",		LTYPE3,	ARCRL,
    "RCRW",		LTYPE3,	ARCRW,
    "REP",		LTYPE0,	AREP,
    "REPN",		LTYPE0,	AREPN,
    "RET",		LTYPE0,	ARET,
    "ROLB",		LTYPE3,	AROLB,
    "ROLL",		LTYPE3,	AROLL,
    "ROLW",		LTYPE3,	AROLW,
    "RORB",		LTYPE3,	ARORB,
    "RORL",		LTYPE3,	ARORL,
    "RORW",		LTYPE3,	ARORW,
    "SAHF",		LTYPE0,	ASAHF,
    "SALB",		LTYPE3,	ASALB,
    "SALL",		LTYPE3,	ASALL,
    "SALW",		LTYPE3,	ASALW,
    "SARB",		LTYPE3,	ASARB,
    "SARL",		LTYPE3,	ASARL,
    "SARW",		LTYPE3,	ASARW,
    "SBBB",		LTYPE3,	ASBBB,
    "SBBL",		LTYPE3,	ASBBL,
    "SBBW",		LTYPE3,	ASBBW,
    "SCASB",		LTYPE0,	ASCASB,
    "SCASL",		LTYPE0,	ASCASL,
    "SCASW",		LTYPE0,	ASCASW,
    "SETCC",		LTYPE1,	ASETCC,
    "SETCS",		LTYPE1,	ASETCS,
    "SETEQ",		LTYPE1,	ASETEQ,
    "SETGE",		LTYPE1,	ASETGE,
    "SETGT",		LTYPE1,	ASETGT,
    "SETHI",		LTYPE1,	ASETHI,
    "SETLE",		LTYPE1,	ASETLE,
    "SETLS",		LTYPE1,	ASETLS,
    "SETLT",		LTYPE1,	ASETLT,
    "SETMI",		LTYPE1,	ASETMI,
    "SETNE",		LTYPE1,	ASETNE,
    "SETOC",		LTYPE1,	ASETOC,
    "SETOS",		LTYPE1,	ASETOS,
    "SETPC",		LTYPE1,	ASETPC,
    "SETPL",		LTYPE1,	ASETPL,
    "SETPS",		LTYPE1,	ASETPS,
    "CDQ",		LTYPE0,	ACDQ,
    "CWD",		LTYPE0,	ACWD,
    "SHLB",		LTYPE3,	ASHLB,
    "SHLL",		LTYPES,	ASHLL,
    "SHLW",		LTYPES,	ASHLW,
    "SHRB",		LTYPE3,	ASHRB,
    "SHRL",		LTYPES,	ASHRL,
    "SHRW",		LTYPES,	ASHRW,
    "STC",		LTYPE0,	ASTC,
    "STD",		LTYPE0,	ASTD,
    "STI",		LTYPE0,	ASTI,
    "STOSB",		LTYPE0,	ASTOSB,
    "STOSL",		LTYPE0,	ASTOSL,
    "STOSW",		LTYPE0,	ASTOSW,
    "SUBB",		LTYPE3,	ASUBB,
    "SUBL",		LTYPE3,	ASUBL,
    "SUBW",		LTYPE3,	ASUBW,
    "SYSCALL",		LTYPE0,	ASYSCALL,
    "TESTB",		LTYPE3,	ATESTB,
    "TESTL",		LTYPE3,	ATESTL,
    "TESTW",		LTYPE3,	ATESTW,
    "TEXT",		LTYPET,	ATEXT,
    "VERR",		LTYPE2,	AVERR,
    "VERW",		LTYPE2,	AVERW,
    "WAIT",		LTYPE0,	AWAIT,
    "WORD",		LTYPE2,	AWORD,
    "XCHGB",		LTYPE3,	AXCHGB,
    "XCHGL",		LTYPE3,	AXCHGL,
    "XCHGW",		LTYPE3,	AXCHGW,
    "XLAT",		LTYPE2,	AXLAT,
    "XORB",		LTYPE3,	AXORB,
    "XORL",		LTYPE3,	AXORL,
    "XORW",		LTYPE3,	AXORW,

    "CMOVLCC",		LTYPE3,	ACMOVLCC,
    "CMOVLCS",		LTYPE3,	ACMOVLCS,
    "CMOVLEQ",		LTYPE3,	ACMOVLEQ,
    "CMOVLGE",		LTYPE3,	ACMOVLGE,
    "CMOVLGT",		LTYPE3,	ACMOVLGT,
    "CMOVLHI",		LTYPE3,	ACMOVLHI,
    "CMOVLLE",		LTYPE3,	ACMOVLLE,
    "CMOVLLS",		LTYPE3,	ACMOVLLS,
    "CMOVLLT",		LTYPE3,	ACMOVLLT,
    "CMOVLMI",		LTYPE3,	ACMOVLMI,
    "CMOVLNE",		LTYPE3,	ACMOVLNE,
    "CMOVLOC",		LTYPE3,	ACMOVLOC,
    "CMOVLOS",		LTYPE3,	ACMOVLOS,
    "CMOVLPC",		LTYPE3,	ACMOVLPC,
    "CMOVLPL",		LTYPE3,	ACMOVLPL,
    "CMOVLPS",		LTYPE3,	ACMOVLPS,
    "CMOVWCC",		LTYPE3,	ACMOVWCC,
    "CMOVWCS",		LTYPE3,	ACMOVWCS,
    "CMOVWEQ",		LTYPE3,	ACMOVWEQ,
    "CMOVWGE",		LTYPE3,	ACMOVWGE,
    "CMOVWGT",		LTYPE3,	ACMOVWGT,
    "CMOVWHI",		LTYPE3,	ACMOVWHI,
    "CMOVWLE",		LTYPE3,	ACMOVWLE,
    "CMOVWLS",		LTYPE3,	ACMOVWLS,
    "CMOVWLT",		LTYPE3,	ACMOVWLT,
    "CMOVWMI",		LTYPE3,	ACMOVWMI,
    "CMOVWNE",		LTYPE3,	ACMOVWNE,
    "CMOVWOC",		LTYPE3,	ACMOVWOC,
    "CMOVWOS",		LTYPE3,	ACMOVWOS,
    "CMOVWPC",		LTYPE3,	ACMOVWPC,
    "CMOVWPL",		LTYPE3,	ACMOVWPL,
    "CMOVWPS",		LTYPE3,	ACMOVWPS,
                	
    "FMOVB",		LTYPE3, AFMOVB,
    "FMOVBP",		LTYPE3, AFMOVBP,
    "FMOVD",		LTYPE3, AFMOVD,
    "FMOVDP",		LTYPE3, AFMOVDP,
    "FMOVF",		LTYPE3, AFMOVF,
    "FMOVFP",		LTYPE3, AFMOVFP,
    "FMOVL",		LTYPE3, AFMOVL,
    "FMOVLP",		LTYPE3, AFMOVLP,
    "FMOVV",		LTYPE3, AFMOVV,
    "FMOVVP",		LTYPE3, AFMOVVP,
    "FMOVW",		LTYPE3, AFMOVW,
    "FMOVWP",		LTYPE3, AFMOVWP,
    "FMOVX",		LTYPE3, AFMOVX,
    "FMOVXP",		LTYPE3, AFMOVXP,
    "FCMOVCC",		LTYPE3, AFCMOVCC,
    "FCMOVCS",		LTYPE3, AFCMOVCS,
    "FCMOVEQ",		LTYPE3, AFCMOVEQ,
    "FCMOVHI",		LTYPE3, AFCMOVHI,
    "FCMOVLS",		LTYPE3, AFCMOVLS,
    "FCMOVNE",		LTYPE3, AFCMOVNE,
    "FCMOVNU",		LTYPE3, AFCMOVNU,
    "FCMOVUN",		LTYPE3, AFCMOVUN,
    "FCOMB",		LTYPE3, AFCOMB,
    "FCOMBP",		LTYPE3, AFCOMBP,
    "FCOMD",		LTYPE3, AFCOMD,
    "FCOMDP",		LTYPE3, AFCOMDP,
    "FCOMDPP",		LTYPE3, AFCOMDPP,
    "FCOMF",		LTYPE3, AFCOMF,
    "FCOMFP",		LTYPE3, AFCOMFP,
    "FCOMI",		LTYPE3, AFCOMI,
    "FCOMIP",		LTYPE3, AFCOMIP,
    "FCOML",		LTYPE3, AFCOML,
    "FCOMLP",		LTYPE3, AFCOMLP,
    "FCOMW",		LTYPE3, AFCOMW,
    "FCOMWP",		LTYPE3, AFCOMWP,
    "FUCOM",		LTYPE3, AFUCOM,
    "FUCOMI",		LTYPE3, AFUCOMI,
    "FUCOMIP",		LTYPE3, AFUCOMIP,
    "FUCOMP",		LTYPE3, AFUCOMP,
    "FUCOMPP",		LTYPE3, AFUCOMPP,
    "FADDW",		LTYPE3, AFADDW,
    "FADDL",		LTYPE3, AFADDL,
    "FADDF",		LTYPE3, AFADDF,
    "FADDD",		LTYPE3, AFADDD,
    "FADDDP",		LTYPE3, AFADDDP,
    "FSUBDP",		LTYPE3, AFSUBDP,
    "FSUBW",		LTYPE3, AFSUBW,
    "FSUBL",		LTYPE3, AFSUBL,
    "FSUBF",		LTYPE3, AFSUBF,
    "FSUBD",		LTYPE3, AFSUBD,
    "FSUBRDP",		LTYPE3, AFSUBRDP,
    "FSUBRW",		LTYPE3, AFSUBRW,
    "FSUBRL",		LTYPE3, AFSUBRL,
    "FSUBRF",		LTYPE3, AFSUBRF,
    "FSUBRD",		LTYPE3, AFSUBRD,
    "FMULDP",		LTYPE3, AFMULDP,
    "FMULW",		LTYPE3, AFMULW,
    "FMULL",		LTYPE3, AFMULL,
    "FMULF",		LTYPE3, AFMULF,
    "FMULD",		LTYPE3, AFMULD,
    "FDIVDP",		LTYPE3, AFDIVDP,
    "FDIVW",		LTYPE3, AFDIVW,
    "FDIVL",		LTYPE3, AFDIVL,
    "FDIVF",		LTYPE3, AFDIVF,
    "FDIVD",		LTYPE3, AFDIVD,
    "FDIVRDP",		LTYPE3, AFDIVRDP,
    "FDIVRW",		LTYPE3, AFDIVRW,
    "FDIVRL",		LTYPE3, AFDIVRL,
    "FDIVRF",		LTYPE3, AFDIVRF,
    "FDIVRD",		LTYPE3, AFDIVRD,
    "FXCHD",		LTYPE3, AFXCHD,
    "FFREE",		LTYPE1, AFFREE,
    "FLDCW",		LTYPE2, AFLDCW,
    "FLDENV",		LTYPE1, AFLDENV,
    "FRSTOR",		LTYPE2, AFRSTOR,
    "FSAVE",		LTYPE1, AFSAVE,
    "FSTCW",		LTYPE1, AFSTCW,
    "FSTENV",		LTYPE1, AFSTENV,
    "FSTSW",		LTYPE1, AFSTSW,
    "F2XM1",		LTYPE0, AF2XM1,
    "FABS",		LTYPE0, AFABS,
    "FCHS",		LTYPE0, AFCHS,
    "FCLEX",		LTYPE0, AFCLEX,
    "FCOS",		LTYPE0, AFCOS,
    "FDECSTP",		LTYPE0, AFDECSTP,
    "FINCSTP",		LTYPE0, AFINCSTP,
    "FINIT",		LTYPE0, AFINIT,
    "FLD1",		LTYPE0, AFLD1,
    "FLDL2E",		LTYPE0, AFLDL2E,
    "FLDL2T",		LTYPE0, AFLDL2T,
    "FLDLG2",		LTYPE0, AFLDLG2,
    "FLDLN2",		LTYPE0, AFLDLN2,
    "FLDPI",		LTYPE0, AFLDPI,
    "FLDZ",		LTYPE0, AFLDZ,
    "FNOP",		LTYPE0, AFNOP,
    "FPATAN",		LTYPE0, AFPATAN,
    "FPREM",		LTYPE0, AFPREM,
    "FPREM1",		LTYPE0, AFPREM1,
    "FPTAN",		LTYPE0, AFPTAN,
    "FRNDINT",		LTYPE0, AFRNDINT,
    "FSCALE",		LTYPE0, AFSCALE,
    "FSIN",		LTYPE0, AFSIN,
    "FSINCOS",		LTYPE0, AFSINCOS,
    "FSQRT",		LTYPE0, AFSQRT,
    "FTST",		LTYPE0, AFTST,
    "FXAM",		LTYPE0, AFXAM,
    "FXTRACT",		LTYPE0, AFXTRACT,
    "FYL2X",		LTYPE0, AFYL2X,
    "FYL2XP1",		LTYPE0, AFYL2XP1,

    0
};
@

\section{[[Sym]] and [[hash]]}

% assembling is a lot about symbolic name processing!

% currently copy pasted in 5a/a.h and va/a.h so if reorder
% may have to reorder there (or factorize code to avoid those pbs)
<<struct Sym>>=
struct	Sym
{
    // for user labels (bar:), variables (VAR)
    // but also used for opcodes (AMOVB) and register (D_AL) keywords 
    // (see itab)
    char	*name;

    //token code (e.g. LNAME, LLAB, LBREG, etc)
    ushort	type;

    //enum<operand_kind> | enum<opcode> | long (e.g. pc for LLAB)
    long	value;

    <<[[Sym]] other fields>>
    // Extra
    <<[[Sym]] extra fields>>
};
@
% this is used for user defined names (e.g. TEXT foo), but
% abused also for keywords operand like AL, AX, and also for opcode
% in which case the value is the opcode.
% note: because of hash below that means that all MOVB in a file
% are shared when lexing
%    // see also itab[i].type and itab[i].value
% archi: not that in va/ value is a vlong, not a long // archi: vlong in va/!!

<<constant NHASH>>=
#define	NHASH		503
@

<<global hash>>=
// hash<string, ref_own?<Sym>>, (next in bucket = Sym.link)
Sym*	hash[NHASH];
@
% diff with h?

% what is the head? hash! and also h?
<<[[Sym]] extra fields>>=
// list<ref<Sym>> (next = Sym.link) bucket of hashtbl 'hash'
Sym*	link;
@

% what is the list it marks the end of? hash for sure, maybe also h and htab?
<<constant S>>=
#define	S	((Sym*)nil)
@



<<constant NSYMB>>=
#define	NSYMB		500
@

<<global symb>>=
char	symb[NSYMB];
@

% use symb global, a bit ugly
% TODO lp split, compute hash key of symb, find in hash global, etc
<<function lookup>>=
Sym*
lookup(void)
{
    Sym *s;
    long h;
    char *p;
    int c, l;

    h = 0;
    for(p=symb; c = *p; p++)
        h = h+h+h + c;
    l = (p - symb) + 1;
    if(h < 0)
        h = ~h;
    h %= NHASH;

    c = symb[0];
    for(s = hash[h]; s != S; s = s->link) {
        if(s->name[0] != c)
            continue;
        if(memcmp(s->name, symb, l) == 0)
            return s;
    }
    s = alloc(sizeof(*s));
    s->name = alloc(l);
    memmove(s->name, symb, l);

    s->link = hash[h];
    hash[h] = s;
    syminit(s);
    return s;
}
@

<<function syminit>>=
void
syminit(Sym *s)
{

    s->type = LNAME;
    s->value = 0;
}
@

<<function slookup>>=
Sym*
slookup(char *s)
{

    strcpy(symb, s);
    return lookup();
}
@


% old? dead?
%<<[[Sym]] other fields>>=
%Ref*	ref; // unused for 5a, matters?
%@
%
%<<struct Ref>>=
%// only for 8a actually
%struct	Ref
%{
%    int	class;
%};
%@


\section{[[Gen]], [[Gen2]]}

% =~ Adr of Linker
% rename operand?
<<struct Gen>>=
struct	Gen
{
    // enum<operand_kind>
    short	type;

    long	offset; // generic value
    double	dval;
    char	sval[8];

    //enum<operand_kind(register-only|D_NONE)>
    short	index;

    short	scale;

    //??
    Sym*	sym;

    long	offset2;
};
@

% see cinit()
<<global nullgen>>=
Gen	nullgen;
@


% if look qemu.root.s from data2c result:
% e.g. 
% DATA boot_CONF_outcode+0(SB)/8, $"\z\z\1\353\z\z\213\33"
% ...
% DATA boot_CONF_outcode+67520(SB)/8, $"\1\201\1\z\z\z\z\z"
% GLOBL boot_CONF_outcode+0(SB), $67528
% GLOBL boot_CONF_outlen+0(SB), $4
% DATA boot_CONF_outlen+0(SB)/4, $67523

<<function checkscale>>=
void
checkscale(int scale)
{

    switch(scale) {
    case 1:
    case 2:
    case 4:
    case 8:
        return;
    }
    yyerror("scale must be 1248: %d", scale);
}
@



% usually MOVW AX, BX, 'from' AX, 'to' BX
% =~ Prog of Linker (but without opcode)
% rename operands?
<<struct Gen2>>=
struct	Gen2
{
    Gen	from;
    Gen	to;
};
@

% actually later do outcode(int a, Gen2 *x)
% where both arguments are really like a Prog of Linker


%section{[[pc]]} ?

\chapter{[[main()]]}

% default object suffix, to generate foo.8
<<global thechar>>=
int	thechar = '8';
@

% to find archi specific core header files, /386/include/...
<<global thestring>>=
char*	thestring = "386";
@

% -o
<<global outfile>>=
char*	outfile;
@



<<function main (assemblers/8a/lex.c)>>=
void
main(int argc, char *argv[])
{
    <<[[main()]] locals>>
    <<[[main()]] debug initialization>>

    cinit();
    outfile = nil;
    include[ninclude++] = ".";

    ARGBEGIN {
    <<[[main()]] command line processing>>
    } ARGEND

    if(*argv == 0) {
        print("usage: %ca [-options] file.s\n", thechar);
        errorexit();
    }

    <<[[main()]] multiple files handling>>

    if(assemble(argv[0]))
        errorexit();
    exits(0);
}
@

<<[[main()]] command line processing>>=
case 'o':
    outfile = ARGF();
    break;
@





% cwd, for #include "" (cwd can change as one include other files)
%  =~ dirname(current_file)
% less: rename? dirname_of_current_file?
<<global pathname>>=
char*	pathname;
@

% could split, nullgen init, hash init (via lookup), pathname init
<<function cinit>>=
void
cinit(void)
{
    Sym *s;
    int i;

    nullgen.sym = S;
    nullgen.offset = 0;
    if(FPCHIP)
        nullgen.dval = 0;
    for(i=0; i<sizeof(nullgen.sval); i++)
        nullgen.sval[i] = '\0';
    nullgen.type = D_NONE;
    nullgen.index = D_NONE;
    nullgen.scale = 0;

    for(i=0; i<NHASH; i++)
        hash[i] = S;
    for(i=0; itab[i].name; i++) {
        s = slookup(itab[i].name);
        if(s->type != LNAME)
            yyerror("double initialization %s", itab[i].name);
        s->type = itab[i].type;
        s->value = itab[i].value;
    }

    pathname = allocn(pathname, 0, 100);
    if(getwd(pathname, 99) == nil) {
        pathname = allocn(pathname, 100, 900);
        if(getwd(pathname, 999) == nil)
            strcpy(pathname, "/???");
    }
}
@





% there is 2 passes.
% actually used outside assemble() in the grammar! and outcode().
% the idea is actually to parse two times, but to do different things the
% second time. Abusing grammar actions (old style).
<<global pass>>=
// 1|2
int	pass;
@


% on windows would be different, but we don't care
% int -> Rune?
<<function pathchar>>=
int
pathchar(void)
{
    return '/';
}
@

<<[[assemble()]] locals>>=
char *p;
fdt of; // outfile
int i;
@

% outfile(string) -> of(fd) -> obuf(biobuf)
<<global obuf>>=
Biobuf	obuf;
@

<<function assemble>>=
int
assemble(char *file)
{
    <<[[assemble()]] locals>>

    <<[[assemble()]] set p to basename(file) and adjust include>>

    if(outfile == nil) {
        <<[[assemble()]] set outfile to {basename(file)}.8>>
    }

    <<[[assemble()]] setinclude("/386/include") or INCLUDE>>

    of = mycreat(outfile, 0664);
    if(of < 0) {
        yyerror("%ca: cannot create %s", thechar, outfile);
        errorexit();
    }
    Binit(&obuf, of, OWRITE);

    pass = 1;

    pinit(file);
    <<[[assemble()]] init Dlist after pinit>>
    yyparse(); // calls outcode() but does nothing when pass == 1

    if(nerrors) {
        cclean();
        return nerrors;
    }

    pass = 2;
    outhist(); // header

    pinit(file);
    <<[[assemble()]] init Dlist after pinit>>
    yyparse(); // calls outcode() that now does things

    cclean();
    return nerrors;
}
@


<<[[assemble()]] locals>>=
char ofile[100];
@

<<[[assemble()]] set p to basename(file) and adjust include>>=
// p = basename(file)
// include[0] = dirname(file); 
strcpy(ofile, file);
p = utfrrune(ofile, pathchar());
if(p) {
    include[0] = ofile;
    *p++ = '\0';
} else
    p = ofile;
@

<<[[assemble()]] set outfile to {basename(file)}.8>>=
// outfile =  p =~ s/.s/.8/;
outfile = p;
if(outfile){
    p = utfrrune(outfile, '.');
    if(p)
        if(p[1] == 's' && p[2] == '\0')
            p[0] = '\0';
    p = utfrune(outfile, '\0');
    p[0] = '.';
    p[1] = thechar;
    p[2] = '\0';
} else
    outfile = "/dev/null";
@


<<[[assemble()]] locals>>=
char incfile[20];
@

<<[[assemble()]] setinclude("/386/include") or INCLUDE>>=
p = getenv("INCLUDE");
if(p) {
    setinclude(p);
} else {
    if(systemtype(Plan9)) {
        sprint(incfile,"/%s/include", thestring);
        setinclude(strdup(incfile));
    }
}
@


<<function cclean>>=
void
cclean(void)
{
    Gen2 g2 = (Gen2) { nullgen, nullgen };

    outcode(AEND, &g2);
    Bflush(&obuf);
}
@


\chapter{Input}

% yyparse() actually calls yylex?

<<global lineno>>=
long	lineno;
@


% =~ yyback(1) trick, used by yylex() and getc(), and?? cg?
<<global peekc>>=
int	peekc = IGN;
@
% used to be set in cinit()

<<constant IGN>>=
#define	IGN		(-2)
@

<<constant EOF>>=
#define	EOF		(-1)
@



% assemble() -> pinit() (before yyparse)
% call at the beginning of each pass with the file to assemble
<<function pinit>>=
void
pinit(char *f)
{
    int i;
    Sym *s;

    lineno = 1;
    newio();
    newfile(f, -1);
    pc = 0;
    peekc = IGN;

    symcounter = 1;
    for(i=0; i<NSYM; i++) {
        h[i].type = 0;
        h[i].sym = S;
    }
    for(i=0; i<NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            s->macro = nil;
}
@


\section{Files managment}

% include so have to open files, close them
% hmm better to separate concern and have cpp in a different program?

<<constant BUFSIZ>>=
#define	BUFSIZ		8192
@

% hmm, shorter fieldnames? hmmm
<<struct Io>>=
struct	Io
{
    char	b[BUFSIZ];

    // -1 if not opened yet
    fdt	f;

    // like Fi, saved IO buffer status
    char*	p;
    short	c;

    // Extra
    Io*	link;
};
@

% list/stack because of #include, iostack point to head and currently
% opened and processed file
<<global iostack>>=
// list<Io> (next = Io.link)
Io*	iostack = I;
@
% used to be set in cinit()

<<constant I>>=
#define	I	((Io*)nil)
@


<<global iofree>>=
// list<IO>, next = IO.link
Io*	iofree = I;
@

// option<ref<IO>>
<<global ionext>>=
Io*	ionext;
@


<<function newio>>=
void
newio(void)
{
    Io *i;
    static int pushdepth = 0;

    i = iofree;
    if(i == I) {
        pushdepth++;
        if(pushdepth > 1000) {
            yyerror("macro/io expansion too deep");
            errorexit();
        }
        //todo: check error code?
        i = alloc(sizeof(Io));
    } else
        iofree = i->link;
    i->c = 0;
    i->f = -1;
    ionext = i;
}
@


<<function newfile>>=
void
newfile(char *s, int f)
{
    Io *i;

    i = ionext;
    i->link = iostack;
    iostack = i;

    i->f = f;
    if(i->f < 0)
        i->f = open(s, 0);
    if(i->f < 0) {
        yyerror("%ca: %r: %s", thechar, s);
        errorexit();
    }
    fi.c = 0;
    linehist(s, 0);
}
@

\section{Buffer managment}

% buffered IO

% File input?
<<struct Fi>>=
struct Fi
{
    // ref<char>, pointer in buffer (of Io.b)
    char*	p;
    // remaining count in buffer (of Io.b)
    int	c;
};
@

% global IO buffer
<<global fi>>=
struct Fi fi;
@


<<function GETC>>=
#define	GETC()		((--fi.c < 0) ? filbuf() : *fi.p++ & 0xff)
@

<<function filbuf>>=
int
filbuf(void)
{
    Io *i;

loop:
    i = iostack;
    if(i == I)
        return EOF;
    if(i->f < 0)
        goto pop;
    fi.c = read(i->f, i->b, BUFSIZ) - 1;
    if(fi.c < 0) {
        close(i->f);
        linehist(0, 0);
        goto pop;
    }
    fi.p = i->b + 1;
    return i->b[0];

pop:
    iostack = i->link;
    i->link = iofree;
    iofree = i;
    i = iostack;
    if(i == I)
        return EOF;
    fi.p = i->p;
    fi.c = i->c;
    if(--fi.c < 0)
        goto loop;
    return *fi.p++;
}
@



\chapter{Lexing}

\section{[[yylex()]]}

% loop until find a token and return its code
% and also set yylval global to contain more
% info about the token (yylval = big union)

% GETC is essentially get next char in current opened file
% (that is iostack->f )
% #define	GETC()		((--fi.c < 0) ? filbuf() : *fi.p++ & 0xff)
% type: unit -> int (-1 for EOF, 0 for?)



% should use lex ... simpler, but maybe to avoid bootstrapping issues?

<<[[yylex()]] locals>>=
int c1;
@
% for peek


% called by? yyparse() in generated code from a.y
<<function yylex>>=
long
yylex(void)
{
    int c;
    <<[[yylex()]] locals>>

    c = peekc;
    if(c != IGN) {
        peekc = IGN;
        goto l1;
    }
l0:
    c = GETC();

l1:
    if(c == EOF) {
        peekc = EOF;
        return -1;
    }

    if(isspace(c)) {
        if(c == '\n') {
            lineno++;
            return ';';
        }
        goto l0;
    }

    if(isalpha(c))
        goto talph;
    if(isdigit(c))
        goto tnum;

    switch(c) {
    <<[[yylex()]] switch c cases>>
    default:
        return c;
    }
    peekc = c1;
    return c;
}
@
%$

% LP aspectize peekc? lp split more the func?

\section{Newline}

<<[[yylex()]] switch c cases>>=
case '\n':
    lineno++;
    return ';';
@

% newline are translated in ';' and this is used by
% the grammar, see in Parsing subsection

\section{Comments}

<<[[yylex()]] switch c cases>>=
case '/':
    c1 = GETC();
    if(c1 == '/') {
        for(;;) {
            c = GETC();
            if(c == '\n')
                goto l1;
            if(c == EOF) {
                yyerror("eof in comment");
                errorexit();
            }
        }
    }
    if(c1 == '*') {
        for(;;) {
            c = GETC();
            while(c == '*') {
                c = GETC();
                if(c == '/')
                    goto l0;
            }
            if(c == EOF) {
                yyerror("eof in comment");
                errorexit();
            }
            if(c == '\n')
                lineno++;
        }
    }
    break;
@

% put getcom() here too?

\section{Keywords and identifiers}

<<[[yylex()]] locals>>=
char *cp;
Sym *s;
@


<<[[yylex()]] switch c cases>>=
case '_':
case '@':
// case 'a'..'z' 'A'..'Z':
talph:
    cp = symb;

aloop:
    *cp++ = c;
    c = GETC();
    if(isalpha(c) || isdigit(c) || c == '_' || c == '$') // $
        goto aloop;

    // went too far, yyback(1)
    peekc = c;

    *cp = '\0';
    s = lookup();

    <<[[yylex()]] if macro symbol>>

    if(s->type == 0)
        s->type = LNAME;

    if(s->type == LNAME || s->type == LVAR || s->type == LLAB) {
        yylval.sym = s;
    } else {
        yylval.lval = s->value;
    }
    return s->type;
@
% possible to have s->type == 0? if new symbol then I think
% it actually set to LNAME in syminit

\section{Numbers}

<<[[yylex()]] switch c cases>>=
// case '0'..'9'
tnum:
    cp = symb;
    if(c != '0')
        goto dc;

    *cp++ = c;
    c = GETC();
    c1 = 3;
    if(c == 'x' || c == 'X') {
        c1 = 4;
        c = GETC();
    } else
    if(c < '0' || c > '7')
        goto dc;
    yylval.lval = 0;
    for(;;) {
        if(c >= '0' && c <= '9') {
            if(c > '7' && c1 == 3)
                break;
            yylval.lval <<= c1;
            yylval.lval += c - '0';
            c = GETC();
            continue;
        }
        if(c1 == 3)
            break;
        if(c >= 'A' && c <= 'F')
            c += 'a' - 'A';
        if(c >= 'a' && c <= 'f') {
            yylval.lval <<= c1;
            yylval.lval += c - 'a' + 10;
            c = GETC();
            continue;
        }
        break;
    }
    goto ncu;

dc:
    for(;;) {
        if(!isdigit(c))
            break;
        *cp++ = c;
        c = GETC();
    }
    if(c == '.')
        goto casedot;
    if(c == 'e' || c == 'E')
        goto casee;
    *cp = 0;
    if(sizeof(yylval.lval) == sizeof(vlong))
        yylval.lval = strtoll(symb, nil, 10);
    else
        yylval.lval = strtol(symb, nil, 10);

ncu:
    while(c == 'U' || c == 'u' || c == 'l' || c == 'L')
        c = GETC();
    peekc = c;
    return LCONST;

casedot:
    for(;;) {
        *cp++ = c;
        c = GETC();
        if(!isdigit(c))
            break;
    }
    if(c == 'e' || c == 'E')
        goto casee;
    goto caseout;

casee:
    *cp++ = 'e';
    c = GETC();
    if(c == '+' || c == '-') {
        *cp++ = c;
        c = GETC();
    }
    while(isdigit(c)) {
        *cp++ = c;
        c = GETC();
    }

caseout:
    *cp = 0;
    peekc = c;
    if(FPCHIP) {
        yylval.dval = atof(symb);
        return LFCONST;
    }
    yyerror("assembler cannot interpret fp constants");
    yylval.lval = 1L;
    return LCONST;
@


\subsection{Decimals}

\subsection{Floats}

<<[[yylex()]] switch c cases>>=
case '.':
    c = GETC();
    if(isalpha(c)) {
        cp = symb;
        *cp++ = '.';
        goto aloop;
    }
    if(isdigit(c)) {
        cp = symb;
        *cp++ = '.';
        goto casedot;
    }
    peekc = c;
    return '.';
@


\section{Characters}

<<[[yylex()]] switch c cases>>=
case '\'':
    c = escchar('\'');
    if(c == EOF)
        c = '\'';
    if(escchar('\'') != EOF)
        yyerror("missing '");
    yylval.lval = c;
    return LCONST;
@

\section{Escaping characters}

% e is usually ' or "
<<function escchar>>=
int
escchar(int e)
{
    int c, l;

loop:
    c = getc();
    if(c == '\n') {
        yyerror("newline in string");
        return EOF;
    }
    if(c != '\\') {
        if(c == e)
            return EOF;
        return c;
    }
    c = getc();
    if(c >= '0' && c <= '7') {
        l = c - '0';
        c = getc();
        if(c >= '0' && c <= '7') {
            l = l*8 + c-'0';
            c = getc();
            if(c >= '0' && c <= '7') {
                l = l*8 + c-'0';
                return l;
            }
        }
        peekc = c;
        return l;
    }
    switch(c)
    {
    case '\n':	goto loop;
    case 'n':	return '\n';
    case 't':	return '\t';
    case 'b':	return '\b';
    case 'r':	return '\r';
    case 'f':	return '\f';
    case 'a':	return 0x07;
    case 'v':	return 0x0b;
    case 'z':	return 0x00;
    }
    return c;
}
@


\section{Strings}

<<[[yylex()]] switch c cases>>=
case '"':
    memcpy(yylval.sval, nullgen.sval, sizeof(yylval.sval));
    cp = yylval.sval;
    c1 = 0;
    for(;;) {
        c = escchar('"');
        if(c == EOF)
            break;
        if(c1 < sizeof(yylval.sval))
            *cp++ = c;
        c1++;
    }
    if(c1 > sizeof(yylval.sval))
        yyerror("string constant too long");
    return LSCONST;
@
% limited to 8 bytes, hence the data2c script


\section{[[getc()]], [[unget()]], [[getnsc()]]}

% from now on those functions are actually used by the preprocessing
% code, not by the basic lexer (yylex) that actually implement
% his own getnsc(), getcom(), getsym() via cases
% (hmmm maybe could factorize things?)

% helpers for other functions

% int? why not uint? GETC can return EOF but not this function!
<<function getc>>=
int
getc(void)
{
    int c;

    c = peekc;
    if(c != IGN) {
        peekc = IGN;
        return c;
    }

    c = GETC();

    if(c == '\n')
        lineno++;
    if(c == EOF) {
        yyerror("End of file");
        errorexit();
    }
    return c;
}
@


% what if had already a peekc? because called unget 2 times?
% should raise Impossible!
<<function unget>>=
void
unget(int c)
{
    peekc = c;
    if(c == '\n')
        lineno--;
}
@

% get non space char (they really like short cryptic names)
<<function getnsc>>=
int
getnsc(void)
{
    int c;

    for(;;) {
        c = getc();
        if(!isspace(c) || c == '\n')
            return c;
    }
}
@



\section{[[getsym()]]}
% mv with Keywords and identifier section?

<<function getsym>>=
Sym*
getsym(void)
{
    int c;
    char *cp;

    c = getnsc();
    if(!isalpha(c) && c != '_' && c < Runeself) {
        unget(c);
        return S;
    }
    for(cp = symb;;) {
        if(cp <= symb+NSYMB-4)
            *cp++ = c;
        c = getc();
        if(isalnum(c) || c == '_' || c >= Runeself)
            continue;
        unget(c);
        break;
    }
    *cp = 0;
    if(cp > symb+NSYMB-4)
        yyerror("symbol too large: %s", symb);
    return lookup();
}
@

\section{[[getcom()]]}
% mv with Comments section above?

<<function getcom>>=
int
getcom(void)
{
    int c;

    for(;;) {
        c = getnsc();
        if(c != '/')
            break;
        c = getc();
        if(c == '/') {
            while(c != '\n')
                c = getc();
            break;
        }
        if(c != '*')
            break;
        c = getc();
        for(;;) {
            if(c == '*') {
                c = getc();
                if(c != '/')
                    continue;
                c = getc();
                break;
            }
            if(c == '\n') {
                yyerror("comment across newline");
                break;
            }
            c = getc();
        }
        if(c == '\n')
            break;
    }
    return c;
}
@

\chapter{Preprocessing}

<<global mactab>>=
struct
{
    char	*macname;
    void	(*macf)(void);
} mactab[] =
{
    "ifdef",	nil,	/* macif(0) */
    "ifndef",	nil,	/* macif(1) */
    "else",	nil,	/* macif(2) */

    "line",	maclin,
    "define",	macdef,
    "include",	macinc,
    "undef",	macund,

    "pragma",	macprag,
    "endif",	macend,
    0
};
@

<<[[yylex()]] switch c cases>>=
case '#':
    domacro();
    goto l0;
@
% goto l0 because does not return any token, we just have
% actually expanded or defined macros or undef, in any case
% no token to return

% dispatcher, should rename because it's not just about macro =>
% parse_and_dispatch_pp_directive?
<<function domacro>>=
void
domacro(void)
{
    int i;
    Sym *s;

    s = getsym();
    if(s == S)
        s = slookup("endif");

    for(i=0; mactab[i].macname; i++)
        if(strcmp(s->name, mactab[i].macname) == 0) {
            if(mactab[i].macf)
                // dispatcher!
                (*mactab[i].macf)();
            else
                macif(i);
            return;
        }
    yyerror("unknown #: %s", s->name);
    macend();
}
@
% abuse getsym just to get an ident, don't have to go through
% lookup really



<<function macend>>=
void
macend(void)
{
    int c;

    for(;;) {
        c = getnsc();
        if(c < 0 || c == '\n')
            return;
    }
}
@
% I don't think c can be < 0 here.

\section{[[#include]] and [[-I]]}

\subsection{Include path}

<<[[main()]] locals>>=
char *p;
@

% -I
<<[[main()]] command line processing>>=
case 'I':
    p = ARGF();
    setinclude(p);
    break;
@

<<constant NINCLUDE>>=
#define	NINCLUDE	10
@

% hmm rename? include_paths?
<<global include>>=
char*	include[NINCLUDE];
@

<<global ninclude>>=
int	ninclude;
@

<<function setinclude>>=
void
setinclude(char *p)
{
    int i;

    if(p == nil)
        return;
    for(i=1; i < ninclude; i++)
        if(strcmp(p, include[i]) == 0)
            return;

    if(ninclude >= nelem(include)) {
        yyerror("ninclude too small %d", nelem(include));
        exits("ninclude");
    }
    include[ninclude++] = p;
}
@


\subsection{Tracing}

% when error, need give line, but can be because of context,
% so useful to give the full location of an error, that is the list
% of files that included it
% TODO give example of why it's useful to not just have the final names

% keep track of where a token comes from, so that error
% messages can look like
%  xxx.h from xxx.h from xxx.c ...
<<struct Hist>>=
struct	Hist
{
    char*	name;

    long	line;
    long	offset;

    // Extra
    Hist*	link;
};
@

<<global hist>>=
// list<ref_own<Hist>>, next = Hist.link
Hist*	hist;
@

<<global ehist>>=
// ref<Hist>, end of hist list?
Hist*	ehist;
@


<<constant H>>=
#define	H	((Hist*)0)
@




% dead? seems just set to 0 ... just one write
% it's used in cc/ though, and we copy pasted code for macbody
<<global newflag>>=
bool	newflag;
@

<<function linehist>>=
void
linehist(char *f, int offset)
{
    Hist *h;

    /*
     * overwrite the last #line directive if
     * no alloc has happened since the last one
     */
    if(newflag == false && ehist != H && offset != 0 && ehist->offset != 0)
        if(f && ehist->name && strcmp(f, ehist->name) == 0) {
            ehist->line = lineno;
            ehist->offset = offset;
            return;
        }
    <<[[linehist()]] debug>>

    newflag = false;

    h = alloc(sizeof(Hist));
    h->name = f;
    h->line = lineno;
    h->offset = offset;
    h->link = H;
    if(ehist == H) {
        hist = h;
        ehist = h;
        return;
    }
    ehist->link = h;
    ehist = h;
}
@





\subsection{[[#include]]}

<<constant STRINGSZ>>=
#define	STRINGSZ	200
@

% LP split, and factorize code with gethunk
<<function macinc>>=
void
macinc(void)
{
    int c0, c, i, f;
    char str[STRINGSZ], *hp;

    c0 = getnsc();
    if(c0 != '"') {
        c = c0;
        if(c0 != '<')
            goto bad;
        c0 = '>';
    }
    for(hp = str;;) {
        c = getc();
        if(c == c0)
            break;
        if(c == '\n')
            goto bad;
        *hp++ = c;
    }
    *hp = 0;

    c = getcom();
    if(c != '\n')
        goto bad;

    f = -1;
    for(i=0; i<ninclude; i++) {
        if(i == 0 && c0 == '>')
            continue;
        strcpy(symb, include[i]);
        strcat(symb, "/");
        if(strcmp(symb, "./") == 0)
            symb[0] = 0;
        strcat(symb, str);

        f = open(symb, 0);
        if(f >= 0)
            break;

    }
    if(f < 0)
        strcpy(symb, str);
    c = strlen(symb) + 1;
    while(c & 3)
        c++;

    while(nhunk < c)
        gethunk();
    hp = hunk;
    memcpy(hunk, symb, c);
    nhunk -= c;
    hunk += c;

    newio();
    pushio();
    newfile(hp, f);
    return;

bad:
    unget(c);
    yyerror("syntax in #include");
    macend();
}
@


<<function pushio>>=
void
pushio(void)
{
    Io *i;

    i = iostack;
    if(i == I) {
        yyerror("botch in pushio");
        errorexit();
    }
    i->p = fi.p;
    i->c = fi.c;
}
@

\section{[[#define]] and [[-D]]}

\subsection{[[-D]]}

<<[[main()]] command line processing>>=
case 'D':
    p = ARGF();
    if(p)
        Dlist[nDlist++] = p;
    break;
@

% -D
<<global Dlist>>=
char*	Dlist[30];
@

<<global nDlist>>=
int	nDlist;
@

<<[[assemble()]] init Dlist after pinit>>=
for(i=0; i<nDlist; i++)
        dodefine(Dlist[i]);
@

<<[[Sym]] other fields>>=
//option<string>, for '#define FOO xxx' expansion
char*	macro;
@

<<function dodefine>>=
void
dodefine(char *cp)
{
    Sym *s;
    char *p;
    long l;

    strcpy(symb, cp);
    p = strchr(symb, '=');
    if(p) {
        *p++ = 0;
        s = lookup();
        l = strlen(p) + 2;	/* +1 null, +1 nargs */
        while(l & 3)
            l++;

        while(nhunk < l)
            gethunk();
        *hunk = 0;
        strcpy(hunk+1, p);
        s->macro = hunk;
        hunk += l;
        nhunk -= l;

    } else {
        s = lookup();
        s->macro = "\0001";	/* \000 is nargs */
    }
    <<[[dodefine()]] debug>>
}
@



\subsection{[[#define]]}

<<constant NARG>>=
#define	NARG	25
@

% wow, this is complicated
<<function macdef>>=
void
macdef(void)
{
    Sym *s, *a;
    char *args[NARG], *np, *base;
    int n, i, c, len, dots;
    int ischr;

    s = getsym();
    if(s == S)
        goto bad;
    if(s->macro)
        yyerror("macro redefined: %s", s->name);
    c = getc();
    n = -1;
    dots = 0;
    if(c == '(') {
        n++;
        c = getnsc();
        if(c != ')') {
            unget(c);
            for(;;) {
                a = getsymdots(&dots);
                if(a == S)
                    goto bad;
                if(n >= NARG) {
                    yyerror("too many arguments in #define: %s", s->name);
                    goto bad;
                }
                args[n++] = a->name;
                c = getnsc();
                if(c == ')')
                    break;
                if(c != ',' || dots)
                    goto bad;
            }
        }
        c = getc();
    }
    if(isspace(c))
        if(c != '\n')
            c = getnsc();
    base = hunk;
    len = 1;
    ischr = 0;
    for(;;) {
        if(isalpha(c) || c == '_') {
            np = symb;
            *np++ = c;
            c = getc();
            while(isalnum(c) || c == '_') {
                *np++ = c;
                c = getc();
            }
            *np = 0;
            for(i=0; i<n; i++)
                if(strcmp(symb, args[i]) == 0)
                    break;
            if(i >= n) {
                i = strlen(symb);
                base = allocn(base, len, i);
                memcpy(base+len, symb, i);
                len += i;
                continue;
            }
            base = allocn(base, len, 2);
            base[len++] = '#';
            base[len++] = 'a' + i;
            continue;
        }
        if(ischr){
            if(c == '\\'){ 
                base = allocn(base, len, 1);
                base[len++] = c;
                c = getc();
            }else if(c == ischr)
                ischr = 0;
        }else{
            if(c == '"' || c == '\''){
                base = allocn(base, len, 1);
                base[len++] = c;
                ischr = c;
                c = getc();
                continue;
            }
            if(c == '/') {
                c = getc();
                if(c == '/'){
                    c = getc();
                    for(;;) {
                        if(c == '\n')
                            break;
                        c = getc();
                    }
                    continue;
                }
                if(c == '*'){
                    c = getc();
                    for(;;) {
                        if(c == '*') {
                            c = getc();
                            if(c != '/')
                                continue;
                            c = getc();
                            break;
                        }
                        if(c == '\n') {
                            yyerror("comment and newline in define: %s", s->name);
                            break;
                        }
                        c = getc();
                    }
                    continue;
                }
                base = allocn(base, len, 1);
                base[len++] = '/';
                continue;
            }
        }
        if(c == '\\') {
            c = getc();
            if(c == '\n') {
                c = getc();
                continue;
            }
            else if(c == '\r') {
                c = getc();
                if(c == '\n') {
                    c = getc();
                    continue;
                }
            }
            base = allocn(base, len, 1);
            base[len++] = '\\';
            continue;
        }
        if(c == '\n')
            break;
        if(c == '#')
        if(n > 0) {
            base = allocn(base, len, 1);
            base[len++] = c;
        }
        base = allocn(base, len, 1);
        base[len++] = c;
        c = ((--fi.c < 0)? filbuf(): (*fi.p++ & 0xff));
        if(c == '\n')
            lineno++;
        if(c == -1) {
            yyerror("eof in a macro: %s", s->name);
            break;
        }
    }
    do {
        base = allocn(base, len, 1);
        base[len++] = 0;
    } while(len & 3);

    *base = n+1;
    if(dots)
        *base |= VARMAC;
    s->macro = base;
    <<[[macdef()]] debug>>
    return;

bad:
    if(s == S)
        yyerror("syntax in #define");
    else
        yyerror("syntax in #define: %s", s->name);
    macend();
}
@

<<constant VARMAC>>=
#define VARMAC 0x80
@


<<function getsymdots>>=
Sym*
getsymdots(int *dots)
{
    int c;
    Sym *s;

    s = getsym();
    if(s != S)
        return s;

    c = getnsc();
    if(c != '.'){
        unget(c);
        return S;
    }
    if(getc() != '.' || getc() != '.')
        yyerror("bad dots in macro");
    *dots = 1;
    return slookup("__VA_ARGS__");
}
@

\subsection{Macro Expansion}

<<[[yylex()]] if macro symbol>>=
if(s->macro) {
    newio();
    cp = ionext->b;
    macexpand(s, cp);
    pushio();

    ionext->link = iostack;
    iostack = ionext;

    fi.p = cp;
    fi.c = strlen(cp);
    if(peekc != IGN) {
        cp[fi.c++] = peekc;
        cp[fi.c] = 0;
        peekc = IGN;
    }
    goto l0;
}
@
% abuse newio()? it's not really a new file here

% wow, complicated too
<<function macexpand>>=
void
macexpand(Sym *s, char *b)
{
    char buf[2000];
    int n, l, c, nargs;
    char *arg[NARG], *cp, *ob, *ecp, dots;

    ob = b;
    if(*s->macro == 0) {
        strcpy(b, s->macro+1);
        if(debug['m'])
            print("#expand %s %s\n", s->name, ob);
        return;
    }
    
    nargs = (char)(*s->macro & ~VARMAC) - 1;
    dots = *s->macro & VARMAC;

    c = getnsc();
    if(c != '(')
        goto bad;
    n = 0;
    c = getc();
    if(c != ')') {
        unget(c);
        l = 0;
        cp = buf;
        ecp = cp + sizeof(buf)-4;
        arg[n++] = cp;
        for(;;) {
            if(cp >= ecp)
                goto toobig;
            c = getc();
            if(c == '"')
                for(;;) {
                    if(cp >= ecp)
                        goto toobig;
                    *cp++ = c;
                    c = getc();
                    if(c == '\\') {
                        *cp++ = c;
                        c = getc();
                        continue;
                    }
                    if(c == '\n')
                        goto bad;
                    if(c == '"')
                        break;
                }
            if(c == '\'')
                for(;;) {
                    if(cp >= ecp)
                        goto toobig;
                    *cp++ = c;
                    c = getc();
                    if(c == '\\') {
                        *cp++ = c;
                        c = getc();
                        continue;
                    }
                    if(c == '\n')
                        goto bad;
                    if(c == '\'')
                        break;
                }
            if(c == '/') {
                c = getc();
                switch(c) {
                case '*':
                    for(;;) {
                        c = getc();
                        if(c == '*') {
                            c = getc();
                            if(c == '/')
                                break;
                        }
                    }
                    *cp++ = ' ';
                    continue;
                case '/':
                    while((c = getc()) != '\n')
                        ;
                    break;
                default:
                    unget(c);
                    c = '/';
                }
            }
            if(l == 0) {
                if(c == ',') {
                    if(n == nargs && dots) {
                        *cp++ = ',';
                        continue;
                    }
                    *cp++ = 0;
                    arg[n++] = cp;
                    if(n > nargs)
                        break;
                    continue;
                }
                if(c == ')')
                    break;
            }
            if(c == '\n')
                c = ' ';
            *cp++ = c;
            if(c == '(')
                l++;
            if(c == ')')
                l--;
        }
        *cp = 0;
    }
    if(n != nargs) {
        yyerror("argument mismatch expanding: %s", s->name);
        *b = 0;
        return;
    }
    cp = s->macro+1;
    for(;;) {
        c = *cp++;
        if(c == '\n')
            c = ' ';
        if(c != '#') {
            *b++ = c;
            if(c == 0)
                break;
            continue;
        }
        c = *cp++;
        if(c == 0)
            goto bad;
        if(c == '#') {
            *b++ = c;
            continue;
        }
        c -= 'a';
        if(c < 0 || c >= n)
            continue;
        strcpy(b, arg[c]);
        b += strlen(arg[c]);
    }
    *b = 0;
    if(debug['m'])
        print("#expand %s %s\n", s->name, ob);
    return;

bad:
    yyerror("syntax in macro expansion: %s", s->name);
    *b = 0;
    return;

toobig:
    yyerror("too much text in macro expansion: %s", s->name);
    *b = 0;
}
@

\section{[[#undef]]}

<<function macund>>=
void
macund(void)
{
    Sym *s;

    s = getsym();
    macend();
    if(s == S) {
        yyerror("syntax in #undef");
        return;
    }
    s->macro = nil;
}
@

\section{[[#ifdef]]}

% 0 = ifdef, 1 = ifndef, 2 = else, see mactab and domacro
<<function macif>>=
void
macif(int f)
{
    int c, l;
    bool bol;
    Sym *s;

    if(f == 2)
        goto skip;
    s = getsym();
    if(s == S)
        goto bad;
    if(getcom() != '\n')
        goto bad;
    if((s->macro != nil) ^ f)
        return;

skip:
    bol = true;
    l = 0;
    for(;;) {
        c = getc();
        if(c != '#') {
            if(!isspace(c))
                bol = false;
            if(c == '\n')
                bol = true;
            continue;
        }
        if(!bol)
            continue;
        s = getsym();
        if(s == S)
            continue;
        if(strcmp(s->name, "endif") == 0) {
            if(l) {
                l--;
                continue;
            }
            macend();
            return;
        }
        if(strcmp(s->name, "ifdef") == 0 || strcmp(s->name, "ifndef") == 0) {
            l++;
            continue;
        }
        if(l == 0 && f != 2 && strcmp(s->name, "else") == 0) {
            macend();
            return;
        }
    }

bad:
    yyerror("syntax in #if(n)def");
    macend();
}
@

\section{[[#pragma]]}

% effect of #pragma lib in .s ??

<<function macprag>>=
void
macprag(void)
{
    Sym *s;
    int c0, c;
    char *hp;
    Hist *h;

    s = getsym();

    if(s && strcmp(s->name, "lib") == 0) {
        c0 = getnsc();
        if(c0 != '"') {
            c = c0;
            if(c0 != '<')
                goto bad;
            c0 = '>';
        }
        for(hp = symb;;) {
            c = getc();
            if(c == c0)
                break;
            if(c == '\n')
                goto bad;
            *hp++ = c;
        }
        *hp = '\0';
        c = getcom();
        if(c != '\n')
            goto bad;
    
        /*
         * put pragma-line in as a funny history 
         */
        c = strlen(symb) + 1;
        while(c & 3)
            c++;
    
        while(nhunk < c)
            gethunk();
        hp = hunk;
        memcpy(hunk, symb, c);
        nhunk -= c;
        hunk += c;
    
        h = alloc(sizeof(Hist));
        h->name = hp;
        h->line = lineno;
        h->offset = -1;

        h->link = H;
        if(ehist == H) {
            hist = h;
            ehist = h;
            return;
        }
        ehist->link = h;
        ehist = h;

        return;

bad:
        unget(c);
        yyerror("syntax in #pragma lib");
        macend();

    } else {
        while(getnsc() != '\n')
            ;
        return;
    }
}
@


% most pragma seems to be discarded except #pragma lib, so
% I removed it (could have aslo simplified by calling prag_do_nothing()).
% is it because code was shared with cc? or because it's in aa/
% and other archi do different things?
%
%    if(s && strcmp(s->name, "pack") == 0) {
%        pragpack();
%        return;
%    }
%    if(s && strcmp(s->name, "fpround") == 0) {
%        pragfpround();
%        return;
%    }
%    if(s && strcmp(s->name, "profile") == 0) {
%        pragprofile();
%        return;
%    }
%    if(s && strcmp(s->name, "varargck") == 0) {
%        pragvararg();
%        return;
%    }
%    if(s && strcmp(s->name, "incomplete") == 0) {
%        pragincomplete();
%        return;
%    }
%
%old:
%<<function pragpack>>=
%void
%pragpack(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@
%
%<<function pragvararg>>=
%void
%pragvararg(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@
%
%<<function pragfpround>>=
%void
%pragfpround(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@
%
%<<function pragprofile>>=
%void
%pragprofile(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@
%
%<<function pragincomplete>>=
%void
%pragincomplete(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@


\section{[[#line]]}

<<function maclin>>=
void
maclin(void)
{
    char *cp;
    int c;
    long n;

    n = getnsn();
    c = getc();
    if(n < 0)
        goto bad;

    for(;;) {
        if(c == ' ' || c == '\t') {
            c = getc();
            continue;
        }
        if(c == '"')
            break;
        if(c == '\n') {
            strcpy(symb, "<noname>");
            goto nn;
        }
        goto bad;
    }
    cp = symb;
    for(;;) {
        c = getc();
        if(c == '"')
            break;
        *cp++ = c;
    }
    *cp = 0;
    c = getcom();
    if(c != '\n')
        goto bad;

nn:
    c = strlen(symb) + 1;
    while(c & 3)
        c++;

    while(nhunk < c)
        gethunk();
    cp = hunk;
    memcpy(hunk, symb, c);
    nhunk -= c;
    hunk += c;

    linehist(cp, n);
    return;

bad:
    unget(c);
    yyerror("syntax in #line");
    macend();
}
@

% could move with the other getxxx()
<<function getnsn>>=
long
getnsn(void)
{
    long n;
    int c;

    c = getnsc();
    if(c < '0' || c > '9')
        return -1;
    n = 0;
    while(c >= '0' && c <= '9') {
        n = n*10 + c-'0';
        c = getc();
    }
    unget(c);
    return n;
}
@



\chapter{Parsing}

\section{Overview}

% assume understand yacc! if not read classic book on lex&yacc
%  or docs/doc/unix/yacc.pdf (or read CompilerGenerator.tex.nw :) )

<<8a/a.y>>=
%{
#include "a.h"
%}
<<union token>>
<<priority and associativity declarations>>
<<token declarations>>
<<type declarations>>

%%
<<grammar>>
@

% have seen token declaration in Core Data structures already.

<<grammar>>=
prog:
  /* empty */
| prog line

<<line rule>>
<<inst rule>>
<<special opcode operands rules>>
<<operands rules>>
<<operand rules>>
<<constant expression rules>>
@

% assembly file is made of lines containing instructions or labels.
% instructions are mostly a single opcode with 0, 1, or 2 operands
% where each operand can be a register, or constant, or address, etc.
% and some combination (like register + constant offset)

% there are some special opcode like TEXT which don't translate
% in binary code but are useful for symbol resolving.

<<line rule>>=
line:
  inst ';'
@


% note that newline are translated in ';' by the lexer
% so can either pack in one line with ';' or use newline
% (haskell spirit :) )

<<line rule>>=
| ';'
| error ';'
@
% error? yacc trick for synchronization? to got until next ; (that is newline)?

\section{Instructions}

<<inst rule>>=
inst:
  LTYPE0 nonnon   { outcode($1, &$2); }
| LTYPE1 nonrem   { outcode($1, &$2); }
| LTYPE2 rimnon   { outcode($1, &$2); }
| LTYPE3 rimrem   { outcode($1, &$2); }
| LTYPE4 remrim   { outcode($1, &$2); }
| LTYPER nonrel   { outcode($1, &$2); }
@

% give apercu of nonnon, rem, but just quick

% outcode =~ pc++

\section{Operand}

% this is the rest from the %union
<<[[Token]] other fields>>=
 Gen   gen;
@

<<type declarations>>=
%type   <gen>   reg imm mem   omem nmem nam
@

% reg = register
% imm = immediate
% mem = memory (complex, omem | nmem)

\subsection{Registers}

<<operand rules>>=
reg:
  LBREG { $$ = nullgen; $$.type = $1; }
| LFREG { $$ = nullgen; $$.type = $1; }
| LLREG { $$ = nullgen; $$.type = $1; }
| LSREG { $$ = nullgen; $$.type = $1; }
| LSP   { $$ = nullgen; $$.type = D_SP; }
@


\subsection{Constants}

% con = constant
% prefix with $ (why? ambiguity with what?) to differentiate
% with just con where it's a omem (see section below)

<<operand rules>>=
imm:
 '$' con
 {
  $$ = nullgen;
  $$.type = D_CONST;
  $$.offset = $2;
 }
| '$' nam
 {
  $$ = $2;
  $$.index = $2.type;
  $$.type = D_ADDR;
  /*
  if($2.type == D_AUTO || $2.type == D_PARAM)
   yyerror("constant cannot be automatic: %s",
    $2.sym->name);
   */
 }
| '$' LSCONST
 {
  $$ = nullgen;
  $$.type = D_SCONST;
  memcpy($$.sval, $2, sizeof($$.sval));
 }
| '$' LFCONST
 {
  $$ = nullgen;
  $$.type = D_FCONST;
  $$.dval = $2;
 }
| '$' '(' LFCONST ')'
 {
  $$ = nullgen;
  $$.type = D_FCONST;
  $$.dval = $3;
 }
| '$' '-' LFCONST
 {
  $$ = nullgen;
  $$.type = D_FCONST;
  $$.dval = -$3;
 }
@

% MOV $AX, ... ?? vs MOV AX, ... ?

\subsection{Memory references}

<<operand rules>>=
mem:
  omem
| nmem
@

% omem = offset mem
% nmem = named memory?

<<operand rules>>=
omem:
 con
 {
  $$ = nullgen;
  $$.type = D_INDIR+D_NONE;
  $$.offset = $1;
 }
| con '(' LLREG ')'
 {
  $$ = nullgen;
  $$.type = D_INDIR+$3;
  $$.offset = $1;
 }
|   con '(' LSP ')'
 {
  $$ = nullgen;
  $$.type = D_INDIR+D_SP;
  $$.offset = $1;
 }
|   con '(' LLREG '*' con ')'
 {
  $$ = nullgen;
  $$.type = D_INDIR+D_NONE;
  $$.offset = $1;
  $$.index = $3;
  $$.scale = $5;
  checkscale($$.scale);
 }
|   con '(' LLREG ')' '(' LLREG '*' con ')'
 {
  $$ = nullgen;
  $$.type = D_INDIR+$3;
  $$.offset = $1;
  $$.index = $6;
  $$.scale = $8;
  checkscale($$.scale);
 }
|   '(' LLREG ')'
 {
  $$ = nullgen;
  $$.type = D_INDIR+$2;
 }
|   '(' LSP ')'
 {
  $$ = nullgen;
  $$.type = D_INDIR+D_SP;
 }
|   con '(' LSREG ')'
 {
  $$ = nullgen;
  $$.type = D_INDIR+$3;
  $$.offset = $1;
 }
|   '(' LLREG '*' con ')'
 {
  $$ = nullgen;
  $$.type = D_INDIR+D_NONE;
  $$.index = $2;
  $$.scale = $4;
  checkscale($$.scale);
 }
|   '(' LLREG ')' '(' LLREG '*' con ')'
 {
  $$ = nullgen;
  $$.type = D_INDIR+$2;
  $$.index = $5;
  $$.scale = $7;
  checkscale($$.scale);
 }
@
%$

\subsection{Named memory references}

% for data

<<operand rules>>=
nmem:
  nam
| nam '(' LLREG '*' con ')'
 {
  $$ = $1;
  $$.index = $3;
  $$.scale = $5;
  checkscale($$.scale);
 }
@
%$

% MOV foo(SB) ( AX * 8 ) ? =~ foo[ax] where sizeof foo element = 8?

%        MOVL    count+8(FP), CX
% this is just symbol for debugging help?

<<operand rules>>=
nam:
  LNAME offset '(' pointer ')'
 {
  $$ = nullgen;
  $$.type = $4;
  $$.sym = $1;
  $$.offset = $2;
 }
| LNAME '<' '>' offset '(' LSB ')'
 {
  $$ = nullgen;
  $$.type = D_STATIC;
  $$.sym = $1;
  $$.offset = $4;
 }
@
%$

<<type declarations>>=
%type   <lval>  pointer
@

<<operand rules>>=
pointer:
  LSB
| LFP
| LSP { $$ = D_AUTO; }
@


<<type declarations>>=
%type   <gen>  rel
@

% for code (rel = ? relocatable?)
<<operand rules>>=
rel:
 con '(' LPC ')'
 {
  $$ = nullgen;
  $$.type = D_BRANCH;
  $$.offset = $1 + pc;
 }
| LLAB offset
 {
  $$ = nullgen;
  $$.type = D_BRANCH;
  $$.sym = $1;
  $$.offset = $1->value + $2;
 }
| LNAME offset
 {
  $$ = nullgen;
  if(pass == 2)
   yyerror("undefined label: %s", $1->name);
  $$.type = D_BRANCH;
  $$.sym = $1;
  $$.offset = $2;
 }
@

%JMP 4(PC)

<<type declarations>>=
%type   <lval>  offset
@

<<operand rules>>=
offset:
 /* empty */ { $$ = 0; }
| '+' con    { $$ = $2; }
| '-' con    { $$ = -$2; }
@

% $


\subsection{Alternative forms}

<<type declarations>>=
%type   <gen>  rem rim rom 
@

% rem = register or memory
% rim = register or memory or immediate
% rom?


% imm2 dead? yacc does not detect?

<<operand rules>>=
rem:
  reg
| mem

rim:
  rem
| imm

rom:
  reg
| mem
| imm
| rel

| '*' reg  { $$ = $2; }
| '*' omem { $$ = $2; }
@
% was 
%| omem
%| nmem
% but factorized with mem which also makes things clearer

% use for the * version? seems equivalent to regular version no?

\section{Operands}

<<[[Token]] other fields>>=
 Gen2  gen2;
@

% I thought I could write code like
% /* empty */ { (Gen2) { .from = nullgen; .to = nullgen; } }
% but didn't work

<<type declarations>>=
%type   <gen2>  nonnon nonrel nonrem rimnon rimrem remrim
@

% xxxyyy = first operand, second operand
% nonnon = nothing first, nothing left


<<operands rules>>=
nonnon:
 /* empty */ { $$.from = nullgen; $$.to = nullgen; }
| ','        { $$.from = nullgen; $$.to = nullgen; }

rimrem:
 rim ',' rem { $$.from = $1; $$.to = $3; }

remrim:
 rem ',' rim { $$.from = $1; $$.to = $3; }

rimnon:
  rim       { $$.from = $1; $$.to = nullgen; }
| rim ','   { $$.from = $1; $$.to = nullgen; }

nonrem:
 rem        { $$.from = nullgen; $$.to = $1; }
| ',' rem   { $$.from = nullgen; $$.to = $2; }

nonrel:
 rel        { $$.from = nullgen; $$.to = $1; }
| ',' rel   { $$.from = nullgen; $$.to = $2; }
@

% each time put example of instructions and why it make sense?
% for instance rimrem vs remrim, make sense?

\section{Labels}

% this is incremented in outcode after each instruction 
% except for ADATA and AGLOBL
<<global pc>>=
long	pc;
@

<<line rule>>=
| LNAME ':'
 {
  $1->type = LLAB;
  $1->value = pc;
 }
 line
| LLAB ':'
 {
  if($1->value != pc)
   yyerror("redeclaration of %s", $1->name);
  $1->value = pc;
 }
 line
@
%$


\section{Special instructions}
% some of those are not really opcodes, they are entities 
% just at the asm level.

%hmm but nop? SHL? MOV? here because pseudo asm
% that get translated in store/load on some archi?

<<inst rule>>=
| LTYPED spec1    { outcode($1, &$2); }
| LTYPET spec2    { outcode($1, &$2); }
| LTYPEC spec3    { outcode($1, &$2); }
| LTYPEN spec4    { outcode($1, &$2); }
| LTYPES spec5    { outcode($1, &$2); }
| LTYPEM spec6    { outcode($1, &$2); }
| LTYPEI spec7    { outcode($1, &$2); }
| LTYPEG spec8    { outcode($1, &$2); }
@

<<type declarations>>=
%type   <gen2>  spec1 spec2 spec3 spec4 spec5 spec6 spec7 spec8
@

\subsection{[[TEXT]]}

<<special opcode operands rules>>=
spec2:  /* TEXT */
 mem ',' imm
 {
  $$.from = $1;
  $$.to = $3;
 }
|   mem ',' con ',' imm
 {
  $$.from = $1;
  $$.from.scale = $3;
  $$.to = $5;
 }
@
%$

\subsection{[[DATA]]}

%LTYPED
<<special opcode operands rules>>=
spec1:  /* DATA */
 nam '/' con ',' imm
 {
  $$.from = $1;
  $$.from.scale = $3;
  $$.to = $5;
 }
@
%$


\subsection{[[GLOBL]]}

<<special opcode operands rules>>=
spec8:  /* GLOBL */
 mem ',' imm
 {
  $$.from = $1;
  $$.to = $3;
 }
| mem ',' con ',' imm
 {
  $$.from = $1;
  $$.from.scale = $3;
  $$.to = $5;
 }
@
%$

\subsection{[[JMP/CALL]]}

<<special opcode operands rules>>=
spec3:  /* JMP/CALL */
 rom
 {
  $$.from = nullgen;
  $$.to = $1;
 }
| ',' rom
 {
  $$.from = nullgen;
  $$.to = $2;
 }
@

\subsection{[[NOP]]}

<<special opcode operands rules>>=
spec4:  /* NOP */
  nonnon
| nonrem
@
% NOP nonrem?

\subsection{[[SHL/SHR]]}

<<special opcode operands rules>>=
spec5:  /* SHL/SHR */
 rim ',' rem
 {
  $$.from = $1;
  $$.to = $3;
 }
| rim ',' rem ':' LLREG
 {
  $$.from = $1;
  $$.to = $3;
  if($$.from.index != D_NONE)
   yyerror("dp shift with lhs index");
  $$.from.index = $5;
 }
@
%$

\subsection{[[MOVW/MOVL]]}


<<special opcode operands rules>>=
spec6:  /* MOVW/MOVL */
 rim ',' rem
 {
  $$.from = $1;
  $$.to = $3;
 }
|   rim ',' rem ':' LSREG
 {
  $$.from = $1;
  $$.to = $3;
  if($$.to.index != D_NONE)
   yyerror("dp move with lhs index");
  $$.to.index = $5;
 }
@
%$

%LSREG! mv with other segments (but used in plan9? except 
% cs vs ds/es/fs/gs vs ss?

\subsection{[[IMUL]]}

<<special opcode operands rules>>=
spec7: /* IMUL */
 rim
 {
  $$.from = $1;
  $$.to = nullgen;
 }
| rim ','
 {
  $$.from = $1;
  $$.to = nullgen;
 }
| rim ',' rem
 {
  $$.from = $1;
  $$.to = $3;
 }
@


\section{Variables}
% useful? cpp can do that too

<<inst rule>>=
| LNAME '=' expr
 {
  $1->type = LVAR;
  $1->value = $3;
 }
| LVAR '=' expr
 {
  if($1->value != $3)
   yyerror("redeclaration of %s", $1->name);
  $1->value = $3;
 }
@

\section{Constant expressions}

% it's not Fortran, we're making an assembler :)
% so it's constant expressions here!

<<type declarations>>=
%type   <lval>  con expr
@

<<priority and associativity declarations>>=
%left   '|'
%left   '^'
%left   '&'
%left   '<' '>'
%left   '+' '-'
%left   '*' '/' '%'
@
% lower in the file = higher priority, earlier = lower priority

<<constant expression rules>>=
con:
  LCONST
| LVAR         { $$ = $1->value; }
| '-' con      { $$ = -$2; }
| '+' con      { $$ = $2; }
| '~' con      { $$ = ~$2; }
| '(' expr ')' { $$ = $2; }

expr:
  con
| expr '+' expr     { $$ = $1 + $3; }
| expr '-' expr     { $$ = $1 - $3; }
| expr '*' expr     { $$ = $1 * $3; }
| expr '/' expr     { $$ = $1 / $3; }
| expr '%' expr     { $$ = $1 % $3; }
| expr '<' '<' expr { $$ = $1 << $4; }
| expr '>' '>' expr { $$ = $1 >> $4; }
| expr '&' expr     { $$ = $1 & $3; }
| expr '^' expr     { $$ = $1 ^ $3; }
| expr '|' expr     { $$ = $1 | $3; }

@


\ifallcode
\section{Optional commas}
% the optional ',' why? because can ge generated by 8c -S that does
% this? a bit ugly so maybe better to aspectize this

\fi

\section{[[yyparse()]]}

% essentially generated code by yacc, that is calling yylex


\chapter{Output}

\chapter{Object Generation}
% it's actually not machine code generation ... 8l/optab.c does this

\section{Symbol table, [[h]] and [[sym]]}

% when an instruction involve a symbol
% the generated code contain an int that is an index
% in a symbol table!


<<struct Htab>>=
struct Htab
{
    // ref<Sym>
    Sym*	sym;
    //enum<operand_kind>?
    short	type;
};
@

<<constant NSYM>>=
#define	NSYM	50
@
% limit of number unresolved external symbols?


% starts to be used at index 1
<<global h>>=
// array<ref<Sym>>
struct Htab h[NSYM];
@


% next free entry in h (actually can be rested to 1)
<<global symcounter>>=
int	symcounter;
@
% was called sym

<<[[Sym]] other fields>>=
//?? seems used only by outcode
char	symidx;
@
% was called 'sym', but really it's an index in h, and it's confusing
% to have so many fields called sym already (as well as the global sym)





\section{[[outcode()]]}

% TODO LP split and transform while into if, easier flow
// a = opcode
<<function outcode>>=
void
outcode(int a, Gen2 *g2)
{
    // symbol from, index in h[]
    int sf;
    // symbol to, index in h[]
    int st;
    // enum<operand_kind>
    int t;
    Sym *s;

    if(pass == 1)
        goto out;

jackpot:
    sf = 0;
    s = g2->from.sym;

    while(s != S) {
        sf = s->symidx;

        if(sf < 0 || sf >= NSYM)
            sf = 0;

        t = g2->from.type;
        if(t == D_ADDR)
            t = g2->from.index;

        if(h[sf].type == t)
            if(h[sf].sym == s)
                break;

        zname(s->name, t, symcounter);
        s->symidx = symcounter;
        h[symcounter].sym = s;
        h[symcounter].type = t;
        sf = symcounter;
        symcounter++;
        if(symcounter >= NSYM)
            symcounter = 1;
        break;
    }

    st = 0;
    s = g2->to.sym;

    while(s != S) {
        st = s->symidx;

        if(st < 0 || st >= NSYM)
            st = 0;

        t = g2->to.type;
        if(t == D_ADDR)
            t = g2->to.index;

        if(h[st].type == t)
            if(h[st].sym == s)
                break;

        zname(s->name, t, symcounter);
        s->symidx = symcounter;
        h[symcounter].sym = s;
        h[symcounter].type = t;
        st = symcounter;
        symcounter++;
        if(symcounter >= NSYM)
            symcounter = 1;

        if(st == sf)
            goto jackpot;
        break;
    }

    Bputc(&obuf, a);
    Bputc(&obuf, a>>8);
    Bputc(&obuf, lineno);
    Bputc(&obuf, lineno>>8);
    Bputc(&obuf, lineno>>16);
    Bputc(&obuf, lineno>>24);
    zaddr(&g2->from, sf);
    zaddr(&g2->to, st);

out:
    if(a != AGLOBL && a != ADATA)
        pc++;
}
@

\section{[[zaddr()]]}

% used also by 8c and 8l
<<enum misc2>>=
enum misc2 {
    T_TYPE		= 1<<0,
    T_INDEX		= 1<<1,
    T_OFFSET	= 1<<2,
    T_FCONST	= 1<<3,
    T_SYM		= 1<<4,
    T_SCONST	= 1<<5,
    T_OFFSET2	= 1<<6,
};
@
% >> >> >> >> >> >> >>
%dead:    T_GOTYPE	= 1<<7,

% s is index in h[] for symbol involved in the operand
<<function zaddr>>=
void
zaddr(Gen *a, int s)
{
    // bitset<enum<misc2>>
    int t;
    long l;
    int i;
    char *n;
    Ieee e;

    t = 0;
    if(a->index != D_NONE || a->scale != 0)
        t |= T_INDEX;
    if(a->offset != 0)
        t |= T_OFFSET;
    if(s != 0)
        t |= T_SYM;

    switch(a->type) {
    case D_NONE:
        break;
    case D_FCONST:
        t |= T_FCONST;
        break;
    case D_CONST2:
        t |= T_OFFSET|T_OFFSET2;
        break;
    case D_SCONST:
        t |= T_SCONST;
        break;
    default:
        t |= T_TYPE;
        break;
    }

    Bputc(&obuf, t);

    if(t & T_INDEX) {	/* implies index, scale */
        Bputc(&obuf, a->index);
        Bputc(&obuf, a->scale);
    }
    if(t & T_OFFSET) {	/* implies offset */
        l = a->offset;
        Bputc(&obuf, l);
        Bputc(&obuf, l>>8);
        Bputc(&obuf, l>>16);
        Bputc(&obuf, l>>24);
    }
    if(t & T_OFFSET2) {
        l = a->offset2;
        Bputc(&obuf, l);
        Bputc(&obuf, l>>8);
        Bputc(&obuf, l>>16);
        Bputc(&obuf, l>>24);
    }
    if(t & T_SYM)		/* implies sym */
        Bputc(&obuf, s);


    if(t & T_FCONST) {
        ieeedtod(&e, a->dval);
        l = e.l;
        Bputc(&obuf, l);
        Bputc(&obuf, l>>8);
        Bputc(&obuf, l>>16);
        Bputc(&obuf, l>>24);
        l = e.h;
        Bputc(&obuf, l);
        Bputc(&obuf, l>>8);
        Bputc(&obuf, l>>16);
        Bputc(&obuf, l>>24);
        return;
    }
    if(t & T_SCONST) {
        n = a->sval;
        for(i=0; i<sizeof(nullgen.sval); i++) {
            Bputc(&obuf, *n);
            n++;
        }
        return;
    }

    if(t & T_TYPE)
        Bputc(&obuf, a->type);
}
@

% for unresolved symbol names?
<<function zname>>=
void
zname(char *n, int t, int s)
{

    Bputc(&obuf, ANAME);		/* as(2) */
    Bputc(&obuf, ANAME>>8);
    Bputc(&obuf, t);		/* type */
    Bputc(&obuf, s);		/* sym */
    while(*n) {
        Bputc(&obuf, *n);
        n++;
    }
    Bputc(&obuf, '\0');
}
@

\section{[[outhist()]]}

% it looks like outhist generate some header information,
% where is the spec of the format? ld uses that I guess no?

% main() -> assemble() -> outhist() at begining of pass 2
%out hist??
<<function outhist>>=
void
outhist(void)
{
    Gen g;
    Hist *h;
    char *p, *q, *op, c;
    int n;

    g = nullgen;
    c = pathchar();

    for(h = hist; h != H; h = h->link) {
        p = h->name;
        op = nil;
        // relative file?
        if(p && p[0] != c && h->offset == 0 && pathname){
            if(pathname[0] == c){
                op = p;
                p = pathname;
            }
        }
        while(p) {
            q = strchr(p, c);
            if(q) {
                n = q-p;
                if(n == 0){
                    n = 1;	/* leading "/" */
                    *p = '/';	/* don't emit "\" on windows */
                }
                q++;
            } else {
                n = strlen(p);
                q = nil;
            }

            if(n) {
                Bputc(&obuf, ANAME);
                Bputc(&obuf, ANAME>>8);
                Bputc(&obuf, D_FILE);	/* type */
                Bputc(&obuf, 1);	/* sym */
                Bputc(&obuf, '<');
                Bwrite(&obuf, p, n);
                Bputc(&obuf, '\0');
            }
            p = q;
            if(p == nil && op) {
                p = op;
                op = nil;
            }
        }

        g.offset = h->offset;

        Bputc(&obuf, AHISTORY);
        Bputc(&obuf, AHISTORY>>8);

        Bputc(&obuf, h->line);
        Bputc(&obuf, h->line>>8);
        Bputc(&obuf, h->line>>16);
        Bputc(&obuf, h->line>>24);

        zaddr(&nullgen, 0);
        zaddr(&g, 0);
    }
}
@

\chapter{Advanced Topics}

\section{[[#pragma lib]] and automagic linking}

% this is very very nice! remove so much headache,
% no need ocamlfind, no need pkg-config, so simple ...

\section{Float}

<<struct ieee>>=
struct	ieee
{
    long	l;	/* contains ls-man	0xffffffff */
    long	h;	/* contains sign	0x80000000
                    exp		0x7ff00000
                    ms-man	0x000fffff */
};
@


<<function ieeedtod>>=
void
ieeedtod(Ieee *ieee, double native)
{
    double fr, ho, f;
    int exp;

    if(native < 0) {
        ieeedtod(ieee, -native);
        ieee->h |= 0x80000000L;
        return;
    }
    if(native == 0) {
        ieee->l = 0;
        ieee->h = 0;
        return;
    }
    fr = frexp(native, &exp);
    f = 2097152L;		/* shouldnt use fp constants here */
    fr = modf(fr*f, &ho);
    ieee->h = ho;
    ieee->h &= 0xfffffL;
    ieee->h |= (exp+1022L) << 20;
    f = 65536L;
    fr = modf(fr*f, &ho);
    ieee->l = ho;
    ieee->l <<= 16;
    ieee->l |= (long)(fr*f);
}
@

<<constant FPCHIP>>=
#define	FPCHIP		true
@


\section{Processing multiple files}

% why need that?


<<[[main()]] locals>>=
int nout, nproc, status;
int i, c;
@

<<[[main()]] multiple files handling>>=
if(argc > 1) {
    nproc = 1;
    if(p = getenv("NPROC"))
        nproc = atol(p);	/* */
    c = 0;
    nout = 0;
    for(;;) {
        while(nout < nproc && argc > 0) {
            i = fork();
            if(i < 0) {
                i = mywait(&status);
                if(i < 0)
                    errorexit();
                if(status)
                    c++;
                nout--;
                continue;
            }
            if(i == 0) {
                print("%s:\n", *argv);
                if(assemble(*argv))
                    errorexit();
                exits(0);
            }
            nout++;
            argc--;
            argv++;
        }
        i = mywait(&status);
        if(i < 0) {
            if(c)
                errorexit();
            exits(0);
        }
        if(status)
            c++;
        nout--;
    }
}
@

\chapter{Conclusion}










\appendix

\chapter{Debugging}

% ex: 'm', 'f' (256 so can have for each character a boolean value)
<<global debug>>=
bool	debug[256];
@

<<[[main()]] debug initialization>>=
memset(debug, false, sizeof(debug));
@

<<[[main()]] command line processing>>=
default:
    c = ARGC();
    if(c >= 0 || c < sizeof(debug))
        debug[c] = true;
    break;
@

\section{[[8a -m]], macro debugging}
% m for macro

<<[[dodefine()]] debug>>=
if(debug['m'])
    print("#define (-D) %s %s\n", s->name, s->macro+1);
@

<<[[macdef()]] debug>>=
if(debug['m'])
    print("#define %s %s\n", s->name, s->macro+1);
@

\section{[[8a -f]], line information debugging}

<<[[linehist()]] debug>>=
if(debug['f'])
    if(f) {
        if(offset)
            print("%4ld: %s (#line %d)\n", lineno, f, offset);
        else
            print("%4ld: %s\n", lineno, f);
    } else
        print("%4ld: <pop>\n", lineno);
@

\chapter{Error Managment}

<<function errorexit>>=
void
errorexit(void)
{

    if(outfile)
        remove(outfile);
    exits("error");
}
@

<<global nerrors>>=
int	nerrors = 0;
@
% used to be initialized in cinit()

<<function yyerror>>=
void
yyerror(char *a, ...)
{
    char buf[200];
    va_list arg;

    /*
     * hack to intercept message from yaccpar
     */
    if(strcmp(a, "syntax error") == 0) {
        yyerror("syntax error, last name: %s", symb);
        return;
    }

    prfile(lineno);

    va_start(arg, a);
    vseprint(buf, buf+sizeof(buf), a, arg);
    va_end(arg);

    print("%s\n", buf);
    nerrors++;
    if(nerrors > 10) {
        print("too many errors\n");
        errorexit();
    }
}
@

<<constant HISTSZ>>=
#define	HISTSZ		20
@

<<function prfile>>=
void
prfile(long l)
{
    int i, n;
    Hist a[HISTSZ], *h;
    long d;

    n = 0;
    for(h = hist; h != H; h = h->link) {
        if(l < h->line)
            break;
        if(h->name) {
            if(h->offset == 0) {
                if(n >= 0 && n < HISTSZ)
                    a[n] = *h;
                n++;
                continue;
            }
            if(n > 0 && n < HISTSZ)
                if(a[n-1].offset == 0) {
                    a[n] = *h;
                    n++;
                } else
                    a[n-1] = *h;
            continue;
        }
        n--;
        if(n >= 0 && n < HISTSZ) {
            d = h->line - a[n].line;
            for(i=0; i<n; i++)
                a[i].line += d;
        }
    }
    if(n > HISTSZ)
        n = HISTSZ;
    for(i=0; i<n; i++)
        print("%s:%ld ", a[i].name, (long)(l-a[i].line+a[i].offset+1));
}
@

\chapter{Libc}

\section{Memory managment}
% same in Linker, not sure why they just don't use malloc?
% to avoid dependencies to libc? for bootstrapping reasons?

<<global hunk>>=
char*	hunk;
@

<<global nhunk>>=
long	nhunk = 0;
@
% used to be set in cinit()

<<global thunk>>=
long	thunk;
@

<<constant NHUNK>>=
#define	NHUNK		10000
@


<<function gethunk>>=
void
gethunk(void)
{
    char *h;
    long nh;

    nh = NHUNK;
    if(thunk >= 10L*NHUNK)
        nh = 10L*NHUNK;

    h = (char*)sbrk(nh);
    if(h == (char*)-1) {
        yyerror("out of memory");
        errorexit();
    }
    hunk = h;
    nhunk = nh;
    thunk += nh;
}
@



<<constant MAXALIGN>>=
#define MAXALIGN 7
@

<<function alloc>>=
/*
 * real allocs
 */
void*
alloc(long n)
{
    void *p;

    while((uintptr)hunk & MAXALIGN) {
        hunk++;
        nhunk--;
    }

    while(nhunk < n)
        gethunk();
    p = hunk;
    nhunk -= n;
    hunk += n;

    return p;
}
@

<<function allocn>>=
void*
allocn(void *p, long on, long n)
{
    void *q;

    q = (uchar*)p + on;
    if(q != hunk || nhunk < n) {

        while(nhunk < on+n)
            gethunk();
        memmove(hunk, p, on);
        p = hunk;
        hunk += on;
        nhunk -= on;

    }
    hunk += n;
    nhunk -= n;
    return p;
}
@


\chapter{Extra Code}

\ifallcode
#include "Assembler_extra.tex.nw"
\fi

\chapter{Changelog}
\label{sec:changelog}

\chapter{Glossary}
\label{sec:glossary}

\begin{verbatim}
ISA Instruction Set Architecture
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{section}{Index}

%\chapter{References} 
\addcontentsline{toc}{section}{References}

\begin{thebibliography}{99}

\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming}, 
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb}, 
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison}, 
\url{http://padator.org/software/project-syncweb/readme.txt}

\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
