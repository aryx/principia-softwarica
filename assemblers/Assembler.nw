\documentclass[twocolumn, landscape]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosetrue % see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things:
%  - better organisation of the code, my TOC is better than the few existing
%    files (which didn't have very good names)
%  - removed deadcode (Ref, imm2, con2, NMACRO, CLAST, isreg, ...)
%  - renamed some enums (as => opcode, <noname> => operand_kind)
%  - reordered opcodes and operand kinds, and cleaned them:
%     * removed opcodes (ADWORD, ABX, ...)
%     * removed operand kinds (D_GOK, D_ADDR, D_OCONST, ...)
%  - introduced sym_kind, splitted from operand_kind, for ANAME
%  - factorized more code between ARM and x86 (abusing LP chunks)
%  - removed a few grammar rules, weird operand forms that were not used anyway
%    as well as the optional commas here and there
%  - TODO rename types, clearer, Gen? as Adr? or Operand? (and Gen2? as Prog?)

%thx to codemap/codegraph/scheck:
% - factorized code in aa/
% - mv errorexit, alloc, in utils.c instead of lexbody.c, same for gethunk
% - have a main.c instead of putting everything in lex.c

%thx to this manual, better understand assembly and assembler:
% - an object file is really a module, the simplest/lowest module abstraction
% - calling conventions, they are really that on ARM: conventions
% - can actually understand the assembly code in Kernel.nw :) param1+0(FP)
% - the difference betweeen GLOBL and DATA, declaration vs definition
% - TODO -fpic?

%history LP-ization:
% - skeleton, mostly copy paste of Template.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * TODO ctor/dtor, dumper
%    * [[xxx]] other fields, [[xxx]] extra fields
% - read Extra section, identify concepts, first TOC
% - distribute parts of the file before
% - nullify, boolify, typeify,    scheckify
% - aspecify advanced features!
% - SEMI add explanations
% - SEMI add figures

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
%\usepackage{cleveref} %\cref
%\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}
%\usepackage{minitoc}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% ifallcode is used for:
%  - forward decl, func decl, extern decl, #ifdef, pragmas (stuff in Extra.nw)
%  - misc opcodes (e.g. MVN)
%  - misc optional syntactic elements (e.g. commas)
%  - grammar literate boilerplate

%\setcounter{tocdepth}{1}

%\usepackage[margin=0.5in]{geometry}
%  but eat the bottom when very low
%\usepackage{fullpage} is deprecated 
% => do the more manual below:

%\addtolength{\oddsidemargin}{-.850in}
%\addtolength{\evensidemargin}{-.850in}
%\addtolength{\textwidth}{1.70in}
%
\addtolength{\topmargin}{-.850in}
\addtolength{\textheight}{1.70in}
% too big constraints when in portrait mode, cause some WEIRD errors
% in landscape it's ok though

\begin{document}
%******************************************************************************
% Title
%******************************************************************************
\title{
{\Huge 
Principia Softwarica: The ARM Assembler [[5a]]
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}\\
\\
with code from\\
Rob Pike
}

\maketitle 
\l ARMv6 (32 bits) edition, and 
\n alt: 8a x86 (32 bits) edition, see Assembler_x86.nw
\n Plan9 in core title? meh

\onecolumn
\hrule
\input{../docs/latex/Copyright}
\input{../docs/latex/CopyrightPlan9}
\hrule
\twocolumn

\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\tableofcontents
\endgroup

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

The goal of this book is to present with full details the source code of
an {assembler}.

\section{Motivations}

Why an assembler? Because we think you are a better programmer 
if you fully understand how things work under the hood, and 
an assembler is an essential part of any {development toolchain}.
\l which itself is essential
Indeed, compilers for higher level languages such as C usually
do not generate directly {machine code} but instead rely
on an assembler (and linker) for their final code-generation step.
\n 5c actually does not really rely on the external assembler 5a
\n but gcc/ocamlopt do generate assembly and call external assembler gas

Even if most programmers very rarely write {assembly} code,
understanding an assembly language, and so also what an assembler does,
is essential to understand low-level fundamental concepts such as 
{binary logic and arithmetic}, {memory operations}, {pointers}, 
{stack processing}, {frames},
{software interrupts}
and to understand what a compiler generates. 
%tags: c-target
Note also that some code, especially in the kernel, can not be written in C
and has to be written in assembly.

Here are a few questions we hope this book will answer:
\begin{itemize}
\item What is the list of all low-level instructions?
What a typical computer can do?

\item What are the essential features of an assembler? How they help
over writing directly machine code?

\item What are the most important assembly constructs? How
can they be used to implement high-level constructs in languages
such as C?
%tags: c-target

\item How function calls are implemented? What is a frame?
What is a frame pointer? How recursive functions are implemented?
What are calling conventions?

\item What is in an object file? What difference there is
between an object file and an executable?

\item How the assembler and linker work together?

\end{itemize}
\n try questions more specific to asm, put the rest in Machine.nw
\l what is position independent code? maybe linker issue

%tags: ocaml: to give a hint on how rewriting C in OCaml could improve things
%tags: real-world: to relate to other assemblers

\section{The \plan ARM assembler, [[5a]]}

We will explain in this book the code of the \plan ARM assembler
[[5a]]\footnote{\url{http://plan9.bell-labs.com/magic/man2html/1/8a},
which despite its name covers also [[5a]]}
%WEIRD: If I uncomment above I get weird pdftex errors when have big textheight
which is about 4100 lines of code (LOC).
\n see make loc (or cm -test_loc)
[[5a]] is written in C for the most part with its parser using also Yacc.
\l cite for C and Yacc?
%
Like for most books in \principia, we chose a \plan software because
they are simple, small, elegant, open source, and they form together
a coherent set of software.
The [[5]] comes from the \plan convention to name architecture
with a number or single letter (0 is MIPS, 5 is ARM, 8 is x86, etc),
and the [[a]] means assembler.
\l put in this section the discussions about Asm5 and Asm9?

Like for the other \principia books covering the
{development toolchain}, we chose the ARM architecture~\cite{arm-refman}
variant, in this case of the \plan assembler ([[5a]]),
and not for instance the x86 variant ([[8a]]), for
reasons of simplicity. Indeed RISC machines
are far simpler than CISC machines. Moreover, the availability
under \plan of an ARM emulator, [[5i]], helps to understand
the semantics of the assembly instructions used in [[5a]].
\n Using x86 also make it more error prone when want to change things
\n because we would have also to change kencc (e.g. error prone to change
\n the order of asm instructions).

Note that the \plan assemblers output differs slightly from
other traditional assemblers. The {files} generated by [[5a]],
called the {\em object files},
are ARM-specific, but they do not contain really machine code. Instead
the object file is essentially the {serialized form} of the 
{abstract syntax tree} of the assembly source. 
\l Ref to later? maybe hard to understand. 
The actual machine code generation is performed by the linker [[5l]].
We think though that it is actually a better design because it leads to
less code in total and also to simpler code.
\n a critique of go/plan9 toolchain though, see comment in .tex:
% - http://dtrace.org/blogs/wesolows/2014/12/29/golang-is-trash/
%   with https://news.ycombinator.com/item?id=8815778
%   and http://www.reddit.com/r/programming/comments/2riayd/golang_is_trash/

\section{Other assemblers}

Here are a few assemblers that were considered for this book but
which were ultimately discarded:
\begin{itemize}

\item The GNU Assembler [[gas]], part of the [[binutils]] package, 
is probably the most used open source assembler.
It supports many architectures.
It is called internally by [[gcc]] and so is indirectly
used to assemble most open source software.
\l maybe clang/llvm competes a bit now
It is very big though:
350K LOC for [[gas/]], which is almost two orders of magnitude
more code than [[5a]],
and 3.4M LOC for the whole [[binutils]] package (not including the testsuite).
Even the ARM-specific file [[gas/config/tc-arm.c]] has already 25 000 LOC.
\l everything moved from as86 to gas

\item NASM is a popular x86 assembler using the Intel
syntax as opposed to [[gas]] (and [[5a]]) which uses the \att syntax.
It is also fairly large: 50 000 LOC.
\n popular on linux especially, but also works on windows and mac

\item AS86, a x86 16-bit and 32-bit assembler, part of
Bruce Evans' C compiler (BCC), is an historical assembler
used to compile old versions of Minix and Linux. It is
also using the Intel syntax. Because it can generate 16-bit
``real-mode'' machine code, it is still used to compile programs such
as boot loaders. It is fairly small: 12 500 LOC. This
includes the machine code generation which is not done by [[5a]]
(but done by [[5l]]). 
\l to be fair LOC of 5l is big, but 5a plus 5l LOC < as86 plus ld86
However, because x86 is a rather
complicated architecture, the 16-bit/32-bit as well as
the different CPU modes (real-mode, protected-mode, virtual-mode) 
being just a testimony of this complexity, 
we prefer to present an ARM assembler.
\l a bit dead, used only by elks project now

\item MMIXAL, an assembler for the MMIX virtual machine
invented by Donald Knuth, is a small and 
very well documented program~\cite{mmixware}.
\l actually not that well, I dont like his style, no structure, no TOC
Its (literate) source is about 3200 LOC. 
\l includes also machine code generation
But, in \principia we want to restrict ourselves to software which can run
on real machines.
\n what about mixal? used in the mdk, smaller? does not matter, not LP probably

\n assembler for hack? not included in distro, had to write ourselves!

\l also fasm, masm, tasm, seems popular

\end{itemize}

\l lots of other assemblers, see the comment in the .tex
%other:
% - llvm has one? well the IR of llvm is a kind of assembler, but portable
% - fbas, use lex and yacc, 720 LOC, but looks really simplified
% - pep/8 assembler?
% - https://github.com/trillek-team/computer-toolkit include
%   a toy asm, linker, and even a toy C compiler
% - http://www.compilers.de/vasm.html (also vbcc and vlink)
% - see also hex2c? the assembler in subc-2014, ...
% - web based assembler+debugger, teaching purpose: http://yasp.me/
% - piton, a proven assembler in boyer moore
%see also http://www.tldp.org/HOWTO/Assembly-HOWTO/other.html

\n more recently:
\n - TAL, typed assembly language
\n - coq macro assembler


\section{Getting started}
\label{sec:getting-started}

To play with [[5a]] you will first need to install
the \plan fork used in \principia. See \urlinstall.
Once installed, you can test [[5a]] under \plan with:

\begin{verbatim}
1   $ cd /tests/5a
2   $ 5a hello.s
3   $ 5l hello.5 -o hello
4   $ ./hello
5   hello world
6   $
\end{verbatim}

The command in Line 2 {assembles} the very simple [[hello.s]]
ARM assembly program and generates the [[hello.5]] ARM {object file}.
\n define object file? partly defined before in motivations
Line 3 then {links} the object file and generates the final 
ARM binary executable [[hello]].
Line 4, which assumes you are under an ARM machine (e.g. a Raspberry Pi)
{launchs} the program.

Note that it is easy under \plan to {cross compile} from another architecture:
you can use the same commands, [[5a]], [[5l]], etc.
\l because magic /bin, and also because special 5 convention
To play with [[5a]] under an x86 machine you just need
after the linking step to use the ARM emulator [[5i]] instead:

\begin{verbatim}
...
4   $ 5i hello
...
\end{verbatim}

See the \book{Emulator} for more information on [[5i]].
\l actually cool cos can be used as an assembly debugger too

\section{Requirements}

Because most of this book is made of C source code, 
you will need to have a good knowledge of 
the C programming language~\cite{k-r} to understand it.
\l actually lots of bit manip, and C idioms used
To understand Chapter~\ref{chap:parsing} you will also
need to know Yacc~\cite{lexyacc}.
\l Can read Compiler.pdf :) and Generators.pdf :) but a bit self reference.

Note that this book is not an introduction to 
assembly programming.
We assume you already know one assembly language
(not necessarily the one used by [[5a]] though),
know roughly how an assembler works, and that you
have a basic understanding of computer architecture.
We assume you are already familiar 
with concepts such as
{registers}, {stack pointer}, {program counter},
{memory move}, {branching},
{labels},
\n {frame pointer}, hmmm maybe not, we can explain in this doc.
etc.
We assume you already know most of the theory; this book is here to
cover the practice.
\l MIPS assembly tutorial, might give some ideas (use spim)
%http://programmedlessons.org/AssemblyTutorial/index.html


It is not necessary to know the ARM architecture to
understand this book, but
we recommend to read the \book{Emulator} to fully understand
the semantics of some assembly instructions.
\l maybe Machine.nw is actually a necessary requirment?

It can be also useful to read the documentation of
the \plan assemblers available in our \plan repository in 
[[assemblers/docs/asm.pdf]] and
[[docs/man/1/8a]]\footnote{Despite its name this document also covers [[5a]]}.
\n 'as' article in unix programmer's manual? meh, seems unrelated to 5a.
There are also some extra notes about the assemblers
at \url{https://golang.org/doc/asm} which can be useful.
\n Go used to use the plan9 developer toolchain, made by same authors :)



\section{About this document}
#include "../docs/latex/About.nw"

\section{Copyright}

Most of this document is actually source code from Plan9, so
those parts are copyright by Lucent Technologies Inc.
The prose is mine and is licensed under the \license.

\section{Acknowledgments}

We would like to acknowledge of course the author of
[[5a]], Rob Pike, 
who wrote in some sense most of this book.






\chapter{Overview}

Before showing the source code of [[5a]] in the following chapters, 
we first give an overview in this chapter
of the general principles of an assembler, 
of the assembly language supported by [[5a]],
and of the format of the object files generated by [[5a]].
We also define terms, explain how the code is organized, 
and more generally give the background needed 
to understand the code we will show later.

\section{Assembler principles}

An {\em assembler} is a program which translates source code
written in an {assembly} programming language into
{machine code}, or into an {object code} close to machine code.
%
An {\em assembly} langage is a low-level programming language mimicing
closely the {instructions} of a machine, but using a {textual}
format far more convenient for the programmer than the
{binary} format used internally by computers.
\n as close as possible but not closer
%
Note that each assembly language is specific to a computer architecture.
\l and in fact even different assembler for same arch use different syntax
\n so it is not portable; C is a portable assembler!

Assembly languages use {\em mnemomics} to denote low-level {instructions}.
%
For instance an assembly programmer can simply use the mnemomic
[[ADD]] in his code instead of having to remember that [[0000100]]
is the binary code to perform an addition in an ARM
processor.
%
Typical instructions are made of an {\em opcode} and 
one or more {\em operands}.
%
For instance [[ADD 15, R1, R4]] is a complete assembly instruction 
telling the computer to add fifteen to the first register
and to put the result in the fourth register.
\l again mnemonic too for register names, and actually it's \$15
\n note that cant have ADD R1, 15, R4 because ARM restrictions on ADD
\n also note att syntax, left to right

A key feature of assemblers is to allow the use of {\em symbolic addresses}
as operands, freeing the programmer from tedious manual calculations.
%
Indeed, in assembly a programmer can {{define}} {\em symbols} designating
certain memory areas (for data or code)
\n use 'symbols' not 'labels', more general; they are in symbol table of binary
\n put globals or functions, hmm but label make things more general
and then {{use}} those symbols as operands.
For instance [[B foobar]] allows to {branch} (jump) 
to the code following the [[foobar]] symbol. 
\n actually it is B foobar(SB) in 5a if foobar is a symbol and not a label
%
Without symbolic addresses a programmer
would have instead to write something like [[B 1562]] and make sure
that he calculated correctly that 1562 was the address corresponding
to the thing he wanted to jump to. This would require to know
the size of each instruction, and each further modification of the program
could entail the recalculation of all those addresses.

So, the main functions of an assembler are typically:
\n function almost in a literal way; those phases correspond almost to 5a funcs
\begin{enumerate}
\item to {\em parse} an input textual file,
\item to {\em check} that the combinations of mnemonics and operands form 
valid machine instructions,
\n in 5a actually a few checks are delayed until linking
\item to {\em compute} the concrete values of symbolic addresses
(which usually requires a two pass algorithm as one can reference symbols
defined later in the file)
\n in 5a actually only labels are resolved, symbols are delayed until linking
\item to {\em generate} the binary machine code.
\n again 5a is special here
\end{enumerate}

In fact most assemblers do not generate the final machine code but instead
generate an {\em object code}, which is mostly machine code but
with extra information about {unresolved} symbols.
\n local labels disappear? Yes! in 5a at least
%
Indeed, even if for small programs the definitions and uses of symbolic
addresses could be in the same single file, as programs
grew larger it becomes useful to separate the source in different files.
\l for separation of concern, modularity, libs, reuse, separate compilation, ..
\l but now I do everything in one big file, so maybe can revisit that idea
In this case, one could want to reference in one assembly file
a symbol defined in another file. This is why the object file
must contain, in addition to machine code, enough information
about the {external} symbols this assembly file is using
(as well as the symbols it defines)  so that another tool, the {\em linker}
can later fully {resolve} all the symbol references used in all the files.
\n asm.pdf use external a lot, but often he means global
%
In essence, an object file is really the simplest form
of a {\em module}: it packs code, data, and information
about {exported} and {imported} entities.
\n but no properties for those entities, so not a real interface

A linker then essentially 
{concatenates} the code (and data) of the multiple object files together,
{resolves} all the symbolic addresses now that all 
the code (and data) is available and has been assigned a fixed memory area,
\n in fact can be tricky for variable-sized instructions like in x86,
\n has to make pessimistic guess and it complicates a lot things
{patches} all the incomplete instructions that were using unresolved symbols,
\n actually 5l does not patch machine code really
and finally {generates} the final binary executable.

\l lots of todo, figures, relocate local things, see comment in .tex
%put some concrete examples where see two assemblies, with symbols
%defined and used, and how the linker resolve and then relocate those things?
%or let that to the linker book?
%
%So the assembler must output code that must be "resolved" later, with 
%some symbol table information in the object for the linker
%to know what to do and where to patch things.
%
%The objects will also be concatenated together so branch/jmp addresses
%need also to be "relocated", and the same for the reference to 
%external symbols.

\section{[[5a]] command line interface}

The command line interface of the assembler [[5a]] is pretty simple:
\begin{verbatim}
$ 5a
usage: 5a [-options] file.s
$ 5a foo.s
$ 5l foo.5 bar.5 ...
\end{verbatim}
\t instruction to disassemble foo.5? db foo.5?

Given an input {assembly file} [[foo.s]], 
[[5a]] outputs an {object file} [[foo.5]].
One can change this default behaviour by using the [[-o <outfile>]] option.
\l normally generate (relocatable) machine code, but here 5a is a bit unusual.
Other options are related to macroprocessing and debugging and will 
be described later.
\l -D -I (cpp),  -f -m for debug
\t env: INCLUDE (for cpp, similar to -I), NPROC (when multi files?)


\section{[[helloworld.s]]}
\label{sec:helloworld}

From now on we call {\em Asm5} the ARM assembly language supported by [[5a]]. 
%
Because the different \plan assemblers
are really variations of a single program, the
assembly languages they support are also variations of a single language
we call {\em Asm9}. Asm5 can be seen as a specialized version of Asm9
for the ARM processor.
By understanding Asm5 you will understand also fairly well the assembly
languages supported by the other \plan assemblers (e.g. [[8a]])
as they have a lot in common.
\n asm is not portable, but cos they have a lot in common, easier a bit to port
\n even more easier thx to the virtual instructions such as MOVW or RET

In this section we will show a simple Asm5 program, [[helloworld.s]],
which prints [[Hello World]] when executed. We will use this
program as a tutorial for Asm5 (and more generally for Asm9).
\n I'd rather not write this tutorial but all existing docs on Asm5 are crap

\subsection*{Background}

To understand [[helloworld.s]] we must first show
the equivalent program written in C to introduce some background
on how to perform {system calls} in \plan.
\l system call em? link to Kernel book?
\n could have a hello.s that you link with libc so easier
\n but I like the idea of really raw simple hello world in assembly!
\n for Linux: http://sysdigcloud.com/fascinating-world-linux-system-calls/

Here is the simplest \plan{} [[hello world]] program written in C:

<<helloworld1.c>>=
#include <u.h>
#include <libc.h>

void main() {
  print("hello world\n");
}
@

This code is using the [[print()]] function from the core C library.
If we expand the code of this function and simplify things
we will get this C program:

<<helloworld2.c>>=
#include <u.h>
#include <libc.h>

void main() {
  pwrite(1, "hello world\n", 12, 0);
}
@

The [[pwrite()]] function is also defined in the C library,
but it is written in assembly in [[lib_core/libc/9syscall/pwrite.s]].
\n actually it's auto generated by mk from sys.h
It is a small wrapper around the {software interrupt} ARM instruction 
[[SWI]] which performs a {\em system call} (also known as a {\em syscall}).
\l more on this SWI later
%
Here is the prototype of [[pwrite()]] defined in [[include/core/libc.h]]:

<<prototype pwrite in libc.h>>=
extern	long	pwrite(fdt, void*, long, vlong);
@

The [[pwrite()]] interface is documented in 
[[docs/man/2/read]]\footnote{Again, despite its name this document also
covers [[pwrite]]}.
The parameters are in order 
a {file descriptor} (e.g. [[1]] for standard output), 
a string pointer, 
the number of bytes to write,
and finally a [[vlong]] seeking offset. 
%
Most of the parameters take 4 bytes except the [[vlong]] which takes 8 bytes.
\l will be important, see later
\l pwrite is the syscall, not write, vlong seek is for protocol atomicity, 2in1

\subsection*{The program}

We now have enough background to present the [[helloworld.s]]
program:

<<assemblers/5a/tests/hello.s>>=
1 	TEXT _main(SB), $20
2 	        B later
3 	        B loop /* not reached */
4 	later:
5 	        /* fill missing characters for hello */
6 	        MOVW $hello(SB), R2
7 	        MOVW $'W', R1        
8 	        MOVB R1, 6(R2)
9 	        MOVW $'o', R1        
10	        MOVB R1, 7(R2)
11	        MOVW $'r', R1        
12	        MOVB R1, 8(R2)
13	        MOVW $'l', R1        
14	        MOVB R1, 9(R2)
15	        MOVW $'d', R1        
16	        MOVB R1, 10(R2)
17	        MOVW $'\n', R1
18	        MOVB R1, 11(R2)
19	        /* prepare the system call PWRITE(1,&hello,12,00) */
20	        MOVW $1, R1
21	        MOVW R1, 4(R13)
22	        MOVW $hello(SB), R1
23	        MOVW R1, 8(R13)
24	        MOVW $12, R1
25	        MOVW R1, 12(R13)
26	        MOVW $0, R1
27	        MOVW R1, 16(R13)
28	        MOVW R1, 20(R13)
29	        MOVW $9 /*PWRITE*/, R0
30	        /* system call */
31	        SWI
32	        BL exit(SB)
33	        RET /* not reached */
34	loop:
35	        B loop
36	        
37	
38	TEXT exit(SB), $4
39	        /* prepare the system call EXITS(0) */
40	        MOVW $0, R1
41	        MOVW R1, 4(R13)
42	        MOVW $3 /*EXITS*/, R0
43	        /* system call */
44	        SWI
45	        RET /* not reached */
46	        
47	                        
48	GLOBL   hello(SB), $12
49	DATA    hello+0(SB)/6, $"Hello "
50	
@
%$
\n No libc! Using a simple _main. As simple as possible.
\l can also maybe show one that use libc, use 5c -S hello.c
\l show more examples? to get a feel for the lang e.g. code of strchr, div,...
\t can do with SP instead of R13 so less leaky abstraction 4(R13)
\l note that we call PWRITE syscall directly, not pwrite(), subtle

To assemble, link, and execute this program, simply do
like in Section~\ref{sec:getting-started}:
\begin{verbatim}
$ 5a hello.s
$ 5l hello.5 -o hello
$ ./hello
hello world
\end{verbatim}
\l if under ARM machine
\l show actual code? echo '$t :c' | 5i hello 
%$
\l show binary format? hexdump? (actually not bin instruction format! see below)

\subsection*{Pseudo-instructions}

The [[helloworld.s]] program defines three {symbols}:
two {procedures} [[_main()]] and [[exit()]], and one {global} [[hello]].
%
The two procedures are introduced via the [[TEXT]] 
{\em pseudo-instruction} Line~1 and 38,
and the global via [[GLOBL]] Line~48.
We say ``pseudo'' (or sometimes ``virtual'') because those
instructions do not match directly a machine instruction.
They are assembly-only constructs, also known as
{\em assembly directives}. Indeed, the ARM processor
has no notion of procedure names; it just manages numbers
and concrete addresses.
\l GLOBL allocate mem, and TEXT actually does magic stuff

The operands of the pseudo-instructions [[TEXT]] and [[GLOBL]]
\n was arguments, but better operands, for uniformity, because they are really
are the name of the {symbol} it defines, followed by [[(SB)]]
which we will explain later, and a {\em constant} value prefixed by a dollar.
In Asm9 all constants are prefixed by a dollar.
\l why? ambiguities? I think it's stupid because easy to make mistake then
\l actually in DATA the size is specified without dollar in .../6, offsets too
% I was doing MOVW 0, R1 which translates to MOVW 0(R0), R1 (not sure why)
% instead of MOVW $0, R1 and so had some segfaults at 0xc because
% R0 was return value from syscall which was lenght printed = 0xc
%
For [[GLOBL]] the constant value represents the size, in number of
bytes, this global will use. For [[hello]] Line~48 it is [[12]], enough
to hold the [["hello world\n"]] string.
%
For [[TEXT]] the constant value represents the size, in number of bytes,
this procedure will need for its {\em locals} in the {stack}. 
For [[_main()]] Line~1 it is [[20]], the
number of bytes needed to hold all the {arguments} in the stack
to the [[PWRITE]] system call 
\l more on this later
\l locals and arguments are the same
\l to the [[pwrite()]] function and 
(4 for the file descriptor integer, plus 4 for for the string pointer,
plus 4 for the size, plus 8 for the [[vlong]] offset).
\l actually there is an implicit plus 4

Note that the linker, [[5l]], is looking for a procedure named
[[_main]] for the entry point of the executable it generates,
even though the entry point of C programs is [[main]], not [[_main]].
This is because the core C library defines a [[_main()]] procedure
written in assembly which does some core initialisations
and then calls [[main()]].
In our example we do not use and so do not link the C library, so we must
define our own [[_main()]] entry point procedure.

%real-world: use .text, .data

\subsection*{Labels}

The first instruction of [[_main()]] Line 2
\l actually there is an hidden instruction generated dealing with R14/R13
is a jump, known as a {\em branch} in ARM (hence the [[B]]),
to [[later]], which is a {\em label} defined Line~4.
In Asm9 all label definitions are suffixed by a colon. 
\l in some sense TEXT and GLOBL are also introducing labels
\l how actually translated? B 1543? relative to PC?(R15)?
%
The syntax for {comments} in Asm9 are the same than in C
(see Line 3 and 5 for instance).

\subsection*{Assignments}

Line 6 places the {address} of the [[hello]] global
(suffixed again by [[(SB)]] which we will explain later)
in the {register} [[R2]]. 
There are 16 ARM registers named [[R0]] to [[R15]].
\l last 3 have special meaning and used specially by ARM
Note that Asm9 uses a {left-to-right} assignment syntax\footnote{called the
\att syntax as opposed to the Intel syntax which is right-to-left}.
Moreover, in Asm9 [[MOV]] instructions are suffixed with a letter
corresponding to a size: [[W]] for word, [[B]] for byte, etc.
\l hmm also sometimes MOVBU, gas does that too
\l also MOV is virtual instr, see later; 
Line 7 places the character constant [['W']], converted
by the assembler in its integer ASCII value (87), into the
register [[R1]].
\l also unicode?

\subsection*{Addressing modes}
\n https://en.wikipedia.org/wiki/Addressing_mode

Line 8 introduces a new {\em memory addressing mode}.
It is the first instruction that writes into memory; until now
we were only modifying the content of registers.
%
It {stores} the first byte (because of the [[B]] suffix)
of register [[R1]] (which should contain 87)
at the address {denoted} by [[R2]] plus [[6]].
%
The assembly instruction [[MOVB N, O(B)]] roughly corresponds
to the following C statement [[B[O] = N]], if [[B]] is a byte pointer,
which is also equivalent to this other C statement [[*(B+O) = N]].
\l what a strange syntax ... not sure where comes from, apparently not unix as
[[O]] is called the {\em offset}, which is applied to 
a pointer [[B]] called the {\em base}.
This addressing mode is called {\em indirect with offset}.
The [[()]] around the register corresponds rougly to the 
C {dereferencing} operator [[*]].
\l why not MOVB 'W', 6(R2)? because linker limitations
\l  but it does some magic for other virtual instr, so why not this one?
\l  because cc didn't need it?
\l there is mo pointer arithmetic though, for MOVW it is also raw B plus O

In fact, Line 6 introduced also an addressing mode.
The syntax [[hello(SB)]] is reminescent of the base
and offset addressing mode we have just seen.
[[SB]] stands for {\em static base} register.
It refers to the beginning of the address space of the program.
\n more on this later, it's a pseudo, it's not needed, it's weird
In Asm9 all references to global data and procedures
are written as offsets to [[SB]] (for definition references
see Line 1, 38, 48, and 49, and for use references
see Line 6, 22, and 32).
%
The instruction [[MOVW foo(SB), R1]] will move the {\em content}
at the address denoted by the symbol [[foo]] into [[R1]].
The instruction [[MOVW $foo(SB), R1]] %$
will store the {\em address} denoted by the symbol [[foo]] in [[R1]].
The \$ in that case corresponds rougly to the 
C {address} operator [[&]].
\l ugly to overload dollar which is already used for constants
\l it is the first instr that read memory?? it's static?
\l but why the generated code for Line 6 is MOVW #84(R15), R2 ? #10a8=#2000 ???
\l this SB is weird

\subsection*{Pseudo-registers}

[[SB]] is actually one of the few {\em pseudo-registers} in Asm9.
[[PC]] is another one which corresponds to the
(virtual) {\em program counter}. 
Similar to pseudo-instructions, pseudo-registers
do not correspond exactly to machine registers.
Indeed, the ARM has already a hardware register, [[R15]], which 
represents the program counter. 
Because the ARM has fixed-length instructions of 4 bytes,
the value of [[R15]] is always a multiple of 4. The pseudo-register
[[PC]] instead counts instructions, not bytes of data. So,
to branch to the second following instruction (that is to skip
one instruction) one does [[B 2(PC)]].
It is equivalent to [[B 8(R15)]].
\l I think it is equivalent
\n branch are absolute, PC plus 2 is absolute

Why using pseudo-registers? The advantage of using [[2(PC)]]
instead of [[8(R15)]] in Asm5 may look small. But, on some
architectures the size of instructions is actually variable.
It is not trivial for instance on x86 to compute the number
of bytes two arbitrary instructions are using.
%
Just like with the symbolic addresses, using pseudo-registers
allows the programmer to think in slightly higher-level terms, 
for [[PC]] in terms of instructions instead of bytes of data,
and delegate some tedious tasks such as counting
the size of instructions to the computer.

Asm9 defines four pseudo-registers:
\begin{itemize}
\item [[PC]], the (virtual) {program counter} which counts in 
number of instructions.
For the ARM, [[PC]] is related to the (real) program counter register [[R15]].

\item [[SB]], the {static base} register which
refers to the beginning of the address space of the program.
For the ARM, [[SB]] is related to the machine register [[R12]].
\t For SB it's more tricky to understand why we need that.
\l R12 is reserved by assembler, it's not reserved by machine

\item [[SP]], the (virtual) {\em stack pointer}, used to access local
variables in the stack.
\l also called auto, but local maybe bad name; it is also for callee args
For the ARM, [[SP]] is related to the (real) stack pointer register [[R13]].

\item [[FP]], the {\em frame pointer}, used to access the arguments
of the procedure in the stack.
\l set by caller
\t related to SP? more on this later

\end{itemize}

In this tutorial we will avoid using those pseudo-registers (except
[[SB]] because we have no choice).
Indeed, they may simplify things in the long term but they
add some extra complexities at the beginning.
\l generic, hide normally pecularities, complexities, but add some complexity

\subsection*{Call stack}

Line 6 through 18 set characters in the [[hello]] global array of characters. 

We can now examine Line 20 through 29 which build the {arguments} for the
system call performed Line 31 (with the software interrupt instruction
[[SWI]]). Arguments, in function calls or system calls, are by {convention}
hold primarily in the stack. We will see later that
[[R0]] under \plan plays also a special role regarding arguments because of 
some C and kernel {\em calling conventions}.
\l convention to be in stack, but convenient, for recursive
As said in the previous section, [[R13]] is the ARM stack pointer register.
\n I use R13 and not SP because SP is a pseudo which get played with
\n in the linker, so simpler use directly R13 to minimize explanations
\t and also because I dont understand how to use SP properly ... hmmm
Figure~\ref{fig:stack-start}
is a representation of the stack when the [[hello]] program
is loaded in memory by the kernel
(the stack grows downward so high addresses are at the top
in the diagram).
\n OSTEP book uses stack growing upward

\begin{figure}[!]\centering
\begin{verbatim}
        |       |
        |       |
R13 +-> +-------+
\end{verbatim}
\caption{Stack when [[hello]] started}\label{fig:stack-start}
\end{figure}

[[R13]] is initialized by the kernel before the kernel gives
control to the entry point of the binary program.
Its value is very high in the virtual memory address space.
Here is a dump of the registers using the emulator/debugger [[5i]]
before the program starts
\footnote{See the \book{Kernel}, or the \book{Emulator} 
and especially the code of [[initmemory()]] in [[5i]], to fully understand
the values of those registers.
}:

\begin{verbatim}
$ 5i helloa
5i> $r
...
R0  #7fffff70 R1  #7ffffffc R2  #0        R3  #0
R4  #0        R5  #0        R6  #0        R7  #0
R8  #0        R9  #0        R10 #0        R11 #0
R12 #0        R13 #7fffff58 R14 #0        R15 #1020
\end{verbatim}
\n first output line is: PC  #1020     SP  #7fffff58 but confusing I think
\n  because SP here is the machine SP, not assembler SP
\n why R0 weird value? and R1? TOS?
% in 5i see initmemory():
%    STACKTOP	= 0x80000000, 
%    ...
%    reg.r[0] = tos;
%    reg.r[REGSP] = sp;
%    reg.r[1] = STACKTOP-4;	/* Plan 9 profiling clock (why & why in R1?) */


Remember that the second operand to the [[TEXT]] pseudo-instruction
is the number of bytes this procedure will need for its {locals} in the {stack}.
\l locals, arguments
So, when assembled the [[TEXT]] pseudo-instruction Line~1
should generate a machine instruction which decrements R13 by 20. 
In fact, the actual generated instruction decrements R13 by 24;
\l in fact it also does also some magic with R14
we will see later why we need an extra word in the stack before the arguments.
%
Figure~\ref{fig:stack-line2} is the representation of the stack after Line~1
when the processor starts to execute the instruction Line~2.

\begin{figure}[!]\centering
\begin{verbatim}
        |       |
        |       |
    +24 +-------+ <-+ old value of R13
        |       |
    +20 +-------+
        |       |
    +16 +-------+
        |       |
    +12 +-------+
        |       |
     +8 +-------+
        |       |
     +4 +-------+ <- start of "locals"
        |       |
R13 +-> +-------+
\end{verbatim}
\caption{Stack before Line 2}\label{fig:stack-line2}
\end{figure}

Figure~\ref{fig:stack-line31} is the same stack before Line~31 
after the arguments to the system call have been set by Line~20 through 28.
\l note that arguments are in the ``stack space'' of the caller

\begin{figure}[!]\centering
\begin{verbatim}
        |       |
        |       |
    +24 +-------+ <-+ old value of R13
        |  0    |
    +20 +-------+
        |  0    |
    +16 +-------+
        |  12   |
    +12 +-------+
        |&hello |
     +8 +-------+
        |  1    |
     +4 +-------+ <- start of PWRITE arguments
        |       |
R13 +-> +-------+
\end{verbatim}
\caption{Stack before Line 31}\label{fig:stack-line31}
\end{figure}
\l remember 0 0 because vlong offset

\l getcallerpc code? with special minus 4
%TEXT getcallerpc(SB), 1, $-4
%	MOVW	0(R13), R0 /* R13 = SP */
%	RET
% 1 attribute??? need diagram again

\subsection*{System call}

The \plan{} {\em kernel calling conventions} impose to have all
the arguments in the stack ``above'' [[R13+4]],
and to use [[R0]] to hold
the syscall ``code''. The magic constant value [[9]]
at Line~29 is the code corresponding to the [[PWRITE]]
system call. See the file [[lib_core/libc/9syscall/sys.h]] 
which defines all those syscall codes.
\l could actually #include and use PWRITE
\n R0 is not the first argument anymore
The [[SWI]] instruction Line~31 then performs the system call
and jumps in the kernel.
\l need extra words before arguments for syscall too? because C convention?

\subsection*{Function call, branch and link}

Regular function calls in Asm5, e.g. the call to [[exit]] Line~32,
use the [[BL]] instruction which stands for {\em branch and link}.
%
Some processors such as the x86 have a [[CALL]] instruction 
which when executed push on the stack the value of the program counter
and then jump/branch to the code of the callee.
Then, a corresponding [[RET]] instruction in the callee
will pop back this value in the program counter to return back
to the caller.
\t and add 4? or it's done before? see code of BL in Machine.nw
\l classic use of stack, can do recursive functions like that
%
In the ARM, [[BL]] instead saves the value of the program
counter ([[R15]]) in a special register, [[R14]], 
known as the {\em link register}, and then jump to the callee. 


The use of a special register to hold {return addresses}
is an ARM optimisation which avoids using the stack, and so 
memory (which is slow), in certain situations.
%
Indeed, when a function does not call other functions, 
in which case it is called a {\em leaf} function, the value
of [[R14]] does not need to be saved and so returning
to the caller can be done quickly by setting the program
counter to the value in the link register via: [[B (R14)]].
\l or MOVW R14, R15 but apparently 5l does the B above.
%
If the function is not a leaf, then the value in [[R14]]
must be saved somewhere, in the stack, before the function calls
another function via [[BL]] which would overwrite [[R14]].
See the \book{Emulator} for more information on the ARM. 
%
Non-leaf functions are the reason the [[TEXT]] pseudo-instruction
allocates one more word that its second operand, e.g. 24
instead of 20 for [[_main]] Line~1, to hold the return address
to the caller in case [[R14]] needs to be saved.

\subsection*{Virtual instructions}

The leaf detection is done ({statically}) by the linker, [[5l]],
since it is the program generating actually the machine code in \plan,
and so the program which needs this information to optimize machine code.
%
A leaf is simply any procedure which does not contain any [[BL]] instruction,
for instance [[exit]] in our example\footnote{[[SWI]] does not count 
as a function call; [[R14]] is not overwritten by [[SWI]].
}.
\l In any case the kernel saves all the registers of the calling process?
\l actually only when context switch no?
[[_main]] on the opposite is not a leaf function since it is
using [[BL]] Line~32.
%
The actual machine instructions generated for the [[TEXT]] pseudo-instruction
depends on whether the function is a leaf. 
The same is true for the [[RET]] instruction, Line~33 and 45,
which is called a {\em virtual instruction}.
\l we call it that way? or asm.pdf does?
Indeed, the ARM does not have any [[RET]] instruction.
%
Figure~\ref{fig:virtual-text-ret}
describes roughly what machine code is generated
for the pseudo and virtual instructions [[TEXT]] and [[RET]]
of a simple procedure [[foo]], depending on whether this
procedure is a leaf or not:

\begin{figure}[!]\centering
\begin{verbatim}
TEXT foo(SB), $0   MOVW R14, 0(SP)          
                   SUB SP, $4, SP
 ...               ...                      ...
                   ADD SP, $4, SP           
 RET               B 0(SP)                  B (R14)
----------------  -----------------------  ------------------
  assembly code    machine code non-leaf    machine code leaf
\end{verbatim}
\caption{Machine code for pseudo/virtual instructions [[TEXT]] and [[RET]]}
\label{fig:virtual-text-ret}
\end{figure}
\l actually for TEXT it is a single MOVW.?? R14, #-4(R13) 
\l  and for RET it is MOVW.P #4(R13), R15
\l and actually it's ADD 0, R14, R15 instead of B (R14) (5l opti?)
\l not also that leaf opti is applied only if no locals (autosize = 0)
\l  so a bit less interesting. See leaf.s

\n real world: -fomit-frame-pointer! no need save SP in the stack!
\n but then harder to walk the stack!
\n can statically know when do RET what you allocated already,
\n can restore old SP easily.

The virtual instruction [[RET]], just like the 
pseudo-instruction [[TEXT]], or the pseudo-registers, allows the programmer
to think in slightly higher-level term and let the computer
do the appropriate optimizations.
%
In fact, [[MOVW]] is also a virtual instruction. It hides some 
architecture restrictions and peculiarities regarding memory accesses.
in Asm5 one can use the very general [[MOV]]
even though the ARM processor supports only the
more basics and separate [[LOAD]] and [[STORE]] instructions.
\n actually there is a MOV and it's LDR and STR but same basic idea
\l but a bit leaky abstraction because the linker puts later some restrictions

Instructions Line~40 though 44 are similar to the instructions
we have seen before. They perform the system call [[exits(0)]]
which terminates the program. This is why a few instructions
have been marked with a comment indicating those instructions
can not be reached since the program will have exited already
and so will not perform the [[RET]].

\subsection*{C calling conventions}

Note that the way arguments are laid out in the stack in
Figure~\ref{fig:stack-line31}, as well as the extra word before the
arguments (to possibly save the return address to the caller via
[[R14]]), and the fact that all those elements are ``above'' the stack
pointer ([[R13]]) at the entry of the function callee (or syscall
interrupt handler), is just a convention. 
%
The ARM processor does not dictate any specific way to call procedures.
In fact it does not even have a notion of procedure.
It only provides the [[BL]] machine instruction which saves 
[[R15]] in [[R14]]. The rest is a design choice.

The calling conventions we use in this tutorial come from the
{\em C calling conventions} used by the C compiler [[5c]].
Indeed, the assembly code generated by [[5c]] assumes
arguments are passed in a certain way and the stack
pointer has a certain value. We use similar conventions
in this tutorial because the code we present
performs a system call and the \plan{} {kernel calling conventions}
are derived from the C calling conventions. Indeed, the kernel
is mostly written in C.

The C calling conventions are actually slightly different from
the kernel calling conventions. Instead of using [[R0]] to
store the syscall code, [[R0]] is used to store the first argument.
In fact [[R0]] is also used to store the return value of C
functions.
\l except for vlong? and float?
This is an optimisation similar to the one we have seen previously
with the link register. For certain simple and small functions,
everything can be done using just registers, without having to use
the stack and so the (slow) memory.

Figure~\ref{fig:stack-c-pwrite} shows how the stack would
look like is we were calling the C function [[pwrite()]]
instead of doing directly the system call to [[PWRITE]].

\begin{figure}[!]\centering
\begin{verbatim}
        |       |
        |       |
    +24 +-------+ <-+ old value of R13
        |  0    |
    +20 +-------+
        |  0    |
    +16 +-------+
        |  12   |
    +12 +-------+
        |&hello |
     +8 +-------+
        |       |
     +4 +-------+ <- start of pwrite() arguments
        |       |
R13 +-> +-------+

R0 = 1
\end{verbatim}
\caption{Stack and [[R0]] value for a C call to [[pwrite()]]}\label{fig:stack-c-pwrite}
\end{figure}

Note that because the first argument is stored in [[R0]], 
the code generated by [[5c]] for a function call does not
bother to store it also in the stack. But, similar to the
link register optimisation, an extra word in the stack is still allocated
for the first argument in case the callee need to overwrite [[R0]]
in which case it can save its value in the stack.
\l note that like R14 we save extra space in caller without knowing
\l if callee really needs it.

The calling conventions used by [[5c]] could be completely different:
the order of the arguments in the stack could be reversed, 
\l but C variable number of arguments '...' would be harder
more registers could be used to store the first $n$ arguments,
the stack arguments could be ``below'' the stack pointer,
the responsability to manage the return address in the stack
could be done by the callee instead of the caller.
The actual {\em C calling conventions} implemented by [[5c]]
are a nice comprimise between simplicity and speed.

Because most assembly code interoperate with C code,
they can also be {\em assembly calling conventions}.
The only calling convention imposed by Asm5
is the extra word in the stack above [[R13]] to store
the return address to the caller, because of the
code generated for [[TEXT]] and [[RET]] by [[5a]].

\subsection*{Data layout}

The last piece of assembly code we need to explain is Line~49 which initializes
(partly) the content of the [[hello]] global. Indeed, 
even if Line~48 {\em declares} the [[hello]] global with the [[GLOBL]] 
pseudo-instruction, it is the [[DATA]] instruction which {\em defines}
the content of the global. 
%
The operands of [[DATA]] are in order:
\begin{enumerate}
\item the symbol of the global,
possibly with an offset (here [[+0]]), and as always for references to
globals or procedures the [[(SB)]] base

\item a slash followed
by an integer between 1 and 8 representing the size in
number of bytes this [[DATA]] instruction is defining (here [[/6]])
\l but no dollar here, hmmm
 
\item a constant, which can be an integer, a character, or a string of
less than 8 bytes.
\end{enumerate}
\l a bit weird those constraints and conventions

To define data which takes more than 8 bytes, one needs
to use multiple [[DATA]] instructions. For instance
to define completely [[hello]], which would remove the need
for Line~6 to 18 (added for education purpose in this tutorial),
one could have done:

<<full definition of [[hello]] content>>=
GLOBL   hello(SB), $12
DATA    hello+0(SB)/8, $"hello wo"
DATA    hello+8(SB)/4, $"rld\n"
@
%$
\l see data2s also

\l need the antislash z?
%The [[\z]] are the equivalent of [[\0]] in C and represents
%the zero value. They are not 
%        MOVW $'\z', R1
%        MOVB R1, 12(R2)



\section{The ARM architecture}

ARM represents different things. It is
a family of RISC machines, 
a family of instruction set architectures (ISAs), and 
also a family of processors. 
%
But, up until now, and also for the rest of this document, 
when we use the term ARM we mean the {\em ARMv6} instruction set architecture.
Confusingly, ARMv6 is the instruction set
used in the {\em ARM11} 32 bits processor 
family~\furl{http://www.arm.com/products/processors/classic/arm11/?tab=Specifications}.
This family powers many smartphones as well as the Raspberry Pi.
\l ARM1136

Because an assembly language mimics closely the instructions
of a machine, most of the instructions in Asm5
are instructions of the ARM: [[B]], [[BL]], [[SWI]], [[ADD]], etc.
The same is true for the registers [[R0]] to [[R15]].
To fully understand those assembly instructions we refer
to our \book{Emulator}, which describes the semantics of 
the corresponding ARM machine instructions, or to
the ARM reference manual~\cite{arm-refman}.
%
Asm5 introduces also some pseudo-instructions, pseudo-registers,
and virtual instructions, as we have seen in the previous section,
and those will be fully explained in this document.

As said briefly in the introduction, [[5a]] does not
generate machine code, the linker [[5l]] does, 
so there is no need to know the binary format of ARM instructions
to understand this document.
\l opcode format, see 5i/ it's more the job of 5l and optab to do that.

\section{Input assembly language}

We have covered already in Section~\ref{sec:helloworld} 
many features of the assembly language Asm5,
the language used by the input files of the assembler [[5a]].
In this section we summarize those features and
give a more systematic description of Asm5.
We recommend to read though [[assemblers/docs/asm.pdf]] for more
information.
\n but not really more complete information, my tutorial is better
\l this is not a reference manual, but it is enough to help implement
%note: was useful to write this summary, see better now the whole lang/picture
% almost look like a refcard

\subsection*{Lexical elements}

The main lexical elements of Asm5 (and also of Asm9) are:
\n implementer POV
\begin{itemize}
\item {\em integers}, e.g. [[42]]

\item {\em characters}, e.g. [['W']]

\item {\em strings}, e.g. [["hello wo"]]. Strings are limited
to 8 characters or less though.
\l why? meh

\item {\em floats}, e.g. [[4.2]]



\item {\em predefined identifiers} in uppercase, used for 
opcode mnemomics ([[ADD]]), 
registers ([[R0]]), 
pseudo-instructions ([[TEXT]]) and 
pseudo registers ([[PC]])
\l keywords

\item {\em identifiers} in lowercase, used for 
symbols ([[_main]]) and 
labels ([[later]])
\l have to be lowercase?

\item {\em comments}, e.g. [[/* not reached */]], using the same
syntax than C comments, which are ignored

\item {\em spaces} and {\em tabs}, which are also ignored

\item {\em newlines}, which is actually internally transformed in a semicolon.
The semicolon is an instruction {separator} in Asm5. So, one can then either 
write multiple instructions on different lines,
or 
multiple instructions on the same line but separated by an explicit [[;]].

\item {\em operators}, e.g. \$, [[()]], [[/]], [[+]], [[;]], [[<>]], etc,
which have different meanings depending on the context

\end{itemize}
\l also cpp lexical elements

\subsection*{Syntactical elements}

The main syntactical element of Asm5 is the {\em instruction}.
An Asm5 file is made essentially of a list of instructions, usually
one per line. 
An instruction is composed of an {\em opcode}, 
followed possibly by 1, 2 or 3 {\em operands}. 
A line can also contain a {\em label} definition which is an identifier
followed by a colon, e.g. [[later:]].

\subsection*{Opcodes}

Opcodes correspond to different kinds of instructions:
\begin{itemize}
\item {machine instructions}, e.g. [[B]], [[SWI]], [[ADD]]

\item {\em pseudo-instructions}, e.g. [[TEXT]], [[GLOBL]],
also known as assembly directives

\item {\em virtual instructions}, e.g. [[RET]], [[MOVW]], [[NOP]]
which are instructions without a
1-to-1 mapping to a machine code instruction, but which
are convenient for the programmer (or compiler writer).
They can hide some architecture restrictions or peculiarities. 
\l makes asm a bit more portable
\end{itemize}

\subsection*{Operands}

Depending on the opcode, different kinds of operands are possible:
\begin{itemize}
\item {\em constants}, which in Asm9 are always prefixed with a dollar,
e.g. \$42, \$[['W']]
\l why? to avoid ambiguity with what? otherwise offset like 32(SP) have no dol

\item {\em registers}, named [[R0]] to [[R15]] in Asm5

\item {\em pseudo-registers}, named [[PC]], [[SP]], [[FP]], and [[SB]]
in Asm9

\item {\em label references}
\l B xx vs B(SB)

\item {\em memory references}, which we describe below

\end{itemize}

\subsection*{Addessing modes}

Memory references appear mainly in branching
instructions (e.g. [[BL]]), memory moves (e.g. [[MOVW]]),
as well as in entity definitions (e.g. [[TEXT]]).
%
There are multiple ways to reference memory in Asm5,
called {\em memory addressing modes}:
\begin{itemize}

\item {\em indirect}, using [[()]] around a register or
pseudo-register, e.g. [[(R1)]], which means
the content at the address {denoted} by [[R1]]

\item {\em indirect with offset}, e.g. [[4(R1)]],
which means the content at the address denoted by [[R1]]
plus 4. Note that there is no prefixing dollars for offsets.

\item {\em symbol reference}, which is always written as ``an offset''
to a pseudo-register, e.g. [[hello(SB)]],
which means the content at the address denoted by the symbol
[[hello]].
With [[SB]] the symbol denotes a global or procedure,
with [[SP]] a local variable, and 
with [[FP]] an argument.
\l and PC?
\l for Text, data, param, locals

\item {\em symbol reference with offset}, e.g. [[hello+4(SB)]],
which means the content at the address denoted by the global symbol
[[hello]] plus 4.
\l p plus 0(FP) is a comment

\item {\em symbol address}, using \$ before the symbol,
e.g. \$[[hello(SB)]], which means the address of the symbol
[[hello]].

\l and weird stuff with slash   hello _plus_ 0(SB)/6

\end{itemize}

Note that Asm9 uses a left-to-right assignment syntax for moves,
\l AT&T syntax, normal
so [[MOVW (R1), R2]] means moving the content at
the address denoted by [[R1]] into [[R2]].

\t note TEXT has actually an operand and it is a memory reference :)
\l take some examples, e.g. start-KZERO(SB), and explain? see comment in .tex
\l will see later also local symbol, with angle operator
%concepts: 
% - external symbols = fully unresolved! will be resolved at linking time
%   but needs to keep the name in the symbol table and the place where it
%   was referenced
%   (note that external entities are not even declared, any use of a symbol
%    not defined in the file is an external reference)
%    less: maybe this should be fixed, easy to make a typo)
%
% (LONG is a macro?)
%        LONG    $-(0x1BADB002 + 0x00010003)     /* checksum */
%vs
%        LONG    $_start-KZERO(SB)          /* load_addr */
%
%why need SB in second case? because it refers to symbol in certain section?
% it's to take the address of _start symbol in SB and adjust
% by removing KZERO to it. tricky. It's really $  _start(SB) - KZERO
%
% it does not have extern declaration, but any ref is implicitely
% an extern.

\l section{Runtime conventions}? hmm more compiler specific

\subsection*{Advanced features}

Asm9 has a few more features beyond mnemonics and symbolic addresses:
\begin{itemize}
\item {\em constant  expressions} as operands, e.g. \$[[1<<6|3]],
which are evaluated at {assembly time}.

\item an embedded {\em macro-processor} similar to [[cpp]] with
features such as [[#include]] and [[#define]]. [[5a]] is thus
what people calls a {\em macro-assembler}.
%
This, combined with the previous feature, allows to overcome
some of the original limitations of [[5a]]. Indeed, even if [[5a]]
does not support any mnemonic for some of the advanced
{coprocessor} ARM instructions, one can simply define and use
this macro instead:

<<macro MCRR>>=
#define MCRR(coproc, op, rd, rn, crm) \
   WORD $(0xec400000|(rn)<<16|(rd)<<12|(coproc)<<8| \
          (op)<<4|(crm))

@
%$

which encodes the binary format of the instruction directly.
%
We will not explain though in this book the code related
to this embedded macro processor as we will explain
similar code in the \book{Compiler}.
\l but compiler book is already big, maybe better do it here?

\item {\em symbolic constants}, e.g. [[TMP = 11 ... MOV R1, R(TMP)]],
which were called originally (and ironically) {\em variables}.
Because they are redundant with the macro-processor, 
this feature has been removed from our version of [[5a]].
\l use LVAR for lexeme name, hmmm

\end{itemize}

\l those are the most common features, we describe more advanced later as needed

\section{Output object format}

As said in the introduction, The {object files} generated by [[5a]],
which use the [[.5]] filename extension,
are ARM-specific, but they do not contain really machine code. Instead
an object file contains the {serialized form} of the 
{abstract syntax tree} of the assembly source. 
The actual machine code generation is performed by the linker [[5l]].
\t why better? because anyway cant resolve everything, and patch is complicated
\t so simpler work on the original abstract syntax tree
\n ocamlc does that too!

Because an Asm5 file is essentially a list of instructions,
its serialized form is simply a concatenation of serialized instructions.
The resolution of label addresses is done by the assembler,
so label definitions do not need to be serialized.
Label references in branching code are transformed in
concrete offsets to the [[PC]] pseudo-register.

A serialized instruction has also a pretty simple format
since all instructions have the same form: an opcode followed by
0 to 3 operands.
%
One byte is enough to encode the opcode
on the ARM since there are less than 256 ARM opcodes (or pseudo-opcodes)
since the ARM is a RISC machine ([[8a]] needs 2 bytes to represent
an x86 opcode).
%
Another byte is used to encode the {\em kind} of the first operand
(an integer constant, a register, nothing, etc) followed by
a serie of bytes encoding the actual operand information 
(e.g. 4 bytes for an integer constant, 1 byte for the register number, etc).
%
The complete format is described precisely in Chapter~\ref{chap:generation}
%but Figure~\ref{fig:dotfive-format} 
but Figure~\ref{fig:object-format} describes roughly the content 
of an object file.

\begin{figure}[!]\centering
\begin{verbatim}
|                  |
+------------------+
|    Opcode        |
|                  |
+------------------+  <--- start of second instruction
|        .         |
|        .         |  <--- operand 2 encoded value
+------------------+
|  Operand 2 kind  |
|     (1 Byte)     |
+------------------+
|        .         |  <--- operand 1 encoded value
|        .         | 
+------------------+
|  Operand 1 kind  |
|     (1 Byte)     |
+------------------+
|        .         |
|        .         |  <--- instruction metadata 
|        .         |       (e.g. line number) 
+------------------+
|     Opcode       |  
|    (1 Byte)      |
+------------------+  <--- start of the .5 file 
\end{verbatim}
\caption{File format of [[.5]] object file}\label{fig:object-format}
\end{figure}

\t symbol table about unresolved? imported and exported? at the end of file
\t actually use a very special encoding scheme, see sectionXX

%ocaml: just marshall the ADT, and unmarshall in linker => shorter code!
%update: hmm but the format is actually not that complicated, so we may win
% but not that big probably. Also nice to have a format that other programs
% coded in different languages can read.

\section{Code organization}

Table~\ref{tab:code-orga} presents a short description
of the source files used by [[5a]], 
the main entities (structures, functions, globals, etc) the file defines,
and the corresponding chapters in this document in which the code
contained in the file is discussed.
\n sorted by chapters, make more sense than sorted by dir

There are multiple assemblers in \plan, one per supported architecture
(ARM and x86 in our \plan fork). The generic code has been
factorized in the [[assemblers/aa/]] directory. 
\l and common.out.h
The ARM-specific code is in [[assemblers/5a/]] 
as well as in [[include/arch/arm/5.out.h]]
(and for x86 in [[assemblers/8a/]] and [[include/arch/386/8.out.h]]).

\begin{table*}[tbh!]
\begin{tabular}{llllr}
\toprule
{\bf File} & {\bf Description} & {\bf Entities} & {\bf Chapters} & {\bf LOC} \\
\otoprule
[[aa/aa.h]] & Symbol table and input related structures & [[Sym]], [[Htab]], [[Fi]], [[Io]] & \ref{chap:core-ds}, \ref{chap:input} & 243 \\
%, [[Hist]]
[[include/.../5.out.h]] & ARM opcodes, operand kinds, registers & [[Opcode]], [[Operand_kind]],  & \ref{chap:core-ds} & 300 \\
 & & [[Register]] & & \\
[[5a/a.h]] & ARM operand & [[Gen]] & \ref{chap:core-ds} & 103 \\
% why not put in 5.out.h too? could be reused by linker and compiler?

\midrule

[[aa/globals.c]] & Generic globals (e.g. output filename) & [[hash]], [[symb]], [[outfile]],   & \ref{chap:main} & 97 \\
 & & [[pass]], [[pc]] & & \\

[[5a/globals.c]] & ARM-specific globals & [[nullgen]] & \ref{chap:main} & 7 \\


[[5a/main.c]] & Main entry point and main functions & [[main()]], [[assemble()]],  & \ref{chap:main}, \ref{chap:generation} & 492 \\
              & & [[outcode()]] & & \\
% (I created this file)

\midrule

[[aa/lexbody.c]] & IO and Lexing utilities & [[yyerror()]], [[newfile()]] & \ref{chap:input} & 664 \\ 
% also lookup(), hmmm


[[5a/lex.c]] & Lexer for Asm5 (not using Lex) & [[yylex()]] & \ref{chap:lexing} & 570 \\

[[aa/macbody.c]] & Macro processing (embedded [[cpp]]) & [[macdef()]], [[macinc()]] & \ref{chap:preprocessing} & 867 \\
 & & [[macexpand()]] & & \\
% mac = macro (not macos :)

[[5a/a.y]] & Yacc grammar for Asm5 & [[yyparse()]], [[inst()]] & \ref{chap:parsing} & 599 \\
% (and calls to outcode)


\midrule

[[aa/utils.c]] & Memory allocation, error managment & [[alloc()]], [[errorexit()]] & \ref{chap:error}, \ref{chap:libc} & 84 \\
% use outfile global in globals.c, use yyerror() (I created this file)

[[aa/compat.c]] & System function wrappers for compatibility & [[mycreat()]], [[mywait()]] & & 50 \\
%todo: to delete at some point?
 & with \unix & & & \\

\midrule
[[include/.../common.out.h]] & IEEE float structure & [[Ieee]] & \ref{chap:advanced} & 22 \\
% and NSYM constant

\otoprule
Total & & & & 4098 \\
\bottomrule
\end{tabular}
\caption{Source files of [[5a]]}
\label{tab:code-orga}
\end{table*}
\n see SRC_VIEWS in the Makefile, and make loc
\l could have a input.c and output.c

\section{Software architecture}

Figure~\ref{fig:controlflow} describes roughly 
the main control flow of [[5a]], while
Figure~\ref{fig:dataflow} describes 
the main data flow of [[5a]].

\begin{figure}[!]\centering
\begin{verbatim}
            +-------------+         
            |    main     |         
            +------+------+         
                   |                
                   |                
            +------v------+         
            |  assemble   |         
            +----+--+-----+         
                 |  |               
                 |  |               
            +----v--v-----+         
            |  yyparse    | (Parser)        
            +---+-------+-+         
                |       |              
       +--------+       +-------+      
       |                        |      
+------v-------+         +------v-----+
|   yylex      | (Lexer) |  outcode   | (Object code generator)
+------+-------+         +------------+
       |                            
       |                            
+------v-------+                    
|    macxxx    | (Preprocessor)                   
+--------------+                    
\end{verbatim}
\caption{Control flow diagram of [[5a]]}\label{fig:controlflow}
\end{figure}
\l add chapter ref in the box? next to the box?
%ocaml: if the code was more functional the diagram would be just a pipeline!
\n alternative with cclean? not that important so better to remove it


\begin{figure}[!]\centering
\begin{verbatim}
assembly file -> tokens -> instructions -> object file
                (use global symbol table)
\end{verbatim}
\caption{Data flow diagram of [[5a]]}\label{fig:dataflow}
\end{figure}
\l focus on components instead? Lexer->Preprocessor->Parser->Generators?


After some basic command line processing and initialisations,
the function [[main()]] calls [[assemble()]] with the name
of the assembly file to process. 
%
[[assemble()]], after further initialisations,
uses then a two-pass algorithm and so calls 
[[yyparse()]], the function generated by Yacc from the Asm5 grammar,
two times. Doing so, it also modifies the global [[pass]]: for the first
call to [[yyparse()]] the value of [[pass]] is 1, and for the second
call the value of [[pass]] is 2.

The {parsing} function [[yyparse()]] internally calls the lexing
function [[yylex()]] to get the next {\em token} from the input file.
[[yylex()]] is usually generated by Lex from a set of 
{regular expressions}, but in the case of [[5a]] was handcoded.
\l why?
[[yylex()]] itself calls {macro-processing} related functions,
e.g. [[macinc()]] (for ``macroprocessing include''), as [[5a]] 
is a macro-assembler supporting [[cpp]] directives such as [[#include]].

From a set of tokens, [[yyparse()]] can parse using
different {\em grammar rules}
a constant,
an expression, 
an operand, 
an opcode, 
an instruction,
and finally a set of instructions.
%
The Yacc {\em actions} associated with those grammar rules
gradually build and return abstract syntax trees (ASTs) of
subparts of an instruction.
\l not really trees though
See~\cite{lexyacc} for more information on Yacc grammar rules
and actions.
Once a full instruction
has been parsed, via the [[inst]] grammar rule,
the yacc action for [[inst]] is triggered,
which calls the function [[outcode()]] with the AST of the 
parsed instruction.
\l actually 5 subASTs arguments but they represent the AST
% 5a abuse tokens and the grammar to do some computations (classic old style)
%ocaml: could return full AST, list of instr and then outcode of that.

[[outcode()]] outputs then the serialized form of the instruction AST
in the object file, but only when the global value of [[pass]] is 2.
Whatever the value of [[pass]], [[outcode()]]
also increments each time [[pc]], a global representing the
current value of the (virtual) program counter.

The lexing and parsing code internally use and modify a symbol
table called [[hash]], which keeps track of the value
of different kinds of identifiers, for instance labels.
%
During lexing, when a new identifier is encountered, a new
symbol in the {\em symbol table} [[hash]] is created. 
%
During parsing, once the identifier is recognized as
a label, because it is followed by a colon token,
its {\em type} in the symbol table is changed to a label type, 
and its value is set to be the current value of the global [[pc]].
%
During the second pass, any reference to this label 
can be resolved by looking at the value of the label in the symbol
table.

\n talk about cclean? maybe not that important, a big ugly, no need AEND

\l relation with other tools? 5c, 5l? easy, do git grep, see comment .tex
% git grep AADDB
%assemblers/8a/lex.c:    "ADDB",		LTYPE3,	AADDB,
%compilers/8c/peep.c:    case AADDB:	/* rhs rar */
%compilers/8c/reg.c:        case AADDB:
%compilers/8c/txt.c:            a = AADDB;
%include/386/8.out.h:    AADDB,
%linkers/8l/optab.c:    { AADDB,	yxorb,	Px, 0x04,0x80,(00),0x00,0x02 },

\l Symbol table assembler, and symbol table in object file! in/out.

\l Depends libc, libio

%\section{Bootstrapping}
% 5a is actually written in C :) not even asm! and also use yacc
% bootstrap from scratch? punch card, hex-to-c, assembler in assembler, asm in C

\section{Book structure}

We now have enough background to understand the source
code of [[5a]]. The rest of the book is organized as follows.
%
We will start by describing the core data structures of [[5a]]
in Chapter~\ref{chap:core-ds}. 
%
Then we will use a top-down approach in Chapter~\ref{chap:main} and 
starting from [[main()]] we will present the code of the main 
functions, e.g. [[assemble()]].
%
The following chapters will be dedicated to describe
the main components of the assembling pipeline:
Chapter~\ref{chap:input} will present the input routines,
Chapter~\ref{chap:lexing} the lexer,
Chapter~\ref{chap:preprocessing} the preprocessor,
Chapter~\ref{chap:parsing} the parser,
and finally Chapter~\ref{chap:generation} the object code generator.
%
In Chapter~\ref{chap:debugging} we will describe the code
responsible for adding debugging support in [[5a]], which
for instance add line information in the object code. 
One can then know, when debugging a binary program,
to which original line and which source file an
instruction in the binary comes from, or what is the
original name of the procedure containing a specific
machine instruction.
%
Chapter~\ref{chap:advanced} presents advanced
assembly features which we did not present 
before to simplify the explanations, for instance
the support for floats. Those features tend to crosscut
many components with extensions to the lexer, the parser,
and the code generator.
%
Finally Chapter~\ref{chap:conclusion} concludes.

Some appendices present the code for non-functional properties,
e.g. code to help debug [[5a]] itself in 
Appendix~\ref{chap:debugging-appendix}, or to manage
errors in Appendix~\ref{chap:error}.




\chapter{Core Data Structures}
\label{chap:core-ds}

\begin{verse}
\begin{flushright}
  {\it Show me your code and conceal your data structures, and I shall
    continue to be mystified. Show me your data structures, and I
    won't usually need your code; it'll be obvious.\\
    ~\\
    Fred Brooks}
\end{flushright}
\end{verse}
\n actually I think the original quote is with "flowchart" and "tables"

In this chapter we will present the core data structures used by [[5a]].
The first three sections contain the definitions
of the different components making together the abstract syntax tree (AST) 
of an instruction:
the opcode, 
the register (which is a kind of operand),
and the other kinds of operands.
\l internal memory representation of assembly textual instructions!
Then we will see how tokens are represented.
Finally we will present the symbol table which is
a central data structure used by the lexer, the preprocessor, the parser,
and the object code generator.

\section{[[Opcode]]}
\label{sec:opcode}

All Asm5 instructions (machine, pseudo, and virtual) have an opcode
defined in [[include/arch/arm/5.out.h]] by the following type:
\n used to be just 5c/5.out.h

<<enum opcode(arm)>>=
// coupling: with 5c/enam.c
enum opcode
{
    AXXX,

    ANOP, // VIRTUAL removed by linker
    // ---------------------------------------------------------
    // Arithmetic and logic opcodes
    // ---------------------------------------------------------
    <<logic opcodes>>
    <<add/sub opcodes>>
    <<mul/div/mod opcodes>>
    <<bitshift opcodes>>
    // works with the branching opcodes
    <<comparison opcodes>>
    // ---------------------------------------------------------
    // Branching opcodes
    // ---------------------------------------------------------
    <<branching opcodes>>
    // ---------------------------------------------------------
    // Memory MOV opcodes
    // ---------------------------------------------------------
    <<mov opcodes>>
    <<swap opcodes>>
    // ---------------------------------------------------------
    // Syscall
    // ---------------------------------------------------------
    <<interrupt opcodes>>
    // ---------------------------------------------------------
    // Float opcodes
    // ---------------------------------------------------------
    <<float mov opcodes>>
    <<float arithmetic opcodes>>
    // ---------------------------------------------------------
    // Pseudo opcodes
    // ---------------------------------------------------------
    <<pseudo opcodes>>

    ALAST,
};
@
\t rename Opcode? use uppercase for enum too?
\l why Axxx? Assembly?
%old: was called 'enum as'
%note: I reordered a lot the original opcodes. Note that it can be dangerous
% for backward compatiblity to do so. Indeed 'ld' and 'as' need to agree
% with each other; one can't use a library compiled (or cross compiled) 
% using a 5l relying on a certain order, and link object files compiled 
% by a 5a relying on another order. So can have some subtle errors if
% want to play with what is cross-compiled! So make sure to recompile your
% libc if you modify 5l or 5a or 5.out.h

\n the enum must contain less than 256 elements, as we rely on 
\n  sending ANAME as a byte in zname(), and all opcode as a byte in zaddr()
\n the order of the opcode below does not have to match the opcode order
% (Actually I have reordered them to be more logical
% e.g. AND, ORR, EOR are closer together.)
% the actual binary code generation is done in the linker
%less: Could analyze *.s in plan9 and do some stats? or use cg on the
%  whole plan9 and see how much AXXX is used

The opcodes follow closely the instruction set (ISA) of the ARM
(see the \book{Emulator}), e.g. [[ASUB]] for the [[SUB]] machine instruction.
They have been divided in different categories: 
arithmetic and logic, 
branching, 
memory,
system, 
and float.
Moreover, Asm5 introduces pseudo opcodes for the pseudo-instructions.
The different opcodes will be presented gradually in this
document.

The [[AXXX]] opcode represents the {\em invalid opcode}. It is put in
first position in the enumeration probably as a form of defensive programming.
%ocaml: ugly, should not need that if had strong enum case checker
[[ALAST]] is an {\em end marker}: a C idiom which makes it easy to loop
over all the opcodes or to declare an array of opcodes.
%
[[ANOP]] is a {virtual instruction} removed by [[5l]]. It is
occasionally used by the assembly generator in [[5c]] to
represent an instruction without any effect.
\l not clear why need that at all, but USED and profiler might use that?
\l also RET, MOV, SLL, BEQ, etc.
\l no PUSH/POP? stack is sugar over MOV with specific conventions.

\section{[[Register]]}
\label{sec:register}

ARM has 16 registers named [[R0]] to [[R15]].
They are represented simply by an integer in [[5a]]: 
0 is [[R0]], 1 is [[R1]], etc.
%ocaml: a big ugly because then have the issue with R_NONE
The following type introduces some convenient names for some of the
{special registers} we have seen before:

<<enum regxxx(arm)>>=
enum registr {
    <<[[regxxx]] compiler conventions cases>>
    REGSB =		12, // static base

    REGSP =		13,
    REGLINK =	14,
    REGPC =		15,

    NREG = 16,
};
@
\n can not use register, it is a reserved keyword

Again, [[NREG]] is not a register but an end marker. 
One can then easily declare an array with all ARM registers
with [[int allregs[NREG];]].
%
Note than [[REGSB]] is not a special ARM register;
it is reserved though by the assembler and linker for a special use.
\t ref to section that explain more REGSB
\l REGSB is new! Machine.nw does not have it.

\t REGFP? not in ARM, but 5a has a fake register LFP (not sure
\l which actual register will be used for it though)

There are few situations where something, e.g. an operand,
can be a register or {nothing}. We can not use 0 to represent nothing since it
is used already to encode [[R0]]. Instead, the following
constant represents nothing:

<<constant R_NONE(arm)>>=
#define R_NONE 16
@
%old: NREG used to represent NONE in the outcode reg param; I prefer R_NONE
%ocaml: None

The ARM has also 
float registers, 
coprocessor registers, and 
status registers, 
but they will be introduced later.
\n Fxxx, Cxxx, PCR (and FPCR)


\section{[[Operand]]}
\label{sec:operand}
\t rename Gen to Operand so better section name
\t Why Gen anyway? gen rule in grammar. General opd? generic? 
\n =~ Adr of Linker. 

A register is only one kind of operand.
Constants (integers, floats, or strings) are another kind.
The following type is used to represent all kinds of operands: 

<<struct Gen(arm)>>=
struct	Gen
{
    // enum<operand_kind>
    short	type;

    union {
        long	offset; // offset or generic value
        double	dval;
        char	sval[8];
    };
    // option<enum<registr>>, None = R_NONE
    short	reg;

    <<[[Gen]] other fields>>
};
@
%old: I introduced the union? can have it? operand_kind will be good enough?
%ocaml: An ADT would be far better than this enum, D_NONE, and separate Sym 
% type operand = 
%  | D_REG of register // and offset?
%  | D_CONST of int
%  | D_OREG of register * offset
%  | Branch of offset (PC)
%  | Extern of name * offset (SB) ?
%less: maybe by playing with Literate Programming I can reproduce a kind of ADT?
% e.g. by introducing LSREG, and then the part of the enum register related
% to LSREG?
% type instr = 
%  | TEXT of name * attribute list * int (* locals *)
%   ...
% type reg = 
%   ...

The [[type]] field is used to encode the {\em kind} of the operand.
It is a [[short]] but really it can only take values of the
[[operand_kind]] enumeration we define below 
(hence the {\em typing} comment above):

<<enum operand_kind(arm)>>=
enum operand_kind {
    D_NONE,

    D_CONST,
    D_SCONST,
    D_FCONST,

    D_REG,
    <<operand_kind cases>>
};
@
\l why Dxxx prefix? 
%dead: D_GOK, D_ADDR (valid for x86 but unused for arm)/* type/name */ for GOK
%note: I reordered again a lot things, which like for opcode has some impact
% on 5l. Now D_REG, D_CONST, D_SHIFT are closer (to mimic imsr rule).
%See Dconv in Linker for dumper (which can help to undertand things too)

The union in [[Gen]] represents the {\em value} of the operand, which has to 
be interpreted in different ways depending on the kind of the 
operand: 
for integer constants ([[D_CONST]]) the [[offset]] field is used,
for string constants ([[D_SCONST]]) the [[sval]] field,
and for float constants ([[D_FCONST]]) the [[fval]] field.
Remember that characters are converted in integers so
there is no need for a [[D_CHARCONST]] and [[cval]] field.
%
The [[long]] element of the union is called [[offset]],
and not [[lval]], because it is (ab)used to represent
different things, not just integer (or character) constants,
as we will see soon.
%ocaml: ugly

The [[D_NONE]] case is used only at the beginning, when initializing
a new operand in [[nullgen()]], and should be used to represent
an operand which has not be defined yet.
%
[[D_REG]] is used to represent register operands. In that
case it is the [[Gen.reg]] field which encodes
the actual register.
\l could use offset? no because can also have offset(reg)

For indirect operands, e.g. [[(R1)]], 
or indirect with offset operands, e.g. [[4(R1)]]
the following case is used:

<<operand_kind cases>>=
D_OREG,
@

In those cases the register is encoded in the [[Gen.reg]] field,
and the optional offset in [[Gen.offset]] (hence the name).
\l an example follow below
\l offset is abused for many things, see the comment in .tex
% - offset
% - constant
% - register for REGREG
% - bitset of register for MOVM
% - ??
%less: rename offset? to generic_value? or generic_long? or lval?
% but it's true in many places it's used to encode an offset to
% a base (a reg, a name).
% e.g. for D_SHIFT the long is used really to encode the whole
% thing with some bits for the shift kind, some bits for the register, etc.
% see the many uses cases of offset in zaddr() switch about operand_kind ...
%mimic what is in union token too


\section{Instructions}
%    outcode(AEND, Always, &nullgen, R_NONE, &nullgen);

There is no type to represent the full AST of an instruction.
Instead, multiple parameters of the [[outcode()]]
functions are used to pass the different components
of an instruction. Here is the signature of [[outcode()]]:
%ocaml: could define a record
\l =~ Prog of Linker (but without opcode)?

<<signature outcode(arm)>>=
void	outcode(int opcode, int cond, Gen* opd1, int reg, Gen* opd3);
@

Here is an example of use of [[outcode()]] to output
the serialized form of the instruction [[SUB $14, R2, R3]]:
%$
%EXAMPLE:
\begin{verbatim}
Gen operand1 = { .type = D_CONST; .offset = 14; ...};
Gen operand3 = { .type = D_REG;   .reg = 3; ... };
outcode(ASUB, Always, &operand1, 2, &operand3);
\end{verbatim}

The [[Always]] constant and the second parameter of [[outcode()]]
are used to represent the {\em conditional execution} of an instruction.
It is an ARM feature we will explain later in Section~\ref{sec:cond-exec}
(and in the \book{Emulator}).
%
The fourth parameter is an integer and not a [[Gen*]] because
when ARM instructions have 3 operands, the middle one is always
a register, so an integer is enough.
Depending on the number of operands, here are the constraints on 
the value of those parameters:
\begin{itemize}
\item 0 operand: [[opd1]] and [[opd3]] are [[NULL]], [[reg]] is [[R_NONE]]
\item 1 operand: [[opd3]] is [[NULL]], [[reg]] is [[R_NONE]]
\item 2 operands: [[reg]] is [[R_NONE]]
\item 3 operands: no constraint, every parameter is used
\end{itemize}

\l speak now about the 2second register which is abused for: TEXT/DATA attr?

\section{Tokens and [[itab]]}
\label{sec:token}

The Yacc-based parser of [[5a]], called via [[yyparse()]],
is taking as input a set of {tokens}.
Those tokens are returned by the [[yylex()]] function, but
their type is defined by a set of {\em Yacc directives}
in the Yacc grammar [[5a/a.y]].
Again, see~\cite{lexyacc} for more information on Yacc.
Here are the directives to declare the names of those
tokens as well as the type of value they hold:

<<token declarations(arm)>>=
/* opcodes */
%token  <lval>  LDEF LDATA LWORD LEND
%token  <lval>  LARITH LCMP LBRANCH LBCOND LMOV LSWAP LSWI LRET
%token  <lval>  LSYSTEM LMISC
%token  <lval>  LARITHFLOAT LCMPFLOAT  LMULL LMULA  LMOVM LMVN
/* registers */
%token  <lval>  LPC LSP LFP LSB
%token  <lval>  LR LREG  LPSR
%token  <lval>  LF LFREG  LFCR 
%token  <lval>  LC LCREG
/* constants */
%token  <lval>  LCONST 
%token  <dval>  LFCONST
%token  <sval>  LSCONST
/* names */
%token  <sym>   LNAME LLAB
%token  <sym>   LVAR
/* bits */
%token  <lval>  LCOND
%token  <lval>  LS LAT
@
\l Lxxx for? lexeme?
%dead: LTYPEX LTYPEF LTYPEG LTYPED
%old: used to be LTYPE1 LTYPE2 LTYPEI etc, but better to give clearer names
%TODO: rename LTYPEXXX by T_END, T_TEXT, etc? L_ARITH? L_CMP L_MOV L_SWAP

Those directives are a bit complicated but things will be clearer
when we describe the Lexer in Chapter~\ref{chap:lexing}.
To understand those directives it can be useful to look at
the generated code and how tokens are internally represented.
A token is really a pair composed of:

\begin{itemize}
\item a {\em code}, which is an integer representing
the kind of the token. 
Based on the directives above, Yacc will generate a [[y.tab.h]]
header file where all the token names are assigned a code.
See an excerpt of this file below.
For instance 
57346 represents all arithmetic mnemonics tokens (e.g. [[ADD]], [[SUB]], etc),
57353 represents the token for the [[RET]] mnemonic, and 
57381 represents all integer tokens.
%

\item a {\em value}, which is represented by a union we will describe below.
Depending on the kind of the token, the value can be 
an integer (e.g. for integer tokens), 
a float (e.g. for float tokens), 
or something else.
For instance for the arithmetic mnemonic tokens,
represented by the code 57346 and the token name [[LARITH]], 
the value will be the opcode corresponding to the actual mnemonic
(e.g. [[ASUB]] for [[SUB]]), which is an enumeration case.


\end{itemize}

Here is an excerpt of the [[y.tab.h]] file generated by Yacc:

<<5a/y.tab.h excerpt>>=
...
#define	LARITH	57346
...
#define	LSWI	57352
#define	LRET	57353
...
#define	LCONST	57381
#define	LFCONST	57382
...
@
%ocaml: ugly sugar, would be simpler have a simple ADT hiding all this shit

The value of those integers is high to not conflict with
the value of regular {unicode} characters. Indeed [[yylex()]]
can return single-character tokens in which case there is no
need to give them a name.
\l see Yacc. typedef Rune token_code; so plan9 lex is unicode aware? ulex?

Here is the union representing the different kinds of values
a token can hold:

<<union token(arm)>>=
%union {
 // long for LCONST
 // and enum<opcode>  for LARITH/...
 // and enum<registr> for LREG/...
 // and enum<cond>    for LCOND
 // and ...
 long   lval;

 double dval;    // for LFCONST
 char   sval[8]; // for LSCONST
 Sym    *sym;    // for LNAME/LLAB/LVAR

 <<[[Token]] other fields(arm)>>
}
@
\t mutual ref with sym here where sym has itself a type that is the token_kind
\l could use NSNAME here instead of char sval[8] ? and at a few other places?
\l note that 8, here is the restriction on 8bytes strings

Again this directive is a bit complicated but things will be clearer
later. The name of those fields, e.g. [[lval]], are actually
referenced in the \%[[token]] directives above.
For instance \%[[token  <lval>  LCONST]] indicates that
the [[LCONST]] tokens will use the [[lval]] field of the union
to hold their values.
\t will see Sym later
\l this is used to typecheck things in Yacc.

Another important data structure related to tokens
is the [[Itab]] structure and the global [[itab]]:

<<struct Itab(arm)>>=
struct Itab
{
    char	*name;

    //enum<token_code>
    ushort	type;
    //enum<opcode|registr|...> | int
    ushort	value;
};
@
\t why Itab? Instruction table? it's not just for instruction
\l  fregisters|sysregisters|sym_kind(pseudo-register) |operand_kind||...
%ocaml: ADT again would be better than union and this

<<global itab(arm)>>=
// map<string, (token_code * token_value)>
struct Itab itab[] =
{
    "NOP",		LMISC, ANOP,
    <<[[itab]] elements>>
    0
};
@

They map the predefined identifiers of Asm5, e.g. [[NOP]], [[PC]], etc,
to their corresponding token, which as we have seen before
is a pair of token code and token value.
%
Elements of the [[itab]] array will be revealed gradually
in this document but the first entry is shown above for [[NOP]].
\l was LTYPEI, now LMISC, but should be LNOP? and then a nop grammar rule?
\t in yylex when parse an identifier, looks in itab if equal string
\t in which case return the appropriate token

\l actually this array is used in xinit to populate hash table of symbols
\l so it's fast.

\section{[[Sym]]bols and [[hash]] table}
\label{sec:sym}

One of the main job of an assembler is to manage symbols
and to resolve symbolic addresses. 
The {\em symbol table} is thus a central data structure
used by [[5a]]. 
The structure below represents a symbol. It essentially
associates a {name} to a {value}:

<<struct Sym>>=
struct	Sym
{
    // Sym is (ab)used to represent many things in the assembler:
    //   symbols, labels, but also macros, opcodes, registers, etc

    // ---------------------------------------------------------
    // The "key"
    // ---------------------------------------------------------
    // ref_own<string>
    char	*name;

    // ---------------------------------------------------------
    // The generic "value"
    // ---------------------------------------------------------
    long	value; 

    <<[[Sym]] identifier value fields>>
    <<[[Sym]] macro value fields>>
    <<[[Sym]] lexeme value fields>>

    // ---------------------------------------------------------
    // Extra
    // ---------------------------------------------------------
    <<[[Sym]] extra fields>>
};
@
%archi: value is a vlong in va/
\n there is no symkind here, this is stored outside the Sym

For instance, the label [[later]] in the [[hello world]] program 
Section~\ref{sec:helloworld}, once resolved, could
be represented by the following [[Sym]]: 
%EXAMPLE:
[[{ .name = "later"; .value = 3; ... }]] as
the label is defined before the 3rd instruction in the program.
\l virtual PC!

The symbol table itself is represented by a global {hash table}
called [[hash]]. It makes sense to use a global because
the symbol table will be accessed by different components
of the assembler pipeline, e.g. the lexer and parser.
%ocaml: actually could pass table in lex to yacc.
One way to implement a hash table in C is to use a big array
of lists, also known as an array of buckets:

<<global hash>>=
// hash<string, ref_own?<Sym>>, (next in bucket = Sym.link)
Sym*	hash[NHASH];
@
\t diff with h?
<<constant NHASH>>=
#define	NHASH		503
@
\l choose as a prime, see below

One way to implement a list of something in C is to embed in
this something a [[link]] field pointing to the next
element in the list:

<<[[Sym]] extra fields>>=
// list<ref<Sym>> (next = Sym.link) bucket of hashtbl 'hash'
Sym*	link;
@
\t what is the head? hash! and also h?

The end of the list is represented by the null pointer:

<<constant S>>=
#define	S	((Sym*)nil)
@

%FIGURE? or standard C idiom?

The main interface to the symbol table are the
functions [[slookup()]] and [[lookup()]] which
both internally uses the global [[hash]].
\l hmm so could hash be a semi global and used only by lookup?
[[slookup()]] given a name returns the [[Sym]] in the
symbol table [[hash]] associated with this name, or
a new symbol if the name was not found:

<<function slookup>>=
Sym*
slookup(char *s)
{

    strcpy(symb, s);
    return lookup();
}
@
\l cleaner interface at least

It internally modifies the global [[symb]] 
(used also by [[yylex()]] as we will see later) 
before calling [[lookup()]].
%ocaml: globals are bad, slookup cleaner than lookup, should not need symb

<<global symb>>=
char	symb[NSYMB];
@
<<constant NSYMB>>=
#define	NSYMB		500
@
%old: was //#define	NSYMB		8192 on arm, not sure it matters

<<function lookup>>=
Sym*
lookup(void)
{
    Sym *sym;
    long h;
    char *p;
    int c;
    int len;

    <<[[lookup()]] compute hash value [[h]] of [[symb]]>>

    c = symb[0];
    // lookup(sym->name, h, hash)
    for(sym = hash[h]; sym != S; sym = sym->link) {
        // fast path
        if(sym->name[0] != c)
            continue;
        // slow path
        if(memcmp(sym->name, symb, len) == 0)
            return sym;
    }
    <<[[lookup()]] if symbol name not found>>
}
@
%old: s/s/sym/, s/l/len, less confusing I think
\l standard way to use a hash table, so we don't elaborate

The code is using standard C idioms to iterate over a hash table.
Note that if the symbol is not found in the symbol table,
a fresh symbol is created and added in the hash table:

<<[[lookup()]] if symbol name not found>>=
sym = alloc(sizeof(Sym));
sym->name = alloc(len);
memmove(sym->name, symb, len);

// add_hash(sym, hash)
sym->link = hash[h];
hash[h] = sym;

syminit(sym);
return sym;
@

The hashing code iterates over the characters in [[symb]]
until the end character (0) and also compute the length
of the symbol in [[len]]:

<<[[lookup()]] compute hash value [[h]] of [[symb]]>>=
// h = hashcode(symb)
h = 0;
for(p=symb; c = *p; p++)
    h = h+h+h + c;
len = (p - symb) + 1;
if(h < 0)
    h = ~h;
h %= NHASH;
@


The symbol table [[hash]] and [[Sym]] are used (some could say abused) to 
represent and keep track of many different things in [[5a]]:

\begin{itemize}
\item {\em labels}, e.g. [[later:]], in which case [[Sym.value]]
contains eventually the value of the (virtual) program counter [[pc]]
at the label definition

\item {\em symbols}, for procedures,
[[TEXT foo(SB)]]) and globals ([[GLOBL hello(SB)]]),
\l and also parameters and locals!
in which case [[Sym.value]] is not used since the address
of global symbols are resolved by [[5l]].
%
Another field of [[Sym]] is used though to store
meta-data about the symbol which will be stored in the 
symbol table of the object file
as we will see in Section~\ref{sec:symidx-sym-field}.
\l symidx, but actually not sym, sym and symkind are in Gen, not Symbol
\l also for SP and FP p _plus_ 0(FP)

\item {\em macros}, e.g [[#define FOO]], since [[5a]] is
a macro-assembler which embeds its own macroprocessor, in which case
[[Sym.value]] is not used but another field of [[Sym]] contains
the text of the macro as we will see in Section~\ref{sec:macro-sym-field}.

\item {\em symbolic constants}, e.g. [[RTMP = 10]], 
in which case [[Sym.value]] contain the constant value

\item {\em predefined identifiers}, 
for opcodes ([[AMOV]]) and registers([[R1]]), in which case
[[Sym.value]] contain the appropriate enumeration value.
\l ugly abuse

\end{itemize}
\n because of hash that means all MOVW in a file are shared when lexing

Predefined identifiers are stored in the symbol table for
efficiency reason.
%ocaml: could use a different hash table
Indeed, the symbol table is first a hash table, and so
it can be (ab)used by the lexer to quickly check 
if an identifier corresponds to the mnemomic of an opcode or register.
One of the initialisation function, [[cinit()]],
resets and then populates [[hash]] with all the 
array elements of [[itab]] we have seen in the previous section:

<<[[cinit()]] hash initialisation from itab>>=
for(i=0; i<NHASH; i++)
    hash[i] = S;
for(i=0; itab[i].name; i++) {
    s = slookup(itab[i].name);
    s->value = itab[i].value;
    s->type = itab[i].type;
}
@

In the case of predefined identifiers, another field of [[Sym]]
is used to also store the token code of the identifier
(in addition to the enum value of the opcode or register
stored in [[Sym.value]]):

<<[[Sym]] lexeme value fields>>=
//enum<token_code> (e.g. LLAB, LNAME, LVAR, LARITH, etc)
ushort	type;
@
\l see also itab[i].type and itab[i].value
\l used by?

The function below is called by [[lookup()]] when
a new symbol is created to reset some of its fields:

<<function syminit>>=
void
syminit(Sym *sym)
{
    sym->type = LNAME;
    sym->value = 0;
}
@


%dead:
%<<[[Sym]] other fields>>=
%Ref*	ref; // unused for 5a, matters?
%@
%<<struct Ref>>=
%// only for 8a actually, and actually not used so I removed it
%struct	Ref
%{
%    int	class;
%};
%@



\section{[[Sym_kind]]}

Now that we have seen the [[Sym]] structure, we
can present the [[sym]] field of the [[Gen]] structure:

<<[[Gen]] other fields>>=
// option<ref<Sym>>, Sym reference owned by hash
Sym*	sym;
@
%less: maybe should rename this field 'name'? and then use name_kind?
\t actually also one of the union token case

This field is used for operands involving symbols. For instance
in [[hello+4(SB)]], [[Gen.sym]] will point
to the symbol [[hello]] in the global [[hash]] table.
%
An additional [[Gen]] field is used to represent
the {\em kind} of the symbol:

<<[[Gen]] other fields>>=
// option<enum<sym_kind>>, None = N_NONE
short	symkind;
@
%old: was called name, but confusing I think, name as a field was used in
% many structures and it's actually not a name
%less: rename to name_kind? rename also the sym field above?

<<enum sym_kind(arm)>>=
enum sym_kind {
    N_NONE,

    D_EXTERN, // text/data/bss values (from SB)
    D_AUTO,   // stack values (from SP)
    D_PARAM,  // parameter (from FP)
    <<sym_kind cases>>
};
@
% use A_EXTERN? or N_EXTERN? is D_XXX because was in operand_kind before
%/* name */ for D_EXTERN
%note: this used to be with operand_kind, but they are really disjoint
% and used only for the ANAME pseudo opcode. In 5l/ there is
% actually a separate Dconv and Nconv (but in 8l/ they are together).

So, the C value of the operand in the example above is:
%EXAMPLE:
\begin{verbatim}
// operand value for: hello+4(SB)
{ sym = &<hello Sym>;  // hello
  offset = 4;          // +4
  sym_kind = D_EXTERN; // SB
  type = D_OREG;       // (...)
}
\end{verbatim}
\l could use reg? but then no need with (R12) and (SB)
\n the symkind is a property of the Gen and not Sym!
\l because people disambiguate at each use, foo(SB), foo _plus_ 0(FP), etc.

Note that there is no special operand type such as [[D_ADDRESS]]
to encode operands such as \$[[hello(SB)]]. Instead
the [[D_CONST]] type is (ab)used:
%EXAMPLE:
\begin{verbatim}
// operand value for: $hello(SB)
{ sym = &<hello Sym>;  // hello
  offset = 0;
  sym_kind = D_EXTERN; // SB
  type = D_CONST;      // $
}
\end{verbatim}

There is no ambiguity with the representation of simple constants
since the [[sym]] field in the case is NULL.
\l moreover address is a kind of constant? actually make sense to use dollar
\l but what is the code generated?

% Assembler is outputing a (spreaded) symbol table in the object file.
% Important job of assembler is to prepare for linker, to enable
% the linker to link modules together and so to resolve references 
% to external symbols.

%note that can have symkind set but not necessarality a sym,
% but it's in the degenerated case of con ( pointer ) which
% I think should not happen (or should happen when don't care
% about naming the parameter so just do  4(FP) in which
% case sym can be seen as an anonymous symbol name.




%section{[[pc]]} ?










\chapter{Main Functions}
\label{chap:main}

We now switch to a top-down approach where we describe
the main functions of [[5a]] starting from [[main()]]
down to [[assemble()]].

\section{[[main()]]}

Before showing the code of [[main()]] we first introduce
a few globals set by [[main()]].
%
A common pair of globals in \plan code
are [[thechar]] and [[thestring]] which both represent
the current architecture.
%
As said in the introduction, \plan by convention 
represents architectures with a single character: 
[['0']] is MIPS, 
[['5']] is ARM, 
[['8']] is x86, etc.
%
This character is used by [[5a]] for instance
for the filename extension of object files (e.g. [[hello.5]]): 

<<global thechar>>=
int	thechar;
@
\l int? no char? then use Rune!

[[thestring]] contains the longer, more readable, version
of the architecture, e.g. [["arm"]] for [[5]].

<<global thestring>>=
char*	thestring;
@

This is used by [[5a]] for instance to find architecture
specific system header files, e.g. in [[/arm/include/...]].
Indeed, [[5a]] is a macro-processor in which [[#include]] have
a default {\em search path} (represented by
the global [[include]] in [[main()]] below).


We can now present the code of [[main()]], the entry point of [[5a]].
The most important thing is the call to [[assemble()]] at the
end, with the filename of the assembly file to process 
passed through a command line argument:

<<function main(arm)>>=
void
main(int argc, char *argv[])
{
    <<[[main()]] locals>>
    <<[[main()]] debug initialization>>

    thechar = '5';
    thestring = "arm";

    cinit();
    include[ninclude++] = ".";

    ARGBEGIN {
    <<[[main()]] command line processing>>
    } ARGEND

    if(*argv == '\0') {
        print("usage: %ca [-options] file.s\n", thechar);
        errorexit();
    }

    <<[[main()]] multiple files handling>>

    if(assemble(argv[0]))
        errorexit();
    exits(0);
}
@


Another important global set possibly by [[main()]]
is [[outfile]] which stores the name of the output object file,
and which can be modified by the [[-o]] option:

<<global outfile>>=
char*	outfile = nil;
@
\l hmm could be 5.out instead no? hmm no, it will be set
\l to {basename(input_file)}.{thechar} in assemble()

<<[[main()]] command line processing>>=
case 'o':
    outfile = ARGF();
    break;
@





\section{[[cinit()]]}
\label{sec:nullgen}
\t rename to just init? why the C?

[[cinit()]] contains a few globals initialisations:
%ocaml: do not need that as initialisations are more flexible in ocaml

<<function cinit(arm)>>=
/// main -> <>
void
cinit(void)
{
    Sym *s;
    int i;

    <<[[cinit()]] nullgen initialisation>>
    <<[[cinit()]] hash initialisation from itab>>
    <<[[cinit()]] pathname initialisation from cwd>>
}
@
%old: used to do more initialisation here, but instead move the init at def loc
\n very similar to the x86 version, except the few change for nullgen fields

[[nullgen]] is a global we will often see later used to initialize
fresh operands in code such as [[newopd = nullgen;]]:

<<global nullgen>>=
Gen	nullgen;
@

<<[[cinit()]] nullgen initialisation>>=
nullgen.type    = D_NONE; // no type set yet
nullgen.reg     = R_NONE;
nullgen.symkind = N_NONE;
nullgen.sym = S;
nullgen.offset = 0; // part of an union
@

\ifallcode
<<[[cinit()]] nullgen initialisation>>=
if(FPCHIP)
    nullgen.dval = 0;
for(i=0; i<sizeof(nullgen.sval); i++)
    nullgen.sval[i] = 0;
@
%todo: now that I use an union, this code is valid about dval and sval?
% can't use N_NONE because this function is in aa/ and N_NONE is
% in 5a/a.h
%ocaml: merge with def, use nice record syntax


% cwd, for #include "" (cwd can change as one include other files)
%  =~ dirname(current_file)

[[pathname]] represents the {\em current working directory} 
(CWD). This is used also for the [[#include]] search path.

<<global pathname>>=
char*	pathname;
@
%less: rename? dirname_of_input_file? (actually it's really
% dirname_of_current_input_file as 5a can process multiple files,
% but it would complicate things; multifile is an advanced topic)

<<[[cinit()]] pathname initialisation from cwd>>=
pathname = allocn(pathname, 0, 100);
if(getwd(pathname, 99) == 0) {
    pathname = allocn(pathname, 100, 900);
    if(getwd(pathname, 999) == 0)
        strcpy(pathname, "/???");
}
@
%???
\t mv later? with #include?

\section{[[assemble()]]}

Because one can reference labels defined later in an assembly file,
a common approach to assembling is to use a two-pass algorithm.
The first pass focuses on the {\em definitions} of labels;
by the end of the file the values of all labels are known.
The second pass focuses on the {\em uses} of labels and leverages
the information computed in the first pass.
%
This is the strategy used by [[5a]]
and so an important global is [[pass]] which stores
in which pass we currently are (1 or 2):
\l alternatives to two-pass algo: lazy, patch back

<<global pass>>=
// 1|2
int	pass;
@
%ocaml: need this to be a global? could instead parse asm, return AST
% and then algo in two passes on the AST, a visitor and then generator.

This global is set by [[assemble()]] below and is used
in a few places in the grammar as well as in [[outcode()]]:

<<function assemble>>=
error1
assemble(char *infile)
{
    fdt of; // outfile
    char *p;
    <<[[assemble()]] locals>>

    <<[[assemble()]] set p to basename(infile) and adjust include>>
    if(outfile == nil) {
        <<[[assemble()]] set outfile to {basename(infile)}.{thechar}>>
    }
    <<[[assemble()]] setinclude("/{thestring}/include") or INCLUDE>>

    of = mycreat(outfile, 0664);
    if(of < 0) {
        yyerror("%ca: cannot create %s", thechar, outfile);
        errorexit();
    }
    Binit(&obuf, of, OWRITE);

    pass = 1;

    pinit(infile);
    <<[[assemble()]] init Dlist after pinit>>
    yyparse(); // calls outcode() but does nothing when pass == 1

    if(nerrors) {
        cclean();
        return nerrors;
    }

    pass = 2;
    outhist(); // file history information at the beginning of the object

    pinit(infile);
    <<[[assemble()]] init Dlist after pinit>>
    yyparse(); // calls outcode() that now does things

    cclean();
    return nerrors;
}
@
%pad: I renamed parameter to infile, to better contrast with outfile

Essentially [[assemble()]] calls [[yyparse()]]
two times, with the appropriate value in [[pass]], after
having initialized some globals related to the input file via [[pinit()]].
This means the input assembly file is parsed two times, but
the actions in the grammar do different things the second time.
%ocaml: ugly globals, dont see clearly, also ugly parse two times

Another global initialized by [[assemble()]] is [[obuf]],
the output buffer which will contain the content
of the object file [[5a]] generates:

% outfile(filename) -> of(fd) -> obuf(biobuf)
<<global obuf>>=
Biobuf	obuf;
@
%ocaml: why another global, ugly, because yyparse inflexible?

This will be used notably by [[outcode()]].
The main output data flow in [[assemble()]] is to go from
the name of the output file ([[outfile]]), 
to an output file descriptor ([[of]]),
to finally an output buffer ([[obuf]]).
%
Note that many globals are used for output data (e.g. [[obuf]])
as well as input data (see [[pinit()]]),
which makes the code harder to read. 
This is probably because the interface
of [[yyparse]], the function generated by Yacc,
does not take any argument nor return anything, so we
are forced to use globals.

The function below is called just before returning
from [[assemble()]] and is used to to add the last
instruction in the object file: [[AEND]].
It is a special marker used by [[5l]].
\t need AEND? yes, the linker wants an AEND, and I think
\l when use a library, can have multiple objects concatenated
\l in which case AEND is a marker for the end of an object.

<<function cclean(arm)>>=
/// main -> assemble -> <>
void
cclean(void)
{

    outcode(AEND, Always, &nullgen, R_NONE, &nullgen);
    Bflush(&obuf);
}
@

[[assemble()]] returns the number of errors it found,
or 0 if everything went fine. It is using the global [[nerrors]].
See Appendix~\ref{chap:error} for the error managment globals and functions.



\ifallcode
<<[[assemble()]] locals>>=
int i;
@
\fi

The remaining code in [[assemble()]] is mostly
filename manipulations and modifying globals used
for [[#include]] processing:

This is temporary used to compute [[outfile]] later:
<<[[assemble()]] locals>>=
char ofile[100];
@

<<[[assemble()]] set p to basename(infile) and adjust include>>=
// p = basename(infile)
// include[0] = dirname(infile); 
strcpy(ofile, infile);
p = utfrrune(ofile, '/');
if(p) {
    include[0] = ofile;
    *p++ = '\0';
} else
    p = ofile;
@

Note that [[utfrrune()]] returns the last occurence of a Rune.
A {\em rune} is a unicode character in \plan terminology.

<<[[assemble()]] set outfile to {basename(infile)}.{thechar}>>=
// outfile =  p =~ s/.s/.5/;
outfile = p;
if(outfile){
    p = utfrrune(outfile, '.');
    if(p)
        if(p[1] == 's' && p[2] == '\0')
            p[0] = '\0';
    p = utfrune(outfile, '\0');
    p[0] = '.';
    p[1] = thechar;
    p[2] = '\0';
} else
    outfile = "/dev/null";
@


<<[[assemble()]] locals>>=
char incfile[20];
@

<<[[assemble()]] setinclude("/{thestring}/include") or INCLUDE>>=
p = getenv("INCLUDE");
if(p) {
    setinclude(p);
} else {
    if(systemtype(Plan9)) {
        sprint(incfile,"/%s/include", thestring);
        setinclude(strdup(incfile));
    }
}
@
\l see Section X






\chapter{Input}
\label{chap:input}

% yyparse -> yylex -> GETC | ...

<<global lineno>>=
long	lineno;
@
% this is incremented by the lexer, and is also outputted
% in the object code for each instruction! so can trace back
% the line of an instruction!
% Is it after #include expansion line number?
% less: rename glineno?


% =~ yyback(1) trick, used by yylex() and getc(), and?? cg?
<<global peekc>>=
int	peekc = IGN;
@
% used to be set in cinit()

<<constant IGN>>=
#define	IGN		(-2)
@

<<constant EOF>>=
#define	EOF		(-1)
@

% FIGURE?

% assemble -> <> (before yyparse, in both passes)
% call at the beginning of each pass with the file to assemble
<<function pinit>>=
void
pinit(char *f)
{
    int i;
    Sym *s;

    lineno = 1;
    pc = 0;

    newio();
    newfile(f, -1);
    peekc = IGN;

    <<[[pinit]] symcounter and h initialisation>>
    <<[[pinit]] hash macro field reset>>
}
@


\section{Files managment, [[iostack]]}

% 5a supports #include  so have to open files, and also close them
%less: better to separate concern and have cpp in a different program?

<<constant BUFSIZ>>=
#define	BUFSIZ		8192
@

% hmm, could they use shorter fieldnames ...
<<struct Io>>=
struct	Io
{
    char	b[BUFSIZ];

    // -1 if not opened yet
    fdt	f;

    // like Fi, saved IO buffer status
    char*	p;
    short	c;

    // Extra
    <<[[Io]] extra fields>>
};
@

% list/stack because of #include, iostack point to head and currently
% opened and processed file
<<global iostack>>=
// list<Io> (next = Io.link)
Io*	iostack = I;
@
% used to be set in cinit()

<<[[Io]] extra fields>>=
Io*	link;
@

<<constant I>>=
#define	I	((Io*)nil)
@


<<global iofree>>=
// list<IO>, next = IO.link
Io*	iofree = I;
@

<<global ionext>>=
// option<ref<IO>>
Io*	ionext;
@

% assemble -> pinit -> <>
<<function newio>>=
void
newio(void)
{
    Io *i;
    static int pushdepth = 0;

    i = iofree;
    if(i == I) {
        pushdepth++;
        if(pushdepth > 1000) {
            yyerror("macro/io expansion too deep");
            errorexit();
        }
        //todo: check error code?
        i = alloc(sizeof(Io));
    } else
        iofree = i->link;
    i->c = 0;
    i->f = -1;
    ionext = i;
}
@


% assemble -> pinit -> <>
<<function newfile>>=
void
newfile(char *s, int f)
{
    Io *i;

    i = ionext;
    i->link = iostack;
    iostack = i;

    i->f = f;
    if(i->f < 0)
        i->f = open(s, 0);
    if(i->f < 0) {
        yyerror("%ca: %r: %s", thechar, s);
        errorexit();
    }
    fi.c = 0;
    linehist(s, 0);
}
@

\section{Buffer managment, [[fi]]}
% buffered IO

% File input?
<<struct Fi>>=
struct Fi
{
    // ref<char>, pointer in buffer (of Io.b)
    char*	p;
    // remaining count in buffer (of Io.b)
    int	c;
};
@

% global IO buffer
<<global fi>>=
struct Fi fi;
@


<<function GETC>>=
#define	GETC()		((--fi.c < 0) ? filbuf() : *fi.p++ & 0xff)
@

<<function filbuf>>=
int
filbuf(void)
{
    Io *i;

loop:
    i = iostack;
    if(i == I)
        return EOF;
    if(i->f < 0)
        goto pop;
    fi.c = read(i->f, i->b, BUFSIZ) - 1;
    if(fi.c < 0) {
        close(i->f);
        linehist(nil, 0);
        goto pop;
    }
    fi.p = i->b + 1;
    return i->b[0];

pop:
    iostack = i->link;
    i->link = iofree;
    iofree = i;
    i = iostack;
    if(i == I)
        return EOF;
    fi.p = i->p;
    fi.c = i->c;
    if(--fi.c < 0)
        goto loop;
    return *fi.p++;
}
@



\chapter{Lexing}
\label{chap:lexing}

\section{[[yylex()]]}

% loop until find a token and return its code
% and also set yylval global to contain more
% info about the token (yylval = the big union)

% GETC is essentially get next char in current opened file
% (that is iostack->f )
% #define	GETC()		((--fi.c < 0) ? filbuf() : *fi.p++ & 0xff)
% type: unit -> int (-1 for EOF, 0 for?)



% should use lex ... simpler, but maybe to avoid bootstrapping issues?
% hmm but they use yacc so ... (and lex uses yacc)
% or maybe because if want to have builtin-cpp, easier to do
% that when don't use lex? (and want builtin-cpp to avoid fork
% and make compilation faster?)



% called by? yyparse() in generated code from a.y
%less: ugly to not take any input and use globals. Should take a lexbuf!
<<function yylex>>=
long
yylex(void)
{
    int c;
    <<[[yylex()]] locals>>

    c = peekc;
    if(c != IGN) {
        peekc = IGN;
        goto l1;
    }
l0:
    c = GETC();

l1:
    if(c == EOF) {
        peekc = EOF;
        return -1;
    }

    if(isspace(c)) {
        <<[[yylex()]] if c is newline>>
        goto l0;
    }

    if(isalpha(c))
        goto talph;
    if(isdigit(c))
        goto tnum;

    switch(c) {
    <<[[yylex()]] switch c cases>>
    default:
        return c;
    }
    peekc = c1;
    return c;
}
@
%$
%newline transformed in ';', haskell spirit :)

% LP aspectize peekc? lp split more the func?


<<[[yylex()]] locals>>=
int c1;
@
% for peek


\section{Newlines}
\l and semicolons in title?
\label{sec:semicolon}

<<[[yylex()]] switch c cases>>=
case '\n':
    lineno++;
    return ';';
@
% can be reached? isspace(c) above seems unreachable

<<[[yylex()]] if c is newline>>=
if(c == '\n') {
    lineno++;
    return ';'; // newline transformed in fake ';'
}
@

% newline are translated in ';' and this is used by
% the grammar, see Parsing subsections

\section{Comments}

<<[[yylex()]] switch c cases>>=
case '/':
    c1 = GETC();
    if(c1 == '/') {
        for(;;) {
            c = GETC();
            if(c == '\n')
                goto l1;
            if(c == EOF) {
                yyerror("eof in comment");
                errorexit();
            }
        }
    }
    if(c1 == '*') {
        for(;;) {
            c = GETC();
            while(c == '*') {
                c = GETC();
                if(c == '/')
                    goto l0;
            }
            if(c == EOF) {
                yyerror("eof in comment");
                errorexit();
            }
            if(c == '\n')
                lineno++;
        }
    }
    break;
@
% goto l1 or l0 depending if want to ask for another char or not

% put getcom() here too?

\section{Mnemonics and identifiers}

<<[[yylex()]] locals>>=
char *cp;
Sym *s;
@


% @ too? maybe could remove it so it would also remove the need for
% the LAT token_kind
<<[[yylex()]] switch c cases>>=
case '_':
case '@':
// case 'a'..'z' 'A'..'Z': (isalpha())
// case '.' too
talph:
    cp = symb;

aloop:
    *cp++ = c;
    c = GETC();
    if(isalpha(c) || isdigit(c) || c == '_' || c == '$') // $
        goto aloop;

    // went too far, yyback(1)
    peekc = c;

    *cp = '\0';
    s = lookup();

    <<[[yylex()]] if macro symbol>>

    if(s->type == 0) // when can this happen?
        s->type = LNAME;

    if(s->type == LNAME || s->type == LLAB || s->type == LVAR) {
        yylval.sym = s;
    } else {
        yylval.lval = s->value;
    }
    return s->type;
@
% possible to have s->type == 0? if new symbol then I think
% it actually set to LNAME in syminit

\section{Numbers}

%TODO LP split
<<[[yylex()]] switch c cases>>=
// case '0'..'9': (isdigit())
tnum:
    cp = symb;
    if(c != '0')
        goto dc;

    *cp++ = c;
    c = GETC();
    c1 = 3;
    if(c == 'x' || c == 'X') {
        c1 = 4;
        c = GETC();
    } else
    if(c < '0' || c > '7')
        goto dc;
    yylval.lval = 0;
    for(;;) {
        if(c >= '0' && c <= '9') {
            if(c > '7' && c1 == 3)
                break;
            yylval.lval <<= c1;
            yylval.lval += c - '0';
            c = GETC();
            continue;
        }
        if(c1 == 3)
            break;
        if(c >= 'A' && c <= 'F')
            c += 'a' - 'A';
        if(c >= 'a' && c <= 'f') {
            yylval.lval <<= c1;
            yylval.lval += c - 'a' + 10;
            c = GETC();
            continue;
        }
        break;
    }
    goto ncu;

dc:
    for(;;) {
        if(!isdigit(c))
            break;
        *cp++ = c;
        c = GETC();
    }
    if(c == '.')
        goto casedot;
    if(c == 'e' || c == 'E')
        goto casee;
    *cp = 0;
    if(sizeof(yylval.lval) == sizeof(vlong))
        yylval.lval = strtoll(symb, nil, 10);
    else
        yylval.lval = strtol(symb, nil, 10);

ncu:
    while(c == 'U' || c == 'u' || c == 'l' || c == 'L')
        c = GETC();
    peekc = c;
    return LCONST;

casedot:
    for(;;) {
        *cp++ = c;
        c = GETC();
        if(!isdigit(c))
            break;
    }
    if(c == 'e' || c == 'E')
        goto casee;
    goto caseout;

casee:
    *cp++ = 'e';
    c = GETC();
    if(c == '+' || c == '-') {
        *cp++ = c;
        c = GETC();
    }
    while(isdigit(c)) {
        *cp++ = c;
        c = GETC();
    }

caseout:
    *cp = 0;
    peekc = c;
    if(FPCHIP) {
        yylval.dval = atof(symb);
        return LFCONST;
    }
    yyerror("assembler cannot interpret fp constants");
    yylval.lval = 1L;
    return LCONST;
@


\subsection{Decimals}

\subsection{Floats}

<<[[yylex()]] switch c cases>>=
case '.':
    c = GETC();
    if(isalpha(c)) {
        cp = symb;
        *cp++ = '.';
        goto aloop;
    }
    if(isdigit(c)) {
        cp = symb;
        *cp++ = '.';
        goto casedot;
    }
    peekc = c;
    return '.';
@
% why not simply goto talph for '.'? avoid duplicate the cp = symb; cp++ ...

\section{Characters (and escape)}

<<[[yylex()]] switch c cases>>=
case '\'':
    c = escchar('\'');
    if(c == EOF)
        c = '\'';
    if(escchar('\'') != EOF)
        yyerror("missing '");
    yylval.lval = c;
    return LCONST;
@

%\section{Escaping characters}
%Special characters?

% e is usually ' or ", the ending characher (and also char you have to escape)
% use Rune instead of int?
<<function escchar>>=
int
escchar(int e)
{
    int c, l;

loop:
    c = getc();
    if(c == '\n') {
        yyerror("newline in string");
        return EOF;
    }
    if(c != '\\') {
        if(c == e)
            return EOF;
        return c;
    }
    c = getc();
    if(c >= '0' && c <= '7') {
        l = c - '0';
        c = getc();
        if(c >= '0' && c <= '7') {
            l = l*8 + c-'0';
            c = getc();
            if(c >= '0' && c <= '7') {
                l = l*8 + c-'0';
                return l;
            }
        }
        peekc = c;
        return l;
    }
    switch(c)
    {
    case '\n':	goto loop;

    case 'n':	return '\n';
    case 't':	return '\t';
    case 'b':	return '\b';
    case 'r':	return '\r';
    case 'f':	return '\f';

    case 'a':	return 0x07;
    case 'v':	return 0x0b;
    case 'z':	return 0x00;
    }
    return c;
}
@
% they abuse EOF to mean end of string

\section{Strings}

<<[[yylex()]] switch c cases>>=
case '"':
    memcpy(yylval.sval, nullgen.sval, sizeof(yylval.sval));
    cp = yylval.sval;
    c1 = 0;
    for(;;) {
        c = escchar('"');
        if(c == EOF)
            break;
        if(c1 < sizeof(yylval.sval))
            *cp++ = c;
        c1++;
    }
    if(c1 > sizeof(yylval.sval))
        yyerror("string constant too long");
    return LSCONST;
@







\chapter{Preprocessing}
\label{chap:preprocessing}

% Builtin in the binary. A bit of code duplication with the
% compiler, but maybe it makes compilation faster because
% there is no fork at all!

<<global mactab>>=
struct
{
    char	*macname;
    void	(*macf)(void);
} mactab[] =
{
    "ifdef",	nil,	/* macif(0) */
    "ifndef",	nil,	/* macif(1) */
    "else",		nil,	/* macif(2) */
    "endif",	macend,

    "include",	macinc,
    "define",	macdef,
    "undef",	macund,
    "pragma",	macprag,
    "line",		maclin,
    0
};
@
% mac for macro (and not macos or macintosh), but used actually
% for all cpp related constructs.
% note: I reorganized the entries, but should not matter

<<[[yylex()]] switch c cases>>=
case '#':
    domacro();
    goto l0;
@
% goto l0 because does not return any token, we just have
% actually expanded or defined macros or undef, in any case
% no token to return

% dispatcher, should rename because it's not just about macro =>
% parse_and_dispatch_pp_directive?
<<function domacro>>=
void
domacro(void)
{
    int i;
    Sym *s;

    s = getsym();
    if(s == S)
        s = slookup("endif");

    for(i=0; mactab[i].macname; i++)
        if(strcmp(s->name, mactab[i].macname) == 0) {
            if(mactab[i].macf)
                // dispatcher!
                (*mactab[i].macf)();
            else
                macif(i);
            return;
        }
    yyerror("unknown #: %s", s->name);
    macend();
}
@
% abuse getsym just to get an ident, don't have to go through
% lookup really
% note: didn't know that a single # is actually equivalent to an endif



<<function macend>>=
void
macend(void)
{
    int c;

    for(;;) {
        c = getnsc();
        if(c < 0 || c == '\n')
            return;
    }
}
@
% I don't think c can be < 0 here.

\section{[[#include]]}
% and [[-I]]

\subsection{Include path, [[-I]]}

<<[[main()]] locals>>=
char *p;
@

% -I
<<[[main()]] command line processing>>=
case 'I':
    p = ARGF();
    setinclude(p);
    break;
@

<<constant NINCLUDE>>=
#define	NINCLUDE	10
@

% hmm rename? include_paths?
<<global include>>=
char*	include[NINCLUDE];
@

<<global ninclude>>=
int	ninclude;
@

<<function setinclude>>=
void
setinclude(char *p)
{
    int i;

    if(p == nil)
        return;
    for(i=1; i < ninclude; i++)
        if(strcmp(p, include[i]) == 0)
            return;

    if(ninclude >= nelem(include)) {
        yyerror("ninclude too small %d", nelem(include));
        exits("ninclude");
    }
    include[ninclude++] = p;
}
@


\subsection{Tracing origin and [[Hist]]}

% when error, need give line, but can be because of context,
% so useful to give the full location of an error, that is the list
% of files that included it
% TODO give example of why it's useful to not just have the final names

% keep track of where a token comes from, so that error
% messages can look like
%  xxx.h from xxx.h from xxx.c ...
<<struct Hist>>=
struct	Hist
{
    char*	filename;

    long	line;   // global line of this Hist
    long	local_line; // local line for this hist 

    // Extra
    <<[[Hist]] extra fields>>
};
@
%note: rename offset to local_line, clearer, and also avoid
% possible confusion with Gen.offset
%abused for #pragma lib "xxx.a" where local_line is then -1. ugly.

<<global hist>>=
// list<ref_own<Hist>>, next = Hist.link
Hist*	hist;
@

<<[[Hist]] extra fields>>=
Hist*	link;
@

<<global ehist>>=
// ref<Hist>, end of list of hist
Hist*	ehist;
@


<<constant H>>=
#define	H	((Hist*)nil)
@





<<function linehist>>=
void
linehist(char *f, int local_line)
{
    Hist *h;

    <<[[linehist()]] debug>>

    h = alloc(sizeof(Hist));
    h->filename = f;
    h->line = lineno;
    h->local_line = local_line;

    //add_list(hist, ehist, h)
    h->link = H;
    if(ehist == H) {
        hist = h;
        ehist = h;
        return;
    }
    ehist->link = h;
    ehist = h;
}
@


%% newflag dead? seems just set to false ... just one write.
%% it's used in cc/ though, but we copy pasted code for macbody so
% I think it's safe to delete it here.
%<<global newflag>>=
%bool	newflag;
%@
%
%    <<[[linehist()]] newflag hack>>
%    <<[[linehist()]] debug>>
%    newflag = false;
%
%
%<<[[linehist()]] newflag hack>>=
%/*
% * overwrite the last #line directive if
% * no alloc has happened since the last one
% */
%if(newflag == false && ehist != H && offset != 0 && ehist->offset != 0)
%    if(f && ehist->filename && strcmp(f, ehist->filename) == 0) {
%        ehist->line = lineno;
%        ehist->offset = offset;
%        return;
%    }
%@




% I prefer to put prfile here rather than in the Error appendix.
% So can better understand actually the tracing mechanism.

<<constant HISTSZ>>=
#define	HISTSZ		20
@

% yyerror -> <>, for nice error reporting with include trace
%  l = lineno
<<function prfile>>=
void
prfile(long l)
{
    int i, n;
    Hist *h;
    Hist a[HISTSZ];
    long d;

    n = 0;
    for(h = hist; h != H; h = h->link) {
        if(l < h->line)
            break;

        if(h->filename) {
            if(h->local_line == 0) {
                if(n >= 0 && n < HISTSZ)
                    a[n] = *h;
                n++;
            } else {
                if(n > 0 && n < HISTSZ)
                    if(a[n-1].local_line == 0) {
                        a[n] = *h;
                        n++;
                    } else
                        a[n-1] = *h;
           }
        }
        // a pop
        else {
            n--;
            if(n >= 0 && n < HISTSZ) {
                d = h->line - a[n].line;
                for(i=0; i<n; i++)
                    a[i].line += d;
            }
        }
    }
    if(n > HISTSZ)
        n = HISTSZ;
    for(i=0; i<n; i++)
        print("%s:%ld ", a[i].filename, 
                         (long)(l - a[i].line + a[i].local_line + 1));
}
@
% see 5a -f to help understand a bit.
% when no filename it means it's a pop

\subsection{[[#include]]}

<<constant STRINGSZ>>=
#define	STRINGSZ	200
@

% LP split
<<function macinc>>=
void
macinc(void)
{
    int c0, c, i, f;
    char str[STRINGSZ], *hp;

    c0 = getnsc();
    if(c0 != '"') {
        c = c0;
        if(c0 != '<')
            goto bad;
        c0 = '>';
    }
    for(hp = str;;) {
        c = getc();
        if(c == c0)
            break;
        if(c == '\n')
            goto bad;
        *hp++ = c;
    }
    *hp = 0;

    c = getcom();
    if(c != '\n')
        goto bad;

    f = -1;
    for(i=0; i<ninclude; i++) {
        if(i == 0 && c0 == '>')
            continue;
        strcpy(symb, include[i]);
        strcat(symb, "/");
        if(strcmp(symb, "./") == 0)
            symb[0] = 0;
        strcat(symb, str);

        f = open(symb, 0);
        if(f >= 0)
            break;

    }
    if(f < 0)
        strcpy(symb, str);
    c = strlen(symb) + 1;
    while(c & 3)
        c++;

    hp = malloc(c);
    memcpy(hp, symb, c);

    newio();
    pushio();
    newfile(hp, f);
    return;

bad:
    unget(c);
    yyerror("syntax in #include");
    macend();
}
@


<<function pushio>>=
void
pushio(void)
{
    Io *i;

    i = iostack;
    if(i == I) {
        yyerror("botch in pushio");
        errorexit();
    }
    i->p = fi.p;
    i->c = fi.c;
}
@

\section{[[#define]]}
% and [[-D]]

\subsection{[[-D]]}

<<[[main()]] command line processing>>=
case 'D':
    p = ARGF();
    if(p)
        Dlist[nDlist++] = p;
    break;
@

% -D
<<global Dlist>>=
char*	Dlist[30];
@

<<global nDlist>>=
int	nDlist;
@

<<[[assemble()]] init Dlist after pinit>>=
for(i=0; i<nDlist; i++)
        dodefine(Dlist[i]);
@

<<[[Sym]] macro value fields>>=
//option<string>, for '#define FOO xxx' expansion
char*	macro;
@
\label{sec:macro-sym-field}

<<[[pinit]] hash macro field reset>>=
for(i=0; i<NHASH; i++)
    for(s = hash[i]; s != S; s = s->link)
        s->macro = nil;
@


<<function dodefine>>=
void
dodefine(char *cp)
{
    Sym *s;
    char *p;
    long l;
    char *x;

    strcpy(symb, cp);
    p = strchr(symb, '=');
    if(p) {
        *p++ = 0;
        s = lookup();
        l = strlen(p) + 2;	/* +1 null, +1 nargs */
        while(l & 3)
            l++;

        x = malloc(l);
        *x = '\0';
        strcpy(x+1, p);
        s->macro = x;
    } else {
        s = lookup();
        s->macro = "\0001";	/* \000 is nargs */
    }
    <<[[dodefine()]] debug>>
}
@



\subsection{[[#define]]}

<<constant NARG>>=
#define	NARG	25
@

% wow, this is complicated
<<function macdef>>=
void
macdef(void)
{
    Sym *s, *a;
    char *args[NARG], *np, *base;
    int n, i, c, len, dots;
    int ischr;

    s = getsym();
    if(s == S)
        goto bad;
    if(s->macro)
        yyerror("macro redefined: %s", s->name);
    c = getc();
    n = -1;
    dots = 0;
    if(c == '(') {
        n++;
        c = getnsc();
        if(c != ')') {
            unget(c);
            for(;;) {
                a = getsymdots(&dots);
                if(a == S)
                    goto bad;
                if(n >= NARG) {
                    yyerror("too many arguments in #define: %s", s->name);
                    goto bad;
                }
                args[n++] = a->name;
                c = getnsc();
                if(c == ')')
                    break;
                if(c != ',' || dots)
                    goto bad;
            }
        }
        c = getc();
    }
    if(isspace(c))
        if(c != '\n')
            c = getnsc();
    base = hunk;
    len = 1;
    ischr = 0;
    for(;;) {
        if(isalpha(c) || c == '_') {
            np = symb;
            *np++ = c;
            c = getc();
            while(isalnum(c) || c == '_') {
                *np++ = c;
                c = getc();
            }
            *np = 0;
            for(i=0; i<n; i++)
                if(strcmp(symb, args[i]) == 0)
                    break;
            if(i >= n) {
                i = strlen(symb);
                base = allocn(base, len, i);
                memcpy(base+len, symb, i);
                len += i;
                continue;
            }
            base = allocn(base, len, 2);
            base[len++] = '#';
            base[len++] = 'a' + i;
            continue;
        }
        if(ischr){
            if(c == '\\'){ 
                base = allocn(base, len, 1);
                base[len++] = c;
                c = getc();
            }else if(c == ischr)
                ischr = 0;
        }else{
            if(c == '"' || c == '\''){
                base = allocn(base, len, 1);
                base[len++] = c;
                ischr = c;
                c = getc();
                continue;
            }
            if(c == '/') {
                c = getc();
                if(c == '/'){
                    c = getc();
                    for(;;) {
                        if(c == '\n')
                            break;
                        c = getc();
                    }
                    continue;
                }
                if(c == '*'){
                    c = getc();
                    for(;;) {
                        if(c == '*') {
                            c = getc();
                            if(c != '/')
                                continue;
                            c = getc();
                            break;
                        }
                        if(c == '\n') {
                            yyerror("comment and newline in define: %s", s->name);
                            break;
                        }
                        c = getc();
                    }
                    continue;
                }
                base = allocn(base, len, 1);
                base[len++] = '/';
                continue;
            }
        }
        if(c == '\\') {
            c = getc();
            if(c == '\n') {
                c = getc();
                continue;
            }
            else if(c == '\r') {
                c = getc();
                if(c == '\n') {
                    c = getc();
                    continue;
                }
            }
            base = allocn(base, len, 1);
            base[len++] = '\\';
            continue;
        }
        if(c == '\n')
            break;
        if(c == '#')
        if(n > 0) {
            base = allocn(base, len, 1);
            base[len++] = c;
        }
        base = allocn(base, len, 1);
        base[len++] = c;
        c = ((--fi.c < 0)? filbuf(): (*fi.p++ & 0xff));
        if(c == '\n')
            lineno++;
        if(c == -1) {
            yyerror("eof in a macro: %s", s->name);
            break;
        }
    }
    do {
        base = allocn(base, len, 1);
        base[len++] = 0;
    } while(len & 3);

    *base = n+1;
    if(dots)
        *base |= VARMAC;
    s->macro = base;
    <<[[macdef()]] debug>>
    return;

bad:
    if(s == S)
        yyerror("syntax in #define");
    else
        yyerror("syntax in #define: %s", s->name);
    macend();
}
@
% wow, complicated

<<constant VARMAC>>=
#define VARMAC 0x80
@


<<function getsymdots>>=
Sym*
getsymdots(int *dots)
{
    int c;
    Sym *s;

    s = getsym();
    if(s != S)
        return s;

    c = getnsc();
    if(c != '.'){
        unget(c);
        return S;
    }
    if(getc() != '.' || getc() != '.')
        yyerror("bad dots in macro");
    *dots = 1;
    return slookup("__VA_ARGS__");
}
@

\subsection{Macro Expansion}

<<[[yylex()]] if macro symbol>>=
if(s->macro) {
    newio();
    cp = ionext->b;
    macexpand(s, cp);
    pushio();

    ionext->link = iostack;
    iostack = ionext;

    fi.p = cp;
    fi.c = strlen(cp);
    if(peekc != IGN) {
        cp[fi.c++] = peekc;
        cp[fi.c] = 0;
        peekc = IGN;
    }
    goto l0;
}
@
% abuse newio()? it's not really a new file here

% wow, complicated too
<<function macexpand>>=
void
macexpand(Sym *s, char *b)
{
    char buf[2000];
    int n, l, c, nargs;
    char *arg[NARG], *cp, *ob, *ecp, dots;

    ob = b;
    if(*s->macro == 0) {
        strcpy(b, s->macro+1);
        if(debug['m'])
            print("#expand %s %s\n", s->name, ob);
        return;
    }
    
    nargs = (char)(*s->macro & ~VARMAC) - 1;
    dots = *s->macro & VARMAC;

    c = getnsc();
    if(c != '(')
        goto bad;
    n = 0;
    c = getc();
    if(c != ')') {
        unget(c);
        l = 0;
        cp = buf;
        ecp = cp + sizeof(buf)-4;
        arg[n++] = cp;
        for(;;) {
            if(cp >= ecp)
                goto toobig;
            c = getc();
            if(c == '"')
                for(;;) {
                    if(cp >= ecp)
                        goto toobig;
                    *cp++ = c;
                    c = getc();
                    if(c == '\\') {
                        *cp++ = c;
                        c = getc();
                        continue;
                    }
                    if(c == '\n')
                        goto bad;
                    if(c == '"')
                        break;
                }
            if(c == '\'')
                for(;;) {
                    if(cp >= ecp)
                        goto toobig;
                    *cp++ = c;
                    c = getc();
                    if(c == '\\') {
                        *cp++ = c;
                        c = getc();
                        continue;
                    }
                    if(c == '\n')
                        goto bad;
                    if(c == '\'')
                        break;
                }
            if(c == '/') {
                c = getc();
                switch(c) {
                case '*':
                    for(;;) {
                        c = getc();
                        if(c == '*') {
                            c = getc();
                            if(c == '/')
                                break;
                        }
                    }
                    *cp++ = ' ';
                    continue;
                case '/':
                    while((c = getc()) != '\n')
                        ;
                    break;
                default:
                    unget(c);
                    c = '/';
                }
            }
            if(l == 0) {
                if(c == ',') {
                    if(n == nargs && dots) {
                        *cp++ = ',';
                        continue;
                    }
                    *cp++ = 0;
                    arg[n++] = cp;
                    if(n > nargs)
                        break;
                    continue;
                }
                if(c == ')')
                    break;
            }
            if(c == '\n')
                c = ' ';
            *cp++ = c;
            if(c == '(')
                l++;
            if(c == ')')
                l--;
        }
        *cp = 0;
    }
    if(n != nargs) {
        yyerror("argument mismatch expanding: %s", s->name);
        *b = 0;
        return;
    }
    cp = s->macro+1;
    for(;;) {
        c = *cp++;
        if(c == '\n')
            c = ' ';
        if(c != '#') {
            *b++ = c;
            if(c == 0)
                break;
            continue;
        }
        c = *cp++;
        if(c == 0)
            goto bad;
        if(c == '#') {
            *b++ = c;
            continue;
        }
        c -= 'a';
        if(c < 0 || c >= n)
            continue;
        strcpy(b, arg[c]);
        b += strlen(arg[c]);
    }
    *b = 0;
    if(debug['m'])
        print("#expand %s %s\n", s->name, ob);
    return;

bad:
    yyerror("syntax in macro expansion: %s", s->name);
    *b = 0;
    return;

toobig:
    yyerror("too much text in macro expansion: %s", s->name);
    *b = 0;
}
@
% wow complicated again

\section{[[#undef]]}

<<function macund>>=
void
macund(void)
{
    Sym *s;

    s = getsym();
    macend();
    if(s == S) {
        yyerror("syntax in #undef");
        return;
    }
    s->macro = nil;
}
@

\section{[[#ifdef]]}

% 0 = ifdef, 1 = ifndef, 2 = else, see mactab and domacro
<<function macif>>=
void
macif(int f)
{
    int c, l;
    bool bol;
    Sym *s;

    if(f == 2)
        goto skip;
    s = getsym();
    if(s == S)
        goto bad;
    if(getcom() != '\n')
        goto bad;
    if((s->macro != nil) ^ f)
        return;

skip:
    bol = true;
    l = 0;
    for(;;) {
        c = getc();
        if(c != '#') {
            if(!isspace(c))
                bol = false;
            if(c == '\n')
                bol = true;
            continue;
        }
        if(!bol)
            continue;
        s = getsym();
        if(s == S)
            continue;
        if(strcmp(s->name, "endif") == 0) {
            if(l) {
                l--;
                continue;
            }
            macend();
            return;
        }
        if(strcmp(s->name, "ifdef") == 0 || strcmp(s->name, "ifndef") == 0) {
            l++;
            continue;
        }
        if(l == 0 && f != 2 && strcmp(s->name, "else") == 0) {
            macend();
            return;
        }
    }

bad:
    yyerror("syntax in #if(n)def");
    macend();
}
@

\section{[[#pragma]]}

% effect of #pragma lib in .s ??

<<[[macprag()]] locals>>=
Sym *s;
@

<<function macprag>>=
void
macprag(void)
{
    <<[[macprag()]] locals>>

    s = getsym();

    <<[[macprag()]] if pragma lib>>
    else {
        while(getnsc() != '\n')
            ;
        return;
    }
}
@


% most pragma seems to be discarded here, except #pragma lib, so
% I removed then (could have aslo simplified by calling prag_do_nothing()).
% it is because the code was shared with cc before I think and the compilers
% had different pragxxx functions with an actual body.
%
%    if(s && strcmp(s->name, "pack") == 0) {
%        pragpack();
%        return;
%    }
%    if(s && strcmp(s->name, "fpround") == 0) {
%        pragfpround();
%        return;
%    }
%    if(s && strcmp(s->name, "profile") == 0) {
%        pragprofile();
%        return;
%    }
%    if(s && strcmp(s->name, "varargck") == 0) {
%        pragvararg();
%        return;
%    }
%    if(s && strcmp(s->name, "incomplete") == 0) {
%        pragincomplete();
%        return;
%    }
%
%old:
%<<function pragpack>>=
%void
%pragpack(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@
%
%<<function pragvararg>>=
%void
%pragvararg(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@
%
%<<function pragfpround>>=
%void
%pragfpround(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@
%
%<<function pragprofile>>=
%void
%pragprofile(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@
%
%<<function pragincomplete>>=
%void
%pragincomplete(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@


\section{[[#line]]}

<<function maclin>>=
void
maclin(void)
{
    char *cp;
    int c;
    long n;

    n = getnsn();
    c = getc();
    if(n < 0)
        goto bad;

    for(;;) {
        if(c == ' ' || c == '\t') {
            c = getc();
            continue;
        }
        if(c == '"')
            break;
        if(c == '\n') {
            strcpy(symb, "<noname>");
            goto nn;
        }
        goto bad;
    }
    cp = symb;
    for(;;) {
        c = getc();
        if(c == '"')
            break;
        *cp++ = c;
    }
    *cp = 0;
    c = getcom();
    if(c != '\n')
        goto bad;

nn:
    c = strlen(symb) + 1;
    while(c & 3)
        c++;

    cp = malloc(c);
    memcpy(cp, symb, c);

    linehist(cp, n);
    return;

bad:
    unget(c);
    yyerror("syntax in #line");
    macend();
}
@

% could move with the other getxxx()
<<function getnsn>>=
long
getnsn(void)
{
    long n;
    int c;

    c = getnsc();
    if(c < '0' || c > '9')
        return -1;
    n = 0;
    while(c >= '0' && c <= '9') {
        n = n*10 + c-'0';
        c = getc();
    }
    unget(c);
    return n;
}
@


\section{[[getxxx()]]}

% from now on those functions are actually used by the preprocessing
% code, not by the basic lexer (yylex) that actually implement
% his own getnsc(), getcom(), getsym() via cases
% (hmmm maybe could factorize things?)

\subsection{[[getc()]], [[unget()]], [[getnsc()]]}


% helpers for other functions

% int? why not uint? GETC can return EOF but not this function!
<<function getc>>=
int
getc(void)
{
    int c;

    c = peekc;
    if(c != IGN) {
        peekc = IGN;
        return c;
    }

    c = GETC();

    if(c == '\n')
        lineno++;
    if(c == EOF) {
        yyerror("End of file");
        errorexit();
    }
    return c;
}
@


% what if had already a peekc? because called unget 2 times?
% should raise Impossible!
<<function unget>>=
void
unget(int c)
{
    peekc = c;
    if(c == '\n')
        lineno--;
}
@

% get non space char (they really like short cryptic names)
<<function getnsc>>=
int
getnsc(void)
{
    int c;

    for(;;) {
        c = getc();
        if(!isspace(c) || c == '\n')
            return c;
    }
}
@



\subsection{[[getsym()]]}
% mv with Keywords and identifier section?

<<function getsym>>=
Sym*
getsym(void)
{
    int c;
    char *cp;

    c = getnsc();
    if(!isalpha(c) && c != '_' && c < Runeself) {
        unget(c);
        return S;
    }
    for(cp = symb;;) {
        if(cp <= symb+NSYMB-4)
            *cp++ = c;
        c = getc();
        if(isalnum(c) || c == '_' || c >= Runeself)
            continue;
        unget(c);
        break;
    }
    *cp = 0;
    if(cp > symb+NSYMB-4)
        yyerror("symbol too large: %s", symb);
    return lookup();
}
@

\subsection{[[getcom()]]}
% mv with Comments section above?

<<function getcom>>=
int
getcom(void)
{
    int c;

    for(;;) {
        c = getnsc();
        if(c != '/')
            break;
        c = getc();
        if(c == '/') {
            while(c != '\n')
                c = getc();
            break;
        }
        if(c != '*')
            break;
        c = getc();
        for(;;) {
            if(c == '*') {
                c = getc();
                if(c != '/')
                    continue;
                c = getc();
                break;
            }
            if(c == '\n') {
                yyerror("comment across newline");
                break;
            }
            c = getc();
        }
        if(c == '\n')
            break;
    }
    return c;
}
@





\chapter{Parsing}
\label{chap:parsing}

In this chapter we assume you know how to read a Yacc grammar.
We recommend~\cite{lexyacc} to learn more about Yacc.
You can also read the original Yacc paper at [[generators/docs/yacc.pdf]]
in our \plan repository, or read our \book{Code Generators} to fully
understand how Yacc works.

\section{Overview}

Here is the outline of the yacc grammar file for Asm5, the ARM assembly
language supported by [[5a]]:

<<5a/a.y>>=
%{
#include "a.h"
%}
<<union token(arm)>>
<<priority and associativity declarations>>
<<token declarations(arm)>>
<<type declarations(arm)>>
%%
<<grammar(arm)>>
@
%$
\n classic Yacc

The [[union]] and [[token]] declarations {directives} have been
already described in Section~\ref{sec:token}.
The [[type]] declarations will be described gradually in this chapter. 
The [[priority]] declarations are used only for the constant
expressions and will be described in Section~\ref{sec:constant-expr}.
The [[grammar]] part is the most important one;
it defines the different grammar rules:

<<grammar(arm)>>=
prog:
  /* empty */
| prog line

<<line rule(arm)>>
<<inst rule(arm)>>
<<cond rule(arm)>>
<<operand rules(arm)>>
<<helper rules(arm)>>

<<constant expression rules>>
<<float rules>>
<<opt rules>>
<<misc rules>>
@
\l actually not context free, parsing a file modify the kind
\l of some tokens, e.g. labels, lval.

An Asm5 [[prog]]ram is either an empty file or a
set of lines.
% FIGURE with derivation where see set of lines?

A [[line]] can be an [[inst]]ruction followed by a semicolon.
Remember that the lexer transformed newlines in semicolons
in Section~\ref{sec:semicolon}.
\l so can either pack in one line with ';' or use newline (haskell spirit :) )

<<line rule(arm)>>=
line:
  inst ';'
@

A line can also be empty, or contain the special [[error]] Yacc
token (used for error recovery, see~\cite{lexyacc}).
\l to got until next ; (that is newline)?

<<line rule(arm)>>=
| ';'
| error ';'
@

In Section~\ref{sec:label-def} we will see that a line
can also contain label definitions.

% assembly file is made of lines containing instructions or labels.
% instructions are mostly a single opcode with 0, 1, 2 or 3 operands
% where each operand can be a register, or constant, or address, etc.
% and some combination (like register + constant offset)

% there are some special opcodes like TEXT which don't translate
% in binary code but are useful for ? (symbol resolving?)
% They are called pseudo-opcodes.

\section{Instructions}

% similar sub sections than in Machine.nw

\subsection{Arithmetic and logic}

\subsubsection{Logic}

<<logic opcodes>>=
AAND,
AORR,
AEOR,
@
%note: not exactly the ARM order, I prefer to put closer AAND and AORR for
% instance
%compiler: need logic for many things, complex if conditions. booleans!
% also useful for bit level operations (bitsets, bit extraction, bit mask)
% (and actually most things can be encoded with just NAND!)
% how NOT?

<<[[itab]] elements>>=
"AND",		LARITH,	AAND,
"ORR",		LARITH,	AORR,
"EOR",		LARITH,	AEOR,
@

<<inst rule(arm)>>=
inst:
/*
 * AND/OR/ADD/SUB/...
 */
  LARITH cond imsr ',' spreg ',' reg { outcode($1, $2, &$3, $5, &$7); }
| LARITH cond imsr ',' spreg ','     { outcode($1, $2, &$3, $5, &nullgen); }
| LARITH cond imsr ',' reg           { outcode($1, $2, &$3, R_NONE, &$5); }
@
%$
% arith operator of Machine.nw, but also SLL, SRL,   DIV, MOD, ...

% ADD X1, X2, X3, imsr = immediate or shift (will see later) or register 
% e.g. ADD 10, R1, R2 (code 3 addresses, well 3 registers).
% if middle register is NONE then ADD X1, X2 -> ADD X1, X2, X2 (+=)

% cond will be explained also later, ARM specificities.

% outcode() =~ pc++
% take 5 arguments, opcode, cond, op1, op2, op3.
% op2 is always a register or nothing

% (in ARM each instruction have same length, so doing pc++ 
%  is easy, but for variable-sized archi like x86, the assembler
%  actually does just pc++ because the pc in 8a/ is a virtual pc)


\subsubsection{Add/sub}

<<add/sub opcodes>>=
AADD,
ASUB,
@
%compiler: need add/sub for arithmetic obviously, so numeric algorithms,
% but need arithmetic for lots of 
% things, including access to more complex data structures like
% fields of struct (need add offset to a base)

<<[[itab]] elements>>=
"ADD",		LARITH,	AADD,
"SUB",		LARITH,	ASUB,
@




\ifallcode
<<logic opcodes>>=
ABIC,
@
<<add/sub opcodes>>=
ARSB,
AADC,
ASBC,
ARSC,
@
<<[[itab]] elements>>=
"BIC",		LARITH,	ABIC,
"RSB",		LARITH,	ARSB,
"ADC",		LARITH,	AADC,
"SBC",		LARITH,	ASBC,
"RSC",		LARITH,	ARSC,
@
\fi




% see also Comparison section, part of Arith opcode
% in Machine.nw, as well as simple MOV


\subsubsection{Bit shift}

<<bitshift opcodes>>=
ASRL,
ASRA,
ASLL,
@
% virtual/fake opcodes? transformed in something using shift?
%compiler: used in this file actually :) also useful for
% multiplication optimisation (when power of 2)

<<[[itab]] elements>>=
"SLL",		LARITH,	ASLL,
"SRL",		LARITH,	ASRL,
"SRA",		LARITH,	ASRA,
@

\subsubsection{Mul/div/mod}

<<mul/div/mod opcodes>>=
AMUL,
ADIV, // VIRTUAL, transformed to call to _div
AMOD, // VIRTUAL, transformed to call to _mod
@
% ARM has no ADIV or AMOD so virtual/fake-opcode again?
% compiler: need also mul for array access, need base + idx * size of entry.
%  for pointer arithmetic in general!

<<[[itab]] elements>>=
"MUL",		LARITH, AMUL,
"DIV",		LARITH,	ADIV,
"MOD",		LARITH,	AMOD,
@



\subsubsection{Comparison}
%note: was actually part of arithmetic in Machine.nw so
% kinda make sense to put it here too, though
% it has some logic too to put it just before branching

<<comparison opcodes>>=
ATST,
ATEQ,
ACMP,
@
%compiler: if, while, they all need to compare values
% and they need to act on it (see also branching)
%todo: (but why 3 different tests? one not enough?)

<<[[itab]] elements>>=
"CMP",		LCMP,	ACMP,
"TST",		LCMP,	ATST,
"TEQ",		LCMP,	ATEQ,
@


<<inst rule(arm)>>=
/*
 * CMP
 */
| LCMP cond imsr ',' spreg { outcode($1, $2, &$3, $5, &nullgen); }
@
%$

\ifallcode
<<comparison opcodes>>=
ACMN,
@
% CMP negative
<<[[itab]] elements>>=
"CMN",		LCMP,	ACMN,
@
\fi


\subsection{Memory}

% ARM has load/store, but plan9 has MOV as a virtual/fake-opcode.

<<mov opcodes>>=
AMOVW, // VIRTUAL, transformed in load and store instructions
@
% compiler: machine is von newman model, memory is everything.
% store simple data(int), complex (aggregate), store results, 
% store pointers! need powerful memory assign.

<<mov opcodes>>=
AMOVB,
AMOVBU,
AMOVH,
AMOVHU,
@


<<[[itab]] elements>>=
"MOVW",		LMOV, AMOVW,
"MOVB",		LMOV, AMOVB,
"MOVBU",	LMOV, AMOVBU,
"MOVH",		LMOV, AMOVH,
"MOVHU",	LMOV, AMOVHU,
@


<<inst rule(arm)>>=
/*
 * MOVW
 */
| LMOV cond gen ',' gen { outcode($1, $2, &$3, R_NONE, &$5); }
@
% gen for general?

% But even if the grammar rule below looks very general, allowing to
% do things like MOVW $1, 4(FP), the linker will actually
% not accept that. The linker forces to decompose in two instructions
% MOVW $1, R1, and then MOVW R1, 4(FP), which is closer to
% what the ARM accept, simple load and store.
% See optab possibilities for AMOVW.

% can do e.g. MOVW R2, (R3)?
% with the load/store of ARM it would be: LOAD R3, R4; store R2, R4?




\ifallcode
% optional? not used a single time in arm/*.s, used a bit in 5c/
<<mov opcodes>>=
AMVN,
@
% MOV negative
%//AMOV, redundant with the other MOV operations
<<[[itab]] elements>>=
"MVN",		LMVN, AMVN,	/* op2 ignored */
@
<<inst rule(arm)>>=
/*
 * MVN
 */
| LMVN cond imsr ',' reg { outcode($1, $2, &$3, R_NONE, &$5); }
@
\fi




%\subsubsection{Swap}
%\subsection{Special}
% mv in advanced topics? or merge with memory section? Like
% I did for Machine.nw?

<<swap opcodes>>=
ASWPW,
ASWPBU,
@
% used in _tas so maybe a special system-like instruction?

<<[[itab]] elements>>=
"SWPW",		LSWAP, ASWPW,
"SWPBU",	LSWAP, ASWPBU,
@

<<inst rule(arm)>>=
/*
 * SWAP
 */
| LSWAP cond reg ',' ireg ',' reg { outcode($1, $2, &$5, $3.reg, &$7); }
| LSWAP cond reg ',' ireg         { outcode($1, $2, &$5, $3.reg, &$3); }
| LSWAP cond ireg ',' reg         { outcode($1, $2, &$3, $5.reg, &$5); }
@
%$



\subsection{Branching}
% rename control flow?
% could split in two, with B and then BL and RET?
% called JMP/CALL in 8a

<<branching opcodes>>=
AB,
ABL, // branch and link, =~ CALL
@
% compiler: if, while, for, switch, they all rely on the
% very basic building block of jmp, conditional or not (goto xxx, if(yyy))

% BL is ARM specific opti for CALL to leaf functions. Branch and Link.

<<[[itab]] elements>>=
"B",		LBRANCH, AB,
"BL",		LBRANCH, ABL,
@


<<inst rule(arm)>>=
/*
 * B/BL
 */
| LBRANCH cond rel   { outcode($1, $2, &nullgen, R_NONE, &$3); }
| LBRANCH cond nireg { outcode($1, $2, &nullgen, R_NONE, &$3); }
@

% B of name? of TEXT or label? both?
% in 'rel' it's just label! so BL foo_ret_lbl (and D_BRANCH)
% in 'nireg' it's name so it can be BL foo+0(SB) (and D_OREG)

<<branching opcodes>>=
/* 
 * Do not reorder or fragment the conditional branch 
 * opcodes, or the predication code will break 
 */ 
// VIRTUAL, AB derivatives with condition code, see 5i/
ABEQ,
ABNE,
ABHS,
ABLO,
ABMI,
ABPL,
ABVS,
ABVC,
ABHI,
ABLS,
ABGE,
ABLT,
ABGT,
ABLE,
//ABAL? (always) done via AB, ABNV (never) done via ANOP probably
@
%old: got rid of ABCS and ABCC, seems redundant
% and does not match the ARM convention
% ABCS,//not in 5i/cond, seems equivalent to ABHS
% ABCC,//not in 5i/cond, seems equivalent to ABLO

<<[[itab]] elements>>=
"BEQ",		LBCOND,	ABEQ,
"BNE",		LBCOND,	ABNE,
"BHS",		LBCOND,	ABHS,
"BLO",		LBCOND,	ABLO,
"BMI",		LBCOND,	ABMI,
"BPL",		LBCOND,	ABPL,
"BVS",		LBCOND,	ABVS,
"BVC",		LBCOND,	ABVC,
"BHI",		LBCOND,	ABHI,
"BLS",		LBCOND,	ABLS,
"BGE",		LBCOND,	ABGE,
"BLT",		LBCOND,	ABLT,
"BGT",		LBCOND,	ABGT,
"BLE",		LBCOND,	ABLE,
@

<<inst rule(arm)>>=
/*
 * BEQ/...
 */
| LBCOND rel { outcode($1, Always, &nullgen, R_NONE, &$2); }
@




<<branching opcodes>>=
ARET, // VIRTUAL, transformed to B (R14) or MOV xxx(SP), R15
@
% actually no RET in ARM, so virtual/fake-opcode

<<[[itab]] elements>>=
"RET",		LRET, ARET,
@

<<inst rule(arm)>>=
/*
 * RET
 */
| LRET cond { outcode($1, $2, &nullgen, R_NONE, &nullgen); }
@
% because of B and BL (and as we will see in 5l STEXT and SLEAF),
% it's convenient to have a general way to return from a procedure
% whether it was a leaf or not. The machine can handle the specifics for us!

\subsection{Software interrupt}
% software interrupt, aka syscall
% interrupts and exceptions

<<interrupt opcodes>>=
ASWI, // syscall
@
% kernel/user! fundamental API of assembly! the bridge!
% open then the door for user process to access real hardware
% (but in supervised mode of course)

<<[[itab]] elements>>=
"SWI",		LSWI, ASWI,
@

<<inst rule(arm)>>=
/*
 * SWI
 */
| LSWI cond { outcode($1, $2, &nullgen, R_NONE, &nullgen); }
@
%$
%old: | LTYPE6 cond comma gen { outcode($1, $2, &nullgen, R_NONE, &$4); }
% but not sure it needs an argument in plan9 context,
% and anyway was doing stupid things like SWI 0  in 9syscall/mkfile
% which was weird, at least should be SWI $0
%\ifallcode
%<<inst rule(arm)>>=
%| LSWI cond gen { outcode($1, $2, &nullgen, R_NONE, &nullgen); }
%@
%%$
%\fi
%% just so can test things with kencc/5a, ignore actually the last argument
%% otherwise the linker will fail.




<<interrupt opcodes>>=
ARFE, // VIRTUAL, return from exception/interrupt, MOVM.IA.S.W (R13), [R15]
@

<<[[itab]] elements>>=
"RFE",		LRET, ARFE,
@
% same grammar rule than RET
% =~ IRET
%in lproc.s 
%	RFE				/* MOVM.IA.S.W (R13), [R15] */



\section{Label definitions and [[pc]]}
\label{sec:label-def}

% this is incremented in outcode() after each instruction 
% (except for ADATA and AGLOBL)
% less: even ATEXT increments PC? hmm maybe simpler that way
<<global pc>>=
long	pc;
@

<<line rule(arm)>>=
| LNAME ':'
 {
  $1->type = LLAB;
  $1->value = pc;
 }
  line
@

% not context free grammar! modify lexer behavior from parser.
% similar in C for typedefs. ugly a bit,
<<line rule(arm)>>=
| LLAB ':'
 {
  if($1->value != pc)
   yyerror("redeclaration of %s", $1->name);
  $1->value = pc;
 }
  line
@
%$

% note that labels are different from ATEXT! they are local
% to the file, and so lead to local jmps. no need to relocate
% those names (well actually we relocate them in 5l when
% we put each object one after another, see the 'ipc' local variable)

\section{Operands}

% this is the rest from the %union
<<[[Token]] other fields(arm)>>=
Gen    gen;
@
% hmmm maybe confusing to have gen field and Gen type and gen grammar rule?

% reg = register
% imm = immediate
% shift = shifted register or constant

% imsr = immediate or shift or register

<<type declarations(arm)>>=
%type   <gen> imsr
@

% e.g. for first operand of ADD
<<operand rules(arm)>>=
imsr:
  imm
| shift
| reg
@

<<type declarations(arm)>>=
%type   <gen> imm shift reg
@


% better to put gen rule here instead of rule about memory dereference.
% That matches closely at first imsr with reg, ximm and shift.



<<type declarations(arm)>>=
%type   <gen>   gen 
@
% gen? general? 
% arguments to MOV have less restrictions


\ifallcode
<<operand rules(arm)>>=
<<gen rule>>
<<spreg rule(arm)>>
<<sreg rule(arm)>>
@
<<misc rules>>=
<<oreg rule>>
@
<<operand rules(arm)>>=
<<ximm rule>>
@
\fi


<<gen rule>>=
gen:
  ximm
| shift
| reg
@
% so close to imsr. close except ximm instead of imm (extended immediate).
% see below.
% and also will see later than the gen rule will grow

<<type declarations(arm)>>=
%type   <gen>   ximm
@



\subsection{Registers}

%<<operand_kind cases>>=
%D_REG,
%@
% works with Gen structure, as shown below

<<operand rules(arm)>>=
reg:
 spreg
 {
  $$ = nullgen;
  $$.type = D_REG;
  $$.reg = $1;
 }
@
%$

% lval but really enum<registr>
<<type declarations(arm)>>=
%type   <lval>  sreg spreg 
@

<<spreg rule(arm)>>=
spreg:
  sreg
@


<<sreg rule(arm)>>=
sreg:
  LREG
| LR '(' expr ')'
 {
  if($3 < 0 || $3 >= NREG)
      print("register value out of range\n");
  $$ = $3;
 }
@
%$
\t s? 
\l expr! see later

<<[[itab]] elements>>=
"R0",		LREG,	0,
"R1",		LREG,	1,
"R2",		LREG,	2,
"R3",		LREG,	3,
"R4",		LREG,	4,
"R5",		LREG,	5,
"R6",		LREG,	6,
"R7",		LREG,	7,
"R8",		LREG,	8,
"R9",		LREG,	9,
"R10",		LREG,	10,
"R11",		LREG,	11,
"R12",		LREG,	12,
"R13",		LREG,	13,
"R14",		LREG,	14,
"R15",		LREG,	15,
@

<<[[itab]] elements>>=
"R",		LR,	0,
@

% note that different from pseudo register!


%XXX
<<spreg rule(arm)>>=
| LSP { $$ = REGSP; }
@
%$
% why another one again? in which context we don't accept LSP?
% and also in which context we don't accept LPC?

<<sreg rule(arm)>>=
| LPC { $$ = REGPC; }
@
%$
% why 2 rules? anyway people can use R13 to encode LSP so why
% not have a simple reg rule that allows all those registers directly?

\subsection{Immediate constants}

% con = constant
% prefix with $ (why? ambiguity with what?) to differentiate
% with just con where it's a omem (see section below)

%<<operand_kind cases>>=
%D_CONST,
%@
%in core ds now

<<operand rules(arm)>>=
imm: '$' con
 {
  $$ = nullgen;
  $$.type = D_CONST;
  $$.offset = $2;
 }
@
% offset is bad field name. maybe a union with value would be nice.

% see con section below, essentially static-time integer constants
% (not float, not string)

<<con rule>>=
con:
  LCONST
@

% float constants are in another category, actually they
% are allowed only for ximm and so for MOV and DATA categories.



% this is used for MOV of course, because of gen, but also
% for DATA, WORD
<<ximm rule>>=
ximm:
  '$' con
 {
  $$ = nullgen;
  $$.type = D_CONST;
  $$.offset = $2;
 }
@
% see later the extension, MOV allows more forms of constants
% (e.g. string constants, float constants)

\subsection{Shift registers}
% register and constant in some sense
% mv in advanced topics?

<<operand_kind cases>>=
D_SHIFT,
@

<<operand rules(arm)>>=
shift:
 spreg '<' '<' rcon
 {
  $$ = nullgen;
  $$.type = D_SHIFT;
  $$.offset = $1 | $4 | (0 << 5);
 }
| spreg '>' '>' rcon
 {
  $$ = nullgen;
  $$.type = D_SHIFT;
  $$.offset = $1 | $4 | (1 << 5);
 }
| spreg '-' '>' rcon
 {
  $$ = nullgen;
  $$.type = D_SHIFT;
  $$.offset = $1 | $4 | (2 << 5);
 }
| spreg LAT '>' rcon
 {
  $$ = nullgen;
  $$.type = D_SHIFT;
  $$.offset = $1 | $4 | (3 << 5);
 }
@

<<[[itab]] elements>>=
"@",		LAT,	0,
@
% hmm could remove @ from the identifier lexing section,
% so then could just do '@' '>' instead of this indirection


<<type declarations(arm)>>=
%type   <lval>  rcon
@

% rcon, register or constant, spreg = sp or general register
<<helper rules(arm)>>=
rcon:
  spreg
 {
  if($$ < 0 || $$ >= NREG)
      print("register value out of range\n");
  $$ = (($1&15) << 8) | (1 << 4);
 }
| con
 {
  if($$ < 0 || $$ >= 32)
      print("shift value out of range\n");
  $$ = ($1&31) << 7;
 }
@
% really does too much work here and close to ARM concrete bits

\subsection{Memory (de)references, pointers}
% indirect addressing?
% was "Memory references"
% arguments to MOVW
% Pointers? or Memory dereference actually? or both :)

% O_REG = offset reg?
%<<operand_kind cases>>=
%D_OREG,
%@
% when do MOV R1, (R2) => means in cell pointer by R2, so
% it's really like *r2 = r1

% offset reg, indirect reg, indirect or offset reg, name indirect reg 
% see section ref manual on different addressing modes

% start of difference with imsr!
<<gen rule>>=
| oreg
@

<<type declarations(arm)>>=
%type   <gen> oreg ioreg ireg nireg 
@

% oreg? offset reg? 
<<oreg rule>>=
oreg:
  ioreg
@

% indirect or offset reg
<<misc rules>>=
ioreg:
  ireg
| con '(' sreg ')'
 {
  $$ = nullgen;
  $$.type = D_OREG;
  $$.reg = $3;
  $$.offset = $1;
 }
@


% ireg? indirect reg? 
% used from ioreg (and so gen), and also specifically from SWAP
<<misc rules>>=
ireg:
 '(' spreg ')'
 {
  $$ = nullgen;
  $$.type = D_OREG;
  $$.reg = $2;
  $$.offset = 0;
 }
@
%$




\subsection{Named memory locations}
% (different from labels, which are just for code refs)


% part of oreg? name is an offset to a reg?
% Actually a name is really a constant offset to a base like LSB!!
% it's implicitly a dereference so foo is really foo(SB); you want
% $foo to get the actual address (and not content)
<<oreg rule>>=
| name
@


% for BL, in addition to rel, can also have nireg
<<misc rules>>=
nireg:
  name
| ireg
@
%$
%old: had a if with nothing in it, weird
%  name
% {
%  $$ = $1;
%  if($1.name != D_EXTERN && $1.name != D_STATIC) {
%  }
% }

% BL ireg means have no idea where it jmps ... can this
% create bugs in 5l that statically tries to find the necessary code?
% well the address of a function should be taken somewhere so
% the function should be considered unless one does really crazy
% magic stuff.





<<type declarations(arm)>>=
%type   <gen>   name 
%type   <lval>  pointer
@
% name is an operand argument for BL (via nireg), but also
% for TEXT, and also for MOV (via oreg)

\ifallcode
<<operand rules(arm)>>=
<<name rule>>
@
\fi


<<name rule>>=
name:
  LNAME offset '(' pointer ')'
 {
  $$ = nullgen;
  $$.type = D_OREG;
  $$.sym = $1;
  $$.symkind = $4;
  $$.offset = $2;
 }
@
%$

% for TEXT foo(SB), ... or GLOBL. Definitions of names.
% and also for references to names, like MOV count(SB), R1
% (to get address of count? no, to get address you need $count(SB))
% no LLAB here!

% (ab)used also in reference to parameters, as in
% MOVL    count+8(FP), CX
% the LNAME here is really just a symbol for debugging help.
%less: actually maybe it's not just that, maybe you can
% then do $count to get the address of this parameter?


% the con (pointer) of 'name:' is not ambiguous with the con (sreg)
% of 'oreg:'? no because pointer != sreg (well even if R12 is actually
% LSB ...)

% hmmm bad name? pointer_basis? but it's true we do '(' pointer ')'
% where we really dereference the pointer (and then add an offset)
<<helper rules(arm)>>=
pointer:
  LSB
| LSP
| LFP
@

<<[[itab]] elements>>=
"SB",		LSB,	D_EXTERN,
"SP",		LSP,	D_AUTO,
"FP",		LFP,	D_PARAM,
@


% can do 
%	BL	div(SB)  so it's SB but it's really a code reference

%<<sym_kind cases>>=
%D_EXTERN, // text/data/bss values (from SB)
%D_AUTO,   // stack values (from SP)
%D_PARAM,  // parameter (from FP)
%@


<<helper rules(arm)>>=
offset:
 /* empty */ { $$ = 0; }
| '+' con    { $$ = $2; }
| '-' con    { $$ = -$2; }
@
%$
%less: rename offset_opt?



%section{Static names?, local names?}

<<name rule>>=
| LNAME '<' '>' offset '(' LSB ')'
 {
  $$ = nullgen;
  $$.type = D_OREG;
  $$.sym = $1;
  $$.symkind = D_STATIC;
  $$.offset = $4;
 }
@
%$

<<sym_kind cases>>=
D_STATIC, // data static variables (from SB)
@

% well this is not really a name ...
<<name rule>>=
| con '(' pointer ')'
 {
  $$ = nullgen;
  $$.type = D_OREG;
  $$.sym = S;
  $$.symkind = $3;
  $$.offset = $1;
 }
@
%$
% could delete that too? hmm no, it's for anonymous params like 4(FP)




<<ximm rule>>=
| '$' name
 {
  $$ = $2;
  $$.type = D_CONST;
 }
@
%old: was $ oreg, but i think it makes more sense to have just '$' name
%less: a special D_ADDR instead of abusing D_CONST?

% a bit confusing that can have gen -> oreg, and also gen -> ximm -> $ oreg
% because MOV support powerful addressing modes? with multiple
% indirections?


\subsection{Code references and label uses}
% hmm con(PC) is not really named code

<<operand_kind cases>>=
D_BRANCH,
@
%/* type */ FOR BRANCH


<<[[itab]] elements>>=
"PC",		LPC,	D_BRANCH,
@

<<type declarations(arm)>>=
%type   <gen>   rel
%type   <lval>  offset
@

% rel = ? relocatable? relative?, argument of B/BL
% Relative because it's labels which are locals to a file and can be
% resolved locally (no need symbols), but at the same time they will
% also need to be relocated when all objects are attached after each
% other
% (and the offset value is actually not relative to the current PC,
% it's an absolute value, so it probably means more relocatable than
% relative in the end)

\ifallcode
<<operand rules(arm)>>=
<<rel rule>>
@
\fi

<<rel rule>>=
rel:
  LLAB offset
 {
  $$ = nullgen;
  $$.type = D_BRANCH;
  $$.sym = $1;
  $$.offset = $1->value + $2;
 }
@
%$
% branch are relative to current PC for ARM, but here
% we deal with more absolute address.

% it's an offset in the sense that it's like a 'LLAB offset (starting_pc)'
% so offset to basis, which should be zero for this assembly
% (and when link will actually be relocated).

% there is also nirel where can use a name instead of a label


% when label is declared later, the symbol table does not know
% yet that it's an LLABL, see section on labels below.
<<rel rule>>=
| LNAME offset
 {
  $$ = nullgen;
  if(pass == 2)
      yyerror("undefined label: %s", $1->name);
  $$.type = D_BRANCH;
  $$.sym = $1;
  $$.offset = $2;
 }
@
%less: if pass == 1 why care about setting the field values?
% anyway outcode will not use the value


<<rel rule>>=
| con '(' LPC ')'
 {
  $$ = nullgen;
  $$.type = D_BRANCH;
  $$.offset = $1 + pc;
 }
@
%$
% need that? we have code using relative jmp?
% anyway if do  B 4(PC) it will jump one instruction?



\subsection{String constants}
%\subsection{Other forms}

%<<operand_kind cases>>=
%D_SCONST,
%@
% string constant


<<ximm rule>>=
| '$' LSCONST
 {
  $$ = nullgen;
  $$.type = D_SCONST;
  memcpy($$.sval, $2, sizeof($$.sval));
 }
@


%<<operand_kind cases>>=
%D_OCONST,
%@
%<<ximm rule>>=
%| '$' '*' '$' oreg
% {
%  $$ = $4;
%  $$.type = D_OCONST;
% }
%@
%%$
% seems unused in ARM/*.s


%<<gen rule>>=
%| con
% {
%  $$ = nullgen;
%  $$.type = D_OREG;
%  $$.offset = $1;
% }
%@
%%$
% no $ in front of con here?
% was used in 9syscall for 'SWI 0' but not sure what it meant.
% how can be D_OREG when there are no registers involved.
% I removed the rule, and rewrote calls to SWI to just be SWI

%<<gen rule>>=
%| shift '(' spreg ')'
% {
%  $$ = $1;
%  $$.reg = $3;
% }
%@

%<<oreg rule>>=
%| name '(' sreg ')'
% {
%  $$ = $1;
%  $$.type = D_OREG;
%  $$.reg = $3;
% }
%@
% but name already has some (sreg), so what this rule mean?
% foo(PC)(PC) ??
% sreg, so can't use FP here, nor LSB, so only name refering to PC?




\section{Pseudo-instructions}
% aka assembly directives

\subsection{[[TEXT/GLOBL]]}

% declare symbols, names, that other can either call (BL) or 
% access (MOVW).

<<pseudo opcodes>>=
ATEXT,
AGLOBL,
@

<<[[itab]] elements>>=
"TEXT",		LDEF, ATEXT,
"GLOBL",	LDEF, AGLOBL,
@

<<inst rule(arm)>>=
/*
 * TEXT/GLOBL
 */
| LDEF name ',' imm         { outcode($1, Always, &$2, R_NONE, &$4); }
| LDEF name ',' con ',' imm { outcode($1, Always, &$2, $4, &$6); }
@
%$
% pseudo-instr are kinda instr, operands too, symbol ref too

% TEXT is for procedures, code symbols, that will go in the TEXT section
% GLOBL is to declare data symbols (globals indeed), that will go in DATA sect

% TEXT foo(SB), 4, $4, semantic for those immediate value? to? 
% - size of the locals to reserve for TEXT
% - size of entity in the case of GLOBL?

% what is the middle con? for attributes? e.g. for NOPROF, DUPOK?
% but then what is 4 for??
% see Section in advanced topics

% the imm can be negative! so SP will be decrememted. This is useful
% for stuff that needs to access the parameter of the enclosing function?

% if look qemu.root.s from data2c result:
% e.g. 
% DATA boot_CONF_outcode+0(SB)/8, $"\z\z\1\353\z\z\213\33"
% ...
% DATA boot_CONF_outcode+67520(SB)/8, $"\1\201\1\z\z\z\z\z"
% GLOBL boot_CONF_outcode+0(SB), $67528
% DATA boot_CONF_outlen+0(SB)/4, $67523
% GLOBL boot_CONF_outlen+0(SB), $4


% in gasm I think it's
% .global foo
% .text
% foo:
%   <adjust SP>

\subsection{[[WORD/DATA]]}

<<pseudo opcodes>>=
ADATA,
AWORD,
@

<<[[itab]] elements>>=
"DATA",		LDATA, ADATA,
"WORD",		LWORD, AWORD,
@

<<inst rule(arm)>>=
/*
 * DATA
 */
| LDATA name '/' con ',' ximm { outcode($1, Always, &$2, $4, &$6); }
@

% DATA boot_CONF_outlen+0(SB)/4, $67523
% DATA boot_CONF_outcode+0(SB)/8, $"\z\z\1\353\z\z\213\33"
% hmm abuse reg for this constant, ugly. It's for boundaries =~
% local size for this chunk of DATA.

<<inst rule(arm)>>=
/*
 * WORD
 */
| LWORD ximm { outcode($1, Always, &nullgen, R_NONE, &$2); }
@
% kind of anonymous DATA? but used in TEXT so can
% write binary data that cannot be expressed by the assembler?
% no need /con here, it's always 4 (WORD).


\subsection{[[END]]}

<<pseudo opcodes>>=
AEND,
@
% not the same than ALAST

<<[[itab]] elements>>=
"END",		LEND, AEND,
@

<<inst rule(arm)>>=
/*
 * END
 */
| LEND { outcode($1, Always, &nullgen, R_NONE, &nullgen); }
@
%$
% also generated in cclean()

%\section{Special instructions}
%\subsection{[[NOP]]}
%\subsection{[[SHL/SHR]]}
%\subsection{[[MOVW/MOVL]]}
%\subsection{[[IMUL]]}

\section{Constant expressions}
\label{sec:constant-expr}

% it's not Fortran, we're making an assembler :)
% so it's constant expressions here!

<<type declarations(arm)>>=
%type   <lval>  con expr 
@

<<con rule>>=
| '-' con      { $$ = -$2; }
| '+' con      { $$ = $2; }
| '~' con      { $$ = ~$2; }
| '(' expr ')' { $$ = $2; }
@
%$

% convenient to have this, when combined with macros it
% can do powerful stuff!



<<priority and associativity declarations>>=
%left   '|'
%left   '^'
%left   '&'
%left   '<' '>'
%left   '+' '-'
%left   '*' '/' '%'
@
% lower in the file = higher priority, earlier = lower priority

<<constant expression rules>>=
<<con rule>>
<<expr rule>>
@

<<expr rule>>=
expr:
  con
| expr '+' expr     { $$ = $1 + $3; }
| expr '-' expr     { $$ = $1 - $3; }
| expr '*' expr     { $$ = $1 * $3; }
| expr '/' expr     { $$ = $1 / $3; }
| expr '%' expr     { $$ = $1 % $3; }
| expr '<' '<' expr { $$ = $1 << $4; }
| expr '>' '>' expr { $$ = $1 >> $4; }
| expr '&' expr     { $$ = $1 & $3; }
| expr '^' expr     { $$ = $1 ^ $3; }
| expr '|' expr     { $$ = $1 | $3; }

@





\section{Symbolic constants}
\n useful, meh cpp can do that too. Was originally called Var, hmm


<<line rule(arm)>>=
| LNAME '=' expr ';'
 {
  $1->type = LVAR;
  $1->value = $3;
 }
| LVAR '=' expr ';'
 {
  if($1->value != $3)
   yyerror("redeclaration of %s", $1->name);
  $1->value = $3;
 }
@

<<con rule>>=
| LVAR         { $$ = $1->value; }
@
%$

\section{Conditional execution}
\label{sec:cond-exec}

% seen most opcodes have this LTYPExxx cond op1, op2, ...

<<type declarations(arm)>>=
%type   <lval>  cond
@

<<cond rule(arm)>>=
cond:
  /* empty */ { $$ = Always; }
| cond LCOND  { $$ = ($1 & ~C_SCOND) | $2; }
@

<<constant C_SCOND(arm)>>=
/* scond byte */
#define	C_SCOND	((1<<4)-1)
@
% >>

<<[[itab]] elements>>=
".EQ",		LCOND,	0,
".NE",		LCOND,	1,
".CS",		LCOND,	2,
".HS",		LCOND,	2,
".CC",		LCOND,	3,
".LO",		LCOND,	3,
".MI",		LCOND,	4,
".PL",		LCOND,	5,
".VS",		LCOND,	6,
".VC",		LCOND,	7,
".HI",		LCOND,	8,
".LS",		LCOND,	9,
".GE",		LCOND,	10,
".LT",		LCOND,	11,
".GT",		LCOND,	12,
".LE",		LCOND,	13,
".AL",		LCOND,	Always,
@
%//Never = 15

% so BEQ is really B.EQ, but can also have MOV.EQ! ADD.LT, etc.

<<constant Always(arm)>>=
#define    Always 14
@
%less: use COND_ALWAYS now?




\ifallcode
\section{Optional commas}
% the optional ',' why? because asm can ge generated by 5c -S that does
% this. A bit ugly so maybe better to aspectize this.
% actually I removed most of the use of comma for 5a/a.y 
% so maybe could even remove this rule, or keep it
% just for the comment about 5c -S.

<<opt rules>>=
comma:
  /* empty */
| ',' comma
@
\fi

\section{[[yyparse()]]}

% essentially generated code by yacc, that is calling yylex







\chapter{Object Generation}
\label{chap:generation}

% it's object generation, not machine code generation ... 5l/optab.c does this.
% so see linker book for that.

% Note also that we must output code that will be part of a bigger set.
% An object is really a module, defining symbols and using external symbols.
% So the code we output can be relocated! so need to 
% output information about use of external symbols! 'U'
% (and also information about symbols the module defines! 'T', 'D')

\section{Object format}

% The format is very regular, essentially a list of instructions
% where each instruction is encoded as:
%  - opcode (1 byte)
%  - condition (1 byte)
%  - register (1 byte) (most instrs have at least one register operand)
%    (also abused to encode some symbol attributes, e.g. DUPOK)
%  - line  (4 bytes)
%  - operand1
%  - operand2
%  where the operands depending on the operand_kind can actually have
%  different size. The register above is a kind of operand3.
%
% the operands themselves have a specific format too
%  - operand_kind (D_CONST, D_REG, etc)
%  - register (again) if any
%  - symidx if any (for D_OREG, and also D_CONST (but really D_ADDR))
%  - symkind if any (for the same)
%  - variable size data, nothing for D_REG, offset for D_OREG, 
%    float for D_FLOAT, string for D_SCONST, ...

%TODO: figure!!

% Then spreaded among those instructions are also symbol table
% entries, using a weird scheme
% ANAME: symkind (1 byte), symidx (1 byte), string finished by \0
% (hmm the symkind might be redundant then if it's already listed
%  as part of the operand? no, it's because of the spreaded symbol
%  table scheme)

% the header is really just a set of ANAME and AHISTORY, and
% AHISTORY use the same format than other instructions.

% 5l then read back this format in a simple loop reading one
% instruction at a time and maintaing the symbol table information
% via the ANAME.

\section{Instruction output, [[outcode()]]}

% used for all opcodes, even pseudo opcodes.
% very generic form, 3 operands (but many times they
% are equivalent to a None).

% scond is cond bits and also special bits
% less: rename reg to reg3? so less confusing with reg in zaddr?
<<function outcode(arm)>>=
void
outcode(int opcode, int scond,  Gen *g1, int reg, Gen *g2)
{
    <<[[outcode()]] locals>>

    <<[[outcode()]] adjust opcode and scond when opcode is AB>>

    if(pass == 1)
        goto out;

    <<[[outcode()]] st and sf computation, and possible calls to zname>>

    // Instruction serialized format: opcode, cond, optional reg, line, operands
    Bputc(&obuf, opcode);
    Bputc(&obuf, scond);
    Bputc(&obuf, reg);
    Bputc(&obuf, lineno);
    Bputc(&obuf, lineno>>8);
    Bputc(&obuf, lineno>>16);
    Bputc(&obuf, lineno>>24);
    zaddr(g1, sf);
    zaddr(g2, st);

out:
    if(opcode != AGLOBL && opcode != ADATA)
        pc++;
}
@
% skip pc++ for AGLOBL and ADATA because those pseudo ops concern
% the DATA section, not the TEXT section.
% WORD is for the TEXT section too!
%note: I renamed a to opcode

% note that output line number here! useful for debugging information,
% to be ablt to go back from one instruction to the actual code!
% (but lineno after #include expansion, see outhist() section
% later so one can get from lineno to actual file+lineno


<<[[outcode()]] adjust opcode and scond when opcode is AB>>=
/* hack to make B.NE etc. work: turn it into the corresponding conditional*/
if(opcode == AB){
    opcode = bcode[scond&0xf];
    scond = (scond & ~0xf) | Always;
}
@
% so B.NE get translated in BNE. Not that important though,
% again this feature could be removed.

<<global bcode(arm)>>=
static int bcode[] =
{
    ABEQ,
    ABNE,
    ABHS,
    ABLO,
    ABMI,
    ABPL,
    ABVS,
    ABVC,
    ABHI,
    ABLS,
    ABGE,
    ABLT,
    ABGT,
    ABLE,
    AB,
    ANOP,
};
@



\section{Operand output, [[outopd()]]}

% outcode -> <>
% less: rename? out_operand?
% s is index in h[] for symbol involved in the operand?
% or 0 if no symbol involved for this operand?
<<function zaddr(arm)>>=
void
zaddr(Gen *a, int symidx)
{
    <<[[zaddr()]] locals>>

    // operand format: operand kind, register, symidx, symkind, optional offset
    Bputc(&obuf, a->type);
    Bputc(&obuf, a->reg);
    // idx in symbol table, 0 if no symbol involved in the operand
    Bputc(&obuf, symidx);
    // symkind of the symbol, if any
    Bputc(&obuf, a->symkind);

    switch(a->type) {
    <<[[zaddr()]] cases>>
    default:
        print("unknown type %d\n", a->type);
        exits("arg");

    }
}
@

\ifallcode
<<[[zaddr()]] locals>>=
long l;
char *n;
Ieee e;
int i;
@
\fi

<<[[zaddr()]] cases>>=
case D_NONE:
    break;

case D_REG:
case D_PSR:
    break;

case D_CONST:
case D_OREG:
case D_BRANCH:
case D_SHIFT:
    l = a->offset;
    Bputc(&obuf, l);
    Bputc(&obuf, l>>8);
    Bputc(&obuf, l>>16);
    Bputc(&obuf, l>>24);
    break;

case D_SCONST:
    n = a->sval;
    for(i=0; i<NSNAME; i++) {
        Bputc(&obuf, *n);
        n++;
    }
    break;
@

% from 5.out.h and 8.out.h
<<constant NSNAME>>=
#define	NSNAME		8
@


\section{Symbol table, [[h]] and [[ANAME]]}
\label{sec:symbols-out}
%note: we could put Htab in Core DS, h is reset in pinit(), but it's
% really just local to the Output code generation so I think
% it is better to put this DS here I think.

% When an operand involves a symbol, the generated operand code 
% contain an int that is an index in a symbol table! See zaddr().

% the way this symbol table is stored in the object file is a bit
% tricky. They could have put the table at the beginning
% of the file (I think it would have been simpler). Instead
% the symbol table is spreaded in the object file and they use
% a circular array scheme.


% so among all those instructions there are some symbol table
% elements, ANAME.

<<pseudo opcodes>>=
ANAME,
@
% could be renamed ASYM

%old: if ANAME is after AHISTORY in 5.out.h then got
% some bugs in ar such as "inconsistent file xxx.5 in libc.a"
%update: maybe it was because the Makefile pb where actually
% libmach was not recompiled?

% outcode -> <>
% for operands involving symbols.
% less: rename? out_symbol_reference?
<<function zname(arm)>>=
void
zname(char *n, int symkind, int symidx)
{

    Bputc(&obuf, ANAME);
    Bputc(&obuf, symkind);	/* type */
    Bputc(&obuf, symidx);	/* sym */
    while(*n) {
        Bputc(&obuf, *n);
        n++;
    }
    Bputc(&obuf, '\0');
}
@
% note that labels do not generate code, they are local to the .o
% and used to compute offsets (pc). TEXT/GLOBL generate symbols defs
% and other opcodes generate symbol uses.

% symidx may seem weird, why need idx if store the symbol entries
% one after the other?


<<struct Htab>>=
struct Htab
{
    // ref<Sym>>
    Sym*	sym;
    //enum<sym_kind>
    short	symkind;
};
@
%old: I rename 'type' to symkind, to avoid confusion with Gen.type.
% Htab is a sliced subset of Sym but just for the symbols 
% (and an array insteaf of a hash)

<<constant NSYM>>=
#define	NSYM	50
@
% limit on number of unresolved external symbols? Nope.
% note: need to be < 256 as currently use Bputc to marshall 
%  symbol indexes in zaddr().


% starts to be used at index 1, as 0 is used as index for none symbol.
<<global h>>=
// array<ref<Sym>>
struct Htab h[NSYM];
@
% why call it h when really it's an array ...

% h is an optimisation to avoid generating too many ANAME? But
% why not a symbol table at the beginning of the file? why spread it?
% because that way can use 1 byte for symbol idx and still have
% infinite possibilities! tricky.

% next free entry in h (actually can be reseted to 1)
<<global symcounter>>=
int	symcounter;
@
%less: why not char instead? like symidx (or better byte)
%old: was called sym, but I renamed it to avoid overloading the sym name
% (as a global, as a field)

<<[[Sym]] identifier value fields>>=
// index in h when the Sym is really a symbol, 0 when not a symbol
int	symidx;
@
\label{sec:symidx-sym-field}

%old: was called 'sym', but really it's an index in h, and it was confusing
% to have so many fields called sym already (as well as the global sym)
% char enough??
%old: was char, but in many places they use int for symcounter so I use int
% there too now


<<[[pinit]] symcounter and h initialisation>>=
symcounter = 1;
for(i=0; i<NSYM; i++) {
    h[i].symkind = 0; // N_NONE
    h[i].sym = S;
}
@






<<[[outcode()]] locals>>=
// symbol from, index in h[]
int sf;
// symbol to, index in h[]
int st;
// enum<sym_kind>
int symkind;
Sym *s;
@


% TODO LP split and transform while into if, easier flow
% and also can maybe factorize code?
<<[[outcode()]] st and sf computation, and possible calls to zname>>=
jackpot:

sf = 0;
s = g1->sym;

while(s != S) {
    sf = s->symidx;

    if(sf < 0 || sf >= NSYM)
        sf = 0;

    symkind = g1->symkind;

    // already generated an ANAME for this symbol reference
    if(h[sf].symkind == symkind)
     if(h[sf].sym == s)
        break;

    s->symidx = symcounter;
    h[symcounter].sym = s;
    h[symcounter].symkind = symkind;
    sf = symcounter;
    zname(s->name, symkind, symcounter);

    symcounter++;
    if(symcounter >= NSYM)
        symcounter = 1;
    break;
}

st = 0;
s = g2->sym;

while(s != S) {
    st = s->symidx;

    if(st < 0 || st >= NSYM)
        st = 0;

    symkind = g2->symkind;

    if(h[st].symkind == symkind)
      if(h[st].sym == s)
        break;

    s->symidx = symcounter;
    h[symcounter].sym = s;
    h[symcounter].symkind = symkind;
    st = symcounter;
    zname(s->name, symkind, symcounter);

    symcounter++;
    if(symcounter >= NSYM)
        symcounter = 1;

    if(st == sf)
        goto jackpot;
    break;
}
@
% when jackpot can happen? 
% if the first operand involved for instance a symbol with for index 41
% and that the second operand involves a symbol not
% yet seen and that the next free index turns out to be 41, 
% then h[41].sym will change but sf now points to a wrong entry
% and so you have to recompute sf.
% this is very very subtle (too subtle I think).

% replace by:
%sf = symidx_of_symopt(g1->sym);
%st = symidx_of_symopt(g2->sym);
% if (sf == st && sf != 0 && symcounter actually changed) goto jackpot;
%  (otherwise could loop on MOVW bar(SB), bar(SB)

\section{File and line information, [[outhist()]] and [[AHISTORY]]}
%note: was called Header section, but
% it's not really an header in traditional sense,
% the object could be parsed without those AHISTORY and ANAME I think.
%less: have a Debugging support section? where put lineno of outcode()
% there?

%todo: use 5l -v -W to see those AHISTORY and ANAME; it can help
% debug things

<<pseudo opcodes>>=
AHISTORY,
@
% history? because trace history of a line if comes from some #include?

% maybe good to take simplest case where have no #include,
% then what will be the output?


<<sym_kind cases>>=
D_FILE,
@




% main -> assemble -> <> (at begining of pass 2)
<<function outhist(arm)>>=
void
outhist(void)
{
    Gen g;
    Hist *h;
    char *p, *op;
    char *q;
    int n;

    g = nullgen;
    for(h = hist; h != H; h = h->link) {
        p = h->filename;

        <<[[outhist()]] adjust p and op if p is relative filename>>
        <<[[outhist()]] output each path component as an ANAME>>
        g.offset = h->local_line;

        Bputc(&obuf, AHISTORY);
        Bputc(&obuf, Always);
        Bputc(&obuf, 0); // reg, but could be R_NONE actually
        Bputc(&obuf, h->line);
        Bputc(&obuf, h->line>>8);
        Bputc(&obuf, h->line>>16);
        Bputc(&obuf, h->line>>24);
        zaddr(&nullgen, 0);
        zaddr(&g, 0);
    }
}
@
% bug???? g.offset is used? do zaddr(&g, 0) but g.type = D_NONE
% at this point which means the offset will not be used.
% look at linker reading back code, excpect a D_CONST here?
% this code works for 8a, but not for 5a because zaddr() is
% different there.

% remember that output lineno for each instruction!

<<[[outhist()]] adjust p and op if p is relative filename>>=
op = nil;
if(p && p[0] != '/' && h->local_line == 0 && pathname){
    if(pathname[0] == '/'){
        op = p;
        p = pathname;
    }
}
@

<<[[outhist()]] output each path component as an ANAME>>=
while(p) {
    q = strchr(p, '/');
    if(q) {
        n = q-p;
        if(n == 0){
            n = 1;	/* leading "/" */
            *p = '/';
        }
        q++;
    } else {
        n = strlen(p);
        q = nil;
    }

    if(n) {
        Bputc(&obuf, ANAME);
        Bputc(&obuf, D_FILE);	/* type */ // symkind
        Bputc(&obuf, 1);	    /* sym */  // symidx
        Bputc(&obuf, '<');
        Bwrite(&obuf, p, n);
        Bputc(&obuf, '\0');
    }
    p = q;
    if(p == nil && op) {
        p = op;
        op = nil;
    }
}
@
% why print each directory path separately?

\chapter{Debugging Support}
\label{chap:debugging}

% db has access to awesome metadata generated by 8s (and also 8c).

%  main(argv=...) /home/pad/.../main.c called from _main+26 (.../main9.s:12)

% put here the +sp, +xxx locals/params format





\chapter{Advanced Topics}
\label{chap:advanced}

\section{Float instructions}
\label{sec:float}

<<struct ieee>>=
struct	ieee
{
    long	l;	/* contains ls-man	0xffffffff */
    long	h;	/* contains sign	0x80000000
                    exp		0x7ff00000
                    ms-man	0x000fffff */
};
@



<<float mov opcodes>>=
AMOVWD,
AMOVWF,
AMOVDW,
AMOVFW,
AMOVFD,
AMOVDF,
AMOVF,
AMOVD,
@

<<float arithmetic opcodes>>=
ACMPF,
ACMPD,
AADDF,
AADDD,
ASUBF,
ASUBD,
AMULF,
AMULD,
ADIVF,
ADIVD,
ASQRTF,
ASQRTD,
@

<<[[itab]] elements>>=
"MOVD",		LMOV, AMOVD,
"MOVDF",	LMOV, AMOVDF,
"MOVDW",	LMOV, AMOVDW,
"MOVF",		LMOV, AMOVF,
"MOVFD",	LMOV, AMOVFD,
"MOVFW",	LMOV, AMOVFW,
"MOVWD",	LMOV, AMOVWD,
"MOVWF",	LMOV, AMOVWF,
@

<<[[itab]] elements>>=
"SQRTF",	LMISC, ASQRTF,
"SQRTD",	LMISC, ASQRTD,
"CMPF",		LCMPFLOAT, ACMPF,
"CMPD",		LCMPFLOAT, ACMPD,
"ADDF",		LARITHFLOAT,	AADDF,
"ADDD",		LARITHFLOAT,	AADDD,
"SUBF",		LARITHFLOAT,	ASUBF,
"SUBD",		LARITHFLOAT,	ASUBD,
"MULF",		LARITHFLOAT,	AMULF,
"MULD",		LARITHFLOAT,	AMULD,
"DIVF",		LARITHFLOAT,	ADIVF,
"DIVD",		LARITHFLOAT,	ADIVD,
@

%/*
%    "ABSF",		LMISC, AABSF,
%    "ABSD",		LMISC, AABSD,
%    "NEGF",		LMISC, ANEGF,
%    "NEGD",		LMISC, ANEGD,
%    "SQTF",		LMISC,	ASQTF,
%    "SQTD",		LMISC,	ASQTD,
%    "RNDF",		LMISC,	ARNDF,
%    "RNDD",		LMISC,	ARNDD,
%    "URDF",		LMISC,	AURDF,
%    "URDD",		LMISC,	AURDD,
%    "NRMF",		LMISC,	ANRMF,
%    "NRMD",		LMISC,	ANRMD,
%*/




<<[[itab]] elements>>=
"F",		LF,	0,

"F0",		LFREG,	0,
"F1",		LFREG,	1,
"F2",		LFREG,	2,
"F3",		LFREG,	3,
"F4",		LFREG,	4,
"F5",		LFREG,	5,
"F6",		LFREG,	6,
"F7",		LFREG,	7,
"F8",		LFREG,	8,
"F9",		LFREG,	9,
"F10",		LFREG,	10,
"F11",		LFREG,	11,
"F12",		LFREG,	12,
"F13",		LFREG,	13,
"F14",		LFREG,	14,
"F15",		LFREG,	15,
@


<<[[itab]] elements>>=
"FPSR",		LFCR,	0,
"FPCR",		LFCR,	1,
@

<<enum fregister(arm)>>=
enum fregister {
    FREGRET = 0,
    /* compiler allocates register variables F0 up */
    FREGEXT = 7,
    /* compiler allocates external registers F7 down */
    FREGTMP = 15, // ??

    NFREG = 8,
};
@

% NFREG used by 5c/ in char	reg[NREG+NFREG];
% 8? looks like 16 above



<<inst rule(arm)>>=
/*
 * floating-point coprocessor
 */
| LMISC cond freg ',' freg { outcode($1, $2, &$3, R_NONE, &$5); }
| LARITHFLOAT cond frcon ',' freg { outcode($1, $2, &$3, R_NONE, &$5); }
| LARITHFLOAT cond frcon ',' LFREG ',' freg { outcode($1, $2, &$3, $5, &$7); }
| LCMPFLOAT cond freg ',' freg { outcode($1, $2, &$3, $5.reg, &nullgen); }
@
%$
% LMISC, meh

<<operand_kind cases>>=
D_FREG,
D_FPCR,
@
% FPCR is the float pending of D_PSR?
% also FCONST we have seen before in core DS

<<[[zaddr()]] cases>>=
case D_FREG:
case D_FPCR:
    break;
@

<<[[zaddr()]] cases>>=
case D_FCONST:
    ieeedtod(&e, a->dval);
    Bputc(&obuf, e.l);
    Bputc(&obuf, e.l>>8);
    Bputc(&obuf, e.l>>16);
    Bputc(&obuf, e.l>>24);
    Bputc(&obuf, e.h);
    Bputc(&obuf, e.h>>8);
    Bputc(&obuf, e.h>>16);
    Bputc(&obuf, e.h>>24);
    break;
@
% >> >> >> >> >> >> >> >> >>

<<type declarations(arm)>>=
%type <gen> freg fcon frcon
@

% for MOV
<<gen rule>>=
| freg
@

<<ximm rule>>=
| fcon
@

<<float rules>>=
freg:
  LFREG
 {
  $$ = nullgen;
  $$.type = D_FREG;
  $$.reg = $1;
 }
| LF '(' con ')'
 {
  $$ = nullgen;
  $$.type = D_FREG;
  $$.reg = $3;
 }

fcon:
 '$' LFCONST
 {
  $$ = nullgen;
  $$.type = D_FCONST;
  $$.dval = $2;
 }
| '$' '-' LFCONST
 {
  $$ = nullgen;
  $$.type = D_FCONST;
  $$.dval = -$3;
 }

frcon:
  freg
| fcon
@
%$



<<gen rule>>=
| LFCR
 {
  $$ = nullgen;
  $$.type = D_FPCR;
  $$.reg = $1;
 }
@
%$




% ?? -> <>
<<function ieeedtod>>=
void
ieeedtod(Ieee *ieee, double native)
{
    double fr, ho, f;
    int exp;

    if(native < 0) {
        ieeedtod(ieee, -native);
        ieee->h |= 0x80000000L;
        return;
    }
    if(native == 0) {
        ieee->l = 0;
        ieee->h = 0;
        return;
    }
    fr = frexp(native, &exp);
    f = 2097152L;		/* shouldnt use fp constants here */
    fr = modf(fr*f, &ho);
    ieee->h = ho;
    ieee->h &= 0xfffffL;
    ieee->h |= (exp+1022L) << 20;
    f = 65536L;
    fr = modf(fr*f, &ho);
    ieee->l = ho;
    ieee->l <<= 16;
    ieee->l |= (long)(fr*f);
}
@

<<constant FPCHIP(arm)>>=
#define	FPCHIP		true
@
% used only by a small if(FPCHIP) in cinit

\section{Long multiplication instructions}
\n advanced topic, so can also put D_REGREG here

%\subsubsection{Mul long}

<<mul/div/mod opcodes>>=
AMULL,
AMULAL,
AMULLU,
AMULALU,
@

<<[[itab]] elements>>=
"MULL",		LMULL, AMULL,
"MULAL",	LMULL, AMULAL,
"MULLU",	LMULL, AMULLU,
"MULALU",	LMULL, AMULALU,
@



% MULL special instruction?
<<inst rule(arm)>>=
/*
 * MULL hi,lo,r1,r2
 */
| LMULL cond reg ',' reg ',' regreg { outcode($1, $2, &$3, $5.reg, &$7); }
@
%$
% ugly $5.reg?

% multiply and accumulate
<<mul/div/mod opcodes>>=
AMULA,
@

<<[[itab]] elements>>=
"MULA",		LMULA, AMULA,
@




<<operand_kind cases>>=
D_REGREG,
@

<<inst rule(arm)>>=
/*
 * MULA hi,lo,r1,r2
 */
| LMULA cond reg ',' reg ',' reg ',' spreg 
 {
  $7.type = D_REGREG;
  $7.offset = $9;
  outcode($1, $2, &$3, $5.reg, &$7);
 }
@
%$
% abuse offset, ADT would be better!




<<type declarations(arm)>>=
%type   <gen>   regreg
@

<<operand rules(arm)>>=
/* for MULL */
regreg:
 '(' spreg ',' spreg ')'
 {
  $$ = nullgen;
  $$.type = D_REGREG;
  $$.reg = $2;
  $$.offset = $4;
 }
@
% abuse offset again ... grrr



<<[[zaddr()]] cases>>=
case D_REGREG:
    Bputc(&obuf, a->offset);
    break;
@
% abuse offset to represent a register

\section{Multiple registers instructions}

% move many?
<<mov opcodes>>=
AMOVM,
@

<<[[itab]] elements>>=
"MOVM",		LMOVM, AMOVM,
@
%in lproc.s 
%	RFE				/* MOVM.IA.S.W (R13), [R15] */

%todo: abuse D_CONST again, why not D_MULTI instead?

<<inst rule(arm)>>=
/*
 * MOVM
 */
| LMOVM cond ioreg ',' '[' reglist ']'
 {
  Gen g;

  g = nullgen;
  g.type = D_CONST;
  g.offset = $6;
  outcode($1, $2, &$3, R_NONE, &g);
 }
| LMOVM cond '[' reglist ']' ',' ioreg
 {
  Gen g;

  g = nullgen;
  g.type = D_CONST;
  g.offset = $4;
  outcode($1, $2, &g, R_NONE, &$7);
 }
@


<<type declarations(arm)>>=
%type   <lval>  reglist
@


<<misc rules>>=
reglist:
  spreg           { $$ = 1 << $1; }
| spreg '-' spreg
 {
  int i;
  $$=0;
  for(i=$1; i<=$3; i++)
      $$ |= 1<<i;
  for(i=$3; i<=$1; i++)
      $$ |= 1<<i;
 }
| spreg comma reglist { $$ = (1<<$1) | $3; }
@
%$



%\section{Misc instructions}

% seems dead
%<<misc opcodes>>=
%ABX, // ?
%ABXRET, // ?
%@
%<<[[itab]] elements>>=
%"BX",		LTYPEBX,	ABX,
%@
%<<inst rule(arm)>>=
%/*
% * BX
% */
%| LTYPEBX comma ireg { outcode($1, Always, &nullgen, R_NONE, &$3); }
%@

%dead: ADWORD, // ? no reading syntax

% have reading syntax, but not transformed by 5l ... not handled,
%<<misc opcodes>>=
%ALDREX,
%ASTREX,
%ALDREXD,
%ASTREXD,
%@
%% LDREX STREX CLREX are arm v7 new instruction according to 5db.c
%% actually they are defined as macros in atom.s:
%%#define	CLREX		WORD	$0xf57ff01f
%%#define	LDREX(a,r)	WORD	$(0xe<<28|0x01900f9f | (a)<<16 | (r)<<12)
%%/* `The order of operands is from left to right in dataflow order' - asm man */
%%#define	STREX(v,a,r)	WORD	$(0xe<<28|0x01800f90 | (a)<<16 | (r)<<12 | (v)<<0)
%
%<<[[itab]] elements>>=
%"LDREX",		LMOV, ALDREX,
%"LDREXD",		LMOV, ALDREXD,
%"STREX",		LSWP, ASTREX,
%"STREXD",		LSWP, ASTREXD,
%@

% from arm.s
%#define ISB	\
%	MOVW	$0, R0; \
%	MCR	CpSC, 0, R0, C(CpCACHE), C(CpCACHEinvi), CpCACHEwait
%
%#define DSB \
%	MOVW	$0, R0; \
%	MCR	CpSC, 0, R0, C(CpCACHE), C(CpCACHEwb), CpCACHEwait
%
%#define	BARRIERS	ISB; DSB
%
%#define MCRR(coproc, op, rd, rn, crm) \
%	WORD $(0xec400000|(rn)<<16|(rd)<<12|(coproc)<<8|(op)<<4|(crm))
%
%#define OKAY \
%	MOVW	$0x7E200028,R2; \
%	MOVW	$0x10000,R3; \
%	MOVW	R3,(R2)

\section{Status register}

% status register, works with MOV but normally it's a special
% ARM load/store instructions: MSR and MRS (here emulated by a single MOV)
% CPSR = ? SPSR = ?
<<[[itab]] elements>>=
"CPSR",		LPSR,	0,
"SPSR",		LPSR,	1,
@
% CPSR is maybe system status register, see l.s where
% do
%	MOVW	$(PsrDirq|PsrDfiq|PsrMsvc), R1
%	MOVW	R1, CPSR


<<operand_kind cases>>=
D_PSR,
@
% similar to D_REG really, just with special register, so reg field
% is enum<registr> | enum<status_registr>

<<gen rule>>=
| LPSR
 {
  $$ = nullgen;
  $$.type = D_PSR;
  $$.reg = $1;
 }
@
%$
% Status register? move earlier? 


\section{System instructions}

% Already seen 2 system instructions: SWI and RFE. Here are a few more.

% no Axxx opcode, binary generation directly in action via D_CONST
<<[[itab]] elements>>=
"MCR",		LSYSTEM, 0,
"MRC",		LSYSTEM, 1,
@

<<inst rule(arm)>>=
/*
 * MCR MRC
 */
| LSYSTEM cond con ',' expr ',' spreg ',' creg ',' creg oexpr
 {
  Gen g;

  g = nullgen;
  g.type = D_CONST;
  g.offset =
   (0xe << 24) |    /* opcode */
   ($1 << 20) |     /* MCR/MRC */
   ($2 << 28) |     /* scond */
   (($3 & 15) << 8) |   /* coprocessor number */
   (($5 & 7) << 21) |   /* coprocessor operation */
   (($7 & 15) << 12) |  /* arm register */
   (($9 & 15) << 16) |  /* Crn */
   (($11 & 15) << 0) |  /* Crm */
   (($12 & 7) << 5) |   /* coprocessor information */
   (1<<4);          /* must be set */ // opcode component
  outcode(AWORD, Always, &nullgen, R_NONE, &g);
 }
@
% >> >> >> >> >> >> >> >> >> >>

<<type declarations(arm)>>=
%type   <lval>  creg
@

<<misc rules>>=
creg:
  LCREG
| LC '(' expr ')'
 {
  if($3 < 0 || $3 >= NREG)
      print("register value out of range\n");
  $$ = $3;
 }
@
%$

<<[[itab]] elements>>=
"C",		LC,	0,

"C0",		LCREG,	0,
"C1",		LCREG,	1,
"C2",		LCREG,	2,
"C3",		LCREG,	3,
"C4",		LCREG,	4,
"C5",		LCREG,	5,
"C6",		LCREG,	6,
"C7",		LCREG,	7,
"C8",		LCREG,	8,
"C9",		LCREG,	9,
"C10",		LCREG,	10,
"C11",		LCREG,	11,
"C12",		LCREG,	12,
"C13",		LCREG,	13,
"C14",		LCREG,	14,
"C15",		LCREG,	15,
@


<<type declarations(arm)>>=
%type   <lval>  oexpr 
@

% other optional stuff
<<opt rules>>=
/* for MCR */ 
oexpr:
  /* empty */ { $$ = 0; }
| ',' expr    { $$ = $2; }
@
%$




\section{Special bits}
% sign? long? p bit, w bit, ???

<<cond rule(arm)>>=
| cond LS    { $$ = $1 | $2; }
@

<<[[itab]] elements>>=
".U",		LS,	C_UBIT,
".S",		LS,	C_SBIT,
".W",		LS,	C_WBIT,
".P",		LS,	C_PBIT,
@
% .S can be used for arithmetic operations, to set condition code

<<constant C_SBIT(arm)>>=
#define	C_SBIT	(1<<4)
@
% >>

<<constant C_PBIT(arm)>>=
#define	C_PBIT	(1<<5)
@
% >>

<<constant C_WBIT(arm)>>=
#define	C_WBIT	(1<<6)
@
% >> >> >> >> 

<<constant C_UBIT(arm)>>=
#define	C_UBIT	(1<<7)	/* up bit */
@
% >>

% composite
<<[[itab]] elements>>=
".PW",		LS,	C_WBIT|C_PBIT,
".WP",		LS,	C_WBIT|C_PBIT,
@

% composite or alternate form
<<[[itab]] elements>>=
".IBW",		LS,	C_WBIT|C_PBIT|C_UBIT,
".IAW",		LS,	C_WBIT|C_UBIT,
".DBW",		LS,	C_WBIT|C_PBIT,
".DAW",		LS,	C_WBIT,

".IB",		LS,	C_PBIT|C_UBIT,
".IA",		LS,	C_UBIT,
".DB",		LS,	C_PBIT,
".DA",		LS,	0,
@
% some seems redundant like .DB and .P, .U and .IA, etc

% see asm.ps ARM section: "addressing modes are supported by suffixes
% of the instruction, IA = increment after, IB = increment before, ..."
% it can be used only with the MOV instruction

<<constant C_FBIT(arm)>>=
#define	C_FBIT	(1<<7)	/* psr flags-only */
@
% >>

<<[[itab]] elements>>=
".F",		LS,	C_FBIT,
@


\section{Compiler-only pseudo-instructions}

% some of those are not really opcodes, they are entities 
% just at the asm AST level produced internally by 5c.
% they have no reading syntax.

% related to NOP, SHL, MOV, pseudo asm
% that get translated in store/load on some archi.


% only used by 5c
<<pseudo opcodes>>=
ACASE,
ABCASE,
@
% BCASE = branch case

% actually they used to have a read syntax, but I didn't see any code
% using them so I commented the code.
%<<[[itab]] elements>>=
%"CASE",		LTYPED, ACASE,
%"BCASE",	LBCOND,	ABCASE,
%@
%<<inst rule(arm)>>=
%/*
% * CASE
% */
%| LTYPED cond reg comma { outcode($1, $2, &$3, R_NONE, &nullgen); }
%@
%$


<<mul/div/mod opcodes>>=
AMULU,
ADIVU, // VIRTUAL, transformed to call to _divu
AMODU, // VIRTUAL, transformed to call to _modu
@
% has no reading syntax, generated just in 5c

<<pseudo opcodes>>=
ASIGNAME,
@
% for signatures checking, generated just in 5c
% really an extended ANAME with signature information (md5sum of the
% type, which for a structure is a md5sum of all its components, so
% pretty safe)


% not pseudo opcodes but related to compile-only opcodes. Here are other 
% constants defined in 5.out.h that are used only
% in compiler context.
% for 5c! conventions! (not used at all by 5a, but in 5.out.h for other tools)
<<[[regxxx]] compiler conventions cases>>=
REGRET =	0,
REGARG =	0,
/* compiler allocates R1 up as temps */
/* compiler allocates register variables R2 up */
REGMIN =	2,
REGMAX =	8,
REGEXT =	10, // R9/R10 possible 'extern register xxx;'
/* compiler allocates external registers R10 down */
REGTMP =	11,
@
% hmm regxxx is not really an enum as REGREG = REGARG, but still useful.

%old:    /* used by the loader for thumb code */
%    REGTMPT =		7,
% no REGFP??

\section{Linker-only pseudo-instructions}

<<pseudo opcodes>>=
AGOK,
@
% GOK =? God only Knows? speciak mark?
% actually used in both compiler and linker
% but I think it's used only for zprg, and in ldobj it's an error
%less: maybe we could delete it, and just use AXXX or ALAST or ANOP instead.
%old: there was a D_GOK, but it was unused in 5a/5c/5l

% not sure it's linker-only pseudo opciodes, could be also compiler
% specific
<<pseudo opcodes>>=
ADYNT,
AINIT,
@
% seems never assigned, maybe not used anymore? seems about
% dynamic loading, alef stuff maybe?
%todo: delete?


% related to linker again, in addition to D_FILE there is:
<<sym_kind cases>>=
D_FILE1, // used by linker only?
@
%todo: delete?

%dead: #define	ALLTHUMBS	(1<<2)

\section{[[TEXT]] attributes}

%Again not an opcode, but related. Where this bit is stored?
%I think in the middle reg of an instruction for opcodes like ATEXT.
%It is used by 5l e.g. to allow override existing symbol.
%I think it's for TEXT and DATA instructions and its reg field
% (that should be unused for TEXT and DATA)
<<constant DUPOK(arm)>>=
#define DUPOK		(1<<1)
@

%less: transform in an enum with DUPOK
% note that it's not used by 5a, used by 5c/5l when have a special #pragma
<<constant NOPROF(arm)>>=
#define NOPROF		(1<<0)
@

\section{[[#pragma lib]] and automagic linking}

% this is very very nice! remove so much headache,
% no need ocamlfind, no need pkg-config, so simple ...

% the object can contain information about which
% lib you want to link with!

% less useful in assembly than in .c, but because anyway it's
% an object file property, it's also in the assembler (that generate
% object files).

<<[[macprag()]] locals>>=
Hist *h;
char *hp;
int c0, c;
@

<<[[macprag()]] if pragma lib>>=
if(s && strcmp(s->name, "lib") == 0) {
    c0 = getnsc();
    if(c0 != '"') {
        c = c0;
        if(c0 != '<')
            goto bad;
        c0 = '>';
    }
    for(hp = symb;;) {
        c = getc();
        if(c == c0)
            break;
        if(c == '\n')
            goto bad;
        *hp++ = c;
    }
    *hp = '\0';
    c = getcom();
    if(c != '\n')
        goto bad;

    /*
     * put pragma-line in as a funny history 
     */
    c = strlen(symb) + 1;
    while(c & 3)
        c++;

    hp = malloc(c);
    memcpy(hp, symb, c);

    h = alloc(sizeof(Hist));
    h->filename = hp;
    h->line = lineno;
    h->local_line = -1; // special mark, ugly

    h->link = H;
    if(ehist == H) {
        hist = h;
        ehist = h;
        return;
    }
    ehist->link = h;
    ehist = h;

    return;

bad:
    unget(c);
    yyerror("syntax in #pragma lib");
    macend();

}
@
%less ugly would be to have object attribute (in addition to
% text/data attributes)


\section{Processing multiple files}

% why need that? people can write mkfiles

<<[[main()]] locals>>=
int nout, nproc, status;
int i, c;
@

<<[[main()]] multiple files handling>>=
if(argc > 1) {
    nproc = 1;
    if(p = getenv("NPROC"))
        nproc = atol(p);	/* */
    c = 0;
    nout = 0;
    for(;;) {
        while(nout < nproc && argc > 0) {
            i = fork();
            if(i < 0) {
                i = mywait(&status);
                if(i < 0)
                    errorexit();
                if(status)
                    c++;
                nout--;
                continue;
            }
            if(i == 0) {
                print("%s:\n", *argv);
                if(assemble(*argv))
                    errorexit();
                exits(0);
            }
            nout++;
            argc--;
            argv++;
        }
        i = mywait(&status);
        if(i < 0) {
            if(c)
                errorexit();
            exits(0);
        }
        if(status)
            c++;
        nout--;
    }
}
@

%\section{Thumb code}
% arg processing: (but then no more generic across 5a/ and 8a/)
%
%    case 't':
%        thechar = 't';
%        thestring = "thumb";
%        break;

\chapter{Conclusion}
\label{chap:conclusion}

%missing features: ORG, but ld can do -Txx

% see linker! next book to read, logically.
% some assembler related stuff is in libmach/ and lots in the linker.

% see compiler

% see disassembler





\appendix

\chapter{Debugging}
\label{chap:debugging-appendix}

% not very powerful debugging options for 5a, mostly stuff
% to debug cpp related issues.
% less: 5l has actually more stuff, with dumpers for Gen, opcode, etc.
% e.g. 5l -v -W is pretty useful as it helps debug the object loading,
% so maybe we could reuse some of this code here.

% ex: 'm', 'f' (256 so can have for each character a boolean value)
<<global debug>>=
bool	debug[256];
@

<<[[main()]] debug initialization>>=
memset(debug, false, sizeof(debug));
@

<<[[main()]] command line processing>>=
default:
    c = ARGC();
    if(c >= 0 || c < sizeof(debug))
        debug[c] = true;
    break;
@

\section{[[5a -m]], macro debugging}
% m for macro

<<[[dodefine()]] debug>>=
if(debug['m'])
    print("#define (-D) %s %s\n", s->name, s->macro+1);
@

<<[[macdef()]] debug>>=
if(debug['m'])
    print("#define %s %s\n", s->name, s->macro+1);
@

\section{[[5a -f]], line information debugging}

<<[[linehist()]] debug>>=
if(debug['f'])
    if(f) {
        if(local_line)
            print("%4ld: %s (#line %d)\n", lineno, f, local_line);
        else
            print("%4ld: %s\n", lineno, f);
    } else
        print("%4ld: <pop>\n", lineno);
@



\chapter{Error Managment}
\label{chap:error}

<<function errorexit>>=
void
errorexit(void)
{

    if(outfile)
        remove(outfile);
    exits("error");
}
@

<<global nerrors>>=
int	nerrors = 0;
@
% used to be initialized in cinit()

<<function yyerror>>=
void
yyerror(char *a, ...)
{
    char buf[200];
    va_list arg;

    /*
     * hack to intercept message from yaccpar
     */
    if(strcmp(a, "syntax error") == 0) {
        yyerror("syntax error, last name: %s", symb);
        return;
    }

    prfile(lineno);

    va_start(arg, a);
    vseprint(buf, buf+sizeof(buf), a, arg);
    va_end(arg);

    print("%s\n", buf);
    nerrors++;
    if(nerrors > 10) {
        print("too many errors\n");
        errorexit();
    }
}
@



\chapter{Utilities}
\label{chap:libc}

\section{Memory managment}
\label{sec:memory}

% same in Linker, not sure why they just don't use malloc?
% to avoid dependencies to libc? for bootstrapping reasons?

<<global hunk>>=
char*	hunk;
@

<<global nhunk>>=
long	nhunk = 0;
@
% used to be set in cinit()

<<global thunk>>=
long	thunk;
@

<<constant NHUNK>>=
#define	NHUNK		10000
@


<<function gethunk>>=
void
gethunk(void)
{
    char *h;
    long nh;

    nh = NHUNK;
    if(thunk >= 10L*NHUNK)
        nh = 10L*NHUNK;

    h = (char*)sbrk(nh);
    if(h == (char*)-1) {
        yyerror("out of memory");
        errorexit();
    }
    hunk = h;
    nhunk = nh;
    thunk += nh;
}
@



<<constant MAXALIGN>>=
#define MAXALIGN 7
@

<<function alloc>>=
/*
 * real allocs
 */
void*
alloc(long n)
{
    void *p;

    while((uintptr)hunk & MAXALIGN) {
        hunk++;
        nhunk--;
    }

    while(nhunk < n)
        gethunk();
    p = hunk;
    nhunk -= n;
    hunk += n;

    return p;
}
@

<<function allocn>>=
void*
allocn(void *p, long on, long n)
{
    void *q;

    q = (uchar*)p + on;
    if(q != hunk || nhunk < n) {

        while(nhunk < on+n)
            gethunk();
        memmove(hunk, p, on);
        p = hunk;
        hunk += on;
        nhunk -= on;

    }
    hunk += n;
    nhunk -= n;
    return p;
}
@


\chapter{Extra Code}

\ifallcode
#include "Assembler_extra.nw"
#include "Assembler_x86.nw"
\fi

%\chapter{Changelog}
%\label{sec:changelog}

\chapter{Glossary}
\label{sec:glossary}

\begin{verbatim}
ISA = Instruction Set Architecture
AST = Abstract Syntax Tree
PC = Program Counter
SP = Stack Pointer
FP = Frame Pointer
SB = Static Base register
BL = Branch and Link
RISC = Reduced Instruction Set Computer
CISC = Complex Instruction Set Computer
ARM  = Akorn Risc Machines
CWD = Current Working Directory
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{chapter}{Index}

%\chapter{References} 
\addcontentsline{toc}{chapter}{References}

\bibliography{../docs/latex/Principia}
\bibliographystyle{plain}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
