\documentclass[twocolumn, landscape]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosetrue % see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things:
%  - better organisation of the code, my TOC is better than the few existing
%    files (which didn't have very good names, and which I even split)
%  - removed deadcode (Ref, imm2, con2, NMACRO, CLAST, isreg, ...)
%  - renamed some enums (as => opcode, <noname> => operand_kind)
%  - reordered opcodes and operand kinds, and cleaned them:
%     * removed opcodes (ADWORD, ABX, ...)
%     * removed operand kinds (D_GOK, D_ADDR, D_OCONST, ...)
%  - introduced sym_kind, splitted from operand_kind, for D_EXTERN, D_PARAM, ..
%  - factorized more code between ARM and x86 (abusing LP chunks)
%  - refactored the Asm5 (ARM) grammar:
%     * removed a few rules, weird operand forms that were not used anyway,
%       or introducing complexity (regi_nosp), e.g. disallow pseudo-reg 
%       in certain places.
%     * removed also optional commas here and there
%     * renamed some grammar rules (spreg -> regi, sreg -> regi_nosp),
%     * inlined and removed intermediate rules not useful anymore: oreg
%  - TODO rename types, clearer, Gen? as Adr? or Operand? (and Gen2? as Prog?)

%thx to assemblers/ocaml: 
%  - see that code could be so much simpler, no need so many globals
%  - could be stricter which would simplify things even more
%  - there are really only 3 kinds of operands: for arith, for mov, for branch
%    (see ast.ml)
%  - outcode must increment pc for TEXT too, because can branch on TEXT
%    and TEXT actually generates code, so if label just after TEXT,
%    it must be a different pc than before TEXT!
%    (see because while writing resolve() it is more explicit)
%  - understand that need LLAB trick only for the check-redefined-label
%    (because there was no ambiguity in parser_asm.mly without LNAME vs LLAB)
% things which improved this document thx to assemblers/ocaml: 

%thx to codemap/codegraph/scheck:
% - factorized code in aa/
% - mv errorexit, alloc, in utils.c instead of lexbody.c, same for gethunk
% - have a main.c instead of putting everything in lex.c

%thx to this manual, better understand assembly and assembler:
% - an object file is really a module: the simplest/lowest-level 
%   module abstraction with code, data, and imported/exported entities
% - calling conventions, they are really that on ARM, conventions
% - can actually understand the assembly code in Kernel.nw :) param1+0(FP)
% - the difference betweeen GLOBL and DATA, declaration vs definition
% - assembly directives are actually more linker/loader directives,
%   for instance they configure data for the loader to setup memory
% - SEMI bit shift logic vs arith?
% - TODO MOVs and unsigned? 
% -  <= and unsigned
% - swap
% - #line and need to keep included files history
% - format of floats, mantisse, exposant, and bit parts
% - TODO -fpic?

%history LP-ization:
% - skeleton, mostly copy paste of Template.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
% - split in chunks (some done automatically)
%    * function, global, struct, enum, constant, macro(actually function)
%    * [[xxx]] other fields, [[xxx]] extra fields
% - read Extra section, identify concepts, first TOC
% - distribute parts of the file before
% - typeify, scheckify
% - aspectify advanced features!
% - add explanations
% - add figures

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
%\usepackage{cleveref} %\cref
%\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% ifallcode is used for:
%  - forward decl, func decl, extern decl, #ifdef, pragmas (stuff in Extra.nw)
%  - misc optional syntactic elements (e.g. commas)
%  - grammar literate boilerplate
%  - STILL? misc opcodes (e.g. MVN)

\addtolength{\topmargin}{-.850in}
\addtolength{\textheight}{1.70in}

\begin{document}
%******************************************************************************
% Title
%******************************************************************************
\title{
{\Huge 
Principia Softwarica: The ARM Assembler [[5a]]
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}\\
\\
with code from\\
Rob Pike
}

\maketitle 
\l ARMv6 (32 bits) edition?
\n alt: 8a x86 (32 bits) edition, see Assembler_x86.nw
\n Plan9 in core title? meh

\onecolumn
\hrule
\input{../docs/latex/Copyright}
\input{../docs/latex/CopyrightPlan9}
\hrule
\twocolumn

\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\tableofcontents
\endgroup

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

The goal of this book is to present with full details the source code of
an {assembler}.

\section{Motivations}

Why an assembler? Because we think you are a better programmer 
if you fully understand how things work under the hood, and 
an assembler is an essential part of any {development toolchain}.
\l which itself is essential
Indeed, compilers for higher level languages such as C usually
do not generate directly {machine code} but instead rely
on an assembler (and linker) for their final code-generation step.
\n 5c actually does not really rely on the external assembler 5a
\n but gcc/ocamlopt do generate assembly and call external assembler gas

Even if most programmers very rarely write {assembly} code,
understanding an assembly language, and so also what an assembler does,
is essential to understand low-level fundamental concepts such as 
{binary logic and arithmetic}, {memory operations}, {pointers}, 
{stack processing}, {frames},
{software interrupts}
and to understand what a compiler generates. 
Note also that some code, especially in the kernel, can not be written in C
and has to be written in assembly.

Here are a few questions we hope this book will answer:
\begin{itemize}
\item What is the list of all assembly instructions?
What a typical computer can do?

\item What are the essential features of an assembler? How they help
over writing directly machine code?

\item What are the most important assembly constructs? How
can they be used to implement high-level constructs in languages
such as C?
\n labels is here, and it's assembly only, it's not in Machine.nw
%compiler:

\item How function calls are implemented? What is a frame?
What is a frame pointer? How recursive functions are implemented?
What are calling conventions?
%SEMI except frame pointer

\item What is in an object file? What difference there is
between an object file and an executable?
%SEMI

\item How the assembler and linker work together?

\end{itemize}
\l binary format? no, in linker book
\n try questions more specific to asm, put the rest in Machine.nw (and Linker)
\l what is position independent code? maybe linker issue

%tags used in this file for different recurring themes:
%turing: fundamental opcodes
%self-ref: opcodes to implement the assembler itself!
%compiler: give idea of what 5c does, what 5c needs
%kernel: for features essential to implement a kernel
%real-world: to relate to other assemblers
%ocaml: to give a hint on how rewriting C in OCaml could improve things
%old: for original code I changed/removed to be clearer
%toc: %trans: %dup: %example:

\section{The \plan ARM assembler, [[5a]]}

We will explain in this book the code of the \plan ARM assembler
[[5a]]\footnote{\url{http://plan9.bell-labs.com/magic/man2html/1/8a},
which despite its name covers also [[5a]]}
which is about 4100 lines of code (LOC).
\n see make loc (or cm -test_loc)
[[5a]] is written in C\footnote{
An OCaml partial port is also shown in Appendix~\ref{chap:5a-ocaml}
}
for the most part with its parser using also Yacc.
\l cite for C and Yacc?
%
Like for most books in \principia, we chose a \plan software because
they are simple, small, elegant, open source, and they form together
a coherent set of software.
%
The [[5]] comes from the \plan convention to name architecture
with a number or single letter (0 is MIPS, 5 is ARM, 8 is x86, etc),
and the [[a]] means assembler.
\n single character, they like that, see also kernel and the #c, #i, etc
\l put in this section the discussions about Asm5 and Asm9?

Like for the other \principia books covering the
{development toolchain}, we chose the ARM architecture~\cite{arm-refman}
variant, in this case of the \plan assembler ([[5a]]),
and not for instance the x86 variant ([[8a]]), for
reasons of simplicity. Indeed RISC machines
are far simpler than CISC machines. Moreover, the availability
under \plan of an ARM emulator, [[5i]], helps to understand
the semantics of the assembly instructions used in [[5a]].
\n Using x86 also make it more error prone when want to change things
\n because we would have also to change kencc (e.g. error prone to change
\n the order of asm instructions).

Note that the \plan assemblers output differs slightly from
other traditional assemblers. The {files} generated by [[5a]],
called the {\em object files},
are ARM-specific, but they do not contain really machine code. Instead
the object file is essentially the {serialized form} of the 
{abstract syntax tree} of the assembly source. 
\l Ref to later? maybe hard to understand. 
The actual machine code generation is performed by the linker [[5l]]\footnote{
Readers interested in this topic should also read the \book{Linker}}.
We think though that it is actually a better design because it leads to
less code in total and also to simpler code.
\l where explain why better? later? or in Linker.nw?
\n a critique of go/plan9 toolchain though, see comment in .tex:
% - http://dtrace.org/blogs/wesolows/2014/12/29/golang-is-trash/
%   with https://news.ycombinator.com/item?id=8815778
%   and http://www.reddit.com/r/programming/comments/2riayd/golang_is_trash/
\l say here Asm5 is not _direct_ representation of underlying ARM machine?

\section{Other assemblers}

Here are a few assemblers that were considered for this book but
which were ultimately discarded:
\begin{itemize}

\item The GNU Assembler [[gas]], part of the 
[[binutils]] package, 
\l furl for binutils and also for the other
is probably the most used open source assembler.
\n everything moved from as86 to gas
It supports many architectures, including ARM and x86.
It is called internally by [[gcc]] and so is indirectly
used to assemble most open source software.
\n maybe clang/llvm competes a bit now
It is very big though:
350K LOC for [[gas/]], which is almost two orders of magnitude
more code than [[5a]],
and 3.4M LOC for the whole [[binutils]] package (not including the testsuite).
Even the ARM-specific file [[gas/config/tc-arm.c]] has already 25 000 LOC.

\item NASM is a popular x86 assembler using the Intel
syntax as opposed to [[gas]] (and [[5a]]) which uses the \att syntax.
It is also fairly large: 50 000 LOC.
\n popular on linux especially, but also works on windows and mac

\item AS86, an x86 16-bit and 32-bit assembler, part of
Bruce Evans' C compiler (BCC), is an historical assembler
used to compile old versions of Minix and Linux. It is
also using the Intel syntax. Because it can generate 16-bit
``real-mode'' machine code, it is still used to compile programs such
as boot loaders. It is fairly small: 12 500 LOC. This
includes the machine code generation which is not done by [[5a]]
(but done by [[5l]]). 
\l to be fair LOC of 5l is big, but 5a plus 5l LOC < as86 plus ld86
However, because x86 is a rather
complicated architecture, the 16-bit/32-bit as well as
the different CPU modes (real-mode, protected-mode, virtual-mode) 
being just a testimony of this complexity, 
we prefer to present an ARM assembler.
\l a bit dead, used only by elks project now

\item MMIXAL, an assembler for the MMIX virtual machine
invented by Donald Knuth, is a small and 
very well documented program~\cite{mmixware}.
\n actually not that well, I dont like his style, no structure, no TOC
Its (literate) source is about 3200 LOC, which includes
the (virtual) machine code generation part.
But, in \principia we want to restrict ourselves to software which can run
on real machines.
\n what about mixal? used in the mdk, smaller? does not matter, not LP probably

\l vasm here?

\n assembler for hack? not included in distro, had to write ourselves!

\end{itemize}

\l lots of other assemblers, see the comment in the .tex
%industry:
% - masm (Microsoft), since 1981
% - tasm (turbo, Borland)
% - mpw? (Apple)
%other:
% - llvm has one? well the IR of llvm is a kind of assembler, but portable
% - http://www.compilers.de/vasm.html (also vbcc and vlink)
%   recent fork: http://sun.hasenbraten.de/vasm/, used in amiga tutorial,
% - fasm, flat assembler (written in assembly, hmmm)
%mini:
% - fbas, use lex and yacc, 720 LOC, but looks really simplified
% - https://github.com/trillek-team/computer-toolkit include
%   a toy asm, linker, and even a toy C compiler
% - see also hex2c? 
% - the assembler in subc-2014
% - mine for hack? but my assemblers/ocaml/ is maybe better, 
%   hack machine language was a bit obscure too
%education:
% - pep/8 assembler?
% - web based assembler+debugger, teaching purpose: http://yasp.me/
%research:
% - piton, a proven assembler in boyer moore
% - TAL typed assembly language, 
% - Coq macro assembler
%see also http://www.tldp.org/HOWTO/Assembly-HOWTO/other.html


\section{Getting started}
\label{sec:getting-started}

To play with [[5a]] you will first need to install
the \plan fork used in \principia. See \urlinstall.
Once installed, you can test [[5a]] under \plan with:

\begin{verbatim}
1   $ cd /tests/5a
2   $ 5a hello.s
3   $ 5l hello.5 -o hello
4   $ ./hello
5   hello world
6   $
\end{verbatim}

The command in Line 2 {assembles} the very simple [[hello.s]]
ARM assembly program and generates the [[hello.5]] ARM {object file}.
\n define object file? partly defined before in motivations
Line 3 then {links} the object file and generates the final 
ARM binary {executable} [[hello]].
Line 4, which assumes you are under an ARM machine (e.g. a Raspberry Pi),
{launchs} the program.

Note that it is easy under \plan to {cross compile} from another architecture;
you can use the same commands, [[5a]], [[5l]], etc.
\l because magic /bin, and also because special 5 convention
To play with [[5a]] under an x86 machine you just need then
after the linking step to use the ARM emulator [[5i]]:

\begin{verbatim}
...
4   $ 5i hello
...
\end{verbatim}

See the \book{Emulator} for more information on [[5i]].
\l actually cool cos can be used as an assembly debugger too

\section{Requirements}

Because most of this book is made of C source code, 
you will need to have a good knowledge of 
the C programming language~\cite{k-r} to understand it.
\l actually quite a view bit manip, and C idioms used
To understand Chapter~\ref{chap:parsing} you will also
need to know Yacc~\cite{lexyacc}.
\l Can read Compiler.pdf :) and Generators.pdf :) but a bit self reference.

Note that this book is not an introduction to
assembly programming.
We assume you already know one assembly language,
not necessarily the one used by [[5a]] though,
and that you have a basic understanding of computer architecture.
%
We assume you are already familiar 
with concepts such as
{registers}, {stack pointer}, {program counter},
{memory move}, {jumps},
{labels},
\n {frame pointer}, hmmm maybe not, we can explain in this doc.
etc.
\t if not good reference to learn Assembler? one mention by asl book?
\l MIPS assembly tutorial, might give some ideas (use spim)?
%  http://programmedlessons.org/AssemblyTutorial/index.html
\l Assembly Programming classic book? once cited by Assembler and Loaders?
%
We do not assume though that you know how an assembler works.
Even if in a few \principia books such as the
\book{Compiler} or \book{Kernel} we assume a knowledge of the concepts
and theory underlying those software, this is not the case here.
Indeed, there are very few books explaining how an assembler works,
e.g. {\em Assemblers and Loaders}~\cite{asl},
\l csapp explain assemblers?
\l get inspiration from TOC? read intro?
as opposed to dozens of books on compilers and kernels.
\t and none to the best of our knowledge showing code (except mmixware)
%We assume you already know most of the theory; this book is here to
%cover the practice.
\n maybe not for this one actually

It is not necessary to know the ARM architecture to
understand this book, but
we recommend to read the \book{Emulator} to fully understand
the semantics of some assembly instructions.

It can be also useful to read the documentation of
the \plan assemblers available in our \plan repository in 
[[assemblers/docs/asm.pdf]] and
[[docs/man/1/8a]]\footnote{Despite its name this document also covers [[5a]]}.
\n 'as' article in unix programmer's manual? meh, seems unrelated to 5a.
There are also some extra notes about the assemblers
at \url{https://golang.org/doc/asm} which can be useful.
\n Go used to use the plan9 developer toolchain, made by same authors :)



\section{About this document}
#include "../docs/latex/About.nw"

\section{Copyright}

Most of this document is actually source code from Plan9, so
those parts are copyright by Lucent Technologies Inc.
The prose is mine and is licensed under the \license.

\section{Acknowledgments}

We would like to acknowledge of course the author of
[[5a]], Rob Pike, 
who wrote in some sense most of this book.

\t I rewrote the code a bit, e.g. symidx_of_symopt is big
\t maybe should say it






\chapter{Overview}

%trans:
Before showing the source code of [[5a]] in the following chapters, 
%toc:
we first give an overview in this chapter
of the general principles of an assembler, 
of the assembly language supported by [[5a]],
and of the format of the object files generated by [[5a]].
We also define terms, explain how the code is organized, 
and more generally give the background needed 
to understand the code we will show later.

\section{Assembler principles}

An {\em assembler} is a program which translates source code
written in an {assembly} programming language into
{machine code}, or into an {object code} close to machine code.
%
An {\em assembly} langage is a low-level programming language mimicing
closely the {instructions} of a machine, but using a {textual}
format far more convenient for the programmer than the
{binary} format used internally by computers.
\n as close as possible but not closer
%
Note that each assembly language is specific to a computer architecture.
\l and in fact even different assembler for same arch use different syntax
\n so it is not portable; C is a portable assembler! Or need meta-assembler.

Assembly languages use {\em mnemomics} to denote low-level {instructions}.
%
For instance an assembly programmer can simply use the mnemomic
[[ADD]] in his code instead of having to remember that [[0000100]]
is the binary code to perform an addition in an ARM processor.
%
Typical instructions are made of an {\em opcode} and 
one or more {\em operands}.
%
For instance [[ADD 15, R1, R4]] is a complete assembly instruction 
telling the computer to add fifteen to the first register
and to put the result in the fourth register.
\l again mnemonic too for register names, and actually it's \$15
\n note that cant have ADD R1, 15, R4 because ARM restrictions on ADD
\n also note att syntax, left to right

A key feature of assemblers is to allow the use of {\em symbolic addresses}
as operands, freeing the programmer from tedious manual calculations.
%
Indeed, in assembly a programmer can {{define}} {\em symbols} designating
certain memory areas (code area or data area),
\n use 'symbols' not 'labels', more general; they are in symbol table of binary
\n put globals or functions, hmm but label make things more general
and can then {{use}} those symbols as operands.
For instance [[B foobar]] allows to {branch} (jump) 
to the code following the [[foobar]] symbol. 
\n actually it is B foobar(SB) in 5a if foobar is a symbol and not a label
%
Without symbolic addresses a programmer
would have instead to write something like [[B 1562]] and make sure
that he calculated correctly that 1562 was the address corresponding
to the thing he wanted to jump to. This would require to know
the size of each instruction, and each further modification of the program
could entail the recalculation of all those addresses.

So, the main functions of an assembler are typically:
\n function almost in a literal way; those phases correspond almost to 5a funcs
\begin{enumerate}
\item to {\em parse} an input textual file,
\item to {\em check} that the combinations of opcodes and operands form 
valid machine instructions,
\n in 5a actually a few checks are delayed until linking
\item to {\em compute} the concrete values of symbolic addresses
(which usually requires a two pass algorithm as one can reference symbols
defined later in the file)
\n in 5a actually only labels are resolved, symbols are delayed until linking
\item to {\em generate} the binary machine code.
\n again 5a is special here
\end{enumerate}

In fact most assemblers do not generate the final machine code but instead
generate an {\em object code}, which is mostly machine code but
with extra information about {\em unresolved symbols}.
\n local labels disappear? Yes, they are resolved, but kept for debugging.
%
Indeed, even if for small programs the definitions and uses of symbolic
addresses could be in the same single file, as programs
grew larger it becomes useful to separate the source in different files.
\l for separation of concern, modularity, libs, reuse, separate compilation, ..
\l but now I do everything in one big file, so maybe can revisit that idea
In this case, one could want to reference in one assembly file
a symbol defined in another file. 
%
This is why the object file
must contain, in addition to machine code, enough information
about the {external} symbols this assembly file is using
(as well as the symbols it defines) so that another tool, the {\em linker}
can later fully {\em resolve} all the symbol references used in 
all the files.
\l So assembler must output symbol table information in the object
\l for the linker to know what to do and where to patch things.
\n asm.pdf use external a lot, but often he means global
%
In essence, an object file is really the simplest form
of a {\em module}: it packs code, data, and information
about {exported} and {imported} entities.
\n but no properties for those entities, so not a real interface

A linker then essentially 
{concatenates} the code (and data) of the multiple object files together,
{resolves} all the symbolic addresses now that all 
the code (and data) is available and has been assigned a fixed memory area,
\n in fact can be tricky for variable-sized instructions like in x86,
\n has to make pessimistic guess and it complicates a lot things
{patches} all the incomplete instructions that were using unresolved symbols,
\n actually 5l does not patch machine code really
and finally {generates} the final binary executable.
\n Put two assembly file with symbols defined and used, and how resolved
\n and how relocate? No, let that to the linker book.

\t normally big concept in assembler is relocation, but job done
\t by linker in case of plan9 so will not talk much about it
\t WIKIPEDIA relocation?
\t When objects are concatenated together so the branch/jmp addresses
\t need also to be "relocated"; same for references to external symbols

\section{[[5a]] command line interface}

The command line interface of the assembler [[5a]] is pretty simple:
\begin{verbatim}
$ 5a
usage: 5a [-options] file.s
$ 5a foo.s
$ 5l foo.5 bar.5 ...
\end{verbatim}

Given an input {assembly file} [[foo.s]], 
[[5a]] outputs an {object file} [[foo.5]].
One can change this default behaviour by using the [[-o <outfile>]] option.
Other options are related to macroprocessing and debugging and will 
be described later.
\l -D -I (cpp),  -f -m for debug
\l env: INCLUDE (for cpp, similar to -I), NPROC (when multi files?)


\section{[[helloworld.s]]}
\label{sec:helloworld}

From now on we call {\em Asm5} the ARM assembly language supported by [[5a]]. 
%
Because the different \plan assemblers
are really variations of a single program, the
assembly languages they support are also variations of a single language
we call {\em Asm9}. Asm5 can be seen as a specialized version of Asm9
for the ARM processor.
By understanding Asm5 you will understand also fairly well the assembly
languages supported by the other \plan assemblers (e.g. [[8a]])
as they have a lot in common.
\n asm is not portable, but cos they have a lot in common, easier a bit to port
\n even more easier thx to the virtual instructions such as MOVW or RET

%toc:
In this section we will show a simple Asm5 program, [[helloworld.s]],
which prints [[Hello World]] when executed. We will use this
program as a tutorial for Asm5 (and more generally for Asm9).
\n I'd rather not write this tutorial but all existing docs on Asm5 are bad

\subsection{Background}

%trans:
To understand [[helloworld.s]] we must first show
the equivalent program written in C to introduce some background
on how to perform {system calls} in \plan.
\l system call em? link to Kernel book?
\n could have a hello.s that you link with libc so easier
\n but I like the idea of really raw simple hello world in assembly!
\n for Linux: http://sysdigcloud.com/fascinating-world-linux-system-calls/

Here is the simplest \plan{} [[hello world]] program written in C:

<<helloworld1.c>>=
#include <u.h>
#include <libc.h>

void main() {
  print("hello world\n");
}
@

This code is using the [[print()]] function from the core C library.
If we expand the code of this function and simplify things
we will get this C program:

<<helloworld2.c>>=
#include <u.h>
#include <libc.h>

void main() {
  pwrite(1, "hello world\n", 12, 0);
}
@

The [[pwrite()]] function is also defined in the C library,
but it is written in assembly in [[lib_core/libc/9syscall/pwrite.s]].
\n actually it's auto generated by mk from sys.h. 
\t See Appendix!
\l Why p?
It is a small wrapper around the {software interrupt} ARM instruction 
[[SWI]] which performs a {\em system call} (also known as a {\em syscall}).
\l more on this SWI later
%
Here is the prototype of [[pwrite()]] defined in [[include/core/libc.h]]:

<<prototype pwrite in libc.h>>=
extern	long	pwrite(fdt, void*, long, vlong);
@
%old: I introduced fdt typedef

The [[pwrite()]] interface is documented in 
[[docs/man/2/read]]\footnote{Again, despite its name this document also
covers [[pwrite]]}.
The parameters are in order 
a {file descriptor} (e.g. [[1]] for standard output), 
a string pointer, 
the number of bytes to write,
and finally a [[vlong]] seeking offset. 
%
Most of the parameters take 4 bytes except the [[vlong]] which takes 8 bytes.
\l will be important, see later
\l pwrite is the syscall, not write, vlong seek is for protocol atomicity, 2in1

\subsection{The program}
\label{sec:hello-program}

%trans:
We now have enough background to present the [[helloworld.s]] program:

<<assemblers/5a/tests/hello.s>>=
1 	TEXT _main(SB), $20
2 	        B later
3 	        B loop /* not reached */
4 	later:
5 	        /* fill missing characters for hello */
6 	        MOVW $hello(SB), R2
7 	        MOVW $'W', R1        
8 	        MOVB R1, 6(R2)
9 	        MOVW $'o', R1        
10	        MOVB R1, 7(R2)
11	        MOVW $'r', R1        
12	        MOVB R1, 8(R2)
13	        MOVW $'l', R1        
14	        MOVB R1, 9(R2)
15	        MOVW $'d', R1        
16	        MOVB R1, 10(R2)
17	        MOVW $'\n', R1
18	        MOVB R1, 11(R2)
19	        /* prepare the system call PWRITE(1,&hello,12,00) */
20	        MOVW $1, R1
21	        MOVW R1, 4(R13)
22	        MOVW $hello(SB), R1
23	        MOVW R1, 8(R13)
24	        MOVW $12, R1
25	        MOVW R1, 12(R13)
26	        MOVW $0, R1
27	        MOVW R1, 16(R13)
28	        MOVW R1, 20(R13)
29	        MOVW $9 /*PWRITE*/, R0
30	        /* system call */
31	        SWI
32	        BL exit(SB)
33	        RET /* not reached */
34	loop:
35	        B loop
36	        
37	
38	TEXT exit(SB), $4
39	        /* prepare the system call EXITS(0) */
40	        MOVW $0, R1
41	        MOVW R1, 4(R13)
42	        MOVW $3 /*EXITS*/, R0
43	        /* system call */
44	        SWI
45	        RET /* not reached */
46	        
47	                        
48	GLOBL   hello(SB), $12
49	DATA    hello+0(SB)/6, $"Hello "
50	
@
%$
\n No libc! Using a simple _main. As simple as possible.
\l can also maybe show one that use libc, use 5c -S hello.c
\t can do with SP instead of R13 so less leaky abstraction 4(R13)?
\l note that we call PWRITE syscall directly, not pwrite(), subtle

%dup: from intro/getting-started
To assemble, link, and execute this program, simply do
like in Section~\ref{sec:getting-started}:
\begin{verbatim}
$ 5a hello.s
$ 5l hello.5 -o hello
$ ./hello
hello world
\end{verbatim}
\l if under ARM machine
\l show actual code? echo '$t :c' | 5i hello 
%$
\l show binary format? hexdump? (actually not bin instruction format! see below)
\t instruction to disassemble foo.5? db foo.5? 
\t 5l -v -W so dumper of object file? nm?

Appendix~\ref{chap:examples} contains more examples of assembly programs.

\subsection{Pseudo-instructions}
\label{sec:pseudo-instructions}

The [[helloworld.s]] program defines three {symbols}:
two {procedures} [[_main()]] and [[exit()]], and one {global} [[hello]].
%
The two procedures are introduced via the [[TEXT]] 
{\em pseudo-instruction} Line~1 and 38,
and the global via [[GLOBL]] Line~48.
We say ``pseudo'' (or sometimes ``virtual'') because those
instructions do not match directly a machine instruction.
They are assembly-only constructs, also known as
{\em assembly directives}. Indeed, the ARM processor
has no notion of procedure names; it just manages numbers
and concrete addresses.
\l GLOBL allocate mem, and TEXT actually does magic stuff

The operands of the pseudo-instructions [[TEXT]] and [[GLOBL]]
\n was arguments, but better operands, for uniformity, because they are really
are the name of the {symbol} it defines, followed by [[(SB)]]
which we will explain later, and a {\em constant} value prefixed by a dollar.
In Asm9 {\em all constants are prefixed by a dollar}.
\l why? ambiguities? I think it's stupid because easy to make mistake then
\l actually in DATA the size is specified without dollar in .../6, offsets too
% I was doing MOVW 0, R1 which translates to MOVW 0(R0), R1 (not sure why)
% instead of MOVW $0, R1 and so had some segfaults at 0xc because
% R0 was return value from syscall which was lenght printed = 0xc
%
For [[GLOBL]] the constant value represents the size, in number of
bytes, this global will use. For [[hello]] Line~48 it is [[12]]; enough
to hold the [["hello world\n"]] string.
%
For [[TEXT]] the constant value represents the size, in number of bytes,
this procedure will need for its {\em locals} in the {stack}. 
For [[_main()]] Line~1 it is [[20]], the
number of bytes needed to hold all the {arguments} in the stack
to the [[PWRITE]] system call 
\l more on this later, locals and arguments are the same
(4 for the file descriptor integer, plus 4 for for the string pointer,
plus 4 for the size, plus 8 for the [[vlong]] offset).
\n actually there is an implicit plus 4 as we will see later

Note that the linker [[5l]] is looking for a procedure named
[[_main]] for the entry point of the executable it generates,
even though the entry point of C programs is [[main]], not [[_main]].
This is because the core C library defines a [[_main()]] procedure
written in assembly which does some core initialisations
and then calls [[main()]].
In our example we do not use and so do not link the C library, 
to simplify things,
\l but in the end meh?
so we must define our own [[_main()]] entry point procedure.

%real-world: use .text, .data

\subsection{Labels}

The first instruction of [[_main()]] Line 2
\n actually there is an hidden instruction generated dealing with R14/R13
is a jump, known as a {\em branch} in ARM (hence the [[B]]),
to [[later]], which is a {\em label} defined Line~4.
In Asm9 {all label definitions are suffixed by a colon}. 
%
Labels are similar to symbols in that they allow to give
a symbolic name to a memory area. Labels are restricted to code area
though and are locals to an assembly file. There are used for
intra-procedural jumps.
\l also not suffixed by SB
\n how actually translated? in absolute (virtual) code address.
%
The syntax for {comments} in Asm9 are the same than in C
(see Line 3 and 5 for instance).

\subsection{Assignments}

Line 6 places the {address} of the [[hello]] global
(suffixed again by [[(SB)]] which we will explain later)
in the {register} [[R2]]. 
There are 16 ARM registers named [[R0]] to [[R15]].
\l last 3 have special meaning and used specially by ARM
Note that Asm9 uses a {\em left-to-right} assignment syntax\footnote{called the
\att syntax as opposed to the Intel syntax which is right-to-left}.
Moreover, in Asm9 [[MOV]] instructions are suffixed with a letter
corresponding to a size: [[W]] for word, [[B]] for byte, etc.
\l hmm also sometimes MOVBU, gas does that too
\n also MOV is virtual instr, see later
Line 7 places the character constant [['W']], converted
by the assembler in its integer ASCII value (87), into the
register [[R1]].
\l also unicode?

\subsection{Addressing modes}
\n https://en.wikipedia.org/wiki/Addressing_mode

Line 8 introduces a new {\em memory addressing mode}.
It is the first instruction that writes into memory; until now
we were only modifying the content of registers.
%
It {stores} the first byte (because of the [[B]] suffix)
of register [[R1]] (which should contain 87)
at the address {denoted} by [[R2]] plus [[6]].
%
The assembly instruction [[MOVB N, O(B)]] roughly corresponds
to the following C statement [[B[O] = N]], if [[B]] is a byte pointer,
which is also equivalent to this other C statement [[*(B+O) = N]].
\l what a strange syntax ... not sure where comes from, apparently not unix as
\n apparently vasm uses similar syntax, so maybe 68k motorola assembly syntax
\n which would make sense since 2a was the first assembler written by Pike
[[O]] is called the {\em offset}, which is applied to 
a pointer [[B]] called the {\em base}.
This addressing mode is called {\em indirect with offset}.
The [[()]] around the register corresponds rougly to the 
C {dereferencing} operator [[*]].
\n why not MOVB 'W', 6(R2)? linker limitations and RISC LDR/STR (talked later)

In fact, Line 6 introduced also an addressing mode.
The syntax [[hello(SB)]] is reminescent of the base
and offset addressing mode we have just seen.
[[SB]] stands for {\em static base} register.
It refers to the beginning of the address space of the program.
\n more on this later, it's a pseudo, it's not needed, it's weird
In Asm9 all references to global data and procedures
are written as offsets to [[SB]] 
\t offset cos in the end symbols will have static address and so static offset?
(for definition references see Line 1, 38, 48, and 49, and 
for use references see Line 6, 22, and 32).
%
The instruction [[MOVW foo(SB), R1]] will move the {\em content}
at the address denoted by the symbol [[foo]] into [[R1]].
The instruction [[MOVW $foo(SB), R1]] %$
will store the {\em address} denoted by the symbol [[foo]] in [[R1]].
The \$ in that case corresponds rougly to the 
C {address} operator [[&]].
\l ugly to overload dollar which is already used for constants? or because
\l  in the end it will be a constant, it will be really an offset
\l It is the first instr that read memory?? it's static?
\l  but why the generated code for Line 6 is MOVW #84(R15), R2 ? #10a8=#2000 ???
\l  this SB is weird

\subsection{Pseudo-registers}
\label{sec:pseudo-registers}

[[SB]] is actually one of the few {\em pseudo-registers} in Asm9.
[[PC]] is another one which corresponds to the
(virtual) {\em program counter}. 
Similar to pseudo-instructions, pseudo-registers
do not correspond exactly to machine registers.
Indeed, the ARM has already a hardware register, [[R15]], which 
represents the program counter. 
Because the ARM has fixed-length instructions of 4 bytes,
the value of [[R15]] is always a multiple of 4. The pseudo-register
[[PC]] instead counts instructions, not bytes of data. So,
to branch to the second following instruction (that is to skip
one instruction) one does [[B 2(PC)]].
\n which is really *(PC _plus_ 2)
It is equivalent to [[B 8(R15)]].
\l I think it is equivalent
\n branch are absolute, PC plus 2 is absolute

Why using pseudo-registers? The advantage of using [[2(PC)]]
instead of [[8(R15)]] in Asm5 may look small. But, on some
architectures the size of instructions is actually variable.
It is not trivial for instance on x86 to compute the number
of bytes two arbitrary instructions are using.
%
Just like with the symbolic addresses, using pseudo-registers
allows the programmer to think in slightly higher-level terms, 
for [[PC]] in terms of instructions instead of bytes of data,
and delegate some tedious tasks such as counting
the size of instructions to the computer.

Asm9 defines four pseudo-registers:
\begin{itemize}
\item [[PC]], the (virtual) {\em program counter} which counts in 
number of instructions.
For the ARM, [[PC]] is related to the (real) program counter register [[R15]].

\item [[SB]], the {\em static base} register which
refers to the beginning of the address space of the program.
For the ARM, [[SB]] is related to the machine register [[R12]].
\t For SB it's more tricky to understand why we need that. See Linker.nw?
\l R12 is reserved by assembler, it's not reserved by machine

\item [[SP]], the (virtual) {\em stack pointer}, used to access local
variables in the stack.
\l also called auto, but local maybe bad name; it is also for callee args
For the ARM, [[SP]] is related to the (real) stack pointer register [[R13]].
\l apparently it points to the top of the local stack frame! so offset
\l must be negative

\item [[FP]], the {\em frame pointer}, used to access the arguments
of the procedure in the stack, which is also related
to [[R13]] for the ARM.
\l set by caller
\t related to SP? more on this later. ref to section in grammar?

\end{itemize}

In this tutorial we will avoid using those pseudo-registers (except
[[SB]] because we have no choice).
Indeed, they may simplify things in the long term but they
add some extra complexities at the beginning.
\l generic, hide normally pecularities, complexities, but add some complexity

\subsection{Call stack}
\label{sec:call-stack}

Line 6 through 18 set characters in the [[hello]] global array of characters. 

We can now examine Line 20 through 29 which build the {arguments} for the
system call performed Line 31 (with the software interrupt instruction
[[SWI]]). Arguments, in function calls or system calls, are by {convention}
in \plan hold primarily in the stack. We will see later that
[[R0]] plays also a special role regarding arguments because of 
some C and kernel {\em calling conventions}.
\l convention to be in stack, but convenient, for recursive
As said in the previous section, [[R13]] is the ARM stack pointer register.
\n I use R13 and not SP because SP is a pseudo which get played with
\n in the linker, so simpler use directly R13 to minimize explanations
\t and also because I dont understand how to use SP properly ... hmmm
Figure~\ref{fig:stack-start}
is a representation of the stack when the [[hello]] program
is loaded in memory by the kernel
(the stack grows downward so high addresses are at the top in the diagram).
\n OSTEP book uses stack growing upward

\begin{figure}[!]\centering
\begin{verbatim}
        |       |
        |       |
R13 +-> +-------+
\end{verbatim}
\caption{Stack when [[hello]] started}\label{fig:stack-start}
\end{figure}

[[R13]] is initialized by the kernel before the kernel gives
control to the entry point of the binary program.
Its value is very high in the virtual memory address space.
Here is a dump of the registers using the emulator/debugger [[5i]]
before the program starts\footnote{
To fully understand the values of those registers
see the \book{Kernel} or the \book{Emulator} 
and especially the code of [[initmemory()]] in [[5i]].
}:

\begin{verbatim}
$ 5i helloa
5i> $r
...
R0  #7fffff70 R1  #7ffffffc R2  #0        R3  #0
R4  #0        R5  #0        R6  #0        R7  #0
R8  #0        R9  #0        R10 #0        R11 #0
R12 #0        R13 #7fffff58 R14 #0        R15 #1020
\end{verbatim}
\n first output line is: PC  #1020     SP  #7fffff58 but confusing I think
\n  because SP here is the machine SP, not assembler SP
\n why R0 weird value? and R1? TOS?
% in 5i see initmemory():
%    STACKTOP	= 0x80000000, 
%    ...
%    reg.r[0] = tos;
%    reg.r[REGSP] = sp;
%    reg.r[1] = STACKTOP-4;	/* Plan 9 profiling clock (why & why in R1?) */


Remember that the second operand to the [[TEXT]] pseudo-instruction
is the number of bytes this procedure will need for its {locals} in the {stack}.
\l locals, arguments
So, when assembled the [[TEXT]] pseudo-instruction Line~1
should generate a machine instruction which decrements R13 by 20. 
In fact, the actual generated instruction decrements R13 by 24;
\l in fact it also does also some magic with R14
we will see later why we need an extra word in the stack before the arguments.
%
Figure~\ref{fig:stack-line2} is the representation of the stack after Line~1
when the processor starts to execute the instruction Line~2.

\begin{figure}[!]\centering
\begin{verbatim}
        |       |
        |       |
    +24 +-------+ <-+ old value of R13
        |       |
    +20 +-------+
        |       |
    +16 +-------+
        |       |
    +12 +-------+
        |       |
     +8 +-------+
        |       |
     +4 +-------+ <- start of "locals"
        |       |
R13 +-> +-------+
\end{verbatim}
\caption{Stack before Line 2}\label{fig:stack-line2}
\end{figure}

Figure~\ref{fig:stack-line31} is the same stack before Line~31 
after the arguments to the system call have been set by Line~20 through 28.
\l note that arguments are in the ``stack space'' of the caller

\begin{figure}[!]\centering
\begin{verbatim}
        |       |
        |       |
    +24 +-------+ <-+ old value of R13
        |  0    |
    +20 +-------+
        |  0    |
    +16 +-------+
        |  12   |
    +12 +-------+
        |&hello |
     +8 +-------+
        |  1    |
     +4 +-------+ <- start of PWRITE arguments
        |       |
R13 +-> +-------+
\end{verbatim}
\caption{Stack before Line 31}\label{fig:stack-line31}
\end{figure}
\l remember 0 0 because vlong offset

\subsection{System calls}

The \plan{} {\em kernel calling conventions} impose to have all
the arguments in the stack ``above'' [[R13+4]],
and to use [[R0]] to hold
the syscall ``code''. The magic constant value [[9]]
at Line~29 is the code corresponding to the [[PWRITE]]
system call. See the file [[lib_core/libc/9syscall/sys.h]] 
which defines all those syscall codes.
\n could actually #include and use PWRITE but less feature to explain that way
\n R0 is not the first argument anymore
The [[SWI]] instruction Line~31 then performs the system call
and jumps in the kernel.
\l normally SWI has one operand in ARM, but in plan9 use R0 for that
\l need extra words before arguments for syscall too? because C convention?

\subsection{Function calls}
\label{sec:bl}
\l branch and link

Regular function calls in Asm5, e.g. the call to [[exit]] Line~32,
use the [[BL]] instruction which stands for {\em branch and link}.
%
Some processors such as the x86 have a [[CALL]] instruction 
which when executed push on the stack the value of the program counter
and then jump/branch to the code of the callee.
\l put diagram of recursive call here? how the magic works!
Then, a corresponding [[RET]] instruction in the callee
will pop back this value in the program counter to return back
to the caller.
\t and add 4? or it's done before? see code of BL in Machine.nw
\l classic use of stack, can do recursive functions like that
%
In the ARM, [[BL]] instead saves the value of the program
counter [[R15]] in the special register [[R14]] 
called the {\em link register}, and then jump to the callee. 


The use of a special register to hold {return addresses}
is an ARM optimisation which avoids using the stack, and so 
memory, which is slow, in certain situations.
%
Indeed, when a function does not call other functions, 
in which case it is called a {\em leaf} function, the value
of [[R14]] does not need to be saved and so returning
to the caller can be done quickly by setting the program
counter to the value in the link register via: [[B (R14)]].
\l or MOVW R14, R15 but apparently 5l does the B above.
%
If the function is not a leaf, then the value in [[R14]]
must be saved somewhere, in the stack, before the function calls
another function via [[BL]] which would overwrite [[R14]]
\footnote{See the \book{Emulator} for more information on the ARM and [[BL]]}. 
%
Non-leaf functions are the reason the [[TEXT]] pseudo-instruction
allocates one more word than its second operand, e.g. 24
instead of 20 for [[_main]] Line~1, to hold the return address
to the caller in case [[R14]] needs to be saved.

\subsection{Virtual instructions}
\label{sec:ret}

The leaf detection is done ({statically}) by the linker [[5l]]
since it is the program generating actually the machine code in \plan,
and so the program which needs this information to optimize machine code.
%
A leaf is simply any procedure which does not contain any [[BL]] instruction,
for instance [[exit]] in our example\footnote{[[SWI]] does not count 
as a function call; [[R14]] is not overwritten by a [[SWI]].
}.
\l In any case the kernel saves all the registers of the calling process?
\l actually only when context switch no?
[[_main]] on the opposite is not a leaf function since it is
using [[BL]] Line~32.
%
The actual machine instructions generated for the [[TEXT]] pseudo-instruction
depends on whether the function is a leaf. 
The same is true for [[RET]], Line~33 and 45,
which is called a {\em virtual instruction}.
\l we call it that way? or asm.pdf does?
Indeed, the ARM does not have any [[RET]] instruction.
%
Figure~\ref{fig:virtual-text-ret}
describes roughly what machine code is generated
for the pseudo and virtual instructions [[TEXT]] and [[RET]]
of a simple procedure [[foo]], depending on whether this
procedure is a leaf or not.

\begin{figure}[!]\centering
\begin{verbatim}
TEXT foo(SB), $0   MOVW R14, 0(SP)          
                   SUB $4, SP, SP
 ...               ...                      ...
                   ADD $4, SP, SP           
 RET               B 0(SP)                  B (R14)
----------------  -----------------------  ------------------
  assembly code    machine code non-leaf    machine code leaf
\end{verbatim}
\caption{Machine code for pseudo/virtual instructions [[TEXT]] and [[RET]]}
\label{fig:virtual-text-ret}
\end{figure}
\t actually need -4? 
\t but SP is virtual above? or R13?
\l actually for TEXT it is a single MOVW.?? R14, #-4(R13) 
\l  and for RET it is MOVW.P #4(R13), R15
\l and actually it's ADD 0, R14, R15 instead of B (R14) (5l opti?)
\l not also that leaf opti is applied only if no locals (autosize = 0)
\l  so a bit less interesting. See leaf.s

%real world: -fomit-frame-pointer see later in grammar chapter.

The virtual instruction [[RET]], just like the 
pseudo-instruction [[TEXT]], or the pseudo-registers, allows the programmer
to think in slightly higher-level term and let the computer
do the appropriate optimizations.
%
In fact, [[MOVW]] is also a virtual instruction. It hides some 
architecture restrictions and peculiarities regarding memory accesses.
in Asm5 one can use the very general [[MOV]]
even though the ARM processor supports only the
more basics and separate [[LOAD]] and [[STORE]] instructions.
\n actually there is a MOV and it's LDR and STR but same basic idea
\n and also MOVW generalizes MSR and MRS that mov StatusRegister
\l but a bit leaky abstraction because the linker puts later some restrictions

Instructions Line~40 though 44 are similar to the instructions
we have seen before. They perform the system call [[exits(0)]]
which terminates the program. This is why a few instructions
have been marked with a comment indicating those instructions
can not be reached since the program will have exited already
(and so will not perform the [[RET]]).

\subsection{C calling conventions}

Note that the way arguments are laid out in the stack in
Figure~\ref{fig:stack-line31}, as well as the extra word before the
arguments (to possibly save the return address to the caller via
[[R14]]), and the fact that all those elements are ``above'' the stack
pointer ([[R13]]) at the entry of the function callee (or syscall
interrupt handler), is just a {\em convention}. 
%
The ARM processor does not dictate any specific way to call procedures.
In fact it does not even have a notion of procedure.
It only provides the [[BL]] machine instruction which saves 
[[R15]] in [[R14]]. The rest is a design choice.

The calling conventions we use in this tutorial come from the
{\em C calling conventions} used by the C compiler [[5c]].
Indeed, the assembly code generated by [[5c]] assumes
arguments are passed in a certain way and the stack
pointer has a certain value. 
\n because you need that! you need at least a convention, see later.
We use similar conventions
in this tutorial because the code we present
performs a system call and the \plan{} {kernel calling conventions}
are derived from the C calling conventions. Indeed, the kernel
is mostly written in C.

The C calling conventions are actually slightly different from
the kernel calling conventions. Instead of using [[R0]] to
store the syscall code, [[R0]] is used to store the first argument.
In fact [[R0]] is also used to store the return value of C
functions.
\l except for vlong? and float?
This is an optimisation similar to the one we have seen previously
with the link register. 
\l but compiler opti, not hardware opti
For certain simple and small functions,
everything can be done using just registers, without having to use
the stack and so the (slow) memory.

Figure~\ref{fig:stack-c-pwrite} shows how the stack would
look like is we were calling the C function [[pwrite()]]
instead of doing directly the system call to [[PWRITE]].

\begin{figure}[!]\centering
\begin{verbatim}
        |       |
        |       |
    +24 +-------+ <-+ old value of R13
        |  0    |
    +20 +-------+
        |  0    |
    +16 +-------+
        |  12   |
    +12 +-------+
        |&hello |
     +8 +-------+
        |       |
     +4 +-------+ <- start of pwrite() arguments
        |       |
R13 +-> +-------+

R0 = 1
\end{verbatim}
\caption{Stack and [[R0]] value for a C call to [[pwrite()]]}\label{fig:stack-c-pwrite}
\end{figure}
\t link to appendix pwrite.s? where see translation from C convention to kernel

Note that because the first argument is stored in [[R0]], 
the code generated by [[5c]] for a function call does not
bother to store it also in the stack. But, similar to the
link register optimisation, an extra word in the stack is still allocated
for the first argument in case the callee need to overwrite [[R0]]
in which case it can save first its value in the stack.
\l note that like R14 we save extra space in caller without knowing
\l if callee really needs it.

The calling conventions used by [[5c]] could be completely different:
the order of the arguments in the stack could be reversed, 
\n but C variable number of arguments '...' would be harder
more registers could be used to store the first $n$ arguments,
the stack arguments could be ``below'' the stack pointer,
the responsability to manage the return address in the stack
could be done by the callee instead of the caller.
The actual {\em C calling conventions} implemented by [[5c]]
are though a nice compromise between simplicity and speed.

Because most assembly code interoperate with C code,
the C calling conventions are also the {\em assembly calling conventions}
in \plan.
\l really?
Note that the only constraint imposed by Asm5
on the calling convention 
is the extra word in the stack above [[R13]] to store
the return address to the caller, because of the
code generated for [[TEXT]] and [[RET]] by [[5l]].

\subsection{Data layout}
\label{sec:data}

The last piece of assembly code we need to explain is Line~49 which initializes
(partially) the content of the [[hello]] global. Indeed, 
even if Line~48 {\em declares} the [[hello]] global with the [[GLOBL]] 
pseudo-instruction, it is the [[DATA]] instruction which {\em defines}
the content of the global. 
%
The operands of [[DATA]] are in order:
\begin{enumerate}
\item the symbol of the global,
possibly with an offset (here [[+0]]), and as always for references to
globals the [[(SB)]] suffix

\item a slash followed
by an integer between 1 and 8 representing the size in
number of bytes this [[DATA]] instruction is defining (here [[/6]])
\l but no dollar here, hmmm
 
\item a constant, which can be an integer, a character, or a string of
less than 8 bytes.
\l ximm so can also be float, or address of symbol
\end{enumerate}
\l a bit weird those constraints and conventions

To define data which takes more than 8 bytes, one needs
to use multiple [[DATA]] instructions. For instance
to define completely [[hello]], which would remove the need
for Line~6 to 18 (added for educational purposes in this tutorial),
one could have done instead:

<<full definition of [[hello]] content>>=
GLOBL   hello(SB), $12
DATA    hello+0(SB)/8, $"hello wo"
DATA    hello+8(SB)/4, $"rld\n"
@
%$
\l see data2s also

\l need the antislash z?
%The [[\z]] are the equivalent of [[\0]] in C and represents
%the zero value. They are not 
%        MOVW $'\z', R1
%        MOVB R1, 12(R2)



\section{The ARM architecture}

The three letters ARM represent different things: 
a family of RISC machines (Akorn Risc Machines), 
a family of instruction set architectures (ISAs), and 
also a family of processors. 
%
But, up until now, and also for the rest of this document, 
when we use the term ARM we mean the {\em ARMv6} instruction set architecture.
Confusingly, ARMv6 is the instruction set
used in the {\em ARM11} 32 bits processor 
family~\furl{http://www.arm.com/products/processors/classic/arm11/?tab=Specifications}.
This family powers many smartphones
\l most?
as well as the Raspberry Pi.
\l ARM1136

Because an assembly language mimics closely the instructions
of a machine, most of the instructions in Asm5
are instructions of the ARM: [[B]], [[BL]], [[SWI]], [[ADD]], etc.
The same is true for the registers [[R0]] to [[R15]].
To fully understand those assembly instructions we refer
to our \book{Emulator} which describes the semantics of 
the corresponding ARM machine instructions, or to
the ARM reference manual~\cite{arm-refman}.
%
Asm5 introduces also some pseudo-instructions, pseudo-registers,
and virtual instructions, as we have seen in the previous section,
and those will be fully explained in this document.

%dup: from intro/5a
As said briefly in the introduction, [[5a]] does not
generate machine code, the linker [[5l]] does, 
%
so there is no need to know the binary format of ARM instructions
to understand this document.
\l opcode format, see 5i/ it's more the job of 5l and optab to do that.

\section{Input assembly language}

%trans:
We have covered already in Section~\ref{sec:helloworld} 
many features of the assembly language Asm5,
the language used by the input files of the assembler [[5a]].
%toc:
In this section we summarize those features and
give a more systematic description of Asm5, which should
help solidify your understanding of Asm5.
\l this is not a reference manual, but it is enough to help implement.
%
We recommend to read [[assemblers/docs/asm.pdf]] for more information.
\n but not really more complete information, my tutorial is better
%note: was useful to write this summary, see better now the whole lang/picture
% almost look like a refcard

\subsection{Lexical elements}
\label{sec:asm5-lexical}

The main lexical elements of Asm5 (and also of Asm9) are:
\n implementer POV
\begin{itemize}
\item {\em integers}, e.g. [[42]] (decimal), [[0x12]] (hexadecimal), [[0666]]
(octal)
\n hexa/octal is new, not in tutorial

\item {\em characters}, e.g. [['W']], [['\n']], [['\007]]
\n octal is new, not in tutorial

\item {\em strings}, e.g. [["hello wo"]]. Strings are limited
to 8 characters or less.
\l why? meh

\item {\em floats}, e.g. [[4.2]], [[10e43]]
\n this is new, not in tutorial


\item {\em predefined identifiers} in uppercase, used for the mnemonics of
opcodes ([[ADD]]), 
registers ([[R0]]), 
pseudo-instructions ([[TEXT]]) and 
pseudo registers ([[PC]]).
\l keywords

%\begin{quote}
%  ``Instructions, registers, and assembler directives are always in
%  UPPER CASE to remind you that assembly programming is a fraught
%  endeavor.'' - Rob Pike
%\end{quote}
\n https://golang.org/doc/asm (cited also from golang is trash article)

\item {\em identifiers} in lowercase, used for 
symbols ([[_main]]) and 
labels ([[later]])
\l have to be lowercase?
\l cant have DOT in it except at start, annoying, which is why in go code they
\l use a special unicode that looks like dot

\item {\em comments}, e.g. [[/* not reached */]], [[// comment]].
They use the same syntax than C comments and are ignored by [[5a]].

\item {\em spaces} and {\em tabs}, which are also ignored by [[5a]].
By convention though it is common to indent with a tab most
instructions except pseudo instructions like [[TEXT]] which
are kept in the first column.

\item {\em newlines}, which are actually internally transformed in semicolons.
The semicolon is an instruction {terminator} in Asm9. So, one can then either 
\n yep terminator, not separator, see inst grammar rule
write multiple instructions on different lines,
or multiple instructions on the same line but separated by an explicit [[;]].

\item {\em operators}, e.g. \$, [[()]], [[/]], [[+]], [[;]], [[<>]], etc,
which can have different meanings depending on the context
\l also extended C operators for asm9 constant expressions

\end{itemize}
\l also cpp lexical elements

\subsection{Syntactical elements}

The main syntactical element of Asm5 is the {\em instruction}.
An Asm5 file is made essentially of a list of instructions, usually
one per line. 
An instruction is composed of an {\em opcode}
followed possibly by 1, 2 or 3 {\em operands}. 
A line can also contain a {\em label} definition which is an identifier
followed by a colon, e.g. [[later:]].
\n actually can have list of labels, but convention is label alone on its line

\subsection{Opcodes}

Opcodes correspond to different kinds of instructions:
\begin{itemize}
\item {\em machine instructions}, e.g. [[B]], [[SWI]], [[ADD]]

\item {\em pseudo-instructions}, e.g. [[TEXT]], [[GLOBL]],
also known as assembly directives
\l note TEXT has actually an operand and it is a memory reference :)

\item {\em virtual instructions}, e.g. [[RET]], [[MOVW]], [[NOP]]
which are instructions without a
1-to-1 mapping to a machine code instruction, but which
are convenient for the programmer (or compiler writer).
They can hide some architecture restrictions or peculiarities. 
\l makes asm a bit more portable
\end{itemize}

\subsection{Operands}

Depending on the opcode, different kinds of operands are possible:
\begin{itemize}
\item {\em constants}, which in Asm9 are always prefixed with a dollar,
e.g. \$42, \$[['W']]
\l why? to avoid ambiguity with what? otherwise offset like 32(SP) have no dol

\item {\em registers}, named [[R0]] to [[R15]] in Asm5

\item {\em pseudo-registers}, named [[PC]], [[SP]], [[FP]], and [[SB]]
in Asm9
\l actually cant anymore have them as operands directly

\t forgot bit shifted registers, but too subtle here?

\item {\em label references}, e.g. [[later]]
\l B xx vs B(SB)

\item {\em memory references}, which we describe below

\end{itemize}

\subsection{Addessing modes}
\label{sec:ref-addressing-modes}

Memory references appear mainly in 
memory moves (e.g. [[MOVW]]),
branching instructions (e.g. [[BL]]), 
as well as in entity definitions (e.g. [[TEXT]]).
%
There are multiple ways to reference memory in Asm5,
called {\em memory addressing modes}:
\begin{itemize}

\item {\em indirect}, using [[()]] around a register or
pseudo-register, e.g. [[(R1)]], which means
the content at the address {denoted} by [[R1]]
\n Can have just pseudo register? not anymore

\item {\em indirect with offset}, e.g. [[4(R1)]],
which means the content at the address denoted by [[R1]]
plus 4. Note that there is no prefixing dollars for offsets.
\l can have pseudo here, specially PC and FP and SP. But not SB.

\item {\em symbol reference}, which is always written as ``an offset''
to a pseudo-register, e.g. [[hello(SB)]],
which means the content at the address denoted by the symbol
[[hello]].
\t offset cos at some point symbol become static address and so number/offset
\t actually here can have only SB I think. or 0(FP), 0(SP)

\item {\em symbol reference with offset}, e.g. [[hello+4(SB)]],
which means the content at the address denoted by the global symbol
[[hello]] plus 4.
%
With [[SB]] the symbol denotes a global or procedure,
with [[SP]] a local variable, and 
with [[FP]] an argument.
\n and PC? no.
\l for Text, data, param, locals
%
For locals and arguments it is also common
to use a symbol as in [[x+4(SP)]] or [[length+4(FP)]]. In those
cases the symbol is just a ``comment'' to give a name to
the local or argument. This comment though is kept in the
symbol table of the object file as we will see in Chapter~\ref{chap:generation}
and can be used by debuggers as we will see in Chapter~\ref{chap:debugging}.
\t plus offset for SB has a meaning?


\item {\em symbol address}, using \$ before the symbol,
e.g. \$[[hello(SB)]], which means the address of the symbol
[[hello]].

\l and weird stuff with slash   hello _plus_ 0(SB)/6

\end{itemize}

Note that Asm9 uses a left-to-right assignment syntax. For moves,
\l AT&T syntax, normal
[[MOVW (R1), R2]] means moving the content at
the address denoted by [[R1]] into [[R2]]. The same
is true for other instructions such as [[ADD]] where the
destination register is the last operand and the sources the two
first operands.


\l take some examples, e.g. start-KZERO(SB), and explain? see comment in .tex
\l will see later also local symbol, with angle operator
%concepts: 
% - external symbols = fully unresolved! will be resolved at linking time
%   but needs to keep the name in the symbol table and the place where it
%   was referenced
%   (note that external entities are not even declared, any use of a symbol
%    not defined in the file is an external reference)
%    less: maybe this should be fixed, easy to make a typo)
%
% (LONG is a macro?)
%        LONG    $-(0x1BADB002 + 0x00010003)     /* checksum */
%vs
%        LONG    $_start-KZERO(SB)          /* load_addr */
%
%why need SB in second case? because it refers to symbol in certain section?
% it's to take the address of _start symbol in SB and adjust
% by removing KZERO to it. tricky. It's really $  _start(SB) - KZERO
%
% it does not have extern declaration, but any ref is implicitely
% an extern.

\l section{Runtime conventions}? hmm more compiler specific

\subsection{Advanced features}
\label{sec:mcrr-macro}
\n this is new, not in tutorial

Asm9 has a few more features beyond mnemonics and symbolic addresses:
\begin{itemize}
\item {\em constant  expressions} as operands, e.g. \$[[1<<6|3]],
which are evaluated at {assembly time}.

\item an embedded {\em macro-processor} similar to [[cpp]] with
features such as [[#include]] and [[#define]]. [[5a]] is thus
what people calls a {\em macro-assembler}.
%
This, combined with the previous feature, allows to overcome
some of the original limitations of [[5a]]. Indeed, even if [[5a]]
does not support any mnemonic for some of the advanced
{coprocessor} ARM instructions, 
\l actually has MCR and MRC
one can simply define and use the macro [[MCRR]] defined below
which encodes the binary format of the instruction directly.

%We will not explain though in this book the code related
%to this embedded macro processor as we will explain
%similar code in the \book{Compiler}.
\l compiler book is already big, maybe better do it here?

\item {\em symbolic constants}, e.g. [[TMP = 11 ... MOV R1, R(TMP)]],
which were called originally (and ironically) {\em variables}.
They are redundant with the [[#define]] of the macro-processor, 
but were probably added before [[5a]] became a macro-assembler.
%this feature has been removed from our version of [[5a]].
\l use LVAR for lexeme name, hmmm

\end{itemize}

\l those are the most common features, we describe more advanced later as needed

% put outside itemize because weird layout otherwise
<<macro MCRR>>=
#define MCRR(coproc, op, rd, rn, crm) \
   WORD $(0xec400000|(rn)<<16|(rd)<<12|(coproc)<<8| \
          (op)<<4|(crm))

@
%$
The [[WORD]] pseudo-instruction is described in Section~\ref{sec:WORD}.

\section{Output object format}
\label{sec:object-format-part1}

%dup: from intro/5a
As said in the introduction, the {object files} generated by [[5a]],
which use the~[[.5]] filename extension,
are ARM-specific, but they do not contain really machine code. Instead
an object file contains the {serialized form} of the 
{abstract syntax tree} of the assembly source. 
%dup: too many dup I think the sentence below so I commented it
%The actual machine code generation is performed by the linker [[5l]].
\t why better? because anyway cant resolve everything, and patch is complicated
\t so simpler work on the original abstract syntax tree
\n ocamlc does that too!

Because an Asm5 file is essentially a list of instructions,
its serialized form is simply a concatenation of serialized instructions.
The resolution of label addresses is done by the assembler,
so label definitions do not need to be serialized.
Label references in branching code are transformed in
absolute (virtual) addresses.
\n NO concrete offsets to the [[PC]] pseudo-register.
\t but still need be relocated when concatenated

A serialized instruction has also a pretty simple format
since all instructions, including the pseudo-instructions.
have the same form: an opcode followed by 0 to 3 operands.
%
One byte is enough to encode the opcode
on the ARM since there are far less than 256 ARM opcodes (and
very few pseudo-opcodes). Indeed the ARM is a RISC machine.
[[8a]] on the opposite needs 2 bytes to represent an x86 opcode.
%
Another byte is used to encode the {\em kind} of the first operand
(e.g. an integer constant, a register, a memory address, nothing) followed by
a serie of bytes encoding the actual operand value
(e.g. 4 bytes for an integer constant, 1 byte for the register number, etc).
%
The complete format is described precisely in Chapter~\ref{chap:generation}
but Figure~\ref{fig:object-format} describes roughly the content 
of an object file.

\begin{figure}[!]\centering
\begin{verbatim}
|                  |
+------------------+
|    Opcode        |
|                  |
+------------------+  <--- start of second instruction
|        .         |
|        .         |  <--- operand 2 encoded value
+------------------+
|  Operand 2 kind  |
|     (1 Byte)     |
+------------------+
|        .         |  <--- operand 1 encoded value
|        .         | 
+------------------+
|  Operand 1 kind  |
|     (1 Byte)     |
+------------------+
|        .         |
|        .         |  <--- instruction metadata 
|        .         |       (e.g. line number) 
+------------------+
|     Opcode       |  
|    (1 Byte)      |
+------------------+  <--- start of the .5 file 
\end{verbatim}
\caption{File format of a [[.5]] object file}\label{fig:object-format}
\end{figure}
\t symbol table about unresolved? imported and exported? at the end of file
\t actually use a very special encoding scheme, see sectionXX
\l same for history at the beginnning of file, but it actually abuse
%   instruction format with AHISTORY (but there are also lots of ANAME)

%ocaml: just marshall the ADT, and unmarshall in linker => shorter code!
%update: hmm but the format is actually not that complicated, so we may win
% but not that big probably. Also nice to have a format that other programs
% coded in different languages can read.

\section{Code organization}

Table~\ref{tab:code-orga} presents a short description
of the source files used by [[5a]], 
the main entities (structures, functions, globals, etc) the file defines,
and the corresponding chapters in this document in which the code
contained in the file is discussed.
\n sorted by chapters, make more sense than sorted by dir

There are multiple assemblers in \plan, one per supported architecture
(ARM and x86 in our \plan fork). The generic code has been
factorized in the [[assemblers/aa/]] directory. 
\l and common.out.h
The ARM-specific code is in [[assemblers/5a/]] 
as well as in [[include/arch/arm/5.out.h]]
(and for x86 in [[assemblers/8a/]] and [[include/arch/386/8.out.h]]).

\begin{table*}[tbh!]
\begin{tabular}{llllr}
\toprule
{\bf File} & {\bf Description} & {\bf Entities} & {\bf Chapters} & {\bf LOC} \\
\otoprule
[[aa/aa.h]] & Symbol table and input related structures & [[Sym]], [[Io]], [[Fi]] & \ref{chap:core-ds}, \ref{chap:input} & 243 \\
%, [[Hist]] [[Htab]],
[[include/.../5.out.h]] & ARM opcodes, operand kinds, registers & [[Opcode]], [[Operand_kind]],  & \ref{chap:core-ds} & 300 \\
 & & [[Register]] & & \\
[[5a/a.h]] & ARM operand & [[Gen]] & \ref{chap:core-ds} & 103 \\
% why not put in 5.out.h too? could be reused by linker and compiler?

\midrule

[[aa/globals.c]] & Generic globals (e.g. output filename) & [[hash]], [[symb]], [[outfile]],   & \ref{chap:core-ds}, \ref{chap:main} & 97 \\
 & & [[pass]], [[pc]] & & \\

[[5a/globals.c]] & ARM-specific globals & [[nullgen]] & \ref{chap:main} & 7 \\


[[5a/main.c]] & Main entry point and main functions & [[main()]], [[assemble()]],  & \ref{chap:main} & 492 \\
              & & [[outcode()]] & \ref{chap:generation} & \\
% (I created this file)

\midrule

[[aa/lexbody.c]] & IO and lexing utilities & [[newfile()]], [[yyerror()]],  & \ref{chap:input}, \ref{chap:error} & 664 \\ 
% also lookup(), hmmm


[[5a/lex.c]] & Lexer for Asm5 (not using Lex) & [[yylex()]] & \ref{chap:lexing} & 570 \\

[[aa/macbody.c]] & Macro processing (embedded [[cpp]]) & [[macdef()]], [[macinc()]] & \ref{chap:preprocessing} & 867 \\
 & & [[macexpand()]] & & \\
% mac = macro (not macos :)

[[5a/a.y]] & Yacc grammar for Asm5 & [[yyparse()]], [[inst()]] & \ref{chap:parsing} & 599 \\
% (and calls to outcode)


\midrule

[[aa/utils.c]] & Memory allocation, error managment & [[alloc()]], [[errorexit()]] & \ref{chap:error}, \ref{chap:libc} & 84 \\
% use outfile global in globals.c, use yyerror() (I created this file)

[[aa/compat.c]] & System function wrappers for compatibility & [[mycreat()]], [[mywait()]] & & 50 \\
%todo: to delete at some point?
 & with \unix & & & \\

\midrule
[[include/.../common.out.h]] & IEEE float structure & [[Ieee]] & \ref{chap:advanced} & 22 \\
% and NSYM constant

\otoprule
Total & & & & 4098 \\
\bottomrule
\end{tabular}
\caption{Source files of [[5a]]}
\label{tab:code-orga}
\end{table*}
\n see SRC_VIEWS in the Makefile, and make loc
\l could have a input.c and output.c

\section{Software architecture}
\label{sec:archi}

Figure~\ref{fig:controlflow} describes roughly 
the main control flow and main {components} of [[5a]], while
Figure~\ref{fig:dataflow} describes 
the main data flow of [[5a]].

\begin{figure}[!]\centering
\begin{verbatim}
            +-------------+         
            |    main     |         
            +------+------+         
                   |                
                   |                
            +------v------+         
            |  assemble   |         
            +----+--+-----+         
                 |  |               
                 |  |               
            +----v--v-----+         
            |  yyparse    | (Parser)        
            +---+-------+-+         
                |       |              
       +--------+       +-------+      
       |                        |      
+------v-------+         +------v-----+
|   yylex      | (Lexer) |  outcode   | (Object code generator)
+------+-------+         +------------+
       |                            
       |                            
+------v-------+                    
|    macxxx    | (Preprocessor)                   
+--------------+                    
\end{verbatim}
\caption{Control flow diagram of [[5a]]}\label{fig:controlflow}
\end{figure}
\l add chapter ref in the box? next to the box?
%ocaml: if the code was more functional the diagram would be just a pipeline!
\n alternative with cclean? not that important so better to remove it


\begin{figure}[!]\centering
\begin{verbatim}
assembly file -> tokens -> instructions -> object file
                (use global symbol table)
\end{verbatim}
\caption{Data flow diagram of [[5a]]}\label{fig:dataflow}
\end{figure}
\l focus on components instead? Lexer->Preprocessor->Parser->Generators?


After some basic command line processing and initialisations,
the function [[main()]] calls [[assemble()]] with the name
of the assembly file to process. 
%
[[assemble()]], after further initialisations,
uses then a two-pass algorithm and so calls 
[[yyparse()]], the function generated by [[yacc]] from the Asm5 grammar,
two times. It also modifies the global [[pass]]: for the first
call to [[yyparse()]] the value of [[pass]] is 1, and for the second
call the value of [[pass]] is 2.

The {parsing} function [[yyparse()]] internally calls the lexing
function [[yylex()]] to get the next {\em token} from the input file.
[[yylex()]] is usually generated by Lex from a set of 
{regular expressions}, but in the case of [[5a]] was handcoded.
\l why?
[[yylex()]] itself calls {macro-processing} related functions,
e.g. [[macinc()]] (for ``macroprocessing include''), as [[5a]] 
is a macro-assembler supporting [[cpp]] directives such as [[#include]].

From a set of tokens, [[yyparse()]] can parse using
different {\em grammar rules}
a constant,
a register,
an operand, 
an opcode, 
an instruction,
and finally a set of instructions.
%
The Yacc {\em actions}\footnote{
See~\cite{lexyacc} for more information on Yacc grammar rules and actions}
associated with those grammar rules
gradually build and return abstract syntax trees (ASTs) of
subparts of an instruction.
\l not really trees though
Once a full instruction
has been parsed, via the [[inst]] grammar rule,
the yacc action for [[inst]] is triggered,
which calls the function [[outcode()]] with the AST of the 
parsed instruction.
\n actually 5 subASTs arguments but they represent the AST
% 5a abuse tokens and the grammar to do some computations (classic old style)
%ocaml: could return full AST, list of instr and then outcode of that.

[[outcode()]] outputs then the serialized form of the instruction AST
in the object file, but only when the global value of [[pass]] is 2.
Whatever the value of [[pass]], [[outcode()]]
also increments each time [[pc]], a global representing the
current value of the {\em virtual program counter}.

The lexing and parsing code internally use and modify a 
{\em symbol table} called [[hash]], which keeps track of the value
of different kinds of identifiers, for instance labels.
%
During lexing, when a new identifier is encountered, a new
symbol in the symbol table [[hash]] is created. 
%
During parsing, once an identifier is recognized as
a label, because it is followed by a colon token,
its {\em type} in the symbol table is changed to a label type, 
and its value is set to be the current value of the global [[pc]].
%
During the second pass, any reference to this label 
can be resolved by simply looking at the value of the label in the symbol
table.

\n talk about cclean? maybe not that important, a big ugly, no need AEND.

\l relation with other tools? 5c, 5l? easy, do git grep, see comment .tex
% git grep AADDB
%assemblers/8a/lex.c:    "ADDB",		LTYPE3,	AADDB,
%compilers/8c/peep.c:    case AADDB:	/* rhs rar */
%compilers/8c/reg.c:        case AADDB:
%compilers/8c/txt.c:            a = AADDB;
%include/386/8.out.h:    AADDB,
%linkers/8l/optab.c:    { AADDB,	yxorb,	Px, 0x04,0x80,(00),0x00,0x02 },

\l Symbol table assembler, and symbol table in object file! in/out.

\l Depends libc, libio




%\section{Bootstrapping}

% 5a is actually written in C :) not even asm! and also use yacc
% bootstrap from scratch? punch card, hex-to-c, assembler in assembler, 
% asm in C

\section{Book structure}

%trans:
We now have enough background to understand the source code of [[5a]].
%toc:
The rest of the book is organized as follows.
%
We will start by describing the core data structures of [[5a]]
in Chapter~\ref{chap:core-ds}. 
%
Then we will use a top-down approach in Chapter~\ref{chap:main} and 
starting from [[main()]] we will present the code of the main 
functions, e.g. [[assemble()]].
%
The following chapters will be dedicated to describe
the main components of the assembling pipeline:
Chapter~\ref{chap:input} will present the input routines,
Chapter~\ref{chap:lexing} the lexer,
Chapter~\ref{chap:preprocessing} the preprocessor,
Chapter~\ref{chap:parsing} the parser,
and finally Chapter~\ref{chap:generation} the object code generator.
%
In Chapter~\ref{chap:debugging} we will describe the code
responsible for adding debugging support in [[5a]], which
for instance add line information in the object code. 
One can then know, when debugging a binary program,
to which original line and which source file an
instruction in the binary comes from, or what is the
original name of the procedure containing this instruction.
%
Chapter~\ref{chap:advanced} presents other
assembly features which we did not present 
before to simplify the explanations, for instance
the support for floats. Those features tend to crosscut
many components with extensions to the lexer, the parser,
and the code generator.
%
Finally Chapter~\ref{chap:conclusion} concludes
and give pointers to other books in the \principia serie.

%toc:
Some appendices present the code of non-functional properties:
code to help debug [[5a]] itself in ppendix~\ref{chap:debugging-appendix}, and 
code to manage errors in Appendix~\ref{chap:error}.
%
Appendix~\ref{chap:libc} contains the code of generic
utilities used by [[5a]] but which are not specific to [[5a]].
%
Appendix~\ref{chap:examples} contains more examples of
assembly programs to get a better feel of Asm5 and how
it is used in practice.
%
Finally, Appendix~\ref{chap:5a-ocaml} contains
the code of an OCaml port of [[5a]].
\t what for? :)












\chapter{Core Data Structures}
\label{chap:core-ds}

\begin{verse}
\begin{flushright}
  {\it Show me your code and conceal your data structures, and I shall
    continue to be mystified. Show me your data structures, and I
    won't usually need your code; it'll be obvious.\\
    ~\\
    Fred Brooks}
\end{flushright}
\end{verse}
\n actually I think the original quote is with "flowchart" and "tables"

%toc:
In this chapter we will present the core data structures used by [[5a]].
The first three sections contain the definitions
of the different components of the abstract syntax tree (AST) 
\l not really a tree though
of an instruction:
the opcode, 
the register (which is a kind of operand),
and the other kinds of operands.
\l internal memory representation of assembly textual instructions!
Then we will see how tokens are represented.
Finally we will present the symbol table which is
a central data structure used by 
the lexer,
\n predefined identifiers, but ugly
the preprocessor, 
\n macro body, but ugly
and the parser.
\n label values, also links to Sym in operands
\n and the object code generator? No. Use the links to Sym in passed operands.


\section{[[Opcode]]}
\label{sec:opcode}

All Asm5 instructions (machine, pseudo, and virtual) have an opcode
defined in [[include/arch/arm/5.out.h]] by the following type:
\n used to be just 5c/5.out.h

<<enum opcode(arm)>>=
// coupling: with 5c/enam.c
enum Opcode
{
    AXXX,

    ANOP, // VIRTUAL removed by linker
    // ---------------------------------------------------------
    // Arithmetic and logic opcodes
    // ---------------------------------------------------------
    <<[[Opcode]] cases, logic opcodes>>
    <<[[Opcode]] cases, add/sub opcodes>>
    <<[[Opcode]] cases, mul/div/mod opcodes>>
    <<[[Opcode]] cases, bitshift opcodes>>
    // ---------------------------------------------------------
    // Memory opcodes
    // ---------------------------------------------------------
    <<[[Opcode]] cases, mov opcodes>>
    <<[[Opcode]] cases, swap opcodes>>
    // ---------------------------------------------------------
    // Control flow opcodes
    // ---------------------------------------------------------
    <<[[Opcode]] cases, comparison opcodes>>
    <<[[Opcode]] cases, branching opcodes>>
    // ---------------------------------------------------------
    // System opcodes
    // ---------------------------------------------------------
    <<[[Opcode]] cases, interrupt opcodes>>
    // ---------------------------------------------------------
    // Float opcodes
    // ---------------------------------------------------------
    <<[[Opcode]] cases, float mov opcodes>>
    <<[[Opcode]] cases, float arithmetic opcodes>>
    // ---------------------------------------------------------
    // Pseudo opcodes
    // ---------------------------------------------------------
    <<[[Opcode]] cases, pseudo opcodes>>

    ALAST,
};
@
\t split pseudo in 2 categories? misc? ``special''?
%ocaml: use an ADT that combines opcodes and operands
%old: was called 'enum as'
%note: I reordered a lot the original opcodes. e.g. AND, ORR, EOR are together.
% Note that it can be dangerous
% for backward compatiblity to do so. Indeed 'ld' and 'as' need to agree
% with each other; one can't use a library compiled (or cross compiled) 
% using a 5l relying on a certain order, and link object files compiled 
% by a 5a relying on another order. So can have some subtle errors if
% want to play with what is cross-compiled! So make sure to recompile your
% libc if you modify 5l or 5a or 5.out.h
\n the enum must contain less than 256 elements, as we rely on 
\n  sending ANAME as a byte in zname(), and all opcode as a byte in zaddr()
\l analyze *.s and do stats? Use cg on plan9/ and see how much AXXX is used?

The opcodes follow closely the instruction set (ISA) of the ARM
(see the \book{Emulator}) and are all prefixed by an [[A]] 
(probably for [[A]]ssembly).
For instance, the [[ASUB]] opcode corresponds to the [[SUB]] 
machine instruction.
%
They have been divided in different categories: 
arithmetic and logic, 
memory,
control flow, 
system, 
and float.
Moreover, Asm5 introduces pseudo opcodes for the pseudo-instructions.
The different opcodes will be presented gradually in this
document.

The [[AXXX]] opcode represents the {\em invalid opcode}. It is put in
first position in the enumeration probably as a form of defensive programming.
%ocaml: ugly, should not need that if had strong enum case checker
%
[[ALAST]] is an {\em end marker}: a C idiom which makes it easy to loop
over all the opcodes or to declare an array of opcodes.
%
[[ANOP]] is a {virtual instruction} removed by [[5l]]. It is
occasionally used by the assembly generator in [[5c]] to
represent an instruction without any effect.
\l not clear why need that at all, but USED and profiler might use that?
\l also RET, MOV, SLL, BEQ, etc.
\l no PUSH/POP? stack is sugar over MOV with specific conventions.

\section{[[Register]]}
\label{sec:register}

ARM has 16 registers named [[R0]] to [[R15]].
They are represented simply by an integer in [[5a]]: 
0 is [[R0]], 1 is [[R1]], etc.
%ocaml: a bit ugly because then have the issue with R_NONE
The following type introduces some convenient names for some of the
{special registers} we have seen before:

<<enum regxxx(arm)>>=
enum Register {
    <<[[Register]] compiler conventions cases>>
    REGSB =		12, // static base

    REGSP =		13,
    REGLINK =	14,
    REGPC =		15,

    NREG = 16,
};
@
\n can not use register, it is a reserved keyword
\n note those are not the pseudo-registers but alias to the real one!
\n which is why there is no REGFP here.

Again, [[NREG]] is not a register but an end marker. 
One can then easily declare an array with all ARM registers
with [[int allregs[NREG];]].
%
Note than [[REGSB]] is not a special ARM register;
it is reserved though by the assembler and linker for a special use.
\t ref to section that explain more REGSB
\l Machine.nw does not have it.


There are few situations where something, e.g. an operand,
can be a register or {nothing}. We can not use 0 to represent nothing since it
is used already to encode [[R0]]. Instead, the following
constant represents nothing:

<<constant R_NONE(arm)>>=
#define R_NONE 16
@
%old: NREG used to represent also NONE in the outcode reg param; I prefer R_NONE
%ocaml: None, no need for special constant

The ARM has also 
float registers, 
coprocessor registers, and 
status registers, 
but they will be introduced later.
\n Fxxx, Cxxx, PCR (and FPCR)


\section{[[Operand]]}
\label{sec:operand}
\t rename Gen to Operand so better section name
\t Why Gen anyway? gen rule in grammar. General opd? generic? 
\n =~ Adr of Linker. 

%trans:
A register is only one kind of operand.
Constants (integers, floats, or strings) are another kind.
%
The following type is used to represent all kinds of operands: 

<<struct Gen(arm)>>=
struct	Gen
{
    // enum<operand_kind>
    short	type;

    // switch on Gen.type
    union {
        long	offset; // offset or lval or ...
        double	dval;
        char	sval[8];
    };
    // option<enum<registr>>, None = R_NONE
    short	reg;

    <<[[Gen]] other fields>>
};
@
\t can use lval too now! after all it's an union now. make it a union too?
%old: I introduced the union. Can have it? operand_kind will be good enough?
%ocaml: An ADT would be far better than this enum, D_NONE, and separate Sym 
%less: maybe by playing with Literate Programming I can reproduce a kind of ADT?
% e.g. by introducing LSREG, and then the part of the enum register related
% to LSREG?

The [[type]] field is used to encode the {\em operand kind}.
It is a [[short]] but really it can only take values of the
[[operand_kind]] enumeration (hence the {typing} comment)
we define below:

<<enum operand_kind(arm)>>=
enum Operand_kind {
    D_NONE,

    D_CONST,
    D_SCONST,
    D_FCONST,

    D_REG,
    <<[[Operand_kind]] cases>>
};
@
\l why Dxxx prefix? 
%dead: D_GOK, D_ADDR (valid for x86 but unused for arm)/* type/name */ for GOK
%note: I reordered again a lot things, which like for opcode has some impact
% on 5l. Now D_REG, D_CONST, D_SHIFT are closer (to mimic imsr rule).
%See Dconv in Linker for dumper (which can help to undertand things too)

The union in [[Gen]] represents the {\em value} of the operand, which has to 
be interpreted in different ways depending on the kind of the 
operand: 
for integer constants ([[D_CONST]]) the [[offset]] field is used,
for string constants ([[D_SCONST]]) the [[sval]] field,
and for float constants ([[D_FCONST]]) the [[fval]] field.
Remember that characters are converted in integers so
there is no need for a [[D_CHARCONST]] and [[cval]] field.
%
The [[long]] element of the union is called [[offset]],
and not [[lval]] (which would be more consistent with the
other union fields) because it is (ab)used to represent
different things, not just integer (or character) constants,
as we will see soon.
%ocaml: ugly, offset abused for many different operand kind, should be union
% see comment below

The [[D_NONE]] case is used in [[nullgen()]] to
represent the null operand. This is similar to [[R_NONE]].
\t for opcodes with less than 1 operands, should be overwritten though
%ocaml: again if ADT no need that

[[D_REG]] is used to represent register operands. In that
case it is the [[Gen.reg]] field which encodes
the actual register.
\n could use offset? no because can have offset(reg), and also used for REGREG

For indirect operands, e.g. [[(R1)]], 
or indirect with offset operands, e.g. [[4(R1)]]
the new operand kind [[D_OREG]] (for offset register) is used:

<<[[Operand_kind]] cases>>=
D_OREG,
@
\l oreg for offset register?

In those cases the register is encoded in the [[Gen.reg]] field,
and the optional offset in [[Gen.offset]] (hence the name).
%example:
Here is the C value of the operand mentioned above:
\begin{verbatim}
// operand value for: 4(R1)
{ offset = 4;          // 4
  reg    = 1;          // R1
  type = D_OREG;       // (...)
}
\end{verbatim}
\l offset is abused for many things, see the comment in .tex
% - offset (D_OREG)
% - constant (D_CONST)
% - instr binary format for bitshifted registers, with bit 0-3, 5-6, 7-11
%   used to encode different parts (D_SHIFT)
% - register (D_REGREG)
% - bitset of register for MOVM
% - ??
%ocaml: split in ADT
%less: rename offset? to generic_value? or generic_long? or lval?
% but it's true in many places it's used to encode an offset to
% a base (a reg, a name).
% e.g. for D_SHIFT the long is used really to encode the whole
% thing with some bits for the shift kind, some bits for the register, etc.
% see the many uses cases of offset in zaddr() switch about operand_kind ...
%mimic what is in union token too
\t just add cases in the union with the long too!


\section{Instructions}
\label{sec:outcode-signature}

There is no type to represent the full AST of an instruction.
Instead, multiple parameters of the [[outcode()]]
functions are used to pass the different components
of an instruction. Here is the signature of [[outcode()]]:
%ocaml: could define a record at least, or better an ADT and a pair for cond
\l =~ Prog of Linker (but without opcode)?

<<signature outcode(arm)>>=
void	outcode(int opcode, int cond, Gen* opd1, int reg, Gen* opd3);
@

Here is an example of use of [[outcode()]] to output
the serialized form of the instruction [[SUB $14, R2, R3]]:
%$
%example:
\begin{verbatim}
Gen operand1 = { .type = D_CONST; .offset = 14; ...};
Gen operand3 = { .type = D_REG;   .reg = 3; ... };
outcode(ASUB, Always, &operand1, 2, &operand3);
\end{verbatim}

The [[Always]] constant and the second parameter of [[outcode()]]
are used to represent the {\em conditional execution} of an instruction.
It is an ARM feature we will explain later in Section~\ref{sec:cond-exec}.
%
The fourth parameter is an integer and not a [[Gen*]] because
when ARM instructions have 3 operands, the middle one is always
a register, so an integer is enough.
Depending on the number of operands, here are the constraints on 
the value of those parameters:
\begin{itemize}
\item 0 operand: [[opd1]] and [[opd3]] are [[nullgen]], [[reg]] is [[R_NONE]]
\item 1 operand: [[opd3]] is [[nullgen]], [[reg]] is [[R_NONE]]
\item 2 operands: [[reg]] is [[R_NONE]]
\item 3 operands: no constraint, every parameter is used
\end{itemize}

\l speak now about the 2second register which is abused for: TEXT/DATA attr?

\section{Tokens and [[itab]]}
\label{sec:token}

The Yacc-based parser of [[5a]], called via [[yyparse()]],
is taking as input a set of {tokens}.
Those tokens are returned by the [[yylex()]] function, but
their type is defined by a set of {\em Yacc directives}
in the Yacc grammar [[5a/a.y]]\footnote{
Again, see~\cite{lexyacc} for more information on Yacc}.
Here are the directives to declare the names of those
tokens as well as the type of value they hold:

<<token declarations(arm)>>=
/* opcodes */
%token  <lval>  LARITH LCMP LBRANCH LBCOND LMOV LSWAP LRET
%token  <lval>  LSWI LSYSTEM 
%token  <lval>  LARITHFLOAT LCMPFLOAT LSQRTFLOAT  LMULL LMULA  LMOVM LMVN
%token  <lval>  LDEF LDATA LWORD LEND
%token  <lval>  LMISC
/* registers */
%token  <lval>  LPC LSP LFP LSB
%token  <lval>  LR LREG  LPSR
%token  <lval>  LF LFREG  LFCR 
%token  <lval>  LC LCREG
/* constants */
%token  <lval>  LCONST 
%token  <dval>  LFCONST
%token  <sval>  LSCONST
/* names */
%token  <sym>   LNAME LLAB
%token  <sym>   LVAR
/* bits */
%token  <lval>  LCOND
%token  <lval>  LS LAT
@
\l Lxxx for? lexeme?
%dead: LTYPEX LTYPEF LTYPEG LTYPED
%old: used to be LTYPE1 LTYPE2 LTYPEI etc, but better to give clearer names
%TODO: rename LTYPEXXX by T_END, T_TEXT, etc? L_ARITH? L_CMP L_MOV L_SWAP

Those directives are a bit complicated but things will be clearer
when we describe the Lexer in Chapter~\ref{chap:lexing}.
To understand those directives it can be useful to look at
the generated code and how tokens are internally represented.
A token is really a pair composed of:

\begin{itemize}
\item a {\em code}, which is an integer representing
the kind of the token. 
Based on the directives above, [[yacc]] will generate a [[y.tab.h]]
header file where all the token names are assigned a code.
See an excerpt of this file below.
For instance 
57346 represents all arithmetic mnemonics tokens (e.g. [[ADD]], [[SUB]], etc),
57353 represents the token for the [[RET]] mnemonic, and 
57381 represents all integer tokens.
%

\item a {\em value}, which is represented by a union we will describe below.
Depending on the kind of the token, the value can be 
an integer (e.g. for integer tokens), 
a float (e.g. for float tokens), 
or something else.
For instance for the arithmetic mnemonic tokens,
represented by the code 57346 and the token name [[LARITH]], 
the value will be the opcode corresponding to the actual mnemonic
(e.g. [[ASUB]] for [[SUB]]), which is an enumeration case.

\end{itemize}
%ocaml: but value is in yyval global, ugly, just because C func cant return pair

Here is an excerpt of the [[y.tab.h]] file generated by [[yacc]]:

<<5a/y.tab.h excerpt>>=
...
#define	LARITH	57346
...
#define	LSWI	57352
#define	LRET	57353
...
#define	LCONST	57381
#define	LFCONST	57382
...
@
%ocaml: ugly sugar, would be simpler have a simple ADT hiding all this shit

The values of those integers are high to not conflict with
the values of regular {unicode} characters. 
Indeed [[yylex()]]
can return single-character tokens (e.g. [[';']]) in which case there is no
need to give them a name.
\n in unix yacc I think it starts at 256 because only ASCII conflict
\l see Yacc. typedef Rune token_code; so plan9 lex is unicode aware? ulex?

Here is the union representing the different kinds of values
a token can hold:

<<union declaration(arm)>>=
%union {
 // long for LCONST
 // and enum<opcode>  for LARITH/...
 // and enum<registr> for LREG/...
 // and enum<cond>    for LCOND
 // and ...
 long   lval;    // for LCONST/LARITH/LREG/LCOND/...
 double dval;    // for LFCONST
 char   sval[8]; // for LSCONST

 <<union declaration other fields(arm)>>
}
@
%ocaml: no need, included in token directives
\l could use NSNAME here instead of char sval[8] ? and at a few other places?
\l note that 8, here is the restriction on 8bytes strings

Again this directive is a bit complicated but things will be clearer
later. The name of those fields, e.g. [[lval]], are actually
referenced in the \%[[token]] directives above.
\l and also in type directives
For instance \%[[token  <lval>  LCONST]] indicates that
the [[LCONST]] tokens will use the [[lval]] field of the union
to hold their values.
\t will see Sym later
\l this is used to typecheck things in Yacc. 

Another important data structure related to tokens
is the [[Itab]] structure and the global [[itab]]:

<<struct Itab(arm)>>=
struct Itab
{
    char	*name;

    //enum<token_code>
    ushort	type;
    //enum<opcode|registr|...> | int
    ushort	value;
};
@
\t why Itab? Instruction table? it's not just for instruction, ren ttab?
\t or mnemonics?
\l  fregisters|sysregisters|sym_kind(pseudo-register) |operand_kind||...
%ocaml: ADT again would be better than union and this

<<global itab(arm)>>=
// map<string, (token_code * token_value)>
struct Itab itab[] =
{
    "NOP",		LMISC, ANOP,
    <<[[itab]] elements>>
    0
};
@
\l itab -> itab[], special literate suffix for arrays/hash/map/...? also lists?

They map the predefined identifiers of Asm5, e.g. [[NOP]], [[PC]], etc,
to their corresponding token, which as we have seen before
is a pair of token code and token value.
%
Elements of the [[itab]] array will be revealed gradually
in this document but the first entry is shown above for [[NOP]].
\l was LTYPEI, now LMISC, but should be LNOP? and then a nop grammar rule?
\l in fact there is no rule with LMISC really to express NOP in a program!

\t in yylex when parse an identifier, looks in itab if equal string
\t in which case return the appropriate token

\l actually this array is used in xinit to populate hash table of symbols
\l so it's fast.

\section{[[Sym]]bols and [[hash]] table}
\label{sec:sym}
\label{sec:hash}

One of the main job of an assembler is to manage symbols
and to resolve symbolic addresses. 
The {\em symbol table} is thus a central data structure
used by [[5a]]. 
The structure below represents a symbol. It essentially
associates a {name} to a {value}:

<<struct Sym>>=
struct	Sym
{
    // Sym is (ab)used to represent many things in the assembler:
    //   actual symbols, labels, but also macros,
    //   tokens for opcodes and registers, etc

    // ---------------------------------------------------------
    // The "key"
    // ---------------------------------------------------------
    // ref_own<string>
    char	*name;

    // ---------------------------------------------------------
    // The generic "value"
    // ---------------------------------------------------------
    long	value; 

    <<[[Sym]] identifier fields>>
    <<[[Sym]] macro fields>>
    <<[[Sym]] token fields>>

    // ---------------------------------------------------------
    // Extra
    // ---------------------------------------------------------
    <<[[Sym]] extra fields>>
};
@
%archi: value is a vlong in va/
\n there is no symkind here, this is stored outside the Sym
%ocaml: no need special type, just use hashtbl for symbol table, just for lbls

For instance, the label [[later]] in the [[hello world]] program 
Section~\ref{sec:helloworld}, once resolved, could
be represented by the following [[Sym]]: 
%example:
[[{ .name = "later"; .value = 2; ... }]] as
the label is defined after the 2nd instruction in the program.
\l virtual PC!



The symbol table itself is represented by a global {hash table}
called [[hash]]. It makes sense to use a global because
the symbol table will be accessed by different components
of the assembler pipeline, e.g. the lexer and parser.
%ocaml: actually could pass table in lex to yacc.
One way to implement a hash table in C is to use a big array
of lists, also known as an array of buckets:

<<global hash>>=
// hash<string, ref_own<Sym>>, (next in bucket = Sym.link)
Sym*	hash[NHASH];
@
\n diff with h? this is assembler symbol table, not object file symbol table
<<constant NHASH>>=
#define	NHASH		503
@
\l choose as a prime, see below
%ocaml: just use stdlib hashtbl

One way to implement a list of something in C is to embed in
this something a [[link]] field pointing to the next
element in the list:

<<[[Sym]] extra fields>>=
// list<ref<Sym>> (next = Sym.link) bucket of hashtbl 'hash'
Sym*	link;
@
\n also of the object file symbol table h? no h is just an array actually.

The end of the list is represented by the null pointer:

<<constant S>>=
#define	S	((Sym*)nil)
@

%FIGURE? or standard C idiom?

The main interface to the symbol table are the
functions [[slookup()]] and [[lookup()]] which
both internally uses the global [[hash]].
\l hmm so could hash be a semi global and used only by lookup?
[[slookup()]] given a name returns the [[Sym]] in the
symbol table [[hash]] associated with this name, or
a new symbol if the name was not found:

<<function slookup>>=
Sym*
slookup(char *s)
{

    strcpy(symb, s);
    return lookup();
}
@
\l cleaner interface at least
%ocaml: use stdlib Hashtbl.find

It internally modifies the global [[symb]] 
(used also by [[yylex()]] as we will see later) 
before calling [[lookup()]].
%ocaml: globals are bad, slookup cleaner than lookup, should not need symb

<<global symb>>=
char	symb[NSYMB];
@
<<constant NSYMB>>=
#define	NSYMB		500
@
%old: was //#define	NSYMB		8192 on arm, not sure it matters

<<function lookup>>=
Sym*
lookup(void)
{
    Sym *sym;
    long h;
    char *p;
    int c;
    int len;

    <<[[lookup()]] compute hash value [[h]] of [[symb]]>>

    // hash_lookup(symb, hash)
    c = symb[0];
    for(sym = hash[h]; sym != S; sym = sym->link) {
        // fast path
        if(sym->name[0] != c)
            continue;
        // slow path
        if(memcmp(sym->name, symb, len) == 0)
            return sym;
    }
    <<[[lookup()]] if symbol name not found>>
}
@
%old: s/s/sym/, s/l/len, less confusing I think
\l standard way to use a hash table, so we don't elaborate
%ocaml: use stdlib Hashtbl.find

The code is using standard C idioms to iterate over a hash table.
Note that if the symbol is not found in the symbol table,
a fresh symbol is created and added in the hash table:

<<[[lookup()]] if symbol name not found>>=
sym = alloc(sizeof(Sym));
sym->name = alloc(len);
memmove(sym->name, symb, len);

// add_hash(sym, hash)
sym->link = hash[h];
hash[h] = sym;

syminit(sym);
return sym;
@

The hashing code iterates over the characters in [[symb]]
until the end-of-string character ([[0]]) and also compute the length
of the symbol in [[len]]:

<<[[lookup()]] compute hash value [[h]] of [[symb]]>>=
// h = hashcode(symb)
h = 0;
for(p=symb; c = *p; p++)
    h = h+h+h + c;
len = (p - symb) + 1;
if(h < 0)
    h = ~h;
h %= NHASH;
@


The symbol table [[hash]] and [[Sym]] are used (some could say abused) to 
represent and keep track of many different things in [[5a]]:

\begin{itemize}
\item {\em labels}, e.g. [[later:]], in which case [[Sym.value]]
contains eventually the value of the (virtual) program counter [[pc]]
at the label definition
%ocaml: only thing needed

\item {\em symbols}, for procedures
([[TEXT foo(SB)]]) and globals ([[GLOBL hello(SB)]]),
\l and also parameters and locals!
in which case [[Sym.value]] is not used since the address
of global symbols are resolved by [[5l]].
%
Another field of [[Sym]] is used though to store
meta-data about the symbol which will be stored in the 
symbol table of the object file
as we will see in Section~\ref{sec:symidx-sym-field}.
\n symidx, but actually not symkind which is in Gen, not Symbol.
\l also for SP and FP p _plus_ 0(FP)
\n Why need symbol in symbol table actually? to have a shared reference
\n which can store symidx which is used in outcode()


\item {\em macros}, e.g [[#define FOO]], since [[5a]] is
a macro-assembler which embeds its own macroprocessor, in which case
[[Sym.value]] is not used. Another field of [[Sym]] contains
the text of the macro as we will see in Section~\ref{sec:macro-sym-field}.
%ocaml: external cpp

\item {\em symbolic constants}, e.g. [[RTMP = 10]], 
in which case [[Sym.value]] contain the constant value
%ocaml: useless feature

\item {\em predefined identifiers}, 
\l use mnemonics?
for opcodes ([[AMOV]]) and registers ([[R1]]), in which case
[[Sym.value]] contain the appropriate enumeration value.
\l ugly abuse
%ocaml: do in lexer instead, not abuse symbol table

\end{itemize}
\n because of hash that means all MOVW in a file are shared when lexing

Predefined identifiers are stored in the symbol table for
efficiency reason.
%ocaml: could use a different hash table
Indeed, the symbol table is first a hash table, and so
it can be (ab)used by the lexer to quickly check 
if an identifier corresponds to the mnemomic of an opcode or register.
One of the initialisation function, [[cinit()]],
resets and then populates [[hash]] with all the 
array elements of [[itab]] we have seen in the previous section:

<<[[cinit()]] hash initialisation from itab>>=
for(i=0; i<NHASH; i++)
    hash[i] = S;
for(i=0; itab[i].name; i++) {
    s = slookup(itab[i].name);
    s->value = itab[i].value;
    s->type = itab[i].type;
}
@

In the case of predefined identifiers, another field of [[Sym]]
is used to also store the token code of the identifier
(in addition to the token value, that is the enumeration value of the opcode or register, stored in [[Sym.value]]):

<<[[Sym]] token fields>>=
//enum<token_code> (e.g. LLAB, LNAME, LVAR, LARITH, etc)
ushort	type;
@
\l see also itab[i].type and itab[i].value
\l used by?



[[Sym]] is part of the token union we have seen in the previous
sections. Indeed the token value for 
symbols ([[LNAME]]), 
labels ([[LLAB]]), 
and symbolic constants ([[LVAR]])
is a reference to its [[Sym]] in the symbol table:

<<union declaration other fields(arm)>>=
Sym    *sym;    // for LNAME/LLAB/LVAR
@
\t mutual ref with sym here where sym has itself a type that is the token_kind



The function below is called by [[lookup()]] when
a new symbol is created to reset some of its fields:

<<function syminit>>=
void
syminit(Sym *sym)
{
    sym->type = LNAME;
    sym->value = 0;
}
@
\t not set symidx to 0??


%dead:
%<<[[Sym]] other fields>>=
%Ref*	ref; // unused for 5a, matters?
%@
%<<struct Ref>>=
%// only for 8a actually, and actually not used so I removed it
%struct	Ref
%{
%    int	class;
%};
%@



\section{[[Sym_kind]]}

%trans:
Now that we have seen the [[Sym]] structure,
%
we can present the [[sym]] field of the [[Gen]] structure:

<<[[Gen]] other fields>>=
// option<ref<Sym>>, ref owned by hash
Sym*	sym;
@
%less: maybe should rename this field 'name'? and then use name_kind?
\t actually also one of the union token case
%ocaml: why need link? name not enough? need value just for labels

This field is used for operands involving symbols or labels.
For instance in [[hello+4(SB)]], [[Gen.sym]] will point
to the symbol [[hello]] in the global [[hash]] table.
\t but what for? just for the name? symkind is part of Gen too
%
An additional [[Gen]] field is used to represent
the {\em kind} of the symbol:

<<[[Gen]] other fields>>=
// option<enum<sym_kind>>, None = N_NONE
short	symkind;
@
%old: was called name, but confusing I think, name as a field was used in
% many structures and it's actually not a name
%less: rename to name_kind? rename also the sym field above?

<<enum sym_kind(arm)>>=
enum sym_kind {
    N_NONE,

    D_EXTERN, // text/data/bss values (from SB)
    D_LOCAL,  // stack values (from SP)
    D_PARAM,  // parameter (from FP)
    <<sym_kind cases>>
};
@
%old: was D_AUTO instead of D_LOCAL but ugly C
% use A_EXTERN? or N_EXTERN? is D_XXX because was in operand_kind before
%/* name */ for D_EXTERN
%note: this used to be with operand_kind, but they are really disjoint
% and used only for the ANAME pseudo opcode. In 5l/ there is
% actually a separate Dconv and Nconv (but in 8l/ they are together).

So, the C value of the operand in the example above is:
%example:
\begin{verbatim}
// operand value for: hello+4(SB)
{ sym = &<hello Sym>;  // hello
  offset = 4;          // +4
  sym_kind = D_EXTERN; // SB
  type = D_OREG;       // (...)
}
\end{verbatim}
\l could use reg? but then no need with (R12) and (SB)
\n the symkind is a property of the Gen and not Sym!
\l because people disambiguate at each use, foo(SB), foo _plus_ 0(FP), etc.

Note that there is no special operand kind such as [[D_ADDRESS]]
to encode operands such as \$[[hello(SB)]]. Instead
the [[D_CONST]] type is (ab)used:
%example:
\begin{verbatim}
// operand value for: $hello(SB)
{ sym = &<hello Sym>;  // hello
  offset = 0;
  sym_kind = D_EXTERN; // SB
  type = D_CONST;      // $
}
\end{verbatim}

There is no ambiguity with the representation of simple constants
since the [[sym]] field in those cases would be NULL.
\l moreover address is a kind of constant? actually make sense to use dollar
\l but what is the code generated?

% Assembler is outputing a (spreaded) symbol table in the object file.
% Important job of assembler is to prepare for linker, to enable
% the linker to link modules together and so to resolve references 
% to external symbols.

%note that can have symkind set but not necessarality a sym,
% but it's in the degenerated case of con ( pointer ) which
% I think should not happen (or should happen when don't care
% about naming the parameter so just do  4(FP) in which
% case sym can be seen as an anonymous symbol name.




%section{[[pc]]} ?










\chapter{Main Functions}
\label{chap:main}

%toc:
We now switch to a top-down approach where we describe
the main functions of [[5a]] starting from [[main()]]
down to [[assemble()]].

\section{[[main()]]}

%trans:
Before showing the code of [[main()]] we first introduce
a few globals set by [[main()]].
%
A common pair of globals in \plan code
are [[thechar]] and [[thestring]] which both represent
the current architecture.
%dup: from intro/5a
As said in the introduction, \plan by convention 
represents architectures with a single character: 
[['0']] is MIPS, 
[['5']] is ARM, 
[['8']] is x86, etc.
%
This character is used by [[5a]] for instance
for the filename extension of object files (e.g. [[hello.5]]): 

<<global thechar>>=
int	thechar;
@
\l int? no char? then use Rune!
\n cant put = '5' here because this chunk is factorized for arm and x86

[[thestring]] contains the longer, more readable, version
of the architecture, e.g. [["arm"]] for [[5]].

<<global thestring>>=
char*	thestring;
@

This is used by [[5a]] for instance to find architecture
specific system header files, e.g. in [[/arm/include/...]].
Indeed, [[5a]] is a macro-assembler in which [[#include]] have
a default {\em search path} (represented by
the global [[include]] in [[main()]] below).

We can now present the code of [[main()]], the entry point of [[5a]].
%
The most important thing is the call to [[assemble()]] at the
end, with the filename of the assembly file to process 
passed through a command line argument:

<<function main(arm)>>=
void
main(int argc, char *argv[])
{
    <<[[main()]] locals>>
    <<[[main()]] debug initialization>>

    thechar = '5';
    thestring = "arm";

    cinit();
    include[ninclude++] = ".";

    ARGBEGIN {
    <<[[main()]] command line processing>>
    } ARGEND

    if(*argv == '\0') {
        print("usage: %ca [-options] file.s\n", thechar);
        errorexit();
    }

    <<[[main()]] multiple files handling>>

    if(assemble(argv[0]))
        errorexit();
    exits(0);
}
@
%ocaml: no need cinit, and include stuff can be done by outside cpp

Another important global, set possibly by [[main()]],
is [[outfile]] which stores the name of the output object file,
and which can be modified by the [[-o]] option:

<<global outfile>>=
char*	outfile = nil;
@
\l hmm could be 5.out instead no? hmm no, it will be set
\l to {basename(input_file)}.{thechar} in assemble()

<<[[main()]] command line processing>>=
case 'o':
    outfile = ARGF();
    break;
@





\section{[[cinit()]]}
\t rename to just init? why the C?

[[cinit()]] contains a few globals initialisations:
%ocaml: do not need that as initialisations are more flexible in ocaml

<<function cinit(arm)>>=
/// main -> <>
void
cinit(void)
{
    Sym *s;
    int i;

    <<[[cinit()]] nullgen initialisation>>
    <<[[cinit()]] hash initialisation from itab>>
    <<[[cinit()]] pathname initialisation from cwd>>
}
@
%old: used to do more initialisation here, but instead move the init at def loc
\n very similar to the x86 version, except the few change for nullgen fields

\label{sec:nullgen}
[[nullgen]] is a global we will often see later used to initialize
fresh operands in code such as [[newopd = nullgen;]]:

<<global nullgen>>=
Gen	nullgen;
@
%ocaml: no need that, just set all fields each time with record

<<[[cinit()]] nullgen initialisation>>=
nullgen.type    = D_NONE; // no type set yet
nullgen.reg     = R_NONE;
nullgen.symkind = N_NONE;
nullgen.sym = S;
nullgen.offset = 0; // part of a union
@

\ifallcode
<<[[cinit()]] nullgen initialisation>>=
if(FPCHIP)
    nullgen.dval = 0;
for(i=0; i<sizeof(nullgen.sval); i++)
    nullgen.sval[i] = 0;
@
\fi
%todo: now that I use an union, this code is valid about dval and sval?
% can't use N_NONE because this function is in aa/ and N_NONE is
% in 5a/a.h
%ocaml: merge with def, use nice record syntax


% cwd, for #include "" (cwd can change as one include other files)
%  =~ dirname(current_file)

\label{sec:pathname}
[[pathname]] represents the {\em current working directory} 
(CWD). This is used also for the [[#include]] search path.

<<global pathname>>=
char*	pathname;
@
%less: rename? dirname_of_input_file? (actually it's really
% dirname_of_current_input_file as 5a can process multiple files,
% but it would complicate things; multifile is an advanced topic)

<<[[cinit()]] pathname initialisation from cwd>>=
pathname = allocn(pathname, 0, 100);
if(getwd(pathname, 99) == 0) {
    pathname = allocn(pathname, 100, 900);
    if(getwd(pathname, 999) == 0)
        strcpy(pathname, "/???");
}
@
%???
\t mv later? with #include?

\section{[[assemble()]]}

Because one can reference labels defined later in an assembly file,
a common approach to assembling is to use a two-pass algorithm.
The first pass focuses on the {\em definitions} of labels;
by the end of the file the values of all labels are known.
The second pass focuses on the {\em uses} of labels and leverages
the information computed in the first pass.
%
This is the strategy used by [[5a]]
and so an important global is [[pass]] which stores
in which pass we currently are (1 or 2):
\l alternatives to two-pass algo: lazy, patch back

<<global pass>>=
// 1|2
int	pass;
@
%ocaml: need this to be a global? could instead parse asm, return AST
% and then algo in two passes on the AST, a visitor and then generator.

This global is set by [[assemble()]] below and is used
in a few places in the grammar as well as in [[outcode()]]:

<<function assemble>>=
error1
assemble(char *infile)
{
    fdt of; // outfile
    char *p;
    <<[[assemble()]] locals>>

    <<[[assemble()]] set p to basename(infile) and adjust include>>
    if(outfile == nil) {
        <<[[assemble()]] set outfile to {basename(infile)}.{thechar}>>
    }
    <<[[assemble()]] setinclude("/{thestring}/include") or INCLUDE>>

    of = mycreat(outfile, 0664);
    if(of < 0) {
        yyerror("%ca: cannot create %s", thechar, outfile);
        errorexit();
    }
    Binit(&obuf, of, OWRITE);

    pass = 1;

    pinit(infile);
    <<[[assemble()]] init Dlist after pinit>>
    yyparse(); // calls outcode() but does nothing when pass == 1

    if(nerrors) {
        cclean();
        return nerrors;
    }

    pass = 2;
    outhist(); // file history information at the beginning of the object

    pinit(infile);
    <<[[assemble()]] init Dlist after pinit>>
    yyparse(); // calls outcode() that now does things

    cclean();
    return nerrors;
}
@
%pad: I renamed parameter to infile, to better contrast with outfile
%ocaml: use exception, no need fdt and buf intermediate, use Marshall
% no need 2 parse, just return AST and resolve() and save_obj()

Essentially [[assemble()]] calls [[yyparse()]]
two times, with the appropriate value set in [[pass]], after
having initialized some globals related to the input file via [[pinit()]].
This means the input assembly file is parsed two times, but
the actions in the grammar do different things the second time.
%ocaml: ugly globals, dont see clearly, also ugly parse two times
%
[[assemble()]] returns the number of errors it found,
or 0 if everything went fine. It is using the global [[nerrors]].
See Appendix~\ref{chap:error} for the error managment globals and functions.

Another global initialized by [[assemble()]] is [[obuf]],
the {output buffer} which will contain the content
of the object file [[5a]] generates:

% outfile(filename) -> of(fd) -> obuf(biobuf)
<<global obuf>>=
Biobuf	obuf;
@
%ocaml: why another global, ugly, because yyparse inflexible?

This will be used notably by [[outcode()]].
The main output data flow in [[assemble()]] is to go from
the name of the output file ([[outfile]]), 
to an output file descriptor ([[of]]),
to finally an output buffer ([[obuf]]).
%
Note that many globals are used for output data (e.g. [[obuf]])
as well as input data (see [[pinit()]]),
which makes the code harder to read. 
This is probably because the interface
for [[yyparse]], the function generated by [[yacc]],
is a function which does not take any argument nor return anything, so we
are forced to use globals.

The function below is called just before returning
from [[assemble()]] and is used to add the last
instruction in the object file: [[AEND]].
It is a special marker used by [[5l]].
\n need AEND? yes, the linker wants an AEND, and I think
\n when use a library, can have multiple objects concatenated
\n in which case AEND is a marker for the end of an obJect.
\n and to facilitate the job of ldobj, easy to use opcode too.
\n (but in a clean world this could be done by linker)

\label{sec:cclean}
<<function cclean(arm)>>=
/// main -> assemble -> <>
void
cclean(void)
{

    outcode(AEND, Always, &nullgen, R_NONE, &nullgen);
    Bflush(&obuf);
}
@
%ocaml: not sure need that, should be done by ar or 5l



\ifallcode
<<[[assemble()]] locals>>=
int i;
@
\fi

The remaining code in [[assemble()]] is mostly
filename manipulations and modifying globals used
for [[#include]] processing.
Those filename manipulatons start with the temporary [[ofile]]
used to compute [[outfile]] later:
<<[[assemble()]] locals>>=
char ofile[100];
@

<<[[assemble()]] set p to basename(infile) and adjust include>>=
// p = basename(infile)
// include[0] = dirname(infile); 
strcpy(ofile, infile);
p = utfrrune(ofile, '/');
if(p) {
    include[0] = ofile;
    *p++ = '\0';
} else
    p = ofile;
@
%ocaml: just use Filename stdlib

Note that [[utfrrune()]] above returns the {\em last} occurence of a Rune.
A {\em rune} is a unicode character in \plan terminology.

<<[[assemble()]] set outfile to {basename(infile)}.{thechar}>>=
// outfile =  p =~ s/.s/.5/;
outfile = p;
if(outfile){
    p = utfrrune(outfile, '.');
    if(p)
        if(p[1] == 's' && p[2] == '\0')
            p[0] = '\0';
    p = utfrune(outfile, '\0');
    p[0] = '.';
    p[1] = thechar;
    p[2] = '\0';
} else
    outfile = "/dev/null";
@
%ocaml: use Common.matched1

<<[[assemble()]] locals>>=
char incfile[20];
@

<<[[assemble()]] setinclude("/{thestring}/include") or INCLUDE>>=
p = getenv("INCLUDE");
if(p) {
    setinclude(p);
} else {
    if(systemtype(Plan9)) {
        sprint(incfile,"/%s/include", thestring);
        setinclude(strdup(incfile));
    }
}
@
\l see Section X
%ocaml: external cpp





\chapter{Input}
\label{chap:input}

%trans:
Now that we have seen [[assemble()]], we can start
explaining the different components in the assembling
pipeline, starting in this chapter with the input functions.

%toc:
We have mentioned before [[pinit()]] which initializes
globals related to input. We will also describe below
[[GETC()]], which uses those globals,
and is called by the lexer [[yylex()]] (called itself
by the parser [[yyparse()]]) to get the next character from
the input assembly file (or one of its included file).

\section{[[pinit()]]}
\t rename pass_init? parse_init?

[[pinit()]] initializes a few globals related to input.
It is called at the beginning of each pass in [[assemble()]]:

<<function pinit>>=
/// main -> assemble -> { <> ; yyparse } x 2
void
pinit(char *f)
{
    <<[[pinit()]] locals>>

    lineno = 1;

    newio(); // set ionext
    newfile(f, FD_NONE); // use ionext, set iostack, set fi

    <<[[pinit()]] initialisations>>
}
@
%ocaml: external cpp so no need newio, etc, and one pass lexing so no need line
% initialisation here

\ifallcode
<<[[pinit()]] locals>>=
int i;
Sym *s;
@
\fi

\label{sec:lineno}
The [[lineno]] global tracks the current line number and will be
incremented by the lexer for each newlines. It is used
in the object code generator to remember where each
instruction comes from. This will be useful for debugging.

<<global lineno>>=
long	lineno;
@
\t Is it after #include expansion? global line number, subtle
\l rename glineno?
%ocaml: could be embedded in the token, so no need global, no need getc
% vs GETC, unget, etc. Less mess.

%toc:
The calls to [[newio()]] and [[newfile()]] will be explained below.

\section{Files managment, [[iostack]]}

[[5a]] is a macro-assembler which embeds his own [[cpp]]-like preprocessor
\footnote{
Note that [[5a]] could also instead rely on an external 
preprocessor, which would factorize code with [[5c]],
but that would be slower because of the need to fork
another process in the assembling pipeline.
\n meh, better to separate concern and have cpp in a different program?
\l actually they factorized a bit originally bug was ugly lexbody, macbody, etc
}.
%
Because [[5a]] supports [[#include]], the input assembly file can include
another file, which itself can include another file and so on.
So, we may have to open many files,
and when a file has been fully processed, we need to go back
to the file which was including it, the {\em includer}.
This suggests a {\em stack} data structure: a stack of opened input file.
The following structure represents an element of this stack,
essentially an opened file with a file descriptor in [[Io.f]]:

<<struct Io>>=
struct	Io
{
    // option<fdt>, None = FD_NONE
    fdt	f;
    <<[[Io]] buffer fields>>
    // Extra
    <<[[Io]] extra fields>>
};
@
\n hmm, could they use shorter fieldnames ...

The global [[iostack]] represents the {top} of the stack, that
is the current file being scanned:

<<global iostack>>=
// list<ref_own<Io> (next = Io.link)
Io*	iostack = I;
@
% used to be set in cinit()

One can implement a stack in C using a list:

<<[[Io]] extra fields>>=
// list<ref_own<Io>>, head = iostack (or iofree)
Io*	link;
@
<<constant I>>=
#define	I	((Io*)nil)
@


The main job of [[newio()]] is to make point
the global [[ionext]] to a newly allocated [[Io]]
which can be used later by [[newfile()]]:
%ocaml: so many globals

<<global ionext>>=
// option<ref<IO>>
Io*	ionext;
@

<<function newio>>=
/// main -> assemble -> pinit -> <>; newfile
void
newio(void)
{
    Io *i;

    <<[[newio()]] allocate a new Io in [[i]] or find a free one>>
    ionext = i;
    i->f = FD_NONE;
    i->c = 0;
}
@
%ocaml: why not return it? because dont want caller to free it?

The [[Io]] allocator could be simply a call to [[malloc()]].
The matching call to [[free()]] then should be in the code which
closes the opened file when the content if fully read.
Instead, [[5a]] uses the common C technique of {\em free list}
to manage [[Io]]s and so can ``recycle'' an [[Io]] 
for another opened file:

<<global iofree>>=
// list<IO>, next = IO.link
Io*	iofree = I;
@

<<[[newio()]] allocate a new Io in [[i]] or find a free one>>=
static int pushdepth = 0;

i = iofree;
if(i == I) {
    pushdepth++;
    if(pushdepth > 1000) {
        yyerror("macro/io expansion too deep");
        errorexit();
    }
    //todo: check error code?
    i = alloc(sizeof(Io));
} else
    iofree = i->link;
@


[[newfile()]] assumes [[ionext]] has been set
correctly in [[newio()]] and open finally the input assembly file:

<<function newfile>>=
/// main -> assemble -> pinit -> { newio; <> }
/// yylex -> macinc -> <>
void
newfile(char *s, fdt f)
{
    Io *i;

    // add_list(ionext, iostack)
    i = ionext;
    i->link = iostack;
    iostack = i;

    i->f = f;
    if(i->f == FD_NONE)
        i->f = open(s, 0);
    if(i->f < 0) {
        yyerror("%ca: %r: %s", thechar, s);
        errorexit();
    }
    fi.c = 0;
    <<[[newfile()]] call linehist>>
}
@

\section{Buffer managment, [[fi]]}

Once the input file is opened,
the lexer needs to look at its content one character at a time.
Instead of using many system calls such as [[read(..., 1)]] to read
one character at a time, which would be slow,
[[5a]] instead calls
[[read()]] once in a while to fill a large
{\em input buffer}, and then use auxillary functions
to move pointers in this buffer. This buffer is simply
an array of character in [[Io]]:
%ocaml: buffered IO should be done in library

<<[[Io]] buffer fields>>=
char	b[BUFSIZ];
@
<<constant BUFSIZ>>=
#define	BUFSIZ		8192
@
%ocaml: just use ocamllex which internally does that

A few functions below are using the global [[fi]] which contains
pointers in the input buffer of the currently processed input file:

<<global fi>>=
struct Fi fi;
@

<<struct Fi>>=
struct Fi
{
    // ref<char>, pointer in Io.b
    char*	p;
    // remaining characters in Io.b to read
    int	c;
};
@
\l File input
\l could use directly iostack->p and iostack->c, no need for this cache

Once we processed an included file we need to
go back to the includer file (which can be found easily thanks
to [[iostack->link]]). But we also need to remember
where we were in the includer file, hence those extra fields:

<<[[Io]] buffer fields>>=
// like Fi, saved pointers in IO.b
char*	p;
short	c;
@
\l unicode input but here char pointer!

\section{[[GETC()]]}

We can finally see the code of [[GETC()]] which
is a macro called many times in [[yylex()]] to
get the next character from the input file, and which
uses the global [[fi]] we have seen above:

<<function GETC>>=
/// main -> assemble -> yyparse -> yylex -> <>
#define	GETC()		((--fi.c < 0) ? filbuf() : *fi.p++ & 0xff)
@
\l a bit tricky; also unicode but here 0xff, it's a character
%ocaml: use ocamllex which does that internally

<<function filbuf>>=
int
filbuf(void)
{
    Io *i;

loop:
    i = iostack;
    if(i == I)
        return EOF;
    if(i->f < 0) // When this happens?
        goto pop; 

    // system call! fill really the buffer
    fi.c = read(i->f, i->b, BUFSIZ) - 1;
    if(fi.c < 0) {
        close(i->f);
        <<[[filbuf()]] when close file, call linehist>>
        goto pop;
    }
    fi.p = i->b + 1;
    return i->b[0];

<<[[filbuf()]] pop>>
}
@
\l return int or char?

The [[-1]] above is because [[Fi.c]] represents the remaining
characters to read, so if [[read()]] returns only 1,
meaning one character only was read, then this character
will be returned and so there is nothing else to read after,
in which case [[Fi.c]] should be 0 (hence the [[-1]]).
%
Figure~\ref{fig:input-buffer} represents the evolution of the state
of [[fi]] while the input buffer gets filled.

\begin{figure}[!]\centering
\begin{verbatim}
0                                                      8192 
+-------------------------------------------------------+
|                                                       |
+-------------------------------------------------------+
^
|                             
fi.p   (fi.c = 0)

(a) Empty buffer in iostack->b

0                                                      8192 
+-------------------------------------------------------+
|l|a|t|e|r|:|              ...                      |M|O|
+-------------------------------------------------------+
  ^<---------------------------------------------------->
  |                       fi.c = 8191
  fi.p 

(b) After first call to GETC(): returned 'l', 
    increment fi.p, decrement fi.c

\end{verbatim}
\caption{Evolution of the input buffer}\label{fig:input-buffer}
\end{figure}


When there is nothing more to read in the file,
we need to [[pop()]] the file from [[iostack]] and
update [[fi]] to point to the input buffer of the includer file:

<<[[filbuf()]] pop>>=
pop:
    // pop(iostack)
    iostack = i->link;
    // push(i, iofree)
    i->link = iofree;
    iofree = i;

    // i = top(iostack), the fresh top of the stack input file
    i = iostack;
    if(i == I)
        return EOF;
    // restore file pointers
    fi.p = i->p;
    fi.c = i->c;
    if(--fi.c < 0)
        goto loop;
    return *fi.p++;
@

\plan uses unicodes so characters are actually integers.
A few constants are used to represent special characters;
they are negatives to not conflict with regular unicode characters:
\t MEH because yylex is not unicode aware I think

<<constant EOF>>=
#define	EOF		(-1)
@
\t MEH

%Note that even if [[5a]] accepts unicode characters, [[GETC()]]
%returns only basic characters. The type of [[Fi.p]] and [[Io.b]]
%are [[char]] pointers.
\l and so? there are functions later that reconstruct unicode from
\l set of chars? what if incomplete unicode char in buffer boundary?







\chapter{Lexing}
\label{chap:lexing}

%trans:
The next component in the assembly pipeline is the lexer
function [[yylex()]] called by the parser [[yyparse()]].
%
It relies on [[GETC()]] which we have seen
before to get the next character in the currently processed input file.
\l (that is iostack->f )

\section{[[yylex()]]}

Even though [[5a]] is not using Lex, Yacc requires
\t why not use Lex? (same question asked in soft archi section)
% maybe to avoid bootstrapping issues?
% hmm but they use yacc so ... (and lex uses yacc)
% or maybe because if want to have builtin-cpp, easier to do without Lex?
the lexer to be represented by a function called [[yylex()]]. 
%
This function does not take any
argument (hence the use of many globals), and must return
the {\em code} of a token, or [[-1]] (EOF) when there is no
more token to read, or a single character if the
token is simply a single character:
%ocaml: EOF needs special care also in ocamlyacc and ocamllex

<<signature yylex>>=
// unit -> (enum<token_code> | -1 (EOF) | Rune)
long	yylex(void);
@
%ocaml: ugly abuse long

[[yylex()]] can also modify the global [[yylval]] 
to store the {\em value} of the token
which is a union type (see Section~\ref{sec:token}).
This value can then be retrieved via the \$$n$ notation
in the Yacc actions as we will see in Chapter~\ref{chap:parsing}.

[[yylex()]] is essentially an {\em automata} 
reading characters (with [[GETC()]]) 
in a loop (with the label [[l0:]] and [[goto]] below),
using a big [[switch]] on the current character read ([[c]])
to transition states (using more labels and [[goto]]s as we will see), 
until a full token is formed:
%ocaml: should use lex. Simpler. 

<<function yylex>>=
/// main -> assemble -> yyparse -> <>
long
yylex(void)
{
    int c; // Rune?
    <<[[yylex()]] locals>>

    <<[[yylex()]] peekc handling, starting part>>
l0:
    c = GETC();
l1:
    if(c == EOF) {
        peekc = EOF; // needed?
        return -1;
    }

    if(isspace(c)) {
        <<[[yylex()]] if c is newline>>
        // ignore spaces
        goto l0;
    }

    <<[[yylex()]] before switch, if isxxx>>
    switch(c) {
    <<[[yylex()]] switch c cases>>
    default:
        return c;
    }
    <<[[yylex()]] peekc handling, ending part>>
    return c;
}
@
\t now return a long, fillbuf was returning an int. hmmm
%ocaml: ugly to not take any input and use globals. Should take a lexbuf!
% also with pattern character range no need ugly isalpha and isdigit

%toc:
In the next sections we will mostly show the code of the
different cases in the [[switch]].

\section{Peek, seek, and look ahead}

When trying to identify a token, e.g. an identifier, it is
frequent to read characters until the current character
does not satisfy a certain criteria, e.g. being a letter.
In that case one has read too far in the input file
and should go back one character using [[seek()]].
%
Another technique is to store instead in a global
this extra character:

<<global peekc>>=
// option<Rune>, None = IGN
int	peekc = IGN;
@
\t use Rune?
\l =~ yyback(1) trick, used by yylex() and getc(), and?? cg?
%pad: used to be set in cinit()

<<constant IGN>>=
#define	IGN		(-2)
@
\l also negative, -2 because EOF is -1 already used

<<[[pinit()]] initialisations>>=
peekc = IGN;
@
%ocaml: no need that with ocamllex behavior to look for longer and
% internally manage peekc/yyback


Then we need to make sure the function reading characters 
from the input file ([[yylex()]]) first looks in this global
before trying to read any new character:

<<[[yylex()]] peekc handling, starting part>>=
c = peekc;
if(c != IGN) {
    peekc = IGN; // consumed
    goto l1; // skip the GETC(), we already have a character in c
}
@

In the sections below, the local [[c1]] can be used
to store the {\em look ahead} character when one needs to read
an extra character in addition to [[c]] to decide
what to do:

<<[[yylex()]] locals>>=
int c1;
@
\n need that? why not modify peekc directly? because not automatic!

This extra character is considered by default the
peek character for the next call to [[yylex()]],
unless [[yylex()]] returns before:

<<[[yylex()]] peekc handling, ending part>>=
peekc = c1;
@



\section{Newlines (and semicolons)}
\label{sec:semicolon}

%dup: from overview/input-lang
As said in Section~\ref{sec:asm5-lexical},
newlines in Asm5 are transformed in semicolons which
are recognized as instruction terminators in the Asm5 grammar:
\n and not separators

<<[[yylex()]] if c is newline>>=
if(c == '\n') {
    lineno++;
    return ';'; // newline transformed in fake ';'
}
@
\l note also lineno plus plus

Note that because the token in a single character, it can
be returned directly. There is no need to invent
a [[LSEMICOLON]] token code.

%old:
%<<[[yylex()]] switch c cases>>=
%case '\n':
%    lineno++;
%    return ';';
%@
% can be reached? with isspace(c) above, this code seems unreachable


\section{Comments}

Asm5 comments use the same syntax than C comments,
e.g. [[/* foo */]] or [[// foo]], and are skipped
by the lexer hence the [[goto]] back to [[l0]] (or [[l1]])
below:

<<[[yylex()]] switch c cases>>=
case '/':
    c1 = GETC();
    if(c1 == '/') {
        // '/''/' read, skip everything until next '\n'
        for(;;) {
            c = GETC();
            if(c == '\n')
                goto l1;
            if(c == EOF) {
                yyerror("eof in comment");
                errorexit();
            }
        }
    }
    if(c1 == '*') {
        // '/''*' read, skip everything until next '*''/'
        for(;;) {
            c = GETC();
            while(c == '*') {
                c = GETC();
                if(c == '/')
                    goto l0;
            }
            if(c == EOF) {
                yyerror("eof in comment");
                errorexit();
            }
            if(c == '\n')
                lineno++;
        }
    }
    break;
@
\l put getcom() here too?
\l important not forget lineno! also while not if subtle :)

\section{Mnemonics, symbols and labels}

%trans:
Until now we were mostly skipping characters (spaces, comments),
or returning a single character (semicolon). 
%
For identifiers we need to accumulate a set of characters and look if
they correspond to mnemonics, symbols, or labels.
%
The local [[cp]] below will point in the [[symb]] global buffer
we have seen in Section~\ref{sec:sym} which is then internally
used by [[lookup()]] to look for predefined identifiers
or labels or symbols in the global [[hash]] symbol table:
\t itab!

<<[[yylex()]] locals>>=
// ref<char>, pointer in symb
char *cp;
// ref<Symbol>, owned by hash
Sym *s;
@

<<[[yylex()]] before switch, if isxxx>>=
if(isalpha(c))
    goto talph;
@
%ocaml: powerful case, character range ftw

<<[[yylex()]] switch c cases>>=
case '_':
case '@':
// case 'a'..'z' 'A'..'Z': (isalpha())
talph:
    cp = symb;

aloop:
    *cp++ = c;
    c = GETC();
    if(isalpha(c) || isdigit(c) || c == '_' || c == '$')
        goto aloop;
    // went too far
    peekc = c;

    *cp = '\0';
    s = lookup(); // uses symb global and so cp
    <<[[yylex()]] if macro symbol>>
    if(s->type == 0) // when can this happen?
        s->type = LNAME;
    <<[[yylex()]] in identifier case, set yylval>>
    return s->type;
@
%$
%ocaml: use of peekc is yyback(1), but no need in ocamllex
\l @? maybe remove it so it would also remove the need for LAT token_kind
\t possible to have s->type == 0? if new sym theni it is set to LNAME in syminit
\t actually does not handle unicode identifiers? how works assembler in go?

Remember that [[Sym.type]] contains the token code of
the ``symbol''.
The union [[yylval]] is set according to the kind of the symbol:
the actual [[Sym]] for labels and symbols, the enumeration value
for predefined identifiers (mnemonics):

<<[[yylex()]] in identifier case, set yylval>>=
if(s->type == LNAME || s->type == LLAB || s->type == LVAR) {
    yylval.sym = s;
} else {
    yylval.lval = s->value;
}
@
%ocaml: ugly to have lexer/parser side effect, solve label in resolve()
% after lexing/parsing

\t note that LLAB set in grammar! so in pass2 or if defined before
\t then return different token_kind! not context free. but need that??

\section{Numbers}

%trans:
Numbers are a bit more complicated to parse than what
we have seen until now  because 
%
Asm5 manages different kinds of numbers and
allows different syntaxes for numbers, similar to C: 
decimals ([[12]]), 
hexadecimals ([[0xa12]]), 
octals ([[0777]]),
floats ([[0.2]], [[1e3]]), 
or typed integers ([[1uL]]).
%
The [[case]] below use different labels and [[goto]]s
to transition to different states where each state
recognizes a different kind of number:

<<[[yylex()]] before switch, if isxxx>>=
if(isdigit(c))
    goto tnum;
@
<<[[yylex()]] switch c cases>>=
// case '0'..'9': (isdigit())
tnum:
    cp = symb;
    if(c != '0')
        goto dc;

    <<[[yylex()]] in number case, 0xxx handling>>

<<[[yylex()]] in number case, decimal dc label handling>>
<<[[yylex()]] in number case, float labels handling>>
@

%FIGURE state diagram?

%old:
%<<[[yylex()]] in number case, if vlong lval>>=
%if(sizeof(yylval.lval) == sizeof(vlong))
%    yylval.lval = strtoll(symb, nil, 10);
%else
%@
% dead code for 5a and 8a I think


\subsection{Decimals}

Most of the magic for decimal numbers is done
by [[strtol()]] from the core C library:

<<[[yylex()]] in number case, decimal dc label handling>>=
dc:
    for(;;) {
        if(!isdigit(c))
            break;
        *cp++ = c;
        c = GETC();
    }
    <<[[yylex()]] in number case, in decimal case, float handling>>
    *cp = '\0';
    yylval.lval = strtol(symb, nil, 10);

<<[[yylex()]] in number case, in decimal case, ncu suffix label handling>>
    peekc = c;
    return LCONST;
@
%old:    <<[[yylex()]] in number case, if vlong lval>>

The unsigned and long typed suffixes are ignored by Asm5:

<<[[yylex()]] in number case, in decimal case, ncu suffix label handling>>=
ncu:
    while(c == 'U' || c == 'u' || c == 'l' || c == 'L')
        c = GETC();
@
\l ncu?  non current unit?
\t code using that? then comment no?

\subsection{Hexadecimals and octals}

[[strtol()]] does not unfortunately handle hexadecimal
or octal numbers so we have to do things manually:
%ocaml: int_of_string does


<<[[yylex()]] in number case, 0xxx handling>>=
*cp++ = c;
c = GETC();
c1 = 3; // 2^3, for octal
if(c == 'x' || c == 'X') {
    c1 = 4; // 2^4, for hexa
    c = GETC();
} 
else if(c < '0' || c > '7')
    goto dc;
yylval.lval = 0;
for(;;) {
    if(c >= '0' && c <= '9') {
        if(c > '7' && c1 == 3)
            break;
        yylval.lval <<= c1;
        yylval.lval += c - '0';
        c = GETC();
        continue;
    }
    if(c1 == 3)
        break;
    if(c >= 'A' && c <= 'F')
        // c = lowercase(c)
        c += 'a' - 'A';
    if(c >= 'a' && c <= 'f') {
        yylval.lval <<= c1;
        yylval.lval += c - 'a' + 10;
        c = GETC();
        continue;
    }
    break;
}
goto ncu;
@
%ocaml: ugly 3 and 4 special code, ugly abuse c1, but convenient for the <<=

\subsection{Floats}

<<[[yylex()]] in number case, in decimal case, float handling>>=
if(c == '.')
    goto casedot;
if(c == 'e' || c == 'E')
    goto casee;
@

Most of the magic for float numbers is done
by [[atof()]] from the core C library:
\l why a?? why not strtof?

<<[[yylex()]] in number case, float labels handling>>=
casedot:
    for(;;) {
        *cp++ = c;
        c = GETC();
        if(!isdigit(c))
            break;
    }
    if(c == 'e' || c == 'E')
        goto casee;
    goto caseout;

casee:
    *cp++ = 'e';
    c = GETC();
    if(c == '+' || c == '-') {
        *cp++ = c;
        c = GETC();
    }
    while(isdigit(c)) {
        *cp++ = c;
        c = GETC();
    }

caseout:
    *cp = '\0';
    peekc = c;
    if(FPCHIP) {
        yylval.dval = atof(symb);
        return LFCONST;
    } else {
        yyerror("assembler cannot interpret fp constants");
        yylval.lval = 1L;
        return LCONST;
    }
@

A dot without numbers before can be in Asm5 the start of a float or
the start of an identifier, or simply the dot character:

<<[[yylex()]] switch c cases>>=
case '.':
    c = GETC();
    if(isalpha(c)) {
        cp = symb;
        *cp++ = '.';
        goto aloop;
    }
    if(isdigit(c)) {
        cp = symb;
        *cp++ = '.';
        goto casedot;
    }
    peekc = c;
    return '.'; // used case?
@
\l why not simply goto talph for '.'? avoid duplicate the cp = symb; ...
\t single token '.' used?
%ocaml: ocamllex returns the longest or the first in the list

\section{Characters and escape sequences}
\l unicode?

Asm5 allows {\em escape sequences}, which are started with
an antislash, to represent special characters. This is similar to C.
For instance 
[['\n']] represents the newline character,
[['\007']] the character with the octal value [[7]], or
\l interet? why not write 007 outside quote? because it's typed as a char!
\l and it is more readable IMHO, I prefer '\0' to 0.
[['\'']] the quote character itself.
\l special chars because no representation otherwise? or because self escape!

The function [[escchar()]] below is a wrapper around
[[GETC()]] which returns also the next
character unless it is the start of an escape sequence
(the antislash) in which case it returns the value
of the parsed escape sequence (the special character).
Note that characters in Asm5 are converted in integers, hence
the [[LCONST]] token code below:

<<[[yylex()]] switch c cases>>=
case '\'':
    c = escchar('\'');
    <<[[yylex()]] in character case, if c is EOF>>
    if(escchar('\'') != EOF)
        yyerror("missing '");

    yylval.lval = c;
    return LCONST;
@

There are two calls to [[escchar()]]: the first to consume the character
after the first quote, e.g. [[a]] in [['a']],
and the second to consume the ending quote itself.
%FIGURE?
%
Indeed, [[escchar()]] returns the special code EOF if 
the character read is the same than the character passed as an argument, 
here the quote.

%Note also that the code itself below uses also escape sequences
%(to represent the quote character):
\l self!

The code below is to deal with the sequence [[''']], which
is parsed as a single quote:

<<[[yylex()]] in character case, if c is EOF>>=
if(c == EOF)
    c = '\'';
@
\l C does not allow ''' ?

%\section{Escaping characters}
%Special characters?

The argument to [[escchar()]] is the character used to mark the
end of the ``entity'', here
a quote [[']] because we are parsing characters. In the
next section the argument to [[escchar()]] will be the
double quote [["]] character because we will parse strings.

<<function escchar>>=
int
escchar(int e)
{
    int c, l;

loop:
    c = getc(); // not GETC
    if(c == '\n') {
        yyerror("newline in string");
        return EOF;
    }
    if(c != '\\') {
        if(c == e)
            return EOF;
        return c;
    }
    // else c is '\\'
    c = getc();
    <<[[escchar()]] if octal character>>
    switch(c)
    {
    case '\n':	goto loop; // multi line strings

    case 'n':	return '\n';
    case 't':	return '\t';
    case 'b':	return '\b';
    case 'r':	return '\r';
    case 'f':	return '\f';

    <<[[escchar()]] switch cases>>
    }
    return c;
}
@
\t use Rune instead of int?
\l they abuse EOF to mean end of string
\n if not known antislash, then return the char, but should yyerror I think

[[getc()]] is a small wrapper over [[GETC()]] which
automatically handles [[lineno]]:

<<function getc>>=
int
getc(void)
{
    int c;

    c = peekc;
    if(c != IGN) {
        peekc = IGN;
        return c;
    }

    c = GETC();

    if(c == '\n')
        lineno++;
    if(c == EOF) {
        yyerror("End of file");
        errorexit();
    }
    return c;
}
@
\l int? why not uint? GETC can return EOF but not this function!
\t will be called also by macro processing code


<<[[escchar()]] if octal character>>=
if(c >= '0' && c <= '7') {
    l = c - '0';
    c = getc();
    if(c >= '0' && c <= '7') {
        l = l*8 + c-'0';
        c = getc();
        if(c >= '0' && c <= '7') {
            l = l*8 + c-'0';
            return l;
        }
    }
    peekc = c;
    return l;
}
@
\n can have 1, 2, or 3 oct, but no more

Asm5 allows a few more escape sequences compared to C:

<<[[escchar()]] switch cases>>=
case 'a':	return 0x07;
case 'v':	return 0x0b;
case 'z':	return 0x00;
@
\l meh

\section{Strings}

<<[[yylex()]] switch c cases>>=
case '"':
    memcpy(yylval.sval, nullgen.sval, sizeof(yylval.sval));
    cp = yylval.sval;
    c1 = 0;
    for(;;) {
        c = escchar('"');
        if(c == EOF)
            break;
        if(c1 < sizeof(yylval.sval))
            *cp++ = c;
        c1++;
    }
    if(c1 > sizeof(yylval.sval))
        yyerror("string constant too long");
    return LSCONST;
@
\l abuse c1
\t works nullgen.sval?? add the appropriate 0? why not just *cp = '\0' ?








\chapter{Preprocessing}
\label{chap:preprocessing}

% Builtin in the binary. A bit of code duplication with the
% compiler, but maybe it makes compilation faster because
% there is no fork at all!

\section{[[mactab]] and [[domacro()]]}

<<[[yylex()]] switch c cases>>=
case '#':
    domacro();
    goto l0;
@
% goto l0 because does not return any token, we just have
% actually expanded or defined macros or undef, in any case
% no token to return, but iostack will have maybe changed,
% or symbol table, and so GETC will maybe change.
%ocaml: external cpp, just handle #line!!

<<global mactab>>=
struct
{
    char	*macname;
    void	(*macf)(void);
} mactab[] =
{
    "ifdef",	nil,	/* macif(0) */
    "ifndef",	nil,	/* macif(1) */
    "else",		nil,	/* macif(2) */
    "endif",	macend,

    "include",	macinc,
    "define",	macdef,
    "undef",	macund,
    "pragma",	macprag,
    "line",		maclin,
    0
};
@
% mac for macro (and not macos or macintosh), but used actually
% for all cpp related constructs.
%old: I reorganized the entries, but should not matter


% dispatcher, should rename because it's not just about macro =>
% parse_and_dispatch_pp_directive?
<<function domacro>>=
/// main -> assemble -> yyparse -> yylex -> <>
void
domacro(void)
{
    int i;
    Sym *s;

    s = getsym();
    if(s == S)
        s = slookup("endif");

    for(i=0; mactab[i].macname; i++)
        if(strcmp(s->name, mactab[i].macname) == 0) {
            if(mactab[i].macf)
                // dispatcher!
                (*mactab[i].macf)();
            else
                macif(i);
            return;
        }
    yyerror("unknown #: %s", s->name);
    macend();
}
@
% abuse getsym just to get an ident, don't have to go through
% lookup really
% note: didn't know that a single # is actually equivalent to an endif



<<function getsym>>=
Sym*
getsym(void)
{
    int c;
    char *cp;

    c = getnsc();
    if(!isalpha(c) && c != '_' && c < Runeself) {
        unget(c);
        return S;
    }
    for(cp = symb;;) {
        if(cp <= symb+NSYMB-4)
            *cp++ = c;
        c = getc();
        if(isalnum(c) || c == '_' || c >= Runeself)
            continue;
        unget(c);
        break;
    }
    *cp = '\0';
    if(cp > symb+NSYMB-4)
        yyerror("symbol too large: %s", symb);
    return lookup();
}
@
% seen getc before



% get non space char (they really like short cryptic names)
<<function getnsc>>=
int
getnsc(void)
{
    int c;

    for(;;) {
        c = getc();
        if(!isspace(c) || c == '\n')
            return c;
    }
}
@

% what if had already a peekc? because called unget 2 times?
% should raise Impossible!
<<function unget>>=
void
unget(int c)
{
    peekc = c;
    if(c == '\n')
        lineno--;
}
@



<<function macend>>=
void
macend(void)
{
    int c;

    for(;;) {
        c = getnsc();
        if(c < 0 || c == '\n')
            return;
    }
}
@
% I don't think c can be < 0 here.


\section{[[#include]]}
% and [[-I]]

\subsection{Include path, [[-I]]}

<<[[main()]] locals>>=
char *p;
@

% -I
<<[[main()]] command line processing>>=
case 'I':
    p = ARGF();
    setinclude(p);
    break;
@


% hmm rename? include_paths?
<<global include>>=
char*	include[NINCLUDE];
@
<<constant NINCLUDE>>=
#define	NINCLUDE	10
@
<<global ninclude>>=
int	ninclude;
@
\n set to 0 because global?

<<function setinclude>>=
void
setinclude(char *p)
{
    int i;

    if(p == nil)
        return;
    for(i=1; i < ninclude; i++)
        if(strcmp(p, include[i]) == 0)
            return;

    if(ninclude >= nelem(include)) {
        yyerror("ninclude too small %d", nelem(include));
        exits("ninclude");
    }
    include[ninclude++] = p;
}
@
\t why starts at 1? because include[0] is special, it is "." or dirname(infile)


\subsection{[[#include]]}

<<constant STRINGSZ>>=
#define	STRINGSZ	200
@

% LP split
<<function macinc>>=
void
macinc(void)
{
    int c0;
    int c, i;
    fdt f = -1;
    char str[STRINGSZ], *hp;

    c0 = getnsc();
    if(c0 != '"') {
        c = c0;
        if(c0 != '<')
            goto bad;
        c0 = '>';
    }
    for(hp = str;;) {
        c = getc();
        if(c == c0)
            break;
        if(c == '\n')
            goto bad;
        *hp++ = c;
    }
    *hp = '\0';

    c = getcom();
    if(c != '\n')
        goto bad;

    for(i=0; i<ninclude; i++) {
        if(i == 0 && c0 == '>')
            continue;
        strcpy(symb, include[i]);
        strcat(symb, "/");
        if(strcmp(symb, "./") == 0)
            symb[0] = '\0';
        strcat(symb, str);

        f = open(symb, 0);
        if(f >= 0)
            break;

    }
    if(f < 0)
        strcpy(symb, str);
    c = strlen(symb) + 1;

    while(c & 3)
        c++;
    hp = malloc(c);

    memcpy(hp, symb, c);

    newio();
    pushio();
    newfile(hp, f);
    return;

bad:
    unget(c);
    yyerror("syntax in #include");
    macend();
}
@

\t how lineno? incremented by 1 and then start processing included file?
\t or #include like non existent and replaced by content?


<<function pushio>>=
void
pushio(void)
{
    Io *i;

    i = iostack;
    if(i == I) {
        yyerror("botch in pushio");
        errorexit();
    }
    // save current position in includer
    i->p = fi.p;
    i->c = fi.c;
}
@

% accept comment or space until newline
% will increment lineno since use getc
<<function getcom>>=
int
getcom(void)
{
    int c;

    for(;;) {
        c = getnsc();
        if(c != '/')
            break;
        c = getc();
        if(c == '/') {
            while(c != '\n')
                c = getc();
            break;
        }
        if(c != '*')
            break;
        c = getc();
        for(;;) {
            if(c == '*') {
                c = getc();
                if(c != '/')
                    continue;
                c = getc();
                break;
            }
            if(c == '\n') {
                yyerror("comment across newline");
                break;
            }
            c = getc();
        }
        if(c == '\n')
            break;
    }
    return c;
}
@
\l dupe because reused code in different assemblers.




\section{[[#define]]}
% and [[-D]]

\subsection{[[-D]]}

<<[[main()]] command line processing>>=
case 'D':
    p = ARGF();
    if(p)
        Dlist[nDlist++] = p;
    break;
@

% -D
<<global Dlist>>=
char*	Dlist[30];
@
<<global nDlist>>=
int	nDlist;
@

<<[[assemble()]] init Dlist after pinit>>=
for(i=0; i<nDlist; i++)
        dodefine(Dlist[i]);
@



<<[[Sym]] macro fields>>=
//option<string>, for '#define FOO xxx' expansion
char*	macro;
@
\label{sec:macro-sym-field}

<<[[pinit()]] initialisations>>=
for(i=0; i<NHASH; i++)
    for(s = hash[i]; s != S; s = s->link)
        s->macro = nil;
@


<<function dodefine>>=
void
dodefine(char *cp)
{
    Sym *s;
    char *p;
    long l;
    char *x;

    strcpy(symb, cp);
    p = strchr(symb, '=');
    if(p) {
        *p++ = '\0';
        s = lookup();
        l = strlen(p) + 2;	/* +1 null, +1 nargs */

        while(l & 3)
            l++;
        x = malloc(l);

        *x = '\0';
        strcpy(x+1, p);
        s->macro = x;
    } else {
        s = lookup();
        s->macro = "\0001";	/* \000 is nargs */
    }
    <<[[dodefine()]] debug>>
}
@
\l argh abuse macro to also store arguments


\subsection{[[#define]]}

<<constant NARG>>=
#define	NARG	25
@

% wow, this is complicated
<<function macdef>>=
void
macdef(void)
{
    Sym *s, *a;
    char *args[NARG], *np, *base;
    int n, i, c, len;
    bool dots;
    int ischr;

    s = getsym();
    if(s == S)
        goto bad;
    if(s->macro)
        yyerror("macro redefined: %s", s->name);
    c = getc();
    n = -1;
    dots = 0;
    if(c == '(') {
        n++;
        c = getnsc();
        if(c != ')') {
            unget(c);
            for(;;) {
                a = getsymdots(&dots);
                if(a == S)
                    goto bad;
                if(n >= NARG) {
                    yyerror("too many arguments in #define: %s", s->name);
                    goto bad;
                }
                args[n++] = a->name;
                c = getnsc();
                if(c == ')')
                    break;
                if(c != ',' || dots)
                    goto bad;
            }
        }
        c = getc();
    }
    if(isspace(c))
        if(c != '\n')
            c = getnsc();
    base = hunk;
    len = 1;
    ischr = 0;
    for(;;) {
        if(isalpha(c) || c == '_') {
            np = symb;
            *np++ = c;
            c = getc();
            while(isalnum(c) || c == '_') {
                *np++ = c;
                c = getc();
            }
            *np = '\0';
            for(i=0; i<n; i++)
                if(strcmp(symb, args[i]) == 0)
                    break;
            if(i >= n) {
                i = strlen(symb);
                base = allocn(base, len, i);
                memcpy(base+len, symb, i);
                len += i;
                continue;
            }
            base = allocn(base, len, 2);
            base[len++] = '#';
            base[len++] = 'a' + i;
            continue;
        }
        if(ischr){
            if(c == '\\'){ 
                base = allocn(base, len, 1);
                base[len++] = c;
                c = getc();
            }else if(c == ischr)
                ischr = 0;
        }else{
            if(c == '"' || c == '\''){
                base = allocn(base, len, 1);
                base[len++] = c;
                ischr = c;
                c = getc();
                continue;
            }
            if(c == '/') {
                c = getc();
                if(c == '/'){
                    c = getc();
                    for(;;) {
                        if(c == '\n')
                            break;
                        c = getc();
                    }
                    continue;
                }
                if(c == '*'){
                    c = getc();
                    for(;;) {
                        if(c == '*') {
                            c = getc();
                            if(c != '/')
                                continue;
                            c = getc();
                            break;
                        }
                        if(c == '\n') {
                            yyerror("comment and newline in define: %s", s->name);
                            break;
                        }
                        c = getc();
                    }
                    continue;
                }
                base = allocn(base, len, 1);
                base[len++] = '/';
                continue;
            }
        }
        if(c == '\\') {
            c = getc();
            if(c == '\n') {
                c = getc();
                continue;
            }
            else if(c == '\r') {
                c = getc();
                if(c == '\n') {
                    c = getc();
                    continue;
                }
            }
            base = allocn(base, len, 1);
            base[len++] = '\\';
            continue;
        }
        if(c == '\n')
            break;
        if(c == '#')
        if(n > 0) {
            base = allocn(base, len, 1);
            base[len++] = c;
        }
        base = allocn(base, len, 1);
        base[len++] = c;
        c = ((--fi.c < 0)? filbuf(): (*fi.p++ & 0xff));
        if(c == '\n')
            lineno++;
        if(c == -1) {
            yyerror("eof in a macro: %s", s->name);
            break;
        }
    }
    do {
        base = allocn(base, len, 1);
        base[len++] = 0;
    } while(len & 3);

    *base = n+1;
    if(dots)
        *base |= VARMAC;
    s->macro = base;
    <<[[macdef()]] debug>>
    return;

bad:
    if(s == S)
        yyerror("syntax in #define");
    else
        yyerror("syntax in #define: %s", s->name);
    macend();
}
@
% wow, complicated

<<constant VARMAC>>=
#define VARMAC 0x80
@


<<function getsymdots>>=
Sym*
getsymdots(bool *dots)
{
    int c;
    Sym *s;

    s = getsym();
    if(s != S)
        return s;

    c = getnsc();
    if(c != '.'){
        unget(c);
        return S;
    }
    if(getc() != '.' || getc() != '.')
        yyerror("bad dots in macro");
    *dots = true;
    return slookup("__VA_ARGS__");
}
@

\subsection{Macro expansion}

<<[[yylex()]] if macro symbol>>=
if(s->macro) {
    newio();
    cp = ionext->b;
    macexpand(s, cp);
    pushio();

    ionext->link = iostack;
    iostack = ionext;

    fi.p = cp;
    fi.c = strlen(cp);
    if(peekc != IGN) {
        cp[fi.c++] = peekc;
        cp[fi.c] = 0;
        peekc = IGN;
    }
    goto l0;
}
@
% abuse newio()? it's not really a new file here

% wow, complicated too
<<function macexpand>>=
void
macexpand(Sym *s, char *b)
{
    char buf[2000];
    int n, l, c, nargs;
    char *arg[NARG], *cp, *ob, *ecp, dots;

    ob = b;
    if(*s->macro == 0) {
        strcpy(b, s->macro+1);
        if(debug['m'])
            print("#expand %s %s\n", s->name, ob);
        return;
    }
    
    nargs = (char)(*s->macro & ~VARMAC) - 1;
    dots = *s->macro & VARMAC;

    c = getnsc();
    if(c != '(')
        goto bad;
    n = 0;
    c = getc();
    if(c != ')') {
        unget(c);
        l = 0;
        cp = buf;
        ecp = cp + sizeof(buf)-4;
        arg[n++] = cp;
        for(;;) {
            if(cp >= ecp)
                goto toobig;
            c = getc();
            if(c == '"')
                for(;;) {
                    if(cp >= ecp)
                        goto toobig;
                    *cp++ = c;
                    c = getc();
                    if(c == '\\') {
                        *cp++ = c;
                        c = getc();
                        continue;
                    }
                    if(c == '\n')
                        goto bad;
                    if(c == '"')
                        break;
                }
            if(c == '\'')
                for(;;) {
                    if(cp >= ecp)
                        goto toobig;
                    *cp++ = c;
                    c = getc();
                    if(c == '\\') {
                        *cp++ = c;
                        c = getc();
                        continue;
                    }
                    if(c == '\n')
                        goto bad;
                    if(c == '\'')
                        break;
                }
            if(c == '/') {
                c = getc();
                switch(c) {
                case '*':
                    for(;;) {
                        c = getc();
                        if(c == '*') {
                            c = getc();
                            if(c == '/')
                                break;
                        }
                    }
                    *cp++ = ' ';
                    continue;
                case '/':
                    while((c = getc()) != '\n')
                        ;
                    break;
                default:
                    unget(c);
                    c = '/';
                }
            }
            if(l == 0) {
                if(c == ',') {
                    if(n == nargs && dots) {
                        *cp++ = ',';
                        continue;
                    }
                    *cp++ = 0;
                    arg[n++] = cp;
                    if(n > nargs)
                        break;
                    continue;
                }
                if(c == ')')
                    break;
            }
            if(c == '\n')
                c = ' ';
            *cp++ = c;
            if(c == '(')
                l++;
            if(c == ')')
                l--;
        }
        *cp = 0;
    }
    if(n != nargs) {
        yyerror("argument mismatch expanding: %s", s->name);
        *b = 0;
        return;
    }
    cp = s->macro+1;
    for(;;) {
        c = *cp++;
        if(c == '\n')
            c = ' ';
        if(c != '#') {
            *b++ = c;
            if(c == 0)
                break;
            continue;
        }
        c = *cp++;
        if(c == 0)
            goto bad;
        if(c == '#') {
            *b++ = c;
            continue;
        }
        c -= 'a';
        if(c < 0 || c >= n)
            continue;
        strcpy(b, arg[c]);
        b += strlen(arg[c]);
    }
    *b = 0;
    if(debug['m'])
        print("#expand %s %s\n", s->name, ob);
    return;

bad:
    yyerror("syntax in macro expansion: %s", s->name);
    *b = 0;
    return;

toobig:
    yyerror("too much text in macro expansion: %s", s->name);
    *b = 0;
}
@
% wow complicated again

\section{[[#undef]]}

<<function macund>>=
void
macund(void)
{
    Sym *s;

    s = getsym();
    macend();
    if(s == S) {
        yyerror("syntax in #undef");
        return;
    }
    s->macro = nil;
}
@

\section{[[#ifdef]]}

% 0 = ifdef, 1 = ifndef, 2 = else, see mactab and domacro
<<function macif>>=
void
macif(int f)
{
    int c, l;
    bool bol;
    Sym *s;

    if(f == 2)
        goto skip;
    s = getsym();
    if(s == S)
        goto bad;
    if(getcom() != '\n')
        goto bad;
    if((s->macro != nil) ^ f)
        return;

skip:
    bol = true;
    l = 0;
    for(;;) {
        c = getc();
        if(c != '#') {
            if(!isspace(c))
                bol = false;
            if(c == '\n')
                bol = true;
            continue;
        }
        if(!bol)
            continue;
        s = getsym();
        if(s == S)
            continue;
        if(strcmp(s->name, "endif") == 0) {
            if(l) {
                l--;
                continue;
            }
            macend();
            return;
        }
        if(strcmp(s->name, "ifdef") == 0 || strcmp(s->name, "ifndef") == 0) {
            l++;
            continue;
        }
        if(l == 0 && f != 2 && strcmp(s->name, "else") == 0) {
            macend();
            return;
        }
    }

bad:
    yyerror("syntax in #if(n)def");
    macend();
}
@

\section{[[#pragma]]}

% effect of #pragma lib in .s ??

<<function macprag>>=
void
macprag(void)
{
    Sym *s;
    <<[[macprag()]] locals>>

    s = getsym();

    <<[[macprag()]] if pragma lib>>
    else {
        while(getnsc() != '\n')
            ;
        return;
    }
}
@


% most pragma seems to be discarded here, except #pragma lib, so
% I removed then (could have aslo simplified by calling prag_do_nothing()).
% it is because the code was shared with cc before I think and the compilers
% had different pragxxx functions with an actual body.
%
%    if(s && strcmp(s->name, "pack") == 0) {
%        pragpack();
%        return;
%    }
%    if(s && strcmp(s->name, "fpround") == 0) {
%        pragfpround();
%        return;
%    }
%    if(s && strcmp(s->name, "profile") == 0) {
%        pragprofile();
%        return;
%    }
%    if(s && strcmp(s->name, "varargck") == 0) {
%        pragvararg();
%        return;
%    }
%    if(s && strcmp(s->name, "incomplete") == 0) {
%        pragincomplete();
%        return;
%    }
%
%old:
%<<function pragpack>>=
%void
%pragpack(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@
%
%<<function pragvararg>>=
%void
%pragvararg(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@
%
%<<function pragfpround>>=
%void
%pragfpround(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@
%
%<<function pragprofile>>=
%void
%pragprofile(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@
%
%<<function pragincomplete>>=
%void
%pragincomplete(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@


\section{[[#line]]}
\label{sec:sharp-line}
% most important one because if have no cpp, at least must handle this one!

% #line 3 "foo.c"
% #line 3 is also possible in which case get <noname>

% also useful for yacc, not just cpp.

<<function maclin>>=
void
maclin(void)
{
    char *cp;
    int c;
    long n;

    n = getnsn();
    c = getc();
    if(n < 0)
        goto bad;

    for(;;) {
        if(c == ' ' || c == '\t') {
            c = getc();
            continue;
        }
        if(c == '"')
            break;
        if(c == '\n') {
            strcpy(symb, "<noname>");
            goto nn;
        }
        goto bad;
    }
    cp = symb;
    for(;;) {
        c = getc();
        if(c == '"')
            break;
        *cp++ = c;
    }
    *cp = '\0';
    c = getcom();
    if(c != '\n')
        goto bad;

nn:
    c = strlen(symb) + 1;

    while(c & 3)
        c++;
    cp = malloc(c);

    memcpy(cp, symb, c);

    <<[[maclin()]] call linehist>>
    return;

bad:
    unget(c);
    yyerror("syntax in #line");
    macend();
}
@
\l does not handle escape char in string this time
%BUG: accept newline?

% get number?
<<function getnsn>>=
long
getnsn(void)
{
    long n;
    int c;

    c = getnsc();
    if(c < '0' || c > '9')
        return -1;
    n = 0;
    while(c >= '0' && c <= '9') {
        n = n*10 + c-'0';
        c = getc();
    }
    unget(c);
    return n;
}
@


%\section{[[getxxx()]]}

% from now on those functions are actually used by the preprocessing
% code, not by the basic lexer (yylex) that actually implement
% his own getnsc(), getcom(), getsym() via cases
% (hmmm maybe could factorize things?)

%\subsection{[[getc()]], [[unget()]], [[getnsc()]]}
% helpers for other functions

% getc() is presented before

% unget()

% getnsc()


%\subsection{[[getsym()]]}
% mv with Keywords and identifier section?

% \subsection{[[getcom()]]}
% mv with Comments section above?





\chapter{Parsing}
\label{chap:parsing}

In this chapter we present the Yacc {\em grammar} of Asm5,
the ARM assembly language supported by [[5a]].
%trans:
[[yacc]] generates from this grammar the [[yyparse()]] parsing function
which is called by [[assemble()]] and which internally
calls [[yylex()]].
%
We assume you know how to read a Yacc grammar, otherwise 
read~\cite{lexyacc}\footnote{
You can also read the original Yacc paper 
at [[generators/docs/yacc.pdf]]
in our \plan repository, or read our \book{Code Generators} to fully
understand how Yacc works.}.

\section{Overview}

Here is the outline of the Yacc grammar file for Asm5:

<<5a/a.y>>=
%{
#include "a.h"
%}
<<union declaration(arm)>>
<<priority and associativity declarations>>
<<token declarations(arm)>>
<<type declarations(arm)>>
%%
<<grammar(arm)>>
@
%$
\n classic Yacc
\n no %start? the first rule in the file is the default start?
%ocaml: no need union, no need much type decls

%toc:
The [[%union]] and [[%token]] {directives} have been
already described in Section~\ref{sec:token}.
The [[%type]] declarations will be described gradually in this chapter. 
The priority declarations are used only for the constant
expressions (an advanced Asm9 feature) and will be described in
Section~\ref{sec:constant-expr}.

The grammar part at the end is the most important one.
It contains the different parsing {\em rules}
which will be presented gradually in this chapter:
\n and also some in other features chapter

<<grammar(arm)>>=
<<prog rule(arm)>>
<<line rule(arm)>>
<<inst rule(arm)>>
<<operand rules(arm)>>
<<cond rule(arm)>>

<<advanced topics rules>>

<<helper rules(arm)>>
@
\n actually not context free; parsing a file modify the kind of toks (LLAB)

Essentially, an assembly program is made of a set lines containing
instructions or labels. Instructions are made of an opcode followed 
possibly by a few operands. Each operand can either be a register, a
constant, a symbol, or certain combinations of the previous elements
(e.g. a register and constant offset forming an address).

More formally, an Asm5 [[prog]]ram is either an empty file or a
set of [[line]]s:
<<prog rule(arm)>>=
prog:
  /* empty */
| prog line
@
\l FIGURE with derivation where see set of lines?
%ocaml: no EOF?

A [[line]] can be an [[inst]]ruction followed by a semicolon
(remember that the lexer transforms newlines in semicolons
as explained in Section~\ref{sec:semicolon}):
\l so can either pack in one line with ';' or use newline (haskell spirit :) )

<<line rule(arm)>>=
line:
  inst ';'
@

It can also be empty, or contain the special [[error]] Yacc
token used for error recovery (see~\cite{lexyacc}):
\l to got until next ; (that is newline)?

<<line rule(arm)>>=
| ';'
| error ';'
@

%toc:
In the following section we will focus on the [[inst]]ruction
rule and see the major opcodes of Asm5.
In Section~\ref{sec:label-def} we will see that a line
can also contain label definitions.
Then, in Section~\ref{sec:operands-grammar} we will focus on the
major operands of Asm5. 
We will then explore a few advanced features of Asm5.
\l pseudo-instr, cond exec
%compiler:
While presenting the syntax of the different features of Asm5,
we will also try in this chapter to discuss how those features can be used
to implement higher-level constructs of languages such as C.
\l which will also help to understand them, why they are useful,when to use them
We will conclude this chapter by discussing the generated code
for [[yyparse()]] by [[yacc]].

\ifallcode
<<advanced topics rules>>=
<<constant expression rules>>
<<float rules>>
<<reglist rule>>
<<creg rule>>
<<oexpr rule>>
@
\fi

\section{Instructions}
\n =~ statements

%dup: from core-ds/opcode
Most instructions of Asm5 correspond to machine instructions
of the ARM described in the \book{Emulator}, and can be
grouped in the same categories: 
arithmetic and logic, 
memory,
control flow, and 
software interrupt.
%
To fully understand the semantics of those Asm5 instructions read
the \book{Emulator}.

%from http://www.vpri.org/pdf/rn2010001_programm.pdf
%a typical cpu can do a few things pretty quickly:
% - fetch, fetch[i], store, store[i]
% - +,-,*,/
% - =, <
% - and, or
% - shift
% - jump, if ... jump, jump-linked

\subsection{Arithmetic and logic}

%turing: fundamental!

\subsubsection{Logic}

Here are the {bitwise} {boolean logic} opcodes of Asm5,
%trans:
which are enumeration cases of the [[Opcode]] type
overviewed in Section~\ref{sec:opcode}:

<<[[Opcode]] cases, logic opcodes>>=
AAND,
AORR,
AEOR, // a.k.a. XOR
@
\n not exactly the ARM order, e.g. I prefer to put closer AAND and AORR

Their ``reading syntax'' are described via entries in [[itab]]
%trans:
presented in Section~\ref{sec:token} (those entries populate
the symbol table [[hash]] as explained in Section~\ref{sec:sym}):

<<[[itab]] elements>>=
"AND",		LARITH,	AAND,
"ORR",		LARITH,	AORR,
"EOR",		LARITH,	AEOR,
@

The logic opcodes take either 2 or 3 operands,
mostly registers. Usually the first two operands are combined
and the result stored in the third operand.
Here are some examples:
\begin{verbatim}
AND $0x0f, R1, R2 // R2 = R1 & 0x0f;
ORR $0xff, R2     // <=> ORR $0xff, R2, R2
\end{verbatim}
%$
\n left-to-right
\n if middle register is NONE then ADD X1, X2 -> ADD X1, X2, X2 (plus=)
\t how do NOT? MVN?

Logic instructions have the same syntax than
arithmetic instructions in Asm5 and so share 
the same grammar rule:

<<inst rule(arm)>>=
inst:
/*
 * AND/ORR/ADD/SUB/...
 */
  LARITH cond imsr ',' regi ',' reg { outcode($1, $2, &$3, $5, &$7); }
| LARITH cond imsr ',' reg          { outcode($1, $2, &$3, R_NONE, &$5); }
@
%$
%old:| LARITH cond imsr ',' spreg ','   { outcode($1, $2, &$3, $5, &nullgen); }
\n arith operator of Machine.nw, but also virtual: SLL, SRL,   DIV, MOD, ...

The \$$n$ Yacc notation in the {\em actions} between braces
gives access to the {\em value} of the nth {terminal} or 
{non-terminal} in the rule.
For terminals this value is derived from the global [[yylval]]
set by the lexer.
\l for non-terminals? \$\$
\n how manage multiple values then at the same time? array ? see \book{Yacc}
Here are the different values for the different elements
in the first rule of [[inst]] above:

\begin{enumerate}
\item [[LARITH]] is the {token name} for all arithmetic and logic mnemonics.
\$1 contains the enumeration value of the corresponding opcode,
for instance [[AAND]] if the lexed token was [["AND"]]
(see the [[itab]] entries above)

\item [[cond]] represents the {\em conditional execution} of an instruction.
It is an ARM feature we will explain later in Section~\ref{sec:cond-exec}.
Every Asm5 instruction rules have a non-terminal [[cond]] after
the opcode.

\item [[imsr]] is a shortand for: 
[[im]]mediate (constant) or 
[[s]]hifted-register or 
[[r]]egister. 
Those are operands we will describe
in Section~\ref{sec:imsr}. \$3 is of type [[Gen]], the
generalized form of operand we described in Section~\ref{sec:operand}.

\item the first comma, a single-character token without
any value
\l or ascii code?

\item [[regi]] is a register. \$5
%\footnote{\$4 corresponds to the comma preceding [[regi]]}
is an integer representing the register, e.g. 10 for [[R10]].

\item the second comma

\item [[reg]] is also a register but wrapped
in a [[Gen]]. We use a [[Gen]] for \$7 and an integer
for \$5 because of the signature of [[outcode()]]
described in Section~\ref{sec:outcode-signature}.
Indeed, when an ARM instruction have 3 operands, the middle one 
is always a register, so an integer is enough for the fourth
argument to [[outcode()]].

\end{enumerate}

Note that almost all operands above are registers, except 
the first one which can also be a constant or a shifted register.
There is no memory reference. Indeed, the ARM is a RISC machine
where memory references are restricted only to the LOAD and STORE
operations (unified in the [[MOV]] virtual instruction in Asm5),
which we will see later.
\l Von Newmann bottleneck
 
%compiler:
The three opcodes in this section have a direct correspondance
with the following C operators: [[&]], [[|]], and [[^]].
They can also be used to encode boolean expressions
involving [[&&]] and [[||]].
\t how NOT? MVN?
Those C operators are useful in many contexts:
complex conditions in [[if]] and [[while]] statements ([[if(e1 && e2)]]),
boolean variables ([[bool b = b1 || b2;]]),
bitsets operations ([[set1 | set2]]),
bit extraction ([[x & 0x4]]),
bitmask ([[y & 0xff]]), 
etc.
\t say that 32 bitwise boolean logic? truth table?
\t to explain AAND we give corresponce to C, but then in C we do the opposite
\t  and in the emulator we use C, so never have a final semantic :(
%self-ref:
Those operators are heavily used in the \book{Emulator}. Indeed,
managing the binary format of ARM instructions requires many bit
manipulations.

%turing:
Boolean logic is at the foundation of mathematics and
so it is also logic (no pun intended) to have boolean opcodes
as fundamental opcodes of the computer
\footnote{In fact, a whole computer can be made using just the 
Nand logic gate~\cite{tecs}}.
\l vs turing? von newmann? they assume basic math lang which is logic and arith

\subsubsection{Add/sub}

Basic arithmetic is also fundamental to have in a computer:

<<[[Opcode]] cases, add/sub opcodes>>=
AADD,
ASUB,
@
<<[[itab]] elements>>=
"ADD",		LARITH,	AADD,
"SUB",		LARITH,	ASUB,
@

As said in the previous section,
arithmetic instructions have the same syntax than
logic instructions in Asm5 and so use the same grammar rule
involving the [[LARITH]] token code.


%compiler: 
Again, The two opcodes above have a direct correspondance
with C operators: [[+]] and [[-]].
\t complement a 2 arithmetic, no need different ops if signed or unsigned!
\t overflow? signed vs unsigned?
\l which are used heavily for instance in numerical algorithms.
%
%The C compiler uses also arithmetic opcodes to encode many things.
%For instance, access to the field of a structure, e.g. [[x->fld]],
%is usually encoded as a memory reference with a base ([[x]])
%and an offset which is the location of the field in the structure.
\l for x->fld, but can do MOV for that
%turing: fundamental arith in turing machine language

% see also Comparison section, part of Arith opcode in Machine.nw




\subsubsection{Mul/div/mod}

%compiler:
The three opcodes below are in direct correspondance
with the following C operators: [[*]], [[/]], [[%]].

<<[[Opcode]] cases, mul/div/mod opcodes>>=
AMUL,
ADIV, // VIRTUAL, transformed in call to _div
AMOD, // VIRTUAL, transformed in call to _mod
@
<<[[itab]] elements>>=
"MUL",		LARITH, AMUL,
"DIV",		LARITH,	ADIV,
"MOD",		LARITH,	AMOD,
@

The ARM actually has no [[DIV]] or [[MOD]] instruction.
Those {virtual instructions} are converted by [[5l]] in
calls to assembly functions of the core C library
[[_div()]] and [[_mod()]]
which implement the division and modulo algorithm in software.
See Appendix~\ref{chap:examples} for the code of those
assembly functions.
% compiler: need also mul for array access, need base + idx * size of entry.
%  for pointer arithmetic in general!




\subsubsection{Bit shift}
\label{sec:bitshift-opcodes}

%compiler:
The opcodes below are in direct correspondance
with the following C operators: [[<<]], and [[>>]]:

<<[[Opcode]] cases, bitshift opcodes>>=
ASLL, // Shift Left  Logic, VIRTUAL transformed in bitshifted registers
ASRL, // Shift Right Logic, VIRTUAL transformed in bitshifted registers
ASRA, // Shift Right Arithmetic, VIRTUAL transformed in bitshifted registers
@
<<[[itab]] elements>>=
"SLL",		LARITH,	ASLL,
"SRL",		LARITH,	ASRL,
"SRA",		LARITH,	ASRA,
@

\t arithmetic right shift?? vs logical right shift??
\t how 5c decides which one to use? type checking? unsigned!

The ARM does not really have those opcodes though; it does
not use those mnemonics for bit shift operations.
Instead, the ARM has a more general approach to bit shifting:
{\em operands} of many operations ([[AND]], [[SUB]],
etc) can be registers with {\em shift annotations}
as explained later in Section~\ref{sec:shift-register}.
%
The opcodes above are thus translated by [[5l]] in the [[MOV]] ARM
instruction (which confusingly as nothing to do with
the Asm5 virtual instruction [[MOV]] we will see later)
with bitshifted register operands.
\n not really virtual

%self-ref:
Bit shift operations are also heavily used
in the \book{Emulator} because of the binary format of 
ARM instructions.
%are used in this document for the
%[[MCRR]] macro in Section~\ref{sec:mcrr-macro}, and as we will
%see later in Section~\ref{sec:outcode} when generating
%the (binary) object file. 
%also to encode the kind of the bitshift (tricky self ref).
\t for what? to extract bit, make bits, etc
\l for MCRR it is assembly code, but for the rest it is in C code. confusing?
%compiler:
\t also useful for multiplication optimisation (when power of 2), but faster?


\subsubsection{Other arithmetic and logic opcodes}

There are a few additional Asm5 opcodes related to
arithmetic and logic mimicing ARM instructions,
but they are less useful:

\t have we covered mostly all C operators?
\l then explain how go from expr to instr?

<<[[Opcode]] cases, logic opcodes>>=
ABIC, // ??
@
<<[[itab]] elements>>=
"BIC",		LARITH,	ABIC,
@

<<[[Opcode]] cases, add/sub opcodes>>=
ARSB, // ??
AADC, // Add and carry?
ASBC, // Sub and carry?
ARSC, // ??
@
<<[[itab]] elements>>=
"RSB",		LARITH,	ARSB,
"ADC",		LARITH,	AADC,
"SBC",		LARITH,	ASBC,
"RSC",		LARITH,	ARSC,
@
\t RSB? used by _div

% optional? not used a single time in arm/*.s, used a bit in 5c/
<<[[Opcode]] cases, add/sub opcodes>>=
AMVN, // MOV negative, but nothing to do with MOVW
@
\l there is also a MOV in 5i, but it has nothing to do with MOVW too
<<[[itab]] elements>>=
"MVN",		LMVN, AMVN,	/* op2 ignored */
@
\n op2 ignored means actually operand 3 ignored, hence the special rule below
<<inst rule(arm)>>=
/*
 * MVN
 */
| LMVN cond imsr ',' reg { outcode($1, $2, &$3, R_NONE, &$5); }
@


Many of those opcodes are actually never used in the assembly
code generated by the C compiler [[5c]].
See the \book{Emulator} to learn about their semantics.
%ex: ABIC, AADC, ASBC, ARSC
% ARSB seems used (used also by _div), AMVN too


\subsection{Memory}

%turing: 
% machine is von newman model, memory is everything
% but bottleneck, hence RISC model actually
%compiler: 
% store simple data(int), complex (aggregate), store results, 
% store pointers! need powerful memory assign.

Because the ARM is a RISC machine, all memory references in the ARM
are restricted to mostly two machine instructions: 
\n mostly because of SWAP too below
[[LDR]] which {\em loads} some data from memory into a register, and 
[[STR]] which {\em stores} the content of a register into memory.
In Asm5 those two instructions are unified in the
single virtual instruction [[MOV]].
%toc:
Another memory instruction [[SWPW]] allows to {\em swap} the content
of a register with the content at a memory address.

\subsubsection{Moves}

[[MOV]]s are converted by [[5l]] in the appropriate
machine instruction depending on the operands:

\begin{verbatim}
MOVW R1, (R2)  // This is a store
MOVW (R2), R1  // This is a load
\end{verbatim}

[[MOV]]s come in different variants, depending on the size
of the memory moved:

\begin{itemize}
\item [[MOVW]] for moving words (4 bytes)
\item [[MOVB]] for moving bytes (1 byte)
\item [[MOVBU]] for moving unsigned bytes (1 byte)
\item [[MOVH]] for moving half words (2 bytes)
\item [[MOVHU]] for moving unsigned half words (2 bytes)
\end{itemize}
\t why unsigned? why care about that in move operations??

Here are the corresponding Asm5 opcodes:

<<[[Opcode]] cases, mov opcodes>>=
AMOVW, // VIRTUAL, transformed in load and store instructions
AMOVB,
AMOVBU,
AMOVH,
AMOVHU,
@
<<[[itab]] elements>>=
"MOVW",		LMOV, AMOVW,
"MOVB",		LMOV, AMOVB,
"MOVBU",	LMOV, AMOVBU,
"MOVH",		LMOV, AMOVH,
"MOVHU",	LMOV, AMOVHU,
@

[[MOV]]s take a new kind of operand, [[gen]], which
is very general (hence the name). [[gen]] accepts
(as we will see later in Section~\ref{sec:operands-grammar})
registers, constants, but also many forms of memory references
such as the indirect with offset addressing mode in [[4(R1)]]:

<<inst rule(arm)>>=
/*
 * MOVW
 */
| LMOV cond gen ',' gen { outcode($1, $2, &$3, R_NONE, &$5); }
@

Note that even if the grammar rule above is very general,
allowing to write things like [[MOVW (R13), 6(R2)]],
the linker [[5l]] will actually not accept those instructions
and report an error at linking time.
\l a bit ugly
Indeed, the linker will force the programmer to decompose the preceding
instruction in two simpler instructions,
which are then closer to the [[LDR]] and [[STR]] machine instructions
of the ARM:

\begin{verbatim}
MOVW (R13), R1 // =~ LDR
MOVW R1, 6(R2) // =~ STR
\end{verbatim}

This is why in the [[helloworld.s]] program 
in Section~\ref{sec:hello-program} we wrote code like:
\begin{verbatim}
MOVW $'W', R1        
MOVB R1, 6(R2) // can not write MOVB $'W', 6(R2) directly
MOVW $'o', R1        
MOVB R1, 7(R2) // can not write MOVB $'o', 7(R2) directly
\end{verbatim}

Because [[MOVW]] is anyway a virtual instruction, one could wonder
why the linker, instead of reporting an error,
could not generate automatically the multiple [[LDR]] and [[STR]]
instructions which are needed. 
After all, [[5l]] transforms already certain Asm5 
virtual instructions such as [[DIV]] or [[MOD]]
in multiple machine instructions as we will see in the \book{Linker}.
\l maybe simply because cc didn't need it?
%
My guess is that even though virtual instructions allow
to abstract certain peculiarities (separate [[LDR]] and [[STR]] instructions),
hide certain optimisations (code generated for leaf functions for [[TEXT]]
and [[RET]]), or
overcome certain limitations (no [[DIV]] and [[MOD]]), 
an assembly language should still try to mimic as closely
as possible the instructions of a machine.
By being forced to decompose and so to write two 
instructions in the example above, it is arguably
easier for the programmer then to evaluate the number of cycles
a procedure will take, or the number of memory references the procedure
performs, by just counting lines.
\l exact? fixed number of cycle in ARM?
\l See optab possibilities for AMOVW in Linker.nw
\l there is mo pointer arithmetic though, for MOVW it is also raw B plus O

\t MOV fundamental for C. Record access, array access, var access,
% ultimately is a MOV with possibly complex address computation before,
% or for record can just base + offset for var + fld_offset.

\subsubsection{Swaps}
\l mv in advanced topics? what I did for Machine.nw?

Memory/register swaps come also in different variants
depending on the size of the memory swapped:

<<[[Opcode]] cases, swap opcodes>>=
ASWPW,
ASWPBU,
@
<<[[itab]] elements>>=
"SWPW",		LSWAP, ASWPW,
"SWPBU",	LSWAP, ASWPBU,
@
\l why only those variants? why not SWPB? SWPH?

<<inst rule(arm)>>=
/*
 * SWAP
 */
| LSWAP cond reg ',' ireg         { outcode($1, $2, &$5, $3.reg, &$3); }
| LSWAP cond ireg ',' reg         { outcode($1, $2, &$3, $5.reg, &$5); }
| LSWAP cond reg ',' ireg ',' reg { outcode($1, $2, &$5, $3.reg, &$7); }
@
%$

The operand [[ireg]] stands for indirect register and
will be described later.
Here are a few examples of swapping instructions:

\begin{verbatim}
SWPW  R1, (R2)
SWPW (R1), R2
SWPW R1, (R2), R3
\end{verbatim}

The point of [[SWPW]] may not be obvious. 
Why do we need such an instruction?
[[SWPW]] is very useful though
because the instruction is guaranteed to be {\em atomic} in
the presence of multiple processors.
With multipe processors, each processor has its own set
of registers but the processors share the same memory.
One can use this shared memory then as a way synchronize
processors.
[[SWPW]] is the foundation to build concurrency
primitives. For instance the {\em test-and-set}
function in \plan in [[lib_core/libc/arm/tas.s]] is
using [[SWPW]].
\l x86 XCHG
\l ref to other book?


\subsection{Control flow}
\n was Branching but better control flow I think

\l have seen arith, memory, but control flow is fundamental

%toc: %compiler:
The control flow constructs of Asm5 are in
direct correspondance with certain C constructs:
inconditional jump with [[goto]],
conditional jump with [[if]],
branch and link with function call [[x()]] and [[return]].

\subsubsection{Jump (inconditional)}

The most basic control flow instruction of Asm5 is the direct jump, called
{\em branch} in the ARM, hence the [[B]] below:

<<[[Opcode]] cases, branching opcodes>>=
AB,  // =~ JMP
@
<<[[itab]] elements>>=
"B",		LBRANCH, AB,
@

The operand of a branch is either
an offset to the PC pseudo-register (e.g. [[B 4(PC)]]), or 
a label (e.g. [[B later]]), 
via the [[rel]] (register or label) non-terminal below, or
\l D_BRANCH
a name/symbol (e.g. [[B foo(SB)]]) or finally
an indirect register (e.g. [[B (R3)]]), 
via [[nireg]] (name or indirect register) below:
\l D_OREG

<<inst rule(arm)>>=
/*
 * B/BL
 */
| LBRANCH cond rel   { outcode($1, $2, &nullgen, R_NONE, &$3); }
| LBRANCH cond nireg { outcode($1, $2, &nullgen, R_NONE, &$3); }
@
\l could MOV, modify R15 also?
\t inline nireg here? not used elsewhere

%compiler:
It is easy to implement loops using [[B]].
The [[helloworld.s]] program in Section~\ref{sec:hello-program} 
contains one (stupid) loop.
%trans:
To not loop infinitely though one needs a way
to escape the loop and jump elsewhere {\em if}
a certain criteria is true.

\subsubsection{Conditional jump and comparisons}
\label{sec:conditional-jump}
\n was actually part of arithmetic in Machine.nw
% but kinda make sense to put it here instead.

%trans:
The [[helloworld.s]] program in Section~\ref{sec:hello-program} 
did not contain any conditional jump. 
Indeed, printing [["hello world"]] is too simple; there
was no need for such an instruction. 
In the same way, there was also no need for an [[if]] 
in the corresponding [[helloworld1.c]] C program.
%turing:
The conditional jump though is a fundamental instruction.
Without it programs would be just long sequences of instructions 
or infinite loops.
\n even BL would not help because BL is almost like a B

The conditional jump instruction is usually preceded
by a {comparison} instruction.
The following opcode allows to ``compare'' two operands in Asm5:

<<[[Opcode]] cases, comparison opcodes>>=
ACMP,
@
<<[[itab]] elements>>=
"CMP",		LCMP,	ACMP,
@
<<inst rule(arm)>>=
/*
 * CMP
 */
| LCMP cond imsr ',' regi { outcode($1, $2, &$3, $5, &nullgen); }
@
%$

Note that despite its name, this instruction does not really 
compare its two operands. Instead, it loads those two operands
in some internal registers of the processor.
Those internal registers can then be used by the instruction
coming just after, for instance a conditional jump, to actually compare
using different {\em relational operators} those registers
and jump accordingly:
\l so actually one compare instr and many conditional jump instrs

<<[[Opcode]] cases, branching opcodes>>=
/* 
 * Do not reorder or fragment the conditional branch 
 * opcodes, or the predication code will break 
 */ 
// VIRTUAL, AB derivatives with condition code, see 5i/
ABEQ, // ==
ABNE, // !=
ABHS, // >= unsigned
ABLO, // <  unsigned
ABMI, // ??
ABPL, // ??
ABVS, // ??
ABVC, // ??
ABHI, // >  unsigned
ABLS, // <= unsigned
ABGE, // >=
ABLT, // <
ABGT, // >
ABLE, // <=
//ABAL (always) done via AB
//ABNV (never) done via ANOP (see bcode[])
@
\t what are the ????
\t explain the unsigned!
\n match closely things in Machine.nw
%old: got rid of ABCS and ABCC, seems redundant
% and does not match the ARM convention
% ABCS,//not in 5i/cond, seems equivalent to ABHS
% ABCC,//not in 5i/cond, seems equivalent to ABLO
<<[[itab]] elements>>=
"BEQ",		LBCOND,	ABEQ,
"BNE",		LBCOND,	ABNE,
"BHS",		LBCOND,	ABHS,
"BLO",		LBCOND,	ABLO,
"BMI",		LBCOND,	ABMI,
"BPL",		LBCOND,	ABPL,
"BVS",		LBCOND,	ABVS,
"BVC",		LBCOND,	ABVC,
"BHI",		LBCOND,	ABHI,
"BLS",		LBCOND,	ABLS,
"BGE",		LBCOND,	ABGE,
"BLT",		LBCOND,	ABLT,
"BGT",		LBCOND,	ABGT,
"BLE",		LBCOND,	ABLE,
@
\l but really you need just = and <, rest can be done with inversing, EORR, etc.

<<inst rule(arm)>>=
/*
 * BEQ/...
 */
| LBCOND rel { outcode($1, Always, &nullgen, R_NONE, &$2); }
@
\l no nireg here?

Here is an example of a comparison and conditional jump:

\begin{verbatim}
    CMP $0, R1
    BEQ r1_is_zero
    B r1_is_nonzero 
r1_is_zero:
    // R1 == 0
    ...
    B after
r1_is_nonzero:
    // else
    ...
    // fallthrough
after:
    ...
\end{verbatim}

%compiler:
All the control flow constructs of C ([[if]], [[while]], [[for]], etc)
can be translated in assembly code using simply labels, branchs,
and conditional jumps.
%FIGURE? control flow diagrams translation with edges?

The [[B]]$xx$ Asm5 instructions are actually virtual instructions.
Similar to the bitshift operations vs the shifted-registers,
the ARM provides a more
general approach to conditional jump where {\em every instruction
can be conditionally executed} as explained later in
Section~\ref{sec:cond-exec}.
The opcodes above are thus translated by [[5l]] in the [[B]] ARM instruction
with special bits set to mark the instruction for conditional execution.
%
Similar to the bitshift operations, Asm5 provides
those specialised virtual instructions jumps because
they correspond more to what assembly programmers
(or compiler writers)
\n probably the reason, to make code of 5c more similar to 8c/vc/...
expect from an assembly language.



There are a few additional Asm5 comparison opcodes similar to
[[CMP]] mimicing ARM instructions, but they
are less useful. Some of them again are not even used by [[5c]]:

<<[[Opcode]] cases, comparison opcodes>>=
ATST,
ATEQ,
ACMN, // CMP negative
@
<<[[itab]] elements>>=
"TST",		LCMP,	ATST,
"TEQ",		LCMP,	ATEQ,
"CMN",		LCMP,	ACMN,
@
\l CMN uses a bit to optimize


\subsubsection{Function call and return}

%turing:
The [[B]], [[CMP]], and [[B]]$xx$ instructions
are enough to have a {Turing complete} machine.
There is no need for a function call instruction; it
would not add any expressivity to the computer.
%
In fact, there is no [[CALL]] or [[RET]] instruction in the ARM,
but instead a very basic [[BL]] instruction.
%dup: from overview/hello/funcall
As explained in Section~\ref{sec:bl}, [[BL]] stands
for {\em branch and link} because the instruction just
saves the current value of the program counter ([[R15]])
in a special {\em link register} ([[R14]]), and then branch/jump:
\n should be called link and branch then
\l why called link? because it create a link with the caller?

<<[[Opcode]] cases, branching opcodes>>=
ABL, // =~ CALL, Branch and Link
@
<<[[itab]] elements>>=
"BL",		LBRANCH, ABL,
@

The [[BL]] instruction uses the same syntax than
[[B]] and so use the same grammar rule
involving the [[LBRANCH]] token name.
Indeed, [[BL]] is really just a slightly different [[B]].
%
But, [[BL]] performs in one instruction something which can
be used as a building block for organizing code into functions.
Indeed, by using [[BL]], the link register [[R14]],
the stack pointer [[R13]], and symbols defined by [[TEXT]], one can easily
simulate functions, function calls, and [[return]]
as explained in Sections~\ref{sec:bl} and~\ref{sec:ret}.

%turing:
From a theoretical computer science point of view,
functions do not add any expressivity to the machine
language, but from a software 
engineering perspective they are tremendously useful.
Indeed, with functions one can decompose a big program 
in multiple independent parts which can be programmed
and understood in isolation.
%
Because those functions though must use and share the same
machine registers, one needs to setup some {\em conventions}
on how to use and {\em save} those registers so that code of one
function can be programmed independently of the code of 
another function.
%
In \plan the convention is as follows: ``a subroutine is responsible
for saving its own registers, and therefore is free to use
any registers without saving them''. 
\n from asm.pdf
This convention is also known as ``caller saves''. 
%
This means that if the body of a function [[foo]] uses the register [[R1]],
and then must call another function [[bar]]
(with [[BL bar(SB)]]), then [[foo]] must save
the register [[R1]] somewhere if it plans to use its value
after the call to [[bar]], because [[bar]] could have overwritten
the value in [[R1]].
%
The stack is usually used to save the values in those registers.

%dup: from overview/hello/call-stack
One needs also to setup {\em calling conventions} on how
to pass arguments and use paramter in functions.
In \plan the stack and [[R0]] are
used to pass the arguments as explained in Section~\ref{sec:call-stack}.
%compiler:
By using the stack and not fixed memory locations,
functions can be called recursively.

%FIGURE? show recursive calls?

Asm5 provides the virtual instruction [[RET]] to make it
easier for the programmer to manage the stack when returing
from a function. Indeed, [[RET]] abstracts
away the differences between leaf and non-leaf functions
as explained in Section~\ref{sec:ret}:

<<[[Opcode]] cases, branching opcodes>>=
ARET, // VIRTUAL, transformed in B (R14) or MOV xxx(SP), R15
@
<<[[itab]] elements>>=
"RET",		LRET, ARET,
@
<<inst rule(arm)>>=
/*
 * RET
 */
| LRET cond { outcode($1, $2, &nullgen, R_NONE, &nullgen); }
@
\n we will see in 5l STEXT and SLEAF


\subsection{Software interrupt}
\l aka syscall
\l interrupts and exceptions

The software interrupt instruction [[SWI]] is really a form of
function call but to a fixed special code area setup by the kernel,
which is why it does not take any operand:
\l interrupt table normally? so take an argument. In ARM there is an argument.

<<[[Opcode]] cases, interrupt opcodes>>=
ASWI, // syscall
@
<<[[itab]] elements>>=
"SWI",		LSWI, ASWI,
@

<<inst rule(arm)>>=
/*
 * SWI
 */
| LSWI cond { outcode($1, $2, &nullgen, R_NONE, &nullgen); }
@
%old: | LTYPE6 cond comma gen { outcode($1, $2, &nullgen, R_NONE, &$4); }
% but not sure it needs an argument in plan9 context,
% and anyway was doing stupid things like SWI 0  in 9syscall/mkfile
% which was weird, at least should be SWI $0
%old:
%<<inst rule(arm)>>=
%| LSWI cond gen { outcode($1, $2, &nullgen, R_NONE, &nullgen); }
%@
%%$
%% just so can test things with kencc/5a, ignore actually the last argument
%% otherwise the linker will fail.

%kernel:
[[SWI]] is the fundamental building block for having a
kernel program clearly separated from user programs. It provides
a safe way to go from user program to kernel code via the system
call API bridge.
\l open then the door for user process to access real hardware
% (but in supervised mode of course)

Asm5 provides also the virtual instruction [[RFE]] to return
from kernel code to a user program. [[RFE]] is actually just
a short alias to the more cryptic [[MOVM]] instruction
we will describe in Section~\ref{sec:movm}.

<<[[Opcode]] cases, interrupt opcodes>>=
ARFE, // VIRTUAL, return from exception/interrupt, MOVM.IA.S.W (R13), [R15]
@

<<[[itab]] elements>>=
"RFE",		LRET, ARFE,
@
% same grammar rule than RET
% =~ IRET
%in lproc.s 
%	RFE				/* MOVM.IA.S.W (R13), [R15] */



\section{Label definitions and [[pc]]}
\label{sec:label-def}
\n put after Operands? Merge with Code refs? maybe better after Instruction
\n section as it is a kind of instr, and better have all opds in one section

Labels allow to give symbolic names to code addresses.
\l it's one way, symbols are another.
They are a fundamental
feature of any assembly language and makes assembly code significantly
easier to understand and maintain.
%compiler:
Indeed, by using label names such as 
[[_loop1]], [[if_zero]], or [[_else]], assembly code using 
jumps (conditional or inconditional) can become closer
to C code using statements such as [[for]] or [[if]].
%
Labels in Asm5 are defined on a line by using an identifier 
followed by a colon:

<<line rule(arm)>>=
| LNAME ':'
 {
  $1->type = LLAB;
  $1->value = pc;
 }
  line
@
\t what for changing the type? for detection of duplicate!

Even though one could have multiple label definitions on a line,
or even labels and machine instructions on the same line, it is
a common practice to put the label definition alone on its own line,
in the first column.

The value of a label is the value of the {\em virtual program counter}
at the label definition. This counter
is stored in the global [[pc]], initialized to 0 before
each pass and incremented by [[outcode()]] after each code instruction:
\l (except for ADATA and AGLOBL)
\l even ATEXT increments PC? hmm maybe simpler that way
<<global pc>>=
long	pc;
@
<<[[pinit()]] initialisations>>=
pc = 0;
@

Once a label has been defined, the code of its
token in the symbol table is changed to [[LLAB]]
\footnote{This means Yacc actions actually have a side effect on how
the lexer behaves. Asm5 is thus not a context free grammar.
This is similar to C where typedefs declarations change
the token code of certain identifiers.
}
\t why need that for LLAB? why need to make it a special token? 
\t grammar ambiguity? NO just to do the redeclaration detection!
\t also can have func and label with same name? I don't think so
\t because then it's a label for the rest of the file!
%  with suffixing with (SB)
as shown in the rule above.
Further use of this label in the rest of the program
or in the next assembling pass will trigger then this rule:

<<line rule(arm)>>=
| LLAB ':'
 {
  if($1->value != pc) {
   yyerror("redeclaration of %s", $1->name);
   $1->value = pc;
  }
 }
  line
@
%$
%ocaml: no need special token and parser/lexer coop. Just postparsing resolve()

Note that there is no use of [[outcode()]] here because labels
can be fully resolved by the assembler. There is no need
to keep them in the object file.

\section{Operands}
\label{sec:operands-grammar}
\label{sec:imsr}
\n =~ expressions

%trans:
Now that we have seen the major opcodes and instructions of Asm5, we
can switch to explain the operands of those instructions.
%
The first non-terminal corresponding to an operand we saw in this chapter
was [[imsr]], the first operand of opcodes such as [[AADD]] or [[AORR]]:

<<operand rules(arm)>>=
imsr:
  imm
| shift
| reg
@

%toc:
The next three subsections will each cover one of the [[imsr]] alternatives.

Rules which return values (in \$\$) must have their type declared
in Yacc via a [[%type]] directive.
Most operand rules have the [[genval]] type:
%ocaml: no need, type inference!

<<type declarations(arm)>>=
%type   <genval> imsr
%type   <genval> imm shift reg
@
\l until now no type for inst, because does not return, call outcode.

In fact [[genval]] is not really a type
but the name of one of the field of the Yacc [[%union]]
declaration described partially in Section~\ref{sec:token}:

<<union declaration other fields(arm)>>=
Gen    genval;
@
%old: was gen, but then confusing with the gen rule, and more consistent genval
\t genval -> oval once have Gen -> Operand

The type of [[genval]] is [[Gen]], the
generalized form of operand we described in Section~\ref{sec:operand}.
%
Thanks to those [[%type]] and [[%union]] Yacc directives,
the generated code by [[yacc]] for the \$$n$
referring to non-terminals will access the appropriate field of 
the union. 
%
In the same way, the [[%token]] and [[%union]] Yacc
directives will guide [[yacc]] to generate the right code
for the \$$n$ refering to terminals (the tokens).

The [[gen]] operand rule, specifying the operands of [[MOVW]], 
has the same type:

<<type declarations(arm)>>=
%type   <genval>   gen 
@
%old: was %type   <gen>   gen, but confusing

<<gen rule>>=
gen:
  ximm
| shift
| reg
@

For now [[gen]] is almost identical to [[imsr]], 
except for the [[ximm]] (extended immediate) vs [[imm]] which we will
explain soon, but we will see later also extensions to the [[gen]] rule.

<<type declarations(arm)>>=
%type   <genval>   ximm
@



\ifallcode
<<operand rules(arm)>>=
<<gen rule>>
<<regi rule(arm)>>
<<ximm rule>>
@
%old: <<oreg rule>>
%old: <<regi_nosp rule(arm)>>
\fi


\subsection{Registers}

%<<operand_kind cases>>=
%D_REG,
%@

Most Asm5 instructions can take one, two, or even three
registers as operands.
%
The [[reg]] rule below allows to wrap in a [[Gen]]
the integer representing the register number.
It uses the [[D_REG]] {\em operand kind} we described
in Section~\ref{sec:operand}:

<<operand rules(arm)>>=
reg:
 regi
 {
  $$ = nullgen;
  $$.type = D_REG;
  $$.reg = $1;
 }
@
%$

[[regi]] (register integer) returns directly the register number:

<<type declarations(arm)>>=
%type   <lval>  regi
@
%old: was called spreg, but prefer regi
\l lval but really enum<registr>


<<regi rule(arm)>>=
regi:
  LREG
@
%old: was called sreg, but prefer regi_nosp, why was called sreg? simple reg?
\l implicit $$ = $1 %$

<<[[itab]] elements>>=
"R0",		LREG,	0,
"R1",		LREG,	1,
"R2",		LREG,	2,
"R3",		LREG,	3,
"R4",		LREG,	4,
"R5",		LREG,	5,
"R6",		LREG,	6,
"R7",		LREG,	7,
"R8",		LREG,	8,
"R9",		LREG,	9,
"R10",		LREG,	10,
"R11",		LREG,	11,
"R12",		LREG,	12,
"R13",		LREG,	13,
"R14",		LREG,	14,
"R15",		LREG,	15,
@

Asm5 allows also the [[R(xx)]] syntax to specify a register:

<<[[itab]] elements>>=
"R",		LR,	0,
@
\l note that different from pseudo register!

<<regi rule(arm)>>=
| LR '(' expr ')'
 {
  if($3 < 0 || $3 >= NREG)
      print("register value out of range\n");
  $$ = $3;
 }
@
%$
\l expr! see later

This feature can be useful when combined with the symbolic constant
feature of Asm5, as shown in Appendix~\ref{sec:_divmod}.
One can achieve a similar effect though by using simply macros.


%old: intermediate not needed anymore once got rid of virtual reg in regi.
%type   <lval>  regi regi_nosp
%<<regi rule(arm)>>=
%regi:
%  regi_nosp
%@
%<<regi_nosp rule(arm)>>=
%| LPC { $$ = REGPC; }
%@
%<<regi rule(arm)>>=
%| LSP { $$ = REGSP; }
%@
%$
% here it was actually hardware registers which I think is confusing
% so I removed those rules.
% Anyway people can use R13 to encode SP and R15 for PC so why
% not have a simple reg rule that allows all those registers directly!
% In which context we don't accept LSP? in which context we don't accept LPC?

\subsection{Immediate constants}

%<<operand_kind cases>>=
%D_CONST,
%@

Many instructions can take a register or an (immediate) constant
as their first operand.
%turing:
This is pretty fundamental of course.
%
All constants in Asm9 are prefixed with a dollar:
\l why? ambiguity with what? 
\l to differentiate with just con where it's a omem (see section below)

<<operand rules(arm)>>=
imm: '$' con
 {
  $$ = nullgen;
  $$.type = D_CONST;
  $$.offset = $2;
 }
@
\l con = constant
\t use lval here instead of offset

<<con rule>>=
con:
  LCONST
| '-' con      { $$ = -$2; }
| '+' con      { $$ = $2; }
| '~' con      { $$ = ~$2; }
@
%$
\n con extended later as expr

Note that the ARM uses fixed-length instructions of 32 bits.
%
Because a few of those 32 bits are used to encode the opcode 
and a few more to encode the other operands, the range
of the Asm5 constants is limited.
For the arithmetic instructions, only 12 bits of the instruction
can be used for the
constant, so in theory only constants between 0 and 4096
could be represented. 
\l and for the other instructions? for STR and LDR?
%
But, the ARM uses a clever trick
and those 12 bits are actually divided in two parts:
8 bits for a constant, and 
4 bits for a {\em rotation} of this constant. 
\n a bit different from the bitshifted registers we will see later, but related
Not all 32 bits integers can be represented
using that scheme but many important numbers like all
the powers of 2 between 0 and 31 can be expressed, which
\n 4 bits so 16 shift + 8 bits for constant, not enough for all power? Yes,
\n see url below, 4 bits rotation is special too!
is very useful in operations involving bitsets or bitmasks.
See the \book{Emulator} for more information
or \url{http://alisdair.mcdiarmid.org/arm-immediate-value-encoding/}
which is an excellent tutorial on the topic.
\l also linker book
\l "so you can set, clear, or toggle any bit with one instruction"

[[MOV]]s instructions, which use the [[gen]] non-terminal
as operand, which derives [[ximm]], can also take a constant as an
operand:

<<ximm rule>>=
ximm:
  '$' con
 {
  $$ = nullgen;
  $$.type = D_CONST;
  $$.offset = $2;
 }
@
\l also for DATA, WORD
\l and range for LDR/STR for the immediate constant?

%\subsection{String constants}
%<<operand_kind cases>>=
%D_SCONST,
%@

In fact, even string constants are possible operands of [[MOV]]s:
\n see later also float

<<ximm rule>>=
| '$' LSCONST
 {
  $$ = nullgen;
  $$.type = D_SCONST;
  memcpy($$.sval, $2, sizeof($$.sval));
 }
@

For those cases the constant itself can not be encoded
in 32 bits though. The address of the string,
which will become an integer constant after linking,
will be used instead in the generated ARM instruction.
\l kinda automatic GLOBL/DATA done by linker
\l related to $symbol(SB) %$ which also become an integer constant

\subsection{Shifted registers}
\label{sec:shift-register}
\l mv in advanced topics?

%dup: from parsing/instr/bitshift
As mentioned in Section~\ref{sec:bitshift-opcodes},
in addition to the (virtual) instructions [[SLL]], [[SRL]], and [[SRA]], 
Asm5 gives access to the ARM generalized approach to bitshift
by allowing to use {\em shifted registers} as operands of many 
arithmetic instructions:
\l many or all?

<<operand rules(arm)>>=
shift:
 regi '<' '<' rcon
 {
  $$ = nullgen;
  $$.type = D_SHIFT;
  $$.offset = $1 | $4 | (0 << 5);
 }
| regi '>' '>' rcon
 {
  $$ = nullgen;
  $$.type = D_SHIFT;
  $$.offset = $1 | $4 | (1 << 5);
 }
| regi '-' '>' rcon
 {
  $$ = nullgen;
  $$.type = D_SHIFT;
  $$.offset = $1 | $4 | (2 << 5);
 }
| regi LAT '>' rcon
 {
  $$ = nullgen;
  $$.type = D_SHIFT;
  $$.offset = $1 | $4 | (3 << 5);
 }
@
%ocaml: ugly to encode so much stuff in offset
\l argh, offset really abused, should use shift here
%self-ref:
\l use bitshift op in the code to handle bitshift, also use bitwise |, 

This combines a register (a [[D_REG]]) and an immediate constant
(a [[D_CONST]]) in a new kind of operand:
\n in fact can be two D_REG rcon is register or con

<<[[Operand_kind]] cases>>=
D_SHIFT,
@

One can then use an opcode like [[ADD]] while at the same time
doing a shift operation on one of the register 
in one single instruction
(which opens many optimisations opportunities in the C compiler [[5c]]):
\begin{verbatim}
ADD R1 << 8, R2, R3
\end{verbatim}

Note that [[Gen.offset]] is used to encode the whole operand value
\footnote{One could use [[Gen.reg]] and [[Gen.offset]] instead}:
the first 4 bits (bits 0 to 3) are used for the register number (0 to 15),
bits 5 and 6 are used to encode the kind of shift, e.g. [[0 << 5]]
for a left shift, and bits 7 to 11  to encode either a small immediate constant
or another register via [[rcon]] (register or constant) below.
\n so a bit different from the imm rotate we saw before which uses 4 bits

<<type declarations(arm)>>=
%type   <lval>  rcon
@

<<helper rules(arm)>>=
rcon:
  regi
 {
  if($$ < 0 || $$ >= NREG)
      print("register value out of range\n");
  $$ = (($1&15) << 8) | (1 << 4);
 }
| con
 {
  if($$ < 0 || $$ >= 32)
      print("shift value out of range\n");
  $$ = ($1&31) << 7;
 }
@
\l really does too much work here and close to ARM concrete bits
%ocaml: ugly to encode so much stuff in offset

The tricky [[Gen.offset]] encoding for bitshifted registers
reflects how such operands are actually encoded in the binary
format of ARM instructions.
%

In addition to the [[<<]] and 
[[>>]] logical shift operators, Asm5 provides
the [[->]] operator for right shift arithmetic
and [[@>]] for right rotate.
Again, see the \book{Emulator} for more information.
Because [[@]] can be part of an identifier in Asm9, a special
entry in [[itab]] had to be used to represent the single character:

<<[[itab]] elements>>=
"@",		LAT,	0,
@
\l could remove @ from the identifier lexing section,
\l so then could just do '@' '>' instead of this indirection
%ocaml: ugly to allow @ in identifiers
\l At for Arithmetic?


\subsection{Memory (de)references, pointers}
\l indirect addressing?

%trans:
We have seen the three components of the [[imsr]] operand rule
used in arithmetic instructions:
the immediate constant, the shifted register, and the register.
\l Those are actually possible operands for other ARM instructions.
%toc:
We will now focus on the [[MOVW]] instruction and its [[gen]]
operand which is even more general (hence the name).
%dup: from overview/input-lang
Section~\ref{sec:ref-addressing-modes} listed the different
ways to reference memory in Asm5, the different {memory addressing modes},
for instance ``indirect with offset'' in [[4(R1)]].

This is where we start to deviate from [[imsr]] in [[gen]]
(in addition to the [[ximm]] vs [[imm]] difference):
<<gen rule>>=
| ioreg
@
%old: was oreg above
%old: oreg is an intermediate rule which we do not need anymore
%<<gen rule>>=
%| oreg
%@
%<<oreg rule>>=
%oreg:
%  ioreg
%@


%<<operand_kind cases>>=
%D_OREG,
%@

[[ireg]] (indirect register) allows to dereference a pointer
stored in a register. [[ioreg]] (indirect offset register) 
adds an offset to the memory address in the register.
Both are using the [[D_OREG]] operand kind introduced in 
Section~\ref{sec:operand}:

<<type declarations(arm)>>=
%type   <genval> ioreg ireg
@

<<operand rules(arm)>>=
ioreg:
  ireg
| con '(' regi ')'
 {
  $$ = nullgen;
  $$.type = D_OREG;
  $$.reg = $3;
  $$.offset = $1;
 }
@
\l could inline in gen, but MOVM use ioreg directly
%old: was regi_nosp here
\t how offset encoded in instruction? what if outside range?
\t remember that MOVW is a virtual instruction. LDR/STR are different.

<<operand rules(arm)>>=
ireg:
 '(' regi ')'
 {
  $$ = nullgen;
  $$.type = D_OREG;
  $$.reg = $2;
  $$.offset = 0;
 }
@
%$
\n could inline in ioreg, but swap use ireg directly




\subsection{Named memory locations, symbols}
\label{sec:name-rule}
\l and pseudo-registers
\n different from labels, which are just for code refs

One can also use symbols (names) to reference memory in Asm5:

<<gen rule>>=
| name
@
%old: inlined in gen now
%<<oreg rule>>=
%| name
%@
\l but actually not just a name really, there can be an offset

<<type declarations(arm)>>=
%type   <genval>   name 
%type   <lval>  offset
%type   <lval>  pointer
@

<<name rule>>=
name:
  LNAME offset '(' pointer ')'
 {
  $$ = nullgen;
  $$.type = D_OREG;
  $$.sym = $1;
  $$.symkind = $4;
  $$.offset = $2;
 }
@
%$
\l name is an operand for BL (via nireg), for TEXT, and for MOV

Note that symbol operands use the same operand kind [[D_OREG]]
than the indirect register with offset we have seen above.
This is because a name can also be seen as a sort of offset to 
one of the (pseudo) register we have seen in 
Section~\ref{sec:pseudo-registers}
(except [[PC]]):
\l PC is used only in one context, for jump, which we will see later
\l but actually before it was used maybe in regi_nosp

<<helper rules(arm)>>=
pointer:
  LSB
| LSP
| LFP
@
\n hmmm bad name? pointer_basis? but it's true we do '(' pointer ')'
\n where we really dereference the pointer (and then add an offset)
\t what is generated code by linker? address of symbol is really offset? R12?

<<[[itab]] elements>>=
"SB",		LSB,	D_EXTERN,
"SP",		LSP,	D_LOCAL,
"FP",		LFP,	D_PARAM,
@
%<<sym_kind cases>>=
%D_EXTERN, // text/data/bss values (from SB)
%D_LOCAL,   // stack values (from SP)
%D_PARAM,  // parameter (from FP)
%@

Note that for locals and parameters the symbol name is
not really necessary, which is why one can also reference
parameters only with an offset, as in [[MOVW 4(FP), R1]]:

<<gen rule>>=
| con '(' pointer ')'
 {
  $$ = nullgen;
  $$.type = D_OREG;
  $$.sym = S;
  $$.symkind = $3;
  $$.offset = $1;
 }
@
%$
%ocaml: make sense to have anon with SB??
%old: was in name rule, but better in gen rule I think, it is not really a name
\n could delete that too? hmm no, it's for anonymous params like 4(FP)
\n the con (pointer) of 'name:' is not ambiguous with the con (sreg)
% of 'oreg:'? no because pointer != sreg (well even if R12 is actually LSB ...)
\l can also do 4(SB)? useful?

%dup: from overview/input-language
The use of symbols for locals and parameters can be useful though as comments,
as in [[MOVW  count+4(FP), R1]].
\t again what is the generated code by linker?
The symbol name is also kept in the symbol table of the object file
as we will see in Chapter~\ref{chap:generating}
which can be leveraged later by tools like debuggers
as we will see in Chapter~\ref{chap:debugging}.


The name/``offset'' can also have an aditional offset applied
to it:

<<helper rules(arm)>>=
offset:
 /* empty */ { $$ = 0; }
| '+' con    { $$ = $2; }
| '-' con    { $$ = -$2; }
@
%$
\l rename offset_opt?

\t explain more FP here, frame pointer, which really is SP,
\t and EBP in x86. Or explain that in Linker.nw?
%real world: -fomit-frame-pointer! no need save SP in the stack!
\n fomit-frame-pointer
\n but then harder to walk the stack!
\n can statically know when do RET what you allocated already,
\n can restore old SP easily.



Using a [[name]] as part of a [[MOVW]] implicitly means
a pointer dereference to access the value at the address
denoted by the symbol, e.g. [[MOVW foo(SB), R1]].
To get the address of the symbol
itself one needs to prefix the name with a dollar,
e.g. [[MOVW $foo(SB), R1]]. %$
This is where [[ximm]] deviates from [[imm]]:

<<ximm rule>>=
| '$' name
 {
  $$ = $2;
  $$.type = D_CONST;
 }
@
%old: was $ oreg, but i think it makes more sense to have just '$' name
\l a special D_ADDR instead of abusing D_CONST?
\l a bit confusing that can have gen -> oreg, and also gen -> ximm -> $ oreg
%$
\l why not allowed in imm too? after all it can be computer statically

%trans:
Note that the [[name]] non-terminal can also be the operand
of the [[TEXT]] pseudo-instruction as we will see soon,
in which case it defines the symbol.


%section{Static names?, local names?}

Asm5 provides also a way to use {\em local} (a.k.a static)
symbols for globals and procedures
in a file by suffixing the name with angles:

<<name rule>>=
| LNAME '<' '>' offset '(' LSB ')'
 {
  $$ = nullgen;
  $$.type = D_OREG;
  $$.sym = $1;
  $$.symkind = D_INTERN;
  $$.offset = $4;
 }
@
%$

<<sym_kind cases>>=
D_INTERN, // data static variables (from SB)
@
%old: was D_STATIC but ugly C name

Those names will not be visible outside the file, but they
will also not conflict with identical names in other files.








Branching instructions can also jump to symbols via 
the [[nireg]] operand rule,
as well as the address contained in registers:

<<type declarations(arm)>>=
%type   <genval>   nireg 
@

<<operand rules(arm)>>=
nireg:
  name
| ireg
@
\t could inline in parent
%$
\l for BL, in addition to rel, can also have nireg
%old: had a if with nothing in it, weird
%  name
% {
%  $$ = $1;
%  if($1.name != D_EXTERN && $1.name != D_STATIC) {
%  }
% }

% BL ireg means have no idea where it jmps ... can this
% create bugs in 5l that statically tries to find the necessary code?
% well the address of a function should be taken somewhere so
% the function should be considered unless one does really crazy
% magic stuff.




\ifallcode
<<operand rules(arm)>>=
<<name rule>>
@
\fi

\subsection{Code references, labels}

%trans:
The last operand rule we have to see is
%
one of the operand for branching instructions ([[B]], [[BL]])
called [[rel]] (register or label):

<<type declarations(arm)>>=
%type   <genval>   rel
@
\l rel = ? relocatable? relative? or simply register or label?
% Relative because it's labels which are locals to a file and can be
% resolved locally (no need symbols), but at the same time they will
% also need to be relocated when all objects are attached after each
% other
% update: the offset value is actually not relative to the current PC,
% it's an absolute value, so it probably means more relocatable than
% relative in the end
% update: but one of the rule of rel is actually a relative jump to PC

<<rel rule>>=
rel:
  LLAB offset
 {
  $$ = nullgen;
  $$.type = D_BRANCH;
  $$.sym = $1;
  $$.offset = $1->value + $2;
 }
@
%$
\t sym saved, so can be saved in object file for debugging?

This operand uses a new operand kind:
\l could abuse D_CONST?

<<[[Operand_kind]] cases>>=
D_BRANCH,
@
%old: /* type */ FOR BRANCH

The value for this kind of operands is 
the {resolved} absolute (virtual) code address of
the label. It is stored in [[Gen.offset]].
\l remember that value of label in symbol table is virtual pc at def

\l can use labels defined in other procedures, see _div and _mod with out:

\l no need to relocate  those names (well actually we relocate them in 5l when
% we put each object one after another, see the 'ipc' local variable)

When a label is declared later in a file, the first mention
of this label in an operand in the first pass will trigger
the rule below. Indeed, the symbol table does not know yet
that this identifier is really a [[LLAB]] not an [[LNAME]]:

<<rel rule>>=
| LNAME offset
 {
  $$ = nullgen;
  if(pass == 2)
      yyerror("undefined label: %s", $1->name);
 }
@
%old: if pass == 1 why care about setting the field values?
%  $$.type = D_BRANCH;
%  $$.sym = $1;
%  $$.offset = $2;
% anyway outcode will not use the value

Another way to reference code is to add an offset
to the virtual program counter [[PC]], allowing
to make {\em relative jumps} (even though this is transformed
in an absolute (virtual) code address thanks to [[pc]]):
\l explain virtual code address, incremented by 1, same dimension than pseudo PC

<<rel rule>>=
| con '(' LPC ')'
 {
  $$ = nullgen;
  $$.type = D_BRANCH;
  $$.offset = $1 + pc;
 }
@
%$
\l con(PC) is not really named code

<<[[itab]] elements>>=
"PC",		LPC,	D_BRANCH,
@
\l no really need D_BRANCH here now.



\ifallcode
<<operand rules(arm)>>=
<<rel rule>>
@
\fi




%\subsection{Other operands}

%old:
%<<operand_kind cases>>=
%D_OCONST,
%@
%<<ximm rule>>=
%| '$' '*' '$' oreg
% {
%  $$ = $4;
%  $$.type = D_OCONST;
% }
%@
%%$
% seems unused in ARM/*.s


%old:
%<<gen rule>>=
%| con
% {
%  $$ = nullgen;
%  $$.type = D_OREG;
%  $$.offset = $1;
% }
%@
%%$
% no $ in front of con here?
% was used in 9syscall for 'SWI 0' but not sure what it meant.
% how can be D_OREG when there are no registers involved.
% I removed the rule, and rewrote calls to SWI to just be SWI

%old:
%<<gen rule>>=
%| shift '(' regi ')'
% {
%  $$ = $1;
%  $$.reg = $3;
% }
%@

%old:
%<<oreg rule>>=
%| name '(' sreg ')'
% {
%  $$ = $1;
%  $$.type = D_OREG;
%  $$.reg = $3;
% }
%@
% but name already has some (sreg), so what this rule mean?
% foo(PC)(PC) ??
% sreg, so can't use FP here, nor LSB, so only name refering to PC?




\section{Pseudo-instructions}

Pseudo-instructions have an opcode and operands, 
just like the other instructions we have seen before, 
but they do not correspond to any machine instruction.
%
This is also true for virtual instructions like [[MOVW]] or [[RET]]
but virtual instructions eventually become machine instructions
after linking.
\n actually TEXT generate some instructions, but the name part does not really
%
Pseudo-instructions on the opposite are assembly-only constructs,
also know as {\em assembly directives}.
It would be more accurate to call them {\em linker directives}
though because they declare things which will be used by the linker
\l or loader for DATA
and which will eventually disappear after linking.
\l or are kept but only for debugger


\subsection{[[TEXT/GLOBL]]}

{Symbols}, for procedures or globals, are {declared}
respectively by the [[TEXT]] and [[GLOBL]] pseudo-instructions
as explained in Section~\ref{sec:pseudo-instructions}:

<<[[Opcode]] cases, pseudo opcodes>>=
ATEXT,
AGLOBL,
@
<<[[itab]] elements>>=
"TEXT",		LDEF, ATEXT,
"GLOBL",	LDEF, AGLOBL,
@
\l it is not really LDEF actually, it's more LDECL

<<inst rule(arm)>>=
/*
 * TEXT/GLOBL
 */
| LDEF name ',' imm         { outcode($1, Always, &$2, R_NONE, &$4); }
| LDEF name ',' con ',' imm { outcode($1, Always, &$2, $4, &$6); }
@
%$

The same non-terminal [[name]] we have seen in Section~\ref{sec:name-rule}
to reference memory via a symbol is used also here to
define a symbol. This is why one needs also to add the
[[(SB)]] suffix in symbol definitions as in [[TEXT _main(SB), $20]].%$
\l no much sense though to allow the offset here, _main _plus_ 4(SB) ??
%
The second operand is an immediate constant which represents a 
size in bytes for the locals of the procedure or for the global
as explained in Section~\ref{sec:pseudo-instructions}.
%
The [[TEXT]] and [[GLOBL]] can also take three operands as 
indicated by the second alternative in the grammar rule above, 
in which case the middle operand is used to encode {\em attributes}
of the entity defined as explained in Section~\ref{sec:attributes}.
%
Note that pseudo-instructions have the same binary format than other Asm5
instructions in the object file, hence the similar use of [[outcode()]]
above in the action.


[[TEXT]] and [[GLOBL]] are pseudo-instructions because 
they give names to procedures and globals
while a machine has no notion of procedure, global, or name. 
Indeed, those names eventually become concrete addresses after linking,
which are really just concrete numbers. Those numbers, not names,
are then used as arguments of machine instructions 
such as [[LDR]] (to access globals), or [[BL]] (to call procedures).

%dup: from ??
Labels are similar to [[TEXT]] symbols but they are not public
and do not have a size. This is because labels are used
for intra-procedural jumps, while [[TEXT]] symbols are used
for public procedures with parameters. 
%
Because labels are local to a file all the references to
a label must be in the same file.
\l actually not local to a procedure
All those references can thus be {resolved} by the assembler
and converted in absolute (virtual) code addresses in the object file.
[[TEXT]] symbols on the opposite are public and may be referenced
by other files which is why they have to be kept in the object file
to be resolved later by the linker.
\l local calls could be resolved by assembler, but redundant

[[TEXT]] pseudo-instructions are used by the linker to put the
code of procedures in the [[Text]] {\em section} of the executable.
[[GLOBL]] are used by the linker to allocate some space in the
[[Data]] {\em section} of the executable.

Note that for procedures, the constant used to represent the size 
of the locals can surprisingly also be [[$-4]].%$
\l ugly a bit
Indeed, as explained in Section~\ref{sec:call-stack}, each
time a procedure is entered
an extra word in the stack is by default allocated before 
the locals to possibly store a return address. This is true
even when the procedure does not declare any local as in
[[TEXT foo(SB), $0]]. %$
In some situations though the programmer would like to change
this default behavior and not allocate anything at all in the stack
in which case he must use [[$-4]]%$.
\t appendix getcallerpc? for getcallerpc

%real-world:
% in gasm I think it's
% .global foo
% .text
% foo:
%   <adjust SP>

\subsection{[[WORD/DATA]]}
\label{sec:WORD}

%trans:
[[GLOBL]] tells the linker to allocate some space in the [[Data]]
section of the executable but it is the
%
[[DATA]] pseudo-instruction which tells the linker how to fill this space
as explained in Section~\ref{sec:data}:

<<[[Opcode]] cases, pseudo opcodes>>=
ADATA,
@
<<[[itab]] elements>>=
"DATA",		LDATA, ADATA,
@
<<inst rule(arm)>>=
/*
 * DATA
 */
| LDATA name '/' con ',' ximm { outcode($1, Always, &$2, $4, &$6); }
@
\l ugly, abuse reg for this constant.

Note that the [[name]] can contain an offset as in [[hello+8(SB)]].
The [[con]] specifies the size in bytes this [[DATA]] pseudo-instruction 
is defining.
Note also the use of [[ximm]] which allows to use string constants
or even addresses of other globals as in [[$otherdata(SB)]]).%$
\l can reference itself
Here are some examples of use of [[DATA]]:
\begin{verbatim}
DATA    hello+0(SB)/8, $"hello wo"
DATA    hello+8(SB)/4, $"rld\n"
...
DATA boot_CONF_outlen+0(SB)/4, $67523
DATA boot_CONF_outcode+0(SB)/8, $"\z\z\1\353\z\z\213\33"
...
\end{verbatim}
\l data2s

%trans:
[[DATA]] allows to put any value in the [[Data]] section of the executable.
%
A similar pseudo-instruction, [[WORD]], does the same for the [[Text]] section:
\l have not seen that in tutorial

<<[[Opcode]] cases, pseudo opcodes>>=
AWORD,
@
<<[[itab]] elements>>=
"WORD",		LWORD, AWORD,
@
<<inst rule(arm)>>=
/*
 * WORD
 */
| LWORD ximm { outcode($1, Always, &nullgen, R_NONE, &$2); }
@
\l no need /con here, it's always 4 (WORD).

The main use of [[WORD]] is to overcome some of the limitations
of the assembler. Indeed, for [[5a]], even if certain system ARM 
instructions do not have yet an Asm5 mnemonics, one can
still use [[WORD]] to specify this instruction
if one knows the exact binary encoding of 
this instruction. One can even use [[WORD]]
in a macro as shown in Section~\ref{sec:mcrr-macro}.
\l used in x86 for real-mode encoding

\l because data sometimes in text section, e.g. kernel interrupt table?
 

\subsection{[[END]]}

The [[END]] pseudo-instruction is a marker used
to indicate the end of the instructions in the object file:

<<[[Opcode]] cases, pseudo opcodes>>=
AEND,
@
<<[[itab]] elements>>=
"END",		LEND, AEND,
@

<<inst rule(arm)>>=
/*
 * END
 */
| LEND { outcode($1, Always, &nullgen, R_NONE, &nullgen); }
@
%$
%ocaml: do not need that I think

The need for such an instruction in the assembly file is
not clear. Having such a marker in the object file
can be useful though. Indeed, when many object files are concatenated
together in a library, the mark can be used to indicate
object boundaries.
\l meh, still linker could do that, but ldobj() is easier to write
\l if AEND is an opcode, like ANAME, like AHISTORY
Note that [[5a]] automatically adds such a marker
at the end of the generated object file
via [[cclean()]] as seen in Section~\ref{sec:cclean}.

\l not the same than ALAST

%\section{Special instructions}
%\subsection{[[NOP]]}
%\subsection{[[SHL/SHR]]}
%\subsection{[[MOVW/MOVL]]}
%\subsection{[[IMUL]]}


\section{Conditional execution}
\label{sec:cond-exec}

In the ARM, {\em every instruction can be conditionally executed},
\n actually no more in ARMv8
not just branching instructions. This is why every Asm5 
instructions we have seen before uses the [[cond]] non-terminal
in their grammar rule. In Asm5 one can suffix
any opcode with a {\em condition} as in [[ADD.EQ R1, R2, R3]]:

<<type declarations(arm)>>=
%type   <lval>  cond
@

<<cond rule(arm)>>=
cond:
  /* empty */ { $$ = Always; }
| cond LCOND  { $$ = ($1 & ~C_SCOND) | $2; }
@

<<[[itab]] elements>>=
".EQ",		LCOND,	0,
".NE",		LCOND,	1,
".CS",		LCOND,	2,
".HS",		LCOND,	2,
".CC",		LCOND,	3,
".LO",		LCOND,	3,
".MI",		LCOND,	4,
".PL",		LCOND,	5,
".VS",		LCOND,	6,
".VC",		LCOND,	7,
".HI",		LCOND,	8,
".LS",		LCOND,	9,
".GE",		LCOND,	10,
".LT",		LCOND,	11,
".GT",		LCOND,	12,
".LE",		LCOND,	13,
".AL",		LCOND,	Always,
@
%//Never = 15

<<constant Always(arm)>>=
#define    Always 14
@
%old: was in a.h, but better put in 5.out.h
\l used as parameter to a few outcode
\l use COND_ALWAYS instead?

So, the branching instruction [[BEQ]] we saw in
Section~\ref{sec:conditional-jump} is really just 
an alias for [[B.EQ]]. 
%
The need to conditionaly execute non-branching instruction
such as addition may not be obvious. 
They were originally designed to compensate for the lack
of branch predicator in ARM CPUs
by having code using less branches. See
\url{https://en.wikipedia.org/wiki/ARM_architecture#Conditional_execution}
or the \book{Emulator} for more information .
\l http://stackoverflow.com/questions/22168992/why-are-conditionally-executed-instructions-not-present-in-later-arm-instruction

The bit manipulation involving [[C_SCOND]] above is because
the [[cond]] non-terminal in addition to the conditional
execution also stores special ARM instruction bits 
as explained in Section~\ref{sec:special-bits}:
\n e.g. Sbit, after 0xf
%ocaml: no need for this special bitset that early. Return one cond
% and a list of constructor for the .S, .etc

<<constant C_SCOND(arm)>>=
/* scond byte */
#define	C_SCOND	((1<<4)-1)
@
% >>
\n 0xf



\section{[[yyparse()]]}
\label{sec:yyparse}

Based on the grammar of Asm5 we have seen in this chapter, [[yacc]]
will generate:

\begin{itemize}
\item a [[y.tab.h]] header file containing the token
codes and the union for [[yylval]], as explained
in Section~\ref{sec:token}. Both the token codes and
[[yylval]] are used by [[yylex()]].

\item a [[y.tab.c]] C file containing the function [[yyparse()]].
This function will internally call [[yylex()]] 
(which is why we call our lexing function [[yylex()]] in
Chapter~\ref{chap:lexing})
to get tokens until the end of the file token ([[EOF]]),
and will parse those tokens according to the first
grammar rule declared in the file: [[prog]].

\end{itemize}







\chapter{Object Code Generation}
\label{chap:generation}

%trans:
We are now ready to present the last component in the
assembling pipeline: the object code generation.
%dup: from intro/5a
As mentioned before, [[5a]] does not actually generate machine
code (the linker does), 
%
which simplifies things.
Indeed, the only thing [[5a]] needs to do is to {serialize} the 
Asm5 instructions and to record in the object file 
the set of symbols used 
\l (and defined) 
in the assembly file, and where those symbols are used, 
so that they can be resolved later by the linker.
%
Note that labels are resolved during parsing by [[5a]] and 
so their definitions do not need to be stored in the object file.
\t but the uses are there for debugging purpose!
\l but use virtual code address; those addresses must be relocated too.
%
The \book{Linker} will describe then the reverse operation which
is to read an object file.
\n ldobj()
It will also describe which machine code
is generated from the object files and how those object files
are combined to form an executable.
\n 5l/optab.c does this

\section{Object format}
\label{sec:object-format-complete}

%trans:
We described rougly the format of the object files at the beginning
of this book in Section~\ref{sec:object-format-part1}. 
We can describe more precisely this format in 
Figure~\ref{fig:object-format-complete} since we now have
a better understanding of Asm5.

\begin{figure}[!]\centering
\begin{verbatim}
                        ^-------------+
                       /|             |
                      / |             |
                     /  |             |
                    /   |  Operand 2  |
+--------------+    |   |             |
|Instruction 4 |    |   |             |
|              |    |   |             |       ^-------------+
+--------------+    |   |             |/-----/|             |
|   Symbol3    |    |   +-------------X       |             |
+--------------+    |   |             |       |             |
|   Symbol2    |    |   |             |       |Operand value|
+--------------+    |   |  Operand 1  |       |             |
|              |    /   |             |       |             |
|Instruction 3 |   /    |             |       |             |
|              |  /     |             |       |             |
+--------------+ /      +-------------X       +-------------+
|   Symbol1    |/       |             |\      | Symbol kind |
+--------------X        |    Line     | \     +-------------+
|Instruction 2 |        |             |  \    |Symbol index |
|              |        |             |   \   +-------------+
+--------------X        +-------------+    \  |  Register   |
|Instruction 1 |\       |  Register   |     \ +-------------+
|              | \      +-------------+      \|Operand kind |
+--------------+  \--\  |  Condition  |       v-------------+
| Files/lines  |      \ +-------------+
|   history    |       \|   Opcode    |
|              |        v-------------+
+--------------+

    File                  Instruction             Operand
\end{verbatim}
\caption{Complete file format of a [[.5]] object file}
\label{fig:object-format-complete}
\end{figure}

The format of an object file is pretty regular, essentially a list
of instructions where each instruction is encoded as:
\l do I repeat too much the code? too verbose? maybe
\begin{itemize}
\item an opcode (1 byte), e.g. the value of [[ASUB]]
\n 1 byte enough for 256 opcodes, as explained in sec:object-format-part1

\item a conditional execution (1 byte), e.g. the value of [[Always]]

\item a register number (1 byte), e.g. 4 for [[R4]], 
when an instruction has 3 operands or the value of [[R_NONE]]
\l also abused to encode some symbol attributes, e.g. DUPOK

\item a line number (4 bytes) encoded in an architecture
independent way by having the bytes representing the lower
part of the number stored first in the object file\footnote{
Also known as the {\em little-endian} format
}.

\item the first operand
\n which can be null operand

\item the second operand
\n which can be null operand

\l The register above is a kind of operand3.

\end{itemize}

The operands themselves are encoded as:
\begin{itemize}
\item the kind of the operand (1 byte), e.g. the value of [[D_REG]].
Note that for opcodes with 0 or 1 operand, [[D_NONE]] is used
to represent the null operand.

\item a register number (1 byte), e.g. 5 for [[R5]] when
the operand involves a register (as in [[(R5)]]) or [[R_NONE]]
\l for direct register, shifted register, and??

\item an {\em index} (1 byte) in the {\em object file symbol table},
e.g. 13 when the operand involves a symbol (as in [[hello(SB)]])
or 0.
\t or label, saved for debugging
The encoding scheme for this symbol table will be described later
in Section~\ref{sec:spreaded-symbol-table}.

\l for D_OREG and also D_CONST (but really D_ADDR)

\item the kind of the symbol (1 byte), e.g. the value of [[D_EXTERN]]
when the operand involves a symbol or [[N_NONE]]

\item the value of the operand, which has a variable size
e.g. 4 bytes for the integer value of a [[D_CONST]]
but 0 byte for [[D_REG]] since the register number
is stored already above.

\end{itemize}

A symbol reference in an operand is represented as an index in a symbol table,
which saves space since the same symbol could be referenced many times.
%ocaml: so kinda pointer to string, but Marshall does this for free!
\n not to confuse with hash, symbol table of assembler vs object file stab
This symbol table could be stored at the beginning or end of the file.
Instead, [[5a]] uses a rather sophisticated scheme 
explained in Section~\ref{sec:spreaded-symbol-table} where the symbol
table is ``spread'' in the object file along with the instructions.
\n ANAME: symkind (1 byte), symidx (1 byte), string finished by \0
%
The beginning of an object file contains files and lines information
which will be explained in Section~\ref{sec:object-file-history}.
\n the header is really just a set of ANAME and AHISTORY, and
\n AHISTORY use the same format than other instructions.

\l 5l then read back this format in a simple loop reading one
\l instruction at a time and maintaing the symbol table information
\l via the ANAME.

\t 5l -v -W to show?


\section{Instruction output, [[outcode()]]}
\label{sec:outcode}

%trans:
The job of [[outcode()]], introduced in Section~\ref{sec:outcode-signature},
and used many times in the grammar, is 
mostly to serialize one instruction (machine, pseudo, or virtual)
according to the format described previously:
\n mostly because actually also serialize symbol table, and increment also pc

<<function outcode(arm)>>=
/// main -> assemble -> yyparse -> <>
void
outcode(int opcode, int scond,  Gen *g1, int reg, Gen *g2)
{
    <<[[outcode()]] locals>>

    <<[[outcode()]] adjust opcode and scond when opcode is AB>>

    if(pass == 1)
        goto out;

    <<[[outcode()]] st and sf computation, and possible calls to zname>>

    Bputc(&obuf, opcode);
    Bputc(&obuf, scond);
    Bputc(&obuf, reg);
    Bputc(&obuf, lineno);
    Bputc(&obuf, lineno>>8);
    Bputc(&obuf, lineno>>16);
    Bputc(&obuf, lineno>>24);
    outopd(g1, sf);
    outopd(g2, st);

out:
    if(opcode != AGLOBL && opcode != ADATA)
        pc++;
}
@
%ocaml: just use Marshall, no need all those stuff
%old: I renamed 'a' to 'opcode', clearer I think
\l less: rename reg to reg3? so less confusing with reg in zaddr?

It also increments the virtual program counter
[[pc]] (used to resolve labels) for all instructions
except the one related to the [[Data]] section of the executable.
Indeed, [[DATA]] or [[GLOBL]] instructions can be mixed
with [[TEXT]] instructions; they do not have to be at the
end of the assembly file (even though this is a common practice).
\n WORD is for the TEXT section too!

Note the use of [[goto]] in the code above where an [[if]] would
have been arguably clearer. This is perhaps the sign that
the person who wrote this code likes too much assembly.
\l maybe ok for an assembler :)

\l note that output line number here! useful for debugging information,
\l to be ablt to go back from one instruction to the actual code!
\l (but lineno after #include expansion, see outhist() section
\l later so one can get from lineno to actual file _plus_ lineno

[[outcode()]] also {\em normalizes} the code:

<<[[outcode()]] adjust opcode and scond when opcode is AB>>=
/* hack to make B.NE etc. work: turn it into the corresponding conditional*/
if(opcode == AB){
    opcode = bcode[scond&0xf];
    scond = (scond & ~0xf) | Always;
}
@
<<global bcode(arm)>>=
static int bcode[] =
{
    ABEQ,
    ABNE,
    ABHS,
    ABLO,
    ABMI,
    ABPL,
    ABVS,
    ABVC,
    ABHI,
    ABLS,
    ABGE,
    ABLT,
    ABGT,
    ABLE,
    AB,
    ANOP,
};
@

\t why not keep B.EQ ? to normalize helps 5l? but ironic that normalize
\t in inverse direction of what ARM actually has.

%dup: from parsing/cond-exec
The bit manipulation with [[scond]] above is because
[[scond]] in addition to store the conditional execution
also stores special ARM instruction bits
as explained in Section~\ref{sec:special-bits}.

\section{Operand output, [[outopd()]]}

Assuming a symbol index parameter [[symidx]] computed by the caller
(and explained in Section~\ref{sec:spreaded-symbol-table}),
[[outopd()]] outputs an operand
according to the format described previously:

<<function zaddr(arm)>>=
/// main -> assemble -> yyparse -> outcode -> <>
void
outopd(Gen *a, int symidx)
{
    <<[[zaddr()]] locals(arm)>>

    Bputc(&obuf, a->type);
    Bputc(&obuf, a->reg);
    // idx in symbol table, 0 if no symbol involved in the operand
    Bputc(&obuf, symidx);
    // symkind of the symbol, or N_NONE
    Bputc(&obuf, a->symkind);

    switch(a->type) {
    <<[[zaddr()]] cases(arm)>>
    default:
        print("unknown type %d\n", a->type);
        exits("arg");

    }
}
@
%old: was zaddr, but no idea why, clearer use outopd
%ocaml: just use Marshall again in caller

\ifallcode
<<[[zaddr()]] locals(arm)>>=
long l;
char *n;
Ieee e;
int i;
@
\fi

The operand value has a variable size depending on the kind
of the operand:

<<[[zaddr()]] cases(arm)>>=
case D_NONE:
    break;

case D_REG:
    break;

case D_CONST:
case D_OREG:
case D_BRANCH:
case D_SHIFT:
    l = a->offset;
    Bputc(&obuf, l);
    Bputc(&obuf, l>>8);
    Bputc(&obuf, l>>16);
    Bputc(&obuf, l>>24);
    break;

case D_SCONST:
    n = a->sval;
    for(i=0; i<NSNAME; i++) {
        Bputc(&obuf, *n);
        n++;
    }
    break;
@

% from 5.out.h and 8.out.h
<<constant NSNAME>>=
#define	NSNAME		8
@


\section{Object file symbol table, [[h]] and [[ANAME]]}
\label{sec:spreaded-symbol-table}

%trans:
Operands can mention symbols which are important to keep track
in the object file since those symbol references must be resolved
later by the linker.
\l or for param and local to help debuggers.
% 
Because only 1 byte is used in the format of the operand
to store the index of the symbol involved,
one could think Asm5 allows only 256 different symbols
in an assembly file. But, the {\em object file symbol table}
we will describe in this section,
in addition to be {\em spread} in the object file, is also a
{\em circular} table with 50 elements.
This clever scheme allows any number of symbols in an object file
as we will see.
\n uselessly complicated? if want only 1 byte for index, then need a 
\n circular thing and need to spread it.
\l can have more incremental linker also?

The global [[h]] below mimics in memory this circular table:
\l why global? why not static in outcode?
\n there will be a similar variable in ldobj() in the linker

<<global h>>=
// array<ref<Sym> * int>
struct Htab h[NSYM];
@
\t why call it h when really it's an array ...
<<constant NSYM>>=
#define	NSYM	50
@
\n need to be < 256 as currently use Bputc to marshall indexes in zaddr()
\n need to be the same in 5l if dont use defensive programming
\t but why not 255 then????

<<struct Htab>>=
struct Htab
{
    // ref<Sym>>
    Sym*	sym;
    //enum<sym_kind>
    short	symkind;
};
@
\n we could put Htab in Core DS, h is reset in pinit(), but it's
\n really just local to the Output code generation so I think
\n it is better to put this DS here I think.
%old: I rename 'type' to symkind, to avoid confusion with Gen.type.
% Htab is a sliced subset of Sym but just for the symbols 
% (and an array insteaf of a hash, which is confusing name.


The object file symbol table [[h]] is different from the symbol
table [[hash]] we have described in Section~\ref{sec:hash}.
Indeed [[hash]] is an hash table which keeps
track of macros, predefined identifiers, labels, and symbols.
The object file symbol table stores only symbols 
(and labels but only for debugging purpose)
and is just an array.

The first entry in [[h]] is unused since 0 represents
the absence of symbol in the operand format.
The next free entry is stored in the following global:

<<global symcounter>>=
int	symcounter;
@
%old: was called sym, but I renamed it to avoid overloading the sym name
% (as a global, as a field)
\l why not char instead? like symidx (or better byte)

<<[[pinit()]] initialisations>>=
symcounter = 1;
for(i=0; i<NSYM; i++) {
    h[i].symkind = 0; // N_NONE
    h[i].sym = S;
}
@
\t still initialize h[0] because used later in symidx_of_symopt()
\n cant use N_NONE because factorized with x86
\l needed only for pass 2

As we will output instructions in [[outcode()]], new symbols
will be referenced in operands and new entries in [[h]]
will be created as we will see soon. To output
in the object file a new entry, the following function is used:

<<function zname(arm)>>=
/// outcode -> <>
void
zname(char *n, int symkind, int symidx)
{

    Bputc(&obuf, ANAME);
    Bputc(&obuf, symkind);	/* type */
    Bputc(&obuf, symidx);	/* sym */
    while(*n) {
        Bputc(&obuf, *n);
        n++;
    }
    Bputc(&obuf, '\0');
}
@
\l rename? out_symbol_table_elt
\t symkind redundant? maybe.
\n symidx redundant too? Why need idx if we store the symbol entries 
\n  one after the other? Defensive programming? so can infer circular size?

A new pseudo-opcode is used:

<<[[Opcode]] cases, pseudo opcodes>>=
ANAME,
@
\n could be renamed ASYM
%old: if ANAME is after AHISTORY in 5.out.h then got
% some bugs in ar such as "inconsistent file xxx.5 in libc.a"
%update: maybe it was because the Makefile pb where actually
% libmach was not recompiled?

This constant must be part of the [[Opcode]] enum so that
it is different from any other opcode. This makes the
format of an object file unambiguous. Indeed, to read
an object file, one can just read one byte and decide
if the further bytes represent an instruction or an element
of the symbol table.
\t this is why also later will have AHISTORY part of that too
\t this is why also have AEND in enum.

We can finally see the code in [[outcode()]] which maintains
[[h]], manages the symbol indexes, and calls [[zname()]] when
a new entry is needed. The locals below are set by this
code. [[sf]] and [[st]] are passed to [[outopd()]]
as we have seen in Section~\ref{sec:outcode}:

<<[[outcode()]] locals>>=
// symbol from, index in h[]
int sf;
// symbol to, index in h[]
int st;
int oldsymcounter;
@

An additional field in [[Sym]] is needed to store
the index of symbols already present in [[h]]:

<<[[Sym]] identifier fields>>=
// index in h when the Sym is a symbol, 0 otherwise
int	symidx;
@
\label{sec:symidx-sym-field}
%old: was called 'sym', but really it's an index in h, and it was confusing
% to have so many fields called sym already (as well as the global sym)
% char enough??
%old: was char, but in many places they use int for symcounter so I use int
% there too now
\t set to 0 in syminit? apparently not

The code below to compute [[sf]] and [[st]] is rather subtle:

<<[[outcode()]] st and sf computation, and possible calls to zname>>=
jackpot:
oldsymcounter = symcounter;
sf = symidx_of_symopt(g1->sym, g1->symkind);
st = symidx_of_symopt(g2->sym, g2->symkind);
<<[[outcode()]] if jackpot condition goto jackpot>>
@

<<function symidx_of_symopt>>=
int
symidx_of_symopt(Sym *sym, int symkind)
{
    int idx = 0;
   
    if(sym != S) {
        idx = sym->symidx;
        <<[[symidx_of_symopt()]] sanity check idx>>
        
        // already generated an ANAME for this symbol reference?
        if((h[idx].symkind != symkind || h[idx].sym != sym)) {
            sym->symidx = symcounter;
            h[symcounter].sym = sym;
            h[symcounter].symkind = symkind;
            idx = symcounter;
            zname(sym->name, symkind, symcounter);
            
            symcounter++;
            if(symcounter >= NSYM)
                // circular array
                symcounter = 1;
        }
    }
    return idx;
}
@
%pad: I introduced this function, because original code was to hard
% to explain

<<[[symidx_of_symopt()]] sanity check idx>>=
if(idx < 0 || idx >= NSYM)
    idx = 0;
@

There is a rather complex condition which can force us to recompute
[[sf]] and [[st]]:

<<[[outcode()]] if jackpot condition goto jackpot>>=
if (sf == st && sf != 0 && symcounter != oldsymcounter) 
   goto jackpot;
@

This situation can happen for instance when the first operand
involves a symbol [[foo]] with an index of 10 ([[sf == 10]]) 
and when the second operand involves another symbol [[bar]] not yet seen. 
Because of the circular nature of [[h]], [[symcounter]] could have already
done one full round and be back to the value of 10.
This means the next entry is 10 and [[h[10].sym]] will be overwritten
to point now to the symbol for [[bar]].
In this case [[sf == st == 10]] but [[sf]] now points
to a wrong entry. In that case we want to recompute [[sf]]
hence the [[goto]].
\t why not infinite loop. what happens next iteration? h[idx].sym != sym
\t so increment
\l this is very very subtle (too subtle I think).
The extra condition about [[oldsymcounter]] is to avoid
an infinite loop in [[outcode()]] with code such 
as [[MOVW bar(SB), bar(SB)]].

\l Figure?

%old:
%<<[[outcode()]] st and sf computation, and possible calls to zname>>=
%jackpot:
%
%sf = 0;
%s = g1->sym;
%
%while(s != S) {
%    sf = s->symidx;
%
%    if(sf < 0 || sf >= NSYM)
%        sf = 0;
%
%    symkind = g1->symkind;
%
%    // already generated an ANAME for this symbol reference
%    if(h[sf].symkind == symkind)
%     if(h[sf].sym == s)
%        break;
%
%    s->symidx = symcounter;
%    h[symcounter].sym = s;
%    h[symcounter].symkind = symkind;
%    sf = symcounter;
%    zname(s->name, symkind, symcounter);
%
%    symcounter++;
%    if(symcounter >= NSYM)
%        symcounter = 1;
%    break;
%}
%
%st = 0;
%s = g2->sym;
%
%while(s != S) {
%    st = s->symidx;
%
%    if(st < 0 || st >= NSYM)
%        st = 0;
%
%    symkind = g2->symkind;
%
%    if(h[st].symkind == symkind)
%      if(h[st].sym == s)
%        break;
%
%    s->symidx = symcounter;
%    h[symcounter].sym = s;
%    h[symcounter].symkind = symkind;
%    st = symcounter;
%    zname(s->name, symkind, symcounter);
%
%    symcounter++;
%    if(symcounter >= NSYM)
%        symcounter = 1;
%
%    if(st == sf)
%        goto jackpot;
%    break;
%}
%@
% use a while so can break? argh, horrible. This code was really bad.

\t nm
\l so need to output information about use of external symbols! 'U'
\l and also information about symbols the module defines! 'T', 'D'


\chapter{Debugging Support}
\label{chap:debugging}

The \plan debugger [[db]], which we will describe in the \book{Debugger},
has access to lots of {\em metadata} in the executable to help debug programs.
For instance, here is a simplified output of [[db]] when 
debugging a C program:

\begin{verbatim}
$ db hello
...
main(argv=...) /usr/.../main.c 
      called from _main+26 (/sys/.../main9.s:12)
...
\end{verbatim}
\t exact trace? no line number for main? 
\l use it instead on helloa?

[[db]] knows from which file and which line a piece of machine
code comes from. It also knows 
the name of the function containing this piece of machine code, 
the names of the parameters of this function, as well as 
the name of the caller to this function. 
Finally it knows the file and line of this caller function.
\t illustrate with actual thing [[main()]], [[_main()]], etc

The metadata in the executable comes from
corresponding metadata in the object files generated by [[5a]] and [[5c]]. 
%
Indeed, the names of the parameters, locals, and entities are kept 
in the object file as we have seen
in the previous chapter. %clever\ref{chap:generation}
\n we will see later how kept also by linker.
%dup: overview/input-lang and parsing/operands/names
This is why Asm5 programmers write code like [[MOVW  count+4(FP), R1]]
even though [[count]] is not used to generate any machine code.
Indeed this symbol is actually kept in the object file
and then in the executable and can then be used by debuggers and tracers.
%
Labels are resolved during parsing by [[5a]] but the names of those
labels are also kept in the object file symbol table.
Their references in operands are kept too which again helps
to debug programs.
\l help debug jump?

%toc:
In this chapter we will focus on the file and line information
as the information about symbols has already been described
in the previous chapter. %clever\ref{chap:generation}

%real-world: in gas needs -g to keep debugging info in object file?

\section{Line origin history, [[Hist]]}
\n could be in Preprocess chapter, but even if no cpp, still need handle #line

Because [[5a]] is a macro-assembler, the file and line origin of an
instruction in the object file are not necessarily the assembly filename
passed on the command line to [[5a]] and a line number in this file.
Indeed, this file could have included via [[#include]] other files containing
also assembly instructions.
\n even though in practice it will be more constants
Moreover, some assembly files are derived from C programs in which 
case one would rather have the location metadata refers to line numbers
in the original C programs (thanks to the [[#line]] directive 
we saw in Section~\ref{sec:sharp-line}) than line numbers
in the generated assembly programs.
%
So, recording only a line number in the format of an instruction
as described in Section~\ref{sec:object-format-complete} seems
insufficient; a filename should also be recorded.
\n but each time a pair of line x file would be costly

The global [[lineno]] we introduced in Section~\ref{sec:lineno},
and which is used by [[outcode()]] to store the line number of an
instruction in the object file, 
is incremented after each newlines by the lexer (see
for instance Section~\ref{sec:semicolon}).
But, this is done while pre-processing the file which means [[lineno]]
is actually more a {\em global line number} than a line number 
in one file. What we need then is a way to go from a global line number
to a filename and a {\em local line number}.

The following structure will help to keep track of the 
[[#include]] and [[#line]] directives used while pre-processing 
the input file.
This will allow us then to compute the file and local line number
of a global line number.

<<struct Hist>>=
struct	Hist
{
    char*	filename; // nil for a ``pop''

    // global line of this Hist
    long	global_line;       
    // 0 for #include, +n for #line, -1 for #pragma lib (ugly)
    long	local_line; 

    // Extra
    <<[[Hist]] extra fields>>
};
@
%old: renamed offset to local_line, clearer; avoid confusion with Gen.offset
% also renamed line to global_line, more consistent.
\t abused for #pragma lib "xxx.a" where local_line is then -1. ugly.
\l many of the comments above will be explained later.
\t why History? because not just origin, but parents too?

The global [[hist]] below maintains a list of those [[Hist]].
The first element of this list will be the input assembly file of [[5a]]
passed on the command line.

<<global hist>>=
// list<ref_own<Hist>>, next = Hist.link
Hist*	hist;
@
%ocaml: use a tree directly
<<[[Hist]] extra fields>>=
// list<ref<Hist>> from hist
Hist*	link;
@
<<constant H>>=
#define	H	((Hist*)nil)
@

We will need also a fast access to the tail of the list:
\l because kind f a stack

<<global ehist>>=
// ref<Hist>, end of list of hist
Hist*	ehist;
@


\section{Recording history, [[linehist()]]}

The only function modifying [[hist]] is [[linehist()]].
It is called notably by [[newfile()]] which itself is called
at the beginning in [[pinit()]] with the name of the input
assembly file and later for each included file:

<<[[newfile()]] call linehist>>=
linehist(s, 0);
@

<<function linehist>>=
/// (pinit | macinc -> newfile) | (GETC -> filbuf) | maclin -> <>
void
linehist(char *f, int local_line)
{
    Hist *h;

    <<[[linehist()]] debug>>

    h = alloc(sizeof(Hist));
    h->filename = f;
    h->global_line = lineno;
    h->local_line = local_line;

    //add_list(hist, ehist, h)
    h->link = H;
    if(ehist == H) {
        hist = h;
        ehist = h;
        return;
    }
    ehist->link = h;
    ehist = h;
}
@
\n debug used in appendix

It is also called for [[#line]] directives such as [[#line 10 "foo"]]:

<<[[maclin()]] call linehist>>=
linehist(cp, n);
@

Note that the included files form a tree. We use a list data
structure though for [[hist]] which seems insufficient.
But, the special value [[nil]]
in a [[Hist]] encodes the end of a file which is enough
to reconstruct the tree:

<<[[filbuf()]] when close file, call linehist>>=
linehist(nil, 0);
@
%ocaml: use a Tree directly

Figure~\ref{fig:hist} illustrates the evolution of
the global [[lineno]] on the content of [[/tests/cpp/foo.s]]
(which includes other files) as well as the value
of [[hist]] and [[ehist]] after having pre-processed the entire file.

\begin{figure}[!]\centering
\begin{verbatim}
                                               hist
                                        +--------------------+
     foo.s---------------------------+  |"foo.s", G1, L0     |
 1   |L1                             |  +--------------------+
 2   |L2                             |
 3   |L3 #include "foo.h"            |  +--------------------+
     |   foo.h-------------------+   |  |"foo.h", G4, L0     |
 4   |   |L1 #include "foo1.h"   |   |  +--------------------+
     |   |   foo1.h-----------+  |   |  |"foo1.h", G5, L0    |
 5   |   |   |L1              |  |   |  +--------------------+
     |   |   +----------------+  |   |  |nil, G6, L0         |
 6   |   |L2                     |   |  +--------------------+
 7   |   |L3 #include "foo2.h"   |   |  +--------------------+
     |   |   foo2.h-----------+  |   |  |"foo2.h", G8, L0    |
 8   |   |   |L1              |  |   |  +--------------------+
     |   |   +----------------+  |   |  |nil, G9, L0         |
 9   |   |L4                     |   |  +--------------------+
 10  |   |L5                     |   |  +--------------------+
     |   +-----------------------+   |  |nil, G11, L0        |
 11  |L4                             |  +--------------------+
 12  |L5 #include "bar.s"            |  +--------------------+
     |   bar.s-------------------+   |  |"bar.s", G13, L0    |
 13  |   |L1                     |   |  +--------------------+
 14  |   |L2                     |   |  +--------------------+
     |   +-----------------------+   |  |nil, G15, L0        |
 15  | L6                            |  +--------------------+
 16  | L7                            |  +--------------------+
 17  | L8#line 10 "foobar.c"         |  |"foobar.c", G18, L10|
 18  | L9                            |  +--------------------+
 19  |L10                            |  +--------------------+
     +-------------------------------+  |nil, G20, L0        |
                                        +--------------------+
lineno          foo.s and                     ehist
(global)     included files
\end{verbatim}
\caption{[[lineno]] and [[hist]] for [[/tests/cpp/foo.s]]}
\label{fig:hist}
\end{figure}

One of the option of [[5a]] described in Section~\ref{sec:debug-line}
helps to debug the debugging support code itself by logging
the value of [[lineno]] and [[Hist]] elements in the
calls to [[linehist()]]:

\begin{verbatim}
$ cd /tests/cpp
$ 5a -f foo.s
   1: foo.s
   4: foo.h
   5: foo1.h
   6: <pop>
   8: foo2.h
   9: <pop>
  11: <pop>
  13: bar.s
  15: <pop>
  18: foobar.c (#line 10)
  20: <pop>
...
\end{verbatim}
\n actually logged two times because two pass algorithm of 5a

%old: newflag dead? seems just set to false ... just one write.
%% it's used in cc/ though, but we copy pasted code for macbody so
% I think it's safe to delete it here.
%<<global newflag>>=
%bool	newflag;
%@
%
%    <<[[linehist()]] newflag hack>>
%    <<[[linehist()]] debug>>
%    newflag = false;
%
%
%<<[[linehist()]] newflag hack>>=
%/*
% * overwrite the last #line directive if
% * no alloc has happened since the last one
% */
%if(newflag == false && ehist != H && offset != 0 && ehist->offset != 0)
%    if(f && ehist->filename && strcmp(f, ehist->filename) == 0) {
%        ehist->line = lineno;
%        ehist->offset = offset;
%        return;
%    }
%@






\section{Displaying history, [[prfile()]]}
\n I prefer to put prfile() here rather than in the Error appendix.
\n so can better understand actually the tracing mechanism.

By keeping the full {history} of the [[#include]] directives, 
\l and [[#line]] but less
[[5a]] can also give better error message such as:

\begin{verbatim}
$ 5a foo.s
foo.s:7 bar.s:2 redeclaration of lbl1
\end{verbatim}
\t actually seems buggy, should be foo.s:5. Copy Lconv in 5c.
\t 5c instead report (correctly):     bar.s:2 foo.s:5 ...

This means the error is in the file [[bar.s]] at line 2 and this
file was actually included from [[foo.s]].
\t especially useful for C code, where can be really tricky to fix error
\t because of some ifdef, and losts of nested include to understand
\t where it comes from
%
We are now ready to understand [[prfile()]] which
is used when reporting error in [[5a]]. It converts
a global line number [[l]] into a serie of filenames and line numbers
representing the {history} of this global line.

The size of this serie is limited to 20 elements:

<<constant HISTSZ>>=
#define	HISTSZ		20
@

For instance with the data on Figure~\ref{fig:hist}, 
[[prfile(14)]] should print:

\begin{verbatim}
foo.s:5 bar.s:2
\end{verbatim}
\t but actually says foo.s:7

\l prfile compute a and n, where a[n-1] contain info about file with error
\l and a[0..n-2] "parent" of this included file if included
\l On our previous example we want a = [....; ...]

<<function prfile>>=
/// yyerror -> <>
void
prfile(long l)
{
    Hist a[HISTSZ];
    int n = 0;
    Hist *h;
    int i;
    long d;

    <<[[prfile()]] compute a and n>>
    if(n > HISTSZ)
        n = HISTSZ;
    for(i=0; i<n; i++)
        print("%s:%ld ", a[i].filename, 
                         (long)(l - a[i].global_line + a[i].local_line + 1));
}
@

The [[+1]] above is to have line numbers starting at 1.

<<[[prfile()]] compute a and n>>=
for(h = hist; h != H; h = h->link) {
    if(l >= h->global_line) {
        if(h->filename) {
            // a #include
            if(h->local_line == 0) {
                if(n >= 0 && n < HISTSZ)
                    a[n] = *h;
                n++;
            } 
            <<[[prfile()]] compute a and n, when line directive>>
        }
        // a pop
        else {
            n--;
            <<[[prfile()]] compute a and n, when pop, adjust parents>>
        }
    }
}
@
%old: was using more break, I rewrote a bit

\t need another field to correctly adjust the parents, see LConv

<<[[prfile()]] compute a and n, when pop, adjust parents>>=
if(n >= 0 && n < HISTSZ) {
    d = h->global_line - a[n].global_line;
    for(i=0; i<n; i++)
        a[i].global_line += d;
}
@

<<[[prfile()]] compute a and n, when line directive>>=
// a #line
else {
    if(n > 0 && n < HISTSZ)
        // previous was a #include
        if(a[n-1].local_line == 0) {
            a[n] = *h;
            n++;
        } else
            a[n-1] = *h; // overwrite previous #line
}
@


\section{Saving history, [[outhist()]] and [[AHISTORY]]}
\label{sec:object-file-history}
\n Was called Header section, but not really an header in traditional sense.
\n The object could be parsed without those AHISTORY and ANAME I think.

We can now describe the only missing piece in the object file
format in Figure~\ref{fig:object-format-complete}: the
[[files/lines history]] at the beginning of the object file.
The function below is called by [[assemble()]] before
the many calls to [[outcode()]] and essentially serializes [[hist]].
To do so it is reusing (some would say abusing) the instruction
format and the symbol table to respectively store the
global/local line numbers in a [[Hist]] and its filename:

<<function outhist(arm)>>=
/// main -> assemble -> <> (at begining of pass 2)
void
outhist(void)
{
    Gen g;
    Hist *h;
    char *p;
    <<[[outhist()]] locals(arm)>>

    g = nullgen;
    for(h = hist; h != H; h = h->link) {
        p = h->filename;

        <<[[outhist()]] adjust p and op if p is relative filename>>
        <<[[outhist()]] output each path component as an ANAME>>
        g.offset = h->local_line;

        Bputc(&obuf, AHISTORY);
        Bputc(&obuf, Always);
        Bputc(&obuf, 0); // reg, but could be R_NONE too 
        Bputc(&obuf, h->global_line);
        Bputc(&obuf, h->global_line>>8);
        Bputc(&obuf, h->global_line>>16);
        Bputc(&obuf, h->global_line>>24);
        outopd(&nullgen, 0);
        outopd(&g, 0);
    }
}
@
%ocaml: should not reuse same format than instruction
\t bug???? g.offset is used? do zaddr(&g, 0) but g.type = D_NONE
\t at this point which means the offset will not be used.
\n this was working for 8a, but not for 5a because zaddr()(x86) is different.

\t look at linker reading back code, expect a D_CONST here?

\t use 5l -v -W to see those AHISTORY and ANAME; it can help debug things

Again, just like for [[ANAME]], a new pseudo-opcode is used,
different from any other opcode, so that the linker
can just read one byte in the object file and decide
if the further bytes represent an instruction or an element
of the symbol table or a line history element:

<<[[Opcode]] cases, pseudo opcodes>>=
AHISTORY,
@

The [[Hist.filename]] is stored in the object file symbol table with [[ANAME]].
%
The full filename is actually split according to its directory
components and each component is stored separately with
its own entry in the object file symbol table.
\t why not full string? why split in components???

\l maybe good to take simplest case where have no #include, then output?

\ifallcode
<<[[outhist()]] locals(arm)>>=
char *q;
int n;
@
\fi

<<[[outhist()]] output each path component as an ANAME>>=
// =~ split("/", p) ...
while(p) {
    q = strchr(p, '/');
    if(q) {
        n = q-p;
        if(n == 0){
            n = 1;	/* leading "/" */
            *p = '/'; // redundant?
        }
        q++;
    } else {
        n = strlen(p);
        q = nil;
    }

    if(n) {
        Bputc(&obuf, ANAME);
        Bputc(&obuf, D_FILE);	/* type */ // symkind
        Bputc(&obuf, 1);	    /* sym */  // symidx
        Bputc(&obuf, '<');
        Bwrite(&obuf, p, n);
        Bputc(&obuf, '\0');
    }
    p = q;
    <<[[outhist()]] adjust p and op if p was a relative filename>>
}
@
\l why print each directory path separately?
%ocaml: Just use Str.split |> ... or simply Marshall

Note the use of the same symbol index above, [[1]], which normally
is incremented after each symbol is added in 
Section~\ref{sec:spreaded-symbol-table}.
This is because the code in the linker which loads the object file
treats specially those entries in the object file symbol table.
A new kind of symbol is also used:

<<sym_kind cases>>=
D_FILE,
@
\t useful? if remove symkind from ANAME, need that?


The code below is to convert relative filenames into
absolute paths. Indeed, The object file stores absolute filenames, 
which is better for [[db]] so that wherever [[db]] is run from, it can
find the source files referenced in the executable.
\n realpath spirit!
Remember that [[pathname]] below is the current working directory
set in [[cinit()]] in Section~\ref{sec:pathname}.

<<[[outhist()]] locals(arm)>>=
char *op;
@

<<[[outhist()]] adjust p and op if p is relative filename>>=
if(p && p[0] != '/' && h->local_line == 0 && pathname && pathname[0] == '/') {
    op = p; // save p
    p = pathname; // start with cwd
} else {
    op = nil; // start directly with p
}
@
%ocaml: Filename.concat, instead of being afraid to alloc and use op.
%old: I rewrote and put the nested if in the &&
\l #line directive are supposed to be absolute already?

<<[[outhist()]] adjust p and op if p was a relative filename>>=
if(p == nil && op) {
    p = op;
    op = nil;
}
@







\chapter{Advanced Topics}
\label{chap:advanced}

%trans:
We have described all the main features of Asm5 and [[5a]].
You can write many assembly programs with all the
instructions we described and 
have a working assembler with all the code we already presented.
%toc:
In this chapter we will described advanced features of Asm5
and [[5a]] which are more rarely used.
% actually start with Asm9, e.g. symbolic constants,
%, then advanced ARM instructions or registers
% mapped in Asm5, e.g. float
% then few more pseudo-opcodes, used only by 5c or 5l, no reading
% syntax

\section{Other assembly language features}

\subsection{Constant expressions}
\label{sec:constant-expr}

% it's not Fortran, we're making an assembler :)
% so it's constant expressions here!

% a bit tricky because we see AADD, AMUL, AAND,
% which corresponds to C operator, and here we use those
% C operators in the assembler itself.

<<type declarations(arm)>>=
%type   <lval>  con expr 
@

<<con rule>>=
| '(' expr ')' { $$ = $2; }
@
%$

% convenient to have this, when combined with macros it
% can do powerful stuff!



<<priority and associativity declarations>>=
%left   '|'
%left   '^'
%left   '&'
%left   '<' '>'
%left   '+' '-'
%left   '*' '/' '%'
@
% lower in the file = higher priority, earlier = lower priority

<<constant expression rules>>=
<<con rule>>
<<expr rule>>
@

<<expr rule>>=
expr:
  con
| expr '+' expr     { $$ = $1 + $3; }
| expr '-' expr     { $$ = $1 - $3; }
| expr '*' expr     { $$ = $1 * $3; }
| expr '/' expr     { $$ = $1 / $3; }
| expr '%' expr     { $$ = $1 % $3; }

| expr '<' '<' expr { $$ = $1 << $4; }
| expr '>' '>' expr { $$ = $1 >> $4; }

| expr '&' expr     { $$ = $1 & $3; }
| expr '^' expr     { $$ = $1 ^ $3; }
| expr '|' expr     { $$ = $1 | $3; }

@





\subsection{Symbolic constants}
\n useful, meh cpp can do that too. Was originally called Var, hmm

<<line rule(arm)>>=
| LNAME '=' expr ';'
 {
  $1->type = LVAR;
  $1->value = $3;
 }
| LVAR '=' expr ';'
 {
  if($1->value != $3)
   yyerror("redeclaration of %s", $1->name);
  $1->value = $3;
 }
@
%ocaml: get rid of, cpp can do that; no need lexer/parser coop then.

<<con rule>>=
| LVAR         { $$ = $1->value; }
@
%$
\n which can be derived by expr

\ifallcode
\subsection{Optional commas}
% the optional ',' why? because asm can ge generated by 5c -S that does
% this. A bit ugly so maybe better to aspectize this.
% actually I removed most of the use of comma for 5a/a.y 
% so maybe could even remove this rule, or keep it
% just for the comment about 5c -S.

<<opt rules>>=
comma:
  /* empty */
| ',' comma
@
\fi

\section{Other instructions and registers}

\subsection{Floats}
\n instructions and registers
\label{sec:float}

%AST
<<struct ieee>>=
struct	ieee
{
    long	l;	/* contains ls-man	0xffffffff */
    long	h;	/* contains sign	0x80000000
                    exp		0x7ff00000
                    ms-man	0x000fffff */
};
@
% ls/ms?
% FIGURE

%OPCODE

% Word, Double, Float? WDF?
<<[[Opcode]] cases, float mov opcodes>>=
AMOVWD,
AMOVWF,
AMOVDW,
AMOVFW,
AMOVFD,
AMOVDF,
AMOVF,
AMOVD,
@
<<[[itab]] elements>>=
"MOVD",		LMOV, AMOVD,
"MOVDF",	LMOV, AMOVDF,
"MOVDW",	LMOV, AMOVDW,
"MOVF",		LMOV, AMOVF,
"MOVFD",	LMOV, AMOVFD,
"MOVFW",	LMOV, AMOVFW,
"MOVWD",	LMOV, AMOVWD,
"MOVWF",	LMOV, AMOVWF,
@

<<[[Opcode]] cases, float arithmetic opcodes>>=
ACMPF,
ACMPD,
AADDF,
AADDD,
ASUBF,
ASUBD,
AMULF,
AMULD,
ADIVF,
ADIVD,
ASQRTF,
ASQRTD,
@
% SQRT is an instr?
<<[[itab]] elements>>=
"CMPF",		LCMPFLOAT, ACMPF,
"CMPD",		LCMPFLOAT, ACMPD,
"ADDF",		LARITHFLOAT,	AADDF,
"ADDD",		LARITHFLOAT,	AADDD,
"SUBF",		LARITHFLOAT,	ASUBF,
"SUBD",		LARITHFLOAT,	ASUBD,
"MULF",		LARITHFLOAT,	AMULF,
"MULD",		LARITHFLOAT,	AMULD,
"DIVF",		LARITHFLOAT,	ADIVF,
"DIVD",		LARITHFLOAT,	ADIVD,
"SQRTF",	LSQRTFLOAT, ASQRTF,
"SQRTD",	LSQRTFLOAT, ASQRTD,
@
%old: SQRTxx was LMISC (which was LTYPEI), but better LSQRTFLOAT

% commented in the original code
%/*
%    "ABSF",		LMISC, AABSF,
%    "ABSD",		LMISC, AABSD,
%    "NEGF",		LMISC, ANEGF,
%    "NEGD",		LMISC, ANEGD,
%    "SQTF",		LMISC,	ASQTF,
%    "SQTD",		LMISC,	ASQTD,
%    "RNDF",		LMISC,	ARNDF,
%    "RNDD",		LMISC,	ARNDD,
%    "URDF",		LMISC,	AURDF,
%    "URDD",		LMISC,	AURDD,
%    "NRMF",		LMISC,	ANRMF,
%    "NRMD",		LMISC,	ANRMD,
%*/


%REGISTERS

<<[[itab]] elements>>=
"F",		LF,	0,

"F0",		LFREG,	0,
"F1",		LFREG,	1,
"F2",		LFREG,	2,
"F3",		LFREG,	3,
"F4",		LFREG,	4,
"F5",		LFREG,	5,
"F6",		LFREG,	6,
"F7",		LFREG,	7,
"F8",		LFREG,	8,
"F9",		LFREG,	9,
"F10",		LFREG,	10,
"F11",		LFREG,	11,
"F12",		LFREG,	12,
"F13",		LFREG,	13,
"F14",		LFREG,	14,
"F15",		LFREG,	15,
@


<<[[itab]] elements>>=
"FPSR",		LFCR,	0,
"FPCR",		LFCR,	1,
@

<<enum fregister(arm)>>=
enum fregister {
    FREGRET = 0,
    /* compiler allocates register variables F0 up */
    FREGEXT = 7,
    /* compiler allocates external registers F7 down */
    FREGTMP = 15, // ??

    NFREG = 8,
};
@
% NFREG used by 5c/ in char	reg[NREG+NFREG];
% 8? looks like 16 above

% GRAMMAR

<<inst rule(arm)>>=
/*
 * floating-point coprocessor
 */
| LARITHFLOAT cond frcon ',' freg { outcode($1, $2, &$3, R_NONE, &$5); }
| LARITHFLOAT cond frcon ',' LFREG ',' freg { outcode($1, $2, &$3, $5, &$7); }
| LCMPFLOAT  cond freg ',' freg { outcode($1, $2, &$3, $5.reg, &nullgen); }
| LSQRTFLOAT cond freg ',' freg { outcode($1, $2, &$3, R_NONE, &$5); }
@
%$
\l could change LFREG and use a fregi?
% use again outcode! 

<<[[Operand_kind]] cases>>=
D_FREG,
D_FPCR,
@
% FPCR is the float pending of D_PSR?
% also FCONST we have seen before in core DS


<<type declarations(arm)>>=
%type <genval> freg fcon frcon
@

% for MOV
<<gen rule>>=
| freg
@

<<ximm rule>>=
| fcon
@

<<float rules>>=
freg:
  LFREG
 {
  $$ = nullgen;
  $$.type = D_FREG;
  $$.reg = $1;
 }
| LF '(' con ')'
 {
  $$ = nullgen;
  $$.type = D_FREG;
  $$.reg = $3;
 }

fcon:
 '$' LFCONST
 {
  $$ = nullgen;
  $$.type = D_FCONST;
  $$.dval = $2;
 }
| '$' '-' LFCONST
 {
  $$ = nullgen;
  $$.type = D_FCONST;
  $$.dval = -$3;
 }

frcon:
  freg
| fcon
@
%$



<<gen rule>>=
| LFCR
 {
  $$ = nullgen;
  $$.type = D_FPCR;
  $$.reg = $1;
 }
@
%$

% OBJECT CODE GENERATION

<<[[zaddr()]] cases(arm)>>=
case D_FREG:
case D_FPCR:
    break;
@

<<[[zaddr()]] cases(arm)>>=
case D_FCONST:
    ieeedtod(&e, a->dval);
    Bputc(&obuf, e.l);
    Bputc(&obuf, e.l>>8);
    Bputc(&obuf, e.l>>16);
    Bputc(&obuf, e.l>>24);
    Bputc(&obuf, e.h);
    Bputc(&obuf, e.h>>8);
    Bputc(&obuf, e.h>>16);
    Bputc(&obuf, e.h>>24);
    break;
@
% >> >> >> >> >> >> >> >> >>

% ?? -> <>
<<function ieeedtod>>=
void
ieeedtod(Ieee *ieee, double native)
{
    double fr, ho, f;
    int exp;

    if(native < 0) {
        ieeedtod(ieee, -native);
        ieee->h |= 0x80000000L;
        return;
    }
    if(native == 0) {
        ieee->l = 0;
        ieee->h = 0;
        return;
    }
    fr = frexp(native, &exp);
    f = 2097152L;		/* shouldnt use fp constants here */
    fr = modf(fr*f, &ho);
    ieee->h = ho;
    ieee->h &= 0xfffffL;
    ieee->h |= (exp+1022L) << 20;
    f = 65536L;
    fr = modf(fr*f, &ho);
    ieee->l = ho;
    ieee->l <<= 16;
    ieee->l |= (long)(fr*f);
}
@

<<constant FPCHIP(arm)>>=
#define	FPCHIP		true
@
% used only by a small if(FPCHIP) in cinit

\subsection{Multiplication and accumulation}

% multiply and accumulate
<<[[Opcode]] cases, mul/div/mod opcodes>>=
AMULA,
@
<<[[itab]] elements>>=
"MULA",		LMULA, AMULA,
@

<<inst rule(arm)>>=
/*
 * MULA hi,lo,r1,r2
 */
| LMULA cond reg ',' reg ',' reg ',' regi 
 {
  $7.type = D_REGREG;
  $7.offset = $9;
  outcode($1, $2, &$3, $5.reg, &$7);
 }
@
%$
% abuse offset, ADT would be better!
\l could use regreg here

<<[[Operand_kind]] cases>>=
D_REGREG,
@


\subsection{Long multiplication}
\n advanced topic, so can also put D_REGREG here

%\subsubsection{Mul long}

<<[[Opcode]] cases, mul/div/mod opcodes>>=
AMULL,
AMULAL,
AMULLU,
AMULALU,
@

<<[[itab]] elements>>=
"MULL",		LMULL, AMULL,
"MULAL",	LMULL, AMULAL,
"MULLU",	LMULL, AMULLU,
"MULALU",	LMULL, AMULALU,
@



% MULL special instruction?
<<inst rule(arm)>>=
/*
 * MULL hi,lo,r1,r2
 */
| LMULL cond reg ',' reg ',' regreg { outcode($1, $2, &$3, $5.reg, &$7); }
@
%$
% ugly $5.reg? why not use regi now?








<<type declarations(arm)>>=
%type   <genval>   regreg
@

<<operand rules(arm)>>=
/* for MULL */
regreg:
 '(' regi ',' regi ')'
 {
  $$ = nullgen;
  $$.type = D_REGREG;
  $$.reg = $2;
  $$.offset = $4;
 }
@
% abuse offset again ... grrr



<<[[zaddr()]] cases(arm)>>=
case D_REGREG:
    Bputc(&obuf, a->offset);
    break;
@



\subsection{Multiple registers move}
\label{sec:movm}

% move many?
<<[[Opcode]] cases, mov opcodes>>=
AMOVM,
@

<<[[itab]] elements>>=
"MOVM",		LMOVM, AMOVM,
@
%in lproc.s 
%	RFE				/* MOVM.IA.S.W (R13), [R15] */

%todo: abuse D_CONST again, why not D_MULTI instead?

<<inst rule(arm)>>=
/*
 * MOVM
 */
| LMOVM cond ioreg ',' '[' reglist ']'
 {
  Gen g;

  g = nullgen;
  g.type = D_CONST;
  g.offset = $6;
  outcode($1, $2, &$3, R_NONE, &g);
 }
| LMOVM cond '[' reglist ']' ',' ioreg
 {
  Gen g;

  g = nullgen;
  g.type = D_CONST;
  g.offset = $4;
  outcode($1, $2, &g, R_NONE, &$7);
 }
@


<<type declarations(arm)>>=
%type   <lval>  reglist
@


<<reglist rule>>=
reglist:
  regi           { $$ = 1 << $1; }
| regi '-' regi
 {
  int i;
  $$=0;
  for(i=$1; i<=$3; i++)
      $$ |= 1<<i;
  for(i=$3; i<=$1; i++)
      $$ |= 1<<i;
 }
| regi ',' reglist { $$ = (1<<$1) | $3; }
@
%$
%old: was using comma here



%\section{Misc instructions}

% seems dead
%<<[[Opcode]] cases, misc opcodes>>=
%ABX, // ?
%ABXRET, // ?
%@
%<<[[itab]] elements>>=
%"BX",		LTYPEBX,	ABX,
%@
%<<inst rule(arm)>>=
%/*
% * BX
% */
%| LTYPEBX comma ireg { outcode($1, Always, &nullgen, R_NONE, &$3); }
%@

%dead: ADWORD, // ? no reading syntax

% have reading syntax, but not transformed by 5l ... not handled,
%<<[[Opcode]] cases, misc opcodes>>=
%ALDREX,
%ASTREX,
%ALDREXD,
%ASTREXD,
%@
%% LDREX STREX CLREX are arm v7 new instruction according to 5db.c
%% actually they are defined as macros in atom.s:
%%#define	CLREX		WORD	$0xf57ff01f
%%#define	LDREX(a,r)	WORD	$(0xe<<28|0x01900f9f | (a)<<16 | (r)<<12)
%%/* `The order of operands is from left to right in dataflow order' - asm man */
%%#define	STREX(v,a,r)	WORD	$(0xe<<28|0x01800f90 | (a)<<16 | (r)<<12 | (v)<<0)
%
%<<[[itab]] elements>>=
%"LDREX",		LMOV, ALDREX,
%"LDREXD",		LMOV, ALDREXD,
%"STREX",		LSWP, ASTREX,
%"STREXD",		LSWP, ASTREXD,
%@

% from arm.s
%#define ISB	\
%	MOVW	$0, R0; \
%	MCR	CpSC, 0, R0, C(CpCACHE), C(CpCACHEinvi), CpCACHEwait
%
%#define DSB \
%	MOVW	$0, R0; \
%	MCR	CpSC, 0, R0, C(CpCACHE), C(CpCACHEwb), CpCACHEwait
%
%#define	BARRIERS	ISB; DSB
%
%#define MCRR(coproc, op, rd, rn, crm) \
%	WORD $(0xec400000|(rn)<<16|(rd)<<12|(coproc)<<8|(op)<<4|(crm))
%
%#define OKAY \
%	MOVW	$0x7E200028,R2; \
%	MOVW	$0x10000,R3; \
%	MOVW	R3,(R2)

\subsection{Status register}

% status register, works with MOV but normally it's a special
% ARM load/store instructions: MSR and MRS (here emulated by a single MOV)
% CPSR = ? SPSR = ?
<<[[itab]] elements>>=
"CPSR",		LPSR,	0,
"SPSR",		LPSR,	1,
@
% CPSR is maybe system status register, see l.s where
% do
%	MOVW	$(PsrDirq|PsrDfiq|PsrMsvc), R1
%	MOVW	R1, CPSR
% related to conditional execution???

% MSR = Status to Register, and Register to Status?

<<[[Operand_kind]] cases>>=
D_PSR,
@
% similar to D_REG really, just with special register, so reg field
% is enum<registr> | enum<status_registr>

<<[[zaddr()]] cases(arm)>>=
case D_PSR:
    break;
@

<<gen rule>>=
| LPSR
 {
  $$ = nullgen;
  $$.type = D_PSR;
  $$.reg = $1;
 }
@
%$
% Status register? move earlier? 


\subsection{Coprocessors}

% Already seen 2 system instructions: SWI and RFE. Here are a few more.

% no Axxx opcode, binary generation directly in action via D_CONST
<<[[itab]] elements>>=
"MCR",		LSYSTEM, 0,
"MRC",		LSYSTEM, 1,
@

<<inst rule(arm)>>=
/*
 * MCR MRC
 */
| LSYSTEM cond con ',' expr ',' regi ',' creg ',' creg oexpr
 {
  Gen g;

  g = nullgen;
  g.type = D_CONST;
  g.offset =
   (0xe << 24) |    /* opcode */
   ($1 << 20) |     /* MCR/MRC */
   ($2 << 28) |     /* scond */
   (($3 & 15) << 8) |   /* coprocessor number */
   (($5 & 7) << 21) |   /* coprocessor operation */
   (($7 & 15) << 12) |  /* arm register */
   (($9 & 15) << 16) |  /* Crn */
   (($11 & 15) << 0) |  /* Crm */
   (($12 & 7) << 5) |   /* coprocessor information */
   (1<<4);          /* must be set */ // opcode component
  outcode(AWORD, Always, &nullgen, R_NONE, &g);
 }
@
% >> >> >> >> >> >> >> >> >> >>
% use of WORD!

<<type declarations(arm)>>=
%type   <lval>  creg
@

<<creg rule>>=
creg:
  LCREG
| LC '(' expr ')'
 {
  if($3 < 0 || $3 >= NREG)
      print("register value out of range\n");
  $$ = $3;
 }
@
%$

<<[[itab]] elements>>=
"C",		LC,	0,

"C0",		LCREG,	0,
"C1",		LCREG,	1,
"C2",		LCREG,	2,
"C3",		LCREG,	3,
"C4",		LCREG,	4,
"C5",		LCREG,	5,
"C6",		LCREG,	6,
"C7",		LCREG,	7,
"C8",		LCREG,	8,
"C9",		LCREG,	9,
"C10",		LCREG,	10,
"C11",		LCREG,	11,
"C12",		LCREG,	12,
"C13",		LCREG,	13,
"C14",		LCREG,	14,
"C15",		LCREG,	15,
@


<<type declarations(arm)>>=
%type   <lval>  oexpr 
@

% other optional stuff
<<oexpr rule>>=
/* for MCR */ 
oexpr:
  /* empty */ { $$ = 0; }
| ',' expr    { $$ = $2; }
@
%$



\subsection{Special bits}
\label{sec:special-bits}

% sign? long? p bit, w bit, ???

<<cond rule(arm)>>=
| cond LS    { $$ = $1 | $2; }
@

<<[[itab]] elements>>=
".S",		LS,	C_SBIT,
".U",		LS,	C_UBIT,
".W",		LS,	C_WBIT,
".P",		LS,	C_PBIT,
@
% .S can be used for arithmetic operations, to set condition code

<<constant C_SBIT(arm)>>=
#define	C_SBIT	(1<<4)
@
% >>
\l after cond which use 4 bits (16 possibilities)


<<constant C_PBIT(arm)>>=
#define	C_PBIT	(1<<5)
@
% >>

<<constant C_WBIT(arm)>>=
#define	C_WBIT	(1<<6)
@
% >> >> >> >> 

<<constant C_UBIT(arm)>>=
#define	C_UBIT	(1<<7)	/* up bit */
@
% >>



% composite
<<[[itab]] elements>>=
".PW",		LS,	C_WBIT|C_PBIT,
".WP",		LS,	C_WBIT|C_PBIT,
@
\l meh

% composite or alternate form
<<[[itab]] elements>>=
".IBW",		LS,	C_WBIT|C_PBIT|C_UBIT,
".IAW",		LS,	C_WBIT|C_UBIT,
".DBW",		LS,	C_WBIT|C_PBIT,
".DAW",		LS,	C_WBIT,

".IB",		LS,	C_PBIT|C_UBIT,
".IA",		LS,	C_UBIT,
".DB",		LS,	C_PBIT,
".DA",		LS,	0,
@
% some seems redundant like .DB and .P, .U and .IA, etc

% see asm.ps ARM section: "addressing modes are supported by suffixes
% of the instruction, IA = increment after, IB = increment before, ..."
% it can be used only with the MOV instruction

<<constant C_FBIT(arm)>>=
#define	C_FBIT	(1<<7)	/* psr flags-only */
@
% >>

<<[[itab]] elements>>=
".F",		LS,	C_FBIT,
@


\section{Other pseudo-opcodes}

\subsection{Compiler-only}
\l or virtual?

% because actually opcodes was written before 5a :)
 

% some of those are not really opcodes, they are entities 
% just at the asm AST level produced internally by 5c.
% they have no reading syntax.
% ANOP is here. No reading syntax.

% related to NOP, SHL, MOV, pseudo asm
% that get translated in store/load on some archi.


% only used by 5c
<<[[Opcode]] cases, pseudo opcodes>>=
ACASE,
ABCASE,
@
% BCASE = branch case

% actually they used to have a read syntax, but I didn't see any code
% using them so I commented the code.
%<<[[itab]] elements>>=
%"CASE",		LTYPED, ACASE,
%"BCASE",	LBCOND,	ABCASE,
%@
%<<inst rule(arm)>>=
%/*
% * CASE
% */
%| LTYPED cond reg comma { outcode($1, $2, &$3, R_NONE, &nullgen); }
%@
%$


<<[[Opcode]] cases, mul/div/mod opcodes>>=
AMULU,
ADIVU, // VIRTUAL, transformed to call to _divu
AMODU, // VIRTUAL, transformed to call to _modu
@
% has no reading syntax, generated just in 5c

<<[[Opcode]] cases, pseudo opcodes>>=
ASIGNAME,
@
% for signatures checking, generated just in 5c
% really an extended ANAME with signature information (md5sum of the
% type, which for a structure is a md5sum of all its components, so
% pretty safe)


% not pseudo opcodes but related to compile-only opcodes. Here are other 
% constants defined in 5.out.h that are used only
% in compiler context.
% for 5c! conventions! (not used at all by 5a, but in 5.out.h for other tools)
<<[[Register]] compiler conventions cases>>=
REGRET =	0,
REGARG =	0,
@
% mv earlier? but cant put too early

<<[[Register]] compiler conventions cases>>=
/* compiler allocates R1 up as temps */
/* compiler allocates register variables R2 up */
REGMIN =	2,
REGMAX =	8,
REGEXT =	10, // R9/R10 possible 'extern register xxx;'
/* compiler allocates external registers R10 down */
REGTMP =	11,
@
% hmm regxxx is not really an enum as REGREG = REGARG, but still useful.

%old:    /* used by the loader for thumb code */
%    REGTMPT =		7,
% no REGFP??

\subsection{Linker-only}

<<[[Opcode]] cases, pseudo opcodes>>=
AGOK,
@
% GOK =? God only Knows? speciak mark?
% actually used in both compiler and linker
% but I think it's used only for zprg, and in ldobj it's an error
%less: maybe we could delete it, and just use AXXX or ALAST or ANOP instead.
%old: there was a D_GOK, but it was unused in 5a/5c/5l

% not sure it's linker-only pseudo opciodes, could be also compiler
% specific
<<[[Opcode]] cases, pseudo opcodes>>=
ADYNT,
AINIT,
@
% seems never assigned, maybe not used anymore? seems about
% dynamic loading, alef stuff maybe?
%todo: delete?


% related to linker again, in addition to D_FILE there is:
<<sym_kind cases>>=
D_FILE1, // used by linker only?
@
%todo: delete?

%dead: #define	ALLTHUMBS	(1<<2)

\section{[[TEXT]] attributes}
\label{sec:attributes}
\l also for GLOBL?

%Again not an opcode, but related. Where this bit is stored?
%I think in the middle reg of an instruction for opcodes like ATEXT.
%It is used by 5l e.g. to allow override existing symbol.
%I think it's for TEXT and DATA instructions and its reg field
% (that should be unused for TEXT and DATA)
<<constant DUPOK(arm)>>=
#define DUPOK		(1<<1)
@

%less: transform in an enum with DUPOK
% note that it's not used by 5a, used by 5c/5l when have a special #pragma
<<constant NOPROF(arm)>>=
#define NOPROF		(1<<0)
@

\section{[[#pragma lib]] and automagic linking}
\n related to linker-only but better separate

% this is very very nice! remove so much headache,
% no need ocamlfind, no need pkg-config, so simple ...

% the object can contain information about which
% lib you want to link with!

% less useful in assembly than in .c, but because anyway it's
% an object file property, it's also in the assembler (that generate
% object files).

<<[[macprag()]] locals>>=
Hist *h;
char *hp;
int c0, c;
@

<<[[macprag()]] if pragma lib>>=
if(s && strcmp(s->name, "lib") == 0) {
    c0 = getnsc();
    if(c0 != '"') {
        c = c0;
        if(c0 != '<')
            goto bad;
        c0 = '>';
    }
    for(hp = symb;;) {
        c = getc();
        if(c == c0)
            break;
        if(c == '\n')
            goto bad;
        *hp++ = c;
    }
    *hp = '\0';
    c = getcom();
    if(c != '\n')
        goto bad;

    /*
     * put pragma-line in as a funny history 
     */
    c = strlen(symb) + 1;
    while(c & 3)
        c++;

    hp = malloc(c);
    memcpy(hp, symb, c);

    h = alloc(sizeof(Hist));
    h->filename = hp;
    h->line = lineno;
    h->local_line = -1; // special mark, ugly

    h->link = H;
    if(ehist == H) {
        hist = h;
        ehist = h;
        return;
    }
    ehist->link = h;
    ehist = h;

    return;

bad:
    unget(c);
    yyerror("syntax in #pragma lib");
    macend();

}
@
%less ugly would be to have object attribute (in addition to
% text/data attributes)


\section{Processing multiple files}

% why need that? people cant write mkfiles?

<<[[main()]] locals>>=
int nout, nproc, status;
int i, c;
@

<<[[main()]] multiple files handling>>=
if(argc > 1) {
    nproc = 1;
    if(p = getenv("NPROC"))
        nproc = atol(p);	/* */
    c = 0;
    nout = 0;
    for(;;) {
        while(nout < nproc && argc > 0) {
            i = fork();
            if(i < 0) {
                i = mywait(&status);
                if(i < 0)
                    errorexit();
                if(status)
                    c++;
                nout--;
                continue;
            }
            if(i == 0) {
                print("%s:\n", *argv);
                if(assemble(*argv))
                    errorexit();
                exits(0);
            }
            nout++;
            argc--;
            argv++;
        }
        i = mywait(&status);
        if(i < 0) {
            if(c)
                errorexit();
            exits(0);
        }
        if(status)
            c++;
        nout--;
    }
}
@

%\section{Thumb code}
% arg processing: (but then no more generic across 5a/ and 8a/)
%
%    case 't':
%        thechar = 't';
%        thestring = "thumb";
%        break;





\chapter{Conclusion}
\label{chap:conclusion}

You now know how the \plan ARM assembler [[5a]] works,
to the smallest details, and more generally how many 
assembler works.

\l could take original questions in intro one by one, itemized
\l and explain or point to places in the book that explains

%dup: from intro/5a BUT too many dup so commented.
%The ARM machine code generation is not done by [[5a]] though,
%but by the linker [[5l]] which is a bit unconventional.
%So, we recommend to follow with the \book{Linker} to
%understand this part. In any case, 
The linker and assembler
being strongly connected in any system, for instance [[ld]] and [[gas]]
are part of the same [[binutils]] package in the GNU system,
the \book{Linker} is the logical next step after the \book{Assembler}.
%
We also suggest to read the \book{Emulator} which fully
describes the semantics of the machine instructions we have
seen in this book.
The \book{Debugger} contains code to {\em disassemble}
machine code which also relates to this book.
Finally, reading the \book{Compiler} will now be easier now
that you can understand the assembly code generated by the compiler [[5c]].

%missing features: ORG, but ld can do -Txx


\appendix

\chapter{Debugging}
\label{chap:debugging-appendix}

% debugging 5a itself, not debugging support as in chapter X.

% not very powerful debugging options for 5a, mostly stuff
% to debug cpp related issues.
% less: 5l has actually more stuff, with dumpers for Gen, opcode, etc.
% e.g. 5l -v -W is pretty useful as it helps debug the object loading,
% so maybe we could reuse some of this code here.

% ex: 'm', 'f' (256 so can have for each character a boolean value)
<<global debug>>=
bool	debug[256];
@

<<[[main()]] debug initialization>>=
memset(debug, false, sizeof(debug));
@

<<[[main()]] command line processing>>=
default:
    c = ARGC();
    if(c >= 0 || c < sizeof(debug))
        debug[c] = true;
    break;
@

\section{[[5a -m]], macro debugging}
% m for macro

<<[[dodefine()]] debug>>=
if(debug['m'])
    print("#define (-D) %s %s\n", s->name, s->macro+1);
@

<<[[macdef()]] debug>>=
if(debug['m'])
    print("#define %s %s\n", s->name, s->macro+1);
@

\section{[[5a -f]], line information debugging}
\label{sec:debug-line}

<<[[linehist()]] debug>>=
if(debug['f'])
    if(f) {
        if(local_line)
            print("%4ld: %s (#line %d)\n", lineno, f, local_line);
        else
            print("%4ld: %s\n", lineno, f);
    } else
        print("%4ld: <pop>\n", lineno);
@

% see section X for example of output


\chapter{Error Managment}
\label{chap:error}

<<function errorexit>>=
/// main | assemble | yyerror | ... -> <>
void
errorexit(void)
{

    if(outfile)
        remove(outfile);
    exits("error");
}
@

<<global nerrors>>=
int	nerrors = 0;
@
% used to be initialized in cinit()

<<function yyerror>>=
/// assemble | yylex | yyparse | ... -> <>
void
yyerror(char *a, ...)
{
    char buf[200];
    va_list arg;

    <<[[yyerror()]] when called from yyparse>>

    prfile(lineno);

    va_start(arg, a);
    vseprint(buf, buf+sizeof(buf), a, arg);
    va_end(arg);

    print("%s\n", buf);

    nerrors++;
    if(nerrors > 10) {
        print("too many errors\n");
        errorexit();
    }
}
@

% could put prfile here, but can be better before to help
% illustrate how to use Hist

<<[[yyerror()]] when called from yyparse>>=
/*
 * hack to intercept message from yaccpar
 */
if(strcmp(a, "syntax error") == 0) {
    yyerror("syntax error, last name: %s", symb);
    return;
}
@


\chapter{Utilities}
\label{chap:libc}

\section{Memory managment}
\label{sec:memory}

% same in Linker, not sure why they just don't use malloc?
% to avoid dependencies to libc? for bootstrapping reasons?

<<global hunk>>=
char*	hunk;
@

<<global nhunk>>=
long	nhunk = 0;
@
% used to be set in cinit()

<<global thunk>>=
long	thunk;
@

<<constant NHUNK>>=
#define	NHUNK		10000
@


<<function gethunk>>=
void
gethunk(void)
{
    char *h;
    long nh;

    nh = NHUNK;
    if(thunk >= 10L*NHUNK)
        nh = 10L*NHUNK;

    h = (char*)sbrk(nh);
    if(h == (char*)-1) {
        yyerror("out of memory");
        errorexit();
    }
    hunk = h;
    nhunk = nh;
    thunk += nh;
}
@



<<constant MAXALIGN>>=
#define MAXALIGN 7
@

<<function alloc>>=
/*
 * real allocs
 */
void*
alloc(long n)
{
    void *p;

    while((uintptr)hunk & MAXALIGN) {
        hunk++;
        nhunk--;
    }

    while(nhunk < n)
        gethunk();
    p = hunk;
    nhunk -= n;
    hunk += n;

    return p;
}
@

<<function allocn>>=
void*
allocn(void *p, long on, long n)
{
    void *q;

    q = (uchar*)p + on;
    if(q != hunk || nhunk < n) {

        while(nhunk < on+n)
            gethunk();
        memmove(hunk, p, on);
        p = hunk;
        hunk += on;
        nhunk -= on;

    }
    hunk += n;
    nhunk -= n;
    return p;
}
@
% there is no free!!?



\chapter{Examples of Assembly Programs}
\label{chap:examples}

\section{[[hello2.s]] and [[pwrite.s]]}

\n seen [[helloworld.s]] before
\l could put simplified hello world here? with 5l -v -W ?
\l and 5i machine trace?

% or 5c -S ?
% also pwrite.s ! so see conv from C to kernel calling convention

\section{[[getcallerpc.s]]}
%lib_core/libc/arm/

\t getcallerpc? help illustrates calling convention? or too subtle?
% but for sure this needs to be written in assembly!

\l getcallerpc code? with special minus 4
%TEXT getcallerpc(SB), 1, $-4
%	MOVW	0(R13), R0 /* R13 = SP */
%	RET
% 1 attribute??? need diagram again


\section{[[main9.s]]}
\n lib_core/libc/arm/main9.s (and main9p.s) would be good 
\n (but the master version should be sync with \book{Core Libraries})

\section{[[tas.s]]}

\section{[[div.s]]}
\label{sec:_divmod}

The [[_div]] function in [[lib_core/libc/arm/div.s]]
implements in software the integer division since
the ARM has no [[DIV]] instruction.

\t how called? generated code in 5l for DIV?

<<function _div>>=
TEXT	_div(SB), 1, $16
	BL	save<>(SB)
	CMP	$0, R(Q)
	BGE	d1
	RSB	$0, R(Q), R(Q)
	CMP	$0, R(D)
	BGE	d2
	RSB	$0, R(D), R(D)
d0:
	BL	div<>(SB)		/* none/both neg */
	MOVW	R(Q), R(TMP)
	B	out
d1:
	CMP	$0, R(D)
	BGE	d0
	RSB	$0, R(D), R(D)
    // Fallthrough
d2:
	BL	div<>(SB)		/* one neg */
	RSB	$0, R(Q), R(TMP)
	B	out

out:
	BL	rest<>(SB)
	B	out
@


\l using more basic instruction, cant use DIV or MOD. use? bit shift??


The [[_mod]] function in [[lib_core/libc/arm/div.s]]
implements in software the integer modulo since
the ARM has no [[MOD]] instruction.

<<function _mod>>=
TEXT	_mod(SB), 1, $16
	BL	save<>(SB)
	CMP	$0, R(D)
	RSB.LT	$0, R(D), R(D)
	CMP	$0, R(Q)
	BGE	m1
	RSB	$0, R(Q), R(Q)
	BL	div<>(SB)		/* neg numerator */
	RSB	$0, R(N), R(TMP)
	B	out
m1:
	BL	div<>(SB)		/* pos numerator */
	MOVW	R(N), R(TMP)
	B	out
@

\chapter{[[5a]] in OCaml}
\label{chap:5a-ocaml}
\n LFS thesis spirit :)

% design decisions: 
% - no optimisations, space or speed, which guides many of the
%   other decisions below.
% - external cpp, and really external,
%   not even -D, -I. Can do that in Makefile with %.s : %.S   cpp ...
% - no symbolic constant feature, redundant with cpp
% - use Lex instead of handcoded lexer 
%   (maybe related to previous point)
% - object file is marshalled form of ocaml AST. Far simpler!
%   (but less open to other languages; could use JSON but no ADT in JSON)
% This decrements size of code, but also size of needed explanations!

% Nice also because offer another "view". Can see full grammar for
% instance below. Full AST. Instead of piece by piece in the main text.
% Maybe help solidify even more.

\section{[[ast_asm.ml]]}

\section{[[main.ml]]}

\section{[[parse_asm.ml]]}
% and mli

\section{[[lexer_asm.mll]]}

\section{[[parser_asm.mly]]}
% small notes on List.rev opti because quadratic @

\section{[[resolve_labels.ml]]}
% and mli

\section{[[object_code.ml]]}
% and mli

\section{[[common.ml]]}

\chapter{Extra Code}

\ifallcode
#include "Assembler_extra.nw"
#include "Assembler_x86.nw"
\fi

%\chapter{Changelog}
%\label{sec:changelog}
% code via make loc = 4100 LOC
% orig Assembler.nw = 6000 LOC, just lpized and comments in sections
% now: 10000 LOC? so added 4000 LOE (Lines of explanations)

\chapter*{Glossary}
\addcontentsline{toc}{chapter}{Glossary}
\label{sec:glossary}

\begin{verbatim}
ISA = Instruction Set Architecture
AST = Abstract Syntax Tree
PC = Program Counter (register)
SP = Stack Pointer (register)
FP = Frame Pointer (register)
SB = Static Base (register)
BL = Branch and Link
RISC = Reduced Instruction Set Computer
CISC = Complex Instruction Set Computer
ARM  = Akorn Risc Machines
CWD = Current Working Directory
EOF = End Of File
IGN = Ignore
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{chapter}{Index}

%\chapter{References} 
\addcontentsline{toc}{chapter}{References}

\bibliography{../docs/latex/Principia}
\bibliographystyle{plain}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
