\documentclass[twocolumn]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse % see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things:
%  - better organisation of the code, TOC better than the few existing
%    files (that didn't have very good names)
%  - removed deadcode (Ref, imm2, con2, NMACRO, CLAST, isreg, D_GOK,...)
%  - renamed some enums (as => opcode, _ => operand_kind)
%  - reordered opcodes and operand kinds, and cleaned them
%  - introduced name_kind, splitted from operand_kind, for ANAME
%  - factorize more code between arm and x86 (abusing LP chunks)
%  - TODO rename types, clearer, Gen? as Adr (and Gen2? as Prog?)

%thx to codemap/codegraph/scheck:
% - factorized code in aa/
% - TODO mv errorexit, alloc, in utils.c instead of lexbody.c, same for gethunk
% - TODO main.c

%thx to this manual, better understand assembly?:
% - can actually understand the assembly code in Kernel.nw :)
% - DATA vs GLOBL?
% - fpic?

%history LP-ization:
% - skeleton, mostly copy paste of Template.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * TODO ctor/dtor, dumper
%    * SEMI [[xxx]] other fields, [[xxx]] extra fields
% - read Extra section, identify concepts, first TOC
% - distribute parts of the file before
% - SEMI nullify, boolify, typeify,    scheckify
% - aspecify advanced features!
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\iffinal
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\fi
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
%\usepackage{cleveref} %\cref
%\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}
 %\usepackage[margin=0.5in]{geometry}
 %  but eat the bottom when very low
 %\usepackage{fullpage} is deprecated 
 % => do the more manual below:
 \addtolength{\oddsidemargin}{-.850in}
 \addtolength{\evensidemargin}{-.850in}
 \addtolength{\textwidth}{1.70in}
 \addtolength{\topmargin}{-.850in}
 \addtolength{\textheight}{1.70in}
%\usepackage{minitoc}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% used for forward decl, pragmas, func decl, extern decl, stats, #ifdef,
% debugging macros

%\setcounter{tocdepth}{1}

%******************************************************************************
% Title
%******************************************************************************

\begin{document}

\title{
{\Huge 
Principia Softwarica: The Plan9 Assembler [[5a]]
}\\
ARM (32 bits) edition\\
{version 0.1}
}
%8a x86 (32 bits) edition

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}
}

\maketitle 
\onecolumn
\hrule
\begin{quote}
    Copyright \copyright{} 2014 Yoann Padioleau \\
    Permission is granted to copy, distribute and/or modify this document,
    except all the source code it contains, under the terms of the GNU Free
    Documentation License, Version 1.3.
\end{quote}
\hrule

%CONFIG: \dominitoc

\iffinal
\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\twocolumn
\tableofcontents
\endgroup
\else
\tableofcontents
\fi

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

\section{Motivations}

The goal of this book is to present in full details the source code of
an assembler.
Why? Because I think it makes you a better programmer if
you fully understand how things work under the hood.

% we gonna focus on plan9 assemblers because
% they are simple, short code, and consistent with the rest of my
% endeavour :)
% we choose 5a, simpler than 8a: ARM RISC simpler than x86 CISC. Moreover
% we have the full executable spec of ARM in 5i/! so it helps to understand
% the semantic of the ASM instructions.

%note: better to do manual with ARM for assembler/compiler/linker. Simpler.
% Using x86 also make it more error prone when want to change things
% because we would have also to change kencc (e.g. error prone to change
% the order of asm instructions).

Here are other candidates that were considered but ultimately discarded:
\begin{itemize}
\item gas
\item nasm
\item dev86
\end{itemize}

% a disadvantage of 5a is that it generates just a special kind of object
% code, the actual machine code is done in the linker. A bit unusual.

% hex2c
%less: there is also one in subc-2014


\section{Getting started}

% see Kernel.nw section?

\section{Requirements}

% know at least one assembler, labels, mov, SP, FP, jmp, etc
% know a bit about architecture (helps to understand Machine.nw)

% asm.ps, 5a(1)

\section{About this document}
#include "../docs/latex/About.nw"

\section{Copyright}

Most of this document is actually source code from Plan9, so
those parts are copyright by Lucent Technologies Inc.
The prose is mine and is licensed under the GNU Free Documentation
License.

\section{Acknowledgments}


\chapter{Overview}

\section{Assembler principles}

% mnemonic and symbolic addresses -> object/machine code

% before was writing binary, then mnemonic but still hardcoded
% address, and then finally symbolic addresses.

% usually 2 passes as can reference stuff coming later. pretty simple.

% less: look at TECS section on assembler?

\section{[[5a]] services}

% command line interface? -o outfile,   -D -I (cpp),  -f -m for debug

% env: INCLUDE (for cpp, similar to -I), NPROC (when multi files?)


% can also have some simple constant expression
% can also have macros and includes!
% (really convenient, can define new instructions thx to macro & bitshift as in:
%  #define MCRR(coproc, op, rd, rn, crm) \
% 	WORD $(0xec400000|(rn)<<16|(rd)<<12|(coproc)<<8|(op)<<4|(crm))

% normally generate (relocatable) machine code, but here 5a is actually
% a bit unusual.
% 5a also support some virtual opcode, to go around some of the restrictions
% of certain architecture, so have a very general MOV even though
% the actual archi supports only simple LOAD/STORE.


\section{[[helloworld.s]]}

%todo: print "hello world" with mov, call, int, etc? with no libc!
% (and a _main (or even just _start?))

% show commands, 5a, ld, ./xxx

% can also maybe show one that use libc, use 5c -S hello.c

% show binary format? hexdump? 
% (actually not binary instruction format! see section below)

% try show code using TEXT, DATA, GLOBL, different addressing modes, etc
% show the advantage of assembly, that is mnemonic and symbolic addresses!
% maybe good to show a few more example of asm, to get a feel for the language
% e.g. the code of strchr, div, etc.

\section{ARM}

% opcode format, see 5i/
% but actually it's more the job of 5l and optab to do that.
% 5a just try to mimic closely the ISA (but actually it also
% introduce virtual/fake opcodes).

\section{Input assembly language}

% specifics of 5a? like left to right or right to left for mv, intel
% or AT&T syntax (I guess AT&T :) )

% the different addressing modes for MOV.

% 8 bytes limit for strings (so if longer have to split manually,
% a bit annoying but can use data2s too)

%concepts: 
% - labels suffixed with :
% - constants, prefixed with $ (why? to avoid ambiguity with what?)
%   otherwise regular numbers are offset like 32(SP)
% - external symbols = fully unresolved! will be resolved at linking time
%   but needs to keep the name in the symbol table and the place where it
%   was referenced

%        LONG    $-(0x1BADB002 + 0x00010003)     /* checksum */
%vs
%        LONG    $_start-KZERO(SB)          /* load_addr */
%why need SB in second case? because it refers to symbol in certain section?

% special registers for addressing: PC, SB, FP, SP
% for text, data, param, locals

\section{Output object format}

% .5 format? a kind of .o, but 5l does actually the job to turn into ARM ISA
% so it's really more a marshalled file of simple data structures that is
% ARM specific only because of the set of opcode and registers really.

%note: should really simplify the code at some point and use Ocaml/Rust
% and just marshall the ADT, and do same in linker => shorter code!

\section{Code organization}

\section{Architecture overview}

% arch generic: aa/, arch specific: xa/
% same for header, common.out.h and arm/5.out.h or 386/8.out.h!

%actually lots of assembler related stuff is in libmach/
%and lots in the linker.

% mac.c = macro (not macos)

% relation with other tools? 5c, 5l? easy, do for instance:
% git grep AADDB
%assemblers/8a/lex.c:    "ADDB",		LTYPE3,	AADDB,
%compilers/8c/peep.c:    case AADDB:	/* rhs rar */
%compilers/8c/reg.c:        case AADDB:
%compilers/8c/txt.c:            a = AADDB;
%include/386/8.out.h:    AADDB,
%linkers/8l/optab.c:    { AADDB,	yxorb,	Px, 0x04,0x80,(00),0x00,0x02 },

% assembler actually generate a binary that is ARM specific, but not 
% matching the ARM instruction set! asm.c is doing the real conversion
% (why? because 5l does some inter-lib optimizations? a la llvm? nice design!?)
% it generates an "object", a kind of .o except it's really not a .o like
% in Linux :) it's a serialized/marshalled data structure (opcode+operands+...)

% text -> grammar -> symbols -> codegen
% does not really use an AST, abuse tokens and the grammar to
% do some computations (the classic old way to do things)

% main -> assemble -> yyparse -> yylex
%                             -> outcode that increments pc and in pass2 output

%###############################################################################

\chapter{Core Data Structures}

% first 3 sections are really about AST: opcode, register, operand_kind/Gen.

\section{[[Opcode]]}

% arm/5.out.h
<<enum as(arm)>>=
// coupling: with 5c/enam.c
enum opcode
{
    AXXX,

    ANOP,
    <<logic opcodes>>
    <<add/sub opcodes>>
    <<mul/div/mod opcodes>>
    <<comparison opcodes>>
    <<bitshift opcodes>>

    <<branching opcodes>>

    <<mov opcodes>>
    <<swap opcodes>>

    <<interrupt opcodes>>

    <<float mov opcodes>>
    <<float arithmetic opcodes>>
    <<misc opcodes>>

    <<pseudo opcodes>>

    ALAST,
};
@
%note: was called 'enum as'
%note: the enum must contain less than 256 elements, as we rely on 
% sending ANAME as a byte in zname()).
%note: I reordered a lot the original opcodes. Note that it can be dangerous
% for backward compatiblity to do so. Indeed
% 'ld' and 'as' need to agree with each other; one can't use a library
% compiled (or cross compiled) using a 5l relying on a certain order,
% and link object files compiled by a 5a relying on another order.
% So can have some subtle errors if want to play with what is cross-compiled!
% So make sure to recompile your libc if you modify 5l or 5a or 5.out.h
%less: Could analyze *.s in plan9 and do some
% stats? or use cg on the whole plan9 and see how much AXXX is used

% Mimic closely ISA of ARM. Actual machine opcodes.
% But also pseudo opcodes (asm directives) like ATEXT. 
% And also "virtual" opcodes! ANOP is such a virtual/fake opcode.
% also RET, MOV, SLL, BEQ, etc.

% Note that the actual binary code generation is done in the linker, so
% the order of the opcode below does not have to match the opcode order
% for the ARM. Actually I have reordered them to be more logical
% e.g. AND, ORR, EOR are closer together.



\section{[[Register]]}

% for 5c! conventions! (not used at all by 5a, but in 5.out.h for other tools)
<<enum regxxx(arm)>>=
enum register {
    REGRET =	0,
    REGARG =	0,
    <<[[regxxx]] cases>>
    REGSB =		12,
    REGSP =		13,
    REGLINK =	14,
    REGPC =		15,
};
@
% hmm it's not really an enum as REGREG = REGARG, but still useful.
%old:    /* used by the loader for thumb code */
%    REGTMPT =		7,
% no REGFP??

<<constant NREG(arm)>>=
#define	NREG		16
@
% used to represent NONE for the outcode reg parameter


%XXXX
<<[[regxxx]] cases>>=
/* compiler allocates R1 up as temps */
/* compiler allocates register variables R2 up */
REGMIN =	2,
REGMAX =	8,

REGEXT =	10,
/* compiler allocates external registers R10 down */
REGTMP =	11,
@



\section{[[Operand_kind]] and [[Gen]]}

<<enum operand_kind(arm)>>=
enum operand_kind {
    D_NONE,
    <<operand_kind cases>>
};
@
% why D_ prefix? 
%dead: D_GOK, D_ADDR (valid for x86 but unused for arm)/* type/name */ for GOK

% see later D_REG, D_CONST, etc.

% how get the remaining info? e.g. for D_BRANCH to get the symbol or int 
% you'll have too look in Gen.value

%note: I reorder again a lot things, which like for opcode has some impact
% on 5l. Now D_REG, D_CONST, D_SHIFT (mimic imsr rule) are closer.


% =~ Adr of Linker ?
% rename operand? Why gen anyway? generic?
<<struct Gen(arm)>>=
struct	Gen
{
    // enum<operand_kind>
    short	type;

    long	offset; // generic value
    double	dval;
    char	sval[8];
    <<[[Gen]] other fields>>
};
@
% mimic what is in union token too

% see cinit()
<<global nullgen>>=
Gen	nullgen;
@

%note: An ADT would be far better than this enum and separate Sym 
% and Gen (=~ Adr). So it works with Gen so it's really
% type operand = 
%  | D_REG of register
%  | D_CONST of int
%  | Branch of offset (PC)
%  | Extern of name * offset (SB) ?
%less: maybe by playing with Literate Programming I can reproduce a kind of ADT?
% e.g. by introducing LSREG, and then the part of the enum register related
% to LSREG?
% type instr = 
%   ...
% type reg = 
%   ...


%XXXXXXX
<<[[Gen]] other fields>>=
// option<enum<register>> where None is done via NREG
short	reg; // ??

// option<Sym>, for debubbing purpose?
Sym*	sym;
// option<name_kind> None = N_NONE
short	name;
@

% if look qemu.root.s from data2c result:
% e.g. 
% DATA boot_CONF_outcode+0(SB)/8, $"\z\z\1\353\z\z\213\33"
% ...
% DATA boot_CONF_outcode+67520(SB)/8, $"\1\201\1\z\z\z\z\z"
% GLOBL boot_CONF_outcode+0(SB), $67528
% GLOBL boot_CONF_outlen+0(SB), $4
% DATA boot_CONF_outlen+0(SB)/4, $67523


% usually ADD, R1, R2, R3 
% =~ Prog of Linker (but without opcode)?
% how encoded the whole instruction? via multiple parameters to outcode?
% define a structure?


\section{[[Token]] and [[itab]]}


%typedef int token_kind; (union { char; enum token_kind })
% see y.tab.h for token_kind enum (which are actually a set of #define
% with also ascii char into it)

% the first part is essentially for keywords
<<token declarations(arm)>>=
%token  <lval>  LTYPE1 LTYPE2 LTYPE3 LTYPE4 LTYPE5 LTYPE6 LTYPE7 LTYPE8 LTYPE9 
%token  <lval>  LTYPEA LTYPEB LTYPEC LTYPED LTYPEE LTYPEF LTYPEG LTYPEH LTYPEI
%token  <lval>  LTYPEJ LTYPEK LTYPEL LTYPEM LTYPEN 
%token  <lval>  LTYPEBX

%token  <lval>  LSP LSB LFP LPC
%token  <lval>  LR LREG  LF LFREG  LC LCREG   LPSR LFCR

%token  <lval>  LCOND
%token  <lval>  LS LAT

%token  <lval>  LCONST 
%token  <dval>  LFCONST
%token  <sval>  LSCONST
%token  <sym>   LNAME LLAB LVAR
@
%dead: LTYPEX 



<<union token(arm)>>=
%union {
 //   enum<opcode>   (for LTYPE/...) 
 // | enum<register> (for LREG/...)
 // | enum<cond>     (for LCOND) 
 // ...
 // | long (for LCONST)
 long   lval;

 double dval;    // for LFCONST
 char   sval[8]; // for LSCONST
 Sym    *sym;    // for LNAME/...

 <<[[Token]] other fields(arm)>>
}
@
% sval[8]?? can't have string more than 8 bytes? hence the data2c
% ugly list?
% note: mutual ref with sym here where sym has itself a type that is 
% the token_kind



% could use NSNAME here instead of char sval[8] ? and at a few other places?
% from 8.out.h
<<constant NSNAME(arm)>>=
#define	NSNAME		8
@




% hmm ADT again would be better than union and this
%    // could put D_NONE as a.y actually redo the job of setting Gen.value
%    // appropriately
%
% LTYPE0 etc are defined in a.y, tokens with value 
% instruction table conversion, string -> token
<<struct Itab(arm)>>=
struct Itab
{
    char	*name;
    //enum<token_kind>
    ushort	type;
    //enum<opcode> | enum<operand_kind> | enum<name_kind> | enum<registers>
    ushort	value;
};
@
% actually value can also range in enum<fregisters>, enum<sysregisters>, etc

<<global itab(arm)>>=
struct Itab itab[] =
{
    "NOP",		LTYPEI, ANOP,
    <<[[itab]] elements>>
    0
};
@


\section{[[Sym]] and [[hash]]}

% assembling is a lot about symbolic name processing!
% (actually generic struct in aa/)

<<struct Sym>>=
struct	Sym
{
    // for user labels (bar:), variables (VAR)
    // but also used for opcodes (AMOVB) and register (D_AL) keywords 
    // (see itab)
    char	*name;

    //enum<token_kind> (e.g. LNAME, LLAB, LBREG, etc)
    ushort	type;

    //enum<operand_kind> | enum<opcode> | long (e.g. pc for LLAB)
    long	value; //vlong in va/

    <<[[Sym]] other fields>>
    // Extra
    <<[[Sym]] extra fields>>
};
@
% this is used for user defined names (e.g. TEXT foo), but
% abused also for keywords operand like AL, AX, and also for opcode
% in which case the value is the opcode.
% note: because of hash below that means that all MOVB in a file
% are shared when lexing
%    // see also itab[i].type and itab[i].value
% archi: not that in va/ value is a vlong, not a long // archi: vlong in va/!!

<<constant NHASH>>=
#define	NHASH		503
@

<<global hash>>=
// hash<string, ref_own?<Sym>>, (next in bucket = Sym.link)
Sym*	hash[NHASH];
@
% diff with h?

% what is the head? hash! and also h?
<<[[Sym]] extra fields>>=
// list<ref<Sym>> (next = Sym.link) bucket of hashtbl 'hash'
Sym*	link;
@

% what is the list it marks the end of? hash for sure, maybe also h and htab?
<<constant S>>=
#define	S	((Sym*)nil)
@



<<constant NSYMB>>=
#define	NSYMB		500
@
% was //#define	NSYMB		8192 on arm, not sure it matters

<<global symb>>=
char	symb[NSYMB];
@

% use symb global, a bit ugly
% TODO lp split, compute hash key of symb, find in hash global, etc
<<function lookup>>=
Sym*
lookup(void)
{
    Sym *s;
    long h;
    char *p;
    int c, l;

    h = 0;
    for(p=symb; c = *p; p++)
        h = h+h+h + c;
    l = (p - symb) + 1;
    if(h < 0)
        h = ~h;
    h %= NHASH;

    c = symb[0];
    for(s = hash[h]; s != S; s = s->link) {
        if(s->name[0] != c)
            continue;
        if(memcmp(s->name, symb, l) == 0)
            return s;
    }
    s = alloc(sizeof(*s));
    s->name = alloc(l);
    memmove(s->name, symb, l);

    s->link = hash[h];
    hash[h] = s;
    syminit(s);
    return s;
}
@

<<function syminit>>=
void
syminit(Sym *s)
{

    s->type = LNAME;
    s->value = 0;
}
@
%x86 and arm


<<function slookup>>=
Sym*
slookup(char *s)
{

    strcpy(symb, s);
    return lookup();
}
@


%dead:
%<<[[Sym]] other fields>>=
%Ref*	ref; // unused for 5a, matters?
%@
%<<struct Ref>>=
%// only for 8a actually, and actually not used so I removed it
%struct	Ref
%{
%    int	class;
%};
%@


\section{[[Name_kind]]}

<<enum name_kind(arm)>>=
enum name_kind {
   N_NONE,
   <<name_kind cases>>
};
@
% this used to be with operand_kind, but they are really disjoint
% and used only for the ANAME pseudo opcode



%section{[[pc]]} ?

\chapter{[[main()]]}

% default object suffix, to generate foo.8
% hmm actually it's in aa/ so should be independent of 8a/
<<global thechar>>=
int	thechar;
@

% to find archi specific core header files, /386/include/...
<<global thestring>>=
char*	thestring;
@

% -o
<<global outfile>>=
char*	outfile;
@




<<function main(arm)>>=
void
main(int argc, char *argv[])
{
    <<[[main()]] locals>>
    <<[[main()]] debug initialization>>

    thechar = '5';
    thestring = "arm";

    cinit();
    outfile = nil;
    include[ninclude++] = ".";

    ARGBEGIN {
    <<[[main()]] command line processing>>
    } ARGEND

    if(*argv == 0) {
        print("usage: %ca [-options] file.s\n", thechar);
        errorexit();
    }

    <<[[main()]] multiple files handling>>

    if(assemble(argv[0]))
        errorexit();
    exits(0);
}
@


<<[[main()]] command line processing>>=
case 'o':
    outfile = ARGF();
    break;
@





% cwd, for #include "" (cwd can change as one include other files)
%  =~ dirname(current_file)
% less: rename? dirname_of_current_file?
<<global pathname>>=
char*	pathname;
@

\section{[[cinit()]]}

% could split, nullgen init, hash init (via lookup), pathname init
<<function cinit(arm)>>=
void
cinit(void)
{
    Sym *s;
    int i;

    nullgen.sym = S;
    nullgen.offset = 0;
    nullgen.type = D_NONE;
    nullgen.name = N_NONE;
    nullgen.reg = NREG;
    if(FPCHIP)
        nullgen.dval = 0;
    for(i=0; i<sizeof(nullgen.sval); i++)
        nullgen.sval[i] = 0;

    for(i=0; i<NHASH; i++)
        hash[i] = S;
    for(i=0; itab[i].name; i++) {
        s = slookup(itab[i].name);
        s->type = itab[i].type;
        s->value = itab[i].value;
    }

    pathname = allocn(pathname, 0, 100);
    if(getwd(pathname, 99) == 0) {
        pathname = allocn(pathname, 100, 900);
        if(getwd(pathname, 999) == 0)
            strcpy(pathname, "/???");
    }
}
@
% used to do more initialisation here, but instead move the init
% at the def location
% very similar to the x86 version, except the few change for nullgen fields


\section{[[assemble()]]}

% there is 2 passes.
% actually used outside assemble() in the grammar! and outcode().
% the idea is actually to parse two times, but to do different things the
% second time. Abusing grammar actions (old style).
<<global pass>>=
// 1|2
int	pass;
@


% on windows would be different, but we don't care
% int -> Rune?
<<function pathchar>>=
int
pathchar(void)
{
    return '/';
}
@

<<[[assemble()]] locals>>=
char *p;
fdt of; // outfile
int i;
@

% outfile(string) -> of(fd) -> obuf(biobuf)
<<global obuf>>=
Biobuf	obuf;
@

<<function assemble>>=
int
assemble(char *file)
{
    <<[[assemble()]] locals>>

    <<[[assemble()]] set p to basename(file) and adjust include>>

    if(outfile == nil) {
        <<[[assemble()]] set outfile to {basename(file)}.8>>
    }

    <<[[assemble()]] setinclude("/<arch>/include") or INCLUDE>>

    of = mycreat(outfile, 0664);
    if(of < 0) {
        yyerror("%ca: cannot create %s", thechar, outfile);
        errorexit();
    }
    Binit(&obuf, of, OWRITE);

    pass = 1;

    pinit(file);
    <<[[assemble()]] init Dlist after pinit>>
    yyparse(); // calls outcode() but does nothing when pass == 1

    if(nerrors) {
        cclean();
        return nerrors;
    }

    pass = 2;
    outhist(); // header

    pinit(file);
    <<[[assemble()]] init Dlist after pinit>>
    yyparse(); // calls outcode() that now does things

    cclean();
    return nerrors;
}
@






<<[[assemble()]] locals>>=
char ofile[100];
@

<<[[assemble()]] set p to basename(file) and adjust include>>=
// p = basename(file)
// include[0] = dirname(file); 
strcpy(ofile, file);
p = utfrrune(ofile, pathchar());
if(p) {
    include[0] = ofile;
    *p++ = '\0';
} else
    p = ofile;
@

<<[[assemble()]] set outfile to {basename(file)}.8>>=
// outfile =  p =~ s/.s/.8/;
outfile = p;
if(outfile){
    p = utfrrune(outfile, '.');
    if(p)
        if(p[1] == 's' && p[2] == '\0')
            p[0] = '\0';
    p = utfrune(outfile, '\0');
    p[0] = '.';
    p[1] = thechar;
    p[2] = '\0';
} else
    outfile = "/dev/null";
@


<<[[assemble()]] locals>>=
char incfile[20];
@

<<[[assemble()]] setinclude("/<arch>/include") or INCLUDE>>=
p = getenv("INCLUDE");
if(p) {
    setinclude(p);
} else {
    if(systemtype(Plan9)) {
        sprint(incfile,"/%s/include", thestring);
        setinclude(strdup(incfile));
    }
}
@



<<function cclean(arm)>>=
void
cclean(void)
{

    outcode(AEND, Always, &nullgen, NREG, &nullgen);
    Bflush(&obuf);
}
@


\chapter{Input}

% yyparse() actually calls yylex?

<<global lineno>>=
long	lineno;
@


% =~ yyback(1) trick, used by yylex() and getc(), and?? cg?
<<global peekc>>=
int	peekc = IGN;
@
% used to be set in cinit()

<<constant IGN>>=
#define	IGN		(-2)
@

<<constant EOF>>=
#define	EOF		(-1)
@



% assemble() -> pinit() (before yyparse)
% call at the beginning of each pass with the file to assemble
<<function pinit>>=
void
pinit(char *f)
{
    int i;
    Sym *s;

    lineno = 1;
    newio();
    newfile(f, -1);
    pc = 0;
    peekc = IGN;

    symcounter = 1;
    for(i=0; i<NSYM; i++) {
        h[i].type = 0;
        h[i].sym = S;
    }
    for(i=0; i<NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            s->macro = nil;
}
@


\section{Files managment}

% include so have to open files, close them
% hmm better to separate concern and have cpp in a different program?

<<constant BUFSIZ>>=
#define	BUFSIZ		8192
@

% hmm, shorter fieldnames? hmmm
<<struct Io>>=
struct	Io
{
    char	b[BUFSIZ];

    // -1 if not opened yet
    fdt	f;

    // like Fi, saved IO buffer status
    char*	p;
    short	c;

    // Extra
    Io*	link;
};
@

% list/stack because of #include, iostack point to head and currently
% opened and processed file
<<global iostack>>=
// list<Io> (next = Io.link)
Io*	iostack = I;
@
% used to be set in cinit()

<<constant I>>=
#define	I	((Io*)nil)
@


<<global iofree>>=
// list<IO>, next = IO.link
Io*	iofree = I;
@

// option<ref<IO>>
<<global ionext>>=
Io*	ionext;
@


<<function newio>>=
void
newio(void)
{
    Io *i;
    static int pushdepth = 0;

    i = iofree;
    if(i == I) {
        pushdepth++;
        if(pushdepth > 1000) {
            yyerror("macro/io expansion too deep");
            errorexit();
        }
        //todo: check error code?
        i = alloc(sizeof(Io));
    } else
        iofree = i->link;
    i->c = 0;
    i->f = -1;
    ionext = i;
}
@


<<function newfile>>=
void
newfile(char *s, int f)
{
    Io *i;

    i = ionext;
    i->link = iostack;
    iostack = i;

    i->f = f;
    if(i->f < 0)
        i->f = open(s, 0);
    if(i->f < 0) {
        yyerror("%ca: %r: %s", thechar, s);
        errorexit();
    }
    fi.c = 0;
    linehist(s, 0);
}
@

\section{Buffer managment}

% buffered IO

% File input?
<<struct Fi>>=
struct Fi
{
    // ref<char>, pointer in buffer (of Io.b)
    char*	p;
    // remaining count in buffer (of Io.b)
    int	c;
};
@

% global IO buffer
<<global fi>>=
struct Fi fi;
@


<<function GETC>>=
#define	GETC()		((--fi.c < 0) ? filbuf() : *fi.p++ & 0xff)
@

<<function filbuf>>=
int
filbuf(void)
{
    Io *i;

loop:
    i = iostack;
    if(i == I)
        return EOF;
    if(i->f < 0)
        goto pop;
    fi.c = read(i->f, i->b, BUFSIZ) - 1;
    if(fi.c < 0) {
        close(i->f);
        linehist(0, 0);
        goto pop;
    }
    fi.p = i->b + 1;
    return i->b[0];

pop:
    iostack = i->link;
    i->link = iofree;
    iofree = i;
    i = iostack;
    if(i == I)
        return EOF;
    fi.p = i->p;
    fi.c = i->c;
    if(--fi.c < 0)
        goto loop;
    return *fi.p++;
}
@



\chapter{Lexing}

\section{[[yylex()]]}

% loop until find a token and return its code
% and also set yylval global to contain more
% info about the token (yylval = big union)

% GETC is essentially get next char in current opened file
% (that is iostack->f )
% #define	GETC()		((--fi.c < 0) ? filbuf() : *fi.p++ & 0xff)
% type: unit -> int (-1 for EOF, 0 for?)



% should use lex ... simpler, but maybe to avoid bootstrapping issues?

<<[[yylex()]] locals>>=
int c1;
@
% for peek


% called by? yyparse() in generated code from a.y
<<function yylex>>=
long
yylex(void)
{
    int c;
    <<[[yylex()]] locals>>

    c = peekc;
    if(c != IGN) {
        peekc = IGN;
        goto l1;
    }
l0:
    c = GETC();

l1:
    if(c == EOF) {
        peekc = EOF;
        return -1;
    }

    if(isspace(c)) {
        if(c == '\n') {
            lineno++;
            return ';';
        }
        goto l0;
    }

    if(isalpha(c))
        goto talph;
    if(isdigit(c))
        goto tnum;

    switch(c) {
    <<[[yylex()]] switch c cases>>
    default:
        return c;
    }
    peekc = c1;
    return c;
}
@
%$

% LP aspectize peekc? lp split more the func?




\section{Newline}

<<[[yylex()]] switch c cases>>=
case '\n':
    lineno++;
    return ';';
@

% newline are translated in ';' and this is used by
% the grammar, see in Parsing subsection

\section{Comments}

<<[[yylex()]] switch c cases>>=
case '/':
    c1 = GETC();
    if(c1 == '/') {
        for(;;) {
            c = GETC();
            if(c == '\n')
                goto l1;
            if(c == EOF) {
                yyerror("eof in comment");
                errorexit();
            }
        }
    }
    if(c1 == '*') {
        for(;;) {
            c = GETC();
            while(c == '*') {
                c = GETC();
                if(c == '/')
                    goto l0;
            }
            if(c == EOF) {
                yyerror("eof in comment");
                errorexit();
            }
            if(c == '\n')
                lineno++;
        }
    }
    break;
@

% put getcom() here too?

\section{Keywords and identifiers}

<<[[yylex()]] locals>>=
char *cp;
Sym *s;
@


<<[[yylex()]] switch c cases>>=
case '_':
case '@':
// case 'a'..'z' 'A'..'Z':
talph:
    cp = symb;

aloop:
    *cp++ = c;
    c = GETC();
    if(isalpha(c) || isdigit(c) || c == '_' || c == '$') // $
        goto aloop;

    // went too far, yyback(1)
    peekc = c;

    *cp = '\0';
    s = lookup();

    <<[[yylex()]] if macro symbol>>

    if(s->type == 0)
        s->type = LNAME;

    if(s->type == LNAME || s->type == LVAR || s->type == LLAB) {
        yylval.sym = s;
    } else {
        yylval.lval = s->value;
    }
    return s->type;
@
% possible to have s->type == 0? if new symbol then I think
% it actually set to LNAME in syminit

\section{Numbers}

<<[[yylex()]] switch c cases>>=
// case '0'..'9'
tnum:
    cp = symb;
    if(c != '0')
        goto dc;

    *cp++ = c;
    c = GETC();
    c1 = 3;
    if(c == 'x' || c == 'X') {
        c1 = 4;
        c = GETC();
    } else
    if(c < '0' || c > '7')
        goto dc;
    yylval.lval = 0;
    for(;;) {
        if(c >= '0' && c <= '9') {
            if(c > '7' && c1 == 3)
                break;
            yylval.lval <<= c1;
            yylval.lval += c - '0';
            c = GETC();
            continue;
        }
        if(c1 == 3)
            break;
        if(c >= 'A' && c <= 'F')
            c += 'a' - 'A';
        if(c >= 'a' && c <= 'f') {
            yylval.lval <<= c1;
            yylval.lval += c - 'a' + 10;
            c = GETC();
            continue;
        }
        break;
    }
    goto ncu;

dc:
    for(;;) {
        if(!isdigit(c))
            break;
        *cp++ = c;
        c = GETC();
    }
    if(c == '.')
        goto casedot;
    if(c == 'e' || c == 'E')
        goto casee;
    *cp = 0;
    if(sizeof(yylval.lval) == sizeof(vlong))
        yylval.lval = strtoll(symb, nil, 10);
    else
        yylval.lval = strtol(symb, nil, 10);

ncu:
    while(c == 'U' || c == 'u' || c == 'l' || c == 'L')
        c = GETC();
    peekc = c;
    return LCONST;

casedot:
    for(;;) {
        *cp++ = c;
        c = GETC();
        if(!isdigit(c))
            break;
    }
    if(c == 'e' || c == 'E')
        goto casee;
    goto caseout;

casee:
    *cp++ = 'e';
    c = GETC();
    if(c == '+' || c == '-') {
        *cp++ = c;
        c = GETC();
    }
    while(isdigit(c)) {
        *cp++ = c;
        c = GETC();
    }

caseout:
    *cp = 0;
    peekc = c;
    if(FPCHIP) {
        yylval.dval = atof(symb);
        return LFCONST;
    }
    yyerror("assembler cannot interpret fp constants");
    yylval.lval = 1L;
    return LCONST;
@


\subsection{Decimals}

\subsection{Floats}

<<[[yylex()]] switch c cases>>=
case '.':
    c = GETC();
    if(isalpha(c)) {
        cp = symb;
        *cp++ = '.';
        goto aloop;
    }
    if(isdigit(c)) {
        cp = symb;
        *cp++ = '.';
        goto casedot;
    }
    peekc = c;
    return '.';
@


\section{Characters}

<<[[yylex()]] switch c cases>>=
case '\'':
    c = escchar('\'');
    if(c == EOF)
        c = '\'';
    if(escchar('\'') != EOF)
        yyerror("missing '");
    yylval.lval = c;
    return LCONST;
@

\section{Escaping characters}

% e is usually ' or "
<<function escchar>>=
int
escchar(int e)
{
    int c, l;

loop:
    c = getc();
    if(c == '\n') {
        yyerror("newline in string");
        return EOF;
    }
    if(c != '\\') {
        if(c == e)
            return EOF;
        return c;
    }
    c = getc();
    if(c >= '0' && c <= '7') {
        l = c - '0';
        c = getc();
        if(c >= '0' && c <= '7') {
            l = l*8 + c-'0';
            c = getc();
            if(c >= '0' && c <= '7') {
                l = l*8 + c-'0';
                return l;
            }
        }
        peekc = c;
        return l;
    }
    switch(c)
    {
    case '\n':	goto loop;
    case 'n':	return '\n';
    case 't':	return '\t';
    case 'b':	return '\b';
    case 'r':	return '\r';
    case 'f':	return '\f';
    case 'a':	return 0x07;
    case 'v':	return 0x0b;
    case 'z':	return 0x00;
    }
    return c;
}
@


\section{Strings}

<<[[yylex()]] switch c cases>>=
case '"':
    memcpy(yylval.sval, nullgen.sval, sizeof(yylval.sval));
    cp = yylval.sval;
    c1 = 0;
    for(;;) {
        c = escchar('"');
        if(c == EOF)
            break;
        if(c1 < sizeof(yylval.sval))
            *cp++ = c;
        c1++;
    }
    if(c1 > sizeof(yylval.sval))
        yyerror("string constant too long");
    return LSCONST;
@
% limited to 8 bytes, hence the data2c script


\section{[[getc()]], [[unget()]], [[getnsc()]]}

% from now on those functions are actually used by the preprocessing
% code, not by the basic lexer (yylex) that actually implement
% his own getnsc(), getcom(), getsym() via cases
% (hmmm maybe could factorize things?)

% helpers for other functions

% int? why not uint? GETC can return EOF but not this function!
<<function getc>>=
int
getc(void)
{
    int c;

    c = peekc;
    if(c != IGN) {
        peekc = IGN;
        return c;
    }

    c = GETC();

    if(c == '\n')
        lineno++;
    if(c == EOF) {
        yyerror("End of file");
        errorexit();
    }
    return c;
}
@


% what if had already a peekc? because called unget 2 times?
% should raise Impossible!
<<function unget>>=
void
unget(int c)
{
    peekc = c;
    if(c == '\n')
        lineno--;
}
@

% get non space char (they really like short cryptic names)
<<function getnsc>>=
int
getnsc(void)
{
    int c;

    for(;;) {
        c = getc();
        if(!isspace(c) || c == '\n')
            return c;
    }
}
@



\section{[[getsym()]]}
% mv with Keywords and identifier section?

<<function getsym>>=
Sym*
getsym(void)
{
    int c;
    char *cp;

    c = getnsc();
    if(!isalpha(c) && c != '_' && c < Runeself) {
        unget(c);
        return S;
    }
    for(cp = symb;;) {
        if(cp <= symb+NSYMB-4)
            *cp++ = c;
        c = getc();
        if(isalnum(c) || c == '_' || c >= Runeself)
            continue;
        unget(c);
        break;
    }
    *cp = 0;
    if(cp > symb+NSYMB-4)
        yyerror("symbol too large: %s", symb);
    return lookup();
}
@

\section{[[getcom()]]}
% mv with Comments section above?

<<function getcom>>=
int
getcom(void)
{
    int c;

    for(;;) {
        c = getnsc();
        if(c != '/')
            break;
        c = getc();
        if(c == '/') {
            while(c != '\n')
                c = getc();
            break;
        }
        if(c != '*')
            break;
        c = getc();
        for(;;) {
            if(c == '*') {
                c = getc();
                if(c != '/')
                    continue;
                c = getc();
                break;
            }
            if(c == '\n') {
                yyerror("comment across newline");
                break;
            }
            c = getc();
        }
        if(c == '\n')
            break;
    }
    return c;
}
@

\chapter{Preprocessing}

<<global mactab>>=
struct
{
    char	*macname;
    void	(*macf)(void);
} mactab[] =
{
    "ifdef",	nil,	/* macif(0) */
    "ifndef",	nil,	/* macif(1) */
    "else",	nil,	/* macif(2) */

    "line",	maclin,
    "define",	macdef,
    "include",	macinc,
    "undef",	macund,

    "pragma",	macprag,
    "endif",	macend,
    0
};
@

<<[[yylex()]] switch c cases>>=
case '#':
    domacro();
    goto l0;
@
% goto l0 because does not return any token, we just have
% actually expanded or defined macros or undef, in any case
% no token to return

% dispatcher, should rename because it's not just about macro =>
% parse_and_dispatch_pp_directive?
<<function domacro>>=
void
domacro(void)
{
    int i;
    Sym *s;

    s = getsym();
    if(s == S)
        s = slookup("endif");

    for(i=0; mactab[i].macname; i++)
        if(strcmp(s->name, mactab[i].macname) == 0) {
            if(mactab[i].macf)
                // dispatcher!
                (*mactab[i].macf)();
            else
                macif(i);
            return;
        }
    yyerror("unknown #: %s", s->name);
    macend();
}
@
% abuse getsym just to get an ident, don't have to go through
% lookup really



<<function macend>>=
void
macend(void)
{
    int c;

    for(;;) {
        c = getnsc();
        if(c < 0 || c == '\n')
            return;
    }
}
@
% I don't think c can be < 0 here.

\section{[[#include]] and [[-I]]}

\subsection{Include path}

<<[[main()]] locals>>=
char *p;
@

% -I
<<[[main()]] command line processing>>=
case 'I':
    p = ARGF();
    setinclude(p);
    break;
@

<<constant NINCLUDE>>=
#define	NINCLUDE	10
@

% hmm rename? include_paths?
<<global include>>=
char*	include[NINCLUDE];
@

<<global ninclude>>=
int	ninclude;
@

<<function setinclude>>=
void
setinclude(char *p)
{
    int i;

    if(p == nil)
        return;
    for(i=1; i < ninclude; i++)
        if(strcmp(p, include[i]) == 0)
            return;

    if(ninclude >= nelem(include)) {
        yyerror("ninclude too small %d", nelem(include));
        exits("ninclude");
    }
    include[ninclude++] = p;
}
@


\subsection{Tracing}

% when error, need give line, but can be because of context,
% so useful to give the full location of an error, that is the list
% of files that included it
% TODO give example of why it's useful to not just have the final names

% keep track of where a token comes from, so that error
% messages can look like
%  xxx.h from xxx.h from xxx.c ...
<<struct Hist>>=
struct	Hist
{
    char*	name;

    long	line;
    long	offset;

    // Extra
    Hist*	link;
};
@

<<global hist>>=
// list<ref_own<Hist>>, next = Hist.link
Hist*	hist;
@

<<global ehist>>=
// ref<Hist>, end of hist list?
Hist*	ehist;
@


<<constant H>>=
#define	H	((Hist*)0)
@




% dead? seems just set to 0 ... just one write
% it's used in cc/ though, and we copy pasted code for macbody
<<global newflag>>=
bool	newflag;
@

<<function linehist>>=
void
linehist(char *f, int offset)
{
    Hist *h;

    /*
     * overwrite the last #line directive if
     * no alloc has happened since the last one
     */
    if(newflag == false && ehist != H && offset != 0 && ehist->offset != 0)
        if(f && ehist->name && strcmp(f, ehist->name) == 0) {
            ehist->line = lineno;
            ehist->offset = offset;
            return;
        }
    <<[[linehist()]] debug>>

    newflag = false;

    h = alloc(sizeof(Hist));
    h->name = f;
    h->line = lineno;
    h->offset = offset;
    h->link = H;
    if(ehist == H) {
        hist = h;
        ehist = h;
        return;
    }
    ehist->link = h;
    ehist = h;
}
@





\subsection{[[#include]]}

<<constant STRINGSZ>>=
#define	STRINGSZ	200
@

% LP split, and factorize code with gethunk
<<function macinc>>=
void
macinc(void)
{
    int c0, c, i, f;
    char str[STRINGSZ], *hp;

    c0 = getnsc();
    if(c0 != '"') {
        c = c0;
        if(c0 != '<')
            goto bad;
        c0 = '>';
    }
    for(hp = str;;) {
        c = getc();
        if(c == c0)
            break;
        if(c == '\n')
            goto bad;
        *hp++ = c;
    }
    *hp = 0;

    c = getcom();
    if(c != '\n')
        goto bad;

    f = -1;
    for(i=0; i<ninclude; i++) {
        if(i == 0 && c0 == '>')
            continue;
        strcpy(symb, include[i]);
        strcat(symb, "/");
        if(strcmp(symb, "./") == 0)
            symb[0] = 0;
        strcat(symb, str);

        f = open(symb, 0);
        if(f >= 0)
            break;

    }
    if(f < 0)
        strcpy(symb, str);
    c = strlen(symb) + 1;
    while(c & 3)
        c++;

    while(nhunk < c)
        gethunk();
    hp = hunk;
    memcpy(hunk, symb, c);
    nhunk -= c;
    hunk += c;

    newio();
    pushio();
    newfile(hp, f);
    return;

bad:
    unget(c);
    yyerror("syntax in #include");
    macend();
}
@


<<function pushio>>=
void
pushio(void)
{
    Io *i;

    i = iostack;
    if(i == I) {
        yyerror("botch in pushio");
        errorexit();
    }
    i->p = fi.p;
    i->c = fi.c;
}
@

\section{[[#define]] and [[-D]]}

\subsection{[[-D]]}

<<[[main()]] command line processing>>=
case 'D':
    p = ARGF();
    if(p)
        Dlist[nDlist++] = p;
    break;
@

% -D
<<global Dlist>>=
char*	Dlist[30];
@

<<global nDlist>>=
int	nDlist;
@

<<[[assemble()]] init Dlist after pinit>>=
for(i=0; i<nDlist; i++)
        dodefine(Dlist[i]);
@

<<[[Sym]] other fields>>=
//option<string>, for '#define FOO xxx' expansion
char*	macro;
@

<<function dodefine>>=
void
dodefine(char *cp)
{
    Sym *s;
    char *p;
    long l;

    strcpy(symb, cp);
    p = strchr(symb, '=');
    if(p) {
        *p++ = 0;
        s = lookup();
        l = strlen(p) + 2;	/* +1 null, +1 nargs */
        while(l & 3)
            l++;

        while(nhunk < l)
            gethunk();
        *hunk = 0;
        strcpy(hunk+1, p);
        s->macro = hunk;
        hunk += l;
        nhunk -= l;

    } else {
        s = lookup();
        s->macro = "\0001";	/* \000 is nargs */
    }
    <<[[dodefine()]] debug>>
}
@



\subsection{[[#define]]}

<<constant NARG>>=
#define	NARG	25
@

% wow, this is complicated
<<function macdef>>=
void
macdef(void)
{
    Sym *s, *a;
    char *args[NARG], *np, *base;
    int n, i, c, len, dots;
    int ischr;

    s = getsym();
    if(s == S)
        goto bad;
    if(s->macro)
        yyerror("macro redefined: %s", s->name);
    c = getc();
    n = -1;
    dots = 0;
    if(c == '(') {
        n++;
        c = getnsc();
        if(c != ')') {
            unget(c);
            for(;;) {
                a = getsymdots(&dots);
                if(a == S)
                    goto bad;
                if(n >= NARG) {
                    yyerror("too many arguments in #define: %s", s->name);
                    goto bad;
                }
                args[n++] = a->name;
                c = getnsc();
                if(c == ')')
                    break;
                if(c != ',' || dots)
                    goto bad;
            }
        }
        c = getc();
    }
    if(isspace(c))
        if(c != '\n')
            c = getnsc();
    base = hunk;
    len = 1;
    ischr = 0;
    for(;;) {
        if(isalpha(c) || c == '_') {
            np = symb;
            *np++ = c;
            c = getc();
            while(isalnum(c) || c == '_') {
                *np++ = c;
                c = getc();
            }
            *np = 0;
            for(i=0; i<n; i++)
                if(strcmp(symb, args[i]) == 0)
                    break;
            if(i >= n) {
                i = strlen(symb);
                base = allocn(base, len, i);
                memcpy(base+len, symb, i);
                len += i;
                continue;
            }
            base = allocn(base, len, 2);
            base[len++] = '#';
            base[len++] = 'a' + i;
            continue;
        }
        if(ischr){
            if(c == '\\'){ 
                base = allocn(base, len, 1);
                base[len++] = c;
                c = getc();
            }else if(c == ischr)
                ischr = 0;
        }else{
            if(c == '"' || c == '\''){
                base = allocn(base, len, 1);
                base[len++] = c;
                ischr = c;
                c = getc();
                continue;
            }
            if(c == '/') {
                c = getc();
                if(c == '/'){
                    c = getc();
                    for(;;) {
                        if(c == '\n')
                            break;
                        c = getc();
                    }
                    continue;
                }
                if(c == '*'){
                    c = getc();
                    for(;;) {
                        if(c == '*') {
                            c = getc();
                            if(c != '/')
                                continue;
                            c = getc();
                            break;
                        }
                        if(c == '\n') {
                            yyerror("comment and newline in define: %s", s->name);
                            break;
                        }
                        c = getc();
                    }
                    continue;
                }
                base = allocn(base, len, 1);
                base[len++] = '/';
                continue;
            }
        }
        if(c == '\\') {
            c = getc();
            if(c == '\n') {
                c = getc();
                continue;
            }
            else if(c == '\r') {
                c = getc();
                if(c == '\n') {
                    c = getc();
                    continue;
                }
            }
            base = allocn(base, len, 1);
            base[len++] = '\\';
            continue;
        }
        if(c == '\n')
            break;
        if(c == '#')
        if(n > 0) {
            base = allocn(base, len, 1);
            base[len++] = c;
        }
        base = allocn(base, len, 1);
        base[len++] = c;
        c = ((--fi.c < 0)? filbuf(): (*fi.p++ & 0xff));
        if(c == '\n')
            lineno++;
        if(c == -1) {
            yyerror("eof in a macro: %s", s->name);
            break;
        }
    }
    do {
        base = allocn(base, len, 1);
        base[len++] = 0;
    } while(len & 3);

    *base = n+1;
    if(dots)
        *base |= VARMAC;
    s->macro = base;
    <<[[macdef()]] debug>>
    return;

bad:
    if(s == S)
        yyerror("syntax in #define");
    else
        yyerror("syntax in #define: %s", s->name);
    macend();
}
@

<<constant VARMAC>>=
#define VARMAC 0x80
@


<<function getsymdots>>=
Sym*
getsymdots(int *dots)
{
    int c;
    Sym *s;

    s = getsym();
    if(s != S)
        return s;

    c = getnsc();
    if(c != '.'){
        unget(c);
        return S;
    }
    if(getc() != '.' || getc() != '.')
        yyerror("bad dots in macro");
    *dots = 1;
    return slookup("__VA_ARGS__");
}
@

\subsection{Macro Expansion}

<<[[yylex()]] if macro symbol>>=
if(s->macro) {
    newio();
    cp = ionext->b;
    macexpand(s, cp);
    pushio();

    ionext->link = iostack;
    iostack = ionext;

    fi.p = cp;
    fi.c = strlen(cp);
    if(peekc != IGN) {
        cp[fi.c++] = peekc;
        cp[fi.c] = 0;
        peekc = IGN;
    }
    goto l0;
}
@
% abuse newio()? it's not really a new file here

% wow, complicated too
<<function macexpand>>=
void
macexpand(Sym *s, char *b)
{
    char buf[2000];
    int n, l, c, nargs;
    char *arg[NARG], *cp, *ob, *ecp, dots;

    ob = b;
    if(*s->macro == 0) {
        strcpy(b, s->macro+1);
        if(debug['m'])
            print("#expand %s %s\n", s->name, ob);
        return;
    }
    
    nargs = (char)(*s->macro & ~VARMAC) - 1;
    dots = *s->macro & VARMAC;

    c = getnsc();
    if(c != '(')
        goto bad;
    n = 0;
    c = getc();
    if(c != ')') {
        unget(c);
        l = 0;
        cp = buf;
        ecp = cp + sizeof(buf)-4;
        arg[n++] = cp;
        for(;;) {
            if(cp >= ecp)
                goto toobig;
            c = getc();
            if(c == '"')
                for(;;) {
                    if(cp >= ecp)
                        goto toobig;
                    *cp++ = c;
                    c = getc();
                    if(c == '\\') {
                        *cp++ = c;
                        c = getc();
                        continue;
                    }
                    if(c == '\n')
                        goto bad;
                    if(c == '"')
                        break;
                }
            if(c == '\'')
                for(;;) {
                    if(cp >= ecp)
                        goto toobig;
                    *cp++ = c;
                    c = getc();
                    if(c == '\\') {
                        *cp++ = c;
                        c = getc();
                        continue;
                    }
                    if(c == '\n')
                        goto bad;
                    if(c == '\'')
                        break;
                }
            if(c == '/') {
                c = getc();
                switch(c) {
                case '*':
                    for(;;) {
                        c = getc();
                        if(c == '*') {
                            c = getc();
                            if(c == '/')
                                break;
                        }
                    }
                    *cp++ = ' ';
                    continue;
                case '/':
                    while((c = getc()) != '\n')
                        ;
                    break;
                default:
                    unget(c);
                    c = '/';
                }
            }
            if(l == 0) {
                if(c == ',') {
                    if(n == nargs && dots) {
                        *cp++ = ',';
                        continue;
                    }
                    *cp++ = 0;
                    arg[n++] = cp;
                    if(n > nargs)
                        break;
                    continue;
                }
                if(c == ')')
                    break;
            }
            if(c == '\n')
                c = ' ';
            *cp++ = c;
            if(c == '(')
                l++;
            if(c == ')')
                l--;
        }
        *cp = 0;
    }
    if(n != nargs) {
        yyerror("argument mismatch expanding: %s", s->name);
        *b = 0;
        return;
    }
    cp = s->macro+1;
    for(;;) {
        c = *cp++;
        if(c == '\n')
            c = ' ';
        if(c != '#') {
            *b++ = c;
            if(c == 0)
                break;
            continue;
        }
        c = *cp++;
        if(c == 0)
            goto bad;
        if(c == '#') {
            *b++ = c;
            continue;
        }
        c -= 'a';
        if(c < 0 || c >= n)
            continue;
        strcpy(b, arg[c]);
        b += strlen(arg[c]);
    }
    *b = 0;
    if(debug['m'])
        print("#expand %s %s\n", s->name, ob);
    return;

bad:
    yyerror("syntax in macro expansion: %s", s->name);
    *b = 0;
    return;

toobig:
    yyerror("too much text in macro expansion: %s", s->name);
    *b = 0;
}
@

\section{[[#undef]]}

<<function macund>>=
void
macund(void)
{
    Sym *s;

    s = getsym();
    macend();
    if(s == S) {
        yyerror("syntax in #undef");
        return;
    }
    s->macro = nil;
}
@

\section{[[#ifdef]]}

% 0 = ifdef, 1 = ifndef, 2 = else, see mactab and domacro
<<function macif>>=
void
macif(int f)
{
    int c, l;
    bool bol;
    Sym *s;

    if(f == 2)
        goto skip;
    s = getsym();
    if(s == S)
        goto bad;
    if(getcom() != '\n')
        goto bad;
    if((s->macro != nil) ^ f)
        return;

skip:
    bol = true;
    l = 0;
    for(;;) {
        c = getc();
        if(c != '#') {
            if(!isspace(c))
                bol = false;
            if(c == '\n')
                bol = true;
            continue;
        }
        if(!bol)
            continue;
        s = getsym();
        if(s == S)
            continue;
        if(strcmp(s->name, "endif") == 0) {
            if(l) {
                l--;
                continue;
            }
            macend();
            return;
        }
        if(strcmp(s->name, "ifdef") == 0 || strcmp(s->name, "ifndef") == 0) {
            l++;
            continue;
        }
        if(l == 0 && f != 2 && strcmp(s->name, "else") == 0) {
            macend();
            return;
        }
    }

bad:
    yyerror("syntax in #if(n)def");
    macend();
}
@

\section{[[#pragma]]}

% effect of #pragma lib in .s ??

<<function macprag>>=
void
macprag(void)
{
    Sym *s;
    int c0, c;
    char *hp;
    Hist *h;

    s = getsym();

    if(s && strcmp(s->name, "lib") == 0) {
        c0 = getnsc();
        if(c0 != '"') {
            c = c0;
            if(c0 != '<')
                goto bad;
            c0 = '>';
        }
        for(hp = symb;;) {
            c = getc();
            if(c == c0)
                break;
            if(c == '\n')
                goto bad;
            *hp++ = c;
        }
        *hp = '\0';
        c = getcom();
        if(c != '\n')
            goto bad;
    
        /*
         * put pragma-line in as a funny history 
         */
        c = strlen(symb) + 1;
        while(c & 3)
            c++;
    
        while(nhunk < c)
            gethunk();
        hp = hunk;
        memcpy(hunk, symb, c);
        nhunk -= c;
        hunk += c;
    
        h = alloc(sizeof(Hist));
        h->name = hp;
        h->line = lineno;
        h->offset = -1;

        h->link = H;
        if(ehist == H) {
            hist = h;
            ehist = h;
            return;
        }
        ehist->link = h;
        ehist = h;

        return;

bad:
        unget(c);
        yyerror("syntax in #pragma lib");
        macend();

    } else {
        while(getnsc() != '\n')
            ;
        return;
    }
}
@


% most pragma seems to be discarded except #pragma lib, so
% I removed it (could have aslo simplified by calling prag_do_nothing()).
% is it because code was shared with cc? or because it's in aa/
% and other archi do different things?
%
%    if(s && strcmp(s->name, "pack") == 0) {
%        pragpack();
%        return;
%    }
%    if(s && strcmp(s->name, "fpround") == 0) {
%        pragfpround();
%        return;
%    }
%    if(s && strcmp(s->name, "profile") == 0) {
%        pragprofile();
%        return;
%    }
%    if(s && strcmp(s->name, "varargck") == 0) {
%        pragvararg();
%        return;
%    }
%    if(s && strcmp(s->name, "incomplete") == 0) {
%        pragincomplete();
%        return;
%    }
%
%old:
%<<function pragpack>>=
%void
%pragpack(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@
%
%<<function pragvararg>>=
%void
%pragvararg(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@
%
%<<function pragfpround>>=
%void
%pragfpround(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@
%
%<<function pragprofile>>=
%void
%pragprofile(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@
%
%<<function pragincomplete>>=
%void
%pragincomplete(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@


\section{[[#line]]}

<<function maclin>>=
void
maclin(void)
{
    char *cp;
    int c;
    long n;

    n = getnsn();
    c = getc();
    if(n < 0)
        goto bad;

    for(;;) {
        if(c == ' ' || c == '\t') {
            c = getc();
            continue;
        }
        if(c == '"')
            break;
        if(c == '\n') {
            strcpy(symb, "<noname>");
            goto nn;
        }
        goto bad;
    }
    cp = symb;
    for(;;) {
        c = getc();
        if(c == '"')
            break;
        *cp++ = c;
    }
    *cp = 0;
    c = getcom();
    if(c != '\n')
        goto bad;

nn:
    c = strlen(symb) + 1;
    while(c & 3)
        c++;

    while(nhunk < c)
        gethunk();
    cp = hunk;
    memcpy(hunk, symb, c);
    nhunk -= c;
    hunk += c;

    linehist(cp, n);
    return;

bad:
    unget(c);
    yyerror("syntax in #line");
    macend();
}
@

% could move with the other getxxx()
<<function getnsn>>=
long
getnsn(void)
{
    long n;
    int c;

    c = getnsc();
    if(c < '0' || c > '9')
        return -1;
    n = 0;
    while(c >= '0' && c <= '9') {
        n = n*10 + c-'0';
        c = getc();
    }
    unget(c);
    return n;
}
@



\chapter{Parsing}

\section{Overview}

% assume understand yacc! if not read classic book on lex&yacc
%  or docs/doc/unix/yacc.pdf (or read CompilerGenerator.nw :) )

<<5a/a.y>>=
%{
#include "a.h"
%}
<<union token(arm)>>
<<priority and associativity declarations>>
<<token declarations(arm)>>
<<type declarations(arm)>>
%%
<<grammar(arm)>>
@
%$


% have seen token declaration in Core Data structures already.


<<grammar(arm)>>=
prog:
  /* empty */
| prog line

<<line rule(arm)>>
<<inst rule(arm)>>
<<cond rule(arm)>>
<<operand rules(arm)>>
<<helper rules(arm)>>
<<constant expression rules>>
<<float rules>>
<<opt rules>>
<<misc rules>>
@

% assembly file is made of lines containing instructions or labels.
% instructions are mostly a single opcode with 0, 1, or 2 operands
% where each operand can be a register, or constant, or address, etc.
% and some combination (like register + constant offset)

% there are some special opcode like TEXT which don't translate
% in binary code but are useful for symbol resolving.


<<line rule(arm)>>=
line:
  inst ';'
@


% note that newline are translated in ';' by the lexer
% so can either pack in one line with ';' or use newline
% (haskell spirit :) )


<<line rule(arm)>>=
| ';'
| error ';'
@
% error? yacc trick for synchronization? to got until next ; (that is newline)?

\section{Instructions}

% outcode =~ pc++
% take 5 arguments, opcode, cond, op1, op2, op3.
% op2 is always a register or nothing.

% similar sections than in Machine.nw

\subsection{Arithmetic}

\subsubsection{Logic}
<<logic opcodes>>=
AAND,
AORR,
AEOR,
@
% not exactly the ARM order, I prefer to put closer AAND and AORR for
% instance

<<inst rule(arm)>>=
inst:
/*
 * AND/OR/ADD/SUB/...
 */
  LTYPE1 cond imsr ',' spreg ',' reg { outcode($1, $2, &$3, $5, &$7); }
| LTYPE1 cond imsr ',' spreg ','     { outcode($1, $2, &$3, $5, &nullgen); }
| LTYPE1 cond imsr ',' reg           { outcode($1, $2, &$3, NREG, &$5); }
@
%$
% arith operator of Machine.nw, but also SLL, SRL,   DIV, MOD, ...


\subsubsection{Add/sub}

<<add/sub opcodes>>=
AADD,
ASUB,
@

<<[[itab]] elements>>=
"AND",		LTYPE1,	AAND,
"ORR",		LTYPE1,	AORR,
"EOR",		LTYPE1,	AEOR,
"ADD",		LTYPE1,	AADD,
"SUB",		LTYPE1,	ASUB,
@




\ifallcode
<<logic opcodes>>=
ABIC,
@
<<add/sub opcodes>>=
ARSB,
AADC,
ASBC,
ARSC,
@
<<[[itab]] elements>>=
"BIC",		LTYPE1,	ABIC,
"RSB",		LTYPE1,	ARSB,
"ADC",		LTYPE1,	AADC,
"SBC",		LTYPE1,	ASBC,
"RSC",		LTYPE1,	ARSC,
@
\fi




% see also Comparison section, part of Arith opcode
% in Machine.nw, as well as simple MOV


\subsubsection{Bit shift}

<<bitshift opcodes>>=
ASRL,
ASRA,
ASLL,
@

<<[[itab]] elements>>=
"SLL",		LTYPE1,	ASLL,
"SRL",		LTYPE1,	ASRL,
"SRA",		LTYPE1,	ASRA,
@

\subsubsection{Mul/div/mod}

<<mul/div/mod opcodes>>=
AMUL,
ADIV,
AMOD,
@
% ARM has no ADIV or AMOD so virtual/fake-opcode

<<[[itab]] elements>>=
"MUL",		LTYPE1, AMUL,
"DIV",		LTYPE1,	ADIV,
"MOD",		LTYPE1,	AMOD,
@

<<mul/div/mod opcodes>>=
AMULU,
ADIVU,
AMODU,
@
% has no reading syntax, generated just in 5c




\subsubsection{Mul long}


<<mul/div/mod opcodes>>=
AMULL,
AMULAL,
AMULLU,
AMULALU,
@

<<[[itab]] elements>>=
"MULL",		LTYPEM, AMULL,
"MULAL",	LTYPEM, AMULAL,
"MULLU",	LTYPEM, AMULLU,
"MULALU",	LTYPEM, AMULALU,
@



% MULL special instruction?
<<inst rule(arm)>>=
/*
 * MULL hi,lo,r1,r2
 */
| LTYPEM cond reg ',' reg ',' regreg { outcode($1, $2, &$3, $5.reg, &$7); }
@
%$


<<mul/div/mod opcodes>>=
AMULA,
@

<<[[itab]] elements>>=
"MULA",		LTYPEN, AMULA,
@

<<operand_kind cases>>=
D_REGREG,
@

% multiply and accumulate
<<inst rule(arm)>>=
/*
 * MULA hi,lo,r1,r2
 */
| LTYPEN cond reg ',' reg ',' reg ',' spreg 
 {
  $7.type = D_REGREG;
  $7.offset = $9;
  outcode($1, $2, &$3, $5.reg, &$7);
 }
@
%$



\subsection{Memory}

% actually ARM has load/store, but plan9 has MOV as a virtual/fake-opcode,
% more powerful, can do e.g. MOVW R2, (R3) !

<<mov opcodes>>=
AMOVW,
@

<<mov opcodes>>=
AMOVB,
AMOVBU,
AMOVH,
AMOVHU,
@


<<[[itab]] elements>>=
"MOVW",		LTYPE3, AMOVW,
"MOVB",		LTYPE3, AMOVB,
"MOVBU",	LTYPE3, AMOVBU,
"MOVH",		LTYPE3, AMOVH,
"MOVHU",	LTYPE3, AMOVHU,
@


<<inst rule(arm)>>=
/*
 * MOVW
 */
| LTYPE3 cond gen ',' gen { outcode($1, $2, &$3, NREG, &$5); }
@
% special instr? the real one accept any gen?


<<mov opcodes>>=
AMVN,
@
%//AMOV, redundant with the other MOV operations

<<[[itab]] elements>>=
"MVN",		LTYPE2, AMVN,	/* op2 ignored */
@

% MOV negative
<<inst rule(arm)>>=
/*
 * MVN
 */
| LTYPE2 cond imsr ',' reg { outcode($1, $2, &$3, NREG, &$5); }
@

\subsection{Comparison}
% was actually part of arithmetic in Machine.nw

<<comparison opcodes>>=
ATST,
ATEQ,
ACMP,
@


<<[[itab]] elements>>=
"CMP",		LTYPE7,	ACMP,
"TST",		LTYPE7,	ATST,
"TEQ",		LTYPE7,	ATEQ,
@


<<inst rule(arm)>>=
/*
 * CMP
 */
| LTYPE7 cond imsr ',' spreg comma { outcode($1, $2, &$3, $5, &nullgen); }
@
%$

\ifallcode
<<comparison opcodes>>=
ACMN,
@
<<[[itab]] elements>>=
"CMN",		LTYPE7,	ACMN,
@
\fi


\subsection{Branch}
% called JMP/CALL in 8a

<<branching opcodes>>=
AB,
ABL,
@

<<[[itab]] elements>>=
"B",		LTYPE4, AB,
"BL",		LTYPE4, ABL,
@


<<inst rule(arm)>>=
/*
 * B/BL
 */
| LTYPE4 cond comma rel   { outcode($1, $2, &nullgen, NREG, &$4); }
| LTYPE4 cond comma nireg { outcode($1, $2, &nullgen, NREG, &$4); }
@

% comma rel? useful?

<<branching opcodes>>=
/* 
 * Do not reorder or fragment the conditional branch 
 * opcodes, or the predication code will break 
 */ 
// AB derivatives with condition code, see 5i/
ABEQ,
ABNE,
ABCS,//not in 5i/cond, seems equivalent to ABHS
ABHS,
ABCC,//not in 5i/cond, seems equivalent to ABLO
ABLO,
ABMI,
ABPL,
ABVS,
ABVC,
ABHI,
ABLS,
ABGE,
ABLT,
ABGT,
ABLE,
//ABAL? (always) done via AB, ABNV (never) done via ANOP probably
@

<<[[itab]] elements>>=
"BEQ",		LTYPE5,	ABEQ,
"BNE",		LTYPE5,	ABNE,
"BCS",		LTYPE5,	ABCS,
"BHS",		LTYPE5,	ABHS,
"BCC",		LTYPE5,	ABCC,
"BLO",		LTYPE5,	ABLO,
"BMI",		LTYPE5,	ABMI,
"BPL",		LTYPE5,	ABPL,
"BVS",		LTYPE5,	ABVS,
"BVC",		LTYPE5,	ABVC,
"BHI",		LTYPE5,	ABHI,
"BLS",		LTYPE5,	ABLS,
"BGE",		LTYPE5,	ABGE,
"BLT",		LTYPE5,	ABLT,
"BGT",		LTYPE5,	ABGT,
"BLE",		LTYPE5,	ABLE,
@



<<inst rule(arm)>>=
/*
 * BEQ/...
 */
| LTYPE5 comma rel { outcode($1, Always, &nullgen, NREG, &$3); }
@




<<branching opcodes>>=
ARET,
@
% actually no RET in ARM, so virtual/fake-opcode

<<[[itab]] elements>>=
"RET",		LTYPEA, ARET,
@

<<inst rule(arm)>>=
/*
 * RET
 */
| LTYPEA cond comma { outcode($1, $2, &nullgen, NREG, &nullgen); }
@

\subsection{Software interrupt}
% software interrupt, aka syscall

<<interrupt opcodes>>=
ASWI, // syscall
@

<<[[itab]] elements>>=
"SWI",		LTYPE6, ASWI,
@

<<inst rule(arm)>>=
/*
 * SWI
 */
| LTYPE6 cond comma gen { outcode($1, $2, &nullgen, NREG, &$4); }
@
%$

\subsection{Swap}
%\subsection{Special}

<<swap opcodes>>=
ASWPW,
ASWPBU,
@
% used in _tas so maybe a special system-like instruction?

<<[[itab]] elements>>=
"SWPW",		LTYPE9, ASWPW,
"SWPBU",	LTYPE9, ASWPBU,
@

<<inst rule(arm)>>=
/*
 * SWAP
 */
| LTYPE9 cond reg ',' ireg ',' reg { outcode($1, $2, &$5, $3.reg, &$7); }
| LTYPE9 cond reg ',' ireg comma   { outcode($1, $2, &$5, $3.reg, &$3); }
| LTYPE9 cond comma ireg ',' reg   { outcode($1, $2, &$4, $6.reg, &$6); }
@
%$




\section{Conditional execution}

<<type declarations(arm)>>=
%type   <lval>  cond
@

<<cond rule(arm)>>=
cond:
  /* empty */ { $$ = Always; }
| cond LCOND  { $$ = ($1 & ~C_SCOND) | $2; }
@

<<constant C_SCOND(arm)>>=
/* scond byte */
#define	C_SCOND	((1<<4)-1)
@


<<[[itab]] elements>>=
".EQ",		LCOND,	0,
".NE",		LCOND,	1,
".CS",		LCOND,	2,
".HS",		LCOND,	2,
".CC",		LCOND,	3,
".LO",		LCOND,	3,
".MI",		LCOND,	4,
".PL",		LCOND,	5,
".VS",		LCOND,	6,
".VC",		LCOND,	7,
".HI",		LCOND,	8,
".LS",		LCOND,	9,
".GE",		LCOND,	10,
".LT",		LCOND,	11,
".GT",		LCOND,	12,
".LE",		LCOND,	13,
".AL",		LCOND,	Always,
@
%//Never = 15

<<constant Always(arm)>>=
#define    Always 14
@


\section{Special bits}
% sign? long? p bit, w bit, ???

<<cond rule(arm)>>=
| cond LS    { $$ = $1 | $2; }
@

<<[[itab]] elements>>=
".U",		LS,	C_UBIT,
".S",		LS,	C_SBIT,
".W",		LS,	C_WBIT,
".P",		LS,	C_PBIT,
@

<<constant C_SBIT(arm)>>=
#define	C_SBIT	(1<<4)
@

<<constant C_PBIT(arm)>>=
#define	C_PBIT	(1<<5)
@

<<constant C_WBIT(arm)>>=
#define	C_WBIT	(1<<6)
@

<<constant C_UBIT(arm)>>=
#define	C_UBIT	(1<<7)	/* up bit */
@


% composite
<<[[itab]] elements>>=
".PW",		LS,	C_WBIT|C_PBIT,
".WP",		LS,	C_WBIT|C_PBIT,
@

% composite or alternate form
<<[[itab]] elements>>=
".IBW",		LS,	C_WBIT|C_PBIT|C_UBIT,
".IAW",		LS,	C_WBIT|C_UBIT,
".DBW",		LS,	C_WBIT|C_PBIT,
".DAW",		LS,	C_WBIT,
".IB",		LS,	C_PBIT|C_UBIT,
".IA",		LS,	C_UBIT,
".DB",		LS,	C_PBIT,
".DA",		LS,	0,
@
% some seems redundant like .DB and .P, .U and .IA, etc

<<constant C_FBIT(arm)>>=
#define	C_FBIT	(1<<7)	/* psr flags-only */
@


<<[[itab]] elements>>=
".F",		LS,	C_FBIT,
@


\section{Operand}

% this is the rest from the %union
<<[[Token]] other fields(arm)>>=
Gen    gen;
@


% reg = register
% imm = immediate
% shift = shifted register or constant

% imsr = immediate or shift or register

<<type declarations(arm)>>=
%type   <gen> imsr
@
<<type declarations(arm)>>=
%type   <gen> reg imm shift
@

<<operand rules(arm)>>=
imsr:
  reg
| imm
| shift
@


\subsection{Registers}

<<operand_kind cases>>=
D_REG,
@


<<type declarations(arm)>>=
%type   <lval>  sreg spreg 
@

<<operand rules(arm)>>=
sreg:
  LREG
| LR '(' expr ')'
 {
  if($3 < 0 || $3 >= NREG)
      print("register value out of range\n");
  $$ = $3;
 }
| LPC { $$ = REGPC; }
@

<<operand rules(arm)>>=
spreg:
  sreg
| LSP { $$ = REGSP; }
@
%$

<<operand rules(arm)>>=
reg:
 spreg
 {
  $$ = nullgen;
  $$.type = D_REG;
  $$.reg = $1;
 }
@
%$

<<[[itab]] elements>>=
"R0",		LREG,	0,
"R1",		LREG,	1,
"R2",		LREG,	2,
"R3",		LREG,	3,
"R4",		LREG,	4,
"R5",		LREG,	5,
"R6",		LREG,	6,
"R7",		LREG,	7,
"R8",		LREG,	8,
"R9",		LREG,	9,
"R10",		LREG,	10,
"R11",		LREG,	11,
"R12",		LREG,	12,
"R13",		LREG,	13,
"R14",		LREG,	14,
"R15",		LREG,	15,
@

<<[[itab]] elements>>=
"R",		LR,	0,
@

<<[[itab]] elements>>=
"SB",		LSB,	D_EXTERN,
"PC",		LPC,	D_BRANCH,
@




\subsection{Constants}

% con = constant
% prefix with $ (why? ambiguity with what?) to differentiate
% with just con where it's a omem (see section below)

<<operand_kind cases>>=
D_CONST,
@

<<operand rules(arm)>>=
imm: '$' con
 {
  $$ = nullgen;
  $$.type = D_CONST;
  $$.offset = $2;
 }
@

% float constants are in another category

\subsection{Shift registers}
% register and constant in some sense

<<operand_kind cases>>=
D_SHIFT,
@

<<operand rules(arm)>>=
shift:
 spreg '<' '<' rcon
 {
  $$ = nullgen;
  $$.type = D_SHIFT;
  $$.offset = $1 | $4 | (0 << 5);
 }
| spreg '>' '>' rcon
 {
  $$ = nullgen;
  $$.type = D_SHIFT;
  $$.offset = $1 | $4 | (1 << 5);
 }
| spreg '-' '>' rcon
 {
  $$ = nullgen;
  $$.type = D_SHIFT;
  $$.offset = $1 | $4 | (2 << 5);
 }
| spreg LAT '>' rcon
 {
  $$ = nullgen;
  $$.type = D_SHIFT;
  $$.offset = $1 | $4 | (3 << 5);
 }
@

<<[[itab]] elements>>=
"@",		LAT,	0,
@


<<type declarations(arm)>>=
%type   <lval>  rcon
@

<<helper rules(arm)>>=
rcon:
  spreg
 {
  if($$ < 0 || $$ >= 16)
      print("register value out of range\n");
  $$ = (($1&15) << 8) | (1 << 4);
 }
| con
 {
  if($$ < 0 || $$ >= 32)
      print("shift value out of range\n");
  $$ = ($1&31) << 7;
 }
@


\subsection{Memory references}
% argument to MOVW

% O_REG = offset reg
<<operand_kind cases>>=
D_OREG,
@


<<type declarations(arm)>>=
%type   <gen>   gen 
@
% gen? general?

<<operand rules(arm)>>=
<<gen rule>>
@


<<gen rule>>=
gen:
  reg
| ximm
| shift
| con
 {
  $$ = nullgen;
  $$.type = D_OREG;
  $$.offset = $1;
 }
| oreg
@
%$
% no $ in front of con here?
% todo: can remove this case? needed? implicit register?
%  how can be D_OREG when there are no registers involved? it's SB by default?

% a bit confusing that can have oreg, and also $ oreg
% because MOV support powerful addressing modes? with multiple
% indirections?

%less: delete?
<<gen rule>>=
| shift '(' spreg ')'
 {
  $$ = $1;
  $$.reg = $3;
 }
@


<<type declarations(arm)>>=
%type   <gen> oreg ireg nireg ioreg 
@



% oreg? offset reg? but not really offset, it's a name
%less: delete the name ( sgreg ) ? used?
<<misc rules>>=
oreg:
  name
| name '(' sreg ')'
 {
  $$ = $1;
  $$.type = D_OREG;
  $$.reg = $3;
 }
| ioreg
@
% sreg, so can't use FP here, nor LSB, so only name refering to PC?
% no cos name allow name refering to LSB or FP or SP.
% but what is then name '(' sreg ')' ?? double ()() ???

% indirect or offset reg
<<misc rules>>=
ioreg:
  ireg
| con '(' sreg ')'
 {
  $$ = nullgen;
  $$.type = D_OREG;
  $$.reg = $3;
  $$.offset = $1;
 }
@


% ireg? indirect reg?
<<misc rules>>=
ireg:
 '(' spreg ')'
 {
  $$ = nullgen;
  $$.type = D_OREG;
  $$.reg = $2;
  $$.offset = 0;
 }
@
%$

% for BL
<<misc rules>>=
nireg:
  name
| ireg
@
%$
%old: had a if with nothing in it, weird
%  name
% {
%  $$ = $1;
%  if($1.name != D_EXTERN && $1.name != D_STATIC) {
%  }
% }



\subsection{Named memory}
% for data, and actually also for code, just not labels

<<type declarations(arm)>>=
%type   <gen>   name 
%type   <lval>  pointer
@


<<operand rules(arm)>>=
name:
 con '(' pointer ')'
 {
  $$ = nullgen;
  $$.type = D_OREG;
  $$.name = $3;
  $$.sym = S;
  $$.offset = $1;
 }
| LNAME offset '(' pointer ')'
 {
  $$ = nullgen;
  $$.type = D_OREG;
  $$.name = $4;
  $$.sym = $1;
  $$.offset = $2;
 }
| LNAME '<' '>' offset '(' LSB ')'
 {
  $$ = nullgen;
  $$.type = D_OREG;
  $$.name = D_STATIC;
  $$.sym = $1;
  $$.offset = $4;
 }
@
%$
%        MOVL    count+8(FP), CX
% the LNAME is really just symbol for debugging help?


<<helper rules(arm)>>=
pointer:
  LSB
| LSP
| LFP
@

<<[[itab]] elements>>=
"SP",		LSP,	D_AUTO,
"FP",		LFP,	D_PARAM,
@

% can do 
%	BL	div<>(SB)  so it's SB but it's really a code reference

% hmm but it's actually not for type? it's for name field!
<<name_kind cases>>=
D_EXTERN, // data/bss values (from SB)
D_STATIC, // data static variables (from SB)
D_AUTO,   // stack values (from SP)
D_PARAM,  // parameter (from FP)
@
% use A_EXTERN? or N_EXTERN?
%/* name */ for D_EXTERN

\subsection{Code references and labels}
% hmm con(PC) is not really named code
% relocatable!

<<operand_kind cases>>=
D_BRANCH,
@
%/* type */ FOR BRANCH


<<type declarations(arm)>>=
%type   <gen>   rel
%type   <lval>  offset
@

% for code (rel = ? relocatable?)
<<operand rules(arm)>>=
rel:
  con '(' LPC ')'
 {
  $$ = nullgen;
  $$.type = D_BRANCH;
  $$.offset = $1 + pc;
 }
| LLAB offset
 {
  $$ = nullgen;
  $$.type = D_BRANCH;
  $$.sym = $1;
  $$.offset = $1->value + $2;
 }
| LNAME offset
 {
  $$ = nullgen;
  if(pass == 2)
      yyerror("undefined label: %s", $1->name);
  $$.type = D_BRANCH;
  $$.sym = $1;
  $$.offset = $2;
 }
@


<<helper rules(arm)>>=
offset:
 /* empty */ { $$ = 0; }
| '+' con    { $$ = $2; }
| '-' con    { $$ = -$2; }
@
%$

\subsection{Alternative forms}

<<type declarations(arm)>>=
%type   <gen>   ximm
@

<<operand_kind cases>>=
D_SCONST,
@
% string constant

<<operand_kind cases>>=
D_OCONST,
@
% ??

<<operand rules(arm)>>=
ximm:
  '$' con
 {
  $$ = nullgen;
  $$.type = D_CONST;
  $$.offset = $2;
 }
| '$' LSCONST
 {
  $$ = nullgen;
  $$.type = D_SCONST;
  memcpy($$.sval, $2, sizeof($$.sval));
 }

| '$' oreg
 {
  $$ = $2;
  $$.type = D_CONST;
 }
| '$' '*' '$' oreg
 {
  $$ = $4;
  $$.type = D_OCONST;
 }
| fcon
@
%$

<<operand rules(arm)>>=
/* for MULL */
regreg:
 '(' spreg ',' spreg ')'
 {
  $$ = nullgen;
  $$.type = D_REGREG;
  $$.reg = $2;
  $$.offset = $4;
 }
@



\section{Labels}

% this is incremented in outcode after each instruction 
% except for ADATA and AGLOBL
<<global pc>>=
long	pc;
@

<<line rule(arm)>>=
| LNAME ':'
 {
  $1->type = LLAB;
  $1->value = pc;
 }
  line
| LLAB ':'
 {
  if($1->value != pc)
   yyerror("redeclaration of %s", $1->name);
  $1->value = pc;
 }
  line
@
%$

\section{Pseudo instructions}

<<pseudo opcodes>>=
AGOK,
ADYNT,
AINIT,
@
% no reading syntax, so used internally
% there was a D_GOK, but it was unused in 5a/5c/5l


\subsection{[[TEXT/GLOBL]]}

<<pseudo opcodes>>=
ATEXT,
AGLOBL,
@

<<[[itab]] elements>>=
"TEXT",		LTYPEB, ATEXT,
"GLOBL",	LTYPEB, AGLOBL,
@

<<inst rule(arm)>>=
/*
 * TEXT/GLOBL
 */
| LTYPEB name ',' imm         { outcode($1, Always, &$2, NREG, &$4); }
| LTYPEB name ',' con ',' imm { outcode($1, Always, &$2, $4, &$6); }
@
%$

\subsection{[[DATA/WORD]]}

<<pseudo opcodes>>=
ADATA,
AWORD,
@

<<[[itab]] elements>>=
"DATA",		LTYPEC, ADATA,
"WORD",		LTYPEH, AWORD,
@

<<inst rule(arm)>>=
/*
 * DATA
 */
| LTYPEC name '/' con ',' ximm { outcode($1, Always, &$2, $4, &$6); }
@

<<inst rule(arm)>>=
/*
 * WORD
 */
| LTYPEH comma ximm { outcode($1, Always, &nullgen, NREG, &$3); }
@
%$



\subsection{[[END]]}

<<pseudo opcodes>>=
AEND,
@

<<[[itab]] elements>>=
"END",		LTYPEE, AEND,
@

<<inst rule(arm)>>=
/*
 * END
 */
| LTYPEE comma { outcode($1, Always, &nullgen, NREG, &nullgen); }
@
%$


%\section{Special instructions}
%\subsection{[[JMP/CALL]]}
%\subsection{[[NOP]]}
%\subsection{[[SHL/SHR]]}
%\subsection{[[MOVW/MOVL]]}
%\subsection{[[IMUL]]}

\section{Variables}
% useful? cpp can do that too


<<line rule(arm)>>=
| LNAME '=' expr ';'
 {
  $1->type = LVAR;
  $1->value = $3;
 }
| LVAR '=' expr ';'
 {
  if($1->value != $3)
   yyerror("redeclaration of %s", $1->name);
  $1->value = $3;
 }
@

\section{Constant expressions}

% it's not Fortran, we're making an assembler :)
% so it's constant expressions here!

<<type declarations(arm)>>=
%type   <lval>  con expr 
@

<<priority and associativity declarations>>=
%left   '|'
%left   '^'
%left   '&'
%left   '<' '>'
%left   '+' '-'
%left   '*' '/' '%'
@
% lower in the file = higher priority, earlier = lower priority

<<constant expression rules>>=
con:
  LCONST
| LVAR         { $$ = $1->value; }
| '-' con      { $$ = -$2; }
| '+' con      { $$ = $2; }
| '~' con      { $$ = ~$2; }
| '(' expr ')' { $$ = $2; }

expr:
  con
| expr '+' expr     { $$ = $1 + $3; }
| expr '-' expr     { $$ = $1 - $3; }
| expr '*' expr     { $$ = $1 * $3; }
| expr '/' expr     { $$ = $1 / $3; }
| expr '%' expr     { $$ = $1 % $3; }
| expr '<' '<' expr { $$ = $1 << $4; }
| expr '>' '>' expr { $$ = $1 >> $4; }
| expr '&' expr     { $$ = $1 & $3; }
| expr '^' expr     { $$ = $1 ^ $3; }
| expr '|' expr     { $$ = $1 | $3; }

@


\ifallcode
\section{Optional commas}
% the optional ',' why? because asm can ge generated by 5c -S that does
% this. A bit ugly so maybe better to aspectize this.

<<opt rules>>=
comma:
  /* empty */
| ',' comma
@

% other optional stuff
<<opt rules>>=
/* for MCR */ 
oexpr:
  /* empty */ { $$ = 0; }
| ',' expr    { $$ = $2; }
@
%$

\fi

\section{[[yyparse()]]}

% essentially generated code by yacc, that is calling yylex


\chapter{Output}

%\chapter{Name resolution}

\chapter{Object Generation}
% it's actually not machine code generation ... 8l/optab.c does this

\section{Symbol table, [[h]] and [[sym]]}

% when an instruction involve a symbol
% the generated code contain an int that is an index
% in a symbol table!


<<struct Htab>>=
struct Htab
{
    // ref<Sym>
    Sym*	sym;
    //enum<operand_kind>?
    short	type;
};
@

<<constant NSYM>>=
#define	NSYM	50
@
% limit of number unresolved external symbols?


% starts to be used at index 1
<<global h>>=
// array<ref<Sym>>
struct Htab h[NSYM];
@


% next free entry in h (actually can be rested to 1)
<<global symcounter>>=
int	symcounter;
@
% was called sym

<<[[Sym]] other fields>>=
//?? seems used only by outcode
char	symidx;
@
% was called 'sym', but really it's an index in h, and it's confusing
% to have so many fields called sym already (as well as the global sym)





\section{[[outcode()]]}


% TODO LP split and transform while into if, easier flow
% a = opcode
<<function outcode(arm)>>=
void
outcode(int a, int scond, Gen *g1, int reg, Gen *g2)
{
    // symbol from, index in h[]
    int sf;
    // symbol to, index in h[]
    int st;
    // enum<operand_kind>
    int t;
    Sym *s;

    /* hack to make B.NE etc. work: turn it into the corresponding conditional*/
    if(a == AB){
        a = bcode[scond&0xf];
        scond = (scond & ~0xf) | Always;
    }

    if(pass == 1)
        goto out;
jackpot:
    sf = 0;
    s = g1->sym;

    while(s != S) {
        sf = s->symidx;

        if(sf < 0 || sf >= NSYM)
            sf = 0;

        t = g1->name;

        if(h[sf].type == t)
         if(h[sf].sym == s)
            break;

        zname(s->name, t, symcounter);
        s->symidx = symcounter;
        h[symcounter].sym = s;
        h[symcounter].type = t;
        sf = symcounter;
        symcounter++;
        if(symcounter >= NSYM)
            symcounter = 1;
        break;
    }

    st = 0;
    s = g2->sym;

    while(s != S) {
        st = s->symidx;

        if(st < 0 || st >= NSYM)
            st = 0;

        t = g2->name;

        if(h[st].type == t)
          if(h[st].sym == s)
            break;

        zname(s->name, t, symcounter);
        s->symidx = symcounter;
        h[symcounter].sym = s;
        h[symcounter].type = t;
        st = symcounter;
        symcounter++;
        if(symcounter >= NSYM)
            symcounter = 1;

        if(st == sf)
            goto jackpot;
        break;
    }

    Bputc(&obuf, a);
    Bputc(&obuf, scond);
    Bputc(&obuf, reg);
    Bputc(&obuf, lineno);
    Bputc(&obuf, lineno>>8);
    Bputc(&obuf, lineno>>16);
    Bputc(&obuf, lineno>>24);
    zaddr(g1, sf);
    zaddr(g2, st);

out:
    if(a != AGLOBL && a != ADATA)
        pc++;
}
@

<<global bcode(arm)>>=
static int bcode[] =
{
    ABEQ,
    ABNE,
    ABCS,
    ABCC,
    ABMI,
    ABPL,
    ABVS,
    ABVC,
    ABHI,
    ABLS,
    ABGE,
    ABLT,
    ABGT,
    ABLE,
    AB,
    ANOP,
};
@


\section{[[zaddr()]]}

% s is index in h[] for symbol involved in the operand?
<<function zaddr(arm)>>=
void
zaddr(Gen *a, int s)
{
    long l;
    int i;
    char *n;
    Ieee e;

    Bputc(&obuf, a->type);
    Bputc(&obuf, a->reg);
    Bputc(&obuf, s);
    Bputc(&obuf, a->name);

    switch(a->type) {
    case D_NONE:
    case D_REG:
    case D_FREG:
    case D_PSR:
    case D_FPCR:
        break;

    case D_REGREG:
        Bputc(&obuf, a->offset);
        break;

    case D_OREG:
    case D_CONST:
    case D_BRANCH:
    case D_SHIFT:
        l = a->offset;
        Bputc(&obuf, l);
        Bputc(&obuf, l>>8);
        Bputc(&obuf, l>>16);
        Bputc(&obuf, l>>24);
        break;

    case D_SCONST:
        n = a->sval;
        for(i=0; i<NSNAME; i++) {
            Bputc(&obuf, *n);
            n++;
        }
        break;

    case D_FCONST:
        ieeedtod(&e, a->dval);
        Bputc(&obuf, e.l);
        Bputc(&obuf, e.l>>8);
        Bputc(&obuf, e.l>>16);
        Bputc(&obuf, e.l>>24);
        Bputc(&obuf, e.h);
        Bputc(&obuf, e.h>>8);
        Bputc(&obuf, e.h>>16);
        Bputc(&obuf, e.h>>24);
        break;

    default:
        print("unknown type %d\n", a->type);
        exits("arg");

    }
}
@


<<pseudo opcodes>>=
ANAME,
@


% for unresolved symbol names?
<<function zname(arm)>>=
void
zname(char *n, int t, int s)
{

    Bputc(&obuf, ANAME);
    Bputc(&obuf, t);	/* type */
    Bputc(&obuf, s);	/* sym */
    while(*n) {
        Bputc(&obuf, *n);
        n++;
    }
    Bputc(&obuf, '\0');
}
@


\section{[[outhist()]]}

% it looks like outhist generate some header information,
% where is the spec of the format? ld uses that I guess no?

% main() -> assemble() -> outhist() at begining of pass 2
%out hist??

<<name_kind cases>>=
D_FILE,
@
<<name_kind cases>>=
D_FILE1, // used by linker only?
@

<<pseudo opcodes>>=
AHISTORY,
@


<<function outhist(arm)>>=
void
outhist(void)
{
    Gen g;
    Hist *h;
    char *p, *q, *op, c;
    int n;

    g = nullgen;
    c = pathchar();
    for(h = hist; h != H; h = h->link) {
        p = h->name;
        op = 0;
        if(p && p[0] != c && h->offset == 0 && pathname){
            if(pathname[0] == c){
                op = p;
                p = pathname;
            }
        }
        while(p) {
            q = strchr(p, c);
            if(q) {
                n = q-p;
                if(n == 0){
                    n = 1;	/* leading "/" */
                    *p = '/';	/* don't emit "\" on windows */
                }
                q++;
            } else {
                n = strlen(p);
                q = 0;
            }
            if(n) {
                Bputc(&obuf, ANAME);
                Bputc(&obuf, D_FILE);	/* type */
                Bputc(&obuf, 1);	/* sym */
                Bputc(&obuf, '<');
                Bwrite(&obuf, p, n);
                Bputc(&obuf, '\0');
            }
            p = q;
            if(p == 0 && op) {
                p = op;
                op = 0;
            }
        }
        g.offset = h->offset;

        Bputc(&obuf, AHISTORY);
        Bputc(&obuf, Always);
        Bputc(&obuf, 0);
        Bputc(&obuf, h->line);
        Bputc(&obuf, h->line>>8);
        Bputc(&obuf, h->line>>16);
        Bputc(&obuf, h->line>>24);
        zaddr(&nullgen, 0);
        zaddr(&g, 0);
    }
}
@


\chapter{Advanced Topics}

\section{[[#pragma lib]] and automagic linking}

% this is very very nice! remove so much headache,
% no need ocamlfind, no need pkg-config, so simple ...

\section{Float}

<<float mov opcodes>>=
// ??
AMOVWD,
AMOVWF,
AMOVDW,
AMOVFW,
AMOVFD,
AMOVDF,
AMOVF,
AMOVD,
@

<<[[itab]] elements>>=
"MOVD",		LTYPE3, AMOVD,
"MOVDF",	LTYPE3, AMOVDF,
"MOVDW",	LTYPE3, AMOVDW,
"MOVF",		LTYPE3, AMOVF,
"MOVFD",	LTYPE3, AMOVFD,
"MOVFW",	LTYPE3, AMOVFW,
"MOVWD",	LTYPE3, AMOVWD,
"MOVWF",	LTYPE3, AMOVWF,
@

<<[[itab]] elements>>=
"SQRTF",	LTYPEI, ASQRTF,
"SQRTD",	LTYPEI, ASQRTD,
"CMPF",		LTYPEL, ACMPF,
"CMPD",		LTYPEL, ACMPD,
"ADDF",		LTYPEK,	AADDF,
"ADDD",		LTYPEK,	AADDD,
"SUBF",		LTYPEK,	ASUBF,
"SUBD",		LTYPEK,	ASUBD,
"MULF",		LTYPEK,	AMULF,
"MULD",		LTYPEK,	AMULD,
"DIVF",		LTYPEK,	ADIVF,
"DIVD",		LTYPEK,	ADIVD,
@

<<float arithmetic opcodes>>=
// floats?
ACMPF,
ACMPD,
AADDF,
AADDD,
ASUBF,
ASUBD,
AMULF,
AMULD,
ADIVF,
ADIVD,
ASQRTF,
ASQRTD,
@


<<[[itab]] elements>>=
"F",		LF,	0,

"F0",		LFREG,	0,
"F1",		LFREG,	1,
"F2",		LFREG,	2,
"F3",		LFREG,	3,
"F4",		LFREG,	4,
"F5",		LFREG,	5,
"F6",		LFREG,	6,
"F7",		LFREG,	7,
"F8",		LFREG,	8,
"F9",		LFREG,	9,
"F10",		LFREG,	10,
"F11",		LFREG,	11,
"F12",		LFREG,	12,
"F13",		LFREG,	13,
"F14",		LFREG,	14,
"F15",		LFREG,	15,
@

<<constant FREGRET(arm)>>=
#define	FREGRET		0
@
<<constant FREGEXT(arm)>>=
#define	FREGEXT		7
@
<<constant FREGTMP(arm)>>=
#define	FREGTMP		15
@

% used by 5c/ in char	reg[NREG+NFREG];
<<constant NFREG(arm)>>=
#define	NFREG		8
@
% 8? looks like 16 above


<<struct ieee>>=
struct	ieee
{
    long	l;	/* contains ls-man	0xffffffff */
    long	h;	/* contains sign	0x80000000
                    exp		0x7ff00000
                    ms-man	0x000fffff */
};
@

<<function ieeedtod>>=
void
ieeedtod(Ieee *ieee, double native)
{
    double fr, ho, f;
    int exp;

    if(native < 0) {
        ieeedtod(ieee, -native);
        ieee->h |= 0x80000000L;
        return;
    }
    if(native == 0) {
        ieee->l = 0;
        ieee->h = 0;
        return;
    }
    fr = frexp(native, &exp);
    f = 2097152L;		/* shouldnt use fp constants here */
    fr = modf(fr*f, &ho);
    ieee->h = ho;
    ieee->h &= 0xfffffL;
    ieee->h |= (exp+1022L) << 20;
    f = 65536L;
    fr = modf(fr*f, &ho);
    ieee->l = ho;
    ieee->l <<= 16;
    ieee->l |= (long)(fr*f);
}
@

<<constant FPCHIP(arm)>>=
#define	FPCHIP		true
@

<<inst rule(arm)>>=
/*
 * floating-point coprocessor
 */
| LTYPEI cond freg ',' freg { outcode($1, $2, &$3, NREG, &$5); }
| LTYPEK cond frcon ',' freg { outcode($1, $2, &$3, NREG, &$5); }
| LTYPEK cond frcon ',' LFREG ',' freg { outcode($1, $2, &$3, $5, &$7); }
| LTYPEL cond freg ',' freg comma { outcode($1, $2, &$3, $5.reg, &nullgen); }
@
%$

<<type declarations(arm)>>=
%type <gen> freg fcon frcon
@


<<gen rule>>=
| freg
@

<<operand_kind cases>>=
D_FREG,
@

<<operand_kind cases>>=
D_FCONST,
@

<<float rules>>=
freg:
  LFREG
 {
  $$ = nullgen;
  $$.type = D_FREG;
  $$.reg = $1;
 }
| LF '(' con ')'
 {
  $$ = nullgen;
  $$.type = D_FREG;
  $$.reg = $3;
 }

fcon:
 '$' LFCONST
 {
  $$ = nullgen;
  $$.type = D_FCONST;
  $$.dval = $2;
 }
| '$' '-' LFCONST
 {
  $$ = nullgen;
  $$.type = D_FCONST;
  $$.dval = -$3;
 }

frcon:
  freg
| fcon
@
%$

\section{System instructions}

% move many?
<<mov opcodes>>=
AMOVM,
@

<<[[itab]] elements>>=
"MOVM",		LTYPE8, AMOVM,
@
%in lproc.s 
%	RFE				/* MOVM.IA.S.W (R13), [R15] */

<<inst rule(arm)>>=
/*
 * MOVM
 */
| LTYPE8 cond ioreg ',' '[' reglist ']'
 {
  Gen g;

  g = nullgen;
  g.type = D_CONST;
  g.offset = $6;
  outcode($1, $2, &$3, NREG, &g);
 }
| LTYPE8 cond '[' reglist ']' ',' ioreg
 {
  Gen g;

  g = nullgen;
  g.type = D_CONST;
  g.offset = $4;
  outcode($1, $2, &g, NREG, &$7);
 }
@



<<misc rules>>=
reglist:
  spreg           { $$ = 1 << $1; }
| spreg '-' spreg
 {
  int i;
  $$=0;
  for(i=$1; i<=$3; i++)
      $$ |= 1<<i;
  for(i=$3; i<=$1; i++)
      $$ |= 1<<i;
 }
| spreg comma reglist { $$ = (1<<$1) | $3; }
@
%$



<<misc opcodes>>=
ARFE, // ?? return from exn?
@

<<[[itab]] elements>>=
"RFE",		LTYPEA, ARFE,
@




<<[[itab]] elements>>=
"MCR",		LTYPEJ, 0,
"MRC",		LTYPEJ, 1,
@



<<inst rule(arm)>>=
/*
 * MCR MRC
 */
| LTYPEJ cond con ',' expr ',' spreg ',' creg ',' creg oexpr
 {
  Gen g;

  g = nullgen;
  g.type = D_CONST;
  g.offset =
   (0xe << 24) |    /* opcode */
   ($1 << 20) |     /* MCR/MRC */
   ($2 << 28) |     /* scond */
   (($3 & 15) << 8) |   /* coprocessor number */
   (($5 & 7) << 21) |   /* coprocessor operation */
   (($7 & 15) << 12) |  /* arm register */
   (($9 & 15) << 16) |  /* Crn */
   (($11 & 15) << 0) |  /* Crm */
   (($12 & 7) << 5) |   /* coprocessor information */
   (1<<4);          /* must be set */ // opcode component
  outcode(AWORD, Always, &nullgen, NREG, &g);
 }
@


<<type declarations(arm)>>=
%type   <lval>  creg
@

<<misc rules>>=
creg:
  LCREG
| LC '(' expr ')'
 {
  if($3 < 0 || $3 >= NREG)
      print("register value out of range\n");
  $$ = $3;
 }
@
%$

<<[[itab]] elements>>=
"C",		LC,	0,

"C0",		LCREG,	0,
"C1",		LCREG,	1,
"C2",		LCREG,	2,
"C3",		LCREG,	3,
"C4",		LCREG,	4,
"C5",		LCREG,	5,
"C6",		LCREG,	6,
"C7",		LCREG,	7,
"C8",		LCREG,	8,
"C9",		LCREG,	9,
"C10",		LCREG,	10,
"C11",		LCREG,	11,
"C12",		LCREG,	12,
"C13",		LCREG,	13,
"C14",		LCREG,	14,
"C15",		LCREG,	15,
@



% status register, works with MOV but normally it's a special
% ARM instruction: MSR and MRS
<<[[itab]] elements>>=
"CPSR",		LPSR,	0,
"SPSR",		LPSR,	1,
@


<<operand_kind cases>>=
D_PSR,
@

<<gen rule>>=
| LPSR
 {
  $$ = nullgen;
  $$.type = D_PSR;
  $$.reg = $1;
 }
@
%$


\section{Misc instructions}

<<pseudo opcodes>>=
ACASE,
@

<<[[itab]] elements>>=
"CASE",		LTYPED, ACASE,
@

% some of those are not really opcodes, they are entities 
% just at the asm level.

%hmm but nop? SHL? MOV? here because pseudo asm
% that get translated in store/load on some archi?

%??
<<inst rule(arm)>>=
/*
 * CASE
 */
| LTYPED cond reg comma { outcode($1, $2, &$3, NREG, &nullgen); }
@
%$





<<pseudo opcodes>>=
ABCASE,
@

<<[[itab]] elements>>=
"BCASE",	LTYPE5,	ABCASE,
@
% ??




<<misc opcodes>>=
ABX, // ?
ABXRET, // ?
ADWORD, // ?
ASIGNAME,
@

<<[[itab]] elements>>=
"BX",		LTYPEBX,	ABX,
@

<<inst rule(arm)>>=
/*
 * BX
 */
| LTYPEBX comma ireg { outcode($1, Always, &nullgen, NREG, &$3); }
@



<<misc opcodes>>=
ALDREX,
ASTREX,
ALDREXD,
ASTREXD,
@

% LDREX STREX CLREX are arm v7 new instruction according to 5db.c
%in atom.s:
%#define	CLREX		WORD	$0xf57ff01f
%#define	LDREX(a,r)	WORD	$(0xe<<28|0x01900f9f | (a)<<16 | (r)<<12)
%/* `The order of operands is from left to right in dataflow order' - asm man */
%#define	STREX(v,a,r)	WORD	$(0xe<<28|0x01800f90 | (a)<<16 | (r)<<12 | (v)<<0)

<<[[itab]] elements>>=
"LDREX",		LTYPE3, ALDREX,
"LDREXD",		LTYPE3, ALDREXD,
"STREX",		LTYPE9, ASTREX,
"STREXD",		LTYPE9, ASTREXD,
@




<<operand_kind cases>>=
D_FPCR,
@

<<[[itab]] elements>>=
"FPSR",		LFCR,	0,
"FPCR",		LFCR,	1,
@

<<gen rule>>=
| LFCR
 {
  $$ = nullgen;
  $$.type = D_FPCR;
  $$.reg = $1;
 }
@
%$

%/*
%    "ABSF",		LTYPEI, AABSF,
%    "ABSD",		LTYPEI, AABSD,
%    "NEGF",		LTYPEI, ANEGF,
%    "NEGD",		LTYPEI, ANEGD,
%    "SQTF",		LTYPEI,	ASQTF,
%    "SQTD",		LTYPEI,	ASQTD,
%    "RNDF",		LTYPEI,	ARNDF,
%    "RNDD",		LTYPEI,	ARNDD,
%    "URDF",		LTYPEI,	AURDF,
%    "URDD",		LTYPEI,	AURDD,
%    "NRMF",		LTYPEI,	ANRMF,
%    "NRMD",		LTYPEI,	ANRMD,
%*/




<<type declarations(arm)>>=
%type   <gen>   regreg
%type   <lval>  oexpr 
%type   <lval>  reglist
@



\section{Processing multiple files}

% why need that?


<<[[main()]] locals>>=
int nout, nproc, status;
int i, c;
@

<<[[main()]] multiple files handling>>=
if(argc > 1) {
    nproc = 1;
    if(p = getenv("NPROC"))
        nproc = atol(p);	/* */
    c = 0;
    nout = 0;
    for(;;) {
        while(nout < nproc && argc > 0) {
            i = fork();
            if(i < 0) {
                i = mywait(&status);
                if(i < 0)
                    errorexit();
                if(status)
                    c++;
                nout--;
                continue;
            }
            if(i == 0) {
                print("%s:\n", *argv);
                if(assemble(*argv))
                    errorexit();
                exits(0);
            }
            nout++;
            argc--;
            argv++;
        }
        i = mywait(&status);
        if(i < 0) {
            if(c)
                errorexit();
            exits(0);
        }
        if(status)
            c++;
        nout--;
    }
}
@

%\section{Thumb code}
% arg processing: (but then no more generic across 5a/ and 8a/)
%
%    case 't':
%        thechar = 't';
%        thestring = "thumb";
%        break;

\chapter{Conclusion}










\appendix

\chapter{Debugging}

% ex: 'm', 'f' (256 so can have for each character a boolean value)
<<global debug>>=
bool	debug[256];
@

<<[[main()]] debug initialization>>=
memset(debug, false, sizeof(debug));
@

<<[[main()]] command line processing>>=
default:
    c = ARGC();
    if(c >= 0 || c < sizeof(debug))
        debug[c] = true;
    break;
@

\section{[[8a -m]], macro debugging}
% m for macro

<<[[dodefine()]] debug>>=
if(debug['m'])
    print("#define (-D) %s %s\n", s->name, s->macro+1);
@

<<[[macdef()]] debug>>=
if(debug['m'])
    print("#define %s %s\n", s->name, s->macro+1);
@

\section{[[8a -f]], line information debugging}

<<[[linehist()]] debug>>=
if(debug['f'])
    if(f) {
        if(offset)
            print("%4ld: %s (#line %d)\n", lineno, f, offset);
        else
            print("%4ld: %s\n", lineno, f);
    } else
        print("%4ld: <pop>\n", lineno);
@

\chapter{Error Managment}

<<function errorexit>>=
void
errorexit(void)
{

    if(outfile)
        remove(outfile);
    exits("error");
}
@

<<global nerrors>>=
int	nerrors = 0;
@
% used to be initialized in cinit()

<<function yyerror>>=
void
yyerror(char *a, ...)
{
    char buf[200];
    va_list arg;

    /*
     * hack to intercept message from yaccpar
     */
    if(strcmp(a, "syntax error") == 0) {
        yyerror("syntax error, last name: %s", symb);
        return;
    }

    prfile(lineno);

    va_start(arg, a);
    vseprint(buf, buf+sizeof(buf), a, arg);
    va_end(arg);

    print("%s\n", buf);
    nerrors++;
    if(nerrors > 10) {
        print("too many errors\n");
        errorexit();
    }
}
@

<<constant HISTSZ>>=
#define	HISTSZ		20
@

<<function prfile>>=
void
prfile(long l)
{
    int i, n;
    Hist a[HISTSZ], *h;
    long d;

    n = 0;
    for(h = hist; h != H; h = h->link) {
        if(l < h->line)
            break;
        if(h->name) {
            if(h->offset == 0) {
                if(n >= 0 && n < HISTSZ)
                    a[n] = *h;
                n++;
                continue;
            }
            if(n > 0 && n < HISTSZ)
                if(a[n-1].offset == 0) {
                    a[n] = *h;
                    n++;
                } else
                    a[n-1] = *h;
            continue;
        }
        n--;
        if(n >= 0 && n < HISTSZ) {
            d = h->line - a[n].line;
            for(i=0; i<n; i++)
                a[i].line += d;
        }
    }
    if(n > HISTSZ)
        n = HISTSZ;
    for(i=0; i<n; i++)
        print("%s:%ld ", a[i].name, (long)(l-a[i].line+a[i].offset+1));
}
@

\chapter{Libc}

\section{Memory managment}
% same in Linker, not sure why they just don't use malloc?
% to avoid dependencies to libc? for bootstrapping reasons?

<<global hunk>>=
char*	hunk;
@

<<global nhunk>>=
long	nhunk = 0;
@
% used to be set in cinit()

<<global thunk>>=
long	thunk;
@

<<constant NHUNK>>=
#define	NHUNK		10000
@


<<function gethunk>>=
void
gethunk(void)
{
    char *h;
    long nh;

    nh = NHUNK;
    if(thunk >= 10L*NHUNK)
        nh = 10L*NHUNK;

    h = (char*)sbrk(nh);
    if(h == (char*)-1) {
        yyerror("out of memory");
        errorexit();
    }
    hunk = h;
    nhunk = nh;
    thunk += nh;
}
@



<<constant MAXALIGN>>=
#define MAXALIGN 7
@

<<function alloc>>=
/*
 * real allocs
 */
void*
alloc(long n)
{
    void *p;

    while((uintptr)hunk & MAXALIGN) {
        hunk++;
        nhunk--;
    }

    while(nhunk < n)
        gethunk();
    p = hunk;
    nhunk -= n;
    hunk += n;

    return p;
}
@

<<function allocn>>=
void*
allocn(void *p, long on, long n)
{
    void *q;

    q = (uchar*)p + on;
    if(q != hunk || nhunk < n) {

        while(nhunk < on+n)
            gethunk();
        memmove(hunk, p, on);
        p = hunk;
        hunk += on;
        nhunk -= on;

    }
    hunk += n;
    nhunk -= n;
    return p;
}
@


\chapter{Extra Code}

\ifallcode
#include "Assembler_extra.nw"
#include "Assembler_x86.nw"
\fi

\chapter{Changelog}
\label{sec:changelog}

\chapter{Glossary}
\label{sec:glossary}

\begin{verbatim}
ISA Instruction Set Architecture
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{section}{Index}

%\chapter{References} 
\addcontentsline{toc}{section}{References}

\begin{thebibliography}{99}

\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming}, 
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb}, 
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison}, 
\url{http://padator.org/software/project-syncweb/readme.txt}

\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
