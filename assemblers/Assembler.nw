\documentclass[twocolumn, landscape]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosetrue % see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things:
%  - better organisation of the code, my TOC is better than the few existing
%    files (which didn't have very good names)
%  - removed deadcode (Ref, imm2, con2, NMACRO, CLAST, isreg, ...)
%  - renamed some enums (as => opcode, <noname> => operand_kind)
%  - reordered opcodes and operand kinds, and cleaned them:
%     * removed opcodes (ADWORD, ABX, ...)
%     * removed operand kinds (D_GOK, D_ADDR, D_OCONST, ...)
%  - introduced sym_kind, splitted from operand_kind, for ANAME
%  - factorized more code between ARM and x86 (abusing LP chunks)
%  - removed a few grammar rules, weird operand forms that were not used anyway
%    as well as the optional commas here and there
%  - rename some grammar rules (spreg -> regi, sreg -> regi_nosp)
%  - TODO rename types, clearer, Gen? as Adr? or Operand? (and Gen2? as Prog?)

%thx to codemap/codegraph/scheck:
% - factorized code in aa/
% - mv errorexit, alloc, in utils.c instead of lexbody.c, same for gethunk
% - have a main.c instead of putting everything in lex.c

%thx to this manual, better understand assembly and assembler:
% - an object file is really a module: the simplest/lowest-level mod abstraction
% - calling conventions, they are really that on ARM, conventions
% - can actually understand the assembly code in Kernel.nw :) param1+0(FP)
% - the difference betweeen GLOBL and DATA, declaration vs definition
% - TODO bit shift logic vs arith?
% - TODO MOVs and unsigned? 
% -  <= and unsigned
% - TODO swap
% - TODO -fpic?

%history LP-ization:
% - skeleton, mostly copy paste of Template.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * TODO ctor/dtor, dumper
%    * [[xxx]] other fields, [[xxx]] extra fields
% - read Extra section, identify concepts, first TOC
% - distribute parts of the file before
% - nullify, boolify, typeify,    scheckify
% - aspecify advanced features!
% - SEMI add explanations
% - SEMI add figures

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
%\usepackage{cleveref} %\cref
%\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}
%\usepackage{minitoc}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% ifallcode is used for:
%  - forward decl, func decl, extern decl, #ifdef, pragmas (stuff in Extra.nw)
%  - STILL? misc opcodes (e.g. MVN)
%  - misc optional syntactic elements (e.g. commas)
%  - grammar literate boilerplate

%\usepackage[margin=0.5in]{geometry}
%  but eat the bottom when very low
%\usepackage{fullpage} is deprecated 
% => do the more manual below:
%\addtolength{\oddsidemargin}{-.850in}
%\addtolength{\evensidemargin}{-.850in}
%\addtolength{\textwidth}{1.70in}
\addtolength{\topmargin}{-.850in}
\addtolength{\textheight}{1.70in}
% too big constraints when in portrait mode, cause some WEIRD errors
% in landscape it's ok though

%\setcounter{tocdepth}{1}

\begin{document}
%******************************************************************************
% Title
%******************************************************************************
\title{
{\Huge 
Principia Softwarica: The ARM Assembler [[5a]]
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}\\
\\
with code from\\
Rob Pike
}

\maketitle 
\l ARMv6 (32 bits) edition, and 
\n alt: 8a x86 (32 bits) edition, see Assembler_x86.nw
\n Plan9 in core title? meh

\onecolumn
\hrule
\input{../docs/latex/Copyright}
\input{../docs/latex/CopyrightPlan9}
\hrule
\twocolumn

\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\tableofcontents
\endgroup

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

The goal of this book is to present with full details the source code of
an {assembler}.

\section{Motivations}

Why an assembler? Because we think you are a better programmer 
if you fully understand how things work under the hood, and 
an assembler is an essential part of any {development toolchain}.
\l which itself is essential
Indeed, compilers for higher level languages such as C usually
do not generate directly {machine code} but instead rely
on an assembler (and linker) for their final code-generation step.
\n 5c actually does not really rely on the external assembler 5a
\n but gcc/ocamlopt do generate assembly and call external assembler gas

Even if most programmers very rarely write {assembly} code,
understanding an assembly language, and so also what an assembler does,
is essential to understand low-level fundamental concepts such as 
{binary logic and arithmetic}, {memory operations}, {pointers}, 
{stack processing}, {frames},
{software interrupts}
and to understand what a compiler generates. 
%tags: compiler:
Note also that some code, especially in the kernel, can not be written in C
and has to be written in assembly.

Here are a few questions we hope this book will answer:
\begin{itemize}
\item What is the list of all assembly instructions?
What a typical computer can do?

\item What are the essential features of an assembler? How they help
over writing directly machine code?

\item What are the most important assembly constructs? How
can they be used to implement high-level constructs in languages
such as C?
\n labels is here, and it's assembly only, it's not in Machine.nw
%tags: compiler:

\item How function calls are implemented? What is a frame?
What is a frame pointer? How recursive functions are implemented?
What are calling conventions?
%SEMI

\item What is in an object file? What difference there is
between an object file and an executable?
%SEMI

\item How the assembler and linker work together?

\end{itemize}
\l binary format? no, in linker book
\n try questions more specific to asm, put the rest in Machine.nw
\l what is position independent code? maybe linker issue

%tags: turing: fundamental opcodes
%tags: ocaml: to give a hint on how rewriting C in OCaml could improve things
%tags: real-world: to relate to other assemblers
%tags: compiler: give idea of what 5c does
%tags: self-ref: opcodes to implement assembler itself!

\section{The \plan ARM assembler, [[5a]]}

We will explain in this book the code of the \plan ARM assembler
[[5a]]\footnote{\url{http://plan9.bell-labs.com/magic/man2html/1/8a},
which despite its name covers also [[5a]]}
%WEIRD: If I uncomment above I get weird pdftex errors when have big textheight
which is about 4100 lines of code (LOC).
\n see make loc (or cm -test_loc)
[[5a]] is written in C for the most part with its parser using also Yacc.
\l cite for C and Yacc?
%
Like for most books in \principia, we chose a \plan software because
they are simple, small, elegant, open source, and they form together
a coherent set of software.
The [[5]] comes from the \plan convention to name architecture
with a number or single letter (0 is MIPS, 5 is ARM, 8 is x86, etc),
and the [[a]] means assembler.
\l put in this section the discussions about Asm5 and Asm9?
\n single character, they like that, see also kernel and the #c, #i, etc

Like for the other \principia books covering the
{development toolchain}, we chose the ARM architecture~\cite{arm-refman}
variant, in this case of the \plan assembler ([[5a]]),
and not for instance the x86 variant ([[8a]]), for
reasons of simplicity. Indeed RISC machines
are far simpler than CISC machines. Moreover, the availability
under \plan of an ARM emulator, [[5i]], helps to understand
the semantics of the assembly instructions used in [[5a]].
\n Using x86 also make it more error prone when want to change things
\n because we would have also to change kencc (e.g. error prone to change
\n the order of asm instructions).

Note that the \plan assemblers output differs slightly from
other traditional assemblers. The {files} generated by [[5a]],
called the {\em object files},
are ARM-specific, but they do not contain really machine code. Instead
the object file is essentially the {serialized form} of the 
{abstract syntax tree} of the assembly source. 
\l Ref to later? maybe hard to understand. 
The actual machine code generation is performed by the linker [[5l]]
(so readers interested in this topic should read the \book{Linker}).
We think though that it is actually a better design because it leads to
less code in total and also to simpler code.
\n a critique of go/plan9 toolchain though, see comment in .tex:
% - http://dtrace.org/blogs/wesolows/2014/12/29/golang-is-trash/
%   with https://news.ycombinator.com/item?id=8815778
%   and http://www.reddit.com/r/programming/comments/2riayd/golang_is_trash/
\l say also Asm5 is not _direct_ representation of underlying ARM machine?

\section{Other assemblers}

Here are a few assemblers that were considered for this book but
which were ultimately discarded:
\begin{itemize}

\item The GNU Assembler [[gas]], part of the [[binutils]] package, 
is probably the most used open source assembler.
\n everything moved from as86 to gas
It supports many architectures, including ARM and x86.
It is called internally by [[gcc]] and so is indirectly
used to assemble most open source software.
\n maybe clang/llvm competes a bit now
It is very big though:
350K LOC for [[gas/]], which is almost two orders of magnitude
more code than [[5a]],
and 3.4M LOC for the whole [[binutils]] package (not including the testsuite).
Even the ARM-specific file [[gas/config/tc-arm.c]] has already 25 000 LOC.

\item NASM is a popular x86 assembler using the Intel
syntax as opposed to [[gas]] (and [[5a]]) which uses the \att syntax.
It is also fairly large: 50 000 LOC.
\n popular on linux especially, but also works on windows and mac

\item AS86, an x86 16-bit and 32-bit assembler, part of
Bruce Evans' C compiler (BCC), is an historical assembler
used to compile old versions of Minix and Linux. It is
also using the Intel syntax. Because it can generate 16-bit
``real-mode'' machine code, it is still used to compile programs such
as boot loaders. It is fairly small: 12 500 LOC. This
includes the machine code generation which is not done by [[5a]]
(but done by [[5l]]). 
\l to be fair LOC of 5l is big, but 5a plus 5l LOC < as86 plus ld86
However, because x86 is a rather
complicated architecture, the 16-bit/32-bit as well as
the different CPU modes (real-mode, protected-mode, virtual-mode) 
being just a testimony of this complexity, 
we prefer to present an ARM assembler.
\l a bit dead, used only by elks project now

\item MMIXAL, an assembler for the MMIX virtual machine
invented by Donald Knuth, is a small and 
very well documented program~\cite{mmixware}.
\n actually not that well, I dont like his style, no structure, no TOC
Its (literate) source is about 3200 LOC, which includes
the (virtual) machine code generation part.
But, in \principia we want to restrict ourselves to software which can run
on real machines.
\n what about mixal? used in the mdk, smaller? does not matter, not LP probably

\n assembler for hack? not included in distro, had to write ourselves!

\l also fasm, masm, tasm, seems popular

\end{itemize}

\l lots of other assemblers, see the comment in the .tex
%other:
% - llvm has one? well the IR of llvm is a kind of assembler, but portable
% - http://www.compilers.de/vasm.html (also vbcc and vlink)
%   recent fork: http://sun.hasenbraten.de/vasm/, used in amiga tutorial,
%mini:
% - fbas, use lex and yacc, 720 LOC, but looks really simplified
% - https://github.com/trillek-team/computer-toolkit include
%   a toy asm, linker, and even a toy C compiler
% - see also hex2c? the assembler in subc-2014, ...
%education:
% - pep/8 assembler?
% - web based assembler+debugger, teaching purpose: http://yasp.me/
%research:
% - piton, a proven assembler in boyer moore
% - TAL typed assembly language, 
% - Coq macro assembler
%see also http://www.tldp.org/HOWTO/Assembly-HOWTO/other.html


\section{Getting started}
\label{sec:getting-started}

To play with [[5a]] you will first need to install
the \plan fork used in \principia. See \urlinstall.
Once installed, you can test [[5a]] under \plan with:

\begin{verbatim}
1   $ cd /tests/5a
2   $ 5a hello.s
3   $ 5l hello.5 -o hello
4   $ ./hello
5   hello world
6   $
\end{verbatim}
\t 5l -?? so dumper of object file?

The command in Line 2 {assembles} the very simple [[hello.s]]
ARM assembly program and generates the [[hello.5]] ARM {object file}.
\n define object file? partly defined before in motivations
Line 3 then {links} the object file and generates the final 
ARM binary executable [[hello]].
Line 4, which assumes you are under an ARM machine (e.g. a Raspberry Pi),
{launchs} the program.

Note that it is easy under \plan to {cross compile} from another architecture;
you can use the same commands, [[5a]], [[5l]], etc.
\l because magic /bin, and also because special 5 convention
To play with [[5a]] under an x86 machine you just need then
after the linking step to use the ARM emulator [[5i]]:

\begin{verbatim}
...
4   $ 5i hello
...
\end{verbatim}

See the \book{Emulator} for more information on [[5i]].
\l actually cool cos can be used as an assembly debugger too

\section{Requirements}

Because most of this book is made of C source code, 
you will need to have a good knowledge of 
the C programming language~\cite{k-r} to understand it.
\l actually lots of bit manip, and C idioms used
To understand Chapter~\ref{chap:parsing} you will also
need to know Yacc~\cite{lexyacc}.
\l Can read Compiler.pdf :) and Generators.pdf :) but a bit self reference.

Note that this book is not an introduction to 
assembly programming.
We assume you already know one assembly language
(not necessarily the one used by [[5a]] though),
know roughly how an assembler works, and that you
have a basic understanding of computer architecture.
We assume you are already familiar 
with concepts such as
{registers}, {stack pointer}, {program counter},
{memory move}, {jumps},
{labels},
\n {frame pointer}, hmmm maybe not, we can explain in this doc.
etc.
We assume you already know most of the theory; this book is here to
cover the practice.
\l MIPS assembly tutorial, might give some ideas (use spim)
%http://programmedlessons.org/AssemblyTutorial/index.html


It is not necessary to know the ARM architecture to
understand this book, but
we recommend to read the \book{Emulator} to fully understand
the semantics of some assembly instructions.
\l maybe Machine.nw is actually a necessary requirment?

It can be also useful to read the documentation of
the \plan assemblers available in our \plan repository in 
[[assemblers/docs/asm.pdf]] and
[[docs/man/1/8a]]\footnote{Despite its name this document also covers [[5a]]}.
\n 'as' article in unix programmer's manual? meh, seems unrelated to 5a.
There are also some extra notes about the assemblers
at \url{https://golang.org/doc/asm} which can be useful.
\n Go used to use the plan9 developer toolchain, made by same authors :)



\section{About this document}
#include "../docs/latex/About.nw"

\section{Copyright}

Most of this document is actually source code from Plan9, so
those parts are copyright by Lucent Technologies Inc.
The prose is mine and is licensed under the \license.

\section{Acknowledgments}

We would like to acknowledge of course the author of
[[5a]], Rob Pike, 
who wrote in some sense most of this book.






\chapter{Overview}

Before showing the source code of [[5a]] in the following chapters, 
we first give an overview in this chapter
of the general principles of an assembler, 
of the assembly language supported by [[5a]],
and of the format of the object files generated by [[5a]].
We also define terms, explain how the code is organized, 
and more generally give the background needed 
to understand the code we will show later.

\section{Assembler principles}

An {\em assembler} is a program which translates source code
written in an {assembly} programming language into
{machine code}, or into an {object code} close to machine code.
%
An {\em assembly} langage is a low-level programming language mimicing
closely the {instructions} of a machine, but using a {textual}
format far more convenient for the programmer than the
{binary} format used internally by computers.
\n as close as possible but not closer
%
Note that each assembly language is specific to a computer architecture.
\l and in fact even different assembler for same arch use different syntax
\n so it is not portable; C is a portable assembler!

Assembly languages use {\em mnemomics} to denote low-level {instructions}.
%
For instance an assembly programmer can simply use the mnemomic
[[ADD]] in his code instead of having to remember that [[0000100]]
is the binary code to perform an addition in an ARM
processor.
%
Typical instructions are made of an {\em opcode} and 
one or more {\em operands}.
%
For instance [[ADD 15, R1, R4]] is a complete assembly instruction 
telling the computer to add fifteen to the first register
and to put the result in the fourth register.
\l again mnemonic too for register names, and actually it's \$15
\n note that cant have ADD R1, 15, R4 because ARM restrictions on ADD
\n also note att syntax, left to right

A key feature of assemblers is to allow the use of {\em symbolic addresses}
as operands, freeing the programmer from tedious manual calculations.
%
Indeed, in assembly a programmer can {{define}} {\em symbols} designating
certain memory areas (code area or data area),
\n use 'symbols' not 'labels', more general; they are in symbol table of binary
\n put globals or functions, hmm but label make things more general
and can then {{use}} those symbols as operands.
For instance [[B foobar]] allows to {branch} (jump) 
to the code following the [[foobar]] symbol. 
\n actually it is B foobar(SB) in 5a if foobar is a symbol and not a label
%
Without symbolic addresses a programmer
would have instead to write something like [[B 1562]] and make sure
that he calculated correctly that 1562 was the address corresponding
to the thing he wanted to jump to. This would require to know
the size of each instruction, and each further modification of the program
could entail the recalculation of all those addresses.

So, the main functions of an assembler are typically:
\n function almost in a literal way; those phases correspond almost to 5a funcs
\begin{enumerate}
\item to {\em parse} an input textual file,
\item to {\em check} that the combinations of opcodes and operands form 
valid machine instructions,
\n in 5a actually a few checks are delayed until linking
\item to {\em compute} the concrete values of symbolic addresses
(which usually requires a two pass algorithm as one can reference symbols
defined later in the file)
\n in 5a actually only labels are resolved, symbols are delayed until linking
\item to {\em generate} the binary machine code.
\n again 5a is special here
\end{enumerate}

In fact most assemblers do not generate the final machine code but instead
generate an {\em object code}, which is mostly machine code but
with extra information about {\em unresolved symbols}.
\n local labels disappear? Yes! in 5a at least
%
Indeed, even if for small programs the definitions and uses of symbolic
addresses could be in the same single file, as programs
grew larger it becomes useful to separate the source in different files.
\l for separation of concern, modularity, libs, reuse, separate compilation, ..
\l but now I do everything in one big file, so maybe can revisit that idea
In this case, one could want to reference in one assembly file
a symbol defined in another file. This is why the object file
must contain, in addition to machine code, enough information
about the {external} symbols this assembly file is using
(as well as the symbols it defines)  so that another tool, the {\em linker}
can later fully {\em resolve} all the symbol references used in all the files.
\n asm.pdf use external a lot, but often he means global
%
In essence, an object file is really the simplest form
of a {\em module}: it packs code, data, and information
about {exported} and {imported} entities.
\n but no properties for those entities, so not a real interface

A linker then essentially 
{concatenates} the code (and data) of the multiple object files together,
{resolves} all the symbolic addresses now that all 
the code (and data) is available and has been assigned a fixed memory area,
\n in fact can be tricky for variable-sized instructions like in x86,
\n has to make pessimistic guess and it complicates a lot things
{patches} all the incomplete instructions that were using unresolved symbols,
\n actually 5l does not patch machine code really
and finally {generates} the final binary executable.

\l lots of todo, figures, relocate local things, see comment in .tex
%put some concrete examples where see two assemblies, with symbols
%defined and used, and how the linker resolve and then relocate those things?
%or let that to the linker book?
%
%So the assembler must output code that must be "resolved" later, with 
%some symbol table information in the object for the linker
%to know what to do and where to patch things.
%
\t The objects will also be concatenated together so branch/jmp addresses
\t need also to be "relocated", and the same for the reference to 
\t external symbols.

\section{[[5a]] command line interface}

The command line interface of the assembler [[5a]] is pretty simple:
\begin{verbatim}
$ 5a
usage: 5a [-options] file.s
$ 5a foo.s
$ 5l foo.5 bar.5 ...
\end{verbatim}
\t instruction to disassemble foo.5? db foo.5?

Given an input {assembly file} [[foo.s]], 
[[5a]] outputs an {object file} [[foo.5]].
One can change this default behaviour by using the [[-o <outfile>]] option.
\l normally generate (relocatable) machine code, but here 5a is a bit unusual.
Other options are related to macroprocessing and debugging and will 
be described later.
\l -D -I (cpp),  -f -m for debug
\t env: INCLUDE (for cpp, similar to -I), NPROC (when multi files?)


\section{[[helloworld.s]]}
\label{sec:helloworld}

From now on we call {\em Asm5} the ARM assembly language supported by [[5a]]. 
%
Because the different \plan assemblers
are really variations of a single program, the
assembly languages they support are also variations of a single language
we call {\em Asm9}. Asm5 can be seen as a specialized version of Asm9
for the ARM processor.
By understanding Asm5 you will understand also fairly well the assembly
languages supported by the other \plan assemblers (e.g. [[8a]])
as they have a lot in common.
\n asm is not portable, but cos they have a lot in common, easier a bit to port
\n even more easier thx to the virtual instructions such as MOVW or RET

In this section we will show a simple Asm5 program, [[helloworld.s]],
which prints [[Hello World]] when executed. We will use this
program as a tutorial for Asm5 (and more generally for Asm9).
\n I'd rather not write this tutorial but all existing docs on Asm5 are bad

\subsection{Background}

To understand [[helloworld.s]] we must first show
the equivalent program written in C to introduce some background
on how to perform {system calls} in \plan.
\l system call em? link to Kernel book?
\n could have a hello.s that you link with libc so easier
\n but I like the idea of really raw simple hello world in assembly!
\n for Linux: http://sysdigcloud.com/fascinating-world-linux-system-calls/

Here is the simplest \plan{} [[hello world]] program written in C:

<<helloworld1.c>>=
#include <u.h>
#include <libc.h>

void main() {
  print("hello world\n");
}
@

This code is using the [[print()]] function from the core C library.
If we expand the code of this function and simplify things
we will get this C program:

<<helloworld2.c>>=
#include <u.h>
#include <libc.h>

void main() {
  pwrite(1, "hello world\n", 12, 0);
}
@

The [[pwrite()]] function is also defined in the C library,
but it is written in assembly in [[lib_core/libc/9syscall/pwrite.s]].
\n actually it's auto generated by mk from sys.h
It is a small wrapper around the {software interrupt} ARM instruction 
[[SWI]] which performs a {\em system call} (also known as a {\em syscall}).
\l more on this SWI later
%
Here is the prototype of [[pwrite()]] defined in [[include/core/libc.h]]:

<<prototype pwrite in libc.h>>=
extern	long	pwrite(fdt, void*, long, vlong);
@

The [[pwrite()]] interface is documented in 
[[docs/man/2/read]]\footnote{Again, despite its name this document also
covers [[pwrite]]}.
The parameters are in order 
a {file descriptor} (e.g. [[1]] for standard output), 
a string pointer, 
the number of bytes to write,
and finally a [[vlong]] seeking offset. 
%
Most of the parameters take 4 bytes except the [[vlong]] which takes 8 bytes.
\l will be important, see later
\l pwrite is the syscall, not write, vlong seek is for protocol atomicity, 2in1

\subsection{The program}
\label{sec:hello-program}

We now have enough background to present the [[helloworld.s]]
program:

<<assemblers/5a/tests/hello.s>>=
1 	TEXT _main(SB), $20
2 	        B later
3 	        B loop /* not reached */
4 	later:
5 	        /* fill missing characters for hello */
6 	        MOVW $hello(SB), R2
7 	        MOVW $'W', R1        
8 	        MOVB R1, 6(R2)
9 	        MOVW $'o', R1        
10	        MOVB R1, 7(R2)
11	        MOVW $'r', R1        
12	        MOVB R1, 8(R2)
13	        MOVW $'l', R1        
14	        MOVB R1, 9(R2)
15	        MOVW $'d', R1        
16	        MOVB R1, 10(R2)
17	        MOVW $'\n', R1
18	        MOVB R1, 11(R2)
19	        /* prepare the system call PWRITE(1,&hello,12,00) */
20	        MOVW $1, R1
21	        MOVW R1, 4(R13)
22	        MOVW $hello(SB), R1
23	        MOVW R1, 8(R13)
24	        MOVW $12, R1
25	        MOVW R1, 12(R13)
26	        MOVW $0, R1
27	        MOVW R1, 16(R13)
28	        MOVW R1, 20(R13)
29	        MOVW $9 /*PWRITE*/, R0
30	        /* system call */
31	        SWI
32	        BL exit(SB)
33	        RET /* not reached */
34	loop:
35	        B loop
36	        
37	
38	TEXT exit(SB), $4
39	        /* prepare the system call EXITS(0) */
40	        MOVW $0, R1
41	        MOVW R1, 4(R13)
42	        MOVW $3 /*EXITS*/, R0
43	        /* system call */
44	        SWI
45	        RET /* not reached */
46	        
47	                        
48	GLOBL   hello(SB), $12
49	DATA    hello+0(SB)/6, $"Hello "
50	
@
%$
\n No libc! Using a simple _main. As simple as possible.
\l can also maybe show one that use libc, use 5c -S hello.c
\l show more examples? to get a feel for the lang e.g. code of strchr, div,...
\t can do with SP instead of R13 so less leaky abstraction 4(R13)
\l note that we call PWRITE syscall directly, not pwrite(), subtle

To assemble, link, and execute this program, simply do
like in Section~\ref{sec:getting-started}:
\begin{verbatim}
$ 5a hello.s
$ 5l hello.5 -o hello
$ ./hello
hello world
\end{verbatim}
\l if under ARM machine
\l show actual code? echo '$t :c' | 5i hello 
%$
\l show binary format? hexdump? (actually not bin instruction format! see below)

\subsection{Pseudo-instructions}

The [[helloworld.s]] program defines three {symbols}:
two {procedures} [[_main()]] and [[exit()]], and one {global} [[hello]].
%
The two procedures are introduced via the [[TEXT]] 
{\em pseudo-instruction} Line~1 and 38,
and the global via [[GLOBL]] Line~48.
We say ``pseudo'' (or sometimes ``virtual'') because those
instructions do not match directly a machine instruction.
They are assembly-only constructs, also known as
{\em assembly directives}. Indeed, the ARM processor
has no notion of procedure names; it just manages numbers
and concrete addresses.
\l GLOBL allocate mem, and TEXT actually does magic stuff

The operands of the pseudo-instructions [[TEXT]] and [[GLOBL]]
\n was arguments, but better operands, for uniformity, because they are really
are the name of the {symbol} it defines, followed by [[(SB)]]
which we will explain later, and a {\em constant} value prefixed by a dollar.
In Asm9 all constants are prefixed by a dollar.
\l why? ambiguities? I think it's stupid because easy to make mistake then
\l actually in DATA the size is specified without dollar in .../6, offsets too
% I was doing MOVW 0, R1 which translates to MOVW 0(R0), R1 (not sure why)
% instead of MOVW $0, R1 and so had some segfaults at 0xc because
% R0 was return value from syscall which was lenght printed = 0xc
%
For [[GLOBL]] the constant value represents the size, in number of
bytes, this global will use. For [[hello]] Line~48 it is [[12]]; enough
to hold the [["hello world\n"]] string.
%
For [[TEXT]] the constant value represents the size, in number of bytes,
this procedure will need for its {\em locals} in the {stack}. 
For [[_main()]] Line~1 it is [[20]], the
number of bytes needed to hold all the {arguments} in the stack
to the [[PWRITE]] system call 
\l more on this later, locals and arguments are the same
(4 for the file descriptor integer, plus 4 for for the string pointer,
plus 4 for the size, plus 8 for the [[vlong]] offset).
\n actually there is an implicit plus 4 as we will see later

Note that the linker, [[5l]], is looking for a procedure named
[[_main]] for the entry point of the executable it generates,
even though the entry point of C programs is [[main]], not [[_main]].
This is because the core C library defines a [[_main()]] procedure
written in assembly which does some core initialisations
and then calls [[main()]].
In our example we do not use and so do not link the C library, 
to simplify things,
\l but in the end meh
so we must define our own [[_main()]] entry point procedure.

%real-world: use .text, .data

\subsection{Labels}

The first instruction of [[_main()]] Line 2
\l actually there is an hidden instruction generated dealing with R14/R13
is a jump, known as a {\em branch} in ARM (hence the [[B]]),
to [[later]], which is a {\em label} defined Line~4.
In Asm9 all label definitions are suffixed by a colon. 
\l in some sense TEXT and GLOBL are also introducing labels
\l how actually translated? B 1543? relative to PC?(R15)?
%
The syntax for {comments} in Asm9 are the same than in C
(see Line 3 and 5 for instance).

\subsection{Assignments}

Line 6 places the {address} of the [[hello]] global
(suffixed again by [[(SB)]] which we will explain later)
in the {register} [[R2]]. 
There are 16 ARM registers named [[R0]] to [[R15]].
\l last 3 have special meaning and used specially by ARM
Note that Asm9 uses a {\em left-to-right} assignment syntax\footnote{called the
\att syntax as opposed to the Intel syntax which is right-to-left}.
Moreover, in Asm9 [[MOV]] instructions are suffixed with a letter
corresponding to a size: [[W]] for word, [[B]] for byte, etc.
\l hmm also sometimes MOVBU, gas does that too
\n also MOV is virtual instr, see later
Line 7 places the character constant [['W']], converted
by the assembler in its integer ASCII value (87), into the
register [[R1]].
\l also unicode?

\subsection{Addressing modes}
\n https://en.wikipedia.org/wiki/Addressing_mode

Line 8 introduces a new {\em memory addressing mode}.
It is the first instruction that writes into memory; until now
we were only modifying the content of registers.
%
It {stores} the first byte (because of the [[B]] suffix)
of register [[R1]] (which should contain 87)
at the address {denoted} by [[R2]] plus [[6]].
%
The assembly instruction [[MOVB N, O(B)]] roughly corresponds
to the following C statement [[B[O] = N]], if [[B]] is a byte pointer,
which is also equivalent to this other C statement [[*(B+O) = N]].
\l what a strange syntax ... not sure where comes from, apparently not unix as
\n apparently vasm uses similar syntax, so maybe 68k motorola assembly syntax
\n which would make sense since 2a was the first assembler written by Pike
[[O]] is called the {\em offset}, which is applied to 
a pointer [[B]] called the {\em base}.
This addressing mode is called {\em indirect with offset}.
The [[()]] around the register corresponds rougly to the 
C {dereferencing} operator [[*]].
\t why not MOVB 'W', 6(R2)? because linker limitations. Also RISC! LOAD/STORE
\l  but it does some magic for other virtual instr, so why not this one?
\l  because cc didn't need it?
\l there is mo pointer arithmetic though, for MOVW it is also raw B plus O

In fact, Line 6 introduced also an addressing mode.
The syntax [[hello(SB)]] is reminescent of the base
and offset addressing mode we have just seen.
[[SB]] stands for {\em static base} register.
It refers to the beginning of the address space of the program.
\n more on this later, it's a pseudo, it's not needed, it's weird
In Asm9 all references to global data and procedures
are written as offsets to [[SB]] 
\t offset cos in the end symbols will have static address and so static offset
(for definition references see Line 1, 38, 48, and 49, and 
for use references see Line 6, 22, and 32).
%
The instruction [[MOVW foo(SB), R1]] will move the {\em content}
at the address denoted by the symbol [[foo]] into [[R1]].
The instruction [[MOVW $foo(SB), R1]] %$
will store the {\em address} denoted by the symbol [[foo]] in [[R1]].
The \$ in that case corresponds rougly to the 
C {address} operator [[&]].
\t ugly to overload dollar which is already used for constants? or because
\t in the end it will be a constant, it will be really an offset
\l it is the first instr that read memory?? it's static?
\l but why the generated code for Line 6 is MOVW #84(R15), R2 ? #10a8=#2000 ???
\l this SB is weird

\subsection{Pseudo-registers}

[[SB]] is actually one of the few {\em pseudo-registers} in Asm9.
[[PC]] is another one which corresponds to the
(virtual) {\em program counter}. 
Similar to pseudo-instructions, pseudo-registers
do not correspond exactly to machine registers.
Indeed, the ARM has already a hardware register, [[R15]], which 
represents the program counter. 
Because the ARM has fixed-length instructions of 4 bytes,
the value of [[R15]] is always a multiple of 4. The pseudo-register
[[PC]] instead counts instructions, not bytes of data. So,
to branch to the second following instruction (that is to skip
one instruction) one does [[B 2(PC)]].
\t which is really *(PC _plus_ 2)
It is equivalent to [[B 8(R15)]].
\l I think it is equivalent
\n branch are absolute, PC plus 2 is absolute

Why using pseudo-registers? The advantage of using [[2(PC)]]
instead of [[8(R15)]] in Asm5 may look small. But, on some
architectures the size of instructions is actually variable.
It is not trivial for instance on x86 to compute the number
of bytes two arbitrary instructions are using.
%
Just like with the symbolic addresses, using pseudo-registers
allows the programmer to think in slightly higher-level terms, 
for [[PC]] in terms of instructions instead of bytes of data,
and delegate some tedious tasks such as counting
the size of instructions to the computer.

Asm9 defines four pseudo-registers:
\begin{itemize}
\item [[PC]], the (virtual) {\em program counter} which counts in 
number of instructions.
For the ARM, [[PC]] is related to the (real) program counter register [[R15]].

\item [[SB]], the {\em static base} register which
refers to the beginning of the address space of the program.
For the ARM, [[SB]] is related to the machine register [[R12]].
\t For SB it's more tricky to understand why we need that.
\l R12 is reserved by assembler, it's not reserved by machine

\item [[SP]], the (virtual) {\em stack pointer}, used to access local
variables in the stack.
\l also called auto, but local maybe bad name; it is also for callee args
For the ARM, [[SP]] is related to the (real) stack pointer register [[R13]].
\l apparently it points to the top of the local stack frame! so offset
\l must be negative

\item [[FP]], the {\em frame pointer}, used to access the arguments
of the procedure in the stack, which is also related
to [[R13]] for the ARM.
\l set by caller
\t related to SP? more on this later

\end{itemize}

In this tutorial we will avoid using those pseudo-registers (except
[[SB]] because we have no choice).
Indeed, they may simplify things in the long term but they
add some extra complexities at the beginning.
\l generic, hide normally pecularities, complexities, but add some complexity

\subsection{Call stack}

Line 6 through 18 set characters in the [[hello]] global array of characters. 

We can now examine Line 20 through 29 which build the {arguments} for the
system call performed Line 31 (with the software interrupt instruction
[[SWI]]). Arguments, in function calls or system calls, are by {convention}
in \plan hold primarily in the stack. We will see later that
[[R0]] plays also a special role regarding arguments because of 
some C and kernel {\em calling conventions}.
\l convention to be in stack, but convenient, for recursive
As said in the previous section, [[R13]] is the ARM stack pointer register.
\n I use R13 and not SP because SP is a pseudo which get played with
\n in the linker, so simpler use directly R13 to minimize explanations
\t and also because I dont understand how to use SP properly ... hmmm
Figure~\ref{fig:stack-start}
is a representation of the stack when the [[hello]] program
is loaded in memory by the kernel
(the stack grows downward so high addresses are at the top
in the diagram).
\n OSTEP book uses stack growing upward

\begin{figure}[!]\centering
\begin{verbatim}
        |       |
        |       |
R13 +-> +-------+
\end{verbatim}
\caption{Stack when [[hello]] started}\label{fig:stack-start}
\end{figure}

[[R13]] is initialized by the kernel before the kernel gives
control to the entry point of the binary program.
Its value is very high in the virtual memory address space.
Here is a dump of the registers using the emulator/debugger [[5i]]
before the program starts
\footnote{To fully understand the values of those registers
see the \book{Kernel} or the \book{Emulator} 
and especially the code of [[initmemory()]] in [[5i]].
}:

\begin{verbatim}
$ 5i helloa
5i> $r
...
R0  #7fffff70 R1  #7ffffffc R2  #0        R3  #0
R4  #0        R5  #0        R6  #0        R7  #0
R8  #0        R9  #0        R10 #0        R11 #0
R12 #0        R13 #7fffff58 R14 #0        R15 #1020
\end{verbatim}
\n first output line is: PC  #1020     SP  #7fffff58 but confusing I think
\n  because SP here is the machine SP, not assembler SP
\n why R0 weird value? and R1? TOS?
% in 5i see initmemory():
%    STACKTOP	= 0x80000000, 
%    ...
%    reg.r[0] = tos;
%    reg.r[REGSP] = sp;
%    reg.r[1] = STACKTOP-4;	/* Plan 9 profiling clock (why & why in R1?) */


Remember that the second operand to the [[TEXT]] pseudo-instruction
is the number of bytes this procedure will need for its {locals} in the {stack}.
\l locals, arguments
So, when assembled the [[TEXT]] pseudo-instruction Line~1
should generate a machine instruction which decrements R13 by 20. 
In fact, the actual generated instruction decrements R13 by 24;
\l in fact it also does also some magic with R14
we will see later why we need an extra word in the stack before the arguments.
%
Figure~\ref{fig:stack-line2} is the representation of the stack after Line~1
when the processor starts to execute the instruction Line~2.

\begin{figure}[!]\centering
\begin{verbatim}
        |       |
        |       |
    +24 +-------+ <-+ old value of R13
        |       |
    +20 +-------+
        |       |
    +16 +-------+
        |       |
    +12 +-------+
        |       |
     +8 +-------+
        |       |
     +4 +-------+ <- start of "locals"
        |       |
R13 +-> +-------+
\end{verbatim}
\caption{Stack before Line 2}\label{fig:stack-line2}
\end{figure}

Figure~\ref{fig:stack-line31} is the same stack before Line~31 
after the arguments to the system call have been set by Line~20 through 28.
\l note that arguments are in the ``stack space'' of the caller

\begin{figure}[!]\centering
\begin{verbatim}
        |       |
        |       |
    +24 +-------+ <-+ old value of R13
        |  0    |
    +20 +-------+
        |  0    |
    +16 +-------+
        |  12   |
    +12 +-------+
        |&hello |
     +8 +-------+
        |  1    |
     +4 +-------+ <- start of PWRITE arguments
        |       |
R13 +-> +-------+
\end{verbatim}
\caption{Stack before Line 31}\label{fig:stack-line31}
\end{figure}
\l remember 0 0 because vlong offset

\l getcallerpc code? with special minus 4
%TEXT getcallerpc(SB), 1, $-4
%	MOVW	0(R13), R0 /* R13 = SP */
%	RET
% 1 attribute??? need diagram again

\subsection{System call}

The \plan{} {\em kernel calling conventions} impose to have all
the arguments in the stack ``above'' [[R13+4]],
and to use [[R0]] to hold
the syscall ``code''. The magic constant value [[9]]
at Line~29 is the code corresponding to the [[PWRITE]]
system call. See the file [[lib_core/libc/9syscall/sys.h]] 
which defines all those syscall codes.
\l could actually #include and use PWRITE
\n R0 is not the first argument anymore
The [[SWI]] instruction Line~31 then performs the system call
and jumps in the kernel.
\l need extra words before arguments for syscall too? because C convention?

\subsection{Function call}
\l branch and link

Regular function calls in Asm5, e.g. the call to [[exit]] Line~32,
use the [[BL]] instruction which stands for {\em branch and link}.
%
Some processors such as the x86 have a [[CALL]] instruction 
which when executed push on the stack the value of the program counter
and then jump/branch to the code of the callee.
\t put diagram of recursive call here? how the magic works!
Then, a corresponding [[RET]] instruction in the callee
will pop back this value in the program counter to return back
to the caller.
\t and add 4? or it's done before? see code of BL in Machine.nw
\l classic use of stack, can do recursive functions like that
%
In the ARM, [[BL]] instead saves the value of the program
counter [[R15]] in the special register [[R14]] 
known as the {\em link register}, and then jump to the callee. 


The use of a special register to hold {return addresses}
is an ARM optimisation which avoids using the stack, and so 
memory (which is slow), in certain situations.
%
Indeed, when a function does not call other functions, 
in which case it is called a {\em leaf} function, the value
of [[R14]] does not need to be saved and so returning
to the caller can be done quickly by setting the program
counter to the value in the link register via: [[B (R14)]].
\l or MOVW R14, R15 but apparently 5l does the B above.
%
If the function is not a leaf, then the value in [[R14]]
must be saved somewhere, in the stack, before the function calls
another function via [[BL]] which would overwrite [[R14]]
\footnote{See the \book{Emulator} for more information on the ARM and [[BL]])}. 
%
Non-leaf functions are the reason the [[TEXT]] pseudo-instruction
allocates one more word than its second operand, e.g. 24
instead of 20 for [[_main]] Line~1, to hold the return address
to the caller in case [[R14]] needs to be saved.

\subsection{Virtual instructions}

The leaf detection is done ({statically}) by the linker, [[5l]],
since it is the program generating actually the machine code in \plan,
and so the program which needs this information to optimize machine code.
%
A leaf is simply any procedure which does not contain any [[BL]] instruction,
for instance [[exit]] in our example\footnote{[[SWI]] does not count 
as a function call; [[R14]] is not overwritten by a [[SWI]].
}.
\l In any case the kernel saves all the registers of the calling process?
\l actually only when context switch no?
[[_main]] on the opposite is not a leaf function since it is
using [[BL]] Line~32.
%
The actual machine instructions generated for the [[TEXT]] pseudo-instruction
depends on whether the function is a leaf. 
The same is true for [[RET]], Line~33 and 45,
which is called a {\em virtual instruction}.
\l we call it that way? or asm.pdf does?
Indeed, the ARM does not have any [[RET]] instruction.
%
Figure~\ref{fig:virtual-text-ret}
describes roughly what machine code is generated
for the pseudo and virtual instructions [[TEXT]] and [[RET]]
of a simple procedure [[foo]], depending on whether this
procedure is a leaf or not.

\begin{figure}[!]\centering
\begin{verbatim}
TEXT foo(SB), $0   MOVW R14, 0(SP)          
                   SUB $4, SP, SP
 ...               ...                      ...
                   ADD $4, SP, SP           
 RET               B 0(SP)                  B (R14)
----------------  -----------------------  ------------------
  assembly code    machine code non-leaf    machine code leaf
\end{verbatim}
\caption{Machine code for pseudo/virtual instructions [[TEXT]] and [[RET]]}
\label{fig:virtual-text-ret}
\end{figure}
\t but SP is virtual above? or R13?
\l actually for TEXT it is a single MOVW.?? R14, #-4(R13) 
\l  and for RET it is MOVW.P #4(R13), R15
\l and actually it's ADD 0, R14, R15 instead of B (R14) (5l opti?)
\l not also that leaf opti is applied only if no locals (autosize = 0)
\l  so a bit less interesting. See leaf.s

\n real world: -fomit-frame-pointer! no need save SP in the stack!
\n but then harder to walk the stack!
\n can statically know when do RET what you allocated already,
\n can restore old SP easily.

The virtual instruction [[RET]], just like the 
pseudo-instruction [[TEXT]], or the pseudo-registers, allows the programmer
to think in slightly higher-level term and let the computer
do the appropriate optimizations.
%
In fact, [[MOVW]] is also a virtual instruction. It hides some 
architecture restrictions and peculiarities regarding memory accesses.
in Asm5 one can use the very general [[MOV]]
even though the ARM processor supports only the
more basics and separate [[LOAD]] and [[STORE]] instructions.
\n actually there is a MOV and it's LDR and STR but same basic idea
\l but a bit leaky abstraction because the linker puts later some restrictions

Instructions Line~40 though 44 are similar to the instructions
we have seen before. They perform the system call [[exits(0)]]
which terminates the program. This is why a few instructions
have been marked with a comment indicating those instructions
can not be reached since the program will have exited already
and so will not perform the [[RET]].

\subsection{C calling conventions}

Note that the way arguments are laid out in the stack in
Figure~\ref{fig:stack-line31}, as well as the extra word before the
arguments (to possibly save the return address to the caller via
[[R14]]), and the fact that all those elements are ``above'' the stack
pointer ([[R13]]) at the entry of the function callee (or syscall
interrupt handler), is just a convention. 
%
The ARM processor does not dictate any specific way to call procedures.
In fact it does not even have a notion of procedure.
It only provides the [[BL]] machine instruction which saves 
[[R15]] in [[R14]]. The rest is a design choice.

The calling conventions we use in this tutorial come from the
{\em C calling conventions} used by the C compiler [[5c]].
Indeed, the assembly code generated by [[5c]] assumes
arguments are passed in a certain way and the stack
pointer has a certain value. 
\t because you need that! you need at least a convention
We use similar conventions
in this tutorial because the code we present
performs a system call and the \plan{} {kernel calling conventions}
are derived from the C calling conventions. Indeed, the kernel
is mostly written in C.

The C calling conventions are actually slightly different from
the kernel calling conventions. Instead of using [[R0]] to
store the syscall code, [[R0]] is used to store the first argument.
In fact [[R0]] is also used to store the return value of C
functions.
\l except for vlong? and float?
This is an optimisation similar to the one we have seen previously
with the link register. 
\l but compiler opti, not hardware opti
For certain simple and small functions,
everything can be done using just registers, without having to use
the stack and so the (slow) memory.

Figure~\ref{fig:stack-c-pwrite} shows how the stack would
look like is we were calling the C function [[pwrite()]]
instead of doing directly the system call to [[PWRITE]].

\begin{figure}[!]\centering
\begin{verbatim}
        |       |
        |       |
    +24 +-------+ <-+ old value of R13
        |  0    |
    +20 +-------+
        |  0    |
    +16 +-------+
        |  12   |
    +12 +-------+
        |&hello |
     +8 +-------+
        |       |
     +4 +-------+ <- start of pwrite() arguments
        |       |
R13 +-> +-------+

R0 = 1
\end{verbatim}
\caption{Stack and [[R0]] value for a C call to [[pwrite()]]}\label{fig:stack-c-pwrite}
\end{figure}

Note that because the first argument is stored in [[R0]], 
the code generated by [[5c]] for a function call does not
bother to store it also in the stack. But, similar to the
link register optimisation, an extra word in the stack is still allocated
for the first argument in case the callee need to overwrite [[R0]]
in which case it can save first its value in the stack.
\l note that like R14 we save extra space in caller without knowing
\l if callee really needs it.

The calling conventions used by [[5c]] could be completely different:
the order of the arguments in the stack could be reversed, 
\l but C variable number of arguments '...' would be harder
more registers could be used to store the first $n$ arguments,
the stack arguments could be ``below'' the stack pointer,
the responsability to manage the return address in the stack
could be done by the callee instead of the caller.
The actual {\em C calling conventions} implemented by [[5c]]
are though a nice compromise between simplicity and speed.

Because most assembly code interoperate with C code,
they can also be {\em assembly calling conventions}.
Note that the only calling convention imposed by Asm5
is the extra word in the stack above [[R13]] to store
the return address to the caller, because of the
code generated for [[TEXT]] and [[RET]] by [[5l]].

\subsection{Data layout}

The last piece of assembly code we need to explain is Line~49 which initializes
(partially) the content of the [[hello]] global. Indeed, 
even if Line~48 {\em declares} the [[hello]] global with the [[GLOBL]] 
pseudo-instruction, it is the [[DATA]] instruction which {\em defines}
the content of the global. 
%
The operands of [[DATA]] are in order:
\begin{enumerate}
\item the symbol of the global,
possibly with an offset (here [[+0]]), and as always for references to
globals or procedures the [[(SB)]] suffix

\item a slash followed
by an integer between 1 and 8 representing the size in
number of bytes this [[DATA]] instruction is defining (here [[/6]])
\l but no dollar here, hmmm
 
\item a constant, which can be an integer, a character, or a string of
less than 8 bytes.
\end{enumerate}
\l a bit weird those constraints and conventions

To define data which takes more than 8 bytes, one needs
to use multiple [[DATA]] instructions. For instance
to define completely [[hello]], which would remove the need
for Line~6 to 18 (added for educational purposes in this tutorial),
one could have done instead:

<<full definition of [[hello]] content>>=
GLOBL   hello(SB), $12
DATA    hello+0(SB)/8, $"hello wo"
DATA    hello+8(SB)/4, $"rld\n"
@
%$
\l see data2s also

\l need the antislash z?
%The [[\z]] are the equivalent of [[\0]] in C and represents
%the zero value. They are not 
%        MOVW $'\z', R1
%        MOVB R1, 12(R2)



\section{The ARM architecture}

ARM represents different things: it is
a family of RISC machines (Akorn Risc Machines), 
a family of instruction set architectures (ISAs), and 
also a family of processors. 
%
But, up until now, and also for the rest of this document, 
when we use the term ARM we mean the {\em ARMv6} instruction set architecture.
Confusingly, ARMv6 is the instruction set
used in the {\em ARM11} 32 bits processor 
family~\furl{http://www.arm.com/products/processors/classic/arm11/?tab=Specifications}.
This family powers many smartphones as well as the Raspberry Pi.
\l ARM1136

Because an assembly language mimics closely the instructions
of a machine, most of the instructions in Asm5
are instructions of the ARM: [[B]], [[BL]], [[SWI]], [[ADD]], etc.
The same is true for the registers [[R0]] to [[R15]].
To fully understand those assembly instructions we refer
to our \book{Emulator} which describes the semantics of 
the corresponding ARM machine instructions, or to
the ARM reference manual~\cite{arm-refman}.
%
Asm5 introduces also some pseudo-instructions, pseudo-registers,
and virtual instructions, as we have seen in the previous section,
and those will be fully explained in this document.

As said briefly in the introduction, [[5a]] does not
generate machine code, the linker [[5l]] does, 
so there is no need to know the binary format of ARM instructions
to understand this document.
\l opcode format, see 5i/ it's more the job of 5l and optab to do that.

\section{Input assembly language}

We have covered already in Section~\ref{sec:helloworld} 
many features of the assembly language Asm5,
the language used by the input files of the assembler [[5a]].
In this section we summarize those features and
give a more systematic description of Asm5, which should
help solidify your understanding of Asm5.
We recommend to read though [[assemblers/docs/asm.pdf]] for more
information.
\n but not really more complete information, my tutorial is better
\l this is not a reference manual, but it is enough to help implement
%note: was useful to write this summary, see better now the whole lang/picture
% almost look like a refcard

\subsection{Lexical elements}
\label{sec:asm5-lexical}

The main lexical elements of Asm5 (and also of Asm9) are:
\n implementer POV
\begin{itemize}
\item {\em integers}, e.g. [[42]] (decimal), [[0x12]] (hexadecimal), [[0666]]
(octal)

\item {\em characters}, e.g. [['W']], [['\n']], [['\007]]

\item {\em strings}, e.g. [["hello wo"]]. Strings are limited
to 8 characters or less.
\l why? meh

\item {\em floats}, e.g. [[4.2]], [[10e43]]



\item {\em predefined identifiers} in uppercase, used for the mnemonics of
opcodes ([[ADD]]), 
registers ([[R0]]), 
pseudo-instructions ([[TEXT]]) and 
pseudo registers ([[PC]]).
\l keywords

\begin{quote}
  ``Instructions, registers, and assembler directives are always in
  UPPER CASE to remind you that assembly programming is a fraught
  endeavor.'' - Rob Pike
\end{quote}
\n https://golang.org/doc/asm (cited also from golang is trash article)

\item {\em identifiers} in lowercase, used for 
symbols ([[_main]]) and 
labels ([[later]])
\l have to be lowercase?
\l cant have DOT in it, annoying, which is why in go code they
\l use a special unicode that looks like dot

\item {\em comments}, e.g. [[/* not reached */]], [[// comment]].
They use the same syntax than C comments and are ignored by [[5a]].

\item {\em spaces} and {\em tabs}, which are also ignored by [[5a]].
By convention though it is common to indent with a tab most
instructions except pseudo instructions like [[TEXT]] which
are kept in the first column.

\item {\em newlines}, which are actually internally transformed in semicolons.
The semicolon is an instruction {terminator} in Asm9. So, one can then either 
\n yep terminator, not separator, see inst grammar rule
write multiple instructions on different lines,
or multiple instructions on the same line but separated by an explicit [[;]].

\item {\em operators}, e.g. \$, [[()]], [[/]], [[+]], [[;]], [[<>]], etc,
which can have different meanings depending on the context
\l also extended C operators for asm9 constant expressions

\end{itemize}
\l also cpp lexical elements

\subsection{Syntactical elements}

The main syntactical element of Asm5 is the {\em instruction}.
An Asm5 file is made essentially of a list of instructions, usually
one per line. 
An instruction is composed of an {\em opcode}
followed possibly by 1, 2 or 3 {\em operands}. 
A line can also contain a {\em label} definition which is an identifier
followed by a colon, e.g. [[later:]].
\l actually can have list of labels?

\subsection{Opcodes}

Opcodes correspond to different kinds of instructions:
\begin{itemize}
\item {\em machine instructions}, e.g. [[B]], [[SWI]], [[ADD]]

\item {\em pseudo-instructions}, e.g. [[TEXT]], [[GLOBL]],
also known as assembly directives

\item {\em virtual instructions}, e.g. [[RET]], [[MOVW]], [[NOP]]
which are instructions without a
1-to-1 mapping to a machine code instruction, but which
are convenient for the programmer (or compiler writer).
They can hide some architecture restrictions or peculiarities. 
\l makes asm a bit more portable
\end{itemize}

\subsection{Operands}

Depending on the opcode, different kinds of operands are possible:
\begin{itemize}
\item {\em constants}, which in Asm9 are always prefixed with a dollar,
e.g. \$42, \$[['W']]
\l why? to avoid ambiguity with what? otherwise offset like 32(SP) have no dol

\item {\em registers}, named [[R0]] to [[R15]] in Asm5

\item {\em pseudo-registers}, named [[PC]], [[SP]], [[FP]], and [[SB]]
in Asm9

\item {\em label references}, e.g. [[later]]
\l B xx vs B(SB)

\item {\em memory references}, which we describe below

\end{itemize}

\subsection{Addessing modes}

Memory references appear mainly in 
memory moves (e.g. [[MOVW]]),
branching instructions (e.g. [[BL]]), 
as well as in entity definitions (e.g. [[TEXT]]).
%
There are multiple ways to reference memory in Asm5,
called {\em memory addressing modes}:
\begin{itemize}

\item {\em indirect}, using [[()]] around a register or
pseudo-register, e.g. [[(R1)]], which means
the content at the address {denoted} by [[R1]]

\item {\em indirect with offset}, e.g. [[4(R1)]],
which means the content at the address denoted by [[R1]]
plus 4. Note that there is no prefixing dollars for offsets.

\item {\em symbol reference}, which is always written as ``an offset''
to a pseudo-register, e.g. [[hello(SB)]],
which means the content at the address denoted by the symbol
[[hello]].
\t offset cos at some point symbol become static address and so number/offset
With [[SB]] the symbol denotes a global or procedure,
with [[SP]] a local variable, and 
with [[FP]] an argument.
\l and PC?
\l for Text, data, param, locals

\item {\em symbol reference with offset}, e.g. [[hello+4(SB)]],
which means the content at the address denoted by the global symbol
[[hello]] plus 4.
%
For locals and arguments it is also common
to use a symbol as in [[x+4(SP)]] or [[length+4(FP)]]. In those
cases the symbol is just a comment to give a name to
the local or argument. This comment though is kept in the
symbol table of the file and so can be used by debuggers.
\t ref to later?
\t plus SB, hmm


\item {\em symbol address}, using \$ before the symbol,
e.g. \$[[hello(SB)]], which means the address of the symbol
[[hello]].

\l and weird stuff with slash   hello _plus_ 0(SB)/6

\end{itemize}

Note that Asm9 uses a left-to-right assignment syntax. For moves,
\l AT&T syntax, normal
[[MOVW (R1), R2]] means moving the content at
the address denoted by [[R1]] into [[R2]]. The same
is true for other instructions such as [[ADD]] where the
destination register is the last operand and the sources the two
first operands.

\t note TEXT has actually an operand and it is a memory reference :)
\l take some examples, e.g. start-KZERO(SB), and explain? see comment in .tex
\l will see later also local symbol, with angle operator
%concepts: 
% - external symbols = fully unresolved! will be resolved at linking time
%   but needs to keep the name in the symbol table and the place where it
%   was referenced
%   (note that external entities are not even declared, any use of a symbol
%    not defined in the file is an external reference)
%    less: maybe this should be fixed, easy to make a typo)
%
% (LONG is a macro?)
%        LONG    $-(0x1BADB002 + 0x00010003)     /* checksum */
%vs
%        LONG    $_start-KZERO(SB)          /* load_addr */
%
%why need SB in second case? because it refers to symbol in certain section?
% it's to take the address of _start symbol in SB and adjust
% by removing KZERO to it. tricky. It's really $  _start(SB) - KZERO
%
% it does not have extern declaration, but any ref is implicitely
% an extern.

\l section{Runtime conventions}? hmm more compiler specific

\subsection{Advanced features}
\label{sec:mcrr-macro}

Asm9 has a few more features beyond mnemonics and symbolic addresses:
\begin{itemize}
\item {\em constant  expressions} as operands, e.g. \$[[1<<6|3]],
which are evaluated at {assembly time}.

\item an embedded {\em macro-processor} similar to [[cpp]] with
features such as [[#include]] and [[#define]]. [[5a]] is thus
what people calls a {\em macro-assembler}.
%
This, combined with the previous feature, allows to overcome
some of the original limitations of [[5a]]. Indeed, even if [[5a]]
does not support any mnemonic for some of the advanced
{coprocessor} ARM instructions, one can simply define and use
the macro [[MCRR]] defined below
which encodes the binary format of the instruction directly.

We will not explain though in this book the code related
to this embedded macro processor as we will explain
similar code in the \book{Compiler}.
\l but compiler book is already big, maybe better do it here?

\item {\em symbolic constants}, e.g. [[TMP = 11 ... MOV R1, R(TMP)]],
which were called originally (and ironically) {\em variables}.
Because they are redundant with the macro-processor, 
this feature has been removed from our version of [[5a]].
\l use LVAR for lexeme name, hmmm

\end{itemize}

\l those are the most common features, we describe more advanced later as needed

% put outside itemize because weird layout otherwise
<<macro MCRR>>=
#define MCRR(coproc, op, rd, rn, crm) \
   WORD $(0xec400000|(rn)<<16|(rd)<<12|(coproc)<<8| \
          (op)<<4|(crm))

@
%$
\t WORD instruction?
%

\section{Output object format}

As said in the introduction, the {object files} generated by [[5a]],
which use the~[[.5]] filename extension,
are ARM-specific, but they do not contain really machine code. Instead
an object file contains the {serialized form} of the 
{abstract syntax tree} of the assembly source. 
The actual machine code generation is performed by the linker [[5l]].
\t why better? because anyway cant resolve everything, and patch is complicated
\t so simpler work on the original abstract syntax tree
\n ocamlc does that too!

Because an Asm5 file is essentially a list of instructions,
its serialized form is simply a concatenation of serialized instructions.
The resolution of label addresses is done by the assembler,
so label definitions do not need to be serialized.
Label references in branching code are transformed in
absolute (virtual) addresses.
\n NO concrete offsets to the [[PC]] pseudo-register.

A serialized instruction has also a pretty simple format
since all instructions have the same form: an opcode followed by
0 to 3 operands.
%
One byte is enough to encode the opcode
on the ARM since there are less than 256 ARM opcodes (or pseudo-opcodes)
since the ARM is a RISC machine ([[8a]] needs 2 bytes to represent
an x86 opcode).
%
Another byte is used to encode the {\em kind} of the first operand
(e.g. an integer constant, a register, a memory address, nothing) followed by
a serie of bytes encoding the actual operand information 
(e.g. 4 bytes for an integer constant, 1 byte for the register number, etc).
%
The complete format is described precisely in Chapter~\ref{chap:generation}
%but Figure~\ref{fig:dotfive-format} 
but Figure~\ref{fig:object-format} describes roughly the content 
of an object file.

\begin{figure}[!]\centering
\begin{verbatim}
|                  |
+------------------+
|    Opcode        |
|                  |
+------------------+  <--- start of second instruction
|        .         |
|        .         |  <--- operand 2 encoded value
+------------------+
|  Operand 2 kind  |
|     (1 Byte)     |
+------------------+
|        .         |  <--- operand 1 encoded value
|        .         | 
+------------------+
|  Operand 1 kind  |
|     (1 Byte)     |
+------------------+
|        .         |
|        .         |  <--- instruction metadata 
|        .         |       (e.g. line number) 
+------------------+
|     Opcode       |  
|    (1 Byte)      |
+------------------+  <--- start of the .5 file 
\end{verbatim}
\caption{File format of a [[.5]] object file}\label{fig:object-format}
\end{figure}

\t symbol table about unresolved? imported and exported? at the end of file
\t actually use a very special encoding scheme, see sectionXX

%ocaml: just marshall the ADT, and unmarshall in linker => shorter code!
%update: hmm but the format is actually not that complicated, so we may win
% but not that big probably. Also nice to have a format that other programs
% coded in different languages can read.

\section{Code organization}

Table~\ref{tab:code-orga} presents a short description
of the source files used by [[5a]], 
the main entities (structures, functions, globals, etc) the file defines,
and the corresponding chapters in this document in which the code
contained in the file is discussed.
\n sorted by chapters, make more sense than sorted by dir

There are multiple assemblers in \plan, one per supported architecture
(ARM and x86 in our \plan fork). The generic code has been
factorized in the [[assemblers/aa/]] directory. 
\l and common.out.h
The ARM-specific code is in [[assemblers/5a/]] 
as well as in [[include/arch/arm/5.out.h]]
(and for x86 in [[assemblers/8a/]] and [[include/arch/386/8.out.h]]).

\begin{table*}[tbh!]
\begin{tabular}{llllr}
\toprule
{\bf File} & {\bf Description} & {\bf Entities} & {\bf Chapters} & {\bf LOC} \\
\otoprule
[[aa/aa.h]] & Symbol table and input related structures & [[Sym]], [[Fi]], [[Io]] & \ref{chap:core-ds}, \ref{chap:input} & 243 \\
%, [[Hist]] [[Htab]],
[[include/.../5.out.h]] & ARM opcodes, operand kinds, registers & [[Opcode]], [[Operand_kind]],  & \ref{chap:core-ds} & 300 \\
 & & [[Register]] & & \\
[[5a/a.h]] & ARM operand & [[Gen]] & \ref{chap:core-ds} & 103 \\
% why not put in 5.out.h too? could be reused by linker and compiler?

\midrule

[[aa/globals.c]] & Generic globals (e.g. output filename) & [[hash]], [[symb]], [[outfile]],   & \ref{chap:main} & 97 \\
 & & [[pass]], [[pc]] & & \\

[[5a/globals.c]] & ARM-specific globals & [[nullgen]] & \ref{chap:main} & 7 \\


[[5a/main.c]] & Main entry point and main functions & [[main()]], [[assemble()]],  & \ref{chap:main} & 492 \\
              & & [[outcode()]] & \ref{chap:generation} & \\
% (I created this file)

\midrule

[[aa/lexbody.c]] & IO and lexing utilities & [[yyerror()]], [[newfile()]] & \ref{chap:input} & 664 \\ 
% also lookup(), hmmm


[[5a/lex.c]] & Lexer for Asm5 (not using Lex) & [[yylex()]] & \ref{chap:lexing} & 570 \\

[[aa/macbody.c]] & Macro processing (embedded [[cpp]]) & [[macdef()]], [[macinc()]] & \ref{chap:preprocessing} & 867 \\
 & & [[macexpand()]] & & \\
% mac = macro (not macos :)

[[5a/a.y]] & Yacc grammar for Asm5 & [[yyparse()]], [[inst()]] & \ref{chap:parsing} & 599 \\
% (and calls to outcode)


\midrule

[[aa/utils.c]] & Memory allocation, error managment & [[alloc()]], [[errorexit()]] & \ref{chap:error}, \ref{chap:libc} & 84 \\
% use outfile global in globals.c, use yyerror() (I created this file)

[[aa/compat.c]] & System function wrappers for compatibility & [[mycreat()]], [[mywait()]] & & 50 \\
%todo: to delete at some point?
 & with \unix & & & \\

\midrule
[[include/.../common.out.h]] & IEEE float structure & [[Ieee]] & \ref{chap:advanced} & 22 \\
% and NSYM constant

\otoprule
Total & & & & 4098 \\
\bottomrule
\end{tabular}
\caption{Source files of [[5a]]}
\label{tab:code-orga}
\end{table*}
\n see SRC_VIEWS in the Makefile, and make loc
\l could have a input.c and output.c

\section{Software architecture}

Figure~\ref{fig:controlflow} describes roughly 
the main control flow and main {components} of [[5a]], while
Figure~\ref{fig:dataflow} describes 
the main data flow of [[5a]].

\begin{figure}[!]\centering
\begin{verbatim}
            +-------------+         
            |    main     |         
            +------+------+         
                   |                
                   |                
            +------v------+         
            |  assemble   |         
            +----+--+-----+         
                 |  |               
                 |  |               
            +----v--v-----+         
            |  yyparse    | (Parser)        
            +---+-------+-+         
                |       |              
       +--------+       +-------+      
       |                        |      
+------v-------+         +------v-----+
|   yylex      | (Lexer) |  outcode   | (Object code generator)
+------+-------+         +------------+
       |                            
       |                            
+------v-------+                    
|    macxxx    | (Preprocessor)                   
+--------------+                    
\end{verbatim}
\caption{Control flow diagram of [[5a]]}\label{fig:controlflow}
\end{figure}
\l add chapter ref in the box? next to the box?
%ocaml: if the code was more functional the diagram would be just a pipeline!
\n alternative with cclean? not that important so better to remove it


\begin{figure}[!]\centering
\begin{verbatim}
assembly file -> tokens -> instructions -> object file
                (use global symbol table)
\end{verbatim}
\caption{Data flow diagram of [[5a]]}\label{fig:dataflow}
\end{figure}
\l focus on components instead? Lexer->Preprocessor->Parser->Generators?


After some basic command line processing and initialisations,
the function [[main()]] calls [[assemble()]] with the name
of the assembly file to process. 
%
[[assemble()]], after further initialisations,
uses then a two-pass algorithm and so calls 
[[yyparse()]], the function generated by Yacc from the Asm5 grammar,
two times. Doing so it also modifies the global [[pass]]: for the first
call to [[yyparse()]] the value of [[pass]] is 1, and for the second
call the value of [[pass]] is 2.

The {parsing} function [[yyparse()]] internally calls the lexing
function [[yylex()]] to get the next {\em token} from the input file.
[[yylex()]] is usually generated by Lex from a set of 
{regular expressions}, but in the case of [[5a]] was handcoded.
\l why?
[[yylex()]] itself calls {macro-processing} related functions,
e.g. [[macinc()]] (for ``macroprocessing include''), as [[5a]] 
is a macro-assembler supporting [[cpp]] directives such as [[#include]].

From a set of tokens, [[yyparse()]] can parse using
different {\em grammar rules}
a constant,
a register,
an operand, 
an opcode, 
an instruction,
and finally a set of instructions.
%
The Yacc {\em actions}\footnote{
See~\cite{lexyacc} for more information on Yacc grammar rules and actions}
associated with those grammar rules
gradually build and return abstract syntax trees (ASTs) of
subparts of an instruction.
\l not really trees though
Once a full instruction
has been parsed, via the [[inst]] grammar rule,
the yacc action for [[inst]] is triggered,
which calls the function [[outcode()]] with the AST of the 
parsed instruction.
\l actually 5 subASTs arguments but they represent the AST
% 5a abuse tokens and the grammar to do some computations (classic old style)
%ocaml: could return full AST, list of instr and then outcode of that.

[[outcode()]] outputs then the serialized form of the instruction AST
in the object file, but only when the global value of [[pass]] is 2.
Whatever the value of [[pass]], [[outcode()]]
also increments each time [[pc]], a global representing the
current value of the (virtual) program counter.

The lexing and parsing code internally use and modify a 
{\em symbol table} called [[hash]], which keeps track of the value
of different kinds of identifiers, for instance labels.
%
During lexing, when a new identifier is encountered, a new
symbol in the symbol table [[hash]] is created. 
%
During parsing, once an identifier is recognized as
a label, because it is followed by a colon token,
its {\em type} in the symbol table is changed to a label type, 
and its value is set to be the current value of the global [[pc]].
%
During the second pass, any reference to this label 
can be resolved by simply looking at the value of the label in the symbol
table.

\n talk about cclean? maybe not that important, a big ugly, no need AEND

\l relation with other tools? 5c, 5l? easy, do git grep, see comment .tex
% git grep AADDB
%assemblers/8a/lex.c:    "ADDB",		LTYPE3,	AADDB,
%compilers/8c/peep.c:    case AADDB:	/* rhs rar */
%compilers/8c/reg.c:        case AADDB:
%compilers/8c/txt.c:            a = AADDB;
%include/386/8.out.h:    AADDB,
%linkers/8l/optab.c:    { AADDB,	yxorb,	Px, 0x04,0x80,(00),0x00,0x02 },

\l Symbol table assembler, and symbol table in object file! in/out.

\l Depends libc, libio

%\section{Bootstrapping}
% 5a is actually written in C :) not even asm! and also use yacc
% bootstrap from scratch? punch card, hex-to-c, assembler in assembler, asm in C

\section{Book structure}

We now have enough background to understand the source
code of [[5a]]. The rest of the book is organized as follows.
%
We will start by describing the core data structures of [[5a]]
in Chapter~\ref{chap:core-ds}. 
%
Then we will use a top-down approach in Chapter~\ref{chap:main} and 
starting from [[main()]] we will present the code of the main 
functions, e.g. [[assemble()]].
%
The following chapters will be dedicated to describe
the main components of the assembling pipeline:
Chapter~\ref{chap:input} will present the input routines,
Chapter~\ref{chap:lexing} the lexer,
Chapter~\ref{chap:preprocessing} the preprocessor,
Chapter~\ref{chap:parsing} the parser,
and finally Chapter~\ref{chap:generation} the object code generator.
%
In Chapter~\ref{chap:debugging} we will describe the code
responsible for adding debugging support in [[5a]], which
for instance add line information in the object code. 
One can then know, when debugging a binary program,
to which original line and which source file an
instruction in the binary comes from, or what is the
original name of the procedure containing this instruction.
%
Chapter~\ref{chap:advanced} presents other
assembly features which we did not present 
before to simplify the explanations, for instance
the support for floats. Those features tend to crosscut
many components with extensions to the lexer, the parser,
and the code generator.
%
Finally Chapter~\ref{chap:conclusion} concludes
and give pointers to other books in the \principia serie.

Some appendices present the code of non-functional properties:
code to help debug [[5a]] itself in 
Appendix~\ref{chap:debugging-appendix}, code to manage
errors in Appendix~\ref{chap:error}.




\chapter{Core Data Structures}
\label{chap:core-ds}

\begin{verse}
\begin{flushright}
  {\it Show me your code and conceal your data structures, and I shall
    continue to be mystified. Show me your data structures, and I
    won't usually need your code; it'll be obvious.\\
    ~\\
    Fred Brooks}
\end{flushright}
\end{verse}
\n actually I think the original quote is with "flowchart" and "tables"

In this chapter we will present the core data structures used by [[5a]].
The first three sections contain the definitions
of the different components of the abstract syntax tree (AST) 
\l not really a tree though
of an instruction:
the opcode, 
the register (which is a kind of operand),
and the other kinds of operands.
\l internal memory representation of assembly textual instructions!
Then we will see how tokens are represented.
Finally we will present the symbol table which is
a central data structure used by 
the lexer,
\n predefined identifiers
the preprocessor, 
\n macro body
the parser, and 
\n label values
the object code generator.
\n ??

\section{[[Opcode]]}
\label{sec:opcode}

All Asm5 instructions (machine, pseudo, and virtual) have an opcode
defined in [[include/arch/arm/5.out.h]] by the following type:
\n used to be just 5c/5.out.h

<<enum opcode(arm)>>=
// coupling: with 5c/enam.c
enum Opcode
{
    AXXX,

    ANOP, // VIRTUAL removed by linker
    // ---------------------------------------------------------
    // Arithmetic and logic opcodes
    // ---------------------------------------------------------
    <<[[Opcode]] cases, logic opcodes>>
    <<[[Opcode]] cases, add/sub opcodes>>
    <<[[Opcode]] cases, mul/div/mod opcodes>>
    <<[[Opcode]] cases, bitshift opcodes>>
    // ---------------------------------------------------------
    // Memory MOV opcodes
    // ---------------------------------------------------------
    <<[[Opcode]] cases, mov opcodes>>
    <<[[Opcode]] cases, swap opcodes>>
    // ---------------------------------------------------------
    // Control flow opcodes
    // ---------------------------------------------------------
    <<[[Opcode]] cases, comparison opcodes>>
    <<[[Opcode]] cases, branching opcodes>>
    // ---------------------------------------------------------
    // Syscall
    // ---------------------------------------------------------
    <<[[Opcode]] cases, interrupt opcodes>>
    // ---------------------------------------------------------
    // Float opcodes
    // ---------------------------------------------------------
    <<[[Opcode]] cases, float mov opcodes>>
    <<[[Opcode]] cases, float arithmetic opcodes>>
    // ---------------------------------------------------------
    // Pseudo opcodes
    // ---------------------------------------------------------
    <<[[Opcode]] cases, pseudo opcodes>>

    ALAST,
};
@
\l why Axxx? Assembly?
%old: was called 'enum as'
%note: I reordered a lot the original opcodes. Note that it can be dangerous
% for backward compatiblity to do so. Indeed 'ld' and 'as' need to agree
% with each other; one can't use a library compiled (or cross compiled) 
% using a 5l relying on a certain order, and link object files compiled 
% by a 5a relying on another order. So can have some subtle errors if
% want to play with what is cross-compiled! So make sure to recompile your
% libc if you modify 5l or 5a or 5.out.h

\n the enum must contain less than 256 elements, as we rely on 
\n  sending ANAME as a byte in zname(), and all opcode as a byte in zaddr()
\n the order of the opcode below does not have to match the opcode order
% (Actually I have reordered them to be more logical
% e.g. AND, ORR, EOR are closer together.)
% the actual binary code generation is done in the linker
%less: Could analyze *.s in plan9 and do some stats? or use cg on the
%  whole plan9 and see how much AXXX is used

The opcodes follow closely the instruction set (ISA) of the ARM
(see the \book{Emulator}) and are all prefixed by an [[A]].
For instance, [[ASUB]] corresponds to the [[SUB]] machine instruction.
They have been divided in different categories: 
arithmetic and logic, 
memory,
control flow, 
system, 
and float.
Moreover, Asm5 introduces pseudo opcodes for the pseudo-instructions.
The different opcodes will be presented gradually in this
document.

The [[AXXX]] opcode represents the {\em invalid opcode}. It is put in
first position in the enumeration probably as a form of defensive programming.
%ocaml: ugly, should not need that if had strong enum case checker
[[ALAST]] is an {\em end marker}: a C idiom which makes it easy to loop
over all the opcodes or to declare an array of opcodes.
%
[[ANOP]] is a {virtual instruction} removed by [[5l]]. It is
occasionally used by the assembly generator in [[5c]] to
represent an instruction without any effect.
\l not clear why need that at all, but USED and profiler might use that?
\l also RET, MOV, SLL, BEQ, etc.
\l no PUSH/POP? stack is sugar over MOV with specific conventions.

\section{[[Register]]}
\label{sec:register}

ARM has 16 registers named [[R0]] to [[R15]].
They are represented simply by an integer in [[5a]]: 
0 is [[R0]], 1 is [[R1]], etc.
%ocaml: a big ugly because then have the issue with R_NONE
The following type introduces some convenient names for some of the
{special registers} we have seen before:

<<enum regxxx(arm)>>=
enum Register {
    <<[[Register]] compiler conventions cases>>
    REGSB =		12, // static base

    REGSP =		13,
    REGLINK =	14,
    REGPC =		15,

    NREG = 16,
};
@
\n can not use register, it is a reserved keyword

Again, [[NREG]] is not a register but an end marker. 
One can then easily declare an array with all ARM registers
with [[int allregs[NREG];]].
%
Note than [[REGSB]] is not a special ARM register;
it is reserved though by the assembler and linker for a special use.
\t ref to section that explain more REGSB
\l REGSB is new! Machine.nw does not have it.

\t REGFP? not in ARM, but 5a has a fake register LFP (not sure
\l which actual register will be used for it though)

There are few situations where something, e.g. an operand,
can be a register or {nothing}. We can not use 0 to represent nothing since it
is used already to encode [[R0]]. Instead, the following
constant represents nothing:

<<constant R_NONE(arm)>>=
#define R_NONE 16
@
%old: NREG used to represent NONE in the outcode reg param; I prefer R_NONE
%ocaml: None

The ARM has also 
float registers, 
coprocessor registers, and 
status registers, 
but they will be introduced later.
\n Fxxx, Cxxx, PCR (and FPCR)


\section{[[Operand]]}
\label{sec:operand}
\t rename Gen to Operand so better section name
\t Why Gen anyway? gen rule in grammar. General opd? generic? 
\n =~ Adr of Linker. 

A register is only one kind of operand.
Constants (integers, floats, or strings) are another kind.
The following type is used to represent all kinds of operands: 

<<struct Gen(arm)>>=
struct	Gen
{
    // enum<operand_kind>
    short	type;

    // switch on Gen.type
    union {
        long	offset; // offset or generic value
        double	dval;
        char	sval[8];
    };
    // option<enum<registr>>, None = R_NONE
    short	reg;

    <<[[Gen]] other fields>>
};
@
%old: I introduced the union? can have it? operand_kind will be good enough?
%ocaml: An ADT would be far better than this enum, D_NONE, and separate Sym 
% type operand = 
%  | D_REG of register // and offset?
%  | D_CONST of int
%  | D_OREG of register * offset
%  | Branch of offset (PC)
%  | Extern of name * offset (SB) ?
%less: maybe by playing with Literate Programming I can reproduce a kind of ADT?
% e.g. by introducing LSREG, and then the part of the enum register related
% to LSREG?
% type instr = 
%  | TEXT of name * attribute list * int (* locals *)
%   ...
% type reg = 
%   ...

The [[type]] field is used to encode the {\em kind} of the operand.
It is a [[short]] but really it can only take values of the
[[operand_kind]] enumeration (hence the {typing} comment)
we define below:

<<enum operand_kind(arm)>>=
enum Operand_kind {
    D_NONE,

    D_CONST,
    D_SCONST,
    D_FCONST,

    D_REG,
    <<[[Operand_kind]] cases>>
};
@
\l why Dxxx prefix? 
%dead: D_GOK, D_ADDR (valid for x86 but unused for arm)/* type/name */ for GOK
%note: I reordered again a lot things, which like for opcode has some impact
% on 5l. Now D_REG, D_CONST, D_SHIFT are closer (to mimic imsr rule).
%See Dconv in Linker for dumper (which can help to undertand things too)

The union in [[Gen]] represents the {\em value} of the operand, which has to 
be interpreted in different ways depending on the kind of the 
operand: 
for integer constants ([[D_CONST]]) the [[offset]] field is used,
for string constants ([[D_SCONST]]) the [[sval]] field,
and for float constants ([[D_FCONST]]) the [[fval]] field.
Remember that characters are converted in integers so
there is no need for a [[D_CHARCONST]] and [[cval]] field.
%
The [[long]] element of the union is called [[offset]],
and not [[lval]] (which would be more consistent with the
other union fields) because it is (ab)used to represent
different things, not just integer (or character) constants,
as we will see soon.
%ocaml: ugly, for bitshift too! bit 5!

The [[D_NONE]] case is used only at the beginning, when initializing
a new operand in [[nullgen()]], and should be used to represent
an operand which has not be defined yet.

[[D_REG]] is used to represent register operands. In that
case it is the [[Gen.reg]] field which encodes
the actual register.
\l could use offset? no because can also have offset(reg)

For indirect operands, e.g. [[(R1)]], 
or indirect with offset operands, e.g. [[4(R1)]]
the new operand kind [[D_OREG]] (for offset register) is used:

<<[[Operand_kind]] cases>>=
D_OREG,
@
\l oreg for offset register?

In those cases the register is encoded in the [[Gen.reg]] field,
and the optional offset in [[Gen.offset]] (hence the name).
%EXAMPLE:
Here is the C value of the operand mentioned above:
\begin{verbatim}
// operand value for: 4(R1)
{ offset = 4;          // 4
  reg    = 1;          // R1
  type = D_OREG;       // (...)
}
\end{verbatim}
\l offset is abused for many things, see the comment in .tex
% - offset
% - constant
% - register for REGREG
% - bitset of register for MOVM
% - ??
%less: rename offset? to generic_value? or generic_long? or lval?
% but it's true in many places it's used to encode an offset to
% a base (a reg, a name).
% e.g. for D_SHIFT the long is used really to encode the whole
% thing with some bits for the shift kind, some bits for the register, etc.
% see the many uses cases of offset in zaddr() switch about operand_kind ...
%mimic what is in union token too


\section{Instructions}
\label{sec:outcode-signature}
%    outcode(AEND, Always, &nullgen, R_NONE, &nullgen);

There is no type to represent the full AST of an instruction.
Instead, multiple parameters of the [[outcode()]]
functions are used to pass the different components
of an instruction. Here is the signature of [[outcode()]]:
%ocaml: could define a record
\l =~ Prog of Linker (but without opcode)?

<<signature outcode(arm)>>=
void	outcode(int opcode, int cond, Gen* opd1, int reg, Gen* opd3);
@

Here is an example of use of [[outcode()]] to output
the serialized form of the instruction [[SUB $14, R2, R3]]:
%$
%EXAMPLE:
\begin{verbatim}
Gen operand1 = { .type = D_CONST; .offset = 14; ...};
Gen operand3 = { .type = D_REG;   .reg = 3; ... };
outcode(ASUB, Always, &operand1, 2, &operand3);
\end{verbatim}

The [[Always]] constant and the second parameter of [[outcode()]]
are used to represent the {\em conditional execution} of an instruction.
It is an ARM feature we will explain later in Section~\ref{sec:cond-exec}.
%
The fourth parameter is an integer and not a [[Gen*]] because
when ARM instructions have 3 operands, the middle one is always
a register, so an integer is enough.
Depending on the number of operands, here are the constraints on 
the value of those parameters:
\begin{itemize}
\item 0 operand: [[opd1]] and [[opd3]] are [[NULL]], [[reg]] is [[R_NONE]]
\item 1 operand: [[opd3]] is [[NULL]], [[reg]] is [[R_NONE]]
\item 2 operands: [[reg]] is [[R_NONE]]
\item 3 operands: no constraint, every parameter is used
\end{itemize}

\l speak now about the 2second register which is abused for: TEXT/DATA attr?

\section{Tokens and [[itab]]}
\label{sec:token}

The Yacc-based parser of [[5a]], called via [[yyparse()]],
is taking as input a set of {tokens}.
Those tokens are returned by the [[yylex()]] function, but
their type is defined by a set of {\em Yacc directives}
in the Yacc grammar [[5a/a.y]]\footnote{
Again, see~\cite{lexyacc} for more information on Yacc}.
Here are the directives to declare the names of those
tokens as well as the type of value they hold:

<<token declarations(arm)>>=
/* opcodes */
%token  <lval>  LARITH LCMP LBRANCH LBCOND LMOV LSWAP LRET LMISC
%token  <lval>  LSWI LSYSTEM 
%token  <lval>  LARITHFLOAT LCMPFLOAT  LMULL LMULA  LMOVM LMVN
%token  <lval>  LDEF LDATA LWORD LEND
/* registers */
%token  <lval>  LPC LSP LFP LSB
%token  <lval>  LR LREG  LPSR
%token  <lval>  LF LFREG  LFCR 
%token  <lval>  LC LCREG
/* constants */
%token  <lval>  LCONST 
%token  <dval>  LFCONST
%token  <sval>  LSCONST
/* names */
%token  <sym>   LNAME LLAB
%token  <sym>   LVAR
/* bits */
%token  <lval>  LCOND
%token  <lval>  LS LAT
@
\l Lxxx for? lexeme?
%dead: LTYPEX LTYPEF LTYPEG LTYPED
%old: used to be LTYPE1 LTYPE2 LTYPEI etc, but better to give clearer names
%TODO: rename LTYPEXXX by T_END, T_TEXT, etc? L_ARITH? L_CMP L_MOV L_SWAP

Those directives are a bit complicated but things will be clearer
when we describe the Lexer in Chapter~\ref{chap:lexing}.
To understand those directives it can be useful to look at
the generated code and how tokens are internally represented.
A token is really a pair composed of:

\begin{itemize}
\item a {\em code}, which is an integer representing
the kind of the token. 
Based on the directives above, Yacc will generate a [[y.tab.h]]
header file where all the token names are assigned a code.
See an excerpt of this file below.
For instance 
57346 represents all arithmetic mnemonics tokens (e.g. [[ADD]], [[SUB]], etc),
57353 represents the token for the [[RET]] mnemonic, and 
57381 represents all integer tokens.
%

\item a {\em value}, which is represented by a union we will describe below.
Depending on the kind of the token, the value can be 
an integer (e.g. for integer tokens), 
a float (e.g. for float tokens), 
or something else.
For instance for the arithmetic mnemonic tokens,
represented by the code 57346 and the token name [[LARITH]], 
the value will be the opcode corresponding to the actual mnemonic
(e.g. [[ASUB]] for [[SUB]]), which is an enumeration case.

\end{itemize}
%ocaml: but value is in yyval global, ugly, just because C func cant return pair

Here is an excerpt of the [[y.tab.h]] file generated by Yacc:

<<5a/y.tab.h excerpt>>=
...
#define	LARITH	57346
...
#define	LSWI	57352
#define	LRET	57353
...
#define	LCONST	57381
#define	LFCONST	57382
...
@
%ocaml: ugly sugar, would be simpler have a simple ADT hiding all this shit

The values of those integers are high to not conflict with
the values of regular {unicode} characters. 
Indeed [[yylex()]]
can return single-character tokens (e.g. [[';']]) in which case there is no
need to give them a name.
\n in unix yacc I think it starts at 256 because only ASCII conflict
\l see Yacc. typedef Rune token_code; so plan9 lex is unicode aware? ulex?

Here is the union representing the different kinds of values
a token can hold:

<<union declaration(arm)>>=
%union {
 // long for LCONST
 // and enum<opcode>  for LARITH/...
 // and enum<registr> for LREG/...
 // and enum<cond>    for LCOND
 // and ...
 long   lval;    // for LCONST/LARITH/LREG/LCOND/...
 double dval;    // for LFCONST
 char   sval[8]; // for LSCONST

 <<union declaration other fields(arm)>>
}
@
\l could use NSNAME here instead of char sval[8] ? and at a few other places?
\l note that 8, here is the restriction on 8bytes strings

Again this directive is a bit complicated but things will be clearer
later. The name of those fields, e.g. [[lval]], are actually
referenced in the \%[[token]] directives above.
\l and also in type directives
For instance \%[[token  <lval>  LCONST]] indicates that
the [[LCONST]] tokens will use the [[lval]] field of the union
to hold their values.
\t will see Sym later
\l this is used to typecheck things in Yacc. 

Another important data structure related to tokens
is the [[Itab]] structure and the global [[itab]]:

<<struct Itab(arm)>>=
struct Itab
{
    char	*name;

    //enum<token_code>
    ushort	type;
    //enum<opcode|registr|...> | int
    ushort	value;
};
@
\t why Itab? Instruction table? it's not just for instruction, ren ttab?
\t or mnemonics?
\l  fregisters|sysregisters|sym_kind(pseudo-register) |operand_kind||...
%ocaml: ADT again would be better than union and this

<<global itab(arm)>>=
// map<string, (token_code * token_value)>
struct Itab itab[] =
{
    "NOP",		LMISC, ANOP,
    <<[[itab]] elements>>
    0
};
@

They map the predefined identifiers of Asm5, e.g. [[NOP]], [[PC]], etc,
to their corresponding token, which as we have seen before
is a pair of token code and token value.
%
Elements of the [[itab]] array will be revealed gradually
in this document but the first entry is shown above for [[NOP]].
\l was LTYPEI, now LMISC, but should be LNOP? and then a nop grammar rule?
\t in yylex when parse an identifier, looks in itab if equal string
\t in which case return the appropriate token

\l actually this array is used in xinit to populate hash table of symbols
\l so it's fast.

\section{[[Sym]]bols and [[hash]] table}
\label{sec:sym}

One of the main job of an assembler is to manage symbols
and to resolve symbolic addresses. 
The {\em symbol table} is thus a central data structure
used by [[5a]]. 
The structure below represents a symbol. It essentially
associates a {name} to a {value}:

<<struct Sym>>=
struct	Sym
{
    // Sym is (ab)used to represent many things in the assembler:
    //   actual symbols, labels, but also macros,
    //   tokens for opcodes and registers, etc

    // ---------------------------------------------------------
    // The "key"
    // ---------------------------------------------------------
    // ref_own<string>
    char	*name;

    // ---------------------------------------------------------
    // The generic "value"
    // ---------------------------------------------------------
    long	value; 

    <<[[Sym]] identifier fields>>
    <<[[Sym]] macro fields>>
    <<[[Sym]] token fields>>

    // ---------------------------------------------------------
    // Extra
    // ---------------------------------------------------------
    <<[[Sym]] extra fields>>
};
@
%archi: value is a vlong in va/
\n there is no symkind here, this is stored outside the Sym

For instance, the label [[later]] in the [[hello world]] program 
Section~\ref{sec:helloworld}, once resolved, could
be represented by the following [[Sym]]: 
%EXAMPLE:
[[{ .name = "later"; .value = 2; ... }]] as
the label is defined after the 2nd instruction in the program.
\l virtual PC!



The symbol table itself is represented by a global {hash table}
called [[hash]]. It makes sense to use a global because
the symbol table will be accessed by different components
of the assembler pipeline, e.g. the lexer and parser.
%ocaml: actually could pass table in lex to yacc.
One way to implement a hash table in C is to use a big array
of lists, also known as an array of buckets:

<<global hash>>=
// hash<string, ref_own<Sym>>, (next in bucket = Sym.link)
Sym*	hash[NHASH];
@
\t diff with h?
<<constant NHASH>>=
#define	NHASH		503
@
\l choose as a prime, see below

One way to implement a list of something in C is to embed in
this something a [[link]] field pointing to the next
element in the list:

<<[[Sym]] extra fields>>=
// list<ref<Sym>> (next = Sym.link) bucket of hashtbl 'hash'
Sym*	link;
@
\t what is the head? hash! and also h?

The end of the list is represented by the null pointer:

<<constant S>>=
#define	S	((Sym*)nil)
@

%FIGURE? or standard C idiom?

The main interface to the symbol table are the
functions [[slookup()]] and [[lookup()]] which
both internally uses the global [[hash]].
\l hmm so could hash be a semi global and used only by lookup?
[[slookup()]] given a name returns the [[Sym]] in the
symbol table [[hash]] associated with this name, or
a new symbol if the name was not found:

<<function slookup>>=
Sym*
slookup(char *s)
{

    strcpy(symb, s);
    return lookup();
}
@
\l cleaner interface at least

It internally modifies the global [[symb]] 
(used also by [[yylex()]] as we will see later) 
before calling [[lookup()]].
%ocaml: globals are bad, slookup cleaner than lookup, should not need symb

<<global symb>>=
char	symb[NSYMB];
@
<<constant NSYMB>>=
#define	NSYMB		500
@
%old: was //#define	NSYMB		8192 on arm, not sure it matters

<<function lookup>>=
Sym*
lookup(void)
{
    Sym *sym;
    long h;
    char *p;
    int c;
    int len;

    <<[[lookup()]] compute hash value [[h]] of [[symb]]>>

    // hash_lookup(symb, hash)
    c = symb[0];
    for(sym = hash[h]; sym != S; sym = sym->link) {
        // fast path
        if(sym->name[0] != c)
            continue;
        // slow path
        if(memcmp(sym->name, symb, len) == 0)
            return sym;
    }
    <<[[lookup()]] if symbol name not found>>
}
@
%old: s/s/sym/, s/l/len, less confusing I think
\l standard way to use a hash table, so we don't elaborate

The code is using standard C idioms to iterate over a hash table.
Note that if the symbol is not found in the symbol table,
a fresh symbol is created and added in the hash table:

<<[[lookup()]] if symbol name not found>>=
sym = alloc(sizeof(Sym));
sym->name = alloc(len);
memmove(sym->name, symb, len);

// add_hash(sym, hash)
sym->link = hash[h];
hash[h] = sym;

syminit(sym);
return sym;
@

The hashing code iterates over the characters in [[symb]]
until the end-of-string character ([[0]]) and also compute the length
of the symbol in [[len]]:

<<[[lookup()]] compute hash value [[h]] of [[symb]]>>=
// h = hashcode(symb)
h = 0;
for(p=symb; c = *p; p++)
    h = h+h+h + c;
len = (p - symb) + 1;
if(h < 0)
    h = ~h;
h %= NHASH;
@


The symbol table [[hash]] and [[Sym]] are used (some could say abused) to 
represent and keep track of many different things in [[5a]]:

\begin{itemize}
\item {\em labels}, e.g. [[later:]], in which case [[Sym.value]]
contains eventually the value of the (virtual) program counter [[pc]]
at the label definition

\item {\em symbols}, for procedures
([[TEXT foo(SB)]]) and globals ([[GLOBL hello(SB)]]),
\l and also parameters and locals!
in which case [[Sym.value]] is not used since the address
of global symbols are resolved by [[5l]].
%
Another field of [[Sym]] is used though to store
meta-data about the symbol which will be stored in the 
symbol table of the object file
as we will see in Section~\ref{sec:symidx-sym-field}.
\l symidx, but actually not sym, sym and symkind are in Gen, not Symbol
\l also for SP and FP p _plus_ 0(FP)

\item {\em macros}, e.g [[#define FOO]], since [[5a]] is
a macro-assembler which embeds its own macroprocessor, in which case
[[Sym.value]] is not used. Another field of [[Sym]] contains
the text of the macro as we will see in Section~\ref{sec:macro-sym-field}.

\item {\em symbolic constants}, e.g. [[RTMP = 10]], 
in which case [[Sym.value]] contain the constant value

\item {\em predefined identifiers}, 
for opcodes ([[AMOV]]) and registers ([[R1]]), in which case
[[Sym.value]] contain the appropriate enumeration value.
\l ugly abuse

\end{itemize}
\n because of hash that means all MOVW in a file are shared when lexing

Predefined identifiers are stored in the symbol table for
efficiency reason.
%ocaml: could use a different hash table
Indeed, the symbol table is first a hash table, and so
it can be (ab)used by the lexer to quickly check 
if an identifier corresponds to the mnemomic of an opcode or register.
One of the initialisation function, [[cinit()]],
resets and then populates [[hash]] with all the 
array elements of [[itab]] we have seen in the previous section:

<<[[cinit()]] hash initialisation from itab>>=
for(i=0; i<NHASH; i++)
    hash[i] = S;
for(i=0; itab[i].name; i++) {
    s = slookup(itab[i].name);
    s->value = itab[i].value;
    s->type = itab[i].type;
}
@

In the case of predefined identifiers, another field of [[Sym]]
is used to also store the token code of the identifier
(in addition to the token value, that is the enumeration value of the opcode or register, stored in [[Sym.value]]):

<<[[Sym]] token fields>>=
//enum<token_code> (e.g. LLAB, LNAME, LVAR, LARITH, etc)
ushort	type;
@
\l see also itab[i].type and itab[i].value
\l used by?



[[Sym]] is part of the token union we have seen in the previous
sections. Indeed the token value for 
symbols ([[LNAME]]), 
labels ([[LLAB]]), 
and symbolic constants ([[LVAR]])
is a reference to its [[Sym]] in the symbol table:

<<union declaration other fields(arm)>>=
Sym    *sym;    // for LNAME/LLAB/LVAR
@
\t mutual ref with sym here where sym has itself a type that is the token_kind



The function below is called by [[lookup()]] when
a new symbol is created to reset some of its fields:

<<function syminit>>=
void
syminit(Sym *sym)
{
    sym->type = LNAME;
    sym->value = 0;
}
@


%dead:
%<<[[Sym]] other fields>>=
%Ref*	ref; // unused for 5a, matters?
%@
%<<struct Ref>>=
%// only for 8a actually, and actually not used so I removed it
%struct	Ref
%{
%    int	class;
%};
%@



\section{[[Sym_kind]]}

Now that we have seen the [[Sym]] structure, we
can present the [[sym]] field of the [[Gen]] structure:

<<[[Gen]] other fields>>=
// option<ref<Sym>>, ref owned by hash
Sym*	sym;
@
%less: maybe should rename this field 'name'? and then use name_kind?
\t actually also one of the union token case

This field is used for operands involving symbols. For instance
in [[hello+4(SB)]], [[Gen.sym]] will point
to the symbol [[hello]] in the global [[hash]] table.
%
An additional [[Gen]] field is used to represent
the {\em kind} of the symbol:

<<[[Gen]] other fields>>=
// option<enum<sym_kind>>, None = N_NONE
short	symkind;
@
%old: was called name, but confusing I think, name as a field was used in
% many structures and it's actually not a name
%less: rename to name_kind? rename also the sym field above?

<<enum sym_kind(arm)>>=
enum sym_kind {
    N_NONE,

    D_EXTERN, // text/data/bss values (from SB)
    D_AUTO,   // stack values (from SP)
    D_PARAM,  // parameter (from FP)
    <<sym_kind cases>>
};
@
% use A_EXTERN? or N_EXTERN? is D_XXX because was in operand_kind before
%/* name */ for D_EXTERN
%note: this used to be with operand_kind, but they are really disjoint
% and used only for the ANAME pseudo opcode. In 5l/ there is
% actually a separate Dconv and Nconv (but in 8l/ they are together).

So, the C value of the operand in the example above is:
%EXAMPLE:
\begin{verbatim}
// operand value for: hello+4(SB)
{ sym = &<hello Sym>;  // hello
  offset = 4;          // +4
  sym_kind = D_EXTERN; // SB
  type = D_OREG;       // (...)
}
\end{verbatim}
\l could use reg? but then no need with (R12) and (SB)
\n the symkind is a property of the Gen and not Sym!
\l because people disambiguate at each use, foo(SB), foo _plus_ 0(FP), etc.

Note that there is no special operand kind such as [[D_ADDRESS]]
to encode operands such as \$[[hello(SB)]]. Instead
the [[D_CONST]] type is (ab)used:
%EXAMPLE:
\begin{verbatim}
// operand value for: $hello(SB)
{ sym = &<hello Sym>;  // hello
  offset = 0;
  sym_kind = D_EXTERN; // SB
  type = D_CONST;      // $
}
\end{verbatim}

There is no ambiguity with the representation of simple constants
since the [[sym]] field in those cases would be NULL.
\l moreover address is a kind of constant? actually make sense to use dollar
\l but what is the code generated?

% Assembler is outputing a (spreaded) symbol table in the object file.
% Important job of assembler is to prepare for linker, to enable
% the linker to link modules together and so to resolve references 
% to external symbols.

%note that can have symkind set but not necessarality a sym,
% but it's in the degenerated case of con ( pointer ) which
% I think should not happen (or should happen when don't care
% about naming the parameter so just do  4(FP) in which
% case sym can be seen as an anonymous symbol name.




%section{[[pc]]} ?










\chapter{Main Functions}
\label{chap:main}

We now switch to a top-down approach where we describe
the main functions of [[5a]] starting from [[main()]]
down to [[assemble()]].

\section{[[main()]]}

Before showing the code of [[main()]] we first introduce
a few globals set by [[main()]].
%
A common pair of globals in \plan code
are [[thechar]] and [[thestring]] which both represent
the current architecture.
%
As said in the introduction, \plan by convention 
represents architectures with a single character: 
[['0']] is MIPS, 
[['5']] is ARM, 
[['8']] is x86, etc.
%
This character is used by [[5a]] for instance
for the filename extension of object files (e.g. [[hello.5]]): 

<<global thechar>>=
int	thechar;
@
\l int? no char? then use Rune!

[[thestring]] contains the longer, more readable, version
of the architecture, e.g. [["arm"]] for [[5]].

<<global thestring>>=
char*	thestring;
@

This is used by [[5a]] for instance to find architecture
specific system header files, e.g. in [[/arm/include/...]].
Indeed, [[5a]] is a macro-processor in which [[#include]] have
a default {\em search path} (represented by
the global [[include]] in [[main()]] below).


We can now present the code of [[main()]], the entry point of [[5a]].
The most important thing is the call to [[assemble()]] at the
end, with the filename of the assembly file to process 
passed through a command line argument:

<<function main(arm)>>=
void
main(int argc, char *argv[])
{
    <<[[main()]] locals>>
    <<[[main()]] debug initialization>>

    thechar = '5';
    thestring = "arm";

    cinit();
    include[ninclude++] = ".";

    ARGBEGIN {
    <<[[main()]] command line processing>>
    } ARGEND

    if(*argv == '\0') {
        print("usage: %ca [-options] file.s\n", thechar);
        errorexit();
    }

    <<[[main()]] multiple files handling>>

    if(assemble(argv[0]))
        errorexit();
    exits(0);
}
@


Another important global, set possibly by [[main()]],
is [[outfile]] which stores the name of the output object file,
and which can be modified by the [[-o]] option:

<<global outfile>>=
char*	outfile = nil;
@
\l hmm could be 5.out instead no? hmm no, it will be set
\l to {basename(input_file)}.{thechar} in assemble()

<<[[main()]] command line processing>>=
case 'o':
    outfile = ARGF();
    break;
@





\section{[[cinit()]]}
\label{sec:nullgen}
\t rename to just init? why the C?

[[cinit()]] contains a few globals initialisations:
%ocaml: do not need that as initialisations are more flexible in ocaml

<<function cinit(arm)>>=
/// main -> <>
void
cinit(void)
{
    Sym *s;
    int i;

    <<[[cinit()]] nullgen initialisation>>
    <<[[cinit()]] hash initialisation from itab>>
    <<[[cinit()]] pathname initialisation from cwd>>
}
@
%old: used to do more initialisation here, but instead move the init at def loc
\n very similar to the x86 version, except the few change for nullgen fields

[[nullgen]] is a global we will often see later used to initialize
fresh operands in code such as [[newopd = nullgen;]]:

<<global nullgen>>=
Gen	nullgen;
@
%ocaml: no need that, just set all fields each time with record

<<[[cinit()]] nullgen initialisation>>=
nullgen.type    = D_NONE; // no type set yet
nullgen.reg     = R_NONE;
nullgen.symkind = N_NONE;
nullgen.sym = S;
nullgen.offset = 0; // part of a union
@

\ifallcode
<<[[cinit()]] nullgen initialisation>>=
if(FPCHIP)
    nullgen.dval = 0;
for(i=0; i<sizeof(nullgen.sval); i++)
    nullgen.sval[i] = 0;
@
\fi
%todo: now that I use an union, this code is valid about dval and sval?
% can't use N_NONE because this function is in aa/ and N_NONE is
% in 5a/a.h
%ocaml: merge with def, use nice record syntax


% cwd, for #include "" (cwd can change as one include other files)
%  =~ dirname(current_file)

[[pathname]] represents the {\em current working directory} 
(CWD). This is used also for the [[#include]] search path.

<<global pathname>>=
char*	pathname;
@
%less: rename? dirname_of_input_file? (actually it's really
% dirname_of_current_input_file as 5a can process multiple files,
% but it would complicate things; multifile is an advanced topic)

<<[[cinit()]] pathname initialisation from cwd>>=
pathname = allocn(pathname, 0, 100);
if(getwd(pathname, 99) == 0) {
    pathname = allocn(pathname, 100, 900);
    if(getwd(pathname, 999) == 0)
        strcpy(pathname, "/???");
}
@
%???
\t mv later? with #include?

\section{[[assemble()]]}

Because one can reference labels defined later in an assembly file,
a common approach to assembling is to use a two-pass algorithm.
The first pass focuses on the {\em definitions} of labels;
by the end of the file the values of all labels are known.
The second pass focuses on the {\em uses} of labels and leverages
the information computed in the first pass.
%
This is the strategy used by [[5a]]
and so an important global is [[pass]] which stores
in which pass we currently are (1 or 2):
\l alternatives to two-pass algo: lazy, patch back

<<global pass>>=
// 1|2
int	pass;
@
%ocaml: need this to be a global? could instead parse asm, return AST
% and then algo in two passes on the AST, a visitor and then generator.

This global is set by [[assemble()]] below and is used
in a few places in the grammar as well as in [[outcode()]]:

<<function assemble>>=
error1
assemble(char *infile)
{
    fdt of; // outfile
    char *p;
    <<[[assemble()]] locals>>

    <<[[assemble()]] set p to basename(infile) and adjust include>>
    if(outfile == nil) {
        <<[[assemble()]] set outfile to {basename(infile)}.{thechar}>>
    }
    <<[[assemble()]] setinclude("/{thestring}/include") or INCLUDE>>

    of = mycreat(outfile, 0664);
    if(of < 0) {
        yyerror("%ca: cannot create %s", thechar, outfile);
        errorexit();
    }
    Binit(&obuf, of, OWRITE);

    pass = 1;

    pinit(infile);
    <<[[assemble()]] init Dlist after pinit>>
    yyparse(); // calls outcode() but does nothing when pass == 1

    if(nerrors) {
        cclean();
        return nerrors;
    }

    pass = 2;
    outhist(); // file history information at the beginning of the object

    pinit(infile);
    <<[[assemble()]] init Dlist after pinit>>
    yyparse(); // calls outcode() that now does things

    cclean();
    return nerrors;
}
@
%pad: I renamed parameter to infile, to better contrast with outfile

Essentially [[assemble()]] calls [[yyparse()]]
two times, with the appropriate value set in [[pass]], after
having initialized some globals related to the input file via [[pinit()]].
This means the input assembly file is parsed two times, but
the actions in the grammar do different things the second time.
%ocaml: ugly globals, dont see clearly, also ugly parse two times
%
[[assemble()]] returns the number of errors it found,
or 0 if everything went fine. It is using the global [[nerrors]].
See Appendix~\ref{chap:error} for the error managment globals and functions.

Another global initialized by [[assemble()]] is [[obuf]],
the {output buffer} which will contain the content
of the object file [[5a]] generates:

% outfile(filename) -> of(fd) -> obuf(biobuf)
<<global obuf>>=
Biobuf	obuf;
@
%ocaml: why another global, ugly, because yyparse inflexible?

This will be used notably by [[outcode()]].
The main output data flow in [[assemble()]] is to go from
the name of the output file ([[outfile]]), 
to an output file descriptor ([[of]]),
to finally an output buffer ([[obuf]]).
%
Note that many globals are used for output data (e.g. [[obuf]])
as well as input data (see [[pinit()]]),
which makes the code harder to read. 
This is probably because the interface
for [[yyparse]], the function generated by Yacc,
is a function which does not take any argument nor return anything, so we
are forced to use globals.

The function below is called just before returning
from [[assemble()]] and is used to add the last
instruction in the object file: [[AEND]].
It is a special marker used by [[5l]].
\t need AEND? yes, the linker wants an AEND, and I think
\l when use a library, can have multiple objects concatenated
\l in which case AEND is a marker for the end of an object.

<<function cclean(arm)>>=
/// main -> assemble -> <>
void
cclean(void)
{

    outcode(AEND, Always, &nullgen, R_NONE, &nullgen);
    Bflush(&obuf);
}
@




\ifallcode
<<[[assemble()]] locals>>=
int i;
@
\fi

The remaining code in [[assemble()]] is mostly
filename manipulations and modifying globals used
for [[#include]] processing.
Those filename manipulatons start with the temporary [[ofile]]
used to compute [[outfile]] later:
<<[[assemble()]] locals>>=
char ofile[100];
@

<<[[assemble()]] set p to basename(infile) and adjust include>>=
// p = basename(infile)
// include[0] = dirname(infile); 
strcpy(ofile, infile);
p = utfrrune(ofile, '/');
if(p) {
    include[0] = ofile;
    *p++ = '\0';
} else
    p = ofile;
@

Note that [[utfrrune()]] above returns the {\em last} occurence of a Rune.
A {\em rune} is a unicode character in \plan terminology.

<<[[assemble()]] set outfile to {basename(infile)}.{thechar}>>=
// outfile =  p =~ s/.s/.5/;
outfile = p;
if(outfile){
    p = utfrrune(outfile, '.');
    if(p)
        if(p[1] == 's' && p[2] == '\0')
            p[0] = '\0';
    p = utfrune(outfile, '\0');
    p[0] = '.';
    p[1] = thechar;
    p[2] = '\0';
} else
    outfile = "/dev/null";
@


<<[[assemble()]] locals>>=
char incfile[20];
@

<<[[assemble()]] setinclude("/{thestring}/include") or INCLUDE>>=
p = getenv("INCLUDE");
if(p) {
    setinclude(p);
} else {
    if(systemtype(Plan9)) {
        sprint(incfile,"/%s/include", thestring);
        setinclude(strdup(incfile));
    }
}
@
\l see Section X






\chapter{Input}
\label{chap:input}

Now that we have seen [[assemble()]], we can start
explaining the different components in the assembling
pipeline, starting in this chapter with the input functions.

We have mentioned before [[pinit()]] which initializes
globals related to input. We will also describe below
[[GETC()]], which uses those globals,
and is called by the lexer [[yylex()]] (called itself
by the parser [[yyparse()]]) to get the next character from
the input assembly file (or one of its included file).

\section{[[pinit()]]}
\t rename pass_init? parse_init?

[[pinit()]] initializes a few globals related to input.
It is called at the beginning of each pass in [[assemble()]]:

<<function pinit>>=
/// main -> assemble -> { <> ; yyparse } x 2
void
pinit(char *f)
{
    <<[[pinit()]] locals>>

    lineno = 1;

    newio(); // set ionext
    newfile(f, FD_NONE); // use ionext, set iostack, set fi

    <<[[pinit()]] initialisations>>
}
@


\ifallcode
<<[[pinit()]] locals>>=
int i;
Sym *s;
@
\fi

The [[lineno]] global tracks the current line number and will be
incremented by the lexer for each newlines. It is used
in the object code generator to remember where each
instruction comes from. This will be useful for debugging.

<<global lineno>>=
long	lineno;
@
\t Is it after #include expansion line number?
%less: rename glineno?
%ocaml: could be embedded in the token, so no need global, no need getc
% vs GETC, unget, etc. Less mess.

The calls to [[newio()]] and [[newfile()]] will be explained below.

\section{Files managment, [[iostack]]}

[[5a]] is a macro-assembler which embeds his own [[cpp]]-like preprocessor
\footnote{
Note that [[5a]] could also instead rely on an external 
preprocessor, which would factorize code with [[5c]],
but that would be slower because of the need to fork
another process in the assembling pipeline.
\n meh, better to separate concern and have cpp in a different program?
\l actually they factorized a bit originally bug was ugly lexbody, macbody, etc
}.
%
Because [[5a]] supports [[#include]], the input assembly file can include
another file, which itself can include another file and so on.
So, we may have to open many files,
and when a file has been fully processed, we need to go back
to the file which was including it, the {\em includer}.
This suggests a {\em stack} data structure: a stack of opened input file.
The following structure represents an element of this stack,
essentially an opened file with a file descriptor in [[Io.f]]:

<<struct Io>>=
struct	Io
{
    // option<fdt>, None = FD_NONE
    fdt	f;
    <<[[Io]] buffer fields>>
    // Extra
    <<[[Io]] extra fields>>
};
@
\n hmm, could they use shorter fieldnames ...

The global [[iostack]] represents the {top} of the stack, that
is the current file being scanned:

<<global iostack>>=
// list<ref_own<Io> (next = Io.link)
Io*	iostack = I;
@
% used to be set in cinit()

One can implement a stack in C using a list:

<<[[Io]] extra fields>>=
// list<ref_own<Io>>, head = iostack (or iofree)
Io*	link;
@
<<constant I>>=
#define	I	((Io*)nil)
@


The main job of [[newio()]] is to make point
the global [[ionext]] to a newly allocated [[Io]]
which can be used later by [[newfile()]]:
%ocaml: so many globals

<<global ionext>>=
// option<ref<IO>>
Io*	ionext;
@

<<function newio>>=
/// main -> assemble -> pinit -> <>; newfile
void
newio(void)
{
    Io *i;

    <<[[newio()]] allocate a new Io in [[i]] or find a free one>>
    ionext = i;
    i->f = FD_NONE;
    i->c = 0;
}
@
%ocaml: why not return it? because dont want caller to free it?

The [[Io]] allocator could be simply a call to [[malloc()]].
The matching call to [[free()]] then should be in the code which
closes the opened file when the content if fully read.
Instead, [[5a]] uses the common C technique of {\em free list}
to manage [[Io]]s and so can ``recycle'' an [[Io]] 
for another opened file:

<<global iofree>>=
// list<IO>, next = IO.link
Io*	iofree = I;
@

<<[[newio()]] allocate a new Io in [[i]] or find a free one>>=
static int pushdepth = 0;

i = iofree;
if(i == I) {
    pushdepth++;
    if(pushdepth > 1000) {
        yyerror("macro/io expansion too deep");
        errorexit();
    }
    //todo: check error code?
    i = alloc(sizeof(Io));
} else
    iofree = i->link;
@


[[newfile()]] assumes [[ionext]] has been set
correctly in [[newio()]] and open finally the input assembly file:

<<function newfile>>=
/// main -> assemble -> pinit -> { newio; <> }
/// yylex -> macinc -> <>
void
newfile(char *s, fdt f)
{
    Io *i;

    // add_list(ionext, iostack)
    i = ionext;
    i->link = iostack;
    iostack = i;

    i->f = f;
    if(i->f == FD_NONE)
        i->f = open(s, 0);
    if(i->f < 0) {
        yyerror("%ca: %r: %s", thechar, s);
        errorexit();
    }
    fi.c = 0;
    linehist(s, 0);
}
@
\t will see linehist later

\section{Buffer managment, [[fi]]}

Once the input file is opened, the lexer needs to look
at its content one character at a time.
%
Instead of using many system calls such as [[read(..., 1)]] to read
one character at a time, which would be slow,
[[5a]] instead calls
[[read()]] once in a while to fill a large
{\em input buffer}, and then use auxillary functions
to move pointers in this buffer. This buffer is simply
an array of character in [[Io]]:
%ocaml: buffered IO should be done in library

<<[[Io]] buffer fields>>=
char	b[BUFSIZ];
@
<<constant BUFSIZ>>=
#define	BUFSIZ		8192
@

A few functions below are using the global [[fi]] which contains
pointers in the input buffer of the currently processed input file:

<<global fi>>=
struct Fi fi;
@

<<struct Fi>>=
struct Fi
{
    // ref<char>, pointer in Io.b
    char*	p;
    // remaining characters in Io.b to read
    int	c;
};
@
\l File input
\l could use directly iostack->p and iostack->c, no need for this cache

Once we processed an included file we need to
go back to the includer file (which can be found easily thanks
to [[iostack->link]]). But we also need to remember
where we were in the includer file, hence those extra fields:

<<[[Io]] buffer fields>>=
// like Fi, saved pointers in IO.b
char*	p;
short	c;
@
\l unicode input but here char pointer!

\section{[[GETC()]]}

We can finally see the code of [[GETC()]] which
is a macro called many times in [[yylex()]] to
get the next character from the input file, and which
uses the global [[fi]] we have seen above:

<<function GETC>>=
/// main -> assemble -> yyparse -> yylex -> <>
#define	GETC()		((--fi.c < 0) ? filbuf() : *fi.p++ & 0xff)
@
\l a bit tricky; also unicode but here 0xff, it's a character

<<function filbuf>>=
int
filbuf(void)
{
    Io *i;

loop:
    i = iostack;
    if(i == I)
        return EOF;
    if(i->f < 0) // When this happens?
        goto pop; 

    // system call! fill really the buffer
    fi.c = read(i->f, i->b, BUFSIZ) - 1;
    if(fi.c < 0) {
        close(i->f);
        linehist(nil, 0);
        goto pop;
    }
    fi.p = i->b + 1;
    return i->b[0];

<<[[filbuf()]] pop>>
}
@
\l return int or char?

The [[-1]] above is because [[Fi.c]] represents the remaining
characters to read, so if [[read()]] returns only 1,
meaning one character only was read, then this character
will be returned and so there is nothing else to read after,
in which case [[Fi.c]] should be 0 (hence the [[-1]]).
%
Figure~\ref{fig:input-buffer} represents the evolution of the state
of [[fi]] while the input buffer gets filled.

\begin{figure}[!]\centering
\begin{verbatim}
0                                                      8192 
+-------------------------------------------------------+
|                                                       |
+-------------------------------------------------------+
^
|                             
fi.p   (fi.c = 0)

(a) Empty buffer in iostack->b

0                                                      8192 
+-------------------------------------------------------+
|l|a|t|e|r|:|              ...                      |M|O|
+-------------------------------------------------------+
  ^<---------------------------------------------------->
  |                       fi.c = 8191
  fi.p 

(b) After first call to GETC(): returned 'l', 
    increment fi.p, decrement fi.c

\end{verbatim}
\caption{Evolution of the input buffer}\label{fig:input-buffer}
\end{figure}


When there is nothing more to read in the file,
we need to [[pop()]] the file from [[iostack]] and
update [[fi]] to point to the input buffer of the includer file:

<<[[filbuf()]] pop>>=
pop:
    // pop(iostack)
    iostack = i->link;
    // push(i, iofree)
    i->link = iofree;
    iofree = i;

    // i = top(iostack), the fresh top of the stack input file
    i = iostack;
    if(i == I)
        return EOF;
    // restore file pointers
    fi.p = i->p;
    fi.c = i->c;
    if(--fi.c < 0)
        goto loop;
    return *fi.p++;
@

\plan uses unicodes so characters are actually integers.
A few constants are used to represent special characters;
they are negatives to not conflict with regular unicode characters:
\t MEH

<<constant EOF>>=
#define	EOF		(-1)
@
\t MEH

%Note that even if [[5a]] accepts unicode characters, [[GETC()]]
%returns only basic characters. The type of [[Fi.p]] and [[Io.b]]
%are [[char]] pointers.
\l and so? there are functions later that reconstruct unicode from
\l set of chars? what if incomplete unicode char in buffer boundary?







\chapter{Lexing}
\label{chap:lexing}

The next component in the assembly pipeline is the lexer
function [[yylex()]] called by the parser [[yyparse()]].
%
It relies on [[GETC()]] which we have seen
before to get the next character in the currently processed input file.
\l (that is iostack->f )

\section{[[yylex()]]}

Even though [[5a]] is not using Lex, Yacc requires
the lexer to be represented by a function called [[yylex()]]. 
%
This function does not take any
argument (hence the use of many globals), and must return
the {\em code} of a token, or [[-1]] (EOF) when there is no
more token to read, or a single character if the
token is simply a single character:
%ocaml: EOF needs special care also in ocamlyacc and ocamllex

<<signature yylex>>=
// unit -> (enum<token_code> | -1 (EOF) | Rune)
long	yylex(void);
@
%ocaml: ugly abuse long

[[yylex()]] can also modify the global [[yylval]] 
to store the {\em value} of the token
which is a union type (see Section~\ref{sec:token}).
This value can then be retrieved via the \$$n$ notation
in the Yacc actions as we will see in Chapter~\ref{chap:parsing}.
%ocaml: should use lex. Simpler. But maybe to avoid bootstrapping issues?
% hmm but they use yacc so ... (and lex uses yacc)
% or maybe because if want to have builtin-cpp, easier to do without Lex?


[[yylex()]] is essentially an {\em automata} 
reading characters (with [[GETC()]]) 
in a loop (with the label [[l0:]] and [[goto]] below),
using a big [[switch]] on the current character read ([[c]])
to transition states (using more labels and [[goto]]s as we will see), 
until a full token is formed:

<<function yylex>>=
/// main -> assemble -> yyparse -> <>
long
yylex(void)
{
    int c; // Rune?
    <<[[yylex()]] locals>>

    <<[[yylex()]] peekc handling, starting part>>
l0:
    c = GETC();
l1:
    if(c == EOF) {
        peekc = EOF; // needed?
        return -1;
    }

    if(isspace(c)) {
        <<[[yylex()]] if c is newline>>
        // ignore spaces
        goto l0;
    }

    <<[[yylex()]] before switch, if isxxx>>
    switch(c) {
    <<[[yylex()]] switch c cases>>
    default:
        return c;
    }
    <<[[yylex()]] peekc handling, ending part>>
    return c;
}
@
\t now return a long, fillbuf was returning an int. hmmm
%ocaml: ugly to not take any input and use globals. Should take a lexbuf!
% also with pattern character range no need ugly isalpha and isdigit

In the next sections we will mostly show the code of the
different cases in the [[switch]].

\section{Peek, seek, and look ahead}

When trying to identify a token, e.g. an identifier, it is
frequent to read characters until the current character
does not satisfy a certain criteria, e.g. being a letter.
In that case one has read too far in the input file
and should go back one character using [[seek()]].
%
Another technique is to store instead in a global
this extra character:

<<global peekc>>=
// option<Rune>, None = IGN
int	peekc = IGN;
@
\t use Rune?
\l =~ yyback(1) trick, used by yylex() and getc(), and?? cg?
%pad: used to be set in cinit()

<<constant IGN>>=
#define	IGN		(-2)
@
\l also negative, -2 because EOF is -1 already used

<<[[pinit()]] initialisations>>=
peekc = IGN;
@


Then we need to make sure the function reading characters 
from the input file ([[yylex()]]) first looks in this global
before trying to read any new character:

<<[[yylex()]] peekc handling, starting part>>=
c = peekc;
if(c != IGN) {
    peekc = IGN; // consumed
    goto l1; // skip the GETC(), we already have a character in c
}
@

In the sections below, the local [[c1]] can be used
to store the {\em look ahead} character when one needs to read
an extra character in addition to [[c]] to decide
what to do:

<<[[yylex()]] locals>>=
int c1;
@
\n need that? why not modify peekc directly? because not automatic!

This extra character is considered by default the
peek character for the next call to [[yylex()]],
unless [[yylex()]] returns before:

<<[[yylex()]] peekc handling, ending part>>=
peekc = c1;
@



\section{Newlines (and semicolons)}
\label{sec:semicolon}

As said in Section~\ref{sec:asm5-lexical},
newlines in Asm5 are transformed in semicolons which
are recognized as instruction terminators in the Asm5 grammar:
\n and not separators

<<[[yylex()]] if c is newline>>=
if(c == '\n') {
    lineno++;
    return ';'; // newline transformed in fake ';'
}
@
\l note also lineno plus plus

Note that because the token in a single character, it can
be returned directly. There is no need to invent
a [[LSEMICOLON]] token code.

<<[[yylex()]] switch c cases>>=
case '\n':
    lineno++;
    return ';';
@
\t can be reached? isspace(c) above seems unreachable



\section{Comments}

Asm5 comments use the same syntax than C comments,
e.g. [[/* foo */]] or [[// foo]], and are skipped
by the lexer hence the [[goto]] back to [[l0]] (or [[l1]])
below:

<<[[yylex()]] switch c cases>>=
case '/':
    c1 = GETC();
    if(c1 == '/') {
        // '/''/' read, skip everything until next '\n'
        for(;;) {
            c = GETC();
            if(c == '\n')
                goto l1;
            if(c == EOF) {
                yyerror("eof in comment");
                errorexit();
            }
        }
    }
    if(c1 == '*') {
        // '/''*' read, skip everything until next '*''/'
        for(;;) {
            c = GETC();
            while(c == '*') {
                c = GETC();
                if(c == '/')
                    goto l0;
            }
            if(c == EOF) {
                yyerror("eof in comment");
                errorexit();
            }
            if(c == '\n')
                lineno++;
        }
    }
    break;
@
\l put getcom() here too?
\l important not forget lineno! also while not if subtle :)

\section{Mnemonics, symbols and labels}

Until now we were mostly skipping characters (spaces, comments),
or returning a single character (semicolon). 
For identifiers we need to accumulate a set of characters and look if
they correspond to mnemonics, symbols, or labels.
%
The local [[cp]] below will point in the [[symb]] global buffer
we have seen in Section~\ref{sec:sym} which is then internally
used by [[lookup()]] to look for predefined identifiers
or labels or symbols in the global [[hash]] symbol table:
\t itab!

<<[[yylex()]] locals>>=
// ref<char>, pointer in symb
char *cp;
// ref<Symbol>, owned by hash
Sym *s;
@

<<[[yylex()]] before switch, if isxxx>>=
if(isalpha(c))
    goto talph;
@
%ocaml: power case, character range ftw

<<[[yylex()]] switch c cases>>=
case '_':
case '@':
// case 'a'..'z' 'A'..'Z': (isalpha())
talph:
    cp = symb;

aloop:
    *cp++ = c;
    c = GETC();
    if(isalpha(c) || isdigit(c) || c == '_' || c == '$')
        goto aloop;
    // went too far
    peekc = c;

    *cp = '\0';
    s = lookup(); // uses symb global and so cp
    <<[[yylex()]] if macro symbol>>
    if(s->type == 0) // when can this happen?
        s->type = LNAME;
    <<[[yylex()]] in identifier case, set yylval>>
    return s->type;
@
%$
%ocaml: use of peekc is yyback(1)
\l @? maybe remove it so it would also remove the need for LAT token_kind
\t possible to have s->type == 0? if new sym theni it is set to LNAME in syminit

Remember that [[Sym.type]] contains the token code of
the ``symbol''.
The union [[yylval]] is set according to the kind of the symbol:
the actual [[Sym]] for labels and symbols, the enumeration value
for predefined identifiers (mnemonics):

<<[[yylex()]] in identifier case, set yylval>>=
if(s->type == LNAME || s->type == LLAB || s->type == LVAR) {
    yylval.sym = s;
} else {
    yylval.lval = s->value;
}
@

\t note that LLAB set in grammar! so in pass2 or if defined before
\t then return different token_kind! not context free.

\section{Numbers}

Numbers are a bit more complicated to parse than what
we have seen until now  because Asm5
manages different kinds of numbers and
allows different syntaxes for numbers, similar to C: 
decimals ([[12]]), 
hexadecimals ([[0xa12]]), 
octals ([[0777]]),
floats ([[0.2]], [[1e3]]), 
or typed integers ([[1uL]]).
%
The [[case]] below use different labels and [[goto]]s
to transition to different states where each state
recognizes a different kind of number:

<<[[yylex()]] before switch, if isxxx>>=
if(isdigit(c))
    goto tnum;
@
<<[[yylex()]] switch c cases>>=
// case '0'..'9': (isdigit())
tnum:
    cp = symb;
    if(c != '0')
        goto dc;

    <<[[yylex()]] in number case, 0xxx handling>>

<<[[yylex()]] in number case, decimal dc label handling>>
<<[[yylex()]] in number case, float labels handling>>
@

%FIGURE state diagram?

\ifallcode
<<[[yylex()]] in number case, if vlong lval>>=
if(sizeof(yylval.lval) == sizeof(vlong))
    yylval.lval = strtoll(symb, nil, 10);
else
@
\fi
\t delete? dead code for 5a and 8a


\subsection{Decimals}

Most of the magic for decimal numbers is done
by [[strtol()]] from the core C library:

<<[[yylex()]] in number case, decimal dc label handling>>=
dc:
    for(;;) {
        if(!isdigit(c))
            break;
        *cp++ = c;
        c = GETC();
    }
    <<[[yylex()]] in number case, in decimal case, float handling>>
    *cp = '\0';
    <<[[yylex()]] in number case, if vlong lval>>
    yylval.lval = strtol(symb, nil, 10);

<<[[yylex()]] in number case, in decimal case, ncu suffix label handling>>
    peekc = c;
    return LCONST;
@

The unsigned and long typed suffixes are ignored by Asm5:

<<[[yylex()]] in number case, in decimal case, ncu suffix label handling>>=
ncu:
    while(c == 'U' || c == 'u' || c == 'l' || c == 'L')
        c = GETC();
@
\l ncu?

\subsection{Hexadecimals and octals}

[[strtol()]] does not unfortunately handle hexadecimal
or octal numbers so we have to do things manually:
%ocaml: int_of_string does


<<[[yylex()]] in number case, 0xxx handling>>=
*cp++ = c;
c = GETC();
c1 = 3; // 2^3, for octal
if(c == 'x' || c == 'X') {
    c1 = 4; // 2^4, for hexa
    c = GETC();
} 
else if(c < '0' || c > '7')
    goto dc;
yylval.lval = 0;
for(;;) {
    if(c >= '0' && c <= '9') {
        if(c > '7' && c1 == 3)
            break;
        yylval.lval <<= c1;
        yylval.lval += c - '0';
        c = GETC();
        continue;
    }
    if(c1 == 3)
        break;
    if(c >= 'A' && c <= 'F')
        // c = lowercase(c)
        c += 'a' - 'A';
    if(c >= 'a' && c <= 'f') {
        yylval.lval <<= c1;
        yylval.lval += c - 'a' + 10;
        c = GETC();
        continue;
    }
    break;
}
goto ncu;
@
%ocaml: ugly 3 and 4 special code, ugly abuse c1, but convenient for the <<=

\subsection{Floats}

<<[[yylex()]] in number case, in decimal case, float handling>>=
if(c == '.')
    goto casedot;
if(c == 'e' || c == 'E')
    goto casee;
@

Most of the magic for float numbers is done
by [[atof()]] from the core C library:
\l why a?? why not strtof?

<<[[yylex()]] in number case, float labels handling>>=
casedot:
    for(;;) {
        *cp++ = c;
        c = GETC();
        if(!isdigit(c))
            break;
    }
    if(c == 'e' || c == 'E')
        goto casee;
    goto caseout;

casee:
    *cp++ = 'e';
    c = GETC();
    if(c == '+' || c == '-') {
        *cp++ = c;
        c = GETC();
    }
    while(isdigit(c)) {
        *cp++ = c;
        c = GETC();
    }

caseout:
    *cp = '\0';
    peekc = c;
    if(FPCHIP) {
        yylval.dval = atof(symb);
        return LFCONST;
    } else {
        yyerror("assembler cannot interpret fp constants");
        yylval.lval = 1L;
        return LCONST;
    }
@

A dot without numbers before can be in Asm5 the start of a float or
the start of an identifier, or simply the dot character:

<<[[yylex()]] switch c cases>>=
case '.':
    c = GETC();
    if(isalpha(c)) {
        cp = symb;
        *cp++ = '.';
        goto aloop;
    }
    if(isdigit(c)) {
        cp = symb;
        *cp++ = '.';
        goto casedot;
    }
    peekc = c;
    return '.';
@
\l why not simply goto talph for '.'? avoid duplicate the cp = symb; ...

\section{Characters and escape sequences}
\l unicode?

Asm5 allows {\em escape sequences}, which are started with
an antislash, to represent special characters. This is similar to C.
For instance 
[['\n']] represents the newline character,
[['\007']] the character with the octal value [[7]], or
\l interet? why not write 007 outside quote? because it's typed as a char!
\l and it is more readable IMHO, I prefer '\0' to 0.
[['\'']] the quote character itself.
\l special chars because no representation otherwise? or because self escape!

The function [[escchar()]] below is a wrapper around
[[GETC()]] which returns also the next
character unless it is the start of an escape sequence
(the antislash) in which case it returns the value
of the parsed escape sequence (the special character).
Note that characters in Asm5 are converted in integers, hence
the [[LCONST]] token code below:

<<[[yylex()]] switch c cases>>=
case '\'':
    c = escchar('\'');
    <<[[yylex()]] in character case, if c is EOF>>
    if(escchar('\'') != EOF)
        yyerror("missing '");

    yylval.lval = c;
    return LCONST;
@

There are two calls to [[escchar()]]: the first to consume the character
after the first quote, e.g. [[a]] in [['a']],
and the second to consume the ending quote itself.
%FIGURE?
%
Indeed, [[escchar()]] returns the special code EOF if 
the character read is the same than the character passed as an argument, 
here the quote.

%Note also that the code itself below uses also escape sequences
%(to represent the quote character):
\l self!

The code below is to deal with the sequence [[''']], which
is parsed as a single quote:

<<[[yylex()]] in character case, if c is EOF>>=
if(c == EOF)
    c = '\'';
@

%\section{Escaping characters}
%Special characters?

The argument to [[escchar()]] is the character used to mark the
end of the ``entity'', here
a quote [[']] because we are parsing characters. In the
next section the argument to [[escchar()]] will be the
double quote [["]] character because we will parse strings.

<<function escchar>>=
int
escchar(int e)
{
    int c, l;

loop:
    c = getc(); // not GETC
    if(c == '\n') {
        yyerror("newline in string");
        return EOF;
    }
    if(c != '\\') {
        if(c == e)
            return EOF;
        return c;
    }
    // else c is '\\'
    c = getc();
    <<[[escchar()]] if octal character>>
    switch(c)
    {
    case '\n':	goto loop; // multi line strings

    case 'n':	return '\n';
    case 't':	return '\t';
    case 'b':	return '\b';
    case 'r':	return '\r';
    case 'f':	return '\f';

    <<[[escchar()]] switch cases>>
    }
    return c;
}
@
\t use Rune instead of int?
\l they abuse EOF to mean end of string

[[getc()]] is a small wrapper over [[GETC()]] which
automatically handles [[lineno]]:

<<function getc>>=
int
getc(void)
{
    int c;

    c = peekc;
    if(c != IGN) {
        peekc = IGN;
        return c;
    }

    c = GETC();

    if(c == '\n')
        lineno++;
    if(c == EOF) {
        yyerror("End of file");
        errorexit();
    }
    return c;
}
@
\l int? why not uint? GETC can return EOF but not this function!
\t will be called also by macro processing code


<<[[escchar()]] if octal character>>=
if(c >= '0' && c <= '7') {
    l = c - '0';
    c = getc();
    if(c >= '0' && c <= '7') {
        l = l*8 + c-'0';
        c = getc();
        if(c >= '0' && c <= '7') {
            l = l*8 + c-'0';
            return l;
        }
    }
    peekc = c;
    return l;
}
@

Asm5 allows a few more escape sequences compared to C:

<<[[escchar()]] switch cases>>=
case 'a':	return 0x07;
case 'v':	return 0x0b;
case 'z':	return 0x00;
@
\l meh

\section{Strings}

<<[[yylex()]] switch c cases>>=
case '"':
    memcpy(yylval.sval, nullgen.sval, sizeof(yylval.sval));
    cp = yylval.sval;
    c1 = 0;
    for(;;) {
        c = escchar('"');
        if(c == EOF)
            break;
        if(c1 < sizeof(yylval.sval))
            *cp++ = c;
        c1++;
    }
    if(c1 > sizeof(yylval.sval))
        yyerror("string constant too long");
    return LSCONST;
@
\l abuse c1
\t works nullgen.sval?? add the appropriate 0? why not just *cp = '\0' ?








\chapter{Preprocessing}
\label{chap:preprocessing}

% Builtin in the binary. A bit of code duplication with the
% compiler, but maybe it makes compilation faster because
% there is no fork at all!

\section{[[mactab]] and [[domacro()]]}

<<[[yylex()]] switch c cases>>=
case '#':
    domacro();
    goto l0;
@
% goto l0 because does not return any token, we just have
% actually expanded or defined macros or undef, in any case
% no token to return, but iostack will have maybe changed,
% or symbol table, and so GETC will maybe change.


<<global mactab>>=
struct
{
    char	*macname;
    void	(*macf)(void);
} mactab[] =
{
    "ifdef",	nil,	/* macif(0) */
    "ifndef",	nil,	/* macif(1) */
    "else",		nil,	/* macif(2) */
    "endif",	macend,

    "include",	macinc,
    "define",	macdef,
    "undef",	macund,
    "pragma",	macprag,
    "line",		maclin,
    0
};
@
% mac for macro (and not macos or macintosh), but used actually
% for all cpp related constructs.
% note: I reorganized the entries, but should not matter


% dispatcher, should rename because it's not just about macro =>
% parse_and_dispatch_pp_directive?
<<function domacro>>=
/// main -> assemble -> yyparse -> yylex -> <>
void
domacro(void)
{
    int i;
    Sym *s;

    s = getsym();
    if(s == S)
        s = slookup("endif");

    for(i=0; mactab[i].macname; i++)
        if(strcmp(s->name, mactab[i].macname) == 0) {
            if(mactab[i].macf)
                // dispatcher!
                (*mactab[i].macf)();
            else
                macif(i);
            return;
        }
    yyerror("unknown #: %s", s->name);
    macend();
}
@
% abuse getsym just to get an ident, don't have to go through
% lookup really
% note: didn't know that a single # is actually equivalent to an endif



<<function macend>>=
void
macend(void)
{
    int c;

    for(;;) {
        c = getnsc();
        if(c < 0 || c == '\n')
            return;
    }
}
@
% I don't think c can be < 0 here.

\section{[[#include]]}
% and [[-I]]

\subsection{Include path, [[-I]]}

<<[[main()]] locals>>=
char *p;
@

% -I
<<[[main()]] command line processing>>=
case 'I':
    p = ARGF();
    setinclude(p);
    break;
@

<<constant NINCLUDE>>=
#define	NINCLUDE	10
@

% hmm rename? include_paths?
<<global include>>=
char*	include[NINCLUDE];
@

<<global ninclude>>=
int	ninclude;
@

<<function setinclude>>=
void
setinclude(char *p)
{
    int i;

    if(p == nil)
        return;
    for(i=1; i < ninclude; i++)
        if(strcmp(p, include[i]) == 0)
            return;

    if(ninclude >= nelem(include)) {
        yyerror("ninclude too small %d", nelem(include));
        exits("ninclude");
    }
    include[ninclude++] = p;
}
@


\subsection{Tracing origin and [[Hist]]}

% when error, need give line, but can be because of context,
% so useful to give the full location of an error, that is the list
% of files that included it
% TODO give example of why it's useful to not just have the final names

% keep track of where a token comes from, so that error
% messages can look like
%  xxx.h from xxx.h from xxx.c ...
<<struct Hist>>=
struct	Hist
{
    char*	filename;

    long	line;   // global line of this Hist
    long	local_line; // local line for this hist 

    // Extra
    <<[[Hist]] extra fields>>
};
@
%note: rename offset to local_line, clearer, and also avoid
% possible confusion with Gen.offset
%abused for #pragma lib "xxx.a" where local_line is then -1. ugly.

<<global hist>>=
// list<ref_own<Hist>>, next = Hist.link
Hist*	hist;
@

<<[[Hist]] extra fields>>=
Hist*	link;
@

<<global ehist>>=
// ref<Hist>, end of list of hist
Hist*	ehist;
@


<<constant H>>=
#define	H	((Hist*)nil)
@





<<function linehist>>=
void
linehist(char *f, int local_line)
{
    Hist *h;

    <<[[linehist()]] debug>>

    h = alloc(sizeof(Hist));
    h->filename = f;
    h->line = lineno;
    h->local_line = local_line;

    //add_list(hist, ehist, h)
    h->link = H;
    if(ehist == H) {
        hist = h;
        ehist = h;
        return;
    }
    ehist->link = h;
    ehist = h;
}
@


%% newflag dead? seems just set to false ... just one write.
%% it's used in cc/ though, but we copy pasted code for macbody so
% I think it's safe to delete it here.
%<<global newflag>>=
%bool	newflag;
%@
%
%    <<[[linehist()]] newflag hack>>
%    <<[[linehist()]] debug>>
%    newflag = false;
%
%
%<<[[linehist()]] newflag hack>>=
%/*
% * overwrite the last #line directive if
% * no alloc has happened since the last one
% */
%if(newflag == false && ehist != H && offset != 0 && ehist->offset != 0)
%    if(f && ehist->filename && strcmp(f, ehist->filename) == 0) {
%        ehist->line = lineno;
%        ehist->offset = offset;
%        return;
%    }
%@




% I prefer to put prfile here rather than in the Error appendix.
% So can better understand actually the tracing mechanism.

<<constant HISTSZ>>=
#define	HISTSZ		20
@

% yyerror -> <>, for nice error reporting with include trace
%  l = lineno
<<function prfile>>=
void
prfile(long l)
{
    int i, n;
    Hist *h;
    Hist a[HISTSZ];
    long d;

    n = 0;
    for(h = hist; h != H; h = h->link) {
        if(l < h->line)
            break;

        if(h->filename) {
            if(h->local_line == 0) {
                if(n >= 0 && n < HISTSZ)
                    a[n] = *h;
                n++;
            } else {
                if(n > 0 && n < HISTSZ)
                    if(a[n-1].local_line == 0) {
                        a[n] = *h;
                        n++;
                    } else
                        a[n-1] = *h;
           }
        }
        // a pop
        else {
            n--;
            if(n >= 0 && n < HISTSZ) {
                d = h->line - a[n].line;
                for(i=0; i<n; i++)
                    a[i].line += d;
            }
        }
    }
    if(n > HISTSZ)
        n = HISTSZ;
    for(i=0; i<n; i++)
        print("%s:%ld ", a[i].filename, 
                         (long)(l - a[i].line + a[i].local_line + 1));
}
@
% see 5a -f to help understand a bit.
% when no filename it means it's a pop

\subsection{[[#include]]}

<<constant STRINGSZ>>=
#define	STRINGSZ	200
@

% LP split
<<function macinc>>=
void
macinc(void)
{
    int c0, c, i, f;
    char str[STRINGSZ], *hp;

    c0 = getnsc();
    if(c0 != '"') {
        c = c0;
        if(c0 != '<')
            goto bad;
        c0 = '>';
    }
    for(hp = str;;) {
        c = getc();
        if(c == c0)
            break;
        if(c == '\n')
            goto bad;
        *hp++ = c;
    }
    *hp = 0;

    c = getcom();
    if(c != '\n')
        goto bad;

    f = -1;
    for(i=0; i<ninclude; i++) {
        if(i == 0 && c0 == '>')
            continue;
        strcpy(symb, include[i]);
        strcat(symb, "/");
        if(strcmp(symb, "./") == 0)
            symb[0] = 0;
        strcat(symb, str);

        f = open(symb, 0);
        if(f >= 0)
            break;

    }
    if(f < 0)
        strcpy(symb, str);
    c = strlen(symb) + 1;
    while(c & 3)
        c++;

    hp = malloc(c);
    memcpy(hp, symb, c);

    newio();
    pushio();
    newfile(hp, f);
    return;

bad:
    unget(c);
    yyerror("syntax in #include");
    macend();
}
@


<<function pushio>>=
void
pushio(void)
{
    Io *i;

    i = iostack;
    if(i == I) {
        yyerror("botch in pushio");
        errorexit();
    }
    i->p = fi.p;
    i->c = fi.c;
}
@

\section{[[#define]]}
% and [[-D]]

\subsection{[[-D]]}

<<[[main()]] command line processing>>=
case 'D':
    p = ARGF();
    if(p)
        Dlist[nDlist++] = p;
    break;
@

% -D
<<global Dlist>>=
char*	Dlist[30];
@

<<global nDlist>>=
int	nDlist;
@

<<[[assemble()]] init Dlist after pinit>>=
for(i=0; i<nDlist; i++)
        dodefine(Dlist[i]);
@

<<[[Sym]] macro fields>>=
//option<string>, for '#define FOO xxx' expansion
char*	macro;
@
\label{sec:macro-sym-field}

<<[[pinit]] initialisations>>=
for(i=0; i<NHASH; i++)
    for(s = hash[i]; s != S; s = s->link)
        s->macro = nil;
@


<<function dodefine>>=
void
dodefine(char *cp)
{
    Sym *s;
    char *p;
    long l;
    char *x;

    strcpy(symb, cp);
    p = strchr(symb, '=');
    if(p) {
        *p++ = 0;
        s = lookup();
        l = strlen(p) + 2;	/* +1 null, +1 nargs */
        while(l & 3)
            l++;

        x = malloc(l);
        *x = '\0';
        strcpy(x+1, p);
        s->macro = x;
    } else {
        s = lookup();
        s->macro = "\0001";	/* \000 is nargs */
    }
    <<[[dodefine()]] debug>>
}
@



\subsection{[[#define]]}

<<constant NARG>>=
#define	NARG	25
@

% wow, this is complicated
<<function macdef>>=
void
macdef(void)
{
    Sym *s, *a;
    char *args[NARG], *np, *base;
    int n, i, c, len, dots;
    int ischr;

    s = getsym();
    if(s == S)
        goto bad;
    if(s->macro)
        yyerror("macro redefined: %s", s->name);
    c = getc();
    n = -1;
    dots = 0;
    if(c == '(') {
        n++;
        c = getnsc();
        if(c != ')') {
            unget(c);
            for(;;) {
                a = getsymdots(&dots);
                if(a == S)
                    goto bad;
                if(n >= NARG) {
                    yyerror("too many arguments in #define: %s", s->name);
                    goto bad;
                }
                args[n++] = a->name;
                c = getnsc();
                if(c == ')')
                    break;
                if(c != ',' || dots)
                    goto bad;
            }
        }
        c = getc();
    }
    if(isspace(c))
        if(c != '\n')
            c = getnsc();
    base = hunk;
    len = 1;
    ischr = 0;
    for(;;) {
        if(isalpha(c) || c == '_') {
            np = symb;
            *np++ = c;
            c = getc();
            while(isalnum(c) || c == '_') {
                *np++ = c;
                c = getc();
            }
            *np = 0;
            for(i=0; i<n; i++)
                if(strcmp(symb, args[i]) == 0)
                    break;
            if(i >= n) {
                i = strlen(symb);
                base = allocn(base, len, i);
                memcpy(base+len, symb, i);
                len += i;
                continue;
            }
            base = allocn(base, len, 2);
            base[len++] = '#';
            base[len++] = 'a' + i;
            continue;
        }
        if(ischr){
            if(c == '\\'){ 
                base = allocn(base, len, 1);
                base[len++] = c;
                c = getc();
            }else if(c == ischr)
                ischr = 0;
        }else{
            if(c == '"' || c == '\''){
                base = allocn(base, len, 1);
                base[len++] = c;
                ischr = c;
                c = getc();
                continue;
            }
            if(c == '/') {
                c = getc();
                if(c == '/'){
                    c = getc();
                    for(;;) {
                        if(c == '\n')
                            break;
                        c = getc();
                    }
                    continue;
                }
                if(c == '*'){
                    c = getc();
                    for(;;) {
                        if(c == '*') {
                            c = getc();
                            if(c != '/')
                                continue;
                            c = getc();
                            break;
                        }
                        if(c == '\n') {
                            yyerror("comment and newline in define: %s", s->name);
                            break;
                        }
                        c = getc();
                    }
                    continue;
                }
                base = allocn(base, len, 1);
                base[len++] = '/';
                continue;
            }
        }
        if(c == '\\') {
            c = getc();
            if(c == '\n') {
                c = getc();
                continue;
            }
            else if(c == '\r') {
                c = getc();
                if(c == '\n') {
                    c = getc();
                    continue;
                }
            }
            base = allocn(base, len, 1);
            base[len++] = '\\';
            continue;
        }
        if(c == '\n')
            break;
        if(c == '#')
        if(n > 0) {
            base = allocn(base, len, 1);
            base[len++] = c;
        }
        base = allocn(base, len, 1);
        base[len++] = c;
        c = ((--fi.c < 0)? filbuf(): (*fi.p++ & 0xff));
        if(c == '\n')
            lineno++;
        if(c == -1) {
            yyerror("eof in a macro: %s", s->name);
            break;
        }
    }
    do {
        base = allocn(base, len, 1);
        base[len++] = 0;
    } while(len & 3);

    *base = n+1;
    if(dots)
        *base |= VARMAC;
    s->macro = base;
    <<[[macdef()]] debug>>
    return;

bad:
    if(s == S)
        yyerror("syntax in #define");
    else
        yyerror("syntax in #define: %s", s->name);
    macend();
}
@
% wow, complicated

<<constant VARMAC>>=
#define VARMAC 0x80
@


<<function getsymdots>>=
Sym*
getsymdots(int *dots)
{
    int c;
    Sym *s;

    s = getsym();
    if(s != S)
        return s;

    c = getnsc();
    if(c != '.'){
        unget(c);
        return S;
    }
    if(getc() != '.' || getc() != '.')
        yyerror("bad dots in macro");
    *dots = 1;
    return slookup("__VA_ARGS__");
}
@

\subsection{Macro Expansion}

<<[[yylex()]] if macro symbol>>=
if(s->macro) {
    newio();
    cp = ionext->b;
    macexpand(s, cp);
    pushio();

    ionext->link = iostack;
    iostack = ionext;

    fi.p = cp;
    fi.c = strlen(cp);
    if(peekc != IGN) {
        cp[fi.c++] = peekc;
        cp[fi.c] = 0;
        peekc = IGN;
    }
    goto l0;
}
@
% abuse newio()? it's not really a new file here

% wow, complicated too
<<function macexpand>>=
void
macexpand(Sym *s, char *b)
{
    char buf[2000];
    int n, l, c, nargs;
    char *arg[NARG], *cp, *ob, *ecp, dots;

    ob = b;
    if(*s->macro == 0) {
        strcpy(b, s->macro+1);
        if(debug['m'])
            print("#expand %s %s\n", s->name, ob);
        return;
    }
    
    nargs = (char)(*s->macro & ~VARMAC) - 1;
    dots = *s->macro & VARMAC;

    c = getnsc();
    if(c != '(')
        goto bad;
    n = 0;
    c = getc();
    if(c != ')') {
        unget(c);
        l = 0;
        cp = buf;
        ecp = cp + sizeof(buf)-4;
        arg[n++] = cp;
        for(;;) {
            if(cp >= ecp)
                goto toobig;
            c = getc();
            if(c == '"')
                for(;;) {
                    if(cp >= ecp)
                        goto toobig;
                    *cp++ = c;
                    c = getc();
                    if(c == '\\') {
                        *cp++ = c;
                        c = getc();
                        continue;
                    }
                    if(c == '\n')
                        goto bad;
                    if(c == '"')
                        break;
                }
            if(c == '\'')
                for(;;) {
                    if(cp >= ecp)
                        goto toobig;
                    *cp++ = c;
                    c = getc();
                    if(c == '\\') {
                        *cp++ = c;
                        c = getc();
                        continue;
                    }
                    if(c == '\n')
                        goto bad;
                    if(c == '\'')
                        break;
                }
            if(c == '/') {
                c = getc();
                switch(c) {
                case '*':
                    for(;;) {
                        c = getc();
                        if(c == '*') {
                            c = getc();
                            if(c == '/')
                                break;
                        }
                    }
                    *cp++ = ' ';
                    continue;
                case '/':
                    while((c = getc()) != '\n')
                        ;
                    break;
                default:
                    unget(c);
                    c = '/';
                }
            }
            if(l == 0) {
                if(c == ',') {
                    if(n == nargs && dots) {
                        *cp++ = ',';
                        continue;
                    }
                    *cp++ = 0;
                    arg[n++] = cp;
                    if(n > nargs)
                        break;
                    continue;
                }
                if(c == ')')
                    break;
            }
            if(c == '\n')
                c = ' ';
            *cp++ = c;
            if(c == '(')
                l++;
            if(c == ')')
                l--;
        }
        *cp = 0;
    }
    if(n != nargs) {
        yyerror("argument mismatch expanding: %s", s->name);
        *b = 0;
        return;
    }
    cp = s->macro+1;
    for(;;) {
        c = *cp++;
        if(c == '\n')
            c = ' ';
        if(c != '#') {
            *b++ = c;
            if(c == 0)
                break;
            continue;
        }
        c = *cp++;
        if(c == 0)
            goto bad;
        if(c == '#') {
            *b++ = c;
            continue;
        }
        c -= 'a';
        if(c < 0 || c >= n)
            continue;
        strcpy(b, arg[c]);
        b += strlen(arg[c]);
    }
    *b = 0;
    if(debug['m'])
        print("#expand %s %s\n", s->name, ob);
    return;

bad:
    yyerror("syntax in macro expansion: %s", s->name);
    *b = 0;
    return;

toobig:
    yyerror("too much text in macro expansion: %s", s->name);
    *b = 0;
}
@
% wow complicated again

\section{[[#undef]]}

<<function macund>>=
void
macund(void)
{
    Sym *s;

    s = getsym();
    macend();
    if(s == S) {
        yyerror("syntax in #undef");
        return;
    }
    s->macro = nil;
}
@

\section{[[#ifdef]]}

% 0 = ifdef, 1 = ifndef, 2 = else, see mactab and domacro
<<function macif>>=
void
macif(int f)
{
    int c, l;
    bool bol;
    Sym *s;

    if(f == 2)
        goto skip;
    s = getsym();
    if(s == S)
        goto bad;
    if(getcom() != '\n')
        goto bad;
    if((s->macro != nil) ^ f)
        return;

skip:
    bol = true;
    l = 0;
    for(;;) {
        c = getc();
        if(c != '#') {
            if(!isspace(c))
                bol = false;
            if(c == '\n')
                bol = true;
            continue;
        }
        if(!bol)
            continue;
        s = getsym();
        if(s == S)
            continue;
        if(strcmp(s->name, "endif") == 0) {
            if(l) {
                l--;
                continue;
            }
            macend();
            return;
        }
        if(strcmp(s->name, "ifdef") == 0 || strcmp(s->name, "ifndef") == 0) {
            l++;
            continue;
        }
        if(l == 0 && f != 2 && strcmp(s->name, "else") == 0) {
            macend();
            return;
        }
    }

bad:
    yyerror("syntax in #if(n)def");
    macend();
}
@

\section{[[#pragma]]}

% effect of #pragma lib in .s ??

<<[[macprag()]] locals>>=
Sym *s;
@

<<function macprag>>=
void
macprag(void)
{
    <<[[macprag()]] locals>>

    s = getsym();

    <<[[macprag()]] if pragma lib>>
    else {
        while(getnsc() != '\n')
            ;
        return;
    }
}
@


% most pragma seems to be discarded here, except #pragma lib, so
% I removed then (could have aslo simplified by calling prag_do_nothing()).
% it is because the code was shared with cc before I think and the compilers
% had different pragxxx functions with an actual body.
%
%    if(s && strcmp(s->name, "pack") == 0) {
%        pragpack();
%        return;
%    }
%    if(s && strcmp(s->name, "fpround") == 0) {
%        pragfpround();
%        return;
%    }
%    if(s && strcmp(s->name, "profile") == 0) {
%        pragprofile();
%        return;
%    }
%    if(s && strcmp(s->name, "varargck") == 0) {
%        pragvararg();
%        return;
%    }
%    if(s && strcmp(s->name, "incomplete") == 0) {
%        pragincomplete();
%        return;
%    }
%
%old:
%<<function pragpack>>=
%void
%pragpack(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@
%
%<<function pragvararg>>=
%void
%pragvararg(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@
%
%<<function pragfpround>>=
%void
%pragfpround(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@
%
%<<function pragprofile>>=
%void
%pragprofile(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@
%
%<<function pragincomplete>>=
%void
%pragincomplete(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@


\section{[[#line]]}

<<function maclin>>=
void
maclin(void)
{
    char *cp;
    int c;
    long n;

    n = getnsn();
    c = getc();
    if(n < 0)
        goto bad;

    for(;;) {
        if(c == ' ' || c == '\t') {
            c = getc();
            continue;
        }
        if(c == '"')
            break;
        if(c == '\n') {
            strcpy(symb, "<noname>");
            goto nn;
        }
        goto bad;
    }
    cp = symb;
    for(;;) {
        c = getc();
        if(c == '"')
            break;
        *cp++ = c;
    }
    *cp = 0;
    c = getcom();
    if(c != '\n')
        goto bad;

nn:
    c = strlen(symb) + 1;
    while(c & 3)
        c++;

    cp = malloc(c);
    memcpy(cp, symb, c);

    linehist(cp, n);
    return;

bad:
    unget(c);
    yyerror("syntax in #line");
    macend();
}
@

% could move with the other getxxx()
<<function getnsn>>=
long
getnsn(void)
{
    long n;
    int c;

    c = getnsc();
    if(c < '0' || c > '9')
        return -1;
    n = 0;
    while(c >= '0' && c <= '9') {
        n = n*10 + c-'0';
        c = getc();
    }
    unget(c);
    return n;
}
@


\section{[[getxxx()]]}

% from now on those functions are actually used by the preprocessing
% code, not by the basic lexer (yylex) that actually implement
% his own getnsc(), getcom(), getsym() via cases
% (hmmm maybe could factorize things?)

\subsection{[[getc()]], [[unget()]], [[getnsc()]]}


% helpers for other functions

% getc() is presented before


% what if had already a peekc? because called unget 2 times?
% should raise Impossible!
<<function unget>>=
void
unget(int c)
{
    peekc = c;
    if(c == '\n')
        lineno--;
}
@

% get non space char (they really like short cryptic names)
<<function getnsc>>=
int
getnsc(void)
{
    int c;

    for(;;) {
        c = getc();
        if(!isspace(c) || c == '\n')
            return c;
    }
}
@



\subsection{[[getsym()]]}
% mv with Keywords and identifier section?

<<function getsym>>=
Sym*
getsym(void)
{
    int c;
    char *cp;

    c = getnsc();
    if(!isalpha(c) && c != '_' && c < Runeself) {
        unget(c);
        return S;
    }
    for(cp = symb;;) {
        if(cp <= symb+NSYMB-4)
            *cp++ = c;
        c = getc();
        if(isalnum(c) || c == '_' || c >= Runeself)
            continue;
        unget(c);
        break;
    }
    *cp = '\0';
    if(cp > symb+NSYMB-4)
        yyerror("symbol too large: %s", symb);
    return lookup();
}
@
% seen getc before

\subsection{[[getcom()]]}
% mv with Comments section above?

<<function getcom>>=
int
getcom(void)
{
    int c;

    for(;;) {
        c = getnsc();
        if(c != '/')
            break;
        c = getc();
        if(c == '/') {
            while(c != '\n')
                c = getc();
            break;
        }
        if(c != '*')
            break;
        c = getc();
        for(;;) {
            if(c == '*') {
                c = getc();
                if(c != '/')
                    continue;
                c = getc();
                break;
            }
            if(c == '\n') {
                yyerror("comment across newline");
                break;
            }
            c = getc();
        }
        if(c == '\n')
            break;
    }
    return c;
}
@





\chapter{Parsing}
\label{chap:parsing}

In this chapter we present the Yacc {\em grammar} of Asm5,
the ARM assembly language supported by [[5a]].
Yacc generates from this grammar the [[yyparse()]] parsing function
which is called by [[assemble()]] and which internally
calls [[yylex()]].
%
We assume you know how to read a Yacc grammar, otherwise read~\cite{lexyacc}
(you can also read the original Yacc paper at [[generators/docs/yacc.pdf]]
in our \plan repository, or read our \book{Code Generators} to fully
understand how Yacc works).

\section{Overview}

Here is the outline of the Yacc grammar file for Asm5:

<<5a/a.y>>=
%{
#include "a.h"
%}
<<union declaration(arm)>>
<<priority and associativity declarations>>
<<token declarations(arm)>>
<<type declarations(arm)>>
%%
<<grammar(arm)>>
@
%$
\n classic Yacc

The [[%union]] and [[%token]] {directives} have been
already described in Section~\ref{sec:token}.
The [[%type]] declarations will be described gradually in this chapter. 
The priority declarations are used only for the constant
expressions (an advanced Asm5 feature) and will be described in
Section~\ref{sec:constant-expr}.

The grammar part at the end is the most important one.
It contains the different parsing {\em rules}
which will be presented gradually in this chapter:
\n and also some in other features chapter

<<grammar(arm)>>=
<<prog rule(arm)>>
<<line rule(arm)>>
<<inst rule(arm)>>
<<operand rules(arm)>>
<<cond rule(arm)>>

<<constant expression rules>>
<<float rules>>

<<helper rules(arm)>>
<<opt rules>>
<<misc rules>>
@
\l actually not context free; parsing a file modify the kind of toks (LLAB)
\t a bit messy those opt, helper, misc, unify!

Essentially, an assembly program is made of a set lines containing
instructions or labels. Instructions are made of an opcode followed 
possibly by a few operands. Each operand can either be a register, a
constant, a symbol, or certain combinations of the previous elements
(e.g. a register and constant offset forming an address).

More formally, an Asm5 [[prog]]ram is either an empty file or a
set of [[line]]s:
<<prog rule(arm)>>=
prog:
  /* empty */
| prog line
@
\l FIGURE with derivation where see set of lines?

A [[line]] can be an [[inst]]ruction followed by a semicolon
(remember that the lexer transforms newlines in semicolons
as explained in Section~\ref{sec:semicolon}):
\l so can either pack in one line with ';' or use newline (haskell spirit :) )

<<line rule(arm)>>=
line:
  inst ';'
@

It can also be empty, or contain the special [[error]] Yacc
token used for error recovery (see~\cite{lexyacc}):
\l to got until next ; (that is newline)?

<<line rule(arm)>>=
| ';'
| error ';'
@

In the following section we will focus on the [[inst]]ruction
rule and see the different opcodes of Asm5.
In Section~\ref{sec:label-def} we will see that a line
can also contain label definitions.
Then, in Section~\ref{sec:operands-grammar} we will focus on the
operands of Asm5. 
We will then explore a few advanced features of Asm5.
%compiler:
While presenting the syntax for the different features of Asm5
in this chapter, we will also try to discuss how those features can be used
to implement higher-level constructs of languages such as C.
\l which will also help to understand them, why they are useful,when to use them
We will conclude this chapter by discussing the generated code
for [[yyparse()]] by Yacc.

\section{Instructions}

Most instructions of Asm5 correspond to machine instructions
of the ARM described in the \book{Emulator}, and can be
grouped in the same categories: 
arithmetic and logic, 
memory,
control flow, and 
software interrupt.
To fully understand the semantics of those Asm5 instructions read
the \book{Emulator}.

%from http://www.vpri.org/pdf/rn2010001_programm.pdf
%a typical cpu can do a few things pretty quickly:
% - fetch, fetch[i], store, store[i]
% - +,-,*,/
% - =, <
% - and, or
% - shift
% - jump, if ... jump, jump-linked

\subsection{Arithmetic and logic}

%turing: fundamental!

\subsubsection{Logic}

Here are the {bitwise} {boolean logic} opcodes of Asm5,
which are enumeration cases of the [[Opcode]] type
overviewed in Section~\ref{sec:opcode}:

<<[[Opcode]] cases, logic opcodes>>=
AAND,
AORR,
AEOR, // aka XOR
@
\n not exactly the ARM order, e.g. I prefer to put closer AAND and AORR

Their ``reading syntax'' are described via entries in [[itab]]
presented in Section~\ref{sec:token} (those entries populate
the symbol table [[hash]] as explained in Section~\ref{sec:sym}):

<<[[itab]] elements>>=
"AND",		LARITH,	AAND,
"ORR",		LARITH,	AORR,
"EOR",		LARITH,	AEOR,
@

The logic instructions take either 2 or 3 operands,
mostly registers. Usually the first two operands are combined
and the result stored in the third operand.
Here are some examples:
\begin{verbatim}
AND $0x0f, R1, R2 // R2 = R1 & 0x0f;
ORR $0xff, R2     // <=> ORR $0xff, R2, R2
\end{verbatim}
%$
\l left-to-right
\l if middle register is NONE then ADD X1, X2 -> ADD X1, X2, X2 (plus=)

Logic instructions have the same syntax than
arithmetic instructions in Asm5 and so they share 
the same grammar rule:

<<inst rule(arm)>>=
inst:
/*
 * AND/ORR/ADD/SUB/...
 */
  LARITH cond imsr ',' regi ',' reg { outcode($1, $2, &$3, $5, &$7); }
| LARITH cond imsr ',' reg          { outcode($1, $2, &$3, R_NONE, &$5); }
@
%$
%old:| LARITH cond imsr ',' spreg ','   { outcode($1, $2, &$3, $5, &nullgen); }
%old: spreg -> regi
\l arith operator of Machine.nw, but also SLL, SRL,   DIV, MOD, ...

The \$$n$ Yacc notation, in the {\em actions} between braces, 
gives access to the {\em value} of the nth {terminal} or 
{non-terminal} in the rule.
For terminals, this value is derived from the global [[yylval]]
set by the lexer.
\l how manage multiple values then at the same time? array ? see \book{Yacc}
Here are the different values for the different elements
in the first rule of [[inst]] above:

\begin{enumerate}
\item [[LARITH]] is the {token code} for all arithmetic and logic mnemonics.
\$1 contains the enumeration value of the corresponding opcode,
for instance [[AAND]] if the lexed token was [["AND"]]
(see the [[itab]] entries above)

\item [[cond]] represents the {\em conditional execution} of an instruction.
It is an ARM feature we will explain later in Section~\ref{sec:cond-exec}.
Every Asm5 instruction rules have a non-terminal [[cond]] after
the opcode.

\item [[imsr]] is a shortand for: 
[[im]]mediate (constant) or 
[[s]]hifted-register or 
[[r]]egister. 
Those are operands we will describe
in Section~\ref{sec:imsr}. \$3 is of type [[Gen]], the
generalized form of operand we described in Section~\ref{sec:operand}.

\item the first comma, a single-character token without
any value
\l or ascii code?

\item [[regi]] is a register. \$5
%\footnote{\$4 corresponds to the comma preceding [[regi]]}
is an integer representing the register, e.g. 10 for [[R10]].

\item the second comma

\item [[reg]] is also a register but wrapped
in a [[Gen]]. We use a [[Gen]] for \$7 and an integer
for \$5 because of the signature of [[outcode()]]
described in Section~\ref{sec:outcode-signature}.
Indeed, when an ARM instruction have 3 operands, the middle one 
is always a register, so an integer is enough for the fourth
argument to [[outcode()]].

\end{enumerate}

Note that almost all operands above are registers, except 
the first one which can also be a constant or a shifted register.
There is no memory reference. Indeed, the ARM is a RISC machine
where memory references are restricted only to the LOAD and STORE
operations (unified in the [[MOV]] virtual instruction in Asm5),
which we will see later.
\l Von Newmann bottleneck
 
%compiler:
The three opcodes in this section have a direct correspondance
with the following C operators: [[&]], [[|]], and [[^]].
They can also be used to encode boolean expressions
involving [[&&]] and [[||]].
\t how NOT? MVN?
Those logic operators are useful in many contexts:
complex conditions in [[if]] and [[while]] statements ([[if(e1 && e2)]]),
boolean variables ([[bool b = b1 || b2;]]),
bitsets operations ([[set1 | set2]]),
bit extraction ([[x & 0x4]]),
bitmask ([[y & 0xff]]), 
etc.
\t say that 32 bitwise boolean logic? truth table?
\t to explain AAND we give corresponce to C, but then in C we do the opposite
\t  and in the emulator we use C, so never have a final semantic :(
%self-ref:
Those operators are heavily used in the \book{Emulator}. Indeed,
managing the binary format of ARM instructions requires many bit
manipulations.

%turing:
Boolean logic is at the foundation of mathematics and
so it is also logic (no pun intended) to have boolean opcodes
as fundamental opcodes of the computer
\footnote{In fact, a whole computer can be made using just the 
Nand logic gate~\cite{tecs}}.
\l vs turing? von newmann? they assume basic math lang which is logic and arith

\subsubsection{Add/sub}

Basic arithmetic is also fundamental to have in a computer:

<<[[Opcode]] cases, add/sub opcodes>>=
AADD,
ASUB,
@
<<[[itab]] elements>>=
"ADD",		LARITH,	AADD,
"SUB",		LARITH,	ASUB,
@

As said in the previous section,
arithmetic instructions have the same syntax than
logic instructions in Asm5 and so use the same grammar rule
involving the [[LARITH]] token code.


%compiler: 
Again, The two opcodes above have a direct correspondance
with C operators: [[+]] and [[-]].
\l which are used heavily for instance in numerical algorithms.
\t overflow? signed vs unsigned?
%
%The C compiler uses also arithmetic opcodes to encode many things.
%For instance, access to the field of a structure, e.g. [[x->fld]],
%is usually encoded as a memory reference with a base ([[x]])
%and an offset which is the location of the field in the structure.
\l for x->fld, but can do MOV for that
%turing: fundamental arith in turing machine language

% see also Comparison section, part of Arith opcode in Machine.nw




\subsubsection{Mul/div/mod}

%compiler:
The three opcodes below are in direct correspondance
with the following C operators: [[*]], [[/]], [[%]].

<<[[Opcode]] cases, mul/div/mod opcodes>>=
AMUL,
ADIV, // VIRTUAL, transformed in call to _div
AMOD, // VIRTUAL, transformed in call to _mod
@
<<[[itab]] elements>>=
"MUL",		LARITH, AMUL,
"DIV",		LARITH,	ADIV,
"MOD",		LARITH,	AMOD,
@

The ARM actually has no [[DIV]] or [[MOD]] instruction.
Those virtual instructions are converted by [[5l]] in
calls to assembly functions of the core C library
([[_div()]] and [[_mod()]])
which implement the division and modulo algorithm in software.
\t using other more basic instruction, such as? bit shift??
\l in which file?
% compiler: need also mul for array access, need base + idx * size of entry.
%  for pointer arithmetic in general!




\subsubsection{Bit shift}

%compiler:
The two opcodes below are in direct correspondance
with the following C operators: [[<<]], and [[>>]]:
\l Shift left logic, Shift right logic
\t actually maybe it is ASRA not ASRL!

<<[[Opcode]] cases, bitshift opcodes>>=
ASLL,
ASRL,
@
<<[[itab]] elements>>=
"SLL",		LARITH,	ASLL,
"SRL",		LARITH,	ASRL,
@


The ARM does not really have those opcodes; it does
not use those mnemonics for bit shift operations.
Instead, the ARM has a more general approach to bit shifting:
{\em operands} of many operations ([[AND]], [[SUB]],
etc) can be registers with {\em shift annotations}
as explained later in Section~\ref{sec:shift-register}.
%
The opcodes above are thus translated by [[5l]] in the [[MOV]] ARM
instruction (which confusingly as nothing to do with
the Asm5 virtual instruction [[MOV]] we will see later)
with bitshifted register operands.
\n not really virtual

%self-ref:
Bit shift operations 
%are used in this document for the
%[[MCRR]] macro in Section~\ref{sec:mcrr-macro}, and as we will
%see later in Section~\ref{sec:outcode} when generating
%the (binary) object file. They 
are also heavily used
in the \book{Emulator} because of the binary format of ARM instructions.
\t for what? to extract bit, make bits, etc
\l for MCRR it is assembly code, but for the rest it is in C code. confusing?
%compiler:
\t also useful for multiplication optimisation (when power of 2), but faster?

\ifallcode
<<[[Opcode]] cases, bitshift opcodes>>=
ASRA,
@
<<[[itab]] elements>>=
"SRA",		LARITH,	ASRA,
@
\t arithmetic right shift?? vs logical right shift??
\t actually ASRL is not used by 5c
\fi

\subsubsection{Other opcodes}

There are a few additional Asm5 opcodes related to
arithmetic and logic mimicing ARM instructions,
but they are less useful:

<<[[Opcode]] cases, logic opcodes>>=
ABIC,
@
<<[[itab]] elements>>=
"BIC",		LARITH,	ABIC,
@

<<[[Opcode]] cases, add/sub opcodes>>=
ARSB,
AADC,
ASBC,
ARSC,
@
<<[[itab]] elements>>=
"RSB",		LARITH,	ARSB,
"ADC",		LARITH,	AADC,
"SBC",		LARITH,	ASBC,
"RSC",		LARITH,	ARSC,
@

% optional? not used a single time in arm/*.s, used a bit in 5c/
<<[[Opcode]] cases, add/sub opcodes>>=
AMVN, // MOV negative, but nothing to do with MOVW
@
\l there is also a MOV in 5i, but it has nothing to do with MOVW too
<<[[itab]] elements>>=
"MVN",		LMVN, AMVN,	/* op2 ignored */
@
\t op2 ignored?? then why no simplify rule below?
<<inst rule(arm)>>=
/*
 * MVN
 */
| LMVN cond imsr ',' reg { outcode($1, $2, &$3, R_NONE, &$5); }
@


Many of those opcodes are actually never used in the assembly
code generated by the C compiler [[5c]].
See the \book{Emulator} to learn about their semantics.
%ex: ABIC, AADC, ASBC, ARSC
% ARSB seems used, AMVN too


\subsection{Memory}

%turing: machine is von newman model, memory is everything
% but bottleneck, hence RISC model actually
%compiler: 
% store simple data(int), complex (aggregate), store results, 
% store pointers! need powerful memory assign.

Because the ARM is a RISC machine, all memory references in the ARM
are restricted to mostly two machine instructions: 
\n mostly because of SWAP too below
[[LDR]] which {\em loads} some data from memory into a register, and 
[[STR]] which {\em stores} the content of a register into memory.
In Asm5 those two instructions are unified in the
single virtual instruction [[MOV]].
Another memory instruction [[SWPW]] allows to {\em swap} the content
of a register with the content at a memory address.

\subsubsection{Moves}

[[MOV]]s are converted by [[5l]] in the appropriate
machine instruction depending on the operands:

\begin{verbatim}
MOVW R1, (R2)  // This is a store
MOVW (R2), R1  // This is a load
\end{verbatim}

[[MOV]]s come in different variants, depending on the size
of the memory moved:

\begin{itemize}
\item [[MOVW]] for moving words (4 bytes)
\item [[MOVB]] for moving bytes (1 byte)
\item [[MOVBU]] for moving unsigned bytes (1 byte)
\item [[MOVH]] for moving half words (2 bytes)
\item [[MOVHU]] for moving unsigned half words (2 bytes)
\end{itemize}
\t why unsigned? why care about that in move operations??

Here are the corresponding Asm5 opcodes:

<<[[Opcode]] cases, mov opcodes>>=
AMOVW, // VIRTUAL, transformed in load and store instructions
AMOVB,
AMOVBU,
AMOVH,
AMOVHU,
@
<<[[itab]] elements>>=
"MOVW",		LMOV, AMOVW,
"MOVB",		LMOV, AMOVB,
"MOVBU",	LMOV, AMOVBU,
"MOVH",		LMOV, AMOVH,
"MOVHU",	LMOV, AMOVHU,
@

[[MOV]]s take a new kind of operand, [[gen]], which
is very general (hence the name). [[gen]] accepts
(as we will see later in Section~\ref{sec:operands-grammar})
registers, constants, but also many forms of memory references
such as the indirect with offset addressing mode in [[4(R1)]]:

<<inst rule(arm)>>=
/*
 * MOVW
 */
| LMOV cond gen ',' gen { outcode($1, $2, &$3, R_NONE, &$5); }
@

Note that even if the grammar rule above is very general,
allowing to write things like [[MOVW (R13), 6(R2)]], %$
the linker [[5l]] will actually not accept those instructions
and report an error at linking time.
\l a bit ugly
Indeed, the linker will force the programmer to decompose the preceding
instruction in two simpler instructions,
which are then closer to the [[LDR]] and [[STR]] machine instructions
of the ARM:

\begin{verbatim}
MOVW (R13), R1 // =~ LDR
MOVW R1, 6(R2) // =~ STR
\end{verbatim}

This is why in the [[helloworld.s]] program 
in Section~\ref{sec:hello-program} we wrote code like:
\begin{verbatim}
MOVW $'W', R1        
MOVB R1, 6(R2) // can not write MOVB $'W', 6(R2) directly
MOVW $'o', R1        
MOVB R1, 7(R2) // can not write MOVB $'o', 7(R2) directly
\end{verbatim}

Because [[MOVW]] is anyway a virtual instruction, one could wonder
why the linker, instead of reporting an error,
could not generate automatically the multiple [[LDR]] and [[STR]]
instructions which are needed. 
After all, [[5l]] transforms already certain Asm5 
virtual instructions such as [[DIV]] or [[MOD]]
in multiple machine instructions as we will see in the \book{Linker}.
%
My guess is that even though virtual instructions allow
to abstract certain peculiarities (separate [[LDR]] and [[STR]] instructions),
hide certain optimisations (code generated for leaf functions for [[TEXT]]
and [[RET]]), or
overcome certain limitations (no [[DIV]] and [[MOD]]), 
an assembly language should still try to mimic as closely
as possible the instructions of a machine.
By being forced to decompose and so to write two 
instructions in the example above, it is arguably
easier for the programmer then to evaluate the number of cycles
a procedure will take, or the number of memory references the procedure
performs, by just counting lines.
\l exact? fixed number of cycle in ARM?
\l See optab possibilities for AMOVW in Linker.nw



\subsubsection{Swaps}
\l mv in advanced topics? what I did for Machine.nw?

Memory/register swaps come also in different variants
depending on the size of the memory swapped:

<<[[Opcode]] cases, swap opcodes>>=
ASWPW,
ASWPBU,
@
<<[[itab]] elements>>=
"SWPW",		LSWAP, ASWPW,
"SWPBU",	LSWAP, ASWPBU,
@
\l why only those variants? why not SWPB? SWPH?

<<inst rule(arm)>>=
/*
 * SWAP
 */
| LSWAP cond reg ',' ireg         { outcode($1, $2, &$5, $3.reg, &$3); }
| LSWAP cond ireg ',' reg         { outcode($1, $2, &$3, $5.reg, &$5); }
| LSWAP cond reg ',' ireg ',' reg { outcode($1, $2, &$5, $3.reg, &$7); }
@
%$

The operand [[ireg]] stands for indirect register and
will be described later.
Here are a few examples of swapping instructions:

\begin{verbatim}
SWPW  R1, (R2)
SWPW (R1), R2
SWPW R1, (R2), R3
\end{verbatim}

The point of [[SWPW]] may not be obvious. Why do
we need such an instruction?
[[SWPW]] is very useful though
because the instruction is guaranteed to be {\em atomic} in
the presence of multiple processors in which case
it can be the foundation to build concurrency
primitives. For instance the {\em test-and-set}
function in \plan in [[lib_core/libc/arm/tas.s]] is
using [[SWPW]].
\l x86 XCHG
\l ref to other book?

%compiler: concurrency

\subsection{Control flow}
\n was Branching but better control flow I think

\l have seen arith, memory, but control flow is fundamental

%compiler:
The control flow constructs of Asm5 are in
direct correspondance with C constructs:
inconditional jump with [[goto]],
conditional jump with [[if]],
branch and link with function call and [[return]].

\subsubsection{Jump (inconditional)}

The most basic control flow is the direct jump, called
branch in the ARM, hence the [[B]] below:

<<[[Opcode]] cases, branching opcodes>>=
AB,  // =~ JMP
@
<<[[itab]] elements>>=
"B",		LBRANCH, AB,
@

The operands of a branch are 
an offset to the PC pseudo-register ([[B 4(PC)]]), or 
a label ([[B later]]), via the [[rel]] non-terminal (register or label), or
\l D_BRANCH
a name/symbol ([[B foo(SB)]]) or 
an indirect register ([[B (R3)]]), via [[nireg]] (name or indirect reg):
\l D_OREG

<<inst rule(arm)>>=
/*
 * B/BL
 */
| LBRANCH cond rel   { outcode($1, $2, &nullgen, R_NONE, &$3); }
| LBRANCH cond nireg { outcode($1, $2, &nullgen, R_NONE, &$3); }
@
\l could MOV, modify R15 also?
\t inline nireg here? not used elsewhere

%compiler:
It is easy to implement loops using [[B]].
To not loop infinitely though one needs a way
to escape the loop and jump elsewhere {\em if}
a certain criteria is true.

% compiler: if, while, for, switch, they all rely on the
% very basic building block of jmp, conditional or not (goto xxx, if(yyy))


\subsubsection{Conditional jump and comparisons}
\n was actually part of arithmetic in Machine.nw
% but kinda make sense to put it here instead.

The [[helloworld.s]] program in Section~\ref{sec:hello-program} 
did not contain any conditional jump. 
Indeed, printing [["hello world"]] is too simple; there
was no need for such an instruction. 
In the same way, there was also no need for an [[if]] 
in the corresponding C program.
%turing:
The conditional jump though is a fundamental instruction.
Without it programs would be just long sequence of instructions 
or infinite loops.
\l even BL would not help

The conditional jump instruction is usually preceded
by a {comparison} instruction.
The following opcode allows to ``compare'' two operands in Asm5:

<<[[Opcode]] cases, comparison opcodes>>=
ACMP,
@
<<[[itab]] elements>>=
"CMP",		LCMP,	ACMP,
@
<<inst rule(arm)>>=
/*
 * CMP
 */
| LCMP cond imsr ',' regi { outcode($1, $2, &$3, $5, &nullgen); }
@
%$

Note that despite its name, this instruction does not really 
compare its two operands. Instead, it loads those two operands
in some internal registers of the processor.
Those internal registers can then be used by the instruction
coming just after, the conditional jump, to actually compare
using different {relational operators} those registers
and jump accordingly:

<<[[Opcode]] cases, branching opcodes>>=
/* 
 * Do not reorder or fragment the conditional branch 
 * opcodes, or the predication code will break 
 */ 
// VIRTUAL, AB derivatives with condition code, see 5i/
ABEQ, // ==
ABNE, // !=
ABHS, // >= unsigned
ABLO, // <  unsigned
ABMI,
ABPL,
ABVS,
ABVC,
ABHI, // >  unsigned
ABLS, // <= unsigned
ABGE, // >=
ABLT, // <
ABGT, // >
ABLE, // <=
//ABAL (always) done via AB
//ABNV (never) done via ANOP probably
@
%old: got rid of ABCS and ABCC, seems redundant
% and does not match the ARM convention
% ABCS,//not in 5i/cond, seems equivalent to ABHS
% ABCC,//not in 5i/cond, seems equivalent to ABLO
<<[[itab]] elements>>=
"BEQ",		LBCOND,	ABEQ,
"BNE",		LBCOND,	ABNE,
"BHS",		LBCOND,	ABHS,
"BLO",		LBCOND,	ABLO,
"BMI",		LBCOND,	ABMI,
"BPL",		LBCOND,	ABPL,
"BVS",		LBCOND,	ABVS,
"BVC",		LBCOND,	ABVC,
"BHI",		LBCOND,	ABHI,
"BLS",		LBCOND,	ABLS,
"BGE",		LBCOND,	ABGE,
"BLT",		LBCOND,	ABLT,
"BGT",		LBCOND,	ABGT,
"BLE",		LBCOND,	ABLE,
@
\l but really you need just = and <, rest can be done with inversing, EORR, etc.

<<inst rule(arm)>>=
/*
 * BEQ/...
 */
| LBCOND rel { outcode($1, Always, &nullgen, R_NONE, &$2); }
@
\l no nireg here?
\t unsigned!

Here are an example of a comparison and a conditional jump:

\begin{verbatim}
    CMP $0, R1
    BEQ zero
    B nonzero 
zero:
    // R1 == 0
    ...
nonzero:
    // else
    ...
\end{verbatim}

%compiler:
All the control flow constructs of C ([[if]], [[while]], [[for]], etc)
can be translated in assembly code using simply labels, branchs,
and conditional jumps.

%FIGURE? control flow diagrams translation with edges?
%compiler: if, while, they all need to compare values
% and they need to act on it (see also branching)
% when combine with goto can also do loops



There are a few additional Asm5 opcodes similar to
[[CMP]] mimicing ARM instructions, but they
are less useful. Some of them are not even used by [[5c]]:

<<[[Opcode]] cases, comparison opcodes>>=
ATST,
ATEQ,
ACMN, // CMP negative
@
<<[[itab]] elements>>=
"TST",		LCMP,	ATST,
"TEQ",		LCMP,	ATEQ,
"CMN",		LCMP,	ACMN,
@
\l CMN uses a bit to optimize


\subsubsection{Function call and return}

%turing:
\l turing complete already. CMP and Bxx are enough.
\l no need for function.
\l in fact no really CALL in ARM, just BL, very very basic.
\l call is really jump and stack! especially for recursive calls!
\l convenient functions for soft eng.

<<[[Opcode]] cases, branching opcodes>>=
ABL, // =~ CALL, Branch and Link
@
<<[[itab]] elements>>=
"BL",		LBRANCH, ABL,
@

\l same syntax than for B, but BL label??

<<[[Opcode]] cases, branching opcodes>>=
ARET, // VIRTUAL, transformed in B (R14) or MOV xxx(SP), R15
@
<<[[itab]] elements>>=
"RET",		LRET, ARET,
@
<<inst rule(arm)>>=
/*
 * RET
 */
| LRET cond { outcode($1, $2, &nullgen, R_NONE, &nullgen); }
@
% because of B and BL (and as we will see in 5l STEXT and SLEAF),
% it's convenient to have a general way to return from a procedure
% whether it was a leaf or not. The machine can handle the specifics for us!


\subsection{Software interrupt}
\l aka syscall
\l interrupts and exceptions

The software interrupt instruction is really a form of
jump to a special area setup by the kernel.
% kernel/user! fundamental API of assembly! the bridge!
% open then the door for user process to access real hardware
% (but in supervised mode of course)

\l interrupt table normally?
\l a form of function call (and later a form of RET)

<<[[Opcode]] cases, interrupt opcodes>>=
ASWI, // syscall
@
<<[[itab]] elements>>=
"SWI",		LSWI, ASWI,
@

<<inst rule(arm)>>=
/*
 * SWI
 */
| LSWI cond { outcode($1, $2, &nullgen, R_NONE, &nullgen); }
@
%$
%old: | LTYPE6 cond comma gen { outcode($1, $2, &nullgen, R_NONE, &$4); }
% but not sure it needs an argument in plan9 context,
% and anyway was doing stupid things like SWI 0  in 9syscall/mkfile
% which was weird, at least should be SWI $0
%<<inst rule(arm)>>=
%| LSWI cond gen { outcode($1, $2, &nullgen, R_NONE, &nullgen); }
%@
%%$
%% just so can test things with kencc/5a, ignore actually the last argument
%% otherwise the linker will fail.





<<[[Opcode]] cases, interrupt opcodes>>=
ARFE, // VIRTUAL, return from exception/interrupt, MOVM.IA.S.W (R13), [R15]
@

<<[[itab]] elements>>=
"RFE",		LRET, ARFE,
@
% same grammar rule than RET
% =~ IRET
%in lproc.s 
%	RFE				/* MOVM.IA.S.W (R13), [R15] */



\section{Label definitions and [[pc]]}
\label{sec:label-def}
\n put after Operands? Merge with Code refs? maybe better after Instruction
\n section as it is a kind of instr, and better have all opds in one section

% this is incremented in outcode() after each instruction 
% (except for ADATA and AGLOBL)
% this is set in pinit() to 0
% less: even ATEXT increments PC? hmm maybe simpler that way
<<global pc>>=
long	pc;
@

<<[[pinit]] initialisations>>=
pc = 0;
@

<<line rule(arm)>>=
| LNAME ':'
 {
  $1->type = LLAB;
  $1->value = pc;
 }
  line
@

% not context free grammar! modify lexer behavior from parser.
% similar in C for typedefs. ugly a bit,
<<line rule(arm)>>=
| LLAB ':'
 {
  if($1->value != pc)
   yyerror("redeclaration of %s", $1->name);
  $1->value = pc;
 }
  line
@
%$

% note that labels are different from ATEXT! they are local
% to the file, and so lead to local jmps. no need to relocate
% those names (well actually we relocate them in 5l when
% we put each object one after another, see the 'ipc' local variable)

\section{Operands}
\label{sec:operands-grammar}
\label{sec:imsr}

<<type declarations(arm)>>=
%type   <gen> imsr
@
\l until now no type for inst, because does not return, call outcode.

% this is the rest from the %union
<<union declaration other fields(arm)>>=
Gen    gen;
@
% hmmm maybe confusing to have gen field and Gen type and gen grammar rule?

% reg = register
% imm = immediate
% shift = shifted register or constant

% imsr = immediate or shift or register

% e.g. for first operand of ADD
<<operand rules(arm)>>=
imsr:
  imm
| shift
| reg
@

<<type declarations(arm)>>=
%type   <gen> imm shift reg
@


% better to put gen rule here instead of rule about memory dereference.
% That matches closely at first imsr with reg, ximm and shift.



<<type declarations(arm)>>=
%type   <gen>   gen 
@
% gen? general? 
% arguments to MOV have less restrictions


<<gen rule>>=
gen:
  ximm
| shift
| reg
@
% so close to imsr. close except ximm instead of imm (extended immediate).
% see below.
% and also will see later than the gen rule will grow

<<type declarations(arm)>>=
%type   <gen>   ximm
@




\ifallcode
<<operand rules(arm)>>=
<<gen rule>>
<<spreg rule(arm)>>
<<sreg rule(arm)>>
@
<<misc rules>>=
<<oreg rule>>
@
<<operand rules(arm)>>=
<<ximm rule>>
@
\fi


\subsection{Registers}

%<<operand_kind cases>>=
%D_REG,
%@
% works with Gen structure, as shown below

<<operand rules(arm)>>=
reg:
 regi
 {
  $$ = nullgen;
  $$.type = D_REG;
  $$.reg = $1;
 }
@
%$

% lval but really enum<registr>
<<type declarations(arm)>>=
%type   <lval>  regi regi_nosp
@

<<spreg rule(arm)>>=
regi:
  regi_nosp
@
%old: was called spreg, but prefer regi


<<sreg rule(arm)>>=
regi_nosp:
  LREG
| LR '(' expr ')'
 {
  if($3 < 0 || $3 >= NREG)
      print("register value out of range\n");
  $$ = $3;
 }
@
%$
%old: was called sreg, but prefer regi_nosp
\t s? 
\l expr! see later

<<[[itab]] elements>>=
"R0",		LREG,	0,
"R1",		LREG,	1,
"R2",		LREG,	2,
"R3",		LREG,	3,
"R4",		LREG,	4,
"R5",		LREG,	5,
"R6",		LREG,	6,
"R7",		LREG,	7,
"R8",		LREG,	8,
"R9",		LREG,	9,
"R10",		LREG,	10,
"R11",		LREG,	11,
"R12",		LREG,	12,
"R13",		LREG,	13,
"R14",		LREG,	14,
"R15",		LREG,	15,
@

<<[[itab]] elements>>=
"R",		LR,	0,
@

% note that different from pseudo register!


%XXX
<<spreg rule(arm)>>=
| LSP { $$ = REGSP; }
@
%$
% so here actually we get the real hardware register?!!! messy
% why another one again? in which context we don't accept LSP?
% and also in which context we don't accept LPC?

<<sreg rule(arm)>>=
| LPC { $$ = REGPC; }
@
%$
% but here it's actually hardware rgister??
% why 2 rules? anyway people can use R13 to encode LSP so why
% not have a simple reg rule that allows all those registers directly?

\subsection{Immediate constants}

% of course need constant :)
%turing: 

% con = constant
% prefix with $ (why? ambiguity with what?) to differentiate
% with just con where it's a omem (see section below)

%<<operand_kind cases>>=
%D_CONST,
%@
%in core ds now

<<operand rules(arm)>>=
imm: '$' con
 {
  $$ = nullgen;
  $$.type = D_CONST;
  $$.offset = $2;
 }
@
% offset is bad field name. maybe a union with value would be nice.

% see con section below, essentially static-time integer constants
% (not float, not string)

<<con rule>>=
con:
  LCONST
@

% float constants are in another category, actually they
% are allowed only for ximm and so for MOV and DATA categories.



% this is used for MOV of course, because of gen, but also
% for DATA, WORD
<<ximm rule>>=
ximm:
  '$' con
 {
  $$ = nullgen;
  $$.type = D_CONST;
  $$.offset = $2;
 }
@
% see later the extension, MOV allows more forms of constants
% (e.g. string constants, float constants)



%\subsection{String constants}

%<<operand_kind cases>>=
%D_SCONST,
%@
% string constant

<<ximm rule>>=
| '$' LSCONST
 {
  $$ = nullgen;
  $$.type = D_SCONST;
  memcpy($$.sval, $2, sizeof($$.sval));
 }
@


\subsection{Shifted registers}
\label{sec:shift-register}

% register and constant in some sense
% mv in advanced topics?

<<[[Operand_kind]] cases>>=
D_SHIFT,
@

<<operand rules(arm)>>=
shift:
 regi '<' '<' rcon
 {
  $$ = nullgen;
  $$.type = D_SHIFT;
  $$.offset = $1 | $4 | (0 << 5);
 }
| regi '>' '>' rcon
 {
  $$ = nullgen;
  $$.type = D_SHIFT;
  $$.offset = $1 | $4 | (1 << 5);
 }
| regi '-' '>' rcon
 {
  $$ = nullgen;
  $$.type = D_SHIFT;
  $$.offset = $1 | $4 | (2 << 5);
 }
| regi LAT '>' rcon
 {
  $$ = nullgen;
  $$.type = D_SHIFT;
  $$.offset = $1 | $4 | (3 << 5);
 }
@
\l argh, offset really abused

<<[[itab]] elements>>=
"@",		LAT,	0,
@
% hmm could remove @ from the identifier lexing section,
% so then could just do '@' '>' instead of this indirection


<<type declarations(arm)>>=
%type   <lval>  rcon
@

% rcon, register or constant, spreg = sp or general register
<<helper rules(arm)>>=
rcon:
  regi
 {
  if($$ < 0 || $$ >= NREG)
      print("register value out of range\n");
  $$ = (($1&15) << 8) | (1 << 4);
 }
| con
 {
  if($$ < 0 || $$ >= 32)
      print("shift value out of range\n");
  $$ = ($1&31) << 7;
 }
@
% really does too much work here and close to ARM concrete bits

\subsection{Memory (de)references, pointers}
% indirect addressing?
% was "Memory references"
% arguments to MOVW
% Pointers? or Memory dereference actually? or both :)

% O_REG = offset reg?
%<<operand_kind cases>>=
%D_OREG,
%@
% when do MOV R1, (R2) => means in cell pointer by R2, so
% it's really like *r2 = r1

% offset reg, indirect reg, indirect or offset reg, name indirect reg 
% see section ref manual on different addressing modes

% start of difference with imsr!
<<gen rule>>=
| oreg
@

<<type declarations(arm)>>=
%type   <gen> oreg ioreg ireg nireg 
@

% oreg? offset reg? 
<<oreg rule>>=
oreg:
  ioreg
@

% indirect or offset reg
<<misc rules>>=
ioreg:
  ireg
| con '(' regi_nosp ')'
 {
  $$ = nullgen;
  $$.type = D_OREG;
  $$.reg = $3;
  $$.offset = $1;
 }
@


% ireg? indirect reg? 
% used from ioreg (and so gen), and also specifically from SWAP
<<misc rules>>=
ireg:
 '(' regi ')'
 {
  $$ = nullgen;
  $$.type = D_OREG;
  $$.reg = $2;
  $$.offset = 0;
 }
@
%$




\subsection{Named memory locations, symbols}
% (different from labels, which are just for code refs)


% part of oreg? name is an offset to a reg?
% Actually a name is really a constant offset to a base like LSB!!
% it's implicitly a dereference so foo is really foo(SB); you want
% $foo to get the actual address (and not content)
<<oreg rule>>=
| name
@


% for BL, in addition to rel, can also have nireg
<<misc rules>>=
nireg:
  name
| ireg
@
%$
%old: had a if with nothing in it, weird
%  name
% {
%  $$ = $1;
%  if($1.name != D_EXTERN && $1.name != D_STATIC) {
%  }
% }

% BL ireg means have no idea where it jmps ... can this
% create bugs in 5l that statically tries to find the necessary code?
% well the address of a function should be taken somewhere so
% the function should be considered unless one does really crazy
% magic stuff.





<<type declarations(arm)>>=
%type   <gen>   name 
%type   <lval>  pointer
@
% name is an operand argument for BL (via nireg), but also
% for TEXT, and also for MOV (via oreg)

\ifallcode
<<operand rules(arm)>>=
<<name rule>>
@
\fi


<<name rule>>=
name:
  LNAME offset '(' pointer ')'
 {
  $$ = nullgen;
  $$.type = D_OREG;
  $$.sym = $1;
  $$.symkind = $4;
  $$.offset = $2;
 }
@
%$

% for TEXT foo(SB), ... or GLOBL. Definitions of names.
% and also for references to names, like MOV count(SB), R1
% (to get address of count? no, to get address you need $count(SB))
% no LLAB here!

% (ab)used also in reference to parameters, as in
% MOVL    count+8(FP), CX
% the LNAME here is really just a symbol for debugging help.
%less: actually maybe it's not just that, maybe you can
% then do $count to get the address of this parameter?


% the con (pointer) of 'name:' is not ambiguous with the con (sreg)
% of 'oreg:'? no because pointer != sreg (well even if R12 is actually
% LSB ...)

% hmmm bad name? pointer_basis? but it's true we do '(' pointer ')'
% where we really dereference the pointer (and then add an offset)
<<helper rules(arm)>>=
pointer:
  LSB
| LSP
| LFP
@

<<[[itab]] elements>>=
"SB",		LSB,	D_EXTERN,
"SP",		LSP,	D_AUTO,
"FP",		LFP,	D_PARAM,
@


% can do 
%	BL	div(SB)  so it's SB but it's really a code reference

%<<sym_kind cases>>=
%D_EXTERN, // text/data/bss values (from SB)
%D_AUTO,   // stack values (from SP)
%D_PARAM,  // parameter (from FP)
%@


<<helper rules(arm)>>=
offset:
 /* empty */ { $$ = 0; }
| '+' con    { $$ = $2; }
| '-' con    { $$ = -$2; }
@
%$
%less: rename offset_opt?



%section{Static names?, local names?}

<<name rule>>=
| LNAME '<' '>' offset '(' LSB ')'
 {
  $$ = nullgen;
  $$.type = D_OREG;
  $$.sym = $1;
  $$.symkind = D_STATIC;
  $$.offset = $4;
 }
@
%$

<<sym_kind cases>>=
D_STATIC, // data static variables (from SB)
@

% well this is not really a name ...
<<name rule>>=
| con '(' pointer ')'
 {
  $$ = nullgen;
  $$.type = D_OREG;
  $$.sym = S;
  $$.symkind = $3;
  $$.offset = $1;
 }
@
%$
% could delete that too? hmm no, it's for anonymous params like 4(FP)




<<ximm rule>>=
| '$' name
 {
  $$ = $2;
  $$.type = D_CONST;
 }
@
%old: was $ oreg, but i think it makes more sense to have just '$' name
%less: a special D_ADDR instead of abusing D_CONST?

% a bit confusing that can have gen -> oreg, and also gen -> ximm -> $ oreg
% because MOV support powerful addressing modes? with multiple
% indirections?


\subsection{Code references, labels}
% hmm con(PC) is not really named code

<<[[Operand_kind]] cases>>=
D_BRANCH,
@
%old: /* type */ FOR BRANCH

<<[[itab]] elements>>=
"PC",		LPC,	D_BRANCH,
@

<<type declarations(arm)>>=
%type   <gen>   rel
%type   <lval>  offset
@

% rel = ? relocatable? relative? or simply register or label?
%  argument of B/BL
% Relative because it's labels which are locals to a file and can be
% resolved locally (no need symbols), but at the same time they will
% also need to be relocated when all objects are attached after each
% other
% (and the offset value is actually not relative to the current PC,
% it's an absolute value, so it probably means more relocatable than
% relative in the end)

\ifallcode
<<operand rules(arm)>>=
<<rel rule>>
@
\fi

<<rel rule>>=
rel:
  LLAB offset
 {
  $$ = nullgen;
  $$.type = D_BRANCH;
  $$.sym = $1;
  $$.offset = $1->value + $2;
 }
@
%$
% branch are relative to current PC for ARM, but here
% we deal with more absolute address.

% it's an offset in the sense that it's like a 'LLAB offset (starting_pc)'
% so offset to basis, which should be zero for this assembly
% (and when link will actually be relocated).

% there is also nirel where can use a name instead of a label


% when label is declared later, the symbol table does not know
% yet that it's an LLABL, see section on labels below.
<<rel rule>>=
| LNAME offset
 {
  $$ = nullgen;
  if(pass == 2)
      yyerror("undefined label: %s", $1->name);
  $$.type = D_BRANCH;
  $$.sym = $1;
  $$.offset = $2;
 }
@
%less: if pass == 1 why care about setting the field values?
% anyway outcode will not use the value


<<rel rule>>=
| con '(' LPC ')'
 {
  $$ = nullgen;
  $$.type = D_BRANCH;
  $$.offset = $1 + pc;
 }
@
%$
% here it's virtual register special case
% need that? we have code using relative jmp?
% anyway if do  B 4(PC) it will jump one instruction?




%\subsection{Other forms}

%<<operand_kind cases>>=
%D_OCONST,
%@
%<<ximm rule>>=
%| '$' '*' '$' oreg
% {
%  $$ = $4;
%  $$.type = D_OCONST;
% }
%@
%%$
% seems unused in ARM/*.s


%<<gen rule>>=
%| con
% {
%  $$ = nullgen;
%  $$.type = D_OREG;
%  $$.offset = $1;
% }
%@
%%$
% no $ in front of con here?
% was used in 9syscall for 'SWI 0' but not sure what it meant.
% how can be D_OREG when there are no registers involved.
% I removed the rule, and rewrote calls to SWI to just be SWI

%<<gen rule>>=
%| shift '(' regi ')'
% {
%  $$ = $1;
%  $$.reg = $3;
% }
%@

%<<oreg rule>>=
%| name '(' sreg ')'
% {
%  $$ = $1;
%  $$.type = D_OREG;
%  $$.reg = $3;
% }
%@
% but name already has some (sreg), so what this rule mean?
% foo(PC)(PC) ??
% sreg, so can't use FP here, nor LSB, so only name refering to PC?




\section{Pseudo-instructions}
\label{sec:pseudo}
% aka assembly directives

\subsection{[[TEXT/GLOBL]]}

% declare symbols, names, that other can either call (BL) or 
% access (MOVW).

<<[[Opcode]] cases, pseudo opcodes>>=
ATEXT,
AGLOBL,
@
<<[[itab]] elements>>=
"TEXT",		LDEF, ATEXT,
"GLOBL",	LDEF, AGLOBL,
@
\l it is not really LDEF actually, it's more LDECL

<<inst rule(arm)>>=
/*
 * TEXT/GLOBL
 */
| LDEF name ',' imm         { outcode($1, Always, &$2, R_NONE, &$4); }
| LDEF name ',' con ',' imm { outcode($1, Always, &$2, $4, &$6); }
@
%$
% pseudo-instr are kinda instr, operands too, symbol ref too

% TEXT is for procedures, code symbols, that will go in the TEXT section
% GLOBL is to declare data symbols (globals indeed), that will go in DATA sect

% TEXT foo(SB), 4, $4, semantic for those immediate value? to? 
% - size of the locals to reserve for TEXT
% - size of entity in the case of GLOBL?

% what is the middle con? for attributes? e.g. for NOPROF, DUPOK?
% but then what is 4 for??
% see Section in advanced topics

% the imm can be negative! so SP will be decrememted. This is useful
% for stuff that needs to access the parameter of the enclosing function?

% if look qemu.root.s from data2c result:
% e.g. 
% DATA boot_CONF_outcode+0(SB)/8, $"\z\z\1\353\z\z\213\33"
% ...
% DATA boot_CONF_outcode+67520(SB)/8, $"\1\201\1\z\z\z\z\z"
% GLOBL boot_CONF_outcode+0(SB), $67528
% DATA boot_CONF_outlen+0(SB)/4, $67523
% GLOBL boot_CONF_outlen+0(SB), $4

%real-world:
% in gasm I think it's
% .global foo
% .text
% foo:
%   <adjust SP>

\subsection{[[WORD/DATA]]}

% have not seen that in tutorial

<<[[Opcode]] cases, pseudo opcodes>>=
ADATA,
AWORD,
@
<<[[itab]] elements>>=
"DATA",		LDATA, ADATA,
"WORD",		LWORD, AWORD,
@

<<inst rule(arm)>>=
/*
 * DATA
 */
| LDATA name '/' con ',' ximm { outcode($1, Always, &$2, $4, &$6); }
@
\t ximm! so can reference address of other global! (or even maybe itself?)

% DATA boot_CONF_outlen+0(SB)/4, $67523
% DATA boot_CONF_outcode+0(SB)/8, $"\z\z\1\353\z\z\213\33"
% hmm abuse reg for this constant, ugly. It's for boundaries =~
% local size for this chunk of DATA.

<<inst rule(arm)>>=
/*
 * WORD
 */
| LWORD ximm { outcode($1, Always, &nullgen, R_NONE, &$2); }
@
% kind of anonymous DATA? but used in TEXT so can
% write binary data that cannot be expressed by the assembler?
% no need /con here, it's always 4 (WORD).


\subsection{[[END]]}

<<[[Opcode]] cases, pseudo opcodes>>=
AEND,
@
% not the same than ALAST
<<[[itab]] elements>>=
"END",		LEND, AEND,
@

<<inst rule(arm)>>=
/*
 * END
 */
| LEND { outcode($1, Always, &nullgen, R_NONE, &nullgen); }
@
%$
% also generated in cclean()

%\section{Special instructions}
%\subsection{[[NOP]]}
%\subsection{[[SHL/SHR]]}
%\subsection{[[MOVW/MOVL]]}
%\subsection{[[IMUL]]}


\section{Conditional execution}
\label{sec:cond-exec}

% seen most opcodes have this LTYPExxx cond op1, op2, ...

<<type declarations(arm)>>=
%type   <lval>  cond
@

<<cond rule(arm)>>=
cond:
  /* empty */ { $$ = Always; }
| cond LCOND  { $$ = ($1 & ~C_SCOND) | $2; }
@

<<constant C_SCOND(arm)>>=
/* scond byte */
#define	C_SCOND	((1<<4)-1)
@
% >>

<<[[itab]] elements>>=
".EQ",		LCOND,	0,
".NE",		LCOND,	1,
".CS",		LCOND,	2,
".HS",		LCOND,	2,
".CC",		LCOND,	3,
".LO",		LCOND,	3,
".MI",		LCOND,	4,
".PL",		LCOND,	5,
".VS",		LCOND,	6,
".VC",		LCOND,	7,
".HI",		LCOND,	8,
".LS",		LCOND,	9,
".GE",		LCOND,	10,
".LT",		LCOND,	11,
".GT",		LCOND,	12,
".LE",		LCOND,	13,
".AL",		LCOND,	Always,
@
%//Never = 15

% so BEQ is really B.EQ, but can also have MOV.EQ! ADD.LT, etc.

<<constant Always(arm)>>=
#define    Always 14
@
%less: use COND_ALWAYS now?




\section{[[yyparse()]]}
\label{sec:yyparse}

% have seen no call yo yylex! because it is assumed by convention.
% yyparse generated by yacc, and is calling an yylex someone
% must defined.







\chapter{Object Generation}
\label{chap:generation}

% it's object generation, not machine code generation ... 5l/optab.c does this.
% so see linker book for that.

% Note also that we must output code that will be part of a bigger set.
% An object is really a module, defining symbols and using external symbols.
% So the code we output can be relocated! so need to 
% output information about use of external symbols! 'U'
% (and also information about symbols the module defines! 'T', 'D')

\section{Object format}

% The format is very regular, essentially a list of instructions
% where each instruction is encoded as:
%  - opcode (1 byte)
%  - condition (1 byte)
%  - register (1 byte) (most instrs have at least one register operand)
%    (also abused to encode some symbol attributes, e.g. DUPOK)
%  - line  (4 bytes)
%  - operand1
%  - operand2
%  where the operands depending on the operand_kind can actually have
%  different size. The register above is a kind of operand3.
%
% the operands themselves have a specific format too
%  - operand_kind (D_CONST, D_REG, etc)
%  - register (again) if any
%  - symidx if any (for D_OREG, and also D_CONST (but really D_ADDR))
%  - symkind if any (for the same)
%  - variable size data, nothing for D_REG, offset for D_OREG, 
%    float for D_FLOAT, string for D_SCONST, ...

%TODO: figure!!

% Then spreaded among those instructions are also symbol table
% entries, using a weird scheme
% ANAME: symkind (1 byte), symidx (1 byte), string finished by \0
% (hmm the symkind might be redundant then if it's already listed
%  as part of the operand? no, it's because of the spreaded symbol
%  table scheme)

% the header is really just a set of ANAME and AHISTORY, and
% AHISTORY use the same format than other instructions.

% 5l then read back this format in a simple loop reading one
% instruction at a time and maintaing the symbol table information
% via the ANAME.

\section{Instruction output, [[outcode()]]}
\label{sec:outcode}

% used for all opcodes, even pseudo opcodes.
% very generic form, 3 operands (but many times they
% are equivalent to a None).

% scond is cond bits and also special bits
% less: rename reg to reg3? so less confusing with reg in zaddr?
<<function outcode(arm)>>=
void
outcode(int opcode, int scond,  Gen *g1, int reg, Gen *g2)
{
    <<[[outcode()]] locals>>

    <<[[outcode()]] adjust opcode and scond when opcode is AB>>

    if(pass == 1)
        goto out;

    <<[[outcode()]] st and sf computation, and possible calls to zname>>

    // Instruction serialized format: opcode, cond, optional reg, line, operands
    Bputc(&obuf, opcode);
    Bputc(&obuf, scond);
    Bputc(&obuf, reg);
    Bputc(&obuf, lineno);
    Bputc(&obuf, lineno>>8);
    Bputc(&obuf, lineno>>16);
    Bputc(&obuf, lineno>>24);
    zaddr(g1, sf);
    zaddr(g2, st);

out:
    if(opcode != AGLOBL && opcode != ADATA)
        pc++;
}
@
% skip pc++ for AGLOBL and ADATA because those pseudo ops concern
% the DATA section, not the TEXT section.
% WORD is for the TEXT section too!
%note: I renamed a to opcode

% note that output line number here! useful for debugging information,
% to be ablt to go back from one instruction to the actual code!
% (but lineno after #include expansion, see outhist() section
% later so one can get from lineno to actual file+lineno


<<[[outcode()]] adjust opcode and scond when opcode is AB>>=
/* hack to make B.NE etc. work: turn it into the corresponding conditional*/
if(opcode == AB){
    opcode = bcode[scond&0xf];
    scond = (scond & ~0xf) | Always;
}
@
% so B.NE get translated in BNE. Not that important though,
% again this feature could be removed.

<<global bcode(arm)>>=
static int bcode[] =
{
    ABEQ,
    ABNE,
    ABHS,
    ABLO,
    ABMI,
    ABPL,
    ABVS,
    ABVC,
    ABHI,
    ABLS,
    ABGE,
    ABLT,
    ABGT,
    ABLE,
    AB,
    ANOP,
};
@



\section{Operand output, [[outopd()]]}

% outcode -> <>
% less: rename? out_operand?
% s is index in h[] for symbol involved in the operand?
% or 0 if no symbol involved for this operand?
<<function zaddr(arm)>>=
void
zaddr(Gen *a, int symidx)
{
    <<[[zaddr()]] locals>>

    // operand format: operand kind, register, symidx, symkind, optional offset
    Bputc(&obuf, a->type);
    Bputc(&obuf, a->reg);
    // idx in symbol table, 0 if no symbol involved in the operand
    Bputc(&obuf, symidx);
    // symkind of the symbol, if any
    Bputc(&obuf, a->symkind);

    switch(a->type) {
    <<[[zaddr()]] cases>>
    default:
        print("unknown type %d\n", a->type);
        exits("arg");

    }
}
@

\ifallcode
<<[[zaddr()]] locals>>=
long l;
char *n;
Ieee e;
int i;
@
\fi

<<[[zaddr()]] cases>>=
case D_NONE:
    break;

case D_REG:
case D_PSR:
    break;

case D_CONST:
case D_OREG:
case D_BRANCH:
case D_SHIFT:
    l = a->offset;
    Bputc(&obuf, l);
    Bputc(&obuf, l>>8);
    Bputc(&obuf, l>>16);
    Bputc(&obuf, l>>24);
    break;

case D_SCONST:
    n = a->sval;
    for(i=0; i<NSNAME; i++) {
        Bputc(&obuf, *n);
        n++;
    }
    break;
@

% from 5.out.h and 8.out.h
<<constant NSNAME>>=
#define	NSNAME		8
@


\section{Symbol table, [[h]] and [[ANAME]]}
\label{sec:symbols-out}
%note: we could put Htab in Core DS, h is reset in pinit(), but it's
% really just local to the Output code generation so I think
% it is better to put this DS here I think.

% When an operand involves a symbol, the generated operand code 
% contain an int that is an index in a symbol table! See zaddr().

% the way this symbol table is stored in the object file is a bit
% tricky. They could have put the table at the beginning
% of the file (I think it would have been simpler). Instead
% the symbol table is spreaded in the object file and they use
% a circular array scheme.


% so among all those instructions there are some symbol table
% elements, ANAME.

<<[[Opcode]] cases, pseudo opcodes>>=
ANAME,
@
% could be renamed ASYM

%old: if ANAME is after AHISTORY in 5.out.h then got
% some bugs in ar such as "inconsistent file xxx.5 in libc.a"
%update: maybe it was because the Makefile pb where actually
% libmach was not recompiled?

% outcode -> <>
% for operands involving symbols.
% less: rename? out_symbol_reference?
<<function zname(arm)>>=
void
zname(char *n, int symkind, int symidx)
{

    Bputc(&obuf, ANAME);
    Bputc(&obuf, symkind);	/* type */
    Bputc(&obuf, symidx);	/* sym */
    while(*n) {
        Bputc(&obuf, *n);
        n++;
    }
    Bputc(&obuf, '\0');
}
@
% note that labels do not generate code, they are local to the .o
% and used to compute offsets (pc). TEXT/GLOBL generate symbols defs
% and other opcodes generate symbol uses.

% symidx may seem weird, why need idx if store the symbol entries
% one after the other?


<<struct Htab>>=
struct Htab
{
    // ref<Sym>>
    Sym*	sym;
    //enum<sym_kind>
    short	symkind;
};
@
%old: I rename 'type' to symkind, to avoid confusion with Gen.type.
% Htab is a sliced subset of Sym but just for the symbols 
% (and an array insteaf of a hash)

<<constant NSYM>>=
#define	NSYM	50
@
% limit on number of unresolved external symbols? Nope.
% note: need to be < 256 as currently use Bputc to marshall 
%  symbol indexes in zaddr().


% starts to be used at index 1, as 0 is used as index for none symbol.
<<global h>>=
// array<ref<Sym>>
struct Htab h[NSYM];
@
% why call it h when really it's an array ...

% h is an optimisation to avoid generating too many ANAME? But
% why not a symbol table at the beginning of the file? why spread it?
% because that way can use 1 byte for symbol idx and still have
% infinite possibilities! tricky.

% next free entry in h (actually can be reseted to 1)
<<global symcounter>>=
int	symcounter;
@
%less: why not char instead? like symidx (or better byte)
%old: was called sym, but I renamed it to avoid overloading the sym name
% (as a global, as a field)

<<[[Sym]] identifier fields>>=
// index in h when the Sym is really a symbol, 0 when not a symbol
int	symidx;
@
\label{sec:symidx-sym-field}

%old: was called 'sym', but really it's an index in h, and it was confusing
% to have so many fields called sym already (as well as the global sym)
% char enough??
%old: was char, but in many places they use int for symcounter so I use int
% there too now


<<[[pinit]] initialisations>>=
symcounter = 1;
for(i=0; i<NSYM; i++) {
    h[i].symkind = 0; // N_NONE
    h[i].sym = S;
}
@






<<[[outcode()]] locals>>=
// symbol from, index in h[]
int sf;
// symbol to, index in h[]
int st;
// enum<sym_kind>
int symkind;
Sym *s;
@


% TODO LP split and transform while into if, easier flow
% and also can maybe factorize code?
<<[[outcode()]] st and sf computation, and possible calls to zname>>=
jackpot:

sf = 0;
s = g1->sym;

while(s != S) {
    sf = s->symidx;

    if(sf < 0 || sf >= NSYM)
        sf = 0;

    symkind = g1->symkind;

    // already generated an ANAME for this symbol reference
    if(h[sf].symkind == symkind)
     if(h[sf].sym == s)
        break;

    s->symidx = symcounter;
    h[symcounter].sym = s;
    h[symcounter].symkind = symkind;
    sf = symcounter;
    zname(s->name, symkind, symcounter);

    symcounter++;
    if(symcounter >= NSYM)
        symcounter = 1;
    break;
}

st = 0;
s = g2->sym;

while(s != S) {
    st = s->symidx;

    if(st < 0 || st >= NSYM)
        st = 0;

    symkind = g2->symkind;

    if(h[st].symkind == symkind)
      if(h[st].sym == s)
        break;

    s->symidx = symcounter;
    h[symcounter].sym = s;
    h[symcounter].symkind = symkind;
    st = symcounter;
    zname(s->name, symkind, symcounter);

    symcounter++;
    if(symcounter >= NSYM)
        symcounter = 1;

    if(st == sf)
        goto jackpot;
    break;
}
@
% when jackpot can happen? 
% if the first operand involved for instance a symbol with for index 41
% and that the second operand involves a symbol not
% yet seen and that the next free index turns out to be 41, 
% then h[41].sym will change but sf now points to a wrong entry
% and so you have to recompute sf.
% this is very very subtle (too subtle I think).

% replace by:
%sf = symidx_of_symopt(g1->sym);
%st = symidx_of_symopt(g2->sym);
% if (sf == st && sf != 0 && symcounter actually changed) goto jackpot;
%  (otherwise could loop on MOVW bar(SB), bar(SB)

\section{File and line information, [[outhist()]] and [[AHISTORY]]}
%note: was called Header section, but
% it's not really an header in traditional sense,
% the object could be parsed without those AHISTORY and ANAME I think.
%less: have a Debugging support section? where put lineno of outcode()
% there?

%todo: use 5l -v -W to see those AHISTORY and ANAME; it can help
% debug things

<<[[Opcode]] cases, pseudo opcodes>>=
AHISTORY,
@
% history? because trace history of a line if comes from some #include?

% maybe good to take simplest case where have no #include,
% then what will be the output?


<<sym_kind cases>>=
D_FILE,
@




% main -> assemble -> <> (at begining of pass 2)
<<function outhist(arm)>>=
void
outhist(void)
{
    Gen g;
    Hist *h;
    char *p, *op;
    char *q;
    int n;

    g = nullgen;
    for(h = hist; h != H; h = h->link) {
        p = h->filename;

        <<[[outhist()]] adjust p and op if p is relative filename>>
        <<[[outhist()]] output each path component as an ANAME>>
        g.offset = h->local_line;

        Bputc(&obuf, AHISTORY);
        Bputc(&obuf, Always);
        Bputc(&obuf, 0); // reg, but could be R_NONE actually
        Bputc(&obuf, h->line);
        Bputc(&obuf, h->line>>8);
        Bputc(&obuf, h->line>>16);
        Bputc(&obuf, h->line>>24);
        zaddr(&nullgen, 0);
        zaddr(&g, 0);
    }
}
@
% bug???? g.offset is used? do zaddr(&g, 0) but g.type = D_NONE
% at this point which means the offset will not be used.
% look at linker reading back code, excpect a D_CONST here?
% this code works for 8a, but not for 5a because zaddr() is
% different there.

% remember that output lineno for each instruction!

<<[[outhist()]] adjust p and op if p is relative filename>>=
op = nil;
if(p && p[0] != '/' && h->local_line == 0 && pathname){
    if(pathname[0] == '/'){
        op = p;
        p = pathname;
    }
}
@

<<[[outhist()]] output each path component as an ANAME>>=
while(p) {
    q = strchr(p, '/');
    if(q) {
        n = q-p;
        if(n == 0){
            n = 1;	/* leading "/" */
            *p = '/';
        }
        q++;
    } else {
        n = strlen(p);
        q = nil;
    }

    if(n) {
        Bputc(&obuf, ANAME);
        Bputc(&obuf, D_FILE);	/* type */ // symkind
        Bputc(&obuf, 1);	    /* sym */  // symidx
        Bputc(&obuf, '<');
        Bwrite(&obuf, p, n);
        Bputc(&obuf, '\0');
    }
    p = q;
    if(p == nil && op) {
        p = op;
        op = nil;
    }
}
@
% why print each directory path separately?

\chapter{Debugging Support}
\label{chap:debugging}

% db has access to awesome metadata generated by 8s (and also 8c).

%  main(argv=...) /home/pad/.../main.c called from _main+26 (.../main9.s:12)

% put here the +sp, +xxx locals/params format





\chapter{Other Features}
\label{chap:advanced}

\section{Constant expressions}
\label{sec:constant-expr}

% it's not Fortran, we're making an assembler :)
% so it's constant expressions here!

% a bit tricky because we see AADD, AMUL, AAND,
% which corresponds to C operator, and here we use those
% C operators in the assembler itself.

<<type declarations(arm)>>=
%type   <lval>  con expr 
@

<<con rule>>=
| '-' con      { $$ = -$2; }
| '+' con      { $$ = $2; }
| '~' con      { $$ = ~$2; }
| '(' expr ')' { $$ = $2; }
@
%$

% convenient to have this, when combined with macros it
% can do powerful stuff!



<<priority and associativity declarations>>=
%left   '|'
%left   '^'
%left   '&'
%left   '<' '>'
%left   '+' '-'
%left   '*' '/' '%'
@
% lower in the file = higher priority, earlier = lower priority

<<constant expression rules>>=
<<con rule>>
<<expr rule>>
@

<<expr rule>>=
expr:
  con
| expr '+' expr     { $$ = $1 + $3; }
| expr '-' expr     { $$ = $1 - $3; }
| expr '*' expr     { $$ = $1 * $3; }
| expr '/' expr     { $$ = $1 / $3; }
| expr '%' expr     { $$ = $1 % $3; }
| expr '<' '<' expr { $$ = $1 << $4; }
| expr '>' '>' expr { $$ = $1 >> $4; }
| expr '&' expr     { $$ = $1 & $3; }
| expr '^' expr     { $$ = $1 ^ $3; }
| expr '|' expr     { $$ = $1 | $3; }

@





\section{Symbolic constants}
\n useful, meh cpp can do that too. Was originally called Var, hmm


<<line rule(arm)>>=
| LNAME '=' expr ';'
 {
  $1->type = LVAR;
  $1->value = $3;
 }
| LVAR '=' expr ';'
 {
  if($1->value != $3)
   yyerror("redeclaration of %s", $1->name);
  $1->value = $3;
 }
@

<<con rule>>=
| LVAR         { $$ = $1->value; }
@
%$

\ifallcode
\section{Optional commas}
% the optional ',' why? because asm can ge generated by 5c -S that does
% this. A bit ugly so maybe better to aspectize this.
% actually I removed most of the use of comma for 5a/a.y 
% so maybe could even remove this rule, or keep it
% just for the comment about 5c -S.

<<opt rules>>=
comma:
  /* empty */
| ',' comma
@
\fi


\section{Float instructions and registers}
\label{sec:float}

<<struct ieee>>=
struct	ieee
{
    long	l;	/* contains ls-man	0xffffffff */
    long	h;	/* contains sign	0x80000000
                    exp		0x7ff00000
                    ms-man	0x000fffff */
};
@



<<[[Opcode]] cases, float mov opcodes>>=
AMOVWD,
AMOVWF,
AMOVDW,
AMOVFW,
AMOVFD,
AMOVDF,
AMOVF,
AMOVD,
@

<<[[Opcode]] cases, float arithmetic opcodes>>=
ACMPF,
ACMPD,
AADDF,
AADDD,
ASUBF,
ASUBD,
AMULF,
AMULD,
ADIVF,
ADIVD,
ASQRTF,
ASQRTD,
@

<<[[itab]] elements>>=
"MOVD",		LMOV, AMOVD,
"MOVDF",	LMOV, AMOVDF,
"MOVDW",	LMOV, AMOVDW,
"MOVF",		LMOV, AMOVF,
"MOVFD",	LMOV, AMOVFD,
"MOVFW",	LMOV, AMOVFW,
"MOVWD",	LMOV, AMOVWD,
"MOVWF",	LMOV, AMOVWF,
@

<<[[itab]] elements>>=
"SQRTF",	LMISC, ASQRTF,
"SQRTD",	LMISC, ASQRTD,
"CMPF",		LCMPFLOAT, ACMPF,
"CMPD",		LCMPFLOAT, ACMPD,
"ADDF",		LARITHFLOAT,	AADDF,
"ADDD",		LARITHFLOAT,	AADDD,
"SUBF",		LARITHFLOAT,	ASUBF,
"SUBD",		LARITHFLOAT,	ASUBD,
"MULF",		LARITHFLOAT,	AMULF,
"MULD",		LARITHFLOAT,	AMULD,
"DIVF",		LARITHFLOAT,	ADIVF,
"DIVD",		LARITHFLOAT,	ADIVD,
@

%/*
%    "ABSF",		LMISC, AABSF,
%    "ABSD",		LMISC, AABSD,
%    "NEGF",		LMISC, ANEGF,
%    "NEGD",		LMISC, ANEGD,
%    "SQTF",		LMISC,	ASQTF,
%    "SQTD",		LMISC,	ASQTD,
%    "RNDF",		LMISC,	ARNDF,
%    "RNDD",		LMISC,	ARNDD,
%    "URDF",		LMISC,	AURDF,
%    "URDD",		LMISC,	AURDD,
%    "NRMF",		LMISC,	ANRMF,
%    "NRMD",		LMISC,	ANRMD,
%*/




<<[[itab]] elements>>=
"F",		LF,	0,

"F0",		LFREG,	0,
"F1",		LFREG,	1,
"F2",		LFREG,	2,
"F3",		LFREG,	3,
"F4",		LFREG,	4,
"F5",		LFREG,	5,
"F6",		LFREG,	6,
"F7",		LFREG,	7,
"F8",		LFREG,	8,
"F9",		LFREG,	9,
"F10",		LFREG,	10,
"F11",		LFREG,	11,
"F12",		LFREG,	12,
"F13",		LFREG,	13,
"F14",		LFREG,	14,
"F15",		LFREG,	15,
@


<<[[itab]] elements>>=
"FPSR",		LFCR,	0,
"FPCR",		LFCR,	1,
@

<<enum fregister(arm)>>=
enum fregister {
    FREGRET = 0,
    /* compiler allocates register variables F0 up */
    FREGEXT = 7,
    /* compiler allocates external registers F7 down */
    FREGTMP = 15, // ??

    NFREG = 8,
};
@

% NFREG used by 5c/ in char	reg[NREG+NFREG];
% 8? looks like 16 above



<<inst rule(arm)>>=
/*
 * floating-point coprocessor
 */
| LMISC cond freg ',' freg { outcode($1, $2, &$3, R_NONE, &$5); }
| LARITHFLOAT cond frcon ',' freg { outcode($1, $2, &$3, R_NONE, &$5); }
| LARITHFLOAT cond frcon ',' LFREG ',' freg { outcode($1, $2, &$3, $5, &$7); }
| LCMPFLOAT cond freg ',' freg { outcode($1, $2, &$3, $5.reg, &nullgen); }
@
%$
% LMISC, meh

<<[[Operand_kind]] cases>>=
D_FREG,
D_FPCR,
@
% FPCR is the float pending of D_PSR?
% also FCONST we have seen before in core DS

<<[[zaddr()]] cases>>=
case D_FREG:
case D_FPCR:
    break;
@

<<[[zaddr()]] cases>>=
case D_FCONST:
    ieeedtod(&e, a->dval);
    Bputc(&obuf, e.l);
    Bputc(&obuf, e.l>>8);
    Bputc(&obuf, e.l>>16);
    Bputc(&obuf, e.l>>24);
    Bputc(&obuf, e.h);
    Bputc(&obuf, e.h>>8);
    Bputc(&obuf, e.h>>16);
    Bputc(&obuf, e.h>>24);
    break;
@
% >> >> >> >> >> >> >> >> >>

<<type declarations(arm)>>=
%type <gen> freg fcon frcon
@

% for MOV
<<gen rule>>=
| freg
@

<<ximm rule>>=
| fcon
@

<<float rules>>=
freg:
  LFREG
 {
  $$ = nullgen;
  $$.type = D_FREG;
  $$.reg = $1;
 }
| LF '(' con ')'
 {
  $$ = nullgen;
  $$.type = D_FREG;
  $$.reg = $3;
 }

fcon:
 '$' LFCONST
 {
  $$ = nullgen;
  $$.type = D_FCONST;
  $$.dval = $2;
 }
| '$' '-' LFCONST
 {
  $$ = nullgen;
  $$.type = D_FCONST;
  $$.dval = -$3;
 }

frcon:
  freg
| fcon
@
%$



<<gen rule>>=
| LFCR
 {
  $$ = nullgen;
  $$.type = D_FPCR;
  $$.reg = $1;
 }
@
%$




% ?? -> <>
<<function ieeedtod>>=
void
ieeedtod(Ieee *ieee, double native)
{
    double fr, ho, f;
    int exp;

    if(native < 0) {
        ieeedtod(ieee, -native);
        ieee->h |= 0x80000000L;
        return;
    }
    if(native == 0) {
        ieee->l = 0;
        ieee->h = 0;
        return;
    }
    fr = frexp(native, &exp);
    f = 2097152L;		/* shouldnt use fp constants here */
    fr = modf(fr*f, &ho);
    ieee->h = ho;
    ieee->h &= 0xfffffL;
    ieee->h |= (exp+1022L) << 20;
    f = 65536L;
    fr = modf(fr*f, &ho);
    ieee->l = ho;
    ieee->l <<= 16;
    ieee->l |= (long)(fr*f);
}
@

<<constant FPCHIP(arm)>>=
#define	FPCHIP		true
@
% used only by a small if(FPCHIP) in cinit

\section{Long multiplication instructions}
\n advanced topic, so can also put D_REGREG here

%\subsubsection{Mul long}

<<[[Opcode]] cases, mul/div/mod opcodes>>=
AMULL,
AMULAL,
AMULLU,
AMULALU,
@

<<[[itab]] elements>>=
"MULL",		LMULL, AMULL,
"MULAL",	LMULL, AMULAL,
"MULLU",	LMULL, AMULLU,
"MULALU",	LMULL, AMULALU,
@



% MULL special instruction?
<<inst rule(arm)>>=
/*
 * MULL hi,lo,r1,r2
 */
| LMULL cond reg ',' reg ',' regreg { outcode($1, $2, &$3, $5.reg, &$7); }
@
%$
% ugly $5.reg?

% multiply and accumulate
<<[[Opcode]] cases, mul/div/mod opcodes>>=
AMULA,
@

<<[[itab]] elements>>=
"MULA",		LMULA, AMULA,
@




<<[[Operand_kind]] cases>>=
D_REGREG,
@

<<inst rule(arm)>>=
/*
 * MULA hi,lo,r1,r2
 */
| LMULA cond reg ',' reg ',' reg ',' regi 
 {
  $7.type = D_REGREG;
  $7.offset = $9;
  outcode($1, $2, &$3, $5.reg, &$7);
 }
@
%$
% abuse offset, ADT would be better!




<<type declarations(arm)>>=
%type   <gen>   regreg
@

<<operand rules(arm)>>=
/* for MULL */
regreg:
 '(' regi ',' regi ')'
 {
  $$ = nullgen;
  $$.type = D_REGREG;
  $$.reg = $2;
  $$.offset = $4;
 }
@
% abuse offset again ... grrr



<<[[zaddr()]] cases>>=
case D_REGREG:
    Bputc(&obuf, a->offset);
    break;
@
% abuse offset to represent a register

\section{Multiple registers instructions}

% move many?
<<[[Opcode]] cases, mov opcodes>>=
AMOVM,
@

<<[[itab]] elements>>=
"MOVM",		LMOVM, AMOVM,
@
%in lproc.s 
%	RFE				/* MOVM.IA.S.W (R13), [R15] */

%todo: abuse D_CONST again, why not D_MULTI instead?

<<inst rule(arm)>>=
/*
 * MOVM
 */
| LMOVM cond ioreg ',' '[' reglist ']'
 {
  Gen g;

  g = nullgen;
  g.type = D_CONST;
  g.offset = $6;
  outcode($1, $2, &$3, R_NONE, &g);
 }
| LMOVM cond '[' reglist ']' ',' ioreg
 {
  Gen g;

  g = nullgen;
  g.type = D_CONST;
  g.offset = $4;
  outcode($1, $2, &g, R_NONE, &$7);
 }
@


<<type declarations(arm)>>=
%type   <lval>  reglist
@


<<misc rules>>=
reglist:
  regi           { $$ = 1 << $1; }
| regi '-' regi
 {
  int i;
  $$=0;
  for(i=$1; i<=$3; i++)
      $$ |= 1<<i;
  for(i=$3; i<=$1; i++)
      $$ |= 1<<i;
 }
| regi comma reglist { $$ = (1<<$1) | $3; }
@
%$



%\section{Misc instructions}

% seems dead
%<<[[Opcode]] cases, misc opcodes>>=
%ABX, // ?
%ABXRET, // ?
%@
%<<[[itab]] elements>>=
%"BX",		LTYPEBX,	ABX,
%@
%<<inst rule(arm)>>=
%/*
% * BX
% */
%| LTYPEBX comma ireg { outcode($1, Always, &nullgen, R_NONE, &$3); }
%@

%dead: ADWORD, // ? no reading syntax

% have reading syntax, but not transformed by 5l ... not handled,
%<<[[Opcode]] cases, misc opcodes>>=
%ALDREX,
%ASTREX,
%ALDREXD,
%ASTREXD,
%@
%% LDREX STREX CLREX are arm v7 new instruction according to 5db.c
%% actually they are defined as macros in atom.s:
%%#define	CLREX		WORD	$0xf57ff01f
%%#define	LDREX(a,r)	WORD	$(0xe<<28|0x01900f9f | (a)<<16 | (r)<<12)
%%/* `The order of operands is from left to right in dataflow order' - asm man */
%%#define	STREX(v,a,r)	WORD	$(0xe<<28|0x01800f90 | (a)<<16 | (r)<<12 | (v)<<0)
%
%<<[[itab]] elements>>=
%"LDREX",		LMOV, ALDREX,
%"LDREXD",		LMOV, ALDREXD,
%"STREX",		LSWP, ASTREX,
%"STREXD",		LSWP, ASTREXD,
%@

% from arm.s
%#define ISB	\
%	MOVW	$0, R0; \
%	MCR	CpSC, 0, R0, C(CpCACHE), C(CpCACHEinvi), CpCACHEwait
%
%#define DSB \
%	MOVW	$0, R0; \
%	MCR	CpSC, 0, R0, C(CpCACHE), C(CpCACHEwb), CpCACHEwait
%
%#define	BARRIERS	ISB; DSB
%
%#define MCRR(coproc, op, rd, rn, crm) \
%	WORD $(0xec400000|(rn)<<16|(rd)<<12|(coproc)<<8|(op)<<4|(crm))
%
%#define OKAY \
%	MOVW	$0x7E200028,R2; \
%	MOVW	$0x10000,R3; \
%	MOVW	R3,(R2)

\section{Status register}

% status register, works with MOV but normally it's a special
% ARM load/store instructions: MSR and MRS (here emulated by a single MOV)
% CPSR = ? SPSR = ?
<<[[itab]] elements>>=
"CPSR",		LPSR,	0,
"SPSR",		LPSR,	1,
@
% CPSR is maybe system status register, see l.s where
% do
%	MOVW	$(PsrDirq|PsrDfiq|PsrMsvc), R1
%	MOVW	R1, CPSR


<<[[Operand_kind]] cases>>=
D_PSR,
@
% similar to D_REG really, just with special register, so reg field
% is enum<registr> | enum<status_registr>

<<gen rule>>=
| LPSR
 {
  $$ = nullgen;
  $$.type = D_PSR;
  $$.reg = $1;
 }
@
%$
% Status register? move earlier? 


\section{System instructions and registers}

% Already seen 2 system instructions: SWI and RFE. Here are a few more.

% no Axxx opcode, binary generation directly in action via D_CONST
<<[[itab]] elements>>=
"MCR",		LSYSTEM, 0,
"MRC",		LSYSTEM, 1,
@

<<inst rule(arm)>>=
/*
 * MCR MRC
 */
| LSYSTEM cond con ',' expr ',' regi ',' creg ',' creg oexpr
 {
  Gen g;

  g = nullgen;
  g.type = D_CONST;
  g.offset =
   (0xe << 24) |    /* opcode */
   ($1 << 20) |     /* MCR/MRC */
   ($2 << 28) |     /* scond */
   (($3 & 15) << 8) |   /* coprocessor number */
   (($5 & 7) << 21) |   /* coprocessor operation */
   (($7 & 15) << 12) |  /* arm register */
   (($9 & 15) << 16) |  /* Crn */
   (($11 & 15) << 0) |  /* Crm */
   (($12 & 7) << 5) |   /* coprocessor information */
   (1<<4);          /* must be set */ // opcode component
  outcode(AWORD, Always, &nullgen, R_NONE, &g);
 }
@
% >> >> >> >> >> >> >> >> >> >>

<<type declarations(arm)>>=
%type   <lval>  creg
@

<<misc rules>>=
creg:
  LCREG
| LC '(' expr ')'
 {
  if($3 < 0 || $3 >= NREG)
      print("register value out of range\n");
  $$ = $3;
 }
@
%$

<<[[itab]] elements>>=
"C",		LC,	0,

"C0",		LCREG,	0,
"C1",		LCREG,	1,
"C2",		LCREG,	2,
"C3",		LCREG,	3,
"C4",		LCREG,	4,
"C5",		LCREG,	5,
"C6",		LCREG,	6,
"C7",		LCREG,	7,
"C8",		LCREG,	8,
"C9",		LCREG,	9,
"C10",		LCREG,	10,
"C11",		LCREG,	11,
"C12",		LCREG,	12,
"C13",		LCREG,	13,
"C14",		LCREG,	14,
"C15",		LCREG,	15,
@


<<type declarations(arm)>>=
%type   <lval>  oexpr 
@

% other optional stuff
<<opt rules>>=
/* for MCR */ 
oexpr:
  /* empty */ { $$ = 0; }
| ',' expr    { $$ = $2; }
@
%$




\section{Special bits}
% sign? long? p bit, w bit, ???

<<cond rule(arm)>>=
| cond LS    { $$ = $1 | $2; }
@

<<[[itab]] elements>>=
".U",		LS,	C_UBIT,
".S",		LS,	C_SBIT,
".W",		LS,	C_WBIT,
".P",		LS,	C_PBIT,
@
% .S can be used for arithmetic operations, to set condition code

<<constant C_SBIT(arm)>>=
#define	C_SBIT	(1<<4)
@
% >>

<<constant C_PBIT(arm)>>=
#define	C_PBIT	(1<<5)
@
% >>

<<constant C_WBIT(arm)>>=
#define	C_WBIT	(1<<6)
@
% >> >> >> >> 

<<constant C_UBIT(arm)>>=
#define	C_UBIT	(1<<7)	/* up bit */
@
% >>

% composite
<<[[itab]] elements>>=
".PW",		LS,	C_WBIT|C_PBIT,
".WP",		LS,	C_WBIT|C_PBIT,
@

% composite or alternate form
<<[[itab]] elements>>=
".IBW",		LS,	C_WBIT|C_PBIT|C_UBIT,
".IAW",		LS,	C_WBIT|C_UBIT,
".DBW",		LS,	C_WBIT|C_PBIT,
".DAW",		LS,	C_WBIT,

".IB",		LS,	C_PBIT|C_UBIT,
".IA",		LS,	C_UBIT,
".DB",		LS,	C_PBIT,
".DA",		LS,	0,
@
% some seems redundant like .DB and .P, .U and .IA, etc

% see asm.ps ARM section: "addressing modes are supported by suffixes
% of the instruction, IA = increment after, IB = increment before, ..."
% it can be used only with the MOV instruction

<<constant C_FBIT(arm)>>=
#define	C_FBIT	(1<<7)	/* psr flags-only */
@
% >>

<<[[itab]] elements>>=
".F",		LS,	C_FBIT,
@


\section{Compiler-only pseudo-instructions}

% some of those are not really opcodes, they are entities 
% just at the asm AST level produced internally by 5c.
% they have no reading syntax.

% related to NOP, SHL, MOV, pseudo asm
% that get translated in store/load on some archi.


% only used by 5c
<<[[Opcode]] cases, pseudo opcodes>>=
ACASE,
ABCASE,
@
% BCASE = branch case

% actually they used to have a read syntax, but I didn't see any code
% using them so I commented the code.
%<<[[itab]] elements>>=
%"CASE",		LTYPED, ACASE,
%"BCASE",	LBCOND,	ABCASE,
%@
%<<inst rule(arm)>>=
%/*
% * CASE
% */
%| LTYPED cond reg comma { outcode($1, $2, &$3, R_NONE, &nullgen); }
%@
%$


<<[[Opcode]] cases, mul/div/mod opcodes>>=
AMULU,
ADIVU, // VIRTUAL, transformed to call to _divu
AMODU, // VIRTUAL, transformed to call to _modu
@
% has no reading syntax, generated just in 5c

<<[[Opcode]] cases, pseudo opcodes>>=
ASIGNAME,
@
% for signatures checking, generated just in 5c
% really an extended ANAME with signature information (md5sum of the
% type, which for a structure is a md5sum of all its components, so
% pretty safe)


% not pseudo opcodes but related to compile-only opcodes. Here are other 
% constants defined in 5.out.h that are used only
% in compiler context.
% for 5c! conventions! (not used at all by 5a, but in 5.out.h for other tools)
<<[[Register]] compiler conventions cases>>=
REGRET =	0,
REGARG =	0,
/* compiler allocates R1 up as temps */
/* compiler allocates register variables R2 up */
REGMIN =	2,
REGMAX =	8,
REGEXT =	10, // R9/R10 possible 'extern register xxx;'
/* compiler allocates external registers R10 down */
REGTMP =	11,
@
% hmm regxxx is not really an enum as REGREG = REGARG, but still useful.

%old:    /* used by the loader for thumb code */
%    REGTMPT =		7,
% no REGFP??

\section{Linker-only pseudo-instructions}

<<[[Opcode]] cases, pseudo opcodes>>=
AGOK,
@
% GOK =? God only Knows? speciak mark?
% actually used in both compiler and linker
% but I think it's used only for zprg, and in ldobj it's an error
%less: maybe we could delete it, and just use AXXX or ALAST or ANOP instead.
%old: there was a D_GOK, but it was unused in 5a/5c/5l

% not sure it's linker-only pseudo opciodes, could be also compiler
% specific
<<[[Opcode]] cases, pseudo opcodes>>=
ADYNT,
AINIT,
@
% seems never assigned, maybe not used anymore? seems about
% dynamic loading, alef stuff maybe?
%todo: delete?


% related to linker again, in addition to D_FILE there is:
<<sym_kind cases>>=
D_FILE1, // used by linker only?
@
%todo: delete?

%dead: #define	ALLTHUMBS	(1<<2)

\section{[[TEXT]] attributes}

%Again not an opcode, but related. Where this bit is stored?
%I think in the middle reg of an instruction for opcodes like ATEXT.
%It is used by 5l e.g. to allow override existing symbol.
%I think it's for TEXT and DATA instructions and its reg field
% (that should be unused for TEXT and DATA)
<<constant DUPOK(arm)>>=
#define DUPOK		(1<<1)
@

%less: transform in an enum with DUPOK
% note that it's not used by 5a, used by 5c/5l when have a special #pragma
<<constant NOPROF(arm)>>=
#define NOPROF		(1<<0)
@

\section{[[#pragma lib]] and automagic linking}

% this is very very nice! remove so much headache,
% no need ocamlfind, no need pkg-config, so simple ...

% the object can contain information about which
% lib you want to link with!

% less useful in assembly than in .c, but because anyway it's
% an object file property, it's also in the assembler (that generate
% object files).

<<[[macprag()]] locals>>=
Hist *h;
char *hp;
int c0, c;
@

<<[[macprag()]] if pragma lib>>=
if(s && strcmp(s->name, "lib") == 0) {
    c0 = getnsc();
    if(c0 != '"') {
        c = c0;
        if(c0 != '<')
            goto bad;
        c0 = '>';
    }
    for(hp = symb;;) {
        c = getc();
        if(c == c0)
            break;
        if(c == '\n')
            goto bad;
        *hp++ = c;
    }
    *hp = '\0';
    c = getcom();
    if(c != '\n')
        goto bad;

    /*
     * put pragma-line in as a funny history 
     */
    c = strlen(symb) + 1;
    while(c & 3)
        c++;

    hp = malloc(c);
    memcpy(hp, symb, c);

    h = alloc(sizeof(Hist));
    h->filename = hp;
    h->line = lineno;
    h->local_line = -1; // special mark, ugly

    h->link = H;
    if(ehist == H) {
        hist = h;
        ehist = h;
        return;
    }
    ehist->link = h;
    ehist = h;

    return;

bad:
    unget(c);
    yyerror("syntax in #pragma lib");
    macend();

}
@
%less ugly would be to have object attribute (in addition to
% text/data attributes)


\section{Processing multiple files}

% why need that? people can write mkfiles

<<[[main()]] locals>>=
int nout, nproc, status;
int i, c;
@

<<[[main()]] multiple files handling>>=
if(argc > 1) {
    nproc = 1;
    if(p = getenv("NPROC"))
        nproc = atol(p);	/* */
    c = 0;
    nout = 0;
    for(;;) {
        while(nout < nproc && argc > 0) {
            i = fork();
            if(i < 0) {
                i = mywait(&status);
                if(i < 0)
                    errorexit();
                if(status)
                    c++;
                nout--;
                continue;
            }
            if(i == 0) {
                print("%s:\n", *argv);
                if(assemble(*argv))
                    errorexit();
                exits(0);
            }
            nout++;
            argc--;
            argv++;
        }
        i = mywait(&status);
        if(i < 0) {
            if(c)
                errorexit();
            exits(0);
        }
        if(status)
            c++;
        nout--;
    }
}
@

%\section{Thumb code}
% arg processing: (but then no more generic across 5a/ and 8a/)
%
%    case 't':
%        thechar = 't';
%        thestring = "thumb";
%        break;

\chapter{Conclusion}
\label{chap:conclusion}

% see linker! next book to read, logically.
% indeed trad job of assembler is actually done by linker in plan9.
% some assembler related stuff is in libmach/ and lots in the linker.

% but really assembler, linker, arm emulator are books strongly connected.

%missing features: ORG, but ld can do -Txx

% see compiler
% see disassembler? in debugger?






\appendix

\chapter{Debugging}
\label{chap:debugging-appendix}

% not very powerful debugging options for 5a, mostly stuff
% to debug cpp related issues.
% less: 5l has actually more stuff, with dumpers for Gen, opcode, etc.
% e.g. 5l -v -W is pretty useful as it helps debug the object loading,
% so maybe we could reuse some of this code here.

% ex: 'm', 'f' (256 so can have for each character a boolean value)
<<global debug>>=
bool	debug[256];
@

<<[[main()]] debug initialization>>=
memset(debug, false, sizeof(debug));
@

<<[[main()]] command line processing>>=
default:
    c = ARGC();
    if(c >= 0 || c < sizeof(debug))
        debug[c] = true;
    break;
@

\section{[[5a -m]], macro debugging}
% m for macro

<<[[dodefine()]] debug>>=
if(debug['m'])
    print("#define (-D) %s %s\n", s->name, s->macro+1);
@

<<[[macdef()]] debug>>=
if(debug['m'])
    print("#define %s %s\n", s->name, s->macro+1);
@

\section{[[5a -f]], line information debugging}

<<[[linehist()]] debug>>=
if(debug['f'])
    if(f) {
        if(local_line)
            print("%4ld: %s (#line %d)\n", lineno, f, local_line);
        else
            print("%4ld: %s\n", lineno, f);
    } else
        print("%4ld: <pop>\n", lineno);
@



\chapter{Error Managment}
\label{chap:error}

<<function errorexit>>=
void
errorexit(void)
{

    if(outfile)
        remove(outfile);
    exits("error");
}
@

<<global nerrors>>=
int	nerrors = 0;
@
% used to be initialized in cinit()

<<function yyerror>>=
void
yyerror(char *a, ...)
{
    char buf[200];
    va_list arg;

    /*
     * hack to intercept message from yaccpar
     */
    if(strcmp(a, "syntax error") == 0) {
        yyerror("syntax error, last name: %s", symb);
        return;
    }

    prfile(lineno);

    va_start(arg, a);
    vseprint(buf, buf+sizeof(buf), a, arg);
    va_end(arg);

    print("%s\n", buf);
    nerrors++;
    if(nerrors > 10) {
        print("too many errors\n");
        errorexit();
    }
}
@



\chapter{Utilities}
\label{chap:libc}

\section{Memory managment}
\label{sec:memory}

% same in Linker, not sure why they just don't use malloc?
% to avoid dependencies to libc? for bootstrapping reasons?

<<global hunk>>=
char*	hunk;
@

<<global nhunk>>=
long	nhunk = 0;
@
% used to be set in cinit()

<<global thunk>>=
long	thunk;
@

<<constant NHUNK>>=
#define	NHUNK		10000
@


<<function gethunk>>=
void
gethunk(void)
{
    char *h;
    long nh;

    nh = NHUNK;
    if(thunk >= 10L*NHUNK)
        nh = 10L*NHUNK;

    h = (char*)sbrk(nh);
    if(h == (char*)-1) {
        yyerror("out of memory");
        errorexit();
    }
    hunk = h;
    nhunk = nh;
    thunk += nh;
}
@



<<constant MAXALIGN>>=
#define MAXALIGN 7
@

<<function alloc>>=
/*
 * real allocs
 */
void*
alloc(long n)
{
    void *p;

    while((uintptr)hunk & MAXALIGN) {
        hunk++;
        nhunk--;
    }

    while(nhunk < n)
        gethunk();
    p = hunk;
    nhunk -= n;
    hunk += n;

    return p;
}
@

<<function allocn>>=
void*
allocn(void *p, long on, long n)
{
    void *q;

    q = (uchar*)p + on;
    if(q != hunk || nhunk < n) {

        while(nhunk < on+n)
            gethunk();
        memmove(hunk, p, on);
        p = hunk;
        hunk += on;
        nhunk -= on;

    }
    hunk += n;
    nhunk -= n;
    return p;
}
@


\chapter{Extra Code}

\ifallcode
#include "Assembler_extra.nw"
#include "Assembler_x86.nw"
\fi

%\chapter{Changelog}
%\label{sec:changelog}

\chapter*{Glossary}
\addcontentsline{toc}{chapter}{Glossary}
\label{sec:glossary}

\begin{verbatim}
ISA = Instruction Set Architecture
AST = Abstract Syntax Tree
PC = Program Counter
SP = Stack Pointer
FP = Frame Pointer
SB = Static Base register
BL = Branch and Link
RISC = Reduced Instruction Set Computer
CISC = Complex Instruction Set Computer
ARM  = Akorn Risc Machines
CWD = Current Working Directory
EOF = End Of File
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{chapter}{Index}

%\chapter{References} 
\addcontentsline{toc}{chapter}{References}

\bibliography{../docs/latex/Principia}
\bibliographystyle{plain}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
