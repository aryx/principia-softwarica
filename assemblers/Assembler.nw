\documentclass[12pt, twocolumn, landscape]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosetrue % see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, I changed for the better a few things:
%  - better organization of the code, my TOC is better than the few existing
%    files (which didn't have very good names, and which I even split)
%  - removed deadcode (Ref, imm2, con2, NMACRO, CLAST, isreg, ...)
%  - renamed some enums (as => opcode, <noname> => operand_kind)
%  - reordered opcodes and operand kinds, and cleaned them:
%     * removed opcodes (ADWORD, ABX, ADYNT, AINIT, ...)
%     * removed operand kinds (D_GOK, D_ADDR, D_OCONST, ...)
%  - introduced sym_kind, splitted from operand_kind, for D_EXTERN, D_PARAM, ..
%    and actually later renamed in N_EXTERN, N_PARAM, ...
%  - introduced R_NONE instead of abusing NREG
%  - introduced D_ADDR, split from D_CONST which was abused
%  - factorized more code between ARM and x86 (abusing LP chunks)
%  - refactored the Asm5 (ARM) grammar:
%     * removed a few rules, weird operand forms that were not used anyway,
%       or introducing complexity (regi_nosp), e.g., disallow pseudo reg 
%       in certain places.
%     * removed also optional commas here and there
%     * renamed some grammar rules (spreg -> regi, sreg -> regi_nosp),
%     * inlined and removed intermediate rules not useful anymore: oreg
%  - TODO rename types, clearer, Gen? as Adr? or Operand? (and Gen2? as Prog?)

%thx to 5a in ocaml: 
%  - see that code could be so much simpler, no need so many globals
%  - could be stricter which would simplify things even more
%    (ex: ??)
%  - there are really only 3 kinds of operands: for arith, for mov, for branch
%    (see ast.ml)
%  - outcode must increment pc for TEXT too, because can branch on TEXT
%    and TEXT actually generates code, so if label just after TEXT,
%    it must be a different pc than before TEXT!
%    (saw because while writing resolve() it is more explicit)
%  - understand that need LLAB trick only for the check-redefined-label
%    (because there was no ambiguity in parser_asm.mly without LNAME vs LLAB)
%  - see that LBCOND does not have cond, indeed would not make sense
%  - introduced more files, obj.c, main.c, lookup.c
% things which improved this document thx to assemblers/ocaml: 
%  - many, hard to list

%thx to codemap/codegraph/scheck:
% - factorized code in aa/
% - mv errorexit, alloc, in utils.c instead of lexbody.c, same for gethunk
% - have a main.c instead of putting everything in lex.c

%thx to this manual, better understand assembly and assembler:
% - an object file is really a module: the simplest/lowest-level 
%   module abstraction with code, data, and imported/exported entities
% - calling conventions, they are really that on ARM, conventions, cos
%   BL does not impose anything
% - can finally understand the assembly code in Kernel.nw :) param1+0(FP)
% - the difference betweeen GLOBL and DATA, declaration vs definition
% - assembly directives are actually more linker/loader directives,
%   for instance they configure data for the loader to setup memory
% - bit shift logic vs arith :) and 2 complement subtelities, and no need SLA
%   (but more in Machine.nw)
% - MOVs and signed vs unsigned, again need to fill with leading 1111
% - comparisons such as <= and unsigned
% - swap
% - #line and need to keep included files history
% - format of integers, 2 complements
% - SEMI format of floats, mantisse, exposant, and bit parts
% - TODO -fpic?

%history LP-ization:
% - skeleton, mostly copy paste of Template.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
% - split in chunks (some done automatically)
%    * function, global, struct, enum, constant, macro(actually function)
%    * [[xxx]] other fields, [[xxx]] extra fields
% - read Extra section, identify concepts, first TOC
% - distribute parts of the file before
% - typeify, scheckify
% - aspectify advanced features!
% - add explanations
% - add figures
% => first version (without preprocessor, adv topics, and appendix chapters)

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% ifallcode is used for:
%  - forward decl, func decl, extern decl, #ifdef, pragmas (stuff in Extra.nw)
%  - misc optional syntactic elements (e.g., commas)
%  - grammar literate boilerplate

\begin{document}
%******************************************************************************
% Title
%******************************************************************************
\title{
{\Huge 
Principia Softwarica: The ARM Assembler [[5a]]
}\\
{version 0.5}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}\\
\\
with code from\\
Rob Pike
}

\maketitle 
\l ARMv6 (32 bits) edition?
\n alt: 8a x86 (32 bits) edition, see Assembler_x86.nw
\n Plan9 in core title? meh

%\onecolumn
\hrule
\input{../docs/latex/Copyright}
\input{../docs/latex/CopyrightPlan9}
\hrule
%\twocolumn

\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\tableofcontents
\endgroup

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

The goal of this book is to explain with full details the source code of
an {assembler}.

\section{Motivations}

Why an assembler? 
Because I think you are a better programmer 
if you fully understand how things work under the hood, and 
an assembler is an essential part of any {development toolchain}.
\l which itself is essential
%
Indeed, compilers for higher level languages such as C usually
do not generate directly {machine code} but instead rely
on an assembler (and linker) for their final code-generation step.
\n 5c actually does not really rely on the external assembler 5a
\n but gcc/ocamlopt do generate assembly and call external assembler gas

Even if most programmers very rarely write {assembly} code,
understanding an assembly language, and so also what an assembler does,
is essential to understand low-level fundamental concepts such as 
{binary logic and arithmetic}, {signed and unsigned integers},
{memory operations}, {pointers}, 
{stack processing}, {frames}, or
{software interrupts}.
%
Understanding assembly is also necessary to understand 
what a compiler generates.
%
Moreover, most programmers will need at some point
to look at generated assembly code (or disassembled code)
to optimize code or fix bugs.
\l performance issue (alok), crack software :)
%
Finally, some code, especially in the kernel, can not be written in C
and has to be written in assembly.
\n actually MenuetOS is full OS with GUI, network, all in assembly! hmm.
\t assembly enables to use all machine functions! How you talk to the machine!
%src: design of go assembler https://www.youtube.com/watch?v=KINIAgRpkDA

% why learning assembly still good idea:
%   http://wilsonminesco.com/AssyDefense/
%   http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html



Here are a few questions I hope this book will answer:
\begin{itemize}

\item What is the list of all assembly instructions?
What can a typical computer do?

\item What are the essential features of an assembler? How do those features
help compared to writing directly machine code?

\item What are the most important assembly constructs? How
can they be used to implement high-level constructs in languages
such as C?
\n labels is here, and it's assembly only, it's not in Machine.nw
%compiler:
\t show more output of 5c -S on toy programs

\item How are function calls implemented? What is a ``frame''?
What is a ``frame pointer''? How are recursive functions implemented?
What are ``calling conventions''?
%SEMI except frame pointer
\n subroutine concept was discovered by David Wheeler; not that simple!
\t actually not yet explained ! I need more figures on that in tutorial

\item What does an object file contain? What are the differences
between an object file and an executable?
%SEMI

\item How do the assembler and linker work together?

\end{itemize}
\n try questions more specific to asm, put the rest in Machine.nw (and Linker)
\n binary format? no, in linker book because of \plan approach
\n what is position independent code? not here, it is a linker issue
\l endianess? need to talk a bit when talk about vlong (jarod)

%tags used in this file for different recurring themes:
 %turing: fundamental opcodes
 %arm: ARM specifics not present in other architectures
 %self-ref: opcodes to implement the assembler itself!
 %style: Asm5 conventions (e.g., indentation)
 %compiler: give idea of what 5c does, what 5c needs
 %kernel: for features essential to implement a kernel
 %
 %real-world: to relate to other assemblers
 % (Hennessy and Patterson use sections prefixed with "Real Stuff: ARMv7 ...")
 %ocaml: to give a hint on how rewriting C in OCaml could improve things
 %alt: alternative technique
 %without: how people do things if they dont have the program presented
 %old: for original code I changed to be clearer
 %pad: for code I introduced to be clearer
 %dead: dead code removed
 %toc: %trans: %dup: %example: %chunks:

\t put in conclusion non-trivial adv algo and data structures seen? see comment
%data-structures (beyond list/hashtbl): (actually use hashtbl but not list)
% - AST using enums and tag/union structure (not recursive and a bit chaotic)
%   with "sentinel" for defensive programming (AXXX), 
%   and end marker enum trick (ALAST)
% - symbol table (really hash table)
% - circular/spreaded symbol table with small symbol index (1 byte)
% - stack/tree with flat list and special pop marker (hist)
% - buffer
% - bitsets and lots of bit tricks (abuse though), abuse int also for NONE
% - automata (kinda, by abusing labels and gotos to parse regexps in yylex)

%algorithms (beyond search/sort): (actually use neither search nor sort)
% - lexing with automata (using labels and gotos and switch)
%   and lookahead/peek, and escape management, and EOF
% - preprocessing: macro expansion, and tracing of line origin
% - parsing with grammar and actions.
%   Lexing/parsing is useful in many contexts! There are so many programs
%   requiring some forms of lexing/parsing of data.
%   actually have code for basic arithmetic evaluator, useful Yacc tutorial.
% - def/use link with two-pass classic algorithm (alt: lazy lookup? )
% - serialization/marshalling portable! with fixed encoding, variable-length
%   operands with tag, shared enum and dispatch, so not trivial.


\section{The \plan ARM assembler: [[5a]]}
\label{sec:plan9-assembler}

I will explain in this book the code of the \plan ARM assembler
[[5a]]\footnote{See \url{http://plan9.bell-labs.com/magic/man2html/1/8a}
for the manual page of [[5a]]. Despite its name, this page
covers also [[5a]].},
which contains about 4200 lines of code (LOC).
\n see make loc (or cm -test_loc)
[[5a]] is written in C for the most part.
%%%\footnote{
%%%An OCaml partial port is also shown in Appendix~\ref{chap:5a-ocaml}.
%%%}
The parser of [[5a]] is using also Yacc~\cite{yacc}.
\l cite for C


Like for most books in \principia, I chose a \plan program because
those programs are simple, small, elegant, open source, and they form together
a coherent set.
%
The [[5]] in [[5a]] comes from the \plan's convention to name architectures
with a number or single letter ([[0]] is MIPS, [[5]] is ARM, [[8]] is x86, etc.)
and the [[a]] means assembler.
\n single character, they like that, see also kernel and the #c, #i, etc
\l put in this section the discussions about Asm5 and Asm9?

Like for the other \principia books covering the
{development toolchain}, I chose the ARM architecture~\cite{arm-refman}
variant, in this case of the \plan assembler [[5a]],
and not for instance the x86 variant [[8a]], for
reasons of simplicity. 
Indeed, RISC machines are far simpler than CISC machines. 
Moreover, the availability
under \plan of an ARM emulator (called [[5i]]) helps to understand
the semantics of the assembly instructions used in [[5a]].
\n Using x86 also make it more error prone when want to change things
\n because we would have also to change kencc (e.g., error prone to change
\n the order of asm instructions).

Note that the \plan assembler's output differs slightly from
other traditional assemblers. The {files} generated by [[5a]],
called the {\em object files},
are ARM-specific but they do not contain machine code. Instead,
an object file is essentially the {serialized form} of the 
{abstract syntax tree} of an assembly source. 
\l Ref to later? maybe hard to understand. 
The actual machine code generation is performed by the linker [[5l]]\footnote{
Readers interested in this topic should read instead the \book{Linker}.
}.
%alt: generate machine code
This design leads I think to less code in total (when combining
the code of [[5a]] and [[5l]]), and leads also I think to simpler code.
\l where explain why better? later? or in Linker.nw?
\l  indeed linker anyway need resolve symbol too and gen code too
\l  so lets keep assembler as simple as possible so avoid code duplication
\n a critique of go/plan9 toolchain though, see comment in .tex:
% - http://dtrace.org/blogs/wesolows/2014/12/29/golang-is-trash/
%   with https://news.ycombinator.com/item?id=8815778
%   and http://www.reddit.com/r/programming/comments/2riayd/golang_is_trash/
\l say here Asm5 is not _direct_ representation of underlying ARM machine?

%the design of the Go assembler (sucessor to plan9 assembler)
% https://www.youtube.com/watch?v=KINIAgRpkDA&feature=youtu.be

% Go assembly by example:
% http://davidwong.fr/goasm/


\section{Other assemblers}

Here are a few assemblers that I considered for this book, but
which I ultimately discarded:
\begin{itemize}

\item The GNU Assembler [[gas]], part of the [[binutils]] 
package\furl{https://www.gnu.org/software/binutils/},
is probably the most used open source assembler.
\n everything moved from as86 to gas
It supports many architectures (ARM, x86, etc.)
and can generate object files using different formats (ELF, COFF, etc.).
\l PE, Mach-O
\l also can generate different kind of object format
It is called internally by [[gcc]] and so is indirectly
used to assemble most open source programs.
\l gcc -verbose show call to gas?
\n maybe llvm competes a bit now
However, the code of [[gas]] is very big:
350~000 LOC, which is almost two orders of magnitude
more code than [[5a]].
The whole [[binutils]] package contains
3.4 million LOC (not including the code in the testsuite).
Even the ARM-specific file [[gas/config/tc-arm.c]] has already 25~000 LOC.
\l why so much bigger? (alok)

\item LLVM 
Machine Code\furl{http://blog.llvm.org/2010/04/intro-to-llvm-mc-project.html}
(MC) is a library, part of the LLVM infrastructure,
that translates assembly into machine code. When used by
the [[llvm-mc]] program, the library acts as a regular assembler.
\n llvm-mc foo.s -o foo.o,    also llvm-mc --disassemble
The library is fairly small, 25~000 LOC, but is part of a fairly
large infrastructure, LLVM, which has 1.3 million LOC.

\item NASM\furl{http://www.nasm.us/} is a popular x86 assembler using the Intel
syntax as opposed to [[gas]] (and [[5a]]) which uses the \att syntax.
\t footnote ? boils down to mov src dst vs  mov dst src  (alok)
\l also say each tool have its own minor variations (alok), .text vs TEXT, etc
\l  no standard, arch specific anyway
It is also fairly large with 50~000 LOC.
\n popular on linux especially, but also works on windows and mac
\l YASM a rewrite of NASM

\item AS86\furl{http://v3.sk/~lkundrak/dev86/} 
is an historical assembler used to compile old 
versions of Minix and Linux.
It is an x86 16-bit and 32-bit assembler part of
Bruce Evans's C compiler (BCC).
\l hmm really? see dev86/bin86/README-04 and the note by torvalds from 1994
\l maybe it was used just for the real-mode 16bits boot stuff for linux?
AS86 is also using the Intel syntax. 
Because it can generate 16-bit ``real-mode'' machine code, it is 
still used to compile programs such as boot loaders. 
It is fairly small: 12~500 LOC. 
This includes the machine code generation, a part that is not done by [[5a]]
(but done by [[5l]]). 
\l to be fair LOC of 5l is big, but 5a plus 5l LOC < as86 plus ld86
However, because x86 is a rather
complicated architecture --- the 16-bit/32-bit as well as
the different CPU modes (real-mode, protected-mode, virtual-mode) 
being just a testimony of this complexity ---
I prefer to present instead an ARM assembler.
\l a bit dead, used only by elks project now


\item MMIXAL is an assembler for the MMIX virtual machine, both
designed by Donald Knuth. It is a small and 
very well documented program~\cite{mmixware}.
\n actually not that well, I dont like his style, no structure, no TOC
Its (literate) source is about 3200 LOC, including
the (virtual) machine code-generation part.
However, in \principia I want to restrict myself to programs that can run
on real machines, not on virtual machines such as the MMIX.
\n what about mixal? used in the mdk, smaller? does not matter, not LP probably

\l vasm here?

\n assembler for hack? not included in distro, had to write ourselves!

\end{itemize}

\l lots of other assemblers, see the comment in the .tex
%industry:
% - masm (Microsoft), since 1981
% - tasm (Borland, Turbo assembler)
% - mpw? (Apple)
%history:
% - ??
%other:
% - http://www.compilers.de/vasm.html (also vbcc and vlink)
%   recent fork: http://sun.hasenbraten.de/vasm/, used in amiga tutorial,
%   by Volker something, 47 000 LOC, many archi, some code by Frank Wille
% - fasm, flat assembler (written in assembly, hmmm)
%   https://flatassembler.net/ with even an IDE
%   https://fresh.flatassembler.net/
% - http://metasm.cr0.org/ ?
% - https://github.com/StanfordPL/x64asm contain also linker and
%   can be used as a library
%mini:
% - fbas, use lex and yacc, 720 LOC, but looks really simplified
% - see also hex2c? 
% - mine for hack? but my assemblers/ocaml/ is maybe better, 
%   hack machine language was a bit obscure too
% - https://github.com/trillek-team/computer-toolkit (for space game)
%   a toy asm, linker, and even a toy C compiler, for TR3200 machine
%education:
% - subc-2014 s86, 1400 LOC?
% - pep/8 assembler?
% - web based assembler+debugger, teaching purpose: http://yasp.me/
% - high level assembly, by randall hyde, for this book
%   the art of assembly programming
% - ADK assembler developer toolkit: write your own assembler from scratch! 
%   http://www.plantation-productions.com/Webster/RollYourOwn/index.html
%   but 75 000 LOC hmmm, and written in assembly? (HLA, high-level assembly)
% - racket-based asm: http://pinksquirrellabs.com/blog/2017/05/30/asi64/
%research:
% - piton, a proven assembler in Boyer Moore
% - TAL typed assembly language, 
% - Coq macro assembler
% - https://github.com/yrp604/rappel a REPL for x86 and ARM
%modern:
% - llvm has one? well the IR of llvm is a kind of assembler, but portable
%   MC layer mentioned http://lld.llvm.org/ to compete with assemblers
% - WebAssembly  http://webassembly.org/docs/semantics/
%   https://hacks.mozilla.org/2016/03/a-webassembly-milestone/
%   (reference implem in ocaml :) )
%   https://github.com/WebAssembly/design/blob/master/AstSemantics.md
%   http://v8project.blogspot.com/2016/10/webassembly-browser-preview.html
% - .NET has one? or JIT so different?
%see also http://www.tldp.org/HOWTO/Assembly-HOWTO/other.html

%related: IDE for nasm, masm, gas, fasm
% https://dman95.github.io/SASM/english.html

%emulator teaching assembly by using a game:
%http://spectrum.ieee.org/geek-life/reviews/three-computer-games-that-make-assembly-language-fun

%http://embed.rs/articles/2016/arm-inline-assembly-rust/

%http://savannah.spinellicreations.com//pgubook/ProgrammingGroundUp-1-0-booksize.pdf
%http://patshaughnessy.net/2016/11/26/learning-to-read-x86-assembly-language
%https://sensepost.com/blogstatic/2014/01/SensePost_crash_course_in_x86_assembly-.pdf
%http://www.cs.virginia.edu/~evans/cs216/guides/x86.html


%pro:
\t not as used as binutils. Still, production-quality assembler!
% used in plan9. Used in Go so used to build many services at Google!
% production-quality!
%(\footnote{rewritten since Go X but still}).

\section{Getting started}
\label{sec:getting-started}

To play with [[5a]], you will first need to install
the \plan fork used in \principia. See \urlinstall.
Once installed, you can test [[5a]] under \plan with:

\begin{verbatim}
1   $ cd /tests/5a
2   $ 5a helloworld.s
3   $ 5l helloworld.5 -o hello
4   $ ./hello
5   hello world
6   $
\end{verbatim}

The command in Line~2 {assembles} the very simple [[helloworld.s]]
ARM assembly program and generates the [[helloworld.5]] ARM {object file}.
%
Note that in \plan object files do not use the [[.o]] filename extension.
Instead, an object file for the ARM architecture uses the [[.5]]
filename extension, hence the use of [[helloworld.5]] above.
\n this allows to generate in same dir object for different archi, making it
\n easy to cross compile binaries for different architectures (said later)
\n define object file? partly defined before in motivations. .5? explained later
Line~3 then {links} the object file and generates the final 
ARM binary {executable} [[hello]].
Line~4 {launches} the program, assuming you are under 
an ARM machine (e.g., a Raspberry Pi).
\l ref Raspberry?

Note that it is easy under \plan to {cross compile} from another architecture;
you can use the same commands ([[5a]], [[5l]], etc.).
\l because magic /bin, and also because special .5 convention
To play with [[5a]] under an x86 machine you just need
after the linking step to use the ARM emulator [[5i]]:

\begin{verbatim}
...
4   $ 5i hello
...
\end{verbatim}

See the \book{Emulator} for more information on [[5i]].
\l actually cool cos can be used as an assembly debugger too

\section{Requirements}

Because most of this book is made of C source code, 
you will need a good knowledge of 
the C programming language~\cite{k-r} to understand it.
\l actually quite a view bit manipulation, and C idioms used
To understand Chapter~\ref{chap:parsing}, you will also
need to know Yacc~\cite{lexyacc}.
\l Can read Compiler :) and Generators :) but a bit self reference.

Note that this book is not an introduction to
assembly programming.
I assume you already know one assembly language,
not necessarily the one used by [[5a]] though,
and that you have a basic understanding of 
computer architecture~\cite{patterson}.
%
I assume you are already familiar 
with concepts such as
a {register}, a {stack pointer}, a {program counter},
{memory move}, {jumps},
{labels},
\n {frame pointer}, hmmm maybe not, we can explain in this doc.
etc.
\t if not good reference to learn Assembler? one mention by asl book?
\t recent Hennessy and Patterson!
\l MIPS assembly tutorial, might give some ideas (use spim)?
%  http://programmedlessons.org/AssemblyTutorial/index.html
\l Assembly Programming classic book? once cited by Assembler and Loaders?
% the Art of Assembly Programming
% http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/toc.html
% Also "The Art of Assembly Language 
%
However, I do not assume that you know how an assembler works.
Even if in a few \principia books such as the
\book{Compiler} or \book{Kernel} I assume a knowledge of the concepts
and theory underlying those programs, this is not the case here.
Indeed, there are very few books explaining how an assembler works
(I can cite almost only {\em Assemblers and Loaders}~\cite{asl}),
as opposed to a myriad of books on compilers and kernels.
\l csapp explain assemblers?
\l get inspiration from TOC? read intro?
\t and none to the best of our knowledge showing code (except mmixware)
%We assume you already know most of the theory; this book is here to
%cover the practice.
\n maybe not for this one actually


It is not necessary to know the ARM architecture to
understand this book,
but I recommend to read the \book{Emulator} if you want to fully understand
the semantics of the assembly instructions presented in this book.
%
An alternative is to read the ARM edition~\cite{patterson-arm} of the classic
computer architecture book by Patterson and Hennessy~\cite{patterson}.
\l but ARM64, so different probably

%dup: Windows.nw
If, while reading this book, you have specific questions
on the assembly syntax used in this book or on the interface
of [[5a]],
I suggest you to consult the man page of [[5a]] at [[docs/man/1/8a]]\footnote{
Despite its name, this document covers also [[5a]].
}
in my \plan repository.
%
You can also consult the documentation of
the \plan assemblers~\cite{plan9-assemblers} (available also in 
[[assemblers/docs/asm.pdf]]).
\n 'as' article in unix programmer's manual? meh, seems unrelated to 5a.
\l There are also some extra notes about assemblers related to [[5a]]
\l at \url{https://golang.org/doc/asm} which can be useful.
\n Go used to use the plan9 developer toolchain, made by same authors :)



\section{About this document}
#include "../docs/latex/About.nw"

\section{Copyright}
\input{../docs/latex/CopyrightPlan9Text}


\section{Acknowledgments}

I would like to acknowledge of course the author of
[[5a]], Rob Pike, 
who wrote in some sense most of this book.
\n I think it's Rob pike because he wrote the doc and he also rewrote
\n the Go Assembler so he was probably the original author
%
Thanks also to Pascal Garcia for his comments on earlier
versions of this book.

\t I rewrote the code a bit (maybe quite a bit), e.g., symidx_of_symopt is big
\t  maybe should say it





\chapter{Overview}

%trans:
Before showing the source code of [[5a]] in the following chapters, 
%toc:
I first give an overview in this chapter
of the general principles of an assembler, 
of the assembly language supported by [[5a]],
and of the format of the object files generated by [[5a]].
%
I also define terms, explain how the code is organized, 
and more generally give the background necessary
to understand the code I will show later.

\section{Assembler principles}

An {\em assembler} is a program that translates source code
written in an {assembly} programming language into
{machine code}, or into an {object code} close to machine code.
\l figure? just box with foo.s -> foo.5 and source file and object file subtitle
%
An {\em assembly language} is a low-level programming language mimicking
closely the {instructions} of a machine,
but using a {textual} format rather than the
{binary} format used internally by computers.
This textual format is far more convenient for the programmer.
\n as close as possible but not closer
%
Note that each assembly language is specific to a computer architecture.
\l and in fact even different assembler for same arch use different syntax
\n so it is not portable; C is a portable assembler! Or need meta-assembler.
\t etymology of assembler/assembly? why call that way?

Assembly languages use {\em mnemonics} to denote low-level {instructions}.
%without:
For instance, an assembly programmer can simply use the mnemonic
[[ADD]] in his code instead of having to remember that [[0000100]]
is the binary code to perform an addition in an ARM processor.
\t programmer -> you? also in the following paragraph?


Typical instructions are made of an {\em opcode} and 
one or more {\em operands}.
%
For instance, [[ADD 15, R1, R4]] is a complete assembly instruction 
telling the computer to add fifteen to the first register
and to put the result in the fourth register.
\l again mnemonic too for register names, and actually it's \$15
\n note that cant have ADD R1, 15, R4 because ARM restrictions on ADD
\n also note att syntax, left to right
\t footnote if use left-to-right assignment syntax, known as ATT syntax

A key feature of assemblers is to allow the use of {\em symbolic addresses}
as operands, freeing the programmer from tedious manual calculations.
%
Indeed, in assembly a programmer can {{define}} {\em symbols} designating
certain memory areas (code area or data area)
\n use 'symbols' not 'labels', more general; they are in symbol table of binary
\n put globals or functions, hmm but label make things more general
and he can then {{use}} those symbols as operands.
For instance, the instruction [[B foobar]] allows to {branch} (jump) 
to the code following the [[foobar]] symbol. 
\n actually it is B foobar(SB) in 5a if foobar is a symbol and not a label
%without:
Without symbolic addresses, a programmer
would have instead to write something like [[B 1562]] and make sure
that he calculated correctly that 1562 was the address corresponding
to the thing he wanted to jump to. This would require to know
the size of each instruction, and each further modification of the program
could entail the recalculation of all those addresses.
\n actually jumps are relative in the ARM

To summarize, the main functions of an assembler are typically the following:
\n function almost in a literal way; those phases correspond almost to 5a funcs
\begin{enumerate}

\item {\em Parse} an input textual file

\item {\em Check} that the combinations of opcodes and operands form 
valid machine instructions
\n in 5a actually a few checks are delayed until linking

\item {\em Compute} the concrete values of symbolic addresses
(this usually requires a two-pass algorithm as one can reference symbols
defined later in the file)
\n in 5a actually only labels are resolved, symbols are delayed until linking

\item {\em Generate} the binary machine code
\n again 5a is special here

\end{enumerate}

In fact, most assemblers do not generate the final machine code but instead
generate an {\em object code}, which is mostly machine code but
with extra information about {\em unresolved symbols}.
\n local labels disappear? Yes, they are resolved, but kept for debugging.
%
Indeed, even if for small programs the definitions and uses of symbolic
addresses could be in the same single file, as programs
grow larger, it becomes useful to separate the source in different files.
\l for separation of concern, modularity, libs, reuse, separate compilation, ..
\l but now I do everything in one big file, so maybe can revisit that idea
In this case, you could want to reference in one assembly file
a symbol defined in another file. 
%
This is why the object file
must contain, in addition to machine code, enough information
about the {external} symbols this assembly file is using
(as well as the symbols it defines) so that another tool, the {\em linker},
can later fully {\em resolve} all the symbol references used in 
all the files.
\l So assembler must output symbol table information in the object
\l for the linker to know what to do and where to patch things.
\n asm.pdf use external a lot, but often he means global
%
In essence, an object file is really the simplest form
of a {\em module}; it packs code, data, and information
about {exported} and {imported} entities.
\n but no properties for those entities, so not a real interface

A linker then essentially 
{concatenates} the code (and data) of the multiple object files together,
{resolves} all the symbolic addresses (now that all 
the code and data is available and has been assigned a fixed memory area),
\n in fact can be tricky for variable-sized instructions like in x86,
\n has to make pessimistic guess and it complicates a lot things
{patches} all the incomplete instructions that were using unresolved symbols,
\n actually 5l does not patch machine code really
and finally {generates} the binary executable.
\n Put two assembly file with symbols defined and used, and how resolved
\n and how relocate? No, let that to the linker book.

\t normally big concept in assembler is relocation, but job done
\t by linker in case of plan9 so will not talk much about it
\t WIKIPEDIA relocation?
\t When objects are concatenated together so the branch/jmp addresses
\t need also to be "relocated"; same for references to external symbols

\section{[[5a]] command-line interface}

The command-line interface of the assembler [[5a]] is pretty simple:
\begin{verbatim}
$ 5a
usage: 5a [-options] file.s
$ 5a foo.s
$ 5l foo.5 bar.5 ...
\end{verbatim}

Given an input {assembly file} [[foo.s]], 
[[5a]] outputs an {object file} [[foo.5]].
You can change this default behaviour by using the [[-o <outfile>]] option.
Other options are related to macroprocessing and debugging and will 
be described later.

%real-world:
Object files in other operating systems (e.g., Linux) usually end
with the [[.o]] filename extension. 
%in-plan9:
However, because \plan supports multiple architectures
and makes it very easy to cross-assemble or cross-compile programs,
it is more convenient to use the code of the architecture (here [[5]]
for ARM) as the filename extension of object files.
\l see mkfile and trick with dollarO, that's nice, mk everything!
That way, you can have in the same directory the ARM
object file [[foo.5]] and the x86 object file [[foo.8]] without any 
name conflict. 
%
For assembly programs, the need for different object filename
extensions may not be obvious. Indeed, assembly files are 
architecture specific anyway. However, for C programs, which can be compiled
by [[5c]] or [[8c]], generating different object files
from the same source is very useful.


\l -D -I (cpp),  -f -m for debug
\l env: INCLUDE (for cpp, similar to -I), NPROC (when multi files?)


\section{[[helloworld.s]]}
\label{sec:helloworld}

From now on, I call {\em Asm5} the ARM assembly language supported by [[5a]]. 
%
Because the different \plan assemblers (e.g., [[5a]], [[8a]])
are variations of a single program, the
assembly languages they support are also variations of a single language
I call {\em Asm9}. 
\t meh, maybe AsmPlan9?
You can see Asm5 as a specialized version of Asm9
for the ARM processor.
By understanding Asm5, you will understand also fairly well the assembly
languages supported by the other \plan assemblers (e.g., [[8a]]),
because they have a lot in common.
\n asm is not portable, but cos they have a lot in common, easier a bit to port
\n even more easier thx to the virtual instructions such as MOVW or RET

%toc:
In this section, I will show a simple Asm5 program, [[helloworld.s]],
which prints [[Hello World]] when executed. I will use this
program as a tutorial for Asm5 (and more generally for Asm9).
\n I'd rather not write this tutorial but all existing docs on Asm5 are bad

%http://weeb.ddns.net/0/programming/c_without_standard_library_linux.txt

\subsection{Background}

%trans:
To understand [[helloworld.s]], I must first show
the equivalent program written in C to introduce some background
on how to perform {\em system calls} in \plan.
\l system call em? link to Kernel book?
\n could have a hello.s that you link with libc so easier
\n but I like the idea of really raw simple hello world in assembly!
\n for Linux: http://sysdigcloud.com/fascinating-world-linux-system-calls/

Here is the simplest \plan{} [[hello world]] program written in C:

<<helloworld1.c>>=
#include <u.h>
#include <libc.h>

void main() {
  print("hello world\n");
}
@

This code is using the [[print()]] function from the core C library
(see the \book{Libcore}).
If I expand the code of this function, and simplify things,
I will get this C program:

<<helloworld2.c>>=
#include <u.h>
#include <libc.h>

void main() {
  pwrite(1, "hello world\n", 12, 0);
}
@
\t why pass size to kernel of string? kernel can not use strlen?
\t No! because kernel does not depend on format of string and fact
\t that they are null-character terminated. The kernel manage an abstract
\t series of bytes in files. Not just text files (or text devices).

The [[pwrite()]] function is also defined in the C library,
but it is written in assembly in [[lib_core/libc/9syscall/pwrite.s]].
\n actually it's auto generated by mk from sys.h. 
\t See Appendix!
\l Why p?
[[pwrite()]] is a small wrapper around the ARM instruction 
[[SWI]] (for ``software interrupt''),
which performs a system call (also known as a {\em syscall}).
\l more on this SWI later
%
Here is the prototype of [[pwrite()]] defined in [[include/core/libc.h]]:

<<prototype pwrite in libc.h>>=
extern	long	pwrite(fdt, void*, long, vlong);
@
%old: I introduced fdt typedef

The [[pwrite()]] interface is documented in 
[[docs/man/2/read]]\footnote{
Again, despite its name, this document covers also [[pwrite]].
}.
The parameters are
a {file descriptor} (e.g., [[1]] for the standard output), 
a string pointer, 
the number of bytes to write,
and finally a [[vlong]] seeking offset. 
%
Most of the parameters use 4 bytes on the ARM,
except the [[vlong]] which uses 8 bytes on the ARM.
\l will be important, see later
\l pwrite is the syscall, not write, vlong seek is for protocol atomicity, 2in1

\subsection{The program}
\label{sec:hello-program}

%trans:
You now have enough background to understand partially
the [[helloworld.s]] program below:

<<assemblers/5a/tests/helloworld.s>>=
1 	TEXT _main(SB), $20
2 	        B later
3 	        B loop /* not reached */
4 	later:
5 	        /* fill missing characters for hello */
6 	        MOVW $hello(SB), R2
7 	        MOVW $'W', R1        
8 	        MOVB R1, 6(R2)
9 	        MOVW $'o', R1        
10	        MOVB R1, 7(R2)
11	        MOVW $'r', R1        
12	        MOVB R1, 8(R2)
13	        MOVW $'l', R1        
14	        MOVB R1, 9(R2)
15	        MOVW $'d', R1        
16	        MOVB R1, 10(R2)
17	        MOVW $'\n', R1
18	        MOVB R1, 11(R2)
19	        /* prepare the system call PWRITE(1,&hello,12,0LL) */
20	        MOVW $1, R1
21	        MOVW R1, 4(R13)
22	        MOVW $hello(SB), R1
23	        MOVW R1, 8(R13)
24	        MOVW $12, R1
25	        MOVW R1, 12(R13)
26	        MOVW $0, R1
27	        MOVW R1, 16(R13)
28	        MOVW R1, 20(R13)
29	        MOVW $9 /*PWRITE*/, R0
30	        /* system call */
31	        SWI $0
32	        BL exit(SB)
33	        RET /* not reached */
34	loop:
35	        B loop
36	        
37	
38	TEXT exit(SB), $4
39	        /* prepare the system call EXITS(0) */
40	        MOVW $0, R1
41	        MOVW R1, 4(R13)
42	        MOVW $3 /*EXITS*/, R0
43	        /* system call */
44	        SWI $0
45	        RET /* not reached */
46	        
47	                        
48	GLOBL   hello(SB), $12
49	DATA    hello+0(SB)/6, $"Hello "
50	
@
%$
%coupling: I repeat the last two lines later in DataLayout section!!
\n No libc! Using a simple _main. As simple as possible.
\n But this works only because luck! See bugneedr12.s. We should initialize R12!\n It just happens that dollar.hello(SB) in this file is not immrot() and so
\n  leads to a LCON not a RECON (see 5l) and so is loaded through
\n  a WORD, not via  'ADD offset, R12, R2'. Subtle. Very subtle.
\n _main and exit are normally part of core C library
\l can also maybe show one that use libc, use 5c -S hello.c
\t can do with SP instead of R13 so less leaky abstraction 4(R13)?
\l note that we call PWRITE syscall directly, not pwrite(), subtle


%dup: from intro/getting-started
To assemble, link, and execute this program, simply do
like in Section~\ref{sec:getting-started}:
\begin{verbatim}
$ 5a helloworld.s
$ 5l helloworld.5 -o hello
$ ./hello
hello world
\end{verbatim}
\l if under ARM machine
\l show actual code? echo '$t :c' | 5i hello 
%$
\l show binary format? hexdump? (actually not bin instruction format! see below)
\t instruction to disassemble foo.5? db foo.5? 
\t 5l -v -W so dumper of object file? nm?
%real-world: objdump --disassemble ?

Appendix~\ref{chap:examples} contains more examples of assembly programs.

\subsection{Pseudo instructions}
\label{sec:pseudo-instructions}

The [[helloworld.s]] program above defines three {\em symbols}:
two {procedures}, [[_main()]] and [[exit()]], and one {global}, [[hello]].
%
The two procedures are introduced via the [[TEXT]] 
{\em pseudo instruction} Line~1 and Line~38,
\l why TEXT? why not PROC?
and the global via [[GLOBL]] Line~48.
I say ``pseudo'' (or sometimes ``virtual'') because those
instructions do not match directly a machine instruction.
They are assembly-only constructs, also known as
{\em assembly directives}. Indeed, the ARM processor
has no notion of procedure names; it just manages numbers
and concrete addresses.
\l GLOBL allocate mem, and TEXT actually does magic stuff, so almost virtual

The operands of the pseudo instructions [[TEXT]] and [[GLOBL]]
\n was arguments, but better operands, for uniformity, because they are really
are the name of the {symbol} it defines followed by [[(SB)]],
which I will explain later, and a {\em constant} value prefixed by a dollar.
In Asm9, {\em all constants are prefixed by a dollar}.
\t why? ambiguities? I think it's stupid because easy to make mistake then
\l actually in DATA the size is specified without dollar in .../6, offsets too
\l and MRC also have a few int without dollars
% I was doing MOVW 0, R1 which translates to MOVW 0(R0), R1 (not sure why)
% instead of MOVW $0, R1 and so had some segfaults at 0xc because
% R0 was return value from syscall which was lenght printed = 0xc
%
For [[GLOBL]], the constant value represents the size, in number of
bytes, this global will use. For [[hello]] Line~48 it is [[12]] (enough
to hold the [["hello world\n"]] string).
%
For [[TEXT]], the constant value represents the size, in number of bytes,
this procedure will need for its {\em locals} in the {stack}. 
For [[_main()]] Line~1 it is [[20]] (the
number of bytes needed to hold all the {arguments} in the stack
to the [[PWRITE]] system call: 
\l more on this later, locals and arguments are the same
4 for the file descriptor integer, plus 4 for the string pointer,
plus 4 for the size, plus 8 for the [[vlong]] offset).
\n actually there is an implicit plus 4 as we will see later
\t so arguments are held in the "stack frame" of the caller

As you will see in the \book{Linker}, the linker [[5l]] is looking 
for a procedure named [[_main]] for the entry point of the executable
it generates,
even though the entry point of C programs is [[main]], not [[_main]].
%
This is because the core C library defines a [[_main()]] procedure,
written in assembly, which does some core initializations
and then calls [[main()]] (see the \book{Libcore}).
\t can change entry point, -E, see 5l.
%
In [[helloworld.s]], I do not use and so do not link the C library, 
to simplify the code and the explanations,
\l but in the end meh?
so I must define a [[_main()]] at Line~1.
%, the entry-point procedure 

%real-world: use .text, .data

\subsection{Labels}

The first instruction of [[_main()]], Line 2,
\n actually there is an hidden instruction generated dealing with R14/R13
is a jump, known as a {\em branch} in ARM (hence the [[B]]).
It is a jump to [[later]], a {\em label} defined Line~4.
In Asm9, {\em all label definitions are suffixed by a colon}. 
%
Labels are similar to symbols: They allow to give
a symbolic name to a memory area. However, labels are restricted to code area
and are locals to an assembly file. They are used for
intra-procedural jumps.
\t locals -> private?
\l also not suffixed by SB
\n how actually translated? in absolute (virtual) code address.

Note that the syntax for {comments} Line~3 and Line~5
is the same than in C.


\subsection{Assignments}

Line~6 places the {\em address} of the [[hello]] global
(suffixed again by [[(SB)]], which I will explain later)
in the {register} [[R2]]. 

\n How this works without having set R12? What code is generated
\n  for those instructions? we are lucky and the address is loaded
\n  from a Pool, it is not computed via ADD Offset, R12, R2.
\n  but too complex to explain here.
There are 16 ARM registers named [[R0]] to [[R15]].
\l last 3 have special meaning and used specially by ARM
Note that Asm9 uses a {\em left-to-right} assignment syntax\footnote{
This syntax is called the
\att syntax, as opposed to the Intel syntax which is right-to-left.}.
%alt: intel syntax, right to left
Moreover, in Asm9 [[MOV]] instructions are suffixed with a letter
corresponding to a size: [[W]] for word, [[B]] for byte, etc.
%alt: intel syntax, no prefix
\l hmm also sometimes MOVBU, gas does that too
\n also MOV is virtual instr, see later

Line 7 places the character constant [['W']], 
converted by the assembler in its integer ASCII value (87), into the
register [[R1]].
\l it is a word
\l also unicode?

\subsection{Addressing modes}
\n https://en.wikipedia.org/wiki/Addressing_mode

Line~8 introduces a new {\em memory addressing mode}.
It is the first instruction that writes into memory. Indeed, until now
the code in [[helloworld.s]] was only modifying the content of registers.
%
[[MOVB R1, 6(R2)]] at Line~8 {stores} the first byte (because of the [[B]] suffix)
of register [[R1]] (which should contain 87)
at the address {denoted} by [[R2]] plus [[6]].
%
The assembly instruction [[MOVB N, O(B)]] roughly corresponds
to the following C statement [[B[O] = N]], if [[B]] is a byte pointer.
This instruction is also equivalent to this C statement [[*(B+O) = N]].
\l what a strange syntax ... not sure where comes from, apparently not unix as
\n apparently vasm uses similar syntax, so maybe 68k motorola assembly syntax
\n which would make sense since 2a was the first assembler written by Pike
[[O]] is called the {\em offset}, and it is applied to 
a pointer [[B]] called the {\em base}.
This addressing mode is called {\em indirect with offset}.
The parenthesis around the register corresponds roughly to the 
C {dereferencing} operator [[*]].
\n why not MOVB 'W', 6(R2)? linker limitations and RISC LDR/STR (talked later)

In fact, Line 6 introduced also an addressing mode.
The syntax [[hello(SB)]] is reminiscent of the base
and offset addressing mode we have just seen.
[[SB]] stands for {\em static base} register.
It refers to the beginning of the address space of the program.
\n more on this later, it's a pseudo, it's not needed, it's weird
\n  because for TEXT reference, SB is actually not, but for GLOBL it is
\n  and it is actually not start of address space but INITDAT plus BIG (see 5l)
\n  when used as hello(SB) (but not when used as dollar.hello(SB), hmm)
In Asm9, all references to globals and procedures
are written as offsets to [[SB]] 
\t offset cos in the end symbols will have static address and so static offset?
(for definition references see Lines 1, 38, 48, and 49;
for use references see Lines 6, 22, and 32).
%
The instruction [[MOVW foo(SB), R1]] will store the {\em content}
at the address denoted by the symbol [[foo]] into [[R1]].
The instruction [[MOVW $foo(SB), R1]] %$
will store the {\em address} denoted by the symbol [[foo]] in [[R1]].
The \$ in that case corresponds roughly to the 
C {address} operator [[&]].
\l ugly to overload dollar which is already used for constants? or because
\l  in the end it will be a constant, it will be really an offset
\l It is the first instr that read memory?? it's static?
\l  but why the generated code for Line 6 is MOVW #84(R15), R2 ? #10a8=#2000 ???
\l  this SB is weird

\subsection{Pseudo registers}
\label{sec:pseudo-registers}

[[SB]] is one of the few {\em pseudo registers} of Asm9.
[[PC]] is another one. It corresponds to the
{\em virtual program counter}. 
Similar to pseudo instructions, pseudo registers
do not correspond exactly to machine registers.
Indeed, the ARM has already an hardware register called [[R15]] 
representing the program counter. 
Because the ARM has fixed-length instructions of 4 bytes,
the value of [[R15]] is always a multiple of 4. The pseudo register
[[PC]] instead counts instructions, not bytes of data. Thus,
to branch to the second following instruction (to skip
one instruction), you could use the following instruction: [[B 2(PC)]].
\n which is really *(PC _plus_ 2)
This instruction is equivalent to [[B 8(R15)]].
\t actually no! because ARM when R15 is involved it does a plus 8
\t  see Linker so B 0(R15) is in fact equivalent to B 2(PC), subtle
\t but then even more an argument for pseudo register :) hide
\t  complexity/tricks of ARM
\l I think it is equivalent
\n branch are absolute, PC plus 2 is absolute

Why should you use pseudo registers? The advantage of using [[2(PC)]]
instead of [[8(R15)]] in Asm5 may look small. However, on some
architectures the size of instructions is variable.
\l actually how do in other assembler? allow B with PC?
\n actually also variable with Asm5 as 1 instr may lead to multiple instr
For instance, it is not trivial on x86 to compute the number
of bytes two arbitrary instructions are using.
%
Just like with symbolic addresses, using pseudo registers
allows the programmer to think in slightly higher-level terms
(for [[PC]] in terms of instructions instead of bytes of data),
and to delegate tedious tasks such as counting
the size of instructions to the computer.
\t for FP and SP it actually helps a lot for debugging format!

Asm9 defines four pseudo registers:
\begin{itemize}
\item [[PC]], the (virtual) {\em program counter}, counts the
number of instructions.
For the ARM, [[PC]] is related to the (real) program counter register [[R15]].

\item [[SB]], the {\em static base} register,
refers to the beginning of the address space of the program.
For the ARM, [[SB]] is related to the machine register [[R12]].
\t For SB it's more tricky to understand why we need that. See Linker.nw?
\l R12 is reserved by assembler, it's not reserved by machine

\item [[SP]], the (virtual) {\em stack pointer}, can be used to access local
variables in the stack.
\l also called auto, but local maybe bad name; it is also for callee args
For the ARM, [[SP]] is related to the machine register [[R13]].
\n note that it is not an ARM stack pointer register, ARM imposes nothing
\l apparently it points to the top of the local stack frame! so offset
\l must be negative

\item [[FP]], the {\em frame pointer}, can be used to access the arguments
of the procedure in the stack. [[FP]] is also related
to [[R13]] for the ARM.
\l set by caller
\t related to SP? more on this later. ref to section in grammar?

\end{itemize}



In this tutorial, I will avoid using those pseudo registers (except
[[SB]] because it is mandatory).
Indeed, they may simplify things in the long term but they
add some extra complexities at the beginning.
\l generic, hide normally peculiarities, complexities, but add some complexity
\n indeed N_xxx not used that much in Assembler.nw but used more in Linker.nw

\bigskip
Line 6 through 18 set characters in the [[hello]] global array of characters. 

\subsection{Call stack}
\label{sec:call-stack}

I can now go through Line~20 to Line~29. Those instructions
build the {arguments} for the
system call performed Line 31 with the software interrupt instruction
[[SWI]]. {\em Arguments}, in function calls or system calls, 
are by {convention}
in \plan hold primarily in the {\em stack}. You will see later that
[[R0]] plays also a special role regarding arguments because of 
some C and kernel {calling conventions}.
\l convention to be in stack, but convenient, for recursive
As I mentioned in the previous section, [[R13]] is by convention used
to represent the stack pointer.
\n I use R13 and not SP because SP is a pseudo which get played with
\n in the linker, so simpler use directly R13 to minimize explanations
\t and also because I dont understand how to use SP properly ... hmmm
Figure~\ref{fig:stack-start} contains a
representation of the stack when the [[hello]] program
is loaded in memory by the kernel.
The stack grows downward, so high addresses are at the top in the diagram.
\n OSTEP book uses stack growing upward

\begin{figure}[!]\centering
\begin{verbatim}
        |       |
        |       |
R13 +-> +-------+
\end{verbatim}
\caption{Stack content when [[hello]] started.}\label{fig:stack-start}
\end{figure}

[[R13]] is initialized by the kernel before the kernel gives
control to the entry point of the binary program.
Its value is very high in the virtual memory address space.
Here is a dump of the registers before the program starts
by using the emulator/debugger [[5i]]
\footnote{
To fully understand the values of those registers,
see the \book{Kernel} or the \book{Emulator},
especially the code of [[initmemory()]] in [[5i]].
}:
\t why R0 value? R1? also talk about R15 and _main

\begin{verbatim}
$ 5i hello
5i> $r
...
R0  #7fffff70 R1  #7ffffffc R2  #0        R3  #0
R4  #0        R5  #0        R6  #0        R7  #0
R8  #0        R9  #0        R10 #0        R11 #0
R12 #0        R13 #7fffff58 R14 #0        R15 #1020
\end{verbatim}
\n first output line is: PC  #1020     SP  #7fffff58 but confusing I think
\n  because SP here is the machine SP, not assembler SP
\n why R0 weird value? and R1? TOS?
% in 5i see initmemory():
%    STACKTOP	= 0x80000000, 
%    ...
%    reg.r[0] = tos;
%    reg.r[REGSP] = sp;
%    reg.r[1] = STACKTOP-4;	/* Plan 9 profiling clock (why & why in R1?) */

Figure~\ref{fig:stack-line2} contains a representation of the stack 
after Line~1,
when the processor starts to execute the instruction Line~2.
%
Remember that the second operand of the [[TEXT]] pseudo instruction
is the number of bytes this procedure will need for its {locals} in the {stack}.
\l locals, arguments
Thus, when assembled, the [[TEXT]] pseudo instruction for [[_main]] Line~1
should generate a machine instruction that decrements [[R13]] by 20. 
In fact, the actual generated instruction decrements [[R13]] by 24;
\n in fact it also does also some magic with R14
you will see later in Section~\ref{sec:extra-word-stack}
why [[_main]] uses an extra word in the stack before the arguments.


\begin{figure}[!]\centering
\begin{verbatim}
        |       |
        |       |
    +24 +-------+ <-+ old value of R13
        |       |
    +20 +-------+
        |       |
    +16 +-------+
        |       |
    +12 +-------+
        |       |
     +8 +-------+
        |       |
     +4 +-------+ <- start of "locals"
        |       |
R13 +-> +-------+
\end{verbatim}
\caption{Stack content before Line 2.}\label{fig:stack-line2}
\end{figure}
\t and content of R14 in bottom cell? should be 0 as no caller actually

Figure~\ref{fig:stack-line31} contains the same stack before Line~31,
after the arguments to the system call have been set by Lines~20 through 28.
\l note that arguments are in the ``stack space'' of the caller

\begin{figure}[!]\centering
\begin{verbatim}
        |       |
        |       |
    +24 +-------+ <-+ old value of R13
        |  0    |
    +20 +-------+
        |  0    |
    +16 +-------+
        |  12   |
    +12 +-------+
        |&hello |
     +8 +-------+
        |  1    |
     +4 +-------+ <- start of PWRITE arguments
        |       |
R13 +-> +-------+
\end{verbatim}
\caption{Stack content before Line 31.}\label{fig:stack-line31}
\end{figure}
\l remember 0 0 because vlong offset
\l need talk endianess if it was not 0 but 1. Which order then? (jarod)
\t and content of R14 in bottom cell? note that return address of hello
\t  in OS, not return address in hello!

%real-world:
\t no need to save old value of R13 in the stack! RET does it.
\t no bad DWARD of frame-pointer thing -fomit-frame-pointer
\t (hmm but if want to have exn in your lang, you need to save
\t somewhere information about the size of the frame)


\subsection{System calls}

The \plan{} {\em kernel calling conventions} impose to have all
the arguments in the stack ``above'' [[R13+4]]
and to use [[R0]] to hold
the syscall ``code''. The magic constant value [[9]]
at Line~29 is the code corresponding to the [[PWRITE]]
system call (see the file [[lib_core/libc/9syscall/sys.h]],
which defines all those syscall codes).
\n could actually #include this file and use PWRITE but 
\n  but better to have less feature to explain in tutorial (here cpp)
\n R0 is not the first argument anymore!
The [[SWI]] instruction Line~31 then performs the system call
and jumps in the kernel.
%
[[SWI]] has one operand in the ARM. This operand
is normally used to specify which entry
in the {\em interrupt table} to go to. However, the \plan kernel
uses [[R0]] instead for that purpose. Thus, the operand of [[SWI]] is
not used under \plan. This is why I pass zero
to [[SWI]] in [[helloworld.s]] Line~31.
\l need extra words before arguments for syscall too? because C convention?

\subsection{Function calls}
\label{sec:bl}
\l branch and link

In Asm5, regular function calls (e.g., the call to [[exit]] Line~32),
use the [[BL]] instruction. You should use [[SWI]] only for system calls.
[[BL]] stands for {\em branch and link}, which I will explain below.

Some processors such as the x86 have a [[CALL]] instruction,
which when executed pushes on the stack the value of the program counter
for the next instruction. This value corresponds to a {\em return address}.
[[CALL]] then jumps (branches) to the code of the {\em callee}.
\l put diagram of recursive call here? how the magic works!
A corresponding [[RET]] instruction in the callee
will pop back in the program counter 
the value pushed by [[CALL]] to return back to the {\em caller}.
\t and add 4? or it's done before? see code of BL in Machine.nw
\l classic use of stack, can do recursive functions like that

There is no [[CALL]] or [[RET]] instruction in the ARM.
Instead, the [[BL]] instruction just saves the current value of the program
counter ([[R15]]) plus 4 (the next instruction)
in the special register [[R14]],
called the {\em link register}, and then jumps to the callee. 


The use of a special register to hold a {return address}
is an ARM optimization that avoids for certain calls
to use the stack, and so the memory (which is slow).
%
Indeed, when a function does not call other functions, 
in which case it is called a {\em leaf} function, the value
of [[R14]] does not need to be saved. Returning
to the caller from the leaf function
can be done simply by setting the program
counter to the value in the link register with [[B (R14)]].
\l or MOVW R14, R15 but apparently 5l does the B above.
%
However, if the function is not a leaf then the value in [[R14]]
must be saved somewhere, in the stack, before the function calls
another function via [[BL]] (which would overwrite [[R14]]).
%\footnote{See the \book{Emulator} for more information on the ARM and [[BL]].}.


\label{sec:extra-word-stack}
Non-leaf functions are the reason the [[TEXT]] pseudo instruction
allocates one more word than its second operand, for instance, 24
instead of 20 for [[_main]] Line~1. This extra
word in Figure~\ref{fig:stack-line2} can be used
by functions called from [[_main]] to save
the return address stored in [[R14]].
\t FIGURE!! where see multiple function calls, and frames (Linker.pdf has one?)
\t  and stored addresses!!
\t !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

\subsection{Virtual instructions}
\label{sec:ret}

The leaf detection is done ({statically}) by the linker [[5l]].
Indeed, [[5l]] is the program generating the machine code in \plan,
and so the program that needs this information to optimize machine code.
%
A leaf is simply any procedure that does not contain a [[BL]] instruction,
for instance, [[exit]] in [[helloworld.s]]\footnote{[[SWI]] does not count 
as a function call; [[R14]] is not overwritten by a [[SWI]].
}.
\l In any case the kernel saves all the registers of the calling process?
\l actually only when context switch no?
[[_main]] in [[helloworld.s]] on the opposite is not a leaf function 
because it is using [[BL]] Line~32.


The machine instructions generated by [[5l]]
for the [[TEXT]] pseudo instruction
depends on whether the function is a leaf. 
The same is true for the [[RET]] instruction, Line~33 and Line~45.
[[RET]] is called a {\em virtual instruction}.
\l we call it that way? or asm.pdf does?
Indeed, as I mentioned before, the ARM does not have any [[RET]] instruction.
However, it is convenient for the programmer to use a [[RET]]
assembly instruction in his program to return to the caller, whether
the caller is a leaf or a non-leaf function.


Figure~\ref{fig:virtual-text-ret}
describes roughly the machine code generated by [[5l]]
for the pseudo and virtual instructions [[TEXT]] and [[RET]]
for a simple procedure [[foo]], depending on whether this
procedure is a leaf or not.
For more information, see the \book{Linker}.

\begin{figure}[!]\centering
\begin{verbatim}
TEXT foo(SB), $0   MOVW R14, (R13)          
                   SUB $4, R13, R13
 ...               ...                      ...
                   ADD $4, R13, R13           
 RET               B -4(R13)                B (R14)
----------------  -----------------------  ------------------
  assembly code    machine code non-leaf    machine code leaf
\end{verbatim}
\caption{Machine code for the pseudo/virtual instructions [[TEXT]] and [[RET]].}
\label{fig:virtual-text-ret}
\end{figure}
\t it is -4(R13) or (R13)? it's in 
\t need to have dollar0 ? but then already means does not call anything no?
\n actually it is a single MOVW.W R14, #-4(R13), ref to later section? 
\n  and for RET it is MOVW.P #4(R13), R15
\l and actually it's ADD 0, R14, R15 instead of B (R14) (5l opti?)
\l not also that leaf opti is applied only if no locals (autosize = 0)
\l  so a bit less interesting. See leaf.s

\t speak about frame? and responsibility. like return address
\t  is stored in frame of caller for instance! not callee.
\t  and the callee itself allocate space for its own return address
\t  if he calls other functions.

%real world: -fomit-frame-pointer see later in grammar chapter.

The virtual instruction [[RET]], just like the 
pseudo instruction [[TEXT]], or the pseudo registers, allows the programmer
to think in slightly higher-level terms and let the computer
do the appropriate optimizations.
\l TEXT is almost a virtual too. maybe say pseudo cos not just serie of instr
\l  but also introduce a label (jarod)
%
In fact, [[MOVW]] used in Figure~\ref{fig:virtual-text-ret} 
is also a virtual instruction. It hides some 
architecture restrictions and peculiarities regarding memory accesses.
in Asm5, you can use the very general [[MOVW]]
even though the ARM processor supports only the
more basic and separate [[LDR]] (load) and [[STR]] (store) instructions.
\n actually there is a MOV and it's LDR and STR but same basic idea
\n and also MOVW generalizes MSR and MRS that mov StatusRegister
\l but a bit leaky abstraction because the linker puts later some restrictions
\t so fig:virtual-text-ret is actually not correct

\t say TEXT is pseudo and virtual at the same time. because introduce
\t  name, which is assembly only constructs that eventually disappear,
\t  but also specify size locals which ultimately becomes an ARM instruction

\bigskip
Instructions Line~40 though 44 are similar to the instructions
we have seen before; they perform the system call [[exits(0)]],
which terminates the program. This is why I marked a few instructions
with a comment indicating the instruction
could not be reached. Indeed, the program will have exited already
(and so will not perform the [[RET]]).

\subsection{C calling conventions}

Note that the way arguments are laid out in the stack in
Figure~\ref{fig:stack-line31}, as well as the extra word before the
arguments (to save the return address to the caller stored temporarily in
[[R14]]), or the fact that all those elements are ``above'' the stack
pointer ([[R13]]) at the entry of the function callee (or syscall
interrupt handler), are just {\em conventions}. 
% official conventions?
% http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042f/IHI0042F_aapcs.pdf
%
The ARM processor does not dictate any specific way to call procedures.
In fact, it does not even have a notion of procedure;
the ARM provides only the [[BL]] machine instruction, which just saves 
[[R15]] in [[R14]] and jumps to an address.
The rest is a design choice.

The calling conventions I use in this tutorial come from the
{\em C calling conventions} used by the C compiler [[5c]].
Indeed, the assembly code generated by [[5c]] assumes
arguments are passed in a certain way and the stack
pointer [[R13]] has a certain value. 
In fact, the use of [[R13]] for the stack pointer is also a 
convention; ARM has no notion of stack, it just manipulates memory.
\n because you need that! you need at least a convention, see later.

I use conventions similar to the C calling conventions
in this tutorial because the code I present
performs a system call and the \plan{} {kernel calling conventions}
are derived from the C calling conventions. Indeed, the kernel
is mostly written in C.

The C calling conventions are slightly different from
the kernel calling conventions. In the C calling conventions,
instead of using [[R0]] to
store the syscall code, [[R0]] is used to store the first argument.
In fact, [[R0]] is also used to store the return value of C
functions.
\l except for vlong? and float?
Using [[R0]] is an optimization similar to the one you have seen previously
with the link register. 
\l but compiler opti, not hardware opti
For certain simple and small functions,
everything can be done using just registers, without having to use
the stack and so the (slow) memory.
\t Example of code generation for abs()!

\begin{figure}[!]\centering
\begin{verbatim}
        |       |
        |       |
    +24 +-------+ <-+ old value of R13
        |  0    |
    +20 +-------+
        |  0    |
    +16 +-------+
        |  12   |
    +12 +-------+
        |&hello |
     +8 +-------+
        |       |
     +4 +-------+ <- start of pwrite() arguments
        |       |
R13 +-> +-------+

R0 = 1
\end{verbatim}
\caption{Stack and [[R0]] value for a C call to [[pwrite()]].}\label{fig:stack-c-pwrite}
\end{figure}
\t add content of R14 in bottom cell?

Figure~\ref{fig:stack-c-pwrite} shows how the stack would
look like if we were calling a C function [[pwrite()]]
instead of doing directly the system call to [[PWRITE]].
\t link to appendix pwrite.s? where see translation from C convention to kernel
%
Note that because the first argument is stored in [[R0]], 
the code generated by [[5c]] for a function call does not
bother to store it also in the stack. However, similar to the
link register optimization, an extra word in the stack is still allocated
for the first argument in case the callee need to overwrite [[R0]]
(in which case it can save its value in the stack).
\l hmm it will overwrite R0 is return something, so it is more if
\l  want to use R0 for something else temporarily

The calling conventions used by [[5c]] could be completely different:
the order of the arguments in the stack could be reversed, 
\n but C variable number of arguments '...' would be harder
more registers could be used to store the first $n$ arguments,
the arguments to a function could be ``below'' the stack pointer,
the return address to a function could be ``below'' the stack pointer,
the responsibility to save the return address in the stack
could be done by the caller instead of the callee, etc.
%
The {\em C calling conventions} implemented by [[5c]]
are a nice compromise between simplicity and speed.

\t who saves what? explained later? callee save?

Because most assembly code interoperates with C code,
the C calling conventions are also the {\em assembly calling conventions}
in \plan.
\l really?
Note that the only constraint imposed by Asm5
on the calling convention 
is the extra word in the stack above [[R13]] to store
the return address to the caller (because of the
code generated for [[TEXT]] and [[RET]] by [[5l]]).

\subsection{Data layout}
\label{sec:data}

The last piece of assembly code I need to explain is Line~49, which initializes
(partially) the content of the [[hello]] global:

<<assemblers/5a/tests/helloworld.s repeat>>=
...
48	GLOBL   hello(SB), $12
49	DATA    hello+0(SB)/6, $"Hello "
@

Even if Line~48 {\em declares} the [[hello]] global (with the [[GLOBL]] 
pseudo instruction), it is the [[DATA]] pseudo instruction Line~49 that {\em defines}
the content of the global.
%
The operands of [[DATA]] are in order:
\begin{enumerate}
\item the symbol of the global,
possibly with an offset ([[+0]] at Line~49), and as always 
for references to globals the [[(SB)]] suffix,

\item a slash followed
by an integer between 1 and 8 representing the size in
number of bytes this [[DATA]] pseudo instruction is defining (here [[/6]]),
\l but no dollar here, hmmm
 
\item a constant, which can be an integer, a character, or a string of
less than 8 bytes.
\l ximm so can also be float, or address of symbol
\end{enumerate}
\l a bit weird those constraints and conventions

To define data that takes more than 8 bytes, you need
to use multiple [[DATA]] pseudo instructions.
%
For instance, to define completely [[hello]], which would remove the need
for Lines~6 to 18 in [[helloworld.s]]
(added for educational purposes in this tutorial),
you could write instead:

<<full definition of [[hello]] content>>=
GLOBL   hello(SB), $12
DATA    hello+0(SB)/8, $"hello wo"
DATA    hello+8(SB)/4, $"rld\n"
@
%$
\l see data2s also

\l need the antislash z?
%The [[\z]] are the equivalent of [[\0]] in C and represents
%the zero value. They are not 
%        MOVW $'\z', R1
%        MOVB R1, 12(R2)

\bigskip
%trans:
This concludes the tutorial of Asm5. I tried to present
the main instructions and main assembly constructs of Asm5.
%chunk:
I will present more instructions gradually in the rest of the book.


\section{The ARM architecture}

The three letters ARM represent different things: 
a family of RISC machines (Acorn RISC Machines), 
\n Advanced Risc Machine now?
a family of {\em instruction set architectures} (ISAs), and 
finally a family of processors. 
%
Up until now, and for the rest of this document, 
when I use the term ARM I mean the {\em ARMv6} instruction set architecture.
\t cite ARMv6?
%
Confusingly, ARMv6 is the instruction set
used in the {\em ARM11} 32-bits processor 
family\furl{http://www.arm.com/products/processors/classic/arm11/?tab=Specifications}.
%
This family powers most smartphones,
as well as the Raspberry Pi\furl{https://www.raspberrypi.org/} 
(an extremely cheap machine popular among electronic hobbyists).
\l ARM1136
\l 15 billions according to Hennessy


Because an assembly language mimics closely the instructions
of a machine, most of the instructions in Asm5
are instructions of the ARM.
The opcodes [[B]], [[BL]], [[SWI]], or [[ADD]]
you have seen in the Asm5 tutorial correspond to ARM opcodes.
%
The same is true for the registers [[R0]] to [[R15]].
%
To fully understand those assembly instructions, I refer you
to either the \book{Emulator}, which describes the semantics of 
the corresponding ARM machine instructions, or
the ARM reference manual~\cite{arm-refman}.

Asm5 introduces also some pseudo instructions, pseudo registers,
and virtual instructions, as you have seen in section~\ref{sec:helloworld}.
Those instructions will be fully explained in this document;
they do not correspond directly to ARM machine instructions.

%dup: from intro/5a
As I said briefly in Section~\ref{sec:plan9-assembler}, [[5a]] does not
generate machine code; the linker [[5l]] does.
%
Thus, there is no need to know the binary format of ARM instructions
to understand this document.
\l opcode format, see 5i/ it's more the job of 5l and optab to do that.

\section{Input assembly language}

%trans:
I have covered already in Section~\ref{sec:helloworld} 
most of features of the assembly language Asm5,
the language used by the input files of the assembler [[5a]].
%toc:
In this section, I summarize those features and
give a more systematic description of Asm5. This should
help solidify your understanding of Asm5.
\l this is not a reference manual, but it is enough to help implement.
%
\n I refer you to the \plan assembler manual~\cite{plan9-assemblers}
%for more information.
\n but not really more complete information, my tutorial is better
%note: was useful to write this summary, see better now the whole lang/picture
% almost look like a refcard

%model is Ken's National 32000 assembler
%src: https://www.youtube.com/watch?v=KINIAgRpkDA&feature=youtu.be at 13min21


\subsection{Lexical elements}
\label{sec:asm5-lexical}

The main lexical elements of Asm5 (and also of Asm9) are:
\n implementer POV
\begin{itemize}

\item {\em integers}, e.g., 
[[42]] (decimal), 
[[0x12]] (hexadecimal), 
or [[0666]] (octal)
\n hexa/octal is new, not in tutorial

\item {\em characters}, e.g., [['W']], [['\n']], or [['\007']]
\n octal is new, not in tutorial

\item {\em strings}, e.g., [["hello wo"]]. Strings are limited
to 8 characters or less.
\l why? meh

\item {\em floats}, e.g., [[4.2]], [[10e43]]
\n this is new, not in tutorial


\item {\em predefined identifiers} in uppercase. Asm5 uses those predefined
identifiers for the mnemonics of
opcodes (e.g., [[ADD]]), 
registers (e.g., [[R0]]), 
pseudo instructions (e.g., [[TEXT]]), and finally
pseudo registers (e.g., [[PC]]).
\l keywords

%\begin{quote}
%  ``Instructions, registers, and assembler directives are always in
%  UPPER CASE to remind you that assembly programming is a fraught
%  endeavor.'' - Rob Pike
%\end{quote}
\n https://golang.org/doc/asm (cited also from golang is trash article)

\item {\em identifiers} in lowercase, used for 
symbols (e.g., [[_main]]) and 
labels (e.g., [[later]])
%style:
\l have to be lowercase?
\l cant have DOT in it except at start, annoying, which is why in go code they
\l use a special unicode that looks like dot

\item {\em comments}, e.g., [[/* not reached */]] or [[// comment]].
Comments in Asm5 use the same syntax than C comments.
They are ignored by [[5a]].

\item {\em spaces} and {\em TABs}, which are also ignored by [[5a]].
%style:
By convention, it is common to indent with a TAB most
instructions, except pseudo instructions such as [[TEXT]] 
or [[GLOBL]] that are kept in the first column.

\item {\em newlines}, which are internally transformed in semicolons.
Indeed,
the semicolon is an {\em instruction terminator} in Asm9. 
By transforming newlines in semicolons, you
you can then either 
\n yep terminator, not separator, see inst grammar rule
write multiple instructions on different lines,
or multiple instructions on the same line but separated by an explicit [[;]].

\item {\em operators} (e.g., \$, [[()]], [[/]], [[+]], [[;]], [[<>]]).
Operators can have different meanings depending on the context.
\l also extended C operators for asm9 constant expressions

\end{itemize}
\l also cpp lexical elements

\subsection{Syntactical elements}

The main syntactical element of Asm5 is the {\em instruction}.
An Asm5 file is made essentially of a list of instructions, usually
one per line. 
An instruction is composed of an {\em opcode}
followed possibly by 1, 2, or 3 {\em operands}. 
A line can also contain a {\em label} definition, which is an identifier
followed by a colon (e.g., [[later:]]).
\n actually can have list of labels, but convention is label alone on its line

\subsection{Opcodes}

Asm5 opcodes can correspond to different kinds of instructions:
\begin{itemize}
\item {\em machine instructions}, e.g., [[B]], [[SWI]], or [[ADD]].

\item {\em pseudo instructions}, e.g., [[TEXT]], [[GLOBL]],
also known as assembly directives.
\l note TEXT has actually an operand and it is a memory reference :)

\item {\em virtual instructions}, e.g., [[RET]], [[MOVW]], or [[NOP]].
%
Virtual instructions are instructions without a
one-to-one mapping to an ARM machine code instruction. 
%
They are convenient for the programmer (or compiler writer)
because they hide some architecture restrictions or peculiarities,
or relieve the programmer from tedious tasks such as checking
whether a function is a leaf.
\l makes asm a bit more portable
\end{itemize}

\subsection{Operands}

Depending on the opcode, Asm5 supports different kinds of operands:
\begin{itemize}

\item {\em constants}, which in Asm9 are always prefixed with a dollar,
e.g., \$42, \$[['W']]
\l why? to avoid ambiguity with what? otherwise offset like 32(SP) have no dol

\item {\em registers}, named [[R0]] to [[R15]] in Asm5

\item {\em shifted registers}, which I will explain in
Section~\ref{sec:shift-register}

\item {\em pseudo registers}, named [[PC]], [[SP]], [[FP]], and [[SB]]
in Asm9
\l actually cant anymore have them as operands directly


\item {\em label references}, e.g., [[later]]
\l B xx vs B(SB)

\item {\em memory references}, which I describe below

\end{itemize}

\subsection{Addressing modes}
\label{sec:ref-addressing-modes}

Memory references appear mainly in 
memory moves (e.g., [[MOVW]]),
branching instructions (e.g., [[BL]]), 
as well as in entity definitions (e.g., [[TEXT]]).
%
There are 5 different ways to reference memory in Asm5,
called {\em memory addressing modes}:


\begin{enumerate}

\item In {\em indirect} mode, you use parenthesis around a register or
pseudo register (e.g., [[(R1)]]) to access
the content at the address {denoted} by the register (here [[R1]])
\n Can have just pseudo register? not anymore

\item In {\em indirect with offset} mode, you 
combine an offset with a register (e.g., [[4(R1)]]),
or pseudo register (e.g., [[4(FP)]]),
to access the content at the address denoted by the sum of the register
(here [[R1]] and [[FP]]) and the offset (here [[4]]).
Note that you do not prefix offsets with a dollar.
\l can have pseudo here, specially PC and FP and SP. But not SB.

\item In {\em symbol reference} mode, 
you combine a symbol with a pseudo register 
(e.g., [[hello(SB)]]) to access the content at the address
denoted by the symbol.
%which is always written as ``an offset''
%to a pseudo register, ,
%[[hello]],
\t offset cos at some point symbol become static address and so number/offset
\t actually here can have only SB I think. or 0(FP), 0(SP)

\item In {\em symbol reference with offset} mode, 
you combine a symbol, an offset, and a pseudo register
(e.g., [[hello+4(SB)]]),
to access the content at the address denoted by the symbol
plus the value in the offset.
%
With [[SB]], the symbol denotes a global or procedure,
with [[SP]] a local variable, and 
with [[FP]] an argument.
\n and PC? no.
\l for Text, data, param, locals

\t mv this later? outside of the enumerate?
For locals and arguments, it is common
to use a symbol as in [[x+4(SP)]] or [[length+4(FP)]]. In those
cases, the symbol is really just a comment to give a name to
the local or argument. However, this comment is kept in the
symbol table of the object file, 
as you will see in Chapter~\ref{chap:generation},
and can be used by debuggers, as you will see in Chapter~\ref{chap:debugging}.
\t plus offset for SB has a meaning?

\item In {\em symbol address} mode, you use a dollar sign
before a symbol (e.g., \$[[hello(SB)]]) to access the address of the symbol
(here [[hello]]).

\l and weird stuff with slash   hello _plus_ 0(SB)/6

\end{enumerate}

Note that Asm9 uses a left-to-right assignment syntax. For moves,
\l AT&T syntax, normal
the instruction
[[MOVW (R1), R2]] means moving the content at
the address denoted by [[R1]] into [[R2]]. The same
is true for other instructions such as [[ADD]] where the
destination register is the last operand and the sources the first two
operands (as in [[ADD R1, R2, R3]]).
%alt: intel syntax

Note also that the ARM processor supports only the first two addressing modes.
The remaining addressing modes, which involve symbols, are assembly-only
constructs.
%
Ultimately, an assembly instruction using a symbol reference
(e.g., [[hello(SB)]]) will be converted by the linker in
a machine instruction using a register and an offset (e.g., [[4100(R12)]]).
%
Indeed, as you will see in the \book{Linker}, [[5l]]
reserves the register [[R12]] to represent the pseudo register [[SB]]
and converts symbol references in offsets to [[R12]].
\t explain gen for SP and FP too here?
\n except reference to setR12 itself (tricky)

\l take some examples, e.g., start-KZERO(SB), and explain? see comment in .tex
\l will see later also private symbol, with angle operator
%concepts: 
% - external symbols = fully unresolved! will be resolved at linking time
%   but needs to keep the name in the symbol table and the place where it
%   was referenced
%   (note that external entities are not even declared, any use of a symbol
%    not defined in the file is an external reference)
%    less: maybe this should be fixed, easy to make a typo)
%
% (LONG is a macro?)
%        LONG    $-(0x1BADB002 + 0x00010003)     /* checksum */
%vs
%        LONG    $_start-KZERO(SB)          /* load_addr */
%
%why need SB in second case? because it refers to symbol in certain section?
% it's to take the address of _start symbol in SB and adjust
% by removing KZERO to it. tricky. It's really $  _start(SB) - KZERO
%
% it does not have extern declaration, but any ref is implicitely
% an extern.

\l section{Runtime conventions}? hmm more compiler specific

\subsection{Advanced features}
\label{sec:mcrr-macro}
\n this is new, not in tutorial

Asm9 has a few more features beyond mnemonics and symbolic addresses:
\begin{itemize}
\item {\em constant  expressions} as operands, e.g., \$[[(1<<6|3)]],
which are evaluated at {assembling-time}
\t see Appendix for example of use?

\item an embedded {\em macro-processor} similar to
the C preprocessor [[cpp]], with
features such as [[#include]] and [[#define]]. [[5a]] is thus
what people calls a {\em macro-assembler}.
%
This, combined with the previous feature, allows to overcome
some of the original limitations of [[5a]]. Indeed, even if [[5a]]
does not support the mnemonics corresponding to the advanced
{coprocessor} ARM instructions, 
\l actually has MCR and MRC
you can simply define and use the macro [[MCRR]] below
to encode the binary format of the instruction directly.
\t see Appendix for example of use?

%We will not explain though in this book the code related
%to this embedded macro processor as we will explain
%similar code in the \book{Compiler}.
\l compiler book is already big, maybe better do it here?

\item {\em symbolic constants} definitions (e.g., [[TMP = 11]]),
and uses (e.g.. [[MOV R1, R(TMP)]]).
Those constants were called originally (and ironically) {\em variables}.
They are redundant with the [[#define]] of the macro-processor;
they were probably added before [[5a]] became a macro-assembler.
%this feature has been removed from our version of [[5a]].
\l use LVAR for lexeme name, hmmm
\t see Appendix for example of use?

\end{itemize}

\l those are the most common features, we describe more advanced later as needed

% put outside itemize because weird layout otherwise
<<macro MCRR>>=
#define MCRR(coproc, op, rd, rn, crm) \
   WORD $(0xec400000|(rn)<<16|(rd)<<12|(coproc)<<8| \
          (op)<<4|(crm))

@
%$
The [[WORD]] pseudo instruction used above
will be described in Section~\ref{sec:WORD}.

\section{Output object format}
\label{sec:object-format-part1}

%dup: from intro/5a
As I said in Section~\ref{sec:plan9-assembler}, 
the {object files} generated by [[5a]]
are ARM-specific but they do not contain machine code. Instead,
an object file contains the {serialized form} of the 
{abstract syntax tree} of the assembly source. 
%dup: too many dup I think the sentence below so I commented it
%The actual machine code generation is performed by the linker [[5l]].
\t why better? because anyway cant resolve everything, and patch is complicated
\t so simpler work on the original abstract syntax tree
\n ocamlc does that too!
%
Because an Asm5 file is essentially a list of instructions,
its serialized form is simply a concatenation of serialized instructions.
%
The complete format of an object file
is described precisely in Chapter~\ref{chap:generation}
but Figure~\ref{fig:object-format} describes roughly the content 
of an object file
(remember that object files generated by [[5a]] use 
the~[[.5]] filename extension).


A serialized instruction has also a pretty simple format
because all instructions, including the pseudo instructions,
have the same syntax: an opcode followed by 0 to 3 operands.
%
One byte is enough to encode an Asm5 opcode
because the ARM is a RISC machine with far less than 256 ARM opcodes 
(and Asm5 introduces very few pseudo opcodes)
\footnote{
[[8a]], the \plan assembler for x86,
needs two bytes to represent an x86 opcode. Indeed, x86
is a CISC machine with more than 400 opcodes.
}.

After the opcode, [[5a]] uses a few bytes to store metadata
about the instruction.
After this metadata,
another byte is used to encode the {\em kind} of the first operand
(e.g., an integer constant, a register, a memory address, or nothing) 
followed by
a series of bytes encoding the actual operand value
(e.g., 4 bytes for an integer constant, 1 byte for the register number, etc.)
as shown in Figure~\ref{fig:object-format}.


\begin{figure}[!]\centering
\begin{verbatim}
|                  |
+------------------+
|    Opcode        |
|                  |
+------------------+  <--- start of second instruction
|        .         |
|        .         |  <--- operand 2 encoded value
+------------------+
|  Operand 2 kind  |
|     (1 Byte)     |
+------------------+
|        .         |  <--- operand 1 encoded value
|        .         | 
+------------------+
|  Operand 1 kind  |
|     (1 Byte)     |
+------------------+
|        .         |
|        .         |  <--- instruction metadata 
|        .         |       (e.g., line number) 
+------------------+
|     Opcode       |  
|    (1 Byte)      |
+------------------+  <--- start of the .5 file 
\end{verbatim}
\caption{File format of a [[.5]] object file.}\label{fig:object-format}
\end{figure}
\t symbol table about unresolved? imported and exported? at the end of file
\t actually use a very special encoding scheme, see sectionXX
\l same for history at the beginnning of file, but it actually abuse
%   instruction format with AHISTORY (but there are also lots of ANAME)

%ocaml: just marshall the AST, and unmarshall in linker => shorter code!
%update: hmm but the format is actually not that complicated, so we may win
% but not that big probably. Also nice to have a format that other programs
% coded in different languages can read.
%update: actually with the abuse of AHISTORY and ANAME, it would be shorter!

%real-world: ELF is executable format _and_ object file format. Same for other.
% looks like in ELF object file has also notion of Section or Segment
% with Text and Data. 5a and .5 are simpler I think. Better.


[[5a]] resolves the use of label addresses
so [[5a]] does not need to serialize label definitions.
\l actually it still saves mention of labels
Label references in branching code are transformed in
absolute addresses.
\l but still keep mention of label for debugging purpose via ref to an ANAME
\l absolute but in terms of virtual program counter scale, and starts a 0
\l  so will need to be relocated
\n NO concrete offsets to the [[PC]] pseudo register.
\t but still need be relocated when concatenated

\section{Code organization}

Table~\ref{tab:code-orga} presents short descriptions
of the source files used by [[5a]], together with
the main entities (e.g., structures, functions, globals) the file defines,
and the corresponding chapter in this document in which the code
contained in the file is primarily discussed.
\n sorted by chapters, make more sense than sorted by dir

There are multiple assemblers in \plan: one per supported architectures
(ARM and x86 in the \plan fork used in \principia). The generic code has been
factorized in the [[assemblers/aa/]] directory;
%pad: I created this dir, to mimic what was done with 5c/8c and cc/
\l and common.out.h
the ARM-specific code is in [[assemblers/5a/]] 
as well as in [[include/obj/5.out.h]]\footnote{
And for x86, the x86-specific code is in 
[[assemblers/8a/]] and [[include/obj/8.out.h]].
}.

\begin{table*}[tbh!]
\begin{center}
\begin{tabular}{lcllr}
\toprule
{\bf Function} & {\bf Chapter} & {\bf File} & {\bf Entities} & {\bf LOC} \\
\otoprule
data structures and constants  & \ref{chap:core-ds}       & [[aa/aa.h]]                  & [[Sym]] [[Io]] [[Fi]]                                & 283 \\ %pad: I created this file. [[Hist]] [[Htab]]
ARM opcodes                    & \ref{chap:core-ds}       & [[include/obj/5.out.h]]      & [[Opcode]] [[Operand_kind]] [[Register]]             & 306 \\
ARM operand                    & \ref{chap:core-ds}       & [[5a/a.h]]                   & [[Gen]]                                              & 70 \\ %less: could put in 5.out.h too. Could be reused by linker and compiler.
symbol table lookup            & \ref{chap:core-ds}       & [[aa/lookup.c]]              & [[slookup()]] [[lookup()]]                           & 62 \\ %pad: I created this file
globals                        & \ref{chap:main}          & [[aa/globals.c]]             & [[hash]] [[symb]] [[outfile]] [[pass]] [[pc]]        & 107 \\ %pad: I created this file
ARM-specific globals           & \ref{chap:main}          & [[5a/globals.c]]             & [[nullgen]]                                          & 7 \\ %pad: I created this file
entry point and main functions & \ref{chap:main}          & [[5a/main.c]]                & [[main()]] [[assemble()]]                            & 207 \\ %pad: I created this file

\midrule                                                                                                                  
                                                                                                                  
IO and lexing utilities        & \ref{chap:input}         & [[aa/lexbody.c]]             & [[newio()]] [[newfile()]] [[pinit()]]                & 540 \\ %pad: was in cc/compat
lexer for Asm5                 & \ref{chap:lexing}        & [[5a/lex.c]]                 & [[yylex()]] [[cinit()]]                              & 590 \\ % (not using Lex)
macro processor                & \ref{chap:preprocessing} & [[aa/macbody.c]]             & [[mactab]] [[macdef()]] [[macinc()]] [[macexpand()]] & 846 \\ % mac = macro (not macos :)  (embedded [[cpp]])
grammar for Asm5               & \ref{chap:parsing}       & [[5a/a.y]]                   & [[yyparse()]] [[inst()]]                             & 600 \\ % (and calls to outcode)
object file generation         & \ref{chap:generation}    & [[5a/obj.c]]                 & [[outcode()]]                                        & 278 \\ %pad: I created this file

\midrule                                                                                                                  

location information           & \ref{chap:debugging}     & [[aa/hist.c]]                & [[linehist()]] [[prfile()]]                          & 95 \\ %pad: I created this file

\midrule                                                                                                                  

float data structure           & \ref{chap:advanced}      & [[include/obj/common.out.h]] & [[Ieee]]                                             & 22 \\ % and NSYM constant
float utilities                & \ref{chap:advanced}      & [[aa/float.c]]               & [[ieeedtod()]]                                       & 35 \\

\midrule                                                                                                                  

error management               & \ref{chap:error}         & [[aa/error.c]]               & [[errorexit()]] [[yyerror()]]                        & 50 \\ %pad: I created this file
utilities                      & \ref{chap:libc}          & [[aa/utils.c]]               & [[alloc()]]                                          & 121 \\ % use outfile global in globals.c, use yyerror() %pad: I created this file

\otoprule
Total                          &                          &                              &                                                      & 4219 \\
\bottomrule
\end{tabular}
\end{center}
\caption{Chapters and source files of [[5a]].}
\label{tab:code-orga}
\end{table*}
\n see SRC_VIEWS in the Makefile, and make loc
\n could have a input.c and output.c, but lex.c and obj.c are fine


\section{Software architecture}
\label{sec:archi}
% What is software architecture? Martin Fowler: whatever is important!

\t 5a is an assembler, which is a kind of compiler. So has
\t  classic soft archi of a compiler. See Figure X.
% Lexer -> Pre -> Parser -> Code generator
\t  and then instantiate with the actual code of 5a.

Figure~\ref{fig:controlflow} describes roughly 
the main control flow and main {components} of [[5a]], whereas 
Figure~\ref{fig:dataflow} describes
the main data flow of [[5a]].

\begin{figure}[!]\centering
\begin{verbatim}
            +-------------+         
            |    main     |         
            +------+------+         
                   |                
                   |                
            +------v------+         
            |  assemble   |         
            +----+--+-----+         
                 |  |               
                 |  |               
            +----v--v-----+         
            |  yyparse    | (Parser)        
            +---+-------+-+         
                |       |              
       +--------+       +-------+      
       |                        |      
+------v-------+         +------v-----+
|   yylex      | (Lexer) |  outcode   | (Object code generator)
+------+-------+         +------------+
       |                            
       |                            
+------v-------+                    
|    macxxx    | (Preprocessor)                   
+--------------+                    
\end{verbatim}
\caption{Control flow diagram of [[5a]].}\label{fig:controlflow}
\end{figure}
\l add chapter ref in the box? next to the box?
%ocaml: if the code was more functional the diagram would be just a pipeline!
\n alternative with cclean? not that important so better to remove it


\begin{figure}[!]\centering
\begin{verbatim}
assembly file -> tokens -> instructions -> object file
                (use global symbol table)
\end{verbatim}
\caption{Data flow diagram of [[5a]].}\label{fig:dataflow}
\end{figure}
\l focus on components instead? Lexer->Preprocessor->Parser->Generators?


After some basic command-line processing and initializations,
the function [[main()]] calls [[assemble()]] with the name
of the assembly file to process. 
%
[[assemble()]], after further initializations,
uses a {two-pass} algorithm and so calls 
[[yyparse()]], the function generated by Yacc~\cite{yacc} from the Asm5 grammar,
two times. It also modifies the global [[pass]]; for the first
call to [[yyparse()]] the value of [[pass]] is 1, and for the second
call the value of [[pass]] is 2.

The {parsing} function [[yyparse()]] internally calls the lexing
function [[yylex()]] to get the next {\em token} from the input file.
%
[[yylex()]] is usually generated by the program Lex~\cite{lex} from a set of 
{regular expressions}. However, in the case of [[5a]],
[[yylex()]] was handcoded instead.
\l why?
[[yylex()]] itself calls {macro-processing} functions
such as [[macinc()]] (for ``macroprocessing include''), as [[5a]] 
is a macro-assembler supporting [[cpp]] directives such as [[#include]].

From a set of tokens, [[yyparse()]] can parse using
different {\em grammar rules}
a constant,
a register,
an operand, 
an opcode, 
an instruction,
or a set of instructions.
%
The Yacc {\em actions}\footnote{
See~\cite{lexyacc} for more information on Yacc's grammar rules and actions.
}
associated with those grammar rules
gradually build and return abstract syntax trees (ASTs) corresponding
to the different parts of an instruction.
\l not really trees though
Once [[yyparse()]] parsed a full instruction,
via the [[inst]] grammar rule,
the Yacc action for [[inst]] is triggered. This action
calls the function [[outcode()]] with the AST of the 
parsed instruction as an argument.
\n actually 5 subASTs arguments but they represent the AST
% 5a abuse tokens and the grammar to do some computations (classic old style)
%ocaml: could return full AST, list of instr and then outcode of that.

[[outcode()]] outputs then the serialized form of the instruction's AST
in the object file. However, it does so only when the global value 
of [[pass]] is 2.
\t because pass 1 have incomplete information
Whatever the value of [[pass]], [[outcode()]]
also increments each time [[pc]], a global representing the
current value of the {\em virtual program counter}.

The lexing and parsing code internally uses and modifies a 
{\em symbol table} called [[hash]] that keeps track of the value
of different kinds of identifiers, for instance, labels.
%
During lexing, when [[yylex()]] encounters a new identifier, 
[[yylex()]] creates a new symbol in the symbol table [[hash]]. 
%
During parsing, once [[yyparse()]] recognizes an identifier as
a label (because it is followed by a colon token),
[[yyparse()]] changes its {\em type} in the symbol table to a label type
and its value is set to be the current value of the global [[pc]].
%
During the second pass, [[yyparse()]] can resolve any reference to this label 
by simply looking at the value of the label in the symbol table.
%
This is why [[outcode()]] outputs code only during the second pass,
once [[yyparse()]] resolved the values of every labels in the first pass.

\n talk about cclean? maybe not that important, a big ugly, no need AEND.

\l relation with other tools? 5c, 5l? easy, do git grep, see comment .tex
% git grep AADDB
%assemblers/8a/lex.c:    "ADDB",		LTYPE3,	AADDB,
%compilers/8c/peep.c:    case AADDB:	/* rhs rar */
%compilers/8c/reg.c:        case AADDB:
%compilers/8c/txt.c:            a = AADDB;
%include/386/8.out.h:    AADDB,
%linkers/8l/optab.c:    { AADDB,	yxorb,	Px, 0x04,0x80,(00),0x00,0x02 },

\l Symbol table assembler, and symbol table in object file! in/out.

\l Depends libc, libio




%\section{Bootstrapping}

%bootstrap:
% 5a is actually written in C :) not even asm! and also use yacc
% bootstrap from scratch? punch card, hex-to-c, assembler in assembler, 
% asm in C

\section{Book structure}

%trans:
You now have enough background to understand the source code of [[5a]].
%toc:
The rest of the book is organized as follows.
%
I will start by describing the core data structures of [[5a]]
in Chapter~\ref{chap:core-ds}. 
%
Then, I will use a top-down approach in Chapter~\ref{chap:main}, and,
starting from [[main()]], I will present the code of the main 
functions of [[5a]] (e.g., [[assemble()]]).
%
The following chapters will describe
the main components of the assembling pipeline:
Chapter~\ref{chap:input} will present the input routines,
Chapter~\ref{chap:lexing} the lexer,
Chapter~\ref{chap:preprocessing} the preprocessor,
Chapter~\ref{chap:parsing} the parser,
and finally Chapter~\ref{chap:generation} the object code generator.
%
In Chapter~\ref{chap:debugging} I will describe the code
responsible for adding debugging support in [[5a]].
For example, this code adds line information in the object code;
you can then know, when debugging a binary program,
to which original line and which source file an
instruction in the binary comes from, or what is the
original name of the procedure containing this instruction.
%
Chapter~\ref{chap:advanced} presents other
assembly features that I did not present 
before to simplify the explanations, for instance,
the support for floating-points. Those features tend to crosscut
many components with extensions to the lexer, the parser,
and the code generator.
%
Finally, Chapter~\ref{chap:conclusion} concludes
and gives pointers to other books in the \principia series.

%toc:
Some appendices present the code of non-functional properties:
code to help debug [[5a]] itself in Appendix~\ref{chap:debugging-appendix}, and 
code to manage errors in Appendix~\ref{chap:error}.
%
Appendix~\ref{chap:libc} contains the code of generic
utilities used by [[5a]] but which are not specific to [[5a]].
%
Appendix~\ref{chap:examples} contains more examples of
assembly programs to get a better feel of Asm5 and to see how
it is used in practice.
%
%%%Finally, Appendix~\ref{chap:5a-ocaml} contains
%%%the code of an OCaml port of [[5a]].
\t what for? :)




%###############################################################################


\chapter{Core Data Structures}
\label{chap:core-ds}

\begin{verse}
\begin{flushright}
  {\it Show me your code and conceal your data structures, and I shall
    continue to be mystified. Show me your data structures, and I
    won't usually need your code; it'll be obvious.\\
    ~\\
    Fred Brooks}
\end{flushright}
\end{verse}
\n actually I think the original quote is with "flowchart" and "tables"

%toc:
In this chapter, I will present the core data structures of [[5a]].
The first three sections contain the definitions
of the different components of the abstract syntax tree (AST) 
\l not really a tree though
of an instruction:
the opcode, 
the register, which is a kind of operand,
and the other kinds of operands.
\l internal memory representation of assembly textual instructions!
Then, you will see how tokens are represented.
Finally, I will present the symbol table, which is
a central data structure used by 
the lexer,
\n predefined identifiers, but ugly
the preprocessor, 
\n macro body, but ugly
and the parser.
\n label values, also links to Sym in operands
\n and the object code generator? No. Use the links to Sym in passed operands.


\section{[[Opcode]]}
\label{sec:opcode}

All Asm5 instructions (machine-, pseudo-, and virtual-) have an opcode
defined in [[include/obj/5.out.h]] by the following type:
\n used to be just 5c/5.out.h

<<enum opcode(arm)>>=
// coupling: with 5c/enam.c
enum Opcode
{
    AXXX,

    ANOP, // VIRTUAL removed by linker
    // ---------------------------------------------------------
    // Arithmetic and logic opcodes
    // ---------------------------------------------------------
    <<[[Opcode]] cases, logic opcodes>>
    <<[[Opcode]] cases, add/sub opcodes>>
    <<[[Opcode]] cases, mul/div/mod opcodes>>
    <<[[Opcode]] cases, bitshift opcodes>>
    // ---------------------------------------------------------
    // Memory opcodes
    // ---------------------------------------------------------
    <<[[Opcode]] cases, mov opcodes>>
    <<[[Opcode]] cases, swap opcodes>>
    // ---------------------------------------------------------
    // Control flow opcodes
    // ---------------------------------------------------------
    <<[[Opcode]] cases, comparison opcodes>>
    <<[[Opcode]] cases, branching opcodes>>
    // ---------------------------------------------------------
    // System opcodes
    // ---------------------------------------------------------
    <<[[Opcode]] cases, interrupt opcodes>>
    // ---------------------------------------------------------
    // Float opcodes
    // ---------------------------------------------------------
    <<[[Opcode]] cases, float mov opcodes>>
    <<[[Opcode]] cases, float arithmetic opcodes>>
    // ---------------------------------------------------------
    // Pseudo opcodes
    // ---------------------------------------------------------
    <<[[Opcode]] cases, pseudo opcodes>>

    ALAST,
};
@
\t split pseudo in 2 categories? misc? ``special''?
%ocaml: use an ADT that combines opcodes and operands
% but retrospectively this has some advantages too. For instance it
% is easier to write visitors in 5l that look for all symbols (ANAME),
% all branch operands (D_BRANCH), etc. In ocaml it is cleaner, but longer.
%old: was called 'enum as'
%note: I reordered a lot the original opcodes. e.g., AND, ORR, EOR are together.
% Note that it can be dangerous
% for backward compatibility to do so. Indeed 'ld' and 'as' need to agree
% with each other; one can't use a library compiled (or cross compiled) 
% using a 5l relying on a certain order, and link object files compiled 
% by a 5a relying on another order. So can have some subtle errors if
% want to play with what is cross-compiled! So make sure to recompile your
% libc if you modify 5l or 5a or 5.out.h
\n the enum must contain less than 256 elements, as we rely on 
\n  sending ANAME as a byte in zname(), and all opcode as a byte in zaddr()
\l analyze *.s and do stats? Use cg on plan9/ and see how much AXXX is used?

The opcodes follow closely the instruction set (ISA) of the ARM
(see the \book{Emulator}) and are all prefixed by an [[A]] 
(for [[A]]ssembly).
For example, the [[ASUB]] assembly opcode I will present in
Section~\ref{sec:asub} corresponds to the [[SUB]] ARM
machine instruction.
%
I have divided the opcodes above in different categories: 
arithmetic and logic, 
memory,
control flow, 
system, 
float,
and pseudo opcodes.
%
%I introduced the last category because Asm5 supports pseudo instructions.
%chunks:
I will present the different opcodes gradually in this book.

The first opcode above, [[AXXX]], 
represents the {\em invalid opcode}. It is in
the first position of the enumeration above as a form of 
defensive programming.
%ocaml: ugly, should not need that if had strong enum case checker

The second opcode, [[ANOP]], is a {virtual instruction} removed by [[5l]]. 
It is
occasionally used by the assembly generator in [[5c]] to
represent an instruction without any effect (see the \book{Compiler}).
\n no reading syntax actually
\l not clear why need that at all, but USED and profiler might use that?
\l also RET, MOV, SLL, BEQ, etc.
\l no PUSH/POP? stack is sugar over MOV with specific conventions.

Finally, the last opcode, [[ALAST]], is an {\em end marker}
(a C idiom making it easy to loop
over all the opcodes or to declare an array of opcodes).


\section{[[Register]]}
\label{sec:register}

The ARM processor has 16 registers named [[R0]] to [[R15]].
They are represented simply by an integer in [[5a]]: 
0 is [[R0]], 1 is [[R1]], etc.
%ocaml: a bit ugly because then have the issue with R_NONE
The following type introduces some convenient names for some of the
{special registers} you have seen before:

<<enum regxxx(arm)>>=
enum Register {
    <<[[Register]] compiler conventions cases>>
    <<[[Register]] linker conventions cases>>

    // reserved by the linker
    REGSB =     12, // static base
    REGSP =     13, // stack pointer

    // reserved by the ARM processor
    REGLINK =   14,
    REGPC =     15,

    NREG = 16,
};
@
\n can not use register, it is a reserved keyword
\n note those are not the pseudo registers but alias to the real one!
\n which is why there is no REGFP here.

Again, [[NREG]] is not a register but an end marker. 
With it, you can declare easily an array containing all the ARM registers
with [[int allregs[NREG];]].


Note than [[REGSB]] and [[REGSP]] are not special ARM registers.
However, they are reserved by the assembler and linker for special uses.
\t ref to section that explain more REGSB
\t actually REGSP is also not special ...
\l Machine.nw does not have it.


There are few situations where something, e.g., an operand,
can be a register or {nothing}. We can not use zero to 
represent nothing because zero
is already used to encode [[R0]]. Instead, the following
constant represents nothing:

<<constant R_NONE(arm)>>=
#define R_NONE 16
@
%old: NREG used to represent also NONE in the outcode reg param; I prefer R_NONE
%ocaml: None, no need for special constant

The ARM processor has also 
floating-point registers, 
coprocessor registers, and 
status registers, 
but I will introduce the constants representing those registers
later in Chapter~\ref{chap:advanced}.
\n Fxxx, Cxxx, PCR (and FPCR)


\section{[[Operand]]}
\label{sec:operand}

%trans:
A register is only one kind of operand;
constants (integers, floats, or strings) are another kind.
%
The following type represents all kinds of operands: 

<<struct Gen(arm)>>=
struct  Gen
{
    // enum<Operand_kind>
    short   type;

    // switch on Gen.type
    union {
        long    offset; // offset or lval or ...
        double  dval;
        char    sval[NSNAME];
    };
    // option<enum<Register>> (None = R_NONE)
    short   reg; // abused also to store a size for DATA

    <<[[Gen]] other fields>>
};
@
\t rename Gen to Operand so better section name
\t Why Gen anyway? gen rule in grammar. General opd? generic? 
\t can use lval too now! after all it's an union now. make it a union too?
\n =~ Operand of Linker. 
%old: was called Gen
%old: there was hardcoded 8 for sval, but bad cos not consistent
% with nullgen.sval and some memcpy done later could fail (jarod, me)
%old: I introduced the union. Can have it? operand_kind will be good enough?
%ocaml: An ADT would be far better than this enum, D_NONE, and separate Sym 
% update: but more tedious then to visit

The [[Gen.type]] field above encodes the {\em operand kind}.
The type of [[Gen.type]] is a [[short]], but [[Gen.type]]
can take only values from the [[Operand_kind]] enumeration below:
%(hence the {typing} comment)

<<enum operand_kind(arm)>>=
enum Operand_kind {
    D_NONE,

    D_CONST,
    D_SCONST,
    D_FCONST,

    D_REG,
    <<[[Operand_kind]] cases>>
};
@
\l why Dxxx prefix? 
%dead: D_GOK, D_ADDR (valid for x86 but unused for arm)/* type/name */ for GOK
%note: I reordered again a lot things, which like for opcode has some impact
% on 5l. Now D_REG, D_CONST, D_SHIFT are closer (to mimic imsr rule).
%See Dconv in Linker for dumper (which can help to undertand things too)

The union in [[Gen]] represents the {\em value} of the operand.
This value has to be interpreted in different ways depending on 
the kind of the 
operand: 
for integer constants ([[D_CONST]]), the [[offset]] field is used;
for string constants ([[D_SCONST]]), the [[sval]] field is used;
for float constants ([[D_FCONST]]), the [[dval]] field is used.
%
Remember that characters are converted in integers by [[5a]] so
there is no need for a [[D_CHARCONST]] constant and a [[cval]] field.
\t example of value now!


The [[long]] element of the union is called [[offset]]
and not [[lval]] (which would be more consistent with the
other union fields) because it is (ab)used to represent
different things, not just integer (or character) constants,
as you will see soon.
%ocaml: ugly, offset abused for many different operand kind, should be union
% see comment below


The [[D_NONE]] case above is used to
represent the {\em null operand}. 
%
Indeed, certain instructions have no operands (e.g., [[RET]]), but
the instruction format in the object file
(see Section~\ref{sec:object-format-part1})
imposes the presence of two operands.
%
For those instructions, the operand kind is set to [[D_NONE]].
%
%This is similar to [[R_NONE]].
\t for opcodes with less than 1 operands, should be overwritten though
%ocaml: again if ADT no need that

\label{sec:nullgen}
[[nullgen]] below is a global you will often in the code of [[5a]].
It represents the null operand. It is also
used to initialize freshly allocated operands.
% in code such as [[newopd = nullgen;]]:

<<global nullgen>>=
Gen	nullgen;
@
%ocaml: no need that, just set all fields each time with record



[[D_REG]] above is used to represent register operands. In that
case, the [[Gen.reg]] field encodes the register number.
\n could use offset? no because can have offset(reg), and also used for REGREG

For indirect operands (e.g., [[(R1)]]), 
or indirect with offset operands (e.g., [[4(R1)]]),
the new operand kind [[D_OREG]] (for ``offset register'') is used:

<<[[Operand_kind]] cases>>=
D_OREG,
@
\l oreg for offset register?

In those cases, the register number is encoded also in the [[Gen.reg]] field,
and the optional offset is stored in [[Gen.offset]] (hence the name of the
field).
%example:
Here is the C value of the operand mentioned above:
\begin{verbatim}
// operand value for: 4(R1)
{ .type = D_OREG;       // (...)
  .offset = 4;          // 4
  .reg    = 1;          // R1
}
\end{verbatim}
\l offset is abused for many things, see the comment in .tex
% - offset (D_OREG)
% - constant (D_CONST)
% - instr binary format for bitshifted registers, with bit 0-3, 5-6, 7-11
%   used to encode different parts (D_SHIFT)
% - register (D_REGREG)
% - bitset of register for MOVM
% - ??
%ocaml: split in ADT
%less: rename offset? to generic_value? or generic_long? or lval?
% but it's true in many places it's used to encode an offset to
% a base (a reg, a name).
% e.g., for D_SHIFT the long is used really to encode the whole
% thing with some bits for the shift kind, some bits for the register, etc.
% see the many uses cases of offset in zaddr() switch about operand_kind ...
%mimic what is in union token too
\t just add cases in the union with the long too!


Strings in Asm5 are limited to 8 characters, hence
the use of the constant below for the [[Gen.sval]] field:
\l really? have seen already idea of multiple DATA
% from 5.out.h and 8.out.h
<<constant NSNAME>>=
#define NSNAME      8
@
\l ref

%You will see later how to overcome this limitation.
% actually I have showed it before.


\section{Instructions}
\label{sec:outcode-signature}

[[5a]] does not define a type to represent a full instruction.
Instead, [[5a]] uses multiple parameters of the [[outcode()]]
function below to represent the different components
of an instruction. Here is the signature of [[outcode()]]:
%ocaml: could define a record at least, or better an ADT and a pair for cond
\l =~ Prog of Linker (but without opcode)?

<<signature outcode(arm)>>=
void    outcode(int opcode, int cond, Gen* opd1, int reg, Gen* opd3);
@
%ocaml: better have type instr

Here is an example of use of [[outcode()]] to output
the serialized form of the instruction [[SUB $14, R2, R3]]:
%$
%example:
\begin{verbatim}
Gen operand1 = { .type = D_CONST; .offset = 14; ...};
Gen operand3 = { .type = D_REG;   .reg = 3; ... };
outcode(ASUB, Always, &operand1, 2, &operand3);
\end{verbatim}

The [[Always]] constant in the second argument to [[outcode()]]
is used to represent the {\em conditional execution} of an instruction.
It is an ARM feature I will explain later in Section~\ref{sec:cond-exec}.
%
The fourth parameter is an integer and not a [[Gen*]] because
when an ARM instruction has three operands, the middle one is always
a register, so an integer is enough.
\t also abused for attributes Instr.reg;
Depending on the number of operands, here are the constraints on
the value of the arguments to [[outcode()]]:
\begin{itemize}
\item 0 operand: [[opd1]] and [[opd3]] are [[&nullgen]]
and [[reg]] is [[R_NONE]],
\l could be different than nullgen? after all know not used?
\item 1 operand: [[opd3]] is [[&nullgen]] and [[reg]] is [[R_NONE]]
\item 2 operands: [[reg]] is [[R_NONE]]
\item 3 operands: no constraint, all arguments are used.
\end{itemize}


\l speak now about the 2second register which is abused for: TEXT/DATA attr?

\section{Tokens and [[itab]]}
\label{sec:token}
\label{sec:union}

\t need FIGURE

The Yacc-based parser of [[5a]], called via [[yyparse()]],
is taking as input a set of {tokens}.
Those tokens are returned by the [[yylex()]] function
but the type of those tokens is defined by a set of {\em Yacc directives}
in the Yacc grammar [[5a/a.y]]\footnote{
Again, see~\cite{lexyacc} for more information on Yacc.
}.
Here are the directives to declare the names of those
tokens as well as the type of value they hold:

<<token declarations(arm)>>=
/* opcodes */
%token  <lval>  LARITH LCMP LBRANCH LBCOND LMOV LSWAP LRET
%token  <lval>  LSWI LSYSTEM 
%token  <lval>  LARITHFLOAT LCMPFLOAT LSQRTFLOAT  LMULL LMULA  LMOVM LMVN
%token  <lval>  LDEF LDATA LWORD LEND
%token  <lval>  LMISC
/* registers */
%token  <lval>  LPC LSP LFP LSB
%token  <lval>  LR LREG  LPSR
%token  <lval>  LF LFREG  LFCR 
%token  <lval>  LC LCREG
/* constants */
%token  <lval>  LCONST 
%token  <dval>  LFCONST
%token  <sval>  LSCONST
/* names */
%token  <sym>   LNAME LLAB
%token  <sym>   LVAR
/* bits */
%token  <lval>  LCOND
%token  <lval>  LS LAT
@
\l Lxxx for? lexeme?
%dead: LTYPEX LTYPEF LTYPEG LTYPED
%old: used to be LTYPE1 LTYPE2 LTYPEI etc, but better to give clearer names
%TODO: rename LTYPEXXX by T_END, T_TEXT, etc? L_ARITH? L_CMP L_MOV L_SWAP

Those directives are a bit complicated but things will be clearer
when I will describe the lexer in Chapter~\ref{chap:lexing}.
%
To understand those directives, it can be useful to look at
the code generated by Yacc and to look at how tokens are 
internally represented.
A Yacc token is a pair composed of the following two elements:

\begin{itemize}
\item The {\em token code} is an integer representing
the kind of the token. 
\l also known as a lexeme, hence L prefix 
Based on the directives above, Yacc will generate a [[y.tab.h]]
header file where all the token names are assigned a code.
%
See an excerpt of this file below.
For example,
57346 represents all the arithmetic mnemonics tokens
(e.g., [[ADD]], [[SUB]], etc.), whereas
57353 represents the token for the [[RET]] mnemonic, and 
57381 represents all integer tokens.
%

\item The {\em token value} is a union I will describe below.
%
Depending on the kind of the token, the value can be 
an integer (e.g., for integer tokens), 
a float (for float tokens), 
or something else.
%
For instance, for the arithmetic mnemonic tokens
(represented by the code 57346 and the token name [[LARITH]]), 
the value will be the opcode corresponding to the actual mnemonic
(e.g., [[ASUB]] for [[SUB]]), which is an enumeration case.

\end{itemize}
%ocaml: but value is in yyval global, ugly, just because C func cant return pair

Figure~\ref{fig:assembler-tokens} illustrates how [[5a]]
converts certain strings in the assembly file in tokens.

\begin{figure}[!]\centering
\begin{verbatim}
                            token      token
                            code       value

  +-----------------+     +---------+---------+
  |TEXT  -----------+---->|  LDEF   |  ATEXT  |
  |                 |     +---------+---------+
  |                 |     +---------+---------+
  |   SUB ... ------+---->| LARITH  |  ASUB   |
  |                 |     +---------+---------+
  |                 |     +---------+---------+
  |   ... 42  ------+---->| LCONST  |   42    |
  |                 |     +---------+---------+
  |                 |     +---------+---------+
  |   ... 3.7 ------+---->| LFCONST |   3.7   |
  |                 |     +---------+---------+
  |                 |     +---------+---------+
  |   ... "foo" ----+---->| LSCONST |  "foo"  |
  |                 |     +---------+---------+
  |                 |     +---------+---------+
  |   NOP ----------+---->|  LMISC  |  ANOP   |
  |                 |     +---------+---------+
  |                 |     +---------+---------+
  |   RET ----------+---->|  LRET   |  ARET   |
  |                 |     +---------+---------+
  |                 |     +---------+---------+
  |GLOBL ....-------+---->|  LDEF   | AGLOBL  |
  +-----------------+     +---------+---------+

    Assembly file                 tokens
\end{verbatim}
\caption{Examples of tokens.}\label{fig:assembler-tokens}
\end{figure}


Here is an excerpt of the [[y.tab.h]] file generated by Yacc:

<<5a/y.tab.h excerpt>>=
...
#define	LARITH	57346
...
#define	LSWI	57352
#define	LRET	57353
...
#define	LCONST	57381
#define	LFCONST	57382
...
@
%ocaml: ugly sugar, would be simpler have a simple ADT hiding all this shit

The values of the integers in [[y.tab.h]] are high to not conflict with
the values of regular {\em unicode} characters.
\l more on unicode now? or later when talk about EOF and input functions?
%
Indeed, [[yylex()]]
can also return single-character tokens, e.g., [[';']],
in which case there is no need to give them a name.
\n in unix yacc I think it starts at 256 because only ASCII conflict
\l see Yacc. typedef int token_code; so plan9 lex is unicode aware? nope. ulex?

Here is finally the union representing the different kinds of values
a token can hold:

<<union declaration(arm)>>=
%union {
 // long for LCONST
 // and enum<Opcode>  for LARITH/...
 // and enum<Register> for LREG/...
 // and enum<Cond>    for LCOND
 // and ...
 long   lval;    // for LCONST/LARITH/LREG/LCOND/...
 double dval;    // for LFCONST
 char   sval[NSNAME]; // for LSCONST

 <<union declaration other fields(arm)>>
}
@
%old: there was hardcoded 8 for sval, but bad cos not consistent
% with Gen.sval and some memcpy done later could fail (jarod, me)
%ocaml: no need, type information specified in token directive

Again, this directive is a bit complicated but things will be clearer later. 
%
The name of those fields (e.g., [[lval]]), are
referenced in the \%[[token]] directives above.
\l and also in type directives
For instance, \%[[token  <lval>  LCONST]] indicates that
the [[LCONST]] tokens will use the [[lval]] field of the union
to hold their values.
\t will see Sym later
\l this is used to typecheck things in Yacc.
\t this information will be used by Yacc when yacc actions access
\t value of terminals.



Another important data structure related to tokens
is the [[Itab]] structure and the global [[itab]] below:

<<struct Itab(arm)>>=
struct Itab
{
    char	*name;

    //enum<token_code>
    ushort	type;
    //enum<Opcode> | enum<Register> | ... | int
    ushort	value;
};
@
\t rename type to code?
\t why Itab? Instruction table? it's not just for instruction, ren ttab?
\t or mnemonics?
\l  fregisters|sysregisters|sym_kind(pseudo register) |operand_kind||...
%ocaml: use match instead directly in lexer instead of table, 
% and return ADT, better than union and this

<<global itab(arm)>>=
// map<string, (token_code * token_value)>
struct Itab itab[] =
{
    "NOP",		LMISC, ANOP,
    <<[[itab]] elements>>
    0
};
@
\l itab -> itab[], special literate suffix for arrays/hash/map/...? also lists?

[[itab]] maps the predefined identifiers of Asm5
(e.g., [[NOP]], [[PC]])
to their corresponding tokens, which as you have seen before
are pairs of a token code and a token value.
%chunks:
I will reveal gradually elements of the [[itab]] array
in this book, but the first entry is shown above for [[NOP]].
\l was LTYPEI, now LMISC, but should be LNOP? and then a nop grammar rule?
\t in fact there is no rule with LMISC really to express NOP in a program!
\l L vs A, Lexeme vs Assembly

\t in yylex when parse an identifier, looks in itab if equal string
\t in which case return the appropriate token

\l actually this array is used in xinit to populate hash table of symbols
\l so it's fast.

\section{[[Sym]]bols and [[hash]] table}
\label{sec:sym}
\label{sec:hash}

One of the main jobs of an assembler is to manage symbols.
\l and to resolve symbols.
\l actually linker does that a lot too, assembler resolve just labels
The {\em symbol table} is thus a central data structure in the code of [[5a]]. 
The structure below represents a symbol. 
It essentially associates a {name} to a {value}:

<<struct Sym>>=
struct  Sym
{
    // Sym is (ab)used to represent many things in the assembler:
    //   actual symbols, labels, but also macros,
    //   tokens for opcodes and registers, etc.

    // ---------------------------------------------------------
    // The "key"
    // ---------------------------------------------------------
    // ref_own<string>
    char    *name;

    // ---------------------------------------------------------
    // The generic "value"
    // ---------------------------------------------------------
    long    value; 

    <<[[Sym]] identifier fields>>
    <<[[Sym]] macro fields>>
    <<[[Sym]] token fields>>

    // ---------------------------------------------------------
    // Extra
    // ---------------------------------------------------------
    <<[[Sym]] extra fields>>
};
@
%archi: value is a vlong in va/
\n there is no symkind here, this is stored outside the Sym
%ocaml: no need special type, just use hashtbl for symbol table, just for lbls

As an example, the label [[later]] in the [[helloworld.s]] program 
in Section~\ref{sec:helloworld}, once resolved, could
be represented by the following [[Sym]]: 
%example:
[[{ .name = "later"; .value = 2; ... }]]. Indeed,
the label is defined after the second instruction in the 
[[helloworld.s]] program.
\l virtual PC!



The symbol table itself is represented by a global {hash table}
called [[hash]]. It makes sense to use a global because
the symbol table will be accessed by different components
of the assembling pipeline (e.g., the lexer, the parser).
%ocaml: actually could pass table in lex to yacc.
One way to implement a hash table in C is to use a big array
of lists, also known as an array of {\em buckets}:

<<global hash>>=
// hash<string, ref_own<Sym>> (next = Sym.link in bucket)
Sym*	hash[NHASH];
@
\n diff with h? this is assembler symbol table, not object file symbol table
<<constant NHASH>>=
#define NHASH       503
@
\l choose as a prime, see below
%ocaml: just use stdlib hashtbl

One way to implement a list of something in C is to embed in
this something a [[link]] field pointing to the next
element in the list:

<<[[Sym]] extra fields>>=
// list<ref<Sym>> (from = hash)
Sym*    link;
@
\n also of the object file symbol table h? no h is just an array actually.

The end of the list is represented by the null pointer:

<<constant S>>=
#define S   ((Sym*)nil)
@

%FIGURE? or standard C idiom?

The main interface to the symbol table are the
functions [[slookup()]] and [[lookup()]] below.
They both internally use the global [[hash]].
\l hmm so could hash be a semi global and used only by lookup?
[[slookup()]], given a name, returns the [[Sym]] in the
symbol table [[hash]] associated with this name, or
a new symbol if the name was not found:

<<function slookup>>=
Sym*
slookup(char *s)
{

    strcpy(symb, s);
    return lookup();
}
@
\l cleaner interface at least
%ocaml: use stdlib Hashtbl.find

[[slookup()]] modifies the global [[symb]] 
(used also by [[yylex()]] as you will see later) 
before calling [[lookup()]].
%ocaml: globals are bad, slookup cleaner than lookup, should not need symb

<<global symb>>=
char	symb[NSYMB];
@
<<constant NSYMB>>=
#define NSYMB       500
@
%old: was //#define	NSYMB		8192 on arm, not sure it matters

Here is finally the code of [[lookup()]]:

<<function lookup>>=
Sym*
lookup(void)
{
    Sym *sym;
    long h;
    int c;
    int len;
    <<[[lookup()]] other locals>>

    <<[[lookup()]] compute hash value [[h]] of [[symb]]>>

    // hash_lookup(symb, hash)
    c = symb[0];
    for(sym = hash[h]; sym != S; sym = sym->link) {
        // fast path
        if(sym->name[0] != c)
            continue;
        // slow path
        if(memcmp(sym->name, symb, len) == 0)
            return sym;
    }
    <<[[lookup()]] if symbol name not found>>
}
@
%old: s/s/sym/, s/l/len, less confusing I think
\l standard way to use a hash table, so we don't elaborate
%ocaml: use stdlib Hashtbl.find

%The code above is using a standard C idiom to iterate over a hash table.


If the symbol is not found in the symbol table,
a fresh symbol is created and added in the hash table:

<<[[lookup()]] if symbol name not found>>=
sym = alloc(sizeof(Sym));
sym->name = alloc(len);
memmove(sym->name, symb, len);

// add_hash(sym, hash)
sym->link = hash[h];
hash[h] = sym;

syminit(sym);
return sym;
@
%old: was memmove but memcpy better (jarod)

%The function below is called by [[lookup()]] when
%a new symbol is created to reset some of its fields:

<<function syminit>>=
void
syminit(Sym *sym)
{
    sym->type = LNAME;
    sym->value = 0;
}
@
\t not set symidx to 0?? because alloc = sbrk = zalloc



The hashing code below iterates over the characters in [[symb]]
until the end-of-string character ([[0]]). It also computes the length
of the symbol in [[len]]:

<<[[lookup()]] other locals>>=
char *p;
@

<<[[lookup()]] compute hash value [[h]] of [[symb]]>>=
// h = hashcode(symb); len = strlen(symb)
h = 0;
for(p=symb; c = *p; p++)
    h = h+h+h + c;
len = (p - symb) + 1;
if(h < 0)
    h = ~h;
h %= NHASH;
@




The symbol table [[hash]] is used (you could say abused) to 
represent and keep track of many different things in [[5a]]:

\begin{itemize}
\item {\em labels}, e.g., [[later:]], in which case [[Sym.value]]
contains eventually the value of the (virtual) program counter [[pc]]
at the label definition,
%ocaml: only thing needed

\item {\em symbols}, for procedures
(e.g., [[TEXT foo(SB)]]) and globals (e.g., [[GLOBL hello(SB)]]),
\l and also parameters and locals!
in which case [[Sym.value]] is not used because the addresses
of global symbols are not resolved by [[5a]] (but but [[5l]]).
%
However, another field of [[Sym]] is used to store
metadata about the symbol. This metadata will be stored in the 
symbol table of the object file
as you will see in Section~\ref{sec:symidx-sym-field}.
\n symidx, but actually not symkind which is in Gen, not Symbol.
\l also for SP and FP p _plus_ 0(FP)
\n Why need symbol in symbol table actually? to have a shared reference
\n which can store symidx which is used in outcode()


\item {\em macros}, e.g [[#define FOO]] ([[5a]] is
a macro-assembler that embeds its own macroprocessor), in which case
[[Sym.value]] is not used. Another field of [[Sym]] contains
the text of the macro as you will see in Section~\ref{sec:macro-sym-field}.
%ocaml: external cpp (update: actually now similar)

\item {\em symbolic constants}, e.g., [[RTMP = 10]], 
in which case [[Sym.value]] contains the constant value.
%ocaml: useless feature

\item {\em predefined identifiers}, 
\l use mnemonics?
for opcodes (e.g., [[MOVW]]) and registers (e.g., [[R1]]), in which case
[[Sym.value]] contains the appropriate enumeration value
(e.g., [[AMOVW]]).
\l ugly abuse
%ocaml: do in lexer instead, not abuse symbol table

\end{itemize}
\n because of hash that means all MOVW in a file are shared when lexing

Predefined identifiers are stored in the symbol table for
efficiency reason.
%ocaml: could use a different hash table
Indeed, the symbol table is first a hash table, and so
it can be (ab)used by the lexer to quickly check 
if an identifier corresponds to the mnemonic of an opcode or register.
One of the initialization functions of [[5a]], [[cinit()]],
resets and then populates [[hash]] with all the 
array elements of [[itab]] you have seen in the previous section:

<<[[cinit()]] locals>>=
Sym *s;
int i;
@
<<[[cinit()]] hash initialization from itab>>=
for(i=0; i<NHASH; i++)
    hash[i] = S;
for(i=0; itab[i].name; i++) {
    s = slookup(itab[i].name);
    s->value = itab[i].value;
    s->type = itab[i].type;
}
@

In the case of predefined identifiers, another field of [[Sym]]
is used to store the token code of the identifier
(in addition to the token value stored in [[Sym.value]]):

<<[[Sym]] token fields>>=
//enum<token_code> (e.g., LLAB, LNAME, LVAR, LARITH)
ushort  type;
@
\t also rename token_code? ? clearer then far later
\t  when access token stuff through Sym (which is an abuse)
\l see also itab[i].type and itab[i].value
\l used by?


\bigskip
[[Sym]] is part of the token union we have seen in
Section~\ref{sec:union}.
Indeed, the token value for 
symbols ([[LNAME]]), 
labels ([[LLAB]]), 
and symbolic constants ([[LVAR]])
is a direct reference to its [[Sym]] in the symbol table:

<<union declaration other fields(arm)>>=
Sym    *sym;    // for LNAME/LLAB/LVAR
@
\t mutual ref with sym here where sym has itself a type that is the token_kind

[[Sym]] is also a possible part of an operand when the operand
involves a symbol (or label):

<<[[Gen]] other fields>>=
// option<ref<Sym>> (owner = hash)
Sym*    sym;
@
%less: maybe should rename this field 'name'? and then use name_kind?
%ocaml: why need link? name not enough? need value just for labels

For example, in [[hello+4(SB)]], [[Gen.sym]] will point
to the symbol [[hello]] in the global [[hash]] table.
\t but what for? just for the name? symkind is part of Gen too
\t  For linker I understand the need because has Sym has pc, memory address,
\t  section, but in assembler? needs what properties of symbol?
\t  I think it's just for the name, to share a string ... so save a bit space.
\t  and also for labels it is useful to access its pc value.



\t FIGURE where see pointers, so symbol table like a tree
\l  and then one instr with some pointers! maybe two operands
\l  with two symbols (even though linker will say no)

%dead:
%<<[[Sym]] other fields>>=
%Ref*	ref; // unused for 5a, matters?
%@
%<<struct Ref>>=
%// only for 8a actually, and actually not used so I removed it
%struct	Ref
%{
%    int	class;
%};
%@



\section{[[Sym_kind]]}

%trans:
%Now that we have seen the [[Sym]] structure,
%we can present the [[sym]] field of the [[Gen]] structure:

For operands involving symbols, e.g., [[hello+4(SB)]],
an additional [[Gen]] field is used to represent
the {\em kind} of the symbol:

<<[[Gen]] other fields>>=
// option<enum<Sym_kind>> (None = N_NONE)
short   symkind;
@
%old: was called name, but confusing I think, name as a field was used in
% many structures and it's actually not a name
%less: rename to name_kind? rename also the sym field above?

<<enum sym_kind(arm)>>=
enum Sym_kind {
    N_NONE,

    N_EXTERN, // text/data/bss values (from SB)
    N_LOCAL,  // stack values (from SP)
    N_PARAM,  // parameter (from FP)
    <<[[Sym_kind]] cases>>
};
@
%ocaml: better included in ADT directly, Param vs Local vs Entity of bool
%old: this used to be with operand_kind, but they are really disjoint
% and used only for the ANAME pseudo opcode. In 5l/ there is
% actually a separate Dconv and Nconv (but in 8l/ they are together).
%old: was D_AUTO instead of D_LOCAL but ugly C
%old: was D_xxx but better N_xxx, anyway more consistent with Nconv

Thus, the C value of the operand in the example above is:
%example:
\begin{verbatim}
// operand value for: hello+4(SB)
{ .type = D_OREG;       // (...)
  .offset = 4;          // +4
  .sym = &<hello Sym>;  // hello
  .sym_kind = N_EXTERN; // SB
}
\end{verbatim}
\l could use reg? but then no need with (R12) and (SB)
\n the symkind is a property of the Gen and not Sym!
\l because people disambiguate at each use, foo(SB), foo _plus_ 0(FP), etc.

Finally, [[5a]] uses another operand kind, [[D_ADDR]],
%no special operand kind such as [[D_ADDR]]
to encode operands such as \$[[hello(SB)]]. 
%Instead the [[D_CONST]] type is (ab)used:

<<[[Operand_kind]] cases>>=
D_ADDR,
@
%pad: I introduced that! because in 5l there was always code where
% was anyway differentiating D_CONST with sym and D_CONST without.
% Note that there was a D_ADDR before but it was for something else.

Here is an example of C value for such an operand:

%example:
\begin{verbatim}
// operand value for: $hello(SB)
{ .type = D_ADDR;       // $
  .offset = 0;
  .sym = &<hello Sym>;  // hello
  .sym_kind = N_EXTERN; // SB
}
\end{verbatim}
%  .type = D_CONST;      // $

%There is no ambiguity with the representation of simple constants
%since the [[sym]] field in those cases would be null.
\n but means code in 5l need to each time if(...->symkind == D_NONE), annoying
\l moreover address is a kind of constant? actually make sense to use dollar
\l but what is the code generated?

% Assembler is outputing a (spread) symbol table in the object file.
% Important job of assembler is to prepare for linker, to enable
% the linker to link modules together and so to resolve references 
% to external symbols.

%note that can have symkind set but not necessarily a sym,
% but it's in the degenerated case of con ( pointer ) which
% I think should not happen (or should happen when don't care
% about naming the parameter so just do  4(FP) in which
% case sym can be seen as an anonymous symbol name.




%section{[[pc]]} ?










\chapter{Main Functions}
\label{chap:main}

\begin{verse}
\begin{flushright}
  {\it .There are two ways of constructing a software design: One way is to
        make it so simple that there are obviously no deficiencies, 
        and the other way is to make it so complicated that there are no
        obvious deficiencies. The first method is far more difficult.\\
    ~\\
    C.A.R Hoare}
\end{flushright}
\end{verse}


%trans: %dup: (but more precise) overview/book-structure
I now switch from a bottom-up approach in
Chapter~\ref{chap:core-ds}, to 
a top-down approach in this chapter.
%toc:
Indeed, I will describe the main functions of [[5a]], 
starting from [[main()]] down to [[assemble()]].

\section{[[main()]]}

%trans:
Before showing the code of [[main()]], I first introduce
a few globals set by [[main()]].


Two globals common in \plan code
are [[thechar]] and [[thestring]]. They both represent
the current architecture.
%dup: from intro/5a
As I said in Section~\ref{sec:plan9-assembler}, \plan by convention 
represents architectures with a single character: 
[['0']] is MIPS, 
[['5']] is ARM, 
[['8']] is x86, etc.
%
This character is used by [[5a]] for many things,
for instance, for the filename extension of 
object files (e.g., [[helloworld.5]]).
This character is stored in the following global:

<<global thechar>>=
int	thechar;
@
\l int? no char? then use Rune at least!
\n cant put = '5' here because this chunk is factorized for arm and x86

[[thestring]] contains the longer, more readable, version
of the architecture, e.g., [["arm"]] for [[5]].

<<global thestring>>=
char*	thestring;
@

[[thestring]] is used by [[5a]] to find 
architecture-specific system header files (e.g., in [[/arm/include/]]).
Indeed, [[5a]] is a macro-assembler and [[#include]] have
an {\em include search path}.
%(represented by the global [[include]] in [[main()]] below).

%trans:
I can now present the code of [[main()]], the entry point of [[5a]].
%
The most important thing in the code below is the call to [[assemble()]] at 
the end, with the filename of the assembly file to process 
passed through a command-line argument:

<<function main(arm)>>=
void
main(int argc, char *argv[])
{
    errorn err;
    <<[[main()]] locals>>

    thechar = '5';
    thestring = "arm";

    cinit();
    <<[[main()]] remaining initializations>>

    ARGBEGIN {
    <<[[main()]] command line processing>>
    } ARGEND

    if(*argv == '\0') {
        print("usage: %ca [-options] file.s\n", thechar);
        errorexit();
    }

    <<[[main()]] multiple files handling>>
    // else

    err = assemble(argv[0]);
    if(err > 0)
        errorexit();
    else
        exits(nil);
}
@
%ocaml: no need cinit, and include stuff can be done by outside cpp
%pad: I added the errorn err; and mv call to assemble outside if
%old: had    <<[[main()]] debug initialization>> earlier, but I put it
%  with remaining initializations

\l ref to chap:error for errorexit?

Another important global, set possibly by [[main()]],
is [[outfile]]. [[outfile]] stores the name of the output object file,
which can be modified by the [[-o]] option:

<<global outfile>>=
char*	outfile = nil;
@
\l hmm could be 5.out instead no? hmm no, it will be set
\l to {basename(input_file)}.{thechar} in assemble()

<<[[main()]] command line processing>>=
case 'o':
    outfile = ARGF();
    break;
@

The macros [[ARGBEGIN]], [[ARGEND]], and [[ARGF]], used 
in [[main()]] above, are defined in the C library 
(see the \book{Libcore}). 
They allow to iterate over command-line arguments in a simple way.




\section{[[cinit()]]}
\t rename to just init? why the C?

[[cinit()]], called from [[main()]],
contains the initializations of a few globals:
%ocaml: do not need that as initializations are more flexible in ocaml

<<function cinit(arm)>>=
/// main -> <>
void
cinit(void)
{
    <<[[cinit()]] locals>>

    <<[[cinit()]] nullgen initialization>>
    <<[[cinit()]] hash initialization from itab>>
    <<[[cinit()]] pathname initialization from cwd>>
}
@
%old: used to do more initialization here, but instead move the init at def loc
\n very similar to the x86 version, except the few change for nullgen fields

I mentioned before the global [[nullgen]] in Section~\ref{sec:nullgen}.
Here is the code initializing [[nullgen]]:

<<[[cinit()]] nullgen initialization>>=
nullgen.type    = D_NONE; // no operand type set yet
nullgen.reg     = R_NONE;
nullgen.symkind = N_NONE;
nullgen.sym = S;
nullgen.offset = 0; // part of a union
@

\ifallcode
<<[[cinit()]] nullgen initialization>>=
if(FPCHIP)
    nullgen.dval = 0;
for(i=0; i<sizeof(nullgen.sval); i++)
    nullgen.sval[i] = 0;
@
\fi
%todo: now that I use an union, this code is valid about dval and sval?
% can't use N_NONE because this function is in aa/ and N_NONE is
% in 5a/a.h
%ocaml: merge with def, use nice record syntax


% cwd, for #include "" (cwd can change as one include other files)
%  =~ dirname(current_file)

\label{sec:pathname}
[[pathname]] below represents the {\em current working directory} (CWD). 
This global will be used when [[5a]] generates debugging information in
the object file (see Section~\ref{sec:object-file-history}).

<<global pathname>>=
char*	pathname;
@
%less: rename? dirname_of_input_file? (actually it's really
% dirname_of_current_input_file as 5a can process multiple files,
% but it would complicate things; multifile is an advanced topic)

<<[[cinit()]] pathname initialization from cwd>>=
pathname = allocn(pathname, 0, 100);
if(getwd(pathname, 99) == 0) {
    pathname = allocn(pathname, 100, 900);
    if(getwd(pathname, 999) == 0)
        strcpy(pathname, "/???");
}
@


\section{[[assemble()]]}
\label{sec:assemble}

%trans:
The most important function called from [[main()]] is 
[[assemble()]]. This is where resides most of the assembling logic.
%
Because a programmer can reference labels defined later in an assembly file,
a common approach for assembling is to use a {\em two-pass} algorithm.
The first pass focuses on the {\em definitions} of labels;
by the end of the file, the values of all labels are known.
The second pass focuses on the {\em uses} of labels; the second
pass leverages the information computed in the first pass.
%
This is the strategy used by [[5a]]
and so an important global is [[pass]], which stores
in which pass we currently are (1 or 2):
\l alternatives to two-pass algo: lazy, patch back

<<global pass>>=
// 1|2
int	pass;
@
%ocaml: need this to be a global? could instead parse asm, return AST
% and then algo in two passes on the AST, a visitor and then generator.

[[pass]] is set by [[assemble()]] below. It is then used
in a few places in the grammar as well as in [[outcode()]] 
as you will see later:

<<function assemble>>=
errorn
assemble(char *infile)
{
    fdt of; // outfile
    <<[[assemble()]] locals>>

    <<[[assemble()]] set p to basename(infile) and adjust include>>
    if(outfile == nil) {
        <<[[assemble()]] set outfile to {basename(infile)}.{thechar}>>
    }
    <<[[assemble()]] setinclude("/{thestring}/include") or use INCLUDE>>

    of = mycreat(outfile, 0664);
    <<[[assemble()]] sanity check [[of]]>>
    Binit(&obuf, of, OWRITE);

    // Pass 1
    pass = 1;
    pinit(infile);
    <<[[assemble()]] init Dlist after pinit>>
    yyparse(); // calls outcode(), which does almost nothing when pass == 1
    <<[[assemble()]] sanity check nerrors>>

    // Pass 2
    pass = 2;
    outhist(); // output file/line history information in object file
    pinit(infile);
    <<[[assemble()]] init Dlist after pinit>>
    yyparse(); // calls outcode() which now does things

    cclean();
    return nerrors;
}
@
%old: I renamed parameter to infile, to better contrast with outfile
%ocaml: use exception, no need fdt and buf intermediate, use Marshall
% no need 2 parse, just return AST and resolve() and save_obj()
\t mycreat -> create directly, remove compat.c

<<[[assemble()]] sanity check [[of]]>>=
if(of < 0) {
    yyerror("%ca: cannot create %s", thechar, outfile);
    errorexit();
}
@
% speech about sanity check?
\t aspectize sanity check? everytime there is a call to yyerror we could.
\t  but maybe it's ok for this book. Error managment code is small and rare.

[[assemble()]] calls [[yyparse()]]
two times, with the appropriate value set in [[pass]] first, 
and after having also initialized some globals related to the input file 
with [[pinit()]].
%
This means the input assembly file is parsed two times, but
the actions in the grammar do different things the second time.
%ocaml: ugly globals, dont see clearly, also ugly parse two times


[[assemble()]] returns the number of errors it found
or zero if everything went fine. 
%
The functions called from [[assemble()]] increment the global
[[nerrors]] to indicate an error, hence the check below:

<<[[assemble()]] sanity check nerrors>>=
if(nerrors) {
    cclean();
    return nerrors;
}
@

See Appendix~\ref{chap:error} for more information on 
the error management in [[5a]].


Another global initialized by [[assemble()]] is [[obuf]],
the {output buffer} that will contain the content
of the object file generated by [[5a]]:

% outfile(filename) -> of(fd) -> obuf(biobuf)
<<global obuf>>=
Biobuf	obuf;
@
%ocaml: why another global, ugly, because yyparse inflexible?

This global will be used notably by [[outcode()]].
%
The type of [[obuf]] is [[Biobuf]] (for ``buffered input/ouput buffer'').
[[Biobuf]] is part of the [[libbio]] \plan library; its interface
is quickly described in Appendix~\ref{sec:libbio}.


The main output data flow in [[assemble()]] is to go from
the name of the output file ([[outfile]]), 
to an output file descriptor ([[of]]),
to finally an output buffer ([[obuf]]).


Note that [[5a]] relies on many globals for outputting data (e.g., [[obuf]]),
as well as for inputting data 
(as you will see in the code of [[pinit()]] later),
which makes the code harder to read. 
%
This is because [[yyparse()]], the function generated by Yacc,
does not take any argument nor return anything, so the
interface of [[yyparse()]] imposes to use globals.


The function below is called just before returning from [[assemble()]]. 
%
[[cclean()]] adds the last instruction in the object file.
This instruction uses the special opcode [[AEND]].
%
[[AEND]] is a special marker convenient to have 
when dealing with {libraries} in [[5l]] (see the \book{Linker}).
Indeed, libraries are little
more than object files concatenated together; the
[[AEND]] opcode represents a {boundary} between object files.
\n need AEND? yes, the linker wants an AEND, and I think
\n when use a library, can have multiple objects concatenated
\n in which case AEND is a marker for the end of an object.
\n and to facilitate the job of ldobj, easy to use opcode too.
%ocaml: no need, libraries can be just Marshall of lists! boundaries clear!

\label{sec:cclean}
<<function cclean(arm)>>=
/// main -> assemble -> <>
void
cclean(void)
{

    outcode(AEND, Always, &nullgen, R_NONE, &nullgen);
    Bflush(&obuf);
}
@
%ocaml: not sure need that, should be done by ar or 5l



The remaining code in [[assemble()]] consists mostly in
filename manipulations and modifications of globals used
for [[#include]] processing.
%
Those filename manipulations use the temporary variable [[ofile]]:
%which is used to compute [[outfile]] later:
<<[[assemble()]] locals>>=
char ofile[100];
@
\t buffer overflow in strcpy below, add a check!

This temporary is then used to compute [[outfile]].
%
The value of [[outfile]] is derived automatically from
the input file [[infile]] (unless you used the [[-o]] option of [[5a]]).
%
For example, given the input file [[/tests/5a/foo.s]], [[5a]] will
generate the object file in the output file [[foo.5]] in the current
directory.
\l so does not generate in dirname of infile! like 5c, can do
\l 5c -c /path/to/x.c in mkfile and it will generate in current dir
%
Figure~\ref{fig:assembler-ofile-outfile} illustrates
the evolution of [[ofile]], [[outfile]], [[infile]], and
the local variable [[p]] while executing
the code below when the input file is [[/tests/5a/foo.s]].


\begin{figure}[!]\centering
\begin{verbatim}
          +--------------------+
 infile:  |/tests/5a/foo.s     |
(argv[0]) +--------------------+               start
          0                         100          of
          +--------------------------+        assemble
  ofile:  |                          |
          +--------------------------+
outfile:   nil
      p:   nil

                     p                        after
          0          |              100      setting
          +----------v---------------+         p to
  ofile:  |/tests/5a|foo.s           |       basename
          +--------------------------+


                  outfile
                     |  p
          0          |  |           100    just after
          +----------v--v------------+        call
  ofile:  |/tests/5a|foo.s           |         to
          +--------------------------+      utfrrune


                  outfile
                     |  p
          0          |  |            100
          +----------v--v------------+        end
  ofile:  |/tests/5a|foo.5           |         of
          +--------------------------+      assemble

\end{verbatim}
\caption{Evolution of [[ofile]] and other variables in [[assemble()]].}
\label{fig:assembler-ofile-outfile}
\end{figure}


<<[[assemble()]] locals>>=
char *p;
@
<<[[assemble()]] set p to basename(infile) and adjust include>>=
// p = basename(infile)
strcpy(ofile, infile);
p = utfrrune(ofile, '/');
if(p) {
    *p++ = '\0';
    <<[[assemble()]] adjust first entry in include with dirname infile>>
} else
    p = ofile;
@
%ocaml: just use Filename stdlib

The function [[utfrrune()]] (for ``UTF reverse rune search'')  called above
comes from the C library and
returns the {\em last} occurrence of a rune in a string.
%
A {\em rune} is a Unicode character in \plan terminology
(see the \book{Libcore} for more information about Unicode and runes).
[[5a]] accepts filename arguments using unicode characters, hence
the use of [[utfrrune()]] above and below.

<<[[assemble()]] set outfile to {basename(infile)}.{thechar}>>=
// outfile =  p =~ s/.s/.5/;
outfile = p;
if(outfile){
    p = utfrrune(outfile, '.');
    if(p)
        if(p[1] == 's' && p[2] == '\0')
            p[0] = '\0';
    p = utfrune(outfile, '\0');
    p[0] = '.';
    p[1] = thechar;
    p[2] = '\0';
} else
    outfile = "/dev/null";
@
%ocaml: use Common.matched1






\chapter{Input}
\label{chap:input}

%trans:
Now that you have seen [[assemble()]], I can start
explaining the different components in the assembling
pipeline, starting in this chapter with the input functions.

%toc:
The most important functions I will present in this chapter are
[[pinit()]] and [[GETC()]].
%
I mentioned before [[pinit()]]; it initializes globals related to input.
%
[[GETC()]], which is called by the lexer [[yylex()]]
(called itself by the parser [[yyparse()]]),
uses those globals to return the next character from the input assembly file.
\n (or one of its included file). but too subtle for now?

\section{[[pinit()]]}
\label{sec:pinit}
\t rename pass_init? parse_init?

%dup: main/assemble? input 
[[pinit()]] initializes a few globals related to input.
%
It is called at the beginning of each pass in [[assemble()]]
(see the code of [[assemble()]] in Section~\ref{sec:assemble}):

<<function pinit>>=
/// main -> assemble -> { <> ; yyparse } x 2
void
pinit(char *f)
{
    <<[[pinit()]] locals>>

    lineno = 1;

    newio(); // set ionext
    newfile(f, FD_NONE); // use ionext, set iostack, set fi

    <<[[pinit()]] initializations>>
}
@
%ocaml: external cpp so no need newio, etc, and one pass lexing so no need line
% initialization here

\ifallcode
<<[[pinit()]] locals>>=
int i;
Sym *s;
@
\fi

\label{sec:lineno}
The [[lineno]] global, set above, tracks the current line number;
[[lineno]] will be incremented by the lexer after each newline. 

<<global lineno>>=
long	lineno;
@
\t Is it after #include expansion? global line number, subtle
\l rename glineno?
%ocaml: could be embedded in the token, so no need global, no need getc
% vs GETC, unget, etc. Less mess. But in the end simple to be in global.

[[lineno]] is used in the object code generator to remember from where each
instruction comes from. This will be useful for debugging
as explained in Chapter~\ref{chap:debugging}.

%toc:
The calls to [[newio()]] and [[newfile()]] in [[pinit()]] above
will be explained in the following sections.

\section{File management, [[iostack]]}
\label{sec:iostack}

[[5a]] is a macro-assembler. Moreover, [[5a]] embeds in its code 
its own [[cpp]]-like preprocessor
\footnote{
Note that [[5a]] could instead rely on an external 
preprocessor. However, 
% which would factorize code with [[5c]],
\l actually they factorized a bit originally bug was ugly lexbody, macbody, etc
doing so would be slower because of the need to fork
another process in the assembling pipeline.
\n meh, better to separate concern and have cpp in a different program?
}.
%
Because [[5a]] supports [[#include]], the input assembly file can include
other files, which themselves can include other files, and so on.
%
Thus, [[5a]] may have to open many files.
Moreover, when a file has been fully processed, [[5a]] needs to go back
to the file which was including it, the {\em includer}.
%
This suggests the use of a {\em stack} data structure
to represent the stack of opened input files.


The structure below represents an element of this stack.
It is essentially a file descriptor referencing an opened file:

<<struct Io>>=
struct  Io
{
    // option<fdt> (None = FD_NONE)
    fdt f;
    <<[[Io]] buffer fields>>
    // Extra
    <<[[Io]] extra fields>>
};
@
\n hmm, could they use shorter fieldnames ...

<<constant FD_NONE>>=
#define FD_NONE (-1)
@

The global [[iostack]] below represents the {top} of the stack, that
is the current file being scanned:

<<global iostack>>=
// list<ref_own<Io> (next = Io.link)
Io*	iostack = I;
@
% used to be set in cinit()

[[5a]] uses a list data structure to represent the stack of opened files:

<<[[Io]] extra fields>>=
// list<ref_own<Io>> (from = iostack or iofree)
Io* link;
@
<<constant I>>=
#define I   ((Io*)nil)
@


The main job of [[newio()]], called from [[pinit()]]
(see Section~\ref{sec:pinit}),
\n also called from macinc
is to make the global [[ionext]] point to a newly allocated [[Io]]
that can be used later by [[newfile()]] (also called from [[pinit()]]):
%ocaml: so many globals

<<global ionext>>=
// option<ref<Io>>
Io*	ionext;
@

<<function newio>>=
/// main -> assemble -> pinit -> <>; newfile
void
newio(void)
{
    Io *i;

    <<[[newio()]] allocate a new Io in [[i]] or find a free one>>
    ionext = i;
    i->f = FD_NONE;
    i->c = 0;
}
@
%ocaml: why not return it? because dont want caller to free it?

The [[Io]] allocator mentioned in the code above 
could be simply a call to [[malloc()]].
The matching call to [[free()]] should then be in the code that
closes the opened file when the content is fully read.
Instead, [[5a]] uses the common C technique of a {\em free list}
to manage [[Io]]s.
%
By using a free list, [[5a]] can ``recycle'' an [[Io]] 
for another file:

<<global iofree>>=
// list<ref<Io>> (next = Io.link)
Io*	iofree = I;
@

<<[[newio()]] allocate a new Io in [[i]] or find a free one>>=
static int pushdepth = 0;

i = iofree;
if(i == I) {
    <<[[newio()]] sanity check depth of macro expansion>>
    i = alloc(sizeof(Io));
} else
    // pop(iofree)
    iofree = i->link;
@

<<[[newio()]] sanity check depth of macro expansion>>=
pushdepth++;
if(pushdepth > 1000) {
    yyerror("macro/io expansion too deep");
    errorexit();
}
@
\l no error checking code of return of alloc?

[[newfile()]], which assumes [[ionext]] has been set
correctly in [[newio()]], can finally open the input assembly file:

<<function newfile>>=
/// main -> assemble -> pinit -> { newio; <> }
/// yylex -> macinc -> <>
void
newfile(char *s, fdt f)
{
    Io *i;

    // add_list(ionext, iostack)
    i = ionext;
    i->link = iostack;
    iostack = i;

    i->f = f;
    if(i->f == FD_NONE)
        i->f = open(s, OREAD);
    <<[[newfile()]] sanity check [[i->f]]>>
    fi.c = 0;
    <<[[newfile()]] call linehist>>
}
@
%pad: 0 -> OREAD
\l [[fi.c]] is explained later, grrr

<<[[newfile()]] sanity check [[i->f]]>>=
if(i->f < 0) {
    yyerror("%ca: %r: %s", thechar, s);
    errorexit();
}
@
\t percent r, refer to error management function

\section{Buffer management, [[fi]]}

Once the input file is opened
(and accessible in [[iostack->f]]),
the lexer needs to look at its content one character at a time.
%
Instead of using many system calls such as [[read(..., 1)]] to read
one character at a time, which would be slow,
[[5a]] instead calls
[[read()]] once in a while to fill a large {\em input buffer}. 
%
[[5a]] then uses auxiliary functions to move pointers in this buffer. 
%
This buffer is simply an array of characters stored in [[Io.b]]:
\l why not use libbio?
%ocaml: buffered IO should be done in library

<<[[Io]] buffer fields>>=
char    b[BUFSIZ];
@
<<constant BUFSIZ>>=
#define BUFSIZ      8192
@
%ocaml: just use ocamllex which internally does that

Each opened file has its own input buffer.
%
This buffer will be referenced by fields in the global
below. 
%A few functions below are using the global [[fi]] below.

<<global fi>>=
struct Fi fi;
@

Indeed, the global [[fi]] contains pointers in the input buffer of 
the currently processed input file:

<<struct Fi>>=
struct Fi
{
    // ref<char> (target = Io.b)
    char*   p;
    // remaining characters in Io.b to read
    int     c;
};
@
\l File input
\l could use directly iostack->p and iostack->c, no need for this cache

Once [[5a]] processed an included file, [[5a]] needs to
go back to the includer file 
(which can be found easily thanks to [[iostack->link]]). 
%
However, [[5a]] needs to remember
in which position it was in the includer file, hence those extra fields:

<<[[Io]] buffer fields>>=
// like Fi, saved pointers in Io.b
char*   p;
short   c;
@
\l unicode input but here char pointer!

\section{[[GETC()]]}

I can finally show the code of [[GETC()]], which
will use the globals [[iostack]] and [[fi]] I mentioned before.
%dup: input
[[GETC()]] is a macro called many times in [[yylex()]] to
get the next character from the input file:
%[[GETC()]] uses the global [[fi]] you have seen above:

<<function GETC>>=
/// main -> assemble -> yyparse -> yylex -> <>
#define GETC()      ((--fi.c < 0) ? filbuf() : *fi.p++ & 0xff)
@
\l a bit tricky; also unicode but here 0xff, so it's a character!
\l 5a does not handle unicode characters in its input (but it accepts
\l unicode characters as command-line arguments)
%ocaml: use ocamllex which does that internally

[[GETC()]] is a complicated macro.
Moreover, it relies also on the complicated function below:

<<function filbuf>>=
int
filbuf(void)
{
    Io *i;

loop:
    i = iostack;
    <<[[filbuf()]] if no more input files in the stack>>

    // system call! fill the buffer
    fi.c = read(i->f, i->b, BUFSIZ) - 1;
    <<[[filbuf()]] if no more character to read>>
    // else
    fi.p = i->b + 1;
    return i->b[0];

<<[[filbuf()]] pop>>
}
@
\l return int or char?
%dead?:
%    if(i->f < 0) // When this happens?
%        goto pop; 

Figure~\ref{fig:input-buffer} represents the evolution of the state
of [[fi]] while the input buffer gets filled during a call to [[GETC()]].


The [[-1]] applied after the call to [[read()]]
above is needed because [[Fi.c]] represents the remaining
characters to read. Thus, if [[read()]] returns only 1,
meaning only one character was read, then this character
will be returned by [[fillbuf()]] (with the code [[return i->b[0]]]),
so there is nothing else to read after.
%
In that case, [[Fi.c]] should be 0, hence the [[-1]].


\begin{figure}[!]\centering
\begin{verbatim}
0                                                      8192 
+-------------------------------------------------------+
|                                                       |
+-------------------------------------------------------+
^
|                             
fi.p   (fi.c = 0)

(a) Empty buffer in iostack->b

0                                                      8192 
+-------------------------------------------------------+
|l|a|t|e|r|:|              ...                |M|O|V|W| |
+-------------------------------------------------------+
  ^<---------------------------------------------------->
  |                       fi.c = 8191
  fi.p 

(b) After the first call to GETC(). fillbuf() returned 'l', 
    incremented fi.p, and decremented fi.c

\end{verbatim}
\caption{Evolution of the input buffer after first call to [[GETC()]].}\label{fig:input-buffer}
\end{figure}


When there is nothing more to read in the file,
[[5a]] needs to ``pop'' the file from [[iostack]] and
updates [[fi]] to point to the input buffer of the includer file:

<<[[filbuf()]] if no more character to read>>=
if(fi.c < 0) {
    close(i->f);
    <<[[filbuf()]] when close file, call linehist>>
    goto pop;
}
@


<<[[filbuf()]] pop>>=
pop:
    // pop(iostack)
    iostack = i->link;
    // push(i, iofree)
    i->link = iofree;
    iofree = i;

    // i = top(iostack), the fresh top of the stack input file
    i = iostack;
    <<[[filbuf()]] if no more input files in the stack>>
    // restore file pointers
    fi.p = i->p;
    fi.c = i->c;
    if(--fi.c < 0)
        goto loop;
    // else, return one character
    return *fi.p++;
@

[[5a]] uses a few constants to represent special characters.
They are negatives to not conflict with regular characters.
\n but yylex does not accept unicode I think (but cpp-related getsym() does)
[[EOF]] (for ``end of file'') below is one of those special
characters:
%real-world: classic, same issue in ocamllex

<<constant EOF>>=
#define EOF     (-1)
@

[[fillbuf()]] (and then [[GETC()]] and [[yylex()]]) returns this
constant when there is no more character to read:

<<[[filbuf()]] if no more input files in the stack>>=
if(i == I)
    return EOF;
@

[[EOF]] will be used by [[yyparse()]] to avoid calling [[yylex()]]
another time when there is nothing more to read.

%Note that even [[5a]] does not accept unicode characters. [[GETC()]]
%returns only basic characters. The type of [[Fi.p]] and [[Io.b]]
%are [[char]] pointers.
\l and so? there are functions later that reconstruct unicode from
\l set of chars? what if incomplete unicode char in buffer boundary?







\chapter{Lexing}
\label{chap:lexing}

%trans:
The next component in the assembling pipeline is the lexer
function [[yylex()]], called by the parser function [[yyparse()]].
%trans: %dup: input input/GETC
[[yylex()]] relies on [[GETC()]], 
which I described in ~Chapter~\ref{chap:input},
to get the next character in the currently processed input file.
\l (that is iostack->f )
%context: yyparse -> yylex -> GETC

\section{[[yylex()]]}

Even though [[5a]] is not using Lex~\cite{lex}, Yacc requires
\t why not use Lex? (same question asked in soft archi section)
% maybe to avoid bootstrapping issues?
% hmm but they use yacc so ... (and lex uses yacc)
% or maybe because if want to have builtin-cpp, easier to do without Lex?
to name the lexer function [[yylex()]]. 
%
This function does not take any
argument (hence the use of many globals), and must return one
of the element below:
\begin{itemize}

\item A {\em token code} (see Section~\ref{sec:token})

\item [[-1]] (represented by EOF), when there is no more token to read

\item A single character, if the token is simply a single character

\end{itemize}
%ocaml: EOF needs special care also in ocamlyacc and ocamllex

Here is the signature of [[yylex()]]:

<<signature yylex>>=
// unit -> (enum<token_code> | -1 (EOF) | char)
long    yylex(void);
@
%ocaml: ugly abuse long

[[yylex()]] can also modify the global [[yylval]] 
to store the {\em token value} of the token.
%
The type of [[yylval]] is a union type I described in Section~\ref{sec:token}.
This token value can then be retrieved via the \$$n$ notation
in the Yacc actions, as you will see in Chapter~\ref{chap:parsing}.


[[yylex()]] is essentially an {\em automata} 
reading characters 
%(with [[GETC()]]) 
in a loop while
%(with the label [[l0:]] and [[goto]] below) and
using a big [[switch]] on the current character read 
%([[c]])
to transition states 
%(using more labels and [[goto]]s as we will see), 
until a full token is formed.
\l FIGURE with automata?
%ocaml: should use lex. Simpler. 
To read characters, [[yylex()]] uses [[GETC()]], 
to loop it uses the label [[l0:]] below and some [[goto l0]] statements,
and to transition state it uses more labels and [[goto]]s
as you will see soon.
%
Here is finally the skeleton of [[yylex()]]:

<<function yylex>>=
/// main -> assemble -> yyparse -> <>
long
yylex(void)
{
    int c;
    <<[[yylex()]] locals>>

    <<[[yylex()]] peekc handling, starting part>>
l0:
    c = GETC();
l1:
    if(c == EOF) {
        return EOF;
    }

    if(isspace(c)) {
        <<[[yylex()]] if c is newline>>
        // ignore spaces
        goto l0;
    }
    // else

    <<[[yylex()]] before switch, if isxxx>>
    switch(c) {
    <<[[yylex()]] switch c cases>>
    default:
        return c;
    }
    <<[[yylex()]] peekc handling, ending part>>
    return c;
}
@
%old: was return -1, but return EOF better I think
%dead? peekc = EOF;  in if(c== EOF), I think is needed.
% it helps to skip a futur call to GETC in yylex() but anyway
% GETC would work and return EOF too.
%ocaml: ugly to not take any input and use globals. Should take a lexbuf!
% also with pattern character range no need ugly isalpha and isdigit
\t now return a long, fillbuf was returning an int. hmmm
\t  but because imposed interface by yyparse?
\t must return int at least because token code is more than a char


%toc:
In the next sections, I will show the code of the
different cases in the [[switch]] above.

\section{Peek, seek, and look ahead}

When trying to identify a token, for instance, an identifier, it is
frequent to read characters until the current character
does not satisfy a certain criteria, for instance, being a letter.
%
In that case, you have read too far in the input file
and should go back one character. One technique
is to use [[seek()]] to go back.
%
Another technique is to store instead in a global this extra character.
This is the strategy used by [[5a]] with the global [[peekc]]:

<<global peekc>>=
// option<char> (None = IGN)
int	peekc = IGN;
@
\n use Rune? nope.
\l =~ yyback(1) trick, used by yylex() and getc(), and cpp (unget), cg?
%old: used to be set in cinit()

%alt: use Biobuf, can get and unget character.

<<constant IGN>>=
#define IGN     (-2) // Ignore
@
\l also negative, -2 because EOF is -1 already used

<<[[pinit()]] initializations>>=
peekc = IGN;
@
%ocaml: no need that with ocamllex behavior to look for longer and
% internally manage peekc/yyback


Then, we need to make sure the function reading characters 
from the input file ([[yylex()]]) first looks in this global
before trying to read any new character:

<<[[yylex()]] peekc handling, starting part>>=
c = peekc;
if(c != IGN) {
    peekc = IGN; // consume the extra character saved in peekc
    goto l1; // skip the GETC(), we already have a character in c
}
@
%ocaml: ocamllex handles that

In the sections below, the local [[c1]] will be used
to store the {\em look ahead} character when the lexer needs to read
an extra character in addition to [[c]] to decide
what to do:

<<[[yylex()]] locals>>=
int c1;
@
\n need that? why not modify peekc directly? because not automatic!

This extra character is considered by default the
peek character for the next call to [[yylex()]]
(unless [[yylex()]] returns before):

<<[[yylex()]] peekc handling, ending part>>=
peekc = c1;
@



\section{Newlines (and semicolons)}
\label{sec:semicolon}

%dup: from overview/input-lang
As I mentioned in Section~\ref{sec:asm5-lexical},
[[5a]] transforms internally newlines in semicolons.
%
This transformation is done in [[yylex()]]:
%are recognized as instruction terminators in the Asm5 grammar:
\n and not separators

<<[[yylex()]] if c is newline>>=
if(c == '\n') {
    lineno++;
    return ';'; // newline transformed in fake ';'
}
@
\l note also lineno plus plus

The grammar of Asm5 then uses those semicolons
as instruction terminators (see Section~\ref{sec:semicolon-terminator-grammar}).

Note that because the semicolon token is a single character, it can
be returned directly by [[yylex()]]. 
There is no need to introduce a [[LSEMICOLON]] token code.


%for jarod:
As we will see in Section~\ref{sec:empty-instr}, the grammar
of Asm5 allows empty instructions, so empty lines with just
a newline, or lines with only comments, will not pose any problem.


%old:
%<<[[yylex()]] switch c cases>>=
%case '\n':
%    lineno++;
%    return ';';
%@
% can be reached? with isspace(c) above, this code seems unreachable


\section{Comments}
\label{sec:yylex-comments}

Asm5 comments use the same syntax than C comments
(e.g., [[/* foo */]], [[// foo]]). They are skipped
by the lexer, hence the [[goto]] back to [[l0]] (or [[l1]])
below:

<<[[yylex()]] switch c cases>>=
case '/':
    c1 = GETC();
    if(c1 == '/') {
        // '/''/' read; skip everything until next '\n'
        for(;;) {
            c = GETC();
            if(c == '\n')
                goto l1; // which will convert the \n in c in a ';'
            if(c == EOF) {
                yyerror("eof in comment");
                errorexit();
            }
        }
    }
    if(c1 == '*') {
        // '/''*' read; skip everything until next '*''/'
        for(;;) {
            c = GETC();
            while(c == '*') { // not an if! to handle /** not finished */
                c = GETC();
                if(c == '/')
                    goto l0;
            }
            if(c == EOF) {
                yyerror("eof in comment");
                errorexit();
            }
            if(c == '\n')
                lineno++;
        }
    }
    break;
@
\l put getcom() here too?
\l important not forget lineno! also while not if subtle :)

%real-world: usually use ';' for comment in masm/tasm

\section{Mnemonics, symbols, and labels}
\label{sec:yylex-identifiers}

%trans:
Until now, [[yylex()]] was mostly skipping characters (spaces and comments),
or returning a single character (a semicolon). 
%
For identifiers, [[yylex()]] needs to accumulate a set 
of characters and look if those characters correspond to a know 
mnemonic, symbol, or label.
%
The local [[cp]] below will point in the [[symb]] global buffer
I introduced in Section~\ref{sec:sym}.
%
Remember that the global [[symb]] is used by [[lookup()]] 
to look for predefined identifiers,
labels, or symbols, in the global symbol table [[hash]].
\t itab!

<<[[yylex()]] locals>>=
// ref<char> (target = symb)
char *cp;
// ref<Symbol> (owner = hash)
Sym *s;
@

Here is the code that uses [[cp]], [[symb]], and the local variable [[s]] 
to recognize an identifier:

<<[[yylex()]] before switch, if isxxx>>=
if(isalpha(c))
    goto talph;
@
%ocaml: powerful case, character range ftw, or use regexp alias in ocamllex

<<[[yylex()]] switch c cases>>=
case '_':
case '@':
// case 'a'..'z' 'A'..'Z': (isalpha())
talph:
    cp = symb;

aloop:
    *cp++ = c;
    c = GETC();
    if(isalpha(c) || isdigit(c) || c == '_' || c == '$')
        goto aloop;
    // went too far
    peekc = c;

    *cp = '\0';
    s = lookup(); // uses symb global (referenced by cp)
    <<[[yylex()]] if macro symbol>>
    <<[[yylex()]] in identifier case, set yylval>>
    return s->type;
@
%$
%ocaml: use of peekc is yyback(1), but no need in ocamllex
\l @? maybe remove it so it would also remove the need for LAT token_kind
\t possible to have s->type == 0? if new sym theni it is set to LNAME in syminit
\t actually does not handle unicode identifiers? how works assembler in go?
%dead?
%    if(s->type == 0) // when can this happen? syminit set already to LNAME
%        s->type = LNAME;

Remember that [[yylex()]] must return to [[yyparse()]] a token code
when the token is not a single character.
%
[[Sym.type]], used in the expression [[s->type]] above,
contains the token code of the recognized symbol
(e.g., [[LARITH]] if the identifier was an arithmetic opcode like [[ADD]]).

The global [[yylval]] must then contain the token value.
%
For labels and symbols, the token value is a pointer to a [[Sym]];
for predefined identifiers, it is the value of an enumeration
(e.g., [[AADD]]).

<<[[yylex()]] in identifier case, set yylval>>=
if(s->type == LNAME || s->type == LLAB || s->type == LVAR) {
    yylval.sym = s;
} else {
    yylval.lval = s->value;
}
@
%ocaml: ugly to have lexer/parser side effect, solve label in resolve()
% after lexing/parsing
\l eg AADD in s->value

\t note that LLAB set in grammar! so in pass2 or if defined before
\t then return different token_kind! not context free. but need that??

\section{Numbers}

%trans:
Numbers are a bit more complicated to parse than what
we have seen until now.
%
Indeed, 
Asm5 allows to use different kinds of numbers with different syntax.
%
Just like in C, in Asm5 you can use
decimals ([[12]]), 
hexadecimals ([[0xa12]]), 
octals ([[0777]]),
or floats ([[0.2]], [[1e3]]) in your assembly program.
%or typed integers ([[1uL]]). (No more, I removed the code)
%
The code below use different labels and [[goto]]s
to transition to different states where each state
recognizes a different kind of number:

<<[[yylex()]] before switch, if isxxx>>=
if(isdigit(c))
    goto tnum;
@
<<[[yylex()]] switch c cases>>=
// case '0'..'9': (isdigit())
tnum:
    cp = symb;
    if(c != '0')
        goto dc;
    // else, read a '0', maybe the start of an hexadecimal number
    <<[[yylex()]] in number case, 0xxx handling>>

<<[[yylex()]] in number case, decimal dc label handling>>
<<[[yylex()]] in number case, float labels handling>>
@

Note that the code above also (ab)uses [[cp]] and [[symb]] to
accumulate characters (but this time there will be no call to [[lookup()]]).

%toc:
I will explain the chunks referenced in the code above in the
following sections.

%old:
%<<[[yylex()]] in number case, if vlong lval>>=
%if(sizeof(yylval.lval) == sizeof(vlong))
%    yylval.lval = strtoll(symb, nil, 10);
%else
%@
% dead code for 5a and 8a I think


\subsection{Decimal numbers}
\label{sec:yylex-decimal-numbers}

%trans:
The first label (and state) used to recognize numbers
%
is [[dc]] (for ``decimal'').
[[yylex()]] jumps to this label when the first digit
is not zero.
%
[[yylex()]] then reads more digits until the next character is not a
digit anymore:

<<[[yylex()]] in number case, decimal dc label handling>>=
dc:
    for(;;) {
        if(!isdigit(c))
            break;
        *cp++ = c;
        c = GETC();
    }
    <<[[yylex()]] in number case, in decimal case, float handling>>
    *cp = '\0';
    yylval.lval = strtol(symb, nil, 10);

    peekc = c;
    return LCONST;
@
%old:    <<[[yylex()]] in number case, if vlong lval>>
%dead? assembly using that? anyway it was skipped by 5a
% <<[[yylex()]] in number case, in decimal case, ncu suffix label handling>>

Most of the magic to convert a set of accumulated (digit)
characters to an integer is done
by the [[strtol()]] function from the core C library (see the \book{Libcore}).
\l not use of peekc here! (could have also set c1?)

%The unsigned and long typed suffixes are ignored by Asm5:
%<<[[yylex()]] in number case, in decimal case, ncu suffix label handling>>=
%ncu:
%    while(c == 'U' || c == 'u' || c == 'l' || c == 'L')
%        c = GETC();
%@
\l ncu?  non current unit?
\l note base 10 passed to strtol

\subsection{Hexadecimal and octal numbers}

%trans:
If a number starts with a zero, it is maybe the
start of an hexadecimal or octal number.
%
In that case, similar to the code to handle decimals,
[[yylex()]] accumulates also characters in [[symb]] (via [[cp]]).
%
However, this time [[yylex()]] does not
rely on [[strtol()]] to convert the characters in 
an integer\footnote{It could because [[strtol()]] handles those cases.}.
Instead, [[yylex()]] gradually updates [[yylval.lval]]:

%[[strtol()]] does handle hexadecimal and octal numbers, 
%but for unknown reasons
%things are done manually for those numbers:
\n it is handled by Linux (jarod) and actually also by plan9, see man page
%ocaml: rely on int_of_string (slightly different syntax though for
% octal so have to prefix with 0o)


<<[[yylex()]] locals>>=
int baselog2;
@
%pad: I introduced that! the code was abusing c1 before.

<<[[yylex()]] in number case, 0xxx handling>>=
*cp++ = c;
c = GETC();
baselog2 = 3; // 2^3, for octal
if(c == 'x' || c == 'X') {
    baselog2 = 4; // 2^4, for hexadecimal
    c = GETC();
} 
else if(c < '0' || c > '7')
    goto dc;

yylval.lval = 0;
for(;;) {
    if(c >= '0' && c <= '9') {
        if(c > '7' && baselog2 == 3)
            break;
        yylval.lval <<= baselog2;
        yylval.lval += c - '0';
        c = GETC();
        continue;
    }
    // else
    if(baselog2 == 3)
        break;
    // else
    <<[[yylex()]] in number case, 0xxx handling, normalize letters>>
    if(c >= 'a' && c <= 'f') {
        yylval.lval <<= baselog2;
        yylval.lval += c - 'a' + 10;
        c = GETC();
        continue;
    }
    break;
}

peekc = c;
return LCONST;
@
%ocaml: ugly 3 and 4 special code, ugly abuse c1, but convenient for the <<=
% anyway just use int_of_string
%old: I use an extra variable 'baselog2' to not abuse the confusing c1
%old: it was doing goto ncu; but I removed ncu, so I inlined
% the peekc=c; return LCONST  at the end

<<[[yylex()]] in number case, 0xxx handling, normalize letters>>=
if(c >= 'A' && c <= 'F')
    // c = lowercase(c)
    c += 'a' - 'A';
@


\subsection{Floating-point numbers}

%trans:
[[yylex()]] uses a set of labels to recognize floating-point
numbers: 

<<[[yylex()]] in number case, in decimal case, float handling>>=
if(c == '.')
    goto casedot;
if(c == 'e' || c == 'E')
    goto casee;
@
\t put regexp for floats used in 5a-ocaml?

% the code below accumulates also the right set of characters in symb

<<[[yylex()]] in number case, float labels handling>>=
casedot:
    for(;;) {
        *cp++ = c;
        c = GETC();
        if(!isdigit(c))
            break;
    }
    if(c == 'e' || c == 'E')
        goto casee;
    goto caseout;

casee:
    *cp++ = 'e';
    c = GETC();
    if(c == '+' || c == '-') {
        *cp++ = c;
        c = GETC();
    }
    while(isdigit(c)) {
        *cp++ = c;
        c = GETC();
    }

caseout:
    *cp = '\0';
    peekc = c;
    if(FPCHIP) {
        yylval.dval = atof(symb);
        return LFCONST;
    } else {
        yyerror("assembler cannot interpret fp constants");
        yylval.lval = 1L;
        return LCONST;
    }
@
%ocaml: ocamllex regexps so much better
%ocaml: rely also on powerful float_of_string?
\l remove FPCHIP? true anyway

Most of the magic to convert a set of characters in
a floating-point number is done by the [[atof()]] 
function from the core C library (see the \book{Libcore}).
\l why a?? why not strtof?


In Asm5, a dot without any number before can be the start of a float,
the start of an identifier, or simply the dot character, hence
the code below:

<<[[yylex()]] switch c cases>>=
case '.':
    c = GETC();
    if(isalpha(c)) { // an identifier
        cp = symb;
        *cp++ = '.';
        goto aloop;
    }
    if(isdigit(c)) { // a float
        cp = symb;
        *cp++ = '.';
        goto casedot;
    }
    // else
    peekc = c;
    return '.'; // a single '.'
@
\l why not simply goto talph for '.'? avoid duplicate the cp = symb; ...
%ocaml: ocamllex returns the longest or the first in the list
% so simpler code


\section{Characters}
\n unicode? nope! 5a does not support unicode.

In Asm5, like in C, characters start and end with a single
quote character (e.g., [['a']]).
%
However, because the quote character is used to mark the end of
a character, how do you represent the quote character itself?
Moreover, how do you represent ASCII characters that can not
be put between quotes such as the backspace character?

\subsection{Escaped sequences}

Asm5, like C, allows to use {escape sequences} to represent
special characters.
%
An {\em escape sequence} starts with the antislash character
and is followed by a character or a series of numbers.
%
For example,
[['\n']] represents the newline character,
[['\007']] the character with the ASCII value [[7]],
\n for Bell; 8 is backspace but in octal it is more complicated 010
\l interet? why not write 008 outside quote? because it's typed as a char!
\l  and it is more readable IMHO, I prefer '\0' to 0.
and [['\'']] the quote character itself.
\n  also [['\\']] (said later), because how escape escape?
%real-world: escaping issues is in all languages, even tools like
%  make or the shell!

The function [[escchar()]] used below is a wrapper around [[GETC()]].
Like [[GETC()]], [[escchar()]] reads a character from the input file
and returns it unless 
(1) the character read is the start of an escape sequence, or 
(2) the quote character itself.
%
In the first case, [[escchar()]] reads more characters from the input
file and returns the value of the escaped character.
%
In the second case, it returns [[EOF]] to indicate there was no
character between the two quotes.
%
Figure~\ref{fig:assembler-escchar} illustrates a few examples
of use of [[escchar()]].

\begin{figure}[!]\centering
\begin{verbatim}
                cursor
                  |
   input  +-------v---------+     before
  buffer  |. . . ' a ' . . .|    escchar()
          +-----------------+
                  cursor
                    |
   input  +---------v-------+       after
  buffer  |. . . ' a ' . . .|   escchar('\'')
          +-----------------+

      return value: 97 (ASCII code of 'a')


                cursor
                  |
   input  +-------v---------+     before
  buffer  |. . . ' \ n ' . .|    escchar()
          +-----------------+
                    cursor
                      |
   input  +-----------v-----+       after
  buffer  |. . . ' \ n ' . .|   escchar('\'')
          +-----------------+

      return value: 10 (ASCII code of '\n')


                cursor
                   |
  input  +---------v-------+     before
 buffer  |. . . ' a ' . . .|    escchar()
         +-----------------+
                   cursor
                     |
  input  +-----------v-----+       after
 buffer  |. . . ' a ' . . .|   escchar('\'')
         +-----------------+

          return value: EOF
\end{verbatim}
\caption{Examples of use of [[escchar()]].}\label{fig:assembler-escchar}
\end{figure}

% FIGURE with evolution of pointers to input after escchar?
%  for 'a', '\n', and ''

Here is finally the code to recognize characters in Asm5:

<<[[yylex()]] switch c cases>>=
case '\'':
    c = escchar('\'');
    <<[[yylex()]] in character case, if c is EOF>>
    if(escchar('\'') != EOF)
        yyerror("missing '");

    yylval.lval = c;
    return LCONST;
@
\l rename getc_or_escc

As I said before, [[5a]] converts characters in integers, hence
the use of the [[LCONST]] token code above used also
for numbers (see Section~\ref{sec:yylex-decimal-numbers}).

There are two calls to [[escchar()]] above. 
The first consumes the character
after the first quote (e.g., [[a]] in [['a']], as shown
at the top of Figure~\ref{fig:assembler-escchar})
The second consumes the ending quote itself
(as illustrated at the bottom of Figure~\ref{fig:assembler-escchar}).
%
Indeed, [[escchar()]] returns the special code [[EOF]] if 
the character read is the same than the character passed as an argument
(here a single quote).

\subsection{Triple quotes}

Note that the C code above uses itself the escape
sequence [['\'']] to represent the quote character.
%
Asm5 uses another technique to represent the quote character:
the programmer can {\em double} the quote character
to represent a single quote character.
%
Indeed, [[5a]] interprets the sequence of characters
[[''']] as the single quote.
%
Here is the code to handle [[''']]:

<<[[yylex()]] in character case, if c is EOF>>=
if(c == EOF)
    c = '\'';
@
\l C does not allow ''' ?

[[5a]] uses this same doubling technique to represent the
escaping character itself; the sequence [['\\']]
represents the antislash character.
\l otherwise how represent antislash?

\subsection{[[escchar()]]}

The argument to [[escchar()]] is a character used to mark the
end of an ``entity''. In this section, the mark is
a single quote ([[']]) because we are parsing characters. 
%
In the next section, the argument to [[escchar()]] will be the
double quote character ([["]]) because we will parse strings.

Here is finally the code of [[escchar()]]:

<<function escchar>>=
int
escchar(int e)
{
    int c;
    <<[[escchar()]] other locals>>

loop:
    c = getc();
    <<[[escchar()]] sanity check if newline>>
    if(c != '\\') {
        if(c == e)
            return EOF;
        return c;
    }
    // else c is '\\'
    c = getc();
    <<[[escchar()]] if octal character>>
    switch(c)
    {
    <<[[escchar()]] switch cases>>
    }
    // else (e.g., '\'', '\\')
    return c;
}
@
\t use Rune instead of int? could because escchar also used in 5c and
\t  5c supports unicode characters
\l they abuse EOF to mean end of string
%ocaml: if not known antislash, then return the char, but 
%  should yyerror I think (except for '\'' which I would add as a case before)


<<[[escchar()]] switch cases>>=
case 'n':	return '\n';
case 't':	return '\t';
case 'b':	return '\b';
case 'r':	return '\r';
case 'f':	return '\f';
@

Asm5 allows a few more escape sequences compared to C:

<<[[escchar()]] switch cases>>=
case 'a':	return 0x07;
case 'v':	return 0x0b;
case 'z':	return 0x00;
@
\l meh


In Asm5, a series of numbers after an escape character
is interpreted as a series of octal numbers.
\l why?
Here is the code to handle those escaped sequences (e.g., [['\007']]):

<<[[escchar()]] other locals>>=
int l;
@
<<[[escchar()]] if octal character>>=
if(c >= '0' && c <= '7') {
    l = c - '0';
    c = getc();
    if(c >= '0' && c <= '7') {
        l = l*8 + c-'0';
        c = getc();
        if(c >= '0' && c <= '7') {
            l = l*8 + c-'0';
            return l;
        }
    }
    peekc = c;
    return l;
}
@
\n can have 1, 2, or 3 oct, but no more



\subsection{Escaped newlines}

[[5a]] forbids the use of newlines in the middle of a character or string:

<<[[escchar()]] sanity check if newline>>=
if(c == '\n') {
    yyerror("newline in character or string");
    return EOF;
}
@
%alt: could allow
%pad: I added the "in character or"

To represent a character or string containing a newline, use the escape
sequence [['\n']] as in [["hello world\n"]].

%alt:
[[5a]] could allow to use directly a newline in a character or string as in:

<<not valid Asm5 example>>=
  MOVW $'
', R1
@
%$

However, this would destroy the indentation of the program, 
which is why [['\n']] is a more convenient way for the programmer
to represent a newline character.


In some cases, it is useful to split a long string on multiple lines.
Asm5, like C, allows to {\em escape a newline} as in the following code:

<<example of escaped newline>>=
DATA foo(SB), "this is\
a long string"
@


Here is the code to handle escaped newlines:

<<[[escchar()]] switch cases>>=
case '\n':	goto loop; // multi line strings
@

Note that the escaped character and the following newline
are skipped by [[escchar()]].

Escaped newlines are not really useful in Asm5 because 
Asm5 limits strings to less than 8 characters.
%
They are supported by [[5a]] because the function [[escchar()]]
was reused from the code of the C compiler [[5c]].


\subsection{[[getc()]]}

\label{sec:getc}
[[getc()]], called from [[escchar()]], is a small wrapper around [[GETC()]]
that takes care of [[lineno]]:
\n will be called a lot by preprocessing code

<<function getc>>=
int
getc(void)
{
    int c;

    <<[[getc()]] peekc handling>>
    c = GETC();

    if(c == '\n')
        lineno++;
    if(c == EOF) {
        yyerror("End of file");
        errorexit();
    }
    return c;
}
@
\l int? why not uint? GETC can return EOF but not this function!
\t will be called also by macro processing code

<<[[getc()]] peekc handling>>=
c = peekc;
if(c != IGN) {
    peekc = IGN;
    return c;
}
@


\section{Strings}

Asm5 supports the use of strings, for instance, in [[DATA]]
pseudo instructions.
%
The code below relies again on the function [[escchar()]]
to handle escaped sequences in strings.

<<[[yylex()]] locals>>=
int i;
@
%pad: I added that, was abusing c1

<<[[yylex()]] switch c cases>>=
case '"':
    memcpy(yylval.sval, nullgen.sval, sizeof(yylval.sval));
    cp = yylval.sval;
    i = 0;
    for(;;) {
        c = escchar('"');
        if(c == EOF)
            break;
        if(i < sizeof(yylval.sval))
            *cp++ = c;
        i++;
    }
    if(i > sizeof(yylval.sval))
        yyerror("string constant too long");
    return LSCONST;
@
\t works nullgen.sval?? add the appropriate 0? why not just *cp = '\0' ?








\chapter{Preprocessing}
\label{chap:preprocessing}

%trans:
The next component in the assembling pipeline is the preprocessor.
Indeed, as I mentioned in Section~\ref{sec:mcrr-macro}, 
[[5a]] is a macro-assembler.


[[5a]], like the C compiler [[5c]], does not rely on
an external program (e.g., [[/bin/cpp]]) to preprocess code.
%dup: overview/language/adv-feature core-ds/symbol-table  input/iostack
Instead, [[5a]] {\em embeds} in its own code a macroprocessor.
%dup: input/iostack
By doing so, [[5a]] avoids to fork and to communicate with
an external program, which would slow down the assembling process.
\l actually true that 5c so much faster than gcc and pcc

In this chapter, I will not present all the code of this
embedded macroprocessor.
Indeed, the macroprocessor of [[5a]] uses the same syntax
than the C preprocessor, so
most of this code is identical to the code of the
C preprocessor I present in the \book{Compiler}.
\n actually was using same code, via some ugly include (bootstrap!)
%toc:
However, I will present the code to handle the
[[#include]] and [[#line]] directives because those
directives are either 
strongly related to code I presented before 
([[iostack]] in Section~\ref{sec:iostack} for [[#include]]), or related
to important code I will present later
(debugging support in Section~\ref{sec:hist} for [[#line]]).
\n actually 5c generate directly output with line info, so no
\n  need for 5a stuff, so could skip this chapter.
%
For the code to handle [[#define]], [[#ifdef]], [[#undef]],
and [[#pragma]], see Section~\ref{sec:preprocessing-rest}
in the Advanced Topics chapter.



\section{Directive dispatch, [[mactab]], and [[domacro()]]}

One of the two entry points in the macroprocessor embedded in [[5a]] is
the call to [[domacro()]] in [[yylex()]] below to handle all
preprocessing directives\footnote{
The other entry point is the call to [[macexpand()]] to expand macro
when [[yylex()]] recognizes an identifier 
(see Section~\ref{sec:macro-expansion}).
}:

<<[[yylex()]] switch c cases>>=
case '#':
    domacro();
    goto l0;
@
%ocaml: external cpp, just handle #line?
% update: actually I now use macroprocessor/ library

[[domacro()]] will read all the characters on the line and modify
some globals (e.g., [[iostack]] and [[fi]] when processing a [[#include]]).
%
Note that after the call to [[domacro()]] above, [[yylex()]]
jumps back to [[l0]]. Indeed, a preprocessing directive
is not a meaningful token for the parser.
%
Once a directive line (e.g., a [[#include]]) has been preprocessed,
[[yylex()]] must go back and read more characters (this time
from the included file).
\l GETC will change because fi and iostack changed

As you will see soon, [[domacro()]] relies internally on
the structure and global below.
%
[[mactab]] below maps a directive string to a {\em callback}
responsible for parsing and processing the directive.

<<global mactab>>=
struct
{
    char    *macname;
    void    (*macf)(void);
} mactab[] =
{
    "ifdef",    nil,    /* macif(0) */
    "ifndef",   nil,    /* macif(1) */
    "else",     nil,    /* macif(2) */
    "endif",    macend,

    "include",  macinc,
    "line",     maclin,
    "define",   macdef,
    "undef",    macund,

    "pragma",   macprag,
    0
};
@
% mac for macro (and not macos or macintosh), but used actually
% for all cpp related constructs.
%old: I reorganized some entries, but should not matter
\l could aspectize more and simplify the code now that ifdef is shown later

%dup: preprocessing
In this chapter, I will only describe the code of [[macinc()]] 
and [[maclin()]]. 
For the other callbacks, see Section~\ref{sec:preprocessing-rest}.

Here is finally the code of [[domacro()]]:

% dispatcher, should rename because it's not just about macro =>
% parse_and_dispatch_pp_directive?
<<function domacro>>=
/// main -> assemble -> yyparse -> yylex -> <>
void
domacro(void)
{
    int i;
    Sym *s;

    s = getsym();
    <<[[domacro()]] set s to endif symbol if no symbol>>

    for(i=0; mactab[i].macname; i++)
        if(strcmp(s->name, mactab[i].macname) == 0) {
            // dispatch!
            if(mactab[i].macf)
                (*mactab[i].macf)();
            else
                macif(i);
            return;
        }
    // else
    <<[[domacro()]] handle unknown directives>>
}
@

[[domacro()]] reads the name of the directive with [[getsym()]]
and then iterates over [[mactab]] to dispatch
the appropriate callback.


%\section{[[getsym()]]}
The code of [[getsym()]] below is similar to the code in [[yylex()]]
to recognize identifiers (see Section~\ref{sec:yylex-identifiers}).
\l why dupe? because shared library for macroprocessing
%
The code also accumulates characters in the global [[symb]] and
calls [[lookup()]].
\t abuse getsym just to get an ident, don't have to go through lookup really
\t indeed, first time encounter a directive name, lookup will add
\t in symbol table, allocate a Sym, and then further reference of
\t same directive name will reuse same string, same symbol.

<<function getsym>>=
Sym*
getsym(void)
{
    int c;
    char *cp;

    c = getnsc();
    if(!isalpha(c) && c != '_' && c < Runeself) {
        unget(c);
        return S;
    }
    for(cp = symb;;) {
        if(cp <= symb+NSYMB-4)
            *cp++ = c;
        c = getc();
        if(isalnum(c) || c == '_' || c >= Runeself)
            continue;
        // else
        unget(c);
        break;
    }
    *cp = '\0';
    <<[[getsym()]] sanity check cp>>
    return lookup();
}
@
% seen getc() before, wrapper over GETC that handles incrementing lineno
%  if needed
% Runeself defined in libc.h
\t why -4 ?

<<[[getsym()]] sanity check cp>>=
if(cp > symb+NSYMB-4)
    yyerror("symbol too large: %s", symb);
@


[[getsym()]] calls first [[getnsc()]] 
(for ``get first non-space character'') below:

% get non space char (they really like short cryptic names)
<<function getnsc>>=
int
getnsc(void)
{
    int c;

    for(;;) {
        c = getc();
        if(!isspace(c) || c == '\n')
            return c;
    }
}
@
% the one in Compiler.nw is more complicated

Indeed, macroprocessor directives can contain spaces between
the [[#]] and the identifier, as in the following example:

<<example of use of ifdef>>=
#ifdef FOO
#   ifdef BAR
...
#   endif //BAR
#endif //FOO
@
\n can also contain comment (said later)


[[getsym()]] must read an extra character to find the end
of an identifier. Doing so, it goes too far in the input buffer.
%
Similar to code in [[yylex()]], the function [[unget()]] below,
called from [[getsym()]] above,
allows to go back in the input buffer by storing the extra
character in the global [[peekc]].

% what if had already a peekc? because called unget 2 times?
% should raise Impossible!
<<function unget>>=
void
unget(int c)
{
    peekc = c;
    if(c == '\n')
        lineno--;
}
@

If the symbol read by [[getsym()]] does not correspond
to a known directive, [[5a]] reports an error and skips the line:

<<[[domacro()]] handle unknown directives>>=
yyerror("unknown #: %s", s->name);
macend();
@

% for error
<<function macend>>=
void
macend(void)
{
    int c;

    for(;;) {
        c = getnsc();
        if(c < 0 || c == '\n')
            return;
    }
}
@
% I don't think c can be < 0 here.
\t use EOF instead of c < 0?

\section{[[#include]]}
% and [[-I]]

%trans: 
I can now describe the first callback [[macinc()]],
which handles [[#include]] directives.


\subsection{Include search path}

%trans:
Before showing the code of [[macinc()]],
%
here are a few globals used by [[macinc()]]:

% hmm rename? include_paths?
<<global include>>=
// array<option<string>> (size = ninclude)
char*	include[NINCLUDE];
@
<<constant NINCLUDE>>=
#define NINCLUDE    10
@
<<global ninclude>>=
int	ninclude;
@
\n set to 0 because global?

[[include]] above contains a set of directories to search
for header files, for instance, [[["."; "/usr/include"; "/arm/include"]]].
This set is called the {\em include search path}.
%
Indeed, in Asm5, like in C, you do not have to specify the full path
of a header file to include it.
%
You can just write in your program [[#include <u.h>]] and [[5a]] 
will try to find this header file automatically in one of the
directory in the include search path.
\t useful for portability, same program, different behavior


By convention, the first entry in [[include]] corresponds
to the directory containing the input assembly file passed
on the command-line to [[5a]].
%
Thus, if you run the command [[5a /tests/foo.s]] from any directory, 
the [[foo.s]] program can still include the header file [[/tests/foo.h]]
by just using [[#include "foo.h"]].

[[main()]] sets first a default value for this first entry:

<<[[main()]] remaining initializations>>=
include[ninclude++] = ".";
@
% could do setinclude(".");  as in 5c
% overriden later? with full path of dirname(infile) ?

This value is then refined in [[assemble()]] during the processing
of the input filename (see Figure~\ref{fig:assembler-ofile-outfile}):

% Put back Figure X. ofile points to dir and terminated by end-of-string
% in middle just before b which point to basename of input file.
<<[[assemble()]] adjust first entry in include with dirname infile>>=
include[0] = ofile;
@
\l ofile is a temporary in assemble, so dangerous to do that. Fortunately
\l there should be no use of include outside of assemble()


\subsection{[[-I]]}

You can also add directories in the include search path by using
the command-line flag [[-I]] as in [[5a -I /arm/include -I /sys/include foo.s]].
Here is the code to manage those flags:

<<[[main()]] locals>>=
char *p;
@
% -I
<<[[main()]] command line processing>>=
case 'I':
    p = ARGF();
    setinclude(p);
    break;
@


<<function setinclude>>=
void
setinclude(char *p)
{
    int i;

    <<[[setinclude()]] sanity check p>>
    <<[[setinclude()]] check if include already added>>
    <<[[setinclude()]] check if too many entries in include>>
    // else
    include[ninclude++] = p;
}
@
% this one does not handle space in p like 5c does ($INCLUDE can contain space)

<<[[setinclude()]] sanity check p>>=
if(p == nil)
    return;
@
<<[[setinclude()]] check if include already added>>=
for(i=1; i < ninclude; i++)
    if(strcmp(p, include[i]) == 0)
        return;
@
\t why starts at 1? because include[0] is special, it is "." or dirname(infile)
\t nelem() is in libc.h

<<[[setinclude()]] check if too many entries in include>>=
if(ninclude >= nelem(include)) {
    yyerror("ninclude too small %d", nelem(include));
    exits("ninclude");
}
@


\subsection{System paths}

Finally, [[5a]] automatically adds in the include search path 
directories contained in the [[INCLUDE]] environment variable
if this variable is set,
or the architecture-specific directory [[/arm/include]] otherwise:

<<[[assemble()]] locals>>=
char incfile[20];
@

<<[[assemble()]] setinclude("/{thestring}/include") or use INCLUDE>>=
p = getenv("INCLUDE");
if(p) {
    setinclude(p);
} else 
     sprint(incfile,"/%s/include", thestring);
     setinclude(strdup(incfile));
}
@
%old:    if(systemtype(Plan9)) {
\l remember thestring

%\subsection{Tracing origin and [[Hist]]}
% too early


\subsection{[[macinc()]]}

Here is finally the code of [[macinc()]]:

<<function macinc>>=
void
macinc(void)
{
    char *hp;
    int n;
    fdt f = -1;
    <<[[macinc()]] other locals>>

    // lexing

    <<[[macinc()]] lexing the included filename>>

    // action

    <<[[macinc()]] find and store the included filename full path in [[symb]]>>

    n = strlen(symb) + 1;

    while(n & 3)
        n++;
    hp = malloc(n);
    memcpy(hp, symb, n);

    newio();
    pushio();
    newfile(hp, f);

    return;

<<[[macinc()]] bad>>
}
@
%old: was abusing c to store result of strlen, I use n instead.
%jarod: does not check size of name, can overflow str?
% use rnd(c, 4) instead of while
\t how lineno? incremented by 1 and then start processing included file?
\t or #include like non existent and replaced by content?

I will describe later the code to lex the [[#include]] line
to extract the included filename, as well as the code to
find the full path of this included file in the include search path.
But before, note the call to [[newio()]] and [[newfile()]] above.
%
I introduced both functions in Chapter~\ref{chap:input}.
%
Those functions modify the globals [[iostack]] and [[fi]].
%
Thus, when [[yylex()]] will [[goto]] back to [[l0]] (after having
processed the [[#include]] line via [[domacro()]] and [[macinc()]]),
further calls to [[GETC()]] will operate on an empty buffer [[fi]]. 
This will trigger a call to [[fillbuf()]], which will use
the new [[iostack]] pointing now to a new file.


Before the call to [[newfile()]], [[macinc()]] calls [[pushio()]] above
to save the current value in [[fi]]. That way, 
when [[5a]] will finish to process the included file, it will
be able to go back to where it was in the includer file.
% FIGURE?

<<function pushio>>=
void
pushio(void)
{
    Io *i;

    i = iostack;
    <<[[pushio()]] sanity check i>>
    <<[[pushio()]] sanity check i>>
    // save current position in includer
    i->p = fi.p;
    i->c = fi.c;
}
@

<<[[pushio()]] sanity check i>>=
if(i == I) {
    yyerror("botch in pushio");
    errorexit();
}
@


The code to parse an [[#include]] must handle two forms of
[[#include]] as shown in the example below:

<<example of use of include>>=
#include <system_file.h>
#include "other_file.h"
@
\l in fact local also looked in include path



<<[[macinc()]] other locals>>=
char str[STRINGSZ];
int c, cend;
@
<<constant STRINGSZ>>=
#define STRINGSZ    200
@
%jarod: doit etre plus grand que NSYMB

%old: was c0, but cend is better
<<[[macinc()]] lexing the included filename>>=
cend = getnsc();
if(cend != '"') {
    if(cend != '<') {
        c = cend;
        goto bad;
    }
    cend = '>';
}
// cend = '"' or '>'
hp = str;
for(;;) {
    c = getc();
    if(c == cend)
        break;
    if(c == '\n')
        goto bad;
    *hp++ = c;
}
*hp = '\0';

<<[[macinc()]] finish parsing the line>>
@
%old: c = cend; if (cend != '<') ... I push first st inside second one
%old: 'for (hp = str;;) ...' 

<<[[macinc()]] bad>>=
bad:
    unget(c);
    yyerror("syntax in #include");
    macend();
@


Once [[macinc()]] filled its local variable [[str]] with
the characters of the included filename (through the [[hp]] pointer),
[[macinc()]] tries to find the full path of the included filename
by iterating over the include search path:

<<[[macinc()]] other locals>>=
int i;
@
<<[[macinc()]] find and store the included filename full path in [[symb]]>>=
for(i=0; i<ninclude; i++) {
    <<[[macinc()]] skipped first entry for system headers>>
    strcpy(symb, include[i]);
    strcat(symb, "/");
    <<[[macinc()]] normalize path>>
    strcat(symb, str);

    f = open(symb, OREAD);
    if(f >= 0)
        break;
    // else, try another directory
}
// could not find a directory, maybe it was an absolute path
if(f < 0)
    strcpy(symb, str);
@
\l opti where can pass an already opened file in newfile so avoid
\l  two calls to open. Otherwise pass -1 to newfile.


The first entry of [[include]], which corresponds by convention to the
directory of the input assembly file, is not looked for
with system headers:

<<[[macinc()]] skipped first entry for system headers>>=
if(i == 0 && cend == '>') // do not look in '.' for system headers
    continue;
@

Thus, you can use in your own project a header file with the same
name than a system header (e.g., [[stdlib.h]]) and select
which file to include by using either [[<>]] or [[""]] around
the filename.
\l so local file are looked in



<<[[macinc()]] normalize path>>=
if(strcmp(symb, "./") == 0)
    symb[0] = '\0';
@
\l need clean ./ ? not handled by open? need call cleanname?


The macroprocessor allows only spaces or comments after
the directive and before the newline:

<<[[macinc()]] finish parsing the line>>=
c = getcom();
if(c != '\n')
    goto bad;
@

The code of [[getcom()]] below is similar to the code
of [[yylex()]] to handle comments in Section~\ref{sec:yylex-comments},
except newlines are not allowed here:

% accept comment or space until newline
% will increment lineno since use getc
<<function getcom>>=
int
getcom(void)
{
    int c;

    for(;;) {
        c = getnsc(); // skip whitespaces

        if(c != '/')
            break;
        c = getc();
        if(c == '/') {
            while(c != '\n')
                c = getc();
            break;
        }
        if(c != '*')
            break;
        c = getc();
        for(;;) {
            if(c == '*') {
                c = getc();
                if(c != '/')
                    continue;
                c = getc();
                break;
            }
            if(c == '\n') {
                yyerror("comment across newline");
                break;
            }
            c = getc();
        }
        if(c == '\n')
            break;
    }
    return c;
}
@
%jarod: can not avec comment across new line?
\l dupe because reused code in different assemblers and in compiler



\section{[[#line]]}
\label{sec:sharp-line}

%trans:
The other (and last) callback I will present in this chapter is
[[maclin()]], which handles [[#line]] directives.

\subsection{Motivations}

[[#line]] directives are extremly useful for debugging purposes,
as I will fully explain in Chapter~\ref{chap:debugging}.
%
They are usually not written by the programmer but instead generated
by programs.
%
For example, if you process an assembly file with the [[/bin/cpp]]
program (instead of relying on the embedded macroprocessor in [[5a]]),
[[cpp]] will expand all directives 
(e.g., [[#include]], [[#ifdef]], [[#define]]), 
but it will also generate in the output many [[#line]] directives.
%
That way, subsequent programs processing this output can know
from which file and which line a line in the output comes from,
which is useful for precise error reporting and debugging.
%
Here is an example of output of [[cpp]] on a toy program:

\begin{verbatim}
$ cd /tests/cpp/
$ cpp foo.s
#line 1 "/tests/cpp/foo.s"


#line 1 "/tests/cpp/./foo.h"
#line 1 "/tests/cpp/./foo1.h"
...
$
\end{verbatim}
\l #line 3 is also possible in which case get <noname>

Because [[5a]] embeds its own macroprocessor, in theory [[5a]] 
does not need to handle [[#line]] directives; [[5a]] can keep
track internally of the origin of lines when processing
[[#include]] and macros.
%
However, some assembly files may also be generated by programs.
%
For example, a C compiler could generate an assembly file from
a C file and add [[#line]] directives in the generated code
so you could see to which line in the C file certain
assembly instructions correspond to. 
Debuggers can also leverage such information as explained 
in Chapter~\ref{chap:debugging}.
%
Thus, it is important for [[5a]] to also handle the [[#line]] directive,
even if it embeds its own macroprocessor.


%real-world:
Note that most compilers for most programming languages accept
in their input a [[#line]] directive. In fact, it is usually the only
directive they support. 
Indeed, programmers use the C preprocessor with many programming languages 
(e.g., Haskell, OCaml, LambdaProlog), not just C, because it is
a versatile tool.
%
Moreover, most programming languages have in their environment tools
similar to Lex and Yacc but specific to the programming language
(e.g., [[ocamllex]] and [[ocamlyacc]] for the OCaml programming language).
%
Those tools will also generate source files containing [[#line]] directives
so the programming language compiler can report errors correctly.
\l also useful for literate programming when use tools like CWEB.
\l meta
Thus, [[#line]] directives are extremely useful in many contexts.


\subsection{[[maclin()]]}

Here is finally the code of [[maclin()]]:

<<function maclin>>=
void
maclin(void)
{
    char *cp;
    long n;
    int size;
    <<[[maclin()]] other locals>>

    // lexing

    <<[[maclin()]] lexing the line [[n]] and filename in [[symb]]>>

    // action
nn:
    size = strlen(symb) + 1;

    while(size & 3)
        size++;
    cp = malloc(size);

    memcpy(cp, symb, size);

    <<[[maclin()]] call linehist>>
    return;

<<[[maclin()]] bad>>
}
@
%jarod: overflow aussi?
\l does not handle escape char in string this time
%BUG: accept newline?
%pad: I added local 'size', was abusing c before

% maclin | ((macinc | pinit) -> newfile) -> linehist
[[maclin()]], 
like [[newfile()]] (called from [[macinc()]] and [[pinit()]]), 
calls the function [[linehist()]] above.
%
It is this function that will keep track of the origin of
lines as you will see in Chapter~\ref{chap:debugging}.



The code to parse a [[#line]] is similar to the code
in [[macinc()]]. The code also accumulates characters in [[symb]]
through a pointer [[cp]].
%
However, the function [[getnsn()]] below
recognizes first the integer before the filename.

<<[[maclin()]] other locals>>=
int c;
@
<<[[maclin()]] lexing the line in [[n]] and filename in [[symb]]>>=
// the line number

n = getnsn();

// the (optional) filename

c = getc();
if(n < 0)
    goto bad;

for(;;) {
    <<[[maclin()]] skipping whitespaces>>
    if(c == '"')
        break;
    <<[[maclin()]] if no filename>>
    // else
    goto bad;
}
cp = symb;
for(;;) {
    c = getc();
    if(c == '"')
        break;
    *cp++ = c;
}
*cp = '\0';

<<[[maclin()]] finish parsing the line>>
@
\l call first getc before test of n because bad assumes c is set


<<[[maclin()]] if no filename>>=
if(c == '\n') {
    strcpy(symb, "<noname>");
    goto nn;
}
@
<<[[maclin()]] skipping whitespaces>>=
if(c == ' ' || c == '\t') {
    c = getc();
    continue;
}
@

<<[[maclin()]] bad>>=
bad:
    unget(c);
    yyerror("syntax in #line");
    macend();
@

<<[[maclin()]] finish parsing the line>>=
c = getcom();
if(c != '\n')
    goto bad;
@

% get number?
<<function getnsn>>=
long
getnsn(void)
{
    long n;
    int c;

    c = getnsc();
    if(c < '0' || c > '9')
        return -1;
    n = 0;
    while(c >= '0' && c <= '9') {
        n = n*10 + c-'0';
        c = getc();
    }
    unget(c);
    return n;
}
@
%ocaml: ocamllex regexps are so much better



%\section{[[getxxx()]]}

% from now on those functions are actually used by the preprocessing
% code, not by the basic lexer (yylex) that actually implement
% his own getnsc(), getcom(), getsym() via cases
% (hmmm maybe could factorize things?)

%\subsection{[[getc()]], [[unget()]], [[getnsc()]]}
% helpers for other functions

% getc() is presented before

% unget()

% getnsc()


%\subsection{[[getsym()]]}
% mv with Keywords and identifier section?

% \subsection{[[getcom()]]}
% mv with Comments section above?





\chapter{Parsing}
\label{chap:parsing}

%toc:
In this chapter we present the Yacc {\em grammar} of Asm5,
the ARM assembly language supported by [[5a]].
%trans:
Yacc generates from this grammar the [[yyparse()]] parsing function
which is called by [[assemble()]] and which internally
calls [[yylex()]].
%
We assume you know how to read a Yacc grammar, otherwise 
read~\cite{lexyacc}\footnote{
You can also read the original Yacc paper 
at [[generators/docs/yacc.pdf]]
in our \plan repository, or read our \book{CompilerGenerator} to fully
understand how Yacc works.
}.

\t finally assembler specific. Before very general input, lexer, and
\t preprocessor, which will be similar in any compiler.

%compiler:
\t more example of 5c -S (CSPP spirit, learn more than just assembler!)

\section{Overview}

Here is the outline of the Yacc grammar file for Asm5:

<<5a/a.y>>=
%{
#include "a.h"
%}
<<union declaration(arm)>>
<<priority and associativity declarations>>
<<token declarations(arm)>>
<<type declarations(arm)>>
%%
<<grammar(arm)>>
@
%$
\n classic Yacc
\n no %start? the first rule in the file is the default start?
%ocaml: no need union, no need much type decls

%toc:
The [[%union]] and [[%token]] {directives} have been
already described in Section~\ref{sec:token}.
%chunks:
The [[%type]] declarations will be described gradually in this chapter. 
%
The priority declarations are only used for the constant
expressions (an advanced Asm9 feature) and will be described in
Section~\ref{sec:constant-expr}.

The grammar part at the end is the most important one.
%chunks:
It contains the different parsing {\em rules}
which will be presented gradually in this chapter:
\n and also some in other features chapter

<<grammar(arm)>>=
<<prog rule(arm)>>
<<line rule(arm)>>
<<inst rule(arm)>>
<<operand rules(arm)>>
<<cond rule(arm)>>

<<advanced topics rules>>

<<helper rules(arm)>>
@
\n actually not context free; parsing a file modify the kind of toks (LLAB)

Essentially, an assembly program is made of a set lines containing
instructions or labels. Instructions are made of an opcode followed 
possibly by a few operands. Each operand can be a register, a
constant, a symbol, or certain combinations of the previous elements
(e.g., a register and constant offset forming an address).

More formally, an Asm5 [[prog]]ram is either an empty file or a
set of [[line]]s:
<<prog rule(arm)>>=
prog:
  /* empty */
| prog line
@
\l FIGURE with derivation where see set of lines?
%ocaml: no EOF?

\label{sec:semicolon-terminator-grammar}
A [[line]] can be an [[inst]]ruction followed by a semicolon
(remember that the lexer transforms newlines in semicolons
as explained in Section~\ref{sec:semicolon}):
\l so can either pack in one line with ';' or use newline (haskell spirit :) )

<<line rule(arm)>>=
line:
  inst ';'
@

\label{sec:empty-instr}
It can also be empty, or contain the special [[error]] Yacc
token used for error recovery (see~\cite{lexyacc}):
\l to got until next ; (that is newline)?

<<line rule(arm)>>=
| ';'
| error ';'
@

%toc:
In the following section we will focus on the [[inst]]ruction
rule and see the major opcodes of Asm5.
In Section~\ref{sec:label-def} we will see that a line
can also contain label definitions.
Then, in Section~\ref{sec:operands-grammar} we will focus on the
major operands of Asm5. 
We will then explore a few advanced features of Asm5.
\l pseudo instr, cond exec
%compiler:
While presenting the syntax of the different features of Asm5,
we will also try in this chapter to discuss how those features can be used
to implement higher-level constructs of languages such as C.
\l which will also help to understand them, why they are useful,when to use them
We will conclude this chapter by discussing the generated code
for [[yyparse()]] by Yacc.

\ifallcode
<<advanced topics rules>>=
<<constant expression rules>>
<<float rules>>
<<reglist rule>>
<<creg rule>>
<<oexpr rule>>
@
\fi

\section{Instructions}
\n =~ statements

%dup: from core-ds/opcode
Most instructions of Asm5 correspond to machine instructions
of the ARM described in the \book{Emulator}, and can be
grouped in the same categories: 
arithmetic and logic, 
memory,
control flow, and 
software interrupt.
%
To fully understand the semantics of those Asm5 instructions read
the \book{Emulator}.

%from http://www.vpri.org/pdf/rn2010001_programm.pdf
%a typical cpu can do a few things pretty quickly:
% - fetch, fetch[i], store, store[i]
% - +,-,*,/
% - =, <
% - and, or
% - shift
% - jump, if ... jump, jump-linked

\subsection{Arithmetic and logic}

%turing: fundamental!

\subsubsection{And/or/xor}

Here are the {bitwise} {boolean logic} opcodes of Asm5,
%trans:
which are enumeration cases of the [[Opcode]] type
(overviewed in Section~\ref{sec:opcode}):

<<[[Opcode]] cases, logic opcodes>>=
AAND,
AORR,
AEOR, // a.k.a. XOR
@
\n not exactly the ARM order, e.g., I prefer to put closer AAND and AORR

Their ``reading syntax'' are described via entries in [[itab]]
%trans:
presented in Section~\ref{sec:token} (those entries populate
the symbol table [[hash]] as explained in Section~\ref{sec:sym}):

<<[[itab]] elements>>=
"AND",		LARITH,	AAND,
"ORR",		LARITH,	AORR,
"EOR",		LARITH,	AEOR,
@

The logic opcodes take either 2 or 3 operands,
mostly registers. Usually the first two operands are combined
and the result stored in the third operand.
Here are some examples:
\begin{verbatim}
AND $0x0f, R1, R2 // R2 = R1 & 0x0f;
ORR $0xff, R2     // <=> ORR $0xff, R2, R2
\end{verbatim}
%$
\n left-to-right
\n if middle register is NONE then ADD X1, X2 -> ADD X1, X2, X2 (plus=)
\t how do NOT? MVN?

Logic instructions have the same syntax than
arithmetic instructions in Asm5 and so share 
the same grammar rule:

<<inst rule(arm)>>=
inst:
/*
 * AND/ORR/ADD/SUB/...
 */
  LARITH cond imsr ',' regi ',' reg { outcode($1, $2, &$3, $5, &$7); }
| LARITH cond imsr ',' reg          { outcode($1, $2, &$3, R_NONE, &$5); }
@
%$
%old:| LARITH cond imsr ',' spreg ','   { outcode($1, $2, &$3, $5, &nullgen); }
\n arith operator of Machine.nw, but also virtual: SLL, SRL,   DIV, MOD, ...

The \$$n$ Yacc notation in the {\em actions} between braces
gives access to the {\em value} of the nth {terminal} or 
{non-terminal} in the rule.
For terminals this value is derived from the global [[yylval]]
set by the lexer.
\l for non-terminals? \$\$
\n how manage multiple values then at the same time? array ? see \book{Yacc}
Here are the different values for the different elements
in the first rule of [[inst]] above:

\begin{enumerate}
\item [[LARITH]] is the {token name} for all arithmetic and logic mnemonics.
\$1 contains the enumeration value of the corresponding opcode,
for instance [[AAND]] if the lexed token was [["AND"]]
(see the [[itab]] entries above)

\item [[cond]] represents the {\em conditional execution} of an instruction.
It is an ARM feature we will explain later in Section~\ref{sec:cond-exec}.
Every Asm5 instruction rules have a non-terminal [[cond]] after
the opcode.

\item [[imsr]] is a shorthand for: 
[[im]]mediate (constant) or 
[[s]]hifted-register or 
[[r]]egister. 
Those are operands we will describe
in Section~\ref{sec:imsr}. \$3 is of type [[Gen]], the
generalized form of operand we described in Section~\ref{sec:operand}.

\item the first comma, a single-character token without
any value
\l or ascii code?

\item [[regi]] is a register. \$5
%\footnote{\$4 corresponds to the comma preceding [[regi]]}
is an integer representing the register, e.g., 10 for [[R10]].

\item the second comma

\item [[reg]] is also a register but wrapped
in a [[Gen]]. We use a [[Gen]] for \$7 and an integer
for \$5 because of the signature of [[outcode()]]
described in Section~\ref{sec:outcode-signature}.
Indeed, when an ARM instruction has 3 operands, the middle one 
is always a register, so an integer is enough for the fourth
argument to [[outcode()]].

\end{enumerate}

Note that almost all operands above are registers, except 
the first one which can also be a constant or a shifted register.
There is no memory reference. Indeed, the ARM is a RISC machine
where memory references are restricted to only the LOAD and STORE
operations (unified in the [[MOV]] virtual instruction in Asm5),
which we will see later.
\l Von Newmann bottleneck
 
%compiler:
The three opcodes in this section have a direct correspondence
with the following C operators: [[&]], [[|]], and [[^]].
They can also be used to encode boolean expressions
involving [[&&]] and [[||]].
\t how NOT? MVN?
Those C operators are useful in many contexts:
complex conditions in [[if]] and [[while]] statements ([[if(e1 && e2)]]),
boolean variables ([[bool b = b1 || b2;]]),
bitsets operations ([[set1 | set2]]),
bit extraction ([[x & 0x4]]),
bitmask ([[y & 0xff]]), 
etc.
\t say that 32 bitwise boolean logic? truth table?
\t to explain AAND we give corresponce to C, but then in C we do the opposite
\t  and in the emulator we use C, so never have a final semantic :(
%self-ref:
Those operators are heavily used in the \book{Emulator}. Indeed,
managing the binary format of ARM instructions requires many bit
manipulations.

%turing:
Boolean logic is at the foundation of mathematics and
so it is also logic (no pun intended) to have boolean opcodes
as fundamental opcodes of the computer
\footnote{In fact, a whole computer can be made using just the 
Nand logic gate~\cite{tecs}.
}.
\l vs Turing? Von Newmann? they assume basic math lang which is logic and arith

\subsubsection{Add/sub}
\label{sec:asub}

Basic arithmetic is also fundamental to have in a computer:

<<[[Opcode]] cases, add/sub opcodes>>=
AADD,
ASUB,
@
<<[[itab]] elements>>=
"ADD",		LARITH,	AADD,
"SUB",		LARITH,	ASUB,
@

As said in the previous section,
arithmetic instructions have the same syntax than
logic instructions in Asm5 and so use the same grammar rule
involving the [[LARITH]] token code.


%compiler: 
Again, The two opcodes above have a direct correspondence
with C operators: [[+]] and [[-]].
\t overflow? BVS?
\t signed vs unsigned? beauty of 2 complement no need different ops if signed or unsigned!
\l which are used heavily for instance in numerical algorithms.
%
%The C compiler uses also arithmetic opcodes to encode many things.
%For instance, access to the field of a structure, e.g., [[x->fld]],
%is usually encoded as a memory reference with a base ([[x]])
%and an offset which is the location of the field in the structure.
\l for x->fld, but can do MOV for that
%turing: fundamental arith in turing machine language

% see also Comparison section, part of Arith opcode in Machine.nw




\subsubsection{Mul/div/mod}

%compiler:
The three opcodes below are in direct correspondence
with the following C operators: [[*]], [[/]], [[%]].

<<[[Opcode]] cases, mul/div/mod opcodes>>=
AMUL,
ADIV, // VIRTUAL, transformed in call to _div
AMOD, // VIRTUAL, transformed in call to _mod
@
<<[[itab]] elements>>=
"MUL",		LARITH, AMUL,
"DIV",		LARITH,	ADIV,
"MOD",		LARITH,	AMOD,
@

The ARM actually has no [[DIV]] or [[MOD]] instruction.
Those {virtual instructions} are converted by [[5l]] in
calls to assembly functions of the core C library
[[_div()]] and [[_mod()]]
which implement the division and modulo algorithm in software.
See Appendix~\ref{chap:examples} for the code of those
assembly functions.
% compiler: need also mul for array access, need base + idx * size of entry.
%  for pointer arithmetic in general!

\t discussion about 32 bits vs 64 bits result and MULL?


\subsubsection{Sll/srl/sra}
\label{sec:bitshift-opcodes}

%compiler:
The opcodes below are in direct correspondence
with the following C operators: [[<<]], and [[>>]]:

<<[[Opcode]] cases, bitshift opcodes>>=
ASLL, // Shift Left  Logic, VIRTUAL transformed in bitshifted registers
ASRL, // Shift Right Logic, VIRTUAL transformed in bitshifted registers
ASRA, // Shift Right Arithmetic, VIRTUAL transformed in bitshifted registers
@
<<[[itab]] elements>>=
"SLL",		LARITH,	ASLL,
"SRL",		LARITH,	ASRL,
"SRA",		LARITH,	ASRA,
@

\t why shift arith vs logic an issue only for the right and not left?
\t  because when to the right need to decide
\t  how to fill bit 31, with 0 or with 1 depending on whether
\t  you interpret the number as a signed or unsigned!
\t  when on left, anyway leading 1, and fill right with 0 for
\t  signed and unsigned! so just need one opcode.
\t  of course at some point can overflow and lose the last sign bit
\t  see also \book{Emulator}
\t remember not issue for ADD, beauty of 2 complement


\t how 5c decides which one to use? via type! if unsigned then SRL, if
\t  signed then SRA

The ARM does not really have those opcodes though; it does
not use those mnemonics for bit shift operations.
Instead, the ARM has a more general approach to bit shifting:
{operands} of many operations ([[AND]], [[SUB]],
etc.) can be registers with {\em shift annotations}
as explained later in Section~\ref{sec:shift-register}.
%
The opcodes above are thus translated by [[5l]] in the [[MOV]] ARM
instruction (which confusingly as nothing to do with
the Asm5 virtual instruction [[MOV]] we will see later)
with bitshifted register operands.
\n not really virtual
\t actually should impose that constant operand be between 0 and 31!

%self-ref:
Bit shift operations are also heavily used
in the \book{Emulator} because of the binary format of 
ARM instructions.
%are used in this document for the
%[[MCRR]] macro in Section~\ref{sec:mcrr-macro}, and as we will
%see later in Section~\ref{sec:outcode} when generating
%the (binary) object file. 
%also to encode the kind of the bitshift (tricky self ref).
\t for what? to extract bit, make bits, etc
\l for MCRR it is assembly code, but for the rest it is in C code. confusing?
%compiler:
\t also useful for multiplication optimisation (when power of 2), but faster?


\subsubsection{Other arithmetic and logic opcodes}

There are a few additional Asm5 opcodes related to
arithmetic and logic mimicking ARM instructions,
but they are less useful:

\t have we covered mostly all C operators?
\l then explain how go from expr to instr?

<<[[Opcode]] cases, logic opcodes>>=
ABIC, // ??
@
<<[[itab]] elements>>=
"BIC",		LARITH,	ABIC,
@

<<[[Opcode]] cases, add/sub opcodes>>=
ARSB, // ??
AADC, // Add and carry?
ASBC, // Sub and carry?
ARSC, // ??
@
<<[[itab]] elements>>=
"RSB",		LARITH,	ARSB,
"ADC",		LARITH,	AADC,
"SBC",		LARITH,	ASBC,
"RSC",		LARITH,	ARSC,
@
\t RSB? used by _div

% optional? not used a single time in arm/*.s, used a bit in 5c/
<<[[Opcode]] cases, add/sub opcodes>>=
AMVN, // MOV negative, but nothing to do with MOVW
@
\l there is also a MOV in 5i, but it has nothing to do with MOVW too
<<[[itab]] elements>>=
"MVN",		LMVN, AMVN,	/* op2 ignored */
@
\n op2 ignored means actually operand 3 ignored, hence the special rule below
<<inst rule(arm)>>=
/*
 * MVN
 */
| LMVN cond imsr ',' reg { outcode($1, $2, &$3, R_NONE, &$5); }
@


Many of those opcodes are actually never used in the assembly
code generated by the C compiler [[5c]].
See the \book{Emulator} to learn about their semantics.
%ex: ABIC, AADC, ASBC, ARSC
% ARSB seems used (used also by _div), AMVN too

%trans:?
\t actually ARM has also MOV, different that one we will see after
\t  where can just take constant or registers. Used to set
\t  content of registers!
\t but in Asm5 have more general MOVW virtual instruction which can
\t  do that and more!

\subsection{Memory}

%turing: 
% machine is Von Newman model, memory is everything
% but bottleneck, hence RISC model actually
%compiler: 
% store simple data(int), complex (aggregate), store results, 
% store pointers! need powerful memory assign.

Because the ARM is a RISC machine, all memory references in the ARM
are restricted to mostly two machine instructions: 
\n mostly because of SWAP too below
[[LDR]] which {\em loads} some data from memory into a register, and 
[[STR]] which {\em stores} the content of a register into memory.
In Asm5 those two instructions are unified in the
single virtual instruction [[MOV]].
%toc:
Another memory instruction [[SWP]] allows to {\em swap} the content
of a register with the content at a memory address.

\subsubsection{Moves}

[[MOV]]s are converted by [[5l]] in the appropriate
machine instruction depending on the operands:

\begin{verbatim}
MOVW R1, (R2)  // This is a store
MOVW (R2), R1  // This is a load
\end{verbatim}

[[MOV]]s come in different variants, depending on the size
of the memory moved:

\begin{itemize}
\item [[MOVW]] for moving words (4 bytes)
\item [[MOVB]] for moving bytes (1 byte)
\item [[MOVH]] for moving half words (2 bytes)
\item [[MOVBU]] for moving unsigned bytes (1 byte)
\item [[MOVHU]] for moving unsigned half words (2 bytes)
\end{itemize}
\t why unsigned? why care about that in move operations?
\t  issue only when loading from memory to put in register.
\t  indeed if load 0b1000000, if programmer knows it's a signed byte
\t  then when loaded in 32 bits register, we wanted filled with leading 1111

Here are the corresponding Asm5 opcodes:

<<[[Opcode]] cases, mov opcodes>>=
AMOVW, // VIRTUAL, transformed in load and store instructions
AMOVB,
AMOVBU,
AMOVH,
AMOVHU,
@
<<[[itab]] elements>>=
"MOVW",		LMOV, AMOVW,
"MOVB",		LMOV, AMOVB,
"MOVBU",	LMOV, AMOVBU,
"MOVH",		LMOV, AMOVH,
"MOVHU",	LMOV, AMOVHU,
@

[[MOV]]s take a new kind of operand, [[gen]], which
is very general (hence the name). [[gen]] accepts
(as we will see later in Section~\ref{sec:operands-grammar})
registers, constants, but also many forms of memory references
such as the indirect with offset addressing mode in [[4(R1)]]:

<<inst rule(arm)>>=
/*
 * MOVW
 */
| LMOV cond gen ',' gen { outcode($1, $2, &$3, R_NONE, &$5); }
@

Note that even if the grammar rule above is very general,
allowing to write things like [[MOVW (R13), 6(R2)]],
the linker [[5l]] will actually not accept those instructions
and report an error at linking time.
\l a bit ugly
Indeed, the linker will force the programmer to decompose the preceding
instruction in two simpler instructions,
which are then closer to the [[LDR]] and [[STR]] machine instructions
of the ARM:

\begin{verbatim}
MOVW (R13), R1 // =~ LDR
MOVW R1, 6(R2) // =~ STR
\end{verbatim}

This is why in the [[helloworld.s]] program 
in Section~\ref{sec:hello-program} we wrote code like:
\begin{verbatim}
MOVW $'W', R1        
MOVB R1, 6(R2) // can not write MOVB $'W', 6(R2) directly
MOVW $'o', R1        
MOVB R1, 7(R2) // can not write MOVB $'o', 7(R2) directly
\end{verbatim}

Because [[MOVW]] is anyway a virtual instruction, you can wonder
why the linker, instead of reporting an error,
does not generate automatically the multiple [[LDR]] and [[STR]]
instructions which are needed. 
After all, [[5l]] transforms already certain Asm5 
virtual instructions such as [[DIV]] or [[MOD]]
in multiple machine instructions as we will see in the \book{Linker}.
\l maybe simply because cc didn't need it?
%
My guess is that even though virtual instructions allow
to abstract certain peculiarities (separate [[LDR]] and [[STR]] instructions),
hide certain optimizations (code generated for leaf functions for [[TEXT]]
and [[RET]]), or
overcome certain limitations (no [[DIV]] and [[MOD]]), 
an assembly language should still try to mimic as closely
as possible the instructions of a machine.
By being forced to decompose and so to write two 
instructions in the example above, it is arguably
easier for the programmer then to evaluate the number of cycles
a procedure will take, or the number of memory references the procedure
performs, by just counting lines.
\l exact? fixed number of cycle in ARM?
\l See optab possibilities for AMOVW in Linker.nw
\l there is mo pointer arithmetic though, for MOVW it is also raw B plus O

\t MOV fundamental for C. Record access, array access, var access,
% ultimately is a MOV with possibly complex address computation before,
% or for record can just base + offset for var + fld_offset.

\t also .P, .W  for stack-like operation! see Section X on special bits.

\t memory-mapped IO, so quite general! can do IO with a LDR!
% e.g., modify the screen (STR), read the keyboard (LDR)

\subsubsection{Swaps}
\l mv in advanced topics? what I did for Machine.nw?

Memory/register swaps come also in different variants
depending on the size of the memory swapped:

<<[[Opcode]] cases, swap opcodes>>=
ASWPW,
ASWPBU,
@
<<[[itab]] elements>>=
"SWPW",		LSWAP, ASWPW,
"SWPBU",	LSWAP, ASWPBU,
@
\l why only those variants? why not SWPB? SWPH?

<<inst rule(arm)>>=
/*
 * SWAP
 */
| LSWAP cond reg ',' ireg         { outcode($1, $2, &$5, $3.reg, &$3); }
| LSWAP cond ireg ',' reg         { outcode($1, $2, &$3, $5.reg, &$5); }
| LSWAP cond reg ',' ireg ',' reg { outcode($1, $2, &$5, $3.reg, &$7); }
@
%$

The operand [[ireg]] stands for indirect register and
will be described later.
Here are a few examples of swapping instructions:

\begin{verbatim}
SWPW  R1, (R2)
SWPW (R1), R2
SWPW R1, (R2), R3
\end{verbatim}

The point of [[SWPW]] may not be obvious. 
Why do we need such an instruction?
[[SWPW]] is very useful though
because the instruction is guaranteed to be {\em atomic}.
% even in the presence of multiple processors.
\t actually used only for rasp1. For rasp2 Miller uses something else.
\t Maybe atomic regarding interruptions!
\t indeed pb is that when have separate LDR/STR, you need 2 instructions
\t to check the value of something and then store something in it.
%With multiple processors, each processor has its own set
%of registers but the processors share the same memory.
%We can use this shared memory then as a way to synchronize
%processors.
[[SWPW]] is the foundation to build concurrency
primitives. For instance the {\em test-and-set}
function in \plan in [[lib_core/libc/arm/tas.s]] is
using [[SWPW]].
\t link to appendix?
\l x86 XCHG
\l ref to other book?


\subsection{Control flow}
\n was Branching but better control flow I think

\l have seen arith, memory, but control flow is fundamental

%toc: %compiler:
The control flow constructs of Asm5 are in
direct correspondence with certain C constructs:
unconditional jump with [[goto]],
conditional jump with [[if]],
branch and link with function call [[x()]] and [[return]].

\subsubsection{Jump (unconditional)}

The most basic control flow instruction of Asm5 is the direct jump, called
{\em branch} in the ARM, hence the [[B]] below:

<<[[Opcode]] cases, branching opcodes>>=
AB,  // =~ JMP
@
<<[[itab]] elements>>=
"B",		LBRANCH, AB,
@

The operand of a branch can be one of the element below:
\begin{itemize}
\item An offset to the PC pseudo register (e.g., [[B 4(PC)]])

\item A label (e.g., [[B later]])
\l D_BRANCH

\item A symbol (e.g., [[B foo(SB)]])

\item An indirect register (e.g., [[B (R3)]])
\l D_OREG
\end{itemize}

The first two cases are covered by the 
the [[rel]] (register or label) non-terminal below,
the last two cases by [[nireg]] (name or indirect register).

<<inst rule(arm)>>=
/*
 * B/BL
 */
| LBRANCH cond rel   { outcode($1, $2, &nullgen, R_NONE, &$3); }
| LBRANCH cond nireg { outcode($1, $2, &nullgen, R_NONE, &$3); }
@
\l could MOV, modify R15 also?
\t inline nireg here? not used elsewhere
\n could forbid to use cond when AB, because anyway it is normalized after
\n  by outcode, but there B/BL are using the same token so can't
%ocaml: I use two different rules for B and BL so I can be stricted

%compiler:
It is easy to implement loops using [[B]].
The [[helloworld.s]] program in Section~\ref{sec:hello-program} 
contains one (stupid) loop.
%trans:
To not loop infinitely though one needs a way
to escape the loop and jump elsewhere {\em if}
a certain criteria is true.

\subsubsection{Conditional jump and comparisons}
\label{sec:conditional-jump}
\n was actually part of arithmetic in Machine.nw
% but kinda make sense to put it here instead.

%trans:
The [[helloworld.s]] program in Section~\ref{sec:hello-program} 
did not contain any conditional jump. 
Indeed, printing [["hello world"]] is too simple; there
was no need for such an instruction. 
In the same way, there was also no need for an [[if]] 
in the corresponding [[helloworld1.c]] C program.
%turing:
The conditional jump though is a fundamental instruction.
Without it programs would be just long sequences of instructions 
or infinite loops.
\n even BL would not help because BL is almost like a B

The conditional jump instruction is usually preceded
by a {\em comparison instruction}.
The following opcode allows to ``compare'' two operands in Asm5:

<<[[Opcode]] cases, comparison opcodes>>=
ACMP,
@
<<[[itab]] elements>>=
"CMP",		LCMP,	ACMP,
@
<<inst rule(arm)>>=
/*
 * CMP
 */
| LCMP cond imsr ',' regi { outcode($1, $2, &$3, $5, &nullgen); }
@
%$
\n nullgen for dest because indeed there is no really dest, but
\n  it complicates a bit the code generation in the linker

Note that despite its name, this instruction does not really 
compare its two operands. Instead, it loads those two operands
in some internal registers of the processor.
Those internal registers can then be used by the instruction
coming just after, for instance a conditional jump, to actually compare
using different {\em relational operators} those registers
and jump accordingly:
\l so actually one compare instr and many conditional jump instrs

<<[[Opcode]] cases, branching opcodes>>=
/* 
 * Do not reorder or fragment the conditional branch 
 * opcodes, or the predication code will break 
 */ 
// VIRTUAL, AB derivatives with condition code, see 5i/
ABEQ, // ==
ABNE, // !=
ABHS, // >= unsigned (higher or same)
ABLO, // <  unsigned (lower)
ABMI, // minus/negative
ABPL, // plus/positive
ABVS, // overvlow set
ABVC, // overflow clear
ABHI, // >  unsigned
ABLS, // <= unsigned
ABGE, // >=
ABLT, // <
ABGT, // >
ABLE, // <=
//ABAL (always) done via AB
//ABNV (never) done via ANOP (see bcode[])
@
\t what are the ???? look ARM book online? See linker, see Machine.
\t explain the unsigned!
\n match closely things in Machine.nw
%ocaml: can factorize things a bit with Signed vs Unsigned
%old: got rid of ABCS and ABCC, seems redundant
% and does not match the ARM convention
% ABCS,//not in 5i/cond, seems equivalent to ABHS
% ABCC,//not in 5i/cond, seems equivalent to ABLO
<<[[itab]] elements>>=
"BEQ",		LBCOND,	ABEQ,
"BNE",		LBCOND,	ABNE,
"BHS",		LBCOND,	ABHS,
"BLO",		LBCOND,	ABLO,
"BMI",		LBCOND,	ABMI,
"BPL",		LBCOND,	ABPL,
"BVS",		LBCOND,	ABVS,
"BVC",		LBCOND,	ABVC,
"BHI",		LBCOND,	ABHI,
"BLS",		LBCOND,	ABLS,
"BGE",		LBCOND,	ABGE,
"BLT",		LBCOND,	ABLT,
"BGT",		LBCOND,	ABGT,
"BLE",		LBCOND,	ABLE,
@
\l but really you need just = and <, rest can be done with inversing, EORR, etc.

<<inst rule(arm)>>=
/*
 * BEQ/...
 */
| LBCOND rel { outcode($1, Always, &nullgen, R_NONE, &$2); }
@
\l no nireg here?
\n note that there is no cond here, would not make sense

Here is an example of a comparison and conditional jump:

\begin{verbatim}
    CMP $0, R1
    BEQ r1_is_zero
    B r1_is_nonzero 
r1_is_zero:
    // R1 == 0
    ...
    B after
r1_is_nonzero:
    // else
    ...
    // fallthrough
after:
    ...
\end{verbatim}

%compiler:
All the control flow constructs of C ([[if]], [[while]], [[for]], etc.)
can be translated in assembly code using simply labels, branches,
and conditional jumps.
%FIGURE? control flow diagrams translation with edges?

The [[B]]$xx$ Asm5 instructions above are actually virtual instructions.
Similar to the bitshift operations vs shifted-registers,
the ARM provides a more
general approach to conditional jump where {\em every instruction
can be conditionally executed} as explained later in
Section~\ref{sec:cond-exec}.
The opcodes above are thus translated by [[5l]] in the [[B]] instruction
\l note that this is done by 5l, not 5a, actually 5a normalize differently
with special bits set to mark the instruction for conditional execution.
%
Similar to the bitshift operations, Asm5 provides
those specialized virtual instructions jumps because
they correspond more to what assembly programmers
(or compiler writers)
\n probably the reason, to make code of 5c more similar to 8c/vc/...
expect from an assembly language.



There are a few additional Asm5 comparison opcodes similar to
[[CMP]] mimicking ARM instructions, but they
are less useful. Some of them, again, are not even used by [[5c]]:

<<[[Opcode]] cases, comparison opcodes>>=
ATST,
ATEQ,
ACMN, // CMP negative
@
<<[[itab]] elements>>=
"TST",		LCMP,	ATST,
"TEQ",		LCMP,	ATEQ,
"CMN",		LCMP,	ACMN,
@
\l CMN uses a bit to optimize

\t also many ops can modify those internal registers, cf S bit on ADD

\subsubsection{Function call and return}
\t talk about ABI (jarod), different than API, low-level convention
\t  and that for ARM not much imposed as said in Section X because of BL.
\t  but 5c and 9 imposes some interface/convention.

%turing:
The [[B]], [[CMP]], and [[B]]$xx$ instructions
are enough to have a {Turing-complete} machine.
There is no need for a function call instruction; it
would not add any expressivity to the computer.
%
In fact, there is no [[CALL]] or [[RET]] instruction in the ARM,
but instead a very basic [[BL]] instruction.
%dup: from overview/hello/funcall
As explained in Section~\ref{sec:bl}, [[BL]] stands
for {\em branch and link} because the instruction just
saves the current value of the program counter ([[R15]])
in a special {\em link register} ([[R14]]), and then branch/jump:
\n should be called link and branch then
\l why called link? because it create a link with the caller?

<<[[Opcode]] cases, branching opcodes>>=
ABL, // =~ CALL, Branch and Link
@
<<[[itab]] elements>>=
"BL",		LBRANCH, ABL,
@

The [[BL]] instruction uses the same syntax than
[[B]] and so use the same grammar rule
involving the [[LBRANCH]] token name.
Indeed, [[BL]] is really just a slightly different [[B]].
%
But, [[BL]] performs in one instruction something which can
be used as a building block for organizing code into functions.
Indeed, by using [[BL]], the link register [[R14]],
the stack pointer [[R13]], and symbols defined by [[TEXT]], you can easily
simulate functions, function calls, and [[return]]
as explained in Sections~\ref{sec:bl} and~\ref{sec:ret}.

%turing:
From a theoretical computer science point of view,
functions do not add any expressivity to the machine
language, but from a software 
engineering perspective they are tremendously useful.
Indeed, with functions you can decompose a big program 
in multiple independent parts which can be programmed
and understood in {\em isolation}.
\l subroutine concept was invented by David-Wheeler/Maurice-Wilkes/Stanley-Gill
%
Because those functions though must use and {\em share} the same
machine registers, one needs to setup some {\em conventions}
on how to use and {save} those registers so that code of one
function can be programmed independently of the code of 
another function.
%
In \plan, the convention is as follows: 
\begin{quote}
``a subroutine is responsible
for saving its own registers, and therefore is free to use
any registers without saving them''. 
  \end{quote}
\n from asm.pdf
This convention is also known as ``caller saves''. 
%
This means that if the body of a function [[foo]] uses the register [[R1]],
and then must call another function [[bar]]
(with [[BL bar(SB)]]), then [[foo]] must save
the register [[R1]] somewhere if it plans to use its value
after the call to [[bar]], because [[bar]] could have overwritten
the value in [[R1]].
%
The stack is usually used to save the values of those registers.

\t FIGURE with foo, bar, leaf  of Linker.nw where see the frames!

%dup: from overview/hello/call-stack
We need also to setup {\em calling conventions} on how
to pass arguments and use parameter in functions.
In \plan the stack and [[R0]] are
used to pass the arguments as explained in Section~\ref{sec:call-stack}.
%compiler:
By using the stack and not fixed memory locations,
you can call functions recursively.
\t cite dijstra 1960 Recursive programming? apparently before him
\l  there were giving each subroutine its own memory space
\l also invented by turing? notion of subroutine and use of stack
\l  was apparently in secret turing technical report. better than Von Newmann

%FIGURE? show recursive calls?

Asm5 provides the virtual instruction [[RET]] to make it
easier for the programmer to manage the stack when returning
from a function. Indeed, [[RET]] abstracts
away the differences between leaf and non-leaf functions
(as explained in Section~\ref{sec:ret}):

<<[[Opcode]] cases, branching opcodes>>=
ARET, // VIRTUAL, transformed in B (R14) or MOV xxx(R13), R15
@
<<[[itab]] elements>>=
"RET",		LRET, ARET,
@
<<inst rule(arm)>>=
/*
 * RET
 */
| LRET cond { outcode($1, $2, &nullgen, R_NONE, &nullgen); }
@
\n we will see in 5l STEXT and SLEAF


\subsection{Software interrupt}
\l aka syscall
\l interrupts and exceptions

The software interrupt instruction [[SWI]] is really a form of
function call but to a fixed set of special routines setup by the kernel.
%dup: from tutorial
Normally the argument to [[SWI]] specifies an entry in an
{interrupt table} but under \plan this argument is actually not
used and instead [[R0]] is used to store the syscall code.

<<[[Opcode]] cases, interrupt opcodes>>=
ASWI, // syscall
@
<<[[itab]] elements>>=
"SWI",		LSWI, ASWI,
@

<<inst rule(arm)>>=
/*
 * SWI
 */
| LSWI cond gen { outcode($1, $2, &nullgen, R_NONE, &$3); }
@
%$
\l could be more restrictive than gen?
%old: was | LTYPE6 cond comma gen { outcode($1, $2, &nullgen, R_NONE, &$4); }
% but in plan9 the argument is not used so I originally simplified by
% removing the operand. Moreover 9syscall/mkfile was doing weird things 
% like SWI 0; at least should be SWI $0, so it made sense to simplify.
% But then it was creating differences with kencc, and anyway in the ARM
%  it has an argument so I put back the arg.

%kernel:
[[SWI]] is the fundamental building block for having a
kernel program clearly separated from user programs. It provides
a safe way to go from user program to kernel code via the system
call API bridge.
\l open then the door for user process to access real hardware
% (but in supervised mode of course)

Asm5 provides also the virtual instruction [[RFE]] to return
from kernel code to a user program. [[RFE]] is actually just
a short alias to the more cryptic [[MOVM]] instruction
we will describe in Section~\ref{sec:movm}.
\t as well as its special bits.

<<[[Opcode]] cases, interrupt opcodes>>=
ARFE, // VIRTUAL, return from exception/interrupt, MOVM.IA.S.W (R13), [R15]
@

<<[[itab]] elements>>=
"RFE",		LRET, ARFE,
@
% same grammar rule than RET
% =~ IRET
%in lproc.s 
%	RFE				/* MOVM.IA.S.W (R13), [R15] */



\section{Label definitions and [[pc]]}
\label{sec:label-def}
\n put after Operands? Merge with Code refs? maybe better after Instruction
\n section as it is a kind of instr, and better have all opds in one section

Labels allow to give symbolic names to code addresses.
\l it's one way, symbols are another.
They are a fundamental
feature of any assembly language and makes assembly code significantly
easier to understand and maintain.
%compiler:
Indeed, by using label names such as 
[[_loop1]], [[if_zero]], or [[_else]], assembly code using 
jumps (conditional or unconditional) can become closer
to C code using statements such as [[for]] or [[if]].
%
Labels in Asm5 are defined on a line by using an identifier 
followed by a colon:

<<line rule(arm)>>=
| LNAME ':'
 {
  $1->type = LLAB;
  $1->value = pc;
 }
  line
@
\t what for changing the type? for detection of duplicate!
\n no outcode here, no increment pc

%style:
Even though you could have multiple label definitions on a line,
or even labels and instructions on the same line, it is
a common practice to put the label definition alone on its own line,
in the first column.

The value of a label is the value of the {\em virtual program counter}
at the label definition. This counter
is stored in the global [[pc]], initialized to 0 before
each pass and incremented by [[outcode()]] after each code instruction:
\l (except for ADATA and AGLOBL)
\l even ATEXT increments PC? hmm maybe simpler that way
<<global pc>>=
long	pc;
@
<<[[pinit()]] initializations>>=
pc = 0;
@
%ocaml: can be a local in resolve_labels.ml

Once a label has been defined, the code of its
token in the symbol table is changed to [[LLAB]]
\footnote{This means Yacc actions actually have a side effect on how
the lexer behaves. Asm5 is thus not a context free grammar.
This is similar to C where typedefs declarations change
the token code of certain identifiers.
}
\t why need that for LLAB? why need to make it a special token? 
\t grammar ambiguity? NO just to do the redeclaration detection!
\t also can have func and label with same name? I don't think so
\t because then it's a label for the rest of the file!
%  with suffixing with (SB)
as shown in the rule above.
Further use of this label in the rest of the program
or in the next assembling pass will trigger then this rule:

<<line rule(arm)>>=
| LLAB ':'
 {
  if($1->value != pc) {
   yyerror("redeclaration of %s", $1->name);
   $1->value = pc;
  }
 }
  line
@
%$
%ocaml: no need special token and parser/lexer coop. Just postparsing resolve()

Note that there is no use of [[outcode()]] here because labels
can be fully resolved by the assembler. There is no need
to keep them in the object file.

\section{Operands}
\label{sec:operands-grammar}
\label{sec:imsr}
\n =~ expressions

%trans:
Now that we have seen the major opcodes and instructions of Asm5, we
can switch to explain the operands of those instructions.
%
The first non-terminal corresponding to an operand we saw in this chapter
was [[imsr]], the first operand of opcodes such as [[AADD]] or [[AORR]]:

<<operand rules(arm)>>=
imsr:
  imm
| shift
| reg
@

%toc:
The next three subsections will each cover one of the [[imsr]] alternatives.

Rules which return values (in \$\$) must have their type declared
in Yacc via a [[%type]] directive.
Most operand rules have the [[genval]] type:
%ocaml: no need, type inference!

<<type declarations(arm)>>=
%type   <genval> imsr
%type   <genval> imm shift reg
@
\l until now no type for inst, because does not return, call outcode.

In fact, [[genval]] is not really a type
but the name of one of the field of the Yacc [[%union]]
declaration (described partially in Section~\ref{sec:token}):

<<union declaration other fields(arm)>>=
Gen    genval;
@
%old: was gen, but then confusing with the gen rule, and more consistent genval
\t genval -> oval once have Gen -> Operand

The type of [[genval]] is [[Gen]], the
generalized form of operand we described in Section~\ref{sec:operand}.
%
Thanks to those [[%type]] and [[%union]] Yacc directives,
the generated code by Yacc for the \$$n$
referring to non-terminals will access the appropriate field of 
the union. 
%
In the same way, the [[%token]] and [[%union]] Yacc
directives will guide Yacc to generate the right code
for the \$$n$ referring to terminals (the tokens).

The [[gen]] operand rule, specifying the operands of [[MOVW]], 
has the same type:

<<type declarations(arm)>>=
%type   <genval>   gen 
@
%old: was %type   <gen>   gen, but confusing

<<gen rule>>=
gen:
  ximm
| shift
| reg
<<more gen rule>>
@

For now [[gen]] is almost identical to [[imsr]], 
except for the [[ximm]] (extended immediate) vs [[imm]] which we will
explain soon, but we will see later many extensions to the [[gen]] rule.

<<type declarations(arm)>>=
%type   <genval>   ximm
@



\ifallcode
<<operand rules(arm)>>=
<<gen rule>>
<<regi rule(arm)>>
<<ximm rule>>
@
%old: <<oreg rule>>
%old: <<regi_nosp rule(arm)>>
\fi


\subsection{Registers}

%<<operand_kind cases>>=
%D_REG,
%@

Most Asm5 instructions can take one, two, or even three
registers as operands.
%
The [[reg]] rule below allows to wrap in a [[Gen]]
the integer representing the register number.
It uses the [[D_REG]] {\em operand kind} we described
in Section~\ref{sec:operand}:

<<operand rules(arm)>>=
reg:
 regi
 {
  $$ = nullgen;
  $$.type = D_REG;
  $$.reg = $1;
 }
@
%$

[[regi]] (register integer) returns directly the register number:

<<type declarations(arm)>>=
%type   <lval>  regi
@
%old: was called spreg, but prefer regi
\l lval but really enum<registr>


<<regi rule(arm)>>=
regi:
  LREG
@
%old: was called sreg, but prefer regi_nosp, why was called sreg? simple reg?
\l implicit $$ = $1 %$

<<[[itab]] elements>>=
"R0",		LREG,	0,
"R1",		LREG,	1,
"R2",		LREG,	2,
"R3",		LREG,	3,
"R4",		LREG,	4,
"R5",		LREG,	5,
"R6",		LREG,	6,
"R7",		LREG,	7,
"R8",		LREG,	8,
"R9",		LREG,	9,
"R10",		LREG,	10,
"R11",		LREG,	11,
"R12",		LREG,	12,
"R13",		LREG,	13,
"R14",		LREG,	14,
"R15",		LREG,	15,
@

Asm5 allows also the [[R(xx)]] syntax to specify a register:

<<[[itab]] elements>>=
"R",		LR,	0,
@
\l note that different from pseudo register!

<<regi rule(arm)>>=
| LR '(' expr ')'
 {
  if($3 < 0 || $3 >= NREG)
      print("register value out of range\n");
  $$ = $3;
 }
@
%$
\l expr! see later

This feature can be useful when combined with the symbolic constant
feature of Asm5, as shown in Appendix~\ref{sec:_divmod}.
You can achieve a similar effect though by using simply macros.


%old: intermediate not needed anymore once got rid of virtual reg in regi.
%type   <lval>  regi regi_nosp
%<<regi rule(arm)>>=
%regi:
%  regi_nosp
%@
%<<regi_nosp rule(arm)>>=
%| LPC { $$ = REGPC; }
%@
%<<regi rule(arm)>>=
%| LSP { $$ = REGSP; }
%@
%$
% here it was actually hardware registers which I think is confusing
% so I removed those rules.
% Anyway people can use R13 to encode SP and R15 for PC so why
% not have a simple reg rule that allows all those registers directly!
% In which context we don't accept LSP? in which context we don't accept LPC?

\subsection{Immediate constants}

%<<operand_kind cases>>=
%D_CONST,
%@

Many instructions can take a register or an (immediate) constant
as their first operand.
\t say immediate because can be encoded in instruction immediately,
\t  no need intermediate to load from memory in temporary register
\t  but in fact not all constants can be immediate, but issue found in linker
%turing:
This is pretty fundamental of course.
%
All constants in Asm9 are prefixed with a dollar:
\l why? ambiguity with what? 
\l to differentiate with just con where it's a omem (see section below)

<<operand rules(arm)>>=
imm: '$' con
 {
  $$ = nullgen;
  $$.type = D_CONST;
  $$.offset = $2;
 }
@
\l con = constant
\t use lval here instead of offset

<<con rule>>=
con:
  LCONST
| '-' con      { $$ = -$2; }
| '+' con      { $$ = $2; }
| '~' con      { $$ = ~$2; }
@
%$
\l ex ~3L in Linker.nw for round_up like macro
\n con extended later as expr

Note that the ARM uses fixed-length instructions of 32 bits.
%
Because a few of those 32 bits are used to encode the opcode 
and a few more to encode the other operands, the range
for ARM immediate constants is limited.
\n was Asm5, but no, no constraint in Asm5!
For arithmetic instructions, only 12 bits of the instruction
can be used for the
constant, so in theory only constants between 0 and 4096
could be represented. 
\l and for the other instructions? for STR and LDR?
%
But, the ARM uses a clever trick
and those 12 bits are actually divided in two parts:
8 bits for a constant, and 
4 bits for a {\em rotation} of this constant. 
\n a bit different from the bitshifted registers we will see later, but related
Not all 32 bits integers can be represented
using that scheme but many important numbers like all
the powers of 2 between 0 and 31 can be expressed, which
\n 4 bits so 16 shift _plus_ 8 bits for constant, not enough for all power? Yes,
\n see url below, 4 bits rotation is special too!
is very useful in operations involving bitsets or bitmasks.
See the \book{Emulator} and \book{Linker} for more information
or \url{http://alisdair.mcdiarmid.org/arm-immediate-value-encoding/}
which is an excellent tutorial on the topic.
\l also linker book
\l "so you can set, clear, or toggle any bit with one instruction"
%
In any case, Asm5 allows any 32 bits constants in operands. If the constant
does not fit the immediate constant constraint of the ARM, the
linker [[5l]] will use multiple instructions to encode the constant.
\t so what happens if cant be represented? use Pool, in Linker, and REGTMP.
\t and so actually generate 2 instructions. A bit like virtual then!
\t but nice that Asm5 hides again those constraints.

[[MOV]]s instructions, which use the [[gen]] non-terminal
as operand (which derives [[ximm]]) can also take a constant as an
operand:

<<ximm rule>>=
ximm:
  '$' con
 {
  $$ = nullgen;
  $$.type = D_CONST;
  $$.offset = $2;
 }
@
\l also for DATA, WORD
\l and range for LDR/STR for the immediate constant?

%\subsection{String constants}
%<<operand_kind cases>>=
%D_SCONST,
%@

In fact, even string constants are possible operands of [[MOV]]s:
\n see later also float

<<ximm rule>>=
| '$' LSCONST
 {
  $$ = nullgen;
  $$.type = D_SCONST;
  memcpy($$.sval, $2, sizeof($$.sval));
 }
@

For those cases the constant itself can not be encoded
in 32 bits though. The address of the string,
which will become an integer constant after linking,
will be used instead in the generated ARM instruction.
\l kinda automatic GLOBL/DATA done by linker
\l related to $symbol(SB) %$ which also become an integer constant

\subsection{ARM shifted registers}
\label{sec:shift-register}
\l mv in advanced topics?
%arm:

%dup: from parsing/instr/bitshift
As mentioned in Section~\ref{sec:bitshift-opcodes},
in addition to the (virtual) instructions [[SLL]], [[SRL]], and [[SRA]], 
Asm5 gives access to the ARM generalized approach to bitshift
by allowing to use {\em shifted registers} as the first operand in all
arithmetic instructions:

<<operand rules(arm)>>=
shift:
 regi '<' '<' rcon
 {
  $$ = nullgen;
  $$.type = D_SHIFT;
  $$.offset = $1 | $4 | (0 << 5);
 }
| regi '>' '>' rcon
 {
  $$ = nullgen;
  $$.type = D_SHIFT;
  $$.offset = $1 | $4 | (1 << 5);
 }
| regi '-' '>' rcon
 {
  $$ = nullgen;
  $$.type = D_SHIFT;
  $$.offset = $1 | $4 | (2 << 5);
 }
| regi LAT '>' rcon
 {
  $$ = nullgen;
  $$.type = D_SHIFT;
  $$.offset = $1 | $4 | (3 << 5);
 }
@
% >> >> >> >> >>
%ocaml: ugly to encode so much stuff in offset, better do that in linker
% do that because does not have powerful ADT so need encode info in 1 integer
\l argh, offset really abused, should use shift here
%self-ref:
\l use bitshift op in the code to handle bitshift, also use bitwise |, 

A shifted-register combines a register (a [[D_REG]]) and an immediate constant
(a [[D_CONST]]) in a new kind of operand:
\n in fact can be two D_REG rcon is register or con

<<[[Operand_kind]] cases>>=
D_SHIFT,
@

You can then use an opcode like [[ADD]] while at the same time
doing a shift operation on one of the register 
in one single instruction
(which opens many optimizations opportunities in the C compiler [[5c]]):
\begin{verbatim}
ADD R1 >> 8, R2, R3
\end{verbatim}
\t convenient for compiler to generate code that access array elt?
\t  try 5c -S and show output?

Note that [[Gen.offset]] is used to encode the whole operand value
\footnote{We could use [[Gen.reg]] and [[Gen.offset]] instead.}:
the first 4 bits (bits 0 to 3) are used for the register number (0 to 15),
bits 5 and 6 are used to encode the kind of shift, e.g., [[0 << 5]]
for a left shift, and bits 7 to 11  to encode either a small immediate constant
or another register via [[rcon]] (register or constant) below.
\n so a bit different from the imm rotate we saw before which uses 4 bits
%self-ref:
\t see usefulness of those operators :)

<<type declarations(arm)>>=
%type   <lval>  rcon
@

<<helper rules(arm)>>=
rcon:
  regi
 {
  if($1 < 0 || $1 >= NREG)
      print("register value out of range\n");
  $$ = (($1&15) << 8) | (1 << 4);
 }
| con
 {
  if($1 < 0 || $1 >= 32)
      print("shift value out of range\n");
  $$ = ($1&31) << 7;
 }
@
%old: was using $$ in if but better use $1 (jarod)
\l no yyerror instead of print?
\n range test for regi a bit redundant since do already tests there (jarod) 
\t put line number? better diagnostic
\l really does too much work here and close to ARM concrete bits
%ocaml: ugly to encode so much stuff in offset
\n no leading dollar here, hmmm

The tricky [[Gen.offset]] encoding for bitshifted registers
reflects how such operands are actually encoded in the binary
format of ARM instructions.
%

In addition to the [[<<]] and 
[[>>]] logical shift operators, Asm5 provides
the [[->]] operator for right shift arithmetic
and [[@>]] for right rotate.
Again, see the \book{Emulator} for more information.
Because [[@]] can be part of an identifier in Asm9, a special
entry in [[itab]] had to be used to represent the single character:

<<[[itab]] elements>>=
"@",		LAT,	0,
@
\l could remove @ from the identifier lexing section,
\l so then could just do '@' '>' instead of this indirection
%ocaml: ugly to allow @ in identifiers
\l At for Arithmetic?


\subsection{Memory (de)references, pointers}
\l indirect addressing?

%trans:
We have seen the three components of the [[imsr]] operand rule
used in arithmetic instructions:
the immediate constant, the shifted register, and the register.
\l Those are actually possible operands for other ARM instructions.
%toc:
We will now focus on the [[MOVW]] instruction and its [[gen]]
operand which is even more general (hence the name).
%dup: from overview/input-lang
Section~\ref{sec:ref-addressing-modes} listed the different
ways to reference memory in Asm5 (the different {memory addressing modes}),
for instance ``indirect with offset'' in [[4(R1)]].

This is where we start to deviate from [[imsr]] in [[gen]]
(in addition to the [[ximm]] vs [[imm]] difference):
<<more gen rule>>=
| ioreg
@
%old: was oreg above
%old: oreg is an intermediate rule which we do not need anymore
%<<gen rule>>=
%| oreg
%@
%<<oreg rule>>=
%oreg:
%  ioreg
%@
%<<operand_kind cases>>=
%D_OREG,
%@

[[ireg]] (indirect register) allows to dereference a pointer
stored in a register. [[ioreg]] (indirect offset register) 
adds an offset to the memory address in the register.
Both are using the [[D_OREG]] operand kind (introduced in 
Section~\ref{sec:operand}):

<<type declarations(arm)>>=
%type   <genval> ioreg ireg
@

<<operand rules(arm)>>=
ioreg:
  ireg
| con '(' regi ')'
 {
  $$ = nullgen;
  $$.type = D_OREG;
  $$.reg = $3;
  $$.offset = $1;
 }
@
\l could inline in gen, but MOVM use ioreg directly
%old: was regi_nosp here
\t how offset encoded in instruction? what if outside range?
\t remember that MOVW is a virtual instruction. LDR/STR are different.

<<operand rules(arm)>>=
ireg:
 '(' regi ')'
 {
  $$ = nullgen;
  $$.type = D_OREG;
  $$.reg = $2;
  $$.offset = 0;
 }
@
%$
\n could inline in ioreg, but swap use ireg directly

\t actually ARM also supports LDR R1(R2), R3
\t  but because probably not used by 5c, it's not
\t  in 5a either (but it can be generated by 5l though when use large offsets)


\subsection{Named memory locations, symbols}
\label{sec:name-rule}
\l and pseudo registers
\n different from labels, which are just for code refs

You can also use symbols to reference memory in Asm5:

<<more gen rule>>=
| name
@
\t rename? not really a name, because has also offset and base
%old: inlined in gen now
%<<oreg rule>>=
%| name
%@
\l but actually not just a name really, there can be an offset

<<type declarations(arm)>>=
%type   <genval>   name 
%type   <lval>  offset
%type   <lval>  pointer
@

<<name rule>>=
name:
  LNAME offset '(' pointer ')'
 {
  $$ = nullgen;
  $$.type = D_OREG;
  $$.sym = $1;
  $$.symkind = $4;
  $$.offset = $2;
 }
@
%$
\l name is an operand for BL (via nireg), for TEXT, and for MOV

Note that symbol operands use the same operand kind [[D_OREG]]
than the indirect register with offset we have seen above.
This is because a name can also be seen as a sort of ``offset'' to 
one of the (pseudo) register we have seen in 
Section~\ref{sec:pseudo-registers}
(except [[PC]]):
\l PC is used only in one context, for jump, which we will see later
\l but actually before it was used maybe in regi_nosp

<<helper rules(arm)>>=
pointer:
  LSB
| LSP
| LFP
@
\n hmmm bad name? pointer_basis? but it's true we do '(' pointer ')'
\n where we really dereference the pointer (and then add an offset)
\n the linker generates really offset(R12) when dereferencing symbols
\n  (but not when taking address of symbol)

<<[[itab]] elements>>=
"SB",		LSB,	N_EXTERN,
"SP",		LSP,	N_LOCAL,
"FP",		LFP,	N_PARAM,
@
%<<[[Sym_kind]] cases>>=
%N_EXTERN, // text/data/bss values (from SB)
%N_LOCAL,   // stack values (from SP)
%N_PARAM,  // parameter (from FP)
%@

The name (which itself is seen as an offset to a pseudo register)
can also have an additional offset applied to it:

<<helper rules(arm)>>=
offset:
 /* empty */ { $$ = 0; }
| '+' con    { $$ = $2; }
| '-' con    { $$ = -$2; }
@
%$
\l rename offset_opt?

\subsubsection{Locals and parameters, [[SP]] and [[FP]]}

Note that for locals and parameters the symbol name is
not really necessary, which is why one can also reference
parameters only with an offset, as in [[MOVW 4(FP), R1]]:

<<more gen rule>>=
| con '(' pointer ')'
 {
  $$ = nullgen;
  $$.type = D_OREG;
  $$.sym = S;
  $$.symkind = $3;
  $$.offset = $1;
 }
@
%$
%ocaml: make sense to have anon with SB? be stricter!
%old: was in name rule, but better in gen rule I think, it is not really a name
\n could delete that too? hmm no, it's for anonymous params like 4(FP)
\n the con (pointer) of 'name:' is not ambiguous with the con (sreg)
% of 'oreg:'? no because pointer != sreg (well even if R12 is actually LSB ...)
\l can also do 4(SB)? useful?

%dup: from overview/input-language
The use of symbols for locals and parameters can be useful though as comments,
as in [[MOVW  count+4(FP), R1]].
\t again what is the generated code by linker?
The symbol name is also kept in the symbol table of the object file
as we will see in Chapter~\ref{chap:generation}
which can be leveraged later by tools like debuggers
as we will see in Chapter~\ref{chap:debugging}.
\t in fact maybe main reason for those pseudo, easy debugging format!

%real-world: no pseudo in real assembler. But all of that 
% makes it easier to name local and params, and to provide
% a better debugging experience. 5c can actually generate
% via #line and good symbol name all the debugging info it needs.
% No need DWARF or stabs. Actually 5c does not need #line because
% it generates object files directly with the appropriate lineno.

% FIGURE call stack where see where FP and SP points compared to R13
\t take same figure than in tutorial, with same arguments in the stack
\t but with FP and SP and rewrite code to use that instead of R13


\t explain more FP here, frame pointer, which really is SP,
\t and EBP in x86. Or explain that in Linker.nw?
%real world: -fomit-frame-pointer! no need save SP in the stack!
\n fomit-frame-pointer
\n but then harder to walk the stack!
\n can statically know when do RET what you allocated already,
\n can restore old SP easily.

\t ref to appendix where have a different helloworld.s!

\subsubsection{Symbol addresses}

Using a [[name]] as part of a [[MOVW]] implicitly means
a pointer dereference to access the value at the address
denoted by the symbol, e.g., [[MOVW foo(SB), R1]].
To get the address of the symbol
itself one needs to prefix the name with a dollar,
e.g., [[MOVW $foo(SB), R1]]. %$
This is where [[ximm]] deviates from [[imm]]:

<<ximm rule>>=
| '$' name
 {
  $$ = $2;
  $$.type = D_ADDR;
 }
@
%old: was $ oreg, but i think it makes more sense to have just '$' name
%pad: I introduced a special D_ADDR instead of abusing D_CONST
\l a bit confusing that can have gen -> oreg, and also gen -> ximm -> $ oreg
%$
\l why not allowed in imm too? after all it can be computer statically

%trans:
Note that the [[name]] non-terminal can also be the operand
of the [[TEXT]] pseudo instruction as we will see soon,
in which case it defines the symbol.

\subsubsection{Private symbols}
\n local is bad name, confusing with local for N_LOCAL
\n maybe internal? good opposite of external? but external confusing a bit

Asm5 provides also a way to use {\em private} (a.k.a static)
symbols for globals and procedures
in a file by suffixing the name with angles:

<<name rule>>=
| LNAME '<' '>' offset '(' LSB ')'
 {
  $$ = nullgen;
  $$.type = D_OREG;
  $$.sym = $1;
  $$.symkind = N_INTERN;
  $$.offset = $4;
 }
@
%$
%ocaml: can be bool in Entity of bool instead of split N_EXTERN vs N_INTERN

<<[[Sym_kind]] cases>>=
N_INTERN, // private (aka static) entities (from SB)
@
%old: was D_STATIC but ugly C name

Those names will not be visible outside the file, but they
will also not conflict with identical names in other files.



\subsubsection{Branching symbols}


Branching instructions (e.g., [[BL]]) can also jump to symbols via 
the [[nireg]] operand rule below.
They can also jump to the address contained in a register:
\t useful for dynamic jump, e.g., function pointers

<<type declarations(arm)>>=
%type   <genval>   nireg 
@

<<operand rules(arm)>>=
nireg:
  name
| ireg
@
\t could inline in parent
%$
\l for BL, in addition to rel, can also have nireg
%old: had a if with nothing in it, weird
%  name
% {
%  $$ = $1;
%  if($1.name != N_EXTERN && $1.name != D_STATIC) {
%  }
% }

% BL ireg means have no idea where it jmps ... can this
% create bugs in 5l that statically tries to find the necessary code?
% well the address of a function should be taken somewhere so
% the function should be considered unless one does really crazy
% magic stuff.




\ifallcode
<<operand rules(arm)>>=
<<name rule>>
@
\fi

\subsection{Code references, labels}

%trans:
The last operand rule we have to see is
%
one of the operand rule of branching instructions ([[B]], [[BL]])
called [[rel]] (register or label):

<<type declarations(arm)>>=
%type   <genval>   rel
@
\l rel = ? relocatable? relative? or simply register or label?
% Relative because it's labels which are locals to a file and can be
% resolved locally (no need symbols), but at the same time they will
% also need to be relocated when all objects are attached after each
% other
% update: the offset value is actually not relative to the current PC,
% it's an absolute value, so it probably means more relocatable than
% relative in the end
% update: but one of the rule of rel is actually a relative jump to PC

<<rel rule>>=
rel:
  LLAB offset
 {
  $$ = nullgen;
  $$.type = D_BRANCH;
  $$.sym = $1;
  $$.offset = $1->value + $2;
 }
@
%$
\t sym saved, so can be saved in object file for debugging?

This operand uses a new kind of operand:
\l could abuse D_CONST?

<<[[Operand_kind]] cases>>=
D_BRANCH,
@
%old: /* type */ FOR BRANCH

The value for this kind of operands is 
the {resolved} absolute code address of the label. 
It is stored in [[Gen.offset]].
\t but core address still virtual in some sense (but not virtual mem sense)
\t  it is virtual virtual
\l remember that value of label in symbol table is virtual pc at def

\l can use labels defined in other procedures, see _div and _mod with out:

\l no need to relocate  those names (well actually we relocate them in 5l when
% we put each object one after another, see the 'ipc' local variable)

When a label is declared later in a file, the first mention
of this label in an operand in the first pass will trigger
the rule below. Indeed, the symbol table does not know yet
that this identifier is really a [[LLAB]] not an [[LNAME]]:

<<rel rule>>=
| LNAME offset
 {
  $$ = nullgen;
  if(pass == 2)
      yyerror("undefined label: %s", $1->name);
 }
@
%old: if pass == 1 why care about setting the field values?
%  $$.type = D_BRANCH;
%  $$.sym = $1;
%  $$.offset = $2;
% anyway outcode will not use the value

Another way to reference code is to add an offset
to the virtual program counter [[PC]], allowing
to make {\em relative jumps} (even though this is transformed
in an absolute code address thanks to [[pc]]):
\t even though ARM actually use relative jumps, so absolute
\t  converted back in relative, but tricky because not that easy
\t  to calculate _real_ relative jump count because some instructions
\t  have different size in the end (even though fixed-length instructions)
\l explain virtual code address, incremented by 1, same dimension than pseudo PC

<<rel rule>>=
| con '(' LPC ')'
 {
  $$ = nullgen;
  $$.type = D_BRANCH;
  $$.offset = $1 + pc;
 }
@
%$
\l con(PC) is not really named code

<<[[itab]] elements>>=
"PC",		LPC,	D_BRANCH,
@
\l no really need D_BRANCH here now.



\ifallcode
<<operand rules(arm)>>=
<<rel rule>>
@
\fi




%\subsection{Other operands}

%dead:
% <<operand_kind cases>>=
% D_OCONST,
% @
% <<ximm rule>>=
% | '$' '*' '$' oreg
%  {
%   $$ = $4;
%   $$.type = D_OCONST;
%  }
% @
% %$
%seems unused in ARM/*.s


%old:
%<<more gen rule>>=
%| con
% {
%  $$ = nullgen;
%  $$.type = D_OREG;
%  $$.offset = $1;
% }
%@
%%$
% no $ in front of con here?
% was used in 9syscall for 'SWI 0' but not sure what it meant.
% how can be D_OREG when there are no registers involved.
% I removed the rule, and rewrote calls to SWI to just be SWI $0

%old:
%<<more gen rule>>=
%| shift '(' regi ')'
% {
%  $$ = $1;
%  $$.reg = $3;
% }
%@

%old:
%<<oreg rule>>=
%| name '(' sreg ')'
% {
%  $$ = $1;
%  $$.type = D_OREG;
%  $$.reg = $3;
% }
%@
% but name already has some (sreg), so what this rule mean?
% foo(PC)(PC) ??
% sreg, so can't use FP here, nor LSB, so only name refering to PC?




\section{Pseudo instructions}

Pseudo instructions have an opcode and operands, 
just like the other instructions we have seen before, 
but they do not correspond to any machine instruction.
%
This is also true for virtual instructions like [[MOVW]] or [[RET]]
but virtual instructions eventually become machine instructions
after linking.
\n actually TEXT generate some instructions, but the name part does not really
%
Pseudo instructions on the opposite are assembly-only constructs,
also know as {\em assembly directives}.
It would be more accurate to call them {\em linker directives}
though because they declare things which will be used by the linker
\l or loader for DATA
and which will eventually disappear after linking.
\l or are kept but only for debugger


\subsection{[[TEXT/GLOBL]]}

{Symbols}, for procedures or globals, are {declared}
respectively by the [[TEXT]] and [[GLOBL]] pseudo instructions
(as explained in Section~\ref{sec:pseudo-instructions}):

<<[[Opcode]] cases, pseudo opcodes>>=
ATEXT,
AGLOBL,
@
<<[[itab]] elements>>=
"TEXT",		LDEF, ATEXT,
"GLOBL",	LDEF, AGLOBL,
@
\l it is not really LDEF actually, it's more LDECL

<<inst rule(arm)>>=
/*
 * TEXT/GLOBL
 */
| LDEF name ',' imm         { outcode($1, Always, &$2, R_NONE, &$4); }
| LDEF name ',' con ',' imm { outcode($1, Always, &$2, $4, &$6); }
@
%$

The same non-terminal [[name]] we have seen in Section~\ref{sec:name-rule}
to reference memory via a symbol is used also here to
define a symbol. This is why one needs also to add the
[[(SB)]] suffix in symbol definitions as in [[TEXT _main(SB), $20]].%$
\l no much sense though to allow the offset here, _main _plus_ 4(SB) ??
%
The second operand is an immediate constant which represents a 
size in bytes for the locals of the procedure or for the global
as explained in Section~\ref{sec:pseudo-instructions}.
%
The [[TEXT]] and [[GLOBL]] can also take three operands as 
indicated by the second alternative in the grammar rule above, 
in which case the middle operand is used to encode {\em attributes}
of the entity defined as explained in Section~\ref{sec:attributes}.
%
Note that pseudo instructions have the same binary format than other Asm5
instructions in the object file, hence the similar use of [[outcode()]]
above in the action.


[[TEXT]] and [[GLOBL]] are pseudo instructions because 
they give names to procedures and globals
while a machine has no notion of procedure, global, or name. 
Indeed, those names eventually become concrete addresses after linking,
which are really just concrete numbers. Those numbers, not names,
are then used as arguments of machine instructions 
such as [[LDR]] (to access globals), or [[BL]] (to call procedures).

%dup: from ??
Labels are similar to [[TEXT]] symbols but they are not public
and do not have a size. This is because labels are used
for intra-procedural jumps, while [[TEXT]] symbols are used
for public procedures with parameters. 
%
Because labels are private to a file, all the references to
a label must be in the same file.
\l actually not local to a procedure
All those references can thus be {resolved} by the assembler
and converted in absolute (virtual) code addresses in the object file.
[[TEXT]] symbols on the opposite are public and may be referenced
by other files which is why they have to be kept in the object file,
to be resolved later by the linker.
\l local calls could be resolved by assembler, but redundant

[[TEXT]] pseudo instructions are used by the linker to put the
code of procedures in the {\em text section} of the executable.
[[GLOBL]] are used by the linker to allocate some space in the
{\em data section} of the executable.

Note that for procedures, the constant used to represent the size 
of the locals can surprisingly also be [[$-4]]. %$
\l ugly a bit
Indeed, as explained in Section~\ref{sec:call-stack}, each
time a procedure is entered
an extra word in the stack is by default allocated before 
the locals to store the return address stored in [[R14]]. This is true
even when the procedure does not declare any local as in
[[TEXT foo(SB), $0]], %$
if [[foo()]] is not a leaf procedure.
%
In some situations though the programmer would like to change
this default behavior and not allocate anything at all in the stack
in which case he must use [[$-4]]%$.
\t appendix getcallerpc which do that (and need to use that?)

\t TEXT transformed in a single MOVW.W R14, #-4(R13), ref to later section? 

%real-world:
% in gasm I think it's
% .global foo
% .text
% foo:
%   <adjust SP>

\subsection{[[WORD/DATA]]}
\label{sec:WORD}

%trans:
[[GLOBL]] tells the linker to allocate some space in the data
section of the executable but it is the
\l actually also for BSS
%
[[DATA]] pseudo instruction which tells the linker how to fill this space
(as explained in Section~\ref{sec:data}):

<<[[Opcode]] cases, pseudo opcodes>>=
ADATA,
@
<<[[itab]] elements>>=
"DATA",		LDATA, ADATA,
@
<<inst rule(arm)>>=
/*
 * DATA
 */
| LDATA name '/' con ',' ximm { outcode($1, Always, &$2, $4, &$6); }
@
\l ugly, abuse reg for this constant.
\n does not increment pc also for those kinds of directives, see outcode()

Note that the [[name]] can contain an offset as in [[hello+8(SB)]].
The [[con]] specifies the size in bytes this [[DATA]] pseudo instruction 
is defining.
Note also the use of [[ximm]] which allows to use string constants
or even addresses of other globals as in [[$otherdata(SB)]]).%$
\l can reference itself
Here are some examples of use of [[DATA]]:
\begin{verbatim}
DATA    hello+0(SB)/8, $"hello wo"
DATA    hello+8(SB)/4, $"rld\n"
...
DATA boot_CONF_outlen+0(SB)/4, $67523
DATA boot_CONF_outcode+0(SB)/8, $"\z\z\1\353\z\z\213\33"
...
\end{verbatim}
\l data2s

%trans:
[[DATA]] allows to put any value in the data section of the executable.
%
A similar pseudo instruction, [[WORD]], does the same for the text section:
\l have not seen that in tutorial

<<[[Opcode]] cases, pseudo opcodes>>=
AWORD,
@
<<[[itab]] elements>>=
"WORD",		LWORD, AWORD,
@
<<inst rule(arm)>>=
/*
 * WORD
 */
| LWORD ximm { outcode($1, Always, &nullgen, R_NONE, &$2); }
@
\l no need /con here, it's always 4 (WORD).

The main use of [[WORD]] is to overcome some of the limitations
of the assembler. Indeed, for [[5a]], even if certain system ARM 
instructions do not have yet an Asm5 mnemonics, you can
still use [[WORD]] to specify this instruction
if one knows the exact binary encoding of 
this instruction. You can even use [[WORD]]
in a macro as shown in Section~\ref{sec:mcrr-macro}.
\l used in x86 for real-mode encoding

\l because data sometimes in text section, e.g., kernel interrupt table?
 

\subsection{[[END]]}
\label{sec:AEND}

The [[END]] pseudo instruction is a marker used
to indicate the end of the instructions in the object file:

<<[[Opcode]] cases, pseudo opcodes>>=
AEND,
@
<<[[itab]] elements>>=
"END",		LEND, AEND,
@

<<inst rule(arm)>>=
/*
 * END
 */
| LEND { outcode($1, Always, &nullgen, R_NONE, &nullgen); }
@
%$
%ocaml: no need, use Marshall also for libs, Marshall list of objects.

The need for such an instruction in the assembly file is
not clear. Having such a marker in the object file
can be useful though. 
Indeed, when many object files are concatenated
together in a library, the [[AEND]] marker can be used to indicate
object boundaries.
\l meh, still linker could do that, but ldobj() is easier to write
\l if AEND is an opcode, like ANAME, like AHISTORY
%ocaml: Marshall my friend!
Note that [[5a]] automatically adds such a marker
at the end of the generated object file
via [[cclean()]] as seen in Section~\ref{sec:cclean}.

\l not the same than ALAST

%\section{Special instructions}
%\subsection{[[NOP]]}
%\subsection{[[SHL/SHR]]}
%\subsection{[[MOVW/MOVL]]}
%\subsection{[[IMUL]]}


\section{ARM conditional execution}
\label{sec:cond-exec}
%arm:

In the ARM, {\em every instruction can be conditionally executed},
\n actually no more in ARMv8
not just branching instructions. This is why every Asm5 
instructions we have seen before uses the [[cond]] non-terminal
in their grammar rule. In Asm5, you can suffix
any opcode with a {\em condition} as in [[ADD.EQ R1, R2, R3]]:

<<type declarations(arm)>>=
%type   <lval>  cond
@

<<cond rule(arm)>>=
cond:
  /* empty */ { $$ = Always; }
| cond LCOND  { $$ = ($1 & ~C_SCOND) | $2; }
@
%ocaml: could not abuse cond and separate in two

<<[[itab]] elements>>=
".EQ",		LCOND,	0,
".NE",		LCOND,	1,
".HS",		LCOND,	2,
".LO",		LCOND,	3,
".MI",		LCOND,	4,
".PL",		LCOND,	5,
".VS",		LCOND,	6,
".VC",		LCOND,	7,
".HI",		LCOND,	8,
".LS",		LCOND,	9,
".GE",		LCOND,	10,
".LT",		LCOND,	11,
".GT",		LCOND,	12,
".LE",		LCOND,	13,
".AL",		LCOND,	Always,
@
%//Never = 15, Nop
%dead: redundant with HS and LO
% ".CS",		LCOND,	2,
% ".CC",		LCOND,	3,

<<constant Always(arm)>>=
#define    Always 14
@
%old: was in a.h, but better put in 5.out.h
\l used as parameter to a few outcode
\l use COND_ALWAYS instead?

So, the branching instruction [[BEQ]] we saw in
Section~\ref{sec:conditional-jump} is really just 
an alias for [[B.EQ]]. 
\n hmm but outcode() will actually do the opposite
%
The need to conditionally execute non-branching instructions
(e.g., an addition) may not be obvious. 
This feature was originally designed to compensate for the lack
of branch predicator in ARM CPUs
by having code using less branches. See
\url{https://en.wikipedia.org/wiki/ARM_architecture#Conditional_execution}
or the \book{Emulator} for more information .
\l http://stackoverflow.com/questions/22168992/why-are-conditionally-executed-instructions-not-present-in-later-arm-instruction

There are bit manipulations involving [[C_SCOND]] above because
the [[cond]] non-terminal in addition to the conditional
execution also stores special ARM instruction bits 
(as explained in Section~\ref{sec:special-bits}):
\n e.g., Sbit, after 0xf
%self-ref: again see need for those operations
%ocaml: no need for this special bitset that early. Return one cond
% and a list of constructor for the .S, .etc
\t why SCOND? S? Special or Cond?

<<constant C_SCOND(arm)>>=
/* scond byte */
#define C_SCOND ((1<<4)-1)
@
% >>
\n 0xf


\section{Special bits}
\label{sec:special-bits}
\n used to be in adv topics, but important cos of RET, TEXT which expands
\n  to MOVW.P or MOVW.W

%Machine.nw and Linker.nw helped for the semantic, but ultimately I used
% also http://www.peter-cockerell.net/aalp/html/app-c.html
% to know the meaning of those letters.

\subsection{Arithmetic instructions and [[.S]]}

% before conditional jump need instruction which sets condition.
% we have seen CMP. But can also use regular arith such as ADD
% with .S suffix. 
\n actually in linker we will see that CMP set this Set field in the instr.
% So overflow detection can be done with ADD.S R1, R2, R3; BVS overflow1.
%http://huonw.github.io/blog/2016/04/myths-and-legends-about-integer-overflow-in-rust/

<<cond rule(arm)>>=
| cond LS    { $$ = $1 | $2; }
@

<<[[itab]] elements>>=
".S",		LS,	C_SBIT,
@
% Set condition codes.

<<constant C_SBIT(arm)>>=
#define C_SBIT  (1<<4)
@
% >>
% after cond which use 4 bits (16 possibilities)
%ocaml: could not abuse cond and separate and move closer to Arith

\t how read condition codes then?

\t .S used also for user vs supervistor register? see MOVM.DB.S ??

\subsection{Moves and [[.P]]/[[.W]]}

% x86 has push and pop stack instruction. No in ARM
% but again special bit to modify slightly semantic
% of instr.

% additional addressing modes via instruction annotation.
% Actually close to how things are represented in ARM.
% (for .U though we do via syntax, allow negative offset)

<<[[itab]] elements>>=
".P",		LS,	C_PBIT,
".W",		LS,	C_WBIT,
@
% for MOV
% U = Up = 1. Nothing = Down = 0. 
%  But when use constant it's automatically handled by 5a/5l, so no need .U
% P = Post = 0, offset added after transfer. Nothing = Pre = 1, 
%  offset added before.
%  For Post it is automatic write, otherwise putting offset would
%  have no effect
% W = Write = 1, write address into base, Nothing = No write back = 0.
% Note that having .P.W does not make sense. .P => .W

<<constant C_PBIT(arm)>>=
#define C_PBIT  (1<<5)
@
% >>
% MOVW.P #4(R13), R15, for RET
% <=> POP

<<constant C_WBIT(arm)>>=
#define C_WBIT  (1<<6)
@
% >> >> >> >> 
%ocaml: could not abuse cond and separate and move closer to Mov

% TEXT foo, $8 ->  MOVW.W	R14,-12(R13)
% <=> PUSH


% see also F_BIT but in adv topics and also 
% special C_UBIT (and more) for MOVM



\section{[[yyparse()]]}
\label{sec:yyparse}

Based on the grammar of Asm5 we have seen in this chapter, Yacc
will generate:

\begin{itemize}
\item a [[y.tab.h]] header file containing the token
codes and the union for [[yylval]], as explained
in Section~\ref{sec:token}. Both the token codes and
[[yylval]] are used by [[yylex()]].

\item a [[y.tab.c]] C file containing the function [[yyparse()]].
This function will internally call [[yylex()]] 
(which is why we call our lexing function [[yylex()]] in
Chapter~\ref{chap:lexing})
to get tokens until the end of the file token ([[EOF]]),
and will parse those tokens according to the first
grammar rule declared in the file: [[prog]].

\end{itemize}







\chapter{Object Code Generation}
\label{chap:generation}

%trans:
We are now ready to present the last component in the
assembling pipeline: the object code generation.
%alt: %dup: from intro/5a
As mentioned before, [[5a]] does not actually generate machine
code (the linker does), 
%
which simplifies things.
Indeed, the only thing [[5a]] needs to do is to {serialize} the 
Asm5 instructions and to record in the object file 
the set of symbols used 
\l (and defined) 
in the assembly file, and where those symbols are used, 
so that they can be resolved later by the linker.
%
Note that labels are resolved during parsing by [[5a]] and 
so their definitions do not need to be stored in the object file.
\t but the uses are there for debugging purpose!
\l but use virtual code address; those addresses must be relocated too.
%
The \book{Linker} will describe then the reverse operation which
is to read an object file.
\n ldobj()
It will also describe which machine code
is generated from the object files and how those object files
are combined to form an executable.
\n 5l/optab.c does this

\section{Object format}
\label{sec:object-format-complete}

%trans:
We described roughly the format of the object files at the beginning
of this book in Section~\ref{sec:object-format-part1}. 
%trans:
We can now describe more precisely this format in 
Figure~\ref{fig:object-format-complete} since we now have
a better understanding of Asm5.

\begin{figure}[!]\centering
\begin{verbatim}
                        ^-------------+
                       /|             |
                      / |             |
                     /  |             |
                    /   |  Operand 2  |
+--------------+    |   |             |
|Instruction 4 |    |   |             |
|              |    |   |             |       ^-------------+
+--------------+    |   |             |/-----/|             |
|   Symbol3    |    |   +-------------X       |             |
+--------------+    |   |             |       |             |
|   Symbol2    |    |   |             |       |Operand value|
+--------------+    |   |  Operand 1  |       |             |
|              |    /   |             |       |             |
|Instruction 3 |   /    |             |       |             |
|              |  /     |             |       |             |
+--------------+ /      +-------------X       +-------------+
|   Symbol1    |/       |             |\      | Symbol kind |
+--------------X        |    Line     | \     +-------------+
|Instruction 2 |        |             |  \    |Symbol index |
|              |        |             |   \   +-------------+
+--------------X        +-------------+    \  |  Register   |
|Instruction 1 |\       |  Register   |     \ +-------------+
|              | \      +-------------+      \|Operand kind |
+--------------+  \--\  |  Condition  |       v-------------+
| Files/lines  |      \ +-------------+
|   history    |       \|   Opcode    |
|              |        v-------------+
+--------------+

    File                  Instruction             Operand
\end{verbatim}
\caption{Complete format of a [[.5]] object file.}
\label{fig:object-format-complete}
\end{figure}

The format of an object file is pretty regular, essentially a list
of instructions where each instruction is encoded as follows:
\l do I repeat too much the code? too verbose? maybe
\begin{itemize}
\item An opcode (1 byte), e.g., the value of [[ASUB]]
\n 1 byte enough for 256 opcodes, as explained in sec:object-format-part1

\item A conditional execution (1 byte), e.g., the value of [[Always]]
\l also special bits

\item A register number (1 byte), e.g., 4 for [[R4]], 
when an instruction has 3 operands or the value of [[R_NONE]]
\l also abused to encode some symbol attributes, e.g., DUPOK

\item A line number (4 bytes) encoded in an architecture
independent way by having the bytes representing the lower
part of the number stored first in the object file\footnote{
Also known as the {\em little-endian} format
}.

\item The first operand
\n which can be null operand

\item The second operand
\n which can be null operand

\l The register above is a kind of operand3.

\end{itemize}

The operands themselves are encoded as:
\begin{itemize}
\item The kind of the operand (1 byte), e.g., the value of [[D_REG]].
Note that for opcodes with 0 or 1 operand, [[D_NONE]] is used
to represent the null operand.
%ocaml: no need when use clean ADT

\item A register number (1 byte), e.g., 5 for [[R5]] when
the operand involves a register (as in [[(R5)]]) or [[R_NONE]].
\l for direct register, shifted register, and??

\item An {\em index} (1 byte) in the {\em object file symbol table},
when the operand involves a symbol (as in [[hello(SB)]])
or 0.
\t or label, saved for debugging
The encoding scheme for this symbol table will be described later
in Section~\ref{sec:spreaded-symbol-table}.

\l for D_OREG and also D_CONST (but really D_ADDR)

\item The kind of the symbol (1 byte), e.g., the value of [[N_EXTERN]],
when the operand involves a symbol or [[N_NONE]].

\item The value of the operand, which has a variable size
e.g., 4 bytes for the integer value of a [[D_CONST]]
but 0 byte for [[D_REG]] since the register number
is stored already above.
\l endianess here too

\end{itemize}

A symbol reference in an operand is represented as an {index} in a symbol table,
which saves space since the same symbol could be referenced many times.
%ocaml: so kinda pointer to string, but Marshall does this for free!
\n not to confuse with hash, symbol table of assembler vs object file stab
This symbol table could be stored at the beginning or end of the file.
Instead, [[5a]] uses a rather sophisticated scheme 
explained in Section~\ref{sec:spreaded-symbol-table} where the symbol
table is ``spread'' in the object file along with the instruction
(represented by the [[Symbol]] cells in 
Figure~\ref{fig:object-format-complete}).
\n ANAME: symkind (1 byte), symidx (1 byte), string finished by \0
%
The beginning of an object file contains files and lines information
which will be explained in Section~\ref{sec:object-file-history}.
\n the header is really just a set of ANAME and AHISTORY, and
\n AHISTORY use the same format than other instructions.

\l 5l then read back this format in a simple loop reading one
\l instruction at a time and maintaining the symbol table information
\l via the ANAME.

\t 5l -v -W to show?


\section{Instruction output, [[outcode()]]}
\label{sec:outcode}

%trans:
The job of [[outcode()]], introduced in Section~\ref{sec:outcode-signature},
and used many times in the grammar, is mostly to 
%
serialize one instruction (machine, pseudo, or virtual)
according to the format described 
in the middle of Figure~\ref{fig:object-format-complete}:
\n mostly because actually also serialize symbol table, and increment also pc

<<function outcode(arm)>>=
/// main -> assemble -> yyparse -> <>
void
outcode(int opcode, int scond,  Gen *g1, int reg, Gen *g2)
{
    <<[[outcode()]] locals>>

    <<[[outcode()]] adjust opcode and scond when opcode is AB>>

    if(pass == 1)
        goto out;

    <<[[outcode()]] st and sf computation, and possible calls to zname>>

    Bputc(&obuf, opcode);
    Bputc(&obuf, scond);
    Bputc(&obuf, reg);
    Bputc(&obuf, lineno);
    Bputc(&obuf, lineno>>8);
    Bputc(&obuf, lineno>>16);
    Bputc(&obuf, lineno>>24);
    outopd(g1, sf);
    outopd(g2, st);

out:
    if(opcode != AGLOBL && opcode != ADATA)
        pc++;
}
@
\t it is not lineno - 1? to compensate for reduction of grammar rule
\t  after the newline token has been recognized
%ocaml: just use Marshall, no need all those stuff
% also clearer when need to do the pc++ in resolve_labels.ml
%old: I renamed 'a' to 'opcode', clearer I think
\l less: rename reg to reg3? so less confusing with reg in zaddr?

It also increments the virtual program counter
[[pc]] (used to resolve labels) for all instructions
except the one related to the data section of the executable.
%style:
Indeed, [[DATA]] or [[GLOBL]] instructions can be mixed
with [[TEXT]] instructions; 
they do not have to be at the end of the assembly file 
(even though this is a common practice).
\n WORD is for the TEXT section too!

%self-ref:
Note the use of [[goto]] in the code above where an [[if]] would
have been arguably clearer. This is perhaps the sign that
the person who wrote this code likes too much assembly.
\l maybe OK for an assembler :)

\l note that output line number here! useful for debugging information,
\l to be ablt to go back from one instruction to the actual code!
\l (but lineno after #include expansion, see outhist() section
\l later so one can get from lineno to actual file _plus_ lineno

[[outcode()]] also {\em normalizes} the code:

<<[[outcode()]] adjust opcode and scond when opcode is AB>>=
/* hack to make B.NE etc. work: turn it into the corresponding conditional*/
if(opcode == AB){
    opcode = bcode[scond&0xf];
    scond = (scond & ~0xf) | Always;
}
@
<<global bcode(arm)>>=
static int bcode[] =
{
    ABEQ,
    ABNE,
    ABHS,
    ABLO,
    ABMI,
    ABPL,
    ABVS,
    ABVC,
    ABHI,
    ABLS,
    ABGE,
    ABLT,
    ABGT,
    ABLE,
    AB,
    ANOP,
};
@
%ocaml: just forbid it at parsing time
\t why not keep B.EQ ? to normalize helps 5l? but ironic that normalize
\t in inverse direction of what ARM actually has.

%dup: from parsing/cond-exec
The bit manipulation with [[scond]] above is because
[[scond]] in addition to store the conditional execution
also stores special ARM instruction bits
as explained in Section~\ref{sec:special-bits}.

\section{Operand output, [[outopd()]]}

Assuming a symbol index parameter [[symidx]] computed by the caller
(and explained in Section~\ref{sec:spreaded-symbol-table}),
[[outopd()]] outputs an operand
according to the format described
in the right of Figure~\ref{fig:object-format-complete}:

<<function zaddr(arm)>>=
/// main -> assemble -> yyparse -> outcode -> <>
void
outopd(Gen *a, int symidx)
{
    <<[[zaddr()]] locals(arm)>>

    Bputc(&obuf, a->type);
    Bputc(&obuf, a->reg);
    // idx in symbol table, 0 if no symbol involved in the operand
    Bputc(&obuf, symidx);
    // symkind of the symbol, or N_NONE
    Bputc(&obuf, a->symkind);

    switch(a->type) {
    <<[[zaddr()]] cases(arm)>>
    default:
        print("unknown type %d\n", a->type);
        exits("arg");

    }
}
@
%old: was zaddr, but no idea why, z for output, addr because kinda
% Adr used in Linker.nw. But clearer use outopd.
%ocaml: just use Marshall again in caller

\ifallcode
<<[[zaddr()]] locals(arm)>>=
long l;
char *n;
Ieee e;
int i;
@
\fi

The operand value has a variable size depending on the kind
of the operand:

<<[[zaddr()]] cases(arm)>>=
case D_NONE:
    break;

case D_REG:
    break;

case D_CONST:
case D_ADDR:
case D_OREG:
case D_BRANCH:
case D_SHIFT:
    l = a->offset;
    Bputc(&obuf, l);
    Bputc(&obuf, l>>8);
    Bputc(&obuf, l>>16);
    Bputc(&obuf, l>>24);
    break;

case D_SCONST:
    n = a->sval;
    for(i=0; i<NSNAME; i++) {
        Bputc(&obuf, *n);
        n++;
    }
    break;
@
%pad: I added case for D_ADDR
\t endianess for D_CONST/... ! portable format.


\section{Object file symbol table, [[h]] and [[ANAME]]}
\label{sec:spreaded-symbol-table}

%trans:
Operands can mention symbols which are important to keep track
in the object file since those symbol references must be resolved
later by the linker.
\l or for param and local to help debuggers.
% 
Because only one byte is used in the format of the operand
to store the index of the symbol involved 
(see Section~\ref{sec:object-format-complete}),
you could think Asm5 allows only 256 different symbols
in an assembly file. But, the {\em object file symbol table}
we will describe in this section,
in addition to be {\em spread} in the object file, is also a
{\em circular} table with 50 elements.
This clever scheme allows any number of symbols in an object file
as we will see.
\n uselessly complicated? if want only 1 byte for index, then need a 
\n circular thing and need to spread it.
\l can have more incremental linker also?

The global [[h]] below mimics in memory this circular table:
\l why global? why not static in outcode?
\n there will be a similar variable in ldobj() in the linker

<<global h>>=
// array<Htab>
struct Htab h[NSYM];
@
\t why call it h when really it's an array ...
<<constant NSYM>>=
#define	NSYM	50
@
\n need to be < 256 as currently use Bputc to marshall indexes in zaddr()
\n need to be the same in 5l if dont use defensive programming
\t but why not 255 then????
%ocaml: no need for this, just marshall with strings in operands,
% use more space but who cares, and Marshall may actually use shared strings

<<struct Htab>>=
struct Htab
{
    // option<ref<Sym>>
    Sym*    sym;
    //enum<Sym_kind>
    short   symkind;
};
@
\n we could put Htab in Core DS, h is reset in pinit(), but it's
\n really just local to the Output code generation so I think
\n it is better to put this DS here I think.
%old: I rename 'type' to symkind, to avoid confusion with Gen.type.
% Htab is a sliced subset of Sym but just for the symbols 
% (and an array instead of a hash, which is confusing name.


The object file symbol table [[h]] is different from the symbol
table [[hash]] we described in Section~\ref{sec:hash}.
Indeed [[hash]] is an hash table which keeps
track of macros, predefined identifiers, labels, and symbols.
The object file symbol table stores only symbols 
(and labels but only for debugging purpose)
and is just an array.

The first entry in [[h]] is unused since 0 represents
the absence of symbol in the operand format.
The next free entry is stored in the following global:

<<global symcounter>>=
int	symcounter;
@
%old: was called sym, but I renamed it to avoid overloading the sym name
% (as a global, as a field)
\l why not char instead? like symidx (or better byte)

<<[[pinit()]] initializations>>=
symcounter = 1;
for(i=0; i<NSYM; i++) {
    h[i].symkind = 0; // N_NONE
    h[i].sym = S;
}
@
\t still initialize h[0] because used later in symidx_of_symopt()
\n cant use N_NONE because factorized with x86
\t maybe could move that in aa.h?
\l needed only for pass 2

As we will output instructions in [[outcode()]], new symbols
will be referenced in operands and new entries in [[h]]
will be created as we will see soon. To output
in the object file a new entry, the following function is used:

<<function zname(arm)>>=
/// outcode -> <>
void
zname(char *n, int symkind, int symidx)
{

    Bputc(&obuf, ANAME);
    Bputc(&obuf, symkind);	/* type */
    Bputc(&obuf, symidx);	/* sym */
    while(*n) {
        Bputc(&obuf, *n);
        n++;
    }
    Bputc(&obuf, '\0');
}
@
\l rename? out_symbol_table_elt
\t symkind redundant? best here (with ANAME) or in the operand?
\t used a bit in 5l to set to SXREF the section
\t  of a symbol we know will be referred as a global symbol
\t  but could be done in inopd instead and so done differently
\t used for the N_EXTERN vs N_INTERN! but again
\t  not really cos could be done by inopd() again
\t useful also for OSIGNAME? but meh again
\t useful a bit for N_FILE/N_LINE in 5l, but symidx is always 1 in that case,
\t  and an AHISTORY is not that far, and string prefixed with '<'
\n symidx redundant too? Why need idx if we store the symbol entries 
\n  one after the other? Defensive programming? so can infer circular size?
\n  for fault-tolerance? or useful if other programs do not know the size
\n  of the circular buffer?

A new pseudo opcode is used:

<<[[Opcode]] cases, pseudo opcodes>>=
ANAME,
@
\n could be renamed ASYM
%old: if ANAME is after AHISTORY in 5.out.h then got
% some bugs in ar such as "inconsistent file xxx.5 in libc.a"
%update: maybe it was because the Makefile pb where actually
% libmach was not recompiled?

\l FIGURE? could extend object format figure

This constant must be part of the [[Opcode]] enum so that
it is different from any other opcode. This makes the
format of an object file unambiguous. Indeed, to read
an object file, we can just read one byte and decide
if the further bytes represent an instruction or an element
of the symbol table.
\t this is why also later will have AHISTORY part of that too
\t this is why also have AEND in enum.

We can finally see the code in [[outcode()]] which maintains
[[h]], manages the symbol indexes, and calls [[zname()]] when
a new entry is needed. The locals below are set by this
code. [[sf]] and [[st]] are passed to [[outopd()]]
(look at the code in Section~\ref{sec:outcode}):

<<[[outcode()]] locals>>=
// symbol from, index in h[]
int sf;
// symbol to, index in h[]
int st;
int oldsymcounter;
@

An additional field in [[Sym]] is needed to store
the index of symbols already present in [[h]]:

<<[[Sym]] identifier fields>>=
// index in h when the Sym is a symbol, 0 otherwise
int symidx;
@
\label{sec:symidx-sym-field}
%old: was called 'sym', but really it's an index in h, and it was confusing
% to have so many fields called sym already (as well as the global sym)
% char enough??
%old: was char, but in many places they use int for symcounter so I use int
% there too now
\t set to 0 in syminit? apparently not, because alloc = sbrk = zalloc

The code below to compute [[sf]] and [[st]] is rather subtle:

<<[[outcode()]] st and sf computation, and possible calls to zname>>=
jackpot:
oldsymcounter = symcounter;
sf = symidx_of_symopt(g1->sym, g1->symkind);
st = symidx_of_symopt(g2->sym, g2->symkind);
<<[[outcode()]] if jackpot condition goto jackpot>>
@

<<function symidx_of_symopt>>=
int
symidx_of_symopt(Sym *sym, int symkind)
{
    int idx = 0;
   
    if(sym != S) {
        idx = sym->symidx;
        <<[[symidx_of_symopt()]] sanity check idx>>
        
        // already generated an ANAME for this symbol reference?
        if((h[idx].symkind != symkind || h[idx].sym != sym)) {
            sym->symidx = symcounter;
            h[symcounter].sym = sym;
            h[symcounter].symkind = symkind;
            idx = symcounter;
            zname(sym->name, symkind, symcounter);
            
            symcounter++;
            if(symcounter >= NSYM)
                // circular array
                symcounter = 1;
        }
    }
    return idx;
}
@
%pad: I introduced this function, because original code was to hard
% to explain

<<[[symidx_of_symopt()]] sanity check idx>>=
if(idx < 0 || idx >= NSYM)
    idx = 0;
@

There is a rather complex condition which can force us to recompute
[[sf]] and [[st]]:

<<[[outcode()]] if jackpot condition goto jackpot>>=
if (sf == st && sf != 0 && symcounter != oldsymcounter) 
   goto jackpot;
@

This situation can happen for instance when the first operand
involves a symbol [[foo]] with an index of 10 ([[sf == 10]]) 
and when the second operand involves another symbol [[bar]] not yet seen. 
Because of the circular nature of [[h]], [[symcounter]] could have already
done one full round and be back to the value of 10.
This means the next entry is 10 and [[h[10].sym]] will be overwritten
to point now to the symbol for [[bar]].
In this case [[sf == st == 10]] but [[sf]] now points
to a wrong entry. In that case we want to recompute [[sf]]
hence the [[goto]].
\t why not infinite loop. what happens next iteration? h[idx].sym != sym
\t so increment
\l this is very very subtle (too subtle I think).
The extra condition about [[oldsymcounter]] is to avoid
an infinite loop in [[outcode()]] with code such 
as [[MOVW bar(SB), bar(SB)]].
\l even though invalid instructions anway rejected by the linker

\l Figure? tricky to understand loop and ref.

\t summary? copy paste figure of Linker? solidify with Jarod's comment:
% Si j'ai bien compris, quand tu lis le fichier code objet, comme tu
% reconstruis petit  petit ce tableau des symboles (h)  partir du
% dbut du fichier, et que tu mets  jour cette table avant de
% recontrer une instruction utilisant ce symbole, quand tu vois une
% rfrence  un numro de symbole dans une instruction, celui
% actuellement dans la table  cet index sera le bon.
%
% D'ailleurs dans la figure 9.1, Symbol1 a t utilis pour la
% premire fois dans Instruction3 et Symbol2 et Symbol3 dans
% l'instruction 4, c bien a ?


%old:
%<<[[outcode()]] st and sf computation, and possible calls to zname>>=
%jackpot:
%
%sf = 0;
%s = g1->sym;
%
%while(s != S) {
%    sf = s->symidx;
%
%    if(sf < 0 || sf >= NSYM)
%        sf = 0;
%
%    symkind = g1->symkind;
%
%    // already generated an ANAME for this symbol reference
%    if(h[sf].symkind == symkind)
%     if(h[sf].sym == s)
%        break;
%
%    s->symidx = symcounter;
%    h[symcounter].sym = s;
%    h[symcounter].symkind = symkind;
%    sf = symcounter;
%    zname(s->name, symkind, symcounter);
%
%    symcounter++;
%    if(symcounter >= NSYM)
%        symcounter = 1;
%    break;
%}
%
%st = 0;
%s = g2->sym;
%
%while(s != S) {
%    st = s->symidx;
%
%    if(st < 0 || st >= NSYM)
%        st = 0;
%
%    symkind = g2->symkind;
%
%    if(h[st].symkind == symkind)
%      if(h[st].sym == s)
%        break;
%
%    s->symidx = symcounter;
%    h[symcounter].sym = s;
%    h[symcounter].symkind = symkind;
%    st = symcounter;
%    zname(s->name, symkind, symcounter);
%
%    symcounter++;
%    if(symcounter >= NSYM)
%        symcounter = 1;
%
%    if(st == sf)
%        goto jackpot;
%    break;
%}
%@
% use a while so can break? argh, horrible. This code was really bad.

\t put 5l -v -w where see ANAME just before the instruction
\t see 5l -v -W helloworld.5

\t nm
\l so need to output information about use of external symbols! 'U'
\l and also information about symbols the module defines! 'T', 'D'


%real-world: objdump --syms foo.o





\chapter{Debugging Support}
\label{chap:debugging}

The \plan debugger [[db]], which we will describe in the \book{Debugger},
has access to lots of {\em metadata} in the executable to help debug programs.
For instance, here is a simplified output of [[db]] when 
debugging a C program:

\begin{verbatim}
$ db hello
...
main(argv=...) /usr/.../main.c 
      called from _main+26 (/sys/.../main9.s:12)
...
\end{verbatim}
\t exact trace? no line number for main? 
\l use it instead on helloa?

[[db]] knows from which {file} and which {line} a piece of machine
code comes from. It also knows 
the name of the function containing this piece of machine code, 
the names of the parameters of this function, as well as 
the name of the caller to this function. 
Finally it knows the file and line of this caller function.
\t illustrate with actual thing [[main()]], [[_main()]], etc

The metadata in the executable comes from
corresponding metadata in the object files generated by [[5a]] and [[5c]]. 
%
Indeed, the names of the parameters, locals, and entities are kept 
in the object file as we have seen
in the previous chapter. %clever\ref{chap:generation}
\n we will see later how kept also by linker.
%dup: overview/input-lang and parsing/operands/names
This is why Asm5 programmers write code like [[MOVW  count+4(FP), R1]]
even though [[count]] is not used to generate any machine code.
Indeed, this symbol is actually kept in the object file
and then transmitted in the executable and can 
then be used by debuggers and tracers.
%
Labels are resolved during parsing by [[5a]] but the names of those
labels are also kept in the object file symbol table.
Their references in operands are kept too, which again helps
to debug programs.
\l help debug jump? but actually not present in executable symbol table

%toc:
In this chapter we will focus on the file and line information
as the information about symbols has already been described
in the previous chapter. %clever\ref{chap:generation}

%real-world: in gas needs -g to keep debugging info in object file?
% DWARF is assembler debugging? STABS?

\section{Line origin history, [[Hist]]}
\label{sec:hist}
\n could be in Preprocess chapter, but even if no cpp, still need handle #line

Because [[5a]] is a macro-assembler, the file and line origin of an
instruction in the object file are not necessarily the assembly filename
passed on the command line to [[5a]] and a line number in this file.
Indeed, this file could have included via [[#include]] other files containing
also assembly instructions.
\n even though in practice it will be more constants
Moreover, some assembly files are derived from C programs in which 
case one would rather have the location metadata refers to line numbers
in the original C programs (thanks to the [[#line]] directive 
we saw in Section~\ref{sec:sharp-line}) than line numbers
in the generated assembly programs.
%
So, recording only a line number in the format of an instruction
as described in Section~\ref{sec:object-format-complete} seems
insufficient; a filename should also be recorded.
\n but each time a pair of line x file would be costly

The global [[lineno]] we introduced in Section~\ref{sec:lineno},
and which is used by [[outcode()]] to store the line number of an
instruction in the object file, 
is incremented after each newlines by the lexer (see
for instance Section~\ref{sec:semicolon}).
But, this is done while pre-processing the file which means [[lineno]]
is actually more a {\em global line number} than a line number 
in one file. What we need then is a way to go from a global line number
to a filename and a {\em local line number}.

The following structure will help to keep track of the 
[[#include]] and [[#line]] directives used while pre-processing 
the input file.
This will allow us then to compute the file and local line number
of a global line number.

<<struct Hist>>=
struct  Hist
{
    // option<ref_own<string> (None = nil = a ``pop'')
    char*   filename; 

    // global line of this Hist
    long    global_line;       
    // 0 for #include, +n for #line, -1 for #pragma lib (ugly)
    long    local_line; 

    // Extra
    <<[[Hist]] extra fields>>
};
@
%ocaml: just do for #line, so simpler, and return with AST, no need
% abuse instr format, just use another constructor in ADT
%old: renamed offset to local_line, clearer; avoid confusion with Gen.offset
% also renamed line to global_line, more consistent.
\t abused for #pragma lib "xxx.a" where local_line is then -1. ugly.
\l many of the comments above will be explained later.
\t why History? because not just origin, but parents too?

The global [[hist]] below maintains a list of those [[Hist]].
The first element of this list will be the input assembly file of [[5a]]
passed on the command line.

<<global hist>>=
// list<ref_own<Hist>> (next = Hist.link)
Hist*	hist;
@
%ocaml: use a tree directly (or just handle #line so more uniform)
<<[[Hist]] extra fields>>=
// list<ref<Hist>> (from = hist)
Hist*   link;
@
<<constant H>>=
#define H   ((Hist*)nil)
@

We will need also a fast access to the tail of the list:
\l because kind f a stack

<<global ehist>>=
// ref<Hist> (end from = hist)
Hist*	ehist;
@


\section{Recording history, [[linehist()]]}

The only function modifying [[hist]] is [[linehist()]].
It is called notably by [[newfile()]] which itself is called
at the beginning in [[pinit()]] with the name of the input
assembly file and later for each included file:

<<[[newfile()]] call linehist>>=
linehist(s, 0);
@

<<function linehist>>=
/// (pinit | macinc -> newfile) | (GETC -> filbuf) | maclin -> <>
void
linehist(char *f, int local_line)
{
    Hist *h;

    <<[[linehist()]] debug>>

    h = alloc(sizeof(Hist));
    h->filename = f;
    h->global_line = lineno;
    h->local_line = local_line;

    //add_list(hist, ehist, h)
    h->link = H;
    if(ehist == H) {
        hist = h;
        ehist = h;
        return;
    }
    ehist->link = h;
    ehist = h;
}
@
\n debug used in appendix

It is also called for [[#line]] directives such as [[#line 10 "foo"]]:

<<[[maclin()]] call linehist>>=
linehist(cp, n);
@

Note that the included files form a tree. We use a list data
structure though for [[hist]] which seems insufficient.
But, the special value [[nil]]
in a [[Hist]] encodes the end of a file which is enough
to reconstruct the tree:

<<[[filbuf()]] when close file, call linehist>>=
linehist(nil, 0);
@
%ocaml: use a tree directly

Figure~\ref{fig:hist} illustrates the evolution of
the global [[lineno]] on the content of [[/tests/cpp/foo.s]]
(which includes other files) as well as the value
of [[hist]] and [[ehist]] after having pre-processed the entire file.

\begin{figure}[!]\centering
\begin{verbatim}
                                               hist
                                        +--------------------+
     foo.s---------------------------+ >|"foo.s", G1, L0     |
 1   |L1                             |  +--------------------+
 2   |L2                             |
 3   |L3 #include "foo.h"            |  +--------------------+
     |   foo.h-------------------+ - + >|"foo.h", G4, L0     |
 4   |   |L1 #include "foo1.h"   |   |  +--------------------+
     |   |   foo1.h-----------+ -|- -|->|"foo1.h", G5, L0    |
 5   |   |   |L1              |  |   |  +--------------------+
     |   |   +----------------+ -|- -|->|nil, G5, L0         |
 6   |   |L2                     |   |  +--------------------+
 7   |   |L3 #include "foo2.h"   |   |  +--------------------+
     |   |   foo2.h-----------+ -|- -|->|"foo2.h", G8, L0    |
 8   |   |   |L1              |  |   |  +--------------------+
     |   |   +----------------+ -|- -|->|nil, G8, L0         |
 9   |   |L4                     |   |  +--------------------+
 10  |   |L5                     |   |  +--------------------+
     |   +-----------------------+ - + >|nil, G10, L0        |
 11  |L4                             |  +--------------------+
 12  |L5 #include "bar.s"            |  +--------------------+
     |   bar.s-------------------+ - + >|"bar.s", G13, L0    |
 13  |   |L1                     |   |  +--------------------+
 14  |   |L2                     |   |  +--------------------+
     |   +-----------------------+ - + >|nil, G14, L0        |
 15  | L6                            |  +--------------------+
 16  | L7                            |  +--------------------+
 17  | L8#line 10 "foobar.c"         |  |"foobar.c", G18, L10|
 18  | L9                            |  +--------------------+
 19  |L10                            |  +--------------------+
     +-------------------------------+ >|nil, G19, L0        |
                                        +--------------------+
lineno          foo.s and                     ehist
(global)     included files
\end{verbatim}
\caption{Values of [[lineno]] and [[hist]] for [[/tests/cpp/foo.s]].}
\label{fig:hist}
\end{figure}

One of the option of [[5a]] described in Section~\ref{sec:debug-line}
helps to debug the debugging support code itself by logging
the value of [[lineno]] and [[Hist]] elements in the
calls to [[linehist()]]:

\begin{verbatim}
$ cd /tests/cpp
$ 5a -f foo.s
   1: foo.s
   4: foo.h
   5: foo1.h
   6: <pop>
   8: foo2.h
   9: <pop>
  11: <pop>
  13: bar.s
  15: <pop>
  18: foobar.c (#line 10)
  20: <pop>
...
\end{verbatim}
\n actually logged two times because two pass algorithm of 5a

%old: newflag dead? seems just set to false ... just one write.
%% it's used in cc/ though, but we copy pasted code for macbody so
% I think it's safe to delete it here.
%<<global newflag>>=
%bool	newflag;
%@
%
%    <<[[linehist()]] newflag hack>>
%    <<[[linehist()]] debug>>
%    newflag = false;
%
%
%<<[[linehist()]] newflag hack>>=
%/*
% * overwrite the last #line directive if
% * no alloc has happened since the last one
% */
%if(newflag == false && ehist != H && offset != 0 && ehist->offset != 0)
%    if(f && ehist->filename && strcmp(f, ehist->filename) == 0) {
%        ehist->line = lineno;
%        ehist->offset = offset;
%        return;
%    }
%@






\section{Displaying history, [[prfile()]]}
\n I prefer to put prfile() here rather than in the Error appendix.
\n so can better understand actually the tracing mechanism.

By keeping the full {history} of the [[#include]] directives, 
\l and [[#line]] but less
[[5a]] can also give better error message such as:

\begin{verbatim}
$ 5a foo.s
foo.s:5 bar.s:2 redeclaration of lbl1
\end{verbatim}
\t actually seems buggy, should be foo.s:5 but says foo.s:7
\t Copy Lconv in 5c. 5c instead report (correctly):     bar.s:2 foo.s:5 ...

This means the error is in the file [[bar.s]] at line 2 and this
file was actually included from [[foo.s]].
\t especially useful for C code, where can be really tricky to fix error
\t because of some ifdef, and losts of nested include to understand
\t where it comes from
%
We are now ready to understand [[prfile()]] which
is used when reporting error in [[5a]]. It converts
a global line number [[l]] into a series of filenames and line numbers
representing the {history} of this global line.

The size of this series is limited to 20 elements:

<<constant HISTSZ>>=
#define HISTSZ      20
@

For instance with the data on Figure~\ref{fig:hist}, 
[[prfile(14)]] should print:

\begin{verbatim}
foo.s:5 bar.s:2
\end{verbatim}
\t but actually says foo.s:7

\l prfile compute a and n, where a[n-1] contain info about file with error
\l and a[0..n-2] "parent" of this included file if included
\l On our previous example we want a = [....; ...]

<<function prfile>>=
/// yyerror -> <>
void
prfile(long l)
{
    Hist a[HISTSZ];
    int n = 0;
    Hist *h;
    int i;
    long d;

    <<[[prfile()]] compute a and n>>
    if(n > HISTSZ)
        n = HISTSZ;
    for(i=0; i<n; i++)
        print("%s:%ld ", a[i].filename, 
                         (long)(l - a[i].global_line + a[i].local_line + 1));
}
@

The [[+1]] above is to have line numbers starting at 1.

<<[[prfile()]] compute a and n>>=
for(h = hist; h != H; h = h->link) {
    if(l >= h->global_line) {
        if(h->filename) {
            // a #include
            if(h->local_line == 0) {
                if(n >= 0 && n < HISTSZ)
                    a[n] = *h;
                n++;
            } 
            <<[[prfile()]] compute a and n, when line directive>>
        }
        // a pop
        else {
            n--;
            <<[[prfile()]] compute a and n, when pop, adjust parents>>
        }
    }
}
@
%old: was using more break, I rewrote a bit

\t need another field to correctly adjust the parents, see LConv

<<[[prfile()]] compute a and n, when pop, adjust parents>>=
if(n >= 0 && n < HISTSZ) {
    d = h->global_line - a[n].global_line;
    for(i=0; i<n; i++)
        a[i].global_line += d;
}
@

<<[[prfile()]] compute a and n, when line directive>>=
// a #line
else {
    if(n > 0 && n < HISTSZ)
        // previous was a #include
        if(a[n-1].local_line == 0) {
            a[n] = *h;
            n++;
        } else
            a[n-1] = *h; // overwrite previous #line
}
@


\section{Saving history, [[outhist()]] and [[AHISTORY]]}
\label{sec:object-file-history}
\n Was called Header section, but not really an header in traditional sense.
\n The object could be parsed without those AHISTORY and ANAME I think.

%trans:
We can now describe the only missing piece in the object file
format in Figure~\ref{fig:object-format-complete}: 
%
the [[files/lines history]] at the beginning of the object file.
%
The function below is called by [[assemble()]] before
the many calls to [[outcode()]] and essentially serializes [[hist]].
To do so it is reusing (some would say abusing) the instruction
format and the symbol table format to respectively store the
global/local line numbers in a [[Hist]] and its filename:

<<function outhist(arm)>>=
/// main -> assemble -> <> (at beginning of pass 2)
void
outhist(void)
{
    Gen g;
    Hist *h;
    char *p;
    <<[[outhist()]] locals(arm)>>

    g = nullgen;
    for(h = hist; h != H; h = h->link) {
        p = h->filename;

        <<[[outhist()]] adjust p and op if p is relative filename>>
        <<[[outhist()]] output each path component as an ANAME>>

        Bputc(&obuf, AHISTORY);
        Bputc(&obuf, Always);
        Bputc(&obuf, 0); // reg, but could be R_NONE too 
        Bputc(&obuf, h->global_line);
        Bputc(&obuf, h->global_line>>8);
        Bputc(&obuf, h->global_line>>16);
        Bputc(&obuf, h->global_line>>24);
        outopd(&nullgen, 0);
        g.offset = h->local_line;
        outopd(&g, 0);
    }
}
@
%ocaml: should not abuse/reuse same format than instruction
\t bug???? g.offset is used? do zaddr(&g, 0) but g.type = D_NONE
\t at this point which means the offset will not be used.
\n this was working for 8a, but not for 5a because zaddr()(x86) is different.

\t look at linker reading back code, expect a D_CONST here?

\t !!!use 5l -v -W to see those AHISTORY and ANAME; it can help debug things!!!

Again, just like for [[ANAME]], a new pseudo opcode is used,
different from any other opcode, so that the linker
can just read one byte in the object file and decide
if the further bytes represent an instruction or an element
of the symbol table or a line history element:

<<[[Opcode]] cases, pseudo opcodes>>=
AHISTORY,
@

The [[Hist.filename]] is stored in the object file symbol table with [[ANAME]].
%
The full filename is actually split according to its directory
components and each component is stored separately with
its own entry in the object file symbol table.
\t why not full string? why split in components???

\l maybe good to take simplest case where have no #include, then output?

\ifallcode
<<[[outhist()]] locals(arm)>>=
char *q;
int n;
@
\fi

<<[[outhist()]] output each path component as an ANAME>>=
// =~ split("/", p) ...
while(p) {
    q = strchr(p, '/');
    if(q) {
        n = q-p;
        if(n == 0){
            n = 1;	/* leading "/" */
            *p = '/'; // redundant?
        }
        q++;
    } else {
        n = strlen(p);
        q = nil;
    }

    if(n) {
        Bputc(&obuf, ANAME);
        Bputc(&obuf, N_FILE);	/* type */ // symkind
        Bputc(&obuf, 1);	    /* sym */  // symidx
        Bputc(&obuf, '<');
        Bwrite(&obuf, p, n);
        Bputc(&obuf, '\0');
    }
    p = q;
    <<[[outhist()]] adjust p and op if p was a relative filename>>
}
@
%ocaml: Just use Str.split |> ... or simply Marshall, useless opti

\t why put leading '<'? lose space, defensive programming?
\t  no cos no no conflit with other symbols, useful in linker
\t  so does not take space of procedure or global
%ocaml: but key should be string x symkind!

\t why print each directory path separately?
\t  to offer optimization opportunity later in linker! factorize paths!
\t  save space in executable
%ocaml: useful opti really? meh.

Note the use of the same symbol index above, [[1]], which normally
is incremented after each symbol is added in 
Section~\ref{sec:spreaded-symbol-table}.
This is because the code in the linker which loads the object file
treats specially those entries in the object file symbol table.
A new kind of symbol is also used:

<<[[Sym_kind]] cases>>=
N_FILE,
@
%old: was D_FILE
\t useful? if remove symkind from ANAME, need that? defensive programming?
\t it's actually more N_FILE_COMPONENT

\l so have at beginning of file many ANAME:N_FILE/1, ANAME:N_FILE/1, and then
\l later finally a real ANAME:N_EXTERN/1 reusing 1 too.


The code below is to convert relative filenames into
absolute paths. Indeed, The object file stores absolute filenames, 
which is better for [[db]] so that wherever [[db]] is run from, it can
find the source files referenced in the executable.
\n realpath spirit! ocamldebug needed that, see jwatzman patch
Remember that [[pathname]] below is the current working directory
set in [[cinit()]] in Section~\ref{sec:pathname}.

<<[[outhist()]] locals(arm)>>=
char *op;
@

<<[[outhist()]] adjust p and op if p is relative filename>>=
if(p && p[0] != '/' && h->local_line == 0 && pathname && pathname[0] == '/') {
    op = p; // save p
    p = pathname; // start with cwd
} else {
    op = nil; // start directly with p
}
@
%ocaml: Filename.concat, instead of being afraid to alloc and use op.
%old: I rewrote and put the nested if in the &&
\l #line directive are supposed to be absolute already?

<<[[outhist()]] adjust p and op if p was a relative filename>>=
if(p == nil && op) {
    p = op;
    op = nil;
}
@








\chapter{Advanced Topics TODO}
\label{chap:advanced}

%trans:
I have described in the previous chapters
all the main features of Asm5 and [[5a]].
%
You can write many assembly programs with only the
instructions I described until now, and you can
have a working assembler with only the code I presented before.
%toc:
In this chapter, I will describe features of Asm5
and [[5a]] that I did not present before to simplify the
explanations. Those features are used more rarely by the 
assembly programmer.
% actually start with Asm9, e.g., symbolic constants,
%, then advanced ARM instructions or registers
% mapped in Asm5, e.g., float
% then few more pseudo opcodes, used only by 5c or 5l, no reading
% syntax

\section{Other assembly language features}

\subsection{Constant expressions}
\label{sec:constant-expr}

% it's not Fortran, we're making an assembler :)
% so it's constant expressions here!

% a bit tricky because we see AADD, AMUL, AAND,
% which corresponds to C operator, and here we use those
% C operators in the assembler itself.

<<type declarations(arm)>>=
%type   <lval>  con expr 
@

<<con rule>>=
| '(' expr ')' { $$ = $2; }
@
%$

% convenient to have this, when combined with macros it
% can do powerful stuff!



<<priority and associativity declarations>>=
%left   '|'
%left   '^'
%left   '&'
%left   '<' '>'
%left   '+' '-'
%left   '*' '/' '%'
@
% lower in the file = higher priority, earlier = lower priority

<<constant expression rules>>=
<<con rule>>
<<expr rule>>
@

<<expr rule>>=
expr:
  con
| expr '+' expr     { $$ = $1 + $3; }
| expr '-' expr     { $$ = $1 - $3; }
| expr '*' expr     { $$ = $1 * $3; }
| expr '/' expr     { $$ = $1 / $3; }
| expr '%' expr     { $$ = $1 % $3; }

| expr '<' '<' expr { $$ = $1 << $4; }
| expr '>' '>' expr { $$ = $1 >> $4; }

| expr '&' expr     { $$ = $1 & $3; }
| expr '^' expr     { $$ = $1 ^ $3; }
| expr '|' expr     { $$ = $1 | $3; }

@





\subsection{Symbolic constants}
\n useful? cpp can do that too. Was originally called Var, hmm.
\n Now that I explain less cpp in the Assembler book
\n  it is maybe ok to keep it. Moreover, there are a few assembly files
\n  that use those variables.

<<line rule(arm)>>=
| LNAME '=' expr ';'
 {
  $1->type = LVAR;
  $1->value = $3;
 }
| LVAR '=' expr ';'
 {
  if($1->value != $3)
   yyerror("redeclaration of %s", $1->name);
  $1->value = $3;
 }
@
%ocaml: get rid of, cpp can do that; no need lexer/parser coop then.

<<con rule>>=
| LVAR         { $$ = $1->value; }
@
%$
\n which can be derived by expr

%real-world: .EQU?

\ifallcode
\subsection{Optional commas}
% the optional ',' why? because asm can ge generated by 5c -S that does
% this. A bit ugly so maybe better to aspectize this.
% actually I removed most of the use of comma for 5a/a.y 
% so maybe could even remove this rule, or keep it
% just for the comment about 5c -S.

<<opt rules>>=
comma:
  /* empty */
| ',' comma
@
\fi
%ocaml: can be stricter

\section{Other instructions and registers}

\subsection{Floating-point numbers}
\n instructions and registers
\label{sec:float}

% cinit | yylex -> <>
<<constant FPCHIP(arm)>>=
#define FPCHIP      true
@


% optional cos can simulate floats in software.
% also can use fixed-precision arithmetic with integers (see ICFP
% contest I did with the car racing)

%AST
<<struct ieee>>=
/*
 * this is the simulated IEEE floating point
 */
struct	ieee
{
    long	l;	/* contains ls-man	0xffffffff */
    long	h;	/* contains sign	0x80000000
                    exp		0x7ff00000
                    ms-man	0x000fffff */
};
@
% ls/ms?
% FIGURE with different bits. 0..16..32 0..16..32

%OPCODE

% Word, Double, Float? WDF?
<<[[Opcode]] cases, float mov opcodes>>=
AMOVWD,
AMOVWF,
AMOVDW,
AMOVFW,
AMOVFD,
AMOVDF,
AMOVF,
AMOVD,
@
<<[[itab]] elements>>=
"MOVD",		LMOV, AMOVD,
"MOVDF",	LMOV, AMOVDF,
"MOVDW",	LMOV, AMOVDW,
"MOVF",		LMOV, AMOVF,
"MOVFD",	LMOV, AMOVFD,
"MOVFW",	LMOV, AMOVFW,
"MOVWD",	LMOV, AMOVWD,
"MOVWF",	LMOV, AMOVWF,
@

<<[[Opcode]] cases, float arithmetic opcodes>>=
ACMPF,
ACMPD,
AADDF,
AADDD,
ASUBF,
ASUBD,
AMULF,
AMULD,
ADIVF,
ADIVD,
ASQRTF,
ASQRTD,
@
% SQRT is an instr?
<<[[itab]] elements>>=
"CMPF",		LCMPFLOAT, ACMPF,
"CMPD",		LCMPFLOAT, ACMPD,
"ADDF",		LARITHFLOAT,	AADDF,
"ADDD",		LARITHFLOAT,	AADDD,
"SUBF",		LARITHFLOAT,	ASUBF,
"SUBD",		LARITHFLOAT,	ASUBD,
"MULF",		LARITHFLOAT,	AMULF,
"MULD",		LARITHFLOAT,	AMULD,
"DIVF",		LARITHFLOAT,	ADIVF,
"DIVD",		LARITHFLOAT,	ADIVD,
"SQRTF",	LSQRTFLOAT, ASQRTF,
"SQRTD",	LSQRTFLOAT, ASQRTD,
@
%old: SQRTxx was LMISC (which was LTYPEI), but better LSQRTFLOAT

% commented in the original code
%/*
%    "ABSF",		LMISC, AABSF,
%    "ABSD",		LMISC, AABSD,
%    "NEGF",		LMISC, ANEGF,
%    "NEGD",		LMISC, ANEGD,
%    "SQTF",		LMISC,	ASQTF,
%    "SQTD",		LMISC,	ASQTD,
%    "RNDF",		LMISC,	ARNDF,
%    "RNDD",		LMISC,	ARNDD,
%    "URDF",		LMISC,	AURDF,
%    "URDD",		LMISC,	AURDD,
%    "NRMF",		LMISC,	ANRMF,
%    "NRMD",		LMISC,	ANRMD,
%*/


%REGISTERS

<<[[itab]] elements>>=
"F",		LF,	0,

"F0",		LFREG,	0,
"F1",		LFREG,	1,
"F2",		LFREG,	2,
"F3",		LFREG,	3,
"F4",		LFREG,	4,
"F5",		LFREG,	5,
"F6",		LFREG,	6,
"F7",		LFREG,	7,
"F8",		LFREG,	8,
"F9",		LFREG,	9,
"F10",		LFREG,	10,
"F11",		LFREG,	11,
"F12",		LFREG,	12,
"F13",		LFREG,	13,
"F14",		LFREG,	14,
"F15",		LFREG,	15,
@


<<[[itab]] elements>>=
"FPSR",		LFCR,	0,
"FPCR",		LFCR,	1,
@

<<enum fregister(arm)>>=
enum Fregister {
    FREGRET = 0,
    /* compiler allocates register variables F0 up */
    FREGEXT = 7,
    /* compiler allocates external registers F7 down */
    FREGTMP = 15, // ??

    NFREG = 8,
};
@
% NFREG used by 5c/ in char	reg[NREG+NFREG];
% 8? looks like 16 above

% GRAMMAR

<<inst rule(arm)>>=
/*
 * floating-point coprocessor
 */
| LARITHFLOAT cond frcon ',' freg { outcode($1, $2, &$3, R_NONE, &$5); }
| LARITHFLOAT cond frcon ',' LFREG ',' freg { outcode($1, $2, &$3, $5, &$7); }
| LCMPFLOAT  cond freg ',' freg { outcode($1, $2, &$3, $5.reg, &nullgen); }
| LSQRTFLOAT cond freg ',' freg { outcode($1, $2, &$3, R_NONE, &$5); }
@
%$
\l could change LFREG and use a fregi?
% use again outcode! 

<<[[Operand_kind]] cases>>=
D_FREG,
D_FPCR,
@
% FPCR is the float pending of D_PSR?
% also FCONST we have seen before in core DS


<<type declarations(arm)>>=
%type <genval> freg fcon frcon
@

% for MOV
<<more gen rule>>=
| freg
@

<<ximm rule>>=
| fcon
@

<<float rules>>=
freg:
  LFREG
 {
  $$ = nullgen;
  $$.type = D_FREG;
  $$.reg = $1;
 }
| LF '(' con ')'
 {
  $$ = nullgen;
  $$.type = D_FREG;
  $$.reg = $3;
 }

fcon:
 '$' LFCONST
 {
  $$ = nullgen;
  $$.type = D_FCONST;
  $$.dval = $2;
 }
| '$' '-' LFCONST
 {
  $$ = nullgen;
  $$.type = D_FCONST;
  $$.dval = -$3;
 }

frcon:
  freg
| fcon
@
%$



<<more gen rule>>=
| LFCR
 {
  $$ = nullgen;
  $$.type = D_FPCR;
  $$.reg = $1;
 }
@
%$

% OBJECT CODE GENERATION

<<[[zaddr()]] cases(arm)>>=
case D_FREG:
case D_FPCR:
    break;
@

<<[[zaddr()]] cases(arm)>>=
case D_FCONST:
    ieeedtod(&e, a->dval);
    Bputc(&obuf, e.l);
    Bputc(&obuf, e.l>>8);
    Bputc(&obuf, e.l>>16);
    Bputc(&obuf, e.l>>24);
    Bputc(&obuf, e.h);
    Bputc(&obuf, e.h>>8);
    Bputc(&obuf, e.h>>16);
    Bputc(&obuf, e.h>>24);
    break;
@
% >> >> >> >> >> >> >> >> >>

% ?? -> <>
<<function ieeedtod>>=
void
ieeedtod(Ieee *ieee, double native)
{
    double fr, ho, f;
    int exp;

    if(native < 0) {
        ieeedtod(ieee, -native);
        ieee->h |= 0x80000000L;
        return;
    }
    if(native == 0) {
        ieee->l = 0;
        ieee->h = 0;
        return;
    }
    fr = frexp(native, &exp);
    f = 2097152L;		/* shouldnt use fp constants here */
    fr = modf(fr*f, &ho);
    ieee->h = ho;
    ieee->h &= 0xfffffL;
    ieee->h |= (exp+1022L) << 20;
    f = 65536L;
    fr = modf(fr*f, &ho);
    ieee->l = ho;
    ieee->l <<= 16;
    ieee->l |= (long)(fr*f);
}
@


\subsection{Multiplication and accumulation}

% multiply and accumulate
<<[[Opcode]] cases, mul/div/mod opcodes>>=
AMULA,
@
<<[[itab]] elements>>=
"MULA",		LMULA, AMULA,
@

<<inst rule(arm)>>=
/*
 * MULA hi,lo,r1,r2
 */
| LMULA cond reg ',' reg ',' reg ',' regi 
 {
  $7.type = D_REGREG;
  $7.offset = $9;
  outcode($1, $2, &$3, $5.reg, &$7);
 }
@
%$
%ocaml: abuse offset, ADT would be better!
\l could use regreg here

<<[[Operand_kind]] cases>>=
D_REGREG,
@

<<[[zaddr()]] cases(arm)>>=
case D_REGREG:
    Bputc(&obuf, a->offset);
    break;
@


\subsection{64-bits multiplication}
% target
\t very long?
\n advanced topic, so can also put D_REGREG here
\l see also vlong argument in pwrite, and also endianess issue (jarod)

%\subsubsection{Mul long}

<<[[Opcode]] cases, mul/div/mod opcodes>>=
AMULL,
AMULAL,
AMULLU,
AMULALU,
@

<<[[itab]] elements>>=
"MULL",		LMULL, AMULL,
"MULAL",	LMULL, AMULAL,
"MULLU",	LMULL, AMULLU,
"MULALU",	LMULL, AMULALU,
@



% MULL special instruction?
<<inst rule(arm)>>=
/*
 * MULL hi,lo,r1,r2
 */
| LMULL cond reg ',' reg ',' regreg { outcode($1, $2, &$3, $5.reg, &$7); }
@
%$
% ugly $5.reg? why not use regi now?



<<type declarations(arm)>>=
%type   <genval>   regreg
@

<<operand rules(arm)>>=
/* for MULL */
regreg:
 '(' regi ',' regi ')'
 {
  $$ = nullgen;
  $$.type = D_REGREG;
  $$.reg = $2;
  $$.offset = $4;
 }
@
% abuse offset again ... grrr
\l could use that also for mult and acc?

\subsection{Moving multiple registers at the same time}
\label{sec:movm}

% what for? for big push?

% move many?
<<[[Opcode]] cases, mov opcodes>>=
AMOVM,
@

<<[[itab]] elements>>=
"MOVM",		LMOVM, AMOVM,
@
%in lproc.s 
%	RFE				/* MOVM.IA.S.W (R13), [R15] */

%todo: abuse D_CONST again, why not D_MULTI instead?

<<inst rule(arm)>>=
/*
 * MOVM
 */
| LMOVM cond ioreg ',' '[' reglist ']'
 {
  Gen g;

  g = nullgen;
  g.type = D_CONST;
  g.offset = $6;
  outcode($1, $2, &$3, R_NONE, &g);
 }
| LMOVM cond '[' reglist ']' ',' ioreg
 {
  Gen g;

  g = nullgen;
  g.type = D_CONST;
  g.offset = $4;
  outcode($1, $2, &g, R_NONE, &$7);
 }
@


<<type declarations(arm)>>=
%type   <lval>  reglist
@


<<reglist rule>>=
reglist:
  regi           { $$ = 1 << $1; }
| regi '-' regi
 {
  int i;
  $$=0;
  for(i=$1; i<=$3; i++)
      $$ |= 1<<i;
  for(i=$3; i<=$1; i++)
      $$ |= 1<<i;
 }
| regi ',' reglist { $$ = (1<<$1) | $3; }
@
%$
%old: was using comma here

% MOVM can also use special bits.

<<[[itab]] elements>>=
".U",		LS,	C_UBIT,
@

<<constant C_UBIT(arm)>>=
#define C_UBIT  (1<<7)  /* up bit */
@
% >>
\l ambiguous with F_BIT

% I originally thought that .U was useful also for MOVW but
% the direction is automatically handled by 5l. If offset is
% negatif then unset, if positif then set U. 
% Then it could have been useful for moves not involving offsets
% but registers as in MOVW.U R1(R2), R3, assuming the absence of .U
% will actually consider -R1. But actually this syntax is not
% supported AND R1 can represent negatif number directly
% => really useless for Moves.

% Used only for MOVM.
% Maybe could remove them.

<<[[itab]] elements>>=
".IB",		LS,	C_PBIT|C_UBIT,
".IA",		LS,	C_UBIT,
".DB",		LS,	C_PBIT,
".DA",		LS,	0,
@
% easier to read.
% see asm.ps ARM section: "addressing modes are supported by suffixes
% of the instruction, IA = increment after, IB = increment before, ..."
% DA = decrement after, DB = decrement before

% composite
<<[[itab]] elements>>=
".PW",		LS,	C_WBIT|C_PBIT,
".WP",		LS,	C_WBIT|C_PBIT,
@
\l meh does not make any sense actually this combination for MOVW, OR maybe it
\l  does when considering MOVM!

% composite or alternate form
<<[[itab]] elements>>=
".IBW",		LS,	C_WBIT|C_PBIT|C_UBIT,
".IAW",		LS,	C_WBIT|C_UBIT,
".DBW",		LS,	C_WBIT|C_PBIT,
".DAW",		LS,	C_WBIT,
@

% those are used in lexception.s, in bcm/, in libcore/arm/, etc.



%\section{Misc instructions}

% seems dead
%<<[[Opcode]] cases, misc opcodes>>=
%ABX, // ?
%ABXRET, // ?
%@
%<<[[itab]] elements>>=
%"BX",		LTYPEBX,	ABX,
%@
%<<inst rule(arm)>>=
%/*
% * BX
% */
%| LTYPEBX comma ireg { outcode($1, Always, &nullgen, R_NONE, &$3); }
%@

%dead: ADWORD, // ? no reading syntax


\subsection{Program status register}

% program status register, works with MOV but normally it's a special
% ARM load/store instructions: MSR and MRS (here emulated by a single MOV)
% CPSR = ? SPSR = ?
<<[[itab]] elements>>=
"CPSR",		LPSR,	0,
"SPSR",		LPSR,	1,
@
% CPSR is maybe system status register, see l.s where
% do
%	MOVW	$(PsrDirq|PsrDfiq|PsrMsvc), R1
%	MOVW	R1, CPSR


% MSR = Status to Register, and Register to Status?

<<[[Operand_kind]] cases>>=
D_PSR,
@
% similar to D_REG really, just with special register, so reg field
% is enum<Register> | enum<Status_register>

<<[[zaddr()]] cases(arm)>>=
case D_PSR:
    break;
@

<<more gen rule>>=
| LPSR
 {
  $$ = nullgen;
  $$.type = D_PSR;
  $$.reg = $1;
 }
@
%$
% Status register? move earlier? 


<<constant C_FBIT(arm)>>=
#define C_FBIT  (1<<7)  /* psr flags-only */
@
% >>

<<[[itab]] elements>>=
".F",		LS,	C_FBIT,
@


\subsection{Mutual exclusion}

% have reading syntax, but not transformed by 5l ... not handled,
%<<[[Opcode]] cases, misc opcodes>>=
%ALDREX,
%ASTREX,
%ALDREXD,
%ASTREXD,
%@
%% LDREX STREX CLREX are arm v7 new instruction according to 5db.c
%% =~ LDR EXCLUSIF, STR EXCLUSIF.
%% actually they are defined as macros in atom.s:
%%#define	CLREX		WORD	$0xf57ff01f
%%#define	LDREX(a,r)	WORD	$(0xe<<28|0x01900f9f | (a)<<16 | (r)<<12)
%%/* `The order of operands is from left to right in dataflow order' - asm man */
%%#define	STREX(v,a,r)	WORD	$(0xe<<28|0x01800f90 | (a)<<16 | (r)<<12 | (v)<<0)
%
%<<[[itab]] elements>>=
%"LDREX",		LMOV, ALDREX,
%"LDREXD",		LMOV, ALDREXD,
%"STREX",		LSWP, ASTREX,
%"STREXD",		LSWP, ASTREXD,
%@

% from arm.s
%#define ISB	\
%	MOVW	$0, R0; \
%	MCR	CpSC, 0, R0, C(CpCACHE), C(CpCACHEinvi), CpCACHEwait
%
%#define DSB \
%	MOVW	$0, R0; \
%	MCR	CpSC, 0, R0, C(CpCACHE), C(CpCACHEwb), CpCACHEwait
%
%#define	BARRIERS	ISB; DSB
%
%#define MCRR(coproc, op, rd, rn, crm) \
%	WORD $(0xec400000|(rn)<<16|(rd)<<12|(coproc)<<8|(op)<<4|(crm))
%
%#define OKAY \
%	MOVW	$0x7E200028,R2; \
%	MOVW	$0x10000,R3; \
%	MOVW	R3,(R2)

\subsection{Coprocessors}

%real-world: also INS, OUT, special IO instruction in x86

% Already seen 2 system instructions: SWI and RFE. Here are a few more.
\t very important when program kernel, see bcm/

% no Axxx opcode, binary generation directly in action via D_CONST
<<[[itab]] elements>>=
"MCR",		LSYSTEM, 0,
"MRC",		LSYSTEM, 1,
@

%MCR is move to coprocessor from ARM register.
%MCR and nor MRC because ARM original syntax for move is
% MOV dest, src, so  make sense to have MCR since C(oprocessor) is
% the target.

<<inst rule(arm)>>=
/*
 * MCR MRC
 */
| LSYSTEM cond con ',' expr ',' regi ',' creg ',' creg oexpr
 {
  Gen g;

  g = nullgen;
  g.type = D_CONST;
  g.offset =
   (0xe << 24) |    /* opcode */
   ($1 << 20) |     /* MCR/MRC */
   ($2 << 28) |     /* scond */
   (($3 & 15) << 8) |   /* coprocessor number */
   (($5 & 7) << 21) |   /* coprocessor operation */
   (($7 & 15) << 12) |  /* arm register */
   (($9 & 15) << 16) |  /* Crn */
   (($11 & 15) << 0) |  /* Crm */
   (($12 & 7) << 5) |   /* coprocessor information */
   (1<<4);          /* must be set */ // opcode component
  outcode(AWORD, Always, &nullgen, R_NONE, &g);
 }
@
% >> >> >> >> >> >> >> >> >> >>
% use of WORD!

<<type declarations(arm)>>=
%type   <lval>  creg
@

<<creg rule>>=
creg:
  LCREG
| LC '(' expr ')'
 {
  if($3 < 0 || $3 >= NREG)
      print("register value out of range\n");
  $$ = $3;
 }
@
%$

<<[[itab]] elements>>=
"C",		LC,	0,

"C0",		LCREG,	0,
"C1",		LCREG,	1,
"C2",		LCREG,	2,
"C3",		LCREG,	3,
"C4",		LCREG,	4,
"C5",		LCREG,	5,
"C6",		LCREG,	6,
"C7",		LCREG,	7,
"C8",		LCREG,	8,
"C9",		LCREG,	9,
"C10",		LCREG,	10,
"C11",		LCREG,	11,
"C12",		LCREG,	12,
"C13",		LCREG,	13,
"C14",		LCREG,	14,
"C15",		LCREG,	15,
@


<<type declarations(arm)>>=
%type   <lval>  oexpr 
@

% other optional stuff
<<oexpr rule>>=
/* for MCR */ 
oexpr:
  /* empty */ { $$ = 0; }
| ',' expr    { $$ = $2; }
@
%$

% See also MCRR done via a macro right now.


\section{Other pseudo opcodes}

\subsection{Compiler-only opcodes}
\l or virtual?

% because actually opcodes was written before 5a :) list of
% opcodes were dictated by 5c needs.
 

% some of those are not really opcodes, they are entities 
% just at the asm AST level produced internally by 5c.
% they have no reading syntax.
% ANOP is here. No reading syntax.

% related to NOP, SHL, MOV, pseudo asm
% that get translated in store/load on some archi.


% only used by 5c
<<[[Opcode]] cases, pseudo opcodes>>=
ACASE,
ABCASE,
@
% BCASE = branch case

% actually they used to have a read syntax, but I didn't see any code
% using them so I commented the code.
%<<[[itab]] elements>>=
%"CASE",		LTYPED, ACASE,
%"BCASE",	LBCOND,	ABCASE,
%@
%<<inst rule(arm)>>=
%/*
% * CASE
% */
%| LTYPED cond reg comma { outcode($1, $2, &$3, R_NONE, &nullgen); }
%@
%$


<<[[Opcode]] cases, mul/div/mod opcodes>>=
AMULU,
ADIVU, // VIRTUAL, transformed to call to _divu
AMODU, // VIRTUAL, transformed to call to _modu
@
% has no reading syntax, generated just in 5c
% but AMULU seems equivalent to AMUL when look at code of 5l so??

% very important!!
<<[[Opcode]] cases, pseudo opcodes>>=
ASIGNAME,
@
% for signatures checking, generated just in 5c
% really an extended ANAME with signature information (md5sum of the
% type, which for a structure is a md5sum of all its components, so
% pretty safe)


% not pseudo opcodes but related to compile-only opcodes. Here are other 
% constants defined in 5.out.h that are used only
% in compiler context.
% for 5c! conventions! (not used at all by 5a, but in 5.out.h for other tools)
<<[[Register]] compiler conventions cases>>=
// reserved by compiler, calling conventions
REGRET =    0,
REGARG =    0,
@
% mv earlier? but cant put too early

<<[[Register]] compiler conventions cases>>=
/* compiler allocates R1 up as temps */
/* compiler allocates register variables R2 up */
REGMIN =    2,
REGMAX =    8,
/* compiler allocates external registers R10 down */
REGEXT =    10, // R9/R10 possible 'extern register xxx;'
@


<<[[Register]] linker conventions cases>>=
// reserved by linker, long address/offset loading
REGTMP =    11,
@
% hmm regxxx is not really an enum as REGREG = REGARG, but still useful.

% REGTMP used for pool in Linker, so very useful!

%old:    /* used by the loader for thumb code */
%    REGTMPT =		7,
% no REGFP??

\subsection{Linker-only opcodes}

<<[[Opcode]] cases, pseudo opcodes>>=
AGOK,
@
% GOK =? God only Knows? speciak mark?
% actually used in both compiler and linker
% but I think it's used only for zprg, and in ldobj it's an error
%less: maybe we could delete it, and just use AXXX or ALAST or ANOP instead.
%old: there was a D_GOK, but it was unused in 5a/5c/5l
%ocaml: meh, not needed I think


% related to linker again, in addition to N_FILE there is:
<<[[Sym_kind]] cases>>=
N_LINE, // used by linker only
@
%old: was D_FILE1, but more consistent N_xxx and LINE more accurate
% for #line, to make difference with regular file
% or #include which is using a D_FILE
%ocaml: because ugly abuse of executable symbol table, use Marshal instead



%dead: #define	ALLTHUMBS	(1<<2)
%dead:
% <<[[Opcode]] cases, pseudo opcodes>>=
% ADYNT,
% AINIT,
% @
% asm.pdf says it's related to Alef

\section{[[TEXT]] attributes}
\label{sec:attributes}
\l also for GLOBL?

\t Instr.reg

%Again not an opcode, but related. Where this bit is stored?
%I think in the middle reg of an instruction for opcodes like ATEXT.
%It is used by 5l e.g., to allow override existing symbol.
%I think it's for TEXT and DATA instructions and its reg field
% (that should be unused for TEXT and DATA)
<<constant DUPOK(arm)>>=
#define DUPOK       (1<<1)
@

%less: transform in an enum with DUPOK
% note that it's not used by 5a, used by 5c/5l when have a special #pragma
<<constant NOPROF(arm)>>=
#define NOPROF      (1<<0)
@

%old: other attributes?
%//#define	ALLTHUMBS	(1<<2)

\section{Other preprocessing directives}
\label{sec:preprocessing-rest}

% Most of this is explained in \book{Compiler}, this is why
% I put it in adv topics in this book.

\subsection{[[#define]]}
% and [[-D]]

\subsubsection{[[-D]]}

<<[[main()]] command line processing>>=
case 'D':
    p = ARGF();
    if(p)
        Dlist[nDlist++] = p;
    break;
@

% -D
<<global Dlist>>=
char*	Dlist[30];
@
<<global nDlist>>=
int	nDlist;
@

<<[[assemble()]] locals>>=
int i;
@
<<[[assemble()]] init Dlist after pinit>>=
for(i=0; i<nDlist; i++)
        dodefine(Dlist[i]);
@



<<[[Sym]] macro fields>>=
//option<string>  for '#define FOO xxx' expansion
char*   macro;
@
\label{sec:macro-sym-field}

<<[[pinit()]] initializations>>=
for(i=0; i<NHASH; i++)
    for(s = hash[i]; s != S; s = s->link)
        s->macro = nil;
@


<<function dodefine>>=
void
dodefine(char *cp)
{
    Sym *s;
    char *p;
    long l;
    char *x;

    strcpy(symb, cp);
    p = strchr(symb, '=');
    if(p) {
        *p++ = '\0';
        s = lookup();
        l = strlen(p) + 2;	/* +1 null, +1 nargs */

        while(l & 3)
            l++;
        x = malloc(l);

        *x = '\0';
        strcpy(x+1, p);
        s->macro = x;
    } else {
        s = lookup();
        s->macro = "\0001";	/* \000 is nargs */
    }
    <<[[dodefine()]] debug>>
}
@
\l argh abuse macro to also store arguments
%jarod: on peut redfinir une macro mais pas dans macdef, (aprs avec gcc c pareil mais avec un warning)

\subsubsection{[[#define]]}

<<constant NARG>>=
#define	NARG	25
@

% wow, this is complicated
% See Compiler.nw, better LP split
<<function macdef>>=
void
macdef(void)
{
    Sym *s, *a;
    char *args[NARG], *np, *base;
    int n, i, c, len;
    bool dots;
    int ischr;

    s = getsym();
    if(s == S)
        goto bad;
    if(s->macro)
        yyerror("macro redefined: %s", s->name);
    c = getc();
    n = -1;
    dots = 0;
    if(c == '(') {
        n++;
        c = getnsc();
        if(c != ')') {
            unget(c);
            for(;;) {
                a = getsymdots(&dots);
                if(a == S)
                    goto bad;
                if(n >= NARG) {
                    yyerror("too many arguments in #define: %s", s->name);
                    goto bad;
                }
                args[n++] = a->name;
                c = getnsc();
                if(c == ')')
                    break;
                if(c != ',' || dots)
                    goto bad;
            }
        }
        c = getc();
    }
    if(isspace(c))
        if(c != '\n')
            c = getnsc();

    base = hunk;

    len = 1;
    ischr = 0;
    for(;;) {
        if(isalpha(c) || c == '_') {
            np = symb; // jarod: overflow?
            *np++ = c;
            c = getc();
            while(isalnum(c) || c == '_') {
                *np++ = c;
                c = getc();
            }
            *np = '\0';
            for(i=0; i<n; i++)
                if(strcmp(symb, args[i]) == 0)
                    break;
            if(i >= n) {
                i = strlen(symb);
                base = allocn(base, len, i);
                memcpy(base+len, symb, i);
                len += i;
                continue;
            }
            base = allocn(base, len, 2);
            base[len++] = '#';
            base[len++] = 'a' + i;
            continue;
        }
        if(ischr){
            if(c == '\\'){ 
                base = allocn(base, len, 1);
                base[len++] = c;
                c = getc();
            }else if(c == ischr)
                ischr = 0;
        }else{
            if(c == '"' || c == '\''){
                base = allocn(base, len, 1);
                base[len++] = c;
                ischr = c;
                c = getc();
                continue;
            }
            if(c == '/') {
                c = getc();
                if(c == '/'){
                    c = getc();
                    for(;;) {
                        if(c == '\n')
                            break;
                        c = getc();
                    }
                    continue;
                }
                if(c == '*'){
                    c = getc();
                    for(;;) {
                        if(c == '*') {
                            c = getc();
                            if(c != '/')
                                continue;
                            c = getc();
                            break;
                        }
                        if(c == '\n') {
                            yyerror("comment and newline in define: %s", s->name);
                            break;
                        }
                        c = getc();
                    }
                    continue;
                }
                base = allocn(base, len, 1);
                base[len++] = '/';
                continue;
            }
        }
        if(c == '\\') {
            c = getc();
            if(c == '\n') {
                c = getc();
                continue;
            }
            else if(c == '\r') {
                c = getc();
                if(c == '\n') {
                    c = getc();
                    continue;
                }
            }
            base = allocn(base, len, 1);
            base[len++] = '\\';
            continue;
        }
        if(c == '\n')
            break;
        if(c == '#')
        if(n > 0) {
            base = allocn(base, len, 1);
            base[len++] = c;
        }
        base = allocn(base, len, 1);
        base[len++] = c;
        c = ((--fi.c < 0)? filbuf(): (*fi.p++ & 0xff)); //jarod: GETC
        if(c == '\n')
            lineno++;
        if(c == -1) { // jarod: EOF
            yyerror("eof in a macro: %s", s->name);
            break;
        }
    }
    do {
        base = allocn(base, len, 1);
        base[len++] = 0;
    } while(len & 3);

    *base = n+1;
    if(dots)
        *base |= VARMAC;
    s->macro = base;
    <<[[macdef()]] debug>>
    return;

bad:
    if(s == S)
        yyerror("syntax in #define");
    else
        yyerror("syntax in #define: %s", s->name);
    macend();
}
@
% wow, complicated

%jarod: difficile de suivre le matching entre accolades ouvrantes/fermantes

<<constant VARMAC>>=
#define VARMAC 0x80
@


<<function getsymdots>>=
Sym*
getsymdots(bool *dots)
{
    int c;
    Sym *s;

    s = getsym();
    if(s != S)
        return s;

    c = getnsc();
    if(c != '.'){
        unget(c);
        return S;
    }
    if(getc() != '.' || getc() != '.')
        yyerror("bad dots in macro");
    *dots = true;
    return slookup("__VA_ARGS__");
}
@

\subsubsection{Macro expansion}

\label{sec:macro-expansion}
<<[[yylex()]] if macro symbol>>=
if(s->macro) {
    newio();
    cp = ionext->b;
    macexpand(s, cp);
    pushio();

    ionext->link = iostack;
    iostack = ionext;

    fi.p = cp;
    fi.c = strlen(cp);
    if(peekc != IGN) {
        cp[fi.c++] = peekc;
        cp[fi.c] = 0;
        peekc = IGN;
    }
    goto l0;
}
@
% abuse newio()? it's not really a new file here

% wow, complicated too
<<function macexpand>>=
void
macexpand(Sym *s, char *b)
{
    char buf[2000];
    int n, l, c, nargs;
    char *arg[NARG], *cp, *ob, *ecp, dots;

    ob = b;
    if(*s->macro == 0) {
        strcpy(b, s->macro+1);
        <<[[macexpand()]] debug part1>>
        return;
    }
    
    nargs = (char)(*s->macro & ~VARMAC) - 1;
    dots = *s->macro & VARMAC;

    c = getnsc();
    if(c != '(')
        goto bad;
    n = 0;
    c = getc();
    if(c != ')') {
        unget(c);
        l = 0;
        cp = buf;
        ecp = cp + sizeof(buf)-4;
        arg[n++] = cp;
        for(;;) {
            if(cp >= ecp)
                goto toobig;
            c = getc();
            if(c == '"')
                for(;;) {
                    if(cp >= ecp)
                        goto toobig;
                    *cp++ = c;
                    c = getc();
                    if(c == '\\') {
                        *cp++ = c;
                        c = getc();
                        continue;
                    }
                    if(c == '\n') //jarod: how can have this in a macro def?
                        goto bad;
                    if(c == '"')
                        break;
                }
            if(c == '\'')
                for(;;) {
                    if(cp >= ecp)
                        goto toobig;
                    *cp++ = c;
                    c = getc();
                    if(c == '\\') {
                        *cp++ = c;
                        c = getc();
                        continue;
                    }
                    if(c == '\n')
                        goto bad;
                    if(c == '\'')
                        break;
                }
            if(c == '/') {
                c = getc();
                switch(c) {
                case '*':
                    for(;;) {
                        c = getc();
                        if(c == '*') {
                            c = getc();
                            if(c == '/')
                                break;
                        }
                    }
                    *cp++ = ' ';
                    continue;
                case '/':
                    while((c = getc()) != '\n')
                        ;
                    break;
                default:
                    unget(c);
                    c = '/';
                }
            }
            if(l == 0) {
                if(c == ',') {
                    if(n == nargs && dots) {
                        *cp++ = ',';
                        continue;
                    }
                    *cp++ = 0;
                    arg[n++] = cp;
                    if(n > nargs)
                        break;
                    continue;
                }
                if(c == ')')
                    break;
            }
            if(c == '\n')
                c = ' ';
            *cp++ = c;
            if(c == '(')
                l++;
            if(c == ')')
                l--;
        }
        *cp = 0;
    }
    if(n != nargs) {
        yyerror("argument mismatch expanding: %s", s->name);
        *b = 0;
        return;
    }
    cp = s->macro+1;
    for(;;) {
        c = *cp++;
        if(c == '\n')
            c = ' ';
        if(c != '#') {
            *b++ = c;
            if(c == 0)
                break;
            continue;
        }
        c = *cp++;
        if(c == 0)
            goto bad;
        if(c == '#') {
            *b++ = c;
            continue;
        }
        c -= 'a';
        if(c < 0 || c >= n)
            continue;
        strcpy(b, arg[c]);
        b += strlen(arg[c]);
    }
    *b = 0;
    <<[[macexpand()]] debug part2>>
    return;

bad:
    yyerror("syntax in macro expansion: %s", s->name);
    *b = 0;
    return;

toobig:
    yyerror("too much text in macro expansion: %s", s->name);
    *b = 0;
}
@
% wow complicated again

\subsection{[[#undef]]}

<<function macund>>=
void
macund(void)
{
    Sym *s;

    s = getsym();
    macend();
    if(s == S) {
        yyerror("syntax in #undef");
        return;
    }
    s->macro = nil;
}
@

\subsection{[[#ifdef]]}

% 0 = ifdef, 1 = ifndef, 2 = else, see mactab and domacro
<<function macif>>=
void
macif(int f)
{
    int c, l;
    bool bol;
    Sym *s;

    if(f == 2)
        goto skip;
    s = getsym();
    if(s == S)
        goto bad;
    if(getcom() != '\n')
        goto bad;
    if((s->macro != nil) ^ f)
        return;

skip:
    bol = true;
    l = 0;
    for(;;) {
        c = getc();
        if(c != '#') {
            if(!isspace(c))
                bol = false;
            if(c == '\n')
                bol = true;
            continue;
        }
        if(!bol)
            continue;
        s = getsym();
        if(s == S)
            continue;
        if(strcmp(s->name, "endif") == 0) {
            if(l) {
                l--;
                continue;
            }
            macend();
            return;
        }
        if(strcmp(s->name, "ifdef") == 0 || strcmp(s->name, "ifndef") == 0) {
            l++;
            continue;
        }
        if(l == 0 && f != 2 && strcmp(s->name, "else") == 0) {
            macend();
            return;
        }
    }

bad:
    yyerror("syntax in #if(n)def");
    macend();
}
@


<<[[domacro()]] set s to endif symbol if no symbol>>=
if(s == S)
    s = slookup("endif");
@
% note: didn't know that a single # is actually equivalent to an endif


\subsection{[[#pragma]]}

<<function macprag>>=
void
macprag(void)
{
    Sym *s;
    <<[[macprag()]] locals>>

    s = getsym();

    <<[[macprag()]] if pragma lib>>
    else {
        while(getnsc() != '\n')
            ;
        return;
    }
}
@
%old: most pragma was mostly discarded, except #pragma lib, so
% I removed them (could have also simplified by calling prag_do_nothing()).
% It is because the code was shared with cc before I think and the compilers
% had different pragxxx functions with an actual body.

%dead: (when defactorize then this code is dead indeed)
%    if(s && strcmp(s->name, "pack") == 0) {
%        pragpack();
%        return;
%    }
%    if(s && strcmp(s->name, "fpround") == 0) {
%        pragfpround();
%        return;
%    }
%    if(s && strcmp(s->name, "profile") == 0) {
%        pragprofile();
%        return;
%    }
%    if(s && strcmp(s->name, "varargck") == 0) {
%        pragvararg();
%        return;
%    }
%    if(s && strcmp(s->name, "incomplete") == 0) {
%        pragincomplete();
%        return;
%    }
%old:
%<<function pragpack>>=
%void
%pragpack(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@
%
%<<function pragvararg>>=
%void
%pragvararg(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@
%
%<<function pragfpround>>=
%void
%pragfpround(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@
%
%<<function pragprofile>>=
%void
%pragprofile(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@
%
%<<function pragincomplete>>=
%void
%pragincomplete(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@




\section{[[#pragma lib]] and automagic linking}
\n related to linker-only but better separate


% this is very very nice! remove so much headache,
% no need ocamlfind, no need pkg-config, so simple ...

% the object can contain information about which
% lib you want to link with!

% effect of #pragma lib in .s ??
% less useful in assembly than in .c, but because anyway it's
% an object file property, it's also in the assembler (that generate
% object files).

<<[[macprag()]] locals>>=
Hist *h;
char *hp;
int c0, c;
@

<<[[macprag()]] if pragma lib>>=
if(s && strcmp(s->name, "lib") == 0) {
    c0 = getnsc();
    if(c0 != '"') {
        c = c0;
        if(c0 != '<')
            goto bad;
        c0 = '>';
    }
    for(hp = symb;;) {
        c = getc();
        if(c == c0)
            break;
        if(c == '\n')
            goto bad;
        *hp++ = c;
    }
    *hp = '\0';
    c = getcom();
    if(c != '\n')
        goto bad;

    /*
     * put pragma-line in as a funny history 
     */
    c = strlen(symb) + 1;
    while(c & 3)
        c++;

    hp = malloc(c);
    memcpy(hp, symb, c);

    h = alloc(sizeof(Hist));
    h->filename = hp;
    h->global_line = lineno;
    h->local_line = -1; // ugly, special mark for #pragma lib in Hist

    h->link = H;
    if(ehist == H) {
        hist = h;
        ehist = h;
        return;
    }
    ehist->link = h;
    ehist = h;

    return;

bad:
    unget(c);
    yyerror("syntax in #pragma lib");
    macend();

}
@
%less ugly would be to have object attribute (in addition to
% text/data attributes)


\section{Processing multiple files}

% why need that? people cant write mkfiles?

<<[[main()]] locals>>=
int nout, nproc, status;
int i, c;
@

<<[[main()]] multiple files handling>>=
if(argc > 1) {
    nproc = 1;
    if(p = getenv("NPROC"))
        nproc = atol(p);	/* */
    c = 0;
    nout = 0;
    for(;;) {
        while(nout < nproc && argc > 0) {
            i = fork();
            if(i < 0) {
                i = mywait(&status);
                if(i < 0)
                    errorexit();
                if(status)
                    c++;
                nout--;
                continue;
            }
            if(i == 0) {
                print("%s:\n", *argv);
                if(assemble(*argv))
                    errorexit();
                exits(nil);
            }
            nout++;
            argc--;
            argv++;
        }
        i = mywait(&status);
        if(i < 0) {
            if(c)
                errorexit();
            exits(nil);
        }
        if(status)
            c++;
        nout--;
    }
}
@
%ocaml: no need that, do that kinds of things via xargs -P32 instead

%\section{Thumb code}
% arg processing: (but then no more generic across 5a/ and 8a/)
%
%    case 't':
%        thechar = 't';
%        thestring = "thumb";
%        break;








\chapter{Conclusion}
\label{chap:conclusion}

You now know how the \plan ARM assembler [[5a]] works,
to the smallest details, and more generally how many 
assemblers work.

\l could take original questions in intro one by one, itemized
\l and explain or point to places in the book that explains

%dup: from intro/5a BUT too many dup so commented.
%The ARM machine code generation is not done by [[5a]] though,
%but by the linker [[5l]] which is a bit unconventional.
%So, we recommend to follow with the \book{Linker} to
%understand this part. In any case, 
The linker and assembler
being strongly connected in any systems (for instance [[ld]] and [[gas]]
are part of the same [[binutils]] package in the GNU system),
the \book{Linker} is the next logical step after this book.
%
I also suggest you to read the \book{Emulator}, which fully
describes the semantics of the machine instructions you have
seen in this book.
%
The \book{Debugger} contains code to {\em disassemble}
machine code that relates to this book.
%
Finally, reading the \book{Compiler} will now be easier
because you can now understand the assembly code 
generated by the C compiler [[5c]].
\n in fact sim and gdb are part of binutils/ too

%missing features: ORG, but ld can do -Txx

%\section{Limitations/Bugs}
% - annoying that somethings are detected only at link time, such as
%   MOVW (R1), (R2)

%###############################################################################

\appendix

\chapter{Debugging}
\label{chap:debugging-appendix}

% debugging 5a itself, not debugging support as in chapter X.

% not very powerful debugging options for 5a, mostly stuff
% to debug cpp related issues.

% but 5l has actually more stuff, with dumpers for Gen, opcode, etc.
% e.g., 5l -v -W is pretty useful as it helps debug the object loading,
% and help see the object file generated by 5a.
% (but need good enam.c! up to date and in sync with 5.out.h)

% ex: 'm', 'f' (256 so can have for each character a boolean value)
<<global debug>>=
bool	debug[256];
@
%ocaml: via Arg.options instead

<<[[main()]] remaining initializations>>=
memset(debug, false, sizeof(debug));
@

<<[[main()]] command line processing>>=
default:
    c = ARGC();
    if(c >= 0 || c < sizeof(debug))
        debug[c] = true;
    break;
@

\section{Line information debugging, [[5a -f]]}
\label{sec:debug-line}
% -f ?? why?

<<[[linehist()]] debug>>=
if(debug['f'])
    if(f) {
        if(local_line)
            print("%4ld: %s (#line %d)\n", lineno, f, local_line);
        else
            print("%4ld: %s\n", lineno, f);
    } else
        print("%4ld: <pop>\n", lineno);
@

% see section X for example of output


\section{Macro debugging, [[5a -m]]}
% m for macro

<<[[dodefine()]] debug>>=
if(debug['m'])
    print("#define (-D) %s %s\n", s->name, s->macro+1);
@

<<[[macdef()]] debug>>=
if(debug['m'])
    print("#define %s %s\n", s->name, s->macro+1);
@

<<[[macexpand()]] debug part1>>=
if(debug['m'])
    print("#expand %s %s\n", s->name, ob);
@

<<[[macexpand()]] debug part2>>=
if(debug['m'])
    print("#expand %s %s\n", s->name, ob);
@

\chapter{Error Management}
\label{chap:error}

<<function errorexit>>=
/// main | assemble | yyerror | ... -> <>
void
errorexit(void)
{

    if(outfile)
        remove(outfile);
    exits("error");
}
@
%ocaml: because do more things in memory, need create file only
% when marshall out, so no need special recovery code

<<global nerrors>>=
int	nerrors = 0;
@
% used to be initialized in cinit()

<<function yyerror>>=
/// assemble | yylex | yyparse | ... -> <>
void
yyerror(char *a, ...)
{
    char buf[200];
    va_list arg;

    <<[[yyerror()]] when called from yyparse>>

    prfile(lineno);

    va_start(arg, a);
    vseprint(buf, buf+sizeof(buf), a, arg);
    va_end(arg);

    print("%s\n", buf);

    nerrors++;
    if(nerrors > 10) {
        print("too many errors\n");
        errorexit();
    }
}
@
\l a string -> fmt string ?

\t percent r is error return code of last syscall I think, so common to have
\t  it in fmt

% could put prfile here, but can be better before to help
% illustrate how to use Hist

<<[[yyerror()]] when called from yyparse>>=
/*
 * hack to intercept message from yaccpar
 */
if(strcmp(a, "syntax error") == 0) {
    yyerror("syntax error, last name: %s", symb);
    return;
}
@
\t actually gives pretty good error message with trace of non-terminal
\t and terminal, see comment in .tex
% if write SWI 0 and does not support such instruction in 5a then get
% hello2.s:16 syntax error, last name: SWI
% line: inst.;
% saw $
% nice :)

\chapter{Utilities}
\label{chap:libc}

\section{Buffer management}
\label{sec:libbio}

% libbio

\section{Memory management}
\label{sec:memory}

% same in Linker, not sure why they just don't use malloc?
% to avoid dependencies to libc? for bootstrapping reasons?
% to optimize? malloc is slower?

<<global hunk>>=
char*	hunk;
@

<<global nhunk>>=
long	nhunk = 0;
@
% used to be set in cinit()

<<global thunk>>=
long	thunk;
@

<<constant NHUNK>>=
#define NHUNK       10000
@
% means alloc(100001) will generate Out_of_memory. Meh.

<<function gethunk>>=
void
gethunk(void)
{
    char *h;
    long nh;

    nh = NHUNK;
    if(thunk >= 10L*NHUNK)
        nh = 10L*NHUNK;

    h = (char*)sbrk(nh);
    if(h == (char*)-1) {
        yyerror("out of memory");
        errorexit();
    }
    hunk = h;
    nhunk = nh;
    thunk += nh;
}
@



<<constant MAXALIGN>>=
#define MAXALIGN 7
@

<<function alloc>>=
/*
 * real allocs
 */
void*
alloc(long n)
{
    void *p;

    while((uintptr)hunk & MAXALIGN) {
        hunk++;
        nhunk--;
    }

    while(nhunk < n)
        gethunk();
    p = hunk;
    nhunk -= n;
    hunk += n;

    return p;
}
@

<<function allocn>>=
void*
allocn(void *p, long on, long n)
{
    void *q;

    q = (uchar*)p + on;
    if(q != hunk || nhunk < n) {

        while(nhunk < on+n)
            gethunk();
        memmove(hunk, p, on);
        p = hunk;
        hunk += on;
        nhunk -= on;

    }
    hunk += n;
    nhunk -= n;
    return p;
}
@
% there is no free!!?
% opti? useless I think.


\chapter{Examples of Assembly Programs TODO}
\label{chap:examples}

%other? mbr.s and x16.h? but x86, not ARM

% MenuetOS and KolibriOS are full OS and GUI written in assembly ... hmm

\section{[[hello.s]] and [[pwrite.s]]}
%lib_core/libc/arm/

\l seen [[helloworld.s]] before
\l could put simplified hello world here? 
\l use libc! use FP, SP, use more standard stuff.
\l intro was nice to go bare, to simplify, but here go more normal.

\l also show 5l -W? 
\l and 5l -a? and 5i machine trace? see diff for TEXT and RET
\l show 5c -S too? actually a bit different for hello

\l also pwrite.s ! so see conv from C to kernel calling convention

\section{[[memset.s]]}

% interesting program. Can show C code and then optimized assembly code.

\section{[[div.s]]}
\label{sec:_divmod}
%turing: see that div/mod are not fundamental

The [[_div]] function in [[lib_core/libc/arm/div.s]]
implements in software the integer division. Indeed,
the ARM has no [[DIV]] instruction.

\l spirit is to see how write algorithm like euclid in Assembly!

\t how called? generated code in 5l for DIV?

<<function _div>>=
TEXT	_div(SB), 1, $16
	BL	save<>(SB)
	CMP	$0, R(Q)
	BGE	d1
	RSB	$0, R(Q), R(Q)
	CMP	$0, R(D)
	BGE	d2
	RSB	$0, R(D), R(D)
d0:
	BL	div<>(SB)		/* none/both neg */
	MOVW	R(Q), R(TMP)
	B	out
d1:
	CMP	$0, R(D)
	BGE	d0
	RSB	$0, R(D), R(D)
    // Fallthrough
d2:
	BL	div<>(SB)		/* one neg */
	RSB	$0, R(Q), R(TMP)
	B	out

out:
	BL	rest<>(SB)
	B	out
@


\l using more basic instruction, cant use DIV or MOD. use? bit shift??


The [[_mod]] function in [[lib_core/libc/arm/div.s]]
implements in software the integer modulo since
the ARM has no [[MOD]] instruction.

<<function _mod>>=
TEXT	_mod(SB), 1, $16
	BL	save<>(SB)
	CMP	$0, R(D)
	RSB.LT	$0, R(D), R(D)
	CMP	$0, R(Q)
	BGE	m1
	RSB	$0, R(Q), R(Q)
	BL	div<>(SB)		/* neg numerator */
	RSB	$0, R(N), R(TMP)
	B	out
m1:
	BL	div<>(SB)		/* pos numerator */
	MOVW	R(N), R(TMP)
	B	out
@


\section{[[main9.s]]}
\n lib_core/libc/arm/main9.s (and main9p.s) would be good 
\n (but the master version should be sync with \book{Core Libraries})

% see _main vs main and BL main+0(SB)!

\section{[[tas.s]]}

\section{[[getcallerpc.s]]}
%lib_core/libc/arm/

\t getcallerpc? help illustrates calling convention? or too subtle?
% but for sure this needs to be written in assembly!

\l getcallerpc code? with special minus 4
%TEXT getcallerpc(SB), 1, $-4
%	MOVW	0(R13), R0 /* R13 = SP */
%	RET
% 1 attribute??? need diagram again

% need -4? anyway it's a leaf, so $0 would work too.


%%%\chapter{[[5a]] in OCaml}
%%%\label{chap:5a-ocaml}
\n LFS thesis spirit :) Chazarin spirit!

% What for?
% - ocaml promotion :) 
% - see even more the essence; it helps solidify even more your knowledge.
% - offer another "view". Can see full grammar for instance below,
%   the full AST, instead of piece by piece in the main text.
% - helped me to see subtle things or bugs in the original, e.g., management of
%   lineno and yacc/lex interaction which may mean lineno was wrong.
% In the end you really fully understand something only when you implement 
% it yourself! (Chazarin)

% design decisions: 
% - no optimisations (space or speed) which guides many of the
%   other decisions below.
% - external cpp, and really external,
%   not even -D, -I. Can do that in Makefile with %.s : %.S   cpp ...
% - no symbolic constant feature, redundant with cpp
% - use Lex instead of handcoded lexer 
%   (maybe related to previous point)
% - object file is marshalled form of ocaml AST. Far simpler!
%   (but less open to other languages; could use JSON but no ADT in JSON)
% This decrements size of code, but also size of needed explanations!
% mk loc = 780 (without advanced topics and extensions, e.g., float)

% below I mimic the order of chapters (core DS then main then lexer ...)

%%%\section{[[ast_asm5.ml]]}
% so much more precise! (but more inconvenient for visiting)

%%%\section{[[globals.ml]]}
% just line!
% could enumerate all globals exported in aa.h and a.h (just gen)
%  and see how cleaner ocaml code is

%%%\section{[[main.ml]]}

%%%\section{[[parse_asm5.ml]]}
% and mli

%%%\section{[[lexer_asm5.mll]]}

%%%\section{[[parser_asm5.mly]]}
% small notes on List.rev opti because quadratic @
% or actually dont care, we strive for simplicity here

%%%\section{[[resolve_labels5.ml]]}
% and mli
% so little :)

%%%\section{[[object_code5.ml]]}
% and mli
% really really little :)

%%%\section{[[common.ml]]}
% I'm still pad


\chapter{Extra Code}

\ifallcode
#include "Assembler_extra.nw"
#include "Assembler_x86.nw"
\fi

%\chapter{Changelog}
% code via make loc = 4100 LOC
% orig Assembler.nw = 6000, just lpized and few comments, ?? pages pdf
% now: =~ 11000 LOC so added 5000 LOE (Lines of explanations)
% 5a in ocaml: 930 LOC (but still miss some advanced-topics features)

\chapter*{Glossary}
\addcontentsline{toc}{chapter}{Glossary}
\label{sec:glossary}
\t or Acronyms? also provide a glossary?

\begin{verbatim}
LOC = Lines Of Code
ISA = Instruction Set Architecture
AST = Abstract Syntax Tree
PC = Program Counter (register)
SP = Stack Pointer (register)
FP = Frame Pointer (register)
SB = Static Base (register)
BL = Branch and Link
RISC = Reduced Instruction Set Computer
CISC = Complex Instruction Set Computer
ARM  = Acorn Risc Machines
CWD = Current Working Directory
EOF = End Of File
IGN = Ignore
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{chapter}{Index}

%\chapter{References} 
\addcontentsline{toc}{chapter}{References}

\bibliography{../docs/latex/Principia}
\bibliographystyle{alpha}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
