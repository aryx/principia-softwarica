\documentclass[twocolumn]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse % see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things:
%  - better organisation of the code, my TOC is better than the few existing
%    files (that didn't have very good names)
%  - removed deadcode (Ref, imm2, con2, NMACRO, CLAST, isreg, ...)
%  - renamed some enums (as => opcode, _ => operand_kind)
%  - reordered opcodes and operand kinds, and cleaned them:
%     * removed opcodes (ADWORD, ABX, ...)
%     * removed operand kinds (D_GOK, D_ADDR, D_OCONST, ...)
%  - introduced sym_kind, splitted from operand_kind, for ANAME
%  - factorize more code between arm and x86 (abusing LP chunks)
%  - removed a few grammar rules, weird operand forms that were not used anyway
%    as well as the optional comma here and there
%  - TODO rename types, clearer, Gen? as Adr? or Operand? (and Gen2? as Prog?)

%thx to codemap/codegraph/scheck:
% - factorized code in aa/
% - TODO mv errorexit, alloc, in utils.c instead of lexbody.c, same for gethunk
% - TODO have a main.c?

%thx to this manual, better understand assembly and assembler:
% - can actually understand the assembly code in Kernel.nw :) param1+0(FP)
% - that an object is really a module, the simplest/lowest module abstraction 
% - DATA vs GLOBL
% - TODO -fpic?

%history LP-ization:
% - skeleton, mostly copy paste of Template.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * TODO ctor/dtor, dumper
%    * SEMI [[xxx]] other fields, [[xxx]] extra fields
% - read Extra section, identify concepts, first TOC
% - distribute parts of the file before
% - SEMI nullify, boolify, typeify,    scheckify
% - aspecify advanced features!
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\iffinal
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\fi
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
%\usepackage{cleveref} %\cref
%\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}
 %\usepackage[margin=0.5in]{geometry}
 %  but eat the bottom when very low
 %\usepackage{fullpage} is deprecated 
 % => do the more manual below:
 \addtolength{\oddsidemargin}{-.850in}
 \addtolength{\evensidemargin}{-.850in}
 \addtolength{\textwidth}{1.70in}
 \addtolength{\topmargin}{-.850in}
 \addtolength{\textheight}{1.70in}
%\usepackage{minitoc}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% used for forward decl, pragmas, func decl, extern decl, stats, #ifdef,
% debugging macros

%\setcounter{tocdepth}{1}

%******************************************************************************
% Title
%******************************************************************************

\begin{document}

\title{
{\Huge 
Principia Softwarica: The Plan9 Assembler [[5a]]
}\\
ARM (32 bits) edition\\
{version 0.1}
}
%alt: 8a x86 (32 bits) edition, see Assembler_x86.nw

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}
}

\maketitle 
\onecolumn
\hrule
\begin{quote}
    Copyright \copyright{} 2014 Yoann Padioleau \\
    Permission is granted to copy, distribute and/or modify this document,
    except all the source code it contains, under the terms of the GNU Free
    Documentation License, Version 1.3.
\end{quote}
\hrule

%CONFIG: \dominitoc

\iffinal
\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\twocolumn
\tableofcontents
\endgroup
\else
\tableofcontents
\fi

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

\section{Motivations}

The goal of this book is to present in full details the source code of
an assembler.
Why? Because I think it makes you a better programmer if
you fully understand how things work under the hood.

% we gonna focus on plan9 assemblers because
% they are simple, short code, and consistent with the rest of my
% endeavour :)
% we choose 5a, simpler than 8a: ARM(v6) RISC simpler than x86 CISC. Moreover
% we have the full executable spec of ARM in 5i/! so it helps to understand
% the semantic of the ASM instructions.
% ARM like in raspberry or many phones. Most popular archi.

%note: better to do manual with ARM for assembler/compiler/linker. Simpler.
% Using x86 also make it more error prone when want to change things
% because we would have also to change kencc (e.g. error prone to change
% the order of asm instructions).

Here are other candidates that were considered but ultimately discarded:
\begin{itemize}
\item gas
\item nasm
\item dev86
\end{itemize}

% a disadvantage of 5a is that it generates just a special kind of object
% code, the actual machine code generation is done by the linker. 
% A bit unusual maybe.x

%hex2c, the assembler in subc-2014, ...


\section{Getting started}

% see Kernel.nw section?

\section{Requirements}

% know at least one assembler, concepts: labels, mov, SP, FP, jmp,
% symbol defs/uses, external symbols.
% know a bit about architecture (helps to understand Machine.nw)

% asm.ps, 5a(1)

\section{About this document}
#include "../docs/latex/About.nw"

\section{Copyright}

Most of this document is actually source code from Plan9, so
those parts are copyright by Lucent Technologies Inc.
The prose is mine and is licensed under the GNU Free Documentation
License.

\section{Acknowledgments}


\chapter{Overview}

\section{Assembler principles}

% goal of assembler is to have a programming language close to
% the machine code, but more convenient than binary. "as close
% as possible but not closer" :)
% essentially a textual form of a binary format.
% mnemonic and symbolic addresses -> object/machine code

% history: (probably)
% at the beginning was writing binary, then mnemonic but still hardcoded
% address, and then finally symbolic addresses.
% First symbol defs/uses in the same file (e.g. labels), but then could also
% split the code in multiple assembly files and symbols can
% reference external files. Introduced then the linker to
% link together all those assembly objects.

% usually 2 passes for assembler itself as can reference labels
% coming later.

% Object code is not the final code, it is then processed by a linker. 
% So the assembler must output code that must be "resolved" later, with 
% some symbol table information in the object for the linker
% to know what to do and where to patch things.
% The .o is really like a module, the really lowest level module abstraction.
% And a module define some symbols, and use external symbols.
% The objects will also be concatenated together so branch/jmp addresses
% need also to be "relocated", and the same for the reference to 
% external symbols.

% less: look at TECS section on assembler?

% put some concrete examples where see two assemblies, with symbols
% defined and used, and how the linker resolve and then relocate those things?

\section{[[5a]] services}

% command line interface? -o outfile,   -D -I (cpp),  -f -m for debug
% env: INCLUDE (for cpp, similar to -I), NPROC (when multi files?)

% 5a has a few more features than just mnemonic and symbolc addresses:
%  - can also have some simple constant expression.
%  - have also "variables" (symbolic name of constants)
%  - can also have macros and includes!
%    (really convenient, can define new instructions thx to macro & 
%     bitshift as in:
%     #define MCRR(coproc, op, rd, rn, crm) \
% 	    WORD $(0xec400000|(rn)<<16|(rd)<<12|(coproc)<<8|(op)<<4|(crm))
%  - 5a also support some virtual opcode, to go around some of the restrictions
%    of certain architecture, so have a very general MOV even though
%    the actual archi supports only simple LOAD/STORE.

% normally generate (relocatable) machine code, but here 5a is actually
% a bit unusual.


\section{[[helloworld.s]]}

%todo: print "hello world" with mov, call, int, etc? with no libc!
% (and a _main (or even just _start?))

% show commands, 5a, ld, ./xxx

% can also maybe show one that use libc, use 5c -S hello.c

% show binary format? hexdump? 
% hmmm actually not binary instruction format! see section below.

% try show code using TEXT, DATA, GLOBL, different addressing modes, etc
% show the advantage of assembly, that is mnemonic and symbolic addresses!

% maybe good to show a few more example of asm, to get a feel for the language
% e.g. the code of strchr, div, etc.


\section{ARM}
% ARMv6, like in Raspberry :)

% opcode format, see 5i/
% but actually it's more the job of 5l and optab to do that.
% 5a just try to mimic closely the ISA (but actually it also
% introducing some virtual/fake opcodes).

\section{Input assembly language}

% specifics of 5a? 
% left to right assignment, AT&T syntax, normal :)
% the different addressing modes for MOV.

%concepts: 
% - labels suffixed with :
% - constants, prefixed with $ (why? to avoid ambiguity with what?)
%   otherwise regular numbers are offset like 32(SP)
% - external symbols = fully unresolved! will be resolved at linking time
%   but needs to keep the name in the symbol table and the place where it
%   was referenced
% - use '(' xxx ')' for memory dereference. so 4(FP) really means
%   *fp + 4 (which in C could be written  fp[4] if fp was a byte pointer.

% special registers for addressing: PC, SB, FP, SP
% for text, data, param, locals
% (hmm has FP special register in 5a?)

% 8 bytes limit for strings (so if longer have to split manually,
% a bit annoying but can use data2s too)


%        LONG    $-(0x1BADB002 + 0x00010003)     /* checksum */
%vs
%        LONG    $_start-KZERO(SB)          /* load_addr */
%why need SB in second case? because it refers to symbol in certain section?
% it's to take the address of _start symbol in SB and adjust
% by removing KZERO to it. tricky. It's really $  _start(SB) - KZERO

% it does not have extern declaration, but any ref is implicitely
% an extern.

\section{Output object format}

% .5 format? a kind of .o, but 5l does actually the job to turn into ARM ISA
% so it's really more a marshalled file of simple data structures that is
% ARM specific only because of the set of opcode and registers really.

%less: could simplify the code at some point and use Ocaml/Rust
% and just marshall the ADT, and do same in linker => shorter code!
%update: hmm but the format is actually not that complicated, so win
% but not that big probably.

% put copy paste of Object format section here?
% Figure!

\section{Code organization}

% arch generic: aa/, arch specific: xa/
% same for header, common.out.h and arm/5.out.h or 386/8.out.h!
%actually lots of assembler related stuff is in libmach/
%and lots in the linker.

%aa/aa.h:
%aa/compat.c: 
%aa/globals.c:
%aa/lexbody.c: many helper functions, not just lexer helper)
% (todo: split lex specific helper vs non lex specific)
%aa/macbody.c: cpp helpers (include, macro, pragmas),
% mac = macro (not macos :)

%5a/a.h:
%5a/a.y: the grammar (and calls to outcode)
%5a/globals.c: just nullgen (because Gen ARM specific so not in aa/)
%5a/lex.c: the lexer and also main()

\section{Software architecture}

% main -> assemble -> (2 passes) -> yyparse -> yylex
%                                -> outcode (increments pc and in pass2 output!)

% text -> grammar -> symbols -> codegen
% does not return an AST (but kinda build one for each instruction), 
% abuse tokens and the grammar to do some computations 
% (the classic old way to do things)

% assembler generates an object file that is ARM specific, but not 
% matching the ARM instruction set! 5l/asm.c is doing the real conversion
% (why? because 5l does some inter-lib optimizations? a la llvm? nice design!?)
% it generates an "object", a kind of .o except it's really not a .o like
% in Linux :) it's a serialized/marshalled data structure (opcode+operands+...)


% relation with other tools? 5c, 5l? easy, do for instance:
% git grep AADDB
%assemblers/8a/lex.c:    "ADDB",		LTYPE3,	AADDB,
%compilers/8c/peep.c:    case AADDB:	/* rhs rar */
%compilers/8c/reg.c:        case AADDB:
%compilers/8c/txt.c:            a = AADDB;
%include/386/8.out.h:    AADDB,
%linkers/8l/optab.c:    { AADDB,	yxorb,	Px, 0x04,0x80,(00),0x00,0x02 },


%###############################################################################

\chapter{Core Data Structures}

% first 3 sections are really about AST: opcode, register, operand_kind/Gen.

% Instructions are made of an opcode and operands, which can be
% registers, immediate values, or memory addresses.
% (actually for ARM there also a COND and some bit modifiers).
% Memory addresses can use symbolic names.

\section{[[Opcode]]}


% include/arm/5.out.h (used to be just 5c/5.out.h)
<<enum opcode(arm)>>=
// coupling: with 5c/enam.c
enum opcode
{
    AXXX,

    ANOP,
    // ----------------------------------------------------------------------
    // Arithmetic and logic opcodes
    // ----------------------------------------------------------------------
    <<logic opcodes>>
    <<add/sub opcodes>>
    <<mul/div/mod opcodes>>
    <<bitshift opcodes>>
    <<comparison opcodes>>
    // ----------------------------------------------------------------------
    // Branching opcodes
    // ----------------------------------------------------------------------
    <<branching opcodes>>
    // ----------------------------------------------------------------------
    // Memory MOV opcodes
    // ----------------------------------------------------------------------
    <<mov opcodes>>
    <<swap opcodes>>
    // ----------------------------------------------------------------------
    // Syscall
    // ----------------------------------------------------------------------
    <<interrupt opcodes>>
    // ----------------------------------------------------------------------
    // Float opcodes
    // ----------------------------------------------------------------------
    <<float mov opcodes>>
    <<float arithmetic opcodes>>
    // ----------------------------------------------------------------------
    // Misc opcodes
    // ----------------------------------------------------------------------
    <<misc opcodes>>

    // ----------------------------------------------------------------------
    // Pseudo opcodes
    // ----------------------------------------------------------------------
    <<pseudo opcodes>>

    ALAST,
};
@
%note: was called 'enum as'
%note: the enum must contain less than 256 elements, as we rely on 
% sending ANAME as a byte in zname(), and all opcode as a byte in zaddr()
%note: I reordered a lot the original opcodes. Note that it can be dangerous
% for backward compatiblity to do so. Indeed 'ld' and 'as' need to agree
% with each other; one can't use a library compiled (or cross compiled) 
% using a 5l relying on a certain order, and link object files compiled 
% by a 5a relying on another order. So can have some subtle errors if
% want to play with what is cross-compiled! So make sure to recompile your
% libc if you modify 5l or 5a or 5.out.h
%note: the actual binary code generation is done in the linker, so
% the order of the opcode below does not have to match the opcode order
% for the ARM. Actually I have reordered them to be more logical
% e.g. AND, ORR, EOR are closer together.
%less: Could analyze *.s in plan9 and do some stats? or use cg on the
%  whole plan9 and see how much AXXX is used

% The opcodes mimic closely the ISA of ARM. Actual machine opcodes.
% But also pseudo opcodes (asm directives) like ATEXT. 
% And also "virtual" opcodes! ANOP is such a virtual/fake opcode.
% also RET, MOV, SLL, BEQ, etc.

% no PUSH/POP?

\section{[[Register]]}

<<enum regxxx(arm)>>=
enum registr {
    <<[[regxxx]] compiler conventions cases>>
    REGSB =		12,
    REGSP =		13,
    REGLINK =	14,
    REGPC =		15,
};
@
% REGSB is new! Machine.nw does not have it.
% REGFP? not in ARM, but 5a has a fake register LFP (not sure
% which actual register will be used for it though)

<<constant NREG(arm)>>=
#define	NREG		16
@
% used to represent NONE for the outcode reg parameter
% but I prefer now R_NONE below.

<<constant R_NONE(arm)>>=
#define R_NONE 16
@

% there are also 
% - float registers Fxxx
% - coprocessor registers Cxxx
% - and also the status register, PCR, and FPCR


\section{[[Operand_kind]] and [[Gen]]}

% many instructions have 2 or 3 operands, e.g. ADD X1, X2, X3,
% MOV X1, X2 where they can all be registers, or sometimes they can be
% constants. 

% 'type' encodes the kind of the operands. see later D_REG, D_CONST, etc. 
% how get the remaining info? e.g. for D_BRANCH to get the symbol or int 
% you'll have too look in Gen.value. For D_CONST it's Gen.offset.

<<struct Gen(arm)>>=
struct	Gen
{
    // enum<operand_kind>
    short	type;

    long	offset; // offset or generic value
    double	dval;
    char	sval[8];

    <<[[Gen]] other fields>>
};
@
%less: =~ Adr of Linker ?
%less: rename operand? Why gen anyway? generic?

%less: rename offset? to generic_value? or generic_long?
% but it's true in many places it's used to encode an offset to
% a base (a reg, a name). maybe a union would be good. like 
% they did for Adr in the linker.
% e.g. for D_SHIFT the long is used really to encode the whole
% thing with some bits for the shift kind, some bits for the register, etc.
% see the many uses cases of offset in zaddr() switch about operand_kind ...
%mimic what is in union token too

<<enum operand_kind(arm)>>=
enum operand_kind {
    D_NONE,
    <<operand_kind cases>>
};
@
%less: why D_ prefix? 
%dead: D_GOK, D_ADDR (valid for x86 but unused for arm)/* type/name */ for GOK
%note: I reordered again a lot things, which like for opcode has some impact
% on 5l. Now D_REG, D_CONST, D_SHIFT are closer (to mimic imsr rule).
%See Dconv in Linker for dumper (which can help to undertand things too)


%note: An ADT would be far better than this enum and separate Sym 
% and Gen (=~ Adr). So it works with Gen so it's really
% type operand = 
%  | D_REG of register
%  | D_CONST of int
%  | Branch of offset (PC)
%  | Extern of name * offset (SB) ?
%less: maybe by playing with Literate Programming I can reproduce a kind of ADT?
% e.g. by introducing LSREG, and then the part of the enum register related
% to LSREG?
% type instr = 
%   ...
% type reg = 
%   ...


<<[[Gen]] other fields>>=
// option<enum<register>>, None = R_NONE
short	reg;
@
% many operands are either directly a register (D_REG), or an offset
% to a register (D_OREG), so most operands involve at least one register
% (this make the link with the previous section also)


% ok but what about an Instruction data structure?
% usually ADD, R1, R2, R3 
% =~ Prog of Linker (but without opcode)?
% how encoded the whole instruction? 
% right now it's done via multiple parameters to outcode.
% less: define a structure?

\section{[[Token]] and [[itab]]}

%typedef int token_kind; (union { char; enum token_kind })
% see y.tab.h for token_kind enum (which are actually a set of #define
% with also ascii char into it)

% less: rename LTYPEXXX by T_END, T_TEXT, etc?
% l for lexeme?
<<token declarations(arm)>>=
/* opcodes */
%token  <lval>  LTYPE1 LTYPE2 LTYPE3 LTYPE4 LTYPE5 LTYPE6 LTYPE7 LTYPE8 LTYPE9 
%token  <lval>  LTYPEA LTYPEB LTYPEC LTYPEE LTYPEH LTYPEI
%token  <lval>  LTYPEJ LTYPEK LTYPEL LTYPEM LTYPEN 
/* registers */
%token  <lval>  LSP LSB LFP LPC
%token  <lval>  LR LREG  LPSR
%token  <lval>  LF LFREG  LFCR 
%token  <lval>  LC LCREG

/* bits */
%token  <lval>  LCOND
%token  <lval>  LS LAT
/* constants */
%token  <lval>  LCONST 
%token  <dval>  LFCONST
%token  <sval>  LSCONST
/* names */
%token  <sym>   LNAME LLAB LVAR
@
%dead: LTYPEX LTYPEF LTYPEG LTYPED



<<union token(arm)>>=
%union {
 //   enum<opcode>   (for LTYPEx/...) 
 // | enum<registr> (for LREG/...)
 // | enum<cond>     (for LCOND) 
 // ...
 // | long (for LCONST)
 long   lval;

 double dval;    // for LFCONST
 char   sval[8]; // for LSCONST
 Sym    *sym;    // for LNAME/LLAB/LVAR

 <<[[Token]] other fields(arm)>>
}
@
% note: mutual ref with sym here where sym has itself a type that is 
% the token_kind

% could use NSNAME here instead of char sval[8] ? and at a few other places?
% from 8.out.h
<<constant NSNAME(arm)>>=
#define	NSNAME		8
@
% sval[8]?? can't have string more than 8 bytes? hence the data2c
% ugly list?


% LTYPE0 etc are defined in a.y, tokens with value 
% instruction table conversion, string -> token
<<struct Itab(arm)>>=
struct Itab
{
    char	*name;

    //enum<token_kind>
    ushort	type;
    //enum<opcode|operand_kind|sym_kind|registr> | int
    ushort	value;
};
@
% actually value can also range in enum<fregisters>, enum<sysregisters>, etc
%less: hmm ADT again would be better than union and this
%    // could put D_NONE as a.y actually redo the job of setting Gen.value
%    // appropriately
%

<<global itab(arm)>>=
// map<string, (token_kind * enum<opcode|register|...>)>
struct Itab itab[] =
{
    "NOP",		LTYPEI, ANOP,
    <<[[itab]] elements>>
    0
};
@
% not a string -> partial_token (miss the concrete values, have just the lval
%  case)

\section{[[Sym]] and [[hash]]}

% assembling is a lot about symbolic name processing!
% The sym structure below is a kind of symbol tables, keep track
% of what symbolic names are used, their type (labels vs variables
% vs parameter vs local vs function).

% This symbol table is abused also by the lexer.

% (actually generic struct in aa/)
<<struct Sym>>=
struct	Sym
{
    char	*name;

    //enum<token_kind> (e.g. LLAB, LNAME, LVAR, LTYPE1, etc)
    ushort	type;

    // long (e.g. pc for LLAB, or integer for LVAR) 
    //   | enum<opcode|operand_kind|registr|...> 
    long	value; 

    <<[[Sym]] other fields>>
    // Extra
    <<[[Sym]] extra fields>>
};
@
%note: value is a vlong in va/
%note: there is no symkind here, this is stored outside the Sym

%    // symbols are used for many things:
%    //  - for labels (bar:), 
%    //  - for symbols/names (e.g. TEXT foo, or MOV foo(SB), R1)
%    //  - variables (VAR=xxx)
%    //  - but also (ab)used for opcodes (AMOV), registers (LR1) (see itab)

% this is used for user defined names (e.g. TEXT foo), but
% abused also for keywords operand like AL, AX, and also for opcode
% in which case the value is the opcode.
% note: because of hash below that means that all MOVB in a file
% are shared when lexing
%    // see also itab[i].type and itab[i].value
% archi: not that in va/ value is a vlong, not a long // archi: vlong in va/!!

<<constant NHASH>>=
#define	NHASH		503
@

<<global hash>>=
// hash<string, ref_own?<Sym>>, (next in bucket = Sym.link)
Sym*	hash[NHASH];
@
% diff with h?

% what is the head? hash! and also h?
<<[[Sym]] extra fields>>=
// list<ref<Sym>> (next = Sym.link) bucket of hashtbl 'hash'
Sym*	link;
@

% what is the list it marks the end of? hash for sure, maybe also h and htab?
<<constant S>>=
#define	S	((Sym*)nil)
@



<<constant NSYMB>>=
#define	NSYMB		500
@
% was //#define	NSYMB		8192 on arm, not sure it matters

% global is bad, slookup cleaner than lookup
<<global symb>>=
char	symb[NSYMB];
@

% use symb global, a bit ugly
% TODO lp split, compute hash key of symb, find in hash global, etc
<<function lookup>>=
Sym*
lookup(void)
{
    Sym *s;
    long h;
    char *p;
    int c, l;

    h = 0;
    for(p=symb; c = *p; p++)
        h = h+h+h + c;
    l = (p - symb) + 1;
    if(h < 0)
        h = ~h;
    h %= NHASH;

    c = symb[0];
    for(s = hash[h]; s != S; s = s->link) {
        if(s->name[0] != c)
            continue;
        if(memcmp(s->name, symb, l) == 0)
            return s;
    }
    s = alloc(sizeof(*s));
    s->name = alloc(l);
    memmove(s->name, symb, l);

    s->link = hash[h];
    hash[h] = s;

    syminit(s);
    return s;
}
@

<<function syminit>>=
void
syminit(Sym *s)
{

    s->type = LNAME;
    s->value = 0;
}
@


<<function slookup>>=
Sym*
slookup(char *s)
{

    strcpy(symb, s);
    return lookup();
}
@
% cleaner interface at least

%dead:
%<<[[Sym]] other fields>>=
%Ref*	ref; // unused for 5a, matters?
%@
%<<struct Ref>>=
%// only for 8a actually, and actually not used so I removed it
%struct	Ref
%{
%    int	class;
%};
%@


\section{[[Sym_kind]]}

% important rule of assembler is to use symbolic names, for
% labels, but also for entities, that can even possibly
% defined in another file. So operands of some opcodes
% are really names, symbols, to define them e.g. TEXT or
% to use them e.g. MOV.

<<[[Gen]] other fields>>=
// option<Sym>
Sym*	sym;
@
%less: maybe should rename this field 'name'? and then use name_kind?

% example: TEXT foo(SB) ... or MOV $1, bar(SB) or BL bar(SB).
% in the case of MOV $1, bar(SB), the Gen structure
% for the first operand will be a D_CONST of offset/value 1.
% For the second operand will be a D_OREG with 
% with symkind = D_EXTERN (SB), offset 0, and sym "bar".


% Assembler is outputing a (spreaded) symbol table in the object file.
% Important job of assembler is to prepare for linker, to enable
% the linker to link modules together and so to resolve references 
% to external symbols.

<<enum sym_kind(arm)>>=
enum sym_kind {
   N_NONE,
   <<sym_kind cases>>
};
@
%note: this used to be with operand_kind, but they are really disjoint
% and used only for the ANAME pseudo opcode. In 5l/ there is
% actually a separate Dconv and Nconv (but in 8l/ they are together).

<<[[Gen]] other fields>>=
// option<sym_kind>, None = N_NONE
short	symkind;
@
%old: was called name, but confusing I think, name as a field was used in
% many structures and it's actually not a name
%less: rename name to name_kind? rename also the sym field above?

%note that can have symkind set but not necessarality a sym,
% but it's in the degenerated case of con ( pointer ) which
% I think should not happen (or should happen when don't care
% about naming the parameter so just do  4(FP) in which
% case sym can be seen as an anonymous symbol name.




%section{[[pc]]} ?

\chapter{[[main()]]}

% default object suffix, to generate foo.5
<<global thechar>>=
int	thechar;
@

% to find archi specific core header files, /arm/include/...
<<global thestring>>=
char*	thestring;
@

% -o
<<global outfile>>=
char*	outfile = nil;
@
% hmm could be 5.out instead no? hmm no, it will be set
% to {basename(input_file)}.{thechar} in assemble()



<<function main(arm)>>=
void
main(int argc, char *argv[])
{
    <<[[main()]] locals>>
    <<[[main()]] debug initialization>>

    thechar = '5';
    thestring = "arm";

    cinit();
    include[ninclude++] = ".";

    ARGBEGIN {
    <<[[main()]] command line processing>>
    } ARGEND

    if(*argv == 0) {
        print("usage: %ca [-options] file.s\n", thechar);
        errorexit();
    }

    <<[[main()]] multiple files handling>>

    if(assemble(argv[0]))
        errorexit();
    exits(0);
}
@

<<[[main()]] command line processing>>=
case 'o':
    outfile = ARGF();
    break;
@





\section{[[cinit()]]}

<<function cinit(arm)>>=
void
cinit(void)
{
    Sym *s;
    int i;

    <<[[cinit()]] nullgen initialisation>>
    <<[[cinit()]] hash initialisation from itab>>
    <<[[cinit()]] pathname initialisation from cwd>>
}
@
% used to do more initialisation here, but instead move the init
% at the def location
% very similar to the x86 version, except the few change for nullgen fields

% see cinit()
<<global nullgen>>=
Gen	nullgen;
@



<<[[cinit()]] nullgen initialisation>>=
nullgen.type = D_NONE;
nullgen.offset = 0;
nullgen.reg = R_NONE;
nullgen.sym = S;
nullgen.symkind = N_NONE;
if(FPCHIP)
    nullgen.dval = 0;
for(i=0; i<sizeof(nullgen.sval); i++)
    nullgen.sval[i] = 0;
@
% can't use N_NONE because this function is in aa/ and N_NONE is
% in 5a/a.h

<<[[cinit()]] hash initialisation from itab>>=
for(i=0; i<NHASH; i++)
    hash[i] = S;
for(i=0; itab[i].name; i++) {
    s = slookup(itab[i].name);
    s->type = itab[i].type;
    s->value = itab[i].value;
}
@

% cwd, for #include "" (cwd can change as one include other files)
%  =~ dirname(current_file)
% less: rename? dirname_of_input_file? (actually it's really
% dirname_of_current_input_file as 5a can process multiple files,
% but it would complicate things; multifile is an advanced topic)
<<global pathname>>=
char*	pathname;
@


<<[[cinit()]] pathname initialisation from cwd>>=
pathname = allocn(pathname, 0, 100);
if(getwd(pathname, 99) == 0) {
    pathname = allocn(pathname, 100, 900);
    if(getwd(pathname, 999) == 0)
        strcpy(pathname, "/???");
}
@

\section{[[assemble()]]}

% there are 2 passes.
% This global is used outside assemble() in the grammar! and outcode().
% the idea is actually to parse two times, but to do different things the
% second time. Abusing grammar actions (old style).
<<global pass>>=
// 1|2
int	pass;
@


<<[[assemble()]] locals>>=
char *p;
fdt of; // outfile
int i;
@

% outfile(string) -> of(fd) -> obuf(biobuf)
% the actual content of the object file 5a generates
<<global obuf>>=
Biobuf	obuf;
@

<<function assemble>>=
int
assemble(char *infile)
{
    <<[[assemble()]] locals>>

    <<[[assemble()]] set p to basename(infile) and adjust include>>
    if(outfile == nil) {
        <<[[assemble()]] set outfile to {basename(infile)}.{thechar}>>
    }
    <<[[assemble()]] setinclude("/{thestring}/include") or INCLUDE>>

    of = mycreat(outfile, 0664);
    if(of < 0) {
        yyerror("%ca: cannot create %s", thechar, outfile);
        errorexit();
    }
    Binit(&obuf, of, OWRITE);

    pass = 1;

    pinit(infile);
    <<[[assemble()]] init Dlist after pinit>>
    yyparse(); // calls outcode() but does nothing when pass == 1

    if(nerrors) {
        cclean();
        return nerrors;
    }

    pass = 2;
    outhist(); // header

    pinit(infile);
    <<[[assemble()]] init Dlist after pinit>>
    yyparse(); // calls outcode() that now does things

    cclean();
    return nerrors;
}
@
%note: I renamed parameter to infile, to better contrast with outfile






<<[[assemble()]] locals>>=
char ofile[100];
@

<<[[assemble()]] set p to basename(infile) and adjust include>>=
// p = basename(infile)
// include[0] = dirname(infile); 
strcpy(ofile, infile);
p = utfrrune(ofile, '/');
if(p) {
    include[0] = ofile;
    *p++ = '\0';
} else
    p = ofile;
@

<<[[assemble()]] set outfile to {basename(infile)}.{thechar}>>=
// outfile =  p =~ s/.s/.5/;
outfile = p;
if(outfile){
    p = utfrrune(outfile, '.');
    if(p)
        if(p[1] == 's' && p[2] == '\0')
            p[0] = '\0';
    p = utfrune(outfile, '\0');
    p[0] = '.';
    p[1] = thechar;
    p[2] = '\0';
} else
    outfile = "/dev/null";
@


<<[[assemble()]] locals>>=
char incfile[20];
@

<<[[assemble()]] setinclude("/{thestring}/include") or INCLUDE>>=
p = getenv("INCLUDE");
if(p) {
    setinclude(p);
} else {
    if(systemtype(Plan9)) {
        sprint(incfile,"/%s/include", thestring);
        setinclude(strdup(incfile));
    }
}
@



<<function cclean(arm)>>=
void
cclean(void)
{

    outcode(AEND, Always, &nullgen, R_NONE, &nullgen);
    Bflush(&obuf);
}
@
% need AEND? yes, the linker wants an AEND, and I think
% when use a library, can have multiple objects concatenated
% in which case AEND is a marker for the end of an object.

\chapter{Input}

% yyparse() actually calls yylex() that calls reading file functions (GETC)

<<global lineno>>=
long	lineno;
@
% this is incremented by the lexer, and is also outputted
% in the object code for each instruction! so can trace back
% the line of an instruction!
% Is it after #include expansion line number?
% less: rename glineno?


% =~ yyback(1) trick, used by yylex() and getc(), and?? cg?
<<global peekc>>=
int	peekc = IGN;
@
% used to be set in cinit()

<<constant IGN>>=
#define	IGN		(-2)
@

<<constant EOF>>=
#define	EOF		(-1)
@



% assemble -> <> (before yyparse, in both passes)
% call at the beginning of each pass with the file to assemble
<<function pinit>>=
void
pinit(char *f)
{
    int i;
    Sym *s;

    lineno = 1;
    pc = 0;

    newio();
    newfile(f, -1);
    peekc = IGN;

    <<[[pinit]] symcounter and h initialisation>>
    <<[[pinit]] hash macro field reset>>
}
@


\section{Files managment, [[iostack]]}

% 5a supports #include  so have to open files, close them
%less: better to separate concern and have cpp in a different program?

<<constant BUFSIZ>>=
#define	BUFSIZ		8192
@

% hmm, could they use shorter fieldnames ...
<<struct Io>>=
struct	Io
{
    char	b[BUFSIZ];

    // -1 if not opened yet
    fdt	f;

    // like Fi, saved IO buffer status
    char*	p;
    short	c;

    // Extra
    <<[[Io]] extra fields>>
};
@

% list/stack because of #include, iostack point to head and currently
% opened and processed file
<<global iostack>>=
// list<Io> (next = Io.link)
Io*	iostack = I;
@
% used to be set in cinit()

<<[[Io]] extra fields>>=
Io*	link;
@

<<constant I>>=
#define	I	((Io*)nil)
@


<<global iofree>>=
// list<IO>, next = IO.link
Io*	iofree = I;
@

<<global ionext>>=
// option<ref<IO>>
Io*	ionext;
@

% assemble -> pinit -> <>
<<function newio>>=
void
newio(void)
{
    Io *i;
    static int pushdepth = 0;

    i = iofree;
    if(i == I) {
        pushdepth++;
        if(pushdepth > 1000) {
            yyerror("macro/io expansion too deep");
            errorexit();
        }
        //todo: check error code?
        i = alloc(sizeof(Io));
    } else
        iofree = i->link;
    i->c = 0;
    i->f = -1;
    ionext = i;
}
@


% assemble -> pinit -> <>
<<function newfile>>=
void
newfile(char *s, int f)
{
    Io *i;

    i = ionext;
    i->link = iostack;
    iostack = i;

    i->f = f;
    if(i->f < 0)
        i->f = open(s, 0);
    if(i->f < 0) {
        yyerror("%ca: %r: %s", thechar, s);
        errorexit();
    }
    fi.c = 0;
    linehist(s, 0);
}
@

\section{Buffer managment, [[fi]]}

% buffered IO

% File input?
<<struct Fi>>=
struct Fi
{
    // ref<char>, pointer in buffer (of Io.b)
    char*	p;
    // remaining count in buffer (of Io.b)
    int	c;
};
@

% global IO buffer
<<global fi>>=
struct Fi fi;
@


<<function GETC>>=
#define	GETC()		((--fi.c < 0) ? filbuf() : *fi.p++ & 0xff)
@

<<function filbuf>>=
int
filbuf(void)
{
    Io *i;

loop:
    i = iostack;
    if(i == I)
        return EOF;
    if(i->f < 0)
        goto pop;
    fi.c = read(i->f, i->b, BUFSIZ) - 1;
    if(fi.c < 0) {
        close(i->f);
        linehist(nil, 0);
        goto pop;
    }
    fi.p = i->b + 1;
    return i->b[0];

pop:
    iostack = i->link;
    i->link = iofree;
    iofree = i;
    i = iostack;
    if(i == I)
        return EOF;
    fi.p = i->p;
    fi.c = i->c;
    if(--fi.c < 0)
        goto loop;
    return *fi.p++;
}
@



\chapter{Lexing}

\section{[[yylex()]]}

% loop until find a token and return its code
% and also set yylval global to contain more
% info about the token (yylval = the big union)

% GETC is essentially get next char in current opened file
% (that is iostack->f )
% #define	GETC()		((--fi.c < 0) ? filbuf() : *fi.p++ & 0xff)
% type: unit -> int (-1 for EOF, 0 for?)



% should use lex ... simpler, but maybe to avoid bootstrapping issues?
% hmm but they use yacc so ... (and lex uses yacc)



% called by? yyparse() in generated code from a.y
<<function yylex>>=
long
yylex(void)
{
    int c;
    <<[[yylex()]] locals>>

    c = peekc;
    if(c != IGN) {
        peekc = IGN;
        goto l1;
    }
l0:
    c = GETC();

l1:
    if(c == EOF) {
        peekc = EOF;
        return -1;
    }

    if(isspace(c)) {
        if(c == '\n') {
            lineno++;
            return ';';
        }
        goto l0;
    }

    if(isalpha(c))
        goto talph;
    if(isdigit(c))
        goto tnum;

    switch(c) {
    <<[[yylex()]] switch c cases>>
    default:
        return c;
    }
    peekc = c1;
    return c;
}
@
%$

% LP aspectize peekc? lp split more the func?


<<[[yylex()]] locals>>=
int c1;
@
% for peek


\section{Newline}
% and semicolons?

<<[[yylex()]] switch c cases>>=
case '\n':
    lineno++;
    return ';';
@

% newline are translated in ';' and this is used by
% the grammar, see Parsing subsections

\section{Comments}

<<[[yylex()]] switch c cases>>=
case '/':
    c1 = GETC();
    if(c1 == '/') {
        for(;;) {
            c = GETC();
            if(c == '\n')
                goto l1;
            if(c == EOF) {
                yyerror("eof in comment");
                errorexit();
            }
        }
    }
    if(c1 == '*') {
        for(;;) {
            c = GETC();
            while(c == '*') {
                c = GETC();
                if(c == '/')
                    goto l0;
            }
            if(c == EOF) {
                yyerror("eof in comment");
                errorexit();
            }
            if(c == '\n')
                lineno++;
        }
    }
    break;
@
% goto l1 or l0 depending if want to ask for another char or not

% put getcom() here too?

\section{Keywords and identifiers}

<<[[yylex()]] locals>>=
char *cp;
Sym *s;
@


% @ too? maybe could remove it so it would also remove the need for
% the LAT token_kind
<<[[yylex()]] switch c cases>>=
case '_':
case '@':
// case 'a'..'z' 'A'..'Z': (isalpha())
talph:
    cp = symb;

aloop:
    *cp++ = c;
    c = GETC();
    if(isalpha(c) || isdigit(c) || c == '_' || c == '$') // $
        goto aloop;

    // went too far, yyback(1)
    peekc = c;

    *cp = '\0';
    s = lookup();

    <<[[yylex()]] if macro symbol>>

    if(s->type == 0)
        s->type = LNAME;

    if(s->type == LNAME || s->type == LVAR || s->type == LLAB) {
        yylval.sym = s;
    } else {
        yylval.lval = s->value;
    }
    return s->type;
@
% possible to have s->type == 0? if new symbol then I think
% it actually set to LNAME in syminit

\section{Numbers}

%TODO LP split
<<[[yylex()]] switch c cases>>=
// case '0'..'9': (isdigit())
tnum:
    cp = symb;
    if(c != '0')
        goto dc;

    *cp++ = c;
    c = GETC();
    c1 = 3;
    if(c == 'x' || c == 'X') {
        c1 = 4;
        c = GETC();
    } else
    if(c < '0' || c > '7')
        goto dc;
    yylval.lval = 0;
    for(;;) {
        if(c >= '0' && c <= '9') {
            if(c > '7' && c1 == 3)
                break;
            yylval.lval <<= c1;
            yylval.lval += c - '0';
            c = GETC();
            continue;
        }
        if(c1 == 3)
            break;
        if(c >= 'A' && c <= 'F')
            c += 'a' - 'A';
        if(c >= 'a' && c <= 'f') {
            yylval.lval <<= c1;
            yylval.lval += c - 'a' + 10;
            c = GETC();
            continue;
        }
        break;
    }
    goto ncu;

dc:
    for(;;) {
        if(!isdigit(c))
            break;
        *cp++ = c;
        c = GETC();
    }
    if(c == '.')
        goto casedot;
    if(c == 'e' || c == 'E')
        goto casee;
    *cp = 0;
    if(sizeof(yylval.lval) == sizeof(vlong))
        yylval.lval = strtoll(symb, nil, 10);
    else
        yylval.lval = strtol(symb, nil, 10);

ncu:
    while(c == 'U' || c == 'u' || c == 'l' || c == 'L')
        c = GETC();
    peekc = c;
    return LCONST;

casedot:
    for(;;) {
        *cp++ = c;
        c = GETC();
        if(!isdigit(c))
            break;
    }
    if(c == 'e' || c == 'E')
        goto casee;
    goto caseout;

casee:
    *cp++ = 'e';
    c = GETC();
    if(c == '+' || c == '-') {
        *cp++ = c;
        c = GETC();
    }
    while(isdigit(c)) {
        *cp++ = c;
        c = GETC();
    }

caseout:
    *cp = 0;
    peekc = c;
    if(FPCHIP) {
        yylval.dval = atof(symb);
        return LFCONST;
    }
    yyerror("assembler cannot interpret fp constants");
    yylval.lval = 1L;
    return LCONST;
@


\subsection{Decimals}

\subsection{Floats}

<<[[yylex()]] switch c cases>>=
case '.':
    c = GETC();
    if(isalpha(c)) {
        cp = symb;
        *cp++ = '.';
        goto aloop;
    }
    if(isdigit(c)) {
        cp = symb;
        *cp++ = '.';
        goto casedot;
    }
    peekc = c;
    return '.';
@


\section{Characters}

<<[[yylex()]] switch c cases>>=
case '\'':
    c = escchar('\'');
    if(c == EOF)
        c = '\'';
    if(escchar('\'') != EOF)
        yyerror("missing '");
    yylval.lval = c;
    return LCONST;
@

\section{Escaping characters}
%Special characters?

% e is usually ' or ", the ending characher (and also char you have to escape)
% use Rune instead of int?
<<function escchar>>=
int
escchar(int e)
{
    int c, l;

loop:
    c = getc();
    if(c == '\n') {
        yyerror("newline in string");
        return EOF;
    }
    if(c != '\\') {
        if(c == e)
            return EOF;
        return c;
    }
    c = getc();
    if(c >= '0' && c <= '7') {
        l = c - '0';
        c = getc();
        if(c >= '0' && c <= '7') {
            l = l*8 + c-'0';
            c = getc();
            if(c >= '0' && c <= '7') {
                l = l*8 + c-'0';
                return l;
            }
        }
        peekc = c;
        return l;
    }
    switch(c)
    {
    case '\n':	goto loop;
    case 'n':	return '\n';
    case 't':	return '\t';
    case 'b':	return '\b';
    case 'r':	return '\r';
    case 'f':	return '\f';

    case 'a':	return 0x07;
    case 'v':	return 0x0b;
    case 'z':	return 0x00;
    }
    return c;
}
@
% they abuse EOF to mean end of string

\section{Strings}

<<[[yylex()]] switch c cases>>=
case '"':
    memcpy(yylval.sval, nullgen.sval, sizeof(yylval.sval));
    cp = yylval.sval;
    c1 = 0;
    for(;;) {
        c = escchar('"');
        if(c == EOF)
            break;
        if(c1 < sizeof(yylval.sval))
            *cp++ = c;
        c1++;
    }
    if(c1 > sizeof(yylval.sval))
        yyerror("string constant too long");
    return LSCONST;
@
% limited to 8 bytes, hence the data2c script


\section{[[getc()]], [[unget()]], [[getnsc()]]}

% from now on those functions are actually used by the preprocessing
% code, not by the basic lexer (yylex) that actually implement
% his own getnsc(), getcom(), getsym() via cases
% (hmmm maybe could factorize things?)

% helpers for other functions

% int? why not uint? GETC can return EOF but not this function!
<<function getc>>=
int
getc(void)
{
    int c;

    c = peekc;
    if(c != IGN) {
        peekc = IGN;
        return c;
    }

    c = GETC();

    if(c == '\n')
        lineno++;
    if(c == EOF) {
        yyerror("End of file");
        errorexit();
    }
    return c;
}
@


% what if had already a peekc? because called unget 2 times?
% should raise Impossible!
<<function unget>>=
void
unget(int c)
{
    peekc = c;
    if(c == '\n')
        lineno--;
}
@

% get non space char (they really like short cryptic names)
<<function getnsc>>=
int
getnsc(void)
{
    int c;

    for(;;) {
        c = getc();
        if(!isspace(c) || c == '\n')
            return c;
    }
}
@



\section{[[getsym()]]}
% mv with Keywords and identifier section?

<<function getsym>>=
Sym*
getsym(void)
{
    int c;
    char *cp;

    c = getnsc();
    if(!isalpha(c) && c != '_' && c < Runeself) {
        unget(c);
        return S;
    }
    for(cp = symb;;) {
        if(cp <= symb+NSYMB-4)
            *cp++ = c;
        c = getc();
        if(isalnum(c) || c == '_' || c >= Runeself)
            continue;
        unget(c);
        break;
    }
    *cp = 0;
    if(cp > symb+NSYMB-4)
        yyerror("symbol too large: %s", symb);
    return lookup();
}
@

\section{[[getcom()]]}
% mv with Comments section above?

<<function getcom>>=
int
getcom(void)
{
    int c;

    for(;;) {
        c = getnsc();
        if(c != '/')
            break;
        c = getc();
        if(c == '/') {
            while(c != '\n')
                c = getc();
            break;
        }
        if(c != '*')
            break;
        c = getc();
        for(;;) {
            if(c == '*') {
                c = getc();
                if(c != '/')
                    continue;
                c = getc();
                break;
            }
            if(c == '\n') {
                yyerror("comment across newline");
                break;
            }
            c = getc();
        }
        if(c == '\n')
            break;
    }
    return c;
}
@

\chapter{Preprocessing}

<<global mactab>>=
struct
{
    char	*macname;
    void	(*macf)(void);
} mactab[] =
{
    "ifdef",	nil,	/* macif(0) */
    "ifndef",	nil,	/* macif(1) */
    "else",		nil,	/* macif(2) */
    "endif",	macend,

    "include",	macinc,
    "define",	macdef,
    "undef",	macund,
    "pragma",	macprag,
    "line",		maclin,
    0
};
@
% mac for macro (and not macos or macintosh), but used actually
% for all cpp related constructs.
% note: I reorganized the entries, but should not matter

<<[[yylex()]] switch c cases>>=
case '#':
    domacro();
    goto l0;
@
% goto l0 because does not return any token, we just have
% actually expanded or defined macros or undef, in any case
% no token to return

% dispatcher, should rename because it's not just about macro =>
% parse_and_dispatch_pp_directive?
<<function domacro>>=
void
domacro(void)
{
    int i;
    Sym *s;

    s = getsym();
    if(s == S)
        s = slookup("endif");

    for(i=0; mactab[i].macname; i++)
        if(strcmp(s->name, mactab[i].macname) == 0) {
            if(mactab[i].macf)
                // dispatcher!
                (*mactab[i].macf)();
            else
                macif(i);
            return;
        }
    yyerror("unknown #: %s", s->name);
    macend();
}
@
% abuse getsym just to get an ident, don't have to go through
% lookup really
% note: didn't know that a single # is actually equivalent to an endif



<<function macend>>=
void
macend(void)
{
    int c;

    for(;;) {
        c = getnsc();
        if(c < 0 || c == '\n')
            return;
    }
}
@
% I don't think c can be < 0 here.

\section{[[#include]]}
% and [[-I]]

\subsection{Include path, [[-I]]}

<<[[main()]] locals>>=
char *p;
@

% -I
<<[[main()]] command line processing>>=
case 'I':
    p = ARGF();
    setinclude(p);
    break;
@

<<constant NINCLUDE>>=
#define	NINCLUDE	10
@

% hmm rename? include_paths?
<<global include>>=
char*	include[NINCLUDE];
@

<<global ninclude>>=
int	ninclude;
@

<<function setinclude>>=
void
setinclude(char *p)
{
    int i;

    if(p == nil)
        return;
    for(i=1; i < ninclude; i++)
        if(strcmp(p, include[i]) == 0)
            return;

    if(ninclude >= nelem(include)) {
        yyerror("ninclude too small %d", nelem(include));
        exits("ninclude");
    }
    include[ninclude++] = p;
}
@


\subsection{Tracing origin and [[Hist]]}

% when error, need give line, but can be because of context,
% so useful to give the full location of an error, that is the list
% of files that included it
% TODO give example of why it's useful to not just have the final names

% keep track of where a token comes from, so that error
% messages can look like
%  xxx.h from xxx.h from xxx.c ...
<<struct Hist>>=
struct	Hist
{
    char*	filename;

    long	line;   // global line of this Hist
    long	local_line; // local line for this hist 

    // Extra
    <<[[Hist]] extra fields>>
};
@
%note: rename offset to local_line, clearer, and also avoid
% possible confusion with Gen.offset

<<global hist>>=
// list<ref_own<Hist>>, next = Hist.link
Hist*	hist;
@

<<[[Hist]] extra fields>>=
Hist*	link;
@

<<global ehist>>=
// ref<Hist>, end of list of hist
Hist*	ehist;
@


<<constant H>>=
#define	H	((Hist*)nil)
@





<<function linehist>>=
void
linehist(char *f, int local_line)
{
    Hist *h;

    <<[[linehist()]] debug>>

    h = alloc(sizeof(Hist));
    h->filename = f;
    h->line = lineno;
    h->local_line = local_line;

    //add_list(hist, ehist, h)
    h->link = H;
    if(ehist == H) {
        hist = h;
        ehist = h;
        return;
    }
    ehist->link = h;
    ehist = h;
}
@


%% newflag dead? seems just set to false ... just one write.
%% it's used in cc/ though, but we copy pasted code for macbody so
% I think it's safe to delete it here.
%<<global newflag>>=
%bool	newflag;
%@
%
%    <<[[linehist()]] newflag hack>>
%    <<[[linehist()]] debug>>
%    newflag = false;
%
%
%<<[[linehist()]] newflag hack>>=
%/*
% * overwrite the last #line directive if
% * no alloc has happened since the last one
% */
%if(newflag == false && ehist != H && offset != 0 && ehist->offset != 0)
%    if(f && ehist->filename && strcmp(f, ehist->filename) == 0) {
%        ehist->line = lineno;
%        ehist->offset = offset;
%        return;
%    }
%@




% I prefer to put prfile here rather than in the Error appendix.
% So can better understand actually the tracing mechanism.

<<constant HISTSZ>>=
#define	HISTSZ		20
@

% yyerror -> <>, for nice error reporting with include trace
%  l = lineno
<<function prfile>>=
void
prfile(long l)
{
    int i, n;
    Hist *h;
    Hist a[HISTSZ];
    long d;

    n = 0;
    for(h = hist; h != H; h = h->link) {
        if(l < h->line)
            break;

        if(h->filename) {
            if(h->local_line == 0) {
                if(n >= 0 && n < HISTSZ)
                    a[n] = *h;
                n++;
            } else {
                if(n > 0 && n < HISTSZ)
                    if(a[n-1].local_line == 0) {
                        a[n] = *h;
                        n++;
                    } else
                        a[n-1] = *h;
           }
        }
        // a pop
        else {
            n--;
            if(n >= 0 && n < HISTSZ) {
                d = h->line - a[n].line;
                for(i=0; i<n; i++)
                    a[i].line += d;
            }
        }
    }
    if(n > HISTSZ)
        n = HISTSZ;
    for(i=0; i<n; i++)
        print("%s:%ld ", a[i].filename, 
                         (long)(l - a[i].line + a[i].local_line + 1));
}
@
% see 5a -f to help understand a bit.
% when no filename it means it's a pop

\subsection{[[#include]]}

<<constant STRINGSZ>>=
#define	STRINGSZ	200
@

% LP split
<<function macinc>>=
void
macinc(void)
{
    int c0, c, i, f;
    char str[STRINGSZ], *hp;

    c0 = getnsc();
    if(c0 != '"') {
        c = c0;
        if(c0 != '<')
            goto bad;
        c0 = '>';
    }
    for(hp = str;;) {
        c = getc();
        if(c == c0)
            break;
        if(c == '\n')
            goto bad;
        *hp++ = c;
    }
    *hp = 0;

    c = getcom();
    if(c != '\n')
        goto bad;

    f = -1;
    for(i=0; i<ninclude; i++) {
        if(i == 0 && c0 == '>')
            continue;
        strcpy(symb, include[i]);
        strcat(symb, "/");
        if(strcmp(symb, "./") == 0)
            symb[0] = 0;
        strcat(symb, str);

        f = open(symb, 0);
        if(f >= 0)
            break;

    }
    if(f < 0)
        strcpy(symb, str);
    c = strlen(symb) + 1;
    while(c & 3)
        c++;

    hp = malloc(c);
    memcpy(hp, symb, c);

    newio();
    pushio();
    newfile(hp, f);
    return;

bad:
    unget(c);
    yyerror("syntax in #include");
    macend();
}
@


<<function pushio>>=
void
pushio(void)
{
    Io *i;

    i = iostack;
    if(i == I) {
        yyerror("botch in pushio");
        errorexit();
    }
    i->p = fi.p;
    i->c = fi.c;
}
@

\section{[[#define]]}
% and [[-D]]

\subsection{[[-D]]}

<<[[main()]] command line processing>>=
case 'D':
    p = ARGF();
    if(p)
        Dlist[nDlist++] = p;
    break;
@

% -D
<<global Dlist>>=
char*	Dlist[30];
@

<<global nDlist>>=
int	nDlist;
@

<<[[assemble()]] init Dlist after pinit>>=
for(i=0; i<nDlist; i++)
        dodefine(Dlist[i]);
@

<<[[Sym]] other fields>>=
//option<string>, for '#define FOO xxx' expansion
char*	macro;
@

<<[[pinit]] hash macro field reset>>=
for(i=0; i<NHASH; i++)
    for(s = hash[i]; s != S; s = s->link)
        s->macro = nil;
@


<<function dodefine>>=
void
dodefine(char *cp)
{
    Sym *s;
    char *p;
    long l;
    char *x;

    strcpy(symb, cp);
    p = strchr(symb, '=');
    if(p) {
        *p++ = 0;
        s = lookup();
        l = strlen(p) + 2;	/* +1 null, +1 nargs */
        while(l & 3)
            l++;

        x = malloc(l);
        *x = '\0';
        strcpy(x+1, p);
        s->macro = x;
    } else {
        s = lookup();
        s->macro = "\0001";	/* \000 is nargs */
    }
    <<[[dodefine()]] debug>>
}
@



\subsection{[[#define]]}

<<constant NARG>>=
#define	NARG	25
@

% wow, this is complicated
<<function macdef>>=
void
macdef(void)
{
    Sym *s, *a;
    char *args[NARG], *np, *base;
    int n, i, c, len, dots;
    int ischr;

    s = getsym();
    if(s == S)
        goto bad;
    if(s->macro)
        yyerror("macro redefined: %s", s->name);
    c = getc();
    n = -1;
    dots = 0;
    if(c == '(') {
        n++;
        c = getnsc();
        if(c != ')') {
            unget(c);
            for(;;) {
                a = getsymdots(&dots);
                if(a == S)
                    goto bad;
                if(n >= NARG) {
                    yyerror("too many arguments in #define: %s", s->name);
                    goto bad;
                }
                args[n++] = a->name;
                c = getnsc();
                if(c == ')')
                    break;
                if(c != ',' || dots)
                    goto bad;
            }
        }
        c = getc();
    }
    if(isspace(c))
        if(c != '\n')
            c = getnsc();
    base = hunk;
    len = 1;
    ischr = 0;
    for(;;) {
        if(isalpha(c) || c == '_') {
            np = symb;
            *np++ = c;
            c = getc();
            while(isalnum(c) || c == '_') {
                *np++ = c;
                c = getc();
            }
            *np = 0;
            for(i=0; i<n; i++)
                if(strcmp(symb, args[i]) == 0)
                    break;
            if(i >= n) {
                i = strlen(symb);
                base = allocn(base, len, i);
                memcpy(base+len, symb, i);
                len += i;
                continue;
            }
            base = allocn(base, len, 2);
            base[len++] = '#';
            base[len++] = 'a' + i;
            continue;
        }
        if(ischr){
            if(c == '\\'){ 
                base = allocn(base, len, 1);
                base[len++] = c;
                c = getc();
            }else if(c == ischr)
                ischr = 0;
        }else{
            if(c == '"' || c == '\''){
                base = allocn(base, len, 1);
                base[len++] = c;
                ischr = c;
                c = getc();
                continue;
            }
            if(c == '/') {
                c = getc();
                if(c == '/'){
                    c = getc();
                    for(;;) {
                        if(c == '\n')
                            break;
                        c = getc();
                    }
                    continue;
                }
                if(c == '*'){
                    c = getc();
                    for(;;) {
                        if(c == '*') {
                            c = getc();
                            if(c != '/')
                                continue;
                            c = getc();
                            break;
                        }
                        if(c == '\n') {
                            yyerror("comment and newline in define: %s", s->name);
                            break;
                        }
                        c = getc();
                    }
                    continue;
                }
                base = allocn(base, len, 1);
                base[len++] = '/';
                continue;
            }
        }
        if(c == '\\') {
            c = getc();
            if(c == '\n') {
                c = getc();
                continue;
            }
            else if(c == '\r') {
                c = getc();
                if(c == '\n') {
                    c = getc();
                    continue;
                }
            }
            base = allocn(base, len, 1);
            base[len++] = '\\';
            continue;
        }
        if(c == '\n')
            break;
        if(c == '#')
        if(n > 0) {
            base = allocn(base, len, 1);
            base[len++] = c;
        }
        base = allocn(base, len, 1);
        base[len++] = c;
        c = ((--fi.c < 0)? filbuf(): (*fi.p++ & 0xff));
        if(c == '\n')
            lineno++;
        if(c == -1) {
            yyerror("eof in a macro: %s", s->name);
            break;
        }
    }
    do {
        base = allocn(base, len, 1);
        base[len++] = 0;
    } while(len & 3);

    *base = n+1;
    if(dots)
        *base |= VARMAC;
    s->macro = base;
    <<[[macdef()]] debug>>
    return;

bad:
    if(s == S)
        yyerror("syntax in #define");
    else
        yyerror("syntax in #define: %s", s->name);
    macend();
}
@
% wow, complicated

<<constant VARMAC>>=
#define VARMAC 0x80
@


<<function getsymdots>>=
Sym*
getsymdots(int *dots)
{
    int c;
    Sym *s;

    s = getsym();
    if(s != S)
        return s;

    c = getnsc();
    if(c != '.'){
        unget(c);
        return S;
    }
    if(getc() != '.' || getc() != '.')
        yyerror("bad dots in macro");
    *dots = 1;
    return slookup("__VA_ARGS__");
}
@

\subsection{Macro Expansion}

<<[[yylex()]] if macro symbol>>=
if(s->macro) {
    newio();
    cp = ionext->b;
    macexpand(s, cp);
    pushio();

    ionext->link = iostack;
    iostack = ionext;

    fi.p = cp;
    fi.c = strlen(cp);
    if(peekc != IGN) {
        cp[fi.c++] = peekc;
        cp[fi.c] = 0;
        peekc = IGN;
    }
    goto l0;
}
@
% abuse newio()? it's not really a new file here

% wow, complicated too
<<function macexpand>>=
void
macexpand(Sym *s, char *b)
{
    char buf[2000];
    int n, l, c, nargs;
    char *arg[NARG], *cp, *ob, *ecp, dots;

    ob = b;
    if(*s->macro == 0) {
        strcpy(b, s->macro+1);
        if(debug['m'])
            print("#expand %s %s\n", s->name, ob);
        return;
    }
    
    nargs = (char)(*s->macro & ~VARMAC) - 1;
    dots = *s->macro & VARMAC;

    c = getnsc();
    if(c != '(')
        goto bad;
    n = 0;
    c = getc();
    if(c != ')') {
        unget(c);
        l = 0;
        cp = buf;
        ecp = cp + sizeof(buf)-4;
        arg[n++] = cp;
        for(;;) {
            if(cp >= ecp)
                goto toobig;
            c = getc();
            if(c == '"')
                for(;;) {
                    if(cp >= ecp)
                        goto toobig;
                    *cp++ = c;
                    c = getc();
                    if(c == '\\') {
                        *cp++ = c;
                        c = getc();
                        continue;
                    }
                    if(c == '\n')
                        goto bad;
                    if(c == '"')
                        break;
                }
            if(c == '\'')
                for(;;) {
                    if(cp >= ecp)
                        goto toobig;
                    *cp++ = c;
                    c = getc();
                    if(c == '\\') {
                        *cp++ = c;
                        c = getc();
                        continue;
                    }
                    if(c == '\n')
                        goto bad;
                    if(c == '\'')
                        break;
                }
            if(c == '/') {
                c = getc();
                switch(c) {
                case '*':
                    for(;;) {
                        c = getc();
                        if(c == '*') {
                            c = getc();
                            if(c == '/')
                                break;
                        }
                    }
                    *cp++ = ' ';
                    continue;
                case '/':
                    while((c = getc()) != '\n')
                        ;
                    break;
                default:
                    unget(c);
                    c = '/';
                }
            }
            if(l == 0) {
                if(c == ',') {
                    if(n == nargs && dots) {
                        *cp++ = ',';
                        continue;
                    }
                    *cp++ = 0;
                    arg[n++] = cp;
                    if(n > nargs)
                        break;
                    continue;
                }
                if(c == ')')
                    break;
            }
            if(c == '\n')
                c = ' ';
            *cp++ = c;
            if(c == '(')
                l++;
            if(c == ')')
                l--;
        }
        *cp = 0;
    }
    if(n != nargs) {
        yyerror("argument mismatch expanding: %s", s->name);
        *b = 0;
        return;
    }
    cp = s->macro+1;
    for(;;) {
        c = *cp++;
        if(c == '\n')
            c = ' ';
        if(c != '#') {
            *b++ = c;
            if(c == 0)
                break;
            continue;
        }
        c = *cp++;
        if(c == 0)
            goto bad;
        if(c == '#') {
            *b++ = c;
            continue;
        }
        c -= 'a';
        if(c < 0 || c >= n)
            continue;
        strcpy(b, arg[c]);
        b += strlen(arg[c]);
    }
    *b = 0;
    if(debug['m'])
        print("#expand %s %s\n", s->name, ob);
    return;

bad:
    yyerror("syntax in macro expansion: %s", s->name);
    *b = 0;
    return;

toobig:
    yyerror("too much text in macro expansion: %s", s->name);
    *b = 0;
}
@
% wow complicated again

\section{[[#undef]]}

<<function macund>>=
void
macund(void)
{
    Sym *s;

    s = getsym();
    macend();
    if(s == S) {
        yyerror("syntax in #undef");
        return;
    }
    s->macro = nil;
}
@

\section{[[#ifdef]]}

% 0 = ifdef, 1 = ifndef, 2 = else, see mactab and domacro
<<function macif>>=
void
macif(int f)
{
    int c, l;
    bool bol;
    Sym *s;

    if(f == 2)
        goto skip;
    s = getsym();
    if(s == S)
        goto bad;
    if(getcom() != '\n')
        goto bad;
    if((s->macro != nil) ^ f)
        return;

skip:
    bol = true;
    l = 0;
    for(;;) {
        c = getc();
        if(c != '#') {
            if(!isspace(c))
                bol = false;
            if(c == '\n')
                bol = true;
            continue;
        }
        if(!bol)
            continue;
        s = getsym();
        if(s == S)
            continue;
        if(strcmp(s->name, "endif") == 0) {
            if(l) {
                l--;
                continue;
            }
            macend();
            return;
        }
        if(strcmp(s->name, "ifdef") == 0 || strcmp(s->name, "ifndef") == 0) {
            l++;
            continue;
        }
        if(l == 0 && f != 2 && strcmp(s->name, "else") == 0) {
            macend();
            return;
        }
    }

bad:
    yyerror("syntax in #if(n)def");
    macend();
}
@

\section{[[#pragma]]}

% effect of #pragma lib in .s ??

<<function macprag>>=
void
macprag(void)
{
    Sym *s;
    int c0, c;
    char *hp;
    Hist *h;

    s = getsym();

    if(s && strcmp(s->name, "lib") == 0) {
        c0 = getnsc();
        if(c0 != '"') {
            c = c0;
            if(c0 != '<')
                goto bad;
            c0 = '>';
        }
        for(hp = symb;;) {
            c = getc();
            if(c == c0)
                break;
            if(c == '\n')
                goto bad;
            *hp++ = c;
        }
        *hp = '\0';
        c = getcom();
        if(c != '\n')
            goto bad;
    
        /*
         * put pragma-line in as a funny history 
         */
        c = strlen(symb) + 1;
        while(c & 3)
            c++;
    
        hp = malloc(c);
        memcpy(hp, symb, c);
    
        h = alloc(sizeof(Hist));
        h->filename = hp;
        h->line = lineno;
        h->local_line = -1;

        h->link = H;
        if(ehist == H) {
            hist = h;
            ehist = h;
            return;
        }
        ehist->link = h;
        ehist = h;

        return;

bad:
        unget(c);
        yyerror("syntax in #pragma lib");
        macend();

    } else {
        while(getnsc() != '\n')
            ;
        return;
    }
}
@


% most pragma seems to be discarded here, except #pragma lib, so
% I removed then (could have aslo simplified by calling prag_do_nothing()).
% it is because the code was shared with cc before I think and the compilers
% had different pragxxx functions with an actual body.
%
%    if(s && strcmp(s->name, "pack") == 0) {
%        pragpack();
%        return;
%    }
%    if(s && strcmp(s->name, "fpround") == 0) {
%        pragfpround();
%        return;
%    }
%    if(s && strcmp(s->name, "profile") == 0) {
%        pragprofile();
%        return;
%    }
%    if(s && strcmp(s->name, "varargck") == 0) {
%        pragvararg();
%        return;
%    }
%    if(s && strcmp(s->name, "incomplete") == 0) {
%        pragincomplete();
%        return;
%    }
%
%old:
%<<function pragpack>>=
%void
%pragpack(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@
%
%<<function pragvararg>>=
%void
%pragvararg(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@
%
%<<function pragfpround>>=
%void
%pragfpround(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@
%
%<<function pragprofile>>=
%void
%pragprofile(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@
%
%<<function pragincomplete>>=
%void
%pragincomplete(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@


\section{[[#line]]}

<<function maclin>>=
void
maclin(void)
{
    char *cp;
    int c;
    long n;

    n = getnsn();
    c = getc();
    if(n < 0)
        goto bad;

    for(;;) {
        if(c == ' ' || c == '\t') {
            c = getc();
            continue;
        }
        if(c == '"')
            break;
        if(c == '\n') {
            strcpy(symb, "<noname>");
            goto nn;
        }
        goto bad;
    }
    cp = symb;
    for(;;) {
        c = getc();
        if(c == '"')
            break;
        *cp++ = c;
    }
    *cp = 0;
    c = getcom();
    if(c != '\n')
        goto bad;

nn:
    c = strlen(symb) + 1;
    while(c & 3)
        c++;

    cp = malloc(c);
    memcpy(cp, symb, c);

    linehist(cp, n);
    return;

bad:
    unget(c);
    yyerror("syntax in #line");
    macend();
}
@

% could move with the other getxxx()
<<function getnsn>>=
long
getnsn(void)
{
    long n;
    int c;

    c = getnsc();
    if(c < '0' || c > '9')
        return -1;
    n = 0;
    while(c >= '0' && c <= '9') {
        n = n*10 + c-'0';
        c = getc();
    }
    unget(c);
    return n;
}
@



\chapter{Parsing}

\section{Overview}

% assume understand yacc! if not read classic book on lex&yacc
%  or docs/doc/unix/yacc.pdf (or read CompilerGenerator.nw :) )

% actually not context free, parsing a file modify the kind
% of some tokens, e.g. labels, lval.

<<5a/a.y>>=
%{
#include "a.h"
%}
<<union token(arm)>>
<<priority and associativity declarations>>
<<token declarations(arm)>>
<<type declarations(arm)>>
%%
<<grammar(arm)>>
@
%$


% have seen token declaration in Core Data structures already.


<<grammar(arm)>>=
prog:
  /* empty */
| prog line

<<line rule(arm)>>
<<inst rule(arm)>>
<<cond rule(arm)>>
<<operand rules(arm)>>
<<helper rules(arm)>>
<<constant expression rules>>
<<float rules>>
<<opt rules>>
<<misc rules>>
@

% assembly file is made of lines containing instructions or labels.
% instructions are mostly a single opcode with 0, 1, 2 or 3 operands
% where each operand can be a register, or constant, or address, etc.
% and some combination (like register + constant offset)

% there are some special opcodes like TEXT which don't translate
% in binary code but are useful for ? (symbol resolving?)
% They are called pseudo-opcodes.


<<line rule(arm)>>=
line:
  inst ';'
@


% note that newline are translated in ';' by the lexer
% so can either pack in one line with ';' or use newline
% (haskell spirit :) )


<<line rule(arm)>>=
| ';'
| error ';'
@
% error? yacc trick for synchronization? to got until next ; (that is newline)?

\section{Instructions}

% similar sub sections than in Machine.nw

\subsection{Arithmetic}

\subsubsection{Logic}

<<logic opcodes>>=
AAND,
AORR,
AEOR,
@
%note: not exactly the ARM order, I prefer to put closer AAND and AORR for
% instance
%compiler: need logic for many things, complex if conditions. booleans!
% also useful for bit level operations (bitsets, bit extraction, bit mask)
% (and actually most things can be encoded with just NAND!)
% how NOT?

<<[[itab]] elements>>=
"AND",		LTYPE1,	AAND,
"ORR",		LTYPE1,	AORR,
"EOR",		LTYPE1,	AEOR,
@


<<inst rule(arm)>>=
inst:
/*
 * AND/OR/ADD/SUB/...
 */
  LTYPE1 cond imsr ',' spreg ',' reg { outcode($1, $2, &$3, $5, &$7); }
| LTYPE1 cond imsr ',' spreg ','     { outcode($1, $2, &$3, $5, &nullgen); }
| LTYPE1 cond imsr ',' reg           { outcode($1, $2, &$3, R_NONE, &$5); }
@
%$
% arith operator of Machine.nw, but also SLL, SRL,   DIV, MOD, ...

% ADD X1, X2, X3, imsr = immediate or shift (will see later) or register 
% e.g. ADD 10, R1, R2 (code 3 addresses, well 3 registers).

% cond will be explained also later, ARM specificities.

% outcode() =~ pc++
% take 5 arguments, opcode, cond, op1, op2, op3.
% op2 is always a register or nothing

% (in ARM each instruction have same length, so doing pc++ 
%  is easy, but for variable-sized archi like x86, the assembler
%  actually does just pc++ because the pc in 8a/ is a virtual pc)


\subsubsection{Add/sub}

<<add/sub opcodes>>=
AADD,
ASUB,
@
%compiler: need add/sub for arithmetic obviously, so numeric algorithms,
% but need arithmetic for lots of 
% things, including access to more complex data structures like
% fields of struct (need add offset to a base)

<<[[itab]] elements>>=
"ADD",		LTYPE1,	AADD,
"SUB",		LTYPE1,	ASUB,
@




\ifallcode
<<logic opcodes>>=
ABIC,
@
<<add/sub opcodes>>=
ARSB,
AADC,
ASBC,
ARSC,
@
<<[[itab]] elements>>=
"BIC",		LTYPE1,	ABIC,
"RSB",		LTYPE1,	ARSB,
"ADC",		LTYPE1,	AADC,
"SBC",		LTYPE1,	ASBC,
"RSC",		LTYPE1,	ARSC,
@
\fi




% see also Comparison section, part of Arith opcode
% in Machine.nw, as well as simple MOV


\subsubsection{Bit shift}

<<bitshift opcodes>>=
ASRL,
ASRA,
ASLL,
@
% virtual/fake opcodes? transformed in something using shift?
%compiler: used in this file actually :) also useful for
% multiplication optimisation (when power of 2)

<<[[itab]] elements>>=
"SLL",		LTYPE1,	ASLL,
"SRL",		LTYPE1,	ASRL,
"SRA",		LTYPE1,	ASRA,
@

\subsubsection{Mul/div/mod}

<<mul/div/mod opcodes>>=
AMUL,
ADIV,
AMOD,
@
% ARM has no ADIV or AMOD so virtual/fake-opcode again?
% compiler: need also mul for array access, need base + idx * size of entry.
%  for pointer arithmetic in general!

<<[[itab]] elements>>=
"MUL",		LTYPE1, AMUL,
"DIV",		LTYPE1,	ADIV,
"MOD",		LTYPE1,	AMOD,
@



\subsubsection{Comparison}
%note: was actually part of arithmetic in Machine.nw so
% kinda make sense to put it here too, though
% it has some logic too to put it just before branching

<<comparison opcodes>>=
ATST,
ATEQ,
ACMP,
@
%compiler: if, while, they all need to compare values
% and they need to act on it (see also branching)
%todo: (but why 3 different tests? one not enough?)

<<[[itab]] elements>>=
"CMP",		LTYPE7,	ACMP,
"TST",		LTYPE7,	ATST,
"TEQ",		LTYPE7,	ATEQ,
@


<<inst rule(arm)>>=
/*
 * CMP
 */
| LTYPE7 cond imsr ',' spreg { outcode($1, $2, &$3, $5, &nullgen); }
@
%$

\ifallcode
<<comparison opcodes>>=
ACMN,
@
% CMP negative
<<[[itab]] elements>>=
"CMN",		LTYPE7,	ACMN,
@
\fi


\subsection{Memory}

% actually ARM has load/store, but plan9 has MOV as a virtual/fake-opcode,
% more powerful, can do e.g. MOVW R2, (R3) !
% with the load/store of ARM it would be: LOAD R3, R4; store R2, R4 ?

<<mov opcodes>>=
AMOVW,
@
% compiler: machine is von newman model, memory is everything.
% store simple data(int), complex (aggregate), store results, 
% store pointers! need powerful memory assign.

<<mov opcodes>>=
AMOVB,
AMOVBU,
AMOVH,
AMOVHU,
@


<<[[itab]] elements>>=
"MOVW",		LTYPE3, AMOVW,
"MOVB",		LTYPE3, AMOVB,
"MOVBU",	LTYPE3, AMOVBU,
"MOVH",		LTYPE3, AMOVH,
"MOVHU",	LTYPE3, AMOVHU,
@


<<inst rule(arm)>>=
/*
 * MOVW
 */
| LTYPE3 cond gen ',' gen { outcode($1, $2, &$3, R_NONE, &$5); }
@
% special instr? the real one accept any gen? no real one are just load/store
% with registers.
% gen for general?




\ifallcode
% optional? not used a single time in arm/*.s, used a bit in 5c/
<<mov opcodes>>=
AMVN,
@
% MOV negative
%//AMOV, redundant with the other MOV operations
<<[[itab]] elements>>=
"MVN",		LTYPE2, AMVN,	/* op2 ignored */
@
<<inst rule(arm)>>=
/*
 * MVN
 */
| LTYPE2 cond imsr ',' reg { outcode($1, $2, &$3, R_NONE, &$5); }
@
\fi




%\subsubsection{Swap}
%\subsection{Special}
% mv in advanced topics? or merge with memory section? Like
% I did for Machine.nw?

<<swap opcodes>>=
ASWPW,
ASWPBU,
@
% used in _tas so maybe a special system-like instruction?

<<[[itab]] elements>>=
"SWPW",		LTYPE9, ASWPW,
"SWPBU",	LTYPE9, ASWPBU,
@

<<inst rule(arm)>>=
/*
 * SWAP
 */
| LTYPE9 cond reg ',' ireg ',' reg { outcode($1, $2, &$5, $3.reg, &$7); }
| LTYPE9 cond reg ',' ireg         { outcode($1, $2, &$5, $3.reg, &$3); }
| LTYPE9 cond ireg ',' reg         { outcode($1, $2, &$3, $5.reg, &$5); }
@
%$



\subsection{Branch}
% rename control flow?
% could split in two, with B and then BL and RET?
% called JMP/CALL in 8a

<<branching opcodes>>=
AB,
ABL,
@
% compiler: if, while, for, switch, they all rely on the
% very basic building block of jmp, conditional or not (goto xxx, if(yyy))

% BL is ARM specific opti for CALL to leaf functions. Branch and Link.

<<[[itab]] elements>>=
"B",		LTYPE4, AB,
"BL",		LTYPE4, ABL,
@


<<inst rule(arm)>>=
/*
 * B/BL
 */
| LTYPE4 cond rel   { outcode($1, $2, &nullgen, R_NONE, &$3); }
| LTYPE4 cond nireg { outcode($1, $2, &nullgen, R_NONE, &$3); }
@

% B of name? of TEXT or label? both?
% in 'rel' it's just label! so BL foo_ret_lbl (and D_BRANCH)
% in 'nireg' it's name so it can be BL foo+0(SB) (and D_OREG)

%less: comma rel? comma useful? could probably rewrite the
% few assembly instruction that uses this bad syntax

<<branching opcodes>>=
/* 
 * Do not reorder or fragment the conditional branch 
 * opcodes, or the predication code will break 
 */ 
// AB derivatives with condition code, see 5i/
ABEQ,
ABNE,
ABCS,//not in 5i/cond, seems equivalent to ABHS
ABHS,
ABCC,//not in 5i/cond, seems equivalent to ABLO
ABLO,
ABMI,
ABPL,
ABVS,
ABVC,
ABHI,
ABLS,
ABGE,
ABLT,
ABGT,
ABLE,
//ABAL? (always) done via AB, ABNV (never) done via ANOP probably
@
%less: get rid ABCS and ABCC, seems redundant
% and does not match the ARM convention

<<[[itab]] elements>>=
"BEQ",		LTYPE5,	ABEQ,
"BNE",		LTYPE5,	ABNE,
"BCS",		LTYPE5,	ABCS,
"BHS",		LTYPE5,	ABHS,
"BCC",		LTYPE5,	ABCC,
"BLO",		LTYPE5,	ABLO,
"BMI",		LTYPE5,	ABMI,
"BPL",		LTYPE5,	ABPL,
"BVS",		LTYPE5,	ABVS,
"BVC",		LTYPE5,	ABVC,
"BHI",		LTYPE5,	ABHI,
"BLS",		LTYPE5,	ABLS,
"BGE",		LTYPE5,	ABGE,
"BLT",		LTYPE5,	ABLT,
"BGT",		LTYPE5,	ABGT,
"BLE",		LTYPE5,	ABLE,
@

<<inst rule(arm)>>=
/*
 * BEQ/...
 */
| LTYPE5 rel { outcode($1, Always, &nullgen, R_NONE, &$2); }
@




<<branching opcodes>>=
ARET,
@
% actually no RET in ARM, so virtual/fake-opcode
% (works with BL?)

<<[[itab]] elements>>=
"RET",		LTYPEA, ARET,
@

<<inst rule(arm)>>=
/*
 * RET
 */
| LTYPEA cond { outcode($1, $2, &nullgen, R_NONE, &nullgen); }
@
% because of B and BL (and as we will see in 5l STEXT and SLEAF),
% it's convenient to have a general way to return from a procedure
% whether it was a leaf or not. The machine can handle the specifics for us!

\subsection{Software interrupt}
% software interrupt, aka syscall

<<interrupt opcodes>>=
ASWI, // syscall
@
% kernel/user! fundamental API of assembly! the bridge!
% open then the door for user process to access real hardware
% (but in supervised mode of course)

<<[[itab]] elements>>=
"SWI",		LTYPE6, ASWI,
@

<<inst rule(arm)>>=
/*
 * SWI
 */
| LTYPE6 cond { outcode($1, $2, &nullgen, R_NONE, &nullgen); }
@
%$
%old: | LTYPE6 cond comma gen { outcode($1, $2, &nullgen, R_NONE, &$4); }
% but not sure it needs an argument in plan9 context,
% and anyway was doing stupid things like SWI 0  in 9syscall/mkfile
% which was weird, at least should be SWI $0



\section{Conditional execution}

% seen most opcodes have this LTYPExxx cond op1, op2, ...

<<type declarations(arm)>>=
%type   <lval>  cond
@

<<cond rule(arm)>>=
cond:
  /* empty */ { $$ = Always; }
| cond LCOND  { $$ = ($1 & ~C_SCOND) | $2; }
@

<<constant C_SCOND(arm)>>=
/* scond byte */
#define	C_SCOND	((1<<4)-1)
@


<<[[itab]] elements>>=
".EQ",		LCOND,	0,
".NE",		LCOND,	1,
".CS",		LCOND,	2,
".HS",		LCOND,	2,
".CC",		LCOND,	3,
".LO",		LCOND,	3,
".MI",		LCOND,	4,
".PL",		LCOND,	5,
".VS",		LCOND,	6,
".VC",		LCOND,	7,
".HI",		LCOND,	8,
".LS",		LCOND,	9,
".GE",		LCOND,	10,
".LT",		LCOND,	11,
".GT",		LCOND,	12,
".LE",		LCOND,	13,
".AL",		LCOND,	Always,
@
%//Never = 15

% so BEQ is really B.EQ, but can also have MOV.EQ! ADD.LT, etc.

<<constant Always(arm)>>=
#define    Always 14
@
%less: use COND_ALWAYS now?

\section{Special bits}
% sign? long? p bit, w bit, ???

<<cond rule(arm)>>=
| cond LS    { $$ = $1 | $2; }
@

<<[[itab]] elements>>=
".U",		LS,	C_UBIT,
".S",		LS,	C_SBIT,
".W",		LS,	C_WBIT,
".P",		LS,	C_PBIT,
@
% .S can be used for arithmetic operations, to set condition code

<<constant C_SBIT(arm)>>=
#define	C_SBIT	(1<<4)
@

<<constant C_PBIT(arm)>>=
#define	C_PBIT	(1<<5)
@

<<constant C_WBIT(arm)>>=
#define	C_WBIT	(1<<6)
@

<<constant C_UBIT(arm)>>=
#define	C_UBIT	(1<<7)	/* up bit */
@


% composite
<<[[itab]] elements>>=
".PW",		LS,	C_WBIT|C_PBIT,
".WP",		LS,	C_WBIT|C_PBIT,
@

% composite or alternate form
<<[[itab]] elements>>=
".IBW",		LS,	C_WBIT|C_PBIT|C_UBIT,
".IAW",		LS,	C_WBIT|C_UBIT,
".DBW",		LS,	C_WBIT|C_PBIT,
".DAW",		LS,	C_WBIT,

".IB",		LS,	C_PBIT|C_UBIT,
".IA",		LS,	C_UBIT,
".DB",		LS,	C_PBIT,
".DA",		LS,	0,
@
% some seems redundant like .DB and .P, .U and .IA, etc

% see asm.ps ARM section: "addressing modes are supported by suffixes
% of the instruction, IA = increment after, IB = increment before, ..."
% it can be used only with the MOV instruction

<<constant C_FBIT(arm)>>=
#define	C_FBIT	(1<<7)	/* psr flags-only */
@


<<[[itab]] elements>>=
".F",		LS,	C_FBIT,
@


\section{Operand}

% this is the rest from the %union
<<[[Token]] other fields(arm)>>=
Gen    gen;
@
% hmmm maybe confusing to have gen field and Gen type and gen grammar rule?

% reg = register
% imm = immediate
% shift = shifted register or constant

% imsr = immediate or shift or register

<<type declarations(arm)>>=
%type   <gen> imsr
@

% e.g. for first operand of ADD
<<operand rules(arm)>>=
imsr:
  reg
| imm
| shift
@

<<type declarations(arm)>>=
%type   <gen> reg imm shift
@


% better to put gen rule here instead of rule about memory dereference.
% That matches closely at first imsr with reg, ximm and shift.



<<type declarations(arm)>>=
%type   <gen>   gen 
@
% gen? general? 
% arguments to MOV have less restrictions


\ifallcode
<<operand rules(arm)>>=
<<gen rule>>
@
<<misc rules>>=
<<oreg rule>>
@
<<operand rules(arm)>>=
<<ximm rule>>
@
\fi


<<gen rule>>=
gen:
  reg
| ximm
| shift
@
% so close to imsr. close except ximm instead of imm (extended immediate).
% see below.
% and also will see later than the gen rule will grow

<<type declarations(arm)>>=
%type   <gen>   ximm
@



\subsection{Registers}

<<operand_kind cases>>=
D_REG,
@
% works with Gen structure, as shown below

<<operand rules(arm)>>=
reg:
 spreg
 {
  $$ = nullgen;
  $$.type = D_REG;
  $$.reg = $1;
 }
@
%$

% lval but really enum<registr>
<<type declarations(arm)>>=
%type   <lval>  sreg spreg 
@


<<operand rules(arm)>>=
sreg:
  LREG
| LR '(' expr ')'
 {
  if($3 < 0 || $3 >= NREG)
      print("register value out of range\n");
  $$ = $3;
 }
| LPC { $$ = REGPC; }
@
%$
% why 2 rules? anyway people can use R12 to encode LSP so why
% not have a simple reg rule that allows all those registers directly?

<<operand rules(arm)>>=
spreg:
  sreg
| LSP { $$ = REGSP; }
@
%$
% why another one again? in which context we don't accept LSP?
% and also in which context we don't accept LPC?

<<[[itab]] elements>>=
"R0",		LREG,	0,
"R1",		LREG,	1,
"R2",		LREG,	2,
"R3",		LREG,	3,
"R4",		LREG,	4,
"R5",		LREG,	5,
"R6",		LREG,	6,
"R7",		LREG,	7,
"R8",		LREG,	8,
"R9",		LREG,	9,
"R10",		LREG,	10,
"R11",		LREG,	11,
"R12",		LREG,	12,
"R13",		LREG,	13,
"R14",		LREG,	14,
"R15",		LREG,	15,
@

<<[[itab]] elements>>=
"R",		LR,	0,
@



\subsection{Constants}

% con = constant
% prefix with $ (why? ambiguity with what?) to differentiate
% with just con where it's a omem (see section below)

<<operand_kind cases>>=
D_CONST,
@

<<operand rules(arm)>>=
imm: '$' con
 {
  $$ = nullgen;
  $$.type = D_CONST;
  $$.offset = $2;
 }
@
% offset is bad field name. maybe a union with value would be nice.

% see con section below, essentially static-time integer constants
% (not float, not string)

% float constants are in another category, actually they
% are allowed only for ximm and so for MOV and DATA categories.



% this is used for MOV of course, because of gen, but also
% for DATA, WORD
<<ximm rule>>=
ximm:
  '$' con
 {
  $$ = nullgen;
  $$.type = D_CONST;
  $$.offset = $2;
 }
@
% see later the extension, MOV allows more forms of constants
% (e.g. string constants, float constants)

\subsection{Shift registers}
% register and constant in some sense

<<operand_kind cases>>=
D_SHIFT,
@

<<operand rules(arm)>>=
shift:
 spreg '<' '<' rcon
 {
  $$ = nullgen;
  $$.type = D_SHIFT;
  $$.offset = $1 | $4 | (0 << 5);
 }
| spreg '>' '>' rcon
 {
  $$ = nullgen;
  $$.type = D_SHIFT;
  $$.offset = $1 | $4 | (1 << 5);
 }
| spreg '-' '>' rcon
 {
  $$ = nullgen;
  $$.type = D_SHIFT;
  $$.offset = $1 | $4 | (2 << 5);
 }
| spreg LAT '>' rcon
 {
  $$ = nullgen;
  $$.type = D_SHIFT;
  $$.offset = $1 | $4 | (3 << 5);
 }
@

<<[[itab]] elements>>=
"@",		LAT,	0,
@
% hmm could remove @ from the identifier lexing section,
% so then could just do '@' '>' instead of this indirection


<<type declarations(arm)>>=
%type   <lval>  rcon
@

% rcon, register or constant, spreg = sp or general register
<<helper rules(arm)>>=
rcon:
  spreg
 {
  if($$ < 0 || $$ >= NREG)
      print("register value out of range\n");
  $$ = (($1&15) << 8) | (1 << 4);
 }
| con
 {
  if($$ < 0 || $$ >= 32)
      print("shift value out of range\n");
  $$ = ($1&31) << 7;
 }
@
% really does too much work here and close to ARM concrete bits

\subsection{Memory (de)references, pointers}
% was "Memory references"
% arguments to MOVW
% Pointers? or Memory dereference actually? or both :)

% O_REG = offset reg?
<<operand_kind cases>>=
D_OREG,
@
% when do MOV R1, (R2) => means in cell pointer by R2, so
% it's really like *r2 = r1


% start of difference with imsr!
<<gen rule>>=
| oreg
@

<<type declarations(arm)>>=
%type   <gen> oreg ioreg ireg nireg 
@

% oreg? offset reg? 
<<oreg rule>>=
oreg:
  ioreg
@

% indirect or offset reg
<<misc rules>>=
ioreg:
  ireg
| con '(' sreg ')'
 {
  $$ = nullgen;
  $$.type = D_OREG;
  $$.reg = $3;
  $$.offset = $1;
 }
@


% ireg? indirect reg? 
% used from ioreg (and so gen), and also specifically from SWAP
<<misc rules>>=
ireg:
 '(' spreg ')'
 {
  $$ = nullgen;
  $$.type = D_OREG;
  $$.reg = $2;
  $$.offset = 0;
 }
@
%$




\subsection{Named memory location}
% (different from labels, which are just for code refs)


% part of oreg? name is an offset to a reg?
% Actually a name is really a constant offset to a base like LSB!!
% it's implicitly a dereference so foo is really (foo), you want
% $foo to get the actual address (and not content)
<<oreg rule>>=
| name
@

% for BL, in addition to rel, can also have nireg
<<misc rules>>=
nireg:
  name
| ireg
@
%$
%old: had a if with nothing in it, weird
%  name
% {
%  $$ = $1;
%  if($1.name != D_EXTERN && $1.name != D_STATIC) {
%  }
% }






<<type declarations(arm)>>=
%type   <gen>   name 
%type   <lval>  pointer
@
% name is an operand argument for BL (via nireg), but also
% for TEXT, and also for MOV (via oreg)

\ifallcode
<<operand rules(arm)>>=
<<name rule>>
@
\fi


<<name rule>>=
name:
  LNAME offset '(' pointer ')'
 {
  $$ = nullgen;
  $$.type = D_OREG;
  $$.sym = $1;
  $$.symkind = $4;
  $$.offset = $2;
 }
@
%$

% for TEXT foo(SB), ... or GLOBL. Definitions of names.
% and also for references to names, like MOV count(SB), R1
% (to get address of count? no, to get address you need $count(SB))
% no LLAB here!

% (ab)used also in reference to parameters, as in
% MOVL    count+8(FP), CX
% the LNAME here is really just a symbol for debugging help


% the con (pointer) of 'name:' is not ambiguous with the con (sreg)
% of 'oreg:'? no because pointer != sreg (well even if R12 is actually
% LSB ...)

% hmmm bad name? pointer_basis? but it's true we do '(' pointer ')'
% where we really dereference the pointer (and then add an offset)
<<helper rules(arm)>>=
pointer:
  LSB
| LSP
| LFP
@

<<[[itab]] elements>>=
"SB",		LSB,	D_EXTERN,
"SP",		LSP,	D_AUTO,
"FP",		LFP,	D_PARAM,
@


% can do 
%	BL	div(SB)  so it's SB but it's really a code reference

<<sym_kind cases>>=
D_EXTERN, // data/bss values (from SB)
D_AUTO,   // stack values (from SP)
D_PARAM,  // parameter (from FP)
@
% use A_EXTERN? or N_EXTERN?
%/* name */ for D_EXTERN


<<helper rules(arm)>>=
offset:
 /* empty */ { $$ = 0; }
| '+' con    { $$ = $2; }
| '-' con    { $$ = -$2; }
@
%$
%less: rename offset_opt?


<<name rule>>=
| LNAME '<' '>' offset '(' LSB ')'
 {
  $$ = nullgen;
  $$.type = D_OREG;
  $$.sym = $1;
  $$.symkind = D_STATIC;
  $$.offset = $4;
 }
@
%$

<<sym_kind cases>>=
D_STATIC, // data static variables (from SB)
@

% well this is not really a name ...
<<name rule>>=
| con '(' pointer ')'
 {
  $$ = nullgen;
  $$.type = D_OREG;
  $$.sym = S;
  $$.symkind = $3;
  $$.offset = $1;
 }
@
%$
% could delete that too? hmm no, it's for anonymous params like 4(FP)




<<ximm rule>>=
| '$' name
 {
  $$ = $2;
  $$.type = D_CONST;
 }
@
% was $ oreg, but i think it makes more sense to have just '$' name
% could simplify to $name? maybe could be better to have
% a special D_ADDR? instead of abusing D_CONST?
% it's to get the address of name?

% a bit confusing that can have gen -> oreg, and also gen -> ximm -> $ oreg
% because MOV support powerful addressing modes? with multiple
% indirections?


\subsection{Code references and labels}
% hmm con(PC) is not really named code

<<operand_kind cases>>=
D_BRANCH,
@
%/* type */ FOR BRANCH


<<[[itab]] elements>>=
"PC",		LPC,	D_BRANCH,
@

<<type declarations(arm)>>=
%type   <gen>   rel
%type   <lval>  offset
@

% rel = ? relocatable? relative?, argument of B/BL
% Relative because it's labels which are locals to a file and can be
% resolved locally (no need symbols), but at the same time they will
% also need to be relocated when all objects are attached after each
% other
% (and the offset value is actually not relative to the current PC,
% it's an absolute value, so it probably means more relocatable than
% relative in the end)

\ifallcode
<<operand rules(arm)>>=
<<rel rule>>
@
\fi

<<rel rule>>=
rel:
  LLAB offset
 {
  $$ = nullgen;
  $$.type = D_BRANCH;
  $$.sym = $1;
  $$.offset = $1->value + $2;
 }
@
%$
% branch are relative to current PC for ARM, but here
% we deal with more absolute address.

% it's an offset in the sense that it's like a 'LLAB offset (starting_pc)'
% so offset to basis, which should be zero for this assembly
% (and when link will actually be relocated).

% there is also nirel where can use a name instead of a label


% when label is declared later, the symbol table does not know
% yet that it's an LLABL, see section on labels below.
<<rel rule>>=
| LNAME offset
 {
  $$ = nullgen;
  if(pass == 2)
      yyerror("undefined label: %s", $1->name);
  $$.type = D_BRANCH;
  $$.sym = $1;
  $$.offset = $2;
 }
@
%less: if pass == 1 why care about setting the field values?
% anyway outcode will not use the value


<<rel rule>>=
| con '(' LPC ')'
 {
  $$ = nullgen;
  $$.type = D_BRANCH;
  $$.offset = $1 + pc;
 }
@
%$
% need that? we have code using relative jmp?
% anyway if do  B 4(PC) it will jump one instruction?



\subsection{Status register}

% status register, works with MOV but normally it's a special
% ARM load/store instructions: MSR and MRS (here emulated by a single MOV)
% CPSR = ? SPSR = ?
<<[[itab]] elements>>=
"CPSR",		LPSR,	0,
"SPSR",		LPSR,	1,
@
% CPSR is maybe system status register, see l.s where
% do
%	MOVW	$(PsrDirq|PsrDfiq|PsrMsvc), R1
%	MOVW	R1, CPSR


<<operand_kind cases>>=
D_PSR,
@
% similar to D_REG really, just with special register, so reg field
% is enum<registr> | enum<status_registr>

<<gen rule>>=
| LPSR
 {
  $$ = nullgen;
  $$.type = D_PSR;
  $$.reg = $1;
 }
@
%$
% Status register? move earlier? 

\subsection{String constants}
%\subsection{Other forms}

<<operand_kind cases>>=
D_SCONST,
@
% string constant


<<ximm rule>>=
| '$' LSCONST
 {
  $$ = nullgen;
  $$.type = D_SCONST;
  memcpy($$.sval, $2, sizeof($$.sval));
 }
@


%<<operand_kind cases>>=
%D_OCONST,
%@
%<<ximm rule>>=
%| '$' '*' '$' oreg
% {
%  $$ = $4;
%  $$.type = D_OCONST;
% }
%@
%%$
% seems unused in ARM/*.s


%<<gen rule>>=
%| con
% {
%  $$ = nullgen;
%  $$.type = D_OREG;
%  $$.offset = $1;
% }
%@
%%$
% no $ in front of con here?
% was used in 9syscall for 'SWI 0' but not sure what it meant.
% how can be D_OREG when there are no registers involved.
% I removed the rule, and rewrote calls to SWI to just be SWI

%<<gen rule>>=
%| shift '(' spreg ')'
% {
%  $$ = $1;
%  $$.reg = $3;
% }
%@

%<<oreg rule>>=
%| name '(' sreg ')'
% {
%  $$ = $1;
%  $$.type = D_OREG;
%  $$.reg = $3;
% }
%@
% but name already has some (sreg), so what this rule mean?
% foo(PC)(PC) ??
% sreg, so can't use FP here, nor LSB, so only name refering to PC?




\section{Label definitions and [[pc]]}

% this is incremented in outcode() after each instruction 
% (except for ADATA and AGLOBL)
% less: even ATEXT increments PC? hmm maybe simpler that way
<<global pc>>=
long	pc;
@

<<line rule(arm)>>=
| LNAME ':'
 {
  $1->type = LLAB;
  $1->value = pc;
 }
  line
@

<<line rule(arm)>>=
| LLAB ':'
 {
  if($1->value != pc)
   yyerror("redeclaration of %s", $1->name);
  $1->value = pc;
 }
  line
@
%$

% note that labels are different from ATEXT! they are local
% to the file, and so lead to local jmps. no need to relocate
% those names.

\section{Pseudo instructions}

\subsection{[[TEXT/GLOBL]]}

% declare symbols, names

<<pseudo opcodes>>=
ATEXT,
AGLOBL,
@

<<[[itab]] elements>>=
"TEXT",		LTYPEB, ATEXT,
"GLOBL",	LTYPEB, AGLOBL,
@

<<inst rule(arm)>>=
/*
 * TEXT/GLOBL
 */
| LTYPEB name ',' imm         { outcode($1, Always, &$2, R_NONE, &$4); }
| LTYPEB name ',' con ',' imm { outcode($1, Always, &$2, $4, &$6); }
@
%$

% TEXT is for procedures, code symbols, that will go in the TEXT section
% GLOBL is to declare data symbols (globals indeed), that will go in DATA sect

% TEXT foo, 4, $4 ??? semantic for those immediate value? to? size
% of entity in the case of GLOBL?

% if look qemu.root.s from data2c result:
% e.g. 
% DATA boot_CONF_outcode+0(SB)/8, $"\z\z\1\353\z\z\213\33"
% ...
% DATA boot_CONF_outcode+67520(SB)/8, $"\1\201\1\z\z\z\z\z"
% GLOBL boot_CONF_outcode+0(SB), $67528
% DATA boot_CONF_outlen+0(SB)/4, $67523
% GLOBL boot_CONF_outlen+0(SB), $4

\subsection{[[WORD/DATA]]}

<<pseudo opcodes>>=
ADATA,
AWORD,
@

<<[[itab]] elements>>=
"DATA",		LTYPEC, ADATA,
"WORD",		LTYPEH, AWORD,
@

<<inst rule(arm)>>=
/*
 * DATA
 */
| LTYPEC name '/' con ',' ximm { outcode($1, Always, &$2, $4, &$6); }
@

% DATA boot_CONF_outlen+0(SB)/4, $67523
% DATA boot_CONF_outcode+0(SB)/8, $"\z\z\1\353\z\z\213\33"
% hmm abuse reg for this constant, ugly

<<inst rule(arm)>>=
/*
 * WORD
 */
| LTYPEH ximm { outcode($1, Always, &nullgen, R_NONE, &$2); }
@
% kind of anonymous DATA? but used in TEXT so can
% write binary data that cannot be expressed by the assembler?



\subsection{[[END]]}

<<pseudo opcodes>>=
AEND,
@

<<[[itab]] elements>>=
"END",		LTYPEE, AEND,
@

<<inst rule(arm)>>=
/*
 * END
 */
| LTYPEE { outcode($1, Always, &nullgen, R_NONE, &nullgen); }
@
%$
% also generated in cclean()

%\section{Special instructions}
%\subsection{[[NOP]]}
%\subsection{[[SHL/SHR]]}
%\subsection{[[MOVW/MOVL]]}
%\subsection{[[IMUL]]}

\section{Variables}
% useful? cpp can do that too


<<line rule(arm)>>=
| LNAME '=' expr ';'
 {
  $1->type = LVAR;
  $1->value = $3;
 }
| LVAR '=' expr ';'
 {
  if($1->value != $3)
   yyerror("redeclaration of %s", $1->name);
  $1->value = $3;
 }
@

\section{Constant expressions}

% it's not Fortran, we're making an assembler :)
% so it's constant expressions here!

<<type declarations(arm)>>=
%type   <lval>  con expr 
@

<<priority and associativity declarations>>=
%left   '|'
%left   '^'
%left   '&'
%left   '<' '>'
%left   '+' '-'
%left   '*' '/' '%'
@
% lower in the file = higher priority, earlier = lower priority

<<constant expression rules>>=
con:
  LCONST
| LVAR         { $$ = $1->value; }
| '-' con      { $$ = -$2; }
| '+' con      { $$ = $2; }
| '~' con      { $$ = ~$2; }
| '(' expr ')' { $$ = $2; }

expr:
  con
| expr '+' expr     { $$ = $1 + $3; }
| expr '-' expr     { $$ = $1 - $3; }
| expr '*' expr     { $$ = $1 * $3; }
| expr '/' expr     { $$ = $1 / $3; }
| expr '%' expr     { $$ = $1 % $3; }
| expr '<' '<' expr { $$ = $1 << $4; }
| expr '>' '>' expr { $$ = $1 >> $4; }
| expr '&' expr     { $$ = $1 & $3; }
| expr '^' expr     { $$ = $1 ^ $3; }
| expr '|' expr     { $$ = $1 | $3; }

@

% convenient to have this, when combined with macros it
% can do powerful stuff!

\ifallcode
\section{Optional commas}
% the optional ',' why? because asm can ge generated by 5c -S that does
% this. A bit ugly so maybe better to aspectize this.
% actually I removed most of the use of comma for 5a/a.y 
% so maybe could even remove this rule, or keep it
% just for the comment about 5c -S.

<<opt rules>>=
comma:
  /* empty */
| ',' comma
@
\fi

\section{[[yyparse()]]}

% essentially generated code by yacc, that is calling yylex


%\chapter{Output}
%\chapter{Name resolution}

\chapter{Object Generation}

% it's object generation, not machine code generation ... 5l/optab.c does this.

% Note also that we must output code that will be part of a bigger set.
% An object is really a module, defining symbols and using external symbols.
% So the code we output can be relocated! so need to 
% output information about use of external symbols! 'U'
% (and also information about symbols the module defines! 'T', 'D')

\section{Object format}

% The format is very regular, essentially a list of instructions
% where each instruction is encoded as:
%  - opcode (1 byte)
%  - condition (1 byte)
%  - register (1 byte) (most instrs have at least one register operand)
%  - line  (4 bytes)
%  - operand1
%  - operand2
%  where the operands depending on the operand_kind can actually have
%  different size. The register above is a kind of operand3.
%
% the operands themselves have a specific format too
%  - operand_kind (D_CONST, D_REG, etc)
%  - register (again) if any
%  - symidx if any (for D_OREG, and also D_CONST (but really D_ADDR))
%  - symkind if any (for the same)
%  - variable size data, nothing for D_REG, offset for D_OREG, 
%    float for D_FLOAT, string for D_SCONST, ...

%TODO: figure!!

% Then spreaded among those instructions are also symbol table
% entries, using a weird scheme
% ANAME: symkind (1 byte), ?? (1 byte), '<', string finished by \0
% (hmm the symkind might be redundant then if it's already listed
%  as part of the operand?)

% the header is really just a set of ANAME and AHISTORY, and
% AHISTORY just the same format than other instructions.

% 5l then read back this format in a simple loop reading one
% instruction at a time and maintaing the symbol table information
% via the ANAME.

\section{Instruction output, [[outcode()]]}

% used for all opcodes, even pseudo opcodes.
% very generic form, 3 operands (but many times they
% are equivalent to a None).

% scond is cond bits and also special bits
% less: rename reg to reg3? so less confusing with reg in zaddr?
<<function outcode(arm)>>=
void
outcode(int opcode, int scond,  Gen *g1, int reg, Gen *g2)
{
    <<[[outcode()]] locals>>

    <<[[outcode()]] adjust opcode and scond when opcode is AB>>

    if(pass == 1)
        goto out;

    <<[[outcode()]] st and sf computation, and possible calls to zname>>

    // Instruction serialized format: opcode, cond, optional reg, line, operands
    Bputc(&obuf, opcode);
    Bputc(&obuf, scond);
    Bputc(&obuf, reg);
    Bputc(&obuf, lineno);
    Bputc(&obuf, lineno>>8);
    Bputc(&obuf, lineno>>16);
    Bputc(&obuf, lineno>>24);
    zaddr(g1, sf);
    zaddr(g2, st);

out:
    if(opcode != AGLOBL && opcode != ADATA)
        pc++;
}
@
% skip pc++ for AGLOBL and ADATA because those pseudo ops concern
% the DATA section, not the TEXT section.
% WORD is for the TEXT section too!
%note: I renamed a to opcode

% note that output line number here! useful for debugging information,
% to be ablt to go back from one instruction to the actual code!
% (but lineno after #include expansion, see outhist() section
% later so one can get from lineno to actual file+lineno


<<[[outcode()]] adjust opcode and scond when opcode is AB>>=
/* hack to make B.NE etc. work: turn it into the corresponding conditional*/
if(opcode == AB){
    opcode = bcode[scond&0xf];
    scond = (scond & ~0xf) | Always;
}
@
% so B.NE get translated in BNE. Not that important though,
% again this feature could be removed.

<<global bcode(arm)>>=
static int bcode[] =
{
    ABEQ,
    ABNE,
    ABCS,
    ABCC,
    ABMI,
    ABPL,
    ABVS,
    ABVC,
    ABHI,
    ABLS,
    ABGE,
    ABLT,
    ABGT,
    ABLE,
    AB,
    ANOP,
};
@



\section{Operand output, [[zaddr()]]}

% outcode -> <>
% less: rename? out_operand?
% s is index in h[] for symbol involved in the operand?
% or 0 if no symbol involved for this operand?
<<function zaddr(arm)>>=
void
zaddr(Gen *a, int symidx)
{
    <<[[zaddr()]] locals>>

    // operand format: operand kind, register, symidx, symlink, optional offset
    Bputc(&obuf, a->type);
    Bputc(&obuf, a->reg);
    // idx in symbol table, 0 if no symbol involved in the operand
    Bputc(&obuf, symidx);
    // symkind of the symbol, if any
    Bputc(&obuf, a->symkind);

    switch(a->type) {
    <<[[zaddr()]] cases>>
    default:
        print("unknown type %d\n", a->type);
        exits("arg");

    }
}
@

\ifallcode
<<[[zaddr()]] locals>>=
long l;
char *n;
Ieee e;
int i;
@
\fi

<<[[zaddr()]] cases>>=
case D_NONE:
case D_REG:
case D_PSR:
    break;

case D_CONST:
case D_OREG:
case D_BRANCH:
case D_SHIFT:
    l = a->offset;
    Bputc(&obuf, l);
    Bputc(&obuf, l>>8);
    Bputc(&obuf, l>>16);
    Bputc(&obuf, l>>24);
    break;

case D_SCONST:
    n = a->sval;
    for(i=0; i<NSNAME; i++) {
        Bputc(&obuf, *n);
        n++;
    }
    break;
@


\section{Symbol table, [[h]] and [[ANAME]]}
%note: we could put Htab in Core DS, h is reset in pinit(), but it's
% really just local to the Output code generation so I think
% it is better to put this DS here I think.

% When an operand involves a symbol, the generated operand code 
% contain an int that is an index in a symbol table! See zaddr().

% the way this symbol table is stored in the object file is a bit
% tricky. They could have put the table at the beginning
% of the file (I think it would have been simpler). Instead
% the symbol table is spreaded in the object file and they use
% a circular array scheme.


% so among all those instructions there are some symbol table
% elements, ANAME.

<<pseudo opcodes>>=
ANAME,
@
% could be renamed ASYM

%old: if ANAME is after AHISTORY in 5.out.h then got
% some bugs in ar such as "inconsistent file xxx.5 in libc.a"
%update: maybe it was because the Makefile pb where actually
% libmach was not recompiled?

% outcode -> <>
% for operands involving symbols.
% less: rename? out_symbol_reference?
<<function zname(arm)>>=
void
zname(char *n, int symkind, int symidx)
{

    Bputc(&obuf, ANAME);
    Bputc(&obuf, symkind);	/* type */
    Bputc(&obuf, symidx);	/* sym */
    while(*n) {
        Bputc(&obuf, *n);
        n++;
    }
    Bputc(&obuf, '\0');
}
@
% note that labels do not generate code, they are local to the .o
% and used to compute offsets (pc). TEXT generate symbols defs
% and some opcodes generate symbol references.

% symidx may seem weird, why need idx if store the symbol entries
% one after the other?





<<struct Htab>>=
struct Htab
{
    // ref<Sym>>
    Sym*	sym;
    //enum<sym_kind>
    short	symkind;
};
@
%old: I rename 'type' to symkind, to avoid confusion with Gen.type.
% Htab is a sliced subset of Sym but just for the symbols 
% (and an array insteaf of a hash)

<<constant NSYM>>=
#define	NSYM	50
@
% limit on number of unresolved external symbols? Nope.
% note: need to be < 256 as currently use Bputc to marshall 
%  symbol indexes in zaddr().


% starts to be used at index 1, as 0 is used as index for none symbol.
<<global h>>=
// array<ref<Sym>>
struct Htab h[NSYM];
@
% why call it h when really it's an array ...

% h is an optimisation to avoid generating too many ANAME? But
% why not a symbol table at the beginning of the file?


% next free entry in h (actually can be reseted to 1)
<<global symcounter>>=
int	symcounter;
@
%less: why not char instead? like symidx (or better byte)
%old: was called sym, but I renamed it to avoid overloading the sym name
% (as a global, as a field)

<<[[Sym]] other fields>>=
// index in h when the Sym is really a symbol, 0 when not a symbol
int	symidx;
@
%old: was called 'sym', but really it's an index in h, and it was confusing
% to have so many fields called sym already (as well as the global sym)
% char enough??
%old: was char, but in many places they use int for symcounter so I use int
% there too now


<<[[pinit]] symcounter and h initialisation>>=
symcounter = 1;
for(i=0; i<NSYM; i++) {
    h[i].symkind = 0; // N_NONE
    h[i].sym = S;
}
@






<<[[outcode()]] locals>>=
// symbol from, index in h[]
int sf;
// symbol to, index in h[]
int st;
// enum<sym_kind>
int symkind;
Sym *s;
@


% TODO LP split and transform while into if, easier flow
% and also can maybe factorize code?
<<[[outcode()]] st and sf computation, and possible calls to zname>>=
jackpot:
sf = 0;
s = g1->sym;

while(s != S) {
    sf = s->symidx;

    if(sf < 0 || sf >= NSYM)
        sf = 0;

    symkind = g1->symkind;

    // already generated an ANAME for this symbol reference
    if(h[sf].symkind == symkind)
     if(h[sf].sym == s)
        break;

    s->symidx = symcounter;
    h[symcounter].sym = s;
    h[symcounter].symkind = symkind;
    sf = symcounter;
    zname(s->name, symkind, symcounter);

    symcounter++;
    if(symcounter >= NSYM)
        symcounter = 1;
    break;
}

st = 0;
s = g2->sym;

while(s != S) {
    st = s->symidx;

    if(st < 0 || st >= NSYM)
        st = 0;

    symkind = g2->symkind;

    if(h[st].symkind == symkind)
      if(h[st].sym == s)
        break;

    s->symidx = symcounter;
    h[symcounter].sym = s;
    h[symcounter].symkind = symkind;
    st = symcounter;
    zname(s->name, symkind, symcounter);

    symcounter++;
    if(symcounter >= NSYM)
        symcounter = 1;

    if(st == sf)
        goto jackpot;
    break;
}
@
% when jackpot can happen? 
% if the first operand involved for instance a symbol with for index 41
% and that the second operand involves a symbol not
% yet seen and that the next free index turns out to be 41, 
% then h[41].sym will change but sf now points to a wrong entry
% and so you have to recompute sf.
% this is very very suble (too subtle I think).

% replace by:
%sf = symidx_of_symopt(g1->sym);
%st = symidx_of_symopt(g2->sym);
% if (sf == st && sf != 0 && symcounter actually changed) goto jackpot;
%  (otherwise could loop on MOVW bar(SB), bar(SB)

\section{File and line information, [[outhist()]] and [[AHISTORY]]}
%note: was called Header section, but 
% it's not really an header in traditional sense,
% the object could be parsed without those AHISTORY and ANAME I think.
%less: have a Debugging support section? where put lineno of outcode()
% there?

<<pseudo opcodes>>=
AHISTORY,
@
% history? because trace history of a line if comes from some #include?

% maybe good to take simplest case where have no #include,
% then what will be the output?


<<sym_kind cases>>=
D_FILE,
@




% main -> assemble -> <> (at begining of pass 2)
<<function outhist(arm)>>=
void
outhist(void)
{
    Gen g;
    Hist *h;
    char *p, *op;
    char *q;
    int n;

    g = nullgen;
    for(h = hist; h != H; h = h->link) {
        p = h->filename;

        <<[[outhist()]] adjust p and op if p is relative filename>>
        <<[[outhist()]] output each path component as an ANAME>>
        g.offset = h->local_line;

        Bputc(&obuf, AHISTORY);
        Bputc(&obuf, Always);
        Bputc(&obuf, 0); // reg, but could be R_NONE actually
        Bputc(&obuf, h->line);
        Bputc(&obuf, h->line>>8);
        Bputc(&obuf, h->line>>16);
        Bputc(&obuf, h->line>>24);
        zaddr(&nullgen, 0);
        zaddr(&g, 0);
    }
}
@
% bug???? g.offset is used? do zaddr(&g, 0) but g.type = D_NONE
% at this point which means the offset will not be used.
% look at linker reading back code, excpect a D_CONST here?
% this code works for 8a, but not for 5a because zaddr() is
% different there.

% remember that output lineno for each instruction!

<<[[outhist()]] adjust p and op if p is relative filename>>=
op = nil;
if(p && p[0] != '/' && h->local_line == 0 && pathname){
    if(pathname[0] == '/'){
        op = p;
        p = pathname;
    }
}
@

<<[[outhist()]] output each path component as an ANAME>>=
while(p) {
    q = strchr(p, '/');
    if(q) {
        n = q-p;
        if(n == 0){
            n = 1;	/* leading "/" */
            *p = '/';
        }
        q++;
    } else {
        n = strlen(p);
        q = nil;
    }

    if(n) {
        Bputc(&obuf, ANAME);
        Bputc(&obuf, D_FILE);	/* type */ // symkind
        Bputc(&obuf, 1);	/* sym */ //symidx
        Bputc(&obuf, '<');
        Bwrite(&obuf, p, n);
        Bputc(&obuf, '\0');
    }
    p = q;
    if(p == nil && op) {
        p = op;
        op = nil;
    }
}
@
% why print each directory path separately?

\chapter{Advanced Topics}

\section{Long multiplication instructions}

%\subsubsection{Mul long}
% advanced topics? so can also put D_REGREG later?

<<mul/div/mod opcodes>>=
AMULL,
AMULAL,
AMULLU,
AMULALU,
@

<<[[itab]] elements>>=
"MULL",		LTYPEM, AMULL,
"MULAL",	LTYPEM, AMULAL,
"MULLU",	LTYPEM, AMULLU,
"MULALU",	LTYPEM, AMULALU,
@



% MULL special instruction?
<<inst rule(arm)>>=
/*
 * MULL hi,lo,r1,r2
 */
| LTYPEM cond reg ',' reg ',' regreg { outcode($1, $2, &$3, $5.reg, &$7); }
@
%$
% ugly $5.reg?

% multiply and accumulate
<<mul/div/mod opcodes>>=
AMULA,
@

<<[[itab]] elements>>=
"MULA",		LTYPEN, AMULA,
@

<<operand_kind cases>>=
D_REGREG,
@

<<inst rule(arm)>>=
/*
 * MULA hi,lo,r1,r2
 */
| LTYPEN cond reg ',' reg ',' reg ',' spreg 
 {
  $7.type = D_REGREG;
  $7.offset = $9;
  outcode($1, $2, &$3, $5.reg, &$7);
 }
@
%$
% abuse offset, ADT would be better!




<<type declarations(arm)>>=
%type   <gen>   regreg
@

<<operand rules(arm)>>=
/* for MULL */
regreg:
 '(' spreg ',' spreg ')'
 {
  $$ = nullgen;
  $$.type = D_REGREG;
  $$.reg = $2;
  $$.offset = $4;
 }
@
% abuse offset again ... grrr



<<[[zaddr()]] cases>>=
case D_REGREG:
    Bputc(&obuf, a->offset);
    break;
@

\section{Float instructions}

<<float mov opcodes>>=
AMOVWD,
AMOVWF,
AMOVDW,
AMOVFW,
AMOVFD,
AMOVDF,
AMOVF,
AMOVD,
@

<<float arithmetic opcodes>>=
ACMPF,
ACMPD,
AADDF,
AADDD,
ASUBF,
ASUBD,
AMULF,
AMULD,
ADIVF,
ADIVD,
ASQRTF,
ASQRTD,
@

<<[[itab]] elements>>=
"MOVD",		LTYPE3, AMOVD,
"MOVDF",	LTYPE3, AMOVDF,
"MOVDW",	LTYPE3, AMOVDW,
"MOVF",		LTYPE3, AMOVF,
"MOVFD",	LTYPE3, AMOVFD,
"MOVFW",	LTYPE3, AMOVFW,
"MOVWD",	LTYPE3, AMOVWD,
"MOVWF",	LTYPE3, AMOVWF,
@

<<[[itab]] elements>>=
"SQRTF",	LTYPEI, ASQRTF,
"SQRTD",	LTYPEI, ASQRTD,
"CMPF",		LTYPEL, ACMPF,
"CMPD",		LTYPEL, ACMPD,
"ADDF",		LTYPEK,	AADDF,
"ADDD",		LTYPEK,	AADDD,
"SUBF",		LTYPEK,	ASUBF,
"SUBD",		LTYPEK,	ASUBD,
"MULF",		LTYPEK,	AMULF,
"MULD",		LTYPEK,	AMULD,
"DIVF",		LTYPEK,	ADIVF,
"DIVD",		LTYPEK,	ADIVD,
@

%/*
%    "ABSF",		LTYPEI, AABSF,
%    "ABSD",		LTYPEI, AABSD,
%    "NEGF",		LTYPEI, ANEGF,
%    "NEGD",		LTYPEI, ANEGD,
%    "SQTF",		LTYPEI,	ASQTF,
%    "SQTD",		LTYPEI,	ASQTD,
%    "RNDF",		LTYPEI,	ARNDF,
%    "RNDD",		LTYPEI,	ARNDD,
%    "URDF",		LTYPEI,	AURDF,
%    "URDD",		LTYPEI,	AURDD,
%    "NRMF",		LTYPEI,	ANRMF,
%    "NRMD",		LTYPEI,	ANRMD,
%*/




<<[[itab]] elements>>=
"F",		LF,	0,

"F0",		LFREG,	0,
"F1",		LFREG,	1,
"F2",		LFREG,	2,
"F3",		LFREG,	3,
"F4",		LFREG,	4,
"F5",		LFREG,	5,
"F6",		LFREG,	6,
"F7",		LFREG,	7,
"F8",		LFREG,	8,
"F9",		LFREG,	9,
"F10",		LFREG,	10,
"F11",		LFREG,	11,
"F12",		LFREG,	12,
"F13",		LFREG,	13,
"F14",		LFREG,	14,
"F15",		LFREG,	15,
@


<<[[itab]] elements>>=
"FPSR",		LFCR,	0,
"FPCR",		LFCR,	1,
@


<<constant FREGRET(arm)>>=
#define	FREGRET		0
@
<<constant FREGEXT(arm)>>=
#define	FREGEXT		7
@
<<constant FREGTMP(arm)>>=
#define	FREGTMP		15
@

% used by 5c/ in char	reg[NREG+NFREG];
<<constant NFREG(arm)>>=
#define	NFREG		8
@
% 8? looks like 16 above



<<inst rule(arm)>>=
/*
 * floating-point coprocessor
 */
| LTYPEI cond freg ',' freg { outcode($1, $2, &$3, R_NONE, &$5); }
| LTYPEK cond frcon ',' freg { outcode($1, $2, &$3, R_NONE, &$5); }
| LTYPEK cond frcon ',' LFREG ',' freg { outcode($1, $2, &$3, $5, &$7); }
| LTYPEL cond freg ',' freg { outcode($1, $2, &$3, $5.reg, &nullgen); }
@
%$


<<operand_kind cases>>=
D_FREG,
D_FCONST,
D_FPCR,
@
% FPCR is the float pending of D_PSR?

<<[[zaddr()]] cases>>=
case D_FREG:
case D_FPCR:
    break;
@

<<[[zaddr()]] cases>>=
case D_FCONST:
    ieeedtod(&e, a->dval);
    Bputc(&obuf, e.l);
    Bputc(&obuf, e.l>>8);
    Bputc(&obuf, e.l>>16);
    Bputc(&obuf, e.l>>24);
    Bputc(&obuf, e.h);
    Bputc(&obuf, e.h>>8);
    Bputc(&obuf, e.h>>16);
    Bputc(&obuf, e.h>>24);
    break;
@
% >> >> >> >> >> >> >> >> >>

<<type declarations(arm)>>=
%type <gen> freg fcon frcon
@

% for MOV
<<gen rule>>=
| freg
@

<<ximm rule>>=
| fcon
@

<<float rules>>=
freg:
  LFREG
 {
  $$ = nullgen;
  $$.type = D_FREG;
  $$.reg = $1;
 }
| LF '(' con ')'
 {
  $$ = nullgen;
  $$.type = D_FREG;
  $$.reg = $3;
 }

fcon:
 '$' LFCONST
 {
  $$ = nullgen;
  $$.type = D_FCONST;
  $$.dval = $2;
 }
| '$' '-' LFCONST
 {
  $$ = nullgen;
  $$.type = D_FCONST;
  $$.dval = -$3;
 }

frcon:
  freg
| fcon
@
%$



<<gen rule>>=
| LFCR
 {
  $$ = nullgen;
  $$.type = D_FPCR;
  $$.reg = $1;
 }
@
%$



<<struct ieee>>=
struct	ieee
{
    long	l;	/* contains ls-man	0xffffffff */
    long	h;	/* contains sign	0x80000000
                    exp		0x7ff00000
                    ms-man	0x000fffff */
};
@

% ?? -> <>
<<function ieeedtod>>=
void
ieeedtod(Ieee *ieee, double native)
{
    double fr, ho, f;
    int exp;

    if(native < 0) {
        ieeedtod(ieee, -native);
        ieee->h |= 0x80000000L;
        return;
    }
    if(native == 0) {
        ieee->l = 0;
        ieee->h = 0;
        return;
    }
    fr = frexp(native, &exp);
    f = 2097152L;		/* shouldnt use fp constants here */
    fr = modf(fr*f, &ho);
    ieee->h = ho;
    ieee->h &= 0xfffffL;
    ieee->h |= (exp+1022L) << 20;
    f = 65536L;
    fr = modf(fr*f, &ho);
    ieee->l = ho;
    ieee->l <<= 16;
    ieee->l |= (long)(fr*f);
}
@

<<constant FPCHIP(arm)>>=
#define	FPCHIP		true
@
% used only by a small if(FPCHIP) in cinit

\section{Multiple registers instructions}

% move many?
<<mov opcodes>>=
AMOVM,
@

<<[[itab]] elements>>=
"MOVM",		LTYPE8, AMOVM,
@
%in lproc.s 
%	RFE				/* MOVM.IA.S.W (R13), [R15] */

%todo: abuse D_CONST again, why not D_MULTI instead?

<<inst rule(arm)>>=
/*
 * MOVM
 */
| LTYPE8 cond ioreg ',' '[' reglist ']'
 {
  Gen g;

  g = nullgen;
  g.type = D_CONST;
  g.offset = $6;
  outcode($1, $2, &$3, R_NONE, &g);
 }
| LTYPE8 cond '[' reglist ']' ',' ioreg
 {
  Gen g;

  g = nullgen;
  g.type = D_CONST;
  g.offset = $4;
  outcode($1, $2, &g, R_NONE, &$7);
 }
@


<<type declarations(arm)>>=
%type   <lval>  reglist
@


<<misc rules>>=
reglist:
  spreg           { $$ = 1 << $1; }
| spreg '-' spreg
 {
  int i;
  $$=0;
  for(i=$1; i<=$3; i++)
      $$ |= 1<<i;
  for(i=$3; i<=$1; i++)
      $$ |= 1<<i;
 }
| spreg comma reglist { $$ = (1<<$1) | $3; }
@
%$



%\section{Misc instructions}

% seems dead
%<<misc opcodes>>=
%ABX, // ?
%ABXRET, // ?
%@
%<<[[itab]] elements>>=
%"BX",		LTYPEBX,	ABX,
%@
%<<inst rule(arm)>>=
%/*
% * BX
% */
%| LTYPEBX comma ireg { outcode($1, Always, &nullgen, R_NONE, &$3); }
%@

%dead: ADWORD, // ? no reading syntax

% have reading syntax, but not transformed by 5l ... not handled,
%<<misc opcodes>>=
%ALDREX,
%ASTREX,
%ALDREXD,
%ASTREXD,
%@
%% LDREX STREX CLREX are arm v7 new instruction according to 5db.c
%% actually they are defined as macros in atom.s:
%%#define	CLREX		WORD	$0xf57ff01f
%%#define	LDREX(a,r)	WORD	$(0xe<<28|0x01900f9f | (a)<<16 | (r)<<12)
%%/* `The order of operands is from left to right in dataflow order' - asm man */
%%#define	STREX(v,a,r)	WORD	$(0xe<<28|0x01800f90 | (a)<<16 | (r)<<12 | (v)<<0)
%
%<<[[itab]] elements>>=
%"LDREX",		LTYPE3, ALDREX,
%"LDREXD",		LTYPE3, ALDREXD,
%"STREX",		LTYPE9, ASTREX,
%"STREXD",		LTYPE9, ASTREXD,
%@

\section{System instructions}

% no Axxx opcode, binary generation directly in action via D_CONST
<<[[itab]] elements>>=
"MCR",		LTYPEJ, 0,
"MRC",		LTYPEJ, 1,
@

<<inst rule(arm)>>=
/*
 * MCR MRC
 */
| LTYPEJ cond con ',' expr ',' spreg ',' creg ',' creg oexpr
 {
  Gen g;

  g = nullgen;
  g.type = D_CONST;
  g.offset =
   (0xe << 24) |    /* opcode */
   ($1 << 20) |     /* MCR/MRC */
   ($2 << 28) |     /* scond */
   (($3 & 15) << 8) |   /* coprocessor number */
   (($5 & 7) << 21) |   /* coprocessor operation */
   (($7 & 15) << 12) |  /* arm register */
   (($9 & 15) << 16) |  /* Crn */
   (($11 & 15) << 0) |  /* Crm */
   (($12 & 7) << 5) |   /* coprocessor information */
   (1<<4);          /* must be set */ // opcode component
  outcode(AWORD, Always, &nullgen, R_NONE, &g);
 }
@
% >> >> >> >> >> >> >> >> >> >>

<<type declarations(arm)>>=
%type   <lval>  creg
@

<<misc rules>>=
creg:
  LCREG
| LC '(' expr ')'
 {
  if($3 < 0 || $3 >= NREG)
      print("register value out of range\n");
  $$ = $3;
 }
@
%$

<<[[itab]] elements>>=
"C",		LC,	0,

"C0",		LCREG,	0,
"C1",		LCREG,	1,
"C2",		LCREG,	2,
"C3",		LCREG,	3,
"C4",		LCREG,	4,
"C5",		LCREG,	5,
"C6",		LCREG,	6,
"C7",		LCREG,	7,
"C8",		LCREG,	8,
"C9",		LCREG,	9,
"C10",		LCREG,	10,
"C11",		LCREG,	11,
"C12",		LCREG,	12,
"C13",		LCREG,	13,
"C14",		LCREG,	14,
"C15",		LCREG,	15,
@


<<type declarations(arm)>>=
%type   <lval>  oexpr 
@

% other optional stuff
<<opt rules>>=
/* for MCR */ 
oexpr:
  /* empty */ { $$ = 0; }
| ',' expr    { $$ = $2; }
@
%$



<<misc opcodes>>=
ARFE, // ?? return from exn?
@

<<[[itab]] elements>>=
"RFE",		LTYPEA, ARFE,
@
% same grammar rule than RET



\section{Compiler-only pseudo opcodes}

% some of those are not really opcodes, they are entities 
% just at the asm AST level produced internally by 5c.
% they have no reading syntax.

% related to NOP, SHL, MOV, pseudo asm
% that get translated in store/load on some archi.


% only used by 5c
<<pseudo opcodes>>=
ACASE,
ABCASE,
@
% BCASE = branch case

% actually they used to have a read syntax, but I didn't see any code
% using them so I commented the code.
%<<[[itab]] elements>>=
%"CASE",		LTYPED, ACASE,
%"BCASE",	LTYPE5,	ABCASE,
%@
%<<inst rule(arm)>>=
%/*
% * CASE
% */
%| LTYPED cond reg comma { outcode($1, $2, &$3, R_NONE, &nullgen); }
%@
%$


<<mul/div/mod opcodes>>=
AMULU,
ADIVU,
AMODU,
@
% has no reading syntax, generated just in 5c

<<pseudo opcodes>>=
ASIGNAME,
@
% for signatures checking I think, generated just in 5c
% really an extended ANAME with signature information


% not pseudo opcodes but related to compile-only opcodes. Here are other 
% constants defined in 5.out.h that are used only
% in compiler context.
% for 5c! conventions! (not used at all by 5a, but in 5.out.h for other tools)
<<[[regxxx]] compiler conventions cases>>=
REGRET =	0,
REGARG =	0,
/* compiler allocates R1 up as temps */
/* compiler allocates register variables R2 up */
REGMIN =	2,
REGMAX =	8,

REGEXT =	10,
/* compiler allocates external registers R10 down */
REGTMP =	11,
@
% hmm regxxx is not really an enum as REGREG = REGARG, but still useful.

%old:    /* used by the loader for thumb code */
%    REGTMPT =		7,
% no REGFP??

\section{Linker-only pseudo opcodes}

<<pseudo opcodes>>=
AGOK,
@
% GOK =? God only Knows? speciak mark?
% actually used in both compiler and linker
% but I think it's used only for zprg, and in ldobj it's an error
% so maybe we could delete it, and just use AXXX or ALAST or ANOP instead.
%old: there was a D_GOK, but it was unused in 5a/5c/5l

<<pseudo opcodes>>=
ADYNT,
AINIT,
@
% seems never assigned, maybe not used anymore?

%again not an opcode, but related (where this bit is stored??)
% used by 5l (to allow override existing symbol? 5l option?)
%I think it's for TEXT and DATA instructions and its reg field
% (that should be unused for TEXT and DATA)
<<constant DUPOK(arm)>>=
#define DUPOK		(1<<1)
@

% less: transform in an enum with DUPOK
% note that it's not used by 5a, used by 5c/5l when have a special #pragma
<<constant NOPROF(arm)>>=
#define NOPROF		(1<<0)
@

% related to linker again, in addition to D_FILE there is:
<<sym_kind cases>>=
D_FILE1, // used by linker only?
@

%dead: #define	ALLTHUMBS	(1<<2)

\section{[[#pragma lib]] and automagic linking}

% this is very very nice! remove so much headache,
% no need ocamlfind, no need pkg-config, so simple ...

% but useful in assembly?

\section{Processing multiple files}

% why need that? people can write mkfiles

<<[[main()]] locals>>=
int nout, nproc, status;
int i, c;
@

<<[[main()]] multiple files handling>>=
if(argc > 1) {
    nproc = 1;
    if(p = getenv("NPROC"))
        nproc = atol(p);	/* */
    c = 0;
    nout = 0;
    for(;;) {
        while(nout < nproc && argc > 0) {
            i = fork();
            if(i < 0) {
                i = mywait(&status);
                if(i < 0)
                    errorexit();
                if(status)
                    c++;
                nout--;
                continue;
            }
            if(i == 0) {
                print("%s:\n", *argv);
                if(assemble(*argv))
                    errorexit();
                exits(0);
            }
            nout++;
            argc--;
            argv++;
        }
        i = mywait(&status);
        if(i < 0) {
            if(c)
                errorexit();
            exits(0);
        }
        if(status)
            c++;
        nout--;
    }
}
@

%\section{Thumb code}
% arg processing: (but then no more generic across 5a/ and 8a/)
%
%    case 't':
%        thechar = 't';
%        thestring = "thumb";
%        break;

\chapter{Conclusion}







\appendix

\chapter{Debugging}
% not very powerful debugging options for 5a, mostly stuff
% to debug cpp related issues.
% 5l has more stuff, with dumpers for Gen, opcode, etc.

% ex: 'm', 'f' (256 so can have for each character a boolean value)
<<global debug>>=
bool	debug[256];
@

<<[[main()]] debug initialization>>=
memset(debug, false, sizeof(debug));
@

<<[[main()]] command line processing>>=
default:
    c = ARGC();
    if(c >= 0 || c < sizeof(debug))
        debug[c] = true;
    break;
@

\section{[[5a -m]], macro debugging}
% m for macro

<<[[dodefine()]] debug>>=
if(debug['m'])
    print("#define (-D) %s %s\n", s->name, s->macro+1);
@

<<[[macdef()]] debug>>=
if(debug['m'])
    print("#define %s %s\n", s->name, s->macro+1);
@

\section{[[5a -f]], line information debugging}

<<[[linehist()]] debug>>=
if(debug['f'])
    if(f) {
        if(local_line)
            print("%4ld: %s (#line %d)\n", lineno, f, local_line);
        else
            print("%4ld: %s\n", lineno, f);
    } else
        print("%4ld: <pop>\n", lineno);
@

\chapter{Error Managment}

<<function errorexit>>=
void
errorexit(void)
{

    if(outfile)
        remove(outfile);
    exits("error");
}
@

<<global nerrors>>=
int	nerrors = 0;
@
% used to be initialized in cinit()

<<function yyerror>>=
void
yyerror(char *a, ...)
{
    char buf[200];
    va_list arg;

    /*
     * hack to intercept message from yaccpar
     */
    if(strcmp(a, "syntax error") == 0) {
        yyerror("syntax error, last name: %s", symb);
        return;
    }

    prfile(lineno);

    va_start(arg, a);
    vseprint(buf, buf+sizeof(buf), a, arg);
    va_end(arg);

    print("%s\n", buf);
    nerrors++;
    if(nerrors > 10) {
        print("too many errors\n");
        errorexit();
    }
}
@



\chapter{Libc}

\section{Memory managment}

% same in Linker, not sure why they just don't use malloc?
% to avoid dependencies to libc? for bootstrapping reasons?

<<global hunk>>=
char*	hunk;
@

<<global nhunk>>=
long	nhunk = 0;
@
% used to be set in cinit()

<<global thunk>>=
long	thunk;
@

<<constant NHUNK>>=
#define	NHUNK		10000
@


<<function gethunk>>=
void
gethunk(void)
{
    char *h;
    long nh;

    nh = NHUNK;
    if(thunk >= 10L*NHUNK)
        nh = 10L*NHUNK;

    h = (char*)sbrk(nh);
    if(h == (char*)-1) {
        yyerror("out of memory");
        errorexit();
    }
    hunk = h;
    nhunk = nh;
    thunk += nh;
}
@



<<constant MAXALIGN>>=
#define MAXALIGN 7
@

<<function alloc>>=
/*
 * real allocs
 */
void*
alloc(long n)
{
    void *p;

    while((uintptr)hunk & MAXALIGN) {
        hunk++;
        nhunk--;
    }

    while(nhunk < n)
        gethunk();
    p = hunk;
    nhunk -= n;
    hunk += n;

    return p;
}
@

<<function allocn>>=
void*
allocn(void *p, long on, long n)
{
    void *q;

    q = (uchar*)p + on;
    if(q != hunk || nhunk < n) {

        while(nhunk < on+n)
            gethunk();
        memmove(hunk, p, on);
        p = hunk;
        hunk += on;
        nhunk -= on;

    }
    hunk += n;
    nhunk -= n;
    return p;
}
@


\chapter{Extra Code}

\ifallcode
#include "Assembler_extra.nw"
#include "Assembler_x86.nw"
\fi

\chapter{Changelog}
\label{sec:changelog}

\chapter{Glossary}
\label{sec:glossary}

\begin{verbatim}
ISA Instruction Set Architecture
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{section}{Index}

%\chapter{References} 
\addcontentsline{toc}{section}{References}

\begin{thebibliography}{99}

\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming}, 
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb}, 
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison}, 
\url{http://padator.org/software/project-syncweb/readme.txt}

\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
