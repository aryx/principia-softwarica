\section{x86}

%https://github.com/intelxed/xed

% see my assembler in ml I wrote a long time ago! in xix-assembler/?

% x86 has many many different addressing modes. 
% Actually I think 8a allows even
% more than what is allowed (optab handles the ugly restrictions
% of Intel?)


%TODO: reorder to have first a set of mostly useful instructions
% e.g. MOV, MOVB, etc. Could maybe analyze *.s in plan9 and do some
% stats? or use cg on the whole plan9 and see how much AXXX is used
% hmmm but can reorder? the opcode generation rely on an order? or 
% just 'ld' and 'as' need to agree with each other; the actual binary code
% generation is done in the linker. Hmm but can have some issues
% if want to play with what is cross-compiled!

% TODO maybe by playing with Literate Programming I can reproduce a kind of ADT?
% e.g. by introducing LSREG, and then the part of the enum register related
% to LSREG?
% type instr = 
%   ...
% type reg = 
%   ...


<<enum as(x86)>>=
// coupling: with 8c/enam.c (and 8l/obj.c#optab?)
enum opcode_kind
{
    AXXX,

    AAAA,
    AAAD,
    AAAM,
    AAAS,
    AADCB,
    AADCL,
    AADCW,
    AADDB,
    AADDL,
    AADDW,
    AADJSP,
    AANDB,
    AANDL,
    AANDW,
    AARPL,
    ABOUNDL,
    ABOUNDW,
    ABSFL,
    ABSFW,
    ABSRL,
    ABSRW,
    ABTL,
    ABTW,
    ABTCL,
    ABTCW,
    ABTRL,
    ABTRW,
    ABTSL,
    ABTSW,

    ABYTE, //

    ACALL, //

    ACLC,
    ACLD,

    ACLI, //

    ACLTS,
    ACMC,

    ACMPB, //
    ACMPL,
    ACMPW,

    ACMPSB,
    ACMPSL,
    ACMPSW,
    ADAA,
    ADAS,

    ADATA, //


    ADECB, //
    ADECL,
    ADECW,

    ADIVB, //
    ADIVL,
    ADIVW,

    AENTER, //

    AGLOBL, //

    AGOK, //?

    AHISTORY, // for ?

    AHLT, //

    AIDIVB,
    AIDIVL,
    AIDIVW,
    AIMULB,
    AIMULL,
    AIMULW,

    AINB, //
    AINL,
    AINW,

    AINCB, //
    AINCL,
    AINCW,

    AINSB,
    AINSL,
    AINSW,
    AINT,
    AINTO,
    AIRETL,
    AIRETW,

    AJCC, //
    AJCS,
    AJCXZ,
    AJEQ,
    AJGE,
    AJGT,
    AJHI,
    AJLE,
    AJLS,
    AJLT,
    AJMI,

    AJMP, //

    AJNE,

    AJOC,
    AJOS,
    AJPC,
    AJPL,
    AJPS,
    ALAHF,
    ALARL,
    ALARW,
    ALEAL,
    ALEAW,
    ALEAVEL,
    ALEAVEW,

    ALOCK, //

    ALODSB, //
    ALODSL,
    ALODSW,

    ALONG, //

    ALOOP,
    ALOOPEQ,
    ALOOPNE,
    ALSLL,
    ALSLW,

    AMOVB, //
    AMOVL,
    AMOVW,

    AMOVBLSX,
    AMOVBLZX,
    AMOVBWSX,
    AMOVBWZX,
    AMOVWLSX,
    AMOVWLZX,
    AMOVSB,
    AMOVSL,
    AMOVSW,

    AMULB, //
    AMULL,
    AMULW,

    ANAME, // seems important

    ANEGB, //
    ANEGL,
    ANEGW,

    ANOP, //

    ANOTB, //
    ANOTL,
    ANOTW,

    AORB, //
    AORL,
    AORW,

    AOUTB, //
    AOUTL,
    AOUTW,

    AOUTSB,
    AOUTSL,
    AOUTSW,

    APOPAL,
    APOPAW,
    APOPFL,
    APOPFW,
    APOPL,
    APOPW,
    APUSHAL,
    APUSHAW,
    APUSHFL,
    APUSHFW,
    APUSHL,
    APUSHW,
    ARCLB,
    ARCLL,
    ARCLW,
    ARCRB,
    ARCRL,
    ARCRW,

    AREP,

    AREPN,

    ARET, //

    AROLB,
    AROLL,
    AROLW,
    ARORB,
    ARORL,
    ARORW,
    ASAHF,
    ASALB,
    ASALL,
    ASALW,
    ASARB,
    ASARL,
    ASARW,
    ASBBB,
    ASBBL,
    ASBBW,
    ASCASB,
    ASCASL,
    ASCASW,
    ASETCC,
    ASETCS,
    ASETEQ,
    ASETGE,
    ASETGT,
    ASETHI,
    ASETLE,
    ASETLS,
    ASETLT,
    ASETMI,
    ASETNE,
    ASETOC,
    ASETOS,
    ASETPC,
    ASETPL,
    ASETPS,
    ACDQ,
    ACWD,
    ASHLB,
    ASHLL,
    ASHLW,
    ASHRB,
    ASHRL,
    ASHRW,
    ASTC,
    ASTD,
    ASTI,

    ASTOSB, //
    ASTOSL,
    ASTOSW,

    ASUBB, //
    ASUBL,
    ASUBW,

    ASYSCALL, // !!!!!!

    ATESTB,
    ATESTL,
    ATESTW,

    ATEXT, // procedure/function TODO rename to AFUNC?

    AVERR,
    AVERW,
    AWAIT,
    AWORD,

    AXCHGB, //
    AXCHGL,
    AXCHGW,

    AXLAT,
    AXORB,
    AXORL,
    AXORW,

    AFMOVB,
    AFMOVBP,
    AFMOVD,
    AFMOVDP,
    AFMOVF,
    AFMOVFP,
    AFMOVL,
    AFMOVLP,
    AFMOVV,
    AFMOVVP,
    AFMOVW,
    AFMOVWP,
    AFMOVX,
    AFMOVXP,

    AFCOMB,
    AFCOMBP,
    AFCOMD,
    AFCOMDP,
    AFCOMDPP,
    AFCOMF,
    AFCOMFP,
    AFCOML,
    AFCOMLP,
    AFCOMW,
    AFCOMWP,
    AFUCOM,
    AFUCOMP,
    AFUCOMPP,

    AFADDDP,
    AFADDW,
    AFADDL,
    AFADDF,
    AFADDD,

    AFMULDP,
    AFMULW,
    AFMULL,
    AFMULF,
    AFMULD,

    AFSUBDP,
    AFSUBW,
    AFSUBL,
    AFSUBF,
    AFSUBD,

    AFSUBRDP,
    AFSUBRW,
    AFSUBRL,
    AFSUBRF,
    AFSUBRD,

    AFDIVDP,
    AFDIVW,
    AFDIVL,
    AFDIVF,
    AFDIVD,

    AFDIVRDP,
    AFDIVRW,
    AFDIVRL,
    AFDIVRF,
    AFDIVRD,

    AFXCHD,
    AFFREE,

    AFLDCW,
    AFLDENV,
    AFRSTOR,
    AFSAVE,
    AFSTCW,
    AFSTENV,
    AFSTSW,

    AF2XM1,
    AFABS,
    AFCHS,
    AFCLEX,
    AFCOS,
    AFDECSTP,
    AFINCSTP,
    AFINIT,
    AFLD1,
    AFLDL2E,
    AFLDL2T,
    AFLDLG2,
    AFLDLN2,
    AFLDPI,
    AFLDZ,
    AFNOP,
    AFPATAN,
    AFPREM,
    AFPREM1,
    AFPTAN,
    AFRNDINT,
    AFSCALE,
    AFSIN,
    AFSINCOS,
    AFSQRT,
    AFTST,
    AFXAM,
    AFXTRACT,
    AFYL2X,
    AFYL2XP1,

    AEND, // ??

    ADYNT,
    AINIT,

    ASIGNAME,

    AFCOMI,
    AFCOMIP,
    AFUCOMI,
    AFUCOMIP,
    ACMPXCHGB,
    ACMPXCHGL,
    ACMPXCHGW,

    /* conditional move */
    ACMOVLCC,
    ACMOVLCS,
    ACMOVLEQ,
    ACMOVLGE,
    ACMOVLGT,
    ACMOVLHI,
    ACMOVLLE,
    ACMOVLLS,
    ACMOVLLT,
    ACMOVLMI,
    ACMOVLNE,
    ACMOVLOC,
    ACMOVLOS,
    ACMOVLPC,
    ACMOVLPL,
    ACMOVLPS,
    ACMOVWCC,
    ACMOVWCS,
    ACMOVWEQ,
    ACMOVWGE,
    ACMOVWGT,
    ACMOVWHI,
    ACMOVWLE,
    ACMOVWLS,
    ACMOVWLT,
    ACMOVWMI,
    ACMOVWNE,
    ACMOVWOC,
    ACMOVWOS,
    ACMOVWPC,
    ACMOVWPL,
    ACMOVWPS,

    AFCMOVCC,
    AFCMOVCS,
    AFCMOVEQ,
    AFCMOVHI,
    AFCMOVLS,
    AFCMOVNE,
    AFCMOVNU,
    AFCMOVUN,

    /* add new operations here. nowhere else. here. */
    ALAST
};
@
% this is more than 256 (454), so when need to marshall the opcode
% we need 2 bytes, hence code like this in outcode():
%    Bputc(&obuf, a);
%    Bputc(&obuf, a>>8);



% for 8c! conventions! (not used at all by 8a, but in 8.out.h for other tools)
<<enum misc3(x86)>>=
enum misc3 {
    REGARG		= -1,
    REGRET		= D_AX,
    FREGRET		= D_F0,
    REGSP		= D_SP,
    REGTMP		= D_DI,
};
@

%\section{[[Register]]}

% ADT would be far better than this enum and separate Sym.
% less: rename operand_part1, to show that need another part
% to be a complete operand (which is Gen =~ Adr)
<<enum reg(x86)>>=
enum operand_kind
{
<<[[operand_kind]] register cases(x86)>>
    D_NONE		= 59,
<<[[operand_kind]] non register cases(x86)>>
};
@

%less: could have start at 1 here so could have D_NONE = 0
<<[[operand_kind]] register cases(x86)>>=
    D_AL		= 0,
    D_CL,
    D_DL,
    D_BL,

    D_AH		= 4,
    D_CH,
    D_DH,
    D_BH,

    D_AX		= 8,
    D_CX,
    D_DX,
    D_BX,
    D_SP,
    D_BP,
    D_SI,
    D_DI,

    D_F0		= 16,
    D_F7		= D_F0 + 7,

    D_CS		= 24,
    D_SS,
    D_DS,
    D_ES,
    D_FS,
    D_GS,

    D_GDTR,		/* global descriptor table register */
    D_IDTR,		/* interrupt descriptor table register */
    D_LDTR,		/* local descriptor table register */
    D_MSW,		/* machine status word */
    D_TASK,		/* task register */

    D_CR		= 35, // D_CR0 .. D_CR7
    D_DR		= 43, // D_DR0 .. D_DR7
    D_TR		= 51, // D_TR0 .. D_TR7
@


% how get the remaining info? e.g. for D_BRANCH to get the symbol or int 
% you'll have too look in Gen.value
<<[[operand_kind]] non register cases(x86)>>=
    // for ACALL, AJMP (from PC)
    D_BRANCH	= 60, 

    // For ADATA
    D_EXTERN	= 61, // data/bss values (from SB)
    D_STATIC	= 62, // data static variables (from SB)
    D_AUTO	= 63, // stack values (from SP)
    D_PARAM	= 64, // parameter (from FP)

    D_CONST	= 65,
    D_FCONST	= 66,
    D_SCONST	= 67,

    D_ADDR	= 68,
@

% ???
<<[[operand_kind]] non register cases(x86)>>=
    D_FILE,
    D_FILE1, // used by linker only

    D_INDIR,	/* additive */

    D_CONST2 = D_INDIR+D_INDIR,

    D_SIZE,	/* 8l internal */
@

%INDIR? faux ami avec previous D_FILE ... it's not about a directory 
% it's INDIRECT, (AX) => =~ *AX, = deref
%  D_INDIR + D_AX (D_INDIR only with register cases, hence safe D_CONST2)
%  ugly ... we really need ADT and simple recursive types ...
% see Dconv in Compiler.nw, seems only for D_INDIR of register






% the first part is essentially for keywords
<<token declarations(x86)>>=
%token  <lval>  LTYPE0 LTYPE1 LTYPE2 LTYPE3 LTYPE4
%token  <lval>  LTYPEC LTYPED LTYPEN LTYPER LTYPET LTYPES LTYPEM LTYPEI LTYPEG
%token  <lval>  LFP LPC LSB LSP
%token  <lval>  LBREG LLREG LSREG LFREG

%token  <lval>  LCONST 
%token  <dval>  LFCONST
%token  <sval>  LSCONST
%token  <sym>   LNAME LLAB LVAR
@
%pad's bugfix? LSP was was LFCONST, does not make sense


<<union token(x86)>>=
%union {
 //   enum<opcode_kind> (for LTYPE/...) 
 // | enum<operand_kind> (for LBREG/...) 
 // | long (for LCONST)
 long   lval;

 double dval;
 char   sval[8];
 Sym    *sym;

 <<[[Token]] other fields(x86)>>
}
@







% LTYPE0 etc are defined in a.y, tokens with value 
% instruction table conversion, string -> token
<<struct Itab(x86)>>=
struct Itab
{
    char	*name;

    //enum<token_kind>
    ushort	type;
    //enum<opcode_kind> | enum<operand_kind>
    ushort	value;
};
@

<<global itab(x86)>>=
struct Itab itab[] =
{
    "SP",		LSP,	D_AUTO,
    "SB",		LSB,	D_EXTERN,
    "FP",		LFP,	D_PARAM,
    "PC",		LPC,	D_BRANCH,

    "AL",		LBREG,	D_AL,
    "CL",		LBREG,	D_CL,
    "DL",		LBREG,	D_DL,
    "BL",		LBREG,	D_BL,
    "AH",		LBREG,	D_AH,
    "CH",		LBREG,	D_CH,
    "DH",		LBREG,	D_DH,
    "BH",		LBREG,	D_BH,

    "AX",		LLREG,	D_AX,
    "CX",		LLREG,	D_CX,
    "DX",		LLREG,	D_DX,
    "BX",		LLREG,	D_BX,
/*	"SP",		LLREG,	D_SP,	*/
    "BP",		LLREG,	D_BP,
    "SI",		LLREG,	D_SI,
    "DI",		LLREG,	D_DI,

    "F0",		LFREG,	D_F0+0,
    "F1",		LFREG,	D_F0+1,
    "F2",		LFREG,	D_F0+2,
    "F3",		LFREG,	D_F0+3,
    "F4",		LFREG,	D_F0+4,
    "F5",		LFREG,	D_F0+5,
    "F6",		LFREG,	D_F0+6,
    "F7",		LFREG,	D_F0+7,

    "CS",		LSREG,	D_CS,
    "SS",		LSREG,	D_SS,
    "DS",		LSREG,	D_DS,
    "ES",		LSREG,	D_ES,
    "FS",		LSREG,	D_FS,
    "GS",		LSREG,	D_GS,

    "GDTR",		LBREG,	D_GDTR,
    "IDTR",		LBREG,	D_IDTR,
    "LDTR",		LBREG,	D_LDTR,
    "MSW",		LBREG,	D_MSW,
    "TASK",		LBREG,	D_TASK,

    "CR0",		LBREG,	D_CR+0,
    "CR1",		LBREG,	D_CR+1,
    "CR2",		LBREG,	D_CR+2,
    "CR3",		LBREG,	D_CR+3,
    "CR4",		LBREG,	D_CR+4,
    "CR5",		LBREG,	D_CR+5,
    "CR6",		LBREG,	D_CR+6,
    "CR7",		LBREG,	D_CR+7,

    "DR0",		LBREG,	D_DR+0,
    "DR1",		LBREG,	D_DR+1,
    "DR2",		LBREG,	D_DR+2,
    "DR3",		LBREG,	D_DR+3,
    "DR4",		LBREG,	D_DR+4,
    "DR5",		LBREG,	D_DR+5,
    "DR6",		LBREG,	D_DR+6,
    "DR7",		LBREG,	D_DR+7,

    "TR0",		LBREG,	D_TR+0,
    "TR1",		LBREG,	D_TR+1,
    "TR2",		LBREG,	D_TR+2,
    "TR3",		LBREG,	D_TR+3,
    "TR4",		LBREG,	D_TR+4,
    "TR5",		LBREG,	D_TR+5,
    "TR6",		LBREG,	D_TR+6,
    "TR7",		LBREG,	D_TR+7,



    "AAA",		LTYPE0,	AAAA,
    "AAD",		LTYPE0,	AAAD,
    "AAM",		LTYPE0,	AAAM,
    "AAS",		LTYPE0,	AAAS,
    "ADCB",		LTYPE3,	AADCB,
    "ADCL",		LTYPE3,	AADCL,
    "ADCW",		LTYPE3,	AADCW,
    "ADDB",		LTYPE3,	AADDB,
    "ADDL",		LTYPE3,	AADDL,
    "ADDW",		LTYPE3,	AADDW,
    "ADJSP",		LTYPE2,	AADJSP,
    "ANDB",		LTYPE3,	AANDB,
    "ANDL",		LTYPE3,	AANDL,
    "ANDW",		LTYPE3,	AANDW,
    "ARPL",		LTYPE3,	AARPL,
    "BOUNDL",		LTYPE3,	ABOUNDL,
    "BOUNDW",		LTYPE3,	ABOUNDW,
    "BSFL",		LTYPE3,	ABSFL,
    "BSFW",		LTYPE3,	ABSFW,
    "BSRL",		LTYPE3,	ABSRL,
    "BSRW",		LTYPE3,	ABSRW,
    "BTCL",		LTYPE3,	ABTCL,
    "BTCW",		LTYPE3,	ABTCW,
    "BTL",		LTYPE3,	ABTL,
    "BTRL",		LTYPE3,	ABTRL,
    "BTRW",		LTYPE3,	ABTRW,
    "BTSL",		LTYPE3,	ABTSL,
    "BTSW",		LTYPE3,	ABTSW,
    "BTW",		LTYPE3,	ABTW,
    "BYTE",		LTYPE2,	ABYTE,
    "CALL",		LTYPEC,	ACALL,
    "CLC",		LTYPE0,	ACLC,
    "CLD",		LTYPE0,	ACLD,
    "CLI",		LTYPE0,	ACLI,
    "CLTS",		LTYPE0,	ACLTS,
    "CMC",		LTYPE0,	ACMC,
    "CMPB",		LTYPE4,	ACMPB,
    "CMPL",		LTYPE4,	ACMPL,
    "CMPW",		LTYPE4,	ACMPW,
    "CMPSB",		LTYPE0,	ACMPSB,
    "CMPSL",		LTYPE0,	ACMPSL,
    "CMPSW",		LTYPE0,	ACMPSW,
    "CMPXCHGB",		LTYPE3,	ACMPXCHGB,
    "CMPXCHGL",		LTYPE3,	ACMPXCHGL,
    "CMPXCHGW",		LTYPE3,	ACMPXCHGW,
    "DAA",		LTYPE0,	ADAA,
    "DAS",		LTYPE0,	ADAS,
    "DATA",		LTYPED,	ADATA,
    "DECB",		LTYPE1,	ADECB,
    "DECL",		LTYPE1,	ADECL,
    "DECW",		LTYPE1,	ADECW,
    "DIVB",		LTYPE2,	ADIVB,
    "DIVL",		LTYPE2,	ADIVL,
    "DIVW",		LTYPE2,	ADIVW,
    "END",		LTYPE0,	AEND,
    "ENTER",		LTYPE2,	AENTER,
    "GLOBL",		LTYPEG,	AGLOBL,
    "HLT",		LTYPE0,	AHLT,
    "IDIVB",		LTYPE2,	AIDIVB,
    "IDIVL",		LTYPE2,	AIDIVL,
    "IDIVW",		LTYPE2,	AIDIVW,
    "IMULB",		LTYPEI,	AIMULB,
    "IMULL",		LTYPEI,	AIMULL,
    "IMULW",		LTYPEI,	AIMULW,
    "INB",		LTYPE0,	AINB,
    "INL",		LTYPE0,	AINL,
    "INW",		LTYPE0,	AINW,
    "INCB",		LTYPE1,	AINCB,
    "INCL",		LTYPE1,	AINCL,
    "INCW",		LTYPE1,	AINCW,
    "INSB",		LTYPE0,	AINSB,
    "INSL",		LTYPE0,	AINSL,
    "INSW",		LTYPE0,	AINSW,
    "INT",		LTYPE2,	AINT,
    "INTO",		LTYPE0,	AINTO,
    "IRETL",		LTYPE0,	AIRETL,
    "IRETW",		LTYPE0,	AIRETW,

    "JOS",		LTYPER,	AJOS,
    "JO",		LTYPER,	AJOS,	/* alternate */
    "JOC",		LTYPER,	AJOC,
    "JNO",		LTYPER,	AJOC,	/* alternate */
    "JCS",		LTYPER,	AJCS,
    "JB",		LTYPER,	AJCS,	/* alternate */
    "JC",		LTYPER,	AJCS,	/* alternate */
    "JNAE",		LTYPER,	AJCS,	/* alternate */
    "JLO",		LTYPER,	AJCS,	/* alternate */
    "JCC",		LTYPER,	AJCC,
    "JAE",		LTYPER,	AJCC,	/* alternate */
    "JNB",		LTYPER,	AJCC,	/* alternate */
    "JNC",		LTYPER,	AJCC,	/* alternate */
    "JHS",		LTYPER,	AJCC,	/* alternate */
    "JEQ",		LTYPER,	AJEQ,
    "JE",		LTYPER,	AJEQ,	/* alternate */
    "JZ",		LTYPER,	AJEQ,	/* alternate */
    "JNE",		LTYPER,	AJNE,
    "JNZ",		LTYPER,	AJNE,	/* alternate */
    "JLS",		LTYPER,	AJLS,
    "JBE",		LTYPER,	AJLS,	/* alternate */
    "JNA",		LTYPER,	AJLS,	/* alternate */
    "JHI",		LTYPER,	AJHI,
    "JA",		LTYPER,	AJHI,	/* alternate */
    "JNBE",		LTYPER,	AJHI,	/* alternate */
    "JMI",		LTYPER,	AJMI,
    "JS",		LTYPER,	AJMI,	/* alternate */
    "JPL",		LTYPER,	AJPL,
    "JNS",		LTYPER,	AJPL,	/* alternate */
    "JPS",		LTYPER,	AJPS,
    "JP",		LTYPER,	AJPS,	/* alternate */
    "JPE",		LTYPER,	AJPS,	/* alternate */
    "JPC",		LTYPER,	AJPC,
    "JNP",		LTYPER,	AJPC,	/* alternate */
    "JPO",		LTYPER,	AJPC,	/* alternate */
    "JLT",		LTYPER,	AJLT,
    "JL",		LTYPER,	AJLT,	/* alternate */
    "JNGE",		LTYPER,	AJLT,	/* alternate */
    "JGE",		LTYPER,	AJGE,
    "JNL",		LTYPER,	AJGE,	/* alternate */
    "JLE",		LTYPER,	AJLE,
    "JNG",		LTYPER,	AJLE,	/* alternate */
    "JGT",		LTYPER,	AJGT,
    "JG",		LTYPER,	AJGT,	/* alternate */
    "JNLE",		LTYPER,	AJGT,	/* alternate */

    "JCXZ",		LTYPER,	AJCXZ,
    "JMP",		LTYPEC,	AJMP,
    "LAHF",		LTYPE0,	ALAHF,
    "LARL",		LTYPE3,	ALARL,
    "LARW",		LTYPE3,	ALARW,
    "LEAL",		LTYPE3,	ALEAL,
    "LEAW",		LTYPE3,	ALEAW,
    "LEAVEL",		LTYPE0,	ALEAVEL,
    "LEAVEW",		LTYPE0,	ALEAVEW,
    "LOCK",		LTYPE0,	ALOCK,
    "LODSB",		LTYPE0,	ALODSB,
    "LODSL",		LTYPE0,	ALODSL,
    "LODSW",		LTYPE0,	ALODSW,
    "LONG",		LTYPE2,	ALONG,
    "LOOP",		LTYPER,	ALOOP,
    "LOOPEQ",		LTYPER,	ALOOPEQ,
    "LOOPNE",		LTYPER,	ALOOPNE,
    "LSLL",		LTYPE3,	ALSLL,
    "LSLW",		LTYPE3,	ALSLW,
    "MOVB",		LTYPE3,	AMOVB,
    "MOVL",		LTYPEM,	AMOVL,
    "MOVW",		LTYPEM,	AMOVW,
    "MOVBLSX",		LTYPE3, AMOVBLSX,
    "MOVBLZX",		LTYPE3, AMOVBLZX,
    "MOVBWSX",		LTYPE3, AMOVBWSX,
    "MOVBWZX",		LTYPE3, AMOVBWZX,
    "MOVWLSX",		LTYPE3, AMOVWLSX,
    "MOVWLZX",		LTYPE3, AMOVWLZX,
    "MOVSB",		LTYPE0,	AMOVSB,
    "MOVSL",		LTYPE0,	AMOVSL,
    "MOVSW",		LTYPE0,	AMOVSW,
    "MULB",		LTYPE2,	AMULB,
    "MULL",		LTYPE2,	AMULL,
    "MULW",		LTYPE2,	AMULW,
    "NEGB",		LTYPE1,	ANEGB,
    "NEGL",		LTYPE1,	ANEGL,
    "NEGW",		LTYPE1,	ANEGW,
    "NOP",		LTYPEN,	ANOP,
    "NOTB",		LTYPE1,	ANOTB,
    "NOTL",		LTYPE1,	ANOTL,
    "NOTW",		LTYPE1,	ANOTW,
    "ORB",		LTYPE3,	AORB,
    "ORL",		LTYPE3,	AORL,
    "ORW",		LTYPE3,	AORW,
    "OUTB",		LTYPE0,	AOUTB,
    "OUTL",		LTYPE0,	AOUTL,
    "OUTW",		LTYPE0,	AOUTW,
    "OUTSB",		LTYPE0,	AOUTSB,
    "OUTSL",		LTYPE0,	AOUTSL,
    "OUTSW",		LTYPE0,	AOUTSW,
    "POPAL",		LTYPE0,	APOPAL,
    "POPAW",		LTYPE0,	APOPAW,
    "POPFL",		LTYPE0,	APOPFL,
    "POPFW",		LTYPE0,	APOPFW,
    "POPL",		LTYPE1,	APOPL,
    "POPW",		LTYPE1,	APOPW,
    "PUSHAL",		LTYPE0,	APUSHAL,
    "PUSHAW",		LTYPE0,	APUSHAW,
    "PUSHFL",		LTYPE0,	APUSHFL,
    "PUSHFW",		LTYPE0,	APUSHFW,
    "PUSHL",		LTYPE2,	APUSHL,
    "PUSHW",		LTYPE2,	APUSHW,
    "RCLB",		LTYPE3,	ARCLB,
    "RCLL",		LTYPE3,	ARCLL,
    "RCLW",		LTYPE3,	ARCLW,
    "RCRB",		LTYPE3,	ARCRB,
    "RCRL",		LTYPE3,	ARCRL,
    "RCRW",		LTYPE3,	ARCRW,
    "REP",		LTYPE0,	AREP,
    "REPN",		LTYPE0,	AREPN,
    "RET",		LTYPE0,	ARET,
    "ROLB",		LTYPE3,	AROLB,
    "ROLL",		LTYPE3,	AROLL,
    "ROLW",		LTYPE3,	AROLW,
    "RORB",		LTYPE3,	ARORB,
    "RORL",		LTYPE3,	ARORL,
    "RORW",		LTYPE3,	ARORW,
    "SAHF",		LTYPE0,	ASAHF,
    "SALB",		LTYPE3,	ASALB,
    "SALL",		LTYPE3,	ASALL,
    "SALW",		LTYPE3,	ASALW,
    "SARB",		LTYPE3,	ASARB,
    "SARL",		LTYPE3,	ASARL,
    "SARW",		LTYPE3,	ASARW,
    "SBBB",		LTYPE3,	ASBBB,
    "SBBL",		LTYPE3,	ASBBL,
    "SBBW",		LTYPE3,	ASBBW,
    "SCASB",		LTYPE0,	ASCASB,
    "SCASL",		LTYPE0,	ASCASL,
    "SCASW",		LTYPE0,	ASCASW,
    "SETCC",		LTYPE1,	ASETCC,
    "SETCS",		LTYPE1,	ASETCS,
    "SETEQ",		LTYPE1,	ASETEQ,
    "SETGE",		LTYPE1,	ASETGE,
    "SETGT",		LTYPE1,	ASETGT,
    "SETHI",		LTYPE1,	ASETHI,
    "SETLE",		LTYPE1,	ASETLE,
    "SETLS",		LTYPE1,	ASETLS,
    "SETLT",		LTYPE1,	ASETLT,
    "SETMI",		LTYPE1,	ASETMI,
    "SETNE",		LTYPE1,	ASETNE,
    "SETOC",		LTYPE1,	ASETOC,
    "SETOS",		LTYPE1,	ASETOS,
    "SETPC",		LTYPE1,	ASETPC,
    "SETPL",		LTYPE1,	ASETPL,
    "SETPS",		LTYPE1,	ASETPS,
    "CDQ",		LTYPE0,	ACDQ,
    "CWD",		LTYPE0,	ACWD,
    "SHLB",		LTYPE3,	ASHLB,
    "SHLL",		LTYPES,	ASHLL,
    "SHLW",		LTYPES,	ASHLW,
    "SHRB",		LTYPE3,	ASHRB,
    "SHRL",		LTYPES,	ASHRL,
    "SHRW",		LTYPES,	ASHRW,
    "STC",		LTYPE0,	ASTC,
    "STD",		LTYPE0,	ASTD,
    "STI",		LTYPE0,	ASTI,
    "STOSB",		LTYPE0,	ASTOSB,
    "STOSL",		LTYPE0,	ASTOSL,
    "STOSW",		LTYPE0,	ASTOSW,
    "SUBB",		LTYPE3,	ASUBB,
    "SUBL",		LTYPE3,	ASUBL,
    "SUBW",		LTYPE3,	ASUBW,
    "SYSCALL",		LTYPE0,	ASYSCALL,
    "TESTB",		LTYPE3,	ATESTB,
    "TESTL",		LTYPE3,	ATESTL,
    "TESTW",		LTYPE3,	ATESTW,
    "TEXT",		LTYPET,	ATEXT,
    "VERR",		LTYPE2,	AVERR,
    "VERW",		LTYPE2,	AVERW,
    "WAIT",		LTYPE0,	AWAIT,
    "WORD",		LTYPE2,	AWORD,
    "XCHGB",		LTYPE3,	AXCHGB,
    "XCHGL",		LTYPE3,	AXCHGL,
    "XCHGW",		LTYPE3,	AXCHGW,
    "XLAT",		LTYPE2,	AXLAT,
    "XORB",		LTYPE3,	AXORB,
    "XORL",		LTYPE3,	AXORL,
    "XORW",		LTYPE3,	AXORW,

    "CMOVLCC",		LTYPE3,	ACMOVLCC,
    "CMOVLCS",		LTYPE3,	ACMOVLCS,
    "CMOVLEQ",		LTYPE3,	ACMOVLEQ,
    "CMOVLGE",		LTYPE3,	ACMOVLGE,
    "CMOVLGT",		LTYPE3,	ACMOVLGT,
    "CMOVLHI",		LTYPE3,	ACMOVLHI,
    "CMOVLLE",		LTYPE3,	ACMOVLLE,
    "CMOVLLS",		LTYPE3,	ACMOVLLS,
    "CMOVLLT",		LTYPE3,	ACMOVLLT,
    "CMOVLMI",		LTYPE3,	ACMOVLMI,
    "CMOVLNE",		LTYPE3,	ACMOVLNE,
    "CMOVLOC",		LTYPE3,	ACMOVLOC,
    "CMOVLOS",		LTYPE3,	ACMOVLOS,
    "CMOVLPC",		LTYPE3,	ACMOVLPC,
    "CMOVLPL",		LTYPE3,	ACMOVLPL,
    "CMOVLPS",		LTYPE3,	ACMOVLPS,
    "CMOVWCC",		LTYPE3,	ACMOVWCC,
    "CMOVWCS",		LTYPE3,	ACMOVWCS,
    "CMOVWEQ",		LTYPE3,	ACMOVWEQ,
    "CMOVWGE",		LTYPE3,	ACMOVWGE,
    "CMOVWGT",		LTYPE3,	ACMOVWGT,
    "CMOVWHI",		LTYPE3,	ACMOVWHI,
    "CMOVWLE",		LTYPE3,	ACMOVWLE,
    "CMOVWLS",		LTYPE3,	ACMOVWLS,
    "CMOVWLT",		LTYPE3,	ACMOVWLT,
    "CMOVWMI",		LTYPE3,	ACMOVWMI,
    "CMOVWNE",		LTYPE3,	ACMOVWNE,
    "CMOVWOC",		LTYPE3,	ACMOVWOC,
    "CMOVWOS",		LTYPE3,	ACMOVWOS,
    "CMOVWPC",		LTYPE3,	ACMOVWPC,
    "CMOVWPL",		LTYPE3,	ACMOVWPL,
    "CMOVWPS",		LTYPE3,	ACMOVWPS,
                	
    "FMOVB",		LTYPE3, AFMOVB,
    "FMOVBP",		LTYPE3, AFMOVBP,
    "FMOVD",		LTYPE3, AFMOVD,
    "FMOVDP",		LTYPE3, AFMOVDP,
    "FMOVF",		LTYPE3, AFMOVF,
    "FMOVFP",		LTYPE3, AFMOVFP,
    "FMOVL",		LTYPE3, AFMOVL,
    "FMOVLP",		LTYPE3, AFMOVLP,
    "FMOVV",		LTYPE3, AFMOVV,
    "FMOVVP",		LTYPE3, AFMOVVP,
    "FMOVW",		LTYPE3, AFMOVW,
    "FMOVWP",		LTYPE3, AFMOVWP,
    "FMOVX",		LTYPE3, AFMOVX,
    "FMOVXP",		LTYPE3, AFMOVXP,
    "FCMOVCC",		LTYPE3, AFCMOVCC,
    "FCMOVCS",		LTYPE3, AFCMOVCS,
    "FCMOVEQ",		LTYPE3, AFCMOVEQ,
    "FCMOVHI",		LTYPE3, AFCMOVHI,
    "FCMOVLS",		LTYPE3, AFCMOVLS,
    "FCMOVNE",		LTYPE3, AFCMOVNE,
    "FCMOVNU",		LTYPE3, AFCMOVNU,
    "FCMOVUN",		LTYPE3, AFCMOVUN,
    "FCOMB",		LTYPE3, AFCOMB,
    "FCOMBP",		LTYPE3, AFCOMBP,
    "FCOMD",		LTYPE3, AFCOMD,
    "FCOMDP",		LTYPE3, AFCOMDP,
    "FCOMDPP",		LTYPE3, AFCOMDPP,
    "FCOMF",		LTYPE3, AFCOMF,
    "FCOMFP",		LTYPE3, AFCOMFP,
    "FCOMI",		LTYPE3, AFCOMI,
    "FCOMIP",		LTYPE3, AFCOMIP,
    "FCOML",		LTYPE3, AFCOML,
    "FCOMLP",		LTYPE3, AFCOMLP,
    "FCOMW",		LTYPE3, AFCOMW,
    "FCOMWP",		LTYPE3, AFCOMWP,
    "FUCOM",		LTYPE3, AFUCOM,
    "FUCOMI",		LTYPE3, AFUCOMI,
    "FUCOMIP",		LTYPE3, AFUCOMIP,
    "FUCOMP",		LTYPE3, AFUCOMP,
    "FUCOMPP",		LTYPE3, AFUCOMPP,
    "FADDW",		LTYPE3, AFADDW,
    "FADDL",		LTYPE3, AFADDL,
    "FADDF",		LTYPE3, AFADDF,
    "FADDD",		LTYPE3, AFADDD,
    "FADDDP",		LTYPE3, AFADDDP,
    "FSUBDP",		LTYPE3, AFSUBDP,
    "FSUBW",		LTYPE3, AFSUBW,
    "FSUBL",		LTYPE3, AFSUBL,
    "FSUBF",		LTYPE3, AFSUBF,
    "FSUBD",		LTYPE3, AFSUBD,
    "FSUBRDP",		LTYPE3, AFSUBRDP,
    "FSUBRW",		LTYPE3, AFSUBRW,
    "FSUBRL",		LTYPE3, AFSUBRL,
    "FSUBRF",		LTYPE3, AFSUBRF,
    "FSUBRD",		LTYPE3, AFSUBRD,
    "FMULDP",		LTYPE3, AFMULDP,
    "FMULW",		LTYPE3, AFMULW,
    "FMULL",		LTYPE3, AFMULL,
    "FMULF",		LTYPE3, AFMULF,
    "FMULD",		LTYPE3, AFMULD,
    "FDIVDP",		LTYPE3, AFDIVDP,
    "FDIVW",		LTYPE3, AFDIVW,
    "FDIVL",		LTYPE3, AFDIVL,
    "FDIVF",		LTYPE3, AFDIVF,
    "FDIVD",		LTYPE3, AFDIVD,
    "FDIVRDP",		LTYPE3, AFDIVRDP,
    "FDIVRW",		LTYPE3, AFDIVRW,
    "FDIVRL",		LTYPE3, AFDIVRL,
    "FDIVRF",		LTYPE3, AFDIVRF,
    "FDIVRD",		LTYPE3, AFDIVRD,
    "FXCHD",		LTYPE3, AFXCHD,
    "FFREE",		LTYPE1, AFFREE,
    "FLDCW",		LTYPE2, AFLDCW,
    "FLDENV",		LTYPE1, AFLDENV,
    "FRSTOR",		LTYPE2, AFRSTOR,
    "FSAVE",		LTYPE1, AFSAVE,
    "FSTCW",		LTYPE1, AFSTCW,
    "FSTENV",		LTYPE1, AFSTENV,
    "FSTSW",		LTYPE1, AFSTSW,
    "F2XM1",		LTYPE0, AF2XM1,
    "FABS",		LTYPE0, AFABS,
    "FCHS",		LTYPE0, AFCHS,
    "FCLEX",		LTYPE0, AFCLEX,
    "FCOS",		LTYPE0, AFCOS,
    "FDECSTP",		LTYPE0, AFDECSTP,
    "FINCSTP",		LTYPE0, AFINCSTP,
    "FINIT",		LTYPE0, AFINIT,
    "FLD1",		LTYPE0, AFLD1,
    "FLDL2E",		LTYPE0, AFLDL2E,
    "FLDL2T",		LTYPE0, AFLDL2T,
    "FLDLG2",		LTYPE0, AFLDLG2,
    "FLDLN2",		LTYPE0, AFLDLN2,
    "FLDPI",		LTYPE0, AFLDPI,
    "FLDZ",		LTYPE0, AFLDZ,
    "FNOP",		LTYPE0, AFNOP,
    "FPATAN",		LTYPE0, AFPATAN,
    "FPREM",		LTYPE0, AFPREM,
    "FPREM1",		LTYPE0, AFPREM1,
    "FPTAN",		LTYPE0, AFPTAN,
    "FRNDINT",		LTYPE0, AFRNDINT,
    "FSCALE",		LTYPE0, AFSCALE,
    "FSIN",		LTYPE0, AFSIN,
    "FSINCOS",		LTYPE0, AFSINCOS,
    "FSQRT",		LTYPE0, AFSQRT,
    "FTST",		LTYPE0, AFTST,
    "FXAM",		LTYPE0, AFXAM,
    "FXTRACT",		LTYPE0, AFXTRACT,
    "FYL2X",		LTYPE0, AFYL2X,
    "FYL2XP1",		LTYPE0, AFYL2XP1,

    0
};
@



% =~ Adr of Linker
% rename operand?
<<struct Gen(x86)>>=
struct	Gen
{
    // enum<operand_kind>
    short	type;

    long	offset; // generic value
    double	dval;
    char	sval[8];

    //enum<operand_kind(register-only|D_NONE)>
    short	index;

    short	scale;

    //??
    Sym*	sym;

    long	offset2;
};
@


<<function checkscale(x86)>>=
void
checkscale(int scale)
{

    switch(scale) {
    case 1:
    case 2:
    case 4:
    case 8:
        return;
    }
    yyerror("scale must be 1248: %d", scale);
}
@

% usually MOVW AX, BX, 'from' AX, 'to' BX
% =~ Prog of Linker (but without opcode)
% rename operands?
<<struct Gen2(x86)>>=
struct	Gen2
{
    Gen	from;
    Gen	to;
};
@

% actually later do outcode(int a, Gen2 *x)
% where both arguments are really like a Prog of Linker


<<function main (assemblers/8a/lex.c)>>=
void
main(int argc, char *argv[])
{
    <<[[main()]] locals>>
    <<[[main()]] debug initialization>>

    thechar = '8';
    thestring = "386";

    cinit();
    outfile = nil;
    include[ninclude++] = ".";

    ARGBEGIN {
    <<[[main()]] command line processing>>
    } ARGEND

    if(*argv == 0) {
        print("usage: %ca [-options] file.s\n", thechar);
        errorexit();
    }

    <<[[main()]] multiple files handling>>

    if(assemble(argv[0]))
        errorexit();
    exits(0);
}
@


% could split, nullgen init, hash init (via lookup), pathname init
<<function cinit(x86)>>=
void
cinit(void)
{
    Sym *s;
    int i;

    nullgen.sym = S;
    nullgen.offset = 0;
    if(FPCHIP)
        nullgen.dval = 0;
    for(i=0; i<sizeof(nullgen.sval); i++)
        nullgen.sval[i] = '\0';
    nullgen.type = D_NONE;
    nullgen.index = D_NONE;
    nullgen.scale = 0;

    for(i=0; i<NHASH; i++)
        hash[i] = S;
    for(i=0; itab[i].name; i++) {
        s = slookup(itab[i].name);
        if(s->type != LNAME)
            yyerror("double initialization %s", itab[i].name);
        s->type = itab[i].type;
        s->value = itab[i].value;
    }

    pathname = allocn(pathname, 0, 100);
    if(getwd(pathname, 99) == nil) {
        pathname = allocn(pathname, 100, 900);
        if(getwd(pathname, 999) == nil)
            strcpy(pathname, "/???");
    }
}
@


<<function cclean(x86)>>=
void
cclean(void)
{
    Gen2 g2 = (Gen2) { nullgen, nullgen };

    outcode(AEND, &g2);
    Bflush(&obuf);
}
@





<<8a/a.y>>=
%{
#include "a.h"
%}
<<union token(x86)>>
<<priority and associativity declarations>>
<<token declarations(x86)>>
<<type declarations(x86)>>
%%
<<grammar(x86)>>
@


<<grammar(x86)>>=
prog:
  /* empty */
| prog line

<<line rule(x86)>>
<<inst rule(x86)>>
<<special opcode operands rules(x86)>>
<<operands rules(x86)>>
<<operand rules(x86)>>
<<constant expression rules>>
@


<<line rule(x86)>>=
line:
  inst ';'
@

<<line rule(x86)>>=
| ';'
| error ';'
@


<<inst rule(x86)>>=
inst:
  LTYPE0 nonnon   { outcode($1, &$2); }
| LTYPE1 nonrem   { outcode($1, &$2); }
| LTYPE2 rimnon   { outcode($1, &$2); }
| LTYPE3 rimrem   { outcode($1, &$2); }
| LTYPE4 remrim   { outcode($1, &$2); }
| LTYPER nonrel   { outcode($1, &$2); }
@

% give apercu of nonnon, rem, but just quick


<<[[Token]] other fields(x86)>>=
 Gen   gen;
@

<<type declarations(x86)>>=
%type   <gen>   reg imm mem   omem nmem nam
@

% reg = register
% imm = immediate
% mem = memory (complex, omem | nmem)



<<operand rules(x86)>>=
reg:
  LBREG { $$ = nullgen; $$.type = $1; }
| LFREG { $$ = nullgen; $$.type = $1; }
| LLREG { $$ = nullgen; $$.type = $1; }
| LSREG { $$ = nullgen; $$.type = $1; }
| LSP   { $$ = nullgen; $$.type = D_SP; }
@



<<operand rules(x86)>>=
imm:
 '$' con
 {
  $$ = nullgen;
  $$.type = D_CONST;
  $$.offset = $2;
 }
| '$' nam
 {
  $$ = $2;
  $$.index = $2.type;
  $$.type = D_ADDR;
  /*
  if($2.type == D_AUTO || $2.type == D_PARAM)
   yyerror("constant cannot be automatic: %s",
    $2.sym->name);
   */
 }
| '$' LSCONST
 {
  $$ = nullgen;
  $$.type = D_SCONST;
  memcpy($$.sval, $2, sizeof($$.sval));
 }
| '$' LFCONST
 {
  $$ = nullgen;
  $$.type = D_FCONST;
  $$.dval = $2;
 }
| '$' '(' LFCONST ')'
 {
  $$ = nullgen;
  $$.type = D_FCONST;
  $$.dval = $3;
 }
| '$' '-' LFCONST
 {
  $$ = nullgen;
  $$.type = D_FCONST;
  $$.dval = -$3;
 }
@

% MOV $AX, ... ?? vs MOV AX, ... ?



<<operand rules(x86)>>=
mem:
  omem
| nmem
@

% omem = offset mem
% nmem = named memory?

<<operand rules(x86)>>=
omem:
 con
 {
  $$ = nullgen;
  $$.type = D_INDIR+D_NONE;
  $$.offset = $1;
 }
| con '(' LLREG ')'
 {
  $$ = nullgen;
  $$.type = D_INDIR+$3;
  $$.offset = $1;
 }
| con '(' LSP ')'
 {
  $$ = nullgen;
  $$.type = D_INDIR+D_SP;
  $$.offset = $1;
 }
| con '(' LLREG '*' con ')'
 {
  $$ = nullgen;
  $$.type = D_INDIR+D_NONE;
  $$.offset = $1;
  $$.index = $3;
  $$.scale = $5;
  checkscale($$.scale);
 }
| con '(' LLREG ')' '(' LLREG '*' con ')'
 {
  $$ = nullgen;
  $$.type = D_INDIR+$3;
  $$.offset = $1;
  $$.index = $6;
  $$.scale = $8;
  checkscale($$.scale);
 }
|   '(' LLREG ')'
 {
  $$ = nullgen;
  $$.type = D_INDIR+$2;
 }
|   '(' LSP ')'
 {
  $$ = nullgen;
  $$.type = D_INDIR+D_SP;
 }
|   con '(' LSREG ')'
 {
  $$ = nullgen;
  $$.type = D_INDIR+$3;
  $$.offset = $1;
 }
|   '(' LLREG '*' con ')'
 {
  $$ = nullgen;
  $$.type = D_INDIR+D_NONE;
  $$.index = $2;
  $$.scale = $4;
  checkscale($$.scale);
 }
|   '(' LLREG ')' '(' LLREG '*' con ')'
 {
  $$ = nullgen;
  $$.type = D_INDIR+$2;
  $$.index = $5;
  $$.scale = $7;
  checkscale($$.scale);
 }
@
%$




<<operand rules(x86)>>=
nmem:
  nam
| nam '(' LLREG '*' con ')'
 {
  $$ = $1;
  $$.index = $3;
  $$.scale = $5;
  checkscale($$.scale);
 }
@
%$

% MOV foo(SB) ( AX * 8 ) ? =~ foo[ax] where sizeof foo element = 8?


%        MOVL    count+8(FP), CX
% this is just symbol for debugging help?

<<operand rules(x86)>>=
nam:
  LNAME offset '(' pointer ')'
 {
  $$ = nullgen;
  $$.type = $4;
  $$.sym = $1;
  $$.offset = $2;
 }
| LNAME '<' '>' offset '(' LSB ')'
 {
  $$ = nullgen;
  $$.type = D_STATIC;
  $$.sym = $1;
  $$.offset = $4;
 }
@
%$

<<type declarations(x86)>>=
%type   <lval>  pointer
@

<<operand rules(x86)>>=
pointer:
  LSB
| LFP
| LSP { $$ = D_AUTO; }
@

<<type declarations(x86)>>=
%type   <gen>  rel
@


% for code (rel = ? relocatable?)
<<operand rules(x86)>>=
rel:
 con '(' LPC ')'
 {
  $$ = nullgen;
  $$.type = D_BRANCH;
  $$.offset = $1 + pc;
 }
| LLAB offset
 {
  $$ = nullgen;
  $$.type = D_BRANCH;
  $$.sym = $1;
  $$.offset = $1->value + $2;
 }
| LNAME offset
 {
  $$ = nullgen;
  if(pass == 2)
   yyerror("undefined label: %s", $1->name);
  $$.type = D_BRANCH;
  $$.sym = $1;
  $$.offset = $2;
 }
@

%JMP 4(PC)

<<type declarations(x86)>>=
%type   <lval>  offset
@

<<operand rules(x86)>>=
offset:
 /* empty */ { $$ = 0; }
| '+' con    { $$ = $2; }
| '-' con    { $$ = -$2; }
@

% $



<<type declarations(x86)>>=
%type   <gen>  rem rim rom 
@

% rem = register or memory
% rim = register or memory or immediate
% rom?


% imm2 dead? yacc does not detect?

<<operand rules(x86)>>=
rem:
  reg
| mem

rim:
  rem
| imm

rom:
  reg
| mem
| imm
| rel

| '*' reg  { $$ = $2; }
| '*' omem { $$ = $2; }
@
% was 
%| omem
%| nmem
% but factorized with mem which also makes things clearer

% use for the * version? seems equivalent to regular version no?



<<line rule(x86)>>=
| LNAME ':'
 {
  $1->type = LLAB;
  $1->value = pc;
 }
 line
| LLAB ':'
 {
  if($1->value != pc)
   yyerror("redeclaration of %s", $1->name);
  $1->value = pc;
 }
 line
@
%$

<<inst rule(x86)>>=
| LTYPED spec1    { outcode($1, &$2); }
| LTYPET spec2    { outcode($1, &$2); }
| LTYPEC spec3    { outcode($1, &$2); }
| LTYPEN spec4    { outcode($1, &$2); }
| LTYPES spec5    { outcode($1, &$2); }
| LTYPEM spec6    { outcode($1, &$2); }
| LTYPEI spec7    { outcode($1, &$2); }
| LTYPEG spec8    { outcode($1, &$2); }
@

<<type declarations(x86)>>=
%type   <gen2>  spec1 spec2 spec3 spec4 spec5 spec6 spec7 spec8
@


<<special opcode operands rules(x86)>>=
spec2:  /* TEXT */
 mem ',' imm
 {
  $$.from = $1;
  $$.to = $3;
 }
|   mem ',' con ',' imm
 {
  $$.from = $1;
  $$.from.scale = $3;
  $$.to = $5;
 }
@
%$

%LTYPED
<<special opcode operands rules(x86)>>=
spec1:  /* DATA */
 nam '/' con ',' imm
 {
  $$.from = $1;
  $$.from.scale = $3;
  $$.to = $5;
 }
@
%$


<<special opcode operands rules(x86)>>=
spec8:  /* GLOBL */
 mem ',' imm
 {
  $$.from = $1;
  $$.to = $3;
 }
| mem ',' con ',' imm
 {
  $$.from = $1;
  $$.from.scale = $3;
  $$.to = $5;
 }
@
%$



<<special opcode operands rules(x86)>>=
spec3:  /* JMP/CALL */
 rom
 {
  $$.from = nullgen;
  $$.to = $1;
 }
| ',' rom
 {
  $$.from = nullgen;
  $$.to = $2;
 }
@


<<special opcode operands rules(x86)>>=
spec4:  /* NOP */
  nonnon
| nonrem
@
% NOP nonrem?

<<special opcode operands rules(x86)>>=
spec5:  /* SHL/SHR */
 rim ',' rem
 {
  $$.from = $1;
  $$.to = $3;
 }
| rim ',' rem ':' LLREG
 {
  $$.from = $1;
  $$.to = $3;
  if($$.from.index != D_NONE)
   yyerror("dp shift with lhs index");
  $$.from.index = $5;
 }
@
%$



<<special opcode operands rules(x86)>>=
spec6:  /* MOVW/MOVL */
 rim ',' rem
 {
  $$.from = $1;
  $$.to = $3;
 }
|   rim ',' rem ':' LSREG
 {
  $$.from = $1;
  $$.to = $3;
  if($$.to.index != D_NONE)
   yyerror("dp move with lhs index");
  $$.to.index = $5;
 }
@
%$

%LSREG! mv with other segments (but used in plan9? except 
% cs vs ds/es/fs/gs vs ss?



<<special opcode operands rules(x86)>>=
spec7: /* IMUL */
 rim
 {
  $$.from = $1;
  $$.to = nullgen;
 }
| rim ','
 {
  $$.from = $1;
  $$.to = nullgen;
 }
| rim ',' rem
 {
  $$.from = $1;
  $$.to = $3;
 }
@




<<inst rule(x86)>>=
| LNAME '=' expr
 {
  $1->type = LVAR;
  $1->value = $3;
 }
| LVAR '=' expr
 {
  if($1->value != $3)
   yyerror("redeclaration of %s", $1->name);
  $1->value = $3;
 }
@

<<type declarations(x86)>>=
%type   <lval>  con expr
@




%\section{Operands}

<<[[Token]] other fields(x86)>>=
 Gen2  gen2;
@

% I thought I could write code like
% /* empty */ { (Gen2) { .from = nullgen; .to = nullgen; } }
% but didn't work

<<type declarations(x86)>>=
%type   <gen2>  nonnon nonrel nonrem rimnon rimrem remrim
@

% xxxyyy = first operand, second operand
% nonnon = nothing first, nothing left


<<operands rules(x86)>>=
nonnon:
 /* empty */ { $$.from = nullgen; $$.to = nullgen; }
| ','        { $$.from = nullgen; $$.to = nullgen; }

rimrem:
 rim ',' rem { $$.from = $1; $$.to = $3; }

remrim:
 rem ',' rim { $$.from = $1; $$.to = $3; }

rimnon:
  rim       { $$.from = $1; $$.to = nullgen; }
| rim ','   { $$.from = $1; $$.to = nullgen; }

nonrem:
 rem        { $$.from = nullgen; $$.to = $1; }
| ',' rem   { $$.from = nullgen; $$.to = $2; }

nonrel:
 rel        { $$.from = nullgen; $$.to = $1; }
| ',' rel   { $$.from = nullgen; $$.to = $2; }
@

% each time put example of instructions and why it make sense?
% for instance rimrem vs remrim, make sense?




% TODO LP split and transform while into if, easier flow
%// a = opcode
<<function outcode(x86)>>=
void
outcode(int a, Gen2 *g2)
{
    // symbol from, index in h[]
    int sf;
    // symbol to, index in h[]
    int st;
    // enum<operand_kind>
    int t;
    Sym *s;

    if(pass == 1)
        goto out;

jackpot:
    sf = 0;
    s = g2->from.sym;

    while(s != S) {
        sf = s->symidx;

        if(sf < 0 || sf >= NSYM)
            sf = 0;

        t = g2->from.type;
        if(t == D_ADDR)
            t = g2->from.index;

        if(h[sf].symkind == t)
            if(h[sf].sym == s)
                break;

        zname(s->name, t, symcounter);
        s->symidx = symcounter;
        h[symcounter].sym = s;
        h[symcounter].symkind = t;
        sf = symcounter;
        symcounter++;
        if(symcounter >= NSYM)
            symcounter = 1;
        break;
    }

    st = 0;
    s = g2->to.sym;

    while(s != S) {
        st = s->symidx;

        if(st < 0 || st >= NSYM)
            st = 0;

        t = g2->to.type;
        if(t == D_ADDR)
            t = g2->to.index;

        if(h[st].symkind == t)
            if(h[st].sym == s)
                break;

        zname(s->name, t, symcounter);
        s->symidx = symcounter;
        h[symcounter].sym = s;
        h[symcounter].symkind = t;
        st = symcounter;
        symcounter++;
        if(symcounter >= NSYM)
            symcounter = 1;

        if(st == sf)
            goto jackpot;
        break;
    }

    Bputc(&obuf, a);
    Bputc(&obuf, a>>8);
    Bputc(&obuf, lineno);
    Bputc(&obuf, lineno>>8);
    Bputc(&obuf, lineno>>16);
    Bputc(&obuf, lineno>>24);
    zaddr(&g2->from, sf);
    zaddr(&g2->to, st);

out:
    if(a != AGLOBL && a != ADATA)
        pc++;
}
@
% quite similar to arm


% used also by 8c and 8l
<<enum misc2(x86)>>=
enum misc2 {
    T_TYPE		= 1<<0,
    T_INDEX		= 1<<1,
    T_OFFSET	= 1<<2,
    T_FCONST	= 1<<3,
    T_SYM		= 1<<4,
    T_SCONST	= 1<<5,
    T_OFFSET2	= 1<<6,
};
@
% >> >> >> >> >> >> >>
%dead:    T_GOTYPE	= 1<<7,

% s is index in h[] for symbol involved in the operand
<<function zaddr(x86)>>=
void
zaddr(Gen *a, int s)
{
    // bitset<enum<misc2>>
    int t;
    long l;
    int i;
    char *n;
    Ieee e;

    t = 0;
    if(a->index != D_NONE || a->scale != 0)
        t |= T_INDEX;
    if(a->offset != 0)
        t |= T_OFFSET;
    if(s != 0)
        t |= T_SYM;

    switch(a->type) {
    case D_NONE:
        break;
    case D_FCONST:
        t |= T_FCONST;
        break;
    case D_CONST2:
        t |= T_OFFSET|T_OFFSET2;
        break;
    case D_SCONST:
        t |= T_SCONST;
        break;
    default:
        t |= T_TYPE;
        break;
    }

    Bputc(&obuf, t);

    if(t & T_INDEX) {	/* implies index, scale */
        Bputc(&obuf, a->index);
        Bputc(&obuf, a->scale);
    }
    if(t & T_OFFSET) {	/* implies offset */
        l = a->offset;
        Bputc(&obuf, l);
        Bputc(&obuf, l>>8);
        Bputc(&obuf, l>>16);
        Bputc(&obuf, l>>24);
    }
    if(t & T_OFFSET2) {
        l = a->offset2;
        Bputc(&obuf, l);
        Bputc(&obuf, l>>8);
        Bputc(&obuf, l>>16);
        Bputc(&obuf, l>>24);
    }
    if(t & T_SYM)		/* implies sym */
        Bputc(&obuf, s);


    if(t & T_FCONST) {
        ieeedtod(&e, a->dval);
        l = e.l;
        Bputc(&obuf, l);
        Bputc(&obuf, l>>8);
        Bputc(&obuf, l>>16);
        Bputc(&obuf, l>>24);
        l = e.h;
        Bputc(&obuf, l);
        Bputc(&obuf, l>>8);
        Bputc(&obuf, l>>16);
        Bputc(&obuf, l>>24);
        return;
    }
    if(t & T_SCONST) {
        n = a->sval;
        for(i=0; i<sizeof(nullgen.sval); i++) {
            Bputc(&obuf, *n);
            n++;
        }
        return;
    }

    if(t & T_TYPE)
        Bputc(&obuf, a->type);
}
@


% for unresolved symbol names?
<<function zname(x86)>>=
void
zname(char *n, int t, int s)
{

    Bputc(&obuf, ANAME);		/* as(2) */
    Bputc(&obuf, ANAME>>8);
    Bputc(&obuf, t);		/* type */
    Bputc(&obuf, s);		/* sym */
    while(*n) {
        Bputc(&obuf, *n);
        n++;
    }
    Bputc(&obuf, '\0');
}
@


<<function outhist(x86)>>=
void
outhist(void)
{
    Gen g;
    Hist *h;
    char *p, *q, *op, c;
    int n;

    g = nullgen;
    c = pathchar();

    for(h = hist; h != H; h = h->link) {
        p = h->filename;
        op = nil;
        // relative file?
        if(p && p[0] != c && h->local_line == 0 && pathname){
            if(pathname[0] == c){
                op = p;
                p = pathname;
            }
        }
        while(p) {
            q = strchr(p, c);
            if(q) {
                n = q-p;
                if(n == 0){
                    n = 1;	/* leading "/" */
                    *p = '/';	/* don't emit "\" on windows */
                }
                q++;
            } else {
                n = strlen(p);
                q = nil;
            }

            if(n) {
                Bputc(&obuf, ANAME);
                Bputc(&obuf, ANAME>>8);
                Bputc(&obuf, D_FILE);	/* type */
                Bputc(&obuf, 1);	/* sym */
                Bputc(&obuf, '<');
                Bwrite(&obuf, p, n);
                Bputc(&obuf, '\0');
            }
            p = q;
            if(p == nil && op) {
                p = op;
                op = nil;
            }
        }

        g.offset = h->local_line;

        Bputc(&obuf, AHISTORY);
        Bputc(&obuf, AHISTORY>>8);

        Bputc(&obuf, h->line);
        Bputc(&obuf, h->line>>8);
        Bputc(&obuf, h->line>>16);
        Bputc(&obuf, h->line>>24);

        zaddr(&nullgen, 0);
        zaddr(&g, 0);
    }
}
@

<<constant FPCHIP(x86)>>=
#define	FPCHIP		true
@

\section{[[include/386/]]}

\subsection*{[[include/386/8.out.h]]}


% todo: transform in an enum? 
% note that it's not used by 8a, used by 8c/8l
<<constant NOPROF(x86)>>=
#define NOPROF	(1<<0)
@

% used by 8l (to allow override existing symbol? 8l option?)
<<constant DUPOK(x86)>>=
#define DUPOK	(1<<1)
@

% dead?
<<constant NOSPLIT(x86)>>=
#define NOSPLIT	(1<<2)
@


% used by ar?
<<constant SYMDEF(x86)>>=
/*
 * this is the ranlib header
 */
#define	SYMDEF	"__.SYMDEF"
@


%-------------------------------------------------------------

<<include/386/8.out.h>>=

<<constant NSNAME>>

<<constant NOPROF(x86)>>
<<constant DUPOK(x86)>>
<<constant NOSPLIT(x86)>>

<<enum as(x86)>>

<<enum reg(x86)>>

<<enum misc2(x86)>>
<<enum misc3(x86)>>

<<constant SYMDEF(x86)>>
@





\section{[[assemblers/8a/]]}

\subsection*{[[assemblers/8a/a.h]]}

%-------------------------------------------------------------

<<assemblers/8a/a.h>>=
#include "../aa/aa.h"
#include <386/8.out.h>

typedef	struct	Gen  Gen;
typedef	struct	Gen2 Gen2;

<<constant FPCHIP(x86)>>

<<struct Gen(x86)>>
<<struct Gen2(x86)>>

extern	char*	Dlist[30];
extern	int	nDlist;
extern	Gen	nullgen;
extern	int	pass;
extern	char*	pathname;
extern	char*	thestring;
extern	Biobuf	obuf;

// for a.y
long	yylex(void);
void	checkscale(int);
void	outcode(int, Gen2*);

int	escchar(int);
//Sym*	getsym(void);

// for lexbody
void	setinclude(char*);
void*	allocn(void*, long, long);
void	errorexit(void);
Sym*	slookup(char*);
void	pinit(char*);
void	ieeedtod(Ieee*, double);
void	dodefine(char*);
void	yyerror(char*, ...);
int	yyparse(void);

// for macbody
int	getc(void);
void	unget(int);
void	pushio(void);
void	newio(void);
void	newfile(char*, int);

// for macbody, was in lexbody

int	mywait(int*);
int	mycreat(char*, int);
int	systemtype(int);
int	pathchar(void);
@


\subsection*{[[assemblers/8a/globals.c]]}

%-------------------------------------------------------------

<<assemblers/8a/globals.c>>=
#include "a.h"

<<global nullgen>>
@


\subsection*{[[assemblers/8a/lex.c]]}


%-------------------------------------------------------------

<<assemblers/8a/lex.c>>=
#include "a.h"
#include "y.tab.h"

void	cinit(void);
int		assemble(char*);
void	cclean(void);
void	outhist(void);

<<function main (assemblers/8a/lex.c)>>

<<function assemble>>

<<struct Itab(x86)>>
<<global itab(x86)>>

<<function cinit(x86)>>

<<function checkscale(x86)>>

<<function syminit>>

<<function cclean(x86)>>

<<function zname(x86)>>

<<function zaddr(x86)>>

<<function outcode(x86)>>

<<function outhist(x86)>>

// now use aa.a8
//#include "../cc/lexbody"
//#include "../cc/compat"

// used to be in ../cc/lexbody and factorized between assemblers by
// using #include, but ugly, so I copy pasted the function for now
<<function yylex>>

// #include "../cc/macbody"
@
