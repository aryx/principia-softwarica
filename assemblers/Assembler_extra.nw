\section{[[include/]]}

\subsection*{[[include/common.out.h]]}

%-------------------------------------------------------------

<<include/common.out.h>>=

<<constant NSYM>>

// was originally in a xxx/y.out.h (but was always the same in all archi)
// hence the factorization here
/*
 * this is the simulated IEEE floating point
 */
typedef	struct	ieee	Ieee;
<<struct ieee>>
@


\section{[[include/arm/]]}

\subsection*{[[include/arm/5.out.h]]}

<<constant NSNAME(arm)>>=
#define	NSNAME		8
@

<<constant NREG(arm)>>=
#define	NREG		16
@

<<constant NOPROF(arm)>>=
#define NOPROF		(1<<0)
@

<<constant DUPOK(arm)>>=
#define DUPOK		(1<<1)
@

<<constant ALLTHUMBS(arm)>>=
#define	ALLTHUMBS	(1<<2)
@

<<constant REGRET(arm)>>=
#define	REGRET		0
@

<<constant REGARG(arm)>>=
#define	REGARG		0
@

<<constant REGMIN(arm)>>=
/* compiler allocates register variables R2 up */
#define	REGMIN		2
@

<<constant REGMAX(arm)>>=
#define	REGMAX		8
@

<<constant REGEXT(arm)>>=
#define	REGEXT		10
@

<<constant REGTMP(arm)>>=
/* compiler allocates external registers R10 down */
#define	REGTMP		11
@

<<constant REGSB(arm)>>=
#define	REGSB		12
@

<<constant REGSP(arm)>>=
#define	REGSP		13
@

<<constant REGLINK(arm)>>=
#define	REGLINK		14
@

<<constant REGPC(arm)>>=
#define	REGPC		15
@

<<constant REGTMPT(arm)>>=
#define	REGTMPT		7	/* used by the loader for thumb code */
@

<<constant NFREG(arm)>>=
#define	NFREG		8
@

<<constant FREGRET(arm)>>=
#define	FREGRET		0
@

<<constant FREGEXT(arm)>>=
#define	FREGEXT		7
@

<<constant FREGTMP(arm)>>=
#define	FREGTMP		15
@

<<enum as(arm)>>=
/* compiler allocates external registers F7 down */

enum	as
{
    AXXX,

    AAND,
    AEOR,
    ASUB,
    ARSB,
    AADD,
    AADC,
    ASBC,
    ARSC,
    ATST,
    ATEQ,
    ACMP,
    ACMN,
    AORR,
    //AMOV, redundant with the other MOV operations
    ABIC,
    AMVN,

    AB,
    ABL,
/* 
 * Do not reorder or fragment the conditional branch 
 * opcodes, or the predication code will break 
 */ 
    // AB derivatives with condition code, see 5i/
    ABEQ,
    ABNE,
    ABCS,//not in 5i/cond, seems equivalent to ABHS
    ABHS,
    ABCC,//not in 5i/cond, seems equivalent to ABLO
    ABLO,
    ABMI,
    ABPL,
    ABVS,
    ABVC,
    ABHI,
    ABLS,
    ABGE,
    ABLT,
    ABGT,
    ABLE,
    //ABAL? (always) done via AB, ABNV (never) done via ANOP probably

    // ??
    AMOVWD,
    AMOVWF,
    AMOVDW,
    AMOVFW,
    AMOVFD,
    AMOVDF,
    AMOVF,
    AMOVD,

    // floats?
    ACMPF,
    ACMPD,
    AADDF,
    AADDD,
    ASUBF,
    ASUBD,
    AMULF,
    AMULD,
    ADIVF,
    ADIVD,
//	ASQRTF, see below
//	ASQRTD, see below

    // pseudo instruction? just special kind of AMOV with shift bits?
    ASRL,
    ASRA,
    ASLL,

    // ARM has ADIV? AMOD?
    AMULU,
    ADIVU,
    AMUL,
    ADIV,
    AMOD,
    AMODU,

    AMOVB,
    AMOVBU,
    AMOVH,
    AMOVHU,
    AMOVW,
    AMOVM,

    ASWPBU,
    ASWPW,

    ANOP, // mv to beginning?

    ARFE, // ?? return from exn?
    ASWI, // syscall
    AMULA, // mov with MUL?

    // pseudo
    ADATA,
    AGLOBL,
    AGOK,
    AHISTORY,
    ANAME,
    ARET,
    ATEXT,
    AWORD,
    ADYNT,
    AINIT,
    ABCASE,
    ACASE,

    AEND, // hmm not really, who uses that?

    AMULL,
    AMULAL,
    AMULLU,
    AMULALU,

    ABX, // ?
    ABXRET, // ?
    ADWORD, // ?

    ASIGNAME,

    /* moved here to preserve values of older identifiers */
    ASQRTF,
    ASQRTD,

    ALDREX,
    ASTREX,
    
    ALDREXD,
    ASTREXD,

    ALAST,
};
@

<<constant C_SCOND(arm)>>=
/* scond byte */
#define	C_SCOND	((1<<4)-1)
@

<<constant C_SBIT(arm)>>=
#define	C_SBIT	(1<<4)
@

<<constant C_PBIT(arm)>>=
#define	C_PBIT	(1<<5)
@

<<constant C_WBIT(arm)>>=
#define	C_WBIT	(1<<6)
@

<<constant C_FBIT(arm)>>=
#define	C_FBIT	(1<<7)	/* psr flags-only */
@

<<constant C_UBIT(arm)>>=
#define	C_UBIT	(1<<7)	/* up bit */
@

<<constant D_GOK(arm)>>=
/* type/name */
#define	D_GOK	0
@

<<constant D_NONE(arm)>>=
#define	D_NONE	1
@

<<constant D_BRANCH(arm)>>=
/* type */
#define	D_BRANCH	(D_NONE+1)
@

<<constant D_OREG(arm)>>=
#define	D_OREG		(D_NONE+2)
@

<<constant D_CONST(arm)>>=
#define	D_CONST		(D_NONE+7)
@

<<constant D_FCONST(arm)>>=
#define	D_FCONST	(D_NONE+8)
@

<<constant D_SCONST(arm)>>=
#define	D_SCONST	(D_NONE+9)
@

<<constant D_PSR(arm)>>=
#define	D_PSR		(D_NONE+10)
@

<<constant D_REG(arm)>>=
#define	D_REG		(D_NONE+12)
@

<<constant D_FREG(arm)>>=
#define	D_FREG		(D_NONE+13)
@

<<constant D_FILE(arm)>>=
#define	D_FILE		(D_NONE+16)
@

<<constant D_OCONST(arm)>>=
#define	D_OCONST	(D_NONE+17)
@

<<constant D_FILE1(arm)>>=
#define	D_FILE1		(D_NONE+18)
@

<<constant D_SHIFT(arm)>>=
#define	D_SHIFT		(D_NONE+19)
@

<<constant D_FPCR(arm)>>=
#define	D_FPCR		(D_NONE+20)
@

<<constant D_REGREG(arm)>>=
#define	D_REGREG	(D_NONE+21)
@

<<constant D_ADDR(arm)>>=
#define	D_ADDR		(D_NONE+22)
@

<<constant D_EXTERN(arm)>>=
/* name */
#define	D_EXTERN	(D_NONE+3)
@

<<constant D_STATIC(arm)>>=
#define	D_STATIC	(D_NONE+4)
@

<<constant D_AUTO(arm)>>=
#define	D_AUTO		(D_NONE+5)
@

<<constant D_PARAM(arm)>>=
#define	D_PARAM		(D_NONE+6)
@

<<constant SYMDEF(arm)>>=
/*
 * this is the ranlib header
 */
#define	SYMDEF	"__.SYMDEF"
@


%-------------------------------------------------------------

<<include/arm/5.out.h>>=
<<constant NSNAME(arm)>>

<<constant NREG(arm)>>

<<constant NOPROF(arm)>>
<<constant DUPOK(arm)>>

<<constant ALLTHUMBS(arm)>>

<<constant REGRET(arm)>>
<<constant REGARG(arm)>>

/* compiler allocates R1 up as temps */
<<constant REGMIN(arm)>>
<<constant REGMAX(arm)>>
<<constant REGEXT(arm)>>
<<constant REGTMP(arm)>>
<<constant REGSB(arm)>>
<<constant REGSP(arm)>>
<<constant REGLINK(arm)>>
<<constant REGPC(arm)>>

<<constant REGTMPT(arm)>>

<<constant NFREG(arm)>>
<<constant FREGRET(arm)>>
<<constant FREGEXT(arm)>>
<<constant FREGTMP(arm)>>
/* compiler allocates register variables F0 up */
<<enum as(arm)>>

<<constant C_SCOND(arm)>>
<<constant C_SBIT(arm)>>
<<constant C_PBIT(arm)>>
<<constant C_WBIT(arm)>>
<<constant C_FBIT(arm)>>
<<constant C_UBIT(arm)>>

<<constant D_GOK(arm)>>
<<constant D_NONE(arm)>>

<<constant D_BRANCH(arm)>>
<<constant D_OREG(arm)>>

<<constant D_CONST(arm)>>
<<constant D_FCONST(arm)>>
<<constant D_SCONST(arm)>>
<<constant D_PSR(arm)>>
<<constant D_REG(arm)>>
<<constant D_FREG(arm)>>
<<constant D_FILE(arm)>>
<<constant D_OCONST(arm)>>
<<constant D_FILE1(arm)>>

<<constant D_SHIFT(arm)>>
<<constant D_FPCR(arm)>>
<<constant D_REGREG(arm)>>
<<constant D_ADDR(arm)>>

<<constant D_EXTERN(arm)>>
<<constant D_STATIC(arm)>>
<<constant D_AUTO(arm)>>
<<constant D_PARAM(arm)>>

<<constant SYMDEF(arm)>>
@


\section{[[include/386/]]}

\subsection*{[[include/386/8.out.h]]}


% todo: transform in an enum? 
% note that it's not used by 8a, used by 8c/8l
<<constant NOPROF(x86)>>=
#define NOPROF	(1<<0)
@

% used by 8l (to allow override existing symbol? 8l option?)
<<constant DUPOK(x86)>>=
#define DUPOK	(1<<1)
@

% dead?
<<constant NOSPLIT(x86)>>=
#define NOSPLIT	(1<<2)
@


% used by ar?
<<constant SYMDEF(x86)>>=
/*
 * this is the ranlib header
 */
#define	SYMDEF	"__.SYMDEF"
@


%-------------------------------------------------------------

<<include/386/8.out.h>>=

<<constant NSNAME(x86)>>
<<constant NOPROF(x86)>>
<<constant DUPOK(x86)>>
<<constant NOSPLIT(x86)>>

<<enum as(x86)>>

<<enum reg(x86)>>

<<enum misc2(x86)>>
<<enum misc3(x86)>>

<<constant SYMDEF(x86)>>
@


\section{[[assemblers/misc/]]}

\subsection*{[[assemblers/misc/data2s.c]]}

<<function main>>=
void
main(int argc, char *argv[])
{
    Biobuf bin, bout;
    long len, slen;
    int c;

    if(argc != 2){
        fprint(2, "usage: data2s name\n");
        exits("usage");
    }
    Binit(&bin, 0, OREAD);
    Binit(&bout, 1, OWRITE);
    for(len=0; (c=Bgetc(&bin))!=Beof; len++){
        if((len&7) == 0)
            Bprint(&bout, "DATA %scode+%ld(SB)/8, $\"", argv[1], len);
        if(c)
            Bprint(&bout, "\\%uo", c);
        else
            Bprint(&bout, "\\z");
        if((len&7) == 7)
            Bprint(&bout, "\"\n");
    }
    slen = len;
    if(len & 7){
        while(len & 7){
            Bprint(&bout, "\\z");
            len++;
        }
        Bprint(&bout, "\"\n");
    }
    Bprint(&bout, "GLOBL %scode+0(SB), $%ld\n", argv[1], len);
    Bprint(&bout, "GLOBL %slen+0(SB), $4\n", argv[1]);
    Bprint(&bout, "DATA %slen+0(SB)/4, $%ld\n", argv[1], slen);
    exits(0);
}
@


%-------------------------------------------------------------

<<assemblers/misc/data2s.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>

<<function main>>
@


\section{[[assemblers/aa/]]}

\subsection*{[[assemblers/aa/aa.h]]}


<<enum _anon_ (assemblers/aa/aa.h)>>=
/*
 *	system-dependent stuff from ../cc/compat.c
 */
enum	/* keep in synch with ../cc/cc.h */
{
    Plan9	= 1<<0,
    Unix	= 1<<1,
};
@


%-------------------------------------------------------------

<<assemblers/aa/aa.h>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <ctype.h>

// aa.h  is the generic part, the specific #include XXX/Y.out.h is done
// in Ya/a.h, e.g.:
//#include "386/8.out.h"
//#include "arm/5.out.h"
#include <common.out.h>

#pragma	lib	"../aa/aa.a$O"
//$

// was originally in a XXX/Y.out.h (and was always the same in all archi)
// most of the content below was originally copy pasted in 8a/a.h, 5a/a.h, etc

typedef	struct	Sym	Sym;
typedef struct  Io Io;
typedef	struct	Hist Hist;

<<constant MAXALIGN>>
<<constant NSYMB>>
<<constant BUFSIZ>>
<<constant HISTSZ>>
<<constant NINCLUDE>>
<<constant NHUNK>>
<<constant EOF>>
<<constant IGN>>
<<function GETC>>
<<constant NHASH>>
<<constant STRINGSZ>>


<<struct Sym>>
<<constant S>>

<<struct Fi>>
extern struct Fi fi;

<<struct Io>>
<<constant I>>

<<struct Htab>>
extern struct Htab h[NSYM];

// Gen

<<struct Hist>>
<<constant H>>



// was in a.h
extern	Sym*	hash[NHASH];
extern	Hist*	hist;
extern	char*	hunk;
extern	char*	include[NINCLUDE];
extern	Io*	iofree;
extern	Io*	ionext;
extern	Io*	iostack;
extern	long	lineno;
extern	int	nerrors;
extern	long	nhunk;
extern	int	ninclude;
extern	char*	outfile;
extern	long	pc;
extern	int	peekc;
extern	int	symcounter;
extern	char	symb[NSYMB];
extern	int	thechar;

// for macbody, was in a.h
extern	bool	debug[256];
extern	Hist*	ehist;
extern	int	newflag;
extern	long	thunk;

// for lexbody, was in a.h
int	getnsc(void);
void	gethunk(void);
void	yyerror(char*, ...);
void	linehist(char*, int);
Sym*	lookup(void);
void	syminit(Sym*);
int	filbuf(void);
void	domacro(void);
void	macexpand(Sym*, char*);

// for macbody, was in a.h
int	getc(void);
void	unget(int);
Sym*	slookup(char*);

// for macbody, was in lexbody
void pragpack(void);
void pragfpround(void);
void pragprofile(void);
void pragvararg(void);
void* alloc(long n);
void pragincomplete(void);
void* allocn(void *p, long on, long n);
void	pushio(void);
void	newio(void);
void	newfile(char*, int);
void	errorexit(void);

// from lexbody.c
void ieeedtod(Ieee *ieee, double native);

<<enum _anon_ (assemblers/aa/aa.h)>>
@
%$


\subsection*{[[assemblers/aa/compat.c]]}

<<function mycreat>>=
int
mycreat(char *n, int p)
{

    return create(n, 1, p);
}
@

<<function mywait>>=
int
mywait(int *s)
{
    int p;
    Waitmsg *w;

    if((w = wait()) == nil)
        return -1;
    else{
        p = w->pid;
        *s = 0;
        if(w->msg[0])
            *s = 1;
        free(w);
        return p;
    }
}
@


<<function systemtype>>=
int
systemtype(int sys)
{
    return sys & Plan9;
}
@

%-------------------------------------------------------------

<<assemblers/aa/compat.c>>=
#include "aa.h"


<<function mycreat>>

<<function mywait>>

<<function systemtype>>

<<function pathchar>>

@


\subsection*{[[assemblers/aa/globals.c]]}


%-------------------------------------------------------------

<<assemblers/aa/globals.c>>=
#include "aa.h"

<<global fi>>
<<global h>>

<<global debug>>
<<global hash>>
<<global Dlist>>
<<global nDlist>>
<<global ehist>>
<<global newflag>>
<<global hist>>
<<global hunk>>
<<global include>>
<<global iofree>>
<<global ionext>>
<<global iostack>>
<<global lineno>>
<<global nerrors>>
<<global nhunk>>
<<global ninclude>>
<<global outfile>>
<<global pass>>
<<global pathname>>
<<global pc>>
<<global peekc>>
<<global symcounter>>
<<global symb>>
<<global thechar>>
<<global thestring>>
<<global thunk>>
<<global obuf>>
@


\subsection*{[[assemblers/aa/lexbody.c]]}


%-------------------------------------------------------------

<<assemblers/aa/lexbody.c>>=
#include "aa.h"

void prfile(long l);

/*
 * common code for all the assemblers
 */

<<function alloc>>

<<function allocn>>

<<function setinclude>>

<<function errorexit>>

<<function pushio>>

<<function newio>>

<<function newfile>>

<<function slookup>>

<<function lookup>>

// this was hard to factorize in aa/, so this is copy pasted
// in each assembler (8a/, va/, etc)
//long
//yylex(void)
//{
//	int c, c1;
//	char *cp;
//	Sym *s;
//
//	c = peekc;
//	if(c != IGN) {
//		peekc = IGN;
//		goto l1;
//	}
//l0:
//	c = GETC();
//
//l1:
//	if(c == EOF) {
//		peekc = EOF;
//		return -1;
//	}
//	if(isspace(c)) {
//		if(c == '\n') {
//			lineno++;
//			return ';';
//		}
//		goto l0;
//	}
//	if(isalpha(c))
//		goto talph;
//	if(isdigit(c))
//		goto tnum;
//	switch(c)
//	{
//	case '\n':
//		lineno++;
//		return ';';
//
//	case '#':
//		domacro();
//		goto l0;
//
//	case '.':
//		c = GETC();
//		if(isalpha(c)) {
//			cp = symb;
//			*cp++ = '.';
//			goto aloop;
//		}
//		if(isdigit(c)) {
//			cp = symb;
//			*cp++ = '.';
//			goto casedot;
//		}
//		peekc = c;
//		return '.';
//
//	talph:
//	case '_':
//	case '@':
//		cp = symb;
//
//	aloop:
//		*cp++ = c;
//		c = GETC();
//		if(isalpha(c) || isdigit(c) || c == '_' || c == '$')
//			goto aloop;
//		*cp = 0;
//		peekc = c;
//		s = lookup();
//		if(s->macro) {
//			newio();
//			cp = ionext->b;
//			macexpand(s, cp);
//			pushio();
//			ionext->link = iostack;
//			iostack = ionext;
//			fi.p = cp;
//			fi.c = strlen(cp);
//			if(peekc != IGN) {
//				cp[fi.c++] = peekc;
//				cp[fi.c] = 0;
//				peekc = IGN;
//			}
//			goto l0;
//		}
//		if(s->type == 0)
//			s->type = LNAME;
//		if(s->type == LNAME ||
//		   s->type == LVAR ||
//		   s->type == LLAB) {
//			yylval.sym = s;
//			return s->type;
//		}
//		yylval.lval = s->value;
//		return s->type;
//
//	tnum:
//		cp = symb;
//		if(c != '0')
//			goto dc;
//		*cp++ = c;
//		c = GETC();
//		c1 = 3;
//		if(c == 'x' || c == 'X') {
//			c1 = 4;
//			c = GETC();
//		} else
//		if(c < '0' || c > '7')
//			goto dc;
//		yylval.lval = 0;
//		for(;;) {
//			if(c >= '0' && c <= '9') {
//				if(c > '7' && c1 == 3)
//					break;
//				yylval.lval <<= c1;
//				yylval.lval += c - '0';
//				c = GETC();
//				continue;
//			}
//			if(c1 == 3)
//				break;
//			if(c >= 'A' && c <= 'F')
//				c += 'a' - 'A';
//			if(c >= 'a' && c <= 'f') {
//				yylval.lval <<= c1;
//				yylval.lval += c - 'a' + 10;
//				c = GETC();
//				continue;
//			}
//			break;
//		}
//		goto ncu;
//
//	dc:
//		for(;;) {
//			if(!isdigit(c))
//				break;
//			*cp++ = c;
//			c = GETC();
//		}
//		if(c == '.')
//			goto casedot;
//		if(c == 'e' || c == 'E')
//			goto casee;
//		*cp = 0;
//		if(sizeof(yylval.lval) == sizeof(vlong))
//			yylval.lval = strtoll(symb, nil, 10);
//		else
//			yylval.lval = strtol(symb, nil, 10);
//
//	ncu:
//		while(c == 'U' || c == 'u' || c == 'l' || c == 'L')
//			c = GETC();
//		peekc = c;
//		return LCONST;
//
//	casedot:
//		for(;;) {
//			*cp++ = c;
//			c = GETC();
//			if(!isdigit(c))
//				break;
//		}
//		if(c == 'e' || c == 'E')
//			goto casee;
//		goto caseout;
//
//	casee:
//		*cp++ = 'e';
//		c = GETC();
//		if(c == '+' || c == '-') {
//			*cp++ = c;
//			c = GETC();
//		}
//		while(isdigit(c)) {
//			*cp++ = c;
//			c = GETC();
//		}
//
//	caseout:
//		*cp = 0;
//		peekc = c;
//		if(FPCHIP) {
//			yylval.dval = atof(symb);
//			return LFCONST;
//		}
//		yyerror("assembler cannot interpret fp constants");
//		yylval.lval = 1L;
//		return LCONST;
//
//	case '"':
//		memcpy(yylval.sval, nullgen.sval, sizeof(yylval.sval));
//		cp = yylval.sval;
//		c1 = 0;
//		for(;;) {
//			c = escchar('"');
//			if(c == EOF)
//				break;
//			if(c1 < sizeof(yylval.sval))
//				*cp++ = c;
//			c1++;
//		}
//		if(c1 > sizeof(yylval.sval))
//			yyerror("string constant too long");
//		return LSCONST;
//
//	case '\'':
//		c = escchar('\'');
//		if(c == EOF)
//			c = '\'';
//		if(escchar('\'') != EOF)
//			yyerror("missing '");
//		yylval.lval = c;
//		return LCONST;
//
//	case '/':
//		c1 = GETC();
//		if(c1 == '/') {
//			for(;;) {
//				c = GETC();
//				if(c == '\n')
//					goto l1;
//				if(c == EOF) {
//					yyerror("eof in comment");
//					errorexit();
//				}
//			}
//		}
//		if(c1 == '*') {
//			for(;;) {
//				c = GETC();
//				while(c == '*') {
//					c = GETC();
//					if(c == '/')
//						goto l0;
//				}
//				if(c == EOF) {
//					yyerror("eof in comment");
//					errorexit();
//				}
//				if(c == '\n')
//					lineno++;
//			}
//		}
//		break;
//
//	default:
//		return c;
//	}
//	peekc = c1;
//	return c;
//}



<<function getc>>

<<function getnsc>>

<<function unget>>

<<function escchar>>

<<function pinit>>

<<function filbuf>>

<<function yyerror>>

<<function prfile>>

<<function ieeedtod>>
@
%$

%<<function pragpack>>
%
%<<function pragvararg>>
%
%<<function pragfpround>>
%
%<<function pragprofile>>
%
%<<function pragincomplete>>


\subsection*{[[assemblers/aa/macbody.c]]}


%-------------------------------------------------------------

<<assemblers/aa/macbody.c>>=
#include "aa.h"

void	macund(void);
void	macdef(void);
void	macinc(void);
void	macprag(void);
void	maclin(void);
void	macif(int);
void	macend(void);

<<constant VARMAC>>

<<function getnsn>>

<<function getsym>>

<<function getsymdots>>

<<function getcom>>

<<function dodefine>>

<<global mactab>>

<<function domacro>>

<<function macund>>

<<constant NARG>>
<<function macdef>>

<<function macexpand>>

<<function macinc>>

<<function maclin>>

<<function macif>>

<<function macprag>>

<<function macend>>

<<function linehist>>

<<function gethunk>>
@



\section{[[assemblers/5a/]]}

\subsection*{[[assemblers/5a/a.h]]}

<<constant FPCHIP(arm)>>=
#define	FPCHIP		true
@

<<constant NMACRO(arm)>>=
#define	NMACRO		10
@

<<struct Gen(arm)>>=
struct	Gen
{
    Sym*	sym;
    long	offset;
    short	type;
    short	reg;
    short	name;
    double	dval;
    char	sval[8];
};
@

<<enum _anon_(arm)>>=
enum
{
    CLAST,
    CMACARG,
    CMACRO,
    CPREPROC,

    Always	= 14,
};
@


%-------------------------------------------------------------

<<assemblers/5a/a.h>>=
#include "../aa/aa.h"
#include "arm/5.out.h"

//#define	NSYMB		8192

typedef	struct	Gen	Gen;

<<constant FPCHIP(arm)>>
<<constant NMACRO(arm)>>

<<struct Gen(arm)>>

<<enum _anon_(arm)>>

extern	char*	Dlist[30];
extern	int	nDlist;
extern	Gen	nullgen;
extern	int	pass;
extern	char*	pathname;
extern	char*	thestring;
extern	Biobuf	obuf;

// for a.y
long	yylex(void);
void	outcode(int, int, Gen*, int, Gen*);

int	escchar(int);
//Sym*	getsym(void);

// for lexbody
void	setinclude(char*);
void*	allocn(void*, long, long);
void	errorexit(void);
Sym*	slookup(char*);
void	pinit(char*);
void	ieeedtod(Ieee*, double);
void	dodefine(char*);
void	yyerror(char*, ...);
int	yyparse(void);

// for macbody
int	getc(void);
void	unget(int);
void	pushio(void);
void	newio(void);
void	newfile(char*, int);

int	mywait(int*);
int	mycreat(char*, int);
int	systemtype(int);
int	pathchar(void);


// TODO remove?
void*	alloc(long);
Sym*	lookup(void);
void	syminit(Sym*);
int	getnsc(void);
void	cinit(void);
void	cclean(void);
int	isreg(Gen*);
void	zname(char*, int, int);
void	zaddr(Gen*, int);
int	filbuf(void);
void	domacro(void);
void	macund(void);
void	macdef(void);
void	macexpand(Sym*, char*);
void	macinc(void);
void	maclin(void);
void	macprag(void);
void	macif(int);
void	macend(void);
void	outhist(void);
void	prfile(long);
void	linehist(char*, int);
void	gethunk(void);
int	assemble(char*);

@


\subsection*{[[assemblers/5a/globals.c]]}

<<global nullgen(arm)>>=
Gen	nullgen;
@


%-------------------------------------------------------------

<<assemblers/5a/globals.c>>=
#include "a.h"

<<global nullgen(arm)>>
@


\subsection*{[[assemblers/5a/lex.c]]}

<<function main(arm)>>=
void
main(int argc, char *argv[])
{
    char *p;
    int nout, nproc, status, i, c;

    thechar = '5';
    thestring = "arm";
    memset(debug, 0, sizeof(debug));
    cinit();
    outfile = 0;
    include[ninclude++] = ".";
    ARGBEGIN {
    default:
        c = ARGC();
        if(c >= 0 || c < sizeof(debug))
            debug[c] = 1;
        break;

    case 'o':
        outfile = ARGF();
        break;

    case 'D':
        p = ARGF();
        if(p)
            Dlist[nDlist++] = p;
        break;

    case 'I':
        p = ARGF();
        setinclude(p);
        break;
    case 't':
        thechar = 't';
        thestring = "thumb";
        break;
    } ARGEND
    if(*argv == 0) {
        print("usage: %ca [-options] file.s\n", thechar);
        errorexit();
    }
    if(argc > 1) {
        nproc = 1;
        if(p = getenv("NPROC"))
            nproc = atol(p);	/* */
        c = 0;
        nout = 0;
        for(;;) {
            while(nout < nproc && argc > 0) {
                i = fork();
                if(i < 0) {
                    i = mywait(&status);
                    if(i < 0)
                        errorexit();
                    if(status)
                        c++;
                    nout--;
                    continue;
                }
                if(i == 0) {
                    print("%s:\n", *argv);
                    if(assemble(*argv))
                        errorexit();
                    exits(0);
                }
                nout++;
                argc--;
                argv++;
            }
            i = mywait(&status);
            if(i < 0) {
                if(c)
                    errorexit();
                exits(0);
            }
            if(status)
                c++;
            nout--;
        }
    }
    if(assemble(argv[0]))
        errorexit();
    exits(0);
}
@

<<function assemble(arm)>>=
int
assemble(char *file)
{
    char ofile[100], incfile[20], *p;
    int i, of;

    strcpy(ofile, file);
    p = utfrrune(ofile, pathchar());
    if(p) {
        include[0] = ofile;
        *p++ = 0;
    } else
        p = ofile;
    if(outfile == 0) {
        outfile = p;
        if(outfile){
            p = utfrrune(outfile, '.');
            if(p)
                if(p[1] == 's' && p[2] == 0)
                    p[0] = 0;
            p = utfrune(outfile, 0);
            p[0] = '.';
            p[1] = thechar;
            p[2] = 0;
        } else
            outfile = "/dev/null";
    }
    p = getenv("INCLUDE");
    if(p) {
        setinclude(p);
    } else {
        if(systemtype(Plan9)) {
            sprint(incfile,"/%s/include", thestring);
            setinclude(strdup(incfile));
        }
    }

    of = mycreat(outfile, 0664);
    if(of < 0) {
        yyerror("%ca: cannot create %s", thechar, outfile);
        errorexit();
    }
    Binit(&obuf, of, OWRITE);

    pass = 1;
    pinit(file);
    for(i=0; i<nDlist; i++)
        dodefine(Dlist[i]);
    yyparse();
    if(nerrors) {
        cclean();
        return nerrors;
    }

    pass = 2;
    outhist();
    pinit(file);
    for(i=0; i<nDlist; i++)
        dodefine(Dlist[i]);
    yyparse();
    cclean();
    return nerrors;
}
@

<<global itab(arm)>>=
struct
{
    char	*name;
    ushort	type;
    ushort	value;
} itab[] =
{
    "SP",		LSP,	D_AUTO,
    "SB",		LSB,	D_EXTERN,
    "FP",		LFP,	D_PARAM,
    "PC",		LPC,	D_BRANCH,

    "R",		LR,	0,
    "R0",		LREG,	0,
    "R1",		LREG,	1,
    "R2",		LREG,	2,
    "R3",		LREG,	3,
    "R4",		LREG,	4,
    "R5",		LREG,	5,
    "R6",		LREG,	6,
    "R7",		LREG,	7,
    "R8",		LREG,	8,
    "R9",		LREG,	9,
    "R10",		LREG,	10,
    "R11",		LREG,	11,
    "R12",		LREG,	12,
    "R13",		LREG,	13,
    "R14",		LREG,	14,
    "R15",		LREG,	15,

    "F",		LF,	0,

    "F0",		LFREG,	0,
    "F1",		LFREG,	1,
    "F2",		LFREG,	2,
    "F3",		LFREG,	3,
    "F4",		LFREG,	4,
    "F5",		LFREG,	5,
    "F6",		LFREG,	6,
    "F7",		LFREG,	7,
    "F8",		LFREG,	8,
    "F9",		LFREG,	9,
    "F10",		LFREG,	10,
    "F11",		LFREG,	11,
    "F12",		LFREG,	12,
    "F13",		LFREG,	13,
    "F14",		LFREG,	14,
    "F15",		LFREG,	15,

    "C",		LC,	0,

    "C0",		LCREG,	0,
    "C1",		LCREG,	1,
    "C2",		LCREG,	2,
    "C3",		LCREG,	3,
    "C4",		LCREG,	4,
    "C5",		LCREG,	5,
    "C6",		LCREG,	6,
    "C7",		LCREG,	7,
    "C8",		LCREG,	8,
    "C9",		LCREG,	9,
    "C10",		LCREG,	10,
    "C11",		LCREG,	11,
    "C12",		LCREG,	12,
    "C13",		LCREG,	13,
    "C14",		LCREG,	14,
    "C15",		LCREG,	15,

    "CPSR",		LPSR,	0,
    "SPSR",		LPSR,	1,

    "FPSR",		LFCR,	0,
    "FPCR",		LFCR,	1,

    ".EQ",		LCOND,	0,
    ".NE",		LCOND,	1,
    ".CS",		LCOND,	2,
    ".HS",		LCOND,	2,
    ".CC",		LCOND,	3,
    ".LO",		LCOND,	3,
    ".MI",		LCOND,	4,
    ".PL",		LCOND,	5,
    ".VS",		LCOND,	6,
    ".VC",		LCOND,	7,
    ".HI",		LCOND,	8,
    ".LS",		LCOND,	9,
    ".GE",		LCOND,	10,
    ".LT",		LCOND,	11,
    ".GT",		LCOND,	12,
    ".LE",		LCOND,	13,
    ".AL",		LCOND,	Always,

    ".U",		LS,	C_UBIT,
    ".S",		LS,	C_SBIT,
    ".W",		LS,	C_WBIT,
    ".P",		LS,	C_PBIT,
    ".PW",		LS,	C_WBIT|C_PBIT,
    ".WP",		LS,	C_WBIT|C_PBIT,

    ".F",		LS,	C_FBIT,

    ".IBW",		LS,	C_WBIT|C_PBIT|C_UBIT,
    ".IAW",		LS,	C_WBIT|C_UBIT,
    ".DBW",		LS,	C_WBIT|C_PBIT,
    ".DAW",		LS,	C_WBIT,
    ".IB",		LS,	C_PBIT|C_UBIT,
    ".IA",		LS,	C_UBIT,
    ".DB",		LS,	C_PBIT,
    ".DA",		LS,	0,

    "@",		LAT,	0,

    "AND",		LTYPE1,	AAND,
    "EOR",		LTYPE1,	AEOR,
    "SUB",		LTYPE1,	ASUB,
    "RSB",		LTYPE1,	ARSB,
    "ADD",		LTYPE1,	AADD,
    "ADC",		LTYPE1,	AADC,
    "SBC",		LTYPE1,	ASBC,
    "RSC",		LTYPE1,	ARSC,
    "ORR",		LTYPE1,	AORR,
    "BIC",		LTYPE1,	ABIC,

    "SLL",		LTYPE1,	ASLL,
    "SRL",		LTYPE1,	ASRL,
    "SRA",		LTYPE1,	ASRA,

    "MUL",		LTYPE1, AMUL,
    "MULA",		LTYPEN, AMULA,
    "DIV",		LTYPE1,	ADIV,
    "MOD",		LTYPE1,	AMOD,

    "MULL",		LTYPEM, AMULL,
    "MULAL",	LTYPEM, AMULAL,
    "MULLU",	LTYPEM, AMULLU,
    "MULALU",	LTYPEM, AMULALU,

    "MVN",		LTYPE2, AMVN,	/* op2 ignored */

    "MOVB",		LTYPE3, AMOVB,
    "MOVBU",	LTYPE3, AMOVBU,
    "MOVH",		LTYPE3, AMOVH,
    "MOVHU",	LTYPE3, AMOVHU,
    "MOVW",		LTYPE3, AMOVW,

    "MOVD",		LTYPE3, AMOVD,
    "MOVDF",		LTYPE3, AMOVDF,
    "MOVDW",	LTYPE3, AMOVDW,
    "MOVF",		LTYPE3, AMOVF,
    "MOVFD",		LTYPE3, AMOVFD,
    "MOVFW",		LTYPE3, AMOVFW,
    "MOVWD",	LTYPE3, AMOVWD,
    "MOVWF",		LTYPE3, AMOVWF,

    "LDREX",		LTYPE3, ALDREX,
    "LDREXD",		LTYPE3, ALDREXD,
    "STREX",		LTYPE9, ASTREX,
    "STREXD",		LTYPE9, ASTREXD,

/*
    "ABSF",		LTYPEI, AABSF,
    "ABSD",		LTYPEI, AABSD,
    "NEGF",		LTYPEI, ANEGF,
    "NEGD",		LTYPEI, ANEGD,
    "SQTF",		LTYPEI,	ASQTF,
    "SQTD",		LTYPEI,	ASQTD,
    "RNDF",		LTYPEI,	ARNDF,
    "RNDD",		LTYPEI,	ARNDD,
    "URDF",		LTYPEI,	AURDF,
    "URDD",		LTYPEI,	AURDD,
    "NRMF",		LTYPEI,	ANRMF,
    "NRMD",		LTYPEI,	ANRMD,
*/

    "SQRTF",	LTYPEI, ASQRTF,
    "SQRTD",	LTYPEI, ASQRTD,
    "CMPF",		LTYPEL, ACMPF,
    "CMPD",		LTYPEL, ACMPD,
    "ADDF",		LTYPEK,	AADDF,
    "ADDD",		LTYPEK,	AADDD,
    "SUBF",		LTYPEK,	ASUBF,
    "SUBD",		LTYPEK,	ASUBD,
    "MULF",		LTYPEK,	AMULF,
    "MULD",		LTYPEK,	AMULD,
    "DIVF",		LTYPEK,	ADIVF,
    "DIVD",		LTYPEK,	ADIVD,

    "B",		LTYPE4, AB,
    "BL",		LTYPE4, ABL,
    "BX",		LTYPEBX,	ABX,

    "BEQ",		LTYPE5,	ABEQ,
    "BNE",		LTYPE5,	ABNE,
    "BCS",		LTYPE5,	ABCS,
    "BHS",		LTYPE5,	ABHS,
    "BCC",		LTYPE5,	ABCC,
    "BLO",		LTYPE5,	ABLO,
    "BMI",		LTYPE5,	ABMI,
    "BPL",		LTYPE5,	ABPL,
    "BVS",		LTYPE5,	ABVS,
    "BVC",		LTYPE5,	ABVC,
    "BHI",		LTYPE5,	ABHI,
    "BLS",		LTYPE5,	ABLS,
    "BGE",		LTYPE5,	ABGE,
    "BLT",		LTYPE5,	ABLT,
    "BGT",		LTYPE5,	ABGT,
    "BLE",		LTYPE5,	ABLE,
    "BCASE",	LTYPE5,	ABCASE,

    "SWI",		LTYPE6, ASWI,

    "CMP",		LTYPE7,	ACMP,
    "TST",		LTYPE7,	ATST,
    "TEQ",		LTYPE7,	ATEQ,
    "CMN",		LTYPE7,	ACMN,

    "MOVM",		LTYPE8, AMOVM,

    "SWPBU",	LTYPE9, ASWPBU,
    "SWPW",		LTYPE9, ASWPW,

    "RET",		LTYPEA, ARET,
    "RFE",		LTYPEA, ARFE,

    "TEXT",		LTYPEB, ATEXT,
    "GLOBL",	LTYPEB, AGLOBL,
    "DATA",		LTYPEC, ADATA,
    "CASE",		LTYPED, ACASE,
    "END",		LTYPEE, AEND,
    "WORD",		LTYPEH, AWORD,
    "NOP",		LTYPEI, ANOP,

    "MCR",		LTYPEJ, 0,
    "MRC",		LTYPEJ, 1,
    0
};
@

<<function cinit(arm)>>=
void
cinit(void)
{
    Sym *s;
    int i;

    nullgen.sym = S;
    nullgen.offset = 0;
    nullgen.type = D_NONE;
    nullgen.name = D_NONE;
    nullgen.reg = NREG;
    if(FPCHIP)
        nullgen.dval = 0;
    for(i=0; i<sizeof(nullgen.sval); i++)
        nullgen.sval[i] = 0;

    nerrors = 0;
    iostack = I;
    iofree = I;
    peekc = IGN;
    nhunk = 0;
    for(i=0; i<NHASH; i++)
        hash[i] = S;
    for(i=0; itab[i].name; i++) {
        s = slookup(itab[i].name);
        s->type = itab[i].type;
        s->value = itab[i].value;
    }

    pathname = allocn(pathname, 0, 100);
    if(getwd(pathname, 99) == 0) {
        pathname = allocn(pathname, 100, 900);
        if(getwd(pathname, 999) == 0)
            strcpy(pathname, "/???");
    }
}
@

<<function syminit(arm)>>=
void
syminit(Sym *s)
{

    s->type = LNAME;
    s->value = 0;
}
@

<<function isreg(arm)>>=
int
isreg(Gen *g)
{

    USED(g);
    return 1;
}
@

<<function cclean(arm)>>=
void
cclean(void)
{

    outcode(AEND, Always, &nullgen, NREG, &nullgen);
    Bflush(&obuf);
}
@

<<function zname(arm)>>=
void
zname(char *n, int t, int s)
{

    Bputc(&obuf, ANAME);
    Bputc(&obuf, t);	/* type */
    Bputc(&obuf, s);	/* sym */
    while(*n) {
        Bputc(&obuf, *n);
        n++;
    }
    Bputc(&obuf, 0);
}
@

<<function zaddr(arm)>>=
void
zaddr(Gen *a, int s)
{
    long l;
    int i;
    char *n;
    Ieee e;

    Bputc(&obuf, a->type);
    Bputc(&obuf, a->reg);
    Bputc(&obuf, s);
    Bputc(&obuf, a->name);
    switch(a->type) {
    default:
        print("unknown type %d\n", a->type);
        exits("arg");

    case D_NONE:
    case D_REG:
    case D_FREG:
    case D_PSR:
    case D_FPCR:
        break;

    case D_REGREG:
        Bputc(&obuf, a->offset);
        break;

    case D_OREG:
    case D_CONST:
    case D_BRANCH:
    case D_SHIFT:
        l = a->offset;
        Bputc(&obuf, l);
        Bputc(&obuf, l>>8);
        Bputc(&obuf, l>>16);
        Bputc(&obuf, l>>24);
        break;

    case D_SCONST:
        n = a->sval;
        for(i=0; i<NSNAME; i++) {
            Bputc(&obuf, *n);
            n++;
        }
        break;

    case D_FCONST:
        ieeedtod(&e, a->dval);
        Bputc(&obuf, e.l);
        Bputc(&obuf, e.l>>8);
        Bputc(&obuf, e.l>>16);
        Bputc(&obuf, e.l>>24);
        Bputc(&obuf, e.h);
        Bputc(&obuf, e.h>>8);
        Bputc(&obuf, e.h>>16);
        Bputc(&obuf, e.h>>24);
        break;
    }
}
@

<<global bcode(arm)>>=
static int bcode[] =
{
    ABEQ,
    ABNE,
    ABCS,
    ABCC,
    ABMI,
    ABPL,
    ABVS,
    ABVC,
    ABHI,
    ABLS,
    ABGE,
    ABLT,
    ABGT,
    ABLE,
    AB,
    ANOP,
};
@

<<function outcode(arm)>>=
void
outcode(int a, int scond, Gen *g1, int reg, Gen *g2)
{
    int sf, st, t;
    Sym *s;

    /* hack to make B.NE etc. work: turn it into the corresponding conditional */
    if(a == AB){
        a = bcode[scond&0xf];
        scond = (scond & ~0xf) | Always;
    }

    if(pass == 1)
        goto out;
jackpot:
    sf = 0;
    s = g1->sym;
    while(s != S) {
        sf = s->symidx;
        if(sf < 0 || sf >= NSYM)
            sf = 0;
        t = g1->name;
        if(h[sf].type == t)
        if(h[sf].sym == s)
            break;
        zname(s->name, t, symcounter);
        s->symidx = symcounter;
        h[symcounter].sym = s;
        h[symcounter].type = t;
        sf = symcounter;
        symcounter++;
        if(symcounter >= NSYM)
            symcounter = 1;
        break;
    }
    st = 0;
    s = g2->sym;
    while(s != S) {
        st = s->symidx;
        if(st < 0 || st >= NSYM)
            st = 0;
        t = g2->name;
        if(h[st].type == t)
        if(h[st].sym == s)
            break;
        zname(s->name, t, symcounter);
        s->symidx = symcounter;
        h[symcounter].sym = s;
        h[symcounter].type = t;
        st = symcounter;
        symcounter++;
        if(symcounter >= NSYM)
            symcounter = 1;
        if(st == sf)
            goto jackpot;
        break;
    }
    Bputc(&obuf, a);
    Bputc(&obuf, scond);
    Bputc(&obuf, reg);
    Bputc(&obuf, lineno);
    Bputc(&obuf, lineno>>8);
    Bputc(&obuf, lineno>>16);
    Bputc(&obuf, lineno>>24);
    zaddr(g1, sf);
    zaddr(g2, st);

out:
    if(a != AGLOBL && a != ADATA)
        pc++;
}
@

<<function outhist(arm)>>=
void
outhist(void)
{
    Gen g;
    Hist *h;
    char *p, *q, *op, c;
    int n;

    g = nullgen;
    c = pathchar();
    for(h = hist; h != H; h = h->link) {
        p = h->name;
        op = 0;
        if(p && p[0] != c && h->offset == 0 && pathname){
            if(pathname[0] == c){
                op = p;
                p = pathname;
            }
        }
        while(p) {
            q = strchr(p, c);
            if(q) {
                n = q-p;
                if(n == 0){
                    n = 1;	/* leading "/" */
                    *p = '/';	/* don't emit "\" on windows */
                }
                q++;
            } else {
                n = strlen(p);
                q = 0;
            }
            if(n) {
                Bputc(&obuf, ANAME);
                Bputc(&obuf, D_FILE);	/* type */
                Bputc(&obuf, 1);	/* sym */
                Bputc(&obuf, '<');
                Bwrite(&obuf, p, n);
                Bputc(&obuf, 0);
            }
            p = q;
            if(p == 0 && op) {
                p = op;
                op = 0;
            }
        }
        g.offset = h->offset;

        Bputc(&obuf, AHISTORY);
        Bputc(&obuf, Always);
        Bputc(&obuf, 0);
        Bputc(&obuf, h->line);
        Bputc(&obuf, h->line>>8);
        Bputc(&obuf, h->line>>16);
        Bputc(&obuf, h->line>>24);
        zaddr(&nullgen, 0);
        zaddr(&g, 0);
    }
}
@

<<function yylex(arm)>>=
//
long
yylex(void)
{
    int c, c1;
    char *cp;
    Sym *s;

    c = peekc;
    if(c != IGN) {
        peekc = IGN;
        goto l1;
    }
l0:
    c = GETC();

l1:
    if(c == EOF) {
        peekc = EOF;
        return -1;
    }
    if(isspace(c)) {
        if(c == '\n') {
            lineno++;
            return ';';
        }
        goto l0;
    }
    if(isalpha(c))
        goto talph;
    if(isdigit(c))
        goto tnum;
    switch(c)
    {
    case '\n':
        lineno++;
        return ';';

    case '#':
        domacro();
        goto l0;

    case '.':
        c = GETC();
        if(isalpha(c)) {
            cp = symb;
            *cp++ = '.';
            goto aloop;
        }
        if(isdigit(c)) {
            cp = symb;
            *cp++ = '.';
            goto casedot;
        }
        peekc = c;
        return '.';

    talph:
    case '_':
    case '@':
        cp = symb;

    aloop:
        *cp++ = c;
        c = GETC();
        if(isalpha(c) || isdigit(c) || c == '_' || c == '$')
            goto aloop;
        *cp = 0;
        peekc = c;
        s = lookup();
        if(s->macro) {
            newio();
            cp = ionext->b;
            macexpand(s, cp);
            pushio();
            ionext->link = iostack;
            iostack = ionext;
            fi.p = cp;
            fi.c = strlen(cp);
            if(peekc != IGN) {
                cp[fi.c++] = peekc;
                cp[fi.c] = 0;
                peekc = IGN;
            }
            goto l0;
        }
        if(s->type == 0)
            s->type = LNAME;
        if(s->type == LNAME ||
           s->type == LVAR ||
           s->type == LLAB) {
            yylval.sym = s;
            return s->type;
        }
        yylval.lval = s->value;
        return s->type;

    tnum:
        cp = symb;
        if(c != '0')
            goto dc;
        *cp++ = c;
        c = GETC();
        c1 = 3;
        if(c == 'x' || c == 'X') {
            c1 = 4;
            c = GETC();
        } else
        if(c < '0' || c > '7')
            goto dc;
        yylval.lval = 0;
        for(;;) {
            if(c >= '0' && c <= '9') {
                if(c > '7' && c1 == 3)
                    break;
                yylval.lval <<= c1;
                yylval.lval += c - '0';
                c = GETC();
                continue;
            }
            if(c1 == 3)
                break;
            if(c >= 'A' && c <= 'F')
                c += 'a' - 'A';
            if(c >= 'a' && c <= 'f') {
                yylval.lval <<= c1;
                yylval.lval += c - 'a' + 10;
                c = GETC();
                continue;
            }
            break;
        }
        goto ncu;

    dc:
        for(;;) {
            if(!isdigit(c))
                break;
            *cp++ = c;
            c = GETC();
        }
        if(c == '.')
            goto casedot;
        if(c == 'e' || c == 'E')
            goto casee;
        *cp = 0;
        if(sizeof(yylval.lval) == sizeof(vlong))
            yylval.lval = strtoll(symb, nil, 10);
        else
            yylval.lval = strtol(symb, nil, 10);

    ncu:
        while(c == 'U' || c == 'u' || c == 'l' || c == 'L')
            c = GETC();
        peekc = c;
        return LCONST;

    casedot:
        for(;;) {
            *cp++ = c;
            c = GETC();
            if(!isdigit(c))
                break;
        }
        if(c == 'e' || c == 'E')
            goto casee;
        goto caseout;

    casee:
        *cp++ = 'e';
        c = GETC();
        if(c == '+' || c == '-') {
            *cp++ = c;
            c = GETC();
        }
        while(isdigit(c)) {
            *cp++ = c;
            c = GETC();
        }

    caseout:
        *cp = 0;
        peekc = c;
        if(FPCHIP) {
            yylval.dval = atof(symb);
            return LFCONST;
        }
        yyerror("assembler cannot interpret fp constants");
        yylval.lval = 1L;
        return LCONST;

    case '"':
        memcpy(yylval.sval, nullgen.sval, sizeof(yylval.sval));
        cp = yylval.sval;
        c1 = 0;
        for(;;) {
            c = escchar('"');
            if(c == EOF)
                break;
            if(c1 < sizeof(yylval.sval))
                *cp++ = c;
            c1++;
        }
        if(c1 > sizeof(yylval.sval))
            yyerror("string constant too long");
        return LSCONST;

    case '\'':
        c = escchar('\'');
        if(c == EOF)
            c = '\'';
        if(escchar('\'') != EOF)
            yyerror("missing '");
        yylval.lval = c;
        return LCONST;

    case '/':
        c1 = GETC();
        if(c1 == '/') {
            for(;;) {
                c = GETC();
                if(c == '\n')
                    goto l1;
                if(c == EOF) {
                    yyerror("eof in comment");
                    errorexit();
                }
            }
        }
        if(c1 == '*') {
            for(;;) {
                c = GETC();
                while(c == '*') {
                    c = GETC();
                    if(c == '/')
                        goto l0;
                }
                if(c == EOF) {
                    yyerror("eof in comment");
                    errorexit();
                }
                if(c == '\n')
                    lineno++;
            }
        }
        break;

    default:
        return c;
    }
    peekc = c1;
    return c;
}
@


%-------------------------------------------------------------

<<assemblers/5a/lex.c>>=
#include "a.h"
#include "y.tab.h"

void	cinit(void);
int		assemble(char*);
void	cclean(void);
void	outhist(void);

<<function main(arm)>>

<<function assemble(arm)>>

<<global itab(arm)>>

<<function cinit(arm)>>

<<function syminit(arm)>>

<<function isreg(arm)>>

<<function cclean(arm)>>

<<function zname(arm)>>

<<function zaddr(arm)>>

<<global bcode(arm)>>

<<function outcode(arm)>>

<<function outhist(arm)>>

// now use aa.a8
//#include "../cc/lexbody"
//#include "../cc/compat"

// used to be in ../cc/lexbody and factorized between assemblers by
// using #include, but ugly, so I copy pasted the function for now
<<function yylex(arm)>>

// #include "../cc/macbody"
@

%$


\section{[[assemblers/8a/]]}

\subsection*{[[assemblers/8a/a.h]]}

%-------------------------------------------------------------

<<assemblers/8a/a.h>>=
#include "../aa/aa.h"
#include "386/8.out.h"

typedef	struct	Gen  Gen;
typedef	struct	Gen2 Gen2;

<<constant FPCHIP(x86)>>

<<struct Gen(x86)>>
<<struct Gen2(x86)>>

extern	char*	Dlist[30];
extern	int	nDlist;
extern	Gen	nullgen;
extern	int	pass;
extern	char*	pathname;
extern	char*	thestring;
extern	Biobuf	obuf;

// for a.y
long	yylex(void);
void	checkscale(int);
void	outcode(int, Gen2*);

int	escchar(int);
//Sym*	getsym(void);

// for lexbody
void	setinclude(char*);
void*	allocn(void*, long, long);
void	errorexit(void);
Sym*	slookup(char*);
void	pinit(char*);
void	ieeedtod(Ieee*, double);
void	dodefine(char*);
void	yyerror(char*, ...);
int	yyparse(void);

// for macbody
int	getc(void);
void	unget(int);
void	pushio(void);
void	newio(void);
void	newfile(char*, int);

// for macbody, was in lexbody

int	mywait(int*);
int	mycreat(char*, int);
int	systemtype(int);
int	pathchar(void);
@


\subsection*{[[assemblers/8a/globals.c]]}

%-------------------------------------------------------------

<<assemblers/8a/globals.c>>=
#include "a.h"

<<global nullgen(x86)>>
@


\subsection*{[[assemblers/8a/lex.c]]}


%-------------------------------------------------------------

<<assemblers/8a/lex.c>>=
#include "a.h"
#include "y.tab.h"

void	cinit(void);
int		assemble(char*);
void	cclean(void);
void	outhist(void);

<<function main (assemblers/8a/lex.c)>>

<<function assemble(x86)>>

<<struct Itab(x86)>>
<<global itab(x86)>>

<<function cinit(x86)>>

<<function checkscale(x86)>>

<<function syminit(x86)>>

<<function cclean(x86)>>

<<function zname(x86)>>

<<function zaddr(x86)>>

<<function outcode(x86)>>

<<function outhist(x86)>>

// now use aa.a8
//#include "../cc/lexbody"
//#include "../cc/compat"

// used to be in ../cc/lexbody and factorized between assemblers by
// using #include, but ugly, so I copy pasted the function for now
<<function yylex(x86)>>

// #include "../cc/macbody"
@
