\documentclass[twocolumn, landscape]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse % see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, I changed for the better a few things:
% - dead code (S_PID, S_MAKEFILE)

%thx to codemap/codegraph/scheck:
% - use cg to reduce backward deps, introduce globals.c, utils.c,
%   (harder to understand non layered code)
% - use scheck to remove deadcode, dead prototypes, useless export
%   or mv as forward decl
%   (harder to understand big interface files)
% - LESS use cg to reduce number of globals by moving them closer to the
%   relevant file (or even function), better cluster the code
%   (harder to understand non functional code using lots of globals)

%thx to this manual, better understand make?:
% - minimal-syntax design leads to use of escaping-newline because newline is
%   (ab)used as a terminator for many things
% - SEMI how to debug issues in your own makefile
% - SEMI mk is actually a job scheduler! with dependent tasks!
% - to not use ';' but instead && for eflag -e to work
% - scope and life of variables (still dont understand in make, = vs := )

%history LP-ization:
% - skeleton, mostly copy paste of Template.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * TODO ctor/dtor, dumper
%    * [[xxx]] other fields, [[xxx]] extra fields
% - read Extra section, identify concepts, first TOC
% - distribute parts of the Extra section in the main file
% - understand main(), LP split main, improve TOC
% - understand main functions, LP split, cluster, improve TOC
% - LP split the structures, use datalog for flow to field info
% - nullify, boolify, errorify, enumify,  typeify,    scheckify, plan9ify
% - aspecify advanced features! remove useless features
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% ifallcode is used for:
%  - forward decl, func decl, extern decl, #ifdef, pragmas (stuff in Extra.nw)

\addtolength{\topmargin}{-.850in}
\addtolength{\textheight}{1.70in}

\begin{document}
%******************************************************************************
% Title
%******************************************************************************
\title{
{\Huge 
Principia Softwarica: The Build System [[mk]]
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}\\
\\
with code from\\
Andrew Hume
}

\maketitle 
\onecolumn
\hrule
\input{../docs/latex/Copyright}
\input{../docs/latex/CopyrightPlan9}
\hrule
\twocolumn

\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\tableofcontents
\endgroup

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

The goal of this book is to present with full details the source code of
a {build system}.

\section{Motivations}

Why a build system? 
Because I think you are a better programmer if
you fully understand how things work under the hood,
and a build system is one of the tools a programmer uses the most.
%
Indeed, it allows programmers to 
assemble, 
compile, 
link,
package, and 
distribute 
software with a simple command, ``the one command that rules them all'',
from very simple programs to entire operating systems.

% No deep concepts. nice DSL though. language-based solution to a problem.
% minimal syntax. nice checks.
% Also use of //. job scheduler (quite useful in general).

Here are a few questions I hope this book will answer:

\begin{itemize}

\item What are the fundamental concepts of a build system? 

\item What is the exact procedure to compute dependencies
between files? What does happen when there are ambiguities
between different rules?

\item How can you visualize the actual dependency tree? 
What help does the build system offer to debug a makefile?

\item How does the build system run different tasks in parallel and coordinate
them? How do you write a simple job scheduler?

\end{itemize}
\l no great questions for now :(

\section{The \plan build system, [[mk]]}

% I gonna present mk, build system of plan9. X? LOC. written entirely in C.
% used also outside plan9 by a few open source software.
% Elegant, simple, bla bla.

% with one mk command, build plan9 libs, plan9 programs, plan9 kernel,
% and build disk image that can be installed on raspberry or QEMU.
% one command!

% similar to make. 
% differences with make? More regular. Simpler (e.g. variables,
%  escaping).
% Author of make Stu Fedlman consider mk better in every way.
% run in // by default, main feature compared to original make
%  (and actually design and features influenced by that I think,
% e.g. multiple targets rule, or build graph at mk time once)
% because plan9 context.
% Also well written, nice use of assert!
% Also no infamous TAB issue :)

\section{Other build systems}

Here are a few build systems that I considered for this book,
but which I ultimately discarded:
\begin{itemize}

\item \unix make
% I mentioned before. Original one.
% Stu Feldman, ACM system software award
% - what about ape/cmd/make/? looks pretty small too.
% Stu himself considers mk a better solution.

% see mk.ps section 4
%  less uglyness with variables too, no $$i need, variables passed as-is
%  (like for rc, cleaner?) so remove some intermediates
%  also no $(X), just $X, far more consistent
%
%  well many mk extensions have become gnu make, e.g. %.c rules instead of .c
%  (hmm still? mk introduced pattern metarules, but metarules may have been
%   in research UNIX make)

\item GNU make
% also in //. Many extensions. Too many.
% 37 000 LOC? main.c 3200 LOC

\item Cmake
% LOC, lol

\item ant
% XML

% one using python, EDSL, but more syntax boilerplate "", [;], etc

\end{itemize}

\l a few other, see the comment in this file:
% - ninja, seems interesting this one, but assembly of build system
% - maven, like ant?
% - gyp, qake, ... huge list
% - buck, huge, python-based like many other google-inspired build systems
%   just ocaml/ specific stuff is 4000 LOC, hmmm
% - bazel, latest from google:
%   http://google-opensource.blogspot.com/2015/09/building-build-system-bazel-reaches-beta.html
% - omake? apparently has listen-to-fs features too, so daemon
%   and rerun when save in editor?
%   http://blog.camlcity.org/blog/omake1.html
% - gulp?

% see https://en.wikipedia.org/wiki/List_of_build_automation_software

%http://aosabook.org/en/500L/contingent-a-fully-dynamic-build-system.html
%http://www.lihaoyi.com/post/WhatsinaBuildTool.html

% make advocacy :)
%http://bost.ocks.org/mike/make/
%http://hadihariri.com/2014/04/21/build-make-no-more/

%make theory and practice
% http://www.ploxiln.net/make.html
%how we use make:
% https://segment.com/blog/how-we-use-make/
%the essence of make (but looks pedantic)
% http://bentnib.org/posts/2015-04-17-propositions-as-filenames-essence-of-make.html



\section{Getting started}

To play with [[mk]], you will first need to install
the \plan fork used in \principia. See \urlinstall.
Once installed you can test [[mk]] under \plan with:

% actually bootstrapping issue here. mk use make? or shell script?

% can get the one from kencc? or plan9port?
% issues though with rc vs sh ...

% TODO


\section{Requirements}

%dup: from Assembler.nw
Because most of this book is made of C source code, 
you will need a good knowledge of 
the C programming language~\cite{k-r} to understand it.
%
I also assume you are already familiar with at least 
one build system, for instance, [[make]],
%
and so are familiar with concepts such as
a {makefile},
a {rule},
a {target}, 
the set of prerequisites,
a {recipe}, 
etc.
%
If not, I suggest you to read the 
\plan article~\cite{article-mk}, which introduces [[mk]]
and is available in my \plan distribution.
%
The man page of [[mk]] can also useful at [[docs/man/1/mk]].
%
%builders/make/ contain how mk used in plan9,
%(and mk_successor_make.pdf if interested specifically of diff with make)

\section{About this document}
#include "../docs/latex/About.nw"

\section{Copyright}
\input{../docs/latex/CopyrightPlan9Text}

\section{Acknowledgments}

I would like to acknowledge of course the author of [[mk]],
Andrew Hume,
% and Bob Flander, 
who wrote in some sense most of this book.
\l can thx Stu Feldman inspiration for make




\chapter{Overview}

%trans:
Before showing the source code of [[mk]] in the following chapters, 
%toc:
I first give an overview in this chapter
of the general principles of a build system.
\t TODO command line interface of mk, simple mkfile.
%dup: from Assembler.nw
I also define terms, explain how the code is organized, 
and more generally give the background necessary
to understand the code we will show later.

\section{Build system principles}

% How was doing before make? adhoc shell scripts? as projects get more complex,
% more files. Example for mk.c? 
% Long. would like to factorize.
% Also not efficient. redo. should recompile only what is necessary, 
%  what depends on the change.
% (but can be used for bootstrapping mk)

The goal of a build system is to 
describe {\em concisely} and 
maintain {\em efficiently}
{\em dependencies} between files or programs.
%toc:
% every word is important :) 
% concisely lead to create of DSL.
% efficiently leads to creation of graph, and stuff in parallel
% as explained in next sections.

\subsection{A domain-specific language}

% A domain-specific language (DSL) is a programming language
%  tailored for one task. Usually not as expressive as full PL,
%  but trade expressivity for compactness, and special checks.

%\subsubsection{Rules}

% essence is state dependencies and how to achieve it.
% simplest syntax,  x : y \n z.

% like arc in a graph. src, dest, and label on edge.
% (and indeed later will see that we generate a graph)

% Most build systems have the notion of
% rule, target: dependencies
% In mk, very simple, minimal syntax! just ':', and newlines
% no need "" around shell command.

% same spirit than shell actually. no need () for calling
% commands, "" around strings, remember
% order of options (but then lead to -xxx named arguments)

% in fact body of a rule is shell command. Embedded lang
% inside lang. Not interpreted. As is. (simpler than in make)

%\subsubsection{Variables}

% can also set variables. again, minimal syntax, X=Y.
% no need [;] for list of things. Just use = until newline
%  (but then need to have \ escaped newline to scale to large lists)

% defs and uses, and actually can have complex uses with substitutions
%  on stemming

%\subsubsection{Generic rules}

% metarules, variables => generic stuff
% stemming, so can factorize with generic rules.

% describe a set of arcs in a graph in a generic way.

%\subsubsection{Modularity}

% < so modularity and can factorize in different files

%\subsection{Generic language}
% works for all PLs. not adhoc to one PL like IDEs

%related: generate from mkfile .project, like Buck does.


\subsection{Graph of dependencies}

% Rules. But what about actual files. Concrete.
% build graph of deps. accurate representation of dependencies.

% graph of deps, if modify a leaf then have to rebuild everything up!
%  but not everything!

% actually DAG (and acyclic check later)

%trans:
% efficiency => graph and //
%  if brother, then can run in // cos independent!


\subsection{A job scheduler}

% FIGURE where can see different steps stuff you can do in //? 

% mk is actually kind of a scheduler because can do things in //,
% run recipe of independent jobs in //, and need to manage dependencies
% between those jobs
% then need coordinate. wait for finish, run independent.
% Master/Workers?

\subsection{Generating some dependencies automatically}

% object level deps. libs.
% But also semantic level.

% Many dependencies are implicit in files. if foo.c include
% foo.h, should recompile. Can declare deps in mkfile, but
% redundant, hard to maintain. 
% So can be good to auto generate some dependencies. But 
% different for each programming language.

% enter .depend 

% so ocamldep, 
% gcc -MM.

% related is library of variables and rules for different languages.

% question is can we generate every dependencies automatically?
% IDE tries to do that. But requires helps, AddFile, AddDir.
% what about when have multiple binaries in one distrib?
% hh_server nice, but works because generate a giant PHP library.

\section{[[mk]] command-line interface}

% interface is pretty simple, go in dir, type 'mk'
% or 'mk target' 
\n great way to use mk is have list of one-liner
% actually can give multiple targets

<<function badusage>>=
void
badusage(void)
{

    fprint(STDERR, "Usage: mk [-f file] [-n] [-a] [-e] [-t] [-k] [-i] [-d[egp]] [targets ...]\n");
    Exit();
}
@
\l also have NPROC, NREP global variables

% mk then look for mkfile by default
%real-world: (make look for Makefile).

<<constant MKFILE>>=
#define	MKFILE		"mkfile"
@

% but can change with -f.


% some xxx=yyy, and some -xxx
% has also many -xxx options, advanced features explained later in the book.


%dead?
<<global version>>=
static char *version = "@(#)mk general release 4 (plan 9)";
@



\section{[[hello.mk]]}
\n [[hello.mk]] concistent with my other books.
\l A simple [[mkfile]]

% mkfile of helloworld.c?
\n minimum spirit, no <objfile, no factorize with mkone

% running example
% concepts: target, prerequistes, recipe

% show also simple output of running mk on a toy project
% maybe even include mk -e output?

%How add to an existing variable? e.g. CFLAGS+= -p?
% easy, CFLAGS= -xxx $CFLAGS
%Can do the $(BLA:.cmo=.cmx)? this is convenient
% yes you can: OBJS=${SRC:%.ml=%.cmo}

% what happen when have general rule like %.cmo: %.ml
% and then more specialized rules? or when have extra rules
% like %.cmo: %.cmi without any recipe?
% (note that right now $prereq seems to also include the .cmi in which
% case you want to use $stem in the general rules)

% For more examples, see appendix. Goal here is to give a taste.
% actually the mkfile of mk itself :) appendix!

\section{Code organization}

%mk.h: main data structures and globals declarations
%fns.h: forward function declarations (prototypes)

%main.c: main() entry point!

%globals.c: globals definitions
%symtab.c: global hash table, and cache

%var.c: setvar(), dumper, utilities

%lex.c: parsing recipe
%parse.c: parsing mkfile
%rule.c: addrule(), dumper
%varsub.c: managing variables and substitution

%arc.c: newarc(), dumper, nrep() (move it?)
%graph.c: graph(), building the dependency graph
%match.c: match() and subst() for metarules

%mk.c: mk() and work(), building the graph and then the targets

%rc.c: rc interaction, quote, unquote, escaping, etc

%file.c: timeof(), touch(), delete()

%run.c: job schedule, run(), sched(), profiling processors
%job.c: newjob(), dumper
%env.c: recipe environment

%recipe.c: dorecipe()

%archive.c: special archive extension xxx(yyy)

%shprint.c: print recipe before executing it

%bufblock.c: buffered IO
%word.c: list of strings
%utils.c: libc like helper functions
%plan9.c: libc like helper functions plan9 specific (unix.c, windows.c)
% (rename os.c?)

\section{Software architecture}

% graphviz of files? or just of the types?

% main() -> parse(mkfile) (populate rules, metarules, target1, S_VAR, ...)
%        -> mk(target1) -> graph(target1)
%                       -> work(node) -> outofdate(file)
%                                     -> run(job) -> sched() -> execsh()
%                                     
%                       -> waitup()

% data flow?

%\section{Boostrapping}
% we use a mkfile and mk to compile mk :)
% can bootstrap simply using a shell script for the very first time.


\section{Book structure}

%trans: %dup: (and adapted) from Assembler.nw
You now have enough background to understand the source code of [[mk]].
%toc:
The rest of the book is organized as follows.
%
I will start by describing the core data structures of [[mk]]
in Chapter~\ref{chap:core-ds}. 
%
Then, I will use a top-down approach in Chapter~\ref{chap:main}, and,
starting from [[main()]], I will present the code
%, or a high-level view of the code, of some 
of the main functions of [[mk]], e.g., [[mk()]].
%
The following chapters will describe
the main components of the building pipeline:
\t parsing rules, building graph, analyzing deps, scheduling jobs,
and finally interacting with the shell.
\t debugging and profiling support for user.
%
Chapter~\ref{chap:advanced} presents advanced
features of [[mk]] that I did not present before to simplify the explanations.
\l for instance?
%
Finally, Chapter~\ref{chap:conclusion} concludes
and gives pointers to other books in the \principia series.

%toc:
Some appendices present the code of non-functional properties:
code to help debug [[mk]] itself in Appendix~\ref{chap:debugging-appendix},
code which profiles [[mk]] itself in Appendix~\ref{chap:profiling-appendix},
and code to manage errors in Appendix~\ref{chap:error}.
%
Appendix~\ref{chap:libc} contains the code of generic
utility functions used by [[mk]] but which are not specific to [[mk]].
%
Appendix~\ref{chap:examples} present examples of [[mkfile]]s.


%###############################################################################

\chapter{Core Data Structures}
\label{chap:core-ds}

\begin{verse}
\begin{flushright}
  {\it Show me your code and conceal your data structures, and I shall
    continue to be mystified. Show me your data structures, and I
    won't usually need your code; it'll be obvious.\\
    ~\\
    Fred Brooks}
\end{flushright}
\end{verse}


%toc:
In this chapter we will present the core data structures of [[mk]],
\t WHICH ARE big symbol table for variables, AST for rules, 
and nodes and arcs for graph of dependencies, and
job gather information about what needs to be actually done, recipe.


% core types: (see mk.h)
% Bufblock, Word
% Sym (a bit generic, could be in libc?)

% Rule (mk -dp?), recipe? metarule, target, prerequiste (see mk.ps)
% Node, Arc (mk -dg)
% Envy (bad name)
% Job, (mk -de)

% core globals: (see mk.h externs)
% envy,    rules, metarules, patrule,    jobs
% symbol hashtbl global
% bout

% draw diagram showing relations to each other, what includes what?

\section{Symbol table}

% need quick access to rules for a specific target.
% need also manage variable of user.
% => generic hashtbl.

\subsection{[[Symtab]]}

<<struct Symtab>>=
struct Symtab
{
    // the key: (name x space)
    char		*name;
    // enum<Namespace>, the ``namespace''
    short		space;

    // the value (generic)
    union{
        void*	ptr;
        uintptr	value;
    } u;

    // Extra
    <<[[Symtab]] extra fields>>
};
@
%ocaml: could reuse hashtbl, but still pb for namespaces.
% may need a record of hashtbl.

% the "world" data structure? hmm rules+metarules is more the world
% here it's more an index over the rules, metarules, and some cache
% (e.g. time of a file)
%less: could use a record instead of that which would be better typed
<<enum Sxxx>>=
enum Sxxx {
    S_VAR,	/* variable -> value */ // value is a list of words
    <<[Sxxx]] cases>>
};
@
% use for fast access and also for memoization, operates as a cache
%dead:
%S_PID,		/* pid -> products */
%S_MAKEFILE,	/* target -> node */

\subsection{[[hash]]}

<<global hash>>=
// hash<(string * enum<Namespace>), 'a> (next = Symtab.next in bucket)
static Symtab *hash[NHASH];
@
<<constant NHASH>>=
#define	NHASH	4099
@

<<[[Symtab]] extra fields>>=
struct Symtab	*next;
@

% main -> <>
<<function syminit>>=
void
syminit(void)
{
    Symtab **s, *ss;

    for(s = hash; s < &hash[NHASH]; s++){
        for(ss = *s; ss; ss = ss->next)
            free((char *)ss);
        *s = nil;
    }
}
@
% free necessary? should be nil no? syminit called at the start of main

<<constant HASHMUL>>=
#define	HASHMUL	79L	/* this is a good value */
@

% many stuff -> <>
% will create new entry if not there!
<<function symlook>>=
Symtab*
symlook(char *sym, int space, void *install)
{
    long h;
    char *p;
    Symtab *s;

    //h = hash(sym, space)
    for(p = sym, h = space; *p; h += *p++)
        h *= HASHMUL;
    if(h < 0)
        h = ~h;
    h %= NHASH;

    for(s = hash[h]; s; s = s->next)
        if((s->space == space) && (strcmp(s->name, sym) == 0))
            return s;
    // else

    if(install == nil)
        return nil;

    s = (Symtab *)Malloc(sizeof(Symtab));
    s->space = space;
    s->name = sym;
    s->u.ptr = install;

    // add_list(s, hash)
    s->next = hash[h];
    hash[h] = s;

    return s;
}
@
%ocaml: just use Hashtbl.find
\t define symexists() that uses install == nil, cleaner?
\t  and return bool

% execinit -> <>
<<function symtraverse>>=
void
symtraverse(int space, void (*fn)(Symtab*))
{
    Symtab **s, *ss;

    for(s = hash; s < &hash[NHASH]; s++)
        for(ss = *s; ss; ss = ss->next)
            if(ss->space == space)
                (*fn)(ss);
}
@

\subsection{Namespaces}

% use symbol table for many things.
% user variable. But also internal variables.
% can be in conflict with user variable.
% so multiple namespaces.

<<[[Sxxx]] cases>>=
S_INTERNAL,	/* an internal mk variable (e.g., stem, target) */
@
% diff with S_VAR? not set by user! set by mk automatically

<<global myenv>>=
static char	*myenv[] =
{
    "target",
    "stem",
    "prereq",

    <<[[myenv]] other array elements>>
    0,
};
@
% $stem $prereq
% (better than $@, $^ )


% main -> <>
<<function initenv>>=
void
initenv(void)
{
    char **p;

    for(p = myenv; *p; p++)
        symlook(*p, S_INTERNAL, (void *)"");
    readenv();				/* o.s. dependent */
}
@
% readenv? for /env/.



<<[[Sxxx]] cases>>=
S_MAKEVAR,	/* dumpable mk variable */
@
\t so mv in Debugging support?

% many stuff -> <>
<<function setvar>>=
void
setvar(char *name, void *value)
{
    symlook(name, S_VAR, value)->u.ptr = value;
    symlook(name, S_MAKEVAR, (void*)"");
}
@
\l aspectize code setting S_MAKEVAR and move setvar earlier?


\section{[[Word]]s}
% could put [[target1]] here too? but it's really not a Words ...

% what is this for? it has to be Words otherwise
% there is no much point in having a Word type that is
% just a wrapper over char*
% HFILES=fns.h mk.h => list of 2 words

<<struct Word>>=
struct Word
{
    char 		*s;
    struct Word 	*next;
};
@
\t rename Words?
%ocaml: just use List


% rename newword_list? new_singleword?
<<constructor newword>>=
Word*
newword(char *s)
{
    Word *w;

    w = (Word *)Malloc(sizeof(Word));
    w->s = strdup(s);
    w->next = nil;
    return w;
}
@

% it's actually delwords
<<destructor delword>>=
void
delword(Word *w)
{
    Word *v;

    while(v = w){
        w = w->next;
        if(v->s)
            free(v->s);
        free(v);
    }
}
@

<<function wdup>>=
Word*
wdup(Word *w)
{
    Word *v, *new, *base;

    v = base = nil;
    while(w){
        new = newword(w->s);
        if(v)
            v->next = new;
        else
            base = new;
        v = new;
        w = w->next;
    }
    return base;
}
@
%ocaml: just use sharing done by ocaml. Pure DS.

% word to string
<<function wtos>>=
char *
wtos(Word *w, int sep)
{
    Bufblock *buf;
    char *cp;

    buf = newbuf();
    for(; w; w = w->next){
        for(cp = w->s; *cp; cp++)
            insert(buf, *cp);
        if(w->next)
            insert(buf, sep);
    }
    insert(buf, '\0');
    cp = strdup(buf->start);
    freebuf(buf);
    return cp;
}
@
%ocaml: Common.join (but using Buffer would be faster too)

% insert? Bufblock? See appendix.


\section{Rules}

% AST of rules, from which will build actual graph of dependencies
% with actual files.

\subsection{[[Rule]]}

<<struct Rule>>=
struct Rule
{
    char 		*target;	/* one target */
    // ref_own<Words>
    Word 		*tail;		/* constituents of targets */
    char 		*recipe;	/* do it ! */

    <<[[Rule]] other fields>>
    <<[[Rule]] debug fields>>

    // Extra
    <<[[Rule]] extra fields>>
};
@
\t rename tail to prerequistes? 
% note that can have multiple rules
% with the same head, in which case you add prerequistes.

% seen Word before.

% recipe can contain $, target and tail not, the variables are expanded
% at parsing time.
% from man page:
%  Variable substitution in a rule is done when
%  the rule is read; variable substitution in the recipe is done
%  when the recipe is executed.
% why? probably because recipe/rc will do the subst itself, but for
% the graph we need concrete values so faster to do it eagerly when parsing

% can also be metarule, %.$O: %.c (but $O would have been expanded)

<<[[Rule]] debug fields>>=
char* 		file;		/* source file */
short 		line;		/* source line */
@
\t put in Debugging support section?

\subsection{Simple [[rules]]}

<<global rules>>=
// list<ref_own<Rule>> (next = Rule.next, end = lr)
Rule *rules;
@

<<[[Rule]] extra fields>>=
// list<ref_own<Rule>> (head = rules | metarules)
struct Rule	*next;
@

% end of rules list, so can add at the end
<<global lr>>=
// option<ref<Rule>> (head = rules)
static Rule *lr;
@

\subsection{[[metarules]]}

<<function PERCENT>>=
#define	PERCENT(ch)	(((ch) == '%') || ((ch) == '&'))
@
% from man page:
% '%' matches a maximal length string of any characters;
% '&' matches a maximal length string of any characters except period or slash


<<[[Rule]] other fields>>=
// bitset<Rule_attr>
short 		attr;		/* attributes */
@

<<enum Rule_attr>>=
enum Rule_attr {
    META   = 0x0001,
    <<[[Rule_attr]] cases>>
};
@
% META is for % metarule and also regexp rules :R:
%//@Scheck: dead indeed
%UNUSED = 0x0002,


<<global metarules>>=
// list<ref_own<Rule>> (next = Rule.next)
Rule *metarules;
@

% end of metarules list, so can add at the end
<<global lmr>>=
// option<ref<Rule>> (head = metarules)
static Rule *lmr;
@



\subsection{[[addrule()]]}

% incremented by addrule()
<<global nrules>>=
static int nrules = 0;
@


% kind of ctor
% syntax: head -> target, tail -> reqs, body -> recipe
% (main -> parse | main) -> <>
<<function addrule>>=
void
addrule(char *head, Word *tail, char *body, Word *ahead, int attr, int hline, char *prog)
{
    Rule *r;
    Rule *rr;
    Symtab *sym;
    bool reuse;

    r = nil;

    reuse = false;
    if(sym = symlook(head, S_TARGET, nil)){
        for(r = sym->u.ptr; r; r = r->chain)
            if(rcmp(r, head, tail) == 0){
                reuse = true;
                break;
            }
    }

    if(r == nil)
        r = (Rule *)Malloc(sizeof(Rule));
    r->target = head;
    r->tail = tail;
    r->recipe = body;

    r->line = hline;
    r->file = infile;

    r->attr = attr;

    r->rule = nrules++;

    r->alltargets = ahead;
    r->prog = prog;

    if(!reuse){
        rr = symlook(head, S_TARGET, r)->u.ptr;
        if(rr != r){
            r->chain = rr->chain;
            rr->chain = r;
        } else 
            r->chain = nil;
        r->next = nil;
    }

    if(charin(head, "%&") || (attr&REGEXP)){
        r->attr |= META;
        if(reuse)
            return;
        <<[[addrule()]] if REGEXP attribute>>
        // add_list(r, metarules, lmr)
        if(metarules == nil)
            metarules = lmr = r;
        else {
            lmr->next = r;
            lmr = r;
        }
    } else {
        if(reuse)
            return;
        r->pat = nil;
        // add_list(r, rules, lr)
        if(rules == nil)
            rules = lr = r;
        else {
            lr->next = r;
            lr = r;
        }
    }
}
@
% could print when find an existing rule with same target/pre
% and display a message?


% used in addrule()
<<[[Sxxx]] cases>>=
S_TARGET,		/* target -> rule */ // actually rules
@

% can have multiple rules with the same target!
% no need :: ? will get ambiguous rule?

<<[[Rule]] extra fields>>=
struct Rule	*chain;		/* hashed per target */
@

% seen symlook before.



% rule compare, check if same target and same prerequistes
<<function rcmp>>=
static int
rcmp(Rule *r, char *target, Word *tail)
{
    Word *w;

    if(strcmp(r->target, target))
        return 1;
    for(w = r->tail; w && tail; w = w->next, tail = tail->next)
        if(strcmp(w->s, tail->s))
            return 1;
    return (w || tail);
}
@
\t strcmp sucks, use string_equal, and return bool that makes sense
\t  so less rcmp(...) == 0, instead rule_match(...)




\section{Graph}

% Rule and metarules are general static descriptions, patterns.
% Node and Arc are concrete instantiation with existing files.
% the actual graph of dependencies! nodes are target names usually filenames
% arcs link nodes to other filenames with a rule attached to know what to do

% it's really more a DAG than a graph; there should be no cycle
% (see cycle check section)

\subsection{[[Node]]}

<<struct Node>>=
struct Node
{
    // ref_own<string>, usually a filename, or target label like 'default'
    char*		name; 
    // last mtime of the file (or zero for non existing files)
    ulong		time;
    // bitset<enum<Node_flag>>
    ushort		flags;

    <<[[Node]] other fields>>

    // Extra
    <<[[Node]] extra fields>>
};
@
% the flags is often an inline of the union of the flags of the
% rules linking to the prerequistes nodes

%ctor. dtor = ?
% main -> mk -> graph -> applyrules -> <>
<<constructor newnode>>=
static Node*
newnode(char *name)
{
    Node *node;

    node = (Node *)Malloc(sizeof(Node));
    <<[[newnode()]] update node cache>>

    node->name = name;

    // call to timeof()! 
    node->time = timeof(name, false);

    node->flags = (node->time? PROBABLE : 0);
    node->prereqs = nil;
    node->next = nil;
    <<[[newnode()]] debug>>
    return node;
}
@
% owning name after call! => call strdup in caller



<<enum Node_flag>>=
enum Node_flag {
    <<[[Node_flag]] cases>>
};
@
% used to be a set of #define

\subsection{[[Arc]]}

<<[[Node]] other fields>>=
// list<ref_own<Arc>> (next = Arc.next)
Arc		*prereqs;
@


<<struct Arc>>=
struct Arc
{
    // option<ref<Node>>, the other node in the arc
    struct Node *n;
    // ref<Rule>, contain recipe to gen the target node from the dependent nodes
    Rule *r;

    <<[[Arc]] other fields>>
    
    //Extra
    <<[[Arc]] extra fields>>
};
@
% option Node? apparently some code is doing if(a->n) so ...
% have some fake arc for leaves nodes (but why create an arc at all?)

% seen Rule before.

<<[[Arc]] extra fields>>=
// list<ref_own<arc> (head = Node.prereq)
struct Arc	*next;
@



% node   arc   rule   relations?

% so can subst $stem by the actual value for the recipe to run
<<[[Arc]] other fields>>=
// what will replace the %
char		*stem;
@
\t why need that? Node.name is not expanded already?


% ctor.  dtor = ?
% main -> mk -> graph -> applyrules -> <>
<<constructor newarc>>=
Arc*
newarc(Node *n, Rule *r, char *stem, Resub *match)
{
    Arc *a;

    a = (Arc *)Malloc(sizeof(Arc));
    a->n = n;
    a->r = r;
    a->stem = strdup(stem);
    rcopy(a->match, match, NREGEXP);

    a->next = nil;
    a->flag = 0;
    a->prog = r->prog;
    return a;
}
@





\section{[[Job]] and [[jobs]]}

% final piece.
% reference rule, node (so Arc) (and Word but less important)

% why so short field names suddenly? avoid
% confusion with the one in Rule?
<<struct Job>>=
struct Job
{
    Word		*t;	/* targets */
    Word		*p;	/* prerequisites */

    //list<ref<Node>> (next = Node.next??)
    Node		*n;	/* list of node targets */
    //ref<Rule>
    Rule		*r;	/* master rule for job */

    char		*stem;

    int		nproc;	/* slot number */ // or -1 if unassigned

    <<[[Job]] other fields>>

    // Extra
    <<[[Job]] extra fields>>
};
@
\t stem again?

% ctor
<<constructor newjob>>=
Job*
newjob(Rule *r, Node *nlist, char *stem, char **match, Word *pre, Word *npre, Word *tar, Word *atar)
{
    Job *j;

    j = (Job *)Malloc(sizeof(Job));
    j->r = r;
    j->n = nlist;
    j->stem = stem;
    j->match = match;
    j->p = pre;
    j->np = npre;
    j->t = tar;
    j->at = atar;
    j->nproc = -1;
    j->next = nil;
    return j;
}
@


<<global jobs>>=
// list<ref_won<jobs>> (next = Job.next)
Job *jobs;
@

<<[[Job]] extra fields>>=
struct Job	*next;
@


%XXX ???? Job.n?
<<[[Node]] extra fields>>=
struct Node	*next;		/* list for a rule */
@










\chapter{[[main()]]}

\ifallcode
<<[[main()]] locals>>=
Word *w;
char *s;
int i;
@
\fi

<<function main>>=
void
main(int argc, char **argv)
{
    <<[[main()]] locals>>

    // Initializing

    <<[[main()]] initializations>>

    // Parsing

    <<[[main()]] parsing mkfile, call parse()>>

    // Querying (optional)

    <<[[main()]] whatif optional setup>>

    // Building

    <<[[main()]] initializations before building>>
    <<[[main()]] building the targets, call mk()>>

    // Reporting (optional)

    <<[[main()]] print profiling stats if uflag>>

    // Exiting

    exits(nil);
}
@




<<global bout>>=
Biobuf bout;
@
% use of libbio quite a lot. Buffered IO module.
% For output and input.
% compared to scanf/printf? 

<<[[main()]] initializations>>=
/*
 *  start with a copy of the current environment variables
 *  instead of sharing them
 */
//??? for execinit?? for initenv/

Binit(&bout, STDOUT, OWRITE);
<<[[main()]] argv processing part 1, -xxx>>
<<[[main()]] setup optional profiling>>
usage();
syminit();
initenv();
usage();
<<[[main()]] argv processing part 2, xxx=yyy>>
<<[[main()]] set variables for recursive mk>>
@
\t simplify



<<[[main()]] initializations before building>>=
execinit();

// can do that earlier??
<<[[main()]] argv processing part 3, skip xxx=yyy>>

catchnotes();
@
\t simplify


\section{[[mk -xxx]] argument processing}

% use for -f, or debug flags.

<<[[main()]] argv processing part 1, -xxx>>=
USED(argc);
for(argv++; *argv && (**argv == '-'); argv++)
{
    <<[[main()]] add [[argv[0]]] in [[buf]]>>
    switch(argv[0][1]) {
    <<[[main()]] -xxx switch cases>>
    default:
        badusage();
    }
}
@
%chunks:
% will see gradually -xxx

<<[[main()]] locals>>=
Bufblock *buf = newbuf();
@
\t save -xxx, why? recursive mk? mv everything later then

<<[[main()]] add [[argv[0]]] in [[buf]]>>=
bufcpy(buf, argv[0], strlen(argv[0]));
insert(buf, ' ');
@

<<[[main()]] add [[argv[i]]] in [[buf]]>>=
bufcpy(buf, argv[i], strlen(argv[i]));
insert(buf, ' ');
@

\section{[[mk xxx=yyy]] argument processing}

% mk CC=6c default => override

% Done by writing variable in temporary file and reusing
%  machinery in parse()

<<[[main()]] locals>>=
char *temp = nil;
fdt tfd = -1;
Biobuf tb;
@

<<[[main()]] argv processing part 2, xxx=yyy>>=
/*
 *   assignment args become null strings
 */
for(i = 0; argv[i]; i++) 
  if(utfrune(argv[i], '=')){
    <<[[main()]] add [[argv[i]]] in [[buf]]>>
    <<[[main()]] create temporary file if not exist yet>>
    Bprint(&tb, "%s\n", argv[i]);
    *argv[i] = '\0';
  }

if(tfd >= 0){
    Bflush(&tb);
    seek(tfd, 0L, SEEK__START);
    parse("<command line args>", tfd, true);
    remove(temp);
}
@
% abuse parse(), pass true so will get varoverride to true
%  so those variables will be marked specially S_OVERRIDE
%old: seek() used to be LSEEK() a macro expanding ultimately to seek


<<[[main()]] create temporary file if not exist yet>>=
if(tfd < 0){
    temp = maketmp();
    if(temp == nil) {
        perror("temp file");
        Exit();
    }
    tfd = create(temp, ORDWR, 0600);
    if(tfd < 0){
        perror(temp);
        Exit();
    }
    Binit(&tb, tfd, OWRITE);
}
@


<<[[main()]] argv processing part 3, skip xxx=yyy>>=
/* skip assignment args */
while(*argv && (**argv == '\0'))
    argv++;
@

\section{Parsing [[mkfile]] or [[mk -f]]{\em file}}

\t simplify code? remove multi -f, who needs that?

<<[[main()]] locals>>=
char *files[256];
char **f = files;
@
% can have more than one file? can use multiple -f, but meh.


<<[[main()]] -xxx switch cases>>=
case 'f':
    if(*++argv == nil)
        badusage();
    *f++ = *argv;
    <<[[main()]] add [[argv[0]]] in [[buf]]>>
    break;
@
% saw -xxx processing before.

<<[[main()]] locals>>=
char **ff;
@

<<[[main()]] parsing mkfile, call parse()>>=
if(f == files){
    if(access(MKFILE, AREAD) == 0)
        parse(MKFILE, open(MKFILE, OREAD), false);
} else
    for(ff = files; ff < f; ff++)
        parse(*ff, open(*ff, OREAD), false);
<<[[main()]] if DEBUG(D_PARSE)>>
@
%old: use AREAD and OREAD instead of 4 and 0 argument



\section{Building the targets}

% parse(), so modified globals rules, metarules.
% just need to initiate with target passed as argument (or use default one)

<<[[main()]] building the targets, call mk()>>=
if(*argv == nil){
    <<[[main()]] when no target arguments>>
} else {
    <<[[main()]] if sequential mode and target arguments given>>
    else {
       <<[[main()]] parallel mode and target arguments given>>
    }
}
@

\subsection{Default target, [[target1]]}

<<global target1>>=
Word *target1;
@

% e.g. 'default', 
% should be initialized while parsing with the first rule added
\t should be a single word (but consistent to use Word), change to char*?
\l  or first rule can contain multiple targets


<<[[main()]] when no target arguments>>=
if(target1)
    for(w = target1; w; w = w->next)
        // The call!
        mk(w->s);
else {
    fprint(STDERR, "mk: nothing to mk\n");
    Exit();
}
@



\subsection{Sequential mode}

% sequential not parallel command line arguments
<<[[main()]] locals>>=
bool sflag = false;
@

<<[[main()]] -xxx switch cases>>=
case 's':
    sflag = true;
    break;
@

<<[[main()]] if sequential mode and target arguments given>>=
if(sflag){
    for(; *argv; argv++)
        if(**argv)
            mk(*argv);
}
@

\subsection{Parallel mode}

<<[[main()]] parallel mode and target arguments given>>=
Word *head, *tail, *t;

/* fake a new rule with all the args as prereqs */
tail = nil;
t = nil;
for(; *argv; argv++)
    if(**argv){
        if(tail == nil)
            tail = t = newword(*argv);
        else {
            t->next = newword(*argv);
            t = t->next;
        }
    }
if(tail->next == nil)
    mk(tail->s);
else {
    head = newword("<command line arguments>");
    addrules(head, tail, strdup(""), VIR, mkinline, nil);
    mk(head->s);
}
@
% could pass 0 instead of mkinline I think

% VIR? virtual? used later?





\chapter{Parsing [[mkfile]]s}
\l Parsing Rules and Variables

% parse() will modify rules, metarules, target1.
%ocaml: return those instead of modifying globals

% UNIX make was using Yacc? 
% cleaner to use Yacc? tricky cos in recipe the tokens have a different meaning
%  => need a lexer with different states/modes (a la Perl/PHP)

\section{[[parse()]]}

% error management:
<<global infile>>=
char *infile;
@

<<global mkinline>>=
int mkinline;
@
% rename just inline?

<<function SYNERR>>=
#define	SYNERR(l)	(fprint(STDERR, "mk: %s:%d: syntax error; ", \
                            infile, ((l)>=0)? (l) : mkinline))
@
% when call SYNERR with explicit line? when dont want default of using
% mkinline because error was actually before.


% read fd, make input buffer, then get line and put in buf.
% use of libbio
% use of Bufblock, appendix X. =~ growing string (realloc)

<<function parse>>=
void
parse(char *f, fdt fd, bool varoverride)
{
    Biobuf in;
    Bufblock *buf;
    char c;
    Word *head, *tail;
    int hline; // head line number
    <<[[parse()]] other locals>>

    <<[[parse()]] sanity check fd>>
    <<[[parse()]] start, push>>

    infile = strdup(f);
    mkinline = 1;
    Binit(&in, fd, OREAD);
    buf = newbuf();

    // Lexing
    while(assline(&in, buf)){
        hline = mkinline;

        // Parsing
        c = rhead(buf->start, &head, &tail,     &attr, &prog);

        // Semantic actions
        switch(c)
        {
        <<[[parse()]] switch rhead cases>>
        default:
            SYNERR(hline);
            fprint(STDERR, "expected one of :<=\n");
            Exit();
            break;
        }
    }
    close(fd);
    freebuf(buf);
    <<[[parse()]] end, pop>>
}
@
\l leak strdup for infile? when free?

<<[[parse()]] sanity check fd>>=
if(fd < 0){
    perror(f);
    Exit();
}
@


<<[[parse()]] other locals>>=
// bitset<Rule_attr>
int attr;
char *prog; // for :P: attribute TODO??
@
\t aspectize 

\subsection{Assembling a line, [[assline()]]}

% =~ lexing


% nice function name
<<function assline>>=
/*
 *	Assemble a line skipping blank lines, comments, and eliding
 *	escaped newlines
 */
bool
assline(Biobuf *bp, Bufblock *buf)
{
    int c;
    <<[[assline()]] other locals>>

    // reset buf
    buf->current = buf->start;

    while ((c = nextrune(bp, true)) >= 0){
        switch(c)
        {
        case '\n':
            if (buf->current != buf->start) {
                insert(buf, '\0');
                return true;
            }
            break;		/* skip empty lines */
        <<[[assline()]] switch character cases>>
        default:
            rinsert(buf, c);
            break;
        }
    }
eof:
    insert(buf, '\0');
    return *buf->start != '\0';
}
@
% rinsert until newline
\t have resetbuf() function and emptybuf() function? and bufcontent()?
%ocaml: use Buffer too

% return false when EOF after line parsed


\subsubsection{Escaped newline, [[nextrune()]]}

<<function nextrune>>=
/*
 *	get next character stripping escaped newlines
 *	the flag specifies whether escaped newlines are to be elided or
 *	replaced with a blank.
 */
int
nextrune(Biobuf *bp, bool elide)
{
    int c;

    for (;;) {
        c = Bgetrune(bp);
        if (c == '\\') {
            if (Bgetrune(bp) == '\n') {
                mkinline++;
                if (elide)
                    continue;
                return ' ';
            }
            Bungetrune(bp);
        }
        if (c == '\n')
            mkinline++;
        return c;
    }
}
@
\l int -> Rune?? also in bio.h?
\t when do you not elide?

% Bgetrune comes from bio.h, buffered IO library (libbio).

% need to support this escape newline feature? 
% Yes, when setting variables containing lots of elements,
% for instance OBJS.
%alt: have syntax for lists, with terminator different than newline,
%  for instance ']' in ocaml
% space and newlines have meaning (TAB used to have one too, consistent,
%  but in the end ugly because dont see diff in editor and can do without)



\subsubsection{Comments}

<<[[assline()]] other locals>>=
int lastc;
@
\t why? to handle \ again?

<<[[assline()]] switch character cases>>=
case '#':
    lastc = '#';
    while ((c = Bgetc(bp)) != '\n') {
        if (c < 0)
            goto eof;
        if(c != '\r')
            lastc = c;
    }
    mkinline++;
    if (lastc == '\\')
        break;		/* propagate escaped newlines??*/
    if (buf->current != buf->start) {
        insert(buf, '\0');
        return true;
    }
    break;
@
\t \r ? for windows?

\subsubsection{Escaped character}

<<[[assline()]] switch character cases>>=
case '\\':
case '\'':
case '"':
    rinsert(buf, c);
    if (escapetoken(bp, buf, true, c) == 0)
        Exit();
    break;
@
\t why process that? 
\t seems like only second one handled, so maybe can remove cases?

% rc.c
<<function escapetoken>>=
/*
 *	Input an escaped token.  Possible escape chars are single-quote,
 *	double-quote and backslash.  Only the first is a valid escape for
 *	rc; the others are just inserted into the receiving buffer.
 */
bool
escapetoken(Biobuf *bp, Bufblock *buf, bool preserve, int esc)
{
    int c;
    int line;

    if(esc != '\'')
        return true;

    line = mkinline;
    while((c = nextrune(bp, 0)) > 0){
        if(c == '\''){
            if(preserve)
                rinsert(buf, c);
            c = Bgetrune(bp);
            if (c < 0)
                break;
            if(c != '\''){
                Bungetrune(bp);
                return true;
            }
        }
        rinsert(buf, c);
    }
    SYNERR(line); 
    fprint(STDERR, "missing closing %c\n", esc);
    return false;
}
@
\t complex code




\subsection{Parsing the head of a line, [[rhead()]]}

% =~ parsing

% <, =, :

% rhead for rule head, but used not only for rule.

\l int -> Rune for return?
<<function rhead>>=
static int
rhead(char *line, Word **h, Word **t,    int *attr, char **prog)
{
    char *p;
    int sep; // : = < 
    Word *w;
    <<[[rhead()]] other locals>>

    p = charin(line, ":=<");
    if(p == 0)
        return '?';

    sep = *p;
    *p++ = '\0';
    <<[[rhead()]] adjust sep if dynamic mkfile [[<|]]>>
    <<[[rhead()]] adjust [[attr]] and [[prog]]>>

    // potentially expand variable names in head
    *h = w = stow(line);
    <<[[rhead()]] sanity check w>>

    // potentially expand variable names in tail
    *t = stow(p);

    return sep;
}
@
\t why need intermediate w? just sanity check *h ?

% FIGURE where before long string,
% then string split in 2 because of \0 put at place of special char

% charin later, complex actually, handle special syntax in head which could
%  contain inside a :=<


<<[[rhead()]] sanity check w>>=
if(*w->s == 0 && sep != '<' && sep != '|') {
    SYNERR(mkinline-1);
    fprint(STDERR, "no var/target on left side of assignment/rule\n");
    Exit();
}
@
%pad: I added the /target in error message

% except <, should have a head (var or target)



<<[[rhead()]] adjust [[attr]] and [[prog]]>>=
*attr = 0; // Nothing
*prog = nil;

<<[[rhead()]] if sep is [[=]]>>
<<[[rhead()]] if sep is [[:]]>>
@

\subsection{Parsing words, [[stow()]]}

% will expand not just variable set in mkfile but also
% plan9 variables, because of [[readenv()]] at the beginning
% of mk.

% note also that do not expand in recipe! this is done
% by shell, and so it allows late binding of variables, use
% before define, etc.

% string to word
<<function stow>>=
Word *
stow(char *s)
{
    Word *head, *w, *new;

    w = head = nil;
    while(*s){
        new = nextword(&s);
        if(new == nil)
            break;
        // add_list(new, head)
        if (w)
            w->next = new;
        else
            head = w = new;
        // concat_list(head, new)
        while(w->next)
            w = w->next;
        
    }
    if (!head)
        head = newword("");
    return head;
}
@
% new can already contain multiple words!
\t rename w to last?
\t rename newword -> new_singleword
\t rename nextword to nextwords?

% stow -> <>
<<function nextword>>=
/*
 *	break out a word from a string handling quotes, executions,
 *	and variable expansions.
 */
static Word*
nextword(char **s)
{
    char *cp;
    Bufblock *b;
    Word *head, *tail;
    Rune r;
    bool empty;
    <<[[nextword()]] other locals>>

    cp = *s;
    b = newbuf();

restart:
    head = tail = nil;
    while(*cp == ' ' || *cp == '\t')		/* leading white space */
        cp++;
    empty = true;

    while(*cp){
        cp += chartorune(&r, cp);
        switch(r)
        {
        case ' ':
        case '\t':
        case '\n':
            goto out;
        <<[[nextword()]] switch rune cases>>
        default:
            empty = false;
            rinsert(b, r);
            break;
        }
    }
out:
    *s = cp;
    if(b->current != b->start){
        if(head){
            cp = b->current;
            bufcpy(b, tail->s, strlen(tail->s));
            bufcpy(b, b->start, cp - b->start);
            insert(b, '\0');
            free(tail->s);
            tail->s = strdup(cp);
        } else {
            insert(b, '\0');
            head = newword(b->start);
        }
    }
    freebuf(b);
    return head;
}
@
%$



<<[[nextword()]] switch rune cases>>=
case '\\':
case '\'':
case '"':
    empty = false;
    cp = expandquote(cp, r, b);
    if(cp == 0){
        fprint(STDERR, "missing closing quote: %s\n", *s);
        Exit();
    }
    break;
@
\t need that again?


\subsection{Expanding variables in words (part 1)}

% in rules target, prerequisites, in variable uses.
% but not recipe!

<<[[nextword()]] other locals>>=
Word *w;
@

<<[[nextword()]] switch rune cases>>=
case '$':
    w = varsub(&cp);
    if(w == nil){
        if(empty)
            goto restart;
        break;
    }
    empty = false;
    if(b->current != b->start){
        bufcpy(b, w->s, strlen(w->s));
        insert(b, '\0');
        free(w->s);
        w->s = strdup(b->start);
        b->current = b->start;
    }
    if(head){
        bufcpy(b, tail->s, strlen(tail->s));
        bufcpy(b, w->s, strlen(w->s));
        insert(b, '\0');
        free(tail->s);
        tail->s = strdup(b->start);
        tail->next = w->next;
        free(w->s);
        free(w);
        b->current = b->start;
    } else
        tail = head = w;

    while(tail->next)
        tail = tail->next;
    break;
@
%$

% done at parsing time for the non recipe part (target and prerequisites).

% see varsup() later.


\section{Rules, {\em t}[[:]]{\em reqs}]]}


<<[[parse()]] other locals>>=
char *body;
@

<<[[parse()]] switch rhead cases>>=
case ':':
    body = rbody(&in);
    addrules(head, tail, body, attr, hline, prog);
    break;
@


% rule body
<<function rbody>>=
static char *
rbody(Biobuf *in)
{
    Bufblock *buf;
    int r, lastr;
    char *p;

    lastr = '\n';
    buf = newbuf();
    for(;;){
        r = Bgetrune(in);
        if (r < 0)
            break;
        if (lastr == '\n') {
            if (r == '#')
                rinsert(buf, r);
            else if (r != ' ' && r != '\t') {
                Bungetrune(in);
                break;
            }
        } else
            rinsert(buf, r);
        lastr = r;
        if (r == '\n')
            mkinline++;
    }
    insert(buf, '\0');
    p = strdup(buf->start);
    freebuf(buf);

    return p;
}
@
\t code for sharp?? consume comment on next line? or is it a feature?
\t test!!

% no stow here! no variable expansion

<<function addrules>>=
void
addrules(Word *head, Word *tail, char *body, int attr, int hline, char *prog)
{
    Word *w;

    assert(/*addrules args*/ head && body);
    /* tuck away first non-meta rule as default target*/

    <<[[addrules()]] set [[target1]]>>
    for(w = head; w; w = w->next)
        addrule(w->s, tail, body, head, attr, hline, prog);
}
@
% can have multiple target, so go through all of them


<<[[addrules()]] set [[target1]]>>=
if(target1 == nil && !(attr&REGEXP)){
    for(w = head; w; w = w->next)
        if(charin(w->s, "%&"))
            break;
    if(w == nil)
        target1 = wdup(head);
}
@



\subsection{Rule attributes}

<<[[rhead()]] other locals>>=
Rune r;
int n;
@


<<[[rhead()]] if sep is [[:]]>>=
if((sep == ':') && *p && (*p != ' ') && (*p != '\t')){
    while (*p) {
        n = chartorune(&r, p);
        if (r == ':')
            break;
        p += n;
        switch(r)
        {
        <<[[rhead()]] when parsing rule attributes, switch rune cases>>
        default:
            SYNERR(-1);
            fprint(STDERR, "unknown attribute '%c'\n", p[-1]);
            Exit();
        }
    }
    if (*p++ != ':') {
eos:
        SYNERR(-1);
        fprint(STDERR, "missing trailing :\n");
        Exit();
    }
}
@
%old: switch cases originally sorted alphabetically, but after
% LP distribution, they might not be anymore

% XXX
\t LP distribute

<<[[Rule_attr]] cases>>=
DEL    = 0x0080,
@
<<[[rhead()]] when parsing rule attributes, switch rune cases>>=
case 'D':
    *attr |= DEL;
    break;
@

<<[[rhead()]] when parsing rule attributes, switch rune cases>>=
case 'E':
    *attr |= NOMINUSE;
    break;
@

<<[[Rule_attr]] cases>>=
NOVIRT = 0x0100,
@
<<[[rhead()]] when parsing rule attributes, switch rune cases>>=
case 'n':
    *attr |= NOVIRT;
    break;
@

<<[[Rule_attr]] cases>>=
NOREC  = 0x0040,
@
<<[[rhead()]] when parsing rule attributes, switch rune cases>>=
case 'N':
    *attr |= NOREC;
    break;
@

<<[[rhead()]] when parsing rule attributes, switch rune cases>>=
case 'Q':
    *attr |= QUIET;
    break;
@

<<[[rhead()]] when parsing rule attributes, switch rune cases>>=
case 'R':
    *attr |= REGEXP;
    break;
@


<<[[Rule_attr]] cases>>=
UPD    = 0x0004,
@
<<[[rhead()]] when parsing rule attributes, switch rune cases>>=
case 'U':
    *attr |= UPD;
    break;
@

<<[[Rule_attr]] cases>>=
VIR    = 0x0010,
@
<<[[rhead()]] when parsing rule attributes, switch rune cases>>=
case 'V':
    *attr |= VIR;
    break;
@


<<[[rhead()]] other locals>>=
char *pp;
@

<<[[rhead()]] when parsing rule attributes, switch rune cases>>=
case 'P':
    pp = utfrune(p, ':');
    if (pp == 0 || *pp == 0)
        goto eos;
    *pp = 0;
    *prog = strdup(p);
    *pp = ':';
    p = pp;
    break;
@
\t WHAT IS THAT?

\section{Included files, [[<]]{\em file}}

<<[[parse()]] other locals>>=
fdt newfd;
char *p;
@

<<[[parse()]] switch rhead cases>>=
case '<':
    p = wtos(tail, ' ');
    <<[[parse()]] when parsing included file, sanity check p>>
    newfd = open(p, OREAD);
    <<[[parse()]] when parsing included file, sanity check newfd>>
    else
        parse(p, newfd, false);
    break;
@
% parsed by rhead, so got variable expansion there too! < $arch.mk 


<<[[parse()]] start, push>>=
ipush();
@

<<[[parse()]] end, pop>>=
ipop();
@


<<struct input>>=
struct Input
{
    char *file;
    int line;

    // Extra
    struct Input *next;
};
@

<<global inputs>>=
static struct Input *inputs = 0;
@

% can process many files, because of the </sys/src/... 

<<function ipush>>=
void
ipush(void)
{
    struct Input *in, *me;

    me = (struct Input *)Malloc(sizeof(*me));
    me->file = infile;
    me->line = mkinline;
    me->next = nil;

    // add_list(me, inputs)
    if(inputs == nil)
        inputs = me;
    else {
        for(in = inputs; in->next; )
            in = in->next;
        in->next = me;
    }
}
@

<<function ipop>>=
void
ipop(void)
{
    struct Input *in, *me;

    assert(/*pop input list*/ inputs != 0);
    // me = pop_list(inputs)
    if(inputs->next == nil){
        me = inputs;
        inputs = nil;
    } else {
        for(in = inputs; in->next->next; )
            in = in->next;
        me = in->next;
        in->next = nil;
    }
    infile = me->file;
    mkinline = me->line;
    free((char *)me);
}
@



<<[[parse()]] when parsing included file, sanity check p>>=
if(*p == '\0'){
    SYNERR(-1);
    fprint(STDERR, "missing include file name\n");
    Exit();
}
@
<<[[parse()]] when parsing included file, sanity check newfd>>=
if(newfd < 0){
    fprint(STDERR, "warning: skipping missing include file: ");
    perror(p);
}
@

\section{Variable definitions, {\em V}[[=]]{\em X}}


<<[[parse()]] other locals>>=
bool set;
@

<<[[parse()]] switch rhead cases>>=
case '=':
    <<[[parse()]] when parsing variable definitions, sanity check head>>
    <<[[parse()]] when parsing variable definitions, override handling>>

    if(set){
        setvar(head->s, (void *) tail);
        symlook(head->s, S_WESET, (void *)"");
    }
    <<[[parse()]] when parsing variable definitions, if variable with attr>>
    break;
@
%dead: was already commented in the original code
%    /*
%    char *cp;
%    dumpw("tail", tail);
%    cp = wtos(tail, ' '); print("assign %s to %s\n", head->s, cp); free(cp);
%    */


<<[[parse()]] when parsing variable definitions, override handling>>=
if(symlook(head->s, S_OVERRIDE, nil)){
    set = varoverride;
} else {
    set = true;
    if(varoverride)
        symlook(head->s, S_OVERRIDE, (void *)"");
}
@
\t could simplify maybe, if there, then set set=false; clearer.


<<[[Sxxx]] cases>>=
S_OVERRIDE,	/* can't override */
@
% when do mk xxx=yyy, it's overriding!

<<[[Sxxx]] cases>>=
S_WESET,	/* variable; we set in the mkfile */
@
% set in mkfile or via mk xxx=yyy? when mk xxx=yyy, varoverride is true
%  so also S_WESET i guess.
\t useful? used for?


<<[[parse()]] when parsing variable definitions, sanity check head>>=
if(head->next){
    SYNERR(-1);
    fprint(STDERR, "multiple vars on left side of assignment\n");
    Exit();
}
@


\subsection{Variable attributes}

% rhead can set attr?

% variable with attributes?? just private var
%  to not transmit to recipe process?

<<[[parse()]] when parsing variable definitions, if variable with attr>>=
if(attr)
    symlook(head->s, S_NOEXPORT, (void *)"");
@

<<[[Sxxx]] cases>>=
S_NOEXPORT,	/* var -> noexport */ // set of noexport variables
@


% rc.c
<<global termchars>>=
char	*termchars = "'= \t";	/*used in parse.c to isolate assignment attribute*/
@

<<[[rhead()]] if sep is [[=]]>>=
if(sep == '='){
    pp = charin(p, termchars);	/* termchars is shell-dependent */
    if (pp && *pp == '=') {
        while (p != pp) {
            n = chartorune(&r, p);
            switch(r)
            {
            default:
                SYNERR(-1);
                fprint(STDERR, "unknown attribute '%c'\n",*p);
                Exit();
            case 'U':
                *attr = 1;
                break;
            }
            p += n;
        }
        p++;		/* skip trailing '=' */
    }
}
@




\section{Variable uses (part 2), [[$]]{\em V} }
%$

\t merge with part 1
% not just $V, can have complex pattern there too.
% sometimes ${xx:%.y=%.z} ! but later in adv topics

% nextword -> <>
<<function varsub>>=
Word*
varsub(char **s)
{
    Bufblock *b;
    Word *w;

    <<[[varsub()]] if variable starts with open brace>>
    // else

    b = varname(s);
    if(b == nil)
        return nil;

    w = varmatch(b->start);

    freebuf(b);
    return w;
}
@
% yes! ${x:%=%}

%\subsection{Simple variables, }
%$

<<function varname>>=
/*
 *	extract a variable name
 */
static Bufblock*
varname(char **s)
{
    Bufblock *b;
    char *cp;
    Rune r;
    int n;

    b = newbuf();
    cp = *s;
    for(;;){
        n = chartorune(&r, cp);
        if (!WORDCHR(r))
            break;
        rinsert(b, r);
        cp += n;
    }
    <<[[varname()]] sanity check b>>
    *s = cp;
    insert(b, '\0');
    return b;
}
@

% what constitutes a variable name, anything except special chars
%  maybe specific to shell too?
<<function WORDCHR>>=
#define WORDCHR(r)	((r) > ' ' && !utfrune("!\"#$%&'()*+,-./:;<=>?@[\\]^`{|}~", (r)))
@
%$


<<[[varname()]] sanity check b>>=
if (b->current == b->start){
    SYNERR(-1);
    fprint(STDERR, "missing variable name <%s>\n", *s);
    freebuf(b);
    return nil;
}
@




<<function varmatch>>=
static Word*
varmatch(char *name)
{
    Word *w;
    Symtab *sym;
    
    sym = symlook(name, S_VAR, nil);
    if(sym){
            /* check for at least one non-NULL value */
        for (w = sym->u.ptr; w; w = w->next)
            if(w->s && *w->s)
                return wdup(w);
    }
    return nil;
}
@




\chapter{Building the Dependency Graph}

% will see mk later. But will call graph(target)
% go down tree using rules (and metarules)

\section{[[graph()]] and [[applyrules()]]}

% constructor?
% mk -> <>
<<function graph>>=
Node*
graph(char *target)
{
    Node *root;
    <<[[graph()]] other locals>>

    <<[[graph()]] set cnt for infinite rule detection>>
    root = applyrules(target, cnt);
    <<[[graph()]] free cnt>>

    <<[[graph()]] checking the graph>>

    // propagate attributes in rules to their node
    attribute(root);

    return root;
}
@
%pad: node -> root, clearer I think





<<function applyrules>>=
static Node*
applyrules(char *target, char *cnt)
{
    Node *node;
    Arc head;
    Arc *a = &head;
    <<[[applyrules]] other locals>>

    <<[[applyrules]] debug>>
    <<[[applyrules]] check node cache if target is already there>>
    // else

    target = strdup(target);
    // calls timeof()
    node = newnode(target);

    head.n = nil;
    head.next = nil;

    <<[[applyrules]] set rmatch>>

    // apply regular rules with target as a head (modify node, head, a)
    <<[[applyrules()]] apply regular rules>>

    // apply meta rules
    <<[[applyrules()]] apply meta rules>>

    // ???
    a->next = node->prereqs;
    node->prereqs = head.next;

    return node;
}
@
\t node->prereqs should be nil no?

% call to newnode() which will call timeof()!

%old: in comment in the original code!
%/*		if(r->attr&VIR)
% *			node->flags |= VIRTUAL;
% *		if(r->attr&NOREC)
% *			node->flags |= NORECIPE;
% *		if(r->attr&DEL)
% *			node->flags |= DELETE;
% */
%/*		if(r->attr&VIR)
% *			node->flags |= VIRTUAL;
% *		if(r->attr&NOREC)
% *			node->flags |= NORECIPE;
% *		if(r->attr&DEL)
% *			node->flags |= DELETE;
% */



\section{Finding the simple rules for a target}

% built index while parsing in hash

<<[[applyrules]] other locals>>=
Symtab *sym;
Rule *r;
Word *w;
@
% rename w to prerequiste?

<<[[applyrules()]] apply regular rules>>=
sym = symlook(target, S_TARGET, nil);
for(r = (sym? sym->u.ptr : nil); r; r = r->chain){
    <<[[applyrules()]] skip this rule and continue if some conditions>>
    <<[[applyrules()]] infinite rule detection part1>>

    node->flags |= PROBABLE;

    <<[[applyrules()]] if no prerequistes in rule r>>
    else
        for(w = r->tail; w; w = w->next){
            // recursive call!
            a->next = newarc(applyrules(w->s, cnt), r, "", rmatch);
            a = a->next;
    }
    <<[[applyrules()]] infinite rule detection part2>>
    head.n = node;
}
@
% PROBABLE?

<<[[applyrules()]] skip this rule and continue if some conditions>>=
if(r->attr&META) continue;
if(strcmp(target, r->target)) continue; // how can happen??
if((!r->recipe || !*r->recipe)
   && (!r->tail || !r->tail->s || !*r->tail->s)) 
      continue;	/* no effect; ignore */
@
%TODO safe to continue when no recipe? should still have an arc
% so than can check if outofdate no?
\t how can be META and in S_TARGET?

<<[[applyrules()]] if no prerequistes in rule r>>=
// no prerequistes, a leaf, still create fake arc
if(!r->tail || !r->tail->s || !*r->tail->s) {
    a->next = newarc((Node *)nil, r, "", rmatch);
    a = a->next;
} 
@
% stem is "" here
% why need that? to at least have something propagate in attribute()?

\section{Finding matching metarules and substituting the stem}

<<[[applyrules]] other locals>>=
char buf[NAMEBLOCK];
char stem[NAMEBLOCK];
@
% NAMEBLOCK ??

% this time, do not use S_TARGET hash, go through all metarules
% and check if pattern can match target.

<<[[applyrules()]] apply meta rules>>=
for(r = metarules; r; r = r->next){
    <<[[applyrules()]] skip this meta rule and continue if some conditions>>
    <<[[applyrules()]] if regexp rule then continue if some conditions>>
    else {
        if(!match(node->name, r->target, stem)) continue;
    }
    <<[[applyrules()]] infinite rule detection part1>>

    <<[[applyrules()]] if no prerequistes in meta rule r>>
    else
        for(w = r->tail; w; w = w->next){
            <<[[applyrules()]] if regexp rule, adjust buf and rmatch>>
            else
                subst(stem, w->s, buf, sizeof(buf));
            // recursive call!
            a->next = newarc(applyrules(buf, cnt), r, stem, rmatch);
            a = a->next;
        }
    <<[[applyrules()]] infinite rule detection part2>>
}
@

<<[[applyrules()]] skip this meta rule and continue if some conditions>>=
if((!r->recipe || !*r->recipe) 
   && (!r->tail || !r->tail->s || !*r->tail->s)) 
    continue;	/* no effect; ignore */
if ((r->attr&NOVIRT) && a != &head && (a->r->attr&VIR))
    continue;
@

<<[[applyrules()]] if no prerequistes in meta rule r>>=
if(!r->tail || !r->tail->s || !*r->tail->s) {
    a->next = newarc((Node *)nil, r, stem, rmatch);
    a = a->next;
} 
@
% almost identical to before, except pass stem here instead of ""
% (not sure it matters, maybe could factorize code)

\subsection{Matching, [[match()]]}

% go through template until percent, and progress at the same time
% on name.

<<function match>>=
bool
match(char *name, char *template, char *stem)
{
    Rune r;
    int n;

    while(*name && *template){
        n = chartorune(&r, template);
        if (PERCENT(r))
            break;
        while (n--)
            if(*name++ != *template++)
                return false;
    }
    if(!PERCENT(*template))
        return false;

    n = strlen(name) - strlen(template+1);
    if (n < 0)
        return false;
    if (strcmp(template+1, name+n))
        return false;

    strncpy(stem, name, n);
    stem[n] = '\0';

    <<[[match()]] if ampersand template>>

    return true;
}
@
% simple pattern, single % or &


<<[[match()]] if ampersand template>>=
if(*template == '&')
    return !charin(stem, "./");
@
\l adv topics?

\subsection{Substituting, [[subst()]]}

<<function subst>>=
void
subst(char *stem, char *template,   char *dest, int dlen)
{
    Rune r;
    char *s, *e;
    int n;

    e = dest + dlen - 1;
    while(*template){
        n = chartorune(&r, template);
        if (PERCENT(r)) {
            template += n;
            for (s = stem; *s; s++)
                if(dest < e)
                    *dest++ = *s;
        } else
            while (n--){
                if(dest < e)
                    *dest++ = *template;
                template++;
            }
    }
    *dest = '\0';
}
@



\section{[[timeof()]]}
% for the leaves!


% multiple levels of cache ... first in cache, 
% then bulk so will get more hit cache.
% force is here to say if want to bypass cache and redo
% the actual read! for instance after the recipe is done
% we want to update the time of the file and disable the cache!

% newnode() -> <> -> mkmktime -> bulktime
%                             -> dirstat (libc)

<<function timeof>>=
ulong
timeof(char *name, bool force)
{
    ulong t;
    <<[[timeof()]] other locals>>

    <<[[timeof()]] if name archive member>>
    if(force)
        return mkmtime(name, true);

    <<[[timeof()]] check time cache>>
    t = mkmtime(name, false);
    <<[[timeof()]] update time cache>>
    return t;
}
@
%old: ulong mtime(char *name) {  return mkmtime(name, true);}
%but simpler to remove, refactor caller sites

<<function mkmtime>>=
ulong
mkmtime(char *name, bool force)
{
    Dir *d;
    char buf[4096];
    ulong t;
    <<[[mkmtime]] locals>>

    strecpy(buf, buf + sizeof buf - 1, name);
    cleanname(buf);
    name = buf;

    <<[[mkmtime()]] bulk dir optimisation>>

    if((d = dirstat(name)) == nil)
        return 0;

    t = d->mtime;
    free(d);

    return t;
}
@


\t adv topics? with opti of node cache?
<<[[Sxxx]] cases>>=
S_TIME,		/* file -> time */
@

<<[[timeof()]] other locals>>=
Symtab *sym;
@

<<[[timeof()]] check time cache>>=
sym = symlook(name, S_TIME, nil);
if (sym)
    return sym->u.value;		/* uggh */
@

<<[[timeof()]] update time cache>>=
if(t == 0)
    return 0;
symlook(name, S_TIME, (void*)t);		/* install time in cache */
@



\section{Checking the rules}

<<[[graph()]] checking the graph>>=
cyclechk(root);

root->flags |= PROBABLE;	/* make sure it doesn't get deleted */
vacuous(root);

ambiguous(root);
@

\subsection{Cycle detection}

<<[[Node_flag]] cases>>=
CYCLE      = 0x0002,
@

<<function cyclechk>>=
static void
cyclechk(Node *n)
{
    Arc *a;

    if((n->flags&CYCLE) && n->prereqs){
        fprint(STDERR, "mk: cycle in graph detected at target %s\n", n->name);
        Exit();
    }
    n->flags |= CYCLE;
    for(a = n->prereqs; a; a = a->next)
        if(a->n)
            cyclechk(a->n);
    n->flags &= ~CYCLE;
}
@

\subsection{Infinite rule detection, [[$NREP]]}%$


<<[[graph()]] other locals>>=
// map<ruleid, int>
char *cnt;
@

<<[[graph()]] set cnt for infinite rule detection>>=
cnt = rulecnt();
@

<<[[graph()]] free cnt>>=
free(cnt);
@

% statistic on how much a rule was fired? for infinite detection?
<<function rulecnt>>=
char*
rulecnt(void)
{
    char *s;

    s = Malloc(nrules);
    memset(s, 0, nrules);
    return s;
}
@
\l mv Profiling? or used also for checking?
\l but hard to move profiling, passed around a lot
% nrules modified by addrule


% for GC? to identify unused rules?
<<[[Rule]] other fields>>=
int 		rule;		/* rule number */
@




% n reps, to manage bad rules like %: %.c that can be executed multiple times
<<global nreps>>=
int nreps = 1;
@
% n repetition?


<<[[applyrules()]] infinite rule detection part1>>=
if(cnt[r->rule] >= nreps) 
    continue;
cnt[r->rule]++;
@

<<[[applyrules()]] infinite rule detection part2>>=
cnt[r->rule]--;
@




<<[[mk()]] initialisation>>=
nrep();		/* it can be updated dynamically */
@

% mk -> nrep
<<function nrep>>=
void
nrep(void)
{
    Symtab *sym;
    Word *w;

    sym = symlook("NREP", S_VAR, nil);
    if(sym){
        w = sym->u.ptr;
        if (w && w->s && *w->s)
            nreps = atoi(w->s);
    }
    if(nreps < 1)
        nreps = 1;
    <<[[nrep()]] if DEBUG(D_GRAPH)>>
}
@


\subsection{Vacuous rule detection}

% def of vacuous? =~ stupid
\t example of stupid rule?

<<[[Node_flag]] cases>>=
VACUOUS    = 0x0200,
@

<<[[Node_flag]] cases>>=
PROBABLE   = 0x0100,
@

<<[[Node_flag]] cases>>=
READY      = 0x0004,
@


<<[[Arc]] other fields>>=
// bool (TOGO)
short flag;
@

<<constant TOGO>>=
/* Arc.flag */
#define		TOGO		true
@



<<function vacuous>>=
static bool
vacuous(Node *node)
{
    Arc *la, *a;
    bool vac = !(node->flags&PROBABLE);

    if(node->flags&READY)
        return node->flags&VACUOUS;
    node->flags |= READY;

    for(a = node->prereqs; a; a = a->next)
        if(a->n && vacuous(a->n) && (a->r->attr&META))
            a->flag |= TOGO;
        else
            vac = false;

    /* if a rule generated arcs that DON'T go; no others from that rule go */
    for(a = node->prereqs; a; a = a->next)
        if((a->flag&TOGO) == 0)
            for(la = node->prereqs; la; la = la->next)
                if((la->flag&TOGO) && (la->r == a->r)){
                    la->flag &= ~TOGO;
                }
    togo(node);
    if(vac) {
        fprint(STDERR, "mk: vacuous node found %s\n", node->name);
        node->flags |= VACUOUS;
    }
    return vac;
}
@
% pad: I've added the warning

<<function togo>>=
static void
togo(Node *node)
{
    Arc *a, *la;

    /* delete them now */
    la = nil;
    for(a = node->prereqs; a; la = a, a = a->next)
        if(a->flag&TOGO){
            fprint(STDERR, "mk: vacuous arc found %s->%s\n", 
                     node->name, a->n->name);
            //delete(a, node->prereqs)
            if(a == node->prereqs)
                node->prereqs = a->next;
            else
                la->next = a->next, a = la;
        }
}
@
% la = last a
% pad: I've added the warning

\subsection{Ambiguous rule detection}

%nice output:
%mk: ambiguous recipes for install:
%	install <-(/sys/src/cmd/mklib:28)- libthreads.a <-(/sys/src/cmd/mklib:12)- libthreads.a(scheduler.8)
%	install <-(mkfile:19)- 

% how to allow :: of GNU make?
% maybe bad to allow :: in the end.

<<function ambiguous>>=
static void
ambiguous(Node *n)
{
    Arc *a;
    Rule *r = nil;
    Arc *la = nil;
    bool bad = false;

    for(a = n->prereqs; a; a = a->next){
        if(a->n)
            ambiguous(a->n);
        if(*a->r->recipe == 0) continue;
        if(r == nil) {
            r = a->r;
            la = a;
        }
        else{
            if(r->recipe != a->r->recipe){
                if((r->attr&META) && !(a->r->attr&META)){
                    la->flag |= TOGO;
                    r = a->r, la = a;
                } else if(!(r->attr&META) && (a->r->attr&META)){
                    a->flag |= TOGO;
                    continue;
                }
            }
            if(r->recipe != a->r->recipe){
                if(!bad){
                    fprint(STDERR, "mk: ambiguous recipes for %s:\n", n->name);
                    bad = true;
                    trace(n->name, la);
                }
                trace(n->name, a);
            }
        }
    }
    if(bad)
        Exit();
    togo(n);
}
@

<<function trace>>=
static void
trace(char *s, Arc *a)
{
    fprint(STDERR, "\t%s", s);
    while(a){
        fprint(STDERR, " <-(%s:%d)- %s", a->r->file, a->r->line,
            a->n? a->n->name:"");
        if(a->n){
            for(a = a->n->prereqs; a; a = a->next)
                if(*a->r->recipe) break;
        } else
            a = 0;
    }
    fprint(STDERR, "\n");
}
@

\section{Rule attribute propagation}

<<[[Node_flag]] cases>>=
VIRTUAL    = 0x0001,
NORECIPE   = 0x0400,
DELETE     = 0x0800,
@

% propagate from rule to node
% why?

<<function attribute>>=
static void
attribute(Node *n)
{
    Arc *a;

    for(a = n->prereqs; a; a = a->next){
        if(a->r->attr&VIR)
            n->flags |= VIRTUAL;
        if(a->r->attr&NOREC)
            n->flags |= NORECIPE;
        if(a->r->attr&DEL)
            n->flags |= DELETE;
        if(a->n)
            attribute(a->n);
    }
    if(n->flags&VIRTUAL)
        n->time = 0;
}
@



\chapter{Analyzing Outdated Dependencies}

% the core!

% main idea = 
% construct dependency graph for target root
% set all nodes to NOTMADE.
% Then ask to build root which will recurse. 
%  If leaf then node MADE (if exist).
%  Otherwise look at time if file > time of all children then MADE, 
%  otherwise run recipe job in parallel, return and wait it's MADE (so loop).

% while(root not finished) { run wave of jobs and update graph }

\section{[[mk()]]}


<<[[Node_flag]] cases>>=
NOTMADE    = 0x0020,
BEINGMADE  = 0x0040,
MADE       = 0x0080,
@
% NOTMADE initially (see clrmade())
% BEINGMADE? when start recipe, but mk can run in // so it returns!
%   can go back to node with BEINGMADE? when
%   2 files with deps on same Node? DAG
% MADE finally when recipe done! (or time was already good, so no need update)
%ocaml: should be different field than other node flags

% FIGURE displaying a tree of files and
% see how mk is running some waves of jobs, and how at each node
% there is a ready or outofdate boolean value.

<<global runerrs>>=
int runerrs;
@


% main -> <> -> graph() ; clrmade(); work()
<<function mk>>=
void
mk(char *target)
{
    Node *root;
    bool did = false;

    <<[[mk()]] initialisation>>

    root = graph(target);
    <<[[main()]] if DEBUG(D_GRAPH)>>
    clrmade(root);

    while(root->flags&NOTMADE){
        if(work(root, (Node *)nil, (Arc *)nil))
            did = true;	/* found something to do */
        else {
            if(waitup(1, (int *)nil) > 0){
                if(root->flags&(NOTMADE|BEINGMADE)){
                    assert(/*must be run errors*/ runerrs);
                    break;	/* nothing more waiting */
                }
            }
        }
    }
    if(root->flags&BEINGMADE) // because of a runerrs
        waitup(-1, (int *)nil);

    while(jobs)
        waitup(-2, (int *)nil);

    assert(/*target didnt get done*/ runerrs || (root->flags&MADE));
    if(!did)
        Bprint(&bout, "mk: '%s' is up to date\n", root->name);
}
@
%old: was called node, but root is better.
%note: subtle, important while loop! because of mk // so run some jobs
% but then later another job might depend on the end of this one,
% so have BEINGMADE flag and waitup??

\t wanted to make did a global because was always threading it
% everywhere and doing did = foo () || did;   
% possible? change semantic?

<<[[mk()]] initialisation>>=
runerrs = 0;
@


\section{[[clrmade()]]}

<<function MADESET>>=
#define	MADESET(n,m)	n->flags = (n->flags&~(NOTMADE|BEINGMADE|MADE))|(m)
@
% keep flags as they were, except for the made stuff
%ocaml: use a separate field than the other node attributes

<<function clrmade>>=
void
clrmade(Node *n)
{
    Arc *a;

    <<[[clrmade()]] n->flags pretend adjustments>>
    MADESET(n, NOTMADE);
    for(a = n->prereqs; a; a = a->next)
        if(a->n)
            clrmade(a->n);
}
@

\section{[[work()]]}

<<[[work()]] locals>>=
bool did = false;
@
\t move as a global! so no need return bool in work() also.

<<[[work()]] locals>>=
bool weoutofdate;
bool ready;
Arc *a;
Arc *ra;
@


% main -> mk -> <> -> outofdate(); dorecipe()

% have to do transitive closure of dependencies ... when
% "making" node, look at is prerequistes, and check if they need
% work too, because maybe a leaf was modified!

\t parent_node, prev_arc, TODO rename parameters?
<<function work>>=
bool
work(Node *node,   Node *p, Arc *parc)
{
    <<[[work()]] locals>>

    <<[[work()]] debug>>

    if(node->flags&BEINGMADE)
        return did;

    <<[[work()]] possibly unpretending node>>

    // Leaf case
    <<[[work()]] no prerequisite, a leaf>>
    // Node case
    /*
     *   now see if we are out of date or what
     */
    ready = true;
    weoutofdate = aflag;
    <<[[work()]] check if node out of date with prerequisites, recursively>>

    if(!ready)	/* can't do anything now */
        return did;
    if(!weoutofdate){
        MADESET(node, MADE);
        return did;
    }
    <<[[work()]] possibly pretending node>>

    did = dorecipe(node) || did;
    return did;
}
@
% can refactor in did ||= foo(); ? hmm maybe not, we actually want the
% side effect!

\t can refactor did in a global? dangerous ... but would clarify I think


% a leaf!
<<[[work()]] no prerequisite, a leaf>>=
/* consider no prerequisite case */
if(node->prereqs == nil){
    if(node->time == 0){
        <<[[work()]] print error when inexistent file without prerequisites>>
    } else
        MADESET(node, MADE);
    return did;
}
@

<<[[work()]] locals>>=
char cwd[256];
@

<<[[work()]] print error when inexistent file without prerequisites>>=
if(getwd(cwd, sizeof cwd))
    fprint(STDERR, "mk: don't know how to make '%s' in directory %s\n", node->name, cwd);
else
    fprint(STDERR, "mk: don't know how to make '%s'\n", node->name);

if(kflag){
    node->flags |= BEINGMADE;
    runerrs++;
} else
    Exit();
@


<<[[work()]] check if node out of date with prerequisites, recursively>>=
ra = nil;
for(a = node->prereqs; a; a = a->next)
    if(a->n){
        // recursive call! go in depth
        did = work(a->n, node, a) || did;

        if(a->n->flags&(NOTMADE|BEINGMADE))
            ready = false;
        if(outofdate(node, a, false)){
            weoutofdate = true;
            if((ra == nil) || (ra->n == nil) || (ra->n->time < a->n->time))
                ra = a;
        }
    } else {
        if(node->time == 0){
            weoutofdate = true;
            if(ra == nil)
                ra = a;
        }
    }
@
% when can happen have no node attached to an arc?
% when fake arc, see applyrules



%\section{[[outofdate()]]}

<<function outofdate>>=
bool
outofdate(Node *node, Arc *arc, bool eval)
{
    <<[[outofdate()]] locals>>

    <<[[outofdate()]] if arc->prog>>
    else 
     <<[[outofdate()]] of arc node is an archive member>>
     else
        /*
         * Treat equal times as out-of-date.
         * It's a race, and the safer option is to do
         * extra building rather than not enough.
         */
        return node->time < arc->n->time;
}
@
% inexistent file has zero time (like very very old time)

%note: on very fast machine the <= above test can be actually annoying.
% For instance in ocaml both the .cmo and .cmi may have
% been created in the same second by ocamlc, which means
% then that the .cmo file will always be recompiled because
% its .cmi has the same date (and recompiling the .cmo
% will generate a new .cmi, which then will trigger at the next
% round another compilation of the .cmo and so on).




\section{[[dorecipe()]]}

% if return error code, then should stop mk right?

%TODO: if have a TAB then does not display it in the output?
% if have a recipe which starts with some space then it outputs
% this extra space?

% main -> mk -> work -> ... -> run(newjob())
<<function dorecipe>>=
bool
dorecipe(Node *node)
{
    bool did = false;
    char buf[BIGBLOCK], cwd[256];
    Arc *a, *aa;
    Node *n;
    Rule *r = nil;
    Symtab *s;
    Word head, ahead, lp, ln, *w, *ww, *aw;

    aa = nil;
    /*
     *   pick up the rule
     */
    for(a = node->prereqs; a; a = a->next)
        if(*a->r->recipe) {
            aa = a;
            r = aa->r;
        }
    /*
     *   no recipe? go to buggery!
     */
    if(r == nil){
        if(!(node->flags&VIRTUAL) && !(node->flags&NORECIPE)){
            if(getwd(cwd, sizeof cwd))
                fprint(STDERR, "mk: no recipe to make '%s' in directory %s\n", node->name, cwd);
            else
                fprint(STDERR, "mk: no recipe to make '%s'\n", node->name);
            Exit();
        }
        if(strchr(node->name, '(') && node->time == 0)
            MADESET(node, MADE);
        else
            update(false, node);
        if(tflag){
            if(!(node->flags&VIRTUAL))
                touch(node->name);
            else if(explain)
                Bprint(&bout, "no touch of virtual '%s'\n", node->name);
        }
        return did;
    }

    /*
     *   build the node list
     */
    node->next = 0;
    head.next = 0;
    ww = &head;
    ahead.next = 0;
    aw = &ahead;
    if(r->attr&REGEXP){
        ww->next = newword(node->name);
        aw->next = newword(node->name);
    } else {
        for(w = r->alltargets; w; w = w->next){
            if(r->attr&META)
                subst(aa->stem, w->s, buf, sizeof(buf));
            else
                strecpy(buf, buf + sizeof buf - 1, w->s);
            aw->next = newword(buf);
            aw = aw->next;
            if((s = symlook(buf, S_NODE, 0)) == 0)
                continue;	/* not a node we are interested in */
            n = s->u.ptr;
            if(!aflag && n->time) {
                for(a = n->prereqs; a; a = a->next)
                    if(a->n && outofdate(n, a, false))
                        break;
                if(a == 0)
                    continue;
            }
            ww->next = newword(buf);
            ww = ww->next;
            if(n == node) continue;
            n->next = node->next;
            node->next = n;
        }
    }
    for(n = node; n; n = n->next)
        if((n->flags&READY) == 0)
            return did;
    /*
        gather the params for the job
    */
    lp.next = ln.next = 0;
    for(n = node; n; n = n->next){
        for(a = n->prereqs; a; a = a->next){
            if(a->n){
                addw(&lp, a->n->name);
                if(outofdate(n, a, false)){
                    addw(&ln, a->n->name);
                    if(explain)
                        fprint(1, "%s(%ld) < %s(%ld)\n",
                            n->name, n->time, a->n->name, a->n->time);
                }
            } else {
                if(explain)
                    fprint(1, "%s has no prerequisites\n",
                            n->name);
            }
        }
        MADESET(n, BEINGMADE);
    }
    run(newjob(r, node, aa->stem, aa->match, lp.next, ln.next, head.next, ahead.next));
    return true;
}
@
%/*print("lt=%s ln=%s lp=%s\n",wtos(head.next, ' '),wtos(ln.next, ' '),wtos(lp.next, ' '));


<<function update>>=
void
update(bool fake, Node *node)
{
    Arc *a;

    MADESET(node, fake? BEINGMADE : MADE);
    if(DEBUG(D_TRACE))
        print("update(): node %s time=%lud flags=0x%x\n", node->name, node->time, node->flags);

    if(((node->flags&VIRTUAL) == 0) && (access(node->name, 0) == 0)){
        node->time = timeof(node->name, true);
        <<[[update()]] unpretend node>>
        for(a = node->prereqs; a; a = a->next)
            if(a->prog)
                outofdate(node, a, true);
    } else {
        node->time = 1;
        for(a = node->prereqs; a; a = a->next)
            if(a->n && outofdate(node, a, true))
                node->time = a->n->time;
    }
}
@



<<function addw>>=
void
addw(Word *w, char *s)
{
    Word *lw;

    for(lw = w; w = w->next; lw = w){
        if(strcmp(s, w->s) == 0)
            return;
    }
    lw->next = newword(s);
}
@

\chapter{Scheduling Jobs}
% can do stuff in //! make originally didn't apparently

%trans: remaining thing to see, run(), the waitup()

\section{[[run()]]}


<<global nrunning>>=
static int nrunning;
@

<<global nproclimit>>=
static int nproclimit;
@


% main -> mk -> work -> dorecipe -> <> -> sched()
<<function run>>=
void
run(Job *j)
{
    Job *jj;

    // enqueue(j, jobs)
    if(jobs){
        for(jj = jobs; jj->next; jj = jj->next)
            ;
        jj->next = j;
    } else 
        jobs = j;
    j->next = nil;

    /* this code also in waitup after parse redirect */
    if(nrunning < nproclimit)
        sched();
}
@

\section{Launching jobs, [[sched()]]}

<<struct RunEvent>>=
struct RunEvent {
    int pid;
    Job *job;
};
@

% should be array[nproclimit]
<<global events>>=
static RunEvent *events;
@

% should be equal to nproclimit
<<global nevents>>=
static int nevents;
@


<<function sched>>=
static void
sched(void)
{
    Job *j;
    int slot;
    Envy *e;

    Bufblock *buf;
    char *flags;
    Node *n;

    if(jobs == nil){
        usage();
        return;
    }

    // j = pop(jobs)
    j = jobs;
    jobs = j->next;
    <<[[sched()]] if DEBUG(D_EXEC)>>

    slot = nextslot();
    events[slot].job = j;

    e = buildenv(j, slot);
    <<[[sched()]] print recipe command on stdout>>

    <<[[sched()]] if dry mode or touch mode>>
    else {
       <<[[sched()]] if DEBUG(D_EXEC) print recipe>>
        flags = (j->r->attr&NOMINUSE)? nil : "-e";
        // launching the job!
        events[slot].pid = execsh(flags, j->r->recipe, 0, e);
        usage();
        nrunning++;
       <<[[sched()]] if DEBUG(D_EXEC) print pid>>
    }
}
@
% -e is important!! want any error in the subshell command
% to abort the whole thing

<<[[Node_flag]] cases>>=
NOMINUSE   = 0x1000,
@


<<[[Rule_attr]] cases>>=
QUIET  = 0x0008,
@

<<[[sched()]] print recipe command on stdout>>=
buf = newbuf();
shprint(j->r->recipe, e, buf);
if(!tflag && (nflag || !(j->r->attr&QUIET)))
    Bwrite(&bout, buf->start, (long)strlen(buf->start));
freebuf(buf);
@



<<function nextslot>>=
int
nextslot(void)
{
    int i;

    for(i = 0; i < nproclimit; i++)
        if(events[i].pid <= 0) 
            return i;
    assert(/*out of slots!!*/ false);
    return 0;	/* cyntax */
}
@



\section{[[Process]]}

<<struct Process>>=
struct Process {
    int pid;
    int status;

    // Extra
    // double linked list, backward, forward
    Process *b, *f;
};
@
% again another example of redundant code ... should be factorized
% in a container library

<<global phead>>=
// double_list<ref_own<Process> (next = Process.f)
static Process *phead;
@

<<global pfree>>=
// double_list<ref_own<Process> (next = Process.f)
static Process *pfree;
@

% ctor
<<function pnew>>=
static void
pnew(int pid, int status)
{
    Process *p;

    if(pfree){
        p = pfree;
        pfree = p->f;
    } else
        p = (Process *)Malloc(sizeof(Process));

    p->pid = pid;
    p->status = status;

    p->f = phead;
    phead = p;
    if(p->f)
        p->f->b = p;
    p->b = nil;
}
@

% dtor
<<function pdelete>>=
static void
pdelete(Process *p)
{
    if(p->f)
        p->f->b = p->b;
    if(p->b)
        p->b->f = p->f;
    else
        phead = p->f;
    p->f = pfree;
    pfree = p;
}
@




\section{Waiting children}


% echildok -1, -2, -3?? just to help debug which one of the waitup?
% then use __LINE__ no?
<<function waitup>>=
int
waitup(int echildok, int *retstatus)
{
    Envy *e;
    int pid;
    int slot;
    Symtab *s;
    Word *w;
    Job *j;
    char buf[ERRMAX];
    Bufblock *bp;
    int uarg = 0;
    int done;
    Node *n;
    Process *p;

    /* first check against the proces slist */
    if(retstatus)
        for(p = phead; p; p = p->f)
            if(p->pid == *retstatus){
                *retstatus = p->status;
                pdelete(p);
                return -1;
            }
again:		/* rogue processes */
    pid = waitfor(buf);
    if(pid == -1){
        if(echildok > 0)
            return 1;
        else {
            fprint(STDERR, "mk: (waitup %d) ", echildok);
            perror("mk wait");
            Exit();
        }
    }
    <<[[waitup()]] if DEBUG(D_EXEC) print pid>>
    if(retstatus && pid == *retstatus){
        *retstatus = buf[0]? 1:0;
        return -1;
    }
    slot = pidslot(pid);
    if(slot < 0){
       <<[[waitup()]] if DEBUG(D_EXEC) and slot < 0>>
        pnew(pid, buf[0]? 1:0);
        goto again;
    }
    j = events[slot].job;
    usage();
    nrunning--;
    events[slot].pid = -1;
    if(buf[0]){
        e = buildenv(j, slot);
        bp = newbuf();
        shprint(j->r->recipe, e, bp);
        front(bp->start);
        fprint(STDERR, "mk: %s: exit status=%s", bp->start, buf);
        freebuf(bp);
        for(n = j->n, done = 0; n; n = n->next)
            if(n->flags&DELETE){
                if(done++ == 0)
                    fprint(STDERR, ", deleting");
                fprint(STDERR, " '%s'", n->name);
                delete(n->name);
            }
        fprint(STDERR, "\n");
        if(kflag){
            runerrs++;
            uarg = 1;
        } else {
            jobs = 0;
            Exit();
        }
    }
    for(w = j->t; w; w = w->next){
        if((s = symlook(w->s, S_NODE, 0)) == 0)
            continue;	/* not interested in this node */
        update(uarg, s->u.ptr);
    }
    if(nrunning < nproclimit)
        sched();
    return 0;
}
@

<<function delete>>=
void
delete(char *name)
{
    if(utfrune(name, '(') == 0) {		/* file */
        if(remove(name) < 0)
            perror(name);
    } else
        fprint(STDERR, "hoon off; mk can'tdelete archive members\n");
}
@

\section{Parallel processing, [[$NPROC]]}%$
% export NPROC=...

<<[[mk()]] initialisation>>=
nproc();	/* it can be updated dynamically */
@

<<function nproc>>=
void
nproc(void)
{
    Symtab *sym;
    Word *w;

    if(sym = symlook("NPROC", S_VAR, nil)) {
        w = sym->u.ptr;
        if (w && w->s && w->s[0])
            nproclimit = atoi(w->s);
    }
    if(nproclimit < 1)
        nproclimit = 1;
    <<[[nproc()]] if DEBUG(D_EXEC)>>
    if(nproclimit > nevents){
        if(nevents)
            events = (RunEvent *)Realloc((char *)events, nproclimit*sizeof(RunEvent));
        else
            events = (RunEvent *)Malloc(nproclimit*sizeof(RunEvent));

        while(nevents < nproclimit)
            events[nevents++].pid = 0;
    }
}
@


<<function pidslot>>=
int
pidslot(int pid)
{
    int i;

    for(i = 0; i < nevents; i++)
        if(events[i].pid == pid) 
            return i;
    <<[[pidslot()]] if DEBUG(D_EXEC)>>
    return -1;
}
@



\section{Signals/Notes managment}

% main -> <>
<<function catchnotes>>=
void
catchnotes()
{
    atnotify(notifyf, 1);
}
@

<<function notifyf>>=
int
notifyf(void *a, char *msg)
{
    static int nnote;

    USED(a);
    if(++nnote > 100){	/* until andrew fixes his program */
        fprint(STDERR, "mk: too many notes\n");
        notify(0);
        abort();
    }
    if(strcmp(msg, "interrupt")!=0 && strcmp(msg, "hangup")!=0)
        return 0;
    killchildren(msg);
    return -1;
}
@


<<function killchildren>>=
void
killchildren(char *msg)
{
    Process *p;

    kflag = true;	/* to make sure waitup doesn't exit */
    jobs = nil;		/* make sure no more get scheduled */
    for(p = phead; p; p = p->f)
        expunge(p->pid, msg);
    while(waitup(1, (int *)0) == 0)
        ;
    Bprint(&bout, "mk: %s\n", msg);
    Exit();
}
@







\chapter{Interacting with the Shell}
% the recipe

<<global shell>>=
char 	*shell =	"/bin/rc";
@

<<global shellname>>=
char 	*shellname =	"rc";
@




<<global shflags>>=
char	*shflags = "-I";	/* rc flag to force non-interactive mode */
@
% pad: should add also -e!! actually -e is added by default
%  unless you added :E: for NOMINUSE

<<global IWS>>=
int	IWS = '\1';		/* inter-word separator in env - not used in plan 9 */
@






\section{[[Envy]]}
%\section{Environment Variables, [[Envy]] and [[envy]]}
% could be in core DS, but used just here, and outside, S_VAR is good
% enough.

% mk simpler than make on this. no Make variables vs shell variables.
% (but then stronger coupling with the shell language? portable?)

% variables, different occurences: in rule target, prerequistes,
% or in recipe. Different handling depending on context.

% Not envy :) just environment variable stuff, rename?
<<struct Envy>>=
struct Envy
{
    // key
    char 		*name;
    // value, list<ref_own<string>>
    Word 		*values;
};
@
\l rename values to value?


<<global envy>>=
// growing_array<Envy>
Envy	*envy;
@
%ocaml: could use a hashtbl

<<constant ENVQUANTA>>=
#define ENVQUANTA 10
@

<<global nextv>>=
// idx for next free entry in envy array
static int nextv;
@

% envupd | ecopy | execinit -> <>
<<function envinsert>>=
static void
envinsert(char *name, Word *value)
{
    static int envsize;

    if (nextv >= envsize) {
        envsize += ENVQUANTA;
        envy = (Envy *) Realloc((char *) envy, envsize*sizeof(Envy));
    }
    envy[nextv].name = name;
    envy[nextv++].values = value;
}
@



\section{The environment}
% as opposed to make, no $(XX), no $$i, the string is passed
% as is to shell! less escaping need!


<<function envupd>>=
static void
envupd(char *name, Word *value)
{
    Envy *e;

    for(e = envy; e->name; e++)
        if(strcmp(name, e->name) == 0){
            delword(e->values);
            e->values = value;
            return;
        }
    e->name = name;
    e->values = value;
    envinsert(nil,nil); // ???
}
@

<<function ecopy>>=
static void
ecopy(Symtab *s)
{
    char **p;

    if(symlook(s->name, S_NOEXPORT, 0))
        return;
    for(p = myenv; *p; p++)
        if(strcmp(*p, s->name) == 0)
            return;
    envinsert(s->name, s->u.ptr);
}
@

% main -> execinit()
<<function execinit>>=
void
execinit(void)
{
    char **p;

    nextv = 0; // reset envy
    for(p = myenv; *p; p++)
        envinsert(*p, stow(""));

    symtraverse(S_VAR, ecopy);
    envinsert(nil, nil);
}
@



<<[[myenv]] other array elements>>=
"pid",
"nproc",
@


<<function buildenv>>=
Envy*
buildenv(Job *j, int slot)
{
    char **p, *cp, *qp;
    Word *w, *v, **l;
    int i;
    char buf[256];

    envupd("target", wdup(j->t));
    if(j->r->attr&REGEXP)
        envupd("stem", newword(""));
    else
        envupd("stem", newword(j->stem));
    envupd("prereq", wdup(j->p));

    snprint(buf, sizeof buf, "%d", getpid());
    envupd("pid", newword(buf));
    snprint(buf, sizeof buf, "%d", slot);
    envupd("nproc", newword(buf));

    <<[[buildenv()]] envupd some variables>>
    
    <<[[buildenv()]] newmember variable setting>>
    <<[[buildenv()]] stemx variables setting>>

    return envy;
}
@



<<[[Sxxx]] cases>>=
S_EXPORTED,	/* var -> current exported value */
@

% plan9 specific, in plan9.c
<<function readenv>>=
void
readenv(void)
{
    char *p;
    int envf, f;
    Dir *e;
    char nam[1024];
    int i, n, len;
    Word *w;

    rfork(RFENVG);	/*  use copy of the current environment variables */

    envf = open("/env", OREAD);
    if(envf < 0)
        return;
    while((n = dirread(envf, &e)) > 0){
        for(i = 0; i < n; i++){
            len = e[i].length;
                /* don't import funny names, NULL values,
                 * or internal mk variables
                 */
            if(len <= 0 || *shname(e[i].name) != '\0')
                continue;
            if (symlook(e[i].name, S_INTERNAL, 0))
                continue;
            snprint(nam, sizeof nam, "/env/%s", e[i].name);
            f = open(nam, OREAD);
            if(f < 0)
                continue;
            p = Malloc(len+1);
            if(read(f, p, len) != len){
                perror(nam);
                close(f);
                continue;
            }
            close(f);
            if (p[len-1] == 0)
                len--;
            else
                p[len] = 0;
            w = encodenulls(p, len);
            free(p);
            p = strdup(e[i].name);
            setvar(p, (void *) w);
            symlook(p, S_EXPORTED, (void*)"")->u.ptr = "";
        }
        free(e);
    }
    close(envf);
}
@


\section{Variables expansion (part 3)}

% not done actually! shell does it! 
% simpler! no $$i mess.

\section{Quotation}
% aka escaping


<<function squote>>=
/*
 *	skip a token in single quotes.
 */
static char *
squote(char *cp)
{
    Rune r;
    int n;

    while(*cp){
        n = chartorune(&r, cp);
        if(r == '\'') {
            n += chartorune(&r, cp+n);
            if(r != '\'')
                return cp;
        }
        cp += n;
    }
    SYNERR(-1);		/* should never occur */
    fprint(STDERR, "missing closing '\n");
    return 0;
}
@

<<function charin>>=
/*
 *	search a string for characters in a pattern set
 *	characters in quotes and variable generators are escaped
 */
char*
charin(char *cp, char *pat)
{
    Rune r;
    int n, vargen;

    vargen = 0;
    while(*cp){
        n = chartorune(&r, cp);
        switch(r){
        case '\'':			/* skip quoted string */
            cp = squote(cp+1);	/* n must = 1 */
            if(!cp)
                return 0;
            break;
        case '$':
            if(*(cp+1) == '{')
                vargen = 1;
            break;
        case '}':
            if(vargen)
                vargen = 0;
            else if(utfrune(pat, r))
                return cp;
            break;
        default:
            if(vargen == 0 && utfrune(pat, r))
                return cp;
            break;
        }
        cp += n;
    }
    if(vargen){
        SYNERR(-1);
        fprint(STDERR, "missing closing } in pattern generator\n");
    }
    return 0;
}
@
%$ 

<<function expandquote>>=
/*
 *	extract an escaped token.  Possible escape chars are single-quote,
 *	double-quote,and backslash.  Only the first is valid for rc. the
 *	others are just inserted into the receiving buffer.
 */
char*
expandquote(char *s, Rune r, Bufblock *b)
{
    if (r != '\'') {
        rinsert(b, r);
        return s;
    }

    while(*s){
        s += chartorune(&r, s);
        if(r == '\'') {
            if(*s == '\'')
                s++;
            else
                return s;
        }
        rinsert(b, r);
    }
    return 0;
}
@


<<function copysingle>>=
/*
 *	copy a single-quoted string; s points to char after opening quote
 */
static char *
copysingle(char *s, Bufblock *buf)
{
    Rune r;

    while(*s){
        s += chartorune(&r, s);
        rinsert(buf, r);
        if(r == '\'')
            break;
    }
    return s;
}
@

<<function copyq>>=
/*
 *	check for quoted strings.  backquotes are handled here; single quotes above.
 *	s points to char after opening quote, q.
 */
char *
copyq(char *s, Rune q, Bufblock *buf)
{
    if(q == '\'')				/* copy quoted string */
        return copysingle(s, buf);

    if(q != '`')				/* not quoted */
        return s;

    while(*s){				/* copy backquoted string */
        s += chartorune(&q, s);
        rinsert(buf, q);
        if(q == '}')
            break;
        if(q == '\'')
            s = copysingle(s, buf);	/* copy quoted string */
    }
    return s;
}
@


\chapter{Debugging and Profiling Support}

\section{Explain mode, [[mk -e]]}

<<global explain>>=
bool explain = false;
@
% used to a char*
<<[[main()]] -xxx switch cases>>=
case 'e':
    explain = true;
    break;
@

\section{Dry mode, [[mk -n]]}

% just print recipe, do not execute them
<<global nflag>>=
bool nflag = false;
@
<<[[main()]] -xxx switch cases>>=
case 'n':
    nflag = true;
    break;
@

<<[[sched()]] if dry mode or touch mode>>=
if(nflag||tflag){
    for(n = j->n; n; n = n->next){
        <<[[sched()]] if touch mode>>
        n->time = time((long *)nil);
        MADESET(n, MADE);
    }
}
@

\section{What if, [[mk -w]]{\em file}}

% what if I change a file, what needs to be done?
% usually works with -n, mk -n -wprog.h

<<[[main()]] locals>>=
Bufblock *whatif = nil;
@

<<[[main()]] -xxx switch cases>>=
case 'w':
    if(whatif == nil)
        whatif = newbuf();
    else
        insert(whatif, ' ');
    if(argv[0][2])
        bufcpy(whatif, &argv[0][2], strlen(&argv[0][2]));
    else {
        if(*++argv == 0)
            badusage();
        bufcpy(whatif, &argv[0][0], strlen(&argv[0][0]));
    }
    break;
@

<<[[main()]] whatif optional setup>>=
if(whatif){
    insert(whatif, '\0');
    timeinit(whatif->start);
    freebuf(whatif);
}
@

% fake time of file to be just modified now by modifying the time cache
<<function timeinit>>=
void
timeinit(char *s)
{
    ulong t;
    char *cp;
    Rune r;
    int c, n;

    t = time(0);
    while (*s) {
        cp = s;
        do{
            n = chartorune(&r, s);
            if (r == ' ' || r == ',' || r == '\n')
                break;
            s += n;
        } while(*s);
        c = *s;
        *s = '\0';

        symlook(strdup(cp), S_TIME, (void *)t)->u.value = t;

        if (c)
            *s++ = c;
        while(*s){
            n = chartorune(&r, s);
            if(r != ' ' && r != ',' && r != '\n')
                break;
            s += n;
        }
    }
}
@

%related: buck query, but operates on hundreds of .buck files so can
% answer complex queries?

%\chapter{Profiling Support}

\section{Utilization, [[mk -u]]}

% display time spent in different nrunnning configuration

<<global uflag>>=
bool uflag = false;
@
<<[[main()]] -xxx switch cases>>=
case 'u':
    uflag = true;
    break;
@


<<global tslot>>=
static ulong tslot[1000];
@

% could be made local static!
<<global tick>>=
static ulong tick;
@

% called from many places
<<function usage>>=
void
usage(void)
{
    ulong t;

    t = time(0);
    if(tick)
        tslot[nrunning] += t - tick;
    tick = t;
}
@

<<[[main()]] print profiling stats if uflag>>=
if(uflag)
    prusage();
@

<<function prusage>>=
void
prusage(void)
{
    int i;

    usage();
    for(i = 0; i <= nevents; i++)
        fprint(1, "%d: %lud\n", i, tslot[i]);
}
@




\chapter{Advanced Features}

% all those features are meh in my opinion

\section{Regular-expression rules, [[:R:]]}

% use libregexp/, regcomp(), regexec(), regsub()

<<[[Rule_attr]] cases>>=
REGEXP = 0x0020,
@

<<[[Rule]] other fields>>=
Reprog		*pat;		/* reg exp goo */
@


% this is for error managment, regcomp can probably trigger
% the regerror callback! subtle!
<<global patrule>>=
Rule *patrule;
@

<<[[addrule()]] if REGEXP attribute>>=
if(attr&REGEXP){
    patrule = r;
    r->pat = regcomp(head);
}
@

<<function regerror>>=
//@Scheck: not dead, called via regcomp() when have regexp syntax error
void regerror(char *s)
{
    if(patrule)
        fprint(STDERR, "mk: %s:%d: regular expression error; %s\n",
            patrule->file, patrule->line, s);
    else
        fprint(STDERR, "mk: %s:%d: regular expression error; %s\n",
            infile, mkinline, s);
    Exit();
}
@


<<constant NREGEXP>>=
#define		NREGEXP		10
@


% instead of stem
<<[[Arc]] other fields>>=
char		*match[NREGEXP];
@

% instead of stem
<<[[Job]] other fields>>=
char		**match;
@

<<[[myenv]] other array elements>>=
"stem0",		/* must be in order from here */
"stem1",
"stem2",
"stem3",
"stem4",
"stem5",
"stem6",
"stem7",
"stem8",
"stem9",
@

<<[[buildenv()]] stemx variables setting>>=
/* update stem0 -> stem9 */
for(p = myenv; *p; p++)
    if(strcmp(*p, "stem0") == 0)
        break;
for(i = 0; *p; i++, p++){
    if((j->r->attr&REGEXP) && j->match[i])
        envupd(*p, newword(j->match[i]));
    else 
        envupd(*p, newword(""));
}
@

<<[[applyrules]] other locals>>=
Resub rmatch[NREGEXP];
@
<<[[applyrules]] set rmatch>>=
memset((char*)rmatch, 0, sizeof(rmatch));
@
% rmatch??? for metarules? for newarc?

<<[[applyrules()]] if regexp rule then continue if some conditions>>=
if(r->attr&REGEXP){
    stem[0] = '\0';
    memset((char*)rmatch, 0, sizeof(rmatch));
    patrule = r;
    if(regexec(r->pat, node->name, rmatch, NREGEXP) == 0)
        continue;
}
@

<<[[applyrules()]] if regexp rule, adjust buf and rmatch>>=
if(r->attr&REGEXP)
    regsub(w->s, buf, sizeof(buf), rmatch, NREGEXP);
@

\section{Multiple targets}

%less: hmm useful for parser.ml parser.mli: parser.mly ?

% a few places where use Word* targets
% where in most cases it should really be simply char* target;

<<[[Rule]] other fields>>=
// list<ref_own?<string>>?
Word 		*alltargets;	/* all the targets */
@
% as in  gram.c gram.h: gram.y ...
% (hmm but could be rewritten with 2 rules, it's just
% that with mk the file would be possibly rebuilt two times!
% because it could run the command in parallel!!!!

<<[[Job]] other fields>>=
Word		*at;	/* all targets */
@

<<[[myenv]] other array elements>>=
"alltarget",
@

<<[[buildenv()]] envupd some variables>>=
envupd("alltarget", wdup(j->at));
@


\section{Dynamic [[mkfile]], [[<|]]{\em prog}}

<<[[rhead()]] adjust sep if dynamic mkfile [[<|]]>>=
if(sep == '<' && *p == '|'){
    sep = '|';
    p++;
}
@

% mkfile content through pipe
% |cmd  instead of <file

<<[[parse()]] other locals>>=
int pid;
@

<<[[parse()]] switch rhead cases>>=
case '|':
    p = wtos(tail, ' ');
    if(*p == '\0'){
        SYNERR(-1);
        fprint(STDERR, "missing include program name\n");
        Exit();
    }
    execinit();
    pid = pipecmd(p, envy, &newfd);
    if(newfd < 0){
        fprint(STDERR, "warning: skipping missing program file: ");
        perror(p);
    } else
        parse(p, newfd, 0);
    while(waitup(-3, &pid) >= 0)
        ;
    if(pid != 0){
        fprint(STDERR, "bad include program status\n");
        Exit();
    }
    break;
@



\section{Complex variables, [[${]]{\em \ldots}[[}]]}
%$


<<[[varsub()]] if variable starts with open brace>>=
if(**s == '{')		/* either ${name} or ${name: A%B==C%D}*/
    return expandvar(s);
@

<<function expandvar>>=
static Word*
expandvar(char **s)
{
    Word *w;
    Bufblock *buf;
    Symtab *sym;
    char *cp, *begin, *end;

    begin = *s;
    (*s)++;						/* skip the '{' */
    buf = varname(s);
    if (buf == nil)
        return nil;
    cp = *s;
    if (*cp == '}') {				/* ${name} variant*/ //$
        (*s)++;					/* skip the '}' */
        w = varmatch(buf->start);
        freebuf(buf);
        return w;
    }
    if (*cp != ':') {
        SYNERR(-1);
        fprint(STDERR, "bad variable name <%s>\n", buf->start);
        freebuf(buf);
        return nil;
    }
    cp++;
    end = charin(cp , "}");
    if(end == nil){
        SYNERR(-1);
        fprint(STDERR, "missing '}': %s\n", begin);
        Exit();
    }
    *end = '\0';
    *s = end+1;
    
    sym = symlook(buf->start, S_VAR, 0);
    if(sym == nil || sym->u.value == 0)
        w = newword(buf->start);
    else
        w = subsub(sym->u.ptr, cp, end);
    freebuf(buf);
    return w;
}
@
%$


<<function subsub>>=
static Word*
subsub(Word *v, char *s, char *end)
{
    int nmid;
    Word *head, *tail, *w, *h;
    Word *a, *b, *c, *d;
    Bufblock *buf;
    char *cp, *enda;

    a = extractpat(s, &cp, "=%&", end);
    b = c = d = nil;
    if(PERCENT(*cp))
        b = extractpat(cp+1, &cp, "=", end);
    if(*cp == '=')
        c = extractpat(cp+1, &cp, "&%", end);
    if(PERCENT(*cp))
        d = stow(cp+1);
    else if(*cp)
        d = stow(cp);

    head = tail = nil;
    buf = newbuf();
    for(; v; v = v->next){
        h = w = 0;
        if(submatch(v->s, a, b, &nmid, &enda)){
            /* enda points to end of A match in source;
             * nmid = number of chars between end of A and start of B
             */
            if(c){
                h = w = wdup(c);
                while(w->next)
                    w = w->next;
            }
            if(PERCENT(*cp) && nmid > 0){	
                if(w){
                    bufcpy(buf, w->s, strlen(w->s));
                    bufcpy(buf, enda, nmid);
                    insert(buf, '\0');
                    free(w->s);
                    w->s = strdup(buf->start);
                } else {
                    bufcpy(buf, enda, nmid);
                    insert(buf, '\0');
                    h = w = newword(buf->start);
                }
                buf->current = buf->start;
            }
            if(d && *d->s){
                if(w){

                    bufcpy(buf, w->s, strlen(w->s));
                    bufcpy(buf, d->s, strlen(d->s));
                    insert(buf, '\0');
                    free(w->s);
                    w->s = strdup(buf->start);
                    w->next = wdup(d->next);
                    while(w->next)
                        w = w->next;
                    buf->current = buf->start;
                } else
                    h = w = wdup(d);
            }
        }
        if(w == 0)
            h = w = newword(v->s);
    
        if(head == 0)
            head = h;
        else
            tail->next = h;
        tail = w;
    }
    freebuf(buf);
    delword(a);
    delword(b);
    delword(c);
    delword(d);
    return head;
}
@

% subsub -> <>
<<function extractpat>>=
static Word*
extractpat(char *s, char **r, char *term, char *end)
{
    int save;
    char *cp;
    Word *w;

    cp = charin(s, term);
    if(cp){
        *r = cp;
        if(cp == s)
            return nil;
        save = *cp;
        *cp = '\0';
        w = stow(s);
        *cp = save;
    } else {
        *r = end;
        w = stow(s);
    }
    return w;
}
@

% subsub -> <>
<<function submatch>>=
static bool
submatch(char *s, Word *a, Word *b, int *nmid, char **enda)
{
    Word *w;
    int n;
    char *end;

    n = 0;
    for(w = a; w; w = w->next){
        n = strlen(w->s);
        if(strncmp(s, w->s, n) == 0)
            break;
    }
    if(a && w == nil)		/*  a == NULL matches everything*/
        return false;

    *enda = s+n;		/* pointer to end a A part match */
    *nmid = strlen(s)-n;	/* size of remainder of source */
    end = *enda+*nmid;
    for(w = b; w; w = w->next){
        n = strlen(w->s);
        if(strcmp(w->s, end-n) == 0){
            *nmid -= n;
            break;
        }
    }
    if(b && w == nil)		/* b == NULL matches everything */
        return false;
    return true;
}
@


\section{Shell-command expansion, [[`]]{\em cmd}[[`]]}

<<[[assline()]] switch character cases>>=
case '`':
    if (bquote(bp, buf) == 0)
        Exit();
    break;
@

<<function bquote>>=
/*
 *	assemble a back-quoted shell command into a buffer
 */
static int
bquote(Biobuf *bp, Bufblock *buf)
{
    int c, line, term;
    int start;

    line = mkinline;
    while((c = Bgetrune(bp)) == ' ' || c == '\t')
            ;
    if(c == '{'){
        term = '}';		/* rc style */
        while((c = Bgetrune(bp)) == ' ' || c == '\t')
            ;
    } else
        term = '`';		/* sh style */

    start = buf->current-buf->start;
    for(;c > 0; c = nextrune(bp, 0)){
        if(c == term){
            insert(buf, '\n');
            insert(buf, '\0');
            buf->current = buf->start+start;
            execinit();
            execsh(0, buf->current, buf, envy);
            return 1;
        }
        if(c == '\n')
            break;
        if(c == '\'' || c == '"' || c == '\\'){
            insert(buf, c);
            if(!escapetoken(bp, buf, 1, c))
                return 0;
            continue;
        }
        rinsert(buf, c);
    }
    SYNERR(line);
    fprint(STDERR, "missing closing %c after `\n", term);
    return 0;
}
@


\section{Aggregates, archives}
% meh

<<[[Job]] other fields>>=
Word		*np;	/* new prerequistes */
@

<<[[myenv]] other array elements>>=
"newprereq",
@
% so does not put *.5 but only the .5 that were more recent than
% the archive.

<<[[buildenv()]] envupd some variables>>=
envupd("newprereq", wdup(j->np));
@






<<[[myenv]] other array elements>>=
"newmember",
@

<<[[buildenv()]] newmember variable setting>>=
l = &v;
v = w = wdup(j->np);
while(w){
    cp = strchr(w->s, '(');
    if(cp){
        qp = strchr(cp+1, ')');
        if(qp){
            *qp = 0;
            strcpy(w->s, cp+1);
            l = &w->next;
            w = w->next;
            continue;
        }
    }
    *l = w->next;
    free(w->s);
    free(w);
    w = *l;
}
envupd("newmember", v);
@


<<[[Sxxx]] cases>>=
S_AGG,		/* aggregate -> time */
@


<<[[timeof()]] if name archive member>>=
if(utfrune(name, '('))
    return atimeof(force, name);		/* archive */
@

<<function atimeof>>=
ulong
atimeof(int force, char *name)
{
    Symtab *sym;
    ulong t;
    char *archive, *member, buf[512];

    archive = split(name, &member);
    if(archive == 0)
        Exit();

    t = mkmtime(archive, true);
    sym = symlook(archive, S_AGG, 0);
    if(sym){
        if(force || t > sym->u.value){
            atimes(archive);
            sym->u.value = t;
        }
    }
    else{
        atimes(archive);
        /* mark the aggegate as having been done */
        symlook(strdup(archive), S_AGG, "")->u.value = t;
    }
        /* truncate long member name to sizeof of name field in archive header */
    snprint(buf, sizeof(buf), "%s(%.*s)", archive, utfnlen(member, SARNAME), member);
    sym = symlook(buf, S_TIME, 0);
    if (sym)
        return sym->u.value;
    return 0;
}
@

<<function atouch>>=
void
atouch(char *name)
{
    char *archive, *member;
    int fd, i;
    struct ar_hdr h;
    long t;

    archive = split(name, &member);
    if(archive == 0)
        Exit();

    fd = open(archive, ORDWR);
    if(fd < 0){
        fd = create(archive, OWRITE, 0666);
        if(fd < 0){
            perror(archive);
            Exit();
        }
        write(fd, ARMAG, SARMAG);
    }
    if(symlook(name, S_TIME, 0)){
        /* hoon off and change it in situ */
        seek(fd, SARMAG, 0);
        while(read(fd, (char *)&h, sizeof(h)) == sizeof(h)){
            for(i = SARNAME-1; i > 0 && h.name[i] == ' '; i--)
                    ;
            h.name[i+1]=0;
            if(strcmp(member, h.name) == 0){
                t = SARNAME-sizeof(h);	/* ughgghh */
                seek(fd, t, 1);
                fprint(fd, "%-12ld", time(0));
                break;
            }
            t = atol(h.size);
            if(t&01) t++;
            seek(fd, t, 1);
        }
    }
    close(fd);
}
@

<<function atimes>>=
static void
atimes(char *ar)
{
    struct ar_hdr h;
    ulong at, t;
    int fd, i;
    char buf[BIGBLOCK];
    Dir *d;
    
    fd = open(ar, OREAD);
    if(fd < 0)
        return;

    if(read(fd, buf, SARMAG) != SARMAG){
        close(fd);
        return;
    }
    if((d = dirfstat(fd)) == nil){
        close(fd);
        return;
    }
    at = d->mtime;
    free(d);
    while(read(fd, (char *)&h, SAR_HDR) == SAR_HDR){
        t = strtoul(h.date, nil, 0);
        if(t >= at)	/* new things in old archives confuses mk */
            t = at-1;
        if(t == 0)	/* as it sometimes happens; thanks ken */
            t = 1;
        for(i = sizeof(h.name)-1; i > 0 && h.name[i] == ' '; i--)
            ;
        if(h.name[i] == '/')		/* system V bug */
            i--;
        h.name[i+1]=0;		/* can stomp on date field */
        snprint(buf, sizeof buf, "%s(%s)", ar, h.name);
        symlook(strdup(buf), S_TIME, (void*)t)->u.value = t;
        t = atol(h.size);
        if(t&01) t++;
        seek(fd, t, 1);
    }
    close(fd);
}
@

<<[[Sxxx]] cases>>=
S_BITCH,	/* bitched about aggregate not there */
@

<<function type>>=
static int
type(char *file)
{
    int fd;
    char buf[SARMAG];

    fd = open(file, OREAD);
    if(fd < 0){
        if(symlook(file, S_BITCH, 0) == 0){
            Bprint(&bout, "%s doesn't exist: assuming it will be an archive\n", file);
            symlook(file, S_BITCH, (void *)file);
        }
        return 1;
    }
    if(read(fd, buf, SARMAG) != SARMAG){
        close(fd);
        return 0;
    }
    close(fd);
    return strncmp(ARMAG, buf, SARMAG) == 0;
}
@

<<function split>>=
static char*
split(char *name, char **member)
{
    char *p, *q;

    p = strdup(name);
    q = utfrune(p, '(');
    if(q){
        *q++ = 0;
        if(member)
            *member = q;
        q = utfrune(q, ')');
        if (q)
            *q = 0;
        if(type(p))
            return p;
        free(p);
        fprint(STDERR, "mk: '%s' is not an archive\n", name);
    }
    return 0;
}
@



<<[[outofdate()]] of arc node is an archive member>>=
if(strchr(arc->n->name, '(') && arc->n->time == 0)
   /* missing archive member */
   return true;
@

\section{Optimizations}

\subsection{Node cache}
\t mv in optim chapter?
% useful in practice? when reuse a target node? when same file
% mentioned again and again, like .o or .a used in different targets

<<[[applyrules]] check node cache if target is already there>>=
sym = symlook(target, S_NODE, nil);
if(sym)
    return sym->u.ptr;
@

<<[[Sxxx]] cases>>=
S_NODE,		/* target name -> node */
@

<<[[newnode()]] update node cache>>=
symlook(name, S_NODE, (void *)node);
@


\subsection{Missing-intermediates optimization, [[mk -I]]}
% mk -i suppress this behavior
% pad: mk -I! new mode :) because I don't like the default mode!

% it is there to optimize disk space, to allow to remove .o
% the intermediate betweem the .out and the .c by pretending
% they are there if we know no .c files has actually changed.
% useful at a time where disk space was expensive, and so having
% both the .o and the .a were seen as redundant waste.

% from man page:
%Nonexistent targets that have prerequisites
%and are themselves prerequisites are treated specially.

<<global iflag>>=
bool iflag = false;
@
<<[[main()]] -xxx switch cases>>=
case 'i':
    iflag = true;
    break;
@


<<[[Node_flag]] cases>>=
CANPRETEND = 0x0008,
PRETENDING = 0x0010,
@


<<[[clrmade()]] n->flags pretend adjustments>>=
n->flags &= ~(CANPRETEND|PRETENDING);
if(strchr(n->name, '(') ==0 || n->time)
    n->flags |= CANPRETEND;
@

<<[[work()]] possibly unpretending node>>=
if((node->flags&MADE) && (node->flags&PRETENDING) && p
    && outofdate(p, parc, false)){
    if(explain)
        fprint(1, "unpretending %s(%lud) because %s is out of date(%lud)\n",
            node->name, node->time, p->name, p->time);
    unpretend(node);
}
/*
 *   have a look if we are pretending in case
 *   someone has been unpretended out from underneath us
 */
if(node->flags&MADE){
    if(node->flags&PRETENDING){
        node->time = 0;
    }else
        return did;
}
@

<<function unpretend>>=
static void
unpretend(Node *n)
{
    MADESET(n, NOTMADE);
    n->flags &= ~(CANPRETEND|PRETENDING);
    n->time = 0;
}
@

<<[[work()]] possibly pretending node>>=
/*
 *   can we pretend to be made?
 */
if((!iflag) && (node->time == 0) 
        && (node->flags&(PRETENDING|CANPRETEND))
        && p && ra->n && !outofdate(p, ra, false)){
    node->flags &= ~CANPRETEND;
    MADESET(node, MADE);
    if(explain && ((node->flags&PRETENDING) == 0))
        fprint(1, "pretending %s has time %lud\n", node->name, node->time);
    node->flags |= PRETENDING;
    return did;
}
/*
 *   node is out of date and we REALLY do have to do something.
 *   quickly rescan for pretenders
 */
for(a = node->prereqs; a; a = a->next)
    if(a->n && (a->n->flags&PRETENDING)){
        if(explain)
            Bprint(&bout, "unpretending %s because of %s because of %s\n",
            a->n->name, node->name, 
            ra->n? ra->n->name : "rule with no prerequisites");

        unpretend(a->n);
        did = work(a->n, node, a) || did;
        ready = false;
    }
if(!ready)/* try later unless nothing has happened for -k's sake */
    return did || work(node, p, parc);
@

<<[[update()]] unpretend node>>=
node->flags &= ~(CANPRETEND|PRETENDING);
@

\subsection{Touching-mode optimization, [[mk -t]]}

% when the user knows what he is doing

<<global tflag>>=
bool tflag = false;
@
<<[[main()]] -xxx switch cases>>=
case 't':
    tflag = true;
    break;
@

<<[[sched()]] if touch mode>>=
if(tflag){
    if(!(n->flags&VIRTUAL))
        touch(n->name);
    else if(explain)
        Bprint(&bout, "no touch of virtual '%s'\n", n->name);
}
@

<<function touch>>=
void
touch(char *name)
{
    Bprint(&bout, "touch(%s)\n", name);
    if(nflag)
        return;

    if(utfrune(name, '('))
        atouch(name);		/* archive */
    else
     if(chgtime(name) < 0) {
        perror(name);
        Exit();
    }
}
@

<<function chgtime>>=
int
chgtime(char *name)
{
    Dir sbuf;

    if(access(name, AEXIST) >= 0) {
        nulldir(&sbuf);
        sbuf.mtime = time((long *)nil);
        return dirwstat(name, &sbuf);
    }
    return close(create(name, OWRITE, 0666));
}
@

\subsection{Bulk time optimisation}

<<[[mkmtime]] locals>>=
//char *s, *ss;
//char carry;
//Symtab *sym;
@

<<[[mkmtime()]] bulk dir optimisation>>=
USED(force);
//TODO    s = utfrrune(name, '/');
//TODO    if(s == name)
//TODO        s++;
//TODO    if(s){
//TODO        ss = name;
//TODO        carry = *s;
//TODO        *s = '\0';
//TODO    }else{
//TODO        ss = nil;
//TODO        carry = 0;
//TODO    }
//TODO    if(carry)
//TODO        *s = carry;
//TODO
//TODO bulkmtime(ss);
//TODO if(!force){
//TODO     sym = symlook(name, S_TIME, 0);
//TODO     if(sym)
//TODO         return sym->u.value;
//TODO     return 0;
//TODO }
@
% subtle: this opti has subtle implications with weird filesystem like VFAT!!
% With this optimisation mk will not be able to run correctly
% in simple projects like tests/8c/! It's because the directory
% contains HELLOC.C not helloc.c and so even if dirstat("helloc.c")
% will work, once you read the directory you will create an
% entry for HELLOC.C in S_TIME but not for helloc.c and then when asking
% for helloc.c you will look in the cache and see nothing and so
% return 0.

<<[[Sxxx]] cases>>=
S_BULKED,	/* we have bulked this dir */
@

<<function bulkmtime>>=
void
bulkmtime(char *dir)
{
    char buf[4096];
    char *ss, *s, *sym;

    if(dir){
        sym = dir;
        s = dir;
        if(strcmp(dir, "/") == 0)
            strecpy(buf, buf + sizeof buf - 1, dir);
        else
            snprint(buf, sizeof buf, "%s/", dir);
    }else{
        s = ".";
        sym = "";
        buf[0] = 0;
    }
    if(symlook(sym, S_BULKED, 0))
        return;
    ss = strdup(sym);
    symlook(ss, S_BULKED, (void*)ss);
    dirtime(s, buf);
}
@

<<function dirtime>>=
void
dirtime(char *dir, char *path)
{
    int i, fd, n;
    ulong mtime;
    Dir *d;
    char buf[4096];

    fd = open(dir, OREAD);
    if(fd >= 0){
        while((n = dirread(fd, &d)) > 0){
            for(i=0; i<n; i++){
                mtime = d[i].mtime;
                /* defensive driving: this does happen */
                if(mtime == 0)
                    mtime = 1;
                snprint(buf, sizeof buf, "%s%s", path,
                    d[i].name);
                if(symlook(buf, S_TIME, 0) == nil)
                    symlook(strdup(buf), S_TIME,
                        (void*)mtime)->u.value = mtime;
            }
            free(d);
        }
        close(fd);
    }
}
@


\section{Recompiling everything, [[mk -a]]}
% bad place

<<global aflag>>=
bool aflag = false;
@
<<[[main()]] -xxx switch cases>>=
case 'a':
    aflag = true;
    iflag = true;
    break;
@
% iflag = true; used to be after the switch, but same
% when -a, means we want to build also the intermediate files when
% they are not there

\section{Recursive [[mk]]}

% if one of the mk return error code, then should stop mk right?
% convenient then.
% TODO: this is not the case right now!!

%\section{Setting [[MKFLAGS]], [[MKARGS]]}
% used by? at least mkfile called recursively can expect those variables

<<[[main()]] set variables for recursive mk>>=
<<[[main()]] set MKFLAGS variable>>
<<[[main()]] set MKARGS variable>>
@

<<[[main()]] set MKFLAGS variable>>=
if (buf->current != buf->start) {
    buf->current--;
    insert(buf, '\0');
}
symlook("MKFLAGS", S_VAR, (void*) stow(buf->start));
@

<<[[main()]] set MKARGS variable>>=
buf->current = buf->start;
for(i = 0; argv[i]; i++){
    if(*argv[i] == '\0') 
        continue;
    if(i)
        insert(buf, ' ');
    bufcpy(buf, argv[i], strlen(argv[i]));
}
insert(buf, '\0');
symlook("MKARGS", S_VAR, (void *) stow(buf->start));

freebuf(buf);
@

\section{[[:P:]] ??}


%XXX??
<<[[Rule]] other fields>>=
char		*prog;		/* to use in out of date */
@
% prog??

%XXX?
<<[[Arc]] other fields>>=
char		*prog;
@


<<[[Sxxx]] cases>>=
S_OUTOFDATE,	/* n1\377n2 -> 2(outofdate) or 1(not outofdate) */
@
% abuse string ...


<<[[outofdate()]] locals>>=
char buf[3*NAMEBLOCK];
char *str = nil;
Symtab *sym;
int ret;
@

<<[[outofdate()]] if arc->prog>>=
if(arc->prog){
    snprint(buf, sizeof buf, "%s%c%s", node->name, 0377,
        arc->n->name);
    sym = symlook(buf, S_OUTOFDATE, 0);
    if(sym == nil || eval){
        if(sym == nil)
            str = strdup(buf);
        ret = pcmp(arc->prog, node->name, arc->n->name);
        if(sym)
            sym->u.value = ret;
        else
            symlook(str, S_OUTOFDATE, (void *)ret);
    } else
        ret = sym->u.value;
    return (ret-1);
}
@

<<function pcmp>>=
static int
pcmp(char *prog, char *p, char *q)
{
    char buf[3*NAMEBLOCK];
    int pid;

    Bflush(&bout);
    snprint(buf, sizeof buf, "%s '%s' '%s'\n", prog, p, q);
    pid = pipecmd(buf, 0, 0);
    while(waitup(-3, &pid) >= 0)
        ;
    return (pid? 2:1);
}
@



\chapter{Conclusion}

% could be nice to have a mk -d session at the end
% where see how all make sense, the flag values of nodes with 0x4
% because all are READY, etc.




\appendix

\chapter{Debugging}

%todo? http://bashdb.sourceforge.net/remake/
% apparently make with more debugging capabilities

%\section{Dumping internals, [[mk -d]]}

%mk -d[epg] EXEC PARSE GRAPH

<<enum Dxxx>>=
enum Dxxx {
    // for rules
    D_PARSE =		0x01,
    // for node and arcs
    D_GRAPH =		0x02,
    // for jobs
    D_EXEC  =		0x04,

    // tracing some calls
    D_TRACE  =		0x08,
};
@
%old: used to be a set of #define
%pad: I added D_TRACE

% -d flag
<<global debug>>=
// bitset<enum<dxxx>>
int debug;
@

<<function DEBUG>>=
#define	DEBUG(x)	(debug&(x))
@


<<[[main()]] -xxx switch cases>>=
case 'd':
    if(*(s = &argv[0][2]))
        while(*s) 
         switch(*s++) {
         case 'p':	debug |= D_PARSE; break;
         case 'g':	debug |= D_GRAPH; break;
         case 'e':	debug |= D_EXEC; break;
        }
    else
        debug = 0xFFFF; // D_PARSE | D_GRAPH | D_EXEC
    break;
@
\t D_TRACE?


\section{The rules, [[mk -dp]]}
% p for parsing

<<[[main()]] if DEBUG(D_PARSE)>>=
if(DEBUG(D_PARSE)){
    dumpw("default targets", target1);
    dumpr("rules", rules);
    dumpr("metarules", metarules);
    dumpv("variables");
}
@


<<dumper dumpw>>=
void
dumpw(char *s, Word *w)
{
    Bprint(&bout, "%s", s);
    for(; w; w = w->next)
        Bprint(&bout, " '%s'", w->s);
    Bputc(&bout, '\n');
}
@

% todo: remove the pointer thing %p, not that useful I think
% note that the variable expansion has been done for the target and prerequestes
<<dumper dumpr>>=
void
dumpr(char *s, Rule *r)
{
    Bprint(&bout, "%s: start=%p\n", s, r);
    for(; r; r = r->next){
        Bprint(&bout, "\tRule %p: %s:%d attr=%x next=%p chain=%p alltarget='%s'",
            r, r->file, r->line, r->attr, r->next, r->chain, wtos(r->alltargets, ' '));
        if(r->prog)
            Bprint(&bout, " prog='%s'", r->prog);
        Bprint(&bout, "\n\ttarget=%s: %s\n", r->target, wtos(r->tail,' '));
        Bprint(&bout, "\trecipe@%p='%s'\n", r->recipe, r->recipe);
    }
}
@

<<dumper dumpv>>=
void
dumpv(char *s)
{
    Bprint(&bout, "%s:\n", s);
    symtraverse(S_VAR, print1);
}
@

<<function print1>>=
static void
print1(Symtab *s)
{
    Word *w;

    Bprint(&bout, "\t%s=", s->name);
    for (w = s->u.ptr; w; w = w->next)
        Bprint(&bout, "'%s'", w->s);
    Bprint(&bout, "\n");
}
@





\section{The graph, [[mk -dg]]}

% node = graph(target) from mk(target)
<<[[main()]] if DEBUG(D_GRAPH)>>=
if(DEBUG(D_GRAPH)){
    dumpn("new target\n", root);
    Bflush(&bout);
}
@
% below the buf is here to compute indentation, depth of the graph in spaces

<<dumper dumpn>>=
void
dumpn(char *s, Node *n)
{
    char buf[1024];
    Arc *a;

    Bprint(&bout, "%s%s@%p: time=%ld flags=0x%x next=%p\n",
        s, n->name, n, n->time, n->flags, n->next);
    for(a = n->prereqs; a; a = a->next){
        snprint(buf, sizeof buf, "%s   ", (*s == ' ')? s:"");
        dumpa(buf, a);
    }
}
@

<<dumper dumpa>>=
void
dumpa(char *s, Arc *a)
{
    char buf[1024];

    Bprint(&bout, "%sArc@%p: n=%p r=%p flag=0x%x stem='%s'",
        s, a, a->n, a->r, a->flag, a->stem);
    if(a->prog)
        Bprint(&bout, " prog='%s'", a->prog);
    Bprint(&bout, "\n");

    if(a->n){
        snprint(buf, sizeof(buf), "%s    ", (*s == ' ')? s:"");
        dumpn(buf, a->n);
    }
}
@

\ifallcode
<<[[nrep()]] if DEBUG(D_GRAPH)>>=
if(DEBUG(D_GRAPH))
    Bprint(&bout, "nreps = %d\n", nreps);
@
\fi

\section{The jobs, [[mk -de]]}
% e for execution

<<[[nproc()]] if DEBUG(D_EXEC)>>=
if(DEBUG(D_EXEC))
    fprint(1, "nprocs = %d\n", nproclimit);
@



<<[[sched()]] if DEBUG(D_EXEC)>>=
if(DEBUG(D_EXEC))
    fprint(STDOUT, "firing up job for target %s\n", wtos(j->t, ' '));
@

<<[[sched()]] if DEBUG(D_EXEC) print recipe>>=
if(DEBUG(D_EXEC))
    fprint(STDOUT, "recipe='%s'\n", j->r->recipe);
Bflush(&bout);
@

<<[[sched()]] if DEBUG(D_EXEC) print pid>>=
if(DEBUG(D_EXEC))
    fprint(STDOUT, "pid for target %s = %d\n", wtos(j->t, ' '), events[slot].pid);
@


<<[[waitup()]] if DEBUG(D_EXEC) print pid>>=
if(DEBUG(D_EXEC))
    fprint(STDOUT, "waitup got pid=%d, status='%s'\n", pid, buf);
@


<<[[waitup()]] if DEBUG(D_EXEC) and slot < 0>>=
 if(DEBUG(D_EXEC))
     fprint(STDERR, "mk: wait returned unexpected process %d\n", pid);
@

<<[[pidslot()]] if DEBUG(D_EXEC)>>=
if(DEBUG(D_EXEC))
    fprint(STDERR, "mk: wait returned unexpected process %d\n", pid);
@




% actually never used
<<dumper dumpj>>=
void
dumpj(char *s, Job *j, int all)
{
    Bprint(&bout, "%s\n", s);
    while(j){
        Bprint(&bout, "job@%p: r=%p n=%p stem='%s' nproc=%d\n",
            j, j->r, j->n, j->stem, j->nproc);
        Bprint(&bout, "\ttarget='%s' alltarget='%s' prereq='%s' nprereq='%s'\n",
            wtos(j->t, ' '), wtos(j->at, ' '), wtos(j->p, ' '), wtos(j->np, ' '));
        j = all? j->next : nil;
    }
}
@


\section{The function calls, [[mk -dt]]}

<<[[newnode()]] debug>>=
if(DEBUG(D_TRACE)) 
    print("newnode(%s), time = %d\n", name, node->time);
@


<<[[applyrules]] debug>>=
if(DEBUG(D_TRACE)) 
    print("applyrules(%lux='%s')\n", target, target);
@

<<[[work()]] debug>>=
if(DEBUG(D_TRACE))
    print("work(%s) flags=0x%x time=%lud\n", node->name, node->flags, node->time);
@

\chapter{Profiling}

<<global buf>>=
short buf[10000];
@

<<[[main()]] setup optional profiling>>=
#ifdef	PROF
    {
        extern int etext();
        monitor(main, etext, buf, sizeof buf, 300);
    }
#endif
@


% dead function actually
<<function symstat>>=
void
symstat(void)
{
    Symtab **s, *ss;
    int n;
    int l[1000];

    memset((char *)l, 0, sizeof(l));
    for(s = hash; s < &hash[NHASH]; s++){
        for(ss = *s, n = 0; ss; ss = ss->next)
            n++;
        l[n]++;
    }
    for(n = 0; n < 1000; n++)
        if(l[n]) 
            Bprint(&bout, "%d of length %d\n", l[n], n);
}
@


\chapter{Error Management}

% see also runerrs

<<global kflag>>=
bool kflag = false;
@
% continue even if errors, not so useful in general, but
% useful for killchildren when get a C-c
<<[[main()]] -xxx switch cases>>=
case 'k':
    kflag = true;
    break;
@




% automatic error handling

<<function Malloc>>=
void*
Malloc(int n)
{
    void *s;

    s = malloc(n);
    if(!s) {
        fprint(STDERR, "mk: cannot alloc %d bytes\n", n);
        Exit();
    }
    return s;
}
@
%old: used to have 'register void *s', but 8c does not use it I think

<<function Realloc>>=
void *
Realloc(void *s, int n)
{
    if(s)
        s = realloc(s, n);
    else
        s = malloc(n);
    if(!s) {
        fprint(STDERR, "mk: cannot alloc %d bytes\n", n);
        Exit();
    }
    return s;
}
@


<<function Exit>>=
void
Exit(void)
{
    while(waitpid() >= 0)
        ;
    exits("error");
}
@

\chapter{Libc}

%\section{Memory managment}
% Malloc and Realloc now in error management section

\section{Buffer managment}

<<struct Bufblock>>=
struct Bufblock
{
    char 		*start;
    char 		*end;
    char 		*current;

    // Extra
    struct Bufblock *next;
};
@

<<global freelist>>=
static Bufblock *freelist;
@



<<constant QUANTA>>=
#define	QUANTA	4096
@

% ctor
<<constructor newbuf>>=
Bufblock *
newbuf(void)
{
    Bufblock *p;

    if (freelist) {
        p = freelist;
        freelist = freelist->next;
    } else {
        p = (Bufblock *) Malloc(sizeof(Bufblock));
        p->start = Malloc(QUANTA*sizeof(*p->start));
        p->end = p->start+QUANTA;
    }
    p->current = p->start;
    *p->start = '\0';
    p->next = nil;
    return p;
}
@

% dtor
<<destructor freebuf>>=
void
freebuf(Bufblock *p)
{
    p->next = freelist;
    freelist = p;
}
@

<<function growbuf>>=
void
growbuf(Bufblock *p)
{
    int n;
    Bufblock *f;
    char *cp;

    n = p->end-p->start+QUANTA;
        /* search the free list for a big buffer */
    for (f = freelist; f; f = f->next) {
        if (f->end-f->start >= n) {
            memcpy(f->start, p->start, p->end-p->start);
            cp = f->start;
            f->start = p->start;
            p->start = cp;
            cp = f->end;
            f->end = p->end;
            p->end = cp;
            f->current = f->start;
            break;
        }
    }
    if (!f) {		/* not found - grow it */
        p->start = Realloc(p->start, n);
        p->end = p->start+n;
    }
    p->current = p->start+n-QUANTA;
}
@

<<function bufcpy>>=
void
bufcpy(Bufblock *buf, char *cp, int n)
{

    while (n--)
        insert(buf, *cp++);
}
@

<<function insert>>=
void
insert(Bufblock *buf, int c)
{

    if (buf->current >= buf->end)
        growbuf(buf);
    *buf->current++ = c;
}
@

<<function rinsert>>=
void
rinsert(Bufblock *buf, Rune r)
{
    int n;

    n = runelen(r);
    if (buf->current+n > buf->end)
        growbuf(buf);
    runetochar(buf->current, &r);
    buf->current += n;
}
@

\section{Utilities}

<<function maketmp>>=
char*
maketmp(void)
{
    static char temp[] = "/tmp/mkargXXXXXX";

    mktemp(temp);
    return temp;
}
@

\chapter{Examples of [[mkfile]]s}
\label{chap:examples}

\section{[[mkfile]] of [[mk]]}
% relies on next section

\section{The [[mkfile]]s of \plan}
% mentioned in mk.ms ?

\subsection{[[/arm/mkfile]]}

\subsection{[[mkone]]}



\chapter{Extra Code}

\ifallcode
#include "Make_extra.nw"
\fi

%\chapter{Changelog}
% code via make loc = 4763 LOC
% orig Make.nw = 5400 LOC, just lpized and comments in sections
% now: =~ ?? LOC so added ?? LOE (Lines of explanations)
% mk in ocaml: ?? LOC


\chapter*{Glossary}
\addcontentsline{toc}{chapter}{Glossary}
\label{sec:glossary}

\begin{verbatim}
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{chapter}{Index}

%\chapter{References} 
\addcontentsline{toc}{chapter}{References}

\bibliography{../docs/latex/Principia}
\bibliographystyle{plain}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
