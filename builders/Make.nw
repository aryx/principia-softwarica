\documentclass[twocolumn, landscape]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse % see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, I changed for the better a few things:
% - removed dead code:
%    dead namespaces (S_PID, S_MAKEFILE, S_EXPORTED, S_MAKEVAR),
%    dead rule attributes (UNUSED, UPD),
%    dead constants (IWS), dead fields (Job.nproc)
%    TODO useless code (head.n=node, ...)
% - TODO rename variables, was abusing head/tail for too many things 
%   (target vs prerequisites, but also head vs tail of lists of arcs, 
%   head and tail of rule/assignement, ...)

%thx to codemap/codegraph/scheck:
% - use cg to reduce backward deps, introduce globals.c, utils.c,
%   (harder to understand non layered code)
% - use scheck to remove deadcode, dead prototypes, useless export
%   or mv as forward decl
%   (harder to understand big interface files)
% - LESS use cg to reduce number of globals by moving them closer to the
%   relevant file (or even function), better cluster the code
%   (harder to understand non functional code using lots of globals)

%thx to mk in ocaml: (see also the %ocaml-found: tag in this file)
%  - parsing code could be simpler, and also better see the
%    different lexing contexts and subtelities
%  - can do X=a and $X=42, hmm
%  - understand need for ${name}ici
%  - understand check for recipe pointer in ambiguous(), cos can have 
%    many arcs but no ambiguity cos all have the same recipe
%  - understand vacuous check and interaction with ambiguous.

%thx to this manual, better understand mk/make:
% - minimal-syntax design leads to need for escaping-newline because newline is
%   (ab)used as a terminator for many things
% - escaping rules, tricky, but needed because space is used too for separator
% - need for ${} in mk (no pb in make though) so can do ${name}here
% - finally will remember the syntax for ${name:%=%} :) 
% - need for multiple targets, and multiple rules with same target 
% - SEMI how to debug issues in your own makefile
% - SEMI mk is actually a job scheduler! with dependent tasks!
% - to not use ';' but instead && for eflag -e to work
% - scope and life of variables (still dont understand in GNU make, = vs := )
%   whether can use $xx in target, in prereqs, in includes, etc

%history LP-ization:
% - skeleton, mostly copy paste of Template.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * TODO ctor/dtor, dumper
%    * [[xxx]] other fields, [[xxx]] extra fields
% - read Extra section, identify concepts, first TOC
% - distribute parts of the Extra section in the main file
% - understand main(), LP split main, improve TOC
% - understand main functions, LP split, cluster, improve TOC
% - LP split the structures, use datalog for flow to field info
% - nullify, boolify, errorify, enumify,  typeify,    scheckify, plan9ify
% - aspecify advanced features! remove useless features
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% ifallcode is used for:
%  - forward decl, func decl, extern decl, #ifdef, pragmas (stuff in Extra.nw)

\addtolength{\topmargin}{-.850in}
\addtolength{\textheight}{1.70in}

\begin{document}
%******************************************************************************
% Title
%******************************************************************************
\title{
{\Huge 
Principia Softwarica: The Build System [[mk]]
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}\\
\\
with code from\\
Andrew Hume
}

\maketitle 
\onecolumn
\hrule
\input{../docs/latex/Copyright}
\input{../docs/latex/CopyrightPlan9}
\hrule
\twocolumn

\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\tableofcontents
\endgroup

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

The goal of this book is to present with full details the source code of
a {build system}.

\section{Motivations}

Why a build system? 
Because I think you are a better programmer if
you fully understand how things work under the hood,
and a build system is one of the tools a programmer uses the most.
%
Indeed, it allows programmers to 
assemble, 
compile, 
link,
test,
package, and 
distribute 
software with one simple command, ``the one command that rules them all'',
from very simple programs to entire operating systems.
\n deploy

% A build system is .. describe and  maintain dependencies between files. Rules.
\n def build system so I can use "rule" and "dependency" in questions below

% No deep concepts. nice DSL though. language-based solution to a problem.
% minimal syntax. nice checks.
% Also use of //. job scheduler (quite useful in general).

Here are a few questions I hope this book will answer:

\begin{itemize}

\item What are the fundamental concepts of a build system?

% what kind of dependency are necessary? just file (target) to file (prereq)?
% target to multi prereq ? what about multi targets to one prereq?
% Do you need multiple rules for same target? what about ambiguities?
% one-to-one, many-to-many?

% What is minimal syntax one needs. DSL.
% :, =, newline, then how escape?

\item What are the user mistakes a build system can detect?
Can it detect stupid rules? Redundant rules? Ambiguous rules?
Infinite rules?

\item How can you visualize the actual dependency tree? 
What help does the build system offer to debug a makefile?

\item How does the build system run different tasks in parallel and coordinate
them? How do you write a simple job scheduler?

\end{itemize}

\t put in conclusion non-trivial adv algo and data structures seen? see comment
%data-structures (beyond list/hashtbl):
% - queue

%algorithms (beyond search/sort): (actually use neither search nor sort)


%tags used in this file for different recurring themes:
 %
 %real-world: to relate to other assemblers
 %ocaml: to give a hint on how rewriting C in OCaml could improve things
 %ocaml-found: found subtle behavior of mk because I ported it to ocaml
 %alt: alternative technique
 %old: for original code I changed to be clearer
 %pad: for code I introduced to be clearer
 %dead: dead code removed
 %toc: %trans: %dup: %example: %chunks:


\section{The \plan build system, [[mk]]}

% I gonna present mk, build system of plan9. X? LOC. written entirely in C.
% used also outside plan9 by a few open source software.
% Elegant, simple, bla bla.

% with one mk command, build plan9 libs, plan9 programs, plan9 kernel,
% and build disk image that can be installed on raspberry or QEMU.
% one command!
\n actually I use make right now :)

% similar to make. 
% differences with make? More regular. Simpler (e.g. variables,
%  escaping).
% Author of make Stu Fedlman consider mk better in every way.
% run in // by default, main feature compared to original make
%  (and actually design and features influenced by that I think,
%  e.g. multiple targets rule, or build graph at mk time once)
% because plan9 context.
% Also well written, nice use of assert!
% Also no infamous TAB issue :)

\section{Other build systems}

Here are a few build systems that I considered for this book,
but which I ultimately discarded:
\begin{itemize}

\item \unix make
% I mentioned before. Original one.
% Stu Feldman, ACM System Software Award.
% in ape/cmd/make/, 3000 LOC. MAKE 2.78 unix 8th edition
% (also in unix-history-repo)

% Stu himself considers mk a better solution.
% see mk.ps section 4
%  less uglyness with variables too, no $$i need, variables passed as-is
%  (like for rc, cleaner?) so remove some intermediates
%  also no $(X), just $X, far more consistent
%
%  well many mk extensions have become gnu make, e.g. %.c rules instead of .c
%  (hmm still? mk introduced pattern metarules, but metarules may have been
%   in research UNIX make)
% see also https://github.com/dcjones/mk for list of improvements
%  cryptic $@, $^, $* vs $target, $prereq, $stem

\item GNU make
% also in // make -j. But as good as mk? since mk has full graph, can
%  run in // from very different parts of the tree. make can?
% Many extensions. Too many.
% still include support for many old platforms, e.g., DOS, VMS., amiga
% 37 000 LOC? main.c 3200 LOC

\item ant
% 222~000 LOC (without tests)
% Java specific?
% XML, major drawback.
% and Ivy (dependency manager, equivalent of cargo?)

\item CMake
% 560~000 LOC, lol
% but it is more a build system generator, more than a build system
% a meta build-system.
% like automake, gyp, etc. mix actually configure/automate feature I think.


% one using python, EDSL, but more syntax boilerplate "", [;], etc

\end{itemize}

\l a few other, see the comment in this file:
%make-clones:
% - pmake, freebsd https://www.freebsd.org/doc/en_US.ISO8859-1/books/pmake/
%   parallel make
% - https://github.com/dcjones/mk is mk port in Go! 2285 LOC but some files
%   looks almost like an automatic C->Go translation (identical logic)
% - omake, apparently has listen-to-fs features too, so daemon
%   and rerun when save in editor?
%   http://blog.camlcity.org/blog/omake1.html
%other:
% - ninja, seems interesting, the assembler of build system, 19~000 LOC
% - bazel?? latest from google:
%   http://google-opensource.blogspot.com/2015/09/building-build-system-bazel-reaches-beta.html
% - buck, huge, python-based like many other google-inspired build systems.
%   the ocaml-specific stuff is already 4000 LOC, hmmm
% - cons/scons, Perl-based and python-based build systems???
% - tup, 31 000 LOC (just src/tup/), does not look that much better than mk
%   but looks pretty nice: *.c |> gcc %f -p %o |> %B.o
%   http://gittup.org/tup/make_vs_tup.html benchmark
% - redo, from dan bernstein, seems minimalist, not sure it's better.
%   maybe better for autodeps.
%meta build system:
% - automake
% - gyp, meta-build-system from Google, python-inspired, simple, 28~000 LOC
%   but support many backends (make, cmake, ninja, eclipse, xcode, ...),
%   fbcode is similar to gyp
%wrappers:
% - qake, just a big makefile, so relies on GNU make
% - OCamlMakefile
%language specific:
% - java: 
%    * maven, first to provide ability to download dependency over the network?
%    * ant+ivy (to catchup with maven)
%    * gradle seems best one, use of DSL based on Groovy. huge codebase.
%    comparison: https://technologyconversations.com/2014/06/18/build-tools/
%    but all 3 are bad.
% - javascript: gulp, grunt
% - ruby: rake, can write rules in Ruby. EDSL again. more verbose than make,
%   need of do, end, need '' around filenames, need of many builtins.
%   maybe inspiration for brew
% - haskell: shake, EDSL in haskell, seems too verbose
% - scala: sbt, meh
% - rust: cargo, integrate in build system a dependency manager
% - ocaml: opam (just dependency manager though)

% see https://en.wikipedia.org/wiki/List_of_build_automation_software

%http://www.lihaoyi.com/post/WhatsinaBuildTool.html
% nice comparisons of a few tools
%http://hadihariri.com/2014/04/21/build-make-no-more/
% nice bashing of all make competitors, a la "evolution of a programmer"
%the essence of make, not too bad, nice relation between ninja and make
% http://bentnib.org/posts/2015-04-17-propositions-as-filenames-essence-of-make.html
%make advocacy :)
% http://bost.ocks.org/mike/make/
%http://aosabook.org/en/500L/contingent-a-fully-dynamic-build-system.html
% meh, EDSL
%make theory and practice
% http://www.ploxiln.net/make.html  meh
%how we use make:
% https://segment.com/blog/how-we-use-make/ list of targets



\section{Getting started}

To play with [[mk]], you will first need to install
the \plan fork used in \principia. See \urlinstall.
Once installed you can test [[mk]] under \plan with:

% cd /tests/mk/
% mk -f hello.mk
% TODO

\n could get one from kencc or plan9port. issues though with rc vs sh ...



\section{Requirements}

%dup: from Assembler.nw
Because most of this book is made of C source code, 
you will need a good knowledge of 
the C programming language~\cite{k-r} to understand it.
%
I also assume you are already familiar with at least 
one build system, for instance, [[make]],
%
and so are familiar with concepts such as
a {makefile},
a {rule},
a {target}, 
a {prerequisite}, or
a {shell command}.
\n called recipe in mk, by shell command easier (said later)
%
If not, I suggest you to read the 
\plan article~\cite{article-mk} that introduces [[mk]],
and which is available in my \plan distribution.
%
%builders/make/ contain how mk used in plan9,

% GNU make manual? books on make? cite them at least?

% if you have questions on interface
The man page of [[mk]] can also useful at [[docs/man/1/mk]].

%also for design decisions, see_successor mk.pdf
%moreover contains diffs with make

\section{About this document}
#include "../docs/latex/About.nw"

\section{Copyright}
\input{../docs/latex/CopyrightPlan9Text}

\section{Acknowledgments}

I would like to acknowledge of course the author of [[mk]],
Andrew Hume,
% and Bob Flandera?, 
who wrote in some sense most of this book.




\chapter{Overview}

%trans:
Before showing the source code of [[mk]] in the following chapters, 
%toc:
I first give an overview in this chapter
of the general principles of a build system.
\t TODO command line interface of mk, simple mkfile.
%dup: from Assembler.nw
I also define terms, explain how the code is organized, 
and more generally give the background necessary
to understand the code I will show later.

\section{Build system principles}

% How was doing before make? Manually remember in your head what needs
% to be done.
% adhoc shell scripts 'make', as projects got more complex,
% more files. Example for mk.c? 
% Long. would like to factorize.
% Also not efficient. redo. should recompile only what is necessary, 
%  what depends on the change.
% (but can be used for bootstrapping mk)

The goal of a build system is to 
describe {\em concisely} and 
maintain {\em efficiently}
{\em dependencies} between files or programs.
%toc:
% every word is important :) 
% concisely lead to create of DSL.
% dependencies leads to graph representation
% efficiently leads job scheduler and stuff in parallel
% as explained in next sections.
\n there are different kinds of deps actually many-to-many

\subsection{A domain-specific language}

% A domain-specific language (DSL) is a computer language
%  tailored for one task. Usually not as expressive as full PL,
%  but trade expressivity for compactness, and special checks.

%toc:
% very small language.
% rules, variables, inclusion, patterns.

\subsubsection{Rules}

% essence is state dependencies and how to achieve it.

% like arc in a graph. src, dest, and label on edge.
% (and indeed later will see that we generate a graph)
% In build systems called
% rule.
% also give names to left and right parts: target: dependencies

% {target} {dependencies} {recipe}
% recipe also called body.
% and start of rule is called head of the rule.

% simplest syntax,  x : y \n z1 \n z2.
% could also x : y ; z1; z2

% In mk, very simple, minimal syntax! just ':', and newlines
% no need "" around shell command.
% same spirit than shell actually. no need () for calling
% commands, "" around strings, remember
% order of options (but then lead to -xxx named arguments)

%\subsubsection{Recipe}
% in fact body of a rule is shell command. Embedded lang
% inside lang. Not interpreted. As is. (simpler than in make)
% leverage existing tools!

% optional recipe. space/tab first char cos support multiline 
% for shell command (otherwise would need escaped newline there too, ugly).




%advanced? maybe fundamental. what types of dependencies we need?
% can have multiple targets:
%    x.ml x.mly: x.mly
%  (but then can be confusing when making graph of deps. dont want
%  run recipe twice, so tricky, so need mark multiple nodes from one job done)
\n  also can be used to factorize simple rules like a.o b.o: x.h

% can have same target and multiple rules (a condition only one recipe)
%    x.o: x.c  recipe     x.o: y.h
% (also with metarules below, when instantiate can add more rules??)
%  but maybe this one is really sugar, could put all prerequisites at once!

% how to allow :: of GNU make? bad to allow :: in the end? can generate
%  ambiguity? just agglomerate recipe?


\subsubsection{Variables}

% to factorize. ex, CFLAGS=-g -x -...
% and then can use in many rules CFLAGS
% easier to modify too.

% one of design of mk is reusing existing stuff. So reuse
% syntax (and some machinery) of shell to define and use variables.
% but in mk really more constants than variables.
% (actually check when override?)
% Again, minimal syntax, X=Y.
% no need [;] for list of things. Just use = until newline
%  (but then need to have \ escaped newline to scale to large lists)
% I say constant cos subtle! 
\n even though can be overriden on commandline
% They need to be statically known for mk, so better
% use constants. Also clearer then diff between constants like OBJS=..
% and variables generated by mk such as target, stem etc.


% var really contain list of strings. Concatenation of list is easy,
% just juxtapose as in  X=a b c  Y=$X d e f
%ocaml-found: scalar vs list context! can be stricter actually

% defs and uses, and actually can have complex uses with substitutions
%  on stemming

% can use constants in rules!
% can reuse constants in different rules.


\subsubsection{Inclusion}

% < so modularity and can factorize in different files

% with variables above, offers already some kind of genericity!
% in fact many mkfiles are just  < /sys/src/cmd/mkone !
% but still need metarules for that.


%\subsection{Generating some dependencies automatically}

% object level deps. libs.
% But also semantic level.

% Many dependencies are implicit in files. if foo.c include
% foo.h, should recompile. Can declare deps in mkfile, but
% redundant, hard to maintain. 
% So can be good to auto generate some dependencies. But 
% different for each programming language.

% enter .depend 
% (and so also need for multiple rules for same targets (but with empty recipe))

% so ocamldep, 
% gcc -MM.

% related is library of variables and rules for different languages.

% question is can we generate every dependencies automatically?
% IDE tries to do that. But requires helps, AddFile, AddDir.
% what about when have multiple binaries in one distrib?
% hh_server nice, but works because generate a giant PHP library.

% in the end, could be job of compiler? like javac does? but then
% impose constrain on how to organize classes in files and path
% (or use hh_server, but again, impose constraint of one giant
% single binary/library)


\subsubsection{Generic (meta) rules}

% metarules (rule generating rules), use variable names => generic stuff
%  (especially when use modularity)
% stemming, so can factorize with generic rules.

% can use only variables in target and prerequisites
% (but can use variables in recipe)

% describe a set of arcs in a graph in a generic way.

%\subsubsection{Generality}

% works for all PLs. not adhoc to one PL like IDEs

%related: generate from mkfile .project, like Buck does.

%\subsection{Different types of dependencies}



\subsection{A graph of dependencies}

% As said, dependencies mostly definition of arc. 
% so can take all rules and build global graph.
% With meta rules, need instantiate also.
% to have actual concrete files.

% build graph of deps. accurate representation of dependencies.

% graph of deps, if modify a leaf then have to rebuild everything up!
%  but not everything!

% actually DAG (and acyclic check later). So in code we will see
% a few times to set a flag on a node marked as done, to avoid
% repeat multiple times the same thing.
% FIGURE dag, with x.o used by multiple targets (multiple binaries or libs)
%  or lib.a used by multiple binaries.

%trans:
% efficiency => graph and //
%  if brother, then can run in // cos independent!


\subsection{A job scheduler}
% parallel job scheduler

% FIGURE where can see different steps stuff you can do in //? 

% mk is actually kind of a scheduler because can do things in //,
% run recipe of independent jobs in //, and need to manage dependencies
% between those jobs
% then need coordinate. wait for finish, run independent.
% Master/Workers?


\section{[[mk]] command-line interface}

% interface is pretty simple, go in dir, type 'mk'
% or 'mk target' 
\n great way to use mk is have list of one-liner
% actually can give multiple targets

% even shorter than make to type :) good, because will type
% this command a lot. (even close on keyboard)

<<function badusage>>=
void
badusage(void)
{

    fprint(STDERR, "Usage: mk [-f file] [-n] [-a] [-e] [-t] [-k] [-i] [-d[egp]] [targets ...]\n");
    Exit();
}
@
\l also have NPROC, NREP global variables
\t actually -I now, not -i
%ocaml: use Arg so cleaner --help (but true that redundant with man page)

%chunks: will present options gradually


% can also mk -f (as shown in Section X), if dont like
% default mkfile.

% mk then look for mkfile by default
%real-world: (make look for Makefile).

<<constant MKFILE>>=
#define	MKFILE		"mkfile"
@
%ocaml: used only once, so could be expanded where it's used

% but can change with -f.


% some xxx=yyy, and some -xxx
% has also many -xxx options, advanced features explained later in the book.


\ifallcode
%dead? used by some tools?
<<global version>>=
static char *version = "@(#)mk general release 4 (plan 9)";
@
\fi


\section{[[hello.mk]]}
\n [[hello.mk]] concistent with my other books.
\l A simple [[mkfile]]

<<tests/mk/hello.mk>>=
OBJS=hello.5 world.5

hello: $OBJS
 5l -o hello $OBJS

%.5: %.c
 5c -c $stem.c
@
%$
\n simple var, simple rule, metarule, special vars; the essence of mk is there


% mkfile of helloworld.c?
\n minimum spirit, no <objfile, no factorize with mkone

% running example
% concepts: target, prerequistes, recipe

% show also simple output of running mk on a toy project
% maybe even include mk -e output?

%How add to an existing variable? e.g. CFLAGS+= -p?
% easy, CFLAGS= -xxx $CFLAGS
%Can do the $(BLA:.cmo=.cmx)? this is convenient
% yes you can: OBJS=${SRC:%.ml=%.cmo}

% what happen when have general rule like %.cmo: %.ml
% and then more specialized rules? or when have extra rules
% like %.cmo: %.cmi without any recipe?
% (note that right now $prereq seems to also include the .cmi in which
% case you want to use $stem in the general rules)

% For more examples, see appendix. Goal here is to give a taste.
% actually the mkfile of mk itself :) appendix!

<<tests/mk/hello.mk alternative>>=
hello: hello.5 world.5
 5l -o $target $prereq
@
%$



%\section{Input [[mkfile]] language}

% precise syntax? can have OBJ = xxx or need OBJ=xxx ?
% need space before recipe? can have comments?


\section{Code organization}

%mk.h: main data structures and globals declarations
%fns.h: forward function declarations (prototypes)

%symtab.c: global hash table, and cache
%globals.c: globals definitions
%var.c: setvar(), dumper, utilities

%word.c: list of strings
%rule.c: addrule(), dumper
%arc.c: newarc(), dumper, nrep() (move it?)
% maybe have also a node.c?
%job.c: newjob(), dumper


%main.c: main() entry point!

%lex.c: lexing a line
%parse.c: parsing mkfile
%varsub.c: managing variables and substitution


%graph.c: graph(), building the dependency graph
%match.c: match() and subst() for metarules

%mk.c: mk() and work(), building the graph and then the targets

%run.c: job schedule, run(), sched(), profiling processors
%env.c: recipe environment
%rc.c: rc interaction, quote, unquote, escaping, etc
%recipe.c: dorecipe()

%file.c: timeof(), touch(), delete(), timeinit()
% maybe have a time.c instead?


%shprint.c: print recipe before executing it

%archive.c: special archive extension xxx(yyy)

%bufblock.c: buffered IO
%utils.c: libc like helper functions
%plan9.c: libc like helper functions plan9 specific (unix.c, windows.c)
% (rename os.c?)

\section{Software architecture}

% compute graph statically! once and for all at the beginning.
% then process graph.

% graphviz of files? or just of the types?

% from top to bottom, and left to right.

% main() -> parse(mkfile) (populate rules, metarules, target1, S_VAR, ...)
%        -> mk(target1) -> graph(target1)
%                       -> work(node) -> outofdate(node, prereq)
%                                     -> dorecipe
%                                         -> run(job) -> sched() -> execsh()
%                                     
%                       -> waitup()

% data flow?

%\section{Boostrapping}
% we use a mkfile and mk to compile mk :)
% can bootstrap simply using a shell script for the very first time.


\section{Book structure}

%trans: %dup: (and adapted) from Assembler.nw
You now have enough background to understand the source code of [[mk]].
%toc:
The rest of the book is organized as follows.
%
I will start by describing the core data structures of [[mk]]
in Chapter~\ref{chap:core-ds}. 
%
Then, I will use a top-down approach in Chapter~\ref{chap:main}, and,
starting from [[main()]], I will present the code
%, or a high-level view of the code, of some 
of the main functions of [[mk]], e.g., [[mk()]].
%
The following chapters will describe
the main components of the building pipeline:
\t parsing rules, building graph, analyzing deps, scheduling jobs,
and finally interacting with the shell.
\t debugging and profiling support for user.
%
Chapter~\ref{chap:advanced} presents advanced
features of [[mk]] that I did not present before to simplify the explanations,
for instance, {rule attributes}.
%
Finally, Chapter~\ref{chap:conclusion} concludes
and gives pointers to other books in the \principia series.

%toc:
Some appendices present the code of non-functional properties:
code to help debug [[mk]] itself in Appendix~\ref{chap:debugging-appendix},
code which profiles [[mk]] itself in Appendix~\ref{chap:profiling-appendix},
and code to manage errors in Appendix~\ref{chap:error}.
%
Appendix~\ref{chap:libc} contains the code of generic
utility functions used by [[mk]] but which are not specific to [[mk]].
%
Appendix~\ref{chap:examples} present examples of [[mkfile]]s.


%###############################################################################

\chapter{Core Data Structures}
\label{chap:core-ds}

\begin{verse}
\begin{flushright}
  {\it Show me your code and conceal your data structures, and I shall
    continue to be mystified. Show me your data structures, and I
    won't usually need your code; it'll be obvious.\\
    ~\\
    Fred Brooks}
\end{flushright}
\end{verse}


%toc:
In this chapter I will present the core data structures of [[mk]],
\t WHICH ARE big symbol table for variables, AST for rules, 
%and nodes and arcs for graph of dependencies, and
%job gather all information needed to generate one target.
% Maybe say appendix X for string buffer Bufblock?

% core types: (see mk.h)
% Bufblock, Word
% Sym (a bit generic, could be in libc?)

% Rule (mk -dp?), recipe? metarule, target, prerequiste (see mk.ps)
% Node, Arc (mk -dg)
% Job, (mk -de)
% Envy (bad name)

% core globals: (see mk.h externs)
% rules, metarules, patrule,    jobs
% symbol hashtbl global
% bout
% envy

% draw diagram showing relations to each other, what includes what?

\section{Symbol table}

% need quick access to rules for a specific target.
% need also manage variable of user.
% => generic hashtbl.

\subsection{[[Symtab]]}

<<struct Symtab>>=
struct Symtab
{
    // the key: (name x space)

    // ref_own<string>
    char		*name;
    // enum<Namespace>, the ``namespace''
    short		space;

    // the value (generic)

    union{
        void*	ptr;
        uintptr	value;
    } u;

    // Extra
    <<[[Symtab]] extra fields>>
};
@
%ocaml: reuse hashtbl and use a record of hashtbl for namespaces
% (so also better types instead of overly generic union)

% the "world" data structure? hmm rules+metarules is more the world
% here it's more an index over the rules, metarules, and some cache
% (e.g. time of a file)
%less: could use a record instead of that which would be better typed

<<enum Namespace>>=
enum Namespace {
    S_VAR,	/* variable -> value */ // value is a list of words
    <<[[Sxxx]] cases>>
};
@
\l actually should be S_CONST? well some variables can be overriden
\l  when passed on the command line, so technically it is kinda a variable
\l  but maybe better to differentate still
% use for fast access and also for memoization, operates as a cache
%dead:
%S_PID,		/* pid -> products */
%S_MAKEFILE,	/* target -> node */

%chunks: will see more namespace gradually

\subsection{[[hash]]}

<<global hash>>=
// hash<(string * enum<Namespace>), 'a> (next = Symtab.next in bucket)
static Symtab *hash[NHASH];
@
<<constant NHASH>>=
#define	NHASH	4099
@
%ocaml: does not have to be a global, can be passed around
% if split in different parts for each namespace
% (var and internal vars, hnodes, time cache)

<<[[Symtab]] extra fields>>=
struct Symtab	*next;
@

<<constant HASHMUL>>=
#define	HASHMUL	79L	/* this is a good value */
@

% many stuff -> <>
% will create new entry if not there!
<<function symlook>>=
Symtab*
symlook(char *sym, int space, void *install)
{
    long h;
    char *p;
    Symtab *s;

    //h = hash(sym, space)
    for(p = sym, h = space; *p; h += *p++)
        h *= HASHMUL;
    if(h < 0)
        h = ~h;
    h %= NHASH;

    for(s = hash[h]; s; s = s->next)
        if((s->space == space) && (strcmp(s->name, sym) == 0))
            return s;
    // else

    if(install == nil)
        return nil;

    s = (Symtab *)Malloc(sizeof(Symtab));
    s->space = space;
    s->name = sym;
    s->u.ptr = install;

    // add_list(s, hash)
    s->next = hash[h];
    hash[h] = s;

    return s;
}
@
%ocaml: just use Hashtbl.find
\t define symexists() that uses install == nil, cleaner?
\t  and return bool

% execinit -> <>
<<function symtraverse>>=
void
symtraverse(int space, void (*fn)(Symtab*))
{
    Symtab **s, *ss;

    for(s = hash; s < &hash[NHASH]; s++)
        for(ss = *s; ss; ss = ss->next)
            if(ss->space == space)
                (*fn)(ss);
}
@
%ocaml: used only for ecopy, so could use Hashtbl.copy?

% main -> <>
<<function syminit>>=
void
syminit(void)
{
    Symtab **s, *ss;

    for(s = hash; s < &hash[NHASH]; s++){
        for(ss = *s; ss; ss = ss->next)
            free((char *)ss);
        *s = nil;
    }
}
@
\l free necessary? should be nil no? syminit called at the start of main
%ocaml: use Hashtbl, which is initialized correctly by ocaml

%\subsection{[[setvar()]]}

% many stuff -> <>
<<function setvar>>=
void
setvar(char *name, void *value)
{
    symlook(name, S_VAR, value)->u.ptr = value;
}
@
%dead:    symlook(name, S_MAKEVAR, (void*)"");
%dead:
%<<[[Sxxx]] cases>>=
%S_MAKEVAR,	/* dumpable mk variable */
%@
%ocaml: since S_MAKEVAR is dead, can just use Hashtbl.set

\subsection{Namespaces}

% use symbol table for many things.
% user variable. But also internal variables.
% can be in conflict with user variable.
% so multiple namespaces.

<<[[Sxxx]] cases>>=
S_INTERNAL,	/* an internal mk variable (e.g., stem, target) */
@
% diff with S_VAR? not set by user! set by mk automatically
% those one are really variables (maybe that's why they are in lowercase)
%ocaml: use record

<<global myenv>>=
static char	*myenv[] =
{
    "target",
    "prereq",
    "stem",

    <<[[myenv]] other array elements>>
    0,
};
@
% $stem $prereq
% (better than $@, $^ )
% but actually can be multiple targets, and prereqs!

%chunks: will see more internal variables gradually.

%chunks: will see more namespaces gradually.

% main -> <>
<<function initenv>>=
void
initenv(void)
{
    char **p;

    for(p = myenv; *p; p++)
        symlook(*p, S_INTERNAL, (void *)"");

    readenv();				/* o.s. dependent */
}
@
% readenv? for /env/, see later.
\t call initsyms() or inithash() (or rename Envy to Shellenv)
%bug? it is supposed to be words no? so at least newword("") ?




\section{[[Word]]s}
% and Bufblock

% list of words is fundamental!
% many things are done over lists in mk. list of prerequistes,
% list of targets, list of files in variables as in
% HFILES=fns.h mk.h => list of 2 words



<<struct Word>>=
struct Word
{
    // ref_own<string>
    char 		*s;

    struct Word 	*next;
};
@
\n rename Words? less consistent with other use of C. You just need to
\n  better qualify the pointer each time in comment.
\n But has to be Words; no much point in having Word just be a char* wrapper
%ocaml: just use List, or even better W of word list


% rename newword_list? new_singleword?
<<constructor newword>>=
Word*
newword(char *s)
{
    Word *w;

    w = (Word *)Malloc(sizeof(Word));
    w->s = strdup(s);
    w->next = nil;
    return w;
}
@

% it's actually delwords, or freewords
<<destructor delword>>=
void
delword(Word *w)
{
    Word *v;

    while(v = w){
        w = w->next;
        if(v->s)
            free(v->s);
        free(v);
    }
}
@
%ocaml: just use the garbage collector

% treat list as a set, dont add if already there
<<function addw>>=
void
addw(Word *w, char *s)
{
    Word *lw;

    for(lw = w; w = w->next; lw = w){
        if(strcmp(s, w->s) == 0)
            return;
    }
    lw->next = newword(s);
}
@
\t mv in words.c ?
%ocaml-found: but can not use Set, because then order
% may not be the order of insertion, and it is important
% since $prereq must be the same than the order in the prereq in the mkfile.

<<function wdup>>=
Word*
wdup(Word *w)
{
    Word *v, *new, *base;

    v = base = nil;
    while(w){
        new = newword(w->s);
        if(v)
            v->next = new;
        else
            base = new;
        v = new;
        w = w->next;
    }
    return base;
}
@
%ocaml: just use sharing done by ocaml. Pure DS.

% word to string
<<function wtos>>=
char *
wtos(Word *w, int sep)
{
    Bufblock *buf;
    char *cp;

    buf = newbuf();
    for(; w; w = w->next){
        for(cp = w->s; *cp; cp++)
            insert(buf, *cp);
        if(w->next)
            insert(buf, sep);
    }
    insert(buf, '\0');

    cp = strdup(buf->start);
    freebuf(buf);
    return cp;
}
@
%ocaml: Common.join (but using Buffer would be faster too)

% insert? Bufblock? See appendix!
% will use Bufblock many times. Avoid quadatric string concatenations.
%ocaml: use Buffer.insert

% stow() later, but complex because does variable expansion!

\section{Rules}

% AST of rules, from which will build actual graph of dependencies
% with actual files.

\subsection{[[Rule]]}

<<struct Rule>>=
struct Rule
{
    char 		*target;	/* one target */
    // option<ref_own<Words>>
    Word 		*tail;		/* constituents of targets */
    // ref_own<string>, never nil, but can be empty string (just '\0')
    char 		*recipe;	/* do it ! */

    <<[[Rule]] other fields>>
    <<[[Rule]] debug fields>>

    // Extra
    <<[[Rule]] extra fields>>
};
@
\t rename tail to prereqs? 
\t seems like recipe can not be nil actually, cos do *a->r->recipe
% note that can have multiple rules
% with the same head, in which case you add prerequistes.

% seen Word before.

% recipe can contain $, target and tail not, the variables are expanded
% at parsing time.
% from man page:
%  Variable substitution in a rule is done when
%  the rule is read; variable substitution in the recipe is done
%  when the recipe is executed.
% why? probably because recipe/rc will do the subst itself, but for
% the graph we need concrete values so faster to do it eagerly when parsing.
% Also because for recipe, some values are known later, when instantiate 
% the rule (e.g., for $stem)

\t recipe can also just be '\0' ? ugly.
\t  can be nil? sometimes seems assume cannot, and sometimes can. fix it!
\t  according to rbody(), it cant be nil, at least it is empty string

% can also be metarule, %.$O: %.c (but $O would have been expanded)

<<[[Rule]] debug fields>>=
char* 		file;		/* source file */
short 		line;		/* source line */
@
\t put in Debugging support section?




\subsection{Simple [[rules]]}

<<global rules>>=
// list<ref_own<Rule>> (next = Rule.next, end = lr)
Rule *rules;
@
%ocaml: return them instead of using globals

<<[[Rule]] extra fields>>=
// list<ref_own<Rule>> (head = rules | metarules)
struct Rule	*next;
@

% end (last) of rules list, so can add at the end
<<global lr>>=
// option<ref<Rule>> (head = rules)
static Rule *lr;
@

\subsection{[[metarules]]}

<<function PERCENT>>=
#define	PERCENT(ch)	(((ch) == '%') || ((ch) == '&'))
@
% from man page:
% '%' matches a maximal length string of any characters;
% '&' matches a maximal length string of any characters except period or slash


<<[[Rule]] other fields>>=
// bitset<Rule_attr>
short 		attr;		/* attributes */
@

<<enum Rule_attr>>=
enum Rule_attr {
    META   = 0x0001,
    <<[[Rule_attr]] cases>>
};
@
%dead: indeed, unused :)
% UNUSED = 0x0002,
%dead:
% UPD    = 0x0004,
% <<[[rhead()]] when parsing rule attributes, switch rune cases>>=
% case 'U':
%     *attr |= UPD;
%     break;
% @
% "the targets are considered to have been updated even if recipe did not do so"

% META is for % metarule (and also regexp rules :R:)

%chunks: will see gradually more rule attributes, especially Section X.

<<global metarules>>=
// list<ref_own<Rule>> (next = Rule.next)
Rule *metarules;
@
%ocaml: return them instead of using globals

% end (last) of metarules list, so can add at the end
<<global lmr>>=
// option<ref<Rule>> (head = metarules)
static Rule *lmr;
@


\subsection{Adding rules}
% and indexing

\subsubsection{One rule with one target, [[addrule()]]}


% kind of ctor
% syntax: head -> target, tail -> reqs, body -> recipe
% (main -> parse | main) -> <>
<<function addrule>>=
void
addrule(char *head, Word *tail, char *body, Word *ahead, int attr, int hline, char *prog)
{
    Rule *r = nil;
    <<[[addrule()]] other locals>>

    <<[[addrule()]] find if rule already exists>>

    if(r == nil)
        r = (Rule *)Malloc(sizeof(Rule));

    r->target = head;
    r->tail = tail;

    r->recipe = body;

    r->line = hline;
    r->file = infile;

    r->attr = attr;

    <<[[addrule()]] set more fields>>

    <<[[addrule()]] indexing [[r]] by target in [[S_TARGET]]>>

    <<[[addrule()]] if meta rule>>
    else {
        if(reuse)
            return;
        r->pat = nil;

        // add_list(r, rules, lr)
        if(rules == nil)
            rules = lr = r;
        else {
            lr->next = r;
            lr = r;
        }
    }
}
@
\t rename arguments! target, prereqs, alltargets, etc
\t mv hline at the very end, or before attr and prog
% could print when find an existing rule with same target/pre
% and display a message?
\l r->pat ?? Malloc does not memset zero anyway?
%ocaml: use record, and no need wrapper constructor, construct directly with
% the fields

<<[[addrule()]] if meta rule>>=
if(charin(head, "%&") || (attr&REGEXP)){
    r->attr |= META;
    if(reuse)
        return;
    <<[[addrule()]] if REGEXP attribute>>

    // add_list(r, metarules, lmr)
    if(metarules == nil)
        metarules = lmr = r;
    else {
        lmr->next = r;
        lmr = r;
    }
}
@

% will see charin() later. subtle if want to handle quoted characters
% because we need to handle filenames that have special characters in it.


<<[[addrule()]] other locals>>=
Symtab *sym;
bool reuse;
@

<<[[addrule()]] find if rule already exists>>=
reuse = false;
if(sym = symlook(head, S_TARGET, nil)){
    for(r = sym->u.ptr; r; r = r->chain)
        if(rcmp(r, head, tail) == 0){
            reuse = true;
            break;
        }
}
@
\t why allows that? just return error? simpler.
\t  anyway, was not guarding nrules plusplus with if(!reuse) so weird.
\t but now S_TARGET is later ... so mv check later?
\t or even simpler, let it go, it will be detected later by ambiguous()

% rule compare, check if same target and same prerequistes
<<function rcmp>>=
static int
rcmp(Rule *r, char *target, Word *tail)
{
    Word *w;

    if(strcmp(r->target, target))
        return 1;
    for(w = r->tail; w && tail; w = w->next, tail = tail->next)
        if(strcmp(w->s, tail->s))
            return 1;
    return (w || tail);
}
@
\t strcmp sucks, use string_equal, and return bool that makes sense
\t  so less rcmp(...) == 0, instead rule_equal(...)
%bug? what about when different orders of prereqs? should compare as a set
% anyway I think it's redundant with ambiguous rule check

\subsubsection{One target with multiple rules, [[S_TARGET]]}

% useful also for .depend? or different because here
%  get multiple rules for same target? x.o: x.c   x.o: y.h

% used in addrule()
<<[[Sxxx]] cases>>=
S_TARGET,		/* target -> rules */ 
@
%old: rule -> rules
%ocaml: build hash in separate phase

% can have multiple rules with the same target!
% no need :: ? will get ambiguous rule?
% but there will be a master rule. Other should have empty recipe.

<<[[Rule]] extra fields>>=
// list<ref<Rule>> (head = symlook(x, S_TARGET))
struct Rule	*chain;		/* hashed per target */
@
% different than next! here in same list because same target.
% for next in same list because same hashed name. 
% And for next, it supports only one element. Here can
% have set of hashed things. One target symbol, get multiple symbols.
% (hashset)


<<[[addrule()]] other locals>>=
Rule *rr;
@
% sym local is above.

<<[[addrule()]] indexing [[r]] by target in [[S_TARGET]]>>=
if(!reuse){
    sym = symlook(head, S_TARGET, r);
    rr = sym->u.ptr;
    if(rr != r){
        r->chain = rr->chain;
        rr->chain = r;
    } else 
        r->chain = nil;
    r->next = nil;
}
@
%old: rr = symlook(head, S_TARGET, r)->u.ptr;
 
% seen symlook before.





\subsubsection{One rule with multiple targets, [[addrules()]]}
% was in advanced topics, but  maybe fundamental features then. 
% Also too much code doing stuff to support multiple targets.


% useful for parser.ml parser.mli: parser.mly !

<<[[Rule]] other fields>>=
// ref<list<ref_own<string>>
Word 		*alltargets;	/* all the targets */
@
% as in  gram.c gram.h: gram.y ...
% (hmm but could be rewritten with 2 rules, it's just
% that with mk the file would be possibly rebuilt two times!
% because it could run the command in parallel!!!!
%ocaml: merge with Rule.target, and make it a list instead of char*

% Is there a few places where use Word* targets
% where in most cases it should really be simply char* target; ??

% why target and alltargets? why not just have alltargets?
% because we index per single target so in applyrules we can be
% faster (but still slow on metarules)

<<function addrules>>=
void
addrules(Word *head, Word *tail, char *body, int attr, int hline, char *prog)
{
    Word *w;

    assert(/*addrules args*/ head && body);

    <<[[addrules()]] set [[target1]]>>
    for(w = head; w; w = w->next)
        addrule(w->s, tail, body, head, attr, hline, prog);
}
@
% can have multiple target, so go through all of them
\t head -> targets!! tail -> prereqs

<<[[addrule()]] set more fields>>=
r->alltargets = ahead;
@
\t rename ahead -> alltargets


%\subsubsection{Extracting the first target}
%target1

\section{Graph}

% Rule and metarules are general static descriptions, patterns.
% Node and Arc are concrete instantiation with existing files.
% the actual graph of dependencies! nodes are target names usually filenames
% arcs link nodes to other filenames with a rule attached to know what to do

% it's really more a DAG than a graph; there should be no cycle
% (see cycle check section)

% FIGURE? where see deps go downward. prereqs.
% tgt vs pre. parent vs child. src vs dest.

\subsection{[[Node]]}

<<struct Node>>=
struct Node
{
    // ref_own<string>, usually a filename, or a virtual target like 'clean'
    char*		name; 
    // option<Time> (None = 0, for nonexistent files and virtual targets)
    ulong		time; // last mtime of file 
    // bitset<enum<Node_flag>>
    ushort		flags;

    <<[[Node]] arcs field>>

    // Extra
    <<[[Node]] extra fields>>
};
@
% the flags is often an inline of the union of the flags of the
% rules linking to the prerequistes nodes
\l name can also maybe be an archive member? like lib.a(foo.o) ?

%ctor. dtor = ?
% main -> mk -> graph -> applyrules -> <>
<<constructor newnode>>=
static Node*
newnode(char *name)
{
    Node *node;

    node = (Node *)Malloc(sizeof(Node));
    <<[[newnode()]] update node cache>>

    node->name = name;

    // call to timeof()! 
    node->time = timeof(name, false);

    <<[[newnode()]] set flags of node>>

    node->prereqs = nil;
    node->next = nil;
    <<[[newnode()]] debug>>
    return node;
}
@
% owning name after call! => call strdup in caller

% pass false, cos ok to use cache. nothing has been generated so nothing
%  can have invalidate the cache.
\t rename false to USE_CACHE_IS_OK, vs FORCE_READ_NO_CACHE

<<enum Node_flag>>=
enum Node_flag {
    <<[[Node_flag]] cases>>
};
@
% used to be a set of #define

%chunks: will see gradually. Mostly used during analysis of graph.

% maybe put here MADE BEINGMADE etc. so make sense
% to have link to set of Nodes in Job

\subsection{[[Arc]]}

<<[[Node]] arcs field>>=
// list<ref_own<Arc>> (next = Arc.next)
Arc		*prereqs;
@
\t actually would be better to call it arcs, because 
\l not always a prereq as for instance virtual rule have an arc
\l from the target without any destination node


<<struct Arc>>=
struct Arc
{
    // option<ref<Node>>, the other node in the arc (the dependency)
    struct Node *n;
    // ref<Rule>, to gen the target node from the dependent node
    Rule *r;

    <<[[Arc]] other fields>>
    
    //Extra
    <<[[Arc]] extra fields>>
};
@
% option Node? apparently some code is doing if(a->n) so ...
%  have some fake arc for virtual targets and need arc to carry the rule
%  (which contains the recipe)
% option Rule? I dont think so, every call to newarc have a defined rule arg
%ocaml: I think you just need the recipe and some flags of the rule.

% seen Rule before.

<<[[Arc]] extra fields>>=
// list<ref_own<arc> (head = Node.prereqs)
struct Arc	*next;
@



% node   arc   rule   relations?

% so can set $stem for the actual value for the recipe to run
<<[[Arc]] other fields>>=
// option<ref_own<string>>, what will replace the %
char		*stem;
@
% why need that? Node.name is not expanded already?
%  yes, in graph, but in recipe still need to set dollar stem in env
% here not in Rule because Rule is generic template; Here it is instantiated.
% Also used because in dorecipe we also use alltargets, which is not
%  expanded.
%ocaml: do a rule_exec containing all necessary information

% ctor.  dtor = ?
% main -> mk -> graph -> applyrules -> <>
<<constructor newarc>>=
Arc*
newarc(Node *n, Rule *r, char *stem, Resub *match)
{
    Arc *a;

    a = (Arc *)Malloc(sizeof(Arc));
    a->n = n;
    a->r = r;
    a->stem = strdup(stem);

    a->next = nil;
    a->flag = 0;
    <<[[newarc()]] set other fields>>
    return a;
}
@
\l assert r ? (but not assert n)




\section{[[Job]] and [[jobs]]}

% final piece.
% reference rule, node (so Arc) (and Word but less important)

<<struct Job>>=
struct Job
{
    // ref<Rule>
    Rule		*r;	/* master rule for job */

    // list<ref<Node>> (next = Node.next)
    Node		*n;	/* list of node targets */

    // $target and $prereq
    Word		*t;	/* targets */
    Word		*p;	/* prerequisites */

    <<[[Job]] other fields>>

    // Extra
    <<[[Job]] extra fields>>
};
@
%ocaml: I think you just need the recipe and some flags of the rule.
%  also why need targets? info is already in node. To ease envupd?
\l why so short field names suddenly? avoid confusion with the one in Rule? meh

% have list of nodes because finishing a job will modify
% the graph! put some MADE

% targets! prerequisites! plural!

<<[[Job]] other fields>>=
char		*stem;
@
% stem again? propagated from Arc? to pass to shell for dollar stem setting
%ocaml: factorize in rule_exec

<<[[Node]] extra fields>>=
// list<ref<Node>> (head = Job.n)
struct Node	*next;		/* list for a rule */
@
% list of all targets for a job (with a master rule), as when done
%  will need to mark as done multiple files (and check they are there)
% usually have set of nodes via Arc, but here, no need target (parent) node.


% ctor
<<constructor newjob>>=
Job*
newjob(Rule *r, Node *nlist, char *stem, char **match, 
       Word *pre, Word *npre, 
       Word *targets, Word *atar)
{
    Job *j;

    j = (Job *)Malloc(sizeof(Job));
    j->r = r;
    j->n = nlist;
    j->p = pre;
    j->t = targets;

    j->stem = stem;
    j->match = match;

    j->np = npre;
    j->at = atar;

    j->next = nil;
    return j;
}
@
%old: tar -> targets
\t rename fields, aspectize setting certain fields

<<global jobs>>=
// list<ref_won<jobs>> (next = Job.next)
Job *jobs;
@
% here cos used by mk(). Cant delayed. 
\t actually aspectized now, so maybe could delay? or maybe useful
\t  to know there is a list of jobs
%ocaml: not sure you need a global, can be a local in run.ml?
% also use a Queue

<<[[Job]] extra fields>>=
struct Job	*next;
@









\chapter{[[main()]]}

\ifallcode
<<[[main()]] locals>>=
Word *w;
char *s;
int i;
@
\fi
\t distribute

<<function main>>=
void
main(int argc, char **argv)
{
    <<[[main()]] locals>>

    // Initializing

    <<[[main()]] initializations>>

    // Parsing

    <<[[main()]] parsing mkfile, call [[parse()]]>>

    // Building

    <<[[main()]] initializations before building>>
    <<[[main()]] building the targets, call [[mk()]]>>

    // Reporting (optional)

    <<[[main()]] print profiling stats if uflag>>

    // Exiting

    exits(nil);
}
@




<<global bout>>=
Biobuf bout;
@
% use of libbio quite a lot. Buffered IO module. For output and input.
%  compared to scanf/printf? 
% used in mk for printing on stdout. No big win vs printf I think.
%  actually use fprintf(STDERR,) for other stuff
%ocaml: stdlib already buffer output

<<[[main()]] initializations>>=
Binit(&bout, STDOUT, OWRITE);
<<[[main()]] argv processing part 1, -xxx>>
<<[[main()]] setup profiling>>
syminit();
initenv();
<<[[main()]] argv processing part 2, xxx=yyy>>
<<[[main()]] set variables for recursive mk>>
<<[[main()]] argv processing part 3, skip xxx=yyy>>
<<[[main()]] profile initializations>>
@
%old: 
% - the processing part 3 was before catchnotes() before but I think better here
% - calls to second usage was earlier


%/*
% *  start with a copy of the current environment variables
% *  instead of sharing them
% */
\t for execinit?? for initenv/





\section{[[mk -xxx]] arguments processing}

% use for -f, or debug flags.

<<[[main()]] argv processing part 1, -xxx>>=
USED(argc);
for(argv++; *argv && (**argv == '-'); argv++)
{
    <<[[main()]] add [[argv[0]]] in [[buf]]>>

    switch(argv[0][1]) {
    <<[[main()]] -xxx switch cases>>
    default:
        badusage();
    }
}
@
%ocaml: use Arg module

%chunks:
% will see gradually -xxx

% note that modify argv!

\section{[[mk xxx=yyy]] arguments processing}

% mk CC=6c default => override

% done by writing variable in temporary file and reusing
%  machinery in parse()

<<[[main()]] locals>>=
char *temp = nil;
fdt tfd = -1;
Biobuf tb;
@

<<[[main()]] argv processing part 2, xxx=yyy>>=
/*
 *   assignment args become null strings
 */
for(i = 0; argv[i]; i++) 
  if(utfrune(argv[i], '=')){
    <<[[main()]] add [[argv[i]]] in [[buf]]>>

    <<[[main()]] create temporary file if not exist yet>>
    Bprint(&tb, "%s\n", argv[i]);
    *argv[i] = '\0';
  }

if(tfd >= 0){
    Bflush(&tb);
    seek(tfd, 0L, SEEK__START);
    parse("<command line args>", tfd, true);
    remove(temp);
}
@
% abuse parse(), pass true so will get varoverride to true
%  so those variables will be marked specially S_OVERRIDE
%old: seek() used to be LSEEK() a macro expanding ultimately to seek

% replace those argv by \0, used later.

<<[[main()]] create temporary file if not exist yet>>=
if(tfd < 0){
    temp = maketmp();
    if(temp == nil) {
        perror("temp file");
        Exit();
    }
    tfd = create(temp, ORDWR, 0600);
    if(tfd < 0){
        perror(temp);
        Exit();
    }
    Binit(&tb, tfd, OWRITE);
}
@
\l perror?

<<[[main()]] argv processing part 3, skip xxx=yyy>>=
/* skip assignment args */
while(*argv && (**argv == '\0'))
    argv++;
@
% but what if mix target and assignments? then will get an error?
\t test it  mk XX=1 default YY=2,  get good error message?

\section{Parsing the [[mkfile]] or [[mk -f]]{\em file}}

\t simplify code? remove multi -f, who needs that?

<<[[main()]] locals>>=
char *files[256];
char **f = files;
@
% can have more than one file? can use multiple -f, but meh.
%ocaml: one -f is enough

<<[[main()]] -xxx switch cases>>=
case 'f':
    if(*++argv == nil)
        badusage();
    *f++ = *argv;
    <<[[main()]] add [[argv[0]]] in [[buf]]>>
    break;
@
% saw -xxx processing before.

<<[[main()]] locals>>=
char **ff;
@

<<[[main()]] parsing mkfile, call [[parse()]]>>=
if(f == files){
    if(access(MKFILE, AREAD) == OK_0)
        parse(MKFILE, open(MKFILE, OREAD), false);
} else
    for(ff = files; ff < f; ff++)
        parse(*ff, open(*ff, OREAD), false);
<<[[main()]] if DEBUG(D_PARSE)>>
@
%old: use AREAD and OREAD instead of 4 and 0 argument
%bug? if mkfile not there, no error? it displays "mk: nothing to mk"
% because target will be empty

% will modify rules, metarules,


\section{Building the target(s)}

% parse(), so modified globals rules, metarules.
% just need to initiate with target passed as argument (or use default one)

<<[[main()]] building the targets, call [[mk()]]>>=
if(*argv == nil){
    <<[[main()]] when no target arguments>>
} else {
    <<[[main()]] if sequential mode and target arguments given>>
    else {
       <<[[main()]] parallel mode and target arguments given>>
    }
}
@

\subsection{Default target, [[target1]]}

<<global target1>>=
Word *target1;
@

% e.g. 'all, 
% should be initialized while parsing with the first rule added
\t should be a single word (but consistent to use Word), change to char*?
\l  or first rule can contain multiple targets


<<[[main()]] when no target arguments>>=
if(target1)
    for(w = target1; w; w = w->next)
        // The call!
        mk(w->s);
else {
    fprint(STDERR, "mk: nothing to mk\n");
    Exit();
}
@

% will see later that Exit is special, but here could be just exits I think.


\subsection{Sequential mode}

% sequential not parallel command line arguments
<<[[main()]] locals>>=
bool sflag = false;
@

<<[[main()]] -xxx switch cases>>=
case 's':
    sflag = true;
    break;
@

<<[[main()]] if sequential mode and target arguments given>>=
if(sflag){
    for(; *argv; argv++)
        if(**argv)
            mk(*argv);
}
@
% but actually for that target it will do things in parallel.
% (unless you put nproclimit to 1), so maybe not that useful.
\l put in advanced feature?

\subsection{Parallel mode}

<<[[main()]] parallel mode and target arguments given>>=
Word *head, *tail;
Word *t;

/* fake a new rule with all the args as prereqs */
tail = nil;
t = nil;
for(; *argv; argv++)
    if(**argv){
        // add_list(newword(*argv), t)
        if(tail == nil)
            tail = t = newword(*argv);
        else {
            t->next = newword(*argv);
            t = t->next;
        }
    }
if(tail->next == nil)
    // a single target argument
    mk(tail->s);
else {
    head = newword("<command line arguments>");
    addrules(head, tail, strdup(""), VIR, mkinline, nil);
    mk(head->s);
}
@
% could pass 0 instead of mkinline I think
% why not call addrule() directly? why addrules? because addrules set target1
\l confusing that tail is actually the head of the prereqs
\t tail -> prereqs, t -> eprereqs, head -> targets

% VIR for virtual because target does not exist, and so ok
%  if after recipe not there. Do not generate warning.
% mkinline, meh. could pass -1 or 0.




\chapter{Parsing [[mkfile]]s}
\l Parsing Rules and Variables

% parse() will modify rules, metarules (patrules), target1.
%ocaml: return those instead of modifying globals

% mk has a very particular way to parse. 
% Partly because mimimal-syntax.
% But maybe grew out with more escaping rules and in the end it's
% a bit complicated.
%real-world: unix make was actually using yacc.

%ocaml: cleaner to use Yacc? tricky too cos in recipe the tokens 
% have a different meaning => need a lexer with different states/modes 
% (a la Perl/PHP). Also escaping is tricky. Unicode also is tricky.

\section{[[parse()]]}

% error management:
<<global infile>>=
char *infile;
@

<<global mkinline>>=
int mkinline;
@
\t rename just inline? or lineno.

<<function SYNERR>>=
#define	SYNERR(l)	(fprint(STDERR, "mk: %s:%d: syntax error; ", \
                            infile, ((l)>=0)? (l) : mkinline))
@
% when call SYNERR with explicit line? when dont want default of using
% mkinline because error was actually before.
% note that useful to put mk: before, to indicate errors comes from mk,
%  not one of its subprocess (and there may be many)

% read fd, make input buffer, make string buffer, then get line and put in buf.
% use of libbio
% use of Bufblock, appendix X. =~ growing string (realloc)

<<function parse>>=
void
parse(char *f, fdt fd, bool varoverride)
{
    Biobuf in;
    Bufblock *buf;
    char c; // one of : = <
    Word *head, *tail;
    int hline; // head line number
    <<[[parse()]] other locals>>

    <<[[parse()]] sanity check fd>>
    <<[[parse()]] start, push>>

    // Init
    infile = strdup(f);
    mkinline = 1;
    Binit(&in, fd, OREAD);
    buf = newbuf();

    // Lexing
    while(assline(&in, buf)){
        hline = mkinline;

        // Parsing
        c = rhead(buf->start, &head, &tail,     &attr, &prog);

        // Semantic actions
        switch(c)
        {
        <<[[parse()]] switch rhead cases>>
        default:
            SYNERR(hline);
            fprint(STDERR, "expected one of :<=\n");
            Exit();
            break;
        }
    }
    close(fd);
    freebuf(buf);
    <<[[parse()]] end, pop>>
}
@
\l leak strdup for infile? when free?

% use Biobuf because will sometimes unget a character.

<<[[parse()]] sanity check fd>>=
if(fd < 0){
    perror(f);
    Exit();
}
@


<<[[parse()]] other locals>>=
// bitset<Rule_attr>
int attr;
@
% prog argument, will see later.

\subsection{Assembling a line, [[assline()]]}

% =~ lexing


% nice function name
<<function assline>>=
/*
 *	Assemble a line skipping blank lines, comments, and eliding
 *	escaped newlines
 */
bool
assline(Biobuf *bp, Bufblock *buf)
{
    int c;
    <<[[assline()]] other locals>>

    // reset buf
    buf->current = buf->start;

    while ((c = nextrune(bp, true)) >= 0){
        switch(c)
        {
        case '\n':
            if (buf->current != buf->start) {
                insert(buf, '\0');
                return true;
            }
            break;		/* skip empty lines */
        <<[[assline()]] switch character cases>>
        default:
            rinsert(buf, c);
            break;
        }
    }
eof:
    insert(buf, '\0');
    return *buf->start != '\0';
}
@
% rinsert until newline
\l int -> Rune?
\t have resetbuf() function and emptybuf() function? and bufcontent()?
%ocaml: use Buffer too

% return false when EOF after line parsed

% pass true to nextrune so elide

%ocaml-found:
% skip only empty lines
% if have line with only spaces, it generate an error because not one of :=<




\subsubsection{Escaped newline, [[nextrune()]]}

% When need to support this escape newline feature? 
% Yes, when setting variables containing lots of elements,
% for instance OBJS.
%alt: have syntax for lists, with terminator different than newline,
%  for instance ']' in ocaml
% space and newlines have meaning (TAB used to have one too, consistent,
%  but in the end ugly because dont see diff in editor and can do without)


<<function nextrune>>=
/*
 *	get next character stripping escaped newlines
 *	the flag specifies whether escaped newlines are to be elided or
 *	replaced with a blank.
 */
int
nextrune(Biobuf *bp, bool elide)
{
    int c;

    for (;;) {
        c = Bgetrune(bp);
        if (c == '\\') {
            if (Bgetrune(bp) == '\n') {
                mkinline++;
                if (elide)
                    continue;
                // else
                return ' ';
            }
            Bungetrune(bp);
        }
        if (c == '\n')
            mkinline++;
        return c;
    }
}
@
\l int -> Rune?? also in bio.h?
\t when do you not elide? for escapetoken() and bquote()

% Bgetrune comes from bio.h, buffered IO library (libbio).




\subsubsection{Comments}

<<[[assline()]] other locals>>=
int lastc;
@
% to handle escaped newline after comment, meh

<<[[assline()]] switch character cases>>=
case '#':
    lastc = '#';
    // skil all characters in comment until newline
    while ((c = Bgetc(bp)) != '\n') {
        if (c < 0)
            goto eof;
        if(c != '\r')
            lastc = c;
    }
    mkinline++;
    if (lastc == '\\')
        break;		/* propagate escaped newlines??*/

   // like '\n' case 
   if (buf->current != buf->start) {
        insert(buf, '\0');
        return true;
    }
    // skip lines with only a comment
    break;
@
\t \r ? for windows? so simplify and just unguard the lastc = c
\t rename lastc to prevc

% lastc is to handle escaped newline after comment.
% so A=foo # this is a long thing\
%      bar 
% will be parsed as a single line A=foo bar

% convenient for
% X=foo\
%  bar\
%  #notthisone\
%  foobar
% ...

% when buf is not empty? when had stuff before the # ? in which case
%  do the same thing as if it was a single newline

\subsubsection{Quoted characters}
% part 1

% some filenames can contain weird characters, like #, :, =.

% when input a line which contains a quote or backquote,
% then # inside has a different meaning; it is not a comment
% anymore, so it needs special processing.

% escaped newline also has a different meaning, it is then a space.

% same way, we can quote : < =, which are lexical elements of mk.
% without quoting syntax, there is no way to have target (filenames)
% containing :, #, =, etc.


<<[[assline()]] switch character cases>>=
case '\\':
case '\'':
case '"':
    rinsert(buf, c);
    if (escapetoken(bp, buf, true, c) == ERROR_0)
        Exit();
    break;
@
\t why process that? 
\t seems like only second one handled, so maybe can remove cases?
% to allow other shells to manage those things.

% escapetoken keep the quote when preserve is true

% rc.c
<<function escapetoken>>=
/*
 *	Input an escaped token.  Possible escape chars are single-quote,
 *	double-quote and backslash.  Only the first is a valid escape for
 *	rc; the others are just inserted into the receiving buffer.
 */
error0
escapetoken(Biobuf *bp, Bufblock *buf, bool preserve, int esc)
{
    int c;
    int line;

    if(esc != '\'')
        return OK_1;

    line = mkinline;
    while((c = nextrune(bp, false)) > 0){
        if(c == '\''){
            if(preserve)
                rinsert(buf, c);

            c = Bgetrune(bp);
            if (c < 0)
                break;
            if(c != '\''){
                Bungetrune(bp);
                return OK_1;
            }
        }
        rinsert(buf, c);
    }
    // reached EOF
    SYNERR(line); 
    fprint(STDERR, "missing closing %c\n", esc);
    return ERROR_0;
}
@

\l does it handle escape of ' itself?
\l  I guess if double '' ? hence the extra read?

% pass false this time to nextrune, so transform escaped newline in space

% use nextrune so handle escaped newline also in quoted string


\subsection{Parsing the head of a line, [[rhead()]]}

% =~ parsing

% <, =, :

% rhead for rule head, or maybe read head because used not only for rule.

% line is buf->start, but with special \0 mark in the middle so know
%  what we need to read.

\l int -> Rune for return?
<<function rhead>>=
static int
rhead(char *line, Word **h, Word **t,    int *attr, char **prog)
{
    char *p;
    int sep; // one of : = < 
    Word *w;
    <<[[rhead()]] other locals>>

    p = charin(line, ":=<");
    if(p == nil)
        return '?';

    sep = *p;
    *p++ = '\0';
    <<[[rhead()]] adjust sep if dynamic mkfile [[<|]]>>
    <<[[rhead()]] adjust [[attr]] and [[prog]]>>

    // potentially expand variables in head
    *h = w = stow(line);
    <<[[rhead()]] sanity check w>>

    // potentially expand variables in tail
    *t = stow(p);

    return sep;
}
@
\t why need intermediate w? just sanity check *h ?

% FIGURE where before long string,
% then string split in 2 because of \0 put at place of special char

% charin later, complex actually, handle special syntax in head which could
%  contain inside a :=<


% except <, should have a head (var or target)

<<[[rhead()]] sanity check w>>=
if(*w->s == '\0' && sep != '<' && sep != '|') {
    SYNERR(mkinline-1);
    fprint(STDERR, "no var/target on left side of assignment/rule\n");
    Exit();
}
@
%pad: I added the /target in error message




<<[[rhead()]] adjust [[attr]] and [[prog]]>>=
*attr = 0; // Nothing
*prog = nil;
// variable attributes
<<[[rhead()]] if sep is [[=]]>>
// rule attributes
<<[[rhead()]] if sep is [[:]]>>
@

\subsubsection{Skipping quotes and variables, [[charin()]]}
% part 2

% redo a bit some of the lexing work done in assline, sad.
%ocaml: use lex so work done only once? or forbid certain elements
% in filenames? meh, bad practice

% addrule | rhead -> <>
<<function charin>>=
/*
 *	search a string for characters in a pattern set
 *	characters in quotes and variable generators are escaped
 */
char*
charin(char *cp, char *pat)
{
    Rune r;
    int n;
    bool vargen = false;

    while(*cp){
        n = chartorune(&r, cp);
        switch(r){
        <<[[charin()]] switch rune cases>>
        default:
            if(!vargen && utfrune(pat, r))
                return cp;
            break;
        }
        cp += n;
    }
    <<[[charin()]] sanity check vargen>>
    return nil;
}
@
%$
\t rename vargen to  in_variable_token
% unicode stuff makes the code hard to read. Regexps or lex are 
% so much cleaner.


\subsubsection{Quoted characters}
% part 2

<<[[charin()]] switch rune cases>>=
case '\'':			/* skip quoted string */
    cp = squote(cp+1);	/* n must = 1 */
    if(!cp)
        return nil;
    break;
@

% charin -> <>
<<function squote>>=
/*
 *	skip a token in single quotes.
 */
static char *
squote(char *cp)
{
    Rune r;
    int n;

    while(*cp){
        n = chartorune(&r, cp);
        if(r == '\'') {
            n += chartorune(&r, cp+n);
            if(r != '\'')
                return cp;
        }
        cp += n;
    }
    SYNERR(-1);		/* should never occur */
    fprint(STDERR, "missing closing '\n");
    return nil;
}
@

% second chartorune is to handle ''' I think.

% simpler that escapetoken because no need to update mkinline, or
% to modify a buffer. We just need to skip it.

% should never occur because escapetoken already handles the case


\subsubsection{Variables}

% variables can contain ':' so need special handling here.
% Didnt do that in assline because variables dont influence the
% semantic of # or newline.

<<[[charin()]] switch rune cases>>=
case '$':
    if(*(cp+1) == '{')
        vargen = true;
    break;
case '}':
    if(vargen)
        vargen = false;
    else
       // same as default: case
       if(utfrune(pat, r))
          return cp;
    break;
@
%$
\l could goto default:

%ocaml-found:
% note that in ${name} name must also be simple, but need that
% so can contatenate a variable name with a letter, as in ${name}ici
% otherwise ambiguity with $nameici, and dont want put a space because
% space have a meaning.
%real-world: not a pb in make since impose $(xxx) format for every variables.

%rc deals with that with ^ so can do in a recipe $stem1^l to get
% 5l, 8l, etc.


<<[[charin()]] sanity check vargen>>=
if(vargen){
    SYNERR(-1);
    fprint(STDERR, "missing closing } in pattern generator\n");
}
@
% pattern, meh

\subsection{Splitting a string in words, [[stow()]]}

% so used for target, prereqs, but also varname, var defs.

% will expand not just variable set in mkfile but also
% plan9 variables, because of [[readenv()]] at the beginning
% of mk.

% note also that do not expand in recipe! this is done
% by shell, and so it allows late binding of variables, use
% before define, etc.

% string to word
<<function stow>>=
Word *
stow(char *s)
{
    Word *head, *w, *new;

    w = head = nil;
    while(*s){
        new = nextword(&s);
        if(new == nil)
            break;

        // concat_list(new, head, w)
        if (w)
            w->next = new;
        else
            head = w = new;
        while(w->next)
            w = w->next;
        
    }
    if (!head)
        head = newword("");
    return head;
}
@
% new can already contain multiple words!
\t rename w to last?
\t rename newword -> new_singleword
\t rename nextword to nextwords?
%ocaml: expanding is done later in eval.ml instead, but 
% the splitting is done at lexing/parsing time.

\subsubsection{Expanding quotes, backquotes, and variables, [[nextword()]]}

% again :)

% indeed, separator marker is space or tab, but what if filename
% with space or tab? deal with putting the filename between ''
% but then splitting need to handle this special character!

% stow -> <>
<<function nextword>>=
/*
 *	break out a word from a string handling quotes, executions,
 *	and variable expansions.
 */
static Word*
nextword(char **s)
{
    char *cp;
    Bufblock *b;
    Word *head, *tail;
    Rune r;
    bool empty;
    <<[[nextword()]] other locals>>

    cp = *s;
    b = newbuf();

restart:
    head = tail = nil;
    while(*cp == ' ' || *cp == '\t')		/* leading white space */
        cp++;
    empty = true;

    while(*cp){
        cp += chartorune(&r, cp);
        switch(r)
        {
        case ' ':
        case '\t':
        case '\n':
            goto out;
        <<[[nextword()]] switch rune cases>>
        default:
            empty = false;
            rinsert(b, r);
            break;
        }
    }
out:
    *s = cp;
    if(b->current != b->start){
        if(head){
            cp = b->current;
            bufcpy(b, tail->s, strlen(tail->s));
            bufcpy(b, b->start, cp - b->start);
            insert(b, '\0');
            free(tail->s);
            tail->s = strdup(cp);
        } else {
            insert(b, '\0');
            head = newword(b->start);
        }
    }
    freebuf(b);
    return head;
}
@
%$
\t mv nextword out of word.c
\t rename b to buf

% so here will handle leading and trailing whitespaces
% so X = yy vv   will be parsed as X=yy vv

% restart because once expanded a backquote, then reprocess

%chunks: will see advanced variables and advanced words gradually

\subsubsection{Quoted characters}
% part 3

<<[[nextword()]] switch rune cases>>=
case '\\':
case '\'':
case '"':
    empty = false;
    cp = expandquote(cp, r, b);
    if(cp == nil){
        fprint(STDERR, "missing closing quote: %s\n", *s);
        Exit();
    }
    break;
@
\l but missing closing quote should never happen
% this time they are removed

% by expand it means remove quote arounds

<<function expandquote>>=
/*
 *	extract an escaped token.  Possible escape chars are single-quote,
 *	double-quote,and backslash.  Only the first is valid for rc. the
 *	others are just inserted into the receiving buffer.
 */
char*
expandquote(char *s, Rune r, Bufblock *b)
{
    if (r != '\'') {
        rinsert(b, r);
        return s;
    }

    while(*s){
        s += chartorune(&r, s);
        if(r == '\'') {
            if(*s == '\'')
                s++;
            else
                return s;
        }
        rinsert(b, r);
    }
    return nil;
}
@
% diff with escapetoken? input an escaped token vs extract?

\l '' to handle escaping of ' itself? but then handled by

\subsubsection{Expanding variables in words (part 1)}

% in rules target, prerequisites, in variable uses.
% but not recipe!

<<[[nextword()]] other locals>>=
Word *w;
@

<<[[nextword()]] switch rune cases>>=
case '$':
    w = varsub(&cp);
    if(w == nil){
        if(empty)
            goto restart;
        break;
    }
    empty = false;
    if(b->current != b->start){
        bufcpy(b, w->s, strlen(w->s));
        insert(b, '\0');
        free(w->s);
        w->s = strdup(b->start);
        b->current = b->start;
    }
    if(head){
        bufcpy(b, tail->s, strlen(tail->s));
        bufcpy(b, w->s, strlen(w->s));
        insert(b, '\0');
        free(tail->s);
        tail->s = strdup(b->start);
        tail->next = w->next;
        free(w->s);
        free(w);
        b->current = b->start;
    } else
        tail = head = w;

    while(tail->next)
        tail = tail->next;
    break;
@
%$

% done at parsing time for the non recipe part (target and prerequisites).



% not just $V, can have complex pattern there too.
% sometimes ${xx:%.y=%.z} ! but later in adv topics

% nextword -> <>
<<function varsub>>=
Word*
varsub(char **s)
{
    Bufblock *b;
    Word *w;

    <<[[varsub()]] if variable starts with open brace>>
    // else

    b = varname(s);
    if(b == nil)
        return nil;

    w = varmatch(b->start);

    freebuf(b);
    return w;
}
@
% yes! ${x:%=%}


%\subsection{Simple variables, }
%$

<<function varname>>=
/*
 *	extract a variable name
 */
static Bufblock*
varname(char **s)
{
    Bufblock *b;
    char *cp;
    Rune r;
    int n;

    b = newbuf();
    cp = *s;
    for(;;){
        n = chartorune(&r, cp);
        if (!WORDCHR(r))
            break;
        rinsert(b, r);
        cp += n;
    }
    <<[[varname()]] sanity check b>>
    *s = cp;
    insert(b, '\0');
    return b;
}
@

% what constitutes a variable name, anything except special chars
%  maybe specific to shell too?
<<function WORDCHR>>=
#define WORDCHR(r)	((r) > ' ' && !utfrune("!\"#$%&'()*+,-./:;<=>?@[\\]^`{|}~", (r)))
@
%$


<<[[varname()]] sanity check b>>=
if (b->current == b->start){
    SYNERR(-1);
    fprint(STDERR, "missing variable name <%s>\n", *s);
    freebuf(b);
    return nil;
}
@




<<function varmatch>>=
static Word*
varmatch(char *name)
{
    Word *w;
    Symtab *sym;
    
    sym = symlook(name, S_VAR, nil);
    if(sym){
            /* check for at least one non-NULL value */
        for (w = sym->u.ptr; w; w = w->next)
            if(w->s && *w->s)
                return wdup(w);
    }
    return nil;
}
@




\t could put the code for dollar{name} here, important escaping mechanism

% will see backquote later too


\section{Rules, {\em target}[[:]]{\em prereqs}}
% actually targets : prereqs

%trans:
% seen main lexing/parsing/splitting.
% Now special parsing code for different constructs.


<<[[parse()]] other locals>>=
char *body;
@
<<[[parse()]] switch rhead cases>>=
case ':':
    body = rbody(&in);
    addrules(head, tail, body, attr, hline, prog);
    break;
@
\t mv hline at the very end

% can have multiple targets! hence addrules below, not addrule.

% put before?
<<[[addrules()]] set [[target1]]>>=
/* tuck away first non-meta rule as default target*/
if(target1 == nil && !(attr&REGEXP)){
    for(w = head; w; w = w->next)
        if(charin(w->s, "%&"))
            break;
    if(w == nil)
        target1 = wdup(head);
}
@
% why not also attr&META?


\subsection{Parsing the recipe, [[rbody()]]}

% Not infamous TAB!

% rule body
<<function rbody>>=
static char *
rbody(Biobuf *in)
{
    Bufblock *buf;
    int r, lastr;
    char *p;

    lastr = '\n';
    buf = newbuf();

    for(;;){
        r = Bgetrune(in);
        if (r < 0)
            break;
        if (lastr == '\n') {
            if (r == '#')
                rinsert(buf, r); // the shell recognize comments too
            else if (r != ' ' && r != '\t') {
                Bungetrune(in);
                break;
            }
        } else
            rinsert(buf, r);

        lastr = r;
        if (r == '\n')
            mkinline++;
    }

    insert(buf, '\0');
    p = strdup(buf->start);
    freebuf(buf);

    return p;
}
@
% so body/recipe always contains at least empty string.

% handle multi lines shell commands, as long as have leading space or tab
%  after last newline
% handle 

% note that no call to  stow() here! no variable expansion


\subsection{Parsing rule attributes}

<<[[rhead()]] other locals>>=
Rune r;
int n;
@

% if not space or tab after :, then must be an attribute!

<<[[rhead()]] if sep is [[:]]>>=
if((sep == ':') && *p && (*p != ' ') && (*p != '\t')){
    while (*p) {
        n = chartorune(&r, p);
        if (r == ':')
            break;
        p += n;
        switch(r)
        {
        <<[[rhead()]] when parsing rule attributes, switch rune cases>>
        default:
            SYNERR(-1);
            fprint(STDERR, "unknown attribute '%c'\n", p[-1]);
            Exit();
        }
    }
    if (*p++ != ':') {
eos:
        SYNERR(-1);
        fprint(STDERR, "missing trailing :\n");
        Exit();
    }
}
@
%old: switch cases originally sorted alphabetically, but after
% LP distribution, they might not be anymore

%chunks: will see them gradually

\section{Included files, [[<]]{\em file}}

<<[[parse()]] other locals>>=
fdt newfd;
char *p;
@

<<[[parse()]] switch rhead cases>>=
case '<':
    p = wtos(tail, ' ');
    <<[[parse()]] when parsing included file, sanity check p>>
    newfd = open(p, OREAD);
    <<[[parse()]] when parsing included file, sanity check newfd>>
    else
        // recurse
        parse(p, newfd, false);
    break;
@
% parsed by rhead, so got variable expansion there too! < $arch.mk 

% handle filename with spaces now ... no need escaping
%ocaml: be more consistent and stricter

% recurse but use globals infile, mkinline, so
% to save and restore them.

<<[[parse()]] start, push>>=
ipush();
@

<<[[parse()]] end, pop>>=
ipop();
@
%ocaml: do that in eval, and use call stack to handle recursivity

<<struct input>>=
struct Input
{
    char *file;
    int line;

    // Extra
    struct Input *next;
};
@

<<global inputs>>=
static struct Input *inputs = nil;
@

% can process many files, because of the </sys/src/... 

<<function ipush>>=
void
ipush(void)
{
    struct Input *in, *me;

    me = (struct Input *)Malloc(sizeof(*me));
    me->file = infile;
    me->line = mkinline;
    me->next = nil;

    // add_list(me, inputs)
    if(inputs == nil)
        inputs = me;
    else {
        for(in = inputs; in->next; )
            in = in->next;
        in->next = me;
    }
}
@

<<function ipop>>=
void
ipop(void)
{
    struct Input *in, *me;

    assert(/*pop input list*/ inputs != 0);
    // me = pop_list(inputs)
    if(inputs->next == nil){
        me = inputs;
        inputs = nil;
    } else {
        for(in = inputs; in->next->next; )
            in = in->next;
        me = in->next;
        in->next = nil;
    }
    infile = me->file;
    mkinline = me->line;
    free((char *)me);
}
@



<<[[parse()]] when parsing included file, sanity check p>>=
if(*p == '\0'){
    SYNERR(-1);
    fprint(STDERR, "missing include file name\n");
    Exit();
}
@
<<[[parse()]] when parsing included file, sanity check newfd>>=
if(newfd < 0){
    fprint(STDERR, "warning: skipping missing include file: ");
    perror(p);
}
@

\section{Variable definitions, {\em C}[[=]]{\em words}}
% really Constant definitions, not variable.
\n ninja calls them bindings


<<[[parse()]] other locals>>=
bool set = true;
@
%old: not set initially, but clearer that way

<<[[parse()]] switch rhead cases>>=
case '=':
    <<[[parse()]] when parsing variable definitions, sanity check head>>
    <<[[parse()]] when parsing variable definitions, override handling>>
    if(set){
        setvar(head->s, (void *) tail);
        <<[[parse()]] when parsing variable definitions, extra setting>>
    }
    <<[[parse()]] when parsing variable definitions, if variable with attr>>
    break;
@
%dead: was already commented in the original code
%    /*
%    char *cp;
%    dumpw("tail", tail);
%    cp = wtos(tail, ' '); print("assign %s to %s\n", head->s, cp); free(cp);
%    */


<<[[parse()]] when parsing variable definitions, sanity check head>>=
if(head->next){
    SYNERR(-1);
    fprint(STDERR, "multiple vars on left side of assignment\n");
    Exit();
}
@

%ocaml-found:
% note that calls wtos() on head before, so can have vars in head!
% can do crazy stuff like
% A=B
% $A=42
% and now B is 42! pointers :) 

\subsection{Overriding variable definitions}

% saw calling parse with true for override for the xxx=yyy argument parsing.

<<[[parse()]] when parsing variable definitions, override handling>>=
if(symlook(head->s, S_OVERRIDE, nil)){
    set = varoverride;
} else {
    set = true;
    if(varoverride)
        symlook(head->s, S_OVERRIDE, (void *)"");
}
@
\t could simplify maybe, if there, then set set=false; clearer.
\t also generate warning when set again same var? 
\t mk allows it? value is used until next def since evaluate vars as we parse.

<<[[Sxxx]] cases>>=
S_OVERRIDE,	/* can't override */
@
% when do mk xxx=yyy, it's overriding! and it's ok.



\subsection{Parsing variable attributes}

% rc.c
<<global termchars>>=
char	*termchars = "'= \t";	/*used in parse.c to isolate assignment attribute*/
@
% what we really want is to find first =, but if there is
% a quote before, then the = should not be interpreted as the = before
% attribute.

<<[[rhead()]] if sep is [[=]]>>=
if(sep == '='){
    pp = charin(p, termchars);	/* termchars is shell-dependent */
    if (pp && *pp == '=') {
        while (p != pp) {
            n = chartorune(&r, p);
            switch(r)
            {
            <<[[rhead()]] when parsing variable attributes, switch rune cases>>
            default:
                SYNERR(-1);
                fprint(STDERR, "unknown attribute '%c'\n",*p);
                Exit();
            }
            p += n;
        }
        p++;		/* skip trailing '=' */
    }
}
@
% can chain? X=V=foo ? or it is more C=U=bla




%\section{Variable uses (expanding variables part 2), [[$]]{\em C} }
%$




\chapter{Building the Dependency Graph}

% Will see [[mk()]] later. But will call [[graph(target)]]
% which goes down building tree using [[rules]] and [[metarules]].

\section{[[graph()]] and [[applyrules()]]}

% mk -> <>
<<function graph>>=
Node*
graph(char *target)
{
    Node *root;
    <<[[graph()]] other locals>>

    <<[[graph()]] set cnt for infinite rule detection>>
    root = applyrules(target, cnt);
    <<[[graph()]] free cnt>>

    <<[[graph()]] checking the graph>>

    // propagate attributes in rules to their node
    attribute(root);

    return root;
}
@
%pad: node -> root, clearer I think

% need attribute? anyway can access rule of node each time
% or probably because it is a union of attr for all matching rules.
%  not just the master rule.
% But in which situation it matters? for Virtual! because timeof
% may have been wrong and considered a file with the same name of
% a target. When we find out it is a virtual node, we need to reset
% the time of this node.



<<function applyrules>>=
static Node*
applyrules(char *target, char *cnt)
{
    Node *node;
    Arc head;
    Arc *a = &head;
    <<[[applyrules]] other locals>>

    <<[[applyrules]] debug>>
    <<[[applyrules]] check node cache if target is already there>>
    // else

    target = strdup(target);
    // calls timeof()
    node = newnode(target);

    head.n = nil;
    head.next = nil;

    <<[[applyrules]] set rmatch>>

    // apply regular rules with target as a head (modify node, head, a)
    <<[[applyrules()]] apply regular rules>>

    // apply meta rules
    <<[[applyrules()]] apply meta rules>>

    // ???
    a->next = node->prereqs;
    node->prereqs = head.next;

    return node;
}
@
\t node->prereqs should be nil no? assert?
\t confusing again to use head, this time for head of arcs.

% call to newnode() which will call timeof()!

%old: in comment in the original code!
%/*		if(r->attr&VIR)
% *			node->flags |= VIRTUAL;
% *		if(r->attr&NOREC)
% *			node->flags |= NORECIPE;
% *		if(r->attr&DEL)
% *			node->flags |= DELETE;
% */
% now done in attribute() anyway.


\section{Finding the simple rules for a target}

% built index while parsing in hash

<<[[applyrules]] other locals>>=
Symtab *sym;
Rule *r;
Word *w;
@
% rename w to prerequiste?

<<[[applyrules()]] apply regular rules>>=
sym = symlook(target, S_TARGET, nil);
for(r = (sym? sym->u.ptr : nil); r; r = r->chain){
    <<[[applyrules()]] skip this rule and continue if some conditions>>
    <<[[applyrules()]] infinite rule detection part1>>
    <<[[applyrules()]] when found a regular rule for target [[node]], set flags>>
    <<[[applyrules()]] if no prerequistes in rule r>>
    else
        for(w = r->tail; w; w = w->next){
            // recursive call!
            a->next = newarc(applyrules(w->s, cnt), r, "", rmatch);
            a = a->next;
    }
    <<[[applyrules()]] infinite rule detection part2>>
    head.n = node;
}
@
\t what is the point of setting head.n? it is not used anyway, and
\t  similar to node

% so for each prereq there is an arc! (but all of those arcs
% will share the same rule/recipe)

<<[[applyrules()]] skip this rule and continue if some conditions>>=
if(r->attr&META) continue;
if(strcmp(target, r->target)) continue; // how can happen??
if((!r->recipe || !*r->recipe)
   && (!r->tail || !r->tail->s || !*r->tail->s)) 
      continue;	/* no effect; ignore */
@
%TODO safe to continue when no recipe? should still have an arc
% so than can check if outofdate no?
\t how can be META and in S_TARGET?
\t ugly those chain of test on tail. Should assert always has a tail?
\t  or should forbid singleton empty word.
\t  maybe define  empty_prereqs() ? and empty_recipe() !!!
\t but no need !r->recipe, every rule has recipe (which can be empty)
\t  so do assert in empty_recipe()

% empty recipe and empty prereqs is useless, but tools like ocamldep
% generates such dependencies

<<[[applyrules()]] if no prerequistes in rule r>>=
// no prerequistes, a leaf, still create fake arc
if(!r->tail || !r->tail->s || !*r->tail->s) {
    a->next = newarc((Node *)nil, r, "", rmatch);
    a = a->next;
} 
@
% example: clean:, there will be no prereqs
% stem is "" here

% why need that? to at least have something propagate in attribute()?
%  so will pass the VIRT to the node?
% because there is a rule attached here!! a recipe for virtual targets.


\section{Finding matching metarules and substituting the stem}

<<[[applyrules]] other locals>>=
char buf[NAMEBLOCK];
char stem[NAMEBLOCK];
@

<<constant NAMEBLOCK>>=
#define	NAMEBLOCK	1000
@


% this time, do not use S_TARGET hash, go through all metarules
% and check if pattern can match target.

<<[[applyrules()]] apply meta rules>>=
for(r = metarules; r; r = r->next){
    <<[[applyrules()]] skip this meta rule and continue if some conditions>>
    <<[[applyrules()]] if regexp rule then continue if some conditions>>
    else {
        if(!match(node->name, r->target, stem)) continue;
    }
    <<[[applyrules()]] infinite rule detection part1>>

    <<[[applyrules()]] if no prerequistes in meta rule r>>
    else
        for(w = r->tail; w; w = w->next){
            <<[[applyrules()]] if regexp rule, adjust buf and rmatch>>
            else
                subst(stem, w->s, buf, sizeof(buf));
            // recursive call!
            a->next = newarc(applyrules(buf, cnt), r, stem, rmatch);
            a = a->next;
        }
    <<[[applyrules()]] infinite rule detection part2>>
}
@

<<[[applyrules()]] skip this meta rule and continue if some conditions>>=
if((!r->recipe || !*r->recipe) 
   && (!r->tail || !r->tail->s || !*r->tail->s)) 
    continue;	/* no effect; ignore */
@
\t useless !r->recipe, can assert instead
% could issue a warning, but some tools generate such dependencies with
%  no recipe and no prereqs
\l could factorize with previous one

<<[[applyrules()]] if no prerequistes in meta rule r>>=
if(!r->tail || !r->tail->s || !*r->tail->s) {
    a->next = newarc((Node *)nil, r, stem, rmatch);
    a = a->next;
} 
@
% almost identical to before, except pass stem here instead of ""
% (not sure it matters, maybe could factorize code)
\t use empty_prereqs() again

\subsection{Matching, [[match()]]}

% go through template until percent, and progress at the same time on name.

% stem is OUT. pointer to array to modify.

<<function match>>=
bool
match(char *name, char *template,    char *stem)
{
    Rune r;
    int n;

    while(*name && *template){
        n = chartorune(&r, template);
        if (PERCENT(r))
            break;
        while (n--)
            if(*name++ != *template++)
                return false;
    }
    if(!PERCENT(*template))
        return false;

    // how many characters % is matching
    n = strlen(name) - strlen(template+1);

    if (n < 0)
        return false;
    if (strcmp(template+1, name+n))
        return false;

    strncpy(stem, name, n);
    stem[n] = '\0';

    <<[[match()]] if ampersand template>>

    return true;
}
@
% simple pattern, single % or &
\t introduce a len_after_percent_in_template?

<<[[match()]] if ampersand template>>=
if(*template == '&')
    return !charin(stem, "./");
@
\l adv topics?

\subsection{Substituting, [[subst()]]}

<<function subst>>=
void
subst(char *stem, char *template,   char *dest, int dlen)
{
    Rune r;
    char *s, *e;
    int n;

    e = dest + dlen - 1;
    while(*template){
        n = chartorune(&r, template);
        if (PERCENT(r)) {
            template += n;
            for (s = stem; *s; s++)
                if(dest < e)
                    *dest++ = *s;
        } else
            while (n--){
                if(dest < e)
                    *dest++ = *template;
                template++;
            }
    }
    *dest = '\0';
}
@


\section{Node cache}
\l generalize to Cache? with node cache, time cache, etc?

% S_NODE used at a few places so maybe cant delay that to opti section.
% Also it is a DAG, not a tree

% useful in practice? when reuse a target node? when same file
%  mentioned again and again, like .o or .a used in different targets?
% but then it's not really an opti, you want to have only one node, 
%  otherwise you will run multiple times the same recipe

<<[[applyrules]] check node cache if target is already there>>=
sym = symlook(target, S_NODE, nil);
if(sym)
    return sym->u.ptr;
@

<<[[Sxxx]] cases>>=
S_NODE,		/* target name -> node */
@

<<[[newnode()]] update node cache>>=
symlook(name, S_NODE, (void *)node);
@


\section{[[timeof()]]}
% for the leaves!

% force is here to say if want to bypass cache and redo
% the actual read! for instance after the recipe is done
% we want to update the time of the file and disable the cache for sure!

% newnode() -> <> -> mkmktime -> bulktime
%                             -> dirstat (libc)
<<function timeof>>=
ulong
timeof(char *name, bool force)
{
    <<[[timeof()]] locals>>

    <<[[timeof()]] if name archive member>>
    if(force)
        return mkmtime(name, true);
    // else
    <<[[timeof()]] if not force, use time cache>>
}
@
%old: ulong mtime(char *name) {  return mkmtime(name, true);}
%but simpler to remove, refactor caller sites

% Note that applyrules goes until the end, even if leaf is up to date
% already. it will compute also the dependencies for this up-to-date
% leaf. Because applyrules just does one thing! Build static graph,
% and then can do analysis on this graph. Better separate concerns
% (so can do tricky analysis like implicit dependencies, etc)

\subsection{[[mkmtime()]]}

<<function mkmtime>>=
ulong
mkmtime(char *name, bool force)
{
    Dir *d;
    char buf[4096];
    ulong t;
    <<[[mkmtime]] locals>>

    strecpy(buf, buf + sizeof buf - 1, name);
    cleanname(buf);
    name = buf;

    <<[[mkmtime()]] bulk dir optimisation>>

    if((d = dirstat(name)) == nil)
        return 0;

    t = d->mtime;
    free(d);

    return t;
}
@

% cleanname! so normalize! otherwise lost opportunity to realize 
%  same file
% but actually not put in node cache

\subsection{Time cache}
\t adv topics? with opti of node cache?


% multiple levels of cache ... first in cache, 
% then bulk so will get more hit cache.


<<[[Sxxx]] cases>>=
S_TIME,		/* file -> time */
@

<<[[timeof()]] locals>>=
ulong t;
@

<<[[timeof()]] if not force, use time cache>>=
<<[[timeof()]] check time cache>>
t = mkmtime(name, false);
<<[[timeof()]] update time cache>>
return t;
@


<<[[timeof()]] locals>>=
Symtab *sym;
@

<<[[timeof()]] check time cache>>=
sym = symlook(name, S_TIME, nil);
if (sym)
    return sym->u.value;		/* uggh */
@
% comment?

<<[[timeof()]] update time cache>>=
if(t == 0)
    return 0;
symlook(name, S_TIME, (void*)t);		/* install time in cache */
@

% other opti about bulktime later.



\section{Checking the rules and the graph}
\n was 'checking the rules', but really it is more checking the graph

% Also simplify the graph by removing some arcs (see togo()).
% Give priority for instance to specialized over meta rules. So
% important calls below.

<<[[graph()]] checking the graph>>=
cyclechk(root);
<<[[graph()]] set root flags before [[vacuous()]]>>
vacuous(root);
ambiguous(root);
@
% can do vacuous after ambiguous? NO! cos whole point of vacuous is
% to delete some nodes and arcs that would generate ambiguity!

\subsection{Cycle detection}

<<[[Node_flag]] cases>>=
CYCLE      = 0x0002,
@

<<function cyclechk>>=
static void
cyclechk(Node *n)
{
    Arc *a;

    if((n->flags&CYCLE) && n->prereqs){
        fprint(STDERR, "mk: cycle in graph detected at target %s\n", n->name);
        Exit();
    }
    n->flags |= CYCLE;
    for(a = n->prereqs; a; a = a->next)
        if(a->n)
            cyclechk(a->n);
    n->flags &= ~CYCLE;
}
@
% important to restore back flags as they were before?
% YES because graph is a DAG, so might encounter another time the same
%  note but that's ok.
% Could optimize and have both a visited field and cycle field
%  so dont explore twice the same already checked subtree?
%  NO, cos context might be different and we might have a loop.

% FIGURE

% sucks a bit that does not show trace, so hard to debug.
%ocaml: give a trace!

\subsection{Infinite rule detection and [[$NREP]]}%$

% to manage bad rules like %: %.c that can be executed multiple times

<<[[graph()]] other locals>>=
// map<ruleid, int>
char *cnt;
@

<<[[Rule]] other fields>>=
int 		rule;		/* rule number */
@


% incremented by addrule()
<<global nrules>>=
static int nrules = 0;
@
% used by rulecnt() later
<<[[addrule()]] set more fields>>=
r->rule = nrules++;
@


<<[[graph()]] set cnt for infinite rule detection>>=
cnt = rulecnt();
@

<<[[graph()]] free cnt>>=
free(cnt);
@

% statistic on how much a rule was fired? for infinite detection?
<<function rulecnt>>=
char*
rulecnt(void)
{
    char *s;

    s = Malloc(nrules);
    memset(s, 0, nrules);
    return s;
}
@
\l mv Profiling? or used also for checking?
\l but hard to move profiling, passed around a lot
% nrules modified by addrule






% n reps, to manage bad rules like %: %.c that can be executed multiple times
<<global nreps>>=
int nreps = 1;
@
% n repetition?


<<[[applyrules()]] infinite rule detection part1>>=
if(cnt[r->rule] >= nreps) 
    continue;
cnt[r->rule]++;
@

<<[[applyrules()]] infinite rule detection part2>>=
cnt[r->rule]--;
@
% restore back because want to allow to apply the same metarules
% multiple time. We just dont want to forbid it when call
% applyrules recursively with the prereqs as the new targets.



<<[[mk()]] initialisation>>=
nrep();		/* it can be updated dynamically */
@

% mk -> nrep
<<function nrep>>=
void
nrep(void)
{
    Symtab *sym;
    Word *w;

    sym = symlook("NREP", S_VAR, nil);
    if(sym){
        w = sym->u.ptr;
        if (w && w->s && *w->s)
            nreps = atoi(w->s);
    }
    if(nreps < 1)
        nreps = 1;
    <<[[nrep()]] if DEBUG(D_GRAPH)>>
}
@
\t mv to graph.c? or check.c?


\subsection{Ambiguous rules detection}
% also modify graph to fix things.

% help to understand subtelities of multiple targets, multiple prereqs,
%  multiple rules ?

\l seems that rely on TOGO field, so assume vacuous has been called before?

%nice output:
%mk: ambiguous recipes for install:
%	install <-(/sys/src/cmd/mklib:28)- libthreads.a <-(/sys/src/cmd/mklib:12)- libthreads.a(scheduler.8)
%	install <-(mkfile:19)- 


<<function ambiguous>>=
static void
ambiguous(Node *n)
{
    Arc *a;
    Rule *r = nil;
    Arc *la = nil;
    bool bad = false;

    for(a = n->prereqs; a; a = a->next){
        // recurse
        if(a->n)
            ambiguous(a->n);

        // rules without any recipe do not generate ambiguity
        if(*a->r->recipe == '\0') continue;
        // else

        // first rule with recipe (so no ambiguity)
        if(r == nil) {
            r = a->r;
            la = a;
        }
        else{
            <<[[ambiguous()]] give priority to simple rules over meta rules>>
            if(r->recipe != a->r->recipe){
                if(!bad){
                    fprint(STDERR, "mk: ambiguous recipes for %s:\n", n->name);
                    bad = true;
                    trace(n->name, la);
                }
                trace(n->name, a);
            }
        }
    }
    if(bad)
        Exit();
    <<[[ambiguous()]] get rid of all skipped arcs>>
}
@
\t rename r to master_rule ? and la to master_arc ?
\t use empty_recipe() (and assert != nil)
\l could optimize again and avoid visiting node already visited

%ocaml-found:
% use != to compare recipe? string address comparison? not strcmp?
%  when can have 2 arcs with same recipe pointer?
% all the time, because in foo.exe: foo.o bar.o\n gcc foo.o bar.o -o foo.exe
%  you will have multiple arcs with recipe, but always same recipe so it's ok.
%  When we build the graph we splitted such single rule in multiple arcs,
%  but we need to remember they come from the same rule after.
  

% why not mark TOGO for rule without recipe? because we still want this
% arc for outdated check! this arc does not contain a recipe, but it
% is still important, e.g. dependencies like foo.o: foo.h

\l can have target with no recipe arc at all?

<<function trace>>=
static void
trace(char *s, Arc *a)
{
    fprint(STDERR, "\t%s", s);
    while(a){
        fprint(STDERR, " <-(%s:%d)- %s", a->r->file, a->r->line,
            a->n? a->n->name:"");
        if(a->n){
            for(a = a->n->prereqs; a; a = a->next)
                if(*a->r->recipe) break;
        } else
            a = nil;
    }
    fprint(STDERR, "\n");
}
@
\t what is the stuff looking in the prereqs of the prereq?

\subsubsection{Specialized versus generic rules}

% seems fair, can write general rules and then add specific ones.

<<[[ambiguous()]] give priority to simple rules over meta rules>>=
if(r->recipe != a->r->recipe){
    if((r->attr&META) && !(a->r->attr&META)){
        la->flag |= TOGO;
        r = a->r;
        la = a;
    } else if(!(r->attr&META) && (a->r->attr&META)){
        a->flag |= TOGO;
        continue;
    }
}
@

\subsubsection{Adjusting the graph, [[togo()]]}

<<[[Arc]] other fields>>=
// bool (TOGO)
short flag;
@
\t rename toremove?

<<constant TOGO>>=
/* Arc.flag */
#define		TOGO		true
@
% mark arc as to be removed
\t remove, just use better field name for arc.flag.

<<[[ambiguous()]] get rid of all skipped arcs>>=
togo(n);
@


<<function togo>>=
static void
togo(Node *node)
{
    Arc *a, *la;

    /* delete them now */
    la = nil;
    for(a = node->prereqs; a; la = a, a = a->next)
        if(a->flag&TOGO){
            //remove_list(a, node->prereqs)
            if(a == node->prereqs)
                node->prereqs = a->next;
            else
                la->next = a->next, a = la;
        }
}
@
%pad: I've added the warning, BUT ACTUALLY I should not!
%            fprint(STDERR, "mk: vacuous arc found %s->%s\n", 
%                     node->name, a->n->name);
\l could do it for explain mode

% la = last a
% leak! 
% should we remove all children of this node? no because DAG so potentially
%  referenced elsewhere

%ocaml: useful only for ambiguous for specialized vs generic so do
% adjustments there by resetting the list of prereqs


\subsection{Vacuous node detection}
% def of vacuous =~ stupid

%ocaml-found:
% without this check and graph adjustment, generic rules such as
% %.o: %.c; CC ...  and %.o: %.s; AS ... would conflict with each other
% (as in plan9/sys/src/cmd/mkone)
% and generate ambiguity. Of course if an object foo.o is requested
% and the directory contain foo.c, obviously we do not want the
% rule foo.o: foo.s. 
% We can mark as PROBABLY node with files that already exist and
% detect VACUOUS node that would generate ambiguity by looking
% if the file in the node does not exist and the node was generated
% from a metarule!



% goal is to mark certain nodes as VACUOUS.
<<[[Node_flag]] cases>>=
VACUOUS    = 0x0200,
@
\l but not sure this flag is needed as it is used only inside
\l  vacuous. If got rid of READY, then no need for VACUOUS

% before, mark a few nodes as PROBABLE
<<[[Node_flag]] cases>>=
PROBABLE   = 0x0100,
@
% not very clear name, but means file exist so probably
% a good node


<<[[newnode()]] set flags of node>>=
node->flags = (node->time? PROBABLE : 0);
@
% so if file exists, then PROBABLE.

<<[[applyrules()]] when found a regular rule for target [[node]], set flags>>=
node->flags |= PROBABLE;
@
% make sense, even if file does not exist, probably a node we
% are interested in.

<<[[graph()]] set root flags before [[vacuous()]]>>=
root->flags |= PROBABLE;	/* make sure it doesn't get deleted */
@


<<[[Node_flag]] cases>>=
READY      = 0x0004,
@
% for what? not very clear name
% Seems just because graph is a DAG so avoid redo work.
% also marked node as vacuous_checked; used later in mk()



<<function vacuous>>=
static bool
vacuous(Node *node)
{
    Arc *la, *a;
    bool vac = !(node->flags&PROBABLE);

    if(node->flags&READY)
        return node->flags&VACUOUS;
    node->flags |= READY;

    for(a = node->prereqs; a; a = a->next)
        if(a->n && vacuous(a->n) && (a->r->attr&META))
            a->flag |= TOGO;
        else
            vac = false;
    <<[[vacuous]] possibly undelete some arcs>>

    togo(node);
    if(vac) {
        node->flags |= VACUOUS;
    }
    return vac;
}
@
% pad: I've originally added the warning
%        fprint(STDERR, "mk: vacuous node found %s\n", node->name);
% but this is wrong. a vacuous node is ok.

<<[[vacuous]] possibly undelete some arcs>>=
/* if a rule generated arcs that DON'T go; no others from that rule go */
for(a = node->prereqs; a; a = a->next)
    if(!(a->flag&TOGO))
        for(la = node->prereqs; la; la = la->next)
            if((la->flag&TOGO) && (la->r == a->r)){
                la->flag &= ~TOGO;
            }
@
\l when this matter?

\section{Rule attributes propagation}

% propagate from rule to node
\t why? just for the union of virtual?

<<function attribute>>=
static void
attribute(Node *n)
{
    Arc *a;

    for(a = n->prereqs; a; a = a->next){
        <<[[attribute()]] propagate rule attribute to node cases>>
        // recurse
        if(a->n)
            attribute(a->n);
    }
    <<[[attribute()]] if virtual node>>
}
@



\chapter{Finding Outdated Files}

% the core algorithm.
% main idea = 
%  construct dependency graph for target root (previous chapter)
%  set all nodes to NOTMADE.
%    Then ask to build root which will recurse. 
%    If leaf then node MADE if exist
%    Otherwise look at time 
%     if file > time of all children then MADE, 
%     otherwise run recipe job in parallel, return and wait it's MADE (so loop).
%    if error in any recipe, then Exit.

% while(root not finished) { run wave of jobs and update graph }

\section{[[mk()]]}

<<[[Node_flag]] cases>>=
NOTMADE    = 0x0020,
BEINGMADE  = 0x0040,
MADE       = 0x0080,
@
%ocaml: should be different field than other node flags

% NOTMADE initially (see clrmade())
% BEINGMADE? when start recipe, but mk can run in // so it returns!
%   can go back to node with BEINGMADE? when
%   2 files with deps on same Node, because of the DAG
% MADE finally when recipe done! (or time was already good, so no need update)

% FIGURE displaying a tree of files and
% see how mk is running some waves of jobs, and how at each node
% there is a ready or outofdate boolean value.

\t put global did here, but then need to reset it each time before work
\t  and so need also to have a local did in mk
\t make did a global because was always threading it
% everywhere and doing did = foo () || did;   
% possible? change semantic?


% main -> <> -> graph() ; clrmade(); work()
<<function mk>>=
void
mk(char *target)
{
    Node *root;
    bool did = false;
    // enum<WaitupResult>
    int res;

    <<[[mk()]] initialisation>>

    root = graph(target);
    <<[[main()]] if DEBUG(D_GRAPH)>>
    clrmade(root);

    while(root->flags&NOTMADE){
        if(work(root, (Node *)nil, (Arc *)nil))
            did = true;	/* found something to do */
        else {
            res = waitup(1, (int *)nil);
            <<[[mk()]] if no child to waitup and root not MADE, possibly break>>
        }
    }
    if(root->flags&BEINGMADE)
        waitup(-1, (int *)nil);

    <<[[main()]] before returning, more [[waitup()]] if there was an error>>
    if(!did)
        Bprint(&bout, "mk: '%s' is up to date\n", root->name);
    return;
}
@
%old: was called node, but root is better.
%old: was if(waitup(1, (int *)nil) > 0) but hard to read
%pad: I added the return

% pass nil, nil to pass previous node and previous arc, but used only
% for pretending stuff.

%ocaml-found:
% waitup take 1 to say 'ok to not have children'.
% when can be the case? when top is virtual target with no recipe
% e.g., all: prog,
% and previous round built prog and updated to MADE the prog node.
% Still the root node is not made, and work will not trigger
% any new process; it will update though all to MADE but we should
% not waitup().

%ocaml-found:
% why extra waitup after? because last work round may have put
% root as BeingMade and so will go out of the loop,
% but we still need to wait!

%note: subtle, important while loop! because of mk // so run some jobs
% but then later another job might depend on the end of this one,
% so have BEINGMADE flag and waitup??

% can have runerrs only when use mk -k ? so could put that in assert too?
% NO, can have it also when C-c.

% When can have did==false so print 'xx is up to date'?
% when did nothing, because prog was _already_ up to date.
\l maybe change message.




\section{[[clrmade()]]}

<<function MADESET>>=
#define	MADESET(n,m)	n->flags = (n->flags&~(NOTMADE|BEINGMADE|MADE))|(m)
@
% keep flags as they were, except for the made stuff
%ocaml: use a separate field than the other node attributes

<<function clrmade>>=
void
clrmade(Node *n)
{
    Arc *a;

    <<[[clrmade()]] [[n->flags]] pretend adjustments>>
    MADESET(n, NOTMADE);
    for(a = n->prereqs; a; a = a->next)
        if(a->n)
            // recurse
            clrmade(a->n);
}
@
%bug? DAG? should avoid repetitive work too there?
%ocaml: no need, do that in newnode() thx to another field.

\section{[[work()]]}

% have to do transitive closure of dependencies ... when
% "making" node, look at is prerequistes, and check if they need
% work too, because maybe a leaf was modified!


<<[[work()]] locals>>=
bool did = false;
@
\t move as a global! so no need return bool in work() also.


\t parent_node, prev_arc, TODO rename parameters?
% extra params for advanced functionality not needed

% main -> mk -> <> -> outofdate(); dorecipe()
<<function work>>=
bool
work(Node *node,   Node *p, Arc *parc)
{
    <<[[work()]] locals>>

    <<[[work()]] debug>>
    if(node->flags&BEINGMADE)
        return did;
    <<[[work()]] possibly unpretending node>>

    // Leaf case
    <<[[work()]] no prerequisite, a leaf>>
    // else
    // Node case
    <<[[work()]] some prerequisites, a node>>
}
@
% can refactor in did ||= foo(); ? hmm maybe not, we actually want the
% side effect!
\t maybe can rewrite with skeleton of if(node->prereqs == nil)
\t  and use else instead of ugly return shortcut.

\t can refactor did in a global? dangerous ... but would clarify I think

% BEINGMADE test because DAG.

\subsection{Leaf case}

% a leaf!
<<[[work()]] no prerequisite, a leaf>>=
/* consider no prerequisite case */
if(node->prereqs == nil){
    if(node->time == 0){
        <<[[work()]] print error when inexistent file without prerequisites>>
    } else
        MADESET(node, MADE);
    return did;
}
@
% if no prereqs, then no arcs, then no rule with recipe
\t why not use update(false, node) here?

% remember that virtual rules have an arc

<<[[work()]] locals>>=
char cwd[256];
@

<<[[work()]] print error when inexistent file without prerequisites>>=
if(getwd(cwd, sizeof cwd))
    fprint(STDERR, "mk: don't know how to make '%s' in directory %s\n", node->name, cwd);
else
    fprint(STDERR, "mk: don't know how to make '%s'\n", node->name);

<<[[work()]] when inexistent target without prerequisites, if kflag>>
else
    Exit();
@
% the directory part is useful in recursive mk context
\l aspectize that part and put in recursive mk section?

\subsection{Node case}

<<[[work()]] locals>>=
bool weoutofdate = false;
bool ready = true;
Arc *a;
@
%old: used to be done later, and weoutofdate used to be aflag
%old: initialization was done later
\n called weoutofdate to avoid conflict with outofdate function

<<[[work()]] some prerequisites, a node>>=
<<[[work()]] adjust weoutofdate if aflag>>
/*
 *   now see if we are out of date or what
 */
for(a = node->prereqs; a; a = a->next)
    if(a->n){
        // recursive call! go in depth
        did = work(a->n, node, a) || did;

        if(a->n->flags&(NOTMADE|BEINGMADE))
            ready = false;
        if(outofdate(node, a, false)){
            weoutofdate = true;
            <<[[work()]] update [[ra]] when outofdate [[node]] with arc [[a]]>>
        }
    } else {
        if(node->time == 0){
            weoutofdate = true;
            <<[[work()]] update [[ra]] when no dest in arc and no src>>
        }
    }

if(!ready)	/* can't do anything now */
    return did;
if(!weoutofdate){
    MADESET(node, MADE);
    return did;
}
<<[[work()]] possibly pretending node>>

// else, out of date

did = dorecipe(node) || did;
return did;
@

\t why not remove ready=false and just return earlier? do side effects
\t  in loop for other stuff? for pretending stuff?
\t  also could rewrite code with cleaner if then else instead of those
\t  ugly return shortcut

% when can happen have no node attached to an arc? virtual targets
%  or when file does not exist, so for sure we are out of date.


%\section{[[outofdate()]]}

<<function outofdate>>=
bool
outofdate(Node *node, Arc *arc, bool eval)
{
    <<[[outofdate()]] locals>>

    <<[[outofdate()]] if arc->prog>>
    else 
     <<[[outofdate()]] if arc node is an archive member>>
     else
        /*
         * Treat equal times as out-of-date.
         * It's a race, and the safer option is to do
         * extra building rather than not enough.
         */
        return node->time < arc->n->time;
}
@
% inexistent file has zero time (like very very old time)
%old: was <=, but annoying, so I ignored the comment

% eval argument? seems used only for :P: prog stuff

%note: on very fast machine the <= above test can be actually annoying.
% For instance in ocaml both the .cmo and .cmi may have
% been created in the same second by ocamlc, which means
% then that the .cmo file will always be recompiled because
% its .cmi has the same date (and recompiling the .cmo
% will generate a new .cmi, which then will trigger at the next
% round another compilation of the .cmo and so on).




\section{[[dorecipe()]]}

%bool dorecipe(Node *node)

% will iterate over arcs, node in args, words, and symbols.

% find right arc with recipe, find master rule

<<[[dorecipe()]] other locals>>=
Arc *aa = nil; // arc with recipe
Rule *r = nil; // rule with recipe
@
\t rename aa to arc or master_arc

% set list of targets (most of the time single one)
% and have alltargets and only-old-targets (outofdate)

<<[[dorecipe()]] other locals>>=
Word head, ahead; // out of date targets,   all targets
@
\t rename head ahead

% set list of prereqs (most of the time single one)
% and have allprereqs and only-new-prereqs (causing outofdate target)

<<[[dorecipe()]] other locals>>=
Word lp, ln; // all prereqs, prereqs making target out of date
@
\t rename lp ln
%old: l for list?

<<[[dorecipe()]] other locals>>=
bool did = false;
@
%dead, always false (maybe use [[did]] instead of false cos clearer)


% main -> mk -> work -> ... -> run(newjob())
<<function dorecipe>>=
bool
dorecipe(Node *node)
{
    // iterators
    Arc *a;
    Node *n;
    Word *w;
    Symtab *s;
    <<[[dorecipe()]] other locals>>

    /*
     *   pick up the rule
     */
    for(a = node->prereqs; a; a = a->next)
        if(*a->r->recipe) {
            aa = a;
            r = a->r;
        }
    <<[[dorecipe()]] if no recipe found>>
    // else

    /*
     *   build the node list
     */
    node->next = nil;
    head.next = ahead.next = nil;
    <<[[dorecipe()]] build lists of targets and node list>>
    <<[[dorecipe()]] return if one target not READY>>

    /*
     *   gather the params for the job
     */
    lp.next = ln.next = nil;
    for(n = node; n; n = n->next){
        <<[[dorecipe()]] build lists of prerequisites>>
        MADESET(n, BEINGMADE);
    }

    // run the job
    run(newjob(r, node, aa->stem, aa->match, 
               lp.next, ln.next, 
               head.next, ahead.next));
    return true;
}
@
%/*print("lt=%s ln=%s lp=%s\n",wtos(head.next, ' '),wtos(ln.next, ' '),wtos(lp.next, ' '));
\t remove local did?
\t replace return true by did=true; return;

% if return error code, then should stop mk right?


<<[[dorecipe()]] other locals>>=
Word *ww, *aw;
char buf[BIGBLOCK];
@


<<[[dorecipe()]] build lists of targets and node list>>=
ww = &head;
aw = &ahead;
<<[[dorecipe()]] if regexp rule>>
else {
    for(w = r->alltargets; w; w = w->next){
        if(r->attr&META)
            subst(aa->stem, w->s, buf, sizeof(buf));
        else
            strecpy(buf, buf + sizeof buf - 1, w->s);

        aw->next = newword(buf);
        aw = aw->next;

        s = symlook(buf, S_NODE, nil);
        if(s == nil)
            continue;	/* not a node we are interested in */
        // else
        n = s->u.ptr;

        <<[[dorecipe()]] update list of outdated targets>>

        if(n == node) continue;

        n->next = node->next;
        node->next = n;
    }
}
@
%ocaml: can do the subst once and for all and have a better rule_exec!
\t but then need to have talked about S_NODE before? so cant aspectize
\t  node cache?

% when can have the case of node not found in S_NODE? because
%  when we build the graph we start from one target which may
%  be part of a multi-target rule, e.g. parser.ml parser.mli: parser.mly
%  and if we did mk parser.mli, then parser.ml will not be in
%  the graph even though we want to add it for the alltargets variable

<<[[dorecipe()]] update list of outdated targets>>=
if(!aflag && n->time) {
    for(a = n->prereqs; a; a = a->next)
        if(a->n && outofdate(n, a, false))
            break;
    // no out of date arc, node does not need to be regenerated
    if(a == nil)
        continue; 
    // else, find an outdated arc for node of target
}
ww->next = newword(buf);
ww = ww->next;
@


<<[[dorecipe()]] return if one target not READY>>=
for(n = node; n; n = n->next)
    if(!(n->flags&READY))
        return did;
@
% did always false here no?
% and look vacuous(), READY is always set ...
\t ???? remove code?

<<[[dorecipe()]] build lists of prerequisites>>=
for(a = n->prereqs; a; a = a->next){
    if(a->n){
        addw(&lp, a->n->name);
        if(outofdate(n, a, false)){
            addw(&ln, a->n->name);
            <<[[dorecipe()]] explain when found arc [[a]] making target [[n]] out of date>>
        }
    } else {
        <<[[dorecipe()]] explain when found target [[n]] with no prerequisite>>
    }
}
@
\l why arc without a node??

<<[[dorecipe()]] other locals>>=
char cwd[256];
@

<<[[dorecipe()]] if no recipe found>>=
/*
 *   no recipe? go to buggery!
 */
if(r == nil){
    if(!(node->flags&VIRTUAL) && !(node->flags&NORECIPE)){
        if(getwd(cwd, sizeof cwd))
            fprint(STDERR, "mk: no recipe to make '%s' in directory %s\n", node->name, cwd);
        else
            fprint(STDERR, "mk: no recipe to make '%s'\n", node->name);
        Exit();
    }
    // else
    <<[[dorecipe()]] when no recipe found, if archive name>>
    else
        update(false, node);

    <<[[dorecipe()]] when no recipe found, if tflag>>
    return did;
}
@
\t change !X && !Y  to X || Y   so easier to aspectize




\chapter{Scheduling Jobs}
\l Fixing outdated files

%trans: remaining things to see: run(), waitup()
% seen Job and jobs before.
% will see a few more globals: nproclimit, nevent, nrunning

% can do stuff in //. Make originally didn't (apparently).

\section{Enqueuing jobs}

\subsection{[[nrunning]] and [[nproclimit]]}

<<global nrunning>>=
static int nrunning;
@

<<global nproclimit>>=
static int nproclimit;
@
% can be set in env (readenv) $NPROC, see below
\l put code setting up nproclimit here?

\subsection{[[run()]]}

% main -> mk -> work -> dorecipe -> <> (-> sched())
<<function run>>=
void
run(Job *j)
{
    Job *jj;

    // enqueue(j, jobs)
    if(jobs){
        for(jj = jobs; jj->next; jj = jj->next)
            ;
        jj->next = j;
    } else 
        jobs = j;
    j->next = nil;

    /* this code also in waitup after parse redirect */
    if(nrunning < nproclimit)
        sched();
}
@
%ocaml: use Queue.add
\l j->next = nil  redundant since does it already in newjob

% if no more processor free, then just enqueued. next round
%  will pop this one.


\subsection{[[$NPROC]]}%$
% export NPROC=...

<<[[mk()]] initialisation>>=
nproc();	/* it can be updated dynamically */
@

<<function nproc>>=
void
nproc(void)
{
    Symtab *sym;
    Word *w;

    if(sym = symlook("NPROC", S_VAR, nil)) {
        w = sym->u.ptr;
        if (w && w->s && w->s[0])
            nproclimit = atoi(w->s);
    }
    if(nproclimit < 1)
        nproclimit = 1;
    <<[[nproc()]] if DEBUG(D_EXEC)>>

    <<[[nproc()]] grow nevents if necessary>>
}
@


\section{Scheduling jobs}

%trans: if processor free, then run job, and keep track of it.

\subsection{[[RunEvent]] and [[events]]}

% to keep track of children process, what they were supposed to do.

<<struct RunEvent>>=
struct RunEvent {
    // option<Pid> (None = 0)
    int pid;

    // ref_own<Job>
    Job *job;
};
@
%bug? seems that job never freed

<<global events>>=
// growing_array<Runevent> (size = nevents (== nproclimit))
static RunEvent *events;
@
%ocaml: use instead map (e.g., hash) from pid to job.


<<global nevents>>=
static int nevents;
@
\t should be == nproclimit, so maybe can remove it
\l  or sometimes nproclimit can go down, in which case we dont really
\l  but useless opti
\t  just remember old_nproclimit in nproc() so know if need realloc

% the slaves processors! called a slot.

% sched -> <>
<<function nextslot>>=
int
nextslot(void)
{
    int i;

    for(i = 0; i < nproclimit; i++)
        if(events[i].pid <= 0) 
            return i;
    assert(/*out of slots!!*/ false);
    return 0;	/* cyntax */
}
@
%ocaml: no need growing_array, just use hash

% waitup -> <>
<<function pidslot>>=
int
pidslot(int pid)
{
    int i;

    for(i = 0; i < nevents; i++)
        if(events[i].pid == pid) 
            return i;
    <<[[pidslot()]] if DEBUG(D_EXEC)>>
    return -1;
}
@
% this one iterate on all nevents, not just nproclimit
% but should be the same between two runs of mk
% so maybe could simplify.
\t use nproclimit, not nevents above, more consistent
%ocaml: use Hashtbl.find


<<[[nproc()]] grow nevents if necessary>>=
if(nproclimit > nevents){
    if(nevents)
        events = (RunEvent *)Realloc((char *)events, nproclimit*sizeof(RunEvent));
    else
        events = (RunEvent *)Malloc(nproclimit*sizeof(RunEvent));

    while(nevents < nproclimit)
        events[nevents++].pid = 0;
}
@
\t replace nproclimit by != nevents
%ocaml: no need, Hashtbl.t grows as needed

% so nevents should be = to nproclimit at the end


\subsection{[[sched()]]}

% main -> mk -> work -> dorecipe -> run -> sched()
<<function sched>>=
static void
sched(void)
{
    Job *j;
    int slot;
    Envy *e;
    char *flags;
    <<[[sched()]] other locals>>

    <<[[sched()]] sanity check jobs>>

    // j = pop(jobs)
    j = jobs;
    jobs = j->next;
    <<[[sched()]] if DEBUG(D_EXEC)>>

    slot = nextslot();
    events[slot].job = j;

    e = buildenv(j, slot);
    <<[[sched()]] print recipe command on stdout>>

    <<[[sched()]] if dry mode or touch mode, alternate to execsh>>
    else {
       <<[[sched()]] if DEBUG(D_EXEC) print recipe>>
        flags = "-e";
       <<[[sched()]] reset flags if NOMINUSE rule>>

        // launching the job!
        events[slot].pid = execsh(flags, j->r->recipe, nil, e);

        usage();
        nrunning++;
       <<[[sched()]] if DEBUG(D_EXEC) print pid>>
    }
}
@
% -e is important!! want any error in the subshell command
% to abort the whole thing

<<[[sched()]] sanity check jobs>>=
if(jobs == nil){
    usage();
    return;
}
@
\t how can have jobs == nil?
% should issue an error here, assert!
\t actually usage is for profiling

% buildenv is important; it is the function using most of the fields in j;

\subsection{Executing shell recipes, [[execsh()]]}

<<global shell>>=
char 	*shell =	"/bin/rc";
@
<<global shellname>>=
char 	*shellname =	"rc";
@


<<global shflags>>=
char	*shflags = "-I";	/* rc flag to force non-interactive mode */
@
\t need that ? does not repeat on stdout the command

% pad: should add also -e!! actually -e is added by default
%  unless you added :E: for NOMINUSE

% will fork, exec shell, and pass as stdin input in pipe 
% to the shell the recipe string.
%alt: sh -e '' ? but then need escape mess?

% can also pass a buf for bquote (backquote execution), to store
%  stdout instead of just displaying it gradually

% FIGURE? cos 2 forks below.
% 2 fork trick for what? because dont want current
% process to be blocked on feeding input to shell. Instead
% do that in another process.

%plan9.c 
<<function execsh>>=
int
execsh(char *args, char *cmd, Bufblock *buf, Envy *e)
{
    int pid;
    fdt in[2];
    int err;
    <<[[execsh()]] other locals>>

    <<[[execsh()]] if buf then create pipe to save output>>

    pid = rfork(RFPROC|RFFDG|RFENVG);
    <<[[execsh()]] sanity check pid rfork>>
    // children
    if(pid == 0){
        <<[[execsh()]] in children, if buf, close one side of pipe>>
        err = pipe(in);
        <<[[execsh()]] sanity check err pipe>>
        pid = fork();
        <<[[execsh()]] sanity check pid fork>>
        // child 1, the shell interpreter
        if(pid != 0){
            // input now comes from the pipe
            dup(in[0], STDIN);
            <<[[execsh()]] in child 1, if buf, dup and close>>
            close(in[0]);
            close(in[1]);
            if (e)
                exportenv(e);
            if(shflags)
                execl(shell, shellname, shflags, args, nil);
            else
                execl(shell, shellname, args, nil);
            // should not be reached
            perror(shell);
            _exits("exec");
        }
        // child 2, feeding the shell with recipe, through a pipe
        <<[[execsh()]] in child 2, if buf, close other side of pipe>>
        close(in[0]);
        // feed the shell
        <<[[execsh()]] in child 2, write cmd in pipe>>
        close(in[1]); // will flush
        _exits(nil);
    }
    // parent
    <<[[execsh()]] in parent, if buf, close other side of pipe and read output>>
    return pid;
}
@
%pad: I introduced int err; so can better aspectize sanity checks
\n put flags after cmd in argument of execsh, more logical? no! cmd is input!
\t rename cmd to input ?

%ocaml-found:
% important for second fork to do the code of the shell in the case where
%  pid <> 0!!
% otherwise, would wait for wrong process! would wait for
% child2 that feeds the shell which returns very quickly!
% Also wait for could possibly capture child2.

% exportenv! so set in child the variables in environment

<<[[execsh()]] other locals>>=
char *p;
@
<<[[execsh()]] in child 2, write cmd in pipe>>=
p = cmd+strlen(cmd);
while(cmd < p){
    n = write(in[1], cmd, p-cmd);
    if(n < 0)
        break;
    cmd += n;
}
@



<<[[execsh()]] sanity check pid rfork>>=
if(pid < 0){
    perror("mk rfork");
    Exit();
}
@
<<[[execsh()]] sanity check pid fork>>=
if(pid < 0){
    perror("mk fork");
    Exit();
}
@
<<[[execsh()]] sanity check err pipe>>=
if(err < 0){
    perror("pipe");
    Exit();
}
@








\section{Waiting jobs}

\subsection{[[waitup()]]}

% wait user processes?

% retstatus param mostly not used. used for <| and :P: so can aspectize it
% INOUT. for IN it is a pid and OUT it is the return status (ugly)
% put here because can have only one call to wait. wait is waiting
%  indiscrimently, so have to centralize in one place.
% For more info, see Section X.

\t enum WaitupResult { WEmptyChild=1, WJobEnded=0, WNotJobProcess=-1 }
\t enum WaitupParam { EmptyChildOk, EmptyChildError1 =-1, EmptyChildError2 =-2}

% mk -> work; <>
<<function waitup>>=
int
waitup(int echildok, int *retstatus)
{
    // child process
    int pid;
    // return string of child process
    char buf[ERRMAX];
    // index in events[]
    int slot;
    Job *j;
    Symtab *sym;
    Word *w;
    bool fake = false;
    <<[[waitup()]] other locals>>

    <<[[waitup()]] if retstatus, check process list>>
again:		/* rogue processes */

    pid = waitfor(buf);
    <<[[waitup()]] if no more children>>
    <<[[waitup()]] if DEBUG(D_EXEC) print pid>>
    <<[[waitup()]] if retstatus, check if matching pid>>

    slot = pidslot(pid);
    <<[[waitup()]] if slot not found, not a job pid, update process list>>

    j = events[slot].job;
    usage();
    nrunning--;
    // free events[slot]
    events[slot].pid = -1;

    <<[[waitup()]] if error in child process, possibly set fake or exit>>
    // else

    for(w = j->t; w; w = w->next){
        sym = symlook(w->s, S_NODE, nil);
        <<[[waitup()]] skip if node not found>>
        update(fake, (Node*) sym->u.ptr);
    }

    if(nrunning < nproclimit)
        sched();
    return 0;
}
@
%bug? could free job in events[i] too
%old: fake was called [[uarg]] (for update arg)
\t return value used?

%plan9.c
<<function waitfor>>=
int
waitfor(char *msg)
{
    Waitmsg *w;
    int pid;

    // blocking call, wait for any children
    w = wait();
    // no more children
    if(w == nil)
        return -1;
    strecpy(msg, msg+ERRMAX, w->msg);
    pid = w->pid;
    free(w);
    return pid;
}
@
% strecpy set msg[0] to \0 if nothing?


% echildok -1, -2, -3?? just to help debug which one of the waitup?
%alt: could use __LINE__ instead
\t introduce enum? ERROR_CHILD_OK, ERROR_CHILD_NOTOK1, ERROR_CHILD_NOTOK2
\t  or is it EMPTY_CHILD_OK?

<<[[waitup()]] if no more children>>=
if(pid == -1){
    if(echildok > 0)
        return 1;
    else {
        fprint(STDERR, "mk: (waitup %d) ", echildok);
        perror("mk wait");
        Exit();
    }
}
@



<<[[waitup()]] other locals>>=
Envy *e;
Bufblock *bp;
@

<<[[waitup()]] if error in child process, possibly set fake or exit>>=
if(buf[0]){
    e = buildenv(j, slot);
    bp = newbuf();
    shprint(j->r->recipe, e, bp);
    front(bp->start);
    fprint(STDERR, "mk: %s: exit status=%s", bp->start, buf);
    freebuf(bp);
    <<[[waitup()]] when error in child process, delete if DELETE node>>
    fprint(STDERR, "\n");

    <<[[waitup()]] when error in child process, if kflag>>
    else {
        jobs = nil;
        Exit();
    }
}
@
% nice shprint! see final command with expanded variables!

<<[[waitup()]] skip if node not found>>=
if(sym == nil)
    continue;	/* not interested in this node */
@
\t should never happen I think, cos node list is made with
\t  node we are interested in

% because up to date target anyway?

<<function front>>=
void
front(char *s)
{
    char *t, *q;
    int i, j;
    char *flds[512];

    q = strdup(s);
    i = getfields(q, flds, nelem(flds), 0, " \t\n");
    if(i > 5){
        flds[4] = flds[i-1];
        flds[3] = "...";
        i = 5;
    }
    t = s;
    for(j = 0; j < i; j++){
        for(s = flds[j]; *s; *t++ = *s++);
        *t++ = ' ';
    }
    *t = 0;
    free(q);
}
@
\t ??? getfields?


\subsection{[[update()]]}

% mk -> waitup -> <>
<<function update>>=
void
update(bool fake, Node *node)
{
    Arc *a;

    MADESET(node, fake? BEINGMADE : MADE);
    <<[[update()]] debug>>


    if((!(node->flags&VIRTUAL)) && (access(node->name, AEXIST) == 0)){
        node->time = timeof(node->name, true);
        <<[[update()]] unpretend node>>
        <<[[update()]] set outofdate prereqs if arc prog>>
    } 
    else {
        // virtual target or target still does not exist (but marked as MADE)
        node->time = 1;
        for(a = node->prereqs; a; a = a->next)
            if(a->n && outofdate(node, a, true))
                node->time = a->n->time;
    }
}
@
% pass true to outofdate here!!
% pass true to timeof, to force, to not use the cache because indeed
%  time probably changed
% why set time to 1 for virtual node? just to be different than None
%  and then anway later take latest time of one of the prereq
\t but then what if no prereq? then time is 1. important?

% so if target not exist, still put MADE for node
% because anyway, otherwise would loop infinitely.
% and set date of newest prereq.





\section{Process management}

% cant just exit with processes hanging out.
% wait at least until job finished.

\subsection{[[Exit()]]}

<<function Exit>>=
void
Exit(void)
{
    while(waitpid() >= 0)
        ;
    exits("error");
}
@

% Malloc, Realloc, they call Exit in case of error.
% there should be no calls directly to exits

%trans:
% good to wait, but what if too long recipe? % enter C-c!


\subsection{Signals/Notes management}
% [[C-c]]

<<[[main()]] initializations before building>>=
catchnotes();
@
%old: argv processing part 3 was there before, in the middle


% main -> <>
<<function catchnotes>>=
void
catchnotes()
{
    atnotify(notifyf, 1);
}
@

<<function notifyf>>=
int
notifyf(void *a, char *msg)
{
    <<[[notifyf()]] sanity check not too many notes>>
    if(strcmp(msg, "interrupt")!=0 && strcmp(msg, "hangup")!=0)
        return 0;
    killchildren(msg);
    return -1;
}
@
% 0 -> IGNORE_NOTE?


<<[[notifyf()]] sanity check not too many notes>>=
static int nnote;

USED(a);
if(++nnote > 100){	/* until andrew fixes his program */
    fprint(STDERR, "mk: too many notes\n");
    notify(0);
    abort();
}
@

\subsection{Killing all children}

\subsubsection{[[killchildren()]]}

<<function killchildren>>=
void
killchildren(char *msg)
{
    <<[[killchildren()]] locals>>

    kflag = true;	/* to make sure waitup doesn't exit */
    jobs = nil;		/* make sure no more get scheduled */

    <<[[killchildren()]] expunge not-job processes>>

    while(waitup(1, (int *)nil) == 0)
        ;
    Bprint(&bout, "mk: %s\n", msg);
    Exit();
}
@
\t 0 -> WJobEnded
\t 1 -> EmptyChildOk

% so at some point should get WEmptyChild
% (or WNotJobProcessDone but would be weird)

\l why not send also postnote to job child process?

\subsubsection{[[kflag]] and [[runerrs]]}

% kflag also used for mk -k, but does not make much sense I think.

<<global kflag>>=
bool kflag = false;
@
% continue even if errors.
% not so useful in general, but useful for killchildren when get a C-c ???
<<[[main()]] -xxx switch cases>>=
case 'k':
    kflag = true;
    break;
@


<<global runerrs>>=
int runerrs;
@
<<[[mk()]] initialisation>>=
runerrs = 0;
@



\subsubsection{Adjusting [[mk()]], [[work()]], and [[waitup()]]}

% instead of Exit
<<[[work()]] when inexistent target without prerequisites, if kflag>>=
if(kflag){
    node->flags |= BEINGMADE;
    runerrs++;
}
@

% instead of Exit again
<<[[waitup()]] when error in child process, if kflag>>=
if(kflag){
    runerrs++;
    fake = true;
}
@
% fake so BEINGMADE instead of MADE


<<[[mk()]] if no child to waitup and root not MADE, possibly break>>=
if(res > 0){
    if(root->flags&(NOTMADE|BEINGMADE)){
        assert(/*must be run errors*/ runerrs);
        break;	/* nothing more waiting */
    }
}
@
\t res == WEmptyChild ?

% subtle
<<[[main()]] before returning, more [[waitup()]] if there was an error>>=
while(jobs)
    waitup(-2, (int *)nil);

assert(/*target didnt get done*/ runerrs || (root->flags&MADE));
@
\t when do we have this? really need that?






\chapter{Interacting with the Shell}

% The recipe is a shell command (or multiple commands).
% Seen execsh() above with global shell, shellname stuff. 
%  (already plan9 specific and some stuff rc specific)
% was taking an Envy because recipe can contain variables.
% buildenv() in sched() before execsh, passing an Envy.

%\section{Variables expansion (part 3)}
% not done actually! shell does it!  simpler! no $$i mess. simplify some things.

%real-world:
% mk simpler than make on this. no Make variables vs shell variables.
% (but then stronger coupling with the shell language? portable?)

% variables, different occurences: in rule target, prerequistes,
% or in recipe. Different handling depending on context.
% See quote from mk manual.

\section{[[Envy]] and [[envy]]}
%\section{Environment Variables, [[Envy]] and [[envy]]}
% could be in core DS, but used just here, and outside S_VAR is good enough.

\t Not envy :) just environment variable stuff, rename? Env and env?
<<struct Envy>>=
struct Envy
{
    // ref<string>, the key
    char 		*name;

    // list<ref_own<string>>, the value
    Word 		*values;
};
@
\l why y?


<<global envy>>=
// growing_array<Envy> (endmarker = nil,nil)
Envy	*envy;
@
%ocaml: just use a hashtbl and reuse env (hash). useless I think to optimize.

%use special data structure with special marks because used in
% special way. Have first full static environment and then
% each time different value for special mk variables ($stem, $target).

<<constant ENVQUANTA>>=
#define ENVQUANTA 10
@

<<global nextv>>=
// idx for next free entry in envy array
static int nextv;
@

% envupd | ecopy | execinit -> <>
<<function envinsert>>=
static void
envinsert(char *name, Word *value)
{
    static int envsize;

    // grow array if necessary
    if (nextv >= envsize) {
        envsize += ENVQUANTA;
        envy = (Envy *) Realloc((char *) envy, envsize*sizeof(Envy));
    }

    envy[nextv].name = name;
    envy[nextv++].values = value;
}
@
%ocaml: just Hashtbl.add


<<function envupd>>=
static void
envupd(char *name, Word *value)
{
    Envy *e;

    for(e = envy; e->name; e++)
        if(strcmp(name, e->name) == 0){
            delword(e->values);
            e->values = value;
            return;
        }
    e->name = name;
    e->values = value;
    envinsert(nil,nil); // ???
}
@
\t else if not found, generate error! 
\t could also just call simply envinsert(e->name, value) instead
\t of this envinsert(nil,nil), but then this would require
\t  to have access to nextv in envupd too.
%ocaml: just Hashtbl.replace

% what is this nil,nil? to make a special mark in envy.
%  because then use e->name termination condition.
%  because growing array and special end marker!

\section{Initializing the environment, [[execinit()]]}
% as opposed to make, no $(XX), no $$i, the string is passed
% as is to shell! less escaping need!

<<[[main()]] initializations before building>>=
execinit();
@
%ocaml: just reuse env, no need for another environment-like data structure.


% main -> parse; mk; <>
<<function execinit>>=
void
execinit(void)
{
    char **p;

    nextv = 0; // reset envy

    // internal mk variables
    for(p = myenv; *p; p++)
        envinsert(*p, stow(""));

    // user variables in mkfile or process shell environment
    symtraverse(S_VAR, ecopy);

    // end marker
    envinsert(nil, nil);
}
@
\l potential leak when reset on Envy.values ?
\t again nil,nil insert because nextv is static. Should be global!
\t rename initenv() for that!

%note that internal vars are put first in Envy because they are the one
% that will be updated! so want fast iteration there.

% use myenv also in initenv(inithash), but it is for the S_INTERNAL stuff and
%  used later for readenv

% execinit -> symtraverse -> <> (as x <- symtraverse(..., <>) <- execinit)
<<function ecopy>>=
static void
ecopy(Symtab *s)
{
    char **p;

    <<[[ecopy()]] return and do not copy if S_NOEXPORT symbol>>
    <<[[ecopy()]] return and do not copy if conflict with mk internal variable>>
     // else
     envinsert(s->name, s->u.ptr);
}
@
%ocaml: just Hashtbl.copy, but not even sure we need that

<<[[ecopy()]] return and do not copy if conflict with mk internal variable>>=
for(p = myenv; *p; p++)
    if(strcmp(*p, s->name) == 0)
        return;
@
% maybe should issue a warning? anyway it is only for user variables
%  because for readenv(), those variables are skipped.
%ocaml-found:
% when use mk recursively, you will get a $stem in the environment! and
% you need to filter it otherwise in exportenv you would need to take care
% of duplicate and give priority to the fresh $stem


\section{Importing the external environment, [[readenv()]]}

% popupate symbol table, but by transitivity it populates
% also envy at some point because of execinit

% plan9 specific, in plan9.c
% initenv -> <>
<<function readenv>>=
void
readenv(void)
{
    fdt envf; // envdir
    fdt f; // envfile
    Dir *e;
    int i, n, len, len2;
    char *p;
    char nam[1024];
    Word *w;

    rfork(RFENVG);	/*  use copy of the current environment variables */

    envf = open("/env", OREAD);
    <<[[readenv()]] sanity check envf>>
    while((n = dirread(envf, &e)) > 0){
        for(i = 0; i < n; i++){
            len = e[i].length;
            <<[[readenv()]] skip some names>>

            snprint(nam, sizeof nam, "/env/%s", e[i].name);
            f = open(nam, OREAD);
            <<[[readenv()]] sanity check f>>
            p = Malloc(len+1);
            len2 = read(f, p, len);
            <<[[readenv()]] sanity check len2>>
            close(f);
            <<[[readenv()]] add null terminator character at end of [[p]]>>
            w = encodenulls(p, len);
            free(p);
            p = strdup(e[i].name);

            // populating symbol table
            setvar(p, (void *) w);
        }
        free(e);
    }
    close(envf);
}
@

%dead: 
% <<[[Sxxx]] cases>>=
% S_EXPORTED,	/* var -> current exported value */
% @
%  symlook(p, S_EXPORTED, (void*)"")->u.ptr = "";


<<[[readenv()]] skip some names>>=
/* don't import funny names, NULL values,
 * or internal mk variables
 */
if(len <= 0 || *shname(e[i].name) != '\0')
    continue;
if (symlook(e[i].name, S_INTERNAL, nil))
    continue;
@
%alt: could import variables with same name, just give priority to
% S_INTERNAL when lookup

<<[[readenv()]] add null terminator character at end of [[p]]>>=
if (p[len-1] == '\0')
    len--;
else
    p[len] = '\0';
@
% why? some variable have and some have not? not specified in plan9?

<<[[readenv()]] sanity check envf>>=
if(envf < 0)
    return;
@
<<[[readenv()]] sanity check f>>=
if(f < 0)
    continue;
@

<<[[readenv()]] sanity check len2>>=
if(len2 != len){
    perror(nam);
    close(f);
    continue;
}
@


<<function encodenulls>>=
/* break string of values into words at 01's or nulls*/
static Word *
encodenulls(char *s, int n)
{
    Word *w, *head;
    char *cp;

    head = w = nil;
    while (n-- > 0) {
        for (cp = s; *cp && *cp != '\0'; cp++)
                n--;
        *cp = '\0';

        // add_list(newword(s), w)
        if (w) {
            w->next = newword(s);
            w = w->next;
        } else
            head = w = newword(s);

        s = cp+1;
    }
    if (!head)
        head = newword("");
    return head;
}
@


\section{Adjusting the environment, [[buildenv()]]}

% ->  run -> sched -> <>
<<function buildenv>>=
Envy*
buildenv(Job *j, int slot)
{
    <<[[buildenv()]] locals>>

    // main variables 
    envupd("target", wdup(j->t));
    <<[[buildenv()]] if regexp rule>>
    else
        envupd("stem", newword(j->stem));
    envupd("prereq", wdup(j->p));

    // advanced variables 
    <<[[buildenv()]] envupd some variables>>

    return envy;
}
@
\t rename adjustenv? or instantiate_env?




\section{Exporting the environment, [[exportenv()]]}

% execsh -> <>
<<function exportenv>>=
/* as well as 01's, change blanks to nulls, so that rc will
 * treat the words as separate arguments
 */
void
exportenv(Envy *e)
{
    Symtab *sy;
    int n;
    fdt f;
    bool hasvalue;
    bool first;
    Word *w;
    char nam[256];

    for(;e->name; e++){
        sy = symlook(e->name, S_VAR, nil);
        if (e->values == nil || e->values->s == nil || e->values->s[0] == '\0')
            hasvalue = false;
        else
            hasvalue = true;
        if(sy == nil && !hasvalue)	/* non-existant null symbol */
            continue;
        // else

        snprint(nam, sizeof nam, "/env/%s", e->name);
        <<[[exportenv()]] if existing symbol but not value, remove from env>>
        // else
    
        f = create(nam, OWRITE, 0666L);
        <<[[exportenv()]] sanity check f>>
        first = true;
        for (w = e->values; w; w = w->next) {
            n = strlen(w->s);
            if (n) {
                <<[[exportenv()]] write null separator>>
                if (write(f, w->s, n) != n)
                    perror(nam);
            }
        }
        close(f);
    }
}
@
\t rename sy to sym, more consistent

<<[[exportenv()]] write null separator>>=
if(first)
    first = false;
else{
    if (write (f, "\0", 1) != 1)
        perror(nam);
}
@

<<[[exportenv()]] if existing symbol but not value, remove from env>>=
if (sy != nil && !hasvalue) {	/* Remove from environment */
    /* we could remove it from the symbol table
     * too, but we're in the child copy, and it
     * would still remain in the parent's table.
     */
    remove(nam);
    delword(e->values);
    e->values = nil;		/* memory leak */
    continue;
}
@

<<[[exportenv()]] sanity check f>>=
if(f < 0) {
    fprint(STDERR, "can't create %s, f=%d\n", nam, f);
    perror(nam);
    continue;
}
@





\chapter{Debugging and Profiling Support}


% seen file/line fields in Rule, so can report error accurately.

\section{Printing jobs, [[shprint()]]}
\l not sure it can be considered a debugging facility, more mandatory

% With use of variables, can be hard to know what was actually executed
% so when there is an error, useful to expand those vars.

% There are some bugs though, so do not trust completely.

<<[[sched()]] other locals>>=
Bufblock *buf;
@

<<[[sched()]] print recipe command on stdout>>=
buf = newbuf();
shprint(j->r->recipe, e, buf);
if(!tflag && (nflag || !(j->r->attr&QUIET)))
    Bwrite(&bout, buf->start, (long)strlen(buf->start));
freebuf(buf);
@
\t should do shprint inside the if, useless otherwise

%\subsection{[[shprint()]]}

% called to print what mk is executing, and also when error in a child.

% sched | update -> <> 
<<function shprint>>=
void
shprint(char *s, Envy *env, Bufblock *buf)
{
    Rune r;
    int n;

    while(*s) {
        n = chartorune(&r, s);
        if (r == '$')
            s = vexpand(s, env, buf);
        else {
            rinsert(buf, r);
            s += n;
            s = copyq(s, r, buf);	/*handle quoted strings*/
        }
    }
    insert(buf, 0);
}
@
%$
\l abuse s as argument and iterator. Maybe could do char *p = s; 

\subsection{Variables}
% part 4?

<<function vexpand>>=
static char*
vexpand(char *w, Envy *env, Bufblock *buf)
{
    char *s;
    char *p, *q;
    char carry;

    assert(/*vexpand no $*/ *w == '$');
    p = w+1;	/* skip dollar sign */
    if(*p == '{') {
        p++;
        q = utfrune(p, '}');
        if (!q)
            q = strchr(p, 0);
    } else
        q = shname(p);

    carry = *q;
    *q = '\0';
    s = mygetenv(p, env);
    *q = carry;

    if (carry == '}')
        q++;

    if (s) {
        bufcpy(buf, s, strlen(s));
        free(s);
    } else 		/* copy name intact*/
        bufcpy(buf, w, q-w);

    return q;
}
@
\l rename carry to savechar?

% either $xxx where xxx must be part of certain chars
% or ${...} and can be anything inside

<<function shname>>=
char *
shname(char *a)
{
    Rune r;
    int n;

    while (*a) {
        n = chartorune(&r, a);
        if (!WORDCHR(r))
            break;
        a += n;
    }
    return a;
}
@


% expand only "recognizable" ("interesting") variables

<<function mygetenv>>=
static char*
mygetenv(char *name, Envy *env)
{
    if (!env)
        return nil;
    if (!symlook(name, S_WESET, nil) && 
        !symlook(name, S_INTERNAL, nil))
        return nil;
    // else

    /* only resolve internal variables and variables we've set */
    for(; env->name; env++){
        if (strcmp(env->name, name) == 0)
            return wtos(env->values, ' ');
    }
    return nil;
}
@


<<[[Sxxx]] cases>>=
S_WESET,	/* variable; we set in the mkfile */
@
% set in mkfile or via mk xxx=yyy? when mk xxx=yyy, varoverride is true
%  so also S_WESET i guess.
% useful for shprint, to expand only weset variables.

<<[[parse()]] when parsing variable definitions, extra setting>>=
symlook(head->s, S_WESET, (void *)"");
@


\subsection{Quoted strings}
% part 4?

% -> <>
<<function copyq>>=
/*
 *	check for quoted strings.  backquotes are handled here; single quotes above.
 *	s points to char after opening quote, q.
 */
char *
copyq(char *s, Rune q, Bufblock *buf)
{
    if(q == '\'')				/* copy quoted string */
        return copysingle(s, buf);

    if(q != '`')				/* not quoted */
        return s;
    // else

    while(*s){				/* copy backquoted string */
        s += chartorune(&q, s);
        rinsert(buf, q);
        if(q == '}')
            break;
        if(q == '\'')
            s = copysingle(s, buf);	/* copy quoted string */
    }
    return s;
}
@

<<function copysingle>>=
/*
 *	copy a single-quoted string; s points to char after opening quote
 */
static char *
copysingle(char *s, Bufblock *buf)
{
    Rune r;

    while(*s){
        s += chartorune(&r, s);
        rinsert(buf, r);
        if(r == '\'')
            break;
    }
    return s;
}
@



\section{Explain mode, [[mk -e]]}

<<global explain>>=
bool explain = false;
@
% used to a char*
<<[[main()]] -xxx switch cases>>=
case 'e':
    explain = true;
    break;
@


<<[[dorecipe()]] explain when found arc [[a]] making target [[n]] out of date>>=
if(explain)
    fprint(STDOUT, "%s(%ld) < %s(%ld)\n",
        n->name, n->time, a->n->name, a->n->time);
@

<<[[dorecipe()]] explain when found target [[n]] with no prerequisite>>=
if(explain)
    fprint(STDOUT, "%s has no prerequisites\n", n->name);
@

\section{Dry mode, [[mk -n]]}

% just print recipe, do not execute them
<<global nflag>>=
bool nflag = false;
@
<<[[main()]] -xxx switch cases>>=
case 'n':
    nflag = true;
    break;
@

<<[[sched()]] other locals>>=
Node *n;
@
<<[[sched()]] if dry mode or touch mode, alternate to execsh>>=
if(nflag || tflag){
    for(n = j->n; n; n = n->next){
        <<[[sched()]] if touch mode>>
        n->time = time((long *)nil);
        MADESET(n, MADE);
    }
}
@
% marked as MADE (and still print recipe)

\section{What if, [[mk -w]]{\em file}}

% what if I change a file, what needs to be done?
% usually works with -n, mk -n -wprog.h

<<[[main()]] locals>>=
Bufblock *whatif = nil;
@

<<[[main()]] -xxx switch cases>>=
case 'w':
    if(whatif == nil)
        whatif = newbuf();
    else
        insert(whatif, ' ');
    if(argv[0][2])
        bufcpy(whatif, &argv[0][2], strlen(&argv[0][2]));
    else {
        if(*++argv == '\0')
            badusage();
        bufcpy(whatif, &argv[0][0], strlen(&argv[0][0]));
    }
    break;
@
\t why not use Words instead? since you join to later split

<<[[main()]] initializations before building>>=
if(whatif){
    insert(whatif, '\0');
    timeinit(whatif->start);
    freebuf(whatif);
}
@
%old: was before execinit, catchnotes before, but I dont think it matters

% fake time of file to be just modified now by modifying the time cache
<<function timeinit>>=
void
timeinit(char *s)
{
    ulong t;
    char *cp;
    Rune r;
    int c, n;

    t = time(nil);
    while (*s) {
        cp = s;
        do{
            n = chartorune(&r, s);
            if (r == ' ' || r == ',' || r == '\n')
                break;
            s += n;
        } while(*s);
        c = *s;
        *s = '\0';

        symlook(strdup(cp), S_TIME, (void *)t)->u.value = t;

        if (c)
            *s++ = c;
        while(*s){
            n = chartorune(&r, s);
            if(r != ' ' && r != ',' && r != '\n')
                break;
            s += n;
        }
    }
}
@

%related: buck query, but operates on hundreds of .buck files so can
% answer complex queries?

%\chapter{Profiling Support}

\section{Processor utilization, [[mk -u]]}

% display time spent in different nrunnning configuration
% also display time to parse and build graph since at that time
%  nrunning is zero.

<<global uflag>>=
bool uflag = false;
@
<<[[main()]] -xxx switch cases>>=
case 'u':
    uflag = true;
    break;
@


<<global tslot>>=
// map<nrunning, int>
static ulong tslot[1000];
@
% must be more than nproclimit

% could be made local static!
<<global tick>>=
static ulong tick;
@

<<[[main()]] setup profiling>>=
usage();
@

<<[[main()]] profile initializations>>=
usage();
@
%old: used to be just after initenv() (=~ inithash()), but I think ok 
% to do after.

% called from many places
<<function usage>>=
void
usage(void)
{
    ulong t;

    t = time(0);
    if(tick)
        tslot[nrunning] += t - tick;
    tick = t;
}
@
\t rename usage, to profile







<<[[main()]] print profiling stats if uflag>>=
if(uflag)
    prusage();
@

<<function prusage>>=
void
prusage(void)
{
    int i;

    usage();
    for(i = 0; i <= nevents; i++)
        fprint(STDOUT, "%d: %lud\n", i, tslot[i]);
}
@
% nevents = nproclimit



\chapter{Advanced Features}

\section{Regular-expression rules, [[:R:]]}

% use libregexp/: regcomp(), regexec(), regsub()

%in sys/src/cmd/mkfile
%^([$OS])\.(.*):R:	\2.\1
%	$stem1^l -o $target $stem2.$stem1
%
%.*\.[$OS]:R:	$HFILES
%
%(.*)\.([$OS])'$':R:	\1.c
%	$stem2^c $CFLAGS $stem1.c


<<[[Rule_attr]] cases>>=
REGEXP = 0x0020,
@
<<[[rhead()]] when parsing rule attributes, switch rune cases>>=
case 'R':
    *attr |= REGEXP;
    break;
@

% need attribute, otherwise no way to infer that quoted regexp
% is a regexp and not a weird filename
% (for %& we look outside quoted strings with charin())

<<[[Rule]] other fields>>=
Reprog		*pat;		/* reg exp goo */
@


% this is for error managment, regcomp can probably trigger
% the regerror callback! subtle!
<<global patrule>>=
Rule *patrule;
@

<<[[addrule()]] if REGEXP attribute>>=
if(attr&REGEXP){
    patrule = r;
    r->pat = regcomp(head);
}
@


<<[[dorecipe()]] if regexp rule>>=
if(r->attr&REGEXP){
    ww->next = newword(node->name);
    aw->next = newword(node->name);
}
@

<<[[buildenv()]] if regexp rule>>=
if(j->r->attr&REGEXP)
    envupd("stem", newword(""));
@
% instead use stem1, stem2, etc

<<function regerror>>=
//@Scheck: not dead, called via regcomp() when have regexp syntax error
void regerror(char *s)
{
    if(patrule)
        fprint(STDERR, "mk: %s:%d: regular expression error; %s\n",
            patrule->file, patrule->line, s);
    else
        fprint(STDERR, "mk: %s:%d: regular expression error; %s\n",
            infile, mkinline, s);
    Exit();
}
@


<<constant NREGEXP>>=
#define		NREGEXP		10
@
% so stem1, stem2, stem9

% instead of stem
<<[[Arc]] other fields>>=
char		*match[NREGEXP];
@

<<[[newarc()]] set other fields>>=
rcopy(a->match, match, NREGEXP);
@

<<function rcopy>>=
void
rcopy(char **to, Resub *match, int n)
{
    int c;
    char *p;

    *to = match->sp;		/* stem0 matches complete target */
    for(to++, match++; --n > 0; to++, match++){
        if(match->sp && match->ep){
            p = match->ep;
            c = *p;
            *p = 0;
            *to = strdup(match->sp);
            *p = c;
        }
        else
            *to = 0;
    }
}
@


% instead of stem
<<[[Job]] other fields>>=
char		**match;
@

<<[[myenv]] other array elements>>=
"stem0",		/* must be in order from here */
"stem1",
"stem2",
"stem3",
"stem4",
"stem5",
"stem6",
"stem7",
"stem8",
"stem9",
@

<<[[buildenv()]] locals>>=
char **p;
int i;
@

<<[[buildenv()]] envupd some variables>>=
/* update stem0 -> stem9 */
for(p = myenv; *p; p++)
    if(strcmp(*p, "stem0") == 0)
        break;
for(i = 0; *p; i++, p++){
    if((j->r->attr&REGEXP) && j->match[i])
        envupd(*p, newword(j->match[i]));
    else 
        envupd(*p, newword(""));
}
@

<<[[applyrules]] other locals>>=
Resub rmatch[NREGEXP];
@
<<[[applyrules]] set rmatch>>=
memset((char*)rmatch, 0, sizeof(rmatch));
@
% rmatch??? for metarules? for newarc?

<<[[applyrules()]] if regexp rule then continue if some conditions>>=
if(r->attr&REGEXP){
    stem[0] = '\0';
    memset((char*)rmatch, 0, sizeof(rmatch));
    patrule = r;
    if(regexec(r->pat, node->name, rmatch, NREGEXP) == 0)
        continue;
}
@

<<[[applyrules()]] if regexp rule, adjust buf and rmatch>>=
if(r->attr&REGEXP)
    regsub(w->s, buf, sizeof(buf), rmatch, NREGEXP);
@

\section{Dynamic [[mkfile]], [[<|]]{\em prog}}

% How to do the ifdef I use in pfff's makefiles?

% Useful to provide an alternative to ifdef in Make.
% instead you put the configurable part in an external
% shell program that just does some echo FOO=X.

<<[[rhead()]] adjust sep if dynamic mkfile [[<|]]>>=
if(sep == '<' && *p == '|'){
    sep = '|';
    p++;
}
@

% mkfile content through pipe
% <|cmd  instead of <file

<<[[parse()]] other locals>>=
int pid;
@
% abused to store pid and later return status

<<[[parse()]] switch rhead cases>>=
case '|':
    p = wtos(tail, ' ');
    if(*p == '\0'){
        SYNERR(-1);
        fprint(STDERR, "missing include program name\n");
        Exit();
    }

    execinit();
    pid = pipecmd(p, envy, &newfd);
    if(newfd < 0){
        fprint(STDERR, "warning: skipping missing program file: ");
        perror(p);
    } else
        parse(p, newfd, 0);
    while(waitup(-3, &pid) >= 0)
        ;
    if(pid != 0){
        fprint(STDERR, "bad include program status\n");
        Exit();
    }
    break;
@
% why use waitup? it's a parsing time, so there should be no jobs
% yet so stupid to introduce Process machinery for that.

% execinit cos command string can contain variables?

%plan9.c
<<function pipecmd>>=
int
pipecmd(char *cmd, Envy *e, int *fd)
{
    int pid;
    fdt pfd[2];

    if(DEBUG(D_EXEC))
        fprint(STDOUT, "pipecmd='%s'\n", cmd);/**/

    if(fd && pipe(pfd) < 0){
        perror("pipe");
        Exit();
    }
    pid = rfork(RFPROC|RFFDG|RFENVG);
    if(pid < 0){
        perror("mk fork");
        Exit();
    }
    if(pid == 0){
        if(fd){
            close(pfd[0]);
            dup(pfd[1], 1);
            close(pfd[1]);
        }
        if(e)
            exportenv(e);
        if(shflags)
            execl(shell, shellname, shflags, "-c", cmd, nil);
        else
            execl(shell, shellname, "-c", cmd, nil);
        perror(shell);
        _exits("exec");
    }
    if(fd){
        close(pfd[1]);
        *fd = pfd[0];
    }
    return pid;
}
@



\section{Shell-command expansion, [[`]]{\em cmd}[[`]]}

% actually two styles, `{...} or `...`

<<[[assline()]] switch character cases>>=
case '`':
    if (bquote(bp, buf) == ERROR_0)
        Exit();
    break;
@

\subsection{[[bquote()]]}

<<function bquote>>=
/*
 *	assemble a back-quoted shell command into a buffer
 */
static error0
bquote(Biobuf *bp, Bufblock *buf)
{
    int c, line, term;
    int start;

    line = mkinline;
    while((c = Bgetrune(bp)) == ' ' || c == '\t')
            ;
    if(c == '{'){
        term = '}';		/* rc style */
        while((c = Bgetrune(bp)) == ' ' || c == '\t')
            ;
    } else
        term = '`';		/* sh style */

    start = buf->current - buf->start;
    for(;c > 0; c = nextrune(bp, false)){
        if(c == term){
            insert(buf, '\n');
            insert(buf, '\0');
            buf->current = buf->start + start;

            execinit();
            // running the command, passing a buf argument
            execsh(nil, buf->current, buf, envy);

            return OK_1;
        }
        if(c == '\n')
            break;
        if(c == '\'' || c == '"' || c == '\\'){
            insert(buf, c);
            if(!escapetoken(bp, buf, 1, c))
                return ERROR_0;
            continue;
        }
        rinsert(buf, c);
    }
    SYNERR(line);
    fprint(STDERR, "missing closing %c after `\n", term);
    return ERROR_0;
}
@

% pass false to nextrune, so do not elide

\subsection{Adjusting [[execsh()]]}

% but so different that maybe should write another function
% instead of trying to factorize too much.


<<[[execsh()]] other locals>>=
fdt out[2];
@
<<[[execsh()]] if buf then create pipe to save output>>=
if(buf && pipe(out) < 0){
    perror("pipe");
    Exit();
}
@

<<[[execsh()]] in children, if buf, close one side of pipe>>=
if(buf)
    close(out[0]);
@

<<[[execsh()]] in child 1, if buf, dup and close>>=
if(buf){
    // output now goes in the pipe
    dup(out[1], STDOUT);
    close(out[1]);
}
@

<<[[execsh()]] in child 2, if buf, close other side of pipe>>=
if(buf)
    close(out[1]);
@
%bug: %pad: was not guared by if(buf), but was bug I think



<<[[execsh()]] other locals>>=
int tot, n;
@

<<[[execsh()]] in parent, if buf, close other side of pipe and read output>>=
if(buf){
    close(out[1]);
    tot = 0;
    for(;;){
        if (buf->current >= buf->end)
            growbuf(buf);
        n = read(out[0], buf->current, buf->end-buf->current);
        if(n <= 0)
            break;
        buf->current += n;
        tot += n;
    }
    if (tot && buf->current[-1] == '\n')
        buf->current--;
    close(out[0]);
}
@

\section{Complex variable uses, [[${]]{\em \ldots}[[}]]}
%$

% note that can use ${x:%=%} only outside recipe :(
% they are not recognized by the shell and recipe are
% not processed by mk.
% So variables are a bit leaky abstraction. Vars in targets/prereqs
% are treated differently than in recipe.

% charin -> <>
<<[[varsub()]] if variable starts with open brace>>=
if(**s == '{')		/* either ${name} or ${name: A%B==C%D}*/
    return expandvar(s);
@

<<function expandvar>>=
static Word*
expandvar(char **s)
{
    Word *w;
    Bufblock *buf;
    Symtab *sym;
    char *cp, *begin, *end;

    begin = *s;
    (*s)++;						/* skip the '{' */
    buf = varname(s);
    if (buf == nil)
        return nil;
    cp = *s;
    if (*cp == '}') {				/* ${name} variant*/ //$
        (*s)++;					/* skip the '}' */
        w = varmatch(buf->start);
        freebuf(buf);
        return w;
    }


    if (*cp != ':') {
        SYNERR(-1);
        fprint(STDERR, "bad variable name <%s>\n", buf->start);
        freebuf(buf);
        return nil;
    }
    cp++;
    end = charin(cp , "}");
    if(end == nil){
        SYNERR(-1);
        fprint(STDERR, "missing '}': %s\n", begin);
        Exit();
    }
    *end = '\0';
    *s = end+1;
    
    sym = symlook(buf->start, S_VAR, 0);
    if(sym == nil || sym->u.value == 0)
        w = newword(buf->start);
    else
        w = subsub(sym->u.ptr, cp, end);
    freebuf(buf);
    return w;
}
@
%$

% note that does not support recursive vars! like ${name:${O}%.c=%.o}

<<function subsub>>=
static Word*
subsub(Word *v, char *s, char *end)
{
    int nmid;
    Word *head, *tail, *w, *h;
    Word *a, *b, *c, *d;
    Bufblock *buf;
    char *cp, *enda;

    a = extractpat(s, &cp, "=%&", end);
    b = c = d = nil;
    if(PERCENT(*cp))
        b = extractpat(cp+1, &cp, "=", end);
    if(*cp == '=')
        c = extractpat(cp+1, &cp, "&%", end);
    if(PERCENT(*cp))
        d = stow(cp+1);
    else if(*cp)
        d = stow(cp);

    head = tail = nil;
    buf = newbuf();
    for(; v; v = v->next){
        h = w = 0;
        if(submatch(v->s, a, b, &nmid, &enda)){
            /* enda points to end of A match in source;
             * nmid = number of chars between end of A and start of B
             */
            if(c){
                h = w = wdup(c);
                while(w->next)
                    w = w->next;
            }
            if(PERCENT(*cp) && nmid > 0){	
                if(w){
                    bufcpy(buf, w->s, strlen(w->s));
                    bufcpy(buf, enda, nmid);
                    insert(buf, '\0');
                    free(w->s);
                    w->s = strdup(buf->start);
                } else {
                    bufcpy(buf, enda, nmid);
                    insert(buf, '\0');
                    h = w = newword(buf->start);
                }
                buf->current = buf->start;
            }
            if(d && *d->s){
                if(w){

                    bufcpy(buf, w->s, strlen(w->s));
                    bufcpy(buf, d->s, strlen(d->s));
                    insert(buf, '\0');
                    free(w->s);
                    w->s = strdup(buf->start);
                    w->next = wdup(d->next);
                    while(w->next)
                        w = w->next;
                    buf->current = buf->start;
                } else
                    h = w = wdup(d);
            }
        }
        if(w == 0)
            h = w = newword(v->s);
    
        if(head == 0)
            head = h;
        else
            tail->next = h;
        tail = w;
    }
    freebuf(buf);
    delword(a);
    delword(b);
    delword(c);
    delword(d);
    return head;
}
@

% another parsing function ...
% subsub -> <>
<<function extractpat>>=
static Word*
extractpat(char *s, char **r, char *term, char *end)
{
    int save;
    char *cp;
    Word *w;

    cp = charin(s, term);
    if(cp){
        *r = cp;
        if(cp == s)
            return nil;
        save = *cp;
        *cp = '\0';
        w = stow(s);
        *cp = save;
    } else {
        *r = end;
        w = stow(s);
    }
    return w;
}
@

% subsub -> <>
<<function submatch>>=
static bool
submatch(char *s, Word *a, Word *b, int *nmid, char **enda)
{
    Word *w;
    int n;
    char *end;

    n = 0;
    for(w = a; w; w = w->next){
        n = strlen(w->s);
        if(strncmp(s, w->s, n) == 0)
            break;
    }
    if(a && w == nil)		/*  a == NULL matches everything*/
        return false;

    *enda = s+n;		/* pointer to end a A part match */
    *nmid = strlen(s)-n;	/* size of remainder of source */
    end = *enda+*nmid;
    for(w = b; w; w = w->next){
        n = strlen(w->s);
        if(strcmp(w->s, end-n) == 0){
            *nmid -= n;
            break;
        }
    }
    if(b && w == nil)		/* b == NULL matches everything */
        return false;
    return true;
}
@


\section{Advanced rule attributes}

\subsection{Virtual target, [[:V:]]}

% this is useful

% ex, clean:V: so even if there is a file called clean
% in the directory (and no prereqs),
%  mk clean   will still run the recipe
% or all:V: $PROG in mkone

<<[[Rule_attr]] cases>>=
VIR    = 0x0010,
@
<<[[rhead()]] when parsing rule attributes, switch rune cases>>=
case 'V':
    *attr |= VIR;
    break;
@

<<[[Node_flag]] cases>>=
VIRTUAL    = 0x0001,
@
<<[[attribute()]] propagate rule attribute to node cases>>=
if(a->r->attr&VIR)
    n->flags |= VIRTUAL;
@


<<[[attribute()]] if virtual node>>=
if(n->flags&VIRTUAL)
    n->time = 0;
@
%ocaml-found:
% need that because maybe there was a file with the same name
% than the virtual target in the directory
% with a date that timeof would have used! then maybe this
% date was very recent, more recent than the prereqs and
% so the recipe will not have been triggered.

\subsection{Deleting target when recipe returns an error, [[:D:]]}

% seems safe, but really the tool involved should not generate
% the target in the first place.

<<[[Rule_attr]] cases>>=
DEL    = 0x0080,
@
<<[[rhead()]] when parsing rule attributes, switch rune cases>>=
case 'D':
    *attr |= DEL;
    break;
@

<<[[Node_flag]] cases>>=
DELETE     = 0x0800,
@
<<[[attribute()]] propagate rule attribute to node cases>>=
if(a->r->attr&DEL)
    n->flags |= DELETE;
@





<<[[waitup()]] other locals>>=
Node *n;
bool done;
@

<<[[waitup()]] when error in child process, delete if DELETE node>>=
for(n = j->n, done = false; n; n = n->next)
    if(n->flags&DELETE){
        if(!done) {
            fprint(STDERR, ", deleting");
            done = true;
        }
        fprint(STDERR, " '%s'", n->name);
        delete(n->name);
    }
@
%old: if(done++ == 0)

% waitup -> <>
<<function delete>>=
void
delete(char *name)
{
    if(utfrune(name, '(') == 0) {		/* file */
        if(remove(name) < 0)
            perror(name);
    } else
        fprint(STDERR, "hoon off; mk can't delete archive members\n");
}
@
%ugly: bug if filename contain open parenthesis

\subsection{Not printing the recipe (quiet mode), [[:Q:]]}
% work with -n too? nflag || !QUIET?

<<[[Rule_attr]] cases>>=
QUIET  = 0x0008,
@

<<[[rhead()]] when parsing rule attributes, switch rune cases>>=
case 'Q':
    *attr |= QUIET;
    break;
@




\subsection{Running shell command without [[-e]], [[:E:]]}
% "continue execution if the recipe draws errors"

% when want that?

<<[[Node_flag]] cases>>=
NOMINUSE   = 0x1000,
@

<<[[rhead()]] when parsing rule attributes, switch rune cases>>=
case 'E':
    *attr |= NOMINUSE;
    break;
@

<<[[sched()]] reset flags if NOMINUSE rule>>=
if (j->r->attr&NOMINUSE)
    flags = nil;
@
%old: flags = (j->r->attr&NOMINUSE)? nil : "-e" ; but was harder to aspectize


\subsection{Disabling norecipe warning, [[:N:]]}
%"if there is no recipe, the target has its time updated"

% when want that?

<<[[Rule_attr]] cases>>=
NOREC  = 0x0040,
@
<<[[rhead()]] when parsing rule attributes, switch rune cases>>=
case 'N':
    *attr |= NOREC;
    break;
@


<<[[Node_flag]] cases>>=
NORECIPE   = 0x0400,
@
<<[[attribute()]] propagate rule attribute to node cases>>=
if(a->r->attr&NOREC)
    n->flags |= NORECIPE;
@

% when no recipe found, print warning or not?


\subsection{Forbidding metarules to match virtual targets,  [[:n:]]}

%" the rule is a meta-rule that cannot be a target of a virtual rule,
% only files match the pattern in the target"

% when want that?

<<[[Rule_attr]] cases>>=
NOVIRT = 0x0100,
@
<<[[rhead()]] when parsing rule attributes, switch rune cases>>=
case 'n':
    *attr |= NOVIRT;
    break;
@

<<[[applyrules()]] skip this meta rule and continue if some conditions>>=
if ((r->attr&NOVIRT) && a != &head && (a->r->attr&VIR))
    continue;
@
% really useful?

\subsection{Custom dependency comparison, [[:P:]]}
% big one

% "the characters after the P until terminating : are taken as a program name.
% It will be invoked as rc -c prog 'arg1' 'arg2' and should return a null
% exit status if and only if arg1 is up to date with respect to arg2 ..."

% it's a way to have a hook in the out-of-date and time of file system.
% If it is not good enough for you, you can give adhoc stuff.

% see mk man page.  use for x.tab and y.tab.h, but
% can do without
% x.tab.h:Pcmp -s: y.tab.h
%    cp y.tab.h x.tab.h

% but can do with
% x.tab.h: y.tab.h
%    cmp y.tab.h x.tab.h || cp y.tab.h x.tab.h

<<[[Rule]] other fields>>=
char		*prog;		/* to use in out of date */
@
% prog??


<<[[parse()]] other locals>>=
char *prog;
@
% passed as rhread(..., &prog) so can then
% be passed to addrules as an argument

<<[[addrule()]] set more fields>>=
r->prog = prog;
@



<<[[Arc]] other fields>>=
char		*prog;
@

<<[[newarc()]] set other fields>>=
a->prog = r->prog;
@




<<[[rhead()]] other locals>>=
char *pp;
@

<<[[rhead()]] when parsing rule attributes, switch rune cases>>=
case 'P':
    pp = utfrune(p, ':');
    if (pp == 0 || *pp == 0)
        goto eos;
    *pp = 0;
    *prog = strdup(p);
    *pp = ':';
    p = pp;
    break;
@


<<[[Sxxx]] cases>>=
S_OUTOFDATE,	/* n1\377n2 -> 2(outofdate) or 1(not outofdate) */
@
% abuse string ...


<<[[update()]] set outofdate prereqs if arc prog>>=
for(a = node->prereqs; a; a = a->next)
    if(a->prog)
        outofdate(node, a, true);
@


<<[[outofdate()]] locals>>=
char buf[3*NAMEBLOCK];
char *str = nil;
Symtab *sym;
int ret;
@

<<[[outofdate()]] if arc->prog>>=
if(arc->prog){
    snprint(buf, sizeof buf, "%s%c%s", node->name, 0377,
        arc->n->name);
    sym = symlook(buf, S_OUTOFDATE, 0);
    if(sym == nil || eval){
        if(sym == nil)
            str = strdup(buf);
        ret = pcmp(arc->prog, node->name, arc->n->name);
        if(sym)
            sym->u.value = ret;
        else
            symlook(str, S_OUTOFDATE, (void *)ret);
    } else
        ret = sym->u.value;
    return (ret-1);
}
@

<<function pcmp>>=
static int
pcmp(char *prog, char *p, char *q)
{
    char buf[3*NAMEBLOCK];
    int pid;

    Bflush(&bout);
    snprint(buf, sizeof buf, "%s '%s' '%s'\n", prog, p, q);
    pid = pipecmd(buf, 0, 0);
    while(waitup(-3, &pid) >= 0)
        ;
    return (pid? 2:1);
}
@






\subsubsection{[[Process]]}

% with all those extensions (backquote, :P:, <|)
% you can run not just recipe jobs. However we need to wait for
% those process to finish too. wait() does not discriminate
% so we need to put more logic in waitup() and remember
% which process are job process and which one are not.

<<struct Process>>=
struct Process {
    int pid;
    int status;

    // Extra
    // double_list<ref_own<Process> backward, forward
    Process *b, *f;
};
@
%ocaml: another ex of redundant code. should be factorized in container library.
\t why need that? [[events]] not enough? seems to store results of process
\t  so rename  ProcessStatus?
\t  I think needed only for process that are not jobs! not in events!
\t  such as backquote, or :P: stuff.
\t rename status to bool error.
\t rename NotJobProcesses

<<global phead>>=
// double_list<ref_own<Process> (next = Process.f)
static Process *phead;
@

% classic, dynamic allocator
<<global pfree>>=
// double_list<ref_own<Process> (next = Process.f)
static Process *pfree;
@

% ctor
% waitup -> <>
<<function pnew>>=
static void
pnew(int pid, int status)
{
    Process *p;

    // p = pop_list(pfree)
    if(pfree){
        p = pfree;
        pfree = p->f;
    } else
        p = (Process *)Malloc(sizeof(Process));

    p->pid = pid;
    p->status = status;

    // add_list(p, phead)
    p->f = phead;
    phead = p;
    if(p->f)
        p->f->b = p;
    p->b = nil;
}
@

% dtor
<<function pdelete>>=
static void
pdelete(Process *p)
{
    // remove_double_list(p, phead, pfree)
    if(p->f)
        p->f->b = p->b;
    if(p->b)
        p->b->f = p->f;
    else
        phead = p->f;
    p->f = pfree;
    pfree = p;
}
@
\l rename pfree instead?

\subsubsection{[[waitup()]] adjustments}

<<[[waitup()]] if slot not found, not a job pid, update process list>>=
if(slot < 0){
   <<[[waitup()]] if DEBUG(D_EXEC) and slot < 0>>
    pnew(pid, buf[0]? 1:0);
    goto again;
}
@
% when can this happen? can waitfor child that was not in 
%  events? maybe child 2 in execsh?



% used only for <|, maybe move to later

<<[[waitup()]] other locals>>=
Process *p;
@

<<[[waitup()]] if retstatus, check process list>>=
/* first check against the process list */
if(retstatus)
    for(p = phead; p; p = p->f)
        if(p->pid == *retstatus){
            *retstatus = p->status;
            pdelete(p);
            return -1;
        }
@

<<[[waitup()]] if retstatus, check if matching pid>>=
if(retstatus && pid == *retstatus){
    *retstatus = buf[0]? 1:0;
    return -1;
}
@

\subsubsection{[[killchildren()]] adjustments}

<<[[killchildren()]] locals>>=
Process *p;
@
<<[[killchildren()]] expunge not-job processes>>=
for(p = phead; p; p = p->f)
    expunge(p->pid, msg);
@


<<function expunge>>=
void
expunge(int pid, char *msg)
{
    postnote(PNPROC, pid, msg);
}
@
% PNPROC?



\section{Advanced variable attributes}
% constant with attributes?? just private var
%  to not transmit to recipe process?

\subsection{Private variables, [[=U=]]}

<<[[rhead()]] when parsing variable attributes, switch rune cases>>=
case 'U':
    *attr = 1;
    break;
@
<<[[parse()]] when parsing variable definitions, if variable with attr>>=
if(attr)
    symlook(head->s, S_NOEXPORT, (void *)"");
@

<<[[Sxxx]] cases>>=
S_NOEXPORT,	/* var -> noexport */ // set of noexport variables
@

% ecopy called from execinit
<<[[ecopy()]] return and do not copy if S_NOEXPORT symbol>>=
if(symlook(s->name, S_NOEXPORT, nil))
    return;
@


\section{Advanced [[mk]] variables}

\subsection{[[$target]] versus [[$alltargets]]}


<<[[myenv]] other array elements>>=
"alltarget",
@

<<[[Job]] other fields>>=
Word		*at;	/* all targets */
@

<<[[buildenv()]] envupd some variables>>=
envupd("alltarget", wdup(j->at));
@

\t code dealing with alltargets in work here.

\subsection{[[$prereq]] versus [[$newprereq]]}

% seems used only for aggregate rules to optimize library building.

<<[[myenv]] other array elements>>=
"newprereq",
@
% so does not put *.5 but only the .5 that were more recent than
% the archive.


<<[[Job]] other fields>>=
Word		*np;	/* new prerequistes */
@

<<[[buildenv()]] envupd some variables>>=
envupd("newprereq", wdup(j->np));
@

% related to aggregates?

\t code dealing with newprereq in work here.

\subsection{[[$pid]]}
%$


<<[[myenv]] other array elements>>=
"pid",
@

<<[[buildenv()]] locals>>=
char buf[256];
@

% note that buildenv is called in the master process, not the execsh one.

<<[[buildenv()]] envupd some variables>>=
snprint(buf, sizeof buf, "%d", getpid());
envupd("pid", newword(buf));
@
% use of pid? mk.ps say can be useful to communicate between rules
% meh

\subsection{[[$nproc]]}
%$

<<[[myenv]] other array elements>>=
"nproc",
@

<<[[buildenv()]] envupd some variables>>=
snprint(buf, sizeof buf, "%d", slot);
envupd("nproc", newword(buf));
@
% use of nproc??


%dead: (was used only in dumper but never set correctly)
%<<[[Job]] other fields>>
%// option<int> (None = -1)
%int		nproc;	/* slot number */
%@
% in newjob()
%    j->nproc = -1;

\section{Aggregates, archives}
% meh

<<[[myenv]] other array elements>>=
"newmember",
@

<<[[buildenv()]] locals>>=
Word *w, *v, **l;
char *cp, *qp;
@

<<[[buildenv()]] envupd some variables>>=
// newmember
l = &v;
v = w = wdup(j->np);
while(w){
    cp = strchr(w->s, '(');
    if(cp){
        qp = strchr(cp+1, ')');
        if(qp){
            *qp = 0;
            strcpy(w->s, cp+1);
            l = &w->next;
            w = w->next;
            continue;
        }
    }
    *l = w->next;
    free(w->s);
    free(w);
    w = *l;
}
envupd("newmember", v);
@


<<[[Sxxx]] cases>>=
S_AGG,		/* aggregate -> time */
@


<<[[dorecipe()]] when no recipe found, if archive name>>=
if(strchr(node->name, '(') && node->time == 0)
    MADESET(node, MADE);
@

<<[[timeof()]] if name archive member>>=
if(utfrune(name, '('))
    return atimeof(force, name);		/* archive */
@

<<function atimeof>>=
ulong
atimeof(int force, char *name)
{
    Symtab *sym;
    ulong t;
    char *archive, *member, buf[512];

    archive = split(name, &member);
    if(archive == 0)
        Exit();

    t = mkmtime(archive, true);
    sym = symlook(archive, S_AGG, 0);
    if(sym){
        if(force || t > sym->u.value){
            atimes(archive);
            sym->u.value = t;
        }
    }
    else{
        atimes(archive);
        /* mark the aggegate as having been done */
        symlook(strdup(archive), S_AGG, "")->u.value = t;
    }
        /* truncate long member name to sizeof of name field in archive header */
    snprint(buf, sizeof(buf), "%s(%.*s)", archive, utfnlen(member, SARNAME), member);
    sym = symlook(buf, S_TIME, 0);
    if (sym)
        return sym->u.value;
    return 0;
}
@

<<function atouch>>=
void
atouch(char *name)
{
    char *archive, *member;
    int fd, i;
    struct ar_hdr h;
    long t;

    archive = split(name, &member);
    if(archive == 0)
        Exit();

    fd = open(archive, ORDWR);
    if(fd < 0){
        fd = create(archive, OWRITE, 0666);
        if(fd < 0){
            perror(archive);
            Exit();
        }
        write(fd, ARMAG, SARMAG);
    }
    if(symlook(name, S_TIME, 0)){
        /* hoon off and change it in situ */
        seek(fd, SARMAG, 0);
        while(read(fd, (char *)&h, sizeof(h)) == sizeof(h)){
            for(i = SARNAME-1; i > 0 && h.name[i] == ' '; i--)
                    ;
            h.name[i+1]=0;
            if(strcmp(member, h.name) == 0){
                t = SARNAME-sizeof(h);	/* ughgghh */
                seek(fd, t, 1);
                fprint(fd, "%-12ld", time(0));
                break;
            }
            t = atol(h.size);
            if(t&01) t++;
            seek(fd, t, 1);
        }
    }
    close(fd);
}
@

<<function atimes>>=
static void
atimes(char *ar)
{
    struct ar_hdr h;
    ulong at, t;
    int fd, i;
    char buf[BIGBLOCK];
    Dir *d;
    
    fd = open(ar, OREAD);
    if(fd < 0)
        return;

    if(read(fd, buf, SARMAG) != SARMAG){
        close(fd);
        return;
    }
    if((d = dirfstat(fd)) == nil){
        close(fd);
        return;
    }
    at = d->mtime;
    free(d);
    while(read(fd, (char *)&h, SAR_HDR) == SAR_HDR){
        t = strtoul(h.date, nil, 0);
        if(t >= at)	/* new things in old archives confuses mk */
            t = at-1;
        if(t == 0)	/* as it sometimes happens; thanks ken */
            t = 1;
        for(i = sizeof(h.name)-1; i > 0 && h.name[i] == ' '; i--)
            ;
        if(h.name[i] == '/')		/* system V bug */
            i--;
        h.name[i+1]=0;		/* can stomp on date field */
        snprint(buf, sizeof buf, "%s(%s)", ar, h.name);
        symlook(strdup(buf), S_TIME, (void*)t)->u.value = t;
        t = atol(h.size);
        if(t&01) t++;
        seek(fd, t, 1);
    }
    close(fd);
}
@

<<[[Sxxx]] cases>>=
S_BITCH,	/* bitched about aggregate not there */
@

<<function type>>=
static int
type(char *file)
{
    int fd;
    char buf[SARMAG];

    fd = open(file, OREAD);
    if(fd < 0){
        if(symlook(file, S_BITCH, 0) == 0){
            Bprint(&bout, "%s doesn't exist: assuming it will be an archive\n", file);
            symlook(file, S_BITCH, (void *)file);
        }
        return 1;
    }
    if(read(fd, buf, SARMAG) != SARMAG){
        close(fd);
        return 0;
    }
    close(fd);
    return strncmp(ARMAG, buf, SARMAG) == 0;
}
@

<<function split>>=
static char*
split(char *name, char **member)
{
    char *p, *q;

    p = strdup(name);
    q = utfrune(p, '(');
    if(q){
        *q++ = 0;
        if(member)
            *member = q;
        q = utfrune(q, ')');
        if (q)
            *q = 0;
        if(type(p))
            return p;
        free(p);
        fprint(STDERR, "mk: '%s' is not an archive\n", name);
    }
    return 0;
}
@



<<[[outofdate()]] if arc node is an archive member>>=
if(strchr(arc->n->name, '(') && arc->n->time == 0)
   /* missing archive member */
   return true;
@

\section{Optimizations}

%\subsection{Node cache}

%\subsection{Time cache}

\subsection{Missing-intermediates optimization, [[mk -I]]}
% mk -i suppress this behavior
% pad: mk -I! new mode :) because I don't like the default mode!

% it is there to optimize disk space, to allow to remove .o
% the intermediate betweem the .out and the .c by pretending
% they are there if we know no .c files has actually changed.
% useful at a time where disk space was expensive, and so having
% both the .o and the .a were seen as redundant waste.

% from man page:
%Nonexistent targets that have prerequisites
%and are themselves prerequisites are treated specially.

\t put to true by default? and have 'I' instead to do the opti?

<<global iflag>>=
bool iflag = false;
@
<<[[main()]] -xxx switch cases>>=
case 'i':
    iflag = true;
    break;
@


<<[[Node_flag]] cases>>=
CANPRETEND = 0x0008,
PRETENDING = 0x0010,
@
% again, should be a different field, not agglomerated with the other node flags


<<[[clrmade()]] [[n->flags]] pretend adjustments>>=
n->flags &= ~(CANPRETEND|PRETENDING);
if(strchr(n->name, '(') == 0 || n->time)
    n->flags |= CANPRETEND;
@


<<[[work()]] possibly pretending node>>=
/*
 *   can we pretend to be made?
 */
if((!iflag) && (node->time == 0) 
        && (node->flags&(PRETENDING|CANPRETEND))
        && p && ra->n && !outofdate(p, ra, false)){
    node->flags &= ~CANPRETEND;
    MADESET(node, MADE);
    if(explain && ((node->flags&PRETENDING) == 0))
        fprint(STDOUT, "pretending %s has time %lud\n", node->name, node->time);
    node->flags |= PRETENDING;
    return did;
}
/*
 *   node is out of date and we REALLY do have to do something.
 *   quickly rescan for pretenders
 */
for(a = node->prereqs; a; a = a->next)
    if(a->n && (a->n->flags&PRETENDING)){
        if(explain)
            Bprint(&bout, "unpretending %s because of %s because of %s\n",
            a->n->name, node->name, 
            ra->n? ra->n->name : "rule with no prerequisites");

        unpretend(a->n);
        did = work(a->n, node, a) || did;
        ready = false;
    }
if(!ready)/* try later unless nothing has happened for -k's sake */
    return did || work(node, p, parc);
@



<<[[work()]] possibly unpretending node>>=
if((node->flags&MADE) && (node->flags&PRETENDING) && p
    && outofdate(p, parc, false)){
    if(explain)
        fprint(STDOUT, "unpretending %s(%lud) because %s is out of date(%lud)\n",
            node->name, node->time, p->name, p->time);
    unpretend(node);
}
/*
 *   have a look if we are pretending in case
 *   someone has been unpretended out from underneath us
 */
if(node->flags&MADE){
    if(node->flags&PRETENDING){
        node->time = 0;
    }else
        return did;
}
@

<<function unpretend>>=
static void
unpretend(Node *n)
{
    MADESET(n, NOTMADE);
    n->flags &= ~(CANPRETEND|PRETENDING);
    n->time = 0;
}
@

<<[[work()]] locals>>=
Arc *ra = nil;
@
% need to save in ra for pretending stuff

<<[[work()]] update [[ra]] when outofdate [[node]] with arc [[a]]>>=
if((ra == nil) || (ra->n == nil) || (ra->n->time < a->n->time))
    ra = a;
@

<<[[work()]] update [[ra]] when no dest in arc and no src>>=
if(ra == nil)
    ra = a;
@


<<[[update()]] unpretend node>>=
node->flags &= ~(CANPRETEND|PRETENDING);
@

\subsection{Touching-mode optimization, [[mk -t]]}

% when the user knows what he is doing

<<global tflag>>=
bool tflag = false;
@
<<[[main()]] -xxx switch cases>>=
case 't':
    tflag = true;
    break;
@

<<[[dorecipe()]] when no recipe found, if tflag>>=
if(tflag){
    if(!(node->flags&VIRTUAL))
        touch(node->name);
    else if(explain)
        Bprint(&bout, "no touch of virtual '%s'\n", node->name);
}
@

<<[[sched()]] if touch mode>>=
if(tflag){
    if(!(n->flags&VIRTUAL))
        touch(n->name);
    else if(explain)
        Bprint(&bout, "no touch of virtual '%s'\n", n->name);
}
@

<<function touch>>=
void
touch(char *name)
{
    Bprint(&bout, "touch(%s)\n", name);
    if(nflag)
        return;

    if(utfrune(name, '('))
        atouch(name);		/* archive */
    else
     if(chgtime(name) < 0) {
        perror(name);
        Exit();
    }
}
@

<<function chgtime>>=
int
chgtime(char *name)
{
    Dir sbuf;

    if(access(name, AEXIST) >= 0) {
        nulldir(&sbuf);
        sbuf.mtime = time((long *)nil);
        return dirwstat(name, &sbuf);
    }
    return close(create(name, OWRITE, 0666));
}
@

\subsection{Bulk time optimisation}

% in addition to time cache, mk also batch the call to time
% by reading/caching the dir?

<<[[mkmtime]] locals>>=
//char *s, *ss;
//char carry;
//Symtab *sym;
@

<<[[mkmtime()]] bulk dir optimisation>>=
USED(force);
//TODO    s = utfrrune(name, '/');
//TODO    if(s == name)
//TODO        s++;
//TODO    if(s){
//TODO        ss = name;
//TODO        carry = *s;
//TODO        *s = '\0';
//TODO    }else{
//TODO        ss = nil;
//TODO        carry = 0;
//TODO    }
//TODO    if(carry)
//TODO        *s = carry;
//TODO
//TODO bulkmtime(ss);
//TODO if(!force){
//TODO     sym = symlook(name, S_TIME, 0);
//TODO     if(sym)
//TODO         return sym->u.value;
//TODO     return 0;
//TODO }
@
% subtle: this opti has subtle implications with weird filesystem like VFAT!!
% With this optimisation mk will not be able to run correctly
% in simple projects like tests/8c/! It's because the directory
% contains HELLOC.C not helloc.c and so even if dirstat("helloc.c")
% will work, once you read the directory you will create an
% entry for HELLOC.C in S_TIME but not for helloc.c and then when asking
% for helloc.c you will look in the cache and see nothing and so
% return 0.

<<[[Sxxx]] cases>>=
S_BULKED,	/* we have bulked this dir */
@

<<function bulkmtime>>=
void
bulkmtime(char *dir)
{
    char buf[4096];
    char *ss, *s, *sym;

    if(dir){
        sym = dir;
        s = dir;
        if(strcmp(dir, "/") == 0)
            strecpy(buf, buf + sizeof buf - 1, dir);
        else
            snprint(buf, sizeof buf, "%s/", dir);
    }else{
        s = ".";
        sym = "";
        buf[0] = 0;
    }
    if(symlook(sym, S_BULKED, 0))
        return;
    ss = strdup(sym);
    symlook(ss, S_BULKED, (void*)ss);
    dirtime(s, buf);
}
@

<<function dirtime>>=
void
dirtime(char *dir, char *path)
{
    int i, fd, n;
    ulong mtime;
    Dir *d;
    char buf[4096];

    fd = open(dir, OREAD);
    if(fd >= 0){
        while((n = dirread(fd, &d)) > 0){
            for(i=0; i<n; i++){
                mtime = d[i].mtime;
                /* defensive driving: this does happen */
                if(mtime == 0)
                    mtime = 1;
                snprint(buf, sizeof buf, "%s%s", path,
                    d[i].name);
                if(symlook(buf, S_TIME, 0) == nil)
                    symlook(strdup(buf), S_TIME,
                        (void*)mtime)->u.value = mtime;
            }
            free(d);
        }
        close(fd);
    }
}
@


\section{Recompiling everything, [[mk -a]]}

<<global aflag>>=
bool aflag = false;
@
<<[[main()]] -xxx switch cases>>=
case 'a':
    aflag = true;
    iflag = true;
    break;
@
% iflag = true; used to be after the switch, but same
% when -a, means we want to build _also_ the intermediate files when
% they are not there.

<<[[work()]] adjust weoutofdate if aflag>>=
if(aflag)
    weoutofdate = true;
@
%old: weoutofdate = aflag;

\section{Recursive [[mk]]}

% if one of the mk return error code, then should stop mk right?
% convenient then.
% TODO: this is not the case right now!!

%\section{Setting [[MKFLAGS]], [[MKARGS]]}
% used by? at least mkfile called recursively can expect those variables


<<[[main()]] locals>>=
Bufblock *buf = newbuf();
@

<<[[main()]] add [[argv[0]]] in [[buf]]>>=
bufcpy(buf, argv[0], strlen(argv[0]));
insert(buf, ' ');
@

<<[[main()]] add [[argv[i]]] in [[buf]]>>=
bufcpy(buf, argv[i], strlen(argv[i]));
insert(buf, ' ');
@



<<[[main()]] set variables for recursive mk>>=
<<[[main()]] set MKFLAGS variable>>
<<[[main()]] set MKARGS variable>>
@

<<[[main()]] set MKFLAGS variable>>=
if (buf->current != buf->start) {
    buf->current--;
    insert(buf, '\0');
}
symlook("MKFLAGS", S_VAR, (void*) stow(buf->start));
@

<<[[main()]] set MKARGS variable>>=
buf->current = buf->start;
for(i = 0; argv[i]; i++){
    if(*argv[i] == '\0') 
        continue;
    if(i)
        insert(buf, ' ');
    bufcpy(buf, argv[i], strlen(argv[i]));
}
insert(buf, '\0');
symlook("MKARGS", S_VAR, (void *) stow(buf->start));

freebuf(buf);
@



\chapter{Conclusion}

% could be nice to have a mk -d session at the end
% where see how all make sense, the flag values of nodes with 0x4
% because all are READY, etc.




\appendix

\chapter{Debugging}

%todo? http://bashdb.sourceforge.net/remake/
% apparently make with more debugging capabilities

%\section{Dumping internals, [[mk -d]]}

%mk -d[epg] EXEC PARSE GRAPH

<<enum Dxxx>>=
enum Dxxx {
    // for rules
    D_PARSE =		0x01,
    // for node and arcs
    D_GRAPH =		0x02,
    // for jobs
    D_EXEC  =		0x04,

    // tracing some calls
    D_TRACE  =		0x08,
};
@
%old: used to be a set of #define
%pad: I added D_TRACE

% -d flag
<<global debug>>=
// bitset<enum<dxxx>>
int debug;
@

<<function DEBUG>>=
#define	DEBUG(x)	(debug&(x))
@


<<[[main()]] -xxx switch cases>>=
case 'd':
    if(*(s = &argv[0][2]))
        while(*s) 
         switch(*s++) {
         case 'p':	debug |= D_PARSE; break;
         case 'g':	debug |= D_GRAPH; break;
         case 'e':	debug |= D_EXEC; break;
        }
    else
        debug = 0xFFFF; // D_PARSE | D_GRAPH | D_EXEC
    break;
@
\t D_TRACE?


\section{The rules, [[mk -dp]]}
% p for parsing

<<[[main()]] if DEBUG(D_PARSE)>>=
if(DEBUG(D_PARSE)){
    dumpw("default targets", target1);
    dumpr("rules", rules);
    dumpr("metarules", metarules);
    dumpv("variables");
}
@


<<dumper dumpw>>=
void
dumpw(char *s, Word *w)
{
    Bprint(&bout, "%s", s);
    for(; w; w = w->next)
        Bprint(&bout, " '%s'", w->s);
    Bputc(&bout, '\n');
}
@

% todo: remove the pointer thing %p, not that useful I think
% note that the variable expansion has been done for the target and prerequestes
<<dumper dumpr>>=
void
dumpr(char *s, Rule *r)
{
    Bprint(&bout, "%s: start=%p\n", s, r);
    for(; r; r = r->next){
        Bprint(&bout, "\tRule %p: %s:%d attr=%x next=%p chain=%p alltarget='%s'",
            r, r->file, r->line, r->attr, r->next, r->chain, wtos(r->alltargets, ' '));
        if(r->prog)
            Bprint(&bout, " prog='%s'", r->prog);
        Bprint(&bout, "\n\ttarget=%s: %s\n", r->target, wtos(r->tail,' '));
        Bprint(&bout, "\trecipe@%p='%s'\n", r->recipe, r->recipe);
    }
}
@

<<dumper dumpv>>=
void
dumpv(char *s)
{
    Bprint(&bout, "%s:\n", s);
    symtraverse(S_VAR, print1);
}
@

<<function print1>>=
static void
print1(Symtab *s)
{
    Word *w;

    Bprint(&bout, "\t%s=", s->name);
    for (w = s->u.ptr; w; w = w->next)
        Bprint(&bout, "'%s'", w->s);
    Bprint(&bout, "\n");
}
@





\section{The graph, [[mk -dg]]}

% node = graph(target) from mk(target)
<<[[main()]] if DEBUG(D_GRAPH)>>=
if(DEBUG(D_GRAPH)){
    dumpn("new target\n", root);
    Bflush(&bout);
}
@
% below the buf is here to compute indentation, depth of the graph in spaces

<<dumper dumpn>>=
void
dumpn(char *s, Node *n)
{
    char buf[1024];
    Arc *a;

    Bprint(&bout, "%s%s@%p: time=%ld flags=0x%x next=%p\n",
        s, n->name, n, n->time, n->flags, n->next);
    for(a = n->prereqs; a; a = a->next){
        snprint(buf, sizeof buf, "%s   ", (*s == ' ')? s:"");
        dumpa(buf, a);
    }
}
@

<<dumper dumpa>>=
void
dumpa(char *s, Arc *a)
{
    char buf[1024];

    Bprint(&bout, "%sArc@%p: n=%p r=%p flag=0x%x stem='%s'",
        s, a, a->n, a->r, a->flag, a->stem);
    if(a->prog)
        Bprint(&bout, " prog='%s'", a->prog);
    Bprint(&bout, "\n");

    if(a->n){
        snprint(buf, sizeof(buf), "%s    ", (*s == ' ')? s:"");
        dumpn(buf, a->n);
    }
}
@

<<[[nrep()]] if DEBUG(D_GRAPH)>>=
if(DEBUG(D_GRAPH))
    Bprint(&bout, "nreps = %d\n", nreps);
@

\section{The jobs, [[mk -de]]}
% e for execution


<<[[sched()]] if DEBUG(D_EXEC)>>=
if(DEBUG(D_EXEC))
    fprint(STDOUT, "firing up job for target %s\n", wtos(j->t, ' '));
@

<<[[sched()]] if DEBUG(D_EXEC) print recipe>>=
if(DEBUG(D_EXEC))
    fprint(STDOUT, "recipe='%s'\n", j->r->recipe);
Bflush(&bout);
@

<<[[sched()]] if DEBUG(D_EXEC) print pid>>=
if(DEBUG(D_EXEC))
    fprint(STDOUT, "pid for target %s = %d\n", wtos(j->t, ' '), events[slot].pid);
@


<<[[waitup()]] if DEBUG(D_EXEC) print pid>>=
if(DEBUG(D_EXEC))
    fprint(STDOUT, "waitup got pid=%d, status='%s'\n", pid, buf);
@

<<[[waitup()]] if DEBUG(D_EXEC) and slot < 0>>=
 if(DEBUG(D_EXEC))
     fprint(STDERR, "mk: wait returned unexpected process %d\n", pid);
@

<<[[pidslot()]] if DEBUG(D_EXEC)>>=
if(DEBUG(D_EXEC))
    fprint(STDERR, "mk: wait returned unexpected process %d\n", pid);
@

<<[[nproc()]] if DEBUG(D_EXEC)>>=
if(DEBUG(D_EXEC))
    fprint(STDERR, "nprocs = %d\n", nproclimit);
@



% actually never used
<<dumper dumpj>>=
void
dumpj(char *s, Job *j, int all)
{
    Bprint(&bout, "%s\n", s);
    while(j){
        Bprint(&bout, "job@%p: r=%p n=%p stem='%s'\n",
            j, j->r, j->n, j->stem);
        Bprint(&bout, "\ttarget='%s' alltarget='%s' prereq='%s' nprereq='%s'\n",
            wtos(j->t, ' '), wtos(j->at, ' '), wtos(j->p, ' '), wtos(j->np, ' '));
        j = all? j->next : nil;
    }
}
@
%old:  nproc=%d ... , j->nproc

\section{The function calls, [[mk -dt]]}

<<[[applyrules]] debug>>=
if(DEBUG(D_TRACE)) 
    print("applyrules(%lux='%s')\n", target, target);
@

<<[[newnode()]] debug>>=
if(DEBUG(D_TRACE)) 
    print("newnode(%s), time = %d\n", name, node->time);
@


<<[[work()]] debug>>=
if(DEBUG(D_TRACE))
    print("work(%s) flags=0x%x time=%lud\n", node->name, node->flags, node->time);
@

<<[[update()]] debug>>=
if(DEBUG(D_TRACE))
    print("update(): node %s time=%lud flags=0x%x\n", node->name, node->time, node->flags);
@




\chapter{Profiling}

<<global buf>>=
short buf[10000];
@


<<[[main()]] setup profiling>>=
#ifdef	PROF
    {
        extern int etext();
        monitor(main, etext, buf, sizeof buf, 300);
    }
#endif
@


% dead function actually
<<function symstat>>=
void
symstat(void)
{
    Symtab **s, *ss;
    int n;
    int l[1000];

    memset((char *)l, 0, sizeof(l));
    for(s = hash; s < &hash[NHASH]; s++){
        for(ss = *s, n = 0; ss; ss = ss->next)
            n++;
        l[n]++;
    }
    for(n = 0; n < 1000; n++)
        if(l[n]) 
            Bprint(&bout, "%d of length %d\n", l[n], n);
}
@


\chapter{Error Management}

% related is mk -k, but not really error management in the end.

% automatic error handling

% Also call Exit, not exit! so carefully wait for children.

<<function Malloc>>=
void*
Malloc(int n)
{
    void *s;

    s = malloc(n);
    if(!s) {
        fprint(STDERR, "mk: cannot alloc %d bytes\n", n);
        Exit();
    }
    return s;
}
@
%old: used to have 'register void *s', but 8c does not use it I think

<<function Realloc>>=
void *
Realloc(void *s, int n)
{
    if(s)
        s = realloc(s, n);
    else
        s = malloc(n);
    if(!s) {
        fprint(STDERR, "mk: cannot alloc %d bytes\n", n);
        Exit();
    }
    return s;
}
@




\chapter{Libc}

%\section{Memory managment}
% Malloc and Realloc now in error management section

\section{Buffer managment}

<<struct Bufblock>>=
struct Bufblock
{
    char 		*start;
    char 		*end;
    char 		*current;

    // Extra
    struct Bufblock *next;
};
@

<<global freelist>>=
static Bufblock *freelist;
@



<<constant QUANTA>>=
#define	QUANTA	4096
@

% ctor
<<constructor newbuf>>=
Bufblock *
newbuf(void)
{
    Bufblock *p;

    if (freelist) {
        p = freelist;
        freelist = freelist->next;
    } else {
        p = (Bufblock *) Malloc(sizeof(Bufblock));
        p->start = Malloc(QUANTA*sizeof(*p->start));
        p->end = p->start+QUANTA;
    }
    p->current = p->start;
    *p->start = '\0';
    p->next = nil;
    return p;
}
@

% dtor
<<destructor freebuf>>=
void
freebuf(Bufblock *p)
{
    p->next = freelist;
    freelist = p;
}
@

<<function growbuf>>=
void
growbuf(Bufblock *p)
{
    int n;
    Bufblock *f;
    char *cp;

    n = p->end-p->start+QUANTA;
        /* search the free list for a big buffer */
    for (f = freelist; f; f = f->next) {
        if (f->end-f->start >= n) {
            memcpy(f->start, p->start, p->end-p->start);
            cp = f->start;
            f->start = p->start;
            p->start = cp;
            cp = f->end;
            f->end = p->end;
            p->end = cp;
            f->current = f->start;
            break;
        }
    }
    if (!f) {		/* not found - grow it */
        p->start = Realloc(p->start, n);
        p->end = p->start+n;
    }
    p->current = p->start+n-QUANTA;
}
@

<<function bufcpy>>=
void
bufcpy(Bufblock *buf, char *cp, int n)
{

    while (n--)
        insert(buf, *cp++);
}
@

<<function insert>>=
void
insert(Bufblock *buf, int c)
{

    if (buf->current >= buf->end)
        growbuf(buf);
    *buf->current++ = c;
}
@

<<function rinsert>>=
void
rinsert(Bufblock *buf, Rune r)
{
    int n;

    n = runelen(r);
    if (buf->current+n > buf->end)
        growbuf(buf);
    runetochar(buf->current, &r);
    buf->current += n;
}
@

\section{Utilities}

<<function maketmp>>=
char*
maketmp(void)
{
    static char temp[] = "/tmp/mkargXXXXXX";

    mktemp(temp);
    return temp;
}
@

\chapter{Examples of [[mkfile]]s}
\label{chap:examples}

\section{[[mkfile]] of [[mk]]}
% relies on next section

\section{The [[mkfile]]s of \plan}
% mentioned in mk.ms ?

\subsection{[[/$objtype/mkfile]]}
%$

\subsection{[[/sys/src/mkfile.proto]]}


\subsection{[[/sys/src/cmd/mkone]]}
% also mkmany

\subsection{[[/sys/src/cmd/mklib]]}
% also mksyslib


% and then the instances
%\subsection{[[/sys/src/mkfile]]}
%\subsection{[[/sys/src/cmd/mkfile]]}

\chapter{Extra Code}

\ifallcode
#include "Make_extra.nw"
\fi

%\chapter{Changelog}
% code via make loc = 4763 LOC, after full lpized 5285 LOC
% orig Make.nw = 5400 LOC, after full lpized and comments in sections 8540
% now: =~ ?? LOC so added ?? LOE (Lines of explanations)
% mk in ocaml: 2000 LOC (but not all features)


\chapter*{Glossary}
\addcontentsline{toc}{chapter}{Glossary}
\label{sec:glossary}

\begin{verbatim}
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{chapter}{Index}

%\chapter{References} 
\addcontentsline{toc}{chapter}{References}

\bibliography{../docs/latex/Principia}
\bibliographystyle{plain}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
