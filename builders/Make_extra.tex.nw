\section{[[mk/]]}

\subsection*{[[mk/fns.h]]}


%-------------------------------------------------------------

<<mk/fns.h>>=
void	addrule(char*, Word*, char*, Word*, int, int, char*);
void	addrules(Word*, Word*, char*, int, int, char*);
int	assline(Biobuf *, Bufblock *);
ulong	atimeof(int,char*);
void	atouch(char*);
void	bufcpy(Bufblock *, char *, int);
Envy	*buildenv(Job*, int);
void	catchnotes(void);
char 	*charin(char *, char *);
int	chgtime(char*);
char	*copyq(char*, Rune, Bufblock*);
void	delete(char*);
void	delword(Word*);
int	dorecipe(Node*);
void	dumpa(char*, Arc*);
void	dumpj(char*, Job*, int);
void	dumpn(char*, Node*);
void	dumpr(char*, Rule*);
void	dumpv(char*);
void	dumpw(char*, Word*);
int	escapetoken(Biobuf*, Bufblock*, int, int);
void	execinit(void);
int	execsh(char*, char*, Bufblock*, Envy*);
void	Exit(void);
char	*expandquote(char*, Rune, Bufblock*);
void	expunge(int, char*);
void	freebuf(Bufblock*);
void	front(char*);
Node	*graph(char*);
void	growbuf(Bufblock *);
void	initenv(void);
void	insert(Bufblock *, int);
void	killchildren(char*);
void	*Malloc(int);
char	*maketmp(void);
int	match(char*, char*, char*);
void	mk(char*);
ulong	mkmtime(char*, int);
ulong	mtime(char*);
Arc	*newarc(Node*, Rule*, char*, Resub*);
Bufblock *newbuf(void);
Job	*newjob(Rule*, Node*, char*, char**, Word*, Word*, Word*, Word*);
Word	*newword(char*);
int	nextrune(Biobuf*, int);
//int	nextslot(void);
void	nproc(void);
void	nrep(void);
int	outofdate(Node*, Arc*, int);
void	parse(char*, int, int);
int	pipecmd(char*, Envy*, int*);
void	prusage(void);
void	rcopy(char**, Resub*, int);
void	readenv(void);
void	*Realloc(void*, int);
void	rinsert(Bufblock *, Rune);
char	*rulecnt(void);
void	run(Job*);
void	setvar(char*, void*);
char	*shname(char*);
void	shprint(char*, Envy*, Bufblock*);
Word	*stow(char*);
void	subst(char*, char*, char*, int);
//void	symdel(char*, int);
void	syminit(void);
Symtab	*symlook(char*, int, void*);
void	symstat(void);
void	symtraverse(int, void(*)(Symtab*));
void	timeinit(char*);
ulong	timeof(char*, int);
void	touch(char*);
void	update(int, Node*);
void	usage(void);
Word	*varsub(char**);
int	waitfor(char*);
int	waitup(int, int*);
Word	*wdup(Word*);
char	*wtos(Word*, int);
@


\subsection*{[[mk/mk.h]]}


<<constant NAMEBLOCK>>=
#define	NAMEBLOCK	1000
@

<<constant BIGBLOCK>>=
#define	BIGBLOCK	20000
@


<<function RERR>>=
//#define	RERR(r)		(fprint(2, "mk: %s:%d: rule error; ", (r)->file, (r)->line))
@
<<function SEP>>=
//#define	SEP(c)		(((c)==' ')||((c)=='\t')||((c)=='\n'))
@




<<function WORDCHR>>=
#define WORDCHR(r)	((r) > ' ' && !utfrune("!\"#$%&'()*+,-./:;<=>?@[\\]^`{|}~", (r)))
@
%$

<<function PERCENT>>=
#define	PERCENT(ch)	(((ch) == '%') || ((ch) == '&'))
@

<<function LSEEK>>=
#define	LSEEK(f,o,p)	seek(f,o,p)
@



%-------------------------------------------------------------

<<mk/mk.h>>=
#include	<u.h>
#include	<libc.h>
#include	<bio.h>
#include	<regexp.h>

extern Biobuf bout;

<<struct Bufblock>>

<<struct Word>>

// used by main and parse.c
extern Word *target1;


<<struct Envy>>

extern Envy *envy;

<<struct Rule>>

extern Rule *rules, *metarules, *patrule;

<<constant META>>
<<constant UNUSED>>
<<constant UPD>>
<<constant QUIET>>
<<constant VIR>>
<<constant REGEXP>>
<<constant NOREC>>
<<constant DEL>>
<<constant NOVIRT>>

<<constant NREGEXP>>

<<struct Arc>>

<<constant TOGO>>

<<struct Node>>

<<constant VIRTUAL>>
<<constant CYCLE>>
<<constant READY>>
<<constant CANPRETEND>>
<<constant PRETENDING>>
<<constant NOTMADE>>
<<constant BEINGMADE>>
<<constant MADE>>
<<function MADESET>>
<<constant PROBABLE>>
<<constant VACUOUS>>
<<constant NORECIPE>>
<<constant DELETE>>
<<constant NOMINUSE>>

<<struct Job>>

extern Job *jobs;

<<struct Symtab>>

<<enum _anon_>>

extern	int	debug;
extern	int	nflag, tflag, iflag, kflag, aflag;
extern	int	mkinline;
extern	char	*infile;
extern	int	nreps;
extern	char	*explain;
extern	char	*termchars;
//extern	char 	*shell;
//extern	char 	*shellname;
extern	char 	*shflags;
//extern	int	IWS;

<<function SYNERR>>
<<function RERR>>
<<constant NAMEBLOCK>>
<<constant BIGBLOCK>>

<<function SEP>>
<<function WORDCHR>>

<<function DEBUG>>
<<constant D_PARSE>>
<<constant D_GRAPH>>
<<constant D_EXEC>>

<<function LSEEK>>

<<function PERCENT>>

#include	"fns.h"
@


\subsection*{[[mk/globals.c]]}

<<global iflag>>=
int iflag = 0;
@

<<global kflag>>=
int kflag = 0;
@


% n reps, to manage bad rules like %: %.c that can be executed multiple times
<<global nreps>>=
int nreps = 1;
@




%-------------------------------------------------------------

<<mk/globals.c>>=
#include	"mk.h"

<<global debug>>
<<global rules>>
<<global metarules>>
<<global nflag>>
<<global tflag>>
<<global iflag>>
<<global kflag>>
<<global aflag>>
<<global explain>>
<<global nreps>>
<<global jobs>>
<<global bout>>
<<global patrule>>
// was in main.c, but used also by parse.c
<<global target1>>
@


\subsection*{[[mk/utils.c]]}

<<function Malloc>>=
void *
Malloc(int n)
{
    register void *s;

    s = malloc(n);
    if(!s) {
        fprint(2, "mk: cannot alloc %d bytes\n", n);
        Exit();
    }
    return(s);
}
@

<<function Realloc>>=
void *
Realloc(void *s, int n)
{
    if(s)
        s = realloc(s, n);
    else
        s = malloc(n);
    if(!s) {
        fprint(2, "mk: cannot alloc %d bytes\n", n);
        Exit();
    }
    return(s);
}
@


%-------------------------------------------------------------

<<mk/utils.c>>=
#include "mk.h"

<<function Malloc>>

<<function Realloc>>
@


\subsection*{[[mk/bufblock.c]]}

%-------------------------------------------------------------

<<mk/bufblock.c>>=
#include	"mk.h"

<<global freelist>>
<<constant QUANTA>>

<<function newbuf>>

<<function freebuf>>

<<function growbuf>>

<<function bufcpy>>

<<function insert>>

<<function rinsert>>
@


\subsection*{[[mk/symtab.c]]}

<<function symdel>>=
//void
//symdel(char *sym, int space)
//{
//    long h;
//    char *p;
//    Symtab *s, *ls;
//
//    /* multiple memory leaks */
//
//    for(p = sym, h = space; *p; h += *p++)
//        h *= HASHMUL;
//    if(h < 0)
//        h = ~h;
//    h %= NHASH;
//    for(s = hash[h], ls = 0; s; ls = s, s = s->next)
//        if((s->space == space) && (strcmp(s->name, sym) == 0)){
//            if(ls)
//                ls->next = s->next;
//            else
//                hash[h] = s->next;
//            free((char *)s);
//        }
//}
@


<<function symstat>>=
void
symstat(void)
{
    Symtab **s, *ss;
    int n;
    int l[1000];

    memset((char *)l, 0, sizeof(l));
    for(s = hash; s < &hash[NHASH]; s++){
        for(ss = *s, n = 0; ss; ss = ss->next)
            n++;
        l[n]++;
    }
    for(n = 0; n < 1000; n++)
        if(l[n]) Bprint(&bout, "%d of length %d\n", l[n], n);
}
@


%-------------------------------------------------------------

<<mk/symtab.c>>=
#include	"mk.h"

<<constant NHASH>>
<<constant HASHMUL>>
<<global hash>>

<<function syminit>>

<<function symlook>>

<<function symdel>>

<<function symtraverse>>

<<function symstat>>
@


\subsection*{[[mk/rc.c]]}

%-------------------------------------------------------------

<<mk/rc.c>>=
#include	"mk.h"

<<global termchars>>
<<global shflags>>
<<global IWS>>

/*
 *	This file contains functions that depend on rc's syntax.  Most
 *	of the routines extract strings observing rc's escape conventions
 */


<<function squote>>

<<function charin>>

<<function expandquote>>

<<function escapetoken>>

<<function copysingle>>
<<function copyq>>
@


\subsection*{[[mk/word.c]]}

<<function newword>>=
Word*
newword(char *s)
{
    Word *w;

    w = (Word *)Malloc(sizeof(Word));
    w->s = strdup(s);
    w->next = 0;
    return(w);
}
@

<<function stow>>=
Word *
stow(char *s)
{
    Word *head, *w, *new;

    w = head = 0;
    while(*s){
        new = nextword(&s);
        if(new == 0)
            break;
        if (w)
            w->next = new;
        else
            head = w = new;
        while(w->next)
            w = w->next;
        
    }
    if (!head)
        head = newword("");
    return(head);
}
@

<<function wtos>>=
char *
wtos(Word *w, int sep)
{
    Bufblock *buf;
    char *cp;

    buf = newbuf();
    for(; w; w = w->next){
        for(cp = w->s; *cp; cp++)
            insert(buf, *cp);
        if(w->next)
            insert(buf, sep);
    }
    insert(buf, 0);
    cp = strdup(buf->start);
    freebuf(buf);
    return(cp);
}
@

<<function wdup>>=
Word*
wdup(Word *w)
{
    Word *v, *new, *base;

    v = base = 0;
    while(w){
        new = newword(w->s);
        if(v)
            v->next = new;
        else
            base = new;
        v = new;
        w = w->next;
    }
    return base;
}
@

<<function delword>>=
void
delword(Word *w)
{
    Word *v;

    while(v = w){
        w = w->next;
        if(v->s)
            free(v->s);
        free(v);
    }
}
@

<<function nextword>>=
/*
 *	break out a word from a string handling quotes, executions,
 *	and variable expansions.
 */
static Word*
nextword(char **s)
{
    Bufblock *b;
    Word *head, *tail, *w;
    Rune r;
    char *cp;
    int empty;

    cp = *s;
    b = newbuf();
restart:
    head = tail = 0;
    while(*cp == ' ' || *cp == '\t')		/* leading white space */
        cp++;
    empty = 1;
    while(*cp){
        cp += chartorune(&r, cp);
        switch(r)
        {
        case ' ':
        case '\t':
        case '\n':
            goto out;
        case '\\':
        case '\'':
        case '"':
            empty = 0;
            cp = expandquote(cp, r, b);
            if(cp == 0){
                fprint(2, "missing closing quote: %s\n", *s);
                Exit();
            }
            break;
        case '$':
            w = varsub(&cp);
            if(w == 0){
                if(empty)
                    goto restart;
                break;
            }
            empty = 0;
            if(b->current != b->start){
                bufcpy(b, w->s, strlen(w->s));
                insert(b, 0);
                free(w->s);
                w->s = strdup(b->start);
                b->current = b->start;
            }
            if(head){
                bufcpy(b, tail->s, strlen(tail->s));
                bufcpy(b, w->s, strlen(w->s));
                insert(b, 0);
                free(tail->s);
                tail->s = strdup(b->start);
                tail->next = w->next;
                free(w->s);
                free(w);
                b->current = b->start;
            } else
                tail = head = w;
            while(tail->next)
                tail = tail->next;
            break;
        default:
            empty = 0;
            rinsert(b, r);
            break;
        }
    }
out:
    *s = cp;
    if(b->current != b->start){
        if(head){
            cp = b->current;
            bufcpy(b, tail->s, strlen(tail->s));
            bufcpy(b, b->start, cp-b->start);
            insert(b, 0);
            free(tail->s);
            tail->s = strdup(cp);
        } else {
            insert(b, 0);
            head = newword(b->start);
        }
    }
    freebuf(b);
    return head;
}
@
%$


%-------------------------------------------------------------

<<mk/word.c>>=
#include	"mk.h"

static	Word	*nextword(char**);

<<function newword>>

<<function stow>>

<<function wtos>>

<<function wdup>>

<<function delword>>

<<function nextword>>

<<function dumpw>>
@


\subsection*{[[mk/var.c]]}

<<function shname>>=
char *
shname(char *a)
{
    Rune r;
    int n;

    while (*a) {
        n = chartorune(&r, a);
        if (!WORDCHR(r))
            break;
        a += n;
    }
    return a;
}
@


%-------------------------------------------------------------

<<mk/var.c>>=
#include	"mk.h"

<<function setvar>>

<<function print1>>

<<function dumpv>>

<<function shname>>
@


\subsection*{[[mk/plan9.c]]}


<<function readenv>>=
void
readenv(void)
{
    char *p;
    int envf, f;
    Dir *e;
    char nam[1024];
    int i, n, len;
    Word *w;

    rfork(RFENVG);	/*  use copy of the current environment variables */

    envf = open("/env", OREAD);
    if(envf < 0)
        return;
    while((n = dirread(envf, &e)) > 0){
        for(i = 0; i < n; i++){
            len = e[i].length;
                /* don't import funny names, NULL values,
                 * or internal mk variables
                 */
            if(len <= 0 || *shname(e[i].name) != '\0')
                continue;
            if (symlook(e[i].name, S_INTERNAL, 0))
                continue;
            snprint(nam, sizeof nam, "/env/%s", e[i].name);
            f = open(nam, OREAD);
            if(f < 0)
                continue;
            p = Malloc(len+1);
            if(read(f, p, len) != len){
                perror(nam);
                close(f);
                continue;
            }
            close(f);
            if (p[len-1] == 0)
                len--;
            else
                p[len] = 0;
            w = encodenulls(p, len);
            free(p);
            p = strdup(e[i].name);
            setvar(p, (void *) w);
            symlook(p, S_EXPORTED, (void*)"")->u.ptr = "";
        }
        free(e);
    }
    close(envf);
}
@

<<function encodenulls>>=
/* break string of values into words at 01's or nulls*/
static Word *
encodenulls(char *s, int n)
{
    Word *w, *head;
    char *cp;

    head = w = 0;
    while (n-- > 0) {
        for (cp = s; *cp && *cp != '\0'; cp++)
                n--;
        *cp = 0;
        if (w) {
            w->next = newword(s);
            w = w->next;
        } else
            head = w = newword(s);
        s = cp+1;
    }
    if (!head)
        head = newword("");
    return head;
}
@

<<function exportenv>>=
/* as well as 01's, change blanks to nulls, so that rc will
 * treat the words as separate arguments
 */
void
exportenv(Envy *e)
{
    int f, n, hasvalue, first;
    Word *w;
    Symtab *sy;
    char nam[256];

    for(;e->name; e++){
        sy = symlook(e->name, S_VAR, 0);
        if (e->values == 0 || e->values->s == 0 || e->values->s[0] == 0)
            hasvalue = 0;
        else
            hasvalue = 1;
        if(sy == 0 && !hasvalue)	/* non-existant null symbol */
            continue;
        snprint(nam, sizeof nam, "/env/%s", e->name);
        if (sy != 0 && !hasvalue) {	/* Remove from environment */
                /* we could remove it from the symbol table
                 * too, but we're in the child copy, and it
                 * would still remain in the parent's table.
                 */
            remove(nam);
            delword(e->values);
            e->values = 0;		/* memory leak */
            continue;
        }
    
        f = create(nam, OWRITE, 0666L);
        if(f < 0) {
            fprint(2, "can't create %s, f=%d\n", nam, f);
            perror(nam);
            continue;
        }
        first = 1;
        for (w = e->values; w; w = w->next) {
            n = strlen(w->s);
            if (n) {
                if(first)
                    first = 0;
                else{
                    if (write (f, "\0", 1) != 1)
                        perror(nam);
                }
                if (write(f, w->s, n) != n)
                    perror(nam);
            }
        }
        close(f);
    }
}
@

<<function waitfor>>=
int
waitfor(char *msg)
{
    Waitmsg *w;
    int pid;

    if((w=wait()) == nil)
        return -1;
    strecpy(msg, msg+ERRMAX, w->msg);
    pid = w->pid;
    free(w);
    return pid;
}
@

<<function expunge>>=
void
expunge(int pid, char *msg)
{
    postnote(PNPROC, pid, msg);
}
@

<<function execsh>>=
int
execsh(char *args, char *cmd, Bufblock *buf, Envy *e)
{
    char *p;
    int tot, n, pid, in[2], out[2];

    if(buf && pipe(out) < 0){
        perror("pipe");
        Exit();
    }
    pid = rfork(RFPROC|RFFDG|RFENVG);
    if(pid < 0){
        perror("mk rfork");
        Exit();
    }
    if(pid == 0){
        if(buf)
            close(out[0]);
        if(pipe(in) < 0){
            perror("pipe");
            Exit();
        }
        pid = fork();
        if(pid < 0){
            perror("mk fork");
            Exit();
        }
        if(pid != 0){
            dup(in[0], 0);
            if(buf){
                dup(out[1], 1);
                close(out[1]);
            }
            close(in[0]);
            close(in[1]);
            if (e)
                exportenv(e);
            if(shflags)
                execl(shell, shellname, shflags, args, nil);
            else
                execl(shell, shellname, args, nil);
            perror(shell);
            _exits("exec");
        }
        close(out[1]);
        close(in[0]);
        p = cmd+strlen(cmd);
        while(cmd < p){
            n = write(in[1], cmd, p-cmd);
            if(n < 0)
                break;
            cmd += n;
        }
        close(in[1]);
        _exits(0);
    }
    if(buf){
        close(out[1]);
        tot = 0;
        for(;;){
            if (buf->current >= buf->end)
                growbuf(buf);
            n = read(out[0], buf->current, buf->end-buf->current);
            if(n <= 0)
                break;
            buf->current += n;
            tot += n;
        }
        if (tot && buf->current[-1] == '\n')
            buf->current--;
        close(out[0]);
    }
    return pid;
}
@

<<function pipecmd>>=
int
pipecmd(char *cmd, Envy *e, int *fd)
{
    int pid, pfd[2];

    if(DEBUG(D_EXEC))
        fprint(1, "pipecmd='%s'\n", cmd);/**/

    if(fd && pipe(pfd) < 0){
        perror("pipe");
        Exit();
    }
    pid = rfork(RFPROC|RFFDG|RFENVG);
    if(pid < 0){
        perror("mk fork");
        Exit();
    }
    if(pid == 0){
        if(fd){
            close(pfd[0]);
            dup(pfd[1], 1);
            close(pfd[1]);
        }
        if(e)
            exportenv(e);
        if(shflags)
            execl(shell, shellname, shflags, "-c", cmd, nil);
        else
            execl(shell, shellname, "-c", cmd, nil);
        perror(shell);
        _exits("exec");
    }
    if(fd){
        close(pfd[1]);
        *fd = pfd[0];
    }
    return pid;
}
@

<<function Exit>>=
void
Exit(void)
{
    while(waitpid() >= 0)
        ;
    exits("error");
}
@

<<function notifyf>>=
int
notifyf(void *a, char *msg)
{
    static int nnote;

    USED(a);
    if(++nnote > 100){	/* until andrew fixes his program */
        fprint(2, "mk: too many notes\n");
        notify(0);
        abort();
    }
    if(strcmp(msg, "interrupt")!=0 && strcmp(msg, "hangup")!=0)
        return 0;
    killchildren(msg);
    return -1;
}
@

<<function catchnotes>>=
void
catchnotes()
{
    atnotify(notifyf, 1);
}
@

<<function maketmp>>=
char*
maketmp(void)
{
    static char temp[] = "/tmp/mkargXXXXXX";

    mktemp(temp);
    return temp;
}
@

<<function chgtime>>=
int
chgtime(char *name)
{
    Dir sbuf;

    if(access(name, AEXIST) >= 0) {
        nulldir(&sbuf);
        sbuf.mtime = time((long *)0);
        return dirwstat(name, &sbuf);
    }
    return close(create(name, OWRITE, 0666));
}
@

<<function rcopy>>=
void
rcopy(char **to, Resub *match, int n)
{
    int c;
    char *p;

    *to = match->sp;		/* stem0 matches complete target */
    for(to++, match++; --n > 0; to++, match++){
        if(match->sp && match->ep){
            p = match->ep;
            c = *p;
            *p = 0;
            *to = strdup(match->sp);
            *p = c;
        }
        else
            *to = 0;
    }
}
@

<<function dirtime>>=
void
dirtime(char *dir, char *path)
{
    int i, fd, n;
    ulong mtime;
    Dir *d;
    char buf[4096];

    fd = open(dir, OREAD);
    if(fd >= 0){
        while((n = dirread(fd, &d)) > 0){
            for(i=0; i<n; i++){
                mtime = d[i].mtime;
                /* defensive driving: this does happen */
                if(mtime == 0)
                    mtime = 1;
                snprint(buf, sizeof buf, "%s%s", path,
                    d[i].name);
                if(symlook(buf, S_TIME, 0) == nil)
                    symlook(strdup(buf), S_TIME,
                        (void*)mtime)->u.value = mtime;
            }
            free(d);
        }
        close(fd);
    }
}
@

<<function bulkmtime>>=
void
bulkmtime(char *dir)
{
    char buf[4096];
    char *ss, *s, *sym;

    if(dir){
        sym = dir;
        s = dir;
        if(strcmp(dir, "/") == 0)
            strecpy(buf, buf + sizeof buf - 1, dir);
        else
            snprint(buf, sizeof buf, "%s/", dir);
    }else{
        s = ".";
        sym = "";
        buf[0] = 0;
    }
    if(symlook(sym, S_BULKED, 0))
        return;
    ss = strdup(sym);
    symlook(ss, S_BULKED, (void*)ss);
    dirtime(s, buf);
}
@

<<function mkmtime>>=
ulong
mkmtime(char *name, int force)
{
    Dir *d;
    char *s, *ss, carry;
    ulong t;
    Symtab *sym;
    char buf[4096];

    strecpy(buf, buf + sizeof buf - 1, name);
    cleanname(buf);
    name = buf;

    s = utfrrune(name, '/');
    if(s == name)
        s++;
    if(s){
        ss = name;
        carry = *s;
        *s = 0;
    }else{
        ss = 0;
        carry = 0;
    }
    bulkmtime(ss);
    if(carry)
        *s = carry;
    if(!force){
        sym = symlook(name, S_TIME, 0);
        if(sym)
            return sym->u.value;
        return 0;
    }
    if((d = dirstat(name)) == nil)
        return 0;
    t = d->mtime;
    free(d);
    return t;
}
@


%-------------------------------------------------------------

<<mk/plan9.c>>=
#include	"mk.h"

<<global shell>>
<<global shellname>>

static	Word	*encodenulls(char*, int);

<<function readenv>>

<<function encodenulls>>

<<function exportenv>>

<<function waitfor>>

<<function expunge>>

<<function execsh>>

<<function pipecmd>>

<<function Exit>>

<<function notifyf>>

<<function catchnotes>>

<<function maketmp>>

<<function chgtime>>

<<function rcopy>>

<<function dirtime>>

<<function bulkmtime>>

<<function mkmtime>>

@


\subsection*{[[mk/archive.c]]}

<<function atimeof>>=
ulong
atimeof(int force, char *name)
{
    Symtab *sym;
    ulong t;
    char *archive, *member, buf[512];

    archive = split(name, &member);
    if(archive == 0)
        Exit();

    t = mtime(archive);
    sym = symlook(archive, S_AGG, 0);
    if(sym){
        if(force || t > sym->u.value){
            atimes(archive);
            sym->u.value = t;
        }
    }
    else{
        atimes(archive);
        /* mark the aggegate as having been done */
        symlook(strdup(archive), S_AGG, "")->u.value = t;
    }
        /* truncate long member name to sizeof of name field in archive header */
    snprint(buf, sizeof(buf), "%s(%.*s)", archive, utfnlen(member, SARNAME), member);
    sym = symlook(buf, S_TIME, 0);
    if (sym)
        return sym->u.value;
    return 0;
}
@

<<function atouch>>=
void
atouch(char *name)
{
    char *archive, *member;
    int fd, i;
    struct ar_hdr h;
    long t;

    archive = split(name, &member);
    if(archive == 0)
        Exit();

    fd = open(archive, ORDWR);
    if(fd < 0){
        fd = create(archive, OWRITE, 0666);
        if(fd < 0){
            perror(archive);
            Exit();
        }
        write(fd, ARMAG, SARMAG);
    }
    if(symlook(name, S_TIME, 0)){
        /* hoon off and change it in situ */
        LSEEK(fd, SARMAG, 0);
        while(read(fd, (char *)&h, sizeof(h)) == sizeof(h)){
            for(i = SARNAME-1; i > 0 && h.name[i] == ' '; i--)
                    ;
            h.name[i+1]=0;
            if(strcmp(member, h.name) == 0){
                t = SARNAME-sizeof(h);	/* ughgghh */
                LSEEK(fd, t, 1);
                fprint(fd, "%-12ld", time(0));
                break;
            }
            t = atol(h.size);
            if(t&01) t++;
            LSEEK(fd, t, 1);
        }
    }
    close(fd);
}
@

<<function atimes>>=
static void
atimes(char *ar)
{
    struct ar_hdr h;
    ulong at, t;
    int fd, i;
    char buf[BIGBLOCK];
    Dir *d;
    
    fd = open(ar, OREAD);
    if(fd < 0)
        return;

    if(read(fd, buf, SARMAG) != SARMAG){
        close(fd);
        return;
    }
    if((d = dirfstat(fd)) == nil){
        close(fd);
        return;
    }
    at = d->mtime;
    free(d);
    while(read(fd, (char *)&h, SAR_HDR) == SAR_HDR){
        t = strtoul(h.date, nil, 0);
        if(t >= at)	/* new things in old archives confuses mk */
            t = at-1;
        if(t == 0)	/* as it sometimes happens; thanks ken */
            t = 1;
        for(i = sizeof(h.name)-1; i > 0 && h.name[i] == ' '; i--)
            ;
        if(h.name[i] == '/')		/* system V bug */
            i--;
        h.name[i+1]=0;		/* can stomp on date field */
        snprint(buf, sizeof buf, "%s(%s)", ar, h.name);
        symlook(strdup(buf), S_TIME, (void*)t)->u.value = t;
        t = atol(h.size);
        if(t&01) t++;
        LSEEK(fd, t, 1);
    }
    close(fd);
}
@

<<function type>>=
static int
type(char *file)
{
    int fd;
    char buf[SARMAG];

    fd = open(file, OREAD);
    if(fd < 0){
        if(symlook(file, S_BITCH, 0) == 0){
            Bprint(&bout, "%s doesn't exist: assuming it will be an archive\n", file);
            symlook(file, S_BITCH, (void *)file);
        }
        return 1;
    }
    if(read(fd, buf, SARMAG) != SARMAG){
        close(fd);
        return 0;
    }
    close(fd);
    return strncmp(ARMAG, buf, SARMAG) == 0;
}
@

<<function split>>=
static char*
split(char *name, char **member)
{
    char *p, *q;

    p = strdup(name);
    q = utfrune(p, '(');
    if(q){
        *q++ = 0;
        if(member)
            *member = q;
        q = utfrune(q, ')');
        if (q)
            *q = 0;
        if(type(p))
            return p;
        free(p);
        fprint(2, "mk: '%s' is not an archive\n", name);
    }
    return 0;
}
@


%-------------------------------------------------------------

<<mk/archive.c>>=
#include	"mk.h"
#include	<ar.h>

static void atimes(char *);
static char *split(char*, char**);

<<function atimeof>>

<<function atouch>>

<<function atimes>>

<<function type>>

<<function split>>
@


\subsection*{[[mk/match.c]]}

%-------------------------------------------------------------

<<mk/match.c>>=
#include	"mk.h"

<<function match>>

<<function subst>>
@


\subsection*{[[mk/env.c]]}

%-------------------------------------------------------------

<<mk/env.c>>=
#include	"mk.h"

<<enum _anon_ (mk/env.c)>>

<<global envy>>
<<global nextv>>

<<global myenv>>

<<function initenv>>

<<function envinsert>>

<<function envupd>>

<<function ecopy>>

<<function execinit>>

<<function buildenv>>
@


\subsection*{[[mk/parse.c]]}

%-------------------------------------------------------------

<<mk/parse.c>>=
#include	"mk.h"

void	ipop(void);
void	ipush(void);

<<global infile>>
<<global mkinline>>

static int rhead(char *, Word **, Word **, int *, char **);
static char *rbody(Biobuf*);

<<function parse>>

<<function addrules>>

<<function rhead>>

<<function rbody>>

<<struct input>>
<<global inputs>>

<<function ipush>>

<<function ipop>>
@


\subsection*{[[mk/shprint.c]]}

<<function shprint>>=
void
shprint(char *s, Envy *env, Bufblock *buf)
{
    int n;
    Rune r;

    while(*s) {
        n = chartorune(&r, s);
        if (r == '$')
            s = vexpand(s, env, buf);
        else {
            rinsert(buf, r);
            s += n;
            s = copyq(s, r, buf);	/*handle quoted strings*/
        }
    }
    insert(buf, 0);
}
@
%$

<<function mygetenv>>=
static char *
mygetenv(char *name, Envy *env)
{
    if (!env)
        return 0;
    if (symlook(name, S_WESET, 0) == 0 && symlook(name, S_INTERNAL, 0) == 0)
        return 0;
        /* only resolve internal variables and variables we've set */
    for(; env->name; env++){
        if (strcmp(env->name, name) == 0)
            return wtos(env->values, ' ');
    }
    return 0;
}
@

<<function vexpand>>=
static char *
vexpand(char *w, Envy *env, Bufblock *buf)
{
    char *s, carry, *p, *q;

    assert(/*vexpand no $*/ *w == '$');
    p = w+1;	/* skip dollar sign */
    if(*p == '{') {
        p++;
        q = utfrune(p, '}');
        if (!q)
            q = strchr(p, 0);
    } else
        q = shname(p);
    carry = *q;
    *q = 0;
    s = mygetenv(p, env);
    *q = carry;
    if (carry == '}')
        q++;
    if (s) {
        bufcpy(buf, s, strlen(s));
        free(s);
    } else 		/* copy name intact*/
        bufcpy(buf, w, q-w);
    return(q);
}
@

<<function front>>=
void
front(char *s)
{
    char *t, *q;
    int i, j;
    char *flds[512];

    q = strdup(s);
    i = getfields(q, flds, nelem(flds), 0, " \t\n");
    if(i > 5){
        flds[4] = flds[i-1];
        flds[3] = "...";
        i = 5;
    }
    t = s;
    for(j = 0; j < i; j++){
        for(s = flds[j]; *s; *t++ = *s++);
        *t++ = ' ';
    }
    *t = 0;
    free(q);
}
@


%-------------------------------------------------------------

<<mk/shprint.c>>=
#include	"mk.h"

static char *vexpand(char*, Envy*, Bufblock*);
static char *shquote(char*, Rune, Bufblock*);
static char *shbquote(char*, Bufblock*);

<<function shprint>>

<<function mygetenv>>

<<function vexpand>>

<<function front>>
@


\subsection*{[[mk/job.c]]}


%-------------------------------------------------------------

<<mk/job.c>>=
#include	"mk.h"

<<function newjob>>

<<function dumpj>>
@


\subsection*{[[mk/arc.c]]}



<<function nrep>>=
void
nrep(void)
{
    Symtab *sym;
    Word *w;

    sym = symlook("NREP", S_VAR, 0);
    if(sym){
        w = sym->u.ptr;
        if (w && w->s && *w->s)
            nreps = atoi(w->s);
    }
    if(nreps < 1)
        nreps = 1;
    if(DEBUG(D_GRAPH))
        Bprint(&bout, "nreps = %d\n", nreps);
}
@


%-------------------------------------------------------------

<<mk/arc.c>>=
#include	"mk.h"

<<function newarc>>

<<function dumpa>>

<<function nrep>>
@


\subsection*{[[mk/rule.c]]}

<<global nrules>>=
static int nrules = 0;
@

<<function addrule>>=
void
addrule(char *head, Word *tail, char *body, Word *ahead, int attr, int hline, char *prog)
{
    Rule *r;
    Rule *rr;
    Symtab *sym;
    int reuse;

    r = 0;
    reuse = 0;
    if(sym = symlook(head, S_TARGET, 0)){
        for(r = sym->u.ptr; r; r = r->chain)
            if(rcmp(r, head, tail) == 0){
                reuse = 1;
                break;
            }
    }
    if(r == 0)
        r = (Rule *)Malloc(sizeof(Rule));
    r->target = head;
    r->tail = tail;
    r->recipe = body;
    r->line = hline;
    r->file = infile;
    r->attr = attr;
    r->alltargets = ahead;
    r->prog = prog;
    r->rule = nrules++;

    if(!reuse){
        rr = symlook(head, S_TARGET, r)->u.ptr;
        if(rr != r){
            r->chain = rr->chain;
            rr->chain = r;
        } else
            r->chain = 0;
    }
    if(!reuse)
        r->next = 0;
    if((attr&REGEXP) || charin(head, "%&")){
        r->attr |= META;
        if(reuse)
            return;
        if(attr&REGEXP){
            patrule = r;
            r->pat = regcomp(head);
        }
        if(metarules == 0)
            metarules = lmr = r;
        else {
            lmr->next = r;
            lmr = r;
        }
    } else {
        if(reuse)
            return;
        r->pat = 0;
        if(rules == 0)
            rules = lr = r;
        else {
            lr->next = r;
            lr = r;
        }
    }
}
@


<<function rcmp>>=
static int
rcmp(Rule *r, char *target, Word *tail)
{
    Word *w;

    if(strcmp(r->target, target))
        return 1;
    for(w = r->tail; w && tail; w = w->next, tail = tail->next)
        if(strcmp(w->s, tail->s))
            return 1;
    return(w || tail);
}
@

<<function rulecnt>>=
char *
rulecnt(void)
{
    char *s;

    s = Malloc(nrules);
    memset(s, 0, nrules);
    return(s);
}
@


%-------------------------------------------------------------

<<mk/rule.c>>=
#include	"mk.h"

static Rule *lr, *lmr;
static int rcmp(Rule *r, char *target, Word *tail);
<<global nrules>>

<<function addrule>>

<<function dumpr>>

<<function rcmp>>

<<function rulecnt>>
@


\subsection*{[[mk/lex.c]]}

%-------------------------------------------------------------

<<mk/lex.c>>=
#include	"mk.h"

static	int	bquote(Biobuf*, Bufblock*);

<<function assline>>

<<function bquote>>

<<function nextrune>>
@


\subsection*{[[mk/file.c]]}

%-------------------------------------------------------------

<<mk/file.c>>=
#include	"mk.h"

<<function mtime>>

<<function timeof>>

<<function touch>>

<<function delete>>

<<function timeinit>>
@


\subsection*{[[mk/run.c]]}


%-------------------------------------------------------------

<<mk/run.c>>=
#include	"mk.h"

<<struct RunEvent>>

<<global events>>
static int nevents;
static int nrunning;
static int nproclimit;

<<struct Process>>
<<global phead>>
<<global pfree>>

static void sched(void);
static void pnew(int, int);
static void pdelete(Process *);

int pidslot(int);

<<function run>>

<<function sched>>

<<function waitup>>

<<function nproc>>

<<function nextslot>>

<<function pidslot>>


<<function pnew>>

<<function pdelete>>

<<function killchildren>>

<<global tslot>>
<<global tick>>

<<function usage>>

<<function prusage>>
@


\subsection*{[[mk/graph.c]]}


<<function attribute>>=
static void
attribute(Node *n)
{
    register Arc *a;

    for(a = n->prereqs; a; a = a->next){
        if(a->r->attr&VIR)
            n->flags |= VIRTUAL;
        if(a->r->attr&NOREC)
            n->flags |= NORECIPE;
        if(a->r->attr&DEL)
            n->flags |= DELETE;
        if(a->n)
            attribute(a->n);
    }
    if(n->flags&VIRTUAL)
        n->time = 0;
}
@


%-------------------------------------------------------------

<<mk/graph.c>>=
#include	"mk.h"

static Node *applyrules(char *, char *);
static void togo(Node *);
static int vacuous(Node *);
static Node *newnode(char *);
static void trace(char *, Arc *);
static void cyclechk(Node *);
static void ambiguous(Node *);
static void attribute(Node *);

<<function graph>>

<<function applyrules>>

<<function togo>>

<<function vacuous>>

<<function newnode>>

<<function dumpn>>

<<function trace>>

<<function cyclechk>>

<<function ambiguous>>

<<function attribute>>
@


\subsection*{[[mk/mk.c]]}


%-------------------------------------------------------------

<<mk/mk.c>>=
#include	"mk.h"

void	clrmade(Node*);
int	work(Node*, Node*, Arc*);

<<global runerrs>>

<<function mk>>

<<function clrmade>>

<<function unpretend>>

<<function work>>

<<function update>>

<<function pcmp>>

<<function outofdate>>
@


\subsection*{[[mk/recipe.c]]}


%-------------------------------------------------------------

<<mk/recipe.c>>=
#include	"mk.h"

void	addw(Word*, char*);

<<function dorecipe>>

<<function addw>>
@


\subsection*{[[mk/varsub.c]]}


%-------------------------------------------------------------

<<mk/varsub.c>>=
#include	"mk.h"

static	Word		*subsub(Word*, char*, char*);
static	Word		*expandvar(char**);
static	Bufblock	*varname(char**);
static	Word		*extractpat(char*, char**, char*, char*);
static	int		submatch(char*, Word*, Word*, int*, char**);
static	Word		*varmatch(char *);

<<function varsub>>

<<function varname>>

<<function varmatch>>

<<function expandvar>>

<<function extractpat>>

<<function subsub>>

<<function submatch>>
@


\subsection*{[[mk/main.c]]}


<<function regerror>>=
//void
//regerror(char *s)
//{
//    if(patrule)
//        fprint(2, "mk: %s:%d: regular expression error; %s\n",
//            patrule->file, patrule->line, s);
//    else
//        fprint(2, "mk: %s:%d: regular expression error; %s\n",
//            infile, mkinline, s);
//    Exit();
//}
@


%-------------------------------------------------------------

<<mk/main.c>>=
#include	"mk.h"

<<constant MKFILE>>

<<global version>>

// see also globals.c

<<global uflag>>

void badusage(void);
#ifdef	PROF
<<global buf>>
#endif

<<function main>>

<<function badusage>>

<<function regerror>>
@


