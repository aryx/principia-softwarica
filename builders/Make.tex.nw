\documentclass[twocolumn]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse
% see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things:
% - dead code (S_PID, S_MAKEFILE)

%thx to codemap/codegraph/scheck:
% - use cg to reduce backward deps, introduce globals.c, utils.c,
%   (harder to understand non layered code)
% - use scheck to remove deadcode, dead prototypes, useless export
%   or mv as forward decl
%   (harder to understand big interface files)
% - LESS use cg to reduce number of globals by moving them closer to the
%   relevant file (or even function), better cluster the code
%   (harder to understand non functional code using lots of globals)

%thx to this manual, better understand make?:
% - SEMI how to debug issues in your own makefile

%history LP-ization:
% - skeleton, mostly copy paste of Template.tex.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * TODO ctor/dtor, dumper
%    * [[xxx]] other fields, [[xxx]] extra fields
% - read Extra section, identify concepts, first TOC
% - SEMI distribute parts of the Extra section in the main file
% - understand main(), LP split main, improve TOC
% - TODO understand main functions, LP split, cluster, improve TOC
% - SEMI LP split the structures, use datalog for flow to field info
% - SEMI nullify, boolify, errorify, enumify,  typeify,    scheckify, plan9ify
% - SEMI aspecify advanced features! remove useless features
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\iffinal
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\fi
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
%\usepackage{cleveref} %\cref
%\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}
 %\usepackage[margin=0.5in]{geometry}
 %  but eat the bottom when very low
 %\usepackage{fullpage} is deprecated 
 % => do the more manual below:
 \addtolength{\oddsidemargin}{-.850in}
 \addtolength{\evensidemargin}{-.850in}
 \addtolength{\textwidth}{1.70in}
 \addtolength{\topmargin}{-.850in}
 \addtolength{\textheight}{1.70in}
%\usepackage{minitoc}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% used for forward decl, pragmas, func decl, extern decl, stats, #ifdef,
% debugging macros

%\setcounter{tocdepth}{1}

%******************************************************************************
% Title
%******************************************************************************

\begin{document}

\title{
{\Huge 
Principia Softwarica: The Plan9 Build Tool [[mk]]
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}
}

\maketitle 
\onecolumn
\hrule
\begin{quote}
    Copyright \copyright{} 2014 Yoann Padioleau \\
    Permission is granted to copy, distribute and/or modify this document,
    except all the source code it contains, under the terms of the GNU Free
    Documentation License, Version 1.3.
\end{quote}
\hrule

%CONFIG: \dominitoc

\iffinal
\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\twocolumn
\tableofcontents
\endgroup
\else
\tableofcontents
\fi

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

\section{Motivations}

The goal of this book is to present in full details the source code of
a build tool.
Why? Because I think it makes you a better programmer if
you fully understand how things work under the hood.

% we gonna present mk.

Here are other candidates that were considered but ultimately discarded:
\begin{itemize}
\item UNIX make
\item GNU make
\item cmake
\item ant
\item maven
\end{itemize}

% gyp, ninja, buck, qake, ... huge list
%https://en.wikipedia.org/wiki/List_of_build_automation_software

%but make advocacy :)
%http://bost.ocks.org/mike/make/
%http://hadihariri.com/2014/04/21/build-make-no-more/

\section{Getting started}

% can get the one from kencc? or plan9port?
% issues though with rc vs sh ...

\section{Requirements}

% mk.ps! and mk(1)
I assume you have read the \f{mk.ps} paper that introduces
the concepts used in this document (e.g. what is a \co{rule},
a \co{target}, a \co{recipe}, etc) as well as [[mk]] man page.

%(and mk_successor_make.pdf if interested specifically of diff with make)

\section{About this document}
#include "../docs/latex/About.tex.nw"

\section{Copyright}

Most of this document is actually source code from Plan9, so
those parts are copyright by Lucent Technologies Inc.
The prose is mine and is licensed under the GNU Free Documentation
License.

\section{Acknowledgments}

I would like to acknowledge of course mk's authors who wrote
most of this book: Andrew Hume and Bob Flandera.

\chapter{Overview}

\section{Build system principles}

The goal of a build system is to describe concisely and maintain
efficiently \co{dependencies} between files or programs.

% conciseness => DSL
% efficiency => graph and //

% rule, target: dependencies
% metarules, variables => generic stuff
% < so modularity and can factorize in different files

\section{[[mk]] services}

% interface is pretty simple, go in dir, type 'mk'
% or mk target

<<constant MKFILE>>=
#define	MKFILE		"mkfile"
@


<<global version>>=
static char *version = "@(#)mk general release 4 (plan 9)";
@

% has also many -xxx options

<<function badusage>>=
void
badusage(void)
{

    fprint(STDERR, "Usage: mk [-f file] [-n] [-a] [-e] [-t] [-k] [-i] [-d[egp]] [targets ...]\n");
    Exit();
}
@

\section{A simple [[mkfile]]}
% actually could also show the mkfile of mk itself :)

% running example
% concepts: target, prerequistes, recipe

% show also simple output of running mk on a toy project
% maybe even include mk -e output?

% differences with make? gnu make? see mk.ps section 4
%  well many mk extensions have become gnu make, e.g. %.c rules instead of .c
%  (hmm still? mk introduced pattern metarules, but metarules may have been
%   in research UNIX make)
%  less uglyness with variables too, no $$i need, variables passed as is
%  (like for rc, cleaner?)

\section{Code organization}

%fns.h: forward function declarations (prototypes)
%mk.h: main data structures and globals declarations

%utils.c: libc like helper functions
%plan9.c: libc like helper functions plan9 specific (unix.c, windows.c)
% (rename os.c?)
%bufblock.c: buffered IO
%word.c: list of strings

%globals.c: globals definitions
%symtab.c: global hash table

%lex.c: parsing recipe
%parse.c: parsing mkfile
%varsub.c: managing variables and substitution
%var.c: setvar(), dumper, utilities
%rc.c: rc interaction, quote, unquote, escaping, etc
%rule.c: addrule(), dumper

%arc.c: newarc(), dumper, nrep() (move it?)
%graph.c: graph(), building the dependency graph
%match.c: match() and subst() for metarules

%archive.c: special archive extension xxx(yyy)

%file.c: timeof(), touch(), delete()
%run.c: job schedule, run(), sched(), profiling processors
%mk.c: mk() and work(), building the graph and then the targets
%recipe.c: dorecipe()
%env.c: recipe environment
%job.c: newjob(), dumper

%shprint.c: ?

%main.c: main() entry point!

\section{Architecture overview}

% graphviz of files? or just of the types?

% main() -> parse(mkfile) (populate rules, metarules, target1, S_VAR, ...)
%        -> mk(target1) -> graph(target1)
%                       -> work(node) -> outofdate(file)
%                                     -> run(job)

%###############################################################################

\chapter{Core Data Structures}

% core types: (see mk.h)
% Rule (mk -dp?), recipe? metarule, target, prerequiste (see mk.ps)
% Word, Bufblock
% Node, Arc (mk -dg)
% Envy
% Job, (mk -de)
% Sym (a bit generic, could be in libc?)

% core globals: (see mk.h externs)
% envy,    rules, metarules, patrule,    jobs
% symbol hashtbl global
% bout

% draw diagram showing relations to each other, what includes what


\section{[[Symtab]] and [[hash]]}

<<struct Symtab>>=
struct Symtab
{
    // the key
    char		*name;
    // enum<sxxx>, the ``namespace''
    short		space;

    // the value (generic)
    union{
        void*	ptr;
        uintptr	value;
    } u;

    // Extra
    <<[[Symtab]] extra fields>>
};
@


% the "world" data structure, but more for efficiency retrieval
%less: could use a record instead of that which would be better typed
<<enum sxxx>>=
enum sxxx {
    S_VAR,	/* variable -> value */ // value is a list of words
    <<enum sxxx cases>>
};
@
%old and dead:
%S_PID,		/* pid -> products */
%S_MAKEFILE,	/* target -> node */

<<constant NHASH>>=
#define	NHASH	4099
@

<<global hash>>=
// hash<(string * enum<sxxx>), 'b> (next = Symtab.next in bucket)
static Symtab *hash[NHASH];
@

<<[[Symtab]] extra fields>>=
struct Symtab	*next;
@

% main -> <>
<<function syminit>>=
void
syminit(void)
{
    Symtab **s, *ss;

    for(s = hash; s < &hash[NHASH]; s++){
        for(ss = *s; ss; ss = ss->next)
            free((char *)ss);
        *s = nil;
    }
}
@

<<constant HASHMUL>>=
#define	HASHMUL	79L	/* this is a good value */
@

<<function symlook>>=
Symtab*
symlook(char *sym, int space, void *install)
{
    long h;
    char *p;
    Symtab *s;

    //h = hash(sym, space)
    for(p = sym, h = space; *p; h += *p++)
        h *= HASHMUL;
    if(h < 0)
        h = ~h;
    h %= NHASH;

    for(s = hash[h]; s; s = s->next)
        if((s->space == space) && (strcmp(s->name, sym) == 0))
            return s;

    if(install == nil)
        return nil;

    s = (Symtab *)Malloc(sizeof(Symtab));
    s->space = space;
    s->name = sym;
    s->u.ptr = install;

    s->next = hash[h];
    hash[h] = s;

    return s;
}
@

<<function symtraverse>>=
void
symtraverse(int space, void (*fn)(Symtab*))
{
    Symtab **s, *ss;

    for(s = hash; s < &hash[NHASH]; s++)
        for(ss = *s; ss; ss = ss->next)
            if(ss->space == space)
                (*fn)(ss);
}
@

<<function setvar>>=
void
setvar(char *name, void *value)
{
    symlook(name, S_VAR, value)->u.ptr = value;
    symlook(name, S_MAKEVAR, (void*)"");
}
@

<<enum sxxx cases>>=
S_MAKEVAR,	/* dumpable mk variable */
@



<<enum sxxx cases>>=
S_INTERNAL,	/* an internal mk variable (e.g., stem, target) */
@

<<global myenv>>=
static char	*myenv[] =
{
    "target",
    "stem",
    "prereq",

    "pid",
    "nproc",
    "newprereq",
    "alltarget",
    "newmember",

    <<[[myenv]] other array elements>>

    0,
};
@
% $stem $prereq
% (better than $@, $^ )

% main ->
<<function initenv>>=
void
initenv(void)
{
    char **p;

    for(p = myenv; *p; p++)
        symlook(*p, S_INTERNAL, (void *)"");
    readenv();				/* o.s. dependent */
}
@



\section{[[Word]]s}
% could put [[target1]] here too? but it's really not a Words ...

% what is this for? it has to be Words otherwise
% there is no much point in having a Word type that is
% just a wrapper over char*
% HFILES=fns.h mk.h => list of 2 words

% should be renamed words ...
<<struct Word>>=
struct Word
{
    char 		*s;
    struct Word 	*next;
};
@


% rename newword_list?
<<constructor newword>>=
Word*
newword(char *s)
{
    Word *w;

    w = (Word *)Malloc(sizeof(Word));
    w->s = strdup(s);
    w->next = nil;
    return w;
}
@

% it's actually delwords
<<destructor delword>>=
void
delword(Word *w)
{
    Word *v;

    while(v = w){
        w = w->next;
        if(v->s)
            free(v->s);
        free(v);
    }
}
@

<<function wdup>>=
Word*
wdup(Word *w)
{
    Word *v, *new, *base;

    v = base = nil;
    while(w){
        new = newword(w->s);
        if(v)
            v->next = new;
        else
            base = new;
        v = new;
        w = w->next;
    }
    return base;
}
@

% word to string
<<function wtos>>=
char *
wtos(Word *w, int sep)
{
    Bufblock *buf;
    char *cp;

    buf = newbuf();
    for(; w; w = w->next){
        for(cp = w->s; *cp; cp++)
            insert(buf, *cp);
        if(w->next)
            insert(buf, sep);
    }
    insert(buf, '\0');
    cp = strdup(buf->start);
    freebuf(buf);
    return cp;
}
@



\section{[[Rule]], [[rules]] and [[metarules]]}

% todo: aspectize split
<<struct Rule>>=
struct Rule
{
    char 		*target;	/* one target */
    //list<ref_own<string>>
    Word 		*tail;		/* constituents of targets */
    char 		*recipe;	/* do it ! */

    char* 		file;		/* source file */
    short 		line;		/* source line */

    // enum<rule_attr>
    short 		attr;		/* attributes */

    <<[[Rule]] other fields>>

    // Extra
    <<[[Rule]] extra fields>>
};
@
% rename tail to prerequistes?
% recipe can contain $, target and tail not, the variables are expanded
% at parsing time for that I think.
% can also be metarule, %.$O: %.c (but $O would have been expanded)

% from man page:
%  Variable substitution in a rule is done when
%  the rule is read; variable substitution in the recipe is done
%  when the recipe is executed.
% why? probably because recipe/rc will do the subst itself, but for
% the graph we need concrete values so fasted to do it eagerly when parsing

<<global rules>>=
// list<ref_own<Rule>> (next = Rule.next)
Rule *rules;
@

<<[[Rule]] extra fields>>=
// list<ref_own<Rule>> (head = rules)
struct Rule	*next;
@



<<enum rule_attr>>=
enum rule_attr {
    META   = 0x0001,
    <<enum rule_attr cases>>
};
@


<<global metarules>>=
// list<ref_own<Rule>>
Rule *metarules;
@

<<function PERCENT>>=
#define	PERCENT(ch)	(((ch) == '%') || ((ch) == '&'))
@
% from man page:
% '%' matches a maximal length string of any characters;
% '&' matches a maximal length string of any characters except period or slash




% used in addrule()
<<enum sxxx cases>>=
S_TARGET,		/* target -> rule */
@


<<[[Rule]] extra fields>>=
struct Rule	*chain;		/* hashed per target */
@


<<enum rule_attr cases>>=
//@Scheck: dead indeed
UNUSED = 0x0002,
UPD    = 0x0004,
QUIET  = 0x0008,
VIR    = 0x0010,
REGEXP = 0x0020,
NOREC  = 0x0040,
DEL    = 0x0080,
NOVIRT = 0x0100,
@


%XXXX??
<<[[Rule]] other fields>>=
char		*prog;		/* to use in out of date */
@
% prog??


\section{[[Node]] and [[Arc]]}

% Rule and metarules are general static descriptions, patterns.
% Node and Arc are concrete instantiation with existing files.
% the actual graph of dependencies! nodes are target names usually filenames
% arcs link nodes to other filenames with a rule attached to know what to do

% it's really more a DAG than a graph, there should be no cycle
% (see cycle check section)

<<struct Node>>=
struct Node
{
    // usually a filename, or target label like 'default'
    char*		name; 
    // last mtime of the file (or zero for non existing files)
    ulong		time;
    // bitset<enum<node_flag>>
    ushort		flags;

    <<[[Node]] other fields>>

    // Extra
    <<[[Node]] extra fields>>
};
@

<<enum sxxx cases>>=
S_NODE,		/* target name -> node */
@

% dtor = ?
<<constructor newnode>>=
static Node *
newnode(char *name)
{
    register Node *node;

    node = (Node *)Malloc(sizeof(Node));
    symlook(name, S_NODE, (void *)node);
    node->name = name;
    node->time = timeof(name, false);
    node->flags = (node->time? PROBABLE : 0);
    node->prereqs = nil;
    node->next = nil;
    return node;
}
@


<<[[Node]] other fields>>=
// list<ref_own<Arc>> (next = Arc.next)
Arc		*prereqs;
@


<<struct Arc>>=
struct Arc
{
    // ref<Node>, dst node in the arc (src is the Node having the prereqs)
    struct Node *n;
    // ref<Rule>, rule to generate the target node from the dependent node
    Rule *r;
    //? enum<rule_flag>?
    short flag;

    <<[[Arc]] other fields>>
    
    //Extra
    <<[[Arc]] extra fields>>
};
@


<<[[Arc]] extra fields>>=
// list<ref_own<arc> (head = Node.prereq)
struct Arc	*next;
@




% node   arc   rule   relations?

% so knows how to run the rule, subst the % by the actual value
% when the rule is a metarule
<<[[Arc]] other fields>>=
// what will replace the %
char		*stem;
@



% dtor = ?
<<constructor newarc>>=
Arc *
newarc(Node *n, Rule *r, char *stem, Resub *match)
{
    Arc *a;

    a = (Arc *)Malloc(sizeof(Arc));
    a->n = n;
    a->r = r;
    a->stem = strdup(stem);
    rcopy(a->match, match, NREGEXP);
    a->next = nil;
    a->flag = 0;
    a->prog = r->prog;
    return a;
}
@




%XXX?
<<[[Arc]] other fields>>=
char		*prog;
@


<<constant TOGO>>=
/* Arc.flag */
#define		TOGO		1
@



<<enum node_flag>>=
enum node_flag {
    <<enum node_flag cases>>
};
@
% used to be a set of #define

<<enum node_flag cases>>=
VIRTUAL    = 0x0001,
CYCLE      = 0x0002,
READY      = 0x0004,
CANPRETEND = 0x0008,
PRETENDING = 0x0010,
NOTMADE    = 0x0020,
BEINGMADE  = 0x0040,
MADE       = 0x0080,
PROBABLE   = 0x0100,
VACUOUS    = 0x0200,
NORECIPE   = 0x0400,
DELETE     = 0x0800,
NOMINUSE   = 0x1000,
@

<<function MADESET>>=
#define	MADESET(n,m)	n->flags = (n->flags&~(NOTMADE|BEINGMADE|MADE))|(m)
@





\section{[[Envy]] and [[envy]]}

% variables, different occurences: in rule target, prerequistes,
% or in recipe. Different handling depending on context.

% Not envy :) just environment variable stuff, rename?
<<struct Envy>>=
struct Envy
{
    char 		*name;

    // list<ref_own<string>>
    Word 		*values;
};
@


<<global envy>>=
// array<ref_own<Envy>> (array or list?)
Envy	*envy;
@

<<constant ENVQUANTA>>=
#define ENVQUANTA 10
@

<<global nextv>>=
// idx for next free entry in envy array
static int nextv;
@

<<function envinsert>>=
static void
envinsert(char *name, Word *value)
{
    static int envsize;

    if (nextv >= envsize) {
        envsize += ENVQUANTA;
        envy = (Envy *) Realloc((char *) envy, envsize*sizeof(Envy));
    }
    envy[nextv].name = name;
    envy[nextv++].values = value;
}
@








\section{[[Job]] and [[jobs]]}

<<struct Job>>=
struct Job
{
    Word		*t;	/* targets */
    Rule		*r;	/* master rule for job */

    // list<ref_?<Node>> (next = Node.next?)
    Node		*n;	/* list of node targets */

    char		*stem;

    Word		*p;	/* prerequistes */
    Word		*np;	/* new prerequistes */
    Word		*at;	/* all targets */

    int		nproc;	/* slot number */

    <<[[Job]] other fields>>

    // Extra
    <<[[Job]] extra fields>>
};
@


<<constructor newjob>>=
Job*
newjob(Rule *r, Node *nlist, char *stem, char **match, Word *pre, Word *npre, Word *tar, Word *atar)
{
    register Job *j;

    j = (Job *)Malloc(sizeof(Job));
    j->r = r;
    j->n = nlist;
    j->stem = stem;
    j->match = match;
    j->p = pre;
    j->np = npre;
    j->t = tar;
    j->at = atar;
    j->nproc = -1;
    j->next = nil;
    return j;
}
@

% ???? Job.n?
<<[[Node]] extra fields>>=
struct Node	*next;		/* list for a rule */
@






<<global jobs>>=
// list<ref_won<jobs>> (next = Job.next)
Job *jobs;
@

<<[[Job]] extra fields>>=
struct Job	*next;
@







\chapter{[[main()]]}

<<global bout>>=
Biobuf bout;
@

<<[[main()]] locals>>=
Bufblock *buf = newbuf();
@



\ifallcode
<<[[main()]] locals>>=
Word *w;
char *s;
int i;
@
\fi

<<function main>>=
void
main(int argc, char **argv)
{
    <<[[main()]] locals>>

    /*
     *  start with a copy of the current environment variables
     *  instead of sharing them
     */
    Binit(&bout, STDOUT, OWRITE);

    <<[[main()]] argv processing for -xxx, modify flags, modify buf>>

    <<[[main()]] setup optional profiling>>
    syminit();
    initenv();

    usage(); // useful?

    <<[[main()]] argv processing for xxx=>>

    <<[[main()]] set MKFLAGS variable>>
    <<[[main()]] set MKARGS variable>>

    <<[[main()]] parsing mkfile, call parse()>>

    <<[[main()]] if DEBUG(D_PARSE)>>
    <<[[main()]] if whatif>>

    execinit();

    /* skip assignment args */
    while(*argv && (**argv == '\0'))
        argv++;

    catchnotes();

    <<[[main()]] building the targets, call mk()>>

    <<[[main()]] print profiling stats if uflag>>
    exits(nil);
}
@

\section{[[mk -xxx]] argument processing}

<<[[main()]] argv processing for -xxx, modify flags, modify buf>>=
USED(argc);
for(argv++; *argv && (**argv == '-'); argv++)
{
    bufcpy(buf, argv[0], strlen(argv[0]));
    insert(buf, ' ');

    switch(argv[0][1]) {
    <<[[main()]] -xxx switch cases>>
    default:
        badusage();
    }
}
@


\section{[[mk xxx=yyy]] argument processing}

% mk CC=6c default => override

<<[[main()]] locals>>=
char *temp;
fdt tfd = -1;
Biobuf tb;
@

<<[[main()]] argv processing for xxx=>>=
/*
 *   assignment args become null strings
 */
temp = 0;
for(i = 0; argv[i]; i++) 
  if(utfrune(argv[i], '=')){
    bufcpy(buf, argv[i], strlen(argv[i]));
    insert(buf, ' ');
    if(tfd < 0){
        temp = maketmp();
        if(temp == nil) {
            perror("temp file");
            Exit();
        }
        if((tfd = create(temp, ORDWR, 0600)) < 0){
            perror(temp);
            Exit();
        }
        Binit(&tb, tfd, OWRITE);
    }
    Bprint(&tb, "%s\n", argv[i]);
    *argv[i] = '\0';
  }
if(tfd >= 0){
    Bflush(&tb);
    seek(tfd, 0L, SEEK__START);
    parse("<command line args>", tfd, true);
    remove(temp);
}
@
% abuse parse(), pass true so will get varoverride to true
%old: seek() used to be LSEEK() a macro expanding ultimately to seek

\section{Setting [[MKFLAGS]], [[MKARGS]]}
% used by? at least mkfile called recursively can expect those variables

<<[[main()]] set MKFLAGS variable>>=
if (buf->current != buf->start) {
    buf->current--;
    insert(buf, '\0');
}
symlook("MKFLAGS", S_VAR, (void*) stow(buf->start));
@

<<[[main()]] set MKARGS variable>>=
buf->current = buf->start;
for(i = 0; argv[i]; i++){
    if(*argv[i] == '\0') 
        continue;
    if(i)
        insert(buf, ' ');
    bufcpy(buf, argv[i], strlen(argv[i]));
}
insert(buf, '\0');
symlook("MKARGS", S_VAR, (void *) stow(buf->start));

freebuf(buf);
@


\section{Parsing [[mkfile]], and [[mk -f]]}

% mk -f
<<[[main()]] locals>>=
char *files[256], **f = files;
char **ff;
@

<<[[main()]] -xxx switch cases>>=
case 'f':
    if(*++argv == nil)
        badusage();
    *f++ = *argv;
    bufcpy(buf, argv[0], strlen(argv[0]));
    insert(buf, ' ');
    break;
@


<<[[main()]] parsing mkfile, call parse()>>=
if(f == files){
    if(access(MKFILE, 4) == 0)
        parse(MKFILE, open(MKFILE, 0), false);
} else
    for(ff = files; ff < f; ff++)
        parse(*ff, open(*ff, 0), false);
@




\section{Building the targets, [[mk(target)]]}

<<[[main()]] building the targets, call mk()>>=
if(*argv == nil){
    <<[[main()]] when no target arguments>>
} else {
    <<[[main()]] if sequential mode and target arguments given>>
    else {
       <<[[main()]] parallel mode and target arguments given>>
    }
}
@

% e.g. 'default', 
% should be a single word (but consistent to use Word)
% should be initialized while parsing with the first rule added
<<global target1>>=
Word *target1;
@

<<[[main()]] when no target arguments>>=
if(target1)
    for(w = target1; w; w = w->next)
        // The call!
        mk(w->s);
else {
    fprint(STDERR, "mk: nothing to mk\n");
    Exit();
}
@



%\subsection{Sequential mode}

% sequential not parallel command line arguments
<<[[main()]] locals>>=
bool sflag = false;
@

<<[[main()]] -xxx switch cases>>=
case 's':
    sflag = true;
    break;
@

<<[[main()]] if sequential mode and target arguments given>>=
if(sflag){
    for(; *argv; argv++)
        if(**argv)
            mk(*argv);
}
@


<<[[main()]] parallel mode and target arguments given>>=
Word *head, *tail, *t;

/* fake a new rule with all the args as prereqs */
tail = nil;
t = nil;
for(; *argv; argv++)
    if(**argv){
        if(tail == nil)
            tail = t = newword(*argv);
        else {
            t->next = newword(*argv);
            t = t->next;
        }
    }
if(tail->next == nil)
    mk(tail->s);
else {
    head = newword("<command line arguments>");
    addrules(head, tail, strdup(""), VIR, mkinline, 0);
    mk(head->s);
}
@
% could pass 0 instead of mkinline I think


\chapter{[[mk()]]}

% main -> <> -> graph() ; clrmade(); work()
<<function mk>>=
void
mk(char *target)
{
    Node *node;
    bool did = false;

    nproc();		/* it can be updated dynamically */
    nrep();		/* it can be updated dynamically */
    runerrs = 0;

    node = graph(target);
    <<[[main()]] if DEBUG(D_GRAPH)>>
    clrmade(node);

    while(node->flags&NOTMADE){
        if(work(node, (Node *)nil, (Arc *)nil))
            did = true;	/* found something to do */
        else {
            if(waitup(1, (int *)0) > 0){
                if(node->flags&(NOTMADE|BEINGMADE)){
                    assert(/*must be run errors*/ runerrs);
                    break;	/* nothing more waiting */
                }
            }
        }
    }
    if(node->flags&BEINGMADE)
        waitup(-1, (int *)0);
    while(jobs)
        waitup(-2, (int *)0);

    assert(/*target didnt get done*/ runerrs || (node->flags&MADE));
    if(did == false)
        Bprint(&bout, "mk: '%s' is up to date\n", node->name);
}
@


<<function clrmade>>=
void
clrmade(Node *n)
{
    Arc *a;

    n->flags &= ~(CANPRETEND|PRETENDING);
    if(strchr(n->name, '(') ==0 || n->time)
        n->flags |= CANPRETEND;

    MADESET(n, NOTMADE);
    for(a = n->prereqs; a; a = a->next)
        if(a->n)
            clrmade(a->n);
}
@

<<function unpretend>>=
static void
unpretend(Node *n)
{
    MADESET(n, NOTMADE);
    n->flags &= ~(CANPRETEND|PRETENDING);
    n->time = 0;
}
@

% TODO LP split, complicated
% main -> mk -> WORK -> outofdate(); dorecipe()
<<function work>>=
bool
work(Node *node, Node *p, Arc *parc)
{
    bool did = false;
    bool weoutofdate;
    bool ready;
    char cwd[256];
    Arc *a, *ra;

    /*print("work(%s) flags=0x%x time=%lud\n", node->name, node->flags, node->time);/**/

    if(node->flags&BEINGMADE)
        return did;

    if((node->flags&MADE) && (node->flags&PRETENDING) && p
        && outofdate(p, parc, 0)){
        if(explain)
            fprint(1, "unpretending %s(%lud) because %s is out of date(%lud)\n",
                node->name, node->time, p->name, p->time);
        unpretend(node);
    }
    /*
     *   have a look if we are pretending in case
     *   someone has been unpretended out from underneath us
     */
    if(node->flags&MADE){
        if(node->flags&PRETENDING){
            node->time = 0;
        }else
            return did;
    }

    /* consider no prerequisite case */
    if(node->prereqs == nil){
        if(node->time == 0){
            if(getwd(cwd, sizeof cwd))
                fprint(STDERR, "mk: don't know how to make '%s' in directory %s\n", node->name, cwd);
            else
                fprint(STDERR, "mk: don't know how to make '%s'\n", node->name);

            if(kflag){
                node->flags |= BEINGMADE;
                runerrs++;
            } else
                Exit();
        } else
            MADESET(node, MADE);
        return did;
    }

    /*
     *   now see if we are out of date or what
     */
    ready = true;
    weoutofdate = aflag;
    ra = nil;
    for(a = node->prereqs; a; a = a->next)
        if(a->n){
            did = work(a->n, node, a) || did;
            if(a->n->flags&(NOTMADE|BEINGMADE))
                ready = false;
            if(outofdate(node, a, 0)){
                weoutofdate = true;
                if((ra == nil) || (ra->n == nil) || (ra->n->time < a->n->time))
                    ra = a;
            }
        } else {
            if(node->time == 0){
                weoutofdate = true;
                if(ra == nil)
                    ra = a;
            }
        }
    if(ready == false)	/* can't do anything now */
        return did;

    if(weoutofdate == false){
        MADESET(node, MADE);
        return did;
    }
    /*
     *   can we pretend to be made?
     */
    if((iflag == false) && (node->time == 0) 
            && (node->flags&(PRETENDING|CANPRETEND))
            && p && ra->n && !outofdate(p, ra, 0)){
        node->flags &= ~CANPRETEND;
        MADESET(node, MADE);
        if(explain && ((node->flags&PRETENDING) == 0))
            fprint(1, "pretending %s has time %lud\n", node->name, node->time);
        node->flags |= PRETENDING;
        return did;
    }
    /*
     *   node is out of date and we REALLY do have to do something.
     *   quickly rescan for pretenders
     */
    for(a = node->prereqs; a; a = a->next)
        if(a->n && (a->n->flags&PRETENDING)){
            if(explain)
                Bprint(&bout, "unpretending %s because of %s because of %s\n",
                a->n->name, node->name, 
                ra->n? ra->n->name : "rule with no prerequisites");

            unpretend(a->n);
            did = work(a->n, node, a) || did;
            ready = false;
        }

    if(ready == false)/* try later unless nothing has happened for -k's sake */
        return did || work(node, p, parc);

    did = dorecipe(node) || did;
    return did;
}
@


<<enum sxxx cases>>=
S_OUTOFDATE,	/* n1\377n2 -> 2(outofdate) or 1(not outofdate) */
@

<<function outofdate>>=
bool
outofdate(Node *node, Arc *arc, int eval)
{
    char buf[3*NAMEBLOCK], *str;
    Symtab *sym;
    int ret;

    str = 0;
    if(arc->prog){
        snprint(buf, sizeof buf, "%s%c%s", node->name, 0377,
            arc->n->name);
        sym = symlook(buf, S_OUTOFDATE, 0);
        if(sym == 0 || eval){
            if(sym == 0)
                str = strdup(buf);
            ret = pcmp(arc->prog, node->name, arc->n->name);
            if(sym)
                sym->u.value = ret;
            else
                symlook(str, S_OUTOFDATE, (void *)ret);
        } else
            ret = sym->u.value;
        return (ret-1);
    } else if(strchr(arc->n->name, '(') && arc->n->time == 0)  /* missing archive member */
        return true;
    else
        /*
         * Treat equal times as out-of-date.
         * It's a race, and the safer option is to do
         * extra building rather than not enough.
         */
        return node->time <= arc->n->time;
}
@

<<function pcmp>>=
static int
pcmp(char *prog, char *p, char *q)
{
    char buf[3*NAMEBLOCK];
    int pid;

    Bflush(&bout);
    snprint(buf, sizeof buf, "%s '%s' '%s'\n", prog, p, q);
    pid = pipecmd(buf, 0, 0);
    while(waitup(-3, &pid) >= 0)
        ;
    return (pid? 2:1);
}
@



\chapter{Rules}

\section{Simple rule}

% kind of ctor
<<function addrule>>=
void
addrule(char *head, Word *tail, char *body, Word *ahead, int attr, int hline, char *prog)
{
    Rule *r;
    Rule *rr;
    Symtab *sym;
    bool reuse;

    r = 0;
    reuse = false;
    if(sym = symlook(head, S_TARGET, nil)){
        for(r = sym->u.ptr; r; r = r->chain)
            if(rcmp(r, head, tail) == 0){
                reuse = true;
                break;
            }
    }
    if(r == 0)
        r = (Rule *)Malloc(sizeof(Rule));
    r->target = head;
    r->tail = tail;
    r->recipe = body;
    r->line = hline;
    r->file = infile;
    r->attr = attr;
    r->alltargets = ahead;
    r->prog = prog;
    r->rule = nrules++;

    if(!reuse){
        rr = symlook(head, S_TARGET, r)->u.ptr;
        if(rr != r){
            r->chain = rr->chain;
            rr->chain = r;
        } else
            r->chain = 0;
    }
    if(!reuse)
        r->next = 0;
    if((attr&REGEXP) || charin(head, "%&")){
        r->attr |= META;
        if(reuse)
            return;
        if(attr&REGEXP){
            patrule = r;
            r->pat = regcomp(head);
        }
        if(metarules == 0)
            metarules = lmr = r;
        else {
            lmr->next = r;
            lmr = r;
        }
    } else {
        if(reuse)
            return;
        r->pat = 0;
        if(rules == 0)
            rules = lr = r;
        else {
            lr->next = r;
            lr = r;
        }
    }
}
@


<<function rcmp>>=
static int
rcmp(Rule *r, char *target, Word *tail)
{
    Word *w;

    if(strcmp(r->target, target))
        return 1;
    for(w = r->tail; w && tail; w = w->next, tail = tail->next)
        if(strcmp(w->s, tail->s))
            return 1;
    return (w || tail);
}
@




\section{Metarule}

% see matching later, or put matching here?

\section{Variables}


\section{Rule attributes}



\chapter{Parsing Rules}
% and Variables?
% could be done later?

<<global infile>>=
char *infile;
@

<<global mkinline>>=
int mkinline;
@


<<function SYNERR>>=
#define	SYNERR(l)	(fprint(STDERR, "mk: %s:%d: syntax error; ", infile, ((l)>=0)?(l):mkinline))
@


\section{Parsing a file}

<<enum sxxx cases>>=
S_NOEXPORT,	/* var -> noexport */ // set of noexport variables
@
<<enum sxxx cases>>=
S_OVERRIDE,	/* can't override */
@
<<enum sxxx cases>>=
S_WESET,	/* variable; we set in the mkfile */
@


<<function parse>>=
void
parse(char *f, fdt fd, bool varoverride)
{
    int hline;
    char *body;
    Word *head, *tail;
    int attr, pid;
    bool set;
    char *prog, *p;
    int newfd;
    Biobuf in;
    Bufblock *buf;

    if(fd < 0){
        perror(f);
        Exit();
    }
    ipush();
    infile = strdup(f);
    mkinline = 1;
    Binit(&in, fd, OREAD);
    buf = newbuf();
    while(assline(&in, buf)){
        hline = mkinline;
        switch(rhead(buf->start, &head, &tail, &attr, &prog))
        {
        case '<':
            p = wtos(tail, ' ');
            if(*p == 0){
                SYNERR(-1);
                fprint(STDERR, "missing include file name\n");
                Exit();
            }
            newfd = open(p, OREAD);
            if(newfd < 0){
                fprint(STDERR, "warning: skipping missing include file: ");
                perror(p);
            } else
                parse(p, newfd, 0);
            break;
        case '|':
            p = wtos(tail, ' ');
            if(*p == 0){
                SYNERR(-1);
                fprint(STDERR, "missing include program name\n");
                Exit();
            }
            execinit();
            pid=pipecmd(p, envy, &newfd);
            if(newfd < 0){
                fprint(STDERR, "warning: skipping missing program file: ");
                perror(p);
            } else
                parse(p, newfd, 0);
            while(waitup(-3, &pid) >= 0)
                ;
            if(pid != 0){
                fprint(STDERR, "bad include program status\n");
                Exit();
            }
            break;
        case ':':
            body = rbody(&in);
            addrules(head, tail, body, attr, hline, prog);
            break;
        case '=':
            if(head->next){
                SYNERR(-1);
                fprint(STDERR, "multiple vars on left side of assignment\n");
                Exit();
            }
            if(symlook(head->s, S_OVERRIDE, 0)){
                set = varoverride;
            } else {
                set = true;
                if(varoverride)
                    symlook(head->s, S_OVERRIDE, (void *)"");
            }
            if(set){
/*
char *cp;
dumpw("tail", tail);
cp = wtos(tail, ' '); print("assign %s to %s\n", head->s, cp); free(cp);
*/
                setvar(head->s, (void *) tail);
                symlook(head->s, S_WESET, (void *)"");
            }
            if(attr)
                symlook(head->s, S_NOEXPORT, (void *)"");
            break;
        default:
            SYNERR(hline);
            fprint(STDERR, "expected one of :<=\n");
            Exit();
            break;
        }
    }
    close(fd);
    freebuf(buf);
    ipop();
}
@

<<function addrules>>=
void
addrules(Word *head, Word *tail, char *body, int attr, int hline, char *prog)
{
    Word *w;

    assert(/*addrules args*/ head && body);
    /* tuck away first non-meta rule as default target*/
    if(target1 == nil && !(attr&REGEXP)){
        for(w = head; w; w = w->next)
            if(charin(w->s, "%&"))
                break;
        if(w == nil)
            target1 = wdup(head);
    }
    for(w = head; w; w = w->next)
        addrule(w->s, tail, body, head, attr, hline, prog);
}
@

<<function rhead>>=
static int
rhead(char *line, Word **h, Word **t, int *attr, char **prog)
{
    char *p;
    char *pp;
    int sep;
    Rune r;
    int n;
    Word *w;

    p = charin(line,":=<");
    if(p == 0)
        return '?';
    sep = *p;
    *p++ = 0;
    if(sep == '<' && *p == '|'){
        sep = '|';
        p++;
    }
    *attr = 0;
    *prog = 0;
    if(sep == '='){
        pp = charin(p, termchars);	/* termchars is shell-dependent */
        if (pp && *pp == '=') {
            while (p != pp) {
                n = chartorune(&r, p);
                switch(r)
                {
                default:
                    SYNERR(-1);
                    fprint(STDERR, "unknown attribute '%c'\n",*p);
                    Exit();
                case 'U':
                    *attr = 1;
                    break;
                }
                p += n;
            }
            p++;		/* skip trailing '=' */
        }
    }
    if((sep == ':') && *p && (*p != ' ') && (*p != '\t')){
        while (*p) {
            n = chartorune(&r, p);
            if (r == ':')
                break;
            p += n;
            switch(r)
            {
            default:
                SYNERR(-1);
                fprint(STDERR, "unknown attribute '%c'\n", p[-1]);
                Exit();
            case 'D':
                *attr |= DEL;
                break;
            case 'E':
                *attr |= NOMINUSE;
                break;
            case 'n':
                *attr |= NOVIRT;
                break;
            case 'N':
                *attr |= NOREC;
                break;
            case 'P':
                pp = utfrune(p, ':');
                if (pp == 0 || *pp == 0)
                    goto eos;
                *pp = 0;
                *prog = strdup(p);
                *pp = ':';
                p = pp;
                break;
            case 'Q':
                *attr |= QUIET;
                break;
            case 'R':
                *attr |= REGEXP;
                break;
            case 'U':
                *attr |= UPD;
                break;
            case 'V':
                *attr |= VIR;
                break;
            }
        }
        if (*p++ != ':') {
    eos:
            SYNERR(-1);
            fprint(STDERR, "missing trailing :\n");
            Exit();
        }
    }
    *h = w = stow(line);
    if(*w->s == 0 && sep != '<' && sep != '|') {
        SYNERR(mkinline-1);
        fprint(STDERR, "no var on left side of assignment/rule\n");
        Exit();
    }
    *t = stow(p);
    return sep;
}
@

<<function rbody>>=
static char *
rbody(Biobuf *in)
{
    Bufblock *buf;
    int r, lastr;
    char *p;

    lastr = '\n';
    buf = newbuf();
    for(;;){
        r = Bgetrune(in);
        if (r < 0)
            break;
        if (lastr == '\n') {
            if (r == '#')
                rinsert(buf, r);
            else if (r != ' ' && r != '\t') {
                Bungetrune(in);
                break;
            }
        } else
            rinsert(buf, r);
        lastr = r;
        if (r == '\n')
            mkinline++;
    }
    insert(buf, '\0');
    p = strdup(buf->start);
    freebuf(buf);
    return p;
}
@

\section{Parsing included files}

<<struct input>>=
struct Input
{
    char *file;
    int line;

    // Extra
    struct Input *next;
};
@

<<global inputs>>=
static struct Input *inputs = 0;
@

% can process many files, because of the </sys/src/... 

<<function ipush>>=
void
ipush(void)
{
    struct Input *in, *me;

    me = (struct Input *)Malloc(sizeof(*me));
    me->file = infile;
    me->line = mkinline;
    me->next = 0;
    if(inputs == 0)
        inputs = me;
    else {
        for(in = inputs; in->next; )
            in = in->next;
        in->next = me;
    }
}
@

<<function ipop>>=
void
ipop(void)
{
    struct Input *in, *me;

    assert(/*pop input list*/ inputs != 0);
    if(inputs->next == 0){
        me = inputs;
        inputs = 0;
    } else {
        for(in = inputs; in->next->next; )
            in = in->next;
        me = in->next;
        in->next = 0;
    }
    infile = me->file;
    mkinline = me->line;
    free((char *)me);
}
@

\section{Parsing a line}

% nice function name ...
<<function assline>>=
/*
 *	Assemble a line skipping blank lines, comments, and eliding
 *	escaped newlines
 */
int
assline(Biobuf *bp, Bufblock *buf)
{
    int c;
    int lastc;

    buf->current=buf->start;
    while ((c = nextrune(bp, 1)) >= 0){
        switch(c)
        {
        case '\r':		/* consumes CRs for Win95 */
            continue;
        case '\n':
            if (buf->current != buf->start) {
                insert(buf, '\0');
                return 1;
            }
            break;		/* skip empty lines */
        case '\\':
        case '\'':
        case '"':
            rinsert(buf, c);
            if (escapetoken(bp, buf, 1, c) == 0)
                Exit();
            break;
        case '`':
            if (bquote(bp, buf) == 0)
                Exit();
            break;
        case '#':
            lastc = '#';
            while ((c = Bgetc(bp)) != '\n') {
                if (c < 0)
                    goto eof;
                if(c != '\r')
                    lastc = c;
            }
            mkinline++;
            if (lastc == '\\')
                break;		/* propagate escaped newlines??*/
            if (buf->current != buf->start) {
                insert(buf, '\0');
                return 1;
            }
            break;
        default:
            rinsert(buf, c);
            break;
        }
    }
eof:
    insert(buf, '\0');
    return *buf->start != 0;
}
@

<<function bquote>>=
/*
 *	assemble a back-quoted shell command into a buffer
 */
static int
bquote(Biobuf *bp, Bufblock *buf)
{
    int c, line, term;
    int start;

    line = mkinline;
    while((c = Bgetrune(bp)) == ' ' || c == '\t')
            ;
    if(c == '{'){
        term = '}';		/* rc style */
        while((c = Bgetrune(bp)) == ' ' || c == '\t')
            ;
    } else
        term = '`';		/* sh style */

    start = buf->current-buf->start;
    for(;c > 0; c = nextrune(bp, 0)){
        if(c == term){
            insert(buf, '\n');
            insert(buf, '\0');
            buf->current = buf->start+start;
            execinit();
            execsh(0, buf->current, buf, envy);
            return 1;
        }
        if(c == '\n')
            break;
        if(c == '\'' || c == '"' || c == '\\'){
            insert(buf, c);
            if(!escapetoken(bp, buf, 1, c))
                return 0;
            continue;
        }
        rinsert(buf, c);
    }
    SYNERR(line);
    fprint(STDERR, "missing closing %c after `\n", term);
    return 0;
}
@

<<function nextrune>>=
/*
 *	get next character stripping escaped newlines
 *	the flag specifies whether escaped newlines are to be elided or
 *	replaced with a blank.
 */
int
nextrune(Biobuf *bp, int elide)
{
    int c;

    for (;;) {
        c = Bgetrune(bp);
        if (c == '\\') {
            if (Bgetrune(bp) == '\n') {
                mkinline++;
                if (elide)
                    continue;
                return ' ';
            }
            Bungetrune(bp);
        }
        if (c == '\n')
            mkinline++;
        return c;
    }
}
@

\section{Parsing a string}


% string to word
<<function stow>>=
Word *
stow(char *s)
{
    Word *head, *w, *new;

    w = head = nil;
    while(*s){
        new = nextword(&s);
        if(new == nil)
            break;
        if (w)
            w->next = new;
        else
            head = w = new;
        while(w->next)
            w = w->next;
        
    }
    if (!head)
        head = newword("");
    return head;
}
@


<<function nextword>>=
/*
 *	break out a word from a string handling quotes, executions,
 *	and variable expansions.
 */
static Word*
nextword(char **s)
{
    Bufblock *b;
    Word *head, *tail, *w;
    Rune r;
    char *cp;
    int empty;

    cp = *s;
    b = newbuf();
restart:
    head = tail = nil;
    while(*cp == ' ' || *cp == '\t')		/* leading white space */
        cp++;
    empty = 1;
    while(*cp){
        cp += chartorune(&r, cp);
        switch(r)
        {
        case ' ':
        case '\t':
        case '\n':
            goto out;
        case '\\':
        case '\'':
        case '"':
            empty = 0;
            cp = expandquote(cp, r, b);
            if(cp == 0){
                fprint(STDERR, "missing closing quote: %s\n", *s);
                Exit();
            }
            break;
        case '$': //$
            w = varsub(&cp);
            if(w == 0){
                if(empty)
                    goto restart;
                break;
            }
            empty = 0;
            if(b->current != b->start){
                bufcpy(b, w->s, strlen(w->s));
                insert(b, '\0');
                free(w->s);
                w->s = strdup(b->start);
                b->current = b->start;
            }
            if(head){
                bufcpy(b, tail->s, strlen(tail->s));
                bufcpy(b, w->s, strlen(w->s));
                insert(b, '\0');
                free(tail->s);
                tail->s = strdup(b->start);
                tail->next = w->next;
                free(w->s);
                free(w);
                b->current = b->start;
            } else
                tail = head = w;
            while(tail->next)
                tail = tail->next;
            break;
        default:
            empty = 0;
            rinsert(b, r);
            break;
        }
    }
out:
    *s = cp;
    if(b->current != b->start){
        if(head){
            cp = b->current;
            bufcpy(b, tail->s, strlen(tail->s));
            bufcpy(b, b->start, cp-b->start);
            insert(b, '\0');
            free(tail->s);
            tail->s = strdup(cp);
        } else {
            insert(b, '\0');
            head = newword(b->start);
        }
    }
    freebuf(b);
    return head;
}
@
%$



\chapter{Building the Dependency Graph}

% for GC? to identify unused rules?
<<[[Rule]] other fields>>=
int 		rule;		/* rule number */
@

% incremented by addrule()
<<global nrules>>=
static int nrules = 0;
@


% constructor?
<<function graph>>=
Node*
graph(char *target)
{
    Node *node;
    char *cnt;

    cnt = rulecnt();
    node = applyrules(target, cnt);
    free(cnt);
    cyclechk(node);
    node->flags |= PROBABLE;	/* make sure it doesn't get deleted */
    vacuous(node);
    ambiguous(node);
    attribute(node);

    return node;
}
@

% ???
<<function rulecnt>>=
char *
rulecnt(void)
{
    char *s;

    s = Malloc(nrules);
    memset(s, 0, nrules);
    return s;
}
@


<<function attribute>>=
static void
attribute(Node *n)
{
    register Arc *a;

    for(a = n->prereqs; a; a = a->next){
        if(a->r->attr&VIR)
            n->flags |= VIRTUAL;
        if(a->r->attr&NOREC)
            n->flags |= NORECIPE;
        if(a->r->attr&DEL)
            n->flags |= DELETE;
        if(a->n)
            attribute(a->n);
    }
    if(n->flags&VIRTUAL)
        n->time = 0;
}
@

\section{Finding the rules for a target}

<<function applyrules>>=
static Node *
applyrules(char *target, char *cnt)
{
    Symtab *sym;
    Node *node;
    Rule *r;
    Arc head, *a = &head;
    Word *w;
    char stem[NAMEBLOCK], buf[NAMEBLOCK];
    Resub rmatch[NREGEXP];

/*	print("applyrules(%lux='%s')\n", target, target);/**/
    sym = symlook(target, S_NODE, 0);
    if(sym)
        return sym->u.ptr;
    target = strdup(target);
    node = newnode(target);
    head.n = 0;
    head.next = 0;
    sym = symlook(target, S_TARGET, 0);
    memset((char*)rmatch, 0, sizeof(rmatch));

    for(r = sym? sym->u.ptr:0; r; r = r->chain){
        if(r->attr&META) continue;
        if(strcmp(target, r->target)) continue;
        if((!r->recipe || !*r->recipe) && (!r->tail || !r->tail->s || !*r->tail->s)) continue;	/* no effect; ignore */
        if(cnt[r->rule] >= nreps) continue;
        cnt[r->rule]++;
        node->flags |= PROBABLE;

/*		if(r->attr&VIR)
 *			node->flags |= VIRTUAL;
 *		if(r->attr&NOREC)
 *			node->flags |= NORECIPE;
 *		if(r->attr&DEL)
 *			node->flags |= DELETE;
 */
        if(!r->tail || !r->tail->s || !*r->tail->s) {
            a->next = newarc((Node *)0, r, "", rmatch);
            a = a->next;
        } else
            for(w = r->tail; w; w = w->next){
                a->next = newarc(applyrules(w->s, cnt), r, "", rmatch);
                a = a->next;
        }
        cnt[r->rule]--;
        head.n = node;
    }
    for(r = metarules; r; r = r->next){
        if((!r->recipe || !*r->recipe) && (!r->tail || !r->tail->s || !*r->tail->s)) continue;	/* no effect; ignore */
        if ((r->attr&NOVIRT) && a != &head && (a->r->attr&VIR))
            continue;
        if(r->attr&REGEXP){
            stem[0] = 0;
            patrule = r;
            memset((char*)rmatch, 0, sizeof(rmatch));
            if(regexec(r->pat, node->name, rmatch, NREGEXP) == 0)
                continue;
        } else {
            if(!match(node->name, r->target, stem)) continue;
        }
        if(cnt[r->rule] >= nreps) continue;
        cnt[r->rule]++;

/*		if(r->attr&VIR)
 *			node->flags |= VIRTUAL;
 *		if(r->attr&NOREC)
 *			node->flags |= NORECIPE;
 *		if(r->attr&DEL)
 *			node->flags |= DELETE;
 */
        if(!r->tail || !r->tail->s || !*r->tail->s) {
            a->next = newarc((Node *)0, r, stem, rmatch);
            a = a->next;
        } else
            for(w = r->tail; w; w = w->next){
                if(r->attr&REGEXP)
                    regsub(w->s, buf, sizeof(buf), rmatch, NREGEXP);
                else
                    subst(stem, w->s, buf, sizeof(buf));
                a->next = newarc(applyrules(buf, cnt), r, stem, rmatch);
                a = a->next;
            }
        cnt[r->rule]--;
    }
    a->next = node->prereqs;
    node->prereqs = head.next;
    return node;
}
@

<<function togo>>=
static void
togo(Node *node)
{
    Arc *la, *a;

    /* delete them now */
    la = 0;
    for(a = node->prereqs; a; la = a, a = a->next)
        if(a->flag&TOGO){
            if(a == node->prereqs)
                node->prereqs = a->next;
            else
                la->next = a->next, a = la;
        }
}
@

<<function vacuous>>=
static int
vacuous(Node *node)
{
    Arc *la, *a;
    int vac = !(node->flags&PROBABLE);

    if(node->flags&READY)
        return node->flags&VACUOUS;
    node->flags |= READY;
    for(a = node->prereqs; a; a = a->next)
        if(a->n && vacuous(a->n) && (a->r->attr&META))
            a->flag |= TOGO;
        else
            vac = 0;
    /* if a rule generated arcs that DON'T go; no others from that rule go */
    for(a = node->prereqs; a; a = a->next)
        if((a->flag&TOGO) == 0)
            for(la = node->prereqs; la; la = la->next)
                if((la->flag&TOGO) && (la->r == a->r)){
                    la->flag &= ~TOGO;
                }
    togo(node);
    if(vac)
        node->flags |= VACUOUS;
    return vac;
}
@


\section{Finding metarules and substituting stem}

<<function match>>=
bool
match(char *name, char *template, char *stem)
{
    Rune r;
    int n;

    while(*name && *template){
        n = chartorune(&r, template);
        if (PERCENT(r))
            break;
        while (n--)
            if(*name++ != *template++)
                return false;
    }
    if(!PERCENT(*template))
        return false;
    n = strlen(name)-strlen(template+1);
    if (n < 0)
        return false;
    if (strcmp(template+1, name+n))
        return false;

    strncpy(stem, name, n);
    stem[n] = '\0';
    if(*template == '&')
        return !charin(stem, "./");
    return true;
}
@

<<function subst>>=
void
subst(char *stem, char *template, char *dest, int dlen)
{
    Rune r;
    char *s, *e;
    int n;

    e = dest+dlen-1;
    while(*template){
        n = chartorune(&r, template);
        if (PERCENT(r)) {
            template += n;
            for (s = stem; *s; s++)
                if(dest < e)
                    *dest++ = *s;
        } else
            while (n--){
                if(dest < e)
                    *dest++ = *template;
                template++;
            }
    }
    *dest = 0;
}
@



\section{Cycle detection}

<<function cyclechk>>=
static void
cyclechk(Node *n)
{
    Arc *a;

    if((n->flags&CYCLE) && n->prereqs){
        fprint(STDERR, "mk: cycle in graph detected at target %s\n", n->name);
        Exit();
    }
    n->flags |= CYCLE;
    for(a = n->prereqs; a; a = a->next)
        if(a->n)
            cyclechk(a->n);
    n->flags &= ~CYCLE;
}
@

\section{Ambiguous rule detection}

<<function ambiguous>>=
static void
ambiguous(Node *n)
{
    Arc *a;
    Rule *r = nil;
    Arc *la = nil;
    bool bad = false;

    for(a = n->prereqs; a; a = a->next){
        if(a->n)
            ambiguous(a->n);
        if(*a->r->recipe == 0) continue;
        if(r == nil)
            r = a->r, la = a;
        else{
            if(r->recipe != a->r->recipe){
                if((r->attr&META) && !(a->r->attr&META)){
                    la->flag |= TOGO;
                    r = a->r, la = a;
                } else if(!(r->attr&META) && (a->r->attr&META)){
                    a->flag |= TOGO;
                    continue;
                }
            }
            if(r->recipe != a->r->recipe){
                if(bad == 0){
                    fprint(STDERR, "mk: ambiguous recipes for %s:\n", n->name);
                    bad = true;
                    trace(n->name, la);
                }
                trace(n->name, a);
            }
        }
    }
    if(bad)
        Exit();
    togo(n);
}
@

<<function trace>>=
static void
trace(char *s, Arc *a)
{
    fprint(STDERR, "\t%s", s);
    while(a){
        fprint(STDERR, " <-(%s:%d)- %s", a->r->file, a->r->line,
            a->n? a->n->name:"");
        if(a->n){
            for(a = a->n->prereqs; a; a = a->next)
                if(*a->r->recipe) break;
        } else
            a = 0;
    }
    fprint(STDERR, "\n");
}
@

\section{Infinite rule detection}

% n reps, to manage bad rules like %: %.c that can be executed multiple times
<<global nreps>>=
int nreps = 1;
@

% mk -> nrep
<<function nrep>>=
void
nrep(void)
{
    Symtab *sym;
    Word *w;

    sym = symlook("NREP", S_VAR, nil);
    if(sym){
        w = sym->u.ptr;
        if (w && w->s && *w->s)
            nreps = atoi(w->s);
    }
    if(nreps < 1)
        nreps = 1;
    <<[[nrep()]] if DEBUG(D_GRAPH)>>
}
@

\chapter{Time}

<<enum sxxx cases>>=
S_TIME,		/* file -> time */
@

<<function timeinit>>=
void
timeinit(char *s)
{
    ulong t;
    char *cp;
    Rune r;
    int c, n;

    t = time(0);
    while (*s) {
        cp = s;
        do{
            n = chartorune(&r, s);
            if (r == ' ' || r == ',' || r == '\n')
                break;
            s += n;
        } while(*s);
        c = *s;
        *s = 0;
        symlook(strdup(cp), S_TIME, (void *)t)->u.value = t;
        if (c)
            *s++ = c;
        while(*s){
            n = chartorune(&r, s);
            if(r != ' ' && r != ',' && r != '\n')
                break;
            s += n;
        }
    }
}
@


% timeof -> mtime -> mkmktime -> bulktime
%                             -> dirstat

<<function timeof>>=
ulong
timeof(char *name, bool force)
{
    Symtab *sym;
    ulong t;

    if(utfrune(name, '('))
        return atimeof(force, name);		/* archive */

    if(force)
        return mtime(name);

    sym = symlook(name, S_TIME, nil);
    if (sym)
        return sym->u.value;		/* uggh */

    t = mkmtime(name, false);
    if(t == 0)
        return 0;

    symlook(name, S_TIME, (void*)t);		/* install time in cache */
    return t;
}
@


<<function mtime>>=
ulong
mtime(char *name)
{
    return mkmtime(name, true);
}
@





<<function mkmtime>>=
ulong
mkmtime(char *name, bool force)
{
    Dir *d;
    char *s, *ss, carry;
    ulong t;
    Symtab *sym;
    char buf[4096];

    strecpy(buf, buf + sizeof buf - 1, name);
    cleanname(buf);
    name = buf;

    s = utfrrune(name, '/');
    if(s == name)
        s++;
    if(s){
        ss = name;
        carry = *s;
        *s = '\0';
    }else{
        ss = nil;
        carry = 0;
    }
    bulkmtime(ss);
    if(carry)
        *s = carry;

    if(!force){
        sym = symlook(name, S_TIME, 0);
        if(sym)
            return sym->u.value;
        return 0;
    }
    if((d = dirstat(name)) == nil)
        return 0;

    t = d->mtime;
    free(d);

    return t;
}
@


<<enum sxxx cases>>=
S_BULKED,	/* we have bulked this dir */
@

<<function bulkmtime>>=
void
bulkmtime(char *dir)
{
    char buf[4096];
    char *ss, *s, *sym;

    if(dir){
        sym = dir;
        s = dir;
        if(strcmp(dir, "/") == 0)
            strecpy(buf, buf + sizeof buf - 1, dir);
        else
            snprint(buf, sizeof buf, "%s/", dir);
    }else{
        s = ".";
        sym = "";
        buf[0] = 0;
    }
    if(symlook(sym, S_BULKED, 0))
        return;
    ss = strdup(sym);
    symlook(ss, S_BULKED, (void*)ss);
    dirtime(s, buf);
}
@






<<function touch>>=
void
touch(char *name)
{
    Bprint(&bout, "touch(%s)\n", name);
    if(nflag)
        return;

    if(utfrune(name, '('))
        atouch(name);		/* archive */
    else
     if(chgtime(name) < 0) {
        perror(name);
        Exit();
    }
}
@

<<function chgtime>>=
int
chgtime(char *name)
{
    Dir sbuf;

    if(access(name, AEXIST) >= 0) {
        nulldir(&sbuf);
        sbuf.mtime = time((long *)0);
        return dirwstat(name, &sbuf);
    }
    return close(create(name, OWRITE, 0666));
}
@



<<function delete>>=
void
delete(char *name)
{
    if(utfrune(name, '(') == 0) {		/* file */
        if(remove(name) < 0)
            perror(name);
    } else
        fprint(STDERR, "hoon off; mk can'tdelete archive members\n");
}
@



\chapter{Shell interaction}
% the recipe

<<global shell>>=
char 	*shell =	"/bin/rc";
@

<<global shellname>>=
char 	*shellname =	"rc";
@



<<global termchars>>=
char	*termchars = "'= \t";	/*used in parse.c to isolate assignment attribute*/
@

<<global shflags>>=
char	*shflags = "-I";	/* rc flag to force non-interactive mode */
@

<<global IWS>>=
int	IWS = '\1';		/* inter-word separator in env - not used in plan 9 */
@


\section{The environment}
% as opposed to make, no $(XX), no $$i, the string is passed
% as is to shell! less escaping need!


<<function envupd>>=
static void
envupd(char *name, Word *value)
{
    Envy *e;

    for(e = envy; e->name; e++)
        if(strcmp(name, e->name) == 0){
            delword(e->values);
            e->values = value;
            return;
        }
    e->name = name;
    e->values = value;
    envinsert(nil,nil); // ???
}
@

<<function ecopy>>=
static void
ecopy(Symtab *s)
{
    char **p;

    if(symlook(s->name, S_NOEXPORT, 0))
        return;
    for(p = myenv; *p; p++)
        if(strcmp(*p, s->name) == 0)
            return;
    envinsert(s->name, s->u.ptr);
}
@

% main -> execinit()
<<function execinit>>=
void
execinit(void)
{
    char **p;

    nextv = 0; // reset envy
    for(p = myenv; *p; p++)
        envinsert(*p, stow(""));

    symtraverse(S_VAR, ecopy);
    envinsert(nil, nil);
}
@

<<function buildenv>>=
Envy*
buildenv(Job *j, int slot)
{
    char **p, *cp, *qp;
    Word *w, *v, **l;
    int i;
    char buf[256];

    envupd("target", wdup(j->t));
    if(j->r->attr&REGEXP)
        envupd("stem",newword(""));
    else
        envupd("stem", newword(j->stem));
    envupd("prereq", wdup(j->p));
    snprint(buf, sizeof buf, "%d", getpid());
    envupd("pid", newword(buf));
    snprint(buf, sizeof buf, "%d", slot);
    envupd("nproc", newword(buf));
    envupd("newprereq", wdup(j->np));
    envupd("alltarget", wdup(j->at));
    l = &v;
    v = w = wdup(j->np);
    while(w){
        cp = strchr(w->s, '(');
        if(cp){
            qp = strchr(cp+1, ')');
            if(qp){
                *qp = 0;
                strcpy(w->s, cp+1);
                l = &w->next;
                w = w->next;
                continue;
            }
        }
        *l = w->next;
        free(w->s);
        free(w);
        w = *l;
    }
    envupd("newmember", v);
        /* update stem0 -> stem9 */
    for(p = myenv; *p; p++)
        if(strcmp(*p, "stem0") == 0)
            break;
    for(i = 0; *p; i++, p++){
        if((j->r->attr&REGEXP) && j->match[i])
            envupd(*p, newword(j->match[i]));
        else 
            envupd(*p, newword(""));
    }
    return envy;
}
@


\section{Variables expansion}

<<function varsub>>=
Word*
varsub(char **s)
{
    Bufblock *b;
    Word *w;

    if(**s == '{')		/* either ${name} or ${name: A%B==C%D}*/
        return expandvar(s);

    b = varname(s);
    if(b == nil)
        return nil;

    w = varmatch(b->start);
    freebuf(b);
    return w;
}
@

<<function varname>>=
/*
 *	extract a variable name
 */
static Bufblock*
varname(char **s)
{
    Bufblock *b;
    char *cp;
    Rune r;
    int n;

    b = newbuf();
    cp = *s;
    for(;;){
        n = chartorune(&r, cp);
        if (!WORDCHR(r))
            break;
        rinsert(b, r);
        cp += n;
    }
    if (b->current == b->start){
        SYNERR(-1);
        fprint(STDERR, "missing variable name <%s>\n", *s);
        freebuf(b);
        return nil;
    }
    *s = cp;
    insert(b, '\0');
    return b;
}
@

<<function WORDCHR>>=
#define WORDCHR(r)	((r) > ' ' && !utfrune("!\"#$%&'()*+,-./:;<=>?@[\\]^`{|}~", (r)))
@
%$

<<function varmatch>>=
static Word*
varmatch(char *name)
{
    Word *w;
    Symtab *sym;
    
    sym = symlook(name, S_VAR, nil);
    if(sym){
            /* check for at least one non-NULL value */
        for (w = sym->u.ptr; w; w = w->next)
            if(w->s && *w->s)
                return wdup(w);
    }
    return nil;
}
@

<<function expandvar>>=
static Word*
expandvar(char **s)
{
    Word *w;
    Bufblock *buf;
    Symtab *sym;
    char *cp, *begin, *end;

    begin = *s;
    (*s)++;						/* skip the '{' */
    buf = varname(s);
    if (buf == nil)
        return nil;
    cp = *s;
    if (*cp == '}') {				/* ${name} variant*/ //$
        (*s)++;					/* skip the '}' */
        w = varmatch(buf->start);
        freebuf(buf);
        return w;
    }
    if (*cp != ':') {
        SYNERR(-1);
        fprint(STDERR, "bad variable name <%s>\n", buf->start);
        freebuf(buf);
        return nil;
    }
    cp++;
    end = charin(cp , "}");
    if(end == nil){
        SYNERR(-1);
        fprint(STDERR, "missing '}': %s\n", begin);
        Exit();
    }
    *end = '\0';
    *s = end+1;
    
    sym = symlook(buf->start, S_VAR, 0);
    if(sym == nil || sym->u.value == 0)
        w = newword(buf->start);
    else
        w = subsub(sym->u.ptr, cp, end);
    freebuf(buf);
    return w;
}
@
%$

<<function extractpat>>=
static Word*
extractpat(char *s, char **r, char *term, char *end)
{
    int save;
    char *cp;
    Word *w;

    cp = charin(s, term);
    if(cp){
        *r = cp;
        if(cp == s)
            return nil;
        save = *cp;
        *cp = '\0';
        w = stow(s);
        *cp = save;
    } else {
        *r = end;
        w = stow(s);
    }
    return w;
}
@

<<function subsub>>=
static Word*
subsub(Word *v, char *s, char *end)
{
    int nmid;
    Word *head, *tail, *w, *h;
    Word *a, *b, *c, *d;
    Bufblock *buf;
    char *cp, *enda;

    a = extractpat(s, &cp, "=%&", end);
    b = c = d = nil;
    if(PERCENT(*cp))
        b = extractpat(cp+1, &cp, "=", end);
    if(*cp == '=')
        c = extractpat(cp+1, &cp, "&%", end);
    if(PERCENT(*cp))
        d = stow(cp+1);
    else if(*cp)
        d = stow(cp);

    head = tail = nil;
    buf = newbuf();
    for(; v; v = v->next){
        h = w = 0;
        if(submatch(v->s, a, b, &nmid, &enda)){
            /* enda points to end of A match in source;
             * nmid = number of chars between end of A and start of B
             */
            if(c){
                h = w = wdup(c);
                while(w->next)
                    w = w->next;
            }
            if(PERCENT(*cp) && nmid > 0){	
                if(w){
                    bufcpy(buf, w->s, strlen(w->s));
                    bufcpy(buf, enda, nmid);
                    insert(buf, '\0');
                    free(w->s);
                    w->s = strdup(buf->start);
                } else {
                    bufcpy(buf, enda, nmid);
                    insert(buf, '\0');
                    h = w = newword(buf->start);
                }
                buf->current = buf->start;
            }
            if(d && *d->s){
                if(w){

                    bufcpy(buf, w->s, strlen(w->s));
                    bufcpy(buf, d->s, strlen(d->s));
                    insert(buf, '\0');
                    free(w->s);
                    w->s = strdup(buf->start);
                    w->next = wdup(d->next);
                    while(w->next)
                        w = w->next;
                    buf->current = buf->start;
                } else
                    h = w = wdup(d);
            }
        }
        if(w == 0)
            h = w = newword(v->s);
    
        if(head == 0)
            head = h;
        else
            tail->next = h;
        tail = w;
    }
    freebuf(buf);
    delword(a);
    delword(b);
    delword(c);
    delword(d);
    return head;
}
@

<<function submatch>>=
static bool
submatch(char *s, Word *a, Word *b, int *nmid, char **enda)
{
    Word *w;
    int n;
    char *end;

    n = 0;
    for(w = a; w; w = w->next){
        n = strlen(w->s);
        if(strncmp(s, w->s, n) == 0)
            break;
    }
    if(a && w == nil)		/*  a == NULL matches everything*/
        return false;

    *enda = s+n;		/* pointer to end a A part match */
    *nmid = strlen(s)-n;	/* size of remainder of source */
    end = *enda+*nmid;
    for(w = b; w; w = w->next){
        n = strlen(w->s);
        if(strcmp(w->s, end-n) == 0){
            *nmid -= n;
            break;
        }
    }
    if(b && w == nil)		/* b == NULL matches everything */
        return false;
    return true;
}
@


\section{Quotation}
% aka escaping


<<function squote>>=
/*
 *	skip a token in single quotes.
 */
static char *
squote(char *cp)
{
    Rune r;
    int n;

    while(*cp){
        n = chartorune(&r, cp);
        if(r == '\'') {
            n += chartorune(&r, cp+n);
            if(r != '\'')
                return cp;
        }
        cp += n;
    }
    SYNERR(-1);		/* should never occur */
    fprint(STDERR, "missing closing '\n");
    return 0;
}
@

<<function charin>>=
/*
 *	search a string for characters in a pattern set
 *	characters in quotes and variable generators are escaped
 */
char*
charin(char *cp, char *pat)
{
    Rune r;
    int n, vargen;

    vargen = 0;
    while(*cp){
        n = chartorune(&r, cp);
        switch(r){
        case '\'':			/* skip quoted string */
            cp = squote(cp+1);	/* n must = 1 */
            if(!cp)
                return 0;
            break;
        case '$':
            if(*(cp+1) == '{')
                vargen = 1;
            break;
        case '}':
            if(vargen)
                vargen = 0;
            else if(utfrune(pat, r))
                return cp;
            break;
        default:
            if(vargen == 0 && utfrune(pat, r))
                return cp;
            break;
        }
        cp += n;
    }
    if(vargen){
        SYNERR(-1);
        fprint(STDERR, "missing closing } in pattern generator\n");
    }
    return 0;
}
@
%$ 

<<function expandquote>>=
/*
 *	extract an escaped token.  Possible escape chars are single-quote,
 *	double-quote,and backslash.  Only the first is valid for rc. the
 *	others are just inserted into the receiving buffer.
 */
char*
expandquote(char *s, Rune r, Bufblock *b)
{
    if (r != '\'') {
        rinsert(b, r);
        return s;
    }

    while(*s){
        s += chartorune(&r, s);
        if(r == '\'') {
            if(*s == '\'')
                s++;
            else
                return s;
        }
        rinsert(b, r);
    }
    return 0;
}
@

<<function escapetoken>>=
/*
 *	Input an escaped token.  Possible escape chars are single-quote,
 *	double-quote and backslash.  Only the first is a valid escape for
 *	rc; the others are just inserted into the receiving buffer.
 */
int
escapetoken(Biobuf *bp, Bufblock *buf, int preserve, int esc)
{
    int c, line;

    if(esc != '\'')
        return 1;

    line = mkinline;
    while((c = nextrune(bp, 0)) > 0){
        if(c == '\''){
            if(preserve)
                rinsert(buf, c);
            c = Bgetrune(bp);
            if (c < 0)
                break;
            if(c != '\''){
                Bungetrune(bp);
                return 1;
            }
        }
        rinsert(buf, c);
    }
    SYNERR(line); fprint(STDERR, "missing closing %c\n", esc);
    return 0;
}
@

<<function copysingle>>=
/*
 *	copy a single-quoted string; s points to char after opening quote
 */
static char *
copysingle(char *s, Bufblock *buf)
{
    Rune r;

    while(*s){
        s += chartorune(&r, s);
        rinsert(buf, r);
        if(r == '\'')
            break;
    }
    return s;
}
@

<<function copyq>>=
/*
 *	check for quoted strings.  backquotes are handled here; single quotes above.
 *	s points to char after opening quote, q.
 */
char *
copyq(char *s, Rune q, Bufblock *buf)
{
    if(q == '\'')				/* copy quoted string */
        return copysingle(s, buf);

    if(q != '`')				/* not quoted */
        return s;

    while(*s){				/* copy backquoted string */
        s += chartorune(&q, s);
        rinsert(buf, q);
        if(q == '}')
            break;
        if(q == '\'')
            s = copysingle(s, buf);	/* copy quoted string */
    }
    return s;
}
@


\section{The recipe}

% main -> mk -> work -> ... -> run(newjob())
<<function dorecipe>>=
bool
dorecipe(Node *node)
{
    bool did = false;
    char buf[BIGBLOCK], cwd[256];
    Arc *a, *aa;
    Node *n;
    Rule *r = nil;
    Symtab *s;
    Word head, ahead, lp, ln, *w, *ww, *aw;

    aa = nil;
    /*
     *   pick up the rule
     */
    for(a = node->prereqs; a; a = a->next)
        if(*a->r->recipe) {
            aa = a;
            r = aa->r;
        }
    /*
     *   no recipe? go to buggery!
     */
    if(r == nil){
        if(!(node->flags&VIRTUAL) && !(node->flags&NORECIPE)){
            if(getwd(cwd, sizeof cwd))
                fprint(STDERR, "mk: no recipe to make '%s' in directory %s\n", node->name, cwd);
            else
                fprint(STDERR, "mk: no recipe to make '%s'\n", node->name);
            Exit();
        }
        if(strchr(node->name, '(') && node->time == 0)
            MADESET(node, MADE);
        else
            update(0, node);
        if(tflag){
            if(!(node->flags&VIRTUAL))
                touch(node->name);
            else if(explain)
                Bprint(&bout, "no touch of virtual '%s'\n", node->name);
        }
        return did;
    }

    /*
     *   build the node list
     */
    node->next = 0;
    head.next = 0;
    ww = &head;
    ahead.next = 0;
    aw = &ahead;
    if(r->attr&REGEXP){
        ww->next = newword(node->name);
        aw->next = newword(node->name);
    } else {
        for(w = r->alltargets; w; w = w->next){
            if(r->attr&META)
                subst(aa->stem, w->s, buf, sizeof(buf));
            else
                strecpy(buf, buf + sizeof buf - 1, w->s);
            aw->next = newword(buf);
            aw = aw->next;
            if((s = symlook(buf, S_NODE, 0)) == 0)
                continue;	/* not a node we are interested in */
            n = s->u.ptr;
            if(aflag == false && n->time) {
                for(a = n->prereqs; a; a = a->next)
                    if(a->n && outofdate(n, a, 0))
                        break;
                if(a == 0)
                    continue;
            }
            ww->next = newword(buf);
            ww = ww->next;
            if(n == node) continue;
            n->next = node->next;
            node->next = n;
        }
    }
    for(n = node; n; n = n->next)
        if((n->flags&READY) == 0)
            return did;
    /*
        gather the params for the job
    */
    lp.next = ln.next = 0;
    for(n = node; n; n = n->next){
        for(a = n->prereqs; a; a = a->next){
            if(a->n){
                addw(&lp, a->n->name);
                if(outofdate(n, a, 0)){
                    addw(&ln, a->n->name);
                    if(explain)
                        fprint(1, "%s(%ld) < %s(%ld)\n",
                            n->name, n->time, a->n->name, a->n->time);
                }
            } else {
                if(explain)
                    fprint(1, "%s has no prerequisites\n",
                            n->name);
            }
        }
        MADESET(n, BEINGMADE);
    }
/*print("lt=%s ln=%s lp=%s\n",wtos(head.next, ' '),wtos(ln.next, ' '),wtos(lp.next, ' '));/**/
    run(newjob(r, node, aa->stem, aa->match, lp.next, ln.next, head.next, ahead.next));
    return true;
}
@


<<function update>>=
void
update(int fake, Node *node)
{
    Arc *a;

    MADESET(node, fake? BEINGMADE : MADE);
    if(((node->flags&VIRTUAL) == 0) && (access(node->name, 0) == 0)){
        node->time = timeof(node->name, true);
        node->flags &= ~(CANPRETEND|PRETENDING);
        for(a = node->prereqs; a; a = a->next)
            if(a->prog)
                outofdate(node, a, 1);
    } else {
        node->time = 1;
        for(a = node->prereqs; a; a = a->next)
            if(a->n && outofdate(node, a, 1))
                node->time = a->n->time;
    }
/*	print("----node %s time=%lud flags=0x%x\n", node->name, node->time, node->flags);/**/
}
@


<<function addw>>=
void
addw(Word *w, char *s)
{
    Word *lw;

    for(lw = w; w = w->next; lw = w){
        if(strcmp(s, w->s) == 0)
            return;
    }
    lw->next = newword(s);
}
@



\chapter{Jobs}
% can do stuff in //! make originally didn't apparently


<<struct RunEvent>>=
struct RunEvent {
    int pid;
    Job *job;
};
@

% should be array[nproclimit]
<<global events>>=
static RunEvent *events;
@

% should be equal to nproclimit
<<global nevents>>=
static int nevents;
@

<<struct Process>>=
struct Process {
    int pid;
    int status;

    Process *b, *f;
};
@

<<global phead>>=
// list<ref_own<Process>??
static Process *phead;
@

<<global pfree>>=
static Process *pfree;
@




<<global nrunning>>=
static int nrunning;
@


<<function run>>=
void
run(Job *j)
{
    Job *jj;

    if(jobs){
        for(jj = jobs; jj->next; jj = jj->next)
            ;
        jj->next = j;
    } else 
        jobs = j;
    j->next = nil;
    /* this code also in waitup after parse redirect */
    if(nrunning < nproclimit)
        sched();
}
@

\section{Scheduling}

<<function sched>>=
static void
sched(void)
{
    char *flags;
    Job *j;
    Bufblock *buf;
    int slot;
    Node *n;
    Envy *e;

    if(jobs == nil){
        usage();
        return;
    }
    j = jobs;
    jobs = j->next;
    <<[[sched()]] if DEBUG(D_EXEC)>>
    slot = nextslot();
    events[slot].job = j;
    buf = newbuf();
    e = buildenv(j, slot);
    shprint(j->r->recipe, e, buf);
    if(!tflag && (nflag || !(j->r->attr&QUIET)))
        Bwrite(&bout, buf->start, (long)strlen(buf->start));
    freebuf(buf);
    if(nflag||tflag){
        for(n = j->n; n; n = n->next){
            if(tflag){
                if(!(n->flags&VIRTUAL))
                    touch(n->name);
                else if(explain)
                    Bprint(&bout, "no touch of virtual '%s'\n", n->name);
            }
            n->time = time((long *)0);
            MADESET(n, MADE);
        }
    } else {
       <<[[sched()]] if DEBUG(D_EXEC) print recipe>>
        if(j->r->attr&NOMINUSE)
            flags = 0;
        else
            flags = "-e";
        events[slot].pid = execsh(flags, j->r->recipe, 0, e);
        usage();
        nrunning++;
       <<[[sched()]] if DEBUG(D_EXEC) print pid>>
    }
}
@


<<function waitup>>=
int
waitup(int echildok, int *retstatus)
{
    Envy *e;
    int pid;
    int slot;
    Symtab *s;
    Word *w;
    Job *j;
    char buf[ERRMAX];
    Bufblock *bp;
    int uarg = 0;
    int done;
    Node *n;
    Process *p;
    extern int runerrs;

    /* first check against the proces slist */
    if(retstatus)
        for(p = phead; p; p = p->f)
            if(p->pid == *retstatus){
                *retstatus = p->status;
                pdelete(p);
                return -1;
            }
again:		/* rogue processes */
    pid = waitfor(buf);
    if(pid == -1){
        if(echildok > 0)
            return 1;
        else {
            fprint(STDERR, "mk: (waitup %d) ", echildok);
            perror("mk wait");
            Exit();
        }
    }
    <<[[waitup()]] if DEBUG(D_EXEC) print pid>>
    if(retstatus && pid == *retstatus){
        *retstatus = buf[0]? 1:0;
        return -1;
    }
    slot = pidslot(pid);
    if(slot < 0){
       <<[[waitup()]] if DEBUG(D_EXEC) and slot < 0>>
        pnew(pid, buf[0]? 1:0);
        goto again;
    }
    j = events[slot].job;
    usage();
    nrunning--;
    events[slot].pid = -1;
    if(buf[0]){
        e = buildenv(j, slot);
        bp = newbuf();
        shprint(j->r->recipe, e, bp);
        front(bp->start);
        fprint(STDERR, "mk: %s: exit status=%s", bp->start, buf);
        freebuf(bp);
        for(n = j->n, done = 0; n; n = n->next)
            if(n->flags&DELETE){
                if(done++ == 0)
                    fprint(STDERR, ", deleting");
                fprint(STDERR, " '%s'", n->name);
                delete(n->name);
            }
        fprint(STDERR, "\n");
        if(kflag){
            runerrs++;
            uarg = 1;
        } else {
            jobs = 0;
            Exit();
        }
    }
    for(w = j->t; w; w = w->next){
        if((s = symlook(w->s, S_NODE, 0)) == 0)
            continue;	/* not interested in this node */
        update(uarg, s->u.ptr);
    }
    if(nrunning < nproclimit)
        sched();
    return 0;
}
@

\section{Parallel processing}
% export NPROC=...

<<global nproclimit>>=
static int nproclimit;
@

<<function nproc>>=
void
nproc(void)
{
    Symtab *sym;
    Word *w;

    if(sym = symlook("NPROC", S_VAR, nil)) {
        w = sym->u.ptr;
        if (w && w->s && w->s[0])
            nproclimit = atoi(w->s);
    }
    if(nproclimit < 1)
        nproclimit = 1;
    <<[[nproc()]] if DEBUG(D_EXEC)>>
    if(nproclimit > nevents){
        if(nevents)
            events = (RunEvent *)Realloc((char *)events, nproclimit*sizeof(RunEvent));
        else
            events = (RunEvent *)Malloc(nproclimit*sizeof(RunEvent));

        while(nevents < nproclimit)
            events[nevents++].pid = 0;
    }
}
@

<<function nextslot>>=
int
nextslot(void)
{
    int i;

    for(i = 0; i < nproclimit; i++)
        if(events[i].pid <= 0) 
            return i;
    assert(/*out of slots!!*/ false);
    return 0;	/* cyntax */
}
@

<<function pidslot>>=
int
pidslot(int pid)
{
    int i;

    for(i = 0; i < nevents; i++)
        if(events[i].pid == pid) 
            return i;
    <<[[pidslot()]] if DEBUG(D_EXEC)>>
    return -1;
}
@

<<function pnew>>=
static void
pnew(int pid, int status)
{
    Process *p;

    if(pfree){
        p = pfree;
        pfree = p->f;
    } else
        p = (Process *)Malloc(sizeof(Process));
    p->pid = pid;
    p->status = status;
    p->f = phead;
    phead = p;
    if(p->f)
        p->f->b = p;
    p->b = 0;
}
@

<<function pdelete>>=
static void
pdelete(Process *p)
{
    if(p->f)
        p->f->b = p->b;
    if(p->b)
        p->b->f = p->f;
    else
        phead = p->f;
    p->f = pfree;
    pfree = p;
}
@

<<function killchildren>>=
void
killchildren(char *msg)
{
    Process *p;

    kflag = true;	/* to make sure waitup doesn't exit */
    jobs = 0;	/* make sure no more get scheduled */
    for(p = phead; p; p = p->f)
        expunge(p->pid, msg);
    while(waitup(1, (int *)0) == 0)
        ;
    Bprint(&bout, "mk: %s\n", msg);
    Exit();
}
@


\section{Subprocesses managment}


<<function notifyf>>=
int
notifyf(void *a, char *msg)
{
    static int nnote;

    USED(a);
    if(++nnote > 100){	/* until andrew fixes his program */
        fprint(STDERR, "mk: too many notes\n");
        notify(0);
        abort();
    }
    if(strcmp(msg, "interrupt")!=0 && strcmp(msg, "hangup")!=0)
        return 0;
    killchildren(msg);
    return -1;
}
@

% main ->
<<function catchnotes>>=
void
catchnotes()
{
    atnotify(notifyf, 1);
}
@

\chapter{Debugging and Profiling Support}

\section{Explain mode, [[mk -e]]}

<<global explain>>=
bool explain = false;
@
% used to a char*

<<[[main()]] -xxx switch cases>>=
case 'e':
    explain = true;
    break;
@

\section{Dry mode, [[mk -n]]}

% just print recipe, do not execute them
<<global nflag>>=
bool nflag = false;
@

<<[[main()]] -xxx switch cases>>=
case 'n':
    nflag = true;
    break;
@


\section{What if, [[mk -w]]}

% what if I change a file, what needs to be done?
% usually works with -n, mk -n -wprog.h

<<[[main()]] locals>>=
Bufblock *whatif = nil;
@

<<[[main()]] -xxx switch cases>>=
case 'w':
    if(whatif == nil)
        whatif = newbuf();
    else
        insert(whatif, ' ');
    if(argv[0][2])
        bufcpy(whatif, &argv[0][2], strlen(&argv[0][2]));
    else {
        if(*++argv == 0)
            badusage();
        bufcpy(whatif, &argv[0][0], strlen(&argv[0][0]));
    }
    break;
@

<<[[main()]] if whatif>>=
if(whatif){
    insert(whatif, '\0');
    timeinit(whatif->start);
    freebuf(whatif);
}
@

%\chapter{Profiling Support}

\section{Utilization, [[mk -u]]}

% display time spent in different nrunnnig configuration

<<global uflag>>=
bool uflag = false;
@

<<[[main()]] -xxx switch cases>>=
case 'u':
    uflag = true;
    break;
@


<<global tslot>>=
static ulong tslot[1000];
@

% could be made local static!
<<global tick>>=
static ulong tick;
@

% called from many places
<<function usage>>=
void
usage(void)
{
    ulong t;

    t = time(0);
    if(tick)
        tslot[nrunning] += t - tick;
    tick = t;
}
@

<<[[main()]] print profiling stats if uflag>>=
if(uflag)
    prusage();
@

<<function prusage>>=
void
prusage(void)
{
    int i;

    usage();
    for(i = 0; i <= nevents; i++)
        fprint(1, "%d: %lud\n", i, tslot[i]);
}
@


\chapter{Advanced Features}

% all those features are meh in my opinion

\section{Regular expression pattern rules}

<<global patrule>>=
Rule *patrule;
@


<<constant NREGEXP>>=
#define		NREGEXP		10
@

<<[[Rule]] other fields>>=
Reprog		*pat;		/* reg exp goo */
@

% instead of stem
<<[[Arc]] other fields>>=
char		*match[NREGEXP];
@

% instead of stem
<<[[Job]] other fields>>=
char		**match;
@

<<[[myenv]] other array elements>>=
"stem0",		/* must be in order from here */
"stem1",
"stem2",
"stem3",
"stem4",
"stem5",
"stem6",
"stem7",
"stem8",
"stem9",
@

\section{Multiple targets}

% a few places where use Word* targets
% where in most cases it should really be simply char* target;

<<[[Rule]] other fields>>=
// list<ref_own?<string>>?
Word 		*alltargets;	/* all the targets */
@

\section{Dynamic [[mkfile]]}
% mkfile content through pipe
% |cmd  instead of <file

\section{Aggregates, archives}

\section{Missing intermediates optimization, [[mk -I]]}
% mk -i suppress this behavior
% pad: mk -I! new mode :) because I don't like the default mode!

% it is there to optimize disk space, to allow to remove .o
% the intermediate betweem the .out and the .c by pretending
% they are there if we know no .c files has actually changed.
% useful at a time where disk space was expensive, and so having
% both the .o and the .a were seen as redundant waste.

% from man page:
%Nonexistent targets that have prerequisites
%and are themselves prerequisites are treated specially.

<<global iflag>>=
bool iflag = false;
@

<<[[main()]] -xxx switch cases>>=
case 'i':
    iflag = true;
    break;
@

\section{Touching mode optimization, [[mk -t]]}

% when the user knows what he is doing

<<global tflag>>=
bool tflag = false;
@

<<[[main()]] -xxx switch cases>>=
case 't':
    tflag = true;
    break;
@

\section{Recompiling everything, [[mk -a]]}
% bad place

<<global aflag>>=
bool aflag = false;
@

<<[[main()]] -xxx switch cases>>=
case 'a':
    aflag = true;
    iflag = true;
    break;
@
% iflag = true; used to be after the switch, but same

\chapter{Conclusion}

\appendix

\chapter{Debugging}

%\section{Dumping internals, [[mk -d]]}

%mk -d[epg] EXEC PARSE GRAPH

% -d flag
<<global debug>>=
// bitset<enum<dxxx>>
int debug;
@

<<function DEBUG>>=
#define	DEBUG(x)	(debug&(x))
@

% enum<dxxx>

% rules
<<constant D_PARSE>>=
#define		D_PARSE		0x01
@
% node and arcs
<<constant D_GRAPH>>=
#define		D_GRAPH		0x02
@
% jobs
<<constant D_EXEC>>=
#define		D_EXEC		0x04
@

<<[[main()]] -xxx switch cases>>=
case 'd':
    if(*(s = &argv[0][2]))
        while(*s) 
         switch(*s++) {
         case 'p':	debug |= D_PARSE; break;
         case 'g':	debug |= D_GRAPH; break;
         case 'e':	debug |= D_EXEC; break;
        }
    else
        debug = 0xFFFF; // D_PARSE | D_GRAPH | D_EXEC
    break;
@



\section{The rules, [[mk -dp]]}

<<[[main()]] if DEBUG(D_PARSE)>>=
if(DEBUG(D_PARSE)){
    dumpw("default targets", target1);
    dumpr("rules", rules);
    dumpr("metarules", metarules);
    dumpv("variables");
}
@


<<dumper dumpw>>=
void
dumpw(char *s, Word *w)
{
    Bprint(&bout, "%s", s);
    for(; w; w = w->next)
        Bprint(&bout, " '%s'", w->s);
    Bputc(&bout, '\n');
}
@

% todo: remove the pointer thing %p, not that useful I think
% note that the variable expansion has been done for the target and prerequestes
<<dumper dumpr>>=
void
dumpr(char *s, Rule *r)
{
    Bprint(&bout, "%s: start=%p\n", s, r);
    for(; r; r = r->next){
        Bprint(&bout, "\tRule %p: %s:%d attr=%x next=%p chain=%p alltarget='%s'",
            r, r->file, r->line, r->attr, r->next, r->chain, wtos(r->alltargets, ' '));
        if(r->prog)
            Bprint(&bout, " prog='%s'", r->prog);
        Bprint(&bout, "\n\ttarget=%s: %s\n", r->target, wtos(r->tail,' '));
        Bprint(&bout, "\trecipe@%p='%s'\n", r->recipe, r->recipe);
    }
}
@

<<dumper dumpv>>=
void
dumpv(char *s)
{
    Bprint(&bout, "%s:\n", s);
    symtraverse(S_VAR, print1);
}
@

<<function print1>>=
static void
print1(Symtab *s)
{
    Word *w;

    Bprint(&bout, "\t%s=", s->name);
    for (w = s->u.ptr; w; w = w->next)
        Bprint(&bout, "'%s'", w->s);
    Bprint(&bout, "\n");
}
@





\section{The graph, [[mk -dg]]}

% node = graph(target) from mk(target)
<<[[main()]] if DEBUG(D_GRAPH)>>=
if(DEBUG(D_GRAPH)){
    dumpn("new target\n", node);
    Bflush(&bout);
}
@
% below the buf is here to compute indentation, depth of the graph in spaces

<<dumper dumpn>>=
void
dumpn(char *s, Node *n)
{
    char buf[1024];
    Arc *a;

    Bprint(&bout, "%s%s@%p: time=%ld flags=0x%x next=%p\n",
        s, n->name, n, n->time, n->flags, n->next);
    for(a = n->prereqs; a; a = a->next){
        snprint(buf, sizeof buf, "%s   ", (*s == ' ')? s:"");
        dumpa(buf, a);
    }
}
@

<<dumper dumpa>>=
void
dumpa(char *s, Arc *a)
{
    char buf[1024];

    Bprint(&bout, "%sArc@%p: n=%p r=%p flag=0x%x stem='%s'",
        s, a, a->n, a->r, a->flag, a->stem);
    if(a->prog)
        Bprint(&bout, " prog='%s'", a->prog);
    Bprint(&bout, "\n");

    if(a->n){
        snprint(buf, sizeof(buf), "%s    ", (*s == ' ')? s:"");
        dumpn(buf, a->n);
    }
}
@

\ifallcode
<<[[nrep()]] if DEBUG(D_GRAPH)>>=
if(DEBUG(D_GRAPH))
    Bprint(&bout, "nreps = %d\n", nreps);
@
\fi

\section{The jobs, [[mk -de]]}

<<[[nproc()]] if DEBUG(D_EXEC)>>=
if(DEBUG(D_EXEC))
    fprint(1, "nprocs = %d\n", nproclimit);
@



<<[[sched()]] if DEBUG(D_EXEC)>>=
if(DEBUG(D_EXEC))
    fprint(STDOUT, "firing up job for target %s\n", wtos(j->t, ' '));
@

<<[[sched()]] if DEBUG(D_EXEC) print recipe>>=
if(DEBUG(D_EXEC))
    fprint(STDOUT, "recipe='%s'\n", j->r->recipe);	/**/
Bflush(&bout);
@

<<[[sched()]] if DEBUG(D_EXEC) print pid>>=
if(DEBUG(D_EXEC))
    fprint(STDOUT, "pid for target %s = %d\n", wtos(j->t, ' '), events[slot].pid);
@


<<[[waitup()]] if DEBUG(D_EXEC) print pid>>=
if(DEBUG(D_EXEC))
    fprint(STDOUT, "waitup got pid=%d, status='%s'\n", pid, buf);
@


<<[[waitup()]] if DEBUG(D_EXEC) and slot < 0>>=
 if(DEBUG(D_EXEC))
     fprint(STDERR, "mk: wait returned unexpected process %d\n", pid);
@

<<[[pidslot()]] if DEBUG(D_EXEC)>>=
if(DEBUG(D_EXEC))
    fprint(STDERR, "mk: wait returned unexpected process %d\n", pid);
@




% actually never used
<<dumper dumpj>>=
void
dumpj(char *s, Job *j, int all)
{
    Bprint(&bout, "%s\n", s);
    while(j){
        Bprint(&bout, "job@%p: r=%p n=%p stem='%s' nproc=%d\n",
            j, j->r, j->n, j->stem, j->nproc);
        Bprint(&bout, "\ttarget='%s' alltarget='%s' prereq='%s' nprereq='%s'\n",
            wtos(j->t, ' '), wtos(j->at, ' '), wtos(j->p, ' '), wtos(j->np, ' '));
        j = all? j->next : nil;
    }
}
@


\chapter{Profiling}

<<global buf>>=
short buf[10000];
@

<<[[main()]] setup optional profiling>>=
#ifdef	PROF
    {
        extern int etext();
        monitor(main, etext, buf, sizeof buf, 300);
    }
#endif
usage();
@


% dead function actually
<<function symstat>>=
void
symstat(void)
{
    Symtab **s, *ss;
    int n;
    int l[1000];

    memset((char *)l, 0, sizeof(l));
    for(s = hash; s < &hash[NHASH]; s++){
        for(ss = *s, n = 0; ss; ss = ss->next)
            n++;
        l[n]++;
    }
    for(n = 0; n < 1000; n++)
        if(l[n]) 
            Bprint(&bout, "%d of length %d\n", l[n], n);
}
@

\chapter{Error Managment}

<<global runerrs>>=
int runerrs;
@

<<global kflag>>=
bool kflag = false;
@

% continue even if errors
<<[[main()]] -xxx switch cases>>=
case 'k':
    kflag = true;
    break;
@


\chapter{Libc}

\section{Memory managment}

% with automatic error handling
% could be in error managment section

<<function Malloc>>=
void *
Malloc(int n)
{
    register void *s;

    s = malloc(n);
    if(!s) {
        fprint(STDERR, "mk: cannot alloc %d bytes\n", n);
        Exit();
    }
    return s;
}
@

<<function Realloc>>=
void *
Realloc(void *s, int n)
{
    if(s)
        s = realloc(s, n);
    else
        s = malloc(n);
    if(!s) {
        fprint(STDERR, "mk: cannot alloc %d bytes\n", n);
        Exit();
    }
    return s;
}
@


\section{Buffer managment}

<<struct Bufblock>>=
struct Bufblock
{
    char 		*start;
    char 		*end;
    char 		*current;

    // Extra
    struct Bufblock *next;
};
@

<<global freelist>>=
static Bufblock *freelist;
@



<<constant QUANTA>>=
#define	QUANTA	4096
@

<<constructor newbuf>>=
Bufblock *
newbuf(void)
{
    Bufblock *p;

    if (freelist) {
        p = freelist;
        freelist = freelist->next;
    } else {
        p = (Bufblock *) Malloc(sizeof(Bufblock));
        p->start = Malloc(QUANTA*sizeof(*p->start));
        p->end = p->start+QUANTA;
    }
    p->current = p->start;
    *p->start = '\0';
    p->next = nil;
    return p;
}
@

<<destructor freebuf>>=
void
freebuf(Bufblock *p)
{
    p->next = freelist;
    freelist = p;
}
@

<<function growbuf>>=
void
growbuf(Bufblock *p)
{
    int n;
    Bufblock *f;
    char *cp;

    n = p->end-p->start+QUANTA;
        /* search the free list for a big buffer */
    for (f = freelist; f; f = f->next) {
        if (f->end-f->start >= n) {
            memcpy(f->start, p->start, p->end-p->start);
            cp = f->start;
            f->start = p->start;
            p->start = cp;
            cp = f->end;
            f->end = p->end;
            p->end = cp;
            f->current = f->start;
            break;
        }
    }
    if (!f) {		/* not found - grow it */
        p->start = Realloc(p->start, n);
        p->end = p->start+n;
    }
    p->current = p->start+n-QUANTA;
}
@

<<function bufcpy>>=
void
bufcpy(Bufblock *buf, char *cp, int n)
{

    while (n--)
        insert(buf, *cp++);
}
@

<<function insert>>=
void
insert(Bufblock *buf, int c)
{

    if (buf->current >= buf->end)
        growbuf(buf);
    *buf->current++ = c;
}
@

<<function rinsert>>=
void
rinsert(Bufblock *buf, Rune r)
{
    int n;

    n = runelen(r);
    if (buf->current+n > buf->end)
        growbuf(buf);
    runetochar(buf->current, &r);
    buf->current += n;
}
@

\section{Misc}

<<function maketmp>>=
char*
maketmp(void)
{
    static char temp[] = "/tmp/mkargXXXXXX";

    mktemp(temp);
    return temp;
}
@

<<function Exit>>=
void
Exit(void)
{
    while(waitpid() >= 0)
        ;
    exits("error");
}
@

\chapter{Extra Code}

\ifallcode
#include "Make_extra.tex.nw"
\fi

\chapter{Changelog}
\label{sec:changelog}

\chapter{Glossary}
\label{sec:glossary}

\begin{verbatim}
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{section}{Index}

%\chapter{References} 
\addcontentsline{toc}{section}{References}

\begin{thebibliography}{99}

\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming}, 
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb}, 
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison}, 
\url{http://padator.org/software/project-syncweb/readme.txt}

\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
