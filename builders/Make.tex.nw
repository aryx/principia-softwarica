\documentclass[twocolumn]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse
% see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things:

%thx to codemap/codegraph:

%thx to this manual, better understand make?:

%history LP-ization:
% - skeleton, mostly copy paste of Template.tex.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * ctor/dtor, dumper
% - read Extra section, identify concepts, first TOC
% - distribute parts of the file before
% - TODO nullify, boolify, typeify,    scheckify
% - TODO aspecify advanced features!
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\iffinal
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\fi
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
\usepackage{cleveref} %\cref
\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}
 %\usepackage[margin=0.5in]{geometry}
 %  but eat the bottom when very low
 %\usepackage{fullpage} is deprecated 
 % => do the more manual below:
 \addtolength{\oddsidemargin}{-.850in}
 \addtolength{\evensidemargin}{-.850in}
 \addtolength{\textwidth}{1.70in}
 \addtolength{\topmargin}{-.850in}
 \addtolength{\textheight}{1.70in}
%\usepackage{minitoc}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% used for forward decl, pragmas, func decl, extern decl, stats, #ifdef,
% debugging macros

%\setcounter{tocdepth}{1}

%******************************************************************************
% Title
%******************************************************************************

\begin{document}

\title{
{\Huge 
Plan9 Build tool: mk
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}
}

\maketitle 
\onecolumn
\hrule
\begin{quote}
    Copyright \copyright{} 2014 Yoann Padioleau \\
    Permission is granted to copy, distribute and/or modify this document,
    except all the source code it contains, under the terms of the GNU Free
    Documentation License, Version 1.3.
\end{quote}
\hrule

%CONFIG: \dominitoc

\iffinal
\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\twocolumn
\tableofcontents
\endgroup
\else
\tableofcontents
\fi

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

\section{Motivations}

The goal of this book is to present in full details the source code of
a build tool.
Why? Because I think it makes you a better programmer if
you fully understand how things work under the hood.

Here are other candidates that were considered but ultimately discarded:
\begin{itemize}
\item make
\item Cmake
\item Ant
\item Maven
\end{itemize}

% gyp, ninja, buck, ...



\section{Getting started}

% can get the one from kencc? or plan9port?
% issues though with rc vs sh ...

\section{Requirements}

% mk.ps! 
I assume you have read the [[mk.ps]] manual that introduces
the concepts used in this document (e.g. what is a rule,
a target, a recipe, etc).

%(and mk_successor_make.pdf if interested specifically of diff with make)

\section{About this document}
#include "About.tex.nw"

\section{Copyright}

Most of this document is actually source code from Plan9, so
those parts are copyright by Lucent Technologies Inc.
The prose is mine and is licensed under the GNU Free Documentation
License.

\section{Acknowledgments}

I would like to acknowledge of course mk's authors who wrote
most of this book: Andrew Hume and Bob Flandera.

\chapter{Overview}

\section{Build system principles}

The goal of a build system is to describe concisely and maintain
efficiently dependencies between files or programs.

% conciseness => DSL
% efficiency => graph and //

\section{mk services}

% interface is pretty simple, go in dir, type 'mk'
% or mk target

<<constant MKFILE>>=
#define		MKFILE		"mkfile"
@


<<global version>>=
static char *version = "@(#)mk general release 4 (plan 9)";
@

% has also many -xxx options

<<function badusage>>=
void
badusage(void)
{

    fprint(2, "Usage: mk [-f file] [-n] [-a] [-e] [-t] [-k] [-i] [-d[egp]] [targets ...]\n");
    Exit();
}
@

\section{A simple [[mkfile]]}
% actually could also show the mkfile of mk itself :)

% running example
% concepts: target, prerequiste, recipe

\section{Code organization}

\section{Architecture overview}

% graphviz of files? or just of the types?

%###############################################################################

\chapter{Core Data Structures}

% core types: (see mk.h)
% Rule (mk -dp?), recipe? metarule, target, prerequiste (see mk.ps)
% Word, Bufblock
% Node, Arc (mk -dg)
% Envy
% Job, (mk -de)
% Sym (a bit generic, could be in libc?)

% core globals: (see mk.h externs)
% bout, envy,    rules, metarules, patrule,    jobs
% symbol hashtbl global

<<global bout>>=
Biobuf bout;
@

\section{[[Rule]] and [[rules]]}

<<struct Rule>>=
typedef struct Rule
{
    char 		*target;	/* one target */
    char 		*recipe;	/* do it ! */
    Word 		*tail;		/* constituents of targets */

    int 		rule;		/* rule number */
    short 		line;		/* source line */
    char 		*file;		/* source file */

    // enum<rule_attr>
    short 		attr;		/* attributes */

    Word 		*alltargets;	/* all the targets */
    Reprog		*pat;		/* reg exp goo */
    char		*prog;		/* to use in out of date */

    // Extra
    struct Rule	*chain;		/* hashed per target */
    struct Rule	*next;
} Rule;
@


<<global rules>>=
// list<ref_own<Rule>>
Rule *rules;
@

% incremented by addrule()
<<global nrules>>=
static int nrules = 0;
@

\section{[[Word]]}

% should be renamed words ...
<<struct Word>>=
typedef struct Word
{
    char 		*s;

    // Extra
    struct Word 	*next;
} Word;
@


% e.g. 'default'
<<global target1>>=
Word *target1;
@


\section{[[Node]] and [[Arc]]}

% Rule are general descriptions, patterns,
% Node and Arc are concrete instantiation with existing files?

<<struct Node>>=
typedef struct Node
{
    char		*name;
    ulong		time;

    // enum<node_flag>
    ushort		flags;

    // list<ref_own?<Arc>>
    Arc		*prereqs;

    // Extra
    struct Node	*next;		/* list for a rule */
} Node;
@



<<constant NREGEXP>>=
#define		NREGEXP		10
@

<<struct Arc>>=
typedef struct Arc
{
    //? enum<rule_flag>?
    short		flag;

    // ref<node>, reverse of Node.prereq?
    struct Node	*n;

    Rule		*r;

    char		*stem;
    char		*prog;

    char		*match[NREGEXP];
    
    //Extra
    struct Arc	*next;
} Arc;
@

<<constant TOGO>>=
/* Arc.flag */
#define		TOGO		1
@






% TODO Node.flags
<<constant VIRTUAL>>=
/* Node.flags */
#define		VIRTUAL		0x0001
@

<<constant CYCLE>>=
#define		CYCLE		0x0002
@

<<constant READY>>=
#define		READY		0x0004
@

<<constant CANPRETEND>>=
#define		CANPRETEND	0x0008
@

<<constant PRETENDING>>=
#define		PRETENDING	0x0010
@

<<constant NOTMADE>>=
#define		NOTMADE		0x0020
@

<<constant BEINGMADE>>=
#define		BEINGMADE	0x0040
@

<<constant MADE>>=
#define		MADE		0x0080
@

<<function MADESET>>=
#define		MADESET(n,m)	n->flags = (n->flags&~(NOTMADE|BEINGMADE|MADE))|(m)
@

<<constant PROBABLE>>=
#define		PROBABLE	0x0100
@

<<constant VACUOUS>>=
#define		VACUOUS		0x0200
@

<<constant NORECIPE>>=
#define		NORECIPE	0x0400
@

<<constant DELETE>>=
#define		DELETE		0x0800
@

<<constant NOMINUSE>>=
#define		NOMINUSE	0x1000
@

\section{[[Envy]] and [[envy]]}

<<struct Envy>>=
typedef struct Envy
{
    char 		*name;

    // list<ref_own<Word>>
    Word 		*values;
} Envy;
@


<<global envy>>=
// list<ref_own<Envy>>
Envy	*envy;
@

<<global myenv>>=
static char	*myenv[] =
{
    "target",
    "stem",
    "prereq",
    "pid",
    "nproc",
    "newprereq",
    "alltarget",
    "newmember",

    "stem0",		/* must be in order from here */
    "stem1",
    "stem2",
    "stem3",
    "stem4",
    "stem5",
    "stem6",
    "stem7",
    "stem8",
    "stem9",

    0,
};
@

\section{[[Job]] and [[jobs]]}

<<struct Job>>=
typedef struct Job
{
    Rule		*r;	/* master rule for job */
    Node		*n;	/* list of node targets */
    char		*stem;
    char		**match;

    Word		*p;	/* prerequistes */
    Word		*np;	/* new prerequistes */
    Word		*t;	/* targets */
    Word		*at;	/* all targets */

    int		nproc;	/* slot number */

    // Extra
    struct Job	*next;
} Job;
@


<<global jobs>>=
// list<ref_won<jobs>>
Job *jobs;
@




\section{[[Symtab]] and [[hash]]}

<<struct Symtab>>=
typedef struct Symtab
{
    char		*name;

    short		space;

    // generic part
    union{
        void		*ptr;
        uintptr	value;
    } u;

    // Extra
    struct Symtab	*next;
} Symtab;
@


% the "world" data structure
<<enum _anon_>>=
enum {
    S_VAR,		/* variable -> value */
    S_TARGET,	/* target -> rule */
    S_TIME,		/* file -> time */

    S_PID,		/* pid -> products */
    S_NODE,		/* target name -> node */
    S_AGG,		/* aggregate -> time */
    S_BITCH,	/* bitched about aggregate not there */
    S_NOEXPORT,	/* var -> noexport */
    S_OVERRIDE,	/* can't override */
    S_OUTOFDATE,	/* n1\377n2 -> 2(outofdate) or 1(not outofdate) */
    S_MAKEFILE,	/* target -> node */
    S_MAKEVAR,	/* dumpable mk variable */
    S_EXPORTED,	/* var -> current exported value */
    S_BULKED,	/* we have bulked this dir */
    S_WESET,	/* variable; we set in the mkfile */
    S_INTERNAL,	/* an internal mk variable (e.g., stem, target) */
};
@




<<constant NHASH>>=
#define	NHASH	4099
@

<<global hash>>=
static Symtab *hash[NHASH];
@


<<constant HASHMUL>>=
#define	HASHMUL	79L	/* this is a good value */
@


<<function syminit>>=
void
syminit(void)
{
    Symtab **s, *ss;

    for(s = hash; s < &hash[NHASH]; s++){
        for(ss = *s; ss; ss = ss->next)
            free((char *)ss);
        *s = 0;
    }
}
@

<<function symlook>>=
Symtab *
symlook(char *sym, int space, void *install)
{
    long h;
    char *p;
    Symtab *s;

    for(p = sym, h = space; *p; h += *p++)
        h *= HASHMUL;
    if(h < 0)
        h = ~h;
    h %= NHASH;
    for(s = hash[h]; s; s = s->next)
        if((s->space == space) && (strcmp(s->name, sym) == 0))
            return(s);
    if(install == 0)
        return(0);
    s = (Symtab *)Malloc(sizeof(Symtab));
    s->space = space;
    s->name = sym;
    s->u.ptr = install;
    s->next = hash[h];
    hash[h] = s;
    return(s);
}
@

<<function symtraverse>>=
void
symtraverse(int space, void (*fn)(Symtab*))
{
    Symtab **s, *ss;

    for(s = hash; s < &hash[NHASH]; s++)
        for(ss = *s; ss; ss = ss->next)
            if(ss->space == space)
                (*fn)(ss);
}
@


<<function setvar>>=
void
setvar(char *name, void *value)
{
    symlook(name, S_VAR, value)->u.ptr = value;
    symlook(name, S_MAKEVAR, (void*)"");
}
@


\chapter{Rules}


\section{Simple rule}

% kind of ctor
<<function addrule>>=
void
addrule(char *head, Word *tail, char *body, Word *ahead, int attr, int hline, char *prog)
{
    Rule *r;
    Rule *rr;
    Symtab *sym;
    int reuse;

    r = 0;
    reuse = 0;
    if(sym = symlook(head, S_TARGET, 0)){
        for(r = sym->u.ptr; r; r = r->chain)
            if(rcmp(r, head, tail) == 0){
                reuse = 1;
                break;
            }
    }
    if(r == 0)
        r = (Rule *)Malloc(sizeof(Rule));
    r->target = head;
    r->tail = tail;
    r->recipe = body;
    r->line = hline;
    r->file = infile;
    r->attr = attr;
    r->alltargets = ahead;
    r->prog = prog;
    r->rule = nrules++;

    if(!reuse){
        rr = symlook(head, S_TARGET, r)->u.ptr;
        if(rr != r){
            r->chain = rr->chain;
            rr->chain = r;
        } else
            r->chain = 0;
    }
    if(!reuse)
        r->next = 0;
    if((attr&REGEXP) || charin(head, "%&")){
        r->attr |= META;
        if(reuse)
            return;
        if(attr&REGEXP){
            patrule = r;
            r->pat = regcomp(head);
        }
        if(metarules == 0)
            metarules = lmr = r;
        else {
            lmr->next = r;
            lmr = r;
        }
    } else {
        if(reuse)
            return;
        r->pat = 0;
        if(rules == 0)
            rules = lr = r;
        else {
            lr->next = r;
            lr = r;
        }
    }
}
@


<<function rcmp>>=
static int
rcmp(Rule *r, char *target, Word *tail)
{
    Word *w;

    if(strcmp(r->target, target))
        return 1;
    for(w = r->tail; w && tail; w = w->next, tail = tail->next)
        if(strcmp(w->s, tail->s))
            return 1;
    return(w || tail);
}
@




\section{Metarule}

<<global metarules>>=
// list<ref_own<Rule>>
Rule *metarules;
@

<<function PERCENT>>=
#define	PERCENT(ch)	(((ch) == '%') || ((ch) == '&'))
@

% see matching later, or put matching here?

\section{Variables}


\section{Rule attributes}

% TODO use enum rule_attr
<<constant META>>=
/*	Rule.attr	*/
#define		META		0x0001
@

<<constant UNUSED>>=
//@Scheck: dead indeed
#define		UNUSED		0x0002
@

<<constant UPD>>=
#define		UPD		0x0004
@

<<constant QUIET>>=
#define		QUIET		0x0008
@

<<constant VIR>>=
#define		VIR		0x0010
@

<<constant REGEXP>>=
#define		REGEXP		0x0020
@

<<constant NOREC>>=
#define		NOREC		0x0040
@

<<constant DEL>>=
#define		DEL		0x0080
@

<<constant NOVIRT>>=
#define		NOVIRT		0x0100
@


\chapter{Parsing}
% could be done later?

<<function SYNERR>>=
#define	SYNERR(l)	(fprint(2, "mk: %s:%d: syntax error; ", infile, ((l)>=0)?(l):mkinline))
@

<<global infile>>=
char *infile;
@

<<global mkinline>>=
int mkinline;
@

\section{Parsing a file}

<<function parse>>=
void
parse(char *f, int fd, int varoverride)
{
    int hline;
    char *body;
    Word *head, *tail;
    int attr, set, pid;
    char *prog, *p;
    int newfd;
    Biobuf in;
    Bufblock *buf;

    if(fd < 0){
        perror(f);
        Exit();
    }
    ipush();
    infile = strdup(f);
    mkinline = 1;
    Binit(&in, fd, OREAD);
    buf = newbuf();
    while(assline(&in, buf)){
        hline = mkinline;
        switch(rhead(buf->start, &head, &tail, &attr, &prog))
        {
        case '<':
            p = wtos(tail, ' ');
            if(*p == 0){
                SYNERR(-1);
                fprint(2, "missing include file name\n");
                Exit();
            }
            newfd = open(p, OREAD);
            if(newfd < 0){
                fprint(2, "warning: skipping missing include file: ");
                perror(p);
            } else
                parse(p, newfd, 0);
            break;
        case '|':
            p = wtos(tail, ' ');
            if(*p == 0){
                SYNERR(-1);
                fprint(2, "missing include program name\n");
                Exit();
            }
            execinit();
            pid=pipecmd(p, envy, &newfd);
            if(newfd < 0){
                fprint(2, "warning: skipping missing program file: ");
                perror(p);
            } else
                parse(p, newfd, 0);
            while(waitup(-3, &pid) >= 0)
                ;
            if(pid != 0){
                fprint(2, "bad include program status\n");
                Exit();
            }
            break;
        case ':':
            body = rbody(&in);
            addrules(head, tail, body, attr, hline, prog);
            break;
        case '=':
            if(head->next){
                SYNERR(-1);
                fprint(2, "multiple vars on left side of assignment\n");
                Exit();
            }
            if(symlook(head->s, S_OVERRIDE, 0)){
                set = varoverride;
            } else {
                set = 1;
                if(varoverride)
                    symlook(head->s, S_OVERRIDE, (void *)"");
            }
            if(set){
/*
char *cp;
dumpw("tail", tail);
cp = wtos(tail, ' '); print("assign %s to %s\n", head->s, cp); free(cp);
*/
                setvar(head->s, (void *) tail);
                symlook(head->s, S_WESET, (void *)"");
            }
            if(attr)
                symlook(head->s, S_NOEXPORT, (void *)"");
            break;
        default:
            SYNERR(hline);
            fprint(2, "expected one of :<=\n");
            Exit();
            break;
        }
    }
    close(fd);
    freebuf(buf);
    ipop();
}
@

<<function addrules>>=
void
addrules(Word *head, Word *tail, char *body, int attr, int hline, char *prog)
{
    Word *w;

    assert(/*addrules args*/ head && body);
        /* tuck away first non-meta rule as default target*/
    if(target1 == 0 && !(attr&REGEXP)){
        for(w = head; w; w = w->next)
            if(charin(w->s, "%&"))
                break;
        if(w == 0)
            target1 = wdup(head);
    }
    for(w = head; w; w = w->next)
        addrule(w->s, tail, body, head, attr, hline, prog);
}
@

<<function rhead>>=
static int
rhead(char *line, Word **h, Word **t, int *attr, char **prog)
{
    char *p;
    char *pp;
    int sep;
    Rune r;
    int n;
    Word *w;

    p = charin(line,":=<");
    if(p == 0)
        return('?');
    sep = *p;
    *p++ = 0;
    if(sep == '<' && *p == '|'){
        sep = '|';
        p++;
    }
    *attr = 0;
    *prog = 0;
    if(sep == '='){
        pp = charin(p, termchars);	/* termchars is shell-dependent */
        if (pp && *pp == '=') {
            while (p != pp) {
                n = chartorune(&r, p);
                switch(r)
                {
                default:
                    SYNERR(-1);
                    fprint(2, "unknown attribute '%c'\n",*p);
                    Exit();
                case 'U':
                    *attr = 1;
                    break;
                }
                p += n;
            }
            p++;		/* skip trailing '=' */
        }
    }
    if((sep == ':') && *p && (*p != ' ') && (*p != '\t')){
        while (*p) {
            n = chartorune(&r, p);
            if (r == ':')
                break;
            p += n;
            switch(r)
            {
            default:
                SYNERR(-1);
                fprint(2, "unknown attribute '%c'\n", p[-1]);
                Exit();
            case 'D':
                *attr |= DEL;
                break;
            case 'E':
                *attr |= NOMINUSE;
                break;
            case 'n':
                *attr |= NOVIRT;
                break;
            case 'N':
                *attr |= NOREC;
                break;
            case 'P':
                pp = utfrune(p, ':');
                if (pp == 0 || *pp == 0)
                    goto eos;
                *pp = 0;
                *prog = strdup(p);
                *pp = ':';
                p = pp;
                break;
            case 'Q':
                *attr |= QUIET;
                break;
            case 'R':
                *attr |= REGEXP;
                break;
            case 'U':
                *attr |= UPD;
                break;
            case 'V':
                *attr |= VIR;
                break;
            }
        }
        if (*p++ != ':') {
    eos:
            SYNERR(-1);
            fprint(2, "missing trailing :\n");
            Exit();
        }
    }
    *h = w = stow(line);
    if(*w->s == 0 && sep != '<' && sep != '|') {
        SYNERR(mkinline-1);
        fprint(2, "no var on left side of assignment/rule\n");
        Exit();
    }
    *t = stow(p);
    return(sep);
}
@

<<function rbody>>=
static char *
rbody(Biobuf *in)
{
    Bufblock *buf;
    int r, lastr;
    char *p;

    lastr = '\n';
    buf = newbuf();
    for(;;){
        r = Bgetrune(in);
        if (r < 0)
            break;
        if (lastr == '\n') {
            if (r == '#')
                rinsert(buf, r);
            else if (r != ' ' && r != '\t') {
                Bungetrune(in);
                break;
            }
        } else
            rinsert(buf, r);
        lastr = r;
        if (r == '\n')
            mkinline++;
    }
    insert(buf, 0);
    p = strdup(buf->start);
    freebuf(buf);
    return p;
}
@

\section{Parsing included files}

<<struct input>>=
struct input
{
    char *file;
    int line;

    // Extra
    struct input *next;
};
@

<<global inputs>>=
static struct input *inputs = 0;
@

% can process many files, because of the </sys/src/... 

<<function ipush>>=
void
ipush(void)
{
    struct input *in, *me;

    me = (struct input *)Malloc(sizeof(*me));
    me->file = infile;
    me->line = mkinline;
    me->next = 0;
    if(inputs == 0)
        inputs = me;
    else {
        for(in = inputs; in->next; )
            in = in->next;
        in->next = me;
    }
}
@

<<function ipop>>=
void
ipop(void)
{
    struct input *in, *me;

    assert(/*pop input list*/ inputs != 0);
    if(inputs->next == 0){
        me = inputs;
        inputs = 0;
    } else {
        for(in = inputs; in->next->next; )
            in = in->next;
        me = in->next;
        in->next = 0;
    }
    infile = me->file;
    mkinline = me->line;
    free((char *)me);
}
@

\section{Parsing a line}

<<function assline>>=
/*
 *	Assemble a line skipping blank lines, comments, and eliding
 *	escaped newlines
 */
int
assline(Biobuf *bp, Bufblock *buf)
{
    int c;
    int lastc;

    buf->current=buf->start;
    while ((c = nextrune(bp, 1)) >= 0){
        switch(c)
        {
        case '\r':		/* consumes CRs for Win95 */
            continue;
        case '\n':
            if (buf->current != buf->start) {
                insert(buf, 0);
                return 1;
            }
            break;		/* skip empty lines */
        case '\\':
        case '\'':
        case '"':
            rinsert(buf, c);
            if (escapetoken(bp, buf, 1, c) == 0)
                Exit();
            break;
        case '`':
            if (bquote(bp, buf) == 0)
                Exit();
            break;
        case '#':
            lastc = '#';
            while ((c = Bgetc(bp)) != '\n') {
                if (c < 0)
                    goto eof;
                if(c != '\r')
                    lastc = c;
            }
            mkinline++;
            if (lastc == '\\')
                break;		/* propagate escaped newlines??*/
            if (buf->current != buf->start) {
                insert(buf, 0);
                return 1;
            }
            break;
        default:
            rinsert(buf, c);
            break;
        }
    }
eof:
    insert(buf, 0);
    return *buf->start != 0;
}
@

<<function bquote>>=
/*
 *	assemble a back-quoted shell command into a buffer
 */
static int
bquote(Biobuf *bp, Bufblock *buf)
{
    int c, line, term;
    int start;

    line = mkinline;
    while((c = Bgetrune(bp)) == ' ' || c == '\t')
            ;
    if(c == '{'){
        term = '}';		/* rc style */
        while((c = Bgetrune(bp)) == ' ' || c == '\t')
            ;
    } else
        term = '`';		/* sh style */

    start = buf->current-buf->start;
    for(;c > 0; c = nextrune(bp, 0)){
        if(c == term){
            insert(buf, '\n');
            insert(buf,0);
            buf->current = buf->start+start;
            execinit();
            execsh(0, buf->current, buf, envy);
            return 1;
        }
        if(c == '\n')
            break;
        if(c == '\'' || c == '"' || c == '\\'){
            insert(buf, c);
            if(!escapetoken(bp, buf, 1, c))
                return 0;
            continue;
        }
        rinsert(buf, c);
    }
    SYNERR(line);
    fprint(2, "missing closing %c after `\n", term);
    return 0;
}
@

<<function nextrune>>=
/*
 *	get next character stripping escaped newlines
 *	the flag specifies whether escaped newlines are to be elided or
 *	replaced with a blank.
 */
int
nextrune(Biobuf *bp, int elide)
{
    int c;

    for (;;) {
        c = Bgetrune(bp);
        if (c == '\\') {
            if (Bgetrune(bp) == '\n') {
                mkinline++;
                if (elide)
                    continue;
                return ' ';
            }
            Bungetrune(bp);
        }
        if (c == '\n')
            mkinline++;
        return c;
    }
}
@

\section{Parsing a string}

<<constructor newword>>=
Word*
newword(char *s)
{
    Word *w;

    w = (Word *)Malloc(sizeof(Word));
    w->s = strdup(s);
    w->next = 0;
    return(w);
}
@

<<destructor delword>>=
void
delword(Word *w)
{
    Word *v;

    while(v = w){
        w = w->next;
        if(v->s)
            free(v->s);
        free(v);
    }
}
@

<<function wdup>>=
Word*
wdup(Word *w)
{
    Word *v, *new, *base;

    v = base = 0;
    while(w){
        new = newword(w->s);
        if(v)
            v->next = new;
        else
            base = new;
        v = new;
        w = w->next;
    }
    return base;
}
@





% string to word
<<function stow>>=
Word *
stow(char *s)
{
    Word *head, *w, *new;

    w = head = 0;
    while(*s){
        new = nextword(&s);
        if(new == 0)
            break;
        if (w)
            w->next = new;
        else
            head = w = new;
        while(w->next)
            w = w->next;
        
    }
    if (!head)
        head = newword("");
    return(head);
}
@



% word to string
<<function wtos>>=
char *
wtos(Word *w, int sep)
{
    Bufblock *buf;
    char *cp;

    buf = newbuf();
    for(; w; w = w->next){
        for(cp = w->s; *cp; cp++)
            insert(buf, *cp);
        if(w->next)
            insert(buf, sep);
    }
    insert(buf, 0);
    cp = strdup(buf->start);
    freebuf(buf);
    return(cp);
}
@



<<function nextword>>=
/*
 *	break out a word from a string handling quotes, executions,
 *	and variable expansions.
 */
static Word*
nextword(char **s)
{
    Bufblock *b;
    Word *head, *tail, *w;
    Rune r;
    char *cp;
    int empty;

    cp = *s;
    b = newbuf();
restart:
    head = tail = 0;
    while(*cp == ' ' || *cp == '\t')		/* leading white space */
        cp++;
    empty = 1;
    while(*cp){
        cp += chartorune(&r, cp);
        switch(r)
        {
        case ' ':
        case '\t':
        case '\n':
            goto out;
        case '\\':
        case '\'':
        case '"':
            empty = 0;
            cp = expandquote(cp, r, b);
            if(cp == 0){
                fprint(2, "missing closing quote: %s\n", *s);
                Exit();
            }
            break;
        case '$':
            w = varsub(&cp);
            if(w == 0){
                if(empty)
                    goto restart;
                break;
            }
            empty = 0;
            if(b->current != b->start){
                bufcpy(b, w->s, strlen(w->s));
                insert(b, 0);
                free(w->s);
                w->s = strdup(b->start);
                b->current = b->start;
            }
            if(head){
                bufcpy(b, tail->s, strlen(tail->s));
                bufcpy(b, w->s, strlen(w->s));
                insert(b, 0);
                free(tail->s);
                tail->s = strdup(b->start);
                tail->next = w->next;
                free(w->s);
                free(w);
                b->current = b->start;
            } else
                tail = head = w;
            while(tail->next)
                tail = tail->next;
            break;
        default:
            empty = 0;
            rinsert(b, r);
            break;
        }
    }
out:
    *s = cp;
    if(b->current != b->start){
        if(head){
            cp = b->current;
            bufcpy(b, tail->s, strlen(tail->s));
            bufcpy(b, b->start, cp-b->start);
            insert(b, 0);
            free(tail->s);
            tail->s = strdup(cp);
        } else {
            insert(b, 0);
            head = newword(b->start);
        }
    }
    freebuf(b);
    return head;
}
@
%$



\chapter{Matching}


<<function match>>=
int
match(char *name, char *template, char *stem)
{
    Rune r;
    int n;

    while(*name && *template){
        n = chartorune(&r, template);
        if (PERCENT(r))
            break;
        while (n--)
            if(*name++ != *template++)
                return 0;
    }
    if(!PERCENT(*template))
        return 0;
    n = strlen(name)-strlen(template+1);
    if (n < 0)
        return 0;
    if (strcmp(template+1, name+n))
        return 0;
    strncpy(stem, name, n);
    stem[n] = 0;
    if(*template == '&')
        return !charin(stem, "./");
    return 1;
}
@

<<function subst>>=
void
subst(char *stem, char *template, char *dest, int dlen)
{
    Rune r;
    char *s, *e;
    int n;

    e = dest+dlen-1;
    while(*template){
        n = chartorune(&r, template);
        if (PERCENT(r)) {
            template += n;
            for (s = stem; *s; s++)
                if(dest < e)
                    *dest++ = *s;
        } else
            while (n--){
                if(dest < e)
                    *dest++ = *template;
                template++;
            }
    }
    *dest = 0;
}
@



\chapter{Dependency graph}

% dtor = ?
<<constructor newnode>>=
static Node *
newnode(char *name)
{
    register Node *node;

    node = (Node *)Malloc(sizeof(Node));
    symlook(name, S_NODE, (void *)node);
    node->name = name;
    node->time = timeof(name, 0);
    node->prereqs = 0;
    node->flags = node->time? PROBABLE : 0;
    node->next = 0;
    return(node);
}
@


% dtor = ?
<<constructor newarc>>=
Arc *
newarc(Node *n, Rule *r, char *stem, Resub *match)
{
    Arc *a;

    a = (Arc *)Malloc(sizeof(Arc));
    a->n = n;
    a->r = r;
    a->stem = strdup(stem);
    rcopy(a->match, match, NREGEXP);
    a->next = 0;
    a->flag = 0;
    a->prog = r->prog;
    return(a);
}
@





% constructor?
<<function graph>>=
Node *
graph(char *target)
{
    Node *node;
    char *cnt;

    cnt = rulecnt();
    node = applyrules(target, cnt);
    free(cnt);
    cyclechk(node);
    node->flags |= PROBABLE;	/* make sure it doesn't get deleted */
    vacuous(node);
    ambiguous(node);
    attribute(node);
    return(node);
}
@

% ???
<<function rulecnt>>=
char *
rulecnt(void)
{
    char *s;

    s = Malloc(nrules);
    memset(s, 0, nrules);
    return(s);
}
@


<<function attribute>>=
static void
attribute(Node *n)
{
    register Arc *a;

    for(a = n->prereqs; a; a = a->next){
        if(a->r->attr&VIR)
            n->flags |= VIRTUAL;
        if(a->r->attr&NOREC)
            n->flags |= NORECIPE;
        if(a->r->attr&DEL)
            n->flags |= DELETE;
        if(a->n)
            attribute(a->n);
    }
    if(n->flags&VIRTUAL)
        n->time = 0;
}
@

<<function applyrules>>=
static Node *
applyrules(char *target, char *cnt)
{
    Symtab *sym;
    Node *node;
    Rule *r;
    Arc head, *a = &head;
    Word *w;
    char stem[NAMEBLOCK], buf[NAMEBLOCK];
    Resub rmatch[NREGEXP];

/*	print("applyrules(%lux='%s')\n", target, target);/**/
    sym = symlook(target, S_NODE, 0);
    if(sym)
        return sym->u.ptr;
    target = strdup(target);
    node = newnode(target);
    head.n = 0;
    head.next = 0;
    sym = symlook(target, S_TARGET, 0);
    memset((char*)rmatch, 0, sizeof(rmatch));
    for(r = sym? sym->u.ptr:0; r; r = r->chain){
        if(r->attr&META) continue;
        if(strcmp(target, r->target)) continue;
        if((!r->recipe || !*r->recipe) && (!r->tail || !r->tail->s || !*r->tail->s)) continue;	/* no effect; ignore */
        if(cnt[r->rule] >= nreps) continue;
        cnt[r->rule]++;
        node->flags |= PROBABLE;

/*		if(r->attr&VIR)
 *			node->flags |= VIRTUAL;
 *		if(r->attr&NOREC)
 *			node->flags |= NORECIPE;
 *		if(r->attr&DEL)
 *			node->flags |= DELETE;
 */
        if(!r->tail || !r->tail->s || !*r->tail->s) {
            a->next = newarc((Node *)0, r, "", rmatch);
            a = a->next;
        } else
            for(w = r->tail; w; w = w->next){
                a->next = newarc(applyrules(w->s, cnt), r, "", rmatch);
                a = a->next;
        }
        cnt[r->rule]--;
        head.n = node;
    }
    for(r = metarules; r; r = r->next){
        if((!r->recipe || !*r->recipe) && (!r->tail || !r->tail->s || !*r->tail->s)) continue;	/* no effect; ignore */
        if ((r->attr&NOVIRT) && a != &head && (a->r->attr&VIR))
            continue;
        if(r->attr&REGEXP){
            stem[0] = 0;
            patrule = r;
            memset((char*)rmatch, 0, sizeof(rmatch));
            if(regexec(r->pat, node->name, rmatch, NREGEXP) == 0)
                continue;
        } else {
            if(!match(node->name, r->target, stem)) continue;
        }
        if(cnt[r->rule] >= nreps) continue;
        cnt[r->rule]++;

/*		if(r->attr&VIR)
 *			node->flags |= VIRTUAL;
 *		if(r->attr&NOREC)
 *			node->flags |= NORECIPE;
 *		if(r->attr&DEL)
 *			node->flags |= DELETE;
 */
        if(!r->tail || !r->tail->s || !*r->tail->s) {
            a->next = newarc((Node *)0, r, stem, rmatch);
            a = a->next;
        } else
            for(w = r->tail; w; w = w->next){
                if(r->attr&REGEXP)
                    regsub(w->s, buf, sizeof(buf), rmatch, NREGEXP);
                else
                    subst(stem, w->s, buf, sizeof(buf));
                a->next = newarc(applyrules(buf, cnt), r, stem, rmatch);
                a = a->next;
            }
        cnt[r->rule]--;
    }
    a->next = node->prereqs;
    node->prereqs = head.next;
    return(node);
}
@

<<function togo>>=
static void
togo(Node *node)
{
    Arc *la, *a;

    /* delete them now */
    la = 0;
    for(a = node->prereqs; a; la = a, a = a->next)
        if(a->flag&TOGO){
            if(a == node->prereqs)
                node->prereqs = a->next;
            else
                la->next = a->next, a = la;
        }
}
@

<<function vacuous>>=
static int
vacuous(Node *node)
{
    Arc *la, *a;
    int vac = !(node->flags&PROBABLE);

    if(node->flags&READY)
        return(node->flags&VACUOUS);
    node->flags |= READY;
    for(a = node->prereqs; a; a = a->next)
        if(a->n && vacuous(a->n) && (a->r->attr&META))
            a->flag |= TOGO;
        else
            vac = 0;
    /* if a rule generated arcs that DON'T go; no others from that rule go */
    for(a = node->prereqs; a; a = a->next)
        if((a->flag&TOGO) == 0)
            for(la = node->prereqs; la; la = la->next)
                if((la->flag&TOGO) && (la->r == a->r)){
                    la->flag &= ~TOGO;
                }
    togo(node);
    if(vac)
        node->flags |= VACUOUS;
    return(vac);
}
@


\section{Cycle detection}

<<function cyclechk>>=
static void
cyclechk(Node *n)
{
    Arc *a;

    if((n->flags&CYCLE) && n->prereqs){
        fprint(2, "mk: cycle in graph detected at target %s\n", n->name);
        Exit();
    }
    n->flags |= CYCLE;
    for(a = n->prereqs; a; a = a->next)
        if(a->n)
            cyclechk(a->n);
    n->flags &= ~CYCLE;
}
@

\section{Ambiguous rule detection}

<<function trace>>=
static void
trace(char *s, Arc *a)
{
    fprint(2, "\t%s", s);
    while(a){
        fprint(2, " <-(%s:%d)- %s", a->r->file, a->r->line,
            a->n? a->n->name:"");
        if(a->n){
            for(a = a->n->prereqs; a; a = a->next)
                if(*a->r->recipe) break;
        } else
            a = 0;
    }
    fprint(2, "\n");
}
@

<<function ambiguous>>=
static void
ambiguous(Node *n)
{
    Arc *a;
    Rule *r = 0;
    Arc *la;
    int bad = 0;

    la = 0;
    for(a = n->prereqs; a; a = a->next){
        if(a->n)
            ambiguous(a->n);
        if(*a->r->recipe == 0) continue;
        if(r == 0)
            r = a->r, la = a;
        else{
            if(r->recipe != a->r->recipe){
                if((r->attr&META) && !(a->r->attr&META)){
                    la->flag |= TOGO;
                    r = a->r, la = a;
                } else if(!(r->attr&META) && (a->r->attr&META)){
                    a->flag |= TOGO;
                    continue;
                }
            }
            if(r->recipe != a->r->recipe){
                if(bad == 0){
                    fprint(2, "mk: ambiguous recipes for %s:\n", n->name);
                    bad = 1;
                    trace(n->name, la);
                }
                trace(n->name, a);
            }
        }
    }
    if(bad)
        Exit();
    togo(n);
}
@


\chapter{Time}


<<function mtime>>=
/* table-driven version in bootes dump of 12/31/96 */

ulong
mtime(char *name)
{
    return mkmtime(name, 1);
}
@

<<function timeof>>=
ulong
timeof(char *name, int force)
{
    Symtab *sym;
    ulong t;

    if(utfrune(name, '('))
        return atimeof(force, name);		/* archive */

    if(force)
        return mtime(name);

    sym = symlook(name, S_TIME, 0);
    if (sym)
        return sym->u.value;		/* uggh */

    t = mkmtime(name, 0);
    if(t == 0)
        return 0;

    symlook(name, S_TIME, (void*)t);		/* install time in cache */
    return t;
}
@

<<function touch>>=
void
touch(char *name)
{
    Bprint(&bout, "touch(%s)\n", name);
    if(nflag)
        return;

    if(utfrune(name, '('))
        atouch(name);		/* archive */
    else if(chgtime(name) < 0) {
        perror(name);
        Exit();
    }
}
@

<<function delete>>=
void
delete(char *name)
{
    if(utfrune(name, '(') == 0) {		/* file */
        if(remove(name) < 0)
            perror(name);
    } else
        fprint(2, "hoon off; mk can'tdelete archive members\n");
}
@

<<function timeinit>>=
void
timeinit(char *s)
{
    ulong t;
    char *cp;
    Rune r;
    int c, n;

    t = time(0);
    while (*s) {
        cp = s;
        do{
            n = chartorune(&r, s);
            if (r == ' ' || r == ',' || r == '\n')
                break;
            s += n;
        } while(*s);
        c = *s;
        *s = 0;
        symlook(strdup(cp), S_TIME, (void *)t)->u.value = t;
        if (c)
            *s++ = c;
        while(*s){
            n = chartorune(&r, s);
            if(r != ' ' && r != ',' && r != '\n')
                break;
            s += n;
        }
    }
}
@


\chapter{Shell interaction}
% the recipe

<<global shell>>=
char 	*shell =	"/bin/rc";
@

<<global shellname>>=
char 	*shellname =	"rc";
@



<<global termchars>>=
char	*termchars = "'= \t";	/*used in parse.c to isolate assignment attribute*/
@

<<global shflags>>=
char	*shflags = "-I";	/* rc flag to force non-interactive mode */
@

<<global IWS>>=
int	IWS = '\1';		/* inter-word separator in env - not used in plan 9 */
@


\section{The environment}
% as opposed to make, no $(XX), no $$i, the string is passed
% as is to shell! less escaping need!

<<enum _anon_ (mk/env.c)>>=
enum {
    ENVQUANTA=10
};
@

<<global nextv>>=
static int nextv;
@


<<function initenv>>=
void
initenv(void)
{
    char **p;

    for(p = myenv; *p; p++)
        symlook(*p, S_INTERNAL, (void *)"");
    readenv();				/* o.s. dependent */
}
@

<<function envinsert>>=
static void
envinsert(char *name, Word *value)
{
    static int envsize;

    if (nextv >= envsize) {
        envsize += ENVQUANTA;
        envy = (Envy *) Realloc((char *) envy, envsize*sizeof(Envy));
    }
    envy[nextv].name = name;
    envy[nextv++].values = value;
}
@

<<function envupd>>=
static void
envupd(char *name, Word *value)
{
    Envy *e;

    for(e = envy; e->name; e++)
        if(strcmp(name, e->name) == 0){
            delword(e->values);
            e->values = value;
            return;
        }
    e->name = name;
    e->values = value;
    envinsert(0,0);
}
@

<<function ecopy>>=
static void
ecopy(Symtab *s)
{
    char **p;

    if(symlook(s->name, S_NOEXPORT, 0))
        return;
    for(p = myenv; *p; p++)
        if(strcmp(*p, s->name) == 0)
            return;
    envinsert(s->name, s->u.ptr);
}
@

<<function execinit>>=
void
execinit(void)
{
    char **p;

    nextv = 0;
    for(p = myenv; *p; p++)
        envinsert(*p, stow(""));

    symtraverse(S_VAR, ecopy);
    envinsert(0, 0);
}
@

<<function buildenv>>=
Envy*
buildenv(Job *j, int slot)
{
    char **p, *cp, *qp;
    Word *w, *v, **l;
    int i;
    char buf[256];

    envupd("target", wdup(j->t));
    if(j->r->attr&REGEXP)
        envupd("stem",newword(""));
    else
        envupd("stem", newword(j->stem));
    envupd("prereq", wdup(j->p));
    snprint(buf, sizeof buf, "%d", getpid());
    envupd("pid", newword(buf));
    snprint(buf, sizeof buf, "%d", slot);
    envupd("nproc", newword(buf));
    envupd("newprereq", wdup(j->np));
    envupd("alltarget", wdup(j->at));
    l = &v;
    v = w = wdup(j->np);
    while(w){
        cp = strchr(w->s, '(');
        if(cp){
            qp = strchr(cp+1, ')');
            if(qp){
                *qp = 0;
                strcpy(w->s, cp+1);
                l = &w->next;
                w = w->next;
                continue;
            }
        }
        *l = w->next;
        free(w->s);
        free(w);
        w = *l;
    }
    envupd("newmember", v);
        /* update stem0 -> stem9 */
    for(p = myenv; *p; p++)
        if(strcmp(*p, "stem0") == 0)
            break;
    for(i = 0; *p; i++, p++){
        if((j->r->attr&REGEXP) && j->match[i])
            envupd(*p, newword(j->match[i]));
        else 
            envupd(*p, newword(""));
    }
    return envy;
}
@


\section{Variables expansion}

<<function varsub>>=
Word *
varsub(char **s)
{
    Bufblock *b;
    Word *w;

    if(**s == '{')		/* either ${name} or ${name: A%B==C%D}*/
        return expandvar(s);

    b = varname(s);
    if(b == 0)
        return 0;

    w = varmatch(b->start);
    freebuf(b);
    return w;
}
@

<<function varname>>=
/*
 *	extract a variable name
 */
static Bufblock*
varname(char **s)
{
    Bufblock *b;
    char *cp;
    Rune r;
    int n;

    b = newbuf();
    cp = *s;
    for(;;){
        n = chartorune(&r, cp);
        if (!WORDCHR(r))
            break;
        rinsert(b, r);
        cp += n;
    }
    if (b->current == b->start){
        SYNERR(-1);
        fprint(2, "missing variable name <%s>\n", *s);
        freebuf(b);
        return 0;
    }
    *s = cp;
    insert(b, 0);
    return b;
}
@

<<function WORDCHR>>=
#define WORDCHR(r)	((r) > ' ' && !utfrune("!\"#$%&'()*+,-./:;<=>?@[\\]^`{|}~", (r)))
@
%$

<<function varmatch>>=
static Word*
varmatch(char *name)
{
    Word *w;
    Symtab *sym;
    
    sym = symlook(name, S_VAR, 0);
    if(sym){
            /* check for at least one non-NULL value */
        for (w = sym->u.ptr; w; w = w->next)
            if(w->s && *w->s)
                return wdup(w);
    }
    return 0;
}
@

<<function expandvar>>=
static Word*
expandvar(char **s)
{
    Word *w;
    Bufblock *buf;
    Symtab *sym;
    char *cp, *begin, *end;

    begin = *s;
    (*s)++;						/* skip the '{' */
    buf = varname(s);
    if (buf == 0)
        return 0;
    cp = *s;
    if (*cp == '}') {				/* ${name} variant*/
        (*s)++;					/* skip the '}' */
        w = varmatch(buf->start);
        freebuf(buf);
        return w;
    }
    if (*cp != ':') {
        SYNERR(-1);
        fprint(2, "bad variable name <%s>\n", buf->start);
        freebuf(buf);
        return 0;
    }
    cp++;
    end = charin(cp , "}");
    if(end == 0){
        SYNERR(-1);
        fprint(2, "missing '}': %s\n", begin);
        Exit();
    }
    *end = 0;
    *s = end+1;
    
    sym = symlook(buf->start, S_VAR, 0);
    if(sym == 0 || sym->u.value == 0)
        w = newword(buf->start);
    else
        w = subsub(sym->u.ptr, cp, end);
    freebuf(buf);
    return w;
}
@
%$

<<function extractpat>>=
static Word*
extractpat(char *s, char **r, char *term, char *end)
{
    int save;
    char *cp;
    Word *w;

    cp = charin(s, term);
    if(cp){
        *r = cp;
        if(cp == s)
            return 0;
        save = *cp;
        *cp = 0;
        w = stow(s);
        *cp = save;
    } else {
        *r = end;
        w = stow(s);
    }
    return w;
}
@

<<function subsub>>=
static Word*
subsub(Word *v, char *s, char *end)
{
    int nmid;
    Word *head, *tail, *w, *h;
    Word *a, *b, *c, *d;
    Bufblock *buf;
    char *cp, *enda;

    a = extractpat(s, &cp, "=%&", end);
    b = c = d = 0;
    if(PERCENT(*cp))
        b = extractpat(cp+1, &cp, "=", end);
    if(*cp == '=')
        c = extractpat(cp+1, &cp, "&%", end);
    if(PERCENT(*cp))
        d = stow(cp+1);
    else if(*cp)
        d = stow(cp);

    head = tail = 0;
    buf = newbuf();
    for(; v; v = v->next){
        h = w = 0;
        if(submatch(v->s, a, b, &nmid, &enda)){
            /* enda points to end of A match in source;
             * nmid = number of chars between end of A and start of B
             */
            if(c){
                h = w = wdup(c);
                while(w->next)
                    w = w->next;
            }
            if(PERCENT(*cp) && nmid > 0){	
                if(w){
                    bufcpy(buf, w->s, strlen(w->s));
                    bufcpy(buf, enda, nmid);
                    insert(buf, 0);
                    free(w->s);
                    w->s = strdup(buf->start);
                } else {
                    bufcpy(buf, enda, nmid);
                    insert(buf, 0);
                    h = w = newword(buf->start);
                }
                buf->current = buf->start;
            }
            if(d && *d->s){
                if(w){

                    bufcpy(buf, w->s, strlen(w->s));
                    bufcpy(buf, d->s, strlen(d->s));
                    insert(buf, 0);
                    free(w->s);
                    w->s = strdup(buf->start);
                    w->next = wdup(d->next);
                    while(w->next)
                        w = w->next;
                    buf->current = buf->start;
                } else
                    h = w = wdup(d);
            }
        }
        if(w == 0)
            h = w = newword(v->s);
    
        if(head == 0)
            head = h;
        else
            tail->next = h;
        tail = w;
    }
    freebuf(buf);
    delword(a);
    delword(b);
    delword(c);
    delword(d);
    return head;
}
@

<<function submatch>>=
static int
submatch(char *s, Word *a, Word *b, int *nmid, char **enda)
{
    Word *w;
    int n;
    char *end;

    n = 0;
    for(w = a; w; w = w->next){
        n = strlen(w->s);
        if(strncmp(s, w->s, n) == 0)
            break;
    }
    if(a && w == 0)		/*  a == NULL matches everything*/
        return 0;

    *enda = s+n;		/* pointer to end a A part match */
    *nmid = strlen(s)-n;	/* size of remainder of source */
    end = *enda+*nmid;
    for(w = b; w; w = w->next){
        n = strlen(w->s);
        if(strcmp(w->s, end-n) == 0){
            *nmid -= n;
            break;
        }
    }
    if(b && w == 0)		/* b == NULL matches everything */
        return 0;
    return 1;
}
@


\section{Quotation}
% aka escaping


<<function squote>>=
/*
 *	skip a token in single quotes.
 */
static char *
squote(char *cp)
{
    Rune r;
    int n;

    while(*cp){
        n = chartorune(&r, cp);
        if(r == '\'') {
            n += chartorune(&r, cp+n);
            if(r != '\'')
                return(cp);
        }
        cp += n;
    }
    SYNERR(-1);		/* should never occur */
    fprint(2, "missing closing '\n");
    return 0;
}
@

<<function charin>>=
/*
 *	search a string for characters in a pattern set
 *	characters in quotes and variable generators are escaped
 */
char *
charin(char *cp, char *pat)
{
    Rune r;
    int n, vargen;

    vargen = 0;
    while(*cp){
        n = chartorune(&r, cp);
        switch(r){
        case '\'':			/* skip quoted string */
            cp = squote(cp+1);	/* n must = 1 */
            if(!cp)
                return 0;
            break;
        case '$':
            if(*(cp+1) == '{')
                vargen = 1;
            break;
        case '}':
            if(vargen)
                vargen = 0;
            else if(utfrune(pat, r))
                return cp;
            break;
        default:
            if(vargen == 0 && utfrune(pat, r))
                return cp;
            break;
        }
        cp += n;
    }
    if(vargen){
        SYNERR(-1);
        fprint(2, "missing closing } in pattern generator\n");
    }
    return 0;
}
@
%$ 

<<function expandquote>>=
/*
 *	extract an escaped token.  Possible escape chars are single-quote,
 *	double-quote,and backslash.  Only the first is valid for rc. the
 *	others are just inserted into the receiving buffer.
 */
char*
expandquote(char *s, Rune r, Bufblock *b)
{
    if (r != '\'') {
        rinsert(b, r);
        return s;
    }

    while(*s){
        s += chartorune(&r, s);
        if(r == '\'') {
            if(*s == '\'')
                s++;
            else
                return s;
        }
        rinsert(b, r);
    }
    return 0;
}
@

<<function escapetoken>>=
/*
 *	Input an escaped token.  Possible escape chars are single-quote,
 *	double-quote and backslash.  Only the first is a valid escape for
 *	rc; the others are just inserted into the receiving buffer.
 */
int
escapetoken(Biobuf *bp, Bufblock *buf, int preserve, int esc)
{
    int c, line;

    if(esc != '\'')
        return 1;

    line = mkinline;
    while((c = nextrune(bp, 0)) > 0){
        if(c == '\''){
            if(preserve)
                rinsert(buf, c);
            c = Bgetrune(bp);
            if (c < 0)
                break;
            if(c != '\''){
                Bungetrune(bp);
                return 1;
            }
        }
        rinsert(buf, c);
    }
    SYNERR(line); fprint(2, "missing closing %c\n", esc);
    return 0;
}
@

<<function copysingle>>=
/*
 *	copy a single-quoted string; s points to char after opening quote
 */
static char *
copysingle(char *s, Bufblock *buf)
{
    Rune r;

    while(*s){
        s += chartorune(&r, s);
        rinsert(buf, r);
        if(r == '\'')
            break;
    }
    return s;
}
@

<<function copyq>>=
/*
 *	check for quoted strings.  backquotes are handled here; single quotes above.
 *	s points to char after opening quote, q.
 */
char *
copyq(char *s, Rune q, Bufblock *buf)
{
    if(q == '\'')				/* copy quoted string */
        return copysingle(s, buf);

    if(q != '`')				/* not quoted */
        return s;

    while(*s){				/* copy backquoted string */
        s += chartorune(&q, s);
        rinsert(buf, q);
        if(q == '}')
            break;
        if(q == '\'')
            s = copysingle(s, buf);	/* copy quoted string */
    }
    return s;
}
@


\section{The recipe}

<<function dorecipe>>=
int
dorecipe(Node *node)
{
    int did = 0;
    char buf[BIGBLOCK], cwd[256];
    Arc *a, *aa;
    Node *n;
    Rule *r = 0;
    Symtab *s;
    Word head, ahead, lp, ln, *w, *ww, *aw;

    aa = 0;
    /*
        pick up the rule
    */
    for(a = node->prereqs; a; a = a->next)
        if(*a->r->recipe)
            r = (aa = a)->r;
    /*
        no recipe? go to buggery!
    */
    if(r == 0){
        if(!(node->flags&VIRTUAL) && !(node->flags&NORECIPE)){
            if(getwd(cwd, sizeof cwd))
                fprint(2, "mk: no recipe to make '%s' in directory %s\n", node->name, cwd);
            else
                fprint(2, "mk: no recipe to make '%s'\n", node->name);
            Exit();
        }
        if(strchr(node->name, '(') && node->time == 0)
            MADESET(node, MADE);
        else
            update(0, node);
        if(tflag){
            if(!(node->flags&VIRTUAL))
                touch(node->name);
            else if(explain)
                Bprint(&bout, "no touch of virtual '%s'\n", node->name);
        }
        return(did);
    }
    /*
        build the node list
    */
    node->next = 0;
    head.next = 0;
    ww = &head;
    ahead.next = 0;
    aw = &ahead;
    if(r->attr&REGEXP){
        ww->next = newword(node->name);
        aw->next = newword(node->name);
    } else {
        for(w = r->alltargets; w; w = w->next){
            if(r->attr&META)
                subst(aa->stem, w->s, buf, sizeof(buf));
            else
                strecpy(buf, buf + sizeof buf - 1, w->s);
            aw->next = newword(buf);
            aw = aw->next;
            if((s = symlook(buf, S_NODE, 0)) == 0)
                continue;	/* not a node we are interested in */
            n = s->u.ptr;
            if(aflag == 0 && n->time) {
                for(a = n->prereqs; a; a = a->next)
                    if(a->n && outofdate(n, a, 0))
                        break;
                if(a == 0)
                    continue;
            }
            ww->next = newword(buf);
            ww = ww->next;
            if(n == node) continue;
            n->next = node->next;
            node->next = n;
        }
    }
    for(n = node; n; n = n->next)
        if((n->flags&READY) == 0)
            return(did);
    /*
        gather the params for the job
    */
    lp.next = ln.next = 0;
    for(n = node; n; n = n->next){
        for(a = n->prereqs; a; a = a->next){
            if(a->n){
                addw(&lp, a->n->name);
                if(outofdate(n, a, 0)){
                    addw(&ln, a->n->name);
                    if(explain)
                        fprint(1, "%s(%ld) < %s(%ld)\n",
                            n->name, n->time, a->n->name, a->n->time);
                }
            } else {
                if(explain)
                    fprint(1, "%s has no prerequisites\n",
                            n->name);
            }
        }
        MADESET(n, BEINGMADE);
    }
/*	print("lt=%s ln=%s lp=%s\n",wtos(head.next, ' '),wtos(ln.next, ' '),wtos(lp.next, ' '));/**/
    run(newjob(r, node, aa->stem, aa->match, lp.next, ln.next, head.next, ahead.next));
    return(1);
}
@

<<function addw>>=
void
addw(Word *w, char *s)
{
    Word *lw;

    for(lw = w; w = w->next; lw = w){
        if(strcmp(s, w->s) == 0)
            return;
    }
    lw->next = newword(s);
}
@



\chapter{Jobs}
% can do stuff in //! make originally didn't apparently


<<constructor newjob>>=
Job *
newjob(Rule *r, Node *nlist, char *stem, char **match, Word *pre, Word *npre, Word *tar, Word *atar)
{
    register Job *j;

    j = (Job *)Malloc(sizeof(Job));
    j->r = r;
    j->n = nlist;
    j->stem = stem;
    j->match = match;
    j->p = pre;
    j->np = npre;
    j->t = tar;
    j->at = atar;
    j->nproc = -1;
    j->next = 0;
    return(j);
}
@



<<struct RunEvent>>=
typedef struct RunEvent
{
    int pid;
    Job *job;
} RunEvent;
@

<<global events>>=
static RunEvent *events;
@

<<struct Process>>=
typedef struct Process
{
    int pid;
    int status;
    struct Process *b, *f;
} Process;
@

<<global phead>>=
static Process *phead;
@

<<global pfree>>=
static Process *pfree;
@

<<function run>>=
void
run(Job *j)
{
    Job *jj;

    if(jobs){
        for(jj = jobs; jj->next; jj = jj->next)
            ;
        jj->next = j;
    } else 
        jobs = j;
    j->next = 0;
    /* this code also in waitup after parse redirect */
    if(nrunning < nproclimit)
        sched();
}
@

\section{Scheduling}

<<function sched>>=
static void
sched(void)
{
    char *flags;
    Job *j;
    Bufblock *buf;
    int slot;
    Node *n;
    Envy *e;

    if(jobs == 0){
        usage();
        return;
    }
    j = jobs;
    jobs = j->next;
    if(DEBUG(D_EXEC))
        fprint(1, "firing up job for target %s\n", wtos(j->t, ' '));
    slot = nextslot();
    events[slot].job = j;
    buf = newbuf();
    e = buildenv(j, slot);
    shprint(j->r->recipe, e, buf);
    if(!tflag && (nflag || !(j->r->attr&QUIET)))
        Bwrite(&bout, buf->start, (long)strlen(buf->start));
    freebuf(buf);
    if(nflag||tflag){
        for(n = j->n; n; n = n->next){
            if(tflag){
                if(!(n->flags&VIRTUAL))
                    touch(n->name);
                else if(explain)
                    Bprint(&bout, "no touch of virtual '%s'\n", n->name);
            }
            n->time = time((long *)0);
            MADESET(n, MADE);
        }
    } else {
        if(DEBUG(D_EXEC))
            fprint(1, "recipe='%s'\n", j->r->recipe);	/**/
        Bflush(&bout);
        if(j->r->attr&NOMINUSE)
            flags = 0;
        else
            flags = "-e";
        events[slot].pid = execsh(flags, j->r->recipe, 0, e);
        usage();
        nrunning++;
        if(DEBUG(D_EXEC))
            fprint(1, "pid for target %s = %d\n", wtos(j->t, ' '), events[slot].pid);
    }
}
@


<<function waitup>>=
int
waitup(int echildok, int *retstatus)
{
    Envy *e;
    int pid;
    int slot;
    Symtab *s;
    Word *w;
    Job *j;
    char buf[ERRMAX];
    Bufblock *bp;
    int uarg = 0;
    int done;
    Node *n;
    Process *p;
    extern int runerrs;

    /* first check against the proces slist */
    if(retstatus)
        for(p = phead; p; p = p->f)
            if(p->pid == *retstatus){
                *retstatus = p->status;
                pdelete(p);
                return(-1);
            }
again:		/* rogue processes */
    pid = waitfor(buf);
    if(pid == -1){
        if(echildok > 0)
            return(1);
        else {
            fprint(2, "mk: (waitup %d) ", echildok);
            perror("mk wait");
            Exit();
        }
    }
    if(DEBUG(D_EXEC))
        fprint(1, "waitup got pid=%d, status='%s'\n", pid, buf);
    if(retstatus && pid == *retstatus){
        *retstatus = buf[0]? 1:0;
        return(-1);
    }
    slot = pidslot(pid);
    if(slot < 0){
        if(DEBUG(D_EXEC))
            fprint(2, "mk: wait returned unexpected process %d\n", pid);
        pnew(pid, buf[0]? 1:0);
        goto again;
    }
    j = events[slot].job;
    usage();
    nrunning--;
    events[slot].pid = -1;
    if(buf[0]){
        e = buildenv(j, slot);
        bp = newbuf();
        shprint(j->r->recipe, e, bp);
        front(bp->start);
        fprint(2, "mk: %s: exit status=%s", bp->start, buf);
        freebuf(bp);
        for(n = j->n, done = 0; n; n = n->next)
            if(n->flags&DELETE){
                if(done++ == 0)
                    fprint(2, ", deleting");
                fprint(2, " '%s'", n->name);
                delete(n->name);
            }
        fprint(2, "\n");
        if(kflag){
            runerrs++;
            uarg = 1;
        } else {
            jobs = 0;
            Exit();
        }
    }
    for(w = j->t; w; w = w->next){
        if((s = symlook(w->s, S_NODE, 0)) == 0)
            continue;	/* not interested in this node */
        update(uarg, s->u.ptr);
    }
    if(nrunning < nproclimit)
        sched();
    return(0);
}
@

\section{Parallel processing}

<<function nproc>>=
void
nproc(void)
{
    Symtab *sym;
    Word *w;

    if(sym = symlook("NPROC", S_VAR, 0)) {
        w = sym->u.ptr;
        if (w && w->s && w->s[0])
            nproclimit = atoi(w->s);
    }
    if(nproclimit < 1)
        nproclimit = 1;
    if(DEBUG(D_EXEC))
        fprint(1, "nprocs = %d\n", nproclimit);
    if(nproclimit > nevents){
        if(nevents)
            events = (RunEvent *)Realloc((char *)events, nproclimit*sizeof(RunEvent));
        else
            events = (RunEvent *)Malloc(nproclimit*sizeof(RunEvent));
        while(nevents < nproclimit)
            events[nevents++].pid = 0;
    }
}
@

<<function nextslot>>=
int
nextslot(void)
{
    int i;

    for(i = 0; i < nproclimit; i++)
        if(events[i].pid <= 0) return i;
    assert(/*out of slots!!*/ 0);
    return 0;	/* cyntax */
}
@

<<function pidslot>>=
int
pidslot(int pid)
{
    int i;

    for(i = 0; i < nevents; i++)
        if(events[i].pid == pid) return(i);
    if(DEBUG(D_EXEC))
        fprint(2, "mk: wait returned unexpected process %d\n", pid);
    return(-1);
}
@

<<function pnew>>=
static void
pnew(int pid, int status)
{
    Process *p;

    if(pfree){
        p = pfree;
        pfree = p->f;
    } else
        p = (Process *)Malloc(sizeof(Process));
    p->pid = pid;
    p->status = status;
    p->f = phead;
    phead = p;
    if(p->f)
        p->f->b = p;
    p->b = 0;
}
@

<<function pdelete>>=
static void
pdelete(Process *p)
{
    if(p->f)
        p->f->b = p->b;
    if(p->b)
        p->b->f = p->f;
    else
        phead = p->f;
    p->f = pfree;
    pfree = p;
}
@

<<function killchildren>>=
void
killchildren(char *msg)
{
    Process *p;

    kflag = 1;	/* to make sure waitup doesn't exit */
    jobs = 0;	/* make sure no more get scheduled */
    for(p = phead; p; p = p->f)
        expunge(p->pid, msg);
    while(waitup(1, (int *)0) == 0)
        ;
    Bprint(&bout, "mk: %s\n", msg);
    Exit();
}
@



\chapter{[[mk()]]}

<<global runerrs>>=
int runerrs;
@

<<function mk>>=
void
mk(char *target)
{
    Node *node;
    int did = 0;

    nproc();		/* it can be updated dynamically */
    nrep();			/* it can be updated dynamically */
    runerrs = 0;
    node = graph(target);
    if(DEBUG(D_GRAPH)){
        dumpn("new target\n", node);
        Bflush(&bout);
    }
    clrmade(node);
    while(node->flags&NOTMADE){
        if(work(node, (Node *)0, (Arc *)0))
            did = 1;	/* found something to do */
        else {
            if(waitup(1, (int *)0) > 0){
                if(node->flags&(NOTMADE|BEINGMADE)){
                    assert(/*must be run errors*/ runerrs);
                    break;	/* nothing more waiting */
                }
            }
        }
    }
    if(node->flags&BEINGMADE)
        waitup(-1, (int *)0);
    while(jobs)
        waitup(-2, (int *)0);
    assert(/*target didnt get done*/ runerrs || (node->flags&MADE));
    if(did == 0)
        Bprint(&bout, "mk: '%s' is up to date\n", node->name);
}
@


<<function clrmade>>=
void
clrmade(Node *n)
{
    Arc *a;

    n->flags &= ~(CANPRETEND|PRETENDING);
    if(strchr(n->name, '(') ==0 || n->time)
        n->flags |= CANPRETEND;
    MADESET(n, NOTMADE);
    for(a = n->prereqs; a; a = a->next)
        if(a->n)
            clrmade(a->n);
}
@

<<function unpretend>>=
static void
unpretend(Node *n)
{
    MADESET(n, NOTMADE);
    n->flags &= ~(CANPRETEND|PRETENDING);
    n->time = 0;
}
@



<<function work>>=
int
work(Node *node, Node *p, Arc *parc)
{
    Arc *a, *ra;
    int weoutofdate;
    int ready;
    int did = 0;
    char cwd[256];

    /*print("work(%s) flags=0x%x time=%lud\n", node->name, node->flags, node->time);/**/
    if(node->flags&BEINGMADE)
        return(did);
    if((node->flags&MADE) && (node->flags&PRETENDING) && p && outofdate(p, parc, 0)){
        if(explain)
            fprint(1, "unpretending %s(%lud) because %s is out of date(%lud)\n",
                node->name, node->time, p->name, p->time);
        unpretend(node);
    }
    /*
        have a look if we are pretending in case
        someone has been unpretended out from underneath us
    */
    if(node->flags&MADE){
        if(node->flags&PRETENDING){
            node->time = 0;
        }else
            return(did);
    }
    /* consider no prerequisite case */
    if(node->prereqs == 0){
        if(node->time == 0){
            if(getwd(cwd, sizeof cwd))
                fprint(2, "mk: don't know how to make '%s' in directory %s\n", node->name, cwd);
            else
                fprint(2, "mk: don't know how to make '%s'\n", node->name);
            if(kflag){
                node->flags |= BEINGMADE;
                runerrs++;
            } else
                Exit();
        } else
            MADESET(node, MADE);
        return(did);
    }
    /*
        now see if we are out of date or what
    */
    ready = 1;
    weoutofdate = aflag;
    ra = 0;
    for(a = node->prereqs; a; a = a->next)
        if(a->n){
            did = work(a->n, node, a) || did;
            if(a->n->flags&(NOTMADE|BEINGMADE))
                ready = 0;
            if(outofdate(node, a, 0)){
                weoutofdate = 1;
                if((ra == 0) || (ra->n == 0)
                        || (ra->n->time < a->n->time))
                    ra = a;
            }
        } else {
            if(node->time == 0){
                if(ra == 0)
                    ra = a;
                weoutofdate = 1;
            }
        }
    if(ready == 0)	/* can't do anything now */
        return(did);
    if(weoutofdate == 0){
        MADESET(node, MADE);
        return(did);
    }
    /*
        can we pretend to be made?
    */
    if((iflag == 0) && (node->time == 0) && (node->flags&(PRETENDING|CANPRETEND))
            && p && ra->n && !outofdate(p, ra, 0)){
        node->flags &= ~CANPRETEND;
        MADESET(node, MADE);
        if(explain && ((node->flags&PRETENDING) == 0))
            fprint(1, "pretending %s has time %lud\n", node->name, node->time);
        node->flags |= PRETENDING;
        return(did);
    }
    /*
        node is out of date and we REALLY do have to do something.
        quickly rescan for pretenders
    */
    for(a = node->prereqs; a; a = a->next)
        if(a->n && (a->n->flags&PRETENDING)){
            if(explain)
                Bprint(&bout, "unpretending %s because of %s because of %s\n",
                a->n->name, node->name, ra->n? ra->n->name : "rule with no prerequisites");

            unpretend(a->n);
            did = work(a->n, node, a) || did;
            ready = 0;
        }
    if(ready == 0)	/* try later unless nothing has happened for -k's sake */
        return(did || work(node, p, parc));
    did = dorecipe(node) || did;
    return(did);
}
@

<<function update>>=
void
update(int fake, Node *node)
{
    Arc *a;

    MADESET(node, fake? BEINGMADE : MADE);
    if(((node->flags&VIRTUAL) == 0) && (access(node->name, 0) == 0)){
        node->time = timeof(node->name, 1);
        node->flags &= ~(CANPRETEND|PRETENDING);
        for(a = node->prereqs; a; a = a->next)
            if(a->prog)
                outofdate(node, a, 1);
    } else {
        node->time = 1;
        for(a = node->prereqs; a; a = a->next)
            if(a->n && outofdate(node, a, 1))
                node->time = a->n->time;
    }
/*	print("----node %s time=%lud flags=0x%x\n", node->name, node->time, node->flags);/**/
}
@

<<function pcmp>>=
static int
pcmp(char *prog, char *p, char *q)
{
    char buf[3*NAMEBLOCK];
    int pid;

    Bflush(&bout);
    snprint(buf, sizeof buf, "%s '%s' '%s'\n", prog, p, q);
    pid = pipecmd(buf, 0, 0);
    while(waitup(-3, &pid) >= 0)
        ;
    return(pid? 2:1);
}
@

<<function outofdate>>=
int
outofdate(Node *node, Arc *arc, int eval)
{
    char buf[3*NAMEBLOCK], *str;
    Symtab *sym;
    int ret;

    str = 0;
    if(arc->prog){
        snprint(buf, sizeof buf, "%s%c%s", node->name, 0377,
            arc->n->name);
        sym = symlook(buf, S_OUTOFDATE, 0);
        if(sym == 0 || eval){
            if(sym == 0)
                str = strdup(buf);
            ret = pcmp(arc->prog, node->name, arc->n->name);
            if(sym)
                sym->u.value = ret;
            else
                symlook(str, S_OUTOFDATE, (void *)ret);
        } else
            ret = sym->u.value;
        return(ret-1);
    } else if(strchr(arc->n->name, '(') && arc->n->time == 0)  /* missing archive member */
        return 1;
    else
        /*
         * Treat equal times as out-of-date.
         * It's a race, and the safer option is to do
         * extra building rather than not enough.
       */
        return node->time <= arc->n->time;
}
@

\chapter{[[main()]]}


<<function main>>=
void
main(int argc, char **argv)
{
    Word *w;
    char *s, *temp;
    char *files[256], **f = files, **ff;
    int sflag = 0;
    int i;
    int tfd = -1;
    Biobuf tb;
    Bufblock *buf;
    Bufblock *whatif;

    /*
     *  start with a copy of the current environment variables
     *  instead of sharing them
     */

    Binit(&bout, 1, OWRITE);
    buf = newbuf();
    whatif = 0;
    USED(argc);
    for(argv++; *argv && (**argv == '-'); argv++)
    {
        bufcpy(buf, argv[0], strlen(argv[0]));
        insert(buf, ' ');
        switch(argv[0][1])
        {
        case 'a':
            aflag = 1;
            break;
        case 'd':
            if(*(s = &argv[0][2]))
                while(*s) switch(*s++)
                {
                case 'p':	debug |= D_PARSE; break;
                case 'g':	debug |= D_GRAPH; break;
                case 'e':	debug |= D_EXEC; break;
                }
            else
                debug = 0xFFFF;
            break;
        case 'e':
            explain = &argv[0][2];
            break;
        case 'f':
            if(*++argv == 0)
                badusage();
            *f++ = *argv;
            bufcpy(buf, argv[0], strlen(argv[0]));
            insert(buf, ' ');
            break;
        case 'i':
            iflag = 1;
            break;
        case 'k':
            kflag = 1;
            break;
        case 'n':
            nflag = 1;
            break;
        case 's':
            sflag = 1;
            break;
        case 't':
            tflag = 1;
            break;
        case 'u':
            uflag = 1;
            break;
        case 'w':
            if(whatif == 0)
                whatif = newbuf();
            else
                insert(whatif, ' ');
            if(argv[0][2])
                bufcpy(whatif, &argv[0][2], strlen(&argv[0][2]));
            else {
                if(*++argv == 0)
                    badusage();
                bufcpy(whatif, &argv[0][0], strlen(&argv[0][0]));
            }
            break;
        default:
            badusage();
        }
    }
    <<main profiling>>

    if(aflag)
        iflag = 1;
    usage();
    syminit();
    initenv();
    usage();

    /*
        assignment args become null strings
    */
    temp = 0;
    for(i = 0; argv[i]; i++) if(utfrune(argv[i], '=')){
        bufcpy(buf, argv[i], strlen(argv[i]));
        insert(buf, ' ');
        if(tfd < 0){
            temp = maketmp();
            if(temp == 0) {
                perror("temp file");
                Exit();
            }
            if((tfd = create(temp, ORDWR, 0600)) < 0){
                perror(temp);
                Exit();
            }
            Binit(&tb, tfd, OWRITE);
        }
        Bprint(&tb, "%s\n", argv[i]);
        *argv[i] = 0;
    }
    if(tfd >= 0){
        Bflush(&tb);
        LSEEK(tfd, 0L, 0);
        parse("command line args", tfd, 1);
        remove(temp);
    }

    if (buf->current != buf->start) {
        buf->current--;
        insert(buf, 0);
    }
    symlook("MKFLAGS", S_VAR, (void *) stow(buf->start));
    buf->current = buf->start;
    for(i = 0; argv[i]; i++){
        if(*argv[i] == 0) continue;
        if(i)
            insert(buf, ' ');
        bufcpy(buf, argv[i], strlen(argv[i]));
    }
    insert(buf, 0);
    symlook("MKARGS", S_VAR, (void *) stow(buf->start));
    freebuf(buf);

    if(f == files){
        if(access(MKFILE, 4) == 0)
            parse(MKFILE, open(MKFILE, 0), 0);
    } else
        for(ff = files; ff < f; ff++)
            parse(*ff, open(*ff, 0), 0);

    if(DEBUG(D_PARSE)){
        dumpw("default targets", target1);
        dumpr("rules", rules);
        dumpr("metarules", metarules);
        dumpv("variables");
    }

    if(whatif){
        insert(whatif, 0);
        timeinit(whatif->start);
        freebuf(whatif);
    }

    execinit();
    /* skip assignment args */
    while(*argv && (**argv == 0))
        argv++;

    catchnotes();
    if(*argv == 0){
        if(target1)
            for(w = target1; w; w = w->next)
                mk(w->s);
        else {
            fprint(2, "mk: nothing to mk\n");
            Exit();
        }
    } else {
        if(sflag){
            for(; *argv; argv++)
                if(**argv)
                    mk(*argv);
        } else {
            Word *head, *tail, *t;

            /* fake a new rule with all the args as prereqs */
            tail = 0;
            t = 0;
            for(; *argv; argv++)
                if(**argv){
                    if(tail == 0)
                        tail = t = newword(*argv);
                    else {
                        t->next = newword(*argv);
                        t = t->next;
                    }
                }
            if(tail->next == 0)
                mk(tail->s);
            else {
                head = newword("command line arguments");
                addrules(head, tail, strdup(""), VIR, mkinline, 0);
                mk(head->s);
            }
        }
    }
    if(uflag)
        prusage();

    exits(0);
}
@


\chapter{Extra commands}
% see also Debugging section

\section{Recompile everything, [[mk -a]]}

<<global aflag>>=
int aflag = 0;
@

\section{What if, [[mk -w]]}

\section{Touching, [[mk -t]]}

<<global tflag>>=
int tflag = 0;
@

\chapter{Advanced Topics}

\section{Pattern rules}

<<global patrule>>=
Rule *patrule;
@

\section{Multiple targets}

\section{Aggregates}
% for archives

\section{Missing intermediates}


\chapter{Conclusion}

\appendix

\chapter{Debugging}

\section{Dumping internals, [[mk -d]]}
%mk -d[epg]

% -d flag
<<global debug>>=
int debug;
@

<<function DEBUG>>=
#define	DEBUG(x)	(debug&(x))
@

<<constant D_PARSE>>=
#define		D_PARSE		0x01
@

<<constant D_GRAPH>>=
#define		D_GRAPH		0x02
@

<<constant D_EXEC>>=
#define		D_EXEC		0x04
@


<<dumper dumpw>>=
void
dumpw(char *s, Word *w)
{
    Bprint(&bout, "%s", s);
    for(; w; w = w->next)
        Bprint(&bout, " '%s'", w->s);
    Bputc(&bout, '\n');
}
@

<<dumper dumpv>>=
void
dumpv(char *s)
{
    Bprint(&bout, "%s:\n", s);
    symtraverse(S_VAR, print1);
}
@

<<function symstat>>=
void
symstat(void)
{
    Symtab **s, *ss;
    int n;
    int l[1000];

    memset((char *)l, 0, sizeof(l));
    for(s = hash; s < &hash[NHASH]; s++){
        for(ss = *s, n = 0; ss; ss = ss->next)
            n++;
        l[n]++;
    }
    for(n = 0; n < 1000; n++)
        if(l[n]) Bprint(&bout, "%d of length %d\n", l[n], n);
}
@



<<function print1>>=
static void
print1(Symtab *s)
{
    Word *w;

    Bprint(&bout, "\t%s=", s->name);
    for (w = s->u.ptr; w; w = w->next)
        Bprint(&bout, "'%s'", w->s);
    Bprint(&bout, "\n");
}
@


<<dumper dumpr>>=
void
dumpr(char *s, Rule *r)
{
    Bprint(&bout, "%s: start=%p\n", s, r);
    for(; r; r = r->next){
        Bprint(&bout, "\tRule %p: %s:%d attr=%x next=%p chain=%p alltarget='%s'",
            r, r->file, r->line, r->attr, r->next, r->chain, wtos(r->alltargets, ' '));
        if(r->prog)
            Bprint(&bout, " prog='%s'", r->prog);
        Bprint(&bout, "\n\ttarget=%s: %s\n", r->target, wtos(r->tail,' '));
        Bprint(&bout, "\trecipe@%p='%s'\n", r->recipe, r->recipe);
    }
}
@




<<dumper dumpn>>=
void
dumpn(char *s, Node *n)
{
    char buf[1024];
    Arc *a;

    Bprint(&bout, "%s%s@%p: time=%ld flags=0x%x next=%p\n",
        s, n->name, n, n->time, n->flags, n->next);
    for(a = n->prereqs; a; a = a->next){
        snprint(buf, sizeof buf, "%s   ", (*s == ' ')? s:"");
        dumpa(buf, a);
    }
}
@

<<dumper dumpa>>=
void
dumpa(char *s, Arc *a)
{
    char buf[1024];

    Bprint(&bout, "%sArc@%p: n=%p r=%p flag=0x%x stem='%s'",
        s, a, a->n, a->r, a->flag, a->stem);
    if(a->prog)
        Bprint(&bout, " prog='%s'", a->prog);
    Bprint(&bout, "\n");

    if(a->n){
        snprint(buf, sizeof(buf), "%s    ", (*s == ' ')? s:"");
        dumpn(buf, a->n);
    }
}
@


<<dumper dumpj>>=
void
dumpj(char *s, Job *j, int all)
{
    Bprint(&bout, "%s\n", s);
    while(j){
        Bprint(&bout, "job@%p: r=%p n=%p stem='%s' nproc=%d\n",
            j, j->r, j->n, j->stem, j->nproc);
        Bprint(&bout, "\ttarget='%s' alltarget='%s' prereq='%s' nprereq='%s'\n",
            wtos(j->t, ' '), wtos(j->at, ' '), wtos(j->p, ' '), wtos(j->np, ' '));
        j = all? j->next : 0;
    }
}
@


\section{Explain mode, [[mk -e]]}

<<global explain>>=
char *explain = 0;
@

\section{Dry mode, [[mk -n]]}

% just print recipe, do not execute them
<<global nflag>>=
int nflag = 0;
@

\chapter{Profiling}

\section{Profiling mk}

<<global buf>>=
short buf[10000];
@

<<main profiling>>=
#ifdef	PROF
    {
        extern int etext();
        monitor(main, etext, buf, sizeof buf, 300);
    }
#endif
@

\section{Profiling the mkfile, [[mk -u]]}
% utlilization

<<global uflag>>=
int uflag = 0;
@

<<global tslot>>=
static ulong tslot[1000];
@

<<global tick>>=
static ulong tick;
@

<<function usage>>=
void
usage(void)
{
    ulong t;

    t = time(0);
    if(tick)
        tslot[nrunning] += t - tick;
    tick = t;
}
@

<<function prusage>>=
void
prusage(void)
{
    int i;

    usage();
    for(i = 0; i <= nevents; i++)
        fprint(1, "%d: %lud\n", i, tslot[i]);
}
@


\chapter{Error Managment}

<<function Malloc>>=
void *
Malloc(int n)
{
    register void *s;

    s = malloc(n);
    if(!s) {
        fprint(2, "mk: cannot alloc %d bytes\n", n);
        Exit();
    }
    return(s);
}
@

<<function Realloc>>=
void *
Realloc(void *s, int n)
{
    if(s)
        s = realloc(s, n);
    else
        s = malloc(n);
    if(!s) {
        fprint(2, "mk: cannot alloc %d bytes\n", n);
        Exit();
    }
    return(s);
}
@

<<function Exit>>=
void
Exit(void)
{
    while(waitpid() >= 0)
        ;
    exits("error");
}
@


\chapter{Libc}

\section{Buffer managment}

<<struct Bufblock>>=
typedef struct Bufblock
{
    char 		*start;
    char 		*end;
    char 		*current;

    // Extra
    struct Bufblock *next;
} Bufblock;
@

<<global freelist>>=
static Bufblock *freelist;
@



<<constant QUANTA>>=
#define	QUANTA	4096
@

<<constructor newbuf>>=
Bufblock *
newbuf(void)
{
    Bufblock *p;

    if (freelist) {
        p = freelist;
        freelist = freelist->next;
    } else {
        p = (Bufblock *) Malloc(sizeof(Bufblock));
        p->start = Malloc(QUANTA*sizeof(*p->start));
        p->end = p->start+QUANTA;
    }
    p->current = p->start;
    *p->start = 0;
    p->next = 0;
    return p;
}
@

<<destructor freebuf>>=
void
freebuf(Bufblock *p)
{
    p->next = freelist;
    freelist = p;
}
@

<<function growbuf>>=
void
growbuf(Bufblock *p)
{
    int n;
    Bufblock *f;
    char *cp;

    n = p->end-p->start+QUANTA;
        /* search the free list for a big buffer */
    for (f = freelist; f; f = f->next) {
        if (f->end-f->start >= n) {
            memcpy(f->start, p->start, p->end-p->start);
            cp = f->start;
            f->start = p->start;
            p->start = cp;
            cp = f->end;
            f->end = p->end;
            p->end = cp;
            f->current = f->start;
            break;
        }
    }
    if (!f) {		/* not found - grow it */
        p->start = Realloc(p->start, n);
        p->end = p->start+n;
    }
    p->current = p->start+n-QUANTA;
}
@

<<function bufcpy>>=
void
bufcpy(Bufblock *buf, char *cp, int n)
{

    while (n--)
        insert(buf, *cp++);
}
@

<<function insert>>=
void
insert(Bufblock *buf, int c)
{

    if (buf->current >= buf->end)
        growbuf(buf);
    *buf->current++ = c;
}
@

<<function rinsert>>=
void
rinsert(Bufblock *buf, Rune r)
{
    int n;

    n = runelen(r);
    if (buf->current+n > buf->end)
        growbuf(buf);
    runetochar(buf->current, &r);
    buf->current += n;
}
@

\chapter{Extra Code}

\ifallcode
#include "Make_extra.tex.nw"
\fi

\chapter{Changelog}
\label{sec:changelog}

\chapter{Glossary}
\label{sec:glossary}

\begin{verbatim}
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{section}{Index}

%\chapter{References} 
\addcontentsline{toc}{section}{References}

\begin{thebibliography}{99}

\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming}, 
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb}, 
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison}, 
\url{http://padator.org/software/project-syncweb/readme.txt}

\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
