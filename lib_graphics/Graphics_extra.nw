%TODO: to lpize

<<lib_graphics/libdraw/enter.c>>=
@
<<lib_graphics/libdraw/eenter.c>>=
@

\section{[[include/]]}

\subsection{[[include/graphics/draw.h]]}
%pad: I reorganized a lot this file. It was huge before.
% I moved stuff in a new font.h, window.h, marshal.h, and draw_private.h

<<enum [[constants1]]>>=
enum
{
    <<constant [[ICOSSCALE]]>>
    <<constant [[Borderwidth]]>>
};
@
\t make #define and move ICOSSCALE to private

%dead: Displaybufsize	= 8000,
%dead: #define	NOREFRESH	((void*)-1)
%dead: extern Font*	mkfont(Subfont*, Rune);
%dead: extern	ulong	setalpha(ulong, byte); // (used only in mahjongg)
%dead: extern Point	stringsubfont(Image*, Point, Image*, Subfont*, char*);
%dead: extern Subfont*	readsubfonti(Display*, char*, int, Image*, int);
%typedef void	(*Reffn)(Image*, Rectangle, void*);


%-------------------------------------------------------------

<<include/graphics/draw.h>>=
#pragma src "/sys/src/libdraw"
#pragma lib "libdraw.a"

typedef struct	Point Point;
typedef struct	Rectangle Rectangle;
typedef struct	Display Display;
typedef struct	Image Image;
typedef struct	Font Font;
typedef struct	RGB RGB;

// defined in other header files
typedef struct	Screen Screen;
typedef struct	Cachefont Cachefont;
typedef struct	Cacheinfo Cacheinfo;
typedef struct	Cachesubf Cachesubf;
typedef struct	Subfont Subfont;
#pragma incomplete Screen
#pragma incomplete Cachefont
#pragma incomplete Cacheinfo
#pragma incomplete Cachesubf
#pragma incomplete Subfont

// temporary hack, because does not have a memfont.h so need to
// disable safe-linking for Fontchar everywhere
typedef struct	Fontchar Fontchar;
#pragma incomplete Fontchar

// TODO why need that?
typedef struct	Mouse Mouse;
#pragma incomplete Mouse

//----------------------------------------------------------------------------
// Data structures and constants
//----------------------------------------------------------------------------

<<struct [[Point]]>>

<<struct [[Rectangle]]>>


<<enum [[Colors]]>>
<<type [[rgba]]>>

<<struct [[RGB]]>>


<<enum [[ImageChan]]>>
<<function [[__DC]]>>
<<function [[CHAN1]]>>
<<function [[CHAN2]]>>
<<function [[CHAN3]]>>
<<function [[CHAN4]]>>
<<function [[NBITS]]>>
<<function [[TYPE]]>>
<<enum [[ImageType]]>>
<<type [[channels]]>>


<<type [[Errorfn]]>>

<<struct [[Display]]>>

<<struct [[Image]]>>

<<struct [[Font]]>>



<<enum [[constants1]]>>

<<enum [[drawop]]>>
typedef enum drawop Drawop;

<<enum [[Refresh]]>>

<<enum [[Endline]]>>

<<function [[ARROW]]>>

//----------------------------------------------------------------------------
// Globals
//----------------------------------------------------------------------------

/*
 * Set up by initdraw()
 */
extern	Display	*display;
extern	Image	*view; // was called 'screen' before
extern	Font	*font;

/*
 * Predefined 
 */
extern	Point		ZP;
extern	Rectangle	ZR;

//----------------------------------------------------------------------------
// Functions
//----------------------------------------------------------------------------

//
// Display
//
// This sets the following globals: display, view, font (and screen).
extern int	initdraw(Errorfn, char*, char*);
extern int	geninitdraw(char*, Errorfn, char*, char*, char*, int);
// to call after a resize event
extern int	getwindow(Display*, int);

extern Display*	initdisplay(char*, char*, Errorfn);
extern void		closedisplay(Display*);

extern int		flushimage(Display*, bool);

extern void	drawerror(Display*, char*);

/*
 * Image management
 */
extern Image*	allocimage(Display*, Rectangle, channels, bool, rgba);
extern Image* 	allocimagemix(Display*, rgba, rgba);
extern int		freeimage(Image*);

extern int		loadimage(Image*, Rectangle, byte*, int);
extern int		unloadimage(Image*, Rectangle, byte*, int);
extern Image* 	readimage(Display*, fdt, bool);
extern int		writeimage(fdt, Image*, bool);
// compressed variants
extern int		cloadimage(Image*, Rectangle, byte*, int);
extern Image* 	creadimage(Display*, int, int);

extern Image*	namedimage(Display*, char*);
extern int		nameimage(Image*, char*, bool);

//
// Channels
//
extern	int		chantodepth(channels);
extern	char*	    chantostr(char*, channels);
extern	channels	strtochan(char*);

/*
 * Colors
 */
extern	void	readcolmap(Display*, RGB*);
extern	void	writecolmap(Display*, RGB*);

extern int		rgb2cmap(int, int, int);
extern int		cmap2rgb(int);
extern int		cmap2rgba(int);

/*
 * Geometry
 */
extern Point	Pt(int, int);
extern int		eqpt(Point, Point);

extern Point	addpt(Point, Point);
extern Point	subpt(Point, Point);
extern Point	divpt(Point, int);
extern Point	mulpt(Point, int);

extern Rectangle	Rect(int, int, int, int);
extern Rectangle	Rpt(Point, Point);
extern int			eqrect(Rectangle, Rectangle);

<<function [[Dx]]>>
<<function [[Dy]]>>

extern Rectangle	rectaddpt(Rectangle, Point);
extern Rectangle	rectsubpt(Rectangle, Point);
extern Rectangle	insetrect(Rectangle, int);
extern Rectangle	canonrect(Rectangle);
extern int		rectXrect(Rectangle, Rectangle);
extern int		rectinrect(Rectangle, Rectangle);
extern void		combinerect(Rectangle*, Rectangle);
extern int		ptinrect(Point, Rectangle);

extern void		icossin(int, int*, int*);
extern void		icossin2(int, int, int*, int*);

// Clipping and replication
extern void		replclipr(Image*, int, Rectangle);
extern int		rectclip(Rectangle*, Rectangle);
extern int		drawreplxy(int, int, int);	/* used to be drawsetxy */
extern Point	drawrepl(Rectangle, Point);

/*
 * Graphics
 */
extern void	draw(Image*, Rectangle, Image*, Image*, Point);
extern void	drawop(Image*, Rectangle, Image*, Image*, Point, Drawop);
extern void	gendraw(Image*, Rectangle, Image*, Point, Image*, Point);
extern void	gendrawop(Image*, Rectangle, Image*, Point, Image*, Point, Drawop);

extern void	border(Image*, Rectangle, int, Image*, Point);
extern void	borderop(Image*, Rectangle, int, Image*, Point, Drawop);

extern void	line(Image*, Point, Point, int, int, int, Image*, Point);
extern void	lineop(Image*, Point, Point, int, int, int, Image*, Point, Drawop);

extern void	poly(Image*, Point*, int, int, int, int, Image*, Point);
extern void	polyop(Image*, Point*, int, int, int, int, Image*, Point, Drawop);
extern void	fillpoly(Image*, Point*, int, int, Image*, Point);
extern void	fillpolyop(Image*, Point*, int, int, Image*, Point, Drawop);

extern void	ellipse(Image*, Point, int, int, int, Image*, Point);
extern void	ellipseop(Image*, Point, int, int, int, Image*, Point, Drawop);
extern void	fillellipse(Image*, Point, int, int, Image*, Point);
extern void	fillellipseop(Image*, Point, int, int, Image*, Point, Drawop);

extern void	arc(Image*, Point, int, int, int, Image*, Point, int, int);
extern void	arcop(Image*, Point, int, int, int, Image*, Point, int, int, Drawop);
extern void	fillarc(Image*, Point, int, int, Image*, Point, int, int);
extern void	fillarcop(Image*, Point, int, int, Image*, Point, int, int, Drawop);

extern int	bezier(Image*, Point, Point, Point, Point, int, int, int, Image*, Point);
extern int	bezierop(Image*, Point, Point, Point, Point, int, int, int, Image*, Point, Drawop);
extern int	bezspline(Image*, Point*, int, int, int, int, Image*, Point);
extern int	bezsplineop(Image*, Point*, int, int, int, int, Image*, Point, Drawop);
extern int	fillbezier(Image*, Point, Point, Point, Point, int, Image*, Point);
extern int	fillbezierop(Image*, Point, Point, Point, Point, int, Image*, Point, Drawop);
extern int	fillbezspline(Image*, Point*, int, int, Image*, Point);
extern int	fillbezsplineop(Image*, Point*, int, int, Image*, Point, Drawop);

extern int	bezsplinepts(Point*, int, Point**);


extern Point	string(Image*, Point, Image*, Point, Font*, char*);
extern Point	stringop(Image*, Point, Image*, Point, Font*, char*, Drawop);
extern Point	stringn(Image*, Point, Image*, Point, Font*, char*, int);
extern Point	stringnop(Image*, Point, Image*, Point, Font*, char*, int, Drawop);
extern Point	runestring(Image*, Point, Image*, Point, Font*, Rune*);
extern Point	runestringop(Image*, Point, Image*, Point, Font*, Rune*, Drawop);
extern Point	runestringn(Image*, Point, Image*, Point, Font*, Rune*, int);
extern Point	runestringnop(Image*, Point, Image*, Point, Font*, Rune*, int, Drawop);
extern Point	stringbg(Image*, Point, Image*, Point, Font*, char*, Image*, Point);
extern Point	stringbgop(Image*, Point, Image*, Point, Font*, char*, Image*, Point, Drawop);
extern Point	stringnbg(Image*, Point, Image*, Point, Font*, char*, int, Image*, Point);
extern Point	stringnbgop(Image*, Point, Image*, Point, Font*, char*, int, Image*, Point, Drawop);
extern Point	runestringbg(Image*, Point, Image*, Point, Font*, Rune*, Image*, Point);
extern Point	runestringbgop(Image*, Point, Image*, Point, Font*, Rune*, Image*, Point, Drawop);
extern Point	runestringnbg(Image*, Point, Image*, Point, Font*, Rune*, int, Image*, Point);
extern Point	runestringnbgop(Image*, Point, Image*, Point, Font*, Rune*, int, Image*, Point, Drawop);


extern Point	stringsize(Font*, char*);
extern int		stringwidth(Font*, char*);
extern int		stringnwidth(Font*, char*, int);

extern Point	runestringsize(Font*, Rune*);
extern int		runestringwidth(Font*, Rune*);
extern int		runestringnwidth(Font*, Rune*, int);


/*
 * Font management
 */
extern Font*	buildfont(Display*, char*, char*);
extern Font*	openfont(Display*, char*);
extern void		freefont(Font*);

/*
 * One of a kind
 */
extern int		mousescrollsize(int);

extern int	bytesperline(Rectangle, int);
extern int	wordsperline(Rectangle, int);

// seems related to font
extern void		lockdisplay(Display*);
extern void		unlockdisplay(Display*);

//
// Dumpers
//
#pragma varargck	type	"R"	Rectangle
#pragma varargck	type	"P"	Point
extern	int	Rfmt(Fmt*);
extern	int	Pfmt(Fmt*);

@
%// extern	int		log2[];	/* was used by libmemlayer/line.c */


\subsection{[[include/graphics/window.h]]}
%pad: I created this file! its content was in draw.h before.
% the newwindow()/getwindow()/... were even in Image section before in draw.h
% there is draw(2) and window(2) so my creating this file makes sense!

% we could put view; here too. The graphics-only programmer
%  could use display->image directly.

%-------------------------------------------------------------

<<include/graphics/window.h>>=
#pragma src "/sys/src/libdraw"
#pragma lib "libdraw.a"
// This file assumes you have included draw.h before.

<<struct [[Screen]]>>

// set by initdraw() automatically.
extern	Screen	*screen; // was called _screen before

// called by initdraw()
extern int	gengetwindow(Display*, char*, Image**, Screen**, int);

//
// Base layer
//
extern Screen*	allocscreen(Image*, Image*, int);
extern int		freescreen(Screen*);
extern Screen*	publicscreen(Display*, int, ulong);

/*
 * Windows
 */
extern Image*	allocwindow(Screen*, Rectangle, int, ulong);

extern int	originwindow(Image*, Point, Point);
extern void	bottomnwindows(Image**, int);
extern void	bottomwindow(Image*);
extern void	topnwindows(Image**, int);
extern void	topwindow(Image*);

extern int	newwindow(char*);

@

\subsection{[[include/graphics/internals/font.h]]}
%pad: I created this file! its content was in draw.h before.

%-------------------------------------------------------------

<<include/graphics/internals/font.h>>=
#pragma src "/sys/src/libdraw"
#pragma lib "libdraw.a"
// This file assumes you have included draw.h before.

typedef struct	Cachefont Cachefont;
typedef struct	Cacheinfo Cacheinfo;
typedef struct	Cachesubf Cachesubf;
typedef struct	Fontchar Fontchar;
typedef struct	Subfont Subfont;

// The main type, Font, is defined in draw.h.

<<struct [[Fontchar]]>>

<<struct [[Subfont]]>>

<<struct [[Cachefont]]>>

<<struct [[Cacheinfo]]>>

<<struct [[Cachesubf]]>>

<<enum [[misc]]>>


// internal to font code
extern Subfont*	allocsubfont(char*, int, int, int, Fontchar*, Image*);
extern void	    freesubfont(Subfont*);
extern Subfont*	lookupsubfont(Display*, char*);
extern void	installsubfont(char*, Subfont*);
extern void	uninstallsubfont(Subfont*);
extern Subfont*	readsubfont(Display*, char*, int, int);
extern char*	subfontname(char*, char*, int);
extern Subfont*	_getsubfont(Display*, char*);
// for subfont designers
extern int	writesubfont(int, Subfont*);

extern int		cachechars(Font*, char**, Rune**, ushort*, int, int*, char**);
extern void		agefont(Font*);
extern Point	strsubfontwidth(Subfont*, char*);
extern int		loadchar(Font*, Rune, Cacheinfo*, int, int, char**);
extern Subfont*	getdefont(Display*);

// used also by libmemdraw/
extern void		_unpackinfo(Fontchar*, byte*, int);
extern	byte	defontdata[];
extern	int		sizeofdefont;


@

\subsection{[[include/graphics/internals/marshal.h]]}
%pad: I created this file! its content was in draw.h before.

%-------------------------------------------------------------

<<include/graphics/internals/marshal.h>>=
<<function [[BGSHORT]]>>
<<function [[BGLONG]]>>
<<function [[BPSHORT]]>>
<<function [[BPLONG]]>>

extern byte*	bufimage(Display*, int);

@

\subsection{[[include/graphics/internals/draw_private.h]]}
%pad: I created this file! its content was in draw.h before.

%-------------------------------------------------------------

<<include/graphics/internals/draw_private.h>>=

extern int		drawlsetrefresh(ulong, int, void*, void*);

// dead?
extern	int		_cursorfd;

extern	bool	_drawdebug;	/* set to true to see errors from flushimage */

// used also by window.c
extern Image*	_allocimage(Image*, Display*, Rectangle, ulong, int, ulong, int, int);
extern int	    _freeimage1(Image*);

extern	void	_setdrawop(Display*, Drawop);

// used also by libmemdraw/
void _twiddlecompressed(uchar *buf, int n);
int _compblocksize(Rectangle r, int depth);

<<constant [[NMATCH]]>>
<<constant [[NRUN]]>>
<<constant [[NMEM]]>>
<<constant [[NDUMP]]>>
<<constant [[NCBLOCK]]>>

/* XXX backwards helps; should go */
extern	ulong	drawld2chan[];
extern	void	drawsetdebug(bool);

#include <marshal.h>

@


\subsection{[[include/graphics/internals/memdraw.h]]}

%dead: (or maybe was used in test code)
% extern void			freememsubfont(Memsubfont*);
% extern Memsubfont*	openmemsubfont(char*);


%-------------------------------------------------------------

<<include/graphics/internals/memdraw.h>>=
#pragma	src	"/sys/src/libmemdraw"
#pragma	lib	"libmemdraw.a"
// This file assumes you have included draw.h before.

typedef struct	Memimage Memimage;
typedef struct	Memdata Memdata;
typedef struct	Memsubfont Memsubfont;
typedef struct	Memcmap Memcmap;
typedef struct	Memdrawparam	Memdrawparam;

// defined in other header files
typedef struct	Memlayer Memlayer;
typedef struct	Fontchar Fontchar;
#pragma incomplete Memlayer
#pragma incomplete Fontchar

<<struct [[Memdata]]>>

<<enum [[fxxx]]>>

<<struct [[Memimage]]>>

<<struct [[Memcmap]]>>

<<struct [[Memsubfont]]>>

<<enum [[_anon_ (include/memdraw.h)2]]>>
//TODO: internal to draw.c?
<<struct [[Memdrawparam]]>>

/*
 * Memimage management
 */
extern Memimage*	allocmemimage(Rectangle, ulong);
extern Memimage*	allocmemimaged(Rectangle, ulong, Memdata*);
extern void			freememimage(Memimage*);

extern Memimage*	readmemimage(fdt);
extern int			writememimage(int, Memimage*);
extern int			loadmemimage(Memimage*, Rectangle, uchar*, int);
extern int			unloadmemimage(Memimage*, Rectangle, uchar*, int);
extern Memimage*	creadmemimage(int);
extern int			cloadmemimage(Memimage*, Rectangle, uchar*, int);

// misc utilities
extern ulong*	wordaddr(Memimage*, Point);
extern uchar*	byteaddr(Memimage*, Point);

extern int		drawclip(Memimage*, Rectangle*, Memimage*, Point*, Memimage*, Point*, Rectangle*, Rectangle*);
extern void		memfillcolor(Memimage*, ulong);
extern int		memsetchan(Memimage*, ulong);

/*
 * Graphics
 */
extern void	memimageinit(void);

// actually in memlayer
extern void	memdraw(Memimage*, Rectangle, Memimage*, Point, Memimage*, Point, int);
extern void	memimagedraw(Memimage*, Rectangle, Memimage*, Point, Memimage*, Point, int);

// actually in memlayer/
extern void	memline(Memimage*, Point, Point, int, int, int, Memimage*, Point, int);


extern void	mempoly(Memimage*, Point*, int, int, int, int, Memimage*, Point, int);
extern void	memfillpoly(Memimage*, Point*, int, int, Memimage*, Point, int);


extern void	memellipse(Memimage*, Point, int, int, int, Memimage*, Point, int);

extern void	memarc(Memimage*, Point, int, int, int, Memimage*, Point, int, int, int);

extern Point	memimagestring(Memimage*, Point, Memimage*, Point, Memsubfont*, char*);

// TODO: cruft private?
// !!!
extern int	hwdraw(Memdrawparam*);


extern Rectangle	memlinebbox(Point, Point, int, int, int);
extern int			memlineendsize(int);
extern void			_memmkcmap(void);

/*
 * Subfont management
 */
extern Point		memsubfontwidth(Memsubfont*, char*);
extern Memsubfont*	getmemdefont(void);
extern Memsubfont*	allocmemsubfont(char*, int, int, int, Fontchar*, Memimage*);

/*
 * Predefined 
 */
extern	Memimage*	memwhite;
extern	Memimage*	memblack;
extern	Memimage*	memopaque;
extern	Memimage*	memtransparent;

extern	Memcmap	*memdefcmap;


// Forward decl? or should be fixed?
extern void	_memimageline(Memimage*, Point, Point, int, int, int, Memimage*, Point, Rectangle, int);
//todo: remove this one and rename the previous one
//extern void	memimageline(Memimage*, Point, Point, int, int, int, Memimage*, Point, int);

extern void	_memfillpolysc(Memimage*, Point*, int, int, Memimage*, Point, int, int, int, int);

// used by color.c and alphadraw.c now (and test files)
<<function [[RGB2K]]>>

/*
 * Kernel interface
 */
void		memimagemove(void*, void*);

/*
 * Kernel cruft
 */
extern void	rdb(void);
extern int	(*iprint)(char*, ...);
#pragma varargck argpos iprint 1

extern int		drawdebug;

/*
 * doprint interface: numbconv bit strings
 */
#pragma varargck type "llb" vlong
#pragma varargck type "llb" uvlong
#pragma varargck type "lb" long
#pragma varargck type "lb" ulong
#pragma varargck type "b" int
#pragma varargck type "b" uint

@


\subsection{[[include/graphics/internals/memlayer.h]]}

%-------------------------------------------------------------

<<include/graphics/internals/memlayer.h>>=
#pragma src "/sys/src/libmemlayer"
#pragma lib "libmemlayer.a"
// This file assumes you have included draw.h before.


typedef struct Memscreen Memscreen;
typedef void (*Refreshfn)(Memimage*, Rectangle, void*);

<<struct [[Memscreen]]>>

<<struct [[Memlayer]]>>

/*
 * These functions accept local coordinates
 */
int			memload(Memimage*, Rectangle, uchar*, int, int);
int			memunload(Memimage*, Rectangle, uchar*, int);

/*
 * All these functions accept screen coordinates, not local ones.
 */

Memimage*		memlalloc(Memscreen*, Rectangle, Refreshfn, void*, ulong);
void			memlfree(Memimage*);
void			memldelete(Memimage*);

int				memlorigin(Memimage*, Point, Point);

void			memltofront(Memimage*);
void			memltofrontn(Memimage**, int);
void			memltorear(Memimage*);
void			memltorearn(Memimage**, int);
void			memlhide(Memimage*, Rectangle);
void			memlexpose(Memimage*, Rectangle);

int				memlsetrefresh(Memimage*, Refreshfn, void*);
void			memlnorefresh(Memimage*, Rectangle, void*);

void			_memlayerop(void (*fn)(Memimage*, Rectangle, Rectangle, void*, int), Memimage*, Rectangle, Rectangle, void*);

void			_memltofrontfill(Memimage*, int);
void			_memlsetclear(Memscreen*);
@


\subsection{[[include/graphics/input/keyboard.h]]}

%-------------------------------------------------------------

<<include/graphics/input/keyboard.h>>=
#pragma src "/sys/src/libdraw"
#pragma lib "libdraw.a"

typedef struct 	Keyboardctl Keyboardctl;
typedef struct	Channel	Channel;

<<struct [[Keyboardctl]]>>

extern	Keyboardctl*	initkeyboard(char*);
extern	int				ctlkeyboard(Keyboardctl*, char*);
extern	void			closekeyboard(Keyboardctl*);

<<enum [[Kxxx]]>>
@


\subsection{[[include/graphics/input/mouse.h]]}


%-------------------------------------------------------------

<<include/graphics/input/mouse.h>>=
#pragma src "/sys/src/libdraw"

typedef struct	Channel Channel;
typedef struct	Cursor Cursor;
typedef struct	Menu Menu;
typedef struct 	Mousectl Mousectl;

<<enum [[Click]]>>

<<struct [[Mouse]]>>

<<struct [[Mousectl]]>>

//TODO: mv in menu.h?
<<struct [[Menu]]>>

/*
 * Mouse
 */
extern Mousectl*	initmouse(char*, Image*);
extern void			closemouse(Mousectl*);

extern int			readmouse(Mousectl*);
extern void			moveto(Mousectl*, Point);
extern void			setcursor(Mousectl*, Cursor*);

//TODO? mv in menu.h?
extern void			drawgetrect(Rectangle, int);
extern Rectangle	getrect(int, Mousectl*);

extern int	 		menuhit(int, Mousectl*, Menu*, Screen*);
@





\subsection{[[include/graphics/cursor.h]]}

%-------------------------------------------------------------

<<include/graphics/cursor.h>>=
#pragma src "/sys/src/libdraw"

typedef struct	Cursor Cursor;

<<struct [[Cursor]]>>
@


\subsection{[[include/graphics/input/event.h]]}


%-------------------------------------------------------------

<<include/graphics/input/event.h>>=
#pragma src "/sys/src/libdraw"
#pragma lib "libdraw.a"

typedef struct	Cursor Cursor;
typedef struct	Event Event;
typedef struct	Menu Menu;
//typedef struct	Mouse Mouse;

<<type [[keys]]>>

<<enum [[Key]]>>

<<enum [[_anon_ (include/event.h)2]]>>

<<struct Mouse (include/event.h)>>

<<struct [[Event]]>>

<<struct Menu (include/event.h)>>

/*
 * Events
 */
extern void		einit(ulong);
extern ulong	estart(ulong, int, int);
extern ulong	estartfn(ulong, int, int, int (*fn)(int, Event*, uchar*, int));
extern ulong	 event(Event*);
extern ulong	 eread(ulong, Event*);
extern int	 ecanread(ulong);

extern Mouse	emouse(void);
extern int	 	ekbd(void);
extern ulong	etimer(ulong, int);

extern int	 	ecanmouse(void);
extern int	 	ecankbd(void);

//ugly!!!
extern void	 eresized(int);	/* supplied by user */

extern int	 	emenuhit(int, Mouse*, Menu*);
extern void	 	esetcursor(Cursor*);
extern void	 	emoveto(Point);
extern void		edrawgetrect(Rectangle, int);
extern int		ereadmouse(Mouse*);
extern int		eatomouse(Mouse*, char*, int);

extern Rectangle	getrect(int, Mouse*);
extern Rectangle	egetrect(int, Mouse*);

// from plan9front
extern int		eenter(char*, char*, int, Mouse*);

@


\section{[[lib_graphics/libdraw/]]}

\subsection{[[lib_graphics/libdraw/arith.c]]}

%dead:
%/*
% * was used by libmemlayer/line.c; made static, instead of deleting it,
% * to avoid updating many binaries on sources.
% */
%static int log2[] = { -1, 0, 1, -1, 2, -1, -1, -1, 3, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, 4 /* BUG */, -1, -1, -1, -1, -1, -1, -1, 5 };
%

%-------------------------------------------------------------

<<lib_graphics/libdraw/arith.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function [[Pt]]>>

<<function [[Rect]]>>

<<function [[Rpt]]>>

<<function [[addpt]]>>

<<function [[subpt]]>>

<<function [[insetrect]]>>

<<function [[divpt]]>>

<<function [[mulpt]]>>

<<function [[rectsubpt]]>>

<<function [[rectaddpt]]>>

<<function [[eqpt]]>>

<<function [[eqrect]]>>

<<function [[rectXrect]]>>

<<function [[rectinrect]]>>

<<function [[ptinrect]]>>

<<function [[canonrect]]>>

<<function [[combinerect]]>>


<<global [[ZP]]>>
<<global [[ZR]]>>
@


\subsection{[[lib_graphics/libdraw/icossin.c]]}


%-------------------------------------------------------------

<<lib_graphics/libdraw/icossin.c>>=
#include	<u.h>
#include	<libc.h>
#include	<draw.h>

<<global [[sinus]]>>

<<function [[icossin]]>>
@


\subsection{[[lib_graphics/libdraw/icossin2.c]]}
% merge?

%-------------------------------------------------------------

<<lib_graphics/libdraw/icossin2.c>>=
#include	<u.h>
#include	<libc.h>
#include	<draw.h>

<<global [[sinus]]([[(lib_graphics/libdraw/icossin2.c)]])>>

<<global [[cosinus]]>>

<<function [[icossin2]]>>
@


\subsection{[[lib_graphics/libdraw/resolution.c]]}
%pad: this file was called bytesperline.c

% Actually used in memdraw/alloc.c, but also here by readimage.c/...) 
% so must be in libgeometry.

%-------------------------------------------------------------

<<lib_graphics/libdraw/resolution.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function [[unitsperline]]>>

<<function [[wordsperline]]>>

<<function [[bytesperline]]>>
@


\subsection{[[lib_graphics/libdraw/chan.c]]}


%-------------------------------------------------------------

<<lib_graphics/libdraw/chan.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<global [[channames]]>>
<<function [[chantostr]]>>

<<function [[isspace]]>>

<<function [[strtochan]]>>

<<function [[chantodepth]]>>
@

\subsection{[[lib_graphics/libdraw/concurrency.c]]}
%pad: I created this file; its content was in init.c before.

%-------------------------------------------------------------

<<lib_graphics/libdraw/concurrency.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<global [[debuglockdisplay]]>>

<<function [[lockdisplay]]>>

<<function [[unlockdisplay]]>>

@

\subsection{[[lib_graphics/libdraw/init.c]]}
%pad: I moved window stuff outside.

%-------------------------------------------------------------

<<lib_graphics/libdraw/init.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <draw_private.h>
#include <window.h>
#include <font.h>

<<global [[deffontname]]>>

static void _closedisplay(Display*, int);

<<function [[drawshutdown]]>>

<<function [[geninitdraw]]>>

<<function [[initdraw]]>>

<<constant [[NINFO]]>>

<<function [[initdisplay]]>>

<<function [[closedisplay]]>>

<<function [[_closedisplay]]>>

@

\subsection{[[lib_graphics/libdraw/globals.c]]}
%pad: I created this file; its content was in init.c before

%-------------------------------------------------------------

<<lib_graphics/libdraw/globals.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<global [[display]]>>
<<global [[view]]>>
<<global [[font]]>>

@

\subsection{[[lib_graphics/libdraw/error.c]]}
%pad: I created this file; its content was in init.c before

%-------------------------------------------------------------

<<lib_graphics/libdraw/error.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function [[drawerror]]>>

@

\subsection{[[lib_graphics/libdraw/flush.c]]}
%pad: I created this file; its content was in init.c before

%-------------------------------------------------------------

<<lib_graphics/libdraw/flush.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <draw_private.h>

<<function [[doflush]]>>

<<function [[flushimage]]>>

<<function [[bufimage]]>>

@

\subsection{[[lib_graphics/libdraw/alloc.c]]}
%pad: I moved the naming stuff in naming.c and added allocimagemix() here.

%-------------------------------------------------------------

<<lib_graphics/libdraw/alloc.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <draw_private.h>

<<function [[allocimage]]>>

<<function [[_allocimage]]>>

<<function [[_freeimage1]]>>

<<function [[freeimage]]>>

<<function [[allocimagemix]]>>
@

%\subsection{[[lib_graphics/libdraw/allocimagemix.c]]}


\subsection{[[lib_graphics/libdraw/naming.c]]}
%pad: I created this file; its content was in alloc.c before.

%-------------------------------------------------------------

<<lib_graphics/libdraw/naming.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <draw_private.h>

<<function [[namedimage]]>>

<<function [[nameimage]]>>

@

\subsection{[[lib_graphics/libdraw/misc.c]]}

<<lib_graphics/libdraw/misc.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<global [[drawld2chan]]>>

@
%<<function setalpha>>

\subsection{[[lib_graphics/libdraw/debug.c]]}
%pad: _drawdebug was in init.c before

%-------------------------------------------------------------

<<lib_graphics/libdraw/debug.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <draw_private.h>

<<global [[_drawdebug]]>>

<<function [[drawsetdebug]]>>
@


\subsection{[[lib_graphics/libdraw/fmt.c]]}

%-------------------------------------------------------------

<<lib_graphics/libdraw/fmt.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function [[Rfmt]]>>

<<function [[Pfmt]]>>

@


\subsection{[[lib_graphics/libdraw/defont.c]]}
%pad: I moved getdefont.c here but then put it back in subfont.c because
% of linking issues with the kernel. See the comment in subfont.c.

<<global [[defontdata]]>>=
/*
 * lucm/latin1.9, in uncompressed form
 */
byte
defontdata[] =
{
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x30,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x30,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x30,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x32,0x33,0x30,0x34,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x31,0x35,0x20,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x30,0x06,0x06,0x03,0x42,0x40,0x00,0x00,0x00,0x18,0x03,0x03,
0x02,0x43,0x00,0x60,0x60,0x48,0x00,0x0d,0x0c,0x01,0x81,0x80,0xd0,0x90,0x00,0x00,
0x18,0x01,0x81,0x81,0x40,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x7f,0x9c,0x1c,
0x0e,0x07,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xe0,0x70,
0x38,0x1c,0x0e,0x04,0x81,0xc1,0xc0,0x70,0x00,0x1c,0x1c,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xaa,0x80,0xc0,0x63,0xe3,
0xf1,0xf8,0xfe,0x7f,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,0x7f,0xff,0xff,0x1f,0x8f,
0xc7,0xe3,0xf1,0xfb,0x7e,0x3e,0x3f,0x8f,0xff,0xe3,0xe3,0xff,0xff,0xff,0xff,0xff,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x0c,0x18,0x09,0x05,0x82,0x40,0xc0,0x00,0x00,0x06,0x0c,0x04,
0x82,0x40,0xc1,0x80,0x90,0x48,0x00,0x16,0x03,0x06,0x02,0x41,0x60,0x90,0x00,0x00,
0x06,0x06,0x02,0x41,0x41,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3e,0x7f,0xa0,0x10,
0x08,0x04,0x02,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x90,0x48,
0x24,0x12,0x09,0x06,0x82,0x01,0x00,0x90,0x00,0x20,0x10,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x04,0x80,0x00,0x40,0x00,0x00,0x38,0x06,0x18,0x00,0x00,0x00,0x00,0x00,
0x00,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x07,0xc6,0x01,0xf0,0x00,0x00,0x0c,0x00,0x18,0x00,0x00,0x30,0x00,0x3c,
0x00,0x60,0x06,0x01,0x8c,0x07,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xe0,0xc3,0xc0,0x01,0x54,0x9c,0xc0,0x5f,0xef,
0xf7,0xfb,0xfd,0xbf,0xff,0xff,0xff,0xff,0xff,0xff,0xfb,0x7f,0xff,0xff,0x6f,0xb7,
0xdb,0xed,0xf6,0xf9,0x7d,0xfe,0xff,0x6f,0xff,0xdf,0xef,0xff,0xff,0xff,0xff,0xff,
0xff,0x00,0x01,0x00,0x00,0x00,0x00,0x30,0x00,0x14,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x38,0x00,0x00,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x20,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x30,0x06,0x06,0x06,0x82,0x80,0xc0,0x00,
0x00,0x18,0x03,0x03,0x02,0x41,0x80,0x30,0x30,0x24,0x76,0x0d,0x0c,0x00,0xc0,0xc0,
0xd0,0x50,0x00,0x00,0x18,0x01,0x81,0x81,0x40,0x30,0x00,0x28,0x0f,0x7f,0xbc,0x1c,
0x0e,0x07,0x03,0xc0,0x10,0x70,0x24,0x10,0x09,0x07,0x03,0x80,0xe0,0x70,0x90,0x48,
0x24,0x12,0x09,0x05,0x81,0x81,0xc0,0x80,0x70,0x18,0x1c,0x07,0x01,0xc1,0xc0,0x90,
0x00,0x0c,0x04,0x84,0x83,0xe1,0xc0,0xe0,0x38,0x0c,0x0c,0x02,0x00,0x00,0x00,0x00,
0x00,0x06,0x1c,0x06,0x0f,0x87,0xc0,0x63,0xf8,0x78,0xfe,0x3e,0x0e,0x00,0x00,0x00,
0x00,0x00,0x00,0x7c,0x1c,0x0c,0x1f,0x03,0xc7,0xc3,0xf1,0xf8,0x3c,0x63,0x3f,0x0f,
0x8c,0x66,0x06,0x19,0x84,0x78,0x7e,0x1e,0x1f,0x07,0xcf,0xf3,0x1b,0x0d,0x86,0x63,
0x61,0x9f,0xc6,0x06,0x00,0x30,0x00,0x00,0x10,0x00,0x18,0x00,0x00,0x30,0x00,0x60,
0x00,0x60,0x06,0x01,0x8c,0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,
0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0xc0,0x60,0x00,0xaa,0xb6,0xc0,0x43,0xe3,
0xf1,0xf8,0xfc,0x3f,0xef,0x8f,0xdb,0xef,0xf6,0xf8,0xfb,0xff,0x1f,0x8f,0x6f,0xb7,
0xdb,0xed,0xf6,0xfa,0x7e,0x7e,0x3f,0x7f,0x8f,0xe7,0xe3,0xf8,0xfe,0x3e,0x3f,0x6f,
0x00,0x00,0x01,0x01,0xc8,0x0b,0x0c,0x30,0x7c,0x14,0x0f,0x0f,0x00,0x00,0x00,0x00,
0x78,0x00,0x1c,0x00,0x0f,0x07,0x81,0x80,0x00,0x7c,0x00,0x00,0x1c,0x0f,0x80,0x04,
0x42,0x23,0x90,0x00,0x18,0x0c,0x06,0x03,0x01,0x80,0xc0,0x3c,0x3c,0x3f,0x1f,0x8f,
0xc7,0xe7,0xe3,0xf1,0xf8,0xfc,0x7c,0x30,0x8f,0x07,0x83,0xc1,0xe0,0xf0,0x00,0x3d,
0x31,0x98,0xcc,0x66,0x36,0x19,0x80,0xcc,0x0c,0x18,0x09,0x0b,0x02,0x81,0x20,0x00,
0x00,0x06,0x0c,0x04,0x82,0x40,0x60,0xc0,0x48,0x24,0x18,0x16,0x03,0x03,0x01,0x21,
0x60,0x50,0x00,0x00,0x06,0x06,0x02,0x41,0x40,0xc1,0x80,0x28,0x87,0x7f,0x84,0x10,
0x08,0x04,0x02,0x40,0x38,0x48,0x24,0x10,0x09,0x04,0x04,0x81,0x00,0x80,0x90,0x48,
0x24,0x12,0x09,0x04,0x80,0x41,0x00,0x80,0x40,0x04,0x10,0x04,0x02,0x01,0x20,0x90,
0x00,0x0c,0x04,0x84,0x86,0x53,0x65,0xb0,0x08,0x18,0x06,0x0a,0x80,0x00,0x00,0x00,
0x00,0x0c,0x36,0x0e,0x19,0xcc,0xe0,0xe3,0xf8,0xcc,0xfe,0x63,0x1b,0x00,0x00,0x00,
0x00,0x00,0x00,0xc6,0x62,0x0c,0x19,0x86,0x66,0x63,0x01,0x80,0x66,0x63,0x0c,0x01,
0x8c,0xc6,0x06,0x19,0xc4,0xcc,0x63,0x33,0x19,0x8c,0x61,0x83,0x1b,0x0d,0x86,0x63,
0x61,0x80,0xc6,0x03,0x00,0x30,0x30,0x00,0x1c,0x00,0x18,0x00,0x00,0x30,0x00,0x60,
0x00,0x60,0x00,0x00,0x0c,0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,
0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0xc0,0x60,0x01,0x54,0x86,0xc0,0x7b,0xef,
0xf7,0xfb,0xfd,0xbf,0xc7,0xb7,0xdb,0xef,0xf6,0xfb,0xfb,0x7e,0xff,0x7f,0x6f,0xb7,
0xdb,0xed,0xf6,0xfb,0x7f,0xbe,0xff,0x7f,0xbf,0xfb,0xef,0xfb,0xfd,0xfe,0xdf,0x6f,
0xff,0x00,0x07,0x83,0x24,0x13,0x0c,0x30,0xc6,0x00,0x10,0x81,0x80,0x00,0x00,0x00,
0x84,0x00,0x22,0x00,0x01,0x80,0xc0,0x00,0x00,0xf4,0x00,0x00,0x2c,0x18,0xc0,0x0c,
0x46,0x20,0x90,0x00,0x18,0x0c,0x06,0x03,0x01,0x80,0xc0,0x70,0x66,0x30,0x18,0x0c,
0x06,0x01,0x80,0xc0,0x60,0x30,0x66,0x38,0x99,0x8c,0xc6,0x63,0x31,0x98,0x00,0x66,
0x31,0x98,0xcc,0x66,0x36,0x19,0x80,0xcc,0x00,0x00,0x00,0x00,0x00,0x00,0xc0,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x6c,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x00,0xff,0x7f,0xb8,0x1c,
0x0e,0x07,0x02,0x40,0x7c,0x70,0x3c,0x10,0x09,0x07,0x04,0x00,0xc0,0x60,0xe0,0x70,
0x38,0x1c,0x0e,0x04,0x83,0x81,0xc0,0x70,0x70,0x38,0x1c,0x07,0x02,0xc1,0xc0,0x90,
0x00,0x0c,0x00,0x04,0x86,0x43,0x69,0xb0,0x30,0x18,0x06,0x07,0x01,0x00,0x00,0x00,
0x00,0x0c,0x63,0x16,0x00,0xc0,0x61,0x62,0x01,0x80,0x06,0x63,0x31,0x80,0x00,0x00,
0x60,0x00,0xc0,0x06,0x43,0x16,0x19,0x8c,0x06,0x33,0x01,0x80,0xc0,0x63,0x0c,0x01,
0x8c,0x86,0x07,0x39,0xc5,0x86,0x63,0x61,0x99,0x8c,0x01,0x83,0x1b,0x0d,0xb6,0x63,
0x31,0x01,0x86,0x03,0x00,0x30,0x30,0x00,0x1c,0x3e,0x1b,0x03,0xc1,0xf0,0xf0,0x60,
0x3e,0x6e,0x3e,0x0f,0x8c,0x60,0xc5,0xb1,0xb8,0x38,0x6c,0x0f,0x8c,0xc7,0xc1,0x83,
0x19,0x8d,0x82,0x63,0x31,0x9f,0xc1,0x80,0xc0,0xc0,0x00,0xaa,0x86,0xc0,0x47,0xe3,
0xf1,0xf8,0xfd,0xbf,0x83,0x8f,0xc3,0xef,0xf6,0xf8,0xfc,0xff,0x3f,0x9f,0x1f,0x8f,
0xc7,0xe3,0xf1,0xfb,0x7c,0x7e,0x3f,0x8f,0x8f,0xc7,0xe3,0xf8,0xfd,0x3e,0x3f,0x6f,
0x00,0x0c,0x0d,0x43,0x03,0xe1,0x88,0x30,0xc0,0x00,0x27,0x41,0x80,0x00,0x00,0x01,
0x72,0x00,0x22,0x04,0x01,0x80,0xc0,0x03,0x18,0xf4,0x00,0x00,0x0c,0x18,0xc0,0x04,
0x82,0x43,0x20,0x18,0x2c,0x16,0x0b,0x05,0x82,0xc1,0x60,0xb0,0xc0,0x30,0x18,0x0c,
0x06,0x01,0x80,0xc0,0x60,0x30,0x63,0x38,0xb0,0xd8,0x6c,0x36,0x1b,0x0c,0x00,0xc7,
0x31,0x98,0xcc,0x66,0x33,0x11,0xf8,0xc8,0x7c,0x3e,0x1f,0x0f,0x87,0xc3,0xe1,0xd8,
0x3c,0x1e,0x0f,0x07,0x83,0xc7,0xc3,0xe1,0xf0,0xf8,0x06,0x37,0x07,0x03,0x81,0xc0,
0xe0,0x70,0x10,0x1d,0x31,0x98,0xcc,0x66,0x33,0x19,0xb0,0xc6,0x8f,0x7f,0x87,0x03,
0x81,0x80,0x90,0x30,0x6c,0x48,0x24,0x10,0x06,0x04,0x04,0x80,0x20,0x10,0x10,0x0e,
0x07,0x03,0x81,0xc0,0x60,0x88,0x38,0x0c,0x40,0x09,0x03,0x84,0x02,0x41,0x40,0x90,
0x00,0x0c,0x00,0x1f,0xe7,0x41,0xd1,0xa0,0x00,0x30,0x03,0x0a,0x81,0x00,0x00,0x00,
0x00,0x18,0x63,0x06,0x00,0xc0,0xc2,0x62,0x01,0xb0,0x0c,0x72,0x31,0x86,0x03,0x00,
0xc0,0x00,0x60,0x06,0x8f,0x16,0x19,0x0c,0x06,0x33,0x01,0x80,0xc0,0x63,0x0c,0x01,
0x8d,0x06,0x07,0x39,0x65,0x86,0x63,0x61,0x99,0x0e,0x01,0x83,0x19,0x89,0xb6,0x32,
0x33,0x03,0x06,0x01,0x80,0x30,0x78,0x00,0x00,0x03,0x1d,0x86,0x23,0x31,0x99,0xfc,
0x66,0x77,0x06,0x01,0x8c,0x40,0xc6,0xd9,0xdc,0x6c,0x76,0x19,0x8d,0xcc,0x27,0xf3,
0x19,0x8d,0x82,0x63,0x31,0x80,0xc0,0x80,0xc0,0x80,0x01,0x54,0x8c,0xc0,0x78,0xfc,
0x7e,0x7f,0x6f,0xcf,0x93,0xb7,0xdb,0xef,0xf9,0xfb,0xff,0xff,0xdf,0xef,0xef,0xf1,
0xf8,0xfc,0x7e,0x3f,0x9f,0x77,0xc7,0xf3,0xbf,0xf6,0xfc,0x7b,0xfd,0xbe,0xbf,0x6f,
0xff,0x0c,0x19,0x03,0x03,0x61,0x98,0x30,0x78,0x00,0x28,0x4f,0x83,0x30,0x00,0x01,
0x4a,0x00,0x1c,0x04,0x03,0x03,0x80,0x03,0x18,0xf4,0x00,0x00,0x0c,0x18,0xd9,0x84,
0x82,0x40,0xa0,0x18,0x2c,0x16,0x0b,0x05,0x82,0xc1,0x60,0xb0,0xc0,0x30,0x18,0x0c,
0x06,0x01,0x80,0xc0,0x60,0x30,0x63,0x2c,0xb0,0xd8,0x6c,0x36,0x1b,0x0c,0x64,0xcb,
0x31,0x98,0xcc,0x66,0x33,0x31,0x8c,0xd8,0x06,0x03,0x01,0x80,0xc0,0x60,0x30,0x6c,
0x62,0x33,0x19,0x8c,0xc6,0x60,0xc0,0x60,0x30,0x18,0x1e,0x3b,0x8d,0x86,0xc3,0x61,
0xb0,0xd8,0x10,0x36,0x31,0x98,0xcc,0x66,0x33,0x19,0xd8,0xc6,0x0f,0x7f,0x82,0x01,
0x02,0x40,0xd0,0x40,0x6c,0x70,0x24,0x1c,0x06,0x04,0x03,0x01,0xc0,0xe0,0x10,0x12,
0x09,0x04,0x82,0x40,0x90,0x50,0x10,0x12,0x70,0x09,0x04,0x04,0x01,0xc1,0x20,0x60,
0x00,0x0c,0x00,0x04,0x83,0xc0,0x20,0xcc,0x00,0x30,0x03,0x02,0x01,0x00,0x00,0x00,
0x00,0x18,0x63,0x06,0x01,0x83,0x84,0x63,0xf1,0xd8,0x18,0x3c,0x31,0x86,0x03,0x01,
0x83,0xf8,0x30,0x1c,0x9b,0x33,0x1e,0x0c,0x06,0x33,0xe1,0x80,0xc0,0x7f,0x0c,0x01,
0x8f,0x06,0x07,0x79,0x65,0x86,0x66,0x61,0x9e,0x07,0x81,0x83,0x19,0x89,0xb6,0x1c,
0x1a,0x03,0x06,0x01,0x80,0x30,0x48,0x00,0x00,0x03,0x18,0xcc,0x06,0x33,0x18,0x60,
0xc6,0x63,0x06,0x01,0x8c,0x80,0xc6,0xd9,0x8c,0xc6,0x63,0x31,0x8e,0x4c,0x01,0x83,
0x19,0x8d,0x92,0x32,0x31,0x81,0x87,0x00,0xc0,0x70,0xe4,0xaa,0x98,0xc0,0x7d,0xfe,
0xfd,0xbf,0x2f,0xbf,0x93,0x8f,0xdb,0xe3,0xf9,0xfb,0xff,0x1e,0x3f,0x1f,0xef,0xed,
0xf6,0xfb,0x7d,0xbf,0x6f,0xaf,0xef,0xed,0x8f,0xf6,0xfb,0xfb,0xfe,0x3e,0xdf,0x9f,
0x00,0x00,0x19,0x0f,0xc6,0x30,0xd0,0x00,0xcc,0x00,0x28,0x59,0x86,0x67,0xf0,0x01,
0x72,0x00,0x00,0x3f,0x86,0x00,0xc0,0x03,0x18,0xf4,0x00,0x00,0x0c,0x18,0xcc,0xc5,
0x32,0x83,0x4c,0x00,0x66,0x33,0x19,0x8c,0xc6,0x63,0x31,0xbc,0xc0,0x3e,0x1f,0x0f,
0x87,0xc1,0x80,0xc0,0x60,0x30,0xfb,0x2c,0xb0,0xd8,0x6c,0x36,0x1b,0x0c,0x38,0xcb,
0x31,0x98,0xcc,0x66,0x31,0xa1,0x8c,0xcc,0x06,0x03,0x01,0x80,0xc0,0x60,0x30,0x6c,
0xc0,0x63,0x31,0x98,0xcc,0x60,0xc0,0x60,0x30,0x18,0x37,0x31,0x98,0xcc,0x66,0x33,
0x19,0x8c,0x00,0x67,0x31,0x98,0xcc,0x66,0x33,0x19,0x8c,0xc6,0x1f,0x7f,0x82,0x01,
0x02,0x40,0xb0,0x40,0x6c,0x07,0x03,0x83,0x80,0xe0,0xe0,0x00,0x18,0x0e,0x10,0x10,
0x08,0x04,0x02,0x00,0xf0,0x20,0x10,0x1e,0x08,0x89,0x03,0x00,0xe0,0x38,0x1c,0x0e,
0x00,0x0c,0x00,0x04,0x81,0xe0,0x41,0x6c,0x00,0x30,0x03,0x00,0x0f,0xe0,0x03,0xf8,
0x00,0x30,0x63,0x06,0x03,0x00,0xc7,0xf0,0x39,0x8c,0x30,0x3e,0x1b,0x80,0x00,0x03,
0x00,0x00,0x18,0x30,0x9b,0x23,0x19,0x0c,0x06,0x33,0x01,0xf8,0xc6,0x63,0x0c,0x01,
0x8d,0x86,0x05,0xd9,0x35,0x86,0x7c,0x61,0x9b,0x01,0xc1,0x83,0x19,0x99,0xb4,0x1c,
0x0c,0x06,0x06,0x00,0xc0,0x30,0xcc,0x00,0x00,0x3f,0x18,0xcc,0x06,0x33,0xf8,0x60,
0xc6,0x63,0x06,0x01,0x8f,0x00,0xc6,0xd9,0x8c,0xc6,0x63,0x31,0x8c,0x0f,0x81,0x83,
0x18,0xd9,0xba,0x1c,0x1b,0x03,0x00,0x80,0xc0,0x81,0x75,0x54,0x98,0xc0,0x7d,0xfe,
0xfd,0xbf,0x4f,0xbf,0x93,0xf8,0xfc,0x7c,0x7f,0x1f,0x1f,0x6f,0xe7,0xf1,0xef,0xef,
0xf7,0xfb,0xfd,0xff,0x0f,0xdf,0xef,0xe1,0xf7,0x76,0xfc,0xff,0x1f,0xc7,0xe3,0xf1,
0xff,0x08,0x19,0x03,0x06,0x31,0xf8,0x00,0xc6,0x00,0x28,0x5b,0x8c,0xc0,0x11,0xf1,
0x4a,0x00,0x00,0x04,0x0c,0x00,0xc0,0x03,0x18,0x74,0x38,0x00,0x0c,0x18,0xc6,0x65,
0x52,0xb8,0x54,0x18,0x46,0x23,0x11,0x88,0xc4,0x62,0x31,0x30,0xc0,0x30,0x18,0x0c,
0x06,0x01,0x80,0xc0,0x60,0x30,0x63,0x26,0xb0,0xd8,0x6c,0x36,0x1b,0x0c,0x10,0xd3,
0x31,0x98,0xcc,0x66,0x30,0xc1,0x8c,0xc6,0x7e,0x3f,0x1f,0x8f,0xc7,0xe3,0xf1,0xfc,
0xc0,0x7f,0x3f,0x9f,0xcf,0xe0,0xc0,0x60,0x30,0x18,0x63,0x31,0x98,0xcc,0x66,0x33,
0x19,0x8c,0xfe,0x6b,0x31,0x98,0xcc,0x66,0x31,0xb1,0x8c,0x6c,0x0e,0x7f,0x82,0x01,
0x01,0x80,0x90,0x30,0xc6,0x08,0x01,0x02,0x00,0x40,0x80,0xe0,0x24,0x04,0x1c,0x10,
0x08,0x04,0x02,0x00,0x90,0x20,0x10,0x12,0x0d,0x86,0x00,0x81,0x00,0x40,0x20,0x10,
0x00,0x04,0x00,0x1f,0xe1,0x70,0xbb,0x28,0x00,0x30,0x03,0x00,0x01,0x00,0x00,0x00,
0x00,0x30,0x63,0x06,0x06,0x00,0x67,0xf0,0x19,0x8c,0x30,0x67,0x0d,0x80,0x00,0x01,
0x83,0xf8,0x30,0x30,0x9b,0x7f,0x19,0x8c,0x06,0x33,0x01,0x80,0xc6,0x63,0x0c,0x01,
0x8c,0xc6,0x05,0xd9,0x35,0x86,0x60,0x61,0x99,0x80,0xe1,0x83,0x18,0xd0,0xdc,0x26,
0x0c,0x0c,0x06,0x00,0xc0,0x30,0x84,0x00,0x00,0x63,0x18,0xcc,0x06,0x33,0x00,0x60,
0xc6,0x63,0x06,0x01,0x8d,0x80,0xc6,0xd9,0x8c,0xc6,0x63,0x31,0x8c,0x03,0xe1,0x83,
0x18,0xd9,0xba,0x1c,0x1b,0x06,0x01,0x80,0xc0,0xc1,0x38,0xaa,0x80,0xc0,0x7d,0xfe,
0xfe,0x7f,0x6f,0xcf,0x39,0xf7,0xfe,0xfd,0xff,0xbf,0x7f,0x0f,0xdb,0xfb,0xe3,0xef,
0xf7,0xfb,0xfd,0xff,0x6f,0xdf,0xef,0xed,0xf2,0x79,0xff,0x7e,0xff,0xbf,0xdf,0xef,
0x00,0x0c,0x19,0x03,0x03,0x60,0x60,0x30,0x66,0x00,0x28,0x4d,0xc6,0x60,0x10,0x00,
0x84,0x00,0x00,0x04,0x0f,0x87,0x80,0x03,0x18,0x14,0x38,0x00,0x3f,0x0f,0x8c,0xc2,
0x90,0x84,0xa4,0x18,0xfe,0x7f,0x3f,0x9f,0xcf,0xe7,0xf1,0xf0,0xc0,0x30,0x18,0x0c,
0x06,0x01,0x80,0xc0,0x60,0x30,0x63,0x26,0xb0,0xd8,0x6c,0x36,0x1b,0x0c,0x38,0xd3,
0x31,0x98,0xcc,0x66,0x30,0xc1,0x98,0xc6,0xc6,0x63,0x31,0x98,0xcc,0x66,0x33,0x60,
0xc0,0x60,0x30,0x18,0x0c,0x00,0xc0,0x60,0x30,0x18,0x63,0x31,0x98,0xcc,0x66,0x33,
0x19,0x8c,0x00,0x6b,0x31,0x98,0xcc,0x66,0x31,0xb1,0x8c,0x6c,0x1c,0x7f,0x81,0x20,
0x90,0x38,0x18,0x0b,0x83,0x06,0x01,0x03,0x80,0x40,0xe0,0x90,0x24,0x04,0x03,0x8e,
0x86,0xc3,0x61,0x90,0x24,0x12,0x0e,0x04,0x8a,0x81,0xc7,0x70,0xc0,0x30,0x18,0x0c,
0x00,0x00,0x00,0x04,0x81,0x31,0x6f,0x30,0x00,0x18,0x06,0x00,0x01,0x00,0x00,0x00,
0x00,0x60,0x63,0x06,0x0c,0x00,0x60,0x60,0x19,0x8c,0x60,0x63,0x01,0x80,0x00,0x00,
0xc0,0x00,0x60,0x00,0x4d,0xe1,0x99,0x8c,0x06,0x33,0x01,0x80,0xc6,0x63,0x0c,0x01,
0x8c,0xc6,0x04,0x99,0x1d,0x86,0x60,0x61,0x99,0x80,0x61,0x83,0x18,0xd0,0xdc,0x63,
0x0c,0x0c,0x06,0x00,0x60,0x30,0x84,0x00,0x00,0x63,0x18,0xcc,0x06,0x33,0x00,0x60,
0x6e,0x63,0x06,0x01,0x8c,0xc0,0xc6,0xd9,0x8c,0xc6,0x63,0x31,0x8c,0x00,0x61,0x83,
0x18,0xd0,0xcc,0x26,0x0e,0x0c,0x03,0x00,0xc0,0x60,0x01,0x54,0x98,0xc0,0x7e,0xdf,
0x6f,0xc7,0xe7,0xf4,0x7c,0xf9,0xfe,0xfc,0x7f,0xbf,0x1f,0x5f,0xdb,0xfb,0xfc,0x71,
0x79,0x3c,0x9e,0x6f,0xdb,0xed,0xf1,0xfb,0x75,0x7e,0x38,0x8f,0x3f,0xcf,0xe7,0xf3,
0xff,0x0c,0x0d,0x03,0x03,0xe1,0xf8,0x30,0x3c,0x00,0x27,0x40,0x03,0x30,0x00,0x00,
0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x18,0x14,0x00,0x00,0x00,0x00,0x19,0x82,
0xf8,0x98,0xbe,0x70,0xc3,0x61,0xb0,0xd8,0x6c,0x36,0x1b,0x30,0xc0,0x30,0x18,0x0c,
0x06,0x01,0x80,0xc0,0x60,0x30,0x63,0x23,0xb0,0xd8,0x6c,0x36,0x1b,0x0c,0x4c,0xe3,
0x31,0x98,0xcc,0x66,0x30,0xc1,0xf0,0xc6,0xc6,0x63,0x31,0x98,0xcc,0x66,0x33,0x60,
0xc0,0x60,0x30,0x18,0x0c,0x00,0xc0,0x60,0x30,0x18,0x63,0x31,0x98,0xcc,0x66,0x33,
0x19,0x8c,0x10,0x73,0x31,0x98,0xcc,0x66,0x30,0xe1,0x8c,0x38,0x1c,0x7f,0x80,0xa0,
0x50,0x10,0x24,0x0d,0xff,0x01,0x01,0x02,0x00,0x40,0x80,0xf0,0x24,0x04,0x02,0x01,
0x81,0x20,0x10,0x30,0x28,0x1a,0x09,0x06,0x8a,0x81,0x20,0x90,0x20,0x08,0x04,0x02,
0x00,0x0c,0x00,0x04,0x85,0x32,0x6f,0xb8,0x00,0x18,0x06,0x00,0x01,0x01,0xc0,0x00,
0x70,0x60,0x36,0x06,0x1f,0xcc,0xe0,0x63,0x30,0xd8,0x60,0x63,0x33,0x06,0x03,0x00,
0x60,0x00,0xc0,0x30,0x60,0x61,0x99,0x86,0x66,0x63,0x01,0x80,0x66,0x63,0x0c,0x03,
0x0c,0x66,0x04,0x19,0x1c,0xcc,0x60,0x33,0x18,0xcc,0x61,0x81,0xb0,0x60,0xcc,0x63,
0x0c,0x18,0x06,0x00,0x60,0x30,0x00,0x00,0x00,0x67,0x19,0x86,0x23,0x71,0x88,0x60,
0x36,0x63,0x06,0x01,0x8c,0x60,0xc6,0xd9,0x8c,0x6c,0x66,0x1b,0x8c,0x08,0x61,0x83,
0xb8,0x70,0xcc,0x63,0x0c,0x18,0x03,0x00,0xc0,0x60,0x00,0xaa,0x98,0xc0,0x7f,0x5f,
0xaf,0xef,0xdb,0xf2,0x00,0xfe,0xfe,0xfd,0xff,0xbf,0x7f,0x6f,0xdb,0xfb,0xfd,0xfe,
0x7e,0xdf,0xef,0xcf,0xd7,0xe5,0xf6,0xf9,0x75,0x7e,0xdf,0x6f,0xdf,0xf7,0xfb,0xfd,
0x00,0x0c,0x07,0xc6,0x04,0x10,0x60,0x30,0x06,0x00,0x10,0x80,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x3f,0x80,0x00,0x00,0x03,0xb8,0x14,0x00,0x00,0x00,0x00,0x00,0x04,
0x11,0x21,0x04,0xc0,0xc3,0x61,0xb0,0xd8,0x6c,0x36,0x1b,0x30,0x66,0x30,0x18,0x0c,
0x06,0x01,0x80,0xc0,0x60,0x30,0x66,0x23,0x99,0x8c,0xc6,0x63,0x31,0x98,0x00,0x66,
0x1b,0x0d,0x86,0xc3,0x60,0xc1,0x80,0xc6,0xce,0x67,0x33,0x99,0xcc,0xe6,0x73,0x74,
0x62,0x31,0x18,0x8c,0x46,0x20,0xc0,0x60,0x30,0x18,0x36,0x31,0x8d,0x86,0xc3,0x61,
0xb0,0xd8,0x10,0x36,0x3b,0x9d,0xce,0xe7,0x70,0xc1,0x98,0x30,0x00,0x7f,0x80,0xc0,
0x60,0x10,0x24,0x0c,0x38,0x0e,0x01,0x02,0x00,0x40,0x80,0xa0,0x18,0x0e,0x03,0x00,
0x80,0x40,0x60,0x50,0x30,0x16,0x0e,0x05,0x88,0x81,0xc0,0x81,0xc0,0x70,0x38,0x1c,
0x00,0x0c,0x00,0x04,0x83,0xe0,0x39,0xcc,0x00,0x0c,0x0c,0x00,0x00,0x01,0xc0,0x00,
0x70,0xc0,0x1c,0x06,0x1f,0xc7,0xc0,0x61,0xe0,0x70,0x60,0x3e,0x1e,0x06,0x03,0x00,
0x00,0x00,0x00,0x30,0x1e,0x61,0x9f,0x03,0xc7,0xc3,0xf1,0x80,0x3e,0x63,0x3f,0x1e,
0x0c,0x67,0xe4,0x19,0x0c,0x78,0x60,0x1e,0x18,0xc7,0xc1,0x80,0xe0,0x60,0xcc,0x63,
0x0c,0x1f,0xc6,0x00,0x30,0x30,0x00,0x00,0x00,0x3b,0x9f,0x03,0xc1,0xb0,0xf0,0x60,
0x06,0x63,0x06,0x01,0x8c,0x70,0xc6,0xd9,0x8c,0x38,0x7c,0x0d,0x8c,0x07,0xc0,0xf1,
0xd8,0x60,0xcc,0x63,0x0c,0x1f,0xc3,0x00,0xc0,0x60,0x01,0x54,0x80,0xc0,0x7f,0x3f,
0x9f,0xef,0xdb,0xf3,0xc7,0xf1,0xfe,0xfd,0xff,0xbf,0x7f,0xff,0xe7,0xf1,0xfc,0xff,
0x7f,0xbf,0x9f,0xaf,0xcf,0xe9,0xf1,0xfa,0x77,0x7e,0x3f,0x7e,0x3f,0x8f,0xc7,0xe3,
0xff,0x0c,0x01,0x0f,0xe8,0x08,0x60,0x30,0xc6,0x00,0x0f,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xd8,0x14,0x00,0x00,0x00,0x00,0x00,0x04,
0x11,0x3d,0x04,0xc0,0xc3,0x61,0xb0,0xd8,0x6c,0x36,0x1b,0x3c,0x3c,0x3f,0x1f,0x8f,
0xc7,0xe7,0xe3,0xf1,0xf8,0xfc,0x7c,0x21,0x8f,0x07,0x83,0xc1,0xe0,0xf0,0x00,0xbc,
0x0e,0x07,0x03,0x81,0xc0,0xc1,0x80,0xcc,0x77,0x3b,0x9d,0xce,0xe7,0x73,0xb9,0x98,
0x3c,0x1e,0x0f,0x07,0x83,0xc0,0xc0,0x60,0x30,0x18,0x1c,0x31,0x87,0x03,0x81,0xc0,
0xe0,0x70,0x00,0x5c,0x1d,0x8e,0xc7,0x63,0xb0,0xc1,0xf0,0x30,0x00,0x7f,0x81,0x40,
0xa0,0x10,0x28,0x0a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x90,0x00,0x00,0x02,0x00,
0x80,0x80,0x10,0xf8,0x28,0x12,0x09,0x04,0x80,0x01,0x20,0x80,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x06,0x18,0x00,0x00,0x00,0x40,0x00,
0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x07,0xc0,0x31,0xf0,0x01,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xcc,0x00,0x00,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x60,0x01,0x80,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x18,0x00,0x01,0xe0,0xc3,0xc0,0x00,0x00,0xff,0xc0,0x7e,0xbf,
0x5f,0xef,0xd7,0xf5,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfd,0xff,
0x7f,0x7f,0xef,0x07,0xd7,0xed,0xf6,0xfb,0x7f,0xfe,0xdf,0x7f,0xff,0xff,0xff,0xff,
0x00,0x0c,0x01,0x00,0x00,0x00,0x00,0x30,0x7c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x14,0x00,0x08,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0xc6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x81,0x80,0x60,0x00,0x7f,0x81,0x20,
0x90,0x10,0x1c,0x0a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x80,
0x81,0xe0,0x60,0x10,0x24,0x12,0x0e,0x04,0x80,0x01,0xc0,0x70,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x78,0x00,0x00,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x01,0x80,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7f,0xfe,0xdf,
0x6f,0xef,0xe3,0xf5,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,0x7f,
0x7e,0x1f,0x9f,0xef,0xdb,0xed,0xf1,0xfb,0x7f,0xfe,0x3f,0x8f,0xff,0xff,0xff,0xff,
0x00,0x0c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x7c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x81,0x80,0x60,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x32,0x35,0x36,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x31,0x35,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x31,0x33,0x20,
0x00,0x00,0x01,0x0c,0x00,0x09,0x09,0x00,0x01,0x0f,0x00,0x09,0x12,0x00,0x01,0x0f,
0x00,0x09,0x1b,0x00,0x01,0x0f,0x00,0x09,0x24,0x00,0x01,0x0f,0x00,0x09,0x2d,0x00,
0x01,0x0f,0x00,0x09,0x36,0x00,0x01,0x0f,0x00,0x09,0x3f,0x00,0x03,0x0d,0x00,0x09,
0x48,0x00,0x03,0x0d,0x00,0x09,0x51,0x00,0x03,0x0d,0x00,0x09,0x5a,0x00,0x03,0x0d,
0x00,0x09,0x63,0x00,0x03,0x0d,0x00,0x09,0x6c,0x00,0x03,0x0d,0x00,0x09,0x75,0x00,
0x03,0x0e,0x00,0x09,0x7e,0x00,0x03,0x0d,0x00,0x09,0x87,0x00,0x03,0x0d,0x00,0x09,
0x90,0x00,0x01,0x0f,0x00,0x09,0x99,0x00,0x01,0x0f,0x00,0x09,0xa2,0x00,0x01,0x0f,
0x00,0x09,0xab,0x00,0x01,0x0f,0x00,0x09,0xb4,0x00,0x01,0x0f,0x00,0x09,0xbd,0x00,
0x01,0x0f,0x00,0x09,0xc6,0x00,0x01,0x0f,0x00,0x09,0xcf,0x00,0x01,0x0f,0x00,0x09,
0xd8,0x00,0x01,0x0f,0x00,0x09,0xe1,0x00,0x03,0x0d,0x00,0x09,0xea,0x00,0x01,0x0f,
0x00,0x09,0xf3,0x00,0x01,0x0f,0x00,0x09,0xfc,0x00,0x03,0x0d,0x00,0x09,0x05,0x01,
0x03,0x0d,0x00,0x09,0x0e,0x01,0x03,0x0d,0x00,0x09,0x17,0x01,0x03,0x0d,0x00,0x09,
0x20,0x01,0x00,0x00,0x00,0x09,0x29,0x01,0x03,0x0d,0x00,0x09,0x32,0x01,0x02,0x05,
0x00,0x09,0x3b,0x01,0x03,0x0d,0x00,0x09,0x44,0x01,0x02,0x0e,0x00,0x09,0x4d,0x01,
0x03,0x0d,0x00,0x09,0x56,0x01,0x03,0x0d,0x00,0x09,0x5f,0x01,0x02,0x06,0x00,0x09,
0x68,0x01,0x02,0x0e,0x00,0x09,0x71,0x01,0x02,0x0e,0x00,0x09,0x7a,0x01,0x03,0x08,
0x00,0x09,0x83,0x01,0x05,0x0c,0x00,0x09,0x8c,0x01,0x0b,0x0f,0x00,0x09,0x95,0x01,
0x08,0x09,0x00,0x09,0x9e,0x01,0x0b,0x0d,0x00,0x09,0xa7,0x01,0x02,0x0e,0x00,0x09,
0xb0,0x01,0x03,0x0d,0x00,0x09,0xb9,0x01,0x03,0x0d,0x00,0x09,0xc2,0x01,0x03,0x0d,
0x00,0x09,0xcb,0x01,0x03,0x0d,0x00,0x09,0xd4,0x01,0x03,0x0d,0x00,0x09,0xdd,0x01,
0x03,0x0d,0x00,0x09,0xe6,0x01,0x03,0x0d,0x00,0x09,0xef,0x01,0x03,0x0d,0x00,0x09,
0xf8,0x01,0x03,0x0d,0x00,0x09,0x01,0x02,0x03,0x0d,0x00,0x09,0x0a,0x02,0x06,0x0d,
0x00,0x09,0x13,0x02,0x06,0x0f,0x00,0x09,0x1c,0x02,0x05,0x0c,0x00,0x09,0x25,0x02,
0x07,0x0a,0x00,0x09,0x2e,0x02,0x05,0x0c,0x00,0x09,0x37,0x02,0x03,0x0d,0x00,0x09,
0x40,0x02,0x03,0x0d,0x00,0x09,0x49,0x02,0x03,0x0d,0x00,0x09,0x52,0x02,0x03,0x0d,
0x00,0x09,0x5b,0x02,0x03,0x0d,0x00,0x09,0x64,0x02,0x03,0x0d,0x00,0x09,0x6d,0x02,
0x03,0x0d,0x00,0x09,0x76,0x02,0x03,0x0d,0x00,0x09,0x7f,0x02,0x03,0x0d,0x00,0x09,
0x88,0x02,0x03,0x0d,0x00,0x09,0x91,0x02,0x03,0x0d,0x00,0x09,0x9a,0x02,0x03,0x0d,
0x00,0x09,0xa3,0x02,0x03,0x0d,0x00,0x09,0xac,0x02,0x03,0x0d,0x00,0x09,0xb5,0x02,
0x03,0x0d,0x00,0x09,0xbe,0x02,0x03,0x0d,0x00,0x09,0xc7,0x02,0x03,0x0d,0x00,0x09,
0xd0,0x02,0x03,0x0d,0x00,0x09,0xd9,0x02,0x03,0x0f,0x00,0x09,0xe2,0x02,0x03,0x0d,
0x00,0x09,0xeb,0x02,0x03,0x0d,0x00,0x09,0xf4,0x02,0x03,0x0d,0x00,0x09,0xfd,0x02,
0x03,0x0d,0x00,0x09,0x06,0x03,0x03,0x0d,0x00,0x09,0x0f,0x03,0x03,0x0d,0x00,0x09,
0x18,0x03,0x03,0x0d,0x00,0x09,0x21,0x03,0x03,0x0d,0x00,0x09,0x2a,0x03,0x03,0x0d,
0x00,0x09,0x33,0x03,0x02,0x0e,0x00,0x09,0x3c,0x03,0x02,0x0e,0x00,0x09,0x45,0x03,
0x02,0x0e,0x00,0x09,0x4e,0x03,0x04,0x0b,0x00,0x09,0x57,0x03,0x0d,0x0e,0x00,0x09,
0x60,0x03,0x02,0x06,0x00,0x09,0x69,0x03,0x05,0x0d,0x00,0x09,0x72,0x03,0x02,0x0d,
0x00,0x09,0x7b,0x03,0x05,0x0d,0x00,0x09,0x84,0x03,0x02,0x0d,0x00,0x09,0x8d,0x03,
0x05,0x0d,0x00,0x09,0x96,0x03,0x02,0x0d,0x00,0x09,0x9f,0x03,0x05,0x0f,0x00,0x09,
0xa8,0x03,0x02,0x0d,0x00,0x09,0xb1,0x03,0x02,0x0d,0x00,0x09,0xba,0x03,0x02,0x0f,
0x00,0x09,0xc3,0x03,0x02,0x0d,0x00,0x09,0xcc,0x03,0x02,0x0d,0x00,0x09,0xd5,0x03,
0x05,0x0d,0x00,0x09,0xde,0x03,0x05,0x0d,0x00,0x09,0xe7,0x03,0x05,0x0d,0x00,0x09,
0xf0,0x03,0x05,0x0f,0x00,0x09,0xf9,0x03,0x05,0x0f,0x00,0x09,0x02,0x04,0x05,0x0d,
0x00,0x09,0x0b,0x04,0x05,0x0d,0x00,0x09,0x14,0x04,0x03,0x0d,0x00,0x09,0x1d,0x04,
0x05,0x0d,0x00,0x09,0x26,0x04,0x05,0x0d,0x00,0x09,0x2f,0x04,0x05,0x0d,0x00,0x09,
0x38,0x04,0x05,0x0d,0x00,0x09,0x41,0x04,0x05,0x0f,0x00,0x09,0x4a,0x04,0x05,0x0d,
0x00,0x09,0x53,0x04,0x02,0x0e,0x00,0x09,0x5c,0x04,0x02,0x0e,0x00,0x09,0x65,0x04,
0x02,0x0e,0x00,0x09,0x6e,0x04,0x07,0x0a,0x00,0x09,0x77,0x04,0x01,0x0d,0x00,0x09,
0x80,0x04,0x00,0x0e,0x00,0x09,0x89,0x04,0x00,0x0f,0x00,0x09,0x92,0x04,0x00,0x0f,
0x00,0x09,0x9b,0x04,0x00,0x0f,0x00,0x09,0xa4,0x04,0x00,0x0f,0x00,0x09,0xad,0x04,
0x00,0x0f,0x00,0x09,0xb6,0x04,0x00,0x0f,0x00,0x09,0xbf,0x04,0x00,0x0f,0x00,0x09,
0xc8,0x04,0x00,0x0f,0x00,0x09,0xd1,0x04,0x00,0x0f,0x00,0x09,0xda,0x04,0x00,0x0f,
0x00,0x09,0xe3,0x04,0x00,0x0f,0x00,0x09,0xec,0x04,0x00,0x0f,0x00,0x09,0xf5,0x04,
0x00,0x0f,0x00,0x09,0xfe,0x04,0x00,0x0f,0x00,0x09,0x07,0x05,0x00,0x0f,0x00,0x09,
0x10,0x05,0x00,0x0f,0x00,0x09,0x19,0x05,0x00,0x0f,0x00,0x09,0x22,0x05,0x00,0x0f,
0x00,0x09,0x2b,0x05,0x00,0x0f,0x00,0x09,0x34,0x05,0x00,0x0f,0x00,0x09,0x3d,0x05,
0x00,0x0f,0x00,0x09,0x46,0x05,0x00,0x0f,0x00,0x09,0x4f,0x05,0x00,0x0f,0x00,0x09,
0x58,0x05,0x00,0x0f,0x00,0x09,0x61,0x05,0x00,0x0f,0x00,0x09,0x6a,0x05,0x00,0x0f,
0x00,0x09,0x73,0x05,0x00,0x0f,0x00,0x09,0x7c,0x05,0x00,0x0f,0x00,0x09,0x85,0x05,
0x00,0x0f,0x00,0x09,0x8e,0x05,0x00,0x0f,0x00,0x09,0x97,0x05,0x00,0x0f,0x00,0x09,
0xa0,0x05,0x00,0x0d,0x00,0x09,0xa9,0x05,0x05,0x0f,0x00,0x09,0xb2,0x05,0x02,0x0e,
0x00,0x09,0xbb,0x05,0x03,0x0d,0x00,0x09,0xc4,0x05,0x03,0x0d,0x00,0x09,0xcd,0x05,
0x03,0x0d,0x00,0x09,0xd6,0x05,0x02,0x0e,0x00,0x09,0xdf,0x05,0x03,0x0e,0x00,0x09,
0xe8,0x05,0x02,0x04,0x00,0x09,0xf1,0x05,0x03,0x0d,0x00,0x09,0xfa,0x05,0x03,0x0a,
0x00,0x09,0x03,0x06,0x06,0x0b,0x00,0x09,0x0c,0x06,0x07,0x0a,0x00,0x09,0x15,0x06,
0x08,0x09,0x00,0x09,0x1e,0x06,0x03,0x0b,0x00,0x09,0x27,0x06,0x02,0x03,0x00,0x09,
0x30,0x06,0x03,0x07,0x00,0x09,0x39,0x06,0x05,0x0c,0x00,0x09,0x42,0x06,0x03,0x0a,
0x00,0x09,0x4b,0x06,0x03,0x0a,0x00,0x09,0x54,0x06,0x02,0x04,0x00,0x09,0x5d,0x06,
0x05,0x0f,0x00,0x09,0x66,0x06,0x03,0x0e,0x00,0x09,0x6f,0x06,0x08,0x0a,0x00,0x09,
0x78,0x06,0x0d,0x0f,0x00,0x09,0x81,0x06,0x03,0x0a,0x00,0x09,0x8a,0x06,0x03,0x0a,
0x00,0x09,0x93,0x06,0x06,0x0b,0x00,0x09,0x9c,0x06,0x03,0x0d,0x00,0x09,0xa5,0x06,
0x03,0x0d,0x00,0x09,0xae,0x06,0x03,0x0d,0x00,0x09,0xb7,0x06,0x05,0x0f,0x00,0x09,
0xc0,0x06,0x00,0x0d,0x00,0x09,0xc9,0x06,0x00,0x0d,0x00,0x09,0xd2,0x06,0x00,0x0d,
0x00,0x09,0xdb,0x06,0x00,0x0d,0x00,0x09,0xe4,0x06,0x00,0x0d,0x00,0x09,0xed,0x06,
0x01,0x0d,0x00,0x09,0xf6,0x06,0x03,0x0d,0x00,0x09,0xff,0x06,0x03,0x0f,0x00,0x09,
0x08,0x07,0x00,0x0d,0x00,0x09,0x11,0x07,0x00,0x0d,0x00,0x09,0x1a,0x07,0x00,0x0d,
0x00,0x09,0x23,0x07,0x00,0x0d,0x00,0x09,0x2c,0x07,0x00,0x0d,0x00,0x09,0x35,0x07,
0x00,0x0d,0x00,0x09,0x3e,0x07,0x00,0x0d,0x00,0x09,0x47,0x07,0x00,0x0d,0x00,0x09,
0x50,0x07,0x03,0x0d,0x00,0x09,0x59,0x07,0x00,0x0d,0x00,0x09,0x62,0x07,0x00,0x0d,
0x00,0x09,0x6b,0x07,0x00,0x0d,0x00,0x09,0x74,0x07,0x00,0x0d,0x00,0x09,0x7d,0x07,
0x00,0x0d,0x00,0x09,0x86,0x07,0x00,0x0d,0x00,0x09,0x8f,0x07,0x06,0x0b,0x00,0x09,
0x98,0x07,0x03,0x0d,0x00,0x09,0xa1,0x07,0x00,0x0d,0x00,0x09,0xaa,0x07,0x00,0x0d,
0x00,0x09,0xb3,0x07,0x00,0x0d,0x00,0x09,0xbc,0x07,0x00,0x0d,0x00,0x09,0xc5,0x07,
0x00,0x0d,0x00,0x09,0xce,0x07,0x03,0x0d,0x00,0x09,0xd7,0x07,0x02,0x0d,0x00,0x09,
0xe0,0x07,0x02,0x0d,0x00,0x09,0xe9,0x07,0x02,0x0d,0x00,0x09,0xf2,0x07,0x02,0x0d,
0x00,0x09,0xfb,0x07,0x02,0x0d,0x00,0x09,0x04,0x08,0x02,0x0d,0x00,0x09,0x0d,0x08,
0x02,0x0d,0x00,0x09,0x16,0x08,0x05,0x0d,0x00,0x09,0x1f,0x08,0x05,0x0f,0x00,0x09,
0x28,0x08,0x02,0x0d,0x00,0x09,0x31,0x08,0x02,0x0d,0x00,0x09,0x3a,0x08,0x02,0x0d,
0x00,0x09,0x43,0x08,0x02,0x0d,0x00,0x09,0x4c,0x08,0x02,0x0d,0x00,0x09,0x55,0x08,
0x02,0x0d,0x00,0x09,0x5e,0x08,0x02,0x0d,0x00,0x09,0x67,0x08,0x02,0x0d,0x00,0x09,
0x70,0x08,0x02,0x0d,0x00,0x09,0x79,0x08,0x02,0x0d,0x00,0x09,0x82,0x08,0x02,0x0d,
0x00,0x09,0x8b,0x08,0x02,0x0d,0x00,0x09,0x94,0x08,0x02,0x0d,0x00,0x09,0x9d,0x08,
0x02,0x0d,0x00,0x09,0xa6,0x08,0x02,0x0d,0x00,0x09,0xaf,0x08,0x05,0x0c,0x00,0x09,
0xb8,0x08,0x05,0x0d,0x00,0x09,0xc1,0x08,0x02,0x0d,0x00,0x09,0xca,0x08,0x02,0x0d,
0x00,0x09,0xd3,0x08,0x02,0x0d,0x00,0x09,0xdc,0x08,0x02,0x0d,0x00,0x09,0xe5,0x08,
0x02,0x0f,0x00,0x09,0xee,0x08,0x03,0x0f,0x00,0x09,0xf7,0x08,0x02,0x0f,0x00,0x09,
0x00,0x09,0x00,0x00,0x00,0x00,
};
@



%-------------------------------------------------------------

<<lib_graphics/libdraw/defont.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <font.h>

// This file is one of the very few files linked by the kernel, because
// of defontdata. Do not add functions in this file with complex dependencies,
// otherwise they will be linked also with the kernel.

<<global [[defontdata]]>>

<<global [[sizeofdefont]]>>

<<function [[_unpackinfo]]>>

@

\subsection{[[lib_graphics/libdraw/draw.c]]}
%pad: I moved border.c here

%-------------------------------------------------------------

<<lib_graphics/libdraw/draw.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <draw_private.h>

<<function [[_setdrawop]]>>
        
<<function [[draw1]]>>

<<function [[draw]]>>

<<function [[drawop]]>>

<<function [[gendraw]]>>

<<function [[gendrawop]]>>

<<function [[border]]>>
@

%\subsection{[[lib_graphics/libdraw/border.c]]}

\subsection{[[lib_graphics/libdraw/line.c]]}


%-------------------------------------------------------------

<<lib_graphics/libdraw/line.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <draw_private.h>

<<function [[line]]>>

<<function [[lineop]]>>
@

\subsection{[[lib_graphics/libdraw/poly.c]]}

%-------------------------------------------------------------

<<lib_graphics/libdraw/poly.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <draw_private.h>

<<function [[addcoord]]>>

<<function [[dopoly]]>>

<<function [[poly]]>>

<<function [[polyop]]>>

<<function [[fillpoly]]>>

<<function [[fillpolyop]]>>
@


\subsection{[[lib_graphics/libdraw/ellipse.c]]}


%-------------------------------------------------------------

<<lib_graphics/libdraw/ellipse.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <draw_private.h>

<<function [[doellipse]]>>

<<function [[ellipse]]>>

<<function [[ellipseop]]>>

<<function [[fillellipse]]>>

<<function [[fillellipseop]]>>

<<function [[arc]]>>

<<function [[arcop]]>>

<<function [[fillarc]]>>

<<function [[fillarcop]]>>
@


\subsection{[[lib_graphics/libdraw/bezier.c]]}


%-------------------------------------------------------------

<<lib_graphics/libdraw/bezier.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<constant [[PINC]]>>

typedef struct Plist Plist;
<<struct [[Plist]]>>

<<function [[appendpt]]>>

<<function [[normsq]]>>

<<function [[psdist]]>>

<<function [[bpts1]]>>

<<function [[bpts]]>>

<<function [[bezierpts]]>>

<<function [[_bezsplinepts]]>>

<<function [[bezsplinepts]]>>

<<function [[bezier]]>>

<<function [[bezierop]]>>

<<function [[bezspline]]>>

<<function [[bezsplineop]]>>

<<function [[fillbezier]]>>

<<function [[fillbezierop]]>>

<<function [[fillbezspline]]>>

<<function [[fillbezsplineop]]>>
@







\subsection{[[lib_graphics/libdraw/fontcache.c]]}
%pad: was called font.c but fontcache.c is a far better name

%dead:
%<<function freeup>>=
%/* release all subfonts, return number freed */
%static
%int
%freeup(Font *f)
%{
%    Cachesubf *s, *es;
%    int nf;
%
%    if(f->sub[0]->name == nil)	/* font from mkfont; don't free */
%        return 0;
%    s = f->subf;
%    es = s+f->nsubf;
%    nf = 0;
%    while(s < es){
%        if(s->age){
%            freesubfont(s->f);
%            s->cf = nil;
%            s->f = nil;
%            s->age = 0;
%            nf++;
%        }
%        s++;
%    }
%    return nf;
%}
%@



%-------------------------------------------------------------

<<lib_graphics/libdraw/fontcache.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <draw_private.h>
#include <font.h>

static int	fontresize(Font*, int, int, int);

<<constant [[PJW]]>>

<<function [[cachechars]]>>

<<function [[agefont]]>>

<<function [[cf2subfont]]>>

<<function [[loadchar]]>>

<<function [[fontresize]]>>
@


\subsection{[[lib_graphics/libdraw/font.c]]}
%pad: was called buildfont.c, but better to call it font.c.


%-------------------------------------------------------------

<<lib_graphics/libdraw/font.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <draw_private.h>
#include <font.h>

<<function [[skip]]>>


<<function [[openfont]]>>

<<function [[buildfont]]>>

<<function [[freefont]]>>
@


%\subsection{[[lib_graphics/libdraw/mkfont.c]]}
%mkfont.c: dead (used in very few apps)

%dead: seems dead, with code quite similar to buildfont
% <<function mkfont>>=
% /*
%  * Cobble fake font using existing subfont
%  */
% Font*
% mkfont(Subfont *subfont, Rune min)
% {
%     Font *font;
%     Cachefont *c;
% 
%     font = malloc(sizeof(Font));
%     if(font == nil)
%         return nil;
%     memset(font, 0, sizeof(Font));
%     font->display = subfont->bits->display;
%     font->name = strdup("<synthetic>");
% 
%     font->ncache = NFCACHE+NFLOOK;
%     font->nsubf = NFSUBF;
%     font->cache = malloc(font->ncache * sizeof(font->cache[0]));
%     font->subf = malloc(font->nsubf * sizeof(font->subf[0]));
%     if(font->name==nil || font->cache==nil || font->subf==nil){
%     Err:
%         free(font->name);
%         free(font->cache);
%         free(font->subf);
%         free(font->sub);
%         free(font);
%         return 0;
%     }
%     memset(font->cache, 0, font->ncache*sizeof(font->cache[0]));
%     memset(font->subf, 0, font->nsubf*sizeof(font->subf[0]));
% 
%     font->height = subfont->height;
%     font->ascent = subfont->ascent;
%     font->age = 1;
%     font->sub = malloc(sizeof(Cachefont*));
%     if(font->sub == 0)
%         goto Err;
%     c = malloc(sizeof(Cachefont));
%     if(c == 0)
%         goto Err;
%     font->nsub = 1;
%     font->sub[0] = c;
%     c->min = min;
%     c->max = min+subfont->n-1;
%     c->offset = 0;
%     c->name = nil;	/* noticed by freeup() and agefont() */
%     c->subfontname = nil;
%     font->subf[0].age = 0;
%     font->subf[0].cf = c;
%     font->subf[0].f = subfont;
%     return font;
% }
% @

%\subsection{[[lib_graphics/libdraw/openfont.c]]}




\subsection{[[lib_graphics/libdraw/colormap.c]]}
%pad: I created this file; I merged readcolmap.c and writecolmap.c

<<lib_graphics/libdraw/colormap.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <bio.h>

<<function [[getval]]>>

<<function [[readcolmap]]>>

<<function [[writecolmap]]>>

<<function [[rgb2cmap]]>>

<<function [[cmap2rgb]]>>

<<function [[cmap2rgba]]>>

@

%\subsection{[[lib_graphics/libdraw/readcolmap.c]]}

%\subsection{[[lib_graphics/libdraw/writecolmap.c]]}

%\subsection{[[lib_graphics/libdraw/rgb.c]]}

%dead:
%/*
% * This original version, although fast and a true inverse of
% * cmap2rgb, in the sense that rgb2cmap(cmap2rgb(c))
% * returned the original color, does a terrible job for RGB
% * triples that do not appear in the color map, so it has been
% * replaced by the much slower version below, that loops
% * over the color map looking for the nearest point in RGB
% * space.  There is no visual psychology reason for that
% * criterion, but it's easy to implement and the results are
% * far more pleasing. 
% *
%int
%rgb2cmap(int cr, int cg, int cb)
%{
%    int r, g, b, v, cv;
%
%    if(cr < 0)
%        cr = 0;
%    else if(cr > 255)
%        cr = 255;
%    if(cg < 0)
%        cg = 0;
%    else if(cg > 255)
%        cg = 255;
%    if(cb < 0)
%        cb = 0;
%    else if(cb > 255)
%        cb = 255;
%    r = cr>>6;
%    g = cg>>6;
%    b = cb>>6;
%    cv = cr;
%    if(cg > cv)
%        cv = cg;
%    if(cb > cv)
%        cv = cb;
%    v = (cv>>4)&3;
%    return ((((r<<2)+v)<<4)+(((g<<2)+b+v-r)&15));
%}



\subsection{[[lib_graphics/libdraw/replclipr.c]]}
%pad: I put rectclip.c and drawrepl.c here

%-------------------------------------------------------------

<<lib_graphics/libdraw/replclipr.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <draw_private.h>

<<function [[replclipr]]>>


<<function [[rectclip]]>>

<<function [[drawreplxy]]>>

<<function [[drawrepl]]>>

@

%\subsection{[[lib_graphics/libdraw/rectclip.c]]}

%\subsection{[[lib_graphics/libdraw/drawrepl.c]]}


\subsection{[[lib_graphics/libdraw/string.c]]}
%pad: I merged stringbg.c here

<<enum [[_anon_]]([[(lib_graphics/libdraw/string.c)]])>>=
enum
{
<<constant [[Max]]>>
};
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/string.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <draw_private.h>
#include <font.h>

<<enum [[_anon_]]([[(lib_graphics/libdraw/string.c)]])>>

Point
_string(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, Rune *r, int len, Rectangle clipr, Image *bg, Point bgp, Drawop op);

<<function [[string]]>>

<<function [[stringop]]>>

<<function [[stringn]]>>

<<function [[stringnop]]>>

<<function [[runestring]]>>

<<function [[runestringop]]>>

<<function [[runestringn]]>>

<<function [[runestringnop]]>>

<<function [[_string]]>>

<<function [[stringbg]]>>

<<function [[stringbgop]]>>

<<function [[stringnbg]]>>

<<function [[stringnbgop]]>>

<<function [[runestringbg]]>>

<<function [[runestringbgop]]>>

<<function [[runestringnbg]]>>

<<function [[runestringnbgop]]>>
@


%\subsection{[[lib_graphics/libdraw/stringbg.c]]}


\subsection{[[lib_graphics/libdraw/stringwidth.c]]}


%-------------------------------------------------------------

<<lib_graphics/libdraw/stringwidth.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <draw_private.h>
#include <font.h>

<<enum [[_anon_]]([[(lib_graphics/libdraw/stringwidth.c)]])>>

<<function [[_stringnwidth]]>>

<<function [[stringnwidth]]>>

<<function [[stringwidth]]>>

<<function [[stringsize]]>>

<<function [[runestringnwidth]]>>

<<function [[runestringwidth]]>>

<<function [[runestringsize]]>>
@


\subsection{[[lib_graphics/libdraw/subfont.c]]}
%pad: I merged many files here.

%-------------------------------------------------------------

<<lib_graphics/libdraw/subfont.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <draw_private.h>
#include <font.h>

// Do not put this function in defont.c! Otherwise it will create a chain
// of dependencies that will force the kernel to link in lockdisplay().
// This in turn will generate a signature conflict because of the differences
// between QLock (used in Display) in libc.h and in the kernel (in lib.h).
<<function [[getdefont]]>>


<<function [[allocsubfont]]>>

<<function [[freesubfont]]>>

<<function [[_getsubfont]]>>

<<function [[readsubfont]]>>

<<function [[packinfo]]>>

<<function [[writesubfont]]>>


<<function [[subfontname]]>>

/*
 * Easy versions of the cache routines; may be substituted by fancier ones for other purposes
 */

<<global [[lastname]]>>
<<global [[lastsubfont]]>>

<<function [[lookupsubfont]]>>

<<function [[installsubfont]]>>

<<function [[uninstallsubfont]]>>

@


%\subsection{[[lib_graphics/libdraw/getsubfont.c]]}

%\subsection{[[lib_graphics/libdraw/freesubfont.c]]}

%\subsection{[[lib_graphics/libdraw/readsubfont.c]]}
%dead: merged with readsubfont <<function readsubfonti>>

%\subsection{[[lib_graphics/libdraw/stringsubfont.c]]}
%stringsubfont.c: dead (or used in test code)

%dead: <<function stringsubfont>>
%dead: <<function strsubfontwidth>>
%dead:
%   <<function stringsubfont>>=
%   Point
%   stringsubfont(Image *b, Point p, Image *color, Subfont *f, char *cs)
%   {
%       int w, width;
%       uchar *s;
%       Rune c;
%       Fontchar *i;
%   
%       s = (uchar*)cs;
%       for(; c=*s; p.x+=width){
%           width = 0;
%           if(c < Runeself)
%               s++;
%           else{
%               w = chartorune(&c, (char*)s);
%               if(w == 0){
%                   s++;
%                   continue;
%               }
%               s += w;
%           }
%           if(c >= f->n)
%               continue;
%           i = f->info+c;
%           width = i->width;
%           draw(b, Rect(p.x+i->left, p.y+i->top, p.x+i->left+(i[1].x-i[0].x), p.y+i->bottom),
%               color, f->bits, Pt(i->x, i->top));
%       }
%       return p;
%   }
%   @
%   
%   <<function strsubfontwidth>>=
%   Point
%   strsubfontwidth(Subfont *f, char *cs)
%   {
%       Rune c;
%       Point p;
%       uchar *s;
%       Fontchar *i;
%       int w, width;
%   
%       p = Pt(0, f->height);
%       s = (uchar*)cs;
%       for(; c=*s; p.x+=width){
%           width = 0;
%           if(c < Runeself)
%               s++;
%           else{
%               w = chartorune(&c, (char*)s);
%               if(w == 0){
%                   s++;
%                   continue;
%               }
%               s += w;
%           }
%           if(c >= f->n)
%               continue;
%           i = f->info+c;
%           width = i->width;
%       }
%       return p;
%   }
%   @


%\subsection{[[lib_graphics/libdraw/writesubfont.c]]}

%\subsection{[[lib_graphics/libdraw/getdefont.c]]}

%\subsection{[[lib_graphics/libdraw/subfontname.c]]}

%\subsection{[[lib_graphics/libdraw/subfontcache.c]]}


\subsection{[[lib_graphics/libdraw/desktop.c]]}
%pad: I created this file; its content was in window.c before.
% I also moved screen here; it was in init.c before.

%-------------------------------------------------------------

<<lib_graphics/libdraw/desktop.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <window.h>
#include <draw_private.h>

<<global [[screenid]]>>


<<function [[allocscreen]]>>

<<function [[publicscreen]]>>

<<function [[freescreen]]>>

@

\subsection{[[lib_graphics/libdraw/window.c]]}
%pad: I moved gengetwindow here; it was in init.c before.

%-------------------------------------------------------------

<<lib_graphics/libdraw/window.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <window.h>
#include <draw_private.h>

// see getwindow()
<<global [[screen]]>>

<<function [[_allocwindow]]>>

<<function [[allocwindow]]>>



<<function [[gengetwindow]]>>

<<function [[getwindow]]>>




<<function [[topbottom]]>>

<<function [[bottomwindow]]>>

<<function [[topwindow]]>>

<<function [[bottomnwindows]]>>

<<function [[topnwindows]]>>

<<function [[originwindow]]>>


<<function [[newwindow]]>>
@

%\subsection{[[lib_graphics/libdraw/newwindow.c]]}







\subsection{[[lib_graphics/libdraw/transfer.c]]}
%pad: I created this file; I merged loadimage.c and unloadimage.c.

%-------------------------------------------------------------

<<lib_graphics/libdraw/transfer.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <draw_private.h>

<<function [[loadimage]]>>

<<function [[unloadimage]]>>
@

%\subsection{[[lib_graphics/libdraw/loadimage.c]]}

%\subsection{[[lib_graphics/libdraw/unloadimage.c]]}




\subsection{[[lib_graphics/libdraw/io.c]]}
%pad: I created this file; I merged readimage.c and writeimage.c


%-------------------------------------------------------------

<<lib_graphics/libdraw/io.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <draw_private.h>

<<function [[readimage]]>>

// writeimage() is in compressed.c. It does not support the 
// regular (uncompressed) format.
@

%\subsection{[[lib_graphics/libdraw/readimage.c]]}

%\subsection{[[lib_graphics/libdraw/writeimage.c]]}




\subsection{[[lib_graphics/libdraw/compressed.c]]}
%pad: I created this file; its content was in cloadimage.c/computil.c before


%-------------------------------------------------------------

<<lib_graphics/libdraw/compressed.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <draw_private.h>

<<function [[_twiddlecompressed]]>>

<<function [[_compblocksize]]>>

<<function [[cloadimage]]>>

<<function [[creadimage]]>>

<<constant [[HSHIFT]]>>
<<constant [[NHASH]]>>
<<constant [[HMASK]]>>
<<function [[hupdate]]>>

typedef struct Hlist Hlist;
<<struct [[Hlist]]>>

<<function [[writeimage]]>>

@
% cwriteimage?

%\subsection{[[lib_graphics/libdraw/cloadimage.c]]}

%\subsection{[[lib_graphics/libdraw/computil.c]]}

%\subsection{[[lib_graphics/libdraw/creadimage.c]]}


\subsection{[[lib_graphics/libdraw/keyboard.c]]}

%-------------------------------------------------------------

<<lib_graphics/libdraw/keyboard.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <keyboard.h>

<<function [[_ioproc]]>>

<<function [[ctlkeyboard]]>>

<<function [[initkeyboard]]>>


<<function [[closekeyboard]]>>


@


\subsection{[[lib_graphics/libdraw/mouse.c]]}

%-------------------------------------------------------------

<<lib_graphics/libdraw/mouse.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <draw_private.h>
#include <thread.h>
#include <cursor.h>
#include <mouse.h>

<<function [[moveto]]>>

<<function [[readmouse]]>>

<<function [[_ioproc]]([[(lib_graphics/libdraw/mouse.c)]])>>

<<function [[initmouse]]>>

<<function [[setcursor]]>>

<<function [[closemouse]]>>


<<function [[mousescrollsize]]>>

@


%\subsection{[[lib_graphics/libdraw/scroll.c]]}

\subsection{[[lib_graphics/libdraw/menuhit.c]]}


%-------------------------------------------------------------

<<lib_graphics/libdraw/menuhit.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <draw_private.h>
#include <window.h>
#include <thread.h>
#include <mouse.h>

<<enum [[_anon_]]([[(lib_graphics/libdraw/menuhit.c)]])>>

<<global [[menutxt]]([[(lib_graphics/libdraw/menuhit.c)]])>>
<<global [[back]]([[(lib_graphics/libdraw/menuhit.c)]])>>
<<global [[high]]([[(lib_graphics/libdraw/menuhit.c)]])>>
<<global [[bord]]([[(lib_graphics/libdraw/menuhit.c)]])>>
<<global [[text]]([[(lib_graphics/libdraw/menuhit.c)]])>>
<<global [[htext]]([[(lib_graphics/libdraw/menuhit.c)]])>>

<<function [[menucolors]]([[(lib_graphics/libdraw/menuhit.c)]])>>

<<function [[menurect]]([[(lib_graphics/libdraw/menuhit.c)]])>>

<<function [[menusel]]([[(lib_graphics/libdraw/menuhit.c)]])>>

<<function [[paintitem]]([[(lib_graphics/libdraw/menuhit.c)]])>>

<<function [[menuscan]]([[(lib_graphics/libdraw/menuhit.c)]])>>

<<function [[menupaint]]([[(lib_graphics/libdraw/menuhit.c)]])>>

<<function [[menuscrollpaint]]([[(lib_graphics/libdraw/menuhit.c)]])>>

<<function [[menuhit]]>>
@


\subsection{[[lib_graphics/libdraw/getrect.c]]}


%-------------------------------------------------------------

<<lib_graphics/libdraw/getrect.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <cursor.h>
#include <mouse.h>

<<constant [[W]]([[(lib_graphics/libdraw/getrect.c)]])>>

<<global [[tmp]]([[(lib_graphics/libdraw/getrect.c)]])>>
<<global [[red]]([[(lib_graphics/libdraw/getrect.c)]])>>

<<global [[sweep]]([[(lib_graphics/libdraw/getrect.c)]])>>

<<function [[brects]]([[(lib_graphics/libdraw/getrect.c)]])>>

<<function [[getrect]]>>

<<function [[freetmp]]([[(lib_graphics/libdraw/getrect.c)]])>>

<<function [[max]]>>

<<function [[drawgetrect]]>>
@



\subsection{[[lib_graphics/libdraw/event.c]]}

%-------------------------------------------------------------

<<lib_graphics/libdraw/event.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <draw_private.h>
#include <cursor.h>
#include <event.h>

typedef struct	Slave Slave;
typedef struct	Ebuf Ebuf;

<<struct [[Slave]]>>

<<struct [[Ebuf]]>>

<<global [[eslave]]>>
<<global [[Skeyboard]]>>
<<global [[Smouse]]>>
<<global [[Stimer]]>>
<<global [[logfid]]>>

<<global [[nslave]]>>
<<global [[parentpid]]>>
<<global [[epipe]]>>

static	int	eforkslave(ulong);
static	void	extract(void);
static	void	ekill(void);
static	int	enote(void *, char *);

<<global [[mousefd]]>>
<<global [[cursorfd]]>>

<<function [[ebread]]>>

<<function [[event]]>>

<<function [[eread]]>>

<<function [[ecanmouse]]>>

<<function [[ecankbd]]>>

<<function [[ecanread]]>>

<<function [[estartfn]]>>

<<function [[estart]]>>

<<function [[etimer]]>>

<<function [[ekeyslave]]>>

<<function [[einit]]>>

<<function [[extract]]>>

<<function [[eforkslave]]>>

<<function [[enote]]>>

<<function [[ekill]]>>

<<function [[emouse]]>>

<<function [[ekbd]]>>

<<function [[emoveto]]>>

<<function [[esetcursor]]>>

<<function [[ereadmouse]]>>

<<function [[eatomouse]]>>
@


\subsection{[[lib_graphics/libdraw/egetrect.c]]}

%-------------------------------------------------------------

<<lib_graphics/libdraw/egetrect.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <cursor.h>
#include <event.h>

<<constant [[W]]>>

<<global [[tmp]]>>
<<global [[red]]>>

<<global [[sweep]]>>

<<function [[brects]]>>

<<function [[egetrect]]>>

<<function [[freetmp]]>>

<<function [[edrawgetrect]]>>
@


\subsection{[[lib_graphics/libdraw/emenuhit.c]]}


%-------------------------------------------------------------

<<lib_graphics/libdraw/emenuhit.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <draw_private.h>
#include <event.h>

<<enum [[_anon_]]([[(lib_graphics/libdraw/emenuhit.c)]])>>

<<global [[menutxt]]>>
<<global [[back]]>>
<<global [[high]]>>
<<global [[bord]]>>
<<global [[text]]>>
<<global [[htext]]>>

<<function [[menucolors]]>>

<<function [[menurect]]>>

<<function [[menusel]]>>

<<function [[paintitem]]>>

<<function [[menuscan]]>>

<<function [[menupaint]]>>

<<function [[menuscrollpaint]]>>

<<function [[emenuhit]]>>
@



\section{[[lib_graphics/libdraw/tests/]]}

\subsection{[[lib_graphics/libdraw/tests/drawtest.c]]}

<<function [[main]]>>=
void
main(int argc, char **argv)
{
        print("%dn", wordsperline(Rect(atoi(argv[1]), atoi(argv[2]), atoi(argv[3]), atoi(argv[4])), atoi(argv[5])));
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/tests/drawtest.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function [[main]]>>
@


\section{[[lib_graphics/libmemdraw/]]}


\subsection{[[lib_graphics/libmemdraw/resolution.c]]}
%pad: I created this file; its content was in alloc.c before but
% better parallel libdraw/ like this

%-------------------------------------------------------------

<<lib_graphics/libmemdraw/resolution.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>

<<function [[byteaddr]]>>

<<function [[wordaddr]]>>

<<function [[pixelbits]]>>

@

\subsection{[[lib_graphics/libmemdraw/chan.c]]}
%pad: I created this file; its content was in alloc.c before but
% better parallel libdraw/ like this.
% I could merge with resolution.c.

%-------------------------------------------------------------

<<lib_graphics/libmemdraw/chan.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>

<<function [[memsetchan]]>>

@

\subsection{[[lib_graphics/libmemdraw/alloc.c]]}

%-------------------------------------------------------------

<<lib_graphics/libmemdraw/alloc.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <pool.h>

<<function [[memimagemove]]>>

<<function [[allocmemimaged]]>>


<<function [[allocmemimage]]>>

<<function [[freememimage]]>>

@


\subsection{[[lib_graphics/libmemdraw/arc.c]]}

%-------------------------------------------------------------

<<lib_graphics/libmemdraw/arc.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<enum [[_anon_]]([[(lib_graphics/libmemdraw/arc.c)]])>>

<<global [[corners]]>>

<<global [[p00]]>>

<<function [[memarc]]>>
@

\subsection{[[lib_graphics/libmemdraw/compressed.c]]}
%pad: I created this file; its content was in cload.c and cread.c

%-------------------------------------------------------------

<<lib_graphics/libmemdraw/compressed.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <draw_private.h>
#include <memdraw.h>

// creadmemimage() could be in this file but then it creates a dependency
// to libdraw which ends up linking in lockdisplay in the kernel.
// To avoid this issue creadmemimage() is defined instead in io.c.

<<function [[cloadmemimage]]>>

@

%\subsection{[[lib_graphics/libmemdraw/cload.c]]}

%\subsection{[[lib_graphics/libmemdraw/cread.c]]}


\subsection{[[lib_graphics/libmemdraw/cmap.c]]}

<<global [[def]]>>=
static Memcmap def = {
/* cmap2rgb */ {
    0x00,0x00,0x00,0x00,0x00,0x44,0x00,0x00,0x88,0x00,0x00,0xcc,0x00,0x44,0x00,0x00,
    0x44,0x44,0x00,0x44,0x88,0x00,0x44,0xcc,0x00,0x88,0x00,0x00,0x88,0x44,0x00,0x88,
    0x88,0x00,0x88,0xcc,0x00,0xcc,0x00,0x00,0xcc,0x44,0x00,0xcc,0x88,0x00,0xcc,0xcc,
    0x00,0xdd,0xdd,0x11,0x11,0x11,0x00,0x00,0x55,0x00,0x00,0x99,0x00,0x00,0xdd,0x00,
    0x55,0x00,0x00,0x55,0x55,0x00,0x4c,0x99,0x00,0x49,0xdd,0x00,0x99,0x00,0x00,0x99,
    0x4c,0x00,0x99,0x99,0x00,0x93,0xdd,0x00,0xdd,0x00,0x00,0xdd,0x49,0x00,0xdd,0x93,
    0x00,0xee,0x9e,0x00,0xee,0xee,0x22,0x22,0x22,0x00,0x00,0x66,0x00,0x00,0xaa,0x00,
    0x00,0xee,0x00,0x66,0x00,0x00,0x66,0x66,0x00,0x55,0xaa,0x00,0x4f,0xee,0x00,0xaa,
    0x00,0x00,0xaa,0x55,0x00,0xaa,0xaa,0x00,0x9e,0xee,0x00,0xee,0x00,0x00,0xee,0x4f,
    0x00,0xff,0x55,0x00,0xff,0xaa,0x00,0xff,0xff,0x33,0x33,0x33,0x00,0x00,0x77,0x00,
    0x00,0xbb,0x00,0x00,0xff,0x00,0x77,0x00,0x00,0x77,0x77,0x00,0x5d,0xbb,0x00,0x55,
    0xff,0x00,0xbb,0x00,0x00,0xbb,0x5d,0x00,0xbb,0xbb,0x00,0xaa,0xff,0x00,0xff,0x00,
    0x44,0x00,0x44,0x44,0x00,0x88,0x44,0x00,0xcc,0x44,0x44,0x00,0x44,0x44,0x44,0x44,
    0x44,0x88,0x44,0x44,0xcc,0x44,0x88,0x00,0x44,0x88,0x44,0x44,0x88,0x88,0x44,0x88,
    0xcc,0x44,0xcc,0x00,0x44,0xcc,0x44,0x44,0xcc,0x88,0x44,0xcc,0xcc,0x44,0x00,0x00,
    0x55,0x00,0x00,0x55,0x00,0x55,0x4c,0x00,0x99,0x49,0x00,0xdd,0x55,0x55,0x00,0x55,
    0x55,0x55,0x4c,0x4c,0x99,0x49,0x49,0xdd,0x4c,0x99,0x00,0x4c,0x99,0x4c,0x4c,0x99,
    0x99,0x49,0x93,0xdd,0x49,0xdd,0x00,0x49,0xdd,0x49,0x49,0xdd,0x93,0x49,0xdd,0xdd,
    0x4f,0xee,0xee,0x66,0x00,0x00,0x66,0x00,0x66,0x55,0x00,0xaa,0x4f,0x00,0xee,0x66,
    0x66,0x00,0x66,0x66,0x66,0x55,0x55,0xaa,0x4f,0x4f,0xee,0x55,0xaa,0x00,0x55,0xaa,
    0x55,0x55,0xaa,0xaa,0x4f,0x9e,0xee,0x4f,0xee,0x00,0x4f,0xee,0x4f,0x4f,0xee,0x9e,
    0x55,0xff,0xaa,0x55,0xff,0xff,0x77,0x00,0x00,0x77,0x00,0x77,0x5d,0x00,0xbb,0x55,
    0x00,0xff,0x77,0x77,0x00,0x77,0x77,0x77,0x5d,0x5d,0xbb,0x55,0x55,0xff,0x5d,0xbb,
    0x00,0x5d,0xbb,0x5d,0x5d,0xbb,0xbb,0x55,0xaa,0xff,0x55,0xff,0x00,0x55,0xff,0x55,
    0x88,0x00,0x88,0x88,0x00,0xcc,0x88,0x44,0x00,0x88,0x44,0x44,0x88,0x44,0x88,0x88,
    0x44,0xcc,0x88,0x88,0x00,0x88,0x88,0x44,0x88,0x88,0x88,0x88,0x88,0xcc,0x88,0xcc,
    0x00,0x88,0xcc,0x44,0x88,0xcc,0x88,0x88,0xcc,0xcc,0x88,0x00,0x00,0x88,0x00,0x44,
    0x99,0x00,0x4c,0x99,0x00,0x99,0x93,0x00,0xdd,0x99,0x4c,0x00,0x99,0x4c,0x4c,0x99,
    0x4c,0x99,0x93,0x49,0xdd,0x99,0x99,0x00,0x99,0x99,0x4c,0x99,0x99,0x99,0x93,0x93,
    0xdd,0x93,0xdd,0x00,0x93,0xdd,0x49,0x93,0xdd,0x93,0x93,0xdd,0xdd,0x99,0x00,0x00,
    0xaa,0x00,0x00,0xaa,0x00,0x55,0xaa,0x00,0xaa,0x9e,0x00,0xee,0xaa,0x55,0x00,0xaa,
    0x55,0x55,0xaa,0x55,0xaa,0x9e,0x4f,0xee,0xaa,0xaa,0x00,0xaa,0xaa,0x55,0xaa,0xaa,
    0xaa,0x9e,0x9e,0xee,0x9e,0xee,0x00,0x9e,0xee,0x4f,0x9e,0xee,0x9e,0x9e,0xee,0xee,
    0xaa,0xff,0xff,0xbb,0x00,0x00,0xbb,0x00,0x5d,0xbb,0x00,0xbb,0xaa,0x00,0xff,0xbb,
    0x5d,0x00,0xbb,0x5d,0x5d,0xbb,0x5d,0xbb,0xaa,0x55,0xff,0xbb,0xbb,0x00,0xbb,0xbb,
    0x5d,0xbb,0xbb,0xbb,0xaa,0xaa,0xff,0xaa,0xff,0x00,0xaa,0xff,0x55,0xaa,0xff,0xaa,
    0xcc,0x00,0xcc,0xcc,0x44,0x00,0xcc,0x44,0x44,0xcc,0x44,0x88,0xcc,0x44,0xcc,0xcc,
    0x88,0x00,0xcc,0x88,0x44,0xcc,0x88,0x88,0xcc,0x88,0xcc,0xcc,0xcc,0x00,0xcc,0xcc,
    0x44,0xcc,0xcc,0x88,0xcc,0xcc,0xcc,0xcc,0x00,0x00,0xcc,0x00,0x44,0xcc,0x00,0x88,
    0xdd,0x00,0x93,0xdd,0x00,0xdd,0xdd,0x49,0x00,0xdd,0x49,0x49,0xdd,0x49,0x93,0xdd,
    0x49,0xdd,0xdd,0x93,0x00,0xdd,0x93,0x49,0xdd,0x93,0x93,0xdd,0x93,0xdd,0xdd,0xdd,
    0x00,0xdd,0xdd,0x49,0xdd,0xdd,0x93,0xdd,0xdd,0xdd,0xdd,0x00,0x00,0xdd,0x00,0x49,
    0xee,0x00,0x4f,0xee,0x00,0x9e,0xee,0x00,0xee,0xee,0x4f,0x00,0xee,0x4f,0x4f,0xee,
    0x4f,0x9e,0xee,0x4f,0xee,0xee,0x9e,0x00,0xee,0x9e,0x4f,0xee,0x9e,0x9e,0xee,0x9e,
    0xee,0xee,0xee,0x00,0xee,0xee,0x4f,0xee,0xee,0x9e,0xee,0xee,0xee,0xee,0x00,0x00,
    0xff,0x00,0x00,0xff,0x00,0x55,0xff,0x00,0xaa,0xff,0x00,0xff,0xff,0x55,0x00,0xff,
    0x55,0x55,0xff,0x55,0xaa,0xff,0x55,0xff,0xff,0xaa,0x00,0xff,0xaa,0x55,0xff,0xaa,
    0xaa,0xff,0xaa,0xff,0xff,0xff,0x00,0xff,0xff,0x55,0xff,0xff,0xaa,0xff,0xff,0xff,
},
/* rgb2cmap */ {
    0x00,0x00,0x11,0x01,0x01,0x12,0x23,0x34,0x02,0x13,0x24,0x35,0x03,0x14,0x25,0x36,
    0x00,0x11,0x11,0x01,0x01,0x12,0x23,0x34,0x02,0x13,0x24,0x35,0x03,0x14,0x25,0x36,
    0x11,0x11,0x11,0x01,0x01,0x12,0x23,0x34,0x02,0x13,0x24,0x35,0x03,0x14,0x25,0x36,
    0x04,0x04,0x04,0x05,0x05,0x05,0x05,0x06,0x06,0x06,0x17,0x07,0x07,0x18,0x18,0x29,
    0x04,0x04,0x04,0x05,0x05,0x05,0x16,0x06,0x06,0x17,0x28,0x07,0x07,0x18,0x29,0x3a,
    0x15,0x15,0x15,0x05,0x05,0x16,0x16,0x06,0x06,0x17,0x28,0x39,0x07,0x18,0x29,0x3a,
    0x26,0x26,0x26,0x05,0x16,0x16,0x27,0x27,0x38,0x28,0x28,0x39,0x39,0x29,0x29,0x3a,
    0x37,0x37,0x37,0x09,0x09,0x09,0x27,0x38,0x0a,0x0a,0x39,0x0b,0x0b,0x0b,0x1c,0x3a,
    0x08,0x08,0x08,0x09,0x09,0x09,0x38,0x0a,0x0a,0x0a,0x1b,0x0b,0x0b,0x1c,0x1c,0x2d,
    0x19,0x19,0x19,0x09,0x1a,0x1a,0x2b,0x0a,0x0a,0x1b,0x1b,0x0b,0x0b,0x1c,0x2d,0x3e,
    0x2a,0x2a,0x2a,0x1a,0x2b,0x2b,0x2b,0x3c,0x1b,0x1b,0x2c,0x2c,0x3d,0x2d,0x2d,0x3e,
    0x3b,0x3b,0x3b,0x0d,0x0d,0x3c,0x3c,0x0e,0x0e,0x0e,0x2c,0x3d,0x0f,0x0f,0x3e,0x3e,
    0x0c,0x0c,0x0c,0x0d,0x0d,0x0d,0x3c,0x0e,0x0e,0x0e,0x3d,0x0f,0x0f,0x0f,0x10,0x3e,
    0x1d,0x1d,0x1d,0x1e,0x1e,0x1e,0x2f,0x0e,0x1f,0x1f,0x20,0x0f,0x0f,0x10,0x10,0x21,
    0x2e,0x2e,0x2e,0x1e,0x2f,0x2f,0x2f,0x1f,0x1f,0x20,0x20,0x31,0x10,0x10,0x21,0x21,
    0x3f,0x3f,0x3f,0x2f,0x30,0x30,0x30,0x30,0x20,0x31,0x31,0x31,0x31,0x21,0x21,0x32,
    0x00,0x11,0x11,0x01,0x01,0x12,0x23,0x34,0x02,0x13,0x24,0x35,0x03,0x14,0x25,0x36,
    0x11,0x11,0x11,0x01,0x01,0x12,0x23,0x34,0x02,0x13,0x24,0x35,0x03,0x14,0x25,0x36,
    0x11,0x11,0x22,0x22,0x01,0x12,0x23,0x34,0x02,0x13,0x24,0x35,0x03,0x14,0x25,0x36,
    0x04,0x04,0x22,0x05,0x05,0x05,0x05,0x06,0x06,0x06,0x17,0x07,0x07,0x18,0x18,0x29,
    0x04,0x04,0x04,0x05,0x05,0x05,0x16,0x06,0x06,0x17,0x28,0x07,0x07,0x18,0x29,0x3a,
    0x15,0x15,0x15,0x05,0x05,0x16,0x16,0x06,0x06,0x17,0x28,0x39,0x07,0x18,0x29,0x3a,
    0x26,0x26,0x26,0x05,0x16,0x16,0x27,0x27,0x38,0x28,0x28,0x39,0x39,0x29,0x29,0x3a,
    0x37,0x37,0x37,0x09,0x09,0x09,0x27,0x38,0x0a,0x0a,0x39,0x0b,0x0b,0x0b,0x1c,0x3a,
    0x08,0x08,0x08,0x09,0x09,0x09,0x38,0x0a,0x0a,0x0a,0x1b,0x0b,0x0b,0x1c,0x1c,0x2d,
    0x19,0x19,0x19,0x09,0x1a,0x1a,0x2b,0x0a,0x0a,0x1b,0x1b,0x0b,0x0b,0x1c,0x2d,0x3e,
    0x2a,0x2a,0x2a,0x1a,0x2b,0x2b,0x2b,0x3c,0x1b,0x1b,0x2c,0x2c,0x3d,0x2d,0x2d,0x3e,
    0x3b,0x3b,0x3b,0x0d,0x0d,0x3c,0x3c,0x0e,0x0e,0x0e,0x2c,0x3d,0x0f,0x0f,0x3e,0x3e,
    0x0c,0x0c,0x0c,0x0d,0x0d,0x0d,0x3c,0x0e,0x0e,0x0e,0x3d,0x0f,0x0f,0x0f,0x10,0x3e,
    0x1d,0x1d,0x1d,0x1e,0x1e,0x1e,0x2f,0x0e,0x1f,0x1f,0x20,0x0f,0x0f,0x10,0x10,0x21,
    0x2e,0x2e,0x2e,0x1e,0x2f,0x2f,0x2f,0x1f,0x1f,0x20,0x20,0x31,0x10,0x10,0x21,0x21,
    0x3f,0x3f,0x3f,0x2f,0x30,0x30,0x30,0x30,0x20,0x31,0x31,0x31,0x31,0x21,0x21,0x32,
    0x11,0x11,0x11,0x01,0x01,0x12,0x23,0x34,0x02,0x13,0x24,0x35,0x03,0x14,0x25,0x36,
    0x11,0x11,0x22,0x22,0x01,0x12,0x23,0x34,0x02,0x13,0x24,0x35,0x03,0x14,0x25,0x36,
    0x11,0x22,0x22,0x22,0x33,0x33,0x23,0x34,0x02,0x13,0x24,0x35,0x03,0x14,0x25,0x36,
    0x04,0x22,0x22,0x33,0x33,0x33,0x05,0x06,0x06,0x06,0x17,0x07,0x07,0x18,0x18,0x29,
    0x04,0x04,0x33,0x33,0x33,0x05,0x16,0x06,0x06,0x17,0x28,0x07,0x07,0x18,0x29,0x3a,
    0x15,0x15,0x33,0x33,0x05,0x16,0x16,0x06,0x06,0x17,0x28,0x39,0x07,0x18,0x29,0x3a,
    0x26,0x26,0x26,0x05,0x16,0x16,0x27,0x27,0x38,0x28,0x28,0x39,0x39,0x29,0x29,0x3a,
    0x37,0x37,0x37,0x09,0x09,0x09,0x27,0x38,0x0a,0x0a,0x39,0x0b,0x0b,0x0b,0x1c,0x3a,
    0x08,0x08,0x08,0x09,0x09,0x09,0x38,0x0a,0x0a,0x0a,0x1b,0x0b,0x0b,0x1c,0x1c,0x2d,
    0x19,0x19,0x19,0x09,0x1a,0x1a,0x2b,0x0a,0x0a,0x1b,0x1b,0x0b,0x0b,0x1c,0x2d,0x3e,
    0x2a,0x2a,0x2a,0x1a,0x2b,0x2b,0x2b,0x3c,0x1b,0x1b,0x2c,0x2c,0x3d,0x2d,0x2d,0x3e,
    0x3b,0x3b,0x3b,0x0d,0x0d,0x3c,0x3c,0x0e,0x0e,0x0e,0x2c,0x3d,0x0f,0x0f,0x3e,0x3e,
    0x0c,0x0c,0x0c,0x0d,0x0d,0x0d,0x3c,0x0e,0x0e,0x0e,0x3d,0x0f,0x0f,0x0f,0x10,0x3e,
    0x1d,0x1d,0x1d,0x1e,0x1e,0x1e,0x2f,0x0e,0x1f,0x1f,0x20,0x0f,0x0f,0x10,0x10,0x21,
    0x2e,0x2e,0x2e,0x1e,0x2f,0x2f,0x2f,0x1f,0x1f,0x20,0x20,0x31,0x10,0x10,0x21,0x21,
    0x3f,0x3f,0x3f,0x2f,0x30,0x30,0x30,0x30,0x20,0x31,0x31,0x31,0x31,0x21,0x21,0x32,
    0x4f,0x4f,0x22,0x40,0x40,0x40,0x40,0x41,0x41,0x41,0x52,0x42,0x42,0x53,0x53,0x64,
    0x4f,0x22,0x22,0x22,0x40,0x40,0x40,0x41,0x41,0x41,0x52,0x42,0x42,0x53,0x53,0x64,
    0x22,0x22,0x22,0x33,0x33,0x33,0x40,0x41,0x41,0x41,0x52,0x42,0x42,0x53,0x53,0x64,
    0x43,0x22,0x33,0x33,0x33,0x44,0x44,0x45,0x45,0x45,0x56,0x46,0x46,0x46,0x57,0x68,
    0x43,0x43,0x33,0x33,0x44,0x44,0x44,0x45,0x45,0x45,0x56,0x46,0x46,0x57,0x57,0x68,
    0x43,0x43,0x33,0x44,0x44,0x44,0x55,0x45,0x45,0x56,0x56,0x46,0x46,0x57,0x68,0x68,
    0x43,0x43,0x43,0x44,0x44,0x55,0x55,0x45,0x45,0x56,0x67,0x46,0x46,0x57,0x68,0x79,
    0x47,0x47,0x47,0x48,0x48,0x48,0x48,0x49,0x49,0x49,0x49,0x4a,0x4a,0x4a,0x5b,0x79,
    0x47,0x47,0x47,0x48,0x48,0x48,0x48,0x49,0x49,0x49,0x5a,0x4a,0x4a,0x4a,0x5b,0x6c,
    0x47,0x47,0x47,0x48,0x48,0x59,0x59,0x49,0x49,0x5a,0x5a,0x4a,0x4a,0x5b,0x5b,0x6c,
    0x58,0x58,0x58,0x59,0x59,0x59,0x6a,0x49,0x5a,0x5a,0x6b,0x6b,0x5b,0x5b,0x6c,0x7d,
    0x4b,0x4b,0x4b,0x4c,0x4c,0x4c,0x4c,0x4d,0x4d,0x4d,0x6b,0x4e,0x4e,0x4e,0x6c,0x7d,
    0x4b,0x4b,0x4b,0x4c,0x4c,0x4c,0x4c,0x4d,0x4d,0x4d,0x5e,0x4e,0x4e,0x4e,0x5f,0x5f,
    0x5c,0x5c,0x5c,0x4c,0x5d,0x5d,0x5d,0x4d,0x4d,0x5e,0x5e,0x4e,0x4e,0x5f,0x5f,0x60,
    0x5c,0x5c,0x5c,0x5d,0x5d,0x6e,0x6e,0x5e,0x5e,0x5e,0x6f,0x6f,0x5f,0x5f,0x60,0x60,
    0x6d,0x6d,0x6d,0x6e,0x6e,0x6e,0x7f,0x7f,0x6f,0x6f,0x70,0x70,0x5f,0x60,0x60,0x71,
    0x4f,0x4f,0x40,0x40,0x40,0x40,0x51,0x41,0x41,0x52,0x63,0x42,0x42,0x53,0x64,0x75,
    0x4f,0x4f,0x22,0x40,0x40,0x40,0x51,0x41,0x41,0x52,0x63,0x42,0x42,0x53,0x64,0x75,
    0x43,0x22,0x33,0x33,0x33,0x40,0x51,0x41,0x41,0x52,0x63,0x42,0x42,0x53,0x64,0x75,
    0x43,0x43,0x33,0x33,0x44,0x44,0x44,0x45,0x45,0x45,0x56,0x46,0x46,0x57,0x57,0x68,
    0x43,0x43,0x33,0x44,0x44,0x44,0x55,0x45,0x45,0x56,0x56,0x46,0x46,0x57,0x68,0x68,
    0x43,0x43,0x43,0x44,0x44,0x55,0x55,0x45,0x45,0x56,0x67,0x46,0x46,0x57,0x68,0x79,
    0x54,0x54,0x54,0x44,0x55,0x55,0x55,0x45,0x56,0x56,0x67,0x78,0x78,0x57,0x68,0x79,
    0x47,0x47,0x47,0x48,0x48,0x48,0x48,0x49,0x49,0x49,0x49,0x4a,0x4a,0x4a,0x5b,0x79,
    0x47,0x47,0x47,0x48,0x48,0x48,0x59,0x49,0x49,0x49,0x5a,0x4a,0x4a,0x5b,0x5b,0x6c,
    0x58,0x58,0x58,0x48,0x59,0x59,0x59,0x49,0x49,0x5a,0x5a,0x4a,0x4a,0x5b,0x6c,0x6c,
    0x69,0x69,0x69,0x59,0x59,0x6a,0x6a,0x49,0x5a,0x5a,0x6b,0x6b,0x5b,0x5b,0x6c,0x7d,
    0x4b,0x4b,0x4b,0x4c,0x4c,0x4c,0x7b,0x4d,0x4d,0x4d,0x6b,0x4e,0x4e,0x4e,0x7d,0x7d,
    0x4b,0x4b,0x4b,0x4c,0x4c,0x4c,0x7b,0x4d,0x4d,0x4d,0x5e,0x4e,0x4e,0x4e,0x5f,0x7d,
    0x5c,0x5c,0x5c,0x5d,0x5d,0x5d,0x5d,0x4d,0x5e,0x5e,0x5e,0x4e,0x4e,0x5f,0x5f,0x60,
    0x6d,0x6d,0x6d,0x5d,0x6e,0x6e,0x6e,0x5e,0x5e,0x6f,0x6f,0x70,0x5f,0x5f,0x60,0x60,
    0x7e,0x7e,0x7e,0x6e,0x6e,0x7f,0x7f,0x7f,0x6f,0x6f,0x70,0x70,0x70,0x60,0x60,0x71,
    0x50,0x50,0x50,0x40,0x40,0x51,0x51,0x41,0x41,0x52,0x63,0x74,0x42,0x53,0x64,0x75,
    0x50,0x50,0x50,0x40,0x40,0x51,0x51,0x41,0x41,0x52,0x63,0x74,0x42,0x53,0x64,0x75,
    0x50,0x50,0x33,0x33,0x40,0x51,0x51,0x41,0x41,0x52,0x63,0x74,0x42,0x53,0x64,0x75,
    0x43,0x43,0x33,0x44,0x44,0x44,0x55,0x45,0x45,0x56,0x56,0x46,0x46,0x57,0x68,0x68,
    0x43,0x43,0x43,0x44,0x44,0x55,0x55,0x45,0x45,0x56,0x67,0x46,0x46,0x57,0x68,0x79,
    0x54,0x54,0x54,0x44,0x55,0x55,0x55,0x45,0x56,0x56,0x67,0x78,0x78,0x57,0x68,0x79,
    0x54,0x54,0x54,0x55,0x55,0x55,0x66,0x66,0x56,0x67,0x67,0x78,0x78,0x68,0x68,0x79,
    0x47,0x47,0x47,0x48,0x48,0x48,0x66,0x49,0x49,0x49,0x78,0x78,0x4a,0x4a,0x5b,0x79,
    0x47,0x47,0x47,0x48,0x48,0x59,0x59,0x49,0x49,0x5a,0x5a,0x4a,0x4a,0x5b,0x6c,0x6c,
    0x58,0x58,0x58,0x59,0x59,0x59,0x6a,0x49,0x5a,0x5a,0x6b,0x6b,0x5b,0x5b,0x6c,0x7d,
    0x69,0x69,0x69,0x59,0x6a,0x6a,0x6a,0x7b,0x5a,0x6b,0x6b,0x6b,0x7c,0x6c,0x6c,0x7d,
    0x7a,0x7a,0x7a,0x4c,0x4c,0x7b,0x7b,0x7b,0x4d,0x6b,0x6b,0x7c,0x7c,0x4e,0x7d,0x7d,
    0x4b,0x4b,0x4b,0x4c,0x4c,0x7b,0x7b,0x4d,0x4d,0x5e,0x7c,0x7c,0x4e,0x5f,0x5f,0x7d,
    0x5c,0x5c,0x5c,0x5d,0x5d,0x5d,0x6e,0x4d,0x5e,0x5e,0x6f,0x4e,0x5f,0x5f,0x60,0x60,
    0x6d,0x6d,0x6d,0x6e,0x6e,0x6e,0x6e,0x5e,0x6f,0x6f,0x6f,0x70,0x5f,0x60,0x60,0x71,
    0x7e,0x7e,0x7e,0x6e,0x7f,0x7f,0x7f,0x7f,0x6f,0x70,0x70,0x70,0x70,0x60,0x71,0x71,
    0x61,0x61,0x61,0x40,0x51,0x51,0x62,0x62,0x73,0x63,0x63,0x74,0x74,0x64,0x64,0x75,
    0x61,0x61,0x61,0x40,0x51,0x51,0x62,0x62,0x73,0x63,0x63,0x74,0x74,0x64,0x64,0x75,
    0x61,0x61,0x61,0x40,0x51,0x51,0x62,0x62,0x73,0x63,0x63,0x74,0x74,0x64,0x64,0x75,
    0x43,0x43,0x43,0x44,0x44,0x55,0x55,0x45,0x45,0x56,0x67,0x46,0x46,0x57,0x68,0x79,
    0x54,0x54,0x54,0x44,0x55,0x55,0x55,0x45,0x56,0x56,0x67,0x78,0x78,0x57,0x68,0x79,
    0x54,0x54,0x54,0x55,0x55,0x55,0x66,0x66,0x56,0x67,0x67,0x78,0x78,0x68,0x68,0x79,
    0x65,0x65,0x65,0x55,0x55,0x66,0x66,0x66,0x77,0x67,0x78,0x78,0x78,0x78,0x79,0x79,
    0x65,0x65,0x65,0x48,0x48,0x66,0x66,0x77,0x77,0x77,0x78,0x78,0x78,0x5b,0x79,0x79,
    0x76,0x76,0x76,0x48,0x59,0x59,0x77,0x77,0x77,0x5a,0x5a,0x4a,0x4a,0x5b,0x6c,0x6c,
    0x69,0x69,0x69,0x59,0x59,0x6a,0x6a,0x77,0x5a,0x5a,0x6b,0x6b,0x5b,0x6c,0x6c,0x7d,
    0x69,0x69,0x69,0x6a,0x6a,0x6a,0x7b,0x7b,0x5a,0x6b,0x6b,0x7c,0x7c,0x6c,0x7d,0x7d,
    0x7a,0x7a,0x7a,0x4c,0x7b,0x7b,0x7b,0x7b,0x4d,0x6b,0x7c,0x7c,0x7c,0x7c,0x7d,0x7d,
    0x7a,0x7a,0x7a,0x4c,0x7b,0x7b,0x7b,0x7b,0x4d,0x5e,0x7c,0x7c,0x7c,0x5f,0x5f,0x7d,
    0x6d,0x6d,0x6d,0x5d,0x5d,0x6e,0x7b,0x5e,0x5e,0x6f,0x6f,0x7c,0x5f,0x5f,0x60,0x60,
    0x6d,0x6d,0x6d,0x6e,0x6e,0x6e,0x7f,0x7f,0x6f,0x6f,0x70,0x70,0x5f,0x60,0x60,0x71,
    0x7e,0x7e,0x7e,0x7f,0x7f,0x7f,0x7f,0x7f,0x6f,0x70,0x70,0x70,0x70,0x60,0x71,0x71,
    0x72,0x72,0x72,0x8f,0x8f,0x62,0x62,0x73,0x73,0x80,0x74,0x81,0x81,0x81,0x92,0x75,
    0x72,0x72,0x72,0x8f,0x8f,0x62,0x62,0x73,0x73,0x80,0x74,0x81,0x81,0x81,0x92,0x75,
    0x72,0x72,0x72,0x83,0x83,0x62,0x62,0x73,0x73,0x80,0x74,0x81,0x81,0x81,0x92,0x75,
    0x82,0x82,0x82,0x83,0x83,0x83,0x83,0x84,0x84,0x84,0x84,0x85,0x85,0x85,0x96,0x79,
    0x82,0x82,0x82,0x83,0x83,0x83,0x66,0x84,0x84,0x84,0x67,0x85,0x85,0x85,0x96,0x79,
    0x65,0x65,0x65,0x83,0x83,0x66,0x66,0x66,0x84,0x84,0x78,0x78,0x85,0x85,0x96,0x79,
    0x65,0x65,0x65,0x83,0x66,0x66,0x66,0x77,0x77,0x77,0x78,0x78,0x78,0x96,0x79,0x79,
    0x76,0x76,0x76,0x87,0x87,0x66,0x77,0x77,0x77,0x88,0x78,0x89,0x89,0x89,0x89,0x79,
    0x76,0x76,0x76,0x87,0x87,0x87,0x77,0x77,0x88,0x88,0x88,0x89,0x89,0x89,0x9a,0x9a,
    0x86,0x86,0x86,0x87,0x87,0x87,0x77,0x88,0x88,0x88,0x6b,0x89,0x89,0x9a,0x9a,0x7d,
    0x7a,0x7a,0x7a,0x87,0x6a,0x7b,0x7b,0x7b,0x88,0x6b,0x6b,0x7c,0x7c,0x9a,0x7d,0x7d,
    0x8a,0x8a,0x8a,0x8b,0x8b,0x7b,0x7b,0x8c,0x8c,0x8c,0x7c,0x7c,0x8d,0x8d,0x7d,0x7d,
    0x8a,0x8a,0x8a,0x8b,0x8b,0x8b,0x7b,0x8c,0x8c,0x8c,0x7c,0x8d,0x8d,0x8d,0x9e,0x9e,
    0x8a,0x8a,0x8a,0x8b,0x8b,0x8b,0x9c,0x8c,0x8c,0x9d,0x9d,0x8d,0x8d,0x9e,0x9e,0x9e,
    0x9b,0x9b,0x9b,0x9c,0x9c,0x9c,0x7f,0x8c,0x9d,0x9d,0x70,0x70,0x9e,0x9e,0x9e,0x71,
    0x7e,0x7e,0x7e,0x7f,0x7f,0x7f,0x7f,0x7f,0x9d,0x70,0x70,0x70,0x9e,0x9e,0x71,0x71,
    0x8e,0x8e,0x8e,0x8f,0x8f,0x8f,0x73,0x73,0x80,0x80,0x91,0x81,0x81,0x92,0x92,0xa3,
    0x8e,0x8e,0x8e,0x8f,0x8f,0x8f,0x73,0x73,0x80,0x80,0x91,0x81,0x81,0x92,0x92,0xa3,
    0x82,0x82,0x82,0x83,0x83,0x83,0x73,0x73,0x80,0x80,0x91,0x81,0x81,0x92,0x92,0xa3,
    0x82,0x82,0x82,0x83,0x83,0x83,0x83,0x84,0x84,0x84,0x95,0x85,0x85,0x85,0x96,0xa7,
    0x82,0x82,0x82,0x83,0x83,0x83,0x94,0x84,0x84,0x84,0x95,0x85,0x85,0x96,0x96,0xa7,
    0x82,0x82,0x82,0x83,0x83,0x94,0x94,0x84,0x84,0x95,0x95,0x85,0x85,0x96,0xa7,0xa7,
    0x76,0x76,0x76,0x83,0x94,0x94,0x77,0x77,0x77,0x95,0x95,0x85,0x85,0x96,0xa7,0xa7,
    0x76,0x76,0x76,0x87,0x87,0x87,0x77,0x77,0x88,0x88,0x88,0x89,0x89,0x89,0x9a,0x9a,
    0x86,0x86,0x86,0x87,0x87,0x87,0x77,0x88,0x88,0x88,0x99,0x89,0x89,0x9a,0x9a,0xab,
    0x86,0x86,0x86,0x87,0x87,0x98,0x98,0x88,0x88,0x99,0x99,0x89,0x89,0x9a,0x9a,0xab,
    0x97,0x97,0x97,0x98,0x98,0x98,0x98,0x88,0x99,0x99,0x99,0x89,0x9a,0x9a,0xab,0xab,
    0x8a,0x8a,0x8a,0x8b,0x8b,0x8b,0x8b,0x8c,0x8c,0x8c,0x8c,0x8d,0x8d,0x8d,0xab,0xbc,
    0x8a,0x8a,0x8a,0x8b,0x8b,0x8b,0x8b,0x8c,0x8c,0x8c,0x9d,0x8d,0x8d,0x8d,0x9e,0x9e,
    0x9b,0x9b,0x9b,0x8b,0x9c,0x9c,0x9c,0x8c,0x9d,0x9d,0x9d,0x8d,0x8d,0x9e,0x9e,0xaf,
    0x9b,0x9b,0x9b,0x9c,0x9c,0xad,0xad,0x9d,0x9d,0x9d,0xae,0xae,0x9e,0x9e,0xaf,0xaf,
    0xac,0xac,0xac,0xad,0xad,0xad,0xad,0x9d,0xae,0xae,0xae,0xbf,0x9e,0xaf,0xaf,0xaf,
    0x9f,0x9f,0x9f,0x8f,0x90,0x90,0xa1,0x80,0x80,0x91,0x91,0x81,0x81,0x92,0xa3,0xb4,
    0x9f,0x9f,0x9f,0x8f,0x90,0x90,0xa1,0x80,0x80,0x91,0x91,0x81,0x81,0x92,0xa3,0xb4,
    0x9f,0x9f,0x9f,0x83,0x90,0x90,0xa1,0x80,0x80,0x91,0x91,0x81,0x81,0x92,0xa3,0xb4,
    0x82,0x82,0x82,0x83,0x83,0x94,0x94,0x84,0x84,0x95,0x95,0x85,0x85,0x96,0x96,0xa7,
    0x93,0x93,0x93,0x83,0x94,0x94,0x94,0x84,0x84,0x95,0x95,0x85,0x85,0x96,0xa7,0xa7,
    0x93,0x93,0x93,0x94,0x94,0x94,0xa5,0x84,0x95,0x95,0xa6,0xa6,0x96,0x96,0xa7,0xb8,
    0xa4,0xa4,0xa4,0x94,0x94,0xa5,0xa5,0x77,0x95,0x95,0xa6,0xa6,0x96,0xa7,0xa7,0xb8,
    0x86,0x86,0x86,0x87,0x87,0x87,0x77,0x88,0x88,0x88,0x99,0x89,0x89,0x9a,0x9a,0xb8,
    0x86,0x86,0x86,0x87,0x87,0x98,0x98,0x88,0x88,0x99,0x99,0x89,0x89,0x9a,0x9a,0xab,
    0x97,0x97,0x97,0x98,0x98,0x98,0x98,0x88,0x99,0x99,0x99,0x89,0x9a,0x9a,0xab,0xab,
    0x97,0x97,0x97,0x98,0x98,0xa9,0xa9,0x99,0x99,0x99,0xaa,0xaa,0x9a,0xab,0xab,0xbc,
    0x8a,0x8a,0x8a,0x8b,0x8b,0xa9,0xa9,0x8c,0x8c,0x8c,0xaa,0x8d,0x8d,0x8d,0xab,0xbc,
    0x8a,0x8a,0x8a,0x8b,0x8b,0x9c,0x9c,0x8c,0x8c,0x9d,0x9d,0x8d,0x8d,0x9e,0x9e,0xbc,
    0x9b,0x9b,0x9b,0x9c,0x9c,0x9c,0xad,0x9d,0x9d,0x9d,0xae,0x8d,0x9e,0x9e,0xaf,0xaf,
    0xac,0xac,0xac,0x9c,0xad,0xad,0xad,0x9d,0x9d,0xae,0xae,0xae,0x9e,0xaf,0xaf,0xaf,
    0xbd,0xbd,0xbd,0xad,0xad,0xbe,0xbe,0xbe,0xae,0xae,0xbf,0xbf,0xbf,0xaf,0xaf,0xb0,
    0xa0,0xa0,0xa0,0x90,0xa1,0xa1,0xa1,0xb2,0x91,0x91,0xa2,0xa2,0xb3,0xa3,0xa3,0xb4,
    0xa0,0xa0,0xa0,0x90,0xa1,0xa1,0xa1,0xb2,0x91,0x91,0xa2,0xa2,0xb3,0xa3,0xa3,0xb4,
    0xa0,0xa0,0xa0,0x90,0xa1,0xa1,0xa1,0xb2,0x91,0x91,0xa2,0xa2,0xb3,0xa3,0xa3,0xb4,
    0x93,0x93,0x93,0x94,0x94,0x94,0xa5,0x84,0x95,0x95,0xa6,0xa6,0x96,0x96,0xa7,0xb8,
    0xa4,0xa4,0xa4,0x94,0x94,0xa5,0xa5,0x84,0x95,0x95,0xa6,0xa6,0x96,0x96,0xa7,0xb8,
    0xa4,0xa4,0xa4,0x94,0xa5,0xa5,0xa5,0xb6,0x95,0xa6,0xa6,0xa6,0xb7,0xa7,0xa7,0xb8,
    0xa4,0xa4,0xa4,0xa5,0xa5,0xa5,0xb6,0xb6,0x95,0xa6,0xa6,0xb7,0xb7,0xa7,0xb8,0xb8,
    0xb5,0xb5,0xb5,0x87,0x87,0xb6,0xb6,0xb6,0x88,0x99,0xa6,0xb7,0xb7,0x9a,0xb8,0xb8,
    0x97,0x97,0x97,0x98,0x98,0x98,0x98,0x88,0x99,0x99,0x99,0x89,0x9a,0x9a,0xab,0xab,
    0x97,0x97,0x97,0x98,0x98,0xa9,0xa9,0x99,0x99,0x99,0xaa,0xaa,0x9a,0xab,0xab,0xbc,
    0xa8,0xa8,0xa8,0xa9,0xa9,0xa9,0xa9,0xa9,0x99,0xaa,0xaa,0xaa,0xbb,0xab,0xab,0xbc,
    0xa8,0xa8,0xa8,0xa9,0xa9,0xa9,0xba,0xba,0x8c,0xaa,0xaa,0xbb,0xbb,0xab,0xbc,0xbc,
    0xb9,0xb9,0xb9,0x9c,0x9c,0xba,0xba,0xba,0x9d,0x9d,0xbb,0xbb,0xbb,0x9e,0x9e,0xbc,
    0xac,0xac,0xac,0x9c,0x9c,0xad,0xad,0x9d,0x9d,0xae,0xae,0xae,0x9e,0x9e,0xaf,0xaf,
    0xac,0xac,0xac,0xad,0xad,0xad,0xbe,0xbe,0xae,0xae,0xae,0xbf,0x9e,0xaf,0xaf,0xb0,
    0xbd,0xbd,0xbd,0xbe,0xbe,0xbe,0xbe,0xbe,0xae,0xbf,0xbf,0xbf,0xbf,0xaf,0xb0,0xb0,
    0xb1,0xb1,0xb1,0xce,0xce,0xb2,0xb2,0xcf,0xcf,0xa2,0xa2,0xb3,0xb3,0xc0,0xb4,0xb4,
    0xb1,0xb1,0xb1,0xce,0xce,0xb2,0xb2,0xcf,0xcf,0xa2,0xa2,0xb3,0xb3,0xc0,0xb4,0xb4,
    0xb1,0xb1,0xb1,0xc2,0xc2,0xb2,0xb2,0xc3,0xc3,0xa2,0xa2,0xb3,0xb3,0xc0,0xb4,0xb4,
    0xc1,0xc1,0xc1,0xc2,0xc2,0xc2,0xa5,0xc3,0xc3,0xc3,0xa6,0xc4,0xc4,0xc4,0xa7,0xb8,
    0xc1,0xc1,0xc1,0xc2,0xc2,0xa5,0xb6,0xc3,0xc3,0xc3,0xa6,0xc4,0xc4,0xc4,0xb8,0xb8,
    0xb5,0xb5,0xb5,0xc2,0xa5,0xb6,0xb6,0xb6,0xc3,0xa6,0xa6,0xb7,0xb7,0xc4,0xb8,0xb8,
    0xb5,0xb5,0xb5,0xa5,0xb6,0xb6,0xb6,0xb6,0xc3,0xa6,0xb7,0xb7,0xb7,0xb7,0xb8,0xb8,
    0xc5,0xc5,0xc5,0xc6,0xc6,0xb6,0xb6,0xc7,0xc7,0xc7,0xb7,0xb7,0xc8,0xc8,0xb8,0xb8,
    0xc5,0xc5,0xc5,0xc6,0xc6,0xc6,0xc6,0xc7,0xc7,0xc7,0xaa,0xc8,0xc8,0xc8,0xab,0xbc,
    0xa8,0xa8,0xa8,0xc6,0xc6,0xa9,0xa9,0xc7,0xc7,0xaa,0xaa,0xaa,0xc8,0xc8,0xab,0xbc,
    0xa8,0xa8,0xa8,0xa9,0xa9,0xa9,0xba,0xba,0xaa,0xaa,0xaa,0xbb,0xbb,0xab,0xbc,0xbc,
    0xb9,0xb9,0xb9,0xca,0xca,0xba,0xba,0xba,0xcb,0xaa,0xbb,0xbb,0xbb,0xcc,0xbc,0xbc,
    0xb9,0xb9,0xb9,0xca,0xca,0xba,0xba,0xcb,0xcb,0xcb,0xbb,0xbb,0xcc,0xcc,0xcc,0xbc,
    0xc9,0xc9,0xc9,0xca,0xca,0xca,0xba,0xcb,0xcb,0xcb,0xae,0xcc,0xcc,0xcc,0xaf,0xaf,
    0xbd,0xbd,0xbd,0xad,0xbe,0xbe,0xbe,0xbe,0xae,0xae,0xbf,0xbf,0xcc,0xaf,0xaf,0xb0,
    0xbd,0xbd,0xbd,0xbe,0xbe,0xbe,0xbe,0xbe,0xbf,0xbf,0xbf,0xbf,0xbf,0xaf,0xb0,0xb0,
    0xcd,0xcd,0xcd,0xce,0xce,0xce,0xb2,0xcf,0xcf,0xcf,0xb3,0xb3,0xc0,0xc0,0xd1,0xb4,
    0xcd,0xcd,0xcd,0xce,0xce,0xce,0xb2,0xcf,0xcf,0xcf,0xb3,0xb3,0xc0,0xc0,0xd1,0xb4,
    0xc1,0xc1,0xc1,0xc2,0xc2,0xc2,0xb2,0xc3,0xc3,0xc3,0xb3,0xb3,0xc0,0xc0,0xd1,0xb4,
    0xc1,0xc1,0xc1,0xc2,0xc2,0xc2,0xc2,0xc3,0xc3,0xc3,0xd4,0xc4,0xc4,0xc4,0xd5,0xd5,
    0xc1,0xc1,0xc1,0xc2,0xc2,0xc2,0xb6,0xc3,0xc3,0xc3,0xd4,0xc4,0xc4,0xc4,0xd5,0xb8,
    0xc1,0xc1,0xc1,0xc2,0xc2,0xb6,0xb6,0xc3,0xc3,0xd4,0xb7,0xb7,0xc4,0xd5,0xd5,0xb8,
    0xb5,0xb5,0xb5,0xc2,0xb6,0xb6,0xb6,0xb6,0xc3,0xd4,0xb7,0xb7,0xb7,0xd5,0xd5,0xb8,
    0xc5,0xc5,0xc5,0xc6,0xc6,0xc6,0xb6,0xc7,0xc7,0xc7,0xb7,0xc8,0xc8,0xc8,0xd9,0xd9,
    0xc5,0xc5,0xc5,0xc6,0xc6,0xc6,0xc6,0xc7,0xc7,0xc7,0xd8,0xc8,0xc8,0xc8,0xd9,0xd9,
    0xc5,0xc5,0xc5,0xc6,0xc6,0xd7,0xd7,0xc7,0xc7,0xd8,0xd8,0xc8,0xc8,0xd9,0xd9,0xbc,
    0xb9,0xb9,0xb9,0xd7,0xd7,0xba,0xba,0xba,0xd8,0xd8,0xbb,0xbb,0xbb,0xd9,0xd9,0xbc,
    0xb9,0xb9,0xb9,0xca,0xca,0xba,0xba,0xcb,0xcb,0xcb,0xbb,0xbb,0xcc,0xcc,0xcc,0xbc,
    0xc9,0xc9,0xc9,0xca,0xca,0xca,0xba,0xcb,0xcb,0xcb,0xbb,0xcc,0xcc,0xcc,0xdd,0xdd,
    0xc9,0xc9,0xc9,0xca,0xca,0xdb,0xdb,0xcb,0xcb,0xdc,0xdc,0xcc,0xcc,0xdd,0xdd,0xdd,
    0xda,0xda,0xda,0xdb,0xdb,0xdb,0xdb,0xdc,0xdc,0xdc,0xdc,0xcc,0xdd,0xdd,0xdd,0xb0,
    0xbd,0xbd,0xbd,0xdb,0xbe,0xbe,0xbe,0xdc,0xdc,0xbf,0xbf,0xbf,0xdd,0xdd,0xb0,0xb0,
    0xde,0xde,0xde,0xdf,0xdf,0xdf,0xe0,0xcf,0xd0,0xd0,0xe1,0xc0,0xc0,0xd1,0xd1,0xe2,
    0xde,0xde,0xde,0xdf,0xdf,0xdf,0xe0,0xcf,0xd0,0xd0,0xe1,0xc0,0xc0,0xd1,0xd1,0xe2,
    0xde,0xde,0xde,0xdf,0xdf,0xdf,0xe0,0xc3,0xd0,0xd0,0xe1,0xc0,0xc0,0xd1,0xd1,0xe2,
    0xd2,0xd2,0xd2,0xc2,0xd3,0xd3,0xd3,0xc3,0xc3,0xd4,0xd4,0xc4,0xc4,0xd5,0xd5,0xe6,
    0xd2,0xd2,0xd2,0xd3,0xd3,0xd3,0xd3,0xc3,0xd4,0xd4,0xd4,0xc4,0xc4,0xd5,0xd5,0xe6,
    0xd2,0xd2,0xd2,0xd3,0xd3,0xd3,0xe4,0xc3,0xd4,0xd4,0xe5,0xc4,0xd5,0xd5,0xe6,0xe6,
    0xe3,0xe3,0xe3,0xd3,0xd3,0xe4,0xb6,0xd4,0xd4,0xe5,0xe5,0xb7,0xd5,0xd5,0xe6,0xe6,
    0xc5,0xc5,0xc5,0xc6,0xc6,0xc6,0xd7,0xc7,0xc7,0xd8,0xd8,0xc8,0xc8,0xd9,0xd9,0xd9,
    0xd6,0xd6,0xd6,0xc6,0xd7,0xd7,0xd7,0xc7,0xd8,0xd8,0xd8,0xc8,0xc8,0xd9,0xd9,0xea,
    0xd6,0xd6,0xd6,0xd7,0xd7,0xd7,0xe8,0xd8,0xd8,0xd8,0xe9,0xc8,0xd9,0xd9,0xea,0xea,
    0xe7,0xe7,0xe7,0xd7,0xd7,0xe8,0xe8,0xd8,0xd8,0xe9,0xe9,0xe9,0xd9,0xd9,0xea,0xea,
    0xc9,0xc9,0xc9,0xca,0xca,0xca,0xba,0xcb,0xcb,0xcb,0xe9,0xcc,0xcc,0xcc,0xea,0xea,
    0xc9,0xc9,0xc9,0xca,0xca,0xdb,0xdb,0xcb,0xcb,0xdc,0xdc,0xcc,0xcc,0xdd,0xdd,0xdd,
    0xda,0xda,0xda,0xdb,0xdb,0xdb,0xdb,0xdc,0xdc,0xdc,0xdc,0xcc,0xdd,0xdd,0xdd,0xee,
    0xda,0xda,0xda,0xdb,0xdb,0xec,0xec,0xdc,0xdc,0xed,0xed,0xed,0xdd,0xdd,0xee,0xee,
    0xeb,0xeb,0xeb,0xec,0xec,0xec,0xec,0xdc,0xed,0xed,0xed,0xed,0xdd,0xee,0xee,0xee,
    0xef,0xef,0xef,0xdf,0xe0,0xe0,0xe0,0xd0,0xd0,0xe1,0xe1,0xf2,0xd1,0xd1,0xe2,0xe2,
    0xef,0xef,0xef,0xdf,0xe0,0xe0,0xe0,0xd0,0xd0,0xe1,0xe1,0xf2,0xd1,0xd1,0xe2,0xe2,
    0xef,0xef,0xef,0xdf,0xe0,0xe0,0xe0,0xd0,0xd0,0xe1,0xe1,0xf2,0xd1,0xd1,0xe2,0xe2,
    0xd2,0xd2,0xd2,0xd3,0xd3,0xe4,0xe4,0xd4,0xd4,0xd4,0xe5,0xe5,0xd5,0xd5,0xe6,0xe6,
    0xe3,0xe3,0xe3,0xd3,0xe4,0xe4,0xe4,0xd4,0xd4,0xe5,0xe5,0xf6,0xd5,0xd5,0xe6,0xe6,
    0xe3,0xe3,0xe3,0xe4,0xe4,0xe4,0xe4,0xd4,0xe5,0xe5,0xe5,0xf6,0xd5,0xe6,0xe6,0xf7,
    0xe3,0xe3,0xe3,0xe4,0xe4,0xe4,0xf5,0xf5,0xe5,0xe5,0xf6,0xf6,0xd5,0xe6,0xe6,0xf7,
    0xd6,0xd6,0xd6,0xd7,0xd7,0xd7,0xf5,0xc7,0xd8,0xd8,0xf6,0xc8,0xd9,0xd9,0xd9,0xf7,
    0xd6,0xd6,0xd6,0xd7,0xd7,0xe8,0xe8,0xd8,0xd8,0xd8,0xe9,0xe9,0xd9,0xd9,0xea,0xea,
    0xe7,0xe7,0xe7,0xd7,0xe8,0xe8,0xe8,0xd8,0xd8,0xe9,0xe9,0xe9,0xd9,0xea,0xea,0xea,
    0xe7,0xe7,0xe7,0xe8,0xe8,0xe8,0xf9,0xf9,0xe9,0xe9,0xe9,0xfa,0xd9,0xea,0xea,0xfb,
    0xf8,0xf8,0xf8,0xe8,0xf9,0xf9,0xf9,0xcb,0xe9,0xe9,0xfa,0xfa,0xcc,0xea,0xea,0xfb,
    0xda,0xda,0xda,0xdb,0xdb,0xdb,0xdb,0xdc,0xdc,0xdc,0xdc,0xcc,0xdd,0xdd,0xdd,0xee,
    0xda,0xda,0xda,0xdb,0xdb,0xec,0xec,0xdc,0xdc,0xed,0xed,0xed,0xdd,0xdd,0xee,0xee,
    0xeb,0xeb,0xeb,0xec,0xec,0xec,0xec,0xdc,0xed,0xed,0xed,0xed,0xdd,0xee,0xee,0xee,
    0xeb,0xeb,0xeb,0xec,0xec,0xfd,0xfd,0xfd,0xed,0xed,0xfe,0xfe,0xee,0xee,0xee,0xff,
    0xf0,0xf0,0xf0,0xe0,0xf1,0xf1,0xf1,0xf1,0xe1,0xf2,0xf2,0xf2,0xf2,0xe2,0xe2,0xf3,
    0xf0,0xf0,0xf0,0xe0,0xf1,0xf1,0xf1,0xf1,0xe1,0xf2,0xf2,0xf2,0xf2,0xe2,0xe2,0xf3,
    0xf0,0xf0,0xf0,0xe0,0xf1,0xf1,0xf1,0xf1,0xe1,0xf2,0xf2,0xf2,0xf2,0xe2,0xe2,0xf3,
    0xe3,0xe3,0xe3,0xe4,0xe4,0xe4,0xf5,0xf5,0xe5,0xe5,0xf6,0xf6,0xd5,0xe6,0xe6,0xf7,
    0xf4,0xf4,0xf4,0xe4,0xe4,0xf5,0xf5,0xf5,0xe5,0xe5,0xf6,0xf6,0xf6,0xe6,0xe6,0xf7,
    0xf4,0xf4,0xf4,0xe4,0xf5,0xf5,0xf5,0xf5,0xe5,0xf6,0xf6,0xf6,0xf6,0xe6,0xf7,0xf7,
    0xf4,0xf4,0xf4,0xf5,0xf5,0xf5,0xf5,0xf5,0xe5,0xf6,0xf6,0xf6,0xf6,0xe6,0xf7,0xf7,
    0xf4,0xf4,0xf4,0xf5,0xf5,0xf5,0xf5,0xf5,0xd8,0xf6,0xf6,0xf6,0xd9,0xd9,0xf7,0xf7,
    0xe7,0xe7,0xe7,0xe8,0xe8,0xe8,0xe8,0xd8,0xe9,0xe9,0xe9,0xfa,0xd9,0xea,0xea,0xea,
    0xf8,0xf8,0xf8,0xe8,0xe8,0xf9,0xf9,0xf9,0xe9,0xe9,0xfa,0xfa,0xfa,0xea,0xea,0xfb,
    0xf8,0xf8,0xf8,0xf9,0xf9,0xf9,0xf9,0xf9,0xe9,0xfa,0xfa,0xfa,0xfa,0xea,0xfb,0xfb,
    0xf8,0xf8,0xf8,0xf9,0xf9,0xf9,0xf9,0xf9,0xfa,0xfa,0xfa,0xfa,0xfa,0xea,0xfb,0xfb,
    0xf8,0xf8,0xf8,0xdb,0xf9,0xf9,0xf9,0xdc,0xdc,0xfa,0xfa,0xfa,0xdd,0xdd,0xee,0xfb,
    0xeb,0xeb,0xeb,0xec,0xec,0xec,0xec,0xdc,0xed,0xed,0xed,0xed,0xdd,0xee,0xee,0xee,
    0xeb,0xeb,0xeb,0xec,0xec,0xfd,0xfd,0xfd,0xed,0xed,0xfe,0xfe,0xee,0xee,0xee,0xff,
    0xfc,0xfc,0xfc,0xfd,0xfd,0xfd,0xfd,0xfd,0xed,0xfe,0xfe,0xfe,0xfe,0xee,0xff,0xff,
}
};
@




%-------------------------------------------------------------

<<lib_graphics/libmemdraw/cmap.c>>=
/*
 * generated by mkcmap.c
 */
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>

<<global [[def]]>>
<<global [[memdefcmap]]>>
<<function [[_memmkcmap]]>>
@




\subsection{[[lib_graphics/libmemdraw/defont.c]]}

%used only for graphical text mode 

%-------------------------------------------------------------

<<lib_graphics/libmemdraw/defont.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <draw_private.h>
#include <font.h>
#include <memdraw.h>

<<function [[getmemdefont]]>>
@


\subsection{[[lib_graphics/libmemdraw/init.c]]}
%pad: I created this file; its content was in draw.c before.

%-------------------------------------------------------------

<<lib_graphics/libmemdraw/init.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <pool.h>

extern Pool* imagmem;

<<global [[memones]]>>
<<global [[memzeros]]>>
<<global [[memwhite]]>>
<<global [[memblack]]>>
<<global [[memtransparent]]>>
<<global [[memopaque]]>>

int	_ifmt(Fmt*);

extern int replmul[];

extern uchar replbit[1+8][256];

<<function [[mktables]]>>


<<function [[memimageinit]]>>

@

\subsection{[[lib_graphics/libmemdraw/alphadraw.c]]}
%pad: I created this file; its content was in draw.c before.

%-------------------------------------------------------------

<<lib_graphics/libmemdraw/alphadraw.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>

<<macro [[DBG1]]>>

<<function [[MUL]]>>
<<constant [[MASK13]]>>
<<constant [[MASK02]]>>
<<function [[MUL13]]>>
<<function [[MUL02]]>>
<<function [[MUL0123]]>>

<<global [[ones]]>>

/*
 * General alpha drawing case.  Can handle anything.
 */
typedef struct	Buffer	Buffer;
<<struct [[Buffer]]>>

typedef struct	ParamDraw	Param;
typedef Buffer	Readfn(Param*, uchar*, int);
typedef void	Writefn(Param*, uchar*, Buffer);
typedef Buffer	Calcfn(Buffer, Buffer, Buffer, int, int, int);

<<enum [[_anon_]]([[(lib_graphics/libmemdraw/draw.c)]])>>

<<struct [[ParamDraw]]>>

static Readfn	greymaskread, replread, readptr;

<<global [[nullwrite]]>>

static Calcfn	alphacalc0, alphacalc14, alphacalc2810, alphacalc3679, alphacalc5, alphacalc11, alphacalcS;
static Calcfn	boolcalc14, boolcalc236789, boolcalc1011;

static Readfn*	readfn(Memimage*);
static Readfn*	readalphafn(Memimage*);
static Writefn*	writefn(Memimage*);

static Calcfn*	boolcopyfn(Memimage*, Memimage*);
static Readfn*	convfn(Memimage*, Param*, Memimage*, Param*, int*);
static Readfn*	ptrfn(Memimage*);

<<global [[alphacalc]]>>

<<global [[boolcalc]]>>

/*
 * Avoid standard Lock, QLock so that can be used in kernel.
 */
typedef struct Dbuf Dbuf;
<<struct [[Dbuf]]>>
<<global [[dbuf]]>>

<<function [[allocdbuf]]>>

<<function [[getparam]]>>

<<function [[clipy]]>>

<<function [[alphadraw]]>>

<<function [[alphacalc0]]>>

<<function [[alphacalc14]]>>

<<function [[alphacalc2810]]>>

<<function [[alphacalc3679]]>>

<<function [[alphacalc5]]>>

<<function [[alphacalc11]]>>

<<function [[alphacalcS]]>>

<<function [[boolcalc14]]>>

<<function [[boolcalc236789]]>>

<<function [[boolcalc1011]]>>
<<function [[replread]]>>

<<function [[greymaskread]]>>

<<global [[replbit]]>>


<<function [[readnbit]]>>

<<function [[writenbit]]>>

<<function [[readcmap]]>>

<<function [[writecmap]]>>

<<function [[readbyte]]>>

<<function [[writebyte]]>>

<<function [[readfn]]>>

<<function [[readalphafn]]>>

<<function [[writefn]]>>

<<function [[nullwrite]]>>

<<function [[readptr]]>>

<<function [[boolmemmove]]>>

<<function [[boolcopy8]]>>

<<function [[boolcopy16]]>>

<<function [[boolcopy24]]>>

<<function [[boolcopy32]]>>

<<function [[genconv]]>>

<<function [[convfn]]>>

// in resolution.c now
extern ulong pixelbits(Memimage *i, Point pt);

<<function [[boolcopyfn]]>>


@

\subsection{[[lib_graphics/libmemdraw/color.c]]}
%pad: I created this file; its content was in draw.c before.
% the img<->rgba functions were static before.

%-------------------------------------------------------------

<<lib_graphics/libmemdraw/color.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>

<<macro [[DBG1]]>>

<<function [[imgtorgba]]>>

<<function [[rgbatoimg]]>>

// could put memfillcolor in draw.c so no need those extern decls.
extern void memsetl(void *vp, ulong val, int n);
extern void memset24(void *vp, ulong val, int n);

<<function [[memfillcolor]]>>
@

\subsection{[[lib_graphics/libmemdraw/draw.c]]}

%dead:
%<<function DIV255>>=
%/*
% * for 0  x  255*255, (x*0x0101+0x100)>>16 is a perfect approximation.
% * for 0  x < (1<<16), x/255 = ((x+1)*0x0101)>>16 is a perfect approximation.
% * the last one is perfect for all up to 1<<16, avoids a multiply, but requires a rathole.
% */ // >> >>
%#define DIV255(x) ((((x)+1)*257)>>16)
%@
%/* #define DIV255(x) (((x)*257+256)>>16)  */
%/* #define DIV255(x) (tmp=(x)+1, (tmp+(tmp>>8))>>8) */



%dead:
%<<function MUL2>>=
%#define MUL2(u, v, x, y)	(t = (u)*(v)+(x)*(y)+256, (t+(t>>8))>>8)
%@



%dead: now a local
%<<global drawbuf>>=
%static uchar *drawbuf;
%@

%dead: now a local
%<<global ndrawbuf>>=
%static int	ndrawbuf;
%@

%dead:
%<<global mdrawbuf>>=
%static int	mdrawbuf;
%@


%dead:
%<<function memsetb>>=
%/*
% * Optimized draw for filling and scrolling; uses memset and memmove.
% */
%static void
%memsetb(void *vp, uchar val, int n)
%{
%    uchar *p, *ep;
%
%    p = vp;
%    ep = p+n;
%    while(p<ep)
%        *p++ = val;
%}
%@


%/*
% * Fill entire byte with replicated (if necessary) copy of source pixel,
% * assuming destination ldepth is >= source ldepth.
% *
% * This code is just plain wrong for >8bpp.
% *
%ulong
%membyteval(Memimage *src)
%{
%    int i, val, bpp;
%    uchar uc;
%
%    unloadmemimage(src, src->r, &uc, 1);
%    bpp = src->depth;
%    uc <<= (src->r.min.x&(7/src->depth))*src->depth;
%    uc &= ~(0xFF>>bpp);
%    /* pixel value is now in high part of byte. repeat throughout byte 
%    val = uc;
%    for(i=bpp; i<8; i<<=1)
%        val |= val>>i;
%    return val;
%}
% * 
% */


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/draw.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>

<<macro [[DBG1]]>>
<<macro [[DBG]]>>

<<global [[drawdebug]]>>

typedef int Subdraw(Memdrawparam*);
static Subdraw chardraw, memoptdraw;

// in alphadraw.c
Subdraw alphadraw;
// in color.c
ulong imgtorgba(Memimage*, ulong);
ulong rgbatoimg(Memimage*, ulong);
// in resolution.c
ulong pixelbits(Memimage*, Point);

<<function [[memimagedraw]]>>

<<function [[drawclip]]>>



<<function [[memsets]]>>

<<function [[memsetl]]>>

<<function [[memset24]]>>

<<function [[memoptdraw]]>>

<<function [[chardraw]]>>

@
% >>


%/*
%not used yet
%source and mask alpha 1
%static Buffer
%alphacalcS0(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, int grey, int op)
%{
%    Buffer obdst;
%    int i;
%
%    USED(op);
%    obdst = bdst;
%    if(bsrc.delta == bdst.delta){
%        memmove(bdst.rgba, bsrc.rgba, dx*bdst.delta);
%        return obdst;
%    }
%    for(i=0; i<dx; i++){
%        if(grey){
%            *bdst.grey = *bsrc.grey;
%            bsrc.grey += bsrc.delta;
%            bdst.grey += bdst.delta;
%        }else{
%            *bdst.red = *bsrc.red;
%            *bdst.grn = *bsrc.grn;
%            *bdst.blu = *bsrc.blu;
%            bsrc.red += bsrc.delta;
%            bsrc.blu += bsrc.delta;
%            bsrc.grn += bsrc.delta;
%            bdst.red += bdst.delta;
%            bdst.blu += bdst.delta;
%            bdst.grn += bdst.delta;
%        }
%        if(bdst.alpha != &ones){
%            *bdst.alpha = 255;
%            bdst.alpha += bdst.delta;
%        }
%    }
%    return obdst;
%}
%*/


\subsection{[[lib_graphics/libmemdraw/ellipse.c]]}


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/ellipse.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

/*
 * ellipse(dst, c, a, b, t, src, sp)
 *   draws an ellipse centered at c with semiaxes a,b>=0
 *   and semithickness t>=0, or filled if t<0.  point sp
 *   in src maps to c in dst
 *
 *   very thick skinny ellipses are brushed with circles (slow)
 *   others are approximated by filling between 2 ellipses
 *   criterion for very thick when b<a: t/b > 0.5*x/(1-x)
 *   where x = b/a
 */

typedef struct ParamEllipse	Param;
typedef struct State	State;

static	void	bellipse(int, State*, Param*);
static	void	erect(int, int, int, int, Param*);
static	void	eline(int, int, int, int, Param*);

<<struct [[ParamEllipse]]>>

<<struct [[State]]>>

<<function [[newstate]]>>

<<function [[step]]>>

<<function [[memellipse]]>>

<<global [[p00]]([[(lib_graphics/libmemdraw/ellipse.c)]])>>

<<function [[bellipse]]>>

<<function [[erect]]>>

<<function [[epoint]]>>

<<function [[eline]]>>
@


\subsection{[[lib_graphics/libmemdraw/fillpoly.c]]}


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/fillpoly.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

typedef struct Seg	Seg;

<<struct [[Seg]]>>

static	void	zsort(Seg **seg, Seg **ep);
static	int	ycompare(void*, void*);
static	int	xcompare(void*, void*);
static	int	zcompare(void*, void*);
static	void	xscan(Memimage *dst, Seg **seg, Seg *segtab, int nseg, int wind, Memimage *src, Point sp, int, int, int, int);
static	void	yscan(Memimage *dst, Seg **seg, Seg *segtab, int nseg, int wind, Memimage *src, Point sp, int, int);

<<function [[fillline]]>>

<<function [[fillpoint]]>>

<<function [[memfillpoly]]>>

<<function [[_memfillpolysc]]>>

<<function [[mod]]>>

<<function [[sdiv]]>>

<<function [[smuldivmod]]>>

<<function [[xscan]]>>

<<function [[yscan]]>>

<<function [[zsort]]>>

<<function [[ycompare]]>>

<<function [[xcompare]]>>

<<function [[zcompare]]>>
@


\subsection{[[lib_graphics/libmemdraw/hooks.c]]}
%pad: I created this file; its content was in hwdraw.c and iprint.c before

% need that? kernel cruft for app outside kernel linking with memdraw.a.

% the kernel/ defines the real one.
%alt: testing apps can just define it each time.

% overriden!
<<function [[memdraw_hwdraw]]>>=
int
hwdraw(Memdrawparam*)
{
    return 0;	/* could not satisfy request */
}
@

<<function [[memdraw_iprint]]>>=
int
memdraw_iprint(char*,...)
{
    return -1;
}
@

<<global [[iprint]]>>=
int		(*iprint)(char*, ...) = &memdraw_iprint;
@


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/hooks.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>

<<function [[memdraw_hwdraw]]>>

<<function [[memdraw_iprint]]>>

<<global [[iprint]]>>

@

%\subsection{[[lib_graphics/libmemdraw/iprint.c]]}

%\subsection{[[lib_graphics/libmemdraw/hwdraw.c]]}




\subsection{[[lib_graphics/libmemdraw/line.c]]}


%<<function lmin>>=
%static
%int
%lmin(int a, int b)
%{
%    if(a < b)
%        return a;
%    return b;
%}
%@


%% version not used

%<<function horline1>>=
%/*
% * Rather than line clip, we run the Bresenham loop over the full line,
% * and clip on each pixel.  This is more expensive but means that
% * lines look the same regardless of how the windowing has tiled them.
% * For speed, we check for clipping outside the loop and make the
% * test easy when possible.
% */
%static
%void
%horline1(Memimage *dst, Point p0, Point p1, int srcval, Rectangle clipr)
%{
%    int x, y, dy, deltay, deltax, maxx;
%    int dd, easy, e, bpp, m, m0;
%    uchar *d;
%
%    deltax = p1.x - p0.x;
%    deltay = p1.y - p0.y;
%    dd = dst->width*sizeof(ulong);
%    dy = 1;
%    if(deltay < 0){
%        dd = -dd;
%        deltay = -deltay;
%        dy = -1;
%    }
%    maxx = lmin(p1.x, clipr.max.x-1);
%    bpp = dst->depth;
%    m0 = 0xFF^(0xFF>>bpp);
%    m = m0 >> (p0.x&(7/dst->depth))*bpp;
%    easy = ptinrect(p0, clipr) && ptinrect(p1, clipr);
%    e = 2*deltay - deltax;
%    y = p0.y;
%    d = byteaddr(dst, p0);
%    deltay *= 2;
%    deltax = deltay - 2*deltax;
%    for(x=p0.x; x<=maxx; x++){
%        if(easy || (clipr.min.x<=x && clipr.min.y<=y && y<clipr.max.y))
%            *d ^= (*d^srcval) & m;
%        if(e > 0){
%            y += dy;
%            d += dd;
%            e += deltax;
%        }else
%            e += deltay;
%        d++;
%        m >>= bpp;
%        if(m == 0)
%            m = m0;
%    }
%}
%@
%

%% version not used

%<<function verline1>>=
%static
%void
%verline1(Memimage *dst, Point p0, Point p1, int srcval, Rectangle clipr)
%{
%    int x, y, deltay, deltax, maxy;
%    int easy, e, bpp, m, m0, dd;
%    uchar *d;
%
%    deltax = p1.x - p0.x;
%    deltay = p1.y - p0.y;
%    dd = 1;
%    if(deltax < 0){
%        dd = -1;
%        deltax = -deltax;
%    }
%    maxy = lmin(p1.y, clipr.max.y-1);
%    bpp = dst->depth;
%    m0 = 0xFF^(0xFF>>bpp);
%    m = m0 >> (p0.x&(7/dst->depth))*bpp;
%    easy = ptinrect(p0, clipr) && ptinrect(p1, clipr);
%    e = 2*deltax - deltay;
%    x = p0.x;
%    d = byteaddr(dst, p0);
%    deltax *= 2;
%    deltay = deltax - 2*deltay;
%    for(y=p0.y; y<=maxy; y++){
%        if(easy || (clipr.min.y<=y && clipr.min.x<=x && x<clipr.max.x))
%            *d ^= (*d^srcval) & m;
%        if(e > 0){
%            x += dd;
%            d += dd;
%            e += deltay;
%        }else
%            e += deltax;
%        d += dst->width*sizeof(ulong);
%        m >>= bpp;
%        if(m == 0)
%            m = m0;
%    }
%}
%@
%
%% version not used

%<<function horliner>>=
%static
%void
%horliner(Memimage *dst, Point p0, Point p1, Memimage *src, Point dsrc, Rectangle clipr)
%{
%    int x, y, sx, sy, deltay, deltax, minx, maxx;
%    int bpp, m, m0;
%    uchar *d, *s;
%
%    deltax = p1.x - p0.x;
%    deltay = p1.y - p0.y;
%    sx = drawreplxy(src->r.min.x, src->r.max.x, p0.x+dsrc.x);
%    minx = lmax(p0.x, clipr.min.x);
%    maxx = lmin(p1.x, clipr.max.x-1);
%    bpp = dst->depth;
%    m0 = 0xFF^(0xFF>>bpp);
%    m = m0 >> (minx&(7/dst->depth))*bpp;
%    for(x=minx; x<=maxx; x++){
%        y = p0.y + (deltay*(x-p0.x)+deltax/2)/deltax;
%        if(clipr.min.y<=y && y<clipr.max.y){
%            d = byteaddr(dst, Pt(x, y));
%            sy = drawreplxy(src->r.min.y, src->r.max.y, y+dsrc.y);
%            s = byteaddr(src, Pt(sx, sy));
%            *d ^= (*d^*s) & m;
%        }
%        if(++sx >= src->r.max.x)
%            sx = src->r.min.x;
%        m >>= bpp;
%        if(m == 0)
%            m = m0;
%    }
%}
%@
%

%% version not used

%<<function verliner>>=
%static
%void
%verliner(Memimage *dst, Point p0, Point p1, Memimage *src, Point dsrc, Rectangle clipr)
%{
%    int x, y, sx, sy, deltay, deltax, miny, maxy;
%    int bpp, m, m0;
%    uchar *d, *s;
%
%    deltax = p1.x - p0.x;
%    deltay = p1.y - p0.y;
%    sy = drawreplxy(src->r.min.y, src->r.max.y, p0.y+dsrc.y);
%    miny = lmax(p0.y, clipr.min.y);
%    maxy = lmin(p1.y, clipr.max.y-1);
%    bpp = dst->depth;
%    m0 = 0xFF^(0xFF>>bpp);
%    for(y=miny; y<=maxy; y++){
%        if(deltay == 0)	/* degenerate line */
%            x = p0.x;
%        else
%            x = p0.x + (deltax*(y-p0.y)+deltay/2)/deltay;
%        if(clipr.min.x<=x && x<clipr.max.x){
%            m = m0 >> (x&(7/dst->depth))*bpp;
%            d = byteaddr(dst, Pt(x, y));
%            sx = drawreplxy(src->r.min.x, src->r.max.x, x+dsrc.x);
%            s = byteaddr(src, Pt(sx, sy));
%            *d ^= (*d^*s) & m;
%        }
%        if(++sy >= src->r.max.y)
%            sy = src->r.min.y;
%    }
%}
%@
%

%% version not used

%<<function horline>>=
%static
%void
%horline(Memimage *dst, Point p0, Point p1, Memimage *src, Point dsrc, Rectangle clipr)
%{
%    int x, y, deltay, deltax, minx, maxx;
%    int bpp, m, m0;
%    uchar *d, *s;
%
%    deltax = p1.x - p0.x;
%    deltay = p1.y - p0.y;
%    minx = lmax(p0.x, clipr.min.x);
%    maxx = lmin(p1.x, clipr.max.x-1);
%    bpp = dst->depth;
%    m0 = 0xFF^(0xFF>>bpp);
%    m = m0 >> (minx&(7/dst->depth))*bpp;
%    for(x=minx; x<=maxx; x++){
%        y = p0.y + (deltay*(x-p0.x)+deltay/2)/deltax;
%        if(clipr.min.y<=y && y<clipr.max.y){
%            d = byteaddr(dst, Pt(x, y));
%            s = byteaddr(src, addpt(dsrc, Pt(x, y)));
%            *d ^= (*d^*s) & m;
%        }
%        m >>= bpp;
%        if(m == 0)
%            m = m0;
%    }
%}
%@
%

%% version not used

%<<function verline>>=
%static
%void
%verline(Memimage *dst, Point p0, Point p1, Memimage *src, Point dsrc, Rectangle clipr)
%{
%    int x, y, deltay, deltax, miny, maxy;
%    int bpp, m, m0;
%    uchar *d, *s;
%
%    deltax = p1.x - p0.x;
%    deltay = p1.y - p0.y;
%    miny = lmax(p0.y, clipr.min.y);
%    maxy = lmin(p1.y, clipr.max.y-1);
%    bpp = dst->depth;
%    m0 = 0xFF^(0xFF>>bpp);
%    for(y=miny; y<=maxy; y++){
%        if(deltay == 0)	/* degenerate line */
%            x = p0.x;
%        else
%            x = p0.x + deltax*(y-p0.y)/deltay;
%        if(clipr.min.x<=x && x<clipr.max.x){
%            m = m0 >> (x&(7/dst->depth))*bpp;
%            d = byteaddr(dst, Pt(x, y));
%            s = byteaddr(src, addpt(dsrc, Pt(x, y)));
%            *d ^= (*d^*s) & m;
%        }
%    }
%}
%@


% who calls that??
%<<function memimageline>>=
%void
%memimageline(Memimage *dst, Point p0, Point p1, int end0, int end1, int radius, Memimage *src, Point sp, int op)
%{
%    _memimageline(dst, p0, p1, end0, end1, radius, src, sp, dst->clipr, op);
%}
%@


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/line.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<enum [[_anon_]]([[(lib_graphics/libmemdraw/line.c)]])>>

<<function [[membrush]]>>

<<function [[discend]]>>

<<function [[arrowend]]>>

<<function [[_memimageline]]>>

<<function [[addbbox]]>>

<<function [[memlineendsize]]>>

<<function [[lmax]]>>

<<function [[memlinebbox]]>>
@


\subsection{[[lib_graphics/libmemdraw/transfer.c]]}
%pad: I created this file; its content was in load.c and unload.c before.


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/transfer.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>

<<function [[loadmemimage]]>>

<<function [[unloadmemimage]]>>
@

%\subsection{[[lib_graphics/libmemdraw/load.c]]}

%\subsection{[[lib_graphics/libmemdraw/unload.c]]}





\subsection{[[lib_graphics/libmemdraw/poly.c]]}


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/poly.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<function [[mempoly]]>>
@


\subsection{[[lib_graphics/libmemdraw/io.c]]}
%pad: I created this file; its content was in read.c and write.c before


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/io.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <draw_private.h>
#include <memdraw.h>

<<function [[readmemimage]]>>

<<function [[creadmemimage]]>>



<<constant [[CHUNK]]>>

<<constant [[HSHIFT]]([[(lib_graphics/libmemdraw/write.c)]])>>
<<constant [[NHASH]]([[(lib_graphics/libmemdraw/write.c)]])>>
<<constant [[HMASK]]([[(lib_graphics/libmemdraw/write.c)]])>>
<<function [[hupdate]]([[(lib_graphics/libmemdraw/write.c)]])>>
typedef struct Hlist Hlist;
<<struct [[Hlist]]([[(lib_graphics/libmemdraw/write.c)]])>>

<<function [[writememimage]]>>

@

%\subsection{[[lib_graphics/libmemdraw/read.c]]}

%\subsection{[[lib_graphics/libmemdraw/write.c]]}


\subsection{[[lib_graphics/libmemdraw/string.c]]}



%-------------------------------------------------------------

<<lib_graphics/libmemdraw/string.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>
#include <font.h>

<<function [[memimagestring]]>>

<<function [[memsubfontwidth]]>>
@


\subsection{[[lib_graphics/libmemdraw/subfont.c]]}


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/subfont.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>

<<function [[allocmemsubfont]]>>

@
%dead:
%<<function freememsubfont>>

%dead:
%   <<function freememsubfont>>=
%   void
%   freememsubfont(Memsubfont *f)
%   {
%       if(f == 0)
%           return;
%       free(f->info);	/* note: f->info must have been malloc'ed! */
%       freememimage(f->bits);
%       free(f);
%   }
%   @


%\subsection{[[lib_graphics/libmemdraw/openmemsubfont.c]]}
%dead:

%-------------------------------------------------------------

%<<lib_graphics/libmemdraw/openmemsubfont.c>>=
%#include <u.h>
%#include <libc.h>
%#include <draw.h>
%#include <memdraw.h>
%
%@
%dead: <<function openmemsubfont>>

%dead:
%  <<function openmemsubfont>>=
%  Memsubfont*
%  openmemsubfont(char *name)
%  {
%      Memsubfont *sf;
%      Memimage *i;
%      Fontchar *fc;
%      int fd, n;
%      char hdr[3*12+4+1];
%      uchar *p;
%  
%      fd = open(name, OREAD);
%      if(fd < 0)
%          return nil;
%      p = nil;
%      i = readmemimage(fd);
%      if(i == nil)
%          goto Err;
%      if(read(fd, hdr, 3*12) != 3*12){
%          werrstr("openmemsubfont: header read error: %r");
%          goto Err;
%      }
%      n = atoi(hdr);
%      p = malloc(6*(n+1));
%      if(p == nil)
%          goto Err;
%      if(read(fd, p, 6*(n+1)) != 6*(n+1)){
%          werrstr("openmemsubfont: fontchar read error: %r");
%          goto Err;
%      }
%      fc = malloc(sizeof(Fontchar)*(n+1));
%      if(fc == nil)
%          goto Err;
%      _unpackinfo(fc, p, n);
%      sf = allocmemsubfont(name, n, atoi(hdr+12), atoi(hdr+24), fc, i);
%      if(sf == nil){
%          free(fc);
%          goto Err;
%      }
%      free(p);
%      return sf;
%  Err:
%      close(fd);
%      if (i != nil)
%          freememimage(i);
%      if (p != nil)
%          free(p);
%      return nil;
%  }
%  @





\section{[[lib_graphics/libmemdraw/scripts/]]}

\subsection{[[lib_graphics/libmemdraw/scripts/mkcmap.c]]}

<<function [[mkcmap]]>>=
/*
struct Memcmap
{
    uchar	cmap2rgb[3*256];
    uchar	rgb2cmap[16*16*16];
};
*/

static Memcmap*
mkcmap(void)
{
    static Memcmap def;

    int i, rgb, r, g, b;

    for(i=0; i<256; i++){
        rgb = cmap2rgb(i);
        r = (rgb>>16)&0xff;
        g = (rgb>>8)&0xff;
        b = rgb&0xff;
        def.cmap2rgb[3*i] = r;
        def.cmap2rgb[3*i+1] = g;
        def.cmap2rgb[3*i+2] = b;
    }

    for(r=0; r<16; r++)
    for(g=0; g<16; g++)
    for(b=0; b<16; b++)
        def.rgb2cmap[r*16*16+g*16+b] = rgb2cmap(r*0x11, g*0x11, b*0x11);
    return &def;
}
@

<<function [[main]]([[(lib_graphics/libmemdraw/scripts/mkcmap.c)]])>>=
void
main(int argc, char **argv)
{
    Memcmap *c;
    int i, j;

    ARGBEGIN{
    }ARGEND

    memimageinit();
    c = mkcmap();

    print("#include <u.h>\n#include <libc.h>\n");
    print("#include <draw.h>\n");
    print("#include <memdraw.h>\n\n");
    print("static Memcmap def = {\n");
    print("/* cmap2rgb */ {\n");
    for(i=0; i<sizeof(c->cmap2rgb); ){
        print("\t");
        for(j=0; j<16; j++, i++)
            print("0x%2.2ux,", c->cmap2rgb[i]);
        print("\n");
    }
    print("},\n");
    print("/* rgb2cmap */ {\n");
    for(i=0; i<sizeof(c->rgb2cmap);){
        print("\t");
        for(j=0; j<16; j++, i++)
            print("0x%2.2ux,", c->rgb2cmap[i]);
        print("\n");
    }
    print("}\n");
    print("};\n");
    print("Memcmap *memdefcmap = &def;\n");
    print("void _memmkcmap(void){}\n");
    exits(0);
}
@


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/scripts/mkcmap.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>

<<function [[mkcmap]]>>

<<function [[main]]([[(lib_graphics/libmemdraw/scripts/mkcmap.c)]])>>
@


\section{[[lib_graphics/libmemdraw/tests/]]}

\subsection{[[lib_graphics/libmemdraw/tests/arctest.c]]}

<<function [[main]]([[(lib_graphics/libmemdraw/tests/arctest.c)]])>>=
void
main(int argc, char **argv)
{
    Memimage *x;
    Point c = {208,871};
    int a = 441;
    int b = 441;
    int thick = 0;
    Point sp = {0,0};
    int alpha = 51;
    int phi = 3;
    vlong t0, t1;
    int i, n;
    vlong del;

    if (argc != 2) {
        fprint(2, "usage: arctest number\n");
        exits("usage");
    }
    memimageinit();

    x = allocmemimage(Rect(0,0,1000,1000), CMAP8);
    n = atoi(argv[1]);

    t0 = nsec();
    t0 = nsec();
    t0 = nsec();
    t1 = nsec();
    del = t1-t0;
    t0 = nsec();
    for(i=0; i<n; i++)
        memarc(x, c, a, b, thick, memblack, sp, alpha, phi, SoverD);
    t1 = nsec();
    print("%lld %lld\n", t1-t0-del, del);
}
@


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/tests/arctest.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<function [[main]]([[(lib_graphics/libmemdraw/tests/arctest.c)]])>>
@

%//static int drawdebug = 0;
%//
%//void
%//rdb(void)
%//{
%//}
%//
%//int
%//iprint(char *fmt, ...)
%//{
%//	int n;	
%//	va_list va;
%//	char buf[1024];
%//
%//	va_start(va, fmt);
%//	n = vseprint(buf, buf+sizeof buf, fmt, va) - buf;
%//	va_end(va);
%//
%//	write(1,buf,n);
%//	return 1;
%//}


\subsection{[[lib_graphics/libmemdraw/tests/memdrawtest.c]]}

<<function [[RGB2K]]([[(lib_graphics/libmemdraw/tests/memdrawtest.c)]])>>=
#define RGB2K(r,g,b)	((299*((ulong)(r))+587*((ulong)(g))+114*((ulong)(b)))/1000)
@
\l factorize with the one in memdraw.h now?

<<global [[drawdebug]]([[(lib_graphics/libmemdraw/tests/memdrawtest.c)]])>>=
//old: used to have static in front, but at some point I got
//some errors (I probably introduced some regressions in 8c of kencc)
int drawdebug=0;
@

<<global [[seed]]>>=
static int	seed;
@

<<global [[niters]]>>=
static int	niters = 100;
@

<<global [[dbpp]]>>=
static int	dbpp;	/* bits per pixel in destination */
@

<<global [[sbpp]]>>=
static int	sbpp;	/* bits per pixel in src */
@

<<global [[mbpp]]>>=
static int	mbpp;	/* bits per pixel in mask */
@

<<global [[dpm]]>>=
static int	dpm;	/* pixel mask at high part of byte, in destination */
@

<<global [[nbytes]]>>=
static int	nbytes;	/* in destination */
@

<<global [[Xrange]]>>=
static int	Xrange	= 64;
@

<<global [[Yrange]]>>=
static int	Yrange	= 8;
@

<<global [[dst]]>>=
static Memimage	*dst;
@

<<global [[src]]>>=
static Memimage	*src;
@

<<global [[mask]]>>=
static Memimage	*mask;
@

<<global [[stmp]]>>=
static Memimage	*stmp;
@

<<global [[mtmp]]>>=
static Memimage	*mtmp;
@

<<global [[ones]]([[(lib_graphics/libmemdraw/tests/memdrawtest.c)]])>>=
static Memimage	*ones;
@

<<global [[dstbits]]>>=
static uchar	*dstbits;
@

<<global [[srcbits]]>>=
static uchar	*srcbits;
@

<<global [[maskbits]]>>=
static uchar	*maskbits;
@

<<global [[savedstbits]]>>=
static ulong	*savedstbits;
@

<<function [[main]]([[(lib_graphics/libmemdraw/tests/memdrawtest.c)]])>>=
void
main(int argc, char *argv[])
{
    memimageinit();
    seed = time(0);

    ARGBEGIN{
    case 'x':
        Xrange = atoi(ARGF());
        break;
    case 'y':
        Yrange = atoi(ARGF());
        break;
    case 'n':
        niters = atoi(ARGF());
        break;
    case 's':
        seed = atoi(ARGF());
        break;
    }ARGEND

    dchan = "r8g8b8";
    schan = "r8g8b8";
    mchan = "r8g8b8";
    switch(argc){
    case 3:	mchan = argv[2];
    case 2:	schan = argv[1];
    case 1:	dchan = argv[0];
    case 0:	break;
    default:	goto Usage;
    Usage:
        fprint(2, "usage: dtest [dchan [schan [mchan]]]\n");
        exits("usage");
    }

//	fmtinstall('b', numbconv);	/* binary! */

    fprint(2, "%s -x %d -y %d -s 0x%x %s %s %s\n", argv0, Xrange, Yrange, seed, dchan, schan, mchan);
    srand(seed);

    dst = allocmemimage(Rect(0, 0, Xrange, Yrange), strtochan(dchan));
    src = allocmemimage(Rect(0, 0, Xrange, Yrange), strtochan(schan));
    mask = allocmemimage(Rect(0, 0, Xrange, Yrange), strtochan(mchan));
    stmp = allocmemimage(Rect(0, 0, Xrange, Yrange), strtochan(schan));
    mtmp = allocmemimage(Rect(0, 0, Xrange, Yrange), strtochan(mchan));
    ones = allocmemimage(Rect(0, 0, Xrange, Yrange), strtochan(mchan));
//	print("chan %lux %lux %lux %lux %lux %lux\n", dst->chan, src->chan, mask->chan, stmp->chan, mtmp->chan, ones->chan);
    if(dst==0 || src==0 || mask==0 || mtmp==0 || ones==0) {
    Alloc:
        fprint(2, "dtest: allocation failed: %r\n");
        exits("alloc");
    }
    nbytes = (4*Xrange+4)*Yrange;
    srcbits = malloc(nbytes);
    dstbits = malloc(nbytes);
    maskbits = malloc(nbytes);
    savedstbits = malloc(nbytes);
    if(dstbits==0 || srcbits==0 || maskbits==0 || savedstbits==0)
        goto Alloc;
    dbpp = dst->depth;
    sbpp = src->depth;
    mbpp = mask->depth;
    dpm = 0xFF ^ (0xFF>>dbpp);
    memset(ones->data->bdata, 0xFF, ones->width*sizeof(ulong)*Yrange);


    fprint(2, "dtest: verify single pixel operation\n");
    verifyone();

    fprint(2, "dtest: verify full line non-replicated\n");
    verifyline();

    fprint(2, "dtest: verify full rectangle non-replicated\n");
    verifyrect();

    fprint(2, "dtest: verify full rectangle source replicated\n");
    verifyrectrepl(1, 0);

    fprint(2, "dtest: verify full rectangle mask replicated\n");
    verifyrectrepl(0, 1);

    fprint(2, "dtest: verify full rectangle source and mask replicated\n");
    verifyrectrepl(1, 1);

    exits(0);
}
@

<<function [[Bprintr5g6b5]]>>=
/*
 * Dump out an ASCII representation of an image.  The label specifies
 * a list of characters to put at various points in the picture.
 */
static void
Bprintr5g6b5(Biobuf *bio, char*, ulong v)
{
    int r,g,b;
    r = (v>>11)&31;
    g = (v>>5)&63;
    b = v&31;
    Bprint(bio, "%.2x%.2x%.2x", r,g,b);
}
@

<<function [[Bprintr5g5b5a1]]>>=
static void
Bprintr5g5b5a1(Biobuf *bio, char*, ulong v)
{
    int r,g,b,a;
    r = (v>>11)&31;
    g = (v>>6)&31;
    b = (v>>1)&31;
    a = v&1;
    Bprint(bio, "%.2x%.2x%.2x%.2x", r,g,b,a);
}
@

<<function [[dumpimage]]>>=
void
dumpimage(char *name, Memimage *img, void *vdata, Point labelpt)
{
    Biobuf b;
    uchar *data;
    uchar *p;
    char *arg;
    void (*fmt)(Biobuf*, char*, ulong);
    int npr, x, y, nb, bpp;
    ulong v, mask;
    Rectangle r;

    fmt = nil;
    arg = nil;
    switch(img->depth){
    case 1:
    case 2:
    case 4:
        fmt = (void(*)(Biobuf*,char*,ulong))Bprint;
        arg = "%.1ux";
        break;
    case 8:
        fmt = (void(*)(Biobuf*,char*,ulong))Bprint;
        arg = "%.2ux";
        break;
    case 16:
        arg = nil;
        if(img->chan == RGB16)
            fmt = Bprintr5g6b5;
        else{
            fmt = (void(*)(Biobuf*,char*,ulong))Bprint;
            arg = "%.4ux";
        }
        break;
    case 24:
        fmt = (void(*)(Biobuf*,char*,ulong))Bprint;
        arg = "%.6lux";
        break;
    case 32:
        fmt = (void(*)(Biobuf*,char*,ulong))Bprint;
        arg = "%.8lux";
        break;
    }
    if(fmt == nil){
        fprint(2, "bad format\n");
        abort();
    }

    r  = img->r;
    Binit(&b, 2, OWRITE);
    data = vdata;
    bpp = img->depth;
    Bprint(&b, "%s\t%d\tr %R clipr %R repl %d data %p *%P\n", name, r.min.x, r, img->clipr, (img->flags&Frepl) ? 1 : 0, vdata, labelpt);
    mask = (1ULL<<bpp)-1;
//	for(y=r.min.y; y<r.max.y; y++){
    for(y=0; y<Yrange; y++){
        nb = 0;
        v = 0;
        p = data+(byteaddr(img, Pt(0,y))-(uchar*)img->data->bdata);
        Bprint(&b, "%-4d\t", y);
//		for(x=r.min.x; x<r.max.x; x++){
        for(x=0; x<Xrange; x++){
            if(x==0)
                Bprint(&b, "\t");

            if(x != 0 && (x%8)==0)
                Bprint(&b, " ");

            npr = 0;
            if(x==labelpt.x && y==labelpt.y){
                Bprint(&b, "*");
                npr++;
            }
            if(npr == 0)
                Bprint(&b, " ");

            while(nb < bpp){
                v &= (1<<nb)-1;
                v |= (ulong)(*p++) << nb;
                nb += 8;
            }
            nb -= bpp;
//			print("bpp %d v %.8lux mask %.8lux nb %d\n", bpp, v, mask, nb);
            fmt(&b, arg, (v>>nb)&mask);
        }
        Bprint(&b, "\n");
    }
    Bterm(&b);
}
@
% >> >>

<<function [[checkone]]>>=
/*
 * Verify that the destination pixel has the specified value.
 * The value is in the high bits of v, suitably masked, but must
 * be extracted from the destination Memimage.
 */
void
checkone(Point p, Point sp, Point mp)
{
    int delta;
    uchar *dp, *sdp;

    delta = (uchar*)byteaddr(dst, p)-(uchar*)dst->data->bdata;
    dp = (uchar*)dst->data->bdata+delta;
    sdp = (uchar*)savedstbits+delta;

    if(memcmp(dp, sdp, (dst->depth+7)/8) != 0) {
        fprint(2, "dtest: one bad pixel drawing at dst %P from source %P mask %P\n", p, sp, mp);
        fprint(2, " %.2ux %.2ux %.2ux %.2ux should be %.2ux %.2ux %.2ux %.2ux\n",
            dp[0], dp[1], dp[2], dp[3], sdp[0], sdp[1], sdp[2], sdp[3]);
        fprint(2, "addresses dst %p src %p mask %p\n", dp, byteaddr(src, sp), byteaddr(mask, mp));
        dumpimage("src", src, src->data->bdata, sp);
        dumpimage("mask", mask, mask->data->bdata, mp);
        dumpimage("origdst", dst, dstbits, p);
        dumpimage("dst", dst, dst->data->bdata, p);
        dumpimage("gooddst", dst, savedstbits, p);
        abort();
    }
}
@

<<function [[RECTPTS]]>>=
/*
 * Verify that the destination line has the same value as the saved line.
 */
#define RECTPTS(r) (r).min.x, (r).min.y, (r).max.x, (r).max.y
@

<<function [[checkline]]>>=
void
checkline(Rectangle r, Point sp, Point mp, int y, Memimage *stmp, Memimage *mtmp)
{
    ulong *dp;
    int nb;
    ulong *saved;

    dp = wordaddr(dst, Pt(0, y));
    saved = savedstbits + y*dst->width;
    if(dst->depth < 8)
        nb = Xrange/(8/dst->depth);
    else
        nb = Xrange*(dst->depth/8);
    if(memcmp(dp, saved, nb) != 0){
        fprint(2, "dtest: bad line at y=%d; saved %p dp %p\n", y, saved, dp);
        fprint(2, "draw dst %R src %P mask %P\n", r, sp, mp);
        dumpimage("src", src, src->data->bdata, sp);
        if(stmp) dumpimage("stmp", stmp, stmp->data->bdata, sp);
        dumpimage("mask", mask, mask->data->bdata, mp);
        if(mtmp) dumpimage("mtmp", mtmp, mtmp->data->bdata, mp);
        dumpimage("origdst", dst, dstbits, r.min);
        dumpimage("dst", dst, dst->data->bdata, r.min);
        dumpimage("gooddst", dst, savedstbits, r.min);
        abort();
    }
}
@

<<function [[fill]]>>=
/*
 * Fill the bits of an image with random data.
 * The Memimage parameter is used only to make sure
 * the data is well formatted: only ucbits is written.
 */
void
fill(Memimage *img, uchar *ucbits)
{
    int i, x, y;
    ushort *up;
    uchar alpha, r, g, b;
    void *data;

    if((img->flags&Falpha) == 0){
        up = (ushort*)ucbits;
        for(i=0; i<nbytes/2; i++)
            *up++ = lrand() >> 7;
        if(i+i != nbytes)
            *(uchar*)up = lrand() >> 7;
    }else{
        data = img->data->bdata;
        img->data->bdata = ucbits;

        for(x=img->r.min.x; x<img->r.max.x; x++)
        for(y=img->r.min.y; y<img->r.max.y; y++){
            alpha = rand() >> 4;
            r = rand()%(alpha+1);
            g = rand()%(alpha+1);
            b = rand()%(alpha+1);
            putpixel(img, Pt(x,y), rgbatopix(r,g,b,alpha));
        }
        img->data->bdata = data;
    }
        
}
@

<<function [[verifyonemask]]>>=
/*
 * Mask is preset; do the rest
 */
void
verifyonemask(void)
{
    Point dp, sp, mp;

    fill(dst, dstbits);
    fill(src, srcbits);
    memmove(dst->data->bdata, dstbits, dst->width*sizeof(ulong)*Yrange);
    memmove(src->data->bdata, srcbits, src->width*sizeof(ulong)*Yrange);
    memmove(mask->data->bdata, maskbits, mask->width*sizeof(ulong)*Yrange);

    dp.x = nrand(Xrange);
    dp.y = nrand(Yrange);

    sp.x = nrand(Xrange);
    sp.y = nrand(Yrange);

    mp.x = nrand(Xrange);
    mp.y = nrand(Yrange);

    drawonepixel(dst, dp, src, sp, mask, mp);
    memmove(mask->data->bdata, maskbits, mask->width*sizeof(ulong)*Yrange);
    memmove(savedstbits, dst->data->bdata, dst->width*sizeof(ulong)*Yrange);
    
    memmove(dst->data->bdata, dstbits, dst->width*sizeof(ulong)*Yrange);
    memimagedraw(dst, Rect(dp.x, dp.y, dp.x+1, dp.y+1), src, sp, mask, mp, SoverD);
    memmove(mask->data->bdata, maskbits, mask->width*sizeof(ulong)*Yrange);

    checkone(dp, sp, mp);
}
@

<<function [[verifyone]]>>=
void
verifyone(void)
{
    int i;

    /* mask all zeros */
    memset(maskbits, 0, nbytes);
    for(i=0; i<niters; i++)
        verifyonemask();

    /* mask all ones */
    memset(maskbits, 0xFF, nbytes);
    for(i=0; i<niters; i++)
        verifyonemask();

    /* random mask */
    for(i=0; i<niters; i++){
        fill(mask, maskbits);
        verifyonemask();
    }
}
@

<<function [[verifylinemask]]>>=
/*
 * Mask is preset; do the rest
 */
void
verifylinemask(void)
{
    Point sp, mp, tp, up;
    Rectangle dr;
    int x;

    fill(dst, dstbits);
    fill(src, srcbits);
    memmove(dst->data->bdata, dstbits, dst->width*sizeof(ulong)*Yrange);
    memmove(src->data->bdata, srcbits, src->width*sizeof(ulong)*Yrange);
    memmove(mask->data->bdata, maskbits, mask->width*sizeof(ulong)*Yrange);

    dr.min.x = nrand(Xrange-1);
    dr.min.y = nrand(Yrange-1);
    dr.max.x = dr.min.x + 1 + nrand(Xrange-1-dr.min.x);
    dr.max.y = dr.min.y + 1;

    sp.x = nrand(Xrange);
    sp.y = nrand(Yrange);

    mp.x = nrand(Xrange);
    mp.y = nrand(Yrange);

    tp = sp;
    up = mp;
    for(x=dr.min.x; x<dr.max.x && tp.x<Xrange && up.x<Xrange; x++,tp.x++,up.x++)
        memimagedraw(dst, Rect(x, dr.min.y, x+1, dr.min.y+1), src, tp, mask, up, SoverD);
    memmove(savedstbits, dst->data->bdata, dst->width*sizeof(ulong)*Yrange);

    memmove(dst->data->bdata, dstbits, dst->width*sizeof(ulong)*Yrange);

    memimagedraw(dst, dr, src, sp, mask, mp, SoverD);
    checkline(dr, drawrepl(src->r, sp), drawrepl(mask->r, mp), dr.min.y, nil, nil);
}
@

<<function [[verifyline]]>>=
void
verifyline(void)
{
    int i;

    /* mask all ones */
    memset(maskbits, 0xFF, nbytes);
    for(i=0; i<niters; i++)
        verifylinemask();

    /* mask all zeros */
    memset(maskbits, 0, nbytes);
    for(i=0; i<niters; i++)
        verifylinemask();

    /* random mask */
    for(i=0; i<niters; i++){
        fill(mask, maskbits);
        verifylinemask();
    }
}
@

<<function [[verifyrectmask]]>>=
/*
 * Mask is preset; do the rest
 */
void
verifyrectmask(void)
{
    Point sp, mp, tp, up;
    Rectangle dr;
    int x, y;

    fill(dst, dstbits);
    fill(src, srcbits);
    memmove(dst->data->bdata, dstbits, dst->width*sizeof(ulong)*Yrange);
    memmove(src->data->bdata, srcbits, src->width*sizeof(ulong)*Yrange);
    memmove(mask->data->bdata, maskbits, mask->width*sizeof(ulong)*Yrange);

    dr.min.x = nrand(Xrange-1);
    dr.min.y = nrand(Yrange-1);
    dr.max.x = dr.min.x + 1 + nrand(Xrange-1-dr.min.x);
    dr.max.y = dr.min.y + 1 + nrand(Yrange-1-dr.min.y);

    sp.x = nrand(Xrange);
    sp.y = nrand(Yrange);

    mp.x = nrand(Xrange);
    mp.y = nrand(Yrange);

    tp = sp;
    up = mp;
    for(y=dr.min.y; y<dr.max.y && tp.y<Yrange && up.y<Yrange; y++,tp.y++,up.y++){
        for(x=dr.min.x; x<dr.max.x && tp.x<Xrange && up.x<Xrange; x++,tp.x++,up.x++)
            memimagedraw(dst, Rect(x, y, x+1, y+1), src, tp, mask, up, SoverD);
        tp.x = sp.x;
        up.x = mp.x;
    }
    memmove(savedstbits, dst->data->bdata, dst->width*sizeof(ulong)*Yrange);

    memmove(dst->data->bdata, dstbits, dst->width*sizeof(ulong)*Yrange);

    memimagedraw(dst, dr, src, sp, mask, mp, SoverD);
    for(y=0; y<Yrange; y++)
        checkline(dr, drawrepl(src->r, sp), drawrepl(mask->r, mp), y, nil, nil);
}
@

<<function [[verifyrect]]>>=
void
verifyrect(void)
{
    int i;

    /* mask all zeros */
    memset(maskbits, 0, nbytes);
    for(i=0; i<niters; i++)
        verifyrectmask();

    /* mask all ones */
    memset(maskbits, 0xFF, nbytes);
    for(i=0; i<niters; i++)
        verifyrectmask();

    /* random mask */
    for(i=0; i<niters; i++){
        fill(mask, maskbits);
        verifyrectmask();
    }
}
@

<<function [[randrect]]>>=
Rectangle
randrect(void)
{
    Rectangle r;

    r.min.x = nrand(Xrange-1);
    r.min.y = nrand(Yrange-1);
    r.max.x = r.min.x + 1 + nrand(Xrange-1-r.min.x);
    r.max.y = r.min.y + 1 + nrand(Yrange-1-r.min.y);
    return r;
}
@

<<function [[tilexy]]>>=
/*
 * Return coordinate corresponding to x withing range [minx, maxx)
 */
int
tilexy(int minx, int maxx, int x)
{
    int sx;

    sx = (x-minx) % (maxx-minx);
    if(sx < 0)
        sx += maxx-minx;
    return sx+minx;
}
@

<<function [[replicate]]>>=
void
replicate(Memimage *i, Memimage *tmp)
{
    Rectangle r, r1;
    int x, y, nb;

    /* choose the replication window (i->r) */
    r.min.x = nrand(Xrange-1);
    r.min.y = nrand(Yrange-1);
    /* make it trivial more often than pure chance allows */
    switch(lrand()&0){
    case 1:
        r.max.x = r.min.x + 2;
        r.max.y = r.min.y + 2;
        if(r.max.x < Xrange && r.max.y < Yrange)
            break;
        /* fall through */
    case 0:
        r.max.x = r.min.x + 1;
        r.max.y = r.min.y + 1;
        break;
    default:
        if(r.min.x+3 >= Xrange)
            r.max.x = Xrange;
        else
            r.max.x = r.min.x+3 + nrand(Xrange-(r.min.x+3));

        if(r.min.y+3 >= Yrange)
            r.max.y = Yrange;
        else
            r.max.y = r.min.y+3 + nrand(Yrange-(r.min.y+3));
    }
    assert(r.min.x >= 0);	
    assert(r.max.x <= Xrange);
    assert(r.min.y >= 0);
    assert(r.max.y <= Yrange);
    /* copy from i to tmp so we have just the replicated bits */
    nb = tmp->width*sizeof(ulong)*Yrange;
    memset(tmp->data->bdata, 0, nb);
    memimagedraw(tmp, r, i, r.min, ones, r.min, SoverD);
    memmove(i->data->bdata, tmp->data->bdata, nb);
    /* i is now a non-replicated instance of the replication */
    /* replicate it by hand through tmp */
    memset(tmp->data->bdata, 0, nb);
    x = -(tilexy(r.min.x, r.max.x, 0)-r.min.x);
    for(; x<Xrange; x+=Dx(r)){
        y = -(tilexy(r.min.y, r.max.y, 0)-r.min.y);
        for(; y<Yrange; y+=Dy(r)){
            /* set r1 to instance of tile by translation */
            r1.min.x = x;
            r1.min.y = y;
            r1.max.x = r1.min.x+Dx(r);
            r1.max.y = r1.min.y+Dy(r);
            memimagedraw(tmp, r1, i, r.min, ones, r.min, SoverD);
        }
    }
    i->flags |= Frepl;
    i->r = r;
    i->clipr = randrect();
//	fprint(2, "replicate [[%d %d] [%d %d]] [[%d %d][%d %d]]\n", r.min.x, r.min.y, r.max.x, r.max.y,
//		i->clipr.min.x, i->clipr.min.y, i->clipr.max.x, i->clipr.max.y);
    tmp->clipr = i->clipr;
}
@

<<function [[verifyrectmaskrepl]]>>=
/*
 * Mask is preset; do the rest
 */
void
verifyrectmaskrepl(int srcrepl, int maskrepl)
{
    Point sp, mp, tp, up;
    Rectangle dr;
    int x, y;
    Memimage *s, *m;

//	print("verfrect %d %d\n", srcrepl, maskrepl);
    src->flags &= ~Frepl;
    src->r = Rect(0, 0, Xrange, Yrange);
    src->clipr = src->r;
    stmp->flags &= ~Frepl;
    stmp->r = Rect(0, 0, Xrange, Yrange);
    stmp->clipr = src->r;
    mask->flags &= ~Frepl;
    mask->r = Rect(0, 0, Xrange, Yrange);
    mask->clipr = mask->r;
    mtmp->flags &= ~Frepl;
    mtmp->r = Rect(0, 0, Xrange, Yrange);
    mtmp->clipr = mask->r;

    fill(dst, dstbits);
    fill(src, srcbits);

    memmove(dst->data->bdata, dstbits, dst->width*sizeof(ulong)*Yrange);
    memmove(src->data->bdata, srcbits, src->width*sizeof(ulong)*Yrange);
    memmove(mask->data->bdata, maskbits, mask->width*sizeof(ulong)*Yrange);

    if(srcrepl){
        replicate(src, stmp);
        s = stmp;
    }else
        s = src;
    if(maskrepl){
        replicate(mask, mtmp);
        m = mtmp;
    }else
        m = mask;

    dr = randrect();

    sp.x = nrand(Xrange);
    sp.y = nrand(Yrange);

    mp.x = nrand(Xrange);
    mp.y = nrand(Yrange);

    //DBG	print("smalldraws\n");
    for(tp.y=sp.y,up.y=mp.y,y=dr.min.y; y<dr.max.y && tp.y<Yrange && up.y<Yrange; y++,tp.y++,up.y++)
        for(tp.x=sp.x,up.x=mp.x,x=dr.min.x; x<dr.max.x && tp.x<Xrange && up.x<Xrange; x++,tp.x++,up.x++)
            memimagedraw(dst, Rect(x, y, x+1, y+1), s, tp, m, up, SoverD);
    memmove(savedstbits, dst->data->bdata, dst->width*sizeof(ulong)*Yrange);

    memmove(dst->data->bdata, dstbits, dst->width*sizeof(ulong)*Yrange);

    //DBG	print("bigdraw\n");
    memimagedraw(dst, dr, src, sp, mask, mp, SoverD);
    for(y=0; y<Yrange; y++)
        checkline(dr, drawrepl(src->r, sp), drawrepl(mask->r, mp), y, srcrepl?stmp:nil, maskrepl?mtmp:nil);
}
@

<<function [[verifyrectrepl]]>>=
void
verifyrectrepl(int srcrepl, int maskrepl)
{
    int i;

    /* mask all ones */
    memset(maskbits, 0xFF, nbytes);
    for(i=0; i<niters; i++)
        verifyrectmaskrepl(srcrepl, maskrepl);

    /* mask all zeros */
    memset(maskbits, 0, nbytes);
    for(i=0; i<niters; i++)
        verifyrectmaskrepl(srcrepl, maskrepl);

    /* random mask */
    for(i=0; i<niters; i++){
        fill(mask, maskbits);
        verifyrectmaskrepl(srcrepl, maskrepl);
    }
}
@

<<function [[replbits]]>>=
/*
 * Convert v, which is nhave bits wide, into its nwant bits wide equivalent.
 * Replicates to widen the value, truncates to narrow it.
 */
ulong
replbits(ulong v, int nhave, int nwant)
{
    v &= (1<<nhave)-1;
    for(; nhave<nwant; nhave*=2)
        v |= v<<nhave;
    v >>= (nhave-nwant);
    return v & ((1<<nwant)-1);
}
@

<<function [[pixtorgba]]>>=
/*
 * Decode a pixel into the uchar* values.
 */
void
pixtorgba(ulong v, uchar *r, uchar *g, uchar *b, uchar *a)
{
    *a = v>>24;
    *r = v>>16;
    *g = v>>8;
    *b = v;
}
@

<<function [[rgbatopix]]>>=
/*
 * Convert uchar channels into ulong pixel.
 */
ulong
rgbatopix(uchar r, uchar g, uchar b, uchar a)
{
    return (a<<24)|(r<<16)|(g<<8)|b;
}
@

<<function [[getpixel]]>>=
/*
 * Retrieve the pixel value at pt in the image.
 */
ulong
getpixel(Memimage *img, Point pt)
{
    uchar r, g, b, a, *p;
    int nbits, npack, bpp;
    ulong v, c, rbits, bits;

    r = g = b = 0;
    a = ~0;	/* default alpha is full */

    p = byteaddr(img, pt);
    v = p[0]|(p[1]<<8)|(p[2]<<16)|(p[3]<<24);
    bpp = img->depth;
    if(bpp<8){
        /*
         * Sub-byte greyscale pixels.
         *
         * We want to throw away the top pt.x%npack pixels and then use the next bpp bits
         * in the bottom byte of v.  This madness is due to having big endian bits
         * but little endian bytes.
         */
        npack = 8/bpp;
        v >>= 8 - bpp*(pt.x%npack+1);
        v &= (1<<bpp)-1;
        r = g = b = replbits(v, bpp, 8);
    }else{
        /*
         * General case.  We need to parse the channel descriptor and do what it says.
         * In all channels but the color map, we replicate to 8 bits because that's the
         * precision that all calculations are done at.
         *
         * In the case of the color map, we leave the bits alone, in case a color map
         * with less than 8 bits of index is used.  This is currently disallowed, so it's
         * sort of silly.
         */

        for(c=img->chan; c; c>>=8){
            nbits = NBITS(c);
            bits = v & ((1<<nbits)-1);
            rbits = replbits(bits, nbits, 8);
            v >>= nbits;
            switch(TYPE(c)){
            case CRed:
                r = rbits;
                break;
            case CGreen:
                g = rbits;
                break;
            case CBlue:
                b = rbits;
                break;
            case CGrey:
                r = g = b = rbits;
                break;
            case CAlpha:
                a = rbits;
                break;
            case CMap:
                p = img->cmap->cmap2rgb + 3*bits;
                r = p[0];
                g = p[1];
                b = p[2];
                break;
            case CIgnore:
                break;
            default:
                fprint(2, "unknown channel type %lud\n", TYPE(c));
                abort();
            }
        }
    }
    return rgbatopix(r, g, b, a);
}
@
% >> >> >> >> >>

<<function [[getgrey]]>>=
/*
 * Return the greyscale equivalent of a pixel.
 */
uchar
getgrey(Memimage *img, Point pt)
{
    uchar r, g, b, a;
    pixtorgba(getpixel(img, pt), &r, &g, &b, &a);
    return RGB2K(r, g, b);
}
@

<<function [[getmask]]>>=
/*
 * Return the value at pt in image, if image is interpreted
 * as a mask.  This means the alpha channel if present, else
 * the greyscale or its computed equivalent.
 */
uchar
getmask(Memimage *img, Point pt)
{
    if(img->flags&Falpha)
        return getpixel(img, pt)>>24;
    else
        return getgrey(img, pt);
}
@

<<function [[putpixel]]>>=
/*
 * Write a pixel to img at point pt.
 * 
 * We do this by reading a 32-bit little endian
 * value from p and then writing it back
 * after tweaking the appropriate bits.  Because
 * the data is little endian, we don't have to worry
 * about what the actual depth is, as long as it is
 * less than 32 bits.
 */
void
putpixel(Memimage *img, Point pt, ulong nv)
{
    uchar r, g, b, a, *p, *q;
    ulong c, mask, bits, v;
    int bpp, sh, npack, nbits;

    pixtorgba(nv, &r, &g, &b, &a);

    p = byteaddr(img, pt);
    v = p[0]|(p[1]<<8)|(p[2]<<16)|(p[3]<<24);
    bpp = img->depth;
    //DBG print("v %.8lux...", v);
    if(bpp < 8){
        /*
         * Sub-byte greyscale pixels.  We need to skip the leftmost pt.x%npack pixels,
         * which is equivalent to skipping the rightmost npack - pt.x%npack - 1 pixels.
         */	
        npack = 8/bpp;
        sh = bpp*(npack - pt.x%npack - 1);
        bits = RGB2K(r,g,b);
        //DBG print("repl %lux 8 %d = %lux...", bits, bpp, replbits(bits, 8, bpp));
        bits = replbits(bits, 8, bpp);
        mask = (1<<bpp)-1;
        //DBG print("bits %lux mask %lux sh %d...", bits, mask, sh);
        mask <<= sh;
        bits <<= sh;
        //DBG print("(%lux & %lux) | (%lux & %lux)", v, ~mask, bits, mask);
        v = (v & ~mask) | (bits & mask);
    } else {
        /*
         * General case.  We need to parse the channel descriptor again.
         */
        sh = 0;
        for(c=img->chan; c; c>>=8){
            nbits = NBITS(c);
            switch(TYPE(c)){
            case CRed:
                bits = r;
                break;
            case CGreen:
                bits = g;
                break;
            case CBlue:
                bits = b;
                break;
            case CGrey:
                bits = RGB2K(r, g, b);
                break;
            case CAlpha:
                bits = a;
                break;
            case CIgnore:
                bits = 0;
                break;
            case CMap:
                q = img->cmap->rgb2cmap;
                bits = q[(r>>4)*16*16+(g>>4)*16+(b>>4)];
                break;
            default:
                SET(bits);
                fprint(2, "unknown channel type %lud\n", TYPE(c));
                abort();
            }

            //DBG print("repl %lux 8 %d = %lux...", bits, nbits, replbits(bits, 8, nbits));
            if(TYPE(c) != CMap)
                bits = replbits(bits, 8, nbits);
            mask = (1<<nbits)-1;
            //DBG print("bits %lux mask %lux sh %d...", bits, mask, sh);
            bits <<= sh;
            mask <<= sh;
            v = (v & ~mask) | (bits & mask);
            sh += nbits;
        }
    }
    //DBG print("v %.8lux\n", v);
    p[0] = v;
    p[1] = v>>8;
    p[2] = v>>16;
    p[3] = v>>24;	
}
@

<<function [[drawonepixel]]>>=
void
drawonepixel(Memimage *dst, Point dp, Memimage *src, Point sp, Memimage *mask, Point mp)
{
    uchar m, M, sr, sg, sb, sa, sk, dr, dg, db, da, dk;

    pixtorgba(getpixel(dst, dp), &dr, &dg, &db, &da);
    pixtorgba(getpixel(src, sp), &sr, &sg, &sb, &sa);
    m = getmask(mask, mp);
    M = 255-(sa*m)/255;

    //DBG print("dst %x %x %x %x src %x %x %x %x m %x = ", dr,dg,db,da, sr,sg,sb,sa, m);
    if(dst->flags&Fgrey){
        /*
         * We need to do the conversion to grey before the alpha calculation
         * because the draw operator does this, and we need to be operating
         * at the same precision so we get exactly the same answers.
         */
        sk = RGB2K(sr, sg, sb);
        dk = RGB2K(dr, dg, db);
        dk = (sk*m + dk*M)/255;
        dr = dg = db = dk;
        da = (sa*m + da*M)/255;
    }else{
        /*
         * True color alpha calculation treats all channels (including alpha)
         * the same.  It might have been nice to use an array, but oh well.
         */
        dr = (sr*m + dr*M)/255;
        dg = (sg*m + dg*M)/255;
        db = (sb*m + db*M)/255;
        da = (sa*m + da*M)/255;
    }

    //DBG print("%x %x %x %x\n", dr,dg,db,da);
    putpixel(dst, dp, rgbatopix(dr, dg, db, da));
}
@


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/tests/memdrawtest.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <draw.h>
#include <memdraw.h>

<<function [[RGB2K]]([[(lib_graphics/libmemdraw/tests/memdrawtest.c)]])>>

/*
 * This program tests the 'memimagedraw' primitive stochastically.
 * It tests the combination aspects of it thoroughly, but since the
 * three images it uses are disjoint, it makes no check of the
 * correct behavior when images overlap.  That is, however, much
 * easier to get right and to test.
 */

void	drawonepixel(Memimage*, Point, Memimage*, Point, Memimage*, Point);
void	verifyone(void);
void	verifyline(void);
void	verifyrect(void);
void	verifyrectrepl(int, int);
void putpixel(Memimage *img, Point pt, ulong nv);
ulong rgbatopix(uchar, uchar, uchar, uchar);

static char *dchan, *schan, *mchan;

<<global [[drawdebug]]([[(lib_graphics/libmemdraw/tests/memdrawtest.c)]])>>
<<global [[seed]]>>
<<global [[niters]]>>
<<global [[dbpp]]>>
<<global [[sbpp]]>>
<<global [[mbpp]]>>
<<global [[dpm]]>>
<<global [[nbytes]]>>

<<global [[Xrange]]>>
<<global [[Yrange]]>>

<<global [[dst]]>>
<<global [[src]]>>
<<global [[mask]]>>
<<global [[stmp]]>>
<<global [[mtmp]]>>
<<global [[ones]]([[(lib_graphics/libmemdraw/tests/memdrawtest.c)]])>>
<<global [[dstbits]]>>
<<global [[srcbits]]>>
<<global [[maskbits]]>>
<<global [[savedstbits]]>>

<<function [[main]]([[(lib_graphics/libmemdraw/tests/memdrawtest.c)]])>>

<<function [[Bprintr5g6b5]]>>

<<function [[Bprintr5g5b5a1]]>>

<<function [[dumpimage]]>>

<<function [[checkone]]>>

<<function [[RECTPTS]]>>
<<function [[checkline]]>>

<<function [[fill]]>>

<<function [[verifyonemask]]>>

<<function [[verifyone]]>>

<<function [[verifylinemask]]>>

<<function [[verifyline]]>>

<<function [[verifyrectmask]]>>

<<function [[verifyrect]]>>

<<function [[randrect]]>>

<<function [[tilexy]]>>

<<function [[replicate]]>>

<<function [[verifyrectmaskrepl]]>>

<<function [[verifyrectrepl]]>>

/*
 * Trivial draw implementation.
 * Color values are passed around as ulongs containing RRGGBB
 */

<<function [[replbits]]>>

<<function [[pixtorgba]]>>

<<function [[rgbatopix]]>>

<<function [[getpixel]]>>

<<function [[getgrey]]>>

<<function [[getmask]]>>

<<function [[putpixel]]>>

<<function [[drawonepixel]]>>
@


%//void
%//rdb(void)
%//{
%//}
%//
%//int
%//iprint(char *fmt, ...)
%//{
%//	int n;	
%//	va_list va;
%//	char buf[1024];
%//
%//	va_start(va, fmt);
%//	n = vseprint(buf, buf+sizeof buf, fmt, va) - buf;
%//	va_end(va);
%//
%//	write(1,buf,n);
%//	return 1;
%//}

\section{[[lib_graphics/libmemlayer/]]}

\subsection{[[lib_graphics/libmemlayer/draw.c]]}


%-------------------------------------------------------------

<<lib_graphics/libmemlayer/draw.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<macro [[DBG1]]>>
<<macro [[DBG]]>>

<<struct [[Draw]]>>

<<function [[ldrawop]]>>

<<function [[memdraw]]>>
@


\subsection{[[lib_graphics/libmemlayer/lalloc.c]]}


%-------------------------------------------------------------

<<lib_graphics/libmemlayer/lalloc.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<function [[memlalloc]]>>
@


\subsection{[[lib_graphics/libmemlayer/layerop.c]]}

%-------------------------------------------------------------

<<lib_graphics/libmemlayer/layerop.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<function [[RECUR]]>>

<<function [[_layerop]]>>

<<function [[_memlayerop]]>>
@


\subsection{[[lib_graphics/libmemlayer/ldelete.c]]}
% merge with lalloc

%-------------------------------------------------------------

<<lib_graphics/libmemlayer/ldelete.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<function [[memldelete]]>>

<<function [[memlfree]]>>

<<function [[_memlsetclear]]>>
@


\subsection{[[lib_graphics/libmemlayer/lhide.c]]}
% rename lvisibility.c

%-------------------------------------------------------------

<<lib_graphics/libmemlayer/lhide.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<function [[lhideop]]>>

<<function [[memlhide]]>>

<<function [[lexposeop]]>>

<<function [[memlexpose]]>>
@


\subsection{[[lib_graphics/libmemlayer/line.c]]}


%-------------------------------------------------------------

<<lib_graphics/libmemlayer/line.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<struct [[Lline]]>>

static void llineop(Memimage*, Rectangle, Rectangle, void*, int);

<<function [[_memline]]>>

<<function [[llineop]]>>

<<function [[memline]]>>
@


\subsection{[[lib_graphics/libmemlayer/load.c]]}
% rename transfer.c

%-------------------------------------------------------------

<<lib_graphics/libmemlayer/load.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<function [[memload]]>>
@


\subsection{[[lib_graphics/libmemlayer/lorigin.c]]}


%-------------------------------------------------------------

<<lib_graphics/libmemlayer/lorigin.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<function [[memlorigin]]>>

<<function [[memlnorefresh]]>>
@


\subsection{[[lib_graphics/libmemlayer/lsetrefresh.c]]}


%-------------------------------------------------------------

<<lib_graphics/libmemlayer/lsetrefresh.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<function [[memlsetrefresh]]>>
@


\subsection{[[lib_graphics/libmemlayer/ltofront.c]]}
% rename lstack.c or lmove.c

%-------------------------------------------------------------

<<lib_graphics/libmemlayer/ltofront.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<function [[_memltofront]]>>

<<function [[_memltofrontfill]]>>

<<function [[memltofront]]>>

<<function [[memltofrontn]]>>
@


\subsection{[[lib_graphics/libmemlayer/ltorear.c]]}

%-------------------------------------------------------------

<<lib_graphics/libmemlayer/ltorear.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<function [[_memltorear]]>>

<<function [[memltorear]]>>

<<function [[memltorearn]]>>
@


\subsection{[[lib_graphics/libmemlayer/unload.c]]}
% merge with load.c

%-------------------------------------------------------------

<<lib_graphics/libmemlayer/unload.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<function [[memunload]]>>
@


\section{[[windows/apps/]]}


\subsection{[[windows/apps/clock.c]]}

<<function [[circlept]]>>=
static Point
circlept(Point c, int r, int degrees)
{

    double rad;
    rad = (double) degrees * PI/180.0;
    c.x += cos(rad)*r;
    c.y -= sin(rad)*r;
    return c;
}
@

<<function [[redraw]]>>=
static void
redraw(Image *view)
{
    static int tm, ntm;
    static Rectangle r;
    static Point c;
    static int rad;
    static Image *im;
    int i;
    int anghr, angmin;
    static Tm tms;
    static Tm ntms;

    ntm = time(0);
    if(ntm == tm && eqrect(view->r, r))
        return;

    ntms = *localtime(ntm);
    anghr = 90-(ntms.hour*5 + ntms.min/12)*6;
    angmin = 90-ntms.min*6;
    tm = ntm;
    tms = ntms;
    r = view->r;
    c = divpt(addpt(r.min, r.max), 2);
    rad = Dx(r) < Dy(r) ? Dx(r) : Dy(r);
    rad /= 2;
    rad -= 8;

    draw(view, view->r, back, nil, ZP);
    for(i=0; i<12; i++)
        fillellipse(view, circlept(c, rad, i*(360/12)), 2, 2, dots, ZP);

    line(view, c, circlept(c, (rad*3)/4, angmin), 0, 0, 1, minhand, ZP);
    line(view, c, circlept(c, rad/2, anghr), 0, 0, 1, hrhand, ZP);

    flushimage(display, true);
}
@

<<function [[eresized]]>>=
void
eresized(bool new)
{
    if(new && getwindow(display, Refnone) < 0)
        fprint(2,"can't reattach to window");
    redraw(view);
}
@

<<function main (windows/apps/clock.c)>>=
void
main(int, char**)
{
    Event e;
    Mouse m;
    Menu menu;
    char *mstr[] = {"exit", 0};
    int key, timer;
    int t;

    if (initdraw(nil, nil, "clock") < 0)
        sysfatal("initdraw failed");
    back = allocimagemix(display, DPalebluegreen, DWhite);

    hrhand  = allocimage(display, Rect(0,0,1,1), CMAP8, 1, DDarkblue);
    minhand = allocimage(display, Rect(0,0,1,1), CMAP8, 1, DPaleblue);
    dots    = allocimage(display, Rect(0,0,1,1), CMAP8, 1, DBlue);

    redraw(view);

    einit(Emouse);
    t = (30*1000);
    timer = etimer(0, t);

    menu.item = mstr;
    menu.lasthit = 0;
    // the event loop
    for(;;) {
        key = event(&e);
        if(key == Emouse) {
            m = e.mouse;
            if(m.buttons & 4) {
                if(emenuhit(3, &m, &menu) == 0)
                    exits(nil);
            }
        } else if(key == timer) {
            redraw(view);
        }
    }   
}
@


%-------------------------------------------------------------

<<windows/apps/clock.c>>=
#include <u.h>
#include <libc.h>

#include <draw.h>
#include <window.h>
#include <event.h>

static Image *hrhand, *minhand;
static Image *dots, *back;

<<function [[circlept]]>>

<<function [[redraw]]>>

<<function [[eresized]]>>

<<function main (windows/apps/clock.c)>>
@


\subsection{[[windows/apps/colors.c]]}

<<global [[pixel]]>>=
static Image *pixel;
@

<<global [[crect]]>>=
static Rectangle crect[256];
@

<<global [[color]]>>=
static Image *color[256];
@

<<function eresized (windows/apps/colors.c)>>=
void
eresized(bool new)
{
    int x, y, i, n, nx, ny;
    Rectangle r, b;

    if(new && getwindow(display, Refnone) < 0){
        fprint(2, "colors: can't reattach to window: %r\n");
        exits("resized");
    }
    if(view->depth > 8){
        n = 256;
        nx = 16;
    }else{
        n = 1<<view->depth;
        nx = 1<<(view->depth/2);
    }

    ny = n/nx;
    draw(view, view->r, display->white, nil, ZP);
    r = insetrect(view->r, 5);
    r.min.y+=20;
    b.max.y=r.min.y;
    for(i=n-1, y=0; y!=ny; y++){
        b.min.y=b.max.y;
        b.max.y=r.min.y+(r.max.y-r.min.y)*(y+1)/ny;
        b.max.x=r.min.x;
        for(x=0; x!=nx; x++, --i){
            b.min.x=b.max.x;
            b.max.x=r.min.x+(r.max.x-r.min.x)*(x+1)/nx;
            crect[i]=insetrect(b, 1);
            draw(view, crect[i], color[i], nil, ZP);
        }
    }
    flushimage(display, true);
}
@

<<global [[buttons]]>>=
static char *buttons[] =
{
    "exit",
    0
};
@

<<global [[menu]]>>=
static Menu menu =
{
    buttons
};
@


<<function [[grey]]>>=
static ulong
grey(int i)
{
    if(i < 0)
        return grey(0);
    if(i > 255)
        return grey(255);
    return (i<<16)+(i<<8)+i;
}
@


<<global [[dither]]>>=
static int
dither[16] =  {
    0, 8, 2, 10,
    12, 4, 14, 6,
    3, 11, 1, 9,
    15, 7, 13, 5
};
@

<<function main (windows/apps/colors.c)>>=
void
main(int argc, char *argv[])
{
    Point p;
    Mouse m;
    bool ramp;
    int i, j, k, l, n, prev;
    char buf[100];
    char *fmt;
    Image *dark;
    ulong rgb;

    ramp = false;

    fmt = "index %3d r %3lud g %3lud b %3lud 0x%.8luX        ";
    ARGBEGIN{
    default:
        goto Usage;
    case 'x':
        fmt = "index %2luX r %3luX g %3luX b %3luX 0x%.8luX       ";
        break;
    case 'r':
        ramp = true;
        break;
    }ARGEND

    if(argc){
    Usage:
        fprint(STDERR, "Usage: %s [-rx]\n", argv0);
        exits("usage");
    }

    if(initdraw(nil, nil, "colors") < 0)
        sysfatal("initdraw failed: %r");
    einit(Emouse);

    for(i=0; i<256; i++){
        if(ramp){
            if(view->chan == CMAP8){
                /* dither the fine grey */
                j = i-(i%17);
                dark = allocimage(display, Rect(0,0,1,1), view->chan, 1, (grey(j)<<8)+0xFF);
                color[i] = allocimage(display, Rect(0,0,4,4), view->chan, 1, (grey(j+17)<<8)+0xFF);
                for(j=0; j<16; j++){
                    k = j%4;
                    l = j/4;
                    if(dither[j] > (i%17))
                        draw(color[i], Rect(k, l, k+1, l+1), dark, nil, ZP);
                }
                freeimage(dark);
            }else
                color[i] = allocimage(display, Rect(0,0,1,1), view->chan, 1, (grey(i)<<8)+0xFF);
        }else
            color[i] = allocimage(display, Rect(0,0,1,1), view->chan, 1, 
                                   (cmap2rgb(i)<<8)+0xFF);
        if(color[i] == nil)
            sysfatal("can't allocate image: %r");
    }

    eresized(false);

    prev = -1;
    for(;;){
        m = emouse();
        switch(m.buttons){
        case 1: // left click
            while(m.buttons){
                if(view->depth > 8)
                    n = 256;
                else
                    n = 1<<view->depth;
                for(i=0; i!=n; i++)
                    if(i!=prev && ptinrect(m.xy, crect[i])){
                        if(ramp)
                            rgb = grey(i);
                        else
                            rgb = cmap2rgb(i);
                        sprint(buf, fmt,
                            i,
                            (rgb>>16)&0xFF,
                            (rgb>>8)&0xFF,
                            rgb&0xFF,
                            (rgb<<8) | 0xFF);
                        p = addpt(view->r.min, Pt(2,2));
                        draw(view, Rpt(p, addpt(p, stringsize(font, buf))), display->white, nil, p);
                        string(view, p, display->black, ZP, font, buf);
                        prev=i;
                        break;
                    }
                m = emouse();
            }
            break;

        case 4: // right click
            switch(emenuhit(3, &m, &menu)){
            case 0:
                exits(nil);
            }
        }
    }
}
@


%-------------------------------------------------------------

<<windows/apps/colors.c>>=
#include <u.h>
#include <libc.h>

#include <draw.h>
#include <window.h>
#include <event.h>

static int nbit, npix;
<<global [[pixel]]>>
<<global [[crect]]>>
<<global [[color]]>>

<<function eresized (windows/apps/colors.c)>>

<<global [[buttons]]>>

<<function [[grey]]>>

<<global [[menu]]>>

<<global [[dither]]>>

<<function main (windows/apps/colors.c)>>
@


\subsection{[[windows/apps/screenlock.c]]}

<<global [[pic]]>>=
static char pic[] = "/lib/bunny.bit";
@

<<global [[vgactl]]>>=
static int vgactl;
@

<<global [[debug]]>>=
static int debug;
@

<<global [[doblank]]>>=
static int doblank;
@

<<global [[chatty]]>>=
static int chatty = 0;
@

<<global [[user]]>>=
static char user[256];
@

<<function [[blankscreen]]>>=
static void
blankscreen(bool blank)
{
    if(vgactl < 0)
        return;
    seek(vgactl, 0, 0);
    if(fprint(vgactl, blank? "blank": "unblank") < 0)
        fprint(2, "blankscreen: can't blank: %r\n");
}
@

<<function error (windows/apps/screenlock.c)>>=
static void
error(char *fmt, ...)
{
    Fmt f;
    char buf[64];
    va_list arg;

    fmtfdinit(&f, 1, buf, sizeof buf);
    fmtprint(&f, "screenlock: ");
    va_start(arg, fmt);
    fmtvprint(&f, fmt, arg);
    va_end(arg);
    fmtprint(&f, "\n");
    fmtfdflush(&f);
    threadexitsall("fatal error");
}
@

<<function usage (windows/apps/screenlock.c)>>=
static void
usage(void)
{
    fprint(2, "usage: %s\n", argv0);
    exits("usage");
}
@

<<function [[readfile]]>>=
static void
readfile(char *name, char *buf, int nbuf, int addnul)
{
    int fd;

    fd = open(name, OREAD);
    if(fd == -1)
        error("%s - can't open: %r", name);
    nbuf = read(fd, buf, nbuf-addnul);
    close(fd);
    if(nbuf == -1)
        error("%s - can't can't read: %r", name);
    if(addnul)
        buf[nbuf] = '\0';
}
@

<<function [[readline]]>>=
static void
readline(char *buf, int nbuf)
{
    char c;
    int i;

    i = 0;
    while(i < nbuf-1)
        if(read(0, &c, 1) != 1 || c == '\04' || c == '\177'){
            i = 0;
            break;
        } else if(c == '\n')
            break;
        else if(c == '\b' && i > 0)
            --i;
        else if(c == ('u' & 037))
            i = 0;
        else
            buf[i++] = c;
    buf[i] = '\0';
}
@

<<function [[checkpassword]]>>=
static void
checkpassword(void)
{
    int fd, consctl, must;
    char buf[256];
    AuthInfo *ai;
    static int opened;

    must = 1;
    if(!opened){
        fd = open("/dev/cons", OREAD);
        if(fd == -1)
            error("can't open cons: %r");
        dup(fd, 0);
        close(fd);
        fd = open("/dev/cons", OWRITE);
        if(fd == -1)
            error("can't open cons: %r");
        dup(fd, 1);
        dup(1, 2);
        close(fd);
        consctl = open("/dev/consctl", OWRITE);
        if(consctl == -1)
            error("can't open consctl: %r");
        if(write(consctl, "rawon", 5) != 5)
            error("can't turn off echo\n");
        opened = 1;
    }

    for(;;){
        if(chatty || !must)
            fprint(2, "%s's screenlock password: ", user);
        memset(buf, 0, sizeof buf);
        readline(buf, sizeof buf);
        blankscreen(0);
        if(chatty || !must)
            fprint(2, "\n");
        if(buf[0] == '\0' || buf[0] == '\04'){
            if(must)
                continue;
            error("no password typed");
        }

        /* authenticate */
        ai = auth_userpasswd(user, buf);
        if(ai != nil && ai->cap != nil)
            break;
        auth_freeAI(ai);

        if(chatty || !must)
            fprint(2, "password mismatch\n");
        doblank = 1;
    }
    memset(buf, 0, sizeof buf);
    blankscreen(0);
}
@

<<function [[blanker]]>>=
static void
blanker(void *)
{
    int tics;

    tics = 0;
    for(;;){
        if(doblank > 0){
            doblank = 0;
            tics = 10;
        }
        if(tics > 0 && --tics == 0)
            blankscreen(1);
        sleep(1000);
    }
}
@

<<function [[grabmouse]]>>=
static void
grabmouse(void*)
{
    int fd, x, y;
    char ibuf[256], obuf[256];

    if(debug)
        return;
    fd = open("/dev/mouse", ORDWR);
    if(fd < 0)
        error("can't open /dev/mouse: %r");

    snprint(obuf, sizeof obuf, "m %d %d",
        view->r.min.x + Dx(view->r)/2,
        view->r.min.y + Dy(view->r)/2);
    while(read(fd, ibuf, sizeof ibuf) > 0){
        ibuf[12] = 0;
        ibuf[24] = 0;
        x = atoi(ibuf+1);
        y = atoi(ibuf+13);
        if(x != view->r.min.x + Dx(view->r)/2 ||
           y != view->r.min.y + Dy(view->r)/2){
            fprint(fd, "%s", obuf);
            doblank = 1;
        }
    }
}
@

<<function [[screenstring]]>>=
/* lay down text at `p' */
static void
screenstring(Point p, char *s)
{
    string(view, p, view->display->white, ZP, font, s);
    flushimage(display, 1);
}
@

<<function [[lockscreen]]>>=
static void
lockscreen(void)
{
    enum { Nfld = 5, Fldlen = 12, Cursorlen = 2*4 + 2*2*16, };
    char *s;
    char buf[Nfld*Fldlen], *flds[Nfld], newcmd[128], cbuf[Cursorlen];
    int fd, dx, dy;
    Image *i;
    Point p;
    Rectangle r;
    Tm *tm;

    fd = open("/dev/screen", OREAD);
    if(fd < 0)
        error("can't open /dev/screen: %r");
    if(read(fd, buf, Nfld*Fldlen) != Nfld*Fldlen)
        error("can't read /dev/screen: %r");
    close(fd);
    buf[sizeof buf-1] = 0;
    if(tokenize(buf, flds, Nfld) != Nfld)
        error("can't tokenize /dev/screen header");
    snprint(newcmd, sizeof newcmd, "-r %s %s %d %d",
        flds[1], flds[2], atoi(flds[3]) - 1, atoi(flds[4]) - 1);
    newwindow(newcmd);
    if (initdraw(nil, nil, "screenlock") < 0)
        sysfatal("initdraw failed");
    if(display == nil)
        error("no display");

    /* screen is now open and covered.  grab mouse and hold on tight */
    procrfork(grabmouse, nil, 4096, RFFDG);
    procrfork(blanker, nil, 4096, RFFDG);
    fd = open(pic, OREAD);
    if(fd > 0){
        i = readimage(display, fd, 0);
        if(i){
    r = view->r;
            p = Pt(r.max.x / 2, r.max.y * 2 / 3); 
            dx = (Dx(view->r) - Dx(i->r)) / 2;
            r.min.x += dx;
            r.max.x -= dx;
            dy = (Dy(view->r) - Dy(i->r)) / 2;
            r.min.y += dy;
            r.max.y -= dy;
            draw(view, view->r, display->black, nil, ZP);
            draw(view, r, i, nil, i->r.min);
            flushimage(display, 1);
        }
        close(fd);

        /* identify the user on screen, centered */
        tm = localtime(time(0));
        s = smprint("user %s at %d:%02.2d", getuser(), tm->hour, tm->min);
        p = subpt(p, Pt(stringwidth(font, "m") * strlen(s) / 2, 0));
        screenstring(p, s);
    }

    /* clear the cursor */
    fd = open("/dev/cursor", OWRITE);
    if(fd > 0){
        memset(cbuf, 0, sizeof cbuf);
        write(fd, cbuf, sizeof cbuf);
        /* leave it open */
    }
}
@

<<function threadmain (windows/apps/screenlock.c)>>=
void
threadmain(int argc, char *argv[])
{
    readfile("#c/user", user, sizeof user, 1);

    if((vgactl = open("/dev/vgactl", OWRITE)) < 0)
        vgactl = open("#v/vgactl", OWRITE);

    ARGBEGIN{
    case 'd':
        debug++;
        break;
    default:
        usage();
    }ARGEND

    if(argc != 0)
        usage();

    doblank = 1;
    lockscreen();
    checkpassword();
    threadexitsall(nil);
}
@


%-------------------------------------------------------------

<<windows/apps/screenlock.c>>=
/* screenlock - lock a terminal */
#include <u.h>
#include <libc.h>
#include <libsec.h>
#include <draw.h>
#include <window.h>
#include <thread.h>
#include <auth.h>

<<global [[pic]]>>

<<global [[vgactl]]>>
<<global [[debug]]>>
<<global [[doblank]]>>
<<global [[chatty]]>>

<<global [[user]]>>

<<function [[blankscreen]]>>

<<function error (windows/apps/screenlock.c)>>

<<function usage (windows/apps/screenlock.c)>>


<<function [[readfile]]>>

<<function [[readline]]>>

<<function [[checkpassword]]>>

<<function [[blanker]]>>

<<function [[grabmouse]]>>

<<function [[screenstring]]>>

<<function [[lockscreen]]>>

<<function threadmain (windows/apps/screenlock.c)>>
@



\section{[[kernel/devices/screen/]]}

\subsection{[[kernel/devices/screen/portscreen.c]]}
%pad: I created this file. I originally called it
% screen.c but then each arch defines its own screen.c which
% then generates conflict in the mkfile of the arch, so simpler
% to have a portscreen.c

<<kernel/devices/screen/portscreen.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "../port/error.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"

#include    <draw.h>
#include    <memdraw.h>
#include    <memlayer.h>
#include    <cursor.h>

// Many of the stuff below used to be in vgascreen.c, but they are
// quite VGA independent so better to have a generic portscreen.c.

<<global [[gscreen]]>>
<<global [[gscreendata]]>>
<<global [[physgscreenr]]>>

// for software cursor look swcursor.c
// for software console look swconsole.c

@

\subsection{[[kernel/devices/screen/portscreen.h]]}
%pad: I originally created this file, but some stuff was redundant
% with portdat_devices.h and was spreading around too much stuff
% related to graphics/keyboard/mouse. Nevertheless, we can not
% put many declarations from portscreen.h in portdat_devices.h
% because of the use of Memimage/Rectangle/... which would
% force every kernel files to include draw.h (or play with pragma incomplete)

%-----------------------------------------------------------------

<<kernel/devices/screen/portscreen.h>>=
// The content of this file used to be in pc/screen.h, but many prototypes were
// VGA independent, so it is better to have a generic portscreen.h interface 
// and VGA-specific stuff in pc/screen.h in a separate file.

// Image

// portscreen.c, set in <arch>/screen.c (used by devmouse.c, swcursor.c)
extern Memimage* gscreen;
extern Memdata   gscreendata;
extern Rectangle physgscreenr;  /* actual monitor size */

/* <arch>/screen.c  (used by devdraw.c) */
extern byte* arch_attachscreen(Rectangle*, ulong*, int*, int*, int*);
extern void  arch_flushmemscreen(Rectangle);
extern void  arch_blankscreen(bool);
extern void	 arch_getcolor(ulong, ulong*, ulong*, ulong*);
extern int	 arch_setcolor(ulong, ulong, ulong, ulong);
extern bool  arch_ishwimage(Memimage*);

// Cursor

<<struct [[Cursorinfo]]>>
typedef struct Cursorinfo Cursorinfo;

<<global signature cursor>>

// swcursor.c (called from <arch>/screen.c from arch_cursorxxx)
extern void swcursor_init(void);
extern void swcursor_hide(void);
extern void swcursor_draw(void);
extern int  swcursor_move(Point p);
extern void swcursor_load(Cursor *curs);
extern void swcursor_avoid(Rectangle);
//extern Cursor swcursor_arrow;

/* <arch>/screen.c (needed by devmouse.c) */
extern Cursor 		arch_arrow;

/* devmouse.c (needed by ??) */ // just enough Mouse getters/setters
extern Point 	mousexy(void);

// <arch>/screen.c (called from devmouse.c)
extern void 	arch_ksetcursor(Cursor*);
extern int  	arch_cursoron(int);
extern void 	arch_cursoroff(int);

// Graphical console

// swconsole.c (used from <arch>/screen.c)
extern Memsubfont *swconsole_memdefont;
extern Memimage *swconsole_conscol;
extern Point     swconsole_curpos;
extern Rectangle swconsole_window;

extern void swconsole_init(void);
extern void swconsole_screenputs(char *s, int n);

@

\subsection{[[kernel/devices/screen/swcursor.c]]}
%pad: I created this file to factorize code between pc/ and bcm/.
% The code used to be in <arch>/screen.c with very little variations.

<<kernel/devices/screen/swcursor.c>>=
/*
 * Software cursor
 */
#include    "u.h"
#include    "../port/lib.h"
#include    "../port/error.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"

#include    <draw.h>
#include    <memdraw.h>
#include    <memlayer.h>
#include    <cursor.h>

#include    "../port/portscreen.h"

<<global [[swcursor_arrow]]>>

<<global [[swback]]>>
<<global [[swimg1]]>>
<<global [[swmask1]]>>

<<global [[swpt]]>>
<<global [[swvispt]]>>
<<global [[swvers]]>>
<<global [[swvisvers]]>>

<<global [[swenabled]]>>
<<global [[swvisible]]>>

<<global [[swimg]]>>
<<global [[swmask]]>>

<<global [[swrect]]>>

<<global [[swoffset]]>>


<<function [[swcursorclock]]>>

<<function [[swcursorinit]]>>

<<function [[swcursordraw]]>>

<<function [[swcursorhide]]>>

<<function [[swcursoravoid]]>>

<<function [[swload]]>>

<<function [[swmove]]>>
@

\subsection{[[kernel/devices/screen/swconsole.c]]}
%pad: I created this file, to factorize again code between pc/ and bcm/
% for code that was portable!


%-------------------------------------------------------------

<<kernel/devices/screen/swconsole.c>>=
/*
 * Text output using memdraw
 */
#include    "u.h"
#include    "../port/lib.h"
#include    "../port/error.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"

#include    <draw.h>
#include    <font.h>
#include    <memdraw.h>
#include    <memlayer.h>
#include    <cursor.h>

#include    "../port/portscreen.h"

// The main entry point of this module is the function 
// swconsole_screenputs() which is assigned to screenputs in devcons.c and
// called from print() to display text on the screen.
// swconsole_screenputs() uses the default text font in memdraw
// and the memdraw functions to draw characters on the screen (via gscreen).
// See pc/cga.c for another screenputs function using the CGA hardware
// to display text.

enum {
    Scroll      = 8, // want this to be configurable?
    Tabstop     = 4,
};

<<global [[swconsole_screenlock]]>>

<<global [[curpos]]>>

<<global window bis>>

<<global [[conscol]]>>

<<global [[back2]]>>

<<global [[memdefont2]]>>

<<global swconsole h w>>

<<function [[swconsole_init]]>>

<<function [[swconsole_scroll]]>>

<<function [[swconsole_screenputc]]>>

<<function [[swconsole_screenputs]]>>

@

\subsection{[[kernel/devices/screen/devdraw.h]]}
%pad: I created this file; its content was in devdraw.c before


%-------------------------------------------------------------

<<kernel/devices/screen/devdraw.h>>=

typedef struct Client Client;
typedef struct KDraw KDraw;
typedef struct DImage DImage;
typedef struct DName DName;
typedef struct DScreen DScreen;
typedef struct CScreen CScreen;
typedef struct FChar FChar;
typedef struct Refresh Refresh;
typedef struct Refx Refx;

<<constant NHASH bis>>
<<constant [[HASHMASK]]>>


<<struct [[KDraw]]>>

<<struct [[Client]]>>


<<struct [[DName]]>>


<<struct [[DImage]]>>

<<struct [[FChar]]>>



<<struct [[CScreen]]>>

<<struct [[DScreen]]>>


<<struct [[Refresh]]>>

<<struct [[Refx]]>>

// drawerror.c
extern char Enodrawimage[];
extern char Enodrawscreen[];
extern char Eshortdraw[];
extern char Eshortread[];
extern char Eimageexists[];
extern char Escreenexists[];
extern char Edrawmem[];
extern char Ereadoutside[];
extern char Ewriteoutside[];
extern char Enotfont[];
extern char Eindex[];
extern char Enoclient[];
extern char Enameused[];
extern char Enoname[];
extern char Eoldname[];
extern char Enamed[];
extern char Ewrongname[];

//drawinit.c
extern Memimage    *screenimage;
error0 initscreenimage(void);

//devdraw.c
extern KDraw        sdraw;
void dlock(void);
int candlock(void);
void dunlock(void);
DImage* drawlookup(Client *client, int id, bool checkname);
void addflush(Rectangle r);
void dstflush(int dstid, Memimage *dst, Rectangle r);
void drawflush(void);

//drawalloc.c
DImage* allocdimage(Memimage *i);
void drawfreedimage(DImage *dimage);
Memimage* drawinstall(Client *client, int id, Memimage *i, DScreen *dscreen);
void drawuninstall(Client *client, int id);

//drawname.c
extern char    screenname[];
DName* drawlookupname(int n, char *str);
bool drawgoodname(DImage *d);
void drawaddname(Client *client, DImage *di, int n, char *str);
void drawdelname(DName *name);

//drawwindow.c
DScreen*   drawlookupscreen(Client *client, int id, CScreen **cs);
Memscreen* drawinstallscreen(Client*, DScreen*, int, DImage *, DImage *, bool);
void       drawuninstallscreen(Client*, CScreen*);
DScreen* drawlookupdscreen(int id);
void drawfreedscreen(DScreen*);

//drawmisc.c
int drawrefactive(void *a);
void drawrefresh(Memimage*, Rectangle r, void *v);
void drawrefreshscreen(DImage *l, Client *client);

@

\subsection{[[kernel/devices/screen/drawinit.c]]}
%pad: I created this file; its content was in devdraw.c before

%-------------------------------------------------------------

<<kernel/devices/screen/drawinit.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "../port/error.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"

#include    <draw.h>
#include    <memdraw.h>
#include    <memlayer.h>

#include    <cursor.h>
#include    "portscreen.h"

#include    "devdraw.h"

<<global [[screenimage]]>>
<<global [[screendimage]]>>

<<global [[screenname]]>>
<<global [[screennameid]]>>


<<function [[makescreenimage]]>>

<<function [[initscreenimage]]>>

<<function [[deletescreenimage]]>>

<<function [[resetscreenimage]]>>

@

\subsection{[[kernel/devices/screen/drawname.c]]}
%pad: I created this file; its content was in devdraw.c before

%-------------------------------------------------------------

<<kernel/devices/screen/drawname.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "../port/error.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"

#include    <draw.h>
#include    <memdraw.h>
#include    <memlayer.h>

#include    "devdraw.h"

<<function [[drawcmp]]>>

<<function [[drawlookupname]]>>

<<function [[drawgoodname]]>>

<<function [[drawdelname]]>>

<<function [[drawaddname]]>>

@

\subsection{[[kernel/devices/screen/drawalloc.c]]}
%pad: I created this file; its content was in devdraw.c before

%-------------------------------------------------------------

<<kernel/devices/screen/drawalloc.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "../port/error.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"

#include    <draw.h>
#include    <memdraw.h>
#include    <memlayer.h>

#include    <cursor.h>
#include    "portscreen.h"

#include    "devdraw.h"

<<function [[allocdimage]]>>

<<function [[drawinstall]]>>

<<function [[drawfreedimage]]>>

<<function [[drawuninstall]]>>

@

\subsection{[[kernel/devices/screen/drawwindow.c]]}
%pad: I created this file; its content was in devdraw.c before

%-------------------------------------------------------------

<<kernel/devices/screen/drawwindow.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "../port/error.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"

#include    <draw.h>
#include    <memdraw.h>
#include    <memlayer.h>

#include    "devdraw.h"

<<global [[dscreen]]>>

<<function [[drawlookupdscreen]]>>

<<function [[drawlookupscreen]]>>

<<function [[drawinstallscreen]]>>

<<function [[drawfreedscreen]]>>

<<function [[drawuninstallscreen]]>>


@

\subsection{[[kernel/devices/screen/drawerror.c]]}
%pad: I created this file; its content was in devdraw.c before

%-------------------------------------------------------------

<<kernel/devices/screen/drawerror.c>>=

<<global [[Enodrawimage]]>>
<<global [[Enodrawscreen]]>>
<<global [[Eshortdraw]]>>
<<global [[Eshortread]]>>
<<global [[Eimageexists]]>>
<<global [[Escreenexists]]>>
<<global [[Edrawmem]]>>
<<global [[Ereadoutside]]>>
<<global [[Ewriteoutside]]>>
<<global [[Enotfont]]>>
<<global [[Eindex]]>>
<<global [[Enoclient]]>>
<<global [[Enameused]]>>
<<global [[Enoname]]>>
<<global [[Eoldname]]>>
<<global [[Enamed]]>>
<<global [[Ewrongname]]>>

@

\subsection{[[kernel/devices/screen/drawmesg.c]]}
%pad: I created this file; its content was in devdraw.c before

%-------------------------------------------------------------

<<kernel/devices/screen/drawmesg.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "../port/error.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"

#include    <draw.h>
#include    <marshal.h>
#include    <memdraw.h>
#include    <memlayer.h>

#include    <cursor.h>
#include    "portscreen.h"

#include    "devdraw.h"

<<function [[drawclientop]]>>

<<function [[drawimage]]>>

<<function [[drawrectangle]]>>

<<function [[drawpoint]]>>

<<function [[drawcoord]]>>



<<function [[drawchar]]>>


<<function [[printmesg]]>>

<<function [[drawmesg]]>>
@

\subsection{[[kernel/devices/screen/drawmisc.c]]}
%pad: I created this file; its content was in devdraw.c before

%-------------------------------------------------------------

<<kernel/devices/screen/drawmisc.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "../port/error.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"

#include    <draw.h>
#include    <memdraw.h>
#include    <memlayer.h>
#include    <cursor.h>

#include    "portscreen.h"
#include    "devdraw.h"

<<global [[blanktime]]>>

<<function [[drawrefactive]]>>

<<function [[drawrefreshscreen]]>>

<<function [[drawrefresh]]>>



<<function [[drawcmap]]>>

<<function [[drawblankscreen]]>>

<<function [[drawactive]]>>

<<function [[drawidletime]]>>

@

\subsection{[[kernel/devices/screen/devdraw.c]]}



%-------------------------------------------------------------

<<kernel/devices/screen/devdraw.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "../port/error.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"

#include    <draw.h>
#include    <marshal.h>
#include    <memdraw.h>
#include    <memlayer.h>
#include    <cursor.h>

#include    "portscreen.h"
#include    "devdraw.h"

<<enum [[QxxxDraw]]>>

<<constant [[QSHIFT]]>>

<<function QID bis>>
<<function [[CLIENTPATH]]>>

<<constant [[IOUNIT]]>>

<<global [[sdraw]]>>
<<global [[drawlock]]>>


<<global [[flushrect]]>>
<<global [[waste]]>>

// forward decls
void        drawmesg(Client*, void*, int);
void        drawuninstall(Client*, int);
void        drawfreedimage(DImage*);
Client*     drawclientofpath(ulong);
DImage* 	allocdimage(Memimage*);



<<function [[dlock]]>>

<<function [[candlock]]>>

<<function [[dunlock]]>>


<<function [[drawgen]]>>




<<function [[addflush]]>>

<<function [[dstflush]]>>

<<function [[drawflush]]>>




<<function [[drawlookup]]>>


<<function [[drawnewclient]]>>


<<function [[drawclientofpath]]>>

<<function [[drawclient]]>>











<<function [[drawattach]]>>

<<function [[drawwalk]]>>

<<function [[drawstat]]>>

<<function [[drawopen]]>>

<<function [[drawclose]]>>

<<function [[drawread]]>>

<<function [[drawwakeall]]>>

<<function [[drawwrite]]>>


<<global [[drawdevtab]]>>

@

%//int
%//drawhasclients(void)
%//{
%//  /*
%//   * if draw has ever been used, we can't resize the frame buffer,
%//   * even if all clients have exited (nclients is cumulative); it's too
%//   * hard to make work.
%//   */
%//  return sdraw.nclient != 0;


\section{[[kernel/devices/screen/arm/]]}

\subsection{[[kernel/devices/screen/arm/screen.c]]}
% vcore.c is in Kernel.nw with fbinit() function

<<kernel/devices/screen/arm/screen.c>>=
/*
 * bcm2385 framebuffer
 */
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"

#include <draw.h>
#include <font.h>
#include <memdraw.h>
#include <cursor.h>

#include "../port/portscreen.h"

enum {
    Wid     = 1024,
    Ht      = 768,
    Depth       = 16,
};

static Memdata xgdata;

static Memimage xgscreen =
{
    .r = { 0, 0, Wid, Ht },
    .clipr = { 0, 0, Wid, Ht },
    .depth = Depth,
    .nchan = 3,
    .chan = RGB16,
    .cmap = nil,
    .data = &xgdata,
    .zero = 0,
    .width = 0,             /* width in words of a single scan line */
    .layer = nil,
    .flags = 0,
};



/*
 * Software cursor. 
 */

// could factorize with swcursor_arrow
Cursor  arch_arrow = {
    { -1, -1 },
    { 0xFF, 0xFF, 0x80, 0x01, 0x80, 0x02, 0x80, 0x0C,
      0x80, 0x10, 0x80, 0x10, 0x80, 0x08, 0x80, 0x04,
      0x80, 0x02, 0x80, 0x01, 0x80, 0x02, 0x8C, 0x04,
      0x92, 0x08, 0x91, 0x10, 0xA0, 0xA0, 0xC0, 0x40,
    },
    { 0x00, 0x00, 0x7F, 0xFE, 0x7F, 0xFC, 0x7F, 0xF0,
      0x7F, 0xE0, 0x7F, 0xE0, 0x7F, 0xF0, 0x7F, 0xF8,
      0x7F, 0xFC, 0x7F, 0xFE, 0x7F, 0xFC, 0x73, 0xF8,
      0x61, 0xF0, 0x60, 0xE0, 0x40, 0x40, 0x00, 0x00,
    },
};

bool
arch_cursoron(bool dolock)
{
    bool retry;

    if (dolock)
        lock(&cursor);
    if (canqlock(&drawlock)) {
        retry = false;
        swcursor_hide();
        swcursor_draw();
        qunlock(&drawlock);
    } else
        retry = true;
    if (dolock)
        unlock(&cursor);
    return retry;
}

void
arch_cursoroff(bool dolock)
{
    if (dolock)
        lock(&cursor);
    swcursor_hide();
    if (dolock)
        unlock(&cursor);
}


/* called from devmouse */
void
arch_ksetcursor(Cursor* curs)
{
    arch_cursoroff(false);
    swcursor_load(curs);
    arch_cursoron(false);
}

/*
 * Drawing
 */

int
hwdraw(Memdrawparam *par)
{
    Memimage *dst, *src, *mask;

    if((dst=par->dst) == nil || dst->data == nil)
        return 0;
    if((src=par->src) == nil || src->data == nil)
        return 0;
    if((mask=par->mask) == nil || mask->data == nil)
        return 0;

    if(dst->data->bdata == xgdata.bdata)
        swcursor_avoid(par->r);
    if(src->data->bdata == xgdata.bdata)
        swcursor_avoid(par->sr);
    if(mask->data->bdata == xgdata.bdata)
        swcursor_avoid(par->mr);

    return 0;
}

static bool
screensize(void)
{
    char *p;
    char *f[3];
    int width, height, depth;

    p = getconf("vgasize");
    if(p == nil || getfields(p, f, nelem(f), 0, "x") != nelem(f) ||
        (width = atoi(f[0])) < 16 ||
        (height = atoi(f[1])) <= 0 ||
        (depth = atoi(f[2])) <= 0)
        return false;
    xgscreen.r.max = Pt(width, height);
    xgscreen.depth = depth;
    return true;
}

static void
screenwin(void)
{
    char *greet;
    Memimage *orange;
    Point p, q;
    int h;

    orange = allocmemimage(Rect(0, 0, 1, 1), RGB16);
    orange->flags |= Frepl;
    orange->clipr = gscreen->r;
    orange->data->bdata[0] = 0x40;      /* magic: colour? */
    orange->data->bdata[1] = 0xfd;      /* magic: colour? */

    h = swconsole_memdefont->height;

    memimagedraw(gscreen, 
                 Rect(swconsole_window.min.x, swconsole_window.min.y,
                      swconsole_window.max.x, swconsole_window.min.y + h + 5 + 6), 
                 orange, ZP, nil, ZP, S);
    freememimage(orange);

    swconsole_window = insetrect(swconsole_window, 5);

    greet = " Plan 9 Console ";
    p = addpt(swconsole_window.min, Pt(10, 0));
    q = memsubfontwidth(swconsole_memdefont, greet);
    memimagestring(gscreen, p, swconsole_conscol, ZP, swconsole_memdefont, 
                   greet);

    arch_flushmemscreen(gscreen->r); // was r before, but now in swconsole.c

    swconsole_window.min.y += h + 6;
    swconsole_curpos = swconsole_window.min;
    swconsole_window.max.y = 
      swconsole_window.min.y + 
      ((swconsole_window.max.y - swconsole_window.min.y) / h) * h;
}


void
arch__screeninit(void)
{
    uchar *fb;
    int set;
    ulong chan;

    set = screensize();
    fb = fbinit(set, &xgscreen.r.max.x, &xgscreen.r.max.y, &xgscreen.depth);
    if(fb == nil){
        print("can't initialise %dx%dx%d framebuffer \n",
            xgscreen.r.max.x, xgscreen.r.max.y, xgscreen.depth);
        return;
    }
    xgscreen.clipr = xgscreen.r;
    switch(xgscreen.depth){
    default:
        print("unsupported screen depth %d\n", xgscreen.depth);
        xgscreen.depth = 16;
        /* fall through */
    case 16:
        chan = RGB16;
        break;
    case 24:
        chan = BGR24;
        break;
    case 32:
        chan = ARGB32;
        break;
    }
    memsetchan(&xgscreen, chan);
    //conf.monitor = 1;
    xgdata.bdata = fb;
    xgdata.ref = 1;

    // set portscreen.c globals (used by draw.c, swcursor.c, swconsole
    gscreen = &xgscreen;
    gscreen->width = wordsperline(gscreen->r, gscreen->depth);

    memimageinit();
    swconsole_init();
    screenwin();

    screenputs = swconsole_screenputs;
}

uchar*
arch_attachscreen(Rectangle *r, ulong *chan, int* d, int *width, bool *softscreen)
{
    *r = gscreen->r;
    *d = gscreen->depth;
    *chan = gscreen->chan;
    *width = gscreen->width;
    *softscreen = false;

    return gscreen->data->bdata;
}

void
arch_blankscreen(bool blank)
{
    fbblank(blank);
}

void arch_flushmemscreen(Rectangle) { }
//old: #define ishwimage(i) 1       /* for ../port/devdraw.c */
bool arch_ishwimage(Memimage*) { return true; }
void arch_getcolor(ulong, ulong*, ulong*, ulong*) { }
int  arch_setcolor(ulong, ulong, ulong, ulong) { return 0; }
@

\section{[[kernel/devices/screen/386/]]}

\subsection{[[kernel/devices/screen/386/screen.h]]}
%pad: I renamed it vga.h at some point, but now that I have portscreen.h,
% which helps avoid some ambiguities in mkfile, so simpler to keep screen.h


%-------------------------------------------------------------

<<kernel/devices/screen/386/screen.h>>=

<<enum [[vgaports]](x86)>>

<<enum [[vgamisc]](x86)>>

<<function [[VGAMEM]](x86)>>

<<function [[vgao]](x86)>>
//#define vgai(port)    inb(port)
extern int vgaxi(long, uchar);
extern int vgaxo(long, uchar, uchar);

// forward decl
typedef struct VGAdev VGAdev;
typedef struct VGAcur VGAcur;
typedef struct VGAscr VGAscr;

<<struct [[VGAdev]](x86)>>

<<struct [[VGAcur]](x86)>>

<<struct [[VGAscr]](x86)>>

//!!!
extern VGAscr vgascreen;

<<enum [[_anon_ (kernel/devices/screen/386/screen.h)2]]>>


/* screen.c */
extern bool    hwaccel;  /* use hw acceleration; default on */
extern bool    hwblank;  /* use hw blanking; default on */
extern bool    panning;  /* use virtual screen panning; default off */

extern void 	addvgaseg(char*, ulong, ulong);

extern int  screensize(int, int, int, ulong);
extern int  screenaperture(int, int);

/* devdraw.c */
extern void deletescreenimage(void);
extern void resetscreenimage(void);
extern int drawidletime(void);
extern void drawblankscreen(int);
extern ulong  blanktime;
extern QLock  drawlock;
//extern int drawhasclients(void);
//extern void setscreenimageclipr(Rectangle);
//extern void drawflush(void);

/* vga.c */
extern void vgascreenwin(VGAscr*);
extern void vgaimageinit(ulong);
extern void vgalinearpciid(VGAscr*, int, int);
extern void vgalinearaddr(VGAscr*, ulong, int);
extern void vgablank(VGAscr*, int);
extern Lock vgascreenlock;

void swcursorinit_wrapper(void);

// software cursors
extern VGAcur swcursor;
@


\subsection{[[kernel/devices/screen/386/screen.c]]}
%pad: I created this file; its content was in vga.c and vgax.c.
% I originally called it vgascreen.c, but better keep as
% screen.c now that I have portscreen.c


%TODO: reuse swconsole.c! 

<<global [[curpos]](x86)>>=
static Point curpos;
@
<<global window bis(x86)>>=
static Rectangle window;
@
<<[[screensize()]] vga settings>>=
scr->memdefont = getmemdefont();
@
% direct access to subfont! no intermediate Font wrapper.
% Just need 1 subfont for simple ascii stuff.

% /dev/vgactl size write -> <>
<<function [[vgascreenwin]](x86)>>=
void
vgascreenwin(VGAscr* scr)
{
    int h, w;

    h = scr->memdefont->height;
    w = scr->memdefont->info[' '].width;

    window = insetrect(gscreen->r, 48);
    window.max.x = window.min.x+((window.max.x-window.min.x)/w)*w;
    window.max.y = window.min.y+((window.max.y-window.min.y)/h)*h;
    curpos = window.min;

    screenputs = vgascreenputs;
}
@
%todo: do like for raspberry, have greet message also in graphic mode?




% vgascreenputs -> screenputs = <> (and screenputs call for printing 
%  keystroke on the screen)
<<function [[vgascreenputs]](x86)>>=
static void
vgascreenputs(char* s, int n)
{
    int i;
    bool gotdraw;
    Rune r;
    char buf[4];
    VGAscr *scr;
    Rectangle flushr;

    scr = &vgascreen;

    if(!arch_islo()){
        /*
         * Don't deadlock trying to
         * print in an interrupt.
         */
        if(!canlock(&vgascreenlock))
            return;
    }
    else
        lock(&vgascreenlock);

    /*
     * Be nice to hold this, but not going to deadlock
     * waiting for it.  Just try and see.
     */
    gotdraw = canqlock(&drawlock);

    flushr = Rect(10000, 10000, -10000, -10000);

    while(n > 0){
        i = chartorune(&r, s);
        if(i == 0){
            s++;
            --n;
            continue;
        }
        memmove(buf, s, i);
        buf[i] = 0;
        n -= i;
        s += i;
        vgascreenputc(scr, buf, &flushr);
    }
    arch_flushmemscreen(flushr);

    if(gotdraw)
        qunlock(&drawlock);
    unlock(&vgascreenlock);
}
@


<<global [[xbuf]](x86)>>=
static int xbuf[256];
@
<<global [[xp]](x86)>>=
static int *xp;
@


% vgascreenputs -> <>
<<function [[vgascreenputc]](x86)>>=
static void
vgascreenputc(VGAscr* scr, char* buf, Rectangle *flushr)
{
    Point p;
    int h, w, pos;
    Rectangle r;

    if(xp < xbuf || xp >= &xbuf[sizeof(xbuf)])
        xp = xbuf;

    h = scr->memdefont->height;
    switch(buf[0]){

    case '\n':
        if(curpos.y+h >= window.max.y){
            vgascroll(scr);
            *flushr = window;
        }
        curpos.y += h;
        vgascreenputc(scr, "\r", flushr);
        break;

    case '\r':
        xp = xbuf;
        curpos.x = window.min.x;
        break;

    case '\t':
        p = memsubfontwidth(scr->memdefont, " ");
        w = p.x;
        if(curpos.x >= window.max.x-4*w)
            vgascreenputc(scr, "\n", flushr);

        pos = (curpos.x-window.min.x)/w;
        pos = 4-(pos%4);
        *xp++ = curpos.x;
        r = Rect(curpos.x, curpos.y, curpos.x+pos*w, curpos.y + h);
        memimagedraw(gscreen, r, back, back->r.min, nil, back->r.min, S);
        curpos.x += pos*w;
        break;

    case '\b':
        if(xp <= xbuf)
            break;
        xp--;
        r = Rect(*xp, curpos.y, curpos.x, curpos.y+h);
        memimagedraw(gscreen, r, back, back->r.min, nil, ZP, S);
        combinerect(flushr, r);
        curpos.x = *xp;
        break;

    case '\0':
        break;

    default:
        p = memsubfontwidth(scr->memdefont, buf);
        w = p.x;

        if(curpos.x >= window.max.x-w)
            vgascreenputc(scr, "\n", flushr);

        *xp++ = curpos.x;
        r = Rect(curpos.x, curpos.y, curpos.x+w, curpos.y+h);
        memimagedraw(gscreen, r, back, back->r.min, nil, back->r.min, S);
        memimagestring(gscreen, curpos, conscol, ZP, scr->memdefont, buf);
        combinerect(flushr, r);
        curpos.x += w;
    }
}
@
%old: was setting to true at beginning and reset at end
%//  drawdebug = true;
%//  drawdebug = false;





% vgascreenputs -> vgascreenputc -> <>
<<function [[vgascroll]](x86)>>=
static void
vgascroll(VGAscr* scr)
{
    int h, o;
    Point p;
    Rectangle r;

    h = scr->memdefont->height;
    o = 8*h;
    r = Rpt(window.min, Pt(window.max.x, window.max.y-o));
    p = Pt(window.min.x, window.min.y+o);
    memimagedraw(gscreen, r, gscreen, p, nil, p, S);
    r = Rpt(Pt(window.min.x, window.max.y-o), window.max);
    memimagedraw(gscreen, r, back, ZP, nil, ZP, S);

    curpos.y -= o;
}
@
% not very hardware specific, could probably be put in a generic screen.c no?


<<global [[back2]](x86)>>=
static Memimage* back;
@

<<global [[conscol]](x86)>>=
static Memimage *conscol;
@









<<[[screensize()]] vga settings>>=
vgaimageinit(chan);
@

<<function [[vgaimageinit]](x86)>>=
void
vgaimageinit(channels chan)
{
    if(back == nil){
        back = allocmemimage(Rect(0,0,1,1), chan);  /* RSC BUG */
        if(back == nil)
            panic("back alloc");        /* RSC BUG */
        back->flags |= Frepl;
        back->clipr = Rect(-0x3FFFFFF, -0x3FFFFFF, 0x3FFFFFF, 0x3FFFFFF);
        memfillcolor(back, DBlack);
    }

    if(conscol == nil){
        conscol = allocmemimage(Rect(0,0,1,1), chan);   /* RSC BUG */
        if(conscol == nil)
            panic("conscol alloc"); /* RSC BUG */
        conscol->flags |= Frepl;
        conscol->clipr = Rect(-0x3FFFFFF, -0x3FFFFFF, 0x3FFFFFF, 0x3FFFFFF);
        memfillcolor(conscol, DWhite);
    }
}
@



%-------------------------------------------------------------

<<kernel/devices/screen/386/screen.c>>=
#include "u.h"
#include "../port/lib.h"
#include "../port/error.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"

#include "io.h"
#include <ureg.h>

#include <draw.h>
#include <font.h>
#include <memdraw.h>
#include <cursor.h>

#include "../port/portscreen.h"
#include "screen.h"

//TODO: can not reuse swcursor.c, WEIRD, kernel fault when run rio!
static void swcursorhide(void);
static void swcursoravoid(Rectangle);
static void swcursordraw(void);
static void swload(VGAscr*, Cursor *curs);
static int swmove(VGAscr*, Point p);
static void swcursorinit(void);

void swcursorinit_wrapper(void);

//---------------------------------------------------------------------------
// vgax.c
//---------------------------------------------------------------------------

<<global [[vgaxlock]](x86)>>

<<function [[vgaxi]](x86)>>

<<function [[vgaxo]](x86)>>

//---------------------------------------------------------------------------
// vga.c
//---------------------------------------------------------------------------

<<global [[back2]](x86)>>
<<global [[conscol]](x86)>>

<<global [[curpos]](x86)>>
<<global window bis(x86)>>
<<global [[xp]](x86)>>
<<global [[xbuf]](x86)>>
<<global [[vgascreenlock]](x86)>>

<<function [[vgaimageinit]](x86)>>

<<function [[vgascroll]](x86)>>

<<function [[vgascreenputc]](x86)>>

<<function [[vgascreenputs]](x86)>>

<<function [[vgascreenwin]](x86)>>

<<function [[vgablank]](x86)>>

<<function [[addvgaseg]](x86)>>


//---------------------------------------------------------------------------
// vgascreen.c
//---------------------------------------------------------------------------


//#define RGB2K(r,g,b)    ((156763*(r)+307758*(g)+59769*(b))>>19)

extern void vgalinearpci(VGAscr*);


//already in libdraw/arith.c

<<global [[vgascreen]](x86)>>

<<global [[didswcursorinit]](x86)>>

<<global [[softscreen]](x86)>>

<<function [[ishwimage]](x86)>>


<<function [[screensize]](x86)>>

<<function [[screenaperture]](x86)>>

<<function [[attachscreen]](x86)>>

<<function [[flushmemscreen]](x86)>>

<<function [[getcolor]](x86)>>

<<function [[setpalette]](x86)>>

<<function [[setcolor]](x86)>>

<<function [[cursoron]](x86)>>

<<function [[cursoroff]](x86)>>

<<function [[ksetcursor]](x86)>>

<<global [[hwaccel]](x86)>>
<<global [[hwblank]](x86)>>
<<global [[panning]](x86)>>

<<function [[hwdraw]](x86)>>

<<function blankscreen bis(x86)>>

<<function [[vgalinearpciid]](x86)>>

<<function [[vgalinearpci]](x86)>>

<<function [[vgalinearaddr]](x86)>>


/*
 * Software cursor. 
 */
//TODO: reuse swcursor.c (but get kernel fault when run rio, WEIRD)

Cursor  arch_arrow = {
    .offset = { -1, -1 },
    .clr = { 
      0xFF, 0xFF, 0x80, 0x01, 0x80, 0x02, 0x80, 0x0C, 
      0x80, 0x10, 0x80, 0x10, 0x80, 0x08, 0x80, 0x04, 
      0x80, 0x02, 0x80, 0x01, 0x80, 0x02, 0x8C, 0x04, 
      0x92, 0x08, 0x91, 0x10, 0xA0, 0xA0, 0xC0, 0x40, 
    },
    .set = { 
      0x00, 0x00, 0x7F, 0xFE, 0x7F, 0xFC, 0x7F, 0xF0, 
      0x7F, 0xE0, 0x7F, 0xE0, 0x7F, 0xF0, 0x7F, 0xF8, 
      0x7F, 0xFC, 0x7F, 0xFE, 0x7F, 0xFC, 0x73, 0xF8, 
      0x61, 0xF0, 0x60, 0xE0, 0x40, 0x40, 0x00, 0x00, 
    },
};

extern bool swvisible;  /* is the cursor visible? */
extern bool swenabled;  /* is the cursor supposed to be on the screen? */
extern Memimage*   swback; /* screen under cursor */
extern Memimage*   swimg;  /* cursor image */
extern Memimage*   swmask; /* cursor mask */
extern Memimage*   swimg1;
extern Memimage*   swmask1;
extern Point   swoffset;
extern Rectangle   swrect; /* screen rectangle in swback */
extern Point   swpt;   /* desired cursor location */
extern Point   swvispt;    /* actual cursor location */
extern int swvers; /* incremented each time cursor image changes */
extern int swvisvers;  /* the version on the screen */


/*
 * called with drawlock locked for us, most of the time.
 * kernel prints at inopportune times might mean we don't
 * hold the lock, but memimagedraw is now reentrant so
 * that should be okay: worst case we get cursor droppings.
 */
static void
swcursorhide(void)
{
    if(!swvisible)
        return;
    if(swback == nil)
        return;

    swvisible = false;
    // restore what was under the cursor
    memimagedraw(gscreen, swrect, swback, ZP, memopaque, ZP, S);
    arch_flushmemscreen(swrect);
}

static void
swcursoravoid(Rectangle r)
{
    if(swvisible && rectXrect(r, swrect))
        swcursorhide();
}

static void
swcursordraw(void)
{
    if(swvisible)
        return;
    if(!swenabled)
        return;
    if(swback == nil || swimg1 == nil || swmask1 == nil)
        return;
    assert(!canqlock(&drawlock));

    swvispt = swpt;
    swvisvers = swvers;
    // cursor is 16x16 picture
    swrect = rectaddpt(Rect(0,0,16,16), swvispt);
    // save what is under the cursor
    memimagedraw(swback, swback->r, gscreen, swpt, memopaque, ZP, S);
    // draw cursor
    memimagedraw(gscreen, swrect, swimg1, ZP, swmask1, ZP, SoverD);
    arch_flushmemscreen(swrect);
    swvisible = true;
}
<<function [[swenable]](x86)>>

<<function [[swdisable]](x86)>>

static void
swload(VGAscr*, Cursor *curs)
{
    byte *ip, *mp;
    int i, j, set, clr;

    if(!swimg || !swmask || !swimg1 || !swmask1)
        return;
    /*
     * Build cursor image and mask.
     * Image is just the usual cursor image
     * but mask is a transparent alpha mask.
     * 
     * The 16x16x8 memimages do not have
     * padding at the end of their scan lines.
     */
    ip = byteaddr(swimg, ZP);
    mp = byteaddr(swmask, ZP);

    for(i=0; i<32; i++){
        set = curs->set[i];
        clr = curs->clr[i];
        for(j=0x80; j; j>>=1){
            *ip++ = set & j ? 0x00 : 0xFF;
            *mp++ = (clr|set) & j ? 0xFF : 0x00;
        }
    }
    swoffset = curs->offset;
    swvers++;

    memimagedraw(swimg1,  swimg1->r,  swimg,  ZP, memopaque, ZP, S);
    memimagedraw(swmask1, swmask1->r, swmask, ZP, memopaque, ZP, S);
}

static int
swmove(VGAscr*, Point p)
{
    swpt = addpt(p, swoffset);
    return 0;
}

static void
swcursorclock(void)
{
    int x;

    if(!swenabled)
        return;
    if(swvisible && eqpt(swpt, swvispt) && swvers==swvisvers)
        return;

    x = arch_splhi();
    // check again, might have changed in between
    if(swenabled)
     if(!swvisible || !eqpt(swpt, swvispt) || swvers!=swvisvers)
      if(canqlock(&drawlock)){

        swcursorhide();
        swcursordraw();

        qunlock(&drawlock);
    }
    arch_splx(x);
}

void
swcursorinit_wrapper(void)
{
    static bool init;
    VGAscr *scr;
    static bool warned;

    didswcursorinit = true;
    if(!init){
        init = true;
        addclock0link(swcursorclock, 10);
    }
    scr = &vgascreen;

    if(scr == nil || gscreen == nil)
        return;
    if(scr->dev == nil || scr->dev->linear == nil){
        if(!warned){
            print("cannot use software cursor on non-linear vga screen\n");
            warned = true;
        }
        return;
    }

    if(swback){
        freememimage(swback);
        freememimage(swmask);
        freememimage(swmask1);
        freememimage(swimg);
        freememimage(swimg1);
    }

    swback  = allocmemimage(Rect(0,0,32,32), gscreen->chan);

    swmask  = allocmemimage(Rect(0,0,16,16), GREY8);
    swmask1 = allocmemimage(Rect(0,0,16,16), GREY1);
    swimg   = allocmemimage(Rect(0,0,16,16), GREY8);
    swimg1  = allocmemimage(Rect(0,0,16,16), GREY1);

    if(swback == nil || swmask == nil || swmask1 == nil || swimg == nil || swimg1 == nil){
        print("software cursor: allocmemimage fails");
        return;
    }

    memfillcolor(swmask,  DOpaque);
    memfillcolor(swmask1, DOpaque);
    memfillcolor(swimg,   DBlack);
    memfillcolor(swimg1,  DBlack);
}


<<global [[swcursor]](x86)>>

@

%what I would like (but currently cant factorize so have to 
% copy lots of swcursor.c in here)
%<<function swenable(x86)>>
%
%<<function swdisable(x86)>>
%
%void swload_wrapper(VGAscr*, Cursor *curs) { swload(curs); }
%int swmove_wrapper(VGAscr*, Point p) { return swmove(p); }
%
%
%<<global swcursor(x86)>>


%\subsection{[[kernel/devices/screen/386/vgax.c]]}
% actually code now in vgascreen.c


%\subsection{[[kernel/devices/screen/386/vga.c]]}
% actually code now in vgascreen.c




%//void
%//cornerstring(char *s)
%//{
%//  int h, w;
%//  VGAscr *scr;
%//  Rectangle r;
%//  Point p;
%//
%//  scr = &vgascreen[0];
%//  if(scr->vaddr == nil || screenputs != vgascreenputs)
%//      return;
%//  p = memsubfontwidth(scr->memdefont, s);
%//  w = p.x;
%//  h = scr->memdefont->height;
%//
%//  r = Rect(0, 0, w, h);
%//  memimagedraw(scr->gscreen, r, back, back->r.min, nil, back->r.min, S);
%//  memimagestring(scr->gscreen, r.min, conscol, ZP, scr->memdefont, s);
%////    flushmemscreen(r);
%//}

\subsection{[[kernel/devices/screen/386/devvga.c]]}


%-------------------------------------------------------------

<<kernel/devices/screen/386/devvga.c>>=
/*
 * VGA controller
 */
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"
#include "io.h"
#include "../port/error.h"

#include <draw.h>
#include <memdraw.h>
#include <cursor.h>

#include "../port/portscreen.h"
#include "screen.h"

<<enum [[_anon_ (kernel/devices/screen/386/devvga.c)]]>>

<<global [[vgadir]](x86)>>

<<enum [[_anon_ (kernel/devices/screen/386/devvga.c)2]]>>

<<global [[vgactlmsg]](x86)>>

<<function [[vgareset]](x86)>>

<<function [[vgaattach]](x86)>>

<<function [[vgawalk]](x86)>>

<<function [[vgastat]](x86)>>

<<function [[vgaopen]](x86)>>

<<function [[vgaclose]](x86)>>

<<function [[vgaread]](x86)>>

<<function [[vgactl]](x86)>>

<<global [[Enooverlay]](x86)>>

<<function [[vgawrite]](x86)>>

<<global [[vgadevtab]](x86)>>
@

%//static void
%//checkport(int start, int end)
%//{
%//  /* standard vga regs are OK */
%//  if(start >= 0x2b0 && end <= 0x2df+1)
%//      return;
%//  if(start >= 0x3c0 && end <= 0x3da+1)
%//      return;
%//
%//  if(iounused(start, end))
%//      return;
%//  error(Eperm);


\subsection{[[kernel/devices/screen/386/vgaclgd542x.c]]}

%-------------------------------------------------------------

<<kernel/devices/screen/386/vgaclgd542x.c>>=
#include "u.h"
#include "../port/lib.h"
#include "../port/error.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"

#include "io.h"

#include <draw.h>
#include <memdraw.h>
#include <cursor.h>

#include "../port/portscreen.h"
#include "screen.h"

<<function [[clgd542xpageset]](x86)>>

<<function [[clgd542xpage]](x86)>>

<<function [[clgd542xlinear]](x86)>>

<<function [[clgd542xdisable]](x86)>>

<<function [[clgd542xenable]](x86)>>

<<function [[clgd542xinitcursor]](x86)>>

<<function [[clgd542xload]](x86)>>

<<function [[clgd542xmove]](x86)>>

<<global [[vgaclgd542xdev]](x86)>>

<<global [[vgaclgd542xcur]](x86)>>
@


\subsection{[[kernel/devices/screen/386/vgavesa.c]]}

<<enum [[_anon_ (kernel/devices/screen/386/vgavesa.c)]]>>=
enum {
    Usesoftscreen = 1,
};
@

<<global [[hardscreen]](x86)>>=
static void *hardscreen;
@

<<global [[modebuf]](x86)>>=
static uchar modebuf[0x1000];
@

<<function [[WORD]](x86)>>=
// pad: seems similar to macros in fcall.h, factorize?
#define WORD(p) ((p)[0] | ((p)[1]<<8))
@

<<function [[LONG]](x86)>>=
#define LONG(p) ((p)[0] | ((p)[1]<<8) | ((p)[2]<<16) | ((p)[3]<<24))
@

%//#define PLONG(p, v) do{(p)[0] = (v); (p)[1] = (v)>>8; (p)[2] = (v)>>16; (p)[3] = (v)>>24;}while(0)


<<function [[vbesetup]](x86)>>=
static uchar*
vbesetup(Ureg *u, int ax)
{
    ulong pa;

    pa = PADDR(RMBUF);
    memset(modebuf, 0, sizeof modebuf);
    memset(u, 0, sizeof *u);
    u->ax = ax;
    u->es = (pa>>4)&0xF000;
    u->di = pa&0xFFFF;
    return modebuf;
}
@

<<function [[vbecall]](x86)>>=
static void
vbecall(Ureg *u)
{
    Chan *creg, *cmem;
    ulong pa;

    cmem = namec("/dev/realmodemem", Aopen, ORDWR, 0);
    if(waserror()){
        cclose(cmem);
        nexterror();
    }
    creg = namec("/dev/realmode", Aopen, ORDWR, 0);
    if(waserror()){
        cclose(creg);
        nexterror();
    }
    pa = PADDR(RMBUF);
    /* TODO: check read and write return values */
    devtab[cmem->type]->write(cmem, modebuf, sizeof modebuf, pa);
    u->trap = 0x10;
    devtab[creg->type]->write(creg, u, sizeof *u, 0);

    devtab[creg->type]->read(creg, u, sizeof *u, 0);
    if((u->ax&0xFFFF) != 0x004F)
        error("vesa bios error");
    devtab[cmem->type]->read(cmem, modebuf, sizeof modebuf, pa);

    poperror();
    cclose(creg);
    poperror();
    cclose(cmem);
}
@

<<function [[vbecheck]](x86)>>=
static void
vbecheck(void)
{
    Ureg u;
    uchar *p;

    p = vbesetup(&u, 0x4F00);
    strcpy((char*)p, "VBE2");
    vbecall(&u);
    if(memcmp((char*)p, "VESA", 4) != 0)
        error("bad vesa signature");
    if(p[5] < 2)
        error("bad vesa version");
}
@

<<function [[vbegetmode]](x86)>>=
static int
vbegetmode(void)
{
    Ureg u;

    vbesetup(&u, 0x4F03);
    vbecall(&u);
    return u.bx;
}
@

<<function [[vbemodeinfo]](x86)>>=
static uchar*
vbemodeinfo(int mode)
{
    uchar *p;
    Ureg u;

    p = vbesetup(&u, 0x4F01);
    u.cx = mode;
    vbecall(&u);
    return p;
}
@


% vesalinear -> <>
% framebuffer for real? can do video games with that?
% vga.c
<<function [[addvgaseg]](x86)>>=
void
addvgaseg(char *name, ulong pa, ulong size)
{
    Physseg seg;

    memset(&seg, 0, sizeof seg);
    seg.attr = SG_PHYSICAL;
    seg.name = name;
    seg.pa = pa;
    seg.size = size;
    addphysseg(&seg);
}
@


% should not take scr in parameter now that I simplified
% vgascreen and gscreen
<<function [[vesaflush]](x86)>>=
static void
vesaflush(VGAscr *scr, Rectangle r)
{
    int t, w, wid, off;
    ulong *hp, *sp, *esp;

    USED(scr); // now use gscreen directly
    if(hardscreen == nil)
        return;
    if(rectclip(&r, gscreen->r) == 0)
        return;
    sp = (ulong*)(gscreendata.bdata + gscreen->zero);
    t = (r.max.x * gscreen->depth + 2*BI2WD-1) / BI2WD;
    w = (r.min.x * gscreen->depth) / BI2WD;
    w = (t - w) * BY2WD;
    wid = gscreen->width;
    off = r.min.y * wid + (r.min.x * gscreen->depth) / BI2WD;

    hp = hardscreen;
    hp += off;
    sp += off;
    esp = sp + Dy(r) * wid;
    while(sp < esp){
        memmove(hp, sp, w);
        hp += wid;
        sp += wid;
    }
}
@



%-------------------------------------------------------------

<<kernel/devices/screen/386/vgavesa.c>>=
/*
 * vga driver using just vesa bios to set up.
 *
 * note that setting hwaccel to zero will cause cursor ghosts to be
 * left behind.  hwaccel set non-zero repairs this.
 */
#include "u.h"
#include "../port/lib.h"
#include "../port/error.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"

#include "io.h"
#include <ureg.h>

#include <draw.h>
#include <memdraw.h>
#include <cursor.h>

#include "../port/portscreen.h"
#include "screen.h"

<<enum [[_anon_ (kernel/devices/screen/386/vgavesa.c)]]>>

<<global [[hardscreen]](x86)>>
<<global [[modebuf]](x86)>>

<<function [[WORD]](x86)>>
<<function [[LONG]](x86)>>
<<function [[vbesetup]](x86)>>

<<function [[vbecall]](x86)>>

<<function [[vbecheck]](x86)>>

<<function [[vbegetmode]](x86)>>

<<function [[vbemodeinfo]](x86)>>

<<function [[vesalinear]](x86)>>

<<function [[vesaflush]](x86)>>

<<global [[vgavesadev]](x86)>>
@

%//#define PWORD(p, v) do{(p)[0] = (v); (p)[1] = (v)>>8;}while(0)

