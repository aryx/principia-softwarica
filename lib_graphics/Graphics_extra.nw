\section{[[include/]]}

\subsection*{[[include/cursor.h]]}

%-------------------------------------------------------------

<<include/cursor.h>>=
#pragma src "/sys/src/libdraw"

typedef struct	Cursor Cursor;

<<struct Cursor>>
@


\subsection*{[[include/draw.h]]}

<<enum _anon_ (include/draw.h)>>=
enum
{
    <<constant ICOSSCALE>>
    <<constant Borderwidth>>
};
@
% dead?    Displaybufsize	= 8000,
% dead: #define	NOREFRESH	((void*)-1)

%typedef void	(*Reffn)(Image*, Rectangle, void*);

%-------------------------------------------------------------

<<include/draw.h>>=
#pragma src "/sys/src/libdraw"
#pragma lib "libdraw.a"

// forward decls
typedef struct	Cachefont Cachefont;
typedef struct	Cacheinfo Cacheinfo;
typedef struct	Cachesubf Cachesubf;
typedef struct	Display Display;
typedef struct	Font Font;
typedef struct	Fontchar Fontchar;
typedef struct	Image Image;
typedef struct	Mouse Mouse;
typedef struct	Point Point;
typedef struct	Rectangle Rectangle;
typedef struct	RGB RGB;
typedef struct	Screen Screen;
typedef struct	Subfont Subfont;

#pragma incomplete Mouse

// dumpers
#pragma varargck	type	"R"	Rectangle
#pragma varargck	type	"P"	Point
extern	int	Rfmt(Fmt*);
extern	int	Pfmt(Fmt*);

<<enum _anon_>>

<<enum _anon_ (include/draw.h)>>

<<enum _anon_ (include/draw.h)2>>

<<enum _anon_ (include/draw.h)3>>

<<function ARROW>>

<<enum drawop>>
typedef enum drawop Drawop;

<<enum _anon_ (include/draw.h)4>>

<<function __DC>>
<<function CHAN1>>
<<function CHAN2>>
<<function CHAN3>>
<<function CHAN4>>

<<function NBITS>>
<<function TYPE>>

<<enum _anon_ (include/draw.h)5>>

extern	int		chantodepth(ulong);

extern	char*	chantostr(char*, ulong);
extern	ulong	strtochan(char*);

<<struct Point>>

<<struct Rectangle>>

<<struct Screen>>

<<struct Display>>

<<struct Image>>

<<struct RGB>>

<<struct Fontchar>>

<<struct Subfont>>

<<enum _anon_ (include/draw.h)6>>

<<struct Cachefont>>

<<struct Cacheinfo>>

<<struct Cachesubf>>

<<struct Font>>

<<function Dx>>
<<function Dy>>

/*
 * Image management
 */
extern int	initdraw(void(*)(Display*, char*), char*, char*);
extern int	geninitdraw(char*, void(*)(Display*, char*), char*, char*, char*, int);
extern Display*	initdisplay(char*, char*, void(*)(Display*, char*));
extern void		closedisplay(Display*);

extern int		flushimage(Display*, bool);

extern Image*	allocimage(Display*, Rectangle, ulong, int, ulong);
extern int		freeimage(Image*);
extern Image* 	allocimagemix(Display*, ulong, ulong);

extern int		loadimage(Image*, Rectangle, uchar*, int);
extern int		unloadimage(Image*, Rectangle, uchar*, int);
extern Image* 	readimage(Display*, int, int);
extern int		writeimage(int, Image*, int);

// compressed variants
extern int		cloadimage(Image*, Rectangle, uchar*, int);
extern Image* 	creadimage(Display*, int, int);

extern Image*	namedimage(Display*, char*);
extern int		nameimage(Image*, char*, int);

extern void	drawerror(Display*, char*);

extern int	bytesperline(Rectangle, int);
extern int	wordsperline(Rectangle, int);

// why not in Windows section?
extern int	newwindow(char*);
extern int	getwindow(Display*, int);
extern int	gengetwindow(Display*, char*, Image**, Screen**, int);


/*
 * Colors
 */
extern	void	readcolmap(Display*, RGB*);
extern	void	writecolmap(Display*, RGB*);
extern	ulong	setalpha(ulong, uchar);

/*
 * Windows
 */
extern Screen*	allocscreen(Image*, Image*, int);
extern int		freescreen(Screen*);
extern Screen*	publicscreen(Display*, int, ulong);

extern Image*	allocwindow(Screen*, Rectangle, int, ulong);
extern int	originwindow(Image*, Point, Point);
extern void	bottomnwindows(Image**, int);
extern void	bottomwindow(Image*);
extern void	topnwindows(Image**, int);
extern void	topwindow(Image*);

/*
 * Geometry
 */
extern Point	Pt(int, int);
extern Point	addpt(Point, Point);
extern Point	subpt(Point, Point);
extern Point	divpt(Point, int);
extern Point	mulpt(Point, int);
extern int		eqpt(Point, Point);

extern Rectangle	Rect(int, int, int, int);
extern Rectangle	Rpt(Point, Point);
extern int			eqrect(Rectangle, Rectangle);
extern Rectangle	insetrect(Rectangle, int);
extern Rectangle	rectaddpt(Rectangle, Point);
extern Rectangle	rectsubpt(Rectangle, Point);
extern Rectangle	canonrect(Rectangle);
extern int		rectXrect(Rectangle, Rectangle);
extern int		rectinrect(Rectangle, Rectangle);
extern void		combinerect(Rectangle*, Rectangle);
extern int		rectclip(Rectangle*, Rectangle);
extern int		ptinrect(Point, Rectangle);

extern void		replclipr(Image*, int, Rectangle);
extern int		drawreplxy(int, int, int);	/* used to be drawsetxy */
extern Point	drawrepl(Rectangle, Point);
extern int		rgb2cmap(int, int, int);
extern int		cmap2rgb(int);
extern int		cmap2rgba(int);

extern void		icossin(int, int*, int*);
extern void		icossin2(int, int, int*, int*);

/*
 * Graphics
 */
extern void	draw(Image*, Rectangle, Image*, Image*, Point);
extern void	drawop(Image*, Rectangle, Image*, Image*, Point, Drawop);
extern void	gendraw(Image*, Rectangle, Image*, Point, Image*, Point);
extern void	gendrawop(Image*, Rectangle, Image*, Point, Image*, Point, Drawop);

extern void	border(Image*, Rectangle, int, Image*, Point);
extern void	borderop(Image*, Rectangle, int, Image*, Point, Drawop);

extern void	line(Image*, Point, Point, int, int, int, Image*, Point);
extern void	lineop(Image*, Point, Point, int, int, int, Image*, Point, Drawop);

extern void	poly(Image*, Point*, int, int, int, int, Image*, Point);
extern void	polyop(Image*, Point*, int, int, int, int, Image*, Point, Drawop);
extern void	fillpoly(Image*, Point*, int, int, Image*, Point);
extern void	fillpolyop(Image*, Point*, int, int, Image*, Point, Drawop);

extern void	ellipse(Image*, Point, int, int, int, Image*, Point);
extern void	ellipseop(Image*, Point, int, int, int, Image*, Point, Drawop);
extern void	fillellipse(Image*, Point, int, int, Image*, Point);
extern void	fillellipseop(Image*, Point, int, int, Image*, Point, Drawop);

extern void	arc(Image*, Point, int, int, int, Image*, Point, int, int);
extern void	arcop(Image*, Point, int, int, int, Image*, Point, int, int, Drawop);
extern void	fillarc(Image*, Point, int, int, Image*, Point, int, int);
extern void	fillarcop(Image*, Point, int, int, Image*, Point, int, int, Drawop);

extern int	bezier(Image*, Point, Point, Point, Point, int, int, int, Image*, Point);
extern int	bezierop(Image*, Point, Point, Point, Point, int, int, int, Image*, Point, Drawop);
extern int	bezspline(Image*, Point*, int, int, int, int, Image*, Point);
extern int	bezsplineop(Image*, Point*, int, int, int, int, Image*, Point, Drawop);
extern int	bezsplinepts(Point*, int, Point**);
extern int	fillbezier(Image*, Point, Point, Point, Point, int, Image*, Point);
extern int	fillbezierop(Image*, Point, Point, Point, Point, int, Image*, Point, Drawop);
extern int	fillbezspline(Image*, Point*, int, int, Image*, Point);
extern int	fillbezsplineop(Image*, Point*, int, int, Image*, Point, Drawop);


extern Point	string(Image*, Point, Image*, Point, Font*, char*);
extern Point	stringop(Image*, Point, Image*, Point, Font*, char*, Drawop);
extern Point	stringn(Image*, Point, Image*, Point, Font*, char*, int);
extern Point	stringnop(Image*, Point, Image*, Point, Font*, char*, int, Drawop);
extern Point	runestring(Image*, Point, Image*, Point, Font*, Rune*);
extern Point	runestringop(Image*, Point, Image*, Point, Font*, Rune*, Drawop);
extern Point	runestringn(Image*, Point, Image*, Point, Font*, Rune*, int);
extern Point	runestringnop(Image*, Point, Image*, Point, Font*, Rune*, int, Drawop);
extern Point	stringbg(Image*, Point, Image*, Point, Font*, char*, Image*, Point);
extern Point	stringbgop(Image*, Point, Image*, Point, Font*, char*, Image*, Point, Drawop);
extern Point	stringnbg(Image*, Point, Image*, Point, Font*, char*, int, Image*, Point);
extern Point	stringnbgop(Image*, Point, Image*, Point, Font*, char*, int, Image*, Point, Drawop);
extern Point	runestringbg(Image*, Point, Image*, Point, Font*, Rune*, Image*, Point);
extern Point	runestringbgop(Image*, Point, Image*, Point, Font*, Rune*, Image*, Point, Drawop);
extern Point	runestringnbg(Image*, Point, Image*, Point, Font*, Rune*, int, Image*, Point);
extern Point	runestringnbgop(Image*, Point, Image*, Point, Font*, Rune*, int, Image*, Point, Drawop);


extern Point	stringsubfont(Image*, Point, Image*, Subfont*, char*);


/*
 * Font management
 */
extern Font*	openfont(Display*, char*);
extern void		freefont(Font*);

extern Font*	buildfont(Display*, char*, char*);
extern Font*	mkfont(Subfont*, Rune);

extern Subfont*	allocsubfont(char*, int, int, int, Fontchar*, Image*);
extern Subfont*	lookupsubfont(Display*, char*);
extern void	installsubfont(char*, Subfont*);
extern void	freesubfont(Subfont*);
extern Subfont*	readsubfont(Display*, char*, int, int);
extern Subfont*	readsubfonti(Display*, char*, int, Image*, int);
extern int	writesubfont(int, Subfont*);
extern void	uninstallsubfont(Subfont*);
extern char*	subfontname(char*, char*, int);
extern Subfont*	_getsubfont(Display*, char*);

extern Point	stringsize(Font*, char*);
extern int		stringwidth(Font*, char*);
extern int		stringnwidth(Font*, char*, int);
extern Point	runestringsize(Font*, Rune*);
extern int		runestringwidth(Font*, Rune*);
extern int		runestringnwidth(Font*, Rune*, int);

extern int		cachechars(Font*, char**, Rune**, ushort*, int, int*, char**);
extern void		agefont(Font*);
extern void		_unpackinfo(Fontchar*, uchar*, int);
extern Point	strsubfontwidth(Subfont*, char*);
extern int		loadchar(Font*, Rune, Cacheinfo*, int, int, char**);
extern Subfont*	getdefont(Display*);
extern int		drawlsetrefresh(ulong, int, void*, void*);

// seems related to font
extern void		lockdisplay(Display*);
extern void		unlockdisplay(Display*);

/*
 * One of a kind
 */
extern int		mousescrollsize(int);


/*
 * Predefined 
 */
extern	Point		ZP;
extern	Rectangle	ZR;
extern	uchar	defontdata[];
extern	int		sizeofdefont;

/*
 * Set up by initdraw()
 */
extern	Display	*display;
extern	Image	*screen;
extern	Font	*font;

extern	Screen	*_screen;
extern	int		_cursorfd;
extern	bool	_drawdebug;	/* set to true to see errors from flushimage */

// forward decl, could be move to individual files or in a drawimpl.h
// used also by window.c
extern Image*	_allocimage(Image*, Display*, Rectangle, ulong, int, ulong, int, int);
extern int	    _freeimage1(Image*);
extern Image*	_allocwindow(Image*, Screen*, Rectangle, int, ulong);
extern Point	_string(Image*, Point, Image*, Point, Font*, char*, Rune*, int, Rectangle, Image*, Point, Drawop);
extern	void	_setdrawop(Display*, Drawop);

// internals
extern byte*	bufimage(Display*, int);

<<function BGSHORT>>
<<function BGLONG>>
<<function BPSHORT>>
<<function BPLONG>>

<<constant NMATCH>>
<<constant NRUN>>
<<constant NMEM>>
<<constant NDUMP>>
<<constant NCBLOCK>>
extern	void	_twiddlecompressed(uchar*, int);
extern	int	_compblocksize(Rectangle, int);

/* XXX backwards helps; should go */
extern	ulong	drawld2chan[];
extern	void	drawsetdebug(int);
@
%// extern	int		log2[];	/* was used by libmemlayer/line.c */


\subsection*{[[include/event.h]]}


%-------------------------------------------------------------

<<include/event.h>>=
#pragma src "/sys/src/libdraw"
#pragma lib "libdraw.a"

typedef struct	Cursor Cursor;
typedef struct	Event Event;
typedef struct	Menu Menu;

<<enum _anon_ (include/event.h)>>

<<enum _anon_ (include/event.h)2>>

<<struct Mouse>>

<<struct Event>>

<<struct Menu>>

/*
 * Events
 */
extern void		einit(ulong);
extern ulong	estart(ulong, int, int);
extern ulong	estartfn(ulong, int, int, int (*fn)(int, Event*, uchar*, int));
extern ulong	 event(Event*);
extern ulong	 eread(ulong, Event*);
extern int	 ecanread(ulong);

extern Mouse	emouse(void);
extern int	 	ekbd(void);
extern ulong	etimer(ulong, int);
extern int	 	ecanmouse(void);
extern int	 	ecankbd(void);

//ugly!!!
extern void	 eresized(int);	/* supplied by user */

extern int	 	emenuhit(int, Mouse*, Menu*);
extern void	 	esetcursor(Cursor*);
extern void	 	emoveto(Point);
extern void		edrawgetrect(Rectangle, int);
extern int		ereadmouse(Mouse*);
extern int		eatomouse(Mouse*, char*, int);

extern Rectangle	getrect(int, Mouse*);
extern Rectangle	egetrect(int, Mouse*);
@


\subsection*{[[include/keyboard.h]]}

%-------------------------------------------------------------

<<include/keyboard.h>>=
#pragma src "/sys/src/libdraw"
#pragma lib "libdraw.a"

typedef struct 	Keyboardctl Keyboardctl;
typedef struct	Channel	Channel;

<<struct Keyboardctl>>

extern	Keyboardctl*	initkeyboard(char*);
extern	int				ctlkeyboard(Keyboardctl*, char*);
extern	void			closekeyboard(Keyboardctl*);

<<enum _anon_ (include/keyboard.h)>>
@


\subsection*{[[include/memdraw.h]]}


%-------------------------------------------------------------

<<include/memdraw.h>>=
#pragma	src	"/sys/src/libmemdraw"
#pragma	lib	"libmemdraw.a"

typedef struct	Memimage Memimage;
typedef struct	Memdata Memdata;
typedef struct	Memsubfont Memsubfont;
typedef struct	Memlayer Memlayer;
typedef struct	Memcmap Memcmap;
typedef struct	Memdrawparam	Memdrawparam;

#pragma incomplete Memlayer

<<struct Memdata>>

<<enum fxxx>>

<<struct Memimage>>

<<struct Memcmap>>

<<struct Memsubfont>>

<<enum _anon_ (include/memdraw.h)2>>
<<struct Memdrawparam>>

/*
 * Memimage management
 */
extern Memimage*	allocmemimage(Rectangle, ulong);
extern Memimage*	allocmemimaged(Rectangle, ulong, Memdata*);
extern void			freememimage(Memimage*);

extern Memimage*	readmemimage(int);
extern int			writememimage(int, Memimage*);
extern int			loadmemimage(Memimage*, Rectangle, uchar*, int);
extern int			unloadmemimage(Memimage*, Rectangle, uchar*, int);
extern Memimage*	creadmemimage(int);
extern int			cloadmemimage(Memimage*, Rectangle, uchar*, int);

extern ulong*	wordaddr(Memimage*, Point);
extern uchar*	byteaddr(Memimage*, Point);

extern int		drawclip(Memimage*, Rectangle*, Memimage*, Point*, Memimage*, Point*, Rectangle*, Rectangle*);
extern void		memfillcolor(Memimage*, ulong);
extern int		memsetchan(Memimage*, ulong);

/*
 * Graphics
 */
extern void	memimageinit(void);

// actually in memlayer
extern void	memdraw(Memimage*, Rectangle, Memimage*, Point, Memimage*, Point, int);
extern void	memimagedraw(Memimage*, Rectangle, Memimage*, Point, Memimage*, Point, int);

// actually in memlayer/
extern void	memline(Memimage*, Point, Point, int, int, int, Memimage*, Point, int);


extern void	mempoly(Memimage*, Point*, int, int, int, int, Memimage*, Point, int);
extern void	memfillpoly(Memimage*, Point*, int, int, Memimage*, Point, int);


extern void	memellipse(Memimage*, Point, int, int, int, Memimage*, Point, int);

extern void	memarc(Memimage*, Point, int, int, int, Memimage*, Point, int, int, int);

extern Point	memimagestring(Memimage*, Point, Memimage*, Point, Memsubfont*, char*);

// !!!
extern int	hwdraw(Memdrawparam*);


extern Rectangle	memlinebbox(Point, Point, int, int, int);
extern int			memlineendsize(int);
extern void			_memmkcmap(void);

/*
 * Subfont management
 */
extern Memsubfont*	allocmemsubfont(char*, int, int, int, Fontchar*, Memimage*);
extern void			freememsubfont(Memsubfont*);
extern Memsubfont*	openmemsubfont(char*);
extern Point		memsubfontwidth(Memsubfont*, char*);
extern Memsubfont*	getmemdefont(void);

/*
 * Predefined 
 */
extern	Memimage*	memwhite;
extern	Memimage*	memblack;
extern	Memimage*	memopaque;
extern	Memimage*	memtransparent;

extern	Memcmap	*memdefcmap;


// Forward decl? or should be fixed?
extern void	_memimageline(Memimage*, Point, Point, int, int, int, Memimage*, Point, Rectangle, int);
//todo: remove this one and rename the previous one
//extern void	memimageline(Memimage*, Point, Point, int, int, int, Memimage*, Point, int);

extern void	_memfillpolysc(Memimage*, Point*, int, int, Memimage*, Point, int, int, int, int);

/*
 * Kernel interface
 */
void		memimagemove(void*, void*);

/*
 * Kernel cruft
 */
extern void	rdb(void);
extern int	(*iprint)(char*, ...);
#pragma varargck argpos iprint 1

extern int		drawdebug;

/*
 * doprint interface: numbconv bit strings
 */
#pragma varargck type "llb" vlong
#pragma varargck type "llb" uvlong
#pragma varargck type "lb" long
#pragma varargck type "lb" ulong
#pragma varargck type "b" int
#pragma varargck type "b" uint

@


\subsection*{[[include/memlayer.h]]}

%-------------------------------------------------------------

<<include/memlayer.h>>=
#pragma src "/sys/src/libmemlayer"
#pragma lib "libmemlayer.a"

typedef struct Memscreen Memscreen;
typedef void (*Refreshfn)(Memimage*, Rectangle, void*);

<<struct Memscreen>>

<<struct Memlayer>>

/*
 * These functions accept local coordinates
 */
int			memload(Memimage*, Rectangle, uchar*, int, int);
int			memunload(Memimage*, Rectangle, uchar*, int);

/*
 * All these functions accept screen coordinates, not local ones.
 */

Memimage*		memlalloc(Memscreen*, Rectangle, Refreshfn, void*, ulong);
void			memlfree(Memimage*);
void			memldelete(Memimage*);

int				memlorigin(Memimage*, Point, Point);

void			memltofront(Memimage*);
void			memltofrontn(Memimage**, int);
void			memltorear(Memimage*);
void			memltorearn(Memimage**, int);
void			memlhide(Memimage*, Rectangle);
void			memlexpose(Memimage*, Rectangle);

int				memlsetrefresh(Memimage*, Refreshfn, void*);
void			memlnorefresh(Memimage*, Rectangle, void*);

void			_memlayerop(void (*fn)(Memimage*, Rectangle, Rectangle, void*, int), Memimage*, Rectangle, Rectangle, void*);

void			_memltofrontfill(Memimage*, int);
void			_memlsetclear(Memscreen*);
@


\subsection*{[[include/mouse.h]]}


%-------------------------------------------------------------

<<include/mouse.h>>=
#pragma src "/sys/src/libdraw"

typedef struct	Channel Channel;
typedef struct	Cursor Cursor;
typedef struct	Menu Menu;
typedef struct 	Mousectl Mousectl;

enum click {
    CLICK_LEFT = 1,
    CLICK_MIDDLE = 2,
    CLICK_RIGHT = 4,
};

<<struct Mouse (include/mouse.h)>>

<<struct Mousectl>>

<<struct Menu (include/mouse.h)>>

/*
 * Mouse
 */
extern Mousectl*	initmouse(char*, Image*);
extern void			closemouse(Mousectl*);

extern int			readmouse(Mousectl*);
extern void			moveto(Mousectl*, Point);
extern void			setcursor(Mousectl*, Cursor*);

extern void			drawgetrect(Rectangle, int);
extern Rectangle	getrect(int, Mousectl*);

extern int	 		menuhit(int, Mousectl*, Menu*, Screen*);
@


\section{[[lib_graphics/libdraw/]]}

\subsection*{[[lib_graphics/libdraw/alloc.c]]}

%-------------------------------------------------------------

<<lib_graphics/libdraw/alloc.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function allocimage>>

<<function _allocimage>>

<<function namedimage>>

<<function nameimage>>

<<function _freeimage1>>

<<function freeimage>>
@


\subsection*{[[lib_graphics/libdraw/allocimagemix.c]]}


%-------------------------------------------------------------

<<lib_graphics/libdraw/allocimagemix.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function allocimagemix>>
@

\subsection*{[[lib_graphics/libdraw/misc.c]]}

<<lib_graphics/libdraw/misc.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<global drawld2chan>>

<<function setalpha>>
@

\subsection*{[[lib_graphics/libdraw/arith.c]]}

%dead
%/*
% * was used by libmemlayer/line.c; made static, instead of deleting it,
% * to avoid updating many binaries on sources.
% */
%static int log2[] = { -1, 0, 1, -1, 2, -1, -1, -1, 3, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, 4 /* BUG */, -1, -1, -1, -1, -1, -1, -1, 5 };
%

%-------------------------------------------------------------

<<lib_graphics/libdraw/arith.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function Pt>>

<<function Rect>>

<<function Rpt>>

<<function addpt>>

<<function subpt>>

<<function insetrect>>

<<function divpt>>

<<function mulpt>>

<<function rectsubpt>>

<<function rectaddpt>>

<<function eqpt>>

<<function eqrect>>

<<function rectXrect>>

<<function rectinrect>>

<<function ptinrect>>

<<function canonrect>>

<<function combinerect>>


<<global ZP>>
<<global ZR>>
@


\subsection*{[[lib_graphics/libdraw/bezier.c]]}


%-------------------------------------------------------------

<<lib_graphics/libdraw/bezier.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<constant PINC>>

typedef struct Plist Plist;
<<struct Plist>>

<<function appendpt>>

<<function normsq>>

<<function psdist>>

<<function bpts1>>

<<function bpts>>

<<function bezierpts>>

<<function _bezsplinepts>>

<<function bezsplinepts>>

<<function bezier>>

<<function bezierop>>

<<function bezspline>>

<<function bezsplineop>>

<<function fillbezier>>

<<function fillbezierop>>

<<function fillbezspline>>

<<function fillbezsplineop>>
@


\subsection*{[[lib_graphics/libdraw/border.c]]}

%-------------------------------------------------------------

<<lib_graphics/libdraw/border.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function border>>
@


\subsection*{[[lib_graphics/libdraw/buildfont.c]]}

<<function skip>>=
static char*
skip(char *s)
{
    while(*s==' ' || *s=='\n' || *s=='\t')
        s++;
    return s;
}
@

<<function buildfont>>=
Font*
buildfont(Display *d, char *buf, char *name)
{
    Font *fnt;
    Cachefont *c;
    char *s, *t;
    ulong min, max;
    int offset;
    char badform[] = "bad font format: number expected (char position %d)";

    s = buf;
    fnt = malloc(sizeof(Font));
    if(fnt == 0)
        return 0;
    memset(fnt, 0, sizeof(Font));
    fnt->display = d;
    fnt->name = strdup(name);
    fnt->ncache = NFCACHE+NFLOOK;
    fnt->nsubf = NFSUBF;
    fnt->cache = malloc(fnt->ncache * sizeof(fnt->cache[0]));
    fnt->subf = malloc(fnt->nsubf * sizeof(fnt->subf[0]));
    if(fnt->name==0 || fnt->cache==0 || fnt->subf==0){
    Err2:
        free(fnt->name);
        free(fnt->cache);
        free(fnt->subf);
        free(fnt->sub);
        free(fnt);
        return 0;
    }
    fnt->height = strtol(s, &s, 0);
    s = skip(s);
    fnt->ascent = strtol(s, &s, 0);
    s = skip(s);
    if(fnt->height<=0 || fnt->ascent<=0){
        werrstr("bad height or ascent in font file");
        goto Err2;
    }
    fnt->width = 0;
    fnt->nsub = 0;
    fnt->sub = 0;

    memset(fnt->subf, 0, fnt->nsubf * sizeof(fnt->subf[0]));
    memset(fnt->cache, 0, fnt->ncache*sizeof(fnt->cache[0]));
    fnt->age = 1;
    do{
        /* must be looking at a number now */
        if(*s<'0' || '9'<*s){
            werrstr(badform, s-buf);
            goto Err3;
        }
        min = strtol(s, &s, 0);
        s = skip(s);
        /* must be looking at a number now */
        if(*s<'0' || '9'<*s){
            werrstr(badform, s-buf);
            goto Err3;
        }
        max = strtol(s, &s, 0);
        s = skip(s);
        if(*s==0 || min>=Runemax || max>=Runemax || min>max){
            werrstr("illegal subfont range");
    Err3:
            freefont(fnt);
            return 0;
        }
        t = s;
        offset = strtol(s, &t, 0);
        if(t>s && (*t==' ' || *t=='\t' || *t=='\n'))
            s = skip(t);
        else
            offset = 0;
        fnt->sub = realloc(fnt->sub, (fnt->nsub+1)*sizeof(Cachefont*));
        if(fnt->sub == 0){
            /* realloc manual says fnt->sub may have been destroyed */
            fnt->nsub = 0;
            goto Err3;
        }
        c = malloc(sizeof(Cachefont));
        if(c == 0)
            goto Err3;
        fnt->sub[fnt->nsub] = c;
        c->min = min;
        c->max = max;
        c->offset = offset;
        t = s;
        while(*s && *s!=' ' && *s!='\n' && *s!='\t')
            s++;
        *s++ = 0;
        c->subfontname = 0;
        c->name = strdup(t);
        if(c->name == 0){
            free(c);
            goto Err3;
        }
        s = skip(s);
        fnt->nsub++;
    }while(*s);
    return fnt;
}
@

<<function freefont>>=
void
freefont(Font *f)
{
    int i;
    Cachefont *c;
    Subfont *s;

    if(f == 0)
        return;

    for(i=0; i<f->nsub; i++){
        c = f->sub[i];
        free(c->subfontname);
        free(c->name);
        free(c);
    }
    for(i=0; i<f->nsubf; i++){
        s = f->subf[i].f;
        if(s && display && s!=display->defaultsubfont)
            freesubfont(s);
    }
    freeimage(f->cacheimage);
    free(f->name);
    free(f->cache);
    free(f->subf);
    free(f->sub);
    free(f);
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/buildfont.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function skip>>

<<function buildfont>>

<<function freefont>>
@


\subsection*{[[lib_graphics/libdraw/bytesperline.c]]}


%-------------------------------------------------------------

<<lib_graphics/libdraw/bytesperline.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function unitsperline>>

<<function wordsperline>>

<<function bytesperline>>
@


\subsection*{[[lib_graphics/libdraw/chan.c]]}


%-------------------------------------------------------------

<<lib_graphics/libdraw/chan.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<global channames>>
<<function chantostr>>

<<function isspace>>

<<function strtochan>>

<<function chantodepth>>
@


\subsection*{[[lib_graphics/libdraw/cloadimage.c]]}


%-------------------------------------------------------------

<<lib_graphics/libdraw/cloadimage.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function cloadimage>>
@


\subsection*{[[lib_graphics/libdraw/computil.c]]}


%-------------------------------------------------------------

<<lib_graphics/libdraw/computil.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function _twiddlecompressed>>

<<function _compblocksize>>
@


\subsection*{[[lib_graphics/libdraw/creadimage.c]]}


%-------------------------------------------------------------

<<lib_graphics/libdraw/creadimage.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function creadimage>>
@


\subsection*{[[lib_graphics/libdraw/debug.c]]}


%-------------------------------------------------------------

<<lib_graphics/libdraw/debug.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function drawsetdebug>>
@


\subsection*{[[lib_graphics/libdraw/defont.c]]}

<<global defontdata>>=
/*
 * lucm/latin1.9, in uncompressed form
 */
uchar
defontdata[] =
{
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x30,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x30,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x30,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x32,0x33,0x30,0x34,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x31,0x35,0x20,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x30,0x06,0x06,0x03,0x42,0x40,0x00,0x00,0x00,0x18,0x03,0x03,
0x02,0x43,0x00,0x60,0x60,0x48,0x00,0x0d,0x0c,0x01,0x81,0x80,0xd0,0x90,0x00,0x00,
0x18,0x01,0x81,0x81,0x40,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x7f,0x9c,0x1c,
0x0e,0x07,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xe0,0x70,
0x38,0x1c,0x0e,0x04,0x81,0xc1,0xc0,0x70,0x00,0x1c,0x1c,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xaa,0x80,0xc0,0x63,0xe3,
0xf1,0xf8,0xfe,0x7f,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,0x7f,0xff,0xff,0x1f,0x8f,
0xc7,0xe3,0xf1,0xfb,0x7e,0x3e,0x3f,0x8f,0xff,0xe3,0xe3,0xff,0xff,0xff,0xff,0xff,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x0c,0x18,0x09,0x05,0x82,0x40,0xc0,0x00,0x00,0x06,0x0c,0x04,
0x82,0x40,0xc1,0x80,0x90,0x48,0x00,0x16,0x03,0x06,0x02,0x41,0x60,0x90,0x00,0x00,
0x06,0x06,0x02,0x41,0x41,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3e,0x7f,0xa0,0x10,
0x08,0x04,0x02,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x90,0x48,
0x24,0x12,0x09,0x06,0x82,0x01,0x00,0x90,0x00,0x20,0x10,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x04,0x80,0x00,0x40,0x00,0x00,0x38,0x06,0x18,0x00,0x00,0x00,0x00,0x00,
0x00,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x07,0xc6,0x01,0xf0,0x00,0x00,0x0c,0x00,0x18,0x00,0x00,0x30,0x00,0x3c,
0x00,0x60,0x06,0x01,0x8c,0x07,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xe0,0xc3,0xc0,0x01,0x54,0x9c,0xc0,0x5f,0xef,
0xf7,0xfb,0xfd,0xbf,0xff,0xff,0xff,0xff,0xff,0xff,0xfb,0x7f,0xff,0xff,0x6f,0xb7,
0xdb,0xed,0xf6,0xf9,0x7d,0xfe,0xff,0x6f,0xff,0xdf,0xef,0xff,0xff,0xff,0xff,0xff,
0xff,0x00,0x01,0x00,0x00,0x00,0x00,0x30,0x00,0x14,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x38,0x00,0x00,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x20,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x30,0x06,0x06,0x06,0x82,0x80,0xc0,0x00,
0x00,0x18,0x03,0x03,0x02,0x41,0x80,0x30,0x30,0x24,0x76,0x0d,0x0c,0x00,0xc0,0xc0,
0xd0,0x50,0x00,0x00,0x18,0x01,0x81,0x81,0x40,0x30,0x00,0x28,0x0f,0x7f,0xbc,0x1c,
0x0e,0x07,0x03,0xc0,0x10,0x70,0x24,0x10,0x09,0x07,0x03,0x80,0xe0,0x70,0x90,0x48,
0x24,0x12,0x09,0x05,0x81,0x81,0xc0,0x80,0x70,0x18,0x1c,0x07,0x01,0xc1,0xc0,0x90,
0x00,0x0c,0x04,0x84,0x83,0xe1,0xc0,0xe0,0x38,0x0c,0x0c,0x02,0x00,0x00,0x00,0x00,
0x00,0x06,0x1c,0x06,0x0f,0x87,0xc0,0x63,0xf8,0x78,0xfe,0x3e,0x0e,0x00,0x00,0x00,
0x00,0x00,0x00,0x7c,0x1c,0x0c,0x1f,0x03,0xc7,0xc3,0xf1,0xf8,0x3c,0x63,0x3f,0x0f,
0x8c,0x66,0x06,0x19,0x84,0x78,0x7e,0x1e,0x1f,0x07,0xcf,0xf3,0x1b,0x0d,0x86,0x63,
0x61,0x9f,0xc6,0x06,0x00,0x30,0x00,0x00,0x10,0x00,0x18,0x00,0x00,0x30,0x00,0x60,
0x00,0x60,0x06,0x01,0x8c,0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,
0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0xc0,0x60,0x00,0xaa,0xb6,0xc0,0x43,0xe3,
0xf1,0xf8,0xfc,0x3f,0xef,0x8f,0xdb,0xef,0xf6,0xf8,0xfb,0xff,0x1f,0x8f,0x6f,0xb7,
0xdb,0xed,0xf6,0xfa,0x7e,0x7e,0x3f,0x7f,0x8f,0xe7,0xe3,0xf8,0xfe,0x3e,0x3f,0x6f,
0x00,0x00,0x01,0x01,0xc8,0x0b,0x0c,0x30,0x7c,0x14,0x0f,0x0f,0x00,0x00,0x00,0x00,
0x78,0x00,0x1c,0x00,0x0f,0x07,0x81,0x80,0x00,0x7c,0x00,0x00,0x1c,0x0f,0x80,0x04,
0x42,0x23,0x90,0x00,0x18,0x0c,0x06,0x03,0x01,0x80,0xc0,0x3c,0x3c,0x3f,0x1f,0x8f,
0xc7,0xe7,0xe3,0xf1,0xf8,0xfc,0x7c,0x30,0x8f,0x07,0x83,0xc1,0xe0,0xf0,0x00,0x3d,
0x31,0x98,0xcc,0x66,0x36,0x19,0x80,0xcc,0x0c,0x18,0x09,0x0b,0x02,0x81,0x20,0x00,
0x00,0x06,0x0c,0x04,0x82,0x40,0x60,0xc0,0x48,0x24,0x18,0x16,0x03,0x03,0x01,0x21,
0x60,0x50,0x00,0x00,0x06,0x06,0x02,0x41,0x40,0xc1,0x80,0x28,0x87,0x7f,0x84,0x10,
0x08,0x04,0x02,0x40,0x38,0x48,0x24,0x10,0x09,0x04,0x04,0x81,0x00,0x80,0x90,0x48,
0x24,0x12,0x09,0x04,0x80,0x41,0x00,0x80,0x40,0x04,0x10,0x04,0x02,0x01,0x20,0x90,
0x00,0x0c,0x04,0x84,0x86,0x53,0x65,0xb0,0x08,0x18,0x06,0x0a,0x80,0x00,0x00,0x00,
0x00,0x0c,0x36,0x0e,0x19,0xcc,0xe0,0xe3,0xf8,0xcc,0xfe,0x63,0x1b,0x00,0x00,0x00,
0x00,0x00,0x00,0xc6,0x62,0x0c,0x19,0x86,0x66,0x63,0x01,0x80,0x66,0x63,0x0c,0x01,
0x8c,0xc6,0x06,0x19,0xc4,0xcc,0x63,0x33,0x19,0x8c,0x61,0x83,0x1b,0x0d,0x86,0x63,
0x61,0x80,0xc6,0x03,0x00,0x30,0x30,0x00,0x1c,0x00,0x18,0x00,0x00,0x30,0x00,0x60,
0x00,0x60,0x00,0x00,0x0c,0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,
0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0xc0,0x60,0x01,0x54,0x86,0xc0,0x7b,0xef,
0xf7,0xfb,0xfd,0xbf,0xc7,0xb7,0xdb,0xef,0xf6,0xfb,0xfb,0x7e,0xff,0x7f,0x6f,0xb7,
0xdb,0xed,0xf6,0xfb,0x7f,0xbe,0xff,0x7f,0xbf,0xfb,0xef,0xfb,0xfd,0xfe,0xdf,0x6f,
0xff,0x00,0x07,0x83,0x24,0x13,0x0c,0x30,0xc6,0x00,0x10,0x81,0x80,0x00,0x00,0x00,
0x84,0x00,0x22,0x00,0x01,0x80,0xc0,0x00,0x00,0xf4,0x00,0x00,0x2c,0x18,0xc0,0x0c,
0x46,0x20,0x90,0x00,0x18,0x0c,0x06,0x03,0x01,0x80,0xc0,0x70,0x66,0x30,0x18,0x0c,
0x06,0x01,0x80,0xc0,0x60,0x30,0x66,0x38,0x99,0x8c,0xc6,0x63,0x31,0x98,0x00,0x66,
0x31,0x98,0xcc,0x66,0x36,0x19,0x80,0xcc,0x00,0x00,0x00,0x00,0x00,0x00,0xc0,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x6c,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x00,0xff,0x7f,0xb8,0x1c,
0x0e,0x07,0x02,0x40,0x7c,0x70,0x3c,0x10,0x09,0x07,0x04,0x00,0xc0,0x60,0xe0,0x70,
0x38,0x1c,0x0e,0x04,0x83,0x81,0xc0,0x70,0x70,0x38,0x1c,0x07,0x02,0xc1,0xc0,0x90,
0x00,0x0c,0x00,0x04,0x86,0x43,0x69,0xb0,0x30,0x18,0x06,0x07,0x01,0x00,0x00,0x00,
0x00,0x0c,0x63,0x16,0x00,0xc0,0x61,0x62,0x01,0x80,0x06,0x63,0x31,0x80,0x00,0x00,
0x60,0x00,0xc0,0x06,0x43,0x16,0x19,0x8c,0x06,0x33,0x01,0x80,0xc0,0x63,0x0c,0x01,
0x8c,0x86,0x07,0x39,0xc5,0x86,0x63,0x61,0x99,0x8c,0x01,0x83,0x1b,0x0d,0xb6,0x63,
0x31,0x01,0x86,0x03,0x00,0x30,0x30,0x00,0x1c,0x3e,0x1b,0x03,0xc1,0xf0,0xf0,0x60,
0x3e,0x6e,0x3e,0x0f,0x8c,0x60,0xc5,0xb1,0xb8,0x38,0x6c,0x0f,0x8c,0xc7,0xc1,0x83,
0x19,0x8d,0x82,0x63,0x31,0x9f,0xc1,0x80,0xc0,0xc0,0x00,0xaa,0x86,0xc0,0x47,0xe3,
0xf1,0xf8,0xfd,0xbf,0x83,0x8f,0xc3,0xef,0xf6,0xf8,0xfc,0xff,0x3f,0x9f,0x1f,0x8f,
0xc7,0xe3,0xf1,0xfb,0x7c,0x7e,0x3f,0x8f,0x8f,0xc7,0xe3,0xf8,0xfd,0x3e,0x3f,0x6f,
0x00,0x0c,0x0d,0x43,0x03,0xe1,0x88,0x30,0xc0,0x00,0x27,0x41,0x80,0x00,0x00,0x01,
0x72,0x00,0x22,0x04,0x01,0x80,0xc0,0x03,0x18,0xf4,0x00,0x00,0x0c,0x18,0xc0,0x04,
0x82,0x43,0x20,0x18,0x2c,0x16,0x0b,0x05,0x82,0xc1,0x60,0xb0,0xc0,0x30,0x18,0x0c,
0x06,0x01,0x80,0xc0,0x60,0x30,0x63,0x38,0xb0,0xd8,0x6c,0x36,0x1b,0x0c,0x00,0xc7,
0x31,0x98,0xcc,0x66,0x33,0x11,0xf8,0xc8,0x7c,0x3e,0x1f,0x0f,0x87,0xc3,0xe1,0xd8,
0x3c,0x1e,0x0f,0x07,0x83,0xc7,0xc3,0xe1,0xf0,0xf8,0x06,0x37,0x07,0x03,0x81,0xc0,
0xe0,0x70,0x10,0x1d,0x31,0x98,0xcc,0x66,0x33,0x19,0xb0,0xc6,0x8f,0x7f,0x87,0x03,
0x81,0x80,0x90,0x30,0x6c,0x48,0x24,0x10,0x06,0x04,0x04,0x80,0x20,0x10,0x10,0x0e,
0x07,0x03,0x81,0xc0,0x60,0x88,0x38,0x0c,0x40,0x09,0x03,0x84,0x02,0x41,0x40,0x90,
0x00,0x0c,0x00,0x1f,0xe7,0x41,0xd1,0xa0,0x00,0x30,0x03,0x0a,0x81,0x00,0x00,0x00,
0x00,0x18,0x63,0x06,0x00,0xc0,0xc2,0x62,0x01,0xb0,0x0c,0x72,0x31,0x86,0x03,0x00,
0xc0,0x00,0x60,0x06,0x8f,0x16,0x19,0x0c,0x06,0x33,0x01,0x80,0xc0,0x63,0x0c,0x01,
0x8d,0x06,0x07,0x39,0x65,0x86,0x63,0x61,0x99,0x0e,0x01,0x83,0x19,0x89,0xb6,0x32,
0x33,0x03,0x06,0x01,0x80,0x30,0x78,0x00,0x00,0x03,0x1d,0x86,0x23,0x31,0x99,0xfc,
0x66,0x77,0x06,0x01,0x8c,0x40,0xc6,0xd9,0xdc,0x6c,0x76,0x19,0x8d,0xcc,0x27,0xf3,
0x19,0x8d,0x82,0x63,0x31,0x80,0xc0,0x80,0xc0,0x80,0x01,0x54,0x8c,0xc0,0x78,0xfc,
0x7e,0x7f,0x6f,0xcf,0x93,0xb7,0xdb,0xef,0xf9,0xfb,0xff,0xff,0xdf,0xef,0xef,0xf1,
0xf8,0xfc,0x7e,0x3f,0x9f,0x77,0xc7,0xf3,0xbf,0xf6,0xfc,0x7b,0xfd,0xbe,0xbf,0x6f,
0xff,0x0c,0x19,0x03,0x03,0x61,0x98,0x30,0x78,0x00,0x28,0x4f,0x83,0x30,0x00,0x01,
0x4a,0x00,0x1c,0x04,0x03,0x03,0x80,0x03,0x18,0xf4,0x00,0x00,0x0c,0x18,0xd9,0x84,
0x82,0x40,0xa0,0x18,0x2c,0x16,0x0b,0x05,0x82,0xc1,0x60,0xb0,0xc0,0x30,0x18,0x0c,
0x06,0x01,0x80,0xc0,0x60,0x30,0x63,0x2c,0xb0,0xd8,0x6c,0x36,0x1b,0x0c,0x64,0xcb,
0x31,0x98,0xcc,0x66,0x33,0x31,0x8c,0xd8,0x06,0x03,0x01,0x80,0xc0,0x60,0x30,0x6c,
0x62,0x33,0x19,0x8c,0xc6,0x60,0xc0,0x60,0x30,0x18,0x1e,0x3b,0x8d,0x86,0xc3,0x61,
0xb0,0xd8,0x10,0x36,0x31,0x98,0xcc,0x66,0x33,0x19,0xd8,0xc6,0x0f,0x7f,0x82,0x01,
0x02,0x40,0xd0,0x40,0x6c,0x70,0x24,0x1c,0x06,0x04,0x03,0x01,0xc0,0xe0,0x10,0x12,
0x09,0x04,0x82,0x40,0x90,0x50,0x10,0x12,0x70,0x09,0x04,0x04,0x01,0xc1,0x20,0x60,
0x00,0x0c,0x00,0x04,0x83,0xc0,0x20,0xcc,0x00,0x30,0x03,0x02,0x01,0x00,0x00,0x00,
0x00,0x18,0x63,0x06,0x01,0x83,0x84,0x63,0xf1,0xd8,0x18,0x3c,0x31,0x86,0x03,0x01,
0x83,0xf8,0x30,0x1c,0x9b,0x33,0x1e,0x0c,0x06,0x33,0xe1,0x80,0xc0,0x7f,0x0c,0x01,
0x8f,0x06,0x07,0x79,0x65,0x86,0x66,0x61,0x9e,0x07,0x81,0x83,0x19,0x89,0xb6,0x1c,
0x1a,0x03,0x06,0x01,0x80,0x30,0x48,0x00,0x00,0x03,0x18,0xcc,0x06,0x33,0x18,0x60,
0xc6,0x63,0x06,0x01,0x8c,0x80,0xc6,0xd9,0x8c,0xc6,0x63,0x31,0x8e,0x4c,0x01,0x83,
0x19,0x8d,0x92,0x32,0x31,0x81,0x87,0x00,0xc0,0x70,0xe4,0xaa,0x98,0xc0,0x7d,0xfe,
0xfd,0xbf,0x2f,0xbf,0x93,0x8f,0xdb,0xe3,0xf9,0xfb,0xff,0x1e,0x3f,0x1f,0xef,0xed,
0xf6,0xfb,0x7d,0xbf,0x6f,0xaf,0xef,0xed,0x8f,0xf6,0xfb,0xfb,0xfe,0x3e,0xdf,0x9f,
0x00,0x00,0x19,0x0f,0xc6,0x30,0xd0,0x00,0xcc,0x00,0x28,0x59,0x86,0x67,0xf0,0x01,
0x72,0x00,0x00,0x3f,0x86,0x00,0xc0,0x03,0x18,0xf4,0x00,0x00,0x0c,0x18,0xcc,0xc5,
0x32,0x83,0x4c,0x00,0x66,0x33,0x19,0x8c,0xc6,0x63,0x31,0xbc,0xc0,0x3e,0x1f,0x0f,
0x87,0xc1,0x80,0xc0,0x60,0x30,0xfb,0x2c,0xb0,0xd8,0x6c,0x36,0x1b,0x0c,0x38,0xcb,
0x31,0x98,0xcc,0x66,0x31,0xa1,0x8c,0xcc,0x06,0x03,0x01,0x80,0xc0,0x60,0x30,0x6c,
0xc0,0x63,0x31,0x98,0xcc,0x60,0xc0,0x60,0x30,0x18,0x37,0x31,0x98,0xcc,0x66,0x33,
0x19,0x8c,0x00,0x67,0x31,0x98,0xcc,0x66,0x33,0x19,0x8c,0xc6,0x1f,0x7f,0x82,0x01,
0x02,0x40,0xb0,0x40,0x6c,0x07,0x03,0x83,0x80,0xe0,0xe0,0x00,0x18,0x0e,0x10,0x10,
0x08,0x04,0x02,0x00,0xf0,0x20,0x10,0x1e,0x08,0x89,0x03,0x00,0xe0,0x38,0x1c,0x0e,
0x00,0x0c,0x00,0x04,0x81,0xe0,0x41,0x6c,0x00,0x30,0x03,0x00,0x0f,0xe0,0x03,0xf8,
0x00,0x30,0x63,0x06,0x03,0x00,0xc7,0xf0,0x39,0x8c,0x30,0x3e,0x1b,0x80,0x00,0x03,
0x00,0x00,0x18,0x30,0x9b,0x23,0x19,0x0c,0x06,0x33,0x01,0xf8,0xc6,0x63,0x0c,0x01,
0x8d,0x86,0x05,0xd9,0x35,0x86,0x7c,0x61,0x9b,0x01,0xc1,0x83,0x19,0x99,0xb4,0x1c,
0x0c,0x06,0x06,0x00,0xc0,0x30,0xcc,0x00,0x00,0x3f,0x18,0xcc,0x06,0x33,0xf8,0x60,
0xc6,0x63,0x06,0x01,0x8f,0x00,0xc6,0xd9,0x8c,0xc6,0x63,0x31,0x8c,0x0f,0x81,0x83,
0x18,0xd9,0xba,0x1c,0x1b,0x03,0x00,0x80,0xc0,0x81,0x75,0x54,0x98,0xc0,0x7d,0xfe,
0xfd,0xbf,0x4f,0xbf,0x93,0xf8,0xfc,0x7c,0x7f,0x1f,0x1f,0x6f,0xe7,0xf1,0xef,0xef,
0xf7,0xfb,0xfd,0xff,0x0f,0xdf,0xef,0xe1,0xf7,0x76,0xfc,0xff,0x1f,0xc7,0xe3,0xf1,
0xff,0x08,0x19,0x03,0x06,0x31,0xf8,0x00,0xc6,0x00,0x28,0x5b,0x8c,0xc0,0x11,0xf1,
0x4a,0x00,0x00,0x04,0x0c,0x00,0xc0,0x03,0x18,0x74,0x38,0x00,0x0c,0x18,0xc6,0x65,
0x52,0xb8,0x54,0x18,0x46,0x23,0x11,0x88,0xc4,0x62,0x31,0x30,0xc0,0x30,0x18,0x0c,
0x06,0x01,0x80,0xc0,0x60,0x30,0x63,0x26,0xb0,0xd8,0x6c,0x36,0x1b,0x0c,0x10,0xd3,
0x31,0x98,0xcc,0x66,0x30,0xc1,0x8c,0xc6,0x7e,0x3f,0x1f,0x8f,0xc7,0xe3,0xf1,0xfc,
0xc0,0x7f,0x3f,0x9f,0xcf,0xe0,0xc0,0x60,0x30,0x18,0x63,0x31,0x98,0xcc,0x66,0x33,
0x19,0x8c,0xfe,0x6b,0x31,0x98,0xcc,0x66,0x31,0xb1,0x8c,0x6c,0x0e,0x7f,0x82,0x01,
0x01,0x80,0x90,0x30,0xc6,0x08,0x01,0x02,0x00,0x40,0x80,0xe0,0x24,0x04,0x1c,0x10,
0x08,0x04,0x02,0x00,0x90,0x20,0x10,0x12,0x0d,0x86,0x00,0x81,0x00,0x40,0x20,0x10,
0x00,0x04,0x00,0x1f,0xe1,0x70,0xbb,0x28,0x00,0x30,0x03,0x00,0x01,0x00,0x00,0x00,
0x00,0x30,0x63,0x06,0x06,0x00,0x67,0xf0,0x19,0x8c,0x30,0x67,0x0d,0x80,0x00,0x01,
0x83,0xf8,0x30,0x30,0x9b,0x7f,0x19,0x8c,0x06,0x33,0x01,0x80,0xc6,0x63,0x0c,0x01,
0x8c,0xc6,0x05,0xd9,0x35,0x86,0x60,0x61,0x99,0x80,0xe1,0x83,0x18,0xd0,0xdc,0x26,
0x0c,0x0c,0x06,0x00,0xc0,0x30,0x84,0x00,0x00,0x63,0x18,0xcc,0x06,0x33,0x00,0x60,
0xc6,0x63,0x06,0x01,0x8d,0x80,0xc6,0xd9,0x8c,0xc6,0x63,0x31,0x8c,0x03,0xe1,0x83,
0x18,0xd9,0xba,0x1c,0x1b,0x06,0x01,0x80,0xc0,0xc1,0x38,0xaa,0x80,0xc0,0x7d,0xfe,
0xfe,0x7f,0x6f,0xcf,0x39,0xf7,0xfe,0xfd,0xff,0xbf,0x7f,0x0f,0xdb,0xfb,0xe3,0xef,
0xf7,0xfb,0xfd,0xff,0x6f,0xdf,0xef,0xed,0xf2,0x79,0xff,0x7e,0xff,0xbf,0xdf,0xef,
0x00,0x0c,0x19,0x03,0x03,0x60,0x60,0x30,0x66,0x00,0x28,0x4d,0xc6,0x60,0x10,0x00,
0x84,0x00,0x00,0x04,0x0f,0x87,0x80,0x03,0x18,0x14,0x38,0x00,0x3f,0x0f,0x8c,0xc2,
0x90,0x84,0xa4,0x18,0xfe,0x7f,0x3f,0x9f,0xcf,0xe7,0xf1,0xf0,0xc0,0x30,0x18,0x0c,
0x06,0x01,0x80,0xc0,0x60,0x30,0x63,0x26,0xb0,0xd8,0x6c,0x36,0x1b,0x0c,0x38,0xd3,
0x31,0x98,0xcc,0x66,0x30,0xc1,0x98,0xc6,0xc6,0x63,0x31,0x98,0xcc,0x66,0x33,0x60,
0xc0,0x60,0x30,0x18,0x0c,0x00,0xc0,0x60,0x30,0x18,0x63,0x31,0x98,0xcc,0x66,0x33,
0x19,0x8c,0x00,0x6b,0x31,0x98,0xcc,0x66,0x31,0xb1,0x8c,0x6c,0x1c,0x7f,0x81,0x20,
0x90,0x38,0x18,0x0b,0x83,0x06,0x01,0x03,0x80,0x40,0xe0,0x90,0x24,0x04,0x03,0x8e,
0x86,0xc3,0x61,0x90,0x24,0x12,0x0e,0x04,0x8a,0x81,0xc7,0x70,0xc0,0x30,0x18,0x0c,
0x00,0x00,0x00,0x04,0x81,0x31,0x6f,0x30,0x00,0x18,0x06,0x00,0x01,0x00,0x00,0x00,
0x00,0x60,0x63,0x06,0x0c,0x00,0x60,0x60,0x19,0x8c,0x60,0x63,0x01,0x80,0x00,0x00,
0xc0,0x00,0x60,0x00,0x4d,0xe1,0x99,0x8c,0x06,0x33,0x01,0x80,0xc6,0x63,0x0c,0x01,
0x8c,0xc6,0x04,0x99,0x1d,0x86,0x60,0x61,0x99,0x80,0x61,0x83,0x18,0xd0,0xdc,0x63,
0x0c,0x0c,0x06,0x00,0x60,0x30,0x84,0x00,0x00,0x63,0x18,0xcc,0x06,0x33,0x00,0x60,
0x6e,0x63,0x06,0x01,0x8c,0xc0,0xc6,0xd9,0x8c,0xc6,0x63,0x31,0x8c,0x00,0x61,0x83,
0x18,0xd0,0xcc,0x26,0x0e,0x0c,0x03,0x00,0xc0,0x60,0x01,0x54,0x98,0xc0,0x7e,0xdf,
0x6f,0xc7,0xe7,0xf4,0x7c,0xf9,0xfe,0xfc,0x7f,0xbf,0x1f,0x5f,0xdb,0xfb,0xfc,0x71,
0x79,0x3c,0x9e,0x6f,0xdb,0xed,0xf1,0xfb,0x75,0x7e,0x38,0x8f,0x3f,0xcf,0xe7,0xf3,
0xff,0x0c,0x0d,0x03,0x03,0xe1,0xf8,0x30,0x3c,0x00,0x27,0x40,0x03,0x30,0x00,0x00,
0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x18,0x14,0x00,0x00,0x00,0x00,0x19,0x82,
0xf8,0x98,0xbe,0x70,0xc3,0x61,0xb0,0xd8,0x6c,0x36,0x1b,0x30,0xc0,0x30,0x18,0x0c,
0x06,0x01,0x80,0xc0,0x60,0x30,0x63,0x23,0xb0,0xd8,0x6c,0x36,0x1b,0x0c,0x4c,0xe3,
0x31,0x98,0xcc,0x66,0x30,0xc1,0xf0,0xc6,0xc6,0x63,0x31,0x98,0xcc,0x66,0x33,0x60,
0xc0,0x60,0x30,0x18,0x0c,0x00,0xc0,0x60,0x30,0x18,0x63,0x31,0x98,0xcc,0x66,0x33,
0x19,0x8c,0x10,0x73,0x31,0x98,0xcc,0x66,0x30,0xe1,0x8c,0x38,0x1c,0x7f,0x80,0xa0,
0x50,0x10,0x24,0x0d,0xff,0x01,0x01,0x02,0x00,0x40,0x80,0xf0,0x24,0x04,0x02,0x01,
0x81,0x20,0x10,0x30,0x28,0x1a,0x09,0x06,0x8a,0x81,0x20,0x90,0x20,0x08,0x04,0x02,
0x00,0x0c,0x00,0x04,0x85,0x32,0x6f,0xb8,0x00,0x18,0x06,0x00,0x01,0x01,0xc0,0x00,
0x70,0x60,0x36,0x06,0x1f,0xcc,0xe0,0x63,0x30,0xd8,0x60,0x63,0x33,0x06,0x03,0x00,
0x60,0x00,0xc0,0x30,0x60,0x61,0x99,0x86,0x66,0x63,0x01,0x80,0x66,0x63,0x0c,0x03,
0x0c,0x66,0x04,0x19,0x1c,0xcc,0x60,0x33,0x18,0xcc,0x61,0x81,0xb0,0x60,0xcc,0x63,
0x0c,0x18,0x06,0x00,0x60,0x30,0x00,0x00,0x00,0x67,0x19,0x86,0x23,0x71,0x88,0x60,
0x36,0x63,0x06,0x01,0x8c,0x60,0xc6,0xd9,0x8c,0x6c,0x66,0x1b,0x8c,0x08,0x61,0x83,
0xb8,0x70,0xcc,0x63,0x0c,0x18,0x03,0x00,0xc0,0x60,0x00,0xaa,0x98,0xc0,0x7f,0x5f,
0xaf,0xef,0xdb,0xf2,0x00,0xfe,0xfe,0xfd,0xff,0xbf,0x7f,0x6f,0xdb,0xfb,0xfd,0xfe,
0x7e,0xdf,0xef,0xcf,0xd7,0xe5,0xf6,0xf9,0x75,0x7e,0xdf,0x6f,0xdf,0xf7,0xfb,0xfd,
0x00,0x0c,0x07,0xc6,0x04,0x10,0x60,0x30,0x06,0x00,0x10,0x80,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x3f,0x80,0x00,0x00,0x03,0xb8,0x14,0x00,0x00,0x00,0x00,0x00,0x04,
0x11,0x21,0x04,0xc0,0xc3,0x61,0xb0,0xd8,0x6c,0x36,0x1b,0x30,0x66,0x30,0x18,0x0c,
0x06,0x01,0x80,0xc0,0x60,0x30,0x66,0x23,0x99,0x8c,0xc6,0x63,0x31,0x98,0x00,0x66,
0x1b,0x0d,0x86,0xc3,0x60,0xc1,0x80,0xc6,0xce,0x67,0x33,0x99,0xcc,0xe6,0x73,0x74,
0x62,0x31,0x18,0x8c,0x46,0x20,0xc0,0x60,0x30,0x18,0x36,0x31,0x8d,0x86,0xc3,0x61,
0xb0,0xd8,0x10,0x36,0x3b,0x9d,0xce,0xe7,0x70,0xc1,0x98,0x30,0x00,0x7f,0x80,0xc0,
0x60,0x10,0x24,0x0c,0x38,0x0e,0x01,0x02,0x00,0x40,0x80,0xa0,0x18,0x0e,0x03,0x00,
0x80,0x40,0x60,0x50,0x30,0x16,0x0e,0x05,0x88,0x81,0xc0,0x81,0xc0,0x70,0x38,0x1c,
0x00,0x0c,0x00,0x04,0x83,0xe0,0x39,0xcc,0x00,0x0c,0x0c,0x00,0x00,0x01,0xc0,0x00,
0x70,0xc0,0x1c,0x06,0x1f,0xc7,0xc0,0x61,0xe0,0x70,0x60,0x3e,0x1e,0x06,0x03,0x00,
0x00,0x00,0x00,0x30,0x1e,0x61,0x9f,0x03,0xc7,0xc3,0xf1,0x80,0x3e,0x63,0x3f,0x1e,
0x0c,0x67,0xe4,0x19,0x0c,0x78,0x60,0x1e,0x18,0xc7,0xc1,0x80,0xe0,0x60,0xcc,0x63,
0x0c,0x1f,0xc6,0x00,0x30,0x30,0x00,0x00,0x00,0x3b,0x9f,0x03,0xc1,0xb0,0xf0,0x60,
0x06,0x63,0x06,0x01,0x8c,0x70,0xc6,0xd9,0x8c,0x38,0x7c,0x0d,0x8c,0x07,0xc0,0xf1,
0xd8,0x60,0xcc,0x63,0x0c,0x1f,0xc3,0x00,0xc0,0x60,0x01,0x54,0x80,0xc0,0x7f,0x3f,
0x9f,0xef,0xdb,0xf3,0xc7,0xf1,0xfe,0xfd,0xff,0xbf,0x7f,0xff,0xe7,0xf1,0xfc,0xff,
0x7f,0xbf,0x9f,0xaf,0xcf,0xe9,0xf1,0xfa,0x77,0x7e,0x3f,0x7e,0x3f,0x8f,0xc7,0xe3,
0xff,0x0c,0x01,0x0f,0xe8,0x08,0x60,0x30,0xc6,0x00,0x0f,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xd8,0x14,0x00,0x00,0x00,0x00,0x00,0x04,
0x11,0x3d,0x04,0xc0,0xc3,0x61,0xb0,0xd8,0x6c,0x36,0x1b,0x3c,0x3c,0x3f,0x1f,0x8f,
0xc7,0xe7,0xe3,0xf1,0xf8,0xfc,0x7c,0x21,0x8f,0x07,0x83,0xc1,0xe0,0xf0,0x00,0xbc,
0x0e,0x07,0x03,0x81,0xc0,0xc1,0x80,0xcc,0x77,0x3b,0x9d,0xce,0xe7,0x73,0xb9,0x98,
0x3c,0x1e,0x0f,0x07,0x83,0xc0,0xc0,0x60,0x30,0x18,0x1c,0x31,0x87,0x03,0x81,0xc0,
0xe0,0x70,0x00,0x5c,0x1d,0x8e,0xc7,0x63,0xb0,0xc1,0xf0,0x30,0x00,0x7f,0x81,0x40,
0xa0,0x10,0x28,0x0a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x90,0x00,0x00,0x02,0x00,
0x80,0x80,0x10,0xf8,0x28,0x12,0x09,0x04,0x80,0x01,0x20,0x80,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x06,0x18,0x00,0x00,0x00,0x40,0x00,
0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x07,0xc0,0x31,0xf0,0x01,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xcc,0x00,0x00,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x60,0x01,0x80,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x18,0x00,0x01,0xe0,0xc3,0xc0,0x00,0x00,0xff,0xc0,0x7e,0xbf,
0x5f,0xef,0xd7,0xf5,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfd,0xff,
0x7f,0x7f,0xef,0x07,0xd7,0xed,0xf6,0xfb,0x7f,0xfe,0xdf,0x7f,0xff,0xff,0xff,0xff,
0x00,0x0c,0x01,0x00,0x00,0x00,0x00,0x30,0x7c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x14,0x00,0x08,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0xc6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x81,0x80,0x60,0x00,0x7f,0x81,0x20,
0x90,0x10,0x1c,0x0a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x80,
0x81,0xe0,0x60,0x10,0x24,0x12,0x0e,0x04,0x80,0x01,0xc0,0x70,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x78,0x00,0x00,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x01,0x80,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7f,0xfe,0xdf,
0x6f,0xef,0xe3,0xf5,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,0x7f,
0x7e,0x1f,0x9f,0xef,0xdb,0xed,0xf1,0xfb,0x7f,0xfe,0x3f,0x8f,0xff,0xff,0xff,0xff,
0x00,0x0c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x7c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x81,0x80,0x60,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x32,0x35,0x36,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x31,0x35,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x31,0x33,0x20,
0x00,0x00,0x01,0x0c,0x00,0x09,0x09,0x00,0x01,0x0f,0x00,0x09,0x12,0x00,0x01,0x0f,
0x00,0x09,0x1b,0x00,0x01,0x0f,0x00,0x09,0x24,0x00,0x01,0x0f,0x00,0x09,0x2d,0x00,
0x01,0x0f,0x00,0x09,0x36,0x00,0x01,0x0f,0x00,0x09,0x3f,0x00,0x03,0x0d,0x00,0x09,
0x48,0x00,0x03,0x0d,0x00,0x09,0x51,0x00,0x03,0x0d,0x00,0x09,0x5a,0x00,0x03,0x0d,
0x00,0x09,0x63,0x00,0x03,0x0d,0x00,0x09,0x6c,0x00,0x03,0x0d,0x00,0x09,0x75,0x00,
0x03,0x0e,0x00,0x09,0x7e,0x00,0x03,0x0d,0x00,0x09,0x87,0x00,0x03,0x0d,0x00,0x09,
0x90,0x00,0x01,0x0f,0x00,0x09,0x99,0x00,0x01,0x0f,0x00,0x09,0xa2,0x00,0x01,0x0f,
0x00,0x09,0xab,0x00,0x01,0x0f,0x00,0x09,0xb4,0x00,0x01,0x0f,0x00,0x09,0xbd,0x00,
0x01,0x0f,0x00,0x09,0xc6,0x00,0x01,0x0f,0x00,0x09,0xcf,0x00,0x01,0x0f,0x00,0x09,
0xd8,0x00,0x01,0x0f,0x00,0x09,0xe1,0x00,0x03,0x0d,0x00,0x09,0xea,0x00,0x01,0x0f,
0x00,0x09,0xf3,0x00,0x01,0x0f,0x00,0x09,0xfc,0x00,0x03,0x0d,0x00,0x09,0x05,0x01,
0x03,0x0d,0x00,0x09,0x0e,0x01,0x03,0x0d,0x00,0x09,0x17,0x01,0x03,0x0d,0x00,0x09,
0x20,0x01,0x00,0x00,0x00,0x09,0x29,0x01,0x03,0x0d,0x00,0x09,0x32,0x01,0x02,0x05,
0x00,0x09,0x3b,0x01,0x03,0x0d,0x00,0x09,0x44,0x01,0x02,0x0e,0x00,0x09,0x4d,0x01,
0x03,0x0d,0x00,0x09,0x56,0x01,0x03,0x0d,0x00,0x09,0x5f,0x01,0x02,0x06,0x00,0x09,
0x68,0x01,0x02,0x0e,0x00,0x09,0x71,0x01,0x02,0x0e,0x00,0x09,0x7a,0x01,0x03,0x08,
0x00,0x09,0x83,0x01,0x05,0x0c,0x00,0x09,0x8c,0x01,0x0b,0x0f,0x00,0x09,0x95,0x01,
0x08,0x09,0x00,0x09,0x9e,0x01,0x0b,0x0d,0x00,0x09,0xa7,0x01,0x02,0x0e,0x00,0x09,
0xb0,0x01,0x03,0x0d,0x00,0x09,0xb9,0x01,0x03,0x0d,0x00,0x09,0xc2,0x01,0x03,0x0d,
0x00,0x09,0xcb,0x01,0x03,0x0d,0x00,0x09,0xd4,0x01,0x03,0x0d,0x00,0x09,0xdd,0x01,
0x03,0x0d,0x00,0x09,0xe6,0x01,0x03,0x0d,0x00,0x09,0xef,0x01,0x03,0x0d,0x00,0x09,
0xf8,0x01,0x03,0x0d,0x00,0x09,0x01,0x02,0x03,0x0d,0x00,0x09,0x0a,0x02,0x06,0x0d,
0x00,0x09,0x13,0x02,0x06,0x0f,0x00,0x09,0x1c,0x02,0x05,0x0c,0x00,0x09,0x25,0x02,
0x07,0x0a,0x00,0x09,0x2e,0x02,0x05,0x0c,0x00,0x09,0x37,0x02,0x03,0x0d,0x00,0x09,
0x40,0x02,0x03,0x0d,0x00,0x09,0x49,0x02,0x03,0x0d,0x00,0x09,0x52,0x02,0x03,0x0d,
0x00,0x09,0x5b,0x02,0x03,0x0d,0x00,0x09,0x64,0x02,0x03,0x0d,0x00,0x09,0x6d,0x02,
0x03,0x0d,0x00,0x09,0x76,0x02,0x03,0x0d,0x00,0x09,0x7f,0x02,0x03,0x0d,0x00,0x09,
0x88,0x02,0x03,0x0d,0x00,0x09,0x91,0x02,0x03,0x0d,0x00,0x09,0x9a,0x02,0x03,0x0d,
0x00,0x09,0xa3,0x02,0x03,0x0d,0x00,0x09,0xac,0x02,0x03,0x0d,0x00,0x09,0xb5,0x02,
0x03,0x0d,0x00,0x09,0xbe,0x02,0x03,0x0d,0x00,0x09,0xc7,0x02,0x03,0x0d,0x00,0x09,
0xd0,0x02,0x03,0x0d,0x00,0x09,0xd9,0x02,0x03,0x0f,0x00,0x09,0xe2,0x02,0x03,0x0d,
0x00,0x09,0xeb,0x02,0x03,0x0d,0x00,0x09,0xf4,0x02,0x03,0x0d,0x00,0x09,0xfd,0x02,
0x03,0x0d,0x00,0x09,0x06,0x03,0x03,0x0d,0x00,0x09,0x0f,0x03,0x03,0x0d,0x00,0x09,
0x18,0x03,0x03,0x0d,0x00,0x09,0x21,0x03,0x03,0x0d,0x00,0x09,0x2a,0x03,0x03,0x0d,
0x00,0x09,0x33,0x03,0x02,0x0e,0x00,0x09,0x3c,0x03,0x02,0x0e,0x00,0x09,0x45,0x03,
0x02,0x0e,0x00,0x09,0x4e,0x03,0x04,0x0b,0x00,0x09,0x57,0x03,0x0d,0x0e,0x00,0x09,
0x60,0x03,0x02,0x06,0x00,0x09,0x69,0x03,0x05,0x0d,0x00,0x09,0x72,0x03,0x02,0x0d,
0x00,0x09,0x7b,0x03,0x05,0x0d,0x00,0x09,0x84,0x03,0x02,0x0d,0x00,0x09,0x8d,0x03,
0x05,0x0d,0x00,0x09,0x96,0x03,0x02,0x0d,0x00,0x09,0x9f,0x03,0x05,0x0f,0x00,0x09,
0xa8,0x03,0x02,0x0d,0x00,0x09,0xb1,0x03,0x02,0x0d,0x00,0x09,0xba,0x03,0x02,0x0f,
0x00,0x09,0xc3,0x03,0x02,0x0d,0x00,0x09,0xcc,0x03,0x02,0x0d,0x00,0x09,0xd5,0x03,
0x05,0x0d,0x00,0x09,0xde,0x03,0x05,0x0d,0x00,0x09,0xe7,0x03,0x05,0x0d,0x00,0x09,
0xf0,0x03,0x05,0x0f,0x00,0x09,0xf9,0x03,0x05,0x0f,0x00,0x09,0x02,0x04,0x05,0x0d,
0x00,0x09,0x0b,0x04,0x05,0x0d,0x00,0x09,0x14,0x04,0x03,0x0d,0x00,0x09,0x1d,0x04,
0x05,0x0d,0x00,0x09,0x26,0x04,0x05,0x0d,0x00,0x09,0x2f,0x04,0x05,0x0d,0x00,0x09,
0x38,0x04,0x05,0x0d,0x00,0x09,0x41,0x04,0x05,0x0f,0x00,0x09,0x4a,0x04,0x05,0x0d,
0x00,0x09,0x53,0x04,0x02,0x0e,0x00,0x09,0x5c,0x04,0x02,0x0e,0x00,0x09,0x65,0x04,
0x02,0x0e,0x00,0x09,0x6e,0x04,0x07,0x0a,0x00,0x09,0x77,0x04,0x01,0x0d,0x00,0x09,
0x80,0x04,0x00,0x0e,0x00,0x09,0x89,0x04,0x00,0x0f,0x00,0x09,0x92,0x04,0x00,0x0f,
0x00,0x09,0x9b,0x04,0x00,0x0f,0x00,0x09,0xa4,0x04,0x00,0x0f,0x00,0x09,0xad,0x04,
0x00,0x0f,0x00,0x09,0xb6,0x04,0x00,0x0f,0x00,0x09,0xbf,0x04,0x00,0x0f,0x00,0x09,
0xc8,0x04,0x00,0x0f,0x00,0x09,0xd1,0x04,0x00,0x0f,0x00,0x09,0xda,0x04,0x00,0x0f,
0x00,0x09,0xe3,0x04,0x00,0x0f,0x00,0x09,0xec,0x04,0x00,0x0f,0x00,0x09,0xf5,0x04,
0x00,0x0f,0x00,0x09,0xfe,0x04,0x00,0x0f,0x00,0x09,0x07,0x05,0x00,0x0f,0x00,0x09,
0x10,0x05,0x00,0x0f,0x00,0x09,0x19,0x05,0x00,0x0f,0x00,0x09,0x22,0x05,0x00,0x0f,
0x00,0x09,0x2b,0x05,0x00,0x0f,0x00,0x09,0x34,0x05,0x00,0x0f,0x00,0x09,0x3d,0x05,
0x00,0x0f,0x00,0x09,0x46,0x05,0x00,0x0f,0x00,0x09,0x4f,0x05,0x00,0x0f,0x00,0x09,
0x58,0x05,0x00,0x0f,0x00,0x09,0x61,0x05,0x00,0x0f,0x00,0x09,0x6a,0x05,0x00,0x0f,
0x00,0x09,0x73,0x05,0x00,0x0f,0x00,0x09,0x7c,0x05,0x00,0x0f,0x00,0x09,0x85,0x05,
0x00,0x0f,0x00,0x09,0x8e,0x05,0x00,0x0f,0x00,0x09,0x97,0x05,0x00,0x0f,0x00,0x09,
0xa0,0x05,0x00,0x0d,0x00,0x09,0xa9,0x05,0x05,0x0f,0x00,0x09,0xb2,0x05,0x02,0x0e,
0x00,0x09,0xbb,0x05,0x03,0x0d,0x00,0x09,0xc4,0x05,0x03,0x0d,0x00,0x09,0xcd,0x05,
0x03,0x0d,0x00,0x09,0xd6,0x05,0x02,0x0e,0x00,0x09,0xdf,0x05,0x03,0x0e,0x00,0x09,
0xe8,0x05,0x02,0x04,0x00,0x09,0xf1,0x05,0x03,0x0d,0x00,0x09,0xfa,0x05,0x03,0x0a,
0x00,0x09,0x03,0x06,0x06,0x0b,0x00,0x09,0x0c,0x06,0x07,0x0a,0x00,0x09,0x15,0x06,
0x08,0x09,0x00,0x09,0x1e,0x06,0x03,0x0b,0x00,0x09,0x27,0x06,0x02,0x03,0x00,0x09,
0x30,0x06,0x03,0x07,0x00,0x09,0x39,0x06,0x05,0x0c,0x00,0x09,0x42,0x06,0x03,0x0a,
0x00,0x09,0x4b,0x06,0x03,0x0a,0x00,0x09,0x54,0x06,0x02,0x04,0x00,0x09,0x5d,0x06,
0x05,0x0f,0x00,0x09,0x66,0x06,0x03,0x0e,0x00,0x09,0x6f,0x06,0x08,0x0a,0x00,0x09,
0x78,0x06,0x0d,0x0f,0x00,0x09,0x81,0x06,0x03,0x0a,0x00,0x09,0x8a,0x06,0x03,0x0a,
0x00,0x09,0x93,0x06,0x06,0x0b,0x00,0x09,0x9c,0x06,0x03,0x0d,0x00,0x09,0xa5,0x06,
0x03,0x0d,0x00,0x09,0xae,0x06,0x03,0x0d,0x00,0x09,0xb7,0x06,0x05,0x0f,0x00,0x09,
0xc0,0x06,0x00,0x0d,0x00,0x09,0xc9,0x06,0x00,0x0d,0x00,0x09,0xd2,0x06,0x00,0x0d,
0x00,0x09,0xdb,0x06,0x00,0x0d,0x00,0x09,0xe4,0x06,0x00,0x0d,0x00,0x09,0xed,0x06,
0x01,0x0d,0x00,0x09,0xf6,0x06,0x03,0x0d,0x00,0x09,0xff,0x06,0x03,0x0f,0x00,0x09,
0x08,0x07,0x00,0x0d,0x00,0x09,0x11,0x07,0x00,0x0d,0x00,0x09,0x1a,0x07,0x00,0x0d,
0x00,0x09,0x23,0x07,0x00,0x0d,0x00,0x09,0x2c,0x07,0x00,0x0d,0x00,0x09,0x35,0x07,
0x00,0x0d,0x00,0x09,0x3e,0x07,0x00,0x0d,0x00,0x09,0x47,0x07,0x00,0x0d,0x00,0x09,
0x50,0x07,0x03,0x0d,0x00,0x09,0x59,0x07,0x00,0x0d,0x00,0x09,0x62,0x07,0x00,0x0d,
0x00,0x09,0x6b,0x07,0x00,0x0d,0x00,0x09,0x74,0x07,0x00,0x0d,0x00,0x09,0x7d,0x07,
0x00,0x0d,0x00,0x09,0x86,0x07,0x00,0x0d,0x00,0x09,0x8f,0x07,0x06,0x0b,0x00,0x09,
0x98,0x07,0x03,0x0d,0x00,0x09,0xa1,0x07,0x00,0x0d,0x00,0x09,0xaa,0x07,0x00,0x0d,
0x00,0x09,0xb3,0x07,0x00,0x0d,0x00,0x09,0xbc,0x07,0x00,0x0d,0x00,0x09,0xc5,0x07,
0x00,0x0d,0x00,0x09,0xce,0x07,0x03,0x0d,0x00,0x09,0xd7,0x07,0x02,0x0d,0x00,0x09,
0xe0,0x07,0x02,0x0d,0x00,0x09,0xe9,0x07,0x02,0x0d,0x00,0x09,0xf2,0x07,0x02,0x0d,
0x00,0x09,0xfb,0x07,0x02,0x0d,0x00,0x09,0x04,0x08,0x02,0x0d,0x00,0x09,0x0d,0x08,
0x02,0x0d,0x00,0x09,0x16,0x08,0x05,0x0d,0x00,0x09,0x1f,0x08,0x05,0x0f,0x00,0x09,
0x28,0x08,0x02,0x0d,0x00,0x09,0x31,0x08,0x02,0x0d,0x00,0x09,0x3a,0x08,0x02,0x0d,
0x00,0x09,0x43,0x08,0x02,0x0d,0x00,0x09,0x4c,0x08,0x02,0x0d,0x00,0x09,0x55,0x08,
0x02,0x0d,0x00,0x09,0x5e,0x08,0x02,0x0d,0x00,0x09,0x67,0x08,0x02,0x0d,0x00,0x09,
0x70,0x08,0x02,0x0d,0x00,0x09,0x79,0x08,0x02,0x0d,0x00,0x09,0x82,0x08,0x02,0x0d,
0x00,0x09,0x8b,0x08,0x02,0x0d,0x00,0x09,0x94,0x08,0x02,0x0d,0x00,0x09,0x9d,0x08,
0x02,0x0d,0x00,0x09,0xa6,0x08,0x02,0x0d,0x00,0x09,0xaf,0x08,0x05,0x0c,0x00,0x09,
0xb8,0x08,0x05,0x0d,0x00,0x09,0xc1,0x08,0x02,0x0d,0x00,0x09,0xca,0x08,0x02,0x0d,
0x00,0x09,0xd3,0x08,0x02,0x0d,0x00,0x09,0xdc,0x08,0x02,0x0d,0x00,0x09,0xe5,0x08,
0x02,0x0f,0x00,0x09,0xee,0x08,0x03,0x0f,0x00,0x09,0xf7,0x08,0x02,0x0f,0x00,0x09,
0x00,0x09,0x00,0x00,0x00,0x00,
};
@

<<global sizeofdefont>>=
int	sizeofdefont = sizeof defontdata;
@

<<function _unpackinfo>>=
void
_unpackinfo(Fontchar *fc, uchar *p, int n)
{
    int j;

    for(j=0;  j<=n;  j++){
        fc->x = p[0]|(p[1]<<8);
        fc->top = p[2];
        fc->bottom = p[3];
        fc->left = p[4];
        fc->width = p[5];
        fc++;
        p += 6;
    }
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/defont.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<global defontdata>>

<<global sizeofdefont>>

<<function _unpackinfo>>
@


\subsection*{[[lib_graphics/libdraw/draw.c]]}


%-------------------------------------------------------------

<<lib_graphics/libdraw/draw.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function _setdrawop>>
        
<<function draw1>>

<<function draw>>

<<function drawop>>

<<function gendraw>>

<<function gendrawop>>
@


\subsection*{[[lib_graphics/libdraw/drawrepl.c]]}



%-------------------------------------------------------------

<<lib_graphics/libdraw/drawrepl.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function drawreplxy>>

<<function drawrepl>>

@


\subsection*{[[lib_graphics/libdraw/egetrect.c]]}

%-------------------------------------------------------------

<<lib_graphics/libdraw/egetrect.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <cursor.h>
#include <event.h>

<<constant W>>

<<global tmp>>
<<global red>>

<<global sweep>>

<<function brects>>

<<function egetrect>>

<<function freetmp>>

<<function edrawgetrect>>
@


\subsection*{[[lib_graphics/libdraw/ellipse.c]]}


%-------------------------------------------------------------

<<lib_graphics/libdraw/ellipse.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function doellipse>>

<<function ellipse>>

<<function ellipseop>>

<<function fillellipse>>

<<function fillellipseop>>

<<function arc>>

<<function arcop>>

<<function fillarc>>

<<function fillarcop>>
@


\subsection*{[[lib_graphics/libdraw/emenuhit.c]]}


%-------------------------------------------------------------

<<lib_graphics/libdraw/emenuhit.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <event.h>

<<enum _anon_ (lib_graphics/libdraw/emenuhit.c)>>

<<global menutxt>>
<<global back>>
<<global high>>
<<global bord>>
<<global text>>
<<global htext>>

<<function menucolors>>

<<function menurect>>

<<function menusel>>

<<function paintitem>>

<<function menuscan>>

<<function menupaint>>

<<function menuscrollpaint>>

<<function emenuhit>>
@


\subsection*{[[lib_graphics/libdraw/event.c]]}

%-------------------------------------------------------------

<<lib_graphics/libdraw/event.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <cursor.h>
#include <event.h>

typedef struct	Slave Slave;
typedef struct	Ebuf Ebuf;

<<struct Slave>>

<<struct Ebuf>>

<<global eslave>>
<<global Skeyboard>>
<<global Smouse>>
<<global Stimer>>
<<global logfid>>

<<global nslave>>
<<global parentpid>>
<<global epipe>>

static	int	eforkslave(ulong);
static	void	extract(void);
static	void	ekill(void);
static	int	enote(void *, char *);

<<global mousefd>>
<<global cursorfd>>

<<function ebread>>

<<function event>>

<<function eread>>

<<function ecanmouse>>

<<function ecankbd>>

<<function ecanread>>

<<function estartfn>>

<<function estart>>

<<function etimer>>

<<function ekeyslave>>

<<function einit>>

<<function extract>>

<<function eforkslave>>

<<function enote>>

<<function ekill>>

<<function emouse>>

<<function ekbd>>

<<function emoveto>>

<<function esetcursor>>

<<function ereadmouse>>

<<function eatomouse>>
@


\subsection*{[[lib_graphics/libdraw/fmt.c]]}


%-------------------------------------------------------------

<<lib_graphics/libdraw/fmt.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function Rfmt>>

<<function Pfmt>>

@


\subsection*{[[lib_graphics/libdraw/font.c]]}

<<constant PJW>>=
#define	PJW	0	/* use NUL==pjw for invisible characters */
@

<<function cachechars>>=
int
cachechars(Font *f, char **ss, Rune **rr, ushort *cp, int max, int *wp, char **subfontname)
{
    int i, th, sh, h, ld, w, rw, wid, nc;
    char *sp;
    Rune r, *rp, vr;
    ulong a;
    Cacheinfo *c, *tc, *ec;

    if(ss){
        sp = *ss;
        rp = L"";
    }else{
        sp = "";
        rp = *rr;
    }
    wid = 0;
    *subfontname = 0;
    for(i=0; i<max && (*sp || *rp); sp+=w, rp+=rw){
        if(ss){
            r = *(uchar*)sp;
            if(r < Runeself)
                w = 1;
            else{
                w = chartorune(&vr, sp);
                r = vr;
            }
            rw = 0;
        }else{
            r = *rp;
            w = 0;
            rw = 1;
        }

        sh = (17 * (uint)r) & (f->ncache-NFLOOK-1);
        c = &f->cache[sh];
        ec = c+NFLOOK;
        h = sh;
        while(c < ec){
            if(c->value==r && c->age)
                goto Found;
            c++;
            h++;
        }
    
        /*
         * Not found; toss out oldest entry
         */
        a = ~0;
        th = sh;
        tc = &f->cache[th];
        while(tc < ec){
            if(tc->age < a){
                a = tc->age;
                h = th;
                c = tc;
            }
            tc++;
            th++;
        }

        if(a && (f->age-a)<500){	/* kicking out too recent; resize */
            nc = 2*(f->ncache-NFLOOK) + NFLOOK;
            if(nc <= MAXFCACHE){
                if(i == 0)
                    fontresize(f, f->width, nc, f->maxdepth);
                /* else flush first; retry will resize */
                break;
            }
        }

        if(c->age == f->age)	/* flush pending string output */
            break;

        ld = loadchar(f, r, c, h, i, subfontname);
        if(ld <= 0){
            if(ld == 0)
                continue;
            break;
        }
        c = &f->cache[h];	/* may have reallocated f->cache */
    
        Found:
        wid += c->width;
        c->age = f->age;
        cp[i] = h;
        i++;
    }
    if(ss)
        *ss = sp;
    else
        *rr = rp;
    *wp = wid;
    return i;
}
@

<<function agefont>>=
void
agefont(Font *f)
{
    Cacheinfo *c, *ec;
    Cachesubf *s, *es;

    f->age++;
    if(f->age == 65536){
        /*
         * Renormalize ages
         */
        c = f->cache;
        ec = c+f->ncache;
        while(c < ec){
            if(c->age){
                c->age >>= 2;
                c->age++;
            }
            c++;
        }
        s = f->subf;
        es = s+f->nsubf;
        while(s < es){
            if(s->age){
                if(s->age<SUBFAGE && s->cf->name != nil){
                    /* clean up */
                    if(display &&
                        s->f != display->defaultsubfont)
                        freesubfont(s->f);
                    s->cf = nil;
                    s->f = nil;
                    s->age = 0;
                }else{
                    s->age >>= 2;
                    s->age++;
                }
            }
            s++;
        }
        f->age = (65536>>2) + 1;
    }
}
@

<<function cf2subfont>>=
static Subfont*
cf2subfont(Cachefont *cf, Font *f)
{
    int depth;
    char *name;
    Subfont *sf;

    name = cf->subfontname;
    if(name == nil){
        if(f->display && f->display->screenimage)
            depth = f->display->screenimage->depth;
        else
            depth = 8;
        name = subfontname(cf->name, f->name, depth);
        if(name == nil)
            return nil;
        cf->subfontname = name;
    }
    sf = lookupsubfont(f->display, name);
    return sf;
}
@


<<function freeup>>=
/* release all subfonts, return number freed */
static
int
freeup(Font *f)
{
    Cachesubf *s, *es;
    int nf;

    if(f->sub[0]->name == nil)	/* font from mkfont; don't free */
        return 0;
    s = f->subf;
    es = s+f->nsubf;
    nf = 0;
    while(s < es){
        if(s->age){
            freesubfont(s->f);
            s->cf = nil;
            s->f = nil;
            s->age = 0;
            nf++;
        }
        s++;
    }
    return nf;
}
@



%-------------------------------------------------------------

<<lib_graphics/libdraw/font.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

static int	fontresize(Font*, int, int, int);
static int	freeup(Font*);

<<constant PJW>>

<<function cachechars>>

<<function agefont>>

<<function cf2subfont>>

<<function loadchar>>

<<function freeup>>

<<function fontresize>>
@


\subsection*{[[lib_graphics/libdraw/freesubfont.c]]}

<<function freesubfont>>=
void
freesubfont(Subfont *f)
{
    if(f == 0)
        return;
    f->ref--;
    if(f->ref > 0)
        return;
    uninstallsubfont(f);
    free(f->info);	/* note: f->info must have been malloc'ed! */
    freeimage(f->bits);
    free(f);
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/freesubfont.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function freesubfont>>
@


\subsection*{[[lib_graphics/libdraw/getdefont.c]]}

<<function getdefont>>=
Subfont*
getdefont(Display *d)
{
    char *hdr, *p;
    int n;
    Fontchar *fc;
    Subfont *f;
    int ld;
    Rectangle r;
    Image *i;

    /*
     * make sure data is word-aligned.  this is true with Plan 9 compilers
     * but not in general.  the byte order is right because the data is
     * declared as char*, not ulong*.
     */
    p = (char*)defontdata;
    n = (int)(uvlong)p & 3;				/* stupid ape */
    if(n != 0){
        memmove(p+(4-n), p, sizeofdefont-n);
        p += 4-n;
    }
    ld = atoi(p+0*12);
    r.min.x = atoi(p+1*12);
    r.min.y = atoi(p+2*12);
    r.max.x = atoi(p+3*12);
    r.max.y = atoi(p+4*12);

    i = allocimage(d, r, drawld2chan[ld], 0, 0);
    if(i == 0)
        return 0;

    p += 5*12;
    n = loadimage(i, r, (uchar*)p, (defontdata+sizeofdefont)-(uchar*)p);
    if(n < 0){
        freeimage(i);
        return 0;
    }

    hdr = p+n;
    n = atoi(hdr);
    p = hdr+3*12;
    fc = malloc(sizeof(Fontchar)*(n+1));
    if(fc == 0){
        freeimage(i);
        return 0;
    }
    _unpackinfo(fc, (uchar*)p, n);
    f = allocsubfont("*default*", n, atoi(hdr+12), atoi(hdr+24), fc, i);
    if(f == 0){
        freeimage(i);
        free(fc);
        return 0;
    }
    return f;
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/getdefont.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function getdefont>>
@


\subsection*{[[lib_graphics/libdraw/getrect.c]]}


%-------------------------------------------------------------

<<lib_graphics/libdraw/getrect.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <cursor.h>
#include <mouse.h>

<<constant W (lib_graphics/libdraw/getrect.c)>>

<<global tmp (lib_graphics/libdraw/getrect.c)>>
<<global red (lib_graphics/libdraw/getrect.c)>>

<<global sweep (lib_graphics/libdraw/getrect.c)>>

<<function brects (lib_graphics/libdraw/getrect.c)>>

<<function getrect>>

<<function freetmp (lib_graphics/libdraw/getrect.c)>>

<<function max>>

<<function drawgetrect>>
@


\subsection*{[[lib_graphics/libdraw/getsubfont.c]]}

<<function _getsubfont>>=
/*
 * Default version: treat as file name
 */

Subfont*
_getsubfont(Display *d, char *name)
{
    int fd;
    Subfont *f;

    fd = open(name, OREAD);
        
    if(fd < 0){
        fprint(2, "getsubfont: can't open %s: %r\n", name);
        return 0;
    }
    /*
     * unlock display so i/o happens with display released, unless
     * user is doing his own locking, in which case this could break things.
     * _getsubfont is called only from string.c and stringwidth.c,
     * which are known to be safe to have this done.
     */
    if(d && d->locking == 0)
        unlockdisplay(d);
    f = readsubfont(d, name, fd, d && d->locking==0);
    if(d && d->locking == 0)
        lockdisplay(d);
    if(f == 0)
        fprint(2, "getsubfont: can't read %s: %r\n", name);
    close(fd);
    setmalloctag(f, getcallerpc(&d));
    return f;
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/getsubfont.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function _getsubfont>>
@


\subsection*{[[lib_graphics/libdraw/icossin.c]]}


%-------------------------------------------------------------

<<lib_graphics/libdraw/icossin.c>>=
#include	<u.h>
#include	<libc.h>
#include	<draw.h>

<<global sinus>>

<<function icossin>>
@


\subsection*{[[lib_graphics/libdraw/icossin2.c]]}


%-------------------------------------------------------------

<<lib_graphics/libdraw/icossin2.c>>=
#include	<u.h>
#include	<libc.h>
#include	<draw.h>

<<global sinus (lib_graphics/libdraw/icossin2.c)>>

<<global cosinus>>

<<function icossin2>>
@


\subsection*{[[lib_graphics/libdraw/init.c]]}


<<global deffontname>>=
static char deffontname[] = "*default*";
@


% seems related to fonts
<<function lockdisplay>>=
void
lockdisplay(Display *disp)
{
    if(debuglockdisplay){
        /* avoid busy looping; it's rare we collide anyway */
        while(!canqlock(&disp->qlock)){
            fprint(1, "proc %d waiting for display lock...\n", getpid());
            sleep(1000);
        }
    }else
        qlock(&disp->qlock);
}
@

<<function unlockdisplay>>=
void
unlockdisplay(Display *disp)
{
    qunlock(&disp->qlock);
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/init.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<global display>>
<<global font>>
<<global screen>>
<<global _drawdebug>>

<<global deffontname>>
<<global _screen>>

<<global debuglockdisplay>>

static void _closedisplay(Display*, int);

<<function drawshutdown>>

<<function geninitdraw>>

<<function initdraw>>

<<function gengetwindow>>

<<function getwindow>>

<<constant NINFO>>

<<function initdisplay>>

<<function closedisplay>>

<<function _closedisplay>>

<<function lockdisplay>>

<<function unlockdisplay>>

<<function drawerror>>

<<function doflush>>

<<function flushimage>>

<<function bufimage>>

@


\subsection*{[[lib_graphics/libdraw/keyboard.c]]}

%-------------------------------------------------------------

<<lib_graphics/libdraw/keyboard.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <keyboard.h>


<<function closekeyboard>>

<<function _ioproc>>

<<function initkeyboard>>

<<function ctlkeyboard>>
@


\subsection*{[[lib_graphics/libdraw/line.c]]}


%-------------------------------------------------------------

<<lib_graphics/libdraw/line.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function line>>

<<function lineop>>
@


\subsection*{[[lib_graphics/libdraw/loadimage.c]]}


%-------------------------------------------------------------

<<lib_graphics/libdraw/loadimage.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function loadimage>>
@


\subsection*{[[lib_graphics/libdraw/menuhit.c]]}


%-------------------------------------------------------------

<<lib_graphics/libdraw/menuhit.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <mouse.h>

<<enum _anon_ (lib_graphics/libdraw/menuhit.c)>>

<<global menutxt (lib_graphics/libdraw/menuhit.c)>>
<<global back (lib_graphics/libdraw/menuhit.c)>>
<<global high (lib_graphics/libdraw/menuhit.c)>>
<<global bord (lib_graphics/libdraw/menuhit.c)>>
<<global text (lib_graphics/libdraw/menuhit.c)>>
<<global htext (lib_graphics/libdraw/menuhit.c)>>

<<function menucolors (lib_graphics/libdraw/menuhit.c)>>

<<function menurect (lib_graphics/libdraw/menuhit.c)>>

<<function menusel (lib_graphics/libdraw/menuhit.c)>>

<<function paintitem (lib_graphics/libdraw/menuhit.c)>>

<<function menuscan (lib_graphics/libdraw/menuhit.c)>>

<<function menupaint (lib_graphics/libdraw/menuhit.c)>>

<<function menuscrollpaint (lib_graphics/libdraw/menuhit.c)>>

<<function menuhit>>
@


\subsection*{[[lib_graphics/libdraw/mkfont.c]]}

<<function mkfont>>=
/*
 * Cobble fake font using existing subfont
 */
Font*
mkfont(Subfont *subfont, Rune min)
{
    Font *font;
    Cachefont *c;

    font = malloc(sizeof(Font));
    if(font == 0)
        return 0;
    memset(font, 0, sizeof(Font));
    font->display = subfont->bits->display;
    font->name = strdup("<synthetic>");
    font->ncache = NFCACHE+NFLOOK;
    font->nsubf = NFSUBF;
    font->cache = malloc(font->ncache * sizeof(font->cache[0]));
    font->subf = malloc(font->nsubf * sizeof(font->subf[0]));
    if(font->name==0 || font->cache==0 || font->subf==0){
    Err:
        free(font->name);
        free(font->cache);
        free(font->subf);
        free(font->sub);
        free(font);
        return 0;
    }
    memset(font->cache, 0, font->ncache*sizeof(font->cache[0]));
    memset(font->subf, 0, font->nsubf*sizeof(font->subf[0]));
    font->height = subfont->height;
    font->ascent = subfont->ascent;
    font->age = 1;
    font->sub = malloc(sizeof(Cachefont*));
    if(font->sub == 0)
        goto Err;
    c = malloc(sizeof(Cachefont));
    if(c == 0)
        goto Err;
    font->nsub = 1;
    font->sub[0] = c;
    c->min = min;
    c->max = min+subfont->n-1;
    c->offset = 0;
    c->name = 0;	/* noticed by freeup() and agefont() */
    c->subfontname = 0;
    font->subf[0].age = 0;
    font->subf[0].cf = c;
    font->subf[0].f = subfont;
    return font;
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/mkfont.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function mkfont>>
@


\subsection*{[[lib_graphics/libdraw/mouse.c]]}

%-------------------------------------------------------------

<<lib_graphics/libdraw/mouse.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <cursor.h>
#include <mouse.h>

<<function moveto>>

<<function closemouse>>

<<function readmouse>>

<<function _ioproc (lib_graphics/libdraw/mouse.c)>>

<<function initmouse>>

<<function setcursor>>
@


\subsection*{[[lib_graphics/libdraw/newwindow.c]]}


%-------------------------------------------------------------

<<lib_graphics/libdraw/newwindow.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function newwindow>>

@


\subsection*{[[lib_graphics/libdraw/openfont.c]]}

<<function openfont>>=
Font*
openfont(Display *d, char *name)
{
    Font *fnt;
    int fd, i, n;
    char *buf;
    Dir *dir;

    fd = open(name, OREAD);
    if(fd < 0)
        return 0;

    dir = dirfstat(fd);
    if(dir == nil){
    Err0:
        close(fd);
        return 0;
    }
    n = dir->length;
    free(dir);
    buf = malloc(n+1);
    if(buf == 0)
        goto Err0;
    buf[n] = 0;
    i = read(fd, buf, n);
    close(fd);
    if(i != n){
        free(buf);
        return 0;
    }
    fnt = buildfont(d, buf, name);
    free(buf);
    return fnt;
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/openfont.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function openfont>>
@


\subsection*{[[lib_graphics/libdraw/poly.c]]}

%-------------------------------------------------------------

<<lib_graphics/libdraw/poly.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function addcoord>>

<<function dopoly>>

<<function poly>>

<<function polyop>>

<<function fillpoly>>

<<function fillpolyop>>
@


\subsection*{[[lib_graphics/libdraw/readcolmap.c]]}

<<function getval>>=
static ulong
getval(char **p)
{
    ulong v;
    char *q;

    v = strtoul(*p, &q, 0);
    v |= v<<8;
    v |= v<<16;
    *p = q;
    return v;
}
@
% >> >>



<<function readcolmap>>=
void
readcolmap(Display *d, RGB *colmap)
{
    int i;
    char *p, *q;
    Biobuf *b;
    char buf[128];

    USED(screen);

    sprint(buf, "/dev/draw/%d/colormap", d->dirno);
    b = Bopen(buf, OREAD);
    if(b == 0)
        drawerror(d, "rdcolmap: can't open colormap device");

    for(;;) {
        p = Brdline(b, '\n');
        if(p == 0)
            break;
        i = strtoul(p, &q, 0);
        if(i < 0 || i > 255) {
            fprint(2, "rdcolmap: bad index\n");
            exits("bad");
        }
        p = q;
        colmap[255-i].red = getval(&p);
        colmap[255-i].green = getval(&p);
        colmap[255-i].blue = getval(&p);
    }
    Bterm(b);
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/readcolmap.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <bio.h>

<<function getval>>

<<function readcolmap>>
@


\subsection*{[[lib_graphics/libdraw/readimage.c]]}


%-------------------------------------------------------------

<<lib_graphics/libdraw/readimage.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function readimage>>
@


\subsection*{[[lib_graphics/libdraw/readsubfont.c]]}

<<function readsubfonti>>=
Subfont*
readsubfonti(Display*d, char *name, int fd, Image *ai, int dolock)
{
    char hdr[3*12+4+1];
    int n;
    uchar *p;
    Fontchar *fc;
    Subfont *f;
    Image *i;

    i = ai;
    if(i == nil){
        i = readimage(d, fd, dolock);
        if(i == nil)
            return nil;
    }
    if(read(fd, hdr, 3*12) != 3*12){
        if(ai == nil)
            freeimage(i);
        werrstr("rdsubfonfile: header read error: %r");
        return nil;
    }
    n = atoi(hdr);
    p = malloc(6*(n+1));
    if(p == nil)
        goto Err;
    if(read(fd, p, 6*(n+1)) != 6*(n+1)){
        werrstr("rdsubfonfile: fontchar read error: %r");
    Err:
        if(ai == nil)
            freeimage(i);
        free(p);
        return nil;
    }
    fc = malloc(sizeof(Fontchar)*(n+1));
    if(fc == nil)
        goto Err;
    _unpackinfo(fc, p, n);
    if(dolock)
        lockdisplay(d);
    f = allocsubfont(name, n, atoi(hdr+12), atoi(hdr+24), fc, i);
    if(dolock)
        unlockdisplay(d);
    if(f == nil){
        free(fc);
        goto Err;
    }
    free(p);
    return f;
}
@

<<function readsubfont>>=
Subfont*
readsubfont(Display *d, char *name, int fd, int dolock)
{
    return readsubfonti(d, name, fd, nil, dolock);
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/readsubfont.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function readsubfonti>>

<<function readsubfont>>
@


\subsection*{[[lib_graphics/libdraw/rectclip.c]]}



%-------------------------------------------------------------

<<lib_graphics/libdraw/rectclip.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function rectclip>>
@


\subsection*{[[lib_graphics/libdraw/replclipr.c]]}


%-------------------------------------------------------------

<<lib_graphics/libdraw/replclipr.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function replclipr>>
@


\subsection*{[[lib_graphics/libdraw/rgb.c]]}



%-------------------------------------------------------------

<<lib_graphics/libdraw/rgb.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>


<<function rgb2cmap>>

<<function cmap2rgb>>

<<function cmap2rgba>>
@


%/*
% * This original version, although fast and a true inverse of
% * cmap2rgb, in the sense that rgb2cmap(cmap2rgb(c))
% * returned the original color, does a terrible job for RGB
% * triples that do not appear in the color map, so it has been
% * replaced by the much slower version below, that loops
% * over the color map looking for the nearest point in RGB
% * space.  There is no visual psychology reason for that
% * criterion, but it's easy to implement and the results are
% * far more pleasing. 
% *
%int
%rgb2cmap(int cr, int cg, int cb)
%{
%    int r, g, b, v, cv;
%
%    if(cr < 0)
%        cr = 0;
%    else if(cr > 255)
%        cr = 255;
%    if(cg < 0)
%        cg = 0;
%    else if(cg > 255)
%        cg = 255;
%    if(cb < 0)
%        cb = 0;
%    else if(cb > 255)
%        cb = 255;
%    r = cr>>6;
%    g = cg>>6;
%    b = cb>>6;
%    cv = cr;
%    if(cg > cv)
%        cv = cg;
%    if(cb > cv)
%        cv = cb;
%    v = (cv>>4)&3;
%    return ((((r<<2)+v)<<4)+(((g<<2)+b+v-r)&15));
%}



\subsection*{[[lib_graphics/libdraw/scroll.c]]}


%-------------------------------------------------------------

<<lib_graphics/libdraw/scroll.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function mousescrollsize>>
@


\subsection*{[[lib_graphics/libdraw/string.c]]}

<<constant Max>>=
Max = 100
@
% bad name, too general

<<enum _anon_ (lib_graphics/libdraw/string.c)>>=
enum
{
<<constant Max>>
};
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/string.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<enum _anon_ (lib_graphics/libdraw/string.c)>>

<<function string>>

<<function stringop>>

<<function stringn>>

<<function stringnop>>

<<function runestring>>

<<function runestringop>>

<<function runestringn>>

<<function runestringnop>>

<<function _string>>
@


\subsection*{[[lib_graphics/libdraw/stringbg.c]]}

%-------------------------------------------------------------

<<lib_graphics/libdraw/stringbg.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function stringbg>>

<<function stringbgop>>

<<function stringnbg>>

<<function stringnbgop>>

<<function runestringbg>>

<<function runestringbgop>>

<<function runestringnbg>>

<<function runestringnbgop>>
@


\subsection*{[[lib_graphics/libdraw/stringsubfont.c]]}

<<function stringsubfont>>=
Point
stringsubfont(Image *b, Point p, Image *color, Subfont *f, char *cs)
{
    int w, width;
    uchar *s;
    Rune c;
    Fontchar *i;

    s = (uchar*)cs;
    for(; c=*s; p.x+=width){
        width = 0;
        if(c < Runeself)
            s++;
        else{
            w = chartorune(&c, (char*)s);
            if(w == 0){
                s++;
                continue;
            }
            s += w;
        }
        if(c >= f->n)
            continue;
        i = f->info+c;
        width = i->width;
        draw(b, Rect(p.x+i->left, p.y+i->top, p.x+i->left+(i[1].x-i[0].x), p.y+i->bottom),
            color, f->bits, Pt(i->x, i->top));
    }
    return p;
}
@

<<function strsubfontwidth>>=
Point
strsubfontwidth(Subfont *f, char *cs)
{
    Rune c;
    Point p;
    uchar *s;
    Fontchar *i;
    int w, width;

    p = Pt(0, f->height);
    s = (uchar*)cs;
    for(; c=*s; p.x+=width){
        width = 0;
        if(c < Runeself)
            s++;
        else{
            w = chartorune(&c, (char*)s);
            if(w == 0){
                s++;
                continue;
            }
            s += w;
        }
        if(c >= f->n)
            continue;
        i = f->info+c;
        width = i->width;
    }
    return p;
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/stringsubfont.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function stringsubfont>>

<<function strsubfontwidth>>
@


\subsection*{[[lib_graphics/libdraw/stringwidth.c]]}

<<enum _anon_ (lib_graphics/libdraw/stringwidth.c)>>=
enum { Max = 64 };
@

<<function _stringnwidth>>=
int
_stringnwidth(Font *f, char *s, Rune *r, int len)
{
    int wid, twid, n, max, l;
    char *name;
    ushort cbuf[Max];
    Rune rune, **rptr;
    char *subfontname, **sptr;
    Font *def;

    if(s == nil){
        s = "";
        sptr = nil;
    }else
        sptr = &s;
    if(r == nil){
          r = L"";
        rptr = nil;
    }else
        rptr = &r;
    twid = 0;
    while(len>0 && (*s || *r)){
        max = Max;
        if(len < max)
            max = len;
        n = 0;
        while((l = cachechars(f, sptr, rptr, cbuf, max, &wid, &subfontname)) <= 0){
            if(++n > 10){
                if(*r)
                    rune = *r;
                else
                    chartorune(&rune, s);
                if(f->name != nil)
                    name = f->name;
                else
                    name = "unnamed font";
                fprint(2, "stringwidth: bad character set for rune 0x%.4ux in %s\n", rune, name);
                return twid;
            }
            if(subfontname){
                if(_getsubfont(f->display, subfontname) == 0){
                    def = f->display->defaultfont;
                    if(def && f!=def)
                        f = def;
                    else
                        break;
                }
            }
        }
        agefont(f);
        twid += wid;
        len -= l;
    }
    return twid;
}
@

<<function stringnwidth>>=
int
stringnwidth(Font *f, char *s, int len)
{
    return _stringnwidth(f, s, nil, len);
}
@

<<function stringwidth>>=
int
stringwidth(Font *f, char *s)
{
    return _stringnwidth(f, s, nil, 1<<24);
}
@

<<function stringsize>>=
Point
stringsize(Font *f, char *s)
{
    return Pt(_stringnwidth(f, s, nil, 1<<24), f->height);
}
@

<<function runestringnwidth>>=
int
runestringnwidth(Font *f, Rune *r, int len)
{
    return _stringnwidth(f, nil, r, len);
}
@

<<function runestringwidth>>=
int
runestringwidth(Font *f, Rune *r)
{
    return _stringnwidth(f, nil, r, 1<<24);
}
@

<<function runestringsize>>=
Point
runestringsize(Font *f, Rune *r)
{
    return Pt(_stringnwidth(f, nil, r, 1<<24), f->height);
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/stringwidth.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<enum _anon_ (lib_graphics/libdraw/stringwidth.c)>>

<<function _stringnwidth>>

<<function stringnwidth>>

<<function stringwidth>>

<<function stringsize>>

<<function runestringnwidth>>

<<function runestringwidth>>

<<function runestringsize>>
@


\subsection*{[[lib_graphics/libdraw/subfont.c]]}

<<function allocsubfont>>=
Subfont*
allocsubfont(char *name, int n, int height, int ascent, Fontchar *info, Image *i)
{
    Subfont *f;

    assert(height != 0 /* allocsubfont */);

    f = malloc(sizeof(Subfont));
    if(f == 0)
        return 0;
    f->n = n;
    f->height = height;
    f->ascent = ascent;
    f->info = info;
    f->bits = i;
    f->ref = 1;
    if(name){
        f->name = strdup(name);
        if(lookupsubfont(i->display, name) == 0)
            installsubfont(name, f);
    }else
        f->name = 0;
    return f;
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/subfont.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function allocsubfont>>
@


\subsection*{[[lib_graphics/libdraw/subfontcache.c]]}

<<global lastname>>=
/*
 * Easy versions of the cache routines; may be substituted by fancier ones for other purposes
 */

static char	*lastname;
@

<<global lastsubfont>>=
Subfont	*lastsubfont;
@

<<function lookupsubfont>>=
Subfont*
lookupsubfont(Display *d, char *name)
{
    if(d && strcmp(name, "*default*") == 0)
        return d->defaultsubfont;
    if(lastname && strcmp(name, lastname)==0)
    if(d==lastsubfont->bits->display){
        lastsubfont->ref++;
        return lastsubfont;
    }
    return 0;
}
@

<<function installsubfont>>=
void
installsubfont(char *name, Subfont *subfont)
{
    free(lastname);
    lastname = strdup(name);
    lastsubfont = subfont;	/* notice we don't free the old one; that's your business */
}
@

<<function uninstallsubfont>>=
void
uninstallsubfont(Subfont *subfont)
{
    if(subfont == lastsubfont){
        lastname = 0;
        lastsubfont = 0;
    }
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/subfontcache.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<global lastname>>
<<global lastsubfont>>

<<function lookupsubfont>>

<<function installsubfont>>

<<function uninstallsubfont>>
@


\subsection*{[[lib_graphics/libdraw/subfontname.c]]}

<<function subfontname>>=
/*
 * Default version: convert to file name
 */

char*
subfontname(char *cfname, char *fname, int maxdepth)
{
    char *t, *u, *tmp1, *tmp2;
    int i;

    t = strdup(cfname);  /* t is the return string */
    if(strcmp(cfname, "*default*") == 0)
        return t;
    if(t[0] != '/'){
        tmp2 = strdup(fname);
        u = utfrrune(tmp2, '/');
        if(u)
            u[0] = 0;
        else
            strcpy(tmp2, ".");
        tmp1 = smprint("%s/%s", tmp2, t);
        free(tmp2);
        free(t);
        t = tmp1;
    }

    if(maxdepth > 8)
        maxdepth = 8;

    for(i=3; i>=0; i--){
        if((1<<i) > maxdepth)
            continue;
        /* try i-bit grey */
        tmp2 = smprint("%s.%d", t, i);
        if(access(tmp2, AREAD) == 0) {
            free(t);
            return tmp2;
        }
        free(tmp2);
    }

    /* try default */
    if(access(t, AREAD) == 0)
        return t;

    free(t);
    return nil;
}
@
% >>


%-------------------------------------------------------------

<<lib_graphics/libdraw/subfontname.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function subfontname>>
@


\subsection*{[[lib_graphics/libdraw/unloadimage.c]]}


%-------------------------------------------------------------

<<lib_graphics/libdraw/unloadimage.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function unloadimage>>
@


\subsection*{[[lib_graphics/libdraw/window.c]]}


%-------------------------------------------------------------

<<lib_graphics/libdraw/window.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

typedef struct Memimage Memimage;

<<global screenid>>

<<function allocscreen>>

<<function publicscreen>>

<<function freescreen>>

<<function allocwindow>>

<<function _allocwindow>>

<<function topbottom>>

<<function bottomwindow>>

<<function topwindow>>

<<function bottomnwindows>>

<<function topnwindows>>

<<function originwindow>>
@


\subsection*{[[lib_graphics/libdraw/writecolmap.c]]}

<<function writecolmap>>=
/*
 * This code (and the devdraw interface) will have to change
 * if we ever get bitmaps with ldepth > 3, because the
 * colormap will have to be written in chunks
 */

void
writecolmap(Display *d, RGB *m)
{
    int i, n, fd;
    char buf[64], *t;
    ulong r, g, b;

    sprint(buf, "/dev/draw/%d/colormap", d->dirno);
    fd = open(buf, OWRITE);
    if(fd < 0)
        drawerror(d, "writecolmap: open colormap failed");
    t = malloc(8192);
    if (t == nil)
        drawerror(d, "writecolmap: no memory");
    n = 0;
    for(i = 0; i < 256; i++) {
        r = m[i].red>>24;
        g = m[i].green>>24;
        b = m[i].blue>>24;
        n += sprint(t+n, "%d %lud %lud %lud\n", 255-i, r, g, b);
    }
    i = write(fd, t, n);
    free(t);
    close(fd);
    if(i != n)
        drawerror(d, "writecolmap: bad write");
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/writecolmap.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function writecolmap>>
@


\subsection*{[[lib_graphics/libdraw/writeimage.c]]}

%-------------------------------------------------------------

<<lib_graphics/libdraw/writeimage.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<constant HSHIFT>>
<<constant NHASH>>
<<constant HMASK>>
<<function hupdate>>
typedef struct Hlist Hlist;
<<struct Hlist>>

<<function writeimage>>
@


\subsection*{[[lib_graphics/libdraw/writesubfont.c]]}

<<function packinfo>>=
static
void
packinfo(Fontchar *fc, uchar *p, int n)
{
    int j;

    for(j=0;  j<=n;  j++){
        p[0] = fc->x;
        p[1] = fc->x>>8;
        p[2] = fc->top;
        p[3] = fc->bottom;
        p[4] = fc->left;
        p[5] = fc->width;
        fc++;
        p += 6;
    }
}
@

<<function writesubfont>>=
int
writesubfont(int fd, Subfont *f)
{
    char hdr[3*12+1];
    uchar *data;
    int nb;

    sprint(hdr, "%11d %11d %11d ", f->n, f->height, f->ascent);
    if(write(fd, hdr, 3*12) != 3*12){
   Err:
        werrstr("writesubfont: bad write: %r");
        return -1;
    }
    nb = 6*(f->n+1);
    data = malloc(nb);
    if(data == nil)
        return -1;
    packinfo(f->info, data, f->n);
    if(write(fd, data, nb) != nb)
        goto Err;
    free(data);
    return 0;
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/writesubfont.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function packinfo>>

<<function writesubfont>>
@


\section{[[lib_graphics/libdraw/tests/]]}

\subsection*{[[lib_graphics/libdraw/tests/drawtest.c]]}

<<function main>>=
void
main(int argc, char **argv)
{
        print("%dn", wordsperline(Rect(atoi(argv[1]), atoi(argv[2]), atoi(argv[3]), atoi(argv[4])), atoi(argv[5])));
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/tests/drawtest.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function main>>
@


\section{[[lib_graphics/libmemdraw/]]}


\subsection*{[[lib_graphics/libmemdraw/alloc.c]]}

%-------------------------------------------------------------

<<lib_graphics/libmemdraw/alloc.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <pool.h>

<<function memimagemove>>

<<function allocmemimaged>>

<<function allocmemimage>>

<<function freememimage>>

<<function wordaddr>>

<<function byteaddr>>

<<function memsetchan>>
@


\subsection*{[[lib_graphics/libmemdraw/arc.c]]}

%-------------------------------------------------------------

<<lib_graphics/libmemdraw/arc.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<enum _anon_ (lib_graphics/libmemdraw/arc.c)>>

<<global corners>>

<<global p00>>

<<function memarc>>
@


\subsection*{[[lib_graphics/libmemdraw/cload.c]]}

%-------------------------------------------------------------

<<lib_graphics/libmemdraw/cload.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>

<<function cloadmemimage>>
@


\subsection*{[[lib_graphics/libmemdraw/cmap.c]]}

<<global def>>=
static Memcmap def = {
/* cmap2rgb */ {
    0x00,0x00,0x00,0x00,0x00,0x44,0x00,0x00,0x88,0x00,0x00,0xcc,0x00,0x44,0x00,0x00,
    0x44,0x44,0x00,0x44,0x88,0x00,0x44,0xcc,0x00,0x88,0x00,0x00,0x88,0x44,0x00,0x88,
    0x88,0x00,0x88,0xcc,0x00,0xcc,0x00,0x00,0xcc,0x44,0x00,0xcc,0x88,0x00,0xcc,0xcc,
    0x00,0xdd,0xdd,0x11,0x11,0x11,0x00,0x00,0x55,0x00,0x00,0x99,0x00,0x00,0xdd,0x00,
    0x55,0x00,0x00,0x55,0x55,0x00,0x4c,0x99,0x00,0x49,0xdd,0x00,0x99,0x00,0x00,0x99,
    0x4c,0x00,0x99,0x99,0x00,0x93,0xdd,0x00,0xdd,0x00,0x00,0xdd,0x49,0x00,0xdd,0x93,
    0x00,0xee,0x9e,0x00,0xee,0xee,0x22,0x22,0x22,0x00,0x00,0x66,0x00,0x00,0xaa,0x00,
    0x00,0xee,0x00,0x66,0x00,0x00,0x66,0x66,0x00,0x55,0xaa,0x00,0x4f,0xee,0x00,0xaa,
    0x00,0x00,0xaa,0x55,0x00,0xaa,0xaa,0x00,0x9e,0xee,0x00,0xee,0x00,0x00,0xee,0x4f,
    0x00,0xff,0x55,0x00,0xff,0xaa,0x00,0xff,0xff,0x33,0x33,0x33,0x00,0x00,0x77,0x00,
    0x00,0xbb,0x00,0x00,0xff,0x00,0x77,0x00,0x00,0x77,0x77,0x00,0x5d,0xbb,0x00,0x55,
    0xff,0x00,0xbb,0x00,0x00,0xbb,0x5d,0x00,0xbb,0xbb,0x00,0xaa,0xff,0x00,0xff,0x00,
    0x44,0x00,0x44,0x44,0x00,0x88,0x44,0x00,0xcc,0x44,0x44,0x00,0x44,0x44,0x44,0x44,
    0x44,0x88,0x44,0x44,0xcc,0x44,0x88,0x00,0x44,0x88,0x44,0x44,0x88,0x88,0x44,0x88,
    0xcc,0x44,0xcc,0x00,0x44,0xcc,0x44,0x44,0xcc,0x88,0x44,0xcc,0xcc,0x44,0x00,0x00,
    0x55,0x00,0x00,0x55,0x00,0x55,0x4c,0x00,0x99,0x49,0x00,0xdd,0x55,0x55,0x00,0x55,
    0x55,0x55,0x4c,0x4c,0x99,0x49,0x49,0xdd,0x4c,0x99,0x00,0x4c,0x99,0x4c,0x4c,0x99,
    0x99,0x49,0x93,0xdd,0x49,0xdd,0x00,0x49,0xdd,0x49,0x49,0xdd,0x93,0x49,0xdd,0xdd,
    0x4f,0xee,0xee,0x66,0x00,0x00,0x66,0x00,0x66,0x55,0x00,0xaa,0x4f,0x00,0xee,0x66,
    0x66,0x00,0x66,0x66,0x66,0x55,0x55,0xaa,0x4f,0x4f,0xee,0x55,0xaa,0x00,0x55,0xaa,
    0x55,0x55,0xaa,0xaa,0x4f,0x9e,0xee,0x4f,0xee,0x00,0x4f,0xee,0x4f,0x4f,0xee,0x9e,
    0x55,0xff,0xaa,0x55,0xff,0xff,0x77,0x00,0x00,0x77,0x00,0x77,0x5d,0x00,0xbb,0x55,
    0x00,0xff,0x77,0x77,0x00,0x77,0x77,0x77,0x5d,0x5d,0xbb,0x55,0x55,0xff,0x5d,0xbb,
    0x00,0x5d,0xbb,0x5d,0x5d,0xbb,0xbb,0x55,0xaa,0xff,0x55,0xff,0x00,0x55,0xff,0x55,
    0x88,0x00,0x88,0x88,0x00,0xcc,0x88,0x44,0x00,0x88,0x44,0x44,0x88,0x44,0x88,0x88,
    0x44,0xcc,0x88,0x88,0x00,0x88,0x88,0x44,0x88,0x88,0x88,0x88,0x88,0xcc,0x88,0xcc,
    0x00,0x88,0xcc,0x44,0x88,0xcc,0x88,0x88,0xcc,0xcc,0x88,0x00,0x00,0x88,0x00,0x44,
    0x99,0x00,0x4c,0x99,0x00,0x99,0x93,0x00,0xdd,0x99,0x4c,0x00,0x99,0x4c,0x4c,0x99,
    0x4c,0x99,0x93,0x49,0xdd,0x99,0x99,0x00,0x99,0x99,0x4c,0x99,0x99,0x99,0x93,0x93,
    0xdd,0x93,0xdd,0x00,0x93,0xdd,0x49,0x93,0xdd,0x93,0x93,0xdd,0xdd,0x99,0x00,0x00,
    0xaa,0x00,0x00,0xaa,0x00,0x55,0xaa,0x00,0xaa,0x9e,0x00,0xee,0xaa,0x55,0x00,0xaa,
    0x55,0x55,0xaa,0x55,0xaa,0x9e,0x4f,0xee,0xaa,0xaa,0x00,0xaa,0xaa,0x55,0xaa,0xaa,
    0xaa,0x9e,0x9e,0xee,0x9e,0xee,0x00,0x9e,0xee,0x4f,0x9e,0xee,0x9e,0x9e,0xee,0xee,
    0xaa,0xff,0xff,0xbb,0x00,0x00,0xbb,0x00,0x5d,0xbb,0x00,0xbb,0xaa,0x00,0xff,0xbb,
    0x5d,0x00,0xbb,0x5d,0x5d,0xbb,0x5d,0xbb,0xaa,0x55,0xff,0xbb,0xbb,0x00,0xbb,0xbb,
    0x5d,0xbb,0xbb,0xbb,0xaa,0xaa,0xff,0xaa,0xff,0x00,0xaa,0xff,0x55,0xaa,0xff,0xaa,
    0xcc,0x00,0xcc,0xcc,0x44,0x00,0xcc,0x44,0x44,0xcc,0x44,0x88,0xcc,0x44,0xcc,0xcc,
    0x88,0x00,0xcc,0x88,0x44,0xcc,0x88,0x88,0xcc,0x88,0xcc,0xcc,0xcc,0x00,0xcc,0xcc,
    0x44,0xcc,0xcc,0x88,0xcc,0xcc,0xcc,0xcc,0x00,0x00,0xcc,0x00,0x44,0xcc,0x00,0x88,
    0xdd,0x00,0x93,0xdd,0x00,0xdd,0xdd,0x49,0x00,0xdd,0x49,0x49,0xdd,0x49,0x93,0xdd,
    0x49,0xdd,0xdd,0x93,0x00,0xdd,0x93,0x49,0xdd,0x93,0x93,0xdd,0x93,0xdd,0xdd,0xdd,
    0x00,0xdd,0xdd,0x49,0xdd,0xdd,0x93,0xdd,0xdd,0xdd,0xdd,0x00,0x00,0xdd,0x00,0x49,
    0xee,0x00,0x4f,0xee,0x00,0x9e,0xee,0x00,0xee,0xee,0x4f,0x00,0xee,0x4f,0x4f,0xee,
    0x4f,0x9e,0xee,0x4f,0xee,0xee,0x9e,0x00,0xee,0x9e,0x4f,0xee,0x9e,0x9e,0xee,0x9e,
    0xee,0xee,0xee,0x00,0xee,0xee,0x4f,0xee,0xee,0x9e,0xee,0xee,0xee,0xee,0x00,0x00,
    0xff,0x00,0x00,0xff,0x00,0x55,0xff,0x00,0xaa,0xff,0x00,0xff,0xff,0x55,0x00,0xff,
    0x55,0x55,0xff,0x55,0xaa,0xff,0x55,0xff,0xff,0xaa,0x00,0xff,0xaa,0x55,0xff,0xaa,
    0xaa,0xff,0xaa,0xff,0xff,0xff,0x00,0xff,0xff,0x55,0xff,0xff,0xaa,0xff,0xff,0xff,
},
/* rgb2cmap */ {
    0x00,0x00,0x11,0x01,0x01,0x12,0x23,0x34,0x02,0x13,0x24,0x35,0x03,0x14,0x25,0x36,
    0x00,0x11,0x11,0x01,0x01,0x12,0x23,0x34,0x02,0x13,0x24,0x35,0x03,0x14,0x25,0x36,
    0x11,0x11,0x11,0x01,0x01,0x12,0x23,0x34,0x02,0x13,0x24,0x35,0x03,0x14,0x25,0x36,
    0x04,0x04,0x04,0x05,0x05,0x05,0x05,0x06,0x06,0x06,0x17,0x07,0x07,0x18,0x18,0x29,
    0x04,0x04,0x04,0x05,0x05,0x05,0x16,0x06,0x06,0x17,0x28,0x07,0x07,0x18,0x29,0x3a,
    0x15,0x15,0x15,0x05,0x05,0x16,0x16,0x06,0x06,0x17,0x28,0x39,0x07,0x18,0x29,0x3a,
    0x26,0x26,0x26,0x05,0x16,0x16,0x27,0x27,0x38,0x28,0x28,0x39,0x39,0x29,0x29,0x3a,
    0x37,0x37,0x37,0x09,0x09,0x09,0x27,0x38,0x0a,0x0a,0x39,0x0b,0x0b,0x0b,0x1c,0x3a,
    0x08,0x08,0x08,0x09,0x09,0x09,0x38,0x0a,0x0a,0x0a,0x1b,0x0b,0x0b,0x1c,0x1c,0x2d,
    0x19,0x19,0x19,0x09,0x1a,0x1a,0x2b,0x0a,0x0a,0x1b,0x1b,0x0b,0x0b,0x1c,0x2d,0x3e,
    0x2a,0x2a,0x2a,0x1a,0x2b,0x2b,0x2b,0x3c,0x1b,0x1b,0x2c,0x2c,0x3d,0x2d,0x2d,0x3e,
    0x3b,0x3b,0x3b,0x0d,0x0d,0x3c,0x3c,0x0e,0x0e,0x0e,0x2c,0x3d,0x0f,0x0f,0x3e,0x3e,
    0x0c,0x0c,0x0c,0x0d,0x0d,0x0d,0x3c,0x0e,0x0e,0x0e,0x3d,0x0f,0x0f,0x0f,0x10,0x3e,
    0x1d,0x1d,0x1d,0x1e,0x1e,0x1e,0x2f,0x0e,0x1f,0x1f,0x20,0x0f,0x0f,0x10,0x10,0x21,
    0x2e,0x2e,0x2e,0x1e,0x2f,0x2f,0x2f,0x1f,0x1f,0x20,0x20,0x31,0x10,0x10,0x21,0x21,
    0x3f,0x3f,0x3f,0x2f,0x30,0x30,0x30,0x30,0x20,0x31,0x31,0x31,0x31,0x21,0x21,0x32,
    0x00,0x11,0x11,0x01,0x01,0x12,0x23,0x34,0x02,0x13,0x24,0x35,0x03,0x14,0x25,0x36,
    0x11,0x11,0x11,0x01,0x01,0x12,0x23,0x34,0x02,0x13,0x24,0x35,0x03,0x14,0x25,0x36,
    0x11,0x11,0x22,0x22,0x01,0x12,0x23,0x34,0x02,0x13,0x24,0x35,0x03,0x14,0x25,0x36,
    0x04,0x04,0x22,0x05,0x05,0x05,0x05,0x06,0x06,0x06,0x17,0x07,0x07,0x18,0x18,0x29,
    0x04,0x04,0x04,0x05,0x05,0x05,0x16,0x06,0x06,0x17,0x28,0x07,0x07,0x18,0x29,0x3a,
    0x15,0x15,0x15,0x05,0x05,0x16,0x16,0x06,0x06,0x17,0x28,0x39,0x07,0x18,0x29,0x3a,
    0x26,0x26,0x26,0x05,0x16,0x16,0x27,0x27,0x38,0x28,0x28,0x39,0x39,0x29,0x29,0x3a,
    0x37,0x37,0x37,0x09,0x09,0x09,0x27,0x38,0x0a,0x0a,0x39,0x0b,0x0b,0x0b,0x1c,0x3a,
    0x08,0x08,0x08,0x09,0x09,0x09,0x38,0x0a,0x0a,0x0a,0x1b,0x0b,0x0b,0x1c,0x1c,0x2d,
    0x19,0x19,0x19,0x09,0x1a,0x1a,0x2b,0x0a,0x0a,0x1b,0x1b,0x0b,0x0b,0x1c,0x2d,0x3e,
    0x2a,0x2a,0x2a,0x1a,0x2b,0x2b,0x2b,0x3c,0x1b,0x1b,0x2c,0x2c,0x3d,0x2d,0x2d,0x3e,
    0x3b,0x3b,0x3b,0x0d,0x0d,0x3c,0x3c,0x0e,0x0e,0x0e,0x2c,0x3d,0x0f,0x0f,0x3e,0x3e,
    0x0c,0x0c,0x0c,0x0d,0x0d,0x0d,0x3c,0x0e,0x0e,0x0e,0x3d,0x0f,0x0f,0x0f,0x10,0x3e,
    0x1d,0x1d,0x1d,0x1e,0x1e,0x1e,0x2f,0x0e,0x1f,0x1f,0x20,0x0f,0x0f,0x10,0x10,0x21,
    0x2e,0x2e,0x2e,0x1e,0x2f,0x2f,0x2f,0x1f,0x1f,0x20,0x20,0x31,0x10,0x10,0x21,0x21,
    0x3f,0x3f,0x3f,0x2f,0x30,0x30,0x30,0x30,0x20,0x31,0x31,0x31,0x31,0x21,0x21,0x32,
    0x11,0x11,0x11,0x01,0x01,0x12,0x23,0x34,0x02,0x13,0x24,0x35,0x03,0x14,0x25,0x36,
    0x11,0x11,0x22,0x22,0x01,0x12,0x23,0x34,0x02,0x13,0x24,0x35,0x03,0x14,0x25,0x36,
    0x11,0x22,0x22,0x22,0x33,0x33,0x23,0x34,0x02,0x13,0x24,0x35,0x03,0x14,0x25,0x36,
    0x04,0x22,0x22,0x33,0x33,0x33,0x05,0x06,0x06,0x06,0x17,0x07,0x07,0x18,0x18,0x29,
    0x04,0x04,0x33,0x33,0x33,0x05,0x16,0x06,0x06,0x17,0x28,0x07,0x07,0x18,0x29,0x3a,
    0x15,0x15,0x33,0x33,0x05,0x16,0x16,0x06,0x06,0x17,0x28,0x39,0x07,0x18,0x29,0x3a,
    0x26,0x26,0x26,0x05,0x16,0x16,0x27,0x27,0x38,0x28,0x28,0x39,0x39,0x29,0x29,0x3a,
    0x37,0x37,0x37,0x09,0x09,0x09,0x27,0x38,0x0a,0x0a,0x39,0x0b,0x0b,0x0b,0x1c,0x3a,
    0x08,0x08,0x08,0x09,0x09,0x09,0x38,0x0a,0x0a,0x0a,0x1b,0x0b,0x0b,0x1c,0x1c,0x2d,
    0x19,0x19,0x19,0x09,0x1a,0x1a,0x2b,0x0a,0x0a,0x1b,0x1b,0x0b,0x0b,0x1c,0x2d,0x3e,
    0x2a,0x2a,0x2a,0x1a,0x2b,0x2b,0x2b,0x3c,0x1b,0x1b,0x2c,0x2c,0x3d,0x2d,0x2d,0x3e,
    0x3b,0x3b,0x3b,0x0d,0x0d,0x3c,0x3c,0x0e,0x0e,0x0e,0x2c,0x3d,0x0f,0x0f,0x3e,0x3e,
    0x0c,0x0c,0x0c,0x0d,0x0d,0x0d,0x3c,0x0e,0x0e,0x0e,0x3d,0x0f,0x0f,0x0f,0x10,0x3e,
    0x1d,0x1d,0x1d,0x1e,0x1e,0x1e,0x2f,0x0e,0x1f,0x1f,0x20,0x0f,0x0f,0x10,0x10,0x21,
    0x2e,0x2e,0x2e,0x1e,0x2f,0x2f,0x2f,0x1f,0x1f,0x20,0x20,0x31,0x10,0x10,0x21,0x21,
    0x3f,0x3f,0x3f,0x2f,0x30,0x30,0x30,0x30,0x20,0x31,0x31,0x31,0x31,0x21,0x21,0x32,
    0x4f,0x4f,0x22,0x40,0x40,0x40,0x40,0x41,0x41,0x41,0x52,0x42,0x42,0x53,0x53,0x64,
    0x4f,0x22,0x22,0x22,0x40,0x40,0x40,0x41,0x41,0x41,0x52,0x42,0x42,0x53,0x53,0x64,
    0x22,0x22,0x22,0x33,0x33,0x33,0x40,0x41,0x41,0x41,0x52,0x42,0x42,0x53,0x53,0x64,
    0x43,0x22,0x33,0x33,0x33,0x44,0x44,0x45,0x45,0x45,0x56,0x46,0x46,0x46,0x57,0x68,
    0x43,0x43,0x33,0x33,0x44,0x44,0x44,0x45,0x45,0x45,0x56,0x46,0x46,0x57,0x57,0x68,
    0x43,0x43,0x33,0x44,0x44,0x44,0x55,0x45,0x45,0x56,0x56,0x46,0x46,0x57,0x68,0x68,
    0x43,0x43,0x43,0x44,0x44,0x55,0x55,0x45,0x45,0x56,0x67,0x46,0x46,0x57,0x68,0x79,
    0x47,0x47,0x47,0x48,0x48,0x48,0x48,0x49,0x49,0x49,0x49,0x4a,0x4a,0x4a,0x5b,0x79,
    0x47,0x47,0x47,0x48,0x48,0x48,0x48,0x49,0x49,0x49,0x5a,0x4a,0x4a,0x4a,0x5b,0x6c,
    0x47,0x47,0x47,0x48,0x48,0x59,0x59,0x49,0x49,0x5a,0x5a,0x4a,0x4a,0x5b,0x5b,0x6c,
    0x58,0x58,0x58,0x59,0x59,0x59,0x6a,0x49,0x5a,0x5a,0x6b,0x6b,0x5b,0x5b,0x6c,0x7d,
    0x4b,0x4b,0x4b,0x4c,0x4c,0x4c,0x4c,0x4d,0x4d,0x4d,0x6b,0x4e,0x4e,0x4e,0x6c,0x7d,
    0x4b,0x4b,0x4b,0x4c,0x4c,0x4c,0x4c,0x4d,0x4d,0x4d,0x5e,0x4e,0x4e,0x4e,0x5f,0x5f,
    0x5c,0x5c,0x5c,0x4c,0x5d,0x5d,0x5d,0x4d,0x4d,0x5e,0x5e,0x4e,0x4e,0x5f,0x5f,0x60,
    0x5c,0x5c,0x5c,0x5d,0x5d,0x6e,0x6e,0x5e,0x5e,0x5e,0x6f,0x6f,0x5f,0x5f,0x60,0x60,
    0x6d,0x6d,0x6d,0x6e,0x6e,0x6e,0x7f,0x7f,0x6f,0x6f,0x70,0x70,0x5f,0x60,0x60,0x71,
    0x4f,0x4f,0x40,0x40,0x40,0x40,0x51,0x41,0x41,0x52,0x63,0x42,0x42,0x53,0x64,0x75,
    0x4f,0x4f,0x22,0x40,0x40,0x40,0x51,0x41,0x41,0x52,0x63,0x42,0x42,0x53,0x64,0x75,
    0x43,0x22,0x33,0x33,0x33,0x40,0x51,0x41,0x41,0x52,0x63,0x42,0x42,0x53,0x64,0x75,
    0x43,0x43,0x33,0x33,0x44,0x44,0x44,0x45,0x45,0x45,0x56,0x46,0x46,0x57,0x57,0x68,
    0x43,0x43,0x33,0x44,0x44,0x44,0x55,0x45,0x45,0x56,0x56,0x46,0x46,0x57,0x68,0x68,
    0x43,0x43,0x43,0x44,0x44,0x55,0x55,0x45,0x45,0x56,0x67,0x46,0x46,0x57,0x68,0x79,
    0x54,0x54,0x54,0x44,0x55,0x55,0x55,0x45,0x56,0x56,0x67,0x78,0x78,0x57,0x68,0x79,
    0x47,0x47,0x47,0x48,0x48,0x48,0x48,0x49,0x49,0x49,0x49,0x4a,0x4a,0x4a,0x5b,0x79,
    0x47,0x47,0x47,0x48,0x48,0x48,0x59,0x49,0x49,0x49,0x5a,0x4a,0x4a,0x5b,0x5b,0x6c,
    0x58,0x58,0x58,0x48,0x59,0x59,0x59,0x49,0x49,0x5a,0x5a,0x4a,0x4a,0x5b,0x6c,0x6c,
    0x69,0x69,0x69,0x59,0x59,0x6a,0x6a,0x49,0x5a,0x5a,0x6b,0x6b,0x5b,0x5b,0x6c,0x7d,
    0x4b,0x4b,0x4b,0x4c,0x4c,0x4c,0x7b,0x4d,0x4d,0x4d,0x6b,0x4e,0x4e,0x4e,0x7d,0x7d,
    0x4b,0x4b,0x4b,0x4c,0x4c,0x4c,0x7b,0x4d,0x4d,0x4d,0x5e,0x4e,0x4e,0x4e,0x5f,0x7d,
    0x5c,0x5c,0x5c,0x5d,0x5d,0x5d,0x5d,0x4d,0x5e,0x5e,0x5e,0x4e,0x4e,0x5f,0x5f,0x60,
    0x6d,0x6d,0x6d,0x5d,0x6e,0x6e,0x6e,0x5e,0x5e,0x6f,0x6f,0x70,0x5f,0x5f,0x60,0x60,
    0x7e,0x7e,0x7e,0x6e,0x6e,0x7f,0x7f,0x7f,0x6f,0x6f,0x70,0x70,0x70,0x60,0x60,0x71,
    0x50,0x50,0x50,0x40,0x40,0x51,0x51,0x41,0x41,0x52,0x63,0x74,0x42,0x53,0x64,0x75,
    0x50,0x50,0x50,0x40,0x40,0x51,0x51,0x41,0x41,0x52,0x63,0x74,0x42,0x53,0x64,0x75,
    0x50,0x50,0x33,0x33,0x40,0x51,0x51,0x41,0x41,0x52,0x63,0x74,0x42,0x53,0x64,0x75,
    0x43,0x43,0x33,0x44,0x44,0x44,0x55,0x45,0x45,0x56,0x56,0x46,0x46,0x57,0x68,0x68,
    0x43,0x43,0x43,0x44,0x44,0x55,0x55,0x45,0x45,0x56,0x67,0x46,0x46,0x57,0x68,0x79,
    0x54,0x54,0x54,0x44,0x55,0x55,0x55,0x45,0x56,0x56,0x67,0x78,0x78,0x57,0x68,0x79,
    0x54,0x54,0x54,0x55,0x55,0x55,0x66,0x66,0x56,0x67,0x67,0x78,0x78,0x68,0x68,0x79,
    0x47,0x47,0x47,0x48,0x48,0x48,0x66,0x49,0x49,0x49,0x78,0x78,0x4a,0x4a,0x5b,0x79,
    0x47,0x47,0x47,0x48,0x48,0x59,0x59,0x49,0x49,0x5a,0x5a,0x4a,0x4a,0x5b,0x6c,0x6c,
    0x58,0x58,0x58,0x59,0x59,0x59,0x6a,0x49,0x5a,0x5a,0x6b,0x6b,0x5b,0x5b,0x6c,0x7d,
    0x69,0x69,0x69,0x59,0x6a,0x6a,0x6a,0x7b,0x5a,0x6b,0x6b,0x6b,0x7c,0x6c,0x6c,0x7d,
    0x7a,0x7a,0x7a,0x4c,0x4c,0x7b,0x7b,0x7b,0x4d,0x6b,0x6b,0x7c,0x7c,0x4e,0x7d,0x7d,
    0x4b,0x4b,0x4b,0x4c,0x4c,0x7b,0x7b,0x4d,0x4d,0x5e,0x7c,0x7c,0x4e,0x5f,0x5f,0x7d,
    0x5c,0x5c,0x5c,0x5d,0x5d,0x5d,0x6e,0x4d,0x5e,0x5e,0x6f,0x4e,0x5f,0x5f,0x60,0x60,
    0x6d,0x6d,0x6d,0x6e,0x6e,0x6e,0x6e,0x5e,0x6f,0x6f,0x6f,0x70,0x5f,0x60,0x60,0x71,
    0x7e,0x7e,0x7e,0x6e,0x7f,0x7f,0x7f,0x7f,0x6f,0x70,0x70,0x70,0x70,0x60,0x71,0x71,
    0x61,0x61,0x61,0x40,0x51,0x51,0x62,0x62,0x73,0x63,0x63,0x74,0x74,0x64,0x64,0x75,
    0x61,0x61,0x61,0x40,0x51,0x51,0x62,0x62,0x73,0x63,0x63,0x74,0x74,0x64,0x64,0x75,
    0x61,0x61,0x61,0x40,0x51,0x51,0x62,0x62,0x73,0x63,0x63,0x74,0x74,0x64,0x64,0x75,
    0x43,0x43,0x43,0x44,0x44,0x55,0x55,0x45,0x45,0x56,0x67,0x46,0x46,0x57,0x68,0x79,
    0x54,0x54,0x54,0x44,0x55,0x55,0x55,0x45,0x56,0x56,0x67,0x78,0x78,0x57,0x68,0x79,
    0x54,0x54,0x54,0x55,0x55,0x55,0x66,0x66,0x56,0x67,0x67,0x78,0x78,0x68,0x68,0x79,
    0x65,0x65,0x65,0x55,0x55,0x66,0x66,0x66,0x77,0x67,0x78,0x78,0x78,0x78,0x79,0x79,
    0x65,0x65,0x65,0x48,0x48,0x66,0x66,0x77,0x77,0x77,0x78,0x78,0x78,0x5b,0x79,0x79,
    0x76,0x76,0x76,0x48,0x59,0x59,0x77,0x77,0x77,0x5a,0x5a,0x4a,0x4a,0x5b,0x6c,0x6c,
    0x69,0x69,0x69,0x59,0x59,0x6a,0x6a,0x77,0x5a,0x5a,0x6b,0x6b,0x5b,0x6c,0x6c,0x7d,
    0x69,0x69,0x69,0x6a,0x6a,0x6a,0x7b,0x7b,0x5a,0x6b,0x6b,0x7c,0x7c,0x6c,0x7d,0x7d,
    0x7a,0x7a,0x7a,0x4c,0x7b,0x7b,0x7b,0x7b,0x4d,0x6b,0x7c,0x7c,0x7c,0x7c,0x7d,0x7d,
    0x7a,0x7a,0x7a,0x4c,0x7b,0x7b,0x7b,0x7b,0x4d,0x5e,0x7c,0x7c,0x7c,0x5f,0x5f,0x7d,
    0x6d,0x6d,0x6d,0x5d,0x5d,0x6e,0x7b,0x5e,0x5e,0x6f,0x6f,0x7c,0x5f,0x5f,0x60,0x60,
    0x6d,0x6d,0x6d,0x6e,0x6e,0x6e,0x7f,0x7f,0x6f,0x6f,0x70,0x70,0x5f,0x60,0x60,0x71,
    0x7e,0x7e,0x7e,0x7f,0x7f,0x7f,0x7f,0x7f,0x6f,0x70,0x70,0x70,0x70,0x60,0x71,0x71,
    0x72,0x72,0x72,0x8f,0x8f,0x62,0x62,0x73,0x73,0x80,0x74,0x81,0x81,0x81,0x92,0x75,
    0x72,0x72,0x72,0x8f,0x8f,0x62,0x62,0x73,0x73,0x80,0x74,0x81,0x81,0x81,0x92,0x75,
    0x72,0x72,0x72,0x83,0x83,0x62,0x62,0x73,0x73,0x80,0x74,0x81,0x81,0x81,0x92,0x75,
    0x82,0x82,0x82,0x83,0x83,0x83,0x83,0x84,0x84,0x84,0x84,0x85,0x85,0x85,0x96,0x79,
    0x82,0x82,0x82,0x83,0x83,0x83,0x66,0x84,0x84,0x84,0x67,0x85,0x85,0x85,0x96,0x79,
    0x65,0x65,0x65,0x83,0x83,0x66,0x66,0x66,0x84,0x84,0x78,0x78,0x85,0x85,0x96,0x79,
    0x65,0x65,0x65,0x83,0x66,0x66,0x66,0x77,0x77,0x77,0x78,0x78,0x78,0x96,0x79,0x79,
    0x76,0x76,0x76,0x87,0x87,0x66,0x77,0x77,0x77,0x88,0x78,0x89,0x89,0x89,0x89,0x79,
    0x76,0x76,0x76,0x87,0x87,0x87,0x77,0x77,0x88,0x88,0x88,0x89,0x89,0x89,0x9a,0x9a,
    0x86,0x86,0x86,0x87,0x87,0x87,0x77,0x88,0x88,0x88,0x6b,0x89,0x89,0x9a,0x9a,0x7d,
    0x7a,0x7a,0x7a,0x87,0x6a,0x7b,0x7b,0x7b,0x88,0x6b,0x6b,0x7c,0x7c,0x9a,0x7d,0x7d,
    0x8a,0x8a,0x8a,0x8b,0x8b,0x7b,0x7b,0x8c,0x8c,0x8c,0x7c,0x7c,0x8d,0x8d,0x7d,0x7d,
    0x8a,0x8a,0x8a,0x8b,0x8b,0x8b,0x7b,0x8c,0x8c,0x8c,0x7c,0x8d,0x8d,0x8d,0x9e,0x9e,
    0x8a,0x8a,0x8a,0x8b,0x8b,0x8b,0x9c,0x8c,0x8c,0x9d,0x9d,0x8d,0x8d,0x9e,0x9e,0x9e,
    0x9b,0x9b,0x9b,0x9c,0x9c,0x9c,0x7f,0x8c,0x9d,0x9d,0x70,0x70,0x9e,0x9e,0x9e,0x71,
    0x7e,0x7e,0x7e,0x7f,0x7f,0x7f,0x7f,0x7f,0x9d,0x70,0x70,0x70,0x9e,0x9e,0x71,0x71,
    0x8e,0x8e,0x8e,0x8f,0x8f,0x8f,0x73,0x73,0x80,0x80,0x91,0x81,0x81,0x92,0x92,0xa3,
    0x8e,0x8e,0x8e,0x8f,0x8f,0x8f,0x73,0x73,0x80,0x80,0x91,0x81,0x81,0x92,0x92,0xa3,
    0x82,0x82,0x82,0x83,0x83,0x83,0x73,0x73,0x80,0x80,0x91,0x81,0x81,0x92,0x92,0xa3,
    0x82,0x82,0x82,0x83,0x83,0x83,0x83,0x84,0x84,0x84,0x95,0x85,0x85,0x85,0x96,0xa7,
    0x82,0x82,0x82,0x83,0x83,0x83,0x94,0x84,0x84,0x84,0x95,0x85,0x85,0x96,0x96,0xa7,
    0x82,0x82,0x82,0x83,0x83,0x94,0x94,0x84,0x84,0x95,0x95,0x85,0x85,0x96,0xa7,0xa7,
    0x76,0x76,0x76,0x83,0x94,0x94,0x77,0x77,0x77,0x95,0x95,0x85,0x85,0x96,0xa7,0xa7,
    0x76,0x76,0x76,0x87,0x87,0x87,0x77,0x77,0x88,0x88,0x88,0x89,0x89,0x89,0x9a,0x9a,
    0x86,0x86,0x86,0x87,0x87,0x87,0x77,0x88,0x88,0x88,0x99,0x89,0x89,0x9a,0x9a,0xab,
    0x86,0x86,0x86,0x87,0x87,0x98,0x98,0x88,0x88,0x99,0x99,0x89,0x89,0x9a,0x9a,0xab,
    0x97,0x97,0x97,0x98,0x98,0x98,0x98,0x88,0x99,0x99,0x99,0x89,0x9a,0x9a,0xab,0xab,
    0x8a,0x8a,0x8a,0x8b,0x8b,0x8b,0x8b,0x8c,0x8c,0x8c,0x8c,0x8d,0x8d,0x8d,0xab,0xbc,
    0x8a,0x8a,0x8a,0x8b,0x8b,0x8b,0x8b,0x8c,0x8c,0x8c,0x9d,0x8d,0x8d,0x8d,0x9e,0x9e,
    0x9b,0x9b,0x9b,0x8b,0x9c,0x9c,0x9c,0x8c,0x9d,0x9d,0x9d,0x8d,0x8d,0x9e,0x9e,0xaf,
    0x9b,0x9b,0x9b,0x9c,0x9c,0xad,0xad,0x9d,0x9d,0x9d,0xae,0xae,0x9e,0x9e,0xaf,0xaf,
    0xac,0xac,0xac,0xad,0xad,0xad,0xad,0x9d,0xae,0xae,0xae,0xbf,0x9e,0xaf,0xaf,0xaf,
    0x9f,0x9f,0x9f,0x8f,0x90,0x90,0xa1,0x80,0x80,0x91,0x91,0x81,0x81,0x92,0xa3,0xb4,
    0x9f,0x9f,0x9f,0x8f,0x90,0x90,0xa1,0x80,0x80,0x91,0x91,0x81,0x81,0x92,0xa3,0xb4,
    0x9f,0x9f,0x9f,0x83,0x90,0x90,0xa1,0x80,0x80,0x91,0x91,0x81,0x81,0x92,0xa3,0xb4,
    0x82,0x82,0x82,0x83,0x83,0x94,0x94,0x84,0x84,0x95,0x95,0x85,0x85,0x96,0x96,0xa7,
    0x93,0x93,0x93,0x83,0x94,0x94,0x94,0x84,0x84,0x95,0x95,0x85,0x85,0x96,0xa7,0xa7,
    0x93,0x93,0x93,0x94,0x94,0x94,0xa5,0x84,0x95,0x95,0xa6,0xa6,0x96,0x96,0xa7,0xb8,
    0xa4,0xa4,0xa4,0x94,0x94,0xa5,0xa5,0x77,0x95,0x95,0xa6,0xa6,0x96,0xa7,0xa7,0xb8,
    0x86,0x86,0x86,0x87,0x87,0x87,0x77,0x88,0x88,0x88,0x99,0x89,0x89,0x9a,0x9a,0xb8,
    0x86,0x86,0x86,0x87,0x87,0x98,0x98,0x88,0x88,0x99,0x99,0x89,0x89,0x9a,0x9a,0xab,
    0x97,0x97,0x97,0x98,0x98,0x98,0x98,0x88,0x99,0x99,0x99,0x89,0x9a,0x9a,0xab,0xab,
    0x97,0x97,0x97,0x98,0x98,0xa9,0xa9,0x99,0x99,0x99,0xaa,0xaa,0x9a,0xab,0xab,0xbc,
    0x8a,0x8a,0x8a,0x8b,0x8b,0xa9,0xa9,0x8c,0x8c,0x8c,0xaa,0x8d,0x8d,0x8d,0xab,0xbc,
    0x8a,0x8a,0x8a,0x8b,0x8b,0x9c,0x9c,0x8c,0x8c,0x9d,0x9d,0x8d,0x8d,0x9e,0x9e,0xbc,
    0x9b,0x9b,0x9b,0x9c,0x9c,0x9c,0xad,0x9d,0x9d,0x9d,0xae,0x8d,0x9e,0x9e,0xaf,0xaf,
    0xac,0xac,0xac,0x9c,0xad,0xad,0xad,0x9d,0x9d,0xae,0xae,0xae,0x9e,0xaf,0xaf,0xaf,
    0xbd,0xbd,0xbd,0xad,0xad,0xbe,0xbe,0xbe,0xae,0xae,0xbf,0xbf,0xbf,0xaf,0xaf,0xb0,
    0xa0,0xa0,0xa0,0x90,0xa1,0xa1,0xa1,0xb2,0x91,0x91,0xa2,0xa2,0xb3,0xa3,0xa3,0xb4,
    0xa0,0xa0,0xa0,0x90,0xa1,0xa1,0xa1,0xb2,0x91,0x91,0xa2,0xa2,0xb3,0xa3,0xa3,0xb4,
    0xa0,0xa0,0xa0,0x90,0xa1,0xa1,0xa1,0xb2,0x91,0x91,0xa2,0xa2,0xb3,0xa3,0xa3,0xb4,
    0x93,0x93,0x93,0x94,0x94,0x94,0xa5,0x84,0x95,0x95,0xa6,0xa6,0x96,0x96,0xa7,0xb8,
    0xa4,0xa4,0xa4,0x94,0x94,0xa5,0xa5,0x84,0x95,0x95,0xa6,0xa6,0x96,0x96,0xa7,0xb8,
    0xa4,0xa4,0xa4,0x94,0xa5,0xa5,0xa5,0xb6,0x95,0xa6,0xa6,0xa6,0xb7,0xa7,0xa7,0xb8,
    0xa4,0xa4,0xa4,0xa5,0xa5,0xa5,0xb6,0xb6,0x95,0xa6,0xa6,0xb7,0xb7,0xa7,0xb8,0xb8,
    0xb5,0xb5,0xb5,0x87,0x87,0xb6,0xb6,0xb6,0x88,0x99,0xa6,0xb7,0xb7,0x9a,0xb8,0xb8,
    0x97,0x97,0x97,0x98,0x98,0x98,0x98,0x88,0x99,0x99,0x99,0x89,0x9a,0x9a,0xab,0xab,
    0x97,0x97,0x97,0x98,0x98,0xa9,0xa9,0x99,0x99,0x99,0xaa,0xaa,0x9a,0xab,0xab,0xbc,
    0xa8,0xa8,0xa8,0xa9,0xa9,0xa9,0xa9,0xa9,0x99,0xaa,0xaa,0xaa,0xbb,0xab,0xab,0xbc,
    0xa8,0xa8,0xa8,0xa9,0xa9,0xa9,0xba,0xba,0x8c,0xaa,0xaa,0xbb,0xbb,0xab,0xbc,0xbc,
    0xb9,0xb9,0xb9,0x9c,0x9c,0xba,0xba,0xba,0x9d,0x9d,0xbb,0xbb,0xbb,0x9e,0x9e,0xbc,
    0xac,0xac,0xac,0x9c,0x9c,0xad,0xad,0x9d,0x9d,0xae,0xae,0xae,0x9e,0x9e,0xaf,0xaf,
    0xac,0xac,0xac,0xad,0xad,0xad,0xbe,0xbe,0xae,0xae,0xae,0xbf,0x9e,0xaf,0xaf,0xb0,
    0xbd,0xbd,0xbd,0xbe,0xbe,0xbe,0xbe,0xbe,0xae,0xbf,0xbf,0xbf,0xbf,0xaf,0xb0,0xb0,
    0xb1,0xb1,0xb1,0xce,0xce,0xb2,0xb2,0xcf,0xcf,0xa2,0xa2,0xb3,0xb3,0xc0,0xb4,0xb4,
    0xb1,0xb1,0xb1,0xce,0xce,0xb2,0xb2,0xcf,0xcf,0xa2,0xa2,0xb3,0xb3,0xc0,0xb4,0xb4,
    0xb1,0xb1,0xb1,0xc2,0xc2,0xb2,0xb2,0xc3,0xc3,0xa2,0xa2,0xb3,0xb3,0xc0,0xb4,0xb4,
    0xc1,0xc1,0xc1,0xc2,0xc2,0xc2,0xa5,0xc3,0xc3,0xc3,0xa6,0xc4,0xc4,0xc4,0xa7,0xb8,
    0xc1,0xc1,0xc1,0xc2,0xc2,0xa5,0xb6,0xc3,0xc3,0xc3,0xa6,0xc4,0xc4,0xc4,0xb8,0xb8,
    0xb5,0xb5,0xb5,0xc2,0xa5,0xb6,0xb6,0xb6,0xc3,0xa6,0xa6,0xb7,0xb7,0xc4,0xb8,0xb8,
    0xb5,0xb5,0xb5,0xa5,0xb6,0xb6,0xb6,0xb6,0xc3,0xa6,0xb7,0xb7,0xb7,0xb7,0xb8,0xb8,
    0xc5,0xc5,0xc5,0xc6,0xc6,0xb6,0xb6,0xc7,0xc7,0xc7,0xb7,0xb7,0xc8,0xc8,0xb8,0xb8,
    0xc5,0xc5,0xc5,0xc6,0xc6,0xc6,0xc6,0xc7,0xc7,0xc7,0xaa,0xc8,0xc8,0xc8,0xab,0xbc,
    0xa8,0xa8,0xa8,0xc6,0xc6,0xa9,0xa9,0xc7,0xc7,0xaa,0xaa,0xaa,0xc8,0xc8,0xab,0xbc,
    0xa8,0xa8,0xa8,0xa9,0xa9,0xa9,0xba,0xba,0xaa,0xaa,0xaa,0xbb,0xbb,0xab,0xbc,0xbc,
    0xb9,0xb9,0xb9,0xca,0xca,0xba,0xba,0xba,0xcb,0xaa,0xbb,0xbb,0xbb,0xcc,0xbc,0xbc,
    0xb9,0xb9,0xb9,0xca,0xca,0xba,0xba,0xcb,0xcb,0xcb,0xbb,0xbb,0xcc,0xcc,0xcc,0xbc,
    0xc9,0xc9,0xc9,0xca,0xca,0xca,0xba,0xcb,0xcb,0xcb,0xae,0xcc,0xcc,0xcc,0xaf,0xaf,
    0xbd,0xbd,0xbd,0xad,0xbe,0xbe,0xbe,0xbe,0xae,0xae,0xbf,0xbf,0xcc,0xaf,0xaf,0xb0,
    0xbd,0xbd,0xbd,0xbe,0xbe,0xbe,0xbe,0xbe,0xbf,0xbf,0xbf,0xbf,0xbf,0xaf,0xb0,0xb0,
    0xcd,0xcd,0xcd,0xce,0xce,0xce,0xb2,0xcf,0xcf,0xcf,0xb3,0xb3,0xc0,0xc0,0xd1,0xb4,
    0xcd,0xcd,0xcd,0xce,0xce,0xce,0xb2,0xcf,0xcf,0xcf,0xb3,0xb3,0xc0,0xc0,0xd1,0xb4,
    0xc1,0xc1,0xc1,0xc2,0xc2,0xc2,0xb2,0xc3,0xc3,0xc3,0xb3,0xb3,0xc0,0xc0,0xd1,0xb4,
    0xc1,0xc1,0xc1,0xc2,0xc2,0xc2,0xc2,0xc3,0xc3,0xc3,0xd4,0xc4,0xc4,0xc4,0xd5,0xd5,
    0xc1,0xc1,0xc1,0xc2,0xc2,0xc2,0xb6,0xc3,0xc3,0xc3,0xd4,0xc4,0xc4,0xc4,0xd5,0xb8,
    0xc1,0xc1,0xc1,0xc2,0xc2,0xb6,0xb6,0xc3,0xc3,0xd4,0xb7,0xb7,0xc4,0xd5,0xd5,0xb8,
    0xb5,0xb5,0xb5,0xc2,0xb6,0xb6,0xb6,0xb6,0xc3,0xd4,0xb7,0xb7,0xb7,0xd5,0xd5,0xb8,
    0xc5,0xc5,0xc5,0xc6,0xc6,0xc6,0xb6,0xc7,0xc7,0xc7,0xb7,0xc8,0xc8,0xc8,0xd9,0xd9,
    0xc5,0xc5,0xc5,0xc6,0xc6,0xc6,0xc6,0xc7,0xc7,0xc7,0xd8,0xc8,0xc8,0xc8,0xd9,0xd9,
    0xc5,0xc5,0xc5,0xc6,0xc6,0xd7,0xd7,0xc7,0xc7,0xd8,0xd8,0xc8,0xc8,0xd9,0xd9,0xbc,
    0xb9,0xb9,0xb9,0xd7,0xd7,0xba,0xba,0xba,0xd8,0xd8,0xbb,0xbb,0xbb,0xd9,0xd9,0xbc,
    0xb9,0xb9,0xb9,0xca,0xca,0xba,0xba,0xcb,0xcb,0xcb,0xbb,0xbb,0xcc,0xcc,0xcc,0xbc,
    0xc9,0xc9,0xc9,0xca,0xca,0xca,0xba,0xcb,0xcb,0xcb,0xbb,0xcc,0xcc,0xcc,0xdd,0xdd,
    0xc9,0xc9,0xc9,0xca,0xca,0xdb,0xdb,0xcb,0xcb,0xdc,0xdc,0xcc,0xcc,0xdd,0xdd,0xdd,
    0xda,0xda,0xda,0xdb,0xdb,0xdb,0xdb,0xdc,0xdc,0xdc,0xdc,0xcc,0xdd,0xdd,0xdd,0xb0,
    0xbd,0xbd,0xbd,0xdb,0xbe,0xbe,0xbe,0xdc,0xdc,0xbf,0xbf,0xbf,0xdd,0xdd,0xb0,0xb0,
    0xde,0xde,0xde,0xdf,0xdf,0xdf,0xe0,0xcf,0xd0,0xd0,0xe1,0xc0,0xc0,0xd1,0xd1,0xe2,
    0xde,0xde,0xde,0xdf,0xdf,0xdf,0xe0,0xcf,0xd0,0xd0,0xe1,0xc0,0xc0,0xd1,0xd1,0xe2,
    0xde,0xde,0xde,0xdf,0xdf,0xdf,0xe0,0xc3,0xd0,0xd0,0xe1,0xc0,0xc0,0xd1,0xd1,0xe2,
    0xd2,0xd2,0xd2,0xc2,0xd3,0xd3,0xd3,0xc3,0xc3,0xd4,0xd4,0xc4,0xc4,0xd5,0xd5,0xe6,
    0xd2,0xd2,0xd2,0xd3,0xd3,0xd3,0xd3,0xc3,0xd4,0xd4,0xd4,0xc4,0xc4,0xd5,0xd5,0xe6,
    0xd2,0xd2,0xd2,0xd3,0xd3,0xd3,0xe4,0xc3,0xd4,0xd4,0xe5,0xc4,0xd5,0xd5,0xe6,0xe6,
    0xe3,0xe3,0xe3,0xd3,0xd3,0xe4,0xb6,0xd4,0xd4,0xe5,0xe5,0xb7,0xd5,0xd5,0xe6,0xe6,
    0xc5,0xc5,0xc5,0xc6,0xc6,0xc6,0xd7,0xc7,0xc7,0xd8,0xd8,0xc8,0xc8,0xd9,0xd9,0xd9,
    0xd6,0xd6,0xd6,0xc6,0xd7,0xd7,0xd7,0xc7,0xd8,0xd8,0xd8,0xc8,0xc8,0xd9,0xd9,0xea,
    0xd6,0xd6,0xd6,0xd7,0xd7,0xd7,0xe8,0xd8,0xd8,0xd8,0xe9,0xc8,0xd9,0xd9,0xea,0xea,
    0xe7,0xe7,0xe7,0xd7,0xd7,0xe8,0xe8,0xd8,0xd8,0xe9,0xe9,0xe9,0xd9,0xd9,0xea,0xea,
    0xc9,0xc9,0xc9,0xca,0xca,0xca,0xba,0xcb,0xcb,0xcb,0xe9,0xcc,0xcc,0xcc,0xea,0xea,
    0xc9,0xc9,0xc9,0xca,0xca,0xdb,0xdb,0xcb,0xcb,0xdc,0xdc,0xcc,0xcc,0xdd,0xdd,0xdd,
    0xda,0xda,0xda,0xdb,0xdb,0xdb,0xdb,0xdc,0xdc,0xdc,0xdc,0xcc,0xdd,0xdd,0xdd,0xee,
    0xda,0xda,0xda,0xdb,0xdb,0xec,0xec,0xdc,0xdc,0xed,0xed,0xed,0xdd,0xdd,0xee,0xee,
    0xeb,0xeb,0xeb,0xec,0xec,0xec,0xec,0xdc,0xed,0xed,0xed,0xed,0xdd,0xee,0xee,0xee,
    0xef,0xef,0xef,0xdf,0xe0,0xe0,0xe0,0xd0,0xd0,0xe1,0xe1,0xf2,0xd1,0xd1,0xe2,0xe2,
    0xef,0xef,0xef,0xdf,0xe0,0xe0,0xe0,0xd0,0xd0,0xe1,0xe1,0xf2,0xd1,0xd1,0xe2,0xe2,
    0xef,0xef,0xef,0xdf,0xe0,0xe0,0xe0,0xd0,0xd0,0xe1,0xe1,0xf2,0xd1,0xd1,0xe2,0xe2,
    0xd2,0xd2,0xd2,0xd3,0xd3,0xe4,0xe4,0xd4,0xd4,0xd4,0xe5,0xe5,0xd5,0xd5,0xe6,0xe6,
    0xe3,0xe3,0xe3,0xd3,0xe4,0xe4,0xe4,0xd4,0xd4,0xe5,0xe5,0xf6,0xd5,0xd5,0xe6,0xe6,
    0xe3,0xe3,0xe3,0xe4,0xe4,0xe4,0xe4,0xd4,0xe5,0xe5,0xe5,0xf6,0xd5,0xe6,0xe6,0xf7,
    0xe3,0xe3,0xe3,0xe4,0xe4,0xe4,0xf5,0xf5,0xe5,0xe5,0xf6,0xf6,0xd5,0xe6,0xe6,0xf7,
    0xd6,0xd6,0xd6,0xd7,0xd7,0xd7,0xf5,0xc7,0xd8,0xd8,0xf6,0xc8,0xd9,0xd9,0xd9,0xf7,
    0xd6,0xd6,0xd6,0xd7,0xd7,0xe8,0xe8,0xd8,0xd8,0xd8,0xe9,0xe9,0xd9,0xd9,0xea,0xea,
    0xe7,0xe7,0xe7,0xd7,0xe8,0xe8,0xe8,0xd8,0xd8,0xe9,0xe9,0xe9,0xd9,0xea,0xea,0xea,
    0xe7,0xe7,0xe7,0xe8,0xe8,0xe8,0xf9,0xf9,0xe9,0xe9,0xe9,0xfa,0xd9,0xea,0xea,0xfb,
    0xf8,0xf8,0xf8,0xe8,0xf9,0xf9,0xf9,0xcb,0xe9,0xe9,0xfa,0xfa,0xcc,0xea,0xea,0xfb,
    0xda,0xda,0xda,0xdb,0xdb,0xdb,0xdb,0xdc,0xdc,0xdc,0xdc,0xcc,0xdd,0xdd,0xdd,0xee,
    0xda,0xda,0xda,0xdb,0xdb,0xec,0xec,0xdc,0xdc,0xed,0xed,0xed,0xdd,0xdd,0xee,0xee,
    0xeb,0xeb,0xeb,0xec,0xec,0xec,0xec,0xdc,0xed,0xed,0xed,0xed,0xdd,0xee,0xee,0xee,
    0xeb,0xeb,0xeb,0xec,0xec,0xfd,0xfd,0xfd,0xed,0xed,0xfe,0xfe,0xee,0xee,0xee,0xff,
    0xf0,0xf0,0xf0,0xe0,0xf1,0xf1,0xf1,0xf1,0xe1,0xf2,0xf2,0xf2,0xf2,0xe2,0xe2,0xf3,
    0xf0,0xf0,0xf0,0xe0,0xf1,0xf1,0xf1,0xf1,0xe1,0xf2,0xf2,0xf2,0xf2,0xe2,0xe2,0xf3,
    0xf0,0xf0,0xf0,0xe0,0xf1,0xf1,0xf1,0xf1,0xe1,0xf2,0xf2,0xf2,0xf2,0xe2,0xe2,0xf3,
    0xe3,0xe3,0xe3,0xe4,0xe4,0xe4,0xf5,0xf5,0xe5,0xe5,0xf6,0xf6,0xd5,0xe6,0xe6,0xf7,
    0xf4,0xf4,0xf4,0xe4,0xe4,0xf5,0xf5,0xf5,0xe5,0xe5,0xf6,0xf6,0xf6,0xe6,0xe6,0xf7,
    0xf4,0xf4,0xf4,0xe4,0xf5,0xf5,0xf5,0xf5,0xe5,0xf6,0xf6,0xf6,0xf6,0xe6,0xf7,0xf7,
    0xf4,0xf4,0xf4,0xf5,0xf5,0xf5,0xf5,0xf5,0xe5,0xf6,0xf6,0xf6,0xf6,0xe6,0xf7,0xf7,
    0xf4,0xf4,0xf4,0xf5,0xf5,0xf5,0xf5,0xf5,0xd8,0xf6,0xf6,0xf6,0xd9,0xd9,0xf7,0xf7,
    0xe7,0xe7,0xe7,0xe8,0xe8,0xe8,0xe8,0xd8,0xe9,0xe9,0xe9,0xfa,0xd9,0xea,0xea,0xea,
    0xf8,0xf8,0xf8,0xe8,0xe8,0xf9,0xf9,0xf9,0xe9,0xe9,0xfa,0xfa,0xfa,0xea,0xea,0xfb,
    0xf8,0xf8,0xf8,0xf9,0xf9,0xf9,0xf9,0xf9,0xe9,0xfa,0xfa,0xfa,0xfa,0xea,0xfb,0xfb,
    0xf8,0xf8,0xf8,0xf9,0xf9,0xf9,0xf9,0xf9,0xfa,0xfa,0xfa,0xfa,0xfa,0xea,0xfb,0xfb,
    0xf8,0xf8,0xf8,0xdb,0xf9,0xf9,0xf9,0xdc,0xdc,0xfa,0xfa,0xfa,0xdd,0xdd,0xee,0xfb,
    0xeb,0xeb,0xeb,0xec,0xec,0xec,0xec,0xdc,0xed,0xed,0xed,0xed,0xdd,0xee,0xee,0xee,
    0xeb,0xeb,0xeb,0xec,0xec,0xfd,0xfd,0xfd,0xed,0xed,0xfe,0xfe,0xee,0xee,0xee,0xff,
    0xfc,0xfc,0xfc,0xfd,0xfd,0xfd,0xfd,0xfd,0xed,0xfe,0xfe,0xfe,0xfe,0xee,0xff,0xff,
}
};
@

<<global memdefcmap>>=
Memcmap *memdefcmap = &def;
@

<<function _memmkcmap>>=
void _memmkcmap(void){}
@


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/cmap.c>>=
/*
 * generated by mkcmap.c
 */
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>

<<global def>>
<<global memdefcmap>>
<<function _memmkcmap>>
@


\subsection*{[[lib_graphics/libmemdraw/cread.c]]}


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/cread.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>

<<function creadmemimage>>
@


\subsection*{[[lib_graphics/libmemdraw/defont.c]]}

<<function getmemdefont>>=
Memsubfont*
getmemdefont(void)
{
    char *hdr, *p;
    int n;
    Fontchar *fc;
    Memsubfont *f;
    int ld;
    Rectangle r;
    Memdata *md;
    Memimage *i;

    /*
     * make sure data is word-aligned.  this is true with Plan 9 compilers
     * but not in general.  the byte order is right because the data is
     * declared as char*, not ulong*.
     */
    p = (char*)defontdata;
    n = (uintptr)p & 3;
    if(n != 0){
        memmove(p+(4-n), p, sizeofdefont-n);
        p += 4-n;
    }
    ld = atoi(p+0*12);
    r.min.x = atoi(p+1*12);
    r.min.y = atoi(p+2*12);
    r.max.x = atoi(p+3*12);
    r.max.y = atoi(p+4*12);

    md = mallocz(sizeof(Memdata), 1);
    if(md == nil)
        return nil;
    
    p += 5*12;

    md->base = nil;		/* so freememimage doesn't free p */
    md->bdata = (uchar*)p;	/* ick */
    md->ref = 1;
    md->allocd = 1;		/* so freememimage does free md */

    i = allocmemimaged(r, drawld2chan[ld], md);
    if(i == nil){
        free(md);
        return nil;
    }

    hdr = p+Dy(r)*i->width*sizeof(ulong);
    n = atoi(hdr);
    p = hdr+3*12;
    fc = malloc(sizeof(Fontchar)*(n+1));
    if(fc == 0){
        freememimage(i);
        return 0;
    }
    _unpackinfo(fc, (uchar*)p, n);
    f = allocmemsubfont("*default*", n, atoi(hdr+12), atoi(hdr+24), fc, i);
    if(f == 0){
        freememimage(i);
        free(fc);
        return 0;
    }
    return f;
}
@


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/defont.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>

<<function getmemdefont>>
@


\subsection*{[[lib_graphics/libmemdraw/draw.c]]}


<<global tablesbuilt>>=
static int	tablesbuilt;
@

<<function RGB2K>>=
/* perfect approximation to NTSC = .299r+.587g+.114b when 0 ≤ r,g,b < 256 */
#define RGB2K(r,g,b)	((156763*(r)+307758*(g)+59769*(b))>>19)
@

<<function DIV255>>=
#define DIV255(x) ((((x)+1)*257)>>16)
@
%/* #define DIV255(x) (((x)*257+256)>>16)  */
%/* #define DIV255(x) (tmp=(x)+1, (tmp+(tmp>>8))>>8) */

<<function MUL>>=
#define MUL(x, y, t)	(t = (x)*(y)+128, (t+(t>>8))>>8)
@

<<constant MASK13>>=
#define MASK13	0xFF00FF00
@

<<constant MASK02>>=
#define MASK02	0x00FF00FF
@

<<function MUL13>>=
#define MUL13(a, x, t)		(t = (a)*(((x)&MASK13)>>8)+128, ((t+((t>>8)&MASK02))>>8)&MASK02)
@

<<function MUL02>>=
#define MUL02(a, x, t)		(t = (a)*(((x)&MASK02)>>0)+128, ((t+((t>>8)&MASK02))>>8)&MASK02)
@

<<function MUL0123>>=
#define MUL0123(a, x, s, t)	((MUL13(a, x, s)<<8)|MUL02(a, x, t))
@

<<function MUL2>>=
#define MUL2(u, v, x, y)	(t = (u)*(v)+(x)*(y)+256, (t+(t>>8))>>8)
@







<<global ones>>=
static uchar ones = 0xff;
@

<<struct Buffer>>=
struct Buffer {
    /* used by most routines */
    uchar	*red;
    uchar	*grn;
    uchar	*blu;

    uchar	*alpha;
    uchar	*grey;
    ulong	*rgba;

    int	delta;	/* number of bytes to add to pointer to get next pixel to the right */

    /* used by boolcalc* for mask data */
    uchar	*m;		/* ptr to mask data r.min byte; like p->bytermin */
    int		mskip;	/* no. of left bits to skip in *m */
    uchar	*bm;		/* ptr to mask data img->r.min byte; like p->bytey0s */
    int		bmskip;	/* no. of left bits to skip in *bm */
    uchar	*em;		/* ptr to mask data img->r.max.x byte; like p->bytey0e */
    int		emskip;	/* no. of right bits to skip in *em */
};
@

<<enum _anon_ (lib_graphics/libmemdraw/draw.c)>>=
enum {
    MAXBCACHE = 16
};
@

<<struct ParamDraw>>=
/* giant rathole to customize functions with */
struct ParamDraw {
    Readfn	*replcall;
    Readfn	*greymaskcall;	
    Readfn	*convreadcall;
    Writefn	*convwritecall;

    Memimage *img;
    Rectangle	r;
    int	dx;	/* of r */
    int	needbuf;
    int	convgrey;
    int	alphaonly;

    uchar	*bytey0s;		/* byteaddr(Pt(img->r.min.x, img->r.min.y)) */
    uchar	*bytermin;	/* byteaddr(Pt(r.min.x, img->r.min.y)) */
    uchar	*bytey0e;		/* byteaddr(Pt(img->r.max.x, img->r.min.y)) */
    int		bwidth;

    int	replcache;	/* if set, cache buffers */
    Buffer	bcache[MAXBCACHE];
    ulong	bfilled;
    uchar	*bufbase;
    int	bufoff;
    int	bufdelta;

    int	dir;

    int	convbufoff;
    uchar	*convbuf;
    Param	*convdpar;
    int	convdx;
};
@

<<global drawbuf>>=
static uchar *drawbuf;
@

<<global ndrawbuf>>=
static int	ndrawbuf;
@

<<global mdrawbuf>>=
static int	mdrawbuf;
@

<<global nullwrite>>=
static Writefn	nullwrite;
@

<<global alphacalc>>=
static Calcfn *alphacalc[Ncomp] = 
{
    alphacalc0,		/* Clear */
    alphacalc14,		/* DoutS */
    alphacalc2810,		/* SoutD */
    alphacalc3679,		/* DxorS */
    alphacalc14,		/* DinS */
    alphacalc5,		/* D */
    alphacalc3679,		/* DatopS */
    alphacalc3679,		/* DoverS */
    alphacalc2810,		/* SinD */
    alphacalc3679,		/* SatopD */
    alphacalc2810,		/* S */
    alphacalc11,		/* SoverD */
};
@

<<global boolcalc>>=
static Calcfn *boolcalc[Ncomp] =
{
    alphacalc0,		/* Clear */
    boolcalc14,		/* DoutS */
    boolcalc236789,		/* SoutD */
    boolcalc236789,		/* DxorS */
    boolcalc14,		/* DinS */
    alphacalc5,		/* D */
    boolcalc236789,		/* DatopS */
    boolcalc236789,		/* DoverS */
    boolcalc236789,		/* SinD */
    boolcalc236789,		/* SatopD */
    boolcalc1011,		/* S */
    boolcalc1011,		/* SoverD */
};
@

<<struct Dbuf>>=
struct Dbuf
{
    uchar *p;
    int n;
    Param spar, mpar, dpar;
    int inuse;
};
@

<<global dbuf>>=
static Dbuf dbuf[10];
@

<<function allocdbuf>>=
static Dbuf*
allocdbuf(void)
{
    int i;

    for(i=0; i<nelem(dbuf); i++){
        if(dbuf[i].inuse)
            continue;
        if(!_tas(&dbuf[i].inuse))
            return &dbuf[i];
    }
    return nil;
}
@

<<function getparam>>=
static void
getparam(Param *p, Memimage *img, Rectangle r, int convgrey, int needbuf, int *ndrawbuf)
{
    int nbuf;

    memset(p, 0, sizeof *p);

    p->img = img;
    p->r = r;
    p->dx = Dx(r);
    p->needbuf = needbuf;
    p->convgrey = convgrey;

    assert(img->r.min.x <= r.min.x && r.min.x < img->r.max.x);

    p->bytey0s = byteaddr(img, Pt(img->r.min.x, img->r.min.y));
    p->bytermin = byteaddr(img, Pt(r.min.x, img->r.min.y));
    p->bytey0e = byteaddr(img, Pt(img->r.max.x, img->r.min.y));
    p->bwidth = sizeof(ulong)*img->width;

    assert(p->bytey0s <= p->bytermin && p->bytermin <= p->bytey0e);

    if(p->r.min.x == p->img->r.min.x)
        assert(p->bytermin == p->bytey0s);

    nbuf = 1;
    if((img->flags&Frepl) && Dy(img->r) <= MAXBCACHE && Dy(img->r) < Dy(r)){
        p->replcache = 1;
        nbuf = Dy(img->r);
    }
    p->bufdelta = 4*p->dx;
    p->bufoff = *ndrawbuf;
    *ndrawbuf += p->bufdelta*nbuf;
}
@

<<function clipy>>=
static void
clipy(Memimage *img, int *y)
{
    int dy;

    dy = Dy(img->r);
    if(*y == dy)
        *y = 0;
    else if(*y == -1)
        *y = dy-1;
    assert(0 <= *y && *y < dy);
}
@

<<function dumpbuf>>=
static void
dumpbuf(char *s, Buffer b, int n)
{
    int i;
    uchar *p;
    
    print("%s", s);
    for(i=0; i<n; i++){
        print(" ");
        if(p=b.grey){
            print(" k%.2uX", *p);
            b.grey += b.delta;
        }else{	
            if(p=b.red){
                print(" r%.2uX", *p);
                b.red += b.delta;
            }
            if(p=b.grn){
                print(" g%.2uX", *p);
                b.grn += b.delta;
            }
            if(p=b.blu){
                print(" b%.2uX", *p);
                b.blu += b.delta;
            }
        }
        if((p=b.alpha) != &ones){
            print(" α%.2uX", *p);
            b.alpha += b.delta;
        }
    }
    print("\n");
}
@


<<function alphacalc0>>=
//#undef DBG

static Buffer
alphacalc0(Buffer bdst, Buffer b1, Buffer b2, int dx, int grey, int op)
{
    USED(grey);
    USED(op);
    USED(b1);
    USED(b2);
    memset(bdst.rgba, 0, dx*bdst.delta);
    return bdst;
}
@

<<function alphacalc14>>=
static Buffer
alphacalc14(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, int grey, int op)
{
    Buffer obdst;
    int fd, sadelta;
    int i, sa, ma, q;
    ulong s, t;

    obdst = bdst;
    sadelta = bsrc.alpha == &ones ? 0 : bsrc.delta;
    q = bsrc.delta == 4 && bdst.delta == 4;

    for(i=0; i<dx; i++){
        sa = *bsrc.alpha;
        ma = *bmask.alpha;
        fd = MUL(sa, ma, t);
        if(op == DoutS)
            fd = 255-fd;

        if(grey){
            *bdst.grey = MUL(fd, *bdst.grey, t);
            bsrc.grey += bsrc.delta;
            bdst.grey += bdst.delta;
        }else{
            if(q){
                *bdst.rgba = MUL0123(fd, *bdst.rgba, s, t);
                bsrc.rgba++;
                bdst.rgba++;
                bsrc.alpha += sadelta;
                bmask.alpha += bmask.delta;
                continue;
            }
            *bdst.red = MUL(fd, *bdst.red, t);
            *bdst.grn = MUL(fd, *bdst.grn, t);
            *bdst.blu = MUL(fd, *bdst.blu, t);
            bsrc.red += bsrc.delta;
            bsrc.blu += bsrc.delta;
            bsrc.grn += bsrc.delta;
            bdst.red += bdst.delta;
            bdst.blu += bdst.delta;
            bdst.grn += bdst.delta;
        }
        if(bdst.alpha != &ones){
            *bdst.alpha = MUL(fd, *bdst.alpha, t);
            bdst.alpha += bdst.delta;
        }
        bmask.alpha += bmask.delta;
        bsrc.alpha += sadelta;
    }
    return obdst;
}
@

<<function alphacalc2810>>=
static Buffer
alphacalc2810(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, int grey, int op)
{
    Buffer obdst;
    int fs, sadelta;
    int i, ma, da, q;
    ulong s, t;

    obdst = bdst;
    sadelta = bsrc.alpha == &ones ? 0 : bsrc.delta;
    q = bsrc.delta == 4 && bdst.delta == 4;

    for(i=0; i<dx; i++){
        ma = *bmask.alpha;
        da = *bdst.alpha;
        if(op == SoutD)
            da = 255-da;
        fs = ma;
        if(op != S)
            fs = MUL(fs, da, t);

        if(grey){
            *bdst.grey = MUL(fs, *bsrc.grey, t);
            bsrc.grey += bsrc.delta;
            bdst.grey += bdst.delta;
        }else{
            if(q){
                *bdst.rgba = MUL0123(fs, *bsrc.rgba, s, t);
                bsrc.rgba++;
                bdst.rgba++;
                bmask.alpha += bmask.delta;
                bdst.alpha += bdst.delta;
                continue;
            }
            *bdst.red = MUL(fs, *bsrc.red, t);
            *bdst.grn = MUL(fs, *bsrc.grn, t);
            *bdst.blu = MUL(fs, *bsrc.blu, t);
            bsrc.red += bsrc.delta;
            bsrc.blu += bsrc.delta;
            bsrc.grn += bsrc.delta;
            bdst.red += bdst.delta;
            bdst.blu += bdst.delta;
            bdst.grn += bdst.delta;
        }
        if(bdst.alpha != &ones){
            *bdst.alpha = MUL(fs, *bsrc.alpha, t);
            bdst.alpha += bdst.delta;
        }
        bmask.alpha += bmask.delta;
        bsrc.alpha += sadelta;
    }
    return obdst;
}
@

<<function alphacalc3679>>=
static Buffer
alphacalc3679(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, int grey, int op)
{
    Buffer obdst;
    int fs, fd, sadelta;
    int i, sa, ma, da, q;
    ulong s, t, u, v;

    obdst = bdst;
    sadelta = bsrc.alpha == &ones ? 0 : bsrc.delta;
    q = bsrc.delta == 4 && bdst.delta == 4;

    for(i=0; i<dx; i++){
        sa = *bsrc.alpha;
        ma = *bmask.alpha;
        da = *bdst.alpha;
        if(op == SatopD)
            fs = MUL(ma, da, t);
        else
            fs = MUL(ma, 255-da, t);
        if(op == DoverS)
            fd = 255;
        else{
            fd = MUL(sa, ma, t);
            if(op != DatopS)
                fd = 255-fd;
        }

        if(grey){
            *bdst.grey = MUL(fs, *bsrc.grey, s)+MUL(fd, *bdst.grey, t);
            bsrc.grey += bsrc.delta;
            bdst.grey += bdst.delta;
        }else{
            if(q){
                *bdst.rgba = MUL0123(fs, *bsrc.rgba, s, t)+MUL0123(fd, *bdst.rgba, u, v);
                bsrc.rgba++;
                bdst.rgba++;
                bsrc.alpha += sadelta;
                bmask.alpha += bmask.delta;
                bdst.alpha += bdst.delta;
                continue;
            }
            *bdst.red = MUL(fs, *bsrc.red, s)+MUL(fd, *bdst.red, t);
            *bdst.grn = MUL(fs, *bsrc.grn, s)+MUL(fd, *bdst.grn, t);
            *bdst.blu = MUL(fs, *bsrc.blu, s)+MUL(fd, *bdst.blu, t);
            bsrc.red += bsrc.delta;
            bsrc.blu += bsrc.delta;
            bsrc.grn += bsrc.delta;
            bdst.red += bdst.delta;
            bdst.blu += bdst.delta;
            bdst.grn += bdst.delta;
        }
        if(bdst.alpha != &ones){
            *bdst.alpha = MUL(fs, sa, s)+MUL(fd, da, t);
            bdst.alpha += bdst.delta;
        }
        bmask.alpha += bmask.delta;
        bsrc.alpha += sadelta;
    }
    return obdst;
}
@

<<function alphacalc5>>=
static Buffer
alphacalc5(Buffer bdst, Buffer b1, Buffer b2, int dx, int grey, int op)
{
    USED(dx);
    USED(grey);
    USED(op);
    USED(b1);
    USED(b2);
    return bdst;
}
@

<<function alphacalc11>>=
static Buffer
alphacalc11(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, int grey, int op)
{
    Buffer obdst;
    int fd, sadelta;
    int i, sa, ma, q;
    ulong s, t, u, v;

    USED(op);
    obdst = bdst;
    sadelta = bsrc.alpha == &ones ? 0 : bsrc.delta;
    q = bsrc.delta == 4 && bdst.delta == 4;

    for(i=0; i<dx; i++){
        sa = *bsrc.alpha;
        ma = *bmask.alpha;
        fd = 255-MUL(sa, ma, t);

        if(grey){
            *bdst.grey = MUL(ma, *bsrc.grey, s)+MUL(fd, *bdst.grey, t);
            bsrc.grey += bsrc.delta;
            bdst.grey += bdst.delta;
        }else{
            if(q){
                *bdst.rgba = MUL0123(ma, *bsrc.rgba, s, t)+MUL0123(fd, *bdst.rgba, u, v);
                bsrc.rgba++;
                bdst.rgba++;
                bsrc.alpha += sadelta;
                bmask.alpha += bmask.delta;
                continue;
            }
            *bdst.red = MUL(ma, *bsrc.red, s)+MUL(fd, *bdst.red, t);
            *bdst.grn = MUL(ma, *bsrc.grn, s)+MUL(fd, *bdst.grn, t);
            *bdst.blu = MUL(ma, *bsrc.blu, s)+MUL(fd, *bdst.blu, t);
            bsrc.red += bsrc.delta;
            bsrc.blu += bsrc.delta;
            bsrc.grn += bsrc.delta;
            bdst.red += bdst.delta;
            bdst.blu += bdst.delta;
            bdst.grn += bdst.delta;
        }
        if(bdst.alpha != &ones){
            *bdst.alpha = MUL(ma, sa, s)+MUL(fd, *bdst.alpha, t);
            bdst.alpha += bdst.delta;
        }
        bmask.alpha += bmask.delta;
        bsrc.alpha += sadelta;
    }
    return obdst;
}
@

<<function alphacalcS>>=
/* source alpha 1 */
static Buffer
alphacalcS(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, int grey, int op)
{
    Buffer obdst;
    int fd;
    int i, ma;
    ulong s, t;

    USED(op);
    obdst = bdst;

    for(i=0; i<dx; i++){
        ma = *bmask.alpha;
        fd = 255-ma;

        if(grey){
            *bdst.grey = MUL(ma, *bsrc.grey, s)+MUL(fd, *bdst.grey, t);
            bsrc.grey += bsrc.delta;
            bdst.grey += bdst.delta;
        }else{
            *bdst.red = MUL(ma, *bsrc.red, s)+MUL(fd, *bdst.red, t);
            *bdst.grn = MUL(ma, *bsrc.grn, s)+MUL(fd, *bdst.grn, t);
            *bdst.blu = MUL(ma, *bsrc.blu, s)+MUL(fd, *bdst.blu, t);
            bsrc.red += bsrc.delta;
            bsrc.blu += bsrc.delta;
            bsrc.grn += bsrc.delta;
            bdst.red += bdst.delta;
            bdst.blu += bdst.delta;
            bdst.grn += bdst.delta;
        }
        if(bdst.alpha != &ones){
            *bdst.alpha = ma+MUL(fd, *bdst.alpha, t);
            bdst.alpha += bdst.delta;
        }
        bmask.alpha += bmask.delta;
    }
    return obdst;
}
@

<<function boolcalc14>>=
static Buffer
boolcalc14(Buffer bdst, Buffer b1, Buffer bmask, int dx, int grey, int op)
{
    Buffer obdst;
    int i, ma, zero;

    USED(b1);

    obdst = bdst;

    for(i=0; i<dx; i++){
        ma = *bmask.alpha;
        zero = ma ? op == DoutS : op == DinS;

        if(grey){
            if(zero)
                *bdst.grey = 0;
            bdst.grey += bdst.delta;
        }else{
            if(zero)
                *bdst.red = *bdst.grn = *bdst.blu = 0;
            bdst.red += bdst.delta;
            bdst.blu += bdst.delta;
            bdst.grn += bdst.delta;
        }
        bmask.alpha += bmask.delta;
        if(bdst.alpha != &ones){
            if(zero)
                *bdst.alpha = 0;
            bdst.alpha += bdst.delta;
        }
    }
    return obdst;
}
@

<<function boolcalc236789>>=
static Buffer
boolcalc236789(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, int grey, int op)
{
    Buffer obdst;
    int fs, fd;
    int i, ma, da, zero;
    ulong s, t;

    obdst = bdst;
    zero = !(op&1);

    for(i=0; i<dx; i++){
        ma = *bmask.alpha;
        da = *bdst.alpha;
        fs = da;
        if(op&2)
            fs = 255-da;
        fd = 0;
        if(op&4)
            fd = 255;

        if(grey){
            if(ma)
                *bdst.grey = MUL(fs, *bsrc.grey, s)+MUL(fd, *bdst.grey, t);
            else if(zero)
                *bdst.grey = 0;
            bsrc.grey += bsrc.delta;
            bdst.grey += bdst.delta;
        }else{
            if(ma){
                *bdst.red = MUL(fs, *bsrc.red, s)+MUL(fd, *bdst.red, t);
                *bdst.grn = MUL(fs, *bsrc.grn, s)+MUL(fd, *bdst.grn, t);
                *bdst.blu = MUL(fs, *bsrc.blu, s)+MUL(fd, *bdst.blu, t);
            }
            else if(zero)
                *bdst.red = *bdst.grn = *bdst.blu = 0;
            bsrc.red += bsrc.delta;
            bsrc.blu += bsrc.delta;
            bsrc.grn += bsrc.delta;
            bdst.red += bdst.delta;
            bdst.blu += bdst.delta;
            bdst.grn += bdst.delta;
        }
        bmask.alpha += bmask.delta;
        if(bdst.alpha != &ones){
            if(ma)
                *bdst.alpha = fs+MUL(fd, da, t);
            else if(zero)
                *bdst.alpha = 0;
            bdst.alpha += bdst.delta;
        }
    }
    return obdst;
}
@

<<function boolcalc1011>>=
static Buffer
boolcalc1011(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, int grey, int op)
{
    Buffer obdst;
    int i, ma, zero;

    obdst = bdst;
    zero = !(op&1);

    for(i=0; i<dx; i++){
        ma = *bmask.alpha;

        if(grey){
            if(ma)
                *bdst.grey = *bsrc.grey;
            else if(zero)
                *bdst.grey = 0;
            bsrc.grey += bsrc.delta;
            bdst.grey += bdst.delta;
        }else{
            if(ma){
                *bdst.red = *bsrc.red;
                *bdst.grn = *bsrc.grn;
                *bdst.blu = *bsrc.blu;
            }
            else if(zero)
                *bdst.red = *bdst.grn = *bdst.blu = 0;
            bsrc.red += bsrc.delta;
            bsrc.blu += bsrc.delta;
            bsrc.grn += bsrc.delta;
            bdst.red += bdst.delta;
            bdst.blu += bdst.delta;
            bdst.grn += bdst.delta;
        }
        bmask.alpha += bmask.delta;
        if(bdst.alpha != &ones){
            if(ma)
                *bdst.alpha = 255;
            else if(zero)
                *bdst.alpha = 0;
            bdst.alpha += bdst.delta;
        }
    }
    return obdst;
}
@

<<function replread>>=
/*
 * Replicated cached scan line read.  Call the function listed in the Param,
 * but cache the result so that for replicated images we only do the work once.
 */
static Buffer
replread(Param *p, uchar *s, int y)
{
    Buffer *b;

    USED(s);
    b = &p->bcache[y];
    if((p->bfilled & (1<<y)) == 0){
        p->bfilled |= 1<<y;
        *b = p->replcall(p, p->bufbase+y*p->bufdelta, y);
    }
    return *b;
}
@
% >> >>

<<function greymaskread>>=
/*
 * Alpha reading function that simply relabels the grey pointer.
 */
static Buffer
greymaskread(Param *p, uchar *buf, int y)
{
    Buffer b;

    b = p->greymaskcall(p, buf, y);
    b.alpha = b.grey;
    return b;
}
@

<<function readnbit>>=
//#define DBG if(0)

static Buffer
readnbit(Param *p, uchar *buf, int y)
{
    Buffer b;
    Memimage *img;
    uchar *repl, *r, *w, *ow, bits;
    int i, n, sh, depth, x, dx, npack, nbits;

    b.rgba = (ulong*)buf;
    b.grey = w = buf;
    b.red = b.blu = b.grn = w;
    b.alpha = &ones;
    b.delta = 1;

    dx = p->dx;
    img = p->img;
    depth = img->depth;
    repl = &replbit[depth][0];
    npack = 8/depth;
    sh = 8-depth;

    /* copy from p->r.min.x until end of repl rectangle */
    x = p->r.min.x;
    n = dx;
    if(n > p->img->r.max.x - x)
        n = p->img->r.max.x - x;

    r = p->bytermin + y*p->bwidth;
    //DBG print("readnbit dx %d %p=%p+%d*%d, *r=%d fetch %d ", dx, r, p->bytermin, y, p->bwidth, *r, n);
    bits = *r++;
    nbits = 8;
    if(i=x&(npack-1)){
      //DBG print("throwaway %d...", i);
        bits <<= depth*i;
        nbits -= depth*i;
    }
    for(i=0; i<n; i++){
        if(nbits == 0){
          //DBG print("(%.2ux)...", *r);
            bits = *r++;
            nbits = 8;
        }
        *w++ = repl[bits>>sh];
        //DBG print("bit %x...", repl[bits>>sh]);
        bits <<= depth;
        nbits -= depth;
    }
    dx -= n;
    if(dx == 0)
        return b;

    assert(x+i == p->img->r.max.x);

    /* copy from beginning of repl rectangle until where we were before. */
    x = p->img->r.min.x;
    n = dx;
    if(n > p->r.min.x - x)
        n = p->r.min.x - x;

    r = p->bytey0s + y*p->bwidth;
    //DBG print("x=%d r=%p...", x, r);
    bits = *r++;
    nbits = 8;
    if(i=x&(npack-1)){
        bits <<= depth*i;
        nbits -= depth*i;
    }
    //DBG print("nbits=%d...", nbits);
    for(i=0; i<n; i++){
        if(nbits == 0){
            bits = *r++;
            nbits = 8;
        }
        *w++ = repl[bits>>sh];
        //DBG print("bit %x...", repl[bits>>sh]);
        bits <<= depth;
        nbits -= depth;
        //DBG print("bits %x nbits %d...", bits, nbits);
    }
    dx -= n;
    if(dx == 0)
        return b;

    assert(dx > 0);
    /* now we have exactly one full scan line: just replicate the buffer itself until we are done */
    ow = buf;
    while(dx--)
        *w++ = *ow++;

    return b;
}
@
% >> 

<<function writenbit>>=
//#define DBG if(0)

static void
writenbit(Param *p, uchar *w, Buffer src)
{
    uchar *r;
    ulong bits;
    int i, sh, depth, npack, nbits, x, ex;

    assert(src.grey != nil && src.delta == 1);

    x = p->r.min.x;
    ex = x+p->dx;
    depth = p->img->depth;
    npack = 8/depth;

    i=x&(npack-1);
    bits = i ? (*w >> (8-depth*i)) : 0;
    nbits = depth*i;
    sh = 8-depth;
    r = src.grey;

    for(; x<ex; x++){
        bits <<= depth;
        //DBG print(" %x", *r);
        bits |= (*r++ >> sh);
        nbits += depth;
        if(nbits == 8){
            *w++ = bits;
            nbits = 0;
        }
    }

    if(nbits){
        sh = 8-nbits;
        bits <<= sh;
        bits |= *w & ((1<<sh)-1);
        *w = bits;
    }
    //DBG print("\n");
    return;
}
@
% >> >>

<<function readcmap>>=
//#undef DBG


static Buffer
readcmap(Param *p, uchar *buf, int y)
{
    Buffer b;
    int a, convgrey, copyalpha, dx, i, m;
    uchar *q, *cmap, *begin, *end, *r, *w;

    begin = p->bytey0s + y*p->bwidth;
    r = p->bytermin + y*p->bwidth;
    end = p->bytey0e + y*p->bwidth;
    cmap = p->img->cmap->cmap2rgb;
    convgrey = p->convgrey;
    copyalpha = (p->img->flags&Falpha) ? 1 : 0;

    w = buf;
    dx = p->dx;
    if(copyalpha){
        b.alpha = buf++;
        a = p->img->shift[CAlpha]/8;
        m = p->img->shift[CMap]/8;
        for(i=0; i<dx; i++){
            *w++ = r[a];
            q = cmap+r[m]*3;
            r += 2;
            if(r == end)
                r = begin;
            if(convgrey){
                *w++ = RGB2K(q[0], q[1], q[2]);
            }else{
                *w++ = q[2];	/* blue */
                *w++ = q[1];	/* green */
                *w++ = q[0];	/* red */
            }
        }
    }else{
        b.alpha = &ones;
        for(i=0; i<dx; i++){
            q = cmap+*r++*3;
            if(r == end)
                r = begin;
            if(convgrey){
                *w++ = RGB2K(q[0], q[1], q[2]);
            }else{
                *w++ = q[2];	/* blue */
                *w++ = q[1];	/* green */
                *w++ = q[0];	/* red */
            }
        }
    }

    b.rgba = (ulong*)(buf-copyalpha);

    if(convgrey){
        b.grey = buf;
        b.red = b.blu = b.grn = buf;
        b.delta = 1+copyalpha;
    }else{
        b.blu = buf;
        b.grn = buf+1;
        b.red = buf+2;
        b.grey = nil;
        b.delta = 3+copyalpha;
    }
    return b;
}
@

<<function writecmap>>=
static void
writecmap(Param *p, uchar *w, Buffer src)
{
    uchar *cmap, *red, *grn, *blu;
    int i, dx, delta;

    cmap = p->img->cmap->rgb2cmap;
    
    delta = src.delta;
    red= src.red;
    grn = src.grn;
    blu = src.blu;

    dx = p->dx;
    for(i=0; i<dx; i++, red+=delta, grn+=delta, blu+=delta)
        *w++ = cmap[(*red>>4)*256+(*grn>>4)*16+(*blu>>4)];
}
@

<<function readbyte>>=
//#define DBG if(0)

static Buffer
readbyte(Param *p, uchar *buf, int y)
{
    Buffer b;
    Memimage *img;
    int dx, isgrey, convgrey, alphaonly, copyalpha, i, nb;
    uchar *begin, *end, *r, *w, *rrepl, *grepl, *brepl, *arepl, *krepl;
    uchar ured, ugrn, ublu;
    ulong u;

    img = p->img;
    begin = p->bytey0s + y*p->bwidth;
    r = p->bytermin + y*p->bwidth;
    end = p->bytey0e + y*p->bwidth;

    w = buf;
    dx = p->dx;
    nb = img->depth/8;

    convgrey = p->convgrey;	/* convert rgb to grey */
    isgrey = img->flags&Fgrey;
    alphaonly = p->alphaonly;
    copyalpha = (img->flags&Falpha) ? 1 : 0;

    //DBG print("copyalpha %d alphaonly %d convgrey %d isgrey %d\n", copyalpha, alphaonly, convgrey, isgrey);
    /* if we can, avoid processing everything */
    if(!(img->flags&Frepl) && !convgrey && (img->flags&Fbytes)){
        memset(&b, 0, sizeof b);
        if(p->needbuf){
            memmove(buf, r, dx*nb);
            r = buf;
        }
        b.rgba = (ulong*)r;
        if(copyalpha)
            b.alpha = r+img->shift[CAlpha]/8;
        else
            b.alpha = &ones;
        if(isgrey){
            b.grey = r+img->shift[CGrey]/8;
            b.red = b.grn = b.blu = b.grey;
        }else{
            b.red = r+img->shift[CRed]/8;
            b.grn = r+img->shift[CGreen]/8;
            b.blu = r+img->shift[CBlue]/8;
        }
        b.delta = nb;
        return b;
    }

    //DBG print("2\n");
    rrepl = replbit[img->nbits[CRed]];
    grepl = replbit[img->nbits[CGreen]];
    brepl = replbit[img->nbits[CBlue]];
    arepl = replbit[img->nbits[CAlpha]];
    krepl = replbit[img->nbits[CGrey]];

    for(i=0; i<dx; i++){
        u = r[0] | (r[1]<<8) | (r[2]<<16) | (r[3]<<24);
        if(copyalpha) {
            *w++ = arepl[(u>>img->shift[CAlpha]) & img->mask[CAlpha]];
            //DBG print("a %x\n", w[-1]);
        }

        if(isgrey)
            *w++ = krepl[(u >> img->shift[CGrey]) & img->mask[CGrey]];
        else if(!alphaonly){
            ured = rrepl[(u >> img->shift[CRed]) & img->mask[CRed]];
            ugrn = grepl[(u >> img->shift[CGreen]) & img->mask[CGreen]];
            ublu = brepl[(u >> img->shift[CBlue]) & img->mask[CBlue]];
            if(convgrey){
              //DBG print("g %x %x %x\n", ured, ugrn, ublu);
                *w++ = RGB2K(ured, ugrn, ublu);
                //DBG print("%x\n", w[-1]);
            }else{
                *w++ = brepl[(u >> img->shift[CBlue]) & img->mask[CBlue]];
                *w++ = grepl[(u >> img->shift[CGreen]) & img->mask[CGreen]];
                *w++ = rrepl[(u >> img->shift[CRed]) & img->mask[CRed]];
            }
        }
        r += nb;
        if(r == end)
            r = begin;
    }
    
    b.alpha = copyalpha ? buf : &ones;
    b.rgba = (ulong*)buf;
    if(alphaonly){
        b.red = b.grn = b.blu = b.grey = nil;
        if(!copyalpha)
            b.rgba = nil;
        b.delta = 1;
    }else if(isgrey || convgrey){
        b.grey = buf+copyalpha;
        b.red = b.grn = b.blu = buf+copyalpha;
        b.delta = copyalpha+1;
        //DBG print("alpha %x grey %x\n", b.alpha ? *b.alpha : 0xFF, *b.grey);
    }else{
        b.blu = buf+copyalpha;
        b.grn = buf+copyalpha+1;
        b.grey = nil;
        b.red = buf+copyalpha+2;
        b.delta = copyalpha+3;
    }
    return b;
}
@

<<function writebyte>>=
//#define DBG if(0)

static void
writebyte(Param *p, uchar *w, Buffer src)
{
    Memimage *img;
    int i, isalpha, isgrey, nb, delta, dx, adelta;
    uchar ff, *red, *grn, *blu, *grey, *alpha;
    ulong u, mask;

    img = p->img;

    red = src.red;
    grn = src.grn;
    blu = src.blu;
    alpha = src.alpha;
    delta = src.delta;
    grey = src.grey;
    dx = p->dx;

    nb = img->depth/8;
    mask = (nb==4) ? 0 : ~((1<<img->depth)-1);

    isalpha = img->flags&Falpha;
    isgrey = img->flags&Fgrey;
    adelta = src.delta;

    if(isalpha && (alpha == nil || alpha == &ones)){
        ff = 0xFF;
        alpha = &ff;
        adelta = 0;
    }

    for(i=0; i<dx; i++){
        u = w[0] | (w[1]<<8) | (w[2]<<16) | (w[3]<<24);
        //DBG print("u %.8lux...", u);
        u &= mask;
        //DBG print("&mask %.8lux...", u);
        if(isgrey){
            u |= ((*grey >> (8-img->nbits[CGrey])) & img->mask[CGrey]) << img->shift[CGrey];
            //DBG print("|grey %.8lux...", u);
            grey += delta;
        }else{
            u |= ((*red >> (8-img->nbits[CRed])) & img->mask[CRed]) << img->shift[CRed];
            u |= ((*grn >> (8-img->nbits[CGreen])) & img->mask[CGreen]) << img->shift[CGreen];
            u |= ((*blu >> (8-img->nbits[CBlue])) & img->mask[CBlue]) << img->shift[CBlue];
            red += delta;
            grn += delta;
            blu += delta;
            //DBG print("|rgb %.8lux...", u);
        }

        if(isalpha){
            u |= ((*alpha >> (8-img->nbits[CAlpha])) & img->mask[CAlpha]) << img->shift[CAlpha];
            alpha += adelta;
            //DBG print("|alpha %.8lux...", u);
        }

        w[0] = u;
        w[1] = u>>8;
        w[2] = u>>16;
        w[3] = u>>24;
        w += nb;
    }
}
@

<<function readfn>>=
//#undef DBG

static Readfn*
readfn(Memimage *img)
{
    if(img->depth < 8)
        return readnbit;
    if(img->nbits[CMap] == 8)
        return readcmap;
    return readbyte;
}
@

<<function readalphafn>>=
static Readfn*
readalphafn(Memimage *m)
{
    USED(m);
    return readbyte;
}
@

<<function writefn>>=
static Writefn*
writefn(Memimage *img)
{
    if(img->depth < 8)
        return writenbit;
    if(img->chan == CMAP8)
        return writecmap;
    return writebyte;
}
@

<<function nullwrite>>=
static void
nullwrite(Param *p, uchar *s, Buffer b)
{
    USED(p);
    USED(s);
    USED(b);
}
@

<<function readptr>>=
static Buffer
readptr(Param *p, uchar *s, int y)
{
    Buffer b;
    uchar *q;

    USED(s);
    q = p->bytermin + y*p->bwidth;
    b.red = q;	/* ptr to data */
    b.grn = b.blu = b.grey = b.alpha = nil;
    b.rgba = (ulong*)q;
    b.delta = p->img->depth/8;
    return b;
}
@

<<function boolmemmove>>=
static Buffer
boolmemmove(Buffer bdst, Buffer bsrc, Buffer b1, int dx, int i, int o)
{
    USED(i);
    USED(o);
    USED(b1);
    USED(bsrc);
    memmove(bdst.red, bsrc.red, dx*bdst.delta);
    return bdst;
}
@

<<function boolcopy8>>=
static Buffer
boolcopy8(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, int i, int o)
{
    uchar *m, *r, *w, *ew;

    USED(i);
    USED(o);
    m = bmask.grey;
    w = bdst.red;
    r = bsrc.red;
    ew = w+dx;
    for(; w < ew; w++,r++)
        if(*m++)
            *w = *r;
    return bdst;	/* not used */
}
@

<<function boolcopy16>>=
static Buffer
boolcopy16(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, int i, int o)
{
    uchar *m;
    ushort *r, *w, *ew;

    USED(i);
    USED(o);
    m = bmask.grey;
    w = (ushort*)bdst.red;
    r = (ushort*)bsrc.red;
    ew = w+dx;
    for(; w < ew; w++,r++)
        if(*m++)
            *w = *r;
    return bdst;	/* not used */
}
@

<<function boolcopy24>>=
static Buffer
boolcopy24(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, int i, int o)
{
    uchar *m;
    uchar *r, *w, *ew;

    USED(i);
    USED(o);
    m = bmask.grey;
    w = bdst.red;
    r = bsrc.red;
    ew = w+dx*3;
    while(w < ew){
        if(*m++){
            *w++ = *r++;
            *w++ = *r++;
            *w++ = *r++;
        }else{
            w += 3;
            r += 3;
        }
    }
    return bdst;	/* not used */
}
@

<<function boolcopy32>>=
static Buffer
boolcopy32(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, int i, int o)
{
    uchar *m;
    ulong *r, *w, *ew;

    USED(i);
    USED(o);
    m = bmask.grey;
    w = (ulong*)bdst.red;
    r = (ulong*)bsrc.red;
    ew = w+dx;
    for(; w < ew; w++,r++)
        if(*m++)
            *w = *r;
    return bdst;	/* not used */
}
@

<<function genconv>>=
static Buffer
genconv(Param *p, uchar *buf, int y)
{
    Buffer b;
    int nb;
    uchar *r, *w, *ew;

    /* read from source into RGB format in convbuf */
    b = p->convreadcall(p, p->convbuf, y);

    /* write RGB format into dst format in buf */
    p->convwritecall(p->convdpar, buf, b);

    if(p->convdx){
        nb = p->convdpar->img->depth/8;
        r = buf;
        w = buf+nb*p->dx;
        ew = buf+nb*p->convdx;
        while(w<ew)
            *w++ = *r++;
    }

    b.red = buf;
    b.blu = b.grn = b.grey = b.alpha = nil;
    b.rgba = (ulong*)buf;
    b.delta = 0;
    
    return b;
}
@

<<function convfn>>=
static Readfn*
convfn(Memimage *dst, Param *dpar, Memimage *src, Param *spar, int *ndrawbuf)
{
    if(dst->chan == src->chan && !(src->flags&Frepl)){
//if(drawdebug) iprint("readptr...");
        return readptr;
    }

    if(dst->chan==CMAP8 && (src->chan==GREY1||src->chan==GREY2||src->chan==GREY4)){
        /* cheat because we know the replicated value is exactly the color map entry. */
//if(drawdebug) iprint("Readnbit...");
        return readnbit;
    }

    spar->convreadcall = readfn(src);
    spar->convwritecall = writefn(dst);
    spar->convdpar = dpar;

    /* allocate a conversion buffer */
    spar->convbufoff = *ndrawbuf;
    *ndrawbuf += spar->dx*4;

    if(spar->dx > Dx(spar->img->r)){
        spar->convdx = spar->dx;
        spar->dx = Dx(spar->img->r);
    }

//if(drawdebug) iprint("genconv...");
    return genconv;
}
@

<<function pixelbits>>=
static ulong
pixelbits(Memimage *i, Point pt)
{
    uchar *p;
    ulong val;
    int off, bpp, npack;

    val = 0;
    p = byteaddr(i, pt);
    switch(bpp=i->depth){
    case 1:
    case 2:
    case 4:
        npack = 8/bpp;
        off = pt.x%npack;
        val = p[0] >> bpp*(npack-1-off);
        val &= (1<<bpp)-1;
        break;
    case 8:
        val = p[0];
        break;
    case 16:
        val = p[0]|(p[1]<<8);
        break;
    case 24:
        val = p[0]|(p[1]<<8)|(p[2]<<16);
        break;
    case 32:
        val = p[0]|(p[1]<<8)|(p[2]<<16)|(p[3]<<24);
        break;
    }
    while(bpp<32){
        val |= val<<bpp;
        bpp *= 2;
    }
    return val;
}
@
% >> >> >> >> >> >> >> >>

<<function boolcopyfn>>=
static Calcfn*
boolcopyfn(Memimage *img, Memimage *mask)
{
    if(mask->flags&Frepl && Dx(mask->r)==1 && Dy(mask->r)==1 && pixelbits(mask, mask->r.min)==~0)
        return boolmemmove;

    switch(img->depth){
    case 8:
        return boolcopy8;
    case 16:
        return boolcopy16;
    case 24:
        return boolcopy24;
    case 32:
        return boolcopy32;
    default:
        assert(0 /* boolcopyfn */);
    }
    return nil;
}
@

<<function memsetb>>=
/*
 * Optimized draw for filling and scrolling; uses memset and memmove.
 */
static void
memsetb(void *vp, uchar val, int n)
{
    uchar *p, *ep;

    p = vp;
    ep = p+n;
    while(p<ep)
        *p++ = val;
}
@

<<function memsets>>=
static void
memsets(void *vp, ushort val, int n)
{
    ushort *p, *ep;

    p = vp;
    ep = p+n;
    while(p<ep)
        *p++ = val;
}
@

<<function memsetl>>=
static void
memsetl(void *vp, ulong val, int n)
{
    ulong *p, *ep;

    p = vp;
    ep = p+n;
    while(p<ep)
        *p++ = val;
}
@

<<function memset24>>=
static void
memset24(void *vp, ulong val, int n)
{
    uchar *p, *ep;
    uchar a,b,c;

    p = vp;
    ep = p+3*n;
    a = val;
    b = val>>8;
    c = val>>16;
    while(p<ep){
        *p++ = a;
        *p++ = b;
        *p++ = c;
    }
}
@

<<function imgtorgba>>=
static ulong
imgtorgba(Memimage *img, ulong val)
{
    uchar r, g, b, a;
    int nb, ov, v;
    ulong chan;
    uchar *p;

    a = 0xFF;
    r = g = b = 0xAA;	/* garbage */
    for(chan=img->chan; chan; chan>>=8){
        nb = NBITS(chan);
        ov = v = val&((1<<nb)-1);
        val >>= nb;

        while(nb < 8){
            v |= v<<nb;
            nb *= 2;
        }
        v >>= (nb-8);

        switch(TYPE(chan)){
        case CRed:
            r = v;
            break;
        case CGreen:
            g = v;
            break;
        case CBlue:
            b = v;
            break;
        case CAlpha:
            a = v;
            break;
        case CGrey:
            r = g = b = v;
            break;
        case CMap:
            p = img->cmap->cmap2rgb+3*ov;
            r = *p++;
            g = *p++;	
            b = *p;
            break;
        }
    }
    return (r<<24)|(g<<16)|(b<<8)|a;	
}
@

<<function rgbatoimg>>=
static ulong
rgbatoimg(Memimage *img, ulong rgba)
{
    ulong chan;
    int d, nb;
    ulong v;
    uchar *p, r, g, b, a, m;

    v = 0;
    r = rgba>>24;
    g = rgba>>16;
    b = rgba>>8;
    a = rgba;
    d = 0;
    for(chan=img->chan; chan; chan>>=8){
        nb = NBITS(chan);
        switch(TYPE(chan)){
        case CRed:
            v |= (r>>(8-nb))<<d;
            break;
        case CGreen:
            v |= (g>>(8-nb))<<d;
            break;
        case CBlue:
            v |= (b>>(8-nb))<<d;
            break;
        case CAlpha:
            v |= (a>>(8-nb))<<d;
            break;
        case CMap:
            p = img->cmap->rgb2cmap;
            m = p[(r>>4)*256+(g>>4)*16+(b>>4)];
            v |= (m>>(8-nb))<<d;
            break;
        case CGrey:
            m = RGB2K(r,g,b);
            v |= (m>>(8-nb))<<d;
            break;
        }
        d += nb;
    }
//	print("rgba2img %.8lux = %.*lux\n", rgba, 2*d/8, v);
    return v;
}
@
% >>

<<function memoptdraw>>=
//#define DBG if(0)

static int
memoptdraw(Memdrawparam *par)
{
    int m, y, dy, dx, op;
    ulong v;
    Memimage *src;
    Memimage *dst;

    dx = Dx(par->r);
    dy = Dy(par->r);
    src = par->src;
    dst = par->dst;
    op = par->op;

    //DBG print("state %lux mval %lux dd %d\n", par->state, par->mval, dst->depth);
    /*
     * If we have an opaque mask and source is one opaque pixel we can convert to the
     * destination format and just replicate with memset.
     */
    m = Simplesrc|Simplemask|Fullmask;
    if((par->state&m)==m && (par->srgba&0xFF) == 0xFF && (op ==S || op == SoverD)){
        uchar *dp, p[4];
        int d, dwid, ppb, np, nb;
        uchar lm, rm;

        //DBG print("memopt, dst %p, dst->data->bdata %p\n", dst, dst->data->bdata);
        dwid = dst->width*sizeof(ulong);
        dp = byteaddr(dst, par->r.min);
        v = par->sdval;
        //DBG print("sdval %lud, depth %d\n", v, dst->depth);
        switch(dst->depth){
        case 1:
        case 2:
        case 4:
            for(d=dst->depth; d<8; d*=2)
                v |= (v<<d);
            ppb = 8/dst->depth;	/* pixels per byte */
            m = ppb-1;
            /* left edge */
            np = par->r.min.x&m;		/* no. pixels unused on left side of word */
            dx -= (ppb-np);
            nb = 8 - np * dst->depth;		/* no. bits used on right side of word */
            lm = (1<<nb)-1;
            //DBG print("np %d x %d nb %d lm %ux ppb %d m %ux\n", np, par->r.min.x, nb, lm, ppb, m);	

            /* right edge */
            np = par->r.max.x&m;	/* no. pixels used on left side of word */
            dx -= np;
            nb = 8 - np * dst->depth;		/* no. bits unused on right side of word */
            rm = ~((1<<nb)-1);
            //DBG print("np %d x %d nb %d rm %ux ppb %d m %ux\n", np, par->r.max.x, nb, rm, ppb, m);	

            //DBG print("dx %d Dx %d\n", dx, Dx(par->r));
            /* lm, rm are masks that are 1 where we should touch the bits */
            if(dx < 0){	/* just one byte */
                lm &= rm;
                for(y=0; y<dy; y++, dp+=dwid)
                    *dp ^= (v ^ *dp) & lm;
            }else if(dx == 0){	/* no full bytes */
                if(lm)
                    dwid--;

                for(y=0; y<dy; y++, dp+=dwid){
                    if(lm){
                      //DBG print("dp %p v %lux lm %ux (v ^ *dp) & lm %lux\n", dp, v, lm, (v^*dp)&lm);
                        *dp ^= (v ^ *dp) & lm;
                        dp++;
                    }
                    *dp ^= (v ^ *dp) & rm;
                }
            }else{		/* full bytes in middle */
                dx /= ppb;
                if(lm)
                    dwid--;
                dwid -= dx;

                for(y=0; y<dy; y++, dp+=dwid){
                    if(lm){
                        *dp ^= (v ^ *dp) & lm;
                        dp++;
                    }
                    memset(dp, v, dx);
                    dp += dx;
                    *dp ^= (v ^ *dp) & rm;
                }
            }
            return 1;
        case 8:
            for(y=0; y<dy; y++, dp+=dwid)
                memset(dp, v, dx);
            return 1;
        case 16:
            p[0] = v;		/* make little endian */
            p[1] = v>>8;
            v = *(ushort*)p;
            //DBG print("dp=%p; dx=%d; for(y=0; y<%d; y++, dp+=%d)\nmemsets(dp, v, dx);\n",
            //	dp, dx, dy, dwid);
            for(y=0; y<dy; y++, dp+=dwid)
                memsets(dp, v, dx);
            return 1;
        case 24:
            for(y=0; y<dy; y++, dp+=dwid)
                memset24(dp, v, dx);
            return 1;
        case 32:
            p[0] = v;		/* make little endian */
            p[1] = v>>8;
            p[2] = v>>16;
            p[3] = v>>24;
            v = *(ulong*)p;
            for(y=0; y<dy; y++, dp+=dwid)
                memsetl(dp, v, dx);
            return 1;
        default:
            assert(0 /* bad dest depth in memoptdraw */);
        }
    }

    /*
     * If no source alpha, an opaque mask, we can just copy the
     * source onto the destination.  If the channels are the same and
     * the source is not replicated, memmove suffices.
     */
    m = Simplemask|Fullmask;
    if((par->state&(m|Replsrc))==m && src->depth >= 8 
    && src->chan == dst->chan && !(src->flags&Falpha) && (op == S || op == SoverD)){
        uchar *sp, *dp;
        long swid, dwid, nb;
        int dir;

        if(src->data == dst->data && byteaddr(dst, par->r.min) > byteaddr(src, par->sr.min))
            dir = -1;
        else
            dir = 1;

        swid = src->width*sizeof(ulong);
        dwid = dst->width*sizeof(ulong);
        sp = byteaddr(src, par->sr.min);
        dp = byteaddr(dst, par->r.min);
        if(dir == -1){
            sp += (dy-1)*swid;
            dp += (dy-1)*dwid;
            swid = -swid;
            dwid = -dwid;
        }
        nb = (dx*src->depth)/8;
        for(y=0; y<dy; y++, sp+=swid, dp+=dwid)
            memmove(dp, sp, nb);
        return 1;
    }

    /*
     * If we have a 1-bit mask, 1-bit source, and 1-bit destination, and
     * they're all bit aligned, we can just use bit operators.  This happens
     * when we're manipulating boolean masks, e.g. in the arc code.
     */
    if((par->state&(Simplemask|Simplesrc|Replmask|Replsrc))==0 
    && dst->chan==GREY1 && src->chan==GREY1 && par->mask->chan==GREY1 
    && (par->r.min.x&7)==(par->sr.min.x&7) && (par->r.min.x&7)==(par->mr.min.x&7)){
        uchar *sp, *dp, *mp;
        uchar lm, rm;
        long swid, dwid, mwid;
        int i, x, dir;

        sp = byteaddr(src, par->sr.min);
        dp = byteaddr(dst, par->r.min);
        mp = byteaddr(par->mask, par->mr.min);
        swid = src->width*sizeof(ulong);
        dwid = dst->width*sizeof(ulong);
        mwid = par->mask->width*sizeof(ulong);

        if(src->data == dst->data && byteaddr(dst, par->r.min) > byteaddr(src, par->sr.min)){
            dir = -1;
        }else
            dir = 1;

        lm = 0xFF>>(par->r.min.x&7);
        rm = 0xFF<<(8-(par->r.max.x&7));
        dx -= (8-(par->r.min.x&7)) + (par->r.max.x&7);

        if(dx < 0){	/* one byte wide */
            lm &= rm;
            if(dir == -1){
                dp += dwid*(dy-1);
                sp += swid*(dy-1);
                mp += mwid*(dy-1);
                dwid = -dwid;
                swid = -swid;
                mwid = -mwid;
            }
            for(y=0; y<dy; y++){
                *dp ^= (*dp ^ *sp) & *mp & lm;
                dp += dwid;
                sp += swid;
                mp += mwid;
            }
            return 1;
        }

        dx /= 8;
        if(dir == 1){
            i = (lm!=0)+dx+(rm!=0);
            mwid -= i;
            swid -= i;
            dwid -= i;
            for(y=0; y<dy; y++, dp+=dwid, sp+=swid, mp+=mwid){
                if(lm){
                    *dp ^= (*dp ^ *sp++) & *mp++ & lm;
                    dp++;
                }
                for(x=0; x<dx; x++){
                    *dp ^= (*dp ^ *sp++) & *mp++;
                    dp++;
                }
                if(rm){
                    *dp ^= (*dp ^ *sp++) & *mp++ & rm;
                    dp++;
                }
            }
            return 1;
        }else{
        /* dir == -1 */
            i = (lm!=0)+dx+(rm!=0);
            dp += dwid*(dy-1)+i-1;
            sp += swid*(dy-1)+i-1;
            mp += mwid*(dy-1)+i-1;
            dwid = -dwid+i;
            swid = -swid+i;
            mwid = -mwid+i;
            for(y=0; y<dy; y++, dp+=dwid, sp+=swid, mp+=mwid){
                if(rm){
                    *dp ^= (*dp ^ *sp--) & *mp-- & rm;
                    dp--;
                }
                for(x=0; x<dx; x++){
                    *dp ^= (*dp ^ *sp--) & *mp--;
                    dp--;
                }
                if(lm){
                    *dp ^= (*dp ^ *sp--) & *mp-- & lm;
                    dp--;
                }
            }
        }
        return 1;
    }
    return 0;	
}
@
% >>

<<function chardraw>>=
/*
 * Boolean character drawing.
 * Solid opaque color through a 1-bit greyscale mask.
 */
static int
chardraw(Memdrawparam *par)
{
    ulong bits;
    int i, ddepth, dy, dx, x, bx, ex, y, npack, bsh, depth, op;
    ulong v, maskwid, dstwid;
    uchar *wp, *rp, *q, *wc;
    ushort *ws;
    ulong *wl;
    uchar sp[4];
    Rectangle r, mr;
    Memimage *mask, *src, *dst;

if(0) if(drawdebug) iprint("chardraw? mf %lux md %d sf %lux dxs %d dys %d dd %d ddat %p sdat %p\n",
        par->mask->flags, par->mask->depth, par->src->flags, 
        Dx(par->src->r), Dy(par->src->r), par->dst->depth, par->dst->data, par->src->data);

    mask = par->mask;
    src = par->src;
    dst = par->dst;
    r = par->r;
    mr = par->mr;
    op = par->op;

    if((par->state&(Replsrc|Simplesrc|Replmask)) != (Replsrc|Simplesrc)
    || mask->depth != 1 || src->flags&Falpha || dst->depth<8 || dst->data==src->data
    || op != SoverD)
        return 0;

//if(drawdebug) iprint("chardraw...");

    depth = mask->depth;
    maskwid = mask->width*sizeof(ulong);
    rp = byteaddr(mask, mr.min);
    npack = 8/depth;
    bsh = (mr.min.x % npack) * depth;

    wp = byteaddr(dst, r.min);
    dstwid = dst->width*sizeof(ulong);
    //DBG print("bsh %d\n", bsh);
    dy = Dy(r);
    dx = Dx(r);

    ddepth = dst->depth;

    /*
     * for loop counts from bsh to bsh+dx
     *
     * we want the bottom bits to be the amount
     * to shift the pixels down, so for n≡0 (mod 8) we want 
     * bottom bits 7.  for n≡1, 6, etc.
     * the bits come from -n-1.
     */

    bx = -bsh-1;
    ex = -bsh-1-dx;
    SET(bits);
    v = par->sdval;

    /* make little endian */
    sp[0] = v;
    sp[1] = v>>8;
    sp[2] = v>>16;
    sp[3] = v>>24;

//print("sp %x %x %x %x\n", sp[0], sp[1], sp[2], sp[3]);
    for(y=0; y<dy; y++, rp+=maskwid, wp+=dstwid){
        q = rp;
        if(bsh)
            bits = *q++;
        switch(ddepth){
        case 8:
//if(drawdebug) iprint("8loop...");
            wc = wp;
            for(x=bx; x>ex; x--, wc++){
                i = x&7;
                if(i == 8-1)
                    bits = *q++;
                //DBG print("bits %lux sh %d...", bits, i);
                if((bits>>i)&1)
                    *wc = v;
            }
            break;
        case 16:
            ws = (ushort*)wp;
            v = *(ushort*)sp;
            for(x=bx; x>ex; x--, ws++){
                i = x&7;
                if(i == 8-1)
                    bits = *q++;
                //DBG print("bits %lux sh %d...", bits, i);
                if((bits>>i)&1)
                    *ws = v;
            }
            break;
        case 24:
            wc = wp;
            for(x=bx; x>ex; x--, wc+=3){
                i = x&7;
                if(i == 8-1)
                    bits = *q++;
                //DBG print("bits %lux sh %d...", bits, i);
                if((bits>>i)&1){
                    wc[0] = sp[0];
                    wc[1] = sp[1];
                    wc[2] = sp[2];
                }
            }
            break;
        case 32:
            wl = (ulong*)wp;
            v = *(ulong*)sp;
            for(x=bx; x>ex; x--, wl++){
                i = x&7;
                if(i == 8-1)
                    bits = *q++;
                //DBG iprint("bits %lux sh %d...", bits, i);
                if((bits>>i)&1)
                    *wl = v;
            }
            break;
        }
    }

    //DBG print("\n");	
    return 1;	
}
@



%/*
% * Fill entire byte with replicated (if necessary) copy of source pixel,
% * assuming destination ldepth is >= source ldepth.
% *
% * This code is just plain wrong for >8bpp.
% *
%ulong
%membyteval(Memimage *src)
%{
%    int i, val, bpp;
%    uchar uc;
%
%    unloadmemimage(src, src->r, &uc, 1);
%    bpp = src->depth;
%    uc <<= (src->r.min.x&(7/src->depth))*src->depth;
%    uc &= ~(0xFF>>bpp);
%    /* pixel value is now in high part of byte. repeat throughout byte 
%    val = uc;
%    for(i=bpp; i<8; i<<=1)
%        val |= val>>i;
%    return val;
%}
% * 
% */


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/draw.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <pool.h>

extern Pool* imagmem;
<<global drawdebug>>
<<global tablesbuilt>>

<<function RGB2K>>

/*
 * for 0 ≤ x ≤ 255*255, (x*0x0101+0x100)>>16 is a perfect approximation.
 * for 0 ≤ x < (1<<16), x/255 = ((x+1)*0x0101)>>16 is a perfect approximation.
 * the last one is perfect for all up to 1<<16, avoids a multiply, but requires a rathole.
 */ // >> >>
<<function DIV255>>
<<function MUL>>
<<constant MASK13>>
<<constant MASK02>>
<<function MUL13>>
<<function MUL02>>
<<function MUL0123>>

<<function MUL2>>

static void mktables(void);
typedef int Subdraw(Memdrawparam*);
static Subdraw chardraw, alphadraw, memoptdraw;

<<global memones>>
<<global memzeros>>
<<global memwhite>>
<<global memblack>>
<<global memtransparent>>
<<global memopaque>>

int	_ifmt(Fmt*);

<<function memimageinit>>

static ulong imgtorgba(Memimage*, ulong);
static ulong rgbatoimg(Memimage*, ulong);
static ulong pixelbits(Memimage*, Point);

//#define DBG if(0)
<<function memimagedraw>>
//#undef DBG

<<function drawclip>>

<<global replbit>>
<<global conv18>>
<<global conv28>>
<<global conv48>>

extern int replmul[];

<<function mktables>>

<<global ones>>

/*
 * General alpha drawing case.  Can handle anything.
 */
typedef struct	Buffer	Buffer;
<<struct Buffer>>

typedef struct	ParamDraw	Param;
typedef Buffer	Readfn(Param*, uchar*, int);
typedef void	Writefn(Param*, uchar*, Buffer);
typedef Buffer	Calcfn(Buffer, Buffer, Buffer, int, int, int);

<<enum _anon_ (lib_graphics/libmemdraw/draw.c)>>

<<struct ParamDraw>>

<<global drawbuf>>
<<global ndrawbuf>>
<<global mdrawbuf>>
static Readfn	greymaskread, replread, readptr;
<<global nullwrite>>
static Calcfn	alphacalc0, alphacalc14, alphacalc2810, alphacalc3679, alphacalc5, alphacalc11, alphacalcS;
static Calcfn	boolcalc14, boolcalc236789, boolcalc1011;

static Readfn*	readfn(Memimage*);
static Readfn*	readalphafn(Memimage*);
static Writefn*	writefn(Memimage*);

static Calcfn*	boolcopyfn(Memimage*, Memimage*);
static Readfn*	convfn(Memimage*, Param*, Memimage*, Param*, int*);
static Readfn*	ptrfn(Memimage*);

<<global alphacalc>>

<<global boolcalc>>

/*
 * Avoid standard Lock, QLock so that can be used in kernel.
 */
typedef struct Dbuf Dbuf;
<<struct Dbuf>>
<<global dbuf>>

<<function allocdbuf>>

<<function getparam>>

<<function clipy>>

<<function dumpbuf>>

//#define DBG if(0)


<<function alphadraw>>

<<function alphacalc0>>

<<function alphacalc14>>

<<function alphacalc2810>>

<<function alphacalc3679>>

<<function alphacalc5>>

<<function alphacalc11>>

<<function alphacalcS>>

<<function boolcalc14>>

<<function boolcalc236789>>

<<function boolcalc1011>>
<<function replread>>

<<function greymaskread>>

<<function readnbit>>

//#undef DBG
<<function writenbit>>

<<function readcmap>>

<<function writecmap>>

<<function readbyte>>

//#undef DBG
<<function writebyte>>

<<function readfn>>

<<function readalphafn>>

<<function writefn>>

<<function nullwrite>>

<<function readptr>>

<<function boolmemmove>>

<<function boolcopy8>>

<<function boolcopy16>>

<<function boolcopy24>>

<<function boolcopy32>>

<<function genconv>>

<<function convfn>>

<<function pixelbits>>

<<function boolcopyfn>>

<<function memsetb>>

<<function memsets>>

<<function memsetl>>

<<function memset24>>

<<function imgtorgba>>

<<function rgbatoimg>>

<<function memoptdraw>>

//#undef DBG
//#define DBG if(0)

<<function chardraw>>

//#undef DBG


<<function memfillcolor>>

@
% >>


%/*
%not used yet
%source and mask alpha 1
%static Buffer
%alphacalcS0(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, int grey, int op)
%{
%    Buffer obdst;
%    int i;
%
%    USED(op);
%    obdst = bdst;
%    if(bsrc.delta == bdst.delta){
%        memmove(bdst.rgba, bsrc.rgba, dx*bdst.delta);
%        return obdst;
%    }
%    for(i=0; i<dx; i++){
%        if(grey){
%            *bdst.grey = *bsrc.grey;
%            bsrc.grey += bsrc.delta;
%            bdst.grey += bdst.delta;
%        }else{
%            *bdst.red = *bsrc.red;
%            *bdst.grn = *bsrc.grn;
%            *bdst.blu = *bsrc.blu;
%            bsrc.red += bsrc.delta;
%            bsrc.blu += bsrc.delta;
%            bsrc.grn += bsrc.delta;
%            bdst.red += bdst.delta;
%            bdst.blu += bdst.delta;
%            bdst.grn += bdst.delta;
%        }
%        if(bdst.alpha != &ones){
%            *bdst.alpha = 255;
%            bdst.alpha += bdst.delta;
%        }
%    }
%    return obdst;
%}
%*/


\subsection*{[[lib_graphics/libmemdraw/ellipse.c]]}


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/ellipse.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

/*
 * ellipse(dst, c, a, b, t, src, sp)
 *   draws an ellipse centered at c with semiaxes a,b>=0
 *   and semithickness t>=0, or filled if t<0.  point sp
 *   in src maps to c in dst
 *
 *   very thick skinny ellipses are brushed with circles (slow)
 *   others are approximated by filling between 2 ellipses
 *   criterion for very thick when b<a: t/b > 0.5*x/(1-x)
 *   where x = b/a
 */

typedef struct ParamEllipse	Param;
typedef struct State	State;

static	void	bellipse(int, State*, Param*);
static	void	erect(int, int, int, int, Param*);
static	void	eline(int, int, int, int, Param*);

<<struct ParamEllipse>>

<<struct State>>

<<function newstate>>

<<function step>>

<<function memellipse>>

<<global p00 (lib_graphics/libmemdraw/ellipse.c)>>

<<function bellipse>>

<<function erect>>

<<function epoint>>

<<function eline>>
@


\subsection*{[[lib_graphics/libmemdraw/fillpoly.c]]}


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/fillpoly.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

typedef struct Seg	Seg;

<<struct Seg>>

static	void	zsort(Seg **seg, Seg **ep);
static	int	ycompare(void*, void*);
static	int	xcompare(void*, void*);
static	int	zcompare(void*, void*);
static	void	xscan(Memimage *dst, Seg **seg, Seg *segtab, int nseg, int wind, Memimage *src, Point sp, int, int, int, int);
static	void	yscan(Memimage *dst, Seg **seg, Seg *segtab, int nseg, int wind, Memimage *src, Point sp, int, int);

<<function fillcolor>>

<<function fillline>>

<<function fillpoint>>

<<function memfillpoly>>

<<function _memfillpolysc>>

<<function mod>>

<<function sdiv>>

<<function smuldivmod>>

<<function xscan>>

<<function yscan>>

<<function zsort>>

<<function ycompare>>

<<function xcompare>>

<<function zcompare>>
@


\subsection*{[[lib_graphics/libmemdraw/hwdraw.c]]}

% need that? kernel cruft for app outside kernel linking with memdraw.a

% the kernel/ defines the real one

%int
%hwdraw(Memdrawparam*)
%{
%    return 0;	/* could not satisfy request */
%}


\subsection*{[[lib_graphics/libmemdraw/iprint.c]]}

% need that? kernel cruft for app outside kernel linking with memdraw.a

<<function memdraw_iprint>>=
int
memdraw_iprint(char*,...)
{
    return -1;
}
@

<<global iprint>>=
int		(*iprint)(char*, ...) = &memdraw_iprint;
@


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/iprint.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>

<<function memdraw_iprint>>

<<global iprint>>

@


\subsection*{[[lib_graphics/libmemdraw/line.c]]}


%<<function lmin>>=
%static
%int
%lmin(int a, int b)
%{
%    if(a < b)
%        return a;
%    return b;
%}
%@
%
%
%
%% version not used
%<<function horline1>>=
%/*
% * Rather than line clip, we run the Bresenham loop over the full line,
% * and clip on each pixel.  This is more expensive but means that
% * lines look the same regardless of how the windowing has tiled them.
% * For speed, we check for clipping outside the loop and make the
% * test easy when possible.
% */
%static
%void
%horline1(Memimage *dst, Point p0, Point p1, int srcval, Rectangle clipr)
%{
%    int x, y, dy, deltay, deltax, maxx;
%    int dd, easy, e, bpp, m, m0;
%    uchar *d;
%
%    deltax = p1.x - p0.x;
%    deltay = p1.y - p0.y;
%    dd = dst->width*sizeof(ulong);
%    dy = 1;
%    if(deltay < 0){
%        dd = -dd;
%        deltay = -deltay;
%        dy = -1;
%    }
%    maxx = lmin(p1.x, clipr.max.x-1);
%    bpp = dst->depth;
%    m0 = 0xFF^(0xFF>>bpp);
%    m = m0 >> (p0.x&(7/dst->depth))*bpp;
%    easy = ptinrect(p0, clipr) && ptinrect(p1, clipr);
%    e = 2*deltay - deltax;
%    y = p0.y;
%    d = byteaddr(dst, p0);
%    deltay *= 2;
%    deltax = deltay - 2*deltax;
%    for(x=p0.x; x<=maxx; x++){
%        if(easy || (clipr.min.x<=x && clipr.min.y<=y && y<clipr.max.y))
%            *d ^= (*d^srcval) & m;
%        if(e > 0){
%            y += dy;
%            d += dd;
%            e += deltax;
%        }else
%            e += deltay;
%        d++;
%        m >>= bpp;
%        if(m == 0)
%            m = m0;
%    }
%}
%@
%
%% version not used
%<<function verline1>>=
%static
%void
%verline1(Memimage *dst, Point p0, Point p1, int srcval, Rectangle clipr)
%{
%    int x, y, deltay, deltax, maxy;
%    int easy, e, bpp, m, m0, dd;
%    uchar *d;
%
%    deltax = p1.x - p0.x;
%    deltay = p1.y - p0.y;
%    dd = 1;
%    if(deltax < 0){
%        dd = -1;
%        deltax = -deltax;
%    }
%    maxy = lmin(p1.y, clipr.max.y-1);
%    bpp = dst->depth;
%    m0 = 0xFF^(0xFF>>bpp);
%    m = m0 >> (p0.x&(7/dst->depth))*bpp;
%    easy = ptinrect(p0, clipr) && ptinrect(p1, clipr);
%    e = 2*deltax - deltay;
%    x = p0.x;
%    d = byteaddr(dst, p0);
%    deltax *= 2;
%    deltay = deltax - 2*deltay;
%    for(y=p0.y; y<=maxy; y++){
%        if(easy || (clipr.min.y<=y && clipr.min.x<=x && x<clipr.max.x))
%            *d ^= (*d^srcval) & m;
%        if(e > 0){
%            x += dd;
%            d += dd;
%            e += deltay;
%        }else
%            e += deltax;
%        d += dst->width*sizeof(ulong);
%        m >>= bpp;
%        if(m == 0)
%            m = m0;
%    }
%}
%@
%
%% version not used
%<<function horliner>>=
%static
%void
%horliner(Memimage *dst, Point p0, Point p1, Memimage *src, Point dsrc, Rectangle clipr)
%{
%    int x, y, sx, sy, deltay, deltax, minx, maxx;
%    int bpp, m, m0;
%    uchar *d, *s;
%
%    deltax = p1.x - p0.x;
%    deltay = p1.y - p0.y;
%    sx = drawreplxy(src->r.min.x, src->r.max.x, p0.x+dsrc.x);
%    minx = lmax(p0.x, clipr.min.x);
%    maxx = lmin(p1.x, clipr.max.x-1);
%    bpp = dst->depth;
%    m0 = 0xFF^(0xFF>>bpp);
%    m = m0 >> (minx&(7/dst->depth))*bpp;
%    for(x=minx; x<=maxx; x++){
%        y = p0.y + (deltay*(x-p0.x)+deltax/2)/deltax;
%        if(clipr.min.y<=y && y<clipr.max.y){
%            d = byteaddr(dst, Pt(x, y));
%            sy = drawreplxy(src->r.min.y, src->r.max.y, y+dsrc.y);
%            s = byteaddr(src, Pt(sx, sy));
%            *d ^= (*d^*s) & m;
%        }
%        if(++sx >= src->r.max.x)
%            sx = src->r.min.x;
%        m >>= bpp;
%        if(m == 0)
%            m = m0;
%    }
%}
%@
%
%% version not used
%<<function verliner>>=
%static
%void
%verliner(Memimage *dst, Point p0, Point p1, Memimage *src, Point dsrc, Rectangle clipr)
%{
%    int x, y, sx, sy, deltay, deltax, miny, maxy;
%    int bpp, m, m0;
%    uchar *d, *s;
%
%    deltax = p1.x - p0.x;
%    deltay = p1.y - p0.y;
%    sy = drawreplxy(src->r.min.y, src->r.max.y, p0.y+dsrc.y);
%    miny = lmax(p0.y, clipr.min.y);
%    maxy = lmin(p1.y, clipr.max.y-1);
%    bpp = dst->depth;
%    m0 = 0xFF^(0xFF>>bpp);
%    for(y=miny; y<=maxy; y++){
%        if(deltay == 0)	/* degenerate line */
%            x = p0.x;
%        else
%            x = p0.x + (deltax*(y-p0.y)+deltay/2)/deltay;
%        if(clipr.min.x<=x && x<clipr.max.x){
%            m = m0 >> (x&(7/dst->depth))*bpp;
%            d = byteaddr(dst, Pt(x, y));
%            sx = drawreplxy(src->r.min.x, src->r.max.x, x+dsrc.x);
%            s = byteaddr(src, Pt(sx, sy));
%            *d ^= (*d^*s) & m;
%        }
%        if(++sy >= src->r.max.y)
%            sy = src->r.min.y;
%    }
%}
%@
%
%% version not used
%<<function horline>>=
%static
%void
%horline(Memimage *dst, Point p0, Point p1, Memimage *src, Point dsrc, Rectangle clipr)
%{
%    int x, y, deltay, deltax, minx, maxx;
%    int bpp, m, m0;
%    uchar *d, *s;
%
%    deltax = p1.x - p0.x;
%    deltay = p1.y - p0.y;
%    minx = lmax(p0.x, clipr.min.x);
%    maxx = lmin(p1.x, clipr.max.x-1);
%    bpp = dst->depth;
%    m0 = 0xFF^(0xFF>>bpp);
%    m = m0 >> (minx&(7/dst->depth))*bpp;
%    for(x=minx; x<=maxx; x++){
%        y = p0.y + (deltay*(x-p0.x)+deltay/2)/deltax;
%        if(clipr.min.y<=y && y<clipr.max.y){
%            d = byteaddr(dst, Pt(x, y));
%            s = byteaddr(src, addpt(dsrc, Pt(x, y)));
%            *d ^= (*d^*s) & m;
%        }
%        m >>= bpp;
%        if(m == 0)
%            m = m0;
%    }
%}
%@
%
%% version not used
%<<function verline>>=
%static
%void
%verline(Memimage *dst, Point p0, Point p1, Memimage *src, Point dsrc, Rectangle clipr)
%{
%    int x, y, deltay, deltax, miny, maxy;
%    int bpp, m, m0;
%    uchar *d, *s;
%
%    deltax = p1.x - p0.x;
%    deltay = p1.y - p0.y;
%    miny = lmax(p0.y, clipr.min.y);
%    maxy = lmin(p1.y, clipr.max.y-1);
%    bpp = dst->depth;
%    m0 = 0xFF^(0xFF>>bpp);
%    for(y=miny; y<=maxy; y++){
%        if(deltay == 0)	/* degenerate line */
%            x = p0.x;
%        else
%            x = p0.x + deltax*(y-p0.y)/deltay;
%        if(clipr.min.x<=x && x<clipr.max.x){
%            m = m0 >> (x&(7/dst->depth))*bpp;
%            d = byteaddr(dst, Pt(x, y));
%            s = byteaddr(src, addpt(dsrc, Pt(x, y)));
%            *d ^= (*d^*s) & m;
%        }
%    }
%}
%@


% who calls that??
%<<function memimageline>>=
%void
%memimageline(Memimage *dst, Point p0, Point p1, int end0, int end1, int radius, Memimage *src, Point sp, int op)
%{
%    _memimageline(dst, p0, p1, end0, end1, radius, src, sp, dst->clipr, op);
%}
%@


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/line.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<enum _anon_ (lib_graphics/libmemdraw/line.c)>>

<<function membrush>>

<<function discend>>

<<function arrowend>>

<<function _memimageline>>

<<function addbbox>>

<<function memlineendsize>>

<<function lmax>>

<<function memlinebbox>>
@


\subsection*{[[lib_graphics/libmemdraw/load.c]]}


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/load.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>

<<function loadmemimage>>
@


\subsection*{[[lib_graphics/libmemdraw/openmemsubfont.c]]}

<<function openmemsubfont>>=
Memsubfont*
openmemsubfont(char *name)
{
    Memsubfont *sf;
    Memimage *i;
    Fontchar *fc;
    int fd, n;
    char hdr[3*12+4+1];
    uchar *p;

    fd = open(name, OREAD);
    if(fd < 0)
        return nil;
    p = nil;
    i = readmemimage(fd);
    if(i == nil)
        goto Err;
    if(read(fd, hdr, 3*12) != 3*12){
        werrstr("openmemsubfont: header read error: %r");
        goto Err;
    }
    n = atoi(hdr);
    p = malloc(6*(n+1));
    if(p == nil)
        goto Err;
    if(read(fd, p, 6*(n+1)) != 6*(n+1)){
        werrstr("openmemsubfont: fontchar read error: %r");
        goto Err;
    }
    fc = malloc(sizeof(Fontchar)*(n+1));
    if(fc == nil)
        goto Err;
    _unpackinfo(fc, p, n);
    sf = allocmemsubfont(name, n, atoi(hdr+12), atoi(hdr+24), fc, i);
    if(sf == nil){
        free(fc);
        goto Err;
    }
    free(p);
    return sf;
Err:
    close(fd);
    if (i != nil)
        freememimage(i);
    if (p != nil)
        free(p);
    return nil;
}
@


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/openmemsubfont.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>

<<function openmemsubfont>>
@


\subsection*{[[lib_graphics/libmemdraw/poly.c]]}



%-------------------------------------------------------------

<<lib_graphics/libmemdraw/poly.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<function mempoly>>
@


\subsection*{[[lib_graphics/libmemdraw/read.c]]}

% called only by font stuff?
<<function readmemimage>>=
Memimage*
readmemimage(int fd)
{
    char hdr[5*12+1];
    int dy;
    ulong chan;
    uint l, n;
    int m, j;
    int new, miny, maxy;
    Rectangle r;
    uchar *tmp;
    int ldepth, chunk;
    Memimage *i;

    if(readn(fd, hdr, 11) != 11){
        werrstr("readimage: short header");
        return nil;
    }
    if(memcmp(hdr, "compressed\n", 11) == 0)
        return creadmemimage(fd);

    if(readn(fd, hdr+11, 5*12-11) != 5*12-11){
        werrstr("readimage: short header (2)");
        return nil;
    }

    /*
     * distinguish new channel descriptor from old ldepth.
     * channel descriptors have letters as well as numbers,
     * while ldepths are a single digit formatted as %-11d.
     */
    new = 0;
    for(m=0; m<10; m++){
        if(hdr[m] != ' '){
            new = 1;
            break;
        }
    }
    if(hdr[11] != ' '){
        werrstr("readimage: bad format");
        return nil;
    }
    if(new){
        hdr[11] = '\0';
        if((chan = strtochan(hdr)) == 0){
            werrstr("readimage: bad channel string %s", hdr);
            return nil;
        }
    }else{
        ldepth = ((int)hdr[10])-'0';
        if(ldepth<0 || ldepth>3){
            werrstr("readimage: bad ldepth %d", ldepth);
            return nil;
        }
        chan = drawld2chan[ldepth];
    }

    r.min.x = atoi(hdr+1*12);
    r.min.y = atoi(hdr+2*12);
    r.max.x = atoi(hdr+3*12);
    r.max.y = atoi(hdr+4*12);
    if(r.min.x>r.max.x || r.min.y>r.max.y){
        werrstr("readimage: bad rectangle");
        return nil;
    }

    miny = r.min.y;
    maxy = r.max.y;

    l = bytesperline(r, chantodepth(chan));
    i = allocmemimage(r, chan);
    if(i == nil)
        return nil;
    chunk = 32*1024;
    if(chunk < l)
        chunk = l;
    tmp = malloc(chunk);
    if(tmp == nil)
        goto Err;
    while(maxy > miny){
        dy = maxy - miny;
        if(dy*l > chunk)
            dy = chunk/l;
        if(dy <= 0){
            werrstr("readmemimage: image too wide for buffer");
            goto Err;
        }
        n = dy*l;
        m = readn(fd, tmp, n);
        if(m != n){
            werrstr("readmemimage: read count %d not %d: %r", m, n);
   Err:
    freememimage(i);
            free(tmp);
            return nil;
        }
        if(!new)	/* an old image: must flip all the bits */
            for(j=0; j<chunk; j++)
                tmp[j] ^= 0xFF;

        if(loadmemimage(i, Rect(r.min.x, miny, r.max.x, miny+dy), tmp, chunk) <= 0)
            goto Err;
        miny += dy;
    }
    free(tmp);
    return i;
}
@


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/read.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>

<<function readmemimage>>
@


\subsection*{[[lib_graphics/libmemdraw/string.c]]}

<<function memimagestring>>=
Point
memimagestring(Memimage *b, Point p, Memimage *color, Point cp, Memsubfont *f, char *cs)
{
    int w, width;
    uchar *s;
    Rune c;
    Fontchar *i;

    s = (uchar*)cs;
    for(; c=*s; p.x+=width, cp.x+=width){
        width = 0;
        if(c < Runeself)
            s++;
        else{
            w = chartorune(&c, (char*)s);
            if(w == 0){
                s++;
                continue;
            }
            s += w;
        }
        if(c >= f->n)
            continue;
        i = f->info+c;
        width = i->width;
        memdraw(b, Rect(p.x+i->left, p.y+i->top, p.x+i->left+(i[1].x-i[0].x), p.y+i->bottom),
            color, cp, f->bits, Pt(i->x, i->top), SoverD);
    }
    return p;
}
@

<<function memsubfontwidth>>=
Point
memsubfontwidth(Memsubfont *f, char *cs)
{
    Rune c;
    Point p;
    uchar *s;
    Fontchar *i;
    int w, width;

    p = Pt(0, f->height);
    s = (uchar*)cs;
    for(; c=*s; p.x+=width){
        width = 0;
        if(c < Runeself)
            s++;
        else{
            w = chartorune(&c, (char*)s);
            if(w == 0){
                s++;
                continue;
            }
            s += w;
        }
        if(c >= f->n)
            continue;
        i = f->info+c;
        width = i->width;
    }
    return p;
}
@


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/string.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<function memimagestring>>

<<function memsubfontwidth>>
@


\subsection*{[[lib_graphics/libmemdraw/subfont.c]]}

<<function allocmemsubfont>>=
Memsubfont*
allocmemsubfont(char *name, int n, int height, int ascent, Fontchar *info, Memimage *i)
{
    Memsubfont *f;

    f = malloc(sizeof(Memsubfont));
    if(f == 0)
        return 0;
    f->n = n;
    f->height = height;
    f->ascent = ascent;
    f->info = info;
    f->bits = i;
    if(name)
        f->name = strdup(name);
    else
        f->name = 0;
    return f;
}
@

<<function freememsubfont>>=
void
freememsubfont(Memsubfont *f)
{
    if(f == 0)
        return;
    free(f->info);	/* note: f->info must have been malloc'ed! */
    freememimage(f->bits);
    free(f);
}
@


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/subfont.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>

<<function allocmemsubfont>>

<<function freememsubfont>>
@

\subsection*{[[lib_graphics/libmemdraw/unload.c]]}



%-------------------------------------------------------------

<<lib_graphics/libmemdraw/unload.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>

<<function unloadmemimage>>
@


\subsection*{[[lib_graphics/libmemdraw/write.c]]}

<<constant CHUNK>>=
#define	CHUNK	8000
@

<<constant HSHIFT (lib_graphics/libmemdraw/write.c)>>=
#define	HSHIFT	3	/* HSHIFT==5 runs slightly faster, but hash table is 64x bigger */
@

<<constant NHASH (lib_graphics/libmemdraw/write.c)>>=
#define	NHASH	(1<<(HSHIFT*NMATCH))
@

<<constant HMASK (lib_graphics/libmemdraw/write.c)>>=
#define	HMASK	(NHASH-1)
@

<<function hupdate (lib_graphics/libmemdraw/write.c)>>=
#define	hupdate(h, c)	((((h)<<HSHIFT)^(c))&HMASK)
@

<<struct Hlist (lib_graphics/libmemdraw/write.c)>>=
struct Hlist{
    uchar *s;
    Hlist *next, *prev;
};
@

% called by???
<<function writememimage>>=
int
writememimage(int fd, Memimage *i)
{
    uchar *outbuf, *outp, *eout;		/* encoded data, pointer, end */
    uchar *loutp;				/* start of encoded line */
    Hlist *hash;				/* heads of hash chains of past strings */
    Hlist *chain, *hp;			/* hash chain members, pointer */
    Hlist *cp;				/* next Hlist to fall out of window */
    int h;					/* hash value */
    uchar *line, *eline;			/* input line, end pointer */
    uchar *data, *edata;			/* input buffer, end pointer */
    ulong n;				/* length of input buffer */
    ulong nb;				/* # of bytes returned by unloadimage */
    int bpl;				/* input line length */
    int offs, runlen;			/* offset, length of consumed data */
    uchar dumpbuf[NDUMP];			/* dump accumulator */
    int ndump;				/* length of dump accumulator */
    int miny, dy;				/* y values while unloading input */
    int ncblock;				/* size of compressed blocks */
    Rectangle r;
    uchar *p, *q, *s, *es, *t;
    char hdr[11+5*12+1];
    char cbuf[20];

    r = i->r;
    bpl = bytesperline(r, i->depth);
    n = Dy(r)*bpl;
    data = malloc(n);
    ncblock = _compblocksize(r, i->depth);
    outbuf = malloc(ncblock);
    hash = malloc(NHASH*sizeof(Hlist));
    chain = malloc(NMEM*sizeof(Hlist));
    if(data == 0 || outbuf == 0 || hash == 0 || chain == 0){
    ErrOut:
        free(data);
        free(outbuf);
        free(hash);
        free(chain);
        return -1;
    }
    for(miny = r.min.y; miny != r.max.y; miny += dy){
        dy = r.max.y-miny;
        if(dy*bpl > CHUNK)
            dy = CHUNK/bpl;
        nb = unloadmemimage(i, Rect(r.min.x, miny, r.max.x, miny+dy),
            data+(miny-r.min.y)*bpl, dy*bpl);
        if(nb != dy*bpl)
            goto ErrOut;
    }
    sprint(hdr, "compressed\n%11s %11d %11d %11d %11d ",
        chantostr(cbuf, i->chan), r.min.x, r.min.y, r.max.x, r.max.y);
    if(write(fd, hdr, 11+5*12) != 11+5*12)
        goto ErrOut;
    edata = data+n;
    eout = outbuf+ncblock;
    line = data;
    r.max.y = r.min.y;
    while(line != edata){
        memset(hash, 0, NHASH*sizeof(Hlist));
        memset(chain, 0, NMEM*sizeof(Hlist));
        cp = chain;
        h = 0;
        outp = outbuf;
        for(n = 0; n != NMATCH; n++)
            h = hupdate(h, line[n]);
        loutp = outbuf;
        while(line != edata){
            ndump = 0;
            eline = line+bpl;
            for(p = line; p != eline; ){
                if(eline-p < NRUN)
                    es = eline;
                else
                    es = p+NRUN;
                q = 0;
                runlen = 0;
                for(hp = hash[h].next; hp; hp = hp->next){
                    s = p + runlen;
                    if(s >= es)
                        continue;
                    t = hp->s + runlen;
                    for(; s >= p; s--)
                        if(*s != *t--)
                            goto matchloop;
                    t += runlen+2;
                    s += runlen+2;
                    for(; s < es; s++)
                        if(*s != *t++)
                            break;
                    n = s-p;
                    if(n > runlen){
                        runlen = n;
                        q = hp->s;
                        if(n == NRUN)
                            break;
                    }
            matchloop: ;
                }
                if(runlen < NMATCH){
                    if(ndump == NDUMP){
                        if(eout-outp < ndump+1)
                            goto Bfull;
                        *outp++ = ndump-1+128;
                        memmove(outp, dumpbuf, ndump);
                        outp += ndump;
                        ndump = 0;
                    }
                    dumpbuf[ndump++] = *p;
                    runlen = 1;
                }
                else{
                    if(ndump != 0){
                        if(eout-outp < ndump+1)
                            goto Bfull;
                        *outp++ = ndump-1+128;
                        memmove(outp, dumpbuf, ndump);
                        outp += ndump;
                        ndump = 0;
                    }
                    offs = p-q-1;
                    if(eout-outp < 2)
                        goto Bfull;
                    *outp++ = ((runlen-NMATCH)<<2) + (offs>>8);
                    *outp++ = offs&255;
                }
                for(q = p+runlen; p != q; p++){
                    if(cp->prev)
                        cp->prev->next = 0;
                    cp->next = hash[h].next;
                    cp->prev = &hash[h];
                    if(cp->next)
                        cp->next->prev = cp;
                    cp->prev->next = cp;
                    cp->s = p;
                    if(++cp == &chain[NMEM])
                        cp = chain;
                    if(edata-p > NMATCH)
                        h = hupdate(h, p[NMATCH]);
                }
            }
            if(ndump != 0){
                if(eout-outp < ndump+1)
                    goto Bfull;
                *outp++ = ndump-1+128;
                memmove(outp, dumpbuf, ndump);
                outp += ndump;
            }
            line = eline;
            loutp = outp;
            r.max.y++;
        }
    Bfull:
        if(loutp == outbuf)
            goto ErrOut;
        n = loutp-outbuf;
        sprint(hdr, "%11d %11ld ", r.max.y, n);
        write(fd, hdr, 2*12);
        write(fd, outbuf, n);
        r.min.y = r.max.y;
    }
    free(data);
    free(outbuf);
    free(hash);
    free(chain);
    return 0;
}
@


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/write.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>

<<constant CHUNK>>

<<constant HSHIFT (lib_graphics/libmemdraw/write.c)>>
<<constant NHASH (lib_graphics/libmemdraw/write.c)>>
<<constant HMASK (lib_graphics/libmemdraw/write.c)>>
<<function hupdate (lib_graphics/libmemdraw/write.c)>>
typedef struct Hlist Hlist;
<<struct Hlist (lib_graphics/libmemdraw/write.c)>>

<<function writememimage>>
@



\section{[[lib_graphics/libmemdraw/scripts/]]}

\subsection*{[[lib_graphics/libmemdraw/scripts/mkcmap.c]]}

<<function mkcmap>>=
/*
struct Memcmap
{
    uchar	cmap2rgb[3*256];
    uchar	rgb2cmap[16*16*16];
};
*/

static Memcmap*
mkcmap(void)
{
    static Memcmap def;

    int i, rgb, r, g, b;

    for(i=0; i<256; i++){
        rgb = cmap2rgb(i);
        r = (rgb>>16)&0xff;
        g = (rgb>>8)&0xff;
        b = rgb&0xff;
        def.cmap2rgb[3*i] = r;
        def.cmap2rgb[3*i+1] = g;
        def.cmap2rgb[3*i+2] = b;
    }

    for(r=0; r<16; r++)
    for(g=0; g<16; g++)
    for(b=0; b<16; b++)
        def.rgb2cmap[r*16*16+g*16+b] = rgb2cmap(r*0x11, g*0x11, b*0x11);
    return &def;
}
@

<<function main (lib_graphics/libmemdraw/scripts/mkcmap.c)>>=
void
main(int argc, char **argv)
{
    Memcmap *c;
    int i, j;

    ARGBEGIN{
    }ARGEND

    memimageinit();
    c = mkcmap();

    print("#include <u.h>\n#include <libc.h>\n");
    print("#include <draw.h>\n");
    print("#include <memdraw.h>\n\n");
    print("static Memcmap def = {\n");
    print("/* cmap2rgb */ {\n");
    for(i=0; i<sizeof(c->cmap2rgb); ){
        print("\t");
        for(j=0; j<16; j++, i++)
            print("0x%2.2ux,", c->cmap2rgb[i]);
        print("\n");
    }
    print("},\n");
    print("/* rgb2cmap */ {\n");
    for(i=0; i<sizeof(c->rgb2cmap);){
        print("\t");
        for(j=0; j<16; j++, i++)
            print("0x%2.2ux,", c->rgb2cmap[i]);
        print("\n");
    }
    print("}\n");
    print("};\n");
    print("Memcmap *memdefcmap = &def;\n");
    print("void _memmkcmap(void){}\n");
    exits(0);
}
@


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/scripts/mkcmap.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>

<<function mkcmap>>

<<function main (lib_graphics/libmemdraw/scripts/mkcmap.c)>>
@


\section{[[lib_graphics/libmemdraw/tests/]]}

\subsection*{[[lib_graphics/libmemdraw/tests/arctest.c]]}

<<function main (lib_graphics/libmemdraw/tests/arctest.c)>>=
void
main(int argc, char **argv)
{
    Memimage *x;
    Point c = {208,871};
    int a = 441;
    int b = 441;
    int thick = 0;
    Point sp = {0,0};
    int alpha = 51;
    int phi = 3;
    vlong t0, t1;
    int i, n;
    vlong del;

    if (argc != 2) {
        fprint(2, "usage: arctest number\n");
        exits("usage");
    }
    memimageinit();

    x = allocmemimage(Rect(0,0,1000,1000), CMAP8);
    n = atoi(argv[1]);

    t0 = nsec();
    t0 = nsec();
    t0 = nsec();
    t1 = nsec();
    del = t1-t0;
    t0 = nsec();
    for(i=0; i<n; i++)
        memarc(x, c, a, b, thick, memblack, sp, alpha, phi, SoverD);
    t1 = nsec();
    print("%lld %lld\n", t1-t0-del, del);
}
@


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/tests/arctest.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<function main (lib_graphics/libmemdraw/tests/arctest.c)>>
@

%//static int drawdebug = 0;
%//
%//void
%//rdb(void)
%//{
%//}
%//
%//int
%//iprint(char *fmt, ...)
%//{
%//	int n;	
%//	va_list va;
%//	char buf[1024];
%//
%//	va_start(va, fmt);
%//	n = vseprint(buf, buf+sizeof buf, fmt, va) - buf;
%//	va_end(va);
%//
%//	write(1,buf,n);
%//	return 1;
%//}


\subsection*{[[lib_graphics/libmemdraw/tests/memdrawtest.c]]}

<<function RGB2K (lib_graphics/libmemdraw/tests/memdrawtest.c)>>=
//#define DBG if(0)
#define RGB2K(r,g,b)	((299*((ulong)(r))+587*((ulong)(g))+114*((ulong)(b)))/1000)
@

<<global drawdebug (lib_graphics/libmemdraw/tests/memdrawtest.c)>>=
//old: used to have static in front, but at some point I got
//some errors (I probably introduced some regressions in 8c of kencc)
int drawdebug=0;
@

<<global seed>>=
static int	seed;
@

<<global niters>>=
static int	niters = 100;
@

<<global dbpp>>=
static int	dbpp;	/* bits per pixel in destination */
@

<<global sbpp>>=
static int	sbpp;	/* bits per pixel in src */
@

<<global mbpp>>=
static int	mbpp;	/* bits per pixel in mask */
@

<<global dpm>>=
static int	dpm;	/* pixel mask at high part of byte, in destination */
@

<<global nbytes>>=
static int	nbytes;	/* in destination */
@

<<global Xrange>>=
static int	Xrange	= 64;
@

<<global Yrange>>=
static int	Yrange	= 8;
@

<<global dst>>=
static Memimage	*dst;
@

<<global src>>=
static Memimage	*src;
@

<<global mask>>=
static Memimage	*mask;
@

<<global stmp>>=
static Memimage	*stmp;
@

<<global mtmp>>=
static Memimage	*mtmp;
@

<<global ones (lib_graphics/libmemdraw/tests/memdrawtest.c)>>=
static Memimage	*ones;
@

<<global dstbits>>=
static uchar	*dstbits;
@

<<global srcbits>>=
static uchar	*srcbits;
@

<<global maskbits>>=
static uchar	*maskbits;
@

<<global savedstbits>>=
static ulong	*savedstbits;
@

<<function main (lib_graphics/libmemdraw/tests/memdrawtest.c)>>=
void
main(int argc, char *argv[])
{
    memimageinit();
    seed = time(0);

    ARGBEGIN{
    case 'x':
        Xrange = atoi(ARGF());
        break;
    case 'y':
        Yrange = atoi(ARGF());
        break;
    case 'n':
        niters = atoi(ARGF());
        break;
    case 's':
        seed = atoi(ARGF());
        break;
    }ARGEND

    dchan = "r8g8b8";
    schan = "r8g8b8";
    mchan = "r8g8b8";
    switch(argc){
    case 3:	mchan = argv[2];
    case 2:	schan = argv[1];
    case 1:	dchan = argv[0];
    case 0:	break;
    default:	goto Usage;
    Usage:
        fprint(2, "usage: dtest [dchan [schan [mchan]]]\n");
        exits("usage");
    }

//	fmtinstall('b', numbconv);	/* binary! */

    fprint(2, "%s -x %d -y %d -s 0x%x %s %s %s\n", argv0, Xrange, Yrange, seed, dchan, schan, mchan);
    srand(seed);

    dst = allocmemimage(Rect(0, 0, Xrange, Yrange), strtochan(dchan));
    src = allocmemimage(Rect(0, 0, Xrange, Yrange), strtochan(schan));
    mask = allocmemimage(Rect(0, 0, Xrange, Yrange), strtochan(mchan));
    stmp = allocmemimage(Rect(0, 0, Xrange, Yrange), strtochan(schan));
    mtmp = allocmemimage(Rect(0, 0, Xrange, Yrange), strtochan(mchan));
    ones = allocmemimage(Rect(0, 0, Xrange, Yrange), strtochan(mchan));
//	print("chan %lux %lux %lux %lux %lux %lux\n", dst->chan, src->chan, mask->chan, stmp->chan, mtmp->chan, ones->chan);
    if(dst==0 || src==0 || mask==0 || mtmp==0 || ones==0) {
    Alloc:
        fprint(2, "dtest: allocation failed: %r\n");
        exits("alloc");
    }
    nbytes = (4*Xrange+4)*Yrange;
    srcbits = malloc(nbytes);
    dstbits = malloc(nbytes);
    maskbits = malloc(nbytes);
    savedstbits = malloc(nbytes);
    if(dstbits==0 || srcbits==0 || maskbits==0 || savedstbits==0)
        goto Alloc;
    dbpp = dst->depth;
    sbpp = src->depth;
    mbpp = mask->depth;
    dpm = 0xFF ^ (0xFF>>dbpp);
    memset(ones->data->bdata, 0xFF, ones->width*sizeof(ulong)*Yrange);


    fprint(2, "dtest: verify single pixel operation\n");
    verifyone();

    fprint(2, "dtest: verify full line non-replicated\n");
    verifyline();

    fprint(2, "dtest: verify full rectangle non-replicated\n");
    verifyrect();

    fprint(2, "dtest: verify full rectangle source replicated\n");
    verifyrectrepl(1, 0);

    fprint(2, "dtest: verify full rectangle mask replicated\n");
    verifyrectrepl(0, 1);

    fprint(2, "dtest: verify full rectangle source and mask replicated\n");
    verifyrectrepl(1, 1);

    exits(0);
}
@

<<function Bprintr5g6b5>>=
/*
 * Dump out an ASCII representation of an image.  The label specifies
 * a list of characters to put at various points in the picture.
 */
static void
Bprintr5g6b5(Biobuf *bio, char*, ulong v)
{
    int r,g,b;
    r = (v>>11)&31;
    g = (v>>5)&63;
    b = v&31;
    Bprint(bio, "%.2x%.2x%.2x", r,g,b);
}
@

<<function Bprintr5g5b5a1>>=
static void
Bprintr5g5b5a1(Biobuf *bio, char*, ulong v)
{
    int r,g,b,a;
    r = (v>>11)&31;
    g = (v>>6)&31;
    b = (v>>1)&31;
    a = v&1;
    Bprint(bio, "%.2x%.2x%.2x%.2x", r,g,b,a);
}
@

<<function dumpimage>>=
void
dumpimage(char *name, Memimage *img, void *vdata, Point labelpt)
{
    Biobuf b;
    uchar *data;
    uchar *p;
    char *arg;
    void (*fmt)(Biobuf*, char*, ulong);
    int npr, x, y, nb, bpp;
    ulong v, mask;
    Rectangle r;

    fmt = nil;
    arg = nil;
    switch(img->depth){
    case 1:
    case 2:
    case 4:
        fmt = (void(*)(Biobuf*,char*,ulong))Bprint;
        arg = "%.1ux";
        break;
    case 8:
        fmt = (void(*)(Biobuf*,char*,ulong))Bprint;
        arg = "%.2ux";
        break;
    case 16:
        arg = nil;
        if(img->chan == RGB16)
            fmt = Bprintr5g6b5;
        else{
            fmt = (void(*)(Biobuf*,char*,ulong))Bprint;
            arg = "%.4ux";
        }
        break;
    case 24:
        fmt = (void(*)(Biobuf*,char*,ulong))Bprint;
        arg = "%.6lux";
        break;
    case 32:
        fmt = (void(*)(Biobuf*,char*,ulong))Bprint;
        arg = "%.8lux";
        break;
    }
    if(fmt == nil){
        fprint(2, "bad format\n");
        abort();
    }

    r  = img->r;
    Binit(&b, 2, OWRITE);
    data = vdata;
    bpp = img->depth;
    Bprint(&b, "%s\t%d\tr %R clipr %R repl %d data %p *%P\n", name, r.min.x, r, img->clipr, (img->flags&Frepl) ? 1 : 0, vdata, labelpt);
    mask = (1ULL<<bpp)-1;
//	for(y=r.min.y; y<r.max.y; y++){
    for(y=0; y<Yrange; y++){
        nb = 0;
        v = 0;
        p = data+(byteaddr(img, Pt(0,y))-(uchar*)img->data->bdata);
        Bprint(&b, "%-4d\t", y);
//		for(x=r.min.x; x<r.max.x; x++){
        for(x=0; x<Xrange; x++){
            if(x==0)
                Bprint(&b, "\t");

            if(x != 0 && (x%8)==0)
                Bprint(&b, " ");

            npr = 0;
            if(x==labelpt.x && y==labelpt.y){
                Bprint(&b, "*");
                npr++;
            }
            if(npr == 0)
                Bprint(&b, " ");

            while(nb < bpp){
                v &= (1<<nb)-1;
                v |= (ulong)(*p++) << nb;
                nb += 8;
            }
            nb -= bpp;
//			print("bpp %d v %.8lux mask %.8lux nb %d\n", bpp, v, mask, nb);
            fmt(&b, arg, (v>>nb)&mask);
        }
        Bprint(&b, "\n");
    }
    Bterm(&b);
}
@
% >> >>

<<function checkone>>=
/*
 * Verify that the destination pixel has the specified value.
 * The value is in the high bits of v, suitably masked, but must
 * be extracted from the destination Memimage.
 */
void
checkone(Point p, Point sp, Point mp)
{
    int delta;
    uchar *dp, *sdp;

    delta = (uchar*)byteaddr(dst, p)-(uchar*)dst->data->bdata;
    dp = (uchar*)dst->data->bdata+delta;
    sdp = (uchar*)savedstbits+delta;

    if(memcmp(dp, sdp, (dst->depth+7)/8) != 0) {
        fprint(2, "dtest: one bad pixel drawing at dst %P from source %P mask %P\n", p, sp, mp);
        fprint(2, " %.2ux %.2ux %.2ux %.2ux should be %.2ux %.2ux %.2ux %.2ux\n",
            dp[0], dp[1], dp[2], dp[3], sdp[0], sdp[1], sdp[2], sdp[3]);
        fprint(2, "addresses dst %p src %p mask %p\n", dp, byteaddr(src, sp), byteaddr(mask, mp));
        dumpimage("src", src, src->data->bdata, sp);
        dumpimage("mask", mask, mask->data->bdata, mp);
        dumpimage("origdst", dst, dstbits, p);
        dumpimage("dst", dst, dst->data->bdata, p);
        dumpimage("gooddst", dst, savedstbits, p);
        abort();
    }
}
@

<<function RECTPTS>>=
/*
 * Verify that the destination line has the same value as the saved line.
 */
#define RECTPTS(r) (r).min.x, (r).min.y, (r).max.x, (r).max.y
@

<<function checkline>>=
void
checkline(Rectangle r, Point sp, Point mp, int y, Memimage *stmp, Memimage *mtmp)
{
    ulong *dp;
    int nb;
    ulong *saved;

    dp = wordaddr(dst, Pt(0, y));
    saved = savedstbits + y*dst->width;
    if(dst->depth < 8)
        nb = Xrange/(8/dst->depth);
    else
        nb = Xrange*(dst->depth/8);
    if(memcmp(dp, saved, nb) != 0){
        fprint(2, "dtest: bad line at y=%d; saved %p dp %p\n", y, saved, dp);
        fprint(2, "draw dst %R src %P mask %P\n", r, sp, mp);
        dumpimage("src", src, src->data->bdata, sp);
        if(stmp) dumpimage("stmp", stmp, stmp->data->bdata, sp);
        dumpimage("mask", mask, mask->data->bdata, mp);
        if(mtmp) dumpimage("mtmp", mtmp, mtmp->data->bdata, mp);
        dumpimage("origdst", dst, dstbits, r.min);
        dumpimage("dst", dst, dst->data->bdata, r.min);
        dumpimage("gooddst", dst, savedstbits, r.min);
        abort();
    }
}
@

<<function fill>>=
/*
 * Fill the bits of an image with random data.
 * The Memimage parameter is used only to make sure
 * the data is well formatted: only ucbits is written.
 */
void
fill(Memimage *img, uchar *ucbits)
{
    int i, x, y;
    ushort *up;
    uchar alpha, r, g, b;
    void *data;

    if((img->flags&Falpha) == 0){
        up = (ushort*)ucbits;
        for(i=0; i<nbytes/2; i++)
            *up++ = lrand() >> 7;
        if(i+i != nbytes)
            *(uchar*)up = lrand() >> 7;
    }else{
        data = img->data->bdata;
        img->data->bdata = ucbits;

        for(x=img->r.min.x; x<img->r.max.x; x++)
        for(y=img->r.min.y; y<img->r.max.y; y++){
            alpha = rand() >> 4;
            r = rand()%(alpha+1);
            g = rand()%(alpha+1);
            b = rand()%(alpha+1);
            putpixel(img, Pt(x,y), rgbatopix(r,g,b,alpha));
        }
        img->data->bdata = data;
    }
        
}
@

<<function verifyonemask>>=
/*
 * Mask is preset; do the rest
 */
void
verifyonemask(void)
{
    Point dp, sp, mp;

    fill(dst, dstbits);
    fill(src, srcbits);
    memmove(dst->data->bdata, dstbits, dst->width*sizeof(ulong)*Yrange);
    memmove(src->data->bdata, srcbits, src->width*sizeof(ulong)*Yrange);
    memmove(mask->data->bdata, maskbits, mask->width*sizeof(ulong)*Yrange);

    dp.x = nrand(Xrange);
    dp.y = nrand(Yrange);

    sp.x = nrand(Xrange);
    sp.y = nrand(Yrange);

    mp.x = nrand(Xrange);
    mp.y = nrand(Yrange);

    drawonepixel(dst, dp, src, sp, mask, mp);
    memmove(mask->data->bdata, maskbits, mask->width*sizeof(ulong)*Yrange);
    memmove(savedstbits, dst->data->bdata, dst->width*sizeof(ulong)*Yrange);
    
    memmove(dst->data->bdata, dstbits, dst->width*sizeof(ulong)*Yrange);
    memimagedraw(dst, Rect(dp.x, dp.y, dp.x+1, dp.y+1), src, sp, mask, mp, SoverD);
    memmove(mask->data->bdata, maskbits, mask->width*sizeof(ulong)*Yrange);

    checkone(dp, sp, mp);
}
@

<<function verifyone>>=
void
verifyone(void)
{
    int i;

    /* mask all zeros */
    memset(maskbits, 0, nbytes);
    for(i=0; i<niters; i++)
        verifyonemask();

    /* mask all ones */
    memset(maskbits, 0xFF, nbytes);
    for(i=0; i<niters; i++)
        verifyonemask();

    /* random mask */
    for(i=0; i<niters; i++){
        fill(mask, maskbits);
        verifyonemask();
    }
}
@

<<function verifylinemask>>=
/*
 * Mask is preset; do the rest
 */
void
verifylinemask(void)
{
    Point sp, mp, tp, up;
    Rectangle dr;
    int x;

    fill(dst, dstbits);
    fill(src, srcbits);
    memmove(dst->data->bdata, dstbits, dst->width*sizeof(ulong)*Yrange);
    memmove(src->data->bdata, srcbits, src->width*sizeof(ulong)*Yrange);
    memmove(mask->data->bdata, maskbits, mask->width*sizeof(ulong)*Yrange);

    dr.min.x = nrand(Xrange-1);
    dr.min.y = nrand(Yrange-1);
    dr.max.x = dr.min.x + 1 + nrand(Xrange-1-dr.min.x);
    dr.max.y = dr.min.y + 1;

    sp.x = nrand(Xrange);
    sp.y = nrand(Yrange);

    mp.x = nrand(Xrange);
    mp.y = nrand(Yrange);

    tp = sp;
    up = mp;
    for(x=dr.min.x; x<dr.max.x && tp.x<Xrange && up.x<Xrange; x++,tp.x++,up.x++)
        memimagedraw(dst, Rect(x, dr.min.y, x+1, dr.min.y+1), src, tp, mask, up, SoverD);
    memmove(savedstbits, dst->data->bdata, dst->width*sizeof(ulong)*Yrange);

    memmove(dst->data->bdata, dstbits, dst->width*sizeof(ulong)*Yrange);

    memimagedraw(dst, dr, src, sp, mask, mp, SoverD);
    checkline(dr, drawrepl(src->r, sp), drawrepl(mask->r, mp), dr.min.y, nil, nil);
}
@

<<function verifyline>>=
void
verifyline(void)
{
    int i;

    /* mask all ones */
    memset(maskbits, 0xFF, nbytes);
    for(i=0; i<niters; i++)
        verifylinemask();

    /* mask all zeros */
    memset(maskbits, 0, nbytes);
    for(i=0; i<niters; i++)
        verifylinemask();

    /* random mask */
    for(i=0; i<niters; i++){
        fill(mask, maskbits);
        verifylinemask();
    }
}
@

<<function verifyrectmask>>=
/*
 * Mask is preset; do the rest
 */
void
verifyrectmask(void)
{
    Point sp, mp, tp, up;
    Rectangle dr;
    int x, y;

    fill(dst, dstbits);
    fill(src, srcbits);
    memmove(dst->data->bdata, dstbits, dst->width*sizeof(ulong)*Yrange);
    memmove(src->data->bdata, srcbits, src->width*sizeof(ulong)*Yrange);
    memmove(mask->data->bdata, maskbits, mask->width*sizeof(ulong)*Yrange);

    dr.min.x = nrand(Xrange-1);
    dr.min.y = nrand(Yrange-1);
    dr.max.x = dr.min.x + 1 + nrand(Xrange-1-dr.min.x);
    dr.max.y = dr.min.y + 1 + nrand(Yrange-1-dr.min.y);

    sp.x = nrand(Xrange);
    sp.y = nrand(Yrange);

    mp.x = nrand(Xrange);
    mp.y = nrand(Yrange);

    tp = sp;
    up = mp;
    for(y=dr.min.y; y<dr.max.y && tp.y<Yrange && up.y<Yrange; y++,tp.y++,up.y++){
        for(x=dr.min.x; x<dr.max.x && tp.x<Xrange && up.x<Xrange; x++,tp.x++,up.x++)
            memimagedraw(dst, Rect(x, y, x+1, y+1), src, tp, mask, up, SoverD);
        tp.x = sp.x;
        up.x = mp.x;
    }
    memmove(savedstbits, dst->data->bdata, dst->width*sizeof(ulong)*Yrange);

    memmove(dst->data->bdata, dstbits, dst->width*sizeof(ulong)*Yrange);

    memimagedraw(dst, dr, src, sp, mask, mp, SoverD);
    for(y=0; y<Yrange; y++)
        checkline(dr, drawrepl(src->r, sp), drawrepl(mask->r, mp), y, nil, nil);
}
@

<<function verifyrect>>=
void
verifyrect(void)
{
    int i;

    /* mask all zeros */
    memset(maskbits, 0, nbytes);
    for(i=0; i<niters; i++)
        verifyrectmask();

    /* mask all ones */
    memset(maskbits, 0xFF, nbytes);
    for(i=0; i<niters; i++)
        verifyrectmask();

    /* random mask */
    for(i=0; i<niters; i++){
        fill(mask, maskbits);
        verifyrectmask();
    }
}
@

<<function randrect>>=
Rectangle
randrect(void)
{
    Rectangle r;

    r.min.x = nrand(Xrange-1);
    r.min.y = nrand(Yrange-1);
    r.max.x = r.min.x + 1 + nrand(Xrange-1-r.min.x);
    r.max.y = r.min.y + 1 + nrand(Yrange-1-r.min.y);
    return r;
}
@

<<function tilexy>>=
/*
 * Return coordinate corresponding to x withing range [minx, maxx)
 */
int
tilexy(int minx, int maxx, int x)
{
    int sx;

    sx = (x-minx) % (maxx-minx);
    if(sx < 0)
        sx += maxx-minx;
    return sx+minx;
}
@

<<function replicate>>=
void
replicate(Memimage *i, Memimage *tmp)
{
    Rectangle r, r1;
    int x, y, nb;

    /* choose the replication window (i->r) */
    r.min.x = nrand(Xrange-1);
    r.min.y = nrand(Yrange-1);
    /* make it trivial more often than pure chance allows */
    switch(lrand()&0){
    case 1:
        r.max.x = r.min.x + 2;
        r.max.y = r.min.y + 2;
        if(r.max.x < Xrange && r.max.y < Yrange)
            break;
        /* fall through */
    case 0:
        r.max.x = r.min.x + 1;
        r.max.y = r.min.y + 1;
        break;
    default:
        if(r.min.x+3 >= Xrange)
            r.max.x = Xrange;
        else
            r.max.x = r.min.x+3 + nrand(Xrange-(r.min.x+3));

        if(r.min.y+3 >= Yrange)
            r.max.y = Yrange;
        else
            r.max.y = r.min.y+3 + nrand(Yrange-(r.min.y+3));
    }
    assert(r.min.x >= 0);	
    assert(r.max.x <= Xrange);
    assert(r.min.y >= 0);
    assert(r.max.y <= Yrange);
    /* copy from i to tmp so we have just the replicated bits */
    nb = tmp->width*sizeof(ulong)*Yrange;
    memset(tmp->data->bdata, 0, nb);
    memimagedraw(tmp, r, i, r.min, ones, r.min, SoverD);
    memmove(i->data->bdata, tmp->data->bdata, nb);
    /* i is now a non-replicated instance of the replication */
    /* replicate it by hand through tmp */
    memset(tmp->data->bdata, 0, nb);
    x = -(tilexy(r.min.x, r.max.x, 0)-r.min.x);
    for(; x<Xrange; x+=Dx(r)){
        y = -(tilexy(r.min.y, r.max.y, 0)-r.min.y);
        for(; y<Yrange; y+=Dy(r)){
            /* set r1 to instance of tile by translation */
            r1.min.x = x;
            r1.min.y = y;
            r1.max.x = r1.min.x+Dx(r);
            r1.max.y = r1.min.y+Dy(r);
            memimagedraw(tmp, r1, i, r.min, ones, r.min, SoverD);
        }
    }
    i->flags |= Frepl;
    i->r = r;
    i->clipr = randrect();
//	fprint(2, "replicate [[%d %d] [%d %d]] [[%d %d][%d %d]]\n", r.min.x, r.min.y, r.max.x, r.max.y,
//		i->clipr.min.x, i->clipr.min.y, i->clipr.max.x, i->clipr.max.y);
    tmp->clipr = i->clipr;
}
@

<<function verifyrectmaskrepl>>=
/*
 * Mask is preset; do the rest
 */
void
verifyrectmaskrepl(int srcrepl, int maskrepl)
{
    Point sp, mp, tp, up;
    Rectangle dr;
    int x, y;
    Memimage *s, *m;

//	print("verfrect %d %d\n", srcrepl, maskrepl);
    src->flags &= ~Frepl;
    src->r = Rect(0, 0, Xrange, Yrange);
    src->clipr = src->r;
    stmp->flags &= ~Frepl;
    stmp->r = Rect(0, 0, Xrange, Yrange);
    stmp->clipr = src->r;
    mask->flags &= ~Frepl;
    mask->r = Rect(0, 0, Xrange, Yrange);
    mask->clipr = mask->r;
    mtmp->flags &= ~Frepl;
    mtmp->r = Rect(0, 0, Xrange, Yrange);
    mtmp->clipr = mask->r;

    fill(dst, dstbits);
    fill(src, srcbits);

    memmove(dst->data->bdata, dstbits, dst->width*sizeof(ulong)*Yrange);
    memmove(src->data->bdata, srcbits, src->width*sizeof(ulong)*Yrange);
    memmove(mask->data->bdata, maskbits, mask->width*sizeof(ulong)*Yrange);

    if(srcrepl){
        replicate(src, stmp);
        s = stmp;
    }else
        s = src;
    if(maskrepl){
        replicate(mask, mtmp);
        m = mtmp;
    }else
        m = mask;

    dr = randrect();

    sp.x = nrand(Xrange);
    sp.y = nrand(Yrange);

    mp.x = nrand(Xrange);
    mp.y = nrand(Yrange);

    //DBG	print("smalldraws\n");
    for(tp.y=sp.y,up.y=mp.y,y=dr.min.y; y<dr.max.y && tp.y<Yrange && up.y<Yrange; y++,tp.y++,up.y++)
        for(tp.x=sp.x,up.x=mp.x,x=dr.min.x; x<dr.max.x && tp.x<Xrange && up.x<Xrange; x++,tp.x++,up.x++)
            memimagedraw(dst, Rect(x, y, x+1, y+1), s, tp, m, up, SoverD);
    memmove(savedstbits, dst->data->bdata, dst->width*sizeof(ulong)*Yrange);

    memmove(dst->data->bdata, dstbits, dst->width*sizeof(ulong)*Yrange);

    //DBG	print("bigdraw\n");
    memimagedraw(dst, dr, src, sp, mask, mp, SoverD);
    for(y=0; y<Yrange; y++)
        checkline(dr, drawrepl(src->r, sp), drawrepl(mask->r, mp), y, srcrepl?stmp:nil, maskrepl?mtmp:nil);
}
@

<<function verifyrectrepl>>=
void
verifyrectrepl(int srcrepl, int maskrepl)
{
    int i;

    /* mask all ones */
    memset(maskbits, 0xFF, nbytes);
    for(i=0; i<niters; i++)
        verifyrectmaskrepl(srcrepl, maskrepl);

    /* mask all zeros */
    memset(maskbits, 0, nbytes);
    for(i=0; i<niters; i++)
        verifyrectmaskrepl(srcrepl, maskrepl);

    /* random mask */
    for(i=0; i<niters; i++){
        fill(mask, maskbits);
        verifyrectmaskrepl(srcrepl, maskrepl);
    }
}
@

<<function replbits>>=
/*
 * Convert v, which is nhave bits wide, into its nwant bits wide equivalent.
 * Replicates to widen the value, truncates to narrow it.
 */
ulong
replbits(ulong v, int nhave, int nwant)
{
    v &= (1<<nhave)-1;
    for(; nhave<nwant; nhave*=2)
        v |= v<<nhave;
    v >>= (nhave-nwant);
    return v & ((1<<nwant)-1);
}
@

<<function pixtorgba>>=
/*
 * Decode a pixel into the uchar* values.
 */
void
pixtorgba(ulong v, uchar *r, uchar *g, uchar *b, uchar *a)
{
    *a = v>>24;
    *r = v>>16;
    *g = v>>8;
    *b = v;
}
@

<<function rgbatopix>>=
/*
 * Convert uchar channels into ulong pixel.
 */
ulong
rgbatopix(uchar r, uchar g, uchar b, uchar a)
{
    return (a<<24)|(r<<16)|(g<<8)|b;
}
@

<<function getpixel>>=
/*
 * Retrieve the pixel value at pt in the image.
 */
ulong
getpixel(Memimage *img, Point pt)
{
    uchar r, g, b, a, *p;
    int nbits, npack, bpp;
    ulong v, c, rbits, bits;

    r = g = b = 0;
    a = ~0;	/* default alpha is full */

    p = byteaddr(img, pt);
    v = p[0]|(p[1]<<8)|(p[2]<<16)|(p[3]<<24);
    bpp = img->depth;
    if(bpp<8){
        /*
         * Sub-byte greyscale pixels.
         *
         * We want to throw away the top pt.x%npack pixels and then use the next bpp bits
         * in the bottom byte of v.  This madness is due to having big endian bits
         * but little endian bytes.
         */
        npack = 8/bpp;
        v >>= 8 - bpp*(pt.x%npack+1);
        v &= (1<<bpp)-1;
        r = g = b = replbits(v, bpp, 8);
    }else{
        /*
         * General case.  We need to parse the channel descriptor and do what it says.
         * In all channels but the color map, we replicate to 8 bits because that's the
         * precision that all calculations are done at.
         *
         * In the case of the color map, we leave the bits alone, in case a color map
         * with less than 8 bits of index is used.  This is currently disallowed, so it's
         * sort of silly.
         */

        for(c=img->chan; c; c>>=8){
            nbits = NBITS(c);
            bits = v & ((1<<nbits)-1);
            rbits = replbits(bits, nbits, 8);
            v >>= nbits;
            switch(TYPE(c)){
            case CRed:
                r = rbits;
                break;
            case CGreen:
                g = rbits;
                break;
            case CBlue:
                b = rbits;
                break;
            case CGrey:
                r = g = b = rbits;
                break;
            case CAlpha:
                a = rbits;
                break;
            case CMap:
                p = img->cmap->cmap2rgb + 3*bits;
                r = p[0];
                g = p[1];
                b = p[2];
                break;
            case CIgnore:
                break;
            default:
                fprint(2, "unknown channel type %lud\n", TYPE(c));
                abort();
            }
        }
    }
    return rgbatopix(r, g, b, a);
}
@
% >> >> >> >> >>

<<function getgrey>>=
/*
 * Return the greyscale equivalent of a pixel.
 */
uchar
getgrey(Memimage *img, Point pt)
{
    uchar r, g, b, a;
    pixtorgba(getpixel(img, pt), &r, &g, &b, &a);
    return RGB2K(r, g, b);
}
@

<<function getmask>>=
/*
 * Return the value at pt in image, if image is interpreted
 * as a mask.  This means the alpha channel if present, else
 * the greyscale or its computed equivalent.
 */
uchar
getmask(Memimage *img, Point pt)
{
    if(img->flags&Falpha)
        return getpixel(img, pt)>>24;
    else
        return getgrey(img, pt);
}
@

<<function putpixel>>=
/*
 * Write a pixel to img at point pt.
 * 
 * We do this by reading a 32-bit little endian
 * value from p and then writing it back
 * after tweaking the appropriate bits.  Because
 * the data is little endian, we don't have to worry
 * about what the actual depth is, as long as it is
 * less than 32 bits.
 */
void
putpixel(Memimage *img, Point pt, ulong nv)
{
    uchar r, g, b, a, *p, *q;
    ulong c, mask, bits, v;
    int bpp, sh, npack, nbits;

    pixtorgba(nv, &r, &g, &b, &a);

    p = byteaddr(img, pt);
    v = p[0]|(p[1]<<8)|(p[2]<<16)|(p[3]<<24);
    bpp = img->depth;
    //DBG print("v %.8lux...", v);
    if(bpp < 8){
        /*
         * Sub-byte greyscale pixels.  We need to skip the leftmost pt.x%npack pixels,
         * which is equivalent to skipping the rightmost npack - pt.x%npack - 1 pixels.
         */	
        npack = 8/bpp;
        sh = bpp*(npack - pt.x%npack - 1);
        bits = RGB2K(r,g,b);
        //DBG print("repl %lux 8 %d = %lux...", bits, bpp, replbits(bits, 8, bpp));
        bits = replbits(bits, 8, bpp);
        mask = (1<<bpp)-1;
        //DBG print("bits %lux mask %lux sh %d...", bits, mask, sh);
        mask <<= sh;
        bits <<= sh;
        //DBG print("(%lux & %lux) | (%lux & %lux)", v, ~mask, bits, mask);
        v = (v & ~mask) | (bits & mask);
    } else {
        /*
         * General case.  We need to parse the channel descriptor again.
         */
        sh = 0;
        for(c=img->chan; c; c>>=8){
            nbits = NBITS(c);
            switch(TYPE(c)){
            case CRed:
                bits = r;
                break;
            case CGreen:
                bits = g;
                break;
            case CBlue:
                bits = b;
                break;
            case CGrey:
                bits = RGB2K(r, g, b);
                break;
            case CAlpha:
                bits = a;
                break;
            case CIgnore:
                bits = 0;
                break;
            case CMap:
                q = img->cmap->rgb2cmap;
                bits = q[(r>>4)*16*16+(g>>4)*16+(b>>4)];
                break;
            default:
                SET(bits);
                fprint(2, "unknown channel type %lud\n", TYPE(c));
                abort();
            }

            //DBG print("repl %lux 8 %d = %lux...", bits, nbits, replbits(bits, 8, nbits));
            if(TYPE(c) != CMap)
                bits = replbits(bits, 8, nbits);
            mask = (1<<nbits)-1;
            //DBG print("bits %lux mask %lux sh %d...", bits, mask, sh);
            bits <<= sh;
            mask <<= sh;
            v = (v & ~mask) | (bits & mask);
            sh += nbits;
        }
    }
    //DBG print("v %.8lux\n", v);
    p[0] = v;
    p[1] = v>>8;
    p[2] = v>>16;
    p[3] = v>>24;	
}
@

<<function drawonepixel>>=
//#define DBG if(0)

void
drawonepixel(Memimage *dst, Point dp, Memimage *src, Point sp, Memimage *mask, Point mp)
{
    uchar m, M, sr, sg, sb, sa, sk, dr, dg, db, da, dk;

    pixtorgba(getpixel(dst, dp), &dr, &dg, &db, &da);
    pixtorgba(getpixel(src, sp), &sr, &sg, &sb, &sa);
    m = getmask(mask, mp);
    M = 255-(sa*m)/255;

    //DBG print("dst %x %x %x %x src %x %x %x %x m %x = ", dr,dg,db,da, sr,sg,sb,sa, m);
    if(dst->flags&Fgrey){
        /*
         * We need to do the conversion to grey before the alpha calculation
         * because the draw operator does this, and we need to be operating
         * at the same precision so we get exactly the same answers.
         */
        sk = RGB2K(sr, sg, sb);
        dk = RGB2K(dr, dg, db);
        dk = (sk*m + dk*M)/255;
        dr = dg = db = dk;
        da = (sa*m + da*M)/255;
    }else{
        /*
         * True color alpha calculation treats all channels (including alpha)
         * the same.  It might have been nice to use an array, but oh well.
         */
        dr = (sr*m + dr*M)/255;
        dg = (sg*m + dg*M)/255;
        db = (sb*m + db*M)/255;
        da = (sa*m + da*M)/255;
    }

    //DBG print("%x %x %x %x\n", dr,dg,db,da);
    putpixel(dst, dp, rgbatopix(dr, dg, db, da));
}
@


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/tests/memdrawtest.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <draw.h>
#include <memdraw.h>

<<function RGB2K (lib_graphics/libmemdraw/tests/memdrawtest.c)>>

/*
 * This program tests the 'memimagedraw' primitive stochastically.
 * It tests the combination aspects of it thoroughly, but since the
 * three images it uses are disjoint, it makes no check of the
 * correct behavior when images overlap.  That is, however, much
 * easier to get right and to test.
 */

void	drawonepixel(Memimage*, Point, Memimage*, Point, Memimage*, Point);
void	verifyone(void);
void	verifyline(void);
void	verifyrect(void);
void	verifyrectrepl(int, int);
void putpixel(Memimage *img, Point pt, ulong nv);
ulong rgbatopix(uchar, uchar, uchar, uchar);

static char *dchan, *schan, *mchan;

<<global drawdebug (lib_graphics/libmemdraw/tests/memdrawtest.c)>>
<<global seed>>
<<global niters>>
<<global dbpp>>
<<global sbpp>>
<<global mbpp>>
<<global dpm>>
<<global nbytes>>

<<global Xrange>>
<<global Yrange>>

<<global dst>>
<<global src>>
<<global mask>>
<<global stmp>>
<<global mtmp>>
<<global ones (lib_graphics/libmemdraw/tests/memdrawtest.c)>>
<<global dstbits>>
<<global srcbits>>
<<global maskbits>>
<<global savedstbits>>

<<function main (lib_graphics/libmemdraw/tests/memdrawtest.c)>>

<<function Bprintr5g6b5>>

<<function Bprintr5g5b5a1>>

<<function dumpimage>>

<<function checkone>>

<<function RECTPTS>>
<<function checkline>>

<<function fill>>

<<function verifyonemask>>

<<function verifyone>>

<<function verifylinemask>>

<<function verifyline>>

<<function verifyrectmask>>

<<function verifyrect>>

<<function randrect>>

<<function tilexy>>

<<function replicate>>

<<function verifyrectmaskrepl>>

<<function verifyrectrepl>>

/*
 * Trivial draw implementation.
 * Color values are passed around as ulongs containing ααRRGGBB
 */

<<function replbits>>

<<function pixtorgba>>

<<function rgbatopix>>

<<function getpixel>>

<<function getgrey>>

<<function getmask>>
//#undef DBG
//#define DBG if(0)

<<function putpixel>>
//#undef DBG
<<function drawonepixel>>
@


%//void
%//rdb(void)
%//{
%//}
%//
%//int
%//iprint(char *fmt, ...)
%//{
%//	int n;	
%//	va_list va;
%//	char buf[1024];
%//
%//	va_start(va, fmt);
%//	n = vseprint(buf, buf+sizeof buf, fmt, va) - buf;
%//	va_end(va);
%//
%//	write(1,buf,n);
%//	return 1;
%//}

\section{[[lib_graphics/libmemlayer/]]}

\subsection*{[[lib_graphics/libmemlayer/draw.c]]}


%-------------------------------------------------------------

<<lib_graphics/libmemlayer/draw.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<struct Draw>>

<<function ldrawop>>

<<function memdraw>>
@


\subsection*{[[lib_graphics/libmemlayer/lalloc.c]]}


%-------------------------------------------------------------

<<lib_graphics/libmemlayer/lalloc.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<function memlalloc>>
@


\subsection*{[[lib_graphics/libmemlayer/layerop.c]]}

%-------------------------------------------------------------

<<lib_graphics/libmemlayer/layerop.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<function RECUR>>

<<function _layerop>>

<<function _memlayerop>>
@


\subsection*{[[lib_graphics/libmemlayer/ldelete.c]]}

%-------------------------------------------------------------

<<lib_graphics/libmemlayer/ldelete.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<function memldelete>>

<<function memlfree>>

<<function _memlsetclear>>
@


\subsection*{[[lib_graphics/libmemlayer/lhide.c]]}


%-------------------------------------------------------------

<<lib_graphics/libmemlayer/lhide.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<function lhideop>>

<<function memlhide>>

<<function lexposeop>>

<<function memlexpose>>
@


\subsection*{[[lib_graphics/libmemlayer/line.c]]}


%-------------------------------------------------------------

<<lib_graphics/libmemlayer/line.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<struct Lline>>

static void llineop(Memimage*, Rectangle, Rectangle, void*, int);

<<function _memline>>

<<function llineop>>

<<function memline>>
@


\subsection*{[[lib_graphics/libmemlayer/load.c]]}


%-------------------------------------------------------------

<<lib_graphics/libmemlayer/load.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<function memload>>
@


\subsection*{[[lib_graphics/libmemlayer/lorigin.c]]}


%-------------------------------------------------------------

<<lib_graphics/libmemlayer/lorigin.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<function memlorigin>>

<<function memlnorefresh>>
@


\subsection*{[[lib_graphics/libmemlayer/lsetrefresh.c]]}


%-------------------------------------------------------------

<<lib_graphics/libmemlayer/lsetrefresh.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<function memlsetrefresh>>
@


\subsection*{[[lib_graphics/libmemlayer/ltofront.c]]}

%-------------------------------------------------------------

<<lib_graphics/libmemlayer/ltofront.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<function _memltofront>>

<<function _memltofrontfill>>

<<function memltofront>>

<<function memltofrontn>>
@


\subsection*{[[lib_graphics/libmemlayer/ltorear.c]]}

%-------------------------------------------------------------

<<lib_graphics/libmemlayer/ltorear.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<function _memltorear>>

<<function memltorear>>

<<function memltorearn>>
@


\subsection*{[[lib_graphics/libmemlayer/unload.c]]}

%-------------------------------------------------------------

<<lib_graphics/libmemlayer/unload.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<function memunload>>
@


\section{[[windows/apps/]]}


\subsection*{[[windows/apps/clock.c]]}

<<function circlept>>=
static Point
circlept(Point c, int r, int degrees)
{

    double rad;
    rad = (double) degrees * PI/180.0;
    c.x += cos(rad)*r;
    c.y -= sin(rad)*r;
    return c;
}
@

<<function redraw>>=
static void
redraw(Image *screen)
{
    static int tm, ntm;
    static Rectangle r;
    static Point c;
    static int rad;
    static Image *im;
    int i;
    int anghr, angmin;
    static Tm tms;
    static Tm ntms;

    ntm = time(0);
    if(ntm == tm && eqrect(screen->r, r))
        return;

    ntms = *localtime(ntm);
    anghr = 90-(ntms.hour*5 + ntms.min/12)*6;
    angmin = 90-ntms.min*6;
    tm = ntm;
    tms = ntms;
    r = screen->r;
    c = divpt(addpt(r.min, r.max), 2);
    rad = Dx(r) < Dy(r) ? Dx(r) : Dy(r);
    rad /= 2;
    rad -= 8;

    draw(screen, screen->r, back, nil, ZP);
    for(i=0; i<12; i++)
        fillellipse(screen, circlept(c, rad, i*(360/12)), 2, 2, dots, ZP);

    line(screen, c, circlept(c, (rad*3)/4, angmin), 0, 0, 1, minhand, ZP);
    line(screen, c, circlept(c, rad/2, anghr), 0, 0, 1, hrhand, ZP);

    flushimage(display, 1);
}
@

<<function eresized>>=
void
eresized(int new)
{
    if(new && getwindow(display, Refnone) < 0)
        fprint(2,"can't reattach to window");
    redraw(screen);
}
@

<<function main (windows/apps/clock.c)>>=
void
main(int, char**)
{
    Event e;
    Mouse m;
    Menu menu;
    char *mstr[] = {"exit", 0};
    int key, timer;
    int t;

    if (initdraw(0, 0, "clock") < 0)
        sysfatal("initdraw failed");
    back = allocimagemix(display, DPalebluegreen, DWhite);

    hrhand = allocimage(display, Rect(0,0,1,1), CMAP8, 1, DDarkblue);
    minhand = allocimage(display, Rect(0,0,1,1), CMAP8, 1, DPaleblue);
    dots = allocimage(display, Rect(0,0,1,1), CMAP8, 1, DBlue);
    redraw(screen);

    einit(Emouse);
    t = (30*1000);
    timer = etimer(0, t);

    menu.item = mstr;
    menu.lasthit = 0;
        // the event loop
    for(;;) {
        key = event(&e);
        if(key == Emouse) {
            m = e.mouse;
            if(m.buttons & 4) {
                if(emenuhit(3, &m, &menu) == 0)
                    exits(0);
            }
        } else if(key == timer) {
            redraw(screen);
        }
    }	
}
@


%-------------------------------------------------------------

<<windows/apps/clock.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <event.h>

static Image *hrhand, *minhand;
static Image *dots, *back;

<<function circlept>>

<<function redraw>>

<<function eresized>>

<<function main (windows/apps/clock.c)>>
@


\subsection*{[[windows/apps/colors.c]]}

<<global pixel>>=
static Image *pixel;
@

<<global crect>>=
static Rectangle crect[256];
@

<<global color>>=
static Image *color[256];
@

<<function eresized (windows/apps/colors.c)>>=
void
eresized(int new)
{
    int x, y, i, n, nx, ny;
    Rectangle r, b;

    if(new && getwindow(display, Refnone) < 0){
        fprint(2, "colors: can't reattach to window: %r\n");
        exits("resized");
    }
    if(screen->depth > 8){
        n = 256;
        nx = 16;
    }else{
        n = 1<<screen->depth;
        nx = 1<<(screen->depth/2);
    }

    ny = n/nx;
    draw(screen, screen->r, display->white, nil, ZP);
    r = insetrect(screen->r, 5);
    r.min.y+=20;
    b.max.y=r.min.y;
    for(i=n-1, y=0; y!=ny; y++){
        b.min.y=b.max.y;
        b.max.y=r.min.y+(r.max.y-r.min.y)*(y+1)/ny;
        b.max.x=r.min.x;
        for(x=0; x!=nx; x++, --i){
            b.min.x=b.max.x;
            b.max.x=r.min.x+(r.max.x-r.min.x)*(x+1)/nx;
            crect[i]=insetrect(b, 1);
            draw(screen, crect[i], color[i], nil, ZP);
        }
    }
    flushimage(display, 1);
}
@

<<global buttons>>=
static char *buttons[] =
{
    "exit",
    0
};
@

<<global menu>>=
static Menu menu =
{
    buttons
};
@


<<function grey>>=
static ulong
grey(int i)
{
    if(i < 0)
        return grey(0);
    if(i > 255)
        return grey(255);
    return (i<<16)+(i<<8)+i;
}
@


<<global dither>>=
static int
dither[16] =  {
    0, 8, 2, 10,
    12, 4, 14, 6,
    3, 11, 1, 9,
    15, 7, 13, 5
};
@

<<function main (windows/apps/colors.c)>>=
void
main(int argc, char *argv[])
{
    Point p;
    Mouse m;
    bool ramp;
    int i, j, k, l, n, prev;
    char buf[100];
    char *fmt;
    Image *dark;
    ulong rgb;

    ramp = false;

    fmt = "index %3d r %3lud g %3lud b %3lud 0x%.8luX        ";
    ARGBEGIN{
    default:
        goto Usage;
    case 'x':
        fmt = "index %2luX r %3luX g %3luX b %3luX 0x%.8luX       ";
        break;
    case 'r':
        ramp = true;
        break;
    }ARGEND

    if(argc){
    Usage:
        fprint(STDERR, "Usage: %s [-rx]\n", argv0);
        exits("usage");
    }

    if(initdraw(nil, nil, "colors") < 0)
        sysfatal("initdraw failed: %r");
    einit(Emouse);

    for(i=0; i<256; i++){
        if(ramp){
            if(screen->chan == CMAP8){
                /* dither the fine grey */
                j = i-(i%17);
                dark = allocimage(display, Rect(0,0,1,1), screen->chan, 1, (grey(j)<<8)+0xFF);
                color[i] = allocimage(display, Rect(0,0,4,4), screen->chan, 1, (grey(j+17)<<8)+0xFF);
                for(j=0; j<16; j++){
                    k = j%4;
                    l = j/4;
                    if(dither[j] > (i%17))
                        draw(color[i], Rect(k, l, k+1, l+1), dark, nil, ZP);
                }
                freeimage(dark);
            }else
                color[i] = allocimage(display, Rect(0,0,1,1), screen->chan, 1, (grey(i)<<8)+0xFF);
        }else
            color[i] = allocimage(display, Rect(0,0,1,1), screen->chan, 1, 
                                   (cmap2rgb(i)<<8)+0xFF);
        if(color[i] == nil)
            sysfatal("can't allocate image: %r");
    }

    eresized(0);

    prev = -1;
    for(;;){
        m = emouse();
        switch(m.buttons){
        case 1: // left click
            while(m.buttons){
                if(screen->depth > 8)
                    n = 256;
                else
                    n = 1<<screen->depth;
                for(i=0; i!=n; i++)
                    if(i!=prev && ptinrect(m.xy, crect[i])){
                        if(ramp)
                            rgb = grey(i);
                        else
                            rgb = cmap2rgb(i);
                        sprint(buf, fmt,
                            i,
                            (rgb>>16)&0xFF,
                            (rgb>>8)&0xFF,
                            rgb&0xFF,
                            (rgb<<8) | 0xFF);
                        p = addpt(screen->r.min, Pt(2,2));
                        draw(screen, Rpt(p, addpt(p, stringsize(font, buf))), display->white, nil, p);
                        string(screen, p, display->black, ZP, font, buf);
                        prev=i;
                        break;
                    }
                m = emouse();
            }
            break;

        case 4: // right click
            switch(emenuhit(3, &m, &menu)){
            case 0:
                exits(0);
            }
        }
    }
}
@


%-------------------------------------------------------------

<<windows/apps/colors.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <event.h>

static int nbit, npix;
<<global pixel>>
<<global crect>>
<<global color>>

<<function eresized (windows/apps/colors.c)>>

<<global buttons>>

<<function grey>>

<<global menu>>

<<global dither>>

<<function main (windows/apps/colors.c)>>
@


\subsection*{[[windows/apps/screenlock.c]]}

<<global pic>>=
static char pic[] = "/lib/bunny.bit";
@

<<global vgactl>>=
static int vgactl;
@

<<global debug>>=
static int debug;
@

<<global doblank>>=
static int doblank;
@

<<global chatty>>=
static int chatty = 0;
@

<<global user>>=
static char user[256];
@

<<function blankscreen>>=
static void
blankscreen(int blank)
{
    if(vgactl < 0)
        return;
    seek(vgactl, 0, 0);
    if(fprint(vgactl, blank? "blank": "unblank") < 0)
        fprint(2, "blankscreen: can't blank: %r\n");
}
@

<<function error (windows/apps/screenlock.c)>>=
static void
error(char *fmt, ...)
{
    Fmt f;
    char buf[64];
    va_list arg;

    fmtfdinit(&f, 1, buf, sizeof buf);
    fmtprint(&f, "screenlock: ");
    va_start(arg, fmt);
    fmtvprint(&f, fmt, arg);
    va_end(arg);
    fmtprint(&f, "\n");
    fmtfdflush(&f);
    threadexitsall("fatal error");
}
@

<<function usage (windows/apps/screenlock.c)>>=
static void
usage(void)
{
    fprint(2, "usage: %s\n", argv0);
    exits("usage");
}
@

<<function readfile>>=
static void
readfile(char *name, char *buf, int nbuf, int addnul)
{
    int fd;

    fd = open(name, OREAD);
    if(fd == -1)
        error("%s - can't open: %r", name);
    nbuf = read(fd, buf, nbuf-addnul);
    close(fd);
    if(nbuf == -1)
        error("%s - can't can't read: %r", name);
    if(addnul)
        buf[nbuf] = '\0';
}
@

<<function readline>>=
static void
readline(char *buf, int nbuf)
{
    char c;
    int i;

    i = 0;
    while(i < nbuf-1)
        if(read(0, &c, 1) != 1 || c == '\04' || c == '\177'){
            i = 0;
            break;
        } else if(c == '\n')
            break;
        else if(c == '\b' && i > 0)
            --i;
        else if(c == ('u' & 037))
            i = 0;
        else
            buf[i++] = c;
    buf[i] = '\0';
}
@

<<function checkpassword>>=
static void
checkpassword(void)
{
    int fd, consctl, must;
    char buf[256];
    AuthInfo *ai;
    static int opened;

    must = 1;
    if(!opened){
        fd = open("/dev/cons", OREAD);
        if(fd == -1)
            error("can't open cons: %r");
        dup(fd, 0);
        close(fd);
        fd = open("/dev/cons", OWRITE);
        if(fd == -1)
            error("can't open cons: %r");
        dup(fd, 1);
        dup(1, 2);
        close(fd);
        consctl = open("/dev/consctl", OWRITE);
        if(consctl == -1)
            error("can't open consctl: %r");
        if(write(consctl, "rawon", 5) != 5)
            error("can't turn off echo\n");
        opened = 1;
    }

    for(;;){
        if(chatty || !must)
            fprint(2, "%s's screenlock password: ", user);
        memset(buf, 0, sizeof buf);
        readline(buf, sizeof buf);
        blankscreen(0);
        if(chatty || !must)
            fprint(2, "\n");
        if(buf[0] == '\0' || buf[0] == '\04'){
            if(must)
                continue;
            error("no password typed");
        }

        /* authenticate */
        ai = auth_userpasswd(user, buf);
        if(ai != nil && ai->cap != nil)
            break;
        auth_freeAI(ai);

        if(chatty || !must)
            fprint(2, "password mismatch\n");
        doblank = 1;
    }
    memset(buf, 0, sizeof buf);
    blankscreen(0);
}
@

<<function blanker>>=
static void
blanker(void *)
{
    int tics;

    tics = 0;
    for(;;){
        if(doblank > 0){
            doblank = 0;
            tics = 10;
        }
        if(tics > 0 && --tics == 0)
            blankscreen(1);
        sleep(1000);
    }
}
@

<<function grabmouse>>=
static void
grabmouse(void*)
{
    int fd, x, y;
    char ibuf[256], obuf[256];

    if(debug)
        return;
    fd = open("/dev/mouse", ORDWR);
    if(fd < 0)
        error("can't open /dev/mouse: %r");

    snprint(obuf, sizeof obuf, "m %d %d",
        screen->r.min.x + Dx(screen->r)/2,
        screen->r.min.y + Dy(screen->r)/2);
    while(read(fd, ibuf, sizeof ibuf) > 0){
        ibuf[12] = 0;
        ibuf[24] = 0;
        x = atoi(ibuf+1);
        y = atoi(ibuf+13);
        if(x != screen->r.min.x + Dx(screen->r)/2 ||
           y != screen->r.min.y + Dy(screen->r)/2){
            fprint(fd, "%s", obuf);
            doblank = 1;
        }
    }
}
@

<<function screenstring>>=
/* lay down text at `p' */
static void
screenstring(Point p, char *s)
{
    string(screen, p, screen->display->white, ZP, font, s);
    flushimage(display, 1);
}
@

<<function lockscreen>>=
static void
lockscreen(void)
{
    enum { Nfld = 5, Fldlen = 12, Cursorlen = 2*4 + 2*2*16, };
    char *s;
    char buf[Nfld*Fldlen], *flds[Nfld], newcmd[128], cbuf[Cursorlen];
    int fd, dx, dy;
    Image *i;
    Point p;
    Rectangle r;
    Tm *tm;

    fd = open("/dev/screen", OREAD);
    if(fd < 0)
        error("can't open /dev/screen: %r");
    if(read(fd, buf, Nfld*Fldlen) != Nfld*Fldlen)
        error("can't read /dev/screen: %r");
    close(fd);
    buf[sizeof buf-1] = 0;
    if(tokenize(buf, flds, Nfld) != Nfld)
        error("can't tokenize /dev/screen header");
    snprint(newcmd, sizeof newcmd, "-r %s %s %d %d",
        flds[1], flds[2], atoi(flds[3]) - 1, atoi(flds[4]) - 1);
    newwindow(newcmd);
    if (initdraw(nil, nil, "screenlock") < 0)
        sysfatal("initdraw failed");
    if(display == nil)
        error("no display");

    /* screen is now open and covered.  grab mouse and hold on tight */
    procrfork(grabmouse, nil, 4096, RFFDG);
    procrfork(blanker, nil, 4096, RFFDG);
    fd = open(pic, OREAD);
    if(fd > 0){
        i = readimage(display, fd, 0);
        if(i){
    r = screen->r;
            p = Pt(r.max.x / 2, r.max.y * 2 / 3); 
            dx = (Dx(screen->r) - Dx(i->r)) / 2;
            r.min.x += dx;
            r.max.x -= dx;
            dy = (Dy(screen->r) - Dy(i->r)) / 2;
            r.min.y += dy;
            r.max.y -= dy;
            draw(screen, screen->r, display->black, nil, ZP);
            draw(screen, r, i, nil, i->r.min);
            flushimage(display, 1);
        }
        close(fd);

        /* identify the user on screen, centered */
        tm = localtime(time(0));
        s = smprint("user %s at %d:%02.2d", getuser(), tm->hour, tm->min);
        p = subpt(p, Pt(stringwidth(font, "m") * strlen(s) / 2, 0));
        screenstring(p, s);
    }

    /* clear the cursor */
    fd = open("/dev/cursor", OWRITE);
    if(fd > 0){
        memset(cbuf, 0, sizeof cbuf);
        write(fd, cbuf, sizeof cbuf);
        /* leave it open */
    }
}
@

<<function threadmain (windows/apps/screenlock.c)>>=
void
threadmain(int argc, char *argv[])
{
    readfile("#c/user", user, sizeof user, 1);

    if((vgactl = open("/dev/vgactl", OWRITE)) < 0)
        vgactl = open("#v/vgactl", OWRITE);

    ARGBEGIN{
    case 'd':
        debug++;
        break;
    default:
        usage();
    }ARGEND

    if(argc != 0)
        usage();

    doblank = 1;
    lockscreen();
    checkpassword();
    threadexitsall(nil);
}
@


%-------------------------------------------------------------

<<windows/apps/screenlock.c>>=
/* screenlock - lock a terminal */
#include <u.h>
#include <libc.h>
#include <libsec.h>
#include <draw.h>
#include <thread.h>
#include <auth.h>

<<global pic>>

<<global vgactl>>
<<global debug>>
<<global doblank>>
<<global chatty>>

<<global user>>

<<function blankscreen>>

<<function error (windows/apps/screenlock.c)>>

<<function usage (windows/apps/screenlock.c)>>


<<function readfile>>

<<function readline>>

<<function checkpassword>>

<<function blanker>>

<<function grabmouse>>

<<function screenstring>>

<<function lockscreen>>

<<function threadmain (windows/apps/screenlock.c)>>
@



\section{[[kernel/devices/screen/]]}

\subsection*{[[kernel/devices/screen/screen.c]]}

<<kernel/devices/screen/screen.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "../port/error.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"

#include    <draw.h>
#include    <memdraw.h>
#include    <memlayer.h>
#include    <cursor.h>

#include    "screen.h"

// many of the stuff below used to be in vgascreen.c, but they are
// quite VGA independent so better to have a generic screen.c

<<global gscreen>>
<<global gscreendata>>
<<global physgscreenr>>

//put cursor here?
// software cursor?
// curpos, window, graphic text mode? graphic_screenputs
@

\subsection*{[[kernel/devices/screen/screen.h]]}


%-----------------------------------------------------------------

<<kernel/devices/screen/screen.h>>=
// this used to contain the stuff now in vga.h but those prototypes are
// VGA independent, so better to have a generic screen.h interface.

// forward decls
typedef struct Cursorinfo Cursorinfo;

// screen.c
extern Memimage *gscreen;
extern Memdata gscreendata;
extern Rectangle physgscreenr;  /* actual monitor size */

/* defined in xxxscreen.c, needed by devdraw.c */
extern void 	flushmemscreen(Rectangle);
extern uchar* 	attachscreen(Rectangle*, ulong*, int*, int*, int*);
extern void 	blankscreen(bool);
extern void		getcolor(ulong, ulong*, ulong*, ulong*);
extern int		setcolor(ulong, ulong, ulong, ulong);
// this used to be a macro, but then it was forbidding this file to be generic
extern bool ishwimage(Memimage*);



<<struct Cursorinfo>>

/* defined in devmouse.c, needed by ?? */ // just enough Mouse getters/setters
extern Point 	mousexy(void);
extern void 	mouseaccelerate(int);
extern void 	mousetrack(int, int, int, int);
extern Cursorinfo 	cursor;
/* xxxmouse.c */
extern void kmousectl(Cmdbuf*);
/* defined in xxxscreen.c, needed by devmouse.c */
extern Cursor 		arrow;
extern void 	ksetcursor(Cursor*);
extern int  	cursoron(int);
extern void 	cursoroff(int);

//now in portfns_devices.h: extern void mouseresize(void);

@

\subsection*{[[kernel/devices/screen/devdraw.c]]}

<<enum _anon_ (kernel/devices/screen/devdraw.c)>>=
enum
{
    Qtopdir     = 0,

    Qnew,

    Qwinname,
    Q3rd,
    Q2nd,
    Qcolormap,

    Qctl,
    Qdata, // all the operations, drawmesg()
    Qrefresh,
};
@

<<constant QSHIFT>>=
/*
 * Qid path is:
 *   4 bits of file type (qids above)
 *  24 bits of mux slot number +1; 0 means not attached to client
 */
#define QSHIFT  4   /* location in qid of client # */
@

<<function QID bis>>=
#define QID(q)      ((((ulong)(q).path)&0x0000000F)>>0)
@

<<function CLIENTPATH>>=
#define CLIENTPATH(q)   ((((ulong)q)&0x7FFFFFF0)>>QSHIFT)
@
%//#define CLIENT(q)   CLIENTPATH((q).path)

<<constant NHASH bis>>=
#define NHASH       (1<<5)
@

<<constant HASHMASK>>=
#define HASHMASK    (NHASH-1)
@

<<constant IOUNIT>>=
#define IOUNIT      (64*1024)
@


<<struct KDraw>>=
struct KDraw
{
    int     clientid;
    int     nclient;
    Client**    client;
    int     nname;
    DName*  name;
    int     vers;
    int     softscreen;
    ulong   savemap[3*256];

    <<[[KDraw]] other fields>>
};
@



<<struct Refresh>>=
struct Refresh
{
    DImage*     dimage;
    Rectangle   r;
    Refresh*    next;
};
@

<<struct Refx>>=
struct Refx
{
    Client*     client;
    DImage*     dimage;
};
@

<<struct DName>>=
struct DName
{
    char        *name;
    Client      *client;
    DImage*     dimage;
    int     vers;
};
@

<<struct FChar>>=
struct FChar
{
    int     minx;   /* left edge of bits */
    int     maxx;   /* right edge of bits */
    uchar       miny;   /* first non-zero scan-line */
    uchar       maxy;   /* last non-zero scan-line + 1 */
    schar       left;   /* offset of baseline */
    uchar       width;  /* width of baseline */
};
@

<<struct DImage>>=
/*
 * Reference counts in DImages:
 *  one per open by original client
 *  one per screen image or fill
 *  one per image derived from this one by name
 */
struct DImage
{
    int     id;
    int     ref;
    char        *name;
    int     vers;
    Memimage*   image;
    int     ascent;
    int     nfchar;
    FChar*      fchar;
    DScreen*    dscreen;    /* 0 if not a window */
    DImage*     fromname;   /* image this one is derived from, by name */
    DImage*     next;
};
@

<<struct CScreen>>=
struct CScreen
{
    DScreen*    dscreen;
    CScreen*    next;
};
@

<<struct DScreen>>=
struct DScreen
{
    int     id;
    int     public;
    int     ref;
    DImage      *dimage;
    DImage      *dfill;
    Memscreen*  screen;
    Client*     owner;
    DScreen*    next;
};
@







<<global sdraw>>=
static  KDraw        sdraw;
@





<<global screenname>>=
static  char    screenname[40];
@

<<global screennameid>>=
static  int screennameid;
@


<<global waste>>=
static  int     waste;
@

<<global dscreen>>=
static  DScreen*    dscreen;
@






<<global Enodrawimage>>=
static  char Enodrawimage[] =   "unknown id for draw image";
@

<<global Enodrawscreen>>=
static  char Enodrawscreen[] =  "unknown id for draw screen";
@

<<global Eshortdraw>>=
static  char Eshortdraw[] = "short draw message";
@

<<global Eshortread>>=
static  char Eshortread[] = "draw read too short";
@

<<global Eimageexists>>=
static  char Eimageexists[] =   "image id in use";
@

<<global Escreenexists>>=
static  char Escreenexists[] =  "screen id in use";
@

<<global Edrawmem>>=
static  char Edrawmem[] =   "image memory allocation failed";
@

<<global Ereadoutside>>=
static  char Ereadoutside[] =   "readimage outside image";
@

<<global Ewriteoutside>>=
static  char Ewriteoutside[] =  "writeimage outside image";
@

<<global Enotfont>>=
static  char Enotfont[] =   "image not a font";
@

<<global Eindex>>=
static  char Eindex[] =     "character index out of range";
@

<<global Enoclient>>=
static  char Enoclient[] =  "no such draw client";
@

<<global Enameused>>=
//static    char Edepth[] =     "image has bad depth";
static  char Enameused[] =  "image name in use";
@

<<global Enoname>>=
static  char Enoname[] =    "no image with that name";
@

<<global Eoldname>>=
static  char Eoldname[] =   "named image no longer valid";
@

<<global Enamed>>=
static  char Enamed[] =     "image already has name";
@

<<global Ewrongname>>=
static  char Ewrongname[] =     "wrong name for image";
@



<<global drawlock>>=
QLock   drawlock;
@

<<function dlock>>=
static void
dlock(void)
{
    qlock(&drawlock);
}
@

<<function candlock>>=
static int
candlock(void)
{
    return canqlock(&drawlock);
}
@

<<function dunlock>>=
static void
dunlock(void)
{
    qunlock(&drawlock);
}
@



<<function drawgen>>=
static int
drawgen(Chan *c, char*, Dirtab*, int, int s, Dir *dp)
{
    int t;
    Qid q;
    ulong path;
    Client *cl;

    q.vers = 0;

    if(s == DEVDOTDOT){
        switch(QID(c->qid)){
        case Qtopdir:
        case Q2nd:
            mkqid(&q, Qtopdir, 0, QTDIR);
            devdir(c, q, "#i", 0, eve, 0500, dp);
            break;
        case Q3rd:
            cl = drawclientofpath(c->qid.path);
            if(cl == nil)
                strncpy(up->genbuf, "??", sizeof up->genbuf);
            else
                snprint(up->genbuf, sizeof up->genbuf,
                    "%d", cl->clientid);
            mkqid(&q, Q2nd, 0, QTDIR);
            devdir(c, q, up->genbuf, 0, eve, 0500, dp);
            break;
        default:
            panic("drawwalk %llux", c->qid.path);
        }
        return 1;
    }

    /*
     * Top level directory contains the name of the device.
     */
    t = QID(c->qid);
    if(t == Qtopdir){
        switch(s){
        case 0:
            mkqid(&q, Q2nd, 0, QTDIR);
            devdir(c, q, "draw", 0, eve, 0555, dp);
            break;
        case 1:
            mkqid(&q, Qwinname, 0, QTFILE);
            devdir(c, q, "winname", 0, eve, 0444, dp);
            break;
        default:
            return -1;
        }
        return 1;
    }

    if(t == Qwinname){
        mkqid(&q, Qwinname, 0, QTFILE);
        devdir(c, q, "winname", 0, eve, 0444, dp);
        return 1;
    }

    /*
     * Second level contains "new" plus all the clients.
     */
    if(t == Q2nd || t == Qnew){
        if(s == 0){
            mkqid(&q, Qnew, 0, QTFILE);
            devdir(c, q, "new", 0, eve, 0666, dp);
        }
        else if(s <= sdraw.nclient){
            cl = sdraw.client[s-1];
            if(cl == 0)
                return 0;
            snprint(up->genbuf, sizeof up->genbuf, "%d",
                cl->clientid);
            mkqid(&q, (s<<QSHIFT)|Q3rd, 0, QTDIR);
            devdir(c, q, up->genbuf, 0, eve, 0555, dp);
            return 1;
        }
        else
            return -1;
        return 1;
    }

    /*
     * Third level.
     */
    path = c->qid.path&~((1<<QSHIFT)-1);    /* slot component */
    q.vers = c->qid.vers;
    q.type = QTFILE;
    switch(s){
    case 0:
        q.path = path|Qcolormap;
        devdir(c, q, "colormap", 0, eve, 0600, dp);
        break;
    case 1:
        q.path = path|Qctl;
        devdir(c, q, "ctl", 0, eve, 0600, dp);
        break;
    case 2:
        q.path = path|Qdata;
        devdir(c, q, "data", 0, eve, 0600, dp);
        break;
    case 3:
        q.path = path|Qrefresh;
        devdir(c, q, "refresh", 0, eve, 0400, dp);
        break;
    default:
        return -1;
    }
    return 1;
}
@

<<function drawrefactive>>=
static
int
drawrefactive(void *a)
{
    Client *c;

    c = a;
    return c->refreshme || c->refresh!=0;
}
@

<<function drawrefreshscreen>>=
static
void
drawrefreshscreen(DImage *l, Client *client)
{
    while(l != nil && l->dscreen == nil)
        l = l->fromname;
    if(l != nil && l->dscreen->owner != client)
        l->dscreen->owner->refreshme = 1;
}
@

<<function drawrefresh>>=
static
void
drawrefresh(Memimage*, Rectangle r, void *v)
{
    Refx *x;
    DImage *d;
    Client *c;
    Refresh *ref;

    if(v == 0)
        return;
    x = v;
    c = x->client;
    d = x->dimage;
    for(ref=c->refresh; ref; ref=ref->next)
        if(ref->dimage == d){
            combinerect(&ref->r, r);
            return;
        }
    ref = malloc(sizeof(Refresh));
    if(ref){
        ref->dimage = d;
        ref->r = r;
        ref->next = c->refresh;
        c->refresh = ref;
    }
}
@

<<function addflush>>=
static void
addflush(Rectangle r)
{
    int abb, ar, anbb;
    Rectangle nbb;

    if(sdraw.softscreen==0 || !rectclip(&r, screenimage->r))
        return;

    if(flushrect.min.x >= flushrect.max.x){
        flushrect = r;
        waste = 0;
        return;
    }
    nbb = flushrect;
    combinerect(&nbb, r);
    ar = Dx(r)*Dy(r);
    abb = Dx(flushrect)*Dy(flushrect);
    anbb = Dx(nbb)*Dy(nbb);
    /*
     * Area of new waste is area of new bb minus area of old bb,
     * less the area of the new segment, which we assume is not waste.
     * This could be negative, but that's OK.
     */
    waste += anbb-abb - ar;
    if(waste < 0)
        waste = 0;
    /*
     * absorb if:
     *  total area is small
     *  waste is less than half total area
     *  rectangles touch
     */
    if(anbb<=1024 || waste*2<anbb || rectXrect(flushrect, r)){
        flushrect = nbb;
        return;
    }
    /* emit current state */
    if(flushrect.min.x < flushrect.max.x)
        flushmemscreen(flushrect);
    flushrect = r;
    waste = 0;
}
@

<<function dstflush>>=
static
void
dstflush(int dstid, Memimage *dst, Rectangle r)
{
    Memlayer *l;

    if(dstid == 0){
        combinerect(&flushrect, r);
        return;
    }
    /* how can this happen? -rsc, dec 12 2002 */
    if(dst == 0){
        print("nil dstflush\n");
        return;
    }
    l = dst->layer;
    if(l == nil)
        return;
    do{
        if(l->screen->image->data != screenimage->data)
            return;
        r = rectaddpt(r, l->delta);
        l = l->screen->image->layer;
    }while(l);
    addflush(r);
}
@


<<function drawcmp>>=
static
int
drawcmp(char *a, char *b, int n)
{
    if(strlen(a) != n)
        return 1;
    return memcmp(a, b, n);
}
@


<<function drawgoodname>>=
int
drawgoodname(DImage *d)
{
    DName *n;

    /* if window, validate the screen's own images */
    if(d->dscreen)
        if(drawgoodname(d->dscreen->dimage) == 0
        || drawgoodname(d->dscreen->dfill) == 0)
            return 0;
    if(d->name == nil)
        return 1;
    n = drawlookupname(strlen(d->name), d->name);
    if(n==nil || n->vers!=d->vers)
        return 0;
    return 1;
}
@

<<function drawlookup>>=
DImage*
drawlookup(Client *client, int id, int checkname)
{
    DImage *d;

    d = client->dimage[id&HASHMASK];
    while(d){
        if(d->id == id){
            if(checkname && !drawgoodname(d))
                error(Eoldname);
            return d;
        }
        d = d->next;
    }
    return 0;
}
@

<<function drawlookupdscreen>>=
DScreen*
drawlookupdscreen(int id)
{
    DScreen *s;

    s = dscreen;
    while(s){
        if(s->id == id)
            return s;
        s = s->next;
    }
    return 0;
}
@

<<function drawlookupscreen>>=
DScreen*
drawlookupscreen(Client *client, int id, CScreen **cs)
{
    CScreen *s;

    s = client->cscreen;
    while(s){
        if(s->dscreen->id == id){
            *cs = s;
            return s->dscreen;
        }
        s = s->next;
    }
    error(Enodrawscreen);
    return 0;
}
@





<<function drawfreedscreen>>=
void
drawfreedscreen(DScreen *this)
{
    DScreen *ds, *next;

    this->ref--;
    if(this->ref < 0)
        print("negative ref in drawfreedscreen\n");
    if(this->ref > 0)
        return;
    ds = dscreen;
    if(ds == this){
        dscreen = this->next;
        goto Found;
    }
    while(next = ds->next){ /* assign = */
        if(next == this){
            ds->next = this->next;
            goto Found;
        }
        ds = next;
    }
    error(Enodrawimage);

    Found:
    if(this->dimage)
        drawfreedimage(this->dimage);
    if(this->dfill)
        drawfreedimage(this->dfill);
    free(this->screen);
    free(this);
}
@





<<function drawnewclient>>=
Client*
drawnewclient(void)
{
    Client *cl, **cp;
    int i;

    for(i=0; i<sdraw.nclient; i++){
        cl = sdraw.client[i];
        if(cl == 0)
            break;
    }
    if(i == sdraw.nclient){
        cp = malloc((sdraw.nclient+1)*sizeof(Client*));
        if(cp == 0)
            return 0;
        memmove(cp, sdraw.client, sdraw.nclient*sizeof(Client*));
        free(sdraw.client);
        sdraw.client = cp;
        sdraw.nclient++;
        cp[i] = 0;
    }
    cl = malloc(sizeof(Client));
    if(cl == 0)
        return 0;
    memset(cl, 0, sizeof(Client));
    cl->slot = i;
    cl->clientid = ++sdraw.clientid;
    cl->op = SoverD;
    sdraw.client[i] = cl;
    return cl;
}
@


<<function drawclientofpath>>=
Client*
drawclientofpath(ulong path)
{
    Client *cl;
    int slot;

    slot = CLIENTPATH(path);
    if(slot == 0)
        return nil;
    cl = sdraw.client[slot-1];
    if(cl==0 || cl->clientid==0)
        return nil;
    return cl;
}
@

<<function drawclient>>=
Client*
drawclient(Chan *c)
{
    Client *client;

    client = drawclientofpath(c->qid.path);
    if(client == nil)
        error(Enoclient);
    return client;
}
@






<<function drawimage>>=
Memimage*
drawimage(Client *client, uchar *a)
{
    DImage *d;

    d = drawlookup(client, BGLONG(a), 1);
    if(d == nil)
        error(Enodrawimage);
    return d->image;
}
@

<<function drawrectangle>>=
void
drawrectangle(Rectangle *r, uchar *a)
{
    r->min.x = BGLONG(a+0*4);
    r->min.y = BGLONG(a+1*4);
    r->max.x = BGLONG(a+2*4);
    r->max.y = BGLONG(a+3*4);
}
@

<<function drawpoint>>=
void
drawpoint(Point *p, uchar *a)
{
    p->x = BGLONG(a+0*4);
    p->y = BGLONG(a+1*4);
}
@

% ?? for console mode?
<<function drawchar>>=
Point
drawchar(Memimage *dst, Memimage *rdst, Point p, Memimage *src, Point *sp, DImage *font, int index, int op)
{
    FChar *fc;
    Rectangle r;
    Point sp1;
    static Memimage *tmp;

    fc = &font->fchar[index];
    r.min.x = p.x+fc->left;
    r.min.y = p.y-(font->ascent-fc->miny);
    r.max.x = r.min.x+(fc->maxx-fc->minx);
    r.max.y = r.min.y+(fc->maxy-fc->miny);
    sp1.x = sp->x+fc->left;
    sp1.y = sp->y+fc->miny;

    /*
     * If we're drawing greyscale fonts onto a VGA screen,
     * it's very costly to read the screen memory to do the
     * alpha blending inside memdraw.  If this is really a stringbg,
     * then rdst is the bg image (in main memory) which we can
     * refer to for the underlying dst pixels instead of reading dst
     * directly.
     */
    if(ishwimage(dst) && !ishwimage(rdst) && font->image->depth > 1){
        if(tmp == nil || tmp->chan != dst->chan || Dx(tmp->r) < Dx(r) || Dy(tmp->r) < Dy(r)){
            if(tmp)
                freememimage(tmp);
            tmp = allocmemimage(Rect(0,0,Dx(r),Dy(r)), dst->chan);
            if(tmp == nil)
                goto fallback;
        }
        memdraw(tmp, Rect(0,0,Dx(r),Dy(r)), rdst, r.min, memopaque, ZP, S);
        memdraw(tmp, Rect(0,0,Dx(r),Dy(r)), src, sp1, font->image, Pt(fc->minx, fc->miny), op);
        memdraw(dst, r, tmp, ZP, memopaque, ZP, S);
    }else{
    fallback:
        memdraw(dst, r, src, sp1, font->image, Pt(fc->minx, fc->miny), op);
    }

    p.x += fc->width;
    sp->x += fc->width;
    return p;
}
@



<<function deletescreenimage>>=
void
deletescreenimage(void)
{
    dlock();
    if(screenimage){
        /* will be freed via screendimage; disable */
        screenimage->clipr = ZR;
        screenimage = nil;
    }
    if(screendimage){
        drawfreedimage(screendimage);
        screendimage = nil;
    }
    dunlock();
}
@

<<function resetscreenimage>>=
void
resetscreenimage(void)
{
    dlock();
    initscreenimage();
    dunlock();
}
@
















<<function drawwalk>>=
static Walkqid*
drawwalk(Chan *c, Chan *nc, char **name, int nname)
{
    if(screenimage == nil)
        error("no frame buffer");
    return devwalk(c, nc, name, nname, 0, 0, drawgen);
}
@

<<function drawstat>>=
static int
drawstat(Chan *c, uchar *db, int n)
{
    return devstat(c, db, n, 0, 0, drawgen);
}
@

<<function drawopen>>=
static Chan*
drawopen(Chan *c, int omode)
{
    Client *cl;
    DName *dn;
    DImage *di;

    if(c->qid.type & QTDIR){
        c = devopen(c, omode, 0, 0, drawgen);
        c->iounit = IOUNIT;
    }

    dlock();
    if(waserror()){
        dunlock();
        nexterror();
    }

    if(QID(c->qid) == Qnew){
        cl = drawnewclient();
        if(cl == 0)
            error(Enodev);
        c->qid.path = Qctl|((cl->slot+1)<<QSHIFT); // >>
    }

    switch(QID(c->qid)){
    case Qwinname:
        break;

    case Qnew:
        break;

    case Qctl:
        cl = drawclient(c);
        if(cl->busy)
            error(Einuse);
        cl->busy = 1;
        flushrect = Rect(10000, 10000, -10000, -10000);
        dn = drawlookupname(strlen(screenname), screenname);
        if(dn == 0)
            error("draw: cannot happen 2");
        if(drawinstall(cl, 0, dn->dimage->image, 0) == 0)
            error(Edrawmem);
        di = drawlookup(cl, 0, 0);
        if(di == 0)
            error("draw: cannot happen 1");
        di->vers = dn->vers;
        di->name = smalloc(strlen(screenname)+1);
        strcpy(di->name, screenname);
        di->fromname = dn->dimage;
        di->fromname->ref++;
        incref(&cl->r);
        break;

    case Qcolormap:
    case Qdata:
    case Qrefresh:
        cl = drawclient(c);
        incref(&cl->r);
        break;
    }

    dunlock();
    poperror();
    c->mode = openmode(omode);
    c->flag |= COPEN;
    c->offset = 0;
    c->iounit = IOUNIT;
    return c;
}
@
% >> 

<<function drawclose>>=
static void
drawclose(Chan *c)
{
    int i;
    DImage *d, **dp;
    Client *cl;
    Refresh *r;

    if(QID(c->qid) < Qcolormap) /* Qtopdir, Qnew, Q3rd, Q2nd have no client */
        return;
    dlock();
    if(waserror()){
        dunlock();
        nexterror();
    }

    cl = drawclient(c);
    if(QID(c->qid) == Qctl)
        cl->busy = 0;
    if((c->flag&COPEN) && (decref(&cl->r)==0)){
        while(r = cl->refresh){ /* assign = */
            cl->refresh = r->next;
            free(r);
        }
        /* free names */
        for(i=0; i<sdraw.nname; )
            if(sdraw.name[i].client == cl)
                drawdelname(sdraw.name+i);
            else
                i++;
        while(cl->cscreen)
            drawuninstallscreen(cl, cl->cscreen);
        /* all screens are freed, so now we can free images */
        dp = cl->dimage;
        for(i=0; i<NHASH; i++){
            while((d = *dp) != nil){
                *dp = d->next;
                drawfreedimage(d);
            }
            dp++;
        }
        sdraw.client[cl->slot] = 0;
        drawflush();    /* to erase visible, now dead windows */
        free(cl);
    }
    dunlock();
    poperror();
}
@

<<function drawread>>=
long
drawread(Chan *c, void *a, long n, vlong off)
{
    int index, m;
    ulong red, green, blue;
    Client *cl;
    uchar *p;
    Refresh *r;
    DImage *di;
    Memimage *i;
    ulong offset = off;
    char buf[16];

    if(c->qid.type & QTDIR)
        return devdirread(c, a, n, 0, 0, drawgen);
    if(QID(c->qid) == Qwinname)
        return readstr(off, a, n, screenname);

    cl = drawclient(c);
    dlock();
    if(waserror()){
        dunlock();
        nexterror();
    }
    switch(QID(c->qid)){
    case Qctl:
        if(n < 12*12)
            error(Eshortread);
        if(cl->infoid < 0)
            error(Enodrawimage);
        if(cl->infoid == 0){
            i = screenimage;
            if(i == nil)
                error(Enodrawimage);
        }else{
            di = drawlookup(cl, cl->infoid, 1);
            if(di == nil)
                error(Enodrawimage);
            i = di->image;
        }
        n = snprint(a, n,
            "%11d %11d %11s %11d %11d %11d %11d %11d %11d %11d %11d %11d ",
            cl->clientid, cl->infoid, chantostr(buf, i->chan),
            (i->flags&Frepl)==Frepl,
            i->r.min.x, i->r.min.y, i->r.max.x, i->r.max.y,
            i->clipr.min.x, i->clipr.min.y, i->clipr.max.x,
            i->clipr.max.y);
        cl->infoid = -1;
        break;

    case Qcolormap:
        drawactive(true);  /* to restore map from backup */
        p = malloc(4*12*256+1);
        if(p == 0)
            error(Enomem);
        m = 0;
        for(index = 0; index < 256; index++){
            getcolor(index, &red, &green, &blue);
            m += snprint((char*)p+m, 4*12*256+1 - m,
                "%11d %11lud %11lud %11lud\n", index,
                red>>24, green>>24, blue>>24);
        }
        n = readstr(offset, a, n, (char*)p);
        free(p);
        break;

    case Qdata:
        if(cl->readdata == nil)
            error("no draw data");
        if(n < cl->nreaddata)
            error(Eshortread);
        n = cl->nreaddata;
        memmove(a, cl->readdata, cl->nreaddata);
        free(cl->readdata);
        cl->readdata = nil;
        break;

    case Qrefresh:
        if(n < 5*4)
            error(Ebadarg);
        for(;;){
            if(cl->refreshme || cl->refresh)
                break;
            dunlock();
            if(waserror()){
                dlock();    /* restore lock for waserror() above */
                nexterror();
            }
            sleep(&cl->refrend, drawrefactive, cl);
            poperror();
            dlock();
        }
        p = a;
        while(cl->refresh && n>=5*4){
            r = cl->refresh;
            BPLONG(p+0*4, r->dimage->id);
            BPLONG(p+1*4, r->r.min.x);
            BPLONG(p+2*4, r->r.min.y);
            BPLONG(p+3*4, r->r.max.x);
            BPLONG(p+4*4, r->r.max.y);
            cl->refresh = r->next;
            free(r);
            p += 5*4;
            n -= 5*4;
        }
        cl->refreshme = 0;
        n = p-(uchar*)a;
        break;
    }
    dunlock();
    poperror();
    return n;
}
@

<<function drawwakeall>>=
void
drawwakeall(void)
{
    Client *cl;
    int i;

    for(i=0; i<sdraw.nclient; i++){
        cl = sdraw.client[i];
        if(cl && (cl->refreshme || cl->refresh))
            wakeup(&cl->refrend);
    }
}
@

<<function drawwrite>>=
static long
drawwrite(Chan *c, void *a, long n, vlong)
{
    char buf[128], *fields[4], *q;
    Client *cl;
    int i, m, red, green, blue, x;

    if(c->qid.type & QTDIR)
        error(Eisdir);
    cl = drawclient(c);
    dlock();
    if(waserror()){
        drawwakeall();
        dunlock();
        nexterror();
    }
    switch(QID(c->qid)){
    case Qctl:
        if(n != 4)
            error("unknown draw control request");
        cl->infoid = BGLONG((uchar*)a);
        break;

    case Qcolormap:
        drawactive(true);  /* to restore map from backup */
        m = n;
        n = 0;
        while(m > 0){
            x = m;
            if(x > sizeof(buf)-1)
                x = sizeof(buf)-1;
            q = memccpy(buf, a, '\n', x);
            if(q == 0)
                break;
            i = q-buf;
            n += i;
            a = (char*)a + i;
            m -= i;
            *q = 0;
            if(tokenize(buf, fields, nelem(fields)) != 4)
                error(Ebadarg);
            i = strtoul(fields[0], 0, 0);
            red = strtoul(fields[1], 0, 0);
            green = strtoul(fields[2], 0, 0);
            blue = strtoul(fields[3], &q, 0);
            if(fields[3] == q)
                error(Ebadarg);
            if(red>255 || green>255 || blue>255 || i<0 || i>255)
                error(Ebadarg);
            red |= red<<8;
            red |= red<<16;
            green |= green<<8;
            green |= green<<16;
            blue |= blue<<8;
            blue |= blue<<16;
            setcolor(i, red, green, blue);
        }
        break;

    case Qdata:
        drawmesg(cl, a, n);
        drawwakeall();
        break;

    default:
        error(Ebadusefd);
    }
    dunlock();
    poperror();
    return n;
}
@

<<function drawcoord>>=
uchar*
drawcoord(uchar *p, uchar *maxp, int oldx, int *newx)
{
    int b, x;

    if(p >= maxp)
        error(Eshortdraw);
    b = *p++;
    x = b & 0x7F;
    if(b & 0x80){
        if(p+1 >= maxp)
            error(Eshortdraw);
        x |= *p++ << 7;
        x |= *p++ << 15;
        if(x & (1<<22))
            x |= ~0<<23;
    }else{
        if(b & 0x40)
            x |= ~0<<7;
        x += oldx;
    }
    *newx = x;
    return p;
}
@




<<function drawcmap>>=
/*
 * On 8 bit displays, load the default color map
 */
void
drawcmap(void)
{
    int r, g, b, cr, cg, cb, v;
    int num, den;
    int i, j;

    drawactive(true);  /* to restore map from backup */
    for(r=0,i=0; r!=4; r++)
        for(v=0; v!=4; v++,i+=16){
        for(g=0,j=v-r; g!=4; g++)
            for(b=0;b!=4;b++,j++){
            den = r;
            if(g > den)
                den = g;
            if(b > den)
                den = b;
            if(den == 0)    /* divide check -- pick grey shades */
                cr = cg = cb = v*17;
            else{
                num = 17*(4*den+v);
                cr = r*num/den;
                cg = g*num/den;
                cb = b*num/den;
            }
            setcolor(i+(j&15),
                cr*0x01010101, cg*0x01010101, cb*0x01010101);
            }
    }
}
@





%-------------------------------------------------------------

<<kernel/devices/screen/devdraw.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "../port/error.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"

#include    <draw.h>
#include    <memdraw.h>
#include    <memlayer.h>
#include    <cursor.h>

#include    "screen.h"

<<enum _anon_ (kernel/devices/screen/devdraw.c)>>

<<constant QSHIFT>>

<<function QID bis>>
<<function CLIENTPATH>>
<<constant NHASH bis>>
<<constant HASHMASK>>
<<constant IOUNIT>>

typedef struct Client Client;
typedef struct KDraw KDraw;
typedef struct DImage DImage;
typedef struct DScreen DScreen;
typedef struct CScreen CScreen;
typedef struct FChar FChar;
typedef struct Refresh Refresh;
typedef struct Refx Refx;
typedef struct DName DName;

<<global blanktime>>

<<struct KDraw>>

<<struct Client>>

<<struct Refresh>>

<<struct Refx>>

<<struct DName>>

<<struct FChar>>

<<struct DImage>>

<<struct CScreen>>

<<struct DScreen>>

<<global sdraw>>
<<global drawlock>>

<<global screenimage>>
<<global screendimage>>
<<global screenname>>
<<global screennameid>>

<<global flushrect>>
<<global waste>>
<<global dscreen>>

// forward decls
void        drawmesg(Client*, void*, int);
void        drawuninstall(Client*, int);
void        drawfreedimage(DImage*);
Client*     drawclientofpath(ulong);
DImage* 	allocdimage(Memimage*);

<<global Enodrawimage>>
<<global Enodrawscreen>>
<<global Eshortdraw>>
<<global Eshortread>>
<<global Eimageexists>>
<<global Escreenexists>>
<<global Edrawmem>>
<<global Ereadoutside>>
<<global Ewriteoutside>>
<<global Enotfont>>
<<global Eindex>>
<<global Enoclient>>
<<global Enameused>>
<<global Enoname>>
<<global Eoldname>>
<<global Enamed>>
<<global Ewrongname>>

<<function dlock>>

<<function candlock>>

<<function dunlock>>

<<function drawgen>>

<<function drawrefactive>>

<<function drawrefreshscreen>>

<<function drawrefresh>>

<<function addflush>>

<<function dstflush>>

<<function drawflush>>

<<function drawcmp>>

<<function drawlookupname>>

<<function drawgoodname>>

<<function drawlookup>>

<<function drawlookupdscreen>>

<<function drawlookupscreen>>

<<function allocdimage>>

<<function drawinstall>>

<<function drawinstallscreen>>

<<function drawdelname>>

<<function drawfreedscreen>>

<<function drawfreedimage>>

<<function drawuninstallscreen>>

<<function drawuninstall>>

<<function drawaddname>>

<<function drawnewclient>>

<<function drawclientop>>

<<function drawclientofpath>>

<<function drawclient>>

<<function drawimage>>

<<function drawrectangle>>

<<function drawpoint>>

<<function drawchar>>

<<function makescreenimage>>

<<function initscreenimage>>

<<function deletescreenimage>>

<<function resetscreenimage>>

<<function drawattach>>

<<function drawwalk>>

<<function drawstat>>

<<function drawopen>>

<<function drawclose>>

<<function drawread>>

<<function drawwakeall>>

<<function drawwrite>>

<<function drawcoord>>

<<function printmesg>>

<<function drawmesg>>

<<global drawdevtab>>

<<function drawcmap>>

<<function drawblankscreen>>

<<function drawactive>>

<<function drawidletime>>
@

%//int
%//drawhasclients(void)
%//{
%//  /*
%//   * if draw has ever been used, we can't resize the frame buffer,
%//   * even if all clients have exited (nclients is cumulative); it's too
%//   * hard to make work.
%//   */
%//  return sdraw.nclient != 0;

\section{[[kernel/devices/screen/386/]]}

\subsection*{[[kernel/devices/screen/386/vga.h]]}


%-------------------------------------------------------------

<<kernel/devices/screen/386/vga.h>>=

<<enum vgaports>>

<<enum vgamisc>>

<<function VGAMEM>>

<<function vgao>>
//#define vgai(port)    inb(port)
extern int vgaxi(long, uchar);
extern int vgaxo(long, uchar, uchar);

// forward decl
typedef struct VGAdev VGAdev;
typedef struct VGAcur VGAcur;
typedef struct VGAscr VGAscr;

<<struct VGAdev>>

<<struct VGAcur>>

<<struct VGAscr>>

//!!!
extern VGAscr vgascreen;

<<enum _anon_ (kernel/devices/screen/386/screen.h)2>>


/* screen.c */
extern bool    hwaccel;  /* use hw acceleration; default on */
extern bool    hwblank;  /* use hw blanking; default on */
extern bool    panning;  /* use virtual screen panning; default off */

extern void 	addvgaseg(char*, ulong, ulong);

extern int  screensize(int, int, int, ulong);
extern int  screenaperture(int, int);

/* devdraw.c */
extern void deletescreenimage(void);
extern void resetscreenimage(void);
extern int drawidletime(void);
extern void drawblankscreen(int);
extern ulong  blanktime;
extern QLock  drawlock;
//extern int drawhasclients(void);
//extern void setscreenimageclipr(Rectangle);
//extern void drawflush(void);

/* vga.c */
extern void vgascreenwin(VGAscr*);
extern void vgaimageinit(ulong);
extern void vgalinearpciid(VGAscr*, int, int);
extern void vgalinearaddr(VGAscr*, ulong, int);
extern void vgablank(VGAscr*, int);
extern Lock vgascreenlock;

// software cursors
extern VGAcur swcursor;
extern void swcursorinit(void);
//extern void swcursorhide(void);
//extern void swcursoravoid(Rectangle);
//extern void swcursorunhide(void);
@


\subsection*{[[kernel/devices/screen/386/vgascreen.c]]}


%-------------------------------------------------------------

<<kernel/devices/screen/386/vgascreen.c>>=
#include "u.h"
#include "../port/lib.h"
#include "../port/error.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"

#include "io.h"
#include <ureg.h>

#include <draw.h>
#include <memdraw.h>
#include <cursor.h>

#include "../port/screen.h"
#include "vga.h"

//---------------------------------------------------------------------------
// vgax.c
//---------------------------------------------------------------------------

<<global vgaxlock>>

<<function vgaxi>>

<<function vgaxo>>

//---------------------------------------------------------------------------
// vga.c
//---------------------------------------------------------------------------

<<global back2>>
<<global conscol>>

<<global curpos>>
<<global window bis>>
<<global xp>>
<<global xbuf>>
<<global vgascreenlock>>

<<function vgaimageinit>>

<<function vgascroll>>

<<function vgascreenputc>>

<<function vgascreenputs>>

<<function vgascreenwin>>

<<function vgablank>>

<<function addvgaseg>>


//---------------------------------------------------------------------------
// vgascreen.c
//---------------------------------------------------------------------------


//#define RGB2K(r,g,b)    ((156763*(r)+307758*(g)+59769*(b))>>19)

extern void swcursorhide(void);
extern void swcursoravoid(Rectangle);
extern void vgalinearpci(VGAscr*);


//already in libdraw/arith.c

<<global vgascreen>>

<<global arrow>>

<<global didswcursorinit>>

<<global softscreen>>

<<function ishwimage>>


<<function screensize>>

<<function screenaperture>>

<<function attachscreen>>

<<function flushmemscreen>>

<<function getcolor>>

<<function setpalette>>

<<function setcolor>>

<<function cursoron>>

<<function cursoroff>>

<<function ksetcursor>>

<<global hwaccel>>
<<global hwblank>>
<<global panning>>

<<function hwdraw>>

<<function blankscreen bis>>

<<function vgalinearpciid>>

<<function vgalinearpci>>

<<function vgalinearaddr>>


/*
 * Software cursor. 
 */

<<global swvisible>>
<<global swenabled>>
<<global swback>>
<<global swimg>>
<<global swmask>>
<<global swimg1>>
<<global swmask1>>

<<global swoffset>>
<<global swrect>>
<<global swpt>>
<<global swvispt>>
<<global swvers>>
<<global swvisvers>>

<<function swcursorhide>>

<<function swcursoravoid>>

<<function swcursordraw>>

<<function swenable>>

<<function swdisable>>

<<function swload>>

<<function swmove>>

<<function swcursorclock>>

<<function swcursorinit>>

<<global swcursor>>
@


%\subsection*{[[kernel/devices/screen/386/vgax.c]]}
% actually code now in vgascreen.c


%\subsection*{[[kernel/devices/screen/386/vga.c]]}
% actually code now in vgascreen.c




%//void
%//cornerstring(char *s)
%//{
%//  int h, w;
%//  VGAscr *scr;
%//  Rectangle r;
%//  Point p;
%//
%//  scr = &vgascreen[0];
%//  if(scr->vaddr == nil || screenputs != vgascreenputs)
%//      return;
%//  p = memsubfontwidth(scr->memdefont, s);
%//  w = p.x;
%//  h = scr->memdefont->height;
%//
%//  r = Rect(0, 0, w, h);
%//  memimagedraw(scr->gscreen, r, back, back->r.min, nil, back->r.min, S);
%//  memimagestring(scr->gscreen, r.min, conscol, ZP, scr->memdefont, s);
%////    flushmemscreen(r);
%//}

\subsection*{[[kernel/devices/screen/386/devvga.c]]}


%-------------------------------------------------------------

<<kernel/devices/screen/386/devvga.c>>=
/*
 * VGA controller
 */
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"
#include "io.h"
#include "../port/error.h"

#include <draw.h>
#include <memdraw.h>
#include <cursor.h>

#include "../port/screen.h"
#include "vga.h"

<<enum _anon_ (kernel/devices/screen/386/devvga.c)>>

<<global vgadir>>

<<enum _anon_ (kernel/devices/screen/386/devvga.c)2>>

<<global vgactlmsg>>

<<function vgareset>>

<<function vgaattach>>

<<function vgawalk>>

<<function vgastat>>

<<function vgaopen>>

<<function vgaclose>>

<<function vgaread>>

<<function vgactl>>

<<global Enooverlay>>

<<function vgawrite>>

<<global vgadevtab>>
@

%//static void
%//checkport(int start, int end)
%//{
%//  /* standard vga regs are OK */
%//  if(start >= 0x2b0 && end <= 0x2df+1)
%//      return;
%//  if(start >= 0x3c0 && end <= 0x3da+1)
%//      return;
%//
%//  if(iounused(start, end))
%//      return;
%//  error(Eperm);


\subsection*{[[kernel/devices/screen/386/vgaclgd542x.c]]}

%-------------------------------------------------------------

<<kernel/devices/screen/386/vgaclgd542x.c>>=
#include "u.h"
#include "../port/lib.h"
#include "../port/error.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"

#include "io.h"

#include <draw.h>
#include <memdraw.h>
#include <cursor.h>

#include "../port/screen.h"
#include "vga.h"

<<function clgd542xpageset>>

<<function clgd542xpage>>

<<function clgd542xlinear>>

<<function clgd542xdisable>>

<<function clgd542xenable>>

<<function clgd542xinitcursor>>

<<function clgd542xload>>

<<function clgd542xmove>>

<<global vgaclgd542xdev>>

<<global vgaclgd542xcur>>
@


\subsection*{[[kernel/devices/screen/386/vgavesa.c]]}

<<enum _anon_ (kernel/devices/screen/386/vgavesa.c)>>=
enum {
    Usesoftscreen = 1,
};
@

<<global hardscreen>>=
static void *hardscreen;
@

<<global modebuf>>=
static uchar modebuf[0x1000];
@

<<function WORD>>=
// pad: seems similar to macros in fcall.h, factorize?
#define WORD(p) ((p)[0] | ((p)[1]<<8))
@

<<function LONG>>=
#define LONG(p) ((p)[0] | ((p)[1]<<8) | ((p)[2]<<16) | ((p)[3]<<24))
@

%//#define PLONG(p, v) do{(p)[0] = (v); (p)[1] = (v)>>8; (p)[2] = (v)>>16; (p)[3] = (v)>>24;}while(0)


<<function vbesetup>>=
static uchar*
vbesetup(Ureg *u, int ax)
{
    ulong pa;

    pa = PADDR(RMBUF);
    memset(modebuf, 0, sizeof modebuf);
    memset(u, 0, sizeof *u);
    u->ax = ax;
    u->es = (pa>>4)&0xF000;
    u->di = pa&0xFFFF;
    return modebuf;
}
@

<<function vbecall>>=
static void
vbecall(Ureg *u)
{
    Chan *creg, *cmem;
    ulong pa;

    cmem = namec("/dev/realmodemem", Aopen, ORDWR, 0);
    if(waserror()){
        cclose(cmem);
        nexterror();
    }
    creg = namec("/dev/realmode", Aopen, ORDWR, 0);
    if(waserror()){
        cclose(creg);
        nexterror();
    }
    pa = PADDR(RMBUF);
    /* TODO: check read and write return values */
    devtab[cmem->type]->write(cmem, modebuf, sizeof modebuf, pa);
    u->trap = 0x10;
    devtab[creg->type]->write(creg, u, sizeof *u, 0);

    devtab[creg->type]->read(creg, u, sizeof *u, 0);
    if((u->ax&0xFFFF) != 0x004F)
        error("vesa bios error");
    devtab[cmem->type]->read(cmem, modebuf, sizeof modebuf, pa);

    poperror();
    cclose(creg);
    poperror();
    cclose(cmem);
}
@

<<function vbecheck>>=
static void
vbecheck(void)
{
    Ureg u;
    uchar *p;

    p = vbesetup(&u, 0x4F00);
    strcpy((char*)p, "VBE2");
    vbecall(&u);
    if(memcmp((char*)p, "VESA", 4) != 0)
        error("bad vesa signature");
    if(p[5] < 2)
        error("bad vesa version");
}
@

<<function vbegetmode>>=
static int
vbegetmode(void)
{
    Ureg u;

    vbesetup(&u, 0x4F03);
    vbecall(&u);
    return u.bx;
}
@

<<function vbemodeinfo>>=
static uchar*
vbemodeinfo(int mode)
{
    uchar *p;
    Ureg u;

    p = vbesetup(&u, 0x4F01);
    u.cx = mode;
    vbecall(&u);
    return p;
}
@

<<function vesalinear>>=
static void
vesalinear(VGAscr *scr, int, int)
{
    int i, mode, size, havesize;
    uchar *p;
    ulong paddr;
    Pcidev *pci;

    if(hardscreen) {
        scr->vaddr = 0;
        scr->paddr = scr->apsize = 0;
        return;
    }

    vbecheck();
    mode = vbegetmode();
    /*
     * bochs loses the top bits - cannot use this
    if((mode&(1<<14)) == 0)
        error("not in linear graphics mode");
     */
    mode &= 0x3FFF;
    p = vbemodeinfo(mode);
    if(!(WORD(p+0) & (1<<4)))
        error("not in VESA graphics mode");
    if(!(WORD(p+0) & (1<<7)))
        error("not in linear graphics mode");

    paddr = LONG(p+40);
    size = WORD(p+20)*WORD(p+16);
    size = PGROUND(size);

    /*
     * figure out max size of memory so that we have
     * enough if the screen is resized.
     */
    pci = nil;
    havesize = 0;
    while(!havesize && (pci = pcimatch(pci, 0, 0)) != nil){
        if(pci->ccrb != Pcibcdisp)
            continue;
        for(i=0; i<nelem(pci->mem); i++)
            if(paddr == (pci->mem[i].bar&~0x0F)){
                if(pci->mem[i].size > size)
                    size = pci->mem[i].size;
                havesize = 1;
                break;
            }
    }

    /* no pci - heuristic guess */
    if (!havesize)
        if(size < 4*1024*1024)
            size = 4*1024*1024;
        else
            size = ROUND(size, 1024*1024);
    if(size > 16*1024*1024)     /* arbitrary */
        size = 16*1024*1024;

    vgalinearaddr(scr, paddr, size);
    if(scr->apsize)
        addvgaseg("vesascreen", scr->paddr, scr->apsize);

    if(Usesoftscreen){
        hardscreen = scr->vaddr;
        scr->vaddr = 0;
        scr->paddr = scr->apsize = 0;
    }
}
@
% >> >> >>

% vesalinear -> <>
% framebuffer for real? can do video games with that?
% vga.c
<<function addvgaseg>>=
void
addvgaseg(char *name, ulong pa, ulong size)
{
    Physseg seg;

    memset(&seg, 0, sizeof seg);
    seg.attr = SG_PHYSICAL;
    seg.name = name;
    seg.pa = pa;
    seg.size = size;
    addphysseg(&seg);
}
@



<<function vesaflush>>=
static void
vesaflush(VGAscr *scr, Rectangle r)
{
    int t, w, wid, off;
    ulong *hp, *sp, *esp;

    if(hardscreen == nil)
        return;
    if(rectclip(&r, gscreen->r) == 0)
        return;
    sp = (ulong*)(gscreendata.bdata + gscreen->zero);
    t = (r.max.x * gscreen->depth + 2*BI2WD-1) / BI2WD;
    w = (r.min.x * gscreen->depth) / BI2WD;
    w = (t - w) * BY2WD;
    wid = gscreen->width;
    off = r.min.y * wid + (r.min.x * gscreen->depth) / BI2WD;

    hp = hardscreen;
    hp += off;
    sp += off;
    esp = sp + Dy(r) * wid;
    while(sp < esp){
        memmove(hp, sp, w);
        hp += wid;
        sp += wid;
    }
}
@

<<global vgavesadev>>=
VGAdev vgavesadev = {
    "vesa",
    0,
    0,
    0,
    vesalinear,
    0,
    0,
    0,
    0,
    vesaflush,
};
@


%-------------------------------------------------------------

<<kernel/devices/screen/386/vgavesa.c>>=
/*
 * vga driver using just vesa bios to set up.
 *
 * note that setting hwaccel to zero will cause cursor ghosts to be
 * left behind.  hwaccel set non-zero repairs this.
 */
#include "u.h"
#include "../port/lib.h"
#include "../port/error.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"

#include "io.h"
#include <ureg.h>

#include <draw.h>
#include <memdraw.h>
#include <cursor.h>

#include "../port/screen.h"
#include "vga.h"

<<enum _anon_ (kernel/devices/screen/386/vgavesa.c)>>

<<global hardscreen>>
<<global modebuf>>

<<function WORD>>
<<function LONG>>
<<function vbesetup>>

<<function vbecall>>

<<function vbecheck>>

<<function vbegetmode>>

<<function vbemodeinfo>>

<<function vesalinear>>

<<function vesaflush>>

<<global vgavesadev>>
@

%//#define PWORD(p, v) do{(p)[0] = (v); (p)[1] = (v)>>8;}while(0)

