\documentclass[twocolumn]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse
% see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things:

%thx to codemap/codegraph/scheck:
% - TODO use cg to reduce backward deps, introduce globals.c, utils.c,
%   (harder to understand non layered code)
% - TODO use scheck to remove deadcode, dead prototypes, useless export
%   or mv as forward decl
%   (harder to understand big interface files)
% - TODO use cg to reduce number of globals by moving them closer to the
%   relevant file (or even function), better cluster the code
%   (harder to understand non functional code using lots of globals)

%thx to this manual, better understand svgalib?:

%history LP-ization:
% - skeleton, mostly copy paste of Template.tex.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * TODO ctor/dtor, dumper
%    * TODO [[xxx]] other fields, [[xxx]] extra fields
% - TODO read Extra section, identify concepts, first TOC
% - TODO distribute parts of the Extra section in the main file
% - TODO understand main(), LP split main, improve TOC
% - TODO understand main functions, LP split, cluster, improve TOC
% - TODO LP split the structures, use datalog for flow to field info
% - TODO nullify, boolify, errorify, enumify,  typeify,    scheckify, plan9ify
% - TODO aspecify advanced features! remove useless features
% - TODO add figures
% - TODO add explanations


%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\iffinal
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\fi
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
%\usepackage{cleveref} %\cref
%\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}
 %\usepackage[margin=0.5in]{geometry}
 %  but eat the bottom when very low
 %\usepackage{fullpage} is deprecated 
 % => do the more manual below:
 \addtolength{\oddsidemargin}{-.850in}
 \addtolength{\evensidemargin}{-.850in}
 \addtolength{\textwidth}{1.70in}
 \addtolength{\topmargin}{-.850in}
 \addtolength{\textheight}{1.70in}
%\usepackage{minitoc}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% used for forward decl, pragmas, func decl, extern decl, stats, #ifdef,
% debugging macros

%\setcounter{tocdepth}{1}

%******************************************************************************
% Title
%******************************************************************************

\begin{document}

\title{
{\Huge 
Principia Softwarica: The Plan9 Graphics System [[/dev/draw]]
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}
}

\maketitle 
\onecolumn
\hrule
\begin{quote}
    Copyright \copyright{} 2014 Yoann Padioleau \\
    Permission is granted to copy, distribute and/or modify this document,
    except all the source code it contains, under the terms of the GNU Free
    Documentation License, Version 1.3.
\end{quote}
\hrule

%CONFIG: \dominitoc

\iffinal
\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\twocolumn
\tableofcontents
\endgroup
\else
\tableofcontents
\fi

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

\section{Motivations}

The goal of this book is to present in full details the source code of
a real graphics system.
Why? Because I think it makes you a better programmer if
you fully understand how things work under the hood.

% gonna present the one in Plan9, mostly /dev/draw, but also
% /dev/mouse, /dev/cons, etc.
% It actually provides some forms of window managment, with backing
% store, and even menu (but rio is more complete)

Here are other candidates that were considered but ultimately discarded:
\begin{itemize}
\item mks
\item svgalib
\item cairo
\item opengl
\item X11
\end{itemize}
% nuttx has some graphic and windowing stack apparently too!

%opengl and glut. the menuhit function is kinda related to glut.

\section{Getting started}

\section{Requirements}

\section{About this document}
#include "../docs/latex/About.tex.nw"

\section{Copyright}

Most of this document is actually source code from Plan9, so
those parts are copyright by Lucent Technologies Inc.
The prose is mine and is licensed under the GNU Free Documentation
License.

\section{Acknowledgments}

I would like to acknowledge of course Plan9's authors who wrote
most of this book: Rob Pike, Ken Thompson, Dave Presotto, Phil
Winterbottom, Russ Cox, and many other people from Bell Labs.

\chapter{Overview}

\section{Graphics system principles}

% Line, poly, ellipse, text (fonts)
% colors
% composition (porter-duff)

% see cairo intro?

\section{[[/dev/draw]] services}
%maybe show code of toy app also?
% show the different devices?

% note that can run 'colors' in console outside rio! it just
% use /dev/draw, /dev/mouse, etc!

% see draw(5?)

\section{A toy graphical application}
% e.g. colors


\section{Code organization}

% libdraw, libmemdraw, libmemlayer?
%#include <draw.h>
%#include <memdraw.h>
%#include <memlayer.h>
% lofs of files have similar name in libdraw/ and libmemdraw/

% kernel part? user part?

%-------------------
% libdraw/
%-------------------

%icossin.c: math
%icossin2.c: math

%arith.c: Point, Rectangle and helpers

%init.c: display, screen, images

%draw.c: draw rectangle
 %border.c: draw border
%line.c: draw line
%poly.c: draw polylines
%ellipse.c: draw ellipse
%bezier.c: draw spline
%string.c: draw text
 %stringbg.c

%alloc.c
%allocimagemix.c:

%chan.c
%rgb.c
%readcolmap.c
%writecolmap.c

%readimage.c
%writeimage.c
%loadimage.c
%unloadimage.c
%cloadimage.c
%creadimage.c

%window.c
%newwindow.c



%event.c
%mouse.c
%keyboard.c

%emenuhit.c
%menuhit.c

%debug.c
%fmt.c


%buildfont.c
%defont.c
%font.c
%freesubfont.c
%getdefont.c
%getsubfont.c
%mkfont.c
%readsubfont.c
%stringsubfont.c
%subfont.c
%subfontcache.c
%subfontname.c
%openfont.c
%writesubfont.c


%bytesperline.c
%computil.c
%drawrepl.c
%egetrect.c
%getrect.c
%rectclip.c
%replclipr.c
%scroll.c
%stringwidth.c


%-------------------
% libmemdraw/
%-------------------

%draw.c
%hwdraw.c

%line.c
%poly.c
%fillpoly.c
%ellipse.c
%arc.c
%string.c

%alloc.c

%cmap.c

%load.c
%unload.c

%read.c
%write.c

%cload.c
%cread.c


%openmemsubfont.c
%subfont.c
%defont.c


%replmul.c

%iprint.c



%-------------------
% libmemlayer/
%-------------------
%draw.c

%lalloc.c
%layerop.c
%ldelete.c
%lsetrefresh.c

%line.c

%lorigin.c
%lhide.c
%ltofront.c
%ltorear.c

%load.c
%unload.c

%-------------------
% kernel/drivers/screen/
%-------------------
% ???

\section{Architecture overview}

% app, library, kernel draw server, vga driver
% kernel vs libs vs apps (vs rio)

% public API -> marshaller -> flush -> KERNEL -> unmarshaller -> algorithm
% some kind of RPC and protocol


% libdraw -> KERNEL -> devdraw -> libmemdraw | libmemlayer -> devvga -> clgd5446
% that's a lot of entities

% Display
%  Image (User side, id) MemImage (Kernel side, id -> full structure)
%  Screen
%   Window (Image)

% devvga
%  why imagmem? why imagmem and mainmem? why not use other allocator?
%  see screen/user/notes.txt especially about the old way to get graphics on PC


% about RPC vs framebuffer.
% design goal was like X11 can be remote! can login on another
% machine, execute program there that actually display on your screen.
% for plan9 they just reuse 9p! network file system so /dev/draw
% can be on the network!
% but this design means it's not a framebuffer! it accepts
% drawing commands, like in X11, because can't allow to send
% all pixels each time through big write on /dev/draw over the network
% (hmm actually with high speed network maybe we could)



\section{Initialization overview}

%\section{Trace of a mouse click}

%\section{Trace of a key press}

\section{Trace of a simple drawing operation}
% when do draw(), then where does it go? go in kernel?


%###############################################################################

\chapter{Core Data Structures}

% draw.h big categories
% the important globals init libdraw/init.c

\section{[[Display]] and [[Client]]}

<<struct Display>>=
struct Display
{
    char	*devdir; // /dev in general
    char	*windir; // /dev in general

    int		dirno; // /dev/draw/x

    fdt		fd;    // /dev/draw/x/data
    fdt		ctlfd; // /dev/draw/new
    fdt		reffd; // /dev/draw/x/refresh

    // ref_own<Image>
    Image	*image;

    // drawing operatings to write in /dev/draw/x/data until flush
    // array<byte>
    byte	*buf;
    int		bufsize;
    // index in Display.buf array
    byte	*bufp;

    void	(*error)(Display*, char*);

    Image	*white;
    Image	*black;

    Image	*opaque;
    Image	*transparent;


    QLock	qlock;
    int		locking;	/*program is using lockdisplay */

    int		imageid;
    int		local;
    char	oldlabel[64];
    ulong	dataqid;

    Font	*defaultfont;
    Subfont	*defaultsubfont;

    Image	*windows;
    Image	*screenimage; // ???

    bool	_isnewdisplay;
};
@


%!!!!
<<global display>>=
Display	*display;
@

% usually have draw(dstimg, rectangle, srcimg, maskimg)
% and srcimg can be just black, and maskimg can be just opaque
% the abuse image for many things, because it's more general!
% Black is an image! (1x1 pixels)


<<struct Client>>=
struct Client
{
    Ref     r;
    DImage*     dimage[NHASH];
    CScreen*    cscreen;
    Refresh*    refresh;
    Rendez      refrend;
    uchar*      readdata;
    int     nreaddata;
    int     busy;
    int     clientid;
    int     slot;
    int     refreshme;
    int     infoid;

    int     op;
};
@


\section{[[Image]] and [[Memimage]]}
% and screen

<<struct Image>>=
struct Image
{
    // ref<Display>, reverse of Display->image
    Display		*display;	/* display holding data */
    int			id;		/* id of system-held Image */

    Rectangle	r;		/* rectangle in data area, local coords */
    Rectangle 	clipr;		/* clipping region */
    int			depth;		/* number of bits per pixel */

    ulong		chan;
    int			repl;		/* flag: data replicates to tile clipr */

    <<[[Image]] other fields>>
};
@
% read from /dev/draw/new initially when open the connection
%  see initdisplay()
% system-held id!

% need display pointer because when do draw operation we need
% to write in img->display.buf! and then flushimage(img->display)!

<<global screen>>=
Image	*screen;
@
% unfortunate ... should call it image really ... or even maybe
% window


<<[[Image]] other fields>>=
Screen		*screen;	/* 0 if not a window */
Image		*next;	/* next in list of windows */
@








<<struct Memimage>>=
struct Memimage
{
    Rectangle	r;		/* rectangle in data area, local coords */
    Rectangle	clipr;		/* clipping region */
    int		depth;	/* number of bits of storage per pixel */
    int		nchan;	/* number of channels */
    ulong	chan;	/* channel descriptions */
    Memcmap	*cmap;

    Memdata	*data;	/* pointer to data; shared by windows in this image */
    int		zero;		/* data->bdata+zero==&byte containing (0,0) */
    ulong	width;	/* width in words of a single scan line */
    Memlayer	*layer;	/* nil if not a layer*/
    ulong	flags;

    int		shift[NChan];
    int		mask[NChan];
    int		nbits[NChan];
};
@


<<struct Memdata>>=
/*
 * Memdata is allocated from main pool, but .data from the image pool.
 * Memdata is allocated separately to permit patching its pointer after
 * compaction when windows share the image data.
 * The first word of data is a back pointer to the Memdata, to find
 * The word to patch.
 */

struct Memdata
{
    ulong	*base;	/* allocated data pointer */
    uchar	*bdata;	/* pointer to first byte of actual data; word-aligned */
    int		ref;		/* number of Memimages using this data */
    void*	imref;
    int		allocd;	/* is this malloc'd? */
};
@

\section{Image channel}

% not thread channel, image channel here
% ulong in previous struct, but more complex format
% actually

<<enum _anon_ (include/draw.h)4>>=
/*
 * image channel descriptors 
 */
enum {
    CRed = 0,
    CGreen,
    CBlue,

    CGrey,
    CAlpha,
    CMap,
    CIgnore,

    NChan,
};
@

<<function __DC>>=
#define __DC(type, nbits)	((((type)&15)<<4)|((nbits)&15))
@

<<function CHAN1>>=
#define CHAN1(a,b)	__DC(a,b)
@

<<function CHAN2>>=
#define CHAN2(a,b,c,d)	(CHAN1((a),(b))<<8|__DC((c),(d)))
@

<<function CHAN3>>=
#define CHAN3(a,b,c,d,e,f)	(CHAN2((a),(b),(c),(d))<<8|__DC((e),(f)))
@

<<function CHAN4>>=
#define CHAN4(a,b,c,d,e,f,g,h)	(CHAN3((a),(b),(c),(d),(e),(f))<<8|__DC((g),(h)))
@

<<function NBITS>>=
#define NBITS(c) ((c)&15)
@

<<function TYPE>>=
#define TYPE(c) (((c)>>4)&15)
@

<<enum _anon_ (include/draw.h)5>>=
enum {
    GREY1	= CHAN1(CGrey, 1),
    GREY2	= CHAN1(CGrey, 2),
    GREY4	= CHAN1(CGrey, 4),
    GREY8	= CHAN1(CGrey, 8),
    CMAP8	= CHAN1(CMap, 8),
    RGB15	= CHAN4(CIgnore, 1, CRed, 5, CGreen, 5, CBlue, 5),
    RGB16	= CHAN3(CRed, 5, CGreen, 6, CBlue, 5),
    RGB24	= CHAN3(CRed, 8, CGreen, 8, CBlue, 8),
    RGBA32	= CHAN4(CRed, 8, CGreen, 8, CBlue, 8, CAlpha, 8),
    ARGB32	= CHAN4(CAlpha, 8, CRed, 8, CGreen, 8, CBlue, 8),	/* stupid VGAs */
    XRGB32	= CHAN4(CIgnore, 8, CRed, 8, CGreen, 8, CBlue, 8),
    BGR24	= CHAN3(CBlue, 8, CGreen, 8, CRed, 8),
    ABGR32	= CHAN4(CAlpha, 8, CBlue, 8, CGreen, 8, CRed, 8),
    XBGR32	= CHAN4(CIgnore, 8, CBlue, 8, CGreen, 8, CRed, 8),
};
@


\section{[[Font]] and [[font]]}

<<struct Font>>=
struct Font
{
    char		*name;
    Display		*display;

    short		height;	/* max height of image, interline spacing */
    short		ascent;	/* top of image to baseline */
    short		width;	/* widest so far; used in caching only */	

    short		nsub;	/* number of subfonts */
    ulong		age;	/* increasing counter; used for LRU */
    int		maxdepth;	/* maximum depth of all loaded subfonts */
    int		ncache;	/* size of cache */
    int		nsubf;	/* size of subfont list */

    Cacheinfo	*cache;
    Cachesubf	*subf;
    Cachefont	**sub;	/* as read from file */
    Image		*cacheimage;
};
@


<<global font>>=
Font	*font;
@

\section{[[Drawop]] and [[Memdrawparam]]}
<<enum drawop>>=
enum drawop
{
    /* Porter-Duff compositing operators */
    Clear	= 0,

    SinD	= 8,
    DinS	= 4,
    SoutD	= 2,
    DoutS	= 1,

    S		= SinD|SoutD,
    SoverD	= SinD|SoutD|DoutS,
    SatopD	= SinD|DoutS,
    SxorD	= SoutD|DoutS,

    D		= DinS|DoutS,
    DoverS	= DinS|DoutS|SoutD,
    DatopS	= DinS|SoutD,
    DxorS	= DoutS|SoutD,	/* == SxorD */

    Ncomp = 12,
};
@


<<struct Memdrawparam>>=
struct	Memdrawparam
{
    Memimage *dst;
    Rectangle	r;
    Memimage *src;
    Rectangle sr;
    Memimage *mask;
    Rectangle mr;
    int op;

    ulong state;
    ulong mval;	/* if Simplemask, the mask pixel in mask format */
    ulong mrgba;	/* mval in rgba */
    ulong sval;	/* if Simplesrc, the source pixel in src format */
    ulong srgba;	/* sval in rgba */
    ulong sdval;	/* sval in dst format */
};
@

\chapter{[[initdraw()]]}

<<function initdraw>>=
errorcodeneg1
initdraw(void(*error)(Display*, char*), char *fontname , char *label)
{
    char *dev = "/dev";

    if(access("/dev/draw/new", AEXIST)<0 && bind("#i", "/dev", MAFTER)<0){
        fprint(2, "imageinit: can't bind /dev/draw: %r\n");
        return ERROR_NEG1;
    }
    return geninitdraw(dev, error, fontname, label, dev, Refnone);
}
@

% devdir and windir often equals and = /dev
<<function geninitdraw>>=
errorcodeneg1
geninitdraw(char *devdir, void(*error)(Display*, char*), char *fontname, char *label, char *windir, int ref)
{
    int fd, n;
    Subfont *df;
    char buf[128];

    display = initdisplay(devdir, windir, error);
    if(display == nil)
        return ERROR_NEG1;

    <<[[geninitdraw()]] set up font>>
    <<[[geninitdraw()]] write label>>
    <<[[geninitdraw()]] get window>>

    atexit(drawshutdown);

    return OK_1;
}
@

<<function drawshutdown>>=
/* note handler */
static void
drawshutdown(void)
{
    Display *d;

    d = display;
    if(d){
        display = nil;
        _closedisplay(d, 1);
    }
}
@


\section{[[initdisplay()]]}

<<constant NINFO>>=
#define	NINFO	12*12
@
% /dev/draw/new content, 12 strings each 11 chars + newline

<<[[initdisplay()]] locals>>=
Display *disp;
Image *image;

fdt ctlfd;
char info[NINFO+1];
fdt datafd;
fdt reffd;

char buf[128];
char *t;
bool isnew;
int n;
Dir *dir;
@

%less: could reorganize error managment like in Linux instead
% have the errorx: followed, so less need 'goto previousone';

% hmm it's actually a public function! but not much app tweaking
% with it
<<function initdisplay>>=
Display*
initdisplay(char *dev, char *win, void(*error)(Display*, char*))
{
    <<[[initdisplay()]] locals>>

    <<[[initdisplay()]] install dumpers>>
    <<[[initdisplay()]] check arguments validity>>

    sprint(buf, "%s/draw/new", dev);
    ctlfd = open(buf, ORDWR|OCEXEC);

    if(ctlfd < 0){
        if(bind("#i", dev, MAFTER) < 0){
    Error1:
            free(t);
            werrstr("initdisplay: %s: %r", buf);
            return nil;
        }
        // try again
        ctlfd = open(buf, ORDWR|OCEXEC);
    }
    if(ctlfd < 0)
        goto Error1;

    n=read(ctlfd, info, sizeof info);

    if(n < 12){
    Error2:
        close(ctlfd);
        goto Error1;
    }
    if(n==NINFO+1)
        n = NINFO;
    info[n] = '\0';

    isnew = false;
    if(n < NINFO)	/* this will do for now, we need something better here */
        isnew = true;

    sprint(buf, "%s/draw/%d/data", dev, atoi(info+0*12));
    datafd = open(buf, ORDWR|OCEXEC);

    if(datafd < 0)
        goto Error2;

    sprint(buf, "%s/draw/%d/refresh", dev, atoi(info+0*12));
    reffd = open(buf, OREAD|OCEXEC);

    if(reffd < 0){
    Error3:
        close(datafd);
        goto Error2;
    }

    disp = mallocz(sizeof(Display), 1);

    if(disp == nil){
    Error4:
        close(reffd);
        goto Error3;
    }

    image = nil;
    if(0){
    Error5:
        free(image);
        free(disp);
        goto Error4;
    }
    if(n >= NINFO){
        image = mallocz(sizeof(Image), 1);
        if(image == nil)
            goto Error5;
        image->display = disp;
        image->id = 0; // info+1*12 but should always be 0
        image->chan = strtochan(info+2*12);
        image->depth = chantodepth(image->chan);
        image->repl = atoi(info+3*12);
        image->r.min.x = atoi(info+4*12);
        image->r.min.y = atoi(info+5*12);
        image->r.max.x = atoi(info+6*12);
        image->r.max.y = atoi(info+7*12);
        image->clipr.min.x = atoi(info+8*12);
        image->clipr.min.y = atoi(info+9*12);
        image->clipr.max.x = atoi(info+10*12);
        image->clipr.max.y = atoi(info+11*12);
    }

    disp->_isnewdisplay = isnew;

    disp->bufsize = iounit(datafd);
    if(disp->bufsize <= 0)
        disp->bufsize = 8000;
    if(disp->bufsize < 512){
        werrstr("iounit %d too small", disp->bufsize);
        goto Error5;
    }
    disp->buf = malloc(disp->bufsize+5);	/* +5 for flush message */
    if(disp->buf == nil)
        goto Error5;

    disp->image = image;
    disp->dirno = atoi(info+0*12);
    disp->fd    = datafd;
    disp->ctlfd = ctlfd;
    disp->reffd = reffd;
    disp->bufp = disp->buf;
    disp->error = error;
    disp->windir = t;
    disp->devdir = strdup(dev);

    qlock(&disp->qlock);
    disp->white = allocimage(disp, Rect(0, 0, 1, 1), GREY1, 1, DWhite);
    disp->black = allocimage(disp, Rect(0, 0, 1, 1), GREY1, 1, DBlack);
    if(disp->white == nil || disp->black == nil){
        free(disp->devdir);
        free(disp->white);
        free(disp->black);
        goto Error5;
    }
    disp->opaque = disp->white;
    disp->transparent = disp->black;

    dir = dirfstat(ctlfd);
    if(dir!=nil && dir->type=='i'){
        disp->local = 1;
        disp->dataqid = dir->qid.path;
    }
    if(dir!=nil && dir->qid.vers==1)	/* other way to tell */
        disp->_isnewdisplay = 1;
    free(dir);

    return disp;
}
@


<<[[initdisplay()]] install dumpers>>=
fmtinstall('P', Pfmt);
fmtinstall('R', Rfmt);
@

<<[[initdisplay()]] check arguments validity>>=
if(dev == nil)
    dev = "/dev";
if(win == nil)
    win = "/dev";

if(strlen(dev)>sizeof buf-25 || strlen(win)>sizeof buf-25){
    werrstr("initdisplay: directory name too long");
    return nil;
}
t = strdup(win);
if(t == nil)
    return nil;
@






<<function closedisplay>>=
/*
 * Call with d unlocked.
 * Note that disp->defaultfont and defaultsubfont are not freed here.
 */
void
closedisplay(Display *disp)
{
    _closedisplay(disp, 0);
}
@

<<function _closedisplay>>=
static void
_closedisplay(Display *disp, int isshutdown)
{
    int fd;
    char buf[128];

    if(disp == nil)
        return;
    if(disp == display)
        display = nil;
    if(disp->oldlabel[0]){
        snprint(buf, sizeof buf, "%s/label", disp->windir);
        fd = open(buf, OWRITE);
        if(fd >= 0){
            write(fd, disp->oldlabel, strlen(disp->oldlabel));
            close(fd);
        }
    }

    /*
     * if we're shutting down, don't free all the resources.
     * if other procs are getting shot down by notes too,
     * one might get shot down while holding the malloc lock.
     * just let the kernel clean things up when we exit.
     */
    if(isshutdown)
        return;

    free(disp->devdir);
    free(disp->windir);
    freeimage(disp->white);
    freeimage(disp->black);
    close(disp->fd);
    close(disp->ctlfd);
    /* should cause refresh slave to shut down */
    close(disp->reffd);
    qunlock(&disp->qlock);
    free(disp);
}
@

\section{Fonts}

<<[[geninitdraw()]] set up font>>=
/*
 * Set up default font
 */
df = getdefont(display);
display->defaultsubfont = df;
if(df == nil){
    fprint(2, "imageinit: can't open default subfont: %r\n");
Error:
    closedisplay(display);
    display = nil;
    return -1;
}
if(fontname == nil){
    fd = open("/env/font", OREAD);
    if(fd >= 0){
        n = read(fd, buf, sizeof(buf));
        if(n>0 && n<sizeof buf-1){
            buf[n] = 0;
            fontname = buf;
        }
        close(fd);
    }
}
/*
 * Build fonts with caches==depth of screen, for speed.
 * If conversion were faster, we'd use 0 and save memory.
 */
if(fontname == nil){
    snprint(buf, sizeof buf, "%d %d\n0 %d\t%s\n", df->height, df->ascent,
        df->n-1, deffontname);
 //BUG: Need something better for this	installsubfont("*default*", df);
    font = buildfont(display, buf, deffontname);
    if(font == nil){
        fprint(2, "imageinit: can't open default font: %r\n");
        goto Error;
    }
}else{
    font = openfont(display, fontname);	/* BUG: grey fonts */
    if(font == nil){
        fprint(2, "imageinit: can't open font %s: %r\n", fontname);
        goto Error;
    }
}
display->defaultfont = font;
@

\section{Label}

<<[[geninitdraw()]] write label>>=
/*
 * Write label; ignore errors (we might not be running under rio)
 */
if(label){
    snprint(buf, sizeof buf, "%s/label", display->windir);
    fd = open(buf, OREAD);
    if(fd >= 0){
        read(fd, display->oldlabel, (sizeof display->oldlabel)-1);
        close(fd);
        fd = create(buf, OWRITE, 0666);
        if(fd >= 0){
            write(fd, label, strlen(label));
            close(fd);
        }
    }
}
@

\section{Screen}

<<[[geninitdraw()]] get window>>=
snprint(buf, sizeof buf, "%s/winname", display->windir);
if(gengetwindow(display, buf, &screen, &_screen, ref) < 0)
    goto Error;
@
% ???

\chapter{User/Kernel Bridge}

% some kind of RPC and protocol
% todo: lots of boilerplate code, would be better to use thrift in the end
% lots of marshalling/unmarshalling boilerplate with BPLONG and so on.
% file interface is nice but limited in the end. Or maybe can just
% write a thrift like tool on top of the file interface that generates
% most of the boilerplate at least.

\section{Draw device}

% so bind #i

<<global drawdevtab>>=
Dev drawdevtab = {
    .dc       =    'i',
    .name     =    "draw",

    .attach   =    drawattach,
    .walk     =    drawwalk,
    .open     =    drawopen,
    .close    =    drawclose,
    .read     =    drawread,
    .write    =    drawwrite,
    .stat     =    drawstat,
    .wstat    =    devwstat,
               
    .reset    =    devreset,
    .init     =    devinit,
    .shutdown =    devshutdown,
    .create   =    devcreate,
    .bread    =    devbread,
    .bwrite   =    devbwrite,
    .remove   =    devremove,
};
@

\subsection{[[/dev/draw/new]]}

\subsection{[[/dev/draw/x/data]]}

\section{Vga device}

<<global vgadevtab>>=
Dev vgadevtab = {
    .dc       =    'v',
    .name     =    "vga",
               
    .reset    =    vgareset,

    .attach   =    vgaattach,
    .walk     =    vgawalk,
    .open     =    vgaopen,
    .close    =    vgaclose,
    .read     =    vgaread,
    .write    =    vgawrite,
    .stat     =    vgastat,
    .wstat    =    devwstat,

    .init     =    devinit,
    .shutdown =    devshutdown,
    .create   =    devcreate,
    .bread    =    devbread,
    .bwrite   =    devbwrite,
    .remove   =    devremove,
};
@

\section{Protocol}

<<function BGSHORT>>=
#define	BGSHORT(p)		(((p)[0]<<0) | ((p)[1]<<8))
@

<<function BGLONG>>=
#define	BGLONG(p)		((BGSHORT(p)<<0) | (BGSHORT(p+2)<<16))
@

<<function BPSHORT>>=
#define	BPSHORT(p, v)		((p)[0]=(v), (p)[1]=((v)>>8))
@

<<function BPLONG>>=
#define	BPLONG(p, v)		(BPSHORT(p, (v)), BPSHORT(p+2, (v)>>16))
@

% could start by a simple example? like flush?


% put buf fields here

<<function bufimage>>=
uchar*
bufimage(Display *d, int n)
{
    uchar *p;

    if(n<0 || n>d->bufsize){
        werrstr("bad count in bufimage");
        return 0;
    }
    if(d->bufp+n > d->buf+d->bufsize)
        if(doflush(d) < 0)
            return 0;
    p = d->bufp;
    d->bufp += n;
    return p;
}
@


\section{[[drawmesg()]]}

<<[[drawmesg()]] locals>>=
byte *a;
int m = 0;

char *fmt = nil;

int c, repl, y, dstid, scrnid, ni, ci, j, nw, e0, e1, op, ox, oy, oesize, esize, doflush;
byte *u, refresh;
ulong value, chan;
Rectangle r, clipr;
Point p, q, *pp, sp;
Memimage *i, *bg, *dst, *src, *mask;
Memimage *l, **lp;
Memscreen *scrn;
DImage *font, *ll, *di, *ddst, *dsrc;
DName *dn;
DScreen *dscrn;
FChar *fc;
Refx *refx;
CScreen *cs;
Refreshfn reffn;
@


% the big one!! this is in kernel!!
<<function drawmesg>>=
void
drawmesg(Client *client, void *av, int n)
{
    <<[[drawmesg()]] locals>>

    a = av;
    if(waserror()){
        if(fmt) 
            printmesg(fmt, a, 1);
    /*  iprint("error: %s\n", up->errstr);  */
        nexterror();
    }
    while((n-=m) > 0){
        USED(fmt);
        a += m;
        switch(*a){
        <<[[drawmesg()]] cases>>
        default:
            error("bad draw command");
        }
    }
    poperror();
}
@


\section{Image}

\subsection{API}

<<function allocimage>>=
Image*
allocimage(Display *d, Rectangle r, ulong chan, int repl, ulong val)
{
    Image*	i;

    i =  _allocimage(nil, d, r, chan, repl, val, 0, 0);
    if (i)
        setmalloctag(i, getcallerpc(&d));
    return i;
}
@

<<function freeimage>>=
int
freeimage(Image *i)
{
    int ret;

    ret = _freeimage1(i);
    free(i);
    return ret;
}
@

\subsection{Marshalling}

<<function _allocimage>>=
Image*
_allocimage(Image *ai, Display *d, Rectangle r, ulong chan, int repl, ulong val, int screenid, int refresh)
{
    uchar *a;
    char *err;
    Image *i;
    Rectangle clipr;
    int id;
    int depth;

    err = 0;
    i = 0;

    if(chan == 0){
        werrstr("bad channel descriptor");
        return nil;
    }

    depth = chantodepth(chan);
    if(depth == 0){
        err = "bad channel descriptor";
    Error:
        if(err)
            werrstr("allocimage: %s", err);
        else
            werrstr("allocimage: %r");
        free(i);
        return 0;
    }

    /* flush pending data so we don't get error allocating the image */
    flushimage(d, 0);
    a = bufimage(d, 1+4+4+1+4+1+4*4+4*4+4);
    if(a == 0)
        goto Error;
    d->imageid++;
    id = d->imageid;

    a[0] = 'b';
    BPLONG(a+1, id);
    BPLONG(a+5, screenid);
    a[9] = refresh;
    BPLONG(a+10, chan);
    a[14] = repl;
    BPLONG(a+15, r.min.x);
    BPLONG(a+19, r.min.y);
    BPLONG(a+23, r.max.x);
    BPLONG(a+27, r.max.y);
    if(repl)
        /* huge but not infinite, so various offsets will leave it huge, not overflow */
        clipr = Rect(-0x3FFFFFFF, -0x3FFFFFFF, 0x3FFFFFFF, 0x3FFFFFFF);
    else
        clipr = r;
    BPLONG(a+31, clipr.min.x);
    BPLONG(a+35, clipr.min.y);
    BPLONG(a+39, clipr.max.x);
    BPLONG(a+43, clipr.max.y);
    BPLONG(a+47, val);

    if(flushimage(d, 0) < 0)
        goto Error;

    if(ai)
        i = ai;
    else{
        i = malloc(sizeof(Image));
        if(i == nil){
            a = bufimage(d, 1+4);
            if(a){
                a[0] = 'f';
                BPLONG(a+1, id);
                flushimage(d, 0);
            }
            goto Error;
        }
    }
    i->display = d;
    i->id = id;
    i->depth = depth;
    i->chan = chan;
    i->r = r;
    i->clipr = clipr;
    i->repl = repl;
    i->screen = 0;
    i->next = 0;
    return i;
}
@


<<function _freeimage1>>=
int
_freeimage1(Image *i)
{
    uchar *a;
    Display *d;
    Image *w;

    if(i == 0 || i->display == 0)
        return 0;
    /* make sure no refresh events occur on this if we block in the write */
    d = i->display;
    /* flush pending data so we don't get error deleting the image */
    flushimage(d, 0);
    a = bufimage(d, 1+4);
    if(a == 0)
        return -1;
    a[0] = 'f';
    BPLONG(a+1, i->id);
    if(i->screen){
        w = d->windows;
        if(w == i)
            d->windows = i->next;
        else
            while(w){
                if(w->next == i){
                    w->next = i->next;
                    break;
                }
                w = w->next;
            }
    }
    if(flushimage(d, i->screen!=0) < 0)
        return -1;

    return 0;
}
@

\subsection{Unmarshalling}

<<[[drawmesg()]] cases>>=
/* new allocate: 'b' id[4] screenid[4] refresh[1] chan[4] repl[1] R[4*4] clipR[4*4] rrggbbaa[4] */
case 'b':
    printmesg(fmt="LLbLbRRL", a, 0);
    m = 1+4+4+1+4+1+4*4+4*4+4;
    if(n < m)
        error(Eshortdraw);
    dstid = BGLONG(a+1);
    scrnid = BGSHORT(a+5);
    refresh = a[9];
    chan = BGLONG(a+10);
    repl = a[14];
    drawrectangle(&r, a+15);
    drawrectangle(&clipr, a+31);
    value = BGLONG(a+47);
    if(drawlookup(client, dstid, 0))
        error(Eimageexists);
    if(scrnid){
        dscrn = drawlookupscreen(client, scrnid, &cs);
        scrn = dscrn->screen;
        if(repl || chan!=scrn->image->chan)
            error("image parameters incompatible with screen");
        reffn = nil;
        switch(refresh){
        case Refbackup:
            break;
        case Refnone:
            reffn = memlnorefresh;
            break;
        case Refmesg:
            reffn = drawrefresh;
            break;
        default:
            error("unknown refresh method");
        }
        l = memlalloc(scrn, r, reffn, 0, value);
        if(l == 0)
            error(Edrawmem);
        addflush(l->layer->screenr);
        l->clipr = clipr;
        rectclip(&l->clipr, r);
        if(drawinstall(client, dstid, l, dscrn) == 0){
            memldelete(l);
            error(Edrawmem);
        }
        dscrn->ref++;
        if(reffn){
            refx = nil;
            if(reffn == drawrefresh){
                refx = malloc(sizeof(Refx));
                if(refx == 0){
                    drawuninstall(client, dstid);
                    error(Edrawmem);
                }
                refx->client = client;
                refx->dimage = drawlookup(client, dstid, 1);
            }
            memlsetrefresh(l, reffn, refx);
        }
        continue;
    }
    i = allocmemimage(r, chan);
    if(i == 0)
        error(Edrawmem);
    if(repl)
        i->flags |= Frepl;
    i->clipr = clipr;
    if(!repl)
        rectclip(&i->clipr, r);
    if(drawinstall(client, dstid, i, 0) == 0){
        freememimage(i);
        error(Edrawmem);
    }
    memfillcolor(i, value);
    continue;
@


<<[[drawmesg()]] cases>>=
/* free: 'f' id[4] */
case 'f':
    printmesg(fmt="L", a, 1);
    m = 1+4;
    if(n < m)
        error(Eshortdraw);
    ll = drawlookup(client, BGLONG(a+1), 0);
    if(ll && ll->dscreen && ll->dscreen->owner != client)
        ll->dscreen->owner->refreshme = 1;
    drawuninstall(client, BGLONG(a+1));
    continue;

@

\subsection{Algorithm}

\section{Flush}

\subsection{API}

<<function flushimage>>=
int
flushimage(Display *d, int visible)
{
    if(d == nil)
        return 0;
    if(visible){
        *d->bufp++ = 'v';	/* five bytes always reserved for this */
        if(d->_isnewdisplay){
            BPLONG(d->bufp, d->screenimage->id);
            d->bufp += 4;
        }
    }
    return doflush(d);
}
@

\subsection{Marshalling}

<<function doflush>>=
static
int
doflush(Display *d)
{
    int n, nn;

    n = d->bufp-d->buf;
    if(n <= 0)
        return 1;

    if((nn=write(d->fd, d->buf, n)) != n){
        if(_drawdebug)
            fprint(2, "flushimage fail: d=%p: n=%d nn=%d %r\n", d, n, nn); /**/
        d->bufp = d->buf;	/* might as well; chance of continuing */
        return -1;
    }
    d->bufp = d->buf;
    return 1;
}
@

\subsection{Unmarshalling}

<<[[drawmesg()]] cases>>=
/* visible: 'v' */
case 'v':
    printmesg(fmt="", a, 0);
    m = 1;
    drawflush();
    continue;

@

\subsection{Algorithm}

\chapter{Geometry}

\section{[[Point]]}

<<struct Point>>=
struct	Point
{
    int	x;
    int	y;
};
@
% int! they are pixels!

%ctor
<<function Pt>>=
Point
Pt(int x, int y)
{
    Point p;

    p.x = x;
    p.y = y;
    return p;
}
@


<<function eqpt>>=
int
eqpt(Point p, Point q)
{
    return p.x==q.x && p.y==q.y;
}
@


<<global ZP>>=
Point	ZP;
@

%dumper
<<function Pfmt>>=
int
Pfmt(Fmt *f)
{
    Point p;

    p = va_arg(f->args, Point);
    return fmtprint(f, "[%d %d]", p.x, p.y);
}
@


<<function addpt>>=
Point
addpt(Point a, Point b)
{
    a.x += b.x;
    a.y += b.y;
    return a;
}
@

<<function subpt>>=
Point
subpt(Point a, Point b)
{
    a.x -= b.x;
    a.y -= b.y;
    return a;
}
@

<<function mulpt>>=
Point
mulpt(Point a, int b)
{
    a.x *= b;
    a.y *= b;
    return a;
}
@

<<function divpt>>=
Point
divpt(Point a, int b)
{
    a.x /= b;
    a.y /= b;
    return a;
}
@


\section{Rectangle}

\subsection{[[Rectangle]]}

<<struct Rectangle>>=
struct Rectangle
{
    Point	min;
    Point	max;
};
@

%ctor
<<function Rect>>=
Rectangle
Rect(int x, int y, int bx, int by)
{
    Rectangle r;

    r.min.x = x;
    r.min.y = y;
    r.max.x = bx;
    r.max.y = by;
    return r;
}
@

%ctor
<<function Rpt>>=
Rectangle
Rpt(Point min, Point max)
{
    Rectangle r;

    r.min = min;
    r.max = max;
    return r;
}
@


%dumper
<<function Rfmt>>=
int
Rfmt(Fmt *f)
{
    Rectangle r;

    r = va_arg(f->args, Rectangle);
    return fmtprint(f, "%P %P", r.min, r.max);
}
@


<<function eqrect>>=
int
eqrect(Rectangle r, Rectangle s)
{
    return r.min.x==s.min.x && r.max.x==s.max.x &&
           r.min.y==s.min.y && r.max.y==s.max.y;
}
@


<<global ZR>>=
Rectangle ZR;
@




<<function rectaddpt>>=
Rectangle
rectaddpt(Rectangle r, Point p)
{
    r.min.x += p.x;
    r.min.y += p.y;
    r.max.x += p.x;
    r.max.y += p.y;
    return r;
}
@

<<function rectsubpt>>=
Rectangle
rectsubpt(Rectangle r, Point p)
{
    r.min.x -= p.x;
    r.min.y -= p.y;
    r.max.x -= p.x;
    r.max.y -= p.y;
    return r;
}
@



<<function insetrect>>=
Rectangle
insetrect(Rectangle r, int n)
{
    r.min.x += n;
    r.min.y += n;
    r.max.x -= n;
    r.max.y -= n;
    return r;
}
@


<<function rectXrect>>=
int
rectXrect(Rectangle r, Rectangle s)
{
    return r.min.x<s.max.x && s.min.x<r.max.x &&
           r.min.y<s.max.y && s.min.y<r.max.y;
}
@

<<function rectinrect>>=
int
rectinrect(Rectangle r, Rectangle s)
{
    return s.min.x<=r.min.x && r.max.x<=s.max.x && s.min.y<=r.min.y && r.max.y<=s.max.y;
}
@

<<function ptinrect>>=
int
ptinrect(Point p, Rectangle r)
{
    return p.x>=r.min.x && p.x<r.max.x &&
           p.y>=r.min.y && p.y<r.max.y;
}
@


<<function canonrect>>=
Rectangle
canonrect(Rectangle r)
{
    int t;
    if (r.max.x < r.min.x) {
        t = r.min.x;
        r.min.x = r.max.x;
        r.max.x = t;
    }
    if (r.max.y < r.min.y) {
        t = r.min.y;
        r.min.y = r.max.y;
        r.max.y = t;
    }
    return r;
}
@

<<function combinerect>>=
void
combinerect(Rectangle *r1, Rectangle r2)
{
    if(r1->min.x > r2.min.x)
        r1->min.x = r2.min.x;
    if(r1->min.y > r2.min.y)
        r1->min.y = r2.min.y;
    if(r1->max.x < r2.max.x)
        r1->max.x = r2.max.x;
    if(r1->max.y < r2.max.y)
        r1->max.y = r2.max.y;
}
@



\subsection{API}

%TODO: show toy program and screenshot of the rectangle!


<<function draw>>=
void
draw(Image *dst, Rectangle r, Image *src, Image *mask, Point p1)
{
    draw1(dst, &r, src, &p1, mask, &p1, SoverD);
}
@

<<function border>>=
void
border(Image *im, Rectangle r, int i, Image *color, Point sp)
{
    if(i < 0){
        r = insetrect(r, i);
        sp = addpt(sp, Pt(i,i));
        i = -i;
    }
    draw(im, Rect(r.min.x, r.min.y, r.max.x, r.min.y+i),
        color, nil, sp);
    draw(im, Rect(r.min.x, r.max.y-i, r.max.x, r.max.y),
        color, nil, Pt(sp.x, sp.y+Dy(r)-i));
    draw(im, Rect(r.min.x, r.min.y+i, r.min.x+i, r.max.y-i),
        color, nil, Pt(sp.x, sp.y+i));
    draw(im, Rect(r.max.x-i, r.min.y+i, r.max.x, r.max.y-i),
        color, nil, Pt(sp.x+Dx(r)-i, sp.y+i));
}
@



<<function drawop>>=
void
drawop(Image *dst, Rectangle r, Image *src, Image *mask, Point p1, Drawop op)
{
    draw1(dst, &r, src, &p1, mask, &p1, op);
}
@

<<function gendraw>>=
void
gendraw(Image *dst, Rectangle r, Image *src, Point p0, Image *mask, Point p1)
{
    draw1(dst, &r, src, &p0, mask, &p1, SoverD);
}
@

<<function gendrawop>>=
void
gendrawop(Image *dst, Rectangle r, Image *src, Point p0, Image *mask, Point p1, Drawop op)
{
    draw1(dst, &r, src, &p0, mask, &p1, op);
}
@






\subsection{Marshalling}

<<function draw1>>=
static void
draw1(Image *dst, Rectangle *r, Image *src, Point *p0, Image *mask, Point *p1, Drawop op)
{
    byte *a;

    _setdrawop(dst->display, op);

    a = bufimage(dst->display, 1+4+4+4+4*4+2*4+2*4);
    if(a == nil)
        return;
    if(src == nil)
        src = dst->display->black;
    if(mask == nil)
        mask = dst->display->opaque;

    a[0] = 'd';
    BPLONG(a+1, dst->id);
    BPLONG(a+5, src->id);
    BPLONG(a+9, mask->id);
    BPLONG(a+13, r->min.x);
    BPLONG(a+17, r->min.y);
    BPLONG(a+21, r->max.x);
    BPLONG(a+25, r->max.y);
    BPLONG(a+29, p0->x);
    BPLONG(a+33, p0->y);
    BPLONG(a+37, p1->x);
    BPLONG(a+41, p1->y);
}
@


<<function _setdrawop>>=
void
_setdrawop(Display *d, Drawop op)
{
    uchar *a;

    if(op != SoverD){
        a = bufimage(d, 1+1);
        if(a == 0)
            return;
        a[0] = 'O';
        a[1] = op;
    }
}
@


\subsection{Unmarshalling}


<<[[drawmesg()]] cases>>=
/* draw: 'd' dstid[4] srcid[4] maskid[4] R[4*4] P[2*4] P[2*4] */
case 'd':
    printmesg(fmt="LLLRPP", a, 0);
    m = 1+4+4+4+4*4+2*4+2*4;
    if(n < m)
        error(Eshortdraw);
    dst = drawimage(client, a+1);
    dstid = BGLONG(a+1);
    src = drawimage(client, a+5);
    mask = drawimage(client, a+9);
    drawrectangle(&r, a+13);
    drawpoint(&p, a+29);
    drawpoint(&q, a+37);
    op = drawclientop(client);

    memdraw(dst, r, src, p, mask, q, op); // the call!
    dstflush(dstid, dst, r);

    continue;

@


<<function drawclientop>>=
static int
drawclientop(Client *cl)
{
    int op;

    op = cl->op;
    cl->op = SoverD;
    return op;
}
@


<<[[drawmesg()]] cases>>=
/* set compositing operator for next draw operation: 'O' op */
case 'O':
    printmesg(fmt="b", a, 0);
    m = 1+1;
    if(n < m)
        error(Eshortdraw);
    client->op = a[1];
    continue;
@





% dead? not even mentionned in the draw(5)
% and nothing generate such a message
%<<[[drawmesg()]] cases>>=
%/* create image mask: 'm' newid[4] id[4] */
%case 'm':
%    printmesg("LL", a, 0);
%    m = 4+4;
%    if(n < m)
%        error(Eshortdraw);
%    break;
%@


\subsection{Algorithm}

\section{Line}

\subsection{API}

<<function line>>=
void
line(Image *dst, Point p0, Point p1, int end0, int end1, int radius, Image *src, Point sp)
{
    lineop(dst, p0, p1, end0, end1, radius, src, sp, SoverD);
}
@

\subsection{Marshalling}

<<function lineop>>=
void
lineop(Image *dst, Point p0, Point p1, int end0, int end1, int radius, Image *src, Point sp, Drawop op)
{
    uchar *a;

    _setdrawop(dst->display, op);

    a = bufimage(dst->display, 1+4+2*4+2*4+4+4+4+4+2*4);
    if(a == 0){
        fprint(2, "image line: %r\n");
        return;
    }
    a[0] = 'L';
    BPLONG(a+1, dst->id);
    BPLONG(a+5, p0.x);
    BPLONG(a+9, p0.y);
    BPLONG(a+13, p1.x);
    BPLONG(a+17, p1.y);
    BPLONG(a+21, end0);
    BPLONG(a+25, end1);
    BPLONG(a+29, radius);
    BPLONG(a+33, src->id);
    BPLONG(a+37, sp.x);
    BPLONG(a+41, sp.y);
}
@

\subsection{Unmarshalling}

<<[[drawmesg()]] cases>>=
/* draw line: 'L' dstid[4] p0[2*4] p1[2*4] end0[4] end1[4] radius[4] srcid[4] sp[2*4] */
case 'L':
    printmesg(fmt="LPPlllLP", a, 0);
    m = 1+4+2*4+2*4+4+4+4+4+2*4;
    if(n < m)
        error(Eshortdraw);
    dst = drawimage(client, a+1);
    dstid = BGLONG(a+1);
    drawpoint(&p, a+5);
    drawpoint(&q, a+13);
    e0 = BGLONG(a+21);
    e1 = BGLONG(a+25);
    j = BGLONG(a+29);
    if(j < 0)
        error("negative line width");
    src = drawimage(client, a+33);
    drawpoint(&sp, a+37);
    op = drawclientop(client);

    memline(dst, p, q, e0, e1, j, src, sp, op); // The call

    /* avoid memlinebbox if possible */
    if(dstid==0 || dst->layer!=nil){
        /* BUG: this is terribly inefficient: update maximal containing rect*/
        r = memlinebbox(p, q, e0, e1, j);
        dstflush(dstid, dst, insetrect(r, -(1+1+j)));
    }
    continue;

@


\subsection{Algorithm}

\section{Polyline}

\subsection{API}

<<function poly>>=
void
poly(Image *dst, Point *p, int np, int end0, int end1, int radius, Image *src, Point sp)
{
    dopoly('p', dst, p, np, end0, end1, radius, src, &sp, SoverD);
}
@

<<function polyop>>=
void
polyop(Image *dst, Point *p, int np, int end0, int end1, int radius, Image *src, Point sp, Drawop op)
{
    dopoly('p', dst, p, np, end0, end1, radius, src, &sp, op);
}
@

<<function fillpoly>>=
void
fillpoly(Image *dst, Point *p, int np, int wind, Image *src, Point sp)
{
    dopoly('P', dst, p, np, wind, 0, 0, src, &sp, SoverD);
}
@

<<function fillpolyop>>=
void
fillpolyop(Image *dst, Point *p, int np, int wind, Image *src, Point sp, Drawop op)
{
    dopoly('P', dst, p, np, wind, 0, 0, src, &sp, op);
}
@

\subsection{Marshalling}

<<function dopoly>>=
static
void
dopoly(int cmd, Image *dst, Point *pp, int np, int end0, int end1, int radius, Image *src, Point *sp, Drawop op)
{
    uchar *a, *t, *u;
    int i, ox, oy;

    if(np == 0)
        return;
    t = malloc(np*2*3);
    if(t == nil)
        return;
    u = t;
    ox = oy = 0;
    for(i=0; i<np; i++){
        u = addcoord(u, ox, pp[i].x);
        ox = pp[i].x;
        u = addcoord(u, oy, pp[i].y);
        oy = pp[i].y;
    }

    _setdrawop(dst->display, op);

    a = bufimage(dst->display, 1+4+2+4+4+4+4+2*4+(u-t));
    if(a == 0){
        free(t);
        fprint(2, "image poly: %r\n");
        return;
    }
    a[0] = cmd;
    BPLONG(a+1, dst->id);
    BPSHORT(a+5, np-1);
    BPLONG(a+7, end0);
    BPLONG(a+11, end1);
    BPLONG(a+15, radius);
    BPLONG(a+19, src->id);
    BPLONG(a+23, sp->x);
    BPLONG(a+27, sp->y);
    memmove(a+31, t, u-t);
    free(t);
}
@

% dopoly -> <>
<<function addcoord>>=
static
uchar*
addcoord(uchar *p, int oldx, int newx)
{
    int dx;

    dx = newx-oldx;
    /* does dx fit in 7 signed bits? */
    if((unsigned)(dx - -0x40) <= 0x7F)
        *p++ = dx&0x7F;
    else{
        *p++ = 0x80 | (newx&0x7F);
        *p++ = newx>>7;
        *p++ = newx>>15;
    }
    return p;
}
@

\subsection{Unmarshalling}


<<[[drawmesg()]] cases>>=
/* filled polygon: 'P' dstid[4] n[2] wind[4] ignore[2*4] srcid[4] sp[2*4] p0[2*4] dp[2*2*n] */
/* polygon: 'p' dstid[4] n[2] end0[4] end1[4] radius[4] srcid[4] sp[2*4] p0[2*4] dp[2*2*n] */
case 'p':
case 'P':
    printmesg(fmt="LslllLPP", a, 0);
    m = 1+4+2+4+4+4+4+2*4;
    if(n < m)
        error(Eshortdraw);
    dstid = BGLONG(a+1);
    dst = drawimage(client, a+1);
    ni = BGSHORT(a+5);
    if(ni < 0)
        error("negative count in polygon");
    e0 = BGLONG(a+7);
    e1 = BGLONG(a+11);
    j = 0;
    if(*a == 'p'){
        j = BGLONG(a+15);
        if(j < 0)
            error("negative polygon line width");
    }
    src = drawimage(client, a+19);
    drawpoint(&sp, a+23);
    drawpoint(&p, a+31);
    ni++;
    pp = malloc(ni*sizeof(Point));
    if(pp == nil)
        error(Enomem);
    doflush = 0;
    if(dstid==0 || (dst->layer && dst->layer->screen->image->data == screenimage->data))
        doflush = 1;    /* simplify test in loop */
    ox = oy = 0;
    esize = 0;
    u = a+m;
    for(y=0; y<ni; y++){
        q = p;
        oesize = esize;
        u = drawcoord(u, a+n, ox, &p.x);
        u = drawcoord(u, a+n, oy, &p.y);
        ox = p.x;
        oy = p.y;
        if(doflush){
            esize = j;
            if(*a == 'p'){
                if(y == 0){
                    c = memlineendsize(e0);
                    if(c > esize)
                        esize = c;
                }
                if(y == ni-1){
                    c = memlineendsize(e1);
                    if(c > esize)
                        esize = c;
                }
            }
            if(*a=='P' && e0!=1 && e0 !=~0)
                r = dst->clipr;
            else if(y > 0){
                r = Rect(q.x-oesize, q.y-oesize, q.x+oesize+1, q.y+oesize+1);
                combinerect(&r, Rect(p.x-esize, p.y-esize, p.x+esize+1, p.y+esize+1));
            }
            if(rectclip(&r, dst->clipr))        /* should perhaps be an arg to dstflush */
                dstflush(dstid, dst, r);
        }
        pp[y] = p;
    }
    if(y == 1)
        dstflush(dstid, dst, Rect(p.x-esize, p.y-esize, p.x+esize+1, p.y+esize+1));
    op = drawclientop(client);
    if(*a == 'p')
        mempoly(dst, pp, ni, e0, e1, j, src, sp, op);
    else
        memfillpoly(dst, pp, ni, e0, src, sp, op);
    free(pp);
    m = u-a;
    continue;

@

\subsection{Algorithm}

\section{Ellipse}

\subsection{API}

<<function ellipse>>=
void
ellipse(Image *dst, Point c, int a, int b, int thick, Image *src, Point sp)
{
    doellipse('e', dst, &c, a, b, thick, src, &sp, 0, 0, SoverD);
}
@

<<function ellipseop>>=
void
ellipseop(Image *dst, Point c, int a, int b, int thick, Image *src, Point sp, Drawop op)
{
    doellipse('e', dst, &c, a, b, thick, src, &sp, 0, 0, op);
}
@

<<function fillellipse>>=
void
fillellipse(Image *dst, Point c, int a, int b, Image *src, Point sp)
{
    doellipse('E', dst, &c, a, b, 0, src, &sp, 0, 0, SoverD);
}
@

<<function fillellipseop>>=
void
fillellipseop(Image *dst, Point c, int a, int b, Image *src, Point sp, Drawop op)
{
    doellipse('E', dst, &c, a, b, 0, src, &sp, 0, 0, op);
}
@


\subsection{Marshalling}

<<function doellipse>>=
static
void
doellipse(int cmd, Image *dst, Point *c, int xr, int yr, int thick, Image *src, Point *sp, int alpha, int phi, Drawop op)
{
    uchar *a;

    _setdrawop(dst->display, op);

    a = bufimage(dst->display, 1+4+4+2*4+4+4+4+2*4+2*4);
    if(a == 0){
        fprint(2, "image ellipse: %r\n");
        return;
    }
    a[0] = cmd;
    BPLONG(a+1, dst->id);
    BPLONG(a+5, src->id);
    BPLONG(a+9, c->x);
    BPLONG(a+13, c->y);
    BPLONG(a+17, xr);
    BPLONG(a+21, yr);
    BPLONG(a+25, thick);
    BPLONG(a+29, sp->x);
    BPLONG(a+33, sp->y);
    BPLONG(a+37, alpha);
    BPLONG(a+41, phi);
}
@

\subsection{Unmarshalling}


<<[[drawmesg()]] cases>>=
/* ellipse: 'e' dstid[4] srcid[4] center[2*4] a[4] b[4] thick[4] sp[2*4] alpha[4] phi[4]*/
case 'e':
case 'E':
    printmesg(fmt="LLPlllPll", a, 0);
    m = 1+4+4+2*4+4+4+4+2*4+2*4;
    if(n < m)
        error(Eshortdraw);
    dst = drawimage(client, a+1);
    dstid = BGLONG(a+1);
    src = drawimage(client, a+5);
    drawpoint(&p, a+9);
    e0 = BGLONG(a+17);
    e1 = BGLONG(a+21);
    if(e0<0 || e1<0)
        error("invalid ellipse semidiameter");
    j = BGLONG(a+25);
    if(j < 0)
        error("negative ellipse thickness");
    drawpoint(&sp, a+29);
    c = j;
    if(*a == 'E')
        c = -1;
    ox = BGLONG(a+37);
    oy = BGLONG(a+41);
    op = drawclientop(client);
    /* high bit indicates arc angles are present */

    if(ox & (1<<31)){
        if((ox & (1<<30)) == 0)
            ox &= ~(1<<31);
        memarc(dst, p, e0, e1, c, src, sp, ox, oy, op);
    }else
        memellipse(dst, p, e0, e1, c, src, sp, op);
    dstflush(dstid, dst, Rect(p.x-e0-j, p.y-e1-j, p.x+e0+j+1, p.y+e1+j+1));

    continue;
@

\subsection{Algorithm}

\section{Arc}

\subsection{API}

<<function arc>>=
void
arc(Image *dst, Point c, int a, int b, int thick, Image *src, Point sp, int alpha, int phi)
{
    alpha |= 1<<31;
    doellipse('e', dst, &c, a, b, thick, src, &sp, alpha, phi, SoverD);
}
@

<<function arcop>>=
void
arcop(Image *dst, Point c, int a, int b, int thick, Image *src, Point sp, int alpha, int phi, Drawop op)
{
    alpha |= 1<<31;
    doellipse('e', dst, &c, a, b, thick, src, &sp, alpha, phi, op);
}
@

<<function fillarc>>=
void
fillarc(Image *dst, Point c, int a, int b, Image *src, Point sp, int alpha, int phi)
{
    alpha |= 1<<31;
    doellipse('E', dst, &c, a, b, 0, src, &sp, alpha, phi, SoverD);
}
@

<<function fillarcop>>=
void
fillarcop(Image *dst, Point c, int a, int b, Image *src, Point sp, int alpha, int phi, Drawop op)
{
    alpha |= 1<<31;
    doellipse('E', dst, &c, a, b, 0, src, &sp, alpha, phi, op);
}
@

%\section{Bezier} see advanced topics

%\section{Text} see font section

\chapter{Colors}
% test code showing use of colors?

\section{[[RGB]]}

<<struct RGB>>=
struct RGB
{
    ulong	red;
    ulong	green;
    ulong	blue;
};
@

\section{Color map}

\section{Pixel depth}

\section{Alpha}

\chapter{Fonts}
% test code showing use of font? display the core font?

\section{Text}
% and rune

\subsection{API}

<<function string>>=
Point
string(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s)
{
    return _string(dst, pt, src, sp, f, s, nil, 1<<24, dst->clipr, nil, ZP, SoverD);
}
@

<<function stringop>>=
Point
stringop(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, Drawop op)
{
    return _string(dst, pt, src, sp, f, s, nil, 1<<24, dst->clipr, nil, ZP, op);
}
@

<<function stringn>>=
Point
stringn(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, int len)
{
    return _string(dst, pt, src, sp, f, s, nil, len, dst->clipr, nil, ZP, SoverD);
}
@

<<function stringnop>>=
Point
stringnop(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, int len, Drawop op)
{
    return _string(dst, pt, src, sp, f, s, nil, len, dst->clipr, nil, ZP, op);
}
@

<<function runestring>>=
Point
runestring(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r)
{
    return _string(dst, pt, src, sp, f, nil, r, 1<<24, dst->clipr, nil, ZP, SoverD);
}
@

<<function runestringop>>=
Point
runestringop(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r, Drawop op)
{
    return _string(dst, pt, src, sp, f, nil, r, 1<<24, dst->clipr, nil, ZP, op);
}
@

<<function runestringn>>=
Point
runestringn(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r, int len)
{
    return _string(dst, pt, src, sp, f, nil, r, len, dst->clipr, nil, ZP, SoverD);
}
@

<<function runestringnop>>=
Point
runestringnop(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r, int len, Drawop op)
{
    return _string(dst, pt, src, sp, f, nil, r, len, dst->clipr, nil, ZP, op);
}
@




<<function stringbg>>=
Point
stringbg(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, Image *bg, Point bgp)
{
    return _string(dst, pt, src, sp, f, s, nil, 1<<24, dst->clipr, bg, bgp, SoverD);
}
@

<<function stringbgop>>=
Point
stringbgop(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, Image *bg, Point bgp, int op)
{
    return _string(dst, pt, src, sp, f, s, nil, 1<<24, dst->clipr, bg, bgp, op);
}
@

<<function stringnbg>>=
Point
stringnbg(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, int len, Image *bg, Point bgp)
{
    return _string(dst, pt, src, sp, f, s, nil, len, dst->clipr, bg, bgp, SoverD);
}
@

<<function stringnbgop>>=
Point
stringnbgop(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, int len, Image *bg, Point bgp, int op)
{
    return _string(dst, pt, src, sp, f, s, nil, len, dst->clipr, bg, bgp, op);
}
@

<<function runestringbg>>=
Point
runestringbg(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r, Image *bg, Point bgp)
{
    return _string(dst, pt, src, sp, f, nil, r, 1<<24, dst->clipr, bg, bgp, SoverD);
}
@

<<function runestringbgop>>=
Point
runestringbgop(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r, Image *bg, Point bgp, int op)
{
    return _string(dst, pt, src, sp, f, nil, r, 1<<24, dst->clipr, bg, bgp, op);
}
@

<<function runestringnbg>>=
Point
runestringnbg(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r, int len, Image *bg, Point bgp)
{
    return _string(dst, pt, src, sp, f, nil, r, len, dst->clipr, bg, bgp, SoverD);
}
@

<<function runestringnbgop>>=
Point
runestringnbgop(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r, int len, Image *bg, Point bgp, int op)
{
    return _string(dst, pt, src, sp, f, nil, r, len, dst->clipr, bg, bgp, op);
}
@


\subsection{Marshalling}


<<function _string>>=
Point
_string(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, Rune *r, int len, Rectangle clipr, Image *bg, Point bgp, Drawop op)
{
    int m, n, wid, max;
    ushort cbuf[Max], *c, *ec;
    uchar *b;
    char *subfontname;
    char **sptr;
    Rune **rptr;
    Font *def;
    Subfont *sf;

    if(s == nil){
        s = "";
        sptr = nil;
    }else
        sptr = &s;
    if(r == nil){
        r = (Rune*) L"";
        rptr = nil;
    }else
        rptr = &r;
    sf = nil;
    while((*s || *r) && len){
        max = Max;
        if(len < max)
            max = len;
        n = cachechars(f, sptr, rptr, cbuf, max, &wid, &subfontname);
        if(n > 0){
            _setdrawop(dst->display, op);

            m = 47+2*n;
            if(bg)
                m += 4+2*4;
            b = bufimage(dst->display, m);
            if(b == 0){
                fprint(2, "string: %r\n");
                break;
            }
            if(bg)
                b[0] = 'x';
            else
                b[0] = 's';
            BPLONG(b+1, dst->id);
            BPLONG(b+5, src->id);
            BPLONG(b+9, f->cacheimage->id);
            BPLONG(b+13, pt.x);
            BPLONG(b+17, pt.y+f->ascent);
            BPLONG(b+21, clipr.min.x);
            BPLONG(b+25, clipr.min.y);
            BPLONG(b+29, clipr.max.x);
            BPLONG(b+33, clipr.max.y);
            BPLONG(b+37, sp.x);
            BPLONG(b+41, sp.y);
            BPSHORT(b+45, n);
            b += 47;
            if(bg){
                BPLONG(b, bg->id);
                BPLONG(b+4, bgp.x);
                BPLONG(b+8, bgp.y);
                b += 12;
            }
            ec = &cbuf[n];
            for(c=cbuf; c<ec; c++, b+=2)
                BPSHORT(b, *c);
            pt.x += wid;
            bgp.x += wid;
            agefont(f);
            len -= n;
        }
        if(subfontname){
            freesubfont(sf);
            if((sf=_getsubfont(f->display, subfontname)) == 0){
                def = f->display ? f->display->defaultfont : nil;
                if(def && f!=def)
                    f = def;
                else
                    break;
            }
            /* 
             * must not free sf until cachechars has found it in the cache
             * and picked up its own reference.
             */
        }
    }
    return pt;
}
@


\subsection{Unmarshalling}

<<[[drawmesg()]] cases>>=
/* string: 's' dstid[4] srcid[4] fontid[4] P[2*4] clipr[4*4] sp[2*4] ni[2] ni*(index[2]) */
/* stringbg: 'x' dstid[4] srcid[4] fontid[4] P[2*4] clipr[4*4] sp[2*4] ni[2] bgid[4] bgpt[2*4] ni*(index[2]) */
case 's':
case 'x':
    printmesg(fmt="LLLPRPs", a, 0);
    m = 1+4+4+4+2*4+4*4+2*4+2;
    if(*a == 'x')
        m += 4+2*4;
    if(n < m)
        error(Eshortdraw);

    dst = drawimage(client, a+1);
    dstid = BGLONG(a+1);
    src = drawimage(client, a+5);
    font = drawlookup(client, BGLONG(a+9), 1);
    if(font == 0)
        error(Enodrawimage);
    if(font->nfchar == 0)
        error(Enotfont);
    drawpoint(&p, a+13);
    drawrectangle(&r, a+21);
    drawpoint(&sp, a+37);
    ni = BGSHORT(a+45);
    u = a+m;
    m += ni*2;
    if(n < m)
        error(Eshortdraw);
    clipr = dst->clipr;
    dst->clipr = r;
    op = drawclientop(client);
    bg = dst;
    if(*a == 'x'){
        /* paint background */
        bg = drawimage(client, a+47);
        drawpoint(&q, a+51);
        r.min.x = p.x;
        r.min.y = p.y-font->ascent;
        r.max.x = p.x;
        r.max.y = r.min.y+Dy(font->image->r);
        j = ni;
        while(--j >= 0){
            ci = BGSHORT(u);
            if(ci<0 || ci>=font->nfchar){
                dst->clipr = clipr;
                error(Eindex);
            }
            r.max.x += font->fchar[ci].width;
            u += 2;
        }
        memdraw(dst, r, bg, q, memopaque, ZP, op);
        u -= 2*ni;
    }
    q = p;
    while(--ni >= 0){
        ci = BGSHORT(u);
        if(ci<0 || ci>=font->nfchar){
            dst->clipr = clipr;
            error(Eindex);
        }
        q = drawchar(dst, bg, q, src, &sp, font, ci, op);
        u += 2;
    }
    dst->clipr = clipr;
    p.y -= font->ascent;
    dstflush(dstid, dst, Rect(p.x, p.y, q.x, p.y+Dy(font->image->r)));
    continue;

@

\subsection{Algorithm}



\section{Fonts}

\subsection{API}

<<function fontresize>>=
/* return whether resize succeeded && f->cache is unchanged */
static int
fontresize(Font *f, int wid, int ncache, int depth)
{
    Cacheinfo *i;
    int ret;
    Image *new;
    uchar *b;
    Display *d;

    ret = 0;
    if(depth <= 0)
        depth = 1;
    if(wid <= 0)
        wid = 1;

    d = f->display;
    if(d == nil)
        goto Nodisplay;

    new = allocimage(d, Rect(0, 0, ncache*wid, f->height), CHAN1(CGrey, depth), 0, 0);
    if(new == nil){
        fprint(2, "font cache resize failed: %r\n");
        abort();
        goto Return;
    }
    flushimage(d, 0);	/* flush any pending errors */
    b = bufimage(d, 1+4+4+1);
    if(b == 0){
        freeimage(new);
        goto Return;
    }
    b[0] = 'i';
    BPLONG(b+1, new->id);
    BPLONG(b+5, ncache);
    b[9] = f->ascent;
    if(flushimage(d, 0) < 0){
        fprint(2, "resize: init failed: %r\n");
        freeimage(new);
        goto Return;
    }
    freeimage(f->cacheimage);
    f->cacheimage = new;
    Nodisplay:
    f->width = wid;
    f->maxdepth = depth;
    ret = 1;
    if(f->ncache != ncache){
        i = malloc(ncache*sizeof f->cache[0]);
        if(i != nil){
            ret = 0;
            free(f->cache);
            f->ncache = ncache;
            f->cache = i;
        }
        /* else just wipe the cache clean and things will be ok */
    }
    Return:
    memset(f->cache, 0, f->ncache*sizeof f->cache[0]);
    return ret;
}
@

<<function loadchar>>=
/* return 1 if load succeeded, 0 if failed, -1 if must retry */
int
loadchar(Font *f, Rune r, Cacheinfo *c, int h, int noflush, char **subfontname)
{
    int i, oi, wid, top, bottom;
    Rune pic;
    Fontchar *fi;
    Cachefont *cf;
    Cachesubf *subf, *of;
    uchar *b;

    pic = r;
    Again:
    for(i=0; i<f->nsub; i++){
        cf = f->sub[i];
        if(cf->min<=pic && pic<=cf->max)
            goto Found;
    }
    TryPJW:
    if(pic != PJW){
        pic = PJW;
        goto Again;
    }
    return 0;

    Found:
    /*
     * Choose exact or oldest
     */
    oi = 0;
    subf = &f->subf[0];
    for(i=0; i<f->nsubf; i++){
        if(cf == subf->cf)
            goto Found2;
        if(subf->age < f->subf[oi].age)
            oi = i;
        subf++;
    }
    subf = &f->subf[oi];

    if(subf->f){
        if(f->age-subf->age>SUBFAGE || f->nsubf>MAXSUBF){
    Toss:
            /* ancient data; toss */
            freesubfont(subf->f);
            subf->cf = nil;
            subf->f = nil;
            subf->age = 0;
        }else{				/* too recent; grow instead */
            of = f->subf;
            f->subf = malloc((f->nsubf+DSUBF)*sizeof *subf);
            if(f->subf == nil){
                f->subf = of;
                goto Toss;
            }
            memmove(f->subf, of, (f->nsubf+DSUBF)*sizeof *subf);
            memset(f->subf+f->nsubf, 0, DSUBF*sizeof *subf);
            subf = &f->subf[f->nsubf];
            f->nsubf += DSUBF;
            free(of);
        }
    }
    subf->age = 0;
    subf->cf = nil;
    subf->f = cf2subfont(cf, f);
    if(subf->f == nil){
        if(cf->subfontname == nil)
            goto TryPJW;
        *subfontname = cf->subfontname;
        return -1;
    }

    subf->cf = cf;
    if(subf->f->ascent > f->ascent && f->display){
        /* should print something? this is a mistake in the font file */
        /* must prevent c->top from going negative when loading cache */
        Image *b;
        int d, t;
        d = subf->f->ascent - f->ascent;
        b = subf->f->bits;
        draw(b, b->r, b, nil, addpt(b->r.min, Pt(0, d)));
        draw(b, Rect(b->r.min.x, b->r.max.y-d, b->r.max.x, b->r.max.y), f->display->black, nil, b->r.min);
        for(i=0; i<subf->f->n; i++){
            t = subf->f->info[i].top-d;
            if(t < 0)
                t = 0;
            subf->f->info[i].top = t;
            t = subf->f->info[i].bottom-d;
            if(t < 0)
                t = 0;
            subf->f->info[i].bottom = t;
        }
        subf->f->ascent = f->ascent;
    }

    Found2:
    subf->age = f->age;

    /* possible overflow here, but works out okay */
    pic += cf->offset;
    pic -= cf->min;
    if(pic >= subf->f->n)
        goto TryPJW;
    fi = &subf->f->info[pic];
    if(fi->width == 0)
        goto TryPJW;
    wid = (fi+1)->x - fi->x;
    if(f->width < wid || f->width == 0 || f->maxdepth < subf->f->bits->depth){
        /*
         * Flush, free, reload (easier than reformatting f->b)
         */
        if(noflush)
            return -1;
        if(f->width < wid)
            f->width = wid;
        if(f->maxdepth < subf->f->bits->depth)
            f->maxdepth = subf->f->bits->depth;
        i = fontresize(f, f->width, f->ncache, f->maxdepth);
        if(i <= 0)
            return i;
        /* c is still valid as didn't reallocate f->cache */
    }
    c->value = r;
    top = fi->top + (f->ascent-subf->f->ascent);
    bottom = fi->bottom + (f->ascent-subf->f->ascent);
    c->width = fi->width;
    c->x = h*f->width;
    c->left = fi->left;
    if(f->display == nil)
        return 1;
    flushimage(f->display, 0);	/* flush any pending errors */
    b = bufimage(f->display, 37);
    if(b == 0)
        return 0;
    b[0] = 'l';
    BPLONG(b+1, f->cacheimage->id);
    BPLONG(b+5, subf->f->bits->id);
    BPSHORT(b+9, c-f->cache);
    BPLONG(b+11, c->x);
    BPLONG(b+15, top);
    BPLONG(b+19, c->x+((fi+1)->x-fi->x));
    BPLONG(b+23, bottom);
    BPLONG(b+27, fi->x);
    BPLONG(b+31, fi->top);
    b[35] = fi->left;
    b[36] = fi->width;
    return 1;
}
@


\subsection{Marshalling}

\subsection{Unmarshalling}

<<[[drawmesg()]] cases>>=
/* initialize font: 'i' fontid[4] nchars[4] ascent[1] */
case 'i':
    printmesg(fmt="Llb", a, 1);
    m = 1+4+4+1;
    if(n < m)
        error(Eshortdraw);
    dstid = BGLONG(a+1);
    if(dstid == 0)
        error("cannot use display as font");
    font = drawlookup(client, dstid, 1);
    if(font == 0)
        error(Enodrawimage);
    if(font->image->layer)
        error("cannot use window as font");
    ni = BGLONG(a+5);
    if(ni<=0 || ni>4096)
        error("bad font size (4096 chars max)");
    free(font->fchar);  /* should we complain if non-zero? */
    font->fchar = malloc(ni*sizeof(FChar));
    if(font->fchar == 0)
        error("no memory for font");
    memset(font->fchar, 0, ni*sizeof(FChar));
    font->nfchar = ni;
    font->ascent = a[9];
    continue;

@


<<[[drawmesg()]] cases>>=
/* load character: 'l' fontid[4] srcid[4] index[2] R[4*4] P[2*4] left[1] width[1] */
case 'l':
    printmesg(fmt="LLSRPbb", a, 0);
    m = 1+4+4+2+4*4+2*4+1+1;
    if(n < m)
        error(Eshortdraw);
    font = drawlookup(client, BGLONG(a+1), 1);
    if(font == 0)
        error(Enodrawimage);
    if(font->nfchar == 0)
        error(Enotfont);
    src = drawimage(client, a+5);
    ci = BGSHORT(a+9);
    if(ci >= font->nfchar)
        error(Eindex);
    drawrectangle(&r, a+11);
    drawpoint(&p, a+27);
    memdraw(font->image, r, src, p, memopaque, p, S);
    fc = &font->fchar[ci];
    fc->minx = r.min.x;
    fc->maxx = r.max.x;
    fc->miny = r.min.y;
    fc->maxy = r.max.y;
    fc->left = a[35];
    fc->width = a[36];
    continue;

@

\subsection{Algorithm}


\section{Compressed form}

\section{Font cache}

\chapter{Composing}

\chapter{Image}

\section{Naming}

\subsection{API}

<<function nameimage>>=
int
nameimage(Image *i, char *name, int in)
{
    uchar *a;
    int n;

    n = strlen(name);
    a = bufimage(i->display, 1+4+1+1+n);
    if(a == 0)
        return 0;
    a[0] = 'N';
    BPLONG(a+1, i->id);
    a[5] = in;
    a[6] = n;
    memmove(a+7, name, n);
    if(flushimage(i->display, 0) < 0)
        return 0;
    return 1;
}
@

<<function namedimage>>=
Image*
namedimage(Display *d, char *name)
{
    uchar *a;
    char *err, buf[12*12+1];
    Image *i;
    int id, n;
    ulong chan;

    err = 0;
    i = 0;

    n = strlen(name);
    if(n >= 256){
        err = "name too long";
    Error:
        if(err)
            werrstr("namedimage: %s", err);
        else
            werrstr("namedimage: %r");
        if(i)
            free(i);
        return 0;
    }
    /* flush pending data so we don't get error allocating the image */
    flushimage(d, 0);
    a = bufimage(d, 1+4+1+n);
    if(a == 0)
        goto Error;
    d->imageid++;
    id = d->imageid;

    a[0] = 'n';
    BPLONG(a+1, id);
    a[5] = n;
    memmove(a+6, name, n);

    if(flushimage(d, 0) < 0)
        goto Error;

    if(pread(d->ctlfd, buf, sizeof buf, 0) < 12*12)
        goto Error;
    buf[12*12] = '\0';

    i = malloc(sizeof(Image));
    if(i == nil){
    Error1:
        a = bufimage(d, 1+4);
        if(a){
            a[0] = 'f';
            BPLONG(a+1, id);
            flushimage(d, 0);
        }
        goto Error;
    }
    i->display = d;
    i->id = id;
    if((chan=strtochan(buf+2*12))==0){
        werrstr("bad channel '%.12s' from devdraw", buf+2*12);
        goto Error1;
    }
    i->chan = chan;
    i->depth = chantodepth(chan);
    i->repl = atoi(buf+3*12);
    i->r.min.x = atoi(buf+4*12);
    i->r.min.y = atoi(buf+5*12);
    i->r.max.x = atoi(buf+6*12);
    i->r.max.y = atoi(buf+7*12);
    i->clipr.min.x = atoi(buf+8*12);
    i->clipr.min.y = atoi(buf+9*12);
    i->clipr.max.x = atoi(buf+10*12);
    i->clipr.max.y = atoi(buf+11*12);
    i->screen = 0;
    i->next = 0;
    return i;
}
@


\subsection{Marshalling}

\subsection{Unmarshalling}

<<[[drawmesg()]] cases>>=
/* name an image: 'N' dstid[4] in[1] j[1] name[j] */
case 'N':
    printmesg(fmt="Lbz", a, 0);
    m = 1+4+1+1;
    if(n < m)
        error(Eshortdraw);
    c = a[5];
    j = a[6];
    if(j == 0)  /* give me a non-empty name please */
        error(Eshortdraw);
    m += j;
    if(n < m)
        error(Eshortdraw);
    di = drawlookup(client, BGLONG(a+1), 0);
    if(di == 0)
        error(Enodrawimage);
    if(di->name)
        error(Enamed);
    if(c)
        drawaddname(client, di, j, (char*)a+7);
    else{
        dn = drawlookupname(j, (char*)a+7);
        if(dn == nil)
            error(Enoname);
        if(dn->dimage != di)
            error(Ewrongname);
        drawdelname(dn);
    }
    continue;

@



<<[[drawmesg()]] cases>>=
/* attach to a named image: 'n' dstid[4] j[1] name[j] */
case 'n':
    printmesg(fmt="Lz", a, 0);
    m = 1+4+1;
    if(n < m)
        error(Eshortdraw);
    j = a[5];
    if(j == 0)  /* give me a non-empty name please */
        error(Eshortdraw);
    m += j;
    if(n < m)
        error(Eshortdraw);
    dstid = BGLONG(a+1);
    if(drawlookup(client, dstid, 0))
        error(Eimageexists);
    dn = drawlookupname(j, (char*)a+6);
    if(dn == nil)
        error(Enoname);
    if(drawinstall(client, dstid, dn->dimage->image, 0) == 0)
        error(Edrawmem);
    di = drawlookup(client, dstid, 0);
    if(di == 0)
        error("draw: cannot happen");
    di->vers = dn->vers;
    di->name = smalloc(j+1);
    di->fromname = dn->dimage;
    di->fromname->ref++;
    memmove(di->name, a+6, j);
    di->name[j] = 0;
    client->infoid = dstid;
    continue;

@

\subsection{Algorithm}





\section{Clipping}

\subsection{API}

<<function replclipr>>=
void
replclipr(Image *i, int repl, Rectangle clipr)
{
    uchar *b;

    b = bufimage(i->display, 22);
    b[0] = 'c';
    BPLONG(b+1, i->id);
    repl = repl!=0;
    b[5] = repl;
    BPLONG(b+6, clipr.min.x);
    BPLONG(b+10, clipr.min.y);
    BPLONG(b+14, clipr.max.x);
    BPLONG(b+18, clipr.max.y);
    i->repl = repl;
    i->clipr = clipr;
}
@

\subsection{Marshalling}

\subsection{Unmarshalling}

<<[[drawmesg()]] cases>>=
/* set repl and clip: 'c' dstid[4] repl[1] clipR[4*4] */
case 'c':
    printmesg(fmt="LbR", a, 0);
    m = 1+4+1+4*4;
    if(n < m)
        error(Eshortdraw);
    ddst = drawlookup(client, BGLONG(a+1), 1);
    if(ddst == nil)
        error(Enodrawimage);
    if(ddst->name)
        error("cannot change repl/clipr of shared image");
    dst = ddst->image;
    if(a[5])
        dst->flags |= Frepl;
    drawrectangle(&dst->clipr, a+6);
    continue;

@

\subsection{Algorithm}


\section{Reading images}

\subsection{API}

<<function readimage>>=
Image*
readimage(Display *d, int fd, int dolock)
{
    char hdr[5*12+1];
    int dy;
    int new;
    uint l, n;
    int m, j, chunk;
    int miny, maxy;
    Rectangle r;
    int ldepth;
    ulong chan;
    uchar *tmp;
    Image *i;

    if(readn(fd, hdr, 11) != 11)
        return nil;
    if(memcmp(hdr, "compressed\n", 11) == 0)
        return creadimage(d, fd, dolock);
    if(readn(fd, hdr+11, 5*12-11) != 5*12-11)
        return nil;
    if(d)
        chunk = d->bufsize - 32;	/* a little room for header */
    else
        chunk = 8192;

    /*
     * distinguish new channel descriptor from old ldepth.
     * channel descriptors have letters as well as numbers,
     * while ldepths are a single digit formatted as %-11d.
     */
    new = 0;
    for(m=0; m<10; m++){
        if(hdr[m] != ' '){
            new = 1;
            break;
        }
    }
    if(hdr[11] != ' '){
        werrstr("readimage: bad format");
        return nil;
    }
    if(new){
        hdr[11] = '\0';
        if((chan = strtochan(hdr)) == 0){
            werrstr("readimage: bad channel string %s", hdr);
            return nil;
        }
    }else{
        ldepth = ((int)hdr[10])-'0';
        if(ldepth<0 || ldepth>3){
            werrstr("readimage: bad ldepth %d", ldepth);
            return nil;
        }
        chan = drawld2chan[ldepth];
    }

    r.min.x = atoi(hdr+1*12);
    r.min.y = atoi(hdr+2*12);
    r.max.x = atoi(hdr+3*12);
    r.max.y = atoi(hdr+4*12);
    if(r.min.x>r.max.x || r.min.y>r.max.y){
        werrstr("readimage: bad rectangle");
        return nil;
    }

    miny = r.min.y;
    maxy = r.max.y;

    l = bytesperline(r, chantodepth(chan));
    if(d){
        if(dolock)
            lockdisplay(d);
        i = allocimage(d, r, chan, 0, -1);
        if(dolock)
            unlockdisplay(d);
        if(i == nil)
            return nil;
    }else{
        i = mallocz(sizeof(Image), 1);
        if(i == nil)
            return nil;
    }

    tmp = malloc(chunk);
    if(tmp == nil)
        goto Err;
    while(maxy > miny){
        dy = maxy - miny;
        if(dy*l > chunk)
            dy = chunk/l;
        if(dy <= 0){
            werrstr("readimage: image too wide for buffer");
            goto Err;
        }
        n = dy*l;
        m = readn(fd, tmp, n);
        if(m != n){
            werrstr("readimage: read count %d not %d: %r", m, n);
   Err:
            if(dolock)
                lockdisplay(d);
   Err1:
    freeimage(i);
            if(dolock)
                unlockdisplay(d);
            free(tmp);
            return nil;
        }
        if(!new)	/* an old image: must flip all the bits */
            for(j=0; j<chunk; j++)
                tmp[j] ^= 0xFF;

        if(d){
            if(dolock)
                lockdisplay(d);
            if(loadimage(i, Rect(r.min.x, miny, r.max.x, miny+dy), tmp, chunk) <= 0)
                goto Err1;
            if(dolock)
                unlockdisplay(d);
        }
        miny += dy;
    }
    free(tmp);
    return i;
}
@




<<function unloadimage>>=
int
unloadimage(Image *i, Rectangle r, uchar *data, int ndata)
{
    int bpl, n, ntot, dy;
    uchar *a;
    Display *d;

    if(!rectinrect(r, i->r)){
        werrstr("unloadimage: bad rectangle");
        return -1;
    }
    bpl = bytesperline(r, i->depth);
    if(ndata < bpl*Dy(r)){
        werrstr("unloadimage: buffer too small");
        return -1;
    }

    d = i->display;
    flushimage(d, 0);	/* make sure subsequent flush is for us only */
    ntot = 0;
    while(r.min.y < r.max.y){
        a = bufimage(d, 1+4+4*4);
        if(a == 0){
            werrstr("unloadimage: %r");
            return -1;
        }
        dy = 8000/bpl;
        if(dy <= 0){
            werrstr("unloadimage: image too wide");
            return -1;
        }
        if(dy > Dy(r))
            dy = Dy(r);
        a[0] = 'r';
        BPLONG(a+1, i->id);
        BPLONG(a+5, r.min.x);
        BPLONG(a+9, r.min.y);
        BPLONG(a+13, r.max.x);
        BPLONG(a+17, r.min.y+dy);
        if(flushimage(d, 0) < 0)
            return -1;
        n = read(d->fd, data+ntot, ndata-ntot);
        if(n < 0)
            return n;
        ntot += n;
        r.min.y += dy;
    }
    return ntot;
}
@


\subsection{Marshalling}

\subsection{Unmarshalling}

<<[[drawmesg()]] cases>>=
/* read: 'r' id[4] R[4*4] */
case 'r':
    printmesg(fmt="LR", a, 0);
    m = 1+4+4*4;
    if(n < m)
        error(Eshortdraw);
    i = drawimage(client, a+1);
    drawrectangle(&r, a+5);
    if(!rectinrect(r, i->r))
        error(Ereadoutside);
    c = bytesperline(r, i->depth);
    c *= Dy(r);
    free(client->readdata);
    client->readdata = mallocz(c, 0);
    if(client->readdata == nil)
        error("readimage malloc failed");
    client->nreaddata = memunload(i, r, client->readdata, c);
    if(client->nreaddata < 0){
        free(client->readdata);
        client->readdata = nil;
        error("bad readimage call");
    }
    continue;

@

\subsection{Algorithm}

\section{Writing images}

%topng </dev/screen >screen.png :) = Grab



<<function writeimage>>=
int
writeimage(int fd, Image *i, int dolock)
{
    uchar *outbuf, *outp, *eout;		/* encoded data, pointer, end */
    uchar *loutp;				/* start of encoded line */
    Hlist *hash;				/* heads of hash chains of past strings */
    Hlist *chain, *hp;			/* hash chain members, pointer */
    Hlist *cp;				/* next Hlist to fall out of window */
    int h;					/* hash value */
    uchar *line, *eline;			/* input line, end pointer */
    uchar *data, *edata;			/* input buffer, end pointer */
    ulong n;				/* length of input buffer */
    ulong nb;				/* # of bytes returned by unloadimage */
    int bpl;				/* input line length */
    int offs, runlen;			/* offset, length of consumed data */
    uchar dumpbuf[NDUMP];			/* dump accumulator */
    int ndump;				/* length of dump accumulator */
    int miny, dy;				/* y values while unloading input */
    int chunk, ncblock;
    Rectangle r;
    uchar *p, *q, *s, *es, *t;
    char hdr[11+5*12+1];
    char cbuf[20];

    chunk = i->display->bufsize - 32;	/* a little room for header */
    r = i->r;
    bpl = bytesperline(r, i->depth);
    n = Dy(r)*bpl;
    data = malloc(n);
    ncblock = _compblocksize(r, i->depth);
    outbuf = malloc(ncblock);
    hash = malloc(NHASH*sizeof(Hlist));
    chain = malloc(NMEM*sizeof(Hlist));
    if(data == 0 || outbuf == 0 || hash == 0 || chain == 0){
    ErrOut:
        free(data);
        free(outbuf);
        free(hash);
        free(chain);
        return -1;
    }
    for(miny = r.min.y; miny != r.max.y; miny += dy){
        dy = r.max.y-miny;
        if(dy*bpl > chunk)
            dy = chunk/bpl;
        if(dolock)
            lockdisplay(i->display);
        nb = unloadimage(i, Rect(r.min.x, miny, r.max.x, miny+dy),
            data+(miny-r.min.y)*bpl, dy*bpl);
        if(dolock)
            unlockdisplay(i->display);
        if(nb != dy*bpl)
            goto ErrOut;
    }
    sprint(hdr, "compressed\n%11s %11d %11d %11d %11d ",
        chantostr(cbuf, i->chan), r.min.x, r.min.y, r.max.x, r.max.y);
    if(write(fd, hdr, 11+5*12) != 11+5*12)
        goto ErrOut;
    edata = data+n;
    eout = outbuf+ncblock;
    line = data;
    r.max.y = r.min.y;
    while(line != edata){
        memset(hash, 0, NHASH*sizeof(Hlist));
        memset(chain, 0, NMEM*sizeof(Hlist));
        cp = chain;
        h = 0;
        outp = outbuf;
        for(n = 0; n != NMATCH; n++)
            h = hupdate(h, line[n]);
        loutp = outbuf;
        while(line != edata){
            ndump = 0;
            eline = line+bpl;
            for(p = line; p != eline; ){
                if(eline-p < NRUN)
                    es = eline;
                else
                    es = p+NRUN;
                q = 0;
                runlen = 0;
                for(hp = hash[h].next; hp; hp = hp->next){
                    s = p + runlen;
                    if(s >= es)
                        continue;
                    t = hp->s + runlen;
                    for(; s >= p; s--)
                        if(*s != *t--)
                            goto matchloop;
                    t += runlen+2;
                    s += runlen+2;
                    for(; s < es; s++)
                        if(*s != *t++)
                            break;
                    n = s-p;
                    if(n > runlen){
                        runlen = n;
                        q = hp->s;
                        if(n == NRUN)
                            break;
                    }
            matchloop: ;
                }
                if(runlen < NMATCH){
                    if(ndump == NDUMP){
                        if(eout-outp < ndump+1)
                            goto Bfull;
                        *outp++ = ndump-1+128;
                        memmove(outp, dumpbuf, ndump);
                        outp += ndump;
                        ndump = 0;
                    }
                    dumpbuf[ndump++] = *p;
                    runlen = 1;
                }
                else{
                    if(ndump != 0){
                        if(eout-outp < ndump+1)
                            goto Bfull;
                        *outp++ = ndump-1+128;
                        memmove(outp, dumpbuf, ndump);
                        outp += ndump;
                        ndump = 0;
                    }
                    offs = p-q-1;
                    if(eout-outp < 2)
                        goto Bfull;
                    *outp++ = ((runlen-NMATCH)<<2) + (offs>>8);
                    *outp++ = offs&255;
                }
                for(q = p+runlen; p != q; p++){
                    if(cp->prev)
                        cp->prev->next = 0;
                    cp->next = hash[h].next;
                    cp->prev = &hash[h];
                    if(cp->next)
                        cp->next->prev = cp;
                    cp->prev->next = cp;
                    cp->s = p;
                    if(++cp == &chain[NMEM])
                        cp = chain;
                    if(edata-p > NMATCH)
                        h = hupdate(h, p[NMATCH]);
                }
            }
            if(ndump != 0){
                if(eout-outp < ndump+1)
                    goto Bfull;
                *outp++ = ndump-1+128;
                memmove(outp, dumpbuf, ndump);
                outp += ndump;
            }
            line = eline;
            loutp = outp;
            r.max.y++;
        }
    Bfull:
        if(loutp == outbuf)
            goto ErrOut;
        n = loutp-outbuf;
        sprint(hdr, "%11d %11ld ", r.max.y, n);
        write(fd, hdr, 2*12);
        write(fd, outbuf, n);
        r.min.y = r.max.y;
    }
    free(data);
    free(outbuf);
    free(hash);
    free(chain);
    return 0;
}
@



\chapter{Windows}

\section{[[Screen]] and [[Memscreen]]}
% and [[_screen]]

<<struct Screen>>=
struct Screen
{
    Display	*display;	/* display holding data */
    int		id;			/* id of system-held Screen */
    Image	*image;		/* unused; for reference only */
    Image	*fill;		/* color to paint behind windows */
};
@
%less: delete image field?

<<global _screen>>=
Screen	*_screen;
@
% called _screen because screen is already use (to actually an Image, hmm)


<<global screenid>>=
static int	screenid;
@


<<struct Memscreen>>=
struct Memscreen
{
    Memimage	*frontmost;	/* frontmost layer on screen */
    Memimage	*rearmost;	/* rearmost layer on screen */
    Memimage	*image;		/* upon which all layers are drawn */
    Memimage	*fill;			/* if non-zero, picture to use when repainting */
};
@

<<struct Memlayer>>=
struct Memlayer
{
    Rectangle		screenr;	/* true position of layer on screen */
    Point			delta;	/* add delta to go from image coords to screen */
    Memscreen	*screen;	/* screen this layer belongs to */
    Memimage	*front;	/* window in front of this one */
    Memimage	*rear;	/* window behind this one*/
    int		clear;	/* layer is fully visible */
    Memimage	*save;	/* save area for obscured parts */
    Refreshfn	refreshfn;		/* function to call to refresh obscured parts if save==nil */
    void		*refreshptr;	/* argument to refreshfn */
};
@


\subsection{API}

<<function allocscreen>>=
Screen*
allocscreen(Image *image, Image *fill, int public)
{
    uchar *a;
    Screen *s;
    int id, try;
    Display *d;

    d = image->display;
    if(d != fill->display){
        werrstr("allocscreen: image and fill on different displays");
        return 0;
    }
    s = malloc(sizeof(Screen));
    if(s == 0)
        return 0;
    SET(id);
    for(try=0; try<25; try++){
        /* loop until find a free id */
        a = bufimage(d, 1+4+4+4+1);
        if(a == 0){
            free(s);
            return 0;
        }
        id = ++screenid;
        a[0] = 'A';
        BPLONG(a+1, id);
        BPLONG(a+5, image->id);
        BPLONG(a+9, fill->id);
        a[13] = public;
        if(flushimage(d, 0) != -1)
            break;
    }
    s->display = d;
    s->id = id;
    s->image = image;
    assert(s->image && s->image->chan != 0);

    s->fill = fill;
    return s;
}
@

<<function freescreen>>=
int
freescreen(Screen *s)
{
    uchar *a;
    Display *d;

    if(s == 0)
        return 0;
    d = s->display;
    a = bufimage(d, 1+4);
    if(a == 0)
        return -1;
    a[0] = 'F';
    BPLONG(a+1, s->id);
    /*
     * flush(1) because screen is likely holding last reference to
     * window, and want it to disappear visually.
     */
    if(flushimage(d, 1) < 0)
        return -1;
    free(s);
    return 1;
}
@

<<function publicscreen>>=
Screen*
publicscreen(Display *d, int id, ulong chan)
{
    uchar *a;
    Screen *s;

    s = malloc(sizeof(Screen));
    if(s == 0)
        return 0;
    a = bufimage(d, 1+4+4);
    if(a == 0){
    Error:
        free(s);
        return 0;
    }
    a[0] = 'S';
    BPLONG(a+1, id);
    BPLONG(a+5, chan);
    if(flushimage(d, 0) < 0)
        goto Error;

    s->display = d;
    s->id = id;
    s->image = 0;
    s->fill = 0;
    return s;
}
@


\subsection{Marshalling}

\subsection{Unmarshalling}


<<[[drawmesg()]] cases>>=
/* allocate screen: 'A' id[4] imageid[4] fillid[4] public[1] */
case 'A':
    printmesg(fmt="LLLb", a, 1);
    m = 1+4+4+4+1;
    if(n < m)
        error(Eshortdraw);
    dstid = BGLONG(a+1);
    if(dstid == 0)
        error(Ebadarg);
    if(drawlookupdscreen(dstid))
        error(Escreenexists);
    ddst = drawlookup(client, BGLONG(a+5), 1);
    dsrc = drawlookup(client, BGLONG(a+9), 1);
    if(ddst==0 || dsrc==0)
        error(Enodrawimage);

    if(drawinstallscreen(client, 0, dstid, ddst, dsrc, a[13]) == 0)
        error(Edrawmem);
    continue;

@

<<[[drawmesg()]] cases>>=
/* free screen: 'F' id[4] */
case 'F':
    printmesg(fmt="L", a, 1);
    m = 1+4;
    if(n < m)
        error(Eshortdraw);
    drawlookupscreen(client, BGLONG(a+1), &cs);
    drawuninstallscreen(client, cs);
    continue;

@



<<[[drawmesg()]] cases>>=
/* use public screen: 'S' id[4] chan[4] */
case 'S':
    printmesg(fmt="Ll", a, 0);
    m = 1+4+4;
    if(n < m)
        error(Eshortdraw);
    dstid = BGLONG(a+1);
    if(dstid == 0)
        error(Ebadarg);
    dscrn = drawlookupdscreen(dstid);
    if(dscrn==0 || (dscrn->public==0 && dscrn->owner!=client))
        error(Enodrawscreen);
    if(dscrn->screen->image->chan != BGLONG(a+5))
        error("inconsistent chan");
    if(drawinstallscreen(client, dscrn, 0, 0, 0, 0) == 0)
        error(Edrawmem);
    continue;

@


\subsection{Algorithm}


\section{Window}

<<function allocwindow>>=
Image*
allocwindow(Screen *s, Rectangle r, int ref, ulong val)
{
    return _allocwindow(nil, s, r, ref, val);
}
@

<<function _allocwindow>>=
Image*
_allocwindow(Image *i, Screen *s, Rectangle r, int ref, ulong val)
{
    Display *d;

    d = s->display;
    i = _allocimage(i, d, r, d->screenimage->chan, 0, val, s->id, ref);
    if(i == 0)
        return 0;
    i->screen = s;
    i->next = s->display->windows;
    s->display->windows = i;
    return i;
}
@


\section{Origin}

\subsection{API}

<<function originwindow>>=
int
originwindow(Image *w, Point log, Point scr)
{
    uchar *b;
    Point delta;

    flushimage(w->display, 0);
    b = bufimage(w->display, 1+4+2*4+2*4);
    if(b == nil)
        return 0;
    b[0] = 'o';
    BPLONG(b+1, w->id);
    BPLONG(b+5, log.x);
    BPLONG(b+9, log.y);
    BPLONG(b+13, scr.x);
    BPLONG(b+17, scr.y);
    if(flushimage(w->display, 1) < 0)
        return -1;
    delta = subpt(log, w->r.min);
    w->r = rectaddpt(w->r, delta);
    w->clipr = rectaddpt(w->clipr, delta);
    return 1;
}
@

\subsection{Marshalling}

\subsection{Unmarshalling}

<<[[drawmesg()]] cases>>=
/* position window: 'o' id[4] r.min [2*4] screenr.min [2*4] */
case 'o':
    printmesg(fmt="LPP", a, 0);
    m = 1+4+2*4+2*4;
    if(n < m)
        error(Eshortdraw);
    dst = drawimage(client, a+1);
    if(dst->layer){
        drawpoint(&p, a+5);
        drawpoint(&q, a+13);
        r = dst->layer->screenr;
        ni = memlorigin(dst, p, q);
        if(ni < 0)
            error("image origin failed");
        if(ni > 0){
            addflush(r);
            addflush(dst->layer->screenr);
            ll = drawlookup(client, BGLONG(a+1), 1);
            drawrefreshscreen(ll, client);
        }
    }
    continue;
@

\subsection{Algorithm}

\section{Windows stack manipulation}
%extern int	newwindow(char*);
% but actually it returns an int that is probably similar to a fd
% and rio itself match this id to a Window structure

% window managment! topwindow(), etc.


\subsection{API}

<<function bottomwindow>>=
void
bottomwindow(Image *w)
{
    if(w->screen == 0)
        return;
    topbottom(&w, 1, 0);
}
@

<<function topwindow>>=
void
topwindow(Image *w)
{
    if(w->screen == 0)
        return;
    topbottom(&w, 1, 1);
}
@

<<function bottomnwindows>>=
void
bottomnwindows(Image **w, int n)
{
    topbottom(w, n, 0);
}
@

<<function topnwindows>>=
void
topnwindows(Image **w, int n)
{
    topbottom(w, n, 1);
}
@

\subsection{Marshalling}


<<function topbottom>>=
static
void
topbottom(Image **w, int n, int top)
{
    int i;
    uchar *b;
    Display *d;

    if(n < 0){
    Ridiculous:
        fprint(2, "top/bottom: ridiculous number of windows\n");
        return;
    }
    if(n == 0)
        return;
    if(n > (w[0]->display->bufsize-100)/4)
        goto Ridiculous;
    /*
     * this used to check that all images were on the same screen.
     * we don't know the screen associated with images we acquired
     * by name.  instead, check that all images are on the same display.
     * the display will check that they are all on the same screen.
     */
    d = w[0]->display;
    for(i=1; i<n; i++)
        if(w[i]->display != d){
            fprint(2, "top/bottom: windows not on same screen\n");
            return;
        }

    if(n==0)
        return;
    b = bufimage(d, 1+1+2+4*n);
    b[0] = 't';
    b[1] = top;
    BPSHORT(b+2, n);
    for(i=0; i<n; i++)
        BPLONG(b+4+4*i, w[i]->id);
}
@

\subsection{Unmarshalling}


<<[[drawmesg()]] cases>>=
/* top or bottom windows: 't' top[1] nw[2] n*id[4] */
case 't':
    printmesg(fmt="bsL", a, 0);
    m = 1+1+2;
    if(n < m)
        error(Eshortdraw);
    nw = BGSHORT(a+2);
    if(nw < 0)
        error(Ebadarg);
    if(nw == 0)
        continue;
    m += nw*4;
    if(n < m)
        error(Eshortdraw);
    lp = malloc(nw*sizeof(Memimage*));
    if(lp == 0)
        error(Enomem);
    if(waserror()){
        free(lp);
        nexterror();
    }
    for(j=0; j<nw; j++)
        lp[j] = drawimage(client, a+1+1+2+j*4);
    if(lp[0]->layer == 0)
        error("images are not windows");
    for(j=1; j<nw; j++)
        if(lp[j]->layer->screen != lp[0]->layer->screen)
            error("images not on same screen");
    if(a[1])
        memltofrontn(lp, nw);
    else
        memltorearn(lp, nw);
    if(lp[0]->layer->screen->image->data == screenimage->data)
        for(j=0; j<nw; j++)
            addflush(lp[j]->layer->screenr);
    ll = drawlookup(client, BGLONG(a+1+1+2), 1);
    drawrefreshscreen(ll, client);
    poperror();
    free(lp);
    continue;

@

\subsection{Algorithm}

\section{Rectangle drawing}

% mv? in Writing image section?

\subsection{API}

<<function cloadimage>>=
int
cloadimage(Image *i, Rectangle r, uchar *data, int ndata)
{
    int m, nb, miny, maxy, ncblock;
    uchar *a;

    if(!rectinrect(r, i->r)){
        werrstr("cloadimage: bad rectangle");
        return -1;
    }

    miny = r.min.y;
    m = 0;
    ncblock = _compblocksize(r, i->depth);
    while(miny != r.max.y){
        maxy = atoi((char*)data+0*12);
        nb = atoi((char*)data+1*12);
        if(maxy<=miny || r.max.y<maxy){
            werrstr("creadimage: bad maxy %d", maxy);
            return -1;
        }
        data += 2*12;
        ndata -= 2*12;
        m += 2*12;
        if(nb<=0 || ncblock<nb || nb>ndata){
            werrstr("creadimage: bad count %d", nb);
            return -1;
        }
        a = bufimage(i->display, 21+nb);
        if(a == nil)
            return -1;
        a[0] = 'Y';
        BPLONG(a+1, i->id);
        BPLONG(a+5, r.min.x);
        BPLONG(a+9, miny);
        BPLONG(a+13, r.max.x);
        BPLONG(a+17, maxy);
        memmove(a+21, data, nb);
        miny = maxy;
        data += nb;
        ndata += nb;
        m += nb;
    }
    return m;
}
@

<<function creadimage>>=
Image *
creadimage(Display *d, int fd, int dolock)
{
    char hdr[5*12+1];
    Rectangle r;
    int m, nb, miny, maxy, new, ldepth, ncblock;
    uchar *buf, *a;
    Image *i;
    ulong chan;

    if(readn(fd, hdr, 5*12) != 5*12)
        return nil;

    /*
     * distinguish new channel descriptor from old ldepth.
     * channel descriptors have letters as well as numbers,
     * while ldepths are a single digit formatted as %-11d.
     */
    new = 0;
    for(m=0; m<10; m++){
        if(hdr[m] != ' '){
            new = 1;
            break;
        }
    }
    if(hdr[11] != ' '){
        werrstr("creadimage: bad format");
        return nil;
    }
    if(new){
        hdr[11] = '\0';
        if((chan = strtochan(hdr)) == 0){
            werrstr("creadimage: bad channel string %s", hdr);
            return nil;
        }
    }else{
        ldepth = ((int)hdr[10])-'0';
        if(ldepth<0 || ldepth>3){
            werrstr("creadimage: bad ldepth %d", ldepth);
            return nil;
        }
        chan = drawld2chan[ldepth];
    }
    r.min.x=atoi(hdr+1*12);
    r.min.y=atoi(hdr+2*12);
    r.max.x=atoi(hdr+3*12);
    r.max.y=atoi(hdr+4*12);
    if(r.min.x>r.max.x || r.min.y>r.max.y){
        werrstr("creadimage: bad rectangle");
        return nil;
    }

    if(d){
        if(dolock)
            lockdisplay(d);
        i = allocimage(d, r, chan, 0, 0);
        setmalloctag(i, getcallerpc(&d));
        if(dolock)
            unlockdisplay(d);
        if(i == nil)
            return nil;
    }else{
        i = mallocz(sizeof(Image), 1);
        if(i == nil)
            return nil;
    }
    ncblock = _compblocksize(r, chantodepth(chan));
    buf = malloc(ncblock);
    if(buf == nil)
        goto Errout;
    miny = r.min.y;
    while(miny != r.max.y){
        if(readn(fd, hdr, 2*12) != 2*12){
        Errout:
            if(dolock)
                lockdisplay(d);
        Erroutlock:
            freeimage(i);
            if(dolock)
                unlockdisplay(d);
            free(buf);
            return nil;
        }
        maxy = atoi(hdr+0*12);
        nb = atoi(hdr+1*12);
        if(maxy<=miny || r.max.y<maxy){
            werrstr("creadimage: bad maxy %d", maxy);
            goto Errout;
        }
        if(nb<=0 || ncblock<nb){
            werrstr("creadimage: bad count %d", nb);
            goto Errout;
        }
        if(readn(fd, buf, nb)!=nb)
            goto Errout;
        if(d){
            if(dolock)
                lockdisplay(d);
            a = bufimage(i->display, 21+nb);
            if(a == nil)
                goto Erroutlock;
            a[0] = 'Y';
            BPLONG(a+1, i->id);
            BPLONG(a+5, r.min.x);
            BPLONG(a+9, miny);
            BPLONG(a+13, r.max.x);
            BPLONG(a+17, maxy);
            if(!new)	/* old image: flip the data bits */
                _twiddlecompressed(buf, nb);
            memmove(a+21, buf, nb);
            if(dolock)
                unlockdisplay(d);
        }
        miny = maxy;
    }
    free(buf);
    return i;
}
@


<<function loadimage>>=
int
loadimage(Image *i, Rectangle r, uchar *data, int ndata)
{
    long dy;
    int n, bpl;
    uchar *a;
    int chunk;

    chunk = i->display->bufsize - 64;

    if(!rectinrect(r, i->r)){
        werrstr("loadimage: bad rectangle");
        return -1;
    }
    bpl = bytesperline(r, i->depth);
    n = bpl*Dy(r);
    if(n > ndata){
        werrstr("loadimage: insufficient data");
        return -1;
    }
    ndata = 0;
    while(r.max.y > r.min.y){
        dy = r.max.y - r.min.y;
        if(dy*bpl > chunk)
            dy = chunk/bpl;
        if(dy <= 0){
            werrstr("loadimage: image too wide for buffer");
            return -1;
        }
        n = dy*bpl;
        a = bufimage(i->display, 21+n);
        if(a == nil){
            werrstr("bufimage failed");
            return -1;
        }
        a[0] = 'y';
        BPLONG(a+1, i->id);
        BPLONG(a+5, r.min.x);
        BPLONG(a+9, r.min.y);
        BPLONG(a+13, r.max.x);
        BPLONG(a+17, r.min.y+dy);
        memmove(a+21, data, n);
        ndata += n;
        data += n;
        r.min.y += dy;
    }
    if(flushimage(i->display, 0) < 0)
        return -1;
    return ndata;
}
@

\subsection{marshalling}

\subsection{Unmarshalling}

<<[[drawmesg()]] cases>>=
/* write: 'y' id[4] R[4*4] data[x*1] */
/* write from compressed data: 'Y' id[4] R[4*4] data[x*1] */
case 'y':
case 'Y':
    printmesg(fmt="LR", a, 0);
//  iprint("load %c\n", *a);
    m = 1+4+4*4;
    if(n < m)
        error(Eshortdraw);
    dstid = BGLONG(a+1);
    dst = drawimage(client, a+1);
    drawrectangle(&r, a+5);
    if(!rectinrect(r, dst->r))
        error(Ewriteoutside);
    y = memload(dst, r, a+m, n-m, *a=='Y');
    if(y < 0)
        error("bad writeimage call");
    dstflush(dstid, dst, r);
    m += y;
    continue;
@

\subsection{Algorithm}


\chapter{Input}

\section{Keyboard}

<<enum _anon_ (include/keyboard.h)>>=
enum {
    KF=	0xF000,	/* Rune: beginning of private Unicode space */
    Spec=	0xF800,
    /* KF|1, KF|2, ..., KF|0xC is F1, F2, ..., F12 */
    Khome=	KF|0x0D,
    Kup=	KF|0x0E,
    Kpgup=	KF|0x0F,
    Kprint=	KF|0x10,
    Kleft=	KF|0x11,
    Kright=	KF|0x12,
    Kdown=	Spec|0x00,
    Kview=	Spec|0x00,
    Kpgdown=	KF|0x13,
    Kins=	KF|0x14,
    Kend=	KF|0x18,

    Kalt=		KF|0x15,
    Kshift=	KF|0x16,
    Kctl=		KF|0x17,

    Kbs=	0x08,
    Kdel=	0x7f,
    Kesc=	0x1b,
    Keof=	0x04,
};
@


<<struct Keyboardctl>>=
struct	Keyboardctl
{
    Channel	*c;	/* chan(Rune)[20] */

    char	*file;

    fdt		consfd;		/* to cons file */
    fdt		ctlfd;		/* to ctl file */

    int		pid;		/* of slave proc */
};
@



% show also kernel interface and refer to Kernel.tex.nw

<<function initkeyboard>>=
Keyboardctl*
initkeyboard(char *file)
{
    Keyboardctl *kc;
    char *t;

    kc = mallocz(sizeof(Keyboardctl), 1);
    if(kc == nil)
        return nil;
    if(file == nil)
        file = "/dev/cons";
    kc->file = strdup(file);
    kc->consfd = open(file, ORDWR|OCEXEC);
    t = malloc(strlen(file)+16);
    if(kc->consfd<0 || t==nil){
Error1:
        free(kc);
        return nil;
    }
    sprint(t, "%sctl", file);
    kc->ctlfd = open(t, OWRITE|OCEXEC);
    if(kc->ctlfd < 0){
        fprint(2, "initkeyboard: can't open %s: %r\n", t);
Error2:
        close(kc->consfd);
        free(t);
        goto Error1;
    }
    if(ctlkeyboard(kc, "rawon") < 0){
        fprint(2, "initkeyboard: can't turn on raw mode on %s: %r\n", t);
        close(kc->ctlfd);
        goto Error2;
    }
    free(t);
    kc->c = chancreate(sizeof(Rune), 20);
    proccreate(_ioproc, kc, 4096);
    return kc;
}
@


<<function _ioproc>>=
static
void
_ioproc(void *arg)
{
    int m, n;
    char buf[20];
    Rune r;
    Keyboardctl *kc;

    kc = arg;
    threadsetname("kbdproc");
    kc->pid = getpid();
    n = 0;
    for(;;){
        while(n>0 && fullrune(buf, n)){
            m = chartorune(&r, buf);
            n -= m;
            memmove(buf, buf+m, n);
            send(kc->c, &r);
        }
        m = read(kc->consfd, buf+n, sizeof buf-n);
        if(m <= 0){
            yield();	/* if error is due to exiting, we'll exit here */
            fprint(2, "keyboard read error: %r\n");
            threadexits("error");
        }
        n += m;
    }
}
@

<<function closekeyboard>>=
void
closekeyboard(Keyboardctl *kc)
{
    if(kc == nil)
        return;

    postnote(PNPROC, kc->pid, "kill");
    close(kc->ctlfd);
    close(kc->consfd);
    free(kc->file);
    free(kc->c);
    free(kc);
}
@
%//#ifdef BUG
%//	/* Drain the channel */
%//	while(?kc->c)
%//		<-kc->c;
%//#endif



<<function ctlkeyboard>>=
int
ctlkeyboard(Keyboardctl *kc, char *m)
{
    return write(kc->ctlfd, m, strlen(m));
}
@




\section{Mouse}

% show also kernel interface and refer to Kernel.tex.nw

% same in mouse.h and event.h
<<struct Mouse (include/mouse.h)>>=
struct	Mouse
{
    int	buttons;	/* bit array: LMR=124 */
    Point	xy;
    ulong	msec;
};
@

<<struct Mousectl>>=
struct Mousectl
{
    Mouse;

    Channel	*c;			/* chan(Mouse) */
    Channel	*resizec;	/* chan(int)[2] */
    /* buffered in case client is waiting for a mouse action before handling resize */

    char	*file;

    fdt		mfd;		/* to mouse file */
    fdt		cfd;		/* to cursor file */

    int		pid;	/* of slave proc */
    Image*	image;	/* of associated window/display */
};
@
% why image? because cursor!! so need to draw on top of it!


<<function initmouse>>=
Mousectl*
initmouse(char *file, Image *i)
{
    Mousectl *mc;
    char *t, *sl;

    mc = mallocz(sizeof(Mousectl), 1);
    if(file == nil)
        file = "/dev/mouse";
    mc->file = strdup(file);
    mc->mfd = open(file, ORDWR|OCEXEC);
    if(mc->mfd<0 && strcmp(file, "/dev/mouse")==0){
        bind("#m", "/dev", MAFTER);
        mc->mfd = open(file, ORDWR|OCEXEC);
    }
    if(mc->mfd < 0){
        free(mc);
        return nil;
    }
    t = malloc(strlen(file)+16);
    if (t == nil) {
        close(mc->mfd);
        free(mc);
        return nil;
    }
    strcpy(t, file);
    sl = utfrrune(t, '/');
    if(sl)
        strcpy(sl, "/cursor");
    else
        strcpy(t, "/dev/cursor");
    mc->cfd = open(t, ORDWR|OCEXEC);
    free(t);
    mc->image = i;
    mc->c = chancreate(sizeof(Mouse), 0);
    mc->resizec = chancreate(sizeof(int), 2);
    proccreate(_ioproc, mc, 4096);
    return mc;
}
@

<<function _ioproc (lib_graphics/libdraw/mouse.c)>>=
static
void
_ioproc(void *arg)
{
    int n, nerr, one;
    char buf[1+5*12];
    Mouse m;
    Mousectl *mc;

    mc = arg;
    threadsetname("mouseproc");
    one = 1;
    memset(&m, 0, sizeof m);
    mc->pid = getpid();
    nerr = 0;
    for(;;){
        n = read(mc->mfd, buf, sizeof buf);
        if(n != 1+4*12){
            yield();	/* if error is due to exiting, we'll exit here */
            fprint(2, "mouse: bad count %d not 49: %r\n", n);
            if(n<0 || ++nerr>10)
                threadexits("read error");
            continue;
        }
        nerr = 0;
        switch(buf[0]){
        case 'r':
            send(mc->resizec, &one);
            /* fall through */
        case 'm':
            m.xy.x = atoi(buf+1+0*12);
            m.xy.y = atoi(buf+1+1*12);
            m.buttons = atoi(buf+1+2*12);
            m.msec = atoi(buf+1+3*12);
            send(mc->c, &m);
            /*
             * mc->Mouse is updated after send so it doesn't have wrong value if we block during send.
             * This means that programs should receive into mc->Mouse (see readmouse() above) if
             * they want full synchrony.
             */
            mc->Mouse = m;
            break;
        }
    }
}
@


<<function moveto>>=
void
moveto(Mousectl *m, Point pt)
{
    fprint(m->mfd, "m%d %d", pt.x, pt.y);
    m->xy = pt;
}
@

<<function closemouse>>=
void
closemouse(Mousectl *mc)
{
    if(mc == nil)
        return;

    postnote(PNPROC, mc->pid, "kill");

    do ; while(nbrecv(mc->c, &mc->Mouse) > 0);

    close(mc->mfd);
    close(mc->cfd);
    free(mc->file);
    free(mc->c);
    free(mc->resizec);
    free(mc);
}
@

<<function readmouse>>=
int
readmouse(Mousectl *mc)
{
    if(mc->image)
        flushimage(mc->image->display, 1);
    if(recv(mc->c, &mc->Mouse) < 0){
        fprint(2, "readmouse: %r\n");
        return -1;
    }
    return 0;
}
@


\section{Cursor}

<<struct Cursor>>=
struct	Cursor
{
    Point	offset;
    uchar	clr[2*16];
    uchar	set[2*16];
};
@

<<function setcursor>>=
void
setcursor(Mousectl *mc, Cursor *c)
{
    char curs[2*4+2*2*16];

    if(c == nil)
        write(mc->cfd, curs, 0);
    else{
        BPLONG(curs+0*4, c->offset.x);
        BPLONG(curs+1*4, c->offset.y);
        memmove(curs+2*4, c->clr, 2*2*16);
        write(mc->cfd, curs, sizeof curs);
    }
}
@


\section{Events}

% have lots of dupes with events, menuhit.c vs emenuhit.c?

<<enum _anon_ (include/event.h)>>=
enum
{
    Emouse	= 1,
    Ekeyboard	= 2,
};
@

% dupe
<<struct Mouse>>=
struct	Mouse
{
    int		buttons;	/* bit array: LMR=124 */
    Point	xy;
    ulong	msec;
};
@

<<struct Event>>=
struct	Event
{
    int		kbdc;
    Mouse	mouse;
    int		n;		/* number of characters in message */
    void	*v;		/* data unpacked by general event-handling function */
    uchar	data[EMAXMSG];	/* message from an arbitrary file descriptor */
};
@


\chapter{Widgets}

\section{Libpanel}
% different alloc, different event loop, 
% and the Panel main data structure



\section{Frame}
% have libframe/ but also a frame widge in libpanel

\section{Scrolling}
% have also a menu in libpanel, scrollbar

\section{Menu}
% have also a menu in libpanel, popup, pulldown

\section{Button}

\section{Label}

\section{Text entry}

\section{Completion}

\section{Slider}

\section{List}

\section{Pack}

\section{Canvas}

\section{Text view}

\section{Rich text}

\chapter{Advanced Topics}

\section{Bezier}
% spline

% no kernel support I think, it just use the previous building blocks

<<constant PINC>>=
#define	PINC	32		/* realloc granularity */
@

<<struct Plist>>=
struct Plist
{
    Point *p;
    int np;			/* -1 if malloc/realloc failed */
};
@

<<function appendpt>>=
static void
appendpt(Plist *l, Point p)
{
    if(l->np == -1)
        return;
    if(l->np == 0)
        l->p = malloc(PINC*sizeof(Point));
    else if(l->np%PINC == 0)
        l->p = realloc(l->p, (l->np+PINC)*sizeof(Point));
    if(l->p == 0){
        l->np = -1;
        return;
    }
    l->p[l->np++] = p;
}
@

<<function normsq>>=
static int
normsq(Point p)
{
    return p.x*p.x+p.y*p.y;
}
@

<<function psdist>>=
static int
psdist(Point p, Point a, Point b)
{
    int num, den;

    p = subpt(p, a);
    b = subpt(b, a);
    num = p.x*b.x + p.y*b.y;
    if(num <= 0)
        return normsq(p);
    den = normsq(b);
    if(num >= den)
        return normsq(subpt(b, p));
    return normsq(subpt(divpt(mulpt(b, num), den), p));
}
@

<<function bpts1>>=
/*
 * Convert cubic Bezier curve control points to polyline
 * vertices.  Leaves the last vertex off, so you can continue
 * with another curve.
 */
static void
bpts1(Plist *l, Point p0, Point p1, Point p2, Point p3, int scale)
{
    Point p01, p12, p23, p012, p123, p0123;
    Point tp0, tp1, tp2, tp3;
    tp0=divpt(p0, scale);
    tp1=divpt(p1, scale);
    tp2=divpt(p2, scale);
    tp3=divpt(p3, scale);
    if(psdist(tp1, tp0, tp3)<=1 && psdist(tp2, tp0, tp3)<=1){
        appendpt(l, tp0);
        appendpt(l, tp1);
        appendpt(l, tp2);
    }
    else{
        /*
         * if scale factor is getting too big for comfort,
         * rescale now & concede the rounding error
         */
        if(scale>(1<<12)){
            p0=tp0;
            p1=tp1;
            p2=tp2;
            p3=tp3;
            scale=1;
        }
        p01=addpt(p0, p1);
        p12=addpt(p1, p2);
        p23=addpt(p2, p3);
        p012=addpt(p01, p12);
        p123=addpt(p12, p23);
        p0123=addpt(p012, p123);
        bpts1(l, mulpt(p0, 8), mulpt(p01, 4), mulpt(p012, 2), p0123, scale*8);
        bpts1(l, p0123, mulpt(p123, 2), mulpt(p23, 4), mulpt(p3, 8), scale*8);
    }
}
@

<<function bpts>>=
static void
bpts(Plist *l, Point p0, Point p1, Point p2, Point p3)
{
    bpts1(l, p0, p1, p2, p3, 1);
}
@

<<function bezierpts>>=
static void
bezierpts(Plist *l, Point p0, Point p1, Point p2, Point p3)
{
    bpts(l, p0, p1, p2, p3);
    appendpt(l, p3);
}
@

<<function _bezsplinepts>>=
static void
_bezsplinepts(Plist *l, Point *pt, int npt)
{
    Point *p, *ep;
    Point a, b, c, d;
    int periodic;

    if(npt<3)
        return;
    ep = &pt[npt-3];
    periodic = eqpt(pt[0], ep[2]);
    if(periodic){
        a = divpt(addpt(ep[1], pt[0]), 2);
        b = divpt(addpt(ep[1], mulpt(pt[0], 5)), 6);
        c = divpt(addpt(mulpt(pt[0], 5), pt[1]), 6);
        d = divpt(addpt(pt[0], pt[1]), 2);
        bpts(l, a, b, c, d);
    }
    for(p=pt; p<=ep; p++){
        if(p==pt && !periodic){
            a = p[0];
            b = divpt(addpt(p[0], mulpt(p[1], 2)), 3);
        }
        else{
            a = divpt(addpt(p[0], p[1]), 2);
            b = divpt(addpt(p[0], mulpt(p[1], 5)), 6);
        }
        if(p==ep && !periodic){
            c = divpt(addpt(mulpt(p[1], 2), p[2]), 3);
            d = p[2];
        }
        else{
            c = divpt(addpt(mulpt(p[1], 5), p[2]), 6);
            d = divpt(addpt(p[1], p[2]), 2);
        }
        bpts(l, a, b, c, d);
    }
    appendpt(l, d);
}
@

<<function bezsplinepts>>=
int
bezsplinepts(Point *pt, int npt, Point **pp)
{
    Plist l;
    l.np = 0;
    l.p = nil;
    _bezsplinepts(&l, pt, npt);
    *pp  = l.p;
    return l.np;
}
@

<<function bezier>>=
int
bezier(Image *dst, Point p0, Point p1, Point p2, Point p3, int end0, int end1, int radius, Image *src, Point sp)
{
    return bezierop(dst, p0, p1, p2, p3, end0, end1, radius, src, sp, SoverD);
}
@

<<function bezierop>>=
int
bezierop(Image *dst, Point p0, Point p1, Point p2, Point p3, int end0, int end1, int radius, Image *src, Point sp, Drawop op)
{
    Plist l;

    l.np = 0;
    bezierpts(&l, p0, p1, p2, p3);
    if(l.np == -1)
        return 0;
    if(l.np != 0){
        polyop(dst, l.p, l.np, end0, end1, radius, src, addpt(subpt(sp, p0), l.p[0]), op);
        free(l.p);
    }
    return 1;
}
@

<<function bezspline>>=
int
bezspline(Image *dst, Point *pt, int npt, int end0, int end1, int radius, Image *src, Point sp)
{
    return bezsplineop(dst, pt, npt, end0, end1, radius, src, sp, SoverD);
}
@

<<function bezsplineop>>=
int
bezsplineop(Image *dst, Point *pt, int npt, int end0, int end1, int radius, Image *src, Point sp, Drawop op)
{
    Plist l;

    l.np = 0;
    _bezsplinepts(&l, pt, npt);
    if(l.np==-1)
        return 0;
    if(l.np != 0){
        polyop(dst, l.p, l.np, end0, end1, radius, src, addpt(subpt(sp, pt[0]), l.p[0]), op);
        free(l.p);
    }
    return 1;
}
@

<<function fillbezier>>=
int
fillbezier(Image *dst, Point p0, Point p1, Point p2, Point p3, int w, Image *src, Point sp)
{
    return fillbezierop(dst, p0, p1, p2, p3, w, src, sp, SoverD);
}
@

<<function fillbezierop>>=
int
fillbezierop(Image *dst, Point p0, Point p1, Point p2, Point p3, int w, Image *src, Point sp, Drawop op)
{
    Plist l;

    l.np = 0;
    bezierpts(&l, p0, p1, p2, p3);
    if(l.np == -1)
        return 0;
    if(l.np != 0){
        fillpolyop(dst, l.p, l.np, w, src, addpt(subpt(sp, p0), l.p[0]), op);
        free(l.p);
    }
    return 1;
}
@

<<function fillbezspline>>=
int
fillbezspline(Image *dst, Point *pt, int npt, int w, Image *src, Point sp)
{
    return fillbezsplineop(dst, pt, npt, w, src, sp, SoverD);
}
@

<<function fillbezsplineop>>=
int
fillbezsplineop(Image *dst, Point *pt, int npt, int w, Image *src, Point sp, Drawop op)
{
    Plist l;

    l.np = 0;
    _bezsplinepts(&l, pt, npt);
    if(l.np == -1)
        return 0;
    if(l.np > 0){
        fillpolyop(dst, l.p, l.np, w, src, addpt(subpt(sp, pt[0]), l.p[0]), op);
        free(l.p);
    }
    return 1;
}
@



\section{Menus}


\chapter{Conclusion}

\appendix

\chapter{Debugging}

% to debug drawmesg()
<<function printmesg>>=
static void
printmesg(char *fmt, uchar *a, bool plsprnt)
{
    char buf[256];
    char *p, *q;
    int s, left;

    if(1|| plsprnt==false){
        SET(s,q,p);
        USED(fmt, a, buf, p, q, s);
        return;
    }

    q = buf;
    *q++ = *a++;
    for(p=fmt; *p; p++){
        left = sizeof buf - 2 - (q - buf);  /* 2 for \n\0 */
        switch(*p){
        case 'l':
            q += snprint(q, left, " %ld", (long)BGLONG(a));
            a += 4;
            break;
        case 'L':
            q += snprint(q, left, " %.8lux", (ulong)BGLONG(a));
            a += 4;
            break;
        case 'R':
            q += snprint(q, left, " [%d %d %d %d]", BGLONG(a),
                BGLONG(a+4), BGLONG(a+8), BGLONG(a+12));
            a += 16;
            break;
        case 'P':
            q += snprint(q, left, " [%d %d]", BGLONG(a), BGLONG(a+4));
            a += 8;
            break;
        case 'b':
            q += snprint(q, left, " %d", *a++);
            break;
        case 's':
            q += snprint(q, left, " %d", BGSHORT(a));
            a += 2;
            break;
        case 'S':
            q += snprint(q, left, " %.4ux", BGSHORT(a));
            a += 2;
            break;
        }
    }
    *q++ = '\n';
    *q = 0;
    iprint("%.*s", (int)(q-buf), buf);
}
@




% libdraw
<<global _drawdebug>>=
bool	_drawdebug = 0;
@

% libmemdrawn
<<global drawdebug>>=
bool drawdebug;
@



<<global debuglockdisplay>>=
int		debuglockdisplay = 0;
@


<<function drawsetdebug>>=
void
drawsetdebug(int v)
{
    uchar *a;
    a = bufimage(display, 1+1);
    if(a == 0){
        fprint(2, "drawsetdebug: %r\n");
        return;
    }
    a[0] = 'D';
    a[1] = v;
}
@

<<[[drawmesg()]] cases>>=
/* toggle debugging: 'D' val[1] */
case 'D':
    printmesg(fmt="b", a, 0);
    m = 1+1;
    if(n < m)
        error(Eshortdraw);
    drawdebug = a[1];
    continue;
@


\chapter{Error Managment}

<<function drawerror>>=
void
drawerror(Display *d, char *s)
{
    char err[ERRMAX];

    if(d && d->error)
        d->error(d, s);
    else{
        errstr(err, sizeof err);
        fprint(2, "draw: %s: %s\n", s, err);
        exits(s);
    }
}
@


\chapter{VGA driver}

\chapter{Mathematics}

\section{Trigonometric functions}

<<global sinus>>=
/*
 * Integer sine and cosine for integral degree argument.
 * Tables computed by (sin,cos)(PI*d/180).
 */
static short sinus[91] = {
    0,	/* 0 */
    18,	/* 1 */
    36,	/* 2 */
    54,	/* 3 */
    71,	/* 4 */
    89,	/* 5 */
    107,	/* 6 */
    125,	/* 7 */
    143,	/* 8 */
    160,	/* 9 */
    178,	/* 10 */
    195,	/* 11 */
    213,	/* 12 */
    230,	/* 13 */
    248,	/* 14 */
    265,	/* 15 */
    282,	/* 16 */
    299,	/* 17 */
    316,	/* 18 */
    333,	/* 19 */
    350,	/* 20 */
    367,	/* 21 */
    384,	/* 22 */
    400,	/* 23 */
    416,	/* 24 */
    433,	/* 25 */
    449,	/* 26 */
    465,	/* 27 */
    481,	/* 28 */
    496,	/* 29 */
    512,	/* 30 */
    527,	/* 31 */
    543,	/* 32 */
    558,	/* 33 */
    573,	/* 34 */
    587,	/* 35 */
    602,	/* 36 */
    616,	/* 37 */
    630,	/* 38 */
    644,	/* 39 */
    658,	/* 40 */
    672,	/* 41 */
    685,	/* 42 */
    698,	/* 43 */
    711,	/* 44 */
    724,	/* 45 */
    737,	/* 46 */
    749,	/* 47 */
    761,	/* 48 */
    773,	/* 49 */
    784,	/* 50 */
    796,	/* 51 */
    807,	/* 52 */
    818,	/* 53 */
    828,	/* 54 */
    839,	/* 55 */
    849,	/* 56 */
    859,	/* 57 */
    868,	/* 58 */
    878,	/* 59 */
    887,	/* 60 */
    896,	/* 61 */
    904,	/* 62 */
    912,	/* 63 */
    920,	/* 64 */
    928,	/* 65 */
    935,	/* 66 */
    943,	/* 67 */
    949,	/* 68 */
    956,	/* 69 */
    962,	/* 70 */
    968,	/* 71 */
    974,	/* 72 */
    979,	/* 73 */
    984,	/* 74 */
    989,	/* 75 */
    994,	/* 76 */
    998,	/* 77 */
    1002,	/* 78 */
    1005,	/* 79 */
    1008,	/* 80 */
    1011,	/* 81 */
    1014,	/* 82 */
    1016,	/* 83 */
    1018,	/* 84 */
    1020,	/* 85 */
    1022,	/* 86 */
    1023,	/* 87 */
    1023,	/* 88 */
    1024,	/* 89 */
    1024,	/* 90 */
};
@

<<function icossin>>=
void
icossin(int deg, int *cosp, int *sinp)
{
    int sinsign, cossign;
    short *stp, *ctp;

    deg %= 360;
    if(deg < 0)
        deg += 360;
    sinsign = 1;
    cossign = 1;
    stp = 0;
    ctp = 0;
    switch(deg/90){
    case 2:
        sinsign = -1;
        cossign = -1;
        deg -= 180;
        /* fall through */
    case 0:
        stp = &sinus[deg];
        ctp = &sinus[90-deg];
        break;
    case 3:
        sinsign = -1;
        cossign = -1;
        deg -= 180;
        /* fall through */
    case 1:
        deg = 180-deg;
        cossign = -cossign;
        stp = &sinus[deg];
        ctp = &sinus[90-deg];
        break;
    }
    *sinp = sinsign*stp[0];
    *cosp = cossign*ctp[0];
}
@



<<global sinus (lib_graphics/libdraw/icossin2.c)>>=
/*
 * Sine and Cosine of arctangents, calculated by 
 *   (sin(atan(index/100.0))*1024.+0.5)
 *   (cos(atan(index/100.0))*1024.+0.5)
 * To use, get rational tangent between 0<=tan<=1, scale by 100,
 * and look up sin and cos, and use linear interpolation.  divide by 1024.
 * Maximum error is 0.0020.  Without linear interpolation, it's 0.010.
 */
static
short sinus[] = {
    0,	/* 0.00 */
    10,	/* 0.01 */
    20,	/* 0.02 */
    31,	/* 0.03 */
    41,	/* 0.04 */
    51,	/* 0.05 */
    61,	/* 0.06 */
    72,	/* 0.07 */
    82,	/* 0.08 */
    92,	/* 0.09 */
    102,	/* 0.10 */
    112,	/* 0.11 */
    122,	/* 0.12 */
    132,	/* 0.13 */
    142,	/* 0.14 */
    152,	/* 0.15 */
    162,	/* 0.16 */
    172,	/* 0.17 */
    181,	/* 0.18 */
    191,	/* 0.19 */
    201,	/* 0.20 */
    210,	/* 0.21 */
    220,	/* 0.22 */
    230,	/* 0.23 */
    239,	/* 0.24 */
    248,	/* 0.25 */
    258,	/* 0.26 */
    267,	/* 0.27 */
    276,	/* 0.28 */
    285,	/* 0.29 */
    294,	/* 0.30 */
    303,	/* 0.31 */
    312,	/* 0.32 */
    321,	/* 0.33 */
    330,	/* 0.34 */
    338,	/* 0.35 */
    347,	/* 0.36 */
    355,	/* 0.37 */
    364,	/* 0.38 */
    372,	/* 0.39 */
    380,	/* 0.40 */
    388,	/* 0.41 */
    397,	/* 0.42 */
    405,	/* 0.43 */
    412,	/* 0.44 */
    420,	/* 0.45 */
    428,	/* 0.46 */
    436,	/* 0.47 */
    443,	/* 0.48 */
    451,	/* 0.49 */
    458,	/* 0.50 */
    465,	/* 0.51 */
    472,	/* 0.52 */
    480,	/* 0.53 */
    487,	/* 0.54 */
    493,	/* 0.55 */
    500,	/* 0.56 */
    507,	/* 0.57 */
    514,	/* 0.58 */
    520,	/* 0.59 */
    527,	/* 0.60 */
    533,	/* 0.61 */
    540,	/* 0.62 */
    546,	/* 0.63 */
    552,	/* 0.64 */
    558,	/* 0.65 */
    564,	/* 0.66 */
    570,	/* 0.67 */
    576,	/* 0.68 */
    582,	/* 0.69 */
    587,	/* 0.70 */
    593,	/* 0.71 */
    598,	/* 0.72 */
    604,	/* 0.73 */
    609,	/* 0.74 */
    614,	/* 0.75 */
    620,	/* 0.76 */
    625,	/* 0.77 */
    630,	/* 0.78 */
    635,	/* 0.79 */
    640,	/* 0.80 */
    645,	/* 0.81 */
    649,	/* 0.82 */
    654,	/* 0.83 */
    659,	/* 0.84 */
    663,	/* 0.85 */
    668,	/* 0.86 */
    672,	/* 0.87 */
    676,	/* 0.88 */
    681,	/* 0.89 */
    685,	/* 0.90 */
    689,	/* 0.91 */
    693,	/* 0.92 */
    697,	/* 0.93 */
    701,	/* 0.94 */
    705,	/* 0.95 */
    709,	/* 0.96 */
    713,	/* 0.97 */
    717,	/* 0.98 */
    720,	/* 0.99 */
    724,	/* 1.00 */
    728,	/* 1.01 */
};
@

<<global cosinus>>=
static
short cosinus[] = {
    1024,	/* 0.00 */
    1024,	/* 0.01 */
    1024,	/* 0.02 */
    1024,	/* 0.03 */
    1023,	/* 0.04 */
    1023,	/* 0.05 */
    1022,	/* 0.06 */
    1022,	/* 0.07 */
    1021,	/* 0.08 */
    1020,	/* 0.09 */
    1019,	/* 0.10 */
    1018,	/* 0.11 */
    1017,	/* 0.12 */
    1015,	/* 0.13 */
    1014,	/* 0.14 */
    1013,	/* 0.15 */
    1011,	/* 0.16 */
    1010,	/* 0.17 */
    1008,	/* 0.18 */
    1006,	/* 0.19 */
    1004,	/* 0.20 */
    1002,	/* 0.21 */
    1000,	/* 0.22 */
    998,	/* 0.23 */
    996,	/* 0.24 */
    993,	/* 0.25 */
    991,	/* 0.26 */
    989,	/* 0.27 */
    986,	/* 0.28 */
    983,	/* 0.29 */
    981,	/* 0.30 */
    978,	/* 0.31 */
    975,	/* 0.32 */
    972,	/* 0.33 */
    969,	/* 0.34 */
    967,	/* 0.35 */
    963,	/* 0.36 */
    960,	/* 0.37 */
    957,	/* 0.38 */
    954,	/* 0.39 */
    951,	/* 0.40 */
    947,	/* 0.41 */
    944,	/* 0.42 */
    941,	/* 0.43 */
    937,	/* 0.44 */
    934,	/* 0.45 */
    930,	/* 0.46 */
    927,	/* 0.47 */
    923,	/* 0.48 */
    920,	/* 0.49 */
    916,	/* 0.50 */
    912,	/* 0.51 */
    909,	/* 0.52 */
    905,	/* 0.53 */
    901,	/* 0.54 */
    897,	/* 0.55 */
    893,	/* 0.56 */
    890,	/* 0.57 */
    886,	/* 0.58 */
    882,	/* 0.59 */
    878,	/* 0.60 */
    874,	/* 0.61 */
    870,	/* 0.62 */
    866,	/* 0.63 */
    862,	/* 0.64 */
    859,	/* 0.65 */
    855,	/* 0.66 */
    851,	/* 0.67 */
    847,	/* 0.68 */
    843,	/* 0.69 */
    839,	/* 0.70 */
    835,	/* 0.71 */
    831,	/* 0.72 */
    827,	/* 0.73 */
    823,	/* 0.74 */
    819,	/* 0.75 */
    815,	/* 0.76 */
    811,	/* 0.77 */
    807,	/* 0.78 */
    804,	/* 0.79 */
    800,	/* 0.80 */
    796,	/* 0.81 */
    792,	/* 0.82 */
    788,	/* 0.83 */
    784,	/* 0.84 */
    780,	/* 0.85 */
    776,	/* 0.86 */
    773,	/* 0.87 */
    769,	/* 0.88 */
    765,	/* 0.89 */
    761,	/* 0.90 */
    757,	/* 0.91 */
    754,	/* 0.92 */
    750,	/* 0.93 */
    746,	/* 0.94 */
    742,	/* 0.95 */
    739,	/* 0.96 */
    735,	/* 0.97 */
    731,	/* 0.98 */
    728,	/* 0.99 */
    724,	/* 1.00 */
    720,	/* 1.01 */
};
@

<<function icossin2>>=
void
icossin2(int x, int y, int *cosp, int *sinp)
{
    int sinsign, cossign, tan, tan10, rem;
    short *stp, *ctp;

    if(x == 0){
        if(y >= 0)
            *sinp = ICOSSCALE, *cosp = 0;
        else
            *sinp = -ICOSSCALE, *cosp = 0;
        return;
    }
    sinsign = cossign = 1;
    if(x < 0){
        cossign = -1;
        x = -x;
    }
    if(y < 0){
        sinsign = -1;
        y = -y;
    }
    if(y > x){
        tan = 1000*x/y;
        tan10 = tan/10;
        stp = &cosinus[tan10];
        ctp = &sinus[tan10];
    }else{
        tan = 1000*y/x;
        tan10 = tan/10;
        stp = &sinus[tan10];
        ctp = &cosinus[tan10];
    }
    rem = tan-(tan10*10);
    *sinp = sinsign*(stp[0]+(stp[1]-stp[0])*rem/10);
    *cosp = cossign*(ctp[0]+(ctp[1]-ctp[0])*rem/10);
}
@



\chapter{Libc}

\chapter{Extra Code}

\ifallcode
#include "Graphics_extra.tex.nw"
\fi

\chapter{Changelog}
\label{sec:changelog}

\chapter{Glossary}
\label{sec:glossary}

\begin{verbatim}
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{section}{Index}

%\chapter{References} 
\addcontentsline{toc}{section}{References}

\begin{thebibliography}{99}

\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming}, 
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb}, 
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison}, 
\url{http://padator.org/software/project-syncweb/readme.txt}

\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
