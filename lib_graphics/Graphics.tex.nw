\documentclass[twocolumn]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse
% see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things:

%thx to codemap/codegraph/scheck:
% - TODO use cg to reduce backward deps, introduce globals.c, utils.c,
%   (harder to understand non layered code)
% - TODO use scheck to remove deadcode, dead prototypes, useless export
%   or mv as forward decl
%   (harder to understand big interface files)
% - TODO use cg to reduce number of globals by moving them closer to the
%   relevant file (or even function), better cluster the code
%   (harder to understand non functional code using lots of globals)

%thx to this manual, better understand svgalib?:

%history LP-ization:
% - skeleton, mostly copy paste of Template.tex.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * TODO ctor/dtor, dumper
%    * TODO [[xxx]] other fields, [[xxx]] extra fields
% - TODO read Extra section, identify concepts, first TOC
% - TODO distribute parts of the Extra section in the main file
% - TODO understand main(), LP split main, improve TOC
% - TODO understand main functions, LP split, cluster, improve TOC
% - TODO LP split the structures, use datalog for flow to field info
% - TODO nullify, boolify, errorify, enumify,  typeify,    scheckify, plan9ify
% - TODO aspecify advanced features! remove useless features
% - TODO add figures
% - TODO add explanations


%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\iffinal
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\fi
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
%\usepackage{cleveref} %\cref
%\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}
 %\usepackage[margin=0.5in]{geometry}
 %  but eat the bottom when very low
 %\usepackage{fullpage} is deprecated 
 % => do the more manual below:
 \addtolength{\oddsidemargin}{-.850in}
 \addtolength{\evensidemargin}{-.850in}
 \addtolength{\textwidth}{1.70in}
 \addtolength{\topmargin}{-.850in}
 \addtolength{\textheight}{1.70in}
%\usepackage{minitoc}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% used for forward decl, pragmas, func decl, extern decl, stats, #ifdef,
% debugging macros

%\setcounter{tocdepth}{1}

%******************************************************************************
% Title
%******************************************************************************

\begin{document}

\title{
{\Huge 
Principia Softwarica: The Plan9 Graphics System [[/dev/draw]]
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}
}

\maketitle 
\onecolumn
\hrule
\begin{quote}
    Copyright \copyright{} 2014 Yoann Padioleau \\
    Permission is granted to copy, distribute and/or modify this document,
    except all the source code it contains, under the terms of the GNU Free
    Documentation License, Version 1.3.
\end{quote}
\hrule

%CONFIG: \dominitoc

\iffinal
\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\twocolumn
\tableofcontents
\endgroup
\else
\tableofcontents
\fi

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

\section{Motivations}

The goal of this book is to present in full details the source code of
a real graphics system.
Why? Because I think it makes you a better programmer if
you fully understand how things work under the hood.

% gonna present the one in Plan9, mostly /dev/draw, but also
% /dev/mouse, /dev/cons, etc.

Here are other candidates that were considered but ultimately discarded:
\begin{itemize}
\item mks
\item svgalib
\item X11
\end{itemize}
% nuttx has some graphic and windowing stack apparently too!


\section{Getting started}

\section{Requirements}

\section{About this document}
#include "../docs/latex/About.tex.nw"

\section{Copyright}

Most of this document is actually source code from Plan9, so
those parts are copyright by Lucent Technologies Inc.
The prose is mine and is licensed under the GNU Free Documentation
License.

\section{Acknowledgments}

I would like to acknowledge of course Plan9's authors who wrote
most of this book: Rob Pike, Ken Thompson, Dave Presotto, Phil
Winterbottom, Russ Cox, and many other people from Bell Labs.

\chapter{Overview}

\section{Graphics system principles}

\section{[[/dev/draw]] services}
%maybe show code of toy app also?
% show the different devices?

% note that can run 'colors' in console outside rio! it just
% use /dev/draw, /dev/mouse, etc!

\section{A toy graphical application}
% e.g. colors



\section{Code organization}

% libdraw, libmemdraw, libmemlayer?
%#include <draw.h>
%#include <memdraw.h>
%#include <memlayer.h>
% lofs of files have similar name in libdraw/ and libmemdraw/

% kernel part? user part?





\section{Architecture overview}

% kernel driver vs libs vs apps vs rio

% design goal was like X11 can be remote! can login on another
% machine, execute program there that actually display on your screen.
% for plan9 they just reuse 9p! network file system so /dev/draw
% can be on the network!
% but this design means it's not a framebuffer! it accepts
% drawing commands, like in X11, because can't allow to send
% all pixels each time through big write on /dev/draw over the network
% (hmm actually with high speed network maybe we could)


% part1: graphics (devvga)
%  why imagmem? why imagmem and mainmem? why not use other allocator?
%  see screen/user/notes.txt especially about the old way to get graphics on PC


\section{Initialization overview}

%\section{Trace of a mouse click}

%\section{Trace of a key press}

\section{Trace of a simple drawing operation}
% when do draw(), then where does it go? go in kernel?


%###############################################################################

\chapter{Core Data Structures}

% see draw.h big categories

% see the important globals init libdraw/init.c

\section{[[Display]] and [[display]]}

<<struct Display>>=
struct Display
{
    QLock		qlock;
    int		locking;	/*program is using lockdisplay */
    int		dirno;
    int		fd;
    int		reffd;
    int		ctlfd;
    int		imageid;
    int		local;
    void		(*error)(Display*, char*);
    char		*devdir;
    char		*windir;
    char		oldlabel[64];
    ulong		dataqid;
    Image		*white;
    Image		*black;
    Image		*opaque;
    Image		*transparent;
    Image		*image;
    uchar		*buf;
    int		bufsize;
    uchar		*bufp;
    Font		*defaultfont;
    Subfont		*defaultsubfont;
    Image		*windows;
    Image		*screenimage;
    int		_isnewdisplay;
};
@


%!!!!
<<global display>>=
Display	*display;
@

\section{[[Image]] and [[screen]]}

<<struct Image>>=
struct Image
{
    Display		*display;	/* display holding data */
    int		id;		/* id of system-held Image */
    Rectangle	r;		/* rectangle in data area, local coords */
    Rectangle 	clipr;		/* clipping region */
    int		depth;		/* number of bits per pixel */
    ulong		chan;
    int		repl;		/* flag: data replicates to tile clipr */
    Screen		*screen;	/* 0 if not a window */
    Image		*next;	/* next in list of windows */
};
@


<<global screen>>=
Image	*screen;
@

\section{[[Screen]] and [[_screen]]}

<<struct Screen>>=
struct Screen
{
    Display	*display;	/* display holding data */
    int	id;		/* id of system-held Screen */
    Image	*image;		/* unused; for reference only */
    Image	*fill;		/* color to paint behind windows */
};
@


<<global _screen>>=
Screen	*_screen;
@



\section{[[Font]] and [[font]]}

<<struct Font>>=
struct Font
{
    char		*name;
    Display		*display;
    short		height;	/* max height of image, interline spacing */
    short		ascent;	/* top of image to baseline */
    short		width;	/* widest so far; used in caching only */	
    short		nsub;	/* number of subfonts */
    ulong		age;	/* increasing counter; used for LRU */
    int		maxdepth;	/* maximum depth of all loaded subfonts */
    int		ncache;	/* size of cache */
    int		nsubf;	/* size of subfont list */
    Cacheinfo	*cache;
    Cachesubf	*subf;
    Cachefont	**sub;	/* as read from file */
    Image		*cacheimage;
};
@


<<global font>>=
Font	*font;
@

\chapter{[[initdraw()]]}

<<function initdraw>>=
errorcodeneg1
initdraw(void(*error)(Display*, char*), char *fontname , char *label)
{
    char *dev = "/dev";

    if(access("/dev/draw/new", AEXIST)<0 && bind("#i", "/dev", MAFTER)<0){
        fprint(2, "imageinit: can't bind /dev/draw: %r\n");
        return ERROR_NEG1;
    }
    return geninitdraw(dev, error, fontname, label, dev, Refnone);
}
@

% devdir and windir often equals and = /dev
<<function geninitdraw>>=
errorcodeneg1
geninitdraw(char *devdir, void(*error)(Display*, char*), char *fontname, char *label, char *windir, int ref)
{
    int fd, n;
    Subfont *df;
    char buf[128];

    display = initdisplay(devdir, windir, error);
    if(display == nil)
        return ERROR_NEG1;

    /*
     * Set up default font
     */
    df = getdefont(display);
    display->defaultsubfont = df;
    if(df == nil){
        fprint(2, "imageinit: can't open default subfont: %r\n");
    Error:
        closedisplay(display);
        display = nil;
        return -1;
    }
    if(fontname == nil){
        fd = open("/env/font", OREAD);
        if(fd >= 0){
            n = read(fd, buf, sizeof(buf));
            if(n>0 && n<sizeof buf-1){
                buf[n] = 0;
                fontname = buf;
            }
            close(fd);
        }
    }
    /*
     * Build fonts with caches==depth of screen, for speed.
     * If conversion were faster, we'd use 0 and save memory.
     */
    if(fontname == nil){
        snprint(buf, sizeof buf, "%d %d\n0 %d\t%s\n", df->height, df->ascent,
            df->n-1, deffontname);
//BUG: Need something better for this	installsubfont("*default*", df);
        font = buildfont(display, buf, deffontname);
        if(font == nil){
            fprint(2, "imageinit: can't open default font: %r\n");
            goto Error;
        }
    }else{
        font = openfont(display, fontname);	/* BUG: grey fonts */
        if(font == nil){
            fprint(2, "imageinit: can't open font %s: %r\n", fontname);
            goto Error;
        }
    }
    display->defaultfont = font;

    /*
     * Write label; ignore errors (we might not be running under rio)
     */
    if(label){
        snprint(buf, sizeof buf, "%s/label", display->windir);
        fd = open(buf, OREAD);
        if(fd >= 0){
            read(fd, display->oldlabel, (sizeof display->oldlabel)-1);
            close(fd);
            fd = create(buf, OWRITE, 0666);
            if(fd >= 0){
                write(fd, label, strlen(label));
                close(fd);
            }
        }
    }

    snprint(buf, sizeof buf, "%s/winname", display->windir);
    if(gengetwindow(display, buf, &screen, &_screen, ref) < 0)
        goto Error;

    atexit(drawshutdown);

    return 1;
}
@



<<function initdisplay>>=
Display*
initdisplay(char *dev, char *win, void(*error)(Display*, char*))
{
    char buf[128], info[NINFO+1], *t, isnew;
    int n, datafd, ctlfd, reffd;
    Display *disp;
    Dir *dir;
    Image *image;

    fmtinstall('P', Pfmt);
    fmtinstall('R', Rfmt);
    if(dev == 0)
        dev = "/dev";
    if(win == 0)
        win = "/dev";
    if(strlen(dev)>sizeof buf-25 || strlen(win)>sizeof buf-25){
        werrstr("initdisplay: directory name too long");
        return nil;
    }
    t = strdup(win);
    if(t == nil)
        return nil;

    sprint(buf, "%s/draw/new", dev);
    ctlfd = open(buf, ORDWR|OCEXEC);
    if(ctlfd < 0){
        if(bind("#i", dev, MAFTER) < 0){
    Error1:
            free(t);
            werrstr("initdisplay: %s: %r", buf);
            return 0;
        }
        ctlfd = open(buf, ORDWR|OCEXEC);
    }
    if(ctlfd < 0)
        goto Error1;
    if((n=read(ctlfd, info, sizeof info)) < 12){
    Error2:
        close(ctlfd);
        goto Error1;
    }
    if(n==NINFO+1)
        n = NINFO;
    info[n] = '\0';
    isnew = 0;
    if(n < NINFO)	/* this will do for now, we need something better here */
        isnew = 1;
    sprint(buf, "%s/draw/%d/data", dev, atoi(info+0*12));
    datafd = open(buf, ORDWR|OCEXEC);
    if(datafd < 0)
        goto Error2;
    sprint(buf, "%s/draw/%d/refresh", dev, atoi(info+0*12));
    reffd = open(buf, OREAD|OCEXEC);
    if(reffd < 0){
    Error3:
        close(datafd);
        goto Error2;
    }
    disp = mallocz(sizeof(Display), 1);
    if(disp == 0){
    Error4:
        close(reffd);
        goto Error3;
    }
    image = nil;
    if(0){
    Error5:
        free(image);
        free(disp);
        goto Error4;
    }
    if(n >= NINFO){
        image = mallocz(sizeof(Image), 1);
        if(image == nil)
            goto Error5;
        image->display = disp;
        image->id = 0;
        image->chan = strtochan(info+2*12);
        image->depth = chantodepth(image->chan);
        image->repl = atoi(info+3*12);
        image->r.min.x = atoi(info+4*12);
        image->r.min.y = atoi(info+5*12);
        image->r.max.x = atoi(info+6*12);
        image->r.max.y = atoi(info+7*12);
        image->clipr.min.x = atoi(info+8*12);
        image->clipr.min.y = atoi(info+9*12);
        image->clipr.max.x = atoi(info+10*12);
        image->clipr.max.y = atoi(info+11*12);
    }

    disp->_isnewdisplay = isnew;
    disp->bufsize = iounit(datafd);
    if(disp->bufsize <= 0)
        disp->bufsize = 8000;
    if(disp->bufsize < 512){
        werrstr("iounit %d too small", disp->bufsize);
        goto Error5;
    }
    disp->buf = malloc(disp->bufsize+5);	/* +5 for flush message */
    if(disp->buf == nil)
        goto Error5;

    disp->image = image;
    disp->dirno = atoi(info+0*12);
    disp->fd = datafd;
    disp->ctlfd = ctlfd;
    disp->reffd = reffd;
    disp->bufp = disp->buf;
    disp->error = error;
    disp->windir = t;
    disp->devdir = strdup(dev);
    qlock(&disp->qlock);
    disp->white = allocimage(disp, Rect(0, 0, 1, 1), GREY1, 1, DWhite);
    disp->black = allocimage(disp, Rect(0, 0, 1, 1), GREY1, 1, DBlack);
    if(disp->white == nil || disp->black == nil){
        free(disp->devdir);
        free(disp->white);
        free(disp->black);
        goto Error5;
    }
    disp->opaque = disp->white;
    disp->transparent = disp->black;
    dir = dirfstat(ctlfd);
    if(dir!=nil && dir->type=='i'){
        disp->local = 1;
        disp->dataqid = dir->qid.path;
    }
    if(dir!=nil && dir->qid.vers==1)	/* other way to tell */
        disp->_isnewdisplay = 1;
    free(dir);

    return disp;
}
@


\chapter{Kernel Graphics API}

\section{[[drawmesg()]]}

% the big one!!
<<function drawmesg>>=
void
drawmesg(Client *client, void *av, int n)
{
    int c, repl, m, y, dstid, scrnid, ni, ci, j, nw, e0, e1, op, ox, oy, oesize, esize, doflush;
    uchar *u, *a, refresh;
    char *fmt;
    ulong value, chan;
    Rectangle r, clipr;
    Point p, q, *pp, sp;
    Memimage *i, *bg, *dst, *src, *mask;
    Memimage *l, **lp;
    Memscreen *scrn;
    DImage *font, *ll, *di, *ddst, *dsrc;
    DName *dn;
    DScreen *dscrn;
    FChar *fc;
    Refx *refx;
    CScreen *cs;
    Refreshfn reffn;

    a = av;
    m = 0;
    fmt = nil;
    if(waserror()){
        if(fmt) printmesg(fmt, a, 1);
    /*  iprint("error: %s\n", up->errstr);  */
        nexterror();
    }
    while((n-=m) > 0){
        USED(fmt);
        a += m;
        switch(*a){
        default:
            error("bad draw command");
        /* new allocate: 'b' id[4] screenid[4] refresh[1] chan[4] repl[1] R[4*4] clipR[4*4] rrggbbaa[4] */
        case 'b':
            printmesg(fmt="LLbLbRRL", a, 0);
            m = 1+4+4+1+4+1+4*4+4*4+4;
            if(n < m)
                error(Eshortdraw);
            dstid = BGLONG(a+1);
            scrnid = BGSHORT(a+5);
            refresh = a[9];
            chan = BGLONG(a+10);
            repl = a[14];
            drawrectangle(&r, a+15);
            drawrectangle(&clipr, a+31);
            value = BGLONG(a+47);
            if(drawlookup(client, dstid, 0))
                error(Eimageexists);
            if(scrnid){
                dscrn = drawlookupscreen(client, scrnid, &cs);
                scrn = dscrn->screen;
                if(repl || chan!=scrn->image->chan)
                    error("image parameters incompatible with screen");
                reffn = nil;
                switch(refresh){
                case Refbackup:
                    break;
                case Refnone:
                    reffn = memlnorefresh;
                    break;
                case Refmesg:
                    reffn = drawrefresh;
                    break;
                default:
                    error("unknown refresh method");
                }
                l = memlalloc(scrn, r, reffn, 0, value);
                if(l == 0)
                    error(Edrawmem);
                addflush(l->layer->screenr);
                l->clipr = clipr;
                rectclip(&l->clipr, r);
                if(drawinstall(client, dstid, l, dscrn) == 0){
                    memldelete(l);
                    error(Edrawmem);
                }
                dscrn->ref++;
                if(reffn){
                    refx = nil;
                    if(reffn == drawrefresh){
                        refx = malloc(sizeof(Refx));
                        if(refx == 0){
                            drawuninstall(client, dstid);
                            error(Edrawmem);
                        }
                        refx->client = client;
                        refx->dimage = drawlookup(client, dstid, 1);
                    }
                    memlsetrefresh(l, reffn, refx);
                }
                continue;
            }
            i = allocmemimage(r, chan);
            if(i == 0)
                error(Edrawmem);
            if(repl)
                i->flags |= Frepl;
            i->clipr = clipr;
            if(!repl)
                rectclip(&i->clipr, r);
            if(drawinstall(client, dstid, i, 0) == 0){
                freememimage(i);
                error(Edrawmem);
            }
            memfillcolor(i, value);
            continue;

        /* allocate screen: 'A' id[4] imageid[4] fillid[4] public[1] */
        case 'A':
            printmesg(fmt="LLLb", a, 1);
            m = 1+4+4+4+1;
            if(n < m)
                error(Eshortdraw);
            dstid = BGLONG(a+1);
            if(dstid == 0)
                error(Ebadarg);
            if(drawlookupdscreen(dstid))
                error(Escreenexists);
            ddst = drawlookup(client, BGLONG(a+5), 1);
            dsrc = drawlookup(client, BGLONG(a+9), 1);
            if(ddst==0 || dsrc==0)
                error(Enodrawimage);
            if(drawinstallscreen(client, 0, dstid, ddst, dsrc, a[13]) == 0)
                error(Edrawmem);
            continue;

        /* set repl and clip: 'c' dstid[4] repl[1] clipR[4*4] */
        case 'c':
            printmesg(fmt="LbR", a, 0);
            m = 1+4+1+4*4;
            if(n < m)
                error(Eshortdraw);
            ddst = drawlookup(client, BGLONG(a+1), 1);
            if(ddst == nil)
                error(Enodrawimage);
            if(ddst->name)
                error("cannot change repl/clipr of shared image");
            dst = ddst->image;
            if(a[5])
                dst->flags |= Frepl;
            drawrectangle(&dst->clipr, a+6);
            continue;

        /* draw: 'd' dstid[4] srcid[4] maskid[4] R[4*4] P[2*4] P[2*4] */
        case 'd':
            printmesg(fmt="LLLRPP", a, 0);
            m = 1+4+4+4+4*4+2*4+2*4;
            if(n < m)
                error(Eshortdraw);
            dst = drawimage(client, a+1);
            dstid = BGLONG(a+1);
            src = drawimage(client, a+5);
            mask = drawimage(client, a+9);
            drawrectangle(&r, a+13);
            drawpoint(&p, a+29);
            drawpoint(&q, a+37);
            op = drawclientop(client);
            memdraw(dst, r, src, p, mask, q, op);
            dstflush(dstid, dst, r);
            continue;

        /* toggle debugging: 'D' val[1] */
        case 'D':
            printmesg(fmt="b", a, 0);
            m = 1+1;
            if(n < m)
                error(Eshortdraw);
            drawdebug = a[1];
            continue;

        /* ellipse: 'e' dstid[4] srcid[4] center[2*4] a[4] b[4] thick[4] sp[2*4] alpha[4] phi[4]*/
        case 'e':
        case 'E':
            printmesg(fmt="LLPlllPll", a, 0);
            m = 1+4+4+2*4+4+4+4+2*4+2*4;
            if(n < m)
                error(Eshortdraw);
            dst = drawimage(client, a+1);
            dstid = BGLONG(a+1);
            src = drawimage(client, a+5);
            drawpoint(&p, a+9);
            e0 = BGLONG(a+17);
            e1 = BGLONG(a+21);
            if(e0<0 || e1<0)
                error("invalid ellipse semidiameter");
            j = BGLONG(a+25);
            if(j < 0)
                error("negative ellipse thickness");
            drawpoint(&sp, a+29);
            c = j;
            if(*a == 'E')
                c = -1;
            ox = BGLONG(a+37);
            oy = BGLONG(a+41);
            op = drawclientop(client);
            /* high bit indicates arc angles are present */
            if(ox & (1<<31)){
                if((ox & (1<<30)) == 0)
                    ox &= ~(1<<31);
                memarc(dst, p, e0, e1, c, src, sp, ox, oy, op);
            }else
                memellipse(dst, p, e0, e1, c, src, sp, op);
            dstflush(dstid, dst, Rect(p.x-e0-j, p.y-e1-j, p.x+e0+j+1, p.y+e1+j+1));
            continue;

        /* free: 'f' id[4] */
        case 'f':
            printmesg(fmt="L", a, 1);
            m = 1+4;
            if(n < m)
                error(Eshortdraw);
            ll = drawlookup(client, BGLONG(a+1), 0);
            if(ll && ll->dscreen && ll->dscreen->owner != client)
                ll->dscreen->owner->refreshme = 1;
            drawuninstall(client, BGLONG(a+1));
            continue;

        /* free screen: 'F' id[4] */
        case 'F':
            printmesg(fmt="L", a, 1);
            m = 1+4;
            if(n < m)
                error(Eshortdraw);
            drawlookupscreen(client, BGLONG(a+1), &cs);
            drawuninstallscreen(client, cs);
            continue;

        /* initialize font: 'i' fontid[4] nchars[4] ascent[1] */
        case 'i':
            printmesg(fmt="Llb", a, 1);
            m = 1+4+4+1;
            if(n < m)
                error(Eshortdraw);
            dstid = BGLONG(a+1);
            if(dstid == 0)
                error("cannot use display as font");
            font = drawlookup(client, dstid, 1);
            if(font == 0)
                error(Enodrawimage);
            if(font->image->layer)
                error("cannot use window as font");
            ni = BGLONG(a+5);
            if(ni<=0 || ni>4096)
                error("bad font size (4096 chars max)");
            free(font->fchar);  /* should we complain if non-zero? */
            font->fchar = malloc(ni*sizeof(FChar));
            if(font->fchar == 0)
                error("no memory for font");
            memset(font->fchar, 0, ni*sizeof(FChar));
            font->nfchar = ni;
            font->ascent = a[9];
            continue;

        /* load character: 'l' fontid[4] srcid[4] index[2] R[4*4] P[2*4] left[1] width[1] */
        case 'l':
            printmesg(fmt="LLSRPbb", a, 0);
            m = 1+4+4+2+4*4+2*4+1+1;
            if(n < m)
                error(Eshortdraw);
            font = drawlookup(client, BGLONG(a+1), 1);
            if(font == 0)
                error(Enodrawimage);
            if(font->nfchar == 0)
                error(Enotfont);
            src = drawimage(client, a+5);
            ci = BGSHORT(a+9);
            if(ci >= font->nfchar)
                error(Eindex);
            drawrectangle(&r, a+11);
            drawpoint(&p, a+27);
            memdraw(font->image, r, src, p, memopaque, p, S);
            fc = &font->fchar[ci];
            fc->minx = r.min.x;
            fc->maxx = r.max.x;
            fc->miny = r.min.y;
            fc->maxy = r.max.y;
            fc->left = a[35];
            fc->width = a[36];
            continue;

        /* draw line: 'L' dstid[4] p0[2*4] p1[2*4] end0[4] end1[4] radius[4] srcid[4] sp[2*4] */
        case 'L':
            printmesg(fmt="LPPlllLP", a, 0);
            m = 1+4+2*4+2*4+4+4+4+4+2*4;
            if(n < m)
                error(Eshortdraw);
            dst = drawimage(client, a+1);
            dstid = BGLONG(a+1);
            drawpoint(&p, a+5);
            drawpoint(&q, a+13);
            e0 = BGLONG(a+21);
            e1 = BGLONG(a+25);
            j = BGLONG(a+29);
            if(j < 0)
                error("negative line width");
            src = drawimage(client, a+33);
            drawpoint(&sp, a+37);
            op = drawclientop(client);
            memline(dst, p, q, e0, e1, j, src, sp, op);
            /* avoid memlinebbox if possible */
            if(dstid==0 || dst->layer!=nil){
                /* BUG: this is terribly inefficient: update maximal containing rect*/
                r = memlinebbox(p, q, e0, e1, j);
                dstflush(dstid, dst, insetrect(r, -(1+1+j)));
            }
            continue;

        /* create image mask: 'm' newid[4] id[4] */
/*
 *
        case 'm':
            printmesg("LL", a, 0);
            m = 4+4;
            if(n < m)
                error(Eshortdraw);
            break;
 *
 */

        /* attach to a named image: 'n' dstid[4] j[1] name[j] */
        case 'n':
            printmesg(fmt="Lz", a, 0);
            m = 1+4+1;
            if(n < m)
                error(Eshortdraw);
            j = a[5];
            if(j == 0)  /* give me a non-empty name please */
                error(Eshortdraw);
            m += j;
            if(n < m)
                error(Eshortdraw);
            dstid = BGLONG(a+1);
            if(drawlookup(client, dstid, 0))
                error(Eimageexists);
            dn = drawlookupname(j, (char*)a+6);
            if(dn == nil)
                error(Enoname);
            if(drawinstall(client, dstid, dn->dimage->image, 0) == 0)
                error(Edrawmem);
            di = drawlookup(client, dstid, 0);
            if(di == 0)
                error("draw: cannot happen");
            di->vers = dn->vers;
            di->name = smalloc(j+1);
            di->fromname = dn->dimage;
            di->fromname->ref++;
            memmove(di->name, a+6, j);
            di->name[j] = 0;
            client->infoid = dstid;
            continue;

        /* name an image: 'N' dstid[4] in[1] j[1] name[j] */
        case 'N':
            printmesg(fmt="Lbz", a, 0);
            m = 1+4+1+1;
            if(n < m)
                error(Eshortdraw);
            c = a[5];
            j = a[6];
            if(j == 0)  /* give me a non-empty name please */
                error(Eshortdraw);
            m += j;
            if(n < m)
                error(Eshortdraw);
            di = drawlookup(client, BGLONG(a+1), 0);
            if(di == 0)
                error(Enodrawimage);
            if(di->name)
                error(Enamed);
            if(c)
                drawaddname(client, di, j, (char*)a+7);
            else{
                dn = drawlookupname(j, (char*)a+7);
                if(dn == nil)
                    error(Enoname);
                if(dn->dimage != di)
                    error(Ewrongname);
                drawdelname(dn);
            }
            continue;

        /* position window: 'o' id[4] r.min [2*4] screenr.min [2*4] */
        case 'o':
            printmesg(fmt="LPP", a, 0);
            m = 1+4+2*4+2*4;
            if(n < m)
                error(Eshortdraw);
            dst = drawimage(client, a+1);
            if(dst->layer){
                drawpoint(&p, a+5);
                drawpoint(&q, a+13);
                r = dst->layer->screenr;
                ni = memlorigin(dst, p, q);
                if(ni < 0)
                    error("image origin failed");
                if(ni > 0){
                    addflush(r);
                    addflush(dst->layer->screenr);
                    ll = drawlookup(client, BGLONG(a+1), 1);
                    drawrefreshscreen(ll, client);
                }
            }
            continue;

        /* set compositing operator for next draw operation: 'O' op */
        case 'O':
            printmesg(fmt="b", a, 0);
            m = 1+1;
            if(n < m)
                error(Eshortdraw);
            client->op = a[1];
            continue;

        /* filled polygon: 'P' dstid[4] n[2] wind[4] ignore[2*4] srcid[4] sp[2*4] p0[2*4] dp[2*2*n] */
        /* polygon: 'p' dstid[4] n[2] end0[4] end1[4] radius[4] srcid[4] sp[2*4] p0[2*4] dp[2*2*n] */
        case 'p':
        case 'P':
            printmesg(fmt="LslllLPP", a, 0);
            m = 1+4+2+4+4+4+4+2*4;
            if(n < m)
                error(Eshortdraw);
            dstid = BGLONG(a+1);
            dst = drawimage(client, a+1);
            ni = BGSHORT(a+5);
            if(ni < 0)
                error("negative count in polygon");
            e0 = BGLONG(a+7);
            e1 = BGLONG(a+11);
            j = 0;
            if(*a == 'p'){
                j = BGLONG(a+15);
                if(j < 0)
                    error("negative polygon line width");
            }
            src = drawimage(client, a+19);
            drawpoint(&sp, a+23);
            drawpoint(&p, a+31);
            ni++;
            pp = malloc(ni*sizeof(Point));
            if(pp == nil)
                error(Enomem);
            doflush = 0;
            if(dstid==0 || (dst->layer && dst->layer->screen->image->data == screenimage->data))
                doflush = 1;    /* simplify test in loop */
            ox = oy = 0;
            esize = 0;
            u = a+m;
            for(y=0; y<ni; y++){
                q = p;
                oesize = esize;
                u = drawcoord(u, a+n, ox, &p.x);
                u = drawcoord(u, a+n, oy, &p.y);
                ox = p.x;
                oy = p.y;
                if(doflush){
                    esize = j;
                    if(*a == 'p'){
                        if(y == 0){
                            c = memlineendsize(e0);
                            if(c > esize)
                                esize = c;
                        }
                        if(y == ni-1){
                            c = memlineendsize(e1);
                            if(c > esize)
                                esize = c;
                        }
                    }
                    if(*a=='P' && e0!=1 && e0 !=~0)
                        r = dst->clipr;
                    else if(y > 0){
                        r = Rect(q.x-oesize, q.y-oesize, q.x+oesize+1, q.y+oesize+1);
                        combinerect(&r, Rect(p.x-esize, p.y-esize, p.x+esize+1, p.y+esize+1));
                    }
                    if(rectclip(&r, dst->clipr))        /* should perhaps be an arg to dstflush */
                        dstflush(dstid, dst, r);
                }
                pp[y] = p;
            }
            if(y == 1)
                dstflush(dstid, dst, Rect(p.x-esize, p.y-esize, p.x+esize+1, p.y+esize+1));
            op = drawclientop(client);
            if(*a == 'p')
                mempoly(dst, pp, ni, e0, e1, j, src, sp, op);
            else
                memfillpoly(dst, pp, ni, e0, src, sp, op);
            free(pp);
            m = u-a;
            continue;

        /* read: 'r' id[4] R[4*4] */
        case 'r':
            printmesg(fmt="LR", a, 0);
            m = 1+4+4*4;
            if(n < m)
                error(Eshortdraw);
            i = drawimage(client, a+1);
            drawrectangle(&r, a+5);
            if(!rectinrect(r, i->r))
                error(Ereadoutside);
            c = bytesperline(r, i->depth);
            c *= Dy(r);
            free(client->readdata);
            client->readdata = mallocz(c, 0);
            if(client->readdata == nil)
                error("readimage malloc failed");
            client->nreaddata = memunload(i, r, client->readdata, c);
            if(client->nreaddata < 0){
                free(client->readdata);
                client->readdata = nil;
                error("bad readimage call");
            }
            continue;

        /* string: 's' dstid[4] srcid[4] fontid[4] P[2*4] clipr[4*4] sp[2*4] ni[2] ni*(index[2]) */
        /* stringbg: 'x' dstid[4] srcid[4] fontid[4] P[2*4] clipr[4*4] sp[2*4] ni[2] bgid[4] bgpt[2*4] ni*(index[2]) */
        case 's':
        case 'x':
            printmesg(fmt="LLLPRPs", a, 0);
            m = 1+4+4+4+2*4+4*4+2*4+2;
            if(*a == 'x')
                m += 4+2*4;
            if(n < m)
                error(Eshortdraw);

            dst = drawimage(client, a+1);
            dstid = BGLONG(a+1);
            src = drawimage(client, a+5);
            font = drawlookup(client, BGLONG(a+9), 1);
            if(font == 0)
                error(Enodrawimage);
            if(font->nfchar == 0)
                error(Enotfont);
            drawpoint(&p, a+13);
            drawrectangle(&r, a+21);
            drawpoint(&sp, a+37);
            ni = BGSHORT(a+45);
            u = a+m;
            m += ni*2;
            if(n < m)
                error(Eshortdraw);
            clipr = dst->clipr;
            dst->clipr = r;
            op = drawclientop(client);
            bg = dst;
            if(*a == 'x'){
                /* paint background */
                bg = drawimage(client, a+47);
                drawpoint(&q, a+51);
                r.min.x = p.x;
                r.min.y = p.y-font->ascent;
                r.max.x = p.x;
                r.max.y = r.min.y+Dy(font->image->r);
                j = ni;
                while(--j >= 0){
                    ci = BGSHORT(u);
                    if(ci<0 || ci>=font->nfchar){
                        dst->clipr = clipr;
                        error(Eindex);
                    }
                    r.max.x += font->fchar[ci].width;
                    u += 2;
                }
                memdraw(dst, r, bg, q, memopaque, ZP, op);
                u -= 2*ni;
            }
            q = p;
            while(--ni >= 0){
                ci = BGSHORT(u);
                if(ci<0 || ci>=font->nfchar){
                    dst->clipr = clipr;
                    error(Eindex);
                }
                q = drawchar(dst, bg, q, src, &sp, font, ci, op);
                u += 2;
            }
            dst->clipr = clipr;
            p.y -= font->ascent;
            dstflush(dstid, dst, Rect(p.x, p.y, q.x, p.y+Dy(font->image->r)));
            continue;

        /* use public screen: 'S' id[4] chan[4] */
        case 'S':
            printmesg(fmt="Ll", a, 0);
            m = 1+4+4;
            if(n < m)
                error(Eshortdraw);
            dstid = BGLONG(a+1);
            if(dstid == 0)
                error(Ebadarg);
            dscrn = drawlookupdscreen(dstid);
            if(dscrn==0 || (dscrn->public==0 && dscrn->owner!=client))
                error(Enodrawscreen);
            if(dscrn->screen->image->chan != BGLONG(a+5))
                error("inconsistent chan");
            if(drawinstallscreen(client, dscrn, 0, 0, 0, 0) == 0)
                error(Edrawmem);
            continue;

        /* top or bottom windows: 't' top[1] nw[2] n*id[4] */
        case 't':
            printmesg(fmt="bsL", a, 0);
            m = 1+1+2;
            if(n < m)
                error(Eshortdraw);
            nw = BGSHORT(a+2);
            if(nw < 0)
                error(Ebadarg);
            if(nw == 0)
                continue;
            m += nw*4;
            if(n < m)
                error(Eshortdraw);
            lp = malloc(nw*sizeof(Memimage*));
            if(lp == 0)
                error(Enomem);
            if(waserror()){
                free(lp);
                nexterror();
            }
            for(j=0; j<nw; j++)
                lp[j] = drawimage(client, a+1+1+2+j*4);
            if(lp[0]->layer == 0)
                error("images are not windows");
            for(j=1; j<nw; j++)
                if(lp[j]->layer->screen != lp[0]->layer->screen)
                    error("images not on same screen");
            if(a[1])
                memltofrontn(lp, nw);
            else
                memltorearn(lp, nw);
            if(lp[0]->layer->screen->image->data == screenimage->data)
                for(j=0; j<nw; j++)
                    addflush(lp[j]->layer->screenr);
            ll = drawlookup(client, BGLONG(a+1+1+2), 1);
            drawrefreshscreen(ll, client);
            poperror();
            free(lp);
            continue;

        /* visible: 'v' */
        case 'v':
            printmesg(fmt="", a, 0);
            m = 1;
            drawflush();
            continue;

        /* write: 'y' id[4] R[4*4] data[x*1] */
        /* write from compressed data: 'Y' id[4] R[4*4] data[x*1] */
        case 'y':
        case 'Y':
            printmesg(fmt="LR", a, 0);
        //  iprint("load %c\n", *a);
            m = 1+4+4*4;
            if(n < m)
                error(Eshortdraw);
            dstid = BGLONG(a+1);
            dst = drawimage(client, a+1);
            drawrectangle(&r, a+5);
            if(!rectinrect(r, dst->r))
                error(Ewriteoutside);
            y = memload(dst, r, a+m, n-m, *a=='Y');
            if(y < 0)
                error("bad writeimage call");
            dstflush(dstid, dst, r);
            m += y;
            continue;
        }
    }
    poperror();
}
@


\chapter{Geometry}

\section{[[Point]]}

<<struct Point>>=
struct	Point
{
    int	x;
    int	y;
};
@

<<function Pt>>=
Point
Pt(int x, int y)
{
    Point p;

    p.x = x;
    p.y = y;
    return p;
}
@


<<function eqpt>>=
int
eqpt(Point p, Point q)
{
    return p.x==q.x && p.y==q.y;
}
@


<<global ZP>>=
Point	ZP;
@


<<function Pfmt>>=
int
Pfmt(Fmt *f)
{
    Point p;

    p = va_arg(f->args, Point);
    return fmtprint(f, "[%d %d]", p.x, p.y);
}
@


<<function addpt>>=
Point
addpt(Point a, Point b)
{
    a.x += b.x;
    a.y += b.y;
    return a;
}
@

<<function subpt>>=
Point
subpt(Point a, Point b)
{
    a.x -= b.x;
    a.y -= b.y;
    return a;
}
@

<<function divpt>>=
Point
divpt(Point a, int b)
{
    a.x /= b;
    a.y /= b;
    return a;
}
@

<<function mulpt>>=
Point
mulpt(Point a, int b)
{
    a.x *= b;
    a.y *= b;
    return a;
}
@

\section{[[Rectangle]]}

<<struct Rectangle>>=
struct Rectangle
{
    Point	min;
    Point	max;
};
@

<<function Rect>>=
Rectangle
Rect(int x, int y, int bx, int by)
{
    Rectangle r;

    r.min.x = x;
    r.min.y = y;
    r.max.x = bx;
    r.max.y = by;
    return r;
}
@

<<function Rpt>>=
Rectangle
Rpt(Point min, Point max)
{
    Rectangle r;

    r.min = min;
    r.max = max;
    return r;
}
@


<<function Rfmt>>=
int
Rfmt(Fmt *f)
{
    Rectangle r;

    r = va_arg(f->args, Rectangle);
    return fmtprint(f, "%P %P", r.min, r.max);
}
@


<<function eqrect>>=
int
eqrect(Rectangle r, Rectangle s)
{
    return r.min.x==s.min.x && r.max.x==s.max.x &&
           r.min.y==s.min.y && r.max.y==s.max.y;
}
@


<<global ZR>>=
Rectangle ZR;
@




<<function insetrect>>=
Rectangle
insetrect(Rectangle r, int n)
{
    r.min.x += n;
    r.min.y += n;
    r.max.x -= n;
    r.max.y -= n;
    return r;
}
@

<<function rectsubpt>>=
Rectangle
rectsubpt(Rectangle r, Point p)
{
    r.min.x -= p.x;
    r.min.y -= p.y;
    r.max.x -= p.x;
    r.max.y -= p.y;
    return r;
}
@

<<function rectaddpt>>=
Rectangle
rectaddpt(Rectangle r, Point p)
{
    r.min.x += p.x;
    r.min.y += p.y;
    r.max.x += p.x;
    r.max.y += p.y;
    return r;
}
@


<<function rectXrect>>=
int
rectXrect(Rectangle r, Rectangle s)
{
    return r.min.x<s.max.x && s.min.x<r.max.x &&
           r.min.y<s.max.y && s.min.y<r.max.y;
}
@

<<function rectinrect>>=
int
rectinrect(Rectangle r, Rectangle s)
{
    return s.min.x<=r.min.x && r.max.x<=s.max.x && s.min.y<=r.min.y && r.max.y<=s.max.y;
}
@

<<function ptinrect>>=
int
ptinrect(Point p, Rectangle r)
{
    return p.x>=r.min.x && p.x<r.max.x &&
           p.y>=r.min.y && p.y<r.max.y;
}
@


<<function canonrect>>=
Rectangle
canonrect(Rectangle r)
{
    int t;
    if (r.max.x < r.min.x) {
        t = r.min.x;
        r.min.x = r.max.x;
        r.max.x = t;
    }
    if (r.max.y < r.min.y) {
        t = r.min.y;
        r.min.y = r.max.y;
        r.max.y = t;
    }
    return r;
}
@

<<function combinerect>>=
void
combinerect(Rectangle *r1, Rectangle r2)
{
    if(r1->min.x > r2.min.x)
        r1->min.x = r2.min.x;
    if(r1->min.y > r2.min.y)
        r1->min.y = r2.min.y;
    if(r1->max.x < r2.max.x)
        r1->max.x = r2.max.x;
    if(r1->max.y < r2.max.y)
        r1->max.y = r2.max.y;
}
@



\section{Line}

<<function line>>=
void
line(Image *dst, Point p0, Point p1, int end0, int end1, int radius, Image *src, Point sp)
{
    lineop(dst, p0, p1, end0, end1, radius, src, sp, SoverD);
}
@

<<function lineop>>=
void
lineop(Image *dst, Point p0, Point p1, int end0, int end1, int radius, Image *src, Point sp, Drawop op)
{
    uchar *a;

    _setdrawop(dst->display, op);

    a = bufimage(dst->display, 1+4+2*4+2*4+4+4+4+4+2*4);
    if(a == 0){
        fprint(2, "image line: %r\n");
        return;
    }
    a[0] = 'L';
    BPLONG(a+1, dst->id);
    BPLONG(a+5, p0.x);
    BPLONG(a+9, p0.y);
    BPLONG(a+13, p1.x);
    BPLONG(a+17, p1.y);
    BPLONG(a+21, end0);
    BPLONG(a+25, end1);
    BPLONG(a+29, radius);
    BPLONG(a+33, src->id);
    BPLONG(a+37, sp.x);
    BPLONG(a+41, sp.y);
}
@


\section{Polyline}

<<function poly>>=
void
poly(Image *dst, Point *p, int np, int end0, int end1, int radius, Image *src, Point sp)
{
    dopoly('p', dst, p, np, end0, end1, radius, src, &sp, SoverD);
}
@

<<function polyop>>=
void
polyop(Image *dst, Point *p, int np, int end0, int end1, int radius, Image *src, Point sp, Drawop op)
{
    dopoly('p', dst, p, np, end0, end1, radius, src, &sp, op);
}
@

<<function fillpoly>>=
void
fillpoly(Image *dst, Point *p, int np, int wind, Image *src, Point sp)
{
    dopoly('P', dst, p, np, wind, 0, 0, src, &sp, SoverD);
}
@

<<function fillpolyop>>=
void
fillpolyop(Image *dst, Point *p, int np, int wind, Image *src, Point sp, Drawop op)
{
    dopoly('P', dst, p, np, wind, 0, 0, src, &sp, op);
}
@


<<function dopoly>>=
static
void
dopoly(int cmd, Image *dst, Point *pp, int np, int end0, int end1, int radius, Image *src, Point *sp, Drawop op)
{
    uchar *a, *t, *u;
    int i, ox, oy;

    if(np == 0)
        return;
    t = malloc(np*2*3);
    if(t == nil)
        return;
    u = t;
    ox = oy = 0;
    for(i=0; i<np; i++){
        u = addcoord(u, ox, pp[i].x);
        ox = pp[i].x;
        u = addcoord(u, oy, pp[i].y);
        oy = pp[i].y;
    }

    _setdrawop(dst->display, op);

    a = bufimage(dst->display, 1+4+2+4+4+4+4+2*4+(u-t));
    if(a == 0){
        free(t);
        fprint(2, "image poly: %r\n");
        return;
    }
    a[0] = cmd;
    BPLONG(a+1, dst->id);
    BPSHORT(a+5, np-1);
    BPLONG(a+7, end0);
    BPLONG(a+11, end1);
    BPLONG(a+15, radius);
    BPLONG(a+19, src->id);
    BPLONG(a+23, sp->x);
    BPLONG(a+27, sp->y);
    memmove(a+31, t, u-t);
    free(t);
}
@


<<function addcoord>>=
static
uchar*
addcoord(uchar *p, int oldx, int newx)
{
    int dx;

    dx = newx-oldx;
    /* does dx fit in 7 signed bits? */
    if((unsigned)(dx - -0x40) <= 0x7F)
        *p++ = dx&0x7F;
    else{
        *p++ = 0x80 | (newx&0x7F);
        *p++ = newx>>7;
        *p++ = newx>>15;
    }
    return p;
}
@

\section{Arc}

<<function doellipse>>=
static
void
doellipse(int cmd, Image *dst, Point *c, int xr, int yr, int thick, Image *src, Point *sp, int alpha, int phi, Drawop op)
{
    uchar *a;

    _setdrawop(dst->display, op);

    a = bufimage(dst->display, 1+4+4+2*4+4+4+4+2*4+2*4);
    if(a == 0){
        fprint(2, "image ellipse: %r\n");
        return;
    }
    a[0] = cmd;
    BPLONG(a+1, dst->id);
    BPLONG(a+5, src->id);
    BPLONG(a+9, c->x);
    BPLONG(a+13, c->y);
    BPLONG(a+17, xr);
    BPLONG(a+21, yr);
    BPLONG(a+25, thick);
    BPLONG(a+29, sp->x);
    BPLONG(a+33, sp->y);
    BPLONG(a+37, alpha);
    BPLONG(a+41, phi);
}
@




<<function arc>>=
void
arc(Image *dst, Point c, int a, int b, int thick, Image *src, Point sp, int alpha, int phi)
{
    alpha |= 1<<31;
    doellipse('e', dst, &c, a, b, thick, src, &sp, alpha, phi, SoverD);
}
@

<<function arcop>>=
void
arcop(Image *dst, Point c, int a, int b, int thick, Image *src, Point sp, int alpha, int phi, Drawop op)
{
    alpha |= 1<<31;
    doellipse('e', dst, &c, a, b, thick, src, &sp, alpha, phi, op);
}
@

<<function fillarc>>=
void
fillarc(Image *dst, Point c, int a, int b, Image *src, Point sp, int alpha, int phi)
{
    alpha |= 1<<31;
    doellipse('E', dst, &c, a, b, 0, src, &sp, alpha, phi, SoverD);
}
@

<<function fillarcop>>=
void
fillarcop(Image *dst, Point c, int a, int b, Image *src, Point sp, int alpha, int phi, Drawop op)
{
    alpha |= 1<<31;
    doellipse('E', dst, &c, a, b, 0, src, &sp, alpha, phi, op);
}
@


\section{Ellipse}

<<function ellipse>>=
void
ellipse(Image *dst, Point c, int a, int b, int thick, Image *src, Point sp)
{
    doellipse('e', dst, &c, a, b, thick, src, &sp, 0, 0, SoverD);
}
@

<<function ellipseop>>=
void
ellipseop(Image *dst, Point c, int a, int b, int thick, Image *src, Point sp, Drawop op)
{
    doellipse('e', dst, &c, a, b, thick, src, &sp, 0, 0, op);
}
@

<<function fillellipse>>=
void
fillellipse(Image *dst, Point c, int a, int b, Image *src, Point sp)
{
    doellipse('E', dst, &c, a, b, 0, src, &sp, 0, 0, SoverD);
}
@

<<function fillellipseop>>=
void
fillellipseop(Image *dst, Point c, int a, int b, Image *src, Point sp, Drawop op)
{
    doellipse('E', dst, &c, a, b, 0, src, &sp, 0, 0, op);
}
@


\section{Bezier}
% spline

%\section{Text}

\chapter{Colors}
% test code showing use of colors?

\section{[[RGB]]}

<<struct RGB>>=
struct RGB
{
    ulong	red;
    ulong	green;
    ulong	blue;
};
@

\section{Color map}

\section{Pixel depth}

\section{Alpha}

\chapter{Fonts}
% test code showing use of font? display the core font?

\section{Text}
% and rune

\section{Compressed form}

\section{Font cache}

\chapter{Image}

\section{Reading images}

\section{Writing images}

%topng </dev/screen >screen.png :) = Grab

\chapter{Composing}

\chapter{Display, Screen, Window}

\section{Display}

\section{Screen}

\section{Window}
%extern int	newwindow(char*);
% but actually it returns an int that is probably similar to a fd
% and rio itself match this id to a Window structure

% window managment! topwindow(), etc.


<<function topbottom>>=
static
void
topbottom(Image **w, int n, int top)
{
    int i;
    uchar *b;
    Display *d;

    if(n < 0){
    Ridiculous:
        fprint(2, "top/bottom: ridiculous number of windows\n");
        return;
    }
    if(n == 0)
        return;
    if(n > (w[0]->display->bufsize-100)/4)
        goto Ridiculous;
    /*
     * this used to check that all images were on the same screen.
     * we don't know the screen associated with images we acquired
     * by name.  instead, check that all images are on the same display.
     * the display will check that they are all on the same screen.
     */
    d = w[0]->display;
    for(i=1; i<n; i++)
        if(w[i]->display != d){
            fprint(2, "top/bottom: windows not on same screen\n");
            return;
        }

    if(n==0)
        return;
    b = bufimage(d, 1+1+2+4*n);
    b[0] = 't';
    b[1] = top;
    BPSHORT(b+2, n);
    for(i=0; i<n; i++)
        BPLONG(b+4+4*i, w[i]->id);
}
@

<<function bottomwindow>>=
void
bottomwindow(Image *w)
{
    if(w->screen == 0)
        return;
    topbottom(&w, 1, 0);
}
@

<<function topwindow>>=
void
topwindow(Image *w)
{
    if(w->screen == 0)
        return;
    topbottom(&w, 1, 1);
}
@

<<function bottomnwindows>>=
void
bottomnwindows(Image **w, int n)
{
    topbottom(w, n, 0);
}
@

<<function topnwindows>>=
void
topnwindows(Image **w, int n)
{
    topbottom(w, n, 1);
}
@


\section{Clipping}

\chapter{Input}

\section{Keyboard}

<<enum _anon_ (include/keyboard.h)>>=
enum {
    KF=	0xF000,	/* Rune: beginning of private Unicode space */
    Spec=	0xF800,
    /* KF|1, KF|2, ..., KF|0xC is F1, F2, ..., F12 */
    Khome=	KF|0x0D,
    Kup=	KF|0x0E,
    Kpgup=	KF|0x0F,
    Kprint=	KF|0x10,
    Kleft=	KF|0x11,
    Kright=	KF|0x12,
    Kdown=	Spec|0x00,
    Kview=	Spec|0x00,
    Kpgdown=	KF|0x13,
    Kins=	KF|0x14,
    Kend=	KF|0x18,

    Kalt=		KF|0x15,
    Kshift=	KF|0x16,
    Kctl=		KF|0x17,

    Kbs=	0x08,
    Kdel=	0x7f,
    Kesc=	0x1b,
    Keof=	0x04,
};
@


<<struct Keyboardctl>>=
struct	Keyboardctl
{
    Channel	*c;	/* chan(Rune)[20] */

    char	*file;

    int		consfd;		/* to cons file */
    int		ctlfd;		/* to ctl file */

    int		pid;		/* of slave proc */
};
@



% show also kernel interface and refer to Kernel.tex.nw

<<function initkeyboard>>=
Keyboardctl*
initkeyboard(char *file)
{
    Keyboardctl *kc;
    char *t;

    kc = mallocz(sizeof(Keyboardctl), 1);
    if(kc == nil)
        return nil;
    if(file == nil)
        file = "/dev/cons";
    kc->file = strdup(file);
    kc->consfd = open(file, ORDWR|OCEXEC);
    t = malloc(strlen(file)+16);
    if(kc->consfd<0 || t==nil){
Error1:
        free(kc);
        return nil;
    }
    sprint(t, "%sctl", file);
    kc->ctlfd = open(t, OWRITE|OCEXEC);
    if(kc->ctlfd < 0){
        fprint(2, "initkeyboard: can't open %s: %r\n", t);
Error2:
        close(kc->consfd);
        free(t);
        goto Error1;
    }
    if(ctlkeyboard(kc, "rawon") < 0){
        fprint(2, "initkeyboard: can't turn on raw mode on %s: %r\n", t);
        close(kc->ctlfd);
        goto Error2;
    }
    free(t);
    kc->c = chancreate(sizeof(Rune), 20);
    proccreate(_ioproc, kc, 4096);
    return kc;
}
@


<<function _ioproc>>=
static
void
_ioproc(void *arg)
{
    int m, n;
    char buf[20];
    Rune r;
    Keyboardctl *kc;

    kc = arg;
    threadsetname("kbdproc");
    kc->pid = getpid();
    n = 0;
    for(;;){
        while(n>0 && fullrune(buf, n)){
            m = chartorune(&r, buf);
            n -= m;
            memmove(buf, buf+m, n);
            send(kc->c, &r);
        }
        m = read(kc->consfd, buf+n, sizeof buf-n);
        if(m <= 0){
            yield();	/* if error is due to exiting, we'll exit here */
            fprint(2, "keyboard read error: %r\n");
            threadexits("error");
        }
        n += m;
    }
}
@

<<function closekeyboard>>=
void
closekeyboard(Keyboardctl *kc)
{
    if(kc == nil)
        return;

    postnote(PNPROC, kc->pid, "kill");

//#ifdef BUG
//	/* Drain the channel */
//	while(?kc->c)
//		<-kc->c;
//#endif

    close(kc->ctlfd);
    close(kc->consfd);
    free(kc->file);
    free(kc->c);
    free(kc);
}
@


<<function ctlkeyboard>>=
int
ctlkeyboard(Keyboardctl *kc, char *m)
{
    return write(kc->ctlfd, m, strlen(m));
}
@




\section{Mouse}

% show also kernel interface and refer to Kernel.tex.nw

% same in mouse.h and event.h
<<struct Mouse (include/mouse.h)>>=
struct	Mouse
{
    int	buttons;	/* bit array: LMR=124 */
    Point	xy;
    ulong	msec;
};
@

<<struct Mousectl>>=
struct Mousectl
{
    Mouse;

    Channel	*c;	/* chan(Mouse) */
    Channel	*resizec;	/* chan(int)[2] */
    /* buffered in case client is waiting for a mouse action before handling resize */

    char	*file;

    int		mfd;		/* to mouse file */
    int		cfd;		/* to cursor file */

    int		pid;	/* of slave proc */
    Image*	image;	/* of associated window/display */
};
@



<<function initmouse>>=
Mousectl*
initmouse(char *file, Image *i)
{
    Mousectl *mc;
    char *t, *sl;

    mc = mallocz(sizeof(Mousectl), 1);
    if(file == nil)
        file = "/dev/mouse";
    mc->file = strdup(file);
    mc->mfd = open(file, ORDWR|OCEXEC);
    if(mc->mfd<0 && strcmp(file, "/dev/mouse")==0){
        bind("#m", "/dev", MAFTER);
        mc->mfd = open(file, ORDWR|OCEXEC);
    }
    if(mc->mfd < 0){
        free(mc);
        return nil;
    }
    t = malloc(strlen(file)+16);
    if (t == nil) {
        close(mc->mfd);
        free(mc);
        return nil;
    }
    strcpy(t, file);
    sl = utfrrune(t, '/');
    if(sl)
        strcpy(sl, "/cursor");
    else
        strcpy(t, "/dev/cursor");
    mc->cfd = open(t, ORDWR|OCEXEC);
    free(t);
    mc->image = i;
    mc->c = chancreate(sizeof(Mouse), 0);
    mc->resizec = chancreate(sizeof(int), 2);
    proccreate(_ioproc, mc, 4096);
    return mc;
}
@

<<function _ioproc (lib_graphics/libdraw/mouse.c)>>=
static
void
_ioproc(void *arg)
{
    int n, nerr, one;
    char buf[1+5*12];
    Mouse m;
    Mousectl *mc;

    mc = arg;
    threadsetname("mouseproc");
    one = 1;
    memset(&m, 0, sizeof m);
    mc->pid = getpid();
    nerr = 0;
    for(;;){
        n = read(mc->mfd, buf, sizeof buf);
        if(n != 1+4*12){
            yield();	/* if error is due to exiting, we'll exit here */
            fprint(2, "mouse: bad count %d not 49: %r\n", n);
            if(n<0 || ++nerr>10)
                threadexits("read error");
            continue;
        }
        nerr = 0;
        switch(buf[0]){
        case 'r':
            send(mc->resizec, &one);
            /* fall through */
        case 'm':
            m.xy.x = atoi(buf+1+0*12);
            m.xy.y = atoi(buf+1+1*12);
            m.buttons = atoi(buf+1+2*12);
            m.msec = atoi(buf+1+3*12);
            send(mc->c, &m);
            /*
             * mc->Mouse is updated after send so it doesn't have wrong value if we block during send.
             * This means that programs should receive into mc->Mouse (see readmouse() above) if
             * they want full synchrony.
             */
            mc->Mouse = m;
            break;
        }
    }
}
@


<<function moveto>>=
void
moveto(Mousectl *m, Point pt)
{
    fprint(m->mfd, "m%d %d", pt.x, pt.y);
    m->xy = pt;
}
@

<<function closemouse>>=
void
closemouse(Mousectl *mc)
{
    if(mc == nil)
        return;

    postnote(PNPROC, mc->pid, "kill");

    do; while(nbrecv(mc->c, &mc->Mouse) > 0);

    close(mc->mfd);
    close(mc->cfd);
    free(mc->file);
    free(mc->c);
    free(mc->resizec);
    free(mc);
}
@

<<function readmouse>>=
int
readmouse(Mousectl *mc)
{
    if(mc->image)
        flushimage(mc->image->display, 1);
    if(recv(mc->c, &mc->Mouse) < 0){
        fprint(2, "readmouse: %r\n");
        return -1;
    }
    return 0;
}
@


<<function setcursor>>=
void
setcursor(Mousectl *mc, Cursor *c)
{
    char curs[2*4+2*2*16];

    if(c == nil)
        write(mc->cfd, curs, 0);
    else{
        BPLONG(curs+0*4, c->offset.x);
        BPLONG(curs+1*4, c->offset.y);
        memmove(curs+2*4, c->clr, 2*2*16);
        write(mc->cfd, curs, sizeof curs);
    }
}
@



\section{Events}

% have lots of dupes with events, menuhit.c vs emenuhit.c?

\chapter{Output}

\section{The screen}

\section{[[/dev/draw]]}
% this time no refer to Kernel.tex.nw, we inline it here!

\section{Cursor}

<<struct Cursor>>=
struct	Cursor
{
    Point	offset;
    uchar	clr[2*16];
    uchar	set[2*16];
};
@

\chapter{Widgets}

\section{Libpanel}
% different alloc, different event loop, 
% and the Panel main data structure



\section{Frame}
% have libframe/ but also a frame widge in libpanel

\section{Scrolling}
% have also a menu in libpanel, scrollbar

\section{Menu}
% have also a menu in libpanel, popup, pulldown

\section{Button}

\section{Label}

\section{Text entry}

\section{Completion}

\section{Slider}

\section{List}

\section{Pack}

\section{Canvas}

\section{Text view}

\section{Rich text}

\chapter{Advanced Topics}

\chapter{Conclusion}

\appendix

\chapter{Debugging}

% libdraw
<<global _drawdebug>>=
bool	_drawdebug = 0;
@

% libmemdrawn
<<global drawdebug>>=
int drawdebug;
@

<<global debuglockdisplay>>=
int		debuglockdisplay = 0;
@


<<function drawsetdebug>>=
void
drawsetdebug(int v)
{
    uchar *a;
    a = bufimage(display, 1+1);
    if(a == 0){
        fprint(2, "drawsetdebug: %r\n");
        return;
    }
    a[0] = 'D';
    a[1] = v;
}
@



\chapter{Error Managment}

\chapter{VGA driver}

\chapter{Mathematics}

\section{Trigonometric functions}

<<global sinus>>=
/*
 * Integer sine and cosine for integral degree argument.
 * Tables computed by (sin,cos)(PI*d/180).
 */
static short sinus[91] = {
    0,	/* 0 */
    18,	/* 1 */
    36,	/* 2 */
    54,	/* 3 */
    71,	/* 4 */
    89,	/* 5 */
    107,	/* 6 */
    125,	/* 7 */
    143,	/* 8 */
    160,	/* 9 */
    178,	/* 10 */
    195,	/* 11 */
    213,	/* 12 */
    230,	/* 13 */
    248,	/* 14 */
    265,	/* 15 */
    282,	/* 16 */
    299,	/* 17 */
    316,	/* 18 */
    333,	/* 19 */
    350,	/* 20 */
    367,	/* 21 */
    384,	/* 22 */
    400,	/* 23 */
    416,	/* 24 */
    433,	/* 25 */
    449,	/* 26 */
    465,	/* 27 */
    481,	/* 28 */
    496,	/* 29 */
    512,	/* 30 */
    527,	/* 31 */
    543,	/* 32 */
    558,	/* 33 */
    573,	/* 34 */
    587,	/* 35 */
    602,	/* 36 */
    616,	/* 37 */
    630,	/* 38 */
    644,	/* 39 */
    658,	/* 40 */
    672,	/* 41 */
    685,	/* 42 */
    698,	/* 43 */
    711,	/* 44 */
    724,	/* 45 */
    737,	/* 46 */
    749,	/* 47 */
    761,	/* 48 */
    773,	/* 49 */
    784,	/* 50 */
    796,	/* 51 */
    807,	/* 52 */
    818,	/* 53 */
    828,	/* 54 */
    839,	/* 55 */
    849,	/* 56 */
    859,	/* 57 */
    868,	/* 58 */
    878,	/* 59 */
    887,	/* 60 */
    896,	/* 61 */
    904,	/* 62 */
    912,	/* 63 */
    920,	/* 64 */
    928,	/* 65 */
    935,	/* 66 */
    943,	/* 67 */
    949,	/* 68 */
    956,	/* 69 */
    962,	/* 70 */
    968,	/* 71 */
    974,	/* 72 */
    979,	/* 73 */
    984,	/* 74 */
    989,	/* 75 */
    994,	/* 76 */
    998,	/* 77 */
    1002,	/* 78 */
    1005,	/* 79 */
    1008,	/* 80 */
    1011,	/* 81 */
    1014,	/* 82 */
    1016,	/* 83 */
    1018,	/* 84 */
    1020,	/* 85 */
    1022,	/* 86 */
    1023,	/* 87 */
    1023,	/* 88 */
    1024,	/* 89 */
    1024,	/* 90 */
};
@

<<function icossin>>=
void
icossin(int deg, int *cosp, int *sinp)
{
    int sinsign, cossign;
    short *stp, *ctp;

    deg %= 360;
    if(deg < 0)
        deg += 360;
    sinsign = 1;
    cossign = 1;
    stp = 0;
    ctp = 0;
    switch(deg/90){
    case 2:
        sinsign = -1;
        cossign = -1;
        deg -= 180;
        /* fall through */
    case 0:
        stp = &sinus[deg];
        ctp = &sinus[90-deg];
        break;
    case 3:
        sinsign = -1;
        cossign = -1;
        deg -= 180;
        /* fall through */
    case 1:
        deg = 180-deg;
        cossign = -cossign;
        stp = &sinus[deg];
        ctp = &sinus[90-deg];
        break;
    }
    *sinp = sinsign*stp[0];
    *cosp = cossign*ctp[0];
}
@



<<global sinus (lib_graphics/libdraw/icossin2.c)>>=
/*
 * Sine and Cosine of arctangents, calculated by 
 *   (sin(atan(index/100.0))*1024.+0.5)
 *   (cos(atan(index/100.0))*1024.+0.5)
 * To use, get rational tangent between 0<=tan<=1, scale by 100,
 * and look up sin and cos, and use linear interpolation.  divide by 1024.
 * Maximum error is 0.0020.  Without linear interpolation, it's 0.010.
 */
static
short sinus[] = {
    0,	/* 0.00 */
    10,	/* 0.01 */
    20,	/* 0.02 */
    31,	/* 0.03 */
    41,	/* 0.04 */
    51,	/* 0.05 */
    61,	/* 0.06 */
    72,	/* 0.07 */
    82,	/* 0.08 */
    92,	/* 0.09 */
    102,	/* 0.10 */
    112,	/* 0.11 */
    122,	/* 0.12 */
    132,	/* 0.13 */
    142,	/* 0.14 */
    152,	/* 0.15 */
    162,	/* 0.16 */
    172,	/* 0.17 */
    181,	/* 0.18 */
    191,	/* 0.19 */
    201,	/* 0.20 */
    210,	/* 0.21 */
    220,	/* 0.22 */
    230,	/* 0.23 */
    239,	/* 0.24 */
    248,	/* 0.25 */
    258,	/* 0.26 */
    267,	/* 0.27 */
    276,	/* 0.28 */
    285,	/* 0.29 */
    294,	/* 0.30 */
    303,	/* 0.31 */
    312,	/* 0.32 */
    321,	/* 0.33 */
    330,	/* 0.34 */
    338,	/* 0.35 */
    347,	/* 0.36 */
    355,	/* 0.37 */
    364,	/* 0.38 */
    372,	/* 0.39 */
    380,	/* 0.40 */
    388,	/* 0.41 */
    397,	/* 0.42 */
    405,	/* 0.43 */
    412,	/* 0.44 */
    420,	/* 0.45 */
    428,	/* 0.46 */
    436,	/* 0.47 */
    443,	/* 0.48 */
    451,	/* 0.49 */
    458,	/* 0.50 */
    465,	/* 0.51 */
    472,	/* 0.52 */
    480,	/* 0.53 */
    487,	/* 0.54 */
    493,	/* 0.55 */
    500,	/* 0.56 */
    507,	/* 0.57 */
    514,	/* 0.58 */
    520,	/* 0.59 */
    527,	/* 0.60 */
    533,	/* 0.61 */
    540,	/* 0.62 */
    546,	/* 0.63 */
    552,	/* 0.64 */
    558,	/* 0.65 */
    564,	/* 0.66 */
    570,	/* 0.67 */
    576,	/* 0.68 */
    582,	/* 0.69 */
    587,	/* 0.70 */
    593,	/* 0.71 */
    598,	/* 0.72 */
    604,	/* 0.73 */
    609,	/* 0.74 */
    614,	/* 0.75 */
    620,	/* 0.76 */
    625,	/* 0.77 */
    630,	/* 0.78 */
    635,	/* 0.79 */
    640,	/* 0.80 */
    645,	/* 0.81 */
    649,	/* 0.82 */
    654,	/* 0.83 */
    659,	/* 0.84 */
    663,	/* 0.85 */
    668,	/* 0.86 */
    672,	/* 0.87 */
    676,	/* 0.88 */
    681,	/* 0.89 */
    685,	/* 0.90 */
    689,	/* 0.91 */
    693,	/* 0.92 */
    697,	/* 0.93 */
    701,	/* 0.94 */
    705,	/* 0.95 */
    709,	/* 0.96 */
    713,	/* 0.97 */
    717,	/* 0.98 */
    720,	/* 0.99 */
    724,	/* 1.00 */
    728,	/* 1.01 */
};
@

<<global cosinus>>=
static
short cosinus[] = {
    1024,	/* 0.00 */
    1024,	/* 0.01 */
    1024,	/* 0.02 */
    1024,	/* 0.03 */
    1023,	/* 0.04 */
    1023,	/* 0.05 */
    1022,	/* 0.06 */
    1022,	/* 0.07 */
    1021,	/* 0.08 */
    1020,	/* 0.09 */
    1019,	/* 0.10 */
    1018,	/* 0.11 */
    1017,	/* 0.12 */
    1015,	/* 0.13 */
    1014,	/* 0.14 */
    1013,	/* 0.15 */
    1011,	/* 0.16 */
    1010,	/* 0.17 */
    1008,	/* 0.18 */
    1006,	/* 0.19 */
    1004,	/* 0.20 */
    1002,	/* 0.21 */
    1000,	/* 0.22 */
    998,	/* 0.23 */
    996,	/* 0.24 */
    993,	/* 0.25 */
    991,	/* 0.26 */
    989,	/* 0.27 */
    986,	/* 0.28 */
    983,	/* 0.29 */
    981,	/* 0.30 */
    978,	/* 0.31 */
    975,	/* 0.32 */
    972,	/* 0.33 */
    969,	/* 0.34 */
    967,	/* 0.35 */
    963,	/* 0.36 */
    960,	/* 0.37 */
    957,	/* 0.38 */
    954,	/* 0.39 */
    951,	/* 0.40 */
    947,	/* 0.41 */
    944,	/* 0.42 */
    941,	/* 0.43 */
    937,	/* 0.44 */
    934,	/* 0.45 */
    930,	/* 0.46 */
    927,	/* 0.47 */
    923,	/* 0.48 */
    920,	/* 0.49 */
    916,	/* 0.50 */
    912,	/* 0.51 */
    909,	/* 0.52 */
    905,	/* 0.53 */
    901,	/* 0.54 */
    897,	/* 0.55 */
    893,	/* 0.56 */
    890,	/* 0.57 */
    886,	/* 0.58 */
    882,	/* 0.59 */
    878,	/* 0.60 */
    874,	/* 0.61 */
    870,	/* 0.62 */
    866,	/* 0.63 */
    862,	/* 0.64 */
    859,	/* 0.65 */
    855,	/* 0.66 */
    851,	/* 0.67 */
    847,	/* 0.68 */
    843,	/* 0.69 */
    839,	/* 0.70 */
    835,	/* 0.71 */
    831,	/* 0.72 */
    827,	/* 0.73 */
    823,	/* 0.74 */
    819,	/* 0.75 */
    815,	/* 0.76 */
    811,	/* 0.77 */
    807,	/* 0.78 */
    804,	/* 0.79 */
    800,	/* 0.80 */
    796,	/* 0.81 */
    792,	/* 0.82 */
    788,	/* 0.83 */
    784,	/* 0.84 */
    780,	/* 0.85 */
    776,	/* 0.86 */
    773,	/* 0.87 */
    769,	/* 0.88 */
    765,	/* 0.89 */
    761,	/* 0.90 */
    757,	/* 0.91 */
    754,	/* 0.92 */
    750,	/* 0.93 */
    746,	/* 0.94 */
    742,	/* 0.95 */
    739,	/* 0.96 */
    735,	/* 0.97 */
    731,	/* 0.98 */
    728,	/* 0.99 */
    724,	/* 1.00 */
    720,	/* 1.01 */
};
@

<<function icossin2>>=
void
icossin2(int x, int y, int *cosp, int *sinp)
{
    int sinsign, cossign, tan, tan10, rem;
    short *stp, *ctp;

    if(x == 0){
        if(y >= 0)
            *sinp = ICOSSCALE, *cosp = 0;
        else
            *sinp = -ICOSSCALE, *cosp = 0;
        return;
    }
    sinsign = cossign = 1;
    if(x < 0){
        cossign = -1;
        x = -x;
    }
    if(y < 0){
        sinsign = -1;
        y = -y;
    }
    if(y > x){
        tan = 1000*x/y;
        tan10 = tan/10;
        stp = &cosinus[tan10];
        ctp = &sinus[tan10];
    }else{
        tan = 1000*y/x;
        tan10 = tan/10;
        stp = &sinus[tan10];
        ctp = &cosinus[tan10];
    }
    rem = tan-(tan10*10);
    *sinp = sinsign*(stp[0]+(stp[1]-stp[0])*rem/10);
    *cosp = cossign*(ctp[0]+(ctp[1]-ctp[0])*rem/10);
}
@



\chapter{Libc}

\chapter{Extra Code}

\ifallcode
#include "Graphics_extra.tex.nw"
\fi

\chapter{Changelog}
\label{sec:changelog}

\chapter{Glossary}
\label{sec:glossary}

\begin{verbatim}
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{section}{Index}

%\chapter{References} 
\addcontentsline{toc}{section}{References}

\begin{thebibliography}{99}

\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming}, 
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb}, 
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison}, 
\url{http://padator.org/software/project-syncweb/readme.txt}

\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
