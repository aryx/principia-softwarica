\documentclass[twocolumn]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse
% see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things:

%thx to codemap/codegraph/scheck:
% - TODO use cg to reduce backward deps, introduce globals.c, utils.c,
%   (harder to understand non layered code)
% - TODO use scheck to remove deadcode, dead prototypes, useless export
%   or mv as forward decl
%   (harder to understand big interface files)
% - TODO use cg to reduce number of globals by moving them closer to the
%   relevant file (or even function), better cluster the code
%   (harder to understand non functional code using lots of globals)

%thx to this manual, better understand svgalib?:

%history LP-ization:
% - skeleton, mostly copy paste of Template.tex.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * TODO ctor/dtor, dumper
%    * TODO [[xxx]] other fields, [[xxx]] extra fields
% - read Extra section, identify concepts, first TOC
% - SEMI distribute parts of the Extra section in the main file
% - SEMI understand main(), LP split main, improve TOC
% - TODO understand main functions, LP split, cluster, improve TOC
% - TODO LP split the structures, use datalog for flow to field info
% - TODO nullify, boolify, errorify, enumify,  typeify,    scheckify, plan9ify
% - TODO aspecify advanced features! remove useless features
% - TODO add figures
% - TODO add explanations


%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\iffinal
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\fi
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
%\usepackage{cleveref} %\cref
%\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}
 %\usepackage[margin=0.5in]{geometry}
 %  but eat the bottom when very low
 %\usepackage{fullpage} is deprecated 
 % => do the more manual below:
 \addtolength{\oddsidemargin}{-.850in}
 \addtolength{\evensidemargin}{-.850in}
 \addtolength{\textwidth}{1.70in}
 \addtolength{\topmargin}{-.850in}
 \addtolength{\textheight}{1.70in}
%\usepackage{minitoc}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% used for forward decl, pragmas, func decl, extern decl, stats, #ifdef,
% debugging macros

\setcounter{tocdepth}{2}

%******************************************************************************
% Title
%******************************************************************************

\begin{document}

\title{
{\Huge 
Principia Softwarica: The Plan9 Graphics System [[/dev/draw]]
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}
}

\maketitle 
\onecolumn
\hrule
\begin{quote}
    Copyright \copyright{} 2014 Yoann Padioleau \\
    Permission is granted to copy, distribute and/or modify this document,
    except all the source code it contains, under the terms of the GNU Free
    Documentation License, Version 1.3.
\end{quote}
\hrule

%CONFIG: \dominitoc

\iffinal
\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\twocolumn
\tableofcontents
\endgroup
\else
\tableofcontents
\fi

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

\section{Motivations}

The goal of this book is to present in full details the source code of
a real graphics system.
Why? Because I think it makes you a better programmer if
you fully understand how things work under the hood.

% gonna present the one in Plan9, mostly /dev/draw, but also
% /dev/mouse, /dev/cons, etc.
% It actually provides some forms of window managment, with backing
% store, and even menu (but rio is more complete)

Here are other candidates that were considered but ultimately discarded:
\begin{itemize}
\item mks
\item svgalib
\item cairo
\item opengl
\item X11
\end{itemize}
% nuttx has some graphic and windowing stack apparently too!

% SDL, canvas, postscript, ...

%opengl and glut. the menuhit function is kinda related to glut.

\section{Getting started}

\section{Requirements}

\section{About this document}
#include "../docs/latex/About.tex.nw"

\section{Copyright}

Most of this document is actually source code from Plan9, so
those parts are copyright by Lucent Technologies Inc.
The prose is mine and is licensed under the GNU Free Documentation
License.

\section{Acknowledgments}

I would like to acknowledge of course Plan9's authors who wrote
most of this book: Rob Pike, Ken Thompson, Dave Presotto, Phil
Winterbottom, Russ Cox, and many other people from Bell Labs.

\chapter{Overview}

\section{Graphics system principles}

% screen made of pixels. Lots of them. Resolution.
% not continuous! so if draw diagonal, then no that easy actually :)
% bresenham

% horiz/vert lines, rectangle, line, poly, ellipse, arc, bezier, text (fonts)
% colors
% composition (porter-duff), alpha, clipping

% see cairo intro?

% advanced: windows/layers, menus, mouse/keyboard

\section{[[/dev/draw]] services}
%maybe show code of toy app also?
% show the different devices?

% note that can run 'colors' in console outside rio! it just
% use /dev/draw, /dev/mouse, etc!

% see draw(5?)

\section{A toy graphical application}
% e.g. colors


\section{Code organization}

% libdraw, libmemdraw, libmemlayer?
%#include <draw.h>
%#include <memdraw.h>
%#include <memlayer.h>
% lofs of files have similar name in libdraw/ and libmemdraw/

% kernel part? user part?

%-------------------
% libdraw/
%-------------------

%icossin.c: math
%icossin2.c: math

%arith.c: Point, Rectangle and helpers

%init.c: display, screen, images

%draw.c: draw rectangle (easier draw horiz or vert)
 %border.c: draw border
%line.c: draw line (bensemann algorithm)
%poly.c: draw polylines
%ellipse.c: draw ellipse, and arcs
%bezier.c: draw spline
%string.c: draw text
 %stringbg.c

%alloc.c
%allocimagemix.c:

%chan.c
%rgb.c
%readcolmap.c
%writecolmap.c

%readimage.c
%writeimage.c
%loadimage.c
%unloadimage.c
%cloadimage.c
%creadimage.c

%window.c
%newwindow.c



%event.c
%mouse.c
%keyboard.c

%emenuhit.c
%menuhit.c

%debug.c
%fmt.c


%font.c
%buildfont.c
%mkfont.c
%defont.c
%getdefont.c
%openfont.c

%subfont.c
%getsubfont.c
%freesubfont.c
%stringsubfont.c
%subfontcache.c
%subfontname.c
%readsubfont.c
%writesubfont.c


%bytesperline.c
%computil.c
%drawrepl.c
%egetrect.c
%getrect.c
%rectclip.c
%replclipr.c
%scroll.c
%stringwidth.c


%-------------------
% libmemdraw/
%-------------------

%draw.c
%hwdraw.c

%line.c
%poly.c
%fillpoly.c
%ellipse.c
%arc.c
%string.c

%alloc.c

%cmap.c

%load.c
%unload.c

%read.c
%write.c

%cload.c
%cread.c


%subfont.c
%openmemsubfont.c
%defont.c


%replmul.c

%iprint.c



%-------------------
% libmemlayer/
%-------------------
%draw.c: again, memdraw(), but should be in libmemdraw/
%line.c: again! memline(), but should be only for horizontal/vert here no?

%lalloc.c
%layerop.c
%ldelete.c
%lsetrefresh.c


%lorigin.c
%lhide.c
%ltofront.c
%ltorear.c

%load.c
%unload.c

%-------------------
% kernel/drivers/screen/
%-------------------
% ???

\section{Architecture overview}

% app, library, kernel draw server, vga driver
% kernel vs libs vs apps (vs rio)

% public API -> marshaller -> flush -> KERNEL -> unmarshaller -> algorithm
% some kind of RPC and protocol


% libdraw -> KERNEL -> devdraw -> libmemdraw | libmemlayer -> devvga -> clgd5446
% that's a lot of entities

% line, doline, memline , linescreen

% Display
%  Image (User side, id) MemImage (Kernel side, id -> full structure)
%  Screen
%   Window (Image)

% devvga
%  why imagmem? why imagmem and mainmem? why not use other allocator?
%  see screen/user/notes.txt especially about the old way to get graphics on PC


% about RPC vs framebuffer.
% design goal was like X11 can be remote! can login on another
% machine, execute program there that actually display on your screen.
% for plan9 they just reuse 9p! network file system so /dev/draw
% can be on the network!
% but this design means it's not a framebuffer! it accepts
% drawing commands, like in X11, because can't allow to send
% all pixels each time through big write on /dev/draw over the network
% (hmm actually with high speed network maybe we could)



\section{Initialization overview}

%\section{Trace of a mouse click}

%\section{Trace of a key press}

\section{Trace of a simple drawing operation}
% when do draw(), then where does it go? go in kernel?


%###############################################################################

\chapter{Core Data Structures}

% draw.h big categories
% the important globals init libdraw/init.c

\section{[[Display]] and [[Client]]}

% user side, can see it as a connection handler
<<struct Display>>=
struct Display
{
    int		dirno; // /dev/draw/x

    fdt		fd;    // /dev/draw/x/data
    fdt		ctlfd; // /dev/draw/new
    fdt		reffd; // /dev/draw/x/refresh

    // ref_own<Image>
    Image	*image;

    // drawing operatings to write in /dev/draw/x/data until flush
    // array<byte>
    byte	*buf;
    int		bufsize;
    // index in Display.buf array
    byte	*bufp;

    void	(*error)(Display*, char*);

    Image	*white;
    Image	*black;

    Image	*opaque;
    Image	*transparent;

    <<[[Display]] other fields>>
};
@

% usually have draw(dstimg, rectangle, srcimg, maskimg)
% and srcimg can be just black, and maskimg can be just opaque
% the abuse image for many things, because it's more general!
% Black is an image! (1x1 pixels)

%!!!!
<<global display>>=
Display	*display;
@




%XXXXXXXXXX
<<[[Display]] other fields>>=
QLock	qlock;
int		locking;	/*program is using lockdisplay */
@
<<[[Display]] other fields>>=
int		local;
char	oldlabel[64];
ulong	dataqid;
@
<<[[Display]] other fields>>=
bool	_isnewdisplay;
@


% just for debugging I think, have ctlfd and fd already
<<[[Display]] other fields>>=
char	*devdir; // /dev in general
char	*windir; // /dev in general
@





<<struct Client>>=
struct Client
{
    int     clientid; // dirno?

    DImage*     dimage[NHASH];

    int     op;

    <<[[Client]] other fields>>
    // Extra
    Ref     r;
};
@
% ref? can share client? if create proc? if attach to another display?


%XXXXXXXXXX
<<[[Client]] other fields>>=
CScreen*    cscreen;

Refresh*    refresh;
Rendez      refrend;

uchar*      readdata;
int     nreaddata;

int     busy;
int     slot;
int     refreshme;
int     infoid;
@

\section{[[Image]] and [[Memimage]]}
% and screen

<<struct Image>>=
struct Image
{
    // ref<Display>, reverse of Display->image
    Display		*display;	/* display holding data */
    int			id;		/* id of system-held Image */

    Rectangle	r;		/* rectangle in data area, local coords */
    Rectangle 	clipr;		/* clipping region */

    int			depth;		/* number of bits per pixel */
    ulong		chan;

    <<[[Image]] other fields>>
    // Extra
    <<[[Image]] extra fields>>
};
@
% read from /dev/draw/new initially when open the connection
%  see initdisplay() 
% system-held id! usually 0 for the first image of /dev/draw/new

% need display pointer because when do draw operation we need
% to write in img->display.buf! and then flushimage(img->display)!
% we need the connection handler!

<<global screen>>=
Image	*screen;
@
% unfortunate ... should call it image really ... or even maybe
% window



<<[[Display]] other fields>>=
int		imageid;
@
% counter, incremented each allocimage

<<[[Image]] other fields>>=
int			repl;		/* flag: data replicates to tile clipr */
@








<<struct Memimage>>=
struct Memimage
{
    Rectangle	r;		/* rectangle in data area, local coords */
    Rectangle	clipr;		/* clipping region */

    int		depth;	/* number of bits of storage per pixel */
    ulong	chan;	/* channel descriptions */
    int		nchan;	/* number of channels */

    // finally, the raw pixels
    Memdata	*data;	/* pointer to data; shared by windows in this image */

    <<[[MemImage]] other fields>>
};
@

<<[[MemImage]] other fields>>=
Memcmap	*cmap;
int		zero;		/* data->bdata+zero==&byte containing (0,0) */
ulong	width;	/* width in words of a single scan line */

ulong	flags;

int		shift[NChan];
int		mask[NChan];
int		nbits[NChan];
@


<<struct Memdata>>=
/*
 * Memdata is allocated from main pool, but .data from the image pool.
 * Memdata is allocated separately to permit patching its pointer after
 * compaction when windows share the image data.
 * The first word of data is a back pointer to the Memdata, to find
 * The word to patch.
 */
struct Memdata
{
    ulong	*base;	/* allocated data pointer */
    // the pixels!
    byte	*bdata;	/* pointer to first byte of actual data; word-aligned */

    <<[[Memdata]] other fields>>
};
@
% this is kinda a framebuffer. But actually needs one
% operation to transfer from this memory to the actual screen!
% this is what vga driver does.

<<[[Memdata]] other fields>>=
int		ref;		/* number of Memimages using this data */

void*	imref;
int		allocd;	/* is this malloc'd? */
@

\section{Image channels}

% not thread channel, image channel here!
% ulong in previous struct, but more complex format
% actually

<<enum _anon_ (include/draw.h)4>>=
/*
 * image channel descriptors 
 */
enum {
    CRed = 0,
    CGreen,
    CBlue,

    CGrey,
    CAlpha,
    CMap,
    CIgnore,

    NChan,
};
@

<<enum _anon_ (include/draw.h)5>>=
enum {
    GREY1	= CHAN1(CGrey, 1),
    GREY2	= CHAN1(CGrey, 2),
    GREY4	= CHAN1(CGrey, 4),
    GREY8	= CHAN1(CGrey, 8),
    CMAP8	= CHAN1(CMap, 8),
    RGB15	= CHAN4(CIgnore, 1, CRed, 5, CGreen, 5, CBlue, 5),
    RGB16	= CHAN3(CRed, 5, CGreen, 6, CBlue, 5),
    RGB24	= CHAN3(CRed, 8, CGreen, 8, CBlue, 8),
    RGBA32	= CHAN4(CRed, 8, CGreen, 8, CBlue, 8, CAlpha, 8),
    ARGB32	= CHAN4(CAlpha, 8, CRed, 8, CGreen, 8, CBlue, 8),	/* stupid VGAs */
    XRGB32	= CHAN4(CIgnore, 8, CRed, 8, CGreen, 8, CBlue, 8),
    BGR24	= CHAN3(CBlue, 8, CGreen, 8, CRed, 8),
    ABGR32	= CHAN4(CAlpha, 8, CBlue, 8, CGreen, 8, CRed, 8),
    XBGR32	= CHAN4(CIgnore, 8, CBlue, 8, CGreen, 8, CRed, 8),
};
@
% need all of that?
% argument of what? allocimage?


<<function __DC>>=
#define __DC(type, nbits)	((((type)&15)<<4)|((nbits)&15))
@

<<function CHAN1>>=
#define CHAN1(a,b)	__DC(a,b)
@

<<function CHAN2>>=
#define CHAN2(a,b,c,d)	(CHAN1((a),(b))<<8|__DC((c),(d)))
@

<<function CHAN3>>=
#define CHAN3(a,b,c,d,e,f)	(CHAN2((a),(b),(c),(d))<<8|__DC((e),(f)))
@

<<function CHAN4>>=
#define CHAN4(a,b,c,d,e,f,g,h)	(CHAN3((a),(b),(c),(d),(e),(f))<<8|__DC((g),(h)))
@

<<function NBITS>>=
#define NBITS(c) ((c)&15)
@

<<function TYPE>>=
#define TYPE(c) (((c)>>4)&15)
@
% >> >> >>

<<function chantodepth>>=
int
chantodepth(ulong c)
{
    int n;

    for(n=0; c; c>>=8){
        if(TYPE(c) >= NChan || NBITS(c) > 8 || NBITS(c) <= 0)
            return 0;
        n += NBITS(c);
    }
    if(n==0 || (n>8 && n%8) || (n<8 && 8%n))
        return 0;
    return n;
}
@


\section{Colors}

<<enum _anon_>>=
enum
{
    DOpaque		= 0xFFFFFFFF,
    DTransparent	= 0x00000000,		/* only useful for allocimage, memfillcolor */

    DBlack		= 0x000000FF,
    DWhite		= 0xFFFFFFFF,
    DRed		= 0xFF0000FF,
    DGreen		= 0x00FF00FF,
    DBlue		= 0x0000FFFF,
    DCyan		= 0x00FFFFFF,
    DMagenta		= 0xFF00FFFF,
    DYellow		= 0xFFFF00FF,

    DPaleyellow	= 0xFFFFAAFF,
    DDarkyellow	= 0xEEEE9EFF,
    DDarkgreen	= 0x448844FF,
    DPalegreen	= 0xAAFFAAFF,
    DMedgreen	= 0x88CC88FF,
    DDarkblue	= 0x000055FF,
    DPalebluegreen= 0xAAFFFFFF,
    DPaleblue	= 0x0000BBFF,
    DBluegreen	= 0x008888FF,
    DGreygreen	= 0x55AAAAFF,
    DPalegreygreen	= 0x9EEEEEFF,
    DYellowgreen	= 0x99994CFF,
    DMedblue		= 0x000099FF,
    DGreyblue		= 0x005DBBFF,
    DPalegreyblue	= 0x4993DDFF,
    DPurpleblue		= 0x8888CCFF,

    DNotacolor	= 0xFFFFFF00,
    DNofill	= DNotacolor,
    
};
@

\section{[[Font]] and [[Subfont]]}
% and [[font]]

<<struct Font>>=
struct Font
{
    char		*name;
    Display		*display;

    short		height;	/* max height of image, interline spacing */
    short		ascent;	/* top of image to baseline */
    short		width;	/* widest so far; used in caching only */	

    short		nsub;	/* number of subfonts */
    ulong		age;	/* increasing counter; used for LRU */
    int		maxdepth;	/* maximum depth of all loaded subfonts */
    int		ncache;	/* size of cache */
    int		nsubf;	/* size of subfont list */

    Cacheinfo	*cache;
    Cachesubf	*subf;
    Cachefont	**sub;	/* as read from file */
    Image		*cacheimage;
};
@


<<global font>>=
Font	*font;
@


<<[[Display]] other fields>>=
Font	*defaultfont;
Subfont	*defaultsubfont;
@

<<struct Subfont>>=
/*
 * Subfonts
 *
 * given char c, Subfont *f, Fontchar *i, and Point p, one says
 *	i = f->info+c;
 *	draw(b, Rect(p.x+i->left, p.y+i->top,
 *		p.x+i->left+((i+1)->x-i->x), p.y+i->bottom),
 *		color, f->bits, Pt(i->x, i->top));
 *	p.x += i->width;
 * to draw characters in the specified color (itself an Image) in Image b.
 */
struct	Subfont
{
    char		*name;
    short		n;		/* number of chars in font */
    uchar		height;		/* height of image */
    char		ascent;		/* top of image to baseline */

    Fontchar 	*info;		/* n+1 character descriptors */
    Image		*bits;		/* of font */
    int		ref;
};
@

<<struct Fontchar>>=
struct	Fontchar
{
    int		x;		/* left edge of bits */
    uchar		top;		/* first non-zero scan-line */
    uchar		bottom;		/* last non-zero scan-line + 1 */
    char		left;		/* offset of baseline */
    uchar		width;		/* width of baseline */
};
@

\section{[[Drawop]] and [[Memdrawparam]]}
<<enum drawop>>=
enum drawop
{
    /* Porter-Duff compositing operators */
    Clear	= 0,

    SinD	= 8,
    DinS	= 4,
    SoutD	= 2,
    DoutS	= 1,

    S		= SinD|SoutD,
    SoverD	= SinD|SoutD|DoutS,
    SatopD	= SinD|DoutS,
    SxorD	= SoutD|DoutS,

    D		= DinS|DoutS,
    DoverS	= DinS|DoutS|SoutD,
    DatopS	= DinS|SoutD,
    DxorS	= DoutS|SoutD,	/* == SxorD */

    Ncomp = 12,
};
@


<<struct Memdrawparam>>=
struct	Memdrawparam
{
    Memimage *dst;
    Rectangle	r;
    Memimage *src;
    Rectangle sr;
    Memimage *mask;
    Rectangle mr;
    int op;

    ulong state;
    ulong mval;	/* if Simplemask, the mask pixel in mask format */
    ulong mrgba;	/* mval in rgba */
    ulong sval;	/* if Simplesrc, the source pixel in src format */
    ulong srgba;	/* sval in rgba */
    ulong sdval;	/* sval in dst format */
};
@

\section{Windows and layers}

<<[[Image]] other fields>>=
Screen		*screen;	/* 0 if not a window */
@

% TODO Screen type here

<<[[Display]] other fields>>=
// list<ref<Window>> (next = Image.next)
Image	*windows;
@

<<[[Image]] extra fields>>=
Image		*next;	/* next in list of windows */
@



<<[[Display]] other fields>>=
Image	*screenimage; // ???
@
% ????




<<[[MemImage]] other fields>>=
Memlayer	*layer;	/* nil if not a layer*/
@

% TODO Memlayer type here


\chapter{[[initdraw()]]}

<<function initdraw>>=
errorcodeneg1
initdraw(void(*error)(Display*, char*), char *fontname , char *label)
{
    char *dev = "/dev";

    if(access("/dev/draw/new", AEXIST)<0 && bind("#i", "/dev", MAFTER)<0){
        fprint(2, "imageinit: can't bind /dev/draw: %r\n");
        return ERROR_NEG1;
    }
    return geninitdraw(dev, error, fontname, label, dev, Refnone);
}
@

% devdir and windir often equals and = /dev
<<function geninitdraw>>=
errorcodeneg1
geninitdraw(char *devdir, void(*error)(Display*, char*), char *fontname, char *label, char *windir, int ref)
{
    int fd, n;
    Subfont *df;
    char buf[128];

    display = initdisplay(devdir, windir, error);
    if(display == nil)
        return ERROR_NEG1;

    <<[[geninitdraw()]] set up font>>
    <<[[geninitdraw()]] write label>>
    <<[[geninitdraw()]] get window>>

    atexit(drawshutdown);

    return OK_1;
}
@

<<function drawshutdown>>=
/* note handler */
static void
drawshutdown(void)
{
    Display *d;

    d = display;
    if(d){
        display = nil;
        _closedisplay(d, 1);
    }
}
@


\section{[[initdisplay()]]}

% get connection and first automatically allocated image in d->image

<<constant NINFO>>=
#define	NINFO	12*12
@
% /dev/draw/new content, 12 strings each 11 chars + newline

<<[[initdisplay()]] locals>>=
Display *disp;
Image *image;

fdt ctlfd;
char info[NINFO+1];
fdt datafd;
fdt reffd;

char buf[128];
char *t;
bool isnew;
int n;
Dir *dir;
@

%less: could reorganize error managment like in Linux instead
% have the errorx: followed, so less need 'goto previousone';

% hmm it's actually a public function! but not much app tweaking
% with it
<<function initdisplay>>=
Display*
initdisplay(char *dev, char *win, void(*error)(Display*, char*))
{
    <<[[initdisplay()]] locals>>

    <<[[initdisplay()]] install dumpers>>
    <<[[initdisplay()]] check arguments validity>>

    sprint(buf, "%s/draw/new", dev);
    ctlfd = open(buf, ORDWR|OCEXEC);

    if(ctlfd < 0){
        if(bind("#i", dev, MAFTER) < 0){
    Error1:
            free(t);
            werrstr("initdisplay: %s: %r", buf);
            return nil;
        }
        // try again
        ctlfd = open(buf, ORDWR|OCEXEC);
    }
    if(ctlfd < 0)
        goto Error1;

    n=read(ctlfd, info, sizeof info);

    if(n < 12){
    Error2:
        close(ctlfd);
        goto Error1;
    }
    if(n==NINFO+1)
        n = NINFO;
    info[n] = '\0';

    isnew = false;
    if(n < NINFO)	/* this will do for now, we need something better here */
        isnew = true;

    sprint(buf, "%s/draw/%d/data", dev, atoi(info+0*12));
    datafd = open(buf, ORDWR|OCEXEC);

    if(datafd < 0)
        goto Error2;

    sprint(buf, "%s/draw/%d/refresh", dev, atoi(info+0*12));
    reffd = open(buf, OREAD|OCEXEC);

    if(reffd < 0){
    Error3:
        close(datafd);
        goto Error2;
    }

    disp = mallocz(sizeof(Display), 1);

    if(disp == nil){
    Error4:
        close(reffd);
        goto Error3;
    }

    image = nil;
    if(0){
    Error5:
        free(image);
        free(disp);
        goto Error4;
    }
    if(n >= NINFO){
        image = mallocz(sizeof(Image), 1);
        if(image == nil)
            goto Error5;
        image->display = disp;
        image->id = 0; // info+1*12 but should always be 0
        image->chan = strtochan(info+2*12);
        image->depth = chantodepth(image->chan);
        image->repl = atoi(info+3*12);
        image->r.min.x = atoi(info+4*12);
        image->r.min.y = atoi(info+5*12);
        image->r.max.x = atoi(info+6*12);
        image->r.max.y = atoi(info+7*12);
        image->clipr.min.x = atoi(info+8*12);
        image->clipr.min.y = atoi(info+9*12);
        image->clipr.max.x = atoi(info+10*12);
        image->clipr.max.y = atoi(info+11*12);
    }

    disp->_isnewdisplay = isnew;

    disp->bufsize = iounit(datafd);
    if(disp->bufsize <= 0)
        disp->bufsize = 8000;
    if(disp->bufsize < 512){
        werrstr("iounit %d too small", disp->bufsize);
        goto Error5;
    }
    disp->buf = malloc(disp->bufsize+5);	/* +5 for flush message */
    if(disp->buf == nil)
        goto Error5;

    disp->image = image;
    disp->dirno = atoi(info+0*12);
    disp->fd    = datafd;
    disp->ctlfd = ctlfd;
    disp->reffd = reffd;
    disp->bufp = disp->buf;
    disp->error = error;
    disp->windir = t;
    disp->devdir = strdup(dev);

    qlock(&disp->qlock);
    disp->white = allocimage(disp, Rect(0, 0, 1, 1), GREY1, 1, DWhite);
    disp->black = allocimage(disp, Rect(0, 0, 1, 1), GREY1, 1, DBlack);
    if(disp->white == nil || disp->black == nil){
        free(disp->devdir);
        free(disp->white);
        free(disp->black);
        goto Error5;
    }
    disp->opaque = disp->white;
    disp->transparent = disp->black;

    dir = dirfstat(ctlfd);
    if(dir!=nil && dir->type=='i'){
        disp->local = 1;
        disp->dataqid = dir->qid.path;
    }
    if(dir!=nil && dir->qid.vers==1)	/* other way to tell */
        disp->_isnewdisplay = 1;
    free(dir);

    return disp;
}
@


<<[[initdisplay()]] install dumpers>>=
fmtinstall('P', Pfmt);
fmtinstall('R', Rfmt);
@

<<[[initdisplay()]] check arguments validity>>=
if(dev == nil)
    dev = "/dev";
if(win == nil)
    win = "/dev";

if(strlen(dev)>sizeof buf-25 || strlen(win)>sizeof buf-25){
    werrstr("initdisplay: directory name too long");
    return nil;
}
t = strdup(win);
if(t == nil)
    return nil;
@






<<function closedisplay>>=
/*
 * Call with d unlocked.
 * Note that disp->defaultfont and defaultsubfont are not freed here.
 */
void
closedisplay(Display *disp)
{
    _closedisplay(disp, 0);
}
@

<<function _closedisplay>>=
static void
_closedisplay(Display *disp, int isshutdown)
{
    int fd;
    char buf[128];

    if(disp == nil)
        return;
    if(disp == display)
        display = nil;
    if(disp->oldlabel[0]){
        snprint(buf, sizeof buf, "%s/label", disp->windir);
        fd = open(buf, OWRITE);
        if(fd >= 0){
            write(fd, disp->oldlabel, strlen(disp->oldlabel));
            close(fd);
        }
    }

    /*
     * if we're shutting down, don't free all the resources.
     * if other procs are getting shot down by notes too,
     * one might get shot down while holding the malloc lock.
     * just let the kernel clean things up when we exit.
     */
    if(isshutdown)
        return;

    free(disp->devdir);
    free(disp->windir);
    freeimage(disp->white);
    freeimage(disp->black);
    close(disp->fd);
    close(disp->ctlfd);
    /* should cause refresh slave to shut down */
    close(disp->reffd);
    qunlock(&disp->qlock);
    free(disp);
}
@

\section{Image}

\section{Fonts}

<<[[geninitdraw()]] set up font>>=
/*
 * Set up default font
 */
df = getdefont(display);
display->defaultsubfont = df;
if(df == nil){
    fprint(2, "imageinit: can't open default subfont: %r\n");
Error:
    closedisplay(display);
    display = nil;
    return -1;
}
if(fontname == nil){
    fd = open("/env/font", OREAD);
    if(fd >= 0){
        n = read(fd, buf, sizeof(buf));
        if(n>0 && n<sizeof buf-1){
            buf[n] = 0;
            fontname = buf;
        }
        close(fd);
    }
}
/*
 * Build fonts with caches==depth of screen, for speed.
 * If conversion were faster, we'd use 0 and save memory.
 */
if(fontname == nil){
    snprint(buf, sizeof buf, "%d %d\n0 %d\t%s\n", df->height, df->ascent,
        df->n-1, deffontname);
 //BUG: Need something better for this	installsubfont("*default*", df);
    font = buildfont(display, buf, deffontname);
    if(font == nil){
        fprint(2, "imageinit: can't open default font: %r\n");
        goto Error;
    }
}else{
    font = openfont(display, fontname);	/* BUG: grey fonts */
    if(font == nil){
        fprint(2, "imageinit: can't open font %s: %r\n", fontname);
        goto Error;
    }
}
display->defaultfont = font;
@

\section{Label}

<<[[geninitdraw()]] write label>>=
/*
 * Write label; ignore errors (we might not be running under rio)
 */
if(label){
    snprint(buf, sizeof buf, "%s/label", display->windir);
    fd = open(buf, OREAD);
    if(fd >= 0){
        read(fd, display->oldlabel, (sizeof display->oldlabel)-1);
        close(fd);
        fd = create(buf, OWRITE, 0666);
        if(fd >= 0){
            write(fd, label, strlen(label));
            close(fd);
        }
    }
}
@

\section{Screen}

<<[[geninitdraw()]] get window>>=
snprint(buf, sizeof buf, "%s/winname", display->windir);
if(gengetwindow(display, buf, &screen, &_screen, ref) < 0)
    goto Error;
@
% ???

\chapter{User/Kernel Bridge}

% some kind of RPC and protocol
% todo: lots of boilerplate code, would be better to use thrift in the end
% lots of marshalling/unmarshalling boilerplate with BPLONG and so on.
% file interface is nice but limited in the end. Or maybe can just
% write a thrift like tool on top of the file interface that generates
% most of the boilerplate at least.

\section{Draw device}

% so bind #i

<<global drawdevtab>>=
Dev drawdevtab = {
    .dc       =    'i',
    .name     =    "draw",

    .attach   =    drawattach,
    .walk     =    drawwalk,
    .open     =    drawopen,
    .close    =    drawclose,
    .read     =    drawread,
    .write    =    drawwrite,
    .stat     =    drawstat,
    .wstat    =    devwstat,
               
    .reset    =    devreset,
    .init     =    devinit,
    .shutdown =    devshutdown,
    .create   =    devcreate,
    .bread    =    devbread,
    .bwrite   =    devbwrite,
    .remove   =    devremove,
};
@

\subsection{[[/dev/draw/new]]}
% and Client?

\subsection{[[/dev/draw/x/data]]}
% and DImage?


\section{Vga device}

<<global vgadevtab>>=
Dev vgadevtab = {
    .dc       =    'v',
    .name     =    "vga",
               
    .reset    =    vgareset,

    .attach   =    vgaattach,
    .walk     =    vgawalk,
    .open     =    vgaopen,
    .close    =    vgaclose,
    .read     =    vgaread,
    .write    =    vgawrite,
    .stat     =    vgastat,
    .wstat    =    devwstat,

    .init     =    devinit,
    .shutdown =    devshutdown,
    .create   =    devcreate,
    .bread    =    devbread,
    .bwrite   =    devbwrite,
    .remove   =    devremove,
};
@

\section{Protocol}

\subsection{API}

\subsection{Marshalling}

<<function BGSHORT>>=
#define	BGSHORT(p)		(((p)[0]<<0) | ((p)[1]<<8))
@

<<function BGLONG>>=
#define	BGLONG(p)		((BGSHORT(p)<<0) | (BGSHORT(p+2)<<16))
@

<<function BPSHORT>>=
#define	BPSHORT(p, v)		((p)[0]=(v), (p)[1]=((v)>>8))
@

<<function BPLONG>>=
#define	BPLONG(p, v)		(BPSHORT(p, (v)), BPSHORT(p+2, (v)>>16))
@

% could start by a simple example? like flush?


% put buf fields here

<<function bufimage>>=
uchar*
bufimage(Display *d, int n)
{
    uchar *p;

    if(n<0 || n>d->bufsize){
        werrstr("bad count in bufimage");
        return 0;
    }
    if(d->bufp+n > d->buf+d->bufsize)
        if(doflush(d) < 0)
            return 0;
    p = d->bufp;
    d->bufp += n;
    return p;
}
@

\subsection{Unmarshalling and [[drawmesg()]]}

<<[[drawmesg()]] locals>>=
byte *a;
int m = 0;
char *fmt = nil;
@

<<[[drawmesg()]] locals>>=
int c, repl, y, dstid, scrnid, ni, ci, j, nw, e0, e1, op, ox, oy, oesize, esize, doflush;
byte *u, refresh;
ulong value, chan;
Rectangle r, clipr;
Point p, q, *pp, sp;
Memimage *i, *bg, *dst, *src, *mask;
Memimage *l, **lp;
Memscreen *scrn;
DImage *font, *ll, *di, *ddst, *dsrc;
DName *dn;
DScreen *dscrn;
FChar *fc;
Refx *refx;
CScreen *cs;
Refreshfn reffn;
@


% the big one!! this is in kernel!!
<<function drawmesg>>=
void
drawmesg(Client *client, void *av, int n)
{
    <<[[drawmesg()]] locals>>

    a = av;
    if(waserror()){
        if(fmt) 
            printmesg(fmt, a, 1);
    /*  iprint("error: %s\n", up->errstr);  */
        nexterror();
    }
    while((n-=m) > 0){
        USED(fmt);
        a += m;
        switch(*a){
        <<[[drawmesg()]] cases>>
        default:
            error("bad draw command");
        }
    }
    poperror();
}
@


% unmarshallers helpers:

% drawrectangle(), etc

\subsection{Algorithm}

\chapter{Display and Image}

%\section{Display}

\section{Image}

% can have multiple image, draw there, and at some point
% quickly copy on main image (d->image)
% the initial d->image is actually allocated for you

\subsection{API}

<<function allocimage>>=
Image*
allocimage(Display *d, Rectangle r, ulong chan, int repl, ulong val)
{
    Image*	i;

    i =  _allocimage(nil, d, r, chan, repl, val, 0, 0);
    if (i)
        setmalloctag(i, getcallerpc(&d));
    return i;
}
@

<<function freeimage>>=
int
freeimage(Image *i)
{
    int ret;

    ret = _freeimage1(i);
    free(i);
    return ret;
}
@

\subsection{Marshalling}

% ai usually nil
<<function _allocimage>>=
Image*
_allocimage(Image *ai, Display *d, Rectangle r, ulong chan, int repl, ulong val, int screenid, int refresh)
{
    uchar *a;
    char *err;
    Image *i;
    Rectangle clipr;
    int id;
    int depth;

    err = 0;
    i = 0;

    if(chan == 0){
        werrstr("bad channel descriptor");
        return nil;
    }

    depth = chantodepth(chan);
    if(depth == 0){
        err = "bad channel descriptor";
    Error:
        if(err)
            werrstr("allocimage: %s", err);
        else
            werrstr("allocimage: %r");
        free(i);
        return 0;
    }

    /* flush pending data so we don't get error allocating the image */
    flushimage(d, 0);

    a = bufimage(d, 1+4+4+1+4+1+4*4+4*4+4);
    if(a == nil)
        goto Error;
    d->imageid++;
    id = d->imageid;

    a[0] = 'b';
    BPLONG(a+1, id);
    BPLONG(a+5, screenid);
    a[9] = refresh;
    BPLONG(a+10, chan);
    a[14] = repl;
    BPLONG(a+15, r.min.x);
    BPLONG(a+19, r.min.y);
    BPLONG(a+23, r.max.x);
    BPLONG(a+27, r.max.y);
    if(repl)
        /* huge but not infinite, so various offsets will leave it huge, not overflow */
        clipr = Rect(-0x3FFFFFFF, -0x3FFFFFFF, 0x3FFFFFFF, 0x3FFFFFFF);
    else
        clipr = r;
    BPLONG(a+31, clipr.min.x);
    BPLONG(a+35, clipr.min.y);
    BPLONG(a+39, clipr.max.x);
    BPLONG(a+43, clipr.max.y);
    BPLONG(a+47, val);

    if(flushimage(d, 0) < 0)
        goto Error;

    if(ai)
        i = ai;
    else{
        i = malloc(sizeof(Image));
        if(i == nil){
            a = bufimage(d, 1+4);
            if(a){
                a[0] = 'f';
                BPLONG(a+1, id);
                flushimage(d, 0);
            }
            goto Error;
        }
    }

    i->display = d;
    i->id = id;
    i->depth = depth;
    i->chan = chan;
    i->r = r;
    i->clipr = clipr;
    i->repl = repl;
    i->screen = nil;
    i->next = nil;
    return i;
}
@


<<function _freeimage1>>=
int
_freeimage1(Image *i)
{
    uchar *a;
    Display *d;
    Image *w;

    if(i == nil || i->display == nil)
        return 0;

    /* make sure no refresh events occur on this if we block in the write */
    d = i->display;
    /* flush pending data so we don't get error deleting the image */
    flushimage(d, 0);

    a = bufimage(d, 1+4);
    if(a == nil)
        return -1;

    a[0] = 'f';
    BPLONG(a+1, i->id);

    if(i->screen){
        // remove_list(i, d->windows)
        w = d->windows;
        if(w == i)
            d->windows = i->next;
        else
            while(w){
                if(w->next == i){
                    w->next = i->next;
                    break;
                }
                w = w->next;
            }
    }
    if(flushimage(d, i->screen!=0) < 0)
        return -1;

    return 0;
}
@

\subsection{Unmarshalling}

<<[[drawmesg()]] cases>>=
/* new allocate: 'b' id[4] screenid[4] refresh[1] chan[4] repl[1] R[4*4] clipR[4*4] rrggbbaa[4] */
case 'b':
    printmesg(fmt="LLbLbRRL", a, 0);
    m = 1+4+4+1+4+1+4*4+4*4+4;
    if(n < m)
        error(Eshortdraw);
    dstid = BGLONG(a+1);
    scrnid = BGSHORT(a+5);
    refresh = a[9];
    chan = BGLONG(a+10);
    repl = a[14];
    drawrectangle(&r, a+15);
    drawrectangle(&clipr, a+31);
    value = BGLONG(a+47);
    if(drawlookup(client, dstid, 0))
        error(Eimageexists);

    if(scrnid){
        dscrn = drawlookupscreen(client, scrnid, &cs);
        scrn = dscrn->screen;
        if(repl || chan!=scrn->image->chan)
            error("image parameters incompatible with screen");
        reffn = nil;
        switch(refresh){
        case Refbackup:
            break;
        case Refnone:
            reffn = memlnorefresh;
            break;
        case Refmesg:
            reffn = drawrefresh;
            break;
        default:
            error("unknown refresh method");
        }
        l = memlalloc(scrn, r, reffn, 0, value);
        if(l == 0)
            error(Edrawmem);
        addflush(l->layer->screenr);
        l->clipr = clipr;
        rectclip(&l->clipr, r);
        if(drawinstall(client, dstid, l, dscrn) == 0){
            memldelete(l);
            error(Edrawmem);
        }
        dscrn->ref++;
        if(reffn){
            refx = nil;
            if(reffn == drawrefresh){
                refx = malloc(sizeof(Refx));
                if(refx == 0){
                    drawuninstall(client, dstid);
                    error(Edrawmem);
                }
                refx->client = client;
                refx->dimage = drawlookup(client, dstid, 1);
            }
            memlsetrefresh(l, reffn, refx);
        }
        continue;
    }

    i = allocmemimage(r, chan); // The call

    if(i == nil)
        error(Edrawmem);
    if(repl)
        i->flags |= Frepl;
    i->clipr = clipr;
    if(!repl)
        rectclip(&i->clipr, r);

    if(drawinstall(client, dstid, i, 0) == 0){
        freememimage(i);
        error(Edrawmem);
    }
    memfillcolor(i, value);
    continue;
@


<<[[drawmesg()]] cases>>=
/* free: 'f' id[4] */
case 'f':
    printmesg(fmt="L", a, 1);
    m = 1+4;
    if(n < m)
        error(Eshortdraw);
    ll = drawlookup(client, BGLONG(a+1), 0);

    if(ll && ll->dscreen && ll->dscreen->owner != client)
        ll->dscreen->owner->refreshme = 1;

    drawuninstall(client, BGLONG(a+1)); // The call
    continue;

@

\subsection{Algorithm}


%Memdata and then Memimage ctor
% should be called once automatically when one creates a new connection no?
<<function allocmemimage>>=
Memimage*
allocmemimage(Rectangle r, ulong chan)
{
    int d;
    uchar *p;
    ulong l, nw;
    Memdata *md;
    Memimage *i;

    if((d = chantodepth(chan)) == 0) {
        werrstr("bad channel descriptor %.8lux", chan);
        return nil;
    }

    l = wordsperline(r, d);
    nw = l*Dy(r);
    md = malloc(sizeof(Memdata));
    if(md == nil)
        return nil;

    md->ref = 1;
    // the big alloc!
    md->base = poolalloc(imagmem, sizeof(Memdata*)+(1+nw)*sizeof(ulong));
    if(md->base == nil){
        free(md);
        return nil;
    }

    p = (uchar*)md->base;
    *(Memdata**)p = md;
    p += sizeof(Memdata*);

    *(ulong*)p = getcallerpc(&r);
    p += sizeof(ulong);

    /* if this changes, memimagemove must change too */
    md->bdata = p;
    md->allocd = 1;

    i = allocmemimaged(r, chan, md);
    if(i == nil){
        poolfree(imagmem, md->base);
        free(md);
        return nil;
    }
    md->imref = i;
    return i;
}
@

%Memimage ctor
<<function allocmemimaged>>=
Memimage*
allocmemimaged(Rectangle r, ulong chan, Memdata *md)
{
    int d;
    ulong l;
    Memimage *i;

    if(Dx(r) <= 0 || Dy(r) <= 0){
        werrstr("bad rectangle %R", r);
        return nil;
    }
    if((d = chantodepth(chan)) == 0) {
        werrstr("bad channel descriptor %.8lux", chan);
        return nil;
    }

    l = wordsperline(r, d);

    i = mallocz(sizeof(Memimage), 1);
    if(i == nil)
        return nil;

    i->data = md;
    i->zero = sizeof(ulong)*l*r.min.y;
    
    if(r.min.x >= 0)
        i->zero += (r.min.x*d)/8;
    else
        i->zero -= (-r.min.x*d+7)/8;
    i->zero = -i->zero;
    i->width = l;
    i->r = r;
    i->clipr = r;
    i->flags = 0;
    i->layer = nil;
    i->cmap = memdefcmap;
    if(memsetchan(i, chan) < 0){
        free(i);
        return nil;
    }
    return i;
}
@


<<function freememimage>>=
void
freememimage(Memimage *i)
{
    if(i == nil)
        return;
    if(i->data->ref-- == 1 && i->data->allocd){
        if(i->data->base)
            poolfree(imagmem, i->data->base);
        free(i->data);
    }
    free(i);
}
@




<<function drawinstall>>=
Memimage*
drawinstall(Client *client, int id, Memimage *i, DScreen *dscreen)
{
    DImage *d;

    d = allocdimage(i);
    if(d == nil)
        return nil;
    d->id = id;
    d->dscreen = dscreen;
    d->next = client->dimage[id&HASHMASK];
    client->dimage[id&HASHMASK] = d;
    return i;
}
@

<<function allocdimage>>=
DImage*
allocdimage(Memimage *i)
{
    DImage *d;

    d = malloc(sizeof(DImage));
    if(d == 0)
        return 0;
    d->ref = 1;
    d->name = 0;
    d->vers = 0;
    d->image = i;
    d->nfchar = 0;
    d->fchar = 0;
    d->fromname = 0;
    return d;
}
@


<<function drawuninstall>>=
void
drawuninstall(Client *client, int id)
{
    DImage *d, *next;

    d = client->dimage[id&HASHMASK];
    if(d == 0)
        error(Enodrawimage);
    if(d->id == id){
        client->dimage[id&HASHMASK] = d->next;
        drawfreedimage(d);
        return;
    }
    while(next = d->next){  /* assign = */
        if(next->id == id){
            d->next = next->next;
            drawfreedimage(next);
            return;
        }
        d = next;
    }
    error(Enodrawimage);
}
@


<<function drawfreedimage>>=
void
drawfreedimage(DImage *dimage)
{
    int i;
    Memimage *l;
    DScreen *ds;

    dimage->ref--;
    if(dimage->ref < 0)
        print("negative ref in drawfreedimage\n");
    if(dimage->ref > 0)
        return;

    /* any names? */
    for(i=0; i<sdraw.nname; )
        if(sdraw.name[i].dimage == dimage)
            drawdelname(sdraw.name+i);
        else
            i++;
    if(dimage->fromname){   /* acquired by name; owned by someone else*/
        drawfreedimage(dimage->fromname);
        goto Return;
    }
//  if(dimage->image == screenimage)    /* don't free the display */
//      goto Return;
    ds = dimage->dscreen;
    if(ds){
        l = dimage->image;
        if(l->data == screenimage->data)
            addflush(l->layer->screenr);
        if(l->layer->refreshfn == drawrefresh)  /* else true owner will clean up */
            free(l->layer->refreshptr);
        l->layer->refreshptr = nil;
        if(drawgoodname(dimage))
            memldelete(l);
        else
            memlfree(l);
        drawfreedscreen(ds);
    }else
        freememimage(dimage->image);
    Return:
    free(dimage->fchar);
    free(dimage);
}
@


\section{Flush}

\subsection{API}

<<function flushimage>>=
int
flushimage(Display *d, int visible)
{
    if(d == nil)
        return 0;
    if(visible){
        *d->bufp++ = 'v';	/* five bytes always reserved for this */
        if(d->_isnewdisplay){
            BPLONG(d->bufp, d->screenimage->id);
            d->bufp += 4;
        }
    }
    return doflush(d);
}
@

\subsection{Marshalling}

<<function doflush>>=
static
int
doflush(Display *d)
{
    int n, nn;

    n = d->bufp-d->buf;
    if(n <= 0)
        return 1;

    if((nn=write(d->fd, d->buf, n)) != n){
        if(_drawdebug)
            fprint(2, "flushimage fail: d=%p: n=%d nn=%d %r\n", d, n, nn); /**/
        d->bufp = d->buf;	/* might as well; chance of continuing */
        return -1;
    }
    d->bufp = d->buf;
    return 1;
}
@

\subsection{Unmarshalling}

<<[[drawmesg()]] cases>>=
/* visible: 'v' */
case 'v':
    printmesg(fmt="", a, 0);
    m = 1;
    drawflush();
    continue;

@


\subsection{Algorithm}

<<global flushrect>>=
static  Rectangle   flushrect;
@

<<function drawflush>>=
void
drawflush(void)
{
    if(flushrect.min.x < flushrect.max.x)
        flushmemscreen(flushrect);
    flushrect = Rect(10000, 10000, -10000, -10000);
}
@

% 386/screen.c!
<<function flushmemscreen>>=
/*
 * It would be fair to say that this doesn't work for >8-bit screens.
 */
void
flushmemscreen(Rectangle r)
{
    VGAscr *scr;
    uchar *sp, *disp, *sdisp, *edisp;
    int y, len, incs, off, page;

    scr = &vgascreen[0];
    if(scr->dev && scr->dev->flush){
        scr->dev->flush(scr, r);
        return;
    }
    if(scr->gscreen == nil || scr->useflush == 0)
        return;
    if(scr->dev == nil || scr->dev->page == nil)
        return;

    if(rectclip(&r, scr->gscreen->r) == 0)
        return;

    incs = scr->gscreen->width * BY2WD;

    switch(scr->gscreen->depth){
    default:
        len = 0;
        panic("flushmemscreen: depth\n");
        break;
    case 8:
        len = Dx(r);
        break;
    }
    if(len < 1)
        return;

    off = r.min.y*scr->gscreen->width*BY2WD+(r.min.x*scr->gscreen->depth)/8;
    page = off/scr->apsize;
    off %= scr->apsize;
    disp = scr->vaddr;
    sdisp = disp+off;
    edisp = disp+scr->apsize;

    off = r.min.y*scr->gscreen->width*BY2WD+(r.min.x*scr->gscreen->depth)/8;

    sp = scr->gscreendata->bdata + off;

    scr->dev->page(scr, page);
    for(y = r.min.y; y < r.max.y; y++) {
        if(sdisp + incs < edisp) {
            memmove(sdisp, sp, len);
            sp += incs;
            sdisp += incs;
        }
        else {
            off = edisp - sdisp;
            page++;
            if(off <= len){
                if(off > 0)
                    memmove(sdisp, sp, off);
                scr->dev->page(scr, page);
                if(len - off > 0)
                    memmove(disp, sp+off, len - off);
            }
            else {
                memmove(sdisp, sp, len);
                scr->dev->page(scr, page);
            }
            sp += incs;
            sdisp += incs - scr->apsize;
        }
    }
}
@

\chapter{Geometry}

\section{[[Point]]}

<<struct Point>>=
struct	Point
{
    int	x;
    int	y;
};
@
% int! they are pixels!

%ctor
<<function Pt>>=
Point
Pt(int x, int y)
{
    Point p;

    p.x = x;
    p.y = y;
    return p;
}
@


<<function eqpt>>=
int
eqpt(Point p, Point q)
{
    return p.x==q.x && p.y==q.y;
}
@


<<global ZP>>=
Point	ZP;
@

%dumper
<<function Pfmt>>=
int
Pfmt(Fmt *f)
{
    Point p;

    p = va_arg(f->args, Point);
    return fmtprint(f, "[%d %d]", p.x, p.y);
}
@


<<function addpt>>=
Point
addpt(Point a, Point b)
{
    a.x += b.x;
    a.y += b.y;
    return a;
}
@

<<function subpt>>=
Point
subpt(Point a, Point b)
{
    a.x -= b.x;
    a.y -= b.y;
    return a;
}
@

<<function mulpt>>=
Point
mulpt(Point a, int b)
{
    a.x *= b;
    a.y *= b;
    return a;
}
@

<<function divpt>>=
Point
divpt(Point a, int b)
{
    a.x /= b;
    a.y /= b;
    return a;
}
@


\section{Rectangle}

\subsection{[[Rectangle]]}

<<struct Rectangle>>=
struct Rectangle
{
    Point	min;
    Point	max;
};
@

%ctor
<<function Rect>>=
Rectangle
Rect(int x, int y, int bx, int by)
{
    Rectangle r;

    r.min.x = x;
    r.min.y = y;
    r.max.x = bx;
    r.max.y = by;
    return r;
}
@

%ctor
<<function Rpt>>=
Rectangle
Rpt(Point min, Point max)
{
    Rectangle r;

    r.min = min;
    r.max = max;
    return r;
}
@


%dumper
<<function Rfmt>>=
int
Rfmt(Fmt *f)
{
    Rectangle r;

    r = va_arg(f->args, Rectangle);
    return fmtprint(f, "%P %P", r.min, r.max);
}
@


<<function eqrect>>=
int
eqrect(Rectangle r, Rectangle s)
{
    return r.min.x==s.min.x && r.max.x==s.max.x &&
           r.min.y==s.min.y && r.max.y==s.max.y;
}
@


<<global ZR>>=
Rectangle ZR;
@




<<function rectaddpt>>=
Rectangle
rectaddpt(Rectangle r, Point p)
{
    r.min.x += p.x;
    r.min.y += p.y;
    r.max.x += p.x;
    r.max.y += p.y;
    return r;
}
@

<<function rectsubpt>>=
Rectangle
rectsubpt(Rectangle r, Point p)
{
    r.min.x -= p.x;
    r.min.y -= p.y;
    r.max.x -= p.x;
    r.max.y -= p.y;
    return r;
}
@



<<function insetrect>>=
Rectangle
insetrect(Rectangle r, int n)
{
    r.min.x += n;
    r.min.y += n;
    r.max.x -= n;
    r.max.y -= n;
    return r;
}
@


<<function rectXrect>>=
int
rectXrect(Rectangle r, Rectangle s)
{
    return r.min.x<s.max.x && s.min.x<r.max.x &&
           r.min.y<s.max.y && s.min.y<r.max.y;
}
@

<<function rectinrect>>=
int
rectinrect(Rectangle r, Rectangle s)
{
    return s.min.x<=r.min.x && r.max.x<=s.max.x && s.min.y<=r.min.y && r.max.y<=s.max.y;
}
@

<<function ptinrect>>=
int
ptinrect(Point p, Rectangle r)
{
    return p.x>=r.min.x && p.x<r.max.x &&
           p.y>=r.min.y && p.y<r.max.y;
}
@


<<function canonrect>>=
Rectangle
canonrect(Rectangle r)
{
    int t;
    if (r.max.x < r.min.x) {
        t = r.min.x;
        r.min.x = r.max.x;
        r.max.x = t;
    }
    if (r.max.y < r.min.y) {
        t = r.min.y;
        r.min.y = r.max.y;
        r.max.y = t;
    }
    return r;
}
@

<<function combinerect>>=
void
combinerect(Rectangle *r1, Rectangle r2)
{
    if(r1->min.x > r2.min.x)
        r1->min.x = r2.min.x;
    if(r1->min.y > r2.min.y)
        r1->min.y = r2.min.y;
    if(r1->max.x < r2.max.x)
        r1->max.x = r2.max.x;
    if(r1->max.y < r2.max.y)
        r1->max.y = r2.max.y;
}
@



\subsection{API}

%TODO: show toy program and screenshot of the rectangle!


<<function draw>>=
void
draw(Image *dst, Rectangle r, Image *src, Image *mask, Point p1)
{
    draw1(dst, &r, src, &p1, mask, &p1, SoverD);
}
@

<<function border>>=
void
border(Image *im, Rectangle r, int i, Image *color, Point sp)
{
    if(i < 0){
        r = insetrect(r, i);
        sp = addpt(sp, Pt(i,i));
        i = -i;
    }
    draw(im, Rect(r.min.x, r.min.y, r.max.x, r.min.y+i),
        color, nil, sp);
    draw(im, Rect(r.min.x, r.max.y-i, r.max.x, r.max.y),
        color, nil, Pt(sp.x, sp.y+Dy(r)-i));
    draw(im, Rect(r.min.x, r.min.y+i, r.min.x+i, r.max.y-i),
        color, nil, Pt(sp.x, sp.y+i));
    draw(im, Rect(r.max.x-i, r.min.y+i, r.max.x, r.max.y-i),
        color, nil, Pt(sp.x+Dx(r)-i, sp.y+i));
}
@



<<function drawop>>=
void
drawop(Image *dst, Rectangle r, Image *src, Image *mask, Point p1, Drawop op)
{
    draw1(dst, &r, src, &p1, mask, &p1, op);
}
@

<<function gendraw>>=
void
gendraw(Image *dst, Rectangle r, Image *src, Point p0, Image *mask, Point p1)
{
    draw1(dst, &r, src, &p0, mask, &p1, SoverD);
}
@

<<function gendrawop>>=
void
gendrawop(Image *dst, Rectangle r, Image *src, Point p0, Image *mask, Point p1, Drawop op)
{
    draw1(dst, &r, src, &p0, mask, &p1, op);
}
@






\subsection{Marshalling}

<<function draw1>>=
static void
draw1(Image *dst, Rectangle *r, Image *src, Point *p0, Image *mask, Point *p1, Drawop op)
{
    byte *a;

    _setdrawop(dst->display, op);

    a = bufimage(dst->display, 1+4+4+4+4*4+2*4+2*4);
    if(a == nil)
        return;
    if(src == nil)
        src = dst->display->black;
    if(mask == nil)
        mask = dst->display->opaque;

    a[0] = 'd';
    BPLONG(a+1, dst->id);
    BPLONG(a+5, src->id);
    BPLONG(a+9, mask->id);
    BPLONG(a+13, r->min.x);
    BPLONG(a+17, r->min.y);
    BPLONG(a+21, r->max.x);
    BPLONG(a+25, r->max.y);
    BPLONG(a+29, p0->x);
    BPLONG(a+33, p0->y);
    BPLONG(a+37, p1->x);
    BPLONG(a+41, p1->y);
}
@


<<function _setdrawop>>=
void
_setdrawop(Display *d, Drawop op)
{
    uchar *a;

    if(op != SoverD){
        a = bufimage(d, 1+1);
        if(a == 0)
            return;
        a[0] = 'O';
        a[1] = op;
    }
}
@


\subsection{Unmarshalling}


<<[[drawmesg()]] cases>>=
/* draw: 'd' dstid[4] srcid[4] maskid[4] R[4*4] P[2*4] P[2*4] */
case 'd':
    printmesg(fmt="LLLRPP", a, 0);
    m = 1+4+4+4+4*4+2*4+2*4;
    if(n < m)
        error(Eshortdraw);
    dst = drawimage(client, a+1);
    dstid = BGLONG(a+1);
    src = drawimage(client, a+5);
    mask = drawimage(client, a+9);
    drawrectangle(&r, a+13);
    drawpoint(&p, a+29);
    drawpoint(&q, a+37);
    op = drawclientop(client);

    memdraw(dst, r, src, p, mask, q, op); // the call!

    dstflush(dstid, dst, r);
    continue;

@


<<function drawclientop>>=
static int
drawclientop(Client *cl)
{
    int op;

    op = cl->op;
    cl->op = SoverD;
    return op;
}
@


<<[[drawmesg()]] cases>>=
/* set compositing operator for next draw operation: 'O' op */
case 'O':
    printmesg(fmt="b", a, 0);
    m = 1+1;
    if(n < m)
        error(Eshortdraw);
    client->op = a[1];
    continue;
@





% dead? not even mentionned in the draw(5)
% and nothing generate such a message
%<<[[drawmesg()]] cases>>=
%/* create image mask: 'm' newid[4] id[4] */
%case 'm':
%    printmesg("LL", a, 0);
%    m = 4+4;
%    if(n < m)
%        error(Eshortdraw);
%    break;
%@


\subsection{Algorithm}

% actually in memlayer/
<<function memdraw>>=
void
memdraw(Memimage *dst, Rectangle r, Memimage *src, Point p0, Memimage *mask, Point p1, int op)
{
    struct Draw d;
    Rectangle srcr, tr, mr;
    Memlayer *dl, *sl;

    if(drawdebug)
        iprint("memdraw %p %R %p %P %p %P\n", dst, r, src, p0, mask, p1);

    if(mask == nil)
        mask = memopaque;

    if(mask->layer){
if(drawdebug)	iprint("mask->layer != nil\n");
        return;	/* too hard, at least for now */
    }

    Top:
    if(dst->layer==nil && src->layer==nil){
        memimagedraw(dst, r, src, p0, mask, p1, op); // back to memdraw
        return;
    }

    if(drawclip(dst, &r, src, &p0, mask, &p1, &srcr, &mr) == 0){
if(drawdebug)	iprint("drawclip dstcr %R srccr %R maskcr %R\n", dst->clipr, src->clipr, mask->clipr);
        return;
    }

    /*
   * Convert to screen coordinates.
     */
    dl = dst->layer;
    if(dl != nil){
        r.min.x += dl->delta.x;
        r.min.y += dl->delta.y;
        r.max.x += dl->delta.x;
        r.max.y += dl->delta.y;
    }
    Clearlayer:
    if(dl!=nil && dl->clear){
        if(src == dst){
            p0.x += dl->delta.x;
            p0.y += dl->delta.y;
            src = dl->screen->image;
        }
        dst = dl->screen->image;
        goto Top;
    }

    sl = src->layer;
    if(sl != nil){
        p0.x += sl->delta.x;
        p0.y += sl->delta.y;
        srcr.min.x += sl->delta.x;
        srcr.min.y += sl->delta.y;
        srcr.max.x += sl->delta.x;
        srcr.max.y += sl->delta.y;
    }

    /*
     * Now everything is in screen coordinates.
     * mask is an image.  dst and src are images or obscured layers.
     */

    /*
     * if dst and src are the same layer, just draw in save area and expose.
     */
    if(dl!=nil && dst==src){
        if(dl->save == nil)
            return;	/* refresh function makes this case unworkable */
        if(rectXrect(r, srcr)){
            tr = r;
            if(srcr.min.x < tr.min.x){
                p1.x += tr.min.x - srcr.min.x;
                tr.min.x = srcr.min.x;
            }
            if(srcr.min.y < tr.min.y){
                p1.y += tr.min.x - srcr.min.x;
                tr.min.y = srcr.min.y;
            }
            if(srcr.max.x > tr.max.x)
                tr.max.x = srcr.max.x;
            if(srcr.max.y > tr.max.y)
                tr.max.y = srcr.max.y;
            memlhide(dst, tr);
        }else{
            memlhide(dst, r);
            memlhide(dst, srcr);
        }
        memdraw(dl->save, rectsubpt(r, dl->delta), dl->save,
            subpt(srcr.min, src->layer->delta), mask, p1, op);
        memlexpose(dst, r);
        return;
    }

    if(sl){
        if(sl->clear){
            src = sl->screen->image;
            if(dl != nil){
                r.min.x -= dl->delta.x;
                r.min.y -= dl->delta.y;
                r.max.x -= dl->delta.x;
                r.max.y -= dl->delta.y;
            }
            goto Top;
        }
        /* relatively rare case; use save area */
        if(sl->save == nil)
            return;	/* refresh function makes this case unworkable */
        memlhide(src, srcr);
        /* convert back to logical coordinates */
        p0.x -= sl->delta.x;
        p0.y -= sl->delta.y;
        srcr.min.x -= sl->delta.x;
        srcr.min.y -= sl->delta.y;
        srcr.max.x -= sl->delta.x;
        srcr.max.y -= sl->delta.y;
        src = src->layer->save;
    }

    /*
     * src is now an image.  dst may be an image or a clear layer
     */
    if(dst->layer==nil)
        goto Top;
    if(dst->layer->clear)
        goto Clearlayer;

    /*
     * dst is an obscured layer
     */
    d.deltas = subpt(p0, r.min);
    d.deltam = subpt(p1, r.min);
    d.dstlayer = dl;
    d.src = src;
    d.op = op;
    d.mask = mask;
    _memlayerop(ldrawop, dst, r, r, &d);
}
@


% back to memdraw/
% TODO cleanup the comments, use better debug macro
<<function memimagedraw>>=
void
memimagedraw(Memimage *dst, Rectangle r, Memimage *src, Point p0, Memimage *mask, Point p1, int op)
{
    static int n = 0;
    Memdrawparam par;

    if(mask == nil)
        mask = memopaque;

    //DBG	print("memimagedraw %p/%luX %R @ %p %p/%luX %P %p/%luX %P... ", dst, dst->chan, r, dst->data->bdata, src, src->chan, p0, mask, mask->chan, p1);

    if(drawclip(dst, &r, src, &p0, mask, &p1, &par.sr, &par.mr) == 0){
//		if(drawdebug)
//			iprint("empty clipped rectangle\n");
        return;
    }

    if(op < Clear || op > SoverD){
//		if(drawdebug)
//			iprint("op out of range: %d\n", op);
        return;
    }

    par.op = op;
    par.dst = dst;
    par.r = r;
    par.src = src;
    /* par.sr set by drawclip */
    par.mask = mask;
    /* par.mr set by drawclip */

    par.state = 0;
    if(src->flags&Frepl){
        par.state |= Replsrc;
        if(Dx(src->r)==1 && Dy(src->r)==1){
            par.sval = pixelbits(src, src->r.min);
            par.state |= Simplesrc;
            par.srgba = imgtorgba(src, par.sval);
            par.sdval = rgbatoimg(dst, par.srgba);
            if((par.srgba&0xFF) == 0 && (op&DoutS)){
//				if (drawdebug) iprint("fill with transparent source\n");
                return;	/* no-op successfully handled */
            }
        }
    }

    if(mask->flags & Frepl){
        par.state |= Replmask;
        if(Dx(mask->r)==1 && Dy(mask->r)==1){
            par.mval = pixelbits(mask, mask->r.min);
            if(par.mval == 0 && (op&DoutS)){
//				if(drawdebug) iprint("fill with zero mask\n");
                return;	/* no-op successfully handled */
            }
            par.state |= Simplemask;
            if(par.mval == ~0)
                par.state |= Fullmask;
            par.mrgba = imgtorgba(mask, par.mval);
        }
    }

//	if(drawdebug)
//		iprint("dr %R sr %R mr %R...", r, par.sr, par.mr);
    //DBG print("draw dr %R sr %R mr %R %lux\n", r, par.sr, par.mr, par.state);

    /*
     * Now that we've clipped the parameters down to be consistent, we 
     * simply try sub-drawing routines in order until we find one that was able
     * to handle us.  If the sub-drawing routine returns zero, it means it was
     * unable to satisfy the request, so we do not return.
     */

    /*
     * Hardware support.  Each video driver provides this function,
     * which checks to see if there is anything it can help with.
     * There could be an if around this checking to see if dst is in video memory.
     */
    //DBG print("test hwdraw\n");
    if(hwdraw(&par)){
//if(drawdebug) iprint("hw handled\n");
      //DBG print("hwdraw handled\n");
        return;
    }
    /*
     * Optimizations using memmove and memset.
     */
    //DBG print("test memoptdraw\n");
    if(memoptdraw(&par)){
//if(drawdebug) iprint("memopt handled\n");
      //DBG print("memopt handled\n");
        return;
    }

    /*
     * Character drawing.
     * Solid source color being painted through a boolean mask onto a high res image.
     */
    //DBG print("test chardraw\n");
    if(chardraw(&par)){
//if(drawdebug) iprint("chardraw handled\n");
      //DBG print("chardraw handled\n");
        return;
    }

    /*
     * General calculation-laden case that does alpha for each pixel.
     */
    //DBG print("do alphadraw\n");
    alphadraw(&par);
//if(drawdebug) iprint("alphadraw handled\n");
    //DBG print("alphadraw handled\n");
}
@






<<function _memlayerop>>=
/*
 * Assumes incoming rectangle has already been clipped to i's logical r and clipr
 */
void
_memlayerop(
    void (*fn)(Memimage*, Rectangle, Rectangle, void*, int),
    Memimage *i,
    Rectangle screenr,	/* clipped to window boundaries */
    Rectangle clipr,		/* clipped also to clipping rectangles of hierarchy */
    void *etc)
{
    Memlayer *l;
    Rectangle r, scr;

    l = i->layer;
    if(!rectclip(&screenr, l->screenr))
        return;
    if(l->clear){
        fn(l->screen->image, screenr, clipr, etc, 0);
        return;
    }
    r = screenr;
    scr = l->screen->image->clipr;

    /*
     * Do the piece on the screen
     */
    if(rectclip(&screenr, scr))
        _layerop(fn, i, screenr, clipr, etc, l->screen->frontmost);
    if(rectinrect(r, scr))
        return;

    /*
     * Do the piece off the screen
    */
    if(!rectXrect(r, scr)){
        /* completely offscreen; easy */
        fn(l->save, r, clipr, etc, 1);
        return;
    }
    if(r.min.y < scr.min.y){
        /* above screen */
        fn(l->save, Rect(r.min.x, r.min.y, r.max.x, scr.min.y), clipr, etc, 1);
        r.min.y = scr.min.y;
    }
    if(r.max.y > scr.max.y){
        /* below screen */
        fn(l->save, Rect(r.min.x, scr.max.y, r.max.x, r.max.y), clipr, etc, 1);
        r.max.y = scr.max.y;
    }
    if(r.min.x < scr.min.x){
        /* left of screen */
        fn(l->save, Rect(r.min.x, r.min.y, scr.min.x, r.max.y), clipr, etc, 1);
        r.min.x = scr.min.x;
    }
    if(r.max.x > scr.max.x){
        /* right of screen */
        fn(l->save, Rect(scr.max.x, r.min.y, r.max.x, r.max.y), clipr, etc, 1);
    }
}
@


<<function ldrawop>>=
static
void
ldrawop(Memimage *dst, Rectangle screenr, Rectangle clipr, void *etc, int insave)
{
    struct Draw *d;
    Point p0, p1;
    Rectangle oclipr, srcr, r, mr;
    int ok;

    d = etc;
    if(insave && d->dstlayer->save==nil)
        return;

    p0 = addpt(screenr.min, d->deltas);
    p1 = addpt(screenr.min, d->deltam);

    if(insave){
        r = rectsubpt(screenr, d->dstlayer->delta);
        clipr = rectsubpt(clipr, d->dstlayer->delta);
    }else
        r = screenr;

    /* now in logical coordinates */

    /* clipr may have narrowed what we should draw on, so clip if necessary */
    if(!rectinrect(r, clipr)){
        oclipr = dst->clipr;
        dst->clipr = clipr;
        ok = drawclip(dst, &r, d->src, &p0, d->mask, &p1, &srcr, &mr);
        dst->clipr = oclipr;
        if(!ok)
            return;
    }
    memdraw(dst, r, d->src, p0, d->mask, p1, d->op);
}
@




\section{Line}

\subsection{API}

<<function line>>=
void
line(Image *dst, Point p0, Point p1, int end0, int end1, int radius, Image *src, Point sp)
{
    lineop(dst, p0, p1, end0, end1, radius, src, sp, SoverD);
}
@

\subsection{Marshalling}

<<function lineop>>=
void
lineop(Image *dst, Point p0, Point p1, int end0, int end1, int radius, Image *src, Point sp, Drawop op)
{
    uchar *a;

    _setdrawop(dst->display, op);

    a = bufimage(dst->display, 1+4+2*4+2*4+4+4+4+4+2*4);
    if(a == 0){
        fprint(2, "image line: %r\n");
        return;
    }
    a[0] = 'L';
    BPLONG(a+1, dst->id);
    BPLONG(a+5, p0.x);
    BPLONG(a+9, p0.y);
    BPLONG(a+13, p1.x);
    BPLONG(a+17, p1.y);
    BPLONG(a+21, end0);
    BPLONG(a+25, end1);
    BPLONG(a+29, radius);
    BPLONG(a+33, src->id);
    BPLONG(a+37, sp.x);
    BPLONG(a+41, sp.y);
}
@

\subsection{Unmarshalling}

<<[[drawmesg()]] cases>>=
/* draw line: 'L' dstid[4] p0[2*4] p1[2*4] end0[4] end1[4] radius[4] srcid[4] sp[2*4] */
case 'L':
    printmesg(fmt="LPPlllLP", a, 0);
    m = 1+4+2*4+2*4+4+4+4+4+2*4;
    if(n < m)
        error(Eshortdraw);
    dst = drawimage(client, a+1);
    dstid = BGLONG(a+1);
    drawpoint(&p, a+5);
    drawpoint(&q, a+13);
    e0 = BGLONG(a+21);
    e1 = BGLONG(a+25);
    j = BGLONG(a+29);
    if(j < 0)
        error("negative line width");
    src = drawimage(client, a+33);
    drawpoint(&sp, a+37);
    op = drawclientop(client);

    memline(dst, p, q, e0, e1, j, src, sp, op); // The call

    /* avoid memlinebbox if possible */
    if(dstid==0 || dst->layer!=nil){
        /* BUG: this is terribly inefficient: update maximal containing rect*/
        r = memlinebbox(p, q, e0, e1, j);
        dstflush(dstid, dst, insetrect(r, -(1+1+j)));
    }
    continue;

@


\subsection{Algorithm}

<<struct Lline>>=
struct Lline
{
    Point			p0;
    Point			p1;
    Point			delta;
    int			end0;
    int			end1;
    int			radius;
    Point			sp;
    Memlayer		*dstlayer;
    Memimage	*src;
    int			op;
};
@

% memlayer/
<<function memline>>=
void
memline(Memimage *dst, Point p0, Point p1, int end0, int end1, int radius, Memimage *src, Point sp, int op)
{
    _memline(dst, p0, p1, end0, end1, radius, src, sp, dst->clipr, op);
}
@

<<function _memline>>=
static
void
_memline(Memimage *dst, Point p0, Point p1, int end0, int end1, int radius, Memimage *src, Point sp, Rectangle clipr, int op)
{
    Rectangle r;
    struct Lline ll;
    Point d;
    int srcclipped;
    Memlayer *dl;

    if(radius < 0)
        return;
    if(src->layer)	/* can't draw line with layered source */
        return;
    srcclipped = 0;

   Top:
    dl = dst->layer;
    if(dl == nil){
        // back to memdraw/
        _memimageline(dst, p0, p1, end0, end1, radius, src, sp, clipr, op);
        return;
    }
    if(!srcclipped){
        d = subpt(sp, p0);
        if(rectclip(&clipr, rectsubpt(src->clipr, d)) == 0)
            return;
        if((src->flags&Frepl)==0 && rectclip(&clipr, rectsubpt(src->r, d))==0)
            return;
        srcclipped = 1;
    }

    /* dst is known to be a layer */
    p0.x += dl->delta.x;
    p0.y += dl->delta.y;
    p1.x += dl->delta.x;
    p1.y += dl->delta.y;
    clipr.min.x += dl->delta.x;
    clipr.min.y += dl->delta.y;
    clipr.max.x += dl->delta.x;
    clipr.max.y += dl->delta.y;
    if(dl->clear){
        dst = dst->layer->screen->image;
        goto Top;
    }

    /* XXX */
    /* this is not the correct set of tests */
//	if(log2[dst->depth] != log2[src->depth] || log2[dst->depth]!=3)
//		return;

    /* can't use sutherland-cohen clipping because lines are wide */
    r = memlinebbox(p0, p1, end0, end1, radius);
    /*
     * r is now a bounding box for the line;
     * use it as a clipping rectangle for subdivision
     */
    if(rectclip(&r, clipr) == 0)
        return;
    ll.p0 = p0;
    ll.p1 = p1;
    ll.end0 = end0;
    ll.end1 = end1;
    ll.sp = sp;
    ll.dstlayer = dst->layer;
    ll.src = src;
    ll.radius = radius;
    ll.delta = dl->delta;
    ll.op = op;
    _memlayerop(llineop, dst, r, r, &ll);
}
@




<<function llineop>>=
static
void
llineop(Memimage *dst, Rectangle screenr, Rectangle clipr, void *etc, int insave)
{
    struct Lline *ll;
    Point p0, p1;

    USED(screenr.min.x);
    ll = etc;
    if(insave && ll->dstlayer->save==nil)
        return;
    if(!rectclip(&clipr, screenr))
        return;
    if(insave){
        p0 = subpt(ll->p0, ll->delta);
        p1 = subpt(ll->p1, ll->delta);
        clipr = rectsubpt(clipr, ll->delta);
    }else{
        p0 = ll->p0;
        p1 = ll->p1;
    }
    // recurse
    _memline(dst, p0, p1, ll->end0, ll->end1, ll->radius, ll->src, ll->sp, clipr, ll->op);
}
@








% back to memdraw/

<<function _memimageline>>=
void
_memimageline(Memimage *dst, Point p0, Point p1, int end0, int end1, int radius, Memimage *src, Point sp, Rectangle clipr, int op)
{
    /*
     * BUG: We should really really pick off purely horizontal and purely
     * vertical lines and handle them separately with calls to memimagedraw
     * on rectangles.
     */

    int hor;
    int sin, cos, dx, dy, t;
    Rectangle oclipr, r;
    Point q, pts[10], *pp, d;

    if(radius < 0)
        return;
    if(rectclip(&clipr, dst->r) == 0)
        return;
    if(rectclip(&clipr, dst->clipr) == 0)
        return;
    d = subpt(sp, p0);
    if(rectclip(&clipr, rectsubpt(src->clipr, d)) == 0)
        return;
    if((src->flags&Frepl)==0 && rectclip(&clipr, rectsubpt(src->r, d))==0)
        return;
    /* this means that only verline() handles degenerate lines (p0==p1) */
    hor = (abs(p1.x-p0.x) > abs(p1.y-p0.y));
    /*
     * Clipping is a little peculiar.  We can't use Sutherland-Cohen
     * clipping because lines are wide.  But this is probably just fine:
     * we do all math with the original p0 and p1, but clip when deciding
     * what pixels to draw.  This means the layer code can call this routine,
     * using clipr to define the region being written, and get the same set
     * of pixels regardless of the dicing.
     */
    if((hor && p0.x>p1.x) || (!hor && p0.y>p1.y)){
        q = p0;
        p0 = p1;
        p1 = q;
        t = end0;
        end0 = end1;
        end1 = t;
    }

    if((p0.x == p1.x || p0.y == p1.y) && (end0&0x1F) == Endsquare && (end1&0x1F) == Endsquare){
        r.min = p0;
        r.max = p1;
        if(p0.x == p1.x){
            r.min.x -= radius;
            r.max.x += radius+1;
        }
        else{
            r.min.y -= radius;
            r.max.y += radius+1;
        }
        oclipr = dst->clipr;
        sp = addpt(r.min, d);
        dst->clipr = clipr;
        memimagedraw(dst, r, src, sp, memopaque, sp, op);
        dst->clipr = oclipr;
        return;
    }

/*    Hard: */
    /* draw thick line using polygon fill */
    icossin2(p1.x-p0.x, p1.y-p0.y, &cos, &sin);
    dx = (sin*(2*radius+1))/2;
    dy = (cos*(2*radius+1))/2;
    pp = pts;
    oclipr = dst->clipr;
    dst->clipr = clipr;
    q.x = ICOSSCALE*p0.x+ICOSSCALE/2-cos/2;
    q.y = ICOSSCALE*p0.y+ICOSSCALE/2-sin/2;
    switch(end0 & 0x1F){
    case Enddisc:
        discend(p0, radius, dst, src, d, op);
        /* fall through */
    case Endsquare:
    default:
        pp->x = q.x-dx;
        pp->y = q.y+dy;
        pp++;
        pp->x = q.x+dx;
        pp->y = q.y-dy;
        pp++;
        break;
    case Endarrow:
        arrowend(q, pp, end0, -sin, -cos, radius);
        _memfillpolysc(dst, pts, 5, ~0, src, addpt(pts[0], mulpt(d, ICOSSCALE)), 1, 10, 1, op);
        pp[1] = pp[4];
        pp += 2;
    }
    q.x = ICOSSCALE*p1.x+ICOSSCALE/2+cos/2;
    q.y = ICOSSCALE*p1.y+ICOSSCALE/2+sin/2;
    switch(end1 & 0x1F){
    case Enddisc:
        discend(p1, radius, dst, src, d, op);
        /* fall through */
    case Endsquare:
    default:
        pp->x = q.x+dx;
        pp->y = q.y-dy;
        pp++;
        pp->x = q.x-dx;
        pp->y = q.y+dy;
        pp++;
        break;
    case Endarrow:
        arrowend(q, pp, end1, sin, cos, radius);
        _memfillpolysc(dst, pp, 5, ~0, src, addpt(pp[0], mulpt(d, ICOSSCALE)), 1, 10, 1, op);
        pp[1] = pp[4];
        pp += 2;
    }
    _memfillpolysc(dst, pts, pp-pts, ~0, src, addpt(pts[0], mulpt(d, ICOSSCALE)), 0, 10, 1, op);
    dst->clipr = oclipr;
    return;
}
@


<<function discend>>=
static
void
discend(Point p, int radius, Memimage *dst, Memimage *src, Point dsrc, int op)
{
    Memimage *disc;
    Rectangle r;

    disc = membrush(radius);
    if(disc != nil){
        r.min.x = p.x - radius;
        r.min.y = p.y - radius;
        r.max.x = p.x + radius+1;
        r.max.y = p.y + radius+1;
        memdraw(dst, r, src, addpt(r.min, dsrc), disc, Pt(0,0), op);
    }
}
@

<<function membrush>>=
static Memimage*
membrush(int radius)
{
    static Memimage *brush;
    static int brushradius;

    if(brush==nil || brushradius!=radius){
        freememimage(brush);
        brush = allocmemimage(Rect(0, 0, 2*radius+1, 2*radius+1), memopaque->chan);
        if(brush != nil){
            memfillcolor(brush, DTransparent);	/* zeros */
            memellipse(brush, Pt(radius, radius), radius, radius, -1, memopaque, Pt(radius, radius), S);
        }
        brushradius = radius;
    }
    return brush;
}
@


<<function arrowend>>=
static
void
arrowend(Point tip, Point *pp, int end, int sin, int cos, int radius)
{
    int x1, x2, x3;

    /* before rotation */
    if(end == Endarrow){
        x1 = Arrow1;
        x2 = Arrow2;
        x3 = Arrow3;
    }else{
        x1 = (end>>5) & 0x1FF;	/* distance along line from end of line to tip */
        x2 = (end>>14) & 0x1FF;	/* distance along line from barb to tip */
        x3 = (end>>23) & 0x1FF;	/* distance perpendicular from edge of line to barb */
    }

    /* comments follow track of right-facing arrowhead */
    pp->x = tip.x+((2*radius+1)*sin/2-x1*cos);		/* upper side of shaft */
    pp->y = tip.y-((2*radius+1)*cos/2+x1*sin);
    pp++;
    pp->x = tip.x+((2*radius+2*x3+1)*sin/2-x2*cos);		/* upper barb */
    pp->y = tip.y-((2*radius+2*x3+1)*cos/2+x2*sin);
    pp++;
    pp->x = tip.x;
    pp->y = tip.y;
    pp++;
    pp->x = tip.x+(-(2*radius+2*x3+1)*sin/2-x2*cos);	/* lower barb */
    pp->y = tip.y-(-(2*radius+2*x3+1)*cos/2+x2*sin);
    pp++;
    pp->x = tip.x+(-(2*radius+1)*sin/2-x1*cos);		/* lower side of shaft */
    pp->y = tip.y+((2*radius+1)*cos/2-x1*sin);
}
@


<<function addbbox>>=
/*
 * Simple-minded conservative code to compute bounding box of line.
 * Result is probably a little larger than it needs to be.
 */
static
void
addbbox(Rectangle *r, Point p)
{
    if(r->min.x > p.x)
        r->min.x = p.x;
    if(r->min.y > p.y)
        r->min.y = p.y;
    if(r->max.x < p.x+1)
        r->max.x = p.x+1;
    if(r->max.y < p.y+1)
        r->max.y = p.y+1;
}
@

<<function memlineendsize>>=
int
memlineendsize(int end)
{
    int x3;

    if((end&0x3F) != Endarrow)
        return 0;
    if(end == Endarrow)
        x3 = Arrow3;
    else
        x3 = (end>>23) & 0x1FF;
    return x3;
}
@

<<function memlinebbox>>=
Rectangle
memlinebbox(Point p0, Point p1, int end0, int end1, int radius)
{
    Rectangle r, r1;
    int extra;

    r.min.x = 10000000;
    r.min.y = 10000000;
    r.max.x = -10000000;
    r.max.y = -10000000;
    extra = lmax(memlineendsize(end0), memlineendsize(end1));
    r1 = insetrect(canonrect(Rpt(p0, p1)), -(radius+extra));
    addbbox(&r, r1.min);
    addbbox(&r, r1.max);
    return r;
}
@


\section{Polyline}

\subsection{API}

<<function poly>>=
void
poly(Image *dst, Point *p, int np, int end0, int end1, int radius, Image *src, Point sp)
{
    dopoly('p', dst, p, np, end0, end1, radius, src, &sp, SoverD);
}
@

<<function polyop>>=
void
polyop(Image *dst, Point *p, int np, int end0, int end1, int radius, Image *src, Point sp, Drawop op)
{
    dopoly('p', dst, p, np, end0, end1, radius, src, &sp, op);
}
@

<<function fillpoly>>=
void
fillpoly(Image *dst, Point *p, int np, int wind, Image *src, Point sp)
{
    dopoly('P', dst, p, np, wind, 0, 0, src, &sp, SoverD);
}
@

<<function fillpolyop>>=
void
fillpolyop(Image *dst, Point *p, int np, int wind, Image *src, Point sp, Drawop op)
{
    dopoly('P', dst, p, np, wind, 0, 0, src, &sp, op);
}
@

\subsection{Marshalling}

<<function dopoly>>=
static
void
dopoly(int cmd, Image *dst, Point *pp, int np, int end0, int end1, int radius, Image *src, Point *sp, Drawop op)
{
    uchar *a, *t, *u;
    int i, ox, oy;

    if(np == 0)
        return;
    t = malloc(np*2*3);
    if(t == nil)
        return;
    u = t;
    ox = oy = 0;
    for(i=0; i<np; i++){
        u = addcoord(u, ox, pp[i].x);
        ox = pp[i].x;
        u = addcoord(u, oy, pp[i].y);
        oy = pp[i].y;
    }

    _setdrawop(dst->display, op);

    a = bufimage(dst->display, 1+4+2+4+4+4+4+2*4+(u-t));
    if(a == 0){
        free(t);
        fprint(2, "image poly: %r\n");
        return;
    }
    a[0] = cmd;
    BPLONG(a+1, dst->id);
    BPSHORT(a+5, np-1);
    BPLONG(a+7, end0);
    BPLONG(a+11, end1);
    BPLONG(a+15, radius);
    BPLONG(a+19, src->id);
    BPLONG(a+23, sp->x);
    BPLONG(a+27, sp->y);
    memmove(a+31, t, u-t);
    free(t);
}
@

% dopoly -> <>
<<function addcoord>>=
static
uchar*
addcoord(uchar *p, int oldx, int newx)
{
    int dx;

    dx = newx-oldx;
    /* does dx fit in 7 signed bits? */
    if((unsigned)(dx - -0x40) <= 0x7F)
        *p++ = dx&0x7F;
    else{
        *p++ = 0x80 | (newx&0x7F);
        *p++ = newx>>7;
        *p++ = newx>>15;
    }
    return p;
}
@

\subsection{Unmarshalling}


<<[[drawmesg()]] cases>>=
/* filled polygon: 'P' dstid[4] n[2] wind[4] ignore[2*4] srcid[4] sp[2*4] p0[2*4] dp[2*2*n] */
/* polygon: 'p' dstid[4] n[2] end0[4] end1[4] radius[4] srcid[4] sp[2*4] p0[2*4] dp[2*2*n] */
case 'p':
case 'P':
    printmesg(fmt="LslllLPP", a, 0);
    m = 1+4+2+4+4+4+4+2*4;
    if(n < m)
        error(Eshortdraw);
    dstid = BGLONG(a+1);
    dst = drawimage(client, a+1);
    ni = BGSHORT(a+5);
    if(ni < 0)
        error("negative count in polygon");
    e0 = BGLONG(a+7);
    e1 = BGLONG(a+11);
    j = 0;
    if(*a == 'p'){
        j = BGLONG(a+15);
        if(j < 0)
            error("negative polygon line width");
    }
    src = drawimage(client, a+19);
    drawpoint(&sp, a+23);
    drawpoint(&p, a+31);
    ni++;
    pp = malloc(ni*sizeof(Point));
    if(pp == nil)
        error(Enomem);
    doflush = false;
    if(dstid==0 || (dst->layer && dst->layer->screen->image->data == screenimage->data))
        doflush = true;    /* simplify test in loop */
    ox = oy = 0;
    esize = 0;
    u = a+m;
    for(y=0; y<ni; y++){
        q = p;
        oesize = esize;
        u = drawcoord(u, a+n, ox, &p.x);
        u = drawcoord(u, a+n, oy, &p.y);
        ox = p.x;
        oy = p.y;
        if(doflush){
            esize = j;
            if(*a == 'p'){
                if(y == 0){
                    c = memlineendsize(e0);
                    if(c > esize)
                        esize = c;
                }
                if(y == ni-1){
                    c = memlineendsize(e1);
                    if(c > esize)
                        esize = c;
                }
            }
            if(*a=='P' && e0!=1 && e0 !=~0)
                r = dst->clipr;
            else if(y > 0){
                r = Rect(q.x-oesize, q.y-oesize, q.x+oesize+1, q.y+oesize+1);
                combinerect(&r, Rect(p.x-esize, p.y-esize, p.x+esize+1, p.y+esize+1));
            }
            if(rectclip(&r, dst->clipr))        /* should perhaps be an arg to dstflush */
                dstflush(dstid, dst, r);
        }
        pp[y] = p;
    }
    if(y == 1)
        dstflush(dstid, dst, Rect(p.x-esize, p.y-esize, p.x+esize+1, p.y+esize+1));
    op = drawclientop(client);

    if(*a == 'p')
        mempoly(dst, pp, ni, e0, e1, j, src, sp, op); // The call
    else
        memfillpoly(dst, pp, ni, e0, src, sp, op); // The call
    free(pp);
    m = u-a;
    continue;

@

\subsection{Algorithm}

<<function mempoly>>=
void
mempoly(Memimage *dst, Point *vert, int nvert, int end0, int end1, int radius, Memimage *src, Point sp, int op)
{
    int i, e0, e1;
    Point d;

    if(nvert < 2)
        return;
    d = subpt(sp, vert[0]);
    for(i=1; i<nvert; i++){
        e0 = e1 = Enddisc;
        if(i == 1)
            e0 = end0;
        if(i == nvert-1)
            e1 = end1;
        memline(dst, vert[i-1], vert[i], e0, e1, radius, src, addpt(d, vert[i-1]), op);
    }
}
@

<<function memfillpoly>>=
void
memfillpoly(Memimage *dst, Point *vert, int nvert, int w, Memimage *src, Point sp, int op)
{
    _memfillpolysc(dst, vert, nvert, w, src, sp, 0, 0, 0, op);
}
@

<<function _memfillpolysc>>=
void
_memfillpolysc(Memimage *dst, Point *vert, int nvert, int w, Memimage *src, Point sp, int detail, int fixshift, int clipped, int op)
{
    Seg **seg, *segtab;
    Point p0;
    int i;

    if(nvert == 0)
        return;

    seg = malloc((nvert+2)*sizeof(Seg*));
    if(seg == nil)
        return;
    segtab = malloc((nvert+1)*sizeof(Seg));
    if(segtab == nil) {
        free(seg);
        return;
    }

    sp.x = (sp.x - vert[0].x) >> fixshift;
    sp.y = (sp.y - vert[0].y) >> fixshift;
    p0 = vert[nvert-1];
    if(!fixshift) {
        p0.x <<= 1;
        p0.y <<= 1;
    }
    for(i = 0; i < nvert; i++) {
        segtab[i].p0 = p0;
        p0 = vert[i];
        if(!fixshift) {
            p0.x <<= 1;
            p0.y <<= 1;
        }
        segtab[i].p1 = p0;
        segtab[i].d = 1;
    }
    if(!fixshift)
        fixshift = 1;

    xscan(dst, seg, segtab, nvert, w, src, sp, detail, fixshift, clipped, op);
    if(detail)
        yscan(dst, seg, segtab, nvert, w, src, sp, fixshift, op);

    free(seg);
    free(segtab);
}
@
% >> >> >> >>

<<function xscan>>=
static void
xscan(Memimage *dst, Seg **seg, Seg *segtab, int nseg, int wind, Memimage *src, Point sp, int detail, int fixshift, int clipped, int op)
{
    long y, maxy, x, x2, xerr, xden, onehalf;
    Seg **ep, **next, **p, **q, *s;
    long n, i, iy, cnt, ix, ix2, minx, maxx;
    Point pt;
    void	(*fill)(Memimage*, int, int, int, Memimage*, Point, int);

    fill = fillline;
/*
 * This can only work on 8-bit destinations, since fillcolor is
 * just using memset on sp.x.
 *
 * I'd rather not even enable it then, since then if the general
 * code is too slow, someone will come up with a better improvement
 * than this sleazy hack.	-rsc
 *
    if(clipped && (src->flags&Frepl) && src->depth==8 && Dx(src->r)==1 && Dy(src->r)==1) {
        fill = fillcolor;
        sp.x = membyteval(src);
    }
 *
 */
    USED(clipped);


    for(i=0, s=segtab, p=seg; i<nseg; i++, s++) {
        *p = s;
        if(s->p0.y == s->p1.y)
            continue;
        if(s->p0.y > s->p1.y) {
            pt = s->p0;
            s->p0 = s->p1;
            s->p1 = pt;
            s->d = -s->d;
        }
        s->num = s->p1.x - s->p0.x;
        s->den = s->p1.y - s->p0.y;
        s->dz = sdiv(s->num, s->den) << fixshift;
        s->dzrem = mod(s->num, s->den) << fixshift;
        s->dz += sdiv(s->dzrem, s->den);
        s->dzrem = mod(s->dzrem, s->den);
        p++;
    }
    n = p-seg;
    if(n == 0)
        return;
    *p = 0;
    qsort(seg, p-seg , sizeof(Seg*), ycompare);

    onehalf = 0;
    if(fixshift)
        onehalf = 1 << (fixshift-1);

    minx = dst->clipr.min.x;
    maxx = dst->clipr.max.x;

    y = seg[0]->p0.y;
    if(y < (dst->clipr.min.y << fixshift))
        y = dst->clipr.min.y << fixshift;
    iy = (y + onehalf) >> fixshift;
    y = (iy << fixshift) + onehalf;
    maxy = dst->clipr.max.y << fixshift;

    ep = next = seg;

    while(y<maxy) {
        for(q = p = seg; p < ep; p++) {
            s = *p;
            if(s->p1.y < y)
                continue;
            s->z += s->dz;
            s->zerr += s->dzrem;
            if(s->zerr >= s->den) {
                s->z++;
                s->zerr -= s->den;
                if(s->zerr < 0 || s->zerr >= s->den)
                    print("bad ratzerr1: %ld den %ld dzrem %ld\n", s->zerr, s->den, s->dzrem);
            }
            *q++ = s;
        }

        for(p = next; *p; p++) {
            s = *p;
            if(s->p0.y >= y)
                break;
            if(s->p1.y < y)
                continue;
            s->z = s->p0.x;
            s->z += smuldivmod(y - s->p0.y, s->num, s->den, &s->zerr);
            if(s->zerr < 0 || s->zerr >= s->den)
                print("bad ratzerr2: %ld den %ld ratdzrem %ld\n", s->zerr, s->den, s->dzrem);
            *q++ = s;
        }
        ep = q;
        next = p;

        if(ep == seg) {
            if(*next == 0)
                break;
            iy = (next[0]->p0.y + onehalf) >> fixshift;
            y = (iy << fixshift) + onehalf;
            continue;
        }

        zsort(seg, ep);

        for(p = seg; p < ep; p++) {
            cnt = 0;
            x = p[0]->z;
            xerr = p[0]->zerr;
            xden = p[0]->den;
            ix = (x + onehalf) >> fixshift;
            if(ix >= maxx)
                break;
            if(ix < minx)
                ix = minx;
            cnt += p[0]->d;
            p++;
            for(;;) {
                if(p == ep) {
                    print("xscan: fill to infinity");
                    return;
                }
                cnt += p[0]->d;
                if((cnt&wind) == 0)
                    break;
                p++;
            }
            x2 = p[0]->z;
            ix2 = (x2 + onehalf) >> fixshift;
            if(ix2 <= minx)
                continue;
            if(ix2 > maxx)
                ix2 = maxx;
            if(ix == ix2 && detail) {
                if(xerr*p[0]->den + p[0]->zerr*xden > p[0]->den*xden)
                    x++;
                ix = (x + x2) >> (fixshift+1);
                ix2 = ix+1;
            }
            (*fill)(dst, ix, ix2, iy, src, sp, op);
        }
        y += (1<<fixshift);
        iy++;
    }
}
@
% >>

<<function yscan>>=
static void
yscan(Memimage *dst, Seg **seg, Seg *segtab, int nseg, int wind, Memimage *src, Point sp, int fixshift, int op)
{
    long x, maxx, y, y2, yerr, yden, onehalf;
    Seg **ep, **next, **p, **q, *s;
    int n, i, ix, cnt, iy, iy2, miny, maxy;
    Point pt;

    for(i=0, s=segtab, p=seg; i<nseg; i++, s++) {
        *p = s;
        if(s->p0.x == s->p1.x)
            continue;
        if(s->p0.x > s->p1.x) {
            pt = s->p0;
            s->p0 = s->p1;
            s->p1 = pt;
            s->d = -s->d;
        }
        s->num = s->p1.y - s->p0.y;
        s->den = s->p1.x - s->p0.x;
        s->dz = sdiv(s->num, s->den) << fixshift;
        s->dzrem = mod(s->num, s->den) << fixshift;
        s->dz += sdiv(s->dzrem, s->den);
        s->dzrem = mod(s->dzrem, s->den);
        p++;
    }
    n = p-seg;
    if(n == 0)
        return;
    *p = 0;
    qsort(seg, n , sizeof(Seg*), xcompare);

    onehalf = 0;
    if(fixshift)
        onehalf = 1 << (fixshift-1);

    miny = dst->clipr.min.y;
    maxy = dst->clipr.max.y;

    x = seg[0]->p0.x;
    if(x < (dst->clipr.min.x << fixshift))
        x = dst->clipr.min.x << fixshift;
    ix = (x + onehalf) >> fixshift;
    x = (ix << fixshift) + onehalf;
    maxx = dst->clipr.max.x << fixshift;

    ep = next = seg;

    while(x<maxx) {
        for(q = p = seg; p < ep; p++) {
            s = *p;
            if(s->p1.x < x)
                continue;
            s->z += s->dz;
            s->zerr += s->dzrem;
            if(s->zerr >= s->den) {
                s->z++;
                s->zerr -= s->den;
                if(s->zerr < 0 || s->zerr >= s->den)
                    print("bad ratzerr1: %ld den %ld ratdzrem %ld\n", s->zerr, s->den, s->dzrem);
            }
            *q++ = s;
        }

        for(p = next; *p; p++) {
            s = *p;
            if(s->p0.x >= x)
                break;
            if(s->p1.x < x)
                continue;
            s->z = s->p0.y;
            s->z += smuldivmod(x - s->p0.x, s->num, s->den, &s->zerr);
            if(s->zerr < 0 || s->zerr >= s->den)
                print("bad ratzerr2: %ld den %ld ratdzrem %ld\n", s->zerr, s->den, s->dzrem);
            *q++ = s;
        }
        ep = q;
        next = p;

        if(ep == seg) {
            if(*next == 0)
                break;
            ix = (next[0]->p0.x + onehalf) >> fixshift;
            x = (ix << fixshift) + onehalf;
            continue;
        }

        zsort(seg, ep);

        for(p = seg; p < ep; p++) {
            cnt = 0;
            y = p[0]->z;
            yerr = p[0]->zerr;
            yden = p[0]->den;
            iy = (y + onehalf) >> fixshift;
            if(iy >= maxy)
                break;
            if(iy < miny)
                iy = miny;
            cnt += p[0]->d;
            p++;
            for(;;) {
                if(p == ep) {
                    print("yscan: fill to infinity");
                    return;
                }
                cnt += p[0]->d;
                if((cnt&wind) == 0)
                    break;
                p++;
            }
            y2 = p[0]->z;
            iy2 = (y2 + onehalf) >> fixshift;
            if(iy2 <= miny)
                continue;
            if(iy2 > maxy)
                iy2 = maxy;
            if(iy == iy2) {
                if(yerr*p[0]->den + p[0]->zerr*yden > p[0]->den*yden)
                    y++;
                iy = (y + y2) >> (fixshift+1);
                fillpoint(dst, ix, iy, src, sp, op);
            }
        }
        x += (1<<fixshift);
        ix++;
    }
}
@
% >>


\section{Ellipse}

\subsection{API}

<<function ellipse>>=
void
ellipse(Image *dst, Point c, int a, int b, int thick, Image *src, Point sp)
{
    doellipse('e', dst, &c, a, b, thick, src, &sp, 0, 0, SoverD);
}
@

<<function ellipseop>>=
void
ellipseop(Image *dst, Point c, int a, int b, int thick, Image *src, Point sp, Drawop op)
{
    doellipse('e', dst, &c, a, b, thick, src, &sp, 0, 0, op);
}
@

<<function fillellipse>>=
void
fillellipse(Image *dst, Point c, int a, int b, Image *src, Point sp)
{
    doellipse('E', dst, &c, a, b, 0, src, &sp, 0, 0, SoverD);
}
@

<<function fillellipseop>>=
void
fillellipseop(Image *dst, Point c, int a, int b, Image *src, Point sp, Drawop op)
{
    doellipse('E', dst, &c, a, b, 0, src, &sp, 0, 0, op);
}
@


\subsection{Marshalling}

<<function doellipse>>=
static
void
doellipse(int cmd, Image *dst, Point *c, int xr, int yr, int thick, Image *src, Point *sp, int alpha, int phi, Drawop op)
{
    uchar *a;

    _setdrawop(dst->display, op);

    a = bufimage(dst->display, 1+4+4+2*4+4+4+4+2*4+2*4);
    if(a == 0){
        fprint(2, "image ellipse: %r\n");
        return;
    }
    a[0] = cmd;
    BPLONG(a+1, dst->id);
    BPLONG(a+5, src->id);
    BPLONG(a+9, c->x);
    BPLONG(a+13, c->y);
    BPLONG(a+17, xr);
    BPLONG(a+21, yr);
    BPLONG(a+25, thick);
    BPLONG(a+29, sp->x);
    BPLONG(a+33, sp->y);
    BPLONG(a+37, alpha);
    BPLONG(a+41, phi);
}
@

\subsection{Unmarshalling}


<<[[drawmesg()]] cases>>=
/* ellipse: 'e' dstid[4] srcid[4] center[2*4] a[4] b[4] thick[4] sp[2*4] alpha[4] phi[4]*/
case 'e':
case 'E':
    printmesg(fmt="LLPlllPll", a, 0);
    m = 1+4+4+2*4+4+4+4+2*4+2*4;
    if(n < m)
        error(Eshortdraw);
    dst = drawimage(client, a+1);
    dstid = BGLONG(a+1);
    src = drawimage(client, a+5);
    drawpoint(&p, a+9);
    e0 = BGLONG(a+17);
    e1 = BGLONG(a+21);
    if(e0<0 || e1<0)
        error("invalid ellipse semidiameter");
    j = BGLONG(a+25);
    if(j < 0)
        error("negative ellipse thickness");
    drawpoint(&sp, a+29);
    c = j;
    if(*a == 'E')
        c = -1;
    ox = BGLONG(a+37);
    oy = BGLONG(a+41);
    op = drawclientop(client);
    /* high bit indicates arc angles are present */

    if(ox & (1<<31)){
        if((ox & (1<<30)) == 0)
            ox &= ~(1<<31);
        memarc(dst, p, e0, e1, c, src, sp, ox, oy, op); // The call
    }else
        memellipse(dst, p, e0, e1, c, src, sp, op); // The call

    dstflush(dstid, dst, Rect(p.x-e0-j, p.y-e1-j, p.x+e0+j+1, p.y+e1+j+1));

    continue;
@
% >> >> >>


\subsection{Algorithm}

<<struct ParamEllipse>>=
struct ParamEllipse {
    Memimage	*dst;
    Memimage	*src;
    Point			c;
    int			t;
    Point			sp;
    Memimage	*disc;
    int			op;
};
@

<<struct State>>=
/*
 * denote residual error by e(x,y) = b^2*x^2 + a^2*y^2 - a^2*b^2
 * e(x,y) = 0 on ellipse, e(x,y) < 0 inside, e(x,y) > 0 outside
 */
struct State {
    int	a;
    int	x;
    vlong	a2;	/* a^2 */
    vlong	b2;	/* b^2 */
    vlong	b2x;	/* b^2 * x */
    vlong	a2y;	/* a^2 * y */
    vlong	c1;
    vlong	c2;	/* test criteria */
    vlong	ee;	/* ee = e(x+1/2,y-1/2) - (a^2+b^2)/4 */
    vlong	dxe;
    vlong	dye;
    vlong	d2xe;
    vlong	d2ye;
};
@

<<function newstate>>=
static
State*
newstate(State *s, int a, int b)
{
    s->x = 0;
    s->a = a;
    s->a2 = (vlong)(a*a);
    s->b2 = (vlong)(b*b);
    s->b2x = (vlong)0;
    s->a2y = s->a2*(vlong)b;
    s->c1 = -((s->a2>>2) + (vlong)(a&1) + s->b2);
    s->c2 = -((s->b2>>2) + (vlong)(b&1));
    s->ee = -s->a2y;
    s->dxe = (vlong)0;
    s->dye = s->ee<<1;
    s->d2xe = s->b2<<1;
    s->d2ye = s->a2<<1;
    return s;
}
@
% >> >> >> 


<<function memellipse>>=
void
memellipse(Memimage *dst, Point c, int a, int b, int t, Memimage *src, Point sp, int op)
{
    State in, out;
    int y, inb, inx, outx, u;
    Param p;

    if(a < 0)
        a = -a;
    if(b < 0)
        b = -b;
    p.dst = dst;
    p.src = src;
    p.c = c;
    p.t = t;
    p.sp = subpt(sp, c);
    p.disc = nil;
    p.op = op;

    u = (t<<1)*(a-b);
    if(b<a && u>b*b || a<b && -u>a*a) {
/*	if(b<a&&(t<<1)>b*b/a || a<b&&(t<<1)>a*a/b)	# very thick */
        bellipse(b, newstate(&in, a, b), &p);
        return;
    }

    if(t < 0) {
        inb = -1;
        newstate(&out, a, y = b);
    } else {	
        inb = b - t;
        newstate(&out, a+t, y = b+t);
    }
    if(t > 0)
        newstate(&in, a-t, inb);
    inx = 0;
    for( ; y>=0; y--) {
        outx = step(&out);
        if(y > inb) {
            erect(-outx, y, outx, y, &p);
            if(y != 0)
                erect(-outx, -y, outx, -y, &p);
            continue;
        }
        if(t > 0) {
            inx = step(&in);
            if(y == inb)
                inx = 0;
        } else if(inx > outx)
            inx = outx;
        erect(inx, y, outx, y, &p);
        if(y != 0)
            erect(inx, -y, outx, -y, &p);
        erect(-outx, y, -inx, y, &p);
        if(y != 0)
            erect(-outx, -y, -inx, -y, &p);
        inx = outx + 1;
    }
}
@
% >> >> >>

<<global p00 (lib_graphics/libmemdraw/ellipse.c)>>=
static Point p00 = {0, 0};
@

<<function bellipse>>=
/*
 * a brushed ellipse
 */
static
void
bellipse(int y, State *s, Param *p)
{
    int t, ox, oy, x, nx;

    t = p->t;
    p->disc = allocmemimage(Rect(-t,-t,t+1,t+1), GREY1);
    if(p->disc == nil)
        return;
    memfillcolor(p->disc, DTransparent);
    memellipse(p->disc, p00, t, t, -1, memopaque, p00, p->op);
    oy = y;
    ox = 0;
    nx = x = step(s);
    do {
        while(nx==x && y-->0)
            nx = step(s);
        y++;
        eline(-x,-oy,-ox, -y, p);
        eline(ox,-oy,  x, -y, p);
        eline(-x,  y,-ox, oy, p);
        eline(ox,  y,  x, oy, p);
        ox = x+1;
        x = nx;
        y--;
        oy = y;
    } while(oy > 0);
}
@

<<function erect>>=
/*
 * a rectangle with closed (not half-open) coordinates expressed
 * relative to the center of the ellipse
 */
static
void
erect(int x0, int y0, int x1, int y1, Param *p)
{
    Rectangle r;

/*	print("R %d,%d %d,%d\n", x0, y0, x1, y1); /**/
    r = Rect(p->c.x+x0, p->c.y+y0, p->c.x+x1+1, p->c.y+y1+1);
    memdraw(p->dst, r, p->src, addpt(p->sp, r.min), memopaque, p00, p->op);
}
@



\section{Arc}

\subsection{API}

<<function arc>>=
void
arc(Image *dst, Point c, int a, int b, int thick, Image *src, Point sp, int alpha, int phi)
{
    alpha |= 1<<31;
    doellipse('e', dst, &c, a, b, thick, src, &sp, alpha, phi, SoverD);
}
@
% >>

<<function arcop>>=
void
arcop(Image *dst, Point c, int a, int b, int thick, Image *src, Point sp, int alpha, int phi, Drawop op)
{
    alpha |= 1<<31;
    doellipse('e', dst, &c, a, b, thick, src, &sp, alpha, phi, op);
}
@
% >>

<<function fillarc>>=
void
fillarc(Image *dst, Point c, int a, int b, Image *src, Point sp, int alpha, int phi)
{
    alpha |= 1<<31;
    doellipse('E', dst, &c, a, b, 0, src, &sp, alpha, phi, SoverD);
}
@
% >>

<<function fillarcop>>=
void
fillarcop(Image *dst, Point c, int a, int b, Image *src, Point sp, int alpha, int phi, Drawop op)
{
    alpha |= 1<<31;
    doellipse('E', dst, &c, a, b, 0, src, &sp, alpha, phi, op);
}
@
% >>

\subsection{Algoritm}

<<function memarc>>=
/*
 * make a "wedge" mask covering the desired angle and contained in
 * a surrounding square; draw a full ellipse; intersect that with the
 * wedge to make a mask through which to copy src to dst.
 */
void
memarc(Memimage *dst, Point c, int a, int b, int t, Memimage *src, Point sp, int alpha, int phi, int op)
{
    int i, w, beta, tmp, c1, c2, m, m1;
    Rectangle rect;
    Point p,	bnd[8];
    Memimage *wedge, *figure, *mask;

    if(a < 0)
        a = -a;
    if(b < 0)
        b = -b;
    w = t;
    if(w < 0)
        w = 0;
    alpha = -alpha;		/* compensate for upside-down coords */
    phi = -phi;
    beta = alpha + phi;
    if(phi < 0){
        tmp = alpha;
        alpha = beta;
        beta = tmp;
        phi = -phi;
    }
    if(phi >= 360){
        memellipse(dst, c, a, b, t, src, sp, op);
        return;
    }
    while(alpha < 0)
        alpha += 360;
    while(beta < 0)
        beta += 360;
    c1 = alpha/90 & 3;	/* number of nearest corner */
    c2 = beta/90 & 3;
        /*
         * icossin returns point at radius ICOSSCALE.
         * multiplying by m1 moves it outside the ellipse
        */
    rect = Rect(-a-w, -b-w, a+w+1, b+w+1);
    m = rect.max.x;	/* inradius of bounding square */
    if(m < rect.max.y)
        m = rect.max.y;
    m1 = (m+ICOSSCALE-1) >> 10;
    m = m1 << 10;		/* assure m1*cossin is inside */
    i = 0;
    bnd[i++] = Pt(0,0);
    icossin(alpha, &p.x, &p.y);
    bnd[i++] = mulpt(p, m1);
    for(;;) {
        bnd[i++] = mulpt(corners[c1], m);
        if(c1==c2 && phi<180)
            break;
        c1 = (c1+1) & 3;
        phi -= 90;
    }
    icossin(beta, &p.x, &p.y);
    bnd[i++] = mulpt(p, m1);

    figure = nil;
    mask = nil;
    wedge = allocmemimage(rect, GREY1);
    if(wedge == nil)
        goto Return;
    memfillcolor(wedge, DTransparent);
    memfillpoly(wedge, bnd, i, ~0, memopaque, p00, S);
    figure = allocmemimage(rect, GREY1);
    if(figure == nil)
        goto Return;
    memfillcolor(figure, DTransparent);
    memellipse(figure, p00, a, b, t, memopaque, p00, S);
    mask = allocmemimage(rect, GREY1);
    if(mask == nil)
        goto Return;
    memfillcolor(mask, DTransparent);
    memimagedraw(mask, rect, figure, rect.min, wedge, rect.min, S);
    c = subpt(c, dst->r.min);
    memdraw(dst, dst->r, src, subpt(sp, c), mask, subpt(p00, c), op);

    Return:
    freememimage(wedge);
    freememimage(figure);
    freememimage(mask);
}
@


%\section{Bezier} see advanced topics

%\section{Text} see font section

\chapter{Colors}
% test code showing use of colors?

\section{[[RGB]]}

<<struct RGB>>=
struct RGB
{
    ulong	red;
    ulong	green;
    ulong	blue;
};
@

\section{Color map}

\section{Pixel depth}

\section{Alpha}

\chapter{Fonts}
% test code showing use of font? display the core font?

\section{Text}
% and rune

\subsection{API}

<<function string>>=
Point
string(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s)
{
    return _string(dst, pt, src, sp, f, s, nil, 1<<24, dst->clipr, nil, ZP, SoverD);
}
@

<<function stringop>>=
Point
stringop(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, Drawop op)
{
    return _string(dst, pt, src, sp, f, s, nil, 1<<24, dst->clipr, nil, ZP, op);
}
@

<<function stringn>>=
Point
stringn(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, int len)
{
    return _string(dst, pt, src, sp, f, s, nil, len, dst->clipr, nil, ZP, SoverD);
}
@

<<function stringnop>>=
Point
stringnop(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, int len, Drawop op)
{
    return _string(dst, pt, src, sp, f, s, nil, len, dst->clipr, nil, ZP, op);
}
@

<<function runestring>>=
Point
runestring(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r)
{
    return _string(dst, pt, src, sp, f, nil, r, 1<<24, dst->clipr, nil, ZP, SoverD);
}
@

<<function runestringop>>=
Point
runestringop(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r, Drawop op)
{
    return _string(dst, pt, src, sp, f, nil, r, 1<<24, dst->clipr, nil, ZP, op);
}
@

<<function runestringn>>=
Point
runestringn(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r, int len)
{
    return _string(dst, pt, src, sp, f, nil, r, len, dst->clipr, nil, ZP, SoverD);
}
@

<<function runestringnop>>=
Point
runestringnop(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r, int len, Drawop op)
{
    return _string(dst, pt, src, sp, f, nil, r, len, dst->clipr, nil, ZP, op);
}
@




<<function stringbg>>=
Point
stringbg(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, Image *bg, Point bgp)
{
    return _string(dst, pt, src, sp, f, s, nil, 1<<24, dst->clipr, bg, bgp, SoverD);
}
@

<<function stringbgop>>=
Point
stringbgop(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, Image *bg, Point bgp, int op)
{
    return _string(dst, pt, src, sp, f, s, nil, 1<<24, dst->clipr, bg, bgp, op);
}
@

<<function stringnbg>>=
Point
stringnbg(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, int len, Image *bg, Point bgp)
{
    return _string(dst, pt, src, sp, f, s, nil, len, dst->clipr, bg, bgp, SoverD);
}
@

<<function stringnbgop>>=
Point
stringnbgop(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, int len, Image *bg, Point bgp, int op)
{
    return _string(dst, pt, src, sp, f, s, nil, len, dst->clipr, bg, bgp, op);
}
@

<<function runestringbg>>=
Point
runestringbg(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r, Image *bg, Point bgp)
{
    return _string(dst, pt, src, sp, f, nil, r, 1<<24, dst->clipr, bg, bgp, SoverD);
}
@

<<function runestringbgop>>=
Point
runestringbgop(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r, Image *bg, Point bgp, int op)
{
    return _string(dst, pt, src, sp, f, nil, r, 1<<24, dst->clipr, bg, bgp, op);
}
@

<<function runestringnbg>>=
Point
runestringnbg(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r, int len, Image *bg, Point bgp)
{
    return _string(dst, pt, src, sp, f, nil, r, len, dst->clipr, bg, bgp, SoverD);
}
@

<<function runestringnbgop>>=
Point
runestringnbgop(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r, int len, Image *bg, Point bgp, int op)
{
    return _string(dst, pt, src, sp, f, nil, r, len, dst->clipr, bg, bgp, op);
}
@


\subsection{Marshalling}


<<function _string>>=
Point
_string(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, Rune *r, int len, Rectangle clipr, Image *bg, Point bgp, Drawop op)
{
    int m, n, wid, max;
    ushort cbuf[Max], *c, *ec;
    uchar *b;
    char *subfontname;
    char **sptr;
    Rune **rptr;
    Font *def;
    Subfont *sf;

    if(s == nil){
        s = "";
        sptr = nil;
    }else
        sptr = &s;
    if(r == nil){
        r = (Rune*) L"";
        rptr = nil;
    }else
        rptr = &r;
    sf = nil;
    while((*s || *r) && len){
        max = Max;
        if(len < max)
            max = len;
        n = cachechars(f, sptr, rptr, cbuf, max, &wid, &subfontname);
        if(n > 0){
            _setdrawop(dst->display, op);

            m = 47+2*n;
            if(bg)
                m += 4+2*4;
            b = bufimage(dst->display, m);
            if(b == 0){
                fprint(2, "string: %r\n");
                break;
            }
            if(bg)
                b[0] = 'x';
            else
                b[0] = 's';
            BPLONG(b+1, dst->id);
            BPLONG(b+5, src->id);
            BPLONG(b+9, f->cacheimage->id);
            BPLONG(b+13, pt.x);
            BPLONG(b+17, pt.y+f->ascent);
            BPLONG(b+21, clipr.min.x);
            BPLONG(b+25, clipr.min.y);
            BPLONG(b+29, clipr.max.x);
            BPLONG(b+33, clipr.max.y);
            BPLONG(b+37, sp.x);
            BPLONG(b+41, sp.y);
            BPSHORT(b+45, n);
            b += 47;
            if(bg){
                BPLONG(b, bg->id);
                BPLONG(b+4, bgp.x);
                BPLONG(b+8, bgp.y);
                b += 12;
            }
            ec = &cbuf[n];
            for(c=cbuf; c<ec; c++, b+=2)
                BPSHORT(b, *c);
            pt.x += wid;
            bgp.x += wid;
            agefont(f);
            len -= n;
        }
        if(subfontname){
            freesubfont(sf);
            if((sf=_getsubfont(f->display, subfontname)) == 0){
                def = f->display ? f->display->defaultfont : nil;
                if(def && f!=def)
                    f = def;
                else
                    break;
            }
            /* 
             * must not free sf until cachechars has found it in the cache
             * and picked up its own reference.
             */
        }
    }
    return pt;
}
@


\subsection{Unmarshalling}

<<[[drawmesg()]] cases>>=
/* string: 's' dstid[4] srcid[4] fontid[4] P[2*4] clipr[4*4] sp[2*4] ni[2] ni*(index[2]) */
/* stringbg: 'x' dstid[4] srcid[4] fontid[4] P[2*4] clipr[4*4] sp[2*4] ni[2] bgid[4] bgpt[2*4] ni*(index[2]) */
case 's':
case 'x':
    printmesg(fmt="LLLPRPs", a, 0);
    m = 1+4+4+4+2*4+4*4+2*4+2;
    if(*a == 'x')
        m += 4+2*4;
    if(n < m)
        error(Eshortdraw);

    dst = drawimage(client, a+1);
    dstid = BGLONG(a+1);
    src = drawimage(client, a+5);
    font = drawlookup(client, BGLONG(a+9), 1);
    if(font == 0)
        error(Enodrawimage);
    if(font->nfchar == 0)
        error(Enotfont);
    drawpoint(&p, a+13);
    drawrectangle(&r, a+21);
    drawpoint(&sp, a+37);
    ni = BGSHORT(a+45);
    u = a+m;
    m += ni*2;
    if(n < m)
        error(Eshortdraw);
    clipr = dst->clipr;
    dst->clipr = r;
    op = drawclientop(client);
    bg = dst;
    if(*a == 'x'){
        /* paint background */
        bg = drawimage(client, a+47);
        drawpoint(&q, a+51);
        r.min.x = p.x;
        r.min.y = p.y-font->ascent;
        r.max.x = p.x;
        r.max.y = r.min.y+Dy(font->image->r);
        j = ni;
        while(--j >= 0){
            ci = BGSHORT(u);
            if(ci<0 || ci>=font->nfchar){
                dst->clipr = clipr;
                error(Eindex);
            }
            r.max.x += font->fchar[ci].width;
            u += 2;
        }
        memdraw(dst, r, bg, q, memopaque, ZP, op);
        u -= 2*ni;
    }
    q = p;
    while(--ni >= 0){
        ci = BGSHORT(u);
        if(ci<0 || ci>=font->nfchar){
            dst->clipr = clipr;
            error(Eindex);
        }
        q = drawchar(dst, bg, q, src, &sp, font, ci, op);
        u += 2;
    }
    dst->clipr = clipr;
    p.y -= font->ascent;
    dstflush(dstid, dst, Rect(p.x, p.y, q.x, p.y+Dy(font->image->r)));
    continue;

@

\subsection{Algorithm}



\section{Fonts}

\subsection{API}

<<function fontresize>>=
/* return whether resize succeeded && f->cache is unchanged */
static int
fontresize(Font *f, int wid, int ncache, int depth)
{
    Cacheinfo *i;
    int ret;
    Image *new;
    uchar *b;
    Display *d;

    ret = 0;
    if(depth <= 0)
        depth = 1;
    if(wid <= 0)
        wid = 1;

    d = f->display;
    if(d == nil)
        goto Nodisplay;

    new = allocimage(d, Rect(0, 0, ncache*wid, f->height), CHAN1(CGrey, depth), 0, 0);
    if(new == nil){
        fprint(2, "font cache resize failed: %r\n");
        abort();
        goto Return;
    }
    flushimage(d, 0);	/* flush any pending errors */
    b = bufimage(d, 1+4+4+1);
    if(b == 0){
        freeimage(new);
        goto Return;
    }
    b[0] = 'i';
    BPLONG(b+1, new->id);
    BPLONG(b+5, ncache);
    b[9] = f->ascent;
    if(flushimage(d, 0) < 0){
        fprint(2, "resize: init failed: %r\n");
        freeimage(new);
        goto Return;
    }
    freeimage(f->cacheimage);
    f->cacheimage = new;
    Nodisplay:
    f->width = wid;
    f->maxdepth = depth;
    ret = 1;
    if(f->ncache != ncache){
        i = malloc(ncache*sizeof f->cache[0]);
        if(i != nil){
            ret = 0;
            free(f->cache);
            f->ncache = ncache;
            f->cache = i;
        }
        /* else just wipe the cache clean and things will be ok */
    }
    Return:
    memset(f->cache, 0, f->ncache*sizeof f->cache[0]);
    return ret;
}
@

<<function loadchar>>=
/* return 1 if load succeeded, 0 if failed, -1 if must retry */
int
loadchar(Font *f, Rune r, Cacheinfo *c, int h, int noflush, char **subfontname)
{
    int i, oi, wid, top, bottom;
    Rune pic;
    Fontchar *fi;
    Cachefont *cf;
    Cachesubf *subf, *of;
    uchar *b;

    pic = r;
    Again:
    for(i=0; i<f->nsub; i++){
        cf = f->sub[i];
        if(cf->min<=pic && pic<=cf->max)
            goto Found;
    }
    TryPJW:
    if(pic != PJW){
        pic = PJW;
        goto Again;
    }
    return 0;

    Found:
    /*
     * Choose exact or oldest
     */
    oi = 0;
    subf = &f->subf[0];
    for(i=0; i<f->nsubf; i++){
        if(cf == subf->cf)
            goto Found2;
        if(subf->age < f->subf[oi].age)
            oi = i;
        subf++;
    }
    subf = &f->subf[oi];

    if(subf->f){
        if(f->age-subf->age>SUBFAGE || f->nsubf>MAXSUBF){
    Toss:
            /* ancient data; toss */
            freesubfont(subf->f);
            subf->cf = nil;
            subf->f = nil;
            subf->age = 0;
        }else{				/* too recent; grow instead */
            of = f->subf;
            f->subf = malloc((f->nsubf+DSUBF)*sizeof *subf);
            if(f->subf == nil){
                f->subf = of;
                goto Toss;
            }
            memmove(f->subf, of, (f->nsubf+DSUBF)*sizeof *subf);
            memset(f->subf+f->nsubf, 0, DSUBF*sizeof *subf);
            subf = &f->subf[f->nsubf];
            f->nsubf += DSUBF;
            free(of);
        }
    }
    subf->age = 0;
    subf->cf = nil;
    subf->f = cf2subfont(cf, f);
    if(subf->f == nil){
        if(cf->subfontname == nil)
            goto TryPJW;
        *subfontname = cf->subfontname;
        return -1;
    }

    subf->cf = cf;
    if(subf->f->ascent > f->ascent && f->display){
        /* should print something? this is a mistake in the font file */
        /* must prevent c->top from going negative when loading cache */
        Image *b;
        int d, t;
        d = subf->f->ascent - f->ascent;
        b = subf->f->bits;
        draw(b, b->r, b, nil, addpt(b->r.min, Pt(0, d)));
        draw(b, Rect(b->r.min.x, b->r.max.y-d, b->r.max.x, b->r.max.y), f->display->black, nil, b->r.min);
        for(i=0; i<subf->f->n; i++){
            t = subf->f->info[i].top-d;
            if(t < 0)
                t = 0;
            subf->f->info[i].top = t;
            t = subf->f->info[i].bottom-d;
            if(t < 0)
                t = 0;
            subf->f->info[i].bottom = t;
        }
        subf->f->ascent = f->ascent;
    }

    Found2:
    subf->age = f->age;

    /* possible overflow here, but works out okay */
    pic += cf->offset;
    pic -= cf->min;
    if(pic >= subf->f->n)
        goto TryPJW;
    fi = &subf->f->info[pic];
    if(fi->width == 0)
        goto TryPJW;
    wid = (fi+1)->x - fi->x;
    if(f->width < wid || f->width == 0 || f->maxdepth < subf->f->bits->depth){
        /*
         * Flush, free, reload (easier than reformatting f->b)
         */
        if(noflush)
            return -1;
        if(f->width < wid)
            f->width = wid;
        if(f->maxdepth < subf->f->bits->depth)
            f->maxdepth = subf->f->bits->depth;
        i = fontresize(f, f->width, f->ncache, f->maxdepth);
        if(i <= 0)
            return i;
        /* c is still valid as didn't reallocate f->cache */
    }
    c->value = r;
    top = fi->top + (f->ascent-subf->f->ascent);
    bottom = fi->bottom + (f->ascent-subf->f->ascent);
    c->width = fi->width;
    c->x = h*f->width;
    c->left = fi->left;
    if(f->display == nil)
        return 1;
    flushimage(f->display, 0);	/* flush any pending errors */
    b = bufimage(f->display, 37);
    if(b == 0)
        return 0;
    b[0] = 'l';
    BPLONG(b+1, f->cacheimage->id);
    BPLONG(b+5, subf->f->bits->id);
    BPSHORT(b+9, c-f->cache);
    BPLONG(b+11, c->x);
    BPLONG(b+15, top);
    BPLONG(b+19, c->x+((fi+1)->x-fi->x));
    BPLONG(b+23, bottom);
    BPLONG(b+27, fi->x);
    BPLONG(b+31, fi->top);
    b[35] = fi->left;
    b[36] = fi->width;
    return 1;
}
@


\subsection{Marshalling}

\subsection{Unmarshalling}

<<[[drawmesg()]] cases>>=
/* initialize font: 'i' fontid[4] nchars[4] ascent[1] */
case 'i':
    printmesg(fmt="Llb", a, 1);
    m = 1+4+4+1;
    if(n < m)
        error(Eshortdraw);
    dstid = BGLONG(a+1);
    if(dstid == 0)
        error("cannot use display as font");
    font = drawlookup(client, dstid, 1);
    if(font == 0)
        error(Enodrawimage);
    if(font->image->layer)
        error("cannot use window as font");
    ni = BGLONG(a+5);
    if(ni<=0 || ni>4096)
        error("bad font size (4096 chars max)");
    free(font->fchar);  /* should we complain if non-zero? */
    font->fchar = malloc(ni*sizeof(FChar));
    if(font->fchar == 0)
        error("no memory for font");
    memset(font->fchar, 0, ni*sizeof(FChar));
    font->nfchar = ni;
    font->ascent = a[9];
    continue;

@


<<[[drawmesg()]] cases>>=
/* load character: 'l' fontid[4] srcid[4] index[2] R[4*4] P[2*4] left[1] width[1] */
case 'l':
    printmesg(fmt="LLSRPbb", a, 0);
    m = 1+4+4+2+4*4+2*4+1+1;
    if(n < m)
        error(Eshortdraw);
    font = drawlookup(client, BGLONG(a+1), 1);
    if(font == 0)
        error(Enodrawimage);
    if(font->nfchar == 0)
        error(Enotfont);
    src = drawimage(client, a+5);
    ci = BGSHORT(a+9);
    if(ci >= font->nfchar)
        error(Eindex);
    drawrectangle(&r, a+11);
    drawpoint(&p, a+27);
    memdraw(font->image, r, src, p, memopaque, p, S);
    fc = &font->fchar[ci];
    fc->minx = r.min.x;
    fc->maxx = r.max.x;
    fc->miny = r.min.y;
    fc->maxy = r.max.y;
    fc->left = a[35];
    fc->width = a[36];
    continue;

@

\subsection{Algorithm}


\section{Compressed form}

\section{Font cache}

\chapter{Composing}

\chapter{Image}

\section{Naming}

\subsection{API}

<<function nameimage>>=
int
nameimage(Image *i, char *name, int in)
{
    uchar *a;
    int n;

    n = strlen(name);
    a = bufimage(i->display, 1+4+1+1+n);
    if(a == 0)
        return 0;
    a[0] = 'N';
    BPLONG(a+1, i->id);
    a[5] = in;
    a[6] = n;
    memmove(a+7, name, n);
    if(flushimage(i->display, 0) < 0)
        return 0;
    return 1;
}
@

<<function namedimage>>=
Image*
namedimage(Display *d, char *name)
{
    uchar *a;
    char *err, buf[12*12+1];
    Image *i;
    int id, n;
    ulong chan;

    err = 0;
    i = 0;

    n = strlen(name);
    if(n >= 256){
        err = "name too long";
    Error:
        if(err)
            werrstr("namedimage: %s", err);
        else
            werrstr("namedimage: %r");
        if(i)
            free(i);
        return 0;
    }
    /* flush pending data so we don't get error allocating the image */
    flushimage(d, 0);
    a = bufimage(d, 1+4+1+n);
    if(a == 0)
        goto Error;
    d->imageid++;
    id = d->imageid;

    a[0] = 'n';
    BPLONG(a+1, id);
    a[5] = n;
    memmove(a+6, name, n);

    if(flushimage(d, 0) < 0)
        goto Error;

    if(pread(d->ctlfd, buf, sizeof buf, 0) < 12*12)
        goto Error;
    buf[12*12] = '\0';

    i = malloc(sizeof(Image));
    if(i == nil){
    Error1:
        a = bufimage(d, 1+4);
        if(a){
            a[0] = 'f';
            BPLONG(a+1, id);
            flushimage(d, 0);
        }
        goto Error;
    }
    i->display = d;
    i->id = id;
    if((chan=strtochan(buf+2*12))==0){
        werrstr("bad channel '%.12s' from devdraw", buf+2*12);
        goto Error1;
    }
    i->chan = chan;
    i->depth = chantodepth(chan);
    i->repl = atoi(buf+3*12);
    i->r.min.x = atoi(buf+4*12);
    i->r.min.y = atoi(buf+5*12);
    i->r.max.x = atoi(buf+6*12);
    i->r.max.y = atoi(buf+7*12);
    i->clipr.min.x = atoi(buf+8*12);
    i->clipr.min.y = atoi(buf+9*12);
    i->clipr.max.x = atoi(buf+10*12);
    i->clipr.max.y = atoi(buf+11*12);
    i->screen = 0;
    i->next = 0;
    return i;
}
@


\subsection{Marshalling}

\subsection{Unmarshalling}

<<[[drawmesg()]] cases>>=
/* name an image: 'N' dstid[4] in[1] j[1] name[j] */
case 'N':
    printmesg(fmt="Lbz", a, 0);
    m = 1+4+1+1;
    if(n < m)
        error(Eshortdraw);
    c = a[5];
    j = a[6];
    if(j == 0)  /* give me a non-empty name please */
        error(Eshortdraw);
    m += j;
    if(n < m)
        error(Eshortdraw);
    di = drawlookup(client, BGLONG(a+1), 0);
    if(di == 0)
        error(Enodrawimage);
    if(di->name)
        error(Enamed);
    if(c)
        drawaddname(client, di, j, (char*)a+7);
    else{
        dn = drawlookupname(j, (char*)a+7);
        if(dn == nil)
            error(Enoname);
        if(dn->dimage != di)
            error(Ewrongname);
        drawdelname(dn);
    }
    continue;

@



<<[[drawmesg()]] cases>>=
/* attach to a named image: 'n' dstid[4] j[1] name[j] */
case 'n':
    printmesg(fmt="Lz", a, 0);
    m = 1+4+1;
    if(n < m)
        error(Eshortdraw);
    j = a[5];
    if(j == 0)  /* give me a non-empty name please */
        error(Eshortdraw);
    m += j;
    if(n < m)
        error(Eshortdraw);
    dstid = BGLONG(a+1);
    if(drawlookup(client, dstid, 0))
        error(Eimageexists);
    dn = drawlookupname(j, (char*)a+6);
    if(dn == nil)
        error(Enoname);
    if(drawinstall(client, dstid, dn->dimage->image, 0) == 0)
        error(Edrawmem);
    di = drawlookup(client, dstid, 0);
    if(di == 0)
        error("draw: cannot happen");
    di->vers = dn->vers;
    di->name = smalloc(j+1);
    di->fromname = dn->dimage;
    di->fromname->ref++;
    memmove(di->name, a+6, j);
    di->name[j] = 0;
    client->infoid = dstid;
    continue;

@

\subsection{Algorithm}



\section{Clipping}

\subsection{API}

<<function replclipr>>=
void
replclipr(Image *i, int repl, Rectangle clipr)
{
    uchar *b;

    b = bufimage(i->display, 22);
    b[0] = 'c';
    BPLONG(b+1, i->id);
    repl = repl!=0;
    b[5] = repl;
    BPLONG(b+6, clipr.min.x);
    BPLONG(b+10, clipr.min.y);
    BPLONG(b+14, clipr.max.x);
    BPLONG(b+18, clipr.max.y);
    i->repl = repl;
    i->clipr = clipr;
}
@

\subsection{Marshalling}

\subsection{Unmarshalling}

<<[[drawmesg()]] cases>>=
/* set repl and clip: 'c' dstid[4] repl[1] clipR[4*4] */
case 'c':
    printmesg(fmt="LbR", a, 0);
    m = 1+4+1+4*4;
    if(n < m)
        error(Eshortdraw);
    ddst = drawlookup(client, BGLONG(a+1), 1);
    if(ddst == nil)
        error(Enodrawimage);
    if(ddst->name)
        error("cannot change repl/clipr of shared image");
    dst = ddst->image;
    if(a[5])
        dst->flags |= Frepl;
    drawrectangle(&dst->clipr, a+6);
    continue;

@

\subsection{Algorithm}


\section{Reading images}

\subsection{API}

<<function readimage>>=
Image*
readimage(Display *d, int fd, int dolock)
{
    char hdr[5*12+1];
    int dy;
    int new;
    uint l, n;
    int m, j, chunk;
    int miny, maxy;
    Rectangle r;
    int ldepth;
    ulong chan;
    uchar *tmp;
    Image *i;

    if(readn(fd, hdr, 11) != 11)
        return nil;
    if(memcmp(hdr, "compressed\n", 11) == 0)
        return creadimage(d, fd, dolock);
    if(readn(fd, hdr+11, 5*12-11) != 5*12-11)
        return nil;
    if(d)
        chunk = d->bufsize - 32;	/* a little room for header */
    else
        chunk = 8192;

    /*
     * distinguish new channel descriptor from old ldepth.
     * channel descriptors have letters as well as numbers,
     * while ldepths are a single digit formatted as %-11d.
     */
    new = 0;
    for(m=0; m<10; m++){
        if(hdr[m] != ' '){
            new = 1;
            break;
        }
    }
    if(hdr[11] != ' '){
        werrstr("readimage: bad format");
        return nil;
    }
    if(new){
        hdr[11] = '\0';
        if((chan = strtochan(hdr)) == 0){
            werrstr("readimage: bad channel string %s", hdr);
            return nil;
        }
    }else{
        ldepth = ((int)hdr[10])-'0';
        if(ldepth<0 || ldepth>3){
            werrstr("readimage: bad ldepth %d", ldepth);
            return nil;
        }
        chan = drawld2chan[ldepth];
    }

    r.min.x = atoi(hdr+1*12);
    r.min.y = atoi(hdr+2*12);
    r.max.x = atoi(hdr+3*12);
    r.max.y = atoi(hdr+4*12);
    if(r.min.x>r.max.x || r.min.y>r.max.y){
        werrstr("readimage: bad rectangle");
        return nil;
    }

    miny = r.min.y;
    maxy = r.max.y;

    l = bytesperline(r, chantodepth(chan));
    if(d){
        if(dolock)
            lockdisplay(d);
        i = allocimage(d, r, chan, 0, -1);
        if(dolock)
            unlockdisplay(d);
        if(i == nil)
            return nil;
    }else{
        i = mallocz(sizeof(Image), 1);
        if(i == nil)
            return nil;
    }

    tmp = malloc(chunk);
    if(tmp == nil)
        goto Err;
    while(maxy > miny){
        dy = maxy - miny;
        if(dy*l > chunk)
            dy = chunk/l;
        if(dy <= 0){
            werrstr("readimage: image too wide for buffer");
            goto Err;
        }
        n = dy*l;
        m = readn(fd, tmp, n);
        if(m != n){
            werrstr("readimage: read count %d not %d: %r", m, n);
   Err:
            if(dolock)
                lockdisplay(d);
   Err1:
    freeimage(i);
            if(dolock)
                unlockdisplay(d);
            free(tmp);
            return nil;
        }
        if(!new)	/* an old image: must flip all the bits */
            for(j=0; j<chunk; j++)
                tmp[j] ^= 0xFF;

        if(d){
            if(dolock)
                lockdisplay(d);
            if(loadimage(i, Rect(r.min.x, miny, r.max.x, miny+dy), tmp, chunk) <= 0)
                goto Err1;
            if(dolock)
                unlockdisplay(d);
        }
        miny += dy;
    }
    free(tmp);
    return i;
}
@




<<function unloadimage>>=
int
unloadimage(Image *i, Rectangle r, uchar *data, int ndata)
{
    int bpl, n, ntot, dy;
    uchar *a;
    Display *d;

    if(!rectinrect(r, i->r)){
        werrstr("unloadimage: bad rectangle");
        return -1;
    }
    bpl = bytesperline(r, i->depth);
    if(ndata < bpl*Dy(r)){
        werrstr("unloadimage: buffer too small");
        return -1;
    }

    d = i->display;
    flushimage(d, 0);	/* make sure subsequent flush is for us only */
    ntot = 0;
    while(r.min.y < r.max.y){
        a = bufimage(d, 1+4+4*4);
        if(a == 0){
            werrstr("unloadimage: %r");
            return -1;
        }
        dy = 8000/bpl;
        if(dy <= 0){
            werrstr("unloadimage: image too wide");
            return -1;
        }
        if(dy > Dy(r))
            dy = Dy(r);
        a[0] = 'r';
        BPLONG(a+1, i->id);
        BPLONG(a+5, r.min.x);
        BPLONG(a+9, r.min.y);
        BPLONG(a+13, r.max.x);
        BPLONG(a+17, r.min.y+dy);
        if(flushimage(d, 0) < 0)
            return -1;
        n = read(d->fd, data+ntot, ndata-ntot);
        if(n < 0)
            return n;
        ntot += n;
        r.min.y += dy;
    }
    return ntot;
}
@


\subsection{Marshalling}

\subsection{Unmarshalling}

<<[[drawmesg()]] cases>>=
/* read: 'r' id[4] R[4*4] */
case 'r':
    printmesg(fmt="LR", a, 0);
    m = 1+4+4*4;
    if(n < m)
        error(Eshortdraw);
    i = drawimage(client, a+1);
    drawrectangle(&r, a+5);
    if(!rectinrect(r, i->r))
        error(Ereadoutside);
    c = bytesperline(r, i->depth);
    c *= Dy(r);
    free(client->readdata);
    client->readdata = mallocz(c, 0);
    if(client->readdata == nil)
        error("readimage malloc failed");

    client->nreaddata = memunload(i, r, client->readdata, c);
    if(client->nreaddata < 0){
        free(client->readdata);
        client->readdata = nil;
        error("bad readimage call");
    }
    continue;

@

\subsection{Algorithm}

\section{Writing images}

%topng </dev/screen >screen.png :) = Grab



<<function writeimage>>=
int
writeimage(int fd, Image *i, int dolock)
{
    uchar *outbuf, *outp, *eout;		/* encoded data, pointer, end */
    uchar *loutp;				/* start of encoded line */
    Hlist *hash;				/* heads of hash chains of past strings */
    Hlist *chain, *hp;			/* hash chain members, pointer */
    Hlist *cp;				/* next Hlist to fall out of window */
    int h;					/* hash value */
    uchar *line, *eline;			/* input line, end pointer */
    uchar *data, *edata;			/* input buffer, end pointer */
    ulong n;				/* length of input buffer */
    ulong nb;				/* # of bytes returned by unloadimage */
    int bpl;				/* input line length */
    int offs, runlen;			/* offset, length of consumed data */
    uchar dumpbuf[NDUMP];			/* dump accumulator */
    int ndump;				/* length of dump accumulator */
    int miny, dy;				/* y values while unloading input */
    int chunk, ncblock;
    Rectangle r;
    uchar *p, *q, *s, *es, *t;
    char hdr[11+5*12+1];
    char cbuf[20];

    chunk = i->display->bufsize - 32;	/* a little room for header */
    r = i->r;
    bpl = bytesperline(r, i->depth);
    n = Dy(r)*bpl;
    data = malloc(n);
    ncblock = _compblocksize(r, i->depth);
    outbuf = malloc(ncblock);
    hash = malloc(NHASH*sizeof(Hlist));
    chain = malloc(NMEM*sizeof(Hlist));
    if(data == 0 || outbuf == 0 || hash == 0 || chain == 0){
    ErrOut:
        free(data);
        free(outbuf);
        free(hash);
        free(chain);
        return -1;
    }
    for(miny = r.min.y; miny != r.max.y; miny += dy){
        dy = r.max.y-miny;
        if(dy*bpl > chunk)
            dy = chunk/bpl;
        if(dolock)
            lockdisplay(i->display);
        nb = unloadimage(i, Rect(r.min.x, miny, r.max.x, miny+dy),
            data+(miny-r.min.y)*bpl, dy*bpl);
        if(dolock)
            unlockdisplay(i->display);
        if(nb != dy*bpl)
            goto ErrOut;
    }
    sprint(hdr, "compressed\n%11s %11d %11d %11d %11d ",
        chantostr(cbuf, i->chan), r.min.x, r.min.y, r.max.x, r.max.y);
    if(write(fd, hdr, 11+5*12) != 11+5*12)
        goto ErrOut;
    edata = data+n;
    eout = outbuf+ncblock;
    line = data;
    r.max.y = r.min.y;
    while(line != edata){
        memset(hash, 0, NHASH*sizeof(Hlist));
        memset(chain, 0, NMEM*sizeof(Hlist));
        cp = chain;
        h = 0;
        outp = outbuf;
        for(n = 0; n != NMATCH; n++)
            h = hupdate(h, line[n]);
        loutp = outbuf;
        while(line != edata){
            ndump = 0;
            eline = line+bpl;
            for(p = line; p != eline; ){
                if(eline-p < NRUN)
                    es = eline;
                else
                    es = p+NRUN;
                q = 0;
                runlen = 0;
                for(hp = hash[h].next; hp; hp = hp->next){
                    s = p + runlen;
                    if(s >= es)
                        continue;
                    t = hp->s + runlen;
                    for(; s >= p; s--)
                        if(*s != *t--)
                            goto matchloop;
                    t += runlen+2;
                    s += runlen+2;
                    for(; s < es; s++)
                        if(*s != *t++)
                            break;
                    n = s-p;
                    if(n > runlen){
                        runlen = n;
                        q = hp->s;
                        if(n == NRUN)
                            break;
                    }
            matchloop: ;
                }
                if(runlen < NMATCH){
                    if(ndump == NDUMP){
                        if(eout-outp < ndump+1)
                            goto Bfull;
                        *outp++ = ndump-1+128;
                        memmove(outp, dumpbuf, ndump);
                        outp += ndump;
                        ndump = 0;
                    }
                    dumpbuf[ndump++] = *p;
                    runlen = 1;
                }
                else{
                    if(ndump != 0){
                        if(eout-outp < ndump+1)
                            goto Bfull;
                        *outp++ = ndump-1+128;
                        memmove(outp, dumpbuf, ndump);
                        outp += ndump;
                        ndump = 0;
                    }
                    offs = p-q-1;
                    if(eout-outp < 2)
                        goto Bfull;
                    *outp++ = ((runlen-NMATCH)<<2) + (offs>>8);
                    *outp++ = offs&255;
                }
                for(q = p+runlen; p != q; p++){
                    if(cp->prev)
                        cp->prev->next = 0;
                    cp->next = hash[h].next;
                    cp->prev = &hash[h];
                    if(cp->next)
                        cp->next->prev = cp;
                    cp->prev->next = cp;
                    cp->s = p;
                    if(++cp == &chain[NMEM])
                        cp = chain;
                    if(edata-p > NMATCH)
                        h = hupdate(h, p[NMATCH]);
                }
            }
            if(ndump != 0){
                if(eout-outp < ndump+1)
                    goto Bfull;
                *outp++ = ndump-1+128;
                memmove(outp, dumpbuf, ndump);
                outp += ndump;
            }
            line = eline;
            loutp = outp;
            r.max.y++;
        }
    Bfull:
        if(loutp == outbuf)
            goto ErrOut;
        n = loutp-outbuf;
        sprint(hdr, "%11d %11ld ", r.max.y, n);
        write(fd, hdr, 2*12);
        write(fd, outbuf, n);
        r.min.y = r.max.y;
    }
    free(data);
    free(outbuf);
    free(hash);
    free(chain);
    return 0;
}
@


\section{XXX}

% mv? in Writing image section?

\subsection{API}

<<function cloadimage>>=
int
cloadimage(Image *i, Rectangle r, uchar *data, int ndata)
{
    int m, nb, miny, maxy, ncblock;
    uchar *a;

    if(!rectinrect(r, i->r)){
        werrstr("cloadimage: bad rectangle");
        return -1;
    }

    miny = r.min.y;
    m = 0;
    ncblock = _compblocksize(r, i->depth);
    while(miny != r.max.y){
        maxy = atoi((char*)data+0*12);
        nb = atoi((char*)data+1*12);
        if(maxy<=miny || r.max.y<maxy){
            werrstr("creadimage: bad maxy %d", maxy);
            return -1;
        }
        data += 2*12;
        ndata -= 2*12;
        m += 2*12;
        if(nb<=0 || ncblock<nb || nb>ndata){
            werrstr("creadimage: bad count %d", nb);
            return -1;
        }
        a = bufimage(i->display, 21+nb);
        if(a == nil)
            return -1;
        a[0] = 'Y';
        BPLONG(a+1, i->id);
        BPLONG(a+5, r.min.x);
        BPLONG(a+9, miny);
        BPLONG(a+13, r.max.x);
        BPLONG(a+17, maxy);
        memmove(a+21, data, nb);
        miny = maxy;
        data += nb;
        ndata += nb;
        m += nb;
    }
    return m;
}
@

<<function creadimage>>=
Image *
creadimage(Display *d, int fd, int dolock)
{
    char hdr[5*12+1];
    Rectangle r;
    int m, nb, miny, maxy, new, ldepth, ncblock;
    uchar *buf, *a;
    Image *i;
    ulong chan;

    if(readn(fd, hdr, 5*12) != 5*12)
        return nil;

    /*
     * distinguish new channel descriptor from old ldepth.
     * channel descriptors have letters as well as numbers,
     * while ldepths are a single digit formatted as %-11d.
     */
    new = 0;
    for(m=0; m<10; m++){
        if(hdr[m] != ' '){
            new = 1;
            break;
        }
    }
    if(hdr[11] != ' '){
        werrstr("creadimage: bad format");
        return nil;
    }
    if(new){
        hdr[11] = '\0';
        if((chan = strtochan(hdr)) == 0){
            werrstr("creadimage: bad channel string %s", hdr);
            return nil;
        }
    }else{
        ldepth = ((int)hdr[10])-'0';
        if(ldepth<0 || ldepth>3){
            werrstr("creadimage: bad ldepth %d", ldepth);
            return nil;
        }
        chan = drawld2chan[ldepth];
    }
    r.min.x=atoi(hdr+1*12);
    r.min.y=atoi(hdr+2*12);
    r.max.x=atoi(hdr+3*12);
    r.max.y=atoi(hdr+4*12);
    if(r.min.x>r.max.x || r.min.y>r.max.y){
        werrstr("creadimage: bad rectangle");
        return nil;
    }

    if(d){
        if(dolock)
            lockdisplay(d);
        i = allocimage(d, r, chan, 0, 0);
        setmalloctag(i, getcallerpc(&d));
        if(dolock)
            unlockdisplay(d);
        if(i == nil)
            return nil;
    }else{
        i = mallocz(sizeof(Image), 1);
        if(i == nil)
            return nil;
    }
    ncblock = _compblocksize(r, chantodepth(chan));
    buf = malloc(ncblock);
    if(buf == nil)
        goto Errout;
    miny = r.min.y;
    while(miny != r.max.y){
        if(readn(fd, hdr, 2*12) != 2*12){
        Errout:
            if(dolock)
                lockdisplay(d);
        Erroutlock:
            freeimage(i);
            if(dolock)
                unlockdisplay(d);
            free(buf);
            return nil;
        }
        maxy = atoi(hdr+0*12);
        nb = atoi(hdr+1*12);
        if(maxy<=miny || r.max.y<maxy){
            werrstr("creadimage: bad maxy %d", maxy);
            goto Errout;
        }
        if(nb<=0 || ncblock<nb){
            werrstr("creadimage: bad count %d", nb);
            goto Errout;
        }
        if(readn(fd, buf, nb)!=nb)
            goto Errout;
        if(d){
            if(dolock)
                lockdisplay(d);
            a = bufimage(i->display, 21+nb);
            if(a == nil)
                goto Erroutlock;
            a[0] = 'Y';
            BPLONG(a+1, i->id);
            BPLONG(a+5, r.min.x);
            BPLONG(a+9, miny);
            BPLONG(a+13, r.max.x);
            BPLONG(a+17, maxy);
            if(!new)	/* old image: flip the data bits */
                _twiddlecompressed(buf, nb);
            memmove(a+21, buf, nb);
            if(dolock)
                unlockdisplay(d);
        }
        miny = maxy;
    }
    free(buf);
    return i;
}
@


<<function loadimage>>=
int
loadimage(Image *i, Rectangle r, uchar *data, int ndata)
{
    long dy;
    int n, bpl;
    uchar *a;
    int chunk;

    chunk = i->display->bufsize - 64;

    if(!rectinrect(r, i->r)){
        werrstr("loadimage: bad rectangle");
        return -1;
    }
    bpl = bytesperline(r, i->depth);
    n = bpl*Dy(r);
    if(n > ndata){
        werrstr("loadimage: insufficient data");
        return -1;
    }
    ndata = 0;
    while(r.max.y > r.min.y){
        dy = r.max.y - r.min.y;
        if(dy*bpl > chunk)
            dy = chunk/bpl;
        if(dy <= 0){
            werrstr("loadimage: image too wide for buffer");
            return -1;
        }
        n = dy*bpl;
        a = bufimage(i->display, 21+n);
        if(a == nil){
            werrstr("bufimage failed");
            return -1;
        }
        a[0] = 'y';
        BPLONG(a+1, i->id);
        BPLONG(a+5, r.min.x);
        BPLONG(a+9, r.min.y);
        BPLONG(a+13, r.max.x);
        BPLONG(a+17, r.min.y+dy);
        memmove(a+21, data, n);
        ndata += n;
        data += n;
        r.min.y += dy;
    }
    if(flushimage(i->display, 0) < 0)
        return -1;
    return ndata;
}
@

\subsection{marshalling}

\subsection{Unmarshalling}

<<[[drawmesg()]] cases>>=
/* write: 'y' id[4] R[4*4] data[x*1] */
/* write from compressed data: 'Y' id[4] R[4*4] data[x*1] */
case 'y':
case 'Y':
    printmesg(fmt="LR", a, 0);
//  iprint("load %c\n", *a);
    m = 1+4+4*4;
    if(n < m)
        error(Eshortdraw);
    dstid = BGLONG(a+1);
    dst = drawimage(client, a+1);
    drawrectangle(&r, a+5);
    if(!rectinrect(r, dst->r))
        error(Ewriteoutside);
    y = memload(dst, r, a+m, n-m, *a=='Y');
    if(y < 0)
        error("bad writeimage call");
    dstflush(dstid, dst, r);
    m += y;
    continue;
@

\subsection{Algorithm}



\chapter{Windows}
% Layers

\section{[[Screen]] and [[Memscreen]]}
% and [[_screen]]

<<struct Screen>>=
struct Screen
{
    Display	*display;	/* display holding data */
    int		id;			/* id of system-held Screen */
    Image	*image;		/* unused; for reference only */
    Image	*fill;		/* color to paint behind windows */
};
@
%less: delete image field?

<<global _screen>>=
Screen	*_screen;
@
% called _screen because screen is already use (to actually an Image, hmm)


<<global screenid>>=
static int	screenid;
@


<<struct Memscreen>>=
struct Memscreen
{
    Memimage	*frontmost;	/* frontmost layer on screen */
    Memimage	*rearmost;	/* rearmost layer on screen */
    Memimage	*image;		/* upon which all layers are drawn */
    Memimage	*fill;			/* if non-zero, picture to use when repainting */
};
@

<<struct Memlayer>>=
struct Memlayer
{
    Rectangle		screenr;	/* true position of layer on screen */
    Point			delta;	/* add delta to go from image coords to screen */
    Memscreen	*screen;	/* screen this layer belongs to */
    Memimage	*front;	/* window in front of this one */
    Memimage	*rear;	/* window behind this one*/
    int		clear;	/* layer is fully visible */
    Memimage	*save;	/* save area for obscured parts */
    Refreshfn	refreshfn;		/* function to call to refresh obscured parts if save==nil */
    void		*refreshptr;	/* argument to refreshfn */
};
@


\subsection{API}

<<function allocscreen>>=
Screen*
allocscreen(Image *image, Image *fill, int public)
{
    uchar *a;
    Screen *s;
    int id, try;
    Display *d;

    d = image->display;
    if(d != fill->display){
        werrstr("allocscreen: image and fill on different displays");
        return 0;
    }
    s = malloc(sizeof(Screen));
    if(s == 0)
        return 0;
    SET(id);
    for(try=0; try<25; try++){
        /* loop until find a free id */
        a = bufimage(d, 1+4+4+4+1);
        if(a == 0){
            free(s);
            return 0;
        }
        id = ++screenid;
        a[0] = 'A';
        BPLONG(a+1, id);
        BPLONG(a+5, image->id);
        BPLONG(a+9, fill->id);
        a[13] = public;
        if(flushimage(d, 0) != -1)
            break;
    }
    s->display = d;
    s->id = id;
    s->image = image;
    assert(s->image && s->image->chan != 0);

    s->fill = fill;
    return s;
}
@

<<function freescreen>>=
int
freescreen(Screen *s)
{
    uchar *a;
    Display *d;

    if(s == 0)
        return 0;
    d = s->display;
    a = bufimage(d, 1+4);
    if(a == 0)
        return -1;
    a[0] = 'F';
    BPLONG(a+1, s->id);
    /*
     * flush(1) because screen is likely holding last reference to
     * window, and want it to disappear visually.
     */
    if(flushimage(d, 1) < 0)
        return -1;
    free(s);
    return 1;
}
@

<<function publicscreen>>=
Screen*
publicscreen(Display *d, int id, ulong chan)
{
    uchar *a;
    Screen *s;

    s = malloc(sizeof(Screen));
    if(s == 0)
        return 0;
    a = bufimage(d, 1+4+4);
    if(a == 0){
    Error:
        free(s);
        return 0;
    }
    a[0] = 'S';
    BPLONG(a+1, id);
    BPLONG(a+5, chan);
    if(flushimage(d, 0) < 0)
        goto Error;

    s->display = d;
    s->id = id;
    s->image = 0;
    s->fill = 0;
    return s;
}
@


\subsection{Marshalling}

\subsection{Unmarshalling}


<<[[drawmesg()]] cases>>=
/* allocate screen: 'A' id[4] imageid[4] fillid[4] public[1] */
case 'A':
    printmesg(fmt="LLLb", a, 1);
    m = 1+4+4+4+1;
    if(n < m)
        error(Eshortdraw);
    dstid = BGLONG(a+1);
    if(dstid == 0)
        error(Ebadarg);
    if(drawlookupdscreen(dstid))
        error(Escreenexists);
    ddst = drawlookup(client, BGLONG(a+5), 1);
    dsrc = drawlookup(client, BGLONG(a+9), 1);
    if(ddst==0 || dsrc==0)
        error(Enodrawimage);

    if(drawinstallscreen(client, 0, dstid, ddst, dsrc, a[13]) == 0) // The call
        error(Edrawmem);
    continue;

@

<<[[drawmesg()]] cases>>=
/* free screen: 'F' id[4] */
case 'F':
    printmesg(fmt="L", a, 1);
    m = 1+4;
    if(n < m)
        error(Eshortdraw);
    drawlookupscreen(client, BGLONG(a+1), &cs);
    drawuninstallscreen(client, cs); // The call
    continue;

@



<<[[drawmesg()]] cases>>=
/* use public screen: 'S' id[4] chan[4] */
case 'S':
    printmesg(fmt="Ll", a, 0);
    m = 1+4+4;
    if(n < m)
        error(Eshortdraw);
    dstid = BGLONG(a+1);
    if(dstid == 0)
        error(Ebadarg);
    dscrn = drawlookupdscreen(dstid);
    if(dscrn==0 || (dscrn->public==0 && dscrn->owner!=client))
        error(Enodrawscreen);
    if(dscrn->screen->image->chan != BGLONG(a+5))
        error("inconsistent chan");

    if(drawinstallscreen(client, dscrn, 0, 0, 0, 0) == 0) // The call
        error(Edrawmem);
    continue;

@


\subsection{Algorithm}

% devdraw.c
<<function drawinstallscreen>>=
Memscreen*
drawinstallscreen(Client *client, DScreen *d, int id, DImage *dimage, DImage *dfill, int public)
{
    Memscreen *s;
    CScreen *c;

    c = malloc(sizeof(CScreen));
    if(dimage && dimage->image && dimage->image->chan == 0)
        panic("bad image %p in drawinstallscreen", dimage->image);

    if(c == 0)
        return 0;
    if(d == 0){
        d = malloc(sizeof(DScreen));
        if(d == 0){
            free(c);
            return 0;
        }
        s = malloc(sizeof(Memscreen));
        if(s == 0){
            free(c);
            free(d);
            return 0;
        }
        s->frontmost = 0;
        s->rearmost = 0;
        d->dimage = dimage;
        if(dimage){
            s->image = dimage->image;
            dimage->ref++;
        }
        d->dfill = dfill;
        if(dfill){
            s->fill = dfill->image;
            dfill->ref++;
        }
        d->ref = 0;
        d->id = id;
        d->screen = s;
        d->public = public;
        d->next = dscreen;
        d->owner = client;
        dscreen = d;
    }
    c->dscreen = d;
    d->ref++;
    c->next = client->cscreen;
    client->cscreen = c;
    return d->screen;
}
@

<<function drawuninstallscreen>>=
void
drawuninstallscreen(Client *client, CScreen *this)
{
    CScreen *cs, *next;

    cs = client->cscreen;
    if(cs == this){
        client->cscreen = this->next;
        drawfreedscreen(this->dscreen);
        free(this);
        return;
    }
    while(next = cs->next){ /* assign = */
        if(next == this){
            cs->next = this->next;
            drawfreedscreen(this->dscreen);
            free(this);
            return;
        }
        cs = next;
    }
}
@


\section{Window creation}

<<function allocwindow>>=
Image*
allocwindow(Screen *s, Rectangle r, int ref, ulong val)
{
    return _allocwindow(nil, s, r, ref, val);
}
@

<<function _allocwindow>>=
Image*
_allocwindow(Image *i, Screen *s, Rectangle r, int ref, ulong val)
{
    Display *d;

    d = s->display;
    i = _allocimage(i, d, r, d->screenimage->chan, 0, val, s->id, ref);
    if(i == 0)
        return 0;
    i->screen = s;
    i->next = s->display->windows;
    s->display->windows = i;
    return i;
}
@


\section{Window origin}

\subsection{API}

<<function originwindow>>=
int
originwindow(Image *w, Point log, Point scr)
{
    uchar *b;
    Point delta;

    flushimage(w->display, 0);
    b = bufimage(w->display, 1+4+2*4+2*4);
    if(b == nil)
        return 0;
    b[0] = 'o';
    BPLONG(b+1, w->id);
    BPLONG(b+5, log.x);
    BPLONG(b+9, log.y);
    BPLONG(b+13, scr.x);
    BPLONG(b+17, scr.y);
    if(flushimage(w->display, 1) < 0)
        return -1;
    delta = subpt(log, w->r.min);
    w->r = rectaddpt(w->r, delta);
    w->clipr = rectaddpt(w->clipr, delta);
    return 1;
}
@

\subsection{Marshalling}

\subsection{Unmarshalling}

<<[[drawmesg()]] cases>>=
/* position window: 'o' id[4] r.min [2*4] screenr.min [2*4] */
case 'o':
    printmesg(fmt="LPP", a, 0);
    m = 1+4+2*4+2*4;
    if(n < m)
        error(Eshortdraw);
    dst = drawimage(client, a+1);
    if(dst->layer){
        drawpoint(&p, a+5);
        drawpoint(&q, a+13);
        r = dst->layer->screenr;

        ni = memlorigin(dst, p, q); // The call

        if(ni < 0)
            error("image origin failed");
        if(ni > 0){
            addflush(r);
            addflush(dst->layer->screenr);
            ll = drawlookup(client, BGLONG(a+1), 1);
            drawrefreshscreen(ll, client);
        }
    }
    continue;
@

\subsection{Algorithm}

<<function memlorigin>>=
/*
 * Place i so i->r.min = log, i->layer->screenr.min == scr.
*/
int
memlorigin(Memimage *i, Point log, Point scr)
{
    Memlayer *l;
    Memscreen *s;
    Memimage *t, *shad, *nsave;
    Rectangle x, newr, oldr;
    Point delta;
    int overlap, eqlog, eqscr, wasclear;

    l = i->layer;
    s = l->screen;
    oldr = l->screenr;
    newr = Rect(scr.x, scr.y, scr.x+Dx(oldr), scr.y+Dy(oldr));
    eqscr = eqpt(scr, oldr.min);
    eqlog = eqpt(log, i->r.min);
    if(eqscr && eqlog)
        return 0;
    nsave = nil;
    if(eqlog==0 && l->save!=nil){
        nsave = allocmemimage(Rect(log.x, log.y, log.x+Dx(oldr), log.y+Dy(oldr)), i->chan);
        if(nsave == nil)
            return -1;
    }

    /*
     * Bring it to front and move logical coordinate system.
     */
    memltofront(i);
    wasclear = l->clear;
    if(nsave){
        if(!wasclear)
            memimagedraw(nsave, nsave->r, l->save, l->save->r.min, nil, Pt(0,0), S);
        freememimage(l->save);
        l->save = nsave;
    }
    delta = subpt(log, i->r.min);
    i->r = rectaddpt(i->r, delta);
    i->clipr = rectaddpt(i->clipr, delta);
    l->delta = subpt(l->screenr.min, i->r.min);
    if(eqscr)
        return 0;

    /*
     * To clean up old position, make a shadow window there, don't paint it,
     * push it behind this one, and (later) delete it.  Because the refresh function
     * for this fake window is a no-op, this will cause no graphics action except
     * to restore the background and expose the windows previously hidden.
     */
    shad = memlalloc(s, oldr, memlnorefresh, nil, DNofill);
    if(shad == nil)
        return -1;
    s->frontmost = i;
    if(s->rearmost == i)
        s->rearmost = shad;
    else
        l->rear->layer->front = shad;
    shad->layer->front = i;
    shad->layer->rear = l->rear;
    l->rear = shad;
    l->front = nil;
    shad->layer->clear = 0;

    /*
     * Shadow is now holding down the fort at the old position.
     * Move the window and hide things obscured by new position.
     */
    for(t=l->rear->layer->rear; t!=nil; t=t->layer->rear){
        x = newr;
        overlap = rectclip(&x, t->layer->screenr);
        if(overlap){
            memlhide(t, x);
            t->layer->clear = 0;
        }
    }
    l->screenr = newr;
    l->delta = subpt(scr, i->r.min);
    l->clear = rectinrect(newr, l->screen->image->clipr);

    /*
     * Everything's covered.  Copy to new position and delete shadow window.
     */
    if(wasclear)
        memdraw(s->image, newr, s->image, oldr.min, nil, Pt(0,0), S);
    else
        memlexpose(i, newr);
    memldelete(shad);

    return 1;
}
@

\section{Windows stack manipulation}
%extern int	newwindow(char*);
% but actually it returns an int that is probably similar to a fd
% and rio itself match this id to a Window structure

% window managment! topwindow(), etc.


\subsection{API}

<<function bottomwindow>>=
void
bottomwindow(Image *w)
{
    if(w->screen == 0)
        return;
    topbottom(&w, 1, 0);
}
@

<<function topwindow>>=
void
topwindow(Image *w)
{
    if(w->screen == 0)
        return;
    topbottom(&w, 1, 1);
}
@

<<function bottomnwindows>>=
void
bottomnwindows(Image **w, int n)
{
    topbottom(w, n, 0);
}
@

<<function topnwindows>>=
void
topnwindows(Image **w, int n)
{
    topbottom(w, n, 1);
}
@

\subsection{Marshalling}


<<function topbottom>>=
static
void
topbottom(Image **w, int n, int top)
{
    int i;
    uchar *b;
    Display *d;

    if(n < 0){
    Ridiculous:
        fprint(2, "top/bottom: ridiculous number of windows\n");
        return;
    }
    if(n == 0)
        return;
    if(n > (w[0]->display->bufsize-100)/4)
        goto Ridiculous;
    /*
     * this used to check that all images were on the same screen.
     * we don't know the screen associated with images we acquired
     * by name.  instead, check that all images are on the same display.
     * the display will check that they are all on the same screen.
     */
    d = w[0]->display;
    for(i=1; i<n; i++)
        if(w[i]->display != d){
            fprint(2, "top/bottom: windows not on same screen\n");
            return;
        }

    if(n==0)
        return;
    b = bufimage(d, 1+1+2+4*n);
    b[0] = 't';
    b[1] = top;
    BPSHORT(b+2, n);
    for(i=0; i<n; i++)
        BPLONG(b+4+4*i, w[i]->id);
}
@

\subsection{Unmarshalling}


<<[[drawmesg()]] cases>>=
/* top or bottom windows: 't' top[1] nw[2] n*id[4] */
case 't':
    printmesg(fmt="bsL", a, 0);
    m = 1+1+2;
    if(n < m)
        error(Eshortdraw);
    nw = BGSHORT(a+2);
    if(nw < 0)
        error(Ebadarg);
    if(nw == 0)
        continue;
    m += nw*4;
    if(n < m)
        error(Eshortdraw);
    lp = malloc(nw*sizeof(Memimage*));
    if(lp == 0)
        error(Enomem);
    if(waserror()){
        free(lp);
        nexterror();
    }
    for(j=0; j<nw; j++)
        lp[j] = drawimage(client, a+1+1+2+j*4);
    if(lp[0]->layer == 0)
        error("images are not windows");
    for(j=1; j<nw; j++)
        if(lp[j]->layer->screen != lp[0]->layer->screen)
            error("images not on same screen");

    if(a[1])
        memltofrontn(lp, nw); // The call
    else
        memltorearn(lp, nw); // The call

    if(lp[0]->layer->screen->image->data == screenimage->data)
        for(j=0; j<nw; j++)
            addflush(lp[j]->layer->screenr);
    ll = drawlookup(client, BGLONG(a+1+1+2), 1);
    drawrefreshscreen(ll, client);
    poperror();
    free(lp);
    continue;

@

\subsection{Algorithm}

<<function memltofrontn>>=
void
memltofrontn(Memimage **ip, int n)
{
    Memimage *i, *front;
    Memscreen *s;

    if(n == 0)
        return;
    front = nil;
    while(--n >= 0){
        i = *ip++;
        _memltofront(i, front, 1);
        front = i;
    }
    s = front->layer->screen;
    _memlsetclear(s);
}
@

<<function memltorearn>>=
void
memltorearn(Memimage **ip, int n)
{
    Memimage *i, *rear;
    Memscreen *s;

    if(n == 0)
        return;
    rear = nil;
    while(--n >= 0){
        i = *ip++;
        _memltorear(i, rear);
        rear = i;
    }
    s = rear->layer->screen;
    _memlsetclear(s);
}
@

\chapter{Input}

\section{Keyboard}

<<enum _anon_ (include/keyboard.h)>>=
enum {
    KF=	0xF000,	/* Rune: beginning of private Unicode space */
    Spec=	0xF800,
    /* KF|1, KF|2, ..., KF|0xC is F1, F2, ..., F12 */
    Khome=	KF|0x0D,
    Kup=	KF|0x0E,
    Kpgup=	KF|0x0F,
    Kprint=	KF|0x10,
    Kleft=	KF|0x11,
    Kright=	KF|0x12,
    Kdown=	Spec|0x00,
    Kview=	Spec|0x00,
    Kpgdown=	KF|0x13,
    Kins=	KF|0x14,
    Kend=	KF|0x18,

    Kalt=		KF|0x15,
    Kshift=	KF|0x16,
    Kctl=		KF|0x17,

    Kbs=	0x08,
    Kdel=	0x7f,
    Kesc=	0x1b,
    Keof=	0x04,
};
@


<<struct Keyboardctl>>=
struct	Keyboardctl
{
    Channel	*c;	/* chan(Rune)[20] */

    char	*file;

    fdt		consfd;		/* to cons file */
    fdt		ctlfd;		/* to ctl file */

    int		pid;		/* of slave proc */
};
@



% show also kernel interface and refer to Kernel.tex.nw

<<function initkeyboard>>=
Keyboardctl*
initkeyboard(char *file)
{
    Keyboardctl *kc;
    char *t;

    kc = mallocz(sizeof(Keyboardctl), 1);
    if(kc == nil)
        return nil;
    if(file == nil)
        file = "/dev/cons";
    kc->file = strdup(file);
    kc->consfd = open(file, ORDWR|OCEXEC);
    t = malloc(strlen(file)+16);
    if(kc->consfd<0 || t==nil){
Error1:
        free(kc);
        return nil;
    }
    sprint(t, "%sctl", file);
    kc->ctlfd = open(t, OWRITE|OCEXEC);
    if(kc->ctlfd < 0){
        fprint(2, "initkeyboard: can't open %s: %r\n", t);
Error2:
        close(kc->consfd);
        free(t);
        goto Error1;
    }
    if(ctlkeyboard(kc, "rawon") < 0){
        fprint(2, "initkeyboard: can't turn on raw mode on %s: %r\n", t);
        close(kc->ctlfd);
        goto Error2;
    }
    free(t);
    kc->c = chancreate(sizeof(Rune), 20);
    proccreate(_ioproc, kc, 4096);
    return kc;
}
@


<<function _ioproc>>=
static
void
_ioproc(void *arg)
{
    int m, n;
    char buf[20];
    Rune r;
    Keyboardctl *kc;

    kc = arg;
    threadsetname("kbdproc");
    kc->pid = getpid();
    n = 0;
    for(;;){
        while(n>0 && fullrune(buf, n)){
            m = chartorune(&r, buf);
            n -= m;
            memmove(buf, buf+m, n);
            send(kc->c, &r);
        }
        m = read(kc->consfd, buf+n, sizeof buf-n);
        if(m <= 0){
            yield();	/* if error is due to exiting, we'll exit here */
            fprint(2, "keyboard read error: %r\n");
            threadexits("error");
        }
        n += m;
    }
}
@

<<function closekeyboard>>=
void
closekeyboard(Keyboardctl *kc)
{
    if(kc == nil)
        return;

    postnote(PNPROC, kc->pid, "kill");
    close(kc->ctlfd);
    close(kc->consfd);
    free(kc->file);
    free(kc->c);
    free(kc);
}
@
%//#ifdef BUG
%//	/* Drain the channel */
%//	while(?kc->c)
%//		<-kc->c;
%//#endif



<<function ctlkeyboard>>=
int
ctlkeyboard(Keyboardctl *kc, char *m)
{
    return write(kc->ctlfd, m, strlen(m));
}
@




\section{Mouse}

% show also kernel interface and refer to Kernel.tex.nw

% same in mouse.h and event.h
<<struct Mouse (include/mouse.h)>>=
struct	Mouse
{
    int	buttons;	/* bit array: LMR=124 */
    Point	xy;
    ulong	msec;
};
@

<<struct Mousectl>>=
struct Mousectl
{
    Mouse;

    Channel	*c;			/* chan(Mouse) */
    Channel	*resizec;	/* chan(int)[2] */
    /* buffered in case client is waiting for a mouse action before handling resize */

    char	*file;

    fdt		mfd;		/* to mouse file */
    fdt		cfd;		/* to cursor file */

    int		pid;	/* of slave proc */
    Image*	image;	/* of associated window/display */
};
@
% why image? because cursor!! so need to draw on top of it!


<<function initmouse>>=
Mousectl*
initmouse(char *file, Image *i)
{
    Mousectl *mc;
    char *t, *sl;

    mc = mallocz(sizeof(Mousectl), 1);
    if(file == nil)
        file = "/dev/mouse";
    mc->file = strdup(file);
    mc->mfd = open(file, ORDWR|OCEXEC);
    if(mc->mfd<0 && strcmp(file, "/dev/mouse")==0){
        bind("#m", "/dev", MAFTER);
        mc->mfd = open(file, ORDWR|OCEXEC);
    }
    if(mc->mfd < 0){
        free(mc);
        return nil;
    }
    t = malloc(strlen(file)+16);
    if (t == nil) {
        close(mc->mfd);
        free(mc);
        return nil;
    }
    strcpy(t, file);
    sl = utfrrune(t, '/');
    if(sl)
        strcpy(sl, "/cursor");
    else
        strcpy(t, "/dev/cursor");
    mc->cfd = open(t, ORDWR|OCEXEC);
    free(t);
    mc->image = i;
    mc->c = chancreate(sizeof(Mouse), 0);
    mc->resizec = chancreate(sizeof(int), 2);
    proccreate(_ioproc, mc, 4096);
    return mc;
}
@

<<function _ioproc (lib_graphics/libdraw/mouse.c)>>=
static
void
_ioproc(void *arg)
{
    int n, nerr, one;
    char buf[1+5*12];
    Mouse m;
    Mousectl *mc;

    mc = arg;
    threadsetname("mouseproc");
    one = 1;
    memset(&m, 0, sizeof m);
    mc->pid = getpid();
    nerr = 0;
    for(;;){
        n = read(mc->mfd, buf, sizeof buf);
        if(n != 1+4*12){
            yield();	/* if error is due to exiting, we'll exit here */
            fprint(2, "mouse: bad count %d not 49: %r\n", n);
            if(n<0 || ++nerr>10)
                threadexits("read error");
            continue;
        }
        nerr = 0;
        switch(buf[0]){
        case 'r':
            send(mc->resizec, &one);
            /* fall through */
        case 'm':
            m.xy.x = atoi(buf+1+0*12);
            m.xy.y = atoi(buf+1+1*12);
            m.buttons = atoi(buf+1+2*12);
            m.msec = atoi(buf+1+3*12);
            send(mc->c, &m);
            /*
             * mc->Mouse is updated after send so it doesn't have wrong value if we block during send.
             * This means that programs should receive into mc->Mouse (see readmouse() above) if
             * they want full synchrony.
             */
            mc->Mouse = m;
            break;
        }
    }
}
@


<<function moveto>>=
void
moveto(Mousectl *m, Point pt)
{
    fprint(m->mfd, "m%d %d", pt.x, pt.y);
    m->xy = pt;
}
@

<<function closemouse>>=
void
closemouse(Mousectl *mc)
{
    if(mc == nil)
        return;

    postnote(PNPROC, mc->pid, "kill");

    do ; while(nbrecv(mc->c, &mc->Mouse) > 0);

    close(mc->mfd);
    close(mc->cfd);
    free(mc->file);
    free(mc->c);
    free(mc->resizec);
    free(mc);
}
@

<<function readmouse>>=
int
readmouse(Mousectl *mc)
{
    if(mc->image)
        flushimage(mc->image->display, 1);
    if(recv(mc->c, &mc->Mouse) < 0){
        fprint(2, "readmouse: %r\n");
        return -1;
    }
    return 0;
}
@


\section{Cursor}

<<struct Cursor>>=
struct	Cursor
{
    Point	offset;
    uchar	clr[2*16];
    uchar	set[2*16];
};
@

<<function setcursor>>=
void
setcursor(Mousectl *mc, Cursor *c)
{
    char curs[2*4+2*2*16];

    if(c == nil)
        write(mc->cfd, curs, 0);
    else{
        BPLONG(curs+0*4, c->offset.x);
        BPLONG(curs+1*4, c->offset.y);
        memmove(curs+2*4, c->clr, 2*2*16);
        write(mc->cfd, curs, sizeof curs);
    }
}
@


\section{Events}

% have lots of dupes with events, menuhit.c vs emenuhit.c?

<<enum _anon_ (include/event.h)>>=
enum
{
    Emouse	= 1,
    Ekeyboard	= 2,
};
@

% dupe
<<struct Mouse>>=
struct	Mouse
{
    int		buttons;	/* bit array: LMR=124 */
    Point	xy;
    ulong	msec;
};
@

<<struct Event>>=
struct	Event
{
    int		kbdc;
    Mouse	mouse;
    int		n;		/* number of characters in message */
    void	*v;		/* data unpacked by general event-handling function */
    uchar	data[EMAXMSG];	/* message from an arbitrary file descriptor */
};
@


























\chapter{Widgets}

\section{Libpanel}
% different alloc, different event loop, 
% and the Panel main data structure



\section{Frame}
% have libframe/ but also a frame widge in libpanel

\section{Scrolling}
% have also a menu in libpanel, scrollbar

\section{Menu}
% have also a menu in libpanel, popup, pulldown

\section{Button}

\section{Label}

\section{Text entry}

\section{Completion}

\section{Slider}

\section{List}

\section{Pack}

\section{Canvas}

\section{Text view}

\section{Rich text}

\chapter{Advanced Topics}

\section{Bezier}
% spline

% no kernel support I think, it just use the previous building blocks

<<constant PINC>>=
#define	PINC	32		/* realloc granularity */
@

<<struct Plist>>=
struct Plist
{
    Point *p;
    int np;			/* -1 if malloc/realloc failed */
};
@

<<function appendpt>>=
static void
appendpt(Plist *l, Point p)
{
    if(l->np == -1)
        return;
    if(l->np == 0)
        l->p = malloc(PINC*sizeof(Point));
    else if(l->np%PINC == 0)
        l->p = realloc(l->p, (l->np+PINC)*sizeof(Point));
    if(l->p == 0){
        l->np = -1;
        return;
    }
    l->p[l->np++] = p;
}
@

<<function normsq>>=
static int
normsq(Point p)
{
    return p.x*p.x+p.y*p.y;
}
@

<<function psdist>>=
static int
psdist(Point p, Point a, Point b)
{
    int num, den;

    p = subpt(p, a);
    b = subpt(b, a);
    num = p.x*b.x + p.y*b.y;
    if(num <= 0)
        return normsq(p);
    den = normsq(b);
    if(num >= den)
        return normsq(subpt(b, p));
    return normsq(subpt(divpt(mulpt(b, num), den), p));
}
@

<<function bpts1>>=
/*
 * Convert cubic Bezier curve control points to polyline
 * vertices.  Leaves the last vertex off, so you can continue
 * with another curve.
 */
static void
bpts1(Plist *l, Point p0, Point p1, Point p2, Point p3, int scale)
{
    Point p01, p12, p23, p012, p123, p0123;
    Point tp0, tp1, tp2, tp3;
    tp0=divpt(p0, scale);
    tp1=divpt(p1, scale);
    tp2=divpt(p2, scale);
    tp3=divpt(p3, scale);
    if(psdist(tp1, tp0, tp3)<=1 && psdist(tp2, tp0, tp3)<=1){
        appendpt(l, tp0);
        appendpt(l, tp1);
        appendpt(l, tp2);
    }
    else{
        /*
         * if scale factor is getting too big for comfort,
         * rescale now & concede the rounding error
         */
        if(scale>(1<<12)){
            p0=tp0;
            p1=tp1;
            p2=tp2;
            p3=tp3;
            scale=1;
        }
        p01=addpt(p0, p1);
        p12=addpt(p1, p2);
        p23=addpt(p2, p3);
        p012=addpt(p01, p12);
        p123=addpt(p12, p23);
        p0123=addpt(p012, p123);
        bpts1(l, mulpt(p0, 8), mulpt(p01, 4), mulpt(p012, 2), p0123, scale*8);
        bpts1(l, p0123, mulpt(p123, 2), mulpt(p23, 4), mulpt(p3, 8), scale*8);
    }
}
@

<<function bpts>>=
static void
bpts(Plist *l, Point p0, Point p1, Point p2, Point p3)
{
    bpts1(l, p0, p1, p2, p3, 1);
}
@

<<function bezierpts>>=
static void
bezierpts(Plist *l, Point p0, Point p1, Point p2, Point p3)
{
    bpts(l, p0, p1, p2, p3);
    appendpt(l, p3);
}
@

<<function _bezsplinepts>>=
static void
_bezsplinepts(Plist *l, Point *pt, int npt)
{
    Point *p, *ep;
    Point a, b, c, d;
    int periodic;

    if(npt<3)
        return;
    ep = &pt[npt-3];
    periodic = eqpt(pt[0], ep[2]);
    if(periodic){
        a = divpt(addpt(ep[1], pt[0]), 2);
        b = divpt(addpt(ep[1], mulpt(pt[0], 5)), 6);
        c = divpt(addpt(mulpt(pt[0], 5), pt[1]), 6);
        d = divpt(addpt(pt[0], pt[1]), 2);
        bpts(l, a, b, c, d);
    }
    for(p=pt; p<=ep; p++){
        if(p==pt && !periodic){
            a = p[0];
            b = divpt(addpt(p[0], mulpt(p[1], 2)), 3);
        }
        else{
            a = divpt(addpt(p[0], p[1]), 2);
            b = divpt(addpt(p[0], mulpt(p[1], 5)), 6);
        }
        if(p==ep && !periodic){
            c = divpt(addpt(mulpt(p[1], 2), p[2]), 3);
            d = p[2];
        }
        else{
            c = divpt(addpt(mulpt(p[1], 5), p[2]), 6);
            d = divpt(addpt(p[1], p[2]), 2);
        }
        bpts(l, a, b, c, d);
    }
    appendpt(l, d);
}
@

<<function bezsplinepts>>=
int
bezsplinepts(Point *pt, int npt, Point **pp)
{
    Plist l;
    l.np = 0;
    l.p = nil;
    _bezsplinepts(&l, pt, npt);
    *pp  = l.p;
    return l.np;
}
@

<<function bezier>>=
int
bezier(Image *dst, Point p0, Point p1, Point p2, Point p3, int end0, int end1, int radius, Image *src, Point sp)
{
    return bezierop(dst, p0, p1, p2, p3, end0, end1, radius, src, sp, SoverD);
}
@

<<function bezierop>>=
int
bezierop(Image *dst, Point p0, Point p1, Point p2, Point p3, int end0, int end1, int radius, Image *src, Point sp, Drawop op)
{
    Plist l;

    l.np = 0;
    bezierpts(&l, p0, p1, p2, p3);
    if(l.np == -1)
        return 0;
    if(l.np != 0){
        polyop(dst, l.p, l.np, end0, end1, radius, src, addpt(subpt(sp, p0), l.p[0]), op);
        free(l.p);
    }
    return 1;
}
@

<<function bezspline>>=
int
bezspline(Image *dst, Point *pt, int npt, int end0, int end1, int radius, Image *src, Point sp)
{
    return bezsplineop(dst, pt, npt, end0, end1, radius, src, sp, SoverD);
}
@

<<function bezsplineop>>=
int
bezsplineop(Image *dst, Point *pt, int npt, int end0, int end1, int radius, Image *src, Point sp, Drawop op)
{
    Plist l;

    l.np = 0;
    _bezsplinepts(&l, pt, npt);
    if(l.np==-1)
        return 0;
    if(l.np != 0){
        polyop(dst, l.p, l.np, end0, end1, radius, src, addpt(subpt(sp, pt[0]), l.p[0]), op);
        free(l.p);
    }
    return 1;
}
@

<<function fillbezier>>=
int
fillbezier(Image *dst, Point p0, Point p1, Point p2, Point p3, int w, Image *src, Point sp)
{
    return fillbezierop(dst, p0, p1, p2, p3, w, src, sp, SoverD);
}
@

<<function fillbezierop>>=
int
fillbezierop(Image *dst, Point p0, Point p1, Point p2, Point p3, int w, Image *src, Point sp, Drawop op)
{
    Plist l;

    l.np = 0;
    bezierpts(&l, p0, p1, p2, p3);
    if(l.np == -1)
        return 0;
    if(l.np != 0){
        fillpolyop(dst, l.p, l.np, w, src, addpt(subpt(sp, p0), l.p[0]), op);
        free(l.p);
    }
    return 1;
}
@

<<function fillbezspline>>=
int
fillbezspline(Image *dst, Point *pt, int npt, int w, Image *src, Point sp)
{
    return fillbezsplineop(dst, pt, npt, w, src, sp, SoverD);
}
@

<<function fillbezsplineop>>=
int
fillbezsplineop(Image *dst, Point *pt, int npt, int w, Image *src, Point sp, Drawop op)
{
    Plist l;

    l.np = 0;
    _bezsplinepts(&l, pt, npt);
    if(l.np == -1)
        return 0;
    if(l.np > 0){
        fillpolyop(dst, l.p, l.np, w, src, addpt(subpt(sp, pt[0]), l.p[0]), op);
        free(l.p);
    }
    return 1;
}
@



\section{Menus}


\chapter{Conclusion}

\appendix

\chapter{Debugging}

% to debug drawmesg()
<<function printmesg>>=
static void
printmesg(char *fmt, uchar *a, bool plsprnt)
{
    char buf[256];
    char *p, *q;
    int s, left;

    if(1|| plsprnt==false){
        SET(s,q,p);
        USED(fmt, a, buf, p, q, s);
        return;
    }

    q = buf;
    *q++ = *a++;
    for(p=fmt; *p; p++){
        left = sizeof buf - 2 - (q - buf);  /* 2 for \n\0 */
        switch(*p){
        case 'l':
            q += snprint(q, left, " %ld", (long)BGLONG(a));
            a += 4;
            break;
        case 'L':
            q += snprint(q, left, " %.8lux", (ulong)BGLONG(a));
            a += 4;
            break;
        case 'R':
            q += snprint(q, left, " [%d %d %d %d]", BGLONG(a),
                BGLONG(a+4), BGLONG(a+8), BGLONG(a+12));
            a += 16;
            break;
        case 'P':
            q += snprint(q, left, " [%d %d]", BGLONG(a), BGLONG(a+4));
            a += 8;
            break;
        case 'b':
            q += snprint(q, left, " %d", *a++);
            break;
        case 's':
            q += snprint(q, left, " %d", BGSHORT(a));
            a += 2;
            break;
        case 'S':
            q += snprint(q, left, " %.4ux", BGSHORT(a));
            a += 2;
            break;
        }
    }
    *q++ = '\n';
    *q = 0;
    iprint("%.*s", (int)(q-buf), buf);
}
@




% libdraw
<<global _drawdebug>>=
bool	_drawdebug = 0;
@

% libmemdrawn
<<global drawdebug>>=
bool drawdebug;
@



<<global debuglockdisplay>>=
int		debuglockdisplay = 0;
@


<<function drawsetdebug>>=
void
drawsetdebug(int v)
{
    uchar *a;
    a = bufimage(display, 1+1);
    if(a == 0){
        fprint(2, "drawsetdebug: %r\n");
        return;
    }
    a[0] = 'D';
    a[1] = v;
}
@

<<[[drawmesg()]] cases>>=
/* toggle debugging: 'D' val[1] */
case 'D':
    printmesg(fmt="b", a, 0);
    m = 1+1;
    if(n < m)
        error(Eshortdraw);
    drawdebug = a[1];
    continue;
@


\chapter{Error Managment}

<<function drawerror>>=
void
drawerror(Display *d, char *s)
{
    char err[ERRMAX];

    if(d && d->error)
        d->error(d, s);
    else{
        errstr(err, sizeof err);
        fprint(2, "draw: %s: %s\n", s, err);
        exits(s);
    }
}
@


\chapter{VGA driver}

\chapter{Mathematics}

\section{Trigonometric functions}

<<global sinus>>=
/*
 * Integer sine and cosine for integral degree argument.
 * Tables computed by (sin,cos)(PI*d/180).
 */
static short sinus[91] = {
    0,	/* 0 */
    18,	/* 1 */
    36,	/* 2 */
    54,	/* 3 */
    71,	/* 4 */
    89,	/* 5 */
    107,	/* 6 */
    125,	/* 7 */
    143,	/* 8 */
    160,	/* 9 */
    178,	/* 10 */
    195,	/* 11 */
    213,	/* 12 */
    230,	/* 13 */
    248,	/* 14 */
    265,	/* 15 */
    282,	/* 16 */
    299,	/* 17 */
    316,	/* 18 */
    333,	/* 19 */
    350,	/* 20 */
    367,	/* 21 */
    384,	/* 22 */
    400,	/* 23 */
    416,	/* 24 */
    433,	/* 25 */
    449,	/* 26 */
    465,	/* 27 */
    481,	/* 28 */
    496,	/* 29 */
    512,	/* 30 */
    527,	/* 31 */
    543,	/* 32 */
    558,	/* 33 */
    573,	/* 34 */
    587,	/* 35 */
    602,	/* 36 */
    616,	/* 37 */
    630,	/* 38 */
    644,	/* 39 */
    658,	/* 40 */
    672,	/* 41 */
    685,	/* 42 */
    698,	/* 43 */
    711,	/* 44 */
    724,	/* 45 */
    737,	/* 46 */
    749,	/* 47 */
    761,	/* 48 */
    773,	/* 49 */
    784,	/* 50 */
    796,	/* 51 */
    807,	/* 52 */
    818,	/* 53 */
    828,	/* 54 */
    839,	/* 55 */
    849,	/* 56 */
    859,	/* 57 */
    868,	/* 58 */
    878,	/* 59 */
    887,	/* 60 */
    896,	/* 61 */
    904,	/* 62 */
    912,	/* 63 */
    920,	/* 64 */
    928,	/* 65 */
    935,	/* 66 */
    943,	/* 67 */
    949,	/* 68 */
    956,	/* 69 */
    962,	/* 70 */
    968,	/* 71 */
    974,	/* 72 */
    979,	/* 73 */
    984,	/* 74 */
    989,	/* 75 */
    994,	/* 76 */
    998,	/* 77 */
    1002,	/* 78 */
    1005,	/* 79 */
    1008,	/* 80 */
    1011,	/* 81 */
    1014,	/* 82 */
    1016,	/* 83 */
    1018,	/* 84 */
    1020,	/* 85 */
    1022,	/* 86 */
    1023,	/* 87 */
    1023,	/* 88 */
    1024,	/* 89 */
    1024,	/* 90 */
};
@

<<function icossin>>=
void
icossin(int deg, int *cosp, int *sinp)
{
    int sinsign, cossign;
    short *stp, *ctp;

    deg %= 360;
    if(deg < 0)
        deg += 360;
    sinsign = 1;
    cossign = 1;
    stp = 0;
    ctp = 0;
    switch(deg/90){
    case 2:
        sinsign = -1;
        cossign = -1;
        deg -= 180;
        /* fall through */
    case 0:
        stp = &sinus[deg];
        ctp = &sinus[90-deg];
        break;
    case 3:
        sinsign = -1;
        cossign = -1;
        deg -= 180;
        /* fall through */
    case 1:
        deg = 180-deg;
        cossign = -cossign;
        stp = &sinus[deg];
        ctp = &sinus[90-deg];
        break;
    }
    *sinp = sinsign*stp[0];
    *cosp = cossign*ctp[0];
}
@



<<global sinus (lib_graphics/libdraw/icossin2.c)>>=
/*
 * Sine and Cosine of arctangents, calculated by 
 *   (sin(atan(index/100.0))*1024.+0.5)
 *   (cos(atan(index/100.0))*1024.+0.5)
 * To use, get rational tangent between 0<=tan<=1, scale by 100,
 * and look up sin and cos, and use linear interpolation.  divide by 1024.
 * Maximum error is 0.0020.  Without linear interpolation, it's 0.010.
 */
static
short sinus[] = {
    0,	/* 0.00 */
    10,	/* 0.01 */
    20,	/* 0.02 */
    31,	/* 0.03 */
    41,	/* 0.04 */
    51,	/* 0.05 */
    61,	/* 0.06 */
    72,	/* 0.07 */
    82,	/* 0.08 */
    92,	/* 0.09 */
    102,	/* 0.10 */
    112,	/* 0.11 */
    122,	/* 0.12 */
    132,	/* 0.13 */
    142,	/* 0.14 */
    152,	/* 0.15 */
    162,	/* 0.16 */
    172,	/* 0.17 */
    181,	/* 0.18 */
    191,	/* 0.19 */
    201,	/* 0.20 */
    210,	/* 0.21 */
    220,	/* 0.22 */
    230,	/* 0.23 */
    239,	/* 0.24 */
    248,	/* 0.25 */
    258,	/* 0.26 */
    267,	/* 0.27 */
    276,	/* 0.28 */
    285,	/* 0.29 */
    294,	/* 0.30 */
    303,	/* 0.31 */
    312,	/* 0.32 */
    321,	/* 0.33 */
    330,	/* 0.34 */
    338,	/* 0.35 */
    347,	/* 0.36 */
    355,	/* 0.37 */
    364,	/* 0.38 */
    372,	/* 0.39 */
    380,	/* 0.40 */
    388,	/* 0.41 */
    397,	/* 0.42 */
    405,	/* 0.43 */
    412,	/* 0.44 */
    420,	/* 0.45 */
    428,	/* 0.46 */
    436,	/* 0.47 */
    443,	/* 0.48 */
    451,	/* 0.49 */
    458,	/* 0.50 */
    465,	/* 0.51 */
    472,	/* 0.52 */
    480,	/* 0.53 */
    487,	/* 0.54 */
    493,	/* 0.55 */
    500,	/* 0.56 */
    507,	/* 0.57 */
    514,	/* 0.58 */
    520,	/* 0.59 */
    527,	/* 0.60 */
    533,	/* 0.61 */
    540,	/* 0.62 */
    546,	/* 0.63 */
    552,	/* 0.64 */
    558,	/* 0.65 */
    564,	/* 0.66 */
    570,	/* 0.67 */
    576,	/* 0.68 */
    582,	/* 0.69 */
    587,	/* 0.70 */
    593,	/* 0.71 */
    598,	/* 0.72 */
    604,	/* 0.73 */
    609,	/* 0.74 */
    614,	/* 0.75 */
    620,	/* 0.76 */
    625,	/* 0.77 */
    630,	/* 0.78 */
    635,	/* 0.79 */
    640,	/* 0.80 */
    645,	/* 0.81 */
    649,	/* 0.82 */
    654,	/* 0.83 */
    659,	/* 0.84 */
    663,	/* 0.85 */
    668,	/* 0.86 */
    672,	/* 0.87 */
    676,	/* 0.88 */
    681,	/* 0.89 */
    685,	/* 0.90 */
    689,	/* 0.91 */
    693,	/* 0.92 */
    697,	/* 0.93 */
    701,	/* 0.94 */
    705,	/* 0.95 */
    709,	/* 0.96 */
    713,	/* 0.97 */
    717,	/* 0.98 */
    720,	/* 0.99 */
    724,	/* 1.00 */
    728,	/* 1.01 */
};
@

<<global cosinus>>=
static
short cosinus[] = {
    1024,	/* 0.00 */
    1024,	/* 0.01 */
    1024,	/* 0.02 */
    1024,	/* 0.03 */
    1023,	/* 0.04 */
    1023,	/* 0.05 */
    1022,	/* 0.06 */
    1022,	/* 0.07 */
    1021,	/* 0.08 */
    1020,	/* 0.09 */
    1019,	/* 0.10 */
    1018,	/* 0.11 */
    1017,	/* 0.12 */
    1015,	/* 0.13 */
    1014,	/* 0.14 */
    1013,	/* 0.15 */
    1011,	/* 0.16 */
    1010,	/* 0.17 */
    1008,	/* 0.18 */
    1006,	/* 0.19 */
    1004,	/* 0.20 */
    1002,	/* 0.21 */
    1000,	/* 0.22 */
    998,	/* 0.23 */
    996,	/* 0.24 */
    993,	/* 0.25 */
    991,	/* 0.26 */
    989,	/* 0.27 */
    986,	/* 0.28 */
    983,	/* 0.29 */
    981,	/* 0.30 */
    978,	/* 0.31 */
    975,	/* 0.32 */
    972,	/* 0.33 */
    969,	/* 0.34 */
    967,	/* 0.35 */
    963,	/* 0.36 */
    960,	/* 0.37 */
    957,	/* 0.38 */
    954,	/* 0.39 */
    951,	/* 0.40 */
    947,	/* 0.41 */
    944,	/* 0.42 */
    941,	/* 0.43 */
    937,	/* 0.44 */
    934,	/* 0.45 */
    930,	/* 0.46 */
    927,	/* 0.47 */
    923,	/* 0.48 */
    920,	/* 0.49 */
    916,	/* 0.50 */
    912,	/* 0.51 */
    909,	/* 0.52 */
    905,	/* 0.53 */
    901,	/* 0.54 */
    897,	/* 0.55 */
    893,	/* 0.56 */
    890,	/* 0.57 */
    886,	/* 0.58 */
    882,	/* 0.59 */
    878,	/* 0.60 */
    874,	/* 0.61 */
    870,	/* 0.62 */
    866,	/* 0.63 */
    862,	/* 0.64 */
    859,	/* 0.65 */
    855,	/* 0.66 */
    851,	/* 0.67 */
    847,	/* 0.68 */
    843,	/* 0.69 */
    839,	/* 0.70 */
    835,	/* 0.71 */
    831,	/* 0.72 */
    827,	/* 0.73 */
    823,	/* 0.74 */
    819,	/* 0.75 */
    815,	/* 0.76 */
    811,	/* 0.77 */
    807,	/* 0.78 */
    804,	/* 0.79 */
    800,	/* 0.80 */
    796,	/* 0.81 */
    792,	/* 0.82 */
    788,	/* 0.83 */
    784,	/* 0.84 */
    780,	/* 0.85 */
    776,	/* 0.86 */
    773,	/* 0.87 */
    769,	/* 0.88 */
    765,	/* 0.89 */
    761,	/* 0.90 */
    757,	/* 0.91 */
    754,	/* 0.92 */
    750,	/* 0.93 */
    746,	/* 0.94 */
    742,	/* 0.95 */
    739,	/* 0.96 */
    735,	/* 0.97 */
    731,	/* 0.98 */
    728,	/* 0.99 */
    724,	/* 1.00 */
    720,	/* 1.01 */
};
@

<<function icossin2>>=
void
icossin2(int x, int y, int *cosp, int *sinp)
{
    int sinsign, cossign, tan, tan10, rem;
    short *stp, *ctp;

    if(x == 0){
        if(y >= 0)
            *sinp = ICOSSCALE, *cosp = 0;
        else
            *sinp = -ICOSSCALE, *cosp = 0;
        return;
    }
    sinsign = cossign = 1;
    if(x < 0){
        cossign = -1;
        x = -x;
    }
    if(y < 0){
        sinsign = -1;
        y = -y;
    }
    if(y > x){
        tan = 1000*x/y;
        tan10 = tan/10;
        stp = &cosinus[tan10];
        ctp = &sinus[tan10];
    }else{
        tan = 1000*y/x;
        tan10 = tan/10;
        stp = &sinus[tan10];
        ctp = &cosinus[tan10];
    }
    rem = tan-(tan10*10);
    *sinp = sinsign*(stp[0]+(stp[1]-stp[0])*rem/10);
    *cosp = cossign*(ctp[0]+(ctp[1]-ctp[0])*rem/10);
}
@



\chapter{Libc}

\chapter{Extra Code}

\ifallcode
#include "Graphics_extra.tex.nw"
\fi

\chapter{Changelog}
\label{sec:changelog}

\chapter{Glossary}
\label{sec:glossary}

\begin{verbatim}
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{section}{Index}

%\chapter{References} 
\addcontentsline{toc}{section}{References}

\begin{thebibliography}{99}

\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming}, 
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb}, 
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison}, 
\url{http://padator.org/software/project-syncweb/readme.txt}

\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
