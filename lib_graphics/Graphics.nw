\documentclass[twocolumn, landscape]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse % see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things:
% - removed deadcode (Displaybufsize, drawbuf/ndrawbuf, Display.dataqid,
%    Display.isnew, Memdata.imref, convxx[], fillxxx(), mkfont(),
%    openmemsubfont(), stringsubfont(), ... 
%    and more, see the %dead in this file
% - screen.h cleaner interface
% - renamed some globals (screen -> view, _screen -> screen)
%   TODO gscreen, screenimage, vgascr, so easier to see associated part
%   TODO or merge globals (screenimage and gscreen, can?)
% - TODO transformed globals in locals (softscreen)

%thx to codemap/codegraph/scheck:
% - SEMI use cg to reduce backward deps, introduce globals.c, utils.c,
%   (harder to understand non layered code)
% - TODO use scheck to remove deadcode, dead prototypes, useless export
%   or mv as forward decl
%   (harder to understand big interface files)
% - TODO use cg to reduce number of globals by moving them closer to the
%   relevant file (or even function), better cluster the code
%   (harder to understand non functional code using lots of globals)

%thx to this manual, better understand svgalib? tronscroll:) mode X? cairo?:
%  - graphics terminology, I didn't take Image option at INSA
%  - raster vs vector graphics, discrete pixels vs continuous geometry shape
%  - channels are the size spec for the different pixel components
%    and the source of many pixel formats
%  - alpha channel is a way to encode transparency strenght for compositing
%    operations
%  - clipping is to restrict operations on a rectangle, essential
%  - tiling is replicating a simple pattern repeatidely
%  - antialiasing is just a simple way to remove effect d'escalier by setting
%    the lightness of a pixel to be function of its distance to the ideal point
%  - scanline algorithm for polygons (subtle)
%  - TODO bezier (could be useful for edge bunding visual)
%    that they are the essence of vectoriel fonts?
%  - TODO understand freshrate, double buffer, vertical sync, flickering,
%    refresh sync
%  - SEMI need for painting-like algorithm for windows, as they overlap and
%    have stuff in front and back, or a more optimized variant where
%    use save image and tricky RECURS


%history LP-ization:
% - skeleton, mostly copy paste of Template.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * TODO ctor/dtor, dumper
%    * [[xxx]] other fields, [[xxx]] extra fields
% - read Extra section, identify concepts, first TOC
% - distribute parts of the Extra section in the main file
% - understand main(), LP split main, improve TOC
% - understand main functions, LP split, cluster, improve TOC
% - LP split the structures, use datalog for flow to field info
% - nullify, boolify, errorify, enumify,  typeify,    scheckify, plan9ify
% - aspecify advanced features! remove useless features
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% ifallcode is used for:
%  - forward decl, func decl, extern decl, #ifdef, pragmas (stuff in Extra.nw)
%  - ??

\setcounter{tocdepth}{2}

\addtolength{\topmargin}{-.850in}
\addtolength{\textheight}{1.70in}

\begin{document}
%******************************************************************************
% Title
%******************************************************************************
\title{
{\Huge 
Principia Softwarica: The Plan~9 Graphics System [[/dev/draw/]]
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}\\
\\
with code from\\
Rob Pike and Russ Cox
}
% really?

\maketitle 

\onecolumn
\hrule
\input{../docs/latex/Copyright}
\input{../docs/latex/CopyrightPlan9}
\hrule
\twocolumn

\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\tableofcontents
\endgroup

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

The goal of this book is to present with full details the source code of
a {graphics system}.

\section{Motivations}

Why a graphics system? Because we think you are a better programmer if
you fully understand how things work under the hood, and
with so many fancy graphics on your screen, there are plenty
of things happening under the hood to be understood.

% Part hardware/software too. Actually more and more done by
% hardware. 3d. But here only 2d and in software mostly.
% Drawing API essentially. But also need mediate shared resource,
% screen, in kernel. 
% (Actually good if also networked, like X11)

Here are a few questions we hope this book will answer:
\begin{itemize}
\item How graphical elements such as  rectangles, lines, circles, or arcs, are
rendered on the screen? How the graphics card helps? How
the kernel helps? 

\item Which low-level instructions allow to modify the screen?

\item How the picture on the screen is represented in the machine?
What is a framebuffer?

\item What are the algorithms to draw arbitrary lines
(e.g. non-vertical and non-horizontal lines)
on a rectangular aligned set of pixels (the screen)?
% or polygons

\item How pictures are represented in memory? How they
are stored on the disk? What is the format of a JPG file?

\item What is the alpha channel?

\item What is rasterization? What are vector graphics?

\item How characters are drawn on the screen? 
How fonts are managed? What are truetype fonts? 

\item What is anti-aliasing?

\item How is the mouse cursor handled?

\end{itemize}
\l how cooperate with windowing system?
\l how implement overlapping windows? 

\t put in conclusion non-trivial adv algo and data structures seen? see comment
%data-structures:
% - double linked lists (windows in Screen.frontmost)
% - growing array (Kdraw.clients, Font.subf, ...)
% - growing hashtable with buckets inline in array (Font.cache)
%   and lookup small window when hash conflict (jordan/julien did that
%   for hh_server no?)
% - glyphs pictures and glyphs cache (a bit like sprite cache?)
% - moveable shared area with backward pointer to intermediate wrapper

%algorithms:
% - bitblt
% - fill polygon, quite complex
% - ellipses, arcs, bezier
% - layerop, overlapping windows with save and interception and RECURS

\section{\plan{} [[/dev/draw/]]}

We will explain in this book the code of the \plan graphics
system, visible to the user through its [[/dev/draw/]] {device directory}.
% Graphics related to mouse, so will see also code for
%and also partially through the [[/dev/mouse]] and [[/dev/cons]] {device files}.

% LOC?
% 2d Graphics library.
% visible to programmer mostly through include/draw.h

% It actually provides some forms of windows managment (overlapping windows
% with backing store), and even menus (but rio is more complete).
% It can also be remote like X11! for free! can draw through the network, and
% so have graphical application running on one machine but displaying
% result on your (powerful! like browser! and web app!)

% screenshot?

% bad stuff of draw though: most of the code is in the kernel :(
% but lots of stuff can be in library and can be tested outside
% (see memdrawtest), but still a bit ugly. The images, fonts,
% reside in special kernel memory (imagmem).


% actually almost one of the first graphics system!
% Alto -> Blit (a cheap Alto) -> ... /dev/draw
%      |> Macintosh -> Microsoft Window -> ...
%      |> X11 (or comes from MIT Lisp Machine?)

% Xerox vs Bell Labs !

\section{Other graphics systems}

Here are a few graphics systems that were considered for this book 
but which were ultimately discarded:
\begin{itemize}

\item gks
% the seminal one? but present in any real system?
% or was it bitblt and the blit machine?

% OO graphics, from GKS and PHIGS to OO systems
%https://books.google.com/books?id=KUWqCAAAQBAJ

\item SRGP (Simple Raster Graphics Package)
% used in second edition of CGPP book. But actual reference implementation?
%  or implemented by calling Xlib, Quickdraw, etc?
% (SGP discussed in the first edition of cgpp book
%  and based on siggraph core 1979 standard)
% SPHIGS was for 3d (Simple PHIGS, where PHIGS was a precursor of openGL)
% 3rd edition use WPF, argh, and apparently does not discuss old style
%  scanline algorithms.

\item Postscript
% maybe every drawing APIs after took Postscript as a model?
% with idea of Context?

\item X11/Xlib
% remote, so cool, bug very very big
% rely also on libpixman now, they factorized code with cairo
% "why X11 is so big" by Ken Thompson, partly the motivation for plan9
% "A simple X11 Client Prgram or Hoa hard it can really be to write
%  hello world" = David Rosenthal
% X11 is multiple things at the same time, graphics system and windowing
% system (but not window manager), but in plan9 this is decoupled.

\item OpenGL
% mostly 3d! can do also 2d. gouraud, shading, textures, 3d rasterizer, etc.
%not much key/mouse/menu thing, like here actually
% tinyGL of bellard (openGL in software).
% Mesa? (openGL also in software no?)
%recent: vulkan, just got out, but looks far more low-level

\item Cairo
% 2d graphics lib with support for many output "devices",
% xwindow, quartz, win32, image buffer, pdf, postscript, svg, opengl, directFB.
% used in firefox
% can leverage hardware acceleration.
% operations similar to drawing operators of postscript and pdf
% from readme:
%  Operations in cairo include stroking and filling
%  cubic BÃ©zier splines, transforming and compositing translucent images,
%  and antialiased text rendering. All drawing operations can be
%  transformed by any affine transformation (scale, rotation, shear,
%  etc.).
% 350 K with tests
% rely on libpixman for pixel stuff, channels, move, etc.

% maybe API simpler than the one of plan9. I get confused with the 
% complex parameters of draw(), the rectangles and point and clipping.

% cairo also handle affine transformation, scaling, rotate, etc a la OpenGL.
% /dev/draw does not (but could make higher-level lib that does).

\item skia
% used in android and chrome


\item NX graphics
% nuttx has some graphic and windowing stack apparently too!
%http://nuttx.org/doku.php?id=documentation:nxgraphics

\end{itemize}

%#industry:
% - WPF (Windows Presentation Framework?), used by 3rd ed of CGPP book. sad.
% - CoreGraphics (and before QuickDraw)
% - Quartz, relate to macos expose? advanced graphics there
% - Flash
%history:
% - Xerox Alto! first bitmap, bitblt, started in 1973
% - Lisp Machine?
% - Blit
% - Smalltalk
% - X
%mini:
% - mini X
% - nano X (was microwindows)
%other:
% - PDF, SVG, canvas, ... 
% - opengl and glut. the menuhit function is kinda related to glut.
% - wayland, mir
% - http://www.helenos.org/doc/theses/pk-thesis.pdf
%wrappers:
% - SDL, SFML, Allegro, Clanlib
% - ocamlgraphics (cleaner/portable interface on top of X11 or windows graphics)
%oldies:
% - svgalib
%#research:
%  - Nile/Gezira DSL from vpri

%advanced:
% http://www.adriancourreges.com/blog/2015/11/02/gta-v-graphics-study/
%old-school style, pc-bible spirit and mode-X:
% http://www.dustmop.io/blog/2015/12/18/nes-graphics-part-3/


\section{Getting started}
% x86
\n no rio yet, really getting started so minimal!

% install driver command? #vga?
% install devdraw #i

% compile and test toy graphical app /tests/draw/ ?

% FIGURE screenshot


\section{Requirements}

% C as usual.

% Basic geometry.
% assume Computer Graphics, Principles and Practice (CGPP) by Foley et al.?
%  Maybe for drawing shapes chapter? Too long otherwise to explain algorithm?
% other books? no, most books focused on 3d anyway.

% graphics(2)!! for big picture
%  great (a few changes though, like screen -> view)
% draw(2) for API
% draw(3) for protocol
% image(6) for image format

% http://blog.golang.org/go-imagedraw-package
% http.golang.org/go-image-package

% memdraw(2) API of libmemdraw, should not be used by user directly,
%  internal code

%advanced: more for later chapters
% font(6)
% window(2) 
% mouse(3)
%note that CGPP talks also about windowing system I think.

% lib_graphics/docs/blit.pdf, lib_graphics/docs/pike-bitmap.ps
% plan9-in-technicolor.ps? meh.

% Principle of Interactive Computer Graphics, Newman and Sproull, McGraw-Hill
%  1979
% seems seminal book about vector graphics, and source for GKS 
% (from pike84bitblt.pdf), even cited by Alto paper

\section{About this document}
#include "../docs/latex/About.nw"

\section{Copyright}

Most of this document is actually source code from \plan, so
those parts are copyright by Lucent Technologies Inc.
The prose is mine and is licensed under the \license.

\section{Acknowledgments}

I would like to acknowledge of course \plan's authors who wrote
most of this book: Rob Pike, Russ Cox, and many other people
from Bell Labs.






\chapter{Overview}

\section{Graphics system principles}
%https://en.wikipedia.org/wiki/Computer_graphics

% pike84bitbltd.pdf intro is pretty good to describe early history
% of graphics, rational for things.


% graphics system =~ screen drawing API


% screen made of pixels. Lots of them. Resolution. Depth/encoding. Image(s)!!
% software/hardware interface can be as simple as a framebuffer (e.g. bcm/).
% pixels, so not continuous! so if draw diagonal, then no that easy actually :)
% => bresenham algorithm, scanline algorithm.

% history was bitmap because black/white and one pixel = 1 bit, so
% had a map of bits (bitmap). Fundamental was bitblt.

% FIGURE, scale

% horiz/vert lines, rectangle, arbitrary line, polyline, polygon (fill),
% ellipse, arc, bezier,
% and also text (fonts) which are special kind of pictures (bezier? or raster?)
% colors, alpha, channels, color map
% "images", composition (porter-duff) so can have transluscent effect, 
% clipping, rotate/scale/transform (lacking in plan9).
% tiling (replicating) when used as a source.


% very generic and powerful operations: draw()! (like bitblt before) 
% see cairo intro? 

% notion of soft screen, flush, direct framebuffer are important.

% Note that principle is not to be a windowing system! independent!
% often correlated but in plan9 can run graphical app outside
% windowing system!!

% advanced: windows, menus, mouse/keyboard

%http://blog.mecheye.net/2012/06/the-linux-graphics-stack/
%http://blogs.igalia.com/itoral/2014/07/29/a-brief-introduction-to-the-linux-graphics-stack/

%other topics:
% - scale/rotate/transform not in this book. But can be library wrapper
%    over library presented here.
% - antialiasing (very simple actually, put light intensity in function of
%    distance to theoritical point on the line (the error))
% - true type fonts? bezier fonts that are vectoriel and so scalable?
% - Animation (Core Animation) not in this book either.
% - 3d. lighting. Not in this book. based on triangles usually.
% - physical rendering
% - GPU

\subsection{Raster graphics (Frame buffer, pixels, bitmaps)}
%https://en.wikipedia.org/wiki/Raster_graphics

% frame buffer, pixels, bitmaps, discrete, digital


% raster mean?

% {image} = two dimensional array, each element is a {pixel}

% from television industry, individual pixels, two dimentional array,
% framebuffer.
% After some time frame buffer less expensive to make than a vector
% display.
% Imperfect, discrete.
% But programmer should not be exposed to them and given access
% to ideal shapes of plane geometry

\subsection{Vector graphics (lines, arcs)}
% lines, shapes, continuous, analog

% from oscilloscope industry, description of lines, curves, shapes!
% was actually the first one to be invented. Analog! continuous.

\subsection{Rasterization}

% From ideal to concrete.

\subsection{[[bitblt()]] and Compositing}

\subsection{Advanced topics}


\section{[[/dev/draw/]] files interface}

% maybe code which initializes kernel? #v and #i


% /dev/draw/new, then ctl, then data protocol.
% can do stuff without API, just by writing in files.

% note that can run 'colors' in console outside rio! it just
% use /dev/draw, /dev/mouse, etc!

% see draw(3)


%from https://news.ycombinator.com/item?id=9829662
%> Why is reading plain text out of /dev/mouse and writing plain text
%to /dev/draw an improvement over how Linux or OS X or Windows does it?
%
%It's very useful because you don't need a C FFI to access OS
%functionality, graphics libraries and the like. Any language whose
%implementation allows you to read and write files can already do a lot
%of things (including GUIs, IPC and so on).

\section{A toy graphical application}

% API more convenient that direct IO and protocol.

% HelloGraphicalWorld.c ?
% e.g. colors? clock.c?

% use view? or display->image?

% see display, image, and draw() generic ops.
% see that colors that are actually images! very general (maybe too much).
%alt: different model is Context of X11, or cairo, or canvas or opengl

% maybe can zoom on line to see it's tricky to get diagonals
% with certain angles.

% a bit annoying that have to transform your xy into the final
% xy ourself by adding view->r.min. Not really "abstraction"
% power. I'd rather have my 0x0 to be the top left on _my_ window.
%update: actually you can, but you have to make your image a window
% which means you also have to create a Screen first.

%\section{A toy window application}
% has nothing to do! abstraction power!

% delay for later rio and /dev/winname? I think so. already quite complicated.
% but maybe can show that can under rio! magic! (and link to other book)
% /dev/winname! from noborder.xxx to window.xxx and then
% thanks to naming image, can find back image you need to write to!
% (instead of writing directly to the screen)


\section{Code organization}

% user code usually just have to do
% #include <draw.h>
% (in addition to u.h and libc.h)

% libdraw/, libmemdraw/, libmemlayer/, kernel/devices/screen/
% lofs of files have similar name in libdraw/ and libmemdraw/
\t could subdivide in further subdirs  image/ font/ input/ ...

%-------------------
% libdraw/
%-------------------

% libdraw is mostly for user DS and API that then just
% marshalled and delegate the actual work to /dev/draw
% normally apps must link just with libdraw.a (and not libmemdraw.a
% or libmemlayer.a!) (there are some apps that use memlayer too though
%  to implement a windowing like system inside the app, e.g. acme)
% can actually divide libdraw in two, have a libcoredraw (or libgeometry)
% so the kernel would not even depend on libdraw

%arith.c: Point and Rectangle ctor and arithmetic (+-/*)
% (libgeometry)

%icossin.c: math
%icossin2.c: math

%rectclip.c: rectclip() utility
%replclipr.c: replicate and clipping rectangle API
%drawrepl.c: replicate utilities

%misc.c: old image format

%a few other utilities appear later: bytesperline.c, chan.c

%debug.c
%fmt.c: dumper


%init.c: display, screen, images
\t could have a globals.c split from init.c

%draw.c: draw rectangle, or copy rectangles (easier draw horiz or vert)
 %border.c: draw border
%line.c: draw line (bresenham algorithm? not here, in libmemdraw/)
%poly.c: draw polylines
%ellipse.c: draw ellipse, and arcs
%bezier.c: draw spline

%string.c: draw text
 %stringbg.c: text with background

%alloc.c: alloc images
 %bytesperline.c: resolution -> malloc size 
  %(actually used in memdraw/alloc.c, but also here by readimage.c/...)
 %allocimagemix.c: used by menuhits

%chan.c: channel functions
%rgb.c: rgb

%readcolmap.c: dead? used in apps?
%writecolmap.c:

%loadimage.c: copy in kernel from user memory
%unloadimage.c: copy from kernel in user memory
%readimage.c: parse from file
%writeimage.c: write to file (in compressed format by default)

%cloadimage.c: compressed load image
%creadimage.c: compressed read image
%computil.c: compression utilities

%window.c: image "layers" (hmm but actually not transparent right now)
%newwindow.c:

%mouse.c:
%keyboard.c:
%getrect.c:
%menuhit.c:

%event.c:
%emenuhit.c:
%egetrect.c:

%scroll.c:

%defont.c: lucm/latin1.9, in uncompressed form

%font.c:
%buildfont.c:
%getdefont.c:


%subfont.c:
%getsubfont.c:
%freesubfont.c:
%subfontcache.c:
%subfontname.c:

%readsubfont.c:
%writesubfont.c:

%stringwidth.c

%openfont.c: dead or redundant with buildfont I think
%mkfont.c: dead (used in very few apps)
%stringsubfont.c: dead (or used in test code)


%-------------------
% kernel/drivers/screen/
%-------------------

% libdraw mostly wrapper on /dev/draw, marshall data, special protocol

% devdraw.c is the /dev/draw handler, especially drawmesg() dispatcher
%  to libmemdraw operations and libmemlayer operations
% should also have actual calls to screen.h implem,
% e.g. vgascreen.c!

% pool.c?: imagmem! image data store! (in kernel :( X11 spirit )
% devdraw.c: /dev/draw
% screen.c: factorize stuff, gscreen, soft cursor, cursor, graphic text mode
%  (I created it as a model of the one in bcm/)
% vgascreen.c: implem of screen.h hardware specific hooks needed by devdraw
%  and memdraw

% devvga.c: /dev/vga ctl files for vgascreen global parameters?
% vgavesa.c: vesa specifics? needed?
% vgaclgd542x.c: cirrus logic specifics

%-------------------
% libmemdraw/
%-------------------
% libmemdraw actually does the drawing stuff in memory
% (and rely on some kernel vga functions to do the rest and transfer
%  images from memory to the actual screen (or nop if framebuffer))
% it also rely on some code in libmemlayer.
% most apps should link only with libdraw. Only the kernel
% (and test programs) link with libmemdraw.a normally.

%draw.c: draw rectangle, actual memory code

%replmul.c: replmul global used in mktables to duplicate bits

%line.c:
%poly.c
%fillpoly.c
%ellipse.c
%arc.c

%alloc.c: memimage

%cmap.c (generated by scripts/mkcmap.c)

%load.c:
%unload.c:

%write.c: dupe, less important
%read.c: dupe, less important

%cload.c: compressed load
%cread.c: compressed read

%string.c: seems used only for graphical text mode, simple code at least
%defont.c: getmemdefont, used only for graphical text mode

%subfont.c: dead
%openmemsubfont.c: dead


%todo: could remove files below? who links with libmemdraw except 
% test files? they can define then the hwdraw(), iprint() empty handler
%hwdraw.c: kernel cruft
%iprint.c: kernel cruft
% when people link with memdraw outside the kernel
% then the linker will complain if no hwdraw() function,
% but normally hwdraw() should be a bridge to screen.h interface 
% functions? (implemented by vgascreen)


%-------------------
% libmemlayer/
%-------------------
% libmemlayer is really about overlapping windows. It's not really
%  layer in the cairo sese.
% Then one can easily implement a windowing system with 
% overlapping pictures (windows) that actually can get exposed back.
% Not sure why it's called layers. It's an additional layer before
% the actual image.

%adapter:
% draw.c: again, memdraw(), but should be in libmemdraw/
% line.c: again! memline(), but should be only for horizontal/vert here no?
% load.c:
% unload.c:

%layerop.c

%lalloc.c: memlayer alloc
%ldelete.c: memlayer free

%lsetrefresh.c

%window operations:
%lorigin.c: mv window (or its origin)
%lhide.c: expose/hide window
%ltofront.c: back to top
%ltorear.c: put to rear



\section{Software architecture}

% Memdraw is core algo. Used by kernel. Wrapped by kernel
% in some Dxxx (e.g. DImage). Memlayer is overlay on memdraw
% to handle overlapping windows and backstore. Kernel use memdraw. 
% User uses libdraw
% which just marshall and have id references mimicking
% stuff in memdraw hold in the kernel.

% id (for image, desktop, etc) is key. pass id instead of whole structure.

% draw() rectangle is fundamental! all other shapes are in term of draw().

% it's not a software, it's a library, so archi is first
% a set of functions and DS in draw.h! entry points!
% Then complicated archi because part done in kernel, part
% in user side, so need bridge, and marshalling and protocol.
% (but this could be skipped if reader interested only in core ideas).
% Moreover in kernel side also complicated because many different
% graphics card so split in different components.

% complicated archi. Even just user side is complicated. So when
% add kernel side, it can get tricky. Maybe easier to first
% show archi on user side, the relation between the important
% types (Display, Image, Rectangle, etc).

% maybe can also show the simplest interface, a framebuffer, and
% how /dev/draw build on top of that? In theory could have
% just a framebuffer and libmemdraw/ on top of it.

% = framebuffer or vga =
% = screen.h and gscreen Memimage =
% = libmemdraw/ =
%
% = libmemlayer/ =
% = draw device =
% = libdraw/ =
% = app =

% app, library, kernel draw server, kernel draw libs, vga driver
% kernel vs libs vs apps (vs rio)

% public API -> marshaller -> flush -> KERNEL -> unmarshaller -> algorithm
% some kind of RPC and protocol

% libdraw -> KERNEL -> devdraw -> libmemdraw | libmemlayer -> devvga -> clgd5446
% that's a lot of entities

% xxx, doxxx, memxxx, memlxxx, drawxxx, screenxxx

% Display (User side, dirno) Client (Kernel side, vga structure) 
%  Image (User side, id) MemImage (Kernel side, id -> full structure) DImage
%   can draw on that (lines, rectangles, lines, ellipses, text, etc)
%  Screen
%   Window (Image)

% devvga
%  why imagmem? why imagmem and mainmem? why not use other allocator?
%  see screen/user/notes.txt especially about the old way to get graphics on PC

% data structures archi:
%  Display|Image|display -> Client|MemImage|screen 
%    -> gscreen -> gscreendata.bdata and vgascreen.paddr?
% interface archi:
%  API -> marshall -> unmarshall 
%   -> algorithm libmemdraw (and libmemlayer sometimes)
%   -> screen.h interface (mostly flush image)
%   -> vgascr interface -> vgadev interface
%   -> actual hardware special operations


% read/load cload/cread
% unload/write
% ???

% what is the minimum we ask from hardware? just a screen.h interface?
% with a not too bad flushmemscreen? if look at screen.c for raspberry,
% most of screen.c is hardware independent (arrow picture, software cursor, 
% gscreen, window, curpos). The only hardware dependent is fbinit to
% initialize framebuffer. hwdraw() does nothing. flushmemscreen() does
% nothing. They just need a gscreen->bdata to point to a framebuffer
% and set the property of this memimage depending on the hardware
% (width, depth, chan). That's it!


% about RPC vs framebuffer.
% design goal was like X11 can be remote! can login on another
% machine, execute program there that actually display on your screen.
% for plan9 they just reuse 9p! network file system so /dev/draw
% can be on the network!
% but this design means it's not a framebuffer! it accepts
% drawing commands, like in X11, because can't allow to send
% all pixels each time through big write on /dev/draw over the network
% (hmm actually with high speed network maybe we could)

% the API seems mostly stateless. As opposed to ocaml graphics
% where you move the cursor and then ask to draw stuff, here
% you specify each time. The API is also very general, see draw().


\section{Initialization overview}

% more in Chapter X.

\section{Trace of a simple drawing operation}
% when do draw(), then where does it go? go in kernel? yes ... :(
% at least when call flush().

%\section{Trace of a mouse click}

%\section{Trace of a key press}


\section{Book structure}






%###############################################################################

\chapter{Core Data Structures}

Below are the most important data structures of [[draw.h]].
% Also their pending DS in the kernel!
% many important globals are in libdraw/init.c

% hmm, lots of DS to present.


\section{Geometry}
\n put early cos many API mention Point and Rectangle, so core DS

% screen is growing right and down. (0,0), (640,480).
%alt: see already that lack of matrix is annoying; in codemap I can map
%  this to a virtual (0,0), (1,1) in float!

% FIGURE! with screen, point and rectangle

% see addpt(2)


\subsection{[[Point]]}

<<struct Point>>=
struct	Point
{
    int	x;
    int	y;
};
@
% int! they are pixels! (good and bad, anyway can be building block for more)
%alt: %real-world: floats as in cairo

% can be interpreted as a vector too sometimes.
\l typedef Point Vector; ?

%ctor
<<function Pt>>=
Point
Pt(int x, int y)
{
    Point p;

    p.x = x;
    p.y = y;
    return p;
}
@


<<function eqpt>>=
bool
eqpt(Point p, Point q)
{
    return p.x==q.x && p.y==q.y;
}
@


<<global ZP>>=
Point	ZP;
@

% arithmetic on points

<<function addpt>>=
Point
addpt(Point a, Point b)
{
    a.x += b.x;
    a.y += b.y;
    return a;
}
@

<<function subpt>>=
Point
subpt(Point a, Point b)
{
    a.x -= b.x;
    a.y -= b.y;
    return a;
}
@

<<function mulpt>>=
Point
mulpt(Point a, int b)
{
    a.x *= b;
    a.y *= b;
    return a;
}
@

<<function divpt>>=
Point
divpt(Point a, int b)
{
    a.x /= b;
    a.y /= b;
    return a;
}
@


\subsection{[[Rectangle]]}

<<struct Rectangle>>=
struct Rectangle
{
    Point	min;
    Point	max;
};
@

% max is first point outside
% so Rect(0,0, 100, 100) is from 0,0 to 99,99 and so is of length 100.
% A bit like 0-indexed array, max express the size.

% enforced max > min? canonrect!
% kind of ctor (law)
<<function canonrect>>=
Rectangle
canonrect(Rectangle r)
{
    int t;
    if (r.max.x < r.min.x) {
        t = r.min.x;
        r.min.x = r.max.x;
        r.max.x = t;
    }
    if (r.max.y < r.min.y) {
        t = r.min.y;
        r.min.y = r.max.y;
        r.max.y = t;
    }
    return r;
}
@
% how can have one but not the other?
% FIGURE where at center point p1, and then p1 can be 4 different places
%  (higher/before, higher/after, lower/before, lower/after)


%ctor
<<function Rect>>=
Rectangle
Rect(int ax, int ay, int bx, int by)
{
    Rectangle r;

    r.min.x = ax;
    r.min.y = ay;
    r.max.x = bx;
    r.max.y = by;
    return r;
}
@

%ctor
<<function Rpt>>=
Rectangle
Rpt(Point min, Point max)
{
    Rectangle r;

    r.min = min;
    r.max = max;
    return r;
}
@
% no alloc. By value. They prefer to pay the cost of copy so simpler API.
%update: but actually in many places they inline the code :(


<<function eqrect>>=
bool
eqrect(Rectangle r, Rectangle s)
{
    return r.min.x==s.min.x && r.max.x==s.max.x &&
           r.min.y==s.min.y && r.max.y==s.max.y;
}
@


<<global ZR>>=
Rectangle ZR;
@



<<function Dx>>=
#define	Dx(r)	((r).max.x-(r).min.x)
@
% width

<<function Dy>>=
#define	Dy(r)	((r).max.y-(r).min.y)
@
% height

% arith too

<<function rectaddpt>>=
Rectangle
rectaddpt(Rectangle r, Point p)
{
    r.min.x += p.x;
    r.min.y += p.y;
    r.max.x += p.x;
    r.max.y += p.y;
    return r;
}
@
% p is kinda interpreted as a vector here

<<function rectsubpt>>=
Rectangle
rectsubpt(Rectangle r, Point p)
{
    r.min.x -= p.x;
    r.min.y -= p.y;
    r.max.x -= p.x;
    r.max.y -= p.y;
    return r;
}
@







<<function rectXrect>>=
bool
rectXrect(Rectangle r, Rectangle s)
{
    return r.min.x < s.max.x && s.min.x < r.max.x &&
           r.min.y < s.max.y && s.min.y < r.max.y;
}
@
% FIGURE (check if intersection non empty)

<<function rectinrect>>=
bool
rectinrect(Rectangle r, Rectangle s)
{
    return s.min.x <= r.min.x && r.max.x <= s.max.x && 
           s.min.y <= r.min.y && r.max.y <= s.max.y;
}
@
% r is in s

<<function ptinrect>>=
bool
ptinrect(Point p, Rectangle r)
{
    return p.x >= r.min.x && p.x < r.max.x &&
           p.y >= r.min.y && p.y < r.max.y;
}
@
% use strict < for max because max is not part of rectangle! 
% first point outside



\n insetrect() later with border()
\n combinerect() later with flush

% will see later Line, Polyline, Ellipse, Arcs, 
% but they all use Pt and Rectangle for their parameters.

\section{[[Display]] (and [[Client]])}
% and [[display]]

%trans: saw in overview chapter, /dev/draw files, so
% need client and server DS.

% connection to device, and client handler!
% initdraw()

\subsection{[[Display]] and [[display]]}

% user side, can see it as essentially a connection handler,
% most things in plan9 done via files! including drawing!
<<struct Display>>=
struct Display
{
    // ref_own<Image>, the full screen
    Image	*image;

    <<[[Display]] devdraw connection fields>>
    <<[[Display]] buffer fields>>
    <<[[Display]] basic images fields>>
    <<[[Display]] font fields>>
    <<[[Display]] other fields>>

    // Extra
    <<[[Display]] concurrency fields>>
};
@
% ctor = initdisplay <- initdraw, shown later
%dead:
% bool	local;
% ulong	dataqid;

% we will see Image later.

% rename image field to screen/view? is it the same than global screen/view?
% NO! it's not the same. it's the whole screen here.
% actually even when run under rio you can draw on the rest :( ugly.


% why not just a fd to device file? because complex device, device
% directory actually. and buffer. and protocol! and other stuff we
% want to hide.

% mostly Image and buffer with command to be flushed to device.


%!!!!
<<global display>>=
// option<Display>
Display	*display;
@
% <> = ... <- initdraw
% Could be returned instead? So API would be opendisplay()?
% Easier that way? no need to pass it everywhere?
% But anyway it's true that when use Image there is anyway a ref
% to Display so maybe it could be returned; after all closedisplay()
% takes it as a parameter.
% But global because initdraw actually sets more than one global, so
% if was opendisplay it would need to return a 4-uple
% (display, screen, view, font)

% can have multiple displays? probably so one program
% can draw to multiple screens :)


% so code for most of this book could use directly
%  display->image but we will see later better use view
%  which handles both when run under rio or not.



<<[[Display]] devdraw connection fields>>=
int		dirno; // /dev/draw/x
fdt		ctlfd; // /dev/draw/x/ctl (opened via /dev/draw/new)
fdt		fd;    // /dev/draw/x/data
@

% just for debugging I think, have ctlfd and fd already
<<[[Display]] devdraw connection fields>>=
char	*devdir; // /dev in general
char	*windir; // /dev in general
@



% usually have draw(dstimg, rectangle, srcimg, maskimg)
% and srcimg can be just black, and maskimg can be just opaque
% the abuse image for many things, because it's more general!
% Black is an image! (1x1 pixels)

<<[[Display]] basic images fields>>=
// ref_own<Image>
Image	*white;
// ref_own<Image>
Image	*black;

// ref_own<Image>
Image	*opaque;
// ref_own<Image>
Image	*transparent;
@
% colors are images! masks are images! uniform

% why here? convenient for program?
% allocated and set in initdisplay() (and redirect to shared
% memimage in kernel)




% could use Display->image directly, but as we will see later,
% windowing system so advice use another image(actually window) instead
% (view).

%alt: X11 has also a Display structure

\subsection{[[Client]]}

% kernel side. Graphics server have a set of clients. 
% need to represent those clients.

\l rename KClient! 
<<struct Client>>=
struct Client
{
    int     clientid; // /dev/draw/x/

    // hash<Image.id, ref_own<Dimage>> (next = Dimage.next in bucket)
    DImage*     dimage[NHASH];

    <<[[Client]] drawing state fields>>
    <<[[Client]] layer fields>>
    <<[[Client]] other fields>>

    // Extra
    <<[[Client]] concurrency fields>>
    Ref     r;
};
@
% ctor = drawnewclient() <- drawopen(Qnew)    (see below for drawnewclient)

% manage set of images! draw op state too!

% Image will have id! need id for bridge user/kernel, to avoid
% passing around big DS.

% ref! once every file has been close in /dev/draw/x/ then
% resource free.
% can share client? if create proc? if attach to another display?


<<constant NHASH bis>>=
#define NHASH       (1<<5)
@
% >>
<<constant HASHMASK>>=
#define HASHMASK    (NHASH-1)
@
<<[[DImage]] extra fields>>=
DImage*     next;
@
% we will see soon Dimage

% big array ... big hash. no collision for a long time
% for first 2^5 images.
% lots of space in kernel :(

<<function drawlookup>>=
DImage*
drawlookup(Client *client, int id, bool checkname)
{
    DImage *d;

    d = client->dimage[id&HASHMASK];
    while(d){
        if(d->id == id){
            <<[[drawlookup()]] if checkname>>
            return d;
        }
        d = d->next;
    }
    return nil;
}
@
% drawimage() returns instead directly the Memimage

\t checkname??

\subsection{[[KDraw]] and [[sdraw]]}
\n hard to not expose now, cos relation between DImage, DName, Client subtle

<<struct KDraw>>=
struct KDraw
{
    // growing_array<option<Client>> (size = KDraw.nclient)
    Client**    client;
    int     nclient;

    // gensym
    int     clientid;
    
    <<[[KDraw]] other fields>>
};
@
% entries in KDraw.client are called "slots"
\l rename clientid? make it more obvious that it is a counter.
\l should rename to Clients too?


%no ctor needed, singleton
<<global sdraw>>=
static  KDraw        sdraw;
@
% why sdraw? static draw? why not kdraw?


<<[[Client]] other fields>>=
// index in KDraw.clients[]
int     slot;
@
% different than Client.clientid as can reuse a free slot
% but clientid always increment. can have /dev/draw/1233322
% after 6 months :)


% sysopen -> ... -> drawopen(Qnew) -> <>
%ctor
<<function drawnewclient>>=
Client*
drawnewclient(void)
{
    Client *cl, **cp;
    int i;

    // find free slot
    for(i=0; i<sdraw.nclient; i++){
        cl = sdraw.client[i];
        // found one? then i contains the free slot number.
        if(cl == nil)
            break;
    }
    <<[[drawnewclient()]] grow array if necessary>>

    cl = malloc(sizeof(Client));
    <<[[drawnewclient()]] sanity check cl>>
    memset(cl, 0, sizeof(Client));
    cl->slot = i;
    cl->clientid = ++sdraw.clientid;
    cl->op = SoverD; // The classic
    sdraw.client[i] = cl;
    return cl;
}
@
% ++ so starts at 1 (because static kdraw.clientid is 0)
% could do too cl->infoid = 0; here.  Clearer. Implicit in malloc.
% note that Client.r set to 0. It is marked as used only when
%  the /dev/draw/x/data (or another file) is opened.

<<[[drawnewclient()]] grow array if necessary>>=
// growing array
if(i == sdraw.nclient){
    cp = malloc((sdraw.nclient+1)*sizeof(Client*));
    <<[[drawnewclient()]] sanity check cp>>
    memmove(cp, sdraw.client, sdraw.nclient*sizeof(Client*));
    free(sdraw.client);
    sdraw.client = cp;
    sdraw.nclient++;
    cp[i] = nil;
}
@
\l grow just by 1?



<<[[drawnewclient()]] sanity check cl>>=
if(cl == nil)
    return nil;
@
<<[[drawnewclient()]] sanity check cp>>=
if(cp == nil)
    return nil;
@


\section{[[Image]] (and [[Memimage]])}
% and [[screen/view]],  and DImage?

% Images in plan9 draw are specials! (see technicolor.ps!)
% used for many things. Screen, temp images, colors, fonts, masks, etc.
% even windows!

\subsection{[[Image]]}
% and [[view]]

% Display.image! here is Image.
% The screen is an image (id = 0).

<<struct Image>>=
struct Image
{
    int			id;		/* id of system-held Image */

    Rectangle	r;		/* rectangle in data area, local coords */

    ulong		chan; // image format
    // derives from Image.chan
    int			depth;		/* number of bits per pixel */

    Rectangle 	clipr;	/* clipping region */
    bool		repl;	/* flag: data replicates to tile clipr */

    Display		*display;	/* display holding data */

    <<[[Image]] layer fields>>

    // Extra
    <<[[Image]] extra fields>>
};
@
% ctor = allocimage (doing some RPC)

% will see chan, the image format later (basically how many bytes
% per colors and in which order, e.g. rgba32)

% display + id => can communicate to kernel what we are talking about.
%  need Display pointer because when do draw operation we need
%  to write in img->display.buf! and then flushimage(img->display)!
%  we need the connection handler! (but could use global ...)

% Just need to pass id to kernel! no need to pass all pixels, and info.
% In fact most of the fields above are duplicate of in kernel DS.

%alt: here no data! just id. alternative models?
%real-world: cairo? no client/server for most images, just pointer
% and many functions over pointer.

% read from /dev/draw/new initially when open the connection
%  see initdisplay() 
% system-held id! usually 0 for the first image of /dev/draw/new
%  for the framebuffer.
% incremented then at each allocimage, thx to Display.imageid field

% Rectangle r. Most of the time starts at 0,0 if full screen but can have
% other format. 
% Why need that? not sure you need really.
% When have windows, get actually a sub rectangle of the full image
% and share internally the same data.
% (but actually can have logical coord then and starts at 0, 0)
% Or when to separate your drawing algo in different parts, you
% can allocate different image for different parts with as a rectangle
% the final destination. Then you can just copy those images on
% the screen and use its rectangle as the dst. But could do without I think.
% Can have multiple rectangles over same shared big image.
% (but could use clipr)


% diff between .r and .clipr? use .r to do stuff like
%  draw_line(10 + r.min.x, 20 + r.min.y, ...). A bit tedious.
%  would be better to abstract this for clients.
% For most images used as source or masks or colors it is 
%  simply Rect(0, 0, width, height)
\l and clipr? maybe could delay its introduction

% clipping notion!! 
% repl notion!! from draw(2):
%  "A boolean value specifying whether the image is tiled to cover
%  the plane when used as a source for a drawing operation."
% chan notion!!
%  alpha notion!!
%  depth notion!

% for r, clipr, repl, see technicolor.ps!
%/* huge but not infinite, so various offsets will leave it huge, not overflow*/
% clipr = Rect(-0x3FFFFFFF, -0x3FFFFFFF, 0x3FFFFFFF, 0x3FFFFFFF);


% Image.display is of Display->image? not necessaraly I think, only
% the main image (screen) is.


\l typedef int imageid;? screenid? windowid?
% hmm but for imageid actually on user side we return Image* not imageid
% so this imageid typedef will be really internal to libdraw

<<[[Display]] other fields>>=
// gensym
int		imageid;
@
% counter, incremented each allocimage(), rename imageidcnt?
% why need that client side? id allocation is handled in kernel no?
% apparently not, kernel actually just check that passed id is indeed
% unused (in Client DImage hash).


\subsection{[[Memimage]], [[screenimage]] and [[gscreen]]}
% rename draw_screen, screen_screen, vga_screen


<<struct Memimage>>=
struct Memimage
{
    Rectangle	r;		/* rectangle in data area, local coords */

    ulong	chan;	/* channel descriptions */
    // derives from Memimage.chan
    int		depth;	/* number of bits of storage per pixel */
    int		nchan;	/* number of channels */

    Rectangle	clipr;		/* clipping region */
    //bitset<enum<fxxx>, // includes if replicate via Frepl
    ulong	flags; 

    // finally, the raw pixels
    // ref_own<Memdata>
    Memdata	*data;	/* pointer to data; shared by windows in this image */

    <<[[MemImage]] layer fields>>
    <<[[MemImage]] other fields>>
};
@
%ctor = allocmemimaged <- (makescreenimage <- ... <- drawattach) | allocmemimage
% shown later cos complicated, memsetchan, etc
%less: no repl here? yes, it's flags. rename repl?

% depth is sum of bits per pixel for r/g/b, so for RGB16 it's ... 16

%no int id; here! Id is really because of User/kernel communication need.
% id is in parent DImage, so also can share same MemImage
% with different id in different clients
% (e.g. the screen, but also imagewhite, etc (even though all of
% those should have same id in client too)

% Note that share also Memdata! many Memimage can be different
% views of the same Memdata (e.g. the screen). Efficient. No copy.
% This is why also have Rectangle r. Windows will be sub rectangle
% over shared screen Memdata.
% Hmm API to get subrectangle of existing Image? allocimage??

% flags is more general than Image.repl; contains info derived
%  from channel too
% this is not in draw.h! this is in memdraw.h so internal to Memimage
<<enum fxxx>>=
enum {
    Frepl	= 1<<0,	/* is replicated */
    // derives from Memimage.chan
    Fgrey	= 1<<2,	/* is grey */
    Falpha	= 1<<3,	/* has explicit alpha */
    Fcmap	= 1<<4,	/* has cmap channel */
    Fbytes	= 1<<5,	/* has only 8-bit channels */
};
@
%dead:    Fsimple	= 1<<1,	/* is 1x1 */
% >> >> >> >> >> >>

%Fbytes does not mean CMAP8, it means 8 bits depth but possibly multiple
% channels

% start of pbs, many different image formats ...

% all important notions!




% libmemdraw/draw.c

% setup in memimageinit
<<global memones>>=
static Memimage*	memones;
@
<<global memzeros>>=
static Memimage*	memzeros;
@
% 1x1 images, Grey1
% Shared by all clients?

% pending of Display->white, Display->opaque, etc? I dont think so
%  more for stuff used internally by kernel. Display->white and Display->back
%  seems to be allocimage each time in each initdisplay()
<<global memwhite>>=
Memimage *memwhite;
@
<<global memblack>>=
Memimage *memblack;
@
<<global memtransparent>>=
Memimage *memtransparent;
@
<<global memopaque>>=
Memimage *memopaque;
@





% [[devdraw]] interface

% put in core DS chapter? merge with screen.h gscreen no?
% the frame buffer!! (at least call like that in error msg when nil)
<<global screenimage>>=
static  Memimage    *screenimage;
@
\t rename draw_screen!
% screendimage->image (less: so could remove this semi global)
%TODO: vs gscreen????? rename vga_screen?


%[[screen.h]] interface

% there will be lots of Memimage, but an important one is
% the screen!

% screen.c, relation to Display->image? to screen/view? g? global screen?
%  rename gview? more consistent with our new naming? No, here it's
%  really the screen.

% kinda pending of view when run app on whole screen.
% (but in fact it's not when run under rio)

<<global gscreen>>=
Memimage *gscreen;
@
\t rename screen_screen? not gview I think, here it's really the screen

%todo: put global kernel gscreen for chunkname? or global gscreen(kernel)
% like I did for (arm) and (386)
%this is set in screensize() by VGA driver

% unfortunate that use term "Screen" already used for other stuff.
% just like have [[screen/view]], client side,
% have also gscreendimage and gscreen kernel side

%[[vga.h]] interface?? vga_screen global?


% This used to be called the [[VGAscr]] section.
% But what matters is not so much VGA but the screen.h interface.
% We actually moved more stuff to a generic screen.c, to be closer
% to the simplicity of bcm/screen.c. We don't want to expose ugly
% VGA details when nowadays things are simpler like the framebuffer
% interface of the raspberry.

% this used to be in vgascreen.c, but every archi was defining
% such a gscreen, so makes sense to factorize in a screen.c.
% there also used to be a vgascreen[0].gscreen (see screensize()), but
% this was redundant then with gscreen.


\subsection{[[Memdata]] and [[gscreendata]]}

<<struct Memdata>>=
/*
 * Memdata is allocated from main pool, but .data from the image pool.
 * Memdata is allocated separately to permit patching its pointer after
 * compaction when windows share the image data.
 * The first word of data is a back pointer to the Memdata, to find
 * The word to patch.
 */
struct Memdata
{
    ulong	*base;	/* allocated data pointer */
    // the pixels!
    byte	*bdata;	/* pointer to first byte of actual data; word-aligned */

    <<[[Memdata]] other fields>>
    // Extra
    int		ref;		/* number of Memimages using this data */
};
@
% ctor = makescreenimage | allocmemimage
\l why not a Ref?
\t base must be first field?

% another intermediate, wrapper in Memimage for compaction
%  need mentioned in comment (see imagemove callback)

% the raw pixel data! but to know where to modify you need
% to understand the format of the image, the #channels, depths
% of channels, etc.

\t FIGURE to explain diff between .base and .bdata (and .zero)
% base is poolalloc raw pointer, then at this address 
% - first word is backpointer to Memdata structure, 
% - second word is callerpc for debugging
% - then the actual pixels

% this is kinda a framebuffer. But actually needs one
% operation to transfer from this memory to the actual screen?
% hmm flushmemscreen is responsible for that, but it can be a nope
% when bdata is already pointing to the framebuffer.
% the vga driver does a copy though probably.
% but anyway bdata is not necessaraly for the framebuffer, it can
% be any images the user works on.
% see also ishwimage()

% could put a generic ishwimage here! that just check if 
% i->data->bdata == gscreen->data->bdata!


<<[[MemImage]] other fields>>=
int		zero;		/* data->bdata+zero==&byte containing (0,0) */
ulong	width;	/* width in words of a single scan line */
@
\t zero is complicated because some Memdata correspond to
\t  rectangle which do not start at 0,0
\l rename wwidth? vs bwidth?

<<function byteaddr>>=
byte*
byteaddr(Memimage *i, Point p)
{
    byte *a;

    a = (i->data->bdata + i->zero) + (sizeof(ulong) * p.y * i->width);

    <<[[byteaddr()]] if depth less than 8>>
    else
        return a + p.x * (i->depth/8);
}
@
% should sanity check still valid pointer?? that in valid range?






<<global gscreendata>>=
Memdata gscreendata;
@
% not a pointer, gscreen->data = &gscreendata.
% gscreendata.data will point to virtual address of framebuffer!






\subsection{[[DImage]]}
% and screendimage

% Saw memimage but in fact as we saw before client instead have
% DImage cache. 

% Why yet another intermediate? Because need id only because of
% kernel/user need. Memimage has no id. Here need kernel wrapper
% over Memimage with id.
% Also because need id only when have User/kernel separation.
% Appli could use directly Memimage (and some do).

% Also id might be different in different client but same shared image!

% why D? For Draw Image. Cos have Image, Memimage (memdraw),
% and DImage for kernel stuff. Indeed can use lots of the graphics
% stack independently of the kernel and draw device.

<<struct DImage>>=
/*
 * Reference counts in DImages:
 *  one per open by original client
 *  one per screen image or fill
 *  one per image derived from this one by name
 */
struct DImage
{
    int     id;
    Memimage*   image;

    <<[[DImage]] layer fields>>
    <<[[DImage]] font fields>>
    <<[[DImage]] other fields>>

    // Extra
    <<[[DImage]] extra fields>>
    int     ref;
};
@
% why not merged with Memimage? Why wrapper? cos of id!
% so can share Memimage but each client has own DImage "view"
% of those shared Memimage (including the screen!!).
% intermediate so can share underlying Memimage.
% Also why id is here, cos id could be different for same Memimage

\l comment above is hard to understand

%ctor
<<function allocdimage>>=
/// makescreenimage | drawinstall -> <>
DImage*
allocdimage(Memimage *i)
{
    DImage *d;

    d = malloc(sizeof(DImage));
    <<[[allocdimage()]] sanity check d>>
    d->image = i;
    d->ref = 1;

    d->name = nil;
    d->fromname = nil;
    d->vers = 0;
    d->nfchar = 0;
    d->fchar = 0;

    return d;
}
@
% no id? done by drawinstall (for instance when open Qctl in
% which case it is set to 0!)


<<[[allocdimage()]] sanity check d>>=
if(d == nil)
    return nil;
@

%\subsection{[[DName]]}
% related to windowing system so moved later


\section{Channels}

% =~ pixel format. How many bits, what bytes represent which color.
% This + rectangle = image format.

% typedef ulong channels;!

% saw ulong chan; in Image and Memimage.

% not thread channel, not kernel Chan, image channels here!
% ulong in previous struct, but more complex format actually.

<<enum ImageChan>>=
/*
 * image channel descriptors 
 */
// coupling: chantostr and channames
enum ImageChan {
    CRed = 0,
    CGreen,
    CBlue,

    CGrey,
    CAlpha,

    CMap,
    <<[[ImageChan]] cases>>

    NChan,
};
@
\n use Chan not Channel to avoid confusing with thread.h struct Channel.
\l I would like to move CAlpha after Blue, but maybe font files
\l  rely on this order

%  4      4
% -------------
% type | nbits
% -------------

%ctor
<<function __DC>>=
#define __DC(type, nbits)	((((type)&15)<<4)|((nbits)&15))
@
% >>

%extractor
<<function NBITS>>=
#define NBITS(c) ((c)&15)
@
<<function TYPE>>=
#define TYPE(c) (((c)>>4)&15)
@
% >> >> >>


% ctors
<<function CHAN1>>=
#define CHAN1(a,b)	__DC(a,b)
@

<<function CHAN2>>=
#define CHAN2(a,b,c,d)	(CHAN1((a),(b))<<8|__DC((c),(d)))
@

<<function CHAN3>>=
#define CHAN3(a,b,c,d,e,f)	(CHAN2((a),(b),(c),(d))<<8|__DC((e),(f)))
@

<<function CHAN4>>=
#define CHAN4(a,b,c,d,e,f,g,h)	(CHAN3((a),(b),(c),(d),(e),(f))<<8|__DC((g),(h)))
@
% >> >> >>


% most common image formats:

<<enum _anon_ (include/draw.h)5>>=
enum ImageType {
    GREY1	= CHAN1(CGrey, 1), // used for masks, black and white
    CMAP8	= CHAN1(CMap, 8), // PC graphics mode by default, 1 byte per pixel
    RGB16	= CHAN3(CRed, 5, CGreen, 6, CBlue, 5), // Raspberry mode by default
    RGBA32	= CHAN4(CRed, 8, CGreen, 8, CBlue, 8, CAlpha, 8), // flexible
    ARGB32	= CHAN4(CAlpha, 8, CRed, 8, CGreen, 8, CBlue, 8),/* stupid VGAs */
    <<[[ImageType] cases>>
};
@
% todo: need all of that? could maybe simplify and support less
% image format. That should remove quite some code, e.g. all those
% alphacalcxxx? hmm actually not that much I think.
% cairo has what? RGBA32 no?

% vga is CMAP8 (cat /dev/draw/new -->  m8 for cmap 8 bit)
% bcm is using RGB16 by default (but can be configured for ARGB32)

%real-world: have more than total depth 32 nowaday for colors?

% what is True Color? mentionned in technicolor.ps. It's RGBA32?
% RGB with 8 bytes each = 16 million of colors.


<<function chantodepth>>=
int
chantodepth(ulong c)
{
    int n;

    for(n=0; c; c>>=8){
        <<[[chantodepth()]] sanity check c>>
        n += NBITS(c);
    }
    <<[[chantodepth()]] sanity check n>>
    return n;
}
@

% see also chantostr in debug, which is also used to give
% readable info in /dev/draw/new/

<<[[chantodepth()]] sanity check c>>=
if(TYPE(c) >= NChan || NBITS(c) > 8 || NBITS(c) <= 0)
    return 0; // warning?
@

<<[[chantodepth()]] sanity check n>>=
if(n==0 || (n>8 && n%8) || (n<8 && 8%n))
    return 0; // warning?
@

% strtochan, chantostr later.

\section{Colors}

<<type rgba>>=
typedef ulong rgba;
@
%pad: I introduced this type, less confusing

%old school graphics:
% https://www.youtube.com/watch?v=Tfh0ytz8S0k&feature=youtu.be

% actually Color are Image* in plan9 draw!
% a Rect(0,0,1,1), with clipr = infinity and repl = true
% very general so less need draw_mask, or draw_color, instead
% just have a generic draw function where you can pass
% black as the src!

% 32 bits! RGBA 8 bits for each channel, which is
% why has FF as the last bit for almost all the elements below
<<enum Colors>>=
enum
{
    DOpaque			= 0xFFFFFFFF,
    DTransparent	= 0x00000000,/* only useful for allocimage, memfillcolor */

    DBlack		= 0x000000FF,
    DWhite		= 0xFFFFFFFF,

    DRed		= 0xFF0000FF,
    DGreen		= 0x00FF00FF,
    DBlue		= 0x0000FFFF,

    DCyan		= 0x00FFFFFF,
    DMagenta	= 0xFF00FFFF,
    DYellow		= 0xFFFF00FF,

    DPaleyellow	= 0xFFFFAAFF,
    DDarkyellow	= 0xEEEE9EFF,
    DDarkgreen	= 0x448844FF,
    DPalegreen	= 0xAAFFAAFF,
    DMedgreen	= 0x88CC88FF,
    DDarkblue	= 0x000055FF,
    DPalebluegreen= 0xAAFFFFFF,
    DPaleblue	= 0x0000BBFF,
    DBluegreen	= 0x008888FF,
    DGreygreen	= 0x55AAAAFF,
    DPalegreygreen	= 0x9EEEEEFF,
    DYellowgreen	= 0x99994CFF,
    DMedblue		= 0x000099FF,
    DGreyblue		= 0x005DBBFF,
    DPalegreyblue	= 0x4993DDFF,
    DPurpleblue		= 0x8888CCFF,

    DNotacolor	= 0xFFFFFF00, // Alpha = 0, transparent white
    DNofill	= DNotacolor,
    
};
@

\subsection{[[imgtorgba()]]}

% we will see different format, copy from one image to another,
% so may need convert. Usually convert to common base: rgba(32).

% memimagedraw -> <>
<<function imgtorgba>>=
static rgba
imgtorgba(Memimage *img, ulong val)
{
    byte r, g, b, a;
    ulong chan;
    int nb, v;
    <<[[imgtorgba()]] other locals>>

    a = 0xFF;
    r = g = b = 0xAA;	/* garbage */

    for(chan=img->chan; chan; chan>>=8){
        nb = NBITS(chan);
        v = val&((1<<nb)-1);
        val >>= nb;
        ov = v;
        <<[[imgtorgba()]] duplicate bits if nb less than 8>>

        switch(TYPE(chan)){
        case CRed:
            r = v;
            break;
        case CGreen:
            g = v;
            break;
        case CBlue:
            b = v;
            break;
        case CAlpha:
            a = v;
            break;
        <<[[imgtorgba()]] switch chan type cases>>
        }
    }
    return (r<<24)|(g<<16)|(b<<8)|a;	
}
@
% >> >> >> >>

% so ARGB32 to RGBA32 easy.

% GREY1, CMAP8, RGB16 later in chapter X.


\subsection{[[rgbatoimg()]]}

% memimagedraw | memfillcolor -> <>
<<function rgbatoimg>>=
static ulong
rgbatoimg(Memimage *img, rgba rgba)
{
    byte r, g, b, a;
    ulong chan;
    int d, nb;
    ulong v;
    <<[[rgbatoimg()]] other locals>>

    v = 0;
    r = rgba>>24;
    g = rgba>>16;
    b = rgba>>8;
    a = rgba;
    d = 0;
    for(chan=img->chan; chan; chan>>=8){
        nb = NBITS(chan);
        switch(TYPE(chan)){
        case CRed:
            v |= (r>>(8-nb))<<d;
            break;
        case CGreen:
            v |= (g>>(8-nb))<<d;
            break;
        case CBlue:
            v |= (b>>(8-nb))<<d;
            break;
        case CAlpha:
            v |= (a>>(8-nb))<<d;
            break;
        <<[[rgbatoimg()]] switch chan type cases>>
        }
        d += nb;
    }
    DBG1("rgba2img %.8lux = %.*lux\n", rgba, 2*d/8, v);
    return v;
}
@
% >>

% Again, GREY1, CMAP8, RGB16 later in chapter X.



%\subsection{[[setalpha()]]}

%dead:
% API function but not used in any graphical applications (just mahjongg).
% Was maybe a bit interesting to understand alpha but in the end I find
% it confusing. Maybe related to notion of pre-alpha (see wikipedia page
% on alpha compositing)
%   <<function setalpha>>=
%   ulong
%   setalpha(ulong color, uchar alpha)
%   {
%       int red, green, blue;
%   
%       red = (color >> 3*8) & 0xFF;
%       green = (color >> 2*8) & 0xFF;
%       blue = (color >> 1*8) & 0xFF;
%       /* ignore incoming alpha */
%       red = (red * alpha)/255;
%       green = (green * alpha)/255;
%       blue = (blue * alpha)/255;
%       return (red<<3*8) | (green<<2*8) | (blue<<1*8) | (alpha<<0*8);
%   }
%   @
%    >> >> >> >>
\n was in arith.c
% that simple? :) to set alpha you just dillute each rgb components?

\subsection{[[memfillcolor()]]}

% drawmesg(allocate) | membrush | bellipse | memarc | memlalloc | ... -> <>
<<function memfillcolor>>=
void
memfillcolor(Memimage *i, rgba val)
{
    ulong bits;
    <<[[memfillcolor()]] other colors>>

    if(val == DNofill)
        return;

    bits = rgbatoimg(i, val);
 
   switch(i->depth){
    <<[[memfillcolor()]] switch depth cases>>
    default:	/* 1, 2, 4, 8, 16, 32 */
        <<[[memfillcolor()]] duplicate bits if depth less than 32>>
        memsetl(wordaddr(i, i->r.min), bits, i->width * Dy(i->r));
        break;
    }
}
@
% >>
%old: param as val but confusing, rgba better if don't use typedef.

% memfillcolor (only) -> <>
<<function wordaddr>>=
/*
 * Wordaddr is deprecated.
 */
ulong*
wordaddr(Memimage *i, Point p)
{
    return (ulong*) ((uintptr)byteaddr(i, p) & ~(sizeof(ulong)-1));
}
@


% l for little endian
<<function memsetl>>=
static void
memsetl(void *vp, ulong val, int n)
{
    ulong *p, *ep;

    p = vp;
    ep = p+n;
    while(p < ep)
        *p++ = val;
}
@


<<[[memfillcolor()]] other colors>>=
int d;
@
% could be in non-32 bit section
<<[[memfillcolor()]] duplicate bits if depth less than 32>>=
for(d=i->depth; d<32; d*=2)
    // duplicate bits
    bits = (bits << d) | bits;
@
% >>
% \section{Color map}
% now in Adv topics



\section{[[Drawop]]}
% Composition
% hmm put now? delay to later?

% composing algebra, Porter-Duff
% (Duff part of plan9 team (did rc), so maybe good API design)

% take technicolor.ps example with nice racket like
% slides where images are arguments of draw(), like slide 9

%\subsection{[[Drawop]]}

<<[[Client]] drawing state fields>>=
// enum<Drawop>
int     op;
@

<<enum drawop>>=
enum Drawop
{
    /* Porter-Duff compositing operators */
    Clear	= 0,

    SinD	= 8,
    DinS	= 4,
    SoutD	= 2,
    DoutS	= 1,

    S		= SinD|SoutD,
    SoverD	= SinD|SoutD|DoutS, // classic Source over Destination
    SatopD	= SinD|DoutS,
    SxorD	= SoutD|DoutS,

    D		= DinS|DoutS,
    DoverS	= DinS|DoutS|SoutD,
    DatopS	= DinS|SoutD,
    DxorS	= DoutS|SoutD,	/* == SxorD */

    Ncomp = 12,
};
@
% 12 porter duff operators.

\l FIGUREs ? or delay to later?
% http://www.svgopen.org/2005/papers/abstractsvgopen/ nice figure


%\subsection{[[Memdrawparam]]}
% later now


\section{Fonts}
% present later, already lots of DS to understand ...

\section{Windows}
% and screen. and view.
% delay to later!

% moved all of that later and aspectized everything related
% to windowing system (basic stuff already quite complicated
% so let's not complicate it even more)



\chapter{Initializations}
% =~ Main

%kernel/user, server/client, system/app

\section{Kernel side}
% part1
% also kinda "Server side". Actually mount and bind are user side
%  operation (triggering kernel side code)
% Better to see first user side?

\subsection{Binding the VGA device}
% [[vgascreen]], (-> vga_screen)
%x86

% complex, arch specific, so in appendix, but important part
% is setup vgascreen global  for aux/vgactl I think.

\subsection{Setting the screen size, VGA [[screensize()]]}
\n put before draw mount as anyway it depends on many globals being set
\n for VGA attachscreen
% [[gscreendata]] and [[gscreen]], ( -> screen, screendata)

% mounting and then call aux/vga ! which ends up calling screensize?
%  run("/bin/vga", "-l", "1024x768x8", nil); // can add -V to debug vga

% ???aux/vga -> <>
% vgascreen.c
<<function screensize(x86)>>=
int
screensize(int x, int y, int z, ulong chan)
{
    VGAscr *scr = &vgascreen;
    <<[[screensize()]] other locals>>

    <<[[screensize()]] lock>>
    <<[[screensize()]] initializations part1>>

    <<[[screensize()]] set [[gscreendata.bdata]]>>

    <<[[screensize()]] free previous gscreen>>
    // Setting gscreen!!
    gscreen = allocmemimaged(Rect(0,0,x,y), chan, &gscreendata);
    <<[[screensize()]] sanity check gscreen>>

    <<[[screensize()]] vga settings>>
    <<[[screensize()]] unlock>>

    // initial draw
    memimagedraw(gscreen, gscreen->r, memblack, ZP, nil, ZP, S);
    flushmemscreen(gscreen->r);

    <<[[screensize()]] initializations part2>>
    return OK_0;
}
@
% >>

% will see memimagedraw later, and flushmem too
% memblack first memimagedraw! so black screen!


% locking

<<global vgascreenlock(x86)>>=
Lock vgascreenlock;
@
<<[[screensize()]] lock>>=
lock(&vgascreenlock);
if(waserror()){
    unlock(&vgascreenlock);
    nexterror();
}
@
<<[[screensize()]] unlock>>=
unlock(&vgascreenlock);
poperror();
@


% memory

<<[[screensize()]] free previous gscreen>>=
if(gscreen)
    freememimage(gscreen);
@

% error managment

<<[[screensize()]] sanity check gscreen>>=
if(gscreen == nil)
    error("no memory for vga memimage");
@

\subsubsection{Soft screen vs framebuffer}

<<[[screensize()]] set [[gscreendata.bdata]]>>=
if(scr->paddr == 0){
    int width = (x*z)/BI2BY; // width in bytes
    void *p;

    // !!the alloc!!
    p = xalloc(width*y);
    <<[[screensize()]] sanity check p>>
    gscreendata.bdata = p;
    scr->useflush = true;
    <<[[screensize()]] when use softscreen, other settings>>
}
else{
    // direct framebuffer
    gscreendata.bdata = scr->vaddr;
    scr->useflush = (scr->dev && scr->dev->flush);
}
@

%old:
%        int width = (x*z)/BI2WD; // width in words


%In Kernel_extra.nw
%#define BI2BY   8     /* bits per byte */
%#define BI2WD   32      /* bits per word */
%
%#define BY2WD   4     /* bytes per word */
%#define BY2V    8     /* bytes per double word */


% memory handling

% xalloc! for physical screen! for other images, it's poolalloc


% useflush and soft screen or direct framebuffer

<<global softscreen(x86)>>=
static void *softscreen;
@
%gscreendata.bdata when have no framebuffer, xalloced
% could remove and use directly gscreendata.bdata no?
%saved in global so free
\t could be a static of screensize really, so actually no need oldsoft below

<<[[screensize()]] when use softscreen, other settings>>=
softscreen = gscreendata.bdata;
@


<<[[screensize()]] other locals>>=
void *oldsoft;
@
<<[[screensize()]] initializations part1>>=
oldsoft = softscreen;
@
<<[[screensize()]] initializations part2>>=
if(oldsoft)
    xfree(oldsoft);
@



% error handling

<<[[screensize()]] sanity check p>>=
if(p == nil)
    error("no memory for vga soft screen");
@


\subsubsection{[[memimageinit()]]}

<<[[screensize()]] initializations part1>>=
memimageinit();
@
% memblack is used in screensize later for the first memimagedraw so need this

% not sure why called from screensize as the things it sets are size
%  independent. Maybe it could be called from vga?

% screensize | main_test -> <>
% when call to screensize in the kernel? when switch to graphic mode via vgactl?
<<function memimageinit>>=
void
memimageinit(void)
{
    <<[[memimageinit()]] only once guard>>

    <<[[memimageinit()]] set image pool allocator move>>
    <<[[memimageinit()]] initializations>>
    <<[[memimageinit()]] install dumpers>>

    memzeros = allocmemimage(Rect(0,0,1,1), GREY1);
    memzeros->flags |= Frepl;
    memzeros->clipr = Rect(-0x3FFFFFF, -0x3FFFFFF, 0x3FFFFFF, 0x3FFFFFF);
    *byteaddr(memzeros, ZP) = 0;

    memones = allocmemimage(Rect(0,0,1,1), GREY1);
    memones->flags |= Frepl;
    memones->clipr = Rect(-0x3FFFFFF, -0x3FFFFFF, 0x3FFFFFF, 0x3FFFFFF);
    *byteaddr(memones, ZP) = ~0;

    <<[[memimageinit()]] sanity check memxxx>>

    memwhite = memones;
    memblack = memzeros;
    memopaque = memones;
    memtransparent = memzeros;
}
@
% 0x3FFFFFF? means huges but not infinite. clipr far bigger than r so replicate
% indifinitely. and not infinite for overflow issue. See clipping section
% later.

% memimageinit seems quite general, not sure why called from screensize
% why need width/height or chan?

% allocmemimage later
% vs allocmemimaged, no data passed (hence the final d).


<<[[memimageinit()]] sanity check memxxx>>=
if(memones == nil || memzeros == nil)
    assert(0 /*cannot initialize memimage library */);	/* RSC BUG */
@

<<[[memimageinit()]] only once guard>>=
static bool didinit = false;
if(didinit)
    return;
didinit = true;
@

\subsubsection{[[memimagemove()]]}

% need understand pool allocator in Libcore.nw

<<[[memimageinit()]] set image pool allocator move>>=
if(  strcmp(imagmem->name, "Image") == 0 
  || strcmp(imagmem->name, "image") == 0
  )
    imagmem->move = memimagemove;
@


% mv earlier? closer to Memdata?
% kernel interface?
% ??? -> <> (imag->move = <> <- memimageinit)
<<function memimagemove>>=
void
memimagemove(void *from, void *to)
{
    Memdata *md;

    md = *(Memdata**)to;
    <<[[memimagemove()]] sanity check md base>>
    md->base = to;

    /* if allocmemimage changes this must change too */
    md->bdata = (byte*)md->base + sizeof(Memdata*) + sizeof(ulong);
}
@
% if compress images pool, then pointer can move, so need
% way to find back stuff pointings to those images. Fortunately
% have back pointer in the array itself.

\t FIGURE hard to understand layout, see also code of allocmemimage

<<[[memimagemove()]] sanity check md base>>=
if(md->base != from){
    print("compacted data not right: #%p\n", md->base);
    abort();
}
@


\subsection{Binding the draw device}
% screenimage (-> draw_screen)

% see kernel init
% bind #i /dev
%  bind_safe("#i", "/dev", MAFTER); // devdraw
% after vga device has been installed (so attachscreen can work)


% ??sysbind?? -> <> (drawdevtab.attach = <> <- toplevel)
<<function drawattach>>=
static Chan*
drawattach(char *spec)
{
    dlock();
    if(!initscreenimage()){
        dunlock();
        error("no frame buffer");
    }
    dunlock();

    return devattach('i', spec);
}
@
% dlock/dunlock?
% will see other device draw ops later

<<global drawlock>>=
QLock   drawlock;
@
% protect? sdraw? screenimage?

<<function dlock>>=
static void
dlock(void)
{
    qlock(&drawlock);
}
@
<<function candlock>>=
static int
candlock(void)
{
    return canqlock(&drawlock);
}
@
<<function dunlock>>=
static void
dunlock(void)
{
    qunlock(&drawlock);
}
@
% this is kernel side. because shared DS.
% client side you may have to use lockdisplay() to protect user DS
%  if multi process.

\subsubsection{[[initscreenimage()]]}

% drawattach -> <>
<<function initscreenimage>>=
static error0
initscreenimage(void)
{

    <<[[initscreenimage()]] only once guard>>

    screendimage = makescreenimage();
    <<[[initscreenimage()]] sanity check screendimage>>
    screenimage = screendimage->image;

    <<[[initscreenimage()]] other initializations>>
    return OK_1;
}
@
%old:    //DBG1("initscreenimage %p %p\n", screendimage, screenimage);


% fuck, another set of globals ... rename gscreendimage?
<<global screendimage>>=
static  DImage* screendimage;
@
\l rename draw_screen_dimage
\t why need this one? anyway will create a new DImage for each
%  client with screenimage wrapped. for drawaddname?


% sysbind -> drawattach -> initscreenimage -> <>
% less: rename makescreendimage? it returns a DImage here
<<function makescreenimage>>=
static DImage*
makescreenimage(void)
{
    <<[[makescreenimage()]] locals>>

    <<[[makescreenimage()]] allocate Memdata md>>
    <<[[makescreenimage()]] allocate Memimage i>>
    <<[[makescreenimage()]] allocate DImage di>>

    <<[[makescreenimage()]] drawaddname>>

    return di;
}
@
% hmm waserror, refer to kernel book! or maybe put appendix again
% with summary of equivalences with modern exn constructs


%toc:
<<[[makescreenimage()]] locals>>=
Memdata *md;
Memimage *i;
DImage *di;
@




<<[[initscreenimage()]] only once guard>>=
if(screenimage != nil)
    return OK_1;
@

<<[[initscreenimage()]] sanity check screendimage>>=
if(screendimage == nil)
    return ERROR_0;
@

\paragraph{[[Memdata]]}

<<[[makescreenimage()]] allocate Memdata md>>=
// allocate Memdata
md = malloc(sizeof(Memdata));
<<[[makescreenimage()]] sanity check md>>
md->allocd = true;

md->bdata = attachscreen(&r, &chan, &depth, &width, &sdraw.softscreen);
<<[[makescreenimage()]] sanity check md bdata>>
md->base = nil; // not allocated by poolalloc
md->ref = 1;
@
% does not set base?
% screen either allocated by xalloc or direct framebuffer

% this md (of devdraw) is a duplicate of gscreendata (of screen.h)

<<[[KDraw]] other fields>>=
bool     softscreen;
@
% important info for draw to know if need to flush


<<[[Memdata]] other fields>>=
bool	allocd;	/* is this malloc'd? */
@
% how it could be false? for gscreendata!! but then why
\l  we have code that call freexxx on gscreendata?

% here it looks like it is using the bdata returned by attachscreen
%  and this one is really poolalloc?
% it is neither (or really xalloc for softscreen) it is physical framebuffer
% but for that Memdata.base is used to possibly
% free and indeed above it is not set!

<<[[makescreenimage()]] locals>>=
int width, depth;
Rectangle r;
ulong chan;
@
% we will see attachscreen() soon


<<[[makescreenimage()]] sanity check md>>=
if(md == nil)
    return nil;
@

<<[[makescreenimage()]] sanity check md bdata>>=
if(md->bdata == nil){
    free(md);
    return nil;
}
@

\paragraph{[[Memimage]]}

% md set, pass it to allocmemimaged encapsulate in Memimage

<<[[makescreenimage()]] allocate Memimage i>>=
// allocate Memimage
i = allocmemimaged(r, chan, md);
<<[[makescreenimage()]] sanity check i>>
@
%old: why overwrite width and clipr already set in allocmemimaged?
% i->width = width;
% i->clipr = r;
\t assert if i->width != width?


<<[[makescreenimage()]] sanity check i>>=
if(i == nil){
    free(md);
    return nil;
}
@

% allocmemimaged assume md has enough data for 
%  chan2depth(chan) * size rectangle ?

% makescreenimage | allocmemimage -> <>
%Memimage ctor (smaller malloc, just a wrapper over Memdata)
<<function allocmemimaged>>=
Memimage*
allocmemimaged(Rectangle r, ulong chan, Memdata *md)
{
    int d;
    ulong l;
    Memimage *i;

    <<[[allocmemimaged()]] sanity check r>>
    d = chantodepth(chan);
    <<[[allocmemimaged()]] sanity check d>>
    l = wordsperline(r, d);

    i = mallocz(sizeof(Memimage), true);
    <<[[allocmemimaged()]] sanity check i>>

    i->data = md;
    <<[[allocmemimaged()]] set zero field>>
    i->width = l;
    i->r = r;
    i->clipr = r;
    i->flags = 0;

    i->layer = nil;
    i->cmap = memdefcmap;

    if(memsetchan(i, chan) < 0){
        free(i);
        return nil;
    }
    return i;
}
@
% memimaged? d for data because pass the data


% remember Memimage.zero is &byte containing(0,0) (which could
% be outside Memdata if Rectangle starts at Pt(10, 10).

<<[[allocmemimaged()]] set zero field>>=
i->zero = sizeof(ulong) * l * r.min.y;
if(r.min.x >= 0)
    i->zero += (r.min.x*d)/8;
else
    i->zero -= (-r.min.x*d+7)/8;
i->zero = -i->zero;
@
% for screenimage Rectangle.min should be Pt(0, 0).
% If rect starts at Pt(10,10) then zero must be negatif!



<<[[allocmemimaged()]] sanity check r>>=
if(Dx(r) <= 0 || Dy(r) <= 0){
    werrstr("bad rectangle %R", r);
    return nil;
}
@
<<[[allocmemimaged()]] sanity check d>>=
if(d == 0) {
    werrstr("bad channel descriptor %.8lux", chan);
    return nil;
}
@
<<[[allocmemimaged()]] sanity check i>>=
if(i == nil)
    return nil;
@




<<function wordsperline>>=
int
wordsperline(Rectangle r, int d)
{
    return unitsperline(r, d, 8*sizeof(ulong));
}
@

<<function bytesperline>>=
int
bytesperline(Rectangle r, int d)
{
    return unitsperline(r, d, 8);
}
@

<<function unitsperline>>=
static
int
unitsperline(Rectangle r, int d, int bitsperunit)
{
    ulong l, t;

    <<[[unitsperline()]] sanity check d>>

    if(r.min.x >= 0){
        l = (r.max.x*d+bitsperunit-1)/bitsperunit;
        l -= (r.min.x*d)/bitsperunit;
    }else{			/* make positive before divide */
        t = (-r.min.x*d+bitsperunit-1)/bitsperunit;
        l = t+(r.max.x*d+bitsperunit-1)/bitsperunit;
    }
    return l;
}
@


<<[[unitsperline()]] sanity check d>>=
if(d <= 0 || d > 32)	/* being called wrong.  d is image depth. */
    abort();
@



%\section{Channels and alpha}

% allocmemimage -> allocmemimaged -> <>
%less: mv in Alloc section?
<<function memsetchan>>=
errorneg1
memsetchan(Memimage *i, ulong chan)
{
    int d;
    int t, j, k;
    ulong cc;
    bool bytes;

    d = chantodepth(chan);
    <<[[memsetchan()]] sanity check d>>
    i->chan = chan;
    i->depth = d;
    i->flags &= ~(Fgrey|Falpha|Fcmap|Fbytes);
    bytes = true;

    for(cc=chan, j=0, k=0; cc; j+=NBITS(cc), cc>>=8, k++){
        t=TYPE(cc);
        <<[[memsetchan()]] sanity check t>>
        if(t == CGrey)
            i->flags |= Fgrey;
        if(t == CAlpha)
            i->flags |= Falpha;
        if(t == CMap && i->cmap == nil){
            i->cmap = memdefcmap;
            i->flags |= Fcmap;
        }

        i->shift[t] = j;
        i->mask[t] = (1<<NBITS(cc))-1;
        i->nbits[t] = NBITS(cc);

        if(NBITS(cc) != 8)
            bytes = false;
    }
    i->nchan = k;
    if(bytes)
        i->flags |= Fbytes;
    return OK_0;
}
@
% >>

% can change chan of existing Memimage? issue if bigger depth?
%  then should reallocate ...

<<[[memsetchan()]] sanity check d>>=
if(d == 0) {
    werrstr("bad channel descriptor");
    return ERROR_NEG1;
}
@

<<[[memsetchan()]] sanity check t>>=
if(t < 0 || t >= NChan){
    werrstr("bad channel string");
    return -1;
}
@

<<[[MemImage]] other fields>>=
// map<enum<ImageChan>, int>
int		shift[NChan];
// map<enum<ImageChan>, int>
int		mask[NChan];
// map<enum<ImageChan>, int>
int		nbits[NChan];
@
% will be useful later when reading the bytes of a pixel, to know
%  where the rgba components are located in the word.


%dtor
<<function freememimage>>=
void
freememimage(Memimage *i)
{
    <<[[freememimage()]] sanity check i>>
    // free the Memdata
    if(i->data->ref-- == 1 && i->data->allocd){
        if(i->data->base)
            poolfree(imagmem, i->data->base);
        free(i->data);
    }
    free(i);
}
@
% remember allocd vs base, two different allocators


<<[[freememimage()]] sanity check i>>=
if(i == nil)
    return;
@
% it should throw a warning. Not good to abuse free to free null pointers.


\paragraph{[[DImage]]}

<<[[makescreenimage()]] allocate DImage di>>=
// allocate DImage
di = allocdimage(i);
<<[[makescreenimage()]] sanity check di>>
@
% we have seen allocdimage before in core DS chapter

<<[[makescreenimage()]] sanity check di>>=
if(di == nil){
    freememimage(i);    /* frees md */
    return nil;
}
@


\paragraph{Screen name}
% drawaddname() have stuff related to screename, but we will see later!

% put later with Windows! assume screen_image
% and screen_dimage are the way for client to get
% their screen image!




\subsubsection{VGA [[attachscreen()]]}
%\subsubsection{Hardware support hook}

% The connection between the two preceding section!

% the interface between screen.h and devdraw, between
% screenimage  and gscreen (and gscreendata).

% /// makescreenimage -> <>
% vgascreen.c
<<function attachscreen(x86)>>=
byte*
attachscreen(Rectangle* r, ulong* chan, int* d, int* width, bool *softscreen)
{

    <<[[attachscreen()]] sanity check gscreen>>

    *r          = gscreen->clipr;
    *chan       = gscreen->chan;
    *d          = gscreen->depth;
    *width      = gscreen->width;

    *softscreen = vgascreen.useflush;

    return gscreendata.bdata;
}
@
% who setup vgascreen? and gscreen?
%old:
%    VGAscr *scr;
%    scr = &vgascreen;
%    *softscreen = scr->useflush;

% VGA has a soft screen?


<<[[attachscreen()]] sanity check gscreen>>=
if(gscreen == nil || gscreendata.bdata == nil)
    return nil;
@

\subsection{Next steps}

% what do you have now? draw_screen is set!

%\subsection{[[drawopen()]]}
% further initialisation when client actually connects to device
% when open Qnew and call drawnewclient
% and later when access Qctl dans get drawlookup and new dimage allocated



\section{Client side}

\subsection{[[initdraw()]]}

% see code of toy graphical app, initdraw(); which should set
% global [[display]] (and [[view]]).

<<function initdraw>>=
errorneg1
initdraw(Errorfn error, char *fontname , char *label)
{

    if(access("/dev/draw/new", AEXIST)<0 && bind("#i", "/dev", MAFTER)<0){
        fprint(2, "imageinit: can't bind /dev/draw: %r\n");
        return ERROR_NEG1;
    }
    return geninitdraw("/dev", error, fontname, label, "/dev", Refnone);
}
@
%old:    char *dev = "/dev";  but was not even used for bind so ...

% so even when run colors under terminal, it will not reuse /dev/draw/n,
% it will open a new draw!

% devdir and windir often equals and equal to "/dev"
<<function geninitdraw>>=
errorneg1
geninitdraw(char *devdir, Errorfn error, char *fontname, char *label, char *windir, int ref)
{
    <<[[geninitdraw()]] locals>>

    display = initdisplay(devdir, windir, error);
    <<[[geninitdraw()]] sanity check display>>

    <<[[geninitdraw()]] set up font>>
    <<[[geninitdraw()]] write new label>>
    <<[[geninitdraw()]] get window>>
    atexit(drawshutdown);

    return OK_1;
}
@
% modify the global!



<<[[geninitdraw()]] sanity check display>>=
if(display == nil)
    return ERROR_NEG1;
@

% Errorfn in appendix.

\subsection{[[initdisplay()]]}

% get connection and first automatically allocated image in d->image

<<[[initdisplay()]] locals>>=
fdt ctlfd;
fdt datafd;
fdt reffd;

char info[NINFO+1];
char buf[128];

Display *disp;
Image *image;

int n;
@
% why NINFO+1? because add a trailing \0 below

<<constant NINFO>>=
#define	NINFO	12*12
@
% /dev/draw/new content, 12 strings each 11 chars + newline
% use ascii format for image information, architecture independent, 
% and readable.


% hmm it's actually a public function! but not much app tweaking with it
% initdraw -> geninitdraw -> <>
<<function initdisplay>>=
Display*
initdisplay(char *dev, char *win, Errorfn error)
{
    <<[[initdisplay()]] locals>>

    <<[[initdisplay()]] install dumpers>>
    <<[[initdisplay()]] sanity check arguments>>

    sprint(buf, "%s/draw/new", dev);
    ctlfd = open(buf, ORDWR|OCEXEC);
    <<[[initdisplay()]] sanity check ctlfd>>

    n=read(ctlfd, info, sizeof info);
    <<[[initdisplay()]] sanity check read ctlfd>>
    info[n] = '\0';

    sprint(buf, "%s/draw/%d/data", dev, atoi(info+0*12));
    datafd = open(buf, ORDWR|OCEXEC);
    <<[[initdisplay()]] sanity check datafd>>

    sprint(buf, "%s/draw/%d/refresh", dev, atoi(info+0*12));
    reffd = open(buf, OREAD|OCEXEC);
    <<[[initdisplay()]] sanity check reffd>>

    // our display!
    disp = mallocz(sizeof(Display), true);
    <<[[initdisplay()]] sanity check disp>>
    disp->dirno = atoi(info+0*12);

    image = nil;
    <<[[initdisplay()]] sanity check image part1>>
    if(n >= NINFO){
        image = mallocz(sizeof(Image), true);
        <<[[initdisplay()]] sanity check image part2>>

        image->display = disp;
        image->id = 0; // info+1*12 but should always be 0
        image->chan = strtochan(info+2*12);
        image->depth = chantodepth(image->chan);
        image->repl = atoi(info+3*12);

        image->r.min.x = atoi(info+4*12);
        image->r.min.y = atoi(info+5*12);
        image->r.max.x = atoi(info+6*12);
        image->r.max.y = atoi(info+7*12);

        image->clipr.min.x = atoi(info+8*12);
        image->clipr.min.y = atoi(info+9*12);
        image->clipr.max.x = atoi(info+10*12);
        image->clipr.max.y = atoi(info+11*12);
    }
    disp->image = image;
    disp->fd    = datafd;
    disp->ctlfd = ctlfd;
    disp->reffd = reffd;

    <<[[initdisplay()]] set display bufsize>>
    disp->buf = malloc(disp->bufsize+5);	/* +5 for flush message */
    <<[[initdisplay()]] sanity check buf>>
    disp->bufp = disp->buf;

    disp->error = error;
    disp->windir = t;
    disp->devdir = strdup(dev);

    qlock(&disp->qlock); // released in closedisplay (why not earlier? first API call?)
  
    // first API calls!
    disp->white = allocimage(disp, Rect(0, 0, 1, 1), GREY1, true, DWhite);
    disp->black = allocimage(disp, Rect(0, 0, 1, 1), GREY1, true, DBlack);
    <<[[initdisplay()]] sanity check white and black>>
    disp->opaque = disp->white;
    disp->transparent = disp->black;

    return disp;
}
@
% refresh is important?
%dead:
%    <<[[initdisplay()]] set isnew>>
%    <<[[initdisplay()]] set display _isnewdisplay part1>>
%    <<[[initdisplay()]] set display _isnewdisplay part2>>
\l plus 5 for flush message? but flush is using only 1 byte now.

% clipped if run under a window? how enforced? not enforced ...

% strtochan later in Image IO chapter.
% atoi = string to number. =~ scanf.


<<[[initdisplay()]] set display bufsize>>=
disp->bufsize = iounit(datafd);
if(disp->bufsize <= 0)
    disp->bufsize = 8000;
<<[[initdisplay()]] sanity check bufsize>>
@
% iounit in libc.h






<<[[initdisplay()]] locals>>=
char *t;
@

<<[[initdisplay()]] sanity check arguments>>=
if(dev == nil)
    dev = "/dev";
if(win == nil)
    win = "/dev";

if(strlen(dev)>sizeof buf-25 || strlen(win)>sizeof buf-25){
    werrstr("initdisplay: directory name too long");
    return nil;
}
t = strdup(win);
if(t == nil)
    return nil;
@


%less: could reorganize error managment like in Linux instead
% have the errorx: followed, so less need 'goto previousone';
%anyway it's aspectized so less important now

<<[[initdisplay()]] sanity check ctlfd>>=
if(ctlfd < 0){
    if(bind("#i", dev, MAFTER) < 0){
Error1:
        free(t);
        werrstr("initdisplay: %s: %r", buf);
        return nil;
    }
    // try again
    ctlfd = open(buf, ORDWR|OCEXEC);
}
if(ctlfd < 0)
    goto Error1;
@

<<[[initdisplay()]] sanity check read ctlfd>>=
if(n < 12){
Error2:
    close(ctlfd);
    goto Error1;
}
if(n==NINFO+1)
    n = NINFO;
@

<<[[initdisplay()]] sanity check datafd>>=
if(datafd < 0)
    goto Error2;
@

<<[[initdisplay()]] sanity check reffd>>=
if(reffd < 0){
Error3:
    close(datafd);
    goto Error2;
}
@

<<[[initdisplay()]] sanity check disp>>=
if(disp == nil){
Error4:
    close(reffd);
    goto Error3;
}
@


<<[[initdisplay()]] sanity check image part1>>=
if(0){
Error5:
    free(image);
    free(disp);
    goto Error4;
}
@

<<[[initdisplay()]] sanity check image part2>>=
if(image == nil)
    goto Error5;
@

<<[[initdisplay()]] sanity check bufsize>>=
if(disp->bufsize < 512){
    werrstr("iounit %d too small", disp->bufsize);
    goto Error5;
}
@

<<[[initdisplay()]] sanity check buf>>=
if(disp->buf == nil)
    goto Error5;
@

<<[[initdisplay()]] sanity check white and black>>=
if(disp->white == nil || disp->black == nil){
    free(disp->devdir);
    free(disp->white);
    free(disp->black);
    goto Error5;
}
@

\subsection{[[closedisplay()]]}

<<function closedisplay>>=
/*
 * Call with d unlocked.
 * Note that disp->defaultfont and defaultsubfont are not freed here.
 */
void
closedisplay(Display *disp)
{
    _closedisplay(disp, false);
}
@
% can have multiple display? apparently.
\l call with d unlocked? initdisplay comment says the opposite


% exit -> <> (atexit(<>) <- geninitdraw <- initdraw)
<<function drawshutdown>>=
/* note handler */
static void
drawshutdown(void)
{
    Display *d;

    d = display;
    if(d){
        display = nil;
        _closedisplay(d, true);
    }
}
@


<<function _closedisplay>>=
static void
_closedisplay(Display *disp, bool isshutdown)
{
    fdt fd;
    char buf[128];

    <<[[_closedisplay()]] sanity check disp>>
    if(disp == display)
        display = nil;

    <<[[_closedisplay()]] restore oldlabel>>

    /*
     * if we're shutting down, don't free all the resources.
     * if other procs are getting shot down by notes too,
     * one might get shot down while holding the malloc lock.
     * just let the kernel clean things up when we exit.
     */
    if(isshutdown)
        return;

    free(disp->devdir);
    free(disp->windir);
    freeimage(disp->white);
    freeimage(disp->black);
    close(disp->fd);
    close(disp->ctlfd);
    /* should cause refresh slave to shut down */
    close(disp->reffd);

    qunlock(&disp->qlock);
    free(disp);
}
@
% unlock!

<<[[_closedisplay()]] sanity check disp>>=
if(disp == nil)
    return;
@
% again, should issue a warning

\subsection{Next steps}

% actually after setup disp->buf we saw first calls to draw API
% with allocimage which will write in /dev/draw/x/data! User/Kernel
% bridge which we will see now.

%\section{Client side part 2}
% but need User/Kernel bridge first.

\section{Fonts, labels, and windows}

% See later. Saw fontname passed to initdraw.

% For windows just say  view point to Display->image? with id 0?







\chapter{User/Kernel Bridge}
% kernel side part 2

% some kind of RPC and protocol

% in initdisplay, open /dev/draw/new and then
% read from it. All of that served by draw device (kinda of a server) 
% which we will see now.


\section{Draw device}


% 'i' below so bind #i

<<global drawdevtab>>=
Dev drawdevtab = {
    .dc       =    'i',
    .name     =    "draw",

    .attach   =    drawattach,
    .walk     =    drawwalk,
    .stat     =    drawstat,

    .open     =    drawopen,
    .close    =    drawclose,
    .read     =    drawread,
    .write    =    drawwrite,

    // generic               
    .create   =    devcreate,
    .remove   =    devremove,
    .bread    =    devbread,
    .bwrite   =    devbwrite,
    .wstat    =    devwstat,
    .reset    =    devreset,
    .init     =    devinit,
    .shutdown =    devshutdown,
};
@
%dc = device char (actually Rune)

% Seen drawattach() in Initialisation/mounting-draw section already.
%  setup screenimage (via attachscreen), from data setup by vga device.

% Need understand part of Kernel.nw.
% does    return devattach('i', spec);
%  spec = extra paramaters (usually nil)

% next most important = drawwalk! and notion of Qids.

<<enum _anon_ (kernel/devices/screen/devdraw.c)>>=
enum
{
    // Directories

    Qtopdir     = 0, // /dev
    Q2nd,            // /dev/draw/
    Q3rd,            // /dev/draw/x/

    // Files

    Qnew,
    Qwinname,

    // /dev/draw/x/y, third level device files associated to a client
    Qctl,  // used in 'x < Qctl' code so must be the first!
    Qdata, // all the operations, drawmesg()

    Qcolormap, 
    Qrefresh,
};
@
%pad: I reordered qids, grouped in QTDIR vs QTFILE

% remember plan9 has union dir, so Qtopdir is actually /dev

<<constant QSHIFT>>=
/*
 * Qid path is:
 *   4 bits of file type (qids above)
 *  24 bits of mux slot number +1; 0 means not attached to client
 */
#define QSHIFT  4   /* location in qid of client # */
@

<<function QID bis>>=
#define QID(q)      ((((ulong)(q).path)&0x0000000F)>>0)
@

<<function CLIENTPATH>>=
#define CLIENTPATH(q)   ((((ulong)q)&0x7FFFFFF0)>>QSHIFT)
@
%old: //#define CLIENT(q)   CLIENTPATH((q).path)
% why 7FFFFFFF0? why not FFFFFFFF0? Qid is not unsigned?


\subsection{[[drawwalk()]]}

% when do ls (see Kernel.nw)

<<function drawwalk>>=
static Walkqid*
drawwalk(Chan *c, Chan *nc, char **name, int nname)
{
    <<[[drawwalk()]] sanity check>>
    return devwalk(c, nc, name, nname, 0, 0, drawgen);
}
@

<<[[drawwalk()]] sanity check>>=
if(screenimage == nil)
    error("no frame buffer");
@

<<function drawstat>>=
static int
drawstat(Chan *c, uchar *db, int n)
{
    return devstat(c, db, n, 0, 0, drawgen);
}
@

% Again see Kernel but idea of xxxgen is that from
% directory in channel c with Qid t, get entry number s and
% populate Dir (actually devdir take care of that).
% return -1 when no more entries. return 1 when possibly more entries. 
% return 0 if error?

% sys?? -> devwalk -> <> (devwalk(..., <>) <- drawwalk)
<<function drawgen>>=
static int
drawgen(Chan *c, char*, Dirtab*, int, int s, Dir *dp)
{
    int t;
    Qid q;
    ulong path;
    Client *cl;

    q.vers = 0;

    <<[[drawgen()]] if dotdot>>
    // else
    t = QID(c->qid);

    /*
     * Top level directory contains the name of the device.
     */
    <<[[drawgen()]] toplevel directory listing>>
    // else
    /*
     * Second level contains "new" plus all the clients.
     */
    <<[[drawgen()]] second level directory listing>>
    // else
    /*
     * Third level.
     */
    <<[[drawgen()]] third level directory listing>>
}
@
% >> >>
\l could use a switch and indent code in default: case


<<[[drawgen()]] toplevel directory listing>>=
if(t == Qtopdir){
    switch(s){
    case 0:
        mkqid(&q, Q2nd, 0, QTDIR);
        devdir(c, q, "draw", 0, eve, 0555, dp);
        break;
    case 1:
        mkqid(&q, Qwinname, 0, QTFILE);
        devdir(c, q, "winname", 0, eve, 0444, dp);
        break;
    default:
        return -1;
    }
    return 1;
}
// else

if(t == Qwinname){
    mkqid(&q, Qwinname, 0, QTFILE);
    devdir(c, q, "winname", 0, eve, 0444, dp);
    return 1;
}
@
% fill dp

% will see important of winname later

% (how make sure not devgen not call drawgen indefinitely for Qwinname?
%  because it returns a QTFILE?)

<<[[drawgen()]] second level directory listing>>=
if(t == Q2nd || t == Qnew){
    if(s == 0){
        mkqid(&q, Qnew, 0, QTFILE);
        devdir(c, q, "new", 0, eve, 0666, dp);
    }
    else if(s <= sdraw.nclient){
        cl = sdraw.client[s-1];
        <<[[drawgen()]] in second level directory listing, sanity check cl>>
        snprint(up->genbuf, sizeof up->genbuf, "%d",
            cl->clientid);
        mkqid(&q, (s<<QSHIFT)|Q3rd, 0, QTDIR);
        devdir(c, q, up->genbuf, 0, eve, 0555, dp);
        return 1;
    }
    else
        return -1;
    return 1;
}
@
% >>
% use of clientid here! so will be listed as /dev/draw/x/... where
%  x is clientid that always increment
\l why t == Qnew here? could remove no? or do extra code like for Qwinname
\l  separated

<<[[drawgen()]] in second level directory listing, sanity check cl>>=
if(cl == nil)
    return 0;
@
% this happens when an entry got freed. drawgen will be called repeatitdely.


<<[[drawgen()]] third level directory listing>>=
path = c->qid.path & ~((1<<QSHIFT)-1);    /* slot component */
q.vers = c->qid.vers;
q.type = QTFILE;
switch(s){
case 0:
    q.path = path|Qcolormap;
    devdir(c, q, "colormap", 0, eve, 0600, dp);
    break;
case 1:
    q.path = path|Qctl;
    devdir(c, q, "ctl", 0, eve, 0600, dp);
    break;
case 2:
    q.path = path|Qdata;
    devdir(c, q, "data", 0, eve, 0600, dp);
    break;
case 3:
    q.path = path|Qrefresh;
    devdir(c, q, "refresh", 0, eve, 0400, dp);
    break;
default:
    return -1;
}
return 1;
@
% >> >>
\l sorted alphabetically? important? kernel requirment?


% DEVDOTDOT is -1
<<[[drawgen()]] if dotdot>>=
if(s == DEVDOTDOT){
    switch(QID(c->qid)){
    case Qtopdir:
    case Q2nd:
        mkqid(&q, Qtopdir, 0, QTDIR);
        devdir(c, q, "#i", 0, eve, 0500, dp);
        break;
    case Q3rd:
        cl = drawclientofpath(c->qid.path);
        if(cl == nil) // when can this happen?
            strncpy(up->genbuf, "??", sizeof up->genbuf);
        else
            snprint(up->genbuf, sizeof up->genbuf,
                "%d", cl->clientid);
        mkqid(&q, Q2nd, 0, QTDIR);
        devdir(c, q, up->genbuf, 0, eve, 0500, dp);
        break;
    default:
        panic("drawwalk %llux", c->qid.path);
    }
    return 1;
}
@

% might return nil
<<function drawclientofpath>>=
Client*
drawclientofpath(ulong path)
{
    Client *cl;
    int slot;

    slot = CLIENTPATH(path);
    if(slot == 0)
        return nil;
    cl = sdraw.client[slot-1];
    if(cl == nil || cl->clientid == 0)
        return nil;
    return cl;
}
@

\subsection{[[drawopen()]]}

% quite generic, specifics detailed later

<<function drawopen>>=
static Chan*
drawopen(Chan *c, int omode)
{
    <<[[drawopen()]] locals>>

    if(c->qid.type & QTDIR){
        c = devopen(c, omode, 0, 0, drawgen);
        c->iounit = IOUNIT;
    }

    <<[[drawxxx()]] lock>>
    <<[[drawopen()]] if Qnew>>
    switch(QID(c->qid)){
    <<[[drawopen()]] switch qid cases>>
    }
    <<[[drawxxx()]] unlock>>

    c->mode = openmode(omode);
    c->flag |= COPEN;
    c->offset = 0;
    c->iounit = IOUNIT;

    return c;
}
@
% >> 

<<constant IOUNIT>>=
#define IOUNIT      (64*1024)
@



<<[[drawxxx()]] lock>>=
dlock();
if(waserror()){
    dunlock();
    nexterror();
}
@

<<[[drawxxx()]] unlock>>=
dunlock();
poperror();
@


\subsection{[[drawclose()]]}

<<function drawclose>>=
static void
drawclose(Chan *c)
{
    Client *cl;
    <<[[drawclose()]] other locals>>

    if(QID(c->qid) < Qctl) /* Qtopdir, Qnew, Q3rd, Q2nd have no client */
        return;

    <<[[drawxxx()]] lock>>

    cl = drawclient(c);
    <<[[drawclose()]] if Qctl>>

    if((c->flag&COPEN) && (decref(&cl->r)==0)){
        <<[[drawclose()]] free refresh>>
        <<[[drawclose()]] free names>>
        <<[[drawclose()]] free screens>>
        /* all screens are freed, so now we can free images */
        <<[[drawclose()]] free dimages>>

        sdraw.client[cl->slot] = nil;

        drawflush();    /* to erase visible, now dead windows */
        free(cl);
    }
    <<[[drawxxx()]] unlock>>
}
@
%old: if(QID(c->qid) < Qcolormap) /* Qtopdir, Qnew, Q3rd, Q2nd have no client */

% small wrapper with error checking, will never return nil, may raise exn!
<<function drawclient>>=
Client*
drawclient(Chan *c)
{
    Client *client;

    client = drawclientofpath(c->qid.path);
    if(client == nil)
        error(Enoclient);
    return client;
}
@



<<[[drawclose()]] other locals>>=
DImage *d, **dp;
int i;
@

<<[[drawclose()]] free dimages>>=
dp = cl->dimage;
for(i=0; i<NHASH; i++){
    while((d = *dp) != nil){
        *dp = d->next;
        drawfreedimage(d);
    }
    dp++;
}
@

% drawfreedimage() later


\subsection{[[drawread()]]}

<<function drawread>>=
long
drawread(Chan *c, void *a, long n, vlong off)
{
    Client *cl;
    <<[[drawread()]] other locals>>

    if(c->qid.type & QTDIR)
        return devdirread(c, a, n, 0, 0, drawgen);
    <<[[drawread()]] if Qwinname>>
    // else

    cl = drawclient(c);

    <<[[drawxxx()]] lock>>
    switch(QID(c->qid)){
    <<[[drawread()]] switch qid cases>>
    }
    <<[[drawxxx()]] unlock>>

    return n;
}
@



\subsection{[[drawwrite()]]}


<<function drawwrite>>=
static long
drawwrite(Chan *c, void *a, long n, vlong)
{
    Client *cl;
    <<[[drawwrite()]] other locals>>

    <<[[drawwrite()]] sanity check c>>
    cl = drawclient(c);

    <<[[drawwrite()]] lock>>
    switch(QID(c->qid)){
    <<[[drawwrite()]] switch qid cases>>
    default:
        error(Ebadusefd);
    }
    <<[[drawxxx()]] unlock>>

    return n;
}
@

<<[[drawwrite()]] sanity check c>>=
if(c->qid.type & QTDIR)
    error(Eisdir);
@


% locking a bit different, why? drawwakeall?
<<[[drawwrite()]] lock>>=
dlock();
if(waserror()){

    drawwakeall();

    dunlock();
    nexterror();
}
@

\section{Draw device files}

\subsection{Opening [[/dev/draw/new]]}

<<[[drawopen()]] locals>>=
Client *cl;
@

<<[[drawopen()]] if Qnew>>=
if(QID(c->qid) == Qnew){
    cl = drawnewclient();
    <<[[drawopen()]] when Qnew, sanity check cl>>
    c->qid.path = Qctl|((cl->slot+1)<<QSHIFT);
}
@
% >>
\l why not put in switch instead?
% saw drawnewclient() in core DS chapter.
<<[[drawopen()]] switch qid cases>>=
case Qnew:
    break;
@

% generate a Qctl qid!
% opening qnew redirect to a /dev/draw/x/ctl!
% (x is not slot, slot is reused, x is clientid, see drawgen

<<[[drawopen()]] when Qnew, sanity check cl>>=
if(cl == nil)
    error(Enodev);
@

\subsection{Reading [[/dev/draw/x/ctl]]}
% (and write a bit)

\l I put the code of drawopen and Qctl in adv topics because normally
\l  you should not do that and the code looked subtle.

<<[[drawread()]] other locals>>=
Memimage *i;
char buf[16];
@

<<[[drawread()]] switch qid cases>>=
case Qctl:
    if(n < 12*12) // NINFO
        error(Eshortread);

    <<[[drawread()]] switch qid cases, when Qctl, set i>>

    // mostly for initdisplay!
    n = snprint(a, n,
        "%11d %11d %11s %11d %11d %11d %11d %11d %11d %11d %11d %11d ",
        cl->clientid, cl->infoid, chantostr(buf, i->chan),
        (i->flags&Frepl)==Frepl,
        i->r.min.x, i->r.min.y, i->r.max.x, i->r.max.y,
        i->clipr.min.x, i->clipr.min.y, i->clipr.max.x, i->clipr.max.y
        );
    cl->infoid = -1;
    break;
@
% 11 integers with %11d + 1 space + 1 string with %11s + space = 12 * 12
%  (note extra space after last number too)
% see that export just the bool for Image.repl, not the whole flag!

% not just for initdisplay though. enter infoid below.

<<[[Client]] other fields>>=
int     infoid;
@
% rename current_image? hmm it's more actually just for
%  get information about image with specific id, so maybe good field name.
\l related to named image too?

% infoid is set to 0 in drawnewclient because of malloc.
% can be changed:
% (also used for namedimage and 'n' message)

<<[[drawwrite()]] switch qid cases>>=
case Qctl:
    if(n != 4)
        error("unknown draw control request");
    cl->infoid = BGLONG((uchar*)a);
    break;
@
% set infoid for further reading operation


<<[[drawread()]] other locals>>=
DImage *di;
@

<<[[drawread()]] switch qid cases, when Qctl, set i>>=
<<[[drawread()]] switch qid cases, when Qctl, sanity check infoid>>
if(cl->infoid == 0){
    i = screenimage;
    <<[[drawread()]] switch qid cases, when Qctl, sanity check i>>
}else{
    di = drawlookup(cl, cl->infoid, true);
    <<[[drawread()]] switch qid cases, when Qctl, sanity check di>>
    i = di->image;
}
@

% when cl->infoid == 0? because of malloc of new client.
% when <0?  just after first read, so further read
%  of Qctl will return an error.
% when positive? when write to ctl to get info about another image!

<<[[drawread()]] switch qid cases, when Qctl, sanity check infoid>>=
if(cl->infoid < 0)
    error(Enodrawimage);
@

<<[[drawread()]] switch qid cases, when Qctl, sanity check i>>=
if(i == nil)
    error(Enodrawimage);
@
<<[[drawread()]] switch qid cases, when Qctl, sanity check di>>=
if(di == nil)
    error(Enodrawimage);
@





\subsection{Writing [[/dev/draw/x/data]]}
% (and open)
% and DImage?


<<[[drawopen()]] switch qid cases>>=
case Qdata:
case Qcolormap:
case Qrefresh:
    cl = drawclient(c);
    incref(&cl->r);
    break;
@


<<[[drawwrite()]] switch qid cases>>=
case Qdata:
    // The big dispatch!!
    drawmesg(cl, a, n);

    drawwakeall();
    break;
@

% The big dispatch, see next section.

% drawwakeall? again.

% it is possible to read from Qdata to read images as explained
% later in Section X.


% seems a bit useless to have 3 different device files.
% maybe we could use only 1 and have the open/read/write on it.
% But as we will see one can also write on /ctl and read on /data
% so at least need two files and then can have multiple clients
% hence the difference between /new and /ctl.

%\subsection{[[/dev/draw/x/refresh]]}
% adv topics



\section{Draw message protocol}

% we will see later in the book repetitive structure
% which correspond to what we call the Draw message protocol.
% Each section below present a step in this protocol.

\subsection{API}

% first API.

% ex line() ...

%real-world: =~ Xlib layer

\subsection{Marshalling}

% ex line code to marshall with use of BGSHORT, bufimage, etc.


% Lots of boilerplate code, would be better to use thrift in the end?
% Lots of marshalling/unmarshalling boilerplate with BPLONG and so on.
% File interface is nice but limited in the end. Or maybe can just
% write a thrift like tool on top of the file interface that generates
% most of the boilerplate at least.

% G = Get, P = Put
% B = Binary? Bytes?

<<function BGSHORT>>=
#define	BGSHORT(p)		(((p)[0]<<0) | ((p)[1]<<8))
@
<<function BGLONG>>=
#define	BGLONG(p)		((BGSHORT(p)<<0) | (BGSHORT(p+2)<<16))
@
<<function BPSHORT>>=
#define	BPSHORT(p, v)		((p)[0]=(v), (p)[1]=((v)>>8))
@
<<function BPLONG>>=
#define	BPLONG(p, v)		(BPSHORT(p, (v)), BPSHORT(p+2, (v)>>16))
@

% could start by a simple example? like flush?


<<[[Display]] buffer fields>>=
// drawing operations to write in /dev/draw/x/data until flush
// array<byte> (length = Display.bufsize)
byte	*buf;
int		bufsize;
// index in Display.buf array
byte	*bufp;
@
% who sets bufsize? initdisplay, usually set to iounit(datafd).

% when want to write a "message" of size n, get a pointer to the
% next free byte in the buffer
<<function bufimage>>=
byte*
bufimage(Display *d, int n)
{
    byte *p;

    <<[[bufimage()]] sanity check n>>
    if(d->bufp + n  >  d->buf + d->bufsize)
        if(doflush(d) < 0)
            return nil;
    p = d->bufp;
    d->bufp += n;
    return p;
}
@

<<[[bufimage()]] sanity check n>>=
if(n < 0 || n > d->bufsize){
    werrstr("bad count in bufimage");
    return nil;
}
@
% werrstr ? Libcore?



% why not _flushimage? because this one we actually write stuff!
% we not just modify buffer. we send it to the device!
<<function doflush>>=
static
errorneg1
doflush(Display *d)
{
    int n, nn;

    n = d->bufp - d->buf;
    if(n <= 0)
        return OK_1; // warning?

    nn=write(d->fd, d->buf, n);
    <<[[doflush()]] sanity check nn>>
    d->bufp = d->buf;
    return OK_1;
}
@
% write!! trigger kernel side!

<<[[doflush()]] sanity check nn>>=
if(nn != n){
    <<[[doflush()]] if _drawdebug>>
    d->bufp = d->buf;	/* might as well; chance of continuing */
    return ERROR_NEG1;
}
@


\subsection{Unmarshalling and [[drawmesg()]]}

%real-world: =~ Xserver

<<[[drawmesg()]] locals>>=
byte *a;
int m = 0;
char *fmt = nil;
@
% m is for storing how much bytes were read for this message,
% so the loop on the buffer can go on and process the next message

% the big one!! this is in kernel!!
% syswrite -> drawwrite(Qdata) -> <>
<<function drawmesg>>=
void
drawmesg(Client *client, void *av, int n)
{
    <<[[drawmesg()]] locals>>

    a = av;
    if(waserror()){
        if(fmt) 
            printmesg(fmt, a, true);
        nexterror();
    }
    while((n-=m) > 0){
        USED(fmt);
        a += m;
        switch(*a){
        <<[[drawmesg()]] cases>>
        default:
            error("bad draw command");
        }
    }
    poperror();
}
@
%old:    /*  iprint("error: %s\n", up->errstr);  */

% split in different messages chunks hence the while.
% the switch will adjust m which contains the size for one message
% (which vary dependong on the message command).

% unmarshallers helpers:
% drawrectangle(), etc


\subsection{Algorithm}
% Memory Algorithm?

%real-world: libpixman?

\subsection{Optional hardware support hook}

%real-world: libdrm and Linux kernel comm?

% via screen and then VGAscr and then VGAdev interfaces
% (and also VGAcur interface)

%\subsubsection{Screen interface}
% Kernel/Hardware bridge

% screen.h

%\subsubsection{Graphics card}
% Graphic VGA card?
% there is also the VGA interface, which is something different

%\subsubsection{VGA interface}
% or VGA screen? meh maybe, simpler to just have a
% framebuffer
% vga.h







\chapter{Images}

% Fundamental piece!
% The screen is an image. Colors are images!! Mask are images.
% Tiles are images. Background are special images.
% Fonts are images (even Windows are images).

% Can have multiple images, draw there, and at some point
% quickly copy on main image (display->image).

% The initial display->image is actually allocated for you
% (got a first image allocated for you when open draw device, 'screen/view')
% But how allocate new one? temporary canvas to draw on.

\section{Allocation}

% already one allocated for you! the screen, image id 0.
% view! (was screen)

\subsection{API}

% remember in initdisplay first API calls!
%    disp->white = allocimage(disp, Rect(0, 0, 1, 1), GREY1, true, DWhite);
%    disp->black = allocimage(disp, Rect(0, 0, 1, 1), GREY1, true, DBlack);


%ctor
<<function allocimage>>=
Image*
allocimage(Display *d, Rectangle r, ulong chan, bool repl, rgba val)
{
    Image*	i;

    i =  _allocimage(nil, d, r, chan, repl, val, 0, 0);
    <<[[allocimage()]] set malloc tag for debug>>
    return i;
}
@
\l 0,0 is screenid and refresh. Could use Refbackup but anyway adv concept.
\t can have a Rectangle that does not start at Pt(0, 0) ?

% for a color r is usually R(0,0,1,1), chan is view->chan, repl = true,
% and val is the color

%dtor
<<function freeimage>>=
errorneg1
freeimage(Image *i)
{
    errorneg1 ret;

    ret = _freeimage1(i);
    free(i);
    return ret;
}
@
\l why not _freeimage? be consistent at least, and why extra function?



\subsection{Marshalling}

% ai usually nil
%ctor
<<function _allocimage>>=
Image*
_allocimage(Image *ai, Display *d, Rectangle r, ulong chan, bool repl, rgba val, int screenid, int refresh)
{
    Image *i = nil;
    char *err = nil;
    byte *a;
    Rectangle clipr;
    int id;
    int depth;

    <<[[_allocimage()]] sanity check chan>>
    depth = chantodepth(chan);
    <<[[_allocimage()]] sanity check depth>>

    /* flush pending data so we don't get error allocating the image */
    flushimage(d, false);

    // new allocate: 'b' id[4] screenid[4] refresh[1] chan[4] repl[1] R[4*4] clipR[4*4] rrggbbaa[4]
    a = bufimage(d, 1+4+4+1+4+1+4*4+4*4+4);
    <<[[_allocimage()]] sanity check a>>

    d->imageid++;
    id = d->imageid;

    a[0] = 'b';
    BPLONG(a+1, id);

    BPLONG(a+5, screenid);
    a[9] = refresh;

    BPLONG(a+10, chan);
    a[14] = repl;
    BPLONG(a+15, r.min.x);
    BPLONG(a+19, r.min.y);
    BPLONG(a+23, r.max.x);
    BPLONG(a+27, r.max.y);
    <<[[_allocimage()]] set clipr>>
    BPLONG(a+31, clipr.min.x);
    BPLONG(a+35, clipr.min.y);
    BPLONG(a+39, clipr.max.x);
    BPLONG(a+43, clipr.max.y);
    BPLONG(a+47, val);

    if(flushimage(d, false) < 0)
        goto Error;

    <<[[_allocimage()]] if passed image>>
    else{
        i = malloc(sizeof(Image)); // client side allocation
        <<[[_allocimage()]] sanity check i>>
    }

    i->display = d;
    i->id = id;
    i->depth = depth;
    i->chan = chan;
    i->r = r;
    i->clipr = clipr;
    i->repl = repl;

    i->screen = nil;
    i->next = nil;

    return i;
}
@
% A bit sad to have this duplicated info kernel and user side.
% Have user side probably for programmer's convenient so he can
%  have directly information about the image.
%alt: could have a get_info call (actually there is one when write
% stuff and read the ctl file with infoid)


<<[[_allocimage()]] if passed image>>=
if(ai)
    i = ai;
@
% when pass an already allocated image to allocimage?





<<[[_allocimage()]] sanity check chan>>=
if(chan == 0){
    werrstr("bad channel descriptor");
    return nil;
}
@

<<[[_allocimage()]] sanity check depth>>=
if(depth == 0){
    err = "bad channel descriptor";
Error:
    if(err)
        werrstr("allocimage: %s", err);
    else
        werrstr("allocimage: %r");
    free(i);
    return nil;
}
@

<<[[_allocimage()]] sanity check a>>=
if(a == nil)
    goto Error;
@

<<[[_allocimage()]] sanity check i>>=
if(i == nil){
    // free: 'f' id[4]
    a = bufimage(d, 1+4);
    if(a){
        a[0] = 'f';
        BPLONG(a+1, id);
        flushimage(d, false);
    }
    goto Error;
}
@





<<function _freeimage1>>=
errorneg1
_freeimage1(Image *i)
{
    byte *a;
    Display *d;
    Image *w;

    <<[[_freeimage1()]] sanity check i>>

    /* make sure no refresh events occur on this if we block in the write */
    d = i->display;
    /* flush pending data so we don't get error deleting the image */
    flushimage(d, false);

    // free: 'f' id[4]
    a = bufimage(d, 1+4);
    <<[[_freeimage1()]] sanity check a>>
    a[0] = 'f';
    BPLONG(a+1, i->id);
    <<[[_freeimage1()]] if screen>>

    if(flushimage(d, i->screen != nil) < 0)
        return ERROR_NEG1;

    return OK_0;
}
@
% free done in caller (a bit ugly)


<<[[_freeimage1()]] sanity check i>>=
if(i == nil || i->display == nil)
    return OK_0;
@
% should issue a warning

<<[[_freeimage1()]] sanity check a>>=
if(a == nil)
    return ERROR_NEG1;
@



\subsection{Unmarshalling}

<<[[drawmesg()]] locals>>=
int dstid, scrnid;
byte refresh;
ulong chan;
int repl;
Rectangle r, clipr;
// rgba
ulong value;

Memimage *i;
@

<<[[drawmesg()]] cases>>=
/* new allocate: 'b' id[4] screenid[4] refresh[1] chan[4] repl[1] R[4*4] clipR[4*4] rrggbbaa[4] */
case 'b':
    printmesg(fmt="LLbLbRRL", a, false);
    m = 1+4+4+1+4+1+4*4+4*4+4;
     <<[[drawmesg()]] sanity check n with m>>
    dstid = BGLONG(a+1);

    scrnid = BGSHORT(a+5);
    refresh = a[9];

    chan = BGLONG(a+10);
    repl = a[14];
    drawrectangle(&r, a+15);
    drawrectangle(&clipr, a+31);
    value = BGLONG(a+47);

    <<[[drawmesg()]] allocate image case, sanity check dstid>>
    <<[[drawmesg()]] allocate image case, if screen id>>
    // else

    i = allocmemimage(r, chan); // server side allocation
    <<[[drawmesg()]] allocate image case, sanity check i>>
    if(repl)
        i->flags |= Frepl;
    i->clipr = clipr;
    <<[[drawmesg()]] allocate image case, clip clipr>>

    if(drawinstall(client, dstid, i, nil) == nil){
        freememimage(i);
        error(Edrawmem);
    }
    memfillcolor(i, value);
    continue;
@


<<[[drawmesg()]] sanity check n with m>>=
if(n < m)
    error(Eshortdraw);
@

<<[[drawmesg()]] allocate image case, sanity check i>>=
if(i == nil)
    error(Edrawmem);
@
<<[[drawmesg()]] allocate image case, sanity check dstid>>=
if(drawlookup(client, dstid, false))
    error(Eimageexists);
@





<<function drawrectangle>>=
void
drawrectangle(Rectangle *r, uchar *a)
{
    r->min.x = BGLONG(a+0*4);
    r->min.y = BGLONG(a+1*4);
    r->max.x = BGLONG(a+2*4);
    r->max.y = BGLONG(a+3*4);
}
@





<<[[drawmesg()]] locals>>=
DImage *ll;
@
\l could reuse di instead

<<[[drawmesg()]] cases>>=
/* free: 'f' id[4] */
case 'f':
    printmesg(fmt="L", a, true);
    m = 1+4;
    <<[[drawmesg()]] sanity check n with m>>
    ll = drawlookup(client, BGLONG(a+1), false);
    <<[[drawmesg()]] free image case, if dscreen>>
    drawuninstall(client, BGLONG(a+1)); // The call

    continue;
@




\subsection{Algorithm}

% allocimage -> _allocimage -> ... -> drawmesg -> <>
%Memdata and then Memimage ctor
% should be called once automatically when one creates a new connection no?
<<function allocmemimage>>=
Memimage*
allocmemimage(Rectangle r, ulong chan)
{
    int d;
    byte *p;
    ulong l, nw;
    Memdata *md;
    Memimage *i;

    d = chantodepth(chan);
    <<[[allocmemimage()]] sanity check d>>

    l = wordsperline(r, d);
    nw = l * Dy(r);

    md = malloc(sizeof(Memdata));
    <<[[allocmemimage()]] sanity check md>>
    md->ref = 1;
    // the big alloc!
    md->base = poolalloc(imagmem, sizeof(Memdata*)+(1+nw)*sizeof(ulong));
    <<[[allocmemimage()]] sanity check md base>>

    p = (byte*)md->base;
    *(Memdata**)p = md;
    p += sizeof(Memdata*);
    *(ulong*)p = getcallerpc(&r);
    p += sizeof(ulong);

    /* if this changes, memimagemove must change too */
    md->bdata = p;
    md->allocd = true;

    i = allocmemimaged(r, chan, md);
    <<[[allocmemimage()]] sanity check i>>

    return i;
}
@
% we have seen allocmemimaged before

%dead:
%    md->imref = i;
% <<[[Memdata]] other fields>>=
% // ref<Memimage>, reverse of Memimage.bdata
% void*	imref;
% @






<<[[allocmemimage()]] sanity check d>>=
if(d == 0) {
    werrstr("bad channel descriptor %.8lux", chan);
    return nil;
}
@

<<[[allocmemimage()]] sanity check md>>=
if(md == nil)
    return nil;
@

<<[[allocmemimage()]] sanity check md base>>=
if(md->base == nil){
    free(md);
    return nil;
}
@

<<[[allocmemimage()]] sanity check i>>=
if(i == nil){
    poolfree(imagmem, md->base);
    free(md);
    return nil;
}
@


\subsection{[[Client]] and [[Memimage]] connection, [[DImage]]}

% drawmesg(allocate) -> <>
<<function drawinstall>>=
Memimage*
drawinstall(Client *client, int id, Memimage *i, DScreen *dscreen)
{
    DImage *d;

    d = allocdimage(i);
    <<[[drawinstall()]] sanity check d>>
    d->id = id;
    <<[[drawinstall()]] install dscreen>>

    // insert_hash(d, client->dimage)
    d->next = client->dimage[id&HASHMASK];
    client->dimage[id&HASHMASK] = d;

    return i;
}
@
% allocdimage we have seen before too

% why not return void? because of this sanity check
<<[[drawinstall()]] sanity check d>>=
if(d == nil)
    return nil;
@



<<function drawuninstall>>=
void
drawuninstall(Client *client, int id)
{
    DImage *d, *next;

    d = client->dimage[id&HASHMASK];
    <<[[drawuninstall()]] sanity check d>>

    // hash_remove(client->dimage, id)
    if(d->id == id){
        client->dimage[id&HASHMASK] = d->next;

        drawfreedimage(d);
        return;
    }
    while(next = d->next){  /* assign = */
        if(next->id == id){
            d->next = next->next;

            drawfreedimage(next);
            return;
        }
        d = next;
    }

    error(Enodrawimage);
}
@

<<[[drawuninstall()]] sanity check d>>=
if(d == nil)
    error(Enodrawimage);
@

% drawclose | drawuninstall  -> <>
<<function drawfreedimage>>=
void
drawfreedimage(DImage *dimage)
{
    int i;
    Memimage *l;
    DScreen *ds;

    dimage->ref--;
    <<[[drawfreedimage()]] sanity check dimage ref>>
    if(dimage->ref > 0)
        return;
    // else

    <<[[drawfreedimage()]] free names>>
    <<[[drawfreedimage()]] if dscreen>>
    else
        freememimage(dimage->image);
    Return:
    free(dimage->fchar);
    free(dimage);
}
@
%//  if(dimage->image == screenimage)    /* don't free the display */
%//      goto Return;

% freeimage before for screen.

<<[[drawfreedimage()]] sanity check dimage ref>>=
if(dimage->ref < 0)
    print("negative ref in drawfreedimage\n");
@



\section{Clipping and replication}
% (tiling)

% Clipping is fundamental graphics operation. Very useful
% generic functionality. Like narrow mode in emacs :)

% Replication is useful to save space in memory, for color, while
% still being general. Also useful for adv effect such as tiling
% (repeating a background pattern for instance).

% Clipping called by many, to optimize things, e.g. no need to flush some modif
% if rectangle outside the clipping area.
% Modify the first parameter when they overlap to match the intersection.


% Can have either repl or clip? Can have both! Usually have
% repl set to true and infinite (actually huge) clipping. This is why in code
% later there is code that first do  rectclip(r, img->clipr)
%  and then if(!(img->flags&Frepl)) rectclip(r, img->r)

% Note that the repl bit is used only when the image is used as a source.
% This is why the clipping code for dst and src is a bit different.


<<[[_allocimage()]] set clipr>>=
if(repl)
    /* huge but not infinite, so various offsets will leave it huge, not overflow */
    clipr = Rect(-0x3FFFFFFF, -0x3FFFFFFF, 0x3FFFFFFF, 0x3FFFFFFF);
else
    clipr = r;
@
% hacky a bit this huge but not infinite



<<[[drawmesg()]] allocate image case, clip clipr>>=
if(!repl)
    rectclip(&i->clipr, r);
@
% kinda optimize a bit more and restrict clipr even more (to be inside r)

% flushmemscreen | drawmesg(allocate) | ... -> <>
<<function rectclip>>=
bool
rectclip(Rectangle *rp, Rectangle b) /* first by reference, second by value */
{
    Rectangle *bp = &b;
    /*
     * Expand rectXrect() in line for speed
     */
    if(!(rp->min.x < bp->max.x && bp->min.x < rp->max.x &&
        rp->min.y < bp->max.y && bp->min.y < rp->max.y))
        return false;

    /* They must overlap */
    if(rp->min.x < bp->min.x)
        rp->min.x = bp->min.x;
    if(rp->min.y < bp->min.y)
        rp->min.y = bp->min.y;
    if(rp->max.x > bp->max.x)
        rp->max.x = bp->max.x;
    if(rp->max.y > bp->max.y)
        rp->max.y = bp->max.y;
    return true;
}
@
% FIGURE with intersection

% return false if no overlap. will be used as rectclip(x, screenimage->r)
%  to see if rectangle is outside screen in which case flush is not needed.



\subsection{API}

<<function replclipr>>=
void
replclipr(Image *i, bool repl, Rectangle clipr)
{
    <<[[replclipr()]] body>>
}
@
% can you enlarge?

\subsection{Marshalling}

<<[[replclipr()]] body>>=
byte *b;

// set repl and clip: 'c' dstid[4] repl[1] clipR[4*4]
b = bufimage(i->display, 1+4+1+4*4);
b[0] = 'c';
BPLONG(b+1, i->id);
repl = (repl != 0);
b[5] = repl;
BPLONG(b+6, clipr.min.x);
BPLONG(b+10, clipr.min.y);
BPLONG(b+14, clipr.max.x);
BPLONG(b+18, clipr.max.y);
i->repl = repl;
i->clipr = clipr;
@
%old: was 22 but more consistent to put the serie of plus as before

\subsection{Unmarshalling}

<<[[drawmesg()]] locals>>=
DImage *ddst;
Memimage *dst;
@

<<[[drawmesg()]] cases>>=
/* set repl and clip: 'c' dstid[4] repl[1] clipR[4*4] */
case 'c':
    printmesg(fmt="LbR", a, false);
    m = 1+4+1+4*4;
    <<[[drawmesg()]] sanity check n with m>>
    ddst = drawlookup(client, BGLONG(a+1), true);
    <<[[drawmesg()]] clipping case, sanity check ddst>>
    dst = ddst->image;

    if(a[5])
        dst->flags |= Frepl;
    drawrectangle(&dst->clipr, a+6); // The call

    continue;

@
% forgot call rectclip()? to make sure valid clipr?

<<[[drawmesg()]] clipping case, sanity check ddst>>=
if(ddst == nil)
    error(Enodrawimage);
@


\subsection{Algorithm}

% The call is actually drawrectangle which really just parse
% a rectangle, so the call is actually to modify dst->clipr.

% But later we will see memimagedraw which use clipping when
% draw a src on dst. But code of drawclip() is very complicated
% so see section X later.



\section{Flushing}

% annoying? why need that? leaky abstraction?
% cos cant hide remote feature of /dev/draw a la X11?

\subsection{API}

% visible argument? called many times with false internally
%  to avoid wrong error messages

<<function flushimage>>=
errorneg1
flushimage(Display *d, bool visible)
{
    <<[[flushimage()]] sanity check d>>
    <<[[flushimage()]] if visible>>
    return doflush(d);
}
@
\l why not use global display instead? can have multiple one?
%dead:
%        <<[[flushimage()]] if isnew>>

% should be called flushdisplay more than flushimage.

% saw doflush before which triggers the write on /dev/draw/x/data fd.

<<[[flushimage()]] sanity check d>>=
if(d == nil)
    return OK_0;
@
% meh OK


%dead: seems useless because unmarshalling code does not use extra passed info
%   <<[[Display]] other fields>>=
%   bool	_isnewdisplay;
%   @
%   <<[[initdisplay()]] locals>>=
%   bool isnew = false;
%   @
%   <<[[initdisplay()]] set isnew>>=
%   if(n < NINFO)	/* this will do for now, we need something better here */
%       isnew = true;
%   @
%   <<[[initdisplay()]] set display _isnewdisplay part1>>=
%   disp->_isnewdisplay = isnew;
%   @
%   
%   <<[[initdisplay()]] locals>>=
%   Dir *dir;
%   @
%   <<[[initdisplay()]] set display _isnewdisplay part2>>=
%   dir = dirfstat(ctlfd);
%   if(dir!=nil && dir->qid.vers==1)	/* other way to tell */
%       disp->_isnewdisplay = true;
%   free(dir);
%   @
%dead:
%if(dir!=nil && dir->type=='i'){
%    disp->local = true;
%    disp->dataqid = dir->qid.path;
%}
%    
%    <<[[flushimage()]] if isnew>>=
%    if(d->_isnewdisplay){
%        BPLONG(d->bufp, d->screenimage->id);
%        d->bufp += 4;
%    }
%    @
% after v, but according to drawmesg protocol and unmarshalling
% code the code does not use this id.




\subsection{Marshalling}

% extra message for the kernel.

<<[[flushimage()]] if visible>>=
// visible: 'v'
if(visible){
    *d->bufp++ = 'v';	/* five bytes always reserved for this */
}
@
% but now I dont use five, so still valid comment?

% see doflush in chapter Kernel/User bridge which finally writes
% on /dev/draw/x/data

\subsection{Unmarshalling}

<<[[drawmesg()]] cases>>=
/* visible: 'v' */
case 'v':
    printmesg(fmt="", a, false);
    m = 1;

    drawflush(); // The call

    continue;

@


\subsection{Algorithm}


<<global flushrect>>=
static  Rectangle   flushrect;
@
% who sets it except drawflush? 
% - dstflush called by memimagedraw
% - addflush
% - drawopen(Qctl)

% drawclose | ... -> <>
<<function drawflush>>=
void
drawflush(void)
{
    if(flushrect.min.x < flushrect.max.x)
        flushmemscreen(flushrect);
    flushrect = Rect(10000, 10000, -10000, -10000);
}
@
% it's actually an empty rectangle! min is more than max!
% see combinerect below.
\l why not use Rect(0,0, 0,0) instead? because can have Rect outside screen?

% some code can limit the flushrect so can optimize things.


% drawmesg(draw) | ??? -> <>
<<function dstflush>>=
static
void
dstflush(int dstid, Memimage *dst, Rectangle r)
{
    <<[[dstflush()]] locals>>

    if(dstid == 0){ // the screen
        combinerect(&flushrect, r);
        return;
    }
    // else
    <<[[dstflush()]] sanity check dst>>
    <<[[dstflush()]] if layer>>
}
@
\t but flushrect is huge originally so combine is useless.
% pass dstid cos id not in Memimage and we want to check if it is the screen.

<<[[dstflush()]] sanity check dst>>=
/* how can this happen? -rsc, dec 12 2002 */
if(dst == nil){
    print("nil dstflush\n");
    return;
}
@

<<function combinerect>>=
void
combinerect(Rectangle *r1, Rectangle r2)
{
    if(r1->min.x > r2.min.x)
        r1->min.x = r2.min.x;
    if(r1->min.y > r2.min.y)
        r1->min.y = r2.min.y;
    if(r1->max.x < r2.max.x)
        r1->max.x = r2.max.x;
    if(r1->max.y < r2.max.y)
        r1->max.y = r2.max.y;
}
@
% bounding box, useless to optimize further.




\subsection{Hardware support hook}

% on bcm/ this is a noop as write in the framebuffer are already
% flushed ... it's a direct connection.
\t but how sync with monitor and avoid flickering?


% 386/vgascreen.c!
% drawflush | many more functions (e.g. swcursorhide) -> <>
<<function flushmemscreen(x86)>>=
/*
 * It would be fair to say that this doesn't work for >8-bit screens.
 */
void
flushmemscreen(Rectangle r)
{
    VGAscr *scr;
    <<[[flushmemscreen()]] other locals>>

    scr = &vgascreen;

    // call the device driver flush hook
    if(scr->dev && scr->dev->flush){
        scr->dev->flush(scr, r);
        return;
    }
    // else
    if(gscreen == nil || !scr->useflush)
        return;
    if(scr->dev == nil || scr->dev->page == nil)
        return;
    if(!rectclip(&r, gscreen->r))
        return;

    <<[[flushmemscreen()]] use VGA page>>
}
@
% See apparendix for dev->flush and dev->page implementation


\section{Naming and sharing (and windows)}
\n mv in adv topics? at the same time windows is so complicated
\n  that good to divide and see a first chunk earlier.


% A form of IPC. Like named pipe, here named images.
%alt: ?? could not use FS for that?


% used also by rio! (see graphics(2)). 
% from allocimage(2):
%  These routines permit unrelated applications sharing a display to share 
%  an image; for example they provide the mechanism behind getwindow

\subsection{API}

<<function nameimage>>=
error0
nameimage(Image *i, char *name, bool in)
{
    <<[[nameimage()]] body>>
}
@
% if [[in]] is true then image published, otherwise name removed (out)

<<function namedimage>>=
Image*
namedimage(Display *d, char *name)
{
    <<[[namedimage()]] body>>
}
@



\subsection{Marshalling}

<<[[nameimage()]] body>>=
byte *a;
int n;

n = strlen(name);
// name an image: 'N' dstid[4] in[1] j[1] name[j]
a = bufimage(i->display, 1+4+1+1+n);
<<[[nameimage()]] sanity check a>>
a[0] = 'N';
BPLONG(a+1, i->id);
a[5] = in;
a[6] = n;
memmove(a+7, name, n);

if(flushimage(i->display, false) < 0)
    return ERROR_0;
return OK_1;
@

<<[[nameimage()]] sanity check a>>=
if(a == nil)
    return 0;
@




<<[[namedimage()]] body>>=
byte *a;
char *err = nil;
char buf[12*12+1]; // NINFO+1
Image *i = nil;
int id, n;
ulong chan;

n = strlen(name);
<<[[namedimage()]] sanity check n>>
/* flush pending data so we don't get error allocating the image */
flushimage(d, false);

// attach to a named image: 'n' dstid[4] j[1] name[j]
a = bufimage(d, 1+4+1+n);
<<[[namedimage()]] sanity check a>>

d->imageid++;
id = d->imageid;

a[0] = 'n';
BPLONG(a+1, id);
a[5] = n;
memmove(a+6, name, n);

if(flushimage(d, false) < 0)
    goto Error;

if(pread(d->ctlfd, buf, sizeof buf, 0) < 12*12)
    goto Error;
buf[12*12] = '\0';

i = malloc(sizeof(Image));
<<[[namedimage()]] sanity check i>>

i->display = d;
i->id = id;
chan=strtochan(buf+2*12);
<<[[namedimage()]] sanity check chan>>
i->chan = chan;
i->depth = chantodepth(chan);
i->repl = atoi(buf+3*12);
i->r.min.x = atoi(buf+4*12);
i->r.min.y = atoi(buf+5*12);
i->r.max.x = atoi(buf+6*12);
i->r.max.y = atoi(buf+7*12);
i->clipr.min.x = atoi(buf+8*12);
i->clipr.min.y = atoi(buf+9*12);
i->clipr.max.x = atoi(buf+10*12);
i->clipr.max.y = atoi(buf+11*12);

i->screen = nil;
i->next = nil;

return i;
@

% similar to initdisplay, read /dev/draw/x/ctl again to get all info

<<[[namedimage()]] sanity check n>>=
if(n >= 256){
    err = "name too long";
Error:
    if(err)
        werrstr("namedimage: %s", err);
    else
        werrstr("namedimage: %r");
    if(i)
        free(i);
    return nil;
}
@

<<[[namedimage()]] sanity check a>>=
if(a == nil)
    goto Error;
@

<<[[namedimage()]] sanity check i>>=
if(i == nil){
Error1:
    a = bufimage(d, 1+4);
    if(a){
        a[0] = 'f';
        BPLONG(a+1, id);
        flushimage(d, false);
    }
    goto Error;
}
@

<<[[namedimage()]] sanity check chan>>=
if(chan == 0){
    werrstr("bad channel '%.12s' from devdraw", buf+2*12);
    goto Error1;
}
@

\subsection{Unmarshalling}

<<[[drawmesg()]] locals>>=
int c, j;
DImage *di;
DName *dn;
@

<<[[drawmesg()]] cases>>=
/* name an image: 'N' dstid[4] in[1] j[1] name[j] */
case 'N':
    printmesg(fmt="Lbz", a, false);
    m = 1+4+1+1;
     <<[[drawmesg()]] sanity check n with m>>
    c = a[5];
    j = a[6];
     <<[[drawmesg()]] name an image case, sanity check j>>
    m += j;
     <<[[drawmesg()]] sanity check n with m>>

    di = drawlookup(client, BGLONG(a+1), false);
    <<[[drawmesg()]] name an image case, sanity check di>>

    if(c)
        drawaddname(client, di, j, (char*)a+7); // The call
    else{
        dn = drawlookupname(j, (char*)a+7);
        <<[[drawmesg()]] name an image case, sanity check dn>>
        drawdelname(dn);
    }
    continue;
@

<<[[drawmesg()]] name an image case, sanity check j>>=
if(j == 0)  /* give me a non-empty name please */
    error(Eshortdraw);
@

<<[[drawmesg()]] name an image case, sanity check di>>=
if(di == nil)
    error(Enodrawimage);
if(di->name)
    error(Enamed);
@

<<[[drawmesg()]] name an image case, sanity check dn>>=
if(dn == nil)
    error(Enoname);
if(dn->dimage != di)
    error(Ewrongname);
@

<<[[drawmesg()]] cases>>=
/* attach to a named image: 'n' dstid[4] j[1] name[j] */
case 'n':
    printmesg(fmt="Lz", a, false);
    m = 1+4+1;
    <<[[drawmesg()]] sanity check n with m>>
    j = a[5];
    <<[[drawmesg()]] name an image case, sanity check j>>
    m += j;
    <<[[drawmesg()]] sanity check n with m>>
    dstid = BGLONG(a+1);

    if(drawlookup(client, dstid, false))
        error(Eimageexists);

    dn = drawlookupname(j, (char*)a+6); // The call
     <<[[drawmesg()]] attach to an image case, sanity check dn>>
    // create new DImage with shared underlying Memimage of dn
    if(drawinstall(client, dstid, dn->dimage->image, nil) == 0)
        error(Edrawmem);
    di = drawlookup(client, dstid, false);
    <<[[drawmesg()]] attach to an image case, sanity check di>>

    <<[[drawmesg()]] attach to an image case, set di name fields using dn>>

    // for further read on /dev/draw/x/ctl
    client->infoid = dstid;
    continue;
@
% infoid! so further read of /dev/draw/x/ctl will get info about namedimage

<<[[drawmesg()]] attach to an image case, sanity check dn>>=
if(dn == nil)
    error(Enoname);
@

<<[[drawmesg()]] attach to an image case, sanity check di>>=
if(di == nil)
    error("draw: cannot happen");
@

\subsection{Algorithm}
% and [[DName]]

% drawlookup seen before, return DImage given a client and id.

<<[[KDraw]] other fields>>=
// growing_array<DName>, size = KDraw.nname
DName*  name;
int     nname;
@
\l a hash from name to (Client x Dimage) would be better maybe? scales better.

<<struct DName>>=
struct DName
{
    // key
    char        *name;

    // value
    Client      *client; // the owner
    DImage*     dimage;
    <<[[DName]] other fields>>
};
@
% ctor = ???

% drawmesg(find a named image, or out a named image) -> <>
<<function drawlookupname>>=
DName*
drawlookupname(int n, char *str)
{
    DName *name, *ename;

    name = sdraw.name;
    ename = &name[sdraw.nname];
    for(; name<ename; name++)
        if(drawcmp(name->name, str, n) == 0)
            return name;
    return nil;
}
@
\l should reverse parameter, more consistent

<<function drawcmp>>=
static
int
drawcmp(char *a, char *b, int n)
{
    if(strlen(a) != n)
        return 1;
    return memcmp(a, b, n);
}
@





<<function drawaddname>>=
void
drawaddname(Client *client, DImage *di, int n, char *str)
{
    DName *name, *ename, *new, *t;

    name = sdraw.name;
    ename = &name[sdraw.nname];
    for(; name<ename; name++)
        if(drawcmp(name->name, str, n) == 0)
            error(Enameused);

    // grow array
    <<[[drawaddname()]] grow array by 1 element>>

    new = &sdraw.name[sdraw.nname++];
    new->name = smalloc(n+1);
    memmove(new->name, str, n);
    new->name[n] = '\0';

    new->dimage = di;
    new->client = client;

    new->vers = ++sdraw.vers;
}
@

<<[[drawaddname()]] grow array by 1 element>>=
t = smalloc((sdraw.nname+1)*sizeof(DName));
memmove(t, sdraw.name, sdraw.nname*sizeof(DName));
free(sdraw.name);
sdraw.name = t;
@

%dtor
<<function drawdelname>>=
void
drawdelname(DName *name)
{
    int i;

    i =  name - sdraw.name;
    memmove(name, name+1, (sdraw.nname-(i+1))*sizeof(DName));
    sdraw.nname--;
}
@



<<[[DImage]] other fields>>=
// option<string>, Some when DImage derives from a named image
char    *name;
// option<ref<DImage>>
DImage*     fromname;   /* image this one is derived from, by name */
@
\l mv earlier in section?

<<[[drawmesg()]] attach to an image case, set di name fields using dn>>=
di->name = smalloc(j+1);
memmove(di->name, a+6, j);
di->name[j] = '\0';
di->fromname = dn->dimage;
di->fromname->ref++;
di->vers = dn->vers;
@


% we gonna share images between clients so need owner, need
% versioning, etc to keep things in sync.
\l really? need vers?

<<[[KDraw]] other fields>>=
int     vers;
@
<<[[DName]] other fields>>=
int     vers;
@
<<[[DImage]] other fields>>=
int     vers;
@
% used by drawgoodname() (used itself by??)




<<[[drawmesg()]] clipping case, sanity check ddst>>=
if(ddst->name)
    error("cannot change repl/clipr of shared image");
@
% first level of security?


<<[[drawclose()]] free names>>=
/* free names */
for(i=0; i<sdraw.nname; )
    if(sdraw.name[i].client == cl)
        drawdelname(sdraw.name+i);
    else
        i++;
@


<<[[drawfreedimage()]] free names>>=
/* any names? */
for(i=0; i<sdraw.nname; )
    if(sdraw.name[i].dimage == dimage)
        drawdelname(sdraw.name+i);
    else
        i++;

if(dimage->fromname){   /* acquired by name; owned by someone else*/
    drawfreedimage(dimage->fromname);
    goto Return;
}
@
% what about other clients of dimage? no, ref is 0 when we are here.





% -> <>
<<function drawgoodname>>=
bool
drawgoodname(DImage *d)
{
    DName *n;

    <<[[drawgoodname()]] if DImage [[d]] is a window>>

    if(d->name == nil)
        return true;
    n = drawlookupname(strlen(d->name), d->name);
    if(n == nil || n->vers != d->vers)
        return false;
    return true;
}
@
% but who increments vers? nobody.
\t rename> draw_stillvalidname? 

% drawlookup seen before, return DImage given a client and id.

<<[[drawlookup()]] if checkname>>=
if(checkname && !drawgoodname(d))
    error(Eoldname);
@
% when drawlookup with checkname = true?




\chapter{Drawing Rectangles}

%\section{[[Point]] and [[Rectangle]]} types in core DS.

% Drawing a "rectangle" is actually a fundamental op. 
% Rectangle can represent an area. Can set/unset/copy/blend 
%  pixels from one area of one  image to another image.
% No need complex algo, horiz and vert lines map well to pixels.
% No need complex shape algorithm, just move all the bytes covering a rectangle.
% In fact it is the basis used by other shape algorithms.

% But operations is actually quite complicated still.

\section{[[draw()]]}

% draw() is fundamental op!
% very flexible.
% normally should be simple but made complicated because of possible
%  complex source, mask, replication, translation, optimisations, 
%  image formats, etc.

% Can have very fancy things done easily (e.g. gradient, tiling, transluscent)
%  but very simple things like drawing a rectangle with one color are
%  forced to use an API a bit more complicated than what it should.

%show toy program and screenshot of the rectangle!
% maybe with very simple draw(dst, Rect(10,10, 20,20), Black, nil, ZR);

%less: put technicolor.ps slides with draw (of actual images like in racket)?
% (meh, technicolors.ps not that good actually)

% see bibio/cs-history/pike84bitblt.pdf, history bitblt() from the Alto
% and Blit. History and implementation. Inventor = Dan Ingalls Diana Merry

\subsection{API}

<<function draw>>=
void
draw(Image *dst, Rectangle r, Image *src, Image *mask, Point p1)
{
    draw1(dst, &r, src, &p1, mask, &p1, SoverD);
}
@
% SoverD Source Over Destination, classic
% see plan9-in-technicolor.ps! bitblt and porter-diff compositing algebra

% FIGURE with meaning of p1, r, vs src, mask, and dst.
% r is rectangle in dst (if not it's clipped anyway).
% p1 is point in src (or mask), which where things will start.
% it will correspond to r.min.
% See draw(2) to understand the complex semantic with repl and clipr.

% For very simple cases src is just a color (and so replicated) 
%  and p1 does not really matter.
% Then can do simple case where dst and src starts at 0,0
%  and then can alter a bit r and p1.
% src can also be a tile in which case p1 matters too.


<<function drawop>>=
void
drawop(Image *dst, Rectangle r, Image *src, Image *mask, Point p1, Drawop op)
{
    draw1(dst, &r, src, &p1, mask, &p1, op);
}
@

% actually this is the one mentionned in the technicolor.ps slides
<<function gendraw>>=
void
gendraw(Image *dst, Rectangle r, Image *src, Point p0, Image *mask, Point p1)
{
    draw1(dst, &r, src, &p0, mask, &p1, SoverD);
}
@

<<function gendrawop>>=
void
gendrawop(Image *dst, Rectangle r, Image *src, Point p0, Image *mask, Point p1, Drawop op)
{
    draw1(dst, &r, src, &p0, mask, &p1, op);
}
@





% images are colors! with repl set to true and rect to just 1.
% e.g. Display->black. See toy app.

<<function border>>=
void
border(Image *im, Rectangle r, int i, Image *color, Point sp)
{
    <<[[border()]] if negative i, border goes outside>>
    // horizontal bars
    draw(im, Rect(r.min.x, r.min.y,   r.max.x, r.min.y+i),
        color, nil, sp);
    draw(im, Rect(r.min.x, r.max.y-i,   r.max.x, r.max.y),
        color, nil, Pt(sp.x, sp.y+Dy(r)-i));
    // vertical bars
    draw(im, Rect(r.min.x, r.min.y+i,   r.min.x+i, r.max.y-i),
        color, nil, Pt(sp.x, sp.y+i));
    draw(im, Rect(r.max.x-i, r.min.y+i,   r.max.x, r.max.y-i),
        color, nil, Pt(sp.x+Dx(r)-i, sp.y+i));
}
@
% outline of a rectangle. if i positive the border goes inside, if
% negative outside.

% FIGURE with each stripe.
% subtle is the sp translation. For now ignore.

<<[[border()]] if negative i, border goes outside>>=
if(i < 0){
    r = insetrect(r, i);
    sp = addpt(sp, Pt(i,i));
    i = -i;
}
@

<<function insetrect>>=
Rectangle
insetrect(Rectangle r, int n)
{
    r.min.x += n;
    r.min.y += n;
    r.max.x -= n;
    r.max.y -= n;
    return r;
}
@
% enlarge rectangle when n is negative. reduce if positive.






\subsection{Marshalling}

<<function draw1>>=
static void
draw1(Image *dst, Rectangle *r, Image *src, Point *p0, Image *mask, Point *p1, Drawop op)
{
    byte *a;

    _setdrawop(dst->display, op);

    // draw: 'd' dstid[4] srcid[4] maskid[4] R[4*4] P[2*4] P[2*4]
    a = bufimage(dst->display, 1+4+4+4+4*4+2*4+2*4);
    <<[[draw1()]] sanity check a>>
    <<[[draw1()]] sanity check src and mask>>
    a[0] = 'd';
    BPLONG(a+1, dst->id);
    BPLONG(a+5, src->id);
    BPLONG(a+9, mask->id);
    BPLONG(a+13, r->min.x);
    BPLONG(a+17, r->min.y);
    BPLONG(a+21, r->max.x);
    BPLONG(a+25, r->max.y);
    BPLONG(a+29, p0->x);
    BPLONG(a+33, p0->y);
    BPLONG(a+37, p1->x);
    BPLONG(a+41, p1->y);
}
@
\l why not _draw? be more consistent

% communicate juste id! efficient network wise!
% if want color then need different image each time! (or have
% image with all colors and pass the right sp?)

<<function _setdrawop>>=
void
_setdrawop(Display *d, Drawop op)
{
    uchar *a;

    if(op != SoverD){
        a = bufimage(d, 1+1);
        <<[[_setdrawop()]] sanity check a>>
        a[0] = 'O';
        a[1] = op;
    }
}
@
% most op are SoverD hence this opti and the default
%  setting back to SoverD server side in drawclientop().




<<[[draw1()]] sanity check a>>=
if(a == nil)
    return; // warning?
@

<<[[_setdrawop()]] sanity check a>>=
if(a == nil)
    return; // warning?
@

<<[[draw1()]] sanity check src and mask>>=
if(src == nil)
    src = dst->display->black;
if(mask == nil)
    mask = dst->display->opaque;
@

\subsection{Unmarshalling}

<<[[drawmesg()]] locals>>=
Memimage *src, *mask;
Point p, q;
// enum<Drawop>
int op;
@

<<[[drawmesg()]] cases>>=
/* draw: 'd' dstid[4] srcid[4] maskid[4] R[4*4] P[2*4] P[2*4] */
case 'd':
    printmesg(fmt="LLLRPP", a, false);
    m = 1+4+4+4+4*4+2*4+2*4;
    <<[[drawmesg()]] sanity check n with m>>
    dstid = BGLONG(a+1);
    dst = drawimage(client, a+1);
    src = drawimage(client, a+5);
    mask = drawimage(client, a+9);
    drawrectangle(&r, a+13);
    drawpoint(&p, a+29);
    drawpoint(&q, a+37);

    op = drawclientop(client);
    memdraw(dst, r, src, p, mask, q, op); // the call!

    dstflush(dstid, dst, r);
    continue;
@
% dstflush!

<<function drawpoint>>=
void
drawpoint(Point *p, uchar *a)
{
    p->x = BGLONG(a+0*4);
    p->y = BGLONG(a+1*4);
}
@


% from image id to Memimage through intermediate DImage.
<<function drawimage>>=
Memimage*
drawimage(Client *client, byte *a)
{
    DImage *d;

    d = drawlookup(client, BGLONG(a), true);
    <<[[drawimage()]] sanity check d>>
    return d->image;
}
@


<<[[drawimage()]] sanity check d>>=
if(d == nil)
    error(Enodrawimage);
@







<<function drawclientop>>=
static int
drawclientop(Client *cl)
{
    int op;

    op = cl->op;
    cl->op = SoverD;
    return op;
}
@
% reset drawop to default value?

<<[[drawmesg()]] cases>>=
/* set compositing operator for next draw operation: 'O' op */
case 'O':
    printmesg(fmt="b", a, false);
    m = 1+1;
    <<[[drawmesg()]] sanity check n with m>>
    client->op = a[1];
    continue;
@





%dead: not even mentionned in the draw(5) and nothing generate such a message
% <<[[drawmesg()]] cases>>=
% /* create image mask: 'm' newid[4] id[4] */
% case 'm':
%     printmesg("LL", a, false);
%     m = 4+4;
%     if(n < m)
%         error(Eshortdraw);
%     break;
% @


\subsection{Algorithm}

% quite complicated, many usecases, many wrappers, many layers, many formats,
%  many optis.
% draw() is very flexible and so it is quite complicated to implement.
% So we will simplify and show simple and general path first.

\subsubsection{[[memdraw()]]}

% actually in memlayer/
<<function memdraw>>=
void
memdraw(Memimage *dst, Rectangle r, Memimage *src, Point p0, Memimage *mask, Point p1, int op)
{
    <<[[memdraw()]] locals>>

    DBG("memdraw %p %R %p %P %p %P\n", dst, r, src, p0, mask, p1);
    <<[[memdraw()]] sanity check mask>>

    <<[[memdraw()]] if mask has layer>>
    Top:
    if(dst->layer == nil && src->layer == nil){
        memimagedraw(dst, r, src, p0, mask, p1, op); // back to memdraw
        return;
    }
    <<[[memdraw()]] when have layers>>
}
@

% wrapper, more complex when have layers/windows, see chapter X.

<<[[memdraw()]] sanity check mask>>=
if(mask == nil)
    mask = memopaque;
@
% already done client side though, and drawimage make sure
%  maskid is valid, so this should never happen when called from
%  drawmesg().

\subsubsection{[[Memdrawparam]]}

% technicolor.ps! see draw()
<<struct Memdrawparam>>=
struct	Memdrawparam
{
    Memimage *dst;
    Rectangle	r;

    Memimage *src;
    Rectangle sr;

    Memimage *mask;
    Rectangle mr;

    // enum<Drawop>
    int op;

    <<[[Memdrawparam]] other fields>>
};
@
% all rectangles should have same size.
% put in special struct cos gonna pass it down a lot, to many
% functions.

\subsubsection{[[memimagedraw()]]}

% back to memdraw/
<<function memimagedraw>>=
void
memimagedraw(Memimage *dst, Rectangle r, Memimage *src, Point p0, Memimage *mask, Point p1, int op)
{
    Memdrawparam par;

    DBG1("memimagedraw %p/%luX %R @ %p %p/%luX %P %p/%luX %P... ", dst, dst->chan, r, dst->data->bdata, src, src->chan, p0, mask, mask->chan, p1);
    <<[[memdraw()]] sanity check mask>>
    <<[[memimagedraw()]] sanity check op>>

    // Clipping
    <<[[memimagedraw()]] call drawclip, if empty rectangle return>>

    par.op = op;
    par.dst = dst;
    par.r = r;
    par.src = src;
    par.mask = mask;
    /* par.sr set by drawclip */
    /* par.mr set by drawclip */

    // Replicating (and adjust par.state)
    par.state = 0;
    <<[[memimagedraw()]] if src is repl>>
    <<[[memimagedraw()]] if mask is repl>>

    DBG1("dr %R sr %R mr %R...", r, par.sr, par.mr);
    DBG1("draw dr %R sr %R mr %R %lux\n", r, par.sr, par.mr, par.state);

    // Optimizing
    /*
     * Now that we've clipped the parameters down to be consistent, we 
     * simply try sub-drawing routines in order until we find one that was able
     * to handle us.  If the sub-drawing routine returns zero, it means it was
     * unable to satisfy the request, so we do not return.
     */
    <<[[memimagedraw()]] try hwdraw>>
    <<[[memimagedraw()]] try memoptdraw>>
    <<[[memimagedraw()]] try chardraw>>
    // else

    // Compositing
    /*
     * General calculation-laden case that does alpha for each pixel.
     */
    alphadraw(&par);
    DBG("alphadraw handled\n");
}
@
%dead:
% static int n = 0;
%old: argh, was ugly debugging code, I improved a bit by using DBG1 macro
%    DBG1("test hwdraw\n");
%    DBG1("test memoptdraw\n");
%    DBG1("test chardraw\n");
%    DBG1("do alphadraw\n");


<<[[memimagedraw()]] sanity check op>>=
if(op < Clear || op > SoverD){
    DBG1("op out of range: %d\n", op);
    return;
}
@

% will see clipping, replicating, and memoptdraw and alphadraw in next sections


\subsection{Hardware support hook}

% but really optional, bcm/screen.c does nothing except
% calling the software cursor save/restore.

% maybe assume simple screen device, like for raspberry,
% and where it's actually a framebuffer where hwdraw does nothing
% except the software cursor stuff.


<<[[memimagedraw()]] try hwdraw>>=
/*
 * Hardware support.  Each video driver provides this function,
 * which checks to see if there is anything it can help with.
 * There could be an if around this checking to see if dst is in video memory.
 */
if(hwdraw(&par)){
    DBG1("hwdraw handled\n");
    return;
}
@

% vgascreen.c
<<global hwaccel(x86)>>=
bool hwaccel = true;
@

% vgascreen.c
<<function hwdraw(x86)>>=
//@Scheck: not dead, actually this is overriding some def in libmemdraw!! ugly
bool hwdraw(Memdrawparam *par)
{
    VGAscr *scr;
    Memimage *dst, *src, *mask;
    int m;

    if(!hwaccel)
        return false;

    scr = &vgascreen;

    dst=par->dst;
    src=par->src;
    mask=par->mask;
    <<[[hwdraw()]] sanity check parameters>>

    <<[[hwdraw()]] if software cursor(x86)>>
    
    if(dst->data->bdata != gscreendata.bdata)
        return false;
    // else
    <<[[hwdraw()]] when dst is the screen>>
}
@

% when dst is screen see Optimisations section in Advanced topics chapter.


<<[[hwdraw()]] sanity check parameters>>=
if(dst == nil || dst->data == nil)
    return false;
if(src == nil || src->data == nil)
    return false;
if(mask == nil || mask->data == nil)
    return false;
@


\section{Clipping}
% part1, because alphadraw does another final clipping.

% saw rectclip() before which will be used heavily below in drawclip().

% see draw(2) and explanation of draw() to understand
%  what clipping is done. Quite long description actually.

\subsection{[[drawclip()]]}

<<[[memimagedraw()]] call drawclip, if empty rectangle return>>=
if(!drawclip(dst, &r, src, &p0, mask, &p1,   &par.sr, &par.mr)){
    DBG1("empty clipped rectangle\n");
    return;
}
@
% will adjust source and mask rectangle sr and mr.
% they will all have the same size but start at the right place,
%  see the assert below.


% FIGURE! where see different coordinate system


% memimagedraw | ?? -> <>
<<function drawclip>>=
/*
 * Clip the destination rectangle further based on the properties of the 
 * source and mask rectangles.  Once the destination rectangle is properly
 * clipped, adjust the source and mask rectangles to be the same size.
 * Then if source or mask is replicated, move its clipped rectangle
 * so that its minimum point falls within the repl rectangle.
 *
 * Return zero if the final rectangle is null.
 */
bool
drawclip(Memimage *dst, Rectangle *r, Memimage *src, Point *p0, Memimage *mask, Point *p1,   Rectangle *sr, Rectangle *mr)
{
    Point rmin = r->min; // save old min
    <<[[drawclip()]] other locals>>

    // empty rectangle? nothing to do then.
    if(r->min.x >= r->max.x || r->min.y >= r->max.y)
        return false;

    <<[[drawclip()]] clipping to destination>>
    <<[[drawclip()]] clipping to source>>
    <<[[drawclip()]] clipping to mask>>

    /* move source clipping back to destination */
    <<[[drawclip()]] adjust r if sr or mr changed>>

    <<[[drawclip()]] clipping and replication handling>>

    assert(Dx(*sr) == Dx(*mr) && Dx(*mr) == Dx(*r));
    assert(Dy(*sr) == Dy(*mr) && Dy(*mr) == Dy(*r));
    assert(ptinrect(*p0, src->r));
    assert(ptinrect(*p1, mask->r));
    assert(ptinrect(r->min, dst->r));

    return true;
}
@

% note that now r, sr, mr have the same size and translated to right place.
% but actually sr and mr might be too big because src and mask could
% be replicated and smaller than that. This is why there will be
% further code later about replicating and clipping.



\subsection{Clipping to destination}

<<[[drawclip()]] clipping to destination>>=
/* clip to destination */ // can modify r
if(!rectclip(r, dst->r) || !rectclip(r, dst->clipr))
    return false;
<<[[drawclip()]] adjust p0 and p1 if r changed>>
@
% note that no repl to handle here. repl has a meaning only when
%  the image is used as a source, to tile and replicate.


% when rectangle r got actually reduced because of dst->clipr or dst->r
%  then p0 and p1 must be adjusted
<<[[drawclip()]] adjust p0 and p1 if r changed>>=
/* move source point */
// p0 = addpt(p0, subpb(r->min, rmin))
p0->x += r->min.x - rmin.x;
p0->y += r->min.y - rmin.y;
/* move mask point */
// p1 = addpt(p1, subpb(r->min, rmin))
p1->x += r->min.x - rmin.x;
p1->y += r->min.y - rmin.y;
@


\subsection{Clipping to source}

<<[[drawclip()]] clipping to source>>=
/* map destination rectangle into source */
sr->min = *p0;
sr->max.x = p0->x+Dx(*r);
sr->max.y = p0->y+Dy(*r);

/* sr is r in source coordinates; clip to source */ // can modify sr
if(!(src->flags&Frepl) && !rectclip(sr, src->r))
    return false;
if(!rectclip(sr, src->clipr))
    return false;
@
% sr is r translated to p0.

<<[[drawclip()]] other locals>>=
Point delta;
@
% r = sr translated back from p0

% when source or mask actually reduces even more rectangle
<<[[drawclip()]] adjust r if sr or mr changed>>=
delta.x = r->min.x - p0->x;
delta.y = r->min.y - p0->y;
// r = rectaddpt(sr, delta)
r->min.x = sr->min.x + delta.x;
r->min.y = sr->min.y + delta.y;
r->max.x = sr->max.x + delta.x;
r->max.y = sr->max.y + delta.y;
@


\subsection{Clipping to mask}


<<[[drawclip()]] clipping to mask>>=
/* compute and clip rectangle in mask */
<<[[drawclip()]] if splitcoords>>
else{
    if(!(mask->flags&Frepl) && !rectclip(sr, mask->r)) // can modify sr
        return false;
    if(!rectclip(sr, mask->clipr))
        return false;
    *p1 = sr->min;
}
@
% new p1


<<[[drawclip()]] other locals>>=
bool splitcoords = (p0->x != p1->x) || (p0->y != p1->y);
@

<<[[drawclip()]] other locals>>=
Rectangle omr;
@
% could use delta instead

<<[[drawclip()]] if splitcoords>>=
if(splitcoords){
    /* move mask point with source */
    // p1 = addpt(p1, subpt(sr->min, p0))
    p1->x += sr->min.x - p0->x;
    p1->y += sr->min.y - p0->y;

    mr->min = *p1;
    mr->max.x = p1->x + Dx(*sr);
    mr->max.y = p1->y + Dy(*sr);
    omr = *mr;

    /* mr is now rectangle in mask; clip it */
    if(!(mask->flags&Frepl) && !rectclip(mr, mask->r))
        return false;
    if(!rectclip(mr, mask->clipr))
        return false;

    /* reflect any clips back to source */
    // sr = rectsub(mr, omr)
    sr->min.x += mr->min.x - omr.min.x;
    sr->min.y += mr->min.y - omr.min.y;
    sr->max.x += mr->max.x - omr.max.x;
    sr->max.y += mr->max.y - omr.max.y;

    *p1 = mr->min;
}
@
% new p1

\subsection{Clipping and replication}

<<[[drawclip()]] clipping and replication handling>>=
/* move source rectangle so sr->min is in src->r */
<<[[drawclip()]] if src is repl>>
/* move mask point so it is in mask->r */
<<[[drawclip()]] mask move>>
@

\subsubsection{Clipping with replicated source}

<<[[drawclip()]] if src is repl>>=
if(src->flags&Frepl) {
    delta.x = drawreplxy(src->r.min.x, src->r.max.x, sr->min.x) - sr->min.x;
    delta.y = drawreplxy(src->r.min.y, src->r.max.y, sr->min.y) - sr->min.y;
    // sr = rectaddpt(sr, delta)
    sr->min.x += delta.x;
    sr->min.y += delta.y;
    sr->max.x += delta.x;
    sr->max.y += delta.y;
}
*p0 = sr->min;
@



% drawrepl | drawclip -> <>
<<function drawreplxy>>=
int
drawreplxy(int min, int max, int x)
{
    int sx;

    sx = (x-min) % (max-min);
    if(sx < 0)
        sx += max - min;
    return sx + min;
}
@


\subsubsection{Clipping with replicated mask}

% actually no if for the mask. Why?

<<[[drawclip()]] mask move>>=
*p1 = drawrepl(mask->r, *p1);

mr->min = *p1;
mr->max.x = p1->x+Dx(*sr);
mr->max.y = p1->y+Dy(*sr);
@

% drawclip | drawmask -> <>
<<function drawrepl>>=
Point
drawrepl(Rectangle r, Point p)
{
    p.x = drawreplxy(r.min.x, r.max.x, p.x);
    p.y = drawreplxy(r.min.y, r.max.y, p.y);
    return p;
}
@



\section{Replicating}
% part1 because later in alphadraw there is another replication
%  done via some module and [[% Dy(src->r)]] and also for the mask.

% most of the code below is preparing data when have simple
% 1x1 replicated rectangles (e.g. colors).

<<enum _anon_ (include/memdraw.h)2>>=
/*
 * Encapsulated parameters and information for sub-draw routines.
 */
enum Drawparams {
    Simplesrc =1<<0, // 1x1 src
    Simplemask=1<<1, // 1x1 mask

    Replsrc =1<<2,
    Replmask=1<<3,

    Fullmask=1<<4, // fully opaque mask
};
@
% >> >> >> >> >>
% info that can be used by further memimagedraw steps, to
%  know if can run optimized version such as hwdraw/...

<<[[Memdrawparam]] other fields>>=
// enum<Drawparams>
ulong state;
@
% state is bad name. maybe props?

\subsection{Source replication}

<<[[Memdrawparam]] other fields>>=
ulong sval;		/* if Simplesrc, the source pixel in src format */
rgba  srgba;	/* sval in rgba */
ulong sdval;	/* sval in dst format */
@
% those fields will be used later in memoptdraw for some optimized draw
\l rename sdval to dval

% remember that src is repl when Image is a simple color.
<<[[memimagedraw()]] if src is repl>>=
if(src->flags&Frepl){
    par.state |= Replsrc;
    if(Dx(src->r)==1 && Dy(src->r)==1){
        par.state |= Simplesrc;
        par.sval = pixelbits(src, src->r.min);

        par.srgba = imgtorgba(src, par.sval);
        par.sdval = rgbatoimg(dst, par.srgba);

        <<[[memimagedraw()]] when src is repl, sanity check pixel value>>
    }
}
@

% src can also be repl when tiling.

% see imgtorgba and rgbatoimg in core DS chapter.

<<[[memimagedraw()]] when src is repl, sanity check pixel value>>=
if((par.srgba&0xFF) == 0 && (op&DoutS)){
    DBG1("fill with transparent source\n");
    return;	/* no-op successfully handled */
}
@
% DoutS ? note that SoverD will satisfy this.


% memimagedraw -> <>
<<function pixelbits>>=
static ulong
pixelbits(Memimage *i, Point pt)
{
    byte *p;
    ulong val = 0;
    int bpp = i->depth; // bits per pixel
    <<[[pixelbits()]] other locals>>

    p = byteaddr(i, pt);

    switch(bpp){
    <<[[pixelbits()]] switch bpp cases>>
    case 8:
        val = p[0];
        break;
    case 32:
        val = p[0]|(p[1]<<8)|(p[2]<<16)|(p[3]<<24);
        break;
    }
    <<[[pixelbits()]] duplicate byte if depth less than 32>>
    return val;
}
@
% >> >> >> >> >> >> >> >>

% duplicate byte since anyway it's a repl and it will be used in a giant
% memset

<<[[pixelbits()]] duplicate byte if depth less than 32>>=
// duplicate byte in the whole word
while(bpp<32){
    val |= val<<bpp;
    bpp *= 2;
}
@
% >>

\subsection{Mask replication}

<<[[Memdrawparam]] other fields>>=
ulong mval;		/* if Simplemask, the mask pixel in mask format */
rgba  mrgba;	/* mval in rgba */
@
% no need mdval?

% mask is repl when memopaque
<<[[memimagedraw()]] if mask is repl>>=
if(mask->flags & Frepl){
    par.state |= Replmask;
    if(Dx(mask->r)==1 && Dy(mask->r)==1){
        par.state |= Simplemask;
        par.mval = pixelbits(mask, mask->r.min);

        if(par.mval == 0 && (op&DoutS)){
            DBG1("fill with zero mask\n");
            return;	/* no-op successfully handled */
        }

        if(par.mval == ~0)
            par.state |= Fullmask;
        par.mrgba = imgtorgba(mask, par.mval);
    }
}
@



\section{Setting or copying pixels}

% kinda opti, but helps to understand alphadraw(), stepping stone.

\subsection{[[memoptdraw()]]}

<<[[memimagedraw()]] try memoptdraw>>=
/*
 * Optimizations using memmove and memset.
 */
if(memoptdraw(&par)){
    DBG1("memopt handled\n");
    return;
}
@


<<function memoptdraw>>=
static bool
memoptdraw(Memdrawparam *par)
{
    int dx, dy;
    // enum<Drawop>
    int op;
    Memimage *src, *dst;

    int m, y;
    ulong v;

    dx = Dx(par->r);
    dy = Dy(par->r);
    src = par->src;
    dst = par->dst;
    op = par->op;

    DBG1("state %lux mval %lux dd %d\n", par->state, par->mval, dst->depth);

    <<[[memoptdraw()]] if condition for memset>>
    <<[[memoptdraw()]] if condition for memmove>>
    <<[[memoptdraw()]] if 1 bit mask, src, and dest>>
    return false;	
}
@
% >>

\subsection{Setting pixels}

<<[[memoptdraw()]] if condition for memset>>=
/*
 * If we have an opaque mask and source is one opaque pixel we can
 * convert to the destination format and just replicate with memset.
 */
m = Simplesrc|Simplemask|Fullmask;
if((par->state&m)==m && 
   (par->srgba&0xFF) == 0xFF && 
   (op == S || op == SoverD)){
    byte p[4]; // source
    byte *dp;  // destination
    int dwid;
    <<[[memoptdraw()]] locals for memset case>>

    dwid = dst->width * sizeof(ulong);
    dp = byteaddr(dst, par->r.min);
    v = par->sdval;

    switch(dst->depth){
    <<[[memoptdraw()]] when condition for memset, switch depth of dst cases>>
    case 32:
        p[0] = v;		/* make little endian */
        p[1] = v>>8;
        p[2] = v>>16;
        p[3] = v>>24;
        v = *(ulong*)p;

        for(y=0; y < dy; y++, dp += dwid)
            memsetl(dp, v, dx);
        return true;
    }
}
@
%old:
%    DBG1("memopt, dst %p, dst->data->bdata %p\n", dst, dst->data->bdata);
%    DBG1("sdval %lud, depth %d\n", v, dst->depth);

% why need this little endian dance?

% so when alpha in source is 1 and have SoverD, then dst does not matter!
% indeed see the general formula later in alphacalc11

\subsection{Copying pixels}

% ok no SimpleSrc, but maybe source with no alpha so no need
% compositing.

<<[[memoptdraw()]] if condition for memmove>>=
/*
 * If no source alpha, an opaque mask, we can just copy the
 * source onto the destination.  If the channels are the same and
 * the source is not replicated, memmove suffices.
 */
m = Simplemask|Fullmask;
if((par->state&(m|Replsrc))==m && 
    src->depth >= 8 && 
    src->chan == dst->chan && 
    !(src->flags&Falpha) && 
    (op == S || op == SoverD)){

    byte *sp, *dp;
    long swid, dwid;
    long nb;
    int dir = 1;

    <<[[memoptdraw()]] when condition for memmove, change possibly dir>>

    swid = src->width * sizeof(ulong);
    dwid = dst->width * sizeof(ulong);
    sp = byteaddr(src, par->sr.min);
    dp = byteaddr(dst, par->r.min);
    <<[[memoptdraw()]] when condition for memmove, if negative dir>>
    nb = (dx * src->depth)/8;
    for(y=0; y<dy; y++, sp+=swid, dp+=dwid)
        memmove(dp, sp, nb);
    return true;
}
@

% remember than memmove handle some overlap. But it will not
%  handle all overlap hence dir adjustment below.

<<[[memoptdraw()]] when condition for memmove, change possibly dir>>=
if(src->data == dst->data && 
   byteaddr(dst, par->r.min) > byteaddr(src, par->sr.min))
    dir = -1;
@

<<[[memoptdraw()]] when condition for memmove, if negative dir>>=
if(dir == -1){
    sp += (dy-1)*swid;
    dp += (dy-1)*dwid;
    swid = -swid;
    dwid = -dwid;
}
@
% start from the end



\section{Compositing pixels}

% The general case. Compositing! advanced effects such as transluscent.
% But also advanced shape clipping, tiling, etc.

%https://en.wikipedia.org/wiki/Alpha_compositing

\subsection{[[alphadraw()]]}

\t can write simple version when dst and src have simple and
\t  same chan format? like RGBA32?


<<[[alphadraw()]] locals>>=
Memimage *src, *mask, *dst;
Rectangle r, sr, mr;
int dx, dy;
// enum<Drawop>
int op;
@

<<[[alphadraw()]] locals>>=
bool isgrey;
@

<<[[alphadraw()]] locals>>=
Readfn *rdsrc, *rdmask, *rddst;
Calcfn *calc;
Writefn *wrdst;
@
% we will see soon the type of those functions.

<<[[alphadraw()]] locals>>=
Buffer bsrc, bdst, bmask;
@
% a full line, will see soon Buffer.

% iterate over lines, each time get a line of the rectangle.
<<[[alphadraw()]] locals>>=
int starty, endy;
int dsty, srcy, masky;
int dir;
int y; // iteration variable, we iterate over lines
@



<<function alphadraw>>=
/*
 * For each scan line, we expand the pixels from source, mask, and destination
 * into byte-aligned red, green, blue, alpha, and grey channels.  If buffering
 * is not needed and the channels were already byte-aligned 
 * (grey8, rgb24, rgba32, rgb32),
 * the readers need not copy the data: they can simply return pointers to the
 * data.
 * If the destination image is grey and the source is not, it is converted
 * using the NTSC formula.
 *
 * Once we have all the channels, we call either rgbcalc or greycalc, 
 * depending on whether the destination image is color.  This is allowed to
 * overwrite the dst buffer (perhaps the actual data, perhaps a copy) with 
 * its result.  It should only overwrite the dst buffer
 * with the same format (i.e. red bytes with red bytes, etc.)  A new buffer
 * is returned from the calculator, and that buffer is passed to a function 
 * to write it to the destination.
 * If the buffer is already pointing at the destination, the writing function 
 * is a no-op.
 */
static int
alphadraw(Memdrawparam *par)
{
    <<[[alphadraw()]] locals>>

    r = par->r;
    dx = Dx(r);
    dy = Dy(r);
    src = par->src;
    mask = par->mask;	
    dst = par->dst;
    sr = par->sr;
    mr = par->mr;
    op = par->op;

    starty = 0;
    endy = dy;
    dir = 1;

    isgrey = dst->flags&Fgrey;
    <<[[alphadraw()]] set needbuf and possibly adjust starty and endy>>

    <<[[alphadraw()]] set Dbuf z part1>>

    <<[[alphadraw()]] if source has no alpha and simple bit mask>>
    else{
        /* usual alphadraw parameter fetching */
        rdsrc = readfn(src);
        rddst = readfn(dst);
        wrdst = writefn(dst);
        calc = alphacalc[op];
        <<[[alphadraw()]] set rdmask>>
    }

    <<[[alphadraw()]] when small repl rectangle optimization>>
    <<[[alphadraw()]] set Dbuf z part2>>

    <<[[alphadraw()]] setting srcy, masky, and dsty, and clipping part1>>
    assert(0 <= srcy  && srcy  < Dy(src->r));
    assert(0 <= masky && masky < Dy(mask->r));
    assert(0 <= dsty  && dsty  < Dy(dst->r));

    // the big loop!
    for(y=starty; y!=endy; y+=dir, srcy+=dir, masky+=dir, dsty+=dir){
        <<[[alphadraw()]] clipping part2>>

        bsrc  = rdsrc (&z->spar, z->spar.bufbase, srcy);
        bmask = rdmask(&z->mpar, z->mpar.bufbase, masky);
        bdst  = rddst (&z->dpar, z->dpar.bufbase, dsty);

        // !!The calc dispatch!!
        bdst = calc(bdst, bsrc, bmask, dx, isgrey, op);
        wrdst(&z->dpar, z->dpar.bytermin + dsty * z->dpar.bwidth, bdst);
    }
    <<[[alphadraw()]] free z>>
    return 1;
}
@
\l return value seems unused so void instead?
%pad: I reordered some statements, put them closer to each other sometimes

% % Dy cos of the tiling and replication!

\subsection{Buffering}

<<[[alphadraw()]] locals>>=
bool needbuf;
@

<<[[alphadraw()]] set needbuf and possibly adjust starty and endy>>=
/*
 * Buffering when src and dst are the same bitmap is sufficient but not 
 * necessary.  There are stronger conditions we could use.  We could
 * check to see if the rectangles intersect, and if simply moving in the
 * correct y direction can avoid the need to buffer.
 */
needbuf = (src->data == dst->data);

if (needbuf && byteaddr(dst, r.min) > byteaddr(src, sr.min)) {
    dir = -1;
    starty = dy-1;
    endy = -1;
}
@
%old: code was a bit different, I added the dir = 1; before
% to be able to aspectize this code.

% later will need to take care and use memmove

\subsection{Clipping and replicating}
% part2

<<[[alphadraw()]] setting srcy, masky, and dsty, and clipping part1>>=
/*
 * srcy, masky, and dsty are offsets from the top of their
 * respective Rectangles.  they need to be contained within
 * the rectangles, so clipy can keep them there without division.
 */
srcy  = (starty + sr.min.y - src->r.min.y)  % Dy(src->r);
masky = (starty + mr.min.y - mask->r.min.y) % Dy(mask->r);
dsty  =  starty + r.min.y  - dst->r.min.y;
@
% use modulo, a bit slow, but does not matter cos outside the loop.

% need modulo because sr mr are the same size than r, even if
%  src and mask are actually smaller and replicated.


<<[[alphadraw()]] clipping part2>>=
clipy(src, &srcy);
clipy(dst, &dsty);
clipy(mask, &masky);
@

% modulo without division or modulo.
<<function clipy>>=
static void
clipy(Memimage *img, int *y)
{
    int dy;

    // *y = *y % Dy(img->r)

    dy = Dy(img->r);
    if(*y == dy)
        *y = 0;
    else if(*y == -1)
        *y = dy-1;
    assert(0 <= *y && *y < dy);
}
@
% when have small tile for source or mask, need to keep it in range,
% do a modulo, which is what is done here




\subsection{Additional data structures}

\subsubsection{[[Dbuf]]}

<<struct Dbuf>>=
struct Dbuf
{
    Param spar, mpar, dpar;
    // array<byte> (length = Dbuf.n)
    byte *p;
    int n;
    <<[[Dbuf]] other fields>>
};
@
% will see Param below

% allocation

<<[[alphadraw()]] locals>>=
Dbuf *z;
@
% will hold buffers containing one line, which might be needed.

<<[[alphadraw()]] set Dbuf z part1>>=
z = allocdbuf();
<<[[alphadraw()]] sanity check z>>
<<[[alphadraw()]] set z params part1>>
@





<<global dbuf>>=
static Dbuf dbuf[10];
@

<<function allocdbuf>>=
static Dbuf*
allocdbuf(void)
{
    int i;

    for(i=0; i<nelem(dbuf); i++){
        if(dbuf[i].inuse)
            continue;
        if(!_tas(&dbuf[i].inuse))
            return &dbuf[i];
    }
    return nil;
}
@
% _tas! mutual exclusion, will set it to true.

<<[[Dbuf]] other fields>>=
bool inuse;
@

<<[[alphadraw()]] free z>>=
z->inuse = false;
@





% buffer allocation


<<[[alphadraw()]] locals>>=
byte *drawbuf;
int ndrawbuf;
@
% ndrawbuf modified later

<<[[alphadraw()]] set Dbuf z part2>>=
<<[[alphadraw()]] grow drawbuf if needed>>
drawbuf = z->p;
<<[[alphadraw()]] set z params part2>>
@

<<[[alphadraw()]] grow drawbuf if needed>>=
if(z->n < ndrawbuf){
    free(z->p);
    z->p = mallocz(ndrawbuf, 0);
    <<[[alphadraw()]] sanity check [[z->p]]>>
    z->n = ndrawbuf;
}
@



<<[[alphadraw()]] sanity check z>>=
if(z == nil)
    return 0;
@
% just return? no warning? hmm

<<[[alphadraw()]] sanity check [[z->p]]>>=
if(z->p == nil){
    z->inuse = false;
    return 0;
}
@

\subsubsection{[[ParamDraw]]}

<<struct ParamDraw>>=
/* giant rathole to customize functions with */
struct ParamDraw {

    Memimage *img;
    Rectangle	r;
    int	dx;	/* of r */ // size of a line of a rectangle in pixels
    int		bwidth; // image width in bytes

    // source bytes, always same y but x varies
    byte	*bytey0s;	/* byteaddr(Pt(img->r.min.x, img->r.min.y)) */
    byte	*bytermin;	/* byteaddr(Pt(r.min.x,      img->r.min.y)) */
    byte	*bytey0e;	/* byteaddr(Pt(img->r.max.x, img->r.min.y)) */

    bool	needbuf;
    // destination bytes
    int	bufoff;
    int	bufdelta;
    // array<byte>, (address = Dbuf.p + bufoff, length = bufdelta)
    byte	*bufbase;

    int	dir; // -1 or 1

    <<[[ParamDraw]] mask fields>>
    <<[[ParamDraw]] conversion fields>>
    <<[[ParamDraw]] replication fields>>
};
@


<<[[alphadraw()]] set z params part1>>=
ndrawbuf = 0;
getparam(&z->spar, src, sr,  isgrey, needbuf, &ndrawbuf);
getparam(&z->dpar, dst, r,   isgrey, needbuf, &ndrawbuf);
getparam(&z->mpar, mask, mr, false,  needbuf, &ndrawbuf);
z->spar.dir = z->mpar.dir = z->dpar.dir = dir;
@
% note that size of sr, r, and mr should be equal.


<<function getparam>>=
static void
getparam(Param *p, Memimage *img, Rectangle r, bool convgrey, bool needbuf, int *ndrawbuf)
{
    int nbuf;

    memset(p, 0, sizeof(Param));

    p->img = img;
    p->r = r;
    p->dx = Dx(r);
    p->needbuf = needbuf;
    p->convgrey = convgrey;

    assert(img->r.min.x <= r.min.x && r.min.x < img->r.max.x);

    p->bytey0s  = byteaddr(img, Pt(img->r.min.x, img->r.min.y));
    p->bytermin = byteaddr(img, Pt(r.min.x,      img->r.min.y));
    p->bytey0e  = byteaddr(img, Pt(img->r.max.x, img->r.min.y));

    assert(p->bytey0s <= p->bytermin && p->bytermin <= p->bytey0e);
    if(p->r.min.x == p->img->r.min.x)
        assert(p->bytermin == p->bytey0s);

    p->bwidth   = sizeof(ulong) * img->width;

    nbuf = 1;
    <<[[getparam()]] if small replicated rectangle>>

    p->bufdelta = 4 * p->dx;
    p->bufoff = *ndrawbuf;
    *ndrawbuf += p->bufdelta * nbuf;
}
@
% why augment ndrawbuf if actually no needbuf?

<<[[alphadraw()]] set z params part2>>=
/*
 * Before we were saving only offsets from drawbuf in the parameter
 * structures; now that drawbuf has been grown to accomodate us,
 * we can fill in the pointers.
 */
z->spar.bufbase = drawbuf + z->spar.bufoff;
z->mpar.bufbase = drawbuf + z->mpar.bufoff;
z->dpar.bufbase = drawbuf + z->dpar.bufoff;
@

% remember code in alphadraw then:
%        bsrc  = rdsrc (&z->spar, z->spar.bufbase, srcy);
%        bmask = rdmask(&z->mpar, z->mpar.bufbase, masky);
%        bdst  = rddst (&z->dpar, z->dpar.bufbase, dsty);


\subsubsection{[[Buffer]]}

% pointer to channel corresponding byte

<<struct Buffer>>=
struct Buffer {
    /* used by most routines */
    byte	*red;
    byte	*grn;
    byte	*blu;
    byte	*alpha; // can be &ones

    ulong	*rgba; // bad name, just start of pixel
    int	delta;	/* number of bytes to add to pointer to get next pixel to the right */

    byte	*grey;

    <<[[Buffer]] boolcalc fields>>
};
@
% delta is int so assume each pixel size is a multiple of bytes. (8, 16, ...)

%old: in alphadraw
%        DBG1("[");
%        DBG1("]\n");
%        //DBG		dumpbuf("src", bsrc, dx);
%        //DBG		dumpbuf("mask", bmask, dx);
%        //DBG		dumpbuf("dst", bdst, dx);

%dead: just used for debugging
%  <<function dumpbuf>>=
%  static void
%  dumpbuf(char *s, Buffer b, int n)
%  {
%      int i;
%      uchar *p;
%      
%      print("%s", s);
%      for(i=0; i<n; i++){
%          print(" ");
%          if(p=b.grey){
%              print(" k%.2uX", *p);
%              b.grey += b.delta;
%          }else{	
%              if(p=b.red){
%                  print(" r%.2uX", *p);
%                  b.red += b.delta;
%              }
%              if(p=b.grn){
%                  print(" g%.2uX", *p);
%                  b.grn += b.delta;
%              }
%              if(p=b.blu){
%                  print(" b%.2uX", *p);
%                  b.blu += b.delta;
%              }
%          }
%          if((p=b.alpha) != &ones){
%              print(" α%.2uX", *p);
%              b.alpha += b.delta;
%          }
%      }
%      print("\n");
%  }
%  @



\subsection{Reading pixels, [[readfn()]]}
% pixels lines

% reading for src and dst (will see reading for mask later).

<<function readfn>>=
static Readfn*
readfn(Memimage *img)
{
    <<[[readfn()]] if depth less than 8>>
    <<[[readfn()]] if cmap>>
    return readbyte;
}
@

% depth >=8  but actually must be also a multiple of 8!

<<function readbyte>>=
static Buffer
readbyte(Param *p, byte *buf, int y)
{
    Memimage *img;
    byte *begin, *end, *r;
    Buffer b;
    byte *w;
    int dx, nb;

    bool isgrey, convgrey;
    bool alphaonly, copyalpha;
    <<[[readbyte]] other locals>>

    img = p->img;
    begin = p->bytey0s  + y*p->bwidth;
    r     = p->bytermin + y*p->bwidth;
    end   = p->bytey0e  + y*p->bwidth;

    w = buf;
    dx = p->dx;
    nb = img->depth/8;

    convgrey = p->convgrey;	/* convert rgb to grey */
    isgrey   = img->flags&Fgrey;
    copyalpha = img->flags&Falpha;
    alphaonly = p->alphaonly;

    <<[[readbyte()]] simple case when no repl, no grey, depth 8>>
    // else
    <<[[readbyte()]] more complex cases, possible repl, grey, and small depth>>
}
@
%old:    copyalpha = (img->flags&Falpha) ? 1 : 0;
%    DBG1("copyalpha %d alphaonly %d convgrey %d isgrey %d\n", copyalpha, alphaonly, convgrey, isgrey);



<<[[readbyte()]] simple case when no repl, no grey, depth 8>>=
/* if we can, avoid processing everything */
if(!(img->flags&Frepl) && !convgrey && (img->flags&Fbytes)){
    memset(&b, 0, sizeof(Buffer));
    if(p->needbuf){
        memmove(buf, r, dx*nb);
        r = buf;
    }
    b.rgba = (ulong*)r;

    if(copyalpha)
        b.alpha = r + img->shift[CAlpha]/8;
    else
        b.alpha = &ones;
    <<[[readbyte()]] in simple case, if isgrey>>
    }else{
        b.red = r + img->shift[CRed]/8;
        b.grn = r + img->shift[CGreen]/8;
        b.blu = r + img->shift[CBlue]/8;
    }
    b.delta = nb;
    return b;
}
@

% Lots of stuff going on. r can point in original image directly
%  if no needbuf.
% See shift[] in Section X.

<<global ones>>=
static uchar ones = 0xff;
@
% used later too, not only in debug code




\subsection{Writing pixels, [[writefn()]]}

% Will call that only for dst, so code is simpler. No need handle repl
% for instance.

<<function writefn>>=
static Writefn*
writefn(Memimage *img)
{
    <<[[writefn()]] if depth less than 8>>
    <<[[writefn()]] if cmap>>
    return writebyte;
}
@

% depth more than 8 and a multiple of 8!
% precond is that have Fbytes? or at least pixel
% size is a multiple of bytes.

% process word by word but actually left some unchanged.
% move pixels by pixels though (nb bytes).

<<function writebyte>>=
static void
writebyte(Param *p, byte *w, Buffer src)
{
    Memimage *img;
    int dx, nb;
    byte *red, *grn, *blu, *grey, *alpha;
    int delta;
    // will iterate over all the pixels in one line in src
    int i;

    bool isalpha, isgrey;
    byte ff;
    int adelta;
    ulong u, mask;

    img = p->img;

    red = src.red;
    grn = src.grn;
    blu = src.blu;
    alpha = src.alpha;
    delta = src.delta;
    grey = src.grey;
    dx = p->dx;

    nb = img->depth/8;
    mask = (nb==4) ? 0 : ~((1<<img->depth)-1); // >>

    isalpha = img->flags&Falpha;
    isgrey = img->flags&Fgrey;

    <<[[writebyte()]] alpha handling part1>>

    for(i=0; i<dx; i++){
        u = w[0] | (w[1]<<8) | (w[2]<<16) | (w[3]<<24);
        u &= mask;
        <<[[writebyte()]] if isgrey>>
        else{
            u |= ((*red >> (8-img->nbits[CRed])) & img->mask[CRed]) << img->shift[CRed];
            u |= ((*grn >> (8-img->nbits[CGreen])) & img->mask[CGreen]) << img->shift[CGreen];
            u |= ((*blu >> (8-img->nbits[CBlue])) & img->mask[CBlue]) << img->shift[CBlue];
            red += delta;
            grn += delta;
            blu += delta;
        }
        <<[[writebyte()]] alpha handling part2>>

        w[0] = u;
        w[1] = u>>8;
        w[2] = u>>16;
        w[3] = u>>24;
        w += nb;
    }
}
@
% >> >> >> >> >> >> >> >>
%old:
%        DBG1("u %.8lux...", u);
%        DBG1("&mask %.8lux...", u);
%            DBG1("|grey %.8lux...", u);
%            DBG1("|rgb %.8lux...", u);
%            DBG1("|alpha %.8lux...", u);

% what if less than 4 channels?
%  it works thanks to umask
% we process word by word but we will always left unchanged
%  the extra byte.
% what if less than 8 bits per channel?
%  it works too thanks to nbits[]

% many situation where we need to write in dst an alpha but there 
% was no alpha channel in the src Buffer
% in which case we need to generate a default one.

<<[[writebyte()]] alpha handling part1>>=
adelta = src.delta;
if(isalpha && (alpha == nil || alpha == &ones)){
    ff = 0xFF;
    alpha = &ff;
    adelta = 0;
}
@
% why use local? because can be overwritten? could use ones too no?
% could have a src.adelta then instead of repeating the detection here.

<<[[writebyte()]] alpha handling part2>>=
if(isalpha){
    u |= ((*alpha >> (8-img->nbits[CAlpha])) & img->mask[CAlpha]) << img->shift[CAlpha];
    alpha += adelta;
}
@
%>>

\subsection{Reading the mask}

%remember that memopaque which is the default mask used when drawing
% is memones which is just a GREY1

<<[[alphadraw()]] set rdmask>>=
if(mask->flags&Falpha){
    rdmask = readalphafn(mask);
    z->mpar.alphaonly = true;
}
/*
 * If there is no alpha channel, we'll ask for a grey channel
 * and pretend it is the alpha.
 */
else{
    z->mpar.greymaskcall = readfn(mask);
    z->mpar.convgrey = true;
    rdmask = greymaskread;

    <<[[alphadraw()]] when mask and source have no alpha, possibly adapt calc>>
}
@



<<[[ParamDraw]] mask fields>>=
bool	alphaonly;
bool	convgrey;
Readfn	*greymaskcall;	
@


<<function readalphafn>>=
static Readfn*
readalphafn(Memimage *m)
{
    USED(m);
    return readbyte;
}
@
% will maybe replicate bytes in buffer!
% the setting of alphaonly will adjust the behavior of readbyte


<<function greymaskread>>=
/*
 * Alpha reading function that simply relabels the grey pointer.
 */
static Buffer
greymaskread(Param *p, uchar *buf, int y)
{
    Buffer b;

    b = p->greymaskcall(p, buf, y);
    b.alpha = b.grey;
    return b;
}
@

% See {Reading replicated pixels} section in adv topics.

%\subsection{Duplicating pixels}


\subsection{Compositing pixels, [[alphacalcxx()]]}

% I put in appendix or adv topics everything except SoverD alphacalc11?

<<global alphacalc>>=
static Calcfn *alphacalc[Ncomp] = 
{
    alphacalc0,         /* Clear */
    alphacalc14,        /* DoutS */
    alphacalc2810,      /* SoutD */
    alphacalc3679,      /* DxorS */
    alphacalc14,        /* DinS */
    alphacalc5,         /* D */
    alphacalc3679,      /* DatopS */
    alphacalc3679,      /* DoverS */
    alphacalc2810,      /* SinD */
    alphacalc3679,      /* SatopD */
    alphacalc2810,      /* S */
    alphacalc11,        /* SoverD */ // the classic
};
@
% numbers suffixes are here to indicate which porter-duff numbers they cover,
% e.g. alphacalc3679 covers operation 3, 6, 7, and 9.

<<function alphacalc11>>=
static Buffer
alphacalc11(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, bool grey, int op)
{
    int sa, ma;
    int fd;
    int sadelta;
    int i; // iterate over pixels of the line
    bool q;
    // temporaries for MUL
    ulong s, t, u, v;
    // ??
    Buffer obdst;

    USED(op);
    obdst = bdst;
    <<[[alphacalc11()]] alpha handling part1>>
    q = (bsrc.delta == 4) && (bdst.delta == 4);

    // pixel iteration of the line
    for(i=0; i<dx; i++){
        sa = *bsrc.alpha;
        ma = *bmask.alpha;
        fd = 255 - MUL(sa, ma, t);

        <<[[alphacalc11()]] if isgrey>>
        else{
            <<[[alphacalc11()]] special case for 32bits source and dest>>
            // else

            *bdst.red = MUL(ma, *bsrc.red, s) + MUL(fd, *bdst.red, t);
            *bdst.grn = MUL(ma, *bsrc.grn, s) + MUL(fd, *bdst.grn, t);
            *bdst.blu = MUL(ma, *bsrc.blu, s) + MUL(fd, *bdst.blu, t);

            bsrc.red += bsrc.delta;
            bsrc.blu += bsrc.delta;
            bsrc.grn += bsrc.delta;

            bdst.red += bdst.delta;
            bdst.blu += bdst.delta;
            bdst.grn += bdst.delta;
        }

        <<[[alphacalc11()]] alpha handling part2>>
    }
    return obdst;
}
@
% why return old bdst?

<<function MUL>>=
#define MUL(x, y, t)	(t = (x)*(y)+128, (t+(t>>8))>>8)
@
% >> >>
% ?????


%        fd = 255 - MUL(sa, ma, t);
% so if opaque mask and opaque sa, then fd should be 0
% in which case it does not participate in the final value 
% which is why we saw the memove opti before.


<<[[alphacalc11()]] alpha handling part1>>=
sadelta = (bsrc.alpha == &ones) ? 0 : bsrc.delta;
@

<<[[alphacalc11()]] alpha handling part2>>=
if(bdst.alpha != &ones){
    *bdst.alpha = MUL(ma, sa, s) + MUL(fd, *bdst.alpha, t);
    bdst.alpha += bdst.delta;
}
bmask.alpha += bmask.delta;
bsrc.alpha += sadelta;
@

\t no special handling for the alpha of a mask?? no madelta?









\chapter{Drawing Shapes}

%trans:
% seen draw rectangle which is actually basic block to draw any shape!
% Indeed in the end any figure is made of a set of rectangle!
%FIGURE where big zoom and see circle made of all those rectangles.

% See classic CGPP book from Foley et al.

%http://members.chello.at/easyfilter/bresenham.html
% but actually not used, use more general algorithm to fill polygons.
%http://www.redblobgames.com/grids/line-drawing.html

%alt: X11 use a Graphic Context to set properties

\section{Line}

\subsection{API}

<<function line>>=
void
line(Image *dst, Point p0, Point p1, int end0, int end1, int radius, Image *src, Point sp)
{
    lineop(dst, p0, p1, end0, end1, radius, src, sp, SoverD);
}
@
% width will be 1+radius*2 (see draw(2)).

% src often simple again, just a Color, and sp is ZP,

% if src is complex picture, can do very fancy effect! like getting
% a slice of the face of someone drawn as a line!

<<enum _anon_ (include/draw.h)3>>=
enum EndLine
{
    /* line ends */
    Endsquare	= 0, // default
    Enddisc		= 1,
    Endarrow	= 2,

    Endmask		= 0x1F
};
@
%less typedef int endline; or use enum?
% see advanced topics actually for code using that
% Endmask ??
\l actually use more Endmask instead of hardcoding those 0x1F everywhere below
\l why 0x1F ??? because of Arrow() macro?


% No dashing parameter as in SRGP. Simple API.
% But actually can by playing with the mask! or src!

\subsection{Marshalling}

<<function lineop>>=
void
lineop(Image *dst, Point p0, Point p1, int end0, int end1, int radius, Image *src, Point sp, Drawop op)
{
    byte *a;

    _setdrawop(dst->display, op);

    // draw line: 'L' dstid[4] p0[2*4] p1[2*4] end0[4] end1[4] radius[4] srcid[4] sp[2*4]
    a = bufimage(dst->display, 1+4+2*4+2*4+4+4+4+4+2*4);
    <<[[lineop()]] sanity check a>>
    a[0] = 'L';
    BPLONG(a+1, dst->id);
    BPLONG(a+5, p0.x);
    BPLONG(a+9, p0.y);
    BPLONG(a+13, p1.x);
    BPLONG(a+17, p1.y);
    BPLONG(a+21, end0);
    BPLONG(a+25, end1);
    BPLONG(a+29, radius);
    BPLONG(a+33, src->id);
    BPLONG(a+37, sp.x);
    BPLONG(a+41, sp.y);
}
@

<<[[lineop()]] sanity check a>>=
if(a == nil){
    fprint(2, "image line: %r\n");
    return;
}
@

\subsection{Unmarshalling}

<<[[drawmesg()]] locals>>=
Point sp;
// enum<EndLine>
int e0, e1;
@

<<[[drawmesg()]] cases>>=
/* draw line: 'L' dstid[4] p0[2*4] p1[2*4] end0[4] end1[4] radius[4] srcid[4] sp[2*4] */
case 'L':
    printmesg(fmt="LPPlllLP", a, false);
    m = 1+4+2*4+2*4+4+4+4+4+2*4;
    <<[[drawmesg()]] sanity check n with m>>
    dst = drawimage(client, a+1);
    dstid = BGLONG(a+1);
    drawpoint(&p, a+5);
    drawpoint(&q, a+13);
    e0 = BGLONG(a+21);
    e1 = BGLONG(a+25);
    j = BGLONG(a+29);
    <<[[drawmesg()]] when draw line, sanity check j>>
    src = drawimage(client, a+33);
    drawpoint(&sp, a+37);
    op = drawclientop(client);

    memline(dst, p, q, e0, e1, j, src, sp, op); // The call
    <<[[drawmesg()]] when draw line, possible flush>>
    continue;
@


<<[[drawmesg()]] when draw line, sanity check j>>=
if(j < 0)
    error("negative line width");
@

\subsection{Algorithm}

% memlayer/
<<function memline>>=
void
memline(Memimage *dst, Point p0, Point p1, int end0, int end1, int radius, Memimage *src, Point sp, int op)
{
    _memline(dst, p0, p1, end0, end1, radius, src, sp, dst->clipr, op);
}
@
% only diff is passing dst->clipr. What for? can not just do that in
%  _memline or _memimageline itself? other callers to _memline?

<<function _memline>>=
static
void
_memline(Memimage *dst, Point p0, Point p1, int end0, int end1, int radius, Memimage *src, Point sp, Rectangle clipr, int op)
{
    Memlayer *dl;
    <<[[_memline()]] other locals>>

    <<[[_memline()]] sanity check radius>>
    <<[[_memline()]] sanity check no src layer>>

    Top:
    dl = dst->layer;
    if(dl == nil){
        // back to memdraw/
        _memimageline(dst, p0, p1, end0, end1, radius, src, sp, clipr, op);
        return;
    }
    <<[[_memline()]] when have layers>>
}
@
% what if src has a layer? it will work?


<<[[_memline()]] sanity check radius>>=
if(radius < 0)
    return;
@
% but already checked in drawmesg normally
% note that it can be zero.





% back to memdraw/
<<function _memimageline>>=
void
_memimageline(Memimage *dst, Point p0, Point p1, int end0, int end1, int radius, Memimage *src, Point sp, Rectangle clipr, int op)
{

    bool hor;
    <<[[_memimageline()]] other locals>>

    <<[[_memline()]] sanity check radius>>
    <<[[_memimageline()]] clipping clipr>>

    /* this means that only verline() handles degenerate lines (p0==p1) */
    hor = (abs(p1.x - p0.x) > abs(p1.y - p0.y));

    /*
     * Clipping is a little peculiar.  We can't use Sutherland-Cohen
     * clipping because lines are wide.  But this is probably just fine:
     * we do all math with the original p0 and p1, but clip when deciding
     * what pixels to draw.  This means the layer code can call this routine,
     * using clipr to define the region being written, and get the same set
     * of pixels regardless of the dicing.
     */
     // ????

    <<[[_memimageline()]] swap p0 and p1 to have p0 before p1>>

    // easy case
    <<[[_memimageline()]] when vertical or horizontal lines>>
    // else
    /*    Hard: */
    <<[[_memimageline()]] when arbitrary lines>>
}
@

% Explain previous comment about clipping?

<<[[_memimageline()]] clipping clipr>>=
// clip to dst
if(!rectclip(&clipr, dst->r))
    return;
if(!rectclip(&clipr, dst->clipr))
    return;

// clip to src
d = subpt(sp, p0);
if(!rectclip(&clipr, rectsubpt(src->clipr, d)))
    return;
if(!(src->flags&Frepl) && !rectclip(&clipr, rectsubpt(src->r, d)))
    return;
@
%old: d = subpt(sp, p0); was there but before I think

% remember that sp will match p0, but sp could be 10,10 and
% p0 5,5 so have to adjust src->clipr
% FIGURE?

% call _memline with dst-clipr so first part should be a NOP.
% Why do those manip? anyway we will call memdraw which will do that for us no?
% to save time? 

<<[[_memimageline()]] swap p0 and p1 to have p0 before p1>>=
if((hor && p0.x > p1.x) || (!hor && p0.y > p1.y)){
    // swap(p0, p1)
    q = p0;
    p0 = p1;
    p1 = q;
    // swap(end0, end1)
    t = end0;
    end0 = end1;
    end1 = t;
}
@
% important as we will see. In what case we will draw
%  horizontal lines which will be part of the final line,
%  in the other vertical lines.

\subsubsection{Simple case: vertical or horizontal lines}

%dead: was in comment, but they actually do that so was old comment probably
%    /*
%     * BUG: We should really really pick off purely horizontal and purely
%     * vertical lines and handle them separately with calls to memimagedraw
%     * on rectangles.
%     */

% remember than p0 is "before" p1

<<[[_memimageline()]] when vertical or horizontal lines>>=
if((p0.x == p1.x || p0.y == p1.y) 
&& (end0&0x1F) == Endsquare 
&& (end1&0x1F) == Endsquare){
    r.min = p0;
    r.max = p1;
    // vertical line
    if(p0.x == p1.x){
        r.min.x -= radius;
        r.max.x += radius+1;
    }
    // horizontal line
    else{
        r.min.y -= radius;
        r.max.y += radius+1;
    }
    <<[[_memimageline()]] change dst clipr>>
    sp = addpt(r.min, d);
    memimagedraw(dst, r, src, sp, memopaque, sp, op);
    <<[[_memimageline()]] restore dst clipr>>
    return;
}
@



<<[[_memimageline()]] other locals>>=
Rectangle oclipr;
@
<<[[_memimageline()]] change dst clipr>>=
oclipr = dst->clipr;
dst->clipr = clipr;
@
<<[[_memimageline()]] restore dst clipr>>=
dst->clipr = oclipr;
@
% not sure why does that, to optimize a bit more?
%  and because this clipping information we have to pass to memdraw
%  so there is no much choice, we have to put it in dst.
% but anyway, it is mostly dst-clipr from the start so no big win ...
%  I think all this clipping code could be removed.


\subsubsection{General case}

<<[[_memimageline()]] other locals>>=
int sin, cos, dx, dy, t;
Rectangle r;
Point q;
Point pts[10], *pp;
Point d;
@


% was in draw.h, but probably could be moved in drawimpl.h
<<constant ICOSSCALE>>=
ICOSSCALE	= 1024,
@
% float with integers!
% (Big) Integer Cosinus Scale?


<<[[_memimageline()]] when arbitrary lines>>=
/* draw thick line using polygon fill */
icossin2(p1.x - p0.x, p1.y - p0.y, &cos, &sin);
dx = (sin*(2*radius+1))/2;
dy = (cos*(2*radius+1))/2;
pp = pts;
<<[[_memimageline()]] change dst clipr>>

q.x = ICOSSCALE*p0.x + ICOSSCALE/2- cos/2;
q.y = ICOSSCALE*p0.y + ICOSSCALE/2- sin/2;
switch(end0 & 0x1F){
<<[[_memimageline()]] switch end0 cases>>
<<[[_memimageline()]] switch end0 cases, fallthrough to Endsquare>>
case Endsquare:
default:
    pp->x = q.x - dx;
    pp->y = q.y + dy;
    pp++;
    pp->x = q.x + dx;
    pp->y = q.y - dy;
    pp++;
    break;
}
// 2 points

q.x = ICOSSCALE*p1.x+ICOSSCALE/2+cos/2;
q.y = ICOSSCALE*p1.y+ICOSSCALE/2+sin/2;
switch(end1 & 0x1F){
<<[[_memimageline()]] switch end1 cases>>
<<[[_memimageline()]] switch end1 cases, fallthrough to Endsquare>>
case Endsquare:
default:
    pp->x = q.x + dx;
    pp->y = q.y - dy;
    pp++;
    pp->x = q.x - dx;
    pp->y = q.y + dy;
    pp++;
    break;
}
// 2 more points

_memfillpolysc(dst, pts, pp-pts, ~0, src, 
               addpt(pts[0], mulpt(d, ICOSSCALE)), 
               false, 10, true, op);
<<[[_memimageline()]] restore dst clipr>>
return;
@
%fixshift 10? = 2^10 = 1024

%~0 = w parameter to _memfillpolysc = winding rule for
% what to do when intersect resulting polygon
% can be 0, 1, ~0, ~1 (see draw(2))

% FIGURE where see the 4 points, I think it's the rectangle!

% no bresenham actually. Instead use more general algorithm that
% fills a polygone. More complex too, but more general.

\l could do bresenham when thickness of line is 1? for education purpose?
\l  a good stepping stone to the more complex algo in xscan?


\section{Polyline and polygon}
% put polygon in separate section?

% actually used as we have seen before for general case of (thick) line drawing.

\subsection{API}

% array of points!
<<function poly>>=
void
poly(Image *dst, Point *p, int np, int end0, int end1, int radius, Image *src, Point sp)
{
    dopoly('p', dst, p, np, end0, end1, radius, src, &sp, SoverD);
}
@

<<function polyop>>=
void
polyop(Image *dst, Point *p, int np, int end0, int end1, int radius, Image *src, Point sp, Drawop op)
{
    dopoly('p', dst, p, np, end0, end1, radius, src, &sp, op);
}
@

<<function fillpoly>>=
void
fillpoly(Image *dst, Point *p, int np, int wind, Image *src, Point sp)
{
    dopoly('P', dst, p, np, wind, 0, 0, src, &sp, SoverD);
}
@

<<function fillpolyop>>=
void
fillpolyop(Image *dst, Point *p, int np, int wind, Image *src, Point sp, Drawop op)
{
    dopoly('P', dst, p, np, wind, 0, 0, src, &sp, op);
}
@

% way to fill poly is simple. No complex pattern, etc. But again
% can play with src to do that! Instead of hardcoded set of style,
% just use very general API with flexible mask and src.


\subsection{Marshalling}

% why not _poly? more consistent
<<function dopoly>>=
static
void
dopoly(int cmd, Image *dst, Point *pp, int np, int end0, int end1, int radius, Image *src, Point *sp, Drawop op)
{
    byte *a, *t, *u;
    int i, ox, oy;

    <<[[dopoly()]] sanity check n>>
    t = malloc(np*2*3);
    <<[[dopoly()]] sanity check t>>
    u = t;
    ox = oy = 0;
    for(i=0; i<np; i++){
        u = addcoord(u, ox, pp[i].x);
        ox = pp[i].x;
        u = addcoord(u, oy, pp[i].y);
        oy = pp[i].y;
    }

    _setdrawop(dst->display, op);

    /// polygon: 'p' dstid[4] n[2] end0[4] end1[4] radius[4] srcid[4] sp[2*4] p0[2*4] dp[2*2*n]
    a = bufimage(dst->display, 1+4+2+4+4+4+4+2*4+(u-t));
    <<[[dopoly()]] sanity check a>>
    a[0] = cmd;
    BPLONG(a+1, dst->id);
    BPSHORT(a+5, np-1);
    BPLONG(a+7, end0);
    BPLONG(a+11, end1);
    BPLONG(a+15, radius);
    BPLONG(a+19, src->id);
    BPLONG(a+23, sp->x);
    BPLONG(a+27, sp->y);
    memmove(a+31, t, u-t);
    free(t);
}
@
\l enforce enough space to pass all points?


<<[[dopoly()]] sanity check n>>=
if(np == 0)
    return;
@
<<[[dopoly()]] sanity check t>>=
if(t == nil)
    return;
@
<<[[dopoly()]] sanity check a>>=
if(a == nil){
    free(t);
    fprint(2, "image poly: %r\n");
    return;
}
@

% dopoly -> <>
<<function addcoord>>=
static
uchar*
addcoord(byte *p, int oldx, int newx)
{
    int dx;

    dx = newx-oldx;
    /* does dx fit in 7 signed bits? */
    if((unsigned)(dx - -0x40) <= 0x7F)
        *p++ = dx&0x7F;
    else{
        *p++ = 0x80 | (newx&0x7F);
        *p++ = newx>>7;
        *p++ = newx>>15;
    }
    return p;
}
@

\subsection{Unmarshalling}

<<[[drawmesg()]] locals>>=
int ni;
Point *pp;
bool doflush;
int ox, oy;
int esize, oesize;
byte *u;
int y;
@

<<[[drawmesg()]] cases>>=
/* filled polygon: 'P' dstid[4] n[2] wind[4] ignore[2*4] srcid[4] sp[2*4] p0[2*4] dp[2*2*n] */
/* polygon: 'p' dstid[4] n[2] end0[4] end1[4] radius[4] srcid[4] sp[2*4] p0[2*4] dp[2*2*n] */
case 'p':
case 'P':
    printmesg(fmt="LslllLPP", a, false);
    m = 1+4+2+4+4+4+4+2*4;
    <<[[drawmesg()]] sanity check n with m>>
    dstid = BGLONG(a+1);
    dst = drawimage(client, a+1);
    ni = BGSHORT(a+5);
    <<[[drawmesg()]] when draw polygon, sanity check ni>>
    e0 = BGLONG(a+7);
    e1 = BGLONG(a+11);
    j = 0;
    if(*a == 'p'){
        j = BGLONG(a+15);
        <<[[drawmesg()]] when draw polygon, sanity check j>>
    }
    src = drawimage(client, a+19);
    drawpoint(&sp, a+23);
    drawpoint(&p, a+31);
    ni++;
    pp = malloc(ni*sizeof(Point));
    <<[[drawmesg()]] when draw polygon, sanity check pp>>

    <<[[drawmesg()]] when draw polygon, set doflush>>

    ox = oy = 0;
    esize = 0;
    u = a+m;
    for(y=0; y<ni; y++){
        q = p;
        oesize = esize;
        u = drawcoord(u, a+n, ox, &p.x);
        u = drawcoord(u, a+n, oy, &p.y);
        ox = p.x;
        oy = p.y;

        <<[[drawmesg()]] when draw polygon, if doflush>>
        pp[y] = p;
    }
    <<[[drawmesg()]] when draw polygon, special flush if y is 1>>
    op = drawclientop(client);

    if(*a == 'p')
        mempoly(dst, pp, ni, e0, e1, j, src, sp, op); // The call
    else
        memfillpoly(dst, pp, ni, e0, src, sp, op); // The call

    free(pp);
    m = u-a;
    continue;

@

<<[[drawmesg()]] when draw polygon, sanity check ni>>=
if(ni < 0)
    error("negative count in polygon");
@

<<[[drawmesg()]] when draw polygon, sanity check j>>=
if(j < 0)
    error("negative polygon line width");
@
<<[[drawmesg()]] when draw polygon, sanity check pp>>=
if(pp == nil)
    error(Enomem);
@


<<function drawcoord>>=
uchar*
drawcoord(uchar *p, uchar *maxp, int oldx, int *newx)
{
    int b, x;

    if(p >= maxp)
        error(Eshortdraw);
    b = *p++;
    x = b & 0x7F;
    if(b & 0x80){
        if(p+1 >= maxp)
            error(Eshortdraw);
        x |= *p++ << 7;
        x |= *p++ << 15;
        if(x & (1<<22))
            x |= ~0<<23;
    }else{
        if(b & 0x40)
            x |= ~0<<7;
        x += oldx;
    }
    *newx = x;
    return p;
}
@
% >> >> >> >> >> >>


\subsection{Algorithm}

%helps?
%https://www.cs.uic.edu/~jbell/CourseNotes/ComputerGraphics/PolygonFilling.html


<<function mempoly>>=
void
mempoly(Memimage *dst, Point *vert, int nvert, int end0, int end1, int radius, Memimage *src, Point sp, int op)
{
    int i;
    //enum<EndLine>>
    int e0, e1;
    Point d;

    <<[[mempoly() sanity check nvert>>
    d = subpt(sp, vert[0]); // to compensate for addpt below
    for(i=1; i<nvert; i++){
        <<[[mempoly()]] set endlines e0 and e1>>
        memline(dst, vert[i-1], vert[i], e0, e1, radius, src, addpt(d, vert[i-1]), op);
    }
}
@
% actually call memline! :) (and not _memimageline, so handle layers and so on)
%  which will call back fillpoly.

% vert for vertexes (points)

<<[[mempoly()]] set endlines e0 and e1>>=
e0 = e1 = Enddisc; // for smooth junctions
if(i == 1)
    e0 = end0;
if(i == nvert-1)
    e1 = end1;
@

<<[[mempoly() sanity check nvert>>=
if(nvert < 2)
    return;
@

<<function memfillpoly>>=
void
memfillpoly(Memimage *dst, Point *vert, int nvert, int w, Memimage *src, Point sp, int op)
{
    _memfillpolysc(dst, vert, nvert, w, src, sp, false, 0, false, op);
}
@
% another story! cant call memline because will be infinite recursion

\subsubsection{[[Seg]]}

<<struct Seg>>=
struct Seg
{
    Point	p0;
    Point	p1;

    long	d; // direction? 1 or -1?

    <<[[Seg]] other fields>>
};
@

% note that can be any points, we will have to sort them and
% to know on which size of the line to fill.

\subsubsection{[[_memfillpolysc()]]}

<<function _memfillpolysc>>=
void
_memfillpolysc(Memimage *dst, Point *vert, int nvert, int w, Memimage *src, Point sp, bool detail, int fixshift, bool clipped, int op)
{
    // array<Seg> (length = nvert+1)
    Seg *segtab;
    // array<Seg*> (length = nvert+2)
    Seg **seg;
    Point p0;
    int i;

    <<[[_memfillpolysc()]] sanity check nvert>>

    segtab = malloc((nvert+1)*sizeof(Seg));
    <<[[_memfillpolysc()]] sanity check segtab>>
    seg = malloc((nvert+2)*sizeof(Seg*));
    <<[[_memfillpolysc()]] sanity check seg>>

    sp.x = (sp.x - vert[0].x) >> fixshift;
    sp.y = (sp.y - vert[0].y) >> fixshift;

    p0 = vert[nvert-1]; // start from the end
    <<[[_memfillpolysc()]] adjust p0 if no fixshift>>
    for(i = 0; i < nvert; i++) {
        segtab[i].p0 = p0;
        p0 = vert[i];
        <<[[_memfillpolysc()]] adjust p0 if no fixshift>>
        segtab[i].p1 = p0;
        segtab[i].d = 1;
    }
    <<[[_memfillpolysc()]] adjust fixshift if no fixshift>>

    xscan(dst, seg, segtab, nvert, w, src, sp, detail, fixshift, clipped, op);
    <<[[_memfillpolysc()]] if detail>>

    free(seg);
    free(segtab);
}
@
% >> >> >> >>
\l remove clipped parameter, unused anyway since the code was commented
\l  later

% it closes the polygone if it was not?

<<[[_memfillpolysc()]] sanity check nvert>>=
if(nvert == 0)
    return;
@
<<[[_memfillpolysc()]] sanity check seg>>=
if(seg == nil)
    return;
@
<<[[_memfillpolysc()]] sanity check segtab>>=
if(segtab == nil) {
    free(seg);
    return;
}
@


\subsubsection{Fix shift arithmetics}

% seen passing 10 before, and ICOSSCALE = 1024.

% if not fixshift, at least improve a bit precision by shifting by 1.
<<[[_memfillpolysc()]] adjust p0 if no fixshift>>=
if(!fixshift) {
    p0.x <<= 1;
    p0.y <<= 1;
}
@
% >> >>

<<[[_memfillpolysc()]] adjust fixshift if no fixshift>>=
if(!fixshift)
    fixshift = 1;
@


\subsubsection{[[xscan()]]}

<<[[Seg]] other fields>>=
long	num;
long	den;
long	dz;
long	dzrem;
@

<<[[Seg]] other fields>>=
long	z;
long	zerr;
@

% this is a very complex algorithm ... made more complex
% with the fixshift, with sp, with wind, etc.
% Rely on CGPP? too long to explain otherwise?

<<function xscan>>=
static void
xscan(Memimage *dst, Seg **seg, Seg *segtab, int nseg, int wind, Memimage *src, Point sp, bool detail, int fixshift, bool clipped, int op)
{
    Seg **ep, **next, **p, **q, *s;
    long y, maxy, x, x2, xerr, xden, onehalf;
    long n, i, iy, cnt, ix, ix2, minx, maxx;
    Point pt;
    void	(*fill)(Memimage*, int, int, int, Memimage*, Point, int);

    fill = fillline;
    USED(clipped);

    for(i=0, s=segtab, p=seg; i<nseg; i++, s++) {
        *p = s;
        if(s->p0.y == s->p1.y)
            continue;
        if(s->p0.y > s->p1.y) {
            // swap(s->p0, s->p1)
            pt = s->p0;
            s->p0 = s->p1;
            s->p1 = pt;

            s->d = -s->d;
        }
        s->num = s->p1.x - s->p0.x;
        s->den = s->p1.y - s->p0.y;

        s->dz = sdiv(s->num, s->den) << fixshift;
        s->dzrem = mod(s->num, s->den) << fixshift;
        s->dz += sdiv(s->dzrem, s->den);
        s->dzrem = mod(s->dzrem, s->den);
        p++;
    }
    n = p-seg;
    if(n == 0)
        return;
    *p = nil;
    qsort(seg, n , sizeof(Seg*), ycompare);

    onehalf = 0;
    if(fixshift)
        onehalf = 1 << (fixshift-1);

    minx = dst->clipr.min.x;
    maxx = dst->clipr.max.x;

    y = seg[0]->p0.y;
    if(y < (dst->clipr.min.y << fixshift))
        y = dst->clipr.min.y << fixshift;
    iy = (y + onehalf) >> fixshift;
    y = (iy << fixshift) + onehalf;
    maxy = dst->clipr.max.y << fixshift;

    ep = next = seg;

    while(y<maxy) {
        for(q = p = seg; p < ep; p++) {
            s = *p;
            if(s->p1.y < y)
                continue;
            s->z += s->dz;
            s->zerr += s->dzrem;
            if(s->zerr >= s->den) {
                s->z++;
                s->zerr -= s->den;
                if(s->zerr < 0 || s->zerr >= s->den)
                    print("bad ratzerr1: %ld den %ld dzrem %ld\n", s->zerr, s->den, s->dzrem);
            }
            *q++ = s;
        }

        for(p = next; *p; p++) {
            s = *p;
            if(s->p0.y >= y)
                break;
            if(s->p1.y < y)
                continue;
            s->z = s->p0.x;
            s->z += smuldivmod(y - s->p0.y, s->num, s->den, &s->zerr);
            if(s->zerr < 0 || s->zerr >= s->den)
                print("bad ratzerr2: %ld den %ld ratdzrem %ld\n", s->zerr, s->den, s->dzrem);
            *q++ = s;
        }
        ep = q;
        next = p;

        if(ep == seg) {
            if(*next == 0)
                break;
            iy = (next[0]->p0.y + onehalf) >> fixshift;
            y = (iy << fixshift) + onehalf;
            continue;
        }

        zsort(seg, ep);

        for(p = seg; p < ep; p++) {
            cnt = 0;

            x = p[0]->z;
            xerr = p[0]->zerr;
            xden = p[0]->den;

            ix = (x + onehalf) >> fixshift;
            if(ix >= maxx)
                break;
            if(ix < minx)
                ix = minx;

            cnt += p[0]->d;
            p++;
            for(;;) {
                if(p == ep) {
                    print("xscan: fill to infinity");
                    return;
                }
                cnt += p[0]->d;
                if((cnt & wind) == 0)
                    break;
                p++;
            }

            x2 = p[0]->z;
            ix2 = (x2 + onehalf) >> fixshift;
            if(ix2 <= minx)
                continue;
            if(ix2 > maxx)
                ix2 = maxx;

            <<[[xscan()]] if detail>>

            // the call
            (*fill)(dst, ix, ix2, iy, src, sp, op);
        }
        y += (1<<fixshift);
        iy++;
    }
}
@
% >> >> >> >> >>
% wow, so complicated
\t remove clipped parameter, unused anyway
%old: can use n in code below, clearer
%    qsort(seg, p-seg , sizeof(Seg*), ycompare);
%old: was commented already in the orginal code
%  /*
%   * This can only work on 8-bit destinations, since fillcolor is
%   * just using memset on sp.x.
%   *
%   * I'd rather not even enable it then, since then if the general
%   * code is too slow, someone will come up with a better improvement
%   * than this sleazy hack.	-rsc
%   *
%      if(clipped 
%      && (src->flags&Frepl) 
%      && src->depth==8 
%      && Dx(src->r)==1 
%      && Dy(src->r)==1) {
%          fill = fillcolor;
%          sp.x = membyteval(src);
%      }
%   *
%   */

\subsubsection{[[fillxxx()]]}

<<function fillline>>=
static void
fillline(Memimage *dst, int xleft, int xright, int y, Memimage *src, Point p, int op)
{
    Rectangle r;

    r.min.x = xleft;
    r.min.y = y;
    r.max.x = xright;
    r.max.y = y+1;

    p.x += xleft;
    p.y += y;

    memdraw(dst, r, src, p, memopaque, p, op);
}
@


%dead: used only in code that is now commented
% <<function fillcolor>>=
% static void
% fillcolor(Memimage *dst, int left, int right, int y, Memimage *src, Point p)
% {
%     int srcval;
% 
%     USED(src);
%     srcval = p.x;
%     p.x = left;
%     p.y = y;
%     memset(byteaddr(dst, p), srcval, right-left);
% }
% @




\subsubsection{Arithmetics}

<<function mod>>=
static long
mod(long x, long y)
{
    long z;

    z = x%y;
    if((long)(((ulong)z)^((ulong)y)) > 0 || z == 0)
        return z;
    return z + y;
}
@

<<function sdiv>>=
static long
sdiv(long x, long y)
{
    if((long)(((ulong)x)^((ulong)y)) >= 0 || x == 0)
        return x/y;

    return (x+((y>>30)|1))/y-1;
}
@

<<function smuldivmod>>=
static long
smuldivmod(long x, long y, long z, long *mod)
{
    vlong vx;

    if(x == 0 || y == 0){
        *mod = 0;
        return 0;
    }
    vx = x;
    vx *= y;
    *mod = vx % z;
    if(*mod < 0)
        *mod += z;	/* z is always >0 */
    if((vx < 0) == (z < 0))
        return vx/z;
    return -((-vx)/z);
}
@

\subsubsection{Sorting}


<<function zsort>>=
static void
zsort(Seg **seg, Seg **ep)
{
    int done;
    Seg **q, **p, *s;

    if(ep-seg < 20) {
        /* bubble sort by z - they should be almost sorted already */
        q = ep;
        do {
            done = 1;
            q--;
            for(p = seg; p < q; p++) {
                if(p[0]->z > p[1]->z) {
                    s = p[0];
                    p[0] = p[1];
                    p[1] = s;
                    done = 0;
                }
            }
        } while(!done);
    } else {
        q = ep-1;
        for(p = seg; p < q; p++) {
            if(p[0]->z > p[1]->z) {
                qsort(seg, ep-seg, sizeof(Seg*), zcompare);
                break;
            }
        }
    }
}
@

<<function ycompare>>=
static int
ycompare(void *a, void *b)
{
    Seg **s0 = a, **s1 = b;
    long y0, y1;

    y0 = (*s0)->p0.y;
    y1 = (*s1)->p0.y;

    if(y0 < y1)
        return -1;
    if(y0 == y1)
        return 0;
    return 1;
}
@


<<function zcompare>>=
static int
zcompare(void *a, void *b)
{
    Seg **s0 = a, **s1 = b;
    long z0, z1;

    z0 = (*s0)->z;
    z1 = (*s1)->z;

    if(z0 < z1)
        return -1;
    if(z0 == z1)
        return 0;
    return 1;
}
@




\section{Ellipse}

% libmemdraw/ellipse.c
%/*
% * ellipse(dst, c, a, b, t, src, sp)
% *   draws an ellipse centered at c with semiaxes a,b>=0
% *   and semithickness t>=0, or filled if t<0.  point sp
% *   in src maps to c in dst
% *
% *   very thick skinny ellipses are brushed with circles (slow)
% *   others are approximated by filling between 2 ellipses
% *   criterion for very thick when b<a: t/b > 0.5*x/(1-x)
% *   where x = b/a
% */

\subsection{API}

<<function ellipse>>=
void
ellipse(Image *dst, Point c, int a, int b, int thick, Image *src, Point sp)
{
    doellipse('e', dst, &c, a, b, thick, src, &sp, 0, 0, SoverD);
}
@
% used also for arc, hence the 0 0 for alpha and phi.
% here thick must be >=0. The comment above is for memdraw,
% not for the API.

<<function ellipseop>>=
void
ellipseop(Image *dst, Point c, int a, int b, int thick, Image *src, Point sp, Drawop op)
{
    doellipse('e', dst, &c, a, b, thick, src, &sp, 0, 0, op);
}
@

<<function fillellipse>>=
void
fillellipse(Image *dst, Point c, int a, int b, Image *src, Point sp)
{
    doellipse('E', dst, &c, a, b, 0, src, &sp, 0, 0, SoverD);
}
@

<<function fillellipseop>>=
void
fillellipseop(Image *dst, Point c, int a, int b, Image *src, Point sp, Drawop op)
{
    doellipse('E', dst, &c, a, b, 0, src, &sp, 0, 0, op);
}
@


\subsection{Marshalling}

% rename _ellipse?
<<function doellipse>>=
static
void
doellipse(int cmd, Image *dst, Point *c, int xr, int yr, int thick, Image *src, Point *sp, int alpha, int phi, Drawop op)
{
    byte *a;

    _setdrawop(dst->display, op);

    // ellipse: 'e' dstid[4] srcid[4] center[2*4] a[4] b[4] thick[4] sp[2*4] alpha[4] phi[4]
    a = bufimage(dst->display, 1+4+4+2*4+4+4+4+2*4+2*4);
    <<[[doellipse()]] sanity check a>>
    a[0] = cmd;
    BPLONG(a+1, dst->id);
    BPLONG(a+5, src->id);
    BPLONG(a+9, c->x);
    BPLONG(a+13, c->y);
    BPLONG(a+17, xr);
    BPLONG(a+21, yr);
    BPLONG(a+25, thick);
    BPLONG(a+29, sp->x);
    BPLONG(a+33, sp->y);
    BPLONG(a+37, alpha);
    BPLONG(a+41, phi);
}
@

<<[[doellipse()]] sanity check a>>=
if(a == nil){
    fprint(2, "image ellipse: %r\n");
    return;
}
@

\subsection{Unmarshalling}


<<[[drawmesg()]] cases>>=
/* ellipse: 'e' dstid[4] srcid[4] center[2*4] a[4] b[4] thick[4] sp[2*4] alpha[4] phi[4]*/
case 'e':
case 'E':
    printmesg(fmt="LLPlllPll", a, false);
    m = 1+4+4+2*4+4+4+4+2*4+2*4;
    <<[[drawmesg()]] sanity check n with m>>
    dst = drawimage(client, a+1);
    dstid = BGLONG(a+1);
    src = drawimage(client, a+5);
    drawpoint(&p, a+9);
    e0 = BGLONG(a+17);
    e1 = BGLONG(a+21);
    <<[[drawmesg()]] when draw ellipse, sanity check widths>>
    j = BGLONG(a+25);
    <<[[drawmesg()]] when draw ellipse, sanity check j>>
    drawpoint(&sp, a+29);
    c = j;
    if(*a == 'E')
        c = -1;
    ox = BGLONG(a+37);
    oy = BGLONG(a+41);
    op = drawclientop(client);
 
   <<[[drawmesg()]] when draw ellipse, if ox>>
    else
        memellipse(dst, p, e0, e1, c, src, sp, op); // The call

   <<[[drawmesg()]] when draw ellipse, dstflush>>

    continue;
@
% >> >> >>


<<[[drawmesg()]] when draw ellipse, sanity check widths>>=
if(e0<0 || e1<0)
    error("invalid ellipse semidiameter");
@

<<[[drawmesg()]] when draw ellipse, sanity check j>>=
if(j < 0)
    error("negative ellipse thickness");
@

\subsection{Algorithm}

%/*
% * ellipse(dst, c, a, b, t, src, sp)
% *   draws an ellipse centered at c with semiaxes a,b>=0
% *   and semithickness t>=0, or filled if t<0.  point sp
% *   in src maps to c in dst
% *
% *   very thick skinny ellipses are brushed with circles (slow)
% *   others are approximated by filling between 2 ellipses
% *   criterion for very thick when b<a: t/b > 0.5*x/(1-x)
% *   where x = b/a
% */

<<struct ParamEllipse>>=
struct ParamEllipse {
    Memimage	*dst;
    Memimage	*src;
    Point			c;
    int			t;
    Point			sp;
    Memimage	*disc;
    int			op;
};
@

<<struct State>>=
/*
 * denote residual error by e(x,y) = b^2*x^2 + a^2*y^2 - a^2*b^2
 * e(x,y) = 0 on ellipse, e(x,y) < 0 inside, e(x,y) > 0 outside
 */
struct State {
    int	a;
    int	x;
    vlong	a2;	/* a^2 */
    vlong	b2;	/* b^2 */
    vlong	b2x;	/* b^2 * x */
    vlong	a2y;	/* a^2 * y */
    vlong	c1;
    vlong	c2;	/* test criteria */
    vlong	ee;	/* ee = e(x+1/2,y-1/2) - (a^2+b^2)/4 */
    vlong	dxe;
    vlong	dye;
    vlong	d2xe;
    vlong	d2ye;
};
@

<<function newstate>>=
static
State*
newstate(State *s, int a, int b)
{
    s->x = 0;
    s->a = a;
    s->a2 = (vlong)(a*a);
    s->b2 = (vlong)(b*b);
    s->b2x = (vlong)0;
    s->a2y = s->a2*(vlong)b;
    s->c1 = -((s->a2>>2) + (vlong)(a&1) + s->b2);
    s->c2 = -((s->b2>>2) + (vlong)(b&1));
    s->ee = -s->a2y;
    s->dxe = (vlong)0;
    s->dye = s->ee<<1;
    s->d2xe = s->b2<<1;
    s->d2ye = s->a2<<1;
    return s;
}
@
% >> >> >> 


<<function memellipse>>=
void
memellipse(Memimage *dst, Point c, int a, int b, int t, Memimage *src, Point sp, int op)
{
    State in, out;
    int y, inb, inx, outx, u;
    Param p;

    if(a < 0)
        a = -a;
    if(b < 0)
        b = -b;
    p.dst = dst;
    p.src = src;
    p.c = c;
    p.t = t;
    p.sp = subpt(sp, c);
    p.disc = nil;
    p.op = op;

    u = (t<<1)*(a-b);
    if(b<a && u>b*b || a<b && -u>a*a) {
/*	if(b<a&&(t<<1)>b*b/a || a<b&&(t<<1)>a*a/b)	# very thick */
        bellipse(b, newstate(&in, a, b), &p);
        return;
    }

    if(t < 0) {
        inb = -1;
        newstate(&out, a, y = b);
    } else {	
        inb = b - t;
        newstate(&out, a+t, y = b+t);
    }
    if(t > 0)
        newstate(&in, a-t, inb);
    inx = 0;
    for( ; y>=0; y--) {
        outx = step(&out);
        if(y > inb) {
            erect(-outx, y, outx, y, &p);
            if(y != 0)
                erect(-outx, -y, outx, -y, &p);
            continue;
        }
        if(t > 0) {
            inx = step(&in);
            if(y == inb)
                inx = 0;
        } else if(inx > outx)
            inx = outx;
        erect(inx, y, outx, y, &p);
        if(y != 0)
            erect(inx, -y, outx, -y, &p);
        erect(-outx, y, -inx, y, &p);
        if(y != 0)
            erect(-outx, -y, -inx, -y, &p);
        inx = outx + 1;
    }
}
@
% >> >> >>

<<global p00 (lib_graphics/libmemdraw/ellipse.c)>>=
static Point p00 = {0, 0};
@

<<function bellipse>>=
/*
 * a brushed ellipse
 */
static
void
bellipse(int y, State *s, Param *p)
{
    int t, ox, oy, x, nx;

    t = p->t;
    p->disc = allocmemimage(Rect(-t,-t,t+1,t+1), GREY1);
    if(p->disc == nil)
        return;
    memfillcolor(p->disc, DTransparent);
    memellipse(p->disc, p00, t, t, -1, memopaque, p00, p->op);
    oy = y;
    ox = 0;
    nx = x = step(s);
    do {
        while(nx==x && y-->0)
            nx = step(s);
        y++;
        eline(-x,-oy,-ox, -y, p);
        eline(ox,-oy,  x, -y, p);
        eline(-x,  y,-ox, oy, p);
        eline(ox,  y,  x, oy, p);
        ox = x+1;
        x = nx;
        y--;
        oy = y;
    } while(oy > 0);
}
@

<<function erect>>=
/*
 * a rectangle with closed (not half-open) coordinates expressed
 * relative to the center of the ellipse
 */
static
void
erect(int x0, int y0, int x1, int y1, Param *p)
{
    Rectangle r;

/*	print("R %d,%d %d,%d\n", x0, y0, x1, y1); /**/
    r = Rect(p->c.x+x0, p->c.y+y0, p->c.x+x1+1, p->c.y+y1+1);
    memdraw(p->dst, r, p->src, addpt(p->sp, r.min), memopaque, p00, p->op);
}
@


<<function step>>=
/*
 * return x coord of rightmost pixel on next scan line
 */
static
int
step(State *s)
{
    while(s->x < s->a) {
        if(s->ee+s->b2x <= s->c1 ||	/* e(x+1,y-1/2) <= 0 */
           s->ee+s->a2y <= s->c2) {	/* e(x+1/2,y) <= 0 (rare) */
            s->dxe += s->d2xe;	  
            s->ee += s->dxe;	  
            s->b2x += s->b2;
            s->x++;	  
            continue;
        }
        s->dye += s->d2ye;	  
        s->ee += s->dye;	  
        s->a2y -= s->a2;
        if(s->ee-s->a2y <= s->c2) {	/* e(x+1/2,y-1) <= 0 */
            s->dxe += s->d2xe;	  
            s->ee += s->dxe;	  
            s->b2x += s->b2;
            return s->x++;
        }
        break;
    }
    return s->x;	  
}
@



<<function epoint>>=
/*
 * a brushed point similarly specified
 */
static
void
epoint(int x, int y, Param *p)
{
    Point p0;
    Rectangle r;

/*	print("P%d %d,%d\n", p->t, x, y);	/**/
    p0 = Pt(p->c.x+x, p->c.y+y);
    r = Rpt(addpt(p0, p->disc->r.min), addpt(p0, p->disc->r.max));
    memdraw(p->dst, r, p->src, addpt(p->sp, r.min), p->disc, p->disc->r.min, p->op);
}
@

<<function eline>>=
/* 
 * a brushed horizontal or vertical line similarly specified
 */
static
void
eline(int x0, int y0, int x1, int y1, Param *p)
{
/*	print("L%d %d,%d %d,%d\n", p->t, x0, y0, x1, y1); /**/
    if(x1 > x0+1)
        erect(x0+1, y0-p->t, x1-1, y1+p->t, p);
    else if(y1 > y0+1)
        erect(x0-p->t, y0+1, x1+p->t, y1-1, p);
    epoint(x0, y0, p);
    if(x1-x0 || y1-y0)
        epoint(x1, y1, p);
}
@



\section{Arc}

\subsection{API}

<<function arc>>=
void
arc(Image *dst, Point c, int a, int b, int thick, Image *src, Point sp, int alpha, int phi)
{
    alpha |= 1<<31;
    doellipse('e', dst, &c, a, b, thick, src, &sp, alpha, phi, SoverD);
}
@
% >>
% special bit, used because want to allow also alpha at 0.

<<function arcop>>=
void
arcop(Image *dst, Point c, int a, int b, int thick, Image *src, Point sp, int alpha, int phi, Drawop op)
{
    alpha |= 1<<31;
    doellipse('e', dst, &c, a, b, thick, src, &sp, alpha, phi, op);
}
@
% >>

<<function fillarc>>=
void
fillarc(Image *dst, Point c, int a, int b, Image *src, Point sp, int alpha, int phi)
{
    alpha |= 1<<31;
    doellipse('E', dst, &c, a, b, 0, src, &sp, alpha, phi, SoverD);
}
@
% >>

<<function fillarcop>>=
void
fillarcop(Image *dst, Point c, int a, int b, Image *src, Point sp, int alpha, int phi, Drawop op)
{
    alpha |= 1<<31;
    doellipse('E', dst, &c, a, b, 0, src, &sp, alpha, phi, op);
}
@
% >>

\subsection{Unmarshalling}

<<[[drawmesg()]] when draw ellipse, if ox>>=
/* high bit indicates arc angles are present */

if(ox & (1<<31)){
    if((ox & (1<<30)) == 0)
        ox &= ~(1<<31);
    memarc(dst, p, e0, e1, c, src, sp, ox, oy, op); // The call
}
@
% >> >> >> >>

\subsection{Algoritm}

<<enum _anon_ (lib_graphics/libmemdraw/arc.c)>>=
/*
 * elarc(dst,c,a,b,t,src,sp,alpha,phi)
 *   draws the part of an ellipse between rays at angles alpha and alpha+phi
 *   measured counterclockwise from the positive x axis. other
 *   arguments are as for ellipse(dst,c,a,b,t,src,sp)
 */
enum
{
    R, T, L, B	/* right, top, left, bottom */
};
@

<<global corners>>=
static
Point corners[] = {
    {1,1},
    {-1,1},
    {-1,-1},
    {1,-1}
};
@

<<global p00>>=
static
Point p00;
@



<<function memarc>>=
/*
 * make a "wedge" mask covering the desired angle and contained in
 * a surrounding square; draw a full ellipse; intersect that with the
 * wedge to make a mask through which to copy src to dst.
 */
void
memarc(Memimage *dst, Point c, int a, int b, int t, Memimage *src, Point sp, int alpha, int phi, int op)
{
    int i, w, beta, tmp, c1, c2, m, m1;
    Rectangle rect;
    Point p,	bnd[8];
    Memimage *wedge, *figure, *mask;

    if(a < 0)
        a = -a;
    if(b < 0)
        b = -b;
    w = t;
    if(w < 0)
        w = 0;
    alpha = -alpha;		/* compensate for upside-down coords */
    phi = -phi;
    beta = alpha + phi;
    if(phi < 0){
        tmp = alpha;
        alpha = beta;
        beta = tmp;
        phi = -phi;
    }
    if(phi >= 360){
        memellipse(dst, c, a, b, t, src, sp, op);
        return;
    }
    while(alpha < 0)
        alpha += 360;
    while(beta < 0)
        beta += 360;
    c1 = alpha/90 & 3;	/* number of nearest corner */
    c2 = beta/90 & 3;
        /*
         * icossin returns point at radius ICOSSCALE.
         * multiplying by m1 moves it outside the ellipse
        */
    rect = Rect(-a-w, -b-w, a+w+1, b+w+1);
    m = rect.max.x;	/* inradius of bounding square */
    if(m < rect.max.y)
        m = rect.max.y;
    m1 = (m+ICOSSCALE-1) >> 10;
    m = m1 << 10;		/* assure m1*cossin is inside */
    i = 0;
    bnd[i++] = Pt(0,0);
    icossin(alpha, &p.x, &p.y);
    bnd[i++] = mulpt(p, m1);
    for(;;) {
        bnd[i++] = mulpt(corners[c1], m);
        if(c1==c2 && phi<180)
            break;
        c1 = (c1+1) & 3;
        phi -= 90;
    }
    icossin(beta, &p.x, &p.y);
    bnd[i++] = mulpt(p, m1);

    figure = nil;
    mask = nil;
    wedge = allocmemimage(rect, GREY1);
    if(wedge == nil)
        goto Return;
    memfillcolor(wedge, DTransparent);
    memfillpoly(wedge, bnd, i, ~0, memopaque, p00, S);
    figure = allocmemimage(rect, GREY1);
    if(figure == nil)
        goto Return;
    memfillcolor(figure, DTransparent);
    memellipse(figure, p00, a, b, t, memopaque, p00, S);
    mask = allocmemimage(rect, GREY1);
    if(mask == nil)
        goto Return;
    memfillcolor(mask, DTransparent);
    memimagedraw(mask, rect, figure, rect.min, wedge, rect.min, S);
    c = subpt(c, dst->r.min);
    memdraw(dst, dst->r, src, subpt(sp, c), mask, subpt(p00, c), op);

    Return:
    freememimage(wedge);
    freememimage(figure);
    freememimage(mask);
}
@
% >> >> >>

%\section{Bezier} see advanced topics

%\section{Text} see font section








\chapter{Fonts}

% Show simple test code showing use of font.
% Maybe just 2 calls to 2 different openfont() and 2 calls to string().
% Also start from last string thanks to the point returned by string.
% Also can call freefont().

% font(6), image(6),
% subfont(2), cachechars(2), 

% related:
%  - toy text API in Cairo 
%    does aliasing! does also scaling!
%  - Pango library with GTK (same than cairo but less buggy)
%  - freetype? fontconfig?
%  - openGL? actually one of the missing stuff in openGL is text API I think

%https://engineering.eventbrite.com/its-2015-and-drawing-text-is-still-hard-webgl-threejs/

% can have font with any size? can scale? like in Cairo (and Pango)?
% can do codemap easily? I don't think so.

\t EASY rename f in sf when it involves a subfont, in fields, in locals
\t EASY rename cf to sfrange

\section{Font files formats}

% show content of unicode.font where see list of subfonts ranges.
%  A subfont is a picture containing many chars! where spec of chars
%   stored after in fontchars.
%  one font is split in many subfonts cos save space cos unicode really 
%   large so would be big images with lots of space wasted.
%   (65000 chars? 8x8 => total size = ?)
% maybe show one subfont file? where see compressed at the top?

% font format: see unicode.font
% - a file (or string) with a list of subfont ranges
% - %d %d\n%d %d\t%s\n...  first 2 numbers are height, ascent, 
%   and then a list of lines with each time
%     min/max (rune range), offset(optional), subfont name
% for offset see latin1.9 font or unicode.font and last unicode chars.

% subfont format (see getdefont): when uncompressed:
%  - ld = format for chan
%  - rectangle of font bits image
%  - data, via loadimage
%  - hdr for fontchars
%  - data for list of fontchars



\section{Additional data structures}

\subsection{[[Font]] and [[font]]}

<<struct Font>>=
struct Font
{
    // ref_own<filename>, // e.g. /lib/font/bit/lucm/latin1.9.font
    char		*name;
    // ref<Display>
    Display		*display;

    short		height;	/* max height of image, interline spacing */
    short		ascent;	/* top of image to baseline */

    <<[[Font]] subfont spec fields>>
    <<[[Font]] subfont cache fields>>
    <<[[Font]] character cache fields>>
    <<[[Font]] other fields>>
};
@
% ctor = buildfont <- openfont

\t FIGURE showing relation with height, ascent, etc.

<<global font>>=
Font	*font;
@
% used for? convenient shortcut?
% one of the global set by initdraw.


<<[[Display]] font fields>>=
Font	*defaultfont;
@
% used for? diff with global font? set in geninitdraw to same value than font
%  not used that much so perhaps could delay


% loaded fonts (subfonts) will be Images! in fact in Dimage
% there will be font properties inlined.


% Fonts are made of a set of subfonts where one subfont
% contain a big image with a set of chars. Not all cos could
% take too much space. So subfonts loaded as needed.

<<[[Font]] subfont spec fields>>=
// array<ref_own<Cachefont>> (length = Font.nsub)
Cachefont	**sub;	/* as read from file */
short		nsub;	/* number of subfonts */
@
\t rename sub to subspec or sf_spec

% spec of set of subfonts, but not the actual loaded subfont.
<<struct Cachefont>>=
struct Cachefont
{
    Rune		min;	/* lowest rune value to be taken from subfont */
    Rune		max;	/* highest rune value+1 to be taken from subfont */
    // option<int>, None = 0
    int		offset;	/* position in subfont of character at min */

    // ref_own<string>, relative filename
    char		*name;			/* stored in font */
    // option<ref_own<filename>>, absolute filename, computed by subfontname()
    char		*subfontname;		/* to access subfont */

};
@
% information about a range of chars, but still no Subfont.
\t rename cos it is actually not a cache ... rename SubfontInfo?

% all of that is set in buildfont.

\t How transit from Font to subfont? other fields are Cachexxx
% which have beneath probably a Subfont.

\subsection{[[Subfont]] and [[Fontchar]]}

%cachechars(2):
%"A Subfont is a set of images for a contiguous range of characters,
%stored as a single image with the characters placed side-by-side on a
%common baseline."

<<[[Display]] font fields>>=
Subfont	*defaultsubfont;
@
% used to bootstrap when lookup *default*, but could be done via
% a installsubfont I think instead.

<<struct Subfont>>=
/*
 * Subfonts
 *
 * given char c, Subfont *f, Fontchar *i, and Point p, one says
 *	i = f->info + c;
 *	draw(b, Rect(p.x + i->left, p.y + i->top,
 *		p.x + i->left + ((i+1)->x - i->x), p.y + i->bottom),
 *		color, f->bits, Pt(i->x, i->top));
 *	p.x += i->width;
 * to draw characters in the specified color (itself an Image) in Image b.
 */
struct	Subfont
{
    // ref_own<string>
    char		*name;
    // ref_own<Image> ?
    Image		*bits;	/* of font */

    // array<Fontchar> (size = Subfont.n + 1)
    Fontchar 	*info;	/* n+1 character descriptors */
    short		n;		/* number of chars in font */

    <<[[Subfont]] other fields>>

    // Extra
    int		ref;
};
@
% ctor = allocsubfont (<- getdefont | ???)
% uchar so image can not be more than 255 pixels (but can be very wide)

% remember though that Image is just an id. Actual data is in kernel.

% n+1 so can have width of last char

<<struct Fontchar>>=
struct	Fontchar
{
    // character coordinates in Subfont.bits
    int		x;		/* left edge of bits */
    uchar	top;		/* first non-zero scan-line */
    uchar	bottom;		/* last non-zero scan-line + 1 */

    // adjustments to make on drawing point coordinates in destination
    schar	left;		/* offset of baseline */
    uchar	width;		/* width of baseline */
};
@
\t FIGURE, the comment of Subfont explains things quite good actually.

% cachechars(2): source
% "The pixels to be displayed for character c are in the
% rectangle (i->x, i->top, (i+1)->x, i->bottom) where i is
% &subfont->info[c]. "

% in libmemdraw/string.c, code used only by vgascreenputc, that is simpler
%  cos subfont already loaded:
%        memdraw(b, Rect(p.x + i->left, p.y + i->top, 
%                        p.x + i->left + (i[1].x -i[0].x), p.y+i->bottom),
%                  color, cp, f->bits, Pt(i->x, i->top), SoverD);


\l not always same top and bottom? no cos chars have different
\l  height and width and interspacing rules, so need adjustments?

% target:
% "When a character is displayed at Point p in an
% image, the character rectangle is placed at (p.x + i->left, p.y) and
% the next character of the string is displayed at (p.x + i->width, p.y)"

\l why left and width different from Fontchar.x and Fontchar.x + 1 ?


<<[[Subfont]] other fields>>=
uchar		height;		/* height of image */
char		ascent;		/* top of image to baseline */
@
\l why different size than the one in Font? why not short here too?


\subsection{Font image cache}


<<[[Font]] character cache fields>>=
// ref_own<Image>, growing image
Image		*cacheimage;
@
% allocimage(d, Rect(0, 0, ncache*wid, f->height), CHAN1(CGrey, depth), 0, 0);
% will contain many glyphs! side by side.

% kernel side! finally. additional info regarding Font.cacheimage->id
<<[[DImage]] font fields>>=
// growing_hash<Rune, ref_own<Fchar>> (size = DImage.nfchar)
FChar*      fchar;
int     nfchar;
@
%// growing_array<option<ref_own<Fchar>>> (size = DImage.nfchar)
% map Rune hashcode actually to FChar via big array. 
% Hashing done user side actually. 
% populated by loadchar().

% can contain glyphs of different subfonts!

% merge with Fontchar? no, this is different cos contain full info,
%  no need to do the x+1 gymnatstic.
<<struct FChar>>=
struct FChar
{
    // Rectangle in Font.cacheimage
    int     minx;   /* left edge of bits */
    int     maxx;   /* right edge of bits */
    uchar   miny;   /* first non-zero scan-line */
    uchar   maxy;   /* last non-zero scan-line + 1 */

    schar   left;   /* offset of baseline */
    uchar   width;  /* width of baseline */
};
@
\l could use a rectangle

% More later.

% FIGURE where see big soft archi picture? where see glyphs
%  from loaded subfonts copies into cacheimage?

<<[[DImage]] font fields>>=
int     ascent;
@
% many places the font is actually a DImage*



\section{Additional (user) initializations}
% client side only

% initdraw() and geninitdraw() take a [[fontname]] parameter.
% If not set then /env/font is used for default fontname. if nothing
% then create font with only default subfont.

<<[[geninitdraw()]] locals>>=
Subfont *df;
@
\t rename sf

<<[[geninitdraw()]] set up font>>=
/*
 * Set up default font
 */

// Set up default subfont
df = getdefont(display);
display->defaultsubfont = df;
<<[[geninitdraw()]] sanity check df>>

// Set up default font
<<[[geninitdraw()]] read fontname if fontname was nil>>
<<[[geninitdraw()]] if fontname still nil>>
else{
    font = openfont(display, fontname);	/* BUG: grey fonts */
    <<[[geninitdraw()]] sanity check font>>
}
display->defaultfont = font;
@








<<[[geninitdraw()]] sanity check df>>=
if(df == nil){
    fprint(2, "imageinit: can't open default subfont: %r\n");
Error:
    closedisplay(display);
    display = nil;
    return ERROR_NEG1;
}
@

<<[[geninitdraw()]] sanity check font>>=
if(font == nil){
    fprint(2, "imageinit: can't open font %s: %r\n", fontname);
    goto Error;
}
@

\subsection{Default subfont, [[getdefont()]]}

% defontdata in libdraw/defont.c, big, "lucm/latin1.9, in uncompressed form"

<<global sizeofdefont>>=
int	sizeofdefont = sizeof defontdata;
@


% initdraw -> geninitdraw -> <>
% ctor Subfont (other = ?)
<<function getdefont>>=
Subfont*
getdefont(Display *d)
{
    Subfont *f; // TODO sf
    Image *i;
    Rectangle r;
    int ld;
    char *p, *hdr;
    int n;
    Fontchar *fc;

    p = (char*)defontdata;
    <<[[getdefont()]] adjust p if not word-aligned>>

    ld = atoi(p+0*12);
    r.min.x = atoi(p+1*12);
    r.min.y = atoi(p+2*12);
    r.max.x = atoi(p+3*12);
    r.max.y = atoi(p+4*12);

    i = allocimage(d, r, drawld2chan[ld], false, 0);
    <<[[getdefont()]] sanity check i>>

    p += 5*12;
    n = loadimage(i, r, (byte*)p, (defontdata + sizeofdefont)-(uchar*)p);
    <<[[getdefont()]] sanity check n>>

    hdr = p+n;
    n = atoi(hdr);
    p = hdr+3*12;
    fc = malloc(sizeof(Fontchar)*(n+1));
    <<[[getdefont()]] sanity check fc>>
    _unpackinfo(fc, (byte*)p, n);

    f = allocsubfont("*default*", n, atoi(hdr+1*12), atoi(hdr+2*12), fc, i);
    <<[[getdefont()]] sanity check f>>
    return f;
}
@
\t use defontname instead of default here!
% n+1 for fake last entry so can compute width of last char.
% 12 bytes each time for integer as a string.
% last two numbers are height and ascent I think.
% related = getmemdefont, almost copy paste but with Memimage instead of Image

% note that loadimage load the image in the kernel!
% this means also that every graphic app actually loads the
% same font in the kernel. Sharing there?

<<function _unpackinfo>>=
void
_unpackinfo(Fontchar *fc, byte *p, int n)
{
    int j;

    for(j=0;  j<=n;  j++){
        fc->x      = p[0]|(p[1]<<8);
        fc->top    = p[2];
        fc->bottom = p[3];

        fc->left   = p[4];
        fc->width  = p[5];

        fc++;
        p += 6;
    }
}
@
% >> >>  >> 
% <= n cos fill also last entry!





<<[[getdefont()]] adjust p if not word-aligned>>=
/*
 * make sure data is word-aligned.  this is true with Plan 9 compilers
 * but not in general.  the byte order is right because the data is
 * declared as char*, not ulong*.
 */
n = (int)(uvlong)p & 3;				/* stupid ape */
if(n != 0){
    memmove(p+(4-n), p, sizeofdefont-n);
    p += 4-n;
}
@



<<[[getdefont()]] sanity check i>>=
if(i == nil)
    return nil;
@

<<[[getdefont()]] sanity check n>>=
if(n < 0){
    freeimage(i);
    return nil;
}
@
<<[[getdefont()]] sanity check fc>>=
if(fc == nil){
    freeimage(i);
    return nil;
}
@
<<[[getdefont()]] sanity check f>>=
if(f == nil){
    freeimage(i);
    free(fc);
    return nil;
}
@






% getdefont -> <>
%ctor
<<function allocsubfont>>=
Subfont*
allocsubfont(char *name, int n, int height, int ascent, Fontchar *info, Image *i)
{
    Subfont *f; // TODO sf

    <<[[allocsubfont()]] sanity check height>>

    f = malloc(sizeof(Subfont));
    <<[[allocsubfont()]] sanity check f>>
    f->n = n;
    f->height = height;
    f->ascent = ascent;
    f->info = info;
    f->bits = i;
    f->ref = 1;
    <<[[allocsubfont()]] install subfont if name>>
    else
        f->name = nil;
    return f;
}
@
% lookup subfont which is *default* here will be explained later.
% but actually not really used because lookup will fail, and so it
% will call installsubfont, but anyway there is special code later
% to lookup *default* to look in Display->defaultsubfont so
% there is no really need for installsubfont here.


<<[[allocsubfont()]] sanity check height>>=
assert(height != 0 /* allocsubfont */);
@

<<[[allocsubfont()]] sanity check f>>=
if(f == nil)
    return nil;
@

%allocsubfont important! allow to share fonts between programs.






\subsection{Default font}

\subsubsection{[[openfont()]]}

% saw in geninitdraw:
%    font = openfont(display, fontname);	/* BUG: grey fonts */


% when passed a fontname (or /env/font non empty).
% (in the end call buildfont)
% pass the font filename (foo.font)

% used by many programs
<<function openfont>>=
Font*
openfont(Display *d, char *name)
{
    Font *fnt;
    fdt fd;
    int i, n;
    char *buf;
    Dir *dir;

    fd = open(name, OREAD);
    <<[[openfont()]] sanity check fd>>

    // n = filename_size(fd)
    dir = dirfstat(fd);
    <<[[openfont()]] sanity check dir>>
    n = dir->length;
    free(dir);

    buf = malloc(n+1);
    <<[[openfont()]] sanity check buf>>
    buf[n] = '\0';
    i = read(fd, buf, n);
    close(fd);
    <<[[openfont()]] sanity check i>>

    fnt = buildfont(d, buf, name);

    free(buf);
    return fnt;
}
@

% call buildfont where buf should contain spec of font (list of subfonts)



<<[[openfont()]] sanity check fd>>=
if(fd < 0)
    return nil;
@
<<[[openfont()]] sanity check dir>>=
if(dir == nil){
Err0:
    close(fd);
    return nil;
}
@

<<[[openfont()]] sanity check buf>>=
if(buf == nil)
    goto Err0;
@

<<[[openfont()]] sanity check i>>=
if(i != n){
    free(buf);
    return nil;
}
@

\subsubsection{[[/env/font]]}

<<[[geninitdraw()]] locals>>=
fdt fd;
int n;
char buf[128];
@

<<[[geninitdraw()]] read fontname if fontname was nil>>=
if(fontname == nil){
    fd = open("/env/font", OREAD);
    if(fd >= 0){
        n = read(fd, buf, sizeof(buf));
        if(n>0 && n < sizeof buf-1){
            buf[n] = '\0';
            fontname = buf;
        }
        close(fd);
    }
}
@

\subsubsection{font from default subfont}

% if no fontname passed and nothing in /env/font, then arrive here
%  and get fontinfo from default subfont

<<[[geninitdraw()]] if fontname still nil>>=
/*
 * Build fonts with caches==depth of screen, for speed.
 * If conversion were faster, we'd use 0 and save memory.
 */
if(fontname == nil){
    snprint(buf, sizeof buf, "%d %d\n0 %d\t%s\n", 
        df->height, df->ascent,
        df->n-1, deffontname);
    //BUG: Need something better for this	installsubfont("*default*", df);
    font = buildfont(display, buf, deffontname);
    <<[[geninitdraw()]] sanity check font part2>>
}
@
\l comment means ??

% format parsed later by buildfont! 0 %d, min and max, just one
% subfont line.

<<global deffontname>>=
static char deffontname[] = "*default*";
@
% but who installed this subfont? getdefont!
% so sharing by using shared name!


<<[[geninitdraw()]] sanity check font part2>>=
if(font == nil){
    fprint(2, "imageinit: can't open default font: %r\n");
    goto Error;
}
@

%\subsection{Kernel initializations}
% there is some, but for Graphical text mode, see adv topics


\section{Font allocation}

\subsection{[[buildfont()]]}

% This is code still in userspace.
% Actually font allocation involves no call to the kernel.
% Just load spec about font and its subfonts.
% Loading of subfonts (and of characters in the character cache)
%   is done on demand when drawing text.

% buf specify information about font, format with spacing and newline
%  so code below does some limited parsing.
% ctor of Font
% openfont -> <>
<<function buildfont>>=
Font*
buildfont(Display *d, char *buf, char *name)
{
    Font *fnt;
    char *s, *t;
    ulong min, max;
    Cachefont *c;
    int offset;
    <<[[buildfont()]] other locals>>

    s = buf;

    fnt = malloc(sizeof(Font));
    <<[[buildfont()]] sanity check fnt>>
    memset(fnt, 0, sizeof(Font));

    fnt->display = d;
    fnt->name = strdup(name);

    <<[[buildfont()]] allocate cache>>
    <<[[buildfont()]] initialize cache>>

    fnt->height = strtol(s, &s, 0);
    s = skip(s);
    fnt->ascent = strtol(s, &s, 0);
    s = skip(s);
    <<[[buildfont()]] sanity check fnt fields part2>>

    fnt->width = 0;

    fnt->sub = nil;
    fnt->nsub = 0;
    do{
        /* must be looking at a number now */
        <<[[buildfont()]] sanity check s content>>
        min = strtol(s, &s, 0);
        s = skip(s);
        /* must be looking at a number now */
        <<[[buildfont()]] sanity check s content>>
        max = strtol(s, &s, 0);
        s = skip(s);
        <<[[buildfont()]] sanity check min and max>>

        <<[[buildfont()]] set optional offset>>

        fnt->sub = realloc(fnt->sub, (fnt->nsub+1)*sizeof(Cachefont*));
        <<[[buildfont()]] sanity check fnt fields part3>>

        c = malloc(sizeof(Cachefont));
        <<[[buildfont()]] sanity check c>>
        fnt->sub[fnt->nsub] = c;
        fnt->nsub++;

        c->min = min;
        c->max = max;
        c->offset = offset;

        t = s;
        while(*s && *s!=' ' && *s!='\n' && *s!='\t')
            s++;
        *s++ = '\0';

        c->name = strdup(t);
        c->subfontname = nil; // full filename computed lazily later
        <<[[buildfont()]] sanity check c name field>>
        s = skip(s);
    } while(*s);
    return fnt;
}
@
%ocaml: use regexps



<<[[buildfont()]] set optional offset>>=
t = s;
offset = strtol(s, &t, 0);
if(t>s && (*t==' ' || *t=='\t' || *t=='\n'))
    s = skip(t);
else
    offset = 0;
@

<<function skip>>=
static char*
skip(char *s)
{
    while(*s==' ' || *s=='\n' || *s=='\t')
        s++;
    return s;
}
@






<<[[buildfont()]] sanity check fnt>>=
if(fnt == nil)
    return nil;
@

<<[[buildfont()]] sanity check fnt fields part1>>=
if(fnt->name==nil || fnt->cache==nil || fnt->subf==nil){
Err2:
    free(fnt->name);
    free(fnt->cache);
    free(fnt->subf);
    free(fnt->sub);
    free(fnt);
    return 0;
}
@
<<[[buildfont()]] sanity check fnt fields part2>>=
if(fnt->height <= 0 || fnt->ascent <= 0){
    werrstr("bad height or ascent in font file");
    goto Err2;
}
@

<<[[buildfont()]] sanity check s content>>=
if(*s<'0' || '9'<*s){
    werrstr(badform, s-buf);
    goto Err3;
}
@
<<[[buildfont()]] other locals>>=
char badform[] = "bad font format: number expected (char position %d)";
@

<<[[buildfont()]] sanity check min and max>>=
if(*s=='\0' || min>=Runemax || max>=Runemax || min>max){
    werrstr("illegal subfont range");
Err3:
    freefont(fnt);
    return nil;
}
@

<<[[buildfont()]] sanity check fnt fields part3>>=
if(fnt->sub == nil){
    /* realloc manual says fnt->sub may have been destroyed */
    fnt->nsub = 0;
    goto Err3;
}
@
<<[[buildfont()]] sanity check c>>=
if(c == nil)
    goto Err3;
@
<<[[buildfont()]] sanity check c name field>>=
if(c->name == nil){
    free(c);
    goto Err3;
}
@

\subsection{[[freefont()]]}

% program user | buildfont (when error) -> <>
% dtor
<<function freefont>>=
void
freefont(Font *f)
{
    int i;
    Cachefont *c;
    Subfont *s;

    <<[[freefont()]] sanity check f>>

    for(i=0; i<f->nsub; i++){
        c = f->sub[i];
        free(c->name);
        free(c->subfontname);
        free(c);
    }
    free(f->sub);

    <<[[freefont()]] free cache>>

    free(f->name);
    free(f);
}
@

<<[[freefont()]] sanity check f>>=
if(f == nil)
    return;
@
% should raise a warning instead



% dtor
% freefont | agefont -> <>
<<function freesubfont>>=
void
freesubfont(Subfont *f)
{
    <<[[freesubfont()]] sanity check f>>
    f->ref--;
    if(f->ref > 0)
        return;

    // else
    uninstallsubfont(f);
    free(f->info);	/* note: f->info must have been malloc'ed! */
    freeimage(f->bits);
    free(f);
}
@
% how can have multiple refs? in c2fsubfont, in lookupfont
% subfonts can be shared in different fonts (indeed some foo.font
% mention the same ranges and subfonts)
\t use sf not f

% uninstallsubfont? 

<<[[freesubfont()]] sanity check f>>=
if(f == nil)
    return;
@








\section{Drawing text}
% and rune

%https://engineering.eventbrite.com/its-2015-and-drawing-text-is-still-hard-webgl-threejs/

\subsection{API}

% variants = string vs rune, maxlen vs smaller n, SoverD vs op, nobg vs bg

<<function string>>=
Point
string(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s)
{
    return _string(dst, pt, src, sp, f, s, nil, 1<<24, dst->clipr, nil, ZP, SoverD);
}
@
% 1 << 24 = length (= infinite)

% return point so can know from where to draw the next string
% (so no need to call stringwidth on what was just drawn)

<<function stringop>>=
Point
stringop(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, Drawop op)
{
    return _string(dst, pt, src, sp, f, s, nil, 1<<24, dst->clipr, nil, ZP, op);
}
@

<<function stringn>>=
Point
stringn(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, int len)
{
    return _string(dst, pt, src, sp, f, s, nil, len, dst->clipr, nil, ZP, SoverD);
}
@
% xxxn, limit length

<<function stringnop>>=
Point
stringnop(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, int len, Drawop op)
{
    return _string(dst, pt, src, sp, f, s, nil, len, dst->clipr, nil, ZP, op);
}
@




<<function runestring>>=
Point
runestring(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r)
{
    return _string(dst, pt, src, sp, f, nil, r, 1<<24, dst->clipr, nil, ZP, SoverD);
}
@

<<function runestringop>>=
Point
runestringop(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r, Drawop op)
{
    return _string(dst, pt, src, sp, f, nil, r, 1<<24, dst->clipr, nil, ZP, op);
}
@

<<function runestringn>>=
Point
runestringn(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r, int len)
{
    return _string(dst, pt, src, sp, f, nil, r, len, dst->clipr, nil, ZP, SoverD);
}
@

<<function runestringnop>>=
Point
runestringnop(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r, int len, Drawop op)
{
    return _string(dst, pt, src, sp, f, nil, r, len, dst->clipr, nil, ZP, op);
}
@


% could mv in adv topics the xxxbg()? will save some code also in
% marshalling/unmarshalling

<<function stringbg>>=
Point
stringbg(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, Image *bg, Point bgp)
{
    return _string(dst, pt, src, sp, f, s, nil, 1<<24, dst->clipr, bg, bgp, SoverD);
}
@

<<function stringbgop>>=
Point
stringbgop(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, Image *bg, Point bgp, int op)
{
    return _string(dst, pt, src, sp, f, s, nil, 1<<24, dst->clipr, bg, bgp, op);
}
@

<<function stringnbg>>=
Point
stringnbg(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, int len, Image *bg, Point bgp)
{
    return _string(dst, pt, src, sp, f, s, nil, len, dst->clipr, bg, bgp, SoverD);
}
@

<<function stringnbgop>>=
Point
stringnbgop(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, int len, Image *bg, Point bgp, int op)
{
    return _string(dst, pt, src, sp, f, s, nil, len, dst->clipr, bg, bgp, op);
}
@

<<function runestringbg>>=
Point
runestringbg(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r, Image *bg, Point bgp)
{
    return _string(dst, pt, src, sp, f, nil, r, 1<<24, dst->clipr, bg, bgp, SoverD);
}
@

<<function runestringbgop>>=
Point
runestringbgop(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r, Image *bg, Point bgp, int op)
{
    return _string(dst, pt, src, sp, f, nil, r, 1<<24, dst->clipr, bg, bgp, op);
}
@

<<function runestringnbg>>=
Point
runestringnbg(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r, int len, Image *bg, Point bgp)
{
    return _string(dst, pt, src, sp, f, nil, r, len, dst->clipr, bg, bgp, SoverD);
}
@

<<function runestringnbgop>>=
Point
runestringnbgop(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r, int len, Image *bg, Point bgp, int op)
{
    return _string(dst, pt, src, sp, f, nil, r, len, dst->clipr, bg, bgp, op);
}
@


\subsection{Marshalling}

<<constant Max>>=
Max = 100
@
% bad name, too general

% idea is process string piece by piece for one subfont.
% cachechars which will set f->cacheimage and create some data
%  structure server side.
% Then draw with this subfont in a loop the chars.
%  Part of info about subfont is stored in kernel.
% cachechars fill cbuf with a set of index corresponding to each
% Rune.
% so cachechars and _string works in tandem.
\l why not do everything userside? because want to batch in one call
\l  drawing many characters, so need char pos info in Kernel.
\l  (hmm could pass the Fontchar info)

<<function _string>>=
Point
_string(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, Rune *r, int len, Rectangle clipr, Image *bg, Point bgp, Drawop op)
{
    Rune **rptr;
    char **sptr;
    int m, n, max;
    ushort cbuf[Max], *c, *ec;
    byte *b;
    int wid;
    <<[[_string()]] other locals>>

    <<[[_string()]] non unicode string handling, set sptr and rptr>>
    else
      rptr = &r;

    while((*s || *r) && len){
        <<[[_string()]] set max>>

        // will trigger many calls to loadchar() for the same subfont
        n = cachechars(f, sptr, rptr, cbuf, max, &wid, &subfontname);

        if(n > 0){
            _setdrawop(dst->display, op);

            // string: 's' dstid[4] srcid[4] fontid[4] P[2*4] clipr[4*4] sp[2*4] ni[2] ni*(index[2]) 

            m = 47+2*n;
            <<[[_string()]] if bg part1>>
            b = bufimage(dst->display, m);
            <<[[_string()]] sanity check b>>
            <<[[_string()]] if bg part2>>
            else
                b[0] = 's';
            BPLONG(b+1, dst->id);
            BPLONG(b+5, src->id);
            BPLONG(b+9, f->cacheimage->id);
            BPLONG(b+13, pt.x);
            BPLONG(b+17, pt.y + f->ascent);
            BPLONG(b+21, clipr.min.x);
            BPLONG(b+25, clipr.min.y);
            BPLONG(b+29, clipr.max.x);
            BPLONG(b+33, clipr.max.y);
            BPLONG(b+37, sp.x);
            BPLONG(b+41, sp.y);
            BPSHORT(b+45, n);
            b += 47;
            <<[[_string()]] if bg part3>>
            // index of the set of characters to draw (hashcode of Rune)
            ec = &cbuf[n];
            for(c=cbuf; c<ec; c++, b+=2)
                BPSHORT(b, *c);

            pt.x += wid;
            bgp.x += wid;

            agefont(f);

            len -= n; // progress
        }
        <<[[_string()]] if subfontname>>
    }
    return pt;
}
@
% return pt!

% cachechars may return 0 when did a fontresize. moreover in that case
% subfontname should have been set.


% can be either string or rune. but in the rest we will focus
%  on rune.
<<[[_string()]] non unicode string handling, set sptr and rptr>>=
if(s == nil){
    s = "";
    sptr = nil;
}else
    sptr = &s;

if(r == nil){
    r = (Rune*) L"";
    rptr = nil;
}
@
% else rptr = &r;


<<[[_string()]] set max>>=
max = Max;
if(len < max)
    max = len;
@
% min(len, Max)



<<[[_string()]] if bg part1>>=
// stringbg: 'x' dstid[4] srcid[4] fontid[4] P[2*4] clipr[4*4] sp[2*4] ni[2] bgid[4] bgpt[2*4] ni*(index[2])
if(bg)
    m += 4+2*4;
@

<<[[_string()]] if bg part2>>=
if(bg)
    b[0] = 'x';
@

<<[[_string()]] if bg part3>>=
if(bg){
    BPLONG(b, bg->id);
    BPLONG(b+4, bgp.x);
    BPLONG(b+8, bgp.y);
    b += 12;
}
@





<<[[_string()]] sanity check b>>=
if(b == nil){
    fprint(2, "string: %r\n");
    break;
}
@





% cachechars
% _getsubfont

\subsection{Unmarshalling}

<<[[drawmesg()]] locals>>=
DImage *font;
Memimage  *bg;
int ci;
@

<<[[drawmesg()]] cases>>=
/* string: 's' dstid[4] srcid[4] fontid[4] P[2*4] clipr[4*4] sp[2*4] ni[2] ni*(index[2]) */
/* stringbg: 'x' dstid[4] srcid[4] fontid[4] P[2*4] clipr[4*4] sp[2*4] ni[2] bgid[4] bgpt[2*4] ni*(index[2]) */
case 's':
case 'x':
    printmesg(fmt="LLLPRPs", a, false);
    m = 1+4+4+4+2*4+4*4+2*4+2;
    <<[[drawmesg()]] when draw string, if bg part1>>
    <<[[drawmesg()]] sanity check n with m>>
    dst = drawimage(client, a+1);
    dstid = BGLONG(a+1);
    src = drawimage(client, a+5);
    font = drawlookup(client, BGLONG(a+9), true);
    <<[[drawmesg()]] when draw string, sanity check font>>
    drawpoint(&p, a+13);
    drawrectangle(&r, a+21);
    drawpoint(&sp, a+37);
    ni = BGSHORT(a+45);
    u = a+m;
    m += ni*2;
    <<[[drawmesg()]] sanity check n with m>>
    <<[[drawmesg()]] change dst clipr>>
    op = drawclientop(client);
    bg = dst;
    <<[[drawmesg()]] when draw string, if paint background>>
    q = p;
    while(--ni >= 0){
        ci = BGSHORT(u);
        <<[[drawmesg()]] when draw string, sanity check ci>>
        q = drawchar(dst, bg, q, src, &sp, font, ci, op); // The call
        u += 2;
    }
    <<[[drawmesg()]] restore dst clipr>>
    <<[[drawmesg()]] when draw text, dstflush>>
    continue;
@



% font = drawlookup(client, BGLONG(a+9), true);
%  true?


<<[[drawmesg()]] change dst clipr>>=
clipr = dst->clipr;
dst->clipr = r;
@
<<[[drawmesg()]] restore dst clipr>>=
dst->clipr = clipr;
@
% similar to the one for _memimageline, but with clipr and r instead
%  of oclipr and clipr


<<[[drawmesg()]] when draw string, if bg part1>>=
if(*a == 'x')
    m += 4+2*4;
@

<<[[drawmesg()]] when draw string, if paint background>>=
if(*a == 'x'){
    /* paint background */
    bg = drawimage(client, a+47);
    drawpoint(&q, a+51);
    r.min.x = p.x;
    r.min.y = p.y - font->ascent;
    r.max.x = p.x;
    r.max.y = r.min.y+Dy(font->image->r);
    j = ni;
    while(--j >= 0){
        ci = BGSHORT(u);
        <<[[drawmesg()]] when draw string, sanity check ci>>
        r.max.x += font->fchar[ci].width;
        u += 2;
    }
    memdraw(dst, r, bg, q, memopaque, ZP, op); // The call
    u -= 2*ni;
}
@

% fchar later



<<[[drawmesg()]] when draw string, sanity check font>>=
if(font == nil)
    error(Enodrawimage);
if(font->nfchar == 0)
    error(Enotfont);
@

<<[[drawmesg()]] when draw string, sanity check ci>>=
if(ci<0 || ci>=font->nfchar){
    dst->clipr = clipr;
    error(Eindex);
}
@
% nfchar later



\subsection{Algorithm}

% note that font below is actually a DImage!
% it has a fchar field that is populated by cachechars and loadchar
% we will see soon.

<<function drawchar>>=
Point
drawchar(Memimage *dst, Memimage *rdst, Point p, Memimage *src, Point *sp, DImage *font, int index, int op)
{
    FChar *fc;
    Rectangle r;
    Point sp1;
    <<[[drawchar()]] other locals>>

    fc = &font->fchar[index];

    r.min.x = p.x + fc->left;
    r.min.y = p.y - (font->ascent - fc->miny);
    r.max.x = r.min.x + (fc->maxx - fc->minx);
    r.max.y = r.min.y + (fc->maxy - fc->miny);

    sp1.x = sp->x + fc->left;
    sp1.y = sp->y + fc->miny;

    <<[[drawchar()]] optimization when possible>>
    else{
    fallback:
        memdraw(dst, r, src, sp1, font->image, Pt(fc->minx, fc->miny), op);
    }

    p.x   += fc->width;
    sp->x += fc->width;
    return p;
}
@
% return point so can know from where to start for next char.

% see also chardraw which is an optimisation?

\section{Text width}

\subsection{API}

<<function stringwidth>>=
int
stringwidth(Font *f, char *s)
{
    return _stringnwidth(f, s, nil, 1<<24);
}
@
% >>

<<function stringnwidth>>=
int
stringnwidth(Font *f, char *s, int len)
{
    return _stringnwidth(f, s, nil, len);
}
@


<<function stringsize>>=
Point
stringsize(Font *f, char *s)
{
    return Pt(_stringnwidth(f, s, nil, 1<<24), f->height);
}
@
% >>


<<function runestringnwidth>>=
int
runestringnwidth(Font *f, Rune *r, int len)
{
    return _stringnwidth(f, nil, r, len);
}
@

<<function runestringwidth>>=
int
runestringwidth(Font *f, Rune *r)
{
    return _stringnwidth(f, nil, r, 1<<24);
}
@
% >>

<<function runestringsize>>=
Point
runestringsize(Font *f, Rune *r)
{
    return Pt(_stringnwidth(f, nil, r, 1<<24), f->height);
}
@
% >> >> >> >> >> >> >> >>


\subsection{Algorithm}

<<enum _anon_ (lib_graphics/libdraw/stringwidth.c)>>=
enum { Max = 64 };
@
% not sure why dont reuse the Max used in string.c

% lots of dupe with _string hence some same chunkname below

<<function _stringnwidth>>=
int
_stringnwidth(Font *f, char *s, Rune *r, int len)
{
    Rune **rptr;
    char **sptr;
    int wid, twid;
    int n, max, l;
    ushort cbuf[Max];
    char *subfontname;
    <<[[_stringnwidth()]] other locals>>

    <<[[_string()]] non unicode string handling, set sptr and rptr>>
    else
        rptr = &r;

    twid = 0;
    while(len > 0 && (*s || *r)){
        <<[[_string()]] set max>>
        n = 0;
        while((l = cachechars(f, sptr, rptr, cbuf, max, &wid, &subfontname)) <= 0){
            <<[[_stringnwidth()]] if cachechars failed too much>>
            <<[[_stringnwidth()]] if subfontname>>
        }
        agefont(f);

        twid += wid;
        len -= l; // progress
    }
    return twid;
}
@
% lots of code in common with _string


<<[[_stringnwidth()]] other locals>>=
char *name;
Rune rune;
@

<<[[_stringnwidth()]] if cachechars failed too much>>=
if(++n > 10){
    if(*r)
        rune = *r;
    else
        chartorune(&rune, s);
    if(f->name != nil)
        name = f->name;
    else
        name = "unnamed font";
    fprint(2, "stringwidth: bad character set for rune 0x%.4ux in %s\n", rune, name);
    return twid;
}
@

% no calls to draw? actually yes, because of cachechars can have
% some loadchar or fontresize.




\section{Character cache}
\n too important opti to be put in adv topics

% need that mainly because unicode I think. Otherwise could have
% an array of 200 entries (printable ascii chars). It would be fine.

% cachechars(2)

<<enum _anon_ (include/draw.h)6>>=
enum
{
    /* starting values */
    <<constant NFCACHE>>
    <<constant NFLOOK>>
    <<constant NFSUBF>>

    /* max value */
    <<constant MAXFCACHE>>
    <<constant MAXSUBF>>

    /* deltas */
    <<constant DSUBF>>

    /* expiry ages */
    SUBFAGE	=	10000,
    CACHEAGE =	10000
};
@
% >> >>


<<[[Font]] character cache fields>>=
ulong		age;	/* increasing counter; used for LRU */
@
% used for character cache and subfont cache?
<<[[buildfont()]] initialize cache>>=
fnt->age = 1;
@
% ok so when filled with first entry? cachechars?

<<[[freefont()]] free cache>>=
freeimage(f->cacheimage);
@



\subsection{Character cache, [[Cacheinfo]]}

<<[[Font]] character cache fields>>=
// growing_hash<Rune, Cacheinfo> (size = Font.ncache, bucketsize = NFLOOK)
Cacheinfo	*cache;
int		ncache;	/* size of cache */
@
% actually hash and bucket = subarray of size NFLOOK
\t rename fchar? after all it mimics fchar in the kernel

% hashing function = ?

% this is user side. There is a corresponding one kernel side!
% saw it before, fchar.

% int cos return index in cache big array which should match the one
% in DImage.fchar

<<struct Cacheinfo>>=
struct Cacheinfo
{
    // the key
    Rune		value;	/* value of character at this slot in cache */

    // the values
    ushort		x;		/* left edge of bits */
    byte		width;		/* width of baseline */
    schar		left;		/* offset of baseline */

    ushort		age;
};
@
\l rename Runeinfo? or Charinfo? 
% seems redundant with Fontchar, could not just have a Fontchar ref here?
%  anyway the Fontchar will be needed to send the whole info to the kernel?


<<[[buildfont()]] allocate cache>>=
fnt->ncache = NFCACHE+NFLOOK;
fnt->cache = malloc(fnt->ncache * sizeof(fnt->cache[0]));
@

<<constant NFCACHE>>=
LOG2NFCACHE =	6,
NFCACHE =	(1<<LOG2NFCACHE),	/* #chars cached */
@
% 64 = enough for 26(A-Z) + 26(a-z) + 10(0-9) and some punctuations.
<<constant NFLOOK>>=
NFLOOK =	5,			/* #chars to scan in cache */
@
<<constant MAXFCACHE>>=
MAXFCACHE =	1024+NFLOOK,		/* upper limit */
@

<<[[buildfont()]] initialize cache>>=
<<[[buildfont()]] sanity check fnt fields part1>>
memset(fnt->subf, 0, fnt->nsubf * sizeof(fnt->subf[0]));
memset(fnt->cache, 0, fnt->ncache * sizeof(fnt->cache[0]));
@


<<[[freefont()]] free cache>>=
free(f->cache);
@


\subsection{Loading characters, [[cachechars()]]}

% fill cp with index to char in subfont.
% return number of characters processed (or 0)
% _string | _stringwidth -> <>
<<function cachechars>>=
int
cachechars(Font *f, char **ss, Rune **rr, ushort *cp, int max, int *wp, char **subfontname)
{
    Rune *rp;
    char *sp;
    Rune r;
    int w, rw;
    int wid = 0;
    int i;
    int h; // index in Font.cache
    int sh; // rune hashcode
    Cacheinfo *c, *ec;
    <<[[cachechars()]] other locals>>

    <<[[cachechars()]] non unicode string handling part1>>
    else{
        sp = "";
        rp = *rr;
    }
    *subfontname = nil;

    for(i=0; i<max && (*sp || *rp); sp+=w, rp+=rw){
        <<[[cachechars()]] non unicode string handling part2>>
        else{
            r = *rp;
            w = 0;
            rw = 1;
        }

        // sh = hash_code(r)
        sh = (17 * (uint)r) & (f->ncache-NFLOOK-1);

        // c,h = lookup(r, sh, f->cache)
        c = &f->cache[sh];
        ec = c+NFLOOK;
        h = sh;
        while(c < ec){
            if(c->value==r && c->age)
                goto Found;
            c++;
            h++;
        }
        // this can break out of the loop
        <<[[cachechars()]] when rune not in cache, loads it>>
    
        Found:
        wid += c->width;
        c->age = f->age;
        cp[i] = h;
        i++;
    }
    <<[[cachechars()]] non unicode string handling part3>>
    else
        *rr = rp;
    *wp = wid;

    return i;
}
@

% so cp[i] = h means it's the index in Font.cache


%        sh = (17 * (uint)r) & (f->ncache-NFLOOK-1);
% so how does it work for a, b, c, d, e
% will spread around? or already cause a resize?

<<[[cachechars()]] non unicode string handling part1>>=
if(ss){
    sp = *ss;
    rp = L"";
}
@
<<[[cachechars()]] other locals>>=
Rune vr;
@
<<[[cachechars()]] non unicode string handling part2>>=
if(ss){
    r = *(uchar*)sp;
    if(r < Runeself)
        w = 1;
    else{
        w = chartorune(&vr, sp);
        r = vr;
    }
    rw = 0;
}
@
<<[[cachechars()]] non unicode string handling part3>>=
if(ss)
    *ss = sp;
@






\subsection{Loading one new character, [[loadchar()]]}

<<[[cachechars()]] other locals>>=
int ld;
@


<<[[cachechars()]] when rune not in cache, loads it>>=
<<[[cachechars()]] find oldest entry [[c]] with age a in cache>>
<<[[cachechars()]] if age too recent then resize cache>>
<<[[cachechars()]] if same age>>
// else

ld = loadchar(f, r, c, h, i, subfontname);
<<[[cachechars()]] if could not load char>>
// else
c = &f->cache[h];	/* may have reallocated f->cache */
@
% pass i, character number cos 0 has a special role
% load in font f, rune r, cacheinfo c, index h, character #i, 
%  and return error code and subfontname loaded if any.



% this will cause to break out of the loop
<<[[cachechars()]] if could not load char>>=
if(ld <= 0){
    <<[[cachechars()]] if loadchar failed>>
    break;
}
@
% break so will work for next loop iteration in cachechars.
% loadchar will return -1 when are outside range of current subfont
%  and so neeed to load a new subfont.
%  In that case subfontname will be set.




<<[[cachechars()]] if loadchar failed>>=
if(ld == 0) // when failed, but why can fail?
    continue;
@







<<[[cachechars()]] other locals>>=
int th;
Cacheinfo *tc;
ulong a;
@

<<[[cachechars()]] find oldest entry [[c]] with age a in cache>>=
/*
 * Not found; toss out oldest entry
 */
a = ~0;
th = sh;
tc = &f->cache[th];
while(tc < ec){
    if(tc->age < a){
        a = tc->age;
        h = th;
        c = tc;
    }
    tc++;
    th++;
}
@
% again set c and h. quite simple.






% passed subfontname ref
% -1 when new subfont which should be passed to cachechars
%  and then back to _string or _stringwidth

% cachechars -> <>
<<function loadchar>>=
/* return 1 if load succeeded, 0 if failed, -1 if must retry */
error0
loadchar(Font *f, Rune r, Cacheinfo *c, int h, int noflush, char **subfontname)
{
    Rune pic; // ?? means
    Cachefont *cf;
    int i;
    int oi, wid, top, bottom;
    Fontchar *fi;
    Cachesubf *subf;
    <<[[loadchar()]] other locals>>

    pic = r;

    // Find subfont spec cf for Rune r 
    Again:
    for(i=0; i < f->nsub; i++){
        cf = f->sub[i];
        if(cf->min <= pic && pic <= cf->max)
            goto Found;
    }
    <<[[loadchar()]] if rune not handled by the font>>

    Found:
    // Now let's find the loaded subfont subf with spec cf 
    /*
     * Choose exact or oldest
     */
    oi = 0;
    subf = &f->subf[0];
    for(i=0; i < f->nsubf; i++){
        if(cf == subf->cf)
            goto Found2;
        if(subf->age < f->subf[oi].age)
            oi = i;
        subf++;
    }
    // may load and find the right subf
    <<[[loadchar()]] when the corresponding subfont is not loaded yet>>

    Found2:
    subf->age = f->age;

    /* possible overflow here, but works out okay */
    pic += cf->offset;
    pic -= cf->min;
    <<[[loadchar()]] if rune outside range>>
    fi = &subf->f->info[pic];
    <<[[loadchar()]] sanity check fontchar width>>
    wid = (fi+1)->x - fi->x;
    <<[[loadchar()]] resize cache if width too big>>

    c->value = r;
    top    = fi->top    + (f->ascent - subf->f->ascent);
    bottom = fi->bottom + (f->ascent - subf->f->ascent);
    c->width = fi->width;
    c->x = h * f->width;
    c->left = fi->left;

    <<[[loadchar()]] sanity check display>>

    <<[[loadchar()]] marshall Cacheinfo c>>
}
@
% it just loads one char at a time? seems very inefficient.
% why not do all of that computation client side instead
% pass the right rect in drawchar?



<<constant PJW>>=
#define	PJW	0	/* use NUL==pjw for invisible characters */
@
% PJW means?

<<[[loadchar()]] if rune not handled by the font>>=
TryPJW:
if(pic != PJW){
    pic = PJW;
    goto Again;
}
return ERROR_0;
@

<<[[loadchar()]] if rune outside range>>=
if(pic >= subf->f->n)
    goto TryPJW;
@

<<[[loadchar()]] sanity check fontchar width>>=
if(fi->width == 0)
    goto TryPJW;
@

<<[[loadchar()]] sanity check display>>=
if(f->display == nil)
    return OK_1;
@



\subsubsection{Marshalling}


<<[[loadchar()]] other locals>>=
byte *b;
@

<<[[loadchar()]] marshall Cacheinfo c>>=
flushimage(f->display, false);	/* flush any pending errors */

// load character: 'l' fontid[4] srcid[4] index[2] R[4*4] P[2*4] left[1] width[1]
b = bufimage(f->display, 37);
<<[[loadchar()]] sanity check b>>
b[0] = 'l';
BPLONG(b+1, f->cacheimage->id);
BPLONG(b+5, subf->f->bits->id);

// index
BPSHORT(b+9, c - f->cache); 

// destination coordinates in f->cacheimage
BPLONG(b+11, c->x);
BPLONG(b+15, top);
BPLONG(b+19, c->x + ((fi+1)->x - fi->x));
BPLONG(b+23, bottom);

// source coordinate in subf->f->bits->id
BPLONG(b+27, fi->x);
BPLONG(b+31, fi->top);
b[35] = fi->left;
b[36] = fi->width;

return OK_1;
@

<<[[loadchar()]] sanity check b>>=
if(b == nil)
    return ERROR_0;
@

\subsubsection{Unmarshalling}

<<[[drawmesg()]] locals>>=
FChar *fc;
@

<<[[drawmesg()]] cases>>=
/* load character: 'l' fontid[4] srcid[4] index[2] R[4*4] P[2*4] left[1] width[1] */
case 'l':
    printmesg(fmt="LLSRPbb", a, false);
    m = 1+4+4+2+4*4+2*4+1+1;
    <<[[drawmesg()]] sanity check n with m>>
    font = drawlookup(client, BGLONG(a+1), true);
    <<[[drawmesg()]] when load character, sanity check font>>
    src = drawimage(client, a+5);
    ci = BGSHORT(a+9);
    <<[[drawmesg()]] when load character, sanity check ci>>
    drawrectangle(&r, a+11);
    drawpoint(&p, a+27);
    memdraw(font->image, r, src, p, memopaque, p, S);

    fc = &font->fchar[ci];

    fc->minx = r.min.x;
    fc->maxx = r.max.x;
    fc->miny = r.min.y;
    fc->maxy = r.max.y;

    fc->left = a[35];
    fc->width = a[36];

    continue;
@

<<[[drawmesg()]] when load character, sanity check font>>=
if(font == nil)
    error(Enodrawimage);
if(font->nfchar == 0)
    error(Enotfont);
@

<<[[drawmesg()]] when load character, sanity check ci>>=
if(ci >= font->nfchar)
    error(Eindex);
@

%\subsubsection{Loading a new subfont part1}

%\subsubsection{Loading a new subfont part2}


\subsection{Resizing the character cache, [[fontresize()]]}
% misleading function name

% 2 reasons: 
% - too small, too many recent entries in NFLOOK window
%   so need to resize fchar
% - width different, depth different, so need to resize
%   cacheimage

<<[[Font]] other fields>>=
short		width;	/* widest so far; used in caching only */	
int		maxdepth;	/* maximum depth of all loaded subfonts */
@
\l rename to maxwidth
% need resize when one glyph has bigger width because we use thids
% width as a way to find the x coord of the nth character in cacheimage



<<[[cachechars()]] other locals>>=
int nc;
@
<<[[cachechars()]] if age too recent then resize cache>>=
if(a && (f->age - a) < 500){	/* kicking out too recent; resize */
    nc = 2*(f->ncache-NFLOOK) + NFLOOK;
    if(nc <= MAXFCACHE){
        if(i == 0)
            fontresize(f, f->width, nc, f->maxdepth);
        /* else flush first; retry will resize */
        break;
    }
    // else, no resize
}
@
% break so we re done for now for this set of chars.
% special test i == 0 because fontresize would invalidade the
%  characters already processed in cachechars which would not
%  a valid entry in fchar, so we resize only if we are the first
%  character.

% if a because at the beginning every entry has age 0 (memset(,0)

<<[[cachechars()]] if same age>>=
if(c->age == f->age)	/* flush pending string output */
    break;
@
% ???



<<[[loadchar()]] resize cache if width too big>>=
if(f->width < wid || f->width == 0 || f->maxdepth < subf->f->bits->depth){
    /*
     * Flush, free, reload (easier than reformatting f->b)
     */
    if(noflush)
        return -1;
    // else

    if(f->width < wid)
        f->width = wid;
    if(f->maxdepth < subf->f->bits->depth)
        f->maxdepth = subf->f->bits->depth;
    i = fontresize(f, f->width, f->ncache, f->maxdepth);
    if(i <= 0)
        return i;
    /* c is still valid as didn't reallocate f->cache */
}
@
% first char of cachechars, we already done some job, so resize
% not a good idea. Same that in cachechars.






\subsubsection{Marshalling}

% can resize because width/depth changed or because ncache size changed
% and in former case we need to invalidate everything.

% will generate 3 messages: allocimage, fontresize, freeimage

% cachechars | loadchar -> <>
<<function fontresize>>=
/* return whether resize succeeded && f->cache is unchanged */
static bool
fontresize(Font *f, int wid, int ncache, int depth)
{
    Cacheinfo *i;
    int ret;
    Image *new;
    uchar *b;
    Display *d;

    ret = false;
    <<[[fontresize()]] sanity check depth and wid>>
    d = f->display;
    <<[[fontresize()]] sanity check d>>

    new = allocimage(d, Rect(0, 0, ncache*wid, f->height), CHAN1(CGrey, depth), false, 0);
    <<[[fontresize()]] sanity check new>>
    flushimage(d, false);	/* flush any pending errors */

    b = bufimage(d, 1+4+4+1);
    <<[[fontresize()]] sanity check b>>
    b[0] = 'i';
    BPLONG(b+1, new->id);
    BPLONG(b+5, ncache);
    b[9] = f->ascent;
    if(flushimage(d, false) < 0){
        fprint(2, "resize: init failed: %r\n");
        freeimage(new);
        goto Return;
    }

    freeimage(f->cacheimage);
    f->cacheimage = new;

    Nodisplay:
    f->width = wid;
    f->maxdepth = depth;
    ret = true;
    <<[[fontresize()]] if need to resize the cache>>
    Return:
    memset(f->cache, 0, f->ncache*sizeof f->cache[0]);
    return ret;
}
@
% so erase all previous chars


<<[[fontresize()]] if need to resize the cache>>=
if(f->ncache != ncache){
    i = malloc(ncache*sizeof f->cache[0]);
    if(i != nil){
        ret = false;
        free(f->cache);
        f->ncache = ncache;
        f->cache = i;
    }
    /* else just wipe the cache clean and things will be ok */
}
@

<<[[fontresize()]] sanity check depth and wid>>=
if(depth <= 0)
    depth = 1;
if(wid <= 0)
    wid = 1;
@
<<[[fontresize()]] sanity check d>>=
if(d == nil)
    goto Nodisplay;
@
<<[[fontresize()]] sanity check new>>=
if(new == nil){
    fprint(2, "font cache resize failed: %r\n");
    abort();
    goto Return;
}
@

<<[[fontresize()]] sanity check b>>=
if(b == nil){
    freeimage(new);
    goto Return;
}
@



\subsubsection{Unmarshalling}

% font below is a DImage
% here we show only unmarshall for initialize font message.
% there is also code for allocimage and freeimage presented in chapter X

% fontresize!
<<[[drawmesg()]] cases>>=
/* initialize font: 'i' fontid[4] nchars[4] ascent[1] */
case 'i':
    printmesg(fmt="Llb", a, true);
    m = 1+4+4+1;
    <<[[drawmesg()]] sanity check n with m>>
    dstid = BGLONG(a+1);
    <<[[drawmesg()]] when initialize font image and cache, sanity check dstid>>
    font = drawlookup(client, dstid, true);
    <<[[drawmesg()]] when initialize font image and cache, sanity check font>>
    ni = BGLONG(a+5);
    <<[[drawmesg()]] when initialize font image and cache, sanity check ni>>
    free(font->fchar);  /* should we complain if non-zero? */
    font->fchar = malloc(ni * sizeof(FChar));
    <<[[drawmesg()]] when initialize font image and cache, sanity check fchar>>
    memset(font->fchar, 0, ni*sizeof(FChar));
    font->nfchar = ni;
    font->ascent = a[9];
    continue;

@
% so erase all previous chars

<<[[drawmesg()]] when initialize font image and cache, sanity check dstid>>=
if(dstid == 0)
    error("cannot use display as font");
@
<<[[drawmesg()]] when initialize font image and cache, sanity check font>>=
if(font == nil)
    error(Enodrawimage);
if(font->image->layer)
    error("cannot use window as font");
@

<<[[drawmesg()]] when initialize font image and cache, sanity check ni>>=
if(ni<=0 || ni>4096)
    error("bad font size (4096 chars max)");
@
<<[[drawmesg()]] when initialize font image and cache, sanity check fchar>>=
if(font->fchar == nil)
    error("no memory for font");
@


\subsection{[[agefont()]]}

% _string -> <>
<<function agefont>>=
void
agefont(Font *f)
{
    <<[[agefont()]] locals>>

    f->age++;
    <<[[agefont()]] if age overflow>>
}
@


<<[[agefont()]] locals>>=
Cacheinfo *c, *ec;
Cachesubf *s, *es;
@

<<[[agefont()]] if age overflow>>=
if(f->age == 65536){
    /*
     * Renormalize ages
     */
    c = f->cache;
    ec = c+f->ncache;
    while(c < ec){
        if(c->age){
            c->age >>= 2;
            c->age++;
        }
        c++;
    }

    s = f->subf;
    es = s + f->nsubf;
    while(s < es){
        if(s->age){
            if(s->age < SUBFAGE && s->cf->name != nil){
                /* clean up */
                if(display &&
                    s->f != display->defaultsubfont)
                    freesubfont(s->f);
                s->cf = nil;
                s->f = nil;
                s->age = 0;
            }else{
                s->age >>= 2;
                s->age++;
            }
        }
        s++;
    }
    f->age = (65536>>2) + 1;
}
@

\section{Subfonts}

%trans:
% use bits->id in loadchar message, assume there was a subf loaded.

\subsection{Subfont cache, [[Cachesubf]]}

<<[[Font]] subfont cache fields>>=
// growing_array<Cachesubf> (size = Font.nsubf, init = NFSUBF, max = MAXSUBF)
Cachesubf	*subf;
int		nsubf;	/* size of subfont list */
@

<<struct Cachesubf>>=
struct Cachesubf
{
    // ref<Cachefont>, the key
    Cachefont	*cf;	/* font info that owns us */
    // ref_own<Subfont>, the value
    Subfont		*f;	/* attached subfont */

    ulong		age;	/* for replacement */
};
@
% link between Font and subfont! finally!
\t rename f to sf here! confusing when have f->sub->f 


<<[[buildfont()]] allocate cache>>=
fnt->nsubf = NFSUBF;
fnt->subf = malloc(fnt->nsubf * sizeof(fnt->subf[0]));
@

<<constant NFSUBF>>=
NFSUBF =	2,			/* #subfonts to cache */
@
<<constant MAXSUBF>>=
MAXSUBF =	50,			/* generous upper limit */
@
<<constant DSUBF>>=
DSUBF = 	4,
@

<<[[freefont()]] free cache>>=
for(i=0; i<f->nsubf; i++){
    s = f->subf[i].f;
    if(s && display && s != display->defaultsubfont)
        freesubfont(s);
}
free(f->subf);
@



\subsection{Subfont loading}

\subsubsection{Subfont loading part 1}


<<[[loadchar()]] other locals>>=
Cachesubf *of;
@

% could not find subf with right cf in Font.subf.
<<[[loadchar()]] when the corresponding subfont is not loaded yet>>=
subf = &f->subf[oi];
<<[[loadchar()]] if old subfont entry valid, free it or expand subfont cache>>
subf->age = 0;
subf->cf = nil;
subf->f = cf2subfont(cf, f);
<<[[loadchar()]] sanity check subfont f>>
subf->cf = cf;
<<[[loadchar()]] sanity check ascents>>
@
% cf2subfont later


<<[[loadchar()]] if old subfont entry valid, free it or expand subfont cache>>=
if(subf->f){
    if(f->age - subf->age > SUBFAGE || f->nsubf > MAXSUBF){
Toss:
        /* ancient data; toss */
        freesubfont(subf->f);
        subf->cf = nil;
        subf->f = nil;
        subf->age = 0;
    }else{				/* too recent; grow instead */
        of = f->subf;
        f->subf = malloc((f->nsubf+DSUBF) * sizeof(Subfont));
        <<[[loadchar()]] sanity check new malloced subf>>
        memmove(f->subf, of, (f->nsubf+DSUBF) * sizeof(Subfont));
        memset(f->subf+f->nsubf, 0, DSUBF*sizeof *subf);
        subf = &f->subf[f->nsubf];
        f->nsubf += DSUBF;
        free(of);
    }
}
@


<<[[loadchar()]] sanity check new malloced subf>>=
if(f->subf == nil){
    f->subf = of;
    goto Toss;
}
@


<<[[loadchar()]] sanity check ascents>>=
if(subf->f->ascent > f->ascent && f->display){
    /* should print something? this is a mistake in the font file */
    /* must prevent c->top from going negative when loading cache */
    Image *b;
    int d, t;
    d = subf->f->ascent - f->ascent;
    b = subf->f->bits;
    draw(b, b->r, b, nil, addpt(b->r.min, Pt(0, d)));
    draw(b, Rect(b->r.min.x, b->r.max.y-d, b->r.max.x, b->r.max.y), f->display->black, nil, b->r.min);
    for(i=0; i<subf->f->n; i++){
        t = subf->f->info[i].top-d;
        if(t < 0)
            t = 0;
        subf->f->info[i].top = t;
        t = subf->f->info[i].bottom-d;
        if(t < 0)
            t = 0;
        subf->f->info[i].bottom = t;
    }
    subf->f->ascent = f->ascent;
}
@







% just set fullname of font

% loadchar -> <>
<<function cf2subfont>>=
static Subfont*
cf2subfont(Cachefont *cf, Font *f)
{
    int depth;
    char *name;

    name = cf->subfontname;
    if(name == nil){
        <<[[cf2subfont()]] set depth>>
        name = subfontname(cf->name, f->name, depth);
        <<[[cf2subfont()]] sanity check name>>
        cf->subfontname = name;
    }
    return lookupsubfont(f->display, name);
}
@
%old:    
%    Subfont *sf;
%    ...
%    sf = lookupsubfont(f->display, name);
%    return sf;


% why not load it now? why return up to _string to get it done?
%  and do this name magic?


<<[[cf2subfont()]] set depth>>=
if(f->display && f->display->screenimage)
    depth = f->display->screenimage->depth;
else
    depth = 8;
@

<<[[cf2subfont()]] sanity check name>>=
if(name == nil)
    return nil;
@



<<function subfontname>>=
/*
 * Default version: convert to file name
 */
char*
subfontname(char *cfname, char *fname, int maxdepth)
{
    char *t, *u, *tmp1, *tmp2;
    int i;

    t = strdup(cfname);  /* t is the return string */
    if(strcmp(cfname, "*default*") == 0)
        return t;
    if(t[0] != '/'){
        tmp2 = strdup(fname);
        u = utfrrune(tmp2, '/');
        if(u)
            u[0] = 0;
        else
            strcpy(tmp2, ".");
        tmp1 = smprint("%s/%s", tmp2, t);
        free(tmp2);
        free(t);
        t = tmp1;
    }

    if(maxdepth > 8)
        maxdepth = 8;

    for(i=3; i>=0; i--){
        if((1<<i) > maxdepth)
            continue;
        /* try i-bit grey */
        tmp2 = smprint("%s.%d", t, i);
        if(access(tmp2, AREAD) == 0) {
            free(t);
            return tmp2;
        }
        free(tmp2);
    }

    /* try default */
    if(access(t, AREAD) == 0)
        return t;

    free(t);
    return nil;
}
@
% >>



\subsubsection{Subfont loading part 2}


% how cf2subfont can fail? it will fail unless
%  the name was in the lookupsubfont memoized

<<[[loadchar()]] sanity check subfont f>>=
if(subf->f == nil){
    if(cf->subfontname == nil)
        goto TryPJW;
    *subfontname = cf->subfontname;
    return -1; // caller must retry
}
@

% n = cachechars(..., &subfontname);
% sometimes n can be 0 because new subfont in which case
%  subfontname should have been set? Or can have n > 0 and
%  subfontname?
%  do some assert? rewrite code to use a else if and a final else
%   which raise an error?

<<[[_string()]] other locals>>=
char *subfontname;
Subfont *sf = nil;
@
% a new subfont may have been loaded.
<<[[_string()]] if subfontname>>=
if(subfontname){
    <<[[_string()]] free previous sf>>
    // populate Font.subf global so next loadchar will find the subfont
    sf=_getsubfont(f->display, subfontname);
    <<[[_string()]] sanity check sf and possibly adjust f>>
    /* 
     * must not free sf until cachechars has found it in the cache
     * and picked up its own reference.
     */
}
@
% comment? very enigmatic

<<[[_string()]] free previous sf>>=
freesubfont(sf);
@
% free it once used and got a new one

<<[[_string()]] other locals>>=
Font *def;
@
<<[[_string()]] sanity check sf and possibly adjust f>>=
if(sf == nil){
    def = f->display ? f->display->defaultfont : nil;
    if(def && f != def)
        f = def;
    else
        break;
}
@
\l this code can be simplified


<<[[_stringnwidth()]] other locals>>=
Font *def;
@

<<[[_stringnwidth()]] if subfontname>>=
if(subfontname){
    if(_getsubfont(f->display, subfontname) == 0){
        def = f->display->defaultfont;
        if(def && f!=def)
            f = def;
        else
            break;
    }
}
@








% called when loadchar set the subfontname
% _string | _stringwidth -> <>

<<function _getsubfont>>=
/*
 * Default version: treat as file name
 */
Subfont*
_getsubfont(Display *d, char *name)
{
    fdt fd;
    Subfont *f;

    fd = open(name, OREAD);
    <<[[_getsubfont()]] sanity check fd>>

    <<[[_getsubfont()]] locking part1>>
    f = readsubfont(d, name, fd, d && !d->locking);
    <<[[_getsubfont()]] locking part2>>
    <<[[_getsubfont()]] sanity check f>>
    close(fd);
    <<[[_getsubfont()]] set malloc tag for debug>>

    return f;
}
@


<<[[_getsubfont()]] sanity check fd>>=
if(fd < 0){
    fprint(2, "getsubfont: can't open %s: %r\n", name);
    return nil;
}
@

<<[[_getsubfont()]] locking part1>>=
/*
 * unlock display so i/o happens with display released, unless
 * user is doing his own locking, in which case this could break things.
 * _getsubfont is called only from string.c and stringwidth.c,
 * which are known to be safe to have this done.
 */
if(d && !d->locking)
    unlockdisplay(d);
@

<<[[_getsubfont()]] locking part2>>=
if(d && !d->locking)
    lockdisplay(d);
@


<<[[_getsubfont()]] sanity check f>>=
if(f == nil)
    fprint(2, "getsubfont: can't read %s: %r\n", name);
@



\subsection{Subfont sharing}
% but seems very limited form of sharing

<<[[allocsubfont()]] install subfont if name>>=
if(name){
    f->name = strdup(name);
    if(lookupsubfont(i->display, name) == nil)
        installsubfont(name, f);
}
@

% memoized
<<global lastname>>=
static char	*lastname;
@
<<global lastsubfont>>=
Subfont	*lastsubfont;
@
%ocaml: could do a hash instead?

% (getdefont -> allocsubfont) | (loadchar -> cf2subfont) -> <>
<<function lookupsubfont>>=
Subfont*
lookupsubfont(Display *d, char *name)
{
    if(d && strcmp(name, "*default*") == 0)
        return d->defaultsubfont; 
    if(lastname && strcmp(name, lastname)==0)
      if(d == lastsubfont->bits->display){
        lastsubfont->ref++;
        return lastsubfont;
    }
    return nil;
}
@
\l use defontname here again! instead of hardcoded?
% ref++ here! so can share?
% which is why no need installsubfont for default subfont.

<<function installsubfont>>=
void
installsubfont(char *name, Subfont *subfont)
{
    free(lastname);
    lastname = strdup(name);
    lastsubfont = subfont;	/* notice we don't free the old one; that's your business */
}
@

% agefont -> freesubfont -> <>
<<function uninstallsubfont>>=
void
uninstallsubfont(Subfont *subfont)
{
    if(subfont == lastsubfont){
        lastname = nil;
        lastsubfont = nil;
    }
}
@




\subsection{Subfont IO}

\subsubsection{Reading a subfont}

% subfont format? image, then fontchar header
%  = 3 integers of 11 chars + 1 space each. and then why 4+1 below?
% and then fontchars.

% _getsubfont -> <>
<<function readsubfont>>=
Subfont*
readsubfont(Display *d, char *name, fdt fd, bool dolock)
{
    Image *i;
    Fontchar *fc;
    char hdr[3*12 + 4+1];
    int n;
    byte *p;
    Subfont *f;

    // reading the image

    i = readimage(d, fd, dolock); // the call!
    <<[[readsubfont()]] sanity check i>>

    // reading the fontchars

    if(read(fd, hdr, 3*12) != 3*12){
        freeimage(i);
        werrstr("rdsubfonfile: header read error: %r");
        return nil;
    }
    n = atoi(hdr);
    p = malloc(6 * (n+1));
    <<[[readsubfont()]] sanity check p>>
    if(read(fd, p, 6 * (n+1)) != 6 * (n+1)){
        werrstr("rdsubfonfile: fontchar read error: %r");
    Err:
        freeimage(i);
        free(p);
        return nil;
    }
    fc = malloc(sizeof(Fontchar) * (n+1));
    <<[[readsubfont()]] sanity check fc>>
    _unpackinfo(fc, p, n);
    <<[[readsubfont()]] if lock part1>>
    f = allocsubfont(name, n, atoi(hdr+12), atoi(hdr+24), fc, i);
    <<[[readsubfont()]] if lock part2>>
    <<[[readsubfont()]] sanity check f>>
    free(p);
    return f;
}
@
%dead:
% Subfont*
%  readsubfonti(Display*d, char *name, fdt fd, Image *ai, bool dolock) {
%    i = ai;
%    if(i == nil){
% ...
%        if(ai == nil)

% seen _unpackinfo in getdefont already


<<[[readsubfont()]] sanity check i>>=
if(i == nil)
    return nil;
@
<<[[readsubfont()]] sanity check p>>=
if(p == nil)
    goto Err;
@
<<[[readsubfont()]] sanity check fc>>=
if(fc == nil)
    goto Err;
@

<<[[readsubfont()]] sanity check f>>=
if(f == nil){
    free(fc);
    goto Err;
}
@


% why need lock before allocsubfont? because shared access
%  to lastname?
<<[[readsubfont()]] if lock part1>>=
if(dolock)
    lockdisplay(d);
@

<<[[readsubfont()]] if lock part2>>=
if(dolock)
    unlockdisplay(d);
@

\subsubsection{Writing a subfont}

% ?? -> <>, for people who wants to write new fonts?
<<function writesubfont>>=
errorneg1
writesubfont(fdt fd, Subfont *f)
{
    char hdr[3*12+1];
    byte *data;
    int nb;

    sprint(hdr, "%11d %11d %11d ", f->n, f->height, f->ascent);
    if(write(fd, hdr, 3*12) != 3*12){
    Err:
        werrstr("writesubfont: bad write: %r");
        return -1;
    }
    nb = 6*(f->n+1);
    data = malloc(nb);
    <<[[writesubfont()]] sanity check data>>
    packinfo(f->info, data, f->n);
    if(write(fd, data, nb) != nb)
        goto Err;
    free(data);
    return OK_0;
}
@
\t rename f to sf


<<[[writesubfont()]] sanity check data>>=
if(data == nil)
    return ERROR_NEG1;
@

% opposite of _unpackinfo
<<function packinfo>>=
static
void
packinfo(Fontchar *fc, uchar *p, int n)
{
    int j;

    for(j=0;  j<=n;  j++){
        p[0] = fc->x;
        p[1] = fc->x>>8;
        p[2] = fc->top;
        p[3] = fc->bottom;
        p[4] = fc->left;
        p[5] = fc->width;
        fc++;
        p += 6;
    }
}
@




\chapter{Image IO}

%trans:
% seen before API calls to image IO functions:
%  - loadimage() in getdefont(), load image (subfont) in memory to kernel
%  - readimage() in readsubfont(), load image (subfont) from disk to kernel
%    (but actually first load in memory and then transfer)

% remember that loading image mean loading in the kernel! in the
% graphic server!

% could do disk IO in the kernel to avoid some memory transfer?

% Loading fonts are also about reading images.
% Those fonts have to be in the kernel like all the other images.


\section{Loading images}
% =~ readimage but from memory instead of file
% rename Loading pixels instead?

\subsection{API}

% assumes already done allocimage. Image format then is really just
% a series of words for its pixels (format specified in chan of Image).

% send multiple lines at a time. 
% note that data contain all lines one after another of rectangle
% specified in r.
% send in chunks because of buffer when write in /dev/draw/x/data
% (bufsize)

% can be used to load parts of an image (see readimage
% which calls loadimage multiple time)

% getdefont | readimage | ...  -> <>
<<function loadimage>>=
errorneg1
loadimage(Image *i, Rectangle r, byte *data, int ndata)
{
    int chunk;
    int n, bpl;
    long dy;
    <<[[loadimage()]] other locals>>

    chunk = i->display->bufsize - 64; // a little room for header

    <<[[loadimage()]] sanity check r>>
    bpl = bytesperline(r, i->depth);
    n = bpl * Dy(r);
    <<[[loadimage()]] sanity check ndata>>

    ndata = 0;
    while(r.max.y > r.min.y){
        dy = r.max.y - r.min.y;
        if(dy * bpl > chunk)
            dy = chunk / bpl;
        <<[[loadimage()]] sanity check dy>>
        n = dy * bpl;

        <<[[loadimage()]] marshall one chunk of size n with height dy>>

        ndata += n;
        data += n;
        r.min.y += dy; // progress
    }
    <<[[loadimage()]] flush and sanity check no error>>
    return ndata;
}
@

% why - 64? room for header of y message.


<<[[loadimage()]] sanity check r>>=
if(!rectinrect(r, i->r)){
    werrstr("loadimage: bad rectangle");
    return ERROR_NEG1;
}
@

<<[[loadimage()]] sanity check ndata>>=
if(n > ndata){
    werrstr("loadimage: insufficient data");
    return ERROR_NEG1;
}
@

<<[[loadimage()]] sanity check dy>>=
if(dy <= 0){
    werrstr("loadimage: image too wide for buffer");
    return ERROR_NEG1;
}
@


\subsection{marshalling}

% send data by writing in /dev/draw/x/data

<<[[loadimage()]] other locals>>=
byte *a;
@

<<[[loadimage()]] marshall one chunk of size n with height dy>>=
// write: 'y' id[4] R[4*4] data[x*1]
a = bufimage(i->display, 21+n);
<<[[loadimage()]] sanity check a>>
a[0] = 'y';
BPLONG(a+1, i->id);
BPLONG(a+5, r.min.x);
BPLONG(a+9, r.min.y);
BPLONG(a+13, r.max.x);
BPLONG(a+17, r.min.y + dy);
memmove(a+21, data, n);
@

% called write, cos write image in the graphics server


<<[[loadimage()]] sanity check a>>=
if(a == nil){
    werrstr("bufimage failed");
    return ERROR_NEG1;
}
@

<<[[loadimage()]] flush and sanity check no error>>=
if(flushimage(i->display, false) < 0)
    return ERROR_NEG1;
@


\subsection{Unmarshalling}

<<[[drawmesg()]] cases>>=
/* write: 'y' id[4] R[4*4] data[x*1] */
/* write from compressed data: 'Y' id[4] R[4*4] data[x*1] */
case 'y':
case 'Y':
    printmesg(fmt="LR", a, false);
    m = 1+4+4*4;
    <<[[drawmesg()]] sanity check n with m>>
    dstid = BGLONG(a+1);
    dst = drawimage(client, a+1);
    drawrectangle(&r, a+5);
    <<[[drawmesg()]] when load an image, sanity check r>>
    y = memload(dst, r, a+m, n-m, *a=='Y'); // The call
    <<[[drawmesg()]] when load an image, sanity check y>>
    dstflush(dstid, dst, r);
    m += y;
    continue;
@
%old:
%//  iprint("load %c\n", *a);

<<[[drawmesg()]] when load an image, sanity check r>>=
if(!rectinrect(r, dst->r))
    error(Ewriteoutside);
@

<<[[drawmesg()]] when load an image, sanity check y>>=
if(y < 0)
    error("bad writeimage call");
@

\subsection{Algorithm}

<<function memload>>=
errorneg1
memload(Memimage *dst, Rectangle r, byte *data, int n, bool iscompressed)
{
    errorneg1 (*loadfn)(Memimage*, Rectangle, byte*, int);
    Memlayer *dl;
    <<[[memload()]] other locals>>

    loadfn = loadmemimage;
    <<[[memload()]] if iscompressed>>

    Top:
    dl = dst->layer;
    if(dl == nil)
        return (*loadfn)(dst, r, data, n);
    // else
    <<[[memload()]] if dst has a layer>>
}
@

% a serie of memmove for each line

% memload -> <> (as loadfn, loadfn = <> <- memload)
<<function loadmemimage>>=
errorneg1
loadmemimage(Memimage *i, Rectangle r, byte *data, int ndata)
{
    int l;
    int y;
    byte *q;
    int lpart = 0, rpart = 0;
    <<[[loadmemimage()]] other locals>>

    <<[[loadmemimage()]] sanity check r>>
    l = bytesperline(r, i->depth);
    <<[[loadmemimage()]] sanity check ndata>>
    ndata = l*Dy(r);

    q = byteaddr(i, r.min);

    <<[[loadmemimage()]] set mx, lpart, rpart, m for small depth images>>
    <<[[loadmemimage()]] if 1 byte per line>>

    if(lpart==0 && rpart==0){	/* easy case */
        for(y = r.min.y; y < r.max.y; y++){
            memmove(q, data, l);
            q += i->width * sizeof(ulong);
            data += l;
        }
        return ndata;
    }
    <<[[loadmemimage()]] when small depth images>>
}
@



<<[[loadmemimage()]] sanity check r>>=
if(!rectinrect(r, i->r))
    return ERROR_NEG1;
@

% a bit sad that redo some of the sanity checking done client side

<<[[loadmemimage()]] sanity check ndata>>=
if(ndata < l*Dy(r))
    return ERROR_NEG1;
@

\section{Unloading images}
% saving pixels

% read data by reading from /dev/draw/x/data!
% 2 steps, send read request by writing in /dev/draw/x/data
% and then read data from /dev/draw/x/data

\subsection{API}

% this time data is an OUT parameter

<<function unloadimage>>=
errorneg1
unloadimage(Image *i, Rectangle r, byte *data, int ndata)
{
    int bpl, dy;
    int n, ntot;
    Display *d;
    <<[[unloadimage()]] other locals>>

    <<[[unloadimage()]] sanity check r>>
    bpl = bytesperline(r, i->depth);
    <<[[unloadimage()]] sanity check ndata>>

    d = i->display;
    flushimage(d, false);	/* make sure subsequent flush is for us only */

    ntot = 0;
    while(r.min.y < r.max.y){

        dy = 8000/bpl;
        <<[[unloadimage()]] sanity check dy>>
        if(dy > Dy(r))
            dy = Dy(r);

       <<[[unloadimage()]] marshall reading request for rectangle of height dy>>

        n = read(d->fd, data + ntot, ndata - ntot);
       <<[[unloadimage()]] sanity check n>>
        ntot += n;
        r.min.y += dy; // progress
    }
    return ntot;
}
@


<<[[unloadimage()]] sanity check r>>=
if(!rectinrect(r, i->r)){
    werrstr("unloadimage: bad rectangle");
    return ERROR_NEG1;
}
@

<<[[unloadimage()]] sanity check ndata>>=
if(ndata < bpl*Dy(r)){
    werrstr("unloadimage: buffer too small");
    return ERROR_NEG1;
}
@

<<[[unloadimage()]] sanity check n>>=
if(n < 0)
    return n;
@

<<[[unloadimage()]] sanity check dy>>=
if(dy <= 0){
    werrstr("unloadimage: image too wide");
    return ERROR_NEG1;
}
@

\subsection{Marshalling}

<<[[unloadimage()]] other locals>>=
byte *a;
@

<<[[unloadimage()]] marshall reading request for rectangle of height dy>>=
// read: 'r' id[4] R[4*4]
a = bufimage(d, 1+4+4*4);
<<[[unloadimage()]] sanity check a>>
a[0] = 'r';
BPLONG(a+1, i->id);
BPLONG(a+5, r.min.x);
BPLONG(a+9, r.min.y);
BPLONG(a+13, r.max.x);
BPLONG(a+17, r.min.y+dy);
@

<<[[unloadimage()]] flush and sanity check no error>>=
if(flushimage(d, false) < 0)
    return ERROR_NEG1;
@

<<[[unloadimage()]] sanity check a>>=
if(a == nil){
    werrstr("unloadimage: %r");
    return -1;
}
@

\subsection{Unmarshalling}

<<[[drawmesg()]] cases>>=
/* read: 'r' id[4] R[4*4] */
case 'r':
    printmesg(fmt="LR", a, false);
    m = 1+4+4*4;
    <<[[drawmesg()]] sanity check n with m>>
    i = drawimage(client, a+1);
    drawrectangle(&r, a+5);
    <<[[drawmesg()]] when read an image, sanity check r>>
    c = bytesperline(r, i->depth);
    c *= Dy(r);

    free(client->readdata);
    client->readdata = mallocz(c, 0);
    <<[[drawmesg()]] when read an image, sanity check readdata>>
    client->nreaddata = memunload(i, r, client->readdata, c); // The call
    <<[[drawmesg()]] when read an image, sanity check nreaddata>>
    continue;
@



<<[[drawmesg()]] when read an image, sanity check r>>=
if(!rectinrect(r, i->r))
    error(Ereadoutside);
@

<<[[drawmesg()]] when read an image, sanity check readdata>>=
if(client->readdata == nil)
    error("readimage malloc failed");
@

<<[[drawmesg()]] when read an image, sanity check nreaddata>>=
if(client->nreaddata < 0){
    free(client->readdata);
    client->readdata = nil;
    error("bad readimage call");
}
@


<<[[Client]] other fields>>=
// array<byte> (size >= Client.nreaddata)
byte*   readdata;
int     nreaddata;
@
% so reading data involves 2 copy, first memcpy from
% image pool to Client.readdata, and then from kernel space
% to user space. See the calls to memmove in this section.

%        n = read(d->fd, data + ntot, ndata - ntot);

% put in buffer a
<<[[drawread()]] switch qid cases>>=
case Qdata:
    <<[[drawread()]] switch qid cases, when Qdata, sanity checks>>
    n = cl->nreaddata;
    memmove(a, cl->readdata, cl->nreaddata);
    free(cl->readdata);
    cl->readdata = nil;
    break;
@
% who fills readdata in the first place? memunload after.
% why set n? because drawread expects that

<<[[drawread()]] switch qid cases, when Qdata, sanity checks>>=
if(cl->readdata == nil)
    error("no draw data");
if(n < cl->nreaddata)
    error(Eshortread);
@


\subsection{Algorithm}

<<function memunload>>=
errorneg1
memunload(Memimage *src, Rectangle r, byte *data, int n)
{
    Memlayer *dl;
    <<[[memunload()]] other locals>>

    Top:
    dl = src->layer;
    if(dl == nil)
        return unloadmemimage(src, r, data, n);
    // else
    <<[[memunload()]] if src has layer>>
}
@

% data should be cl->readdata
<<function unloadmemimage>>=
errorneg1
unloadmemimage(Memimage *i, Rectangle r, byte *data, int ndata)
{
    int y, l;
    byte *q;

    <<[[unloadmemimage()]] sanity check r>>
    l = bytesperline(r, i->depth);
    <<[[unloadmemimage()]] sanity check ndata>>
    ndata = l*Dy(r);
    q = byteaddr(i, r.min);
    for(y = r.min.y; y < r.max.y; y++){
        memmove(data, q, l);
        q += i->width * sizeof(ulong);
        data += l;
    }
    return ndata;
}
@


<<[[unloadmemimage()]] sanity check r>>=
if(!rectinrect(r, i->r))
    return ERROR_NEG1;
@
<<[[unloadmemimage()]] sanity check ndata>>=
if(ndata < l*Dy(r))
    return ERROR_NEG1;
@


\section{Image format}

% image(6) format.
% A bit like format when read /dev/draw/x/ctl image spec for the format.
% get id, chan as str, rectangle, etc. Each time get number of 
% 11 chars and newline.

% different dimensions:
%  - new and old style channel format.
%  - compressed vs uncompressed.

% uncompressed new format =
%  - channel (as 12 chars)
%  - rectangle coordinates (4 times 12 characters)
%  - pixels



<<global channames>>=
static char channames[] = "rgbkamx";
@

% used when reading the first image spec from the draw new connection
% and also when readimage
% initdisplay | readimage | ... -> <>
<<function strtochan>>=
ulong
strtochan(char *s)
{
    char *p, *q;
    int t, n;
    int depth = 0;
    ulong chan = 0;

    p = s;
    while(*p && isspace(*p))
        p++;

    while(*p && !isspace(*p)){
        q = strchr(channames, p[0]);
        <<[[strtochan()]] sanity check q>>
        t = q-channames;
        <<[[strtochan()]] sanity check number after channel type>>
        n = p[1]-'0';
        depth += n;
        chan = (chan << 8) | __DC(t, n);
        p += 2;
    }
    <<[[strtochan()]] sanity check depth>>
    return chan;
}
@
% >> 
%old: d -> depth, c -> chan

<<function isspace>>=
/* avoid pulling in ctype when using with drawterm etc. */
static int
isspace(char c)
{
    return c==' ' || c== '\t' || c=='\r' || c=='\n';
}
@


<<[[strtochan()]] sanity check q>>=
if(q == nil) 
    return 0;
@
<<[[strtochan()]] sanity check number after channel type>>=
if(p[1] < '0' || p[1] > '9')
    return 0;
@

<<[[strtochan()]] sanity check depth>>=
if(depth == 0 || (depth > 8 && depth % 8) || (depth < 8 && 8 % depth))
    return 0;
@




<<global drawld2chan>>=
ulong drawld2chan[] = {
    GREY1,
    GREY2,
    GREY4,

    CMAP8,
};
@
% ld for ldepth, old channel format.
% log 2 depth, so 0 = 1, 1 = 2, 3 = 4, etc.


\section{Reading images}

% will call loadimage

<<function readimage>>=
Image*
readimage(Display *d, fdt fd, bool dolock)
{
    char hdr[5*12+1]; // 5 numbers as 11 chars plus space
    ulong chan;
    Rectangle r;
    Image *i;

    int miny, maxy;
    int dy;
    uint l, n;
    int m, j, chunk;
    byte *tmp;
    <<[[readimage()]] other locals>>

    // Reading the header

    if(readn(fd, hdr, 11) != 11)
        return nil;
    <<[[readimage()]] if first 11 characters are compressed string>>
    // else
    if(readn(fd, hdr+11, 5*12-11) != 5*12-11)
        return nil;
    if(d)
        chunk = d->bufsize - 32;	/* a little room for header */
    <<[[readimage()]] set chunk if no display>>

    <<[[readimage()]] check if new or old format, set new>>
    <<[[readimage()]] sanity check hdr>>
    <<[[readimage()]] if old format>>
    else{
        hdr[11] = '\0';
        chan = strtochan(hdr);
        <<[[readimage()]] sanity check chan>>
    }

    r.min.x = atoi(hdr+1*12);
    r.min.y = atoi(hdr+2*12);
    r.max.x = atoi(hdr+3*12);
    r.max.y = atoi(hdr+4*12);
    <<[[readimage()]] sanity check r>>

    miny = r.min.y;
    maxy = r.max.y;

    // Allocating the image

    l = bytesperline(r, chantodepth(chan));
    if(d){
        <<[[readimage()]] lock display>>
        i = allocimage(d, r, chan, false, -1);
        <<[[readimage()]] unlock display>>
        <<[[readimage()]] sanity check i>>
    }
    <<[[readimage()]] alloc image if no display>>

    // Read from disk and load the image

    tmp = malloc(chunk);
    <<[[readimage()]] sanity check tmp>>

    while(maxy > miny){
        dy = maxy - miny;
        if(dy * l > chunk)
            dy = chunk/l;
        <<[[readimage()]] sanity check dy>>
        n = dy * l;

        m = readn(fd, tmp, n);

        <<[[readimage()]] sanity check m>>
        <<[[readimage()]] if old format, flip all bits>>
        if(d){
            <<[[readimage()]] lock display>>

            if(loadimage(i, Rect(r.min.x, miny, r.max.x, miny+dy), tmp, 
                         chunk) <= 0)
                goto Err1;
            <<[[readimage()]] unlock display>>
        }
        miny += dy; // progress
    }
    free(tmp);
    return i;
}
@
% a bit redundant to split in chunk; this is already handled by loadimage

<<[[readimage()]] lock display>>=
if(dolock)
    lockdisplay(d);
@

<<[[readimage()]] unlock display>>=
if(dolock)
    unlockdisplay(d);
@

% for testing code?
<<[[readimage()]] set chunk if no display>>=
else
    chunk = 8192;
@

<<[[readimage()]] alloc image if no display>>=
else{
    i = mallocz(sizeof(Image), 1);
    if(i == nil)
        return nil;
}
@



<<[[readimage()]] sanity check hdr>>=
if(hdr[11] != ' '){
    werrstr("readimage: bad format");
    return nil;
}
@

<<[[readimage()]] sanity check chan>>=
if(chan == 0){
    werrstr("readimage: bad channel string %s", hdr);
    return nil;
}
@

<<[[readimage()]] sanity check r>>=
if(r.min.x > r.max.x || r.min.y > r.max.y){
    werrstr("readimage: bad rectangle");
    return nil;
}
@

<<[[readimage()]] sanity check i>>=
if(i == nil)
    return nil;
@

<<[[readimage()]] sanity check tmp>>=
if(tmp == nil)
    goto Err;
@

<<[[readimage()]] sanity check dy>>=
if(dy <= 0){
    werrstr("readimage: image too wide for buffer");
    goto Err;
}
@

<<[[readimage()]] sanity check m>>=
if(m != n){
    werrstr("readimage: read count %d not %d: %r", m, n);
Err:
    if(dolock)
        lockdisplay(d);
Err1:
    freeimage(i);
    if(dolock)
        unlockdisplay(d);
    free(tmp);
    return nil;
}
@







\section{Writing images}

%topng </dev/screen >screen.png :) = Grab

% will call unloadimage

% actually always write in compressed format, not even a bool
%  to say whether want compression












\chapter{Windows}
% overlapping windows

% See window(2)! have even nice examples at the end.

% lib_graphics/docs/pike-bitmap.ps, with layerop(), and many
% other stuff.

% Put toy example showing use of windows, A la acme, all in one,
% where also see overlapping idea.
% What if windows is overlapped by many other windows? Tricky
% for draw operations to not overflow.

% FIGURE screenshot of result of toy example.

% Core idea is that can have overlapping independent images, can move on top,
% move on the back. It also saves the old content when overlapped.
% It manages that for you. You don't have to care. Just draw in your
% windows as usual.
% Can also have a logical coordinate system so even if window
% on the right, its upper left can still be set to Pt(0,0).

% Note that when draw anything on it, it will handle if part of the image
% is overlapped and save this part somewhere if window is put to front later
% (if use default refresh mechanism).
% It means it needs to intercept all drawing operations.

%alt: or it could draw everything on save image, and this save image
% could be paint back on the main screen (in the right order of windows).
% that would remove lots of code. Does not even have to do the
% coordinate translation each time as save use the logical coordinates.
% In fact Lisp Machine was doing that, "shadow bitmap" and pike called
% his layerop an optimization of this shadow bitmap technique.

% Not only the windowing system can use windows. Acme uses windows.
% But of course this is a big building block for windowing system.

% What we have seen was already very complicated, lots of architecture layers,
% wrapper data structures. A real onion.
% Here is another one :) Windows and Desktops (Screen).

%alt: in X11 no shadow bitmap, it is responsibility of programs to repaint
% possibly to optimize by repainting only subareas,
% possibly to remove other expose event, ... this
% complicates client programs

\section{Additional data structures}

\subsection{Desktop, [[Screen]] (and [[Memscreen]])}

\subsubsection{[[Screen]]}

% to create windows, first need Desktop(Screen) holding them all.
% Screen factorize for all windows the target image and filling image.

% The id field allows to sync with similar structure in kernel.

% ctor = allocscreen | publicscreen
<<struct Screen>>=
struct Screen
{
    Display	*display;	/* display holding data */
    int		id;			/* id of system-held Screen */

    Image	*image;		/* unused; for reference only */
    Image	*fill;		/* color to paint behind windows */
};
@
% unused in user space yes. fill also unused?
%todo: rename? Confusing with Vga screen, screeimage, etc.
% maybe Desktop? After all that's the term Macos uses, with also the
% notion of virtual desktops. You have a desktop where you can put
% papers, papers which can overlap on the desktop.


\subsubsection{[[DScreen]]}

% kernel side, D for Draw (device).
% A bit like DImage for Image but here for Screen.

<<struct DScreen>>=
struct DScreen
{
    int     id;

    DImage      *dimage;
    DImage      *dfill;

    <<[[DScreen]] other fields>>

    // Extra
    int     ref;
    <<[[DScreen]] extra fields>>
};
@
% DImage screen
% ref here! cos can be made public and shared 

<<[[DScreen]] other fields>>=
bool     public;
@
% could mv in rio chapter.


<<global dscreen>>=
// list<ref<DScreen>> (next = DScreen.next)
static  DScreen*    dscreen;
@
% for publicscreen all public screens are shared and so stored globally
% in dscreen

<<[[DScreen]] extra fields>>=
// list<ref<DScreen>> (head = dscreen)
DScreen*    next;
@

% drawmesg (public screen) -> <>
<<function drawlookupdscreen>>=
DScreen*
drawlookupdscreen(int id)
{
    DScreen *s;

    s = dscreen;
    while(s){
        if(s->id == id)
            return s;
        s = s->next;
    }
    return nil;
}
@



\subsubsection{[[CScreen]]}

% one client can have multiple screens, so need lookup screen id
% so need list of those screens.
% (a client can create a subdesktop inside its desktop!).

% CScreen = Client screens

<<[[Client]] layer fields>>=
// list<ref_own<DScreen>> (next = CScreen.next)
CScreen*    cscreen;
@
% a bit like DImage hash, but here it's simply a list.
% probably because in practice a client has only one screen.
% Faster than dscreen big list.

% ctor = drawinstallscreen
<<struct CScreen>>=
struct CScreen
{
    // ref_shared<DScreen>
    DScreen*    dscreen;

    CScreen*    next;
};
@
%alt: could have embed that in DScreen itself, have a nextbis field.



% drawmesg (free screen) | drawmesg (allocate window) -> <>
<<function drawlookupscreen>>=
DScreen*
drawlookupscreen(Client *client, int id, CScreen **cs)
{
    CScreen *s;

    s = client->cscreen;
    while(s){
        if(s->dscreen->id == id){
            *cs = s;
            return s->dscreen;
        }
        s = s->next;
    }
    error(Enodrawscreen);
    return nil;
}
@




<<[[DScreen]] other fields>>=
Client*     owner;
@
% when private screen apparently the same client can access it too, but
% then need this information stored in the DScreen.
\l could delete I think, weird to allow use-public-screen message on
\l  non-public screen


\subsubsection{[[Memscreen]]}

% kernel independent. no id here.

<<[[DScreen]] other fields>>=
// ref_own<Memscreen>
Memscreen*  screen;
@

% why another DS? why not merge in DScreen? because of libmemdraw
% to be independent of kernel. In fact acme probably uses memscreen directly
% and no DScreen.

<<struct Memscreen>>=
struct Memscreen
{
    Memimage	*image;		/* upon which all layers are drawn */
    Memimage	*fill;		/* if non-zero, picture to use when repainting */

    <<[[Memscreen]] stack windows fields>>
};
@
% The image and fill seems redundant with same DScreen field, but
%  again it's because of kernel independence.
% Maybe the kernel one could be removed?

% Memscreen.image->data will be shared among all windows,
% with a different rectangle part each time.



\subsection{Window (and [[Memlayer]])}

% Windows are images! They just have a few more operations available to
% them. But they need to be connected to a desktop.

<<[[Image]] layer fields>>=
Screen		*screen;	/* nil if not a window */
@

<<[[DImage]] layer fields>>=
DScreen*    dscreen;    /* nil if not a window */
@
% seems redundant with Memimage.screen, but here it's a DScreen
%  not a kernel independent Memscreen.

% Actually for DImage got by name, the dscreen field will
% not be set because of nil passed below:
%    if(drawinstall(client, dstid, dn->dimage->image, nil) == 0)
% but the underlying memimage will have its layer and screen set.


\subsubsection{[[Memlayer]]}

% Could have also a 
% <<[[Memimage]] layer fields>>=
% Memscreen* *mscreen;
% but instead it's done in the Memlayer intermediate structure
%  with more info.


<<[[MemImage]] layer fields>>=
// ref_own<Memlayer>
Memlayer	*layer;	/* nil if not a layer*/
@
% why call that layer? cos additional layer when do draw operation
% on them? to translate, clip, save, etc.

% additional info on image related to window managment.

% ref to Memscreen below so will share pixel data of screen.image!
% Also will give access to other windows in this Screen, which will
% be needed when move around this window, to obscure/save and expose
% other windows.

% can move around the window on the desktop/screen image via screenr.
% can move its origin via delta.

% Memlayer is really an adapter to a shared Memdata.
% The Memimage of a window will be similar to the underlying full screen
%  image but thx to the layer link draw operation will know which
%  actual part of the shared full screen image to touch.

<<struct Memlayer>>=
struct Memlayer
{
    Rectangle		screenr;	/* true position of layer on screen */
    Point			delta;	/* add delta to go from image coords to screen */

    // ref<Memscreen>
    Memscreen	*screen;	/* screen this layer belongs to */

    // ref_own<Memimage> (in image coords)
    Memimage	*save;	/* save area for obscured parts */


    <<[[Memlayer]] stack windows fields>>
    <<[[Memlayer]] refresh fields>>
    <<[[Memlayer]] other fields>>
};
@
%alt: have the Memimage be the save image, with the data of the save
% image, instead of the data to the full screen image, and then after
% each draw op copy from save to full screen (found in Memscreen).
% Need clipping though, and because of arbitrary overlap, can not just
% have one rectangle, but could have a list of rectangles, or simply
% each time redraw as a painter.

%alt: could use screen coord for save too, would save conversion
% issues back and forth in memlayerop and memdraw

% Memlayer.screenr different from Memimage.r?

<<[[Memlayer]] other fields>>=
bool		clear;	/* layer is fully visible */
@
% what need clear for? optimisations, to know if need to get
%  pixels from save or not. When fully visible then things are
%  simpler

%alt: [[save]] saves only the obscured parts. Maybe an alternative would
% be for [[save]] to contain everything, and each time there is an update
% to copy accordingly [[save]] to the main screen in a painter fashion
% (last stuff painted overwrite previous stuff).
% Might be slower, but far more simpler than what they do where
% they really optimise and draw only what is necessary. Even the background
% is rendered on demand when a window disappear. 


%\subsubsection{Summary}

% FIGURE where could see in // the 3 universe, Image, DImage, Memimage
%  and also Screen, DScreen, Memscreen, and the pointers in both
%  directions each time.




\subsubsection{[[Display.windows]]}

%dead:
<<[[Display]] other fields>>=
// list<ref<Window>> (next = Image.next)
Image	*windows;
@
<<[[Image]] extra fields>>=
Image		*next;	/* next in list of windows */
@

\t I think it's dead, no need that, it's maintained in allocwindow
\t  and freeimage but nobody is using those fields then.


\subsection{Window stack}

% double linked list of windows.

<<[[Memscreen]] stack windows fields>>=
// list<ref<Memimage>> (next = Memimage.layer->rear)
Memimage	*frontmost;	/* frontmost layer on screen */
// list<ref<Memimage>> (next = Memimage.layer->front)
Memimage	*rearmost;	/* rearmost layer on screen */
@


<<[[Memlayer]] stack windows fields>>=
Memimage	*front;	/* window in front of this one */
Memimage	*rear;	/* window behind this one*/
@

% remember that each Memlayer has a ref to Memscreen and so has
% access to the other windows, which will be needed when move around
% this Memlayer/window, to hide(save)/expose(restore) other windows.

\section{Desktop allocation}

\subsection{API}

% gengetwindow -> <>
% ctor
<<function allocscreen>>=
Screen*
allocscreen(Image *image, Image *fill, bool public)
{
    Display *d;
    Screen *s;
    int id, try;
    byte *a;

    d = image->display;
    <<[[allocscreen()]] sanity check images have same display>>
    s = malloc(sizeof(Screen));
    <<[[allocscreen()]] sanity check s>>
    SET(id);
    for(try=0; try<25; try++){
        /* loop until find a free id */
        <<[[allocscreen()]] marshall allocate screen message>>
    }
    s->display = d;
    s->id = id;
    s->image = image;
    s->fill = fill;
    <<[[allocscreen()]] sanity check screen image>>
    return s;
}
@

<<[[allocscreen()]] sanity check images have same display>>=
if(d != fill->display){
    werrstr("allocscreen: image and fill on different displays");
    return nil;
}
@

<<[[allocscreen()]] sanity check s>>=
if(s == nil)
    return nil;
@

<<[[allocscreen()]] sanity check screen image>>=
assert(s->image && s->image->chan != 0);
@






<<function freescreen>>=
errorneg1
freescreen(Screen *s)
{
    Display *d;
    byte *a;

    <<[[freescreen()]] sanity check s>>
    d = s->display;
    <<[[freescreen()]] marshall free screen message>>
    free(s);
    return OK_1;
}
@

<<[[freescreen()]] sanity check s>>=
if(s == nil)
    return 0;
@
% should raise warning







% function to access a screen created by allocscreen which was public
% (or private but with same client)
% could mv in rio chapter?
<<function publicscreen>>=
Screen*
publicscreen(Display *d, int id, ulong chan)
{
    Screen *s;
    byte *a;

    s = malloc(sizeof(Screen));
    <<[[publicscreen()]] sanity check s>>

    <<[[publicscreen()]] marshall use public screen message>>

    s->display = d;
    s->id = id;

    s->image = nil;
    s->fill = nil;

    return s;
}
@
% do not have image and fill info client side, but the info will be there
% kernel side. Anyway it was there for reference only.
\l hmm actually useful to know the chan, but chan is passed here
\l  so maybe could stored it in the Screen instead of using
\l  d->screenimage->chan?


<<[[publicscreen()]] sanity check s>>=
if(s == nil)
    return nil;
@


\subsection{Marshalling}

<<global screenid>>=
static int	screenid;
@

<<[[allocscreen()]] marshall allocate screen message>>=
// allocate screen: 'A' id[4] imageid[4] fillid[4] public[1]
a = bufimage(d, 1+4+4+4+1);
<<[[allocscreen()]] sanity check a>>
id = ++screenid;
a[0] = 'A';
BPLONG(a+1, id);
BPLONG(a+5, image->id);
BPLONG(a+9, fill->id);
a[13] = public;
if(flushimage(d, false) != -1)
    break;
@

<<[[allocscreen()]] sanity check a>>=
if(a == nil){
    free(s);
    return nil;
}
@




<<[[freescreen()]] marshall free screen message>>=
// free screen: 'F' id[4]
a = bufimage(d, 1+4);
<<[[freescreen()]] sanity check a>>
a[0] = 'F';
BPLONG(a+1, s->id);
/*
 * flush(true) because screen is likely holding last reference to
 * window, and want it to disappear visually.
 */
if(flushimage(d, true) < 0)
    return ERROR_NEG1;
@



<<[[freescreen()]] sanity check a>>=
if(a == nil)
    return ERROR_NEG1;
@





<<[[publicscreen()]] marshall use public screen message>>=
// use public screen: 'S' id[4] chan[4]
a = bufimage(d, 1+4+4);
<<[[publicscreen()]] sanity check a>>
a[0] = 'S';
BPLONG(a+1, id);
BPLONG(a+5, chan);
if(flushimage(d, false) < 0)
    goto Error;
@


<<[[publicscreen()]] sanity check a>>=
if(a == nil){
Error:
    free(s);
    return nil;
}
@


\subsection{Unmarshalling}

<<[[drawmesg()]] locals>>=
DImage *dsrc;
@

<<[[drawmesg()]] cases>>=
/* allocate screen: 'A' id[4] imageid[4] fillid[4] public[1] */
case 'A':
    printmesg(fmt="LLLb", a, true);
    m = 1+4+4+4+1;
    <<[[drawmesg()]] sanity check n with m>>
    dstid = BGLONG(a+1);
    <<[[drawmesg()]] when allocate screen, sanity check dstid>>
    ddst = drawlookup(client, BGLONG(a+5), true);
    dsrc = drawlookup(client, BGLONG(a+9), true);
    <<[[drawmesg()]] when allocate screen, sanity check ddst and dsrc>>

    if(drawinstallscreen(client, nil, dstid, ddst, dsrc, a[13]) == 0)// The call
        error(Edrawmem);
    continue;

@

<<[[drawmesg()]] when allocate screen, sanity check dstid>>=
if(dstid == 0)
    error(Ebadarg);
if(drawlookupdscreen(dstid))
    error(Escreenexists);
@
% id screen is global so use global drawlookupdscreen lookup.

<<[[drawmesg()]] when allocate screen, sanity check ddst and dsrc>>=
if(ddst==nil || dsrc==nil)
    error(Enodrawimage);
@




<<[[drawmesg()]] locals>>=
CScreen *cs;
@

<<[[drawmesg()]] cases>>=
/* free screen: 'F' id[4] */
case 'F':
    printmesg(fmt="L", a, true);
    m = 1+4;
    <<[[drawmesg()]] sanity check n with m>>
    drawlookupscreen(client, BGLONG(a+1), &cs);
    drawuninstallscreen(client, cs); // The call
    continue;

@




<<[[drawmesg()]] locals>>=
DScreen *dscrn;
@


<<[[drawmesg()]] cases>>=
/* use public screen: 'S' id[4] chan[4] */
case 'S':
    printmesg(fmt="Ll", a, false);
    m = 1+4+4;
    <<[[drawmesg()]] sanity check n with m>>
    dstid = BGLONG(a+1);
    <<[[drawmesg()]] when use public screen, sanity check dstid>>
    dscrn = drawlookupdscreen(dstid);
    <<[[drawmesg()]] when use public screen, sanity check dscrn>>
    if(drawinstallscreen(client, dscrn, 0, nil, nil, false) == 0) // The call
        error(Edrawmem);
    continue;
@




<<[[drawmesg()]] when use public screen, sanity check dstid>>=
if(dstid == 0)
    error(Ebadarg);
@

<<[[drawmesg()]] when use public screen, sanity check dscrn>>=
if(dscrn == nil || (!dscrn->public && dscrn->owner != client))
    error(Enodrawscreen);
if(dscrn->screen->image->chan != BGLONG(a+5))
    error("inconsistent chan");
@
% check same owner when private screen. Not sure why allow 
% a use public screen on a private screen ...

%\subsection{Algorithm}
% no really algorithm, it's just about malloc.

\subsection{[[Client]] and [[Memscreen]] connection, [[CScreen]]}

% a bit like drawinstall which installs an image, except here it's a screen.
% replaced CScreen list with Dimage hash in client.

% pass existing DScreen when publicscreen (but 0 id) and nil when allocscreen

% ctor Memscreen
<<function drawinstallscreen>>=
Memscreen*
drawinstallscreen(Client *client, DScreen *d, int id, DImage *dimage, DImage *dfill, bool public)
{
    Memscreen *s;
    CScreen *c;

    c = malloc(sizeof(CScreen));
    <<[[drawinstallscreen()]] sanity check dimage>>
    <<[[drawinstallscreen()]] sanity check c>>

    if(d == nil){
        d = malloc(sizeof(DScreen));
        <<[[drawinstallscreen()]] sanity check d>>
        s = malloc(sizeof(Memscreen));
        <<[[drawinstallscreen()]] sanity check s>>

        d->id = id;
        d->dimage = dimage;
        d->dfill = dfill;

        d->screen = s;
        if(dimage){
            s->image = dimage->image;
            dimage->ref++;
        }
        if(dfill){
            s->fill = dfill->image;
            dfill->ref++;
        }
        // no windows yet
        s->frontmost = nil;
        s->rearmost = nil;

        d->public = public;
        d->owner = client;
        d->ref = 0;

        // add_list(d, dscreen)
        d->next = dscreen;
        dscreen = d;
    }

    c->dscreen = d;
    d->ref++;

    // add_list(c, client->cscreen)
    c->next = client->cscreen;
    client->cscreen = c;

    return d->screen;
}
@
% ref++ because screen can be shared, when use public screen.

<<[[drawinstallscreen()]] sanity check dimage>>=
if(dimage && dimage->image && dimage->image->chan == 0)
    panic("bad image %p in drawinstallscreen", dimage->image);
@
<<[[drawinstallscreen()]] sanity check c>>=
if(c == nil)
    return nil;
@
<<[[drawinstallscreen()]] sanity check d>>=
if(d == nil){
    free(c);
    return nil;
}
@
<<[[drawinstallscreen()]] sanity check s>>=
if(s == nil){
    free(c);
    free(d);
    return nil;
}
@




<<[[drawclose()]] free screens>>=
while(cl->cscreen)
    drawuninstallscreen(cl, cl->cscreen);
@
% drawclose then free all dimages (and so the windows)


% drawmesg(free screen) | drawclose -> <>
% free cscreen
<<function drawuninstallscreen>>=
void
drawuninstallscreen(Client *client, CScreen *this)
{
    CScreen *cs, *next;

    // remove_list(this, client->cscreen)
    cs = client->cscreen;
    if(cs == this){
        client->cscreen = this->next;

        drawfreedscreen(this->dscreen);
        free(this);
        return;
    }
    while(next = cs->next){ /* assign = */
        if(next == this){
            cs->next = this->next;
     
            drawfreedscreen(this->dscreen);
            free(this);
            return;
        }
        cs = next;
    }
}
@

% free dscreen
% drawuninstallscreen | drawfreedimage -> <>
<<function drawfreedscreen>>=
void
drawfreedscreen(DScreen *this)
{
    DScreen *ds, *next;

    this->ref--;
    <<[[drawfreedscreen()]] sanity check reference count>>
    if(this->ref > 0)
        return;
    // else

    // remove_list(this, dscreen)
    ds = dscreen;
    if(ds == this){
        dscreen = this->next;
        goto Found;
    }
    while(next = ds->next){ /* assign = */
        if(next == this){
            ds->next = this->next;
            goto Found;
        }
        ds = next;
    }
    error(Enodrawimage);

    Found:
    if(this->dimage)
        drawfreedimage(this->dimage);
    if(this->dfill)
        drawfreedimage(this->dfill);
    free(this->screen);
    free(this);
}
@
% no shared Memscreen, ref_own

% does not free the windows? leak? if abrupt process attached
% to /dev/draw/x/ dies? drawclose? enough?
% windows are images, and drawclose actually free all DImage
% see the comment in drawclose:
%  /* all screens are freed, so now we can free images */


<<[[drawfreedscreen()]] sanity check reference count>>=
if(this->ref < 0)
    print("negative ref in drawfreedscreen\n");
@






\section{Window creation}

% A window is an Image! It just needs to be connected to a Screen/Desktop

% Window really a special kind of Memimage with logical coord
% over underlying shared big image and save image. 


\subsection{API}

<<function allocwindow>>=
Image*
allocwindow(Screen *s, Rectangle r, int ref, rgba val)
{
    return _allocwindow(nil, s, r, ref, val);
}
@
% A screen is first a target image. Allocate a window is allocate
% a subimage of this target image. No need chan here as use same chan
% than image in Screen.

% ever call _allocwindow with non nil Image? not sure.
<<function _allocwindow>>=
Image*
_allocwindow(Image *i, Screen *s, Rectangle r, int ref, rgba val)
{
    Display *d;

    d = s->display;
    i = _allocimage(i, d, r, d->screenimage->chan, false, val, s->id, ref);
    <<[[_allocwindow()]] sanity check i>>
    i->screen = s;

    // add_list(i, display->windows)
    i->next = s->display->windows;
    s->display->windows = i;

    return i;
}
@

% call _allocimage, but this time passing a screen id!

% screenimage set in gengetwindow, later.
\l but why not use s->image->chan instead? because not there
\l  when use public screen ... so maybe should have a Screen.chan field.

<<[[_allocwindow()]] sanity check i>>=
if(i == nil)
    return nil;
@



% a window is an image, it is freeed by freeimage (which calls _freeimage1)
<<[[_freeimage1()]] if screen>>=
if(i->screen){
    // remove_list(i, d->windows)
    w = d->windows;
    if(w == i)
        d->windows = i->next;
    else
        while(w){
            if(w->next == i){
                w->next = i->next;
                break;
            }
            w = w->next;
        }
}
@
\l this is dead actually I think, noone use those fields

%\subsection{Marshalling}
% done in _allocimage, main diff is pass screen id and refresh.

\subsection{Unmarshalling}

<<[[drawmesg()]] locals>>=
Memscreen *scrn;
Memimage *l;
@


<<[[drawmesg()]] allocate image case, if screen id>>=
if(scrnid){
    dscrn = drawlookupscreen(client, scrnid, &cs);
    scrn = dscrn->screen;
    <<[[drawmesg()]] when allocate window, sanity check repl and chan>>
    <<[[drawmesg()]] when allocate window, set reffn>>
    l = memlalloc(scrn, r, reffn, nil, value); // The call
    <<[[drawmesg()]] when allocate window, sanity check l>>
    <<[[drawmesg()]] when allocate window, addflush>>

    // similar to regular allocate image case
    l->clipr = clipr;
    rectclip(&l->clipr, r);

    if(drawinstall(client, dstid, l, dscrn) == 0){
        memldelete(l);
        error(Edrawmem);
    }
    dscrn->ref++;

    <<[[drawmesg()]] when allocate window, if reffn>>
    continue;
}
@
% a window depends on a screen hence the ref++

<<[[drawmesg()]] when allocate window, sanity check repl and chan>>=
if(repl || chan != scrn->image->chan)
    error("image parameters incompatible with screen");
@

<<[[drawmesg()]] when allocate window, sanity check l>>=
if(l == nil)
    error(Edrawmem);
@



% also here unmarshall code when free image, which will call
% drawuninstall (which will call drawfreedimage which calls memldelete)

\subsection{Algorithm}

% ctor Memlayer
% return a Memimage! (with attached layer)
<<function memlalloc>>=
Memimage*
memlalloc(Memscreen *s, Rectangle screenr, Refreshfn refreshfn, void *refreshptr, rgba val)
{
    Memimage *n;
    Memlayer *l;
    <<[[memlalloc()]] other locals>>

    <<[[memlalloc()]] set paint once>>

    // share pixels data with screen image
    n = allocmemimaged(screenr, s->image->chan, s->image->data);
    <<[[memlalloc()]] sanity check n>>
    // overwrite zero and width derived from screenr in allocmemimaged
    // because the rectangle here does not match the data, it's a
    // subrectangle. Zero and width should remain the same.
    n->zero = s->image->zero;
    n->width = s->image->width;

    l = malloc(sizeof(Memlayer));
    <<[[memlalloc()]] sanity check l>>

    l->screen = s;
    l->screenr = screenr;
    l->delta = Pt(0,0); // can be changed later by originwindow()
    l->clear = false;
    <<[[memlalloc()]] allocate save image>>

    n->layer = l;
    // ok no more sanity check, we can make the connection
    n->data->ref++;

    <<[[memlalloc()]] set refresh fields part1>>
    <<[[memlalloc()]] manage stack of windows>>
    <<[[memlalloc()]] set refresh fields part2>>

    <<[[memlalloc()]] paint with requested color>>
    return n;
}
@
%old: I put the setting of n field closer to the call to allocmemimaged
\t rename n to i or mi

% refreshptr != nil sometimes? in rio?


<<[[memlalloc()]] allocate save image>>=
<<[[memlalloc()]] if refreshfn>>
else{
    l->save = allocmemimage(screenr, s->image->chan);
    <<[[memlalloc()]] sanity check l save>>
    /* allocmemimage doesn't initialize memory; this paints save area */
    if(val != DNofill)
        memfillcolor(l->save, val);
}
@
% why need fill save? anyway will fill with paint the whole window.


<<[[memlalloc()]] manage stack of windows>>=
/* start with new window behind all existing ones */

// add_end_double_list(l, s->frontmost, s->rearmost)
l->front = s->rearmost;
l->rear = nil;
if(s->rearmost)
    s->rearmost->layer->rear = n;
s->rearmost = n;
if(s->frontmost == nil)
    s->frontmost = n;

/* now pull new window to front */
_memltofrontfill(n, val != DNofill);
@
%old: used to set l->clear = false; here but more consistent I think
% to do it before

% see _memltofrontfill later, but this will gradually
% save the obscured part by this new window of all other windows.

% put at the very end first, to respect invariant, 
% and then put at top so will trigger the hide of every windows
% now under.



<<[[memlalloc()]] other locals>>=
static Memimage *paint;
@
<<[[memlalloc()]] set paint once>>=
if(paint == nil){
    paint = allocmemimage(Rect(0,0,1,1), RGBA32);
    <<[[memlalloc()]] sanity check paint>>
    paint->flags |= Frepl;
    paint->clipr = Rect(-0x3FFFFFF, -0x3FFFFFF, 0x3FFFFFF, 0x3FFFFFF);
}
@

<<[[memlalloc()]] paint with requested color>>=
/*
 * paint with requested color; previously exposed areas are already right
 * if this window has backing store, but just painting the whole thing is simplest.
 */
if(val != DNofill){
    memsetchan(paint, n->chan);
    memfillcolor(paint, val);
    memdraw(n, n->r, paint, n->r.min, nil, n->r.min, S);
}
@
% can change chan of existing image? should assert chantodepth(n->chan)
%  compatible or less than the depth of RGBA32.




<<[[memlalloc()]] sanity check n>>=
if(n == nil)
    return nil;
@
<<[[memlalloc()]] sanity check l>>=
if(l == nil){
    free(n);
    return nil;
}
@
<<[[memlalloc()]] sanity check l save>>=
if(l->save == nil){
    free(l);
    free(n);
    return nil;
}
@
<<[[memlalloc()]] sanity check paint>>=
if(paint == nil)
    return nil;
@





% call when error, call when free dimage in next section
% drawmesg (allocate window) | freedimage (below) -> <>
<<function memldelete>>=
void
memldelete(Memimage *i)
{
    Memlayer *l;
    Memscreen *s;

    l = i->layer;
    s = i->layer->screen;

    /* free backing store and disconnect refresh, to make pushback fast */
    freememimage(l->save);
    l->save = nil;
    l->refreshptr = nil;
    memltorear(i);

    /* window is now the rearmost;  clean up screen structures and deallocate */

    if(s->fill){
        i->clipr = i->r;
        memdraw(i, i->r, s->fill, i->r.min, nil, i->r.min, S);
    }
    <<[[memldelete()]] manage stack of windows>>

    free(l);
    freememimage(i);
}
@
%old: put s initialization earlier

<<[[memldelete()]] manage stack of windows>>=
// remove_double_list(l, s->frontmost, s->rearmost)
if(l->front){
    l->front->layer->rear = nil;
    s->rearmost = l->front;
}else{
    s->frontmost = nil;
    s->rearmost = nil;
}
@





\subsection{[[Client]] and [[Memimage]] connection, [[DImage]]}
% part2

% see call to drawinstall above. drawinstall connect a memimage and a client.
% drawmesg(allocate) -> <>
<<[[drawinstall()]] install dscreen>>=
d->dscreen = dscreen;
@
% so create connection too between client and DScreen via DImage.
% (after having done connection between Memimage and Memlayer and Memscreen)


% drawclose | drawuninstall -> <>
<<[[drawfreedimage()]] if dscreen>>=
ds = dimage->dscreen;
if(ds){
    l = dimage->image;
    <<[[drawfreedimage()]] addflush>>
    <<[[drawfreedimage()]] free refreshptr>>

    if(drawgoodname(dimage))
        memldelete(l);
    else
        memlfree(l);

    drawfreedscreen(ds); // one less reference
}
@

% See "Naming and sharing (and windows)" section for drawgoodname.
% But basically if not shared image, or if shared image
%  and up to data, then we must do the effect on the screen.
% Otherwise, if shared image and not up to date, then just free the
%  structure.


<<[[drawgoodname()]] if DImage [[d]] is a window>>=
/* if window, validate the screen's own images */
if(d->dscreen)
    if(!drawgoodname(d->dscreen->dimage)
    || !drawgoodname(d->dscreen->dfill))
        return false;
@


% simpler version, which does not do the windows stack handling
% drawfreedimage (when not goodname) -> <>
<<function memlfree>>=
/*
 * Just free the data structures, don't do graphics
 */
void
memlfree(Memimage *i)
{
    Memlayer *l;

    l = i->layer;
    freememimage(l->save);
    free(l);
    freememimage(i);
}
@



\section{Window stack manipulation}

\subsection{API}

<<function topwindow>>=
void
topwindow(Image *w)
{
    <<[[xxxmwindow()]] sanity check window w>>
    topbottom(&w, 1, true);
}
@

<<function bottomwindow>>=
void
bottomwindow(Image *w)
{
    <<[[xxxmwindow()]] sanity check window w>>
    topbottom(&w, 1, false);
}
@

<<function topnwindows>>=
void
topnwindows(Image **w, int n)
{
    topbottom(w, n, true);
}
@

<<function bottomnwindows>>=
void
bottomnwindows(Image **w, int n)
{
    topbottom(w, n, false);
}
@





<<[[xxxmwindow()]] sanity check window w>>=
if(w->screen == nil)
    return;
@

\subsection{Marshalling}

<<function topbottom>>=
static
void
topbottom(Image **w, int n, bool top)
{
    int i;
    byte *b;
    Display *d;

    <<[[topbottom()]] sanity check n>>
    <<[[topbottom()]] sanity check images have same display>>

    // top or bottom windows: 't' top[1] nw[2] n*id[4]
    b = bufimage(d, 1+1+2+4*n);
    b[0] = 't';
    b[1] = top;
    BPSHORT(b+2, n);
    for(i=0; i<n; i++)
        BPLONG(b+4+4*i, w[i]->id);
}
@
%dead: redundant with code already doing that before
%    if(n==0)
%        return;
\l forgot bufimage b sanity check


<<[[topbottom()]] sanity check n>>=
if(n < 0){
Ridiculous:
    fprint(2, "top/bottom: ridiculous number of windows\n");
    return;
}
if(n == 0)
    return;
if(n > (w[0]->display->bufsize - 100)/4)
    goto Ridiculous;
@
% last check? because will pass one BPLONG per window, and -100 is for header

<<[[topbottom()]] sanity check images have same display>>=
/*
 * this used to check that all images were on the same screen.
 * we don't know the screen associated with images we acquired
 * by name.  instead, check that all images are on the same display.
 * the display will check that they are all on the same screen.
 */
d = w[0]->display;
for(i=1; i<n; i++)
    if(w[i]->display != d){
        fprint(2, "top/bottom: windows not on same screen\n");
        return;
    }
@
% important comment about images acquired by name!

\subsection{Unmarshalling}

<<[[drawmesg()]] locals>>=
int nw;
Memimage **lp;
@

<<[[drawmesg()]] cases>>=
/* top or bottom windows: 't' top[1] nw[2] n*id[4] */
case 't':
    printmesg(fmt="bsL", a, false);
    m = 1+1+2;
    <<[[drawmesg()]] sanity check n with m>>
    nw = BGSHORT(a+2);
    <<[[drawmesg()]] when top or bottom windows, sanity check nw>>
    m += nw*4;
    <<[[drawmesg()]] sanity check n with m>>
    lp = malloc(nw * sizeof(Memimage*));
    <<[[drawmesg()]] when top or bottom windows, sanity check lp>>
    for(j=0; j<nw; j++)
        lp[j] = drawimage(client, a+1+1+2+j*4);
    <<[[drawmesg()]] when top or bottom windows, sanity check windows>>

    if(a[1])
        memltofrontn(lp, nw); // The call
    else
        memltorearn(lp, nw); // The call

    <<[[drawmesg()]] when top or bottom windows, addflush>>
    <<[[drawmesg()]] when top or bottom windows, refresh>>

    poperror();
    free(lp);
    continue;

@
% poperror because waserror in one of the sanity check



<<[[drawmesg()]] when top or bottom windows, sanity check nw>>=
if(nw < 0)
    error(Ebadarg);
if(nw == 0)
    continue;
@

<<[[drawmesg()]] when top or bottom windows, sanity check lp>>=
if(lp == nil)
    error(Enomem);
if(waserror()){
    free(lp);
    nexterror();
}
@
% hence poperror above.

<<[[drawmesg()]] when top or bottom windows, sanity check windows>>=
if(lp[0]->layer == nil)
    error("images are not windows");
for(j=1; j<nw; j++)
    if(lp[j]->layer->screen != lp[0]->layer->screen)
        error("images not on same screen");
@
% now we can do the check that all images have the same screen.
% Note that if got DImage by name, it may not not have its dscreen field set
% (indeed see the nil in if(drawinstall(client, dstid, dn->dimage->image, nil)))
% but it will share the same Memimage which will have a layer and appropriate
% screen set. Anyway here we deal with Memimage directly.



\subsection{Algorithm}

\subsubsection{To front}

% so first entry in array will be at the end the first one
<<function memltofrontn>>=
void
memltofrontn(Memimage **ip, int n)
{
    Memimage *i, *front;

    <<[[memltofrontn()]] sanity check n>>
    front = nil;
    while(--n >= 0){
        i = *ip++;
        _memltofront(i, front, true);
        front = i;
    }
    _memlsetclear(front->layer->screen);
}
@
%old:    Memscreen *s; s = front->layer->screen;

<<[[memltofrontn()]] sanity check n>>=
if(n == 0)
    return;
@

% memlorigin -> <>
<<function memltofront>>=
void
memltofront(Memimage *i)
{
    _memltofront(i, nil, true);
    _memlsetclear(i->layer->screen);
}
@




<<function _memltofront>>=
/*
 * Pull i towards top of screen, just behind front
*/
static
void
_memltofront(Memimage *i, Memimage *front, bool fill)
{
    Memlayer *l;
    Memscreen *s;
    Memimage *f;
    Rectangle x;
    bool overlap;
    <<[[_memltofront()]] other locals>>

    l = i->layer;
    s = l->screen;

    while(l->front != front){
        f = l->front;
        x = l->screenr;

        // i will now pass in front of f, so hide f
        overlap = rectclip(&x, f->layer->screenr);
        if(overlap){
            memlhide(f, x);
            f->layer->clear = false;
        }
        <<[[_memltofront()]] put f behind i>>
        if(overlap && fill)
            memlexpose(i, x);
    }
}
@
% fill just false when have a Dnotfill color when create window the first time

% useless to set clear here I think since anyway it's set in _memlsetclear


<<[[_memltofront()]] other locals>>=
Memimage *ff, *rr;
@

<<[[_memltofront()]] put f behind i>>=
/* swap l and f in screen's list */
// swap_double_list(l, f, s->frontmost, s->rearmost)
ff = f->layer->front;
rr = l->rear;

if(ff == nil)
    s->frontmost = i;
else
    ff->layer->rear = i;

if(rr == nil)
    s->rearmost = f;
else
    rr->layer->front = f;

l->front = ff;
l->rear = f; // f is now behind i
f->layer->front = i;
f->layer->rear = rr;
@


% update invariant
<<function _memlsetclear>>=
void
_memlsetclear(Memscreen *s)
{
    Memimage *i, *j;
    Memlayer *l;

    for(i = s->rearmost; i; i = i->layer->front){
        l = i->layer;
        l->clear = rectinrect(l->screenr, l->screen->image->clipr);
        if(l->clear)
            for(j = l->front; j; j = j->layer->front)
                if(rectXrect(l->screenr, j->layer->screenr)){
                    l->clear = false;
                    break;
                }
    }
}
@
% why need clear field to be maintained? to optimize things,
%  to know whether we need to pull some pixels back from save 
%  or whether they are already on the screen.



<<function _memltofrontfill>>=
void
_memltofrontfill(Memimage *i, bool fill)
{
    _memltofront(i, nil, fill);
    _memlsetclear(i->layer->screen);
}
@


\subsubsection{To rear}


<<function memltorearn>>=
void
memltorearn(Memimage **ip, int n)
{
    Memimage *i, *rear;

    <<[[memltofrontn()]] sanity check n>>
    rear = nil;
    while(--n >= 0){
        i = *ip++;
        _memltorear(i, rear);
        rear = i;
    }
    _memlsetclear(rear->layer->screen);
}
@
%old:    Memscreen *s; s = rear->layer->screen;

% memldelete -> <>
<<function memltorear>>=
void
memltorear(Memimage *i)
{
    _memltorear(i, nil);
    _memlsetclear(i->layer->screen);
}
@



<<function _memltorear>>=
void
_memltorear(Memimage *i, Memimage *rear)
{
    Memlayer *l;
    Memscreen *s;
    Memimage *f, *r, *rr;
    Rectangle x;
    bool overlap;

    l = i->layer;
    s = l->screen;

    while(l->rear != rear){
        r = l->rear;
        x = l->screenr;

        overlap = rectclip(&x, r->layer->screenr);
        if(overlap){
            memlhide(i, x);
            l->clear = false;
        }
        <<[[_memltorear()]] put i behind r>>
        if(overlap)
            memlexpose(r, x);
    }
}
@


<<[[_memltorear()]] put i behind r>>=
/* swap l and r in screen's list */
// swap_end_double_list(i, r, s->frontmost, s->rearmost)
rr = r->layer->rear;
f = l->front;

if(rr == nil)
    s->rearmost = i;
else
    rr->layer->front = i;

if(f == nil)
    s->frontmost = r;
else
    f->layer->rear = r;

l->rear = rr;
l->front = r; // i is now behind r
r->layer->rear = i;
r->layer->front = f;
@





\section{Window hide/expose}

%trans: seen memlhide and memlexpose before.

\subsection{[[memlhide()]]}

% rectangle in screen coordinate!
<<function memlhide>>=
void
memlhide(Memimage *i, Rectangle screenr)
{
    if(i->layer->save == nil)
        return;
    if(!rectclip(&screenr, i->layer->screen->image->r))
        return;

    _memlayerop(lhideop, i, screenr, screenr, i->layer);
}
@

% will see _memlayerop later. Will call lhideop for each sub rectangles
% in screenr. 

% FIGURE with visible rectangle and invisible one?



% memlhide -> _memlayerop -> <> (as ?? <- _memlayerop(<>, ...) <- memlhide)
<<function lhideop>>=
/*
 * Hide puts that portion of screenr now on the screen into the window's
 * save area.
 * Expose puts that portion of screenr now in the save area onto the screen.
 *
 * Hide and Expose both require that the layer structures in the screen
 * match the geometry they are being asked to update, that is, they update the
 * save area (hide) or screen (expose) based on what those structures tell them.
 * This means they must be called at the correct time during window shuffles.
 */
static
void
lhideop(Memimage *src, Rectangle screenr, Rectangle clipr, void *etc, bool insave)
{
    Memlayer *l = etc;
    Rectangle r;

    USED(clipr.min.x);
    USED(insave);

    if(src != l->save){	/* do nothing if src is already in save area */
        r = rectsubpt(screenr, l->delta);
        memdraw(l->save, r, src, screenr.min, nil, screenr.min, S);
    }
}
@
% delete clipr?
\l mv insave closer to first parameter?
%ocaml: use variant instead of pair src x insave

% why rectsubpt? because screenr is in screen coordinate but
% when src is actually the save Memimage, then we need to translate
% back to logical coordinate.
%alt: simpler system? 
%ocaml: Logical of Pt | Screen of Pt

\subsection{[[memlexpose()]]}

<<function memlexpose>>=
void
memlexpose(Memimage *i, Rectangle screenr)
{
    if(!rectclip(&screenr, i->layer->screen->image->r))
        return;
    _memlayerop(lexposeop, i, screenr, screenr, i->layer);
}
@

<<function lexposeop>>=
static
void
lexposeop(Memimage *dst, Rectangle screenr, Rectangle clipr, void *etc, bool insave)
{
    Memlayer *l = etc;
    Rectangle r;

    USED(clipr.min.x);
    if(insave)	/* if dst is save area, don't bother */
        return;
    r = rectsubpt(screenr, l->delta);
    if(l->save)
        memdraw(dst, screenr, l->save, r.min, nil, r.min, S);
    <<[[lexposeop()]] if not save but refresh method>>
}
@

% insave?

\section{Window origin}

% one of the main reason why need adaptations I think later when
% draw things is the change of origin (the other is because
% things may have to be put in save instead of on the desktop image).

\subsection{API}

% log for logical coordinate, scr for screen position.

% does two things at the same time:
% - can change coordinate system,
% - can move window around (which will hide/expose other windows)

<<function originwindow>>=
errorneg1
originwindow(Image *w, Point log, Point scr)
{
    byte *b;
    Point delta;

    flushimage(w->display, false);

    <<[[originwindow()]] marshall position window message>>

    delta = subpt(log, w->r.min);
    // new image coords
    w->r     = rectaddpt(w->r, delta);
    w->clipr = rectaddpt(w->clipr, delta);
    return OK_1;
}
@
% adapt visible r and clipr to logical coordinate

\subsection{Marshalling}

<<[[originwindow()]] marshall position window message>>=
// position window: 'o' id[4] r.min [2*4] screenr.min [2*4]
b = bufimage(w->display, 1+4+2*4+2*4);
<<[[originwindow()]] sanity check b>>
b[0] = 'o';
BPLONG(b+1, w->id);
BPLONG(b+5, log.x);
BPLONG(b+9, log.y);
BPLONG(b+13, scr.x);
BPLONG(b+17, scr.y);
if(flushimage(w->display, true) < 0)
    return ERROR_NEG1;
@

<<[[originwindow()]] sanity check b>>=
if(b == nil)
    return 0; // really? not -1?
@

\subsection{Unmarshalling}

<<[[drawmesg()]] cases>>=
/* position window: 'o' id[4] r.min [2*4] screenr.min [2*4] */
case 'o':
    printmesg(fmt="LPP", a, false);
    m = 1+4+2*4+2*4;
    <<[[drawmesg()]] sanity check n with m>>
    dst = drawimage(client, a+1);
    if(dst->layer){
        drawpoint(&p, a+5);
        drawpoint(&q, a+13);
        r = dst->layer->screenr;

        ni = memlorigin(dst, p, q); // The call

        <<[[drawmesg()]] when position window, sanity check ni>>
        if(ni > 0){
            <<[[drawmesg()]] when position window, addflush>>
            <<[[drawmesg()]] when position window, refresh>>
        }
    }
    // else, could display error
    continue;
@

<<[[drawmesg()]] when position window, sanity check ni>>=
if(ni < 0)
    error("image origin failed");
@


\subsection{Algorithm}

% 0 means no change, < 0 means error, > 0 means changes

% as said before, can do 2 different things at the same time.

<<function memlorigin>>=
/*
 * Place i so i->r.min = log, i->layer->screenr.min == scr.
*/
errorneg1
memlorigin(Memimage *i, Point log, Point scr)
{
    Memlayer *l;
    Memscreen *s;
    Rectangle newr, oldr;
    Point delta;
    bool eqlog, eqscr, wasclear;
    <<[[memlorigin()]] other locals>>

    l = i->layer;
    s = l->screen;

    oldr = l->screenr;
    newr = Rect(scr.x, scr.y, scr.x + Dx(oldr), scr.y + Dy(oldr));

    eqscr = eqpt(scr, oldr.min);
    eqlog = eqpt(log, i->r.min);

    if(eqscr && eqlog)
        return 0;

    <<[[memlorigin()]] allocate new save image if log changed>>
    /*
     * Bring it to front and move logical coordinate system.
     */
    memltofront(i);
    wasclear = l->clear;
    <<[[memlorigin()]] set new save image if log changed>>

    // like in user side
    delta = subpt(log, i->r.min);
    // new image coords
    i->r     = rectaddpt(i->r, delta);
    i->clipr = rectaddpt(i->clipr, delta);

    l->delta = subpt(l->screenr.min, i->r.min);

    if(eqscr)
        return 0;
    // else

    <<[[memlorigin()]] move window>>
}
@
% remember delta field from Memlayer:
%    Point			delta;	/* add delta to go from image coords to screen */

\subsubsection{New origin}

<<[[memlorigin()]] other locals>>=
Memimage *nsave;
@
% Memlayer.save use logical coord, so if move origin, 
% then need new image.

<<[[memlorigin()]] allocate new save image if log changed>>=
nsave = nil;
if(!eqlog && l->save != nil){
    nsave = allocmemimage(Rect(log.x, log.y, log.x+Dx(oldr), log.y+Dy(oldr)), i->chan);
    <<[[memlorigin()]] sanity check nsave>>
}
@

<<[[memlorigin()]] set new save image if log changed>>=
if(nsave){
    if(!wasclear)
        memimagedraw(nsave, nsave->r, l->save, l->save->r.min, nil, ZP, S);
    freememimage(l->save);
    l->save = nsave;
}
@
%old: was Pt(0,0) but ZP better I think


<<[[memlorigin()]] sanity check nsave>>=
if(nsave == nil)
    return ERROR_NEG1;
@

\subsubsection{New screen position}

<<[[memlorigin()]] other locals>>=
Memimage *shad, *t;
bool overlap;
Rectangle x;
@

% why need shadow? what would happen if didn't have shadow window?

<<[[memlorigin()]] move window>>=
/*
 * To clean up old position, make a shadow window there, don't paint it,
 * push it behind this one, and (later) delete it.  Because the refresh
 * function for this fake window is a no-op, this will cause no graphics
 * action except to restore the background and expose the windows
 * previously hidden.
 */
shad = memlalloc(s, oldr, memlnorefresh, nil, DNofill);
<<[[memlorigin()]] sanity check shad>>
<<[[memlorigin()]] manage stack of windows, put shad after front>>
shad->layer->clear = false;

/*
 * Shadow is now holding down the fort at the old position.
 * Move the window and hide things obscured by new position.
 */
for(t = l->rear->layer->rear; t != nil; t = t->layer->rear){
    x = newr;
    overlap = rectclip(&x, t->layer->screenr);
    if(overlap){
        memlhide(t, x);
        t->layer->clear = false;
    }
}
l->screenr = newr;
l->delta = subpt(scr, i->r.min);
l->clear = rectinrect(newr, l->screen->image->clipr);

/*
 * Everything's covered.  Copy to new position and delete shadow window.
 */
if(wasclear)
    memdraw(s->image, newr, s->image, oldr.min, nil, ZP, S);
else
    memlexpose(i, newr);

memldelete(shad);

return 1;
@
% change again l->delta here.
%old: use ZP here again


<<[[memlorigin()]] manage stack of windows, put shad after front>>=
// add_after_double_list(shad, i, s->frontmost, s->rearmost)
s->frontmost = i; // useless since memltofront(i) above
if(s->rearmost == i)
    s->rearmost = shad;
else
    l->rear->layer->front = shad;
shad->layer->front = i;
shad->layer->rear = l->rear;
l->rear = shad;
l->front = nil;
@


<<[[memlorigin()]] sanity check shad>>=
if(shad == nil)
    return ERROR_NEG1;
@




\section{Drawing and windows}

%trans:
% Most drawing code we presented before for images handle basic images 
% but not windows. A window is mostly an image, but not exactly an image:
% We need first to adapt coordinates and then draw on
% underlying screen image or draw on save depending if area is visible or not.
% So need many adaptations to drawing algo we saw before. Cant just
% draw with coord on full underlying screen (shared) image.

%alt: just draw on save and use painter algorithm, far simpler.

\subsection{Drawing rectangles}

%trans:
% seen memdraw() in chapter X. But for simple case where src and
% dst are simple images, not windows, in which case call
% the simple memimagedraw().
% Here adaptations when one of the image is actually a window in which case we 
% need to translate image coords to actual screen coord and possibly draw in 
% save area instead if destination is a window. We may also have
% to take pixels from the save area if src is a partially obscured window.

\subsubsection{[[memdraw()]]}

<<[[memdraw()]] if mask has layer>>=
if(mask->layer){
    DBG1("mask->layer != nil\n");
    return;	/* too hard, at least for now */
}
@
\l no warning??
% ok, so now still src and dst to transform in regular images.

<<[[memdraw()]] locals>>=
Memlayer *dl, *sl;
@

% starts like memimagedraw with drawclip
<<[[memdraw()]] when have layers>>=
<<[[memdraw()]] call drawclip, if empty rectangle return>>

/*
 Convert to screen coordinates.
 */
dl = dst->layer;
<<[[memdraw()]] convert [[r]] if dst is a window>>

<<[[memdraw()]] if dst is fully visible can optimize>>
// else

sl = src->layer;
<<[[memdraw()]] convert [[p0]] and [[srcr]] if src is a window>>

/*
 * Now everything is in screen coordinates.
 * mask is an image.  dst and src are images or obscured layers.
 */
<<[[memdraw()]] if dst and src are the same window>>
// else

<<[[memdraw()]] make src an image>>

/*
 * src is now an image.  dst may be an image or a clear layer
 */
if(dl == nil)
    goto Top;
<<[[memdraw()]] after src is an image, if dst is fully visible can optimize>>
// else

<<[[memdraw()]] general case where dst is an obscured window>>
@
%old: was using dst->layer at a few places instead of dl



<<[[memdraw()]] locals>>=
Rectangle srcr, mr; // set by drawclip
@

% similar to memimagedraw
<<[[memdraw()]] call drawclip, if empty rectangle return>>=
if(!drawclip(dst, &r, src, &p0, mask, &p1,   &srcr, &mr)){
    return;
}
@
%old:   DBG1("drawclip dstcr %R srccr %R maskcr %R\n", dst->clipr, src->clipr, mask->clipr);

% What if different coordinate system? If dst is regular image but
% src a window? Does not matter. Logically the coord of the window
% are the coord we mean for the data. It's not the real one because
% we share an image, but the user does not have to care about that.

\subsubsection{Coordinate conversions}

<<[[memdraw()]] convert [[r]] if dst is a window>>=
if(dl != nil){
    // r = rectaddpt(r, dl->delta)
    r.min.x += dl->delta.x;
    r.min.y += dl->delta.y;
    r.max.x += dl->delta.x;
    r.max.y += dl->delta.y;
}
@

<<[[memdraw()]] convert [[p0]] and [[srcr]] if src is a window>>=
if(sl != nil){
    // p0 = addpt(p0, sl->delta)
    p0.x += sl->delta.x;
    p0.y += sl->delta.y;
    // srcr = rectaddpt(srcr, sl->delta)
    srcr.min.x += sl->delta.x;
    srcr.min.y += sl->delta.y;
    srcr.max.x += sl->delta.x;
    srcr.max.y += sl->delta.y;
}
@

\subsubsection{Source conversion}

<<[[memdraw()]] make src an image>>=
if(sl){
    <<[[memdraw()]] if src is fully visible can optimize>>

    /* relatively rare case; use save area */
    <<[[memdraw()]] if refresh function for src>>
    memlhide(src, srcr); // draw the needed pixels in sl->save

    /* convert back to logical coordinates */
    // p0 = subpt(p0, sl->delta)
    p0.x -= sl->delta.x;
    p0.y -= sl->delta.y;
    // srcr = rectsubpt(srcr, sl->delta)
    srcr.min.x -= sl->delta.x;
    srcr.min.y -= sl->delta.y;
    srcr.max.x -= sl->delta.x;
    srcr.max.y -= sl->delta.y;

    src = src->layer->save; // progress
}
@
% note that memlhide -> _memlayerop -> memdraw, so kinda recursif,
% but the memdraw will be with src->layer->save, a simple image.

% convert back to logical because sl->save have data with logical coords.

\subsubsection{Shortcuts}

<<[[memdraw()]] if dst is fully visible can optimize>>=
Clearlayer:
if(dl!=nil && dl->clear){
    if(src == dst){
        // p0 = addpt(p0, dl->delta)
        p0.x += dl->delta.x;
        p0.y += dl->delta.y;

        src = dl->screen->image; // progress
    }
    dst = dl->screen->image; // progress
    goto Top;
}
@

% note that maybe src != dst and still a layer in which case one
% could think there could be a problem. But actually Top will still
% check dst and src are not windows, and so at least here we may have
% made some progress (but there will be no infinite loop though, because
% dst has changed now! it's not a window for sure and so it will
% not take this code path again).


<<[[memdraw()]] locals>>=
Rectangle tr;
@

% r has been converted to screen coord 
<<[[memdraw()]] if dst and src are the same window>>=
/*
 * if dst and src are the same layer, just draw in save area and expose.
 */
if(dl != nil && dst == src){
    <<[[memdraw()]] if refresh function for dst>>
    if(rectXrect(r, srcr)){
        <<[[memdraw()]] set tr to union of r and srcr and adapt p1>>
        memlhide(dst, tr);
    }else{
        memlhide(dst, r);
        memlhide(dst, srcr);
    }
    memdraw(dl->save, rectsubpt(r,    dl->delta), 
            dl->save, subpt(srcr.min, dl->delta),  
            mask, p1, op);
    memlexpose(dst, r);
    return;
}
@
%old: was src->layer->delta but dst == src so can simplify

% restore coord back since use save here which use logical coord

\l why do union for tr? be simpler to do the 2 memlhide like below no?

<<[[memdraw()]] set tr to union of r and srcr and adapt p1>>=
tr = r;
if(srcr.min.x < tr.min.x){
    p1.x += tr.min.x - srcr.min.x;
    tr.min.x = srcr.min.x;
}
if(srcr.min.y < tr.min.y){
    p1.y += tr.min.x - srcr.min.x;
    tr.min.y = srcr.min.y;
}
if(srcr.max.x > tr.max.x)
    tr.max.x = srcr.max.x;
if(srcr.max.y > tr.max.y)
    tr.max.y = srcr.max.y;
@




<<[[memdraw()]] if src is fully visible can optimize>>=
if(sl->clear){
    src = sl->screen->image;
    if(dl != nil){
        // r = rectsubpt(r, dl->delta)
        r.min.x -= dl->delta.x;
        r.min.y -= dl->delta.y;
        r.max.x -= dl->delta.x;
        r.max.y -= dl->delta.y;
    }
    goto Top;
}
@
\l why this rectsubpt because goto Top so need to put back invariant?


<<[[memdraw()]] after src is an image, if dst is fully visible can optimize>>=
if(dl->clear)
    goto Clearlayer;
@





\subsubsection{[[_ldrawop()]]}

%trans: back to general case when dst is obscured window.
% src is a simple image, coords have been converted (r is a screenr)
% but now need to draw on window.

%DS to present first:

<<[[memdraw()]] locals>>=
struct Draw d;
@

<<struct Draw>>=
struct Draw
{
    Memlayer    *dstlayer;

    Memimage	*src;
    Point	deltas;

    Memimage	*mask;
    Point	deltam;

    // enum<Drawop>
    int	op;
};
@
% Similar to Memdrawparam. Needed because _memlayerop is generic
%  higher order function but can pass only one parameter to callback.

\l could have Draw.p0 and Draw.p1 instead of those deltas I think.
\l Would be simpler than those subpt and addpt.


<<[[memdraw()]] general case where dst is an obscured window>>=
/*
 * dst is an obscured layer
 */
d.dstlayer = dl;
d.src = src;
d.mask = mask;
d.op = op;
d.deltas = subpt(p0, r.min);
d.deltam = subpt(p1, r.min);

_memlayerop(ldrawop, dst, r, r, &d);
@

% see _memlayerop soon.
% what will happen is that we call callback for every rectangles
% to draw, in save, in visible, because of overlapping windows.

% FIGURE where see all those little rectangles, visible,
% and also the invisible one in save.

% Note that dst below is not the same than in Draw.dstlayer!
% dst here can be the Memimage of the save! or the Memimage of the full screen
% image. The case is actually defined by insave parameter.

<<function ldrawop>>=
static
void
ldrawop(Memimage *dst, Rectangle screenr, Rectangle clipr, void *etc, bool insave)
{
    struct Draw *d = etc;
    Point p0, p1;
    Rectangle r;
    <<[[ldrawop()]] other locals>>

    <<[[ldrawop()]] return if no save in dst>>

    p0 = addpt(screenr.min, d->deltas);
    p1 = addpt(screenr.min, d->deltam);

    if(insave){
        r     = rectsubpt(screenr, d->dstlayer->delta);
        clipr = rectsubpt(clipr,   d->dstlayer->delta);
    }else
        r = screenr;

    /* now in logical coordinates */

    <<[[ldrawop()]] if r not in clipr>>
    memdraw(dst, r, d->src, p0, d->mask, p1, d->op); // will call memimagedraw
}
@
% need adjust clipr because of the if r not in clipr test after.
% need same coordinate system.

% ???
<<[[ldrawop()]] other locals>>=
Rectangle oclipr, srcr, mr;
bool ok;
@
<<[[ldrawop()]] if r not in clipr>>=
/* clipr may have narrowed what we should draw on, so clip if necessary */
if(!rectinrect(r, clipr)){
    <<[[ldrawop()]] change dst clipr>>
    ok = drawclip(dst, &r, d->src, &p0, d->mask, &p1, &srcr, &mr);
    <<[[ldrawop()]] restore dst clipr>>
    if(!ok)
        return;
}
@

<<[[ldrawop()]] change dst clipr>>=
oclipr = dst->clipr;
dst->clipr = clipr;
@
<<[[ldrawop()]] restore dst clipr>>=
dst->clipr = oclipr;
@

\subsubsection{[[_memlayerop()]]}

% Memimage i below is a window.

% not just for ldawop! for expose, window (and line later)

% memlhide | memlexpose | memdraw -> <>
<<function _memlayerop>>=
/*
 * Assumes incoming rectangle has already been clipped to i's logical r and clipr
 */
void
_memlayerop(
    void (*fn)(Memimage*, Rectangle, Rectangle, void*, int),
    Memimage *i,
    Rectangle screenr,	/* clipped to window boundaries */
    Rectangle clipr,	/* clipped also to clipping rectangles of hierarchy */
    void *etc)
{
    Memlayer *l;
    Rectangle r, scr;

    l = i->layer;
    if(!rectclip(&screenr, l->screenr))
        return;

    if(l->clear){
        fn(l->screen->image, screenr, clipr, etc, false);
        return;
    }

    r = screenr; // original value before rectclip below
    scr = l->screen->image->clipr;

    /*
     * Do the piece on the screen
     */
    if(rectclip(&screenr, scr))
        _layerop(fn, i, screenr, clipr, etc, l->screen->frontmost);

    if(rectinrect(r, scr))
        return;

    /*
     * Do the piece off the screen
    */
    if(!rectXrect(r, scr)){
        /* completely offscreen; easy */
        fn(l->save, r, clipr, etc, true);
        return;
    }
    // else

    if(r.min.y < scr.min.y){
        /* above screen */
        fn(l->save, Rect(r.min.x, r.min.y, r.max.x, scr.min.y), clipr, etc, true);
        r.min.y = scr.min.y;
    }
    if(r.max.y > scr.max.y){
        /* below screen */
        fn(l->save, Rect(r.min.x, scr.max.y, r.max.x, r.max.y), clipr, etc, true);
        r.max.y = scr.max.y;
    }
    if(r.min.x < scr.min.x){
        /* left of screen */
        fn(l->save, Rect(r.min.x, r.min.y, scr.min.x, r.max.y), clipr, etc, true);
        r.min.x = scr.min.x;
    }
    if(r.max.x > scr.max.x){
        /* right of screen */
        fn(l->save, Rect(scr.max.x, r.min.y, r.max.x, r.max.y), clipr, etc, true);
    }
}
@

% FIGURE with stuff outside screen

\subsubsection{[[_layerop()]]}

% finally. last step.

% draw on screen when can because on top for this part,
% or on save when obscured.

<<function _layerop>>=
static void
_layerop(
    void (*fn)(Memimage*, Rectangle, Rectangle, void*, int),
    Memimage *i,
    Rectangle r,
    Rectangle clipr,
    void *etc,
    Memimage *front)
{
    Rectangle fr;

    Top:
    if(front == i){
        /* no one is in front of this part of window; use the screen */
        fn(i->layer->screen->image, r, clipr, etc, false);
        return;
    }
    // else

    fr = front->layer->screenr;
    if(!rectXrect(r, fr)){
        /* r doesn't touch this window; continue on next rearmost */
        front = front->layer->rear;
        goto Top;
    }
    // else, r touches this window somewhere

    if(fr.max.y < r.max.y){
        // rectangle below front
        RECUR(r.min.x, fr.max.y, r.max.x, r.max.y);
        r.max.y = fr.max.y;
    }
    if(r.min.y < fr.min.y){
        // rectangle above front
        RECUR(r.min.x, r.min.y, r.max.x, fr.min.y);
        r.min.y = fr.min.y;
    }
    if(fr.max.x < r.max.x){
        // rectangle right of front
        RECUR(fr.max.x, r.min.y, r.max.x, r.max.y);
        r.max.x = fr.max.x;
    }
    if(r.min.x < fr.min.x){
        // rectangle left of front
        RECUR(r.min.x, r.min.y, fr.min.x, r.max.y);
        r.min.x = fr.min.x;
    }
    /* r is covered by front, so put in save area */
    (*fn)(i->layer->save, r, clipr, etc, true);
}
@
%old: when !rectXrect
%        // assert(front && front->layer && front->layer->screen && front->layer->rear);

<<function RECUR>>=
#define	RECUR(a,b,c,d)	_layerop(fn, i, Rect(a, b, c, d), clipr, etc, front->layer->rear);
@
%old:#define	RECUR(a,b,c,d)	_layerop(fn, i, Rect(a.x, b.y, c.x, d.y), clipr, etc, front->layer->rear);

% r.max.y = fr.max.y to avoid redundant work! and for the save part

% FIGURE with mini rectangles, maybe do 4 mini figures for each cases





\subsection{Drawing lines}

<<[[_memline()]] sanity check no src layer>>=
if(src->layer)	/* can't draw line with layered source */
    return;
@
% no mask with _memline, just dst and src.


<<[[_memline()]] when have layers>>=
<<[[_memline()]] clip source>>

// Convert to screen coordinates
<<[[_memline()]] convert p0, p1, clipr coordinates >>

<<[[_memline()]] if dst is fully visible can optimize>>

<<[[_memline()]] set r bounding box and clip it>>

<<[[_memline()]] general case, call _memlayerop>>
@


<<[[_memline()]] other locals>>=
bool srcclipped = false;
Point d;
@

<<[[_memline()]] clip source>>=
if(!srcclipped){
    d = subpt(sp, p0);
    if(!rectclip(&clipr, rectsubpt(src->clipr, d)))
        return;
    if(!(src->flags&Frepl) && !rectclip(&clipr, rectsubpt(src->r, d)))
        return;
    srcclipped = true;
}
@
% why need srcclipped once guard? because of goto Top?

<<[[_memline()]] convert p0, p1, clipr coordinates >>=
/* dst is known to be a layer */
// p0 = addpt(p0, dl->delta)
p0.x += dl->delta.x;
p0.y += dl->delta.y;
// p1 = addpt(p1, dl->delta)
p1.x += dl->delta.x;
p1.y += dl->delta.y;
// clipr = rectaddpt(clipr, dl->elta)
clipr.min.x += dl->delta.x;
clipr.min.y += dl->delta.y;
clipr.max.x += dl->delta.x;
clipr.max.y += dl->delta.y;
@

<<[[_memline()]] if dst is fully visible can optimize>>=
if(dl->clear){
    dst = dst->layer->screen->image;
    goto Top;
}
@


<<[[_memline()]] other locals>>=
Rectangle r;
@

<<[[_memline()]] set r bounding box and clip it>>=
/* can't use sutherland-cohen clipping because lines are wide */
r = memlinebbox(p0, p1, end0, end1, radius);
/*
 * r is now a bounding box for the line;
 * use it as a clipping rectangle for subdivision
 */
if(!rectclip(&r, clipr))
    return;
@
%old:
% /* XXx */
% /* this is not the correct set of tests */
% //	if(log2[dst->depth] != log2[src->depth] || log2[dst->depth]!=3)
% //		return;


<<[[_memline()]] other locals>>=
struct Lline ll;
@

<<struct Lline>>=
struct Lline
{
    Point			p0;
    Point			p1;
    Point			delta;
    int			end0;
    int			end1;
    int			radius;
    Point			sp;

    Memlayer		*dstlayer;
    Memimage	*src;
    int			op;
};
@
% all the params of _memline mostly


<<[[_memline()]] general case, call _memlayerop>>=
ll.p0 = p0;
ll.p1 = p1;
ll.end0 = end0;
ll.end1 = end1;
ll.sp = sp;
ll.dstlayer = dst->layer;
ll.src = src;
ll.radius = radius;
ll.delta = dl->delta;
ll.op = op;

_memlayerop(llineop, dst, r, r, &ll);
@


% each time called with a small screenr
<<function llineop>>=
static
void
llineop(Memimage *dst, Rectangle screenr, Rectangle clipr, void *etc, bool insave)
{
    struct Lline *ll = etc;
    Point p0, p1;

    USED(screenr.min.x);

    if(insave && ll->dstlayer->save == nil)
        return;
    if(!rectclip(&clipr, screenr))
        return;

    if(insave){
        p0 = subpt(ll->p0, ll->delta);
        p1 = subpt(ll->p1, ll->delta);
        clipr = rectsubpt(clipr, ll->delta);
    }else{
        p0 = ll->p0;
        p1 = ll->p1;
    }

    _memline(dst, p0, p1, ll->end0, ll->end1, ll->radius, ll->src, ll->sp, clipr, ll->op);
}
@





\subsection{Loading an image}

\subsubsection{[[memload()]]}

<<[[memload()]] other locals>>=
Rectangle lr; // saved logical r
int dx;
Memimage *tmp;
@

<<[[memload()]] if dst has a layer>>=
/*
 * Convert to screen coordinates.
 */
lr = r;
// r = rectaddpt(r, dl->delta)
r.min.x += dl->delta.x;
r.min.y += dl->delta.y;
r.max.x += dl->delta.x;
r.max.y += dl->delta.y;

dx = dl->delta.x & (7 / dst->depth);

<<[[memload()]] if dst is fully visible can optimize>>

/*
 * dst is an obscured layer or data is unaligned
 */
<<[[memload()]] if data is aligned, load on save and expose>>
// else
tmp = allocmemimage(lr, dst->chan);
<<[[memload()]] sanity check tmp>>
n = loadfn(tmp, lr, data, n);
memdraw(dst, lr, tmp, lr.min, nil, lr.min, S);
freememimage(tmp);
return n;
@


<<[[memload()]] if dst is fully visible can optimize>>=
if(dl->clear && dx==0){
    dst = dl->screen->image;
    goto Top;
}
@

<<[[memload()]] if data is aligned, load on save and expose>>=
if(dl->save && dx==0){
    n = loadfn(dl->save, lr, data, n);
    if(n > 0)
        memlexpose(dst, r);
    return n;
}
@




<<[[memload()]] sanity check tmp>>=
if(tmp == nil)
    return ERROR_NEG1;
@



\subsubsection{[[memunload()]]}

% very similar

<<[[memunload()]] other locals>>=
Rectangle lr;
int dx;
Memimage *tmp;
@

<<[[memunload()]] if src has layer>>=
/*
 Convert to screen coordinates.
 */
lr = r;
// r = rectaddpt(r, dl->delta)
r.min.x += dl->delta.x;
r.min.y += dl->delta.y;
r.max.x += dl->delta.x;
r.max.y += dl->delta.y;

dx = dl->delta.x&(7/src->depth);
if(dl->clear && dx==0){
    src = dl->screen->image;
    goto Top;
}

/*
 * src is an obscured layer or data is unaligned
 */
if(dl->save && dx==0){
    if(dl->refreshfn != nil)
        return ERROR_NEG1;	/* can't unload window if it's not Refbackup */
    if(n > 0)
        memlhide(src, r);
    n = unloadmemimage(dl->save, lr, data, n);
    return n;
}

tmp = allocmemimage(lr, src->chan);
if(tmp == nil)
    return ERROR_NEG1;
memdraw(tmp, lr, src, lr.min, nil, lr.min, S);
n = unloadmemimage(tmp, lr, data, n);
freememimage(tmp);
return n;
@



%\subsection{Flushing}
% see adv topics




\chapter{Windowing System Support}

%trans:
% Saw windows chapter before. Can be used for regular app. e.g. acme.
% Will be used by rio. Actually used by every app by default too as we will see.
% Saw Naming images section before. Can be used for interprocess sharing.
% A few more pieces (/dev/winname) and enough building blocks for rio.

% rio overview: when run, access to full screen, direct access to
% /dev/draw (actually even rio go through initdraw and so have screen
% and view, but when noborder screenname, a bit special).
% Then with screen create subwindows when special command with mouse,
% then associate process with this screen and emulate /dev/winname
%  for this process.
% (and also public screen but actually less important)
% every app use initdraw(), so can put stuff there to setup things.


% Also fast windowing system because even if window, draw directly 
% on framebuffer! (actually can mess up with Display->image)
%alt: 8 1/2 was virtualizing the window too, cleaner, and more
% elegant, but slower apparently. Maybe could not have games in a window
% then. Also would be safer! any app can draw on desktop ! maybe can
% do tricky stuff to fool the user?

% see window(2) discussion at the end about rio and initdraw.
% rio creates a public screen, with public windows (images).
% then builds a screen for each window, then a border (a window?)
% and then a subwindow for the client.

\section{Additional data structures}

% every window run will have view and screen set accordingly.

\subsection{[[view]]}

<<global screen>>=
// ref<Image>, a window
Image	*view;
@
% gengetwindow(..., &view) <- geninitdraw <- initdraw
%old: was called screen, but unfortunate because there was
% also a Screen type and then a _screen global.
% I could maybe also call it image, or window.
% At the same time with the virtual screen principle, every app thinks it has
% the whole screen for itself, so maybe it made sense to call this
% variable screen. But view is good too, less confusing.
% Actually rio uses a 'view' global assigned to screen.

% it is not the same than Display->image! (or Display->screenimage?)
% it comes from gengetwindown so it is really the window image!
% it should be smaller than Display->image (unless not run under rio).

% It has a backing store too?


% Why need to be a global? convenient, just call initdraw and everything
% is set for you.


\subsection{[[screen]]}

<<global _screen>>=
Screen	*screen;
@
% gengetwindow(..., &screen) <- geninitdraw <- initdraw
%old: was called _screen because screen was already use 
%  (to actually an Image, hmm), but I s/screen/view so now screen is free.
\t rename desktop (even if actually it's a subdesktop)

% screen is not screen of rio! it's actually a subscreen
% where client can create window in. Need subscreen because
% otherwise client could move around its own window? and need
% screen because only way for client to create its own window in it.
%(note that can still mess with Display->image, ugly)

\section{Additional (user) initializations}

\subsection{[[geninitdraw()]]}

% initdraw -> geninitdraw -> initdisplay; <>
<<[[geninitdraw()]] get window>>=
snprint(buf, sizeof buf, "%s/winname", display->windir);
if(gengetwindow(display, buf, &view, &screen, ref) < 0)
    goto Error;
@
%old: was &screen, &_screen
\l could call getwindow as it does this winname gymnastic

% ref is refresh method

% set the globals!

% so uses /dev/winname!
% which is noborder.screen.1 at the very beginning when run outside rio.


%\subsection{[[getwindow()]]}
<<function getwindow>>=
errorneg1
getwindow(Display *d, int ref)
{
    char winname[128];

    snprint(winname, sizeof winname, "%s/winname", d->windir);
    return gengetwindow(d, winname, &view, &screen, ref);
}
@
% not sure why need that, every app should go through
% initdraw and so should not call gengetwindow manually anyway.
% or maybe rio uses that? but then could move that in rio's code!

\subsection{[[gengetwindow()]]}

% use /dev/winname and named image! way to know from rio
% which window I'm associated with (but could cheat?)

% ref below is refresh
<<function gengetwindow>>=
/*
 * Attach, or possibly reattach, to window.
 * If reattaching, maintain value of screen pointer.
 */
errorneg1
gengetwindow(Display *d, char *winname, Image **winp, Screen **scrp, int ref)
{
    int n;
    fdt fd;
    char buf[64+1]; // /dev/winname content
    Image *image;
    Rectangle r;

    fd = open(winname, OREAD);
    if(fd<0 || (n=read(fd, buf, sizeof buf-1))<=0){
        // no /dev/winname, image is then the full screen
        image = d->image;
        <<[[gengetwindow()]] sanity check image from display>>
        strcpy(buf, "noborder");
    }else{
        close(fd);
        buf[n] = '\0';
        <<[[gengetwindow()]] if already had a view, free it>>
        // get our window!
        image = namedimage(d, buf);
        <<[[gengetwindow()]] sanity check image from namedimage>>
    }

    d->screenimage = image;
    *scrp = allocscreen(image, d->white, false);
    <<[[gengetwindow()]] sanity check srcp>>

    r = image->r;
    if(strncmp(buf, "noborder", 8) != 0)
        r = insetrect(image->r, Borderwidth);
    *winp = _allocwindow(*winp, *scrp, r, ref, DWhite);
    <<[[gengetwindow()]] sanity check winp>>
    d->screenimage = *winp;
    assert((*winp)->chan != 0);
    return OK_1;
}
@
% noborder trick a bit ugly.
\t could do originwindow here

% so app can mess up with its border :)

% draw.h
<<constant Borderwidth>>=
//coupling: must be equal to Selborder in rio
Borderwidth =	4,
@


% Note that works when run under rio and when not! in both cases
% view (via *winp) is set (and is always a window).

<<[[Display]] other fields>>=
// option<Image>, same than view, the window (or desktop image)
Image	*screenimage;
@
\t not sure why need that in Display.





<<[[gengetwindow()]] sanity check image from display>>=
if(image == nil){
    fprint(2, "gengetwindow: %r\n");
    <<[[gengetwindow()]] return error>>
}
@
<<[[gengetwindow()]] return error>>=
*winp = nil;
d->screenimage = nil;
return ERROR_NEG1;
@

<<[[gengetwindow()]] sanity check image from namedimage>>=
if(image == nil){
    fprint(2, "namedimage %s failed: %r\n", buf);
    <<[[gengetwindow()]] return error>>
}
assert(image->chan != 0);
@

<<[[gengetwindow()]] sanity check srcp>>=
if(*scrp == nil){
    freeimage(d->screenimage);
    <<[[gengetwindow()]] return error>>
}
@

<<[[gengetwindow()]] sanity check winp>>=
if(*winp == nil){
    freescreen(*scrp);
    *scrp = nil;
    freeimage(image);
    <<[[gengetwindow()]] return error>>
}
@
% winp = nil is redundant in return error but ok.





<<[[gengetwindow()]] if already had a view, free it>>=
if(*winp != nil){
    _freeimage1(*winp);
    freeimage((*scrp)->image);
    freescreen(*scrp);
    *scrp = nil;
}
@
% not *winp = nil?




\section{[[/dev/winname]] and [[screenname]]}

% kernel side now.

% default /dev/winname, so gengetwindow works also for bootstrap.

<<[[drawopen()]] switch qid cases>>=
case Qwinname:
    break;
@

<<[[drawread()]] if Qwinname>>=
if(QID(c->qid) == Qwinname)
    return readstr(off, a, n, screenname);
@

%\subsection{[[screename]]}
\n DName now in Image/Naming section

<<global screenname>>=
static  char    screenname[40];
@


<<[[makescreenimage()]] drawaddname>>=
if(!waserror()){
    snprint(screenname, sizeof screenname, "noborder.screen.%d", ++screennameid);
    drawaddname(nil, di, strlen(screenname), screenname);
    poperror();
}
@
% to bootstrap mechanism for /dev/winname!
% note that screen here is really screen, not Screen (desktop).
% noborder trick.
% drawaddname to draw_screen (screenimage) so made public so found
%  via initdraw for app running outside rio (and for rio itself)

<<global screennameid>>=
// gensym
static  int screennameid;
@

% drawlookupname for screename should always return screen_dimage!


% indirection to get image! go through a name!
% a bit like stdin/stdout = 0, 1, but behind the scene
% connected to different things.


% Rio will intercept this file as we will see in Windows.nw.
% It will create public images, and then make sure client can find them
% and "connect" to them.

%alt: why not pass down information via wsys instead like in newwindow?


\section{[[/dev/label]]}

%trans:
% /dev/winname is rio communicating info to client
% /dev/label is client communicating back info to rio

% so can identify the window when hidden

<<[[geninitdraw()]] write new label>>=
/*
 * Write label; ignore errors (we might not be running under rio)
 */
if(label){
    snprint(buf, sizeof buf, "%s/label", display->windir);
    fd = open(buf, OREAD);
    if(fd >= 0){
        read(fd, display->oldlabel, (sizeof display->oldlabel)-1);
        close(fd);
        fd = create(buf, OWRITE, 0666);
        if(fd >= 0){
            write(fd, label, strlen(label));
            close(fd);
        }
    }
}
@
% else? no error managment here?

% read old label, because when app take over previous app
% e.g. when run colors inside terminal, then want to switch back
% to terminal label when color exits.


<<[[Display]] other fields>>=
char	oldlabel[64];
@

% restore old label
<<[[_closedisplay()]] restore oldlabel>>=
if(disp->oldlabel[0]){
    snprint(buf, sizeof buf, "%s/label", disp->windir);
    fd = open(buf, OWRITE);
    if(fd >= 0){
        write(fd, disp->oldlabel, strlen(disp->oldlabel));
        close(fd);
    }
}
@

% write back old label, so when app run from terminal,
% we restore back the label so the window manager
% can display better titles



\section{[[newwindow()]]}

% see graphics(2)
% must be called before initdraw, to not take over existing window
% but create a new one. Communicate with rio!

% ex newwindow("-dy 100 -hide")  will run in newly created window
%  of 100 pixels high hidden at first.

% /env/wsys is location of rio listening server (its fd to connect to)

<<function newwindow>>=
/* Connect us to new window, if possible */
errorneg1
newwindow(char *str)
{
    fdt fd;
    char *wsys;
    char buf[256];

    wsys = getenv("wsys");
    <<[[newwindow()]] sanity check wsys>>
    fd = open(wsys, ORDWR);
    free(wsys);
    <<[[newwindow()]] sanity check fd>>
    rfork(RFNAMEG);

    if(str)
        snprint(buf, sizeof buf, "new %s", str);
    else
        strcpy(buf, "new");

    return mount(fd, -1, "/dev", MBEFORE, buf);
}
@
% mount! need see Windows.nw


<<[[newwindow()]] sanity check wsys>>=
if(wsys == nil)
    return ERROR_NEG1;
@

<<[[newwindow()]] sanity check fd>>=
if(fd < 0)
    return ERROR_NEG1;
@









\chapter{Input}

%trans: why talk about input in book mostly about output (Graphics)?
% because one important input, mouse, actually has some output feedback,
% the cursor! Graphics and mouse are strongly related (historically too).
% (ok can have cursor in text mode with gpm, but not the same)

\section{Mouse}

%example:
% show toy app code using mouse? which calls initmouse (non-event version)
% and then readmouse(), draw coords, and quit when middle click.

\subsection{[[/dev/mouse]] interface}

% bind("#m", "/dev")

% show kernel interface and refer to Kernel.nw

% can read /dev/mouse? yes first char code and then 5 numbers
%  using 12 chars (so readable interface!)
% e.g.
% $ cat /dev/mouse
% m xxx yyy zzz www ppp
% then move around and see update!

% can write on /dev/mouse? yes to change position, see moveto()

%trans:
% program could use directly /dev/mouse. Nice, easy.
% But then synchrone ... annoying. Need another model.

\subsection{Additional data structures}
% [[mouse.h]] interface
% user side

<<struct Mouse (include/mouse.h)>>=
struct	Mouse
{
    Point	xy;
    // bitset<enum<Click>>
    int	buttons;	/* bit array: LMR=124 */

    ulong	msec;
};
@
\l same in mouse.h and event.h, could factorize chunks?

\t msec? since last time?

<<enum Click>>=
enum Click {
    CLICK_LEFT = 1,
    CLICK_MIDDLE = 2,
    CLICK_RIGHT = 4,
};
@

% /dev/mouse and /dev/cursor handler

<<struct Mousectl>>=
struct Mousectl
{
    Mouse;

    // /dev/mouse
    fdt		mfd;		/* to mouse file */ 
    // ref_own<filename>
    char	*file; // "/dev/mouse" usually

    // ref<Image>
    Image*	image;	/* of associated window/display */

    <<[[Mousectl]] channel fields>>
    <<[[Mousectl]] IO process field>>
    <<[[Mousectl]] cursor field>>
};
@
%ctor = initmouse

% Image here! so kinda depends on graphics.
% why need image? because cursor! need to draw on top of main image?
\t actually not sure why it's needed

% use kencc extension above. Inline struct. See Compiler.nw book.
% kinda poor's man inheritance, so can use mc as a mouse and do
% things like mc->x, mc->buttons, no need mc->mouse->buttons.

% synchrone issue solved by plan9 concurrent model, use channel,
% so code can listen without blocking! But need trick.

<<[[Mousectl]] IO process field>>=
int		pid;	/* of slave proc */
@
% keep pid so can kill it when closemouse()

<<[[Mousectl]] channel fields>>=
// chan<Mouse> (listener = user program, sender = _ioproc(mouse.c))
Channel	*c;			/* chan(Mouse) */
@

% so code who wants to read info must
%  recv(mymc->c, &mymouseinfo)
%  and can use alt()! so non blocking. Event!
% See Libcore.nw

\subsection{Additional (user) initializations, [[initmouse()]]}

% in rio.c or trace.c: initmouse(nil, view)

% user program -> <>
<<function initmouse>>=
Mousectl*
initmouse(char *file, Image *i)
{
    Mousectl *mc;
    char *t, *sl;

    mc = mallocz(sizeof(Mousectl), true);

    if(file == nil)
        file = "/dev/mouse";
    mc->mfd = open(file, ORDWR|OCEXEC);
    <<[[initmouse()]] sanity check mfd>>
    mc->file = strdup(file);

    <<[[initmouse()]] set cursor field>>
    mc->image = i;
    <<[[initmouse()]] set channels>>
    <<[[initmouse()]] create process>>

    return mc;
}
@







<<[[initmouse()]] sanity check mfd>>=
if(mc->mfd < 0 && strcmp(file, "/dev/mouse")==0){
    bind("#m", "/dev", MAFTER);
    mc->mfd = open(file, ORDWR|OCEXEC);
}
if(mc->mfd < 0){
    free(mc);
    return nil;
}
@


\subsection{IO process and communication channels}

% not to confuse with Color channels ...
<<[[initmouse()]] set channels>>=
mc->c       = chancreate(sizeof(Mouse), 0);
@
% =~ pipe
% 0 so no buffering?

<<[[initmouse()]] create process>>=
proccreate(_ioproc, mc, 4096);
@
% pass around mc

% "server" of mouse information.

% Why in another proc? Why not a thread? because plan9 thread lib
%  are actually blocking when doing IO (a bit like in ocaml originally?)
%  so need extra process wrapper.


<<function _ioproc (lib_graphics/libdraw/mouse.c)>>=
static
void
_ioproc(void *arg)
{
    int n, nerr;
    char buf[1+5*12]; // /dev/mouse first code char and 5 numbers
    Mouse m;
    Mousectl *mc = arg;
    <<[[_ioproc()]] other locals (mouse.c)>>
 
    threadsetname("mouseproc");
    memset(&m, 0, sizeof m);
    mc->pid = getpid();

    nerr = 0;
    for(;;){
        // blocking call
        n = read(mc->mfd, buf, sizeof buf);
        <<[[_ioproc()]] sanity check n from read (mouse.c)>>
        nerr = 0;
        switch(buf[0]){
        <<[[_ioproc()]] switch buf, resize case, fallthrough m case (mouse.c)>>
        case 'm':

            m.xy.x    = atoi(buf+1+0*12);
            m.xy.y    = atoi(buf+1+1*12);
            m.buttons = atoi(buf+1+2*12);
            m.msec    = atoi(buf+1+3*12);

            // send it!
            send(mc->c, &m);

            /*
             * mc->Mouse is updated after send so it doesn't have wrong value
             * if we block during send.
             * This means that programs should receive into mc->Mouse 
             * (see readmouse() above) if they want full synchrony.
             */
            mc->Mouse = m;
            break;
        }
    }
}
@
% so only 4 numbers? why 5*12 then?

% comment???





<<[[_ioproc()]] sanity check n from read (mouse.c)>>=
if(n != 1+4*12){
    yield();	/* if error is due to exiting, we'll exit here */
    fprint(2, "mouse: bad count %d not 49: %r\n", n);
    if(n<0 || ++nerr>10)
        threadexits("read error");
    continue;
}
@
% yield?









<<function closemouse>>=
void
closemouse(Mousectl *mc)
{
    <<[[closemouse()]] sanity check mc>>

    postnote(PNPROC, mc->pid, "kill");

    do ; while(nbrecv(mc->c, &mc->Mouse) > 0);

    close(mc->mfd);
    close(mc->cfd);
    free(mc->file);
    free(mc->c);
    free(mc->resizec);
    free(mc);
}
@

<<[[closemouse()]] sanity check mc>>=
if(mc == nil)
    return;
@
% should issue warning!


\subsection{API}

<<function readmouse>>=
errorneg1
readmouse(Mousectl *mc)
{
    if(mc->image)
        flushimage(mc->image->display, true);
    if(recv(mc->c, &mc->Mouse) < 0){
        fprint(2, "readmouse: %r\n");
        return ERROR_NEG1;
    }
    return OK_0;
}
@
% info can be read then in mc->Mouse, so can actually do mc->x, mc->y, etc.

% why flushimage? to update cursor?

<<function moveto>>=
void
moveto(Mousectl *m, Point pt)
{
    fprint(m->mfd, "m%d %d", pt.x, pt.y);
    m->xy = pt;
}
@

% ok, nothing really graphics until now, but important DS
% for next section such as Mousectl passed to setcursor.


\section{Cursor}

% Cursor is very low-level actually. This is why sometimes everything
% is frozen and the only thing that still works is the cursor
% (see swcursorclock()).

% Strong link between Graphics.nw and Kernel.nw.
% Cursor related code is here, but devmouse.c is in Kernel.nw.
% Also hard to know if software cursor are generic code.

\subsection{Additionnal data structures}

\subsubsection{[[Cursor]]}
% and [[cursor]]

%in cursor.h
<<struct Cursor>>=
struct	Cursor
{
    Point	offset;

    byte	clr[2*16];
    byte	set[2*16];
};
@
% normally a 16x16 picture
% offset??
% used kernel side (also user side to load cursor, but less important)
%coupling: clr must be before set, cos code in setcursor() assumes so.
\l graphics(2) says clr/set are bad names and instead be white/black.

% FIGURE show cursor in bigger size where can see pixels.
% actually can see that cursor arrow is black at center, white on the border
% and transparent otherwise.


% see swload to understand format.
% Can be changed! e.g. in rio when hover over border of window, 
% cursor icon changes!

% screen.h interface
% vgascreen.c (seems general enough, could be put in a generic screen.c)
<<global arrow(x86)>>=
Cursor  arrow = {
    .offset = { -1, -1 },
    .clr = { 
      0xFF, 0xFF, 0x80, 0x01, 0x80, 0x02, 0x80, 0x0C, 
      0x80, 0x10, 0x80, 0x10, 0x80, 0x08, 0x80, 0x04, 
      0x80, 0x02, 0x80, 0x01, 0x80, 0x02, 0x8C, 0x04, 
      0x92, 0x08, 0x91, 0x10, 0xA0, 0xA0, 0xC0, 0x40, 
    },
    .set = { 
      0x00, 0x00, 0x7F, 0xFE, 0x7F, 0xFC, 0x7F, 0xF0, 
      0x7F, 0xE0, 0x7F, 0xE0, 0x7F, 0xF0, 0x7F, 0xF8, 
      0x7F, 0xFC, 0x7F, 0xFE, 0x7F, 0xFC, 0x73, 0xF8, 
      0x61, 0xF0, 0x60, 0xE0, 0x40, 0x40, 0x00, 0x00, 
    },
};
@
% picture? format? 16x16 bitmap??
% used by??
% offset?


%screen.h,  declared in screen.h and defined in  devmouse.c
<<struct Cursorinfo>>=
struct Cursorinfo {
  Cursor;
  Lock;
};
@
% Cursor with lock, used in kernel

<<global signature cursor>>=
extern Cursorinfo 	cursor;
@

% global cursor!! stuff do lock(&cursor)!


% See also VGAScr.Cursor

\subsubsection{Cursor rendering in software, cursor images}

% Can do cursor via software! just have cursor image,
% save image, and then draw/save appropriately!


<<global swback(x86)>>=
Memimage*   swback; /* screen under cursor */
@
% quite important!


% Grey1 version

<<global swimg1(x86)>>=
Memimage*   swimg1;
@
% should be just black color no?
<<global swmask1(x86)>>=
Memimage*   swmask1;
@
% mask of the bits of the cursor?

% why need Grey1 version too?


\subsubsection{Cursor coordinates and visibility}


<<global swpt(x86)>>=
Point   swpt;   /* desired cursor location */
@
<<global swvispt(x86)>>=
Point   swvispt;    /* actual cursor location */
@
% set by devmouse? mouse interrupt?

% used to optimize things in swcursorclock (avoid flickering?)



<<global swvers(x86)>>=
int swvers; /* incremented each time cursor image changes */
@
<<global swvisvers(x86)>>=
int swvisvers;  /* the version on the screen */
@
% changed by swload



% see swcursorclock for use of those globals

<<global swenabled(x86)>>=
bool swenabled;  /* is the cursor supposed to be on the screen? */
@
% set after cursoron() and swenable

<<global swvisible(x86)>>=
bool swvisible;  /* is the cursor visible? */
@
% set where? why it would not be visible? after swcursorhide,
%  but anyway should be followed by swcursordraw so not sure need this global.

\subsubsection{[[VGAcur]] and [[swcursor]]}

% VGAscr exposed in appendix (sad that have to introduce it here)
<<[[VGAscr]] cursor fields>>=
Cursor;
// the cursor device methods (software cursor or hardware support)
VGAcur* cur;
@
% so a scr is a cursor too ... argh, confusing I think.
\l name cursor cursor, and rename cur to curbackend?

% VGA cursor interface
<<struct VGAcur(x86)>>=
struct VGAcur {
  char* name;

  void  (*enable)(VGAscr*);
  void  (*disable)(VGAscr*);

  int   (*move)(VGAscr*, Point);

  void  (*load)(VGAscr*, Cursor*);

  // optional
  int doespanning;
};
@



<<global swcursor(x86)>>=
VGAcur swcursor =
{
    .name = "soft",

    .enable  = swenable,
    .disable = swdisable,

    .load = swload,
    .move = swmove,
};
@


\subsection{Additionnal (kernel) initializations}

% who set vgascreen.cur to swcursor?

% screensize is vgascreen.c, called by aux/vga to see the size
<<[[screensize()]] initializations part2>>=
if(didswcursorinit)
    swcursorinit();
@
% if did then redo?

<<global didswcursorinit(x86)>>=
bool didswcursorinit;
@
% if did it once that means we want to use swcursor?


% screensize | ?? -> <>
<<function swcursorinit(x86)>>=
void
swcursorinit(void)
{
    static bool init;
    VGAscr *scr;
    <<[[swcursorinit()]] other locals>>

    didswcursorinit = true;
    if(!init){
        init = true;
        addclock0link(swcursorclock, 10);
    }
    scr = &vgascreen;

    <<[[swcursorinit()]] sanity check scr regarding cursor>>
    <<[[swcursorinit()]] free old versions of cursor images if any>>

    swback  = allocmemimage(Rect(0,0,32,32), gscreen->chan);

    swmask  = allocmemimage(Rect(0,0,16,16), GREY8);
    swmask1 = allocmemimage(Rect(0,0,16,16), GREY1);
    swimg   = allocmemimage(Rect(0,0,16,16), GREY8);
    swimg1  = allocmemimage(Rect(0,0,16,16), GREY1);

    <<[[swcursorinit()]] sanity check cursor images>>

    memfillcolor(swmask,  DOpaque);
    memfillcolor(swmask1, DOpaque);
    memfillcolor(swimg,   DBlack);
    memfillcolor(swimg1,  DBlack);
}
@
% why 32 for swback? just to be safe? a bit ugly.

% Not sure why need to do that at resize, like for memimageinit.
% Maybe because use gscreen->chan here.


% Grey8 version

<<global swimg(x86)>>=
Memimage*   swimg;  /* cursor image */
@
<<global swmask(x86)>>=
Memimage*   swmask; /* cursor mask */
@
% initialized by swcursorinit, but set by by swload. used then
% to draw in swimg1.




<<[[swcursorinit()]] other locals>>=
static bool warned;
@
<<[[swcursorinit()]] sanity check scr regarding cursor>>=
if(scr == nil || gscreen == nil)
    return;
if(scr->dev == nil || scr->dev->linear == nil){
    if(!warned){
        print("cannot use software cursor on non-linear vga screen\n");
        warned = true;
    }
    return;
}
@
% linear??

<<[[swcursorinit()]] free old versions of cursor images if any>>=
if(swback){
    freememimage(swback);
    freememimage(swmask);
    freememimage(swmask1);
    freememimage(swimg);
    freememimage(swimg1);
}
@

<<[[swcursorinit()]] sanity check cursor images>>=
if(swback == nil || swmask == nil || swmask1 == nil || swimg == nil || swimg1 == nil){
    print("software cursor: allocmemimage fails");
    return;
}
@



\subsection{[[swcursorclock()]]}

% important!

% ?? -> <> (as ?? <- addlock0link(<>) <- swcursorinit
% so called at each clock interrupt 
<<function swcursorclock(x86)>>=
void
swcursorclock(void)
{
    int x;

    if(!swenabled)
        return;
    if(swvisible && eqpt(swpt, swvispt) && swvers==swvisvers)
        return;

    x = splhi();
    // check again, might have changed in between
    if(swenabled)
     if(!swvisible || !eqpt(swpt, swvispt) || swvers!=swvisvers)
      if(canqlock(&drawlock)){

        swcursorhide();
        swcursordraw();

        qunlock(&drawlock);
    }
    splx(x);
}
@
% if !swvisible?

% why not do that in devmouse interrupt? to do as few as possible
% in devmouse? to separate concerns?

% check again with splhi so sure devmouse will not change those variables?
% use canqlock otherwise deadlock!

% who changes swpt? devmouse?



<<global swrect(x86)>>=
Rectangle   swrect; /* screen rectangle in swback */
@
% why need to be a global? because used in swcursorhide after.


% swcursorclock | swenable -> <> (assumes drawlock is hold)
<<function swcursordraw(x86)>>=
void
swcursordraw(void)
{
    if(swvisible)
        return;
    if(!swenabled)
        return;
    if(swback == nil || swimg1 == nil || swmask1 == nil)
        return;
    assert(!canqlock(&drawlock));

    swvispt = swpt;
    swvisvers = swvers;
    // cursor is 16x16 picture
    swrect = rectaddpt(Rect(0,0,16,16), swvispt);
    // save what is under the cursor
    memimagedraw(swback, swback->r, gscreen, swpt, memopaque, ZP, S);
    // draw cursor
    memimagedraw(gscreen, swrect, swimg1, ZP, swmask1, ZP, SoverD);
    flushmemscreen(swrect);
    swvisible = true;
}
@
% no use swimg here. dead?

% swcursorclock | (hwdraw -> swcursoravoid) -> <>
<<function swcursorhide(x86)>>=
/*
 * called with drawlock locked for us, most of the time.
 * kernel prints at inopportune times might mean we don't
 * hold the lock, but memimagedraw is now reentrant so
 * that should be okay: worst case we get cursor droppings.
 */
void
swcursorhide(void)
{
    if(!swvisible)
        return;
    if(swback == nil)
        return;

    swvisible = false;
    // restore what was under the cursor
    memimagedraw(gscreen, swrect, swback, ZP, memopaque, ZP, S);
    flushmemscreen(swrect);
}
@
% comment?

% actually called before swcursordraw while swrect has not been set
%  the very first time




\subsection{Drawing rectangles and software cursor}

% swcursorclock modifies gscreen, but what if draw operation
%  with screen as targer or source? then need restore 
%  original gscreen first, so need to call swcursorhide() first!
% (and who is gonna restore it? swcursorclock!)


<<[[hwdraw()]] if software cursor(x86)>>=
if(scr->cur == &swcursor){
    /*
     * always calling swcursorhide here doesn't cure
     * leaving cursor tracks nor failing to refresh menus
     * with the latest libmemdraw/draw.c.
     */
    if(dst->data->bdata == gscreendata.bdata)
        swcursoravoid(par->r);
    if(src->data->bdata == gscreendata.bdata)
        swcursoravoid(par->sr);
    if(mask->data->bdata == gscreendata.bdata)
        swcursoravoid(par->mr);
}
@

% if no hardware accel then no call to hwdraw, but ok?

<<function swcursoravoid(x86)>>=
void
swcursoravoid(Rectangle r)
{
    if(swvisible && rectXrect(r, swrect))
        swcursorhide();
}
@


\subsection{Enabling the cursor}

% screen.h interface, vgascreen.c
% ?? -> <>
<<function cursoron(x86)>>=
int
cursoron(bool dolock)
{
    VGAscr *scr;
    int v;

    scr = &vgascreen;
    if(scr->cur == nil || scr->cur->move == nil)
        return 0;

    if(dolock)
        lock(&cursor);

    v = scr->cur->move(scr, mousexy());

    if(dolock)
        unlock(&cursor);

    return v;
}
@
% use of the global!
% mousexy() also part of screen.h interface, but should
% be implemented by devmouse.c or mouse.c

% screen.h interface again, vgascreen.c
% ?? -> <>
<<function cursoroff(x86)>>=
void
cursoroff(int)
{
}
@
% empty? not even swcursorhide()?



% relation between cursoron and swenable?


% ?? -> <> (as xx <- swcursor.enable = <> <- xxx.c?)
<<function swenable(x86)>>=
/*
 * Need to lock drawlock for ourselves.
 */
void
swenable(VGAscr*)
{
    swenabled = true;
    if(canqlock(&drawlock)){
        swcursordraw();
        qunlock(&drawlock);
    }
}
@
% if can not qlock? just continue? without draw?

<<function swdisable(x86)>>=
void
swdisable(VGAscr*)
{
    swenabled = false;
    if(canqlock(&drawlock)){
        swcursorhide();
        qunlock(&drawlock);
    }
}
@

\subsection{Loading the cursor}

% Important that can be changed. Rio uses that.

% screen.h interface, vgascreen.c
% called from mouse.c?
% ?? -> <>
<<function ksetcursor(x86)>>=
void
ksetcursor(Cursor* curs)
{
    VGAscr *scr;

    scr = &vgascreen;
    if(scr->cur == nil || scr->cur->load == nil)
        return;

    scr->cur->load(scr, curs);
}
@
% kxxx this time, cos kernel side



<<function swload(x86)>>=
void
swload(VGAscr*, Cursor *curs)
{
    byte *ip, *mp;
    int i, j, set, clr;

    if(!swimg || !swmask || !swimg1 || !swmask1)
        return;
    /*
     * Build cursor image and mask.
     * Image is just the usual cursor image
     * but mask is a transparent alpha mask.
     * 
     * The 16x16x8 memimages do not have
     * padding at the end of their scan lines.
     */
    ip = byteaddr(swimg, ZP);
    mp = byteaddr(swmask, ZP);

    for(i=0; i<32; i++){
        set = curs->set[i];
        clr = curs->clr[i];
        for(j=0x80; j; j>>=1){
            *ip++ = set & j ? 0x00 : 0xFF;
            *mp++ = (clr|set) & j ? 0xFF : 0x00;
        }
    }
    swoffset = curs->offset;
    swvers++;

    memimagedraw(swimg1,  swimg1->r,  swimg,  ZP, memopaque, ZP, S);
    memimagedraw(swmask1, swmask1->r, swmask, ZP, memopaque, ZP, S);
}
@
% use of swimg outside swload? so why not make a local?
% why not directly modify swimg1? why the intermediate?


% see also adv topics section on setcursor and /dev/cursor

<<global swoffset(x86)>>=
Point   swoffset;
@

<<function swmove(x86)>>=
int
swmove(VGAscr*, Point p)
{
    swpt = addpt(p, swoffset);
    return 0;
}
@
% swpt global
% not sure why need swoffset






\section{Keyboard}
\n put mouse first because the mouse is more related to graphical app

% In graphical app need different model for keyboard too. 
% Dont want synchrone key reading. Can not use scanf.
% Need similar archi that for mouse, and then can
% use alt().

%related: big-bang function in racket/htdp


\subsection{[[/dev/cons]] and [[/dev/consctl]] interface}

% Refer to Kernel.nw

% first issue is that /dev/cons is buffered. when do read /dev/cons,
% get answer only after newline. Dont want that for graphical app
% where need to draw char after each type, different font, etc
% (in text mode this is handled by the kernel itself).

% so need /dev/consctl and rawon.
% but then synchrony issue like for /dev/mouse, so need again
% channels.

\subsection{Additional data structures}

<<enum _anon_ (include/keyboard.h)>>=
enum {
    KF=	0xF000,	/* Rune: beginning of private Unicode space */
    Spec=	0xF800,

    /* KF|1, KF|2, ..., KF|0xC is F1, F2, ..., F12 */
    Khome=	KF|0x0D,
    Kpgup=	KF|0x0F,
    Kpgdown=	KF|0x13,
    Kprint=	KF|0x10,

    Kup=	KF|0x0E,
    Kdown=	Spec|0x00,
    Kleft=	KF|0x11,
    Kright=	KF|0x12,

    Kview=	Spec|0x00,
    Kins=	KF|0x14,
    Kend=	KF|0x18,

    Kalt=	KF|0x15,
    Kshift=	KF|0x16,
    Kctl=	KF|0x17,

    Kdel=	0x7f,
    Kesc=	0x1b,
    Keof=	0x04, // C-d
    Kbs=	0x08, // C-h (backspace)
};
@
% similar to 'enum specialkey' in Kernel.nw
% note that 1-26 are C-a, C-b, ...
%todo: reorder?
%less: Kview and Kdown. Kview is used by the console, to scroll down

% similar to Mousectl
<<struct Keyboardctl>>=
struct	Keyboardctl
{
    // /dev/cons
    fdt		consfd;		/* to cons file */
    char	*file;

    // dev/consctl
    fdt		ctlfd;		/* to ctl file */

    // chan<Rune, 20> (listener = user program, sender = _ioproc(keyboard.c))
    Channel	*c;	/* chan(Rune)[20] */

    int		pid;		/* of slave proc */
};
@
% 20 so buffer of 20 Rune?

\subsection{Additional (user) initializations, [[initkeyboard()]]}

<<function initkeyboard>>=
Keyboardctl*
initkeyboard(char *file)
{
    Keyboardctl *kc;
    char *t;

    kc = mallocz(sizeof(Keyboardctl), 1);
    <<[[initkeyboard()]] sanity check kc>>

    if(file == nil)
        file = "/dev/cons";
    kc->file = strdup(file);
    kc->consfd = open(file, ORDWR|OCEXEC);

    t = malloc(strlen(file)+16);
    <<[[initkeyboard()]] sanity check t and consfd>>
    sprint(t, "%sctl", file);
    kc->ctlfd = open(t, OWRITE|OCEXEC);
    <<[[initkeyboard()]] sanity check ctlfd>>

    if(ctlkeyboard(kc, "rawon") < 0){
        fprint(2, "initkeyboard: can't turn on raw mode on %s: %r\n", t);
        close(kc->ctlfd);
        goto Error2;
    }
    free(t);

    kc->c = chancreate(sizeof(Rune), 20);
    proccreate(_ioproc, kc, 4096);

    return kc;
}
@

% initmouse | ??? -> <>
<<function ctlkeyboard>>=
int
ctlkeyboard(Keyboardctl *kc, char *m)
{
    return write(kc->ctlfd, m, strlen(m));
}
@




<<[[initkeyboard()]] sanity check kc>>=
if(kc == nil)
    return nil;
@

<<[[initkeyboard()]] sanity check t and consfd>>=
if(kc->consfd<0 || t == nil){
Error1:
    free(kc);
    return nil;
}
@

<<[[initkeyboard()]] sanity check ctlfd>>=
if(kc->ctlfd < 0){
    fprint(2, "initkeyboard: can't open %s: %r\n", t);
Error2:
    close(kc->consfd);
    free(t);
    goto Error1;
}
@

\subsection{IO process and communication channels}

<<function _ioproc>>=
static
void
_ioproc(void *arg)
{
    Keyboardctl *kc = arg;
    int m, n;
    char buf[20];
    Rune r;

    threadsetname("kbdproc");
    kc->pid = getpid();

    n = 0;
    for(;;){
        while(n>0 && fullrune(buf, n)){
            m = chartorune(&r, buf);
            n -= m;
            memmove(buf, buf+m, n);
            // sent it!
            send(kc->c, &r);
        }
        // blocking call
        m = read(kc->consfd, buf+n, sizeof buf-n);
        <<[[_ioproc()]] sanity check m from read (keyboard.c)>>
        n += m;
    }
}
@


<<[[_ioproc()]] sanity check m from read (keyboard.c)>>=
if(m <= 0){
    yield();	/* if error is due to exiting, we'll exit here */
    fprint(2, "keyboard read error: %r\n");
    threadexits("error");
}
@

<<function closekeyboard>>=
void
closekeyboard(Keyboardctl *kc)
{
    if(kc == nil)
        return;

    postnote(PNPROC, kc->pid, "kill");
    close(kc->ctlfd);
    close(kc->consfd);
    free(kc->file);
    free(kc->c);
    free(kc);
}
@
%//#ifdef BUG
%//	/* Drain the channel */
%//	while(?kc->c)
%//		<-kc->c;
%//#endif



%\section{Events}
%  in advanced topics now and move also egetrect.c and emenuhits.c?


%\chapter{Widgets}
% now in Widgets.nw


\chapter{Non 32 Bits Images TODO}

% Actually need Grey1 (many bitmasks), need CMAP (VGA), 
% need Grey8 (Cursor), need RGB16 (Raspberry), ...
% So need many of the logic that makes it possible to have
% images with pixels of different depth and different color arrangments.

<<[[ImageType] cases>>=
GREY2	= CHAN1(CGrey, 2),
GREY4	= CHAN1(CGrey, 4),
GREY8	= CHAN1(CGrey, 8),

RGB15	= CHAN4(CIgnore, 1, CRed, 5, CGreen, 5, CBlue, 5),
RGB24	= CHAN3(CRed, 8, CGreen, 8, CBlue, 8),
BGR24	= CHAN3(CBlue, 8, CGreen, 8, CRed, 8),
@
% RGB24 used for background image in rio, as no need for alpha

<<[[ImageChan]] cases>>=
CIgnore,
@
% used for padding to get byte boundaries for pixels.


% other formats for 32 bits, but less useful.
<<[[ImageType] cases>>=
ABGR32	= CHAN4(CAlpha, 8, CBlue, 8, CGreen, 8, CRed, 8),

XRGB32	= CHAN4(CIgnore, 8, CRed, 8, CGreen, 8, CBlue, 8),
XBGR32	= CHAN4(CIgnore, 8, CBlue, 8, CGreen, 8, CRed, 8),
@


\section{1-Bit images}
% or bitmasks

% GREY1, used for masks


% some kind of optimisations
<<[[memoptdraw()]] if 1 bit mask, src, and dest>>=
/*
 * If we have a 1-bit mask, 1-bit source, and 1-bit destination, and
 * they're all bit aligned, we can just use bit operators.  This happens
 * when we're manipulating boolean masks, e.g. in the arc code.
 */
if((par->state&(Simplemask|Simplesrc|Replmask|Replsrc))==0 
&& dst->chan==GREY1 
&& src->chan==GREY1 
&& par->mask->chan==GREY1 
&& (par->r.min.x&7)==(par->sr.min.x&7) 
&& (par->r.min.x&7)==(par->mr.min.x&7)){
    uchar *sp, *dp, *mp;
    uchar lm, rm;
    long swid, dwid, mwid;
    int i, x, dir;

    sp = byteaddr(src, par->sr.min);
    dp = byteaddr(dst, par->r.min);
    mp = byteaddr(par->mask, par->mr.min);
    swid = src->width*sizeof(ulong);
    dwid = dst->width*sizeof(ulong);
    mwid = par->mask->width*sizeof(ulong);

    if(src->data == dst->data 
    && byteaddr(dst, par->r.min) > byteaddr(src, par->sr.min)){
        dir = -1;
    }else
        dir = 1;

    lm = 0xFF>>(par->r.min.x&7);
    rm = 0xFF<<(8-(par->r.max.x&7));
    dx -= (8-(par->r.min.x&7)) + (par->r.max.x&7);

    if(dx < 0){	/* one byte wide */
        lm &= rm;
        if(dir == -1){
            dp += dwid*(dy-1);
            sp += swid*(dy-1);
            mp += mwid*(dy-1);
            dwid = -dwid;
            swid = -swid;
            mwid = -mwid;
        }
        for(y=0; y<dy; y++){
            *dp ^= (*dp ^ *sp) & *mp & lm;
            dp += dwid;
            sp += swid;
            mp += mwid;
        }
        return 1;
    }

    dx /= 8;
    if(dir == 1){
        i = (lm!=0)+dx+(rm!=0);
        mwid -= i;
        swid -= i;
        dwid -= i;
        for(y=0; y<dy; y++, dp+=dwid, sp+=swid, mp+=mwid){
            if(lm){
                *dp ^= (*dp ^ *sp++) & *mp++ & lm;
                dp++;
            }
            for(x=0; x<dx; x++){
                *dp ^= (*dp ^ *sp++) & *mp++;
                dp++;
            }
            if(rm){
                *dp ^= (*dp ^ *sp++) & *mp++ & rm;
                dp++;
            }
        }
        return 1;
    }else{
    /* dir == -1 */
        i = (lm!=0)+dx+(rm!=0);
        dp += dwid*(dy-1)+i-1;
        sp += swid*(dy-1)+i-1;
        mp += mwid*(dy-1)+i-1;
        dwid = -dwid+i;
        swid = -swid+i;
        mwid = -mwid+i;
        for(y=0; y<dy; y++, dp+=dwid, sp+=swid, mp+=mwid){
            if(rm){
                *dp ^= (*dp ^ *sp--) & *mp-- & rm;
                dp--;
            }
            for(x=0; x<dx; x++){
                *dp ^= (*dp ^ *sp--) & *mp--;
                dp--;
            }
            if(lm){
                *dp ^= (*dp ^ *sp--) & *mp-- & lm;
                dp--;
            }
        }
    }
    return 1;
}
@
% >> >> >> >>


\section{Small depth images}

% Each time nbits[] is used in code before, it is handling
% small depth images (e.g. in writebyte() for alphadraw()).
% so there are more code than in this section related to
% small depth images.


<<[[pixelbits()]] other locals>>=
int off, npack;
@
<<[[pixelbits()]] switch bpp cases>>=
case 1:
case 2:
case 4:
    npack = 8/bpp;
    off = pt.x % npack;
    val = p[0] >> bpp*(npack-1-off);
    val &= (1<<bpp)-1;
    break;
@
% >>





<<[[imgtorgba()]] duplicate bits if nb less than 8>>=
// duplicate bits
while(nb < 8){
    v |= v<<nb;
    nb *= 2;
}
v >>= (nb-8);
@
% for GREY1? for RBG16? works?




<<[[byteaddr()]] if depth less than 8>>=
if(i->depth < 8){
    /*
     * We need to always round down,
     * but C rounds toward zero.
     */
    int np;
    np = 8/i->depth;
    if(p.x < 0)
        return a+(p.x-np+1)/np;
    else
        return a+p.x/np;
}
@

<<[[allocimagemix()]] if depth less than 8>>=
if(d->screenimage->depth <= 8){	/* create a 2x2 texture */
    t = allocimage(d, Rect(0,0,1,1), d->screenimage->chan, false, color1);
    if(t == nil)
        return nil;

    b = allocimage(d, Rect(0,0,2,2), d->screenimage->chan, true, color3);
    if(b == nil){
        freeimage(t);
        return nil;
    }

    draw(b, Rect(0,0,1,1), t, nil, ZP);
    freeimage(t);
    return b;
}
@


<<[[memoptdraw()]] locals for memset case>>=
int ppb, np, nb;
uchar lm, rm;
int d;
@

<<[[memoptdraw()]] when condition for memset, switch depth of dst cases>>=
case 1:
case 2:
case 4:
    for(d=dst->depth; d<8; d*=2)
        v |= (v<<d);
    ppb = 8/dst->depth;	/* pixels per byte */
    m = ppb-1;
    /* left edge */
    np = par->r.min.x&m;		/* no. pixels unused on left side of word */
    dx -= (ppb-np);
    nb = 8 - np * dst->depth;		/* no. bits used on right side of word */
    lm = (1<<nb)-1;
    DBG1("np %d x %d nb %d lm %ux ppb %d m %ux\n", np, par->r.min.x, nb, lm, ppb, m);	

    /* right edge */
    np = par->r.max.x&m;	/* no. pixels used on left side of word */
    dx -= np;
    nb = 8 - np * dst->depth;		/* no. bits unused on right side of word */
    rm = ~((1<<nb)-1);
    DBG1("np %d x %d nb %d rm %ux ppb %d m %ux\n", np, par->r.max.x, nb, rm, ppb, m);	

    DBG1("dx %d Dx %d\n", dx, Dx(par->r));
    /* lm, rm are masks that are 1 where we should touch the bits */
    if(dx < 0){	/* just one byte */
        lm &= rm;
        for(y=0; y<dy; y++, dp+=dwid)
            *dp ^= (v ^ *dp) & lm;
    }else if(dx == 0){	/* no full bytes */
        if(lm)
            dwid--;

        for(y=0; y<dy; y++, dp+=dwid){
            if(lm){
              DBG1("dp %p v %lux lm %ux (v ^ *dp) & lm %lux\n", dp, v, lm, (v^*dp)&lm);
                *dp ^= (v ^ *dp) & lm;
                dp++;
            }
            *dp ^= (v ^ *dp) & rm;
        }
    }else{		/* full bytes in middle */
        dx /= ppb;
        if(lm)
            dwid--;
        dwid -= dx;

        for(y=0; y<dy; y++, dp+=dwid){
            if(lm){
                *dp ^= (v ^ *dp) & lm;
                dp++;
            }
            memset(dp, v, dx);
            dp += dx;
            *dp ^= (v ^ *dp) & rm;
        }
    }
    return true;
@
% >> >> >> >>

<<[[memoptdraw()]] when condition for memset, switch depth of dst cases>>=
default:
    assert(0 /* bad dest depth in memoptdraw */);
@


<<[[setcolor()]] switch depth cases>>=
case 1:
case 2:
case 4:
    x = 0x0F;
    break;
@


<<[[readfn()]] if depth less than 8>>=
if(img->depth < 8)
    return readnbit;
@


<<function readnbit>>=
static Buffer
readnbit(Param *p, uchar *buf, int y)
{
    Buffer b;
    Memimage *img;
    uchar *repl, *r, *w, *ow, bits;
    int i, n, sh, depth, x, dx, npack, nbits;

    b.rgba = (ulong*)buf;
    b.grey = w = buf;
    b.red = b.blu = b.grn = w;
    b.alpha = &ones;
    b.delta = 1;

    dx = p->dx;
    img = p->img;
    depth = img->depth;
    repl = &replbit[depth][0];
    npack = 8/depth;
    sh = 8-depth;

    /* copy from p->r.min.x until end of repl rectangle */
    x = p->r.min.x;
    n = dx;
    if(n > p->img->r.max.x - x)
        n = p->img->r.max.x - x;

    r = p->bytermin + y*p->bwidth;
    DBG1("readnbit dx %d %p=%p+%d*%d, *r=%d fetch %d ", dx, r, p->bytermin, y, p->bwidth, *r, n);
    bits = *r++;
    nbits = 8;
    if(i=x&(npack-1)){
        DBG1("throwaway %d...", i);
        bits <<= depth*i;
        nbits -= depth*i;
    }
    for(i=0; i<n; i++){
        if(nbits == 0){
            DBG1("(%.2ux)...", *r);
            bits = *r++;
            nbits = 8;
        }
        *w++ = repl[bits>>sh];
        DBG1("bit %x...", repl[bits>>sh]);
        bits <<= depth;
        nbits -= depth;
    }
    dx -= n;
    if(dx == 0)
        return b;

    assert(x+i == p->img->r.max.x);

    /* copy from beginning of repl rectangle until where we were before. */
    x = p->img->r.min.x;
    n = dx;
    if(n > p->r.min.x - x)
        n = p->r.min.x - x;

    r = p->bytey0s + y*p->bwidth;
    DBG1("x=%d r=%p...", x, r);
    bits = *r++;
    nbits = 8;
    if(i=x&(npack-1)){
        bits <<= depth*i;
        nbits -= depth*i;
    }
    DBG1("nbits=%d...", nbits);
    for(i=0; i<n; i++){
        if(nbits == 0){
            bits = *r++;
            nbits = 8;
        }
        *w++ = repl[bits>>sh];
        DBG1("bit %x...", repl[bits>>sh]);
        bits <<= depth;
        nbits -= depth;
        DBG1("bits %x nbits %d...", bits, nbits);
    }
    dx -= n;
    if(dx == 0)
        return b;

    assert(dx > 0);
    /* now we have exactly one full scan line: just replicate the buffer itself until we are done */
    ow = buf;
    while(dx--)
        *w++ = *ow++;

    return b;
}
@
% >> 

<<[[writefn()]] if depth less than 8>>=
if(img->depth < 8)
    return writenbit;
@

<<function writenbit>>=
static void
writenbit(Param *p, uchar *w, Buffer src)
{
    uchar *r;
    ulong bits;
    int i, sh, depth, npack, nbits, x, ex;

    assert(src.grey != nil && src.delta == 1);

    x = p->r.min.x;
    ex = x+p->dx;
    depth = p->img->depth;
    npack = 8/depth;

    i=x&(npack-1);
    bits = i ? (*w >> (8-depth*i)) : 0;
    nbits = depth*i;
    sh = 8-depth;
    r = src.grey;

    for(; x<ex; x++){
        bits <<= depth;
        DBG1(" %x", *r);
        bits |= (*r++ >> sh);
        nbits += depth;
        if(nbits == 8){
            *w++ = bits;
            nbits = 0;
        }
    }

    if(nbits){
        sh = 8-nbits;
        bits <<= sh;
        bits |= *w & ((1<<sh)-1);
        *w = bits;
    }
    DBG1("\n");
    return;
}
@
% >> >>





<<[[loadmemimage()]] other locals>>=
int mx, m, mr;
@

<<[[loadmemimage()]] set mx, lpart, rpart, m for small depth images>>=
mx = 7 / i->depth;
lpart = (r.min.x & mx) * i->depth;
rpart = (r.max.x & mx) * i->depth;
m = 0xFF >> lpart;
@

<<[[loadmemimage()]] if 1 byte per line>>=
/* may need to do bit insertion on edges */
if(l == 1){	/* all in one byte */
    if(rpart)
        m ^= 0xFF >> rpart;
    for(y = r.min.y; y < r.max.y; y++){
        *q ^= (*data ^ *q) & m;
        q += i->width*sizeof(ulong);
        data++;
    }
    return ndata;
}
@
% more an opti than a small depth images, but still has some pieces of code
%  related to small depth images



<<[[loadmemimage()]] when small depth images>>=
mr = 0xFF ^ (0xFF >> rpart);
if(lpart!=0 && rpart==0){
    for(y=r.min.y; y<r.max.y; y++){
        *q ^= (*data^*q) & m;
        if(l > 1)
            memmove(q+1, data+1, l-1);
        q += i->width*sizeof(ulong);
        data += l;
    }
    return ndata;
}
if(lpart==0 && rpart!=0){
    for(y=r.min.y; y<r.max.y; y++){
        if(l > 1)
            memmove(q, data, l-1);
        q[l-1] ^= (data[l-1]^q[l-1]) & mr;
        q += i->width*sizeof(ulong);
        data += l;
    }
    return ndata;
}
for(y=r.min.y; y<r.max.y; y++){
    *q ^= (*data^*q) & m;
    if(l > 2)
        memmove(q+1, data+1, l-2);
    q[l-1] ^= (data[l-1]^q[l-1]) & mr;
    q += i->width*sizeof(ulong);
    data += l;
}
return ndata;
@



\section{8-bits images}

<<[[memoptdraw()]] when condition for memset, switch depth of dst cases>>=
case 8:
    for(y=0; y < dy; y++, dp += dwid)
        memset(dp, v, dx);
    return true;
@

<<[[chardraw()]] switch depth cases>>=
case 8:
    DBG1("8loop...");
    wc = wp;
    for(x=bx; x>ex; x--, wc++){
        i = x&7;
        if(i == 8-1)
            bits = *q++;
        DBG1("bits %lux sh %d...", bits, i);
        if((bits>>i)&1)
            *wc = v;
    }
    break;
@

<<[[getcolor()]] switch depth cases>>=
case 8:
    x = 0xFF;
    break;
@

<<[[setcolor()]] switch depth cases>>=
case 8:
    x = 0xFF;
    break;
@


\section{16-bits images}

% raspberry is in RGB16 by default

<<[[pixelbits()]] switch bpp cases>>=
case 16:
    val = p[0]|(p[1]<<8);
    break;
@
% >>

<<[[memoptdraw()]] when condition for memset, switch depth of dst cases>>=
case 16:
    p[0] = v;		/* make little endian */
    p[1] = v>>8;
    v = *(ushort*)p;
    DBG("dp=%p; dx=%d; for(y=0; y<%d; y++, dp+=%d)\nmemsets(dp, v, dx);\n",         	dp, dx, dy, dwid);
    for(y=0; y<dy; y++, dp+=dwid)
        memsets(dp, v, dx);
    return 1;
@

<<function memsets>>=
static void
memsets(void *vp, ushort val, int n)
{
    ushort *p, *ep;

    p = vp;
    ep = p+n;
    while(p<ep)
        *p++ = val;
}
@


<<[[chardraw()]] switch depth cases>>=
case 16:
    ws = (ushort*)wp;
    v = *(ushort*)sp;
    for(x=bx; x>ex; x--, ws++){
        i = x&7;
        if(i == 8-1)
            bits = *q++;
        DBG1("bits %lux sh %d...", bits, i);
        if((bits>>i)&1)
            *ws = v;
    }
    break;
@


\section{24-bits images}

<<[[pixelbits()]] switch bpp cases>>=
case 24:
    val = p[0]|(p[1]<<8)|(p[2]<<16);
    break;
@
% >> >>

<<[[memoptdraw()]] when condition for memset, switch depth of dst cases>>=
case 24:
    for(y=0; y<dy; y++, dp+=dwid)
        memset24(dp, v, dx);
    return 1;
@

<<function memset24>>=
static void
memset24(void *vp, ulong val, int n)
{
    uchar *p, *ep;
    uchar a,b,c;

    p = vp;
    ep = p+3*n;

    a = val;
    b = val>>8;
    c = val>>16;
    while(p<ep){
        *p++ = a;
        *p++ = b;
        *p++ = c;
    }
}
@

<<[[memfillcolor()]] other colors>>=
int y;
@

<<[[memfillcolor()]] switch depth cases>>=
case 24:	/* 24-bit images suck */
    for(y=i->r.min.y; y<i->r.max.y; y++)
        memset24(byteaddr(i, Pt(i->r.min.x, y)), bits, Dx(i->r));
    break;
@


<<[[chardraw()]] switch depth cases>>=
case 24:
    wc = wp;
    for(x=bx; x>ex; x--, wc+=3){
        i = x&7;
        if(i == 8-1)
            bits = *q++;
        DBG1("bits %lux sh %d...", bits, i);
        if((bits>>i)&1){
            wc[0] = sp[0];
            wc[1] = sp[1];
            wc[2] = sp[2];
        }
    }
    break;
@



\section{Grey images}

<<[[imgtorgba()]] switch chan type cases>>=
case CGrey:
    r = g = b = v;
    break;
@

<<[[rgbatoimg()]] switch chan type cases>>=
case CGrey:
    m = RGB2K(r,g,b);
    v |= (m>>(8-nb))<<d;
    break;
@
% >>


<<function RGB2K>>=
/* perfect approximation to NTSC = .299r+.587g+.114b when 0 ≤ r,g,b < 256 */
#define RGB2K(r,g,b)	((156763*(r)+307758*(g)+59769*(b))>>19)
@


% Lots of isgrey fields and parameters. I could aspectize even more.

<<[[readbyte()]] in simple case, if isgrey>>=
if(isgrey){
    b.grey = r + img->shift[CGrey]/8;
    b.red = b.grn = b.blu = b.grey;
@


<<[[writebyte()]] if isgrey>>=
if(isgrey){
    u |= ((*grey >> (8-img->nbits[CGrey])) & img->mask[CGrey]) << img->shift[CGrey];
    grey += delta;
}
@
% >> >>


<<[[alphacalc11()]] if isgrey>>=
if(grey){
    *bdst.grey = MUL(ma, *bsrc.grey, s) + MUL(fd, *bdst.grey, t);
    bsrc.grey += bsrc.delta;
    bdst.grey += bdst.delta;
}
@


\section{Color maps images}
% remember that CMap is enum in core DS.

% need color map if use RGBA32? No but VGA seems to be limited to depth 8 :(

% color(2), color(6)

\subsection{[[RGB]]}

<<struct RGB>>=
struct RGB
{
    ulong	red;
    ulong	green;
    ulong	blue;
};
@

\subsection{[[Memcmap]]}

<<[[MemImage]] other fields>>=
Memcmap	*cmap;
@

<<struct Memcmap>>=
struct Memcmap
{
    // map<colorcmap8, (reg8, green8, blue8)>
    byte	cmap2rgb[3*256];
    // map<(red4,green4,blue4), colorcmap8)
    byte	rgb2cmap[16*16*16];
};
@
% 3*256 so extract rgb from color of cmap.
% use 4 bytes only of r,g, or b  so 16 red variant x 16 green x 16 blue.


<<global memdefcmap>>=
Memcmap *memdefcmap = &def;
@
% def is big array in libmemdraw/cmap.c
% used in allocmemimaged


%dead? bcm does something different?
<<[[memimageinit()]] initializations>>=
_memmkcmap();
@
<<function _memmkcmap>>=
void _memmkcmap(void){}
@

\subsection{Conversions}

<<[[imgtorgba()]] other locals>>=
byte *p;
int ov;
@

<<[[imgtorgba()]] switch chan type cases>>=
case CMap:
    p = img->cmap->cmap2rgb + 3*ov;
    r = *p++;
    g = *p++;	
    b = *p;
    break;
@
% but only CMap is CMAP8 so ov should be equal to v.
% more on this later

<<[[rgbatoimg()]] other locals>>=
byte *p;
byte m;
@

<<[[rgbatoimg()]] switch chan type cases>>=
case CMap:
    p = img->cmap->rgb2cmap;
    m = p[(r>>4)*256+(g>>4)*16+(b>>4)];
    v |= (m>>(8-nb))<<d;
    break;
@
% >>




% seems dead now that use memdefcmap or maybe was used to generate
%  memdefcmap

% there is an optimized but less appealing version in comment below

%dead?
<<function rgb2cmap>>=
int
rgb2cmap(int cr, int cg, int cb)
{
    int i, r, g, b, sq;
    ulong rgb;
    int best, bestsq;

    best = 0;
    bestsq = 0x7FFFFFFF;
    // find best candidate
    for(i=0; i<256; i++){
        rgb = cmap2rgb(i);
        r = (rgb>>16) & 0xFF;
        g = (rgb>>8) & 0xFF;
        b = (rgb>>0) & 0xFF;
        sq = (r-cr)*(r-cr)+(g-cg)*(g-cg)+(b-cb)*(b-cb);
        if(sq < bestsq){
            bestsq = sq;
            best = i;
        }
    }
    return best;
}
@

%dead?
<<function cmap2rgb>>=
int
cmap2rgb(int c)
{
    int j, num, den, r, g, b, v, rgb;

    r = c>>6;
    v = (c>>4)&3;
    j = (c-v+r)&15;
    g = j>>2;
    b = j&3;
    den=r;
    if(g>den)
        den=g;
    if(b>den)
        den=b;
    if(den==0) {
        v *= 17;
        rgb = (v<<16)|(v<<8)|v;
    }
    else{
        num=17*(4*den+v);
        rgb = ((r*num/den)<<16)|((g*num/den)<<8)|(b*num/den);
    }
    return rgb;
}
@
% >> >> >> >>


%dead?
<<function cmap2rgba>>=
int
cmap2rgba(int c)
{
    return (cmap2rgb(c)<<8)|0xFF;
}
@
% >> 








<<[[readfn()]] if cmap>>=
if(img->nbits[CMap] == 8)
    return readcmap;
@

<<[[writefn()]] if cmap>>=
if(img->chan == CMAP8)
    return writecmap;
@
% why different test than readfn??

<<function readcmap>>=
static Buffer
readcmap(Param *p, uchar *buf, int y)
{
    Buffer b;
    int a, convgrey, copyalpha, dx, i, m;
    uchar *q, *cmap, *begin, *end, *r, *w;

    begin = p->bytey0s + y*p->bwidth;
    r = p->bytermin + y*p->bwidth;
    end = p->bytey0e + y*p->bwidth;

    cmap = p->img->cmap->cmap2rgb;
    convgrey = p->convgrey;
    copyalpha = (p->img->flags&Falpha) ? 1 : 0;

    w = buf;
    dx = p->dx;
    if(copyalpha){
        b.alpha = buf++;
        a = p->img->shift[CAlpha]/8;
        m = p->img->shift[CMap]/8;
        for(i=0; i<dx; i++){
            *w++ = r[a];
            q = cmap+r[m]*3;
            r += 2;
            if(r == end)
                r = begin;
            if(convgrey){
                *w++ = RGB2K(q[0], q[1], q[2]);
            }else{
                *w++ = q[2];	/* blue */
                *w++ = q[1];	/* green */
                *w++ = q[0];	/* red */
            }
        }
    }else{
        b.alpha = &ones;
        for(i=0; i<dx; i++){
            q = cmap+*r++*3;
            if(r == end)
                r = begin;
            if(convgrey){
                *w++ = RGB2K(q[0], q[1], q[2]);
            }else{
                *w++ = q[2];	/* blue */
                *w++ = q[1];	/* green */
                *w++ = q[0];	/* red */
            }
        }
    }

    b.rgba = (ulong*)(buf-copyalpha);

    if(convgrey){
        b.grey = buf;
        b.red = b.blu = b.grn = buf;
        b.delta = 1+copyalpha;
    }else{
        b.blu = buf;
        b.grn = buf+1;
        b.red = buf+2;
        b.grey = nil;
        b.delta = 3+copyalpha;
    }
    return b;
}
@


<<function writecmap>>=
static void
writecmap(Param *p, uchar *w, Buffer src)
{
    uchar *cmap, *red, *grn, *blu;
    int i, dx, delta;

    cmap = p->img->cmap->rgb2cmap;
    
    delta = src.delta;
    red = src.red;
    grn = src.grn;
    blu = src.blu;

    dx = p->dx;
    for(i=0; i<dx; i++, red+=delta, grn+=delta, blu+=delta)
        *w++ = cmap[(*red>>4)*256+(*grn>>4)*16+(*blu>>4)];
}
@
% shift right 4 so remains 4 bytes, 16 possible values


\subsection{API}

<<function readcolmap>>=
void
readcolmap(Display *d, RGB *colmap)
{
    int i;
    char *p, *q;
    Biobuf *b;
    char buf[128];

    sprint(buf, "/dev/draw/%d/colormap", d->dirno);
    b = Bopen(buf, OREAD);
    if(b == 0)
        drawerror(d, "rdcolmap: can't open colormap device");

    for(;;) {
        p = Brdline(b, '\n');
        if(p == 0)
            break;
        i = strtoul(p, &q, 0);
        if(i < 0 || i > 255) {
            fprint(2, "rdcolmap: bad index\n");
            exits("bad");
        }
        p = q;
        colmap[255-i].red = getval(&p);
        colmap[255-i].green = getval(&p);
        colmap[255-i].blue = getval(&p);
    }
    Bterm(b);
}
@
%old:    //USED(screen);

<<function getval>>=
static ulong
getval(char **p)
{
    ulong v;
    char *q;

    v = strtoul(*p, &q, 0);
    v |= v<<8;
    v |= v<<16;
    *p = q;
    return v;
}
@
% >> >>



<<function writecolmap>>=
/*
 * This code (and the devdraw interface) will have to change
 * if we ever get bitmaps with ldepth > 3, because the
 * colormap will have to be written in chunks
 */

void
writecolmap(Display *d, RGB *m)
{
    int i, n, fd;
    char buf[64], *t;
    ulong r, g, b;

    sprint(buf, "/dev/draw/%d/colormap", d->dirno);
    fd = open(buf, OWRITE);
    if(fd < 0)
        drawerror(d, "writecolmap: open colormap failed");
    t = malloc(8192);
    if (t == nil)
        drawerror(d, "writecolmap: no memory");
    n = 0;
    for(i = 0; i < 256; i++) {
        r = m[i].red>>24;
        g = m[i].green>>24;
        b = m[i].blue>>24;
        n += sprint(t+n, "%d %lud %lud %lud\n", 255-i, r, g, b);
    }
    i = write(fd, t, n);
    free(t);
    close(fd);
    if(i != n)
        drawerror(d, "writecolmap: bad write");
}
@




\subsection{[[/dev/draw/x/colormap]]}

<<[[drawread()]] other locals>>=
uchar *p;
int index, m;
ulong red, green, blue;
ulong offset = off;
@

<<[[drawread()]] switch qid cases>>=
case Qcolormap:
    drawactive(true);  /* to restore map from backup */
    p = malloc(4*12*256+1);
    if(p == nil)
        error(Enomem);
    m = 0;
    for(index = 0; index < 256; index++){
        getcolor(index, &red, &green, &blue);
        m += snprint((char*)p+m, 4*12*256+1 - m,
            "%11d %11lud %11lud %11lud\n", index,
            red>>24, green>>24, blue>>24);
    }
    n = readstr(offset, a, n, (char*)p);
    free(p);
    break;
@



<<[[drawwrite()]] other locals>>=
char buf[128], *fields[4], *q;
int i, m, red, green, blue, x;
@


<<[[drawwrite()]] switch qid cases>>=
case Qcolormap:
    drawactive(true);  /* to restore map from backup */
    m = n;
    n = 0;
    while(m > 0){
        x = m;
        if(x > sizeof(buf)-1)
            x = sizeof(buf)-1;
        q = memccpy(buf, a, '\n', x);
        if(q == 0)
            break;
        i = q-buf;
        n += i;
        a = (char*)a + i;
        m -= i;
        *q = 0;
        if(tokenize(buf, fields, nelem(fields)) != 4)
            error(Ebadarg);
        i = strtoul(fields[0], 0, 0);
        red = strtoul(fields[1], 0, 0);
        green = strtoul(fields[2], 0, 0);
        blue = strtoul(fields[3], &q, 0);
        if(fields[3] == q)
            error(Ebadarg);
        if(red>255 || green>255 || blue>255 || i<0 || i>255)
            error(Ebadarg);
        red |= red<<8;
        red |= red<<16;
        green |= green<<8;
        green |= green<<16;
        blue |= blue<<8;
        blue |= blue<<16;
        setcolor(i, red, green, blue);
    }
    break;
@
% >> >> >> >> >> >> >>


\subsection{Hardware support hook}

% drawread | blankscreen -> <>, part of screen.h interface now
<<function getcolor(x86)>>=
void
getcolor(ulong p, ulong* pr, ulong* pg, ulong* pb)
{
    VGAscr *scr;
    ulong x;

    scr = &vgascreen;
    if(gscreen == nil)
        return;

    switch(gscreen->depth){
    default:
        x = 0x0F;
        break;
    <<[[getcolor()]] switch depth cases>>
    }
    p &= x;

    lock(&cursor);
    *pr = scr->colormap[p][0];
    *pg = scr->colormap[p][1];
    *pb = scr->colormap[p][2];
    unlock(&cursor);
}
@


\subsubsection{[[drawcmap()]] and [[setcolor()]]}

<<[[screensize()]] initializations part2>>=
drawcmap();
@

<<function drawcmap>>=
/*
 * On 8 bit displays, load the default color map
 */
void
drawcmap(void)
{
    int r, g, b;
    int cr, cg, cb, v;
    int num, den;
    int i, j;

    drawactive(true);  /* to restore map from backup */
    for(r=0,i=0; r!=4; r++)
        for(v=0; v!=4; v++,i+=16){
        for(g=0,j=v-r; g!=4; g++)
            for(b=0;b!=4;b++,j++){
            den = r;
            if(g > den)
                den = g;
            if(b > den)
                den = b;
            if(den == 0)    /* divide check -- pick grey shades */
                cr = cg = cb = v*17;
            else{
                num = 17*(4*den+v);
                cr = r*num/den;
                cg = g*num/den;
                cb = b*num/den;
            }
            setcolor(i+(j&15),
                cr*0x01010101, cg*0x01010101, cb*0x01010101);
            }
    }
}
@



% drawread | blankscreen -> <>, part of screen.h interface now
<<function setcolor(x86)>>=
/*
 * On some video cards (e.g. Mach64), the palette is used as the 
 * DAC registers for >8-bit modes.  We don't want to set them when the user
 * is trying to set a colormap and the card is in one of these modes.
 */
int
setcolor(ulong p, ulong r, ulong g, ulong b)
{
    VGAscr *scr;
    int x;

    scr = &vgascreen;
    if(gscreen == nil)
        return 0;

    switch(gscreen->depth){
    <<[[setcolor()]] switch depth cases>>
    default:
        return 0;
    }
    p &= x;

    return setpalette(p, r, g, b);
}
@

\subsubsection{[[setpalette()]]}


<<[[screensize()]] vga settings>>=
scr->palettedepth = 6;  /* default */
@

% setcolor -> <>
<<function setpalette(x86)>>=
int
setpalette(ulong p, ulong r, ulong g, ulong b)
{
    VGAscr *scr;
    int d;

    scr = &vgascreen;
    d = scr->palettedepth;

    lock(&cursor);
    scr->colormap[p][0] = r;
    scr->colormap[p][1] = g;
    scr->colormap[p][2] = b;
    vgao(PaddrW, p);
    vgao(Pdata, r>>(32-d));
    vgao(Pdata, g>>(32-d));
    vgao(Pdata, b>>(32-d));
    unlock(&cursor);

    return ~0;
}
@





\chapter{Advanced Topics TODO}
%\section{Image naming?} Better before.
%\section{Image compression?}
%\section{JPG}
% libimg/

\section{Advanced shapes}

\subsection{Special line ends}

\subsubsection{Disc}

<<[[_memimageline()]] switch end0 cases, fallthrough to Endsquare>>=
case Enddisc:
    discend(p0, radius, dst, src, d, op);
    /* fall through */
@
<<[[_memimageline()]] switch end1 cases, fallthrough to Endsquare>>=
case Enddisc:
    discend(p1, radius, dst, src, d, op);
    /* fall through */
@

<<function discend>>=
static
void
discend(Point p, int radius, Memimage *dst, Memimage *src, Point dsrc, int op)
{
    Memimage *disc;
    Rectangle r;

    disc = membrush(radius);
    if(disc != nil){
        r.min.x = p.x - radius;
        r.min.y = p.y - radius;
        r.max.x = p.x + radius+1;
        r.max.y = p.y + radius+1;
        memdraw(dst, r, src, addpt(r.min, dsrc), disc, Pt(0,0), op);
    }
}
@

<<function membrush>>=
static Memimage*
membrush(int radius)
{
    static Memimage *brush;
    static int brushradius;

    if(brush == nil || brushradius != radius){
        freememimage(brush);
        brush = allocmemimage(Rect(0, 0, 2*radius+1, 2*radius+1), memopaque->chan);
        if(brush != nil){
            memfillcolor(brush, DTransparent);	/* zeros */
            memellipse(brush, Pt(radius, radius), radius, radius, -1, memopaque, Pt(radius, radius), S);
        }
        brushradius = radius;
    }

    return brush;
}
@

% so memline -> ... ->  memellipse ( -> memdraw)

\subsubsection{Arrows}

\paragraph{[[ARROW()]]}

<<function ARROW>>=
#define	ARROW(a, b, c)	(Endarrow|((a)<<5)|((b)<<14)|((c)<<23))
@
% see draw(2) for explanations and arrowend() below
%  x1 = (end>>5) & 0x1FF;	/* distance along line from end of line to tip */
%  x2 = (end>>14) & 0x1FF;	/* distance along line from barb to tip */
%  x3 = (end>>23) & 0x1FF;	/* distance perpendicular from edge of line to b
% >> >> >> >> >>

% advanced topics?
<<enum _anon_ (lib_graphics/libmemdraw/line.c)>>=
enum
{
    Arrow1 = 8,
    Arrow2 = 10,
    Arrow3 = 3,
};
@

\paragraph{[[_memimageline()]] and arrows}

<<[[_memimageline()]] switch end0 cases>>=
case Endarrow:
    arrowend(q, pp, end0, -sin, -cos, radius);
    _memfillpolysc(dst, pts, 5, ~0, src, 
                   addpt(pts[0], mulpt(d, ICOSSCALE)), 
                   true, 10, true, op);
    pp[1] = pp[4];
    pp += 2;
    break;
@
% detail parameter on!

<<[[_memimageline()]] switch end1 cases>>=
case Endarrow:
    arrowend(q, pp, end1, sin, cos, radius);
    _memfillpolysc(dst, pp, 5, ~0, src, 
                   addpt(pp[0], mulpt(d, ICOSSCALE)), 
                   true, 10, true, op);
    pp[1] = pp[4];
    pp += 2;
    break;
@

% detail on


<<function arrowend>>=
static
void
arrowend(Point tip, Point *pp, int end, int sin, int cos, int radius)
{
    int x1, x2, x3;

    /* before rotation */
    if(end == Endarrow){
        x1 = Arrow1;
        x2 = Arrow2;
        x3 = Arrow3;
    }else{
        x1 = (end>>5) & 0x1FF;	/* distance along line from end of line to tip */
        x2 = (end>>14) & 0x1FF;	/* distance along line from barb to tip */
        x3 = (end>>23) & 0x1FF;	/* distance perpendicular from edge of line to barb */
    }

    /* comments follow track of right-facing arrowhead */
    pp->x = tip.x+((2*radius+1)*sin/2-x1*cos);		/* upper side of shaft */
    pp->y = tip.y-((2*radius+1)*cos/2+x1*sin);
    pp++;
    pp->x = tip.x+((2*radius+2*x3+1)*sin/2-x2*cos);		/* upper barb */
    pp->y = tip.y-((2*radius+2*x3+1)*cos/2+x2*sin);
    pp++;
    pp->x = tip.x;
    pp->y = tip.y;
    pp++;
    pp->x = tip.x+(-(2*radius+2*x3+1)*sin/2-x2*cos);	/* lower barb */
    pp->y = tip.y-(-(2*radius+2*x3+1)*cos/2+x2*sin);
    pp++;
    pp->x = tip.x+(-(2*radius+1)*sin/2-x1*cos);		/* lower side of shaft */
    pp->y = tip.y+((2*radius+1)*cos/2-x1*sin);
}
@

\paragraph{detail and [[yscan()]]}

<<[[xscan()]] if detail>>=
if(ix == ix2 && detail) {
    if(xerr*p[0]->den + p[0]->zerr*xden > p[0]->den*xden)
        x++;
    ix = (x + x2) >> (fixshift+1);
    ix2 = ix+1;
}
@

<<[[_memfillpolysc()]] if detail>>=
if(detail)
    yscan(dst, seg, segtab, nvert, w, src, sp, fixshift, op);
@

<<function xcompare>>=
static int
xcompare(void *a, void *b)
{
    Seg **s0, **s1;
    long x0, x1;

    s0 = a;
    s1 = b;
    x0 = (*s0)->p0.x;
    x1 = (*s1)->p0.x;

    if(x0 < x1)
        return -1;
    if(x0 == x1)
        return 0;
    return 1;
}
@


<<function yscan>>=
static void
yscan(Memimage *dst, Seg **seg, Seg *segtab, int nseg, int wind, Memimage *src, Point sp, int fixshift, int op)
{
    long x, maxx, y, y2, yerr, yden, onehalf;
    Seg **ep, **next, **p, **q, *s;
    int n, i, ix, cnt, iy, iy2, miny, maxy;
    Point pt;

    for(i=0, s=segtab, p=seg; i<nseg; i++, s++) {
        *p = s;
        if(s->p0.x == s->p1.x)
            continue;
        if(s->p0.x > s->p1.x) {
            pt = s->p0;
            s->p0 = s->p1;
            s->p1 = pt;
            s->d = -s->d;
        }
        s->num = s->p1.y - s->p0.y;
        s->den = s->p1.x - s->p0.x;
        s->dz = sdiv(s->num, s->den) << fixshift;
        s->dzrem = mod(s->num, s->den) << fixshift;
        s->dz += sdiv(s->dzrem, s->den);
        s->dzrem = mod(s->dzrem, s->den);
        p++;
    }
    n = p-seg;
    if(n == 0)
        return;
    *p = 0;
    qsort(seg, n , sizeof(Seg*), xcompare);

    onehalf = 0;
    if(fixshift)
        onehalf = 1 << (fixshift-1);

    miny = dst->clipr.min.y;
    maxy = dst->clipr.max.y;

    x = seg[0]->p0.x;
    if(x < (dst->clipr.min.x << fixshift))
        x = dst->clipr.min.x << fixshift;
    ix = (x + onehalf) >> fixshift;
    x = (ix << fixshift) + onehalf;
    maxx = dst->clipr.max.x << fixshift;

    ep = next = seg;

    while(x<maxx) {
        for(q = p = seg; p < ep; p++) {
            s = *p;
            if(s->p1.x < x)
                continue;
            s->z += s->dz;
            s->zerr += s->dzrem;
            if(s->zerr >= s->den) {
                s->z++;
                s->zerr -= s->den;
                if(s->zerr < 0 || s->zerr >= s->den)
                    print("bad ratzerr1: %ld den %ld ratdzrem %ld\n", s->zerr, s->den, s->dzrem);
            }
            *q++ = s;
        }

        for(p = next; *p; p++) {
            s = *p;
            if(s->p0.x >= x)
                break;
            if(s->p1.x < x)
                continue;
            s->z = s->p0.y;
            s->z += smuldivmod(x - s->p0.x, s->num, s->den, &s->zerr);
            if(s->zerr < 0 || s->zerr >= s->den)
                print("bad ratzerr2: %ld den %ld ratdzrem %ld\n", s->zerr, s->den, s->dzrem);
            *q++ = s;
        }
        ep = q;
        next = p;

        if(ep == seg) {
            if(*next == 0)
                break;
            ix = (next[0]->p0.x + onehalf) >> fixshift;
            x = (ix << fixshift) + onehalf;
            continue;
        }

        zsort(seg, ep);

        for(p = seg; p < ep; p++) {
            cnt = 0;
            y = p[0]->z;
            yerr = p[0]->zerr;
            yden = p[0]->den;
            iy = (y + onehalf) >> fixshift;
            if(iy >= maxy)
                break;
            if(iy < miny)
                iy = miny;
            cnt += p[0]->d;
            p++;
            for(;;) {
                if(p == ep) {
                    print("yscan: fill to infinity");
                    return;
                }
                cnt += p[0]->d;
                if((cnt&wind) == 0)
                    break;
                p++;
            }
            y2 = p[0]->z;
            iy2 = (y2 + onehalf) >> fixshift;
            if(iy2 <= miny)
                continue;
            if(iy2 > maxy)
                iy2 = maxy;
            if(iy == iy2) {
                if(yerr*p[0]->den + p[0]->zerr*yden > p[0]->den*yden)
                    y++;
                iy = (y + y2) >> (fixshift+1);
                fillpoint(dst, ix, iy, src, sp, op);
            }
        }
        x += (1<<fixshift);
        ix++;
    }
}
@
% >> >> >> >>

<<function fillpoint>>=
static void
fillpoint(Memimage *dst, int x, int y, Memimage *src, Point p, int op)
{
    Rectangle r;

    r.min.x = x;
    r.min.y = y;
    r.max.x = x+1;
    r.max.y = y+1;
    p.x += x;
    p.y += y;
    memdraw(dst, r, src, p, memopaque, p, op);
}
@



\subsection{Bezier curves}
% spline

% no special message, it just uses the previous building blocks.

\subsubsection{[[Plist]]}

<<constant PINC>>=
#define	PINC	32		/* realloc granularity */
@

<<struct Plist>>=
struct Plist
{
    Point *p;
    int np;			/* -1 if malloc/realloc failed */
};
@

<<function appendpt>>=
static void
appendpt(Plist *l, Point p)
{
    if(l->np == -1)
        return;

    if(l->np == 0)
        l->p = malloc(PINC*sizeof(Point));
    else if(l->np % PINC == 0)
        l->p = realloc(l->p, (l->np+PINC)*sizeof(Point));

    if(l->p == nil){
        l->np = -1;
        return;
    }
    l->p[l->np++] = p;
}
@

\subsubsection{API}

<<function bezier>>=
error0
bezier(Image *dst, Point p0, Point p1, Point p2, Point p3, int end0, int end1, int radius, Image *src, Point sp)
{
    return bezierop(dst, p0, p1, p2, p3, end0, end1, radius, src, sp, SoverD);
}
@

<<function bezierop>>=
error0
bezierop(Image *dst, Point p0, Point p1, Point p2, Point p3, int end0, int end1, int radius, Image *src, Point sp, Drawop op)
{
    Plist l;

    l.np = 0;
    bezierpts(&l, p0, p1, p2, p3);
    if(l.np == -1)
        return ERROR_0;
    if(l.np != 0){
        polyop(dst, l.p, l.np, end0, end1, radius, src, addpt(subpt(sp, p0), l.p[0]), op);
        free(l.p);
    }
    return OK_1;
}
@
% so does not use arc? use polyop?

<<function bezspline>>=
error0
bezspline(Image *dst, Point *pt, int npt, int end0, int end1, int radius, Image *src, Point sp)
{
    return bezsplineop(dst, pt, npt, end0, end1, radius, src, sp, SoverD);
}
@

<<function bezsplineop>>=
error0
bezsplineop(Image *dst, Point *pt, int npt, int end0, int end1, int radius, Image *src, Point sp, Drawop op)
{
    Plist l;

    l.np = 0;
    _bezsplinepts(&l, pt, npt);
    if(l.np==-1)
        return ERROR_0;
    if(l.np != 0){
        polyop(dst, l.p, l.np, end0, end1, radius, src, addpt(subpt(sp, pt[0]), l.p[0]), op);
        free(l.p);
    }
    return OK_1;
}
@

<<function fillbezier>>=
error0
fillbezier(Image *dst, Point p0, Point p1, Point p2, Point p3, int w, Image *src, Point sp)
{
    return fillbezierop(dst, p0, p1, p2, p3, w, src, sp, SoverD);
}
@

<<function fillbezierop>>=
error0
fillbezierop(Image *dst, Point p0, Point p1, Point p2, Point p3, int w, Image *src, Point sp, Drawop op)
{
    Plist l;

    l.np = 0;
    bezierpts(&l, p0, p1, p2, p3);
    if(l.np == -1)
        return ERROR_0;
    if(l.np != 0){
        fillpolyop(dst, l.p, l.np, w, src, addpt(subpt(sp, p0), l.p[0]), op);
        free(l.p);
    }
    return OK_1;
}
@


<<function fillbezspline>>=
error0
fillbezspline(Image *dst, Point *pt, int npt, int w, Image *src, Point sp)
{
    return fillbezsplineop(dst, pt, npt, w, src, sp, SoverD);
}
@

<<function fillbezsplineop>>=
error0
fillbezsplineop(Image *dst, Point *pt, int npt, int w, Image *src, Point sp, Drawop op)
{
    Plist l;

    l.np = 0;
    _bezsplinepts(&l, pt, npt);
    if(l.np == -1)
        return ERROR_0;
    if(l.np > 0){
        fillpolyop(dst, l.p, l.np, w, src, addpt(subpt(sp, pt[0]), l.p[0]), op);
        free(l.p);
    }
    return OK_1;
}
@


% part of API for people who want to inspect what is computed maybe
<<function bezsplinepts>>=
int
bezsplinepts(Point *pt, int npt, Point **pp)
{
    Plist l;
    l.np = 0;
    l.p = nil;
    _bezsplinepts(&l, pt, npt);
    *pp  = l.p;
    return l.np;
}
@


\subsubsection{Algorithm}

\paragraph{[[bezierpts()]]}
<<function bezierpts>>=
static void
bezierpts(Plist *l, Point p0, Point p1, Point p2, Point p3)
{
    bpts(l, p0, p1, p2, p3);
    appendpt(l, p3);
}
@

<<function bpts>>=
static void
bpts(Plist *l, Point p0, Point p1, Point p2, Point p3)
{
    bpts1(l, p0, p1, p2, p3, 1);
}
@

<<function bpts1>>=
/*
 * Convert cubic Bezier curve control points to polyline
 * vertices.  Leaves the last vertex off, so you can continue
 * with another curve.
 */
static void
bpts1(Plist *l, Point p0, Point p1, Point p2, Point p3, int scale)
{
    Point p01, p12, p23, p012, p123, p0123;
    Point tp0, tp1, tp2, tp3;
    tp0=divpt(p0, scale);
    tp1=divpt(p1, scale);
    tp2=divpt(p2, scale);
    tp3=divpt(p3, scale);
    if(psdist(tp1, tp0, tp3)<=1 && psdist(tp2, tp0, tp3)<=1){
        appendpt(l, tp0);
        appendpt(l, tp1);
        appendpt(l, tp2);
    }
    else{
        /*
         * if scale factor is getting too big for comfort,
         * rescale now & concede the rounding error
         */
        if(scale>(1<<12)){
            p0=tp0;
            p1=tp1;
            p2=tp2;
            p3=tp3;
            scale=1;
        }
        p01=addpt(p0, p1);
        p12=addpt(p1, p2);
        p23=addpt(p2, p3);
        p012=addpt(p01, p12);
        p123=addpt(p12, p23);
        p0123=addpt(p012, p123);
        bpts1(l, mulpt(p0, 8), mulpt(p01, 4), mulpt(p012, 2), p0123, scale*8);
        bpts1(l, p0123, mulpt(p123, 2), mulpt(p23, 4), mulpt(p3, 8), scale*8);
    }
}
@
% >> >> >> >> >> >>

<<function normsq>>=
static int
normsq(Point p)
{
    return p.x*p.x+p.y*p.y;
}
@

<<function psdist>>=
static int
psdist(Point p, Point a, Point b)
{
    int num, den;

    p = subpt(p, a);
    b = subpt(b, a);
    num = p.x*b.x + p.y*b.y;
    if(num <= 0)
        return normsq(p);
    den = normsq(b);
    if(num >= den)
        return normsq(subpt(b, p));
    return normsq(subpt(divpt(mulpt(b, num), den), p));
}
@


\paragraph{[[_bezsplinepts()]]}


<<function _bezsplinepts>>=
static void
_bezsplinepts(Plist *l, Point *pt, int npt)
{
    Point *p, *ep;
    Point a, b, c, d;
    int periodic;

    if(npt<3)
        return;
    ep = &pt[npt-3];
    periodic = eqpt(pt[0], ep[2]);
    if(periodic){
        a = divpt(addpt(ep[1], pt[0]), 2);
        b = divpt(addpt(ep[1], mulpt(pt[0], 5)), 6);
        c = divpt(addpt(mulpt(pt[0], 5), pt[1]), 6);
        d = divpt(addpt(pt[0], pt[1]), 2);
        bpts(l, a, b, c, d);
    }
    for(p=pt; p<=ep; p++){
        if(p==pt && !periodic){
            a = p[0];
            b = divpt(addpt(p[0], mulpt(p[1], 2)), 3);
        }
        else{
            a = divpt(addpt(p[0], p[1]), 2);
            b = divpt(addpt(p[0], mulpt(p[1], 5)), 6);
        }
        if(p==ep && !periodic){
            c = divpt(addpt(mulpt(p[1], 2), p[2]), 3);
            d = p[2];
        }
        else{
            c = divpt(addpt(mulpt(p[1], 5), p[2]), 6);
            d = divpt(addpt(p[1], p[2]), 2);
        }
        bpts(l, a, b, c, d);
    }
    appendpt(l, d);
}
@





\section{Advanced compositing}

\subsection{Reading replicated pixels}
% tiling?

<<[[readbyte]] other locals>>=
int i;
byte *rrepl, *grepl, *brepl, *arepl, *krepl;
byte ured, ugrn, ublu;
ulong u;
@

<<[[readbyte()]] more complex cases, possible repl, grey, and small depth>>=
DBG1("2\n");
rrepl = replbit[img->nbits[CRed]];
grepl = replbit[img->nbits[CGreen]];
brepl = replbit[img->nbits[CBlue]];
arepl = replbit[img->nbits[CAlpha]];

krepl = replbit[img->nbits[CGrey]];

for(i=0; i<dx; i++){
    u = r[0] | (r[1]<<8) | (r[2]<<16) | (r[3]<<24);
    if(copyalpha) {
        *w++ = arepl[(u>>img->shift[CAlpha]) & img->mask[CAlpha]];
        //DBG print("a %x\n", w[-1]);
    }

    if(isgrey)
        *w++ = krepl[(u >> img->shift[CGrey]) & img->mask[CGrey]];
    else if(!alphaonly){
        ured = rrepl[(u >> img->shift[CRed]) & img->mask[CRed]];
        ugrn = grepl[(u >> img->shift[CGreen]) & img->mask[CGreen]];
        ublu = brepl[(u >> img->shift[CBlue]) & img->mask[CBlue]];
        if(convgrey){
            DBG1("g %x %x %x\n", ured, ugrn, ublu);
            *w++ = RGB2K(ured, ugrn, ublu);
            DBG1("%x\n", w[-1]);
        }else{
            *w++ = brepl[(u >> img->shift[CBlue]) & img->mask[CBlue]];
            *w++ = grepl[(u >> img->shift[CGreen]) & img->mask[CGreen]];
            *w++ = rrepl[(u >> img->shift[CRed]) & img->mask[CRed]];
        }
    }
    r += nb;
    if(r == end)
        r = begin;
}

b.alpha = copyalpha ? buf : &ones;
b.rgba = (ulong*)buf;
if(alphaonly){
    b.red = b.grn = b.blu = b.grey = nil;
    if(!copyalpha)
        b.rgba = nil;
    b.delta = 1;
}else if(isgrey || convgrey){
    b.grey = buf+copyalpha;
    b.red = b.grn = b.blu = buf+copyalpha;
    b.delta = copyalpha+1;
    DBG1("alpha %x grey %x\n", b.alpha ? *b.alpha : 0xFF, *b.grey);
}else{
    b.blu = buf+copyalpha;
    b.grn = buf+copyalpha+1;
    b.grey = nil;
    b.red = buf+copyalpha+2;
    b.delta = copyalpha+3;
}
return b;
@



\subsubsection{[[mktables]]}

<<[[memimageinit()]] initializations>>=
mktables();
@

% later?
<<global replbit>>=
/*
 * Conversion tables.
 */
static uchar replbit[1+8][256];		/* replbit[x][y] is the replication of the x-bit quantity y to 8-bit depth */
@


% ?? -> screensize -> memimageinit -> <>
<<function mktables>>=
static void
mktables(void)
{
    int i, j, small;
    <<[[mktables()]] only once guard>>

    /* bit replication up to 8 bits */
    for(i=0; i<256; i++){
        for(j=0; j<=8; j++){	/* j <= 8 [sic] */
            small = i & ((1<<j)-1);
            replbit[j][i] = (small*replmul[j])>>8;
        }
    }

}
@
%dead: done in caller anyway
%    fmtinstall('R', Rfmt);
%    fmtinstall('P', Pfmt);
%dead:
%    int mask, sh, 
%    /* bit unpacking up to 8 bits, only powers of 2 */
%    for(i=0; i<256; i++){
%        for(j=0, sh=7, mask=1; j<8; j++, sh--)
%            conv18[i][j] = replbit[1][(i>>sh)&mask];
%
%        for(j=0, sh=6, mask=3; j<4; j++, sh-=2)
%            conv28[i][j] = replbit[2][(i>>sh)&mask];
%
%        for(j=0, sh=4, mask=15; j<2; j++, sh-=4)
%            conv48[i][j] = replbit[4][(i>>sh)&mask];
%    }
% <<global conv18>>=
% static uchar conv18[256][8];		/* conv18[x][y] is the yth pixel in the depth-1 pixel x */
% @
% 
% <<global conv28>>=
% static uchar conv28[256][4];		/* ... */
% @
% 
% <<global conv48>>=
% static uchar conv48[256][2];
% @


<<[[mktables()]] only once guard>>=
static bool	tablesbuilt = false;
if(tablesbuilt)
    return;
tablesbuilt = true;
@
% used to be a global, but can be a static, better.




\subsection{Other compositing operators}

% apparently http.golang.org/go-image-package says that when you
% have masks, you need less operators and just DoverS and S are useful
% so maybe all this code below is useless.

\subsubsection{[[Clear]]}
%    alphacalc0,		/* Clear */

<<function alphacalc0>>=
static Buffer
alphacalc0(Buffer bdst, Buffer b1, Buffer b2, int dx, int grey, int op)
{
    USED(grey);
    USED(op);
    USED(b1);
    USED(b2);

    memset(bdst.rgba, 0, dx * bdst.delta);
    return bdst;
}
@

\subsubsection{[[DoutS]]}
%    alphacalc14,		/* DoutS */

<<function alphacalc14>>=
static Buffer
alphacalc14(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, int grey, int op)
{
    Buffer obdst;
    int fd, sadelta;
    int i, sa, ma, q;
    ulong s, t;

    obdst = bdst;
    sadelta = bsrc.alpha == &ones ? 0 : bsrc.delta;
    q = bsrc.delta == 4 && bdst.delta == 4;

    for(i=0; i<dx; i++){
        sa = *bsrc.alpha;
        ma = *bmask.alpha;
        fd = MUL(sa, ma, t);
        if(op == DoutS)
            fd = 255-fd;

        if(grey){
            *bdst.grey = MUL(fd, *bdst.grey, t);
            bsrc.grey += bsrc.delta;
            bdst.grey += bdst.delta;
        }else{
            if(q){
                *bdst.rgba = MUL0123(fd, *bdst.rgba, s, t);
                bsrc.rgba++;
                bdst.rgba++;
                bsrc.alpha += sadelta;
                bmask.alpha += bmask.delta;
                continue;
            }
            *bdst.red = MUL(fd, *bdst.red, t);
            *bdst.grn = MUL(fd, *bdst.grn, t);
            *bdst.blu = MUL(fd, *bdst.blu, t);
            bsrc.red += bsrc.delta;
            bsrc.blu += bsrc.delta;
            bsrc.grn += bsrc.delta;
            bdst.red += bdst.delta;
            bdst.blu += bdst.delta;
            bdst.grn += bdst.delta;
        }
        if(bdst.alpha != &ones){
            *bdst.alpha = MUL(fd, *bdst.alpha, t);
            bdst.alpha += bdst.delta;
        }
        bmask.alpha += bmask.delta;
        bsrc.alpha += sadelta;
    }
    return obdst;
}
@





\subsubsection{[[SoutD]]}
%    alphacalc2810,		/* SoutD */

<<function alphacalc2810>>=
static Buffer
alphacalc2810(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, int grey, int op)
{
    Buffer obdst;
    int fs, sadelta;
    int i, ma, da, q;
    ulong s, t;

    obdst = bdst;
    sadelta = bsrc.alpha == &ones ? 0 : bsrc.delta;
    q = bsrc.delta == 4 && bdst.delta == 4;

    for(i=0; i<dx; i++){
        ma = *bmask.alpha;
        da = *bdst.alpha;
        if(op == SoutD)
            da = 255-da;
        fs = ma;
        if(op != S)
            fs = MUL(fs, da, t);

        if(grey){
            *bdst.grey = MUL(fs, *bsrc.grey, t);
            bsrc.grey += bsrc.delta;
            bdst.grey += bdst.delta;
        }else{
            if(q){
                *bdst.rgba = MUL0123(fs, *bsrc.rgba, s, t);
                bsrc.rgba++;
                bdst.rgba++;
                bmask.alpha += bmask.delta;
                bdst.alpha += bdst.delta;
                continue;
            }
            *bdst.red = MUL(fs, *bsrc.red, t);
            *bdst.grn = MUL(fs, *bsrc.grn, t);
            *bdst.blu = MUL(fs, *bsrc.blu, t);
            bsrc.red += bsrc.delta;
            bsrc.blu += bsrc.delta;
            bsrc.grn += bsrc.delta;
            bdst.red += bdst.delta;
            bdst.blu += bdst.delta;
            bdst.grn += bdst.delta;
        }
        if(bdst.alpha != &ones){
            *bdst.alpha = MUL(fs, *bsrc.alpha, t);
            bdst.alpha += bdst.delta;
        }
        bmask.alpha += bmask.delta;
        bsrc.alpha += sadelta;
    }
    return obdst;
}
@


\subsubsection{[[DxorS]]}
%    alphacalc3679,		/* DxorS */

<<function alphacalc3679>>=
static Buffer
alphacalc3679(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, bool grey, int op)
{
    Buffer obdst;
    int fs, fd, sadelta;
    int i, sa, ma, da, q;
    ulong s, t, u, v;

    obdst = bdst;
    sadelta = (bsrc.alpha == &ones) ? 0 : bsrc.delta;
    q = (bsrc.delta == 4) && (bdst.delta == 4);

    for(i=0; i<dx; i++){
        sa = *bsrc.alpha;
        ma = *bmask.alpha;
        da = *bdst.alpha;
        if(op == SatopD)
            fs = MUL(ma, da, t);
        else
            fs = MUL(ma, 255-da, t);
        if(op == DoverS)
            fd = 255;
        else{
            fd = MUL(sa, ma, t);
            if(op != DatopS)
                fd = 255-fd;
        }

        if(grey){
            *bdst.grey = MUL(fs, *bsrc.grey, s) + MUL(fd, *bdst.grey, t);
            bsrc.grey += bsrc.delta;
            bdst.grey += bdst.delta;
        }else{
            if(q){
                *bdst.rgba = MUL0123(fs, *bsrc.rgba, s, t)+MUL0123(fd, *bdst.rgba, u, v);
                bsrc.rgba++;
                bdst.rgba++;
                bsrc.alpha += sadelta;
                bmask.alpha += bmask.delta;
                bdst.alpha += bdst.delta;
                continue;
            }
            *bdst.red = MUL(fs, *bsrc.red, s)+MUL(fd, *bdst.red, t);
            *bdst.grn = MUL(fs, *bsrc.grn, s)+MUL(fd, *bdst.grn, t);
            *bdst.blu = MUL(fs, *bsrc.blu, s)+MUL(fd, *bdst.blu, t);
            bsrc.red += bsrc.delta;
            bsrc.blu += bsrc.delta;
            bsrc.grn += bsrc.delta;
            bdst.red += bdst.delta;
            bdst.blu += bdst.delta;
            bdst.grn += bdst.delta;
        }
        if(bdst.alpha != &ones){
            *bdst.alpha = MUL(fs, sa, s)+MUL(fd, da, t);
            bdst.alpha += bdst.delta;
        }
        bmask.alpha += bmask.delta;
        bsrc.alpha += sadelta;
    }
    return obdst;
}
@

\subsubsection{[[DinS]]}
%    alphacalc14,		/* DinS */


\subsubsection{[[D]]}
%    alphacalc5,		/* D */

<<function alphacalc5>>=
static Buffer
alphacalc5(Buffer bdst, Buffer b1, Buffer b2, int dx, int grey, int op)
{
    USED(dx);
    USED(grey);
    USED(op);
    USED(b1);
    USED(b2);

    return bdst;
}
@


\subsubsection{[[DatopS]]}
%    alphacalc3679,		/* DatopS */


\subsubsection{[[DoverS]]}
%    alphacalc3679,		/* DoverS */


\subsubsection{[[SinD]]}
%    alphacalc2810,		/* SinD */


\subsubsection{[[SatopD]]}
%    alphacalc3679,		/* SatopD */


\subsubsection{[[S]]}
%    alphacalc2810,		/* S */


\subsubsection{[[SoverD]]}
%    alphacalc11,		/* SoverD */
% the classic! see section X






\section{Advanced mouse settings}

\subsection{Mouse and resize}

% a bit ugly but rio abuse /dev/mouse to indicate
% to client app that they have been resized
% by writing there a special message, r ...
%alt: could use a postnote?

<<[[Mousectl]] channel fields>>=
Channel	*resizec;	/* chan(int)[2] */
/* buffered in case client is waiting for a mouse action before handling resize */
@
% comment?
% 2?

<<[[initmouse()]] set channels>>=
mc->resizec = chancreate(sizeof(int), 2);
@


<<[[_ioproc()]] other locals (mouse.c)>>=
int one = 1;
@
<<[[_ioproc()]] switch buf, resize case, fallthrough m case (mouse.c)>>=
case 'r':
    send(mc->resizec, &one);
    /* fall through */
@



% in kernel

<<[[initscreenimage()]] other initializations>>=
mouseresize();
@
% wakeup processes waiting for resize event

\subsection{[[getrect.c]]}
% mv with cursor?

<<constant W (lib_graphics/libdraw/getrect.c)>>=
#define	W	Borderwidth
@

<<global tmp (lib_graphics/libdraw/getrect.c)>>=
static Image *tmp[4];
@

<<global red (lib_graphics/libdraw/getrect.c)>>=
static Image *red;
@

<<global sweep (lib_graphics/libdraw/getrect.c)>>=
static Cursor sweep={
    {-7, -7},
    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0x07,
     0xE0, 0x07, 0xE0, 0x07, 0xE3, 0xF7, 0xE3, 0xF7,
     0xE3, 0xE7, 0xE3, 0xF7, 0xE3, 0xFF, 0xE3, 0x7F,
     0xE0, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,},
    {0x00, 0x00, 0x7F, 0xFE, 0x40, 0x02, 0x40, 0x02,
     0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x41, 0xE2,
     0x41, 0xC2, 0x41, 0xE2, 0x41, 0x72, 0x40, 0x38,
     0x40, 0x1C, 0x40, 0x0E, 0x7F, 0xE6, 0x00, 0x00,}
};
@

<<function brects (lib_graphics/libdraw/getrect.c)>>=
static
void
brects(Rectangle r, Rectangle rp[4])
{
    if(Dx(r) < 2*W)
        r.max.x = r.min.x+2*W;
    if(Dy(r) < 2*W)
        r.max.y = r.min.y+2*W;
    rp[0] = Rect(r.min.x, r.min.y, r.max.x, r.min.y+W);
    rp[1] = Rect(r.min.x, r.max.y-W, r.max.x, r.max.y);
    rp[2] = Rect(r.min.x, r.min.y+W, r.min.x+W, r.max.y-W);
    rp[3] = Rect(r.max.x-W, r.min.y+W, r.max.x, r.max.y-W);
}
@

<<function getrect>>=
Rectangle
getrect(int but, Mousectl *mc)
{
    Rectangle r, rc;

    but = 1<<(but-1);
    setcursor(mc, &sweep);
    while(mc->buttons)
        readmouse(mc);
    while(!(mc->buttons & but)){
        readmouse(mc);
        if(mc->buttons & (7^but))
            goto Return;
    }
    r.min = mc->xy;
    r.max = mc->xy;
    do{
        rc = canonrect(r);
        drawgetrect(rc, 1);
        readmouse(mc);
        drawgetrect(rc, 0);
        r.max = mc->xy;
    }while(mc->buttons == but);

    Return:
    setcursor(mc, nil);
    if(mc->buttons & (7^but)){
        rc.min.x = rc.max.x = 0;
        rc.min.y = rc.max.y = 0;
        while(mc->buttons)
            readmouse(mc);
    }
    return rc;
}
@

<<function drawgetrect>>=
void
drawgetrect(Rectangle rc, int up)
{
    int i;
    Rectangle r, rects[4];

    /*
     * BUG: if for some reason we have two of these going on at once
     * when we must grow the tmp buffers, we lose data.  Also if tmp
     * is unallocated and we ask to restore the screen, it would be nice
     * to complain, but we silently make a mess.
     */
    if(up && tmp[0]!=nil)
        if(Dx(tmp[0]->r)<Dx(rc) || Dy(tmp[2]->r)<Dy(rc))
            freetmp();
    if(tmp[0] == 0){
        r = Rect(0, 0, max(Dx(display->screenimage->r), Dx(rc)), W);
        tmp[0] = allocimage(display, r, view->chan, false, -1);
        tmp[1] = allocimage(display, r, view->chan, false, -1);
        r = Rect(0, 0, W, max(Dy(display->screenimage->r), Dy(rc)));
        tmp[2] = allocimage(display, r, view->chan, false, -1);
        tmp[3] = allocimage(display, r, view->chan, false, -1);
        red = allocimage(display, Rect(0,0,1,1), view->chan, true, DRed);
        if(tmp[0]==0 || tmp[1]==0 || tmp[2]==0 || tmp[3]==0 || red==0){
            freetmp();
            drawerror(display, "getrect: allocimage failed");
        }
    }
    brects(rc, rects);
    if(!up){
        for(i=0; i<4; i++)
            draw(view, rects[i], tmp[i], nil, ZP);
        return;
    }
    for(i=0; i<4; i++){
        draw(tmp[i], Rect(0, 0, Dx(rects[i]), Dy(rects[i])), view, nil, rects[i].min);
        draw(view, rects[i], red, nil, ZP);
    }
}
@

% drawgetrect -> <>
<<function freetmp (lib_graphics/libdraw/getrect.c)>>=
static
void
freetmp(void)
{
    freeimage(tmp[0]);
    freeimage(tmp[1]);
    freeimage(tmp[2]);
    freeimage(tmp[3]);
    freeimage(red);
    tmp[0] = tmp[1] = tmp[2] = tmp[3] = red = nil;
}
@

<<function max>>=
static
int
max(int a, int b)
{
    if(a > b)
        return a;
    return b;
}
@




\subsection{[[mousescrollsize()]]}
% advanced topic? who calls that?

<<function mousescrollsize>>=
int
mousescrollsize(int maxlines)
{
    static int lines, pcnt;
    char *mss;

    if(lines == 0 && pcnt == 0){
        mss = getenv("mousescrollsize");
        if(mss){
            if(strchr(mss, '%') != nil)
                pcnt = atof(mss);
            else
                lines = atoi(mss);
            free(mss);
        }
        if(lines == 0 && pcnt == 0)
            lines = 1;
        if(pcnt>=100)
            pcnt = 100;
    }

    if(lines)
        return lines;
    return pcnt * maxlines/100.0;	
}
@

\subsection{[[/dev/cursor]]}
\n not that important in the end

% code in devmouse.c? mostly to set new cursor picture?


<<[[Mousectl]] cursor field>>=
// /dev/cursor
fdt		cfd;		/* to cursor file */
@

<<[[initmouse()]] set cursor field>>=
<<[[initmouse()]] set t to /dev/cursor>>
mc->cfd = open(t, ORDWR|OCEXEC);
free(t);
@

<<[[initmouse()]] set t to /dev/cursor>>=
// t = "{basename(file)}/cursor"
t = malloc(strlen(file)+16);
<<[[initmouse()]] sanity check t>>
strcpy(t, file);
sl = utfrrune(t, '/');
if(sl)
    strcpy(sl, "/cursor");
else
    strcpy(t, "/dev/cursor");
@

<<[[initmouse()]] sanity check t>>=
if (t == nil) {
    close(mc->mfd);
    free(mc);
    return nil;
}
@






<<function setcursor>>=
void
setcursor(Mousectl *mc, Cursor *c)
{
    char curs[2*4 + 2*2*16]; // sizeof Cursor

    if(c == nil)
        write(mc->cfd, curs, 0);
    else{
        BPLONG(curs+0*4, c->offset.x);
        BPLONG(curs+1*4, c->offset.y);
        memmove(curs+2*4, c->clr, 2*2*16);
        write(mc->cfd, curs, sizeof curs);
    }
}
@
\l case when == nil?? what for?

%? devmouse.c code? for /dev/cursor?



\section{Menus}
% mv in advanced shapes?
% related to mouse too.
% should be in Widgets.nw maybe?
% Or make Widgets chapter? and say that just subset?
% At the same time kinda example of use of draw.h

% Nice example of use of drawing API?

% dupe in mouse.h
<<struct Menu>>=
struct Menu
{
    char	**item;
    char	*(*gen)(int);
    int	lasthit;
};
@

\ifallcode
<<struct Menu (include/mouse.h)>>=
struct Menu
{
    char	**item;
    char	*(*gen)(int);
    int	lasthit;
};
@
\fi

%\subsection{[[menuhits.c]]}

<<enum _anon_ (lib_graphics/libdraw/menuhit.c)>>=
enum
{
    Margin = 4,		/* outside to text */
    Border = 2,		/* outside to selection boxes */
    Blackborder = 2,	/* width of outlining border */
    Vspacing = 2,		/* extra spacing between lines of text */
    Maxunscroll = 25,	/* maximum #entries before scrolling turns on */
    Nscroll = 20,		/* number entries in scrolling part */
    Scrollwid = 14,		/* width of scroll bar */
    Gap = 4,			/* between text and scroll bar */
};
@

<<global menutxt (lib_graphics/libdraw/menuhit.c)>>=
static	Image	*menutxt;
@

<<global back (lib_graphics/libdraw/menuhit.c)>>=
static	Image	*back;
@

<<global high (lib_graphics/libdraw/menuhit.c)>>=
static	Image	*high;
@

<<global bord (lib_graphics/libdraw/menuhit.c)>>=
static	Image	*bord;
@

<<global text (lib_graphics/libdraw/menuhit.c)>>=
static	Image	*text;
@

<<global htext (lib_graphics/libdraw/menuhit.c)>>=
static	Image	*htext;
@

<<function menucolors (lib_graphics/libdraw/menuhit.c)>>=
static
void
menucolors(void)
{
    /* Main tone is greenish, with negative selection */
    back = allocimagemix(display, DPalegreen, DWhite);
    high = allocimage(display, Rect(0,0,1,1), view->chan, true, DDarkgreen);	/* dark green */
    bord = allocimage(display, Rect(0,0,1,1), view->chan, true, DMedgreen);	/* not as dark green */
    if(back == nil || high == nil || bord == nil)
        goto Error;
    text = display->black;
    htext = back;
    return;

    Error:
    freeimage(back);
    freeimage(high);
    freeimage(bord);
    back = display->white;
    high = display->black;
    bord = display->black;
    text = display->black;
    htext = display->white;
}
@

% menucolors -> <>
<<function allocimagemix>>=
Image*
allocimagemix(Display *d, ulong color1, ulong color3)
{
    Image *t, *b;
    static Image *qmask;

    if(qmask == nil)
        qmask = allocimage(d, Rect(0,0,1,1), GREY8, true, 0x3F3F3FFF);

    <<[[allocimagemix()]] if depth less than 8>>
    else{	/* use a solid color, blended using alpha */
        t = allocimage(d, Rect(0,0,1,1), d->screenimage->chan, true, color1);
        if(t == nil)
            return nil;

        b = allocimage(d, Rect(0,0,1,1), d->screenimage->chan, true, color3);
        if(b == nil){
            freeimage(t);
            return nil;
        }

        draw(b, b->r, t, qmask, ZP);
        freeimage(t);
        return b;
    }
}
@

<<function menurect (lib_graphics/libdraw/menuhit.c)>>=
/*
 * r is a rectangle holding the text elements.
 * return the rectangle, including its black edge, holding element i.
 */
static Rectangle
menurect(Rectangle r, int i)
{
    if(i < 0)
        return Rect(0, 0, 0, 0);
    r.min.y += (font->height+Vspacing)*i;
    r.max.y = r.min.y+font->height+Vspacing;
    return insetrect(r, Border-Margin);
}
@

<<function menusel (lib_graphics/libdraw/menuhit.c)>>=
/*
 * r is a rectangle holding the text elements.
 * return the element number containing p.
 */
static int
menusel(Rectangle r, Point p)
{
    r = insetrect(r, Margin);
    if(!ptinrect(p, r))
        return -1;
    return (p.y-r.min.y)/(font->height+Vspacing);
}
@

<<function paintitem (lib_graphics/libdraw/menuhit.c)>>=
static
void
paintitem(Image *m, Menu *menu, Rectangle textr, int off, int i, int highlight, Image *save, Image *restore)
{
    char *item;
    Rectangle r;
    Point pt;

    if(i < 0)
        return;
    r = menurect(textr, i);
    if(restore){
        draw(m, r, restore, nil, restore->r.min);
        return;
    }
    if(save)
        draw(save, save->r, m, nil, r.min);
    item = menu->item? menu->item[i+off] : (*menu->gen)(i+off);
    pt.x = (textr.min.x+textr.max.x-stringwidth(font, item))/2;
    pt.y = textr.min.y+i*(font->height+Vspacing);
    draw(m, r, highlight? high : back, nil, pt);
    string(m, pt, highlight? htext : text, pt, font, item);
}
@

<<function menuscan (lib_graphics/libdraw/menuhit.c)>>=
/*
 * menur is a rectangle holding all the highlightable text elements.
 * track mouse while inside the box, return what's selected when button
 * is raised, -1 as soon as it leaves box.
 * invariant: nothing is highlighted on entry or exit.
 */
static int
menuscan(Image *m, Menu *menu, int but, Mousectl *mc, Rectangle textr, int off, int lasti, Image *save)
{
    int i;

    paintitem(m, menu, textr, off, lasti, 1, save, nil);
    for(readmouse(mc); mc->buttons & (1<<(but-1)); readmouse(mc)){
        i = menusel(textr, mc->xy);
        if(i != -1 && i == lasti)
            continue;
        paintitem(m, menu, textr, off, lasti, 0, nil, save);
        if(i == -1)
            return i;
        lasti = i;
        paintitem(m, menu, textr, off, lasti, 1, save, nil);
    }
    return lasti;
}
@

<<function menupaint (lib_graphics/libdraw/menuhit.c)>>=
static void
menupaint(Image *m, Menu *menu, Rectangle textr, int off, int nitemdrawn)
{
    int i;

    draw(m, insetrect(textr, Border-Margin), back, nil, ZP);
    for(i = 0; i<nitemdrawn; i++)
        paintitem(m, menu, textr, off, i, 0, nil, nil);
}
@

<<function menuscrollpaint (lib_graphics/libdraw/menuhit.c)>>=
static void
menuscrollpaint(Image *m, Rectangle scrollr, int off, int nitem, int nitemdrawn)
{
    Rectangle r;

    draw(m, scrollr, back, nil, ZP);
    r.min.x = scrollr.min.x;
    r.max.x = scrollr.max.x;
    r.min.y = scrollr.min.y + (Dy(scrollr)*off)/nitem;
    r.max.y = scrollr.min.y + (Dy(scrollr)*(off+nitemdrawn))/nitem;
    if(r.max.y < r.min.y+2)
        r.max.y = r.min.y+2;
    border(m, r, 1, bord, ZP);
    if(menutxt == 0)
        menutxt = allocimage(display, Rect(0, 0, 1, 1), view->chan, true, DDarkgreen);	/* border color; BUG? */
    if(menutxt)
        draw(m, insetrect(r, 1), menutxt, nil, ZP);
}
@

<<function menuhit>>=
int
menuhit(int but, Mousectl *mc, Menu *menu, Screen *scr)
{
    int i, nitem, nitemdrawn, maxwid, lasti, off, noff, wid, screenitem;
    int scrolling;
    Rectangle r, menur, sc, textr, scrollr;
    Image *b, *save, *backup;
    Point pt;
    char *item;

    if(back == nil)
        menucolors();
    sc = view->clipr;
    replclipr(view, 0, view->r);
    maxwid = 0;
    for(nitem = 0;
        item = menu->item? menu->item[nitem] : (*menu->gen)(nitem);
        nitem++){
        i = stringwidth(font, item);
        if(i > maxwid)
            maxwid = i;
    }
    if(menu->lasthit<0 || menu->lasthit>=nitem)
        menu->lasthit = 0;
    screenitem = (Dy(view->r)-10)/(font->height+Vspacing);
    if(nitem>Maxunscroll || nitem>screenitem){
        scrolling = 1;
        nitemdrawn = Nscroll;
        if(nitemdrawn > screenitem)
            nitemdrawn = screenitem;
        wid = maxwid + Gap + Scrollwid;
        off = menu->lasthit - nitemdrawn/2;
        if(off < 0)
            off = 0;
        if(off > nitem-nitemdrawn)
            off = nitem-nitemdrawn;
        lasti = menu->lasthit-off;
    }else{
        scrolling = 0;
        nitemdrawn = nitem;
        wid = maxwid;
        off = 0;
        lasti = menu->lasthit;
    }
    r = insetrect(Rect(0, 0, wid, nitemdrawn*(font->height+Vspacing)), -Margin);
    r = rectsubpt(r, Pt(wid/2, lasti*(font->height+Vspacing)+font->height/2));
    r = rectaddpt(r, mc->xy);
    pt = ZP;
    if(r.max.x>view->r.max.x)
        pt.x = view->r.max.x-r.max.x;
    if(r.max.y>view->r.max.y)
        pt.y = view->r.max.y-r.max.y;
    if(r.min.x<view->r.min.x)
        pt.x = view->r.min.x-r.min.x;
    if(r.min.y<view->r.min.y)
        pt.y = view->r.min.y-r.min.y;
    menur = rectaddpt(r, pt);
    textr.max.x = menur.max.x-Margin;
    textr.min.x = textr.max.x-maxwid;
    textr.min.y = menur.min.y+Margin;
    textr.max.y = textr.min.y + nitemdrawn*(font->height+Vspacing);
    if(scrolling){
        scrollr = insetrect(menur, Border);
        scrollr.max.x = scrollr.min.x+Scrollwid;
    }else
        scrollr = Rect(0, 0, 0, 0);

    if(scr){
        b = allocwindow(scr, menur, Refbackup, DWhite);
        if(b == nil)
            b = view;
        backup = nil;
    }else{
        b = view;
        backup = allocimage(display, menur, view->chan, false, -1);
        if(backup)
            draw(backup, menur, view, nil, menur.min);
    }
    draw(b, menur, back, nil, ZP);
    border(b, menur, Blackborder, bord, ZP);
    save = allocimage(display, menurect(textr, 0), view->chan, false, -1);
    r = menurect(textr, lasti);
    moveto(mc, divpt(addpt(r.min, r.max), 2));
    menupaint(b, menu, textr, off, nitemdrawn);
    if(scrolling)
        menuscrollpaint(b, scrollr, off, nitem, nitemdrawn);
    while(mc->buttons & (1<<(but-1))){
        lasti = menuscan(b, menu, but, mc, textr, off, lasti, save);
        if(lasti >= 0)
            break;
        while(!ptinrect(mc->xy, textr) && (mc->buttons & (1<<(but-1)))){
            if(scrolling && ptinrect(mc->xy, scrollr)){
                noff = ((mc->xy.y-scrollr.min.y)*nitem)/Dy(scrollr);
                noff -= nitemdrawn/2;
                if(noff < 0)
                    noff = 0;
                if(noff > nitem-nitemdrawn)
                    noff = nitem-nitemdrawn;
                if(noff != off){
                    off = noff;
                    menupaint(b, menu, textr, off, nitemdrawn);
                    menuscrollpaint(b, scrollr, off, nitem, nitemdrawn);
                }
            }
            readmouse(mc);
        }
    }
    if(b != view)
        freeimage(b);
    if(backup){
        draw(view, menur, backup, nil, menur.min);
        freeimage(backup);
    }
    freeimage(save);
    replclipr(view, 0, sc);
    flushimage(display, true);
    if(lasti >= 0){
        menu->lasthit = lasti+off;
        return menu->lasthit;
    }
    return -1;
}
@



\section{Events}
% Should be in Widgets too?

%related: big-bang function in racket/htdp

% seen before /dev/mouse synchrony issue, and the introduction
% of ioproc and channel and alt(). 
% Events are alternative API.
%classic thread vs event slide?

% have lots of dupes, menuhit.c vs emenuhit.c?

%alt: X11 has XEvent structure

<<enum _anon_ (include/event.h)>>=
enum
{
    Emouse	= 1,
    Ekeyboard	= 2,
};
@

% dupe
<<struct Mouse>>=
struct	Mouse
{
    int		buttons;	/* bit array: LMR=124 */
    Point	xy;
    ulong	msec;
};
@

<<struct Event>>=
struct	Event
{
    int		kbdc;
    Mouse	mouse;

    int		n;		/* number of characters in message */
    void	*v;		/* data unpacked by general event-handling function */
    uchar	data[EMAXMSG];	/* message from an arbitrary file descriptor */
};
@


% event.c



<<enum _anon_ (include/event.h)2>>=
enum
{
    MAXSLAVE = 32,
    EMAXMSG = 128+8192,	/* size of 9p header+data */
};
@


<<struct Slave>>=
struct Slave
{
    int	pid;
    Ebuf	*head;		/* queue of messages for this descriptor */
    Ebuf	*tail;
    int	(*fn)(int, Event*, uchar*, int);
};
@

<<struct Ebuf>>=
struct Ebuf
{
    Ebuf	*next;
    int	n;		/* number of bytes in buf */
    uchar	buf[EMAXMSG];
};
@

<<global eslave>>=
static	Slave	eslave[MAXSLAVE];
@



<<global Skeyboard>>=
static	int	Skeyboard = -1;
@

<<global Smouse>>=
static	int	Smouse = -1;
@

<<global Stimer>>=
static	int	Stimer = -1;
@



<<global logfid>>=
static	int	logfid;
@

<<global nslave>>=
static	int	nslave;
@

<<global parentpid>>=
static	int	parentpid;
@

<<global epipe>>=
static	int	epipe[2];
@

<<global mousefd>>=
static	int	mousefd;
@

<<global cursorfd>>=
static	int	cursorfd;
@

<<function ebread>>=
static
Ebuf*
ebread(Slave *s)
{
    Ebuf *eb;
    Dir *d;
    ulong l;

    for(;;){
        d = dirfstat(epipe[0]);
        if(d == nil)
            drawerror(display, "events: eread stat error");
        l = d->length;
        free(d);
        if(s->head && l==0)
            break;
        extract();
    }
    eb = s->head;
    s->head = s->head->next;
    if(s->head == 0)
        s->tail = 0;
    return eb;
}
@

<<function event>>=
ulong
event(Event *e)
{
    return eread(~0UL, e);
}
@

<<function eread>>=
ulong
eread(ulong keys, Event *e)
{
    Ebuf *eb;
    int i, id;

    if(keys == 0)
        return 0;
    for(;;){
        for(i=0; i<nslave; i++)
            if((keys & (1<<i)) && eslave[i].head){
                id = 1<<i;
                if(i == Smouse)
                    e->mouse = emouse();
                else if(i == Skeyboard)
                    e->kbdc = ekbd();
                else if(i == Stimer)
                    eslave[i].head = 0;
                else{
                    eb = ebread(&eslave[i]);
                    e->n = eb->n;
                    if(eslave[i].fn)
                        id = (*eslave[i].fn)(id, e, eb->buf, eb->n);
                    else
                        memmove(e->data, eb->buf, eb->n);
                    free(eb);
                }
                return id;
            }
        extract();
    }
}
@
% >> >>

<<function ecanmouse>>=
int
ecanmouse(void)
{
    if(Smouse < 0)
        drawerror(display, "events: mouse not initialized");
    return ecanread(Emouse);
}
@

<<function ecankbd>>=
int
ecankbd(void)
{
    if(Skeyboard < 0)
        drawerror(display, "events: keyboard not initialzed");
    return ecanread(Ekeyboard);
}
@

<<function ecanread>>=
int
ecanread(ulong keys)
{
    Dir *d;
    int i;
    ulong l;

    for(;;){
        for(i=0; i<nslave; i++)
            if((keys & (1<<i)) && eslave[i].head)
                return 1;
        d = dirfstat(epipe[0]);
        if(d == nil)
            drawerror(display, "events: ecanread stat error");
        l = d->length;
        free(d);
        if(l == 0)
            return 0;
        extract();
    }
}
@
% >>

<<function estartfn>>=
ulong
estartfn(ulong key, int fd, int n, int (*fn)(int, Event*, uchar*, int))
{
    char buf[EMAXMSG+1];
    int i, r;

    if(fd < 0)
        drawerror(display, "events: bad file descriptor");
    if(n <= 0 || n > EMAXMSG)
        n = EMAXMSG;
    i = eforkslave(key);
    if(i < MAXSLAVE){
        eslave[i].fn = fn;
        return 1<<i;
    }
    buf[0] = i - MAXSLAVE;
    while((r = read(fd, buf+1, n))>0)
        if(write(epipe[1], buf, r+1)!=r+1)
            break;
    buf[0] = MAXSLAVE;
    write(epipe[1], buf, 1);
    _exits(0);
    return 0;
}
@
% >>

<<function estart>>=
ulong
estart(ulong key, int fd, int n)
{
    return estartfn(key, fd, n, nil);
}
@

<<function etimer>>=
ulong
etimer(ulong key, int n)
{
    char t[2];

    if(Stimer != -1)
        drawerror(display, "events: timer started twice");
    Stimer = eforkslave(key);
    if(Stimer < MAXSLAVE)
        return 1<<Stimer;
    if(n <= 0)
        n = 1000;
    t[0] = t[1] = Stimer - MAXSLAVE;
    do
        sleep(n);
    while(write(epipe[1], t, 2) == 2);
    t[0] = MAXSLAVE;
    write(epipe[1], t, 1);
    _exits(0);
    return 0;
}
@
% >> >> >> >> >>

<<function ekeyslave>>=
static void
ekeyslave(int fd)
{
    Rune r;
    char t[3], k[10];
    int kr, kn, w;

    if(eforkslave(Ekeyboard) < MAXSLAVE)
        return;
    kn = 0;
    t[0] = Skeyboard;
    for(;;){
        while(!fullrune(k, kn)){
            kr = read(fd, k+kn, sizeof k - kn);
            if(kr <= 0)
                goto breakout;
            kn += kr;
        }
        w = chartorune(&r, k);
        kn -= w;
        memmove(k, &k[w], kn);
        t[1] = r;
        t[2] = r>>8;
        if(write(epipe[1], t, 3) != 3)
            break;
    }
breakout:;
    t[0] = MAXSLAVE;
    write(epipe[1], t, 1);
    _exits(0);
}
@

<<function einit>>=
void
einit(ulong keys)
{
    int ctl, fd;
    char buf[256];

    parentpid = getpid();
    if(pipe(epipe) < 0)
        drawerror(display, "events: einit pipe");
    atexit(ekill);
    atnotify(enote, 1);
    snprint(buf, sizeof buf, "%s/mouse", display->devdir);
    mousefd = open(buf, ORDWR|OCEXEC);
    if(mousefd < 0)
        drawerror(display, "einit: can't open mouse\n");
    snprint(buf, sizeof buf, "%s/cursor", display->devdir);
    cursorfd = open(buf, ORDWR|OCEXEC);
    if(cursorfd < 0)
        drawerror(display, "einit: can't open cursor\n");
    if(keys&Ekeyboard){
        snprint(buf, sizeof buf, "%s/cons", display->devdir);
        fd = open(buf, OREAD);
        if(fd < 0)
            drawerror(display, "events: can't open console");
        snprint(buf, sizeof buf, "%s/consctl", display->devdir);
        ctl = open("/dev/consctl", OWRITE|OCEXEC);
        if(ctl < 0)
            drawerror(display, "events: can't open consctl");
        write(ctl, "rawon", 5);
        for(Skeyboard=0; Ekeyboard & ~(1<<Skeyboard); Skeyboard++)
            ;
        ekeyslave(fd);
    }
    if(keys&Emouse){
        estart(Emouse, mousefd, 1+4*12);
        for(Smouse=0; Emouse & ~(1<<Smouse); Smouse++)
            ;
    }
}
@
% >> >> >>


<<function extract>>=
static void
extract(void)
{
    Slave *s;
    Ebuf *eb;
    int i, n;
    uchar ebuf[EMAXMSG+1];

    /* avoid generating a message if there's nothing to show. */
    /* this test isn't perfect, though; could do flushimage(display, 0) then call extract */
    /* also: make sure we don't interfere if we're multiprocessing the display */
    if(display->locking){
        /* if locking is being done by program, this means it can't depend on automatic flush in emouse() etc. */
        if(canqlock(&display->qlock)){
            if(display->bufp > display->buf)
                flushimage(display, true);
            unlockdisplay(display);
        }
    }else
        if(display->bufp > display->buf)
            flushimage(display, true);
loop:
    if((n=read(epipe[0], ebuf, EMAXMSG+1)) < 0
    || ebuf[0] >= MAXSLAVE)
        drawerror(display, "eof on event pipe");
    if(n == 0)
        goto loop;
    i = ebuf[0];
    if(i >= nslave || n <= 1)
        drawerror(display, "events: protocol error: short read");
    s = &eslave[i];
    if(i == Stimer){
        s->head = (Ebuf *)1;
        return;
    }
    if(i == Skeyboard && n != 3)
        drawerror(display, "events: protocol error: keyboard");
    if(i == Smouse){
        if(n < 1+1+2*12)
            drawerror(display, "events: protocol error: mouse");
        if(ebuf[1] == 'r')
            eresized(1);
        /* squash extraneous mouse events */
        if((eb=s->tail) && memcmp(eb->buf+1+2*12, ebuf+1+1+2*12, 12)==0){
            memmove(eb->buf, &ebuf[1], n - 1);
            return;
        }
    }
    /* try to save space by only allocating as much buffer as we need */
    eb = malloc(sizeof(*eb) - sizeof(eb->buf) + n - 1);
    if(eb == 0)
        drawerror(display, "events: protocol error 4");
    eb->n = n - 1;
    memmove(eb->buf, &ebuf[1], n - 1);
    eb->next = 0;
    if(s->head)
        s->tail = s->tail->next = eb;
    else
        s->head = s->tail = eb;
}
@

<<function eforkslave>>=
static int
eforkslave(ulong key)
{
    int i, pid;

    for(i=0; i<MAXSLAVE; i++)
        if((key & ~(1<<i)) == 0 && eslave[i].pid == 0){
            if(nslave <= i)
                nslave = i + 1;
            /*
             * share the file descriptors so the last child
             * out closes all connections to the window server.
             */
            switch(pid = rfork(RFPROC)){
            case 0:
                return MAXSLAVE+i;
            case -1:
                fprint(2, "events: fork error\n");
                exits("fork");
            }
            eslave[i].pid = pid;
            eslave[i].head = eslave[i].tail = 0;
            return i;
        }
    drawerror(display, "events: bad slave assignment");
    return 0;
}
@
% >> >>

<<function enote>>=
static int
enote(void *v, char *s)
{
    char t[1];
    int i, pid;

    USED(v, s);
    pid = getpid();
    if(pid != parentpid){
        for(i=0; i<nslave; i++){
            if(pid == eslave[i].pid){
                t[0] = MAXSLAVE;
                write(epipe[1], t, 1);
                break;
            }
        }
        return 0;
    }
    close(epipe[0]);
    epipe[0] = -1;
    close(epipe[1]);
    epipe[1] = -1;
    for(i=0; i<nslave; i++){
        if(pid == eslave[i].pid)
            continue;	/* don't kill myself */
        postnote(PNPROC, eslave[i].pid, "die");
    }
    return 0;
}
@

<<function ekill>>=
static void
ekill(void)
{
    enote(0, 0);
}
@

<<function emouse>>=
Mouse
emouse(void)
{
    Mouse m;
    Ebuf *eb;
    static int but[2];
    int b;

    if(Smouse < 0)
        drawerror(display, "events: mouse not initialized");
    eb = ebread(&eslave[Smouse]);
    m.xy.x = atoi((char*)eb->buf+1+0*12);
    m.xy.y = atoi((char*)eb->buf+1+1*12);
    b = atoi((char*)eb->buf+1+2*12);
    m.buttons = b;
    m.msec = atoi((char*)eb->buf+1+3*12);
    if (logfid)
        fprint(logfid, "b: %d xy: %P\n", m.buttons, m.xy);
    free(eb);
    return m;
}
@

<<function ekbd>>=
int
ekbd(void)
{
    Ebuf *eb;
    int c;

    if(Skeyboard < 0)
        drawerror(display, "events: keyboard not initialzed");
    eb = ebread(&eslave[Skeyboard]);
    c = eb->buf[0] + (eb->buf[1]<<8);
    free(eb);
    return c;
}
@
% >>

<<function emoveto>>=
void
emoveto(Point pt)
{
    char buf[2*12+2];
    int n;

    n = sprint(buf, "m%d %d", pt.x, pt.y);
    write(mousefd, buf, n);
}
@

<<function esetcursor>>=
void
esetcursor(Cursor *c)
{
    uchar curs[2*4+2*2*16];

    if(c == 0)
        write(cursorfd, curs, 0);
    else{
        BPLONG(curs+0*4, c->offset.x);
        BPLONG(curs+1*4, c->offset.y);
        memmove(curs+2*4, c->clr, 2*2*16);
        write(cursorfd, curs, sizeof curs);
    }
}
@

<<function ereadmouse>>=
int
ereadmouse(Mouse *m)
{
    int n;
    char buf[128];

    do{
        n = read(mousefd, buf, sizeof(buf));
        if(n < 0)	/* probably interrupted */
            return -1;
        n = eatomouse(m, buf, n);
    }while(n == 0);
    return n;
}
@

<<function eatomouse>>=
int
eatomouse(Mouse *m, char *buf, int n)
{
    if(n != 1+4*12){
        werrstr("atomouse: bad count");
        return -1;
    }

    if(buf[0] == 'r')
        eresized(1);
    m->xy.x = atoi(buf+1+0*12);
    m->xy.y = atoi(buf+1+1*12);
    m->buttons = atoi(buf+1+2*12);
    m->msec = atoi(buf+1+3*12);
    return n;
}
@


















\subsection{[[egetrects.c]]}
% event version of getrects.c ?


<<constant W>>=
#define	W	Borderwidth
@

<<global tmp>>=
static Image *tmp[4];
@

<<global red>>=
static Image *red;
@

<<global sweep>>=
static Cursor sweep={
    {-7, -7},
    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0x07,
     0xE0, 0x07, 0xE0, 0x07, 0xE3, 0xF7, 0xE3, 0xF7,
     0xE3, 0xE7, 0xE3, 0xF7, 0xE3, 0xFF, 0xE3, 0x7F,
     0xE0, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,},
    {0x00, 0x00, 0x7F, 0xFE, 0x40, 0x02, 0x40, 0x02,
     0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x41, 0xE2,
     0x41, 0xC2, 0x41, 0xE2, 0x41, 0x72, 0x40, 0x38,
     0x40, 0x1C, 0x40, 0x0E, 0x7F, 0xE6, 0x00, 0x00,}
};
@

% edrawgetrects -> <>
<<function brects>>=
static
void
brects(Rectangle r, Rectangle rp[4])
{
    if(Dx(r) < 2*W)
        r.max.x = r.min.x+2*W;
    if(Dy(r) < 2*W)
        r.max.y = r.min.y+2*W;
    rp[0] = Rect(r.min.x, r.min.y, r.max.x, r.min.y+W);
    rp[1] = Rect(r.min.x, r.max.y-W, r.max.x, r.max.y);
    rp[2] = Rect(r.min.x, r.min.y+W, r.min.x+W, r.max.y-W);
    rp[3] = Rect(r.max.x-W, r.min.y+W, r.max.x, r.max.y-W);
}
@

<<function egetrect>>=
Rectangle
egetrect(int but, Mouse *m)
{
    Rectangle r, rc;

    but = 1<<(but-1);
    esetcursor(&sweep);
    while(m->buttons)
        *m = emouse();
    while(!(m->buttons & but)){
        *m = emouse();
        if(m->buttons & (7^but))
            goto Return;
    }
    r.min = m->xy;
    r.max = m->xy;
    do{
        rc = canonrect(r);
        edrawgetrect(rc, 1);
        *m = emouse();
        edrawgetrect(rc, 0);
        r.max = m->xy;
    }while(m->buttons == but);

    Return:
    esetcursor(0);
    if(m->buttons & (7^but)){
        rc.min.x = rc.max.x = 0;
        rc.min.y = rc.max.y = 0;
        while(m->buttons)
            *m = emouse();
    }
    return rc;
}
@

<<function freetmp>>=
static
void
freetmp(void)
{
    freeimage(tmp[0]);
    freeimage(tmp[1]);
    freeimage(tmp[2]);
    freeimage(tmp[3]);
    freeimage(red);
    tmp[0] = tmp[1] = tmp[2] = tmp[3] = red = nil;
}
@

<<function edrawgetrect>>=
void
edrawgetrect(Rectangle rc, int up)
{
    int i;
    Rectangle r, rects[4];

    if(up && tmp[0]!=nil)
        if(Dx(tmp[0]->r)<Dx(rc) || Dy(tmp[2]->r)<Dy(rc))
            freetmp();

    if(tmp[0] == 0){
        r = Rect(0, 0, Dx(view->r), W);
        tmp[0] = allocimage(display, r, view->chan, 0, -1);
        tmp[1] = allocimage(display, r, view->chan, 0, -1);
        r = Rect(0, 0, W, Dy(view->r));
        tmp[2] = allocimage(display, r, view->chan, 0, -1);
        tmp[3] = allocimage(display, r, view->chan, 0, -1);
        red = allocimage(display, Rect(0,0,1,1), view->chan, 1, DRed);
        if(tmp[0]==0 || tmp[1]==0 || tmp[2]==0 || tmp[3]==0 || red==0)
            drawerror(display, "getrect: allocimage failed");
    }
    brects(rc, rects);
    if(!up){
        for(i=0; i<4; i++)
            draw(view, rects[i], tmp[i], nil, ZP);
        return;
    }
    for(i=0; i<4; i++){
        draw(tmp[i], Rect(0, 0, Dx(rects[i]), Dy(rects[i])), view, nil, rects[i].min);
        draw(view, rects[i], red, nil, ZP);
    }
}
@

\subsection{[[emenuhits.c]]}
% event version of menuhits.c

<<enum _anon_ (lib_graphics/libdraw/emenuhit.c)>>=
enum
{
    Margin = 4,		/* outside to text */
    Border = 2,		/* outside to selection boxes */
    Blackborder = 2,	/* width of outlining border */
    Vspacing = 2,		/* extra spacing between lines of text */
    Maxunscroll = 25,	/* maximum #entries before scrolling turns on */
    Nscroll = 20,		/* number entries in scrolling part */
    Scrollwid = 14,		/* width of scroll bar */
    Gap = 4,			/* between text and scroll bar */
};
@

<<global menutxt>>=
static	Image	*menutxt;
@

<<global back>>=
static	Image	*back;
@

<<global high>>=
static	Image	*high;
@

<<global bord>>=
static	Image	*bord;
@

<<global text>>=
static	Image	*text;
@

<<global htext>>=
static	Image	*htext;
@

<<function menucolors>>=
static
void
menucolors(void)
{
    /* Main tone is greenish, with negative selection */
    back = allocimagemix(display, DPalegreen, DWhite);
    high = allocimage(display, Rect(0,0,1,1), CMAP8, 1, DDarkgreen);	/* dark green */
    bord = allocimage(display, Rect(0,0,1,1), CMAP8, 1, DMedgreen);	/* not as dark green */
    if(back == nil || high == nil || bord == nil)
        goto Error;
    text = display->black;
    htext = back;
    return;

    Error:
    freeimage(back);
    freeimage(high);
    freeimage(bord);
    back = display->white;
    high = display->black;
    bord = display->black;
    text = display->black;
    htext = display->white;
}
@

<<function menurect>>=
/*
 * r is a rectangle holding the text elements.
 * return the rectangle, including its black edge, holding element i.
 */
static Rectangle
menurect(Rectangle r, int i)
{
    if(i < 0)
        return Rect(0, 0, 0, 0);
    r.min.y += (font->height+Vspacing)*i;
    r.max.y = r.min.y+font->height+Vspacing;
    return insetrect(r, Border-Margin);
}
@

<<function menusel>>=
/*
 * r is a rectangle holding the text elements.
 * return the element number containing p.
 */
static int
menusel(Rectangle r, Point p)
{
    r = insetrect(r, Margin);
    if(!ptinrect(p, r))
        return -1;
    return (p.y-r.min.y)/(font->height+Vspacing);
}
@

<<function paintitem>>=
static
void
paintitem(Menu *menu, Rectangle textr, int off, int i, int highlight, Image *save, Image *restore)
{
    char *item;
    Rectangle r;
    Point pt;

    if(i < 0)
        return;
    r = menurect(textr, i);
    if(restore){
        draw(view, r, restore, nil, restore->r.min);
        return;
    }
    if(save)
        draw(save, save->r, view, nil, r.min);
    item = menu->item? menu->item[i+off] : (*menu->gen)(i+off);
    pt.x = (textr.min.x+textr.max.x-stringwidth(font, item))/2;
    pt.y = textr.min.y+i*(font->height+Vspacing);
    draw(view, r, highlight? high : back, nil, pt);
    string(view, pt, highlight? htext : text, pt, font, item);
}
@

<<function menuscan>>=
/*
 * menur is a rectangle holding all the highlightable text elements.
 * track mouse while inside the box, return what's selected when button
 * is raised, -1 as soon as it leaves box.
 * invariant: nothing is highlighted on entry or exit.
 */
static int
menuscan(Menu *menu, int but, Mouse *m, Rectangle textr, int off, int lasti, Image *save)
{
    int i;

    paintitem(menu, textr, off, lasti, 1, save, nil);
    flushimage(display, true);	/* in case display->locking is set */
    *m = emouse();
    while(m->buttons & (1<<(but-1))){
        flushimage(display, true);	/* in case display->locking is set */
        *m = emouse();
        i = menusel(textr, m->xy);
        if(i != -1 && i == lasti)
            continue;
        paintitem(menu, textr, off, lasti, 0, nil, save);
        if(i == -1)
            return i;
        lasti = i;
        paintitem(menu, textr, off, lasti, 1, save, nil);
    }
    return lasti;
}
@

<<function menupaint>>=
static void
menupaint(Menu *menu, Rectangle textr, int off, int nitemdrawn)
{
    int i;

    draw(view, insetrect(textr, Border-Margin), back, nil, ZP);
    for(i = 0; i<nitemdrawn; i++)
        paintitem(menu, textr, off, i, 0, nil, nil);
}
@

<<function menuscrollpaint>>=
static void
menuscrollpaint(Rectangle scrollr, int off, int nitem, int nitemdrawn)
{
    Rectangle r;

    draw(view, scrollr, back, nil, ZP);
    r.min.x = scrollr.min.x;
    r.max.x = scrollr.max.x;
    r.min.y = scrollr.min.y + (Dy(scrollr)*off)/nitem;
    r.max.y = scrollr.min.y + (Dy(scrollr)*(off+nitemdrawn))/nitem;
    if(r.max.y < r.min.y+2)
        r.max.y = r.min.y+2;
    border(view, r, 1, bord, ZP);
    if(menutxt == 0)
        menutxt = allocimage(display, Rect(0, 0, 1, 1), CMAP8, 1, DDarkgreen);
    if(menutxt)
        draw(view, insetrect(r, 1), menutxt, nil, ZP);
}
@

<<function emenuhit>>=
int
emenuhit(int but, Mouse *m, Menu *menu)
{
    int i, nitem, nitemdrawn, maxwid, lasti, off, noff, wid, screenitem;
    int scrolling;
    Rectangle r, menur, sc, textr, scrollr;
    Image *b, *save;
    Point pt;
    char *item;

    if(back == nil)
        menucolors();
    sc = view->clipr;
    replclipr(view, 0, view->r);
    maxwid = 0;
    for(nitem = 0;
        item = menu->item? menu->item[nitem] : (*menu->gen)(nitem);
        nitem++){
        i = stringwidth(font, item);
        if(i > maxwid)
            maxwid = i;
    }
    if(menu->lasthit<0 || menu->lasthit>=nitem)
        menu->lasthit = 0;
    screenitem = (Dy(view->r)-10)/(font->height+Vspacing);
    if(nitem>Maxunscroll || nitem>screenitem){
        scrolling = 1;
        nitemdrawn = Nscroll;
        if(nitemdrawn > screenitem)
            nitemdrawn = screenitem;
        wid = maxwid + Gap + Scrollwid;
        off = menu->lasthit - nitemdrawn/2;
        if(off < 0)
            off = 0;
        if(off > nitem-nitemdrawn)
            off = nitem-nitemdrawn;
        lasti = menu->lasthit-off;
    }else{
        scrolling = 0;
        nitemdrawn = nitem;
        wid = maxwid;
        off = 0;
        lasti = menu->lasthit;
    }
    r = insetrect(Rect(0, 0, wid, nitemdrawn*(font->height+Vspacing)), -Margin);
    r = rectsubpt(r, Pt(wid/2, lasti*(font->height+Vspacing)+font->height/2));
    r = rectaddpt(r, m->xy);
    pt = ZP;
    if(r.max.x>view->r.max.x)
        pt.x = view->r.max.x-r.max.x;
    if(r.max.y>view->r.max.y)
        pt.y = view->r.max.y-r.max.y;
    if(r.min.x<view->r.min.x)
        pt.x = view->r.min.x-r.min.x;
    if(r.min.y<view->r.min.y)
        pt.y = view->r.min.y-r.min.y;
    menur = rectaddpt(r, pt);
    textr.max.x = menur.max.x-Margin;
    textr.min.x = textr.max.x-maxwid;
    textr.min.y = menur.min.y+Margin;
    textr.max.y = textr.min.y + nitemdrawn*(font->height+Vspacing);
    if(scrolling){
        scrollr = insetrect(menur, Border);
        scrollr.max.x = scrollr.min.x+Scrollwid;
    }else
        scrollr = Rect(0, 0, 0, 0);

    b = allocimage(display, menur, view->chan, 0, 0);
    if(b == 0)
        b = view;
    draw(b, menur, view, nil, menur.min);
    draw(view, menur, back, nil, ZP);
    border(view, menur, Blackborder, bord, ZP);
    save = allocimage(display, menurect(textr, 0), view->chan, 0, -1);
    r = menurect(textr, lasti);
    emoveto(divpt(addpt(r.min, r.max), 2));
    menupaint(menu, textr, off, nitemdrawn);
    if(scrolling)
        menuscrollpaint(scrollr, off, nitem, nitemdrawn);
    while(m->buttons & (1<<(but-1))){
        lasti = menuscan(menu, but, m, textr, off, lasti, save);
        if(lasti >= 0)
            break;
        while(!ptinrect(m->xy, textr) && (m->buttons & (1<<(but-1)))){
            if(scrolling && ptinrect(m->xy, scrollr)){
                noff = ((m->xy.y-scrollr.min.y)*nitem)/Dy(scrollr);
                noff -= nitemdrawn/2;
                if(noff < 0)
                    noff = 0;
                if(noff > nitem-nitemdrawn)
                    noff = nitem-nitemdrawn;
                if(noff != off){
                    off = noff;
                    menupaint(menu, textr, off, nitemdrawn);
                    menuscrollpaint(scrollr, off, nitem, nitemdrawn);
                }
            }
            flushimage(display, true);	/* in case display->locking is set */
            *m = emouse();
        }
    }
    draw(view, menur, b, nil, menur.min);
    if(b != view)
        freeimage(b);
    freeimage(save);
    replclipr(view, 0, sc);
    if(lasti >= 0){
        menu->lasthit = lasti+off;
        return menu->lasthit;
    }
    return -1;
}
@
% >> >>



\section{Graphics text mode}

% when do aux/vga it switches to graphic mode, but we still want a console!
% the kernel still needs a working (*screenputs)(...).

% this used to be a subsection of VGA driver, 
% but the code seems quite generic and almost independent of VGA
% so I moved it here.

<<global curpos(x86)>>=
static Point curpos;
@
<<global window bis(x86)>>=
static Rectangle window;
@



<<[[screensize()]] vga settings>>=
scr->memdefont = getmemdefont();
@
% direct access to subfont! no intermediate Font wrapper.
% Just need 1 subfont for simple ascii stuff.




% /dev/vgactl size write -> <>
<<function vgascreenwin(x86)>>=
void
vgascreenwin(VGAscr* scr)
{
    int h, w;

    h = scr->memdefont->height;
    w = scr->memdefont->info[' '].width;

    window = insetrect(gscreen->r, 48);
    window.max.x = window.min.x+((window.max.x-window.min.x)/w)*w;
    window.max.y = window.min.y+((window.max.y-window.min.y)/h)*h;
    curpos = window.min;

    screenputs = vgascreenputs;
}
@
%todo: do like for raspberry, have greet message also in graphic mode?

% vgascreenputs -> screenputs = <> (and screenputs call for printing 
%  keystroke on the screen)
<<function vgascreenputs(x86)>>=
static void
vgascreenputs(char* s, int n)
{
    int i;
    bool gotdraw;
    Rune r;
    char buf[4];
    VGAscr *scr;
    Rectangle flushr;

    scr = &vgascreen;

    if(!islo()){
        /*
         * Don't deadlock trying to
         * print in an interrupt.
         */
        if(!canlock(&vgascreenlock))
            return;
    }
    else
        lock(&vgascreenlock);

    /*
     * Be nice to hold this, but not going to deadlock
     * waiting for it.  Just try and see.
     */
    gotdraw = canqlock(&drawlock);

    flushr = Rect(10000, 10000, -10000, -10000);

    while(n > 0){
        i = chartorune(&r, s);
        if(i == 0){
            s++;
            --n;
            continue;
        }
        memmove(buf, s, i);
        buf[i] = 0;
        n -= i;
        s += i;
        vgascreenputc(scr, buf, &flushr);
    }
    flushmemscreen(flushr);

    if(gotdraw)
        qunlock(&drawlock);
    unlock(&vgascreenlock);
}
@


<<global xbuf(x86)>>=
static int xbuf[256];
@
<<global xp(x86)>>=
static int *xp;
@


% vgascreenputs -> <>
<<function vgascreenputc(x86)>>=
static void
vgascreenputc(VGAscr* scr, char* buf, Rectangle *flushr)
{
    Point p;
    int h, w, pos;
    Rectangle r;

    if(xp < xbuf || xp >= &xbuf[sizeof(xbuf)])
        xp = xbuf;

    h = scr->memdefont->height;
    switch(buf[0]){

    case '\n':
        if(curpos.y+h >= window.max.y){
            vgascroll(scr);
            *flushr = window;
        }
        curpos.y += h;
        vgascreenputc(scr, "\r", flushr);
        break;

    case '\r':
        xp = xbuf;
        curpos.x = window.min.x;
        break;

    case '\t':
        p = memsubfontwidth(scr->memdefont, " ");
        w = p.x;
        if(curpos.x >= window.max.x-4*w)
            vgascreenputc(scr, "\n", flushr);

        pos = (curpos.x-window.min.x)/w;
        pos = 4-(pos%4);
        *xp++ = curpos.x;
        r = Rect(curpos.x, curpos.y, curpos.x+pos*w, curpos.y + h);
        memimagedraw(gscreen, r, back, back->r.min, nil, back->r.min, S);
        curpos.x += pos*w;
        break;

    case '\b':
        if(xp <= xbuf)
            break;
        xp--;
        r = Rect(*xp, curpos.y, curpos.x, curpos.y+h);
        memimagedraw(gscreen, r, back, back->r.min, nil, ZP, S);
        combinerect(flushr, r);
        curpos.x = *xp;
        break;

    case '\0':
        break;

    default:
        p = memsubfontwidth(scr->memdefont, buf);
        w = p.x;

        if(curpos.x >= window.max.x-w)
            vgascreenputc(scr, "\n", flushr);

        *xp++ = curpos.x;
        r = Rect(curpos.x, curpos.y, curpos.x+w, curpos.y+h);
        memimagedraw(gscreen, r, back, back->r.min, nil, back->r.min, S);
        memimagestring(gscreen, curpos, conscol, ZP, scr->memdefont, buf);
        combinerect(flushr, r);
        curpos.x += w;
    }
}
@
%old: was setting to true at beginning and reset at end
%//  drawdebug = true;
%//  drawdebug = false;





% vgascreenputs -> vgascreenputc -> <>
<<function vgascroll(x86)>>=
static void
vgascroll(VGAscr* scr)
{
    int h, o;
    Point p;
    Rectangle r;

    h = scr->memdefont->height;
    o = 8*h;
    r = Rpt(window.min, Pt(window.max.x, window.max.y-o));
    p = Pt(window.min.x, window.min.y+o);
    memimagedraw(gscreen, r, gscreen, p, nil, p, S);
    r = Rpt(Pt(window.min.x, window.max.y-o), window.max);
    memimagedraw(gscreen, r, back, ZP, nil, ZP, S);

    curpos.y -= o;
}
@
% not very hardware specific, could probably be put in a generic screen.c no?


<<global back2(x86)>>=
static Memimage* back;
@

<<global conscol(x86)>>=
static Memimage *conscol;
@

<<[[screensize()]] vga settings>>=
vgaimageinit(chan);
@

<<function vgaimageinit(x86)>>=
void
vgaimageinit(ulong chan)
{
    if(back == nil){
        back = allocmemimage(Rect(0,0,1,1), chan);  /* RSC BUG */
        if(back == nil)
            panic("back alloc");        /* RSC BUG */
        back->flags |= Frepl;
        back->clipr = Rect(-0x3FFFFFF, -0x3FFFFFF, 0x3FFFFFF, 0x3FFFFFF);
        memfillcolor(back, DBlack);
    }

    if(conscol == nil){
        conscol = allocmemimage(Rect(0,0,1,1), chan);   /* RSC BUG */
        if(conscol == nil)
            panic("conscol alloc"); /* RSC BUG */
        conscol->flags |= Frepl;
        conscol->clipr = Rect(-0x3FFFFFF, -0x3FFFFFF, 0x3FFFFFF, 0x3FFFFFF);
        memfillcolor(conscol, DWhite);
    }
}
@

\section{Blank screen}

%echo blang > /dev/vgactl ??

<<[[vgactl]] cases(x86)>>=
case CMblank:
    drawblankscreen(true);
    return;
@
<<[[vgactl]] cases(x86)>>=
case CMunblank:
    drawblankscreen(false);
    return;
@

<<[[KDraw]] other fields>>=
bool	blanked;    /* screen turned off */
@


% in draw!
<<function drawblankscreen>>=
void
drawblankscreen(bool blank)
{
    int i, nc;
    ulong *p;

    if(blank == sdraw.blanked)
        return;
    if(!candlock())
        return;
    if(screenimage == nil){
        dunlock();
        return;
    }
    p = sdraw.savemap;
    nc = screenimage->depth > 8 ? 256 : 1<<screenimage->depth;

    /*
     * blankscreen uses the hardware to blank the screen
     * when possible.  to help in cases when it is not possible,
     * we set the color map to be all black.
     */
    if(!blank){ /* turn screen on */
        for(i=0; i<nc; i++, p+=3)
            setcolor(i, p[0], p[1], p[2]);
        blankscreen(false);
    }else{  /* turn screen off */
        blankscreen(true);
        for(i=0; i<nc; i++, p+=3){
            getcolor(i, &p[0], &p[1], &p[2]);
            setcolor(i, 0, 0, 0);
        }
    }
    sdraw.blanked = blank;
    dunlock();
}
@
% >>

<<[[KDraw]] other fields>>=
ulong   savemap[3*256];
@



<<global blanktime>>=
ulong blanktime = 30;   /* in minutes; a half hour */
@
% used by drawactive()
<<[[vgactl]] cases(x86)>>=
case CMblanktime:
    blanktime = strtoul(cb->f[1], 0, 0);
    return;
@

<<[[KDraw]] other fields>>=
ulong   blanktime;  /* time of last operation */
@

% seems always caleld with active = true (from draw read/write colormap)
<<function drawactive>>=
/*
 * record activity on screen, changing blanking as appropriate
 */
void
drawactive(bool active)
{
    if(active){
        drawblankscreen(false);
        sdraw.blanktime = CPUS(0)->ticks;
    }else{
        if(blanktime && sdraw.blanktime 
           && TK2SEC(CPUS(0)->ticks - sdraw.blanktime)/60 >= blanktime)
            drawblankscreen(true);
    }
}
@

% vgaread -> <>
<<function drawidletime>>=
int
drawidletime(void)
{
    return TK2SEC(CPUS(0)->ticks - sdraw.blanktime)/60;
}
@

\subsection{Hardware support hook}

<<global hwblank(x86)>>=
bool hwblank = false;    /* turned on by drivers that are known good */
@

<<[[vgactl]] cases(x86)>>=
case CMhwblank:
    if(strcmp(cb->f[1], "on") == 0)
        hwblank = true;
    else if(strcmp(cb->f[1], "off") == 0)
        hwblank = false;
    else
        break;
    return;
@



<<[[VGAscr]] optional methods(x86)>>=
void  (*blank)(VGAscr*, int);
@

<<[[VGAscr]] other fields(x86)>>=
int isblank;
@
% dead isblank? not set in drawblankscreen, probably bug no?

<<function blankscreen bis(x86)>>=
void
blankscreen(int blank)
{
    VGAscr *scr;

    scr = &vgascreen;
    if(hwblank){
        if(scr->blank)
            scr->blank(scr, blank);
        else
            vgablank(scr, blank);
    }
}
@

% blankscreen -> <>
<<function vgablank(x86)>>=
/*
 * Supposedly this is the way to turn DPMS
 * monitors off using just the VGA registers.
 * Unfortunately, it seems to mess up the video mode
 * on the cards I've tried.
 */
void
vgablank(VGAscr*, int blank)
{
    uchar seq1, crtc17;

    if(blank) {
        seq1 = 0x00;
        crtc17 = 0x80;
    } else {
        seq1 = 0x20;
        crtc17 = 0x00;
    }

    outs(Seqx, 0x0100);         /* synchronous reset */
    seq1 |= vgaxi(Seqx, 1) & ~0x20;
    vgaxo(Seqx, 1, seq1);
    crtc17 |= vgaxi(Crtx, 0x17) & ~0x80;
    delay(10);
    vgaxo(Crtx, 0x17, crtc17);
    outs(Crtx, 0x0300);             /* end synchronous reset */
}
@



\section{Refresh}

<<[[Client]] other fields>>=
Refresh*    refresh;
Rendez      refrend;
int     refreshme;
@

<<function drawrefactive>>=
static
int
drawrefactive(void *a)
{
    Client *c;

    c = a;
    return c->refreshme || c->refresh != nil;
}
@


<<struct Refresh>>=
struct Refresh
{
    DImage*     dimage;
    Rectangle   r;
    Refresh*    next;
};
@


% many -> <>
<<function drawwakeall>>=
void
drawwakeall(void)
{
    Client *cl;
    int i;

    for(i=0; i<sdraw.nclient; i++){
        cl = sdraw.client[i];
        if(cl && (cl->refreshme || cl->refresh))
            wakeup(&cl->refrend);
    }
}
@

<<[[drawclose()]] other locals>>=
Refresh *r;
@

<<[[drawclose()]] free refresh>>=
while(r = cl->refresh){ /* assign = */
    cl->refresh = r->next;
    free(r);
}
@

\subsection{[[/dev/draw/x/refresh]]}

<<[[Display]] devdraw connection fields>>=
fdt		reffd; // /dev/draw/x/refresh
@

<<[[drawread()]] other locals>>=
Refresh *r;
@

<<[[drawread()]] switch qid cases>>=
case Qrefresh:
    if(n < 5*4)
        error(Ebadarg);
    for(;;){
        if(cl->refreshme || cl->refresh)
            break;

        dunlock();
        if(waserror()){
            dlock();    /* restore lock for waserror() above */
            nexterror();
        }

        sleep(&cl->refrend, drawrefactive, cl);

        poperror();
        dlock();
    }
    p = a;
    while(cl->refresh && n>=5*4){
        r = cl->refresh;
        BPLONG(p+0*4, r->dimage->id);
        BPLONG(p+1*4, r->r.min.x);
        BPLONG(p+2*4, r->r.min.y);
        BPLONG(p+3*4, r->r.max.x);
        BPLONG(p+4*4, r->r.max.y);
        cl->refresh = r->next;
        free(r);
        p += 5*4;
        n -= 5*4;
    }
    cl->refreshme = 0;
    n = p-(uchar*)a;
    break;
@



\subsection{Window refresh}

<<[[ldrawop()]] return if no save in dst>>=
if(insave && d->dstlayer->save == nil)
    return;
@

<<[[memdraw()]] if refresh function for src>>=
if(sl->save == nil)
    return;	/* refresh function makes this case unworkable */
@
% todo, memdraw does not handle src where window and refresh func

<<[[memdraw()]] if refresh function for dst>>=
if(dl->save == nil)
    return;	/* refresh function makes this case unworkable */
@

<<[[drawfreedimage()]] free refreshptr>>=
if(l->layer->refreshfn == drawrefresh)  /* else true owner will clean up */
    free(l->layer->refreshptr);
l->layer->refreshptr = nil;
@

<<function drawrefresh>>=
static
void
drawrefresh(Memimage*, Rectangle r, void *v)
{
    Refx *x;
    DImage *d;
    Client *c;
    Refresh *ref;

    if(v == 0)
        return;
    x = v;
    c = x->client;
    d = x->dimage;
    for(ref=c->refresh; ref; ref=ref->next)
        if(ref->dimage == d){
            combinerect(&ref->r, r);
            return;
        }
    ref = malloc(sizeof(Refresh));
    if(ref){
        ref->dimage = d;
        ref->r = r;
        ref->next = c->refresh;
        c->refresh = ref;
    }
}
@

<<[[drawmesg()]] free image case, if dscreen>>=
if(ll && ll->dscreen && ll->dscreen->owner != client)
    ll->dscreen->owner->refreshme = 1;
@



<<struct Refx>>=
struct Refx
{
    Client*     client;
    DImage*     dimage;
};
@




% used by shadow window in originwindow
<<function memlnorefresh>>=
void
memlnorefresh(Memimage *l, Rectangle r, void *v)
{
    USED(l);
    USED(r.min.x);
    USED(v);
}
@


<<[[lexposeop()]] if not save but refresh method>>=
else
    l->refreshfn(dst, r, l->refreshptr);
@

<<[[drawmesg()]] when top or bottom windows, refresh>>=
ll = drawlookup(client, BGLONG(a+1+1+2), true);
drawrefreshscreen(ll, client);
@

<<[[drawmesg()]] when position window, refresh>>=
ll = drawlookup(client, BGLONG(a+1), true);
drawrefreshscreen(ll, client);
@


<<function drawrefreshscreen>>=
static
void
drawrefreshscreen(DImage *l, Client *client)
{
    while(l != nil && l->dscreen == nil)
        l = l->fromname;
    if(l != nil && l->dscreen->owner != client)
        l->dscreen->owner->refreshme = 1;
}
@


<<[[Memlayer]] refresh fields>>=
Refreshfn	refreshfn;		/* function to call to refresh obscured parts if save==nil */
void		*refreshptr;	/* argument to refreshfn */
@


<<[[drawmesg()]] locals>>=
Refreshfn reffn;
Refx *refx;
@

<<enum _anon_ (include/draw.h)2>>=
enum
{
    /* refresh methods */
    Refbackup	= 0,
    Refnone		= 1,
    Refmesg		= 2 // incomplete apparently
};
@


<<[[drawmesg()]] when allocate window, set reffn>>=
reffn = nil;
switch(refresh){
case Refbackup:
    break;
case Refnone:
    reffn = memlnorefresh;
    break;
case Refmesg:
    reffn = drawrefresh;
    break;
default:
    error("unknown refresh method");
}
@


<<[[drawmesg()]] when allocate window, if reffn>>=
if(reffn){
    refx = nil;
    if(reffn == drawrefresh){
        refx = malloc(sizeof(Refx));
        if(refx == 0){
            drawuninstall(client, dstid);
            error(Edrawmem);
        }
        refx->client = client;
        refx->dimage = drawlookup(client, dstid, true);
    }
    memlsetrefresh(l, reffn, refx);
}
@

<<[[memlalloc()]] if refreshfn>>=
if(refreshfn)
    l->save = nil;
@



<<[[memlalloc()]] set refresh fields part1>>=
l->refreshfn = refreshfn;
l->refreshptr = nil;	/* don't set it until we're done */
@

<<[[memlalloc()]] set refresh fields part2>>=
l->refreshptr = refreshptr;
@


<<function memlsetrefresh>>=
int
memlsetrefresh(Memimage *i, Refreshfn fn, void *ptr)
{
    Memlayer *l;

    l = i->layer;
    if(l->refreshfn!=nil && fn!=nil){	/* just change functions */
        l->refreshfn = fn;
        l->refreshptr = ptr;
        return 1;
    }

    if(l->refreshfn == nil){	/* is using backup image; just free it */
        freememimage(l->save);
        l->save = nil;
        l->refreshfn = fn;
        l->refreshptr = ptr;
        return 1;
    }

    l->save = allocmemimage(i->r, i->chan);
    if(l->save == nil)
        return 0;
    /* easiest way is just to update the entire save area */
    l->refreshfn(i, i->r, l->refreshptr);
    l->refreshfn = nil;
    l->refreshptr = nil;
    return 1;
}
@


\section{Concurrency}

\subsection{[[lockdisplay()]]}

% seems related to IO. graphics(2) mentions it when
%  use multi-thread program! then need lock Display around
%  each API call

<<function lockdisplay>>=
void
lockdisplay(Display *disp)
{
    <<[[lockdisplay()]] if debuglockdisplay>>
    else
        qlock(&disp->qlock);
}
@

<<function unlockdisplay>>=
void
unlockdisplay(Display *disp)
{
    qunlock(&disp->qlock);
}
@

<<[[Display]] concurrency fields>>=
QLock	qlock;
@

% also need notify the library to use a locking protocol also
% for its own accesses (seems used mostly when do internal IO)
<<[[Display]] concurrency fields>>=
bool		locking;	/*program is using lockdisplay */
@

\subsection{[[/dev/draw/x/ctl]] concurrent access}

<<[[drawopen()]] locals>>=
DImage *di;
DName *dn;
@

<<[[drawopen()]] switch qid cases>>=
case Qctl:
    cl = drawclient(c);

    <<[[drawopen()]] switch qid cases, when Qctl, set busy>>

    flushrect = Rect(10000, 10000, -10000, -10000);
    dn = drawlookupname(strlen(screenname), screenname);
    if(dn == nil)
        error("draw: cannot happen 2");

    if(drawinstall(cl, 0, dn->dimage->image, 0) == 0)
        error(Edrawmem);

    di = drawlookup(cl, 0, false);
    if(di == nil)
        error("draw: cannot happen 1");

    <<[[drawopen()]] switch qid cases, when Qctl, set name>>

    incref(&cl->r);
    break;
@
% this is used when someone else access Qctl? normally
%  should have been accessed via Qnew above

\t rect? clipped? or full access? protection?? can draw on
% other windows? when write on /dev/draw/x/ctl ?

%TODO: drawlookupname should be screen_dimage!! assert! 

<<[[drawopen()]] switch qid cases, when Qctl, set name>>=
di->vers = dn->vers;
di->name = smalloc(strlen(screenname)+1);
strcpy(di->name, screenname);
di->fromname = dn->dimage;
di->fromname->ref++;
@







<<[[drawopen()]] switch qid cases, when Qctl, set busy>>=
if(cl->busy)
    error(Einuse);
cl->busy = true;
@

<<[[drawclose()]] if Qctl>>=
if(QID(c->qid) == Qctl)
    cl->busy = false;
@

<<[[Client]] concurrency fields>>=
bool     busy;
@
% only one client of /dev/draw/x/ctl





\section{Optimisations}

\subsection{[[memimagedraw()]] optimisations}

\subsubsection{[[hwdraw()]]}

<<[[hwdraw()]] when dst is the screen>>=
if(scr->fill == nil && scr->scroll == nil)
    return false;
/*
 * If we have an opaque mask and source is one opaque
 * pixel we can convert to the destination format and just
 * replicate with memset.
 */
m = Simplesrc|Simplemask|Fullmask;
if(scr->fill
&& (par->state&m)==m
&& ((par->srgba&0xFF) == 0xFF)
&& (par->op&S) == S)
    return scr->fill(scr, par->r, par->sdval);

/*
 * If no source alpha, an opaque mask, we can just copy the
 * source onto the destination.  If the channels are the same and
 * the source is not replicated, memmove suffices.
 */
m = Simplemask|Fullmask;
if(scr->scroll
&& src->data->bdata==dst->data->bdata
&& !(src->flags&Falpha)
&& (par->state&m)==m
&& (par->op&S) == S)
    return scr->scroll(scr, par->r, par->sr);

return false;   
@

% see fill and scroll in appendix


\subsubsection{[[chardraw()]]}
% also see drawchar() optimisation

% not sure why it's called chardraw. Seems unrelated to fonts.

<<[[memimagedraw()]] try chardraw>>=
/*
 * Character drawing.
 * Solid source color being painted through a boolean mask onto a 
 * high res image.
 */
if(chardraw(&par)){
    DBG1("chardraw handled\n");
    return;
}
@


<<function chardraw>>=
/*
 * Boolean character drawing.
 * Solid opaque color through a 1-bit greyscale mask.
 */
static bool
chardraw(Memdrawparam *par)
{
    Rectangle r, mr;
    Memimage *mask, *src, *dst;
    int op;
    int dx, dy;

    ulong bits;
    int i, ddepth, x, bx, ex, y, npack, bsh, depth;
    ulong v, maskwid, dstwid;
    uchar *wp, *rp, *q, *wc;
    ushort *ws;
    ulong *wl;
    uchar sp[4];

    DBG1("chardraw? mf %lux md %d sf %lux dxs %d dys %d dd %d ddat %p sdat %p\n",
        par->mask->flags, par->mask->depth, par->src->flags, 
        Dx(par->src->r), Dy(par->src->r), par->dst->depth, par->dst->data, par->src->data);

    mask = par->mask;
    src = par->src;
    dst = par->dst;
    r = par->r;
    mr = par->mr;
    op = par->op;

    if((par->state&(Replsrc|Simplesrc|Replmask)) != (Replsrc|Simplesrc)
    || mask->depth != 1 
    || src->flags&Falpha 
    || dst->depth<8 
    || dst->data==src->data
    || op != SoverD)
        return false;

    // else

    DBG1("chardraw...");

    depth = mask->depth;
    maskwid = mask->width * sizeof(ulong);
    rp = byteaddr(mask, mr.min);
    npack = 8/depth;
    bsh = (mr.min.x % npack) * depth;

    wp = byteaddr(dst, r.min);
    dstwid = dst->width*sizeof(ulong);
    DBG1("bsh %d\n", bsh);
    dy = Dy(r);
    dx = Dx(r);

    ddepth = dst->depth;

    /*
     * for loop counts from bsh to bsh+dx
     *
     * we want the bottom bits to be the amount
     * to shift the pixels down, so for n≡0 (mod 8) we want 
     * bottom bits 7.  for n≡1, 6, etc.
     * the bits come from -n-1.
     */

    bx = -bsh-1;
    ex = -bsh-1-dx;
    SET(bits);
    v = par->sdval;

    /* make little endian */
    sp[0] = v;
    sp[1] = v>>8;
    sp[2] = v>>16;
    sp[3] = v>>24;

    DBG1("sp %x %x %x %x\n", sp[0], sp[1], sp[2], sp[3]);
    for(y=0; y<dy; y++, rp+=maskwid, wp+=dstwid){
        q = rp;
        if(bsh)
            bits = *q++;
        switch(ddepth){
        <<[[chardraw()]] switch depth cases>>
        case 32:
            wl = (ulong*)wp;
            v = *(ulong*)sp;
            for(x=bx; x>ex; x--, wl++){
                i = x&7;
                if(i == 8-1)
                    bits = *q++;
                DBG1("bits %lux sh %d...", bits, i);
                if((bits>>i)&1)
                    *wl = v;
            }
            break;
        }
    }

    DBG1("\n");	
    return 1;	
}
@

\subsection{[[alphadraw()]] optimisations}

\subsubsection{Small replicated rectangle}

<<[[ParamDraw]] replication fields>>=
bool	replcache;	/* if set, cache buffers */
@



<<[[getparam()]] if small replicated rectangle>>=
if((img->flags&Frepl) && Dy(img->r) <= MAXBCACHE && Dy(img->r) < Dy(r)){
    p->replcache = true;
    nbuf = Dy(img->r);
}
@

<<[[ParamDraw]] replication fields>>=
Readfn	*replcall;
@

<<[[alphadraw()]] when small repl rectangle optimization>>=
/*
 * If the image has a small enough repl rectangle,
 * we can just read each line once and cache them.
 */
if(z->spar.replcache){
    z->spar.replcall = rdsrc;
    rdsrc = replread;
}
if(z->mpar.replcache){
    z->mpar.replcall = rdmask;
    rdmask = replread;
}
@

<<[[ParamDraw]] replication fields>>=
Buffer	bcache[MAXBCACHE];
ulong	bfilled;
@

<<enum _anon_ (lib_graphics/libmemdraw/draw.c)>>=
enum {
    MAXBCACHE = 16
};
@


<<function replread>>=
/*
 * Replicated cached scan line read.  Call the function listed in the Param,
 * but cache the result so that for replicated images we only do the work once.
 */
static Buffer
replread(Param *p, uchar *s, int y)
{
    Buffer *b;

    USED(s);
    b = &p->bcache[y];
    if((p->bfilled & (1<<y)) == 0){
        p->bfilled |= 1<<y;
        *b = p->replcall(p, p->bufbase+y*p->bufdelta, y);
    }
    return *b;
}
@
% >> >>

\subsubsection{No alpha source}

<<[[alphadraw()]] if source has no alpha and simple bit mask>>=
/*
 * If the mask is purely boolean, we can convert from src to dst format
 * when we read src, and then just copy it to dst where the mask tells us to.
 * This requires a boolean (1-bit grey) mask and lack of a source alpha channel.
 *
 * The computation is accomplished by assigning the function pointers as follows:
 *	rdsrc - read and convert source into dst format in a buffer
 * 	rdmask - convert mask to bytes, set pointer to it
 * 	rddst - fill with pointer to real dst data, but do no reads
 *	calc - copy src onto dst when mask says to.
 *	wrdst - do nothing
 * This is slightly sleazy, since things aren't doing exactly what their names say,
 * but it avoids a fair amount of code duplication to make this a case here
 * rather than have a separate booldraw.
 */
if(!(src->flags&Falpha) 
&& mask->chan == GREY1 
&& dst->depth >= 8 
&& op == SoverD){
    rdsrc = convfn(dst, &z->dpar, src, &z->spar, &ndrawbuf);
    rddst = readptr;
    rdmask = readfn(mask);
    calc = boolcopyfn(dst, mask);
    wrdst = nullwrite;
}
@
%old:
% DBG1("flag %lud mchan %lux=?%x dd %d\n", src->flags&Falpha, mask->chan, GREY1, dst->depth);
%    DBG1("boolcopy...");


<<[[alphadraw()]] when mask and source have no alpha, possibly adapt calc>>=
/*
 * Should really be above, but then boolcopyfns would have
 * to deal with bit alignment, and I haven't written that.
 *
 * This is a common case for things like ellipse drawing.
 * When there's no alpha involved and the mask is boolean,
 * we can avoid all the division and multiplication.
 */
if(mask->chan == GREY1 && !(src->flags&Falpha))
    calc = boolcalc[op];
else if(op == SoverD && !(src->flags&Falpha))
    calc = alphacalcS;
@
% here means depth < 8


\subsubsection{Simple bit mask and big dest, [[boolcopyxxx()]]}

<<[[ParamDraw]] conversion fields>>=
Readfn	*convreadcall;
Writefn	*convwritecall;
int	convbufoff;
Param	*convdpar;
int	convdx;
@

<<function convfn>>=
static Readfn*
convfn(Memimage *dst, Param *dpar, Memimage *src, Param *spar, int *ndrawbuf)
{
    if(dst->chan == src->chan && !(src->flags&Frepl)){
        DBG1("readptr...");
        return readptr;
    }

    if(dst->chan==CMAP8 && (src->chan==GREY1||src->chan==GREY2||src->chan==GREY4)){
        /* cheat because we know the replicated value is exactly the color map entry. */
        DBG1("Readnbit...");
        return readnbit;
    }

    spar->convreadcall = readfn(src);
    spar->convwritecall = writefn(dst);
    spar->convdpar = dpar;

    /* allocate a conversion buffer */
    spar->convbufoff = *ndrawbuf;
    *ndrawbuf += spar->dx*4;

    if(spar->dx > Dx(spar->img->r)){
        spar->convdx = spar->dx;
        spar->dx = Dx(spar->img->r);
    }

    DBG1("genconv...");
    return genconv;
}
@


<<[[ParamDraw]] conversion fields>>=
uchar	*convbuf;
@

<<[[alphadraw()]] set z params part2>>=
z->spar.convbuf = drawbuf + z->spar.convbufoff;
@

<<function genconv>>=
static Buffer
genconv(Param *p, uchar *buf, int y)
{
    Buffer b;
    int nb;
    uchar *r, *w, *ew;

    /* read from source into RGB format in convbuf */
    b = p->convreadcall(p, p->convbuf, y);

    /* write RGB format into dst format in buf */
    p->convwritecall(p->convdpar, buf, b);

    if(p->convdx){
        nb = p->convdpar->img->depth/8;
        r = buf;
        w = buf+nb*p->dx;
        ew = buf+nb*p->convdx;
        while(w<ew)
            *w++ = *r++;
    }

    b.red = buf;
    b.blu = b.grn = b.grey = b.alpha = nil;
    b.rgba = (ulong*)buf;
    b.delta = 0;
    
    return b;
}
@






<<global nullwrite>>=
static Writefn	nullwrite;
@
<<function nullwrite>>=
static void
nullwrite(Param *p, uchar *s, Buffer b)
{
    USED(p);
    USED(s);
    USED(b);
}
@

<<function readptr>>=
static Buffer
readptr(Param *p, uchar *s, int y)
{
    Buffer b;
    uchar *q;

    USED(s);
    q = p->bytermin + y*p->bwidth;
    b.red = q;	/* ptr to data */
    b.grn = b.blu = b.grey = b.alpha = nil;
    b.rgba = (ulong*)q;
    b.delta = p->img->depth/8;
    return b;
}
@

<<function boolcopyfn>>=
static Calcfn*
boolcopyfn(Memimage *img, Memimage *mask)
{
    if(mask->flags&Frepl && Dx(mask->r)==1 && Dy(mask->r)==1 && pixelbits(mask, mask->r.min)==~0)
        return boolmemmove;

    switch(img->depth){
    case 8:
        return boolcopy8;
    case 16:
        return boolcopy16;
    case 24:
        return boolcopy24;
    case 32:
        return boolcopy32;
    default:
        assert(0 /* boolcopyfn */);
    }
    return nil;
}
@

<<function boolmemmove>>=
static Buffer
boolmemmove(Buffer bdst, Buffer bsrc, Buffer b1, int dx, int i, int o)
{
    USED(i);
    USED(o);
    USED(b1);
    USED(bsrc);
    memmove(bdst.red, bsrc.red, dx*bdst.delta);
    return bdst;
}
@

<<function boolcopy8>>=
static Buffer
boolcopy8(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, int i, int o)
{
    uchar *m, *r, *w, *ew;

    USED(i);
    USED(o);
    m = bmask.grey;
    w = bdst.red;
    r = bsrc.red;
    ew = w+dx;
    for(; w < ew; w++,r++)
        if(*m++)
            *w = *r;
    return bdst;	/* not used */
}
@

<<function boolcopy16>>=
static Buffer
boolcopy16(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, int i, int o)
{
    uchar *m;
    ushort *r, *w, *ew;

    USED(i);
    USED(o);
    m = bmask.grey;
    w = (ushort*)bdst.red;
    r = (ushort*)bsrc.red;
    ew = w+dx;
    for(; w < ew; w++,r++)
        if(*m++)
            *w = *r;
    return bdst;	/* not used */
}
@

<<function boolcopy24>>=
static Buffer
boolcopy24(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, int i, int o)
{
    uchar *m;
    uchar *r, *w, *ew;

    USED(i);
    USED(o);
    m = bmask.grey;
    w = bdst.red;
    r = bsrc.red;
    ew = w+dx*3;
    while(w < ew){
        if(*m++){
            *w++ = *r++;
            *w++ = *r++;
            *w++ = *r++;
        }else{
            w += 3;
            r += 3;
        }
    }
    return bdst;	/* not used */
}
@

<<function boolcopy32>>=
static Buffer
boolcopy32(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, int i, int o)
{
    uchar *m;
    ulong *r, *w, *ew;

    USED(i);
    USED(o);
    m = bmask.grey;
    w = (ulong*)bdst.red;
    r = (ulong*)bsrc.red;
    ew = w+dx;
    for(; w < ew; w++,r++)
        if(*m++)
            *w = *r;
    return bdst;	/* not used */
}
@

\subsubsection{Simple bit mask, [[boolcalcxxx()]]}

<<global boolcalc>>=
static Calcfn *boolcalc[Ncomp] =
{
    alphacalc0,		/* Clear */
    boolcalc14,		/* DoutS */
    boolcalc236789,		/* SoutD */
    boolcalc236789,		/* DxorS */
    boolcalc14,		/* DinS */
    alphacalc5,		/* D */
    boolcalc236789,		/* DatopS */
    boolcalc236789,		/* DoverS */
    boolcalc236789,		/* SinD */
    boolcalc236789,		/* SatopD */
    boolcalc1011,		/* S */
    boolcalc1011,		/* SoverD */
};
@

%dead?
<<[[Buffer]] boolcalc fields>>=
/* used by boolcalc* for mask data */
uchar	*m;		/* ptr to mask data r.min byte; like p->bytermin */
int		mskip;	/* no. of left bits to skip in *m */
uchar	*bm;		/* ptr to mask data img->r.min byte; like p->bytey0s */
int		bmskip;	/* no. of left bits to skip in *bm */
uchar	*em;		/* ptr to mask data img->r.max.x byte; like p->bytey0e */
int		emskip;	/* no. of right bits to skip in *em */
@


<<function boolcalc14>>=
static Buffer
boolcalc14(Buffer bdst, Buffer b1, Buffer bmask, int dx, int grey, int op)
{
    Buffer obdst;
    int i, ma, zero;

    USED(b1);

    obdst = bdst;

    for(i=0; i<dx; i++){
        ma = *bmask.alpha;
        zero = ma ? op == DoutS : op == DinS;

        if(grey){
            if(zero)
                *bdst.grey = 0;
            bdst.grey += bdst.delta;
        }else{
            if(zero)
                *bdst.red = *bdst.grn = *bdst.blu = 0;
            bdst.red += bdst.delta;
            bdst.blu += bdst.delta;
            bdst.grn += bdst.delta;
        }
        bmask.alpha += bmask.delta;
        if(bdst.alpha != &ones){
            if(zero)
                *bdst.alpha = 0;
            bdst.alpha += bdst.delta;
        }
    }
    return obdst;
}
@

<<function boolcalc236789>>=
static Buffer
boolcalc236789(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, int grey, int op)
{
    Buffer obdst;
    int fs, fd;
    int i, ma, da, zero;
    ulong s, t;

    obdst = bdst;
    zero = !(op&1);

    for(i=0; i<dx; i++){
        ma = *bmask.alpha;
        da = *bdst.alpha;
        fs = da;
        if(op&2)
            fs = 255-da;
        fd = 0;
        if(op&4)
            fd = 255;

        if(grey){
            if(ma)
                *bdst.grey = MUL(fs, *bsrc.grey, s)+MUL(fd, *bdst.grey, t);
            else if(zero)
                *bdst.grey = 0;
            bsrc.grey += bsrc.delta;
            bdst.grey += bdst.delta;
        }else{
            if(ma){
                *bdst.red = MUL(fs, *bsrc.red, s)+MUL(fd, *bdst.red, t);
                *bdst.grn = MUL(fs, *bsrc.grn, s)+MUL(fd, *bdst.grn, t);
                *bdst.blu = MUL(fs, *bsrc.blu, s)+MUL(fd, *bdst.blu, t);
            }
            else if(zero)
                *bdst.red = *bdst.grn = *bdst.blu = 0;
            bsrc.red += bsrc.delta;
            bsrc.blu += bsrc.delta;
            bsrc.grn += bsrc.delta;
            bdst.red += bdst.delta;
            bdst.blu += bdst.delta;
            bdst.grn += bdst.delta;
        }
        bmask.alpha += bmask.delta;
        if(bdst.alpha != &ones){
            if(ma)
                *bdst.alpha = fs+MUL(fd, da, t);
            else if(zero)
                *bdst.alpha = 0;
            bdst.alpha += bdst.delta;
        }
    }
    return obdst;
}
@

<<function boolcalc1011>>=
static Buffer
boolcalc1011(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, int grey, int op)
{
    Buffer obdst;
    int i, ma, zero;

    obdst = bdst;
    zero = !(op&1);

    for(i=0; i<dx; i++){
        ma = *bmask.alpha;

        if(grey){
            if(ma)
                *bdst.grey = *bsrc.grey;
            else if(zero)
                *bdst.grey = 0;
            bsrc.grey += bsrc.delta;
            bdst.grey += bdst.delta;
        }else{
            if(ma){
                *bdst.red = *bsrc.red;
                *bdst.grn = *bsrc.grn;
                *bdst.blu = *bsrc.blu;
            }
            else if(zero)
                *bdst.red = *bdst.grn = *bdst.blu = 0;
            bsrc.red += bsrc.delta;
            bsrc.blu += bsrc.delta;
            bsrc.grn += bsrc.delta;
            bdst.red += bdst.delta;
            bdst.blu += bdst.delta;
            bdst.grn += bdst.delta;
        }
        bmask.alpha += bmask.delta;
        if(bdst.alpha != &ones){
            if(ma)
                *bdst.alpha = 255;
            else if(zero)
                *bdst.alpha = 0;
            bdst.alpha += bdst.delta;
        }
    }
    return obdst;
}
@






\subsubsection{No alpha source, [[alphacalcS()]]}

<<function alphacalcS>>=
/* source alpha 1 */
static Buffer
alphacalcS(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, int grey, int op)
{
    Buffer obdst;
    int fd;
    int i, ma;
    ulong s, t;

    USED(op);
    obdst = bdst;

    for(i=0; i<dx; i++){
        ma = *bmask.alpha;
        fd = 255-ma;

        if(grey){
            *bdst.grey = MUL(ma, *bsrc.grey, s)+MUL(fd, *bdst.grey, t);
            bsrc.grey += bsrc.delta;
            bdst.grey += bdst.delta;
        }else{
            *bdst.red = MUL(ma, *bsrc.red, s)+MUL(fd, *bdst.red, t);
            *bdst.grn = MUL(ma, *bsrc.grn, s)+MUL(fd, *bdst.grn, t);
            *bdst.blu = MUL(ma, *bsrc.blu, s)+MUL(fd, *bdst.blu, t);
            bsrc.red += bsrc.delta;
            bsrc.blu += bsrc.delta;
            bsrc.grn += bsrc.delta;
            bdst.red += bdst.delta;
            bdst.blu += bdst.delta;
            bdst.grn += bdst.delta;
        }
        if(bdst.alpha != &ones){
            *bdst.alpha = ma+MUL(fd, *bdst.alpha, t);
            bdst.alpha += bdst.delta;
        }
        bmask.alpha += bmask.delta;
    }
    return obdst;
}
@

\subsubsection{32 bits SoverD [[alphacalc()]]}

<<[[alphacalc11()]] special case for 32bits source and dest>>=
if(q){
    *bdst.rgba = MUL0123(ma, *bsrc.rgba, s, t)+MUL0123(fd, *bdst.rgba, u, v);
    bsrc.rgba++;
    bdst.rgba++;
    bsrc.alpha += sadelta;
    bmask.alpha += bmask.delta;
    continue;
}
@


<<function MUL0123>>=
#define MUL0123(a, x, s, t)	((MUL13(a, x, s)<<8)|MUL02(a, x, t))
@


<<function MUL13>>=
#define MUL13(a, x, t)		(t = (a)*(((x)&MASK13)>>8)+128, ((t+((t>>8)&MASK02))>>8)&MASK02)
@

<<constant MASK13>>=
#define MASK13	0xFF00FF00
@


<<function MUL02>>=
#define MUL02(a, x, t)		(t = (a)*(((x)&MASK02)>>0)+128, ((t+((t>>8)&MASK02))>>8)&MASK02)
@
<<constant MASK02>>=
#define MASK02	0x00FF00FF
@


\subsection{[[drawchar()]] optimisation}

% (to not confuse with chardraw)

<<[[drawchar()]] other locals>>=
static Memimage *tmp;
@

<<[[drawchar()]] optimization when possible>>=
/*
 * If we're drawing greyscale fonts onto a VGA screen,
 * it's very costly to read the screen memory to do the
 * alpha blending inside memdraw.  If this is really a stringbg,
 * then rdst is the bg image (in main memory) which we can
 * refer to for the underlying dst pixels instead of reading dst
 * directly.
 */
if(ishwimage(dst) && !ishwimage(rdst) && font->image->depth > 1){
    if(tmp == nil || tmp->chan != dst->chan || Dx(tmp->r) < Dx(r) || Dy(tmp->r) < Dy(r)){
        if(tmp)
            freememimage(tmp);
        tmp = allocmemimage(Rect(0,0,Dx(r),Dy(r)), dst->chan);
        if(tmp == nil)
            goto fallback;
    }
    memdraw(tmp, Rect(0,0,Dx(r),Dy(r)), rdst, r.min, memopaque, ZP, S);
    memdraw(tmp, Rect(0,0,Dx(r),Dy(r)), src, sp1, font->image, 
      Pt(fc->minx, fc->miny), op);
    memdraw(dst, r, tmp, ZP, memopaque, ZP, S);
}
@

\subsection{Flushing bounding boxes}

\subsubsection{Flushing lines}

% useful optimisation?


<<[[drawmesg()]] when draw line, possible flush>>=
/* avoid memlinebbox if possible */
if(dstid==0 || dst->layer!=nil){
    /* BUG: this is terribly inefficient: update maximal containing rect*/
    r = memlinebbox(p, q, e0, e1, j);
    dstflush(dstid, dst, insetrect(r, -(1+1+j)));
}
@

<<function memlinebbox>>=
Rectangle
memlinebbox(Point p0, Point p1, int end0, int end1, int radius)
{
    Rectangle r, r1;
    int extra;

    r.min.x = 10000000;
    r.min.y = 10000000;
    r.max.x = -10000000;
    r.max.y = -10000000;
    extra = lmax(memlineendsize(end0), memlineendsize(end1));
    r1 = insetrect(canonrect(Rpt(p0, p1)), -(radius+extra));
    addbbox(&r, r1.min);
    addbbox(&r, r1.max);
    return r;
}
@
% need canonrect here?

<<function memlineendsize>>=
int
memlineendsize(int end)
{
    int x3;

    if((end&0x3F) != Endarrow)
        return 0;
    if(end == Endarrow)
        x3 = Arrow3;
    else
        x3 = (end>>23) & 0x1FF;
    return x3;
}
@


<<function lmax>>=
static
int
lmax(int a, int b)
{
    if(a > b)
        return a;
    return b;
}
@


<<function addbbox>>=
/*
 * Simple-minded conservative code to compute bounding box of line.
 * Result is probably a little larger than it needs to be.
 */
static
void
addbbox(Rectangle *r, Point p)
{
    if(r->min.x > p.x)
        r->min.x = p.x;
    if(r->min.y > p.y)
        r->min.y = p.y;
    if(r->max.x < p.x+1)
        r->max.x = p.x+1;
    if(r->max.y < p.y+1)
        r->max.y = p.y+1;
}
@



\subsubsection{Flushing polygons}

<<[[drawmesg()]] when draw polygon, set doflush>>=
doflush = false;
if(dstid==0 || (dst->layer && dst->layer->screen->image->data == screenimage->data))
    doflush = true;    /* simplify test in loop */
@


<<[[drawmesg()]] when draw polygon, if doflush>>=
if(doflush){
    esize = j;
    if(*a == 'p'){
        if(y == 0){
            c = memlineendsize(e0);
            if(c > esize)
                esize = c;
        }
        if(y == ni-1){
            c = memlineendsize(e1);
            if(c > esize)
                esize = c;
        }
    }
    if(*a=='P' && e0!=1 && e0 !=~0)
        r = dst->clipr;
    else if(y > 0){
        r = Rect(q.x-oesize, q.y-oesize, q.x+oesize+1, q.y+oesize+1);
        combinerect(&r, Rect(p.x-esize, p.y-esize, p.x+esize+1, p.y+esize+1));
    }
    if(rectclip(&r, dst->clipr))  /* should perhaps be an arg to dstflush */
        dstflush(dstid, dst, r);
}
@

<<[[drawmesg()]] when draw polygon, special flush if y is 1>>=
if(y == 1)
    dstflush(dstid, dst, Rect(p.x-esize, p.y-esize, p.x+esize+1, p.y+esize+1));
@


\subsubsection{Flushing ellipses}

<<[[drawmesg()]] when draw ellipse, dstflush>>=
dstflush(dstid, dst, Rect(p.x-e0-j, p.y-e1-j, p.x+e0+j+1, p.y+e1+j+1));
@

\subsubsection{Flushing text}

<<[[drawmesg()]] when draw text, dstflush>>=
p.y -= font->ascent;
dstflush(dstid, dst, Rect(p.x, p.y, q.x, p.y+Dy(font->image->r)));
@

\subsubsection{Flushing and windows}


<<[[drawfreedimage()]] addflush>>=
if(l->data == screenimage->data)
    addflush(l->layer->screenr);
@

<<[[dstflush()]] locals>>=
Memlayer *l;
@

<<[[dstflush()]] if layer>>=
l = dst->layer;
if(l == nil)
    return;

// else
do{
    if(l->screen->image->data != screenimage->data)
        return;
    r = rectaddpt(r, l->delta);
    l = l->screen->image->layer;
}while(l);

addflush(r);

@


<<[[drawmesg()]] when allocate window, addflush>>=
addflush(l->layer->screenr);
@

<<[[drawmesg()]] when top or bottom windows, addflush>>=
if(lp[0]->layer->screen->image->data == screenimage->data)
    for(j=0; j<nw; j++)
        addflush(lp[j]->layer->screenr);
@


<<[[drawmesg()]] when position window, addflush>>=
addflush(r);
addflush(dst->layer->screenr);
@


% drawmsg(draw) -> dstflush -> <>
<<function addflush>>=
static void
addflush(Rectangle r)
{
    int abb, ar, anbb;
    Rectangle nbb;

    if(!sdraw.softscreen || !rectclip(&r, screenimage->r))
        return;
    if(flushrect.min.x >= flushrect.max.x){
        flushrect = r;
        waste = 0;
        return;
    }
    // else

    nbb = flushrect;
    combinerect(&nbb, r);
    ar = Dx(r)*Dy(r);
    abb = Dx(flushrect)*Dy(flushrect);
    anbb = Dx(nbb)*Dy(nbb);
    /*
     * Area of new waste is area of new bb minus area of old bb,
     * less the area of the new segment, which we assume is not waste.
     * This could be negative, but that's OK.
     */
    waste += anbb-abb - ar;
    if(waste < 0)
        waste = 0;
    /*
     * absorb if:
     *  total area is small
     *  waste is less than half total area
     *  rectangles touch
     */
    if(anbb<=1024 || waste*2<anbb || rectXrect(flushrect, r)){
        flushrect = nbb;
        return;
    }

    /* emit current state */
    if(flushrect.min.x < flushrect.max.x)
        flushmemscreen(flushrect);
    flushrect = r;

    waste = 0;
}
@
<<global waste>>=
static  int     waste;
@



\subsection{Image compression}

<<constant NMATCH>>=
/*
 * Compressed image file parameters and helper routines
 */
#define	NMATCH	3		/* shortest match possible */
@

<<constant NRUN>>=
#define	NRUN	(NMATCH+31)	/* longest match possible */
@


\subsubsection{Loading compressed images}


% user -> <>
<<function cloadimage>>=
int
cloadimage(Image *i, Rectangle r, uchar *data, int ndata)
{
    int m, nb, miny, maxy, ncblock;
    uchar *a;

    if(!rectinrect(r, i->r)){
        werrstr("cloadimage: bad rectangle");
        return -1;
    }

    miny = r.min.y;
    m = 0;
    ncblock = _compblocksize(r, i->depth);
    while(miny != r.max.y){
        maxy = atoi((char*)data+0*12);
        nb = atoi((char*)data+1*12);
        if(maxy<=miny || r.max.y<maxy){
            werrstr("creadimage: bad maxy %d", maxy);
            return -1;
        }
        data += 2*12;
        ndata -= 2*12;
        m += 2*12;
        if(nb<=0 || ncblock<nb || nb>ndata){
            werrstr("creadimage: bad count %d", nb);
            return -1;
        }
        a = bufimage(i->display, 21+nb);
        if(a == nil)
            return -1;
        a[0] = 'Y';
        BPLONG(a+1, i->id);
        BPLONG(a+5, r.min.x);
        BPLONG(a+9, miny);
        BPLONG(a+13, r.max.x);
        BPLONG(a+17, maxy);
        memmove(a+21, data, nb);
        miny = maxy;
        data += nb;
        ndata += nb;
        m += nb;
    }
    return m;
}
@




<<[[memload()]] if iscompressed>>=
if(iscompressed)
    loadfn = cloadmemimage;
@


% memload -> <> (as loadfn)
<<function cloadmemimage>>=
int
cloadmemimage(Memimage *i, Rectangle r, uchar *data, int ndata)
{
    int y, bpl, c, cnt, offs;
    uchar mem[NMEM], *memp, *omemp, *emem, *linep, *elinep, *u, *eu;

    if(!rectinrect(r, i->r))
        return -1;
    bpl = bytesperline(r, i->depth);
    u = data;
    eu = data+ndata;
    memp = mem;
    emem = mem+NMEM;
    y = r.min.y;
    linep = byteaddr(i, Pt(r.min.x, y));
    elinep = linep+bpl;
    for(;;){
        if(linep == elinep){
            if(++y == r.max.y)
                break;
            linep = byteaddr(i, Pt(r.min.x, y));
            elinep = linep+bpl;
        }
        if(u == eu){	/* buffer too small */
            return -1;
        }
        c = *u++;
        if(c >= 128){
            for(cnt=c-128+1; cnt!=0 ;--cnt){
                if(u == eu){		/* buffer too small */
                    return -1;
                }
                if(linep == elinep){	/* phase error */
                    return -1;
                }
                *linep++ = *u;
                *memp++ = *u++;
                if(memp == emem)
                    memp = mem;
            }
        }
        else{
            if(u == eu)	/* short buffer */
                return -1;
            offs = *u++ + ((c&3)<<8)+1;
            if(memp-mem < offs)
                omemp = memp+(NMEM-offs);
            else
                omemp = memp-offs;
            for(cnt=(c>>2)+NMATCH; cnt!=0; --cnt){
                if(linep == elinep)	/* phase error */
                    return -1;
                *linep++ = *omemp;
                *memp++ = *omemp++;
                if(omemp == emem)
                    omemp = mem;
                if(memp == emem)
                    memp = mem;
            }
        }
    }
    return u-data;
}
@



\subsubsection{Reading compressed images}


<<[[readimage()]] if first 11 characters are compressed string>>=
if(memcmp(hdr, "compressed\n", 11) == 0)
    return creadimage(d, fd, dolock);
@

% readimage -> <>
<<function creadimage>>=
Image *
creadimage(Display *d, int fd, int dolock)
{
    char hdr[5*12+1];
    Rectangle r;
    int m, nb, miny, maxy, new, ldepth, ncblock;
    uchar *buf, *a;
    Image *i;
    ulong chan;

    if(readn(fd, hdr, 5*12) != 5*12)
        return nil;

    /*
     * distinguish new channel descriptor from old ldepth.
     * channel descriptors have letters as well as numbers,
     * while ldepths are a single digit formatted as %-11d.
     */
    new = 0;
    for(m=0; m<10; m++){
        if(hdr[m] != ' '){
            new = 1;
            break;
        }
    }
    if(hdr[11] != ' '){
        werrstr("creadimage: bad format");
        return nil;
    }
    if(new){
        hdr[11] = '\0';
        if((chan = strtochan(hdr)) == 0){
            werrstr("creadimage: bad channel string %s", hdr);
            return nil;
        }
    }else{
        ldepth = ((int)hdr[10])-'0';
        if(ldepth<0 || ldepth>3){
            werrstr("creadimage: bad ldepth %d", ldepth);
            return nil;
        }
        chan = drawld2chan[ldepth];
    }
    r.min.x=atoi(hdr+1*12);
    r.min.y=atoi(hdr+2*12);
    r.max.x=atoi(hdr+3*12);
    r.max.y=atoi(hdr+4*12);
    if(r.min.x>r.max.x || r.min.y>r.max.y){
        werrstr("creadimage: bad rectangle");
        return nil;
    }

    if(d){
        if(dolock)
            lockdisplay(d);
        i = allocimage(d, r, chan, 0, 0);
        <<[[creadimage()]] set malloc tag for debug>>
        if(dolock)
            unlockdisplay(d);
        if(i == nil)
            return nil;
    }else{
        i = mallocz(sizeof(Image), 1);
        if(i == nil)
            return nil;
    }
    ncblock = _compblocksize(r, chantodepth(chan));
    buf = malloc(ncblock);
    if(buf == nil)
        goto Errout;
    miny = r.min.y;
    while(miny != r.max.y){
        if(readn(fd, hdr, 2*12) != 2*12){
        Errout:
            if(dolock)
                lockdisplay(d);
        Erroutlock:
            freeimage(i);
            if(dolock)
                unlockdisplay(d);
            free(buf);
            return nil;
        }
        maxy = atoi(hdr+0*12);
        nb = atoi(hdr+1*12);
        if(maxy<=miny || r.max.y<maxy){
            werrstr("creadimage: bad maxy %d", maxy);
            goto Errout;
        }
        if(nb<=0 || ncblock<nb){
            werrstr("creadimage: bad count %d", nb);
            goto Errout;
        }
        if(readn(fd, buf, nb)!=nb)
            goto Errout;
        if(d){
            if(dolock)
                lockdisplay(d);
            a = bufimage(i->display, 21+nb);
            if(a == nil)
                goto Erroutlock;
            a[0] = 'Y';
            BPLONG(a+1, i->id);
            BPLONG(a+5, r.min.x);
            BPLONG(a+9, miny);
            BPLONG(a+13, r.max.x);
            BPLONG(a+17, maxy);
            if(!new)	/* old image: flip the data bits */
                _twiddlecompressed(buf, nb);
            memmove(a+21, buf, nb);
            if(dolock)
                unlockdisplay(d);
        }
        miny = maxy;
    }
    free(buf);
    return i;
}
@


% creadimage -> <>
<<function _compblocksize>>=
int
_compblocksize(Rectangle r, int depth)
{
    int bpl;

    bpl = bytesperline(r, depth);
    bpl = 2*bpl;	/* add plenty extra for blocking, etc. */
    if(bpl < NCBLOCK)
        return NCBLOCK;
    return bpl;
}
@



% creadimage -> <>
% for old image format
<<function _twiddlecompressed>>=
/*
 * compressed data are seuences of byte codes.  
 * if the first byte b has the 0x80 bit set, the next (b^0x80)+1 bytes
 * are data.  otherwise, it's two bytes specifying a previous string to repeat.
 */
void
_twiddlecompressed(uchar *buf, int n)
{
    uchar *ebuf;
    int j, k, c;

    ebuf = buf+n;
    while(buf < ebuf){
        c = *buf++;
        if(c >= 128){
            k = c-128+1;
            for(j=0; j<k; j++, buf++)
                *buf ^= 0xFF;
        }else
            buf++;
    }
}
@



\subsubsection{Writing compressed images}

<<constant HSHIFT>>=
#define	HSHIFT	3	/* HSHIFT==5 runs slightly faster, but hash table is 64x bigger */
@

<<constant NHASH>>=
#define	NHASH	(1<<(HSHIFT*NMATCH))
@

<<constant HMASK>>=
#define	HMASK	(NHASH-1)
@

<<function hupdate>>=
#define	hupdate(h, c)	((((h)<<HSHIFT)^(c))&HMASK)
@

<<struct Hlist>>=
struct Hlist{
    uchar *s;
    Hlist *next, *prev;
};
@

% >> >>


<<constant NMEM>>=
#define	NMEM	1024		/* window size */
@

<<constant NDUMP>>=
#define	NDUMP	128		/* maximum length of dump */
@

<<constant NCBLOCK>>=
#define	NCBLOCK	6000		/* size of compressed blocks */
@



<<function writeimage>>=
int
writeimage(fdt fd, Image *i, bool dolock)
{
    uchar *outbuf, *outp, *eout;		/* encoded data, pointer, end */
    uchar *loutp;				/* start of encoded line */
    Hlist *hash;				/* heads of hash chains of past strings */
    Hlist *chain, *hp;			/* hash chain members, pointer */
    Hlist *cp;				/* next Hlist to fall out of window */
    int h;					/* hash value */
    uchar *line, *eline;			/* input line, end pointer */
    uchar *data, *edata;			/* input buffer, end pointer */
    ulong n;				/* length of input buffer */
    ulong nb;				/* # of bytes returned by unloadimage */
    int bpl;				/* input line length */
    int offs, runlen;			/* offset, length of consumed data */
    uchar dumpbuf[NDUMP];			/* dump accumulator */
    int ndump;				/* length of dump accumulator */
    int miny, dy;				/* y values while unloading input */
    int chunk, ncblock;
    Rectangle r;
    uchar *p, *q, *s, *es, *t;
    char hdr[11+5*12+1];
    char cbuf[20];

    chunk = i->display->bufsize - 32;	/* a little room for header */
    r = i->r;
    bpl = bytesperline(r, i->depth);
    n = Dy(r)*bpl;
    data = malloc(n);

    ncblock = _compblocksize(r, i->depth);
    outbuf = malloc(ncblock);
    hash = malloc(NHASH*sizeof(Hlist));
    chain = malloc(NMEM*sizeof(Hlist));
    if(data == 0 || outbuf == 0 || hash == 0 || chain == 0){
    ErrOut:
        free(data);
        free(outbuf);
        free(hash);
        free(chain);
        return -1;
    }

    for(miny = r.min.y; miny != r.max.y; miny += dy){
        dy = r.max.y-miny;
        if(dy*bpl > chunk)
            dy = chunk/bpl;

        if(dolock)
            lockdisplay(i->display);

        nb = unloadimage(i, Rect(r.min.x, miny, r.max.x, miny+dy),
            data+(miny-r.min.y)*bpl, dy*bpl);

        if(dolock)
            unlockdisplay(i->display);

        if(nb != dy*bpl)
            goto ErrOut;
    }

    sprint(hdr, "compressed\n%11s %11d %11d %11d %11d ",
        chantostr(cbuf, i->chan), r.min.x, r.min.y, r.max.x, r.max.y);
    if(write(fd, hdr, 11+5*12) != 11+5*12)
        goto ErrOut;
    edata = data+n;
    eout = outbuf+ncblock;
    line = data;
    r.max.y = r.min.y;
    while(line != edata){
        memset(hash, 0, NHASH*sizeof(Hlist));
        memset(chain, 0, NMEM*sizeof(Hlist));
        cp = chain;
        h = 0;
        outp = outbuf;
        for(n = 0; n != NMATCH; n++)
            h = hupdate(h, line[n]);
        loutp = outbuf;
        while(line != edata){
            ndump = 0;
            eline = line+bpl;
            for(p = line; p != eline; ){
                if(eline-p < NRUN)
                    es = eline;
                else
                    es = p+NRUN;
                q = 0;
                runlen = 0;
                for(hp = hash[h].next; hp; hp = hp->next){
                    s = p + runlen;
                    if(s >= es)
                        continue;
                    t = hp->s + runlen;
                    for(; s >= p; s--)
                        if(*s != *t--)
                            goto matchloop;
                    t += runlen+2;
                    s += runlen+2;
                    for(; s < es; s++)
                        if(*s != *t++)
                            break;
                    n = s-p;
                    if(n > runlen){
                        runlen = n;
                        q = hp->s;
                        if(n == NRUN)
                            break;
                    }
            matchloop: ;
                }
                if(runlen < NMATCH){
                    if(ndump == NDUMP){
                        if(eout-outp < ndump+1)
                            goto Bfull;
                        *outp++ = ndump-1+128;
                        memmove(outp, dumpbuf, ndump);
                        outp += ndump;
                        ndump = 0;
                    }
                    dumpbuf[ndump++] = *p;
                    runlen = 1;
                }
                else{
                    if(ndump != 0){
                        if(eout-outp < ndump+1)
                            goto Bfull;
                        *outp++ = ndump-1+128;
                        memmove(outp, dumpbuf, ndump);
                        outp += ndump;
                        ndump = 0;
                    }
                    offs = p-q-1;
                    if(eout-outp < 2)
                        goto Bfull;
                    *outp++ = ((runlen-NMATCH)<<2) + (offs>>8);
                    *outp++ = offs&255;
                }
                for(q = p+runlen; p != q; p++){
                    if(cp->prev)
                        cp->prev->next = 0;
                    cp->next = hash[h].next;
                    cp->prev = &hash[h];
                    if(cp->next)
                        cp->next->prev = cp;
                    cp->prev->next = cp;
                    cp->s = p;
                    if(++cp == &chain[NMEM])
                        cp = chain;
                    if(edata-p > NMATCH)
                        h = hupdate(h, p[NMATCH]);
                }
            }
            if(ndump != 0){
                if(eout-outp < ndump+1)
                    goto Bfull;
                *outp++ = ndump-1+128;
                memmove(outp, dumpbuf, ndump);
                outp += ndump;
            }
            line = eline;
            loutp = outp;
            r.max.y++;
        }
    Bfull:
        if(loutp == outbuf)
            goto ErrOut;
        n = loutp-outbuf;
        sprint(hdr, "%11d %11ld ", r.max.y, n);
        write(fd, hdr, 2*12);
        write(fd, outbuf, n);
        r.min.y = r.max.y;
    }
    free(data);
    free(outbuf);
    free(hash);
    free(chain);
    return 0;
}
@


\subsubsection{[[Memimage]] functions}


% not necessary, Memimage copy paste
% readmemimage -> <>
<<function creadmemimage>>=
Memimage*
creadmemimage(int fd)
{
    char hdr[5*12+1];
    Rectangle r;
    int m, nb, miny, maxy, new, ldepth, ncblock;
    uchar *buf;
    Memimage *i;
    ulong chan;

    if(readn(fd, hdr, 5*12) != 5*12){
        werrstr("readmemimage: short header (2)");
        return nil;
    }

    /*
     * distinguish new channel descriptor from old ldepth.
     * channel descriptors have letters as well as numbers,
     * while ldepths are a single digit formatted as %-11d.
     */
    new = 0;
    for(m=0; m<10; m++){
        if(hdr[m] != ' '){
            new = 1;
            break;
        }
    }
    if(hdr[11] != ' '){
        werrstr("creadimage: bad format");
        return nil;
    }
    if(new){
        hdr[11] = '\0';
        if((chan = strtochan(hdr)) == 0){
            werrstr("creadimage: bad channel string %s", hdr);
            return nil;
        }
    }else{
        ldepth = ((int)hdr[10])-'0';
        if(ldepth<0 || ldepth>3){
            werrstr("creadimage: bad ldepth %d", ldepth);
            return nil;
        }
        chan = drawld2chan[ldepth];
    }
    r.min.x=atoi(hdr+1*12);
    r.min.y=atoi(hdr+2*12);
    r.max.x=atoi(hdr+3*12);
    r.max.y=atoi(hdr+4*12);
    if(r.min.x>r.max.x || r.min.y>r.max.y){
        werrstr("creadimage: bad rectangle");
        return nil;
    }

    i = allocmemimage(r, chan);
    if(i == nil)
        return nil;
    ncblock = _compblocksize(r, i->depth);
    buf = malloc(ncblock);
    if(buf == nil)
        goto Errout;
    miny = r.min.y;
    while(miny != r.max.y){
        if(readn(fd, hdr, 2*12) != 2*12){
        Shortread:
            werrstr("readmemimage: short read");
        Errout:
            freememimage(i);
            free(buf);
            return nil;
        }
        maxy = atoi(hdr+0*12);
        nb = atoi(hdr+1*12);
        if(maxy<=miny || r.max.y<maxy){
            werrstr("readimage: bad maxy %d", maxy);
            goto Errout;
        }
        if(nb<=0 || ncblock<nb){
            werrstr("readimage: bad count %d", nb);
            goto Errout;
        }
        if(readn(fd, buf, nb)!=nb)
            goto Shortread;
        if(!new)	/* old image: flip the data bits */
            _twiddlecompressed(buf, nb);
        cloadmemimage(i, Rect(r.min.x, miny, r.max.x, maxy), buf, nb);
        miny = maxy;
    }
    free(buf);
    return i;
}
@






\section{Old image format}

<<[[readimage()]] other locals>>=
bool new;
@

<<[[readimage()]] check if new or old format, set new>>=
/*
 * distinguish new channel descriptor from old ldepth.
 * channel descriptors have letters as well as numbers,
 * while ldepths are a single digit formatted as %-11d.
 */
new = false;
for(m=0; m<10; m++){
    if(hdr[m] != ' '){
        new = true;
        break;
    }
}
@


<<[[readimage()]] other locals>>=
int ldepth;
@

<<[[readimage()]] if old format>>=
if(!new){
    ldepth = ((int)hdr[10])-'0';
    if(ldepth<0 || ldepth>3){
        werrstr("readimage: bad ldepth %d", ldepth);
        return nil;
    }
    chan = drawld2chan[ldepth];
}
@


<<[[readimage()]] if old format, flip all bits>>=
if(!new)	/* an old image: must flip all the bits */
    for(j=0; j<chunk; j++)
        tmp[j] ^= 0xFF;
@

\section{[[Memimage]] duplicated API}
% for testing code, for togif, for graphics text mode below
% maybe could be put in appendix? or extra?

% dup of getdefont
<<function getmemdefont>>=
Memsubfont*
getmemdefont(void)
{
    char *hdr, *p;
    int n;
    Fontchar *fc;
    Memsubfont *f;
    int ld;
    Rectangle r;
    Memdata *md;
    Memimage *i;

    /*
     * make sure data is word-aligned.  this is true with Plan 9 compilers
     * but not in general.  the byte order is right because the data is
     * declared as char*, not ulong*.
     */
    p = (char*)defontdata;
    n = (uintptr)p & 3;
    if(n != 0){
        memmove(p+(4-n), p, sizeofdefont-n);
        p += 4-n;
    }
    ld = atoi(p+0*12);
    r.min.x = atoi(p+1*12);
    r.min.y = atoi(p+2*12);
    r.max.x = atoi(p+3*12);
    r.max.y = atoi(p+4*12);

    md = mallocz(sizeof(Memdata), 1);
    if(md == nil)
        return nil;
    
    p += 5*12;

    md->base = nil;		/* so freememimage doesn't free p */
    md->bdata = (uchar*)p;	/* ick */
    md->ref = 1;
    md->allocd = true;		/* so freememimage does free md */

    i = allocmemimaged(r, drawld2chan[ld], md);
    if(i == nil){
        free(md);
        return nil;
    }

    hdr = p+Dy(r)*i->width*sizeof(ulong);
    n = atoi(hdr);
    p = hdr+3*12;
    fc = malloc(sizeof(Fontchar)*(n+1));
    if(fc == nil){
        freememimage(i);
        return 0;
    }
    _unpackinfo(fc, (uchar*)p, n);
    f = allocmemsubfont("*default*", n, atoi(hdr+12), atoi(hdr+24), fc, i);
    if(f == nil){
        freememimage(i);
        free(fc);
        return 0;
    }
    return f;
}
@


%\subsection{[[Memsubfont]]}
% not sure you need that actually. Might be dead code.
% or just used in test code?

<<struct Memsubfont>>=
/*
 * Subfonts
 *
 * given char c, Subfont *f, Fontchar *i, and Point p, one says
 *	i = f->info+c;
 *	draw(b, Rect(p.x+i->left, p.y+i->top,
 *		p.x+i->left+((i+1)->x-i->x), p.y+i->bottom),
 *		color, f->bits, Pt(i->x, i->top));
 *	p.x += i->width;
 * to draw characters in the specified color (itself a Memimage) in Memimage b.
 */
struct	Memsubfont
{
    char	*name;

    Memimage	*bits;		/* of font */

    short	n;		/* number of chars in font */
    Fontchar *info;		/* n+1 character descriptors */

    uchar	height;		/* height of bitmap */
    char	ascent;		/* top of bitmap to baseline */
};
@
% ctor = ?
\l actually identical at Subfont, except Image vs Memimage.
\l and it's an important difference, cos the bits are really there





%openmemsubfont | getmemdefont -> <>
<<function allocmemsubfont>>=
Memsubfont*
allocmemsubfont(char *name, int n, int height, int ascent, Fontchar *info, Memimage *i)
{
    Memsubfont *f;
 
    f = malloc(sizeof(Memsubfont));
    if(f == 0)
        return 0;
    f->n = n;
    f->height = height;
    f->ascent = ascent;
    f->info = info;
    f->bits = i;
    if(name)
        f->name = strdup(name);
    else
        f->name = 0;
    return f;
}
@


<<function memsubfontwidth>>=
Point
memsubfontwidth(Memsubfont *f, char *cs)
{
    Rune c;
    Point p;
    uchar *s;
    Fontchar *i;
    int w, width;

    p = Pt(0, f->height);
    s = (uchar*)cs;
    for(; c=*s; p.x+=width){
        width = 0;
        if(c < Runeself)
            s++;
        else{
            w = chartorune(&c, (char*)s);
            if(w == 0){
                s++;
                continue;
            }
            s += w;
        }
        if(c >= f->n)
            continue;
        i = f->info+c;
        width = i->width;
    }
    return p;
}
@


% vgascreenputc -> <>
<<function memimagestring>>=
Point
memimagestring(Memimage *b, Point p, Memimage *color, Point cp, Memsubfont *f, char *cs)
{
    int w, width;
    uchar *s;
    Rune c;
    Fontchar *i;

    s = (uchar*)cs;
    for(; c=*s; p.x+=width, cp.x+=width){
        width = 0;
        if(c < Runeself)
            s++;
        else{
            w = chartorune(&c, (char*)s);
            if(w == 0){
                s++;
                continue;
            }
            s += w;
        }
        if(c >= f->n)
            continue;
        i = f->info+c;
        width = i->width;
        memdraw(b, Rect(p.x+i->left, p.y+i->top, p.x+i->left+(i[1].x-i[0].x), p.y+i->bottom),
            color, cp, f->bits, Pt(i->x, i->top), SoverD);
    }
    return p;
}
@



% dupe of readimage()
% used by togif.c, topng.c, etc
<<function readmemimage>>=
Memimage*
readmemimage(fdt fd)
{
    char hdr[5*12+1];
    int dy;
    ulong chan;
    uint l, n;
    int m, j;
    int new, miny, maxy;
    Rectangle r;
    uchar *tmp;
    int ldepth, chunk;
    Memimage *i;

    if(readn(fd, hdr, 11) != 11){
        werrstr("readimage: short header");
        return nil;
    }
    if(memcmp(hdr, "compressed\n", 11) == 0)
        return creadmemimage(fd);

    if(readn(fd, hdr+11, 5*12-11) != 5*12-11){
        werrstr("readimage: short header (2)");
        return nil;
    }

    /*
     * distinguish new channel descriptor from old ldepth.
     * channel descriptors have letters as well as numbers,
     * while ldepths are a single digit formatted as %-11d.
     */
    new = 0;
    for(m=0; m<10; m++){
        if(hdr[m] != ' '){
            new = 1;
            break;
        }
    }
    if(hdr[11] != ' '){
        werrstr("readimage: bad format");
        return nil;
    }
    if(new){
        hdr[11] = '\0';
        if((chan = strtochan(hdr)) == 0){
            werrstr("readimage: bad channel string %s", hdr);
            return nil;
        }
    }else{
        ldepth = ((int)hdr[10])-'0';
        if(ldepth<0 || ldepth>3){
            werrstr("readimage: bad ldepth %d", ldepth);
            return nil;
        }
        chan = drawld2chan[ldepth];
    }

    r.min.x = atoi(hdr+1*12);
    r.min.y = atoi(hdr+2*12);
    r.max.x = atoi(hdr+3*12);
    r.max.y = atoi(hdr+4*12);
    if(r.min.x>r.max.x || r.min.y>r.max.y){
        werrstr("readimage: bad rectangle");
        return nil;
    }

    miny = r.min.y;
    maxy = r.max.y;

    l = bytesperline(r, chantodepth(chan));
    i = allocmemimage(r, chan);
    if(i == nil)
        return nil;
    chunk = 32*1024;
    if(chunk < l)
        chunk = l;
    tmp = malloc(chunk);
    if(tmp == nil)
        goto Err;
    while(maxy > miny){
        dy = maxy - miny;
        if(dy*l > chunk)
            dy = chunk/l;
        if(dy <= 0){
            werrstr("readmemimage: image too wide for buffer");
            goto Err;
        }
        n = dy*l;
        m = readn(fd, tmp, n);
        if(m != n){
            werrstr("readmemimage: read count %d not %d: %r", m, n);
   Err:
    freememimage(i);
            free(tmp);
            return nil;
        }
        if(!new)	/* an old image: must flip all the bits */
            for(j=0; j<chunk; j++)
                tmp[j] ^= 0xFF;

        if(loadmemimage(i, Rect(r.min.x, miny, r.max.x, miny+dy), tmp, chunk) <= 0)
            goto Err;
        miny += dy;
    }
    free(tmp);
    return i;
}
@





<<constant CHUNK>>=
#define	CHUNK	8000
@

<<constant HSHIFT (lib_graphics/libmemdraw/write.c)>>=
#define	HSHIFT	3	/* HSHIFT==5 runs slightly faster, but hash table is 64x bigger */
@

<<constant NHASH (lib_graphics/libmemdraw/write.c)>>=
#define	NHASH	(1<<(HSHIFT*NMATCH))
@

<<constant HMASK (lib_graphics/libmemdraw/write.c)>>=
#define	HMASK	(NHASH-1)
@

<<function hupdate (lib_graphics/libmemdraw/write.c)>>=
#define	hupdate(h, c)	((((h)<<HSHIFT)^(c))&HMASK)
@

<<struct Hlist (lib_graphics/libmemdraw/write.c)>>=
struct Hlist{
    uchar *s;
    Hlist *next, *prev;
};
@

% dupe of writeimage
% called by iconv.c, but seems mostly dead
<<function writememimage>>=
int
writememimage(int fd, Memimage *i)
{
    uchar *outbuf, *outp, *eout;		/* encoded data, pointer, end */
    uchar *loutp;				/* start of encoded line */
    Hlist *hash;				/* heads of hash chains of past strings */
    Hlist *chain, *hp;			/* hash chain members, pointer */
    Hlist *cp;				/* next Hlist to fall out of window */
    int h;					/* hash value */
    uchar *line, *eline;			/* input line, end pointer */
    uchar *data, *edata;			/* input buffer, end pointer */
    ulong n;				/* length of input buffer */
    ulong nb;				/* # of bytes returned by unloadimage */
    int bpl;				/* input line length */
    int offs, runlen;			/* offset, length of consumed data */
    uchar dumpbuf[NDUMP];			/* dump accumulator */
    int ndump;				/* length of dump accumulator */
    int miny, dy;				/* y values while unloading input */
    int ncblock;				/* size of compressed blocks */
    Rectangle r;
    uchar *p, *q, *s, *es, *t;
    char hdr[11+5*12+1];
    char cbuf[20];

    r = i->r;
    bpl = bytesperline(r, i->depth);
    n = Dy(r)*bpl;
    data = malloc(n);
    ncblock = _compblocksize(r, i->depth);
    outbuf = malloc(ncblock);
    hash = malloc(NHASH*sizeof(Hlist));
    chain = malloc(NMEM*sizeof(Hlist));
    if(data == 0 || outbuf == 0 || hash == 0 || chain == 0){
    ErrOut:
        free(data);
        free(outbuf);
        free(hash);
        free(chain);
        return -1;
    }
    for(miny = r.min.y; miny != r.max.y; miny += dy){
        dy = r.max.y-miny;
        if(dy*bpl > CHUNK)
            dy = CHUNK/bpl;
        nb = unloadmemimage(i, Rect(r.min.x, miny, r.max.x, miny+dy),
            data+(miny-r.min.y)*bpl, dy*bpl);
        if(nb != dy*bpl)
            goto ErrOut;
    }
    sprint(hdr, "compressed\n%11s %11d %11d %11d %11d ",
        chantostr(cbuf, i->chan), r.min.x, r.min.y, r.max.x, r.max.y);
    if(write(fd, hdr, 11+5*12) != 11+5*12)
        goto ErrOut;
    edata = data+n;
    eout = outbuf+ncblock;
    line = data;
    r.max.y = r.min.y;
    while(line != edata){
        memset(hash, 0, NHASH*sizeof(Hlist));
        memset(chain, 0, NMEM*sizeof(Hlist));
        cp = chain;
        h = 0;
        outp = outbuf;
        for(n = 0; n != NMATCH; n++)
            h = hupdate(h, line[n]);
        loutp = outbuf;
        while(line != edata){
            ndump = 0;
            eline = line+bpl;
            for(p = line; p != eline; ){
                if(eline-p < NRUN)
                    es = eline;
                else
                    es = p+NRUN;
                q = 0;
                runlen = 0;
                for(hp = hash[h].next; hp; hp = hp->next){
                    s = p + runlen;
                    if(s >= es)
                        continue;
                    t = hp->s + runlen;
                    for(; s >= p; s--)
                        if(*s != *t--)
                            goto matchloop;
                    t += runlen+2;
                    s += runlen+2;
                    for(; s < es; s++)
                        if(*s != *t++)
                            break;
                    n = s-p;
                    if(n > runlen){
                        runlen = n;
                        q = hp->s;
                        if(n == NRUN)
                            break;
                    }
            matchloop: ;
                }
                if(runlen < NMATCH){
                    if(ndump == NDUMP){
                        if(eout-outp < ndump+1)
                            goto Bfull;
                        *outp++ = ndump-1+128;
                        memmove(outp, dumpbuf, ndump);
                        outp += ndump;
                        ndump = 0;
                    }
                    dumpbuf[ndump++] = *p;
                    runlen = 1;
                }
                else{
                    if(ndump != 0){
                        if(eout-outp < ndump+1)
                            goto Bfull;
                        *outp++ = ndump-1+128;
                        memmove(outp, dumpbuf, ndump);
                        outp += ndump;
                        ndump = 0;
                    }
                    offs = p-q-1;
                    if(eout-outp < 2)
                        goto Bfull;
                    *outp++ = ((runlen-NMATCH)<<2) + (offs>>8);
                    *outp++ = offs&255;
                }
                for(q = p+runlen; p != q; p++){
                    if(cp->prev)
                        cp->prev->next = 0;
                    cp->next = hash[h].next;
                    cp->prev = &hash[h];
                    if(cp->next)
                        cp->next->prev = cp;
                    cp->prev->next = cp;
                    cp->s = p;
                    if(++cp == &chain[NMEM])
                        cp = chain;
                    if(edata-p > NMATCH)
                        h = hupdate(h, p[NMATCH]);
                }
            }
            if(ndump != 0){
                if(eout-outp < ndump+1)
                    goto Bfull;
                *outp++ = ndump-1+128;
                memmove(outp, dumpbuf, ndump);
                outp += ndump;
            }
            line = eline;
            loutp = outp;
            r.max.y++;
        }
    Bfull:
        if(loutp == outbuf)
            goto ErrOut;
        n = loutp-outbuf;
        sprint(hdr, "%11d %11ld ", r.max.y, n);
        write(fd, hdr, 2*12);
        write(fd, outbuf, n);
        r.min.y = r.max.y;
    }
    free(data);
    free(outbuf);
    free(hash);
    free(chain);
    return 0;
}
@



\chapter{Conclusion}

% That's it! you know now!

% Next book = Windowing system. Good example of use of many API
%  functions presented here.
% Also Editor is a graphical app.











\appendix

\chapter{Debugging}


%dead:? used just for this? maybe better to remove no?
% libdraw
<<global _drawdebug>>=
bool	_drawdebug = false;
@
<<[[doflush()]] if _drawdebug>>=
if(_drawdebug)
    fprint(2, "flushimage fail: d=%p: n=%d nn=%d %r\n", d, n, nn); /**/
@




<<global debuglockdisplay>>=
bool		debuglockdisplay = false;
@
<<[[lockdisplay()]] if debuglockdisplay>>=
if(debuglockdisplay){
    /* avoid busy looping; it's rare we collide anyway */
    while(!canqlock(&disp->qlock)){
        fprint(1, "proc %d waiting for display lock...\n", getpid());
        sleep(1000);
    }
}
@



\section{[[drawsetdebug()]]}

% API and marshalling
<<function drawsetdebug>>=
void
drawsetdebug(bool v)
{
    byte *a;
    a = bufimage(display, 1+1);
    if(a == nil){
        fprint(2, "drawsetdebug: %r\n");
        return;
    }
    a[0] = 'D';
    a[1] = v;
}
@

% libmemdrawn
<<global drawdebug>>=
bool drawdebug;
@
% rename? memdrawdebug?


% Unmarshalling
<<[[drawmesg()]] cases>>=
/* toggle debugging: 'D' val[1] */
case 'D':
    printmesg(fmt="b", a, 0);
    m = 1+1;
    <<[[drawmesg()]] sanity check n with m>>
    drawdebug = a[1];
    continue;
@


\section{Dumpers}


\subsection{Point and Rectangle}

% user side
<<[[initdisplay()]] install dumpers>>=
fmtinstall('P', Pfmt);
fmtinstall('R', Rfmt);
@

% kernel side
<<[[memimageinit()]] install dumpers>>=
fmtinstall('P', Pfmt);
fmtinstall('R', Rfmt); 
@

%dumper
<<function Pfmt>>=
int
Pfmt(Fmt *f)
{
    Point p;

    p = va_arg(f->args, Point);
    return fmtprint(f, "[%d %d]", p.x, p.y);
}
@

%dumper
<<function Rfmt>>=
int
Rfmt(Fmt *f)
{
    Rectangle r;

    r = va_arg(f->args, Rectangle);
    return fmtprint(f, "%P %P", r.min, r.max);
}
@


%???
<<[[memimageinit()]] install dumpers>>=
fmtinstall('b', _ifmt);
@

\subsection{Channel}

<<function chantostr>>=
char*
chantostr(char *buf, ulong cc)
{
    ulong c, rc;
    char *p;

    if(chantodepth(cc) == 0)
        return nil;

    /* reverse the channel descriptor so we can easily generate the string in the right order */
    rc = 0;
    for(c=cc; c; c>>=8){
        rc <<= 8;
        rc |= c&0xFF;
    }

    p = buf;
    for(c=rc; c; c>>=8) {
        *p++ = channames[TYPE(c)];
        *p++ = '0'+NBITS(c);
    }
    *p = 0;

    return buf;
}
@



\subsection{Draw protocol message}

% to debug drawmesg()
<<function printmesg>>=
static void
printmesg(char *fmt, uchar *a, bool plsprnt)
{
    char buf[256];
    char *p, *q;
    int s, left;

    if(true || !plsprnt){ //old: 1 || !plsprnt
        SET(s,q,p);
        USED(fmt, a, buf, p, q, s);
        return;
    }

    q = buf;
    *q++ = *a++;
    for(p=fmt; *p; p++){
        left = sizeof buf - 2 - (q - buf);  /* 2 for \n\0 */
        switch(*p){
        case 'l':
            q += snprint(q, left, " %ld", (long)BGLONG(a));
            a += 4;
            break;
        case 'L':
            q += snprint(q, left, " %.8lux", (ulong)BGLONG(a));
            a += 4;
            break;
        case 'R':
            q += snprint(q, left, " [%d %d %d %d]", BGLONG(a),
                BGLONG(a+4), BGLONG(a+8), BGLONG(a+12));
            a += 16;
            break;
        case 'P':
            q += snprint(q, left, " [%d %d]", BGLONG(a), BGLONG(a+4));
            a += 8;
            break;
        case 'b':
            q += snprint(q, left, " %d", *a++);
            break;
        case 's':
            q += snprint(q, left, " %d", BGSHORT(a));
            a += 2;
            break;
        case 'S':
            q += snprint(q, left, " %.4ux", BGSHORT(a));
            a += 2;
            break;
        }
    }
    *q++ = '\n';
    *q = '\0';
    iprint("%.*s", (int)(q-buf), buf);
}
@



\section{Memory tags}

% not sure why do only those 3

<<[[allocimage()]] set malloc tag for debug>>=
if (i)
    setmalloctag(i, getcallerpc(&d));
@

<<[[_getsubfont()]] set malloc tag for debug>>=
setmalloctag(f, getcallerpc(&d));
@

<<[[creadimage()]] set malloc tag for debug>>=
setmalloctag(i, getcallerpc(&d));
@



\chapter{Error Managment}

\section{User side}

<<type Errorfn>>=
typedef void (*Errorfn)(Display*, char*);
@
%pad: I added that


% initdraw take an error parameter?

<<[[Display]] other fields>>=
Errorfn error;
@
%old: void	(*error)(Display*, char*);

% drawgetrect | readcolmap | writecolmap | ebread | ecanmouse | ...-> <>
<<function drawerror>>=
void
drawerror(Display *d, char *s)
{
    char err[ERRMAX];

    if(d && d->error)
        d->error(d, s);
    else{
        errstr(err, sizeof err);
        fprint(STDERR, "draw: %s: %s\n", s, err);
        exits(s); // extreme!
    }
}
@

% not so many calls to drawerror in libdraw/ actually.
% more use of werrstr and returning error code.

\section{Kernel side}

<<global Enodrawimage>>=
static  char Enodrawimage[] =   "unknown id for draw image";
@

<<global Enodrawscreen>>=
static  char Enodrawscreen[] =  "unknown id for draw screen";
@

<<global Eshortdraw>>=
static  char Eshortdraw[] = "short draw message";
@

<<global Eshortread>>=
static  char Eshortread[] = "draw read too short";
@

<<global Eimageexists>>=
static  char Eimageexists[] =   "image id in use";
@

<<global Escreenexists>>=
static  char Escreenexists[] =  "screen id in use";
@

<<global Edrawmem>>=
static  char Edrawmem[] =   "image memory allocation failed";
@

<<global Ereadoutside>>=
static  char Ereadoutside[] =   "readimage outside image";
@

<<global Ewriteoutside>>=
static  char Ewriteoutside[] =  "writeimage outside image";
@

<<global Enotfont>>=
static  char Enotfont[] =   "image not a font";
@

<<global Eindex>>=
static  char Eindex[] =     "character index out of range";
@

<<global Enoclient>>=
static  char Enoclient[] =  "no such draw client";
@

<<global Enameused>>=
static  char Enameused[] =  "image name in use";
@

%dead: //static    char Edepth[] =     "image has bad depth";

<<global Enoname>>=
static  char Enoname[] =    "no image with that name";
@

<<global Eoldname>>=
static  char Eoldname[] =   "named image no longer valid";
@

<<global Enamed>>=
static  char Enamed[] =     "image already has name";
@

<<global Ewrongname>>=
static  char Ewrongname[] =     "wrong name for image";
@






\chapter{Raspberry Framebuffer Driver}
% bcm2385 framebuffer and videocore GPU

% 1024 x 768 x 16 (and can do also x 32)
% but when in 32, does it mean GPU understand alpha channel?

% screen.c and vcore.c

\chapter{PC VGA driver TODO}

<<struct VGAscr(x86)>>=
struct VGAscr {

  ulong paddr;    /* frame buffer */
  void* vaddr;

  int   apsize;

  Memsubfont* memdefont;

  <<[[VGAscr]] cursor fields>>

  ulong colormap[Pcolours][3];
  int palettedepth;

  Pcidev* pci;
  ulong io;       /* device specific registers */
  ulong *mmio;

  ulong storage;
  bool useflush;

  ulong id; /* internal identifier for driver use */

  // the vga device methods
  VGAdev* dev;

  // why here? why not in VGAdev?
  <<[[VGAscr]] optional methods(x86)>>

  <<[[VGAscr]] other fields(x86)>>

  // Extra
  Lock  devlock;
};
@
%old: this used to have a gscreen and gscreendata fields, but
% there were just redundant with gscreen and gscreendata globals,
% so I removed those fields, which makes it also easier to move
% more generic stuff in screen.c


<<global vgascreen(x86)>>=
VGAscr vgascreen;
@
%set by screensize()? and probably via vgactl
%old: this used to be vgascreen[1], but I refactored to just vgascreen.
% I didn't find any vga driver having more than 1 VGAscr so not sure
% why it was like that. Once this was done, it didn't make sense to
% have the gscreen/gscreendata globals and vgascreen[0].gscreen
% and vgascreen[0].gscreendata so I removed those fields.


<<function VGAMEM(x86)>>=
#define VGAMEM()  0xA0000
@
% vgascreen.paddr?





<<[[VGAscr]] other fields(x86)>>=
int overlayinit;
@

%XXX move later
<<[[VGAscr]] optional methods(x86)>>=
int (*fill)(VGAscr*, Rectangle, ulong);
int (*scroll)(VGAscr*, Rectangle, Rectangle);
@





% !!!!!!!!!
<<function ishwimage(x86)>>=
bool
ishwimage(Memimage* i)
{
  return (i->data->bdata == gscreendata.bdata);
}
@
% could be just i == gscreen no?
%//#define ishwimage(i)  (vgascreen[0].gscreendata && (i)->data->bdata == vgascreen[0].gscreendata->bdata)




% see "adventure in graphic card" from BeOS people in src/vga/? meh

<<enum vgamisc(x86)>>=
  Pcolours  = 256,    /* Palette */

  Pred    = 0,
  Pgreen  = 1,
  Pblue   = 2,

  Pblack    = 0x00,
  Pwhite    = 0xFF,
};
@

<<enum _anon_ (kernel/devices/screen/386/screen.h)2>>=
enum {
  Backgnd   = 0,  /* black */
};
@


<<global vgadevtab(x86)>>=
Dev vgadevtab = {
    .dc       =    'v',
    .name     =    "vga",
               
    .attach   =    vgaattach,
    .walk     =    vgawalk,

    .open     =    vgaopen,
    .close    =    vgaclose,
    .read     =    vgaread,
    .write    =    vgawrite,
    .stat     =    vgastat,

    .reset    =    vgareset,

    // generic
    .create   =    devcreate,
    .remove   =    devremove,
    .wstat    =    devwstat,
    .bread    =    devbread,
    .bwrite   =    devbwrite,
    .init     =    devinit,
    .shutdown =    devshutdown,
};
@
% put the devtab? where have the cirrus logic there?

\section{IO ports}

<<enum vgaports(x86)>>=
/*
 * Generic VGA registers.
 */
enum {
  MiscW   = 0x03C2, /* Miscellaneous Output (W) */
  MiscR   = 0x03CC, /* Miscellaneous Output (R) */
  Status0   = 0x03C2, /* Input status 0 (R) */
  Status1   = 0x03DA, /* Input Status 1 (R) */
  FeatureR  = 0x03CA, /* Feature Control (R) */
  FeatureW  = 0x03DA, /* Feature Control (W) */

  Seqx    = 0x03C4, /* Sequencer Index, Data at Seqx+1 */
  Crtx    = 0x03D4, /* CRT Controller Index, Data at Crtx+1 */
  Grx   = 0x03CE, /* Graphics Controller Index, Data at Grx+1 */
  Attrx   = 0x03C0, /* Attribute Controller Index and Data */

  PaddrW    = 0x03C8, /* Palette Address Register, write */
  Pdata     = 0x03C9, /* Palette Data Register */
  Pixmask   = 0x03C6, /* Pixel Mask Register */
  PaddrR    = 0x03C7, /* Palette Address Register, read */
  Pstatus   = 0x03C7, /* DAC Status (RO) */
@

<<function vgao(x86)>>=
#define vgao(port, data)  outb(port, data)
@


<<global vgaxlock(x86)>>=
static Lock vgaxlock;           /* access to index registers */
@

<<function vgaxi(x86)>>=
int
vgaxi(long port, uchar index)
{
    uchar data;

    ilock(&vgaxlock);
    switch(port){

    case Seqx:
    case Crtx:
    case Grx:
        outb(port, index);
        data = inb(port+1);
        break;

    case Attrx:
        /*
         * Allow processor access to the colour
         * palette registers. Writes to Attrx must
         * be preceded by a read from Status1 to
         * initialise the register to point to the
         * index register and not the data register.
         * Processor access is allowed by turning
         * off bit 0x20.
         */
        inb(Status1);
        if(index < 0x10){
            outb(Attrx, index);
            data = inb(Attrx+1);
            inb(Status1);
            outb(Attrx, 0x20|index);
        }
        else{
            outb(Attrx, 0x20|index);
            data = inb(Attrx+1);
        }
        break;

    default:
        iunlock(&vgaxlock);
        return -1;
    }
    iunlock(&vgaxlock);

    return data & 0xFF;
}
@

<<function vgaxo(x86)>>=
int
vgaxo(long port, uchar index, uchar data)
{
    ilock(&vgaxlock);
    switch(port){

    case Seqx:
    case Crtx:
    case Grx:
        /*
         * We could use an outport here, but some chips
         * (e.g. 86C928) have trouble with that for some
         * registers.
         */
        outb(port, index);
        outb(port+1, data);
        break;

    case Attrx:
        inb(Status1);
        if(index < 0x10){
            outb(Attrx, index);
            outb(Attrx, data);
            inb(Status1);
            outb(Attrx, 0x20|index);
        }
        else{
            outb(Attrx, 0x20|index);
            outb(Attrx, data);
        }
        break;

    default:
        iunlock(&vgaxlock);
        return -1;
    }
    iunlock(&vgaxlock);

    return 0;
}
@


\section{[[VGAdev]]}

<<struct VGAdev(x86)>>=
struct VGAdev {
  char* name;

  void  (*enable)(VGAscr*);
  void  (*disable)(VGAscr*);

  void  (*page)(VGAscr*, int);
  void  (*linear)(VGAscr*, int, int);
 
  // optional
  void  (*drawinit)(VGAscr*);
  int   (*fill)(VGAscr*, Rectangle, ulong);

  void  (*ovlctl)(VGAscr*, Chan*, void*, int);
  int   (*ovlwrite)(VGAscr*, void*, int, vlong);

  void  (*flush)(VGAscr*, Rectangle);
};
@

% linear? apparently can't use soft cursor with non-linear VGA, but
% I don't know what it means ...

\section{[[/dev/vgaxxx]]}

<<enum _anon_ (kernel/devices/screen/386/devvga.c)>>=
enum {
    Qdir,

    Qvgabios,
    Qvgactl,

    Qvgaovl,
    Qvgaovlctl,
};
@

<<global vgadir(x86)>>=
static Dirtab vgadir[] = {
    ".",    { Qdir, 0, QTDIR },     0,  0550,
    "vgabios",  { Qvgabios, 0 },    0x100000, 0440,
    "vgactl",       { Qvgactl, 0 },     0,  0660,
    "vgaovl",       { Qvgaovl, 0 },     0,  0660,
    "vgaovlctl",    { Qvgaovlctl, 0 },  0,  0660,
};
@

<<enum _anon_ (kernel/devices/screen/386/devvga.c)2>>=
enum {
    CMactualsize,
    CMblank,
    CMblanktime,
    CMdrawinit,
    CMhwaccel,
    CMhwblank,
    CMhwgc,
    CMlinear,
    CMpalettedepth,
    CMpanning,
    CMsize,
    CMtextmode,
    CMtype,
    CMunblank,
};
@

<<global vgactlmsg(x86)>>=
static Cmdtab vgactlmsg[] = {
    CMactualsize,   "actualsize",   2,
    CMblank,    "blank",    1,
    CMblanktime,    "blanktime",    2,
    CMdrawinit, "drawinit", 1,
    CMhwaccel,  "hwaccel",  2,
    CMhwblank,  "hwblank",  2,
    CMhwgc,     "hwgc",     2,
    CMlinear,   "linear",   0,
    CMpalettedepth, "palettedepth", 2,
    CMpanning,  "panning",  2,
    CMsize,     "size",     3,
    CMtextmode, "textmode", 1,
    CMtype,     "type",     2,
    CMunblank,  "unblank",  1,
};
@

<<function vgareset(x86)>>=
static void
vgareset(void)
{
    /* reserve the 'standard' vga registers */
    if(ioalloc(0x2b0, 0x2df-0x2b0+1, 0, "vga") < 0)
        panic("vga ports already allocated"); 
    if(ioalloc(0x3c0, 0x3da-0x3c0+1, 0, "vga") < 0)
        panic("vga ports already allocated"); 
}
@

<<function vgaattach(x86)>>=
static Chan*
vgaattach(char* spec)
{
    if(*spec && strcmp(spec, "0"))
        error(Eio);
    return devattach('v', spec);
}
@

<<function vgawalk(x86)>>=
Walkqid*
vgawalk(Chan* c, Chan *nc, char** name, int nname)
{
    return devwalk(c, nc, name, nname, vgadir, nelem(vgadir), devgen);
}
@

<<function vgastat(x86)>>=
static int
vgastat(Chan* c, uchar* dp, int n)
{
    return devstat(c, dp, n, vgadir, nelem(vgadir), devgen);
}
@

<<function vgaopen(x86)>>=
static Chan*
vgaopen(Chan* c, int omode)
{
    VGAscr *scr;
    static char *openctl = "openctl\n";

    scr = &vgascreen;
    if ((ulong)c->qid.path == Qvgaovlctl) {
        if (scr->dev && scr->dev->ovlctl)
            scr->dev->ovlctl(scr, c, openctl, strlen(openctl));
        else 
            error(Enonexist);
    }
    return devopen(c, omode, vgadir, nelem(vgadir), devgen);
}
@

<<function vgaclose(x86)>>=
static void
vgaclose(Chan* c)
{
    VGAscr *scr;
    static char *closectl = "closectl\n";

    scr = &vgascreen;
    if((ulong)c->qid.path == Qvgaovlctl)
        if(scr->dev && scr->dev->ovlctl){
            if(waserror()){
                print("ovlctl error: %s\n", up->errstr);
                return;
            }
            scr->dev->ovlctl(scr, c, closectl, strlen(closectl));
            poperror();
        }
}
@

<<[[screensize()]] initializations part2>>=
physgscreenr = gscreen->r;
@

<<global physgscreenr>>=
Rectangle physgscreenr;
@
% gscreen->r at init time, later can be different

%XXX LP split
<<function vgaread(x86)>>=
static long
vgaread(Chan* c, void* a, long n, vlong off)
{
    int len;
    char *p, *s;
    VGAscr *scr;
    ulong offset = off;
    char chbuf[30];

    switch((ulong)c->qid.path){

    case Qdir:
        return devdirread(c, a, n, vgadir, nelem(vgadir), devgen);

    case Qvgabios:
        if(offset >= 0x100000)
            return 0;
        if(offset+n >= 0x100000)
            n = 0x100000 - offset;
        memmove(a, (uchar*)kaddr(0)+offset, n);
        return n;

    case Qvgactl:
        scr = &vgascreen;

        p = malloc(READSTR);
        if(p == nil)
            error(Enomem);
        if(waserror()){
            free(p);
            nexterror();
        }

        len = 0;

        if(scr->dev)
            s = scr->dev->name;
        else
            s = "cga";
        len += snprint(p+len, READSTR-len, "type %s\n", s);

        if(gscreen) {
            len += snprint(p+len, READSTR-len, "size %dx%dx%d %s\n",
                gscreen->r.max.x, gscreen->r.max.y,
                gscreen->depth, chantostr(chbuf, gscreen->chan));

            if(Dx(gscreen->r) != Dx(physgscreenr) 
            || Dy(gscreen->r) != Dy(physgscreenr))
                len += snprint(p+len, READSTR-len, "actualsize %dx%d\n",
                    physgscreenr.max.x, physgscreenr.max.y);
        }

        len += snprint(p+len, READSTR-len, "blank time %lud idle %d state %s\n",
            blanktime, drawidletime(), scr->isblank ? "off" : "on");
        len += snprint(p+len, READSTR-len, "hwaccel %s\n", hwaccel ? "on" : "off");
        len += snprint(p+len, READSTR-len, "hwblank %s\n", hwblank ? "on" : "off");
        len += snprint(p+len, READSTR-len, "panning %s\n", panning ? "on" : "off");
        len += snprint(p+len, READSTR-len, "addr p 0x%lux v 0x%p size 0x%ux\n", scr->paddr, scr->vaddr, scr->apsize);
        USED(len);

        n = readstr(offset, a, n, p);
        poperror();
        free(p);

        return n;

    case Qvgaovl:
    case Qvgaovlctl:
        error(Ebadusefd);
        break;

    default:
        error(Egreg);
        break;
    }

    return 0;
}
@

%//static char Ebusy[] = "vga already configured";

<<function vgactl(x86)>>=
static void
vgactl(Cmdbuf *cb)
{
    int align, i, size, x, y, z;
    char *chanstr, *p;
    ulong chan;
    Cmdtab *ct;
    VGAscr *scr;
    extern VGAdev *vgadev[];
    extern VGAcur *vgacur[];

    scr = &vgascreen;
    ct = lookupcmd(cb, vgactlmsg, nelem(vgactlmsg));
    switch(ct->index){
    <<[[vgactl]] cases(x86)>>
    }

    cmderror(cb, "bad VGA control message");
}
@


<<[[vgactl]] cases(x86)>>=
case CMhwgc:
    if(strcmp(cb->f[1], "off") == 0){
        lock(&cursor);
        if(scr->cur){
            if(scr->cur->disable)
                scr->cur->disable(scr);
            scr->cur = nil;
        }
        unlock(&cursor);
        return;
    }
    if(strcmp(cb->f[1], "soft") == 0){
        lock(&cursor);
        swcursorinit();
        if(scr->cur && scr->cur->disable)
            scr->cur->disable(scr);
        scr->cur = &swcursor;
        if(scr->cur->enable)
            scr->cur->enable(scr);
        unlock(&cursor);
        return;
    }
    for(i = 0; vgacur[i]; i++){
        if(strcmp(cb->f[1], vgacur[i]->name))
            continue;
        lock(&cursor);
        if(scr->cur && scr->cur->disable)
            scr->cur->disable(scr);
        scr->cur = vgacur[i];
        if(scr->cur->enable)
            scr->cur->enable(scr);
        unlock(&cursor);
        return;
    }
    break;
@
<<[[vgactl]] cases(x86)>>=
case CMtype:
    for(i = 0; vgadev[i]; i++){
        if(strcmp(cb->f[1], vgadev[i]->name))
            continue;
        if(scr->dev && scr->dev->disable)
            scr->dev->disable(scr);
        scr->dev = vgadev[i];
        if(scr->dev->enable)
            scr->dev->enable(scr);
        return;
    }
    break;
@


<<[[vgactl]] cases(x86)>>=
case CMsize:
    x = strtoul(cb->f[1], &p, 0);
    if(x == 0 || x > 10240)
        error(Ebadarg);
    if(*p)
        p++;

    y = strtoul(p, &p, 0);
    if(y == 0 || y > 10240)
        error(Ebadarg);
    if(*p)
        p++;

    z = strtoul(p, &p, 0);

    chanstr = cb->f[2];
    if((chan = strtochan(chanstr)) == 0)
        error("bad channel");

    if(chantodepth(chan) != z)
        error("depth, channel do not match");

    cursoroff(1);
    deletescreenimage();
    if(screensize(x, y, z, chan))
        error(Egreg);
    vgascreenwin(scr);
    resetscreenimage();
    cursoron(1);
    return;
@

<<function resetscreenimage>>=
void
resetscreenimage(void)
{
    dlock();
    initscreenimage();
    dunlock();
}
@



<<function deletescreenimage>>=
void
deletescreenimage(void)
{
    dlock();
    if(screenimage){
        /* will be freed via screendimage; disable */
        screenimage->clipr = ZR;
        screenimage = nil;
    }
    if(screendimage){
        drawfreedimage(screendimage);
        screendimage = nil;
    }
    dunlock();
}
@



<<[[vgactl]] cases(x86)>>=
case CMactualsize:
    if(gscreen == nil)
        error("set the screen size first");

    x = strtoul(cb->f[1], &p, 0);
    if(x == 0 || x > 2048)
        error(Ebadarg);
    if(*p)
        p++;

    y = strtoul(p, nil, 0);
    if(y == 0 || y > 2048)
        error(Ebadarg);

    if(x > gscreen->r.max.x || y > gscreen->r.max.y)
        error("physical screen bigger than virtual");

    physgscreenr = Rect(0,0,x,y);
    gscreen->clipr = physgscreenr;
    return;
@
<<[[vgactl]] cases(x86)>>=
case CMpalettedepth:
    x = strtoul(cb->f[1], &p, 0);
    if(x != 8 && x != 6)
        error(Ebadarg);

    scr->palettedepth = x;
    return;
@
<<[[vgactl]] cases(x86)>>=
case CMdrawinit:
    if(gscreen == nil)
        error("drawinit: no gscreen");
    if(scr->dev && scr->dev->drawinit)
        scr->dev->drawinit(scr);
    return;
@



<<[[vgactl]] cases(x86)>>=
case CMlinear:
    if(cb->nf!=2 && cb->nf!=3)
        error(Ebadarg);
    size = strtoul(cb->f[1], 0, 0);
    if(cb->nf == 2)
        align = 0;
    else
        align = strtoul(cb->f[2], 0, 0);
    if(screenaperture(size, align) < 0)
        error("not enough free address space");
    return;
@

% vgactl linear -> <>
<<function screenaperture(x86)>>=
int
screenaperture(int size, int align)
{
    VGAscr *scr;

    scr = &vgascreen;

    if(scr->paddr)  /* set up during enable */
        return 0;

    if(size == 0)
        return 0;

    if(scr->dev && scr->dev->linear){
        scr->dev->linear(scr, size, align);
        return 0;
    }

    /*
     * Need to allocate some physical address space.
     * The driver will tell the card to use it.
     */
    size = PGROUND(size);
    scr->paddr = upaalloc(size, align);
    if(scr->paddr == 0)
        return -1;
    scr->vaddr = vmap(scr->paddr, size);
    if(scr->vaddr == nil)
        return -1;
    scr->apsize = size;

    return 0;
}
@



%/*  
%case CMmemset:
%    memset((void*)strtoul(cb->f[1], 0, 0), atoi(cb->f[2]), atoi(cb->f[3]));
%    return;
%*/


<<global panning(x86)>>=
bool panning = false;
@
% try? 

<<[[vgactl]] cases(x86)>>=
case CMpanning:
    if(strcmp(cb->f[1], "on") == 0){
        if(scr == nil || scr->cur == nil)
            error("set screen first");
        if(!scr->cur->doespanning)
            error("panning not supported");
        gscreen->clipr = gscreen->r;
        panning = true;
    }
    else if(strcmp(cb->f[1], "off") == 0){
        gscreen->clipr = physgscreenr;
        panning = false;
    }else
        break;
    return;
@


<<[[vgactl]] cases(x86)>>=
case CMhwaccel:
    if(strcmp(cb->f[1], "on") == 0)
        hwaccel = 1;
    else if(strcmp(cb->f[1], "off") == 0)
        hwaccel = 0;
    else
        break;
    return;
@


<<[[vgactl]] cases(x86)>>=
case CMtextmode:
    screeninit();
    return;
@
% screeninit() is in kernel.nw, and essentially does
% screenputs = cgascreenputs;





<<global Enooverlay(x86)>>=
char Enooverlay[] = "No overlay support";
@

<<function vgawrite(x86)>>=
static long
vgawrite(Chan* c, void* a, long n, vlong off)
{
    ulong offset = off;
    Cmdbuf *cb;
    VGAscr *scr;

    switch((ulong)c->qid.path){

    case Qdir:
        error(Eperm);

    case Qvgactl:
        if(offset || n >= READSTR)
            error(Ebadarg);
        cb = parsecmd(a, n);
        if(waserror()){
            free(cb);
            nexterror();
        }
        vgactl(cb);
        poperror();
        free(cb);
        return n;

    case Qvgaovl:
        scr = &vgascreen;
        if (scr->dev == nil || scr->dev->ovlwrite == nil) {
            error(Enooverlay);
            break;
        }
        return scr->dev->ovlwrite(scr, a, n, off);

    case Qvgaovlctl:
        scr = &vgascreen;
        if (scr->dev == nil || scr->dev->ovlctl == nil) {
            error(Enooverlay);
            break;
        }
        scr->dev->ovlctl(scr, c, a, n);
        return n;

    default:
        error(Egreg);
        break;
    }

    return 0;
}
@


\section{VGA linear addressing}

% used?

<<function vgalinearpciid(x86)>>=
void
vgalinearpciid(VGAscr *scr, int vid, int did)
{
    Pcidev *p;

    p = nil;
    while((p = pcimatch(p, vid, 0)) != nil){
        if(p->ccrb != 3)    /* video card */
            continue;
        if(did != 0 && p->did != did)
            continue;
        break;
    }
    if(p == nil)
        error("pci video card not found");

    scr->pci = p;
    vgalinearpci(scr);
}
@

% vgalinearpciid -> <>
<<function vgalinearpci(x86)>>=
void
vgalinearpci(VGAscr *scr)
{
    ulong paddr;
    int i, size, best;
    Pcidev *p;
    
    p = scr->pci;
    if(p == nil)
        return;

    /*
     * Scan for largest memory region on card.
     * Some S3 cards (e.g. Savage) have enormous
     * mmio regions (but even larger frame buffers).
     * Some 3dfx cards (e.g., Voodoo3) have mmio
     * buffers the same size as the frame buffer,
     * but only the frame buffer is marked as
     * prefetchable (bar&8).  If a card doesn't fit
     * into these heuristics, its driver will have to
     * call vgalinearaddr directly.
     */
    best = -1;
    for(i=0; i<nelem(p->mem); i++){
        if(p->mem[i].bar&1) /* not memory */
            continue;
        if(p->mem[i].size < 640*480)    /* not big enough */
            continue;
        if(best==-1 
        || p->mem[i].size > p->mem[best].size 
        || (p->mem[i].size == p->mem[best].size 
          && (p->mem[i].bar&8)
          && !(p->mem[best].bar&8)))
            best = i;
    }
    if(best >= 0){
        paddr = p->mem[best].bar & ~0x0F;
        size = p->mem[best].size;
        vgalinearaddr(scr, paddr, size);
        return;
    }
    error("no video memory found on pci card");
}
@


% vgalinearpci | vesalinear -> <>
<<function vgalinearaddr(x86)>>=
void
vgalinearaddr(VGAscr *scr, ulong paddr, int size)
{
    int x, nsize;
    ulong npaddr;

    /*
     * new approach.  instead of trying to resize this
     * later, let's assume that we can just allocate the
     * entire window to start with.
     */

    if(scr->paddr == paddr && size <= scr->apsize)
        return;

    if(scr->paddr){
        /*
         * could call vunmap and vmap,
         * but worried about dangling pointers in devdraw
         */
        error("cannot grow vga frame buffer");
    }
    
    /* round to page boundary, just in case */
    x = paddr&(BY2PG-1);
    npaddr = paddr-x;
    nsize = PGROUND(size+x);

    /*
     * Don't bother trying to map more than 4000x4000x32 = 64MB.
     * We only have a 256MB window.
     */
    if(nsize > 64*MB)
        nsize = 64*MB;
    scr->vaddr = vmap(npaddr, nsize);
    if(scr->vaddr == 0)
        error("cannot allocate vga frame buffer");
    scr->vaddr = (char*)scr->vaddr+x;
    scr->paddr = paddr;
    scr->apsize = nsize;
    /* let mtrr harmlessly fail on old CPUs, e.g., P54C */
    if(!waserror()){
        //mtrr(npaddr, nsize, "wc"); disabled mtrr
                error("mtrr disabled");
        poperror();
    }
}
@

\section{VGA page}

<<[[screensize()]] when use softscreen, other settings>>=
if(scr->dev && scr->dev->page){
    scr->vaddr = KADDR(VGAMEM());
    scr->apsize = 1<<16;
}
@
% >>

<<[[flushmemscreen()]] other locals>>=
byte *sp, *disp, *sdisp, *edisp;
int y, len, incs, off, page;
@

<<[[flushmemscreen()]] use VGA page>>=
incs = gscreen->width * BY2WD;

switch(gscreen->depth){
case 8:
    len = Dx(r);
    break;
default:
    len = 0;
    panic("flushmemscreen: depth\n");
    break;
}
if(len < 1)
    return;

off = r.min.y * gscreen->width * BY2WD 
       + (r.min.x * gscreen->depth)/8;
page = off/scr->apsize;
off %= scr->apsize;
disp = scr->vaddr;
sdisp = disp+off;
edisp = disp+scr->apsize;

off = r.min.y * gscreen->width * BY2WD
       + (r.min.x * gscreen->depth)/8;

sp = gscreendata.bdata + off;

// call device driver again, for subpart
scr->dev->page(scr, page);

for(y = r.min.y; y < r.max.y; y++) {
    if(sdisp + incs < edisp) {
        memmove(sdisp, sp, len);
        sp += incs;
        sdisp += incs;
    }
    else {
        off = edisp - sdisp;
        page++;
        if(off <= len){
            if(off > 0)
                memmove(sdisp, sp, off);

            // call device driver again, for subpart
            scr->dev->page(scr, page);
            if(len - off > 0)
                memmove(disp, sp+off, len - off);
        }
        else {
            memmove(sdisp, sp, len);
            // call device driver again, for subpart
            scr->dev->page(scr, page);
        }
        sp += incs;
        sdisp += incs - scr->apsize;
    }
}
@

\section{VESA}

% see more in Graphics_extra

<<global vgavesadev(x86)>>=
VGAdev vgavesadev = {
    "vesa",
    0,
    0,
    0,
    vesalinear,
    0,
    0,
    0,
    0,
    vesaflush,
};
@


<<function vesalinear(x86)>>=
static void
vesalinear(VGAscr *scr, int, int)
{
    int i, mode, size, havesize;
    uchar *p;
    ulong paddr;
    Pcidev *pci;

    if(hardscreen) {
        scr->vaddr = 0;
        scr->paddr = scr->apsize = 0;
        return;
    }

    vbecheck();
    mode = vbegetmode();
    /*
     * bochs loses the top bits - cannot use this
    if((mode&(1<<14)) == 0)
        error("not in linear graphics mode");
     */
    mode &= 0x3FFF;
    p = vbemodeinfo(mode);
    if(!(WORD(p+0) & (1<<4)))
        error("not in VESA graphics mode");
    if(!(WORD(p+0) & (1<<7)))
        error("not in linear graphics mode");

    paddr = LONG(p+40);
    size = WORD(p+20)*WORD(p+16);
    size = PGROUND(size);

    /*
     * figure out max size of memory so that we have
     * enough if the screen is resized.
     */
    pci = nil;
    havesize = 0;
    while(!havesize && (pci = pcimatch(pci, 0, 0)) != nil){
        if(pci->ccrb != Pcibcdisp)
            continue;
        for(i=0; i<nelem(pci->mem); i++)
            if(paddr == (pci->mem[i].bar&~0x0F)){
                if(pci->mem[i].size > size)
                    size = pci->mem[i].size;
                havesize = 1;
                break;
            }
    }

    /* no pci - heuristic guess */
    if (!havesize)
        if(size < 4*1024*1024)
            size = 4*1024*1024;
        else
            size = ROUND(size, 1024*1024);
    if(size > 16*1024*1024)     /* arbitrary */
        size = 16*1024*1024;

    vgalinearaddr(scr, paddr, size);
    if(scr->apsize)
        addvgaseg("vesascreen", scr->paddr, scr->apsize);

    if(Usesoftscreen){
        hardscreen = scr->vaddr;
        scr->vaddr = 0;
        scr->paddr = scr->apsize = 0;
    }
}
@
% >> >> >>


\section{Cirrus logic 5446}

% A classic car, I even got it I think :)

<<global vgaclgd542xdev(x86)>>=
VGAdev vgaclgd542xdev = {
    .name = "clgd542x",

    .enable = nil,
    .disable = nil,
    .page = clgd542xpage,
    .linear = clgd542xlinear,
};
@



\subsection{Linear mode}

<<function clgd542xlinear(x86)>>=
static void
clgd542xlinear(VGAscr* scr, int, int)
{
    vgalinearpciid(scr, 0x1013, 0);
}
@


\subsection{Page}

<<function clgd542xpage(x86)>>=
static void
clgd542xpage(VGAscr* scr, int page)
{
    lock(&scr->devlock);
    clgd542xpageset(scr, page);
    unlock(&scr->devlock);
}
@

<<function clgd542xpageset(x86)>>=
static int
clgd542xpageset(VGAscr*, int page)
{
    uchar gr09;
    int opage;
    
    if(vgaxi(Seqx, 0x07) & 0xF0)
        page = 0;
    gr09 = vgaxi(Grx, 0x09);
    if(vgaxi(Grx, 0x0B) & 0x20){
        vgaxo(Grx, 0x09, page<<2);
        opage = gr09>>2;
    }
    else{
        vgaxo(Grx, 0x09, page<<4);
        opage = gr09>>4;
    }

    return opage;
}
@



\subsection{Cursor}

<<global vgaclgd542xcur(x86)>>=
VGAcur vgaclgd542xcur = {
    .name = "clgd542xhwgc",

    .enable = clgd542xenable,
    .disable = clgd542xdisable,
    .load = clgd542xload,
    .move = clgd542xmove,
};
@


<<function clgd542xenable(x86)>>=
static void
clgd542xenable(VGAscr* scr)
{
    uchar sr12;
    int mem, x;
 
    /*
     * Disable the cursor.
     */
    sr12 = vgaxi(Seqx, 0x12);
    vgaxo(Seqx, 0x12, sr12 & ~0x01);

    /*
     * Cursor colours.
     * Can't call setcolor here as cursor is already locked.
     */
    vgaxo(Seqx, 0x12, sr12|0x02);
    vgao(PaddrW, 0x00);
    vgao(Pdata, Pwhite);
    vgao(Pdata, Pwhite);
    vgao(Pdata, Pwhite);
    vgao(PaddrW, 0x0F);
    vgao(Pdata, Pblack);
    vgao(Pdata, Pblack);
    vgao(Pdata, Pblack);
    vgaxo(Seqx, 0x12, sr12);

    mem = 0;
    switch(vgaxi(Crtx, 0x27) & ~0x03){

    case 0x88:              /* CL-GD5420 */
    case 0x8C:              /* CL-GD5422 */
    case 0x94:              /* CL-GD5424 */
    case 0x80:              /* CL-GD5425 */
    case 0x90:              /* CL-GD5426 */
    case 0x98:              /* CL-GD5427 */
    case 0x9C:              /* CL-GD5429 */
        /*
         * The BIOS leaves the memory size in Seq0A, bits 4 and 3.
         * See Technical Reference Manual Appendix E1, Section 1.3.2.
         *
         * The storage area for the 64x64 cursors is the last 16Kb of
         * display memory.
         */
        mem = (vgaxi(Seqx, 0x0A)>>3) & 0x03;
        break;

    case 0xA0:              /* CL-GD5430 */
    case 0xA8:              /* CL-GD5434 */
    case 0xAC:              /* CL-GD5436 */
    case 0xB8:              /* CL-GD5446 */
    case 0x30:              /* CL-GD7543 */
        /*
         * Attempt to intuit the memory size from the DRAM control
         * register. Minimum is 512KB.
         * If DRAM bank switching is on then there's double.
         */
        x = vgaxi(Seqx, 0x0F);
        mem = (x>>3) & 0x03;
        if(x & 0x80)
            mem++;
        break;

    case 0xBC:              /* CL-GD5480 */
        mem = 2;            /* 1024 = 256<<2 */
        x = vgaxi(Seqx, 0x0F);
        if((x & 0x18) == 0x18){
            mem <<= 1;      /* 2048 = 256<<3 */
            if(x & 0x80)
                mem <<= 2;  /* 2048 = 256<<4 */
        }
        if(vgaxi(Seqx, 0x17) & 0x80)
            mem <<= 1;
        break;

    default:                /* uh, ah dunno */
        break;
    }
    scr->storage = ((256<<mem)-16)*1024;

    /*
     * Set the current cursor to index 0
     * and turn the 64x64 cursor on.
     */
    vgaxo(Seqx, 0x13, 0);
    vgaxo(Seqx, 0x12, sr12|0x05);
}
@
% >> >> >> >> >> >> >>


<<function clgd542xdisable(x86)>>=
static void
clgd542xdisable(VGAscr*)
{
    uchar sr12;

    sr12 = vgaxi(Seqx, 0x12);
    vgaxo(Seqx, 0x12, sr12 & ~0x01);
}
@


% xxxload | xxxmove -> <>
<<function clgd542xinitcursor(x86)>>=
static void
clgd542xinitcursor(VGAscr* scr, int xo, int yo, int index)
{
    uchar *p, seq07;
    uint p0, p1;
    int opage, x, y;

    /*
     * Is linear addressing turned on? This will determine
     * how we access the cursor storage.
     */
    seq07 = vgaxi(Seqx, 0x07);
    opage = 0;
    p = scr->vaddr;
    if(!(seq07 & 0xF0)){
        lock(&scr->devlock);
        opage = clgd542xpageset(scr, scr->storage>>16);
        p += (scr->storage & 0xFFFF);
    }
    else
        p += scr->storage;
    p += index*1024;

    for(y = yo; y < 16; y++){
        p0 = scr->set[2*y];
        p1 = scr->set[2*y+1];
        if(xo){
            p0 = (p0<<xo)|(p1>>(8-xo));
            p1 <<= xo;
        }
        *p++ = p0;
        *p++ = p1;

        for(x = 16; x < 64; x += 8)
            *p++ = 0x00;

        p0 = scr->clr[2*y]|scr->set[2*y];
        p1 = scr->clr[2*y+1]|scr->set[2*y+1];
        if(xo){
            p0 = (p0<<xo)|(p1>>(8-xo));
            p1 <<= xo;
        }
        *p++ = p0;
        *p++ = p1;

        for(x = 16; x < 64; x += 8)
            *p++ = 0x00;
    }
    while(y < 64+yo){
        for(x = 0; x < 64; x += 8){
            *p++ = 0x00;
            *p++ = 0x00;
        }
        y++;
    }

    if(!(seq07 & 0xF0)){
        clgd542xpageset(scr, opage);
        unlock(&scr->devlock);
    }
}
@


<<function clgd542xmove(x86)>>=
static int
clgd542xmove(VGAscr* scr, Point p)
{
    int index, x, xo, y, yo;

    index = 0;
    if((x = p.x+scr->offset.x) < 0){
        xo = -x;
        x = 0;
    }
    else
        xo = 0;
    if((y = p.y+scr->offset.y) < 0){
        yo = -y;
        y = 0;
    }
    else
        yo = 0;

    if(xo || yo){
        clgd542xinitcursor(scr, xo, yo, 1);
        index = 1;
    }
    vgaxo(Seqx, 0x13, index<<2);
    
    vgaxo(Seqx, 0x10|((x & 0x07)<<5), (x>>3) & 0xFF);
    vgaxo(Seqx, 0x11|((y & 0x07)<<5), (y>>3) & 0xFF);

    return 0;
}
@


<<function clgd542xload(x86)>>=
static void
clgd542xload(VGAscr* scr, Cursor* curs)
{
    uchar sr12;

    /*
     * Disable the cursor.
     */
    sr12 = vgaxi(Seqx, 0x12);
    vgaxo(Seqx, 0x12, sr12 & ~0x01);

    memmove(&scr->Cursor, curs, sizeof(Cursor));
    clgd542xinitcursor(scr, 0, 0, 0);

    /*
     * Enable the cursor.
     */
    vgaxo(Seqx, 0x13, 0);
    vgaxo(Seqx, 0x12, sr12|0x05);
}
@




\chapter{Mathematics}

\section{Trigonometric functions}

% float is expensive, so instead represent float in integer approximation.
% 0.0 = 0 degree, 1.0 = 1024

<<global sinus>>=
/*
 * Integer sine and cosine for integral degree argument.
 * Tables computed by (sin,cos)(PI*d/180).
 */
static short sinus[91] = {
    0,	/* 0 */
    18,	/* 1 */
    36,	/* 2 */
    54,	/* 3 */
    71,	/* 4 */
    89,	/* 5 */
    107,	/* 6 */
    125,	/* 7 */
    143,	/* 8 */
    160,	/* 9 */
    178,	/* 10 */
    195,	/* 11 */
    213,	/* 12 */
    230,	/* 13 */
    248,	/* 14 */
    265,	/* 15 */
    282,	/* 16 */
    299,	/* 17 */
    316,	/* 18 */
    333,	/* 19 */
    350,	/* 20 */
    367,	/* 21 */
    384,	/* 22 */
    400,	/* 23 */
    416,	/* 24 */
    433,	/* 25 */
    449,	/* 26 */
    465,	/* 27 */
    481,	/* 28 */
    496,	/* 29 */
    512,	/* 30 */
    527,	/* 31 */
    543,	/* 32 */
    558,	/* 33 */
    573,	/* 34 */
    587,	/* 35 */
    602,	/* 36 */
    616,	/* 37 */
    630,	/* 38 */
    644,	/* 39 */
    658,	/* 40 */
    672,	/* 41 */
    685,	/* 42 */
    698,	/* 43 */
    711,	/* 44 */
    724,	/* 45 */
    737,	/* 46 */
    749,	/* 47 */
    761,	/* 48 */
    773,	/* 49 */
    784,	/* 50 */
    796,	/* 51 */
    807,	/* 52 */
    818,	/* 53 */
    828,	/* 54 */
    839,	/* 55 */
    849,	/* 56 */
    859,	/* 57 */
    868,	/* 58 */
    878,	/* 59 */
    887,	/* 60 */
    896,	/* 61 */
    904,	/* 62 */
    912,	/* 63 */
    920,	/* 64 */
    928,	/* 65 */
    935,	/* 66 */
    943,	/* 67 */
    949,	/* 68 */
    956,	/* 69 */
    962,	/* 70 */
    968,	/* 71 */
    974,	/* 72 */
    979,	/* 73 */
    984,	/* 74 */
    989,	/* 75 */
    994,	/* 76 */
    998,	/* 77 */
    1002,	/* 78 */
    1005,	/* 79 */
    1008,	/* 80 */
    1011,	/* 81 */
    1014,	/* 82 */
    1016,	/* 83 */
    1018,	/* 84 */
    1020,	/* 85 */
    1022,	/* 86 */
    1023,	/* 87 */
    1023,	/* 88 */
    1024,	/* 89 */
    1024,	/* 90 */
};
@

<<function icossin>>=
void
icossin(int deg, int *cosp, int *sinp)
{
    int sinsign, cossign;
    short *stp, *ctp;

    deg %= 360;
    if(deg < 0)
        deg += 360;
    sinsign = 1;
    cossign = 1;
    stp = 0;
    ctp = 0;
    switch(deg/90){
    case 2:
        sinsign = -1;
        cossign = -1;
        deg -= 180;
        /* fall through */
    case 0:
        stp = &sinus[deg];
        ctp = &sinus[90-deg];
        break;
    case 3:
        sinsign = -1;
        cossign = -1;
        deg -= 180;
        /* fall through */
    case 1:
        deg = 180-deg;
        cossign = -cossign;
        stp = &sinus[deg];
        ctp = &sinus[90-deg];
        break;
    }
    *sinp = sinsign*stp[0];
    *cosp = cossign*ctp[0];
}
@



<<global sinus (lib_graphics/libdraw/icossin2.c)>>=
/*
 * Sine and Cosine of arctangents, calculated by 
 *   (sin(atan(index/100.0))*1024.+0.5)
 *   (cos(atan(index/100.0))*1024.+0.5)
 * To use, get rational tangent between 0<=tan<=1, scale by 100,
 * and look up sin and cos, and use linear interpolation.  divide by 1024.
 * Maximum error is 0.0020.  Without linear interpolation, it's 0.010.
 */
static
short sinus[] = {
    0,	/* 0.00 */
    10,	/* 0.01 */
    20,	/* 0.02 */
    31,	/* 0.03 */
    41,	/* 0.04 */
    51,	/* 0.05 */
    61,	/* 0.06 */
    72,	/* 0.07 */
    82,	/* 0.08 */
    92,	/* 0.09 */
    102,	/* 0.10 */
    112,	/* 0.11 */
    122,	/* 0.12 */
    132,	/* 0.13 */
    142,	/* 0.14 */
    152,	/* 0.15 */
    162,	/* 0.16 */
    172,	/* 0.17 */
    181,	/* 0.18 */
    191,	/* 0.19 */
    201,	/* 0.20 */
    210,	/* 0.21 */
    220,	/* 0.22 */
    230,	/* 0.23 */
    239,	/* 0.24 */
    248,	/* 0.25 */
    258,	/* 0.26 */
    267,	/* 0.27 */
    276,	/* 0.28 */
    285,	/* 0.29 */
    294,	/* 0.30 */
    303,	/* 0.31 */
    312,	/* 0.32 */
    321,	/* 0.33 */
    330,	/* 0.34 */
    338,	/* 0.35 */
    347,	/* 0.36 */
    355,	/* 0.37 */
    364,	/* 0.38 */
    372,	/* 0.39 */
    380,	/* 0.40 */
    388,	/* 0.41 */
    397,	/* 0.42 */
    405,	/* 0.43 */
    412,	/* 0.44 */
    420,	/* 0.45 */
    428,	/* 0.46 */
    436,	/* 0.47 */
    443,	/* 0.48 */
    451,	/* 0.49 */
    458,	/* 0.50 */
    465,	/* 0.51 */
    472,	/* 0.52 */
    480,	/* 0.53 */
    487,	/* 0.54 */
    493,	/* 0.55 */
    500,	/* 0.56 */
    507,	/* 0.57 */
    514,	/* 0.58 */
    520,	/* 0.59 */
    527,	/* 0.60 */
    533,	/* 0.61 */
    540,	/* 0.62 */
    546,	/* 0.63 */
    552,	/* 0.64 */
    558,	/* 0.65 */
    564,	/* 0.66 */
    570,	/* 0.67 */
    576,	/* 0.68 */
    582,	/* 0.69 */
    587,	/* 0.70 */
    593,	/* 0.71 */
    598,	/* 0.72 */
    604,	/* 0.73 */
    609,	/* 0.74 */
    614,	/* 0.75 */
    620,	/* 0.76 */
    625,	/* 0.77 */
    630,	/* 0.78 */
    635,	/* 0.79 */
    640,	/* 0.80 */
    645,	/* 0.81 */
    649,	/* 0.82 */
    654,	/* 0.83 */
    659,	/* 0.84 */
    663,	/* 0.85 */
    668,	/* 0.86 */
    672,	/* 0.87 */
    676,	/* 0.88 */
    681,	/* 0.89 */
    685,	/* 0.90 */
    689,	/* 0.91 */
    693,	/* 0.92 */
    697,	/* 0.93 */
    701,	/* 0.94 */
    705,	/* 0.95 */
    709,	/* 0.96 */
    713,	/* 0.97 */
    717,	/* 0.98 */
    720,	/* 0.99 */
    724,	/* 1.00 */
    728,	/* 1.01 */
};
@

<<global cosinus>>=
static
short cosinus[] = {
    1024,	/* 0.00 */
    1024,	/* 0.01 */
    1024,	/* 0.02 */
    1024,	/* 0.03 */
    1023,	/* 0.04 */
    1023,	/* 0.05 */
    1022,	/* 0.06 */
    1022,	/* 0.07 */
    1021,	/* 0.08 */
    1020,	/* 0.09 */
    1019,	/* 0.10 */
    1018,	/* 0.11 */
    1017,	/* 0.12 */
    1015,	/* 0.13 */
    1014,	/* 0.14 */
    1013,	/* 0.15 */
    1011,	/* 0.16 */
    1010,	/* 0.17 */
    1008,	/* 0.18 */
    1006,	/* 0.19 */
    1004,	/* 0.20 */
    1002,	/* 0.21 */
    1000,	/* 0.22 */
    998,	/* 0.23 */
    996,	/* 0.24 */
    993,	/* 0.25 */
    991,	/* 0.26 */
    989,	/* 0.27 */
    986,	/* 0.28 */
    983,	/* 0.29 */
    981,	/* 0.30 */
    978,	/* 0.31 */
    975,	/* 0.32 */
    972,	/* 0.33 */
    969,	/* 0.34 */
    967,	/* 0.35 */
    963,	/* 0.36 */
    960,	/* 0.37 */
    957,	/* 0.38 */
    954,	/* 0.39 */
    951,	/* 0.40 */
    947,	/* 0.41 */
    944,	/* 0.42 */
    941,	/* 0.43 */
    937,	/* 0.44 */
    934,	/* 0.45 */
    930,	/* 0.46 */
    927,	/* 0.47 */
    923,	/* 0.48 */
    920,	/* 0.49 */
    916,	/* 0.50 */
    912,	/* 0.51 */
    909,	/* 0.52 */
    905,	/* 0.53 */
    901,	/* 0.54 */
    897,	/* 0.55 */
    893,	/* 0.56 */
    890,	/* 0.57 */
    886,	/* 0.58 */
    882,	/* 0.59 */
    878,	/* 0.60 */
    874,	/* 0.61 */
    870,	/* 0.62 */
    866,	/* 0.63 */
    862,	/* 0.64 */
    859,	/* 0.65 */
    855,	/* 0.66 */
    851,	/* 0.67 */
    847,	/* 0.68 */
    843,	/* 0.69 */
    839,	/* 0.70 */
    835,	/* 0.71 */
    831,	/* 0.72 */
    827,	/* 0.73 */
    823,	/* 0.74 */
    819,	/* 0.75 */
    815,	/* 0.76 */
    811,	/* 0.77 */
    807,	/* 0.78 */
    804,	/* 0.79 */
    800,	/* 0.80 */
    796,	/* 0.81 */
    792,	/* 0.82 */
    788,	/* 0.83 */
    784,	/* 0.84 */
    780,	/* 0.85 */
    776,	/* 0.86 */
    773,	/* 0.87 */
    769,	/* 0.88 */
    765,	/* 0.89 */
    761,	/* 0.90 */
    757,	/* 0.91 */
    754,	/* 0.92 */
    750,	/* 0.93 */
    746,	/* 0.94 */
    742,	/* 0.95 */
    739,	/* 0.96 */
    735,	/* 0.97 */
    731,	/* 0.98 */
    728,	/* 0.99 */
    724,	/* 1.00 */
    720,	/* 1.01 */
};
@

<<function icossin2>>=
void
icossin2(int x, int y, int *cosp, int *sinp)
{
    int sinsign, cossign, tan, tan10, rem;
    short *stp, *ctp;

    if(x == 0){
        if(y >= 0)
            *sinp = ICOSSCALE, *cosp = 0;
        else
            *sinp = -ICOSSCALE, *cosp = 0;
        return;
    }
    sinsign = cossign = 1;
    if(x < 0){
        cossign = -1;
        x = -x;
    }
    if(y < 0){
        sinsign = -1;
        y = -y;
    }
    if(y > x){
        tan = 1000*x/y;
        tan10 = tan/10;
        stp = &cosinus[tan10];
        ctp = &sinus[tan10];
    }else{
        tan = 1000*y/x;
        tan10 = tan/10;
        stp = &sinus[tan10];
        ctp = &cosinus[tan10];
    }
    rem = tan-(tan10*10);
    *sinp = sinsign*(stp[0]+(stp[1]-stp[0])*rem/10);
    *cosp = cossign*(ctp[0]+(ctp[1]-ctp[0])*rem/10);
}
@





\chapter{Examples of Graphical Applications TODO}

% rio! next book.

% hello world! shorter than horrible X11 version?

% put code for menu? after all it's a nice example of use
% of draw.h, and how to build 

% color.c?
% lens? illustrate well features?
% faces.c? 

% both are mentioned in Unix Readers as very early graphic programs.



\chapter{Extra Code}

\ifallcode
#include "Graphics_extra.nw"
\fi

%\chapter{Changelog}
%\label{sec:changelog}
% code via make loc = 23 241 LOC (but code of tests, apps, drivers code, ...)
% orig nw = 26700, just lpized and many comments, 231 pages pdf
%  (but no tests, no apps)
% now: ? LOC ? pages, so added ?? LOE (Lines of explanations)


\chapter*{Glossary}
\addcontentsline{toc}{chapter}{Glossary}
\label{sec:glossary}

\begin{verbatim}
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{chapter}{Index}

%\chapter{References} 
\addcontentsline{toc}{chapter}{References}

\bibliography{../docs/latex/Principia}
\bibliographystyle{plain}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
