\documentclass[twocolumn, landscape]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse % see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things:
% - removed deadcode (Displaybufsize, ...)
% - screen.h cleaner interface, TODO merge globals (screenimage and gscreen)
% - renamed some globals (screen -> view, _screen -> screen)

%thx to codemap/codegraph/scheck:
% - SEMI use cg to reduce backward deps, introduce globals.c, utils.c,
%   (harder to understand non layered code)
% - TODO use scheck to remove deadcode, dead prototypes, useless export
%   or mv as forward decl
%   (harder to understand big interface files)
% - TODO use cg to reduce number of globals by moving them closer to the
%   relevant file (or even function), better cluster the code
%   (harder to understand non functional code using lots of globals)

%thx to this manual, better understand svgalib? tronscroll:) mode X? cairo?:
%  - SEMI better understand channels, and the many image formats
%  - TODO better understand alpha
%  - TODO better understand bezier (could be useful for edge bunding visual)
%    that they are essence of vectoriel fonts?
%  - TODO understand freshrate, double buffer, vertical sync, flickering


%history LP-ization:
% - skeleton, mostly copy paste of Template.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * TODO ctor/dtor, dumper
%    * TODO [[xxx]] other fields, [[xxx]] extra fields
% - read Extra section, identify concepts, first TOC
% - SEMI distribute parts of the Extra section in the main file
% - SEMI understand main(), LP split main, improve TOC
% - TODO understand main functions, LP split, cluster, improve TOC
% - SEMI LP split the structures, use datalog for flow to field info
% - SEMI nullify, boolify, errorify, enumify,  typeify,    scheckify, plan9ify
% - TODO aspecify advanced features! remove useless features
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% ifallcode is used for:
%  - forward decl, func decl, extern decl, #ifdef, pragmas (stuff in Extra.nw)
%  - ??

\setcounter{tocdepth}{2}

\addtolength{\topmargin}{-.850in}
\addtolength{\textheight}{1.70in}

\begin{document}
%******************************************************************************
% Title
%******************************************************************************
\title{
{\Huge 
Principia Softwarica: The Plan9 Graphics System [[/dev/draw/]]
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}\\
\\
with code from\\
Rob Pike and Russ Cox
}
% really?

\maketitle 

\onecolumn
\hrule
\input{../docs/latex/Copyright}
\input{../docs/latex/CopyrightPlan9}
\hrule
\twocolumn

\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\tableofcontents
\endgroup

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

The goal of this book is to present with full details the source code of
a {graphics system}.

\section{Motivations}

Why a graphics system? Because we think you are a better programmer if
you fully understand how things work under the hood, and
with so many fancy graphics on your screen, there are plenty
of things happening under the hood to be understood.

% Part hardware/software too. Actually more and more done by
% hardware. 3d. But here only 2d and in software mostly.
% Drawing API essentially. But also need mediate shared resource,
% screen, in kernel. 
% (Actually good if also networked, like X11)

Here are a few questions we hope this book will answer:
\begin{itemize}
\item Which low-level instructions allow to modify the screen?

\item How the picture on the screen is represented in the machine?
What is a framebuffer?

\item What are the algorithms to draw arbitrary lines
(e.g. non-vertical and non-horizontal lines)
on a rectangular aligned set of pixels (the screen)?

\item How pictures are represented in memory? How they
are stored on disk? What is the format of a JPG file?

\item What is the alpha layer?

\item What is rasterization? What are vector graphics?

\item How fonts are managed? How characters are drawn on the screen?
What are true type fonts? 

\item What is anti-aliasing?

\item How certain graphical elements, rectangles, ellipses, fonts, are
rendered on the screen? How the graphics card helps? How
the kernel helps? 

\item How is the mouse cursor handled?

\end{itemize}
\l how cooperate with windowing system?

\section{\plan [[/dev/draw/]]}

We will explain in this book the code of the \plan graphics
stack, visible to the programmer primarily through 
its [[/dev/draw/]] device directory, 
and also partially through the [[/dev/mouse]] and [[/dev/cons]] device files.
% LOC?
% 2d Graphics library.

% It actually provides some forms of windows managment, with backing
% store, and even menus (but rio is more complete).
% It can also be remote like X11! can draw through the network, and
% so have graphical application running on one machine but displaying
% result on your (powerful! like browser! and web app!)

% screenshot?

% bad stuff of draw though: most of the code is in the kernel :(
% lots of stuff can be in library and can be tested outside
% (see memdrawtest), but still a bit ugly. The images, fonts,
% all of that reside in special kernel memory (imagmem)

\section{Other graphics systems}

Here are other graphics systems that were considered for this book 
but which were ultimately discarded:
\begin{itemize}
\item gks
% the seminal one? but present in any real system?
% or was it bitblt and the blit machine?
\item Cairo
% 2d graphics libs with support for many output "devices",
% xwindow, quartz, win32, image buffer, pdf, postscript, svg
% opengl, directFB.
% used in firefox
% can leverage hardware acceleration.
% operations similar to drawing operators of postscript and pdf
% from readme:
%  Operations in cairo include stroking and filling
%  cubic BÃ©zier splines, transforming and compositing translucent images,
%  and antialiased text rendering. All drawing operations can be
%  transformed by any affine transformation (scale, rotation, shear,
%  etc.).
% 350 K with tests

\item skia
% used in android and chrome
\item X11
%remote so cool, bug very very big
\item OpenGL
% mostly 3d! can do also 2d. gouraud, shading, textures, 3d rasterizer, etc.
%not much key/mouse/menu thing, like here actually
% tinyGL of bellard (openGL in software).
% Mesa? (openGL also in software no?)
\item NX graphics
% nuttx has some graphic and windowing stack apparently too!
%http://nuttx.org/doku.php?id=documentation:nxgraphics
\end{itemize}

%#industry:
% - Flash
% - CoreGraphics
% - WPF (Windows Presentation Framework?)
% - Quartz, relate to macos expose? advanced graphics there
%mini:
% - mini X
% - nano X (was microwindows)
%other:
% - canvas, postscript, SVG, ... 
% - wayland, mir
% - opengl and glut. the menuhit function is kinda related to glut.
% - http://www.helenos.org/doc/theses/pk-thesis.pdf
%wrappers:
% - SDL, SFML, Allegro, Clanlib
% - ocamlgraphics (cleaner/portable interface on top of X11 or windows graphics)
%oldies:
% - svgalib
%#research:
%  - Nile/Gezira DSL from vpri

%advanced:
% http://www.adriancourreges.com/blog/2015/11/02/gta-v-graphics-study/
%old-school style, pc-bible spirit and mode-X:
% http://www.dustmop.io/blog/2015/12/18/nes-graphics-part-3/


\section{Getting started}

% toy graphical app /tests/draw/

\section{Requirements}

% C as usual.
% but assume more? assume principle of graphics book? no.
% most books focused on 3d anyway.

%itemize docs/man/6/...
% graphics(2), draw(2), 
% draw(6?) 
% font(?) image(?)

%advanced: more for rio
% window(2) 
% mouse(3)

% see plan9-in-technicolor.ps

\section{About this document}
#include "../docs/latex/About.nw"

\section{Copyright}

Most of this document is actually source code from Plan9, so
those parts are copyright by Lucent Technologies Inc.
The prose is mine and is licensed under the \license.

\section{Acknowledgments}

I would like to acknowledge of course Plan9's authors who wrote
most of this book: Rob Pike, Russ Cox, and many other people
from Bell Labs.




\chapter{Overview}

\section{Graphics system principles}

%https://en.wikipedia.org/wiki/Computer_graphics

% screen made of pixels. Lots of them. Resolution. Depth/encoding.
% software/hardware interface can be as simple as a framebuffer (e.g. bcm/).
% pixels, so not continuous! so if draw diagonal, then no that easy actually :)
% => bresenham algorithm

% horiz/vert lines, rectangle, arbitrary line, polyline, ellipse, arc, bezier,
% and also text (fonts) which are special kind of pictures
% colors, alpha, channels, color map
% composition (porter-duff), clipping

% Vector graphics, rasterization

% very generic and powerful operations: draw()! (like bitblt before) 
% see cairo intro? 

% advanced: windows/layers, menus, mouse/keyboard

%http://blog.mecheye.net/2012/06/the-linux-graphics-stack/
%http://blogs.igalia.com/itoral/2014/07/29/a-brief-introduction-to-the-linux-graphics-stack/

% 3d. Not in this book.

\section{[[/dev/draw/]] files interface}

%maybe show code of toy app also?
% show the different devices?

% note that can run 'colors' in console outside rio! it just
% use /dev/draw, /dev/mouse, etc!

% see draw(5?)

%from https://news.ycombinator.com/item?id=9829662
%> Why is reading plain text out of /dev/mouse and writing plain text
%to /dev/draw an improvement over how Linux or OS X or Windows does it?
%
%It's very useful because you don't need a C FFI to access OS
%functionality, graphics libraries and the like. Any language whose
%implementation allows you to read and write files can already do a lot
%of things (including GUIs, IPC and so on).

\section{A toy graphical application}
% e.g. colors? clock.c?

% see display, image, and draw() generic ops.
% see that colors that are actually images! very general (maybe too much).
% different model than the Context of X11, or cairo, or canvas.

% maybe can zoom on line to see it's tricky to get diagonals
% with certain angles.


% a bit annoying that have to transform your xy into the final
% xy ourself by adding view->r.min. Not really "abstraction"
% power. I'd rather have my 0x0 to be the top left on _my_ window.

\section{Code organization}

% user code usually just have to do
% #include <draw.h>

% libdraw/, libmemdraw/, libmemlayer/, kernel/devices/screen/
% lofs of files have similar name in libdraw/ and libmemdraw/

%-------------------
% libdraw/
%-------------------
% libdraw is mostly for user DS and API that then just
% marshalled and delegate the actual work to /dev/draw
% normally apps must link just with libdraw.a (and not libmemdraw.a
% or libmemlayer.a!) (there are some apps that use memlayer too though).
% can actually divide libdraw in two, have a libcoredraw (or libgeometry)
% so the kernel would not depend on libdraw

%arith.c: Point and Rectangle ctor and arithmetic (+-/*)

%icossin.c: math
%icossin2.c: math

%drawrepl.c: utilities
%rectclip.c: utilities
%replclipr.c: utilities
%misc.c: utilities
%a few other utilities appear later: bytesperline.c, chan.c

%debug.c
%fmt.c: dumper


%init.c: display, screen, images

%draw.c: draw rectangle, or copy rectangles (easier draw horiz or vert)
 %border.c: draw border
%line.c: draw line (bresenham algorithm? not here, in libmemdraw/)
%poly.c: draw polylines
%ellipse.c: draw ellipse, and arcs
%bezier.c: draw spline
%string.c: draw text
 %stringbg.c

%alloc.c: alloc images
 %bytesperline.c: resolution -> malloc size 
  %(actually used in memdraw/alloc.c, but also here by readimage.c/...)
 %allocimagemix.c: ??

%chan.c: channel functions
%rgb.c: rgb
%readcolmap.c:
%writecolmap.c:

%readimage.c: parse from file
%loadimage.c: parse from memory
%writeimage.c: write to file
%unloadimage.c: write to memory
%cloadimage.c: compressed load image
%creadimage.c: compressed read image
%computil.c: compression utilities

%window.c: image "layers" (hmm but actually not transparent right now)
%newwindow.c:

%mouse.c:
%keyboard.c:
%event.c:
%menuhit.c:
%getrect.c:
%emenuhit.c:
%egetrect.c:
%scroll.c:

%defont.c: lucm/latin1.9, in uncompressed form

%font.c:
%buildfont.c:
%mkfont.c:
%getdefont.c:
%openfont.c:

%subfont.c:
%getsubfont.c:
%freesubfont.c:
%stringsubfont.c:
%subfontcache.c:
%subfontname.c:
%readsubfont.c:
%writesubfont.c:

%stringwidth.c


%-------------------
% kernel/drivers/screen/
%-------------------

% libdraw mostly wrapper on /dev/draw, marshall data, special protocol

% devdraw.c is the /dev/draw handler, especially drawmesg() dispatcher
%  to libmemdraw operations and libmemlayer operations
% should also have actual calls to screen.h implem,
% e.g. vgascreen.c!

% pool.c?: imagmem! image data store! (in kernel :( X11 spirit )
% devdraw.c: /dev/draw
% screen.c: factorize stuff, gscreen, soft cursor, cursor, graphic text mode
% vgascreen.c: implem of screen.h hardware specific ops needed by devdraw
%  and memdraw

% devvga.c: /dev/vga ctl files for vgascreen global parameters?
% vgavesa.c: vesa specifics? needed?
% vgaclgd542x.c: cirrus logic specifics

%-------------------
% libmemdraw/
%-------------------
% libmemdraw actually does the drawing stuff in memory
% (and rely on some kernel vga functions to do the rest and transfer
%  images from memory to the actual screen (or nop if framebuffer))
% it also rely on some code in libmemlayer.
% most apps should link only with libdraw. Only the kernel
% (and test programs) link with libmemdraw.a normally.

%draw.c: draw rectangle, actual memory code

%replmul.c: utilities?

%line.c: bresenham?
%poly.c
%fillpoly.c
%ellipse.c
%arc.c
%string.c

%alloc.c: memimage?

%cmap.c


%read.c: read image?
%write.c:
%load.c:
%unload.c:
%cload.c: compressed load
%cread.c: compressed read


%subfont.c
%openmemsubfont.c
%defont.c


%todo: could remove files below? who links with libmemdraw except 
% test files? they can define then the hwdraw(), iprint() empty handler
%hwdraw.c: kernel cruft
%iprint.c: kernel cruft
% when people link with memdraw outside the kernel
% then the linker will complain if no hwdraw() function,
% but normally hwdraw() should be a bridge to screen.h interface 
% functions? (implemented by vgascreen)


%-------------------
% libmemlayer/
%-------------------
% libmemlayer is mostly to have "layers", layers of images
% so one can more easily implement a windowing system with 
% overlapping pictures (windows) that actually can get exposed back

%draw.c: again, memdraw(), but should be in libmemdraw/
%line.c: again! memline(), but should be only for horizontal/vert here no?

%layerop.c

%lalloc.c: ??
%ldelete.c

%lsetrefresh.c


%lorigin.c: mv window
%lhide.c: hide window
%ltofront.c: back to top
%ltorear.c: put to rear

%load.c: ??
%unload.c: ??


\section{Software architecture}

% complicated archi. Even just user side is complicated. So when
% add kernel side, it can get tricky. Maybe easier to first
% show archi on user side, the relation between the important
% types (Display, Image, Rectangle, etc).
% maybe can also show the simplest interface, a framebuffer, and
% how /dev/draw build on top of that? In theory could have
% just a framebuffer and libmemdraw/ on top of it.

% = framebuffer or vga =
% = screen.h and gscreen Memimage =
% = libmemdraw/ =
%
% = libmemlayer/ =
% = draw device =
% = libdraw/ =
% = app =


% app, library, kernel draw server, kernel draw libs, vga driver
% kernel vs libs vs apps (vs rio)

% public API -> marshaller -> flush -> KERNEL -> unmarshaller -> algorithm
% some kind of RPC and protocol

% libdraw -> KERNEL -> devdraw -> libmemdraw | libmemlayer -> devvga -> clgd5446
% that's a lot of entities

% xxx, doxxx, memxxx, memlxxx, drawxxx, screenxxx

% Display (User side, dirno) Client (Kernel side, vga structure) 
%  Image (User side, id) MemImage (Kernel side, id -> full structure) DImage
%   can draw on that (lines, rectangles, lines, ellipses, text, etc)
%  Screen
%   Window (Image)

% devvga
%  why imagmem? why imagmem and mainmem? why not use other allocator?
%  see screen/user/notes.txt especially about the old way to get graphics on PC

% data structures archi:
%  Display|Image|display -> Client|MemImage|screen 
%    -> gscreen -> gscreendata.bdata and vgascreen.paddr?
% interface archi:
%  API -> marshall -> unmarshall 
%   -> algorithm libmemdraw (and libmemlayer sometimes)
%   -> screen.h interface (mostly flush image)
%   -> vgascr interface -> vgadev interface
%   -> actual hardware special operations


% read/load cload/cread
% unload/write
% ???

% what is the minimum we ask from hardware? just a screen.h interface?
% with a not too bad flushmemscreen? if look at screen.c for raspberry,
% most of screen.c is hardware independent (arrow picture, software cursor, 
% gscreen, window, curpos). The only hardware dependent is fbinit to
% initialize framebuffer. hwdraw() does nothing. flushmemscreen() does
% nothing. They just need a gscreen->bdata to point to a framebuffer
% and set the property of this memimage depending on the hardware
% (width, depth, chan). That's it!


% about RPC vs framebuffer.
% design goal was like X11 can be remote! can login on another
% machine, execute program there that actually display on your screen.
% for plan9 they just reuse 9p! network file system so /dev/draw
% can be on the network!
% but this design means it's not a framebuffer! it accepts
% drawing commands, like in X11, because can't allow to send
% all pixels each time through big write on /dev/draw over the network
% (hmm actually with high speed network maybe we could)

% the API seems mostly stateless. As opposed to ocaml graphics
% where you move the cursor and then ask to draw stuff, here
% you specify each time. The API is also very general, see draw().


\section{Initialization overview}

\section{Trace of a simple drawing operation}
% when do draw(), then where does it go? go in kernel? yes ... :(
% at least when call flush().

%\section{Trace of a mouse click}

%\section{Trace of a key press}


\section{Book structure}

%###############################################################################

\chapter{Core Data Structures}

% below are draw.h big DS and also their pending DS in the kernel.
% many important globals are in libdraw/init.c

% lots of DS to present.

\section{[[Display]] and [[Client]]}
% and [[display]]

% user side, can see it as essentially a connection handler
<<struct Display>>=
struct Display
{
    // ref_own<Image>
    Image	*image;

    <<[[Display]] devdraw connection fields>>
    <<[[Display]] buffer related fields>>
    <<[[Display]] basic images fields>>

    <<[[Display]] other fields>>
};
@
% rename image field to screen/view? is it the same than global screen/view?

% usually have draw(dstimg, rectangle, srcimg, maskimg)
% and srcimg can be just black, and maskimg can be just opaque
% the abuse image for many things, because it's more general!
% Black is an image! (1x1 pixels)

%!!!!
<<global display>>=
// option<Display>
Display	*display;
@
% set by initdraw() (meh, could be returned instead no?)


<<[[Display]] devdraw connection fields>>=
int		dirno; // /dev/draw/x
fdt		ctlfd; // /dev/draw/new
fdt		fd;    // /dev/draw/x/data
@

% just for debugging I think, have ctlfd and fd already
<<[[Display]] devdraw connection fields>>=
char	*devdir; // /dev in general
char	*windir; // /dev in general
@


<<[[Display]] basic images fields>>=
// ref_own<Image>
Image	*white;
// ref_own<Image>
Image	*black;

// ref_own<Image>
Image	*opaque;
// ref_own<Image>
Image	*transparent;
@
% colors are images! uniform





%XXXXXXXXXX
<<[[Display]] other fields>>=
QLock	qlock;
int		locking;	/*program is using lockdisplay */
@
<<[[Display]] other fields>>=
int		local;
char	oldlabel[64];
ulong	dataqid;
@
<<[[Display]] other fields>>=
bool	_isnewdisplay;
@







<<struct Client>>=
struct Client
{
    int     clientid; // dirno?

    // ??? map<?, ref_own?<Dimage>> ?
    DImage*     dimage[NHASH];
    // enum<drawop>?
    int     op;

    <<[[Client]] other fields>>
    // Extra
    Ref     r;
};
@
% ref? can share client? if create proc? if attach to another display?


%XXXXXXXXXX
<<[[Client]] other fields>>=
CScreen*    cscreen;

Refresh*    refresh;
Rendez      refrend;
int     refreshme;

byte*   readdata;
int     nreaddata;

int     busy;
int     slot;
int     infoid;
@


% put DImage at least? why D?
% CScreen? DScreen? ...

\section{[[Image]] and [[Memimage]]}
% and [[screen/view]],  and DImage?

% see technicolor.ps! images in plan9 draw are
% specials.

<<struct Image>>=
struct Image
{
    // ref<Display>
    Display		*display;	/* display holding data */
    int			id;		/* id of system-held Image */

    Rectangle	r;		/* rectangle in data area, local coords */
    Rectangle 	clipr;	/* clipping region */
    // bitset<enum<fxxx>>    
    int			repl;		/* flag: data replicates to tile clipr */

    ulong		chan;
    int			depth;		/* number of bits per pixel */

    <<[[Image]] other fields>>
    // Extra
    <<[[Image]] extra fields>>
};
@
% read from /dev/draw/new initially when open the connection
%  see initdisplay() 
% system-held id! usually 0 for the first image of /dev/draw/new
% incremented then at each allocimage, thx to Display.imageid field

% Image.display is of Display->image? not necessaraly I think, only
% the main image (screen) is.

% need display pointer because when do draw operation we need
% to write in img->display.buf! and then flushimage(img->display)!
% we need the connection handler!

<<global screen>>=
// option<Image>
Image	*view;
@
%less: can be modified? Is it the same than Display->image?
%old: was called screen, but unfortunate because there was
% also a Screen type and then a _screen global.
% could maybe also call it image, or window.
% At the same time with the virtual screen principle, every app thinks it has
% the whole screen for himself, so maybe it made sense to call this
% variable screen. But view is good too, less confusing
% Actually rio use a 'view' global assigned to screen.



%less: typedef int imageid;? screenid? windowid?
% hmm but for imageid actually on user side we return Image* not imageid
% so this imageid typedef will be really internal

<<[[Display]] other fields>>=
int		imageid;
@
% counter, incremented each allocimage(), rename imageidcnt;

% for r, clipr, repl, see technicolor.ps!
%/* huge but not infinite, so various offsets will leave it huge, not overflow*/
% clipr = Rect(-0x3FFFFFFF, -0x3FFFFFFF, 0x3FFFFFFF, 0x3FFFFFFF);



%less: hmm actually this is in memdraw.h so maybe
% it can't be the repl flag in Image.
<<enum fxxx>>=
enum {
    Frepl	= 1<<0,	/* is replicated */
    Fsimple	= 1<<1,	/* is 1x1 */
    Fgrey	= 1<<2,	/* is grey */
    Falpha	= 1<<3,	/* has explicit alpha */
    Fcmap	= 1<<4,	/* has cmap channel */
    Fbytes	= 1<<5,	/* has only 8-bit channels */
};
@
% >> >> >> >> >> >>







<<struct Memimage>>=
struct Memimage
{
    Rectangle	r;		/* rectangle in data area, local coords */
    Rectangle	clipr;		/* clipping region */
    //bitset<enum<fxxx>
    ulong	flags;

    ulong	chan;	/* channel descriptions */
    int		nchan;	/* number of channels */
    int		depth;	/* number of bits of storage per pixel */

    // finally, the raw pixels
    // ref_own<Memdata>
    Memdata	*data;	/* pointer to data; shared by windows in this image */

    <<[[MemImage]] other fields>>
};
@
%less: no repl here? yes, it's flags. rename repl?
% depth is sum of bits per pixel for r/g/b, so for RGB16 it's ... 16


<<struct Memdata>>=
/*
 * Memdata is allocated from main pool, but .data from the image pool.
 * Memdata is allocated separately to permit patching its pointer after
 * compaction when windows share the image data.
 * The first word of data is a back pointer to the Memdata, to find
 * The word to patch.
 */
struct Memdata
{
    ulong	*base;	/* allocated data pointer */
    // the pixels!
    byte	*bdata;	/* pointer to first byte of actual data; word-aligned */

    <<[[Memdata]] other fields>>
};
@
% the raw pixel data! but to know where to modify you need
% to understand the format of the image, the #channels, depths
% of channels, etc.
% this is kinda a framebuffer. But actually needs one
% operation to transfer from this memory to the actual screen?
% hmm flushmemscreen is responsible for that, but it can be a nope
% when bdata is already pointing to the framebuffer.
% the vga driver does a copy though probably.
% but anyway bdata is not necessaraly for the framebuffer, it can
% be any images the user works on.
% see also ishwimage()


% put DImage here and screendimage? and even gscreen?

<<function byteaddr>>=
byte*
byteaddr(Memimage *i, Point p)
{
    byte *a;

    a = i->data->bdata + i->zero + sizeof(ulong) * p.y * i->width;

    <<[[byteaddr()]] if depth less than 8>>
    else
        return a + p.x*(i->depth/8);
}
@

<<[[MemImage]] other fields>>=
int		zero;		/* data->bdata+zero==&byte containing (0,0) */
ulong	width;	/* width in words of a single scan line */
@


<<[[byteaddr()]] if depth less than 8>>=
if(i->depth < 8){
    /*
     * We need to always round down,
     * but C rounds toward zero.
     */
    int np;
    np = 8/i->depth;
    if(p.x < 0)
        return a+(p.x-np+1)/np;
    else
        return a+p.x/np;
}
@

% memfillcolor -> <>
<<function wordaddr>>=
/*
 * Wordaddr is deprecated.
 */
ulong*
wordaddr(Memimage *i, Point p)
{
    return (ulong*) ((uintptr)byteaddr(i, p) & ~(sizeof(ulong)-1));
}
@








%\section{[[gscreen]]}
% just like have [[screen/view]], client side,
% have also gscreendimage and gscreen kernel side
%[[screen.h]] interface
% This used to be called the [[VGAscr]] section.
% But what matters is not so much VGA but the screen.h interface.
% We actually moved more stuff to a generic screen.c, to be closer
% to the simplicity of bcm/screen.c. We don't want to expose ugly
% VGA details when nowadays things are simpler like the framebuffer
% interface of the raspberry.

% screen.c, relation to Display->image? to screen/view? g? global screen?
<<global gscreen>>=
Memimage *gscreen;
@
% this used to be in vgascreen.c, but every archi was defining
% such a gscreen, so makes sense to factorize in a screen.c.
% there also used to be a vgascreen[0].gscreen (see screensize()), but
% this was redundant then with gscreen.
%todo: put global kernel gscreen for chunkname? or global gscreen(kernel)
% like I did for (arm) and (386)

<<global gscreendata>>=
Memdata gscreendata;
@
% not a pointer, gscreen->data = &gscreendata.

<<global physgscreenr>>=
Rectangle physgscreenr;
@
% gscreen->r, could remove again then? too much globals


% could put a generic ishwimage here! that just check if 
% i->data->bdata == gscreen->data->bdata!





%XXXXXXXXXXXXXXXXXXXXX
<<[[MemImage]] other fields>>=
int		shift[NChan];
int		mask[NChan];
int		nbits[NChan];
@

%XXXXXXXXXX
<<[[Memdata]] other fields>>=
int		ref;		/* number of Memimages using this data */

void*	imref;
int		allocd;	/* is this malloc'd? */
@


% libmemdraw/draw.c

% setup in memimageinit
<<global memones>>=
static Memimage*	memones;
@
<<global memzeros>>=
static Memimage*	memzeros;
@

% pending of Display->white, Display->opaque, etc
<<global memwhite>>=
Memimage *memwhite;
@
<<global memblack>>=
Memimage *memblack;
@
<<global memtransparent>>=
Memimage *memtransparent;
@
<<global memopaque>>=
Memimage *memopaque;
@





\section{[[Drawop]] and [[Memdrawparam]]}
% Composition
% hmm put now?

% take technicolor.ps example with nice racket like
% slides where images are arguments of draw(), like slide 9

<<enum drawop>>=
enum drawop
{
    /* Porter-Duff compositing operators */
    Clear	= 0,

    SinD	= 8,
    DinS	= 4,
    SoutD	= 2,
    DoutS	= 1,

    S		= SinD|SoutD,
    SoverD	= SinD|SoutD|DoutS,
    SatopD	= SinD|DoutS,
    SxorD	= SoutD|DoutS,

    D		= DinS|DoutS,
    DoverS	= DinS|DoutS|SoutD,
    DatopS	= DinS|SoutD,
    DxorS	= DoutS|SoutD,	/* == SxorD */

    Ncomp = 12,
};
@



<<enum _anon_ (include/memdraw.h)2>>=
/*
 * Encapsulated parameters and information for sub-draw routines.
 */
enum {
    Simplesrc=1<<0,
    Simplemask=1<<1,
    Replsrc=1<<2,
    Replmask=1<<3,
    Fullmask=1<<4,
};
@
% >> >> >> >> >>

% technicolor.ps! see draw()
<<struct Memdrawparam>>=
struct	Memdrawparam
{
    Memimage *dst;
    Rectangle	r;
    Memimage *src;
    Rectangle sr;
    Memimage *mask;
    Rectangle mr;

    int op;

    ulong state;
    ulong mval;		/* if Simplemask, the mask pixel in mask format */
    ulong mrgba;	/* mval in rgba */
    ulong sval;		/* if Simplesrc, the source pixel in src format */
    ulong srgba;	/* sval in rgba */
    ulong sdval;	/* sval in dst format */
};
@

\section{Image channels}

% not thread channel, image channel here!
% ulong in previous struct, but more complex format
% actually

<<enum _anon_ (include/draw.h)4>>=
/*
 * image channel descriptors 
 */
enum {
    CRed = 0,
    CGreen,
    CBlue,

    CGrey,
    CAlpha,

    CMap,
    CIgnore,

    NChan,
};
@

<<enum _anon_ (include/draw.h)5>>=
enum {
    GREY1	= CHAN1(CGrey, 1),
    GREY2	= CHAN1(CGrey, 2),
    GREY4	= CHAN1(CGrey, 4),
    GREY8	= CHAN1(CGrey, 8),

    CMAP8	= CHAN1(CMap, 8),

    RGB15	= CHAN4(CIgnore, 1, CRed, 5, CGreen, 5, CBlue, 5),
    RGB16	= CHAN3(CRed, 5, CGreen, 6, CBlue, 5),
    RGB24	= CHAN3(CRed, 8, CGreen, 8, CBlue, 8),
    BGR24	= CHAN3(CBlue, 8, CGreen, 8, CRed, 8),

    RGBA32	= CHAN4(CRed, 8, CGreen, 8, CBlue, 8, CAlpha, 8), // classic one?
    ARGB32	= CHAN4(CAlpha, 8, CRed, 8, CGreen, 8, CBlue, 8),/* stupid VGAs */
    ABGR32	= CHAN4(CAlpha, 8, CBlue, 8, CGreen, 8, CRed, 8),

    XRGB32	= CHAN4(CIgnore, 8, CRed, 8, CGreen, 8, CBlue, 8),
    XBGR32	= CHAN4(CIgnore, 8, CBlue, 8, CGreen, 8, CRed, 8),
};
@
% todo: need all of that? could maybe simplfy and support less
% image format. That should remove quite some code, e.g. all those
% alphacalcxxx.
% cairo has what? RGBA32 no?

% what is True Color? mentionned in technicolor.ps. It's RGBA32?

% argument of what? allocimage?


<<function __DC>>=
#define __DC(type, nbits)	((((type)&15)<<4)|((nbits)&15))
@

<<function CHAN1>>=
#define CHAN1(a,b)	__DC(a,b)
@

<<function CHAN2>>=
#define CHAN2(a,b,c,d)	(CHAN1((a),(b))<<8|__DC((c),(d)))
@

<<function CHAN3>>=
#define CHAN3(a,b,c,d,e,f)	(CHAN2((a),(b),(c),(d))<<8|__DC((e),(f)))
@

<<function CHAN4>>=
#define CHAN4(a,b,c,d,e,f,g,h)	(CHAN3((a),(b),(c),(d),(e),(f))<<8|__DC((g),(h)))
@

<<function NBITS>>=
#define NBITS(c) ((c)&15)
@

<<function TYPE>>=
#define TYPE(c) (((c)>>4)&15)
@
% >> >> >>

<<function chantodepth>>=
int
chantodepth(ulong c)
{
    int n;

    for(n=0; c; c>>=8){
        if(TYPE(c) >= NChan || NBITS(c) > 8 || NBITS(c) <= 0)
            return 0;
        n += NBITS(c);
    }
    if(n==0 || (n>8 && n%8) || (n<8 && 8%n))
        return 0;
    return n;
}
@





\section{Colors}

%old school graphics:
%https://www.youtube.com/watch?v=Tfh0ytz8S0k&feature=youtu.be

% actually Color are Image* in plan9 draw!
% a Rect(0,0,1,1), with clipr = infinity and repl = true
% very general so less need draw_mask, or draw_color, instead
% just have a generic draw function where you can pass
% black as the src!

% 32 bits! RGBA 8 bits for each channel, which is
% why has FF as the last bit for almost all the elements below
<<enum _anon_>>=
enum
{
    DOpaque			= 0xFFFFFFFF,
    DTransparent	= 0x00000000,/* only useful for allocimage, memfillcolor */

    DBlack		= 0x000000FF,
    DWhite		= 0xFFFFFFFF,
    DRed		= 0xFF0000FF,
    DGreen		= 0x00FF00FF,
    DBlue		= 0x0000FFFF,
    DCyan		= 0x00FFFFFF,
    DMagenta	= 0xFF00FFFF,
    DYellow		= 0xFFFF00FF,

    DPaleyellow	= 0xFFFFAAFF,
    DDarkyellow	= 0xEEEE9EFF,
    DDarkgreen	= 0x448844FF,
    DPalegreen	= 0xAAFFAAFF,
    DMedgreen	= 0x88CC88FF,
    DDarkblue	= 0x000055FF,
    DPalebluegreen= 0xAAFFFFFF,
    DPaleblue	= 0x0000BBFF,
    DBluegreen	= 0x008888FF,
    DGreygreen	= 0x55AAAAFF,
    DPalegreygreen	= 0x9EEEEEFF,
    DYellowgreen	= 0x99994CFF,
    DMedblue		= 0x000099FF,
    DGreyblue		= 0x005DBBFF,
    DPalegreyblue	= 0x4993DDFF,
    DPurpleblue		= 0x8888CCFF,

    DNotacolor	= 0xFFFFFF00, // Alpha = 0
    DNofill	= DNotacolor,
    
};
@
%less: typedef unsigned int rbga; ?

\section{Color map}
% need color map if use RGBA32? hmm but VGA seems to be limited to depth 8
% maybe could move in advanced topics?

% CMAP vs RGB????

<<[[MemImage]] other fields>>=
Memcmap	*cmap;
@

<<struct Memcmap>>=
struct Memcmap
{
    uchar	cmap2rgb[3*256];
    uchar	rgb2cmap[16*16*16];
};
@


% dead? seems not very used, was in arith.c
<<function setalpha>>=
ulong
setalpha(ulong color, uchar alpha)
{
    int red, green, blue;

    red = (color >> 3*8) & 0xFF;
    green = (color >> 2*8) & 0xFF;
    blue = (color >> 1*8) & 0xFF;
    /* ignore incoming alpha */
    red = (red * alpha)/255;
    green = (green * alpha)/255;
    blue = (blue * alpha)/255;
    return (red<<3*8) | (green<<2*8) | (blue<<1*8) | (alpha<<0*8);
}
@
% >> >> >> >>
% that simple? :) to set alpha you just dillute each rgb components?


% there is an optimized but less appealing version in comment below
<<function rgb2cmap>>=
int
rgb2cmap(int cr, int cg, int cb)
{
    int i, r, g, b, sq;
    ulong rgb;
    int best, bestsq;

    best = 0;
    bestsq = 0x7FFFFFFF;
    // find best candidate
    for(i=0; i<256; i++){
        rgb = cmap2rgb(i);
        r = (rgb>>16) & 0xFF;
        g = (rgb>>8) & 0xFF;
        b = (rgb>>0) & 0xFF;
        sq = (r-cr)*(r-cr)+(g-cg)*(g-cg)+(b-cb)*(b-cb);
        if(sq < bestsq){
            bestsq = sq;
            best = i;
        }
    }
    return best;
}
@

<<function cmap2rgb>>=
int
cmap2rgb(int c)
{
    int j, num, den, r, g, b, v, rgb;

    r = c>>6;
    v = (c>>4)&3;
    j = (c-v+r)&15;
    g = j>>2;
    b = j&3;
    den=r;
    if(g>den)
        den=g;
    if(b>den)
        den=b;
    if(den==0) {
        v *= 17;
        rgb = (v<<16)|(v<<8)|v;
    }
    else{
        num=17*(4*den+v);
        rgb = ((r*num/den)<<16)|((g*num/den)<<8)|(b*num/den);
    }
    return rgb;
}
@
% >> >> >> >>
<<function cmap2rgba>>=
int
cmap2rgba(int c)
{
    return (cmap2rgb(c)<<8)|0xFF;
}
@
% >> 

\section{[[Font]] and [[Subfont]]}
% and [[font]]

<<struct Font>>=
struct Font
{
    char		*name;
    Display		*display;

    short		height;	/* max height of image, interline spacing */
    short		ascent;	/* top of image to baseline */
    short		width;	/* widest so far; used in caching only */	

    short		nsub;	/* number of subfonts */
    ulong		age;	/* increasing counter; used for LRU */
    int		maxdepth;	/* maximum depth of all loaded subfonts */
    int		ncache;	/* size of cache */
    int		nsubf;	/* size of subfont list */

    Cacheinfo	*cache;
    Cachesubf	*subf;
    Cachefont	**sub;	/* as read from file */
    Image		*cacheimage;
};
@


<<global font>>=
Font	*font;
@


<<[[Display]] other fields>>=
Font	*defaultfont;
Subfont	*defaultsubfont;
@

<<struct Subfont>>=
/*
 * Subfonts
 *
 * given char c, Subfont *f, Fontchar *i, and Point p, one says
 *	i = f->info+c;
 *	draw(b, Rect(p.x+i->left, p.y+i->top,
 *		p.x+i->left+((i+1)->x-i->x), p.y+i->bottom),
 *		color, f->bits, Pt(i->x, i->top));
 *	p.x += i->width;
 * to draw characters in the specified color (itself an Image) in Image b.
 */
struct	Subfont
{
    char		*name;
    short		n;		/* number of chars in font */
    byte		height;		/* height of image */
    char		ascent;		/* top of image to baseline */

    Fontchar 	*info;		/* n+1 character descriptors */
    Image		*bits;		/* of font */
    int		ref;
};
@

<<struct Fontchar>>=
struct	Fontchar
{
    int		x;		/* left edge of bits */
    byte	top;		/* first non-zero scan-line */
    byte	bottom;		/* last non-zero scan-line + 1 */
    char	left;		/* offset of baseline */
    byte	width;		/* width of baseline */
};
@




<<struct Memsubfont>>=
/*
 * Subfonts
 *
 * given char c, Subfont *f, Fontchar *i, and Point p, one says
 *	i = f->info+c;
 *	draw(b, Rect(p.x+i->left, p.y+i->top,
 *		p.x+i->left+((i+1)->x-i->x), p.y+i->bottom),
 *		color, f->bits, Pt(i->x, i->top));
 *	p.x += i->width;
 * to draw characters in the specified color (itself a Memimage) in Memimage b.
 */
struct	Memsubfont
{
    char	*name;
    short	n;		/* number of chars in font */
    uchar	height;		/* height of bitmap */
    char	ascent;		/* top of bitmap to baseline */

    Fontchar *info;		/* n+1 character descriptors */

    Memimage	*bits;		/* of font */
};
@


\section{Windows and layers}

% What we have seen was already very complicated, lots of architecture layers,
% wrapper data structures. A real onion.
% Here is another one :) Windows/Layers.

<<[[Display]] other fields>>=
// list<ref<Window>> (next = Image.next)
Image	*windows;
@

<<[[Image]] extra fields>>=
Image		*next;	/* next in list of windows */
@


<<[[Display]] other fields>>=
Image	*screenimage; // ???
@
% ???? different from Display.image?




<<[[Image]] other fields>>=
Screen		*screen;	/* nil if not a window */
@

% Screen type described later, but really should
% rename it Layer or something, so more consistent
% with Memlayer


<<[[MemImage]] other fields>>=
Memlayer	*layer;	/* nil if not a layer*/
@
% Memlayer described later in Windows chapter



\chapter{Initialisation}

\section{Kernel side}
% also kinda "Server side"
% hmm maybe better to see first user side?

\subsection{Mounting the draw device}

% see kernel init
% bind #i /dev
%  bind_safe("#i", "/dev", MAFTER); // devdraw


% ??sysbind?? -> <> (drawdevtab.attach <- toplevel)
<<function drawattach>>=
static Chan*
drawattach(char *spec)
{
    dlock();
    if(!initscreenimage()){
        dunlock();
        error("no frame buffer");
    }
    dunlock();
    return devattach('i', spec);
}
@

% drawattach -> <>
<<function initscreenimage>>=
static errorcode0
initscreenimage(void)
{
    if(screenimage != nil)
        return OK_1;

    screendimage = makescreenimage();
    if(screendimage == nil)
        return ERROR_0;
    screenimage = screendimage->image;
    // iprint("initscreenimage %p %p\n", screendimage, screenimage);
    mouseresize();
    return OK_1;
}
@

% put in core DS chapter? merge with screen.h gscreen no?
<<global screenimage>>=
static  Memimage    *screenimage;
@
% screendimage->image (less: so could remove this semi global)
% vs gscreen??

% fuck, another set of globals ... rename gscreendimage?
<<global screendimage>>=
static  DImage* screendimage;
@



% initscreenimage -> <>
% less: rename makescreendimage? it returns a DImage here
<<function makescreenimage>>=
static DImage*
makescreenimage(void)
{
    int width, depth;
    ulong chan;
    DImage *di;
    Memdata *md;
    Memimage *i;
    Rectangle r;

    md = malloc(sizeof(Memdata));
    if(md == nil)
        return nil;
    md->allocd = 1;
    md->base = nil;
    md->bdata = attachscreen(&r, &chan, &depth, &width, &sdraw.softscreen);
    if(md->bdata == nil){
        free(md);
        return nil;
    }
    md->ref = 1;
    i = allocmemimaged(r, chan, md);
    if(i == nil){
        free(md);
        return nil;
    }
    i->width = width;
    i->clipr = r;

    di = allocdimage(i);
    if(di == nil){
        freememimage(i);    /* frees md */
        return nil;
    }
    if(!waserror()){
        snprint(screenname, sizeof screenname, "noborder.screen.%d", ++screennameid);
        drawaddname(nil, di, strlen(screenname), screenname);
        poperror();
    }
    return di;
}
@
% hmm waserror, refer to kernel book! or maybe put appendix again
% with summary of equivalences with modern exn constructs

%\subsubsection{Hardware support hook}

% makescreenimage -> <>
% vgascreen.c
<<function attachscreen(x86)>>=
byte*
attachscreen(Rectangle* r, ulong* chan, int* d, int* width, int *softscreen)
{
    VGAscr *scr;

    scr = &vgascreen;
    if(gscreen == nil || gscreendata.bdata == nil)
        return nil;

    *r = gscreen->clipr;
    *chan = gscreen->chan;
    *d = gscreen->depth;
    *width = gscreen->width;
    *softscreen = scr->useflush;

    return gscreendata.bdata;
}
@
% who setup vgascreen? 

\subsection{[[screensize()]]}
% aux/vgactl ??

<<global vgascreenlock(x86)>>=
Lock vgascreenlock;
@

<<global softscreen(x86)>>=
static void *softscreen;
@
%gscreendata.bdata?


% ???aux/vga -> <>
% vgascreen.c
<<function screensize(x86)>>=
int
screensize(int x, int y, int z, ulong chan)
{
    VGAscr *scr;
    void *oldsoft;

    lock(&vgascreenlock);
    if(waserror()){
        unlock(&vgascreenlock);
        nexterror();
    }

    memimageinit();

    scr = &vgascreen;
    oldsoft = softscreen;

    if(scr->paddr == 0){
        int width = (x*z)/BI2WD;
        void *p;

        p = xalloc(width*BY2WD*y);
        if(p == nil)
            error("no memory for vga soft screen");
        gscreendata.bdata = softscreen = p;
        if(scr->dev && scr->dev->page){
            scr->vaddr = KADDR(VGAMEM());
            scr->apsize = 1<<16; // >>
        }
        scr->useflush = true;
    }
    else{
        gscreendata.bdata = scr->vaddr;
        scr->useflush = scr->dev && scr->dev->flush;
    }

    if(gscreen)
        freememimage(gscreen);
    gscreen = allocmemimaged(Rect(0,0,x,y), chan, &gscreendata);
    if(gscreen == nil)
        error("no memory for vga memimage");

    <<[[screensize()]] setup globals for vga text mode(x86)>>

    scr->palettedepth = 6;  /* default */
    scr->memdefont = getmemdefont();

    physgscreenr = gscreen->r;

    unlock(&vgascreenlock);
    poperror();
    if(oldsoft)
        xfree(oldsoft);

    memimagedraw(gscreen, gscreen->r, memblack, ZP, nil, ZP, S);
    flushmemscreen(gscreen->r);

    if(didswcursorinit)
        swcursorinit();
    drawcmap();
    return 0;
}
@
% >>


\subsection{[[memimageinit()]]}

% screensize | main_test -> <>
% when call to screensize in the kernel? when switch to graphic mode via vgactl?
<<function memimageinit>>=
void
memimageinit(void)
{
    static bool didinit = false;
    if(didinit)
        return;
    didinit = true;

    if(  strcmp(imagmem->name, "Image") == 0 
      || strcmp(imagmem->name, "image") == 0
      )
        imagmem->move = memimagemove;

    mktables();
    _memmkcmap();

    fmtinstall('R', Rfmt); 
    fmtinstall('P', Pfmt);
    fmtinstall('b', _ifmt);

    memzeros = allocmemimage(Rect(0,0,1,1), GREY1);
    memzeros->flags |= Frepl;
    memzeros->clipr = Rect(-0x3FFFFFF, -0x3FFFFFF, 0x3FFFFFF, 0x3FFFFFF);
    *byteaddr(memzeros, ZP) = 0;

    memones = allocmemimage(Rect(0,0,1,1), GREY1);
    memones->flags |= Frepl;
    memones->clipr = Rect(-0x3FFFFFF, -0x3FFFFFF, 0x3FFFFFF, 0x3FFFFFF);
    *byteaddr(memones, ZP) = ~0;

    if(memones == nil || memzeros == nil)
        assert(0 /*cannot initialize memimage library */);	/* RSC BUG */

    memwhite = memones;
    memblack = memzeros;
    memopaque = memones;
    memtransparent = memzeros;
}
@

% kernel interface?
% memimageinit -> imag->move = <>
<<function memimagemove>>=
void
memimagemove(void *from, void *to)
{
    Memdata *md;

    md = *(Memdata**)to;
    if(md->base != from){
        print("compacted data not right: #%p\n", md->base);
        abort();
    }
    md->base = to;

    /* if allocmemimage changes this must change too */
    md->bdata = (uchar*)md->base+sizeof(Memdata*)+sizeof(ulong);
}
@



<<global replbit>>=
/*
 * Conversion tables.
 */
static uchar replbit[1+8][256];		/* replbit[x][y] is the replication of the x-bit quantity y to 8-bit depth */
@

<<global conv18>>=
static uchar conv18[256][8];		/* conv18[x][y] is the yth pixel in the depth-1 pixel x */
@

<<global conv28>>=
static uchar conv28[256][4];		/* ... */
@

<<global conv48>>=
static uchar conv48[256][2];
@



<<function mktables>>=
static void
mktables(void)
{
    int i, j, mask, sh, small;
        
    if(tablesbuilt)
        return;

    fmtinstall('R', Rfmt);
    fmtinstall('P', Pfmt);
    tablesbuilt = 1;

    /* bit replication up to 8 bits */
    for(i=0; i<256; i++){
        for(j=0; j<=8; j++){	/* j <= 8 [sic] */
            small = i & ((1<<j)-1);
            replbit[j][i] = (small*replmul[j])>>8;
        }
    }

    /* bit unpacking up to 8 bits, only powers of 2 */
    for(i=0; i<256; i++){
        for(j=0, sh=7, mask=1; j<8; j++, sh--)
            conv18[i][j] = replbit[1][(i>>sh)&mask];

        for(j=0, sh=6, mask=3; j<4; j++, sh-=2)
            conv28[i][j] = replbit[2][(i>>sh)&mask];

        for(j=0, sh=4, mask=15; j<2; j++, sh-=4)
            conv48[i][j] = replbit[4][(i>>sh)&mask];
    }
}
@


\section{Client side}

\subsection{[[initdraw()]]}

<<function initdraw>>=
errorneg1
initdraw(void(*error)(Display*, char*), char *fontname , char *label)
{
    char *dev = "/dev";

    if(access("/dev/draw/new", AEXIST)<0 && bind("#i", "/dev", MAFTER)<0){
        fprint(2, "imageinit: can't bind /dev/draw: %r\n");
        return ERROR_NEG1;
    }
    return geninitdraw(dev, error, fontname, label, dev, Refnone);
}
@

% devdir and windir often equals and = /dev
<<function geninitdraw>>=
errorneg1
geninitdraw(char *devdir, void(*error)(Display*, char*), char *fontname, char *label, char *windir, int ref)
{
    int fd, n;
    Subfont *df;
    char buf[128];

    display = initdisplay(devdir, windir, error);
    if(display == nil)
        return ERROR_NEG1;

    <<[[geninitdraw()]] set up font>>
    <<[[geninitdraw()]] write label>>
    <<[[geninitdraw()]] get window>>

    atexit(drawshutdown);

    return OK_1;
}
@

<<function drawshutdown>>=
/* note handler */
static void
drawshutdown(void)
{
    Display *d;

    d = display;
    if(d){
        display = nil;
        _closedisplay(d, 1);
    }
}
@


\subsection{[[initdisplay()]]}

% get connection and first automatically allocated image in d->image

<<constant NINFO>>=
#define	NINFO	12*12
@
% /dev/draw/new content, 12 strings each 11 chars + newline

<<[[initdisplay()]] locals>>=
Display *disp;
Image *image;

fdt ctlfd;
char info[NINFO+1];
fdt datafd;
fdt reffd;

char buf[128];
char *t;
bool isnew;
int n;
Dir *dir;
@

%less: could reorganize error managment like in Linux instead
% have the errorx: followed, so less need 'goto previousone';

% hmm it's actually a public function! but not much app tweaking
% with it
<<function initdisplay>>=
Display*
initdisplay(char *dev, char *win, void(*error)(Display*, char*))
{
    <<[[initdisplay()]] locals>>

    <<[[initdisplay()]] install dumpers>>
    <<[[initdisplay()]] check arguments validity>>

    sprint(buf, "%s/draw/new", dev);
    ctlfd = open(buf, ORDWR|OCEXEC);

    if(ctlfd < 0){
        if(bind("#i", dev, MAFTER) < 0){
    Error1:
            free(t);
            werrstr("initdisplay: %s: %r", buf);
            return nil;
        }
        // try again
        ctlfd = open(buf, ORDWR|OCEXEC);
    }
    if(ctlfd < 0)
        goto Error1;

    n=read(ctlfd, info, sizeof info);

    if(n < 12){
    Error2:
        close(ctlfd);
        goto Error1;
    }
    if(n==NINFO+1)
        n = NINFO;
    info[n] = '\0';

    isnew = false;
    if(n < NINFO)	/* this will do for now, we need something better here */
        isnew = true;

    sprint(buf, "%s/draw/%d/data", dev, atoi(info+0*12));
    datafd = open(buf, ORDWR|OCEXEC);

    if(datafd < 0)
        goto Error2;

    sprint(buf, "%s/draw/%d/refresh", dev, atoi(info+0*12));
    reffd = open(buf, OREAD|OCEXEC);

    if(reffd < 0){
    Error3:
        close(datafd);
        goto Error2;
    }

    disp = mallocz(sizeof(Display), 1);

    if(disp == nil){
    Error4:
        close(reffd);
        goto Error3;
    }

    image = nil;
    if(0){
    Error5:
        free(image);
        free(disp);
        goto Error4;
    }
    if(n >= NINFO){
        image = mallocz(sizeof(Image), 1);
        if(image == nil)
            goto Error5;
        image->display = disp;
        image->id = 0; // info+1*12 but should always be 0
        image->chan = strtochan(info+2*12);
        image->depth = chantodepth(image->chan);
        image->repl = atoi(info+3*12);
        image->r.min.x = atoi(info+4*12);
        image->r.min.y = atoi(info+5*12);
        image->r.max.x = atoi(info+6*12);
        image->r.max.y = atoi(info+7*12);
        image->clipr.min.x = atoi(info+8*12);
        image->clipr.min.y = atoi(info+9*12);
        image->clipr.max.x = atoi(info+10*12);
        image->clipr.max.y = atoi(info+11*12);
    }

    disp->_isnewdisplay = isnew;

    disp->bufsize = iounit(datafd);
    if(disp->bufsize <= 0)
        disp->bufsize = 8000;
    if(disp->bufsize < 512){
        werrstr("iounit %d too small", disp->bufsize);
        goto Error5;
    }
    disp->buf = malloc(disp->bufsize+5);	/* +5 for flush message */
    if(disp->buf == nil)
        goto Error5;

    disp->image = image;
    disp->dirno = atoi(info+0*12);
    disp->fd    = datafd;
    disp->ctlfd = ctlfd;
    disp->reffd = reffd;
    disp->bufp = disp->buf;
    disp->error = error;
    disp->windir = t;
    disp->devdir = strdup(dev);

    qlock(&disp->qlock);
    disp->white = allocimage(disp, Rect(0, 0, 1, 1), GREY1, 1, DWhite);
    disp->black = allocimage(disp, Rect(0, 0, 1, 1), GREY1, 1, DBlack);
    if(disp->white == nil || disp->black == nil){
        free(disp->devdir);
        free(disp->white);
        free(disp->black);
        goto Error5;
    }
    disp->opaque = disp->white;
    disp->transparent = disp->black;

    dir = dirfstat(ctlfd);
    if(dir!=nil && dir->type=='i'){
        disp->local = 1;
        disp->dataqid = dir->qid.path;
    }
    if(dir!=nil && dir->qid.vers==1)	/* other way to tell */
        disp->_isnewdisplay = 1;
    free(dir);

    return disp;
}
@



<<[[initdisplay()]] check arguments validity>>=
if(dev == nil)
    dev = "/dev";
if(win == nil)
    win = "/dev";

if(strlen(dev)>sizeof buf-25 || strlen(win)>sizeof buf-25){
    werrstr("initdisplay: directory name too long");
    return nil;
}
t = strdup(win);
if(t == nil)
    return nil;
@





\subsection{[[closedisplay()]]}

<<function closedisplay>>=
/*
 * Call with d unlocked.
 * Note that disp->defaultfont and defaultsubfont are not freed here.
 */
void
closedisplay(Display *disp)
{
    _closedisplay(disp, 0);
}
@

<<function _closedisplay>>=
static void
_closedisplay(Display *disp, int isshutdown)
{
    int fd;
    char buf[128];

    if(disp == nil)
        return;
    if(disp == display)
        display = nil;
    if(disp->oldlabel[0]){
        snprint(buf, sizeof buf, "%s/label", disp->windir);
        fd = open(buf, OWRITE);
        if(fd >= 0){
            write(fd, disp->oldlabel, strlen(disp->oldlabel));
            close(fd);
        }
    }

    /*
     * if we're shutting down, don't free all the resources.
     * if other procs are getting shot down by notes too,
     * one might get shot down while holding the malloc lock.
     * just let the kernel clean things up when we exit.
     */
    if(isshutdown)
        return;

    free(disp->devdir);
    free(disp->windir);
    freeimage(disp->white);
    freeimage(disp->black);
    close(disp->fd);
    close(disp->ctlfd);
    /* should cause refresh slave to shut down */
    close(disp->reffd);
    qunlock(&disp->qlock);
    free(disp);
}
@

\section{Fonts}

<<[[geninitdraw()]] set up font>>=
/*
 * Set up default font
 */
df = getdefont(display);
display->defaultsubfont = df;
if(df == nil){
    fprint(2, "imageinit: can't open default subfont: %r\n");
Error:
    closedisplay(display);
    display = nil;
    return -1;
}
if(fontname == nil){
    fd = open("/env/font", OREAD);
    if(fd >= 0){
        n = read(fd, buf, sizeof(buf));
        if(n>0 && n<sizeof buf-1){
            buf[n] = 0;
            fontname = buf;
        }
        close(fd);
    }
}
/*
 * Build fonts with caches==depth of screen, for speed.
 * If conversion were faster, we'd use 0 and save memory.
 */
if(fontname == nil){
    snprint(buf, sizeof buf, "%d %d\n0 %d\t%s\n", df->height, df->ascent,
        df->n-1, deffontname);
 //BUG: Need something better for this	installsubfont("*default*", df);
    font = buildfont(display, buf, deffontname);
    if(font == nil){
        fprint(2, "imageinit: can't open default font: %r\n");
        goto Error;
    }
}else{
    font = openfont(display, fontname);	/* BUG: grey fonts */
    if(font == nil){
        fprint(2, "imageinit: can't open font %s: %r\n", fontname);
        goto Error;
    }
}
display->defaultfont = font;
@

\section{Label}

<<[[geninitdraw()]] write label>>=
/*
 * Write label; ignore errors (we might not be running under rio)
 */
if(label){
    snprint(buf, sizeof buf, "%s/label", display->windir);
    fd = open(buf, OREAD);
    if(fd >= 0){
        read(fd, display->oldlabel, (sizeof display->oldlabel)-1);
        close(fd);
        fd = create(buf, OWRITE, 0666);
        if(fd >= 0){
            write(fd, label, strlen(label));
            close(fd);
        }
    }
}
@

\section{Screen}

<<[[geninitdraw()]] get window>>=
snprint(buf, sizeof buf, "%s/winname", display->windir);
if(gengetwindow(display, buf, &view, &screen, ref) < 0)
    goto Error;
@
% ???

<<function gengetwindow>>=
/*
 * Attach, or possibly reattach, to window.
 * If reattaching, maintain value of screen pointer.
 */
int
gengetwindow(Display *d, char *winname, Image **winp, Screen **scrp, int ref)
{
    int n, fd;
    char buf[64+1];
    Image *image;
    Rectangle r;

    fd = open(winname, OREAD);
    if(fd<0 || (n=read(fd, buf, sizeof buf-1))<=0){
        if((image=d->image) == nil){
            fprint(2, "gengetwindow: %r\n");
            *winp = nil;
            d->screenimage = nil;
            return -1;
        }
        strcpy(buf, "noborder");
    }else{
        close(fd);
        buf[n] = '\0';
        if(*winp != nil){
            _freeimage1(*winp);
            freeimage((*scrp)->image);
            freescreen(*scrp);
            *scrp = nil;
        }
        image = namedimage(d, buf);
        if(image == 0){
            fprint(2, "namedimage %s failed: %r\n", buf);
            *winp = nil;
            d->screenimage = nil;
            return -1;
        }
        assert(image->chan != 0);
    }

    d->screenimage = image;
    *scrp = allocscreen(image, d->white, 0);
    if(*scrp == nil){
        freeimage(d->screenimage);
        *winp = nil;
        d->screenimage = nil;
        return -1;
    }

    r = image->r;
    if(strncmp(buf, "noborder", 8) != 0)
        r = insetrect(image->r, Borderwidth);
    *winp = _allocwindow(*winp, *scrp, r, ref, DWhite);
    if(*winp == nil){
        freescreen(*scrp);
        *scrp = nil;
        freeimage(image);
        d->screenimage = nil;
        return -1;
    }
    d->screenimage = *winp;
    assert((*winp)->chan != 0);
    return 1;
}
@


<<function getwindow>>=
int
getwindow(Display *d, int ref)
{
    char winname[128];

    snprint(winname, sizeof winname, "%s/winname", d->windir);
    return gengetwindow(d, winname, &view, &screen, ref);
}
@

\chapter{User/Kernel Bridge}

% some kind of RPC and protocol
% todo: lots of boilerplate code, would be better to use thrift in the end
% lots of marshalling/unmarshalling boilerplate with BPLONG and so on.
% file interface is nice but limited in the end. Or maybe can just
% write a thrift like tool on top of the file interface that generates
% most of the boilerplate at least.

\section{Draw device}

% so bind #i

<<global drawdevtab>>=
Dev drawdevtab = {
    .dc       =    'i',
    .name     =    "draw",

    .attach   =    drawattach,
    .walk     =    drawwalk,
    .open     =    drawopen,
    .close    =    drawclose,
    .read     =    drawread,
    .write    =    drawwrite,
    .stat     =    drawstat,
    .wstat    =    devwstat,
               
    .reset    =    devreset,
    .init     =    devinit,
    .shutdown =    devshutdown,
    .create   =    devcreate,
    .bread    =    devbread,
    .bwrite   =    devbwrite,
    .remove   =    devremove,
};
@

% Seen drawattach() in previous section already.
% Need understand part of Kernel.nw.

\subsection{[[/dev/draw/new]]}
% and Client?


\subsection{[[/dev/draw/x/data]]}
% and DImage?

\section{Draw message protocol}
% pipeline?

\subsection{API}

\subsection{Marshalling}

<<function BGSHORT>>=
#define	BGSHORT(p)		(((p)[0]<<0) | ((p)[1]<<8))
@
<<function BGLONG>>=
#define	BGLONG(p)		((BGSHORT(p)<<0) | (BGSHORT(p+2)<<16))
@
<<function BPSHORT>>=
#define	BPSHORT(p, v)		((p)[0]=(v), (p)[1]=((v)>>8))
@
<<function BPLONG>>=
#define	BPLONG(p, v)		(BPSHORT(p, (v)), BPSHORT(p+2, (v)>>16))
@

% could start by a simple example? like flush?


<<[[Display]] buffer related fields>>=
// drawing operatings to write in /dev/draw/x/data until flush
// array<byte>
byte	*buf;
int		bufsize;
// index in Display.buf array
byte	*bufp;
@

% when want to write a "message" of size n, get a pointer to the
% next free byte in the buffer
<<function bufimage>>=
byte*
bufimage(Display *d, int n)
{
    uchar *p;

    if(n < 0 || n > d->bufsize){
        werrstr("bad count in bufimage");
        return nil;
    }
    if(d->bufp+n >  d->buf + d->bufsize)
        if(doflush(d) < 0)
            return nil;
    p = d->bufp;
    d->bufp += n;
    return p;
}
@

\subsection{Unmarshalling and [[drawmesg()]]}

<<[[drawmesg()]] locals>>=
byte *a;
int m = 0;
char *fmt = nil;
@
% m is for storing how much bytes were read for this message,
% so the loop on the buffer can go on and process the next message

<<[[drawmesg()]] locals>>=
int c, repl, y, dstid, scrnid, ni, ci, j, nw, e0, e1, op, ox, oy, oesize, esize, doflush;
byte *u, refresh;
ulong value, chan;
Rectangle r, clipr;
Point p, q, *pp, sp;
Memimage *i, *bg, *dst, *src, *mask;
Memimage *l, **lp;
Memscreen *scrn;
DImage *font, *ll, *di, *ddst, *dsrc;
DName *dn;
DScreen *dscrn;
FChar *fc;
Refx *refx;
CScreen *cs;
Refreshfn reffn;
@


% the big one!! this is in kernel!!
% ??? -> <>
<<function drawmesg>>=
void
drawmesg(Client *client, void *av, int n)
{
    <<[[drawmesg()]] locals>>

    a = av;
    if(waserror()){
        if(fmt) 
            printmesg(fmt, a, 1);
    /*  iprint("error: %s\n", up->errstr);  */
        nexterror();
    }
    while((n-=m) > 0){
        USED(fmt);
        a += m;
        switch(*a){
        <<[[drawmesg()]] cases>>
        default:
            error("bad draw command");
        }
    }
    poperror();
}
@


% unmarshallers helpers:

% drawrectangle(), etc

\subsection{Algorithm}
% Memory Algorithm?

\subsection{Optional hardware support}
% hook?

% via screen and then VGAscr and then VGAdev interfaces
% (and also VGAcur interface)

\section{Screen interface}
% screen.h

%\section{VGA interface}
% or VGA screen? meh maybe, simpler to just have a
% framebuffer
% vga.h

\section{Graphic card}
% Graphic VGA card?
% there is also the VGA interface, which is something different

\chapter{Image}

% fundamental piece! image, rectangle, mask.
% screen is an image, colors are images!! point are images,
% tiles are images, background are special images.

% can have multiple image, draw there, and at some point
% quickly copy on main image (d->image)
% the initial d->image is actually allocated for you

% but first how allocate them?
% (got a first image allocated for you when open draw device, 'screen')

\section{Allocation}

\subsection{API}

% for a color r is usually R(0,0,1,1), chan is view->chan, repl = 1,
% and val is the color
<<function allocimage>>=
Image*
allocimage(Display *d, Rectangle r, ulong chan, bool repl, ulong val)
{
    Image*	i;

    i =  _allocimage(nil, d, r, chan, repl, val, 0, 0);
    if (i)
        setmalloctag(i, getcallerpc(&d));
    return i;
}
@

<<function freeimage>>=
int
freeimage(Image *i)
{
    int ret;

    ret = _freeimage1(i);
    free(i);
    return ret;
}
@
%todo: why not _freeimage? be consistent at least

<<function allocimagemix>>=
Image*
allocimagemix(Display *d, ulong color1, ulong color3)
{
    Image *t, *b;
    static Image *qmask;

    if(qmask == nil)
        qmask = allocimage(d, Rect(0,0,1,1), GREY8, 1, 0x3F3F3FFF);
        
    if(d->screenimage->depth <= 8){	/* create a 2x2 texture */
        t = allocimage(d, Rect(0,0,1,1), d->screenimage->chan, 0, color1);
        if(t == nil)
            return nil;

        b = allocimage(d, Rect(0,0,2,2), d->screenimage->chan, 1, color3);
        if(b == nil){
            freeimage(t);
            return nil;
        }

        draw(b, Rect(0,0,1,1), t, nil, ZP);
        freeimage(t);
        return b;
    }else{	/* use a solid color, blended using alpha */
        t = allocimage(d, Rect(0,0,1,1), d->screenimage->chan, 1, color1);
        if(t == nil)
            return nil;

        b = allocimage(d, Rect(0,0,1,1), d->screenimage->chan, 1, color3);
        if(b == nil){
            freeimage(t);
            return nil;
        }

        draw(b, b->r, t, qmask, ZP);
        freeimage(t);
        return b;
    }
}
@


\subsection{Marshalling}

% ai usually nil
<<function _allocimage>>=
Image*
_allocimage(Image *ai, Display *d, Rectangle r, ulong chan, bool repl, ulong val, int screenid, int refresh)
{
    byte *a;
    char *err;
    Image *i;
    Rectangle clipr;
    int id;
    int depth;

    err = 0;
    i = 0;

    if(chan == 0){
        werrstr("bad channel descriptor");
        return nil;
    }

    depth = chantodepth(chan);
    if(depth == 0){
        err = "bad channel descriptor";
    Error:
        if(err)
            werrstr("allocimage: %s", err);
        else
            werrstr("allocimage: %r");
        free(i);
        return 0;
    }

    /* flush pending data so we don't get error allocating the image */
    flushimage(d, false);

    a = bufimage(d, 1+4+4+1+4+1+4*4+4*4+4);
    if(a == nil)
        goto Error;
    d->imageid++;
    id = d->imageid;

    a[0] = 'b';
    BPLONG(a+1, id);
    BPLONG(a+5, screenid);
    a[9] = refresh;
    BPLONG(a+10, chan);
    a[14] = repl;
    BPLONG(a+15, r.min.x);
    BPLONG(a+19, r.min.y);
    BPLONG(a+23, r.max.x);
    BPLONG(a+27, r.max.y);
    if(repl)
        /* huge but not infinite, so various offsets will leave it huge, not overflow */
        clipr = Rect(-0x3FFFFFFF, -0x3FFFFFFF, 0x3FFFFFFF, 0x3FFFFFFF);
    else
        clipr = r;
    BPLONG(a+31, clipr.min.x);
    BPLONG(a+35, clipr.min.y);
    BPLONG(a+39, clipr.max.x);
    BPLONG(a+43, clipr.max.y);
    BPLONG(a+47, val);

    if(flushimage(d, false) < 0)
        goto Error;

    if(ai)
        i = ai;
    else{
        i = malloc(sizeof(Image));
        if(i == nil){
            a = bufimage(d, 1+4);
            if(a){
                a[0] = 'f';
                BPLONG(a+1, id);
                flushimage(d, false);
            }
            goto Error;
        }
    }

    i->display = d;
    i->id = id;
    i->depth = depth;
    i->chan = chan;
    i->r = r;
    i->clipr = clipr;
    i->repl = repl;
    i->screen = nil;
    i->next = nil;
    return i;
}
@


<<function _freeimage1>>=
int
_freeimage1(Image *i)
{
    byte *a;
    Display *d;
    Image *w;

    if(i == nil || i->display == nil)
        return 0;

    /* make sure no refresh events occur on this if we block in the write */
    d = i->display;
    /* flush pending data so we don't get error deleting the image */
    flushimage(d, false);

    a = bufimage(d, 1+4);
    if(a == nil)
        return -1;

    a[0] = 'f';
    BPLONG(a+1, i->id);

    if(i->screen){
        // remove_list(i, d->windows)
        w = d->windows;
        if(w == i)
            d->windows = i->next;
        else
            while(w){
                if(w->next == i){
                    w->next = i->next;
                    break;
                }
                w = w->next;
            }
    }
    if(flushimage(d, i->screen!=0) < 0)
        return -1;

    return 0;
}
@

\subsection{Unmarshalling}

<<enum _anon_ (include/draw.h)2>>=
enum
{
    /* refresh methods */
    Refbackup	= 0,
    Refnone		= 1,
    Refmesg		= 2 // incomplete apparently
};
@


<<[[drawmesg()]] cases>>=
/* new allocate: 'b' id[4] screenid[4] refresh[1] chan[4] repl[1] R[4*4] clipR[4*4] rrggbbaa[4] */
case 'b':
    printmesg(fmt="LLbLbRRL", a, 0);
    m = 1+4+4+1+4+1+4*4+4*4+4;
    if(n < m)
        error(Eshortdraw);
    dstid = BGLONG(a+1);
    scrnid = BGSHORT(a+5);
    refresh = a[9];
    chan = BGLONG(a+10);
    repl = a[14];
    drawrectangle(&r, a+15);
    drawrectangle(&clipr, a+31);
    value = BGLONG(a+47);
    if(drawlookup(client, dstid, 0))
        error(Eimageexists);

    <<[[drawmesg()]] allocate image case, if screen id>>

    i = allocmemimage(r, chan); // The call

    if(i == nil)
        error(Edrawmem);
    if(repl)
        i->flags |= Frepl;
    i->clipr = clipr;
    if(!repl)
        rectclip(&i->clipr, r);

    if(drawinstall(client, dstid, i, 0) == 0){
        freememimage(i);
        error(Edrawmem);
    }
    memfillcolor(i, value); // The call
    continue;
@


<<[[drawmesg()]] cases>>=
/* free: 'f' id[4] */
case 'f':
    printmesg(fmt="L", a, 1);
    m = 1+4;
    if(n < m)
        error(Eshortdraw);
    ll = drawlookup(client, BGLONG(a+1), 0);

    if(ll && ll->dscreen && ll->dscreen->owner != client)
        ll->dscreen->owner->refreshme = 1;

    drawuninstall(client, BGLONG(a+1)); // The call

    continue;
@




\subsection{Algorithm}

% allocimage -> _allocimage -> drawmesg -> <>
%Memdata and then Memimage ctor
% should be called once automatically when one creates a new connection no?
<<function allocmemimage>>=
Memimage*
allocmemimage(Rectangle r, ulong chan)
{
    int d;
    uchar *p;
    ulong l, nw;
    Memdata *md;
    Memimage *i;

    if((d = chantodepth(chan)) == 0) {
        werrstr("bad channel descriptor %.8lux", chan);
        return nil;
    }

    l = wordsperline(r, d);
    nw = l*Dy(r);
    md = malloc(sizeof(Memdata));
    if(md == nil)
        return nil;

    md->ref = 1;
    // the big alloc!
    md->base = poolalloc(imagmem, sizeof(Memdata*)+(1+nw)*sizeof(ulong));
    if(md->base == nil){
        free(md);
        return nil;
    }

    p = (uchar*)md->base;
    *(Memdata**)p = md;
    p += sizeof(Memdata*);

    *(ulong*)p = getcallerpc(&r);
    p += sizeof(ulong);

    /* if this changes, memimagemove must change too */
    md->bdata = p;
    md->allocd = 1;

    i = allocmemimaged(r, chan, md);
    if(i == nil){
        poolfree(imagmem, md->base);
        free(md);
        return nil;
    }
    md->imref = i;
    return i;
}
@

<<function wordsperline>>=
int
wordsperline(Rectangle r, int d)
{
    return unitsperline(r, d, 8*sizeof(ulong));
}
@

<<function bytesperline>>=
int
bytesperline(Rectangle r, int d)
{
    return unitsperline(r, d, 8);
}
@

<<function unitsperline>>=
static
int
unitsperline(Rectangle r, int d, int bitsperunit)
{
    ulong l, t;

    if(d <= 0 || d > 32)	/* being called wrong.  d is image depth. */
        abort();

    if(r.min.x >= 0){
        l = (r.max.x*d+bitsperunit-1)/bitsperunit;
        l -= (r.min.x*d)/bitsperunit;
    }else{			/* make positive before divide */
        t = (-r.min.x*d+bitsperunit-1)/bitsperunit;
        l = t+(r.max.x*d+bitsperunit-1)/bitsperunit;
    }
    return l;
}
@

% allocmemimage -> <>
%Memimage ctor (smaller malloc, just a wrapper over Memdata)
<<function allocmemimaged>>=
Memimage*
allocmemimaged(Rectangle r, ulong chan, Memdata *md)
{
    int d;
    ulong l;
    Memimage *i;

    if(Dx(r) <= 0 || Dy(r) <= 0){
        werrstr("bad rectangle %R", r);
        return nil;
    }
    if((d = chantodepth(chan)) == 0) {
        werrstr("bad channel descriptor %.8lux", chan);
        return nil;
    }

    l = wordsperline(r, d);

    i = mallocz(sizeof(Memimage), 1);
    if(i == nil)
        return nil;

    i->data = md;
    i->zero = sizeof(ulong)*l*r.min.y;
    
    if(r.min.x >= 0)
        i->zero += (r.min.x*d)/8;
    else
        i->zero -= (-r.min.x*d+7)/8;
    i->zero = -i->zero;
    i->width = l;
    i->r = r;
    i->clipr = r;
    i->flags = 0;
    i->layer = nil;
    i->cmap = memdefcmap;

    if(memsetchan(i, chan) < 0){
        free(i);
        return nil;
    }
    return i;
}
@
% memimaged? d?


<<function freememimage>>=
void
freememimage(Memimage *i)
{
    if(i == nil)
        return;
    if(i->data->ref-- == 1 && i->data->allocd){
        if(i->data->base)
            poolfree(imagmem, i->data->base);
        free(i->data);
    }
    free(i);
}
@


<<function memfillcolor>>=
void
memfillcolor(Memimage *i, ulong val)
{
    ulong bits;
    int d, y;

    if(val == DNofill)
        return;

    bits = rgbatoimg(i, val);
    switch(i->depth){
    case 24:	/* 24-bit images suck */
        for(y=i->r.min.y; y<i->r.max.y; y++)
            memset24(byteaddr(i, Pt(i->r.min.x, y)), bits, Dx(i->r));
        break;
    default:	/* 1, 2, 4, 8, 16, 32 */
        for(d=i->depth; d<32; d*=2)
            bits = (bits << d) | bits;
        memsetl(wordaddr(i, i->r.min), bits, i->width*Dy(i->r));
        break;
    }
}
@
% >>

\subsection{Client and Memimage connection}

<<function drawinstall>>=
Memimage*
drawinstall(Client *client, int id, Memimage *i, DScreen *dscreen)
{
    DImage *d;

    d = allocdimage(i);
    if(d == nil)
        return nil;
    d->id = id;
    d->dscreen = dscreen;
    d->next = client->dimage[id&HASHMASK];
    client->dimage[id&HASHMASK] = d;
    return i;
}
@

<<function allocdimage>>=
DImage*
allocdimage(Memimage *i)
{
    DImage *d;

    d = malloc(sizeof(DImage));
    if(d == 0)
        return 0;
    d->ref = 1;
    d->name = 0;
    d->vers = 0;
    d->image = i;
    d->nfchar = 0;
    d->fchar = 0;
    d->fromname = 0;
    return d;
}
@


<<function drawuninstall>>=
void
drawuninstall(Client *client, int id)
{
    DImage *d, *next;

    d = client->dimage[id&HASHMASK];
    if(d == 0)
        error(Enodrawimage);
    if(d->id == id){
        client->dimage[id&HASHMASK] = d->next;
        drawfreedimage(d);
        return;
    }
    while(next = d->next){  /* assign = */
        if(next->id == id){
            d->next = next->next;
            drawfreedimage(next);
            return;
        }
        d = next;
    }
    error(Enodrawimage);
}
@


<<function drawfreedimage>>=
void
drawfreedimage(DImage *dimage)
{
    int i;
    Memimage *l;
    DScreen *ds;

    dimage->ref--;
    if(dimage->ref < 0)
        print("negative ref in drawfreedimage\n");
    if(dimage->ref > 0)
        return;

    /* any names? */
    for(i=0; i<sdraw.nname; )
        if(sdraw.name[i].dimage == dimage)
            drawdelname(sdraw.name+i);
        else
            i++;
    if(dimage->fromname){   /* acquired by name; owned by someone else*/
        drawfreedimage(dimage->fromname);
        goto Return;
    }
//  if(dimage->image == screenimage)    /* don't free the display */
//      goto Return;
    ds = dimage->dscreen;
    if(ds){
        l = dimage->image;
        if(l->data == screenimage->data)
            addflush(l->layer->screenr);
        if(l->layer->refreshfn == drawrefresh)  /* else true owner will clean up */
            free(l->layer->refreshptr);
        l->layer->refreshptr = nil;
        if(drawgoodname(dimage))
            memldelete(l);
        else
            memlfree(l);
        drawfreedscreen(ds);
    }else
        freememimage(dimage->image);
    Return:
    free(dimage->fchar);
    free(dimage);
}
@

\section{Clipping}

% clipping is fundamental graphics operation. Very useful
% generic functionality. Like narrow mode in emacs :)

% called by many, to optimize things, e.g. no need to flush some modif
% if rectangle outside the clipping area.
% modify the first parameter when they overlap to match the intersection
% flushmemscreen -> <>
<<function rectclip>>=
bool
rectclip(Rectangle *rp, Rectangle b)		/* first by reference, second by value */
{
    Rectangle *bp = &b;
    /*
     * Expand rectXrect() in line for speed
     */
    if((rp->min.x < bp->max.x && bp->min.x < rp->max.x &&
        rp->min.y < bp->max.y && bp->min.y < rp->max.y)==false)
        return false;

    /* They must overlap */
    if(rp->min.x < bp->min.x)
        rp->min.x = bp->min.x;
    if(rp->min.y < bp->min.y)
        rp->min.y = bp->min.y;
    if(rp->max.x > bp->max.x)
        rp->max.x = bp->max.x;
    if(rp->max.y > bp->max.y)
        rp->max.y = bp->max.y;
    return true;
}
@

\subsection{API}

<<function replclipr>>=
void
replclipr(Image *i, int repl, Rectangle clipr)
{
    uchar *b;

    b = bufimage(i->display, 22);
    b[0] = 'c';
    BPLONG(b+1, i->id);
    repl = repl!=0;
    b[5] = repl;
    BPLONG(b+6, clipr.min.x);
    BPLONG(b+10, clipr.min.y);
    BPLONG(b+14, clipr.max.x);
    BPLONG(b+18, clipr.max.y);
    i->repl = repl;
    i->clipr = clipr;
}
@

\subsection{Marshalling}

\subsection{Unmarshalling}

<<[[drawmesg()]] cases>>=
/* set repl and clip: 'c' dstid[4] repl[1] clipR[4*4] */
case 'c':
    printmesg(fmt="LbR", a, 0);
    m = 1+4+1+4*4;
    if(n < m)
        error(Eshortdraw);
    ddst = drawlookup(client, BGLONG(a+1), 1);
    if(ddst == nil)
        error(Enodrawimage);
    if(ddst->name)
        error("cannot change repl/clipr of shared image");
    dst = ddst->image;
    if(a[5])
        dst->flags |= Frepl;

    drawrectangle(&dst->clipr, a+6); // The call

    continue;

@

\subsection{Algorithm}

% the call is actually drawrectangle which really just parse
% a rectangle, so the call is actually to modify dst->clipr


% ?? -> <>?
<<function drawclip>>=
/*
 * Clip the destination rectangle further based on the properties of the 
 * source and mask rectangles.  Once the destination rectangle is properly
 * clipped, adjust the source and mask rectangles to be the same size.
 * Then if source or mask is replicated, move its clipped rectangle
 * so that its minimum point falls within the repl rectangle.
 *
 * Return zero if the final rectangle is null.
 */
int
drawclip(Memimage *dst, Rectangle *r, Memimage *src, Point *p0, Memimage *mask, Point *p1, Rectangle *sr, Rectangle *mr)
{
    Point rmin, delta;
    int splitcoords;
    Rectangle omr;

    if(r->min.x>=r->max.x || r->min.y>=r->max.y)
        return 0;
    splitcoords = (p0->x!=p1->x) || (p0->y!=p1->y);
    /* clip to destination */
    rmin = r->min;
    if(!rectclip(r, dst->r) || !rectclip(r, dst->clipr))
        return 0;
    /* move mask point */
    p1->x += r->min.x-rmin.x;
    p1->y += r->min.y-rmin.y;
    /* move source point */
    p0->x += r->min.x-rmin.x;
    p0->y += r->min.y-rmin.y;
    /* map destination rectangle into source */
    sr->min = *p0;
    sr->max.x = p0->x+Dx(*r);
    sr->max.y = p0->y+Dy(*r);
    /* sr is r in source coordinates; clip to source */
    if(!(src->flags&Frepl) && !rectclip(sr, src->r))
        return 0;
    if(!rectclip(sr, src->clipr))
        return 0;
    /* compute and clip rectangle in mask */
    if(splitcoords){
        /* move mask point with source */
        p1->x += sr->min.x-p0->x;
        p1->y += sr->min.y-p0->y;
        mr->min = *p1;
        mr->max.x = p1->x+Dx(*sr);
        mr->max.y = p1->y+Dy(*sr);
        omr = *mr;
        /* mr is now rectangle in mask; clip it */
        if(!(mask->flags&Frepl) && !rectclip(mr, mask->r))
            return 0;
        if(!rectclip(mr, mask->clipr))
            return 0;
        /* reflect any clips back to source */
        sr->min.x += mr->min.x-omr.min.x;
        sr->min.y += mr->min.y-omr.min.y;
        sr->max.x += mr->max.x-omr.max.x;
        sr->max.y += mr->max.y-omr.max.y;
        *p1 = mr->min;
    }else{
        if(!(mask->flags&Frepl) && !rectclip(sr, mask->r))
            return 0;
        if(!rectclip(sr, mask->clipr))
            return 0;
        *p1 = sr->min;
    }

    /* move source clipping back to destination */
    delta.x = r->min.x - p0->x;
    delta.y = r->min.y - p0->y;
    r->min.x = sr->min.x + delta.x;
    r->min.y = sr->min.y + delta.y;
    r->max.x = sr->max.x + delta.x;
    r->max.y = sr->max.y + delta.y;

    /* move source rectangle so sr->min is in src->r */
    if(src->flags&Frepl) {
        delta.x = drawreplxy(src->r.min.x, src->r.max.x, sr->min.x) - sr->min.x;
        delta.y = drawreplxy(src->r.min.y, src->r.max.y, sr->min.y) - sr->min.y;
        sr->min.x += delta.x;
        sr->min.y += delta.y;
        sr->max.x += delta.x;
        sr->max.y += delta.y;
    }
    *p0 = sr->min;

    /* move mask point so it is in mask->r */
    *p1 = drawrepl(mask->r, *p1);
    mr->min = *p1;
    mr->max.x = p1->x+Dx(*sr);
    mr->max.y = p1->y+Dy(*sr);

    assert(Dx(*sr) == Dx(*mr) && Dx(*mr) == Dx(*r));
    assert(Dy(*sr) == Dy(*mr) && Dy(*mr) == Dy(*r));
    assert(ptinrect(*p0, src->r));
    assert(ptinrect(*p1, mask->r));
    assert(ptinrect(r->min, dst->r));

    return 1;
}
@



% drawrepl | drawclip -> <>
<<function drawreplxy>>=
int
drawreplxy(int min, int max, int x)
{
    int sx;

    sx = (x-min)%(max-min);
    if(sx < 0)
        sx += max-min;
    return sx+min;
}
@

% drawclip | drawmask -> <>
<<function drawrepl>>=
Point
drawrepl(Rectangle r, Point p)
{
    p.x = drawreplxy(r.min.x, r.max.x, p.x);
    p.y = drawreplxy(r.min.y, r.max.y, p.y);
    return p;
}
@


\section{Channels and alpha}


% allocmemimage -> allocmemimaged -> <>
%less: mv in Alloc section?
<<function memsetchan>>=
int
memsetchan(Memimage *i, ulong chan)
{
    int d;
    int t, j, k;
    ulong cc;
    int bytes;

    if((d = chantodepth(chan)) == 0) {
        werrstr("bad channel descriptor");
        return -1;
    }

    i->depth = d;
    i->chan = chan;
    i->flags &= ~(Fgrey|Falpha|Fcmap|Fbytes);
    bytes = 1;
    for(cc=chan, j=0, k=0; cc; j+=NBITS(cc), cc>>=8, k++){
        t=TYPE(cc);
        if(t < 0 || t >= NChan){
            werrstr("bad channel string");
            return -1;
        }
        if(t == CGrey)
            i->flags |= Fgrey;
        if(t == CAlpha)
            i->flags |= Falpha;
        if(t == CMap && i->cmap == nil){
            i->cmap = memdefcmap;
            i->flags |= Fcmap;
        }

        i->shift[t] = j;
        i->mask[t] = (1<<NBITS(cc))-1;
        i->nbits[t] = NBITS(cc);
        if(NBITS(cc) != 8)
            bytes = 0;
    }
    i->nchan = k;
    if(bytes)
        i->flags |= Fbytes;
    return 0;
}
@
% >>



%\subsection{Algorithm}

<<function alphadraw>>=
/*
 * For each scan line, we expand the pixels from source, mask, and destination
 * into byte-aligned red, green, blue, alpha, and grey channels.  If buffering is not
 * needed and the channels were already byte-aligned (grey8, rgb24, rgba32, rgb32),
 * the readers need not copy the data: they can simply return pointers to the data.
 * If the destination image is grey and the source is not, it is converted using the NTSC
 * formula.
 *
 * Once we have all the channels, we call either rgbcalc or greycalc, depending on 
 * whether the destination image is color.  This is allowed to overwrite the dst buffer (perhaps
 * the actual data, perhaps a copy) with its result.  It should only overwrite the dst buffer
 * with the same format (i.e. red bytes with red bytes, etc.)  A new buffer is returned from
 * the calculator, and that buffer is passed to a function to write it to the destination.
 * If the buffer is already pointing at the destination, the writing function is a no-op.
 */
static int
alphadraw(Memdrawparam *par)
{
    int isgrey, starty, endy, op;
    int needbuf, dsty, srcy, masky;
    int y, dir, dx, dy, ndrawbuf;
    uchar *drawbuf;
    Buffer bsrc, bdst, bmask;
    Readfn *rdsrc, *rdmask, *rddst;
    Calcfn *calc;
    Writefn *wrdst;
    Memimage *src, *mask, *dst;
    Rectangle r, sr, mr;
    Dbuf *z;

    r = par->r;
    dx = Dx(r);
    dy = Dy(r);

    z = allocdbuf();
    if(z == nil)
        return 0;

    src = par->src;
    mask = par->mask;	
    dst = par->dst;
    sr = par->sr;
    mr = par->mr;
    op = par->op;

    isgrey = dst->flags&Fgrey;

    /*
     * Buffering when src and dst are the same bitmap is sufficient but not 
     * necessary.  There are stronger conditions we could use.  We could
     * check to see if the rectangles intersect, and if simply moving in the
     * correct y direction can avoid the need to buffer.
     */
    needbuf = (src->data == dst->data);

    ndrawbuf = 0;
    getparam(&z->spar, src, sr, isgrey, needbuf, &ndrawbuf);
    getparam(&z->dpar, dst, r, isgrey, needbuf, &ndrawbuf);
    getparam(&z->mpar, mask, mr, 0, needbuf, &ndrawbuf);

    dir = (needbuf && byteaddr(dst, r.min) > byteaddr(src, sr.min)) ? -1 : 1;
    z->spar.dir = z->mpar.dir = z->dpar.dir = dir;

    /*
     * If the mask is purely boolean, we can convert from src to dst format
     * when we read src, and then just copy it to dst where the mask tells us to.
     * This requires a boolean (1-bit grey) mask and lack of a source alpha channel.
     *
     * The computation is accomplished by assigning the function pointers as follows:
     *	rdsrc - read and convert source into dst format in a buffer
     * 	rdmask - convert mask to bytes, set pointer to it
     * 	rddst - fill with pointer to real dst data, but do no reads
     *	calc - copy src onto dst when mask says to.
     *	wrdst - do nothing
     * This is slightly sleazy, since things aren't doing exactly what their names say,
     * but it avoids a fair amount of code duplication to make this a case here
     * rather than have a separate booldraw.
     */
//if(drawdebug) iprint("flag %lud mchan %lux=?%x dd %d\n", src->flags&Falpha, mask->chan, GREY1, dst->depth);
    if(!(src->flags&Falpha) && mask->chan == GREY1 && dst->depth >= 8 && op == SoverD){
//if(drawdebug) iprint("boolcopy...");
        rdsrc = convfn(dst, &z->dpar, src, &z->spar, &ndrawbuf);
        rddst = readptr;
        rdmask = readfn(mask);
        calc = boolcopyfn(dst, mask);
        wrdst = nullwrite;
    }else{
        /* usual alphadraw parameter fetching */
        rdsrc = readfn(src);
        rddst = readfn(dst);
        wrdst = writefn(dst);
        calc = alphacalc[op];

        /*
         * If there is no alpha channel, we'll ask for a grey channel
         * and pretend it is the alpha.
         */
        if(mask->flags&Falpha){
            rdmask = readalphafn(mask);
            z->mpar.alphaonly = 1;
        }else{
            z->mpar.greymaskcall = readfn(mask);
            z->mpar.convgrey = 1;
            rdmask = greymaskread;

            /*
             * Should really be above, but then boolcopyfns would have
             * to deal with bit alignment, and I haven't written that.
             *
             * This is a common case for things like ellipse drawing.
             * When there's no alpha involved and the mask is boolean,
             * we can avoid all the division and multiplication.
             */
            if(mask->chan == GREY1 && !(src->flags&Falpha))
                calc = boolcalc[op];
            else if(op == SoverD && !(src->flags&Falpha))
                calc = alphacalcS;
        }
    }

    /*
     * If the image has a small enough repl rectangle,
     * we can just read each line once and cache them.
     */
    if(z->spar.replcache){
        z->spar.replcall = rdsrc;
        rdsrc = replread;
    }
    if(z->mpar.replcache){
        z->mpar.replcall = rdmask;
        rdmask = replread;
    }

    if(z->n < ndrawbuf){
        free(z->p);
        if((z->p = mallocz(ndrawbuf, 0)) == nil){
            z->inuse = 0;
            return 0;
        }
        z->n = ndrawbuf;
    }
    drawbuf = z->p;

    /*
     * Before we were saving only offsets from drawbuf in the parameter
     * structures; now that drawbuf has been grown to accomodate us,
     * we can fill in the pointers.
     */
    z->spar.bufbase = drawbuf+z->spar.bufoff;
    z->mpar.bufbase = drawbuf+z->mpar.bufoff;
    z->dpar.bufbase = drawbuf+z->dpar.bufoff;
    z->spar.convbuf = drawbuf+z->spar.convbufoff;

    if(dir == 1){
        starty = 0;
        endy = dy;
    }else{
        starty = dy-1;
        endy = -1;
    }

    /*
     * srcy, masky, and dsty are offsets from the top of their
     * respective Rectangles.  they need to be contained within
     * the rectangles, so clipy can keep them there without division.
   */
    srcy = (starty + sr.min.y - src->r.min.y)%Dy(src->r);
    masky = (starty + mr.min.y - mask->r.min.y)%Dy(mask->r);
    dsty = starty + r.min.y - dst->r.min.y;

    assert(0 <= srcy && srcy < Dy(src->r));
    assert(0 <= masky && masky < Dy(mask->r));
    assert(0 <= dsty && dsty < Dy(dst->r));

    for(y=starty; y!=endy; y+=dir, srcy+=dir, masky+=dir, dsty+=dir){
        clipy(src, &srcy);
        clipy(dst, &dsty);
        clipy(mask, &masky);

        bsrc = rdsrc(&z->spar, z->spar.bufbase, srcy);
        //DBG print("[");
        bmask = rdmask(&z->mpar, z->mpar.bufbase, masky);
        //DBG print("]\n");
        bdst = rddst(&z->dpar, z->dpar.bufbase, dsty);
        //DBG		dumpbuf("src", bsrc, dx);
        //DBG		dumpbuf("mask", bmask, dx);
        //DBG		dumpbuf("dst", bdst, dx);
        bdst = calc(bdst, bsrc, bmask, dx, isgrey, op);
        wrdst(&z->dpar, z->dpar.bytermin+dsty*z->dpar.bwidth, bdst);
    }

    z->inuse = 0;
    return 1;
}
@

\section{Drawing}

% rectangle is fundamental ops. area. copy/move/blend pixels from one
% aera to another.
% no need complex algo, horiz and vert lines map well to pixels.
% draw()! no need complex shape algorithm, just
% move all the words covering a rectangle

% draw is fundamenta op!
% very flexibly.
% put technicolor.ps nice slides with draw(of actual images like in racket)

\subsection{API}

%TODO: show toy program and screenshot of the rectangle!


% see plan9-in-technicolor.ps! bitblt and porter-diff compositing algebra
<<function draw>>=
void
draw(Image *dst, Rectangle r, Image *src, Image *mask, Point p1)
{
    draw1(dst, &r, src, &p1, mask, &p1, SoverD);
}
@

% images are colors! e.g. Display->black
% see toy app

<<function border>>=
void
border(Image *im, Rectangle r, int i, Image *color, Point sp)
{
    if(i < 0){
        r = insetrect(r, i);
        sp = addpt(sp, Pt(i,i));
        i = -i;
    }
    draw(im, Rect(r.min.x, r.min.y, r.max.x, r.min.y+i),
        color, nil, sp);
    draw(im, Rect(r.min.x, r.max.y-i, r.max.x, r.max.y),
        color, nil, Pt(sp.x, sp.y+Dy(r)-i));
    draw(im, Rect(r.min.x, r.min.y+i, r.min.x+i, r.max.y-i),
        color, nil, Pt(sp.x, sp.y+i));
    draw(im, Rect(r.max.x-i, r.min.y+i, r.max.x, r.max.y-i),
        color, nil, Pt(sp.x+Dx(r)-i, sp.y+i));
}
@


<<function drawop>>=
void
drawop(Image *dst, Rectangle r, Image *src, Image *mask, Point p1, Drawop op)
{
    draw1(dst, &r, src, &p1, mask, &p1, op);
}
@

% actually this is the one mentionned in the technicolor.ps slides
<<function gendraw>>=
void
gendraw(Image *dst, Rectangle r, Image *src, Point p0, Image *mask, Point p1)
{
    draw1(dst, &r, src, &p0, mask, &p1, SoverD);
}
@

<<function gendrawop>>=
void
gendrawop(Image *dst, Rectangle r, Image *src, Point p0, Image *mask, Point p1, Drawop op)
{
    draw1(dst, &r, src, &p0, mask, &p1, op);
}
@



\subsection{Marshalling}

% why not _draw? be more consistent
<<function draw1>>=
static void
draw1(Image *dst, Rectangle *r, Image *src, Point *p0, Image *mask, Point *p1, Drawop op)
{
    byte *a;

    _setdrawop(dst->display, op);

    a = bufimage(dst->display, 1+4+4+4+4*4+2*4+2*4);
    if(a == nil)
        return;
    if(src == nil)
        src = dst->display->black;
    if(mask == nil)
        mask = dst->display->opaque;

    a[0] = 'd';
    BPLONG(a+1, dst->id);
    BPLONG(a+5, src->id);
    BPLONG(a+9, mask->id);
    BPLONG(a+13, r->min.x);
    BPLONG(a+17, r->min.y);
    BPLONG(a+21, r->max.x);
    BPLONG(a+25, r->max.y);
    BPLONG(a+29, p0->x);
    BPLONG(a+33, p0->y);
    BPLONG(a+37, p1->x);
    BPLONG(a+41, p1->y);
}
@


<<function _setdrawop>>=
void
_setdrawop(Display *d, Drawop op)
{
    uchar *a;

    if(op != SoverD){
        a = bufimage(d, 1+1);
        if(a == 0)
            return;
        a[0] = 'O';
        a[1] = op;
    }
}
@


\subsection{Unmarshalling}


<<[[drawmesg()]] cases>>=
/* draw: 'd' dstid[4] srcid[4] maskid[4] R[4*4] P[2*4] P[2*4] */
case 'd':
    printmesg(fmt="LLLRPP", a, 0);
    m = 1+4+4+4+4*4+2*4+2*4;
    if(n < m)
        error(Eshortdraw);
    dst = drawimage(client, a+1);
    dstid = BGLONG(a+1);
    src = drawimage(client, a+5);
    mask = drawimage(client, a+9);
    drawrectangle(&r, a+13);
    drawpoint(&p, a+29);
    drawpoint(&q, a+37);

    op = drawclientop(client);
    memdraw(dst, r, src, p, mask, q, op); // the call!

    dstflush(dstid, dst, r);
    continue;

@


<<function drawclientop>>=
static int
drawclientop(Client *cl)
{
    int op;

    op = cl->op;
    cl->op = SoverD;
    return op;
}
@


<<[[drawmesg()]] cases>>=
/* set compositing operator for next draw operation: 'O' op */
case 'O':
    printmesg(fmt="b", a, 0);
    m = 1+1;
    if(n < m)
        error(Eshortdraw);
    client->op = a[1];
    continue;
@





% dead? not even mentionned in the draw(5)
% and nothing generate such a message
%<<[[drawmesg()]] cases>>=
%/* create image mask: 'm' newid[4] id[4] */
%case 'm':
%    printmesg("LL", a, 0);
%    m = 4+4;
%    if(n < m)
%        error(Eshortdraw);
%    break;
%@


\subsection{Algorithm}

<<struct Draw>>=
struct Draw
{
    Point	deltas;
    Point	deltam;

    Memimage	*src;
    Memimage	*mask;

    int	op;

    <<[[Draw]] other fields>>
};
@

% actually in memlayer/
<<function memdraw>>=
void
memdraw(Memimage *dst, Rectangle r, Memimage *src, Point p0, Memimage *mask, Point p1, int op)
{
    struct Draw d;
    Rectangle srcr, tr, mr;
    Memlayer *dl, *sl;

    if(drawdebug)
        iprint("memdraw %p %R %p %P %p %P\n", dst, r, src, p0, mask, p1);

    if(mask == nil)
        mask = memopaque;

    <<[[memdraw()]] if mask has layer>>

    Top:
    if(dst->layer==nil && src->layer==nil){
        memimagedraw(dst, r, src, p0, mask, p1, op); // back to memdraw
        return;
    }
    <<[[memdraw()]] when have layers>>
}
@


% back to memdraw/
% TODO cleanup the comments, use better debug macro
<<function memimagedraw>>=
void
memimagedraw(Memimage *dst, Rectangle r, Memimage *src, Point p0, Memimage *mask, Point p1, int op)
{
    static int n = 0;
    Memdrawparam par;

    if(mask == nil)
        mask = memopaque;

    //DBG	print("memimagedraw %p/%luX %R @ %p %p/%luX %P %p/%luX %P... ", dst, dst->chan, r, dst->data->bdata, src, src->chan, p0, mask, mask->chan, p1);

    if(drawclip(dst, &r, src, &p0, mask, &p1, &par.sr, &par.mr) == 0){
//		if(drawdebug)
//			iprint("empty clipped rectangle\n");
        return;
    }

    if(op < Clear || op > SoverD){
//		if(drawdebug)
//			iprint("op out of range: %d\n", op);
        return;
    }

    par.op = op;
    par.dst = dst;
    par.r = r;
    par.src = src;
    /* par.sr set by drawclip */
    par.mask = mask;
    /* par.mr set by drawclip */

    par.state = 0;
    if(src->flags&Frepl){
        par.state |= Replsrc;
        if(Dx(src->r)==1 && Dy(src->r)==1){
            par.sval = pixelbits(src, src->r.min);
            par.state |= Simplesrc;
            par.srgba = imgtorgba(src, par.sval);
            par.sdval = rgbatoimg(dst, par.srgba);
            if((par.srgba&0xFF) == 0 && (op&DoutS)){
//				if (drawdebug) iprint("fill with transparent source\n");
                return;	/* no-op successfully handled */
            }
        }
    }

    if(mask->flags & Frepl){
        par.state |= Replmask;
        if(Dx(mask->r)==1 && Dy(mask->r)==1){
            par.mval = pixelbits(mask, mask->r.min);
            if(par.mval == 0 && (op&DoutS)){
//				if(drawdebug) iprint("fill with zero mask\n");
                return;	/* no-op successfully handled */
            }
            par.state |= Simplemask;
            if(par.mval == ~0)
                par.state |= Fullmask;
            par.mrgba = imgtorgba(mask, par.mval);
        }
    }

//	if(drawdebug)
//		iprint("dr %R sr %R mr %R...", r, par.sr, par.mr);
    //DBG print("draw dr %R sr %R mr %R %lux\n", r, par.sr, par.mr, par.state);

    /*
     * Now that we've clipped the parameters down to be consistent, we 
     * simply try sub-drawing routines in order until we find one that was able
     * to handle us.  If the sub-drawing routine returns zero, it means it was
     * unable to satisfy the request, so we do not return.
     */

    /*
     * Hardware support.  Each video driver provides this function,
     * which checks to see if there is anything it can help with.
     * There could be an if around this checking to see if dst is in video memory.
     */
    //DBG print("test hwdraw\n");
    if(hwdraw(&par)){
//if(drawdebug) iprint("hw handled\n");
      //DBG print("hwdraw handled\n");
        return;
    }
    /*
     * Optimizations using memmove and memset.
     */
    //DBG print("test memoptdraw\n");
    if(memoptdraw(&par)){
//if(drawdebug) iprint("memopt handled\n");
      //DBG print("memopt handled\n");
        return;
    }

    /*
     * Character drawing.
     * Solid source color being painted through a boolean mask onto a high res image.
     */
    //DBG print("test chardraw\n");
    if(chardraw(&par)){
//if(drawdebug) iprint("chardraw handled\n");
      //DBG print("chardraw handled\n");
        return;
    }

    /*
     * General calculation-laden case that does alpha for each pixel.
     */
    //DBG print("do alphadraw\n");
    alphadraw(&par);
//if(drawdebug) iprint("alphadraw handled\n");
    //DBG print("alphadraw handled\n");
}
@



\subsection{Hardware support hook}
% but really optional, bcm/screen.c does nothing except
% calling the software cursor save/restore.

% vgascreen.c
<<global hwaccel(x86)>>=
int hwaccel = true;
@


% * Hardware support.  Each video driver provides this function,
% * which checks to see if there is anything it can help with.
% * There could be an if around this checking to see if dst is in video memo
r
% vgascreen.c
<<function hwdraw(x86)>>=
//@Scheck: not dead, actually this is overriding some def in libmemdraw!! ugly
bool hwdraw(Memdrawparam *par)
{
    VGAscr *scr;
    Memimage *dst, *src, *mask;
    int m;

    if(hwaccel == false)
        return false;

    scr = &vgascreen;

    if((dst=par->dst) == nil || dst->data == nil)
        return false;
    if((src=par->src) == nil || src->data == nil)
        return false;
    if((mask=par->mask) == nil || mask->data == nil)
        return false;

    <<[[hwdraw()]] if software cursor(x86)>>
    
    if(dst->data->bdata != gscreendata.bdata)
        return false;




    if(scr->fill==nil && scr->scroll==nil)
        return false;
    /*
     * If we have an opaque mask and source is one opaque
     * pixel we can convert to the destination format and just
     * replicate with memset.
     */
    m = Simplesrc|Simplemask|Fullmask;
    if(scr->fill
    && (par->state&m)==m
    && ((par->srgba&0xFF) == 0xFF)
    && (par->op&S) == S)
        return scr->fill(scr, par->r, par->sdval);

    /*
     * If no source alpha, an opaque mask, we can just copy the
     * source onto the destination.  If the channels are the same and
     * the source is not replicated, memmove suffices.
     */
    m = Simplemask|Fullmask;
    if(scr->scroll
    && src->data->bdata==dst->data->bdata
    && !(src->flags&Falpha)
    && (par->state&m)==m
    && (par->op&S) == S)
        return scr->scroll(scr, par->r, par->sr);

    return false;   
}
@

% TODO: maybe assume simple screen device, like for raspberry,
% and where it's actually a framebuffer where hwdraw does nothing
% except the software cursor stuff.

% TODO put scroll or fill method here?

\section{Flush}

\subsection{API}

% visible argument??
% seems errorneg because called do if(flushimage() < 0)
<<function flushimage>>=
int
flushimage(Display *d, bool visible)
{
    if(d == nil)
        return 0;
    if(visible){
        *d->bufp++ = 'v';	/* five bytes always reserved for this */
        if(d->_isnewdisplay){
            BPLONG(d->bufp, d->screenimage->id);
            d->bufp += 4;
        }
    }
    return doflush(d);
}
@

\subsection{Marshalling}

% why not _flushimage? because this one we actually write stuff!
% we not just modify buffer. we send it to the device!
<<function doflush>>=
static
errorneg1
doflush(Display *d)
{
    int n, nn;

    n = d->bufp-d->buf;
    if(n <= 0)
        return OK_1;

    nn=write(d->fd, d->buf, n);
    if(nn != n){
        if(_drawdebug)
            fprint(2, "flushimage fail: d=%p: n=%d nn=%d %r\n", d, n, nn); /**/
        d->bufp = d->buf;	/* might as well; chance of continuing */
        return ERROR_NEG1;
    }
    d->bufp = d->buf;
    return OK_1;
}
@

\subsection{Unmarshalling}

<<[[drawmesg()]] cases>>=
/* visible: 'v' */
case 'v':
    printmesg(fmt="", a, 0);
    m = 1;
    drawflush();
    continue;

@


\subsection{Algorithm}

% who sets that?
<<global flushrect>>=
static  Rectangle   flushrect;
@

<<function drawflush>>=
void
drawflush(void)
{
    if(flushrect.min.x < flushrect.max.x)
        flushmemscreen(flushrect);
    flushrect = Rect(10000, 10000, -10000, -10000);
}
@

\subsection{Hardware support hook}

% on bcm/ this is a noop as write in the framebuffer are already
% flushed ... it's a direct connection.

% 386/vgascreen.c!
% drawflush | many more functions (e.g. swcursorhide) -> <>
<<function flushmemscreen(x86)>>=
/*
 * It would be fair to say that this doesn't work for >8-bit screens.
 */
void
flushmemscreen(Rectangle r)
{
    VGAscr *scr;
    uchar *sp, *disp, *sdisp, *edisp;
    int y, len, incs, off, page;

    scr = &vgascreen;

    // call the device driver flush hook
    if(scr->dev && scr->dev->flush){
        scr->dev->flush(scr, r);
        return;
    }

    if(gscreen == nil || scr->useflush == false)
        return;
    if(scr->dev == nil || scr->dev->page == nil)
        return;
    if(rectclip(&r, gscreen->r) == 0)
        return;

    incs = gscreen->width * BY2WD;

    switch(gscreen->depth){
    case 8:
        len = Dx(r);
        break;
    default:
        len = 0;
        panic("flushmemscreen: depth\n");
        break;
    }
    if(len < 1)
        return;

    off = r.min.y * gscreen->width * BY2WD 
           + (r.min.x * gscreen->depth)/8;
    page = off/scr->apsize;
    off %= scr->apsize;
    disp = scr->vaddr;
    sdisp = disp+off;
    edisp = disp+scr->apsize;

    off = r.min.y * gscreen->width * BY2WD
           + (r.min.x * gscreen->depth)/8;

    sp = gscreendata.bdata + off;

    // call device driver again, for subpart
    scr->dev->page(scr, page);

    for(y = r.min.y; y < r.max.y; y++) {
        if(sdisp + incs < edisp) {
            memmove(sdisp, sp, len);
            sp += incs;
            sdisp += incs;
        }
        else {
            off = edisp - sdisp;
            page++;
            if(off <= len){
                if(off > 0)
                    memmove(sdisp, sp, off);

                // call device driver again, for subpart
                scr->dev->page(scr, page);
                if(len - off > 0)
                    memmove(disp, sp+off, len - off);
            }
            else {
                memmove(sdisp, sp, len);
                // call device driver again, for subpart
                scr->dev->page(scr, page);
            }
            sp += incs;
            sdisp += incs - scr->apsize;
        }
    }
}
@

% TODO put flush or page here?


\section{Naming}

\subsection{API}

<<function nameimage>>=
int
nameimage(Image *i, char *name, int in)
{
    uchar *a;
    int n;

    n = strlen(name);
    a = bufimage(i->display, 1+4+1+1+n);
    if(a == 0)
        return 0;
    a[0] = 'N';
    BPLONG(a+1, i->id);
    a[5] = in;
    a[6] = n;
    memmove(a+7, name, n);
    if(flushimage(i->display, false) < 0)
        return 0;
    return 1;
}
@

<<function namedimage>>=
Image*
namedimage(Display *d, char *name)
{
    uchar *a;
    char *err, buf[12*12+1];
    Image *i;
    int id, n;
    ulong chan;

    err = 0;
    i = 0;

    n = strlen(name);
    if(n >= 256){
        err = "name too long";
    Error:
        if(err)
            werrstr("namedimage: %s", err);
        else
            werrstr("namedimage: %r");
        if(i)
            free(i);
        return nil;
    }
    /* flush pending data so we don't get error allocating the image */
    flushimage(d, false);
    a = bufimage(d, 1+4+1+n);
    if(a == 0)
        goto Error;
    d->imageid++;
    id = d->imageid;

    a[0] = 'n';
    BPLONG(a+1, id);
    a[5] = n;
    memmove(a+6, name, n);

    if(flushimage(d, false) < 0)
        goto Error;

    if(pread(d->ctlfd, buf, sizeof buf, 0) < 12*12)
        goto Error;
    buf[12*12] = '\0';

    i = malloc(sizeof(Image));
    if(i == nil){
    Error1:
        a = bufimage(d, 1+4);
        if(a){
            a[0] = 'f';
            BPLONG(a+1, id);
            flushimage(d, false);
        }
        goto Error;
    }
    i->display = d;
    i->id = id;
    if((chan=strtochan(buf+2*12))==0){
        werrstr("bad channel '%.12s' from devdraw", buf+2*12);
        goto Error1;
    }
    i->chan = chan;
    i->depth = chantodepth(chan);
    i->repl = atoi(buf+3*12);
    i->r.min.x = atoi(buf+4*12);
    i->r.min.y = atoi(buf+5*12);
    i->r.max.x = atoi(buf+6*12);
    i->r.max.y = atoi(buf+7*12);
    i->clipr.min.x = atoi(buf+8*12);
    i->clipr.min.y = atoi(buf+9*12);
    i->clipr.max.x = atoi(buf+10*12);
    i->clipr.max.y = atoi(buf+11*12);
    i->screen = 0;
    i->next = 0;
    return i;
}
@


\subsection{Marshalling}

\subsection{Unmarshalling}

<<[[drawmesg()]] cases>>=
/* name an image: 'N' dstid[4] in[1] j[1] name[j] */
case 'N':
    printmesg(fmt="Lbz", a, 0);
    m = 1+4+1+1;
    if(n < m)
        error(Eshortdraw);
    c = a[5];
    j = a[6];
    if(j == 0)  /* give me a non-empty name please */
        error(Eshortdraw);
    m += j;
    if(n < m)
        error(Eshortdraw);
    di = drawlookup(client, BGLONG(a+1), 0);
    if(di == nil)
        error(Enodrawimage);
    if(di->name)
        error(Enamed);

    if(c)
        drawaddname(client, di, j, (char*)a+7); // The call?
    else{
        dn = drawlookupname(j, (char*)a+7);
        if(dn == nil)
            error(Enoname);
        if(dn->dimage != di)
            error(Ewrongname);
        drawdelname(dn);
    }
    continue;

@



<<[[drawmesg()]] cases>>=
/* attach to a named image: 'n' dstid[4] j[1] name[j] */
case 'n':
    printmesg(fmt="Lz", a, 0);
    m = 1+4+1;
    if(n < m)
        error(Eshortdraw);
    j = a[5];
    if(j == 0)  /* give me a non-empty name please */
        error(Eshortdraw);
    m += j;
    if(n < m)
        error(Eshortdraw);
    dstid = BGLONG(a+1);
    if(drawlookup(client, dstid, 0))
        error(Eimageexists);

    dn = drawlookupname(j, (char*)a+6); // The call?

    if(dn == nil)
        error(Enoname);
    if(drawinstall(client, dstid, dn->dimage->image, 0) == 0)
        error(Edrawmem);

    di = drawlookup(client, dstid, 0);
    if(di == nil)
        error("draw: cannot happen");
    di->vers = dn->vers;
    di->name = smalloc(j+1);
    di->fromname = dn->dimage;
    di->fromname->ref++;
    memmove(di->name, a+6, j);
    di->name[j] = 0;
    client->infoid = dstid;
    continue;

@

\subsection{Algorithm}

<<function drawaddname>>=
void
drawaddname(Client *client, DImage *di, int n, char *str)
{
    DName *name, *ename, *new, *t;

    name = sdraw.name;
    ename = &name[sdraw.nname];
    for(; name<ename; name++)
        if(drawcmp(name->name, str, n) == 0)
            error(Enameused);
    t = smalloc((sdraw.nname+1)*sizeof(DName));
    memmove(t, sdraw.name, sdraw.nname*sizeof(DName));
    free(sdraw.name);
    sdraw.name = t;
    new = &sdraw.name[sdraw.nname++];
    new->name = smalloc(n+1);
    memmove(new->name, str, n);
    new->name[n] = 0;
    new->dimage = di;
    new->client = client;
    new->vers = ++sdraw.vers;
}
@

<<function drawlookupname>>=
DName*
drawlookupname(int n, char *str)
{
    DName *name, *ename;

    name = sdraw.name;
    ename = &name[sdraw.nname];
    for(; name<ename; name++)
        if(drawcmp(name->name, str, n) == 0)
            return name;
    return 0;
}
@

<<function drawdelname>>=
void
drawdelname(DName *name)
{
    int i;

    i =  name - sdraw.name;
    memmove(name, name+1, (sdraw.nname-(i+1))*sizeof(DName));
    sdraw.nname--;
}
@



\chapter{Geometry}

\section{[[Point]]}

<<struct Point>>=
struct	Point
{
    int	x;
    int	y;
};
@
% int! they are pixels!

%ctor
<<function Pt>>=
Point
Pt(int x, int y)
{
    Point p;

    p.x = x;
    p.y = y;
    return p;
}
@


<<function eqpt>>=
int
eqpt(Point p, Point q)
{
    return p.x==q.x && p.y==q.y;
}
@


<<global ZP>>=
Point	ZP;
@



<<function addpt>>=
Point
addpt(Point a, Point b)
{
    a.x += b.x;
    a.y += b.y;
    return a;
}
@

<<function subpt>>=
Point
subpt(Point a, Point b)
{
    a.x -= b.x;
    a.y -= b.y;
    return a;
}
@

<<function mulpt>>=
Point
mulpt(Point a, int b)
{
    a.x *= b;
    a.y *= b;
    return a;
}
@

<<function divpt>>=
Point
divpt(Point a, int b)
{
    a.x /= b;
    a.y /= b;
    return a;
}
@


\section{[[Rectangle]]}

<<struct Rectangle>>=
struct Rectangle
{
    Point	min;
    Point	max;
};
@

% seen already operations with rectangle in Drawing

%ctor
<<function Rect>>=
Rectangle
Rect(int x, int y, int bx, int by)
{
    Rectangle r;

    r.min.x = x;
    r.min.y = y;
    r.max.x = bx;
    r.max.y = by;
    return r;
}
@

%ctor
<<function Rpt>>=
Rectangle
Rpt(Point min, Point max)
{
    Rectangle r;

    r.min = min;
    r.max = max;
    return r;
}
@




<<function eqrect>>=
int
eqrect(Rectangle r, Rectangle s)
{
    return r.min.x==s.min.x && r.max.x==s.max.x &&
           r.min.y==s.min.y && r.max.y==s.max.y;
}
@


<<global ZR>>=
Rectangle ZR;
@



<<function Dx>>=
#define	Dx(r)	((r).max.x-(r).min.x)
@

<<function Dy>>=
#define	Dy(r)	((r).max.y-(r).min.y)
@



<<function rectaddpt>>=
Rectangle
rectaddpt(Rectangle r, Point p)
{
    r.min.x += p.x;
    r.min.y += p.y;
    r.max.x += p.x;
    r.max.y += p.y;
    return r;
}
@

<<function rectsubpt>>=
Rectangle
rectsubpt(Rectangle r, Point p)
{
    r.min.x -= p.x;
    r.min.y -= p.y;
    r.max.x -= p.x;
    r.max.y -= p.y;
    return r;
}
@



<<function insetrect>>=
Rectangle
insetrect(Rectangle r, int n)
{
    r.min.x += n;
    r.min.y += n;
    r.max.x -= n;
    r.max.y -= n;
    return r;
}
@


<<function rectXrect>>=
int
rectXrect(Rectangle r, Rectangle s)
{
    return r.min.x<s.max.x && s.min.x<r.max.x &&
           r.min.y<s.max.y && s.min.y<r.max.y;
}
@

<<function rectinrect>>=
int
rectinrect(Rectangle r, Rectangle s)
{
    return s.min.x<=r.min.x && r.max.x<=s.max.x && s.min.y<=r.min.y && r.max.y<=s.max.y;
}
@

<<function ptinrect>>=
int
ptinrect(Point p, Rectangle r)
{
    return p.x>=r.min.x && p.x<r.max.x &&
           p.y>=r.min.y && p.y<r.max.y;
}
@


<<function canonrect>>=
Rectangle
canonrect(Rectangle r)
{
    int t;
    if (r.max.x < r.min.x) {
        t = r.min.x;
        r.min.x = r.max.x;
        r.max.x = t;
    }
    if (r.max.y < r.min.y) {
        t = r.min.y;
        r.min.y = r.max.y;
        r.max.y = t;
    }
    return r;
}
@

<<function combinerect>>=
void
combinerect(Rectangle *r1, Rectangle r2)
{
    if(r1->min.x > r2.min.x)
        r1->min.x = r2.min.x;
    if(r1->min.y > r2.min.y)
        r1->min.y = r2.min.y;
    if(r1->max.x < r2.max.x)
        r1->max.x = r2.max.x;
    if(r1->max.y < r2.max.y)
        r1->max.y = r2.max.y;
}
@




\section{Line}

%http://www.redblobgames.com/grids/line-drawing.html

\subsection{API}

%todo: typedef this!! typedef int endline; or use enu,?
<<function line>>=
void
line(Image *dst, Point p0, Point p1, int end0, int end1, int radius, Image *src, Point sp)
{
    lineop(dst, p0, p1, end0, end1, radius, src, sp, SoverD);
}
@

% maybe could be put in advanced topics?
<<enum _anon_ (include/draw.h)3>>=
enum
{
    /* line ends */
    Endsquare	= 0,
    Enddisc		= 1,
    Endarrow	= 2,

    Endmask		= 0x1F
};
@

<<function ARROW>>=
#define	ARROW(a, b, c)	(Endarrow|((a)<<5)|((b)<<14)|((c)<<23))
@
% see draw(2) for explanations

\subsection{Marshalling}

<<function lineop>>=
void
lineop(Image *dst, Point p0, Point p1, int end0, int end1, int radius, Image *src, Point sp, Drawop op)
{
    uchar *a;

    _setdrawop(dst->display, op);

    a = bufimage(dst->display, 1+4+2*4+2*4+4+4+4+4+2*4);
    if(a == 0){
        fprint(2, "image line: %r\n");
        return;
    }
    a[0] = 'L';
    BPLONG(a+1, dst->id);
    BPLONG(a+5, p0.x);
    BPLONG(a+9, p0.y);
    BPLONG(a+13, p1.x);
    BPLONG(a+17, p1.y);
    BPLONG(a+21, end0);
    BPLONG(a+25, end1);
    BPLONG(a+29, radius);
    BPLONG(a+33, src->id);
    BPLONG(a+37, sp.x);
    BPLONG(a+41, sp.y);
}
@

\subsection{Unmarshalling}

<<[[drawmesg()]] cases>>=
/* draw line: 'L' dstid[4] p0[2*4] p1[2*4] end0[4] end1[4] radius[4] srcid[4] sp[2*4] */
case 'L':
    printmesg(fmt="LPPlllLP", a, 0);
    m = 1+4+2*4+2*4+4+4+4+4+2*4;
    if(n < m)
        error(Eshortdraw);
    dst = drawimage(client, a+1);
    dstid = BGLONG(a+1);
    drawpoint(&p, a+5);
    drawpoint(&q, a+13);
    e0 = BGLONG(a+21);
    e1 = BGLONG(a+25);
    j = BGLONG(a+29);
    if(j < 0)
        error("negative line width");
    src = drawimage(client, a+33);
    drawpoint(&sp, a+37);
    op = drawclientop(client);

    memline(dst, p, q, e0, e1, j, src, sp, op); // The call

    /* avoid memlinebbox if possible */
    if(dstid==0 || dst->layer!=nil){
        /* BUG: this is terribly inefficient: update maximal containing rect*/
        r = memlinebbox(p, q, e0, e1, j);
        dstflush(dstid, dst, insetrect(r, -(1+1+j)));
    }
    continue;
@


\subsection{Algorithm}

<<struct Lline>>=
struct Lline
{
    Point			p0;
    Point			p1;
    Point			delta;
    int			end0;
    int			end1;
    int			radius;
    Point			sp;
    Memlayer		*dstlayer;
    Memimage	*src;
    int			op;
};
@

% memlayer/
<<function memline>>=
void
memline(Memimage *dst, Point p0, Point p1, int end0, int end1, int radius, Memimage *src, Point sp, int op)
{
    _memline(dst, p0, p1, end0, end1, radius, src, sp, dst->clipr, op);
}
@

<<function _memline>>=
static
void
_memline(Memimage *dst, Point p0, Point p1, int end0, int end1, int radius, Memimage *src, Point sp, Rectangle clipr, int op)
{
    Rectangle r;
    struct Lline ll;
    Point d;
    int srcclipped;
    Memlayer *dl;

    if(radius < 0)
        return;
    if(src->layer)	/* can't draw line with layered source */
        return;
    srcclipped = 0;

   Top:
    dl = dst->layer;
    if(dl == nil){
        // back to memdraw/
        _memimageline(dst, p0, p1, end0, end1, radius, src, sp, clipr, op);
        return;
    }
    <<[[_memline()]] when have layers>>
}
@





% was in draw.h, but probably could be moved in drawimpl.h
<<constant ICOSSCALE>>=
ICOSSCALE	= 1024,
@

% back to memdraw/
<<function _memimageline>>=
void
_memimageline(Memimage *dst, Point p0, Point p1, int end0, int end1, int radius, Memimage *src, Point sp, Rectangle clipr, int op)
{
    /*
     * BUG: We should really really pick off purely horizontal and purely
     * vertical lines and handle them separately with calls to memimagedraw
     * on rectangles.
     */

    int hor;
    int sin, cos, dx, dy, t;
    Rectangle oclipr, r;
    Point q, pts[10], *pp, d;

    if(radius < 0)
        return;
    if(rectclip(&clipr, dst->r) == 0)
        return;
    if(rectclip(&clipr, dst->clipr) == 0)
        return;
    d = subpt(sp, p0);
    if(rectclip(&clipr, rectsubpt(src->clipr, d)) == 0)
        return;
    if((src->flags&Frepl)==0 && rectclip(&clipr, rectsubpt(src->r, d))==0)
        return;
    /* this means that only verline() handles degenerate lines (p0==p1) */
    hor = (abs(p1.x-p0.x) > abs(p1.y-p0.y));
    /*
     * Clipping is a little peculiar.  We can't use Sutherland-Cohen
     * clipping because lines are wide.  But this is probably just fine:
     * we do all math with the original p0 and p1, but clip when deciding
     * what pixels to draw.  This means the layer code can call this routine,
     * using clipr to define the region being written, and get the same set
     * of pixels regardless of the dicing.
     */
    if((hor && p0.x>p1.x) || (!hor && p0.y>p1.y)){
        q = p0;
        p0 = p1;
        p1 = q;
        t = end0;
        end0 = end1;
        end1 = t;
    }

    if((p0.x == p1.x || p0.y == p1.y) && (end0&0x1F) == Endsquare && (end1&0x1F) == Endsquare){
        r.min = p0;
        r.max = p1;
        if(p0.x == p1.x){
            r.min.x -= radius;
            r.max.x += radius+1;
        }
        else{
            r.min.y -= radius;
            r.max.y += radius+1;
        }
        oclipr = dst->clipr;
        sp = addpt(r.min, d);
        dst->clipr = clipr;
        memimagedraw(dst, r, src, sp, memopaque, sp, op);
        dst->clipr = oclipr;
        return;
    }

/*    Hard: */
    /* draw thick line using polygon fill */
    icossin2(p1.x-p0.x, p1.y-p0.y, &cos, &sin);
    dx = (sin*(2*radius+1))/2;
    dy = (cos*(2*radius+1))/2;
    pp = pts;
    oclipr = dst->clipr;
    dst->clipr = clipr;
    q.x = ICOSSCALE*p0.x+ICOSSCALE/2-cos/2;
    q.y = ICOSSCALE*p0.y+ICOSSCALE/2-sin/2;
    switch(end0 & 0x1F){
    case Enddisc:
        discend(p0, radius, dst, src, d, op);
        /* fall through */
    case Endsquare:
    default:
        pp->x = q.x-dx;
        pp->y = q.y+dy;
        pp++;
        pp->x = q.x+dx;
        pp->y = q.y-dy;
        pp++;
        break;
    case Endarrow:
        arrowend(q, pp, end0, -sin, -cos, radius);
        _memfillpolysc(dst, pts, 5, ~0, src, addpt(pts[0], mulpt(d, ICOSSCALE)), 1, 10, 1, op);
        pp[1] = pp[4];
        pp += 2;
    }
    q.x = ICOSSCALE*p1.x+ICOSSCALE/2+cos/2;
    q.y = ICOSSCALE*p1.y+ICOSSCALE/2+sin/2;
    switch(end1 & 0x1F){
    case Enddisc:
        discend(p1, radius, dst, src, d, op);
        /* fall through */
    case Endsquare:
    default:
        pp->x = q.x+dx;
        pp->y = q.y-dy;
        pp++;
        pp->x = q.x-dx;
        pp->y = q.y+dy;
        pp++;
        break;
    case Endarrow:
        arrowend(q, pp, end1, sin, cos, radius);
        _memfillpolysc(dst, pp, 5, ~0, src, addpt(pp[0], mulpt(d, ICOSSCALE)), 1, 10, 1, op);
        pp[1] = pp[4];
        pp += 2;
    }
    _memfillpolysc(dst, pts, pp-pts, ~0, src, addpt(pts[0], mulpt(d, ICOSSCALE)), 0, 10, 1, op);
    dst->clipr = oclipr;
    return;
}
@


<<function discend>>=
static
void
discend(Point p, int radius, Memimage *dst, Memimage *src, Point dsrc, int op)
{
    Memimage *disc;
    Rectangle r;

    disc = membrush(radius);
    if(disc != nil){
        r.min.x = p.x - radius;
        r.min.y = p.y - radius;
        r.max.x = p.x + radius+1;
        r.max.y = p.y + radius+1;
        memdraw(dst, r, src, addpt(r.min, dsrc), disc, Pt(0,0), op);
    }
}
@

<<function membrush>>=
static Memimage*
membrush(int radius)
{
    static Memimage *brush;
    static int brushradius;

    if(brush==nil || brushradius!=radius){
        freememimage(brush);
        brush = allocmemimage(Rect(0, 0, 2*radius+1, 2*radius+1), memopaque->chan);
        if(brush != nil){
            memfillcolor(brush, DTransparent);	/* zeros */
            memellipse(brush, Pt(radius, radius), radius, radius, -1, memopaque, Pt(radius, radius), S);
        }
        brushradius = radius;
    }
    return brush;
}
@




<<function addbbox>>=
/*
 * Simple-minded conservative code to compute bounding box of line.
 * Result is probably a little larger than it needs to be.
 */
static
void
addbbox(Rectangle *r, Point p)
{
    if(r->min.x > p.x)
        r->min.x = p.x;
    if(r->min.y > p.y)
        r->min.y = p.y;
    if(r->max.x < p.x+1)
        r->max.x = p.x+1;
    if(r->max.y < p.y+1)
        r->max.y = p.y+1;
}
@

<<function memlineendsize>>=
int
memlineendsize(int end)
{
    int x3;

    if((end&0x3F) != Endarrow)
        return 0;
    if(end == Endarrow)
        x3 = Arrow3;
    else
        x3 = (end>>23) & 0x1FF;
    return x3;
}
@

<<function memlinebbox>>=
Rectangle
memlinebbox(Point p0, Point p1, int end0, int end1, int radius)
{
    Rectangle r, r1;
    int extra;

    r.min.x = 10000000;
    r.min.y = 10000000;
    r.max.x = -10000000;
    r.max.y = -10000000;
    extra = lmax(memlineendsize(end0), memlineendsize(end1));
    r1 = insetrect(canonrect(Rpt(p0, p1)), -(radius+extra));
    addbbox(&r, r1.min);
    addbbox(&r, r1.max);
    return r;
}
@

<<function lmax>>=
static
int
lmax(int a, int b)
{
    if(a > b)
        return a;
    return b;
}
@


\subsection{Arrows}

% advanced topics?
<<enum _anon_ (lib_graphics/libmemdraw/line.c)>>=
enum
{
    Arrow1 = 8,
    Arrow2 = 10,
    Arrow3 = 3,
};
@


<<function arrowend>>=
static
void
arrowend(Point tip, Point *pp, int end, int sin, int cos, int radius)
{
    int x1, x2, x3;

    /* before rotation */
    if(end == Endarrow){
        x1 = Arrow1;
        x2 = Arrow2;
        x3 = Arrow3;
    }else{
        x1 = (end>>5) & 0x1FF;	/* distance along line from end of line to tip */
        x2 = (end>>14) & 0x1FF;	/* distance along line from barb to tip */
        x3 = (end>>23) & 0x1FF;	/* distance perpendicular from edge of line to barb */
    }

    /* comments follow track of right-facing arrowhead */
    pp->x = tip.x+((2*radius+1)*sin/2-x1*cos);		/* upper side of shaft */
    pp->y = tip.y-((2*radius+1)*cos/2+x1*sin);
    pp++;
    pp->x = tip.x+((2*radius+2*x3+1)*sin/2-x2*cos);		/* upper barb */
    pp->y = tip.y-((2*radius+2*x3+1)*cos/2+x2*sin);
    pp++;
    pp->x = tip.x;
    pp->y = tip.y;
    pp++;
    pp->x = tip.x+(-(2*radius+2*x3+1)*sin/2-x2*cos);	/* lower barb */
    pp->y = tip.y-(-(2*radius+2*x3+1)*cos/2+x2*sin);
    pp++;
    pp->x = tip.x+(-(2*radius+1)*sin/2-x1*cos);		/* lower side of shaft */
    pp->y = tip.y+((2*radius+1)*cos/2-x1*sin);
}
@


\section{Polyline}

\subsection{API}

<<function poly>>=
void
poly(Image *dst, Point *p, int np, int end0, int end1, int radius, Image *src, Point sp)
{
    dopoly('p', dst, p, np, end0, end1, radius, src, &sp, SoverD);
}
@

<<function polyop>>=
void
polyop(Image *dst, Point *p, int np, int end0, int end1, int radius, Image *src, Point sp, Drawop op)
{
    dopoly('p', dst, p, np, end0, end1, radius, src, &sp, op);
}
@

<<function fillpoly>>=
void
fillpoly(Image *dst, Point *p, int np, int wind, Image *src, Point sp)
{
    dopoly('P', dst, p, np, wind, 0, 0, src, &sp, SoverD);
}
@

<<function fillpolyop>>=
void
fillpolyop(Image *dst, Point *p, int np, int wind, Image *src, Point sp, Drawop op)
{
    dopoly('P', dst, p, np, wind, 0, 0, src, &sp, op);
}
@

\subsection{Marshalling}

% why not _poly? more consistent
<<function dopoly>>=
static
void
dopoly(int cmd, Image *dst, Point *pp, int np, int end0, int end1, int radius, Image *src, Point *sp, Drawop op)
{
    uchar *a, *t, *u;
    int i, ox, oy;

    if(np == 0)
        return;
    t = malloc(np*2*3);
    if(t == nil)
        return;
    u = t;
    ox = oy = 0;
    for(i=0; i<np; i++){
        u = addcoord(u, ox, pp[i].x);
        ox = pp[i].x;
        u = addcoord(u, oy, pp[i].y);
        oy = pp[i].y;
    }

    _setdrawop(dst->display, op);

    a = bufimage(dst->display, 1+4+2+4+4+4+4+2*4+(u-t));
    if(a == 0){
        free(t);
        fprint(2, "image poly: %r\n");
        return;
    }
    a[0] = cmd;
    BPLONG(a+1, dst->id);
    BPSHORT(a+5, np-1);
    BPLONG(a+7, end0);
    BPLONG(a+11, end1);
    BPLONG(a+15, radius);
    BPLONG(a+19, src->id);
    BPLONG(a+23, sp->x);
    BPLONG(a+27, sp->y);
    memmove(a+31, t, u-t);
    free(t);
}
@

% dopoly -> <>
<<function addcoord>>=
static
uchar*
addcoord(uchar *p, int oldx, int newx)
{
    int dx;

    dx = newx-oldx;
    /* does dx fit in 7 signed bits? */
    if((unsigned)(dx - -0x40) <= 0x7F)
        *p++ = dx&0x7F;
    else{
        *p++ = 0x80 | (newx&0x7F);
        *p++ = newx>>7;
        *p++ = newx>>15;
    }
    return p;
}
@

\subsection{Unmarshalling}


<<[[drawmesg()]] cases>>=
/* filled polygon: 'P' dstid[4] n[2] wind[4] ignore[2*4] srcid[4] sp[2*4] p0[2*4] dp[2*2*n] */
/* polygon: 'p' dstid[4] n[2] end0[4] end1[4] radius[4] srcid[4] sp[2*4] p0[2*4] dp[2*2*n] */
case 'p':
case 'P':
    printmesg(fmt="LslllLPP", a, 0);
    m = 1+4+2+4+4+4+4+2*4;
    if(n < m)
        error(Eshortdraw);
    dstid = BGLONG(a+1);
    dst = drawimage(client, a+1);
    ni = BGSHORT(a+5);
    if(ni < 0)
        error("negative count in polygon");
    e0 = BGLONG(a+7);
    e1 = BGLONG(a+11);
    j = 0;
    if(*a == 'p'){
        j = BGLONG(a+15);
        if(j < 0)
            error("negative polygon line width");
    }
    src = drawimage(client, a+19);
    drawpoint(&sp, a+23);
    drawpoint(&p, a+31);
    ni++;
    pp = malloc(ni*sizeof(Point));
    if(pp == nil)
        error(Enomem);
    doflush = false;
    if(dstid==0 || (dst->layer && dst->layer->screen->image->data == screenimage->data))
        doflush = true;    /* simplify test in loop */
    ox = oy = 0;
    esize = 0;
    u = a+m;
    for(y=0; y<ni; y++){
        q = p;
        oesize = esize;
        u = drawcoord(u, a+n, ox, &p.x);
        u = drawcoord(u, a+n, oy, &p.y);
        ox = p.x;
        oy = p.y;
        if(doflush){
            esize = j;
            if(*a == 'p'){
                if(y == 0){
                    c = memlineendsize(e0);
                    if(c > esize)
                        esize = c;
                }
                if(y == ni-1){
                    c = memlineendsize(e1);
                    if(c > esize)
                        esize = c;
                }
            }
            if(*a=='P' && e0!=1 && e0 !=~0)
                r = dst->clipr;
            else if(y > 0){
                r = Rect(q.x-oesize, q.y-oesize, q.x+oesize+1, q.y+oesize+1);
                combinerect(&r, Rect(p.x-esize, p.y-esize, p.x+esize+1, p.y+esize+1));
            }
            if(rectclip(&r, dst->clipr))        /* should perhaps be an arg to dstflush */
                dstflush(dstid, dst, r);
        }
        pp[y] = p;
    }
    if(y == 1)
        dstflush(dstid, dst, Rect(p.x-esize, p.y-esize, p.x+esize+1, p.y+esize+1));
    op = drawclientop(client);

    if(*a == 'p')
        mempoly(dst, pp, ni, e0, e1, j, src, sp, op); // The call
    else
        memfillpoly(dst, pp, ni, e0, src, sp, op); // The call
    free(pp);
    m = u-a;
    continue;

@

\subsection{Algorithm}

<<struct Seg>>=
struct Seg
{
    Point	p0;
    Point	p1;
    long	num;
    long	den;
    long	dz;
    long	dzrem;
    long	z;
    long	zerr;
    long	d;
};
@

<<function mempoly>>=
void
mempoly(Memimage *dst, Point *vert, int nvert, int end0, int end1, int radius, Memimage *src, Point sp, int op)
{
    int i, e0, e1;
    Point d;

    if(nvert < 2)
        return;
    d = subpt(sp, vert[0]);
    for(i=1; i<nvert; i++){
        e0 = e1 = Enddisc;
        if(i == 1)
            e0 = end0;
        if(i == nvert-1)
            e1 = end1;
        memline(dst, vert[i-1], vert[i], e0, e1, radius, src, addpt(d, vert[i-1]), op);
    }
}
@

<<function memfillpoly>>=
void
memfillpoly(Memimage *dst, Point *vert, int nvert, int w, Memimage *src, Point sp, int op)
{
    _memfillpolysc(dst, vert, nvert, w, src, sp, 0, 0, 0, op);
}
@

<<function _memfillpolysc>>=
void
_memfillpolysc(Memimage *dst, Point *vert, int nvert, int w, Memimage *src, Point sp, int detail, int fixshift, int clipped, int op)
{
    Seg **seg, *segtab;
    Point p0;
    int i;

    if(nvert == 0)
        return;

    seg = malloc((nvert+2)*sizeof(Seg*));
    if(seg == nil)
        return;
    segtab = malloc((nvert+1)*sizeof(Seg));
    if(segtab == nil) {
        free(seg);
        return;
    }

    sp.x = (sp.x - vert[0].x) >> fixshift;
    sp.y = (sp.y - vert[0].y) >> fixshift;
    p0 = vert[nvert-1];
    if(!fixshift) {
        p0.x <<= 1;
        p0.y <<= 1;
    }
    for(i = 0; i < nvert; i++) {
        segtab[i].p0 = p0;
        p0 = vert[i];
        if(!fixshift) {
            p0.x <<= 1;
            p0.y <<= 1;
        }
        segtab[i].p1 = p0;
        segtab[i].d = 1;
    }
    if(!fixshift)
        fixshift = 1;

    xscan(dst, seg, segtab, nvert, w, src, sp, detail, fixshift, clipped, op);
    if(detail)
        yscan(dst, seg, segtab, nvert, w, src, sp, fixshift, op);

    free(seg);
    free(segtab);
}
@
% >> >> >> >>

<<function xscan>>=
static void
xscan(Memimage *dst, Seg **seg, Seg *segtab, int nseg, int wind, Memimage *src, Point sp, int detail, int fixshift, int clipped, int op)
{
    long y, maxy, x, x2, xerr, xden, onehalf;
    Seg **ep, **next, **p, **q, *s;
    long n, i, iy, cnt, ix, ix2, minx, maxx;
    Point pt;
    void	(*fill)(Memimage*, int, int, int, Memimage*, Point, int);

    fill = fillline;
/*
 * This can only work on 8-bit destinations, since fillcolor is
 * just using memset on sp.x.
 *
 * I'd rather not even enable it then, since then if the general
 * code is too slow, someone will come up with a better improvement
 * than this sleazy hack.	-rsc
 *
    if(clipped && (src->flags&Frepl) && src->depth==8 && Dx(src->r)==1 && Dy(src->r)==1) {
        fill = fillcolor;
        sp.x = membyteval(src);
    }
 *
 */
    USED(clipped);


    for(i=0, s=segtab, p=seg; i<nseg; i++, s++) {
        *p = s;
        if(s->p0.y == s->p1.y)
            continue;
        if(s->p0.y > s->p1.y) {
            pt = s->p0;
            s->p0 = s->p1;
            s->p1 = pt;
            s->d = -s->d;
        }
        s->num = s->p1.x - s->p0.x;
        s->den = s->p1.y - s->p0.y;
        s->dz = sdiv(s->num, s->den) << fixshift;
        s->dzrem = mod(s->num, s->den) << fixshift;
        s->dz += sdiv(s->dzrem, s->den);
        s->dzrem = mod(s->dzrem, s->den);
        p++;
    }
    n = p-seg;
    if(n == 0)
        return;
    *p = 0;
    qsort(seg, p-seg , sizeof(Seg*), ycompare);

    onehalf = 0;
    if(fixshift)
        onehalf = 1 << (fixshift-1);

    minx = dst->clipr.min.x;
    maxx = dst->clipr.max.x;

    y = seg[0]->p0.y;
    if(y < (dst->clipr.min.y << fixshift))
        y = dst->clipr.min.y << fixshift;
    iy = (y + onehalf) >> fixshift;
    y = (iy << fixshift) + onehalf;
    maxy = dst->clipr.max.y << fixshift;

    ep = next = seg;

    while(y<maxy) {
        for(q = p = seg; p < ep; p++) {
            s = *p;
            if(s->p1.y < y)
                continue;
            s->z += s->dz;
            s->zerr += s->dzrem;
            if(s->zerr >= s->den) {
                s->z++;
                s->zerr -= s->den;
                if(s->zerr < 0 || s->zerr >= s->den)
                    print("bad ratzerr1: %ld den %ld dzrem %ld\n", s->zerr, s->den, s->dzrem);
            }
            *q++ = s;
        }

        for(p = next; *p; p++) {
            s = *p;
            if(s->p0.y >= y)
                break;
            if(s->p1.y < y)
                continue;
            s->z = s->p0.x;
            s->z += smuldivmod(y - s->p0.y, s->num, s->den, &s->zerr);
            if(s->zerr < 0 || s->zerr >= s->den)
                print("bad ratzerr2: %ld den %ld ratdzrem %ld\n", s->zerr, s->den, s->dzrem);
            *q++ = s;
        }
        ep = q;
        next = p;

        if(ep == seg) {
            if(*next == 0)
                break;
            iy = (next[0]->p0.y + onehalf) >> fixshift;
            y = (iy << fixshift) + onehalf;
            continue;
        }

        zsort(seg, ep);

        for(p = seg; p < ep; p++) {
            cnt = 0;
            x = p[0]->z;
            xerr = p[0]->zerr;
            xden = p[0]->den;
            ix = (x + onehalf) >> fixshift;
            if(ix >= maxx)
                break;
            if(ix < minx)
                ix = minx;
            cnt += p[0]->d;
            p++;
            for(;;) {
                if(p == ep) {
                    print("xscan: fill to infinity");
                    return;
                }
                cnt += p[0]->d;
                if((cnt&wind) == 0)
                    break;
                p++;
            }
            x2 = p[0]->z;
            ix2 = (x2 + onehalf) >> fixshift;
            if(ix2 <= minx)
                continue;
            if(ix2 > maxx)
                ix2 = maxx;
            if(ix == ix2 && detail) {
                if(xerr*p[0]->den + p[0]->zerr*xden > p[0]->den*xden)
                    x++;
                ix = (x + x2) >> (fixshift+1);
                ix2 = ix+1;
            }
            (*fill)(dst, ix, ix2, iy, src, sp, op);
        }
        y += (1<<fixshift);
        iy++;
    }
}
@
% >>

<<function yscan>>=
static void
yscan(Memimage *dst, Seg **seg, Seg *segtab, int nseg, int wind, Memimage *src, Point sp, int fixshift, int op)
{
    long x, maxx, y, y2, yerr, yden, onehalf;
    Seg **ep, **next, **p, **q, *s;
    int n, i, ix, cnt, iy, iy2, miny, maxy;
    Point pt;

    for(i=0, s=segtab, p=seg; i<nseg; i++, s++) {
        *p = s;
        if(s->p0.x == s->p1.x)
            continue;
        if(s->p0.x > s->p1.x) {
            pt = s->p0;
            s->p0 = s->p1;
            s->p1 = pt;
            s->d = -s->d;
        }
        s->num = s->p1.y - s->p0.y;
        s->den = s->p1.x - s->p0.x;
        s->dz = sdiv(s->num, s->den) << fixshift;
        s->dzrem = mod(s->num, s->den) << fixshift;
        s->dz += sdiv(s->dzrem, s->den);
        s->dzrem = mod(s->dzrem, s->den);
        p++;
    }
    n = p-seg;
    if(n == 0)
        return;
    *p = 0;
    qsort(seg, n , sizeof(Seg*), xcompare);

    onehalf = 0;
    if(fixshift)
        onehalf = 1 << (fixshift-1);

    miny = dst->clipr.min.y;
    maxy = dst->clipr.max.y;

    x = seg[0]->p0.x;
    if(x < (dst->clipr.min.x << fixshift))
        x = dst->clipr.min.x << fixshift;
    ix = (x + onehalf) >> fixshift;
    x = (ix << fixshift) + onehalf;
    maxx = dst->clipr.max.x << fixshift;

    ep = next = seg;

    while(x<maxx) {
        for(q = p = seg; p < ep; p++) {
            s = *p;
            if(s->p1.x < x)
                continue;
            s->z += s->dz;
            s->zerr += s->dzrem;
            if(s->zerr >= s->den) {
                s->z++;
                s->zerr -= s->den;
                if(s->zerr < 0 || s->zerr >= s->den)
                    print("bad ratzerr1: %ld den %ld ratdzrem %ld\n", s->zerr, s->den, s->dzrem);
            }
            *q++ = s;
        }

        for(p = next; *p; p++) {
            s = *p;
            if(s->p0.x >= x)
                break;
            if(s->p1.x < x)
                continue;
            s->z = s->p0.y;
            s->z += smuldivmod(x - s->p0.x, s->num, s->den, &s->zerr);
            if(s->zerr < 0 || s->zerr >= s->den)
                print("bad ratzerr2: %ld den %ld ratdzrem %ld\n", s->zerr, s->den, s->dzrem);
            *q++ = s;
        }
        ep = q;
        next = p;

        if(ep == seg) {
            if(*next == 0)
                break;
            ix = (next[0]->p0.x + onehalf) >> fixshift;
            x = (ix << fixshift) + onehalf;
            continue;
        }

        zsort(seg, ep);

        for(p = seg; p < ep; p++) {
            cnt = 0;
            y = p[0]->z;
            yerr = p[0]->zerr;
            yden = p[0]->den;
            iy = (y + onehalf) >> fixshift;
            if(iy >= maxy)
                break;
            if(iy < miny)
                iy = miny;
            cnt += p[0]->d;
            p++;
            for(;;) {
                if(p == ep) {
                    print("yscan: fill to infinity");
                    return;
                }
                cnt += p[0]->d;
                if((cnt&wind) == 0)
                    break;
                p++;
            }
            y2 = p[0]->z;
            iy2 = (y2 + onehalf) >> fixshift;
            if(iy2 <= miny)
                continue;
            if(iy2 > maxy)
                iy2 = maxy;
            if(iy == iy2) {
                if(yerr*p[0]->den + p[0]->zerr*yden > p[0]->den*yden)
                    y++;
                iy = (y + y2) >> (fixshift+1);
                fillpoint(dst, ix, iy, src, sp, op);
            }
        }
        x += (1<<fixshift);
        ix++;
    }
}
@
% >> >> >> >>

<<function fillcolor>>=
static void
fillcolor(Memimage *dst, int left, int right, int y, Memimage *src, Point p)
{
    int srcval;

    USED(src);
    srcval = p.x;
    p.x = left;
    p.y = y;
    memset(byteaddr(dst, p), srcval, right-left);
}
@

<<function fillline>>=
static void
fillline(Memimage *dst, int left, int right, int y, Memimage *src, Point p, int op)
{
    Rectangle r;

    r.min.x = left;
    r.min.y = y;
    r.max.x = right;
    r.max.y = y+1;
    p.x += left;
    p.y += y;
    memdraw(dst, r, src, p, memopaque, p, op);
}
@

<<function fillpoint>>=
static void
fillpoint(Memimage *dst, int x, int y, Memimage *src, Point p, int op)
{
    Rectangle r;

    r.min.x = x;
    r.min.y = y;
    r.max.x = x+1;
    r.max.y = y+1;
    p.x += x;
    p.y += y;
    memdraw(dst, r, src, p, memopaque, p, op);
}
@

<<function mod>>=
static long
mod(long x, long y)
{
    long z;

    z = x%y;
    if((long)(((ulong)z)^((ulong)y)) > 0 || z == 0)
        return z;
    return z + y;
}
@

<<function sdiv>>=
static long
sdiv(long x, long y)
{
    if((long)(((ulong)x)^((ulong)y)) >= 0 || x == 0)
        return x/y;

    return (x+((y>>30)|1))/y-1;
}
@

<<function smuldivmod>>=
static long
smuldivmod(long x, long y, long z, long *mod)
{
    vlong vx;

    if(x == 0 || y == 0){
        *mod = 0;
        return 0;
    }
    vx = x;
    vx *= y;
    *mod = vx % z;
    if(*mod < 0)
        *mod += z;	/* z is always >0 */
    if((vx < 0) == (z < 0))
        return vx/z;
    return -((-vx)/z);
}
@


<<function zsort>>=
static void
zsort(Seg **seg, Seg **ep)
{
    int done;
    Seg **q, **p, *s;

    if(ep-seg < 20) {
        /* bubble sort by z - they should be almost sorted already */
        q = ep;
        do {
            done = 1;
            q--;
            for(p = seg; p < q; p++) {
                if(p[0]->z > p[1]->z) {
                    s = p[0];
                    p[0] = p[1];
                    p[1] = s;
                    done = 0;
                }
            }
        } while(!done);
    } else {
        q = ep-1;
        for(p = seg; p < q; p++) {
            if(p[0]->z > p[1]->z) {
                qsort(seg, ep-seg, sizeof(Seg*), zcompare);
                break;
            }
        }
    }
}
@

<<function ycompare>>=
static int
ycompare(void *a, void *b)
{
    Seg **s0, **s1;
    long y0, y1;

    s0 = a;
    s1 = b;
    y0 = (*s0)->p0.y;
    y1 = (*s1)->p0.y;

    if(y0 < y1)
        return -1;
    if(y0 == y1)
        return 0;
    return 1;
}
@

<<function xcompare>>=
static int
xcompare(void *a, void *b)
{
    Seg **s0, **s1;
    long x0, x1;

    s0 = a;
    s1 = b;
    x0 = (*s0)->p0.x;
    x1 = (*s1)->p0.x;

    if(x0 < x1)
        return -1;
    if(x0 == x1)
        return 0;
    return 1;
}
@

<<function zcompare>>=
static int
zcompare(void *a, void *b)
{
    Seg **s0, **s1;
    long z0, z1;

    s0 = a;
    s1 = b;
    z0 = (*s0)->z;
    z1 = (*s1)->z;

    if(z0 < z1)
        return -1;
    if(z0 == z1)
        return 0;
    return 1;
}
@



\section{Ellipse}

% libmemdraw/ellipse.c
%/*
% * ellipse(dst, c, a, b, t, src, sp)
% *   draws an ellipse centered at c with semiaxes a,b>=0
% *   and semithickness t>=0, or filled if t<0.  point sp
% *   in src maps to c in dst
% *
% *   very thick skinny ellipses are brushed with circles (slow)
% *   others are approximated by filling between 2 ellipses
% *   criterion for very thick when b<a: t/b > 0.5*x/(1-x)
% *   where x = b/a
% */

\subsection{API}

<<function ellipse>>=
void
ellipse(Image *dst, Point c, int a, int b, int thick, Image *src, Point sp)
{
    doellipse('e', dst, &c, a, b, thick, src, &sp, 0, 0, SoverD);
}
@

<<function ellipseop>>=
void
ellipseop(Image *dst, Point c, int a, int b, int thick, Image *src, Point sp, Drawop op)
{
    doellipse('e', dst, &c, a, b, thick, src, &sp, 0, 0, op);
}
@

<<function fillellipse>>=
void
fillellipse(Image *dst, Point c, int a, int b, Image *src, Point sp)
{
    doellipse('E', dst, &c, a, b, 0, src, &sp, 0, 0, SoverD);
}
@

<<function fillellipseop>>=
void
fillellipseop(Image *dst, Point c, int a, int b, Image *src, Point sp, Drawop op)
{
    doellipse('E', dst, &c, a, b, 0, src, &sp, 0, 0, op);
}
@


\subsection{Marshalling}

% rename _ellipse?
<<function doellipse>>=
static
void
doellipse(int cmd, Image *dst, Point *c, int xr, int yr, int thick, Image *src, Point *sp, int alpha, int phi, Drawop op)
{
    uchar *a;

    _setdrawop(dst->display, op);

    a = bufimage(dst->display, 1+4+4+2*4+4+4+4+2*4+2*4);
    if(a == 0){
        fprint(2, "image ellipse: %r\n");
        return;
    }
    a[0] = cmd;
    BPLONG(a+1, dst->id);
    BPLONG(a+5, src->id);
    BPLONG(a+9, c->x);
    BPLONG(a+13, c->y);
    BPLONG(a+17, xr);
    BPLONG(a+21, yr);
    BPLONG(a+25, thick);
    BPLONG(a+29, sp->x);
    BPLONG(a+33, sp->y);
    BPLONG(a+37, alpha);
    BPLONG(a+41, phi);
}
@

\subsection{Unmarshalling}


<<[[drawmesg()]] cases>>=
/* ellipse: 'e' dstid[4] srcid[4] center[2*4] a[4] b[4] thick[4] sp[2*4] alpha[4] phi[4]*/
case 'e':
case 'E':
    printmesg(fmt="LLPlllPll", a, 0);
    m = 1+4+4+2*4+4+4+4+2*4+2*4;
    if(n < m)
        error(Eshortdraw);
    dst = drawimage(client, a+1);
    dstid = BGLONG(a+1);
    src = drawimage(client, a+5);
    drawpoint(&p, a+9);
    e0 = BGLONG(a+17);
    e1 = BGLONG(a+21);
    if(e0<0 || e1<0)
        error("invalid ellipse semidiameter");
    j = BGLONG(a+25);
    if(j < 0)
        error("negative ellipse thickness");
    drawpoint(&sp, a+29);
    c = j;
    if(*a == 'E')
        c = -1;
    ox = BGLONG(a+37);
    oy = BGLONG(a+41);
    op = drawclientop(client);
    /* high bit indicates arc angles are present */

    if(ox & (1<<31)){
        if((ox & (1<<30)) == 0)
            ox &= ~(1<<31);
        memarc(dst, p, e0, e1, c, src, sp, ox, oy, op); // The call
    }else
        memellipse(dst, p, e0, e1, c, src, sp, op); // The call

    dstflush(dstid, dst, Rect(p.x-e0-j, p.y-e1-j, p.x+e0+j+1, p.y+e1+j+1));

    continue;
@
% >> >> >>


\subsection{Algorithm}

%/*
% * ellipse(dst, c, a, b, t, src, sp)
% *   draws an ellipse centered at c with semiaxes a,b>=0
% *   and semithickness t>=0, or filled if t<0.  point sp
% *   in src maps to c in dst
% *
% *   very thick skinny ellipses are brushed with circles (slow)
% *   others are approximated by filling between 2 ellipses
% *   criterion for very thick when b<a: t/b > 0.5*x/(1-x)
% *   where x = b/a
% */

<<struct ParamEllipse>>=
struct ParamEllipse {
    Memimage	*dst;
    Memimage	*src;
    Point			c;
    int			t;
    Point			sp;
    Memimage	*disc;
    int			op;
};
@

<<struct State>>=
/*
 * denote residual error by e(x,y) = b^2*x^2 + a^2*y^2 - a^2*b^2
 * e(x,y) = 0 on ellipse, e(x,y) < 0 inside, e(x,y) > 0 outside
 */
struct State {
    int	a;
    int	x;
    vlong	a2;	/* a^2 */
    vlong	b2;	/* b^2 */
    vlong	b2x;	/* b^2 * x */
    vlong	a2y;	/* a^2 * y */
    vlong	c1;
    vlong	c2;	/* test criteria */
    vlong	ee;	/* ee = e(x+1/2,y-1/2) - (a^2+b^2)/4 */
    vlong	dxe;
    vlong	dye;
    vlong	d2xe;
    vlong	d2ye;
};
@

<<function newstate>>=
static
State*
newstate(State *s, int a, int b)
{
    s->x = 0;
    s->a = a;
    s->a2 = (vlong)(a*a);
    s->b2 = (vlong)(b*b);
    s->b2x = (vlong)0;
    s->a2y = s->a2*(vlong)b;
    s->c1 = -((s->a2>>2) + (vlong)(a&1) + s->b2);
    s->c2 = -((s->b2>>2) + (vlong)(b&1));
    s->ee = -s->a2y;
    s->dxe = (vlong)0;
    s->dye = s->ee<<1;
    s->d2xe = s->b2<<1;
    s->d2ye = s->a2<<1;
    return s;
}
@
% >> >> >> 


<<function memellipse>>=
void
memellipse(Memimage *dst, Point c, int a, int b, int t, Memimage *src, Point sp, int op)
{
    State in, out;
    int y, inb, inx, outx, u;
    Param p;

    if(a < 0)
        a = -a;
    if(b < 0)
        b = -b;
    p.dst = dst;
    p.src = src;
    p.c = c;
    p.t = t;
    p.sp = subpt(sp, c);
    p.disc = nil;
    p.op = op;

    u = (t<<1)*(a-b);
    if(b<a && u>b*b || a<b && -u>a*a) {
/*	if(b<a&&(t<<1)>b*b/a || a<b&&(t<<1)>a*a/b)	# very thick */
        bellipse(b, newstate(&in, a, b), &p);
        return;
    }

    if(t < 0) {
        inb = -1;
        newstate(&out, a, y = b);
    } else {	
        inb = b - t;
        newstate(&out, a+t, y = b+t);
    }
    if(t > 0)
        newstate(&in, a-t, inb);
    inx = 0;
    for( ; y>=0; y--) {
        outx = step(&out);
        if(y > inb) {
            erect(-outx, y, outx, y, &p);
            if(y != 0)
                erect(-outx, -y, outx, -y, &p);
            continue;
        }
        if(t > 0) {
            inx = step(&in);
            if(y == inb)
                inx = 0;
        } else if(inx > outx)
            inx = outx;
        erect(inx, y, outx, y, &p);
        if(y != 0)
            erect(inx, -y, outx, -y, &p);
        erect(-outx, y, -inx, y, &p);
        if(y != 0)
            erect(-outx, -y, -inx, -y, &p);
        inx = outx + 1;
    }
}
@
% >> >> >>

<<global p00 (lib_graphics/libmemdraw/ellipse.c)>>=
static Point p00 = {0, 0};
@

<<function bellipse>>=
/*
 * a brushed ellipse
 */
static
void
bellipse(int y, State *s, Param *p)
{
    int t, ox, oy, x, nx;

    t = p->t;
    p->disc = allocmemimage(Rect(-t,-t,t+1,t+1), GREY1);
    if(p->disc == nil)
        return;
    memfillcolor(p->disc, DTransparent);
    memellipse(p->disc, p00, t, t, -1, memopaque, p00, p->op);
    oy = y;
    ox = 0;
    nx = x = step(s);
    do {
        while(nx==x && y-->0)
            nx = step(s);
        y++;
        eline(-x,-oy,-ox, -y, p);
        eline(ox,-oy,  x, -y, p);
        eline(-x,  y,-ox, oy, p);
        eline(ox,  y,  x, oy, p);
        ox = x+1;
        x = nx;
        y--;
        oy = y;
    } while(oy > 0);
}
@

<<function erect>>=
/*
 * a rectangle with closed (not half-open) coordinates expressed
 * relative to the center of the ellipse
 */
static
void
erect(int x0, int y0, int x1, int y1, Param *p)
{
    Rectangle r;

/*	print("R %d,%d %d,%d\n", x0, y0, x1, y1); /**/
    r = Rect(p->c.x+x0, p->c.y+y0, p->c.x+x1+1, p->c.y+y1+1);
    memdraw(p->dst, r, p->src, addpt(p->sp, r.min), memopaque, p00, p->op);
}
@


<<function step>>=
/*
 * return x coord of rightmost pixel on next scan line
 */
static
int
step(State *s)
{
    while(s->x < s->a) {
        if(s->ee+s->b2x <= s->c1 ||	/* e(x+1,y-1/2) <= 0 */
           s->ee+s->a2y <= s->c2) {	/* e(x+1/2,y) <= 0 (rare) */
            s->dxe += s->d2xe;	  
            s->ee += s->dxe;	  
            s->b2x += s->b2;
            s->x++;	  
            continue;
        }
        s->dye += s->d2ye;	  
        s->ee += s->dye;	  
        s->a2y -= s->a2;
        if(s->ee-s->a2y <= s->c2) {	/* e(x+1/2,y-1) <= 0 */
            s->dxe += s->d2xe;	  
            s->ee += s->dxe;	  
            s->b2x += s->b2;
            return s->x++;
        }
        break;
    }
    return s->x;	  
}
@



<<function epoint>>=
/*
 * a brushed point similarly specified
 */
static
void
epoint(int x, int y, Param *p)
{
    Point p0;
    Rectangle r;

/*	print("P%d %d,%d\n", p->t, x, y);	/**/
    p0 = Pt(p->c.x+x, p->c.y+y);
    r = Rpt(addpt(p0, p->disc->r.min), addpt(p0, p->disc->r.max));
    memdraw(p->dst, r, p->src, addpt(p->sp, r.min), p->disc, p->disc->r.min, p->op);
}
@

<<function eline>>=
/* 
 * a brushed horizontal or vertical line similarly specified
 */
static
void
eline(int x0, int y0, int x1, int y1, Param *p)
{
/*	print("L%d %d,%d %d,%d\n", p->t, x0, y0, x1, y1); /**/
    if(x1 > x0+1)
        erect(x0+1, y0-p->t, x1-1, y1+p->t, p);
    else if(y1 > y0+1)
        erect(x0-p->t, y0+1, x1+p->t, y1-1, p);
    epoint(x0, y0, p);
    if(x1-x0 || y1-y0)
        epoint(x1, y1, p);
}
@



\section{Arc}

\subsection{API}

<<function arc>>=
void
arc(Image *dst, Point c, int a, int b, int thick, Image *src, Point sp, int alpha, int phi)
{
    alpha |= 1<<31;
    doellipse('e', dst, &c, a, b, thick, src, &sp, alpha, phi, SoverD);
}
@
% >>

<<function arcop>>=
void
arcop(Image *dst, Point c, int a, int b, int thick, Image *src, Point sp, int alpha, int phi, Drawop op)
{
    alpha |= 1<<31;
    doellipse('e', dst, &c, a, b, thick, src, &sp, alpha, phi, op);
}
@
% >>

<<function fillarc>>=
void
fillarc(Image *dst, Point c, int a, int b, Image *src, Point sp, int alpha, int phi)
{
    alpha |= 1<<31;
    doellipse('E', dst, &c, a, b, 0, src, &sp, alpha, phi, SoverD);
}
@
% >>

<<function fillarcop>>=
void
fillarcop(Image *dst, Point c, int a, int b, Image *src, Point sp, int alpha, int phi, Drawop op)
{
    alpha |= 1<<31;
    doellipse('E', dst, &c, a, b, 0, src, &sp, alpha, phi, op);
}
@
% >>

\subsection{Algoritm}

<<enum _anon_ (lib_graphics/libmemdraw/arc.c)>>=
/*
 * elarc(dst,c,a,b,t,src,sp,alpha,phi)
 *   draws the part of an ellipse between rays at angles alpha and alpha+phi
 *   measured counterclockwise from the positive x axis. other
 *   arguments are as for ellipse(dst,c,a,b,t,src,sp)
 */

enum
{
    R, T, L, B	/* right, top, left, bottom */
};
@

<<global corners>>=
static
Point corners[] = {
    {1,1},
    {-1,1},
    {-1,-1},
    {1,-1}
};
@

<<global p00>>=
static
Point p00;
@



<<function memarc>>=
/*
 * make a "wedge" mask covering the desired angle and contained in
 * a surrounding square; draw a full ellipse; intersect that with the
 * wedge to make a mask through which to copy src to dst.
 */
void
memarc(Memimage *dst, Point c, int a, int b, int t, Memimage *src, Point sp, int alpha, int phi, int op)
{
    int i, w, beta, tmp, c1, c2, m, m1;
    Rectangle rect;
    Point p,	bnd[8];
    Memimage *wedge, *figure, *mask;

    if(a < 0)
        a = -a;
    if(b < 0)
        b = -b;
    w = t;
    if(w < 0)
        w = 0;
    alpha = -alpha;		/* compensate for upside-down coords */
    phi = -phi;
    beta = alpha + phi;
    if(phi < 0){
        tmp = alpha;
        alpha = beta;
        beta = tmp;
        phi = -phi;
    }
    if(phi >= 360){
        memellipse(dst, c, a, b, t, src, sp, op);
        return;
    }
    while(alpha < 0)
        alpha += 360;
    while(beta < 0)
        beta += 360;
    c1 = alpha/90 & 3;	/* number of nearest corner */
    c2 = beta/90 & 3;
        /*
         * icossin returns point at radius ICOSSCALE.
         * multiplying by m1 moves it outside the ellipse
        */
    rect = Rect(-a-w, -b-w, a+w+1, b+w+1);
    m = rect.max.x;	/* inradius of bounding square */
    if(m < rect.max.y)
        m = rect.max.y;
    m1 = (m+ICOSSCALE-1) >> 10;
    m = m1 << 10;		/* assure m1*cossin is inside */
    i = 0;
    bnd[i++] = Pt(0,0);
    icossin(alpha, &p.x, &p.y);
    bnd[i++] = mulpt(p, m1);
    for(;;) {
        bnd[i++] = mulpt(corners[c1], m);
        if(c1==c2 && phi<180)
            break;
        c1 = (c1+1) & 3;
        phi -= 90;
    }
    icossin(beta, &p.x, &p.y);
    bnd[i++] = mulpt(p, m1);

    figure = nil;
    mask = nil;
    wedge = allocmemimage(rect, GREY1);
    if(wedge == nil)
        goto Return;
    memfillcolor(wedge, DTransparent);
    memfillpoly(wedge, bnd, i, ~0, memopaque, p00, S);
    figure = allocmemimage(rect, GREY1);
    if(figure == nil)
        goto Return;
    memfillcolor(figure, DTransparent);
    memellipse(figure, p00, a, b, t, memopaque, p00, S);
    mask = allocmemimage(rect, GREY1);
    if(mask == nil)
        goto Return;
    memfillcolor(mask, DTransparent);
    memimagedraw(mask, rect, figure, rect.min, wedge, rect.min, S);
    c = subpt(c, dst->r.min);
    memdraw(dst, dst->r, src, subpt(sp, c), mask, subpt(p00, c), op);

    Return:
    freememimage(wedge);
    freememimage(figure);
    freememimage(mask);
}
@
% >> >> >>

%\section{Bezier} see advanced topics

%\section{Text} see font section

\chapter{Colors}
% test code showing use of colors?

\section{[[RGB]]}

<<struct RGB>>=
struct RGB
{
    ulong	red;
    ulong	green;
    ulong	blue;
};
@

\section{Color map}

\subsection{API}

\subsection{Hardware support hook}

% drawread | blankscreen -> <>, part of screen.h interface now
<<function getcolor(x86)>>=
void
getcolor(ulong p, ulong* pr, ulong* pg, ulong* pb)
{
    VGAscr *scr;
    ulong x;

    scr = &vgascreen;
    if(gscreen == nil)
        return;

    switch(gscreen->depth){
    default:
        x = 0x0F;
        break;
    case 8:
        x = 0xFF;
        break;
    }
    p &= x;

    lock(&cursor);
    *pr = scr->colormap[p][0];
    *pg = scr->colormap[p][1];
    *pb = scr->colormap[p][2];
    unlock(&cursor);
}
@

% drawread | blankscreen -> <>, part of screen.h interface now
<<function setcolor(x86)>>=
/*
 * On some video cards (e.g. Mach64), the palette is used as the 
 * DAC registers for >8-bit modes.  We don't want to set them when the user
 * is trying to set a colormap and the card is in one of these modes.
 */
int
setcolor(ulong p, ulong r, ulong g, ulong b)
{
    VGAscr *scr;
    int x;

    scr = &vgascreen;
    if(gscreen == nil)
        return 0;

    switch(gscreen->depth){
    case 1:
    case 2:
    case 4:
        x = 0x0F;
        break;
    case 8:
        x = 0xFF;
        break;
    default:
        return 0;
    }
    p &= x;

    return setpalette(p, r, g, b);
}
@

% setcolor -> <>
<<function setpalette(x86)>>=
int
setpalette(ulong p, ulong r, ulong g, ulong b)
{
    VGAscr *scr;
    int d;

    scr = &vgascreen;
    d = scr->palettedepth;

    lock(&cursor);
    scr->colormap[p][0] = r;
    scr->colormap[p][1] = g;
    scr->colormap[p][2] = b;
    vgao(PaddrW, p);
    vgao(Pdata, r>>(32-d));
    vgao(Pdata, g>>(32-d));
    vgao(Pdata, b>>(32-d));
    unlock(&cursor);

    return ~0;
}
@



\section{Pixel depth}

\section{Alpha}

\chapter{Fonts}
% test code showing use of font? display the core font?

% related:
%  - toy text api in cairo
%  - pango library with gtk
%  - freetype? fontconfig?
%  - more??


\section{Text}
% and rune

%https://engineering.eventbrite.com/its-2015-and-drawing-text-is-still-hard-webgl-threejs/

\subsection{API}

<<function string>>=
Point
string(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s)
{
    return _string(dst, pt, src, sp, f, s, nil, 1<<24, dst->clipr, nil, ZP, SoverD);
}
@

<<function stringop>>=
Point
stringop(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, Drawop op)
{
    return _string(dst, pt, src, sp, f, s, nil, 1<<24, dst->clipr, nil, ZP, op);
}
@

<<function stringn>>=
Point
stringn(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, int len)
{
    return _string(dst, pt, src, sp, f, s, nil, len, dst->clipr, nil, ZP, SoverD);
}
@

<<function stringnop>>=
Point
stringnop(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, int len, Drawop op)
{
    return _string(dst, pt, src, sp, f, s, nil, len, dst->clipr, nil, ZP, op);
}
@

<<function runestring>>=
Point
runestring(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r)
{
    return _string(dst, pt, src, sp, f, nil, r, 1<<24, dst->clipr, nil, ZP, SoverD);
}
@

<<function runestringop>>=
Point
runestringop(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r, Drawop op)
{
    return _string(dst, pt, src, sp, f, nil, r, 1<<24, dst->clipr, nil, ZP, op);
}
@

<<function runestringn>>=
Point
runestringn(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r, int len)
{
    return _string(dst, pt, src, sp, f, nil, r, len, dst->clipr, nil, ZP, SoverD);
}
@

<<function runestringnop>>=
Point
runestringnop(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r, int len, Drawop op)
{
    return _string(dst, pt, src, sp, f, nil, r, len, dst->clipr, nil, ZP, op);
}
@




<<function stringbg>>=
Point
stringbg(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, Image *bg, Point bgp)
{
    return _string(dst, pt, src, sp, f, s, nil, 1<<24, dst->clipr, bg, bgp, SoverD);
}
@

<<function stringbgop>>=
Point
stringbgop(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, Image *bg, Point bgp, int op)
{
    return _string(dst, pt, src, sp, f, s, nil, 1<<24, dst->clipr, bg, bgp, op);
}
@

<<function stringnbg>>=
Point
stringnbg(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, int len, Image *bg, Point bgp)
{
    return _string(dst, pt, src, sp, f, s, nil, len, dst->clipr, bg, bgp, SoverD);
}
@

<<function stringnbgop>>=
Point
stringnbgop(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, int len, Image *bg, Point bgp, int op)
{
    return _string(dst, pt, src, sp, f, s, nil, len, dst->clipr, bg, bgp, op);
}
@

<<function runestringbg>>=
Point
runestringbg(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r, Image *bg, Point bgp)
{
    return _string(dst, pt, src, sp, f, nil, r, 1<<24, dst->clipr, bg, bgp, SoverD);
}
@

<<function runestringbgop>>=
Point
runestringbgop(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r, Image *bg, Point bgp, int op)
{
    return _string(dst, pt, src, sp, f, nil, r, 1<<24, dst->clipr, bg, bgp, op);
}
@

<<function runestringnbg>>=
Point
runestringnbg(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r, int len, Image *bg, Point bgp)
{
    return _string(dst, pt, src, sp, f, nil, r, len, dst->clipr, bg, bgp, SoverD);
}
@

<<function runestringnbgop>>=
Point
runestringnbgop(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r, int len, Image *bg, Point bgp, int op)
{
    return _string(dst, pt, src, sp, f, nil, r, len, dst->clipr, bg, bgp, op);
}
@


\subsection{Marshalling}


<<function _string>>=
Point
_string(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, Rune *r, int len, Rectangle clipr, Image *bg, Point bgp, Drawop op)
{
    int m, n, wid, max;
    ushort cbuf[Max], *c, *ec;
    uchar *b;
    char *subfontname;
    char **sptr;
    Rune **rptr;
    Font *def;
    Subfont *sf;

    if(s == nil){
        s = "";
        sptr = nil;
    }else
        sptr = &s;
    if(r == nil){
        r = (Rune*) L"";
        rptr = nil;
    }else
        rptr = &r;
    sf = nil;
    while((*s || *r) && len){
        max = Max;
        if(len < max)
            max = len;
        n = cachechars(f, sptr, rptr, cbuf, max, &wid, &subfontname);
        if(n > 0){
            _setdrawop(dst->display, op);

            m = 47+2*n;
            if(bg)
                m += 4+2*4;
            b = bufimage(dst->display, m);
            if(b == 0){
                fprint(2, "string: %r\n");
                break;
            }
            if(bg)
                b[0] = 'x';
            else
                b[0] = 's';
            BPLONG(b+1, dst->id);
            BPLONG(b+5, src->id);
            BPLONG(b+9, f->cacheimage->id);
            BPLONG(b+13, pt.x);
            BPLONG(b+17, pt.y+f->ascent);
            BPLONG(b+21, clipr.min.x);
            BPLONG(b+25, clipr.min.y);
            BPLONG(b+29, clipr.max.x);
            BPLONG(b+33, clipr.max.y);
            BPLONG(b+37, sp.x);
            BPLONG(b+41, sp.y);
            BPSHORT(b+45, n);
            b += 47;
            if(bg){
                BPLONG(b, bg->id);
                BPLONG(b+4, bgp.x);
                BPLONG(b+8, bgp.y);
                b += 12;
            }
            ec = &cbuf[n];
            for(c=cbuf; c<ec; c++, b+=2)
                BPSHORT(b, *c);
            pt.x += wid;
            bgp.x += wid;
            agefont(f);
            len -= n;
        }
        if(subfontname){
            freesubfont(sf);
            if((sf=_getsubfont(f->display, subfontname)) == 0){
                def = f->display ? f->display->defaultfont : nil;
                if(def && f!=def)
                    f = def;
                else
                    break;
            }
            /* 
             * must not free sf until cachechars has found it in the cache
             * and picked up its own reference.
             */
        }
    }
    return pt;
}
@


\subsection{Unmarshalling}

<<[[drawmesg()]] cases>>=
/* string: 's' dstid[4] srcid[4] fontid[4] P[2*4] clipr[4*4] sp[2*4] ni[2] ni*(index[2]) */
/* stringbg: 'x' dstid[4] srcid[4] fontid[4] P[2*4] clipr[4*4] sp[2*4] ni[2] bgid[4] bgpt[2*4] ni*(index[2]) */
case 's':
case 'x':
    printmesg(fmt="LLLPRPs", a, 0);
    m = 1+4+4+4+2*4+4*4+2*4+2;
    if(*a == 'x')
        m += 4+2*4;
    if(n < m)
        error(Eshortdraw);

    dst = drawimage(client, a+1);
    dstid = BGLONG(a+1);
    src = drawimage(client, a+5);
    font = drawlookup(client, BGLONG(a+9), 1);
    if(font == 0)
        error(Enodrawimage);
    if(font->nfchar == 0)
        error(Enotfont);
    drawpoint(&p, a+13);
    drawrectangle(&r, a+21);
    drawpoint(&sp, a+37);
    ni = BGSHORT(a+45);
    u = a+m;
    m += ni*2;
    if(n < m)
        error(Eshortdraw);
    clipr = dst->clipr;
    dst->clipr = r;
    op = drawclientop(client);
    bg = dst;
    if(*a == 'x'){
        /* paint background */
        bg = drawimage(client, a+47);
        drawpoint(&q, a+51);
        r.min.x = p.x;
        r.min.y = p.y-font->ascent;
        r.max.x = p.x;
        r.max.y = r.min.y+Dy(font->image->r);
        j = ni;
        while(--j >= 0){
            ci = BGSHORT(u);
            if(ci<0 || ci>=font->nfchar){
                dst->clipr = clipr;
                error(Eindex);
            }
            r.max.x += font->fchar[ci].width;
            u += 2;
        }
        memdraw(dst, r, bg, q, memopaque, ZP, op);
        u -= 2*ni;
    }
    q = p;
    while(--ni >= 0){
        ci = BGSHORT(u);
        if(ci<0 || ci>=font->nfchar){
            dst->clipr = clipr;
            error(Eindex);
        }
        q = drawchar(dst, bg, q, src, &sp, font, ci, op);
        u += 2;
    }
    dst->clipr = clipr;
    p.y -= font->ascent;
    dstflush(dstid, dst, Rect(p.x, p.y, q.x, p.y+Dy(font->image->r)));
    continue;

@

\subsection{Algorithm}



\section{Fonts}

\subsection{API}

<<function fontresize>>=
/* return whether resize succeeded && f->cache is unchanged */
static int
fontresize(Font *f, int wid, int ncache, int depth)
{
    Cacheinfo *i;
    int ret;
    Image *new;
    uchar *b;
    Display *d;

    ret = 0;
    if(depth <= 0)
        depth = 1;
    if(wid <= 0)
        wid = 1;

    d = f->display;
    if(d == nil)
        goto Nodisplay;

    new = allocimage(d, Rect(0, 0, ncache*wid, f->height), CHAN1(CGrey, depth), 0, 0);
    if(new == nil){
        fprint(2, "font cache resize failed: %r\n");
        abort();
        goto Return;
    }
    flushimage(d, false);	/* flush any pending errors */
    b = bufimage(d, 1+4+4+1);
    if(b == 0){
        freeimage(new);
        goto Return;
    }
    b[0] = 'i';
    BPLONG(b+1, new->id);
    BPLONG(b+5, ncache);
    b[9] = f->ascent;
    if(flushimage(d, false) < 0){
        fprint(2, "resize: init failed: %r\n");
        freeimage(new);
        goto Return;
    }
    freeimage(f->cacheimage);
    f->cacheimage = new;
    Nodisplay:
    f->width = wid;
    f->maxdepth = depth;
    ret = 1;
    if(f->ncache != ncache){
        i = malloc(ncache*sizeof f->cache[0]);
        if(i != nil){
            ret = 0;
            free(f->cache);
            f->ncache = ncache;
            f->cache = i;
        }
        /* else just wipe the cache clean and things will be ok */
    }
    Return:
    memset(f->cache, 0, f->ncache*sizeof f->cache[0]);
    return ret;
}
@

<<function loadchar>>=
/* return 1 if load succeeded, 0 if failed, -1 if must retry */
int
loadchar(Font *f, Rune r, Cacheinfo *c, int h, int noflush, char **subfontname)
{
    int i, oi, wid, top, bottom;
    Rune pic;
    Fontchar *fi;
    Cachefont *cf;
    Cachesubf *subf, *of;
    uchar *b;

    pic = r;
    Again:
    for(i=0; i<f->nsub; i++){
        cf = f->sub[i];
        if(cf->min<=pic && pic<=cf->max)
            goto Found;
    }
    TryPJW:
    if(pic != PJW){
        pic = PJW;
        goto Again;
    }
    return 0;

    Found:
    /*
     * Choose exact or oldest
     */
    oi = 0;
    subf = &f->subf[0];
    for(i=0; i<f->nsubf; i++){
        if(cf == subf->cf)
            goto Found2;
        if(subf->age < f->subf[oi].age)
            oi = i;
        subf++;
    }
    subf = &f->subf[oi];

    if(subf->f){
        if(f->age-subf->age>SUBFAGE || f->nsubf>MAXSUBF){
    Toss:
            /* ancient data; toss */
            freesubfont(subf->f);
            subf->cf = nil;
            subf->f = nil;
            subf->age = 0;
        }else{				/* too recent; grow instead */
            of = f->subf;
            f->subf = malloc((f->nsubf+DSUBF)*sizeof *subf);
            if(f->subf == nil){
                f->subf = of;
                goto Toss;
            }
            memmove(f->subf, of, (f->nsubf+DSUBF)*sizeof *subf);
            memset(f->subf+f->nsubf, 0, DSUBF*sizeof *subf);
            subf = &f->subf[f->nsubf];
            f->nsubf += DSUBF;
            free(of);
        }
    }
    subf->age = 0;
    subf->cf = nil;
    subf->f = cf2subfont(cf, f);
    if(subf->f == nil){
        if(cf->subfontname == nil)
            goto TryPJW;
        *subfontname = cf->subfontname;
        return -1;
    }

    subf->cf = cf;
    if(subf->f->ascent > f->ascent && f->display){
        /* should print something? this is a mistake in the font file */
        /* must prevent c->top from going negative when loading cache */
        Image *b;
        int d, t;
        d = subf->f->ascent - f->ascent;
        b = subf->f->bits;
        draw(b, b->r, b, nil, addpt(b->r.min, Pt(0, d)));
        draw(b, Rect(b->r.min.x, b->r.max.y-d, b->r.max.x, b->r.max.y), f->display->black, nil, b->r.min);
        for(i=0; i<subf->f->n; i++){
            t = subf->f->info[i].top-d;
            if(t < 0)
                t = 0;
            subf->f->info[i].top = t;
            t = subf->f->info[i].bottom-d;
            if(t < 0)
                t = 0;
            subf->f->info[i].bottom = t;
        }
        subf->f->ascent = f->ascent;
    }

    Found2:
    subf->age = f->age;

    /* possible overflow here, but works out okay */
    pic += cf->offset;
    pic -= cf->min;
    if(pic >= subf->f->n)
        goto TryPJW;
    fi = &subf->f->info[pic];
    if(fi->width == 0)
        goto TryPJW;
    wid = (fi+1)->x - fi->x;
    if(f->width < wid || f->width == 0 || f->maxdepth < subf->f->bits->depth){
        /*
         * Flush, free, reload (easier than reformatting f->b)
         */
        if(noflush)
            return -1;
        if(f->width < wid)
            f->width = wid;
        if(f->maxdepth < subf->f->bits->depth)
            f->maxdepth = subf->f->bits->depth;
        i = fontresize(f, f->width, f->ncache, f->maxdepth);
        if(i <= 0)
            return i;
        /* c is still valid as didn't reallocate f->cache */
    }
    c->value = r;
    top = fi->top + (f->ascent-subf->f->ascent);
    bottom = fi->bottom + (f->ascent-subf->f->ascent);
    c->width = fi->width;
    c->x = h*f->width;
    c->left = fi->left;
    if(f->display == nil)
        return 1;
    flushimage(f->display, false);	/* flush any pending errors */
    b = bufimage(f->display, 37);
    if(b == 0)
        return 0;
    b[0] = 'l';
    BPLONG(b+1, f->cacheimage->id);
    BPLONG(b+5, subf->f->bits->id);
    BPSHORT(b+9, c-f->cache);
    BPLONG(b+11, c->x);
    BPLONG(b+15, top);
    BPLONG(b+19, c->x+((fi+1)->x-fi->x));
    BPLONG(b+23, bottom);
    BPLONG(b+27, fi->x);
    BPLONG(b+31, fi->top);
    b[35] = fi->left;
    b[36] = fi->width;
    return 1;
}
@


\subsection{Marshalling}

\subsection{Unmarshalling}

<<[[drawmesg()]] cases>>=
/* initialize font: 'i' fontid[4] nchars[4] ascent[1] */
case 'i':
    printmesg(fmt="Llb", a, 1);
    m = 1+4+4+1;
    if(n < m)
        error(Eshortdraw);
    dstid = BGLONG(a+1);
    if(dstid == 0)
        error("cannot use display as font");
    font = drawlookup(client, dstid, 1);
    if(font == 0)
        error(Enodrawimage);
    if(font->image->layer)
        error("cannot use window as font");
    ni = BGLONG(a+5);
    if(ni<=0 || ni>4096)
        error("bad font size (4096 chars max)");
    free(font->fchar);  /* should we complain if non-zero? */
    font->fchar = malloc(ni*sizeof(FChar));
    if(font->fchar == 0)
        error("no memory for font");
    memset(font->fchar, 0, ni*sizeof(FChar));
    font->nfchar = ni;
    font->ascent = a[9];
    continue;

@


<<[[drawmesg()]] cases>>=
/* load character: 'l' fontid[4] srcid[4] index[2] R[4*4] P[2*4] left[1] width[1] */
case 'l':
    printmesg(fmt="LLSRPbb", a, 0);
    m = 1+4+4+2+4*4+2*4+1+1;
    if(n < m)
        error(Eshortdraw);
    font = drawlookup(client, BGLONG(a+1), 1);
    if(font == 0)
        error(Enodrawimage);
    if(font->nfchar == 0)
        error(Enotfont);
    src = drawimage(client, a+5);
    ci = BGSHORT(a+9);
    if(ci >= font->nfchar)
        error(Eindex);
    drawrectangle(&r, a+11);
    drawpoint(&p, a+27);
    memdraw(font->image, r, src, p, memopaque, p, S);
    fc = &font->fchar[ci];
    fc->minx = r.min.x;
    fc->maxx = r.max.x;
    fc->miny = r.min.y;
    fc->maxy = r.max.y;
    fc->left = a[35];
    fc->width = a[36];
    continue;

@

\subsection{Algorithm}


\section{Compressed form}

\section{Font cache}

<<enum _anon_ (include/draw.h)6>>=
enum
{
    /* starting values */
    LOG2NFCACHE =	6,
    NFCACHE =	(1<<LOG2NFCACHE),	/* #chars cached */
    NFLOOK =	5,			/* #chars to scan in cache */
    NFSUBF =	2,			/* #subfonts to cache */
    /* max value */
    MAXFCACHE =	1024+NFLOOK,		/* upper limit */
    MAXSUBF =	50,			/* generous upper limit */
    /* deltas */
    DSUBF = 	4,
    /* expiry ages */
    SUBFAGE	=	10000,
    CACHEAGE =	10000
};
@


<<struct Cachefont>>=
struct Cachefont
{
    Rune		min;	/* lowest rune value to be taken from subfont */
    Rune		max;	/* highest rune value+1 to be taken from subfont */
    int		offset;	/* position in subfont of character at min */
    char		*name;			/* stored in font */
    char		*subfontname;		/* to access subfont */
};
@

<<struct Cacheinfo>>=
struct Cacheinfo
{
    ushort		x;		/* left edge of bits */
    byte		width;		/* width of baseline */
    schar		left;		/* offset of baseline */
    Rune		value;	/* value of character at this slot in cache */
    ushort		age;
};
@

<<struct Cachesubf>>=
struct Cachesubf
{
    ulong		age;	/* for replacement */
    Cachefont	*cf;	/* font info that owns us */
    Subfont		*f;	/* attached subfont */
};
@

\chapter{Image IO}
% advanced topics? not that important no?


<<constant NMEM>>=
#define	NMEM	1024		/* window size */
@

<<constant NDUMP>>=
#define	NDUMP	128		/* maximum length of dump */
@

<<constant NCBLOCK>>=
#define	NCBLOCK	6000		/* size of compressed blocks */
@

% why this has to be in the kernel?
% because in the end if load in user space, then
% have to transfer info to kernel ... how? 
% don't want lose bandwifth.
% also loading fonts, etc, are about reading images,
% and those fonts have to be in the kernel like all the
% other images.


\section{Reading images}

\subsection{API}


<<global drawld2chan>>=
ulong drawld2chan[] = {
    GREY1,
    GREY2,
    GREY4,
    CMAP8,
};
@

<<function readimage>>=
Image*
readimage(Display *d, fdt fd, bool dolock)
{
    char hdr[5*12+1];
    int dy;
    int new;
    uint l, n;
    int m, j, chunk;
    int miny, maxy;
    Rectangle r;
    int ldepth;
    ulong chan;
    uchar *tmp;
    Image *i;

    if(readn(fd, hdr, 11) != 11)
        return nil;

    if(memcmp(hdr, "compressed\n", 11) == 0)
        return creadimage(d, fd, dolock);

    if(readn(fd, hdr+11, 5*12-11) != 5*12-11)
        return nil;
    if(d)
        chunk = d->bufsize - 32;	/* a little room for header */
    else
        chunk = 8192;

    /*
     * distinguish new channel descriptor from old ldepth.
     * channel descriptors have letters as well as numbers,
     * while ldepths are a single digit formatted as %-11d.
     */
    new = 0;
    for(m=0; m<10; m++){
        if(hdr[m] != ' '){
            new = 1;
            break;
        }
    }
    if(hdr[11] != ' '){
        werrstr("readimage: bad format");
        return nil;
    }
    if(new){
        hdr[11] = '\0';
        if((chan = strtochan(hdr)) == 0){
            werrstr("readimage: bad channel string %s", hdr);
            return nil;
        }
    }else{
        ldepth = ((int)hdr[10])-'0';
        if(ldepth<0 || ldepth>3){
            werrstr("readimage: bad ldepth %d", ldepth);
            return nil;
        }
        chan = drawld2chan[ldepth];
    }

    r.min.x = atoi(hdr+1*12);
    r.min.y = atoi(hdr+2*12);
    r.max.x = atoi(hdr+3*12);
    r.max.y = atoi(hdr+4*12);
    if(r.min.x>r.max.x || r.min.y>r.max.y){
        werrstr("readimage: bad rectangle");
        return nil;
    }

    miny = r.min.y;
    maxy = r.max.y;

    l = bytesperline(r, chantodepth(chan));
    if(d){
        if(dolock)
            lockdisplay(d);
        i = allocimage(d, r, chan, 0, -1);
        if(dolock)
            unlockdisplay(d);
        if(i == nil)
            return nil;
    }else{
        i = mallocz(sizeof(Image), 1);
        if(i == nil)
            return nil;
    }

    tmp = malloc(chunk);
    if(tmp == nil)
        goto Err;
    while(maxy > miny){
        dy = maxy - miny;
        if(dy*l > chunk)
            dy = chunk/l;
        if(dy <= 0){
            werrstr("readimage: image too wide for buffer");
            goto Err;
        }
        n = dy*l;
        m = readn(fd, tmp, n);
        if(m != n){
            werrstr("readimage: read count %d not %d: %r", m, n);
   Err:
            if(dolock)
                lockdisplay(d);
   Err1:
    freeimage(i);
            if(dolock)
                unlockdisplay(d);
            free(tmp);
            return nil;
        }
        if(!new)	/* an old image: must flip all the bits */
            for(j=0; j<chunk; j++)
                tmp[j] ^= 0xFF;

        if(d){
            if(dolock)
                lockdisplay(d);
            if(loadimage(i, Rect(r.min.x, miny, r.max.x, miny+dy), tmp, chunk) <= 0)
                goto Err1;
            if(dolock)
                unlockdisplay(d);
        }
        miny += dy;
    }
    free(tmp);
    return i;
}
@



<<function unloadimage>>=
int
unloadimage(Image *i, Rectangle r, uchar *data, int ndata)
{
    int bpl, n, ntot, dy;
    uchar *a;
    Display *d;

    if(!rectinrect(r, i->r)){
        werrstr("unloadimage: bad rectangle");
        return -1;
    }
    bpl = bytesperline(r, i->depth);
    if(ndata < bpl*Dy(r)){
        werrstr("unloadimage: buffer too small");
        return -1;
    }

    d = i->display;
    flushimage(d, false);	/* make sure subsequent flush is for us only */
    ntot = 0;
    while(r.min.y < r.max.y){
        a = bufimage(d, 1+4+4*4);
        if(a == 0){
            werrstr("unloadimage: %r");
            return -1;
        }
        dy = 8000/bpl;
        if(dy <= 0){
            werrstr("unloadimage: image too wide");
            return -1;
        }
        if(dy > Dy(r))
            dy = Dy(r);
        a[0] = 'r';
        BPLONG(a+1, i->id);
        BPLONG(a+5, r.min.x);
        BPLONG(a+9, r.min.y);
        BPLONG(a+13, r.max.x);
        BPLONG(a+17, r.min.y+dy);
        if(flushimage(d, false) < 0)
            return -1;
        n = read(d->fd, data+ntot, ndata-ntot);
        if(n < 0)
            return n;
        ntot += n;
        r.min.y += dy;
    }
    return ntot;
}
@



\subsection{Marshalling}

\subsection{Unmarshalling}

<<[[drawmesg()]] cases>>=
/* read: 'r' id[4] R[4*4] */
case 'r':
    printmesg(fmt="LR", a, 0);
    m = 1+4+4*4;
    if(n < m)
        error(Eshortdraw);
    i = drawimage(client, a+1);
    drawrectangle(&r, a+5);
    if(!rectinrect(r, i->r))
        error(Ereadoutside);
    c = bytesperline(r, i->depth);
    c *= Dy(r);

    free(client->readdata);
    client->readdata = mallocz(c, 0);
    if(client->readdata == nil)
        error("readimage malloc failed");

    client->nreaddata = memunload(i, r, client->readdata, c); // The call

    if(client->nreaddata < 0){
        free(client->readdata);
        client->readdata = nil;
        error("bad readimage call");
    }
    continue;

@

\subsection{Algorithm}

<<function memunload>>=
int
memunload(Memimage *src, Rectangle r, uchar *data, int n)
{
    Memimage *tmp;
    Memlayer *dl;
    Rectangle lr;
    int dx;

    Top:
    dl = src->layer;
    if(dl == nil)
        return unloadmemimage(src, r, data, n);

    /*
   * Convert to screen coordinates.
     */
    lr = r;
    r.min.x += dl->delta.x;
    r.min.y += dl->delta.y;
    r.max.x += dl->delta.x;
    r.max.y += dl->delta.y;
    dx = dl->delta.x&(7/src->depth);
    if(dl->clear && dx==0){
        src = dl->screen->image;
        goto Top;
    }

    /*
     * src is an obscured layer or data is unaligned
     */
    if(dl->save && dx==0){
        if(dl->refreshfn != nil)
            return -1;	/* can't unload window if it's not Refbackup */
        if(n > 0)
            memlhide(src, r);
        n = unloadmemimage(dl->save, lr, data, n);
        return n;
    }
    tmp = allocmemimage(lr, src->chan);
    if(tmp == nil)
        return -1;
    memdraw(tmp, lr, src, lr.min, nil, lr.min, S);
    n = unloadmemimage(tmp, lr, data, n);
    freememimage(tmp);
    return n;
}
@

<<function unloadmemimage>>=
int
unloadmemimage(Memimage *i, Rectangle r, uchar *data, int ndata)
{
    int y, l;
    uchar *q;

    if(!rectinrect(r, i->r))
        return -1;
    l = bytesperline(r, i->depth);
    if(ndata < l*Dy(r))
        return -1;
    ndata = l*Dy(r);
    q = byteaddr(i, r.min);
    for(y=r.min.y; y<r.max.y; y++){
        memmove(data, q, l);
        q += i->width*sizeof(ulong);
        data += l;
    }
    return ndata;
}
@

\section{Writing images}

%topng </dev/screen >screen.png :) = Grab

<<constant HSHIFT>>=
#define	HSHIFT	3	/* HSHIFT==5 runs slightly faster, but hash table is 64x bigger */
@

<<constant NHASH>>=
#define	NHASH	(1<<(HSHIFT*NMATCH))
@

<<constant HMASK>>=
#define	HMASK	(NHASH-1)
@

<<function hupdate>>=
#define	hupdate(h, c)	((((h)<<HSHIFT)^(c))&HMASK)
@

<<struct Hlist>>=
struct Hlist{
    uchar *s;
    Hlist *next, *prev;
};
@

% >> >>



<<function writeimage>>=
int
writeimage(fdt fd, Image *i, bool dolock)
{
    uchar *outbuf, *outp, *eout;		/* encoded data, pointer, end */
    uchar *loutp;				/* start of encoded line */
    Hlist *hash;				/* heads of hash chains of past strings */
    Hlist *chain, *hp;			/* hash chain members, pointer */
    Hlist *cp;				/* next Hlist to fall out of window */
    int h;					/* hash value */
    uchar *line, *eline;			/* input line, end pointer */
    uchar *data, *edata;			/* input buffer, end pointer */
    ulong n;				/* length of input buffer */
    ulong nb;				/* # of bytes returned by unloadimage */
    int bpl;				/* input line length */
    int offs, runlen;			/* offset, length of consumed data */
    uchar dumpbuf[NDUMP];			/* dump accumulator */
    int ndump;				/* length of dump accumulator */
    int miny, dy;				/* y values while unloading input */
    int chunk, ncblock;
    Rectangle r;
    uchar *p, *q, *s, *es, *t;
    char hdr[11+5*12+1];
    char cbuf[20];

    chunk = i->display->bufsize - 32;	/* a little room for header */
    r = i->r;
    bpl = bytesperline(r, i->depth);
    n = Dy(r)*bpl;
    data = malloc(n);
    ncblock = _compblocksize(r, i->depth);
    outbuf = malloc(ncblock);
    hash = malloc(NHASH*sizeof(Hlist));
    chain = malloc(NMEM*sizeof(Hlist));
    if(data == 0 || outbuf == 0 || hash == 0 || chain == 0){
    ErrOut:
        free(data);
        free(outbuf);
        free(hash);
        free(chain);
        return -1;
    }
    for(miny = r.min.y; miny != r.max.y; miny += dy){
        dy = r.max.y-miny;
        if(dy*bpl > chunk)
            dy = chunk/bpl;
        if(dolock)
            lockdisplay(i->display);
        nb = unloadimage(i, Rect(r.min.x, miny, r.max.x, miny+dy),
            data+(miny-r.min.y)*bpl, dy*bpl);
        if(dolock)
            unlockdisplay(i->display);
        if(nb != dy*bpl)
            goto ErrOut;
    }

    sprint(hdr, "compressed\n%11s %11d %11d %11d %11d ",
        chantostr(cbuf, i->chan), r.min.x, r.min.y, r.max.x, r.max.y);
    if(write(fd, hdr, 11+5*12) != 11+5*12)
        goto ErrOut;
    edata = data+n;
    eout = outbuf+ncblock;
    line = data;
    r.max.y = r.min.y;
    while(line != edata){
        memset(hash, 0, NHASH*sizeof(Hlist));
        memset(chain, 0, NMEM*sizeof(Hlist));
        cp = chain;
        h = 0;
        outp = outbuf;
        for(n = 0; n != NMATCH; n++)
            h = hupdate(h, line[n]);
        loutp = outbuf;
        while(line != edata){
            ndump = 0;
            eline = line+bpl;
            for(p = line; p != eline; ){
                if(eline-p < NRUN)
                    es = eline;
                else
                    es = p+NRUN;
                q = 0;
                runlen = 0;
                for(hp = hash[h].next; hp; hp = hp->next){
                    s = p + runlen;
                    if(s >= es)
                        continue;
                    t = hp->s + runlen;
                    for(; s >= p; s--)
                        if(*s != *t--)
                            goto matchloop;
                    t += runlen+2;
                    s += runlen+2;
                    for(; s < es; s++)
                        if(*s != *t++)
                            break;
                    n = s-p;
                    if(n > runlen){
                        runlen = n;
                        q = hp->s;
                        if(n == NRUN)
                            break;
                    }
            matchloop: ;
                }
                if(runlen < NMATCH){
                    if(ndump == NDUMP){
                        if(eout-outp < ndump+1)
                            goto Bfull;
                        *outp++ = ndump-1+128;
                        memmove(outp, dumpbuf, ndump);
                        outp += ndump;
                        ndump = 0;
                    }
                    dumpbuf[ndump++] = *p;
                    runlen = 1;
                }
                else{
                    if(ndump != 0){
                        if(eout-outp < ndump+1)
                            goto Bfull;
                        *outp++ = ndump-1+128;
                        memmove(outp, dumpbuf, ndump);
                        outp += ndump;
                        ndump = 0;
                    }
                    offs = p-q-1;
                    if(eout-outp < 2)
                        goto Bfull;
                    *outp++ = ((runlen-NMATCH)<<2) + (offs>>8);
                    *outp++ = offs&255;
                }
                for(q = p+runlen; p != q; p++){
                    if(cp->prev)
                        cp->prev->next = 0;
                    cp->next = hash[h].next;
                    cp->prev = &hash[h];
                    if(cp->next)
                        cp->next->prev = cp;
                    cp->prev->next = cp;
                    cp->s = p;
                    if(++cp == &chain[NMEM])
                        cp = chain;
                    if(edata-p > NMATCH)
                        h = hupdate(h, p[NMATCH]);
                }
            }
            if(ndump != 0){
                if(eout-outp < ndump+1)
                    goto Bfull;
                *outp++ = ndump-1+128;
                memmove(outp, dumpbuf, ndump);
                outp += ndump;
            }
            line = eline;
            loutp = outp;
            r.max.y++;
        }
    Bfull:
        if(loutp == outbuf)
            goto ErrOut;
        n = loutp-outbuf;
        sprint(hdr, "%11d %11ld ", r.max.y, n);
        write(fd, hdr, 2*12);
        write(fd, outbuf, n);
        r.min.y = r.max.y;
    }
    free(data);
    free(outbuf);
    free(hash);
    free(chain);
    return 0;
}
@

\section{Loading images}
% = readimage but from memory instead of file

\subsection{API}

<<function loadimage>>=
int
loadimage(Image *i, Rectangle r, uchar *data, int ndata)
{
    long dy;
    int n, bpl;
    uchar *a;
    int chunk;

    chunk = i->display->bufsize - 64;

    if(!rectinrect(r, i->r)){
        werrstr("loadimage: bad rectangle");
        return -1;
    }
    bpl = bytesperline(r, i->depth);
    n = bpl*Dy(r);
    if(n > ndata){
        werrstr("loadimage: insufficient data");
        return -1;
    }
    ndata = 0;
    while(r.max.y > r.min.y){
        dy = r.max.y - r.min.y;
        if(dy*bpl > chunk)
            dy = chunk/bpl;
        if(dy <= 0){
            werrstr("loadimage: image too wide for buffer");
            return -1;
        }
        n = dy*bpl;
        a = bufimage(i->display, 21+n);
        if(a == nil){
            werrstr("bufimage failed");
            return -1;
        }
        a[0] = 'y';
        BPLONG(a+1, i->id);
        BPLONG(a+5, r.min.x);
        BPLONG(a+9, r.min.y);
        BPLONG(a+13, r.max.x);
        BPLONG(a+17, r.min.y+dy);
        memmove(a+21, data, n);
        ndata += n;
        data += n;
        r.min.y += dy;
    }
    if(flushimage(i->display, false) < 0)
        return -1;
    return ndata;
}
@

\subsection{marshalling}

\subsection{Unmarshalling}

<<[[drawmesg()]] cases>>=
/* write: 'y' id[4] R[4*4] data[x*1] */
/* write from compressed data: 'Y' id[4] R[4*4] data[x*1] */
case 'y':
case 'Y':
    printmesg(fmt="LR", a, 0);
//  iprint("load %c\n", *a);
    m = 1+4+4*4;
    if(n < m)
        error(Eshortdraw);
    dstid = BGLONG(a+1);
    dst = drawimage(client, a+1);
    drawrectangle(&r, a+5);
    if(!rectinrect(r, dst->r))
        error(Ewriteoutside);

    y = memload(dst, r, a+m, n-m, *a=='Y'); // The call

    if(y < 0)
        error("bad writeimage call");
    dstflush(dstid, dst, r);
    m += y;
    continue;
@

\subsection{Algorithm}

<<function memload>>=
int
memload(Memimage *dst, Rectangle r, uchar *data, int n, int iscompressed)
{
    int (*loadfn)(Memimage*, Rectangle, uchar*, int);
    Memimage *tmp;
    Memlayer *dl;
    Rectangle lr;
    int dx;

    loadfn = loadmemimage;
    if(iscompressed)
        loadfn = cloadmemimage;

    Top:
    dl = dst->layer;
    if(dl == nil)
        return (*loadfn)(dst, r, data, n);

    /*
   * Convert to screen coordinates.
     */
    lr = r;
    r.min.x += dl->delta.x;
    r.min.y += dl->delta.y;
    r.max.x += dl->delta.x;
    r.max.y += dl->delta.y;
    dx = dl->delta.x&(7/dst->depth);
    if(dl->clear && dx==0){
        dst = dl->screen->image;
        goto Top;
    }

    /*
     * dst is an obscured layer or data is unaligned
     */
    if(dl->save && dx==0){
        n = loadfn(dl->save, lr, data, n);
        if(n > 0)
            memlexpose(dst, r);
        return n;
    }
    tmp = allocmemimage(lr, dst->chan);
    if(tmp == nil)
        return -1;
    n = loadfn(tmp, lr, data, n);
    memdraw(dst, lr, tmp, lr.min, nil, lr.min, S);
    freememimage(tmp);
    return n;
}
@


<<function loadmemimage>>=
int
loadmemimage(Memimage *i, Rectangle r, uchar *data, int ndata)
{
    int y, l, lpart, rpart, mx, m, mr;
    uchar *q;

    if(!rectinrect(r, i->r))
        return -1;
    l = bytesperline(r, i->depth);
    if(ndata < l*Dy(r))
        return -1;
    ndata = l*Dy(r);
    q = byteaddr(i, r.min);
    mx = 7/i->depth;
    lpart = (r.min.x & mx) * i->depth;
    rpart = (r.max.x & mx) * i->depth;
    m = 0xFF >> lpart;
    /* may need to do bit insertion on edges */
    if(l == 1){	/* all in one byte */
        if(rpart)
            m ^= 0xFF >> rpart;
        for(y=r.min.y; y<r.max.y; y++){
            *q ^= (*data^*q) & m;
            q += i->width*sizeof(ulong);
            data++;
        }
        return ndata;
    }
    if(lpart==0 && rpart==0){	/* easy case */
        for(y=r.min.y; y<r.max.y; y++){
            memmove(q, data, l);
            q += i->width*sizeof(ulong);
            data += l;
        }
        return ndata;
    }
    mr = 0xFF ^ (0xFF >> rpart);
    if(lpart!=0 && rpart==0){
        for(y=r.min.y; y<r.max.y; y++){
            *q ^= (*data^*q) & m;
            if(l > 1)
                memmove(q+1, data+1, l-1);
            q += i->width*sizeof(ulong);
            data += l;
        }
        return ndata;
    }
    if(lpart==0 && rpart!=0){
        for(y=r.min.y; y<r.max.y; y++){
            if(l > 1)
                memmove(q, data, l-1);
            q[l-1] ^= (data[l-1]^q[l-1]) & mr;
            q += i->width*sizeof(ulong);
            data += l;
        }
        return ndata;
    }
    for(y=r.min.y; y<r.max.y; y++){
        *q ^= (*data^*q) & m;
        if(l > 2)
            memmove(q+1, data+1, l-2);
        q[l-1] ^= (data[l-1]^q[l-1]) & mr;
        q += i->width*sizeof(ulong);
        data += l;
    }
    return ndata;
}
@




\section{Compressed images}

\subsection{API}

<<constant NMATCH>>=
/*
 * Compressed image file parameters and helper routines
 */
#define	NMATCH	3		/* shortest match possible */
@

<<constant NRUN>>=
#define	NRUN	(NMATCH+31)	/* longest match possible */
@

% called???
<<function cloadimage>>=
int
cloadimage(Image *i, Rectangle r, uchar *data, int ndata)
{
    int m, nb, miny, maxy, ncblock;
    uchar *a;

    if(!rectinrect(r, i->r)){
        werrstr("cloadimage: bad rectangle");
        return -1;
    }

    miny = r.min.y;
    m = 0;
    ncblock = _compblocksize(r, i->depth);
    while(miny != r.max.y){
        maxy = atoi((char*)data+0*12);
        nb = atoi((char*)data+1*12);
        if(maxy<=miny || r.max.y<maxy){
            werrstr("creadimage: bad maxy %d", maxy);
            return -1;
        }
        data += 2*12;
        ndata -= 2*12;
        m += 2*12;
        if(nb<=0 || ncblock<nb || nb>ndata){
            werrstr("creadimage: bad count %d", nb);
            return -1;
        }
        a = bufimage(i->display, 21+nb);
        if(a == nil)
            return -1;
        a[0] = 'Y';
        BPLONG(a+1, i->id);
        BPLONG(a+5, r.min.x);
        BPLONG(a+9, miny);
        BPLONG(a+13, r.max.x);
        BPLONG(a+17, maxy);
        memmove(a+21, data, nb);
        miny = maxy;
        data += nb;
        ndata += nb;
        m += nb;
    }
    return m;
}
@

% readimage -> <>
<<function creadimage>>=
Image *
creadimage(Display *d, int fd, int dolock)
{
    char hdr[5*12+1];
    Rectangle r;
    int m, nb, miny, maxy, new, ldepth, ncblock;
    uchar *buf, *a;
    Image *i;
    ulong chan;

    if(readn(fd, hdr, 5*12) != 5*12)
        return nil;

    /*
     * distinguish new channel descriptor from old ldepth.
     * channel descriptors have letters as well as numbers,
     * while ldepths are a single digit formatted as %-11d.
     */
    new = 0;
    for(m=0; m<10; m++){
        if(hdr[m] != ' '){
            new = 1;
            break;
        }
    }
    if(hdr[11] != ' '){
        werrstr("creadimage: bad format");
        return nil;
    }
    if(new){
        hdr[11] = '\0';
        if((chan = strtochan(hdr)) == 0){
            werrstr("creadimage: bad channel string %s", hdr);
            return nil;
        }
    }else{
        ldepth = ((int)hdr[10])-'0';
        if(ldepth<0 || ldepth>3){
            werrstr("creadimage: bad ldepth %d", ldepth);
            return nil;
        }
        chan = drawld2chan[ldepth];
    }
    r.min.x=atoi(hdr+1*12);
    r.min.y=atoi(hdr+2*12);
    r.max.x=atoi(hdr+3*12);
    r.max.y=atoi(hdr+4*12);
    if(r.min.x>r.max.x || r.min.y>r.max.y){
        werrstr("creadimage: bad rectangle");
        return nil;
    }

    if(d){
        if(dolock)
            lockdisplay(d);
        i = allocimage(d, r, chan, 0, 0);
        setmalloctag(i, getcallerpc(&d));
        if(dolock)
            unlockdisplay(d);
        if(i == nil)
            return nil;
    }else{
        i = mallocz(sizeof(Image), 1);
        if(i == nil)
            return nil;
    }
    ncblock = _compblocksize(r, chantodepth(chan));
    buf = malloc(ncblock);
    if(buf == nil)
        goto Errout;
    miny = r.min.y;
    while(miny != r.max.y){
        if(readn(fd, hdr, 2*12) != 2*12){
        Errout:
            if(dolock)
                lockdisplay(d);
        Erroutlock:
            freeimage(i);
            if(dolock)
                unlockdisplay(d);
            free(buf);
            return nil;
        }
        maxy = atoi(hdr+0*12);
        nb = atoi(hdr+1*12);
        if(maxy<=miny || r.max.y<maxy){
            werrstr("creadimage: bad maxy %d", maxy);
            goto Errout;
        }
        if(nb<=0 || ncblock<nb){
            werrstr("creadimage: bad count %d", nb);
            goto Errout;
        }
        if(readn(fd, buf, nb)!=nb)
            goto Errout;
        if(d){
            if(dolock)
                lockdisplay(d);
            a = bufimage(i->display, 21+nb);
            if(a == nil)
                goto Erroutlock;
            a[0] = 'Y';
            BPLONG(a+1, i->id);
            BPLONG(a+5, r.min.x);
            BPLONG(a+9, miny);
            BPLONG(a+13, r.max.x);
            BPLONG(a+17, maxy);
            if(!new)	/* old image: flip the data bits */
                _twiddlecompressed(buf, nb);
            memmove(a+21, buf, nb);
            if(dolock)
                unlockdisplay(d);
        }
        miny = maxy;
    }
    free(buf);
    return i;
}
@


<<function _twiddlecompressed>>=
/*
 * compressed data are seuences of byte codes.  
 * if the first byte b has the 0x80 bit set, the next (b^0x80)+1 bytes
 * are data.  otherwise, it's two bytes specifying a previous string to repeat.
 */
void
_twiddlecompressed(uchar *buf, int n)
{
    uchar *ebuf;
    int j, k, c;

    ebuf = buf+n;
    while(buf < ebuf){
        c = *buf++;
        if(c >= 128){
            k = c-128+1;
            for(j=0; j<k; j++, buf++)
                *buf ^= 0xFF;
        }else
            buf++;
    }
}
@

<<function _compblocksize>>=
int
_compblocksize(Rectangle r, int depth)
{
    int bpl;

    bpl = bytesperline(r, depth);
    bpl = 2*bpl;	/* add plenty extra for blocking, etc. */
    if(bpl < NCBLOCK)
        return NCBLOCK;
    return bpl;
}
@



\subsection{Algorithm}

<<function cloadmemimage>>=
int
cloadmemimage(Memimage *i, Rectangle r, uchar *data, int ndata)
{
    int y, bpl, c, cnt, offs;
    uchar mem[NMEM], *memp, *omemp, *emem, *linep, *elinep, *u, *eu;

    if(!rectinrect(r, i->r))
        return -1;
    bpl = bytesperline(r, i->depth);
    u = data;
    eu = data+ndata;
    memp = mem;
    emem = mem+NMEM;
    y = r.min.y;
    linep = byteaddr(i, Pt(r.min.x, y));
    elinep = linep+bpl;
    for(;;){
        if(linep == elinep){
            if(++y == r.max.y)
                break;
            linep = byteaddr(i, Pt(r.min.x, y));
            elinep = linep+bpl;
        }
        if(u == eu){	/* buffer too small */
            return -1;
        }
        c = *u++;
        if(c >= 128){
            for(cnt=c-128+1; cnt!=0 ;--cnt){
                if(u == eu){		/* buffer too small */
                    return -1;
                }
                if(linep == elinep){	/* phase error */
                    return -1;
                }
                *linep++ = *u;
                *memp++ = *u++;
                if(memp == emem)
                    memp = mem;
            }
        }
        else{
            if(u == eu)	/* short buffer */
                return -1;
            offs = *u++ + ((c&3)<<8)+1;
            if(memp-mem < offs)
                omemp = memp+(NMEM-offs);
            else
                omemp = memp-offs;
            for(cnt=(c>>2)+NMATCH; cnt!=0; --cnt){
                if(linep == elinep)	/* phase error */
                    return -1;
                *linep++ = *omemp;
                *memp++ = *omemp++;
                if(omemp == emem)
                    omemp = mem;
                if(memp == emem)
                    memp = mem;
            }
        }
    }
    return u-data;
}
@




<<function creadmemimage>>=
Memimage*
creadmemimage(int fd)
{
    char hdr[5*12+1];
    Rectangle r;
    int m, nb, miny, maxy, new, ldepth, ncblock;
    uchar *buf;
    Memimage *i;
    ulong chan;

    if(readn(fd, hdr, 5*12) != 5*12){
        werrstr("readmemimage: short header (2)");
        return nil;
    }

    /*
     * distinguish new channel descriptor from old ldepth.
     * channel descriptors have letters as well as numbers,
     * while ldepths are a single digit formatted as %-11d.
     */
    new = 0;
    for(m=0; m<10; m++){
        if(hdr[m] != ' '){
            new = 1;
            break;
        }
    }
    if(hdr[11] != ' '){
        werrstr("creadimage: bad format");
        return nil;
    }
    if(new){
        hdr[11] = '\0';
        if((chan = strtochan(hdr)) == 0){
            werrstr("creadimage: bad channel string %s", hdr);
            return nil;
        }
    }else{
        ldepth = ((int)hdr[10])-'0';
        if(ldepth<0 || ldepth>3){
            werrstr("creadimage: bad ldepth %d", ldepth);
            return nil;
        }
        chan = drawld2chan[ldepth];
    }
    r.min.x=atoi(hdr+1*12);
    r.min.y=atoi(hdr+2*12);
    r.max.x=atoi(hdr+3*12);
    r.max.y=atoi(hdr+4*12);
    if(r.min.x>r.max.x || r.min.y>r.max.y){
        werrstr("creadimage: bad rectangle");
        return nil;
    }

    i = allocmemimage(r, chan);
    if(i == nil)
        return nil;
    ncblock = _compblocksize(r, i->depth);
    buf = malloc(ncblock);
    if(buf == nil)
        goto Errout;
    miny = r.min.y;
    while(miny != r.max.y){
        if(readn(fd, hdr, 2*12) != 2*12){
        Shortread:
            werrstr("readmemimage: short read");
        Errout:
            freememimage(i);
            free(buf);
            return nil;
        }
        maxy = atoi(hdr+0*12);
        nb = atoi(hdr+1*12);
        if(maxy<=miny || r.max.y<maxy){
            werrstr("readimage: bad maxy %d", maxy);
            goto Errout;
        }
        if(nb<=0 || ncblock<nb){
            werrstr("readimage: bad count %d", nb);
            goto Errout;
        }
        if(readn(fd, buf, nb)!=nb)
            goto Shortread;
        if(!new)	/* old image: flip the data bits */
            _twiddlecompressed(buf, nb);
        cloadmemimage(i, Rect(r.min.x, miny, r.max.x, maxy), buf, nb);
        miny = maxy;
    }
    free(buf);
    return i;
}
@





\chapter{Windows}
% Layers

% ??? 
<<function newwindow>>=
/* Connect us to new window, if possible */
int
newwindow(char *str)
{
    int fd;
    char *wsys;
    char buf[256];

    wsys = getenv("wsys");
    if(wsys == nil)
        return -1;
    fd = open(wsys, ORDWR);
    free(wsys);
    if(fd < 0)
        return -1;
    rfork(RFNAMEG);
    if(str)
        snprint(buf, sizeof buf, "new %s", str);
    else
        strcpy(buf, "new");
    return mount(fd, -1, "/dev", MBEFORE, buf);
}
@

\section{Screen creation, [[Screen]] and [[Memscreen]]}
% and [[_screen]]

<<struct Screen>>=
struct Screen
{
    Display	*display;	/* display holding data */
    int		id;			/* id of system-held Screen */
    Image	*image;		/* unused; for reference only */
    Image	*fill;		/* color to paint behind windows */
};
@
%less: delete image field?

<<global _screen>>=
Screen	*screen;
@
%old: was called _screen because screen was already use 
% (to actually an Image, hmm), but I s/screen/view so now screen is free.


<<global screenid>>=
static int	screenid;
@


<<struct Memscreen>>=
struct Memscreen
{
    Memimage	*frontmost;	/* frontmost layer on screen */
    Memimage	*rearmost;	/* rearmost layer on screen */
    Memimage	*image;		/* upon which all layers are drawn */
    Memimage	*fill;			/* if non-zero, picture to use when repainting */
};
@

<<struct Memlayer>>=
struct Memlayer
{
    Rectangle		screenr;	/* true position of layer on screen */
    Point			delta;	/* add delta to go from image coords to screen */
    Memscreen	*screen;	/* screen this layer belongs to */
    Memimage	*front;	/* window in front of this one */
    Memimage	*rear;	/* window behind this one*/
    int		clear;	/* layer is fully visible */
    Memimage	*save;	/* save area for obscured parts */
    Refreshfn	refreshfn;		/* function to call to refresh obscured parts if save==nil */
    void		*refreshptr;	/* argument to refreshfn */
};
@


\subsection{API}

<<function allocscreen>>=
Screen*
allocscreen(Image *image, Image *fill, int public)
{
    uchar *a;
    Screen *s;
    int id, try;
    Display *d;

    d = image->display;
    if(d != fill->display){
        werrstr("allocscreen: image and fill on different displays");
        return 0;
    }
    s = malloc(sizeof(Screen));
    if(s == 0)
        return 0;
    SET(id);
    for(try=0; try<25; try++){
        /* loop until find a free id */
        a = bufimage(d, 1+4+4+4+1);
        if(a == 0){
            free(s);
            return 0;
        }
        id = ++screenid;
        a[0] = 'A';
        BPLONG(a+1, id);
        BPLONG(a+5, image->id);
        BPLONG(a+9, fill->id);
        a[13] = public;
        if(flushimage(d, false) != -1)
            break;
    }
    s->display = d;
    s->id = id;
    s->image = image;
    assert(s->image && s->image->chan != 0);

    s->fill = fill;
    return s;
}
@

<<function freescreen>>=
int
freescreen(Screen *s)
{
    uchar *a;
    Display *d;

    if(s == 0)
        return 0;
    d = s->display;
    a = bufimage(d, 1+4);
    if(a == 0)
        return -1;
    a[0] = 'F';
    BPLONG(a+1, s->id);
    /*
     * flush(1) because screen is likely holding last reference to
     * window, and want it to disappear visually.
     */
    if(flushimage(d, true) < 0)
        return -1;
    free(s);
    return 1;
}
@

<<function publicscreen>>=
Screen*
publicscreen(Display *d, int id, ulong chan)
{
    uchar *a;
    Screen *s;

    s = malloc(sizeof(Screen));
    if(s == 0)
        return 0;
    a = bufimage(d, 1+4+4);
    if(a == 0){
    Error:
        free(s);
        return 0;
    }
    a[0] = 'S';
    BPLONG(a+1, id);
    BPLONG(a+5, chan);
    if(flushimage(d, false) < 0)
        goto Error;

    s->display = d;
    s->id = id;
    s->image = 0;
    s->fill = 0;
    return s;
}
@


\subsection{Marshalling}

\subsection{Unmarshalling}


<<[[drawmesg()]] cases>>=
/* allocate screen: 'A' id[4] imageid[4] fillid[4] public[1] */
case 'A':
    printmesg(fmt="LLLb", a, 1);
    m = 1+4+4+4+1;
    if(n < m)
        error(Eshortdraw);
    dstid = BGLONG(a+1);
    if(dstid == 0)
        error(Ebadarg);
    if(drawlookupdscreen(dstid))
        error(Escreenexists);
    ddst = drawlookup(client, BGLONG(a+5), 1);
    dsrc = drawlookup(client, BGLONG(a+9), 1);
    if(ddst==0 || dsrc==0)
        error(Enodrawimage);

    if(drawinstallscreen(client, 0, dstid, ddst, dsrc, a[13]) == 0) // The call
        error(Edrawmem);
    continue;

@

<<[[drawmesg()]] cases>>=
/* free screen: 'F' id[4] */
case 'F':
    printmesg(fmt="L", a, 1);
    m = 1+4;
    if(n < m)
        error(Eshortdraw);
    drawlookupscreen(client, BGLONG(a+1), &cs);
    drawuninstallscreen(client, cs); // The call
    continue;

@



<<[[drawmesg()]] cases>>=
/* use public screen: 'S' id[4] chan[4] */
case 'S':
    printmesg(fmt="Ll", a, 0);
    m = 1+4+4;
    if(n < m)
        error(Eshortdraw);
    dstid = BGLONG(a+1);
    if(dstid == 0)
        error(Ebadarg);
    dscrn = drawlookupdscreen(dstid);
    if(dscrn==0 || (dscrn->public==0 && dscrn->owner!=client))
        error(Enodrawscreen);
    if(dscrn->screen->image->chan != BGLONG(a+5))
        error("inconsistent chan");

    if(drawinstallscreen(client, dscrn, 0, 0, 0, 0) == 0) // The call
        error(Edrawmem);
    continue;

@


\subsection{Algorithm}

% devdraw.c
<<function drawinstallscreen>>=
Memscreen*
drawinstallscreen(Client *client, DScreen *d, int id, DImage *dimage, DImage *dfill, int public)
{
    Memscreen *s;
    CScreen *c;

    c = malloc(sizeof(CScreen));
    if(dimage && dimage->image && dimage->image->chan == 0)
        panic("bad image %p in drawinstallscreen", dimage->image);

    if(c == 0)
        return 0;
    if(d == 0){
        d = malloc(sizeof(DScreen));
        if(d == 0){
            free(c);
            return 0;
        }
        s = malloc(sizeof(Memscreen));
        if(s == 0){
            free(c);
            free(d);
            return 0;
        }
        s->frontmost = 0;
        s->rearmost = 0;
        d->dimage = dimage;
        if(dimage){
            s->image = dimage->image;
            dimage->ref++;
        }
        d->dfill = dfill;
        if(dfill){
            s->fill = dfill->image;
            dfill->ref++;
        }
        d->ref = 0;
        d->id = id;
        d->screen = s;
        d->public = public;
        d->next = dscreen;
        d->owner = client;
        dscreen = d;
    }
    c->dscreen = d;
    d->ref++;
    c->next = client->cscreen;
    client->cscreen = c;
    return d->screen;
}
@

<<function drawuninstallscreen>>=
void
drawuninstallscreen(Client *client, CScreen *this)
{
    CScreen *cs, *next;

    cs = client->cscreen;
    if(cs == this){
        client->cscreen = this->next;
        drawfreedscreen(this->dscreen);
        free(this);
        return;
    }
    while(next = cs->next){ /* assign = */
        if(next == this){
            cs->next = this->next;
            drawfreedscreen(this->dscreen);
            free(this);
            return;
        }
        cs = next;
    }
}
@

\section{Hooks}

\subsection{Image allocation}

%TODO mv in Windows section?
<<[[drawmesg()]] allocate image case, if screen id>>=
if(scrnid){
    dscrn = drawlookupscreen(client, scrnid, &cs);
    scrn = dscrn->screen;
    if(repl || chan!=scrn->image->chan)
        error("image parameters incompatible with screen");
    reffn = nil;
    switch(refresh){
    case Refbackup:
        break;
    case Refnone:
        reffn = memlnorefresh;
        break;
    case Refmesg:
        reffn = drawrefresh;
        break;
    default:
        error("unknown refresh method");
    }
    l = memlalloc(scrn, r, reffn, 0, value);
    if(l == 0)
        error(Edrawmem);
    addflush(l->layer->screenr);
    l->clipr = clipr;
    rectclip(&l->clipr, r);
    if(drawinstall(client, dstid, l, dscrn) == 0){
        memldelete(l);
        error(Edrawmem);
    }
    dscrn->ref++;
    if(reffn){
        refx = nil;
        if(reffn == drawrefresh){
            refx = malloc(sizeof(Refx));
            if(refx == 0){
                drawuninstall(client, dstid);
                error(Edrawmem);
            }
            refx->client = client;
            refx->dimage = drawlookup(client, dstid, 1);
        }
        memlsetrefresh(l, reffn, refx);
    }
    continue;
}
@


\subsection{Image draw}


<<[[Draw]] other fields>>=
Memlayer		*dstlayer;
@


<<[[memdraw()]] when have layers>>=
if(drawclip(dst, &r, src, &p0, mask, &p1, &srcr, &mr) == 0){
   if(drawdebug)	iprint("drawclip dstcr %R srccr %R maskcr %R\n", dst->clipr, src->clipr, mask->clipr);
    return;
}

/*
 Convert to screen coordinates.
 */
dl = dst->layer;
if(dl != nil){
    r.min.x += dl->delta.x;
    r.min.y += dl->delta.y;
    r.max.x += dl->delta.x;
    r.max.y += dl->delta.y;
}
Clearlayer:
if(dl!=nil && dl->clear){
    if(src == dst){
        p0.x += dl->delta.x;
        p0.y += dl->delta.y;
        src = dl->screen->image;
    }
    dst = dl->screen->image;
    goto Top;
}

sl = src->layer;
if(sl != nil){
    p0.x += sl->delta.x;
    p0.y += sl->delta.y;
    srcr.min.x += sl->delta.x;
    srcr.min.y += sl->delta.y;
    srcr.max.x += sl->delta.x;
    srcr.max.y += sl->delta.y;
}

/*
 * Now everything is in screen coordinates.
 * mask is an image.  dst and src are images or obscured layers.
 */

/*
 * if dst and src are the same layer, just draw in save area and expose.
 */
if(dl!=nil && dst==src){
    if(dl->save == nil)
        return;	/* refresh function makes this case unworkable */
    if(rectXrect(r, srcr)){
        tr = r;
        if(srcr.min.x < tr.min.x){
            p1.x += tr.min.x - srcr.min.x;
            tr.min.x = srcr.min.x;
        }
        if(srcr.min.y < tr.min.y){
            p1.y += tr.min.x - srcr.min.x;
            tr.min.y = srcr.min.y;
        }
        if(srcr.max.x > tr.max.x)
            tr.max.x = srcr.max.x;
        if(srcr.max.y > tr.max.y)
            tr.max.y = srcr.max.y;
        memlhide(dst, tr);
    }else{
        memlhide(dst, r);
        memlhide(dst, srcr);
    }
    memdraw(dl->save, rectsubpt(r, dl->delta), dl->save,
        subpt(srcr.min, src->layer->delta), mask, p1, op);
    memlexpose(dst, r);
    return;
}

if(sl){
    if(sl->clear){
        src = sl->screen->image;
        if(dl != nil){
            r.min.x -= dl->delta.x;
            r.min.y -= dl->delta.y;
            r.max.x -= dl->delta.x;
            r.max.y -= dl->delta.y;
        }
        goto Top;
    }
    /* relatively rare case; use save area */
    if(sl->save == nil)
        return;	/* refresh function makes this case unworkable */
    memlhide(src, srcr);
    /* convert back to logical coordinates */
    p0.x -= sl->delta.x;
    p0.y -= sl->delta.y;
    srcr.min.x -= sl->delta.x;
    srcr.min.y -= sl->delta.y;
    srcr.max.x -= sl->delta.x;
    srcr.max.y -= sl->delta.y;
    src = src->layer->save;
}

/*
 * src is now an image.  dst may be an image or a clear layer
 */
if(dst->layer==nil)
    goto Top;
if(dst->layer->clear)
    goto Clearlayer;

/*
 * dst is an obscured layer
 */
d.deltas = subpt(p0, r.min);
d.deltam = subpt(p1, r.min);
d.dstlayer = dl;
d.src = src;
d.op = op;
d.mask = mask;
_memlayerop(ldrawop, dst, r, r, &d);
@


<<[[memdraw()]] if mask has layer>>=
if(mask->layer){
  if(drawdebug)	iprint("mask->layer != nil\n");
    return;	/* too hard, at least for now */
}
@


% -> <>
<<function _memlayerop>>=
/*
 * Assumes incoming rectangle has already been clipped to i's logical r and clipr
 */
void
_memlayerop(
    void (*fn)(Memimage*, Rectangle, Rectangle, void*, int),
    Memimage *i,
    Rectangle screenr,	/* clipped to window boundaries */
    Rectangle clipr,		/* clipped also to clipping rectangles of hierarchy */
    void *etc)
{
    Memlayer *l;
    Rectangle r, scr;

    l = i->layer;
    if(!rectclip(&screenr, l->screenr))
        return;
    if(l->clear){
        fn(l->screen->image, screenr, clipr, etc, 0);
        return;
    }
    r = screenr;
    scr = l->screen->image->clipr;

    /*
     * Do the piece on the screen
     */
    if(rectclip(&screenr, scr))
        _layerop(fn, i, screenr, clipr, etc, l->screen->frontmost);
    if(rectinrect(r, scr))
        return;

    /*
     * Do the piece off the screen
    */
    if(!rectXrect(r, scr)){
        /* completely offscreen; easy */
        fn(l->save, r, clipr, etc, 1);
        return;
    }
    if(r.min.y < scr.min.y){
        /* above screen */
        fn(l->save, Rect(r.min.x, r.min.y, r.max.x, scr.min.y), clipr, etc, 1);
        r.min.y = scr.min.y;
    }
    if(r.max.y > scr.max.y){
        /* below screen */
        fn(l->save, Rect(r.min.x, scr.max.y, r.max.x, r.max.y), clipr, etc, 1);
        r.max.y = scr.max.y;
    }
    if(r.min.x < scr.min.x){
        /* left of screen */
        fn(l->save, Rect(r.min.x, r.min.y, scr.min.x, r.max.y), clipr, etc, 1);
        r.min.x = scr.min.x;
    }
    if(r.max.x > scr.max.x){
        /* right of screen */
        fn(l->save, Rect(scr.max.x, r.min.y, r.max.x, r.max.y), clipr, etc, 1);
    }
}
@


<<function RECUR>>=
#define	RECUR(a,b,c,d)	_layerop(fn, i, Rect(a.x, b.y, c.x, d.y), clipr, etc, front->layer->rear);
@

<<function _layerop>>=
static void
_layerop(
    void (*fn)(Memimage*, Rectangle, Rectangle, void*, int),
    Memimage *i,
    Rectangle r,
    Rectangle clipr,
    void *etc,
    Memimage *front)
{
    Rectangle fr;

    Top:
    if(front == i){
        /* no one is in front of this part of window; use the screen */
        fn(i->layer->screen->image, r, clipr, etc, 0);
        return;
    }
    fr = front->layer->screenr;
    if(rectXrect(r, fr) == 0){
        /* r doesn't touch this window; continue on next rearmost */
        // assert(front && front->layer && front->layer->screen && front->layer->rear);
        front = front->layer->rear;
        goto Top;
    }
    if(fr.max.y < r.max.y){
        RECUR(r.min, fr.max, r.max, r.max);
        r.max.y = fr.max.y;
    }
    if(r.min.y < fr.min.y){
        RECUR(r.min, r.min, r.max, fr.min);
        r.min.y = fr.min.y;
    }
    if(fr.max.x < r.max.x){
        RECUR(fr.max, r.min, r.max, r.max);
        r.max.x = fr.max.x;
    }
    if(r.min.x < fr.min.x){
        RECUR(r.min, r.min, fr.min, r.max);
        r.min.x = fr.min.x;
    }
    /* r is covered by front, so put in save area */
    (*fn)(i->layer->save, r, clipr, etc, 1);
}
@



<<function ldrawop>>=
static
void
ldrawop(Memimage *dst, Rectangle screenr, Rectangle clipr, void *etc, int insave)
{
    struct Draw *d;
    Point p0, p1;
    Rectangle oclipr, srcr, r, mr;
    int ok;

    d = etc;
    if(insave && d->dstlayer->save==nil)
        return;

    p0 = addpt(screenr.min, d->deltas);
    p1 = addpt(screenr.min, d->deltam);

    if(insave){
        r = rectsubpt(screenr, d->dstlayer->delta);
        clipr = rectsubpt(clipr, d->dstlayer->delta);
    }else
        r = screenr;

    /* now in logical coordinates */

    /* clipr may have narrowed what we should draw on, so clip if necessary */
    if(!rectinrect(r, clipr)){
        oclipr = dst->clipr;
        dst->clipr = clipr;
        ok = drawclip(dst, &r, d->src, &p0, d->mask, &p1, &srcr, &mr);
        dst->clipr = oclipr;
        if(!ok)
            return;
    }
    memdraw(dst, r, d->src, p0, d->mask, p1, d->op);
}
@







\subsection{Image line}

<<[[_memline()]] when have layers>>=
if(!srcclipped){
    d = subpt(sp, p0);
    if(rectclip(&clipr, rectsubpt(src->clipr, d)) == 0)
        return;
    if((src->flags&Frepl)==0 && rectclip(&clipr, rectsubpt(src->r, d))==0)
        return;
    srcclipped = 1;
}

/* dst is known to be a layer */
p0.x += dl->delta.x;
p0.y += dl->delta.y;
p1.x += dl->delta.x;
p1.y += dl->delta.y;
clipr.min.x += dl->delta.x;
clipr.min.y += dl->delta.y;
clipr.max.x += dl->delta.x;
clipr.max.y += dl->delta.y;
if(dl->clear){
    dst = dst->layer->screen->image;
    goto Top;
}

/* XXX */
/* this is not the correct set of tests */
//	if(log2[dst->depth] != log2[src->depth] || log2[dst->depth]!=3)
//		return;

/* can't use sutherland-cohen clipping because lines are wide */
r = memlinebbox(p0, p1, end0, end1, radius);
/*
 * r is now a bounding box for the line;
 * use it as a clipping rectangle for subdivision
 */
if(rectclip(&r, clipr) == 0)
    return;
ll.p0 = p0;
ll.p1 = p1;
ll.end0 = end0;
ll.end1 = end1;
ll.sp = sp;
ll.dstlayer = dst->layer;
ll.src = src;
ll.radius = radius;
ll.delta = dl->delta;
ll.op = op;
_memlayerop(llineop, dst, r, r, &ll);
@

<<function llineop>>=
static
void
llineop(Memimage *dst, Rectangle screenr, Rectangle clipr, void *etc, int insave)
{
    struct Lline *ll;
    Point p0, p1;

    USED(screenr.min.x);
    ll = etc;
    if(insave && ll->dstlayer->save==nil)
        return;
    if(!rectclip(&clipr, screenr))
        return;
    if(insave){
        p0 = subpt(ll->p0, ll->delta);
        p1 = subpt(ll->p1, ll->delta);
        clipr = rectsubpt(clipr, ll->delta);
    }else{
        p0 = ll->p0;
        p1 = ll->p1;
    }
    // recurse
    _memline(dst, p0, p1, ll->end0, ll->end1, ll->radius, ll->src, ll->sp, clipr, ll->op);
}
@







\section{Window creation}

<<function allocwindow>>=
Image*
allocwindow(Screen *s, Rectangle r, int ref, ulong val)
{
    return _allocwindow(nil, s, r, ref, val);
}
@

<<function _allocwindow>>=
Image*
_allocwindow(Image *i, Screen *s, Rectangle r, int ref, ulong val)
{
    Display *d;

    d = s->display;
    i = _allocimage(i, d, r, d->screenimage->chan, 0, val, s->id, ref);
    if(i == 0)
        return 0;
    i->screen = s;
    i->next = s->display->windows;
    s->display->windows = i;
    return i;
}
@


\section{Window refresh}

<<function memlsetrefresh>>=
int
memlsetrefresh(Memimage *i, Refreshfn fn, void *ptr)
{
    Memlayer *l;

    l = i->layer;
    if(l->refreshfn!=nil && fn!=nil){	/* just change functions */
        l->refreshfn = fn;
        l->refreshptr = ptr;
        return 1;
    }

    if(l->refreshfn == nil){	/* is using backup image; just free it */
        freememimage(l->save);
        l->save = nil;
        l->refreshfn = fn;
        l->refreshptr = ptr;
        return 1;
    }

    l->save = allocmemimage(i->r, i->chan);
    if(l->save == nil)
        return 0;
    /* easiest way is just to update the entire save area */
    l->refreshfn(i, i->r, l->refreshptr);
    l->refreshfn = nil;
    l->refreshptr = nil;
    return 1;
}
@


\section{Window hide/expose}

% memlhide -> <>
<<function lhideop>>=
/*
 * Hide puts that portion of screenr now on the screen into the window's save area.
 * Expose puts that portion of screenr now in the save area onto the screen.
 *
 * Hide and Expose both require that the layer structures in the screen
 * match the geometry they are being asked to update, that is, they update the
 * save area (hide) or screen (expose) based on what those structures tell them.
 * This means they must be called at the correct time during window shuffles.
 */
static
void
lhideop(Memimage *src, Rectangle screenr, Rectangle clipr, void *etc, int insave)
{
    Rectangle r;
    Memlayer *l;

    USED(clipr.min.x);
    USED(insave);
    l = etc;
    if(src != l->save){	/* do nothing if src is already in save area */
        r = rectsubpt(screenr, l->delta);
        memdraw(l->save, r, src, screenr.min, nil, screenr.min, S);
    }
}
@

<<function memlhide>>=
void
memlhide(Memimage *i, Rectangle screenr)
{
    if(i->layer->save == nil)
        return;
    if(rectclip(&screenr, i->layer->screen->image->r) == 0)
        return;
    _memlayerop(lhideop, i, screenr, screenr, i->layer);
}
@

<<function lexposeop>>=
static
void
lexposeop(Memimage *dst, Rectangle screenr, Rectangle clipr, void *etc, int insave)
{
    Memlayer *l;
    Rectangle r;

    USED(clipr.min.x);
    if(insave)	/* if dst is save area, don't bother */
        return;
    l = etc;
    r = rectsubpt(screenr, l->delta);
    if(l->save)
        memdraw(dst, screenr, l->save, r.min, nil, r.min, S);
    else
        l->refreshfn(dst, r, l->refreshptr);
}
@

<<function memlexpose>>=
void
memlexpose(Memimage *i, Rectangle screenr)
{
    if(rectclip(&screenr, i->layer->screen->image->r) == 0)
        return;
    _memlayerop(lexposeop, i, screenr, screenr, i->layer);
}
@

\section{Window origin}

\subsection{API}

<<function originwindow>>=
int
originwindow(Image *w, Point log, Point scr)
{
    uchar *b;
    Point delta;

    flushimage(w->display, false);
    b = bufimage(w->display, 1+4+2*4+2*4);
    if(b == nil)
        return 0;
    b[0] = 'o';
    BPLONG(b+1, w->id);
    BPLONG(b+5, log.x);
    BPLONG(b+9, log.y);
    BPLONG(b+13, scr.x);
    BPLONG(b+17, scr.y);
    if(flushimage(w->display, true) < 0)
        return -1;
    delta = subpt(log, w->r.min);
    w->r = rectaddpt(w->r, delta);
    w->clipr = rectaddpt(w->clipr, delta);
    return 1;
}
@

\subsection{Marshalling}

\subsection{Unmarshalling}

<<[[drawmesg()]] cases>>=
/* position window: 'o' id[4] r.min [2*4] screenr.min [2*4] */
case 'o':
    printmesg(fmt="LPP", a, 0);
    m = 1+4+2*4+2*4;
    if(n < m)
        error(Eshortdraw);
    dst = drawimage(client, a+1);
    if(dst->layer){
        drawpoint(&p, a+5);
        drawpoint(&q, a+13);
        r = dst->layer->screenr;

        ni = memlorigin(dst, p, q); // The call

        if(ni < 0)
            error("image origin failed");
        if(ni > 0){
            addflush(r);
            addflush(dst->layer->screenr);
            ll = drawlookup(client, BGLONG(a+1), 1);
            drawrefreshscreen(ll, client);
        }
    }
    continue;
@

\subsection{Algorithm}

<<function memlorigin>>=
/*
 * Place i so i->r.min = log, i->layer->screenr.min == scr.
*/
int
memlorigin(Memimage *i, Point log, Point scr)
{
    Memlayer *l;
    Memscreen *s;
    Memimage *t, *shad, *nsave;
    Rectangle x, newr, oldr;
    Point delta;
    int overlap, eqlog, eqscr, wasclear;

    l = i->layer;
    s = l->screen;
    oldr = l->screenr;
    newr = Rect(scr.x, scr.y, scr.x+Dx(oldr), scr.y+Dy(oldr));
    eqscr = eqpt(scr, oldr.min);
    eqlog = eqpt(log, i->r.min);
    if(eqscr && eqlog)
        return 0;
    nsave = nil;
    if(eqlog==0 && l->save!=nil){
        nsave = allocmemimage(Rect(log.x, log.y, log.x+Dx(oldr), log.y+Dy(oldr)), i->chan);
        if(nsave == nil)
            return -1;
    }

    /*
     * Bring it to front and move logical coordinate system.
     */
    memltofront(i);
    wasclear = l->clear;
    if(nsave){
        if(!wasclear)
            memimagedraw(nsave, nsave->r, l->save, l->save->r.min, nil, Pt(0,0), S);
        freememimage(l->save);
        l->save = nsave;
    }
    delta = subpt(log, i->r.min);
    i->r = rectaddpt(i->r, delta);
    i->clipr = rectaddpt(i->clipr, delta);
    l->delta = subpt(l->screenr.min, i->r.min);
    if(eqscr)
        return 0;

    /*
     * To clean up old position, make a shadow window there, don't paint it,
     * push it behind this one, and (later) delete it.  Because the refresh function
     * for this fake window is a no-op, this will cause no graphics action except
     * to restore the background and expose the windows previously hidden.
     */
    shad = memlalloc(s, oldr, memlnorefresh, nil, DNofill);
    if(shad == nil)
        return -1;
    s->frontmost = i;
    if(s->rearmost == i)
        s->rearmost = shad;
    else
        l->rear->layer->front = shad;
    shad->layer->front = i;
    shad->layer->rear = l->rear;
    l->rear = shad;
    l->front = nil;
    shad->layer->clear = 0;

    /*
     * Shadow is now holding down the fort at the old position.
     * Move the window and hide things obscured by new position.
     */
    for(t=l->rear->layer->rear; t!=nil; t=t->layer->rear){
        x = newr;
        overlap = rectclip(&x, t->layer->screenr);
        if(overlap){
            memlhide(t, x);
            t->layer->clear = 0;
        }
    }
    l->screenr = newr;
    l->delta = subpt(scr, i->r.min);
    l->clear = rectinrect(newr, l->screen->image->clipr);

    /*
     * Everything's covered.  Copy to new position and delete shadow window.
     */
    if(wasclear)
        memdraw(s->image, newr, s->image, oldr.min, nil, Pt(0,0), S);
    else
        memlexpose(i, newr);
    memldelete(shad);

    return 1;
}
@

<<function memlnorefresh>>=
void
memlnorefresh(Memimage *l, Rectangle r, void *v)
{
    USED(l);
    USED(r.min.x);
    USED(v);
}
@



<<function memlalloc>>=
Memimage*
memlalloc(Memscreen *s, Rectangle screenr, Refreshfn refreshfn, void *refreshptr, ulong val)
{
    Memlayer *l;
    Memimage *n;
    static Memimage *paint;

    if(paint == nil){
        paint = allocmemimage(Rect(0,0,1,1), RGBA32);
        if(paint == nil)
            return nil;
        paint->flags |= Frepl;
        paint->clipr = Rect(-0x3FFFFFF, -0x3FFFFFF, 0x3FFFFFF, 0x3FFFFFF);
    }

    n = allocmemimaged(screenr, s->image->chan, s->image->data);
    if(n == nil)
        return nil;
    l = malloc(sizeof(Memlayer));
    if(l == nil){
        free(n);
        return nil;
    }

    l->screen = s;
    if(refreshfn)
        l->save = nil;
    else{
        l->save = allocmemimage(screenr, s->image->chan);
        if(l->save == nil){
            free(l);
            free(n);
            return nil;
        }
        /* allocmemimage doesn't initialize memory; this paints save area */
        if(val != DNofill)
            memfillcolor(l->save, val);
    }
    l->refreshfn = refreshfn;
    l->refreshptr = nil;	/* don't set it until we're done */
    l->screenr = screenr;
    l->delta = Pt(0,0);

    n->data->ref++;
    n->zero = s->image->zero;
    n->width = s->image->width;
    n->layer = l;

    /* start with new window behind all existing ones */
    l->front = s->rearmost;
    l->rear = nil;
    if(s->rearmost)
        s->rearmost->layer->rear = n;
    s->rearmost = n;
    if(s->frontmost == nil)
        s->frontmost = n;
    l->clear = 0;

    /* now pull new window to front */
    _memltofrontfill(n, val != DNofill);
    l->refreshptr = refreshptr;

    /*
     * paint with requested color; previously exposed areas are already right
     * if this window has backing store, but just painting the whole thing is simplest.
     */
    if(val != DNofill){
        memsetchan(paint, n->chan);
        memfillcolor(paint, val);
        memdraw(n, n->r, paint, n->r.min, nil, n->r.min, S);
    }
    return n;
}
@



<<function memldelete>>=
void
memldelete(Memimage *i)
{
    Memscreen *s;
    Memlayer *l;

    l = i->layer;
    /* free backing store and disconnect refresh, to make pushback fast */
    freememimage(l->save);
    l->save = nil;
    l->refreshptr = nil;
    memltorear(i);

    /* window is now the rearmost;  clean up screen structures and deallocate */
    s = i->layer->screen;
    if(s->fill){
        i->clipr = i->r;
        memdraw(i, i->r, s->fill, i->r.min, nil, i->r.min, S);
    }
    if(l->front){
        l->front->layer->rear = nil;
        s->rearmost = l->front;
    }else{
        s->frontmost = nil;
        s->rearmost = nil;
    }
    free(l);
    freememimage(i);
}
@

<<function memlfree>>=
/*
 * Just free the data structures, don't do graphics
 */
void
memlfree(Memimage *i)
{
    Memlayer *l;

    l = i->layer;
    freememimage(l->save);
    free(l);
    freememimage(i);
}
@

<<function _memlsetclear>>=
void
_memlsetclear(Memscreen *s)
{
    Memimage *i, *j;
    Memlayer *l;

    for(i=s->rearmost; i; i=i->layer->front){
        l = i->layer;
        l->clear = rectinrect(l->screenr, l->screen->image->clipr);
        if(l->clear)
            for(j=l->front; j; j=j->layer->front)
                if(rectXrect(l->screenr, j->layer->screenr)){
                    l->clear = 0;
                    break;
                }
    }
}
@


\section{Windows stack manipulation}
%extern int	newwindow(char*);
% but actually it returns an int that is probably similar to a fd
% and rio itself match this id to a Window structure

% window managment! topwindow(), etc.


\subsection{API}

<<function bottomwindow>>=
void
bottomwindow(Image *w)
{
    if(w->screen == 0)
        return;
    topbottom(&w, 1, 0);
}
@

<<function topwindow>>=
void
topwindow(Image *w)
{
    if(w->screen == 0)
        return;
    topbottom(&w, 1, 1);
}
@

<<function bottomnwindows>>=
void
bottomnwindows(Image **w, int n)
{
    topbottom(w, n, 0);
}
@

<<function topnwindows>>=
void
topnwindows(Image **w, int n)
{
    topbottom(w, n, 1);
}
@

\subsection{Marshalling}


% _topbottom?
<<function topbottom>>=
static
void
topbottom(Image **w, int n, int top)
{
    int i;
    uchar *b;
    Display *d;

    if(n < 0){
    Ridiculous:
        fprint(2, "top/bottom: ridiculous number of windows\n");
        return;
    }
    if(n == 0)
        return;
    if(n > (w[0]->display->bufsize-100)/4)
        goto Ridiculous;
    /*
     * this used to check that all images were on the same screen.
     * we don't know the screen associated with images we acquired
     * by name.  instead, check that all images are on the same display.
     * the display will check that they are all on the same screen.
     */
    d = w[0]->display;
    for(i=1; i<n; i++)
        if(w[i]->display != d){
            fprint(2, "top/bottom: windows not on same screen\n");
            return;
        }

    if(n==0)
        return;
    b = bufimage(d, 1+1+2+4*n);
    b[0] = 't';
    b[1] = top;
    BPSHORT(b+2, n);
    for(i=0; i<n; i++)
        BPLONG(b+4+4*i, w[i]->id);
}
@

\subsection{Unmarshalling}


<<[[drawmesg()]] cases>>=
/* top or bottom windows: 't' top[1] nw[2] n*id[4] */
case 't':
    printmesg(fmt="bsL", a, 0);
    m = 1+1+2;
    if(n < m)
        error(Eshortdraw);
    nw = BGSHORT(a+2);
    if(nw < 0)
        error(Ebadarg);
    if(nw == 0)
        continue;
    m += nw*4;
    if(n < m)
        error(Eshortdraw);
    lp = malloc(nw*sizeof(Memimage*));
    if(lp == 0)
        error(Enomem);
    if(waserror()){
        free(lp);
        nexterror();
    }
    for(j=0; j<nw; j++)
        lp[j] = drawimage(client, a+1+1+2+j*4);
    if(lp[0]->layer == 0)
        error("images are not windows");
    for(j=1; j<nw; j++)
        if(lp[j]->layer->screen != lp[0]->layer->screen)
            error("images not on same screen");

    if(a[1])
        memltofrontn(lp, nw); // The call
    else
        memltorearn(lp, nw); // The call

    if(lp[0]->layer->screen->image->data == screenimage->data)
        for(j=0; j<nw; j++)
            addflush(lp[j]->layer->screenr);
    ll = drawlookup(client, BGLONG(a+1+1+2), 1);
    drawrefreshscreen(ll, client);
    poperror();
    free(lp);
    continue;

@

\subsection{Algorithm}

<<function memltofront>>=
void
memltofront(Memimage *i)
{
    _memltofront(i, nil, 1);
    _memlsetclear(i->layer->screen);
}
@


<<function memltofrontn>>=
void
memltofrontn(Memimage **ip, int n)
{
    Memimage *i, *front;
    Memscreen *s;

    if(n == 0)
        return;
    front = nil;
    while(--n >= 0){
        i = *ip++;
        _memltofront(i, front, 1);
        front = i;
    }
    s = front->layer->screen;
    _memlsetclear(s);
}
@


<<function _memltofront>>=
/*
 * Pull i towards top of screen, just behind front
*/
static
void
_memltofront(Memimage *i, Memimage *front, int fill)
{
    Memlayer *l;
    Memscreen *s;
    Memimage *f, *ff, *rr;
    Rectangle x;
    int overlap;

    l = i->layer;
    s = l->screen;
    while(l->front != front){
        f = l->front;
        x = l->screenr;
        overlap = rectclip(&x, f->layer->screenr);
        if(overlap){
            memlhide(f, x);
            f->layer->clear = 0;
        }
        /* swap l and f in screen's list */
        ff = f->layer->front;
        rr = l->rear;
        if(ff == nil)
            s->frontmost = i;
        else
            ff->layer->rear = i;
        if(rr == nil)
            s->rearmost = f;
        else
            rr->layer->front = f;
        l->front = ff;
        l->rear = f;
        f->layer->front = i;
        f->layer->rear = rr;
        if(overlap && fill)
            memlexpose(i, x);
    }
}
@

<<function _memltofrontfill>>=
void
_memltofrontfill(Memimage *i, int fill)
{
    _memltofront(i, nil, fill);
    _memlsetclear(i->layer->screen);
}
@




<<function memltorearn>>=
void
memltorearn(Memimage **ip, int n)
{
    Memimage *i, *rear;
    Memscreen *s;

    if(n == 0)
        return;
    rear = nil;
    while(--n >= 0){
        i = *ip++;
        _memltorear(i, rear);
        rear = i;
    }
    s = rear->layer->screen;
    _memlsetclear(s);
}
@

<<function memltorear>>=
void
memltorear(Memimage *i)
{
    _memltorear(i, nil);
    _memlsetclear(i->layer->screen);
}
@



<<function _memltorear>>=
void
_memltorear(Memimage *i, Memimage *rear)
{
    Memlayer *l;
    Memscreen *s;
    Memimage *f, *r, *rr;
    Rectangle x;
    int overlap;

    l = i->layer;
    s = l->screen;
    while(l->rear != rear){
        r = l->rear;
        x = l->screenr;
        overlap = rectclip(&x, r->layer->screenr);
        if(overlap){
            memlhide(i, x);
            l->clear = 0;
        }
        /* swap l and r in screen's list */
        rr = r->layer->rear;
        f = l->front;
        if(rr == nil)
            s->rearmost = i;
        else
            rr->layer->front = i;
        if(f == nil)
            s->frontmost = r;
        else
            f->layer->rear = r;
        l->rear = rr;
        l->front = r;
        r->layer->rear = i;
        r->layer->front = f;
        if(overlap)
            memlexpose(r, x);
    }
}
@



\chapter{Input}

% related: big-bang function in racket/htdp

\section{Keyboard}

<<enum _anon_ (include/keyboard.h)>>=
enum {
    KF=	0xF000,	/* Rune: beginning of private Unicode space */
    Spec=	0xF800,

    /* KF|1, KF|2, ..., KF|0xC is F1, F2, ..., F12 */
    Khome=	KF|0x0D,
    Kpgup=	KF|0x0F,
    Kpgdown=	KF|0x13,
    Kprint=	KF|0x10,

    Kup=	KF|0x0E,
    Kdown=	Spec|0x00,
    Kleft=	KF|0x11,
    Kright=	KF|0x12,

    Kview=	Spec|0x00,
    Kins=	KF|0x14,
    Kend=	KF|0x18,

    Kalt=	KF|0x15,
    Kshift=	KF|0x16,
    Kctl=	KF|0x17,

    Kdel=	0x7f,
    Kesc=	0x1b,
    Keof=	0x04, // C-d
    Kbs=	0x08, // C-h (backspace)
};
@
% similar to 'enum specialkey' in Kernel.nw
% note that 1-26 are C-a, C-b, ...
%todo: reorder?
%less: Kview and Kdown. Kview is used by the console, to scroll down


<<struct Keyboardctl>>=
struct	Keyboardctl
{
    Channel	*c;	/* chan(Rune)[20] */

    char	*file;

    fdt		consfd;		/* to cons file */
    fdt		ctlfd;		/* to ctl file */

    int		pid;		/* of slave proc */
};
@



% show also kernel interface and refer to Kernel.nw

<<function initkeyboard>>=
Keyboardctl*
initkeyboard(char *file)
{
    Keyboardctl *kc;
    char *t;

    kc = mallocz(sizeof(Keyboardctl), 1);
    if(kc == nil)
        return nil;
    if(file == nil)
        file = "/dev/cons";
    kc->file = strdup(file);
    kc->consfd = open(file, ORDWR|OCEXEC);
    t = malloc(strlen(file)+16);
    if(kc->consfd<0 || t==nil){
Error1:
        free(kc);
        return nil;
    }
    sprint(t, "%sctl", file);
    kc->ctlfd = open(t, OWRITE|OCEXEC);
    if(kc->ctlfd < 0){
        fprint(2, "initkeyboard: can't open %s: %r\n", t);
Error2:
        close(kc->consfd);
        free(t);
        goto Error1;
    }
    if(ctlkeyboard(kc, "rawon") < 0){
        fprint(2, "initkeyboard: can't turn on raw mode on %s: %r\n", t);
        close(kc->ctlfd);
        goto Error2;
    }
    free(t);
    kc->c = chancreate(sizeof(Rune), 20);
    proccreate(_ioproc, kc, 4096);
    return kc;
}
@


<<function _ioproc>>=
static
void
_ioproc(void *arg)
{
    int m, n;
    char buf[20];
    Rune r;
    Keyboardctl *kc;

    kc = arg;
    threadsetname("kbdproc");
    kc->pid = getpid();
    n = 0;
    for(;;){
        while(n>0 && fullrune(buf, n)){
            m = chartorune(&r, buf);
            n -= m;
            memmove(buf, buf+m, n);
            send(kc->c, &r);
        }
        m = read(kc->consfd, buf+n, sizeof buf-n);
        if(m <= 0){
            yield();	/* if error is due to exiting, we'll exit here */
            fprint(2, "keyboard read error: %r\n");
            threadexits("error");
        }
        n += m;
    }
}
@

<<function closekeyboard>>=
void
closekeyboard(Keyboardctl *kc)
{
    if(kc == nil)
        return;

    postnote(PNPROC, kc->pid, "kill");
    close(kc->ctlfd);
    close(kc->consfd);
    free(kc->file);
    free(kc->c);
    free(kc);
}
@
%//#ifdef BUG
%//	/* Drain the channel */
%//	while(?kc->c)
%//		<-kc->c;
%//#endif



<<function ctlkeyboard>>=
int
ctlkeyboard(Keyboardctl *kc, char *m)
{
    return write(kc->ctlfd, m, strlen(m));
}
@




\section{Mouse}

% show also kernel interface and refer to Kernel.nw

% same in mouse.h and event.h
<<struct Mouse (include/mouse.h)>>=
struct	Mouse
{
    // bitset<enum<click>>
    int	buttons;	/* bit array: LMR=124 */
    Point	xy;
    ulong	msec;
};
@

<<struct Mousectl>>=
struct Mousectl
{
    Mouse;

    Channel	*c;			/* chan(Mouse) */
    Channel	*resizec;	/* chan(int)[2] */
    /* buffered in case client is waiting for a mouse action before handling resize */

    char	*file;

    fdt		mfd;		/* to mouse file */
    fdt		cfd;		/* to cursor file */

    int		pid;	/* of slave proc */
    Image*	image;	/* of associated window/display */
};
@
% why image? because cursor!! so need to draw on top of it!


<<function initmouse>>=
Mousectl*
initmouse(char *file, Image *i)
{
    Mousectl *mc;
    char *t, *sl;

    mc = mallocz(sizeof(Mousectl), 1);
    if(file == nil)
        file = "/dev/mouse";
    mc->file = strdup(file);
    mc->mfd = open(file, ORDWR|OCEXEC);
    if(mc->mfd<0 && strcmp(file, "/dev/mouse")==0){
        bind("#m", "/dev", MAFTER);
        mc->mfd = open(file, ORDWR|OCEXEC);
    }
    if(mc->mfd < 0){
        free(mc);
        return nil;
    }
    t = malloc(strlen(file)+16);
    if (t == nil) {
        close(mc->mfd);
        free(mc);
        return nil;
    }
    strcpy(t, file);
    sl = utfrrune(t, '/');
    if(sl)
        strcpy(sl, "/cursor");
    else
        strcpy(t, "/dev/cursor");
    mc->cfd = open(t, ORDWR|OCEXEC);
    free(t);
    mc->image = i;
    mc->c = chancreate(sizeof(Mouse), 0);
    mc->resizec = chancreate(sizeof(int), 2);
    proccreate(_ioproc, mc, 4096);
    return mc;
}
@

<<function _ioproc (lib_graphics/libdraw/mouse.c)>>=
static
void
_ioproc(void *arg)
{
    int n, nerr, one;
    char buf[1+5*12];
    Mouse m;
    Mousectl *mc;

    mc = arg;
    threadsetname("mouseproc");
    one = 1;
    memset(&m, 0, sizeof m);
    mc->pid = getpid();
    nerr = 0;
    for(;;){
        n = read(mc->mfd, buf, sizeof buf);
        if(n != 1+4*12){
            yield();	/* if error is due to exiting, we'll exit here */
            fprint(2, "mouse: bad count %d not 49: %r\n", n);
            if(n<0 || ++nerr>10)
                threadexits("read error");
            continue;
        }
        nerr = 0;
        switch(buf[0]){
        case 'r':
            send(mc->resizec, &one);
            /* fall through */
        case 'm':
            m.xy.x = atoi(buf+1+0*12);
            m.xy.y = atoi(buf+1+1*12);
            m.buttons = atoi(buf+1+2*12);
            m.msec = atoi(buf+1+3*12);
            send(mc->c, &m);
            /*
             * mc->Mouse is updated after send so it doesn't have wrong value if we block during send.
             * This means that programs should receive into mc->Mouse (see readmouse() above) if
             * they want full synchrony.
             */
            mc->Mouse = m;
            break;
        }
    }
}
@


<<function moveto>>=
void
moveto(Mousectl *m, Point pt)
{
    fprint(m->mfd, "m%d %d", pt.x, pt.y);
    m->xy = pt;
}
@

<<function closemouse>>=
void
closemouse(Mousectl *mc)
{
    if(mc == nil)
        return;

    postnote(PNPROC, mc->pid, "kill");

    do ; while(nbrecv(mc->c, &mc->Mouse) > 0);

    close(mc->mfd);
    close(mc->cfd);
    free(mc->file);
    free(mc->c);
    free(mc->resizec);
    free(mc);
}
@

<<function readmouse>>=
int
readmouse(Mousectl *mc)
{
    if(mc->image)
        flushimage(mc->image->display, true);
    if(recv(mc->c, &mc->Mouse) < 0){
        fprint(2, "readmouse: %r\n");
        return -1;
    }
    return 0;
}
@

\subsection{[[getrect.c]]}

<<constant W (lib_graphics/libdraw/getrect.c)>>=
#define	W	Borderwidth
@

<<global tmp (lib_graphics/libdraw/getrect.c)>>=
static Image *tmp[4];
@

<<global red (lib_graphics/libdraw/getrect.c)>>=
static Image *red;
@

<<global sweep (lib_graphics/libdraw/getrect.c)>>=
static Cursor sweep={
    {-7, -7},
    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0x07,
     0xE0, 0x07, 0xE0, 0x07, 0xE3, 0xF7, 0xE3, 0xF7,
     0xE3, 0xE7, 0xE3, 0xF7, 0xE3, 0xFF, 0xE3, 0x7F,
     0xE0, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,},
    {0x00, 0x00, 0x7F, 0xFE, 0x40, 0x02, 0x40, 0x02,
     0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x41, 0xE2,
     0x41, 0xC2, 0x41, 0xE2, 0x41, 0x72, 0x40, 0x38,
     0x40, 0x1C, 0x40, 0x0E, 0x7F, 0xE6, 0x00, 0x00,}
};
@

<<function brects (lib_graphics/libdraw/getrect.c)>>=
static
void
brects(Rectangle r, Rectangle rp[4])
{
    if(Dx(r) < 2*W)
        r.max.x = r.min.x+2*W;
    if(Dy(r) < 2*W)
        r.max.y = r.min.y+2*W;
    rp[0] = Rect(r.min.x, r.min.y, r.max.x, r.min.y+W);
    rp[1] = Rect(r.min.x, r.max.y-W, r.max.x, r.max.y);
    rp[2] = Rect(r.min.x, r.min.y+W, r.min.x+W, r.max.y-W);
    rp[3] = Rect(r.max.x-W, r.min.y+W, r.max.x, r.max.y-W);
}
@

<<function getrect>>=
Rectangle
getrect(int but, Mousectl *mc)
{
    Rectangle r, rc;

    but = 1<<(but-1);
    setcursor(mc, &sweep);
    while(mc->buttons)
        readmouse(mc);
    while(!(mc->buttons & but)){
        readmouse(mc);
        if(mc->buttons & (7^but))
            goto Return;
    }
    r.min = mc->xy;
    r.max = mc->xy;
    do{
        rc = canonrect(r);
        drawgetrect(rc, 1);
        readmouse(mc);
        drawgetrect(rc, 0);
        r.max = mc->xy;
    }while(mc->buttons == but);

    Return:
    setcursor(mc, nil);
    if(mc->buttons & (7^but)){
        rc.min.x = rc.max.x = 0;
        rc.min.y = rc.max.y = 0;
        while(mc->buttons)
            readmouse(mc);
    }
    return rc;
}
@

<<function freetmp (lib_graphics/libdraw/getrect.c)>>=
static
void
freetmp(void)
{
    freeimage(tmp[0]);
    freeimage(tmp[1]);
    freeimage(tmp[2]);
    freeimage(tmp[3]);
    freeimage(red);
    tmp[0] = tmp[1] = tmp[2] = tmp[3] = red = nil;
}
@

<<function max>>=
static
int
max(int a, int b)
{
    if(a > b)
        return a;
    return b;
}
@

<<function drawgetrect>>=
void
drawgetrect(Rectangle rc, int up)
{
    int i;
    Rectangle r, rects[4];

    /*
     * BUG: if for some reason we have two of these going on at once
     * when we must grow the tmp buffers, we lose data.  Also if tmp
     * is unallocated and we ask to restore the screen, it would be nice
     * to complain, but we silently make a mess.
     */
    if(up && tmp[0]!=nil)
        if(Dx(tmp[0]->r)<Dx(rc) || Dy(tmp[2]->r)<Dy(rc))
            freetmp();
    if(tmp[0] == 0){
        r = Rect(0, 0, max(Dx(display->screenimage->r), Dx(rc)), W);
        tmp[0] = allocimage(display, r, view->chan, 0, -1);
        tmp[1] = allocimage(display, r, view->chan, 0, -1);
        r = Rect(0, 0, W, max(Dy(display->screenimage->r), Dy(rc)));
        tmp[2] = allocimage(display, r, view->chan, 0, -1);
        tmp[3] = allocimage(display, r, view->chan, 0, -1);
        red = allocimage(display, Rect(0,0,1,1), view->chan, 1, DRed);
        if(tmp[0]==0 || tmp[1]==0 || tmp[2]==0 || tmp[3]==0 || red==0){
            freetmp();
            drawerror(display, "getrect: allocimage failed");
        }
    }
    brects(rc, rects);
    if(!up){
        for(i=0; i<4; i++)
            draw(view, rects[i], tmp[i], nil, ZP);
        return;
    }
    for(i=0; i<4; i++){
        draw(tmp[i], Rect(0, 0, Dx(rects[i]), Dy(rects[i])), view, nil, rects[i].min);
        draw(view, rects[i], red, nil, ZP);
    }
}
@


\subsection{[[mousescrollsize()]]}
% advanced topic?

<<function mousescrollsize>>=
int
mousescrollsize(int maxlines)
{
    static int lines, pcnt;
    char *mss;

    if(lines == 0 && pcnt == 0){
        mss = getenv("mousescrollsize");
        if(mss){
            if(strchr(mss, '%') != nil)
                pcnt = atof(mss);
            else
                lines = atoi(mss);
            free(mss);
        }
        if(lines == 0 && pcnt == 0)
            lines = 1;
        if(pcnt>=100)
            pcnt = 100;
    }

    if(lines)
        return lines;
    return pcnt * maxlines/100.0;	
}
@


\section{Cursor}

\subsection{API}

%cursor.h, normally a 16x16 picture
<<struct Cursor>>=
struct	Cursor
{
    Point	offset;

    byte	clr[2*16];
    byte	set[2*16];
};
@

% screen.h interface
% vgascreen.c (seems general enough, could be put in a generic screen.c)
<<global arrow(x86)>>=
Cursor  arrow = {
    .offset = { -1, -1 },
    .clr = { 
      0xFF, 0xFF, 0x80, 0x01, 0x80, 0x02, 0x80, 0x0C, 
      0x80, 0x10, 0x80, 0x10, 0x80, 0x08, 0x80, 0x04, 
      0x80, 0x02, 0x80, 0x01, 0x80, 0x02, 0x8C, 0x04, 
      0x92, 0x08, 0x91, 0x10, 0xA0, 0xA0, 0xC0, 0x40, 
    },
    .set = { 
      0x00, 0x00, 0x7F, 0xFE, 0x7F, 0xFC, 0x7F, 0xF0, 
      0x7F, 0xE0, 0x7F, 0xE0, 0x7F, 0xF0, 0x7F, 0xF8, 
      0x7F, 0xFC, 0x7F, 0xFE, 0x7F, 0xFC, 0x73, 0xF8, 
      0x61, 0xF0, 0x60, 0xE0, 0x40, 0x40, 0x00, 0x00, 
    },
};
@
% picture? format? 16x16 bitmap??


%\subsection{Marshalling}

% protocol, but very simple
<<function setcursor>>=
void
setcursor(Mousectl *mc, Cursor *c)
{
    char curs[2*4+2*2*16]; // sizeof Cursor

    if(c == nil)
        write(mc->cfd, curs, 0);
    else{
        BPLONG(curs+0*4, c->offset.x);
        BPLONG(curs+1*4, c->offset.y);
        memmove(curs+2*4, c->clr, 2*2*16);
        write(mc->cfd, curs, sizeof curs);
    }
}
@

%\subsection{Unmarshalling}
%? devmouse.c code? for /dev/cursor?

\subsection{Hardware support hook}

<<struct Cursorinfo>>=
struct Cursorinfo {
  Cursor;
  Lock;
};
@

% TODO global cursor!! stuff do lock(&cursor)!



% vga cursor interface
<<struct VGAcur(x86)>>=
struct VGAcur {
  char* name;

  void  (*enable)(VGAscr*);
  void  (*disable)(VGAscr*);
  void  (*load)(VGAscr*, Cursor*);
  int   (*move)(VGAscr*, Point);

  // optional
  int doespanning;
};
@


% screen.h interface, vgascreen.c
<<function cursoron(x86)>>=
int
cursoron(bool dolock)
{
    VGAscr *scr;
    int v;

    scr = &vgascreen;
    if(scr->cur == nil || scr->cur->move == nil)
        return 0;

    if(dolock)
        lock(&cursor);

    v = scr->cur->move(scr, mousexy());

    if(dolock)
        unlock(&cursor);

    return v;
}
@
% mousexy() also part of screen.h interface, but should
% be implemented by devmouse.c or mouse.c

% screen.h interface, vgascreen.c
<<function cursoroff(x86)>>=
void
cursoroff(int)
{
}
@
% empty? not even swcursorhide()?

% screen.h interface, vgascreen.c
% called from mouse.c?
<<function ksetcursor(x86)>>=
void
ksetcursor(Cursor* curs)
{
    VGAscr *scr;

    scr = &vgascreen;
    if(scr->cur == nil || scr->cur->load == nil)
        return;

    scr->cur->load(scr, curs);
}
@






\subsubsection{VGA software cursor}
% nice simple examples of drawing operations

<<global swcursor(x86)>>=
VGAcur swcursor =
{
    .name = "soft",

    .enable = swenable,
    .disable = swdisable,
    .load = swload,
    .move = swmove,
};
@

<<global swenabled(x86)>>=
bool swenabled;  /* is the cursor supposed to be on the screen? */
@



<<global swvisible(x86)>>=
bool swvisible;  /* is the cursor visible? */
@

<<global swrect(x86)>>=
Rectangle   swrect; /* screen rectangle in swback */
@
<<global swback(x86)>>=
Memimage*   swback; /* screen under cursor */
@


<<global swimg1(x86)>>=
Memimage*   swimg1;
@
<<global swmask1(x86)>>=
Memimage*   swmask1;
@
% for transparent cursor?

% convenient function to understand many things, keep early


<<global swpt(x86)>>=
Point   swpt;   /* desired cursor location */
@
<<global swvispt(x86)>>=
Point   swvispt;    /* actual cursor location */
@





<<global swvers(x86)>>=
int swvers; /* incremented each time cursor image changes */
@
<<global swvisvers(x86)>>=
int swvisvers;  /* the version on the screen */
@

<<function swcursordraw(x86)>>=
void
swcursordraw(void)
{
    if(swvisible)
        return;
    if(swenabled == false)
        return;
    if(swback == nil || swimg1 == nil || swmask1 == nil)
        return;
    assert(!canqlock(&drawlock));

    swvispt = swpt;
    swvisvers = swvers;
    // cursor is 16x16 picture
    swrect = rectaddpt(Rect(0,0,16,16), swvispt);
    // save what is under the cursor
    memimagedraw(swback, swback->r, gscreen, swpt, memopaque, ZP, S);
    memimagedraw(gscreen, swrect, swimg1, ZP, swmask1, ZP, SoverD);
    flushmemscreen(swrect);
    swvisible = true;
}
@

% convenient function to understand many things, keep early
% ??? -> <>
<<function swcursorhide(x86)>>=
/*
 * called with drawlock locked for us, most of the time.
 * kernel prints at inopportune times might mean we don't
 * hold the lock, but memimagedraw is now reentrant so
 * that should be okay: worst case we get cursor droppings.
 */
void
swcursorhide(void)
{
    if(swvisible == false)
        return;
    if(swback == nil)
        return;

    swvisible = false;
    // restore what was under the cursor
    memimagedraw(gscreen, swrect, swback, ZP, memopaque, ZP, S);
    flushmemscreen(swrect);
}
@




<<function swenable(x86)>>=
/*
 * Need to lock drawlock for ourselves.
 */
void
swenable(VGAscr*)
{
    swenabled = true;
    if(canqlock(&drawlock)){
        swcursordraw();
        qunlock(&drawlock);
    }
}
@

<<function swdisable(x86)>>=
void
swdisable(VGAscr*)
{
    swenabled = false;
    if(canqlock(&drawlock)){
        swcursorhide();
        qunlock(&drawlock);
    }
}
@


<<global swoffset(x86)>>=
Point   swoffset;
@

<<function swmove(x86)>>=
int
swmove(VGAscr*, Point p)
{
    swpt = addpt(p, swoffset);
    return 0;
}
@





<<global swimg(x86)>>=
Memimage*   swimg;  /* cursor image */
@

<<global swmask(x86)>>=
Memimage*   swmask; /* cursor mask */
@

<<function swload(x86)>>=
void
swload(VGAscr*, Cursor *curs)
{
    uchar *ip, *mp;
    int i, j, set, clr;

    if(!swimg || !swmask || !swimg1 || !swmask1)
        return;
    /*
     * Build cursor image and mask.
     * Image is just the usual cursor image
     * but mask is a transparent alpha mask.
     * 
     * The 16x16x8 memimages do not have
     * padding at the end of their scan lines.
     */
    ip = byteaddr(swimg, ZP);
    mp = byteaddr(swmask, ZP);
    for(i=0; i<32; i++){
        set = curs->set[i];
        clr = curs->clr[i];
        for(j=0x80; j; j>>=1){
            *ip++ = set&j ? 0x00 : 0xFF;
            *mp++ = (clr|set)&j ? 0xFF : 0x00;
        }
    }
    swoffset = curs->offset;
    swvers++;
    memimagedraw(swimg1, swimg1->r, swimg, ZP, memopaque, ZP, S);
    memimagedraw(swmask1, swmask1->r, swmask, ZP, memopaque, ZP, S);
}
@
% use of swimg outside swload? so why not make a local?
% why not directly modify swimg1? why the intermediate?





<<global didswcursorinit(x86)>>=
bool didswcursorinit;
@

<<function swcursorinit(x86)>>=
void
swcursorinit(void)
{
    static bool init, warned;
    VGAscr *scr;

    didswcursorinit = true;
    if(!init){
        init = true;
        addclock0link(swcursorclock, 10);
    }
    scr = &vgascreen;

    if(scr==nil || gscreen==nil)
        return;
    if(scr->dev == nil || scr->dev->linear == nil){
        if(!warned){
            print("cannot use software cursor on non-linear vga screen\n");
            warned = 1;
        }
        return;
    }

    if(swback){
        freememimage(swback);
        freememimage(swmask);
        freememimage(swmask1);
        freememimage(swimg);
        freememimage(swimg1);
    }

    swback = allocmemimage(Rect(0,0,32,32), gscreen->chan);
    swmask = allocmemimage(Rect(0,0,16,16), GREY8);
    swmask1 = allocmemimage(Rect(0,0,16,16), GREY1);
    swimg = allocmemimage(Rect(0,0,16,16), GREY8);
    swimg1 = allocmemimage(Rect(0,0,16,16), GREY1);
    if(swback==nil || swmask==nil || swmask1==nil || swimg==nil || swimg1 == nil){
        print("software cursor: allocmemimage fails");
        return;
    }

    memfillcolor(swmask, DOpaque);
    memfillcolor(swmask1, DOpaque);
    memfillcolor(swimg, DBlack);
    memfillcolor(swimg1, DBlack);
}
@

% swcursorinit -> addlock0link(<>), so called at each clock interrupt 
<<function swcursorclock(x86)>>=
void
swcursorclock(void)
{
    int x;

    if(!swenabled)
        return;
    if(swvisible && eqpt(swpt, swvispt) && swvers==swvisvers)
        return;

    x = splhi();
    if(swenabled)
     if(!swvisible || !eqpt(swpt, swvispt) || swvers!=swvisvers)
      if(canqlock(&drawlock)){
        swcursorhide();
        swcursordraw();
        qunlock(&drawlock);
    }
    splx(x);
}
@
% if !swvisible?????



<<[[hwdraw()]] if software cursor(x86)>>=
if(scr->cur == &swcursor){
    /*
     * always calling swcursorhide here doesn't cure
     * leaving cursor tracks nor failing to refresh menus
     * with the latest libmemdraw/draw.c.
     */
    if(dst->data->bdata == gscreendata.bdata)
        swcursoravoid(par->r);
    if(src->data->bdata == gscreendata.bdata)
        swcursoravoid(par->sr);
    if(mask->data->bdata == gscreendata.bdata)
        swcursoravoid(par->mr);
}
@


<<function swcursoravoid(x86)>>=
void
swcursoravoid(Rectangle r)
{
    if(swvisible && rectXrect(r, swrect))
        swcursorhide();
}
@



\subsubsection{VGA Hardware cursor}

% see VGA driver section


\section{Events}
% TODO: advanced topics? and move also egetrect.c and emenuhits.c?

% have lots of dupes with events, menuhit.c vs emenuhit.c?

<<enum _anon_ (include/event.h)>>=
enum
{
    Emouse	= 1,
    Ekeyboard	= 2,
};
@

% dupe
<<struct Mouse>>=
struct	Mouse
{
    int		buttons;	/* bit array: LMR=124 */
    Point	xy;
    ulong	msec;
};
@

<<struct Event>>=
struct	Event
{
    int		kbdc;
    Mouse	mouse;
    int		n;		/* number of characters in message */
    void	*v;		/* data unpacked by general event-handling function */
    uchar	data[EMAXMSG];	/* message from an arbitrary file descriptor */
};
@


% event.c



<<enum _anon_ (include/event.h)2>>=
enum
{
    MAXSLAVE = 32,
    EMAXMSG = 128+8192,	/* size of 9p header+data */
};
@


<<struct Slave>>=
struct Slave
{
    int	pid;
    Ebuf	*head;		/* queue of messages for this descriptor */
    Ebuf	*tail;
    int	(*fn)(int, Event*, uchar*, int);
};
@

<<struct Ebuf>>=
struct Ebuf
{
    Ebuf	*next;
    int	n;		/* number of bytes in buf */
    uchar	buf[EMAXMSG];
};
@

<<global eslave>>=
static	Slave	eslave[MAXSLAVE];
@



<<global Skeyboard>>=
static	int	Skeyboard = -1;
@

<<global Smouse>>=
static	int	Smouse = -1;
@

<<global Stimer>>=
static	int	Stimer = -1;
@



<<global logfid>>=
static	int	logfid;
@

<<global nslave>>=
static	int	nslave;
@

<<global parentpid>>=
static	int	parentpid;
@

<<global epipe>>=
static	int	epipe[2];
@

<<global mousefd>>=
static	int	mousefd;
@

<<global cursorfd>>=
static	int	cursorfd;
@

<<function ebread>>=
static
Ebuf*
ebread(Slave *s)
{
    Ebuf *eb;
    Dir *d;
    ulong l;

    for(;;){
        d = dirfstat(epipe[0]);
        if(d == nil)
            drawerror(display, "events: eread stat error");
        l = d->length;
        free(d);
        if(s->head && l==0)
            break;
        extract();
    }
    eb = s->head;
    s->head = s->head->next;
    if(s->head == 0)
        s->tail = 0;
    return eb;
}
@

<<function event>>=
ulong
event(Event *e)
{
    return eread(~0UL, e);
}
@

<<function eread>>=
ulong
eread(ulong keys, Event *e)
{
    Ebuf *eb;
    int i, id;

    if(keys == 0)
        return 0;
    for(;;){
        for(i=0; i<nslave; i++)
            if((keys & (1<<i)) && eslave[i].head){
                id = 1<<i;
                if(i == Smouse)
                    e->mouse = emouse();
                else if(i == Skeyboard)
                    e->kbdc = ekbd();
                else if(i == Stimer)
                    eslave[i].head = 0;
                else{
                    eb = ebread(&eslave[i]);
                    e->n = eb->n;
                    if(eslave[i].fn)
                        id = (*eslave[i].fn)(id, e, eb->buf, eb->n);
                    else
                        memmove(e->data, eb->buf, eb->n);
                    free(eb);
                }
                return id;
            }
        extract();
    }
}
@
% >> >>

<<function ecanmouse>>=
int
ecanmouse(void)
{
    if(Smouse < 0)
        drawerror(display, "events: mouse not initialized");
    return ecanread(Emouse);
}
@

<<function ecankbd>>=
int
ecankbd(void)
{
    if(Skeyboard < 0)
        drawerror(display, "events: keyboard not initialzed");
    return ecanread(Ekeyboard);
}
@

<<function ecanread>>=
int
ecanread(ulong keys)
{
    Dir *d;
    int i;
    ulong l;

    for(;;){
        for(i=0; i<nslave; i++)
            if((keys & (1<<i)) && eslave[i].head)
                return 1;
        d = dirfstat(epipe[0]);
        if(d == nil)
            drawerror(display, "events: ecanread stat error");
        l = d->length;
        free(d);
        if(l == 0)
            return 0;
        extract();
    }
}
@
% >>

<<function estartfn>>=
ulong
estartfn(ulong key, int fd, int n, int (*fn)(int, Event*, uchar*, int))
{
    char buf[EMAXMSG+1];
    int i, r;

    if(fd < 0)
        drawerror(display, "events: bad file descriptor");
    if(n <= 0 || n > EMAXMSG)
        n = EMAXMSG;
    i = eforkslave(key);
    if(i < MAXSLAVE){
        eslave[i].fn = fn;
        return 1<<i;
    }
    buf[0] = i - MAXSLAVE;
    while((r = read(fd, buf+1, n))>0)
        if(write(epipe[1], buf, r+1)!=r+1)
            break;
    buf[0] = MAXSLAVE;
    write(epipe[1], buf, 1);
    _exits(0);
    return 0;
}
@
% >>

<<function estart>>=
ulong
estart(ulong key, int fd, int n)
{
    return estartfn(key, fd, n, nil);
}
@

<<function etimer>>=
ulong
etimer(ulong key, int n)
{
    char t[2];

    if(Stimer != -1)
        drawerror(display, "events: timer started twice");
    Stimer = eforkslave(key);
    if(Stimer < MAXSLAVE)
        return 1<<Stimer;
    if(n <= 0)
        n = 1000;
    t[0] = t[1] = Stimer - MAXSLAVE;
    do
        sleep(n);
    while(write(epipe[1], t, 2) == 2);
    t[0] = MAXSLAVE;
    write(epipe[1], t, 1);
    _exits(0);
    return 0;
}
@
% >> >> >> >> >>

<<function ekeyslave>>=
static void
ekeyslave(int fd)
{
    Rune r;
    char t[3], k[10];
    int kr, kn, w;

    if(eforkslave(Ekeyboard) < MAXSLAVE)
        return;
    kn = 0;
    t[0] = Skeyboard;
    for(;;){
        while(!fullrune(k, kn)){
            kr = read(fd, k+kn, sizeof k - kn);
            if(kr <= 0)
                goto breakout;
            kn += kr;
        }
        w = chartorune(&r, k);
        kn -= w;
        memmove(k, &k[w], kn);
        t[1] = r;
        t[2] = r>>8;
        if(write(epipe[1], t, 3) != 3)
            break;
    }
breakout:;
    t[0] = MAXSLAVE;
    write(epipe[1], t, 1);
    _exits(0);
}
@

<<function einit>>=
void
einit(ulong keys)
{
    int ctl, fd;
    char buf[256];

    parentpid = getpid();
    if(pipe(epipe) < 0)
        drawerror(display, "events: einit pipe");
    atexit(ekill);
    atnotify(enote, 1);
    snprint(buf, sizeof buf, "%s/mouse", display->devdir);
    mousefd = open(buf, ORDWR|OCEXEC);
    if(mousefd < 0)
        drawerror(display, "einit: can't open mouse\n");
    snprint(buf, sizeof buf, "%s/cursor", display->devdir);
    cursorfd = open(buf, ORDWR|OCEXEC);
    if(cursorfd < 0)
        drawerror(display, "einit: can't open cursor\n");
    if(keys&Ekeyboard){
        snprint(buf, sizeof buf, "%s/cons", display->devdir);
        fd = open(buf, OREAD);
        if(fd < 0)
            drawerror(display, "events: can't open console");
        snprint(buf, sizeof buf, "%s/consctl", display->devdir);
        ctl = open("/dev/consctl", OWRITE|OCEXEC);
        if(ctl < 0)
            drawerror(display, "events: can't open consctl");
        write(ctl, "rawon", 5);
        for(Skeyboard=0; Ekeyboard & ~(1<<Skeyboard); Skeyboard++)
            ;
        ekeyslave(fd);
    }
    if(keys&Emouse){
        estart(Emouse, mousefd, 1+4*12);
        for(Smouse=0; Emouse & ~(1<<Smouse); Smouse++)
            ;
    }
}
@

<<function extract>>=
static void
extract(void)
{
    Slave *s;
    Ebuf *eb;
    int i, n;
    uchar ebuf[EMAXMSG+1];

    /* avoid generating a message if there's nothing to show. */
    /* this test isn't perfect, though; could do flushimage(display, 0) then call extract */
    /* also: make sure we don't interfere if we're multiprocessing the display */
    if(display->locking){
        /* if locking is being done by program, this means it can't depend on automatic flush in emouse() etc. */
        if(canqlock(&display->qlock)){
            if(display->bufp > display->buf)
                flushimage(display, true);
            unlockdisplay(display);
        }
    }else
        if(display->bufp > display->buf)
            flushimage(display, true);
loop:
    if((n=read(epipe[0], ebuf, EMAXMSG+1)) < 0
    || ebuf[0] >= MAXSLAVE)
        drawerror(display, "eof on event pipe");
    if(n == 0)
        goto loop;
    i = ebuf[0];
    if(i >= nslave || n <= 1)
        drawerror(display, "events: protocol error: short read");
    s = &eslave[i];
    if(i == Stimer){
        s->head = (Ebuf *)1;
        return;
    }
    if(i == Skeyboard && n != 3)
        drawerror(display, "events: protocol error: keyboard");
    if(i == Smouse){
        if(n < 1+1+2*12)
            drawerror(display, "events: protocol error: mouse");
        if(ebuf[1] == 'r')
            eresized(1);
        /* squash extraneous mouse events */
        if((eb=s->tail) && memcmp(eb->buf+1+2*12, ebuf+1+1+2*12, 12)==0){
            memmove(eb->buf, &ebuf[1], n - 1);
            return;
        }
    }
    /* try to save space by only allocating as much buffer as we need */
    eb = malloc(sizeof(*eb) - sizeof(eb->buf) + n - 1);
    if(eb == 0)
        drawerror(display, "events: protocol error 4");
    eb->n = n - 1;
    memmove(eb->buf, &ebuf[1], n - 1);
    eb->next = 0;
    if(s->head)
        s->tail = s->tail->next = eb;
    else
        s->head = s->tail = eb;
}
@

<<function eforkslave>>=
static int
eforkslave(ulong key)
{
    int i, pid;

    for(i=0; i<MAXSLAVE; i++)
        if((key & ~(1<<i)) == 0 && eslave[i].pid == 0){
            if(nslave <= i)
                nslave = i + 1;
            /*
             * share the file descriptors so the last child
             * out closes all connections to the window server.
             */
            switch(pid = rfork(RFPROC)){
            case 0:
                return MAXSLAVE+i;
            case -1:
                fprint(2, "events: fork error\n");
                exits("fork");
            }
            eslave[i].pid = pid;
            eslave[i].head = eslave[i].tail = 0;
            return i;
        }
    drawerror(display, "events: bad slave assignment");
    return 0;
}
@

<<function enote>>=
static int
enote(void *v, char *s)
{
    char t[1];
    int i, pid;

    USED(v, s);
    pid = getpid();
    if(pid != parentpid){
        for(i=0; i<nslave; i++){
            if(pid == eslave[i].pid){
                t[0] = MAXSLAVE;
                write(epipe[1], t, 1);
                break;
            }
        }
        return 0;
    }
    close(epipe[0]);
    epipe[0] = -1;
    close(epipe[1]);
    epipe[1] = -1;
    for(i=0; i<nslave; i++){
        if(pid == eslave[i].pid)
            continue;	/* don't kill myself */
        postnote(PNPROC, eslave[i].pid, "die");
    }
    return 0;
}
@

<<function ekill>>=
static void
ekill(void)
{
    enote(0, 0);
}
@

<<function emouse>>=
Mouse
emouse(void)
{
    Mouse m;
    Ebuf *eb;
    static int but[2];
    int b;

    if(Smouse < 0)
        drawerror(display, "events: mouse not initialized");
    eb = ebread(&eslave[Smouse]);
    m.xy.x = atoi((char*)eb->buf+1+0*12);
    m.xy.y = atoi((char*)eb->buf+1+1*12);
    b = atoi((char*)eb->buf+1+2*12);
    m.buttons = b;
    m.msec = atoi((char*)eb->buf+1+3*12);
    if (logfid)
        fprint(logfid, "b: %d xy: %P\n", m.buttons, m.xy);
    free(eb);
    return m;
}
@

<<function ekbd>>=
int
ekbd(void)
{
    Ebuf *eb;
    int c;

    if(Skeyboard < 0)
        drawerror(display, "events: keyboard not initialzed");
    eb = ebread(&eslave[Skeyboard]);
    c = eb->buf[0] + (eb->buf[1]<<8);
    free(eb);
    return c;
}
@

<<function emoveto>>=
void
emoveto(Point pt)
{
    char buf[2*12+2];
    int n;

    n = sprint(buf, "m%d %d", pt.x, pt.y);
    write(mousefd, buf, n);
}
@

<<function esetcursor>>=
void
esetcursor(Cursor *c)
{
    uchar curs[2*4+2*2*16];

    if(c == 0)
        write(cursorfd, curs, 0);
    else{
        BPLONG(curs+0*4, c->offset.x);
        BPLONG(curs+1*4, c->offset.y);
        memmove(curs+2*4, c->clr, 2*2*16);
        write(cursorfd, curs, sizeof curs);
    }
}
@

<<function ereadmouse>>=
int
ereadmouse(Mouse *m)
{
    int n;
    char buf[128];

    do{
        n = read(mousefd, buf, sizeof(buf));
        if(n < 0)	/* probably interrupted */
            return -1;
        n = eatomouse(m, buf, n);
    }while(n == 0);
    return n;
}
@

<<function eatomouse>>=
int
eatomouse(Mouse *m, char *buf, int n)
{
    if(n != 1+4*12){
        werrstr("atomouse: bad count");
        return -1;
    }

    if(buf[0] == 'r')
        eresized(1);
    m->xy.x = atoi(buf+1+0*12);
    m->xy.y = atoi(buf+1+1*12);
    m->buttons = atoi(buf+1+2*12);
    m->msec = atoi(buf+1+3*12);
    return n;
}
@





















\chapter{Widgets}

\section{Libpanel}
% different alloc, different event loop, 
% and the Panel main data structure



\section{Frame}
% have libframe/ but also a frame widge in libpanel

\section{Scrolling}
% have also a menu in libpanel, scrollbar

\section{Menu}
% have also a menu in libpanel, popup, pulldown

\section{Button}

\section{Label}

\section{Text entry}

\section{Completion}

\section{Slider}

\section{List}

\section{Pack}

\section{Canvas}

\section{Text view}

\section{Rich text}

\chapter{Advanced Topics}

\section{Bezier}
% spline

% no kernel support I think, it just use the previous building blocks

<<constant PINC>>=
#define	PINC	32		/* realloc granularity */
@

<<struct Plist>>=
struct Plist
{
    Point *p;
    int np;			/* -1 if malloc/realloc failed */
};
@

<<function appendpt>>=
static void
appendpt(Plist *l, Point p)
{
    if(l->np == -1)
        return;
    if(l->np == 0)
        l->p = malloc(PINC*sizeof(Point));
    else if(l->np%PINC == 0)
        l->p = realloc(l->p, (l->np+PINC)*sizeof(Point));
    if(l->p == 0){
        l->np = -1;
        return;
    }
    l->p[l->np++] = p;
}
@

<<function normsq>>=
static int
normsq(Point p)
{
    return p.x*p.x+p.y*p.y;
}
@

<<function psdist>>=
static int
psdist(Point p, Point a, Point b)
{
    int num, den;

    p = subpt(p, a);
    b = subpt(b, a);
    num = p.x*b.x + p.y*b.y;
    if(num <= 0)
        return normsq(p);
    den = normsq(b);
    if(num >= den)
        return normsq(subpt(b, p));
    return normsq(subpt(divpt(mulpt(b, num), den), p));
}
@

<<function bpts1>>=
/*
 * Convert cubic Bezier curve control points to polyline
 * vertices.  Leaves the last vertex off, so you can continue
 * with another curve.
 */
static void
bpts1(Plist *l, Point p0, Point p1, Point p2, Point p3, int scale)
{
    Point p01, p12, p23, p012, p123, p0123;
    Point tp0, tp1, tp2, tp3;
    tp0=divpt(p0, scale);
    tp1=divpt(p1, scale);
    tp2=divpt(p2, scale);
    tp3=divpt(p3, scale);
    if(psdist(tp1, tp0, tp3)<=1 && psdist(tp2, tp0, tp3)<=1){
        appendpt(l, tp0);
        appendpt(l, tp1);
        appendpt(l, tp2);
    }
    else{
        /*
         * if scale factor is getting too big for comfort,
         * rescale now & concede the rounding error
         */
        if(scale>(1<<12)){
            p0=tp0;
            p1=tp1;
            p2=tp2;
            p3=tp3;
            scale=1;
        }
        p01=addpt(p0, p1);
        p12=addpt(p1, p2);
        p23=addpt(p2, p3);
        p012=addpt(p01, p12);
        p123=addpt(p12, p23);
        p0123=addpt(p012, p123);
        bpts1(l, mulpt(p0, 8), mulpt(p01, 4), mulpt(p012, 2), p0123, scale*8);
        bpts1(l, p0123, mulpt(p123, 2), mulpt(p23, 4), mulpt(p3, 8), scale*8);
    }
}
@

<<function bpts>>=
static void
bpts(Plist *l, Point p0, Point p1, Point p2, Point p3)
{
    bpts1(l, p0, p1, p2, p3, 1);
}
@

<<function bezierpts>>=
static void
bezierpts(Plist *l, Point p0, Point p1, Point p2, Point p3)
{
    bpts(l, p0, p1, p2, p3);
    appendpt(l, p3);
}
@

<<function _bezsplinepts>>=
static void
_bezsplinepts(Plist *l, Point *pt, int npt)
{
    Point *p, *ep;
    Point a, b, c, d;
    int periodic;

    if(npt<3)
        return;
    ep = &pt[npt-3];
    periodic = eqpt(pt[0], ep[2]);
    if(periodic){
        a = divpt(addpt(ep[1], pt[0]), 2);
        b = divpt(addpt(ep[1], mulpt(pt[0], 5)), 6);
        c = divpt(addpt(mulpt(pt[0], 5), pt[1]), 6);
        d = divpt(addpt(pt[0], pt[1]), 2);
        bpts(l, a, b, c, d);
    }
    for(p=pt; p<=ep; p++){
        if(p==pt && !periodic){
            a = p[0];
            b = divpt(addpt(p[0], mulpt(p[1], 2)), 3);
        }
        else{
            a = divpt(addpt(p[0], p[1]), 2);
            b = divpt(addpt(p[0], mulpt(p[1], 5)), 6);
        }
        if(p==ep && !periodic){
            c = divpt(addpt(mulpt(p[1], 2), p[2]), 3);
            d = p[2];
        }
        else{
            c = divpt(addpt(mulpt(p[1], 5), p[2]), 6);
            d = divpt(addpt(p[1], p[2]), 2);
        }
        bpts(l, a, b, c, d);
    }
    appendpt(l, d);
}
@

<<function bezsplinepts>>=
int
bezsplinepts(Point *pt, int npt, Point **pp)
{
    Plist l;
    l.np = 0;
    l.p = nil;
    _bezsplinepts(&l, pt, npt);
    *pp  = l.p;
    return l.np;
}
@

<<function bezier>>=
int
bezier(Image *dst, Point p0, Point p1, Point p2, Point p3, int end0, int end1, int radius, Image *src, Point sp)
{
    return bezierop(dst, p0, p1, p2, p3, end0, end1, radius, src, sp, SoverD);
}
@

<<function bezierop>>=
int
bezierop(Image *dst, Point p0, Point p1, Point p2, Point p3, int end0, int end1, int radius, Image *src, Point sp, Drawop op)
{
    Plist l;

    l.np = 0;
    bezierpts(&l, p0, p1, p2, p3);
    if(l.np == -1)
        return 0;
    if(l.np != 0){
        polyop(dst, l.p, l.np, end0, end1, radius, src, addpt(subpt(sp, p0), l.p[0]), op);
        free(l.p);
    }
    return 1;
}
@

<<function bezspline>>=
int
bezspline(Image *dst, Point *pt, int npt, int end0, int end1, int radius, Image *src, Point sp)
{
    return bezsplineop(dst, pt, npt, end0, end1, radius, src, sp, SoverD);
}
@

<<function bezsplineop>>=
int
bezsplineop(Image *dst, Point *pt, int npt, int end0, int end1, int radius, Image *src, Point sp, Drawop op)
{
    Plist l;

    l.np = 0;
    _bezsplinepts(&l, pt, npt);
    if(l.np==-1)
        return 0;
    if(l.np != 0){
        polyop(dst, l.p, l.np, end0, end1, radius, src, addpt(subpt(sp, pt[0]), l.p[0]), op);
        free(l.p);
    }
    return 1;
}
@

<<function fillbezier>>=
int
fillbezier(Image *dst, Point p0, Point p1, Point p2, Point p3, int w, Image *src, Point sp)
{
    return fillbezierop(dst, p0, p1, p2, p3, w, src, sp, SoverD);
}
@

<<function fillbezierop>>=
int
fillbezierop(Image *dst, Point p0, Point p1, Point p2, Point p3, int w, Image *src, Point sp, Drawop op)
{
    Plist l;

    l.np = 0;
    bezierpts(&l, p0, p1, p2, p3);
    if(l.np == -1)
        return 0;
    if(l.np != 0){
        fillpolyop(dst, l.p, l.np, w, src, addpt(subpt(sp, p0), l.p[0]), op);
        free(l.p);
    }
    return 1;
}
@

<<function fillbezspline>>=
int
fillbezspline(Image *dst, Point *pt, int npt, int w, Image *src, Point sp)
{
    return fillbezsplineop(dst, pt, npt, w, src, sp, SoverD);
}
@

<<function fillbezsplineop>>=
int
fillbezsplineop(Image *dst, Point *pt, int npt, int w, Image *src, Point sp, Drawop op)
{
    Plist l;

    l.np = 0;
    _bezsplinepts(&l, pt, npt);
    if(l.np == -1)
        return 0;
    if(l.np > 0){
        fillpolyop(dst, l.p, l.np, w, src, addpt(subpt(sp, pt[0]), l.p[0]), op);
        free(l.p);
    }
    return 1;
}
@



\section{Menus}

% dupe in mouse.h
<<struct Menu>>=
struct Menu
{
    char	**item;
    char	*(*gen)(int);
    int	lasthit;
};
@

\ifallcode
<<struct Menu (include/mouse.h)>>=
struct Menu
{
    char	**item;
    char	*(*gen)(int);
    int	lasthit;
};
@
\fi

%\subsection{[[menuhits.c]]}

<<enum _anon_ (lib_graphics/libdraw/menuhit.c)>>=
enum
{
    Margin = 4,		/* outside to text */
    Border = 2,		/* outside to selection boxes */
    Blackborder = 2,	/* width of outlining border */
    Vspacing = 2,		/* extra spacing between lines of text */
    Maxunscroll = 25,	/* maximum #entries before scrolling turns on */
    Nscroll = 20,		/* number entries in scrolling part */
    Scrollwid = 14,		/* width of scroll bar */
    Gap = 4,			/* between text and scroll bar */
};
@

<<global menutxt (lib_graphics/libdraw/menuhit.c)>>=
static	Image	*menutxt;
@

<<global back (lib_graphics/libdraw/menuhit.c)>>=
static	Image	*back;
@

<<global high (lib_graphics/libdraw/menuhit.c)>>=
static	Image	*high;
@

<<global bord (lib_graphics/libdraw/menuhit.c)>>=
static	Image	*bord;
@

<<global text (lib_graphics/libdraw/menuhit.c)>>=
static	Image	*text;
@

<<global htext (lib_graphics/libdraw/menuhit.c)>>=
static	Image	*htext;
@

<<function menucolors (lib_graphics/libdraw/menuhit.c)>>=
static
void
menucolors(void)
{
    /* Main tone is greenish, with negative selection */
    back = allocimagemix(display, DPalegreen, DWhite);
    high = allocimage(display, Rect(0,0,1,1), view->chan, 1, DDarkgreen);	/* dark green */
    bord = allocimage(display, Rect(0,0,1,1), view->chan, 1, DMedgreen);	/* not as dark green */
    if(back==nil || high==nil || bord==nil)
        goto Error;
    text = display->black;
    htext = back;
    return;

    Error:
    freeimage(back);
    freeimage(high);
    freeimage(bord);
    back = display->white;
    high = display->black;
    bord = display->black;
    text = display->black;
    htext = display->white;
}
@

<<function menurect (lib_graphics/libdraw/menuhit.c)>>=
/*
 * r is a rectangle holding the text elements.
 * return the rectangle, including its black edge, holding element i.
 */
static Rectangle
menurect(Rectangle r, int i)
{
    if(i < 0)
        return Rect(0, 0, 0, 0);
    r.min.y += (font->height+Vspacing)*i;
    r.max.y = r.min.y+font->height+Vspacing;
    return insetrect(r, Border-Margin);
}
@

<<function menusel (lib_graphics/libdraw/menuhit.c)>>=
/*
 * r is a rectangle holding the text elements.
 * return the element number containing p.
 */
static int
menusel(Rectangle r, Point p)
{
    r = insetrect(r, Margin);
    if(!ptinrect(p, r))
        return -1;
    return (p.y-r.min.y)/(font->height+Vspacing);
}
@

<<function paintitem (lib_graphics/libdraw/menuhit.c)>>=
static
void
paintitem(Image *m, Menu *menu, Rectangle textr, int off, int i, int highlight, Image *save, Image *restore)
{
    char *item;
    Rectangle r;
    Point pt;

    if(i < 0)
        return;
    r = menurect(textr, i);
    if(restore){
        draw(m, r, restore, nil, restore->r.min);
        return;
    }
    if(save)
        draw(save, save->r, m, nil, r.min);
    item = menu->item? menu->item[i+off] : (*menu->gen)(i+off);
    pt.x = (textr.min.x+textr.max.x-stringwidth(font, item))/2;
    pt.y = textr.min.y+i*(font->height+Vspacing);
    draw(m, r, highlight? high : back, nil, pt);
    string(m, pt, highlight? htext : text, pt, font, item);
}
@

<<function menuscan (lib_graphics/libdraw/menuhit.c)>>=
/*
 * menur is a rectangle holding all the highlightable text elements.
 * track mouse while inside the box, return what's selected when button
 * is raised, -1 as soon as it leaves box.
 * invariant: nothing is highlighted on entry or exit.
 */
static int
menuscan(Image *m, Menu *menu, int but, Mousectl *mc, Rectangle textr, int off, int lasti, Image *save)
{
    int i;

    paintitem(m, menu, textr, off, lasti, 1, save, nil);
    for(readmouse(mc); mc->buttons & (1<<(but-1)); readmouse(mc)){
        i = menusel(textr, mc->xy);
        if(i != -1 && i == lasti)
            continue;
        paintitem(m, menu, textr, off, lasti, 0, nil, save);
        if(i == -1)
            return i;
        lasti = i;
        paintitem(m, menu, textr, off, lasti, 1, save, nil);
    }
    return lasti;
}
@

<<function menupaint (lib_graphics/libdraw/menuhit.c)>>=
static void
menupaint(Image *m, Menu *menu, Rectangle textr, int off, int nitemdrawn)
{
    int i;

    draw(m, insetrect(textr, Border-Margin), back, nil, ZP);
    for(i = 0; i<nitemdrawn; i++)
        paintitem(m, menu, textr, off, i, 0, nil, nil);
}
@

<<function menuscrollpaint (lib_graphics/libdraw/menuhit.c)>>=
static void
menuscrollpaint(Image *m, Rectangle scrollr, int off, int nitem, int nitemdrawn)
{
    Rectangle r;

    draw(m, scrollr, back, nil, ZP);
    r.min.x = scrollr.min.x;
    r.max.x = scrollr.max.x;
    r.min.y = scrollr.min.y + (Dy(scrollr)*off)/nitem;
    r.max.y = scrollr.min.y + (Dy(scrollr)*(off+nitemdrawn))/nitem;
    if(r.max.y < r.min.y+2)
        r.max.y = r.min.y+2;
    border(m, r, 1, bord, ZP);
    if(menutxt == 0)
        menutxt = allocimage(display, Rect(0, 0, 1, 1), view->chan, 1, DDarkgreen);	/* border color; BUG? */
    if(menutxt)
        draw(m, insetrect(r, 1), menutxt, nil, ZP);
}
@

<<function menuhit>>=
int
menuhit(int but, Mousectl *mc, Menu *menu, Screen *scr)
{
    int i, nitem, nitemdrawn, maxwid, lasti, off, noff, wid, screenitem;
    int scrolling;
    Rectangle r, menur, sc, textr, scrollr;
    Image *b, *save, *backup;
    Point pt;
    char *item;

    if(back == nil)
        menucolors();
    sc = view->clipr;
    replclipr(view, 0, view->r);
    maxwid = 0;
    for(nitem = 0;
        item = menu->item? menu->item[nitem] : (*menu->gen)(nitem);
        nitem++){
        i = stringwidth(font, item);
        if(i > maxwid)
            maxwid = i;
    }
    if(menu->lasthit<0 || menu->lasthit>=nitem)
        menu->lasthit = 0;
    screenitem = (Dy(view->r)-10)/(font->height+Vspacing);
    if(nitem>Maxunscroll || nitem>screenitem){
        scrolling = 1;
        nitemdrawn = Nscroll;
        if(nitemdrawn > screenitem)
            nitemdrawn = screenitem;
        wid = maxwid + Gap + Scrollwid;
        off = menu->lasthit - nitemdrawn/2;
        if(off < 0)
            off = 0;
        if(off > nitem-nitemdrawn)
            off = nitem-nitemdrawn;
        lasti = menu->lasthit-off;
    }else{
        scrolling = 0;
        nitemdrawn = nitem;
        wid = maxwid;
        off = 0;
        lasti = menu->lasthit;
    }
    r = insetrect(Rect(0, 0, wid, nitemdrawn*(font->height+Vspacing)), -Margin);
    r = rectsubpt(r, Pt(wid/2, lasti*(font->height+Vspacing)+font->height/2));
    r = rectaddpt(r, mc->xy);
    pt = ZP;
    if(r.max.x>view->r.max.x)
        pt.x = view->r.max.x-r.max.x;
    if(r.max.y>view->r.max.y)
        pt.y = view->r.max.y-r.max.y;
    if(r.min.x<view->r.min.x)
        pt.x = view->r.min.x-r.min.x;
    if(r.min.y<view->r.min.y)
        pt.y = view->r.min.y-r.min.y;
    menur = rectaddpt(r, pt);
    textr.max.x = menur.max.x-Margin;
    textr.min.x = textr.max.x-maxwid;
    textr.min.y = menur.min.y+Margin;
    textr.max.y = textr.min.y + nitemdrawn*(font->height+Vspacing);
    if(scrolling){
        scrollr = insetrect(menur, Border);
        scrollr.max.x = scrollr.min.x+Scrollwid;
    }else
        scrollr = Rect(0, 0, 0, 0);

    if(scr){
        b = allocwindow(scr, menur, Refbackup, DWhite);
        if(b == nil)
            b = view;
        backup = nil;
    }else{
        b = view;
        backup = allocimage(display, menur, view->chan, 0, -1);
        if(backup)
            draw(backup, menur, view, nil, menur.min);
    }
    draw(b, menur, back, nil, ZP);
    border(b, menur, Blackborder, bord, ZP);
    save = allocimage(display, menurect(textr, 0), view->chan, 0, -1);
    r = menurect(textr, lasti);
    moveto(mc, divpt(addpt(r.min, r.max), 2));
    menupaint(b, menu, textr, off, nitemdrawn);
    if(scrolling)
        menuscrollpaint(b, scrollr, off, nitem, nitemdrawn);
    while(mc->buttons & (1<<(but-1))){
        lasti = menuscan(b, menu, but, mc, textr, off, lasti, save);
        if(lasti >= 0)
            break;
        while(!ptinrect(mc->xy, textr) && (mc->buttons & (1<<(but-1)))){
            if(scrolling && ptinrect(mc->xy, scrollr)){
                noff = ((mc->xy.y-scrollr.min.y)*nitem)/Dy(scrollr);
                noff -= nitemdrawn/2;
                if(noff < 0)
                    noff = 0;
                if(noff > nitem-nitemdrawn)
                    noff = nitem-nitemdrawn;
                if(noff != off){
                    off = noff;
                    menupaint(b, menu, textr, off, nitemdrawn);
                    menuscrollpaint(b, scrollr, off, nitem, nitemdrawn);
                }
            }
            readmouse(mc);
        }
    }
    if(b != view)
        freeimage(b);
    if(backup){
        draw(view, menur, backup, nil, menur.min);
        freeimage(backup);
    }
    freeimage(save);
    replclipr(view, 0, sc);
    flushimage(display, true);
    if(lasti >= 0){
        menu->lasthit = lasti+off;
        return menu->lasthit;
    }
    return -1;
}
@



\section{Events part2}

\subsection{[[egetrects.c]]}
% advanced topic? with events?

<<constant Borderwidth>>=
Borderwidth =	4,
@

<<constant W>>=
#define	W	Borderwidth
@

<<global tmp>>=
static Image *tmp[4];
@

<<global red>>=
static Image *red;
@

<<global sweep>>=
static Cursor sweep={
    {-7, -7},
    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0x07,
     0xE0, 0x07, 0xE0, 0x07, 0xE3, 0xF7, 0xE3, 0xF7,
     0xE3, 0xE7, 0xE3, 0xF7, 0xE3, 0xFF, 0xE3, 0x7F,
     0xE0, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,},
    {0x00, 0x00, 0x7F, 0xFE, 0x40, 0x02, 0x40, 0x02,
     0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x41, 0xE2,
     0x41, 0xC2, 0x41, 0xE2, 0x41, 0x72, 0x40, 0x38,
     0x40, 0x1C, 0x40, 0x0E, 0x7F, 0xE6, 0x00, 0x00,}
};
@

% edrawgetrects -> <>
<<function brects>>=
static
void
brects(Rectangle r, Rectangle rp[4])
{
    if(Dx(r) < 2*W)
        r.max.x = r.min.x+2*W;
    if(Dy(r) < 2*W)
        r.max.y = r.min.y+2*W;
    rp[0] = Rect(r.min.x, r.min.y, r.max.x, r.min.y+W);
    rp[1] = Rect(r.min.x, r.max.y-W, r.max.x, r.max.y);
    rp[2] = Rect(r.min.x, r.min.y+W, r.min.x+W, r.max.y-W);
    rp[3] = Rect(r.max.x-W, r.min.y+W, r.max.x, r.max.y-W);
}
@

<<function egetrect>>=
Rectangle
egetrect(int but, Mouse *m)
{
    Rectangle r, rc;

    but = 1<<(but-1);
    esetcursor(&sweep);
    while(m->buttons)
        *m = emouse();
    while(!(m->buttons & but)){
        *m = emouse();
        if(m->buttons & (7^but))
            goto Return;
    }
    r.min = m->xy;
    r.max = m->xy;
    do{
        rc = canonrect(r);
        edrawgetrect(rc, 1);
        *m = emouse();
        edrawgetrect(rc, 0);
        r.max = m->xy;
    }while(m->buttons == but);

    Return:
    esetcursor(0);
    if(m->buttons & (7^but)){
        rc.min.x = rc.max.x = 0;
        rc.min.y = rc.max.y = 0;
        while(m->buttons)
            *m = emouse();
    }
    return rc;
}
@

<<function freetmp>>=
static
void
freetmp(void)
{
    freeimage(tmp[0]);
    freeimage(tmp[1]);
    freeimage(tmp[2]);
    freeimage(tmp[3]);
    freeimage(red);
    tmp[0] = tmp[1] = tmp[2] = tmp[3] = red = nil;
}
@

<<function edrawgetrect>>=
void
edrawgetrect(Rectangle rc, int up)
{
    int i;
    Rectangle r, rects[4];

    if(up && tmp[0]!=nil)
        if(Dx(tmp[0]->r)<Dx(rc) || Dy(tmp[2]->r)<Dy(rc))
            freetmp();

    if(tmp[0] == 0){
        r = Rect(0, 0, Dx(view->r), W);
        tmp[0] = allocimage(display, r, view->chan, 0, -1);
        tmp[1] = allocimage(display, r, view->chan, 0, -1);
        r = Rect(0, 0, W, Dy(view->r));
        tmp[2] = allocimage(display, r, view->chan, 0, -1);
        tmp[3] = allocimage(display, r, view->chan, 0, -1);
        red = allocimage(display, Rect(0,0,1,1), view->chan, 1, DRed);
        if(tmp[0]==0 || tmp[1]==0 || tmp[2]==0 || tmp[3]==0 || red==0)
            drawerror(display, "getrect: allocimage failed");
    }
    brects(rc, rects);
    if(!up){
        for(i=0; i<4; i++)
            draw(view, rects[i], tmp[i], nil, ZP);
        return;
    }
    for(i=0; i<4; i++){
        draw(tmp[i], Rect(0, 0, Dx(rects[i]), Dy(rects[i])), view, nil, rects[i].min);
        draw(view, rects[i], red, nil, ZP);
    }
}
@

\subsection{[[emenuhits.c]]}

<<enum _anon_ (lib_graphics/libdraw/emenuhit.c)>>=
enum
{
    Margin = 4,		/* outside to text */
    Border = 2,		/* outside to selection boxes */
    Blackborder = 2,	/* width of outlining border */
    Vspacing = 2,		/* extra spacing between lines of text */
    Maxunscroll = 25,	/* maximum #entries before scrolling turns on */
    Nscroll = 20,		/* number entries in scrolling part */
    Scrollwid = 14,		/* width of scroll bar */
    Gap = 4,			/* between text and scroll bar */
};
@

<<global menutxt>>=
static	Image	*menutxt;
@

<<global back>>=
static	Image	*back;
@

<<global high>>=
static	Image	*high;
@

<<global bord>>=
static	Image	*bord;
@

<<global text>>=
static	Image	*text;
@

<<global htext>>=
static	Image	*htext;
@

<<function menucolors>>=
static
void
menucolors(void)
{
    /* Main tone is greenish, with negative selection */
    back = allocimagemix(display, DPalegreen, DWhite);
    high = allocimage(display, Rect(0,0,1,1), CMAP8, 1, DDarkgreen);	/* dark green */
    bord = allocimage(display, Rect(0,0,1,1), CMAP8, 1, DMedgreen);	/* not as dark green */
    if(back==nil || high==nil || bord==nil)
        goto Error;
    text = display->black;
    htext = back;
    return;

    Error:
    freeimage(back);
    freeimage(high);
    freeimage(bord);
    back = display->white;
    high = display->black;
    bord = display->black;
    text = display->black;
    htext = display->white;
}
@

<<function menurect>>=
/*
 * r is a rectangle holding the text elements.
 * return the rectangle, including its black edge, holding element i.
 */
static Rectangle
menurect(Rectangle r, int i)
{
    if(i < 0)
        return Rect(0, 0, 0, 0);
    r.min.y += (font->height+Vspacing)*i;
    r.max.y = r.min.y+font->height+Vspacing;
    return insetrect(r, Border-Margin);
}
@

<<function menusel>>=
/*
 * r is a rectangle holding the text elements.
 * return the element number containing p.
 */
static int
menusel(Rectangle r, Point p)
{
    r = insetrect(r, Margin);
    if(!ptinrect(p, r))
        return -1;
    return (p.y-r.min.y)/(font->height+Vspacing);
}
@

<<function paintitem>>=
static
void
paintitem(Menu *menu, Rectangle textr, int off, int i, int highlight, Image *save, Image *restore)
{
    char *item;
    Rectangle r;
    Point pt;

    if(i < 0)
        return;
    r = menurect(textr, i);
    if(restore){
        draw(view, r, restore, nil, restore->r.min);
        return;
    }
    if(save)
        draw(save, save->r, view, nil, r.min);
    item = menu->item? menu->item[i+off] : (*menu->gen)(i+off);
    pt.x = (textr.min.x+textr.max.x-stringwidth(font, item))/2;
    pt.y = textr.min.y+i*(font->height+Vspacing);
    draw(view, r, highlight? high : back, nil, pt);
    string(view, pt, highlight? htext : text, pt, font, item);
}
@

<<function menuscan>>=
/*
 * menur is a rectangle holding all the highlightable text elements.
 * track mouse while inside the box, return what's selected when button
 * is raised, -1 as soon as it leaves box.
 * invariant: nothing is highlighted on entry or exit.
 */
static int
menuscan(Menu *menu, int but, Mouse *m, Rectangle textr, int off, int lasti, Image *save)
{
    int i;

    paintitem(menu, textr, off, lasti, 1, save, nil);
    flushimage(display, true);	/* in case display->locking is set */
    *m = emouse();
    while(m->buttons & (1<<(but-1))){
        flushimage(display, true);	/* in case display->locking is set */
        *m = emouse();
        i = menusel(textr, m->xy);
        if(i != -1 && i == lasti)
            continue;
        paintitem(menu, textr, off, lasti, 0, nil, save);
        if(i == -1)
            return i;
        lasti = i;
        paintitem(menu, textr, off, lasti, 1, save, nil);
    }
    return lasti;
}
@

<<function menupaint>>=
static void
menupaint(Menu *menu, Rectangle textr, int off, int nitemdrawn)
{
    int i;

    draw(view, insetrect(textr, Border-Margin), back, nil, ZP);
    for(i = 0; i<nitemdrawn; i++)
        paintitem(menu, textr, off, i, 0, nil, nil);
}
@

<<function menuscrollpaint>>=
static void
menuscrollpaint(Rectangle scrollr, int off, int nitem, int nitemdrawn)
{
    Rectangle r;

    draw(view, scrollr, back, nil, ZP);
    r.min.x = scrollr.min.x;
    r.max.x = scrollr.max.x;
    r.min.y = scrollr.min.y + (Dy(scrollr)*off)/nitem;
    r.max.y = scrollr.min.y + (Dy(scrollr)*(off+nitemdrawn))/nitem;
    if(r.max.y < r.min.y+2)
        r.max.y = r.min.y+2;
    border(view, r, 1, bord, ZP);
    if(menutxt == 0)
        menutxt = allocimage(display, Rect(0, 0, 1, 1), CMAP8, 1, DDarkgreen);
    if(menutxt)
        draw(view, insetrect(r, 1), menutxt, nil, ZP);
}
@

<<function emenuhit>>=
int
emenuhit(int but, Mouse *m, Menu *menu)
{
    int i, nitem, nitemdrawn, maxwid, lasti, off, noff, wid, screenitem;
    int scrolling;
    Rectangle r, menur, sc, textr, scrollr;
    Image *b, *save;
    Point pt;
    char *item;

    if(back == nil)
        menucolors();
    sc = view->clipr;
    replclipr(view, 0, view->r);
    maxwid = 0;
    for(nitem = 0;
        item = menu->item? menu->item[nitem] : (*menu->gen)(nitem);
        nitem++){
        i = stringwidth(font, item);
        if(i > maxwid)
            maxwid = i;
    }
    if(menu->lasthit<0 || menu->lasthit>=nitem)
        menu->lasthit = 0;
    screenitem = (Dy(view->r)-10)/(font->height+Vspacing);
    if(nitem>Maxunscroll || nitem>screenitem){
        scrolling = 1;
        nitemdrawn = Nscroll;
        if(nitemdrawn > screenitem)
            nitemdrawn = screenitem;
        wid = maxwid + Gap + Scrollwid;
        off = menu->lasthit - nitemdrawn/2;
        if(off < 0)
            off = 0;
        if(off > nitem-nitemdrawn)
            off = nitem-nitemdrawn;
        lasti = menu->lasthit-off;
    }else{
        scrolling = 0;
        nitemdrawn = nitem;
        wid = maxwid;
        off = 0;
        lasti = menu->lasthit;
    }
    r = insetrect(Rect(0, 0, wid, nitemdrawn*(font->height+Vspacing)), -Margin);
    r = rectsubpt(r, Pt(wid/2, lasti*(font->height+Vspacing)+font->height/2));
    r = rectaddpt(r, m->xy);
    pt = ZP;
    if(r.max.x>view->r.max.x)
        pt.x = view->r.max.x-r.max.x;
    if(r.max.y>view->r.max.y)
        pt.y = view->r.max.y-r.max.y;
    if(r.min.x<view->r.min.x)
        pt.x = view->r.min.x-r.min.x;
    if(r.min.y<view->r.min.y)
        pt.y = view->r.min.y-r.min.y;
    menur = rectaddpt(r, pt);
    textr.max.x = menur.max.x-Margin;
    textr.min.x = textr.max.x-maxwid;
    textr.min.y = menur.min.y+Margin;
    textr.max.y = textr.min.y + nitemdrawn*(font->height+Vspacing);
    if(scrolling){
        scrollr = insetrect(menur, Border);
        scrollr.max.x = scrollr.min.x+Scrollwid;
    }else
        scrollr = Rect(0, 0, 0, 0);

    b = allocimage(display, menur, view->chan, 0, 0);
    if(b == 0)
        b = view;
    draw(b, menur, view, nil, menur.min);
    draw(view, menur, back, nil, ZP);
    border(view, menur, Blackborder, bord, ZP);
    save = allocimage(display, menurect(textr, 0), view->chan, 0, -1);
    r = menurect(textr, lasti);
    emoveto(divpt(addpt(r.min, r.max), 2));
    menupaint(menu, textr, off, nitemdrawn);
    if(scrolling)
        menuscrollpaint(scrollr, off, nitem, nitemdrawn);
    while(m->buttons & (1<<(but-1))){
        lasti = menuscan(menu, but, m, textr, off, lasti, save);
        if(lasti >= 0)
            break;
        while(!ptinrect(m->xy, textr) && (m->buttons & (1<<(but-1)))){
            if(scrolling && ptinrect(m->xy, scrollr)){
                noff = ((m->xy.y-scrollr.min.y)*nitem)/Dy(scrollr);
                noff -= nitemdrawn/2;
                if(noff < 0)
                    noff = 0;
                if(noff > nitem-nitemdrawn)
                    noff = nitem-nitemdrawn;
                if(noff != off){
                    off = noff;
                    menupaint(menu, textr, off, nitemdrawn);
                    menuscrollpaint(scrollr, off, nitem, nitemdrawn);
                }
            }
            flushimage(display, true);	/* in case display->locking is set */
            *m = emouse();
        }
    }
    draw(view, menur, b, nil, menur.min);
    if(b != view)
        freeimage(b);
    freeimage(save);
    replclipr(view, 0, sc);
    if(lasti >= 0){
        menu->lasthit = lasti+off;
        return menu->lasthit;
    }
    return -1;
}
@
% >> >>

\section{Graphics text mode}
% when do aux/vga it switches to graphic mode, but we still want a console!
% the kernel still needs a working (*screenputs)(...).


% this used to be a subsection of VGA driver, 
% but the code seems quite generic and almost independent of VGA
% so I moved it here.

<<global curpos(x86)>>=
static Point curpos;
@
<<global window bis(x86)>>=
static Rectangle window;
@


% /dev/vgactl size write -> <>
<<function vgascreenwin(x86)>>=
void
vgascreenwin(VGAscr* scr)
{
    int h, w;

    h = scr->memdefont->height;
    w = scr->memdefont->info[' '].width;

    window = insetrect(gscreen->r, 48);
    window.max.x = window.min.x+((window.max.x-window.min.x)/w)*w;
    window.max.y = window.min.y+((window.max.y-window.min.y)/h)*h;
    curpos = window.min;

    screenputs = vgascreenputs;
}
@
%todo: do like for raspberry, have greet message also in graphic mode?

% vgascreenputs -> screenputs = <> (and screenputs call for printing 
%  keystroke on the screen)
<<function vgascreenputs(x86)>>=
static void
vgascreenputs(char* s, int n)
{
    int i;
    bool gotdraw;
    Rune r;
    char buf[4];
    VGAscr *scr;
    Rectangle flushr;

    scr = &vgascreen;

    if(!islo()){
        /*
         * Don't deadlock trying to
         * print in an interrupt.
         */
        if(!canlock(&vgascreenlock))
            return;
    }
    else
        lock(&vgascreenlock);

    /*
     * Be nice to hold this, but not going to deadlock
     * waiting for it.  Just try and see.
     */
    gotdraw = canqlock(&drawlock);

    flushr = Rect(10000, 10000, -10000, -10000);

    while(n > 0){
        i = chartorune(&r, s);
        if(i == 0){
            s++;
            --n;
            continue;
        }
        memmove(buf, s, i);
        buf[i] = 0;
        n -= i;
        s += i;
        vgascreenputc(scr, buf, &flushr);
    }
    flushmemscreen(flushr);

    if(gotdraw)
        qunlock(&drawlock);
    unlock(&vgascreenlock);
}
@


<<global xbuf(x86)>>=
static int xbuf[256];
@
<<global xp(x86)>>=
static int *xp;
@


% vgascreenputs -> <>
<<function vgascreenputc(x86)>>=
static void
vgascreenputc(VGAscr* scr, char* buf, Rectangle *flushr)
{
    Point p;
    int h, w, pos;
    Rectangle r;

//  drawdebug = 1;
    if(xp < xbuf || xp >= &xbuf[sizeof(xbuf)])
        xp = xbuf;

    h = scr->memdefont->height;
    switch(buf[0]){

    case '\n':
        if(curpos.y+h >= window.max.y){
            vgascroll(scr);
            *flushr = window;
        }
        curpos.y += h;
        vgascreenputc(scr, "\r", flushr);
        break;

    case '\r':
        xp = xbuf;
        curpos.x = window.min.x;
        break;

    case '\t':
        p = memsubfontwidth(scr->memdefont, " ");
        w = p.x;
        if(curpos.x >= window.max.x-4*w)
            vgascreenputc(scr, "\n", flushr);

        pos = (curpos.x-window.min.x)/w;
        pos = 4-(pos%4);
        *xp++ = curpos.x;
        r = Rect(curpos.x, curpos.y, curpos.x+pos*w, curpos.y + h);
        memimagedraw(gscreen, r, back, back->r.min, nil, back->r.min, S);
        curpos.x += pos*w;
        break;

    case '\b':
        if(xp <= xbuf)
            break;
        xp--;
        r = Rect(*xp, curpos.y, curpos.x, curpos.y+h);
        memimagedraw(gscreen, r, back, back->r.min, nil, ZP, S);
        combinerect(flushr, r);
        curpos.x = *xp;
        break;

    case '\0':
        break;

    default:
        p = memsubfontwidth(scr->memdefont, buf);
        w = p.x;

        if(curpos.x >= window.max.x-w)
            vgascreenputc(scr, "\n", flushr);

        *xp++ = curpos.x;
        r = Rect(curpos.x, curpos.y, curpos.x+w, curpos.y+h);
        memimagedraw(gscreen, r, back, back->r.min, nil, back->r.min, S);
        memimagestring(gscreen, curpos, conscol, ZP, scr->memdefont, buf);
        combinerect(flushr, r);
        curpos.x += w;
    }
//  drawdebug = 0;
}
@


% vgascreenputs -> vgascreenputc -> <>
<<function vgascroll(x86)>>=
static void
vgascroll(VGAscr* scr)
{
    int h, o;
    Point p;
    Rectangle r;

    h = scr->memdefont->height;
    o = 8*h;
    r = Rpt(window.min, Pt(window.max.x, window.max.y-o));
    p = Pt(window.min.x, window.min.y+o);
    memimagedraw(gscreen, r, gscreen, p, nil, p, S);
    r = Rpt(Pt(window.min.x, window.max.y-o), window.max);
    memimagedraw(gscreen, r, back, ZP, nil, ZP, S);

    curpos.y -= o;
}
@
% not very hardware specific, could probably be put in a generic screen.c no?


<<global back2(x86)>>=
static Memimage* back;
@

<<global conscol(x86)>>=
static Memimage *conscol;
@

<<[[screensize()]] setup globals for vga text mode(x86)>>=
vgaimageinit(chan);
@

<<function vgaimageinit(x86)>>=
void
vgaimageinit(ulong chan)
{
    if(back == nil){
        back = allocmemimage(Rect(0,0,1,1), chan);  /* RSC BUG */
        if(back == nil)
            panic("back alloc");        /* RSC BUG */
        back->flags |= Frepl;
        back->clipr = Rect(-0x3FFFFFF, -0x3FFFFFF, 0x3FFFFFF, 0x3FFFFFF);
        memfillcolor(back, DBlack);
    }

    if(conscol == nil){
        conscol = allocmemimage(Rect(0,0,1,1), chan);   /* RSC BUG */
        if(conscol == nil)
            panic("conscol alloc"); /* RSC BUG */
        conscol->flags |= Frepl;
        conscol->clipr = Rect(-0x3FFFFFF, -0x3FFFFFF, 0x3FFFFFF, 0x3FFFFFF);
        memfillcolor(conscol, DWhite);
    }
}
@


\section{Blank screen}

<<[[vgactl]] cases(x86)>>=
case CMblank:
    drawblankscreen(true);
    return;
@
<<[[vgactl]] cases(x86)>>=
case CMunblank:
    drawblankscreen(false);
    return;
@

<<[[KDraw]] other fields>>=
bool	blanked;    /* screen turned off */
@


<<function drawblankscreen>>=
void
drawblankscreen(bool blank)
{
    int i, nc;
    ulong *p;

    if(blank == sdraw.blanked)
        return;
    if(!candlock())
        return;
    if(screenimage == nil){
        dunlock();
        return;
    }
    p = sdraw.savemap;
    nc = screenimage->depth > 8 ? 256 : 1<<screenimage->depth;

    /*
     * blankscreen uses the hardware to blank the screen
     * when possible.  to help in cases when it is not possible,
     * we set the color map to be all black.
     */
    if(blank == false){ /* turn screen on */
        for(i=0; i<nc; i++, p+=3)
            setcolor(i, p[0], p[1], p[2]);
        blankscreen(false);
    }else{  /* turn screen off */
        blankscreen(true);
        for(i=0; i<nc; i++, p+=3){
            getcolor(i, &p[0], &p[1], &p[2]);
            setcolor(i, 0, 0, 0);
        }
    }
    sdraw.blanked = blank;
    dunlock();
}
@
% >>



<<global blanktime>>=
ulong blanktime = 30;   /* in minutes; a half hour */
@
% used by drawactive()
<<[[vgactl]] cases(x86)>>=
case CMblanktime:
    blanktime = strtoul(cb->f[1], 0, 0);
    return;
@

<<[[KDraw]] other fields>>=
ulong   blanktime;  /* time of last operation */
@

% seems always caleld with active = true (from draw read/write colormap)
<<function drawactive>>=
/*
 * record activity on screen, changing blanking as appropriate
 */
void
drawactive(bool active)
{
    if(active){
        drawblankscreen(false);
        sdraw.blanktime = CPUS(0)->ticks;
    }else{
        if(blanktime && sdraw.blanktime 
           && TK2SEC(CPUS(0)->ticks - sdraw.blanktime)/60 >= blanktime)
            drawblankscreen(true);
    }
}
@

% vgaread -> <>
<<function drawidletime>>=
int
drawidletime(void)
{
    return TK2SEC(CPUS(0)->ticks - sdraw.blanktime)/60;
}
@

\subsection{Hardware support}

<<global hwblank(x86)>>=
bool hwblank = false;    /* turned on by drivers that are known good */
@

<<[[vgactl]] cases(x86)>>=
case CMhwblank:
    if(strcmp(cb->f[1], "on") == 0)
        hwblank = true;
    else if(strcmp(cb->f[1], "off") == 0)
        hwblank = false;
    else
        break;
    return;
@



<<[[VGAscr]] optional methods(x86)>>=
void  (*blank)(VGAscr*, int);
@

<<[[VGAscr]] other fields(x86)>>=
int isblank;
@
% dead isblank? not set in drawblankscreen, probably bug no?

<<function blankscreen bis(x86)>>=
void
blankscreen(int blank)
{
    VGAscr *scr;

    scr = &vgascreen;
    if(hwblank){
        if(scr->blank)
            scr->blank(scr, blank);
        else
            vgablank(scr, blank);
    }
}
@

% blankscreen -> <>
<<function vgablank(x86)>>=
/*
 * Supposedly this is the way to turn DPMS
 * monitors off using just the VGA registers.
 * Unfortunately, it seems to mess up the video mode
 * on the cards I've tried.
 */
void
vgablank(VGAscr*, int blank)
{
    uchar seq1, crtc17;

    if(blank) {
        seq1 = 0x00;
        crtc17 = 0x80;
    } else {
        seq1 = 0x20;
        crtc17 = 0x00;
    }

    outs(Seqx, 0x0100);         /* synchronous reset */
    seq1 |= vgaxi(Seqx, 1) & ~0x20;
    vgaxo(Seqx, 1, seq1);
    crtc17 |= vgaxi(Crtx, 0x17) & ~0x80;
    delay(10);
    vgaxo(Crtx, 0x17, crtc17);
    outs(Crtx, 0x0300);             /* end synchronous reset */
}
@

\section{[[/dev/draw/x/refresh]]}

<<[[Display]] devdraw connection fields>>=
fdt		reffd; // /dev/draw/x/refresh
@


\chapter{Conclusion}

\appendix

\chapter{Debugging}

% to debug drawmesg()
<<function printmesg>>=
static void
printmesg(char *fmt, uchar *a, bool plsprnt)
{
    char buf[256];
    char *p, *q;
    int s, left;

    if(1|| plsprnt==false){
        SET(s,q,p);
        USED(fmt, a, buf, p, q, s);
        return;
    }

    q = buf;
    *q++ = *a++;
    for(p=fmt; *p; p++){
        left = sizeof buf - 2 - (q - buf);  /* 2 for \n\0 */
        switch(*p){
        case 'l':
            q += snprint(q, left, " %ld", (long)BGLONG(a));
            a += 4;
            break;
        case 'L':
            q += snprint(q, left, " %.8lux", (ulong)BGLONG(a));
            a += 4;
            break;
        case 'R':
            q += snprint(q, left, " [%d %d %d %d]", BGLONG(a),
                BGLONG(a+4), BGLONG(a+8), BGLONG(a+12));
            a += 16;
            break;
        case 'P':
            q += snprint(q, left, " [%d %d]", BGLONG(a), BGLONG(a+4));
            a += 8;
            break;
        case 'b':
            q += snprint(q, left, " %d", *a++);
            break;
        case 's':
            q += snprint(q, left, " %d", BGSHORT(a));
            a += 2;
            break;
        case 'S':
            q += snprint(q, left, " %.4ux", BGSHORT(a));
            a += 2;
            break;
        }
    }
    *q++ = '\n';
    *q = 0;
    iprint("%.*s", (int)(q-buf), buf);
}
@




% libdraw
<<global _drawdebug>>=
bool	_drawdebug = 0;
@

% libmemdrawn
<<global drawdebug>>=
bool drawdebug;
@
% rename? memdrawdebug?


<<global debuglockdisplay>>=
bool		debuglockdisplay = false;
@


<<function drawsetdebug>>=
void
drawsetdebug(bool v)
{
    uchar *a;
    a = bufimage(display, 1+1);
    if(a == 0){
        fprint(2, "drawsetdebug: %r\n");
        return;
    }
    a[0] = 'D';
    a[1] = v;
}
@

<<[[drawmesg()]] cases>>=
/* toggle debugging: 'D' val[1] */
case 'D':
    printmesg(fmt="b", a, 0);
    m = 1+1;
    if(n < m)
        error(Eshortdraw);
    drawdebug = a[1];
    continue;
@


\section{Dumpers}

\subsection{Point and Rectangle}

<<[[initdisplay()]] install dumpers>>=
fmtinstall('P', Pfmt);
fmtinstall('R', Rfmt);
@

%dumper
<<function Pfmt>>=
int
Pfmt(Fmt *f)
{
    Point p;

    p = va_arg(f->args, Point);
    return fmtprint(f, "[%d %d]", p.x, p.y);
}
@

%dumper
<<function Rfmt>>=
int
Rfmt(Fmt *f)
{
    Rectangle r;

    r = va_arg(f->args, Rectangle);
    return fmtprint(f, "%P %P", r.min, r.max);
}
@

\subsection{Channel}

% maybe could put in dumper section?

<<global channames>>=
static char channames[] = "rgbkamx";
@

<<function chantostr>>=
char*
chantostr(char *buf, ulong cc)
{
    ulong c, rc;
    char *p;

    if(chantodepth(cc) == 0)
        return nil;

    /* reverse the channel descriptor so we can easily generate the string in the right order */
    rc = 0;
    for(c=cc; c; c>>=8){
        rc <<= 8;
        rc |= c&0xFF;
    }

    p = buf;
    for(c=rc; c; c>>=8) {
        *p++ = channames[TYPE(c)];
        *p++ = '0'+NBITS(c);
    }
    *p = 0;

    return buf;
}
@

<<function isspace>>=
/* avoid pulling in ctype when using with drawterm etc. */
static int
isspace(char c)
{
    return c==' ' || c== '\t' || c=='\r' || c=='\n';
}
@

% used when reading the first image spec from the draw new connection
<<function strtochan>>=
ulong
strtochan(char *s)
{
    char *p, *q;
    ulong c;
    int t, n, d;

    c = 0;
    d = 0;
    p=s;
    while(*p && isspace(*p))
        p++;

    while(*p && !isspace(*p)){
        if((q = strchr(channames, p[0])) == nil) 
            return 0;
        t = q-channames;
        if(p[1] < '0' || p[1] > '9')
            return 0;
        n = p[1]-'0';
        d += n;
        c = (c<<8) | __DC(t, n);
        p += 2;
    }
    if(d==0 || (d>8 && d%8) || (d<8 && 8%d))
        return 0;
    return c;
}
@
% >> 


\chapter{Error Managment}

% initdraw take an error parameter?

<<[[Display]] other fields>>=
void	(*error)(Display*, char*);
@

<<function drawerror>>=
void
drawerror(Display *d, char *s)
{
    char err[ERRMAX];

    if(d && d->error)
        d->error(d, s);
    else{
        errstr(err, sizeof err);
        fprint(STDERR, "draw: %s: %s\n", s, err);
        exits(s);
    }
}
@


\chapter{VGA driver}

<<struct VGAscr(x86)>>=
struct VGAscr {

  ulong paddr;    /* frame buffer */
  void* vaddr;
  int   apsize;

  Memsubfont* memdefont;

  Cursor;
  // the cursor device methods (software cursor or hardware support)
  VGAcur* cur;

  ulong colormap[Pcolours][3];
  int palettedepth;

  // the vga device methods
  VGAdev* dev;

  Pcidev* pci;
  ulong io;       /* device specific registers */
  ulong *mmio;

  ulong storage;
  bool useflush;

  ulong id; /* internal identifier for driver use */

  // why here? why not in VGAdev?
  <<[[VGAscr]] optional methods(x86)>>

  <<[[VGAscr]] other fields(x86)>>

  // Extra
  Lock  devlock;
};
@
% old: this used to have a gscreen and gscreendata fields, but
% there were just redundant with gscreen and gscreendata globals,
% so I removed those fields, which makes it also easier to move
% more generic stuff in screen.c

<<[[VGAscr]] other fields(x86)>>=
int overlayinit;
@

%XXX move later
<<[[VGAscr]] optional methods(x86)>>=
int (*fill)(VGAscr*, Rectangle, ulong);
int (*scroll)(VGAscr*, Rectangle, Rectangle);
@


<<global vgascreen(x86)>>=
VGAscr vgascreen;
@
%set by screensize()? and probably via vgactl
%old: this used to be vgascreen[1], but I refactored to just vgascreen.
% I didn't find any vga driver having more than 1 VGAscr so not sure
% why it was like that. Once this was done, it didn't make sense to
% have the gscreen/gscreendata globals and vgascreen[0].gscreen
% and vgascreen[0].gscreendata so I removed those fields.

<<function VGAMEM(x86)>>=
#define VGAMEM()  0xA0000
@
% vgascreen.paddr?


% !!!!!!!!!
<<function ishwimage(x86)>>=
bool
ishwimage(Memimage* i)
{
  return (i->data->bdata == gscreendata.bdata);
}
@
% could be just i == gscreen no?
%//#define ishwimage(i)  (vgascreen[0].gscreendata && (i)->data->bdata == vgascreen[0].gscreendata->bdata)




% see "adventure in graphic card" from BeOS people in src/vga/? meh

<<enum vgamisc(x86)>>=
  Pcolours  = 256,    /* Palette */
  Pred    = 0,
  Pgreen  = 1,
  Pblue   = 2,

  Pblack    = 0x00,
  Pwhite    = 0xFF,
};
@

<<enum _anon_ (kernel/devices/screen/386/screen.h)2>>=
enum {
  Backgnd   = 0,  /* black */
};
@


<<global vgadevtab(x86)>>=
Dev vgadevtab = {
    .dc       =    'v',
    .name     =    "vga",
               
    .reset    =    vgareset,

    .attach   =    vgaattach,
    .walk     =    vgawalk,
    .open     =    vgaopen,
    .close    =    vgaclose,
    .read     =    vgaread,
    .write    =    vgawrite,
    .stat     =    vgastat,
    .wstat    =    devwstat,

    .init     =    devinit,
    .shutdown =    devshutdown,
    .create   =    devcreate,
    .bread    =    devbread,
    .bwrite   =    devbwrite,
    .remove   =    devremove,
};
@
% put the devtab? where have the cirrus logic there?

\section{IO ports}

<<enum vgaports(x86)>>=
/*
 * Generic VGA registers.
 */
enum {
  MiscW   = 0x03C2, /* Miscellaneous Output (W) */
  MiscR   = 0x03CC, /* Miscellaneous Output (R) */
  Status0   = 0x03C2, /* Input status 0 (R) */
  Status1   = 0x03DA, /* Input Status 1 (R) */
  FeatureR  = 0x03CA, /* Feature Control (R) */
  FeatureW  = 0x03DA, /* Feature Control (W) */

  Seqx    = 0x03C4, /* Sequencer Index, Data at Seqx+1 */
  Crtx    = 0x03D4, /* CRT Controller Index, Data at Crtx+1 */
  Grx   = 0x03CE, /* Graphics Controller Index, Data at Grx+1 */
  Attrx   = 0x03C0, /* Attribute Controller Index and Data */

  PaddrW    = 0x03C8, /* Palette Address Register, write */
  Pdata     = 0x03C9, /* Palette Data Register */
  Pixmask   = 0x03C6, /* Pixel Mask Register */
  PaddrR    = 0x03C7, /* Palette Address Register, read */
  Pstatus   = 0x03C7, /* DAC Status (RO) */
@

<<function vgao(x86)>>=
#define vgao(port, data)  outb(port, data)
@


<<global vgaxlock(x86)>>=
static Lock vgaxlock;           /* access to index registers */
@

<<function vgaxi(x86)>>=
int
vgaxi(long port, uchar index)
{
    uchar data;

    ilock(&vgaxlock);
    switch(port){

    case Seqx:
    case Crtx:
    case Grx:
        outb(port, index);
        data = inb(port+1);
        break;

    case Attrx:
        /*
         * Allow processor access to the colour
         * palette registers. Writes to Attrx must
         * be preceded by a read from Status1 to
         * initialise the register to point to the
         * index register and not the data register.
         * Processor access is allowed by turning
         * off bit 0x20.
         */
        inb(Status1);
        if(index < 0x10){
            outb(Attrx, index);
            data = inb(Attrx+1);
            inb(Status1);
            outb(Attrx, 0x20|index);
        }
        else{
            outb(Attrx, 0x20|index);
            data = inb(Attrx+1);
        }
        break;

    default:
        iunlock(&vgaxlock);
        return -1;
    }
    iunlock(&vgaxlock);

    return data & 0xFF;
}
@

<<function vgaxo(x86)>>=
int
vgaxo(long port, uchar index, uchar data)
{
    ilock(&vgaxlock);
    switch(port){

    case Seqx:
    case Crtx:
    case Grx:
        /*
         * We could use an outport here, but some chips
         * (e.g. 86C928) have trouble with that for some
         * registers.
         */
        outb(port, index);
        outb(port+1, data);
        break;

    case Attrx:
        inb(Status1);
        if(index < 0x10){
            outb(Attrx, index);
            outb(Attrx, data);
            inb(Status1);
            outb(Attrx, 0x20|index);
        }
        else{
            outb(Attrx, 0x20|index);
            outb(Attrx, data);
        }
        break;

    default:
        iunlock(&vgaxlock);
        return -1;
    }
    iunlock(&vgaxlock);

    return 0;
}
@


\section{[[VGAdev]]}

<<struct VGAdev(x86)>>=
struct VGAdev {
  char* name;

  void  (*enable)(VGAscr*);
  void  (*disable)(VGAscr*);

  void  (*page)(VGAscr*, int);
  void  (*linear)(VGAscr*, int, int);
 
  // optional
  void  (*drawinit)(VGAscr*);
  int   (*fill)(VGAscr*, Rectangle, ulong);
  void  (*ovlctl)(VGAscr*, Chan*, void*, int);
  int   (*ovlwrite)(VGAscr*, void*, int, vlong);

  void  (*flush)(VGAscr*, Rectangle);
};
@

% linear? apparently can't use soft cursor with non-linear VGA, but
% I don't know what it means ...

\section{[[/dev/vgaxxx]]}

<<enum _anon_ (kernel/devices/screen/386/devvga.c)>>=
enum {
    Qdir,

    Qvgabios,
    Qvgactl,

    Qvgaovl,
    Qvgaovlctl,
};
@

<<global vgadir(x86)>>=
static Dirtab vgadir[] = {
    ".",    { Qdir, 0, QTDIR },     0,  0550,
    "vgabios",  { Qvgabios, 0 },    0x100000, 0440,
    "vgactl",       { Qvgactl, 0 },     0,  0660,
    "vgaovl",       { Qvgaovl, 0 },     0,  0660,
    "vgaovlctl",    { Qvgaovlctl, 0 },  0,  0660,
};
@

<<enum _anon_ (kernel/devices/screen/386/devvga.c)2>>=
enum {
    CMactualsize,
    CMblank,
    CMblanktime,
    CMdrawinit,
    CMhwaccel,
    CMhwblank,
    CMhwgc,
    CMlinear,
    CMpalettedepth,
    CMpanning,
    CMsize,
    CMtextmode,
    CMtype,
    CMunblank,
};
@

<<global vgactlmsg(x86)>>=
static Cmdtab vgactlmsg[] = {
    CMactualsize,   "actualsize",   2,
    CMblank,    "blank",    1,
    CMblanktime,    "blanktime",    2,
    CMdrawinit, "drawinit", 1,
    CMhwaccel,  "hwaccel",  2,
    CMhwblank,  "hwblank",  2,
    CMhwgc,     "hwgc",     2,
    CMlinear,   "linear",   0,
    CMpalettedepth, "palettedepth", 2,
    CMpanning,  "panning",  2,
    CMsize,     "size",     3,
    CMtextmode, "textmode", 1,
    CMtype,     "type",     2,
    CMunblank,  "unblank",  1,
};
@

<<function vgareset(x86)>>=
static void
vgareset(void)
{
    /* reserve the 'standard' vga registers */
    if(ioalloc(0x2b0, 0x2df-0x2b0+1, 0, "vga") < 0)
        panic("vga ports already allocated"); 
    if(ioalloc(0x3c0, 0x3da-0x3c0+1, 0, "vga") < 0)
        panic("vga ports already allocated"); 
}
@

<<function vgaattach(x86)>>=
static Chan*
vgaattach(char* spec)
{
    if(*spec && strcmp(spec, "0"))
        error(Eio);
    return devattach('v', spec);
}
@

<<function vgawalk(x86)>>=
Walkqid*
vgawalk(Chan* c, Chan *nc, char** name, int nname)
{
    return devwalk(c, nc, name, nname, vgadir, nelem(vgadir), devgen);
}
@

<<function vgastat(x86)>>=
static int
vgastat(Chan* c, uchar* dp, int n)
{
    return devstat(c, dp, n, vgadir, nelem(vgadir), devgen);
}
@

<<function vgaopen(x86)>>=
static Chan*
vgaopen(Chan* c, int omode)
{
    VGAscr *scr;
    static char *openctl = "openctl\n";

    scr = &vgascreen;
    if ((ulong)c->qid.path == Qvgaovlctl) {
        if (scr->dev && scr->dev->ovlctl)
            scr->dev->ovlctl(scr, c, openctl, strlen(openctl));
        else 
            error(Enonexist);
    }
    return devopen(c, omode, vgadir, nelem(vgadir), devgen);
}
@

<<function vgaclose(x86)>>=
static void
vgaclose(Chan* c)
{
    VGAscr *scr;
    static char *closectl = "closectl\n";

    scr = &vgascreen;
    if((ulong)c->qid.path == Qvgaovlctl)
        if(scr->dev && scr->dev->ovlctl){
            if(waserror()){
                print("ovlctl error: %s\n", up->errstr);
                return;
            }
            scr->dev->ovlctl(scr, c, closectl, strlen(closectl));
            poperror();
        }
}
@

<<function vgaread(x86)>>=
static long
vgaread(Chan* c, void* a, long n, vlong off)
{
    int len;
    char *p, *s;
    VGAscr *scr;
    ulong offset = off;
    char chbuf[30];

    switch((ulong)c->qid.path){

    case Qdir:
        return devdirread(c, a, n, vgadir, nelem(vgadir), devgen);

    case Qvgabios:
        if(offset >= 0x100000)
            return 0;
        if(offset+n >= 0x100000)
            n = 0x100000 - offset;
        memmove(a, (uchar*)kaddr(0)+offset, n);
        return n;

    case Qvgactl:
        scr = &vgascreen;

        p = malloc(READSTR);
        if(p == nil)
            error(Enomem);
        if(waserror()){
            free(p);
            nexterror();
        }

        len = 0;

        if(scr->dev)
            s = scr->dev->name;
        else
            s = "cga";
        len += snprint(p+len, READSTR-len, "type %s\n", s);

        if(gscreen) {
            len += snprint(p+len, READSTR-len, "size %dx%dx%d %s\n",
                gscreen->r.max.x, gscreen->r.max.y,
                gscreen->depth, chantostr(chbuf, gscreen->chan));

            if(Dx(gscreen->r) != Dx(physgscreenr) 
            || Dy(gscreen->r) != Dy(physgscreenr))
                len += snprint(p+len, READSTR-len, "actualsize %dx%d\n",
                    physgscreenr.max.x, physgscreenr.max.y);
        }

        len += snprint(p+len, READSTR-len, "blank time %lud idle %d state %s\n",
            blanktime, drawidletime(), scr->isblank ? "off" : "on");
        len += snprint(p+len, READSTR-len, "hwaccel %s\n", hwaccel ? "on" : "off");
        len += snprint(p+len, READSTR-len, "hwblank %s\n", hwblank ? "on" : "off");
        len += snprint(p+len, READSTR-len, "panning %s\n", panning ? "on" : "off");
        len += snprint(p+len, READSTR-len, "addr p 0x%lux v 0x%p size 0x%ux\n", scr->paddr, scr->vaddr, scr->apsize);
        USED(len);

        n = readstr(offset, a, n, p);
        poperror();
        free(p);

        return n;

    case Qvgaovl:
    case Qvgaovlctl:
        error(Ebadusefd);
        break;

    default:
        error(Egreg);
        break;
    }

    return 0;
}
@

%//static char Ebusy[] = "vga already configured";

<<function vgactl(x86)>>=
static void
vgactl(Cmdbuf *cb)
{
    int align, i, size, x, y, z;
    char *chanstr, *p;
    ulong chan;
    Cmdtab *ct;
    VGAscr *scr;
    extern VGAdev *vgadev[];
    extern VGAcur *vgacur[];

    scr = &vgascreen;
    ct = lookupcmd(cb, vgactlmsg, nelem(vgactlmsg));
    switch(ct->index){
    <<[[vgactl]] cases(x86)>>
    }

    cmderror(cb, "bad VGA control message");
}
@


<<[[vgactl]] cases(x86)>>=
case CMhwgc:
    if(strcmp(cb->f[1], "off") == 0){
        lock(&cursor);
        if(scr->cur){
            if(scr->cur->disable)
                scr->cur->disable(scr);
            scr->cur = nil;
        }
        unlock(&cursor);
        return;
    }
    if(strcmp(cb->f[1], "soft") == 0){
        lock(&cursor);
        swcursorinit();
        if(scr->cur && scr->cur->disable)
            scr->cur->disable(scr);
        scr->cur = &swcursor;
        if(scr->cur->enable)
            scr->cur->enable(scr);
        unlock(&cursor);
        return;
    }
    for(i = 0; vgacur[i]; i++){
        if(strcmp(cb->f[1], vgacur[i]->name))
            continue;
        lock(&cursor);
        if(scr->cur && scr->cur->disable)
            scr->cur->disable(scr);
        scr->cur = vgacur[i];
        if(scr->cur->enable)
            scr->cur->enable(scr);
        unlock(&cursor);
        return;
    }
    break;
@
<<[[vgactl]] cases(x86)>>=
case CMtype:
    for(i = 0; vgadev[i]; i++){
        if(strcmp(cb->f[1], vgadev[i]->name))
            continue;
        if(scr->dev && scr->dev->disable)
            scr->dev->disable(scr);
        scr->dev = vgadev[i];
        if(scr->dev->enable)
            scr->dev->enable(scr);
        return;
    }
    break;
@


<<[[vgactl]] cases(x86)>>=
case CMsize:
    x = strtoul(cb->f[1], &p, 0);
    if(x == 0 || x > 10240)
        error(Ebadarg);
    if(*p)
        p++;

    y = strtoul(p, &p, 0);
    if(y == 0 || y > 10240)
        error(Ebadarg);
    if(*p)
        p++;

    z = strtoul(p, &p, 0);

    chanstr = cb->f[2];
    if((chan = strtochan(chanstr)) == 0)
        error("bad channel");

    if(chantodepth(chan) != z)
        error("depth, channel do not match");

    cursoroff(1);
    deletescreenimage();
    if(screensize(x, y, z, chan))
        error(Egreg);
    vgascreenwin(scr);
    resetscreenimage();
    cursoron(1);
    return;
@
<<[[vgactl]] cases(x86)>>=
case CMactualsize:
    if(gscreen == nil)
        error("set the screen size first");

    x = strtoul(cb->f[1], &p, 0);
    if(x == 0 || x > 2048)
        error(Ebadarg);
    if(*p)
        p++;

    y = strtoul(p, nil, 0);
    if(y == 0 || y > 2048)
        error(Ebadarg);

    if(x > gscreen->r.max.x || y > gscreen->r.max.y)
        error("physical screen bigger than virtual");

    physgscreenr = Rect(0,0,x,y);
    gscreen->clipr = physgscreenr;
    return;
@
<<[[vgactl]] cases(x86)>>=
case CMpalettedepth:
    x = strtoul(cb->f[1], &p, 0);
    if(x != 8 && x != 6)
        error(Ebadarg);

    scr->palettedepth = x;
    return;
@
<<[[vgactl]] cases(x86)>>=
case CMdrawinit:
    if(gscreen == nil)
        error("drawinit: no gscreen");
    if(scr->dev && scr->dev->drawinit)
        scr->dev->drawinit(scr);
    return;
@



<<[[vgactl]] cases(x86)>>=
case CMlinear:
    if(cb->nf!=2 && cb->nf!=3)
        error(Ebadarg);
    size = strtoul(cb->f[1], 0, 0);
    if(cb->nf == 2)
        align = 0;
    else
        align = strtoul(cb->f[2], 0, 0);
    if(screenaperture(size, align) < 0)
        error("not enough free address space");
    return;
@

% vgactl linear -> <>
<<function screenaperture(x86)>>=
int
screenaperture(int size, int align)
{
    VGAscr *scr;

    scr = &vgascreen;

    if(scr->paddr)  /* set up during enable */
        return 0;

    if(size == 0)
        return 0;

    if(scr->dev && scr->dev->linear){
        scr->dev->linear(scr, size, align);
        return 0;
    }

    /*
     * Need to allocate some physical address space.
     * The driver will tell the card to use it.
     */
    size = PGROUND(size);
    scr->paddr = upaalloc(size, align);
    if(scr->paddr == 0)
        return -1;
    scr->vaddr = vmap(scr->paddr, size);
    if(scr->vaddr == nil)
        return -1;
    scr->apsize = size;

    return 0;
}
@



%/*  
%case CMmemset:
%    memset((void*)strtoul(cb->f[1], 0, 0), atoi(cb->f[2]), atoi(cb->f[3]));
%    return;
%*/


<<global panning(x86)>>=
bool panning = false;
@
% try? 

<<[[vgactl]] cases(x86)>>=
case CMpanning:
    if(strcmp(cb->f[1], "on") == 0){
        if(scr == nil || scr->cur == nil)
            error("set screen first");
        if(!scr->cur->doespanning)
            error("panning not supported");
        gscreen->clipr = gscreen->r;
        panning = true;
    }
    else if(strcmp(cb->f[1], "off") == 0){
        gscreen->clipr = physgscreenr;
        panning = false;
    }else
        break;
    return;
@


<<[[vgactl]] cases(x86)>>=
case CMhwaccel:
    if(strcmp(cb->f[1], "on") == 0)
        hwaccel = 1;
    else if(strcmp(cb->f[1], "off") == 0)
        hwaccel = 0;
    else
        break;
    return;
@


<<[[vgactl]] cases(x86)>>=
case CMtextmode:
    screeninit();
    return;
@
% screeninit() is in kernel.nw, and essentially does
% screenputs = cgascreenputs;





<<global Enooverlay(x86)>>=
char Enooverlay[] = "No overlay support";
@

<<function vgawrite(x86)>>=
static long
vgawrite(Chan* c, void* a, long n, vlong off)
{
    ulong offset = off;
    Cmdbuf *cb;
    VGAscr *scr;

    switch((ulong)c->qid.path){

    case Qdir:
        error(Eperm);

    case Qvgactl:
        if(offset || n >= READSTR)
            error(Ebadarg);
        cb = parsecmd(a, n);
        if(waserror()){
            free(cb);
            nexterror();
        }
        vgactl(cb);
        poperror();
        free(cb);
        return n;

    case Qvgaovl:
        scr = &vgascreen;
        if (scr->dev == nil || scr->dev->ovlwrite == nil) {
            error(Enooverlay);
            break;
        }
        return scr->dev->ovlwrite(scr, a, n, off);

    case Qvgaovlctl:
        scr = &vgascreen;
        if (scr->dev == nil || scr->dev->ovlctl == nil) {
            error(Enooverlay);
            break;
        }
        scr->dev->ovlctl(scr, c, a, n);
        return n;

    default:
        error(Egreg);
        break;
    }

    return 0;
}
@


\section{VGA linear addressing}

% used?

<<function vgalinearpciid(x86)>>=
void
vgalinearpciid(VGAscr *scr, int vid, int did)
{
    Pcidev *p;

    p = nil;
    while((p = pcimatch(p, vid, 0)) != nil){
        if(p->ccrb != 3)    /* video card */
            continue;
        if(did != 0 && p->did != did)
            continue;
        break;
    }
    if(p == nil)
        error("pci video card not found");

    scr->pci = p;
    vgalinearpci(scr);
}
@

% vgalinearpciid -> <>
<<function vgalinearpci(x86)>>=
void
vgalinearpci(VGAscr *scr)
{
    ulong paddr;
    int i, size, best;
    Pcidev *p;
    
    p = scr->pci;
    if(p == nil)
        return;

    /*
     * Scan for largest memory region on card.
     * Some S3 cards (e.g. Savage) have enormous
     * mmio regions (but even larger frame buffers).
     * Some 3dfx cards (e.g., Voodoo3) have mmio
     * buffers the same size as the frame buffer,
     * but only the frame buffer is marked as
     * prefetchable (bar&8).  If a card doesn't fit
     * into these heuristics, its driver will have to
     * call vgalinearaddr directly.
     */
    best = -1;
    for(i=0; i<nelem(p->mem); i++){
        if(p->mem[i].bar&1) /* not memory */
            continue;
        if(p->mem[i].size < 640*480)    /* not big enough */
            continue;
        if(best==-1 
        || p->mem[i].size > p->mem[best].size 
        || (p->mem[i].size == p->mem[best].size 
          && (p->mem[i].bar&8)
          && !(p->mem[best].bar&8)))
            best = i;
    }
    if(best >= 0){
        paddr = p->mem[best].bar & ~0x0F;
        size = p->mem[best].size;
        vgalinearaddr(scr, paddr, size);
        return;
    }
    error("no video memory found on pci card");
}
@


% vgalinearpci | vesalinear -> <>
<<function vgalinearaddr(x86)>>=
void
vgalinearaddr(VGAscr *scr, ulong paddr, int size)
{
    int x, nsize;
    ulong npaddr;

    /*
     * new approach.  instead of trying to resize this
     * later, let's assume that we can just allocate the
     * entire window to start with.
     */

    if(scr->paddr == paddr && size <= scr->apsize)
        return;

    if(scr->paddr){
        /*
         * could call vunmap and vmap,
         * but worried about dangling pointers in devdraw
         */
        error("cannot grow vga frame buffer");
    }
    
    /* round to page boundary, just in case */
    x = paddr&(BY2PG-1);
    npaddr = paddr-x;
    nsize = PGROUND(size+x);

    /*
     * Don't bother trying to map more than 4000x4000x32 = 64MB.
     * We only have a 256MB window.
     */
    if(nsize > 64*MB)
        nsize = 64*MB;
    scr->vaddr = vmap(npaddr, nsize);
    if(scr->vaddr == 0)
        error("cannot allocate vga frame buffer");
    scr->vaddr = (char*)scr->vaddr+x;
    scr->paddr = paddr;
    scr->apsize = nsize;
    /* let mtrr harmlessly fail on old CPUs, e.g., P54C */
    if(!waserror()){
        //mtrr(npaddr, nsize, "wc"); disabled mtrr
                error("mtrr disabled");
        poperror();
    }
}
@


\section{Cirrus logic 5446}

% A classic car, I even got it I think :)

<<global vgaclgd542xdev(x86)>>=
VGAdev vgaclgd542xdev = {
    .name = "clgd542x",

    .enable = nil,
    .disable = nil,
    .page = clgd542xpage,
    .linear = clgd542xlinear,
};
@



\subsection{Page}

<<function clgd542xpage(x86)>>=
static void
clgd542xpage(VGAscr* scr, int page)
{
    lock(&scr->devlock);
    clgd542xpageset(scr, page);
    unlock(&scr->devlock);
}
@

<<function clgd542xpageset(x86)>>=
static int
clgd542xpageset(VGAscr*, int page)
{
    uchar gr09;
    int opage;
    
    if(vgaxi(Seqx, 0x07) & 0xF0)
        page = 0;
    gr09 = vgaxi(Grx, 0x09);
    if(vgaxi(Grx, 0x0B) & 0x20){
        vgaxo(Grx, 0x09, page<<2);
        opage = gr09>>2;
    }
    else{
        vgaxo(Grx, 0x09, page<<4);
        opage = gr09>>4;
    }

    return opage;
}
@



\subsection{Linear mode}

<<function clgd542xlinear(x86)>>=
static void
clgd542xlinear(VGAscr* scr, int, int)
{
    vgalinearpciid(scr, 0x1013, 0);
}
@


\subsection{Cursor}

<<global vgaclgd542xcur(x86)>>=
VGAcur vgaclgd542xcur = {
    .name = "clgd542xhwgc",

    .enable = clgd542xenable,
    .disable = clgd542xdisable,
    .load = clgd542xload,
    .move = clgd542xmove,
};
@


<<function clgd542xenable(x86)>>=
static void
clgd542xenable(VGAscr* scr)
{
    uchar sr12;
    int mem, x;
 
    /*
     * Disable the cursor.
     */
    sr12 = vgaxi(Seqx, 0x12);
    vgaxo(Seqx, 0x12, sr12 & ~0x01);

    /*
     * Cursor colours.
     * Can't call setcolor here as cursor is already locked.
     */
    vgaxo(Seqx, 0x12, sr12|0x02);
    vgao(PaddrW, 0x00);
    vgao(Pdata, Pwhite);
    vgao(Pdata, Pwhite);
    vgao(Pdata, Pwhite);
    vgao(PaddrW, 0x0F);
    vgao(Pdata, Pblack);
    vgao(Pdata, Pblack);
    vgao(Pdata, Pblack);
    vgaxo(Seqx, 0x12, sr12);

    mem = 0;
    switch(vgaxi(Crtx, 0x27) & ~0x03){

    case 0x88:              /* CL-GD5420 */
    case 0x8C:              /* CL-GD5422 */
    case 0x94:              /* CL-GD5424 */
    case 0x80:              /* CL-GD5425 */
    case 0x90:              /* CL-GD5426 */
    case 0x98:              /* CL-GD5427 */
    case 0x9C:              /* CL-GD5429 */
        /*
         * The BIOS leaves the memory size in Seq0A, bits 4 and 3.
         * See Technical Reference Manual Appendix E1, Section 1.3.2.
         *
         * The storage area for the 64x64 cursors is the last 16Kb of
         * display memory.
         */
        mem = (vgaxi(Seqx, 0x0A)>>3) & 0x03;
        break;

    case 0xA0:              /* CL-GD5430 */
    case 0xA8:              /* CL-GD5434 */
    case 0xAC:              /* CL-GD5436 */
    case 0xB8:              /* CL-GD5446 */
    case 0x30:              /* CL-GD7543 */
        /*
         * Attempt to intuit the memory size from the DRAM control
         * register. Minimum is 512KB.
         * If DRAM bank switching is on then there's double.
         */
        x = vgaxi(Seqx, 0x0F);
        mem = (x>>3) & 0x03;
        if(x & 0x80)
            mem++;
        break;

    case 0xBC:              /* CL-GD5480 */
        mem = 2;            /* 1024 = 256<<2 */
        x = vgaxi(Seqx, 0x0F);
        if((x & 0x18) == 0x18){
            mem <<= 1;      /* 2048 = 256<<3 */
            if(x & 0x80)
                mem <<= 2;  /* 2048 = 256<<4 */
        }
        if(vgaxi(Seqx, 0x17) & 0x80)
            mem <<= 1;
        break;

    default:                /* uh, ah dunno */
        break;
    }
    scr->storage = ((256<<mem)-16)*1024;

    /*
     * Set the current cursor to index 0
     * and turn the 64x64 cursor on.
     */
    vgaxo(Seqx, 0x13, 0);
    vgaxo(Seqx, 0x12, sr12|0x05);
}
@
% >> >> >> >> >> >> >>


<<function clgd542xdisable(x86)>>=
static void
clgd542xdisable(VGAscr*)
{
    uchar sr12;

    sr12 = vgaxi(Seqx, 0x12);
    vgaxo(Seqx, 0x12, sr12 & ~0x01);
}
@


% xxxload | xxxmove -> <>
<<function clgd542xinitcursor(x86)>>=
static void
clgd542xinitcursor(VGAscr* scr, int xo, int yo, int index)
{
    uchar *p, seq07;
    uint p0, p1;
    int opage, x, y;

    /*
     * Is linear addressing turned on? This will determine
     * how we access the cursor storage.
     */
    seq07 = vgaxi(Seqx, 0x07);
    opage = 0;
    p = scr->vaddr;
    if(!(seq07 & 0xF0)){
        lock(&scr->devlock);
        opage = clgd542xpageset(scr, scr->storage>>16);
        p += (scr->storage & 0xFFFF);
    }
    else
        p += scr->storage;
    p += index*1024;

    for(y = yo; y < 16; y++){
        p0 = scr->set[2*y];
        p1 = scr->set[2*y+1];
        if(xo){
            p0 = (p0<<xo)|(p1>>(8-xo));
            p1 <<= xo;
        }
        *p++ = p0;
        *p++ = p1;

        for(x = 16; x < 64; x += 8)
            *p++ = 0x00;

        p0 = scr->clr[2*y]|scr->set[2*y];
        p1 = scr->clr[2*y+1]|scr->set[2*y+1];
        if(xo){
            p0 = (p0<<xo)|(p1>>(8-xo));
            p1 <<= xo;
        }
        *p++ = p0;
        *p++ = p1;

        for(x = 16; x < 64; x += 8)
            *p++ = 0x00;
    }
    while(y < 64+yo){
        for(x = 0; x < 64; x += 8){
            *p++ = 0x00;
            *p++ = 0x00;
        }
        y++;
    }

    if(!(seq07 & 0xF0)){
        clgd542xpageset(scr, opage);
        unlock(&scr->devlock);
    }
}
@


<<function clgd542xmove(x86)>>=
static int
clgd542xmove(VGAscr* scr, Point p)
{
    int index, x, xo, y, yo;

    index = 0;
    if((x = p.x+scr->offset.x) < 0){
        xo = -x;
        x = 0;
    }
    else
        xo = 0;
    if((y = p.y+scr->offset.y) < 0){
        yo = -y;
        y = 0;
    }
    else
        yo = 0;

    if(xo || yo){
        clgd542xinitcursor(scr, xo, yo, 1);
        index = 1;
    }
    vgaxo(Seqx, 0x13, index<<2);
    
    vgaxo(Seqx, 0x10|((x & 0x07)<<5), (x>>3) & 0xFF);
    vgaxo(Seqx, 0x11|((y & 0x07)<<5), (y>>3) & 0xFF);

    return 0;
}
@


<<function clgd542xload(x86)>>=
static void
clgd542xload(VGAscr* scr, Cursor* curs)
{
    uchar sr12;

    /*
     * Disable the cursor.
     */
    sr12 = vgaxi(Seqx, 0x12);
    vgaxo(Seqx, 0x12, sr12 & ~0x01);

    memmove(&scr->Cursor, curs, sizeof(Cursor));
    clgd542xinitcursor(scr, 0, 0, 0);

    /*
     * Enable the cursor.
     */
    vgaxo(Seqx, 0x13, 0);
    vgaxo(Seqx, 0x12, sr12|0x05);
}
@



\chapter{Mathematics}

\section{Trigonometric functions}

<<global sinus>>=
/*
 * Integer sine and cosine for integral degree argument.
 * Tables computed by (sin,cos)(PI*d/180).
 */
static short sinus[91] = {
    0,	/* 0 */
    18,	/* 1 */
    36,	/* 2 */
    54,	/* 3 */
    71,	/* 4 */
    89,	/* 5 */
    107,	/* 6 */
    125,	/* 7 */
    143,	/* 8 */
    160,	/* 9 */
    178,	/* 10 */
    195,	/* 11 */
    213,	/* 12 */
    230,	/* 13 */
    248,	/* 14 */
    265,	/* 15 */
    282,	/* 16 */
    299,	/* 17 */
    316,	/* 18 */
    333,	/* 19 */
    350,	/* 20 */
    367,	/* 21 */
    384,	/* 22 */
    400,	/* 23 */
    416,	/* 24 */
    433,	/* 25 */
    449,	/* 26 */
    465,	/* 27 */
    481,	/* 28 */
    496,	/* 29 */
    512,	/* 30 */
    527,	/* 31 */
    543,	/* 32 */
    558,	/* 33 */
    573,	/* 34 */
    587,	/* 35 */
    602,	/* 36 */
    616,	/* 37 */
    630,	/* 38 */
    644,	/* 39 */
    658,	/* 40 */
    672,	/* 41 */
    685,	/* 42 */
    698,	/* 43 */
    711,	/* 44 */
    724,	/* 45 */
    737,	/* 46 */
    749,	/* 47 */
    761,	/* 48 */
    773,	/* 49 */
    784,	/* 50 */
    796,	/* 51 */
    807,	/* 52 */
    818,	/* 53 */
    828,	/* 54 */
    839,	/* 55 */
    849,	/* 56 */
    859,	/* 57 */
    868,	/* 58 */
    878,	/* 59 */
    887,	/* 60 */
    896,	/* 61 */
    904,	/* 62 */
    912,	/* 63 */
    920,	/* 64 */
    928,	/* 65 */
    935,	/* 66 */
    943,	/* 67 */
    949,	/* 68 */
    956,	/* 69 */
    962,	/* 70 */
    968,	/* 71 */
    974,	/* 72 */
    979,	/* 73 */
    984,	/* 74 */
    989,	/* 75 */
    994,	/* 76 */
    998,	/* 77 */
    1002,	/* 78 */
    1005,	/* 79 */
    1008,	/* 80 */
    1011,	/* 81 */
    1014,	/* 82 */
    1016,	/* 83 */
    1018,	/* 84 */
    1020,	/* 85 */
    1022,	/* 86 */
    1023,	/* 87 */
    1023,	/* 88 */
    1024,	/* 89 */
    1024,	/* 90 */
};
@

<<function icossin>>=
void
icossin(int deg, int *cosp, int *sinp)
{
    int sinsign, cossign;
    short *stp, *ctp;

    deg %= 360;
    if(deg < 0)
        deg += 360;
    sinsign = 1;
    cossign = 1;
    stp = 0;
    ctp = 0;
    switch(deg/90){
    case 2:
        sinsign = -1;
        cossign = -1;
        deg -= 180;
        /* fall through */
    case 0:
        stp = &sinus[deg];
        ctp = &sinus[90-deg];
        break;
    case 3:
        sinsign = -1;
        cossign = -1;
        deg -= 180;
        /* fall through */
    case 1:
        deg = 180-deg;
        cossign = -cossign;
        stp = &sinus[deg];
        ctp = &sinus[90-deg];
        break;
    }
    *sinp = sinsign*stp[0];
    *cosp = cossign*ctp[0];
}
@



<<global sinus (lib_graphics/libdraw/icossin2.c)>>=
/*
 * Sine and Cosine of arctangents, calculated by 
 *   (sin(atan(index/100.0))*1024.+0.5)
 *   (cos(atan(index/100.0))*1024.+0.5)
 * To use, get rational tangent between 0<=tan<=1, scale by 100,
 * and look up sin and cos, and use linear interpolation.  divide by 1024.
 * Maximum error is 0.0020.  Without linear interpolation, it's 0.010.
 */
static
short sinus[] = {
    0,	/* 0.00 */
    10,	/* 0.01 */
    20,	/* 0.02 */
    31,	/* 0.03 */
    41,	/* 0.04 */
    51,	/* 0.05 */
    61,	/* 0.06 */
    72,	/* 0.07 */
    82,	/* 0.08 */
    92,	/* 0.09 */
    102,	/* 0.10 */
    112,	/* 0.11 */
    122,	/* 0.12 */
    132,	/* 0.13 */
    142,	/* 0.14 */
    152,	/* 0.15 */
    162,	/* 0.16 */
    172,	/* 0.17 */
    181,	/* 0.18 */
    191,	/* 0.19 */
    201,	/* 0.20 */
    210,	/* 0.21 */
    220,	/* 0.22 */
    230,	/* 0.23 */
    239,	/* 0.24 */
    248,	/* 0.25 */
    258,	/* 0.26 */
    267,	/* 0.27 */
    276,	/* 0.28 */
    285,	/* 0.29 */
    294,	/* 0.30 */
    303,	/* 0.31 */
    312,	/* 0.32 */
    321,	/* 0.33 */
    330,	/* 0.34 */
    338,	/* 0.35 */
    347,	/* 0.36 */
    355,	/* 0.37 */
    364,	/* 0.38 */
    372,	/* 0.39 */
    380,	/* 0.40 */
    388,	/* 0.41 */
    397,	/* 0.42 */
    405,	/* 0.43 */
    412,	/* 0.44 */
    420,	/* 0.45 */
    428,	/* 0.46 */
    436,	/* 0.47 */
    443,	/* 0.48 */
    451,	/* 0.49 */
    458,	/* 0.50 */
    465,	/* 0.51 */
    472,	/* 0.52 */
    480,	/* 0.53 */
    487,	/* 0.54 */
    493,	/* 0.55 */
    500,	/* 0.56 */
    507,	/* 0.57 */
    514,	/* 0.58 */
    520,	/* 0.59 */
    527,	/* 0.60 */
    533,	/* 0.61 */
    540,	/* 0.62 */
    546,	/* 0.63 */
    552,	/* 0.64 */
    558,	/* 0.65 */
    564,	/* 0.66 */
    570,	/* 0.67 */
    576,	/* 0.68 */
    582,	/* 0.69 */
    587,	/* 0.70 */
    593,	/* 0.71 */
    598,	/* 0.72 */
    604,	/* 0.73 */
    609,	/* 0.74 */
    614,	/* 0.75 */
    620,	/* 0.76 */
    625,	/* 0.77 */
    630,	/* 0.78 */
    635,	/* 0.79 */
    640,	/* 0.80 */
    645,	/* 0.81 */
    649,	/* 0.82 */
    654,	/* 0.83 */
    659,	/* 0.84 */
    663,	/* 0.85 */
    668,	/* 0.86 */
    672,	/* 0.87 */
    676,	/* 0.88 */
    681,	/* 0.89 */
    685,	/* 0.90 */
    689,	/* 0.91 */
    693,	/* 0.92 */
    697,	/* 0.93 */
    701,	/* 0.94 */
    705,	/* 0.95 */
    709,	/* 0.96 */
    713,	/* 0.97 */
    717,	/* 0.98 */
    720,	/* 0.99 */
    724,	/* 1.00 */
    728,	/* 1.01 */
};
@

<<global cosinus>>=
static
short cosinus[] = {
    1024,	/* 0.00 */
    1024,	/* 0.01 */
    1024,	/* 0.02 */
    1024,	/* 0.03 */
    1023,	/* 0.04 */
    1023,	/* 0.05 */
    1022,	/* 0.06 */
    1022,	/* 0.07 */
    1021,	/* 0.08 */
    1020,	/* 0.09 */
    1019,	/* 0.10 */
    1018,	/* 0.11 */
    1017,	/* 0.12 */
    1015,	/* 0.13 */
    1014,	/* 0.14 */
    1013,	/* 0.15 */
    1011,	/* 0.16 */
    1010,	/* 0.17 */
    1008,	/* 0.18 */
    1006,	/* 0.19 */
    1004,	/* 0.20 */
    1002,	/* 0.21 */
    1000,	/* 0.22 */
    998,	/* 0.23 */
    996,	/* 0.24 */
    993,	/* 0.25 */
    991,	/* 0.26 */
    989,	/* 0.27 */
    986,	/* 0.28 */
    983,	/* 0.29 */
    981,	/* 0.30 */
    978,	/* 0.31 */
    975,	/* 0.32 */
    972,	/* 0.33 */
    969,	/* 0.34 */
    967,	/* 0.35 */
    963,	/* 0.36 */
    960,	/* 0.37 */
    957,	/* 0.38 */
    954,	/* 0.39 */
    951,	/* 0.40 */
    947,	/* 0.41 */
    944,	/* 0.42 */
    941,	/* 0.43 */
    937,	/* 0.44 */
    934,	/* 0.45 */
    930,	/* 0.46 */
    927,	/* 0.47 */
    923,	/* 0.48 */
    920,	/* 0.49 */
    916,	/* 0.50 */
    912,	/* 0.51 */
    909,	/* 0.52 */
    905,	/* 0.53 */
    901,	/* 0.54 */
    897,	/* 0.55 */
    893,	/* 0.56 */
    890,	/* 0.57 */
    886,	/* 0.58 */
    882,	/* 0.59 */
    878,	/* 0.60 */
    874,	/* 0.61 */
    870,	/* 0.62 */
    866,	/* 0.63 */
    862,	/* 0.64 */
    859,	/* 0.65 */
    855,	/* 0.66 */
    851,	/* 0.67 */
    847,	/* 0.68 */
    843,	/* 0.69 */
    839,	/* 0.70 */
    835,	/* 0.71 */
    831,	/* 0.72 */
    827,	/* 0.73 */
    823,	/* 0.74 */
    819,	/* 0.75 */
    815,	/* 0.76 */
    811,	/* 0.77 */
    807,	/* 0.78 */
    804,	/* 0.79 */
    800,	/* 0.80 */
    796,	/* 0.81 */
    792,	/* 0.82 */
    788,	/* 0.83 */
    784,	/* 0.84 */
    780,	/* 0.85 */
    776,	/* 0.86 */
    773,	/* 0.87 */
    769,	/* 0.88 */
    765,	/* 0.89 */
    761,	/* 0.90 */
    757,	/* 0.91 */
    754,	/* 0.92 */
    750,	/* 0.93 */
    746,	/* 0.94 */
    742,	/* 0.95 */
    739,	/* 0.96 */
    735,	/* 0.97 */
    731,	/* 0.98 */
    728,	/* 0.99 */
    724,	/* 1.00 */
    720,	/* 1.01 */
};
@

<<function icossin2>>=
void
icossin2(int x, int y, int *cosp, int *sinp)
{
    int sinsign, cossign, tan, tan10, rem;
    short *stp, *ctp;

    if(x == 0){
        if(y >= 0)
            *sinp = ICOSSCALE, *cosp = 0;
        else
            *sinp = -ICOSSCALE, *cosp = 0;
        return;
    }
    sinsign = cossign = 1;
    if(x < 0){
        cossign = -1;
        x = -x;
    }
    if(y < 0){
        sinsign = -1;
        y = -y;
    }
    if(y > x){
        tan = 1000*x/y;
        tan10 = tan/10;
        stp = &cosinus[tan10];
        ctp = &sinus[tan10];
    }else{
        tan = 1000*y/x;
        tan10 = tan/10;
        stp = &sinus[tan10];
        ctp = &cosinus[tan10];
    }
    rem = tan-(tan10*10);
    *sinp = sinsign*(stp[0]+(stp[1]-stp[0])*rem/10);
    *cosp = cossign*(ctp[0]+(ctp[1]-ctp[0])*rem/10);
}
@


\chapter{Utilities}

% lens? illustrate well features?
% faces.c? 

% both are mentioned in Unix Readers as very early graphic programs.

\chapter{Extra Code}

\ifallcode
#include "Graphics_extra.nw"
\fi

%\chapter{Changelog}
%\label{sec:changelog}
% code via make loc = ? LOC
% orig nw = ???, just lpized and few comments, ??? pages pdf
% now: ? LOC ? pages, so added ?? LOE (Lines of explanations)


\chapter*{Glossary}
\addcontentsline{toc}{chapter}{Glossary}
\label{sec:glossary}

\begin{verbatim}
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{chapter}{Index}

%\chapter{References} 
\addcontentsline{toc}{chapter}{References}

\bibliography{../docs/latex/Principia}
\bibliographystyle{plain}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
