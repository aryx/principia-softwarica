\documentclass[twocolumn, landscape]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse % see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, I changed for the better a few things:
% - removed deadcode (Displaybufsize, drawbuf/ndrawbuf, Display.dataqid,
%    Display.isnew (many stuff), Memdata.imref, convxx[], fillxxx(), mkfont(),
%    openmemsubfont(), stringsubfont(), ... 
%    and more (see the %dead in this file)
% - screen.h cleaner interface (taking as inspiration the raspberry plan9 code)
% - renamed some globals (screen -> view, _screen -> screen TODO desktop)
%   TODO gscreen, screenimage, vgascr, so easier to see associated part
%   TODO or merge globals (screenimage and gscreen, can?)
% - TODO transformed globals in locals (softscreen)
% - reorganized a lot the files; I merged many small files in bigger one
%   (e.g., libdraw/subfont.c), or split in different files to better
%   separate concerns (e.g., draw.h in window.h and font.h and draw_private.h)

%thx to codemap/codegraph/scheck:
% - SEMI use cg to reduce backward deps, introduce globals.c, utils.c,
%   (harder to understand non layered code)
% - TODO use scheck to remove deadcode, dead prototypes, useless export
%   or mv as forward decl
%   (harder to understand big interface files)
% - TODO use cg to reduce number of globals by moving them closer to the
%   relevant file (or even function), better cluster the code
%   (harder to understand non functional code using lots of globals)

%thx to this manual, I better understand:
%  - graphics terminology (I didn't take the Image option at INSA)
%  - graphics history, with Postscript, PDF, Display Postscript, Cairo, Xlib
%  - raster vs vector graphics, discrete pixels vs continuous geometry shapes
%  - bitblt(), which I often heard of but never really understood what it was
%  - channels are the size spec for the different pixel components
%    and the source of many pixel formats
%  - alpha channel is a way to encode transparency strength for compositing
%    operations at a pixel granularity (very flexible)
%  - TODO pre-alpha vs post-alpha?
%  - clipping is to restrict operations on a rectangle
%  - tiling is replicating a simple pattern repeatidely
%  - antialiasing is just a simple way to remove effect d'escalier by setting
%    the lightness of a pixel to be function of its distance to the ideal point,
%    so clearer text at the cost of slight blur
%  - SEMI scanline algorithm for polygons (subtle)
%  - TODO Bezier (could be useful for edge bundling visual in codemap?)
%    that they are the essence of vectoriel fonts.
%  - TODO understand freshrate, double buffer, vertical sync, flickering,
%    refresh sync
%  - need for a painting-like algorithm for overlapping windows, as they
%    overlap and have stuff in front and back, or a more optimized variant
%    where use save image and tricky RECURS
%  - svgalib? tronscroll:) mode X?
%  - True Color, True Type

%history LP-ization:
% - skeleton, mostly copy paste of Template.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(function)
%    * TODO ctor/dtor, dumper
%    * [[xxx]] other fields, [[xxx]] extra fields
% - read Extra section, identify concepts, first TOC
% - distribute parts of the Extra section in the main file
% - understand main(), LP split main, improve TOC
% - understand main functions, LP split, cluster, improve TOC
% - LP split the structures (optionally use datalog for flow to field info)
% - nullify, boolify, errorify, enumify,  typeify,    scheckify, plan9ify
% - aspecify advanced features! remove useless features
% - SEMI add figures
% - SEMI add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% ifallcode is used for:
%  - forward decl, func decl, extern decl, #ifdef, pragmas (stuff in Extra.nw)


\setcounter{tocdepth}{2}

\addtolength{\topmargin}{-.850in}
\addtolength{\textheight}{1.70in}

\begin{document}
%******************************************************************************
% Title
%******************************************************************************
\title{
{\Huge 
Principia Softwarica: The Plan~9 Graphics System [[draw]]
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}\\
\\
with code from\\
Rob Pike and Russ Cox
}
% Looks like Pike did Blit a long time ago and Russ added support for colors.
% And Tom Duff? (from Porter/Duff)

\maketitle 

\onecolumn
\hrule
\input{../docs/latex/Copyright}
\input{../docs/latex/CopyrightPlan9}
\hrule
\twocolumn

\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\tableofcontents
\endgroup

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

The goal of this book is to present with full details the source code of
a {graphics system}.

\section{Motivations}

Why a graphics system? 
Because I think you are a better programmer if
you fully understand how things work under the hood, and
with so many fancy graphics on your screen, there are plenty
of things happening under the hood to understand.


\n Definition. Could be in Principles, but better def now as GS is a bit vague.
A {graphics system} provides essentially an
application programming interface (API) to draw things:
lines, rectangles, circles, text, etc.
It can also mediate access to a shared resource: the {screen}.
\l 'can mediate' cos not always; more role of windowing system in the end.
\l also a bit to give access to the mouse and raw keyboard (mouse.h, keyboard.h)
%
Graphics systems are usually coupled with a {windowing system}
to form a {graphical user interface} (GUI).
\l hmm actually can have a GUI without a windowing system
%history:
GUIs, introduced in the 1970's with the Xerox Alto~\cite{alto},
were a vast improvement over {text-based} user interfaces, to
the point where every mainstream operating systems now come with a GUI
(e.g., Microsoft Windows, macOS and iOS, Linux with X Window, or Android).



Graphics systems are usually implemented by a combination of hardware 
and software. In fact, modern graphics systems rely more and more on
specialized hardware, especially for {3D operations}.
\n I assume you know what 3D/2D means
%
However, in this book, I will cover only {2D operations}, implemented mostly
in software. I will assume very little from the graphics hardware.
\n a frame buffer, see also VGA appendix
%
Even though 2D operations are usually covered quickly
in books about computer graphics (e.g.,~\cite{cgpp-foley}),
where the focus is more on 3D and advanced rendering techniques,
the result of simple 2D operations is what most people see
on their screen.
\n STEPS also focused on 2D (they say 2.5D)
%
Indeed, most graphical applications use simple
drawing primitives such as functions to draw
lines, rectangles, or text.
Those primitives are the foundation of even the 
{windowing systems} themselves.
%
Indeed, the \book{Windows}, which covers
the \plan windowing system, relies only on 
the simple functions described in this book.


Here are a few questions I hope this book will answer:
\begin{itemize}

\item Which low-level instructions allow to modify the screen?
\n can relate to Assembler.nw

\item How is the picture on the screen represented in the machine?
What is a {frame buffer}?

\item How do the kernel and graphics system provide and protect access to 
the screen?

\n how to manage multiple processes wanting to access shared resource?
\n  hmm more a windowing system issue than graphic system issue

\item How are images represented in memory? 
How are they stored on the disk? 
What is the format of a JPG file?
\l image vs picture?
\n actually we will see related one, creadimage
\l alok think same than frame buffer, but can be ARGB32 vs RGB24!

\item How are graphical elements such as 
rectangles, 
lines, 
or circles,
rendered on the screen? 
How does the graphics card help? 

\item What is the algorithm to draw arbitrary lines
(non-vertical and non-horizontal lines)
on a rectangular grid of pixels (the screen)?
\n actually we will see fillpolygon

\item How are colors represented in the machine?
What does {True Color} mean?

\item What is the {alpha channel}? 
What is {alpha compositing}? 
%What is {alpha blending}?
\n I dont even know diff between blending and compositing; alok neither.

\item What is the {rasterization} process? 
What is {vector graphics}?

\item How are characters drawn on the screen? 
How {fonts} are managed? 
What are {True Type} fonts? 
\n in fact not implemented by /dev/draw

\item What is {anti-aliasing}?
\n in fact not implemented by /dev/draw
% What is subpixel rendering?

\item How is the mouse cursor handled?
Where are saved the pixels that were under the cursor?
How those pixels are restored on the screen when the mouse moves?
\l which forces us to talk about how mouse is handled

\item How does the introduction of graphics and the mouse change
the programming model of an application?
What are the differences between a command-line application and
a graphical application beyond the obvious? 
%How can a graphical application {react} to a mouse event?
\n reactive model. notification oriented. events vs threads.
\l  not sequential style with input/output. event loop 
\l how to react simultaneously to two input devices, mouse and keyboard?

\end{itemize}
\l how to implement overlapping layers(window)? what is a backing store?
\l how to cooperate with windowing system?
\t how synchro with monitor balayage? glitches? API? how done in Soldat.nw?
\l memory leak with imagmem? or when close fd then freeimage in pool?

%tags used in this file for different recurring themes:
 %history:
 %
 %in-plan9: when in generation section (e.g. principles), instantiate with plan9
 %real-world: to relate to other graphics systems
 %alt: alternative techniques
 %ocaml: to give a hint on how rewriting C in OCaml could improve things
 %old: for original code I changed to be clearer
 %pad: for code I introduced to be clearer
 %dead: dead code removed
 %toc: %trans: %dup: %example: %chunks:



\t put in conclusion non-trivial adv algo and data structures seen? see comment
%data-structures (beyond list/hashtbl):
% - double linked lists (Screen.frontmost and Screen.rearmost)
% - growing array (Kdraw.clients, Font.subf, ...)
% - growing hashtable with buckets inline in array (Font.cache)
%   and lookup with small window when hash conflict (jordan/julien did that
%   for hh_server no?)
% - glyphs pictures and glyphs cache (a bit like sprite cache?)
% - moveable shared area with backward pointer to intermediate wrapper

%algorithms:
% - bitblt()
% - fill polygon, quite complex
% - ellipses, arcs
% - Bezier
% - layerop(), overlapping windows with save and interception and RECURS
% - protocol encoding (a la thrift) to have client/server communication

\section{The \plan{} graphics system:  [[draw]]}

I will explain in this book the code of the \plan graphics system
\footnote{\url{http://plan9.bell-labs.com/magic/man2html/3/draw}},
visible to the user primarily through the [[/dev/draw/]] {device directory},
and to the programmer mostly through the [[draw.h]] header file.
\n also memdraw.h and memlayer.h, but more internals
%
Because users usually manipulate graphical applications with a {mouse},
I will also cover code related to the [[/dev/mouse]] {device file}
(and the [[mouse.h]] and [[cursor.h]] header files).
\n also a bit [[/dev/cons]] and [[keyboard.h]],  and [[/dev/cursor]]
%
In total, the \plan graphics system, which from now on I will 
call just [[draw]],
\n /dev/draw, draw.h, so seems like a good name
is made of 23~300 lines of code (LOC),
including the code of two device drivers for two traditional graphics cards. 
[[draw]] is written entirely in C.
\l part library, part kernel, part drivers. 
\n LOC includes some tests and apps.
\l portable! x86 and ARM!


%dup: from Assembler.nw
Like for most books in \principia, I chose a \plan program because
those programs are simple, small, elegant, open source, and they form together
a coherent set.
%history:
The ancestor of [[draw]], the graphics system of the Blit machine~\cite{blit},
also designed by Rob Pike, was one of the first graphics systems back in 1982. 
It was created even before the Macintosh, X Window, and Microsoft Windows.
\n comment shows the lineage and dates
% Alto -> Blit (1982, a cheap Alto, Xerox vs Bell Labs) -> .. /dev/draw (1990?)
%  79  |> Lisa (1983) -> Macintosh (1984) -> Microsoft Windows (1985) -> ...
%      |> X Window (1984) (or comes from MIT Lisp Machine?)


[[draw]] services, like many other services in \plan,
are accessible through files. Indeed, [[draw]] is a device
{\em and} a filesystem (see the \book{Kernel} if this sounds confusing).
[[draw]] manages the files under [[/dev/draw/]].
\n actually also /dev/winname
%
Because you can export filesystems through
the network in \plan, [[draw]] is also a 
{networked graphics system}, similar to X Window.
%
Thus, in \plan, programs running on one machine
can even display their results on another machine.
\l powerful! like browser! remote for free

%dup: (and changed, not-coupled) intro/motivations
In \plan, as opposed to X Window, the graphics system
and windowing system are clearly separated. 
You can use graphical applications without a windowing system running.
%
%[[draw]] provides some forms of {window management}, for instance, by giving
%the ability for applications to create {overlapping windows}, but
\l overlapping layers (similar to windows)
\l and backing store, and menus
%this is only one of the building blocks necessary to get a windowing system.
The code of the \plan windowing system, called [[rio]],
will be explained in another book (the \book{Windows}).

\l bad stuff of draw though: most of the code is in the kernel :(
% but lots of stuff can be in library and can be tested outside
% (see memdrawtest), but still a bit ugly. The images, fonts,
% reside in special kernel memory (imagmem).
% Note though that putting stuff in kernel is trendy with DRM/Xorg/wayland 
% in Linux.

\l just 2D, no 3D, mostly in software, almost no hardware acceleration, no GPU
\l no scale/rotate/translate as in cairo, so no text in diagonal, no codemap
\l No true type fonts. No subpixel rendering. No anti-aliasing.

\n there is also a draw in plan9port written by Russ Cox called drawterm,
\n  ported to many systems, including X Window! can be nice to compare the API

%pro:
% Still relevant. Model used in Go for image drawing library!
% So power some Google internal tools probably! Profiling visualization tools?
% Also source of inspiration of Cairo (cite papers by Packard who reference
% draw).

\section{Other graphics systems}

Here are a few graphics systems that I considered for this book,
but which I ultimately discarded:
\begin{itemize}

\item Xorg~\furl{http://www.x.org} is the most popular open-source
implementation of the X Window System~\cite{x-window},
a graphics system (and a windowing system) designed in the 1980's at MIT.
%
It is used by all Linux distributions and has even been ported
to other operating systems such as macOS and Microsoft Windows.
\n before was Xfree86 but now dead. Xquartz/Xwin now merged in Xorg.
%
X Window defines a protocol, X11, for
a networked client/server architecture. Clients using
a set of libraries (e.g., Xlib) communicate with
a {display server} ([[Xorg]]) to render graphics.
\n actually similar archi in plan9, but shorter!
\n now XCB seems to be preferred to Xlib, cairo has backends for Xlib and XCB
%
Xorg supports many graphics cards
(with hardware acceleration), many extensions (e.g., 3D operations), 
and many operating systems.
%
However, its codebase is enormous with more than 1 million LOC,
even when counting just the code of the display server, a few core libraries, 
and a few device drivers.
\n but just xserver/{dix/,fb/,mi/} is about 70 000 LOC though.
\n and xserver/hw/kdrive/fb/ is small, a tiny X server model implementation.

\l known to be hard to understand, many tutorials on the web
\l "why X11 is so big" by Ken Thompson, partly the motivation for plan9

X Window was designed at a time where memory was 
extremely limited, and remote applications were crucial.
\l because had cheap poor graphic terminal connected to big machines
\n nice to have network, I used it at FB with emacs, but big design price to pay
Time has changed,
but this historical baggage means that even the code of simple applications
such as a graphical hello world~\cite{x11-hello-world} is
very long and complicated to write.
\l compare size of draw.h with size of any X11 header ... (or cairo, or pixman)
\l stupid expose callback, should be done by display server!
%
Some programmers wrote {toolkits} such as 
Gtk\furl{http://www.gtk.org/} or 
Qt\furl{https://www.qt.io/}
\n Xaw, Xt, FLTK, WxWindows, ...
to simplify things,
but those toolkits add another layer of complexity on something that 
is already very complicated.
%
\t imaging model a bit old, so sometimes it's just a glorified pixmal
\t  compositor. People use cairo and send just bitmap (with Xrender).
\l also drawing API in Xlib is poor. No transluscence, no compositing.
\l  no modern effects such as shadows, so many programs actually resort
\l  to external lib (e.g., cairo) and send simply bitmap to X (using X Render).
\n X Render by Keith packard was inspired by plan9 draw and rio
%dup: (and adapted) intro/motivations intro/draw
Finally, the graphics and windowing system parts of Xorg are {strongly} coupled;
this coupling makes the whole system harder to understand than [[draw]]
and [[rio]], which we can study separately.
\l x86 specific? X on Raspberry Pi?


\item Ghostscript\furl{http://www.ghostscript.com/} is an 
open source interpreter for Postscript, 
\l \cite maybe
a graphics language invented by Adobe and used initially in printers.
\n by people who worked before with Sutherland and later at Xerox
\n Page Description Language (PDL), Printer Control Language (PCL)
Postscript was a very influential programming language; most graphics API
today use it as a model.
\l seminal one? idea of Context? Stroke? of rotation/scale of everything(text!)
\l processing.org is a successor of that tradition?
%
\l Ghostscript not full graphics system.
However, Ghostscript is a large program, with more than 750~000 LOC.
\n not counting external dependencies, libpng, etc
\n xpost is 30~000 LOC but not complete

Note that a few graphics systems, for instance, Display Postscript (DPS) 
in the NeXT computer, or the NeWS windowing system~\cite{news-book} from Sun,
were based on Postscript and embedded a Postscript interpreter
to render graphics on the screen.
\l ancestor of Quartz for macOS (Quartz 2D is using PDF model =~ Postscript)
%
One advantage of this approach is that it is easy to print what is on
the screen when the printer also understands Postscript;
the same code can be used. Moreover,
what is printed will match exactly what is on the screen.
%
However, one disadvantage is that you have to use two languages to program a
graphical application: one for the business logic (e.g., C),
and one for the graphics (Postscript).

\t any graphics or fonts at any scale or angle (like cairo later)


\item Cairo~\furl{http://cairographics.org/} is a 2D
graphics library used in many applications (e.g., Firefox).
\l and libraries (GTK use cairo internally, so all GTK apps use cairo)
\n actually partly grew from X limitations, called Xr. User-space compositing. 
However, it is not a complete graphics system; it relies on
a ``backend'' for the final display.
% =~ Postscript + Compositing extensions (=~ PDF 1.4 model) in C, EDSL
%
It is relatively large with its 235~000 LOC 
(350~000 LOC with the tests and benchmark code),
\n originally in Xr paper it was just 7000 LOC (libtwin is small still)
but supports many drawing primitives
and many backends (e.g., X Window via Xlib, macOS via Quartz 2D).
\l can leverage hardware acceleration e.g., XRender, send directly pixmaps
\l actually use 3d hardware to optimize also 2d operations! see siggraph paper
\l win32, opengl, directFB, DRM, even now SKIA
Cairo can also generate directly graphic files with backends for
Postscript, PDF, SVG, PNG, etc.
%
In Cairo, all drawing operations are expressed in float coordinates, not pixels,
and can be transformed by any affine transformations
(rotation, scaling, translation), which is very flexible.
\t for instance can draw fonts in any orientation (also any scale)
\t more device independent because of float. but postscipt had that already?
\t  so Cairo is really Postscript spirit but as a lib, not a language.
\l openGL has also that (/dev/draw nope but could have higher-level lib with it)
\l for instance can draw Hello in diagonal in any size (and scalable fonts)
\l let the computation be done by the library! simplify user code, can do
\l  very fancy things with rotate/scale/translate (a la Postscript).

\l maybe API simpler than the one of plan9. I get confused with the 
\l complex parameters of draw(), the rectangles and point and clipping.
\l pen-based drawing model. Also PDF 1.4 imaging model.

\l toy text API, so need add Pango, freetype, fontconfig. => additional LOC!
\l  but text API in draw is alsi limited; I can't even do codemap with draw.
\n nice is cairo/BIBLIOGRAPHY file

Note that both Cairo and Xorg rely on the Pixman 
library~\furl{http://www.pixman.org/}
for low-level pixel manipulation and compositing. 
This library adds another 50~000 LOC.


\item Skia~\furl{https://skia.org/} is a 2D graphics library
developed by Google that is similar to Cairo.
\n written in C plus plus
It is the graphics engine of Android and Chrome.
It is also large: 485~000 LOC (without the tests).
\l anti-aliasing, subpixel text (for LCD), shaders, ... gpu/ is big
\n http://www.slideshare.net/SamsungOSG/duel-of-two-libraries-cairo-skia (ok)


\item Mesa~\furl{http://www.mesa3d.org/} is a 3D graphics library
implementing the OpenGL (Open Graphics Library)
specification. OpenGL is a standard API for rendering 2D
and 3D vector graphics.
\l also stateful, similar to Postscript/Cairo
Mesa contains a few software-based
renderers, as well as drivers supporting hardware-accelerated
operations for many graphics cards.
However, its codebase is enormous with more than 1.6 million LOC.

Mesa in some sense is more general than Cairo, Skia, or [[draw]]. Indeed,
if a function can draw a line in 3D, the same function can
be used to draw a line in 2D. However, the algorithms and geometry involved
are far more complicated to explain.
\l but being more general is better? learn once and apply for many things?
%dup: (but changed) intro/motivation
In practice, the graphics used in most applications
are 2D graphics, except for some video games and CAD software,
which is why I decided to focus on 2D graphics in this book.
%
Moreover, OpenGL does not have a good API to draw text
on the screen, even though text is fundamental, 
even in graphical applications.
\n has gouraud shading, phong?, textures, 3d rasterizer, ...
\l not good story for window integration too, and menu, and key/mouse
\l opengl and glut. the menuhit function is kinda related to glut.

\l DRM in Linux. But very low level. Not really drawing API, just
\l  an interface for mode settings and shared buffer, so need
\l  cairo to make a complete graphics system.
\l  Linux graphic archi is now super complicated: 
\l   (DRM (and GEM, KMS), DRI (in X11), fbdev, EGL?, GGI?, etc)
\l  and also just a buffer compositor, it assumes clients use cairo or openGL
\l  it just composes a set of pixmaps.
%  
%http://blog.mecheye.net/2012/06/the-linux-graphics-stack/ (very good)
%http://blogs.igalia.com/itoral/2014/07/29/a-brief-introduction-to-the-linux-graphics-stack/

%\item Mini-X was a graphics system for MINIX modeled after X Window.
\n Mini-X, Minix :)
% A library. No display server so limited to single application.
% Can have multiple windows, line in draw, but only one app. 
% So no windowing system like Xorg (or rio and draw).
% Small 10 000 LOC, but quite limited, and dead.
\n The README says that they dont support multiple clients.
\n alive through Nano-X, a full graphics and windowing system. See Windows.nw
% http://members.canb.auug.org.au/~dbell/ (but no mini-X link)

%\item TWIN, the Tiny Window system, is, despite its name,
%just a graphics system for small devices.
% designed for sub-PDAs, e.g. watch!
% used by petitboot
% by main contributor to X, Keith Packard. Many extensions XRender.
% itself took inspiration from draw!
% TWIN start from scratch. 
% took rio as a model, again! 
% includes also some widgets, 
% 12 KLOC, so very small, with quite fancy graphics system!
% but unmaintained.
% small, also cos does not support every image format. just
% ARGB32, RGB8?, and?
\n No screenshot. Not really maintained. Was even hard to get the source.
\n not to confuse with another Twin window system in text mode, a la curses
% Twin. designed for severly memory constraints systems, sub PDAs.
% Actually not full window system, a graphics system.
% with support for overlapping windows. similar to draw. In fact
% modeled partially after draw.
% In fact not a server but lib so more limited than draw:
% single-client multiple-windows. No protocol.
% Designed by Keith Packard, developer of Xorg, many extensions.
% developer also on Cairo! He is everywhere!
% Advanced graphics: anti aliasing, scalable outline fonts,
% any affine transformation (e.g. rotation of text).
% Also widgets, layout!


\end{itemize}

\n there is a literate award winning book about rendering http://www.pbrt.org/

\l lots of other graphics systems, see the comment in the .nw
%#industry:
% - GDI (quite limited apparently), WPF (Windows Presentation Framework?), 
%   Direct2D (lots of optis), DirectX, etc.
%   (WPF used by 3rd ed of CGPP book which doesn't even discuss scanline algo)
% - QuickDraw (which was apparently very innovative), Quartz 2D (part of 
%   CoreGraphics)
% - PDF, Flash (Adobe did lots of stuff on graphics)
% - SVG, Canvas (Apple again?), ...
%history:
% - Xerox Alto! first bitmap display, bitblt, started in 1973 (-> Smalltalk)
% - Lisp Machine (->? DLisp? Interlisp-D?  
%  -? -> W Window -> X Window
% - Blit (-> draw/rio)
%education:
% - GKS, first graphics standard. But not present in any current system.
%   "OO graphics, from GKS and PHIGS to OO systems"
%   https://books.google.com/books?id=KUWqCAAAQBAJ
% - SRGP (Simple Raster Graphics Package)
%   used in second edition of CGPP book. But actual reference implementation?
%   Seems implemented by some by calling Xlib, Quickdraw, etc.
%   SGP discussed in the first edition of cgpp book
%   and based on siggraph core 1979 standard.
%   SPHIGS was for 3d (Simple PHIGS, where PHIGS was a precursor of openGL).
%mini:
% - mini X, only a graphics system but with overlapped window support a la draw
% - nano X, graphics system and windowing system (it has a window manager)
%   but graphics part is just a fork of mini X
% - Twin by keith packard, 2004, 12 KLOC, supports only A8, RGB16 and ARGB32,
%   says that took as a model porter/duff and [[draw]].
%   Includes also widgets.
% - tinyGL of bellard (openGL in software), 6800 LOC
%   mentions NanoX (mentions also Mesa and copy examples from it and .h)
%other:
% - Squeak on bare-metal?
% - metafont by Knuth
% - gnome libart?
% - nuttx, NX graphics
%   nuttx has some graphic and windowing stack apparently too!
%   http://nuttx.org/doku.php?id=documentation:nxgraphics
% - http://www.helenos.org/doc/theses/pk-thesis.pdf
% - MIR, same goal than wayland but from canonical
% - vg, gg, by daniel bunzli for ocaml: http://erratique.ch/software/gg
% - https://arcan-fe.com/about/ also inspired by plan9
%wrappers:
% - SDL (backends for GDI, DirectX, Quartz, Xlib, OpenGL, EGL)
% - SFML, Allegro, Clanlib, ...
% - ocamlgraphics (cleaner/portable interface on top of X11 or windows graphics)
% - GGI? oldies? wrapper?
% - GDK of GTK is a wrapper too?
%oldies:
% - svgalib
% - old-school style, pc-bible spirit and mode-X:
%   http://www.dustmop.io/blog/2015/12/18/nes-graphics-part-3/
%#research/recent:
%  - Nile/Gezira DSL from vpri, 450 LOC only!! but then need compiler/evaluator
%  - vulkan, sucessor of OpenGL, just got out, but looks far more low-level

%advanced:
% http://www.adriancourreges.com/blog/2015/11/02/gta-v-graphics-study/
% https://engineering.riotgames.com/news/trip-down-lol-graphics-pipeline

\section{Getting started (x86)}
\label{sec:getting-started}

%dup: (and adapted) Assembler.mw
To play with [[draw]], you will first need to install
the \plan fork used in \principia. See \urlinstall.
Once installed, you can test [[draw]] under \plan
on an x86 machine by executing the following commands:

\begin{verbatim}
1   $ bind -a '#v' /dev
2   $ vga -l 640x480x8 
# screen should change layout
3   $ bind -a '#i' /dev

4   $ cd /tests/draw
5   $ 8c hellodraw.c
6   $ 8l hellodraw.8 -o hellowdraw
7   $ ./hellodraw
\end{verbatim}
% x86 for vga part
\l on bcm? needs to do anything? can change to 1024x768x24? instead of 16?
\l use bcm instead? and then 5c, not 8c.

You should then see on your screen
the graphics in Figure~\ref{fig:hellodraw}.

\begin{figure}\begin{center}
\includegraphics[width=8cm]{hellodraw}
\end{center}
\caption{[[hellodraw]] screenshot.}
\label{fig:hellodraw}
\end{figure}
\n no rio; minimal "getting started" spirit!
\t explain QEMU? or remove it!

The command in Line~1, above, installs the VGA\footnote{
VGA (Video Graphics Array) is a graphics standard for x86 machines.
\l more in appendix
}
{device driver},
which exports the VGA {device files} in [[/dev/]] (e.g., [[/dev/vgactl]]).
%
See the \book{Kernel} for more information on how device
drivers work and how to use [[bind]]. You can also read
[[docs/man/3/0intro]] for an introduction to the \plan devices.

Line~2 runs the program [[vga]]. This program internally uses
the [[/dev/vgactl]] device file to instruct the graphics card
to change the {resolution}, here to 640 by 480 with 8 bits
per pixel. The effect of this command will change the layout of the screen,
but you will still be in a {terminal textual mode}.
\n see Section X for graphical text-mode.

Line~3 then installs the [[draw]] device, which
exports the [[draw]] device files in [[/dev]] (e.g., [[/dev/draw/new]]).

Line~5 and Line~6 respectively compiles and links the simple
C program [[hellodraw.c]], which uses functions from [[draw.h]].

Finally, Line~7 executes the program, which will internally
use files under [[dev/draw/]] to create the graphics
shown in Figure~\ref{fig:hellodraw}.


\section{Requirements}

%dup: from Assembler.nw
Because most of this book contains C source code, 
you will need a good knowledge of 
the C programming language~\cite{k-r} to understand it.
%
I also assume you have a basic understanding of geometry and trigonometry.
%
Books on computer graphics such as
{\em Computer Graphics, Principles and Practice}~\cite{cgpp-foley}
\l Principle of Interactive Computer Graphics, Newman and Sproull, McGraw-Hill
% seems seminal book about vector graphics, and source for GKS, in 1979
% (from pike84bitblt.pdf), even cited by Alto paper. But "interactive"?
would be useful, especially for Chapter~\ref{chap:drawing-shapes},
which contains the algorithms do draw shapes (e.g., lines, ellipses).
However, those books are not mandatory; most computer graphics books
focus on 3D, which I do not cover at all.
\n actually CGPP3 does not even cover scanline algo apparently. so sad.
\n CS overview by brookshear covers only 3D.

I strongly suggest reading the \book{Kernel} before reading
this book, especially for Chapter~\ref{chap:user-kernel-bridge},
which describes the user-to-kernel bridge.
Indeed, an important part of [[draw]] resides
in the kernel and implements interfaces such as [[Dev]]
defined by the kernel.
[[draw]] is implemented as a device;
\l and a filesystem
I assume you know what is a {device file} for instance.

\t to as in Windows.nw instead? "If while reading this book you have questions''
It can also be useful to read the many manual pages concerning
[[draw]]. Those pages are located under [[docs/man/]]
in my \plan repository.
Here is a partial list of those pages and a short description
of their content:
\t relevant pages to draw, as in Windows.nw

\begin{itemize}

\item [[2/graphics]]: the big picture (no pun intented)
\t a few changes though, like screen -> view

\item [[2/draw]]: the [[draw.h]] API

\item [[2/memdraw]]: the drawing functions used
in the kernel

\item [[3/draw]]: the [[draw]] {protocol} (supported
by the [[/dev/draw/x/data]] file)
\t can not understand that

\item [[6/image]]: the \plan image format

\end{itemize}
\l plan9 tutorial? shows some use of /dev/draw/?


A few other manual pages concern advanced functionalities
of [[draw]] such as 
the font system (in [[6/font]]),
the mouse (in [[2/mouse]] and [[3/mouse]]), or 
overlapping layers (in [[2/window]]),
but you can read them later.
\n CGPP talks also about windowing system, so graphics system material

%history:
The historical paper~\cite{pike-layers}
describes an ancestor of [[draw]] for the Blit machine.
This article is useful to understand some of the design decisions
presented in this book.
% plan9-in-technicolor.ps? meh.

%Finally, the following web pages describe descendants of [[draw]]:
%\url{http://blog.golang.org/go-imagedraw-package} and
%\url{http://blog.golang.org/go-image-package}.


\section{About this document}
#include "../docs/latex/About.nw"

\section{Copyright}
\input{../docs/latex/CopyrightPlan9Text}

\section{Acknowledgments}

I would like to acknowledge of course the authors of [[draw]]:
Rob Pike and Russ Cox.
They wrote in some sense most of this book.







\chapter{Overview}

%trans: %dup: Assembler.nw
Before showing the source code of [[draw]] in the following chapters, 
%toc:
I first give in this chapter an overview 
of the general principles of a graphics system.
%
I also describe quickly the interface of the
files in [[/dev/draw/]], and 
%
show the code of a toy program using functions from [[draw.h]].
%dup: from Assembler.nw
I also define terms, explain how the code is organized, 
and more generally give the background necessary
to understand the code I will show later.


\section{Graphics system principles}

\l image (photo, raster) vs graphics (line drawings, plot, vector)
\l picture vs screen vs monitor vs display
\l graphics card vs graphics adapter vs GPU

%dup: (and extended) introduction/motivations
As said in the introduction, a {\em graphics system}
provides essentially an {API} to {draw} things on a {screen}:
lines, 
rectangles, 
circles, 
characters, etc.
%
The API usually allows also to draw those graphical elements
with different 
{colors},
{widths},
{fonts}, 
{filling patterns},
{orientations},
etc.
\n orientation, hmm, not so much for text in [[draw]]
%
A {\em screen} is composed of thousands of {picture elements}
called {\em pixels}, which can be individually accessed
programmatically.
%
Instead of the screen, the programmer can also draw
first in off-screen {\em images}, and then copy parts of
those images on the screen.
\l in fact screen is usually considered a special image. so in the rest
\l  will use image instead of screen.
\t good to abstract away differences, that screen is just another image

\l FIGURE a screenshot where can see graphic elements?
% genre Facebook page? rectangles, gradiant, circles, images

%toc: ?

\subsection{Display server}
\n could be in Windows.nw, but useful to explain the /dev/draw/x/

Graphics systems are usually implemented as display servers.
%alt: just lib for old style DOS games? or mirage style?
A {\em display server} is a program that accepts {\em drawing commands}
from multiple {\em clients} via a {\em communication protocol}, 
and then translates those commands into instructions to the graphics card.
%(and changed) intro/motivations  intro/draw  intro/other-system
Designers of graphics systems often used a client/server architecture 
because graphics systems are usually coupled with a windowing system. 
%
In that case, the graphics system needs to serve many clients:
the multiple processes corresponding to the multiple windows on the screen.

%dup: (and changed) intro/motivations  intro/draw  intro/other-system
In most operating systems (e.g., Linux, macOS, or Microsoft Windows),
the graphics system is {\em strongly} coupled with the {windowing system}.
\l and some windowing systems have network component!
%in-plan9:
However, this does not have to be the case. In fact, in \plan 
you can run a graphical application without any windowing system running.
\l advanced: windows, menus, mouse/keyboard


\subsection{Image resolution}

The {\em resolution} of a screen or {image},
for example, [[640x480x8]], indicates the 
{width} (640), 
{height} (480), and 
{depth} (8) of the image.
\l use 1024x768x16 instead! simpler model! raspberry ftw?
\l resolution def is just the grid? I thought it was also the depth.
%
The {\em width} and {\em height} specify the dimensions of the two-dimensional
array of pixels, also called the {\em grid}.
The {\em depth} represents the number of bits used per pixel.
%
For instance, with a depth of 8 bits, each pixel can take one of 
256 different values.

\l FIGURE where can see gray picture and next to it matrix with values

Pixel values usually encode either a color or a shade of gray
depending on the {monitor}.
%
For the shades of gray, 0 can mean black and 255 white.
In old black-and-white displays, each pixel was using only
one bit: 0 for black and 1 for white. Pictures were then called {\em bitmaps}.
\n Alto introduced bitmapped displays

\subsection{Color representation}

Colors are usually decomposed into three different {\em components}:
red, green, and blue, or {\em RGB} for short.
Note that those colors are {\em primary colors}, meaning that
any color can be expressed as a combination of those three colors.
For instance, yellow is an equal mix of red and green.
\l history is monitor? CRT tubes? the eye system? trichromatic means?

The pixel value of a colored image
can be translated into an actual color by using, for instance,
a {color map}. A {\em color map} associates to a pixel value
between 0 and 255 the three different values for the different RGB components,
for example, 127 for red, 127 for green, and 0 for blue 
(forming a light yellow).

Note that color maps are not necessary. If the resolution of a screen
is for instance [[1024x768x24]], meaning that 24 bits are used
to represent one pixel, then those 24 bits can be decomposed in three
different bytes encoding each one of the RGB components.
The use of 24 bits per pixel, also known as the {\em True Color} format,
is enough to encode 16 million ($2^{24}$) different colors.
\l channels =~ components, but not necessarly colors, pixel value structure
\l FIGURE? src:alok
\l say that arbitrary. can be 24, 16, 32.

\subsection{Raster graphics (pixels)}
\n discrete, digital

The term {\em raster graphics} is often used to talk about graphics
in terms of pixels. 
%
The word {raster} comes from the {\em raster scan} process used in
the cathode ray tubes of old television sets. This process painted an image
line-by-line by illuminating, with three different electron emitters,
thousands of phosphorescent dots triples (one red, one green, one blue)
arranged in a grid.
%
In raster graphics, a programmer sees an image as a two-dimensional array.
\n nice property is that fix amount of memory for any image

The software interface of a graphic card
can be as simple as a reserved area of the memory address space
used to represent the screen as a two-dimensional array.
Such an area is often called the {\em frame buffer}. 
You can then draw on the screen simply by modifying bytes in the frame buffer.
The graphics card then interprets the pixel values in the 
frame buffer to send the appropriate signals to the monitor.
\t only issue is synchro!

The graphics card of the Raspberry Pi machine uses such an interface,
as explained in Appendix~\ref{chap:raspberry-pi-graphic-card}.
When the resolution of the screen is [[1024x768x24]], 
\n actually it's 1024x768x16 by default, but 16 is complicated to explain
the frame buffer requires around 2.2 MB of address space.
If we assume that the frame buffer is {memory-mapped}
at the virtual address [[0xA0000000]], then the simple function 
below can be used to set the color of any pixels on the screen:
\n good to be concrete quickly, to get quickly an idea on how to draw things!

<<function set_pixel (imaginary)>>=
void set_pixel(uint x, uint y, byte red, byte green, byte blue) {
  byte* addr;

  assert(x < 1024);
  assert(y < 768);

  addr = 0xA0000000 + y*1024*3 + x*3;
  *addr = red;
  *(addr+1) = green;
  *(addr+2) = blue;
}
@
\n assume RGB order is byte order, also assume y grows up, also assume kernel
\n  since access directly physical space

\n notion of soft screen and flush vs direct frame buffer but can see later



\subsection{Vector graphics (shapes)}
\n continuous, analog

%trans:
Drawing pictures by modifying individual pixels can be
very tiresome. We would like a more high-level approach.
%
The term {\em vector graphics}, used in opposition
to raster graphics, expresses graphics in terms of
ideal {\em geometric shapes}:
lines, 
rectangles,
circles, 
ellipsis, 
arcs,
Bezier curves,
etc.
%
In vector graphics, a programmer sees
an image as a list of shapes.
%
A shape can be defined by a list of vectors specifying the 
{control points} of a line or a curve.

\n horiz/vert lines, rectangle, arbitrary line, polyline, polygon (fill),
\n ellipse, arc, Bezier

%history:
Note that vector-graphics displays, developed from the oscilloscope
industry, actually predated raster-graphics displays, which
were rooted in the television industry.
\n pike-bitbltd-1984.pdf intro is good to describe early history of graphics
% description of lines, curves?
With time, raster displays became more economical to produce
and more flexible to program, and so are now dominant on the market.

\subsection{Rasterization}

{\em Rasterization} is the process of turning vector graphics, that is 
geometric shapes, into raster graphics, that is pixels on a grid.
Rasterization is a fundamental operation.
\l also valid for 3D? turns a scene in pixels? raycasting is a rasterization?
%
For instance, Figure~\ref{fig:line-raster}
shows the set of pixels resulting from the rasterization
of a line drawn in the [[hellodraw.c]] program
mentioned in Section~\ref{sec:getting-started}.
Figure~\ref{fig:line-raster} shows the magnified left part of the screen of 
Figure~\ref{fig:hellodraw}, where you can then see the individual pixels
making up a line.
%
If the resolution of the screen is high enough, and the pixels 
on the monitor small enough,
then the brain can be fooled and can get the illusion that the line
is continuous as in Figure~\ref{fig:hellodraw}.
\n anti-aliasing makes it even better, better illusion, trick the eye more
\l actually just like the thing you read now on paper, it's dots too?
\n Retina display reach physical limite of the eye/retina/brain?
\l ``bitmaps [...] imperfect approximations to the ideal images one
\l  would like to display - Pike-bibltd.pdf

\begin{figure}\begin{center}
\includegraphics[width=8cm]{line-raster}
\end{center}
\caption{Line rasterization.}
\label{fig:line-raster}
\end{figure}
\n From ideal to concrete.

\n if draw not at 45 degree but 32, then no that easy actually :)
% => bresenham algorithm, scanline algorithm.

\subsection{[[bitblt()]] and compositing}
\label{sec:bitblt}

[[bitblt()]]\cite{pike-bitblt}, 
for {\em bit}-boundary {\em bl}ock {\em t}ransfer, is another
fundamental graphic operation.
%
It copies a rectangular area of an image, the {\em source},
to another area of the same or different image, the {\em destination},
while applying for each pixel involved a {\em composition operator} [[op]].
%
The value of a destination pixel [[d]]
is given by the following formula where [[s]] is the value
of a source pixel:

\begin{verbatim}
d <- d op s;
\end{verbatim}

% FIGURE? for transluscence? but then need explain alpha channel?

%history:
The name [[bitblt()]] comes from its use in early graphic systems
where pictures were represented as bitmaps.
%
Programmers are using [[bitblt()]] to highlight regions, 
draw horizontal and vertical lines, draw
rectangles, scroll an image, draw characters, and many more things.
\n see pike-bitbltd-1984.pdf
\l see pictures in "Graphics Smalltalk Kernel" article?
%
In pictures with colors, the [[bitblt()]] primitive can be used
to implement a variety of effects such as translucence by using
the appropriate composition operator.
\n porter-duff

%\subsection{Alpha layer} % and transluscence
\l alpha compositing here? to say how much want from the background?
\l then cite Porter-Duff
% FIGURE with different alpha values?
\l how is rendered a picture with certain alpha value? those are used?
\l or it's used only when compositing? notion of pre-alpha vs post-alpha?

Under \plan, the [[bitblt()]] primitive is called [[draw()]]
and is slightly more general. [[draw()]] is a very generic and
powerful function.
In fact, it is such a versatile procedure that, as we will see later,
it is the building block used by all the other drawing functions;
drawing a line, a polygon, or a circle involves at some
point many internal calls to [[draw()]].
\n actually [[memimagedraw()]]

\l FIGURE Indeed in Figure X a line is a set of horizontal or vertical
% lines which can be set through bitblt.
% same for polygon! fill polygon, scanline.

\l clipping
\l tiling (replicating) when used as a source.

%\subsection{Graphic context}
%alt: used in X11
% but not needed in rio

\subsection{Fonts}
\n fonts illustrate many of the principles we have seen so far, so cool.

%trans:
Geometric shapes are important, but so is {text}, even in a 
graphical-user-interface context.
%
A graphics system can improve over text-based user interfaces
(e.g., terminals) by allowing
the programmer to draw text with different sizes, different styles, and
even different orientations.
\l [[draw]] cant do that though, as opposed to cairo, or can it?
To draw characters, the graphics system requires
a series of pictures defining the shapes of all the characters
of an alphabet. Such a set of pictures is called a {\em font}.

Each character can be represented 
either using vector graphics, as in Figure~\ref{fig:font-vector},
or raster graphics, as in Figure~\ref{fig:font-raster}.
The two approaches illustrate well the pro and cons of the
two picture representations:

\begin{figure}\begin{center}
\includegraphics[width=6cm]{font-m-vector}
\end{center}
\caption{Letter [[m]] defined by a list of shapes.}
\label{fig:font-vector}
\end{figure}

\begin{figure}\begin{center}
\includegraphics[width=5cm]{font-a-raster}
\end{center}
\caption{Letter [[a]] defined by a grid of pixels.}
\label{fig:font-raster}
\end{figure}


\begin{itemize}
\item In Figure~\ref{fig:font-vector}, the letter [[m]] is defined
as a set of vectors representing the control points of straight lines
or Bezier curves.
\n also called Outline Font.
{\em TrueType} is a font format\footnote{
Such fonts are stored in files with the [[.ttf]] extension.
}
using this technique.
A character is then just another list of geometric shapes to draw.
\n unify power!
%
This approach is {\em scalable} as one
can {render} the letter in different sizes or orientations by rasterizing
its different elements.
\l hmm scalable missleading? because it is actually slow.
\l actually some issues when scaled down, so some fonts use ``Hinting''
However, such a rasterization can be expensive
to compute, and must be done each time
the program wants to draw a character.
\n in the end it also uses bitblt/draw

\item In Figure~\ref{fig:font-raster}, the letter [[a]] is
defined instead as a bitmap.
This approach supports only one size,
\l or risk of pixelization
but drawing a character can be very fast. Indeed, 
a programmer can just use [[bitblt()]] to copy the rectangle defining
the character on the screen.
\l idea of glyphs put together, kinda template, like printing machine
\l also can be used as cache for vector font

\end{itemize}

Note that \plan uses Unicode for its characters set (and not simply ASCII),
so font files can be large. 
\l Which is why indeed have subfont concept.
\l packard mentioned unicode leads to Xft/fontconfig because it was a mess


%\subsection{Advanced topics}

\l In this book we will cover basic 2D primitives but many adv topics.
\l Or put that in Conclusion? Future directions?

%other topics:
% - Imaging model? Postscript vs PDF? pen-based vs stroke-based?
% - scale/rotate/transform not in this book. But can be library wrapper
%    over library presented here.
% - antialiasing (very simple actually, put light intensity in function of
%    distance to theoritical point on the line (the error))
% - subpixel rendering, leverage position of RGB dots on the screen
% - SEMI True Type fonts, fonts using bezier curves
%    that are vectoriel and so scalable
% - Animation (Core Animation, Flash)
% - 3D. lighting. Shaders. GPU.
%   Not in this book. based on triangles usually. 
% - physical rendering
%   (but already literate programming book on it)


\subsection{Graphical application versus textual application}

% Evidently, output different. text vs graphics (including possibly text).
% But also input different.
% graphics system usually offer also API to access mouse!
% mouse and graphics come together. indeed, mouse is grid input.

% graphics and mouse change how app are programmed. inside out.
% reactive.
% also for keyboard, raw mode. not buffered.
% More on this in Chapter X. First will focus on output. graphics.
% /dev/draw/. Will see later /dev/mouse (and cursor) and /dev/cons 
% and input APIs.

\section{[[/dev/draw/]] filesystem interface}

[[draw]] is a \plan{} device/{filesystem}, not a regular program, 
so its interface
is not a set of command-line arguments and input-output files.
Instead, its primary interface is the files it {serves}.
\l draw is actually many things. one of its interface is draw.h
\n can take some param when bind, but usually empty, just /dev
%
Once you have {installed} [[draw]], usually with the command
[[bind -a '#i' /dev]] (see Section~\ref{sec:getting-started}),
[[draw]] serves a three-levels file tree that provides an interface 
to the graphics facilities of \plan.
\l unioned with other devices
\n 3 levels not that important now, but will be useful later with Q3rd/Q2nd/...
Here is the meaning of the main files and directories managed by [[draw]]:

\l but really could have just a /dev/draw like in 8 1/2 I think.

\begin{itemize}
\l maybe a table instead of a flat list? or a tree :)

\item [[/dev/draw/]] is at the first level and
is the main directory of [[draw]]; almost all the
files of [[draw]] reside under it.
%
As opposed to simpler devices such as
the mouse with [[/dev/mouse]], or the console with [[/dev/cons]],
\n actually there is also /dev/consctl so could be grouped in /dev/cons/ctl
the [[draw]] device uses a directory
because it will manage multiple clients at the same time.
\n will see later that another tech is used later for multiplex /dev/mouse
Because each client is associated with multiple dynamically-created device
files, not grouping those files together under [[/dev/draw/]]
would pollute the [[/dev/]] directory.
%Thus, [[draw]] is more a filesystem than a device file.


\item [[/dev/draw/new]] is at the second level and
is the first file that a graphical application must open.
It allows the opening a new connection to the [[draw]] display server.
%
The function [[initdraw()]], which we will see in Section~\ref{sec:hellodraw_c},
and which is used by all graphical applications,
is using internally this file.
\l why need connection? because there is a state! stored server side!
\l  for each client.

\item [[/dev/draw/1/]], [[/dev/draw/2/]], etc.
are directories corresponding to different connections
to the display server. A process opening [[/dev/draw/new]] will
create a new dynamic subdirectory under [[/dev/draw/]].
%
Those directories will make more sense in the \book{Windows}.
Indeed, the use of the same screen by multiple processes at the same time
is useful mainly in a windowing system context
where independent graphical applications are running concurrently.
\l but only because of the way rio is implemented with efficiency constraint

\item [[/dev/draw/1/ctl]] (and [[/dev/draw/2/ctl]], etc.)
is at the third level
and contains mostly information about the screen, for instance,
its resolution.
Opening [[/dev/draw/new]] returns a file descriptor
that corresponds to a [[/dev/draw/x/ctl]] file, so the programmer
does not need to open this file.
\l a bit magic. Actually can open this file and then have concurrency issues.
\n 12 strings, info on screen, first Image.

\item [[/dev/draw/1/data]] is the file used
by the graphical application to communicate {\em drawing commands}
to the display server. 
%
The format of those drawing commands is pretty regular:
they start all with a single character, for instance, 
[['L']] for drawing a line,
followed by binary parameters\footnote{Multi-byte integer parameters
are transmitted with the low-order byte first.}.
%
The code of all the drawing functions in [[draw.h]] eventually write 
a drawing command in the [[/dev/draw/x/data]] file.
\l protocol
\l can do stuff without API, just by writing in files.

\end{itemize}

The remaining files managed by [[draw]] are listed below;
I will cover them later in this book:

\begin{itemize}

\item [[/dev/draw/1/colormap]] is useful only on 8-bit displays.
I will cover this file in Section~\ref{sec:colormap}.

\item [[/dev/draw/1/refresh]] is discussed in Section~\ref{sec:refresh}.

\item [[/dev/winname]] is at the first level again
and is the only file managed by [[draw]] that is 
not under [[/dev/draw/]].
It is related to the windowing system
and I will cover it in Chapter~\ref{chap:windowing-support}.
\l bootstrap

\end{itemize}

For more information on the [[draw]] files and their
format, I refer you to the documentation of [[draw]]
in [[docs/man/3/draw]].

\n Why is reading plain text out of /dev/mouse and writing plain text
\n to /dev/draw an improvement over how Linux or OS X or Windows does it?
%from https://news.ycombinator.com/item?id=9829662
%   It's very useful because you don't need a C FFI to access OS
%   functionality, graphics libraries and the like. Any language whose
%   implementation allows you to read and write files can already do a lot
%   of things (including GUIs, IPC and so on).
%actually programs uses a C FFI with draw.h, so not a net win.
% maybe one advantage is that it's more transparent.
%alt: maybe Mach MIG is better than "everything is a filesystem" metaphor?

\section{[[hellodraw.c]]}
\label{sec:hellodraw_c}

%trans:
Programs usually do not access directly [[/dev/draw/new]]
or [[/dev/draw/x/data]].
They use instead a higher-level API declared in [[draw.h]].
%rather than writing directly in the device files.
%
The program [[hellodraw.c]] below, which I mentioned
in Section~\ref{sec:getting-started}, and whose graphical output
is Figure~\ref{fig:hellodraw}, uses this API:

<<tests/draw/hellodraw.c>>=
1   #include <u.h>
2   #include <libc.h>
3   #include <draw.h>
4   
5   void main(void) {
6       int result;
7       Image *color;
8       
9       result = initdraw(nil, nil, "Hello Draw");
10      if (result < 0) {
11          exits("Error in initdraw");
12      }
13      
14      color = allocimage(display, Rect(0,0, 1,1), RGB24, true, DMagenta);
15      draw(display->image, display->image->r, color, nil, ZP);
16      
17      line(display->image, 
18           Pt(10, 10), Pt(100, 100), 
19           Endsquare, Endsquare, 10, display->black, ZP);
20      string(display->image, 
21             Pt(200, 200), display->black, ZP, font, 
22             "Hello Graphical World");
23      flushimage(display, true);
24      
25      sleep(5000); // msec
26  }
@
\n use view? no! use display->image directly so simpler. hellorio.c uses view!
\l could introduce a alloccolor?
%ocaml: use exn instead of error code, and return display instead
% of using global (possible because does not use error code for return value)

Here are a few important things to note in this program:

\begin{itemize}

\item [[draw.h]], included at Line~3, contains all
the public data structures and drawing functions of [[draw]].
%
[[libc.h]], included at Line~2, defines
the functions of the \plan core C library.

\item [[initdraw()]], called at Line~9, must be the first
call to the [[draw]] API. It initializes necessary globals
such as [[display]] (used later at Line~14),
%, 15, 17, etc.
which contains information about the screen. 
[[initdraw()]] internally opens [[/dev/draw/new]]
to open a new connection to the display server.
\l and get screen information from /dev/draw/x/ctl
%
It also sets the global [[font]] (used later at Line~21)
to the default font of the system.


\item Lines~7 and 14 illustrate an important concept in [[draw]]:
{\em everything is an image}. Indeed, the [[Image]] type from [[draw.h]]
unifies many things: the screen is represented as an
image in [[display->image]]; fonts are images;
windows, as we will see later, are images; even colors are images.
%
A color is simply a
[[1x1]] image 
(see the second argument of [[allocimage()]], Line~14, which creates a 
rectangle with [[Rect(0,0,1,1)]])
with the {\em replicating} bit set to true 
(the fourth argument of [[allocimage()]]), 
and where all pixels have a fixed RGB value (here [[DMagenta]],
the last argument of [[allocimage()]]).
\l RGBA32?

\item Line~15 uses the very general [[draw()]] function
that I mentioned before in Section~\ref{sec:bitblt}.
It copies the {source} image [[color]] (a replicated [[1x1]] image)
to the {destination} image [[display->image]] (the screen) over
the whole screen rectangle ([[display->image->r]]).
\l mask but here nil. ZP is Zero point so Pt(0,0)

\item 
Line~17 draws on the screen a black line of width 10 in diagonal.
Line~20 draws some text in the font specified by
the global [[font]], which was set previously by [[initdraw()]].

\item Line~23 {\em flushes} the {\em drawing commands buffer} by writing
all the previous commands in [[/dev/draw/x/data]].
Line~23 also instructs the [[draw]] server to make the result 
visible on the screen with the second parameter
of [[flushimage()]].
\l we will see more about that later.

\end{itemize}

%toc:
The following chapters will clarify the code of [[hellodraw.c]],
especially the meaning of the different parameters of the different
functions of [[draw.h]].
%
The goal here was just to give a quick idea on how to use [[draw.h]].

\l stateless API
%alt: different model is Context/State of X11, Postscript, cairo, openGL,
% canvas?

%real-world:
% no need Expose | MappingNotify | ... events, just draw!

See Appendix~\ref{chap:examples} for more examples of graphical
applications using [[draw.h]].

% Dont handle input at all here (mouse, keyboard), or resize event.
% graphical app needs to do that too normally, but simpler for now
% to just show the code to draw.
% There is also an event vs thread programming model for graphical applications.

\l education purpose, program below show how to draw a line
\l without using draw.h but accessing directly the devices.
\l hellorawdraw.c without draw.h

\l note that can run 'colors' in console outside rio! it just
% use /dev/draw, /dev/mouse, etc!



\section{Code organization}
\label{sec:code-orga}

The code of [[draw]] can be decomposed in multiple components that
correspond to different directories in the \plan repository:

\begin{itemize}

\item [[include/graphics/draw.h]] contains the visible part of [[draw]]
for the programmer. This header file contains the
data structures (e.g., [[Image]]) and 
function declarations (e.g., [[draw()]], [[line()]], or [[string()]])
to draw different shapes on the screen.
\n I reference only entities used in hellodraw.c

\item [[lib_graphics/libdraw/]] is a user-space library implementing
the functions defined in [[draw.h]]. However, those functions are just
thin wrappers that write into [[/dev/draw/x/data]] to delegate
the actual rendering to code in the kernel.
%real-world: called libdrm for Linux; hide ioctls behind nice C API.

%defont.c: lucm/latin1.9, in uncompressed form
%readcolmap.c: dead? used in apps?
%misc.c: old image format. delete? used by font still? utilities to convert?


\item [[kernel/devices/screen/]] contains the kernel code
that implements the [[draw]] filesystem, as well as a few device
drivers for graphics cards. 
%
The [[devdraw.c]] file, in particular, contains the different
filesystem methods (e.g., [[drawopen()]], [[drawread()]], or [[drawwrite()]])
\l device/filesystem methods
that will be executed when a program accesses files from [[/dev/draw/]].
\l [[screen.h]]
%
As we will see in Section~\ref{sec:drawwrite-drawmesg},
the [[drawwrite()]] method calls [[drawmesg()]] when
the file involved is a [[/dev/draw/x/data]] file.
[[drawmesg()]] is a large function that
processes all incoming drawing commands in
a giant [[switch()]]. This function looks at the first letter of
the drawing command to decide which graphic operation to perform.

% pool.c?: imagmem! image data store! (in kernel :( X11 spirit )
% screen.c: factorize stuff, gscreen, soft cursor, cursor, graphic text mode
%  (I created it as a model of the one in bcm/)
% vgascreen.c: implem of screen.h hardware specific hooks needed by devdraw
%  and memdraw
% devvga.c: /dev/vga ctl files for vgascreen global parameters?

\item [[lib_graphics/libmemdraw/]] is a library
used by the kernel that contains most of the 
generic graphics-related code. [[drawmesg()]] calls mostly functions
from [[libmemdraw/]] (e.g., [[memimagedraw()]], [[memimageline()]]).
Most of those functions operate on the [[Memimage]] type defined
in [[include/graphics/internals/memdraw.h]].
\l why not directly use memdraw.h? why need all this mess?
% drawmesg() dispatcher to libmemdraw operations and libmemlayer operations
% should also have actual calls to screen.h implem, e.g., vgascreen.c!

% libmemdraw actually does the drawing stuff in memory
% (and rely on some kernel vga functions to do the rest and transfer
%  images from memory to the actual screen (or nop if frame buffer))
% it also rely on some code in libmemlayer.

%replmul.c: replmul global used in mktables to duplicate bits
%defont.c: getmemdefont, used only for graphical text mode
%string.c: seems used only for graphical text mode, simple code at least
% drawchar() is actually in devvga.c
%cruft.c: default implem if link directly with memdraw outside kernel.
% otherwise the linker will complain if no hwdraw() function.
% But normally hwdraw() should be a bridge to screen.h interface 
% functions? (implemented by vgascreen)


\item [[lib_graphics/libmemlayer/]] is another library used
by the kernel to manage overlapping layers. I will cover it
later in Chapter~\ref{chap:overlapping-windows}.
% It's not really layer in the cairo sense. It's really windows.
% Then you can easily implement a windowing system with 
% overlapping pictures (windows) that actually can get exposed back.

%\item [[kernel/devices/screen/386/]]
% specific drivers. Important is interface to provide access to the screen
%  Memimage/Memdata.

%\item [[kernel/devices/screen/user/]]
% user-space utilities for VGA, see appendix X?
% could get rid of it? Does not need that for Raspberry.

%\item [[lib_graphics/libimg/]]

\end{itemize}

%dup: (but changed a lot) from Assembler.nw
Table~\ref{tab:code-orga} presents short descriptions
of the source files used by [[draw]]. I organized
those files according to the directories I mentioned above,
except for the files in [[lib_graphics/libmemlayer/]],
which I will cover in Chapter~\ref{chap:overlapping-windows}.
\t explain that put together in one line
\t  because of the way draw is architectured they are strongly related.
\l lofs of files have similar name in libdraw/ and libmemdraw/.
\l also many .h are really in include/graphics but put with associated dir.
%
The table also shows
the main entities (e.g., structures, functions, globals) the files define
and the corresponding chapter in this document in which the code
contained in a file is primarily discussed.



\begin{table*}[tbh!]
\begin{center}
\begin{tabular}{lcllll}
\toprule
{\bf Function} & {\bf Ch.} & {\bf [[libdraw/]] Files} & {\bf [[libmemdraw/]] Files} & {\bf [[kernel/]] Files} & {\bf Entities}\\
\otoprule
data structures          & \ref{chap:core-ds}                   & [[draw.h]] [[arith.c]]          & [[memdraw.h]]             & [[devdraw.h]] [[screen.h]]  & [[Point]] [[Rectangle]] [[Display]] [[Image]] [[Memimage]]  \\ % actually many .h are under include/graphics/ % [[ImageChan]] [[rgba]] % [[screen.c]]  Colors
%geometry                 & \ref{chap:core-ds}                   & [[arith.c]]                     &                           &                             & [[eqpt()]] [[eqrect()]] [[ZP]] [[ZR]]                       \\ %  (libgeometry) % [[addpt()]] [[rectaddpt()]]
%
image resolution         & \ref{chap:core-ds}                   & [[chan.c]] [[resolution.c]]     &  [[color.c]] [[resolution.c]]         &                             & [[bytesperline()]] [[chantodepth()]]            \\ % byteaddr() % chan.c for libmemdraw too
initializations          & \ref{chap:init}                      & [[init.c]]                      &  [[init.c]]               & [[drawinit.c]]              & [[initdraw()]] [[memimageinit()]]                           \\ % [[display]] [[screensize()]]  [[initscreenimage()]]  [[initdisplay()]]
user/kernel bridge       & \ref{chap:user-kernel-bridge}        & [[marshal.h]] [[flush.c]]       &                           & [[devdraw.c]] [[drawmesg.c]]& [[drawdevtab]] [[Qxxx]] [[drawopen()]] [[drawmesg()]]       \\ %  [[drawwalk()]] 

\midrule                                                                                                                  

image allocation         & \ref{chap:images}                    & [[alloc.c]]                     & [[alloc.c]]               & [[drawalloc.c]]             & [[allocimage()]] [[allocmemimage()]]                        \\ % mv byteaddr() memsetchan() elsewhere? % [[freeimage()]] 
clipping and replication & \ref{chap:images}                    & [[replclipr.c]]                 &                           &                             & [[]]                                                        \\ % replmul.c, could also have a libmemdraw/drawclip.c also with rectclip() maybe
image naming             & \ref{chap:images}                    & [[naming.c]]                    &                           & [[drawname.c]]                        & [[nameimage()]] [[namedimage()]]                  \\
manipulating rectangles  & \ref{chap:draw}                      & [[draw.c]]                      & [[draw.c]] [[alphadraw.c]]&                             & [[draw()]] [[memimagedraw()]] [[alphadraw()]]               \\
drawing lines            & \ref{chap:drawing-shapes}            & [[line.c]]                      & [[line.c]]                &                             & [[line()]] [[memimageline()]]                              \\
drawing polygons         & \ref{chap:drawing-shapes}            & [[poly.c]]                      & [[poly.c]] [[fillpoly.c]] &                             & [[poly()]] [[fillpoly()]] [[mempoly()]]                     \\
drawing ellipses/arcs    & \ref{chap:drawing-shapes}            & [[ellipse.c]]                   & [[ellipse.c]] [[arc.c]]   &                             & [[ellipse()]] [[fillellipse()]] [[memellipse()]]            \\ % [[arc()]] [[fillarc()]] [[memarc()]]

\midrule                                                                                                                  

font data structures     & \ref{chap:fonts}                     & [[font.h]]                      &                           &                             & [[Subfont]] [[Cacheinfo]]                                   \\ %pad: I created font.h
font initialization      & \ref{chap:fonts}                     & [[defont.c]] [[font.c]]         &                           &                             & [[defontdata]] [[buildfont()]]                              \\ % %pad: I changed font.c to contain buildfont.   freefont()
text drawing             & \ref{chap:fonts}                     & [[string.c]]                    &                           &                             & [[string()]] [[stringbg()]]                                 \\ % [[drawchar()]] is not in string.c!
%computing text width    & \ref{chap:fonts}                     & [[stringwidth.c]]               &                           &                             & [[stringwidth()]]                                           \\
characters cache         & \ref{chap:fonts}                     & [[fontcache.c]]                 &                           &                             & [[cachechars()]] [[loadchar()]] [[fontresize()]]            \\ %
subfont management       & \ref{chap:fonts}                     & [[subfont.c]]                   &                           &                             & [[readsubfont()]] [[writesubfont()]]                        \\ % could put subfont.c of libmemdraw, but not really needed

\midrule

transfering an image     & \ref{chap:image-io}                  & [[transfer.c]]                  & [[transfer.c]]            &                             & [[loadimage()]] [[loadmemimage()]]                           \\ % [[unloadimage()]] [[unloadmemimage()]] %
image IO                 & \ref{chap:image-io}                  & [[io.c]]                        & [[io.c]]                  &                             & [[readimage()]]                                              \\ % writememimage() is here actually, and it's compressed
%
mouse management         & \ref{chap:input}                     & [[mouse.h]] [[mouse.c]]         &                           &                             & [[Mouse]] [[Mousectl]] [[initmouse()]] [[readmouse()]]      \\ % [[closemouse()]]
cursor management        & \ref{chap:input}                     & [[cursor.h]]                    &                           & [[CURSOR.h]] [[swcursor.c]] & [[swcursorinit()]] [[cursoron()]]                           \\
keyboard management      & \ref{chap:input}                     & [[keyboard.h]] [[keyboard.c]]   &                           &                             & [[Kxxx]] [[Keyboardctl]] [[initkeyboard()]]                 \\ % [[closekeyboard()]] 
%
overlapping layers      & \ref{chap:overlapping-windows}       & [[window.h]] [[window.c]]       &                           & [[DRAWDESKTOP.c]]           & [[allocwindow()]] \\ % desktop.c,
%
color maps               & \ref{chap:non-true-color}            & [[colormap.c]]                  & [[cmap.c]]                &                             & [[rgb2cmap()]] [[cmap2rgb()]] [[readcmap()]]                \\ % [[writecmap()]] [[writecolmap()]] %cmap.c (generated by scripts/mkcmap.c) % %  [[readcolmap()]] [[memdefcmap]]  % lots of stuff in memdraw/draw.c related to color map too
drawing Bezier curves    & \ref{chap:advanced}                  & [[bezier.c]]                    &                           &                             & [[bezier()]] [[bezspline()]] [[fillbezier()]]               \\
%get rect?               & \ref{chap:advanced}                  & [[getrect.c]]                   &                           &                             & [[getrect()]]                                               \\
basic menus              & \ref{chap:advanced}                  & [[menuhit.c]]                   &                           &                             & [[Menu]] [[menuhit()]]                                      \\ %
event-based IO           & \ref{chap:advanced}                  & [[event.c]]                     &                           &                             & [[Event]] [[einit()]] [[ekbd()]] [[emouse()]]               \\ % [[egetrect.c]] [[emunuhits.c]]
graphical text mode      & \ref{chap:advanced}                  &                                 & [[defont.c]] [[string.c]] & [[swconsole.c]]            & [[graphical_screenputc()]] [[memimagestring()]]                    \\ % cga.c is for old style
%refresh                 & \ref{chap:advanced}                  &                                 &                           & [[drawmisc.c]]              &                                                             \\
image compression        & \ref{chap:advanced}                  & [[compressed.c]]                & [[compressed.c]]           &                             & [[cloadimage()]]  [[creadimage()]] [[writeimage()]]        \\ % [[cloadmemimage()]] [[creadmemimage()]] % libmemdraw/io.c contains some compressed stuff too

\midrule
debugging                & \ref{chap:debugging-appendix}        & [[debug.c]]                     &                           &                             & [[drawsetdebug()]]                                          \\
dumpers                  & \ref{chap:debugging-appendix}        & [[fmt.c]]                       &                           &                             & [[Pfmt()]] [[Rfmt()]] [[chantostr()]] [[printmesg()]]       \\
error management         & \ref{chap:error}                     & [[error.c]]                     &                           & [[drawerror.c]]             & [[Errorfn]] [[drawerror()]]                                 \\ %pad: I created this file
trigonometry             & \ref{chap:math}                      & [[icossin.c]] [[icossin2.c]]    &                           &                             & [[sinus]] [[cosinus]] [[icossin()]] [[icossin2()]]          \\

\midrule

VideoCore driver         & \ref{chap:raspberry-pi-graphic-card} &                                 &                           &                             &                                                            \\
VGA generic driver       & \ref{chap:pc-vga-driver}             &                                 &                           &  [[vga.h]] [[devvga.c]]     & [[vgadevtab]] [[VGAscr]] [[VGAdev]] [[vgaattach()]]        \\ % [[vgascreen]] % [[vgascreen.c]] [[vgavesa.c]]  
%Cirrus logic VGA driver &                                      &                                 &                           &  [[vgaclgd542x.c]]          &                                                             \\
\otoprule
Total LOC                &                                      &  8700                           &  5800                     &  7300                       &                                                             \\
\bottomrule
\end{tabular}
\end{center}
\caption{Chapters and source files of [[draw]].}
\label{tab:code-orga}
\end{table*}
\n put total LOC per directory, no space for a LOC column and made less sense
\t add window and windowing system support. Have files in libdraw/ and kernel
\t  related to that. maybe can even split libdraw/window.c in rio.c
\t  with getwindow() there and view/screen ?
\l could move menuhit.c and getrect.c out of draw/ in a ui/
%ocaml: more split of draw/ with input/ (keyboard.c, mouse.c) 
% and ui/ (getrect.c, menuhit.c) and geometry/ (arith.c)

% normally apps must link just with libdraw.a, and not libmemdraw.a
% (or libmemlayer.a). 
% There are some apps that use memdraw/memlayer too though
%  to implement a windowing like system inside the app, e.g., acme.
% Only the kernel (and test programs) link with libmemdraw.a normally.
% can actually divide libdraw in two, have a libcoredraw (or libgeometry)
%  so the kernel would not even depend on libdraw.

\n libdraw/ was split in many small files originally. See the comment below.
% The rectclip() function was originally in his own rectclip.c file instead of
% with replclipr.c. In the same way, getdefont() was in his own file
% instead of with defont.c. Note that the kernel needs only rectclip(),
% not rectclipr(). It needs only defontdata and not getdefont(). But
% by putting those functions in bigger files, the linker is then forced
% to link the whole object file and its further dependencies. In
% the case of getdefont(), this generates in the end a signature conflict
% in lockdisplay() because of the differences between QLock (used in Display
% in draw.h) between libc.h and the kernel. For rectclipr() this forced
% to link bufimage() which was in init.c with lockdisplay and so would
% generate the same error (I now put bufimage in another file so
% I can put rectclip() with replclipr()).
% So merging many functions in one single file is actually tricky.
% All of this could be avoided by having a geometry.h and libgeometry.a
% and by having the kernel linking with only libgeometry.a, not libdraw.a.


%common short
% 'sp' for source point
% 'r' rectangle
% 'i' image (img would be better)




\section{Software architecture}

From the programmer's point of view, [[draw]] is just a library.
\n not a program you execute like [[5a]] or [[5l]]
%dup: overview/code-orga
Its software architecture is first made of the set of
functions you can call (e.g., [[line()]], [[string()]]),
and data structures you can use (e.g., [[Image]]),
to draw things on a screen.
%dup: overview/interface  overview/helloworld.c  overview/code-orga
All those entities are declared in [[draw.h]].
%
Those are the {\em entry points} of [[draw]].
%
However, what is under those entry points is rather complicated.
Indeed, as we have seen in Section~\ref{sec:code-orga},
[[draw]] has many {components}:
\begin{itemize}

\item A user-space library ([[libdraw]])

\item Two kernel-space libraries ([[libmemdraw]] and [[libmemlayer]])

\item A filesystem (accessible though [[/dev/draw/]], thanks mainly
to [[devdraw.c]])

\item A protocol (for user-space programs to communicate with
the kernel via a [[/dev/draw/x/data]] device file)

\item A few device drivers (for different graphics cards)

\end{itemize}
\l Could this be skipped if reader interested only in core ideas?

%toc:
A good way to see how those components work together is to
{\em trace} a call to one of the functions of the [[draw]] API
through those different components.


\subsection{Trace of a drawing operation}
\l When do draw(), go in kernel? yes (at least when call flush())


\begin{figure}[!]\centering
\begin{verbatim}
       hellodraw.c-----+    clock.c--+    colors.c--+
       |   ...         |    |        |    |         |    APPLICATIONS
 U     |   line(...);  |    |        |    |         |
 S     +---------------+    +--------+    +---------+
 E  include/graphics/draw.h----------------------------+
 R  |    void line(...);        ...                    |
    +--------------------------------------------------+
 S  lib_graphics/libdraw/------------------------------+
 P  |  line.c-------------------------+ ellipse.c+     |    USER
 A  |  |void line(...) {              | |        |     |  LIBRARIES
 C  |  |  ...                         | |        |     |
 E  |  |  write(display->fd, "L ...");| |        | ... |
    |  |}                             | |        |     |
    |  +------------------------------+ +--------+     |
    +--------------------------------------------------+
 ----------------------- /dev/draw/1/data  -----------------------
     kernel/---------------------------------------------+
     |+---+ files/------+ devices/screen/--------------+ |
 K   || s | | syswrite()| | devdraw.c----------------+ | |
 E   || y | | sysread() | | |void drawwrite() { ... }| | |
 R   || s | |           | | |void drawmesg(...) {    | | |
 N   || c | +-----------+ | |  ...                   | | |  KERNEL
 E   || a |               | |  switch(c) {           | | |
 L   || l |               | |  ...                   | | |
     || l |               | |  case 'L':             | | |
 S   || s |               | |     memline(...);      | | |
 P   || / |               | +------------------------+ | |
 A   |+---+               +----------------------------+ |
 C   +---------------------------------------------------+
 E   lib_graphics/libmemlayer/---------------------------+
     | line.c------------------------------------+       |
     | |void memline(...) { memimageline(...); } |  ...  |
     | +-----------------------------------------+       |
     +---------------------------------------------------+   KERNEL
     lib_graphics/libmemdraw/----------------------------+ LIBRARIES
     | line.c-----------------------+ ellipse.c-+        |
     | |void memimageline() { ... } | |         |   ...  |
     | +----------------------------+ +---------+        |
     +---------------------------------------------------+
\end{verbatim}
\caption{Tracing of [[line()]] through the [[draw]] components.}
\label{fig:soft-archi-directories}
\end{figure}


Figure~\ref{fig:soft-archi-directories} illustrates a trace of
a call to [[line()]].
%
This trace starts at the top of Figure~\ref{fig:soft-archi-directories}
with the call to [[line()]] in the program [[hellodraw.c]] that you saw
in Section~\ref{sec:hellodraw_c}. I will now go gradually
downwards in Figure~\ref{fig:soft-archi-directories} to explain the trace:


\begin{enumerate}

\item [[line()]] is {declared} in [[draw.h]].
Its slightly simplified prototype is given below:
\begin{verbatim}
void line(Image* dst, Point p0, Point p1, ..., 
          int width, Image* color, ...);
\end{verbatim}
\l or better to keep things simpler for now?

\item [[line()]] is {defined} in [[libdraw/]].
%dup: (changed) overview/code-orga
However, as I said in Section~\ref{sec:code-orga}, [[libdraw]] is just a 
thin wrapper that delegates most of the work to the kernel. 
The code of [[line()]] just writes a {\em drawing command} 
(starting with the letter [['L']]) in the file descriptor [[Display.fd]]
of the global [[display]].
\n actually this is done in flushimage, but too subtle for now.
%
Remember that this global has been set
previously by a call to [[initdraw()]], as we saw in
Section~\ref{sec:hellodraw_c}.
\l form of RPC. a la thrift.

\item [[display->fd]], as we will see in Chapter~\ref{chap:core-ds},
is a file descriptor that corresponds to a [[/dev/draw/x/data]] device file.
This device file is the primary interface between 
a graphical application and the graphics code in the kernel.

\item The call to [[write()]] in [[libdraw/line.c]] is
a {\em system call}. It triggers a {\em software interrupt}
that jumps to code in the kernel.
%
This software interrupt is handled by
the {system-call dispatcher} in [[kernel/syscalls/]].
%
For more information on how system calls work,
I refer you to the \book{Kernel}.

\item The system-call dispatcher calls [[syswrite()]] 
in [[kernel/files/]] because the original system call was [[write()]].

\item [[syswrite()]] dispatches to the appropriate {\em filesystem method}.
Because the argument to [[write()]] is a file descriptor corresponding
to a file under [[/dev/draw/]], [[syswrite()]] calls the
[[drawwrite()]] method in [[kernel/devices/screen/devdraw.c]].
%
Again, I refer you to the \book{Kernel} to understand how
filesystems work.

\item [[drawwrite()]] calls [[drawmesg()]] because
the file descriptor corresponds to a [[/dev/draw/x/data]]
device file.

\item [[drawmesg()]] is the kernel function that handles
all the drawing commands written in [[/dev/draw/x/data]].
Because the first letter of the command is [['L']], 
[[drawmesg()]] calls the [[memline()]] function.

\item [[memline()]] is a function from the [[libmemlayer]]
library. This library, which I will describe in 
Chapter~\ref{chap:overlapping-windows},
handles images that are overlapping layers.
The important thing for now
is that [[memline()]] eventually calls [[memimageline()]].

\item [[memimageline()]] is a function from the [[libmemdraw]]
library. Its sligtly simplified prototype is given below:

\begin{verbatim}
void memimageline(Memimage *dst, Point p0, Point p1, ..., 
                   int radius, Memimage *color, ...);
\end{verbatim}
\t it is actually _memimageline for now, rename it!
\l explain Memimage vs Image? or say will explain soon.

[[memimageline()]] contains the algorithm to draw lines in 
images in memory. Those images have the type [[Memimage]].
As we will see in Section~\ref{sec:data-struct-relationshops}, 
one of those images
corresponds to the framebuffer; changing bytes
in this image translates to changes on the screen.

\end{enumerate}
\l device driver?

[[memimageline()]] then returns to the caller
[[memline()]], which does the same.
Eventually, the whole call stack is popped,
leading back to code in [[hellodraw.c]].


\l This was complicated ... Why not get line() call directly memimageline?
%  could, but will still need a system call to transfer computed 
%  pictures from user-space to the framebuffer (but there will be no
%  need for drawing commands and the protocol though). Would need a Xrender.

\l about protocol/RPC vs frame buffer.
% design goal was like X11, to be remote! can log on another
% machine, execute program there that actually display on your screen.
% for plan9 they just reuse 9p! network file system so /dev/draw
% can be on the network!
% but this design imply it can not be a frame buffer! The frame buffer
% may not be on the machine the program is running!
% so need send drawing commands, like in X11, because can't allow to send
% all pixels each time through big write on /dev/draw over the network
% (hmm actually with high-speed network maybe we could)



\subsection{Data structures relationships}
\label{sec:data-struct-relationshops}

\begin{figure}[!]\centering
\begin{verbatim}
    display <Display>
 U  |.fd = ...      |
 S  |.image = --+   |
 E  |           |   |
 R  +-----------+---+
                v
 S   <Image>---------------+  <Image>----------+
 P   |.id = 1              |  |.id = 2         |
 A   |.r = (0,0),(1024,768)|  |.r = (0,0),(1,1)|
 C   |.chan = RGB24        |  |.chan = RGB24   |
 E   +---------------------+  +----------------+
                ^                      ^
 ---------------+----------------------+--------------------------
                v                      v
        <DImage>--------+      <DImage>--------+  imagmem <Pool>-+
        |.id = 1        |      | .id = 2       |  |  +--------+  |
   +--->|.image = -+    |      | .image = -+   |  |  |        |  |
   |    +----------+----+      +-----------+---+  |  |        |  |
 K |               v                       v      |  +--------+  |
 E | drawscreen <Memimage>-+  <Memimage>-------+  |  +-+         |
 R | |.r = (0,0),(1024,768)|  |.r = (0,0),(1,1)| ++->| |         |
 N | |.chan = RGB24        |  |.chan = RGB24   | ||  +-+         |
 E | |.data = |            |  |.data = --------+-+|              |
 L | +--------+------------+  +----------------+  |  +---------+ |
   |          +-----------------------------+     |  |         | |
 S | <Client>--------+  <Client>---------+  |     |  +---------+ |
 P | |.clientid = 1  |  |.clientid = ... |  |     +--------------+
 A | |.dimage =|     |  |   ...          |  |
 C | +---------+-----+  +----------------+  |     0xA0000000 (FB)+
 E +-----------+  ^        ^                |     |              |
                  +--------+                |     |              |
   sdraw <KDraw>--++                        +---->|              |
   |              ||                              |              |
   | .clients =---+|                              |              |
   +---------------+                              +--------------+
\end{verbatim}
\caption{Data structures of [[draw]].}
\label{fig:soft-archi-data}
\end{figure}
\n use RBG24, not default config for Raspberry, but simpler
\n could use CMAP8 instead of RGB24 for color, so need translation, but Complex
\n .data point to Memdata intermediate first actually, but too suble for now.
\t actually id is 0

%trans:
Figure~\ref{fig:soft-archi-directories} focused on the functions
and the control flow of [[draw]]. However, the control flow
is only one part of the story. A few questions are remaining:
%
How are images represented in memory? 
What is the difference between an [[Image]] and a [[Memimage]]?
Where do images reside in memory? In user space? In kernel space? 
How can the frame buffer, usually a protected area of memory, be modified
by user-space programs? 
%
To answer those questions, Figure~\ref{fig:soft-archi-data}
focuses on the data structures of [[draw]], as well as their relationships.
\n the data flow this time
%
This time, I will go from the top and bottom of 
Figure~\ref{fig:soft-archi-data} towards its center.


At the top of Figure~\ref{fig:soft-archi-data} is the
global [[display]] I mentioned a few times before.
%
Its type is the structure [[Display]] defined in [[draw.h]].
In Figure~\ref{fig:soft-archi-directories}, you saw the use
of [[display->fd]] to write drawing commands in [[/dev/draw/x/data]].
Another important field of [[display]] is [[display->image]], which, as
I said in Section~\ref{sec:hellodraw_c}, {\em represents} the screen.
%
The type of [[display->image]] is the structure [[Image]],
also defined in [[draw.h]]. The global [[display]]
and [[display->image]] are both initialized by [[initdraw()]].


An [[Image]] has three important fields:
\begin{itemize}

\item An {identifier} ([[Image.id]])

\item A {rectangle} ([[Image.r]])

\item An {image format} (called [[Image.chan]]
because it is made of a set of  {\em channels}, 
which I will define in Section~\ref{sec:channels})

\end{itemize}

The last two fields together specify the {resolution} of the image.
%
The first field provides the mean for user-space programs to
{reference} data in the kernel. Indeed, an [[Image]] identifier is nothing more
than a {\em handle} to the real image (of type [[Memimage]])
that resides in kernel space.
%
The identifier is what is transmitted through [[/dev/draw/x/data]].
The call to [[line(display->image, ...)]] in Section~\ref{sec:hellodraw_c}
eventually writes [['L']] (a character), and the identifier
for the screen image [[1]] (an integer) in [[/dev/draw/x/data]].
Identifiers allow programs to tell on which image to 
apply the drawing command.

The first [[Image]] allocated by [[initdraw()]] has always
the identifier [[1]], and always corresponds to the screen.
A program can allocate more off-screen images, for instance
with [[allocimage()]], as shown in Section~\ref{sec:hellodraw_c}.
As we will see in Chapter~\ref{chap:images}, calls to [[allocimage()]]
lead to memory allocations both in user space (for [[Image]])
and kernel space (for [[Memimage]] and the data containing
all the pixels).


%trans:
The kernel-space side of Figure~\ref{fig:soft-archi-data},
at the bottom, is a bit more complicated than the user-space side.
%
At the very bottom, the kernel global [[sdraw]]
\n sdraw probably because static variable
keeps track of the set of clients the [[draw]] display server
serves.
%dup: (but changed) overview/files-interface
In the examples of this book, the display server will serve mostly a single
client. In the \book{Windows}, it will serve many clients: one
per window, and one for the windowing system program itself.
\n actually not one per terminal window
%dup: (but changed) overview/files-interface overview/hellodraw
In any case, each graphical application must first call [[initdraw()]],
which, by opening [[/dev/draw/new]], opens a new connexion
to the display server. Each connexion adds a new entry in
[[sdraw.clients]], which is an array of pointers to [[Client]],
a structure defined in [[devdraw.h]].
\l kernel header file

Each [[Client]] has an integer identifier that corresponds to
one of the [[/dev/draw/x/]] subdirectory.
%
Moreover, the field [[Client.dimage]] contains a 
set of [[Dimage]] (for [[Draw]] image), a structure also defined 
in [[devdraw.h]].

A [[DImage]] mirrors in kernel space part of an [[Image]] 
that resides in user-space.
The [[Dimage]] and associated [[Image]]
share the same identifier. However, a [[DImage]] also maps
an image identifier to a [[Memimage]], a structured defined
in [[memdraw.h]]. 

A [[Memimage]] is similar to an [[Image]];
they have similar fields ([[r]] and [[chan]]). An important
difference is that the new field [[Memimage.data]] points
to an area in kernel space where resides the actual pixels
of the image.
This area can be either the framebuffer (shortened [[FB]] in
Figure~\ref{fig:soft-archi-data}) or an off-screen image
allocated from the {\em memory pool} [[imagmem]]
(see the \book{Kernel} and the \book{Libcore} for
more information on memory pools).
\l (or soft screen and flush hook)
The [[Memimage]] representing the screen is also stored
in the global [[drawscreen]].
\l important global we will see in the following chapter.
\n skip Memdata for now, already quite complicated.
\l Many intermediate because sharing. will see later.



% --------------------------------

% Memdraw is core algo. Used by kernel. Wrapped by kernel
% in some Dxxx (e.g., DImage). Memlayer is overlay on memdraw
% to handle overlapping windows and backstore. Kernel use memdraw. 
% User uses libdraw
% which just marshall and have id references mimicking
% stuff in memdraw hold in the kernel.

% id (for image, desktop, etc) is key. pass id instead of whole structure.

% draw() rectangle is fundamental! all other shapes are in term of draw().


% maybe can also show the simplest interface, a frame buffer, and
% how /dev/draw build on top of that? In theory could have
% just a frame buffer and libmemdraw/ on top of it.

% = frame buffer or vga =
% = screen.h and gscreen Memimage =
% = libmemdraw/ =
%
% = libmemlayer/ =
% = draw device =
% = libdraw/ =
% = app =

% app, library, kernel draw server, kernel draw libs, vga driver
% kernel vs libs vs apps (vs rio)

% public API -> marshaller -> flush -> KERNEL -> unmarshaller -> algorithm
% some kind of RPC and protocol

% libdraw -> KERNEL -> devdraw -> libmemdraw | libmemlayer -> devvga -> clgd5446
% that's a lot of entities

% xxx, doxxx, memxxx, memlxxx, drawxxx, screenxxx

% Display (User side, dirno) Client (Kernel side, vga structure) 
%  Image (User side, id) MemImage (Kernel side, id -> full structure) DImage
%   can draw on that (lines, rectangles, lines, ellipses, text, etc)
%  Screen
%   Window (Image)

% devvga
%  why imagmem? why imagmem and mainmem? why not use other allocator?
%  see screen/user/notes.txt especially about the old way to get graphics on PC

% data structures archi:
%  Display|Image|display -> Client|MemImage|screen 
%    -> gscreen -> gscreendata.bdata and vgascreen.paddr?
% interface archi:
%  API -> marshall -> unmarshall 
%   -> algorithm libmemdraw (and libmemlayer sometimes)
%   -> screen.h interface (mostly flush image)
%   -> vgascr interface -> vgadev interface
%   -> actual hardware special operations


% read/load cload/cread
% unload/write
% ???

% what is the minimum we ask from hardware? just a screen.h interface?
% with a not too bad flushmemscreen? if look at screen.c for raspberry,
% most of screen.c is hardware independent (arrow picture, software cursor, 
% gscreen, window, curpos). The only hardware dependent is fbinit to
% initialize frame buffer. hwdraw() does nothing. flushmemscreen() does
% nothing. They just need a gscreen->bdata to point to a frame buffer
% and set the property of this memimage depending on the hardware
% (width, depth, chan). That's it!


%alt: a stateful API.
% The API of draw stateless, as opposed to ocamlgraphics/cairo/X11/...
% where you move the cursor and then ask to draw stuff. In those systems
% you have a context. Here you specify everything each time.

%\section{Initialization overview}
% more in Chapter X.

%\section{Trace of a mouse click}
% more important in Windows.nw

%\section{Trace of a key press}
% more important in Windows.nw

\section{Book structure}

%trans: %dup: (and adapted) from Assembler.nw
You now have enough background to understand the source code of [[draw]].
%toc:
The rest of the book is organized as follows.
%
I will start by describing the core data structures of [[draw]]
in Chapter~\ref{chap:core-ds}.
%
Then, in Chapter~\ref{chap:init}, I will explain
how [[draw]] is initialized, both on the kernel side,
where the graphics card needs to be configured for a particular
resolution, and on the user side, where client applications
need to connect to the display server.
%
Chapter~\ref{chap:user-kernel-bridge} will focus on the bridge
between the user and the kernel. I will explain how
client applications communicate with the display server.

The following chapters will describe the different
functions of the [[draw]] API: 
Chapter~\ref{chap:images} the functions to allocate images
(e.g. [[allocimage()]]), 
Chapter~\ref{chap:draw} the central function [[draw()]] to manipulate
rectangles, 
Chapter~\ref{chap:drawing-shapes} the functions to draw shapes
(e.g. [[line()]]),
\l rely on draw
Chapter~\ref{chap:fonts} the functions to draw text
(e.g. [[string()]],
\l rely also on draw
and finally Chapter~\ref{chap:image-io} the functions to load and save images 
(e.g. [[loadimage()]]).
\l Image IO not draw, not vector but raster, pixel directly.

In Chapter~\ref{chap:input}, I will describe the functions of [[draw]]
that programs can use to interact with input devices, especially the mouse.
The mouse is the primary device used in graphical applications,
and its use leads to the animation of some graphics on the screen: 
the {mouse cursor}.
\n not in draw.h, in mouse.h and keyboard.h, but code is in libdraw/

Chapter~\ref{chap:overlapping-windows} and Chapter~\ref{chap:windowing-support}
will present a major image extension: overlapping layers.
They are one of the building blocks to implement a windowing system,
but they can also be used in regular applications
(e.g., the \plan editor [[acme]]).

Some of the code in Chapter~\ref{chap:images} through
\ref{chap:image-io} will be simplified to show
only the parts of the code that handle 32-bits images.
However, a real graphics system must support different image formats:
24-bits, 16-bits, 8 bits, images using color maps, or
even bitmaps. A graphics system must be able to copy the
pixels from one image using one format, to another image
using an entirely different format. I will cover
all those cases in Chapter~\ref{chap:non-true-color}.
% 
Chapter~\ref{chap:advanced} presents other
features of [[draw]] which I did not show 
before to simplify the explanations, for instance,
the support for Bezier curves, or optimizations in 
certain drawing functions.

Finally, Chapter~\ref{chap:conclusion} concludes
and gives pointers to other books in the \principia series.

%toc: %dup: (adapted) Assembler.nw
Some appendices present the code of non-functional properties:
code to help debug [[draw]] in Appendix~\ref{chap:debugging-appendix}, 
and code to manage errors in Appendix~\ref{chap:error}.
%
Appendix~\ref{chap:math} contains the code of generic
mathematic functions used by [[draw]], but which are
not unique to [[draw]].
\l hmm actually a bit specific
%
Appendix~\ref{chap:raspberry-pi-graphic-card} and \ref{chap:pc-vga-driver}
will present the code for the device drivers of two traditional graphics cards.
%
Finally, Appendix~\ref{chap:examples} contains more examples of
graphical applications to get a better feel of how to use [[draw]]
in practice.







%###############################################################################

\chapter{Core Data Structures}
\label{chap:core-ds}

\begin{verse}
\begin{flushright}
  {\it Show me your code and conceal your data structures, and I shall
    continue to be mystified. Show me your data structures, and I
    won't usually need your code; it'll be obvious.\\
    ~\\
    Fred Brooks}
\end{flushright}
\end{verse}


%toc:
In this chapter, I will present the most important data structures of [[draw]].
Most of them are defined in [[draw.h]]; the others are defined in the kernel,
but they relate to structures from [[draw.h]].
For instance, [[Client]], which is defined in [[devdraw.c]],
is the kernel equivalent of [[Display]], which is defined in [[draw.h]].
\l also memdraw.h

\n many important globals are in libdraw/globals.c
\l hmm, lots of DS to present.

\n many section titles mimic the section of overview/principles, which is good

\section{Geometry}
\n put early cos many API mention Point and Rectangle, so core DS

%trans: before image, display, basics! geometry!

% screen is by convention growing right and down. (0,0), (640,480),
% so (0,0) is top left.
%alt: see already that lack of float is annoying; in codemap I can map
%  this to a virtual (0,0), (1,1) in float!
%alt: why not like math 0,0 is at lower left?

% FIGURE! with screen, point and rectangle

% see addpt(2)
% http://blog.golang.org/go-image-package

\subsection{[[Point]]}

<<struct Point>>=
struct	Point
{
    int	x;
    int	y;
};
@
% int! they are pixels! (good and bad, anyway can be building block for more)
\l RasterOp model. opposed to Postscript imaging model?
%alt: %real-world: floats as in cairo
% more device-independent, let computer do the math to adapt to screen.
% Big deal. but can have wrapper library.
%device-coordinate (or screen-coordinate) vs world-coordinate

% can be interpreted as a vector too sometimes.
\l typedef Point Vector; ?

%ctor
<<function Pt>>=
Point
Pt(int x, int y)
{
    Point p;

    p.x = x;
    p.y = y;
    return p;
}
@
%ocaml: ocaml does not require some copy here. can return "shared value".
%c: no allocation so convenient. No malloc/free needed.

<<function eqpt>>=
bool
eqpt(Point p, Point q)
{
    return p.x==q.x && p.y==q.y;
}
@
%ocaml: builtin = does that


<<global ZP>>=
Point	ZP;
@
% Zero point, used a lot for default argument.
%ocaml: explicit initialize instead of bss default 0 initialization

% arithmetic on points

<<function addpt>>=
Point
addpt(Point a, Point b)
{
    a.x += b.x;
    a.y += b.y;
    return a;
}
@
%ocaml: factorize code of all binary operations 'binary op pt1 pt2'
%ocaml: some copy involved (but in ocaml functional too so allocate new one)

<<function subpt>>=
Point
subpt(Point a, Point b)
{
    a.x -= b.x;
    a.y -= b.y;
    return a;
}
@

<<function mulpt>>=
Point
mulpt(Point a, int b)
{
    a.x *= b;
    a.y *= b;
    return a;
}
@

<<function divpt>>=
Point
divpt(Point a, int b)
{
    a.x /= b;
    a.y /= b;
    return a;
}
@


\subsection{[[Rectangle]]}

% rectangle defined by two point, upper-left and lower right.

<<struct Rectangle>>=
struct Rectangle
{
    Point	min;
    Point	max;
};
@

% max is first point outside
% so Rect(0,0, 100, 100) is from 0,0 to 99,99 and so is of length 100.
% A bit like 0-indexed array, max express the size.


% enforced max > min? canonrect!
% kind of ctor (law)
<<function canonrect>>=
Rectangle
canonrect(Rectangle r)
{
    int t;
    if (r.max.x < r.min.x) {
        t = r.min.x;
        r.min.x = r.max.x;
        r.max.x = t;
    }
    if (r.max.y < r.min.y) {
        t = r.min.y;
        r.min.y = r.max.y;
        r.max.y = t;
    }
    return r;
}
@
%ocaml: takes 2 points, because actual use cases and then
% use simply pervasives min and max

% how can have one but not the other?
% FIGURE where at center point p1, and then p1 can be 4 different places
%  (higher/before, higher/after, lower/before, lower/after)

% ex of use in Windows.nw: r = canonrect(Rpt(p0, p));
% but you don't know if p0 is in regards to p because when you draw
% a rectangle, you set 2 points, but can go in any direction.


%ctor
<<function Rect>>=
Rectangle
Rect(int ax, int ay, int bx, int by)
{
    Rectangle r;

    r.min.x = ax;
    r.min.y = ay;
    r.max.x = bx;
    r.max.y = by;
    return r;
}
@

%ctor
<<function Rpt>>=
Rectangle
Rpt(Point min, Point max)
{
    Rectangle r;

    r.min = min;
    r.max = max;
    return r;
}
@
% no alloc. By value. They prefer to pay the cost of copy so simpler API.
%update: but actually in many places they inline the code :(


<<function eqrect>>=
bool
eqrect(Rectangle r, Rectangle s)
{
    return r.min.x==s.min.x && r.max.x==s.max.x &&
           r.min.y==s.min.y && r.max.y==s.max.y;
}
@
%ocaml: builtin, no need define one

<<global ZR>>=
Rectangle ZR;
@
\l more empty rectangle than zero rectangle


<<function Dx>>=
#define	Dx(r)	((r).max.x - (r).min.x)
@
% width
%ocaml: no need macros, ocaml has a good cross module inliner!

<<function Dy>>=
#define	Dy(r)	((r).max.y - (r).min.y)
@
% height

% arith too

<<function rectaddpt>>=
Rectangle
rectaddpt(Rectangle r, Point p)
{
    r.min.x += p.x;
    r.min.y += p.y;
    r.max.x += p.x;
    r.max.y += p.y;
    return r;
}
@
%ocaml: again can factorize by using higher-order function

% p is kinda interpreted as a vector here

<<function rectsubpt>>=
Rectangle
rectsubpt(Rectangle r, Point p)
{
    r.min.x -= p.x;
    r.min.y -= p.y;
    r.max.x -= p.x;
    r.max.y -= p.y;
    return r;
}
@




<<function ptinrect>>=
bool
ptinrect(Point p, Rectangle r)
{
    return p.x >= r.min.x && p.x < r.max.x &&
           p.y >= r.min.y && p.y < r.max.y;
}
@
% use strict < for max because max is not part of rectangle! 
% first point outside


<<function rectinrect>>=
bool
rectinrect(Rectangle r, Rectangle s)
{
    return s.min.x <= r.min.x && r.max.x <= s.max.x && 
           s.min.y <= r.min.y && r.max.y <= s.max.y;
}
@
% r is in s



<<function rectXrect>>=
bool
rectXrect(Rectangle r, Rectangle s)
{
    return r.min.x < s.max.x && s.min.x < r.max.x &&
           r.min.y < s.max.y && s.min.y < r.max.y;
}
@
% FIGURE (check if intersection non empty)




\n insetrect() later with border()
\n combinerect() later with flush

% no DS for lines, ellipses, etc. Instead parameter of drawing functions.
% will see later Line, Polyline, Ellipse, Arcs, 
% but they all use Pt and Rectangle for their parameters.

\l bytesperline here?
\l rectclip here?

\section{[[Display]] (and [[Client]])}
% and [[display]]

%trans: saw in overview chapter, /dev/draw files, and client/server archi.
% need client and server DS. 
%clients have Server and server has Client.

% Display server.

% connection to device, and client handler!
% initdraw()

\subsection{[[Display]] and [[display]]}

% user side, can see it as essentially a connection handler,
% most things in plan9 done via files! including drawing!
<<struct Display>>=
struct Display
{
    // ref_own<Image>, the full screen
    Image	*image;

    <<[[Display]] devdraw connection fields>>
    <<[[Display]] buffer fields>>
    <<[[Display]] basic images fields>>
    <<[[Display]] font fields>>
    <<[[Display]] other fields>>

    // Extra
    <<[[Display]] concurrency fields>>
};
@
% ctor = initdisplay <- initdraw, shown later
%dead:
% bool	local;
% ulong	dataqid;

% we will see Image later.

% rename image field to screen/view? is it the same than global screen/view?
% NO! it's not the same. it's the whole screen here.
% actually even when run under rio you can draw on the rest :( ugly.
\t rename to screen!! now that I have cleaned up screen-name issues
\t  by using instead view and desktop (still todo last part)


% why not just a fd to device file? because complex device, device
% directory actually. and buffer. and protocol! and other stuff we
% want to hide.

% mostly Image and buffer with command to be flushed to device.


%!!!!
<<global display>>=
// option<Display>
Display	*display;
@
%ocaml: return value instead of using global? why need global?
% can pass display to the line/draw/ellipse/... through Image.display
% so not really need a global!

% <> = ... <- initdraw
% Could be returned instead? So API would be opendisplay()?
% Easier that way? no need to pass it everywhere?
% But anyway it's true that when use Image there is anyway a ref
% to Display so maybe it could be returned; after all closedisplay()
% takes it as a parameter.
% But global because initdraw actually sets more than one global, so
% if was opendisplay it would need to return a 4-uple
% (display, screen, view, font)

% can have multiple displays? probably so one program
% can draw to multiple screens :)


% so code for most of this book could use directly
%  display->image but we will see later better use view
%  which handles both when run under rio or not.



<<[[Display]] devdraw connection fields>>=
int		dirno; // /dev/draw/x
fdt		ctlfd; // /dev/draw/x/ctl (opened via /dev/draw/new)
fdt		fd;    // /dev/draw/x/data
@

% just for debugging I think, have ctlfd and fd already
<<[[Display]] devdraw connection fields>>=
char	*devdir; // /dev in general
char	*windir; // /dev in general
@
\t mv windir out of it? 
\l useful? anyway it's always /dev


% usually have draw(dstimg, rectangle, srcimg, maskimg)
% and srcimg can be just black, and maskimg can be just opaque
% the abuse image for many things, because it's more general!
% Black is an image! (1x1 pixels)

<<[[Display]] basic images fields>>=
// ref_own<Image>
Image	*white;
// ref_own<Image>
Image	*black;

// ref_own<Image>
Image	*opaque;
// ref_own<Image>
Image	*transparent;
@
% colors are images! masks are images! uniform

% why here? convenient for program?
% allocated and set in initdisplay() (and redirect to shared
% memimage in kernel)




% could use Display->image directly, but as we will see later,
% windowing system so advice use another image(actually window) instead
% (view).

%alt: X11 has also a Display structure

\subsection{[[Client]]}

% kernel side. Graphics server have a set of clients. 
% need to represent those clients.

\l rename KClient! 
<<struct Client>>=
struct Client
{
    int     clientid; // /dev/draw/x/

    // hash<Image.id, ref_own<Dimage>> (next = Dimage.next in bucket)
    DImage*     dimage[NHASH];

    <<[[Client]] drawing state fields>>
    <<[[Client]] layer fields>>
    <<[[Client]] other fields>>

    // Extra
    <<[[Client]] concurrency fields>>
    Ref     r;
};
@
% ctor = drawnewclient() <- drawopen(Qnew)    (see below for drawnewclient)

% manage set of images! draw op state too!

% Image will have id! need id for bridge user/kernel, to avoid
% passing around big DS.

% ref! once every file has been close in /dev/draw/x/ then
% resource free.
% can share client? if create proc? if attach to another display?


<<constant NHASH bis>>=
#define NHASH       (1<<5)
@
% >>
<<constant HASHMASK>>=
#define HASHMASK    (NHASH-1)
@
<<[[DImage]] extra fields>>=
DImage*     next;
@
% we will see soon Dimage

% big array ... big hash. no collision for a long time
% for first 2^5 images.
% lots of space in kernel :(

<<function drawlookup>>=
DImage*
drawlookup(Client *client, int id, bool checkname)
{
    DImage *d;

    d = client->dimage[id&HASHMASK];
    while(d){
        if(d->id == id){
            <<[[drawlookup()]] if checkname>>
            return d;
        }
        d = d->next;
    }
    return nil;
}
@
% drawimage() returns instead directly the Memimage

\t checkname??

\subsection{[[KDraw]] and [[sdraw]]}
\n hard to not expose now, cos relation between DImage, DName, Client subtle
\l rename to Clients? also rename its client to clients field.

% this is needed only because draw is a display server. It does not have
% to be though. rio could multiplex /dev/draw.

<<struct KDraw>>=
struct KDraw
{
    // growing_array<option<Client>> (size = KDraw.nclient)
    Client**    client;
    int     nclient;

    // gensym
    int     clientid;
    
    <<[[KDraw]] other fields>>
};
@
% entries in KDraw.client are called "slots"
\l rename clientid? make it more obvious that it is a counter.



%no ctor needed, singleton
<<global sdraw>>=
KDraw        sdraw;
@
% why sdraw? static draw? why not kdraw?


<<[[Client]] other fields>>=
// index in KDraw.clients[]
int     slot;
@
% different than Client.clientid as can reuse a free slot
% but clientid always increment. can have /dev/draw/1233322
% after 6 months :)


% sysopen -> ... -> drawopen(Qnew) -> <>
%ctor
<<function drawnewclient>>=
Client*
drawnewclient(void)
{
    Client *cl, **cp;
    int i;

    // find free slot
    for(i=0; i<sdraw.nclient; i++){
        cl = sdraw.client[i];
        // found one? then i contains the free slot number.
        if(cl == nil)
            break;
    }
    <<[[drawnewclient()]] grow array if necessary>>

    cl = malloc(sizeof(Client));
    <<[[drawnewclient()]] sanity check cl>>
    memset(cl, 0, sizeof(Client));
    cl->slot = i;
    cl->clientid = ++sdraw.clientid;
    cl->op = SoverD; // The classic
    sdraw.client[i] = cl;
    return cl;
}
@
% ++ so starts at 1 (because static kdraw.clientid is 0)
% could do too cl->infoid = 0; here.  Clearer. Implicit in malloc.
% note that Client.r set to 0. It is marked as used only when
%  the /dev/draw/x/data (or another file) is opened.

<<[[drawnewclient()]] grow array if necessary>>=
// growing array
if(i == sdraw.nclient){
    cp = malloc((sdraw.nclient+1)*sizeof(Client*));
    <<[[drawnewclient()]] sanity check cp>>
    memmove(cp, sdraw.client, sdraw.nclient*sizeof(Client*));
    free(sdraw.client);
    sdraw.client = cp;
    sdraw.nclient++;
    cp[i] = nil;
}
@
\l grow just by 1?



<<[[drawnewclient()]] sanity check cl>>=
if(cl == nil)
    return nil;
@
<<[[drawnewclient()]] sanity check cp>>=
if(cp == nil)
    return nil;
@





\section{[[Image]] (and [[Memimage]])}
% and [[screen/view]],  and DImage?

% Images in plan9 draw are specials! (see plan9-in-technicolor.ps!)
% used for many things. Screen, off-screen (temp) images, 
% colors, fonts, masks, etc.
% even windows!

% unify on-screen and offscreen data

%real-world: called pixmap in Twin, probably X11, and more.

\subsection{[[Image]]}
% and [[view]]

% Display.image! here is Image.
% The screen is an image (id = 0).

<<struct Image>>=
struct Image
{
    int			id;		/* id of system-held Image */

    Rectangle	r;		/* rectangle in data area, local coords */

    channels		chan; // image format
    // derives from Image.chan
    int			depth;		/* number of bits per pixel */

    Rectangle 	clipr;	/* clipping region */
    bool		repl;	/* flag: data replicates to tile clipr */

    Display		*display;	/* display holding data */

    <<[[Image]] layer fields>>

    // Extra
    <<[[Image]] extra fields>>
};
@
%ocaml: mutual recursive type between Image and Display

% ctor = allocimage (doing some RPC)

% will see chan, the image format later (basically how many bytes
% per colors and in which order, e.g., rgba32)

% display + id => can communicate to kernel what we are talking about.
%  need Display pointer because when do draw operation we need
%  to write in img->display.buf! and then flushimage(img->display)!
%  we need the connection handler! (but could use global ...)

% Just need to pass id to kernel! no need to pass all pixels, and info.
% In fact most of the fields above are duplicate of in kernel DS.

%alt: here no data! just id. alternative models?
%real-world: cairo? no client/server for most images, just pointer
% and many functions over pointer.

% read from /dev/draw/new initially when open the connection
%  see initdisplay() 
% system-held id! usually 0 for the first image of /dev/draw/new
%  for the frame buffer.
% incremented then at each allocimage, thx to Display.imageid field

% Rectangle r. Most of the time starts at 0,0 if full screen but can have
% other format. 
% Why need that? not sure you need really.
% When have windows, get actually a sub rectangle of the full image
% and share internally the same data.
% (but actually can have logical coord then and starts at 0, 0)
% Or when to separate your drawing algo in different parts, you
% can allocate different image for different parts with as a rectangle
% the final destination. Then you can just copy those images on
% the screen and use its rectangle as the dst. But could do without I think.
% Can have multiple rectangles over same shared big image.
% (but could use clipr)


% diff between .r and .clipr? use .r to do stuff like
%  draw_line(10 + r.min.x, 20 + r.min.y, ...). A bit tedious.
%  would be better to abstract this for clients.
% For most images used as source or masks or colors it is 
%  simply Rect(0, 0, width, height)
\l and clipr? maybe could delay its introduction

% clipping notion!! 
% repl notion!! from draw(2):
%  "A boolean value specifying whether the image is tiled to cover
%  the plane when used as a source for a drawing operation."
% chan notion!!
%  alpha notion!!
%  depth notion!

% for r, clipr, repl, see plan9-in-technicolor.ps!
%/* huge but not infinite, so various offsets will leave it huge, not overflow*/
% clipr = Rect(-0x3FFFFFFF, -0x3FFFFFFF, 0x3FFFFFFF, 0x3FFFFFFF);


% Image.display is of Display->image? not necessaraly I think, only
% the main image (screen) is.


\l typedef int imageid;? screenid? windowid?
% hmm but for imageid actually on user side we return Image* not imageid
% so this imageid typedef will be really internal to libdraw

<<[[Display]] other fields>>=
// gensym
int		imageid;
@
% counter, incremented each allocimage(), rename imageidcnt?
% why need that client side? id allocation is handled in kernel no?
% apparently not, kernel actually just check that passed id is indeed
% unused (in Client DImage hash).



\subsection{[[Memimage]]}
% rename draw_screen, screen_screen, vga_screen

% Equivalent of Image but on kernel side. Very similar fields
% to Image.

<<struct Memimage>>=
struct Memimage
{
    Rectangle	r;		/* rectangle in data area, local coords */

    channels	chan;	/* channel descriptions */
    // derives from Memimage.chan
    int		depth;	/* number of bits of storage per pixel */
    int		nchan;	/* number of channels */

    Rectangle	clipr;		/* clipping region */
    //bitset<enum<fxxx>, // includes if replicate via Frepl
    ulong	flags; 

    // finally, the raw pixels
    // ref_own<Memdata>
    Memdata	*data;	/* pointer to data; shared by windows in this image */

    <<[[MemImage]] layer fields>>
    <<[[MemImage]] other fields>>
};
@
%ctor = allocmemimaged <- (makescreenimage <- ... <- drawattach) | allocmemimage
% shown later cos complicated, memsetchan, etc
%less: no repl here? yes, it's flags. rename repl?

% depth is sum of bits per pixel for r/g/b, so for RGB16 it's ... 16

%no int id; here! Id is really because of User/kernel communication need.
% id is in parent DImage, so also can share same MemImage
% with different id in different clients
% (e.g., the screen, but also imagewhite, etc (even though all of
% those should have same id in client too)

% important diff with Image, data field! this is the real image!
% not just a handler.

% Note that share also Memdata! many Memimage can be different
% views of the same Memdata (e.g., the screen). Efficient. No copy.
% This is why also have Rectangle r. Windows will be sub rectangle
% over shared screen Memdata.
% Hmm API to get subrectangle of existing Image? allocimage??

% flags is more general than Image.repl; contains info derived
%  from channel too
% this is not in draw.h! this is in memdraw.h so internal to Memimage
<<enum fxxx>>=
enum {
    Frepl	= 1<<0,	/* is replicated */

    // derives from Memimage.chan
    Fgrey	= 1<<2,	/* is grey */
    Falpha	= 1<<3,	/* has explicit alpha */
    Fcmap	= 1<<4,	/* has cmap channel */
    Fbytes	= 1<<5,	/* has only 8-bit channels */
};
@
%dead:    Fsimple	= 1<<1,	/* is 1x1 */
% >> >> >> >> >> >>

%Fbytes does not mean CMAP8, it means 8 bits depth but possibly multiple
% channels

% start of pbs, many different image formats ...

% all important notions!




% libmemdraw/draw.c

% setup in memimageinit
<<global memones>>=
static Memimage*	memones;
@
<<global memzeros>>=
static Memimage*	memzeros;
@
% 1x1 images, Grey1
% Shared by all clients?

% pending of Display->white, Display->opaque, etc? I dont think so
%  more for stuff used internally by kernel. Display->white and Display->back
%  seems to be allocimage each time in each initdisplay()
<<global memwhite>>=
Memimage *memwhite;
@
<<global memblack>>=
Memimage *memblack;
@
<<global memtransparent>>=
Memimage *memtransparent;
@
<<global memopaque>>=
Memimage *memopaque;
@




\subsection{[[Memdata]]}

<<struct Memdata>>=
/*
 * Memdata is allocated from main pool, but .data from the image pool.
 * Memdata is allocated separately to permit patching its pointer after
 * compaction when windows share the image data.
 * The first word of data is a back pointer to the Memdata, to find
 * The word to patch.
 */
struct Memdata
{
    ulong	*base;	/* allocated data pointer */
    // the pixels!
    byte	*bdata;	/* pointer to first byte of actual data; word-aligned */

    <<[[Memdata]] other fields>>
    // Extra
    int		ref;		/* number of Memimages using this data */
};
@
% ctor = makescreenimage | allocmemimage
\l why not a Ref?
\t base must be first field?

% another intermediate, wrapper in Memimage for compaction
%  need mentioned in comment (see imagemove callback)

% the raw pixel data! but to know where to modify you need
% to understand the format of the image, the #channels, depths
% of channels, etc.

\t FIGURE to explain diff between .base and .bdata (and .zero)
% base is poolalloc raw pointer, then at this address 
% - first word is backpointer to Memdata structure, 
% - second word is callerpc for debugging
% - then the actual pixels

% this is kinda a frame buffer. But actually needs one
% operation to transfer from this memory to the actual screen?
% hmm flushmemscreen is responsible for that, but it can be a nope
% when bdata is already pointing to the frame buffer.
% the vga driver does a copy though probably.
% but anyway bdata is not necessaraly for the frame buffer, it can
% be any images the user works on.
% see also ishwimage()

% could put a generic ishwimage here! that just check if 
% i->data->bdata == gscreen->data->bdata!


<<[[MemImage]] other fields>>=
int		zero;		/* data->bdata+zero==&byte containing (0,0) */
ulong	width;	/* width in words of a single scan line */
@
\t zero is complicated because some Memdata correspond to
\t  rectangle which do not start at 0,0
\l rename wwidth? vs bwidth?

% libmemdraw/alloc.c
<<function byteaddr>>=
byte*
byteaddr(Memimage *i, Point p)
{
    byte *a;

    a = (i->data->bdata + i->zero) + (sizeof(ulong) * p.y * i->width);

    <<[[byteaddr()]] if depth less than 8>>
    else
        return a + p.x * (i->depth/8);
}
@
% should sanity check still valid pointer?? that in valid range?




\subsection{[[screenimage]], [[gscreen]], and  and [[gscreendata]]}

% [[devdraw]] interface

% put in core DS chapter? merge with screen.h gscreen no?
% the frame buffer!! (at least call like that in error msg when nil)
<<global screenimage>>=
Memimage    *screenimage;
@
\t rename draw_screen!
% screendimage->image (less: so could remove this semi global)
%TODO: vs gscreen????? rename vga_screen?


%[[screen.h]] interface

% there will be lots of Memimage, but an important one is
% the screen!

% screen.c, relation to Display->image? to screen/view? g? global screen?
%  rename gview? more consistent with our new naming? No, here it's
%  really the screen.

% kinda pending of view when run app on whole screen.
% (but in fact it's not when run under rio)

<<global gscreen>>=
Memimage *gscreen;
@
\t rename screen? (aka screen_screen but seems heavy)
\t   not gview I think, here it's really the screen

%todo: put global kernel gscreen for chunkname? or global gscreen(kernel)
% like I did for (arm) and (386)
%this is set in screensize() by VGA driver

% unfortunate that use term "Screen" already used for other stuff.
% just like have [[screen/view]], client side,
% have also gscreendimage and gscreen kernel side

%[[vga.h]] interface?? vga_screen global?


% This used to be called the [[VGAscr]] section.
% But what matters is not so much VGA but the screen.h interface.
% We actually moved more stuff to a generic screen.c, to be closer
% to the simplicity of bcm/screen.c. We don't want to expose ugly
% VGA details when nowadays things are simpler like the frame buffer
% interface of the raspberry.

% this used to be in vgascreen.c, but every archi was defining
% such a gscreen, so makes sense to factorize in a screen.c.
% there also used to be a vgascreen[0].gscreen (see screensize()), but
% this was redundant then with gscreen.



<<global gscreendata>>=
Memdata gscreendata;
@
% not a pointer, gscreen->data = &gscreendata.
% gscreendata.data will point to virtual address of frame buffer!




\subsection{[[DImage]]}
% and screendimage

% Saw memimage but in fact as we saw before client instead have
% DImage cache. 

% Why yet another intermediate? Because need id only because of
% kernel/user need. Memimage has no id. Here need kernel wrapper
% over Memimage with id.
% Also because need id only when have User/kernel separation.
% Appli could use directly Memimage (and some do).

% Also id might be different in different client but same shared image!

% why D? For Draw Image. Cos have Image, Memimage (memdraw),
% and DImage for kernel stuff. Indeed can use lots of the graphics
% stack independently of the kernel and draw device.

<<struct DImage>>=
/*
 * Reference counts in DImages:
 *  one per open by original client
 *  one per screen image or fill
 *  one per image derived from this one by name
 */
struct DImage
{
    int     id;
    Memimage*   image;

    <<[[DImage]] layer fields>>
    <<[[DImage]] font fields>>
    <<[[DImage]] other fields>>

    // Extra
    <<[[DImage]] extra fields>>
    int     ref;
};
@
% why not merged with Memimage? Why wrapper? cos of id!
% so can share Memimage but each client has own DImage "view"
% of those shared Memimage (including the screen!!).
% intermediate so can share underlying Memimage.
% Also why id is here, cos id could be different for same Memimage

\l comment above is hard to understand

%ctor
<<function allocdimage>>=
/// makescreenimage | drawinstall -> <>
DImage*
allocdimage(Memimage *i)
{
    DImage *d;

    d = malloc(sizeof(DImage));
    <<[[allocdimage()]] sanity check d>>
    d->image = i;
    d->ref = 1;

    d->name = nil;
    d->fromname = nil;
    d->vers = 0;
    d->nfchar = 0;
    d->fchar = 0;

    return d;
}
@
% no id? done by drawinstall (for instance when open Qctl in
% which case it is set to 0!)


<<[[allocdimage()]] sanity check d>>=
if(d == nil)
    return nil;
@

%\subsection{[[DName]]}
% related to windowing system so moved later


\section{Channels}
\label{sec:channels}

<<type channels>>=
typedef ulong channels;
@
%ocaml: more complex type, than then get serialized/deserialized correctly
%c: complex structure in one int by (ab)using bit operations

% =~ image format. How many bits, what bytes represent which color.
% This + rectangle = image resolution.

%trans: Image.chan and Memimage.chan
% saw ulong chan; in Image and Memimage.

% not thread channel, not kernel Chan, image channels here!
% ulong in previous struct, but more complex format actually.

<<enum ImageChan>>=
/*
 * image channel descriptors 
 */
// coupling: chantostr and channames
enum ImageChan {
    CRed = 0,
    CGreen,
    CBlue,

    CGrey,
    CAlpha,

    CMap,
    <<[[ImageChan]] cases>>

    NChan,
};
@
\n use Chan not Channel to avoid confusing with thread.h struct Channel.
\l I would like to move CAlpha after Blue, but maybe font files
\l  rely on this order

%  4      4
% -------------
% type | nbits
% -------------

%ctor
<<function __DC>>=
#define __DC(type, nbits)	((((type)&15)<<4)|((nbits)&15))
@
% >>
%ocaml: use that only when serializing

%extractor
<<function NBITS>>=
#define NBITS(c) ((c)&15)
@
<<function TYPE>>=
#define TYPE(c) (((c)>>4)&15)
@
% >> >> >>


% ctors
<<function CHAN1>>=
#define CHAN1(a,b)	__DC(a,b)
@

<<function CHAN2>>=
#define CHAN2(a,b,c,d)	(CHAN1((a),(b))<<8|__DC((c),(d)))
@

<<function CHAN3>>=
#define CHAN3(a,b,c,d,e,f)	(CHAN2((a),(b),(c),(d))<<8|__DC((e),(f)))
@

<<function CHAN4>>=
#define CHAN4(a,b,c,d,e,f,g,h)	(CHAN3((a),(b),(c),(d),(e),(f))<<8|__DC((g),(h)))
@
% >> >> >>

% no Chan5 because it would not fit in 32 bits

% most common image formats:

<<enum ImageType>>=
enum ImageType {
    GREY1	= CHAN1(CGrey, 1), // used for masks, fonts (black and white)
    CMAP8	= CHAN1(CMap, 8), // PC graphics mode by default, 1 byte per pixel
    RGB16	= CHAN3(CRed, 5, CGreen, 6, CBlue, 5), // Raspberry mode by default
    RGBA32	= CHAN4(CRed, 8, CGreen, 8, CBlue, 8, CAlpha, 8), // flexible
    ARGB32	= CHAN4(CAlpha, 8, CRed, 8, CGreen, 8, CBlue, 8),/* stupid VGAs */
    <<[[ImageType] cases>>
};
@
% todo: need all of that? could maybe simplify and support less
% image format. That should remove quite some code, e.g., all those
% alphacalcxxx? hmm actually not that much I think.
% cairo has what? RGBA32 no?

% vga is CMAP8 (cat /dev/draw/new -->  m8 for cmap 8 bit)
% bcm is using RGB16 by default (but can be configured for ARGB32)

%real-world: have more than total depth 32 nowaday for colors?

% what is True Color? mentionned in plan9-in-technicolor.ps. It's RGBA32?
% RGB with 8 bytes each = 16 million of colors.


<<function chantodepth>>=
int
chantodepth(ulong c)
{
    int n;

    for(n=0; c; c>>=8){
        <<[[chantodepth()]] sanity check c>>
        n += NBITS(c);
    }
    <<[[chantodepth()]] sanity check n>>
    return n;
}
@

% usually chantodepth() and then bytesperline()?

% see also chantostr in debug, which is also used to give
% readable info in /dev/draw/new/

<<[[chantodepth()]] sanity check c>>=
if(TYPE(c) >= NChan || NBITS(c) > 8 || NBITS(c) <= 0)
    return 0; // warning?
@
%ocaml: no need for typep check; by construction correct

<<[[chantodepth()]] sanity check n>>=
if(n==0 || (n>8 && n%8) || (n<8 && 8%n))
    return 0; // warning?
@
%ocaml: return exn! who checks return value of chantodepth?

% strtochan, chantostr later.




\section{Colors}

<<type rgba>>=
typedef ulong rgba;
@
%pad: I introduced this type, less confusing
%c: again, complex type (quadruple) by (ab)using a simple int
%ocaml: use record (a bit more tedious to build colors from values)

%old school graphics:
% https://www.youtube.com/watch?v=Tfh0ytz8S0k&feature=youtu.be

% actually Color are Image* in plan9 draw!
% a Rect(0,0,1,1), with clipr = infinity and repl = true
% very general so less need draw_mask, or draw_color, instead
% just have a generic draw function where you can pass
% black as the src!

% 32 bits! RGBA 8 bits for each channel, which is
% why has FF as the last bit for almost all the elements below
<<enum Colors>>=
enum
{
    DOpaque			= 0xFFFFFFFF,
    DTransparent	= 0x00000000,/* only useful for allocimage, memfillcolor */

    DBlack		= 0x000000FF,
    DWhite		= 0xFFFFFFFF,

    DRed		= 0xFF0000FF,
    DGreen		= 0x00FF00FF,
    DBlue		= 0x0000FFFF,

    DCyan		= 0x00FFFFFF,
    DMagenta	= 0xFF00FFFF,
    DYellow		= 0xFFFF00FF,

    DPaleyellow	= 0xFFFFAAFF,
    DDarkyellow	= 0xEEEE9EFF,
    DDarkgreen	= 0x448844FF,
    DPalegreen	= 0xAAFFAAFF,
    DMedgreen	= 0x88CC88FF,
    DDarkblue	= 0x000055FF,
    DPalebluegreen= 0xAAFFFFFF,
    DPaleblue	= 0x0000BBFF,
    DBluegreen	= 0x008888FF,
    DGreygreen	= 0x55AAAAFF,
    DPalegreygreen	= 0x9EEEEEFF,
    DYellowgreen	= 0x99994CFF,
    DMedblue		= 0x000099FF,
    DGreyblue		= 0x005DBBFF,
    DPalegreyblue	= 0x4993DDFF,
    DPurpleblue		= 0x8888CCFF,

    DNotacolor	= 0xFFFFFF00, // Alpha = 0, transparent white
    DNofill	= DNotacolor,
    
};
@

%alt: different "color management" model to RGB? ICC profiles? sRGB?
% (mentioned in Xr paper)

\subsection{[[imgtorgba()]]}

% we will see different format, copy from one image to another,
% so may need convert. Usually convert to common base: rgba(32).

% Below pass img but just to get the channel of the image

% memimagedraw -> <>
<<function imgtorgba>>=
rgba
imgtorgba(Memimage *img, ulong val)
{
    byte r, g, b, a;
    ulong chan;
    int nb, v;
    <<[[imgtorgba()]] other locals>>

    a = 0xFF;
    r = g = b = 0xAA;	/* garbage */

    for(chan=img->chan; chan; chan>>=8){
        nb = NBITS(chan);
        v = val&((1<<nb)-1);
        val >>= nb;
        ov = v;
        <<[[imgtorgba()]] duplicate bits if nb less than 8>>

        switch(TYPE(chan)){
        case CRed:
            r = v;
            break;
        case CGreen:
            g = v;
            break;
        case CBlue:
            b = v;
            break;
        case CAlpha:
            a = v;
            break;
        <<[[imgtorgba()]] switch chan type cases>>
        }
    }
    return (r<<24)|(g<<16)|(b<<8)|a;	
}
@
% >> >> >> >>

% so ARGB32 to RGBA32 easy.

% GREY1, CMAP8, RGB16 later in chapter X.


\subsection{[[rgbatoimg()]]}

% memimagedraw | memfillcolor -> <>
<<function rgbatoimg>>=
ulong
rgbatoimg(Memimage *img, rgba rgba)
{
    byte r, g, b, a;
    ulong chan;
    int d, nb;
    ulong v;
    <<[[rgbatoimg()]] other locals>>

    v = 0;
    r = rgba>>24;
    g = rgba>>16;
    b = rgba>>8;
    a = rgba;
    d = 0;
    for(chan=img->chan; chan; chan>>=8){
        nb = NBITS(chan);
        switch(TYPE(chan)){
        case CRed:
            v |= (r>>(8-nb))<<d;
            break;
        case CGreen:
            v |= (g>>(8-nb))<<d;
            break;
        case CBlue:
            v |= (b>>(8-nb))<<d;
            break;
        case CAlpha:
            v |= (a>>(8-nb))<<d;
            break;
        <<[[rgbatoimg()]] switch chan type cases>>
        }
        d += nb;
    }
    DBG1("rgba2img %.8lux = %.*lux\n", rgba, 2*d/8, v);
    return v;
}
@
% >>

% Again, GREY1, CMAP8, RGB16 later in chapter X.



%\subsection{[[setalpha()]]}

%dead:
% API function but not used in any graphical applications (just mahjongg).
% Was maybe a bit interesting to understand alpha but in the end I find
% it confusing. Maybe related to notion of pre-alpha (see wikipedia page
% on alpha compositing)
%   <<function setalpha>>=
%   ulong
%   setalpha(ulong color, uchar alpha)
%   {
%       int red, green, blue;
%   
%       red = (color >> 3*8) & 0xFF;
%       green = (color >> 2*8) & 0xFF;
%       blue = (color >> 1*8) & 0xFF;
%       /* ignore incoming alpha */
%       red = (red * alpha)/255;
%       green = (green * alpha)/255;
%       blue = (blue * alpha)/255;
%       return (red<<3*8) | (green<<2*8) | (blue<<1*8) | (alpha<<0*8);
%   }
%   @
%    >> >> >> >>
\n was in arith.c
% that simple? :) to set alpha you just dillute each rgb components?

\subsection{[[memfillcolor()]]}
\n illustrate well many things

% drawmesg(allocate) | membrush | bellipse | memarc | memlalloc | ... -> <>
<<function memfillcolor>>=
void
memfillcolor(Memimage *i, rgba val)
{
    ulong bits;
    <<[[memfillcolor()]] other colors>>

    if(val == DNofill)
        return;

    bits = rgbatoimg(i, val);
 
    switch(i->depth){
    <<[[memfillcolor()]] switch depth cases>>
    default:	/* 1, 2, 4, 8, 16, 32 */
        <<[[memfillcolor()]] duplicate bits if depth less than 32>>
        memsetl(wordaddr(i, i->r.min), bits, i->width * Dy(i->r));
        break;
    }
}
@
% >>
%old: param as val but confusing, rgba better if don't use typedef.

% memfillcolor (only) -> <>
<<function wordaddr>>=
/*
 * Wordaddr is deprecated.
 */
ulong*
wordaddr(Memimage *i, Point p)
{
    return (ulong*) ((uintptr)byteaddr(i, p) & ~(sizeof(ulong)-1));
}
@


% l for little endian
<<function memsetl>>=
void
memsetl(void *vp, ulong val, int n)
{
    ulong *p, *ep;

    p = vp;
    ep = p+n;
    while(p < ep)
        *p++ = val;
}
@


<<[[memfillcolor()]] other colors>>=
int d;
@
% could be in non-32 bit section
<<[[memfillcolor()]] duplicate bits if depth less than 32>>=
for(d=i->depth; d<32; d*=2)
    // duplicate bits
    bits = (bits << d) | bits;
@
% >>
% \section{Color map}
% now in Adv topics



\section{[[Drawop]]}
% Composition
% hmm put now? delay to later?

% composing algebra, Porter-Duff
% (Duff part of plan9 team (did rc), so maybe good API design)

% take plan9-in-technicolor.ps example with nice racket like
% slides where images are arguments of draw(), like slide 9

%\subsection{[[Drawop]]}

<<[[Client]] drawing state fields>>=
// enum<Drawop>
int     op;
@

<<enum drawop>>=
enum Drawop
{
    /* Porter-Duff compositing operators */
    Clear	= 0,

    SinD	= 8,
    DinS	= 4,
    SoutD	= 2,
    DoutS	= 1,

    S		= SinD|SoutD,
    SoverD	= SinD|SoutD|DoutS, // classic Source over Destination
    SatopD	= SinD|DoutS,
    SxorD	= SoutD|DoutS,

    D		= DinS|DoutS,
    DoverS	= DinS|DoutS|SoutD,
    DatopS	= DinS|SoutD,
    DxorS	= DoutS|SoutD,	/* == SxorD */

    Ncomp = 12,
};
@
% 12 porter duff operators.
% In practice use mostly?

\l FIGUREs ? or delay to later?
% http://www.svgopen.org/2005/papers/abstractsvgopen/ nice figure


%\subsection{[[Memdrawparam]]}
% later now


\section{Fonts}
% present later, already lots of DS to understand ...

\section{Overlapping layers}
\n better to use layer than window for Windows.nw; less risk of confusion

% and screen. and view.
% delay to later!

% moved all of that later and aspectized everything related
% to windowing system (basic stuff already quite complicated
% so let's not complicate it even more)





\chapter{Initializations}
\label{chap:init}
% =~ Main

%kernel/user, server/client, system/app

% different from command line where done by kernel with stdin/stdout

\section{Kernel side}
% part1
% also kinda "Server side". Actually mount and bind are user side
%  operation (triggering kernel side code)
% Better to see first user side?

% complex flow, maybe need a control flow Figure?

\subsection{Binding the VGA device (x86)}
% [[vgascreen]], (-> vga_screen)
%x86

% complex, arch specific, so in appendix, but important part
% is setup vgascreen global  for aux/vgactl I think.

\subsection{Setting the screen size, VGA [[screensize()]] (x86)}
\n put before draw mount as anyway it depends on many globals being set
\n for VGA attachscreen
% [[gscreendata]] and [[gscreen]], ( -> screen, screendata)


%https://en.wikipedia.org/wiki/Direct_Rendering_Manager#Kernel_Mode_Setting


% mounting and then call aux/vga ! which ends up calling screensize?
%  run("/bin/vga", "-l", "1024x768x8", nil); // can add -V to debug vga

\t rename vga_screensize?
% ???aux/vga -> <>
% vgascreen.c
<<function screensize(x86)>>=
int
screensize(int x, int y, int z, ulong chan)
{
    VGAscr *scr = &vgascreen;
    <<[[screensize()]] other locals>>

    <<[[screensize()]] lock>>
    <<[[screensize()]] initializations part1>>

    <<[[screensize()]] set [[gscreendata.bdata]]>>

    <<[[screensize()]] free previous gscreen>>
    // Setting gscreen!!
    gscreen = allocmemimaged(Rect(0,0,x,y), chan, &gscreendata);
    <<[[screensize()]] sanity check gscreen>>

    <<[[screensize()]] vga settings>>
    <<[[screensize()]] unlock>>

    // initial draw
    memimagedraw(gscreen, gscreen->r, memblack, ZP, nil, ZP, S);
    arch_flushmemscreen(gscreen->r);

    <<[[screensize()]] initializations part2>>
    return OK_0;
}
@
% >>

% will see memimagedraw later, and flushmem too
% memblack first memimagedraw! so black screen!


% locking

<<global vgascreenlock(x86)>>=
Lock vgascreenlock;
@
<<[[screensize()]] lock>>=
lock(&vgascreenlock);
if(waserror()){
    unlock(&vgascreenlock);
    nexterror();
}
@
<<[[screensize()]] unlock>>=
unlock(&vgascreenlock);
poperror();
@


% memory

<<[[screensize()]] free previous gscreen>>=
if(gscreen)
    freememimage(gscreen);
@

% error management

<<[[screensize()]] sanity check gscreen>>=
if(gscreen == nil)
    error("no memory for vga memimage");
@

\subsubsection{Soft screen vs frame buffer (x86)}

<<[[screensize()]] set [[gscreendata.bdata]]>>=
if(scr->paddr == 0){
    int width = (x*z)/BI2BY; // width in bytes
    void *p;

    // !!the alloc!!
    p = xalloc(width*y);
    <<[[screensize()]] sanity check p>>
    gscreendata.bdata = p;
    scr->useflush = true;
    <<[[screensize()]] when use softscreen, other settings>>
}
else{
    // direct frame buffer
    gscreendata.bdata = scr->vaddr;
    scr->useflush = (scr->dev && scr->dev->flush);
}
@

%old:
%        int width = (x*z)/BI2WD; // width in words


%In Kernel_extra.nw
%#define BI2BY   8     /* bits per byte */
%#define BI2WD   32      /* bits per word */
%
%#define BY2WD   4     /* bytes per word */
%#define BY2V    8     /* bytes per double word */


% memory handling

% xalloc! for physical screen! for other images, it's poolalloc


% useflush and soft screen or direct frame buffer

<<global softscreen(x86)>>=
static void *softscreen;
@
%gscreendata.bdata when have no frame buffer, xalloced
% could remove and use directly gscreendata.bdata no?
%saved in global so free
\t could be a static of screensize really, so actually no need oldsoft below

<<[[screensize()]] when use softscreen, other settings>>=
softscreen = gscreendata.bdata;
@


<<[[screensize()]] other locals>>=
void *oldsoft;
@
<<[[screensize()]] initializations part1>>=
oldsoft = softscreen;
@
<<[[screensize()]] initializations part2>>=
if(oldsoft)
    xfree(oldsoft);
@



% error handling

<<[[screensize()]] sanity check p>>=
if(p == nil)
    error("no memory for vga soft screen");
@


\subsubsection{[[memimageinit()]]}

<<[[screensize()]] initializations part1>>=
memimageinit();
@
% memblack is used in screensize later for the first memimagedraw so need this

% not sure why called from screensize as the things it sets are size
%  independent. Maybe it could be called from vga?

% screensize | main_test -> <>
% when call to screensize in the kernel? when switch to graphic mode via vgactl?
<<function memimageinit>>=
void
memimageinit(void)
{
    <<[[memimageinit()]] only once guard>>

    <<[[memimageinit()]] set image pool allocator move>>
    <<[[memimageinit()]] initializations>>
    <<[[memimageinit()]] install dumpers>>

    memzeros = allocmemimage(Rect(0,0,1,1), GREY1);
    memzeros->flags |= Frepl;
    memzeros->clipr = Rect(-0x3FFFFFF, -0x3FFFFFF, 0x3FFFFFF, 0x3FFFFFF);
    *byteaddr(memzeros, ZP) = 0;

    memones = allocmemimage(Rect(0,0,1,1), GREY1);
    memones->flags |= Frepl;
    memones->clipr = Rect(-0x3FFFFFF, -0x3FFFFFF, 0x3FFFFFF, 0x3FFFFFF);
    *byteaddr(memones, ZP) = ~0;

    <<[[memimageinit()]] sanity check memxxx>>

    memwhite = memones;
    memblack = memzeros;
    memopaque = memones;
    memtransparent = memzeros;
}
@
% 0x3FFFFFF? means huges but not infinite. clipr far bigger than r so replicate
% indifinitely. and not infinite for overflow issue. See clipping section
% later.

% memimageinit seems quite general, not sure why called from screensize
% why need width/height or chan?

% allocmemimage later
% vs allocmemimaged, no data passed (hence the final d).


<<[[memimageinit()]] sanity check memxxx>>=
if(memones == nil || memzeros == nil)
    assert(0 /*cannot initialize memimage library */);	/* RSC BUG */
@

<<[[memimageinit()]] only once guard>>=
static bool didinit = false;
if(didinit)
    return;
didinit = true;
@

\subsubsection{[[memimagemove()]]}

% need understand pool allocator in Libcore.nw

<<[[memimageinit()]] set image pool allocator move>>=
if(  strcmp(imagmem->name, "Image") == 0 
  || strcmp(imagmem->name, "image") == 0
  )
    imagmem->move = memimagemove;
@


% mv earlier? closer to Memdata?
% kernel interface?
% ??? -> <> (imag->move = <> <- memimageinit)
<<function memimagemove>>=
void
memimagemove(void *from, void *to)
{
    Memdata *md;

    md = *(Memdata**)to;
    <<[[memimagemove()]] sanity check md base>>
    md->base = to;

    /* if allocmemimage changes this must change too */
    md->bdata = (byte*)md->base + sizeof(Memdata*) + sizeof(ulong);
}
@
% if compress images pool, then pointer can move, so need
% way to find back stuff pointings to those images. Fortunately
% have back pointer in the array itself.

\t FIGURE hard to understand layout, see also code of allocmemimage

<<[[memimagemove()]] sanity check md base>>=
if(md->base != from){
    print("compacted data not right: #%p\n", md->base);
    abort();
}
@


\subsection{Binding the [[draw]] device}
% screenimage (-> draw_screen)

% see kernel init
% bind #i /dev
%  bind_safe("#i", "/dev", MAFTER); // devdraw
% after vga device has been installed (so attachscreen can work)


% ??sysbind?? -> <> (drawdevtab.attach = <> <- toplevel)
<<function drawattach>>=
static Chan*
drawattach(char *spec)
{
    dlock();
    if(!initscreenimage()){
        dunlock();
        error("no frame buffer");
    }
    dunlock();

    return devattach('i', spec);
}
@
% dlock/dunlock?
% will see other device draw ops later

<<global drawlock>>=
QLock   drawlock;
@
% protect? sdraw? screenimage?

<<function dlock>>=
void
dlock(void)
{
    qlock(&drawlock);
}
@
<<function candlock>>=
int
candlock(void)
{
    return canqlock(&drawlock);
}
@
<<function dunlock>>=
void
dunlock(void)
{
    qunlock(&drawlock);
}
@
% this is kernel side. because shared DS.
% client side you may have to use lockdisplay() to protect user DS
%  if multi process.

\subsubsection{[[initscreenimage()]]}

% drawattach -> <>
<<function initscreenimage>>=
error0
initscreenimage(void)
{

    <<[[initscreenimage()]] only once guard>>

    screendimage = makescreenimage();
    <<[[initscreenimage()]] sanity check screendimage>>
    screenimage = screendimage->image;

    <<[[initscreenimage()]] other initializations>>
    return OK_1;
}
@
%old:    //DBG1("initscreenimage %p %p\n", screendimage, screenimage);


% fuck, another set of globals ... rename gscreendimage?
<<global screendimage>>=
static  DImage* screendimage;
@
\l rename draw_screen_dimage
\t why need this one? anyway will create a new DImage for each
%  client with screenimage wrapped. 
\t for drawaddname????


% sysbind -> drawattach -> initscreenimage -> <>
% less: rename makescreendimage? it returns a DImage here
<<function makescreenimage>>=
static DImage*
makescreenimage(void)
{
    <<[[makescreenimage()]] locals>>

    <<[[makescreenimage()]] allocate Memdata md>>
    <<[[makescreenimage()]] allocate Memimage i>>
    <<[[makescreenimage()]] allocate DImage di>>

    <<[[makescreenimage()]] drawaddname>>

    return di;
}
@
% hmm waserror, refer to kernel book! or maybe put appendix again
% with summary of equivalences with modern exn constructs


%toc:
<<[[makescreenimage()]] locals>>=
Memdata *md;
Memimage *i;
DImage *di;
@




<<[[initscreenimage()]] only once guard>>=
if(screenimage != nil)
    return OK_1;
@

<<[[initscreenimage()]] sanity check screendimage>>=
if(screendimage == nil)
    return ERROR_0;
@

\paragraph{[[Memdata]]}

<<[[makescreenimage()]] allocate Memdata md>>=
// allocate Memdata
md = malloc(sizeof(Memdata));
<<[[makescreenimage()]] sanity check md>>
md->allocd = true;

md->bdata = arch_attachscreen(&r, &chan, &depth, &width, &sdraw.softscreen);
<<[[makescreenimage()]] sanity check md bdata>>
md->base = nil; // not allocated by poolalloc
md->ref = 1;
@
% does not set base?
% screen either allocated by xalloc or direct frame buffer

% this md (of devdraw) is a duplicate of gscreendata (of screen.h)

<<[[KDraw]] other fields>>=
bool     softscreen;
@
% important info for draw to know if need to flush


<<[[Memdata]] other fields>>=
bool	allocd;	/* is this malloc'd? */
@
% how it could be false? for gscreendata!! but then why
\l  we have code that call freexxx on gscreendata?

% here it looks like it is using the bdata returned by attachscreen
%  and this one is really poolalloc?
% it is neither (or really xalloc for softscreen) it is physical frame buffer
% but for that Memdata.base is used to possibly
% free and indeed above it is not set!

<<[[makescreenimage()]] locals>>=
int width, depth;
Rectangle r;
ulong chan;
@
% we will see attachscreen() soon


<<[[makescreenimage()]] sanity check md>>=
if(md == nil)
    return nil;
@

<<[[makescreenimage()]] sanity check md bdata>>=
if(md->bdata == nil){
    free(md);
    return nil;
}
@

\paragraph{[[Memimage]]}

% md set, pass it to allocmemimaged encapsulate in Memimage

<<[[makescreenimage()]] allocate Memimage i>>=
// allocate Memimage
i = allocmemimaged(r, chan, md);
<<[[makescreenimage()]] sanity check i>>
@
%old: why overwrite width and clipr already set in allocmemimaged?
% i->width = width;
% i->clipr = r;
\t assert if i->width != width?


<<[[makescreenimage()]] sanity check i>>=
if(i == nil){
    free(md);
    return nil;
}
@

% allocmemimaged assume md has enough data for 
%  chan2depth(chan) * size rectangle ?

% makescreenimage | allocmemimage -> <>
%Memimage ctor (smaller malloc, just a wrapper over Memdata)
<<function allocmemimaged>>=
Memimage*
allocmemimaged(Rectangle r, ulong chan, Memdata *md)
{
    int d;
    ulong l;
    Memimage *i;

    <<[[allocmemimaged()]] sanity check r>>
    d = chantodepth(chan);
    <<[[allocmemimaged()]] sanity check d>>
    l = wordsperline(r, d);

    i = mallocz(sizeof(Memimage), true);
    <<[[allocmemimaged()]] sanity check i>>

    i->data = md;
    <<[[allocmemimaged()]] set zero field>>
    i->width = l;
    i->r = r;
    i->clipr = r;
    i->flags = 0;

    i->layer = nil;
    i->cmap = memdefcmap;

    if(memsetchan(i, chan) < 0){
        free(i);
        return nil;
    }
    return i;
}
@
% memimaged? d for data because pass the data


% remember Memimage.zero is &byte containing(0,0) (which could
% be outside Memdata if Rectangle starts at Pt(10, 10).

<<[[allocmemimaged()]] set zero field>>=
i->zero = sizeof(ulong) * l * r.min.y;
if(r.min.x >= 0)
    i->zero += (r.min.x*d)/8;
else
    i->zero -= (-r.min.x*d+7)/8;
i->zero = -i->zero;
@
% for screenimage Rectangle.min should be Pt(0, 0).
% If rect starts at Pt(10,10) then zero must be negatif!



<<[[allocmemimaged()]] sanity check r>>=
if(Dx(r) <= 0 || Dy(r) <= 0){
    werrstr("bad rectangle %R", r);
    return nil;
}
@
<<[[allocmemimaged()]] sanity check d>>=
if(d == 0) {
    werrstr("bad channel descriptor %.8lux", chan);
    return nil;
}
@
<<[[allocmemimaged()]] sanity check i>>=
if(i == nil)
    return nil;
@



\t mv earlier? too many stuff here
<<function wordsperline>>=
int
wordsperline(Rectangle r, int d)
{
    return unitsperline(r, d, 8*sizeof(ulong));
}
@

<<function bytesperline>>=
int
bytesperline(Rectangle r, int d)
{
    return unitsperline(r, d, 8);
}
@

<<function unitsperline>>=
static
int
unitsperline(Rectangle r, int d, int bitsperunit)
{
    ulong l, t;

    <<[[unitsperline()]] sanity check d>>

    if(r.min.x >= 0){
        l = (r.max.x*d+bitsperunit-1)/bitsperunit;
        l -= (r.min.x*d)/bitsperunit;
    }else{			/* make positive before divide */
        t = (-r.min.x*d+bitsperunit-1)/bitsperunit;
        l = t+(r.max.x*d+bitsperunit-1)/bitsperunit;
    }
    return l;
}
@


<<[[unitsperline()]] sanity check d>>=
if(d <= 0 || d > 32)	/* being called wrong.  d is image depth. */
    abort();
@



%\section{Channels and alpha}

\t mv with Memimage? or with Channel section? too many stuff here.
% allocmemimage -> allocmemimaged -> <>
%less: mv in Alloc section?
<<function memsetchan>>=
errorneg1
memsetchan(Memimage *i, ulong chan)
{
    int d;
    int t, j, k;
    ulong cc;
    bool bytes;

    d = chantodepth(chan);
    <<[[memsetchan()]] sanity check d>>
    i->chan = chan;
    i->depth = d;
    i->flags &= ~(Fgrey|Falpha|Fcmap|Fbytes);
    bytes = true;

    for(cc=chan, j=0, k=0; cc; j+=NBITS(cc), cc>>=8, k++){
        t=TYPE(cc);
        <<[[memsetchan()]] sanity check t>>
        if(t == CGrey)
            i->flags |= Fgrey;
        if(t == CAlpha)
            i->flags |= Falpha;
        if(t == CMap && i->cmap == nil){
            i->cmap = memdefcmap;
            i->flags |= Fcmap;
        }

        i->shift[t] = j;
        i->mask[t] = (1<<NBITS(cc))-1;
        i->nbits[t] = NBITS(cc);

        if(NBITS(cc) != 8)
            bytes = false;
    }
    i->nchan = k;
    if(bytes)
        i->flags |= Fbytes;
    return OK_0;
}
@
% >>

% can change chan of existing Memimage? issue if bigger depth?
%  then should reallocate ...

<<[[memsetchan()]] sanity check d>>=
if(d == 0) {
    werrstr("bad channel descriptor");
    return ERROR_NEG1;
}
@

<<[[memsetchan()]] sanity check t>>=
if(t < 0 || t >= NChan){
    werrstr("bad channel string");
    return -1;
}
@

<<[[MemImage]] other fields>>=
// map<enum<ImageChan>, int>
int		shift[NChan];
// map<enum<ImageChan>, int>
int		mask[NChan];
// map<enum<ImageChan>, int>
int		nbits[NChan];
@
% will be useful later when reading the bytes of a pixel, to know
%  where the rgba components are located in the word.


%dtor
<<function freememimage>>=
void
freememimage(Memimage *i)
{
    <<[[freememimage()]] sanity check i>>
    // free the Memdata
    if(i->data->ref-- == 1 && i->data->allocd){
        if(i->data->base)
            poolfree(imagmem, i->data->base);
        free(i->data);
    }
    free(i);
}
@
% remember allocd vs base, two different allocators


<<[[freememimage()]] sanity check i>>=
if(i == nil)
    return;
@
% it should throw a warning. Not good to abuse free to free null pointers.


\paragraph{[[DImage]]}

<<[[makescreenimage()]] allocate DImage di>>=
// allocate DImage
di = allocdimage(i);
<<[[makescreenimage()]] sanity check di>>
@
% we have seen allocdimage before in core DS chapter

<<[[makescreenimage()]] sanity check di>>=
if(di == nil){
    freememimage(i);    /* frees md */
    return nil;
}
@


\paragraph{Screen name}
% drawaddname() have stuff related to screename, but we will see later!

% put later with Windows! assume screen_image
% and screen_dimage are the way for client to get
% their screen image!




\subsubsection{VGA [[attachscreen()]] (x86)}
%\subsubsection{Hardware support hook}

% The connection between the two preceding section!

% the interface between screen.h and devdraw, between
% screenimage  and gscreen (and gscreendata).

% /// makescreenimage -> <>
% vgascreen.c
<<function attachscreen(x86)>>=
byte*
arch_attachscreen(Rectangle* r, ulong* chan, int* d, int* width, bool *softscreen)
{

    <<[[attachscreen()]] sanity check gscreen>>

    *r          = gscreen->clipr;
    *chan       = gscreen->chan;
    *d          = gscreen->depth;
    *width      = gscreen->width;

    *softscreen = vgascreen.useflush;

    return gscreendata.bdata;
}
@
% who setup vgascreen? and gscreen?
%old:
%    VGAscr *scr;
%    scr = &vgascreen;
%    *softscreen = scr->useflush;

% VGA has a soft screen?


<<[[attachscreen()]] sanity check gscreen>>=
if(gscreen == nil || gscreendata.bdata == nil)
    return nil;
@

\subsection{Next steps}

% what do you have now? draw_screen is set!

%\subsection{[[drawopen()]]}
% further initialisation when client actually connects to device
% when open Qnew and call drawnewclient
% and later when access Qctl dans get drawlookup and new dimage allocated



\section{Client side}

\subsection{[[initdraw()]]}

% see code of toy graphical app, initdraw(); which should set
% global [[display]] (and [[view]]).

<<function initdraw>>=
errorneg1
initdraw(Errorfn error, char *fontname , char *label)
{

    if(access("/dev/draw/new", AEXIST)<0 && bind("#i", "/dev", MAFTER)<0){
        fprint(2, "imageinit: can't bind /dev/draw: %r\n");
        return ERROR_NEG1;
    }
    return geninitdraw("/dev", error, fontname, label, "/dev", Refnone);
}
@
%old:    char *dev = "/dev";  but was not even used for bind so ...
%ocaml: return display instead

% so even when run colors under terminal, it will not reuse /dev/draw/n,
% it will open a new draw!

% devdir and windir often equals and equal to "/dev"
<<function geninitdraw>>=
errorneg1
geninitdraw(char *devdir, Errorfn error, char *fontname, char *label, char *windir, int ref)
{
    <<[[geninitdraw()]] locals>>

    display = initdisplay(devdir, windir, error);
    <<[[geninitdraw()]] sanity check display>>

    <<[[geninitdraw()]] set up font>>
    <<[[geninitdraw()]] write new label>>
    <<[[geninitdraw()]] get window>>
    atexit(drawshutdown);

    return OK_1;
}
@
%ocaml: less general, hardcode /dev, anyway who uses something different?

% modify the global!
\l care about being so general? devdir changes?


<<[[geninitdraw()]] sanity check display>>=
if(display == nil)
    return ERROR_NEG1;
@
%ocaml: no need, use exn instead

% Errorfn in appendix.

\t initdisplay is not enough to get a graphical window! 

\subsection{[[initdisplay()]]}

% get connection and first automatically allocated image in d->image

<<[[initdisplay()]] locals>>=
fdt ctlfd;
fdt datafd;
fdt reffd;

char info[NINFO+1];
char buf[128];

Display *disp;
Image *image;

int n;
@
% why NINFO+1? because add a trailing \0 below
\l aspectize reffd?

<<constant NINFO>>=
#define	NINFO	12*12
@
% /dev/draw/new content, 12 strings each 11 chars + newline
% use ascii format for image information, architecture independent, 
% and readable.


% hmm it's actually a public function! but not much app tweaking with it
% initdraw -> geninitdraw -> <>
<<function initdisplay>>=
Display*
initdisplay(char *dev, char *win, Errorfn error)
{
    <<[[initdisplay()]] locals>>

    <<[[initdisplay()]] install dumpers>>
    <<[[initdisplay()]] sanity check arguments>>

    sprint(buf, "%s/draw/new", dev);
    ctlfd = open(buf, ORDWR|OCEXEC);
    <<[[initdisplay()]] sanity check ctlfd>>

    n=read(ctlfd, info, sizeof info);
    <<[[initdisplay()]] sanity check read ctlfd>>
    info[n] = '\0';

    sprint(buf, "%s/draw/%d/data", dev, atoi(info+0*12));
    datafd = open(buf, ORDWR|OCEXEC);
    <<[[initdisplay()]] sanity check datafd>>

    sprint(buf, "%s/draw/%d/refresh", dev, atoi(info+0*12));
    reffd = open(buf, OREAD|OCEXEC);
    <<[[initdisplay()]] sanity check reffd>>

    // our display!
    disp = mallocz(sizeof(Display), true);
    <<[[initdisplay()]] sanity check disp>>
    disp->dirno = atoi(info+0*12);

    image = nil;
    <<[[initdisplay()]] sanity check image part1>>
    if(n >= NINFO){
        image = mallocz(sizeof(Image), true);
        <<[[initdisplay()]] sanity check image part2>>

        image->display = disp;
        image->id = 0; // info+1*12 but should always be 0
        image->chan = strtochan(info+2*12);
        image->depth = chantodepth(image->chan);
        image->repl = atoi(info+3*12);

        image->r.min.x = atoi(info+4*12);
        image->r.min.y = atoi(info+5*12);
        image->r.max.x = atoi(info+6*12);
        image->r.max.y = atoi(info+7*12);

        image->clipr.min.x = atoi(info+8*12);
        image->clipr.min.y = atoi(info+9*12);
        image->clipr.max.x = atoi(info+10*12);
        image->clipr.max.y = atoi(info+11*12);
    }
    disp->image = image;
    disp->fd    = datafd;
    disp->ctlfd = ctlfd;
    disp->reffd = reffd;

    <<[[initdisplay()]] set display bufsize>>
    disp->buf = malloc(disp->bufsize+5);	/* +5 for flush message */
    <<[[initdisplay()]] sanity check buf>>
    disp->bufp = disp->buf;

    disp->error = error;
    disp->windir = t;
    disp->devdir = strdup(dev);

    qlock(&disp->qlock); // released in closedisplay (why not earlier? first API call?)
  
    // first API calls!
    disp->white = allocimage(disp, Rect(0, 0, 1, 1), GREY1, true, DWhite);
    disp->black = allocimage(disp, Rect(0, 0, 1, 1), GREY1, true, DBlack);
    <<[[initdisplay()]] sanity check white and black>>
    disp->opaque = disp->white;
    disp->transparent = disp->black;

    return disp;
}
@
% refresh is important?
%dead:
%    <<[[initdisplay()]] set isnew>>
%    <<[[initdisplay()]] set display _isnewdisplay part1>>
%    <<[[initdisplay()]] set display _isnewdisplay part2>>
\l plus 5 for flush message? flush is using only 1 byte now.

% clipped if run under a window? how enforced? not enforced ...

% the opaque and transparent seems counterintuitive, but
% white means all colors. Black means no color.

% strtochan later in Image IO chapter.
% atoi = string to number. =~ scanf.


<<[[initdisplay()]] set display bufsize>>=
disp->bufsize = iounit(datafd);
if(disp->bufsize <= 0)
    disp->bufsize = 8000;
<<[[initdisplay()]] sanity check bufsize>>
@
% iounit in libc.h which is?






<<[[initdisplay()]] locals>>=
char *t;
@

<<[[initdisplay()]] sanity check arguments>>=
if(dev == nil)
    dev = "/dev";
if(win == nil)
    win = "/dev";

if(strlen(dev)>sizeof buf-25 || strlen(win)>sizeof buf-25){
    werrstr("initdisplay: directory name too long");
    return nil;
}
t = strdup(win);
if(t == nil)
    return nil;
@
%ocaml: no string overflow (also no need sanitize, hardcode /dev)


%less: could reorganize error management like in Linux instead
% have the errorx: followed, so less need 'goto previousone';
%anyway it's aspectized so less important now

<<[[initdisplay()]] sanity check ctlfd>>=
if(ctlfd < 0){
    if(bind("#i", dev, MAFTER) < 0){
Error1:
        free(t);
        werrstr("initdisplay: %s: %r", buf);
        return nil;
    }
    // try again
    ctlfd = open(buf, ORDWR|OCEXEC);
}
if(ctlfd < 0)
    goto Error1;
@
%ocaml: use exn, and no need free, use GC

<<[[initdisplay()]] sanity check read ctlfd>>=
if(n < 12){
Error2:
    close(ctlfd);
    goto Error1;
}
if(n==NINFO+1)
    n = NINFO;
@
%ocaml: should use finalize?

<<[[initdisplay()]] sanity check datafd>>=
if(datafd < 0)
    goto Error2;
@

<<[[initdisplay()]] sanity check reffd>>=
if(reffd < 0){
Error3:
    close(datafd);
    goto Error2;
}
@

<<[[initdisplay()]] sanity check disp>>=
if(disp == nil){
Error4:
    close(reffd);
    goto Error3;
}
@

<<[[initdisplay()]] sanity check image part1>>=
if(0){
Error5:
    free(image);
    free(disp);
    goto Error4;
}
@
%ocaml: use GC to free automatically when exn

<<[[initdisplay()]] sanity check image part2>>=
if(image == nil)
    goto Error5;
@

<<[[initdisplay()]] sanity check bufsize>>=
if(disp->bufsize < 512){
    werrstr("iounit %d too small", disp->bufsize);
    goto Error5;
}
@

<<[[initdisplay()]] sanity check buf>>=
if(disp->buf == nil)
    goto Error5;
@

<<[[initdisplay()]] sanity check white and black>>=
if(disp->white == nil || disp->black == nil){
    free(disp->devdir);
    free(disp->white);
    free(disp->black);
    goto Error5;
}
@

\subsection{[[closedisplay()]]}

% drawshutdown | <prog> -> <>
<<function closedisplay>>=
/*
 * Call with d unlocked.
 * Note that disp->defaultfont and defaultsubfont are not freed here.
 */
void
closedisplay(Display *disp)
{
    _closedisplay(disp, false);
}
@
% can have multiple display? apparently.
\l call with d unlocked? initdisplay comment says the opposite
\t why need that? just let OS do that?


% exit -> <> (atexit(<>) <- geninitdraw <- initdraw)
<<function drawshutdown>>=
/* note handler */
static void
drawshutdown(void)
{
    Display *d;

    d = display;
    if(d){
        display = nil;
        _closedisplay(d, true);
    }
}
@


<<function _closedisplay>>=
static void
_closedisplay(Display *disp, bool isshutdown)
{
    fdt fd;
    char buf[128];

    <<[[_closedisplay()]] sanity check disp>>
    if(disp == display)
        display = nil;

    <<[[_closedisplay()]] restore oldlabel>>

    /*
     * if we're shutting down, don't free all the resources.
     * if other procs are getting shot down by notes too,
     * one might get shot down while holding the malloc lock.
     * just let the kernel clean things up when we exit.
     */
    if(isshutdown)
        return;

    free(disp->devdir);
    free(disp->windir);
    freeimage(disp->white);
    freeimage(disp->black);
    close(disp->fd);
    close(disp->ctlfd);
    /* should cause refresh slave to shut down */
    close(disp->reffd);

    qunlock(&disp->qlock);
    free(disp);
}
@
% unlock!

<<[[_closedisplay()]] sanity check disp>>=
if(disp == nil)
    return;
@
% again, should issue a warning

\subsection{Next steps}

% actually after setup disp->buf we saw first calls to draw API
% with allocimage which will write in /dev/draw/x/data! User/Kernel
% bridge which we will see now.

%\section{Client side part 2}
% but need User/Kernel bridge first.

\section{Fonts and overlapping layers}
% labels

% See later. Saw fontname passed to initdraw.

% For windows just say  view point to Display->image? with id 0?







\chapter{User/Kernel Bridge}
\label{chap:user-kernel-bridge}
% kernel side part 2

% some kind of RPC and protocol

% in initdisplay, open /dev/draw/new and then
% read from it. All of that served by draw device (kinda of a server) 
% which we will see now.


\section{The [[draw]] filesystem}


% 'i' below so bind #i

<<global drawdevtab>>=
Dev drawdevtab = {
    .dc       =    'i',
    .name     =    "draw",

    .attach   =    drawattach,
    .walk     =    drawwalk,
    .stat     =    drawstat,

    .open     =    drawopen,
    .close    =    drawclose,
    .read     =    drawread,
    .write    =    drawwrite,

    // generic               
    .create   =    devcreate,
    .remove   =    devremove,
    .bread    =    devbread,
    .bwrite   =    devbwrite,
    .wstat    =    devwstat,
    .reset    =    devreset,
    .init     =    devinit,
    .shutdown =    devshutdown,
};
@
%dc = device char (actually Rune)

% Seen drawattach() in Initialisation/mounting-draw section already.
%  setup screenimage (via attachscreen), from data setup by vga device.

% Need understand part of Kernel.nw.
% does    return devattach('i', spec);
%  spec = extra paramaters (usually nil)

% next most important = drawwalk! and notion of Qids.

<<enum QxxxDraw>>=
enum
{
    // Directories

    Qtopdir     = 0, // /dev
    Q2nd,            // /dev/draw/
    Q3rd,            // /dev/draw/x/

    // Files

    Qnew,
    Qwinname,

    // /dev/draw/x/y, third level device files associated to a client
    Qctl,  // used in 'x < Qctl' code, so must be the first!
    Qdata, // used for drawing commands, see drawmesg()

    Qcolormap, 
    Qrefresh,
};
@
%pad: I reordered qids, grouped in QTDIR vs QTFILE

% remember plan9 has union dir, so Qtopdir is actually /dev

<<constant QSHIFT>>=
/*
 * Qid path is:
 *   4 bits of file type (qids above)
 *  24 bits of mux slot number +1; 0 means not attached to client
 */
#define QSHIFT  4   /* location in qid of client # */
@

<<function QID bis>>=
#define QID(q)      ((((ulong)(q).path)&0x0000000F)>>0)
@

<<function CLIENTPATH>>=
#define CLIENTPATH(q)   ((((ulong)q)&0x7FFFFFF0)>>QSHIFT)
@
%old: //#define CLIENT(q)   CLIENTPATH((q).path)
% why 7FFFFFFF0? why not FFFFFFFF0? Qid is not unsigned?


\subsection{[[drawwalk()]]}

% when do ls (see Kernel.nw)

<<function drawwalk>>=
static Walkqid*
drawwalk(Chan *c, Chan *nc, char **name, int nname)
{
    <<[[drawwalk()]] sanity check>>
    return devwalk(c, nc, name, nname, 0, 0, drawgen);
}
@

<<[[drawwalk()]] sanity check>>=
if(screenimage == nil)
    error("no frame buffer");
@

<<function drawstat>>=
static int
drawstat(Chan *c, uchar *db, int n)
{
    return devstat(c, db, n, 0, 0, drawgen);
}
@

% Again see Kernel but idea of xxxgen is that from
% directory in channel c with Qid t, get entry number s and
% populate Dir (actually devdir take care of that).
% return -1 when no more entries. return 1 when possibly more entries. 
% return 0 if error?

% sys?? -> devwalk -> <> (devwalk(..., <>) <- drawwalk)
<<function drawgen>>=
static int
drawgen(Chan *c, char*, Dirtab*, int, int s, Dir *dp)
{
    int t;
    Qid q;
    ulong path;
    Client *cl;

    q.vers = 0;

    <<[[drawgen()]] if dotdot>>
    // else
    t = QID(c->qid);

    /*
     * Top level directory contains the name of the device.
     */
    <<[[drawgen()]] toplevel directory listing>>
    // else
    /*
     * Second level contains "new" plus all the clients.
     */
    <<[[drawgen()]] second level directory listing>>
    // else
    /*
     * Third level.
     */
    <<[[drawgen()]] third level directory listing>>
}
@
% >> >>
\l could use a switch and indent code in default: case


<<[[drawgen()]] toplevel directory listing>>=
if(t == Qtopdir){
    switch(s){
    case 0:
        mkqid(&q, Q2nd, 0, QTDIR);
        devdir(c, q, "draw", 0, eve, 0555, dp);
        break;
    case 1:
        mkqid(&q, Qwinname, 0, QTFILE);
        devdir(c, q, "winname", 0, eve, 0444, dp);
        break;
    default:
        return -1;
    }
    return 1;
}
// else

if(t == Qwinname){
    mkqid(&q, Qwinname, 0, QTFILE);
    devdir(c, q, "winname", 0, eve, 0444, dp);
    return 1;
}
@
% fill dp

% will see important of winname later

% (how make sure not devgen not call drawgen indefinitely for Qwinname?
%  because it returns a QTFILE?)

<<[[drawgen()]] second level directory listing>>=
if(t == Q2nd || t == Qnew){
    if(s == 0){
        mkqid(&q, Qnew, 0, QTFILE);
        devdir(c, q, "new", 0, eve, 0666, dp);
    }
    else if(s <= sdraw.nclient){
        cl = sdraw.client[s-1];
        <<[[drawgen()]] in second level directory listing, sanity check cl>>
        snprint(up->genbuf, sizeof up->genbuf, "%d",
            cl->clientid);
        mkqid(&q, (s<<QSHIFT)|Q3rd, 0, QTDIR);
        devdir(c, q, up->genbuf, 0, eve, 0555, dp);
        return 1;
    }
    else
        return -1;
    return 1;
}
@
% >>
% use of clientid here! so will be listed as /dev/draw/x/... where
%  x is clientid that always increment
\l why t == Qnew here? could remove no? or do extra code like for Qwinname
\l  separated

<<[[drawgen()]] in second level directory listing, sanity check cl>>=
if(cl == nil)
    return 0;
@
% this happens when an entry got freed. drawgen will be called repeatitdely.


<<[[drawgen()]] third level directory listing>>=
path = c->qid.path & ~((1<<QSHIFT)-1);    /* slot component */
q.vers = c->qid.vers;
q.type = QTFILE;
switch(s){
case 0:
    q.path = path|Qcolormap;
    devdir(c, q, "colormap", 0, eve, 0600, dp);
    break;
case 1:
    q.path = path|Qctl;
    devdir(c, q, "ctl", 0, eve, 0600, dp);
    break;
case 2:
    q.path = path|Qdata;
    devdir(c, q, "data", 0, eve, 0600, dp);
    break;
case 3:
    q.path = path|Qrefresh;
    devdir(c, q, "refresh", 0, eve, 0400, dp);
    break;
default:
    return -1;
}
return 1;
@
% >> >>
\l sorted alphabetically? important? kernel requirment?


% DEVDOTDOT is -1
<<[[drawgen()]] if dotdot>>=
if(s == DEVDOTDOT){
    switch(QID(c->qid)){
    case Qtopdir:
    case Q2nd:
        mkqid(&q, Qtopdir, 0, QTDIR);
        devdir(c, q, "#i", 0, eve, 0500, dp);
        break;
    case Q3rd:
        cl = drawclientofpath(c->qid.path);
        if(cl == nil) // when can this happen?
            strncpy(up->genbuf, "??", sizeof up->genbuf);
        else
            snprint(up->genbuf, sizeof up->genbuf,
                "%d", cl->clientid);
        mkqid(&q, Q2nd, 0, QTDIR);
        devdir(c, q, up->genbuf, 0, eve, 0500, dp);
        break;
    default:
        panic("drawwalk %llux", c->qid.path);
    }
    return 1;
}
@

% might return nil
<<function drawclientofpath>>=
Client*
drawclientofpath(ulong path)
{
    Client *cl;
    int slot;

    slot = CLIENTPATH(path);
    if(slot == 0)
        return nil;
    cl = sdraw.client[slot-1];
    if(cl == nil || cl->clientid == 0)
        return nil;
    return cl;
}
@

\subsection{[[drawopen()]]}

% quite generic, specifics detailed later

<<function drawopen>>=
static Chan*
drawopen(Chan *c, int omode)
{
    <<[[drawopen()]] locals>>

    if(c->qid.type & QTDIR){
        c = devopen(c, omode, 0, 0, drawgen);
        c->iounit = IOUNIT;
    }

    <<[[drawxxx()]] lock>>
    <<[[drawopen()]] if Qnew>>
    switch(QID(c->qid)){
    <<[[drawopen()]] switch qid cases>>
    }
    <<[[drawxxx()]] unlock>>

    c->mode = openmode(omode);
    c->flag |= COPEN;
    c->offset = 0;
    c->iounit = IOUNIT;

    return c;
}
@
% >> 

<<constant IOUNIT>>=
#define IOUNIT      (64*1024)
@



<<[[drawxxx()]] lock>>=
dlock();
if(waserror()){
    dunlock();
    nexterror();
}
@

<<[[drawxxx()]] unlock>>=
dunlock();
poperror();
@


\subsection{[[drawclose()]]}

<<function drawclose>>=
static void
drawclose(Chan *c)
{
    Client *cl;
    <<[[drawclose()]] other locals>>

    if(QID(c->qid) < Qctl) /* Qtopdir, Qnew, Q3rd, Q2nd have no client */
        return;

    <<[[drawxxx()]] lock>>

    cl = drawclient(c);
    <<[[drawclose()]] if Qctl>>

    if((c->flag&COPEN) && (decref(&cl->r)==0)){
        <<[[drawclose()]] free refresh>>
        <<[[drawclose()]] free names>>
        <<[[drawclose()]] free screens>>
        /* all screens are freed, so now we can free images */
        <<[[drawclose()]] free dimages>>

        sdraw.client[cl->slot] = nil;

        drawflush();    /* to erase visible, now dead windows */
        free(cl);
    }
    <<[[drawxxx()]] unlock>>
}
@
%old: if(QID(c->qid) < Qcolormap) /* Qtopdir, Qnew, Q3rd, Q2nd have no client */

% small wrapper with error checking, will never return nil, may raise exn!
<<function drawclient>>=
Client*
drawclient(Chan *c)
{
    Client *client;

    client = drawclientofpath(c->qid.path);
    if(client == nil)
        error(Enoclient);
    return client;
}
@



<<[[drawclose()]] other locals>>=
DImage *d, **dp;
int i;
@

<<[[drawclose()]] free dimages>>=
dp = cl->dimage;
for(i=0; i<NHASH; i++){
    while((d = *dp) != nil){
        *dp = d->next;
        drawfreedimage(d);
    }
    dp++;
}
@

% drawfreedimage() later


\subsection{[[drawread()]]}

<<function drawread>>=
long
drawread(Chan *c, void *a, long n, vlong off)
{
    Client *cl;
    <<[[drawread()]] other locals>>

    if(c->qid.type & QTDIR)
        return devdirread(c, a, n, 0, 0, drawgen);
    <<[[drawread()]] if Qwinname>>
    // else

    cl = drawclient(c);

    <<[[drawxxx()]] lock>>
    switch(QID(c->qid)){
    <<[[drawread()]] switch qid cases>>
    }
    <<[[drawxxx()]] unlock>>

    return n;
}
@



\subsection{[[drawwrite()]]}


<<function drawwrite>>=
static long
drawwrite(Chan *c, void *a, long n, vlong)
{
    Client *cl;
    <<[[drawwrite()]] other locals>>

    <<[[drawwrite()]] sanity check c>>
    cl = drawclient(c);

    <<[[drawwrite()]] lock>>
    switch(QID(c->qid)){
    <<[[drawwrite()]] switch qid cases>>
    default:
        error(Ebadusefd);
    }
    <<[[drawxxx()]] unlock>>

    return n;
}
@

<<[[drawwrite()]] sanity check c>>=
if(c->qid.type & QTDIR)
    error(Eisdir);
@


% locking a bit different, why? drawwakeall?
<<[[drawwrite()]] lock>>=
dlock();
if(waserror()){

    drawwakeall();

    dunlock();
    nexterror();
}
@

\section{[[/dev/draw/]] files}

% but really it could be only one file, /dev/draw
% if rio could multiplex it.

\subsection{Opening [[/dev/draw/new]]}

<<[[drawopen()]] locals>>=
Client *cl;
@

<<[[drawopen()]] if Qnew>>=
if(QID(c->qid) == Qnew){
    cl = drawnewclient();
    <<[[drawopen()]] when Qnew, sanity check cl>>
    c->qid.path = Qctl|((cl->slot+1)<<QSHIFT);
}
@
% >>
\l why not put in switch instead?
% saw drawnewclient() in core DS chapter.
<<[[drawopen()]] switch qid cases>>=
case Qnew:
    break;
@

% generate a Qctl qid!
% opening qnew redirect to a /dev/draw/x/ctl!
% (x is not slot, slot is reused, x is clientid, see drawgen

<<[[drawopen()]] when Qnew, sanity check cl>>=
if(cl == nil)
    error(Enodev);
@

\subsection{Reading from [[/dev/draw/x/ctl]]}
% (and write a bit)

\l I put the code of drawopen and Qctl in adv topics because normally
\l  you should not do that and the code looked subtle.

<<[[drawread()]] other locals>>=
Memimage *i;
char buf[16];
@

<<[[drawread()]] switch qid cases>>=
case Qctl:
    if(n < 12*12) // NINFO
        error(Eshortread);

    <<[[drawread()]] switch qid cases, when Qctl, set i>>

    // mostly for initdisplay!
    n = snprint(a, n,
        "%11d %11d %11s %11d %11d %11d %11d %11d %11d %11d %11d %11d ",
        cl->clientid, cl->infoid, chantostr(buf, i->chan),
        (i->flags&Frepl)==Frepl,
        i->r.min.x, i->r.min.y, i->r.max.x, i->r.max.y,
        i->clipr.min.x, i->clipr.min.y, i->clipr.max.x, i->clipr.max.y
        );
    cl->infoid = -1;
    break;
@
% 11 integers with %11d + 1 space + 1 string with %11s + space = 12 * 12
%  (note extra space after last number too)
% see that export just the bool for Image.repl, not the whole flag!

% not just for initdisplay though. enter infoid below.

<<[[Client]] other fields>>=
int     infoid;
@
% rename current_image? hmm it's more actually just for
%  get information about image with specific id, so maybe good field name.
\l related to named image too?

% infoid is set to 0 in drawnewclient because of malloc.
% can be changed:
% (also used for namedimage and 'n' message)

<<[[drawwrite()]] switch qid cases>>=
case Qctl:
    if(n != 4)
        error("unknown draw control request");
    cl->infoid = BGLONG((uchar*)a);
    break;
@
% set infoid for further reading operation


<<[[drawread()]] other locals>>=
DImage *di;
@

<<[[drawread()]] switch qid cases, when Qctl, set i>>=
<<[[drawread()]] switch qid cases, when Qctl, sanity check infoid>>
if(cl->infoid == 0){
    i = screenimage;
    <<[[drawread()]] switch qid cases, when Qctl, sanity check i>>
}else{
    di = drawlookup(cl, cl->infoid, true);
    <<[[drawread()]] switch qid cases, when Qctl, sanity check di>>
    i = di->image;
}
@

% when cl->infoid == 0? because of malloc of new client.
% when <0?  just after first read, so further read
%  of Qctl will return an error.
% when positive? when write to ctl to get info about another image!

<<[[drawread()]] switch qid cases, when Qctl, sanity check infoid>>=
if(cl->infoid < 0)
    error(Enodrawimage);
@

<<[[drawread()]] switch qid cases, when Qctl, sanity check i>>=
if(i == nil)
    error(Enodrawimage);
@
<<[[drawread()]] switch qid cases, when Qctl, sanity check di>>=
if(di == nil)
    error(Enodrawimage);
@




\subsection{Writing in [[/dev/draw/x/data]]}
\label{sec:drawwrite-drawmesg}
% (and open)
% and DImage?


<<[[drawopen()]] switch qid cases>>=
case Qdata:
case Qcolormap:
case Qrefresh:
    cl = drawclient(c);
    incref(&cl->r);
    break;
@


<<[[drawwrite()]] switch qid cases>>=
case Qdata:
    // The big dispatch!!
    drawmesg(cl, a, n);

    drawwakeall();
    break;
@

% The big dispatch, see next section.

% drawwakeall? again.

% it is possible to read from Qdata to read images as explained
% later in Section X.


% seems a bit useless to have 3 different device files.
% maybe we could use only 1 and have the open/read/write on it.
% But as we will see one can also write on /ctl and read on /data
% so at least need two files and then can have multiple clients
% hence the difference between /new and /ctl.

%\subsection{[[/dev/draw/x/refresh]]}
% adv topics



\section{The drawing commands protocol}

% we will see later in the book repetitive structure
% which correspond to what we call the Draw message protocol.
% Each section below present a step in this protocol.

\subsection{Step 1: API function}

% first API.

% ex line() ...

%real-world: =~ Xlib layer

\subsection{Step 2: marshalling}
% This is also called serializing. 
% (Java says marshalling is serializing the data and the code itself)

% ex line code to marshall with use of BGSHORT, bufimage, etc.


% Lots of boilerplate code, would be better to use thrift in the end?
% Lots of marshalling/unmarshalling boilerplate with BPLONG and so on.
% File interface is nice but limited in the end. Or maybe can just
% write a thrift like tool on top of the file interface that generates
% most of the boilerplate at least.

% G = Get, P = Put
% B = Binary? Bytes? Buffer?

<<function BGSHORT>>=
#define	BGSHORT(p)		(((p)[0]<<0) | ((p)[1]<<8))
@
<<function BGLONG>>=
#define	BGLONG(p)		((BGSHORT(p)<<0) | (BGSHORT(p+2)<<16))
@
<<function BPSHORT>>=
#define	BPSHORT(p, v)		((p)[0]=(v), (p)[1]=((v)>>8))
@
<<function BPLONG>>=
#define	BPLONG(p, v)		(BPSHORT(p, (v)), BPSHORT(p+2, (v)>>16))
@

% could start by a simple example? like flush?


<<[[Display]] buffer fields>>=
// drawing operations to write in /dev/draw/x/data until flush
// array<byte> (length = Display.bufsize)
byte	*buf;
int		bufsize;
// index in Display.buf array
byte	*bufp;
@
% who sets bufsize? initdisplay, usually set to iounit(datafd).

% when want to write a "message" of size n, get a pointer to the
% next free byte in the buffer
<<function bufimage>>=
byte*
bufimage(Display *d, int n)
{
    byte *p;

    <<[[bufimage()]] sanity check n>>
    <<[[bufimage()]] flush if buffer full>>
    p = d->bufp;
    d->bufp += n;
    return p;
}
@
%ocaml: use ^ and simply add_buf and string buffer
% instead of those bufimage and manual a+5, a+12, etc.

<<[[bufimage()]] flush if buffer full>>=
if(d->bufp + n  >  d->buf + d->bufsize)
    if(doflush(d) < 0)
        return nil;
@
%ocaml: use exn not nil return

<<[[bufimage()]] sanity check n>>=
if(n < 0 || n > d->bufsize){
    werrstr("bad count in bufimage");
    return nil;
}
@
% werrstr ? Libcore?



% why not _flushimage? because this one we actually write stuff!
% we not just modify buffer. we send it to the device!
<<function doflush>>=
static
errorneg1
doflush(Display *d)
{
    int n, nn;

    n = d->bufp - d->buf;
    if(n <= 0)
        return OK_1; // warning?

    nn=write(d->fd, d->buf, n);
    <<[[doflush()]] sanity check nn>>
    d->bufp = d->buf;
    return OK_1;
}
@
%ocaml: exn?

% write!! trigger kernel side!

<<[[doflush()]] sanity check nn>>=
if(nn != n){
    <<[[doflush()]] if _drawdebug>>
    d->bufp = d->buf;	/* might as well; chance of continuing */
    return ERROR_NEG1;
}
@
%ocaml: use exn because anyway many places do not check the return value
% of doflush or flushimage and just ignore if error

% important to reset bufp! otherwise get into a loop

% usually first letter is message kind. e.g., 'a' for alloc
% 'l' for line.
% in total =~ 20 messages?
% compared to 120 messages in X11R4, and in X11R6?

% how communicate error from API call? from kernel?
% By having syscall returning error code when writing in /dev/draw/x/data
% (can then use werrstr to know more about the error)

\subsection{Step 3: unmarshalling and [[drawmesg()]]}
% also called demarshalling, or deserializing

%real-world: =~ Xserver

<<[[drawmesg()]] locals>>=
byte *a;
int m = 0;
char *fmt = nil;
@
% m is for storing how much bytes were read for this message,
% so the loop on the buffer can go on and process the next message

% the big one!! this is in kernel!!
% syswrite -> drawwrite(Qdata) -> <>
<<function drawmesg>>=
void
drawmesg(Client *client, void *av, int n)
{
    <<[[drawmesg()]] locals>>

    a = av;
    if(waserror()){
        if(fmt) 
            printmesg(fmt, a, true);
        nexterror();
    }
    while((n-=m) > 0){
        USED(fmt);
        a += m;
        // dispatch on first letter of the drawing command
        switch(*a){
        <<[[drawmesg()]] cases>>
        default:
            error("bad draw command");
        }
    }
    poperror();
}
@
%old:    /*  iprint("error: %s\n", up->errstr);  */
%old: I put 'true' to printmesg, but then removed it because
% it is normal that certain calls generate an error like allocscreen.

% split in different messages chunks hence the while.
% the switch will adjust m which contains the size for one message
% (which vary dependong on the message command).

% unmarshallers helpers:
% drawrectangle(), etc


\subsection{Step 4: algorithm}
% Memory Algorithm?

%real-world: libpixman?

\subsection{Step 5 (optional): hardware support hook}

%real-world: libdrm and Linux kernel comm?

% via screen and then VGAscr and then VGAdev interfaces
% (and also VGAcur interface)

%\subsubsection{Screen interface}
% Kernel/Hardware bridge

% screen.h

%\subsubsection{Graphics card}
% Graphic VGA card?
% there is also the VGA interface, which is something different

%\subsubsection{VGA interface}
% or VGA screen? meh maybe, simpler to just have a
% frame buffer
% vga.h







\chapter{Images}
\label{chap:images}

% Fundamental piece!
% The screen is an image. Colors are images!! Mask are images.
% Tiles are images. Background are special images.
% Fonts are images (even Windows are images).

% Can have multiple images, draw there, and at some point
% quickly copy on main image (display->image).

% The initial display->image is actually allocated for you
% (got a first image allocated for you when open draw device, 'screen/view')
% But how allocate new one? temporary canvas to draw on.

% see Image IO later, individual pixels! raster images.

\section{Allocation}

% already one allocated for you! the screen, image id 0.
% view! (was screen)

% allocimage(2)

\subsection{API}

% remember in initdisplay first API calls!
%    disp->white = allocimage(disp, Rect(0, 0, 1, 1), GREY1, true, DWhite);
%    disp->black = allocimage(disp, Rect(0, 0, 1, 1), GREY1, true, DBlack);


%ctor
<<function allocimage>>=
Image*
allocimage(Display *d, Rectangle r, ulong chan, bool repl, rgba val)
{
    Image*	i;

    i =  _allocimage(nil, d, r, chan, repl, val, 0, 0);
    <<[[allocimage()]] set malloc tag for debug>>
    return i;
}
@
\l 0,0 is screenid and refresh. Could use Refbackup but anyway adv concept.
\t can have a Rectangle that does not start at Pt(0, 0) ?

% for a color r is usually R(0,0,1,1), chan is view->chan, repl = true,
% and val is the color

%dtor
<<function freeimage>>=
errorneg1
freeimage(Image *i)
{
    errorneg1 ret;

    ret = _freeimage1(i);
    free(i);
    return ret;
}
@
\l why not _freeimage? be consistent at least, and why extra function?

% need to free sometimes because resource used in the kernel! it takes space.


\subsection{Marshalling}

% ai usually nil
%ctor
<<function _allocimage>>=
Image*
_allocimage(Image *ai, Display *d, Rectangle r, ulong chan, bool repl, rgba val, int screenid, int refresh)
{
    Image *i = nil;
    char *err = nil;
    byte *a;
    Rectangle clipr;
    int id;
    int depth;

    <<[[_allocimage()]] sanity check chan>>
    depth = chantodepth(chan);
    <<[[_allocimage()]] sanity check depth>>

    /* flush pending data so we don't get error allocating the image */
    flushimage(d, false);

    // new allocate: 'b' id[4] screenid[4] refresh[1] chan[4] repl[1] R[4*4] clipR[4*4] rrggbbaa[4]
    a = bufimage(d, 1+4+4+1+4+1+4*4+4*4+4);
    <<[[_allocimage()]] sanity check a>>

    d->imageid++;
    id = d->imageid;

    a[0] = 'b';
    BPLONG(a+1, id);

    BPLONG(a+5, screenid);
    a[9] = refresh;

    BPLONG(a+10, chan);
    a[14] = repl;
    BPLONG(a+15, r.min.x);
    BPLONG(a+19, r.min.y);
    BPLONG(a+23, r.max.x);
    BPLONG(a+27, r.max.y);
    <<[[_allocimage()]] set clipr>>
    BPLONG(a+31, clipr.min.x);
    BPLONG(a+35, clipr.min.y);
    BPLONG(a+39, clipr.max.x);
    BPLONG(a+43, clipr.max.y);
    BPLONG(a+47, val);

    if(flushimage(d, false) < 0)
        goto Error;

    <<[[_allocimage()]] if passed image>>
    else{
        i = malloc(sizeof(Image)); // client side allocation
        <<[[_allocimage()]] sanity check i>>
    }

    i->display = d;
    i->id = id;
    i->depth = depth;
    i->chan = chan;
    i->r = r;
    i->clipr = clipr;
    i->repl = repl;

    i->screen = nil;
    i->next = nil;

    return i;
}
@
%ocaml: use exn instead of ignoring possible error when do
% flushimage()
\l could use BPRECT macro

% A bit sad to have this duplicated info kernel and user side.
% Have user side probably for programmer's convenient so he can
%  have directly information about the image.
%alt: could have a get_info call (actually there is one when write
% stuff and read the ctl file with infoid)


<<[[_allocimage()]] if passed image>>=
if(ai)
    i = ai;
@
% when pass an already allocated image to allocimage?
\l when need that?




<<[[_allocimage()]] sanity check chan>>=
if(chan == 0){
    werrstr("bad channel descriptor");
    return nil;
}
@
%ocaml: can not happen by construction when use proper type

<<[[_allocimage()]] sanity check depth>>=
if(depth == 0){
    err = "bad channel descriptor";
Error:
    if(err)
        werrstr("allocimage: %s", err);
    else
        werrstr("allocimage: %r");
    free(i);
    return nil;
}
@
%ocaml: exn

<<[[_allocimage()]] sanity check a>>=
if(a == nil)
    goto Error;
@

<<[[_allocimage()]] sanity check i>>=
if(i == nil){
    // free: 'f' id[4]
    a = bufimage(d, 1+4);
    if(a){
        a[0] = 'f';
        BPLONG(a+1, id);
        flushimage(d, false);
    }
    goto Error;
}
@





<<function _freeimage1>>=
errorneg1
_freeimage1(Image *i)
{
    byte *a;
    Display *d;
    Image *w;

    <<[[_freeimage1()]] sanity check i>>

    /* make sure no refresh events occur on this if we block in the write */
    d = i->display;
    /* flush pending data so we don't get error deleting the image */
    flushimage(d, false);

    // free: 'f' id[4]
    a = bufimage(d, 1+4);
    <<[[_freeimage1()]] sanity check a>>
    a[0] = 'f';
    BPLONG(a+1, i->id);
    <<[[_freeimage1()]] if screen>>

    if(flushimage(d, i->screen != nil) < 0)
        return ERROR_NEG1;

    return OK_0;
}
@
% free done in caller (a bit ugly)

% flushimage!

<<[[_freeimage1()]] sanity check i>>=
if(i == nil || i->display == nil)
    return OK_0;
@
%ocaml: can not arrive by construction! (well there is fakeimage)

% should issue a warning

<<[[_freeimage1()]] sanity check a>>=
if(a == nil)
    return ERROR_NEG1;
@
%ocaml: exn (Out_of_memory, but rare)


\subsection{Unmarshalling}

<<[[drawmesg()]] locals>>=
int dstid, scrnid;
byte refresh;
ulong chan;
int repl;
Rectangle r, clipr;
// rgba
ulong value;

Memimage *i;
@

<<[[drawmesg()]] cases>>=
/* new allocate: 'b' id[4] screenid[4] refresh[1] chan[4] repl[1] R[4*4] clipR[4*4] rrggbbaa[4] */
case 'b':
    printmesg(fmt="LLbLbRRL", a, false);
    m = 1+4+4+1+4+1+4*4+4*4+4;
     <<[[drawmesg()]] sanity check n with m>>
    dstid = BGLONG(a+1);

    scrnid = BGSHORT(a+5);
    refresh = a[9];

    chan = BGLONG(a+10);
    repl = a[14];
    drawrectangle(&r, a+15);
    drawrectangle(&clipr, a+31);
    value = BGLONG(a+47);

    <<[[drawmesg()]] allocate image case, sanity check dstid>>
    <<[[drawmesg()]] allocate image case, if screen id>>
    // else

    i = allocmemimage(r, chan); // server side allocation
    <<[[drawmesg()]] allocate image case, sanity check i>>
    if(repl)
        i->flags |= Frepl;
    i->clipr = clipr;
    <<[[drawmesg()]] allocate image case, clip clipr>>

    if(drawinstall(client, dstid, i, nil) == nil){
        freememimage(i);
        error(Edrawmem);
    }
    memfillcolor(i, value);
    continue;
@


<<[[drawmesg()]] sanity check n with m>>=
if(n < m)
    error(Eshortdraw);
@

<<[[drawmesg()]] allocate image case, sanity check i>>=
if(i == nil)
    error(Edrawmem);
@
<<[[drawmesg()]] allocate image case, sanity check dstid>>=
if(drawlookup(client, dstid, false))
    error(Eimageexists);
@





<<function drawrectangle>>=
void
drawrectangle(Rectangle *r, uchar *a)
{
    r->min.x = BGLONG(a+0*4);
    r->min.y = BGLONG(a+1*4);
    r->max.x = BGLONG(a+2*4);
    r->max.y = BGLONG(a+3*4);
}
@
\l could do that also in the upper side in draw and have a putrectangle()




<<[[drawmesg()]] locals>>=
DImage *ll;
@
\l could reuse di instead

<<[[drawmesg()]] cases>>=
/* free: 'f' id[4] */
case 'f':
    printmesg(fmt="L", a, false);
    m = 1+4;
    <<[[drawmesg()]] sanity check n with m>>
    ll = drawlookup(client, BGLONG(a+1), false);
    <<[[drawmesg()]] free image case, if dscreen>>
    drawuninstall(client, BGLONG(a+1)); // The call

    continue;
@
%old: was passing true to printmesg but weird



\subsection{Algorithm}

% allocimage -> _allocimage -> ... -> drawmesg -> <>
%Memdata and then Memimage ctor
% should be called once automatically when one creates a new connection no?
<<function allocmemimage>>=
Memimage*
allocmemimage(Rectangle r, ulong chan)
{
    int d;
    byte *p;
    ulong l, nw;
    Memdata *md;
    Memimage *i;

    d = chantodepth(chan);
    <<[[allocmemimage()]] sanity check d>>

    l = wordsperline(r, d);
    nw = l * Dy(r);

    md = malloc(sizeof(Memdata));
    <<[[allocmemimage()]] sanity check md>>
    md->ref = 1;
    // the big alloc!
    md->base = poolalloc(imagmem, sizeof(Memdata*)+(1+nw)*sizeof(ulong));
    <<[[allocmemimage()]] sanity check md base>>

    p = (byte*)md->base;
    *(Memdata**)p = md;
    p += sizeof(Memdata*);
    *(ulong*)p = getcallerpc(&r);
    p += sizeof(ulong);

    /* if this changes, memimagemove must change too */
    md->bdata = p;
    md->allocd = true;

    i = allocmemimaged(r, chan, md);
    <<[[allocmemimage()]] sanity check i>>

    return i;
}
@
% we have seen allocmemimaged before

%dead:
%    md->imref = i;
% <<[[Memdata]] other fields>>=
% // ref<Memimage>, reverse of Memimage.bdata
% void*	imref;
% @






<<[[allocmemimage()]] sanity check d>>=
if(d == 0) {
    werrstr("bad channel descriptor %.8lux", chan);
    return nil;
}
@

<<[[allocmemimage()]] sanity check md>>=
if(md == nil)
    return nil;
@

<<[[allocmemimage()]] sanity check md base>>=
if(md->base == nil){
    free(md);
    return nil;
}
@

<<[[allocmemimage()]] sanity check i>>=
if(i == nil){
    poolfree(imagmem, md->base);
    free(md);
    return nil;
}
@


\subsection{[[Client]] and [[Memimage]] connection, [[DImage]]}

% drawmesg(allocate) -> <>
<<function drawinstall>>=
Memimage*
drawinstall(Client *client, int id, Memimage *i, DScreen *dscreen)
{
    DImage *d;

    d = allocdimage(i);
    <<[[drawinstall()]] sanity check d>>
    d->id = id;
    <<[[drawinstall()]] install dscreen>>

    // insert_hash(d, client->dimage)
    d->next = client->dimage[id&HASHMASK];
    client->dimage[id&HASHMASK] = d;

    return i;
}
@
% allocdimage we have seen before too

% why not return void? because of this sanity check
<<[[drawinstall()]] sanity check d>>=
if(d == nil)
    return nil;
@



<<function drawuninstall>>=
void
drawuninstall(Client *client, int id)
{
    DImage *d, *next;

    d = client->dimage[id&HASHMASK];
    <<[[drawuninstall()]] sanity check d>>

    // hash_remove(client->dimage, id)
    if(d->id == id){
        client->dimage[id&HASHMASK] = d->next;

        drawfreedimage(d);
        return;
    }
    while(next = d->next){  /* assign = */
        if(next->id == id){
            d->next = next->next;

            drawfreedimage(next);
            return;
        }
        d = next;
    }

    error(Enodrawimage);
}
@

<<[[drawuninstall()]] sanity check d>>=
if(d == nil)
    error(Enodrawimage);
@

% drawclose | drawuninstall  -> <>
<<function drawfreedimage>>=
void
drawfreedimage(DImage *dimage)
{
    int i;
    Memimage *l;
    DScreen *ds;

    dimage->ref--;
    <<[[drawfreedimage()]] sanity check dimage ref>>
    if(dimage->ref > 0)
        return;
    // else

    <<[[drawfreedimage()]] free names>>
    <<[[drawfreedimage()]] if dscreen>>
    else
        freememimage(dimage->image);
    Return:
    free(dimage->fchar);
    free(dimage);
}
@
%//  if(dimage->image == screenimage)    /* don't free the display */
%//      goto Return;

% freeimage before for screen.

<<[[drawfreedimage()]] sanity check dimage ref>>=
if(dimage->ref < 0)
    print("negative ref in drawfreedimage\n");
@



\section{Clipping and replicating}
% (tiling)
% part 1

% Clipping is fundamental graphics operation. Very useful
% generic functionality. Like narrow mode in emacs :)
% Useful especially internally when have multiple windows!

% what about non-rectangular clipping? useful?

% Replication is useful to save space in memory, for color, while
% still being general. Also useful for adv effect such as tiling
% (repeating a background pattern for instance).

% Clipping called by many, to optimize things, e.g., no need to flush some modif
% if rectangle outside the clipping area.
% Modify the first parameter when they overlap to match the intersection.


% Can have either repl or clip? Can have both! Usually have
% repl set to true and infinite (actually huge) clipping. This is why in code
% later there is code that first do  rectclip(r, img->clipr)
%  and then if(!(img->flags&Frepl)) rectclip(r, img->r)

% Note that the repl bit is used only when the image is used as a source.
% This is why the clipping code for dst and src is a bit different.


<<[[_allocimage()]] set clipr>>=
if(repl)
    /* huge but not infinite, so various offsets will leave it huge, not overflow */
    clipr = Rect(-0x3FFFFFFF, -0x3FFFFFFF, 0x3FFFFFFF, 0x3FFFFFFF);
else
    clipr = r;
@
% hacky a bit this huge but not infinite



<<[[drawmesg()]] allocate image case, clip clipr>>=
if(!repl)
    rectclip(&i->clipr, r);
@
% kinda optimize a bit more and restrict clipr even more (to be inside r)

% flushmemscreen | drawmesg(allocate) | ... -> <>
<<function rectclip>>=
bool
rectclip(Rectangle *rp, Rectangle b) /* first by reference, second by value */
{
    Rectangle *bp = &b;
    /*
     * Expand rectXrect() in line for speed
     */
    if(!(rp->min.x < bp->max.x && bp->min.x < rp->max.x &&
        rp->min.y < bp->max.y && bp->min.y < rp->max.y))
        return false;

    /* They must overlap */
    if(rp->min.x < bp->min.x)
        rp->min.x = bp->min.x;
    if(rp->min.y < bp->min.y)
        rp->min.y = bp->min.y;
    if(rp->max.x > bp->max.x)
        rp->max.x = bp->max.x;
    if(rp->max.y > bp->max.y)
        rp->max.y = bp->max.y;
    return true;
}
@
% FIGURE with intersection

% return false if no overlap. will be used as rectclip(x, screenimage->r)
%  to see if rectangle is outside screen in which case flush is not needed.



\subsection{API}

<<function replclipr>>=
void
replclipr(Image *i, bool repl, Rectangle clipr)
{
    <<[[replclipr()]] body>>
}
@
% can you enlarge?

\subsection{Marshalling}

<<[[replclipr()]] body>>=
byte *b;

// set repl and clip: 'c' dstid[4] repl[1] clipR[4*4]
b = bufimage(i->display, 1+4+1+4*4);
b[0] = 'c';
BPLONG(b+1, i->id);
repl = (repl != 0);
b[5] = repl;
BPLONG(b+6, clipr.min.x);
BPLONG(b+10, clipr.min.y);
BPLONG(b+14, clipr.max.x);
BPLONG(b+18, clipr.max.y);
i->repl = repl;
i->clipr = clipr;
@
%old: was 22 but more consistent to put the series of plus as before

\subsection{Unmarshalling}

<<[[drawmesg()]] locals>>=
DImage *ddst;
Memimage *dst;
@

<<[[drawmesg()]] cases>>=
/* set repl and clip: 'c' dstid[4] repl[1] clipR[4*4] */
case 'c':
    printmesg(fmt="LbR", a, false);
    m = 1+4+1+4*4;
    <<[[drawmesg()]] sanity check n with m>>
    ddst = drawlookup(client, BGLONG(a+1), true);
    <<[[drawmesg()]] clipping case, sanity check ddst>>
    dst = ddst->image;

    if(a[5])
        dst->flags |= Frepl;
    drawrectangle(&dst->clipr, a+6); // The call

    continue;

@
% forgot call rectclip()? to make sure valid clipr?

<<[[drawmesg()]] clipping case, sanity check ddst>>=
if(ddst == nil)
    error(Enodrawimage);
@


\subsection{Algorithm}

% The call is actually drawrectangle which really just parse
% a rectangle, so the call is actually to modify dst->clipr.

% But later we will see memimagedraw which use clipping when
% draw a src on dst. But code of drawclip() is very complicated
% so see section X later.



\section{Flushing}

% annoying? why need that? leaky abstraction?
% cos cant hide remote feature of /dev/draw a la X11?

\subsection{API}

% visible argument? called many times with false internally
%  to avoid wrong error messages

<<function flushimage>>=
errorneg1
flushimage(Display *d, bool visible)
{
    <<[[flushimage()]] sanity check d>>
    <<[[flushimage()]] if visible>>
    return doflush(d);
}
@
\l why not use global display instead? can have multiple one?
%ocaml: use exn so less need of those intermediate flush?
%ocaml: use 2 different functions so clearer interface than boolean arg
%dead:
%        <<[[flushimage()]] if isnew>>

% should be called flushdisplay more than flushimage.

% we saw doflush before which triggers the write on /dev/draw/x/data fd.
% 

<<[[flushimage()]] sanity check d>>=
if(d == nil)
    return OK_0;
@
% meh OK
%ocaml: no need


%dead: seems useless because unmarshalling code does not use extra passed info
%   <<[[Display]] other fields>>=
%   bool	_isnewdisplay;
%   @
%   <<[[initdisplay()]] locals>>=
%   bool isnew = false;
%   @
%   <<[[initdisplay()]] set isnew>>=
%   if(n < NINFO)	/* this will do for now, we need something better here */
%       isnew = true;
%   @
%   <<[[initdisplay()]] set display _isnewdisplay part1>>=
%   disp->_isnewdisplay = isnew;
%   @
%   
%   <<[[initdisplay()]] locals>>=
%   Dir *dir;
%   @
%   <<[[initdisplay()]] set display _isnewdisplay part2>>=
%   dir = dirfstat(ctlfd);
%   if(dir!=nil && dir->qid.vers==1)	/* other way to tell */
%       disp->_isnewdisplay = true;
%   free(dir);
%   @
%dead:
%if(dir!=nil && dir->type=='i'){
%    disp->local = true;
%    disp->dataqid = dir->qid.path;
%}
%    
%    <<[[flushimage()]] if isnew>>=
%    if(d->_isnewdisplay){
%        BPLONG(d->bufp, d->screenimage->id);
%        d->bufp += 4;
%    }
%    @
% after v, but according to drawmesg protocol and unmarshalling
% code the code does not use this id.




\subsection{Marshalling}

% extra message for the kernel.

<<[[flushimage()]] if visible>>=
// visible: 'v'
if(visible){
    *d->bufp++ = 'v';	/* five bytes always reserved for this */
}
@
% but now I dont use five, I use only 1 cos no more _isnew stuff
% so invalid comment

% see doflush in chapter Kernel/User bridge which finally writes
% on /dev/draw/x/data

\subsection{Unmarshalling}

<<[[drawmesg()]] cases>>=
/* visible: 'v' */
case 'v':
    printmesg(fmt="", a, false);
    m = 1;

    drawflush(); // The call

    continue;

@


\subsection{Algorithm}


<<global flushrect>>=
static  Rectangle   flushrect;
@
% who sets it except drawflush? 
% - dstflush called by memimagedraw
% - addflush
% - drawopen(Qctl)

% drawclose | ... -> <>
<<function drawflush>>=
void
drawflush(void)
{
    if(flushrect.min.x < flushrect.max.x)
        arch_flushmemscreen(flushrect);
    flushrect = Rect(10000, 10000, -10000, -10000);
}
@
% it's actually an empty rectangle! min is more than max!
% see combinerect below.
\l why not use Rect(0,0, 0,0) instead? because can have Rect outside screen?

% some code can limit the flushrect so can optimize things.


% drawmesg(draw) | ??? -> <>
<<function dstflush>>=
void
dstflush(int dstid, Memimage *dst, Rectangle r)
{
    <<[[dstflush()]] locals>>

    if(dstid == 0){ // the screen
        combinerect(&flushrect, r);
        return;
    }
    // else
    <<[[dstflush()]] sanity check dst>>
    <<[[dstflush()]] if layer>>
}
@
\t but flushrect is huge originally so combine is useless.
% pass dstid cos id not in Memimage and we want to check if it is the screen.

<<[[dstflush()]] sanity check dst>>=
/* how can this happen? -rsc, dec 12 2002 */
if(dst == nil){
    print("nil dstflush\n");
    return;
}
@

<<function combinerect>>=
void
combinerect(Rectangle *r1, Rectangle r2)
{
    if(r1->min.x > r2.min.x)
        r1->min.x = r2.min.x;
    if(r1->min.y > r2.min.y)
        r1->min.y = r2.min.y;
    if(r1->max.x < r2.max.x)
        r1->max.x = r2.max.x;
    if(r1->max.y < r2.max.y)
        r1->max.y = r2.max.y;
}
@
% bounding box, useless to optimize further.




\subsection{Hardware support hook (x86)}

% on bcm/ this is a noop as write in the frame buffer are already
% flushed ... it's a direct connection.
\t but how sync with monitor and avoid flickering?


% 386/vgascreen.c!
% drawflush | many more functions (e.g., swcursorhide) -> <>
<<function flushmemscreen(x86)>>=
/*
 * It would be fair to say that this doesn't work for >8-bit screens.
 */
void
arch_flushmemscreen(Rectangle r)
{
    VGAscr *scr;
    <<[[flushmemscreen()]] other locals>>

    scr = &vgascreen;

    // call the device driver flush hook
    if(scr->dev && scr->dev->flush){
        scr->dev->flush(scr, r);
        return;
    }
    // else
    if(gscreen == nil || !scr->useflush)
        return;
    if(scr->dev == nil || scr->dev->page == nil)
        return;
    if(!rectclip(&r, gscreen->r))
        return;

    <<[[flushmemscreen()]] use VGA page>>
}
@
% See appendix for dev->flush and dev->page implementation


\section{Naming and sharing}
% (and windowing system support)
\n mv in adv topics? at the same time windows is so complicated
\n  that good to divide and see a first chunk earlier.


% A form of IPC. Like named pipe, here named images.
%alt: ?? could not use FS for that?


% used also by rio! (see graphics(2)). 
% from allocimage(2):
%  These routines permit unrelated applications sharing a display to share 
%  an image; for example they provide the mechanism behind getwindow

\subsection{API}

<<function nameimage>>=
error0
nameimage(Image *i, char *name, bool in)
{
    <<[[nameimage()]] body>>
}
@
% if [[in]] is true then image published, otherwise name removed (out)

<<function namedimage>>=
Image*
namedimage(Display *d, char *name)
{
    <<[[namedimage()]] body>>
}
@



\subsection{Marshalling}

<<[[nameimage()]] body>>=
byte *a;
int n;

n = strlen(name);
// name an image: 'N' dstid[4] in[1] j[1] name[j]
a = bufimage(i->display, 1+4+1+1+n);
<<[[nameimage()]] sanity check a>>
a[0] = 'N';
BPLONG(a+1, i->id);
a[5] = in;
a[6] = n;
memmove(a+7, name, n);

if(flushimage(i->display, false) < 0)
    return ERROR_0;
return OK_1;
@
\l why not sanity check here than n not more than 256!

<<[[nameimage()]] sanity check a>>=
if(a == nil)
    return ERROR_0;
@




<<[[namedimage()]] body>>=
byte *a;
char *err = nil;
char buf[12*12+1]; // NINFO+1
Image *i = nil;
int id, n;
ulong chan;

n = strlen(name);
<<[[namedimage()]] sanity check n>>
/* flush pending data so we don't get error allocating the image */
flushimage(d, false);

// attach to a named image: 'n' dstid[4] j[1] name[j]
a = bufimage(d, 1+4+1+n);
<<[[namedimage()]] sanity check a>>

d->imageid++;
id = d->imageid;

a[0] = 'n';
BPLONG(a+1, id);
a[5] = n;
memmove(a+6, name, n);

if(flushimage(d, false) < 0)
    goto Error;

if(pread(d->ctlfd, buf, sizeof buf, 0) < 12*12)
    goto Error;
buf[12*12] = '\0';

i = malloc(sizeof(Image));
<<[[namedimage()]] sanity check i>>

i->display = d;
i->id = id;
chan=strtochan(buf+2*12);
<<[[namedimage()]] sanity check chan>>
i->chan = chan;
i->depth = chantodepth(chan);
i->repl = atoi(buf+3*12);
i->r.min.x = atoi(buf+4*12);
i->r.min.y = atoi(buf+5*12);
i->r.max.x = atoi(buf+6*12);
i->r.max.y = atoi(buf+7*12);
i->clipr.min.x = atoi(buf+8*12);
i->clipr.min.y = atoi(buf+9*12);
i->clipr.max.x = atoi(buf+10*12);
i->clipr.max.y = atoi(buf+11*12);

i->screen = nil;
i->next = nil;

return i;
@
\l could sanity check get same id than the one required

% similar to initdisplay, read /dev/draw/x/ctl again to get all info

<<[[namedimage()]] sanity check n>>=
if(n >= 256){
    err = "name too long";
Error:
    if(err)
        werrstr("namedimage: %s", err);
    else
        werrstr("namedimage: %r");
    if(i)
        free(i);
    return nil;
}
@

<<[[namedimage()]] sanity check a>>=
if(a == nil)
    goto Error;
@

<<[[namedimage()]] sanity check i>>=
if(i == nil){
Error1:
    a = bufimage(d, 1+4);
    if(a){
        a[0] = 'f';
        BPLONG(a+1, id);
        flushimage(d, false);
    }
    goto Error;
}
@

<<[[namedimage()]] sanity check chan>>=
if(chan == 0){
    werrstr("bad channel '%.12s' from devdraw", buf+2*12);
    goto Error1;
}
@

\subsection{Unmarshalling}

<<[[drawmesg()]] locals>>=
int c, j;
DImage *di;
DName *dn;
@

<<[[drawmesg()]] cases>>=
/* name an image: 'N' dstid[4] in[1] j[1] name[j] */
case 'N':
    printmesg(fmt="Lbz", a, false);
    m = 1+4+1+1;
     <<[[drawmesg()]] sanity check n with m>>
    c = a[5];
    j = a[6];
     <<[[drawmesg()]] name an image case, sanity check j>>
    m += j;
     <<[[drawmesg()]] sanity check n with m>>

    di = drawlookup(client, BGLONG(a+1), false);
    <<[[drawmesg()]] name an image case, sanity check di>>

    if(c)
        drawaddname(client, di, j, (char*)a+7); // The call
    else{
        dn = drawlookupname(j, (char*)a+7);
        <<[[drawmesg()]] name an image case, sanity check dn>>
        drawdelname(dn);
    }
    continue;
@

<<[[drawmesg()]] name an image case, sanity check j>>=
if(j == 0)  /* give me a non-empty name please */
    error(Eshortdraw);
@

<<[[drawmesg()]] name an image case, sanity check di>>=
if(di == nil)
    error(Enodrawimage);
if(di->name)
    error(Enamed);
@

<<[[drawmesg()]] name an image case, sanity check dn>>=
if(dn == nil)
    error(Enoname);
if(dn->dimage != di)
    error(Ewrongname);
@

<<[[drawmesg()]] cases>>=
/* attach to a named image: 'n' dstid[4] j[1] name[j] */
case 'n':
    printmesg(fmt="Lz", a, false);
    m = 1+4+1;
    <<[[drawmesg()]] sanity check n with m>>
    j = a[5];
    <<[[drawmesg()]] name an image case, sanity check j>>
    m += j;
    <<[[drawmesg()]] sanity check n with m>>
    dstid = BGLONG(a+1);

    if(drawlookup(client, dstid, false))
        error(Eimageexists);

    dn = drawlookupname(j, (char*)a+6); // The call
     <<[[drawmesg()]] attach to an image case, sanity check dn>>
    // create new DImage with shared underlying Memimage of dn
    if(drawinstall(client, dstid, dn->dimage->image, nil) == 0)
        error(Edrawmem);
    di = drawlookup(client, dstid, false);
    <<[[drawmesg()]] attach to an image case, sanity check di>>

    <<[[drawmesg()]] attach to an image case, set di name fields using dn>>

    // for further read on /dev/draw/x/ctl
    client->infoid = dstid;
    continue;
@
% infoid! so further read of /dev/draw/x/ctl will get info about namedimage

<<[[drawmesg()]] attach to an image case, sanity check dn>>=
if(dn == nil)
    error(Enoname);
@

<<[[drawmesg()]] attach to an image case, sanity check di>>=
if(di == nil)
    error("draw: cannot happen");
@

\subsection{Algorithm}
% and [[DName]]

% drawlookup seen before, return DImage given a client and id.

<<[[KDraw]] other fields>>=
// growing_array<DName>, size = KDraw.nname
DName*  name;
int     nname;
@
\l a hash from name to (Client x Dimage) would be better maybe? scales better.

<<struct DName>>=
struct DName
{
    // key
    char        *name;

    // value
    Client      *client; // the owner
    DImage*     dimage;
    <<[[DName]] other fields>>
};
@
% ctor = ???

% drawmesg(find a named image, or out a named image) -> <>
<<function drawlookupname>>=
DName*
drawlookupname(int n, char *str)
{
    DName *name, *ename;

    name = sdraw.name;
    ename = &name[sdraw.nname];
    for(; name<ename; name++)
        if(drawcmp(name->name, str, n) == 0)
            return name;
    return nil;
}
@
\l should reverse parameter, more consistent

<<function drawcmp>>=
static
int
drawcmp(char *a, char *b, int n)
{
    if(strlen(a) != n)
        return 1;
    return memcmp(a, b, n);
}
@





<<function drawaddname>>=
void
drawaddname(Client *client, DImage *di, int n, char *str)
{
    DName *name, *ename, *new, *t;

    name = sdraw.name;
    ename = &name[sdraw.nname];
    for(; name<ename; name++)
        if(drawcmp(name->name, str, n) == 0)
            error(Enameused);

    // grow array
    <<[[drawaddname()]] grow array by 1 element>>

    new = &sdraw.name[sdraw.nname++];
    new->name = smalloc(n+1);
    memmove(new->name, str, n);
    new->name[n] = '\0';

    new->dimage = di;
    new->client = client;

    new->vers = ++sdraw.vers;
}
@

<<[[drawaddname()]] grow array by 1 element>>=
t = smalloc((sdraw.nname+1)*sizeof(DName));
memmove(t, sdraw.name, sdraw.nname*sizeof(DName));
free(sdraw.name);
sdraw.name = t;
@

%dtor
<<function drawdelname>>=
void
drawdelname(DName *name)
{
    int i;

    i =  name - sdraw.name;
    memmove(name, name+1, (sdraw.nname-(i+1))*sizeof(DName));
    sdraw.nname--;
}
@



<<[[DImage]] other fields>>=
// option<string>, Some when DImage derives from a named image
char    *name;
// option<ref<DImage>>
DImage*     fromname;   /* image this one is derived from, by name */
@
\l mv earlier in section?

<<[[drawmesg()]] attach to an image case, set di name fields using dn>>=
di->name = smalloc(j+1);
memmove(di->name, a+6, j);
di->name[j] = '\0';
di->fromname = dn->dimage;
di->fromname->ref++;
di->vers = dn->vers;
@


% we gonna share images between clients so need owner, need
% versioning, etc to keep things in sync.
\l really? need vers?

<<[[KDraw]] other fields>>=
int     vers;
@
<<[[DName]] other fields>>=
int     vers;
@
<<[[DImage]] other fields>>=
int     vers;
@
% used by drawgoodname() (used itself by??)




<<[[drawmesg()]] clipping case, sanity check ddst>>=
if(ddst->name)
    error("cannot change repl/clipr of shared image");
@
% first level of security?


<<[[drawclose()]] free names>>=
/* free names */
for(i=0; i<sdraw.nname; )
    if(sdraw.name[i].client == cl)
        drawdelname(sdraw.name+i);
    else
        i++;
@


<<[[drawfreedimage()]] free names>>=
/* any names? */
for(i=0; i<sdraw.nname; )
    if(sdraw.name[i].dimage == dimage)
        drawdelname(sdraw.name+i);
    else
        i++;

if(dimage->fromname){   /* acquired by name; owned by someone else*/
    drawfreedimage(dimage->fromname);
    goto Return;
}
@
% what about other clients of dimage? no, ref is 0 when we are here.





% -> <>
<<function drawgoodname>>=
bool
drawgoodname(DImage *d)
{
    DName *n;

    <<[[drawgoodname()]] if DImage [[d]] is a window>>

    if(d->name == nil)
        return true;
    n = drawlookupname(strlen(d->name), d->name);
    if(n == nil || n->vers != d->vers)
        return false;
    return true;
}
@
% but who increments vers? nobody.
\t rename> draw_stillvalidname? 

% drawlookup seen before, return DImage given a client and id.

<<[[drawlookup()]] if checkname>>=
if(checkname && !drawgoodname(d))
    error(Eoldname);
@
% when drawlookup with checkname = true?




\chapter{Manipulating Rectangles}
\label{chap:draw}

%\section{[[Point]] and [[Rectangle]]} types in core DS.

% Drawing a "rectangle" is actually a fundamental op. 
% Rectangle can represent an area. Can set/unset/copy/blend 
%  pixels from one area of one  image to another image.
% No need complex algo, horiz and vert lines map well to pixels.
% No need complex shape algorithm, just move all the bytes covering a rectangle.
% In fact it is the basis used by other shape algorithms.

% But operations is actually quite complicated still.

%real-world: the fundamental block of cairo seems to be trapezoids.
% the fundamental block of 3D cards are triangles.

% http://blog.golang.org/go-imagedraw-package is pretty good to
%  explain API and rational (but has just draw(), no line()/ellipsis()/...)

% aka bitblt aka RasterOp

\section{[[draw()]]}

% draw() is fundamental op!
% very flexible.
% normally should be simple but made complicated because of possible
%  complex source, mask, replication, translation, optimisations, 
%  image formats, etc.

% Can have very fancy things done easily (e.g., gradient, tiling, transluscent)
%  but very simple things like drawing a rectangle with one color are
%  forced to use an API a bit more complicated than what it should.

%show toy program and screenshot of the rectangle!
% maybe with very simple draw(dst, Rect(10,10, 20,20), Black, nil, ZR);

%less: put technicolor.ps slides with draw (of actual images like in racket)?
% (meh, technicolors.ps not that good actually)

% see bibio/cs-history/pike84bitblt.pdf, history bitblt() from the Alto
% and Blit. History and implementation. Inventor = Dan Ingalls Diana Merry

\subsection{API}

<<function draw>>=
void
draw(Image *dst, Rectangle r, Image *src, Image *mask, Point p1)
{
    draw1(dst, &r, src, &p1, mask, &p1, SoverD);
}
@
% SoverD Source Over Destination, classic
% see plan9-in-technicolor.ps! bitblt and porter-diff compositing algebra

% FIGURE with meaning of p1, r, vs src, mask, and dst.
% r is rectangle in dst (if not it's clipped anyway).
% p1 is point in src (or mask), which where things will start.
% it will correspond to r.min.
% See draw(2) to understand the complex semantic with repl and clipr.

% For very simple cases src is just a color (and so replicated) 
%  and p1 does not really matter.
% Then can do simple case where dst and src starts at 0,0
%  and then can alter a bit r and p1.
% src can also be a tile in which case p1 matters too.


<<function drawop>>=
void
drawop(Image *dst, Rectangle r, Image *src, Image *mask, Point p1, Drawop op)
{
    draw1(dst, &r, src, &p1, mask, &p1, op);
}
@

% actually this is the one mentionned in the plan9-in-technicolor.ps slides
<<function gendraw>>=
void
gendraw(Image *dst, Rectangle r, Image *src, Point p0, Image *mask, Point p1)
{
    draw1(dst, &r, src, &p0, mask, &p1, SoverD);
}
@

<<function gendrawop>>=
void
gendrawop(Image *dst, Rectangle r, Image *src, Point p0, Image *mask, Point p1, Drawop op)
{
    draw1(dst, &r, src, &p0, mask, &p1, op);
}
@
%ocaml: have just draw and draw_gen




% images are colors! with repl set to true and rect to just 1.
% e.g., Display->black. See toy app.


<<function border>>=
void
border(Image *im, Rectangle r, int i, Image *color, Point sp)
{
    <<[[border()]] if negative i, border goes outside>>
    // horizontal bars
    draw(im, Rect(r.min.x, r.min.y,   r.max.x, r.min.y+i),
        color, nil, sp);
    draw(im, Rect(r.min.x, r.max.y-i,   r.max.x, r.max.y),
        color, nil, Pt(sp.x, sp.y+Dy(r)-i));
    // vertical bars
    draw(im, Rect(r.min.x, r.min.y+i,   r.min.x+i, r.max.y-i),
        color, nil, Pt(sp.x, sp.y+i));
    draw(im, Rect(r.max.x-i, r.min.y+i,   r.max.x, r.max.y-i),
        color, nil, Pt(sp.x+Dx(r)-i, sp.y+i));
}
@
% outline of a rectangle. if i positive the border goes inside, if
% negative outside.
% Should be in poly.c; a special case polygon, but better to illustrate
% how to use draw earlier.

% FIGURE with each stripe.
% Note that could simplify if accept to redraw two times on the corner.
% But maybe color has some alpha! so must take care of that.

% subtle is the sp translation. For now ignore.

<<[[border()]] if negative i, border goes outside>>=
if(i < 0){
    r = insetrect(r, i);
    sp = addpt(sp, Pt(i,i));
    i = -i;
}
@

<<function insetrect>>=
Rectangle
insetrect(Rectangle r, int n)
{
    r.min.x += n;
    r.min.y += n;
    r.max.x -= n;
    r.max.y -= n;
    return r;
}
@
% enlarge rectangle when n is negative. reduce if positive.






\subsection{Marshalling}

<<function draw1>>=
static void
draw1(Image *dst, Rectangle *r, Image *src, Point *p0, Image *mask, Point *p1, Drawop op)
{
    byte *a;

    _setdrawop(dst->display, op);

    // draw: 'd' dstid[4] srcid[4] maskid[4] R[4*4] P[2*4] P[2*4]
    a = bufimage(dst->display, 1+4+4+4+4*4+2*4+2*4);
    <<[[draw1()]] sanity check a>>
    <<[[draw1()]] sanity check src and mask>>
    a[0] = 'd';
    BPLONG(a+1, dst->id);
    BPLONG(a+5, src->id);
    BPLONG(a+9, mask->id);
    BPLONG(a+13, r->min.x);
    BPLONG(a+17, r->min.y);
    BPLONG(a+21, r->max.x);
    BPLONG(a+25, r->max.y);
    BPLONG(a+29, p0->x);
    BPLONG(a+33, p0->y);
    BPLONG(a+37, p1->x);
    BPLONG(a+41, p1->y);
}
@
\l why not _draw? be more consistent

% communicate juste id! efficient network wise!
% if want color then need different image each time! (or have
% image with all colors and pass the right sp?)

<<function _setdrawop>>=
void
_setdrawop(Display *d, Drawop op)
{
    uchar *a;

    if(op != SoverD){
        a = bufimage(d, 1+1);
        <<[[_setdrawop()]] sanity check a>>
        a[0] = 'O';
        a[1] = op;
    }
}
@
% most op are SoverD hence this opti and the default
%  setting back to SoverD server side in drawclientop().




<<[[draw1()]] sanity check a>>=
if(a == nil)
    return; // warning?
@
%ocaml: exn. ugly no way to know if error in C!

<<[[_setdrawop()]] sanity check a>>=
if(a == nil)
    return; // warning?
@

<<[[draw1()]] sanity check src and mask>>=
if(src == nil)
    src = dst->display->black;
if(mask == nil)
    mask = dst->display->opaque;
@

\subsection{Unmarshalling}

<<[[drawmesg()]] locals>>=
Memimage *src, *mask;
Point p, q;
// enum<Drawop>
int op;
@

<<[[drawmesg()]] cases>>=
/* draw: 'd' dstid[4] srcid[4] maskid[4] R[4*4] P[2*4] P[2*4] */
case 'd':
    printmesg(fmt="LLLRPP", a, false);
    m = 1+4+4+4+4*4+2*4+2*4;
    <<[[drawmesg()]] sanity check n with m>>
    dstid = BGLONG(a+1);
    dst = drawimage(client, a+1);
    src = drawimage(client, a+5);
    mask = drawimage(client, a+9);
    drawrectangle(&r, a+13);
    drawpoint(&p, a+29);
    drawpoint(&q, a+37);

    op = drawclientop(client);
    memdraw(dst, r, src, p, mask, q, op); // the call!

    dstflush(dstid, dst, r);
    continue;
@
% dstflush!

<<function drawpoint>>=
void
drawpoint(Point *p, uchar *a)
{
    p->x = BGLONG(a+0*4);
    p->y = BGLONG(a+1*4);
}
@
%ocaml: can also have a bp_point()

% from image id to Memimage through intermediate DImage.
<<function drawimage>>=
Memimage*
drawimage(Client *client, byte *a)
{
    DImage *d;

    d = drawlookup(client, BGLONG(a), true);
    <<[[drawimage()]] sanity check d>>
    return d->image;
}
@


<<[[drawimage()]] sanity check d>>=
if(d == nil)
    error(Enodrawimage);
@







<<function drawclientop>>=
static int
drawclientop(Client *cl)
{
    int op;

    op = cl->op;
    cl->op = SoverD;
    return op;
}
@
% reset drawop to default value?

<<[[drawmesg()]] cases>>=
/* set compositing operator for next draw operation: 'O' op */
case 'O':
    printmesg(fmt="b", a, false);
    m = 1+1;
    <<[[drawmesg()]] sanity check n with m>>
    client->op = a[1];
    continue;
@





%dead: not even mentionned in the draw(5) and nothing generate such a message
% <<[[drawmesg()]] cases>>=
% /* create image mask: 'm' newid[4] id[4] */
% case 'm':
%     printmesg("LL", a, false);
%     m = 4+4;
%     if(n < m)
%         error(Eshortdraw);
%     break;
% @


\subsection{Algorithm}

% quite complicated, many usecases, many wrappers, many layers, many formats,
%  many optis.
% draw() is very flexible and so it is quite complicated to implement.
% So we will simplify and show simple and general path first.

\subsubsection{[[memdraw()]]}

% actually in memlayer/
<<function memdraw>>=
void
memdraw(Memimage *dst, Rectangle r, Memimage *src, Point p0, Memimage *mask, Point p1, int op)
{
    <<[[memdraw()]] locals>>

    DBG("memdraw %p %R %p %P %p %P\n", dst, r, src, p0, mask, p1);
    <<[[memdraw()]] sanity check mask>>

    <<[[memdraw()]] if mask has layer>>
    Top:
    if(dst->layer == nil && src->layer == nil){
        memimagedraw(dst, r, src, p0, mask, p1, op); // back to memdraw
        return;
    }
    <<[[memdraw()]] when have layers>>
}
@

% wrapper, more complex when have layers/windows, see chapter X.

<<[[memdraw()]] sanity check mask>>=
if(mask == nil)
    mask = memopaque;
@
% already done client side though, and drawimage make sure
%  maskid is valid, so this should never happen when called from
%  drawmesg().

\subsubsection{[[Memdrawparam]]}

% plan9-in-technicolor.ps! see draw()
<<struct Memdrawparam>>=
struct	Memdrawparam
{
    Memimage *dst;
    Rectangle	r;

    Memimage *src;
    Rectangle sr;

    Memimage *mask;
    Rectangle mr;

    // enum<Drawop>
    int op;

    <<[[Memdrawparam]] other fields>>
};
@
% all rectangles should have same size.
% put in special struct cos gonna pass it down a lot, to many
% functions.

\subsubsection{[[memimagedraw()]]}

% back to memdraw/
<<function memimagedraw>>=
void
memimagedraw(Memimage *dst, Rectangle r, Memimage *src, Point p0, Memimage *mask, Point p1, int op)
{
    Memdrawparam par;

    DBG1("memimagedraw %p/%luX %R @ %p %p/%luX %P %p/%luX %P... ", dst, dst->chan, r, dst->data->bdata, src, src->chan, p0, mask, mask->chan, p1);
    <<[[memdraw()]] sanity check mask>>
    <<[[memimagedraw()]] sanity check op>>

    // Clipping
    <<[[memimagedraw()]] call drawclip, if empty rectangle return>>

    par.op = op;
    par.dst = dst;
    par.r = r;
    par.src = src;
    par.mask = mask;
    /* par.sr set by drawclip */
    /* par.mr set by drawclip */

    // Replicating (and adjust par.state)
    par.state = 0;
    <<[[memimagedraw()]] if src is repl>>
    <<[[memimagedraw()]] if mask is repl>>

    DBG1("dr %R sr %R mr %R...", r, par.sr, par.mr);
    DBG1("draw dr %R sr %R mr %R %lux\n", r, par.sr, par.mr, par.state);

    // Optimizing
    /*
     * Now that we've clipped the parameters down to be consistent, we 
     * simply try sub-drawing routines in order until we find one that was able
     * to handle us.  If the sub-drawing routine returns zero, it means it was
     * unable to satisfy the request, so we do not return.
     */
    <<[[memimagedraw()]] try hwdraw>>
    <<[[memimagedraw()]] try memoptdraw>>
    <<[[memimagedraw()]] try chardraw>>
    // else

    // Compositing
    /*
     * General calculation-laden case that does alpha for each pixel.
     */
    alphadraw(&par);
    DBG("alphadraw handled\n");
}
@
%dead:
% static int n = 0;
%old: argh, was ugly debugging code, I improved a bit by using DBG1 macro
%    DBG1("test hwdraw\n");
%    DBG1("test memoptdraw\n");
%    DBG1("test chardraw\n");
%    DBG1("do alphadraw\n");


<<[[memimagedraw()]] sanity check op>>=
if(op < Clear || op > SoverD){
    DBG1("op out of range: %d\n", op);
    return;
}
@

% will see clipping, replicating, and memoptdraw and alphadraw in next sections


\subsection{Hardware support hook (x86)}

% but really optional, bcm/screen.c does nothing except
% calling the software cursor save/restore.

% maybe assume simple screen device, like for raspberry,
% and where it's actually a frame buffer where hwdraw does nothing
% except the software cursor stuff.


<<[[memimagedraw()]] try hwdraw>>=
/*
 * Hardware support.  Each video driver provides this function,
 * which checks to see if there is anything it can help with.
 * There could be an if around this checking to see if dst is in video memory.
 */
if(hwdraw(&par)){
    DBG1("hwdraw handled\n");
    return;
}
@

% vgascreen.c
<<global hwaccel(x86)>>=
bool hwaccel = true;
@

% vgascreen.c
<<function hwdraw(x86)>>=
//@Scheck: not dead, actually this is overriding some def in libmemdraw!! ugly
bool hwdraw(Memdrawparam *par)
{
    VGAscr *scr;
    Memimage *dst, *src, *mask;
    int m;

    if(!hwaccel)
        return false;

    scr = &vgascreen;

    dst=par->dst;
    src=par->src;
    mask=par->mask;
    <<[[hwdraw()]] sanity check parameters>>

    <<[[hwdraw()]] if software cursor(x86)>>
    
    if(dst->data->bdata != gscreendata.bdata)
        return false;
    // else
    <<[[hwdraw()]] when dst is the screen>>
}
@

% when dst is screen see Optimisations section in Advanced topics chapter.


<<[[hwdraw()]] sanity check parameters>>=
if(dst == nil || dst->data == nil)
    return false;
if(src == nil || src->data == nil)
    return false;
if(mask == nil || mask->data == nil)
    return false;
@


\section{Clipping}
% part1, because alphadraw does another final clipping.

% saw rectclip() before which will be used heavily below in drawclip().

% see draw(2) and explanation of draw() to understand
%  what clipping is done. Quite long description actually.

\subsection{[[drawclip()]]}

<<[[memimagedraw()]] call drawclip, if empty rectangle return>>=
if(!drawclip(dst, &r, src, &p0, mask, &p1,   &par.sr, &par.mr)){
    DBG1("empty clipped rectangle\n");
    return;
}
@
% will adjust source and mask rectangle sr and mr.
% they will all have the same size but start at the right place,
%  see the assert below.


% FIGURE! where see different coordinate system


% memimagedraw | ?? -> <>
<<function drawclip>>=
/*
 * Clip the destination rectangle further based on the properties of the 
 * source and mask rectangles.  Once the destination rectangle is properly
 * clipped, adjust the source and mask rectangles to be the same size.
 * Then if source or mask is replicated, move its clipped rectangle
 * so that its minimum point falls within the repl rectangle.
 *
 * Return zero if the final rectangle is null.
 */
bool
drawclip(Memimage *dst, Rectangle *r, Memimage *src, Point *p0, Memimage *mask, Point *p1,   Rectangle *sr, Rectangle *mr)
{
    Point rmin = r->min; // save old min
    <<[[drawclip()]] other locals>>

    // empty rectangle? nothing to do then.
    if(r->min.x >= r->max.x || r->min.y >= r->max.y)
        return false;

    <<[[drawclip()]] clipping to destination>>
    <<[[drawclip()]] clipping to source>>
    <<[[drawclip()]] clipping to mask>>

    /* move source clipping back to destination */
    <<[[drawclip()]] adjust r if sr or mr changed>>

    <<[[drawclip()]] clipping and replication handling>>

    assert(Dx(*sr) == Dx(*mr) && Dx(*mr) == Dx(*r));
    assert(Dy(*sr) == Dy(*mr) && Dy(*mr) == Dy(*r));
    assert(ptinrect(*p0, src->r));
    assert(ptinrect(*p1, mask->r));
    assert(ptinrect(r->min, dst->r));

    return true;
}
@

% note that now r, sr, mr have the same size and translated to right place.
% but actually sr and mr might be too big because src and mask could
% be replicated and smaller than that. This is why there will be
% further code later about replicating and clipping.



\subsection{Clipping to destination}

<<[[drawclip()]] clipping to destination>>=
/* clip to destination */ // can modify r
if(!rectclip(r, dst->r) || !rectclip(r, dst->clipr))
    return false;
<<[[drawclip()]] adjust p0 and p1 if r changed>>
@
% note that no repl to handle here. repl has a meaning only when
%  the image is used as a source, to tile and replicate.


% when rectangle r got actually reduced because of dst->clipr or dst->r
%  then p0 and p1 must be adjusted
<<[[drawclip()]] adjust p0 and p1 if r changed>>=
/* move source point */
// p0 = addpt(p0, subpb(r->min, rmin))
p0->x += r->min.x - rmin.x;
p0->y += r->min.y - rmin.y;
/* move mask point */
// p1 = addpt(p1, subpb(r->min, rmin))
p1->x += r->min.x - rmin.x;
p1->y += r->min.y - rmin.y;
@


\subsection{Clipping to source}

<<[[drawclip()]] clipping to source>>=
/* map destination rectangle into source */
sr->min = *p0;
sr->max.x = p0->x+Dx(*r);
sr->max.y = p0->y+Dy(*r);

/* sr is r in source coordinates; clip to source */ // can modify sr
if(!(src->flags&Frepl) && !rectclip(sr, src->r))
    return false;
if(!rectclip(sr, src->clipr))
    return false;
@
% sr is r translated to p0.

<<[[drawclip()]] other locals>>=
Point delta;
@
% r = sr translated back from p0

% when source or mask actually reduces even more rectangle
<<[[drawclip()]] adjust r if sr or mr changed>>=
delta.x = r->min.x - p0->x;
delta.y = r->min.y - p0->y;
// r = rectaddpt(sr, delta)
r->min.x = sr->min.x + delta.x;
r->min.y = sr->min.y + delta.y;
r->max.x = sr->max.x + delta.x;
r->max.y = sr->max.y + delta.y;
@


\subsection{Clipping to mask}


<<[[drawclip()]] clipping to mask>>=
/* compute and clip rectangle in mask */
<<[[drawclip()]] if splitcoords>>
else{
    if(!(mask->flags&Frepl) && !rectclip(sr, mask->r)) // can modify sr
        return false;
    if(!rectclip(sr, mask->clipr))
        return false;
    *p1 = sr->min;
}
@
% new p1


<<[[drawclip()]] other locals>>=
bool splitcoords = (p0->x != p1->x) || (p0->y != p1->y);
@

<<[[drawclip()]] other locals>>=
Rectangle omr;
@
% could use delta instead

<<[[drawclip()]] if splitcoords>>=
if(splitcoords){
    /* move mask point with source */
    // p1 = addpt(p1, subpt(sr->min, p0))
    p1->x += sr->min.x - p0->x;
    p1->y += sr->min.y - p0->y;

    mr->min = *p1;
    mr->max.x = p1->x + Dx(*sr);
    mr->max.y = p1->y + Dy(*sr);
    omr = *mr;

    /* mr is now rectangle in mask; clip it */
    if(!(mask->flags&Frepl) && !rectclip(mr, mask->r))
        return false;
    if(!rectclip(mr, mask->clipr))
        return false;

    /* reflect any clips back to source */
    // sr = rectsub(mr, omr)
    sr->min.x += mr->min.x - omr.min.x;
    sr->min.y += mr->min.y - omr.min.y;
    sr->max.x += mr->max.x - omr.max.x;
    sr->max.y += mr->max.y - omr.max.y;

    *p1 = mr->min;
}
@
% new p1

\subsection{Clipping and replication}

<<[[drawclip()]] clipping and replication handling>>=
/* move source rectangle so sr->min is in src->r */
<<[[drawclip()]] if src is repl>>
/* move mask point so it is in mask->r */
<<[[drawclip()]] mask move>>
@

\subsubsection{Clipping with replicated source}

<<[[drawclip()]] if src is repl>>=
if(src->flags&Frepl) {
    delta.x = drawreplxy(src->r.min.x, src->r.max.x, sr->min.x) - sr->min.x;
    delta.y = drawreplxy(src->r.min.y, src->r.max.y, sr->min.y) - sr->min.y;
    // sr = rectaddpt(sr, delta)
    sr->min.x += delta.x;
    sr->min.y += delta.y;
    sr->max.x += delta.x;
    sr->max.y += delta.y;
}
*p0 = sr->min;
@



% drawrepl | drawclip -> <>
<<function drawreplxy>>=
int
drawreplxy(int min, int max, int x)
{
    int sx;

    sx = (x-min) % (max-min);
    if(sx < 0)
        sx += max - min;
    return sx + min;
}
@


\subsubsection{Clipping with replicated mask}

% actually no if for the mask. Why?

<<[[drawclip()]] mask move>>=
*p1 = drawrepl(mask->r, *p1);

mr->min = *p1;
mr->max.x = p1->x+Dx(*sr);
mr->max.y = p1->y+Dy(*sr);
@

% drawclip | drawmask -> <>
<<function drawrepl>>=
Point
drawrepl(Rectangle r, Point p)
{
    p.x = drawreplxy(r.min.x, r.max.x, p.x);
    p.y = drawreplxy(r.min.y, r.max.y, p.y);
    return p;
}
@



\section{Replicating}
% part1 because later in alphadraw there is another replication
%  done via some module and [[% Dy(src->r)]] and also for the mask.

% most of the code below is preparing data when have simple
% 1x1 replicated rectangles (e.g., colors).

<<enum _anon_ (include/memdraw.h)2>>=
/*
 * Encapsulated parameters and information for sub-draw routines.
 */
enum Drawparams {
    Simplesrc =1<<0, // 1x1 src
    Simplemask=1<<1, // 1x1 mask

    Replsrc =1<<2,
    Replmask=1<<3,

    Fullmask=1<<4, // fully opaque mask
};
@
% >> >> >> >> >>
% info that can be used by further memimagedraw steps, to
%  know if can run optimized version such as hwdraw/...

<<[[Memdrawparam]] other fields>>=
// enum<Drawparams>
ulong state;
@
% state is bad name. maybe props?

\subsection{Source replication}

<<[[Memdrawparam]] other fields>>=
ulong sval;		/* if Simplesrc, the source pixel in src format */
rgba  srgba;	/* sval in rgba */
ulong sdval;	/* sval in dst format */
@
% those fields will be used later in memoptdraw for some optimized draw
\l rename sdval to dval

% remember that src is repl when Image is a simple color.
<<[[memimagedraw()]] if src is repl>>=
if(src->flags&Frepl){
    par.state |= Replsrc;
    if(Dx(src->r)==1 && Dy(src->r)==1){
        par.state |= Simplesrc;
        par.sval = pixelbits(src, src->r.min);

        par.srgba = imgtorgba(src, par.sval);
        par.sdval = rgbatoimg(dst, par.srgba);

        <<[[memimagedraw()]] when src is repl, sanity check pixel value>>
    }
}
@

% src can also be repl when tiling.

% see imgtorgba and rgbatoimg in core DS chapter.

<<[[memimagedraw()]] when src is repl, sanity check pixel value>>=
if((par.srgba&0xFF) == 0 && (op&DoutS)){
    DBG1("fill with transparent source\n");
    return;	/* no-op successfully handled */
}
@
% DoutS ? note that SoverD will satisfy this.


% memimagedraw -> <>
<<function pixelbits>>=
ulong
pixelbits(Memimage *i, Point pt)
{
    byte *p;
    ulong val = 0;
    int bpp = i->depth; // bits per pixel
    <<[[pixelbits()]] other locals>>

    p = byteaddr(i, pt);

    switch(bpp){
    <<[[pixelbits()]] switch bpp cases>>
    case 8:
        val = p[0];
        break;
    case 32:
        val = p[0]|(p[1]<<8)|(p[2]<<16)|(p[3]<<24);
        break;
    }
    <<[[pixelbits()]] duplicate byte if depth less than 32>>
    return val;
}
@
% >> >> >> >> >> >> >> >>

% duplicate byte since anyway it's a repl and it will be used in a giant
% memset

<<[[pixelbits()]] duplicate byte if depth less than 32>>=
// duplicate byte in the whole word
while(bpp<32){
    val |= val<<bpp;
    bpp *= 2;
}
@
% >>

\subsection{Mask replication}

<<[[Memdrawparam]] other fields>>=
ulong mval;		/* if Simplemask, the mask pixel in mask format */
rgba  mrgba;	/* mval in rgba */
@
% no need mdval?

% mask is repl when memopaque
<<[[memimagedraw()]] if mask is repl>>=
if(mask->flags & Frepl){
    par.state |= Replmask;
    if(Dx(mask->r)==1 && Dy(mask->r)==1){
        par.state |= Simplemask;
        par.mval = pixelbits(mask, mask->r.min);

        if(par.mval == 0 && (op&DoutS)){
            DBG1("fill with zero mask\n");
            return;	/* no-op successfully handled */
        }

        if(par.mval == ~0)
            par.state |= Fullmask;
        par.mrgba = imgtorgba(mask, par.mval);
    }
}
@



\section{Setting or copying pixels}

% kinda opti, but helps to understand alphadraw(), stepping stone.

\subsection{[[memoptdraw()]]}

<<[[memimagedraw()]] try memoptdraw>>=
/*
 * Optimizations using memmove and memset.
 */
if(memoptdraw(&par)){
    DBG1("memopt handled\n");
    return;
}
@


<<function memoptdraw>>=
static bool
memoptdraw(Memdrawparam *par)
{
    int dx, dy;
    // enum<Drawop>
    int op;
    Memimage *src, *dst;

    int m, y;
    ulong v;

    dx = Dx(par->r);
    dy = Dy(par->r);
    src = par->src;
    dst = par->dst;
    op = par->op;

    DBG1("state %lux mval %lux dd %d\n", par->state, par->mval, dst->depth);

    <<[[memoptdraw()]] if condition for memset>>
    <<[[memoptdraw()]] if condition for memmove>>
    <<[[memoptdraw()]] if 1 bit mask, src, and dest>>
    return false;	
}
@
% >>

\subsection{Setting pixels}

<<[[memoptdraw()]] if condition for memset>>=
/*
 * If we have an opaque mask and source is one opaque pixel we can
 * convert to the destination format and just replicate with memset.
 */
m = Simplesrc|Simplemask|Fullmask;
if((par->state&m)==m && 
   (par->srgba&0xFF) == 0xFF && 
   (op == S || op == SoverD)){
    byte p[4]; // source
    byte *dp;  // destination
    int dwid;
    <<[[memoptdraw()]] locals for memset case>>

    dwid = dst->width * sizeof(ulong);
    dp = byteaddr(dst, par->r.min);
    v = par->sdval;

    switch(dst->depth){
    <<[[memoptdraw()]] when condition for memset, switch depth of dst cases>>
    case 32:
        p[0] = v;		/* make little endian */
        p[1] = v>>8;
        p[2] = v>>16;
        p[3] = v>>24;
        v = *(ulong*)p;

        for(y=0; y < dy; y++, dp += dwid)
            memsetl(dp, v, dx);
        return true;
    }
}
@
%old:
%    DBG1("memopt, dst %p, dst->data->bdata %p\n", dst, dst->data->bdata);
%    DBG1("sdval %lud, depth %d\n", v, dst->depth);

% why need this little endian dance?

% so when alpha in source is 1 and have SoverD, then dst does not matter!
% indeed see the general formula later in alphacalc11

\subsection{Copying pixels}

% ok no SimpleSrc, but maybe source with no alpha so no need
% compositing.

<<[[memoptdraw()]] if condition for memmove>>=
/*
 * If no source alpha, an opaque mask, we can just copy the
 * source onto the destination.  If the channels are the same and
 * the source is not replicated, memmove suffices.
 */
m = Simplemask|Fullmask;
if((par->state&(m|Replsrc))==m && 
    src->depth >= 8 && 
    src->chan == dst->chan && 
    !(src->flags&Falpha) && 
    (op == S || op == SoverD)){

    byte *sp, *dp;
    long swid, dwid;
    long nb;
    int dir = 1;

    <<[[memoptdraw()]] when condition for memmove, change possibly dir>>

    swid = src->width * sizeof(ulong);
    dwid = dst->width * sizeof(ulong);
    sp = byteaddr(src, par->sr.min);
    dp = byteaddr(dst, par->r.min);
    <<[[memoptdraw()]] when condition for memmove, if negative dir>>
    nb = (dx * src->depth)/8;
    for(y=0; y<dy; y++, sp+=swid, dp+=dwid)
        memmove(dp, sp, nb);
    return true;
}
@

% remember than memmove handle some overlap. But it will not
%  handle all overlap hence dir adjustment below.

<<[[memoptdraw()]] when condition for memmove, change possibly dir>>=
if(src->data == dst->data && 
   byteaddr(dst, par->r.min) > byteaddr(src, par->sr.min))
    dir = -1;
@

<<[[memoptdraw()]] when condition for memmove, if negative dir>>=
if(dir == -1){
    sp += (dy-1)*swid;
    dp += (dy-1)*dwid;
    swid = -swid;
    dwid = -dwid;
}
@
% start from the end



\section{Compositing pixels}

% The general case. Compositing! advanced effects such as transluscent.
% But also advanced shape clipping, tiling, etc.

% also can have multiple "layers" with this tech and do stuff like codemap!
% intermediate surfaces. Like in Photoshop/Gimp. You Compose!

%https://en.wikipedia.org/wiki/Alpha_compositing

% Porter/Duff model. Used everywhere (cairo, OpenGL, Quartz, PDF 1.4, etc)
% draw() model actually cited by Keith Packard:
% dest = (source IN mask) OVER dest


% good example: what to draw a char, so have images with raster of
% char, but then black and white. Dont want white to cover! Could
% have convention that white means special, but more general is
% notion of alpha! Dnotacolor (or Dnofill)! fully transparent.
% And then can have different graduation of transparency! powerful!

% for transparency, drop shadows, and I think also for text anti-aliasing
% you need compositing with the old value, and you need that at different
% strength for each pixel and so an alpha channel!

\subsection{[[alphadraw()]]}

\t can write simple version when dst and src have simple and
\t  same chan format? like RGBA32?


<<[[alphadraw()]] locals>>=
Memimage *src, *mask, *dst;
Rectangle r, sr, mr;
int dx, dy;
// enum<Drawop>
int op;
@

<<[[alphadraw()]] locals>>=
bool isgrey;
@

<<[[alphadraw()]] locals>>=
Readfn *rdsrc, *rdmask, *rddst;
Calcfn *calc;
Writefn *wrdst;
@
% we will see soon the type of those functions.

<<[[alphadraw()]] locals>>=
Buffer bsrc, bdst, bmask;
@
% a full line, will see soon Buffer.

% iterate over lines, each time get a line of the rectangle.
<<[[alphadraw()]] locals>>=
int starty, endy;
int dsty, srcy, masky;
int dir;
int y; // iteration variable, we iterate over lines
@



<<function alphadraw>>=
/*
 * For each scan line, we expand the pixels from source, mask, and destination
 * into byte-aligned red, green, blue, alpha, and grey channels.  If buffering
 * is not needed and the channels were already byte-aligned 
 * (grey8, rgb24, rgba32, rgb32),
 * the readers need not copy the data: they can simply return pointers to the
 * data.
 * If the destination image is grey and the source is not, it is converted
 * using the NTSC formula.
 *
 * Once we have all the channels, we call either rgbcalc or greycalc, 
 * depending on whether the destination image is color.  This is allowed to
 * overwrite the dst buffer (perhaps the actual data, perhaps a copy) with 
 * its result.  It should only overwrite the dst buffer
 * with the same format (i.e. red bytes with red bytes, etc.)  A new buffer
 * is returned from the calculator, and that buffer is passed to a function 
 * to write it to the destination.
 * If the buffer is already pointing at the destination, the writing function 
 * is a no-op.
 */
int
alphadraw(Memdrawparam *par)
{
    <<[[alphadraw()]] locals>>

    r = par->r;
    dx = Dx(r);
    dy = Dy(r);
    src = par->src;
    mask = par->mask;	
    dst = par->dst;
    sr = par->sr;
    mr = par->mr;
    op = par->op;

    starty = 0;
    endy = dy;
    dir = 1;

    isgrey = dst->flags&Fgrey;
    <<[[alphadraw()]] set needbuf and possibly adjust starty and endy>>

    <<[[alphadraw()]] set Dbuf z part1>>

    <<[[alphadraw()]] if source has no alpha and simple bit mask>>
    else{
        /* usual alphadraw parameter fetching */
        rdsrc = readfn(src);
        rddst = readfn(dst);
        wrdst = writefn(dst);
        calc = alphacalc[op];
        <<[[alphadraw()]] set rdmask>>
    }

    <<[[alphadraw()]] when small repl rectangle optimization>>
    <<[[alphadraw()]] set Dbuf z part2>>

    <<[[alphadraw()]] setting srcy, masky, and dsty, and clipping part1>>
    assert(0 <= srcy  && srcy  < Dy(src->r));
    assert(0 <= masky && masky < Dy(mask->r));
    assert(0 <= dsty  && dsty  < Dy(dst->r));

    // the big loop!
    for(y=starty; y!=endy; y+=dir, srcy+=dir, masky+=dir, dsty+=dir){
        <<[[alphadraw()]] clipping part2>>

        bsrc  = rdsrc (&z->spar, z->spar.bufbase, srcy);
        bmask = rdmask(&z->mpar, z->mpar.bufbase, masky);
        bdst  = rddst (&z->dpar, z->dpar.bufbase, dsty);

        // !!The calc dispatch!!
        bdst = calc(bdst, bsrc, bmask, dx, isgrey, op);
        wrdst(&z->dpar, z->dpar.bytermin + dsty * z->dpar.bwidth, bdst);
    }
    <<[[alphadraw()]] free z>>
    return 1;
}
@
\l return value seems unused so void instead?
%pad: I reordered some statements, put them closer to each other sometimes

% % Dy cos of the tiling and replication!

\subsection{Buffering}

<<[[alphadraw()]] locals>>=
bool needbuf;
@

<<[[alphadraw()]] set needbuf and possibly adjust starty and endy>>=
/*
 * Buffering when src and dst are the same bitmap is sufficient but not 
 * necessary.  There are stronger conditions we could use.  We could
 * check to see if the rectangles intersect, and if simply moving in the
 * correct y direction can avoid the need to buffer.
 */
needbuf = (src->data == dst->data);

if (needbuf && byteaddr(dst, r.min) > byteaddr(src, sr.min)) {
    dir = -1;
    starty = dy-1;
    endy = -1;
}
@
%old: code was a bit different, I added the dir = 1; before
% to be able to aspectize this code.

% later will need to take care and use memmove

\subsection{Clipping and replicating}
% part2

<<[[alphadraw()]] setting srcy, masky, and dsty, and clipping part1>>=
/*
 * srcy, masky, and dsty are offsets from the top of their
 * respective Rectangles.  they need to be contained within
 * the rectangles, so clipy can keep them there without division.
 */
srcy  = (starty + sr.min.y - src->r.min.y)  % Dy(src->r);
masky = (starty + mr.min.y - mask->r.min.y) % Dy(mask->r);
dsty  =  starty + r.min.y  - dst->r.min.y;
@
% use modulo, a bit slow, but does not matter cos outside the loop.

% need modulo because sr mr are the same size than r, even if
%  src and mask are actually smaller and replicated.


<<[[alphadraw()]] clipping part2>>=
clipy(src, &srcy);
clipy(dst, &dsty);
clipy(mask, &masky);
@

% modulo without division or modulo.
<<function clipy>>=
static void
clipy(Memimage *img, int *y)
{
    int dy;

    // *y = *y % Dy(img->r)

    dy = Dy(img->r);
    if(*y == dy)
        *y = 0;
    else if(*y == -1)
        *y = dy-1;
    assert(0 <= *y && *y < dy);
}
@
% when have small tile for source or mask, need to keep it in range,
% do a modulo, which is what is done here




\subsection{Additional data structures}

\subsubsection{[[Dbuf]]}

<<struct Dbuf>>=
struct Dbuf
{
    Param spar, mpar, dpar;
    // array<byte> (length = Dbuf.n)
    byte *p;
    int n;
    <<[[Dbuf]] other fields>>
};
@
% will see Param below

% allocation

<<[[alphadraw()]] locals>>=
Dbuf *z;
@
% will hold buffers containing one line, which might be needed.

<<[[alphadraw()]] set Dbuf z part1>>=
z = allocdbuf();
<<[[alphadraw()]] sanity check z>>
<<[[alphadraw()]] set z params part1>>
@





<<global dbuf>>=
static Dbuf dbuf[10];
@

<<function allocdbuf>>=
static Dbuf*
allocdbuf(void)
{
    int i;

    for(i=0; i<nelem(dbuf); i++){
        if(dbuf[i].inuse)
            continue;
        if(!_tas(&dbuf[i].inuse))
            return &dbuf[i];
    }
    return nil;
}
@
% _tas! mutual exclusion, will set it to true.

<<[[Dbuf]] other fields>>=
bool inuse;
@

<<[[alphadraw()]] free z>>=
z->inuse = false;
@





% buffer allocation


<<[[alphadraw()]] locals>>=
byte *drawbuf;
int ndrawbuf;
@
% ndrawbuf modified later

<<[[alphadraw()]] set Dbuf z part2>>=
<<[[alphadraw()]] grow drawbuf if needed>>
drawbuf = z->p;
<<[[alphadraw()]] set z params part2>>
@

<<[[alphadraw()]] grow drawbuf if needed>>=
if(z->n < ndrawbuf){
    free(z->p);
    z->p = mallocz(ndrawbuf, 0);
    <<[[alphadraw()]] sanity check [[z->p]]>>
    z->n = ndrawbuf;
}
@



<<[[alphadraw()]] sanity check z>>=
if(z == nil)
    return 0;
@
% just return? no warning? hmm

<<[[alphadraw()]] sanity check [[z->p]]>>=
if(z->p == nil){
    z->inuse = false;
    return 0;
}
@

\subsubsection{[[ParamDraw]]}

<<struct ParamDraw>>=
/* giant rathole to customize functions with */
struct ParamDraw {

    Memimage *img;
    Rectangle	r;
    int	dx;	/* of r */ // size of a line of a rectangle in pixels
    int		bwidth; // image width in bytes

    // source bytes, always same y but x varies
    byte	*bytey0s;	/* byteaddr(Pt(img->r.min.x, img->r.min.y)) */
    byte	*bytermin;	/* byteaddr(Pt(r.min.x,      img->r.min.y)) */
    byte	*bytey0e;	/* byteaddr(Pt(img->r.max.x, img->r.min.y)) */

    bool	needbuf;
    // destination bytes
    int	bufoff;
    int	bufdelta;
    // array<byte>, (address = Dbuf.p + bufoff, length = bufdelta)
    byte	*bufbase;

    int	dir; // -1 or 1

    <<[[ParamDraw]] mask fields>>
    <<[[ParamDraw]] conversion fields>>
    <<[[ParamDraw]] replication fields>>
};
@


<<[[alphadraw()]] set z params part1>>=
ndrawbuf = 0;
getparam(&z->spar, src, sr,  isgrey, needbuf, &ndrawbuf);
getparam(&z->dpar, dst, r,   isgrey, needbuf, &ndrawbuf);
getparam(&z->mpar, mask, mr, false,  needbuf, &ndrawbuf);
z->spar.dir = z->mpar.dir = z->dpar.dir = dir;
@
% note that size of sr, r, and mr should be equal.


<<function getparam>>=
static void
getparam(Param *p, Memimage *img, Rectangle r, bool convgrey, bool needbuf, int *ndrawbuf)
{
    int nbuf;

    memset(p, 0, sizeof(Param));

    p->img = img;
    p->r = r;
    p->dx = Dx(r);
    p->needbuf = needbuf;
    p->convgrey = convgrey;

    assert(img->r.min.x <= r.min.x && r.min.x < img->r.max.x);

    p->bytey0s  = byteaddr(img, Pt(img->r.min.x, img->r.min.y));
    p->bytermin = byteaddr(img, Pt(r.min.x,      img->r.min.y));
    p->bytey0e  = byteaddr(img, Pt(img->r.max.x, img->r.min.y));

    assert(p->bytey0s <= p->bytermin && p->bytermin <= p->bytey0e);
    if(p->r.min.x == p->img->r.min.x)
        assert(p->bytermin == p->bytey0s);

    p->bwidth   = sizeof(ulong) * img->width;

    nbuf = 1;
    <<[[getparam()]] if small replicated rectangle>>

    p->bufdelta = 4 * p->dx;
    p->bufoff = *ndrawbuf;
    *ndrawbuf += p->bufdelta * nbuf;
}
@
% why augment ndrawbuf if actually no needbuf?

<<[[alphadraw()]] set z params part2>>=
/*
 * Before we were saving only offsets from drawbuf in the parameter
 * structures; now that drawbuf has been grown to accomodate us,
 * we can fill in the pointers.
 */
z->spar.bufbase = drawbuf + z->spar.bufoff;
z->mpar.bufbase = drawbuf + z->mpar.bufoff;
z->dpar.bufbase = drawbuf + z->dpar.bufoff;
@

% remember code in alphadraw then:
%        bsrc  = rdsrc (&z->spar, z->spar.bufbase, srcy);
%        bmask = rdmask(&z->mpar, z->mpar.bufbase, masky);
%        bdst  = rddst (&z->dpar, z->dpar.bufbase, dsty);


\subsubsection{[[Buffer]]}

% pointer to channel corresponding byte

<<struct Buffer>>=
struct Buffer {
    /* used by most routines */
    byte	*red;
    byte	*grn;
    byte	*blu;
    byte	*alpha; // can be &ones

    ulong	*rgba; // bad name, just start of pixel
    int	delta;	/* number of bytes to add to pointer to get next pixel to the right */

    byte	*grey;

    <<[[Buffer]] boolcalc fields>>
};
@
% delta is int so assume each pixel size is a multiple of bytes. (8, 16, ...)

%old: in alphadraw
%        DBG1("[");
%        DBG1("]\n");
%        //DBG		dumpbuf("src", bsrc, dx);
%        //DBG		dumpbuf("mask", bmask, dx);
%        //DBG		dumpbuf("dst", bdst, dx);

%dead: just used for debugging
%  <<function dumpbuf>>=
%  static void
%  dumpbuf(char *s, Buffer b, int n)
%  {
%      int i;
%      uchar *p;
%      
%      print("%s", s);
%      for(i=0; i<n; i++){
%          print(" ");
%          if(p=b.grey){
%              print(" k%.2uX", *p);
%              b.grey += b.delta;
%          }else{	
%              if(p=b.red){
%                  print(" r%.2uX", *p);
%                  b.red += b.delta;
%              }
%              if(p=b.grn){
%                  print(" g%.2uX", *p);
%                  b.grn += b.delta;
%              }
%              if(p=b.blu){
%                  print(" b%.2uX", *p);
%                  b.blu += b.delta;
%              }
%          }
%          if((p=b.alpha) != &ones){
%              print(" α%.2uX", *p);
%              b.alpha += b.delta;
%          }
%      }
%      print("\n");
%  }
%  @



\subsection{Reading pixels, [[readfn()]]}
% pixels lines

% reading for src and dst (will see reading for mask later).

<<function readfn>>=
static Readfn*
readfn(Memimage *img)
{
    <<[[readfn()]] if depth less than 8>>
    <<[[readfn()]] if cmap>>
    return readbyte;
}
@

% depth >=8  but actually must be also a multiple of 8!

<<function readbyte>>=
static Buffer
readbyte(Param *p, byte *buf, int y)
{
    Memimage *img;
    byte *begin, *end, *r;
    Buffer b;
    byte *w;
    int dx, nb;

    bool isgrey, convgrey;
    bool alphaonly, copyalpha;
    <<[[readbyte]] other locals>>

    img = p->img;
    begin = p->bytey0s  + y*p->bwidth;
    r     = p->bytermin + y*p->bwidth;
    end   = p->bytey0e  + y*p->bwidth;

    w = buf;
    dx = p->dx;
    nb = img->depth/8;

    convgrey = p->convgrey;	/* convert rgb to grey */
    isgrey   = img->flags&Fgrey;
    copyalpha = img->flags&Falpha;
    alphaonly = p->alphaonly;

    <<[[readbyte()]] simple case when no repl, no grey, depth 8>>
    // else
    <<[[readbyte()]] more complex cases, possible repl, grey, and small depth>>
}
@
%old:    copyalpha = (img->flags&Falpha) ? 1 : 0;
%    DBG1("copyalpha %d alphaonly %d convgrey %d isgrey %d\n", copyalpha, alphaonly, convgrey, isgrey);



<<[[readbyte()]] simple case when no repl, no grey, depth 8>>=
/* if we can, avoid processing everything */
if(!(img->flags&Frepl) && !convgrey && (img->flags&Fbytes)){
    memset(&b, 0, sizeof(Buffer));
    if(p->needbuf){
        memmove(buf, r, dx*nb);
        r = buf;
    }
    b.rgba = (ulong*)r;

    if(copyalpha)
        b.alpha = r + img->shift[CAlpha]/8;
    else
        b.alpha = &ones;
    <<[[readbyte()]] in simple case, if isgrey>>
    }else{
        b.red = r + img->shift[CRed]/8;
        b.grn = r + img->shift[CGreen]/8;
        b.blu = r + img->shift[CBlue]/8;
    }
    b.delta = nb;
    return b;
}
@

% Lots of stuff going on. r can point in original image directly
%  if no needbuf.
% See shift[] in Section X.

<<global ones>>=
static uchar ones = 0xff;
@
% used later too, not only in debug code




\subsection{Writing pixels, [[writefn()]]}

% Will call that only for dst, so code is simpler. No need handle repl
% for instance.

<<function writefn>>=
static Writefn*
writefn(Memimage *img)
{
    <<[[writefn()]] if depth less than 8>>
    <<[[writefn()]] if cmap>>
    return writebyte;
}
@

% depth more than 8 and a multiple of 8!
% precond is that have Fbytes? or at least pixel
% size is a multiple of bytes.

% process word by word but actually left some unchanged.
% move pixels by pixels though (nb bytes).

<<function writebyte>>=
static void
writebyte(Param *p, byte *w, Buffer src)
{
    Memimage *img;
    int dx, nb;
    byte *red, *grn, *blu, *grey, *alpha;
    int delta;
    // will iterate over all the pixels in one line in src
    int i;

    bool isalpha, isgrey;
    byte ff;
    int adelta;
    ulong u, mask;

    img = p->img;

    red = src.red;
    grn = src.grn;
    blu = src.blu;
    alpha = src.alpha;
    delta = src.delta;
    grey = src.grey;
    dx = p->dx;

    nb = img->depth/8;
    mask = (nb==4) ? 0 : ~((1<<img->depth)-1); // >>

    isalpha = img->flags&Falpha;
    isgrey = img->flags&Fgrey;

    <<[[writebyte()]] alpha handling part1>>

    for(i=0; i<dx; i++){
        u = w[0] | (w[1]<<8) | (w[2]<<16) | (w[3]<<24);
        u &= mask;
        <<[[writebyte()]] if isgrey>>
        else{
            u |= ((*red >> (8-img->nbits[CRed])) & img->mask[CRed]) << img->shift[CRed];
            u |= ((*grn >> (8-img->nbits[CGreen])) & img->mask[CGreen]) << img->shift[CGreen];
            u |= ((*blu >> (8-img->nbits[CBlue])) & img->mask[CBlue]) << img->shift[CBlue];
            red += delta;
            grn += delta;
            blu += delta;
        }
        <<[[writebyte()]] alpha handling part2>>

        w[0] = u;
        w[1] = u>>8;
        w[2] = u>>16;
        w[3] = u>>24;
        w += nb;
    }
}
@
% >> >> >> >> >> >> >> >>
%old:
%        DBG1("u %.8lux...", u);
%        DBG1("&mask %.8lux...", u);
%            DBG1("|grey %.8lux...", u);
%            DBG1("|rgb %.8lux...", u);
%            DBG1("|alpha %.8lux...", u);

% what if less than 4 channels?
%  it works thanks to umask
% we process word by word but we will always left unchanged
%  the extra byte.
% what if less than 8 bits per channel?
%  it works too thanks to nbits[]

% many situation where we need to write in dst an alpha but there 
% was no alpha channel in the src Buffer
% in which case we need to generate a default one.

<<[[writebyte()]] alpha handling part1>>=
adelta = src.delta;
if(isalpha && (alpha == nil || alpha == &ones)){
    ff = 0xFF;
    alpha = &ff;
    adelta = 0;
}
@
% why use local? because can be overwritten? could use ones too no?
% could have a src.adelta then instead of repeating the detection here.

<<[[writebyte()]] alpha handling part2>>=
if(isalpha){
    u |= ((*alpha >> (8-img->nbits[CAlpha])) & img->mask[CAlpha]) << img->shift[CAlpha];
    alpha += adelta;
}
@
%>>

\subsection{Reading the mask}

%remember that memopaque which is the default mask used when drawing
% is memones which is just a GREY1

<<[[alphadraw()]] set rdmask>>=
if(mask->flags&Falpha){
    rdmask = readalphafn(mask);
    z->mpar.alphaonly = true;
}
/*
 * If there is no alpha channel, we'll ask for a grey channel
 * and pretend it is the alpha.
 */
else{
    z->mpar.greymaskcall = readfn(mask);
    z->mpar.convgrey = true;
    rdmask = greymaskread;

    <<[[alphadraw()]] when mask and source have no alpha, possibly adapt calc>>
}
@



<<[[ParamDraw]] mask fields>>=
bool	alphaonly;
bool	convgrey;
Readfn	*greymaskcall;	
@


<<function readalphafn>>=
static Readfn*
readalphafn(Memimage *m)
{
    USED(m);
    return readbyte;
}
@
% will maybe replicate bytes in buffer!
% the setting of alphaonly will adjust the behavior of readbyte


<<function greymaskread>>=
/*
 * Alpha reading function that simply relabels the grey pointer.
 */
static Buffer
greymaskread(Param *p, uchar *buf, int y)
{
    Buffer b;

    b = p->greymaskcall(p, buf, y);
    b.alpha = b.grey;
    return b;
}
@

% See {Reading replicated pixels} section in adv topics.

%\subsection{Duplicating pixels}


\subsection{Compositing pixels, [[alphacalcxx()]]}

% I put in appendix or adv topics everything except SoverD alphacalc11?

<<global alphacalc>>=
static Calcfn *alphacalc[Ncomp] = 
{
    alphacalc0,         /* Clear */
    alphacalc14,        /* DoutS */
    alphacalc2810,      /* SoutD */
    alphacalc3679,      /* DxorS */
    alphacalc14,        /* DinS */
    alphacalc5,         /* D */
    alphacalc3679,      /* DatopS */
    alphacalc3679,      /* DoverS */
    alphacalc2810,      /* SinD */
    alphacalc3679,      /* SatopD */
    alphacalc2810,      /* S */
    alphacalc11,        /* SoverD */ // the classic
};
@
% numbers suffixes are here to indicate which porter-duff numbers they cover,
% e.g., alphacalc3679 covers operation 3, 6, 7, and 9.

<<function alphacalc11>>=
static Buffer
alphacalc11(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, bool grey, int op)
{
    int sa, ma;
    int fd;
    int sadelta;
    int i; // iterate over pixels of the line
    bool q;
    // temporaries for MUL
    ulong s, t, u, v;
    // ??
    Buffer obdst;

    USED(op);
    obdst = bdst;
    <<[[alphacalc11()]] alpha handling part1>>
    q = (bsrc.delta == 4) && (bdst.delta == 4);

    // pixel iteration of the line
    for(i=0; i<dx; i++){
        sa = *bsrc.alpha;
        ma = *bmask.alpha;
        fd = 255 - MUL(sa, ma, t);

        <<[[alphacalc11()]] if isgrey>>
        else{
            <<[[alphacalc11()]] special case for 32bits source and dest>>
            // else

            *bdst.red = MUL(ma, *bsrc.red, s) + MUL(fd, *bdst.red, t);
            *bdst.grn = MUL(ma, *bsrc.grn, s) + MUL(fd, *bdst.grn, t);
            *bdst.blu = MUL(ma, *bsrc.blu, s) + MUL(fd, *bdst.blu, t);

            bsrc.red += bsrc.delta;
            bsrc.blu += bsrc.delta;
            bsrc.grn += bsrc.delta;

            bdst.red += bdst.delta;
            bdst.blu += bdst.delta;
            bdst.grn += bdst.delta;
        }

        <<[[alphacalc11()]] alpha handling part2>>
    }
    return obdst;
}
@
% why return old bdst?

<<function MUL>>=
#define MUL(x, y, t)	(t = (x)*(y)+128, (t+(t>>8))>>8)
@
% >> >>
% ?????


%        fd = 255 - MUL(sa, ma, t);
% so if opaque mask and opaque sa, then fd should be 0
% in which case it does not participate in the final value 
% which is why we saw the memove opti before.


<<[[alphacalc11()]] alpha handling part1>>=
sadelta = (bsrc.alpha == &ones) ? 0 : bsrc.delta;
@

<<[[alphacalc11()]] alpha handling part2>>=
if(bdst.alpha != &ones){
    *bdst.alpha = MUL(ma, sa, s) + MUL(fd, *bdst.alpha, t);
    bdst.alpha += bdst.delta;
}
bmask.alpha += bmask.delta;
bsrc.alpha += sadelta;
@

\t no special handling for the alpha of a mask?? no madelta?









\chapter{Drawing Shapes}
\label{chap:drawing-shapes}

%trans:
% seen draw rectangle which is actually basic block to draw any shape!
% Indeed in the end any figure is made of a set of rectangle!
%FIGURE where big zoom and see circle made of all those rectangles.

% See classic CGPP book from Foley et al.

%http://members.chello.at/easyfilter/bresenham.html
% but actually not used, use more general algorithm to fill polygons.
%http://www.redblobgames.com/grids/line-drawing.html

%alt: X11 use a Graphic Context to set properties

%alt: Path construction and then stroke/kill, apparently comes from Postscript
% instead we have each time a xxx or xxxfill with path as parameter.
% stateless!

\section{Lines}

\subsection{API}

<<function line>>=
void
line(Image *dst, Point p0, Point p1, int end0, int end1, int radius, Image *src, Point sp)
{
    lineop(dst, p0, p1, end0, end1, radius, src, sp, SoverD);
}
@
% width will be 1+radius*2 (see draw(2)).

% src often simple again, just a Color, and sp is ZP,

% if src is complex picture, can do very fancy effect! like getting
% a slice of the face of someone drawn as a line!

<<enum Endline>>=
enum EndLine
{
    /* line ends */
    Endsquare	= 0, // default
    Enddisc		= 1,
    Endarrow	= 2,

    Endmask		= 0x1F
};
@
%less typedef int endline; or use enum?
% see advanced topics actually for code using that
% Endmask ??
\l actually use more Endmask instead of hardcoding those 0x1F everywhere below
\l why 0x1F ??? because of Arrow() macro?

%alt: path construction like in cairo separated from drawing function.

% No dashing parameter as in SRGP. Simple API.
% But actually can by playing with the mask! or src!

\subsection{Marshalling}

<<function lineop>>=
void
lineop(Image *dst, Point p0, Point p1, int end0, int end1, int radius, Image *src, Point sp, Drawop op)
{
    byte *a;

    _setdrawop(dst->display, op);

    // draw line: 'L' dstid[4] p0[2*4] p1[2*4] end0[4] end1[4] radius[4] srcid[4] sp[2*4]
    a = bufimage(dst->display, 1+4+2*4+2*4+4+4+4+4+2*4);
    <<[[lineop()]] sanity check a>>
    a[0] = 'L';
    BPLONG(a+1, dst->id);
    BPLONG(a+5, p0.x);
    BPLONG(a+9, p0.y);
    BPLONG(a+13, p1.x);
    BPLONG(a+17, p1.y);
    BPLONG(a+21, end0);
    BPLONG(a+25, end1);
    BPLONG(a+29, radius);
    BPLONG(a+33, src->id);
    BPLONG(a+37, sp.x);
    BPLONG(a+41, sp.y);
}
@

<<[[lineop()]] sanity check a>>=
if(a == nil){
    fprint(2, "image line: %r\n");
    return;
}
@
%ocaml: exn again

\subsection{Unmarshalling}

<<[[drawmesg()]] locals>>=
Point sp;
// enum<EndLine>
int e0, e1;
@

<<[[drawmesg()]] cases>>=
/* draw line: 'L' dstid[4] p0[2*4] p1[2*4] end0[4] end1[4] radius[4] srcid[4] sp[2*4] */
case 'L':
    printmesg(fmt="LPPlllLP", a, false);
    m = 1+4+2*4+2*4+4+4+4+4+2*4;
    <<[[drawmesg()]] sanity check n with m>>
    dst = drawimage(client, a+1);
    dstid = BGLONG(a+1);
    drawpoint(&p, a+5);
    drawpoint(&q, a+13);
    e0 = BGLONG(a+21);
    e1 = BGLONG(a+25);
    j = BGLONG(a+29);
    <<[[drawmesg()]] when draw line, sanity check j>>
    src = drawimage(client, a+33);
    drawpoint(&sp, a+37);
    op = drawclientop(client);

    memline(dst, p, q, e0, e1, j, src, sp, op); // The call
    <<[[drawmesg()]] when draw line, possible flush>>
    continue;
@


<<[[drawmesg()]] when draw line, sanity check j>>=
if(j < 0)
    error("negative line width");
@

\subsection{Algorithm}

% memlayer/
<<function memline>>=
void
memline(Memimage *dst, Point p0, Point p1, int end0, int end1, int radius, Memimage *src, Point sp, int op)
{
    _memline(dst, p0, p1, end0, end1, radius, src, sp, dst->clipr, op);
}
@
% only diff is passing dst->clipr. What for? can not just do that in
%  _memline or _memimageline itself? other callers to _memline?
% same thing for memimageline vs _memimageline except they have
%  changed all the callers already and so memimageline is now useless.

<<function _memline>>=
static
void
_memline(Memimage *dst, Point p0, Point p1, int end0, int end1, int radius, Memimage *src, Point sp, Rectangle clipr, int op)
{
    Memlayer *dl;
    <<[[_memline()]] other locals>>

    <<[[_memline()]] sanity check radius>>
    <<[[_memline()]] sanity check no src layer>>

    Top:
    dl = dst->layer;
    if(dl == nil){
        // back to memdraw/
        _memimageline(dst, p0, p1, end0, end1, radius, src, sp, clipr, op);
        return;
    }
    <<[[_memline()]] when have layers>>
}
@
% what if src has a layer? it will work?


<<[[_memline()]] sanity check radius>>=
if(radius < 0)
    return;
@
% but already checked in drawmesg normally
% note that it can be zero.





% back to memdraw/
<<function _memimageline>>=
void
_memimageline(Memimage *dst, Point p0, Point p1, int end0, int end1, int radius, Memimage *src, Point sp, Rectangle clipr, int op)
{

    bool hor;
    <<[[_memimageline()]] other locals>>

    <<[[_memline()]] sanity check radius>>
    <<[[_memimageline()]] clipping clipr>>

    /* this means that only verline() handles degenerate lines (p0==p1) */
    hor = (abs(p1.x - p0.x) > abs(p1.y - p0.y));

    /*
     * Clipping is a little peculiar.  We can't use Sutherland-Cohen
     * clipping because lines are wide.  But this is probably just fine:
     * we do all math with the original p0 and p1, but clip when deciding
     * what pixels to draw.  This means the layer code can call this routine,
     * using clipr to define the region being written, and get the same set
     * of pixels regardless of the dicing.
     */
     // ????

    <<[[_memimageline()]] swap p0 and p1 to have p0 before p1>>

    // easy case
    <<[[_memimageline()]] when vertical or horizontal lines>>
    // else
    /*    Hard: */
    <<[[_memimageline()]] when arbitrary lines>>
}
@
\l why _ ? because interface was simpler in memimageline? no clipr param?

% Explain previous comment about clipping?

<<[[_memimageline()]] clipping clipr>>=
// clip to dst
if(!rectclip(&clipr, dst->r))
    return;
if(!rectclip(&clipr, dst->clipr))
    return;

// clip to src
d = subpt(sp, p0);
if(!rectclip(&clipr, rectsubpt(src->clipr, d)))
    return;
if(!(src->flags&Frepl) && !rectclip(&clipr, rectsubpt(src->r, d)))
    return;
@
%old: d = subpt(sp, p0); was there but before I think

% remember that sp will match p0, but sp could be 10,10 and
% p0 5,5 so have to adjust src->clipr
% FIGURE?

% call _memline with dst-clipr so first part should be a NOP.
% Why do those manip? anyway we will call memdraw which will do that for us no?
% to save time? 

<<[[_memimageline()]] swap p0 and p1 to have p0 before p1>>=
if((hor && p0.x > p1.x) || (!hor && p0.y > p1.y)){
    // swap(p0, p1)
    q = p0;
    p0 = p1;
    p1 = q;
    // swap(end0, end1)
    t = end0;
    end0 = end1;
    end1 = t;
}
@
% important as we will see. In what case we will draw
%  horizontal lines which will be part of the final line,
%  in the other vertical lines.

\subsubsection{Simple case: vertical or horizontal lines}

%dead: was in comment, but they actually do that so was old comment probably
%    /*
%     * BUG: We should really really pick off purely horizontal and purely
%     * vertical lines and handle them separately with calls to memimagedraw
%     * on rectangles.
%     */

% remember than p0 is "before" p1

<<[[_memimageline()]] when vertical or horizontal lines>>=
if((p0.x == p1.x || p0.y == p1.y) 
&& (end0&0x1F) == Endsquare 
&& (end1&0x1F) == Endsquare){
    r.min = p0;
    r.max = p1;
    // vertical line
    if(p0.x == p1.x){
        r.min.x -= radius;
        r.max.x += radius+1;
    }
    // horizontal line
    else{
        r.min.y -= radius;
        r.max.y += radius+1;
    }
    <<[[_memimageline()]] change dst clipr>>
    sp = addpt(r.min, d);
    memimagedraw(dst, r, src, sp, memopaque, sp, op);
    <<[[_memimageline()]] restore dst clipr>>
    return;
}
@



<<[[_memimageline()]] other locals>>=
Rectangle oclipr;
@
<<[[_memimageline()]] change dst clipr>>=
oclipr = dst->clipr;
dst->clipr = clipr;
@
<<[[_memimageline()]] restore dst clipr>>=
dst->clipr = oclipr;
@
% not sure why does that, to optimize a bit more?
%  and because this clipping information we have to pass to memdraw
%  so there is no much choice, we have to put it in dst.
% but anyway, it is mostly dst-clipr from the start so no big win ...
%  I think all this clipping code could be removed.


\subsubsection{General case}

<<[[_memimageline()]] other locals>>=
int sin, cos, dx, dy, t;
Rectangle r;
Point q;
Point pts[10], *pp;
Point d;
@


% was in draw.h, but probably could be moved in drawimpl.h
<<constant ICOSSCALE>>=
ICOSSCALE	= 1024,
@
% float with integers!
% (Big) Integer Cosinus Scale?


<<[[_memimageline()]] when arbitrary lines>>=
/* draw thick line using polygon fill */
icossin2(p1.x - p0.x, p1.y - p0.y, &cos, &sin);
dx = (sin*(2*radius+1))/2;
dy = (cos*(2*radius+1))/2;
pp = pts;
<<[[_memimageline()]] change dst clipr>>

q.x = ICOSSCALE*p0.x + ICOSSCALE/2- cos/2;
q.y = ICOSSCALE*p0.y + ICOSSCALE/2- sin/2;
switch(end0 & 0x1F){
<<[[_memimageline()]] switch end0 cases>>
<<[[_memimageline()]] switch end0 cases, fallthrough to Endsquare>>
case Endsquare:
default:
    pp->x = q.x - dx;
    pp->y = q.y + dy;
    pp++;
    pp->x = q.x + dx;
    pp->y = q.y - dy;
    pp++;
    break;
}
// 2 points

q.x = ICOSSCALE*p1.x+ICOSSCALE/2+cos/2;
q.y = ICOSSCALE*p1.y+ICOSSCALE/2+sin/2;
switch(end1 & 0x1F){
<<[[_memimageline()]] switch end1 cases>>
<<[[_memimageline()]] switch end1 cases, fallthrough to Endsquare>>
case Endsquare:
default:
    pp->x = q.x + dx;
    pp->y = q.y - dy;
    pp++;
    pp->x = q.x - dx;
    pp->y = q.y + dy;
    pp++;
    break;
}
// 2 more points

_memfillpolysc(dst, pts, pp-pts, ~0, src, 
               addpt(pts[0], mulpt(d, ICOSSCALE)), 
               false, 10, true, op);
<<[[_memimageline()]] restore dst clipr>>
return;
@
%fixshift 10? = 2^10 = 1024

%~0 = w parameter to _memfillpolysc = winding rule for
% what to do when intersect resulting polygon
% can be 0, 1, ~0, ~1 (see draw(2))

% FIGURE where see the 4 points, I think it's the rectangle!

% no bresenham actually. Instead use more general algorithm that
% fills a polygone. More complex too, but more general.

\l could do bresenham when thickness of line is 1? for education purpose?
\l  a good stepping stone to the more complex algo in xscan?


\section{Polygons}
% put polygon in separate section?

% actually used as we have seen before for general case of (thick) line drawing.

\subsection{API}

% array of points!
<<function poly>>=
void
poly(Image *dst, Point *p, int np, int end0, int end1, int radius, Image *src, Point sp)
{
    dopoly('p', dst, p, np, end0, end1, radius, src, &sp, SoverD);
}
@

<<function polyop>>=
void
polyop(Image *dst, Point *p, int np, int end0, int end1, int radius, Image *src, Point sp, Drawop op)
{
    dopoly('p', dst, p, np, end0, end1, radius, src, &sp, op);
}
@

<<function fillpoly>>=
void
fillpoly(Image *dst, Point *p, int np, int wind, Image *src, Point sp)
{
    dopoly('P', dst, p, np, wind, 0, 0, src, &sp, SoverD);
}
@

<<function fillpolyop>>=
void
fillpolyop(Image *dst, Point *p, int np, int wind, Image *src, Point sp, Drawop op)
{
    dopoly('P', dst, p, np, wind, 0, 0, src, &sp, op);
}
@

% way to fill poly is simple. No complex pattern, etc. But again
% can play with src to do that! Instead of hardcoded set of style,
% just use very general API with flexible mask and src.


\subsection{Marshalling}

% why not _poly? more consistent
<<function dopoly>>=
static
void
dopoly(int cmd, Image *dst, Point *pp, int np, int end0, int end1, int radius, Image *src, Point *sp, Drawop op)
{
    byte *a, *t, *u;
    int i, ox, oy;

    <<[[dopoly()]] sanity check n>>
    t = malloc(np*2*3);
    <<[[dopoly()]] sanity check t>>
    u = t;
    ox = oy = 0;
    for(i=0; i<np; i++){
        u = addcoord(u, ox, pp[i].x);
        ox = pp[i].x;
        u = addcoord(u, oy, pp[i].y);
        oy = pp[i].y;
    }

    _setdrawop(dst->display, op);

    /// polygon: 'p' dstid[4] n[2] end0[4] end1[4] radius[4] srcid[4] sp[2*4] p0[2*4] dp[2*2*n]
    a = bufimage(dst->display, 1+4+2+4+4+4+4+2*4+(u-t));
    <<[[dopoly()]] sanity check a>>
    a[0] = cmd;
    BPLONG(a+1, dst->id);
    BPSHORT(a+5, np-1);
    BPLONG(a+7, end0);
    BPLONG(a+11, end1);
    BPLONG(a+15, radius);
    BPLONG(a+19, src->id);
    BPLONG(a+23, sp->x);
    BPLONG(a+27, sp->y);
    memmove(a+31, t, u-t);
    free(t);
}
@
\l enforce enough space to pass all points?


<<[[dopoly()]] sanity check n>>=
if(np == 0)
    return;
@
<<[[dopoly()]] sanity check t>>=
if(t == nil)
    return;
@
<<[[dopoly()]] sanity check a>>=
if(a == nil){
    free(t);
    fprint(2, "image poly: %r\n");
    return;
}
@

% dopoly -> <>
<<function addcoord>>=
static
uchar*
addcoord(byte *p, int oldx, int newx)
{
    int dx;

    dx = newx-oldx;
    /* does dx fit in 7 signed bits? */
    if((unsigned)(dx - -0x40) <= 0x7F)
        *p++ = dx&0x7F;
    else{
        *p++ = 0x80 | (newx&0x7F);
        *p++ = newx>>7;
        *p++ = newx>>15;
    }
    return p;
}
@

\subsection{Unmarshalling}

<<[[drawmesg()]] locals>>=
int ni;
Point *pp;
bool doflush;
int ox, oy;
int esize, oesize;
byte *u;
int y;
@

<<[[drawmesg()]] cases>>=
/* filled polygon: 'P' dstid[4] n[2] wind[4] ignore[2*4] srcid[4] sp[2*4] p0[2*4] dp[2*2*n] */
/* polygon: 'p' dstid[4] n[2] end0[4] end1[4] radius[4] srcid[4] sp[2*4] p0[2*4] dp[2*2*n] */
case 'p':
case 'P':
    printmesg(fmt="LslllLPP", a, false);
    m = 1+4+2+4+4+4+4+2*4;
    <<[[drawmesg()]] sanity check n with m>>
    dstid = BGLONG(a+1);
    dst = drawimage(client, a+1);
    ni = BGSHORT(a+5);
    <<[[drawmesg()]] when draw polygon, sanity check ni>>
    e0 = BGLONG(a+7);
    e1 = BGLONG(a+11);
    j = 0;
    if(*a == 'p'){
        j = BGLONG(a+15);
        <<[[drawmesg()]] when draw polygon, sanity check j>>
    }
    src = drawimage(client, a+19);
    drawpoint(&sp, a+23);
    drawpoint(&p, a+31);
    ni++;
    pp = malloc(ni*sizeof(Point));
    <<[[drawmesg()]] when draw polygon, sanity check pp>>

    <<[[drawmesg()]] when draw polygon, set doflush>>

    ox = oy = 0;
    esize = 0;
    u = a+m;
    for(y=0; y<ni; y++){
        q = p;
        oesize = esize;
        u = drawcoord(u, a+n, ox, &p.x);
        u = drawcoord(u, a+n, oy, &p.y);
        ox = p.x;
        oy = p.y;

        <<[[drawmesg()]] when draw polygon, if doflush>>
        pp[y] = p;
    }
    <<[[drawmesg()]] when draw polygon, special flush if y is 1>>
    op = drawclientop(client);

    if(*a == 'p')
        mempoly(dst, pp, ni, e0, e1, j, src, sp, op); // The call
    else
        memfillpoly(dst, pp, ni, e0, src, sp, op); // The call

    free(pp);
    m = u-a;
    continue;

@

<<[[drawmesg()]] when draw polygon, sanity check ni>>=
if(ni < 0)
    error("negative count in polygon");
@

<<[[drawmesg()]] when draw polygon, sanity check j>>=
if(j < 0)
    error("negative polygon line width");
@
<<[[drawmesg()]] when draw polygon, sanity check pp>>=
if(pp == nil)
    error(Enomem);
@


<<function drawcoord>>=
uchar*
drawcoord(uchar *p, uchar *maxp, int oldx, int *newx)
{
    int b, x;

    if(p >= maxp)
        error(Eshortdraw);
    b = *p++;
    x = b & 0x7F;
    if(b & 0x80){
        if(p+1 >= maxp)
            error(Eshortdraw);
        x |= *p++ << 7;
        x |= *p++ << 15;
        if(x & (1<<22))
            x |= ~0<<23;
    }else{
        if(b & 0x40)
            x |= ~0<<7;
        x += oldx;
    }
    *newx = x;
    return p;
}
@
% >> >> >> >> >> >>


\subsection{Algorithm}

%helps?
%https://www.cs.uic.edu/~jbell/CourseNotes/ComputerGraphics/PolygonFilling.html


<<function mempoly>>=
void
mempoly(Memimage *dst, Point *vert, int nvert, int end0, int end1, int radius, Memimage *src, Point sp, int op)
{
    int i;
    //enum<EndLine>>
    int e0, e1;
    Point d;

    <<[[mempoly() sanity check nvert>>
    d = subpt(sp, vert[0]); // to compensate for addpt below
    for(i=1; i<nvert; i++){
        <<[[mempoly()]] set endlines e0 and e1>>
        memline(dst, vert[i-1], vert[i], e0, e1, radius, src, addpt(d, vert[i-1]), op);
    }
}
@
% actually call memline! :) (and not _memimageline, so handle layers and so on)
%  which will call back fillpoly.

% vert for vertexes (points)

<<[[mempoly()]] set endlines e0 and e1>>=
e0 = e1 = Enddisc; // for smooth junctions
if(i == 1)
    e0 = end0;
if(i == nvert-1)
    e1 = end1;
@

<<[[mempoly() sanity check nvert>>=
if(nvert < 2)
    return;
@

<<function memfillpoly>>=
void
memfillpoly(Memimage *dst, Point *vert, int nvert, int w, Memimage *src, Point sp, int op)
{
    _memfillpolysc(dst, vert, nvert, w, src, sp, false, 0, false, op);
}
@
% another story! cant call memline because will be infinite recursion

\subsubsection{[[Seg]]}

<<struct Seg>>=
struct Seg
{
    Point	p0;
    Point	p1;

    long	d; // direction? 1 or -1?

    <<[[Seg]] other fields>>
};
@

% note that can be any points, we will have to sort them and
% to know on which size of the line to fill.

\subsubsection{[[_memfillpolysc()]]}

<<function _memfillpolysc>>=
void
_memfillpolysc(Memimage *dst, Point *vert, int nvert, int w, Memimage *src, Point sp, bool detail, int fixshift, bool clipped, int op)
{
    // array<Seg> (length = nvert+1)
    Seg *segtab;
    // array<Seg*> (length = nvert+2)
    Seg **seg;
    Point p0;
    int i;

    <<[[_memfillpolysc()]] sanity check nvert>>

    segtab = malloc((nvert+1)*sizeof(Seg));
    <<[[_memfillpolysc()]] sanity check segtab>>
    seg = malloc((nvert+2)*sizeof(Seg*));
    <<[[_memfillpolysc()]] sanity check seg>>

    sp.x = (sp.x - vert[0].x) >> fixshift;
    sp.y = (sp.y - vert[0].y) >> fixshift;

    p0 = vert[nvert-1]; // start from the end
    <<[[_memfillpolysc()]] adjust p0 if no fixshift>>
    for(i = 0; i < nvert; i++) {
        segtab[i].p0 = p0;
        p0 = vert[i];
        <<[[_memfillpolysc()]] adjust p0 if no fixshift>>
        segtab[i].p1 = p0;
        segtab[i].d = 1;
    }
    <<[[_memfillpolysc()]] adjust fixshift if no fixshift>>

    xscan(dst, seg, segtab, nvert, w, src, sp, detail, fixshift, clipped, op);
    <<[[_memfillpolysc()]] if detail>>

    free(seg);
    free(segtab);
}
@
% >> >> >> >>
\l remove clipped parameter, unused anyway since the code was commented
\l  later

% it closes the polygone if it was not?

<<[[_memfillpolysc()]] sanity check nvert>>=
if(nvert == 0)
    return;
@
<<[[_memfillpolysc()]] sanity check seg>>=
if(seg == nil)
    return;
@
<<[[_memfillpolysc()]] sanity check segtab>>=
if(segtab == nil) {
    free(seg);
    return;
}
@


\subsubsection{Fix shift arithmetics}

% seen passing 10 before, and ICOSSCALE = 1024.

% if not fixshift, at least improve a bit precision by shifting by 1.
<<[[_memfillpolysc()]] adjust p0 if no fixshift>>=
if(!fixshift) {
    p0.x <<= 1;
    p0.y <<= 1;
}
@
% >> >>

<<[[_memfillpolysc()]] adjust fixshift if no fixshift>>=
if(!fixshift)
    fixshift = 1;
@


\subsubsection{[[xscan()]]}

<<[[Seg]] other fields>>=
long	num;
long	den;
long	dz;
long	dzrem;
@

<<[[Seg]] other fields>>=
long	z;
long	zerr;
@

% this is a very complex algorithm ... made more complex
% with the fixshift, with sp, with wind, etc.
% Rely on CGPP? too long to explain otherwise?

<<function xscan>>=
static void
xscan(Memimage *dst, Seg **seg, Seg *segtab, int nseg, int wind, Memimage *src, Point sp, bool detail, int fixshift, bool clipped, int op)
{
    Seg **ep, **next, **p, **q, *s;
    long y, maxy, x, x2, xerr, xden, onehalf;
    long n, i, iy, cnt, ix, ix2, minx, maxx;
    Point pt;
    void	(*fill)(Memimage*, int, int, int, Memimage*, Point, int);

    fill = fillline;
    USED(clipped);

    for(i=0, s=segtab, p=seg; i<nseg; i++, s++) {
        *p = s;
        if(s->p0.y == s->p1.y)
            continue;
        if(s->p0.y > s->p1.y) {
            // swap(s->p0, s->p1)
            pt = s->p0;
            s->p0 = s->p1;
            s->p1 = pt;

            s->d = -s->d;
        }
        s->num = s->p1.x - s->p0.x;
        s->den = s->p1.y - s->p0.y;

        s->dz = sdiv(s->num, s->den) << fixshift;
        s->dzrem = mod(s->num, s->den) << fixshift;
        s->dz += sdiv(s->dzrem, s->den);
        s->dzrem = mod(s->dzrem, s->den);
        p++;
    }
    n = p-seg;
    if(n == 0)
        return;
    *p = nil;
    qsort(seg, n , sizeof(Seg*), ycompare);

    onehalf = 0;
    if(fixshift)
        onehalf = 1 << (fixshift-1);

    minx = dst->clipr.min.x;
    maxx = dst->clipr.max.x;

    y = seg[0]->p0.y;
    if(y < (dst->clipr.min.y << fixshift))
        y = dst->clipr.min.y << fixshift;
    iy = (y + onehalf) >> fixshift;
    y = (iy << fixshift) + onehalf;
    maxy = dst->clipr.max.y << fixshift;

    ep = next = seg;

    while(y<maxy) {
        for(q = p = seg; p < ep; p++) {
            s = *p;
            if(s->p1.y < y)
                continue;
            s->z += s->dz;
            s->zerr += s->dzrem;
            if(s->zerr >= s->den) {
                s->z++;
                s->zerr -= s->den;
                if(s->zerr < 0 || s->zerr >= s->den)
                    print("bad ratzerr1: %ld den %ld dzrem %ld\n", s->zerr, s->den, s->dzrem);
            }
            *q++ = s;
        }

        for(p = next; *p; p++) {
            s = *p;
            if(s->p0.y >= y)
                break;
            if(s->p1.y < y)
                continue;
            s->z = s->p0.x;
            s->z += smuldivmod(y - s->p0.y, s->num, s->den, &s->zerr);
            if(s->zerr < 0 || s->zerr >= s->den)
                print("bad ratzerr2: %ld den %ld ratdzrem %ld\n", s->zerr, s->den, s->dzrem);
            *q++ = s;
        }
        ep = q;
        next = p;

        if(ep == seg) {
            if(*next == 0)
                break;
            iy = (next[0]->p0.y + onehalf) >> fixshift;
            y = (iy << fixshift) + onehalf;
            continue;
        }

        zsort(seg, ep);

        for(p = seg; p < ep; p++) {
            cnt = 0;

            x = p[0]->z;
            xerr = p[0]->zerr;
            xden = p[0]->den;

            ix = (x + onehalf) >> fixshift;
            if(ix >= maxx)
                break;
            if(ix < minx)
                ix = minx;

            cnt += p[0]->d;
            p++;
            for(;;) {
                if(p == ep) {
                    print("xscan: fill to infinity");
                    return;
                }
                cnt += p[0]->d;
                if((cnt & wind) == 0)
                    break;
                p++;
            }

            x2 = p[0]->z;
            ix2 = (x2 + onehalf) >> fixshift;
            if(ix2 <= minx)
                continue;
            if(ix2 > maxx)
                ix2 = maxx;

            <<[[xscan()]] if detail>>

            // the call
            (*fill)(dst, ix, ix2, iy, src, sp, op);
        }
        y += (1<<fixshift);
        iy++;
    }
}
@
% >> >> >> >> >>
% wow, so complicated
\t remove clipped parameter, unused anyway
%old: can use n in code below, clearer
%    qsort(seg, p-seg , sizeof(Seg*), ycompare);
%old: was commented already in the orginal code
%  /*
%   * This can only work on 8-bit destinations, since fillcolor is
%   * just using memset on sp.x.
%   *
%   * I'd rather not even enable it then, since then if the general
%   * code is too slow, someone will come up with a better improvement
%   * than this sleazy hack.	-rsc
%   *
%      if(clipped 
%      && (src->flags&Frepl) 
%      && src->depth==8 
%      && Dx(src->r)==1 
%      && Dy(src->r)==1) {
%          fill = fillcolor;
%          sp.x = membyteval(src);
%      }
%   *
%   */

\subsubsection{[[fillxxx()]]}

<<function fillline>>=
static void
fillline(Memimage *dst, int xleft, int xright, int y, Memimage *src, Point p, int op)
{
    Rectangle r;

    r.min.x = xleft;
    r.min.y = y;
    r.max.x = xright;
    r.max.y = y+1;

    p.x += xleft;
    p.y += y;

    memdraw(dst, r, src, p, memopaque, p, op);
}
@


%dead: used only in code that is now commented
% <<function fillcolor>>=
% static void
% fillcolor(Memimage *dst, int left, int right, int y, Memimage *src, Point p)
% {
%     int srcval;
% 
%     USED(src);
%     srcval = p.x;
%     p.x = left;
%     p.y = y;
%     memset(byteaddr(dst, p), srcval, right-left);
% }
% @




\subsubsection{Arithmetics}

<<function mod>>=
static long
mod(long x, long y)
{
    long z;

    z = x%y;
    if((long)(((ulong)z)^((ulong)y)) > 0 || z == 0)
        return z;
    return z + y;
}
@

<<function sdiv>>=
static long
sdiv(long x, long y)
{
    if((long)(((ulong)x)^((ulong)y)) >= 0 || x == 0)
        return x/y;

    return (x+((y>>30)|1))/y-1;
}
@

<<function smuldivmod>>=
static long
smuldivmod(long x, long y, long z, long *mod)
{
    vlong vx;

    if(x == 0 || y == 0){
        *mod = 0;
        return 0;
    }
    vx = x;
    vx *= y;
    *mod = vx % z;
    if(*mod < 0)
        *mod += z;	/* z is always >0 */
    if((vx < 0) == (z < 0))
        return vx/z;
    return -((-vx)/z);
}
@

\subsubsection{Sorting}


<<function zsort>>=
static void
zsort(Seg **seg, Seg **ep)
{
    int done;
    Seg **q, **p, *s;

    if(ep-seg < 20) {
        /* bubble sort by z - they should be almost sorted already */
        q = ep;
        do {
            done = 1;
            q--;
            for(p = seg; p < q; p++) {
                if(p[0]->z > p[1]->z) {
                    s = p[0];
                    p[0] = p[1];
                    p[1] = s;
                    done = 0;
                }
            }
        } while(!done);
    } else {
        q = ep-1;
        for(p = seg; p < q; p++) {
            if(p[0]->z > p[1]->z) {
                qsort(seg, ep-seg, sizeof(Seg*), zcompare);
                break;
            }
        }
    }
}
@

<<function ycompare>>=
static int
ycompare(void *a, void *b)
{
    Seg **s0 = a, **s1 = b;
    long y0, y1;

    y0 = (*s0)->p0.y;
    y1 = (*s1)->p0.y;

    if(y0 < y1)
        return -1;
    if(y0 == y1)
        return 0;
    return 1;
}
@


<<function zcompare>>=
static int
zcompare(void *a, void *b)
{
    Seg **s0 = a, **s1 = b;
    long z0, z1;

    z0 = (*s0)->z;
    z1 = (*s1)->z;

    if(z0 < z1)
        return -1;
    if(z0 == z1)
        return 0;
    return 1;
}
@




\section{Ellipses}

% libmemdraw/ellipse.c
%/*
% * ellipse(dst, c, a, b, t, src, sp)
% *   draws an ellipse centered at c with semiaxes a,b>=0
% *   and semithickness t>=0, or filled if t<0.  point sp
% *   in src maps to c in dst
% *
% *   very thick skinny ellipses are brushed with circles (slow)
% *   others are approximated by filling between 2 ellipses
% *   criterion for very thick when b<a: t/b > 0.5*x/(1-x)
% *   where x = b/a
% */

\subsection{API}

<<function ellipse>>=
void
ellipse(Image *dst, Point c, int a, int b, int thick, Image *src, Point sp)
{
    doellipse('e', dst, &c, a, b, thick, src, &sp, 0, 0, SoverD);
}
@
% used also for arc, hence the 0 0 for alpha and phi.
% here thick must be >=0. The comment above is for memdraw,
% not for the API.

<<function ellipseop>>=
void
ellipseop(Image *dst, Point c, int a, int b, int thick, Image *src, Point sp, Drawop op)
{
    doellipse('e', dst, &c, a, b, thick, src, &sp, 0, 0, op);
}
@

<<function fillellipse>>=
void
fillellipse(Image *dst, Point c, int a, int b, Image *src, Point sp)
{
    doellipse('E', dst, &c, a, b, 0, src, &sp, 0, 0, SoverD);
}
@

<<function fillellipseop>>=
void
fillellipseop(Image *dst, Point c, int a, int b, Image *src, Point sp, Drawop op)
{
    doellipse('E', dst, &c, a, b, 0, src, &sp, 0, 0, op);
}
@


\subsection{Marshalling}

% rename _ellipse?
<<function doellipse>>=
static
void
doellipse(int cmd, Image *dst, Point *c, int xr, int yr, int thick, Image *src, Point *sp, int alpha, int phi, Drawop op)
{
    byte *a;

    _setdrawop(dst->display, op);

    // ellipse: 'e' dstid[4] srcid[4] center[2*4] a[4] b[4] thick[4] sp[2*4] alpha[4] phi[4]
    a = bufimage(dst->display, 1+4+4+2*4+4+4+4+2*4+2*4);
    <<[[doellipse()]] sanity check a>>
    a[0] = cmd;
    BPLONG(a+1, dst->id);
    BPLONG(a+5, src->id);
    BPLONG(a+9, c->x);
    BPLONG(a+13, c->y);
    BPLONG(a+17, xr);
    BPLONG(a+21, yr);
    BPLONG(a+25, thick);
    BPLONG(a+29, sp->x);
    BPLONG(a+33, sp->y);
    BPLONG(a+37, alpha);
    BPLONG(a+41, phi);
}
@

<<[[doellipse()]] sanity check a>>=
if(a == nil){
    fprint(2, "image ellipse: %r\n");
    return;
}
@

\subsection{Unmarshalling}


<<[[drawmesg()]] cases>>=
/* ellipse: 'e' dstid[4] srcid[4] center[2*4] a[4] b[4] thick[4] sp[2*4] alpha[4] phi[4]*/
case 'e':
case 'E':
    printmesg(fmt="LLPlllPll", a, false);
    m = 1+4+4+2*4+4+4+4+2*4+2*4;
    <<[[drawmesg()]] sanity check n with m>>
    dst = drawimage(client, a+1);
    dstid = BGLONG(a+1);
    src = drawimage(client, a+5);
    drawpoint(&p, a+9);
    e0 = BGLONG(a+17);
    e1 = BGLONG(a+21);
    <<[[drawmesg()]] when draw ellipse, sanity check widths>>
    j = BGLONG(a+25);
    <<[[drawmesg()]] when draw ellipse, sanity check j>>
    drawpoint(&sp, a+29);
    c = j;
    if(*a == 'E')
        c = -1;
    ox = BGLONG(a+37);
    oy = BGLONG(a+41);
    op = drawclientop(client);
 
   <<[[drawmesg()]] when draw ellipse, if ox>>
    else
        memellipse(dst, p, e0, e1, c, src, sp, op); // The call

   <<[[drawmesg()]] when draw ellipse, dstflush>>

    continue;
@
% >> >> >>


<<[[drawmesg()]] when draw ellipse, sanity check widths>>=
if(e0<0 || e1<0)
    error("invalid ellipse semidiameter");
@

<<[[drawmesg()]] when draw ellipse, sanity check j>>=
if(j < 0)
    error("negative ellipse thickness");
@

\subsection{Algorithm}

%/*
% * ellipse(dst, c, a, b, t, src, sp)
% *   draws an ellipse centered at c with semiaxes a,b>=0
% *   and semithickness t>=0, or filled if t<0.  point sp
% *   in src maps to c in dst
% *
% *   very thick skinny ellipses are brushed with circles (slow)
% *   others are approximated by filling between 2 ellipses
% *   criterion for very thick when b<a: t/b > 0.5*x/(1-x)
% *   where x = b/a
% */

<<struct ParamEllipse>>=
struct ParamEllipse {
    Memimage	*dst;
    Memimage	*src;
    Point			c;
    int			t;
    Point			sp;
    Memimage	*disc;
    int			op;
};
@

<<struct State>>=
/*
 * denote residual error by e(x,y) = b^2*x^2 + a^2*y^2 - a^2*b^2
 * e(x,y) = 0 on ellipse, e(x,y) < 0 inside, e(x,y) > 0 outside
 */
struct State {
    int	a;
    int	x;
    vlong	a2;	/* a^2 */
    vlong	b2;	/* b^2 */
    vlong	b2x;	/* b^2 * x */
    vlong	a2y;	/* a^2 * y */
    vlong	c1;
    vlong	c2;	/* test criteria */
    vlong	ee;	/* ee = e(x+1/2,y-1/2) - (a^2+b^2)/4 */
    vlong	dxe;
    vlong	dye;
    vlong	d2xe;
    vlong	d2ye;
};
@

<<function newstate>>=
static
State*
newstate(State *s, int a, int b)
{
    s->x = 0;
    s->a = a;
    s->a2 = (vlong)(a*a);
    s->b2 = (vlong)(b*b);
    s->b2x = (vlong)0;
    s->a2y = s->a2*(vlong)b;
    s->c1 = -((s->a2>>2) + (vlong)(a&1) + s->b2);
    s->c2 = -((s->b2>>2) + (vlong)(b&1));
    s->ee = -s->a2y;
    s->dxe = (vlong)0;
    s->dye = s->ee<<1;
    s->d2xe = s->b2<<1;
    s->d2ye = s->a2<<1;
    return s;
}
@
% >> >> >> 


<<function memellipse>>=
void
memellipse(Memimage *dst, Point c, int a, int b, int t, Memimage *src, Point sp, int op)
{
    State in, out;
    int y, inb, inx, outx, u;
    Param p;

    if(a < 0)
        a = -a;
    if(b < 0)
        b = -b;
    p.dst = dst;
    p.src = src;
    p.c = c;
    p.t = t;
    p.sp = subpt(sp, c);
    p.disc = nil;
    p.op = op;

    u = (t<<1)*(a-b);
    if(b<a && u>b*b || a<b && -u>a*a) {
/*	if(b<a&&(t<<1)>b*b/a || a<b&&(t<<1)>a*a/b)	# very thick */
        bellipse(b, newstate(&in, a, b), &p);
        return;
    }

    if(t < 0) {
        inb = -1;
        newstate(&out, a, y = b);
    } else {	
        inb = b - t;
        newstate(&out, a+t, y = b+t);
    }
    if(t > 0)
        newstate(&in, a-t, inb);
    inx = 0;
    for( ; y>=0; y--) {
        outx = step(&out);
        if(y > inb) {
            erect(-outx, y, outx, y, &p);
            if(y != 0)
                erect(-outx, -y, outx, -y, &p);
            continue;
        }
        if(t > 0) {
            inx = step(&in);
            if(y == inb)
                inx = 0;
        } else if(inx > outx)
            inx = outx;
        erect(inx, y, outx, y, &p);
        if(y != 0)
            erect(inx, -y, outx, -y, &p);
        erect(-outx, y, -inx, y, &p);
        if(y != 0)
            erect(-outx, -y, -inx, -y, &p);
        inx = outx + 1;
    }
}
@
% >> >> >>

<<global p00 (lib_graphics/libmemdraw/ellipse.c)>>=
static Point p00 = {0, 0};
@

<<function bellipse>>=
/*
 * a brushed ellipse
 */
static
void
bellipse(int y, State *s, Param *p)
{
    int t, ox, oy, x, nx;

    t = p->t;
    p->disc = allocmemimage(Rect(-t,-t,t+1,t+1), GREY1);
    if(p->disc == nil)
        return;
    memfillcolor(p->disc, DTransparent);
    memellipse(p->disc, p00, t, t, -1, memopaque, p00, p->op);
    oy = y;
    ox = 0;
    nx = x = step(s);
    do {
        while(nx==x && y-->0)
            nx = step(s);
        y++;
        eline(-x,-oy,-ox, -y, p);
        eline(ox,-oy,  x, -y, p);
        eline(-x,  y,-ox, oy, p);
        eline(ox,  y,  x, oy, p);
        ox = x+1;
        x = nx;
        y--;
        oy = y;
    } while(oy > 0);
}
@

<<function erect>>=
/*
 * a rectangle with closed (not half-open) coordinates expressed
 * relative to the center of the ellipse
 */
static
void
erect(int x0, int y0, int x1, int y1, Param *p)
{
    Rectangle r;

/*	print("R %d,%d %d,%d\n", x0, y0, x1, y1); /**/
    r = Rect(p->c.x+x0, p->c.y+y0, p->c.x+x1+1, p->c.y+y1+1);
    memdraw(p->dst, r, p->src, addpt(p->sp, r.min), memopaque, p00, p->op);
}
@


<<function step>>=
/*
 * return x coord of rightmost pixel on next scan line
 */
static
int
step(State *s)
{
    while(s->x < s->a) {
        if(s->ee+s->b2x <= s->c1 ||	/* e(x+1,y-1/2) <= 0 */
           s->ee+s->a2y <= s->c2) {	/* e(x+1/2,y) <= 0 (rare) */
            s->dxe += s->d2xe;	  
            s->ee += s->dxe;	  
            s->b2x += s->b2;
            s->x++;	  
            continue;
        }
        s->dye += s->d2ye;	  
        s->ee += s->dye;	  
        s->a2y -= s->a2;
        if(s->ee-s->a2y <= s->c2) {	/* e(x+1/2,y-1) <= 0 */
            s->dxe += s->d2xe;	  
            s->ee += s->dxe;	  
            s->b2x += s->b2;
            return s->x++;
        }
        break;
    }
    return s->x;	  
}
@



<<function epoint>>=
/*
 * a brushed point similarly specified
 */
static
void
epoint(int x, int y, Param *p)
{
    Point p0;
    Rectangle r;

/*	print("P%d %d,%d\n", p->t, x, y);	/**/
    p0 = Pt(p->c.x+x, p->c.y+y);
    r = Rpt(addpt(p0, p->disc->r.min), addpt(p0, p->disc->r.max));
    memdraw(p->dst, r, p->src, addpt(p->sp, r.min), p->disc, p->disc->r.min, p->op);
}
@

<<function eline>>=
/* 
 * a brushed horizontal or vertical line similarly specified
 */
static
void
eline(int x0, int y0, int x1, int y1, Param *p)
{
/*	print("L%d %d,%d %d,%d\n", p->t, x0, y0, x1, y1); /**/
    if(x1 > x0+1)
        erect(x0+1, y0-p->t, x1-1, y1+p->t, p);
    else if(y1 > y0+1)
        erect(x0-p->t, y0+1, x1+p->t, y1-1, p);
    epoint(x0, y0, p);
    if(x1-x0 || y1-y0)
        epoint(x1, y1, p);
}
@



\section{Arcs}

\subsection{API}

<<function arc>>=
void
arc(Image *dst, Point c, int a, int b, int thick, Image *src, Point sp, int alpha, int phi)
{
    alpha |= 1<<31;
    doellipse('e', dst, &c, a, b, thick, src, &sp, alpha, phi, SoverD);
}
@
% >>
% special bit, used because want to allow also alpha at 0.

<<function arcop>>=
void
arcop(Image *dst, Point c, int a, int b, int thick, Image *src, Point sp, int alpha, int phi, Drawop op)
{
    alpha |= 1<<31;
    doellipse('e', dst, &c, a, b, thick, src, &sp, alpha, phi, op);
}
@
% >>

<<function fillarc>>=
void
fillarc(Image *dst, Point c, int a, int b, Image *src, Point sp, int alpha, int phi)
{
    alpha |= 1<<31;
    doellipse('E', dst, &c, a, b, 0, src, &sp, alpha, phi, SoverD);
}
@
% >>

<<function fillarcop>>=
void
fillarcop(Image *dst, Point c, int a, int b, Image *src, Point sp, int alpha, int phi, Drawop op)
{
    alpha |= 1<<31;
    doellipse('E', dst, &c, a, b, 0, src, &sp, alpha, phi, op);
}
@
% >>

\subsection{Unmarshalling}

<<[[drawmesg()]] when draw ellipse, if ox>>=
/* high bit indicates arc angles are present */

if(ox & (1<<31)){
    if((ox & (1<<30)) == 0)
        ox &= ~(1<<31);
    memarc(dst, p, e0, e1, c, src, sp, ox, oy, op); // The call
}
@
% >> >> >> >>

\subsection{Algorithm}

<<enum _anon_ (lib_graphics/libmemdraw/arc.c)>>=
/*
 * elarc(dst,c,a,b,t,src,sp,alpha,phi)
 *   draws the part of an ellipse between rays at angles alpha and alpha+phi
 *   measured counterclockwise from the positive x axis. other
 *   arguments are as for ellipse(dst,c,a,b,t,src,sp)
 */
enum
{
    R, T, L, B	/* right, top, left, bottom */
};
@

<<global corners>>=
static
Point corners[] = {
    {1,1},
    {-1,1},
    {-1,-1},
    {1,-1}
};
@

<<global p00>>=
static
Point p00;
@



<<function memarc>>=
/*
 * make a "wedge" mask covering the desired angle and contained in
 * a surrounding square; draw a full ellipse; intersect that with the
 * wedge to make a mask through which to copy src to dst.
 */
void
memarc(Memimage *dst, Point c, int a, int b, int t, Memimage *src, Point sp, int alpha, int phi, int op)
{
    int i, w, beta, tmp, c1, c2, m, m1;
    Rectangle rect;
    Point p,	bnd[8];
    Memimage *wedge, *figure, *mask;

    if(a < 0)
        a = -a;
    if(b < 0)
        b = -b;
    w = t;
    if(w < 0)
        w = 0;
    alpha = -alpha;		/* compensate for upside-down coords */
    phi = -phi;
    beta = alpha + phi;
    if(phi < 0){
        tmp = alpha;
        alpha = beta;
        beta = tmp;
        phi = -phi;
    }
    if(phi >= 360){
        memellipse(dst, c, a, b, t, src, sp, op);
        return;
    }
    while(alpha < 0)
        alpha += 360;
    while(beta < 0)
        beta += 360;
    c1 = alpha/90 & 3;	/* number of nearest corner */
    c2 = beta/90 & 3;
        /*
         * icossin returns point at radius ICOSSCALE.
         * multiplying by m1 moves it outside the ellipse
        */
    rect = Rect(-a-w, -b-w, a+w+1, b+w+1);
    m = rect.max.x;	/* inradius of bounding square */
    if(m < rect.max.y)
        m = rect.max.y;
    m1 = (m+ICOSSCALE-1) >> 10;
    m = m1 << 10;		/* assure m1*cossin is inside */
    i = 0;
    bnd[i++] = Pt(0,0);
    icossin(alpha, &p.x, &p.y);
    bnd[i++] = mulpt(p, m1);
    for(;;) {
        bnd[i++] = mulpt(corners[c1], m);
        if(c1==c2 && phi<180)
            break;
        c1 = (c1+1) & 3;
        phi -= 90;
    }
    icossin(beta, &p.x, &p.y);
    bnd[i++] = mulpt(p, m1);

    figure = nil;
    mask = nil;
    wedge = allocmemimage(rect, GREY1);
    if(wedge == nil)
        goto Return;
    memfillcolor(wedge, DTransparent);
    memfillpoly(wedge, bnd, i, ~0, memopaque, p00, S);
    figure = allocmemimage(rect, GREY1);
    if(figure == nil)
        goto Return;
    memfillcolor(figure, DTransparent);
    memellipse(figure, p00, a, b, t, memopaque, p00, S);
    mask = allocmemimage(rect, GREY1);
    if(mask == nil)
        goto Return;
    memfillcolor(mask, DTransparent);
    memimagedraw(mask, rect, figure, rect.min, wedge, rect.min, S);
    c = subpt(c, dst->r.min);
    memdraw(dst, dst->r, src, subpt(sp, c), mask, subpt(p00, c), op);

    Return:
    freememimage(wedge);
    freememimage(figure);
    freememimage(mask);
}
@
% >> >> >>

%\section{Bezier} see advanced topics

%\section{Text} see font section








\chapter{Fonts}
\label{chap:fonts}

\l how to draw text in diagonal? can? cairo can.

% fonts are a special kind of pictures 
% (bezier? or raster? raster here but could be bezier)

% Show simple test code showing use of font.
% Maybe just 2 calls to 2 different openfont() and 2 calls to string().
% Also start from last string thanks to the point returned by string.
% Also can call freefont().

% font(6), image(6),
% subfont(2), cachechars(2), 

% related:
%  - toy text API in Cairo 
%    does aliasing! scaling! rotation!
%  - Pango library with GTK (same than cairo but less buggy)
%  - freetype? fontconfig?
%  - openGL? actually one of the missing stuff in openGL is text API I think


%https://engineering.eventbrite.com/its-2015-and-drawing-text-is-still-hard-webgl-threejs/
% 
%http://behdad.org/text/
% State of text rendering in 2012 in Linux
% - fast font rasterizer using GPU in rust:
%   http://pcwalton.github.io/blog/2017/02/14/pathfinder/
% - enclyclopedie of fonts, font design: http://luc.devroye.org/fonts.html
% on hinting
%http://www.antigrain.com/research/font_rasterization/index.html

% super tricky rasterization process of scalable fonts:
% https://www.microsoft.com/typography/tools/trtalr.aspx

% can have font with any size? can scale? like in Cairo (and Pango)?
% can do codemap easily? I don't think so.

\t EASY rename f in sf when it involves a subfont, in fields, in locals
\t EASY rename cf to sf_range

% Bitmap font
% True Type font (of Apple originally)
% Clear Type font (subpixel of MS)
% Free Type = open source True Type

% Outline fonts = vector font.
% Hinting information = hacks to adjust glyphs at small pixel sizes
% Advanced topic.

\section{Font files formats}

% show content of unicode.font where see list of subfonts ranges.
%  A subfont is a picture containing many chars! where spec of chars
%   stored after in fontchars.
%  one font is split in many subfonts cos save space cos unicode really 
%   large so would be big images with lots of space wasted.
%   (65000 chars? 8x8 => total size = ?)
% maybe show one subfont file? where see compressed at the top?

% font format: see unicode.font
% - a file (or string) with a list of subfont ranges
% - %d %d\n%d %d\t%s\n...  first 2 numbers are height, ascent, 
%   and then a list of lines with each time
%     min/max (rune range), offset(optional), subfont name
% for offset see latin1.9 font or unicode.font and last unicode chars.

% subfont format (see getdefont): when uncompressed:
%  - ld = format for chan
%  - rectangle of font bits image
%  - data, via loadimage
%  - hdr for fontchars
%  - data for list of fontchars

% why subfont? because Unicode! far bigger than ASCII.

% so bitmap-based font. Not outline-font/true-type fonts. So 
% fixed size, fixed orientation :( no codemap.

\section{Additional data structures}

\subsection{[[Font]] and [[font]]}

<<struct Font>>=
struct Font
{
    // ref_own<filename>, // e.g., /lib/font/bit/lucm/latin1.9.font
    char		*name;
    // ref<Display>
    Display		*display;

    short		height;	/* max height of image, interline spacing */
    short		ascent;	/* top of image to baseline */

    <<[[Font]] subfont spec fields>>
    <<[[Font]] subfont cache fields>>
    <<[[Font]] character cache fields>>
    <<[[Font]] other fields>>
};
@
% ctor = buildfont <- openfont

\t FIGURE showing relation with height, ascent, etc.
% ascent used in string() to adjust the point where to display text
% so can say string(Pt(10,10)) but in the end it will display at
% Pt(10, 23) because the ascent is 13 and we want the text to be
% below Pt(10,10).

<<global font>>=
Font	*font;
@
%ocaml: pass it around each time instead? more functional? more tedious?

% used for? convenient shortcut?
% one of the global set by initdraw.


<<[[Display]] font fields>>=
Font	*defaultfont;
@
% used for? diff with global font? set in geninitdraw to same value than font
%  not used that much so perhaps could delay


% loaded fonts (subfonts) will be Images! in fact in Dimage
% there will be font properties inlined.


% Fonts are made of a set of subfonts where one subfont
% contain a big image with a set of chars. Not all cos could
% take too much space. So subfonts loaded as needed.

<<[[Font]] subfont spec fields>>=
// array<ref_own<Cachefont>> (length = Font.nsub)
Cachefont	**sub;	/* as read from file */
short		nsub;	/* number of subfonts */
@
%ocaml: array directly, no need separate nsub
\t rename sub to subspec or sf_spec

% spec of set of subfonts, but not the actual loaded subfont.
<<struct Cachefont>>=
struct Cachefont
{
    Rune		min;	/* lowest rune value to be taken from subfont */
    Rune		max;	/* highest rune value+1 to be taken from subfont */
    // option<int>, None = 0
    int		offset;	/* position in subfont of character at min */

    // ref_own<string>, relative filename
    char		*name;			/* stored in font */
    // option<ref_own<filename>>, absolute filename, computed by subfontname()
    char		*subfontname;		/* to access subfont */

};
@
% information about a range of chars, but still no Subfont.
\t rename cos it is actually not a cache ... rename SubfontInfo?

% all of that is set in buildfont.

\t How transit from Font to subfont? other fields are Cachexxx
% which have beneath probably a Subfont.

\subsection{[[Subfont]] and [[Fontchar]]}

%cachechars(2):
%"A Subfont is a set of images for a contiguous range of characters,
%stored as a single image with the characters placed side-by-side on a
%common baseline."

<<[[Display]] font fields>>=
Subfont	*defaultsubfont;
@
% used to bootstrap when lookup *default*, but could be done via
% a installsubfont I think instead.

<<struct Subfont>>=
/*
 * Subfonts
 *
 * given char c, Subfont *f, Fontchar *i, and Point p, one says
 *	i = f->info + c;
 *	draw(b, Rect(p.x + i->left, p.y + i->top,
 *		p.x + i->left + ((i+1)->x - i->x), p.y + i->bottom),
 *		color, f->bits, Pt(i->x, i->top));
 *	p.x += i->width;
 * to draw characters in the specified color (itself an Image) in Image b.
 */
struct	Subfont
{
    // ref_own<string>
    char		*name;
    // ref_own<Image> ?
    Image		*bits;	/* of font */

    // array<Fontchar> (size = Subfont.n + 1)
    Fontchar 	*info;	/* n+1 character descriptors */
    short		n;		/* number of chars in font */

    <<[[Subfont]] other fields>>

    // Extra
    int		ref;
};
@
%ocaml: no need n, use array which has fast Array.length

% ctor = allocsubfont (<- getdefont | ???)
% uchar so image can not be more than 255 pixels (but can be very wide)

% remember though that Image is just an id. Actual data is in kernel.

% n+1 so can have width of last char

<<struct Fontchar>>=
struct	Fontchar
{
    // character coordinates in Subfont.bits
    int		x;		/* left edge of bits */
    uchar	top;		/* first non-zero scan-line */
    uchar	bottom;		/* last non-zero scan-line + 1 */

    // adjustments to make on drawing point coordinates in destination
    schar	left;		/* offset of baseline */
    uchar	width;		/* width of baseline */
};
@
%c: finer grained int so can optimize layout on disk
%ocaml: just int everywhere? 
\t FIGURE, the comment of Subfont explains things quite good actually.

% cachechars(2): source
% "The pixels to be displayed for character c are in the
% rectangle (i->x, i->top, (i+1)->x, i->bottom) where i is
% &subfont->info[c]. "

% in libmemdraw/string.c, code used only by vgascreenputc, that is simpler
%  cos subfont already loaded:
%        memdraw(b, Rect(p.x + i->left, p.y + i->top, 
%                        p.x + i->left + (i[1].x -i[0].x), p.y+i->bottom),
%                  color, cp, f->bits, Pt(i->x, i->top), SoverD);


\l not always same top and bottom? no cos chars have different
\l  height and width and interspacing rules, so need adjustments?

% target:
% "When a character is displayed at Point p in an
% image, the character rectangle is placed at (p.x + i->left, p.y) and
% the next character of the string is displayed at (p.x + i->width, p.y)"

\l why left and width different from Fontchar.x and Fontchar.x + 1 ?


<<[[Subfont]] other fields>>=
uchar		height;		/* height of image */
char		ascent;		/* top of image to baseline */
@
\l why different size than the one in Font? why not short here too?


\subsection{Font image cache}


<<[[Font]] character cache fields>>=
// ref_own<Image>, growing image
Image		*cacheimage;
@
% allocimage(d, Rect(0, 0, ncache*wid, f->height), CHAN1(CGrey, depth), 0, 0);
% will contain many glyphs! side by side.

% kernel side! finally. additional info regarding Font.cacheimage->id
<<[[DImage]] font fields>>=
// growing_hash<Rune, ref_own<Fchar>> (size = DImage.nfchar)
FChar*      fchar;
int     nfchar;
@
%// growing_array<option<ref_own<Fchar>>> (size = DImage.nfchar)
% map Rune hashcode actually to FChar via big array. 
% Hashing done user side actually. 
% populated by loadchar().

% can contain glyphs of different subfonts!

% merge with Fontchar? no, this is different cos contain full info,
%  no need to do the x+1 gymnatstic.
<<struct FChar>>=
struct FChar
{
    // Rectangle in Font.cacheimage
    int     minx;   /* left edge of bits */
    int     maxx;   /* right edge of bits */
    uchar   miny;   /* first non-zero scan-line */
    uchar   maxy;   /* last non-zero scan-line + 1 */

    schar   left;   /* offset of baseline */
    uchar   width;  /* width of baseline */
};
@
\l could use a rectangle

% More later.

% FIGURE where see big soft archi picture? where see glyphs
%  from loaded subfonts copies into cacheimage?

<<[[DImage]] font fields>>=
int     ascent;
@
% many places the font is actually a DImage*



\section{Additional (user) initializations}
% client side only

% initdraw() and geninitdraw() take a [[fontname]] parameter.
% If not set then /env/font is used for default fontname. if nothing
% then create font with only default subfont.

<<[[geninitdraw()]] locals>>=
Subfont *df;
@
\t rename sf

<<[[geninitdraw()]] set up font>>=
/*
 * Set up default font
 */

// Set up default subfont
df = getdefont(display);
display->defaultsubfont = df;
<<[[geninitdraw()]] sanity check df>>

// Set up default font
<<[[geninitdraw()]] read fontname if fontname was nil>>
<<[[geninitdraw()]] if fontname still nil>>
else{
    font = openfont(display, fontname);	/* BUG: grey fonts */
    <<[[geninitdraw()]] sanity check font>>
}
display->defaultfont = font;
@








<<[[geninitdraw()]] sanity check df>>=
if(df == nil){
    fprint(2, "imageinit: can't open default subfont: %r\n");
Error:
    closedisplay(display);
    display = nil;
    return ERROR_NEG1;
}
@

<<[[geninitdraw()]] sanity check font>>=
if(font == nil){
    fprint(2, "imageinit: can't open font %s: %r\n", fontname);
    goto Error;
}
@

\subsection{Default subfont, [[getdefont()]]}

% defontdata in libdraw/defont.c, big, "lucm/latin1.9, in uncompressed form"

<<global sizeofdefont>>=
int	sizeofdefont = sizeof defontdata;
@
%ocaml: build directly parsed value instead of raw bytes that needs
% to be parsed

% initdraw -> geninitdraw -> <>
% ctor Subfont (other = ?)
<<function getdefont>>=
Subfont*
getdefont(Display *d)
{
    Subfont *f; // TODO sf
    Image *i;
    Rectangle r;
    int ld;
    char *p, *hdr;
    int n;
    Fontchar *fc;

    p = (char*)defontdata;
    <<[[getdefont()]] adjust p if not word-aligned>>

    // header of the image
    ld = atoi(p+0*12);
    r.min.x = atoi(p+1*12);
    r.min.y = atoi(p+2*12);
    r.max.x = atoi(p+3*12);
    r.max.y = atoi(p+4*12);

    i = allocimage(d, r, drawld2chan[ld], false, 0);
    <<[[getdefont()]] sanity check i>>

    p += 5*12;
    n = loadimage(i, r, (byte*)p, (defontdata + sizeofdefont)-(uchar*)p);
    <<[[getdefont()]] sanity check n>>

    // header of the Fontchar
    hdr = p+n;
    n = atoi(hdr+0*12);
    p = hdr+3*12;
    fc = malloc(sizeof(Fontchar)*(n+1));
    <<[[getdefont()]] sanity check fc>>
    _unpackinfo(fc, (byte*)p, n);

    f = allocsubfont("*default*", n, atoi(hdr+1*12), atoi(hdr+2*12), fc, i);
    <<[[getdefont()]] sanity check f>>
    return f;
}
@
%pad: I added the plus 0*12 for hdr too
%ocaml: simplified because of already-parsed complex value defontdata
% anyway the code is a bit redundant with code to read images

\t use defontname instead of default here!
% n+1 for fake last entry so can compute width of last char.
% 12 bytes each time for integer as a string.
% last two numbers are height and ascent I think.
% related = getmemdefont, almost copy paste but with Memimage instead of Image

% note that loadimage load the image in the kernel!
% this means also that every graphic app actually loads the
% same font in the kernel. Sharing there?

<<function _unpackinfo>>=
void
_unpackinfo(Fontchar *fc, byte *p, int n)
{
    int j;

    for(j=0;  j<=n;  j++){
        fc->x      = p[0]|(p[1]<<8);
        fc->top    = p[2];
        fc->bottom = p[3];

        fc->left   = p[4];
        fc->width  = p[5];

        fc++;
        p += 6;
    }
}
@
% >> >>  >> 
% <= n cos fill also last entry!





<<[[getdefont()]] adjust p if not word-aligned>>=
/*
 * make sure data is word-aligned.  this is true with Plan 9 compilers
 * but not in general.  the byte order is right because the data is
 * declared as char*, not ulong*.
 */
n = (int)(uvlong)p & 3;				/* stupid ape */
if(n != 0){
    memmove(p+(4-n), p, sizeofdefont-n);
    p += 4-n;
}
@
\l why it matters? for loadimage?


<<[[getdefont()]] sanity check i>>=
if(i == nil)
    return nil;
@
%ocaml: exn

<<[[getdefont()]] sanity check n>>=
if(n < 0){
    freeimage(i);
    return nil;
}
@
<<[[getdefont()]] sanity check fc>>=
if(fc == nil){
    freeimage(i);
    return nil;
}
@
%ocaml: exn and finalize

<<[[getdefont()]] sanity check f>>=
if(f == nil){
    freeimage(i);
    free(fc);
    return nil;
}
@
%ocaml: exn and finalize and gc for fc






% getdefont -> <>
%ctor
<<function allocsubfont>>=
Subfont*
allocsubfont(char *name, int n, int height, int ascent, Fontchar *info, Image *i)
{
    Subfont *f; // TODO sf

    <<[[allocsubfont()]] sanity check height>>

    f = malloc(sizeof(Subfont));
    <<[[allocsubfont()]] sanity check f>>
    f->n = n;
    f->height = height;
    f->ascent = ascent;
    f->info = info;
    f->bits = i;
    f->ref = 1;
    <<[[allocsubfont()]] install subfont if name>>
    else
        f->name = nil;
    return f;
}
@
% lookup subfont which is *default* here will be explained later.
% but actually not really used because lookup will fail, and so it
% will call installsubfont, but anyway there is special code later
% to lookup *default* to look in Display->defaultsubfont so
% there is no really need for installsubfont here.

% use a cache from subfontname to subfont because the same subfont can be reused
% across multiple fonts. 

<<[[allocsubfont()]] sanity check height>>=
assert(height != 0 /* allocsubfont */);
@

<<[[allocsubfont()]] sanity check f>>=
if(f == nil)
    return nil;
@
%ocaml: exn

%allocsubfont important! allow to share fonts between programs.






\subsection{Default font}

\subsubsection{[[openfont()]]}

% saw in geninitdraw:
%    font = openfont(display, fontname);	/* BUG: grey fonts */


% when passed a fontname (or /env/font non empty).
% (in the end call buildfont)
% pass the font filename (foo.font)

% used by many programs
<<function openfont>>=
Font*
openfont(Display *d, char *name)
{
    Font *fnt;
    fdt fd;
    int i, n;
    char *buf;
    Dir *dir;

    fd = open(name, OREAD);
    <<[[openfont()]] sanity check fd>>

    // n = filename_size(fd)
    dir = dirfstat(fd);
    <<[[openfont()]] sanity check dir>>
    n = dir->length;
    free(dir);

    buf = malloc(n+1);
    <<[[openfont()]] sanity check buf>>
    buf[n] = '\0';
    i = read(fd, buf, n);
    close(fd);
    <<[[openfont()]] sanity check i>>

    fnt = buildfont(d, buf, name);

    free(buf);
    return fnt;
}
@

% call buildfont where buf should contain spec of font (list of subfonts)



<<[[openfont()]] sanity check fd>>=
if(fd < 0)
    return nil;
@
<<[[openfont()]] sanity check dir>>=
if(dir == nil){
Err0:
    close(fd);
    return nil;
}
@

<<[[openfont()]] sanity check buf>>=
if(buf == nil)
    goto Err0;
@

<<[[openfont()]] sanity check i>>=
if(i != n){
    free(buf);
    return nil;
}
@

\subsubsection{[[/env/font]]}

<<[[geninitdraw()]] locals>>=
fdt fd;
int n;
char buf[128];
@

<<[[geninitdraw()]] read fontname if fontname was nil>>=
if(fontname == nil){
    fd = open("/env/font", OREAD);
    if(fd >= 0){
        n = read(fd, buf, sizeof(buf));
        if(n>0 && n < sizeof buf-1){
            buf[n] = '\0';
            fontname = buf;
        }
        close(fd);
    }
}
@

\subsubsection{font from default subfont}

% if no fontname passed and nothing in /env/font, then arrive here
%  and get fontinfo from default subfont

<<[[geninitdraw()]] if fontname still nil>>=
/*
 * Build fonts with caches==depth of screen, for speed.
 * If conversion were faster, we'd use 0 and save memory.
 */
if(fontname == nil){
    snprint(buf, sizeof buf, "%d %d\n0 %d\t%s\n", 
        df->height, df->ascent,
        df->n-1, deffontname);
    //BUG: Need something better for this	installsubfont("*default*", df);
    font = buildfont(display, buf, deffontname);
    <<[[geninitdraw()]] sanity check font part2>>
}
@
\l comment means ??

% format parsed later by buildfont! 0 %d, min and max, just one
% subfont line.

<<global deffontname>>=
static char deffontname[] = "*default*";
@
% but who installed this subfont? getdefont!
% so sharing by using shared name!


<<[[geninitdraw()]] sanity check font part2>>=
if(font == nil){
    fprint(2, "imageinit: can't open default font: %r\n");
    goto Error;
}
@

%\subsection{Kernel initializations}
% there is some, but for Graphical text mode, see adv topics


\section{Font allocation}

\subsection{[[buildfont()]]}

% This is code still in userspace.
% Actually font allocation involves no call to the kernel.
% Just load spec about font and its subfonts.
% Loading of subfonts (and of characters in the character cache)
%   is done on demand when drawing text.

% buf specify information about font, format with spacing and newline
%  so code below does some limited parsing.
% ctor of Font
% openfont -> <>
<<function buildfont>>=
Font*
buildfont(Display *d, char *buf, char *name)
{
    Font *fnt;
    char *s, *t;
    ulong min, max;
    Cachefont *c;
    int offset;
    <<[[buildfont()]] other locals>>

    s = buf;

    fnt = malloc(sizeof(Font));
    <<[[buildfont()]] sanity check fnt>>
    memset(fnt, 0, sizeof(Font));

    fnt->display = d;
    fnt->name = strdup(name);

    <<[[buildfont()]] allocate cache>>
    <<[[buildfont()]] initialize cache>>

    fnt->height = strtol(s, &s, 0);
    s = skip(s);
    fnt->ascent = strtol(s, &s, 0);
    s = skip(s);
    <<[[buildfont()]] sanity check fnt fields part2>>

    fnt->width = 0;

    fnt->sub = nil;
    fnt->nsub = 0;
    do{
        /* must be looking at a number now */
        <<[[buildfont()]] sanity check s content>>
        min = strtol(s, &s, 0);
        s = skip(s);
        /* must be looking at a number now */
        <<[[buildfont()]] sanity check s content>>
        max = strtol(s, &s, 0);
        s = skip(s);
        <<[[buildfont()]] sanity check min and max>>

        <<[[buildfont()]] set optional offset>>

        fnt->sub = realloc(fnt->sub, (fnt->nsub+1)*sizeof(Cachefont*));
        <<[[buildfont()]] sanity check fnt fields part3>>

        c = malloc(sizeof(Cachefont));
        <<[[buildfont()]] sanity check c>>
        fnt->sub[fnt->nsub] = c;
        fnt->nsub++;

        c->min = min;
        c->max = max;
        c->offset = offset;

        t = s;
        while(*s && *s!=' ' && *s!='\n' && *s!='\t')
            s++;
        *s++ = '\0';

        c->name = strdup(t);
        c->subfontname = nil; // full filename computed lazily later
        <<[[buildfont()]] sanity check c name field>>
        s = skip(s);
    } while(*s);
    return fnt;
}
@
%ocaml: use regexps



<<[[buildfont()]] set optional offset>>=
t = s;
offset = strtol(s, &t, 0);
if(t>s && (*t==' ' || *t=='\t' || *t=='\n'))
    s = skip(t);
else
    offset = 0;
@

<<function skip>>=
static char*
skip(char *s)
{
    while(*s==' ' || *s=='\n' || *s=='\t')
        s++;
    return s;
}
@






<<[[buildfont()]] sanity check fnt>>=
if(fnt == nil)
    return nil;
@

<<[[buildfont()]] sanity check fnt fields part1>>=
if(fnt->name==nil || fnt->cache==nil || fnt->subf==nil){
Err2:
    free(fnt->name);
    free(fnt->cache);
    free(fnt->subf);
    free(fnt->sub);
    free(fnt);
    return 0;
}
@
<<[[buildfont()]] sanity check fnt fields part2>>=
if(fnt->height <= 0 || fnt->ascent <= 0){
    werrstr("bad height or ascent in font file");
    goto Err2;
}
@

<<[[buildfont()]] sanity check s content>>=
if(*s<'0' || '9'<*s){
    werrstr(badform, s-buf);
    goto Err3;
}
@
<<[[buildfont()]] other locals>>=
char badform[] = "bad font format: number expected (char position %d)";
@

<<[[buildfont()]] sanity check min and max>>=
if(*s=='\0' || min>=Runemax || max>=Runemax || min>max){
    werrstr("illegal subfont range");
Err3:
    freefont(fnt);
    return nil;
}
@

<<[[buildfont()]] sanity check fnt fields part3>>=
if(fnt->sub == nil){
    /* realloc manual says fnt->sub may have been destroyed */
    fnt->nsub = 0;
    goto Err3;
}
@
<<[[buildfont()]] sanity check c>>=
if(c == nil)
    goto Err3;
@
<<[[buildfont()]] sanity check c name field>>=
if(c->name == nil){
    free(c);
    goto Err3;
}
@

\subsection{[[freefont()]]}

% program user | buildfont (when error) -> <>
% dtor
<<function freefont>>=
void
freefont(Font *f)
{
    int i;
    Cachefont *c;
    Subfont *s;

    <<[[freefont()]] sanity check f>>

    for(i=0; i<f->nsub; i++){
        c = f->sub[i];
        free(c->name);
        free(c->subfontname);
        free(c);
    }
    free(f->sub);

    <<[[freefont()]] free cache>>

    free(f->name);
    free(f);
}
@

<<[[freefont()]] sanity check f>>=
if(f == nil)
    return;
@
% should raise a warning instead



% dtor
% freefont | agefont -> <>
<<function freesubfont>>=
void
freesubfont(Subfont *f)
{
    <<[[freesubfont()]] sanity check f>>
    f->ref--;
    if(f->ref > 0)
        return;

    // else
    uninstallsubfont(f);
    free(f->info);	/* note: f->info must have been malloc'ed! */
    freeimage(f->bits);
    free(f);
}
@
% how can have multiple refs? in c2fsubfont, in lookupfont
% subfonts can be shared in different fonts (indeed some foo.font
% mention the same ranges and subfonts)
\t use sf not f

% uninstallsubfont? 

<<[[freesubfont()]] sanity check f>>=
if(f == nil)
    return;
@








\section{Drawing text}
% and rune

%https://engineering.eventbrite.com/its-2015-and-drawing-text-is-still-hard-webgl-threejs/

\subsection{API}

% variants = string vs rune, maxlen vs smaller n, SoverD vs op, nobg vs bg

<<function string>>=
Point
string(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s)
{
    return _string(dst, pt, src, sp, f, s, nil, 1<<24, dst->clipr, nil, ZP, SoverD);
}
@
% 1 << 24 = length (= infinite)

% return point so can know from where to draw the next string
% (so no need to call stringwidth on what was just drawn)

<<function stringop>>=
Point
stringop(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, Drawop op)
{
    return _string(dst, pt, src, sp, f, s, nil, 1<<24, dst->clipr, nil, ZP, op);
}
@

<<function stringn>>=
Point
stringn(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, int len)
{
    return _string(dst, pt, src, sp, f, s, nil, len, dst->clipr, nil, ZP, SoverD);
}
@
% xxxn, limit length
%ocaml: easy to build substring and GC it, so no need specialize stringn,
% just call string with a String.sub

<<function stringnop>>=
Point
stringnop(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, int len, Drawop op)
{
    return _string(dst, pt, src, sp, f, s, nil, len, dst->clipr, nil, ZP, op);
}
@




<<function runestring>>=
Point
runestring(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r)
{
    return _string(dst, pt, src, sp, f, nil, r, 1<<24, dst->clipr, nil, ZP, SoverD);
}
@

<<function runestringop>>=
Point
runestringop(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r, Drawop op)
{
    return _string(dst, pt, src, sp, f, nil, r, 1<<24, dst->clipr, nil, ZP, op);
}
@

<<function runestringn>>=
Point
runestringn(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r, int len)
{
    return _string(dst, pt, src, sp, f, nil, r, len, dst->clipr, nil, ZP, SoverD);
}
@

<<function runestringnop>>=
Point
runestringnop(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r, int len, Drawop op)
{
    return _string(dst, pt, src, sp, f, nil, r, len, dst->clipr, nil, ZP, op);
}
@


% could mv in adv topics the xxxbg()? will save some code also in
% marshalling/unmarshalling

<<function stringbg>>=
Point
stringbg(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, Image *bg, Point bgp)
{
    return _string(dst, pt, src, sp, f, s, nil, 1<<24, dst->clipr, bg, bgp, SoverD);
}
@

<<function stringbgop>>=
Point
stringbgop(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, Image *bg, Point bgp, int op)
{
    return _string(dst, pt, src, sp, f, s, nil, 1<<24, dst->clipr, bg, bgp, op);
}
@

<<function stringnbg>>=
Point
stringnbg(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, int len, Image *bg, Point bgp)
{
    return _string(dst, pt, src, sp, f, s, nil, len, dst->clipr, bg, bgp, SoverD);
}
@

<<function stringnbgop>>=
Point
stringnbgop(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, int len, Image *bg, Point bgp, int op)
{
    return _string(dst, pt, src, sp, f, s, nil, len, dst->clipr, bg, bgp, op);
}
@

<<function runestringbg>>=
Point
runestringbg(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r, Image *bg, Point bgp)
{
    return _string(dst, pt, src, sp, f, nil, r, 1<<24, dst->clipr, bg, bgp, SoverD);
}
@

<<function runestringbgop>>=
Point
runestringbgop(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r, Image *bg, Point bgp, int op)
{
    return _string(dst, pt, src, sp, f, nil, r, 1<<24, dst->clipr, bg, bgp, op);
}
@

<<function runestringnbg>>=
Point
runestringnbg(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r, int len, Image *bg, Point bgp)
{
    return _string(dst, pt, src, sp, f, nil, r, len, dst->clipr, bg, bgp, SoverD);
}
@

<<function runestringnbgop>>=
Point
runestringnbgop(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r, int len, Image *bg, Point bgp, int op)
{
    return _string(dst, pt, src, sp, f, nil, r, len, dst->clipr, bg, bgp, op);
}
@


\subsection{Marshalling}

<<constant Max>>=
Max = 100
@
% bad name, too general

% idea is process string piece by piece for one subfont.
% cachechars which will set f->cacheimage and create some data
%  structure server side.
% Then draw with this subfont in a loop the chars.
%  Part of info about subfont is stored in kernel.
% cachechars fill cbuf with a set of index corresponding to each
% Rune.
% so cachechars and _string works in tandem.
\l why not do everything userside? because want to batch in one call
\l  drawing many characters, so need char pos info in Kernel.
\l  (hmm could pass the Fontchar info)

<<function _string>>=
Point
_string(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, Rune *r, int len, Rectangle clipr, Image *bg, Point bgp, Drawop op)
{
    Rune **rptr;
    char **sptr;
    int m, n, max;
    ushort cbuf[Max], *c, *ec;
    byte *b;
    int wid;
    <<[[_string()]] other locals>>

    <<[[_string()]] non unicode string handling, set sptr and rptr>>
    else
      rptr = &r;

    while((*s || *r) && len){ // PAD: len > 0 in recent
        <<[[_string()]] set max>>

        // will trigger many calls to loadchar() for the same subfont
        n = cachechars(f, sptr, rptr, cbuf, max, &wid, &subfontname);

        if(n > 0){
            _setdrawop(dst->display, op);

            // string: 's' dstid[4] srcid[4] fontid[4] P[2*4] clipr[4*4] sp[2*4] ni[2] ni*(index[2]) 

            m = 47+2*n;
            <<[[_string()]] if bg part1>>
            b = bufimage(dst->display, m);
            <<[[_string()]] sanity check b>>
            <<[[_string()]] if bg part2>>
            else
                b[0] = 's';
            BPLONG(b+1, dst->id);
            BPLONG(b+5, src->id);
            BPLONG(b+9, f->cacheimage->id);
            BPLONG(b+13, pt.x);
            BPLONG(b+17, pt.y + f->ascent); // + ascent!
            BPLONG(b+21, clipr.min.x);
            BPLONG(b+25, clipr.min.y);
            BPLONG(b+29, clipr.max.x);
            BPLONG(b+33, clipr.max.y);
            BPLONG(b+37, sp.x);
            BPLONG(b+41, sp.y);
            BPSHORT(b+45, n);
            b += 47;
            <<[[_string()]] if bg part3>>
            // index of the set of characters to draw (hashcode of Rune)
            ec = &cbuf[n];
            for(c=cbuf; c<ec; c++, b+=2)
                BPSHORT(b, *c);

            pt.x += wid;
            bgp.x += wid;

            agefont(f);

            len -= n; // progress
        }
        <<[[_string()]] if subfontname>>
    }
    return pt;
}
@
% return pt!

% Important to add ascent!

% cachechars may return 0 when did a fontresize. moreover in that case
% subfontname should have been set.


% can be either string or rune. but in the rest we will focus
%  on rune.
<<[[_string()]] non unicode string handling, set sptr and rptr>>=
if(s == nil){
    s = "";
    sptr = nil;
}else
    sptr = &s;

if(r == nil){
    r = (Rune*) L"";
    rptr = nil;
}
@
% else rptr = &r;
%ocaml: use either?


<<[[_string()]] set max>>=
max = Max;
if(len < max)
    max = len;
@
%ocaml: functional style: min(len, Max)



<<[[_string()]] if bg part1>>=
// stringbg: 'x' dstid[4] srcid[4] fontid[4] P[2*4] clipr[4*4] sp[2*4] ni[2] bgid[4] bgpt[2*4] ni*(index[2])
if(bg)
    m += 4+2*4;
@

<<[[_string()]] if bg part2>>=
if(bg)
    b[0] = 'x';
@

<<[[_string()]] if bg part3>>=
if(bg){
    BPLONG(b, bg->id);
    BPLONG(b+4, bgp.x);
    BPLONG(b+8, bgp.y);
    b += 12;
}
@





<<[[_string()]] sanity check b>>=
if(b == nil){
    fprint(2, "string: %r\n");
    break;
}
@
%ocaml: exn




% cachechars
% _getsubfont

\subsection{Unmarshalling}

<<[[drawmesg()]] locals>>=
DImage *font;
Memimage  *bg;
int ci;
@

<<[[drawmesg()]] cases>>=
/* string: 's' dstid[4] srcid[4] fontid[4] P[2*4] clipr[4*4] sp[2*4] ni[2] ni*(index[2]) */
/* stringbg: 'x' dstid[4] srcid[4] fontid[4] P[2*4] clipr[4*4] sp[2*4] ni[2] bgid[4] bgpt[2*4] ni*(index[2]) */
case 's':
case 'x':
    printmesg(fmt="LLLPRPs", a, false);
    m = 1+4+4+4+2*4+4*4+2*4+2;
    <<[[drawmesg()]] when draw string, if bg part1>>
    <<[[drawmesg()]] sanity check n with m>>
    dst = drawimage(client, a+1);
    dstid = BGLONG(a+1);
    src = drawimage(client, a+5);
    font = drawlookup(client, BGLONG(a+9), true);
    <<[[drawmesg()]] when draw string, sanity check font>>
    drawpoint(&p, a+13);
    drawrectangle(&r, a+21);
    drawpoint(&sp, a+37);
    ni = BGSHORT(a+45);
    u = a+m;
    m += ni*2;
    <<[[drawmesg()]] sanity check n with m>>
    <<[[drawmesg()]] change dst clipr>>
    op = drawclientop(client);
    bg = dst;
    <<[[drawmesg()]] when draw string, if paint background>>
    q = p;
    while(--ni >= 0){
        ci = BGSHORT(u);
        <<[[drawmesg()]] when draw string, sanity check ci>>
        q = drawchar(dst, bg, q, src, &sp, font, ci, op); // The call
        u += 2;
    }
    <<[[drawmesg()]] restore dst clipr>>
    <<[[drawmesg()]] when draw text, dstflush>>
    continue;
@



% font = drawlookup(client, BGLONG(a+9), true);
%  true?


<<[[drawmesg()]] change dst clipr>>=
clipr = dst->clipr;
dst->clipr = r;
@
<<[[drawmesg()]] restore dst clipr>>=
dst->clipr = clipr;
@
% similar to the one for _memimageline, but with clipr and r instead
%  of oclipr and clipr


<<[[drawmesg()]] when draw string, if bg part1>>=
if(*a == 'x')
    m += 4+2*4;
@

<<[[drawmesg()]] when draw string, if paint background>>=
if(*a == 'x'){
    /* paint background */
    bg = drawimage(client, a+47);
    drawpoint(&q, a+51);
    r.min.x = p.x;
    r.min.y = p.y - font->ascent;
    r.max.x = p.x;
    r.max.y = r.min.y+Dy(font->image->r);
    j = ni;
    while(--j >= 0){
        ci = BGSHORT(u);
        <<[[drawmesg()]] when draw string, sanity check ci>>
        r.max.x += font->fchar[ci].width;
        u += 2;
    }
    memdraw(dst, r, bg, q, memopaque, ZP, op); // The call
    u -= 2*ni;
}
@

% fchar later



<<[[drawmesg()]] when draw string, sanity check font>>=
if(font == nil)
    error(Enodrawimage);
if(font->nfchar == 0)
    error(Enotfont);
@

<<[[drawmesg()]] when draw string, sanity check ci>>=
if(ci<0 || ci>=font->nfchar){
    dst->clipr = clipr;
    error(Eindex);
}
@
% nfchar later



\subsection{Algorithm}

% note that font below is actually a DImage!
% it has a fchar field that is populated by cachechars and loadchar
% we will see soon.

% in devvga.c, ugly, because of DImage here
<<function drawchar>>=
Point
drawchar(Memimage *dst, Memimage *rdst, Point p, Memimage *src, Point *sp, DImage *font, int index, int op)
{
    FChar *fc;
    Rectangle r;
    Point sp1;
    <<[[drawchar()]] other locals>>

    fc = &font->fchar[index];

    r.min.x = p.x + fc->left;
    r.min.y = p.y - (font->ascent - fc->miny);
    r.max.x = r.min.x + (fc->maxx - fc->minx);
    r.max.y = r.min.y + (fc->maxy - fc->miny);

    sp1.x = sp->x + fc->left;
    sp1.y = sp->y + fc->miny;

    <<[[drawchar()]] optimization when possible>>
    else{
    fallback:
        memdraw(dst, r, src, sp1, font->image, Pt(fc->minx, fc->miny), op);
    }

    p.x   += fc->width;
    sp->x += fc->width;
    return p;
}
@
% return point so can know from where to start for next char.

% see also chardraw which is an optimisation?

\section{Computing text width}

\subsection{API}

<<function stringwidth>>=
int
stringwidth(Font *f, char *s)
{
    return _stringnwidth(f, s, nil, 1<<24);
}
@
% >>

<<function stringnwidth>>=
int
stringnwidth(Font *f, char *s, int len)
{
    return _stringnwidth(f, s, nil, len);
}
@
%ocaml: again, use String.sub if you want a substring

<<function stringsize>>=
Point
stringsize(Font *f, char *s)
{
    return Pt(_stringnwidth(f, s, nil, 1<<24), f->height);
}
@
% >>



<<function runestringnwidth>>=
int
runestringnwidth(Font *f, Rune *r, int len)
{
    return _stringnwidth(f, nil, r, len);
}
@

<<function runestringwidth>>=
int
runestringwidth(Font *f, Rune *r)
{
    return _stringnwidth(f, nil, r, 1<<24);
}
@
% >>

<<function runestringsize>>=
Point
runestringsize(Font *f, Rune *r)
{
    return Pt(_stringnwidth(f, nil, r, 1<<24), f->height);
}
@
% >> >> >> >> >> >> >> >>


\subsection{Algorithm}

<<enum _anon_ (lib_graphics/libdraw/stringwidth.c)>>=
enum { Max = 64 };
@
% not sure why dont reuse the Max used in string.c

% lots of dupe with _string hence some same chunkname below

<<function _stringnwidth>>=
int
_stringnwidth(Font *f, char *s, Rune *r, int len)
{
    Rune **rptr;
    char **sptr;
    int wid, twid;
    int n, max, l;
    ushort cbuf[Max];
    char *subfontname;
    <<[[_stringnwidth()]] other locals>>

    <<[[_string()]] non unicode string handling, set sptr and rptr>>
    else
        rptr = &r;

    twid = 0;
    while(len > 0 && (*s || *r)){
        <<[[_string()]] set max>>
        n = 0;
        while((l = cachechars(f, sptr, rptr, cbuf, max, &wid, &subfontname)) <= 0){
            <<[[_stringnwidth()]] if cachechars failed too much>>
            <<[[_stringnwidth()]] if subfontname>>
        }
        agefont(f);

        twid += wid;
        len -= l; // progress
    }
    return twid;
}
@
% lots of code in common with _string


<<[[_stringnwidth()]] other locals>>=
char *name;
Rune rune;
@

<<[[_stringnwidth()]] if cachechars failed too much>>=
if(++n > 10){
    if(*r)
        rune = *r;
    else
        chartorune(&rune, s);
    if(f->name != nil)
        name = f->name;
    else
        name = "unnamed font";
    fprint(2, "stringwidth: bad character set for rune 0x%.4ux in %s\n", rune, name);
    return twid;
}
@
% when can this happen?

% no calls to draw? actually yes, because of cachechars can have
% some loadchar or fontresize.




\section{Character cache}
\n too important opti to be put in adv topics

% need that mainly because unicode I think. Otherwise could have
% an array of 200 entries (printable ascii chars). It would be fine.

% cachechars(2)

<<enum misc>>=
enum
{
    /* starting values */
    <<constant NFCACHE>>
    <<constant NFLOOK>>
    <<constant NFSUBF>>

    /* max value */
    <<constant MAXFCACHE>>
    <<constant MAXSUBF>>

    /* deltas */
    <<constant DSUBF>>

    /* expiry ages */
    SUBFAGE	=	10000,
    CACHEAGE =	10000
};
@
% >> >>


<<[[Font]] character cache fields>>=
ulong		age;	/* increasing counter; used for LRU */
@
% used for character cache and subfont cache?
<<[[buildfont()]] initialize cache>>=
fnt->age = 1;
@
% ok so when filled with first entry? cachechars?

<<[[freefont()]] free cache>>=
freeimage(f->cacheimage);
@



\subsection{[[Cacheinfo]]}

<<[[Font]] character cache fields>>=
// growing_hash<Rune, Cacheinfo> (size = Font.ncache, bucketsize = NFLOOK)
Cacheinfo	*cache;
int		ncache;	/* size of cache */
@
% actually hash and bucket = subarray of size NFLOOK
\t rename fchar? after all it mimics fchar in the kernel

% hashing function = ?

% this is user side. There is a corresponding one kernel side!
% saw it before, fchar.

% int cos return index in cache big array which should match the one
% in DImage.fchar

<<struct Cacheinfo>>=
struct Cacheinfo
{
    // the key
    Rune		value;	/* value of character at this slot in cache */

    // the values
    ushort		x;		/* left edge of bits */
    byte		width;		/* width of baseline */
    schar		left;		/* offset of baseline */

    ushort		age;
};
@
\l rename Runeinfo? or Charinfo? 
% seems redundant with Fontchar, could not just have a Fontchar ref here?
%  anyway the Fontchar will be needed to send the whole info to the kernel?


<<[[buildfont()]] allocate cache>>=
fnt->ncache = NFCACHE+NFLOOK;
fnt->cache = malloc(fnt->ncache * sizeof(fnt->cache[0]));
@

<<constant NFCACHE>>=
LOG2NFCACHE =	6,
NFCACHE =	(1<<LOG2NFCACHE),	/* #chars cached */
@
% 64 = enough for 26(A-Z) + 26(a-z) + 10(0-9) and some punctuations.
<<constant NFLOOK>>=
NFLOOK =	5,			/* #chars to scan in cache */
@
<<constant MAXFCACHE>>=
MAXFCACHE =	1024+NFLOOK,		/* upper limit */
@

<<[[buildfont()]] initialize cache>>=
<<[[buildfont()]] sanity check fnt fields part1>>
memset(fnt->subf, 0, fnt->nsubf * sizeof(fnt->subf[0]));
memset(fnt->cache, 0, fnt->ncache * sizeof(fnt->cache[0]));
@


<<[[freefont()]] free cache>>=
free(f->cache);
@


\subsection{Loading characters, [[cachechars()]]}

% fill cp with index to char in subfont.
% return number of characters processed (or 0)
% _string | _stringwidth -> <>
<<function cachechars>>=
int
cachechars(Font *f, char **ss, Rune **rr, ushort *cp, int max, int *wp, char **subfontname)
{
    Rune *rp;
    char *sp;
    Rune r;
    int w, rw;
    int wid = 0;
    int i;
    int h; // index in Font.cache
    int sh; // rune hashcode
    Cacheinfo *c, *ec;
    <<[[cachechars()]] other locals>>

    <<[[cachechars()]] non unicode string handling part1>>
    else{
        sp = "";
        rp = *rr;
    }
    *subfontname = nil;

    for(i=0; i<max && (*sp || *rp); sp+=w, rp+=rw){
        <<[[cachechars()]] non unicode string handling part2>>
        else{
            r = *rp;
            w = 0;
            rw = 1;
        }

        // sh = hash_code(r)
        sh = (17 * (uint)r) & (f->ncache-NFLOOK-1);

        // c,h = lookup(r, sh, f->cache)
        c = &f->cache[sh];
        ec = c+NFLOOK;
        h = sh;
        while(c < ec){
            if(c->value==r && c->age)
                goto Found;
            c++;
            h++;
        }
        // this can break out of the loop
        <<[[cachechars()]] when rune not in cache, loads it>>
    
        Found:
        wid += c->width;
        c->age = f->age;
        cp[i] = h;
        i++;
    }
    <<[[cachechars()]] non unicode string handling part3>>
    else
        *rr = rp;
    *wp = wid;

    return i;
}
@

% so cp[i] = h means it's the index in Font.cache


%        sh = (17 * (uint)r) & (f->ncache-NFLOOK-1);
% so how does it work for a, b, c, d, e
% will spread around? or already cause a resize?

<<[[cachechars()]] non unicode string handling part1>>=
if(ss){
    sp = *ss;
    rp = L"";
}
@
<<[[cachechars()]] other locals>>=
Rune vr;
@
<<[[cachechars()]] non unicode string handling part2>>=
if(ss){
    r = *(uchar*)sp;
    if(r < Runeself)
        w = 1;
    else{
        w = chartorune(&vr, sp);
        r = vr;
    }
    rw = 0;
}
@
<<[[cachechars()]] non unicode string handling part3>>=
if(ss)
    *ss = sp;
@






\subsection{Loading one new character, [[loadchar()]]}

<<[[cachechars()]] other locals>>=
int ld;
@


<<[[cachechars()]] when rune not in cache, loads it>>=
<<[[cachechars()]] find oldest entry [[c]] with age a in cache>>
<<[[cachechars()]] if age too recent then resize cache>>
<<[[cachechars()]] if same age>>
// else

ld = loadchar(f, r, c, h, i, subfontname);
<<[[cachechars()]] if could not load char>>
// else
c = &f->cache[h];	/* may have reallocated f->cache */
@
% pass i, character number cos 0 has a special role
% load in font f, rune r, cacheinfo c, index h, character #i, 
%  and return error code and subfontname loaded if any.



% this will cause to break out of the loop
<<[[cachechars()]] if could not load char>>=
if(ld <= 0){
    <<[[cachechars()]] if loadchar failed>>
    break;
}
@
% break so will work for next loop iteration in cachechars.
% loadchar will return -1 when are outside range of current subfont
%  and so neeed to load a new subfont.
%  In that case subfontname will be set.




<<[[cachechars()]] if loadchar failed>>=
if(ld == 0) // when failed, but why can fail?
    continue;
@







<<[[cachechars()]] other locals>>=
int th;
Cacheinfo *tc;
ulong a;
@

<<[[cachechars()]] find oldest entry [[c]] with age a in cache>>=
/*
 * Not found; toss out oldest entry
 */
a = ~0;
th = sh;
tc = &f->cache[th];
while(tc < ec){
    if(tc->age < a){
        a = tc->age;
        h = th;
        c = tc;
    }
    tc++;
    th++;
}
@
% again set c and h. quite simple.






% passed subfontname ref
% -1 when new subfont which should be passed to cachechars
%  and then back to _string or _stringwidth

% cachechars -> <>
<<function loadchar>>=
/* return 1 if load succeeded, 0 if failed, -1 if must retry */
error0
loadchar(Font *f, Rune r, Cacheinfo *c, int h, int noflush, char **subfontname)
{
    Rune pic; // ?? means
    Cachefont *cf;
    int i;
    int oi, wid, top, bottom;
    Fontchar *fi;
    Cachesubf *subf;
    <<[[loadchar()]] other locals>>

    pic = r;

    // Find subfont spec cf for Rune r 
    Again:
    for(i=0; i < f->nsub; i++){
        cf = f->sub[i];
        if(cf->min <= pic && pic <= cf->max)
            goto Found;
    }
    <<[[loadchar()]] if rune not handled by the font>>

    Found:
    // Now let's find the loaded subfont subf with spec cf 
    /*
     * Choose exact or oldest
     */
    oi = 0;
    subf = &f->subf[0];
    for(i=0; i < f->nsubf; i++){
        if(cf == subf->cf)
            goto Found2;
        if(subf->age < f->subf[oi].age)
            oi = i;
        subf++;
    }
    // may load and find the right subf
    <<[[loadchar()]] when the corresponding subfont is not loaded yet>>

    Found2:
    subf->age = f->age;

    /* possible overflow here, but works out okay */
    pic += cf->offset;
    pic -= cf->min;
    <<[[loadchar()]] if rune outside range>>
    fi = &subf->f->info[pic];
    <<[[loadchar()]] sanity check fontchar width>>
    wid = (fi+1)->x - fi->x;
    <<[[loadchar()]] resize cache if width too big>>

    c->value = r;
    top    = fi->top    + (f->ascent - subf->f->ascent);
    bottom = fi->bottom + (f->ascent - subf->f->ascent);
    c->width = fi->width;
    c->x = h * f->width;
    c->left = fi->left;

    <<[[loadchar()]] sanity check display>>

    <<[[loadchar()]] marshall Cacheinfo c>>
}
@
% it just loads one char at a time? seems very inefficient.
% why not do all of that computation client side instead
% pass the right rect in drawchar?



<<constant PJW>>=
#define	PJW	0	/* use NUL==pjw for invisible characters */
@
% PJW means?

<<[[loadchar()]] if rune not handled by the font>>=
TryPJW:
if(pic != PJW){
    pic = PJW;
    goto Again;
}
return ERROR_0;
@

<<[[loadchar()]] if rune outside range>>=
if(pic >= subf->f->n)
    goto TryPJW;
@

<<[[loadchar()]] sanity check fontchar width>>=
if(fi->width == 0)
    goto TryPJW;
@

<<[[loadchar()]] sanity check display>>=
if(f->display == nil)
    return OK_1;
@



\subsubsection{Marshalling}



<<[[loadchar()]] other locals>>=
byte *b;
@

<<[[loadchar()]] marshall Cacheinfo c>>=
flushimage(f->display, false);	/* flush any pending errors */

// load character: 'l' fontid[4] srcid[4] index[2] R[4*4] P[2*4] left[1] width[1]
b = bufimage(f->display, 37);
<<[[loadchar()]] sanity check b>>
b[0] = 'l';
BPLONG(b+1, f->cacheimage->id);
BPLONG(b+5, subf->f->bits->id);

// index
BPSHORT(b+9, c - f->cache); 

// destination coordinates in f->cacheimage
BPLONG(b+11, c->x);
BPLONG(b+15, top);
BPLONG(b+19, c->x + ((fi+1)->x - fi->x));
BPLONG(b+23, bottom);

// source coordinate in subf->f->bits->id
BPLONG(b+27, fi->x);
BPLONG(b+31, fi->top);
b[35] = fi->left;
b[36] = fi->width;

return OK_1;
@

% Note that fontid must be a fontimage, so must have gone
% through the initialize message ('i') for server side to be ready
% to see fontid as a font cache image.

<<[[loadchar()]] sanity check b>>=
if(b == nil)
    return ERROR_0;
@

\subsubsection{Unmarshalling}

<<[[drawmesg()]] locals>>=
FChar *fc;
@

<<[[drawmesg()]] cases>>=
/* load character: 'l' fontid[4] srcid[4] index[2] R[4*4] P[2*4] left[1] width[1] */
case 'l':
    printmesg(fmt="LLSRPbb", a, false);
    m = 1+4+4+2+4*4+2*4+1+1;
    <<[[drawmesg()]] sanity check n with m>>
    font = drawlookup(client, BGLONG(a+1), true);
    <<[[drawmesg()]] when load character, sanity check font>>
    src = drawimage(client, a+5);
    ci = BGSHORT(a+9);
    <<[[drawmesg()]] when load character, sanity check ci>>
    drawrectangle(&r, a+11);
    drawpoint(&p, a+27);
    memdraw(font->image, r, src, p, memopaque, p, S);

    fc = &font->fchar[ci];

    fc->minx = r.min.x;
    fc->maxx = r.max.x;
    fc->miny = r.min.y;
    fc->maxy = r.max.y;

    fc->left = a[35];
    fc->width = a[36];

    continue;
@

<<[[drawmesg()]] when load character, sanity check font>>=
if(font == nil)
    error(Enodrawimage);
if(font->nfchar == 0)
    error(Enotfont);
@

<<[[drawmesg()]] when load character, sanity check ci>>=
if(ci >= font->nfchar)
    error(Eindex);
@

%\subsubsection{Loading a new subfont part1}

%\subsubsection{Loading a new subfont part2}


\subsection{Resizing the character cache, [[fontresize()]]}
% misleading function name

% 2 reasons: 
% - too small, too many recent entries in NFLOOK window
%   so need to resize fchar
% - width different, depth different, so need to resize
%   cacheimage

<<[[Font]] other fields>>=
short		width;	/* widest so far; used in caching only */	
int		maxdepth;	/* maximum depth of all loaded subfonts */
@
\l rename to maxwidth
% need resize when one glyph has bigger width because we use thids
% width as a way to find the x coord of the nth character in cacheimage



<<[[cachechars()]] other locals>>=
int nc;
@
<<[[cachechars()]] if age too recent then resize cache>>=
if(a && (f->age - a) < 500){	/* kicking out too recent; resize */
    nc = 2*(f->ncache-NFLOOK) + NFLOOK;
    if(nc <= MAXFCACHE){
        if(i == 0)
            fontresize(f, f->width, nc, f->maxdepth);
        /* else flush first; retry will resize */
        break;
    }
    // else, no resize
}
@
% break so we re done for now for this set of chars.
% special test i == 0 because fontresize would invalidade the
%  characters already processed in cachechars which would not
%  a valid entry in fchar, so we resize only if we are the first
%  character.

% if a because at the beginning every entry has age 0 (memset(,0)

<<[[cachechars()]] if same age>>=
if(c->age == f->age)	/* flush pending string output */
    break;
@
% ???



<<[[loadchar()]] resize cache if width too big>>=
if(f->width < wid || f->width == 0 || f->maxdepth < subf->f->bits->depth){
    /*
     * Flush, free, reload (easier than reformatting f->b)
     */
    if(noflush)
        return -1;
    // else

    if(f->width < wid)
        f->width = wid;
    if(f->maxdepth < subf->f->bits->depth)
        f->maxdepth = subf->f->bits->depth;
    i = fontresize(f, f->width, f->ncache, f->maxdepth);
    if(i <= 0)
        return i;
    /* c is still valid as didn't reallocate f->cache */
}
@
% first char of cachechars, we already done some job, so resize
% not a good idea. Same that in cachechars.






\subsubsection{Marshalling}

% can resize because width/depth changed or because ncache size changed
% and in former case we need to invalidate everything.

% will generate 3 messages: allocimage, fontresize, freeimage

% cachechars | loadchar -> <>
<<function fontresize>>=
/* return whether resize succeeded && f->cache is unchanged */
static bool
fontresize(Font *f, int wid, int ncache, int depth)
{
    Cacheinfo *i;
    int ret;
    Image *new;
    uchar *b;
    Display *d;

    ret = false;
    <<[[fontresize()]] sanity check depth and wid>>
    d = f->display;
    <<[[fontresize()]] sanity check d>>

    new = allocimage(d, Rect(0, 0, ncache*wid, f->height), CHAN1(CGrey, depth), false, 0);
    <<[[fontresize()]] sanity check new>>
    flushimage(d, false);	/* flush any pending errors */

    b = bufimage(d, 1+4+4+1);
    <<[[fontresize()]] sanity check b>>
    b[0] = 'i';
    BPLONG(b+1, new->id);
    BPLONG(b+5, ncache);
    b[9] = f->ascent;
    if(flushimage(d, false) < 0){
        fprint(2, "resize: init failed: %r\n");
        freeimage(new);
        goto Return;
    }

    freeimage(f->cacheimage);
    f->cacheimage = new;

    Nodisplay:
    f->width = wid;
    f->maxdepth = depth;
    ret = true;
    <<[[fontresize()]] if need to resize the cache>>
    Return:
    memset(f->cache, 0, f->ncache*sizeof f->cache[0]);
    return ret;
}
@
% so erase all previous chars


<<[[fontresize()]] if need to resize the cache>>=
if(f->ncache != ncache){
    i = malloc(ncache*sizeof f->cache[0]);
    if(i != nil){
        ret = false;
        free(f->cache);
        f->ncache = ncache;
        f->cache = i;
    }
    /* else just wipe the cache clean and things will be ok */
}
@

<<[[fontresize()]] sanity check depth and wid>>=
if(depth <= 0)
    depth = 1;
if(wid <= 0)
    wid = 1;
@
<<[[fontresize()]] sanity check d>>=
if(d == nil)
    goto Nodisplay;
@
<<[[fontresize()]] sanity check new>>=
if(new == nil){
    fprint(2, "font cache resize failed: %r\n");
    abort();
    goto Return;
}
@

<<[[fontresize()]] sanity check b>>=
if(b == nil){
    freeimage(new);
    goto Return;
}
@



\subsubsection{Unmarshalling}

% font below is a DImage
% here we show only unmarshall for initialize font message.
% there is also code for allocimage and freeimage presented in chapter X

% fontresize!
<<[[drawmesg()]] cases>>=
/* initialize font: 'i' fontid[4] nchars[4] ascent[1] */
case 'i':
    printmesg(fmt="Llb", a, false);
    m = 1+4+4+1;
    <<[[drawmesg()]] sanity check n with m>>
    dstid = BGLONG(a+1);
    <<[[drawmesg()]] when initialize font image and cache, sanity check dstid>>
    font = drawlookup(client, dstid, true);
    <<[[drawmesg()]] when initialize font image and cache, sanity check font>>
    ni = BGLONG(a+5);
    <<[[drawmesg()]] when initialize font image and cache, sanity check ni>>
    free(font->fchar);  /* should we complain if non-zero? */
    font->fchar = malloc(ni * sizeof(FChar));
    <<[[drawmesg()]] when initialize font image and cache, sanity check fchar>>
    memset(font->fchar, 0, ni*sizeof(FChar));
    font->nfchar = ni;
    font->ascent = a[9];
    continue;

@
%old: was passing true to printmesg

% so erase all previous chars

<<[[drawmesg()]] when initialize font image and cache, sanity check dstid>>=
if(dstid == 0)
    error("cannot use display as font");
@
<<[[drawmesg()]] when initialize font image and cache, sanity check font>>=
if(font == nil)
    error(Enodrawimage);
if(font->image->layer)
    error("cannot use window as font");
@

<<[[drawmesg()]] when initialize font image and cache, sanity check ni>>=
if(ni<=0 || ni>4096)
    error("bad font size (4096 chars max)");
@
<<[[drawmesg()]] when initialize font image and cache, sanity check fchar>>=
if(font->fchar == nil)
    error("no memory for font");
@


\subsection{[[agefont()]]}

% _string -> <>
<<function agefont>>=
void
agefont(Font *f)
{
    <<[[agefont()]] locals>>

    f->age++;
    <<[[agefont()]] if age overflow>>
}
@


<<[[agefont()]] locals>>=
Cacheinfo *c, *ec;
Cachesubf *s, *es;
@

<<[[agefont()]] if age overflow>>=
if(f->age == 65536){
    /*
     * Renormalize ages
     */
    c = f->cache;
    ec = c+f->ncache;
    while(c < ec){
        if(c->age){
            c->age >>= 2;
            c->age++;
        }
        c++;
    }

    s = f->subf;
    es = s + f->nsubf;
    while(s < es){
        if(s->age){
            if(s->age < SUBFAGE && s->cf->name != nil){
                /* clean up */
                if(display &&
                    s->f != display->defaultsubfont)
                    freesubfont(s->f);
                s->cf = nil;
                s->f = nil;
                s->age = 0;
            }else{
                s->age >>= 2;
                s->age++;
            }
        }
        s++;
    }
    f->age = (65536>>2) + 1;
}
@

\section{Subfonts}

%trans:
% use bits->id in loadchar message, assume there was a subf loaded.

\subsection{Subfont cache, [[Cachesubf]]}

<<[[Font]] subfont cache fields>>=
// growing_array<Cachesubf> (size = Font.nsubf, init = NFSUBF, max = MAXSUBF)
Cachesubf	*subf;
int		nsubf;	/* size of subfont list */
@

<<struct Cachesubf>>=
struct Cachesubf
{
    // ref<Cachefont>, the key
    Cachefont	*cf;	/* font info that owns us */
    // ref_own<Subfont>, the value
    Subfont		*f;	/* attached subfont */

    ulong		age;	/* for replacement */
};
@
% link between Font and subfont! finally!
\t rename f to sf here! confusing when have f->sub->f 


<<[[buildfont()]] allocate cache>>=
fnt->nsubf = NFSUBF;
fnt->subf = malloc(fnt->nsubf * sizeof(fnt->subf[0]));
@

<<constant NFSUBF>>=
NFSUBF =	2,			/* #subfonts to cache */
@
<<constant MAXSUBF>>=
MAXSUBF =	50,			/* generous upper limit */
@
<<constant DSUBF>>=
DSUBF = 	4,
@

<<[[freefont()]] free cache>>=
for(i=0; i<f->nsubf; i++){
    s = f->subf[i].f;
    if(s && display && s != display->defaultsubfont)
        freesubfont(s);
}
free(f->subf);
@



\subsection{Subfont loading}

\subsubsection{Subfont loading part 1}


<<[[loadchar()]] other locals>>=
Cachesubf *of;
@

% could not find subf with right cf in Font.subf.
<<[[loadchar()]] when the corresponding subfont is not loaded yet>>=
subf = &f->subf[oi];
<<[[loadchar()]] if old subfont entry valid, free it or expand subfont cache>>
subf->age = 0;
subf->cf = nil;
subf->f = cf2subfont(cf, f);
<<[[loadchar()]] sanity check subfont f>>
subf->cf = cf;
<<[[loadchar()]] sanity check ascents>>
@
% cf2subfont later


<<[[loadchar()]] if old subfont entry valid, free it or expand subfont cache>>=
if(subf->f){
    if(f->age - subf->age > SUBFAGE || f->nsubf > MAXSUBF){
Toss:
        /* ancient data; toss */
        freesubfont(subf->f);
        subf->cf = nil;
        subf->f = nil;
        subf->age = 0;
    }else{				/* too recent; grow instead */
        of = f->subf;
        f->subf = malloc((f->nsubf+DSUBF) * sizeof(Subfont));
        <<[[loadchar()]] sanity check new malloced subf>>
        memmove(f->subf, of, (f->nsubf+DSUBF) * sizeof(Subfont));
        memset(f->subf+f->nsubf, 0, DSUBF*sizeof *subf);
        subf = &f->subf[f->nsubf];
        f->nsubf += DSUBF;
        free(of);
    }
}
@


<<[[loadchar()]] sanity check new malloced subf>>=
if(f->subf == nil){
    f->subf = of;
    goto Toss;
}
@


<<[[loadchar()]] sanity check ascents>>=
if(subf->f->ascent > f->ascent && f->display){
    /* should print something? this is a mistake in the font file */
    /* must prevent c->top from going negative when loading cache */
    Image *b;
    int d, t;
    d = subf->f->ascent - f->ascent;
    b = subf->f->bits;
    draw(b, b->r, b, nil, addpt(b->r.min, Pt(0, d)));
    draw(b, Rect(b->r.min.x, b->r.max.y-d, b->r.max.x, b->r.max.y), f->display->black, nil, b->r.min);
    for(i=0; i<subf->f->n; i++){
        t = subf->f->info[i].top-d;
        if(t < 0)
            t = 0;
        subf->f->info[i].top = t;
        t = subf->f->info[i].bottom-d;
        if(t < 0)
            t = 0;
        subf->f->info[i].bottom = t;
    }
    subf->f->ascent = f->ascent;
}
@







% just set fullname of font

% loadchar -> <>
<<function cf2subfont>>=
static Subfont*
cf2subfont(Cachefont *cf, Font *f)
{
    int depth;
    char *name;

    name = cf->subfontname;
    if(name == nil){
        <<[[cf2subfont()]] set depth>>
        name = subfontname(cf->name, f->name, depth);
        <<[[cf2subfont()]] sanity check name>>
        cf->subfontname = name;
    }
    return lookupsubfont(f->display, name);
}
@
%old:    
%    Subfont *sf;
%    ...
%    sf = lookupsubfont(f->display, name);
%    return sf;


% why not load it now? why return up to _string to get it done?
%  and do this name magic?


<<[[cf2subfont()]] set depth>>=
if(f->display && f->display->screenimage)
    depth = f->display->screenimage->depth;
else
    depth = 8;
@

<<[[cf2subfont()]] sanity check name>>=
if(name == nil)
    return nil;
@



<<function subfontname>>=
/*
 * Default version: convert to file name
 */
char*
subfontname(char *cfname, char *fname, int maxdepth)
{
    char *t, *u, *tmp1, *tmp2;
    int i;

    t = strdup(cfname);  /* t is the return string */
    if(strcmp(cfname, "*default*") == 0)
        return t;
    if(t[0] != '/'){
        tmp2 = strdup(fname);
        u = utfrrune(tmp2, '/');
        if(u)
            u[0] = 0;
        else
            strcpy(tmp2, ".");
        tmp1 = smprint("%s/%s", tmp2, t);
        free(tmp2);
        free(t);
        t = tmp1;
    }

    if(maxdepth > 8)
        maxdepth = 8;

    for(i=3; i>=0; i--){
        if((1<<i) > maxdepth)
            continue;
        /* try i-bit grey */
        tmp2 = smprint("%s.%d", t, i);
        if(access(tmp2, AREAD) == 0) {
            free(t);
            return tmp2;
        }
        free(tmp2);
    }

    /* try default */
    if(access(t, AREAD) == 0)
        return t;

    free(t);
    return nil;
}
@
% >>



\subsubsection{Subfont loading part 2}


% how cf2subfont can fail? it will fail unless
%  the name was in the lookupsubfont memoized

<<[[loadchar()]] sanity check subfont f>>=
if(subf->f == nil){
    if(cf->subfontname == nil)
        goto TryPJW;
    *subfontname = cf->subfontname;
    return -1; // caller must retry
}
@

% n = cachechars(..., &subfontname);
% sometimes n can be 0 because new subfont in which case
%  subfontname should have been set? Or can have n > 0 and
%  subfontname?
%  do some assert? rewrite code to use a else if and a final else
%   which raise an error?

<<[[_string()]] other locals>>=
char *subfontname;
Subfont *sf = nil;
@
% a new subfont may have been loaded.
<<[[_string()]] if subfontname>>=
if(subfontname){
    <<[[_string()]] free previous sf>>
    // populate Font.subf global so next loadchar will find the subfont
    sf=_getsubfont(f->display, subfontname);
    <<[[_string()]] sanity check sf and possibly adjust f>>
    /* 
     * must not free sf until cachechars has found it in the cache
     * and picked up its own reference.
     */
}
@
% comment? very enigmatic

<<[[_string()]] free previous sf>>=
freesubfont(sf);
@
% free it once used and got a new one

<<[[_string()]] other locals>>=
Font *def;
@
<<[[_string()]] sanity check sf and possibly adjust f>>=
if(sf == nil){
    def = f->display ? f->display->defaultfont : nil;
    if(def && f != def)
        f = def;
    else
        break;
}
@
\l this code can be simplified


<<[[_stringnwidth()]] other locals>>=
Font *def;
@

<<[[_stringnwidth()]] if subfontname>>=
if(subfontname){
    if(_getsubfont(f->display, subfontname) == 0){
        def = f->display->defaultfont;
        if(def && f!=def)
            f = def;
        else
            break;
    }
}
@








% called when loadchar set the subfontname
% _string | _stringwidth -> <>

<<function _getsubfont>>=
/*
 * Default version: treat as file name
 */
Subfont*
_getsubfont(Display *d, char *name)
{
    fdt fd;
    Subfont *f;

    fd = open(name, OREAD);
    <<[[_getsubfont()]] sanity check fd>>

    <<[[_getsubfont()]] locking part1>>
    f = readsubfont(d, name, fd, d && !d->locking);
    <<[[_getsubfont()]] locking part2>>
    <<[[_getsubfont()]] sanity check f>>
    close(fd);
    <<[[_getsubfont()]] set malloc tag for debug>>

    return f;
}
@


<<[[_getsubfont()]] sanity check fd>>=
if(fd < 0){
    fprint(2, "getsubfont: can't open %s: %r\n", name);
    return nil;
}
@

<<[[_getsubfont()]] locking part1>>=
/*
 * unlock display so i/o happens with display released, unless
 * user is doing his own locking, in which case this could break things.
 * _getsubfont is called only from string.c and stringwidth.c,
 * which are known to be safe to have this done.
 */
if(d && !d->locking)
    unlockdisplay(d);
@

<<[[_getsubfont()]] locking part2>>=
if(d && !d->locking)
    lockdisplay(d);
@


<<[[_getsubfont()]] sanity check f>>=
if(f == nil)
    fprint(2, "getsubfont: can't read %s: %r\n", name);
@



\subsection{Subfont sharing}
% but seems very limited form of sharing

<<[[allocsubfont()]] install subfont if name>>=
if(name){
    f->name = strdup(name);
    if(lookupsubfont(i->display, name) == nil)
        installsubfont(name, f);
}
@

% memoized
<<global lastname>>=
static char	*lastname;
@
<<global lastsubfont>>=
Subfont	*lastsubfont;
@
%ocaml: could do a hash instead?

% (getdefont -> allocsubfont) | (loadchar -> cf2subfont) -> <>
<<function lookupsubfont>>=
Subfont*
lookupsubfont(Display *d, char *name)
{
    if(d && strcmp(name, "*default*") == 0)
        return d->defaultsubfont; 
    if(lastname && strcmp(name, lastname)==0)
      if(d == lastsubfont->bits->display){
        lastsubfont->ref++;
        return lastsubfont;
    }
    return nil;
}
@
\l use defontname here again! instead of hardcoded?
% ref++ here! so can share?
% which is why no need installsubfont for default subfont.

<<function installsubfont>>=
void
installsubfont(char *name, Subfont *subfont)
{
    free(lastname);
    lastname = strdup(name);
    lastsubfont = subfont;	/* notice we don't free the old one; that's your business */
}
@

% agefont -> freesubfont -> <>
<<function uninstallsubfont>>=
void
uninstallsubfont(Subfont *subfont)
{
    if(subfont == lastsubfont){
        lastname = nil;
        lastsubfont = nil;
    }
}
@




\subsection{Subfont IO}

\subsubsection{Reading a subfont}

% subfont format? image, then fontchar header
%  = 3 integers of 11 chars + 1 space each. and then why 4+1 below?
% and then fontchars.

% _getsubfont -> <>
<<function readsubfont>>=
Subfont*
readsubfont(Display *d, char *name, fdt fd, bool dolock)
{
    Image *i;
    Fontchar *fc;
    char hdr[3*12 + 4+1];
    int n;
    byte *p;
    Subfont *f;

    // reading the image

    i = readimage(d, fd, dolock); // the call!
    <<[[readsubfont()]] sanity check i>>

    // reading the fontchars

    if(read(fd, hdr, 3*12) != 3*12){
        freeimage(i);
        werrstr("rdsubfonfile: header read error: %r");
        return nil;
    }
    n = atoi(hdr);
    p = malloc(6 * (n+1));
    <<[[readsubfont()]] sanity check p>>
    if(read(fd, p, 6 * (n+1)) != 6 * (n+1)){
        werrstr("rdsubfonfile: fontchar read error: %r");
    Err:
        freeimage(i);
        free(p);
        return nil;
    }
    fc = malloc(sizeof(Fontchar) * (n+1));
    <<[[readsubfont()]] sanity check fc>>
    _unpackinfo(fc, p, n);
    <<[[readsubfont()]] if lock part1>>
    f = allocsubfont(name, n, atoi(hdr+12), atoi(hdr+24), fc, i);
    <<[[readsubfont()]] if lock part2>>
    <<[[readsubfont()]] sanity check f>>
    free(p);
    return f;
}
@
%dead:
% Subfont*
%  readsubfonti(Display*d, char *name, fdt fd, Image *ai, bool dolock) {
%    i = ai;
%    if(i == nil){
% ...
%        if(ai == nil)

% seen _unpackinfo in getdefont already


<<[[readsubfont()]] sanity check i>>=
if(i == nil)
    return nil;
@
<<[[readsubfont()]] sanity check p>>=
if(p == nil)
    goto Err;
@
<<[[readsubfont()]] sanity check fc>>=
if(fc == nil)
    goto Err;
@

<<[[readsubfont()]] sanity check f>>=
if(f == nil){
    free(fc);
    goto Err;
}
@


% why need lock before allocsubfont? because shared access
%  to lastname?
<<[[readsubfont()]] if lock part1>>=
if(dolock)
    lockdisplay(d);
@

<<[[readsubfont()]] if lock part2>>=
if(dolock)
    unlockdisplay(d);
@

\subsubsection{Writing a subfont}

% ?? -> <>, for people who wants to write new fonts?
<<function writesubfont>>=
errorneg1
writesubfont(fdt fd, Subfont *f)
{
    char hdr[3*12+1];
    byte *data;
    int nb;

    sprint(hdr, "%11d %11d %11d ", f->n, f->height, f->ascent);
    if(write(fd, hdr, 3*12) != 3*12){
    Err:
        werrstr("writesubfont: bad write: %r");
        return -1;
    }
    nb = 6*(f->n+1);
    data = malloc(nb);
    <<[[writesubfont()]] sanity check data>>
    packinfo(f->info, data, f->n);
    if(write(fd, data, nb) != nb)
        goto Err;
    free(data);
    return OK_0;
}
@
\t rename f to sf


<<[[writesubfont()]] sanity check data>>=
if(data == nil)
    return ERROR_NEG1;
@

% opposite of _unpackinfo
<<function packinfo>>=
static
void
packinfo(Fontchar *fc, uchar *p, int n)
{
    int j;

    for(j=0;  j<=n;  j++){
        p[0] = fc->x;
        p[1] = fc->x>>8;
        p[2] = fc->top;
        p[3] = fc->bottom;
        p[4] = fc->left;
        p[5] = fc->width;
        fc++;
        p += 6;
    }
}
@




\chapter{Image IO}
\label{chap:image-io}

%trans:
% seen before API calls to image IO functions:
%  - loadimage() in getdefont(), load image (subfont) in memory to kernel
%  - readimage() in readsubfont(), load image (subfont) from disk to kernel
%    (but actually first load in memory and then transfer)

% remember that loading image mean loading in the kernel! in the
% graphic server!

% could do disk IO in the kernel to avoid some memory transfer?

% Loading fonts are also about reading images.
% Those fonts have to be in the kernel like all the other images.


\section{Loading images in the display server}
% =~ readimage but from memory instead of file
% rename Loading pixels instead?

\subsection{API}

% assumes already done allocimage. Image format then is really just
% a series of words for its pixels (format specified in chan of Image).

% send multiple lines at a time. 
% note that data contain all lines one after another of rectangle
% specified in r.
% send in chunks because of buffer when write in /dev/draw/x/data
% (bufsize)

% can be used to load parts of an image (see readimage
% which calls loadimage multiple time)

% getdefont | readimage | ...  -> <>
<<function loadimage>>=
errorneg1
loadimage(Image *i, Rectangle r, byte *data, int ndata)
{
    int chunk;
    int n, bpl;
    long dy;
    <<[[loadimage()]] other locals>>

    chunk = i->display->bufsize - 64; // a little room for header

    <<[[loadimage()]] sanity check r>>
    bpl = bytesperline(r, i->depth);
    n = bpl * Dy(r);
    <<[[loadimage()]] sanity check ndata>>

    ndata = 0;
    while(r.max.y > r.min.y){
        dy = r.max.y - r.min.y;
        if(dy * bpl > chunk)
            dy = chunk / bpl;
        <<[[loadimage()]] sanity check dy>>
        n = dy * bpl;

        <<[[loadimage()]] marshall one chunk of size n with height dy>>

        ndata += n;
        data += n;
        r.min.y += dy; // progress
    }
    <<[[loadimage()]] flush and sanity check no error>>
    return ndata;
}
@

% why - 64? room for header of y message.


<<[[loadimage()]] sanity check r>>=
if(!rectinrect(r, i->r)){
    werrstr("loadimage: bad rectangle");
    return ERROR_NEG1;
}
@
%ocaml: exn

<<[[loadimage()]] sanity check ndata>>=
if(n > ndata){
    werrstr("loadimage: insufficient data");
    return ERROR_NEG1;
}
@
%ocaml: exn, and use Array.length not passed parameter ndata

<<[[loadimage()]] sanity check dy>>=
if(dy <= 0){
    werrstr("loadimage: image too wide for buffer");
    return ERROR_NEG1;
}
@


\subsection{marshalling}

% send data by writing in /dev/draw/x/data

<<[[loadimage()]] other locals>>=
byte *a;
@

<<[[loadimage()]] marshall one chunk of size n with height dy>>=
// write: 'y' id[4] R[4*4] data[x*1]
a = bufimage(i->display, 21+n);
<<[[loadimage()]] sanity check a>>
a[0] = 'y';
BPLONG(a+1, i->id);
BPLONG(a+5, r.min.x);
BPLONG(a+9, r.min.y);
BPLONG(a+13, r.max.x);
BPLONG(a+17, r.min.y + dy);
memmove(a+21, data, n);
@

% called write, cos write image in the graphics server


<<[[loadimage()]] sanity check a>>=
if(a == nil){
    werrstr("bufimage failed");
    return ERROR_NEG1;
}
@

<<[[loadimage()]] flush and sanity check no error>>=
if(flushimage(i->display, false) < 0)
    return ERROR_NEG1;
@


\subsection{Unmarshalling}

<<[[drawmesg()]] cases>>=
/* write: 'y' id[4] R[4*4] data[x*1] */
/* write from compressed data: 'Y' id[4] R[4*4] data[x*1] */
case 'y':
case 'Y':
    printmesg(fmt="LR", a, false);
    m = 1+4+4*4;
    <<[[drawmesg()]] sanity check n with m>>
    dstid = BGLONG(a+1);
    dst = drawimage(client, a+1);
    drawrectangle(&r, a+5);
    <<[[drawmesg()]] when load an image, sanity check r>>
    y = memload(dst, r, a+m, n-m, *a=='Y'); // The call
    <<[[drawmesg()]] when load an image, sanity check y>>
    dstflush(dstid, dst, r);
    m += y;
    continue;
@
%old:
%//  iprint("load %c\n", *a);

<<[[drawmesg()]] when load an image, sanity check r>>=
if(!rectinrect(r, dst->r))
    error(Ewriteoutside);
@

<<[[drawmesg()]] when load an image, sanity check y>>=
if(y < 0)
    error("bad writeimage call");
@

\subsection{Algorithm}

<<function memload>>=
errorneg1
memload(Memimage *dst, Rectangle r, byte *data, int n, bool iscompressed)
{
    errorneg1 (*loadfn)(Memimage*, Rectangle, byte*, int);
    Memlayer *dl;
    <<[[memload()]] other locals>>

    loadfn = loadmemimage;
    <<[[memload()]] if iscompressed>>

    Top:
    dl = dst->layer;
    if(dl == nil)
        return (*loadfn)(dst, r, data, n);
    // else
    <<[[memload()]] if dst has a layer>>
}
@

% a series of memmove for each line

% memload -> <> (as loadfn, loadfn = <> <- memload)
<<function loadmemimage>>=
errorneg1
loadmemimage(Memimage *i, Rectangle r, byte *data, int ndata)
{
    int l;
    int y;
    byte *q;
    int lpart = 0, rpart = 0;
    <<[[loadmemimage()]] other locals>>

    <<[[loadmemimage()]] sanity check r>>
    l = bytesperline(r, i->depth);
    <<[[loadmemimage()]] sanity check ndata>>
    ndata = l*Dy(r);

    q = byteaddr(i, r.min);

    <<[[loadmemimage()]] set mx, lpart, rpart, m for small depth images>>
    <<[[loadmemimage()]] if 1 byte per line>>

    if(lpart==0 && rpart==0){	/* easy case */
        for(y = r.min.y; y < r.max.y; y++){
            memmove(q, data, l);
            q += i->width * sizeof(ulong);
            data += l;
        }
        return ndata;
    }
    <<[[loadmemimage()]] when small depth images>>
}
@



<<[[loadmemimage()]] sanity check r>>=
if(!rectinrect(r, i->r))
    return ERROR_NEG1;
@

% a bit sad that redo some of the sanity checking done client side

<<[[loadmemimage()]] sanity check ndata>>=
if(ndata < l*Dy(r))
    return ERROR_NEG1;
@

\section{Unloading images from the display server}
% saving pixels

% read data by reading from /dev/draw/x/data!
% 2 steps, send read request by writing in /dev/draw/x/data
% and then read data from /dev/draw/x/data

\subsection{API}

% this time data is an OUT parameter

<<function unloadimage>>=
errorneg1
unloadimage(Image *i, Rectangle r, byte *data, int ndata)
{
    int bpl, dy;
    int n, ntot;
    Display *d;
    <<[[unloadimage()]] other locals>>

    <<[[unloadimage()]] sanity check r>>
    bpl = bytesperline(r, i->depth);
    <<[[unloadimage()]] sanity check ndata>>

    d = i->display;
    flushimage(d, false);	/* make sure subsequent flush is for us only */

    ntot = 0;
    while(r.min.y < r.max.y){

        dy = 8000/bpl;
        <<[[unloadimage()]] sanity check dy>>
        if(dy > Dy(r))
            dy = Dy(r);

       <<[[unloadimage()]] marshall reading request for rectangle of height dy>>

        n = read(d->fd, data + ntot, ndata - ntot);
       <<[[unloadimage()]] sanity check n>>
        ntot += n;
        r.min.y += dy; // progress
    }
    return ntot;
}
@


<<[[unloadimage()]] sanity check r>>=
if(!rectinrect(r, i->r)){
    werrstr("unloadimage: bad rectangle");
    return ERROR_NEG1;
}
@

<<[[unloadimage()]] sanity check ndata>>=
if(ndata < bpl*Dy(r)){
    werrstr("unloadimage: buffer too small");
    return ERROR_NEG1;
}
@

<<[[unloadimage()]] sanity check n>>=
if(n < 0)
    return n;
@

<<[[unloadimage()]] sanity check dy>>=
if(dy <= 0){
    werrstr("unloadimage: image too wide");
    return ERROR_NEG1;
}
@

\subsection{Marshalling}

<<[[unloadimage()]] other locals>>=
byte *a;
@

<<[[unloadimage()]] marshall reading request for rectangle of height dy>>=
// read: 'r' id[4] R[4*4]
a = bufimage(d, 1+4+4*4);
<<[[unloadimage()]] sanity check a>>
a[0] = 'r';
BPLONG(a+1, i->id);
BPLONG(a+5, r.min.x);
BPLONG(a+9, r.min.y);
BPLONG(a+13, r.max.x);
BPLONG(a+17, r.min.y+dy);
@

<<[[unloadimage()]] flush and sanity check no error>>=
if(flushimage(d, false) < 0)
    return ERROR_NEG1;
@

<<[[unloadimage()]] sanity check a>>=
if(a == nil){
    werrstr("unloadimage: %r");
    return -1;
}
@

\subsection{Unmarshalling}

<<[[drawmesg()]] cases>>=
/* read: 'r' id[4] R[4*4] */
case 'r':
    printmesg(fmt="LR", a, false);
    m = 1+4+4*4;
    <<[[drawmesg()]] sanity check n with m>>
    i = drawimage(client, a+1);
    drawrectangle(&r, a+5);
    <<[[drawmesg()]] when read an image, sanity check r>>
    c = bytesperline(r, i->depth);
    c *= Dy(r);

    free(client->readdata);
    client->readdata = mallocz(c, 0);
    <<[[drawmesg()]] when read an image, sanity check readdata>>
    client->nreaddata = memunload(i, r, client->readdata, c); // The call
    <<[[drawmesg()]] when read an image, sanity check nreaddata>>
    continue;
@



<<[[drawmesg()]] when read an image, sanity check r>>=
if(!rectinrect(r, i->r))
    error(Ereadoutside);
@

<<[[drawmesg()]] when read an image, sanity check readdata>>=
if(client->readdata == nil)
    error("readimage malloc failed");
@

<<[[drawmesg()]] when read an image, sanity check nreaddata>>=
if(client->nreaddata < 0){
    free(client->readdata);
    client->readdata = nil;
    error("bad readimage call");
}
@


<<[[Client]] other fields>>=
// array<byte> (size >= Client.nreaddata)
byte*   readdata;
int     nreaddata;
@
% so reading data involves 2 copy, first memcpy from
% image pool to Client.readdata, and then from kernel space
% to user space. See the calls to memmove in this section.

%        n = read(d->fd, data + ntot, ndata - ntot);

% put in buffer a
<<[[drawread()]] switch qid cases>>=
case Qdata:
    <<[[drawread()]] switch qid cases, when Qdata, sanity checks>>
    n = cl->nreaddata;
    memmove(a, cl->readdata, cl->nreaddata);
    free(cl->readdata);
    cl->readdata = nil;
    break;
@
% who fills readdata in the first place? memunload after.
% why set n? because drawread expects that

<<[[drawread()]] switch qid cases, when Qdata, sanity checks>>=
if(cl->readdata == nil)
    error("no draw data");
if(n < cl->nreaddata)
    error(Eshortread);
@


\subsection{Algorithm}

<<function memunload>>=
errorneg1
memunload(Memimage *src, Rectangle r, byte *data, int n)
{
    Memlayer *dl;
    <<[[memunload()]] other locals>>

    Top:
    dl = src->layer;
    if(dl == nil)
        return unloadmemimage(src, r, data, n);
    // else
    <<[[memunload()]] if src has layer>>
}
@

% data should be cl->readdata
<<function unloadmemimage>>=
errorneg1
unloadmemimage(Memimage *i, Rectangle r, byte *data, int ndata)
{
    int y, l;
    byte *q;

    <<[[unloadmemimage()]] sanity check r>>
    l = bytesperline(r, i->depth);
    <<[[unloadmemimage()]] sanity check ndata>>
    ndata = l*Dy(r);
    q = byteaddr(i, r.min);
    for(y = r.min.y; y < r.max.y; y++){
        memmove(data, q, l);
        q += i->width * sizeof(ulong);
        data += l;
    }
    return ndata;
}
@


<<[[unloadmemimage()]] sanity check r>>=
if(!rectinrect(r, i->r))
    return ERROR_NEG1;
@
<<[[unloadmemimage()]] sanity check ndata>>=
if(ndata < l*Dy(r))
    return ERROR_NEG1;
@


\section{Image format}

% image(6) format.
% A bit like format when read /dev/draw/x/ctl image spec for the format.
% get id, chan as str, rectangle, etc. Each time get number of 
% 11 chars and newline.

% different dimensions:
%  - new and old style channel format.
%  - compressed vs uncompressed.

% uncompressed new format =
%  - channel (as 12 chars)
%  - rectangle coordinates (4 times 12 characters)
%  - pixels



<<global channames>>=
static char channames[] = "rgbkamx";
@

% used when reading the first image spec from the draw new connection
% and also when readimage
% initdisplay | readimage | ... -> <>
<<function strtochan>>=
ulong
strtochan(char *s)
{
    char *p, *q;
    int t, n;
    int depth = 0;
    ulong chan = 0;

    p = s;
    while(*p && isspace(*p))
        p++;

    while(*p && !isspace(*p)){
        q = strchr(channames, p[0]);
        <<[[strtochan()]] sanity check q>>
        t = q-channames;
        <<[[strtochan()]] sanity check number after channel type>>
        n = p[1]-'0';
        depth += n;
        chan = (chan << 8) | __DC(t, n);
        p += 2;
    }
    <<[[strtochan()]] sanity check depth>>
    return chan;
}
@
% >> 
%old: d -> depth, c -> chan

<<function isspace>>=
/* avoid pulling in ctype when using with drawterm etc. */
static int
isspace(char c)
{
    return c==' ' || c== '\t' || c=='\r' || c=='\n';
}
@


<<[[strtochan()]] sanity check q>>=
if(q == nil) 
    return 0;
@
<<[[strtochan()]] sanity check number after channel type>>=
if(p[1] < '0' || p[1] > '9')
    return 0;
@

<<[[strtochan()]] sanity check depth>>=
if(depth == 0 || (depth > 8 && depth % 8) || (depth < 8 && 8 % depth))
    return 0;
@



% old format! mv in appendix? or delete? fonts still use that?
<<global drawld2chan>>=
ulong drawld2chan[] = {
    GREY1,
    GREY2,
    GREY4,

    CMAP8,
};
@
% ld for ldepth, old channel format.
% log 2 depth, so 0 = 1, 1 = 2, 3 = 4, etc.


\section{Reading images from the disk}

% will call loadimage

<<function readimage>>=
Image*
readimage(Display *d, fdt fd, bool dolock)
{
    char hdr[5*12+1]; // 5 numbers as 11 chars plus space
    ulong chan;
    Rectangle r;
    Image *i;

    int miny, maxy;
    int dy;
    uint l, n;
    int m, j, chunk;
    byte *tmp;
    <<[[readimage()]] other locals>>

    // Reading the header

    if(readn(fd, hdr, 11) != 11)
        return nil;
    <<[[readimage()]] if first 11 characters are compressed string>>
    // else
    if(readn(fd, hdr+11, 5*12-11) != 5*12-11)
        return nil;
    if(d)
        chunk = d->bufsize - 32;	/* a little room for header */
    <<[[readimage()]] set chunk if no display>>

    <<[[readimage()]] check if new or old format, set new>>
    <<[[readimage()]] sanity check hdr>>
    <<[[readimage()]] if old format>>
    else{
        hdr[11] = '\0';
        chan = strtochan(hdr);
        <<[[readimage()]] sanity check chan>>
    }

    r.min.x = atoi(hdr+1*12);
    r.min.y = atoi(hdr+2*12);
    r.max.x = atoi(hdr+3*12);
    r.max.y = atoi(hdr+4*12);
    <<[[readimage()]] sanity check r>>

    miny = r.min.y;
    maxy = r.max.y;

    // Allocating the image

    l = bytesperline(r, chantodepth(chan));
    if(d){
        <<[[readimage()]] lock display>>
        i = allocimage(d, r, chan, false, -1);
        <<[[readimage()]] unlock display>>
        <<[[readimage()]] sanity check i>>
    }
    <<[[readimage()]] alloc image if no display>>

    // Read from disk and load the image

    tmp = malloc(chunk);
    <<[[readimage()]] sanity check tmp>>

    while(maxy > miny){
        dy = maxy - miny;
        if(dy * l > chunk)
            dy = chunk/l;
        <<[[readimage()]] sanity check dy>>
        n = dy * l;

        m = readn(fd, tmp, n);

        <<[[readimage()]] sanity check m>>
        <<[[readimage()]] if old format, flip all bits>>
        if(d){
            <<[[readimage()]] lock display>>

            if(loadimage(i, Rect(r.min.x, miny, r.max.x, miny+dy), tmp, 
                         chunk) <= 0)
                goto Err1;
            <<[[readimage()]] unlock display>>
        }
        miny += dy; // progress
    }
    free(tmp);
    return i;
}
@
% a bit redundant to split in chunk; this is already handled by loadimage

<<[[readimage()]] lock display>>=
if(dolock)
    lockdisplay(d);
@

<<[[readimage()]] unlock display>>=
if(dolock)
    unlockdisplay(d);
@

% for testing code?
<<[[readimage()]] set chunk if no display>>=
else
    chunk = 8192;
@

<<[[readimage()]] alloc image if no display>>=
else{
    i = mallocz(sizeof(Image), 1);
    if(i == nil)
        return nil;
}
@



<<[[readimage()]] sanity check hdr>>=
if(hdr[11] != ' '){
    werrstr("readimage: bad format");
    return nil;
}
@

<<[[readimage()]] sanity check chan>>=
if(chan == 0){
    werrstr("readimage: bad channel string %s", hdr);
    return nil;
}
@

<<[[readimage()]] sanity check r>>=
if(r.min.x > r.max.x || r.min.y > r.max.y){
    werrstr("readimage: bad rectangle");
    return nil;
}
@

<<[[readimage()]] sanity check i>>=
if(i == nil)
    return nil;
@

<<[[readimage()]] sanity check tmp>>=
if(tmp == nil)
    goto Err;
@

<<[[readimage()]] sanity check dy>>=
if(dy <= 0){
    werrstr("readimage: image too wide for buffer");
    goto Err;
}
@

<<[[readimage()]] sanity check m>>=
if(m != n){
    werrstr("readimage: read count %d not %d: %r", m, n);
Err:
    if(dolock)
        lockdisplay(d);
Err1:
    freeimage(i);
    if(dolock)
        unlockdisplay(d);
    free(tmp);
    return nil;
}
@







\section{Writing images to the disk}

%topng </dev/screen >screen.png :) = Grab

% will call unloadimage

% actually always write in compressed format, not even a bool
%  to say whether want compression












\chapter{Input Devices}
\label{chap:input}

%trans: why talk about input in book mostly about output (Graphics)?
% because one important input, mouse, strongly related to Graphics
% (historically too).
% Actually mouse has also some output feedback: the cursor! 
% (ok can have cursor in text mode with gpm, but not the same)


% event vs thread model

\section{Mouse}

%example:
% show toy app code using mouse? which calls initmouse (non-event version)
% and then readmouse(), draw coords, and quit when middle click.

\subsection{[[/dev/mouse]] interface}

% bind("#m", "/dev")

% show kernel interface and refer to Kernel.nw

% can read /dev/mouse? yes first char code and then 5 numbers
%  using 12 chars (so readable interface!)
% e.g.
% $ cat /dev/mouse
% m xxx yyy zzz www ppp
% then move around and see update!

% can write on /dev/mouse? yes to change position, see moveto()

%trans:
% program could use directly /dev/mouse. Nice, easy.
% But then synchrone ... annoying. Need another model!

\subsection{Additional data structures}
% [[mouse.h]] interface
% user side

<<struct Mouse>>=
struct	Mouse
{
    Point	xy;
    // bitset<enum<Click>>
    int	buttons;	/* bit array: LMR=124 */

    ulong	msec;
};
@
\l same in mouse.h and event.h, could factorize chunks?

\t msec? since last time?

<<enum Click>>=
enum Click {
    CLICK_LEFT = 1,
    CLICK_MIDDLE = 2,
    CLICK_RIGHT = 4,
};
@
%pad: I introduced that
\l should use that in Windows.nw then!

% /dev/mouse and /dev/cursor handler

<<struct Mousectl>>=
struct Mousectl
{
    Mouse;

    // /dev/mouse
    fdt		mfd;		/* to mouse file */ 
    // ref_own<filename>
    char	*file; // "/dev/mouse" usually

    // ref<Image>
    Image*	image;	/* of associated window/display */

    <<[[Mousectl]] channel fields>>
    <<[[Mousectl]] IO process field>>
    <<[[Mousectl]] cursor field>>
};
@
%ctor = initmouse
%ocaml: just mfd. Also separate Mouse from Mousectl. If want
% to pass mouse information then you need to pass both a mousectl and a mouse
% update: still good design? not sure cos force to return and pass more
% stuff around
%ocaml: no image here, more explicit again in caller when call
% flush_and_read display mousectl

% Image here! so kinda depends on graphics. why need image? 
%thanks to rio-in-ocaml (and especially menu_widget.ml), discovered
% that when you read the mouse you want first the display to be uptodate
% but you dont want reach time to do Display.flush display; Mouse.receive ...
% you want the Mouse.receive to do that internally! see readmouse()


% use kencc extension above. Inline struct. See Compiler.nw book.
% kinda poor's man inheritance, so can use mc as a mouse and do
% things like mc->x, mc->buttons, no need mc->mouse->buttons.

% synchrone issue solved by plan9 concurrent model, use channel,
% so code can listen without blocking! But need trick.

<<[[Mousectl]] IO process field>>=
int		pid;	/* of slave proc */
@
% keep pid so can kill it when closemouse()
%ocaml: ocaml threads alleviate need for proc/thread, non-blocking IO

<<[[Mousectl]] channel fields>>=
// chan<Mouse> (listener = user program, sender = _ioproc(mouse.c))
Channel	*c;			/* chan(Mouse) */
@
%ocaml: typed channels!

% so code who wants to read info must
%  recv(mymc->c, &mymouseinfo)
%  and can use alt()! so non blocking. Event!
% See Libcore.nw

\subsection{Additional (user) initializations, [[initmouse()]]}

% in rio.c or trace.c: initmouse(nil, view)

% user program -> <>
<<function initmouse>>=
Mousectl*
initmouse(char *file, Image *i)
{
    Mousectl *mc;
    <<[[initmouse()]] other locals>>

    mc = mallocz(sizeof(Mousectl), true);

    <<[[initmouse()]] sanitize file>>
    mc->mfd = open(file, ORDWR|OCEXEC);
    <<[[initmouse()]] sanity check mfd>>
    mc->file = strdup(file);

    <<[[initmouse()]] set cursor field>>
    mc->image = i;
    <<[[initmouse()]] set channels>>
    <<[[initmouse()]] create process>>

    return mc;
}
@

<<[[initmouse()]] sanitize file>>=
if(file == nil)
    file = "/dev/mouse";
@





<<[[initmouse()]] sanity check mfd>>=
if(mc->mfd < 0 && strcmp(file, "/dev/mouse")==0){
    bind("#m", "/dev", MAFTER);
    mc->mfd = open(file, ORDWR|OCEXEC);
}
if(mc->mfd < 0){
    free(mc);
    return nil;
}
@


\subsection{IO process and communication channels}

% not to confuse with Color channels ...
<<[[initmouse()]] set channels>>=
mc->c       = chancreate(sizeof(Mouse), 0);
@
% =~ pipe
% 0 so no buffering?
%ocaml: typed channels!

<<[[initmouse()]] create process>>=
proccreate(_ioproc, mc, 4096);
@
%ocaml: create thread instead. threads use non-blocking IO!

% pass around mc

% "server" of mouse information.

% Why in another proc? Why not a thread? because plan9 thread lib
%  are actually blocking when doing IO (a bit like in ocaml originally?)
%  so need extra process wrapper.


<<function _ioproc (lib_graphics/libdraw/mouse.c)>>=
static
void
_ioproc(void *arg)
{
    int n, nerr;
    char buf[1+5*12]; // /dev/mouse first code char and 5 numbers
    Mouse m;
    Mousectl *mc = arg;
    <<[[_ioproc()]] other locals (mouse.c)>>
 
    threadsetname("mouseproc");
    memset(&m, 0, sizeof m);
    mc->pid = getpid();

    nerr = 0;
    for(;;){
        // blocking call
        n = read(mc->mfd, buf, sizeof buf);
        <<[[_ioproc()]] sanity check n from read (mouse.c)>>
        nerr = 0;
        switch(buf[0]){
        <<[[_ioproc()]] switch buf, resize case, fallthrough m case (mouse.c)>>
        case 'm':

            m.xy.x    = atoi(buf+1+0*12);
            m.xy.y    = atoi(buf+1+1*12);
            m.buttons = atoi(buf+1+2*12);
            m.msec    = atoi(buf+1+3*12);

            // send it!
            send(mc->c, &m);

            /*
             * mc->Mouse is updated after send so it doesn't have wrong value
             * if we block during send.
             * This means that programs should receive into mc->Mouse 
             * (see readmouse() above) if they want full synchrony.
             */
            mc->Mouse = m;
            break;
        }
    }
}
@
% so only 4 numbers? why 5*12 then?
\l comment???
%ocaml: very similar! thx to event.mli

\t this model will be used in Windows.nw a lot!



<<[[_ioproc()]] sanity check n from read (mouse.c)>>=
if(n != 1+4*12){
    yield();	/* if error is due to exiting, we'll exit here */
    fprint(2, "mouse: bad count %d not 49: %r\n", n);
    if(n<0 || ++nerr>10)
        threadexits("read error");
    continue;
}
@
% yield?
\l why 4 here and 5 before??








<<function closemouse>>=
void
closemouse(Mousectl *mc)
{
    <<[[closemouse()]] sanity check mc>>

    postnote(PNPROC, mc->pid, "kill");

    do ; while(nbrecv(mc->c, &mc->Mouse) > 0);

    close(mc->mfd);
    close(mc->cfd);
    free(mc->file);
    free(mc->c);
    free(mc->resizec);
    free(mc);
}
@

<<[[closemouse()]] sanity check mc>>=
if(mc == nil)
    return;
@
% should issue warning!


\subsection{API}

% synchrone
% for choice, use alt() with mc->c in the list of Alt.

<<function readmouse>>=
errorneg1
readmouse(Mousectl *mc)
{
    <<[[readmouse()]] flush image before reading mouse>>
    if(recv(mc->c, &mc->Mouse) < 0){
        fprint(2, "readmouse: %r\n");
        return ERROR_NEG1;
    }
    return OK_0;
}
@
%ocaml: more functional interface and typed interface! typed channel
% so can simply use Event.recv directly. It will handle errors.
% In the end most code does not check the return value!!

% info can be read then in mc->Mouse, so can actually do mc->x, mc->y, etc.

<<[[readmouse()]] flush image before reading mouse>>=
if(mc->image)
    flushimage(mc->image->display, true);
@
%ocaml: could store directly display, no need for image, but
% even more functional is to have a 'flush_and_read display mouse'
% function so more explicit that the display is flushed!

%thx to rio in ocaml I found why we need that!
% Because before you read the mouse, you want the display to be up to date!
% Otherwise force the programmer each time he calls readmouse() to
% first flush the display as he probaby has drawn things since last
% readmouse().

<<function moveto>>=
void
moveto(Mousectl *m, Point pt)
{
    fprint(m->mfd, "m%d %d", pt.x, pt.y);
    m->xy = pt;
}
@
% this is why opens in Write mode too

% ok, nothing really graphics until now, but important DS
% for next section such as Mousectl passed to setcursor.


\section{Cursor}

% Cursor is very low-level actually. This is why sometimes everything
% is frozen and the only thing that still works is the cursor
% (see swcursorclock()).

% Strong link between Graphics.nw and Kernel.nw.
% Cursor related code is here, but devmouse.c is in Kernel.nw.
% Also hard to know if software cursor are generic code.



\subsection{Additionnal data structures}

\subsubsection{[[Cursor]]}
% and [[cursor]]

%in cursor.h
<<struct Cursor>>=
struct	Cursor
{
    Point	offset;

    byte	clr[2*16];
    byte	set[2*16];
};
@
% normally a 16x16 picture
% offset??
% used kernel side (also user side to load cursor, but less important)
%coupling: clr must be before set, cos code in setcursor() assumes so.
\l graphics(2) says clr/set are bad names and instead be white/black.

% FIGURE show cursor in bigger size where can see pixels.
% actually can see that cursor arrow is black at center, white on the border
% and transparent otherwise.


% see swload to understand format.
% Can be changed! e.g., in rio when hover over border of window, 
% cursor icon changes!

% screen.h interface
% vgascreen.c (seems general enough, could be put in a generic screen.c)
<<global swcursor_arrow>>=
Cursor  swcursor_arrow = {
    .offset = { -1, -1 },
    .clr = { 
      0xFF, 0xFF, 0x80, 0x01, 0x80, 0x02, 0x80, 0x0C, 
      0x80, 0x10, 0x80, 0x10, 0x80, 0x08, 0x80, 0x04, 
      0x80, 0x02, 0x80, 0x01, 0x80, 0x02, 0x8C, 0x04, 
      0x92, 0x08, 0x91, 0x10, 0xA0, 0xA0, 0xC0, 0x40, 
    },
    .set = { 
      0x00, 0x00, 0x7F, 0xFE, 0x7F, 0xFC, 0x7F, 0xF0, 
      0x7F, 0xE0, 0x7F, 0xE0, 0x7F, 0xF0, 0x7F, 0xF8, 
      0x7F, 0xFC, 0x7F, 0xFE, 0x7F, 0xFC, 0x73, 0xF8, 
      0x61, 0xF0, 0x60, 0xE0, 0x40, 0x40, 0x00, 0x00, 
    },
};
@
% picture? format? 16x16 bitmap??
% used by??
% offset?


%screen.h,  declared in screen.h and defined in  devmouse.c
<<struct Cursorinfo>>=
struct Cursorinfo {
  Cursor;
  Lock;
};
@
% Cursor with lock, used in kernel

<<global signature cursor>>=
// devmouse.c (set in <arch>/screen.c)
extern Cursorinfo 	cursor;
@

% global cursor!! stuff do lock(&cursor)!


% See also VGAScr.Cursor

\subsubsection{Cursor rendering in software, cursor images}

% Can do cursor via software! just have cursor image,
% save image, and then draw/save appropriately!


<<global swback>>=
Memimage*   swback; /* screen under cursor */
@
% quite important!


% Grey1 version

<<global swimg1>>=
Memimage*   swimg1;
@
% should be just black color no?
<<global swmask1>>=
Memimage*   swmask1;
@
% mask of the bits of the cursor?

% why need Grey1 version too?


\subsubsection{Cursor coordinates and visibility}


<<global swpt>>=
Point   swpt;   /* desired cursor location */
@
<<global swvispt>>=
Point   swvispt;    /* actual cursor location */
@
% set by devmouse? mouse interrupt?

% used to optimize things in swcursorclock (avoid flickering?)



<<global swvers>>=
int swvers; /* incremented each time cursor image changes */
@
<<global swvisvers>>=
int swvisvers;  /* the version on the screen */
@
% changed by swload



% see swcursorclock for use of those globals

<<global swenabled>>=
bool swenabled;  /* is the cursor supposed to be on the screen? */
@
% set after cursoron() and swenable

<<global swvisible>>=
bool swvisible;  /* is the cursor visible? */
@
% set where? why it would not be visible? after swcursorhide,
%  but anyway should be followed by swcursordraw so not sure need this global.

\subsubsection{[[VGAcur]] and [[swcursor]] (x86)}

% VGAscr exposed in appendix (sad that have to introduce it here)
<<[[VGAscr]] cursor fields>>=
Cursor;
// the cursor device methods (software cursor or hardware support)
VGAcur* cur;
@
% so a scr is a cursor too ... argh, confusing I think.
\l name cursor cursor, and rename cur to curbackend?

% VGA cursor interface
<<struct VGAcur(x86)>>=
struct VGAcur {
  char* name;

  void  (*enable)(VGAscr*);
  void  (*disable)(VGAscr*);

  int   (*move)(VGAscr*, Point);

  void  (*load)(VGAscr*, Cursor*);

  // optional
  int doespanning;
};
@



<<global swcursor(x86)>>=
VGAcur swcursor =
{
    .name = "soft",

    .enable  = swenable,
    .disable = swdisable,

    .load = swload,
    .move = swmove,
};
@


\subsection{Additionnal (kernel) initializations}
\t look Raspberry, can factorize stuff in a swcursor.c? 

% who set vgascreen.cur to swcursor?

% screensize is vgascreen.c, called by aux/vga to see the size
<<[[screensize()]] initializations part2>>=
if(didswcursorinit)
    swcursorinit_wrapper();
@
% if did then redo?

<<global didswcursorinit(x86)>>=
bool didswcursorinit;
@
% if did it once that means we want to use swcursor?



% screensize | ?? -> <>
<<function swcursorinit>>=
void
swcursor_init(void)
{
    static bool init;

    if(!init){
        init = true;
        addclock0link(swcursor_clock, 10);
        swenabled = 1; //bcm: was not in pc (but maybe bug?)
    }
    <<[[swcursorinit()]] free old versions of cursor images if any>>

    swback  = allocmemimage(Rect(0,0,32,32), gscreen->chan);

    swmask  = allocmemimage(Rect(0,0,16,16), GREY8);
    swmask1 = allocmemimage(Rect(0,0,16,16), GREY1);
    swimg   = allocmemimage(Rect(0,0,16,16), GREY8);
    swimg1  = allocmemimage(Rect(0,0,16,16), GREY1);

    <<[[swcursorinit()]] sanity check cursor images>>

    memfillcolor(swmask,  DOpaque);
    memfillcolor(swmask1, DOpaque);
    memfillcolor(swimg,   DBlack);
    memfillcolor(swimg1,  DBlack);
}
@
% why 32 for swback? just to be safe? a bit ugly.

% Not sure why need to do that at resize, like for memimageinit.
% Maybe because use gscreen->chan here.


% Grey8 version

<<global swimg>>=
Memimage*   swimg;  /* cursor image */
@
<<global swmask>>=
Memimage*   swmask; /* cursor mask */
@
% initialized by swcursorinit, but set by by swload. used then
% to draw in swimg1.





<<[[swcursorinit()]] free old versions of cursor images if any>>=
if(swback){
    freememimage(swback);
    freememimage(swmask);
    freememimage(swmask1);
    freememimage(swimg);
    freememimage(swimg1);
}
@

<<[[swcursorinit()]] sanity check cursor images>>=
if(swback == nil || swmask == nil || swmask1 == nil || swimg == nil || swimg1 == nil){
    print("software cursor: allocmemimage fails");
    return;
}
@



\subsection{[[swcursorclock()]]}

% important!

% ?? -> <> (as ?? <- addlock0link(<>) <- swcursorinit
% so called at each clock interrupt 
<<function swcursorclock>>=
void
swcursor_clock(void)
{
    int x;

    if(!swenabled)
        return;
    swcursor_move(mousexy()); //bcm: only, was not in pc
    if(swvisible && eqpt(swpt, swvispt) && swvers==swvisvers)
        return;

    x = arch_splhi();
    // check again, might have changed in between
    if(swenabled)
     if(!swvisible || !eqpt(swpt, swvispt) || swvers!=swvisvers)
      if(canqlock(&drawlock)){

        swcursor_hide();
        swcursor_draw();

        qunlock(&drawlock);
    }
    arch_splx(x);
}
@
% if !swvisible?

% why not do that in devmouse interrupt? to do as few as possible
% in devmouse? to separate concerns?

% check again with splhi so sure devmouse will not change those variables?
% use canqlock otherwise deadlock!

% who changes swpt? devmouse?



<<global swrect>>=
Rectangle   swrect; /* screen rectangle in swback */
@
% why need to be a global? because used in swcursorhide after.


% swcursorclock | swenable -> <> (assumes drawlock is hold)
<<function swcursordraw>>=
void
swcursor_draw(void)
{
    bool dounlock;

    if(swvisible)
        return;
    if(!swenabled)
        return;
    if(swback == nil || swimg1 == nil || swmask1 == nil)
        return;
    dounlock = canqlock(&drawlock); //bcm:
    //assert(!canqlock(&drawlock)); // pc:

    swvispt = swpt;
    swvisvers = swvers;
    // cursor is 16x16 picture
    swrect = rectaddpt(Rect(0,0,16,16), swvispt);
    // save what is under the cursor
    memimagedraw(swback, swback->r, gscreen, swpt, memopaque, ZP, S);
    // draw cursor
    memimagedraw(gscreen, swrect, swimg1, ZP, swmask1, ZP, SoverD);
    arch_flushmemscreen(swrect);
    swvisible = true;
    //bcm:
    if(dounlock)
        qunlock(&drawlock);

}
@
% no use swimg here. dead?

% swcursorclock | (hwdraw -> swcursoravoid) -> <>
<<function swcursorhide>>=
/*
 * called with drawlock locked for us, most of the time.
 * kernel prints at inopportune times might mean we don't
 * hold the lock, but memimagedraw is now reentrant so
 * that should be okay: worst case we get cursor droppings.
 */
void
swcursor_hide(void)
{
    if(!swvisible)
        return;
    if(swback == nil)
        return;

    swvisible = false;
    // restore what was under the cursor
    memimagedraw(gscreen, swrect, swback, ZP, memopaque, ZP, S);
    arch_flushmemscreen(swrect);
}
@
% comment?

% actually called before swcursordraw while swrect has not been set
%  the very first time




\subsection{Drawing rectangles and the cursor (x86)}

% swcursorclock modifies gscreen, but what if draw operation
%  with screen as targer or source? then need restore 
%  original gscreen first, so need to call swcursorhide() first!
% (and who is gonna restore it? swcursorclock!)


<<[[hwdraw()]] if software cursor(x86)>>=
if(scr->cur == &swcursor){
    /*
     * always calling swcursorhide here doesn't cure
     * leaving cursor tracks nor failing to refresh menus
     * with the latest libmemdraw/draw.c.
     */
    if(dst->data->bdata == gscreendata.bdata)
        swcursoravoid(par->r);
    if(src->data->bdata == gscreendata.bdata)
        swcursoravoid(par->sr);
    if(mask->data->bdata == gscreendata.bdata)
        swcursoravoid(par->mr);
}
@

% if no hardware accel then no call to hwdraw, but ok?

<<function swcursoravoid>>=
void
swcursor_avoid(Rectangle r)
{
    if(swvisible && rectXrect(r, swrect))
        swcursor_hide();
}
@


\subsection{Enabling the cursor (x86)}

% screen.h interface, vgascreen.c
% ?? -> <>
<<function cursoron(x86)>>=
int
arch_cursoron(bool dolock)
{
    VGAscr *scr;
    int v;

    scr = &vgascreen;
    if(scr->cur == nil || scr->cur->move == nil)
        return 0;

    if(dolock)
        lock(&cursor);

    v = scr->cur->move(scr, mousexy());

    if(dolock)
        unlock(&cursor);

    return v;
}
@
% use of the global!
% mousexy() also part of screen.h interface, but should
% be implemented by devmouse.c or mouse.c

% screen.h interface again, vgascreen.c
% ?? -> <>
<<function cursoroff(x86)>>=
void
arch_cursoroff(int)
{
}
@
% empty? not even swcursorhide()?



% relation between cursoron and swenable?


% ?? -> <> (as xx <- swcursor.enable = <> <- xxx.c?)
<<function swenable(x86)>>=
/*
 * Need to lock drawlock for ourselves.
 */
void
swenable(VGAscr*)
{
    swenabled = true;
    if(canqlock(&drawlock)){
        swcursordraw();
        qunlock(&drawlock);
    }
}
@
% if can not qlock? just continue? without draw?

<<function swdisable(x86)>>=
void
swdisable(VGAscr*)
{
    swenabled = false;
    if(canqlock(&drawlock)){
        swcursorhide();
        qunlock(&drawlock);
    }
}
@

\subsection{Setting the cursor (x86)}

% Important that can be changed. Rio uses that.

% screen.h interface, vgascreen.c
% called from mouse.c?
% ?? -> <>
<<function ksetcursor(x86)>>=
void
arch_ksetcursor(Cursor* curs)
{
    VGAscr *scr;

    scr = &vgascreen;
    if(scr->cur == nil || scr->cur->load == nil)
        return;

    scr->cur->load(scr, curs);
}
@
% kxxx this time, cos kernel side
%old: was called setcursor


<<function swload>>=
void
swcursor_load(Cursor *curs)
{
    byte *ip, *mp;
    int i, j, set, clr;

    if(!swimg || !swmask || !swimg1 || !swmask1)
        return;
    /*
     * Build cursor image and mask.
     * Image is just the usual cursor image
     * but mask is a transparent alpha mask.
     * 
     * The 16x16x8 memimages do not have
     * padding at the end of their scan lines.
     */
    ip = byteaddr(swimg, ZP);
    mp = byteaddr(swmask, ZP);

    for(i=0; i<32; i++){
        set = curs->set[i];
        clr = curs->clr[i];
        for(j=0x80; j; j>>=1){
            *ip++ = set & j ? 0x00 : 0xFF;
            *mp++ = (clr|set) & j ? 0xFF : 0x00;
        }
    }
    swoffset = curs->offset;
    swvers++;

    memimagedraw(swimg1,  swimg1->r,  swimg,  ZP, memopaque, ZP, S);
    memimagedraw(swmask1, swmask1->r, swmask, ZP, memopaque, ZP, S);
}
@
% use of swimg outside swload? so why not make a local?
% why not directly modify swimg1? why the intermediate?


% see also adv topics section on setcursor and /dev/cursor

<<global swoffset>>=
Point   swoffset;
@

<<function swmove>>=
int
swcursor_move(Point p)
{
    swpt = addpt(p, swoffset);
    return 0;
}
@
% swpt global
% not sure why need swoffset




\subsection{[[/dev/cursor]]}

% see advanced topics


\section{Keyboard}
\n put mouse first because the mouse is more related to graphical app

% In graphical app need different model for keyboard too. 
% Dont want synchrone key reading. Can not use scanf.
% Need similar archi that for mouse, and then can
% use alt().

%related: big-bang function in racket/htdp


\subsection{[[/dev/cons]] and [[/dev/consctl]] interfaces}

% Refer to Kernel.nw
% Copy what is in Windows.nw/overview/interface/fs/keyboard ?

% first issue is that /dev/cons is buffered. when do read /dev/cons,
% get answer only after newline. Dont want that for graphical app
% where need to draw char after each type, different font, etc
% (in text mode this is handled by the kernel itself).

% so need /dev/consctl and rawon.

% but then synchronous issue like for /dev/mouse, so need again
% channels and io proc.

\subsection{Additional data structures}

<<enum Kxxx>>=
enum {
    KF=	0xF000,	/* Rune: beginning of private Unicode space */
    Spec=	0xF800,

    /* KF|1, KF|2, ..., KF|0xC is F1, F2, ..., F12 */
    Khome=	KF|0x0D,
    Kpgup=	KF|0x0F,
    Kpgdown=	KF|0x13,
    Kprint=	KF|0x10,

    Kup=	KF|0x0E,
    Kdown=	Spec|0x00,
    Kleft=	KF|0x11,
    Kright=	KF|0x12,

    Kview=	Spec|0x00,
    Kins=	KF|0x14,
    Kend=	KF|0x18,

    Kalt=	KF|0x15,
    Kshift=	KF|0x16,
    Kctl=	KF|0x17,

    Kdel=	0x7f,
    Kesc=	0x1b,
    Keof=	0x04, // C-d
    Kbs=	0x08, // C-h (backspace)
};
@
% similar to 'enum specialkey' in Kernel.nw
% note that 1-26 are C-a, C-b, ...
%todo: reorder?
%less: Kview and Kdown. Kview is used by the console, to scroll down

% similar to Mousectl
<<struct Keyboardctl>>=
struct	Keyboardctl
{
    // /dev/cons
    fdt		consfd;		/* to cons file */
    char	*file;

    // dev/consctl
    fdt		ctlfd;		/* to ctl file */

    // chan<Rune, 20> (listener = user program, sender = _ioproc(keyboard.c))
    Channel	*c;	/* chan(Rune)[20] */

    int		pid;		/* of slave proc */
};
@
% 20 so buffer of 20 Rune?

\subsection{Additional (user) initializations, [[initkeyboard()]]}

<<function initkeyboard>>=
Keyboardctl*
initkeyboard(char *file)
{
    Keyboardctl *kc;
    char *t;

    kc = mallocz(sizeof(Keyboardctl), 1);
    <<[[initkeyboard()]] sanity check kc>>

    <<[[initkeyboard()]] sanitize file>>
    kc->file = strdup(file);
    kc->consfd = open(file, ORDWR|OCEXEC);

    t = malloc(strlen(file)+16);
    <<[[initkeyboard()]] sanity check t and consfd>>
    sprint(t, "%sctl", file);
    kc->ctlfd = open(t, OWRITE|OCEXEC);
    <<[[initkeyboard()]] sanity check ctlfd>>

    if(ctlkeyboard(kc, "rawon") < 0){
        fprint(2, "initkeyboard: can't turn on raw mode on %s: %r\n", t);
        close(kc->ctlfd);
        goto Error2;
    }
    free(t);

    kc->c = chancreate(sizeof(Rune), 20);
    proccreate(_ioproc, kc, 4096);

    return kc;
}
@
\l RDWR on /dev/cons?

<<[[initkeyboard()]] sanitize file>>=
if(file == nil)
    file = "/dev/cons";
@

% initmouse | ??? -> <>
<<function ctlkeyboard>>=
int
ctlkeyboard(Keyboardctl *kc, char *m)
{
    return write(kc->ctlfd, m, strlen(m));
}
@




<<[[initkeyboard()]] sanity check kc>>=
if(kc == nil)
    return nil;
@
%ocaml: not needed, exn

<<[[initkeyboard()]] sanity check t and consfd>>=
if(kc->consfd<0 || t == nil){
Error1:
    free(kc);
    return nil;
}
@

<<[[initkeyboard()]] sanity check ctlfd>>=
if(kc->ctlfd < 0){
    fprint(2, "initkeyboard: can't open %s: %r\n", t);
Error2:
    close(kc->consfd);
    free(t);
    goto Error1;
}
@

\subsection{IO process and communication channels}

<<function _ioproc>>=
static
void
_ioproc(void *arg)
{
    Keyboardctl *kc = arg;
    int m, n;
    char buf[20];
    Rune r;

    threadsetname("kbdproc");
    kc->pid = getpid();

    n = 0;
    for(;;){
        while(n>0 && fullrune(buf, n)){
            m = chartorune(&r, buf);
            n -= m;
            memmove(buf, buf+m, n);
            // sent it!
            send(kc->c, &r);
        }
        // blocking call
        m = read(kc->consfd, buf+n, sizeof buf-n);
        <<[[_ioproc()]] sanity check m from read (keyboard.c)>>
        n += m;
    }
}
@


<<[[_ioproc()]] sanity check m from read (keyboard.c)>>=
if(m <= 0){
    yield();	/* if error is due to exiting, we'll exit here */
    fprint(2, "keyboard read error: %r\n");
    threadexits("error");
}
@

<<function closekeyboard>>=
void
closekeyboard(Keyboardctl *kc)
{
    if(kc == nil)
        return;

    postnote(PNPROC, kc->pid, "kill");
    close(kc->ctlfd);
    close(kc->consfd);
    free(kc->file);
    free(kc->c);
    free(kc);
}
@
%//#ifdef BUG
%//	/* Drain the channel */
%//	while(?kc->c)
%//		<-kc->c;
%//#endif



%\section{Events}
%  in advanced topics now and move also egetrect.c and emenuhits.c?


%\chapter{Widgets}
% now in Widgets.nw


\chapter{Overlapping Layers}
\label{chap:overlapping-windows}

% kind of window.
% but not process associated, so better use term layer, but in the end
% used for windows! by rio!
% rename allocwindow() to alloclayer?

% See \cite{pike-layers}!

% put another code orga here? desktop.c, window.c, good stuff!
% stuff in libdraw/desktop.c, and also now stuff in kernel/.../drawwindow.c

%libdraw/window.c: image "layers" (hmm but actually not transparent right now)
%libdraw/desktop.c
%kernel/devices/screen/drawwindow.c

%adapter:
% draw.c: again, memdraw(), but should be in libmemdraw/
% line.c: again! memline(), but should be only for horizontal/vert here no?
% load.c:
% unload.c:

%layerop.c

%lalloc.c: memlayer alloc
%ldelete.c: memlayer free

%lsetrefresh.c

%window operations:
% lorigin.c: mv window (or its origin)
% lhide.c: expose/hide window
% ltofront.c: back to top
% ltorear.c: put to rear






% actually Window is a bad name (see pike paper?)

% See window(2)! have even nice examples at the end.

% lib_graphics/docs/pike-bitmap.ps, with layerop(), and many
% other stuff.

% Put toy example showing use of windows, A la acme, all in one,
% where also see overlapping idea.
% What if windows is overlapped by many other windows? Tricky
% for draw operations to not overflow.

% FIGURE screenshot of result of toy example.

% Core idea is that can have overlapping independent images, can move on top,
% move on the back. It also saves the old content when overlapped.
% It manages that for you. You don't have to care. Just draw in your
% windows as usual.
% Can also have a logical coordinate system so even if window
% on the right, its upper left can still be set to Pt(0,0).

% Note that when draw anything on it, it will handle if part of the image
% is overlapped and save this part somewhere if window is put to front later
% (if use default refresh mechanism).
% It means it needs to intercept all drawing operations.

%alt: or it could draw everything on save image, and this save image
% could be paint back on the main screen (in the right order of windows).
% that would remove lots of code. Does not even have to do the
% coordinate translation each time as save use the logical coordinates.
% In fact Lisp Machine was doing that, "shadow bitmap" and pike called
% his layerop an optimization of this shadow bitmap technique.

% Not only the windowing system can use windows. Acme uses windows.
% But of course this is a big building block for windowing system.

% What we have seen was already very complicated, lots of architecture layers,
% wrapper data structures. A real onion.
% Here is another one :) Windows and Desktops (Screen).

%alt: in X11 no shadow bitmap, it is responsibility of programs to repaint
% possibly to optimize by repainting only subareas,
% possibly to remove other expose event, ... this
% complicates client programs

% See Sundew paper, good principle says to not bother client with that!
% that memory is cheap now, can have shadow bitmap!


\section{Additional data structures}

\subsection{Base layer, [[Screen]] (and [[Memscreen]])}
\n use BaseLayer, more consistent with Photoshop, and base image gives
\n  idea that it is an image when really it is another data structure.

\subsubsection{[[Screen]]}

% to create windows, first need Desktop(Screen) holding them all.
% Screen factorize for all windows the target image and filling image.

% The id field allows to sync with similar structure in kernel.

% ctor = allocscreen | publicscreen
<<struct Screen>>=
struct Screen
{
    Display	*display;	/* display holding data */
    int		id;			/* id of system-held Screen */

    Image	*image;		/* unused; for reference only */
    Image	*fill;		/* color to paint behind windows */
};
@
% unused in user space yes. fill also unused?
%todo: rename? Confusing with Vga screen, screeimage, etc.
% maybe Desktop? After all that's the term Macos uses, with also the
% notion of virtual desktops. You have a desktop where you can put
% papers, papers which can overlap on the desktop.
%update: rename BaseLayer?

% display not redundant with Screen.fill.display? 
% yes, but because we dont need the fill (the information is stored 
% server-side), the only thing we need is really the display to communicate
% with the server.

\subsubsection{[[DScreen]]}

% kernel side, D for Draw (device).
% A bit like DImage for Image but here for Screen.

<<struct DScreen>>=
struct DScreen
{
    int     id;

    DImage      *dimage;
    DImage      *dfill;

    <<[[DScreen]] other fields>>

    // Extra
    int     ref;
    <<[[DScreen]] extra fields>>
};
@
% DImage screen
% ref here! cos can be made public and shared 

<<[[DScreen]] other fields>>=
bool     public;
@
% could mv in rio chapter.


<<global dscreen>>=
// list<ref<DScreen>> (next = DScreen.next)
static  DScreen*    dscreen;
@
% for publicscreen all public screens are shared and so stored globally
% in dscreen

<<[[DScreen]] extra fields>>=
// list<ref<DScreen>> (head = dscreen)
DScreen*    next;
@

% drawmesg (public screen) -> <>
<<function drawlookupdscreen>>=
DScreen*
drawlookupdscreen(int id)
{
    DScreen *s;

    s = dscreen;
    while(s){
        if(s->id == id)
            return s;
        s = s->next;
    }
    return nil;
}
@



\subsubsection{[[CScreen]]}
\l CDesktop

% one client can have multiple screens, so need lookup screen id
% so need list of those screens.
% (a client can create a subdesktop inside its desktop!).

% CScreen = Client screens

<<[[Client]] layer fields>>=
// list<ref_own<DScreen>> (next = CScreen.next)
CScreen*    cscreen;
@
% a bit like DImage hash, but here it's simply a list.
% probably because in practice a client has only one screen.
% Faster than dscreen big list.

% ctor = drawinstallscreen
<<struct CScreen>>=
struct CScreen
{
    // ref_shared<DScreen>
    DScreen*    dscreen;

    CScreen*    next;
};
@
%alt: could have embed that in DScreen itself, have a nextbis field.



% drawmesg (free screen) | drawmesg (allocate window) -> <>
<<function drawlookupscreen>>=
DScreen*
drawlookupscreen(Client *client, int id, CScreen **cs)
{
    CScreen *s;

    s = client->cscreen;
    while(s){
        if(s->dscreen->id == id){
            *cs = s;
            return s->dscreen;
        }
        s = s->next;
    }
    error(Enodrawscreen);
    return nil;
}
@




<<[[DScreen]] other fields>>=
Client*     owner;
@
% when private screen apparently the same client can access it too, but
% then need this information stored in the DScreen.
\l could delete I think, weird to allow use-public-screen message on
\l  non-public screen


\subsubsection{[[Memscreen]]}

% kernel independent. no id here.

<<[[DScreen]] other fields>>=
// ref_own<Memscreen>
Memscreen*  screen;
@

% why another DS? why not merge in DScreen? because of libmemdraw
% to be independent of kernel. In fact acme probably uses memscreen directly
% and no DScreen.

<<struct Memscreen>>=
struct Memscreen
{
    Memimage	*image;		/* upon which all layers are drawn */
    Memimage	*fill;		/* if non-zero, picture to use when repainting */

    <<[[Memscreen]] stack windows fields>>
};
@
% The image and fill seems redundant with same DScreen field, but
%  again it's because of kernel independence.
% Maybe the kernel one could be removed?

% Memscreen.image->data will be shared among all windows,
% with a different rectangle part each time.



\subsection{Layer (and [[Memlayer]])}

% Windows are images! They just have a few more operations available to
% them. But they need to be connected to a desktop.

<<[[Image]] layer fields>>=
Screen		*screen;	/* nil if not a window */
@
\t dead? seems used only in freeimage, and mostly to
\t  maintain Display.windows which itself seems dead
\t so information useful only server-side I think

<<[[DImage]] layer fields>>=
DScreen*    dscreen;    /* nil if not a window */
@
% seems redundant with Memimage.screen, but here it's a DScreen
%  not a kernel independent Memscreen.

% Actually for DImage got by name, the dscreen field will
% not be set because of nil passed below:
%    if(drawinstall(client, dstid, dn->dimage->image, nil) == 0)
% but the underlying memimage will have its layer and screen set.


\subsubsection{[[Memlayer]]}

% Could have also a 
% <<[[Memimage]] layer fields>>=
% Memscreen* *mscreen;
% but instead it's done in the Memlayer intermediate structure
%  with more info.


<<[[MemImage]] layer fields>>=
// ref_own<Memlayer>
Memlayer	*layer;	/* nil if not a layer*/
@
% why call that layer? cos additional layer when do draw operation
% on them? to translate, clip, save, etc.

% additional info on image related to window management.

% ref to Memscreen below so will share pixel data of screen.image!
% Also will give access to other windows in this Screen, which will
% be needed when move around this window, to obscure/save and expose
% other windows.

% can move around the window on the desktop/screen image via screenr.
% can move its origin via delta.

% Memlayer is really an adapter to a shared Memdata.
% The Memimage of a window will be similar to the underlying full screen
%  image but thx to the layer link draw operation will know which
%  actual part of the shared full screen image to touch.

<<struct Memlayer>>=
struct Memlayer
{
    Rectangle		screenr;	/* true position of layer on screen */
    Point			delta;	/* add delta to go from image coords to screen */

    // ref<Memscreen>
    Memscreen	*screen;	/* screen this layer belongs to */

    // ref_own<Memimage> (in image coords)
    Memimage	*save;	/* save area for obscured parts */


    <<[[Memlayer]] stack windows fields>>
    <<[[Memlayer]] refresh fields>>
    <<[[Memlayer]] other fields>>
};
@
%alt: have the Memimage be the save image, with the data of the save
% image, instead of the data to the full screen image, and then after
% each draw op copy from save to full screen (found in Memscreen).
% Need clipping though, and because of arbitrary overlap, can not just
% have one rectangle, but could have a list of rectangles, or simply
% each time redraw as a painter.

%alt: could use screen coord for save too, would save conversion
% issues back and forth in memlayerop and memdraw

% Memlayer.screenr different from Memimage.r?

<<[[Memlayer]] other fields>>=
bool		clear;	/* layer is fully visible */
@
% what need clear for? optimisations, to know if need to get
%  pixels from save or not. When fully visible then things are
%  simpler

%alt: [[save]] saves only the obscured parts. Maybe an alternative would
% be for [[save]] to contain everything, and each time there is an update
% to copy accordingly [[save]] to the main screen in a painter fashion
% (last stuff painted overwrite previous stuff).
% Might be slower, but far more simpler than what they do where
% they really optimise and draw only what is necessary. Even the background
% is rendered on demand when a window disappear. 


%\subsubsection{Summary}

% FIGURE where could see in // the 3 universe, Image, DImage, Memimage
%  and also Screen, DScreen, Memscreen, and the pointers in both
%  directions each time.




\subsubsection{[[Display.windows]]}

%dead:
<<[[Display]] other fields>>=
// list<ref<Window>> (next = Image.next)
Image	*windows;
@
<<[[Image]] extra fields>>=
Image		*next;	/* next in list of windows */
@

\t I think it's dead, no need that, it's maintained in allocwindow
\t  and freeimage but nobody is using those fields then.


\subsection{Layer stack}

% double linked list of windows.

<<[[Memscreen]] stack windows fields>>=
// list<ref<Memimage>> (next = Memimage.layer->rear)
Memimage	*frontmost;	/* frontmost layer on screen */
// list<ref<Memimage>> (next = Memimage.layer->front)
Memimage	*rearmost;	/* rearmost layer on screen */
@


<<[[Memlayer]] stack windows fields>>=
Memimage	*front;	/* window in front of this one */
Memimage	*rear;	/* window behind this one*/
@

% remember that each Memlayer has a ref to Memscreen and so has
% access to the other windows, which will be needed when move around
% this Memlayer/window, to hide(save)/expose(restore) other windows.

\section{Base layer allocation}

\subsection{API}

% gengetwindow -> <>
% ctor
<<function allocscreen>>=
Screen*
allocscreen(Image *image, Image *fill, bool public)
{
    Display *d;
    Screen *s;
    int id, try;
    byte *a;

    d = image->display;
    <<[[allocscreen()]] sanity check images have same display>>
    s = malloc(sizeof(Screen));
    <<[[allocscreen()]] sanity check s>>
    SET(id);
    for(try=0; try<25; try++){
        /* loop until find a free id */
        <<[[allocscreen()]] marshall allocate screen message>>
    }
    s->display = d;
    s->id = id;
    s->image = image;
    s->fill = fill;
    <<[[allocscreen()]] sanity check screen image>>
    return s;
}
@

% multiple try because screen id can be public and screen
% can be accessible to other processes, so we need to find
% an id not used by another process.

% Note that each graphical app running under rio calls gengetwindow
% which allocates a screen each time! so can not have more than
% 25 graphical windows at the same time.

<<[[allocscreen()]] sanity check images have same display>>=
if(d != fill->display){
    werrstr("allocscreen: image and fill on different displays");
    return nil;
}
@

<<[[allocscreen()]] sanity check s>>=
if(s == nil)
    return nil;
@
%ocaml: exn

<<[[allocscreen()]] sanity check screen image>>=
assert(s->image && s->image->chan != 0);
@






<<function freescreen>>=
errorneg1
freescreen(Screen *s)
{
    Display *d;
    byte *a;

    <<[[freescreen()]] sanity check s>>
    d = s->display;
    <<[[freescreen()]] marshall free screen message>>
    free(s);
    return OK_1;
}
@

<<[[freescreen()]] sanity check s>>=
if(s == nil)
    return 0;
@
% should raise warning







% function to access a screen created by allocscreen which was public
% (or private but with same client)
% could mv in rio chapter?
<<function publicscreen>>=
Screen*
publicscreen(Display *d, int id, ulong chan)
{
    Screen *s;
    byte *a;

    s = malloc(sizeof(Screen));
    <<[[publicscreen()]] sanity check s>>

    <<[[publicscreen()]] marshall use public screen message>>

    s->display = d;
    s->id = id;

    s->image = nil;
    s->fill = nil;

    return s;
}
@
% do not have image and fill info client side, but the info will be there
% kernel side. Anyway it was there for reference only.
\l hmm actually useful to know the chan, but chan is passed here
\l  so maybe could stored it in the Screen instead of using
\l  d->screenimage->chan?


<<[[publicscreen()]] sanity check s>>=
if(s == nil)
    return nil;
@


\subsection{Marshalling}

<<global screenid>>=
static int	screenid;
@

<<[[allocscreen()]] marshall allocate screen message>>=
// allocate screen: 'A' id[4] imageid[4] fillid[4] public[1]
a = bufimage(d, 1+4+4+4+1);
<<[[allocscreen()]] sanity check a>>
id = ++screenid;
a[0] = 'A';
BPLONG(a+1, id);
BPLONG(a+5, image->id);
BPLONG(a+9, fill->id);
a[13] = public;
if(flushimage(d, false) != -1)
    break;
@

<<[[allocscreen()]] sanity check a>>=
if(a == nil){
    free(s);
    return nil;
}
@
%ocaml: exn



<<[[freescreen()]] marshall free screen message>>=
// free screen: 'F' id[4]
a = bufimage(d, 1+4);
<<[[freescreen()]] sanity check a>>
a[0] = 'F';
BPLONG(a+1, s->id);
/*
 * flush(true) because screen is likely holding last reference to
 * window, and want it to disappear visually.
 */
if(flushimage(d, true) < 0)
    return ERROR_NEG1;
@



<<[[freescreen()]] sanity check a>>=
if(a == nil)
    return ERROR_NEG1;
@





<<[[publicscreen()]] marshall use public screen message>>=
// use public screen: 'S' id[4] chan[4]
a = bufimage(d, 1+4+4);
<<[[publicscreen()]] sanity check a>>
a[0] = 'S';
BPLONG(a+1, id);
BPLONG(a+5, chan);
if(flushimage(d, false) < 0)
    goto Error;
@


<<[[publicscreen()]] sanity check a>>=
if(a == nil){
Error:
    free(s);
    return nil;
}
@


\subsection{Unmarshalling}

<<[[drawmesg()]] locals>>=
DImage *dsrc;
@

<<[[drawmesg()]] cases>>=
/* allocate screen: 'A' id[4] imageid[4] fillid[4] public[1] */
case 'A':
    printmesg(fmt="LLLb", a, false);
    m = 1+4+4+4+1;
    <<[[drawmesg()]] sanity check n with m>>
    dstid = BGLONG(a+1);
    <<[[drawmesg()]] when allocate screen, sanity check dstid>>
    ddst = drawlookup(client, BGLONG(a+5), true);
    dsrc = drawlookup(client, BGLONG(a+9), true);
    <<[[drawmesg()]] when allocate screen, sanity check ddst and dsrc>>

    if(drawinstallscreen(client, nil, dstid, ddst, dsrc, a[13]) == 0)// The call
        error(Edrawmem);
    continue;

@
%old: was passing true to printmesg

% Note that normal if some calls to allocate screen fail because
% of the counter and retry approach in allocscreen()

<<[[drawmesg()]] when allocate screen, sanity check dstid>>=
if(dstid == 0)
    error(Ebadarg);
if(drawlookupdscreen(dstid))
    error(Escreenexists);
@
% id screen is global so use global drawlookupdscreen lookup.

<<[[drawmesg()]] when allocate screen, sanity check ddst and dsrc>>=
if(ddst==nil || dsrc==nil)
    error(Enodrawimage);
@




<<[[drawmesg()]] locals>>=
CScreen *cs;
@

<<[[drawmesg()]] cases>>=
/* free screen: 'F' id[4] */
case 'F':
    printmesg(fmt="L", a, false);
    m = 1+4;
    <<[[drawmesg()]] sanity check n with m>>
    drawlookupscreen(client, BGLONG(a+1), &cs);
    drawuninstallscreen(client, cs); // The call
    continue;

@
%old: was passing true to printmesg



<<[[drawmesg()]] locals>>=
DScreen *dscrn;
@


<<[[drawmesg()]] cases>>=
/* use public screen: 'S' id[4] chan[4] */
case 'S':
    printmesg(fmt="Ll", a, false);
    m = 1+4+4;
    <<[[drawmesg()]] sanity check n with m>>
    dstid = BGLONG(a+1);
    <<[[drawmesg()]] when use public screen, sanity check dstid>>
    dscrn = drawlookupdscreen(dstid);
    <<[[drawmesg()]] when use public screen, sanity check dscrn>>
    if(drawinstallscreen(client, dscrn, 0, nil, nil, false) == 0) // The call
        error(Edrawmem);
    continue;
@




<<[[drawmesg()]] when use public screen, sanity check dstid>>=
if(dstid == 0)
    error(Ebadarg);
@

<<[[drawmesg()]] when use public screen, sanity check dscrn>>=
if(dscrn == nil || (!dscrn->public && dscrn->owner != client))
    error(Enodrawscreen);
if(dscrn->screen->image->chan != BGLONG(a+5))
    error("inconsistent chan");
@
% check same owner when private screen. Not sure why allow 
% a use public screen on a private screen ...

%\subsection{Algorithm}
% no really algorithm, it's just about malloc.

\subsection{[[Client]] and [[Memscreen]] connection, [[CScreen]]}

% a bit like drawinstall which installs an image, except here it's a screen.
% replaced CScreen list with Dimage hash in client.

% pass existing DScreen when publicscreen (but 0 id) and nil when allocscreen

% ctor Memscreen
<<function drawinstallscreen>>=
Memscreen*
drawinstallscreen(Client *client, DScreen *d, int id, DImage *dimage, DImage *dfill, bool public)
{
    Memscreen *s;
    CScreen *c;

    c = malloc(sizeof(CScreen));
    <<[[drawinstallscreen()]] sanity check dimage>>
    <<[[drawinstallscreen()]] sanity check c>>

    if(d == nil){
        d = malloc(sizeof(DScreen));
        <<[[drawinstallscreen()]] sanity check d>>
        s = malloc(sizeof(Memscreen));
        <<[[drawinstallscreen()]] sanity check s>>

        d->id = id;
        d->dimage = dimage;
        d->dfill = dfill;

        d->screen = s;
        if(dimage){
            s->image = dimage->image;
            dimage->ref++;
        }
        if(dfill){
            s->fill = dfill->image;
            dfill->ref++;
        }
        // no windows yet
        s->frontmost = nil;
        s->rearmost = nil;

        d->public = public;
        d->owner = client;
        d->ref = 0;

        // add_list(d, dscreen)
        d->next = dscreen;
        dscreen = d;
    }

    c->dscreen = d;
    d->ref++;

    // add_list(c, client->cscreen)
    c->next = client->cscreen;
    client->cscreen = c;

    return d->screen;
}
@
% ref++ because screen can be shared, when use public screen.

<<[[drawinstallscreen()]] sanity check dimage>>=
if(dimage && dimage->image && dimage->image->chan == 0)
    panic("bad image %p in drawinstallscreen", dimage->image);
@
<<[[drawinstallscreen()]] sanity check c>>=
if(c == nil)
    return nil;
@
<<[[drawinstallscreen()]] sanity check d>>=
if(d == nil){
    free(c);
    return nil;
}
@
<<[[drawinstallscreen()]] sanity check s>>=
if(s == nil){
    free(c);
    free(d);
    return nil;
}
@




<<[[drawclose()]] free screens>>=
while(cl->cscreen)
    drawuninstallscreen(cl, cl->cscreen);
@
% drawclose then free all dimages (and so the windows)


% drawmesg(free screen) | drawclose -> <>
% free cscreen
<<function drawuninstallscreen>>=
void
drawuninstallscreen(Client *client, CScreen *this)
{
    CScreen *cs, *next;

    // remove_list(this, client->cscreen)
    cs = client->cscreen;
    if(cs == this){
        client->cscreen = this->next;

        drawfreedscreen(this->dscreen);
        free(this);
        return;
    }
    while(next = cs->next){ /* assign = */
        if(next == this){
            cs->next = this->next;
     
            drawfreedscreen(this->dscreen);
            free(this);
            return;
        }
        cs = next;
    }
}
@

% free dscreen
% drawuninstallscreen | drawfreedimage -> <>
<<function drawfreedscreen>>=
void
drawfreedscreen(DScreen *this)
{
    DScreen *ds, *next;

    this->ref--;
    <<[[drawfreedscreen()]] sanity check reference count>>
    if(this->ref > 0)
        return;
    // else

    // remove_list(this, dscreen)
    ds = dscreen;
    if(ds == this){
        dscreen = this->next;
        goto Found;
    }
    while(next = ds->next){ /* assign = */
        if(next == this){
            ds->next = this->next;
            goto Found;
        }
        ds = next;
    }
    error(Enodrawimage);

    Found:
    if(this->dimage)
        drawfreedimage(this->dimage);
    if(this->dfill)
        drawfreedimage(this->dfill);
    free(this->screen);
    free(this);
}
@
% no shared Memscreen, ref_own

% does not free the windows? leak? if abrupt process attached
% to /dev/draw/x/ dies? drawclose? enough?
% windows are images, and drawclose actually free all DImage
% see the comment in drawclose:
%  /* all screens are freed, so now we can free images */


<<[[drawfreedscreen()]] sanity check reference count>>=
if(this->ref < 0)
    print("negative ref in drawfreedscreen\n");
@






\section{Layers creation}

% A window is an Image! It just needs to be connected to a Screen/Desktop

% Window really a special kind of Memimage with logical coord
% over underlying shared big image and save image. 


\subsection{API}

<<function allocwindow>>=
Image*
allocwindow(Screen *s, Rectangle r, int ref, rgba val)
{
    return _allocwindow(nil, s, r, ref, val);
}
@
% A screen is first a target image. Allocate a window is allocate
% a subimage of this target image. No need chan here as use same chan
% than image in Screen.

% ever call _allocwindow with non nil Image? Yes! in gengetwindow()
%  if got a resize and so call gengetwindow another time, in which
%  case view would have been set already so no need to malloc again
%  the Image.

<<function _allocwindow>>=
Image*
_allocwindow(Image *i, Screen *s, Rectangle r, int ref, rgba val)
{
    Display *d;

    d = s->display;
    i = _allocimage(i, d, r, d->screenimage->chan, false, val, s->id, ref);
    <<[[_allocwindow()]] sanity check i>>

    i->screen = s;
    // add_list(i, display->windows)
    i->next = s->display->windows;
    s->display->windows = i;

    return i;
}
@
%ocaml: realloc when pass already an image?

% repl set to false.

% call _allocimage, but this time passing a screen id!

% screenimage set in gengetwindow, later.
\l but why not use s->image->chan instead? because not there
\l  when use public screen ... so maybe should have a Screen.chan field?
\l but then why not d->image->chan?

<<[[_allocwindow()]] sanity check i>>=
if(i == nil)
    return nil;
@



% a window is an image, it is freeed by freeimage (which calls _freeimage1)
<<[[_freeimage1()]] if screen>>=
if(i->screen){
    // remove_list(i, d->windows)
    w = d->windows;
    if(w == i)
        d->windows = i->next;
    else
        while(w){
            if(w->next == i){
                w->next = i->next;
                break;
            }
            w = w->next;
        }
}
@
\l this is dead actually I think, noone use those fields

%\subsection{Marshalling}
% done in _allocimage, main diff is pass screen id and refresh.

\subsection{Unmarshalling}

<<[[drawmesg()]] locals>>=
Memscreen *scrn;
Memimage *l;
@


<<[[drawmesg()]] allocate image case, if screen id>>=
if(scrnid){
    dscrn = drawlookupscreen(client, scrnid, &cs);
    scrn = dscrn->screen;
    <<[[drawmesg()]] when allocate window, sanity check repl and chan>>
    <<[[drawmesg()]] when allocate window, set reffn>>
    l = memlalloc(scrn, r, reffn, nil, value); // The call
    <<[[drawmesg()]] when allocate window, sanity check l>>
    <<[[drawmesg()]] when allocate window, addflush>>

    // similar to regular allocate image case
    l->clipr = clipr;
    rectclip(&l->clipr, r);

    if(drawinstall(client, dstid, l, dscrn) == 0){
        memldelete(l);
        error(Edrawmem);
    }
    dscrn->ref++;

    <<[[drawmesg()]] when allocate window, if reffn>>
    continue;
}
@
% a window depends on a screen hence the ref++

<<[[drawmesg()]] when allocate window, sanity check repl and chan>>=
if(repl || chan != scrn->image->chan)
    error("image parameters incompatible with screen");
@

<<[[drawmesg()]] when allocate window, sanity check l>>=
if(l == nil)
    error(Edrawmem);
@



% also here unmarshall code when free image, which will call
% drawuninstall (which will call drawfreedimage which calls memldelete)

\subsection{Algorithm}

% ctor Memlayer
% return a Memimage! (with attached layer)
<<function memlalloc>>=
Memimage*
memlalloc(Memscreen *s, Rectangle screenr, Refreshfn refreshfn, void *refreshptr, rgba val)
{
    Memimage *n;
    Memlayer *l;
    <<[[memlalloc()]] other locals>>

    <<[[memlalloc()]] set paint once>>

    // share pixels data with screen image
    n = allocmemimaged(screenr, s->image->chan, s->image->data);
    <<[[memlalloc()]] sanity check n>>
    // overwrite zero and width derived from screenr in allocmemimaged
    // because the rectangle here does not match the data, it's a
    // subrectangle. Zero and width should remain the same.
    n->zero = s->image->zero;
    n->width = s->image->width;

    l = malloc(sizeof(Memlayer));
    <<[[memlalloc()]] sanity check l>>

    l->screen = s;
    l->screenr = screenr;
    l->delta = Pt(0,0); // can be changed later by originwindow()
    l->clear = false;
    <<[[memlalloc()]] allocate save image>>

    n->layer = l;
    // ok no more sanity check, we can make the connection
    n->data->ref++;

    <<[[memlalloc()]] set refresh fields part1>>
    <<[[memlalloc()]] manage stack of windows>>
    <<[[memlalloc()]] set refresh fields part2>>

    <<[[memlalloc()]] paint with requested color>>
    return n;
}
@
%old: I put the setting of n field closer to the call to allocmemimaged
\t rename n to i or mi

% refreshptr != nil sometimes? in rio?


<<[[memlalloc()]] allocate save image>>=
<<[[memlalloc()]] if refreshfn>>
else{
    l->save = allocmemimage(screenr, s->image->chan);
    <<[[memlalloc()]] sanity check l save>>
    /* allocmemimage doesn't initialize memory; this paints save area */
    if(val != DNofill)
        memfillcolor(l->save, val);
}
@
% why need fill save? anyway will fill with paint the whole window.


<<[[memlalloc()]] manage stack of windows>>=
/* start with new window behind all existing ones */

// add_end_double_list(l, s->frontmost, s->rearmost)
l->front = s->rearmost;
l->rear = nil;
if(s->rearmost)
    s->rearmost->layer->rear = n;
s->rearmost = n;
if(s->frontmost == nil)
    s->frontmost = n;

/* now pull new window to front */
_memltofrontfill(n, val != DNofill);
@
%old: used to set l->clear = false; here but more consistent I think
% to do it before

% see _memltofrontfill later, but this will gradually
% save the obscured part by this new window of all other windows.

% put at the very end first, to respect invariant, 
% and then put at top so will trigger the hide of every windows
% now under.



<<[[memlalloc()]] other locals>>=
static Memimage *paint;
@
<<[[memlalloc()]] set paint once>>=
if(paint == nil){
    paint = allocmemimage(Rect(0,0,1,1), RGBA32);
    <<[[memlalloc()]] sanity check paint>>
    paint->flags |= Frepl;
    paint->clipr = Rect(-0x3FFFFFF, -0x3FFFFFF, 0x3FFFFFF, 0x3FFFFFF);
}
@

<<[[memlalloc()]] paint with requested color>>=
/*
 * paint with requested color; previously exposed areas are already right
 * if this window has backing store, but just painting the whole thing is simplest.
 */
if(val != DNofill){
    memsetchan(paint, n->chan);
    memfillcolor(paint, val);
    memdraw(n, n->r, paint, n->r.min, nil, n->r.min, S);
}
@
% can change chan of existing image? should assert chantodepth(n->chan)
%  compatible or less than the depth of RGBA32.




<<[[memlalloc()]] sanity check n>>=
if(n == nil)
    return nil;
@
<<[[memlalloc()]] sanity check l>>=
if(l == nil){
    free(n);
    return nil;
}
@
<<[[memlalloc()]] sanity check l save>>=
if(l->save == nil){
    free(l);
    free(n);
    return nil;
}
@
<<[[memlalloc()]] sanity check paint>>=
if(paint == nil)
    return nil;
@





% call when error, call when free dimage in next section
% drawmesg (allocate window) | freedimage (below) -> <>
<<function memldelete>>=
void
memldelete(Memimage *i)
{
    Memlayer *l;
    Memscreen *s;

    l = i->layer;
    s = i->layer->screen;

    /* free backing store and disconnect refresh, to make pushback fast */
    freememimage(l->save);
    l->save = nil;
    l->refreshptr = nil;
    memltorear(i);

    /* window is now the rearmost;  clean up screen structures and deallocate */

    if(s->fill){
        i->clipr = i->r;
        memdraw(i, i->r, s->fill, i->r.min, nil, i->r.min, S);
    }
    <<[[memldelete()]] manage stack of windows>>

    free(l);
    freememimage(i);
}
@
%old: put s initialization earlier

<<[[memldelete()]] manage stack of windows>>=
// remove_double_list(l, s->frontmost, s->rearmost)
if(l->front){
    l->front->layer->rear = nil;
    s->rearmost = l->front;
}else{
    s->frontmost = nil;
    s->rearmost = nil;
}
@





\subsection{[[Client]] and [[Memimage]] connection, [[DImage]]}
% part2

% see call to drawinstall above. drawinstall connect a memimage and a client.
% drawmesg(allocate) -> <>
<<[[drawinstall()]] install dscreen>>=
d->dscreen = dscreen;
@
% so create connection too between client and DScreen via DImage.
% (after having done connection between Memimage and Memlayer and Memscreen)


% drawclose | drawuninstall -> <>
<<[[drawfreedimage()]] if dscreen>>=
ds = dimage->dscreen;
if(ds){
    l = dimage->image;
    <<[[drawfreedimage()]] addflush>>
    <<[[drawfreedimage()]] free refreshptr>>

    if(drawgoodname(dimage))
        memldelete(l);
    else
        memlfree(l);

    drawfreedscreen(ds); // one less reference
}
@

% See "Naming and sharing (and windows)" section for drawgoodname.
% But basically if not shared image, or if shared image
%  and up to data, then we must do the effect on the screen.
% Otherwise, if shared image and not up to date, then just free the
%  structure.


<<[[drawgoodname()]] if DImage [[d]] is a window>>=
/* if window, validate the screen's own images */
if(d->dscreen)
    if(!drawgoodname(d->dscreen->dimage)
    || !drawgoodname(d->dscreen->dfill))
        return false;
@


% simpler version, which does not do the windows stack handling
% drawfreedimage (when not goodname) -> <>
<<function memlfree>>=
/*
 * Just free the data structures, don't do graphics
 */
void
memlfree(Memimage *i)
{
    Memlayer *l;

    l = i->layer;
    freememimage(l->save);
    free(l);
    freememimage(i);
}
@



\section{Layer stack manipulation}

\subsection{API}

<<function topwindow>>=
void
topwindow(Image *w)
{
    <<[[xxxmwindow()]] sanity check window w>>
    topbottom(&w, 1, true);
}
@

<<function bottomwindow>>=
void
bottomwindow(Image *w)
{
    <<[[xxxmwindow()]] sanity check window w>>
    topbottom(&w, 1, false);
}
@

<<function topnwindows>>=
void
topnwindows(Image **w, int n)
{
    topbottom(w, n, true);
}
@
%ocaml: need this generality?

<<function bottomnwindows>>=
void
bottomnwindows(Image **w, int n)
{
    topbottom(w, n, false);
}
@





<<[[xxxmwindow()]] sanity check window w>>=
if(w->screen == nil)
    return;
@
%ocaml: exn

\subsection{Marshalling}

<<function topbottom>>=
static
void
topbottom(Image **w, int n, bool top)
{
    int i;
    byte *b;
    Display *d;

    <<[[topbottom()]] sanity check n>>
    <<[[topbottom()]] sanity check images have same display>>

    // top or bottom windows: 't' top[1] nw[2] n*id[4]
    b = bufimage(d, 1+1+2+4*n);
    b[0] = 't';
    b[1] = top;
    BPSHORT(b+2, n);
    for(i=0; i<n; i++)
        BPLONG(b+4+4*i, w[i]->id);
}
@
%dead: redundant with code already doing that before
%    if(n==0)
%        return;
\l forgot bufimage b sanity check


<<[[topbottom()]] sanity check n>>=
if(n < 0){
Ridiculous:
    fprint(2, "top/bottom: ridiculous number of windows\n");
    return;
}
if(n == 0)
    return;
if(n > (w[0]->display->bufsize - 100)/4)
    goto Ridiculous;
@
% last check? because will pass one BPLONG per window, and -100 is for header

<<[[topbottom()]] sanity check images have same display>>=
/*
 * this used to check that all images were on the same screen.
 * we don't know the screen associated with images we acquired
 * by name.  instead, check that all images are on the same display.
 * the display will check that they are all on the same screen.
 */
d = w[0]->display;
for(i=1; i<n; i++)
    if(w[i]->display != d){
        fprint(2, "top/bottom: windows not on same screen\n");
        return;
    }
@
% important comment about images acquired by name!

\subsection{Unmarshalling}

<<[[drawmesg()]] locals>>=
int nw;
Memimage **lp;
@

<<[[drawmesg()]] cases>>=
/* top or bottom windows: 't' top[1] nw[2] n*id[4] */
case 't':
    printmesg(fmt="bsL", a, false);
    m = 1+1+2;
    <<[[drawmesg()]] sanity check n with m>>
    nw = BGSHORT(a+2);
    <<[[drawmesg()]] when top or bottom windows, sanity check nw>>
    m += nw*4;
    <<[[drawmesg()]] sanity check n with m>>
    lp = malloc(nw * sizeof(Memimage*));
    <<[[drawmesg()]] when top or bottom windows, sanity check lp>>
    for(j=0; j<nw; j++)
        lp[j] = drawimage(client, a+1+1+2+j*4);
    <<[[drawmesg()]] when top or bottom windows, sanity check windows>>

    if(a[1])
        memltofrontn(lp, nw); // The call
    else
        memltorearn(lp, nw); // The call

    <<[[drawmesg()]] when top or bottom windows, addflush>>
    <<[[drawmesg()]] when top or bottom windows, refresh>>

    poperror();
    free(lp);
    continue;

@
% poperror because waserror in one of the sanity check



<<[[drawmesg()]] when top or bottom windows, sanity check nw>>=
if(nw < 0)
    error(Ebadarg);
if(nw == 0)
    continue;
@

<<[[drawmesg()]] when top or bottom windows, sanity check lp>>=
if(lp == nil)
    error(Enomem);
if(waserror()){
    free(lp);
    nexterror();
}
@
% hence poperror above.

<<[[drawmesg()]] when top or bottom windows, sanity check windows>>=
if(lp[0]->layer == nil)
    error("images are not windows");
for(j=1; j<nw; j++)
    if(lp[j]->layer->screen != lp[0]->layer->screen)
        error("images not on same screen");
@
% now we can do the check that all images have the same screen.
% Note that if got DImage by name, it may not not have its dscreen field set
% (indeed see the nil in if(drawinstall(client, dstid, dn->dimage->image, nil)))
% but it will share the same Memimage which will have a layer and appropriate
% screen set. Anyway here we deal with Memimage directly.



\subsection{Algorithm}

\subsubsection{To front}

% so first entry in array will be at the end the first one
<<function memltofrontn>>=
void
memltofrontn(Memimage **ip, int n)
{
    Memimage *i, *front;

    <<[[memltofrontn()]] sanity check n>>
    front = nil;
    while(--n >= 0){
        i = *ip++;
        _memltofront(i, front, true);
        front = i;
    }
    _memlsetclear(front->layer->screen);
}
@
%old:    Memscreen *s; s = front->layer->screen;

<<[[memltofrontn()]] sanity check n>>=
if(n == 0)
    return;
@

% memlorigin -> <>
<<function memltofront>>=
void
memltofront(Memimage *i)
{
    _memltofront(i, nil, true);
    _memlsetclear(i->layer->screen);
}
@




<<function _memltofront>>=
/*
 * Pull i towards top of screen, just behind front
*/
static
void
_memltofront(Memimage *i, Memimage *front, bool fill)
{
    Memlayer *l;
    Memscreen *s;
    Memimage *f;
    Rectangle x;
    bool overlap;
    <<[[_memltofront()]] other locals>>

    l = i->layer;
    s = l->screen;

    while(l->front != front){
        f = l->front;
        x = l->screenr;

        // i will now pass in front of f, so hide f
        overlap = rectclip(&x, f->layer->screenr);
        if(overlap){
            memlhide(f, x);
            f->layer->clear = false;
        }
        <<[[_memltofront()]] put f behind i>>
        if(overlap && fill)
            memlexpose(i, x);
    }
}
@
% fill just false when have a Dnotfill color when create window the first time

% useless to set clear here I think since anyway it's set in _memlsetclear


<<[[_memltofront()]] other locals>>=
Memimage *ff, *rr;
@

<<[[_memltofront()]] put f behind i>>=
/* swap l and f in screen's list */
// swap_double_list(l, f, s->frontmost, s->rearmost)
ff = f->layer->front;
rr = l->rear;

if(ff == nil)
    s->frontmost = i;
else
    ff->layer->rear = i;

if(rr == nil)
    s->rearmost = f;
else
    rr->layer->front = f;

l->front = ff;
l->rear = f; // f is now behind i
f->layer->front = i;
f->layer->rear = rr;
@


% update invariant
<<function _memlsetclear>>=
void
_memlsetclear(Memscreen *s)
{
    Memimage *i, *j;
    Memlayer *l;

    for(i = s->rearmost; i; i = i->layer->front){
        l = i->layer;
        l->clear = rectinrect(l->screenr, l->screen->image->clipr);
        if(l->clear)
            for(j = l->front; j; j = j->layer->front)
                if(rectXrect(l->screenr, j->layer->screenr)){
                    l->clear = false;
                    break;
                }
    }
}
@
% why need clear field to be maintained? to optimize things,
%  to know whether we need to pull some pixels back from save 
%  or whether they are already on the screen.



<<function _memltofrontfill>>=
void
_memltofrontfill(Memimage *i, bool fill)
{
    _memltofront(i, nil, fill);
    _memlsetclear(i->layer->screen);
}
@


\subsubsection{To rear}


<<function memltorearn>>=
void
memltorearn(Memimage **ip, int n)
{
    Memimage *i, *rear;

    <<[[memltofrontn()]] sanity check n>>
    rear = nil;
    while(--n >= 0){
        i = *ip++;
        _memltorear(i, rear);
        rear = i;
    }
    _memlsetclear(rear->layer->screen);
}
@
%old:    Memscreen *s; s = rear->layer->screen;

% memldelete -> <>
<<function memltorear>>=
void
memltorear(Memimage *i)
{
    _memltorear(i, nil);
    _memlsetclear(i->layer->screen);
}
@



<<function _memltorear>>=
void
_memltorear(Memimage *i, Memimage *rear)
{
    Memlayer *l;
    Memscreen *s;
    Memimage *f, *r, *rr;
    Rectangle x;
    bool overlap;

    l = i->layer;
    s = l->screen;

    while(l->rear != rear){
        r = l->rear;
        x = l->screenr;

        overlap = rectclip(&x, r->layer->screenr);
        if(overlap){
            memlhide(i, x);
            l->clear = false;
        }
        <<[[_memltorear()]] put i behind r>>
        if(overlap)
            memlexpose(r, x);
    }
}
@


<<[[_memltorear()]] put i behind r>>=
/* swap l and r in screen's list */
// swap_end_double_list(i, r, s->frontmost, s->rearmost)
rr = r->layer->rear;
f = l->front;

if(rr == nil)
    s->rearmost = i;
else
    rr->layer->front = i;

if(f == nil)
    s->frontmost = r;
else
    f->layer->rear = r;

l->rear = rr;
l->front = r; // i is now behind r
r->layer->rear = i;
r->layer->front = f;
@





\section{Layer visibility}

%trans: seen memlhide and memlexpose before.

\subsection{[[memlhide()]]}

% rectangle in screen coordinate!
<<function memlhide>>=
void
memlhide(Memimage *i, Rectangle screenr)
{
    if(i->layer->save == nil)
        return;
    if(!rectclip(&screenr, i->layer->screen->image->r))
        return;

    _memlayerop(lhideop, i, screenr, screenr, i->layer);
}
@

% will see _memlayerop later. Will call lhideop for each sub rectangles
% in screenr. 

% FIGURE with visible rectangle and invisible one?



% memlhide -> _memlayerop -> <> (as ?? <- _memlayerop(<>, ...) <- memlhide)
<<function lhideop>>=
/*
 * Hide puts that portion of screenr now on the screen into the window's
 * save area.
 * Expose puts that portion of screenr now in the save area onto the screen.
 *
 * Hide and Expose both require that the layer structures in the screen
 * match the geometry they are being asked to update, that is, they update the
 * save area (hide) or screen (expose) based on what those structures tell them.
 * This means they must be called at the correct time during window shuffles.
 */
static
void
lhideop(Memimage *src, Rectangle screenr, Rectangle clipr, void *etc, bool insave)
{
    Memlayer *l = etc;
    Rectangle r;

    USED(clipr.min.x);
    USED(insave);

    if(src != l->save){	/* do nothing if src is already in save area */
        r = rectsubpt(screenr, l->delta);
        memdraw(l->save, r, src, screenr.min, nil, screenr.min, S);
    }
}
@
% delete clipr?
\l mv insave closer to first parameter?
%ocaml: use variant instead of pair src x insave

% why rectsubpt? because screenr is in screen coordinate but
% when src is actually the save Memimage, then we need to translate
% back to logical coordinate.
%alt: simpler system? 
%ocaml: Logical of Pt | Screen of Pt

\subsection{[[memlexpose()]]}

<<function memlexpose>>=
void
memlexpose(Memimage *i, Rectangle screenr)
{
    if(!rectclip(&screenr, i->layer->screen->image->r))
        return;
    _memlayerop(lexposeop, i, screenr, screenr, i->layer);
}
@

<<function lexposeop>>=
static
void
lexposeop(Memimage *dst, Rectangle screenr, Rectangle clipr, void *etc, bool insave)
{
    Memlayer *l = etc;
    Rectangle r;

    USED(clipr.min.x);
    if(insave)	/* if dst is save area, don't bother */
        return;
    r = rectsubpt(screenr, l->delta);
    if(l->save)
        memdraw(dst, screenr, l->save, r.min, nil, r.min, S);
    <<[[lexposeop()]] if not save but refresh method>>
}
@

% insave?

\section{Layer origin}

% one of the main reason why need adaptations I think later when
% draw things is the change of origin (the other is because
% things may have to be put in save instead of on the desktop image).

\subsection{API}

% log for logical coordinate, scr for screen position.

% does two things at the same time:
% - can change coordinate system,
% - can move window around (which will hide/expose other windows)

<<function originwindow>>=
errorneg1
originwindow(Image *w, Point log, Point scr)
{
    byte *b;
    Point delta;

    flushimage(w->display, false);

    <<[[originwindow()]] marshall position window message>>

    delta = subpt(log, w->r.min);
    // new image coords
    w->r     = rectaddpt(w->r, delta);
    w->clipr = rectaddpt(w->clipr, delta);
    return OK_1;
}
@
% adapt visible r and clipr to logical coordinate

\subsection{Marshalling}

<<[[originwindow()]] marshall position window message>>=
// position window: 'o' id[4] r.min [2*4] screenr.min [2*4]
b = bufimage(w->display, 1+4+2*4+2*4);
<<[[originwindow()]] sanity check b>>
b[0] = 'o';
BPLONG(b+1, w->id);
BPLONG(b+5, log.x);
BPLONG(b+9, log.y);
BPLONG(b+13, scr.x);
BPLONG(b+17, scr.y);
if(flushimage(w->display, true) < 0)
    return ERROR_NEG1;
@

<<[[originwindow()]] sanity check b>>=
if(b == nil)
    return 0; // really? not -1?
@

\subsection{Unmarshalling}

<<[[drawmesg()]] cases>>=
/* position window: 'o' id[4] r.min [2*4] screenr.min [2*4] */
case 'o':
    printmesg(fmt="LPP", a, false);
    m = 1+4+2*4+2*4;
    <<[[drawmesg()]] sanity check n with m>>
    dst = drawimage(client, a+1);
    if(dst->layer){
        drawpoint(&p, a+5);
        drawpoint(&q, a+13);
        r = dst->layer->screenr;

        ni = memlorigin(dst, p, q); // The call

        <<[[drawmesg()]] when position window, sanity check ni>>
        if(ni > 0){
            <<[[drawmesg()]] when position window, addflush>>
            <<[[drawmesg()]] when position window, refresh>>
        }
    }
    // else, could display error
    continue;
@

<<[[drawmesg()]] when position window, sanity check ni>>=
if(ni < 0)
    error("image origin failed");
@


\subsection{Algorithm}

% 0 means no change, < 0 means error, > 0 means changes

% as said before, can do 2 different things at the same time.

<<function memlorigin>>=
/*
 * Place i so i->r.min = log, i->layer->screenr.min == scr.
*/
errorneg1
memlorigin(Memimage *i, Point log, Point scr)
{
    Memlayer *l;
    Memscreen *s;
    Rectangle newr, oldr;
    Point delta;
    bool eqlog, eqscr, wasclear;
    <<[[memlorigin()]] other locals>>

    l = i->layer;
    s = l->screen;

    oldr = l->screenr;
    newr = Rect(scr.x, scr.y, scr.x + Dx(oldr), scr.y + Dy(oldr));

    eqscr = eqpt(scr, oldr.min);
    eqlog = eqpt(log, i->r.min);

    if(eqscr && eqlog)
        return 0;

    <<[[memlorigin()]] allocate new save image if log changed>>
    /*
     * Bring it to front and move logical coordinate system.
     */
    memltofront(i);
    wasclear = l->clear;
    <<[[memlorigin()]] set new save image if log changed>>

    // like in user side
    delta = subpt(log, i->r.min);
    // new image coords
    i->r     = rectaddpt(i->r, delta);
    i->clipr = rectaddpt(i->clipr, delta);

    l->delta = subpt(l->screenr.min, i->r.min);

    if(eqscr)
        return 0;
    // else

    <<[[memlorigin()]] move window>>
}
@
% remember delta field from Memlayer:
%    Point			delta;	/* add delta to go from image coords to screen */

\subsubsection{New origin}

<<[[memlorigin()]] other locals>>=
Memimage *nsave;
@
% Memlayer.save use logical coord, so if move origin, 
% then need new image.

<<[[memlorigin()]] allocate new save image if log changed>>=
nsave = nil;
if(!eqlog && l->save != nil){
    nsave = allocmemimage(Rect(log.x, log.y, log.x+Dx(oldr), log.y+Dy(oldr)), i->chan);
    <<[[memlorigin()]] sanity check nsave>>
}
@

<<[[memlorigin()]] set new save image if log changed>>=
if(nsave){
    if(!wasclear)
        memimagedraw(nsave, nsave->r, l->save, l->save->r.min, nil, ZP, S);
    freememimage(l->save);
    l->save = nsave;
}
@
%old: was Pt(0,0) but ZP better I think


<<[[memlorigin()]] sanity check nsave>>=
if(nsave == nil)
    return ERROR_NEG1;
@

\subsubsection{New screen position}

<<[[memlorigin()]] other locals>>=
Memimage *shad, *t;
bool overlap;
Rectangle x;
@

% why need shadow? what would happen if didn't have shadow window?

<<[[memlorigin()]] move window>>=
/*
 * To clean up old position, make a shadow window there, don't paint it,
 * push it behind this one, and (later) delete it.  Because the refresh
 * function for this fake window is a no-op, this will cause no graphics
 * action except to restore the background and expose the windows
 * previously hidden.
 */
shad = memlalloc(s, oldr, memlnorefresh, nil, DNofill);
<<[[memlorigin()]] sanity check shad>>
<<[[memlorigin()]] manage stack of windows, put shad after front>>
shad->layer->clear = false;

/*
 * Shadow is now holding down the fort at the old position.
 * Move the window and hide things obscured by new position.
 */
for(t = l->rear->layer->rear; t != nil; t = t->layer->rear){
    x = newr;
    overlap = rectclip(&x, t->layer->screenr);
    if(overlap){
        memlhide(t, x);
        t->layer->clear = false;
    }
}
l->screenr = newr;
l->delta = subpt(scr, i->r.min);
l->clear = rectinrect(newr, l->screen->image->clipr);

/*
 * Everything's covered.  Copy to new position and delete shadow window.
 */
if(wasclear)
    memdraw(s->image, newr, s->image, oldr.min, nil, ZP, S);
else
    memlexpose(i, newr);

memldelete(shad);

return 1;
@
% change again l->delta here.
%old: use ZP here again


<<[[memlorigin()]] manage stack of windows, put shad after front>>=
// add_after_double_list(shad, i, s->frontmost, s->rearmost)
s->frontmost = i; // useless since memltofront(i) above
if(s->rearmost == i)
    s->rearmost = shad;
else
    l->rear->layer->front = shad;
shad->layer->front = i;
shad->layer->rear = l->rear;
l->rear = shad;
l->front = nil;
@


<<[[memlorigin()]] sanity check shad>>=
if(shad == nil)
    return ERROR_NEG1;
@




\section{Drawing and Layers}

%trans:
% Most drawing code we presented before for images handle basic images 
% but not windows. A window is mostly an image, but not exactly an image:
% We need first to adapt coordinates and then draw on
% underlying screen image or draw on save depending if area is visible or not.
% So need many adaptations to drawing algo we saw before. Cant just
% draw with coord on full underlying screen (shared) image.

%alt: just draw on save and use painter algorithm, far simpler.

\subsection{Drawing rectangles on overlapping layers}

%trans:
% seen memdraw() in chapter X. But for simple case where src and
% dst are simple images, not windows, in which case call
% the simple memimagedraw().
% Here adaptations when one of the image is actually a window in which case we 
% need to translate image coords to actual screen coord and possibly draw in 
% save area instead if destination is a window. We may also have
% to take pixels from the save area if src is a partially obscured window.

\subsubsection{[[memdraw()]]}

<<[[memdraw()]] if mask has layer>>=
if(mask->layer){
    DBG1("mask->layer != nil\n");
    return;	/* too hard, at least for now */
}
@
\l no warning??
% ok, so now still src and dst to transform in regular images.

<<[[memdraw()]] locals>>=
Memlayer *dl, *sl;
@

% starts like memimagedraw with drawclip
<<[[memdraw()]] when have layers>>=
<<[[memdraw()]] call drawclip, if empty rectangle return>>

/*
 Convert to screen coordinates.
 */
dl = dst->layer;
<<[[memdraw()]] convert [[r]] if dst is a window>>

<<[[memdraw()]] if dst is fully visible can optimize>>
// else

sl = src->layer;
<<[[memdraw()]] convert [[p0]] and [[srcr]] if src is a window>>

/*
 * Now everything is in screen coordinates.
 * mask is an image.  dst and src are images or obscured layers.
 */
<<[[memdraw()]] if dst and src are the same window>>
// else

<<[[memdraw()]] make src an image>>

/*
 * src is now an image.  dst may be an image or a clear layer
 */
if(dl == nil)
    goto Top;
<<[[memdraw()]] after src is an image, if dst is fully visible can optimize>>
// else

<<[[memdraw()]] general case where dst is an obscured window>>
@
%old: was using dst->layer at a few places instead of dl



<<[[memdraw()]] locals>>=
Rectangle srcr, mr; // set by drawclip
@

% similar to memimagedraw
<<[[memdraw()]] call drawclip, if empty rectangle return>>=
if(!drawclip(dst, &r, src, &p0, mask, &p1,   &srcr, &mr)){
    return;
}
@
%old:   DBG1("drawclip dstcr %R srccr %R maskcr %R\n", dst->clipr, src->clipr, mask->clipr);

% What if different coordinate system? If dst is regular image but
% src a window? Does not matter. Logically the coord of the window
% are the coord we mean for the data. It's not the real one because
% we share an image, but the user does not have to care about that.

\subsubsection{Coordinate conversions}

<<[[memdraw()]] convert [[r]] if dst is a window>>=
if(dl != nil){
    // r = rectaddpt(r, dl->delta)
    r.min.x += dl->delta.x;
    r.min.y += dl->delta.y;
    r.max.x += dl->delta.x;
    r.max.y += dl->delta.y;
}
@

<<[[memdraw()]] convert [[p0]] and [[srcr]] if src is a window>>=
if(sl != nil){
    // p0 = addpt(p0, sl->delta)
    p0.x += sl->delta.x;
    p0.y += sl->delta.y;
    // srcr = rectaddpt(srcr, sl->delta)
    srcr.min.x += sl->delta.x;
    srcr.min.y += sl->delta.y;
    srcr.max.x += sl->delta.x;
    srcr.max.y += sl->delta.y;
}
@

\subsubsection{Source conversion}

<<[[memdraw()]] make src an image>>=
if(sl){
    <<[[memdraw()]] if src is fully visible can optimize>>

    /* relatively rare case; use save area */
    <<[[memdraw()]] if refresh function for src>>
    memlhide(src, srcr); // draw the needed pixels in sl->save

    /* convert back to logical coordinates */
    // p0 = subpt(p0, sl->delta)
    p0.x -= sl->delta.x;
    p0.y -= sl->delta.y;
    // srcr = rectsubpt(srcr, sl->delta)
    srcr.min.x -= sl->delta.x;
    srcr.min.y -= sl->delta.y;
    srcr.max.x -= sl->delta.x;
    srcr.max.y -= sl->delta.y;

    src = src->layer->save; // progress
}
@
% note that memlhide -> _memlayerop -> memdraw, so kinda recursif,
% but the memdraw will be with src->layer->save, a simple image.

% convert back to logical because sl->save have data with logical coords.

\subsubsection{Shortcuts}

<<[[memdraw()]] if dst is fully visible can optimize>>=
Clearlayer:
if(dl!=nil && dl->clear){
    if(src == dst){
        // p0 = addpt(p0, dl->delta)
        p0.x += dl->delta.x;
        p0.y += dl->delta.y;

        src = dl->screen->image; // progress
    }
    dst = dl->screen->image; // progress
    goto Top;
}
@

% note that maybe src != dst and still a layer in which case one
% could think there could be a problem. But actually Top will still
% check dst and src are not windows, and so at least here we may have
% made some progress (but there will be no infinite loop though, because
% dst has changed now! it's not a window for sure and so it will
% not take this code path again).


<<[[memdraw()]] locals>>=
Rectangle tr;
@

% r has been converted to screen coord 
<<[[memdraw()]] if dst and src are the same window>>=
/*
 * if dst and src are the same layer, just draw in save area and expose.
 */
if(dl != nil && dst == src){
    <<[[memdraw()]] if refresh function for dst>>
    if(rectXrect(r, srcr)){
        <<[[memdraw()]] set tr to union of r and srcr and adapt p1>>
        memlhide(dst, tr);
    }else{
        memlhide(dst, r);
        memlhide(dst, srcr);
    }
    memdraw(dl->save, rectsubpt(r,    dl->delta), 
            dl->save, subpt(srcr.min, dl->delta),  
            mask, p1, op);
    memlexpose(dst, r);
    return;
}
@
%old: was src->layer->delta but dst == src so can simplify

% restore coord back since use save here which use logical coord

\l why do union for tr? be simpler to do the 2 memlhide like below no?

<<[[memdraw()]] set tr to union of r and srcr and adapt p1>>=
tr = r;
if(srcr.min.x < tr.min.x){
    p1.x += tr.min.x - srcr.min.x;
    tr.min.x = srcr.min.x;
}
if(srcr.min.y < tr.min.y){
    p1.y += tr.min.x - srcr.min.x;
    tr.min.y = srcr.min.y;
}
if(srcr.max.x > tr.max.x)
    tr.max.x = srcr.max.x;
if(srcr.max.y > tr.max.y)
    tr.max.y = srcr.max.y;
@




<<[[memdraw()]] if src is fully visible can optimize>>=
if(sl->clear){
    src = sl->screen->image;
    if(dl != nil){
        // r = rectsubpt(r, dl->delta)
        r.min.x -= dl->delta.x;
        r.min.y -= dl->delta.y;
        r.max.x -= dl->delta.x;
        r.max.y -= dl->delta.y;
    }
    goto Top;
}
@
\l why this rectsubpt because goto Top so need to put back invariant?


<<[[memdraw()]] after src is an image, if dst is fully visible can optimize>>=
if(dl->clear)
    goto Clearlayer;
@





\subsubsection{[[_ldrawop()]]}

%trans: back to general case when dst is obscured window.
% src is a simple image, coords have been converted (r is a screenr)
% but now need to draw on window.

%DS to present first:

<<[[memdraw()]] locals>>=
struct Draw d;
@

<<struct Draw>>=
struct Draw
{
    Memlayer    *dstlayer;

    Memimage	*src;
    Point	deltas;

    Memimage	*mask;
    Point	deltam;

    // enum<Drawop>
    int	op;
};
@
% Similar to Memdrawparam. Needed because _memlayerop is generic
%  higher order function but can pass only one parameter to callback.

\l could have Draw.p0 and Draw.p1 instead of those deltas I think.
\l Would be simpler than those subpt and addpt.


<<[[memdraw()]] general case where dst is an obscured window>>=
/*
 * dst is an obscured layer
 */
d.dstlayer = dl;
d.src = src;
d.mask = mask;
d.op = op;
d.deltas = subpt(p0, r.min);
d.deltam = subpt(p1, r.min);

_memlayerop(ldrawop, dst, r, r, &d);
@

% see _memlayerop soon.
% what will happen is that we call callback for every rectangles
% to draw, in save, in visible, because of overlapping windows.

% FIGURE where see all those little rectangles, visible,
% and also the invisible one in save.

% Note that dst below is not the same than in Draw.dstlayer!
% dst here can be the Memimage of the save! or the Memimage of the full screen
% image. The case is actually defined by insave parameter.

<<function ldrawop>>=
static
void
ldrawop(Memimage *dst, Rectangle screenr, Rectangle clipr, void *etc, bool insave)
{
    struct Draw *d = etc;
    Point p0, p1;
    Rectangle r;
    <<[[ldrawop()]] other locals>>

    <<[[ldrawop()]] return if no save in dst>>

    p0 = addpt(screenr.min, d->deltas);
    p1 = addpt(screenr.min, d->deltam);

    if(insave){
        r     = rectsubpt(screenr, d->dstlayer->delta);
        clipr = rectsubpt(clipr,   d->dstlayer->delta);
    }else
        r = screenr;

    /* now in logical coordinates */

    <<[[ldrawop()]] if r not in clipr>>
    memdraw(dst, r, d->src, p0, d->mask, p1, d->op); // will call memimagedraw
}
@
% need adjust clipr because of the if r not in clipr test after.
% need same coordinate system.

% ???
<<[[ldrawop()]] other locals>>=
Rectangle oclipr, srcr, mr;
bool ok;
@
<<[[ldrawop()]] if r not in clipr>>=
/* clipr may have narrowed what we should draw on, so clip if necessary */
if(!rectinrect(r, clipr)){
    <<[[ldrawop()]] change dst clipr>>
    ok = drawclip(dst, &r, d->src, &p0, d->mask, &p1, &srcr, &mr);
    <<[[ldrawop()]] restore dst clipr>>
    if(!ok)
        return;
}
@

<<[[ldrawop()]] change dst clipr>>=
oclipr = dst->clipr;
dst->clipr = clipr;
@
<<[[ldrawop()]] restore dst clipr>>=
dst->clipr = oclipr;
@

\subsubsection{[[_memlayerop()]]}

% Memimage i below is a window.

% not just for ldawop! for expose, window (and line later)

% memlhide | memlexpose | memdraw -> <>
<<function _memlayerop>>=
/*
 * Assumes incoming rectangle has already been clipped to i's logical r and clipr
 */
void
_memlayerop(
    void (*fn)(Memimage*, Rectangle, Rectangle, void*, int),
    Memimage *i,
    Rectangle screenr,	/* clipped to window boundaries */
    Rectangle clipr,	/* clipped also to clipping rectangles of hierarchy */
    void *etc)
{
    Memlayer *l;
    Rectangle r, scr;

    l = i->layer;
    if(!rectclip(&screenr, l->screenr))
        return;

    if(l->clear){
        fn(l->screen->image, screenr, clipr, etc, false);
        return;
    }

    r = screenr; // original value before rectclip below
    scr = l->screen->image->clipr;

    /*
     * Do the piece on the screen
     */
    if(rectclip(&screenr, scr))
        _layerop(fn, i, screenr, clipr, etc, l->screen->frontmost);

    if(rectinrect(r, scr))
        return;

    /*
     * Do the piece off the screen
    */
    if(!rectXrect(r, scr)){
        /* completely offscreen; easy */
        fn(l->save, r, clipr, etc, true);
        return;
    }
    // else

    if(r.min.y < scr.min.y){
        /* above screen */
        fn(l->save, Rect(r.min.x, r.min.y, r.max.x, scr.min.y), clipr, etc, true);
        r.min.y = scr.min.y;
    }
    if(r.max.y > scr.max.y){
        /* below screen */
        fn(l->save, Rect(r.min.x, scr.max.y, r.max.x, r.max.y), clipr, etc, true);
        r.max.y = scr.max.y;
    }
    if(r.min.x < scr.min.x){
        /* left of screen */
        fn(l->save, Rect(r.min.x, r.min.y, scr.min.x, r.max.y), clipr, etc, true);
        r.min.x = scr.min.x;
    }
    if(r.max.x > scr.max.x){
        /* right of screen */
        fn(l->save, Rect(scr.max.x, r.min.y, r.max.x, r.max.y), clipr, etc, true);
    }
}
@

% FIGURE with stuff outside screen

\subsubsection{[[_layerop()]]}

% finally. last step.

% draw on screen when can because on top for this part,
% or on save when obscured.

<<function _layerop>>=
static void
_layerop(
    void (*fn)(Memimage*, Rectangle, Rectangle, void*, int),
    Memimage *i,
    Rectangle r,
    Rectangle clipr,
    void *etc,
    Memimage *front)
{
    Rectangle fr;

    Top:
    if(front == i){
        /* no one is in front of this part of window; use the screen */
        fn(i->layer->screen->image, r, clipr, etc, false);
        return;
    }
    // else

    fr = front->layer->screenr;
    if(!rectXrect(r, fr)){
        /* r doesn't touch this window; continue on next rearmost */
        front = front->layer->rear;
        goto Top;
    }
    // else, r touches this window somewhere

    if(fr.max.y < r.max.y){
        // rectangle below front
        RECUR(r.min.x, fr.max.y, r.max.x, r.max.y);
        r.max.y = fr.max.y;
    }
    if(r.min.y < fr.min.y){
        // rectangle above front
        RECUR(r.min.x, r.min.y, r.max.x, fr.min.y);
        r.min.y = fr.min.y;
    }
    if(fr.max.x < r.max.x){
        // rectangle right of front
        RECUR(fr.max.x, r.min.y, r.max.x, r.max.y);
        r.max.x = fr.max.x;
    }
    if(r.min.x < fr.min.x){
        // rectangle left of front
        RECUR(r.min.x, r.min.y, fr.min.x, r.max.y);
        r.min.x = fr.min.x;
    }
    /* r is covered by front, so put in save area */
    (*fn)(i->layer->save, r, clipr, etc, true);
}
@
%old: when !rectXrect
%        // assert(front && front->layer && front->layer->screen && front->layer->rear);

<<function RECUR>>=
#define	RECUR(a,b,c,d)	_layerop(fn, i, Rect(a, b, c, d), clipr, etc, front->layer->rear);
@
%old:#define	RECUR(a,b,c,d)	_layerop(fn, i, Rect(a.x, b.y, c.x, d.y), clipr, etc, front->layer->rear);

% r.max.y = fr.max.y to avoid redundant work! and for the save part

% FIGURE with mini rectangles, maybe do 4 mini figures for each cases





\subsection{Drawing lines on overlapping layers}

<<[[_memline()]] sanity check no src layer>>=
if(src->layer)	/* can't draw line with layered source */
    return;
@
% no mask with _memline, just dst and src.


<<[[_memline()]] when have layers>>=
<<[[_memline()]] clip source>>

// Convert to screen coordinates
<<[[_memline()]] convert p0, p1, clipr coordinates >>

<<[[_memline()]] if dst is fully visible can optimize>>

<<[[_memline()]] set r bounding box and clip it>>

<<[[_memline()]] general case, call _memlayerop>>
@


<<[[_memline()]] other locals>>=
bool srcclipped = false;
Point d;
@

<<[[_memline()]] clip source>>=
if(!srcclipped){
    d = subpt(sp, p0);
    if(!rectclip(&clipr, rectsubpt(src->clipr, d)))
        return;
    if(!(src->flags&Frepl) && !rectclip(&clipr, rectsubpt(src->r, d)))
        return;
    srcclipped = true;
}
@
% why need srcclipped once guard? because of goto Top?

<<[[_memline()]] convert p0, p1, clipr coordinates >>=
/* dst is known to be a layer */
// p0 = addpt(p0, dl->delta)
p0.x += dl->delta.x;
p0.y += dl->delta.y;
// p1 = addpt(p1, dl->delta)
p1.x += dl->delta.x;
p1.y += dl->delta.y;
// clipr = rectaddpt(clipr, dl->elta)
clipr.min.x += dl->delta.x;
clipr.min.y += dl->delta.y;
clipr.max.x += dl->delta.x;
clipr.max.y += dl->delta.y;
@

<<[[_memline()]] if dst is fully visible can optimize>>=
if(dl->clear){
    dst = dst->layer->screen->image;
    goto Top;
}
@


<<[[_memline()]] other locals>>=
Rectangle r;
@

<<[[_memline()]] set r bounding box and clip it>>=
/* can't use sutherland-cohen clipping because lines are wide */
r = memlinebbox(p0, p1, end0, end1, radius);
/*
 * r is now a bounding box for the line;
 * use it as a clipping rectangle for subdivision
 */
if(!rectclip(&r, clipr))
    return;
@
%old:
% /* XXx */
% /* this is not the correct set of tests */
% //	if(log2[dst->depth] != log2[src->depth] || log2[dst->depth]!=3)
% //		return;


<<[[_memline()]] other locals>>=
struct Lline ll;
@

<<struct Lline>>=
struct Lline
{
    Point			p0;
    Point			p1;
    Point			delta;
    int			end0;
    int			end1;
    int			radius;
    Point			sp;

    Memlayer		*dstlayer;
    Memimage	*src;
    int			op;
};
@
% all the params of _memline mostly


<<[[_memline()]] general case, call _memlayerop>>=
ll.p0 = p0;
ll.p1 = p1;
ll.end0 = end0;
ll.end1 = end1;
ll.sp = sp;
ll.dstlayer = dst->layer;
ll.src = src;
ll.radius = radius;
ll.delta = dl->delta;
ll.op = op;

_memlayerop(llineop, dst, r, r, &ll);
@


% each time called with a small screenr
<<function llineop>>=
static
void
llineop(Memimage *dst, Rectangle screenr, Rectangle clipr, void *etc, bool insave)
{
    struct Lline *ll = etc;
    Point p0, p1;

    USED(screenr.min.x);

    if(insave && ll->dstlayer->save == nil)
        return;
    if(!rectclip(&clipr, screenr))
        return;

    if(insave){
        p0 = subpt(ll->p0, ll->delta);
        p1 = subpt(ll->p1, ll->delta);
        clipr = rectsubpt(clipr, ll->delta);
    }else{
        p0 = ll->p0;
        p1 = ll->p1;
    }

    _memline(dst, p0, p1, ll->end0, ll->end1, ll->radius, ll->src, ll->sp, clipr, ll->op);
}
@





\subsection{Loading an image on overlapping layers}

\subsubsection{[[memload()]]}

<<[[memload()]] other locals>>=
Rectangle lr; // saved logical r
int dx;
Memimage *tmp;
@

<<[[memload()]] if dst has a layer>>=
/*
 * Convert to screen coordinates.
 */
lr = r;
// r = rectaddpt(r, dl->delta)
r.min.x += dl->delta.x;
r.min.y += dl->delta.y;
r.max.x += dl->delta.x;
r.max.y += dl->delta.y;

dx = dl->delta.x & (7 / dst->depth);

<<[[memload()]] if dst is fully visible can optimize>>

/*
 * dst is an obscured layer or data is unaligned
 */
<<[[memload()]] if data is aligned, load on save and expose>>
// else
tmp = allocmemimage(lr, dst->chan);
<<[[memload()]] sanity check tmp>>
n = loadfn(tmp, lr, data, n);
memdraw(dst, lr, tmp, lr.min, nil, lr.min, S);
freememimage(tmp);
return n;
@


<<[[memload()]] if dst is fully visible can optimize>>=
if(dl->clear && dx==0){
    dst = dl->screen->image;
    goto Top;
}
@

<<[[memload()]] if data is aligned, load on save and expose>>=
if(dl->save && dx==0){
    n = loadfn(dl->save, lr, data, n);
    if(n > 0)
        memlexpose(dst, r);
    return n;
}
@




<<[[memload()]] sanity check tmp>>=
if(tmp == nil)
    return ERROR_NEG1;
@



\subsubsection{[[memunload()]]}

% very similar

<<[[memunload()]] other locals>>=
Rectangle lr;
int dx;
Memimage *tmp;
@

<<[[memunload()]] if src has layer>>=
/*
 Convert to screen coordinates.
 */
lr = r;
// r = rectaddpt(r, dl->delta)
r.min.x += dl->delta.x;
r.min.y += dl->delta.y;
r.max.x += dl->delta.x;
r.max.y += dl->delta.y;

dx = dl->delta.x&(7/src->depth);
if(dl->clear && dx==0){
    src = dl->screen->image;
    goto Top;
}

/*
 * src is an obscured layer or data is unaligned
 */
if(dl->save && dx==0){
    if(dl->refreshfn != nil)
        return ERROR_NEG1;	/* can't unload window if it's not Refbackup */
    if(n > 0)
        memlhide(src, r);
    n = unloadmemimage(dl->save, lr, data, n);
    return n;
}

tmp = allocmemimage(lr, src->chan);
if(tmp == nil)
    return ERROR_NEG1;
memdraw(tmp, lr, src, lr.min, nil, lr.min, S);
n = unloadmemimage(tmp, lr, data, n);
freememimage(tmp);
return n;
@



%\subsection{Flushing}
% see adv topics




\chapter{Windowing System Support}
\label{chap:windowing-support}

%trans:
% Saw windows chapter before. Can be used for regular app. e.g., acme.
% Will be used by rio. Actually used by every app by default too as we will see.
% Saw Naming images section before. Can be used for interprocess sharing.
% A few more pieces (/dev/winname) and enough building blocks for rio.

% rio overview: when run, access to full screen, direct access to
% /dev/draw (actually even rio go through initdraw and so have screen
% and view, but when noborder screenname, a bit special).
% Then with screen create subwindows when special command with mouse,
% then associate process with this screen and emulate /dev/winname
%  for this process.
% (and also public screen but actually less important)
% every app use initdraw(), so can put stuff there to setup things.


% Also fast windowing system because even if window, draw directly 
% on frame buffer! (actually can mess up with Display->image)
%alt: 8 1/2 was virtualizing the window too, cleaner, and more
% elegant, but slower apparently. Maybe could not have games in a window
% then. Also would be safer! any app can draw on desktop ! maybe can
% do tricky stuff to fool the user?

% see window(2) discussion at the end about rio and initdraw.
% rio creates a public screen, with public windows (images).
% then builds a screen for each window, then a border (a window?)
% and then a subwindow for the client.

\section{Additional data structures}

% every window run will have view and screen set accordingly.

\subsection{[[view]]}

<<global view>>=
// ref<Image>, a window
Image	*view;
@
% gengetwindow(..., &view) <- geninitdraw <- initdraw
%old: was called screen, but unfortunate because there was
% also a Screen type and then a _screen global.
% I could maybe also call it image, or window.
% At the same time with the virtual screen principle, every app thinks it has
% the whole screen for itself, so maybe it made sense to call this
% variable screen. But view is good too, less confusing.
% Actually rio uses a 'view' global assigned to screen.
%ocaml: does not need to be a global

% it is not the same than Display->image! (or Display->screenimage?)
% it comes from gengetwindown so it is really the window image!
% it should be smaller than Display->image (unless not run under rio).

% It has a backing store too?


% Why need to be a global? convenient, just call initdraw and everything
% is set for you.


\subsection{[[screen]]}

<<global screen>>=
Screen	*screen;
@
% gengetwindow(..., &screen) <- geninitdraw <- initdraw
%old: was called _screen because screen was already use 
%  (to actually an Image, hmm), but I s/screen/view so now screen is free.
%ocaml: does not need to be a global
\t rename desktop? (even if actually it's a subdesktop)

% screen is not screen of rio! it's actually a subscreen
% where client can create window in. Need subscreen because
% otherwise client could move around its own window? and need
% screen because only way for client to create its own window in it.
%(note that can still mess with Display->image, ugly)

\section{Additional (user) initializations}

\subsection{[[geninitdraw()]]}

% initdraw -> geninitdraw -> initdisplay; <>
<<[[geninitdraw()]] get window>>=
snprint(buf, sizeof buf, "%s/winname", display->windir);
if(gengetwindow(display, buf, &view, &screen, ref) < 0)
    goto Error;
@
%old: was &screen, &_screen
\l could call getwindow as it does this winname gymnastic

% ref is refresh method

% set the globals!

% so uses /dev/winname!
% which is noborder.screen.1 at the very beginning when run outside rio.


%\subsection{[[getwindow()]]}
<<function getwindow>>=
errorneg1
getwindow(Display *d, int ref)
{
    char winname[128];

    snprint(winname, sizeof winname, "%s/winname", d->windir);
    return gengetwindow(d, winname, &view, &screen, ref);
}
@
% every app go through initdraw and so should call gengetwindow, but
% after a resize event it is the responsibility of the app to
% call getwindow() to get your new 'view'.

\subsection{[[gengetwindow()]]}

% use /dev/winname and named image! way to know from rio
% which window I'm associated with (but could cheat?)

% ref below is refresh
<<function gengetwindow>>=
/*
 * Attach, or possibly reattach, to window.
 * If reattaching, maintain value of screen pointer.
 */
errorneg1
gengetwindow(Display *d, char *winname, Image **winp, Screen **scrp, int ref)
{
    int n;
    fdt fd;
    char buf[64+1]; // /dev/winname content
    Image *image;
    Rectangle r;

    fd = open(winname, OREAD);
    if(fd<0 || (n=read(fd, buf, sizeof buf-1))<=0){
        // no /dev/winname, image is then the full screen
        image = d->image;
        <<[[gengetwindow()]] sanity check image from display>>
        strcpy(buf, "noborder");
    }else{
        close(fd);
        buf[n] = '\0';
        <<[[gengetwindow()]] if already had a view, free it>>
        // get our window!
        image = namedimage(d, buf);
        <<[[gengetwindow()]] sanity check image from namedimage>>
    }

    d->screenimage = image;
    *scrp = allocscreen(image, d->white, false);
    <<[[gengetwindow()]] sanity check srcp>>

    r = image->r;
    if(strncmp(buf, "noborder", 8) != 0)
        r = insetrect(image->r, Borderwidth);
    *winp = _allocwindow(*winp, *scrp, r, ref, DWhite);
    <<[[gengetwindow()]] sanity check winp>>

    // get logical coordinates when run under rio
    // TODO: buggy!
    if(originwindow(*winp, Pt(0,0), r.min) <= 0)
      return ERROR_NEG1;

    d->screenimage = *winp;
    assert((*winp)->chan != 0);
    return OK_1;
}
@
% noborder trick a bit ugly.
\t could do originwindow here
% in fact have to do originwindow here cos do the border thing here.

% so app can mess up with its border :)

% draw.h
<<constant Borderwidth>>=
//coupling: must be equal to Selborder in rio
Borderwidth =	4,
@


% Note that works when run under rio and when not! in both cases
% view (via *winp) is set (and is always a window).

<<[[Display]] other fields>>=
// option<Image>, same than view, the window (or desktop image)
Image	*screenimage;
@
\t not sure why need that in Display. Seems redundant with Display.image





<<[[gengetwindow()]] sanity check image from display>>=
if(image == nil){
    fprint(2, "gengetwindow: %r\n");
    <<[[gengetwindow()]] return error>>
}
@
<<[[gengetwindow()]] return error>>=
*winp = nil;
d->screenimage = nil;
return ERROR_NEG1;
@

<<[[gengetwindow()]] sanity check image from namedimage>>=
if(image == nil){
    fprint(2, "namedimage %s failed: %r\n", buf);
    <<[[gengetwindow()]] return error>>
}
assert(image->chan != 0);
@

<<[[gengetwindow()]] sanity check srcp>>=
if(*scrp == nil){
    freeimage(d->screenimage);
    <<[[gengetwindow()]] return error>>
}
@

<<[[gengetwindow()]] sanity check winp>>=
if(*winp == nil){
    freescreen(*scrp);
    *scrp = nil;
    freeimage(image);
    <<[[gengetwindow()]] return error>>
}
@
% winp = nil is redundant in return error but ok.





<<[[gengetwindow()]] if already had a view, free it>>=
if(*winp != nil){
    _freeimage1(*winp);
    freeimage((*scrp)->image);
    freescreen(*scrp);
    *scrp = nil;
}
@
% not *winp = nil?

\t call freescreen atexit? seems not, but then kernel knows
% when graphical app terminate that can free the id of the screen?



\section{[[/dev/winname]] and [[screenname]]}

% kernel side now.

% default /dev/winname, so gengetwindow works also for bootstrap.

<<[[drawopen()]] switch qid cases>>=
case Qwinname:
    break;
@

<<[[drawread()]] if Qwinname>>=
if(QID(c->qid) == Qwinname)
    return readstr(off, a, n, screenname);
@

%\subsection{[[screename]]}
\n DName now in Image/Naming section

<<global screenname>>=
char    screenname[40];
@


<<[[makescreenimage()]] drawaddname>>=
if(!waserror()){
    snprint(screenname, sizeof screenname, "noborder.screen.%d", ++screennameid);
    drawaddname(nil, di, strlen(screenname), screenname);
    poperror();
}
@
% to bootstrap mechanism for /dev/winname!
% note that screen here is really screen, not Screen (desktop).
% noborder trick.
% drawaddname to draw_screen (screenimage) so made public so found
%  via initdraw for app running outside rio (and for rio itself)

<<global screennameid>>=
// gensym
static  int screennameid;
@

% drawlookupname for screename should always return screen_dimage!


% indirection to get image! go through a name!
% a bit like stdin/stdout = 0, 1, but behind the scene
% connected to different things.


% Rio will intercept this file as we will see in Windows.nw.
% It will create public images, and then make sure client can find them
% and "connect" to them.

%alt: why not pass down information via wsys instead like in newwindow?


\section{[[/dev/label]]}

%trans:
% /dev/winname is rio communicating info to client
% /dev/label is client communicating back info to rio

% so can identify the window when hidden

<<[[geninitdraw()]] write new label>>=
/*
 * Write label; ignore errors (we might not be running under rio)
 */
if(label){
    snprint(buf, sizeof buf, "%s/label", display->windir);
    fd = open(buf, OREAD);
    if(fd >= 0){
        read(fd, display->oldlabel, (sizeof display->oldlabel)-1);
        close(fd);
        fd = create(buf, OWRITE, 0666);
        if(fd >= 0){
            write(fd, label, strlen(label));
            close(fd);
        }
    }
}
@
% else? no error management here?

% read old label, because when app take over previous app
% e.g., when run colors inside terminal, then want to switch back
% to terminal label when color exits.


<<[[Display]] other fields>>=
char	oldlabel[64];
@

% restore old label
<<[[_closedisplay()]] restore oldlabel>>=
if(disp->oldlabel[0]){
    snprint(buf, sizeof buf, "%s/label", disp->windir);
    fd = open(buf, OWRITE);
    if(fd >= 0){
        write(fd, disp->oldlabel, strlen(disp->oldlabel));
        close(fd);
    }
}
@

% write back old label, so when app run from terminal,
% we restore back the label so the window manager
% can display better titles


\section{Additional mouse functions}

\subsection{The resize event}
\l mv in Windowing system support? but then need put Input chapter
\l  before Overlapping windows and windowing system support
\l or resize also valid outside windowing system when change resolution?

% a bit ugly but rio abuse /dev/mouse to indicate
% to client app that they have been resized
% by writing there a special message, r ...
%alt: could use a postnote?

<<[[Mousectl]] channel fields>>=
Channel	*resizec;	/* chan(int)[2] */
/* buffered in case client is waiting for a mouse action before handling resize */
@
% comment?
% 2?

<<[[initmouse()]] set channels>>=
mc->resizec = chancreate(sizeof(int), 2);
@


<<[[_ioproc()]] other locals (mouse.c)>>=
int one = 1;
@
<<[[_ioproc()]] switch buf, resize case, fallthrough m case (mouse.c)>>=
case 'r':
    send(mc->resizec, &one);
    /* fall through */
@



% in kernel

<<[[initscreenimage()]] other initializations>>=
mouseresize();
@
% wakeup processes waiting for resize event



\section{[[newwindow()]]}

% see graphics(2)
% must be called before initdraw, to not take over existing window
% but create a new one. Communicate with rio!

% ex newwindow("-dy 100 -hide")  will run in newly created window
%  of 100 pixels high hidden at first.

% /env/wsys is location of rio listening server (its fd to connect to)

<<function newwindow>>=
/* Connect us to new window, if possible */
errorneg1
newwindow(char *str)
{
    fdt fd;
    char *wsys;
    char buf[256];

    wsys = getenv("wsys");
    <<[[newwindow()]] sanity check wsys>>
    fd = open(wsys, ORDWR);
    free(wsys);
    <<[[newwindow()]] sanity check fd>>
    rfork(RFNAMEG);

    if(str)
        snprint(buf, sizeof buf, "new %s", str);
    else
        strcpy(buf, "new");

    return mount(fd, -1, "/dev", MBEFORE, buf);
}
@
% mount! need see Windows.nw


<<[[newwindow()]] sanity check wsys>>=
if(wsys == nil)
    return ERROR_NEG1;
@

<<[[newwindow()]] sanity check fd>>=
if(fd < 0)
    return ERROR_NEG1;
@




\t show code of wlabel scripts? or do that in Windows.nw?




\chapter{Non 32-Bits Images TODO}
\label{chap:non-true-color}

% Actually need Grey1 (many bitmasks), need CMAP (VGA), 
% need Grey8 (Cursor), need RGB16 (Raspberry), ...
% So need many of the logic that makes it possible to have
% images with pixels of different depth and different color arrangments.

<<[[ImageType] cases>>=
GREY2	= CHAN1(CGrey, 2),
GREY4	= CHAN1(CGrey, 4),
GREY8	= CHAN1(CGrey, 8),

RGB15	= CHAN4(CIgnore, 1, CRed, 5, CGreen, 5, CBlue, 5),
RGB24	= CHAN3(CRed, 8, CGreen, 8, CBlue, 8),
BGR24	= CHAN3(CBlue, 8, CGreen, 8, CRed, 8),
@
% RGB24 used for background image in rio, as no need for alpha

<<[[ImageChan]] cases>>=
CIgnore,
@
% used for padding to get byte boundaries for pixels.


% other formats for 32 bits, but less useful.
<<[[ImageType] cases>>=
ABGR32	= CHAN4(CAlpha, 8, CBlue, 8, CGreen, 8, CRed, 8),

XRGB32	= CHAN4(CIgnore, 8, CRed, 8, CGreen, 8, CBlue, 8),
XBGR32	= CHAN4(CIgnore, 8, CBlue, 8, CGreen, 8, CRed, 8),
@


\section{1-Bit images}
% or bitmasks

% GREY1, used for masks


% some kind of optimisations
<<[[memoptdraw()]] if 1 bit mask, src, and dest>>=
/*
 * If we have a 1-bit mask, 1-bit source, and 1-bit destination, and
 * they're all bit aligned, we can just use bit operators.  This happens
 * when we're manipulating boolean masks, e.g., in the arc code.
 */
if((par->state&(Simplemask|Simplesrc|Replmask|Replsrc))==0 
&& dst->chan==GREY1 
&& src->chan==GREY1 
&& par->mask->chan==GREY1 
&& (par->r.min.x&7)==(par->sr.min.x&7) 
&& (par->r.min.x&7)==(par->mr.min.x&7)){
    uchar *sp, *dp, *mp;
    uchar lm, rm;
    long swid, dwid, mwid;
    int i, x, dir;

    sp = byteaddr(src, par->sr.min);
    dp = byteaddr(dst, par->r.min);
    mp = byteaddr(par->mask, par->mr.min);
    swid = src->width*sizeof(ulong);
    dwid = dst->width*sizeof(ulong);
    mwid = par->mask->width*sizeof(ulong);

    if(src->data == dst->data 
    && byteaddr(dst, par->r.min) > byteaddr(src, par->sr.min)){
        dir = -1;
    }else
        dir = 1;

    lm = 0xFF>>(par->r.min.x&7);
    rm = 0xFF<<(8-(par->r.max.x&7));
    dx -= (8-(par->r.min.x&7)) + (par->r.max.x&7);

    if(dx < 0){	/* one byte wide */
        lm &= rm;
        if(dir == -1){
            dp += dwid*(dy-1);
            sp += swid*(dy-1);
            mp += mwid*(dy-1);
            dwid = -dwid;
            swid = -swid;
            mwid = -mwid;
        }
        for(y=0; y<dy; y++){
            *dp ^= (*dp ^ *sp) & *mp & lm;
            dp += dwid;
            sp += swid;
            mp += mwid;
        }
        return 1;
    }

    dx /= 8;
    if(dir == 1){
        i = (lm!=0)+dx+(rm!=0);
        mwid -= i;
        swid -= i;
        dwid -= i;
        for(y=0; y<dy; y++, dp+=dwid, sp+=swid, mp+=mwid){
            if(lm){
                *dp ^= (*dp ^ *sp++) & *mp++ & lm;
                dp++;
            }
            for(x=0; x<dx; x++){
                *dp ^= (*dp ^ *sp++) & *mp++;
                dp++;
            }
            if(rm){
                *dp ^= (*dp ^ *sp++) & *mp++ & rm;
                dp++;
            }
        }
        return 1;
    }else{
    /* dir == -1 */
        i = (lm!=0)+dx+(rm!=0);
        dp += dwid*(dy-1)+i-1;
        sp += swid*(dy-1)+i-1;
        mp += mwid*(dy-1)+i-1;
        dwid = -dwid+i;
        swid = -swid+i;
        mwid = -mwid+i;
        for(y=0; y<dy; y++, dp+=dwid, sp+=swid, mp+=mwid){
            if(rm){
                *dp ^= (*dp ^ *sp--) & *mp-- & rm;
                dp--;
            }
            for(x=0; x<dx; x++){
                *dp ^= (*dp ^ *sp--) & *mp--;
                dp--;
            }
            if(lm){
                *dp ^= (*dp ^ *sp--) & *mp-- & lm;
                dp--;
            }
        }
    }
    return 1;
}
@
% >> >> >> >>


\section{Small-depth images}

% Each time nbits[] is used in code before, it is handling
% small depth images (e.g., in writebyte() for alphadraw()).
% so there are more code than in this section related to
% small depth images.


<<[[pixelbits()]] other locals>>=
int off, npack;
@
<<[[pixelbits()]] switch bpp cases>>=
case 1:
case 2:
case 4:
    npack = 8/bpp;
    off = pt.x % npack;
    val = p[0] >> bpp*(npack-1-off);
    val &= (1<<bpp)-1;
    break;
@
% >>





<<[[imgtorgba()]] duplicate bits if nb less than 8>>=
// duplicate bits
while(nb < 8){
    v |= v<<nb;
    nb *= 2;
}
v >>= (nb-8);
@
% for GREY1? for RBG16? works?




<<[[byteaddr()]] if depth less than 8>>=
if(i->depth < 8){
    /*
     * We need to always round down,
     * but C rounds toward zero.
     */
    int np;
    np = 8/i->depth;
    if(p.x < 0)
        return a+(p.x-np+1)/np;
    else
        return a+p.x/np;
}
@

<<[[allocimagemix()]] if depth less than 8>>=
if(d->screenimage->depth <= 8){	/* create a 2x2 texture */
    t = allocimage(d, Rect(0,0,1,1), d->screenimage->chan, false, color1);
    if(t == nil)
        return nil;

    b = allocimage(d, Rect(0,0,2,2), d->screenimage->chan, true, color3);
    if(b == nil){
        freeimage(t);
        return nil;
    }

    draw(b, Rect(0,0,1,1), t, nil, ZP);
    freeimage(t);
    return b;
}
@


<<[[memoptdraw()]] locals for memset case>>=
int ppb, np, nb;
uchar lm, rm;
int d;
@

<<[[memoptdraw()]] when condition for memset, switch depth of dst cases>>=
case 1:
case 2:
case 4:
    for(d=dst->depth; d<8; d*=2)
        v |= (v<<d);
    ppb = 8/dst->depth;	/* pixels per byte */
    m = ppb-1;
    /* left edge */
    np = par->r.min.x&m;		/* no. pixels unused on left side of word */
    dx -= (ppb-np);
    nb = 8 - np * dst->depth;		/* no. bits used on right side of word */
    lm = (1<<nb)-1;
    DBG1("np %d x %d nb %d lm %ux ppb %d m %ux\n", np, par->r.min.x, nb, lm, ppb, m);	

    /* right edge */
    np = par->r.max.x&m;	/* no. pixels used on left side of word */
    dx -= np;
    nb = 8 - np * dst->depth;		/* no. bits unused on right side of word */
    rm = ~((1<<nb)-1);
    DBG1("np %d x %d nb %d rm %ux ppb %d m %ux\n", np, par->r.max.x, nb, rm, ppb, m);	

    DBG1("dx %d Dx %d\n", dx, Dx(par->r));
    /* lm, rm are masks that are 1 where we should touch the bits */
    if(dx < 0){	/* just one byte */
        lm &= rm;
        for(y=0; y<dy; y++, dp+=dwid)
            *dp ^= (v ^ *dp) & lm;
    }else if(dx == 0){	/* no full bytes */
        if(lm)
            dwid--;

        for(y=0; y<dy; y++, dp+=dwid){
            if(lm){
              DBG1("dp %p v %lux lm %ux (v ^ *dp) & lm %lux\n", dp, v, lm, (v^*dp)&lm);
                *dp ^= (v ^ *dp) & lm;
                dp++;
            }
            *dp ^= (v ^ *dp) & rm;
        }
    }else{		/* full bytes in middle */
        dx /= ppb;
        if(lm)
            dwid--;
        dwid -= dx;

        for(y=0; y<dy; y++, dp+=dwid){
            if(lm){
                *dp ^= (v ^ *dp) & lm;
                dp++;
            }
            memset(dp, v, dx);
            dp += dx;
            *dp ^= (v ^ *dp) & rm;
        }
    }
    return true;
@
% >> >> >> >>

<<[[memoptdraw()]] when condition for memset, switch depth of dst cases>>=
default:
    assert(0 /* bad dest depth in memoptdraw */);
@


<<[[setcolor()]] switch depth cases>>=
case 1:
case 2:
case 4:
    x = 0x0F;
    break;
@


<<[[readfn()]] if depth less than 8>>=
if(img->depth < 8)
    return readnbit;
@


<<function readnbit>>=
static Buffer
readnbit(Param *p, uchar *buf, int y)
{
    Buffer b;
    Memimage *img;
    uchar *repl, *r, *w, *ow, bits;
    int i, n, sh, depth, x, dx, npack, nbits;

    b.rgba = (ulong*)buf;
    b.grey = w = buf;
    b.red = b.blu = b.grn = w;
    b.alpha = &ones;
    b.delta = 1;

    dx = p->dx;
    img = p->img;
    depth = img->depth;
    repl = &replbit[depth][0];
    npack = 8/depth;
    sh = 8-depth;

    /* copy from p->r.min.x until end of repl rectangle */
    x = p->r.min.x;
    n = dx;
    if(n > p->img->r.max.x - x)
        n = p->img->r.max.x - x;

    r = p->bytermin + y*p->bwidth;
    DBG1("readnbit dx %d %p=%p+%d*%d, *r=%d fetch %d ", dx, r, p->bytermin, y, p->bwidth, *r, n);
    bits = *r++;
    nbits = 8;
    if(i=x&(npack-1)){
        DBG1("throwaway %d...", i);
        bits <<= depth*i;
        nbits -= depth*i;
    }
    for(i=0; i<n; i++){
        if(nbits == 0){
            DBG1("(%.2ux)...", *r);
            bits = *r++;
            nbits = 8;
        }
        *w++ = repl[bits>>sh];
        DBG1("bit %x...", repl[bits>>sh]);
        bits <<= depth;
        nbits -= depth;
    }
    dx -= n;
    if(dx == 0)
        return b;

    assert(x+i == p->img->r.max.x);

    /* copy from beginning of repl rectangle until where we were before. */
    x = p->img->r.min.x;
    n = dx;
    if(n > p->r.min.x - x)
        n = p->r.min.x - x;

    r = p->bytey0s + y*p->bwidth;
    DBG1("x=%d r=%p...", x, r);
    bits = *r++;
    nbits = 8;
    if(i=x&(npack-1)){
        bits <<= depth*i;
        nbits -= depth*i;
    }
    DBG1("nbits=%d...", nbits);
    for(i=0; i<n; i++){
        if(nbits == 0){
            bits = *r++;
            nbits = 8;
        }
        *w++ = repl[bits>>sh];
        DBG1("bit %x...", repl[bits>>sh]);
        bits <<= depth;
        nbits -= depth;
        DBG1("bits %x nbits %d...", bits, nbits);
    }
    dx -= n;
    if(dx == 0)
        return b;

    assert(dx > 0);
    /* now we have exactly one full scan line: just replicate the buffer itself until we are done */
    ow = buf;
    while(dx--)
        *w++ = *ow++;

    return b;
}
@
% >> 

<<[[writefn()]] if depth less than 8>>=
if(img->depth < 8)
    return writenbit;
@

<<function writenbit>>=
static void
writenbit(Param *p, uchar *w, Buffer src)
{
    uchar *r;
    ulong bits;
    int i, sh, depth, npack, nbits, x, ex;

    assert(src.grey != nil && src.delta == 1);

    x = p->r.min.x;
    ex = x+p->dx;
    depth = p->img->depth;
    npack = 8/depth;

    i=x&(npack-1);
    bits = i ? (*w >> (8-depth*i)) : 0;
    nbits = depth*i;
    sh = 8-depth;
    r = src.grey;

    for(; x<ex; x++){
        bits <<= depth;
        DBG1(" %x", *r);
        bits |= (*r++ >> sh);
        nbits += depth;
        if(nbits == 8){
            *w++ = bits;
            nbits = 0;
        }
    }

    if(nbits){
        sh = 8-nbits;
        bits <<= sh;
        bits |= *w & ((1<<sh)-1);
        *w = bits;
    }
    DBG1("\n");
    return;
}
@
% >> >>





<<[[loadmemimage()]] other locals>>=
int mx, m, mr;
@

<<[[loadmemimage()]] set mx, lpart, rpart, m for small depth images>>=
mx = 7 / i->depth;
lpart = (r.min.x & mx) * i->depth;
rpart = (r.max.x & mx) * i->depth;
m = 0xFF >> lpart;
@

<<[[loadmemimage()]] if 1 byte per line>>=
/* may need to do bit insertion on edges */
if(l == 1){	/* all in one byte */
    if(rpart)
        m ^= 0xFF >> rpart;
    for(y = r.min.y; y < r.max.y; y++){
        *q ^= (*data ^ *q) & m;
        q += i->width*sizeof(ulong);
        data++;
    }
    return ndata;
}
@
% more an opti than a small depth images, but still has some pieces of code
%  related to small depth images



<<[[loadmemimage()]] when small depth images>>=
mr = 0xFF ^ (0xFF >> rpart);
if(lpart!=0 && rpart==0){
    for(y=r.min.y; y<r.max.y; y++){
        *q ^= (*data^*q) & m;
        if(l > 1)
            memmove(q+1, data+1, l-1);
        q += i->width*sizeof(ulong);
        data += l;
    }
    return ndata;
}
if(lpart==0 && rpart!=0){
    for(y=r.min.y; y<r.max.y; y++){
        if(l > 1)
            memmove(q, data, l-1);
        q[l-1] ^= (data[l-1]^q[l-1]) & mr;
        q += i->width*sizeof(ulong);
        data += l;
    }
    return ndata;
}
for(y=r.min.y; y<r.max.y; y++){
    *q ^= (*data^*q) & m;
    if(l > 2)
        memmove(q+1, data+1, l-2);
    q[l-1] ^= (data[l-1]^q[l-1]) & mr;
    q += i->width*sizeof(ulong);
    data += l;
}
return ndata;
@



\section{8-bits images}

<<[[memoptdraw()]] when condition for memset, switch depth of dst cases>>=
case 8:
    for(y=0; y < dy; y++, dp += dwid)
        memset(dp, v, dx);
    return true;
@

<<[[chardraw()]] switch depth cases>>=
case 8:
    DBG1("8loop...");
    wc = wp;
    for(x=bx; x>ex; x--, wc++){
        i = x&7;
        if(i == 8-1)
            bits = *q++;
        DBG1("bits %lux sh %d...", bits, i);
        if((bits>>i)&1)
            *wc = v;
    }
    break;
@

<<[[getcolor()]] switch depth cases>>=
case 8:
    x = 0xFF;
    break;
@

<<[[setcolor()]] switch depth cases>>=
case 8:
    x = 0xFF;
    break;
@


\section{16-bits images}

% called high color

% raspberry is in RGB16 by default

<<[[pixelbits()]] switch bpp cases>>=
case 16:
    val = p[0]|(p[1]<<8);
    break;
@
% >>

<<[[memoptdraw()]] when condition for memset, switch depth of dst cases>>=
case 16:
    p[0] = v;		/* make little endian */
    p[1] = v>>8;
    v = *(ushort*)p;
    DBG("dp=%p; dx=%d; for(y=0; y<%d; y++, dp+=%d)\nmemsets(dp, v, dx);\n",         	dp, dx, dy, dwid);
    for(y=0; y<dy; y++, dp+=dwid)
        memsets(dp, v, dx);
    return 1;
@

<<function memsets>>=
static void
memsets(void *vp, ushort val, int n)
{
    ushort *p, *ep;

    p = vp;
    ep = p+n;
    while(p<ep)
        *p++ = val;
}
@


<<[[chardraw()]] switch depth cases>>=
case 16:
    ws = (ushort*)wp;
    v = *(ushort*)sp;
    for(x=bx; x>ex; x--, ws++){
        i = x&7;
        if(i == 8-1)
            bits = *q++;
        DBG1("bits %lux sh %d...", bits, i);
        if((bits>>i)&1)
            *ws = v;
    }
    break;
@


\section{24-bits images}

% called true color

<<[[pixelbits()]] switch bpp cases>>=
case 24:
    val = p[0]|(p[1]<<8)|(p[2]<<16);
    break;
@
% >> >>

<<[[memoptdraw()]] when condition for memset, switch depth of dst cases>>=
case 24:
    for(y=0; y<dy; y++, dp+=dwid)
        memset24(dp, v, dx);
    return 1;
@

<<function memset24>>=
void
memset24(void *vp, ulong val, int n)
{
    uchar *p, *ep;
    uchar a,b,c;

    p = vp;
    ep = p+3*n;

    a = val;
    b = val>>8;
    c = val>>16;
    while(p<ep){
        *p++ = a;
        *p++ = b;
        *p++ = c;
    }
}
@

<<[[memfillcolor()]] other colors>>=
int y;
@

<<[[memfillcolor()]] switch depth cases>>=
case 24:	/* 24-bit images suck */
    for(y=i->r.min.y; y<i->r.max.y; y++)
        memset24(byteaddr(i, Pt(i->r.min.x, y)), bits, Dx(i->r));
    break;
@


<<[[chardraw()]] switch depth cases>>=
case 24:
    wc = wp;
    for(x=bx; x>ex; x--, wc+=3){
        i = x&7;
        if(i == 8-1)
            bits = *q++;
        DBG1("bits %lux sh %d...", bits, i);
        if((bits>>i)&1){
            wc[0] = sp[0];
            wc[1] = sp[1];
            wc[2] = sp[2];
        }
    }
    break;
@



\section{Gray-scale images}

<<[[imgtorgba()]] switch chan type cases>>=
case CGrey:
    r = g = b = v;
    break;
@

<<[[rgbatoimg()]] switch chan type cases>>=
case CGrey:
    m = RGB2K(r,g,b);
    v |= (m>>(8-nb))<<d;
    break;
@
% >>


<<function RGB2K>>=
/* perfect approximation to NTSC = .299r+.587g+.114b when 0 ≤ r,g,b < 256 */
#define RGB2K(r,g,b)	((156763*(r)+307758*(g)+59769*(b))>>19)
@


% Lots of isgrey fields and parameters. I could aspectize even more.

<<[[readbyte()]] in simple case, if isgrey>>=
if(isgrey){
    b.grey = r + img->shift[CGrey]/8;
    b.red = b.grn = b.blu = b.grey;
@


<<[[writebyte()]] if isgrey>>=
if(isgrey){
    u |= ((*grey >> (8-img->nbits[CGrey])) & img->mask[CGrey]) << img->shift[CGrey];
    grey += delta;
}
@
% >> >>


<<[[alphacalc11()]] if isgrey>>=
if(grey){
    *bdst.grey = MUL(ma, *bsrc.grey, s) + MUL(fd, *bdst.grey, t);
    bsrc.grey += bsrc.delta;
    bdst.grey += bdst.delta;
}
@


\section{Images with a color map}
\label{sec:colormap}

% remember that CMap is enum in core DS.

% need color map if use RGBA32? No but VGA seems to be limited to depth 8 :(

% color(2), color(6)

\subsection{[[RGB]]}

<<struct RGB>>=
struct RGB
{
    ulong	red;
    ulong	green;
    ulong	blue;
};
@

\subsection{[[Memcmap]]}

<<[[MemImage]] other fields>>=
Memcmap	*cmap;
@

<<struct Memcmap>>=
struct Memcmap
{
    // map<colorcmap8, (reg8, green8, blue8)>
    byte	cmap2rgb[3*256];
    // map<(red4,green4,blue4), colorcmap8)
    byte	rgb2cmap[16*16*16];
};
@
% 3*256 so extract rgb from color of cmap.
% use 4 bytes only of r,g, or b  so 16 red variant x 16 green x 16 blue.


<<global memdefcmap>>=
Memcmap *memdefcmap = &def;
@
% def is big array in libmemdraw/cmap.c
% used in allocmemimaged


%dead? bcm does something different?
<<[[memimageinit()]] initializations>>=
_memmkcmap();
@
<<function _memmkcmap>>=
void _memmkcmap(void){}
@

\subsection{Conversions}

<<[[imgtorgba()]] other locals>>=
byte *p;
int ov;
@

<<[[imgtorgba()]] switch chan type cases>>=
case CMap:
    p = img->cmap->cmap2rgb + 3*ov;
    r = *p++;
    g = *p++;	
    b = *p;
    break;
@
% but only CMap is CMAP8 so ov should be equal to v.
% more on this later

<<[[rgbatoimg()]] other locals>>=
byte *p;
byte m;
@

<<[[rgbatoimg()]] switch chan type cases>>=
case CMap:
    p = img->cmap->rgb2cmap;
    m = p[(r>>4)*256+(g>>4)*16+(b>>4)];
    v |= (m>>(8-nb))<<d;
    break;
@
% >>




% seems dead now that use memdefcmap or maybe was used to generate
%  memdefcmap

% there is an optimized but less appealing version in comment below

%dead?
<<function rgb2cmap>>=
int
rgb2cmap(int cr, int cg, int cb)
{
    int i, r, g, b, sq;
    ulong rgb;
    int best, bestsq;

    best = 0;
    bestsq = 0x7FFFFFFF;
    // find best candidate
    for(i=0; i<256; i++){
        rgb = cmap2rgb(i);
        r = (rgb>>16) & 0xFF;
        g = (rgb>>8) & 0xFF;
        b = (rgb>>0) & 0xFF;
        sq = (r-cr)*(r-cr)+(g-cg)*(g-cg)+(b-cb)*(b-cb);
        if(sq < bestsq){
            bestsq = sq;
            best = i;
        }
    }
    return best;
}
@

%dead?
<<function cmap2rgb>>=
int
cmap2rgb(int c)
{
    int j, num, den, r, g, b, v, rgb;

    r = c>>6;
    v = (c>>4)&3;
    j = (c-v+r)&15;
    g = j>>2;
    b = j&3;
    den=r;
    if(g>den)
        den=g;
    if(b>den)
        den=b;
    if(den==0) {
        v *= 17;
        rgb = (v<<16)|(v<<8)|v;
    }
    else{
        num=17*(4*den+v);
        rgb = ((r*num/den)<<16)|((g*num/den)<<8)|(b*num/den);
    }
    return rgb;
}
@
% >> >> >> >>


%dead?
<<function cmap2rgba>>=
int
cmap2rgba(int c)
{
    return (cmap2rgb(c)<<8)|0xFF;
}
@
% >> 








<<[[readfn()]] if cmap>>=
if(img->nbits[CMap] == 8)
    return readcmap;
@

<<[[writefn()]] if cmap>>=
if(img->chan == CMAP8)
    return writecmap;
@
% why different test than readfn??

<<function readcmap>>=
static Buffer
readcmap(Param *p, uchar *buf, int y)
{
    Buffer b;
    int a, convgrey, copyalpha, dx, i, m;
    uchar *q, *cmap, *begin, *end, *r, *w;

    begin = p->bytey0s + y*p->bwidth;
    r = p->bytermin + y*p->bwidth;
    end = p->bytey0e + y*p->bwidth;

    cmap = p->img->cmap->cmap2rgb;
    convgrey = p->convgrey;
    copyalpha = (p->img->flags&Falpha) ? 1 : 0;

    w = buf;
    dx = p->dx;
    if(copyalpha){
        b.alpha = buf++;
        a = p->img->shift[CAlpha]/8;
        m = p->img->shift[CMap]/8;
        for(i=0; i<dx; i++){
            *w++ = r[a];
            q = cmap+r[m]*3;
            r += 2;
            if(r == end)
                r = begin;
            if(convgrey){
                *w++ = RGB2K(q[0], q[1], q[2]);
            }else{
                *w++ = q[2];	/* blue */
                *w++ = q[1];	/* green */
                *w++ = q[0];	/* red */
            }
        }
    }else{
        b.alpha = &ones;
        for(i=0; i<dx; i++){
            q = cmap+*r++*3;
            if(r == end)
                r = begin;
            if(convgrey){
                *w++ = RGB2K(q[0], q[1], q[2]);
            }else{
                *w++ = q[2];	/* blue */
                *w++ = q[1];	/* green */
                *w++ = q[0];	/* red */
            }
        }
    }

    b.rgba = (ulong*)(buf-copyalpha);

    if(convgrey){
        b.grey = buf;
        b.red = b.blu = b.grn = buf;
        b.delta = 1+copyalpha;
    }else{
        b.blu = buf;
        b.grn = buf+1;
        b.red = buf+2;
        b.grey = nil;
        b.delta = 3+copyalpha;
    }
    return b;
}
@


<<function writecmap>>=
static void
writecmap(Param *p, uchar *w, Buffer src)
{
    uchar *cmap, *red, *grn, *blu;
    int i, dx, delta;

    cmap = p->img->cmap->rgb2cmap;
    
    delta = src.delta;
    red = src.red;
    grn = src.grn;
    blu = src.blu;

    dx = p->dx;
    for(i=0; i<dx; i++, red+=delta, grn+=delta, blu+=delta)
        *w++ = cmap[(*red>>4)*256+(*grn>>4)*16+(*blu>>4)];
}
@
% shift right 4 so remains 4 bytes, 16 possible values


\subsection{API}

<<function readcolmap>>=
void
readcolmap(Display *d, RGB *colmap)
{
    int i;
    char *p, *q;
    Biobuf *b;
    char buf[128];

    sprint(buf, "/dev/draw/%d/colormap", d->dirno);
    b = Bopen(buf, OREAD);
    if(b == 0)
        drawerror(d, "rdcolmap: can't open colormap device");

    for(;;) {
        p = Brdline(b, '\n');
        if(p == 0)
            break;
        i = strtoul(p, &q, 0);
        if(i < 0 || i > 255) {
            fprint(2, "rdcolmap: bad index\n");
            exits("bad");
        }
        p = q;
        colmap[255-i].red = getval(&p);
        colmap[255-i].green = getval(&p);
        colmap[255-i].blue = getval(&p);
    }
    Bterm(b);
}
@
%old:    //USED(screen);

<<function getval>>=
static ulong
getval(char **p)
{
    ulong v;
    char *q;

    v = strtoul(*p, &q, 0);
    v |= v<<8;
    v |= v<<16;
    *p = q;
    return v;
}
@
% >> >>



<<function writecolmap>>=
/*
 * This code (and the devdraw interface) will have to change
 * if we ever get bitmaps with ldepth > 3, because the
 * colormap will have to be written in chunks
 */
void
writecolmap(Display *d, RGB *m)
{
    int i, n, fd;
    char buf[64], *t;
    ulong r, g, b;

    sprint(buf, "/dev/draw/%d/colormap", d->dirno);
    fd = open(buf, OWRITE);
    if(fd < 0)
        drawerror(d, "writecolmap: open colormap failed");
    t = malloc(8192);
    if (t == nil)
        drawerror(d, "writecolmap: no memory");
    n = 0;
    for(i = 0; i < 256; i++) {
        r = m[i].red>>24;
        g = m[i].green>>24;
        b = m[i].blue>>24;
        n += sprint(t+n, "%d %lud %lud %lud\n", 255-i, r, g, b);
    }
    i = write(fd, t, n);
    free(t);
    close(fd);
    if(i != n)
        drawerror(d, "writecolmap: bad write");
}
@




\subsection{[[/dev/draw/x/colormap]]}
\label{sec:colormap-device}

<<[[drawread()]] other locals>>=
uchar *p;
int index, m;
ulong red, green, blue;
ulong offset = off;
@

<<[[drawread()]] switch qid cases>>=
case Qcolormap:
    drawactive(true);  /* to restore map from backup */
    p = malloc(4*12*256+1);
    if(p == nil)
        error(Enomem);
    m = 0;
    for(index = 0; index < 256; index++){
        arch_getcolor(index, &red, &green, &blue);
        m += snprint((char*)p+m, 4*12*256+1 - m,
            "%11d %11lud %11lud %11lud\n", index,
            red>>24, green>>24, blue>>24);
    }
    n = readstr(offset, a, n, (char*)p);
    free(p);
    break;
@



<<[[drawwrite()]] other locals>>=
char buf[128], *fields[4], *q;
int i, m, red, green, blue, x;
@


<<[[drawwrite()]] switch qid cases>>=
case Qcolormap:
    drawactive(true);  /* to restore map from backup */
    m = n;
    n = 0;
    while(m > 0){
        x = m;
        if(x > sizeof(buf)-1)
            x = sizeof(buf)-1;
        q = memccpy(buf, a, '\n', x);
        if(q == 0)
            break;
        i = q-buf;
        n += i;
        a = (char*)a + i;
        m -= i;
        *q = 0;
        if(tokenize(buf, fields, nelem(fields)) != 4)
            error(Ebadarg);
        i = strtoul(fields[0], 0, 0);
        red = strtoul(fields[1], 0, 0);
        green = strtoul(fields[2], 0, 0);
        blue = strtoul(fields[3], &q, 0);
        if(fields[3] == q)
            error(Ebadarg);
        if(red>255 || green>255 || blue>255 || i<0 || i>255)
            error(Ebadarg);
        red |= red<<8;
        red |= red<<16;
        green |= green<<8;
        green |= green<<16;
        blue |= blue<<8;
        blue |= blue<<16;
        arch_setcolor(i, red, green, blue);
    }
    break;
@
% >> >> >> >> >> >> >>


\subsection{Hardware support hook (x86)}

% drawread | blankscreen -> <>, part of screen.h interface now
<<function getcolor(x86)>>=
void
arch_getcolor(ulong p, ulong* pr, ulong* pg, ulong* pb)
{
    VGAscr *scr;
    ulong x;

    scr = &vgascreen;
    if(gscreen == nil)
        return;

    switch(gscreen->depth){
    default:
        x = 0x0F;
        break;
    <<[[getcolor()]] switch depth cases>>
    }
    p &= x;

    lock(&cursor);
    *pr = scr->colormap[p][0];
    *pg = scr->colormap[p][1];
    *pb = scr->colormap[p][2];
    unlock(&cursor);
}
@


\subsubsection{[[drawcmap()]] and [[setcolor()]]}

<<[[screensize()]] initializations part2>>=
drawcmap();
@

<<function drawcmap>>=
/*
 * On 8 bit displays, load the default color map
 */
void
drawcmap(void)
{
    int r, g, b;
    int cr, cg, cb, v;
    int num, den;
    int i, j;

    drawactive(true);  /* to restore map from backup */
    for(r=0,i=0; r!=4; r++)
        for(v=0; v!=4; v++,i+=16){
        for(g=0,j=v-r; g!=4; g++)
            for(b=0;b!=4;b++,j++){
            den = r;
            if(g > den)
                den = g;
            if(b > den)
                den = b;
            if(den == 0)    /* divide check -- pick grey shades */
                cr = cg = cb = v*17;
            else{
                num = 17*(4*den+v);
                cr = r*num/den;
                cg = g*num/den;
                cb = b*num/den;
            }
            arch_setcolor(i+(j&15),
                cr*0x01010101, cg*0x01010101, cb*0x01010101);
            }
    }
}
@



% drawread | blankscreen -> <>, part of screen.h interface now
<<function setcolor(x86)>>=
/*
 * On some video cards (e.g., Mach64), the palette is used as the 
 * DAC registers for >8-bit modes.  We don't want to set them when the user
 * is trying to set a colormap and the card is in one of these modes.
 */
int
arch_setcolor(ulong p, ulong r, ulong g, ulong b)
{
    int x;

    if(gscreen == nil)
        return 0;

    switch(gscreen->depth){
    <<[[setcolor()]] switch depth cases>>
    default:
        return 0;
    }
    p &= x;

    return setpalette(p, r, g, b);
}
@
%old: simplified gscreen so no need 
%    scr = &vgascreen;

\subsubsection{[[setpalette()]]}


<<[[screensize()]] vga settings>>=
scr->palettedepth = 6;  /* default */
@

% setcolor -> <>
<<function setpalette(x86)>>=
int
setpalette(ulong p, ulong r, ulong g, ulong b)
{
    VGAscr *scr;
    int d;

    scr = &vgascreen;
    d = scr->palettedepth;

    lock(&cursor);
    scr->colormap[p][0] = r;
    scr->colormap[p][1] = g;
    scr->colormap[p][2] = b;
    vgao(PaddrW, p);
    vgao(Pdata, r>>(32-d));
    vgao(Pdata, g>>(32-d));
    vgao(Pdata, b>>(32-d));
    unlock(&cursor);

    return ~0;
}
@






\chapter{Advanced Topics TODO}
\label{chap:advanced}

%\section{Image naming?} Better before.
%\section{JPG}
% libimg/

\section{Advanced shapes}

\subsection{Special line ends}

\subsubsection{Disc}

<<[[_memimageline()]] switch end0 cases, fallthrough to Endsquare>>=
case Enddisc:
    discend(p0, radius, dst, src, d, op);
    /* fall through */
@
<<[[_memimageline()]] switch end1 cases, fallthrough to Endsquare>>=
case Enddisc:
    discend(p1, radius, dst, src, d, op);
    /* fall through */
@

<<function discend>>=
static
void
discend(Point p, int radius, Memimage *dst, Memimage *src, Point dsrc, int op)
{
    Memimage *disc;
    Rectangle r;

    disc = membrush(radius);
    if(disc != nil){
        r.min.x = p.x - radius;
        r.min.y = p.y - radius;
        r.max.x = p.x + radius+1;
        r.max.y = p.y + radius+1;
        memdraw(dst, r, src, addpt(r.min, dsrc), disc, Pt(0,0), op);
    }
}
@

<<function membrush>>=
static Memimage*
membrush(int radius)
{
    static Memimage *brush;
    static int brushradius;

    if(brush == nil || brushradius != radius){
        freememimage(brush);
        brush = allocmemimage(Rect(0, 0, 2*radius+1, 2*radius+1), memopaque->chan);
        if(brush != nil){
            memfillcolor(brush, DTransparent);	/* zeros */
            memellipse(brush, Pt(radius, radius), radius, radius, -1, memopaque, Pt(radius, radius), S);
        }
        brushradius = radius;
    }

    return brush;
}
@

% so memline -> ... ->  memellipse ( -> memdraw)

\subsubsection{Arrows}

\paragraph{[[ARROW()]]}

<<function ARROW>>=
#define	ARROW(a, b, c)	(Endarrow|((a)<<5)|((b)<<14)|((c)<<23))
@
% see draw(2) for explanations and arrowend() below
%  x1 = (end>>5) & 0x1FF;	/* distance along line from end of line to tip */
%  x2 = (end>>14) & 0x1FF;	/* distance along line from barb to tip */
%  x3 = (end>>23) & 0x1FF;	/* distance perpendicular from edge of line to b
% >> >> >> >> >>

% advanced topics?
<<enum _anon_ (lib_graphics/libmemdraw/line.c)>>=
enum
{
    Arrow1 = 8,
    Arrow2 = 10,
    Arrow3 = 3,
};
@

\paragraph{[[_memimageline()]] and arrows}

<<[[_memimageline()]] switch end0 cases>>=
case Endarrow:
    arrowend(q, pp, end0, -sin, -cos, radius);
    _memfillpolysc(dst, pts, 5, ~0, src, 
                   addpt(pts[0], mulpt(d, ICOSSCALE)), 
                   true, 10, true, op);
    pp[1] = pp[4];
    pp += 2;
    break;
@
% detail parameter on!

<<[[_memimageline()]] switch end1 cases>>=
case Endarrow:
    arrowend(q, pp, end1, sin, cos, radius);
    _memfillpolysc(dst, pp, 5, ~0, src, 
                   addpt(pp[0], mulpt(d, ICOSSCALE)), 
                   true, 10, true, op);
    pp[1] = pp[4];
    pp += 2;
    break;
@

% detail on


<<function arrowend>>=
static
void
arrowend(Point tip, Point *pp, int end, int sin, int cos, int radius)
{
    int x1, x2, x3;

    /* before rotation */
    if(end == Endarrow){
        x1 = Arrow1;
        x2 = Arrow2;
        x3 = Arrow3;
    }else{
        x1 = (end>>5) & 0x1FF;	/* distance along line from end of line to tip */
        x2 = (end>>14) & 0x1FF;	/* distance along line from barb to tip */
        x3 = (end>>23) & 0x1FF;	/* distance perpendicular from edge of line to barb */
    }

    /* comments follow track of right-facing arrowhead */
    pp->x = tip.x+((2*radius+1)*sin/2-x1*cos);		/* upper side of shaft */
    pp->y = tip.y-((2*radius+1)*cos/2+x1*sin);
    pp++;
    pp->x = tip.x+((2*radius+2*x3+1)*sin/2-x2*cos);		/* upper barb */
    pp->y = tip.y-((2*radius+2*x3+1)*cos/2+x2*sin);
    pp++;
    pp->x = tip.x;
    pp->y = tip.y;
    pp++;
    pp->x = tip.x+(-(2*radius+2*x3+1)*sin/2-x2*cos);	/* lower barb */
    pp->y = tip.y-(-(2*radius+2*x3+1)*cos/2+x2*sin);
    pp++;
    pp->x = tip.x+(-(2*radius+1)*sin/2-x1*cos);		/* lower side of shaft */
    pp->y = tip.y+((2*radius+1)*cos/2-x1*sin);
}
@

\paragraph{detail and [[yscan()]]}

<<[[xscan()]] if detail>>=
if(ix == ix2 && detail) {
    if(xerr*p[0]->den + p[0]->zerr*xden > p[0]->den*xden)
        x++;
    ix = (x + x2) >> (fixshift+1);
    ix2 = ix+1;
}
@

<<[[_memfillpolysc()]] if detail>>=
if(detail)
    yscan(dst, seg, segtab, nvert, w, src, sp, fixshift, op);
@

<<function xcompare>>=
static int
xcompare(void *a, void *b)
{
    Seg **s0, **s1;
    long x0, x1;

    s0 = a;
    s1 = b;
    x0 = (*s0)->p0.x;
    x1 = (*s1)->p0.x;

    if(x0 < x1)
        return -1;
    if(x0 == x1)
        return 0;
    return 1;
}
@


<<function yscan>>=
static void
yscan(Memimage *dst, Seg **seg, Seg *segtab, int nseg, int wind, Memimage *src, Point sp, int fixshift, int op)
{
    long x, maxx, y, y2, yerr, yden, onehalf;
    Seg **ep, **next, **p, **q, *s;
    int n, i, ix, cnt, iy, iy2, miny, maxy;
    Point pt;

    for(i=0, s=segtab, p=seg; i<nseg; i++, s++) {
        *p = s;
        if(s->p0.x == s->p1.x)
            continue;
        if(s->p0.x > s->p1.x) {
            pt = s->p0;
            s->p0 = s->p1;
            s->p1 = pt;
            s->d = -s->d;
        }
        s->num = s->p1.y - s->p0.y;
        s->den = s->p1.x - s->p0.x;
        s->dz = sdiv(s->num, s->den) << fixshift;
        s->dzrem = mod(s->num, s->den) << fixshift;
        s->dz += sdiv(s->dzrem, s->den);
        s->dzrem = mod(s->dzrem, s->den);
        p++;
    }
    n = p-seg;
    if(n == 0)
        return;
    *p = 0;
    qsort(seg, n , sizeof(Seg*), xcompare);

    onehalf = 0;
    if(fixshift)
        onehalf = 1 << (fixshift-1);

    miny = dst->clipr.min.y;
    maxy = dst->clipr.max.y;

    x = seg[0]->p0.x;
    if(x < (dst->clipr.min.x << fixshift))
        x = dst->clipr.min.x << fixshift;
    ix = (x + onehalf) >> fixshift;
    x = (ix << fixshift) + onehalf;
    maxx = dst->clipr.max.x << fixshift;

    ep = next = seg;

    while(x<maxx) {
        for(q = p = seg; p < ep; p++) {
            s = *p;
            if(s->p1.x < x)
                continue;
            s->z += s->dz;
            s->zerr += s->dzrem;
            if(s->zerr >= s->den) {
                s->z++;
                s->zerr -= s->den;
                if(s->zerr < 0 || s->zerr >= s->den)
                    print("bad ratzerr1: %ld den %ld ratdzrem %ld\n", s->zerr, s->den, s->dzrem);
            }
            *q++ = s;
        }

        for(p = next; *p; p++) {
            s = *p;
            if(s->p0.x >= x)
                break;
            if(s->p1.x < x)
                continue;
            s->z = s->p0.y;
            s->z += smuldivmod(x - s->p0.x, s->num, s->den, &s->zerr);
            if(s->zerr < 0 || s->zerr >= s->den)
                print("bad ratzerr2: %ld den %ld ratdzrem %ld\n", s->zerr, s->den, s->dzrem);
            *q++ = s;
        }
        ep = q;
        next = p;

        if(ep == seg) {
            if(*next == 0)
                break;
            ix = (next[0]->p0.x + onehalf) >> fixshift;
            x = (ix << fixshift) + onehalf;
            continue;
        }

        zsort(seg, ep);

        for(p = seg; p < ep; p++) {
            cnt = 0;
            y = p[0]->z;
            yerr = p[0]->zerr;
            yden = p[0]->den;
            iy = (y + onehalf) >> fixshift;
            if(iy >= maxy)
                break;
            if(iy < miny)
                iy = miny;
            cnt += p[0]->d;
            p++;
            for(;;) {
                if(p == ep) {
                    print("yscan: fill to infinity");
                    return;
                }
                cnt += p[0]->d;
                if((cnt&wind) == 0)
                    break;
                p++;
            }
            y2 = p[0]->z;
            iy2 = (y2 + onehalf) >> fixshift;
            if(iy2 <= miny)
                continue;
            if(iy2 > maxy)
                iy2 = maxy;
            if(iy == iy2) {
                if(yerr*p[0]->den + p[0]->zerr*yden > p[0]->den*yden)
                    y++;
                iy = (y + y2) >> (fixshift+1);
                fillpoint(dst, ix, iy, src, sp, op);
            }
        }
        x += (1<<fixshift);
        ix++;
    }
}
@
% >> >> >> >>

<<function fillpoint>>=
static void
fillpoint(Memimage *dst, int x, int y, Memimage *src, Point p, int op)
{
    Rectangle r;

    r.min.x = x;
    r.min.y = y;
    r.max.x = x+1;
    r.max.y = y+1;
    p.x += x;
    p.y += y;
    memdraw(dst, r, src, p, memopaque, p, op);
}
@



\subsection{Bezier curves}
% spline



% no special message, it just uses the previous building blocks.

% a primer on bezier and splines:
% https://pomax.github.io/bezierinfo/

\subsubsection{[[Plist]]}

<<constant PINC>>=
#define	PINC	32		/* realloc granularity */
@

<<struct Plist>>=
struct Plist
{
    Point *p;
    int np;			/* -1 if malloc/realloc failed */
};
@

<<function appendpt>>=
static void
appendpt(Plist *l, Point p)
{
    if(l->np == -1)
        return;

    if(l->np == 0)
        l->p = malloc(PINC*sizeof(Point));
    else if(l->np % PINC == 0)
        l->p = realloc(l->p, (l->np+PINC)*sizeof(Point));

    if(l->p == nil){
        l->np = -1;
        return;
    }
    l->p[l->np++] = p;
}
@

\subsubsection{API}

<<function bezier>>=
error0
bezier(Image *dst, Point p0, Point p1, Point p2, Point p3, int end0, int end1, int radius, Image *src, Point sp)
{
    return bezierop(dst, p0, p1, p2, p3, end0, end1, radius, src, sp, SoverD);
}
@

<<function bezierop>>=
error0
bezierop(Image *dst, Point p0, Point p1, Point p2, Point p3, int end0, int end1, int radius, Image *src, Point sp, Drawop op)
{
    Plist l;

    l.np = 0;
    bezierpts(&l, p0, p1, p2, p3);
    if(l.np == -1)
        return ERROR_0;
    if(l.np != 0){
        polyop(dst, l.p, l.np, end0, end1, radius, src, addpt(subpt(sp, p0), l.p[0]), op);
        free(l.p);
    }
    return OK_1;
}
@
% so does not use arc? use polyop?

<<function bezspline>>=
error0
bezspline(Image *dst, Point *pt, int npt, int end0, int end1, int radius, Image *src, Point sp)
{
    return bezsplineop(dst, pt, npt, end0, end1, radius, src, sp, SoverD);
}
@

<<function bezsplineop>>=
error0
bezsplineop(Image *dst, Point *pt, int npt, int end0, int end1, int radius, Image *src, Point sp, Drawop op)
{
    Plist l;

    l.np = 0;
    _bezsplinepts(&l, pt, npt);
    if(l.np==-1)
        return ERROR_0;
    if(l.np != 0){
        polyop(dst, l.p, l.np, end0, end1, radius, src, addpt(subpt(sp, pt[0]), l.p[0]), op);
        free(l.p);
    }
    return OK_1;
}
@

<<function fillbezier>>=
error0
fillbezier(Image *dst, Point p0, Point p1, Point p2, Point p3, int w, Image *src, Point sp)
{
    return fillbezierop(dst, p0, p1, p2, p3, w, src, sp, SoverD);
}
@

<<function fillbezierop>>=
error0
fillbezierop(Image *dst, Point p0, Point p1, Point p2, Point p3, int w, Image *src, Point sp, Drawop op)
{
    Plist l;

    l.np = 0;
    bezierpts(&l, p0, p1, p2, p3);
    if(l.np == -1)
        return ERROR_0;
    if(l.np != 0){
        fillpolyop(dst, l.p, l.np, w, src, addpt(subpt(sp, p0), l.p[0]), op);
        free(l.p);
    }
    return OK_1;
}
@


<<function fillbezspline>>=
error0
fillbezspline(Image *dst, Point *pt, int npt, int w, Image *src, Point sp)
{
    return fillbezsplineop(dst, pt, npt, w, src, sp, SoverD);
}
@

<<function fillbezsplineop>>=
error0
fillbezsplineop(Image *dst, Point *pt, int npt, int w, Image *src, Point sp, Drawop op)
{
    Plist l;

    l.np = 0;
    _bezsplinepts(&l, pt, npt);
    if(l.np == -1)
        return ERROR_0;
    if(l.np > 0){
        fillpolyop(dst, l.p, l.np, w, src, addpt(subpt(sp, pt[0]), l.p[0]), op);
        free(l.p);
    }
    return OK_1;
}
@


% part of API for people who want to inspect what is computed maybe
<<function bezsplinepts>>=
int
bezsplinepts(Point *pt, int npt, Point **pp)
{
    Plist l;
    l.np = 0;
    l.p = nil;
    _bezsplinepts(&l, pt, npt);
    *pp  = l.p;
    return l.np;
}
@


\subsubsection{Algorithm}

\paragraph{[[bezierpts()]]}
<<function bezierpts>>=
static void
bezierpts(Plist *l, Point p0, Point p1, Point p2, Point p3)
{
    bpts(l, p0, p1, p2, p3);
    appendpt(l, p3);
}
@

<<function bpts>>=
static void
bpts(Plist *l, Point p0, Point p1, Point p2, Point p3)
{
    bpts1(l, p0, p1, p2, p3, 1);
}
@

<<function bpts1>>=
/*
 * Convert cubic Bezier curve control points to polyline
 * vertices.  Leaves the last vertex off, so you can continue
 * with another curve.
 */
static void
bpts1(Plist *l, Point p0, Point p1, Point p2, Point p3, int scale)
{
    Point p01, p12, p23, p012, p123, p0123;
    Point tp0, tp1, tp2, tp3;
    tp0=divpt(p0, scale);
    tp1=divpt(p1, scale);
    tp2=divpt(p2, scale);
    tp3=divpt(p3, scale);
    if(psdist(tp1, tp0, tp3)<=1 && psdist(tp2, tp0, tp3)<=1){
        appendpt(l, tp0);
        appendpt(l, tp1);
        appendpt(l, tp2);
    }
    else{
        /*
         * if scale factor is getting too big for comfort,
         * rescale now & concede the rounding error
         */
        if(scale>(1<<12)){
            p0=tp0;
            p1=tp1;
            p2=tp2;
            p3=tp3;
            scale=1;
        }
        p01=addpt(p0, p1);
        p12=addpt(p1, p2);
        p23=addpt(p2, p3);
        p012=addpt(p01, p12);
        p123=addpt(p12, p23);
        p0123=addpt(p012, p123);
        bpts1(l, mulpt(p0, 8), mulpt(p01, 4), mulpt(p012, 2), p0123, scale*8);
        bpts1(l, p0123, mulpt(p123, 2), mulpt(p23, 4), mulpt(p3, 8), scale*8);
    }
}
@
% >> >> >> >> >> >>

<<function normsq>>=
static int
normsq(Point p)
{
    return p.x*p.x+p.y*p.y;
}
@

<<function psdist>>=
static int
psdist(Point p, Point a, Point b)
{
    int num, den;

    p = subpt(p, a);
    b = subpt(b, a);
    num = p.x*b.x + p.y*b.y;
    if(num <= 0)
        return normsq(p);
    den = normsq(b);
    if(num >= den)
        return normsq(subpt(b, p));
    return normsq(subpt(divpt(mulpt(b, num), den), p));
}
@


\paragraph{[[_bezsplinepts()]]}


<<function _bezsplinepts>>=
static void
_bezsplinepts(Plist *l, Point *pt, int npt)
{
    Point *p, *ep;
    Point a, b, c, d;
    int periodic;

    if(npt<3)
        return;
    ep = &pt[npt-3];
    periodic = eqpt(pt[0], ep[2]);
    if(periodic){
        a = divpt(addpt(ep[1], pt[0]), 2);
        b = divpt(addpt(ep[1], mulpt(pt[0], 5)), 6);
        c = divpt(addpt(mulpt(pt[0], 5), pt[1]), 6);
        d = divpt(addpt(pt[0], pt[1]), 2);
        bpts(l, a, b, c, d);
    }
    for(p=pt; p<=ep; p++){
        if(p==pt && !periodic){
            a = p[0];
            b = divpt(addpt(p[0], mulpt(p[1], 2)), 3);
        }
        else{
            a = divpt(addpt(p[0], p[1]), 2);
            b = divpt(addpt(p[0], mulpt(p[1], 5)), 6);
        }
        if(p==ep && !periodic){
            c = divpt(addpt(mulpt(p[1], 2), p[2]), 3);
            d = p[2];
        }
        else{
            c = divpt(addpt(mulpt(p[1], 5), p[2]), 6);
            d = divpt(addpt(p[1], p[2]), 2);
        }
        bpts(l, a, b, c, d);
    }
    appendpt(l, d);
}
@





\section{Advanced compositing}

\subsection{Reading replicated pixels}
% tiling?

<<[[readbyte]] other locals>>=
int i;
byte *rrepl, *grepl, *brepl, *arepl, *krepl;
byte ured, ugrn, ublu;
ulong u;
@

<<[[readbyte()]] more complex cases, possible repl, grey, and small depth>>=
DBG1("2\n");
rrepl = replbit[img->nbits[CRed]];
grepl = replbit[img->nbits[CGreen]];
brepl = replbit[img->nbits[CBlue]];
arepl = replbit[img->nbits[CAlpha]];

krepl = replbit[img->nbits[CGrey]];

for(i=0; i<dx; i++){
    u = r[0] | (r[1]<<8) | (r[2]<<16) | (r[3]<<24);
    if(copyalpha) {
        *w++ = arepl[(u>>img->shift[CAlpha]) & img->mask[CAlpha]];
        //DBG print("a %x\n", w[-1]);
    }

    if(isgrey)
        *w++ = krepl[(u >> img->shift[CGrey]) & img->mask[CGrey]];
    else if(!alphaonly){
        ured = rrepl[(u >> img->shift[CRed]) & img->mask[CRed]];
        ugrn = grepl[(u >> img->shift[CGreen]) & img->mask[CGreen]];
        ublu = brepl[(u >> img->shift[CBlue]) & img->mask[CBlue]];
        if(convgrey){
            DBG1("g %x %x %x\n", ured, ugrn, ublu);
            *w++ = RGB2K(ured, ugrn, ublu);
            DBG1("%x\n", w[-1]);
        }else{
            *w++ = brepl[(u >> img->shift[CBlue]) & img->mask[CBlue]];
            *w++ = grepl[(u >> img->shift[CGreen]) & img->mask[CGreen]];
            *w++ = rrepl[(u >> img->shift[CRed]) & img->mask[CRed]];
        }
    }
    r += nb;
    if(r == end)
        r = begin;
}

b.alpha = copyalpha ? buf : &ones;
b.rgba = (ulong*)buf;
if(alphaonly){
    b.red = b.grn = b.blu = b.grey = nil;
    if(!copyalpha)
        b.rgba = nil;
    b.delta = 1;
}else if(isgrey || convgrey){
    b.grey = buf+copyalpha;
    b.red = b.grn = b.blu = buf+copyalpha;
    b.delta = copyalpha+1;
    DBG1("alpha %x grey %x\n", b.alpha ? *b.alpha : 0xFF, *b.grey);
}else{
    b.blu = buf+copyalpha;
    b.grn = buf+copyalpha+1;
    b.grey = nil;
    b.red = buf+copyalpha+2;
    b.delta = copyalpha+3;
}
return b;
@



\subsubsection{[[mktables]]}

<<[[memimageinit()]] initializations>>=
mktables();
@

% later?
<<global replbit>>=
/*
 * Conversion tables.
 */
uchar replbit[1+8][256];		/* replbit[x][y] is the replication of the x-bit quantity y to 8-bit depth */
@


% ?? -> screensize -> memimageinit -> <>
<<function mktables>>=
static void
mktables(void)
{
    int i, j, small;
    <<[[mktables()]] only once guard>>

    /* bit replication up to 8 bits */
    for(i=0; i<256; i++){
        for(j=0; j<=8; j++){	/* j <= 8 [sic] */
            small = i & ((1<<j)-1);
            replbit[j][i] = (small*replmul[j])>>8;
        }
    }

}
@
%dead: done in caller anyway
%    fmtinstall('R', Rfmt);
%    fmtinstall('P', Pfmt);
%dead:
%    int mask, sh, 
%    /* bit unpacking up to 8 bits, only powers of 2 */
%    for(i=0; i<256; i++){
%        for(j=0, sh=7, mask=1; j<8; j++, sh--)
%            conv18[i][j] = replbit[1][(i>>sh)&mask];
%
%        for(j=0, sh=6, mask=3; j<4; j++, sh-=2)
%            conv28[i][j] = replbit[2][(i>>sh)&mask];
%
%        for(j=0, sh=4, mask=15; j<2; j++, sh-=4)
%            conv48[i][j] = replbit[4][(i>>sh)&mask];
%    }
% <<global conv18>>=
% static uchar conv18[256][8];		/* conv18[x][y] is the yth pixel in the depth-1 pixel x */
% @
% 
% <<global conv28>>=
% static uchar conv28[256][4];		/* ... */
% @
% 
% <<global conv48>>=
% static uchar conv48[256][2];
% @


<<[[mktables()]] only once guard>>=
static bool	tablesbuilt = false;
if(tablesbuilt)
    return;
tablesbuilt = true;
@
% used to be a global, but can be a static, better.




\subsection{Other compositing operators}

% apparently http.golang.org/go-image-package says that when you
% have masks, you need less operators and just DoverS and S are useful
% so maybe all this code below is useless.

\subsubsection{[[Clear]]}
%    alphacalc0,		/* Clear */

<<function alphacalc0>>=
static Buffer
alphacalc0(Buffer bdst, Buffer b1, Buffer b2, int dx, int grey, int op)
{
    USED(grey);
    USED(op);
    USED(b1);
    USED(b2);

    memset(bdst.rgba, 0, dx * bdst.delta);
    return bdst;
}
@

\subsubsection{[[DoutS]]}
%    alphacalc14,		/* DoutS */

<<function alphacalc14>>=
static Buffer
alphacalc14(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, int grey, int op)
{
    Buffer obdst;
    int fd, sadelta;
    int i, sa, ma, q;
    ulong s, t;

    obdst = bdst;
    sadelta = bsrc.alpha == &ones ? 0 : bsrc.delta;
    q = bsrc.delta == 4 && bdst.delta == 4;

    for(i=0; i<dx; i++){
        sa = *bsrc.alpha;
        ma = *bmask.alpha;
        fd = MUL(sa, ma, t);
        if(op == DoutS)
            fd = 255-fd;

        if(grey){
            *bdst.grey = MUL(fd, *bdst.grey, t);
            bsrc.grey += bsrc.delta;
            bdst.grey += bdst.delta;
        }else{
            if(q){
                *bdst.rgba = MUL0123(fd, *bdst.rgba, s, t);
                bsrc.rgba++;
                bdst.rgba++;
                bsrc.alpha += sadelta;
                bmask.alpha += bmask.delta;
                continue;
            }
            *bdst.red = MUL(fd, *bdst.red, t);
            *bdst.grn = MUL(fd, *bdst.grn, t);
            *bdst.blu = MUL(fd, *bdst.blu, t);
            bsrc.red += bsrc.delta;
            bsrc.blu += bsrc.delta;
            bsrc.grn += bsrc.delta;
            bdst.red += bdst.delta;
            bdst.blu += bdst.delta;
            bdst.grn += bdst.delta;
        }
        if(bdst.alpha != &ones){
            *bdst.alpha = MUL(fd, *bdst.alpha, t);
            bdst.alpha += bdst.delta;
        }
        bmask.alpha += bmask.delta;
        bsrc.alpha += sadelta;
    }
    return obdst;
}
@





\subsubsection{[[SoutD]]}
%    alphacalc2810,		/* SoutD */

<<function alphacalc2810>>=
static Buffer
alphacalc2810(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, int grey, int op)
{
    Buffer obdst;
    int fs, sadelta;
    int i, ma, da, q;
    ulong s, t;

    obdst = bdst;
    sadelta = bsrc.alpha == &ones ? 0 : bsrc.delta;
    q = bsrc.delta == 4 && bdst.delta == 4;

    for(i=0; i<dx; i++){
        ma = *bmask.alpha;
        da = *bdst.alpha;
        if(op == SoutD)
            da = 255-da;
        fs = ma;
        if(op != S)
            fs = MUL(fs, da, t);

        if(grey){
            *bdst.grey = MUL(fs, *bsrc.grey, t);
            bsrc.grey += bsrc.delta;
            bdst.grey += bdst.delta;
        }else{
            if(q){
                *bdst.rgba = MUL0123(fs, *bsrc.rgba, s, t);
                bsrc.rgba++;
                bdst.rgba++;
                bmask.alpha += bmask.delta;
                bdst.alpha += bdst.delta;
                continue;
            }
            *bdst.red = MUL(fs, *bsrc.red, t);
            *bdst.grn = MUL(fs, *bsrc.grn, t);
            *bdst.blu = MUL(fs, *bsrc.blu, t);
            bsrc.red += bsrc.delta;
            bsrc.blu += bsrc.delta;
            bsrc.grn += bsrc.delta;
            bdst.red += bdst.delta;
            bdst.blu += bdst.delta;
            bdst.grn += bdst.delta;
        }
        if(bdst.alpha != &ones){
            *bdst.alpha = MUL(fs, *bsrc.alpha, t);
            bdst.alpha += bdst.delta;
        }
        bmask.alpha += bmask.delta;
        bsrc.alpha += sadelta;
    }
    return obdst;
}
@


\subsubsection{[[DxorS]]}
%    alphacalc3679,		/* DxorS */

<<function alphacalc3679>>=
static Buffer
alphacalc3679(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, bool grey, int op)
{
    Buffer obdst;
    int fs, fd, sadelta;
    int i, sa, ma, da, q;
    ulong s, t, u, v;

    obdst = bdst;
    sadelta = (bsrc.alpha == &ones) ? 0 : bsrc.delta;
    q = (bsrc.delta == 4) && (bdst.delta == 4);

    for(i=0; i<dx; i++){
        sa = *bsrc.alpha;
        ma = *bmask.alpha;
        da = *bdst.alpha;
        if(op == SatopD)
            fs = MUL(ma, da, t);
        else
            fs = MUL(ma, 255-da, t);
        if(op == DoverS)
            fd = 255;
        else{
            fd = MUL(sa, ma, t);
            if(op != DatopS)
                fd = 255-fd;
        }

        if(grey){
            *bdst.grey = MUL(fs, *bsrc.grey, s) + MUL(fd, *bdst.grey, t);
            bsrc.grey += bsrc.delta;
            bdst.grey += bdst.delta;
        }else{
            if(q){
                *bdst.rgba = MUL0123(fs, *bsrc.rgba, s, t)+MUL0123(fd, *bdst.rgba, u, v);
                bsrc.rgba++;
                bdst.rgba++;
                bsrc.alpha += sadelta;
                bmask.alpha += bmask.delta;
                bdst.alpha += bdst.delta;
                continue;
            }
            *bdst.red = MUL(fs, *bsrc.red, s)+MUL(fd, *bdst.red, t);
            *bdst.grn = MUL(fs, *bsrc.grn, s)+MUL(fd, *bdst.grn, t);
            *bdst.blu = MUL(fs, *bsrc.blu, s)+MUL(fd, *bdst.blu, t);
            bsrc.red += bsrc.delta;
            bsrc.blu += bsrc.delta;
            bsrc.grn += bsrc.delta;
            bdst.red += bdst.delta;
            bdst.blu += bdst.delta;
            bdst.grn += bdst.delta;
        }
        if(bdst.alpha != &ones){
            *bdst.alpha = MUL(fs, sa, s)+MUL(fd, da, t);
            bdst.alpha += bdst.delta;
        }
        bmask.alpha += bmask.delta;
        bsrc.alpha += sadelta;
    }
    return obdst;
}
@

\subsubsection{[[DinS]]}
%    alphacalc14,		/* DinS */


\subsubsection{[[D]]}
%    alphacalc5,		/* D */

<<function alphacalc5>>=
static Buffer
alphacalc5(Buffer bdst, Buffer b1, Buffer b2, int dx, int grey, int op)
{
    USED(dx);
    USED(grey);
    USED(op);
    USED(b1);
    USED(b2);

    return bdst;
}
@


\subsubsection{[[DatopS]]}
%    alphacalc3679,		/* DatopS */


\subsubsection{[[DoverS]]}
%    alphacalc3679,		/* DoverS */


\subsubsection{[[SinD]]}
%    alphacalc2810,		/* SinD */


\subsubsection{[[SatopD]]}
%    alphacalc3679,		/* SatopD */


\subsubsection{[[S]]}
%    alphacalc2810,		/* S */


\subsubsection{[[SoverD]]}
%    alphacalc11,		/* SoverD */
% the classic! see section X






\section{Advanced mouse settings}


\subsection{[[/dev/cursor]]}
\n not that important in the end

% code in devmouse.c? mostly to set new cursor picture?


<<[[Mousectl]] cursor field>>=
// /dev/cursor
fdt		cfd;		/* to cursor file */
@

<<[[initmouse()]] other locals>>=
char *t;
char *sl;
@

<<[[initmouse()]] set cursor field>>=
<<[[initmouse()]] set t to /dev/cursor>>
mc->cfd = open(t, ORDWR|OCEXEC);
free(t);
@

<<[[initmouse()]] set t to /dev/cursor>>=
// t = "{basename(file)}/cursor"
t = malloc(strlen(file)+16);
<<[[initmouse()]] sanity check t>>
strcpy(t, file);
sl = utfrrune(t, '/');
if(sl)
    strcpy(sl, "/cursor");
else
    strcpy(t, "/dev/cursor");
@
%ocaml: just hardcode /dev/cursor, no need to be so general, who
% does not open /dev/mouse?

<<[[initmouse()]] sanity check t>>=
if (t == nil) {
    close(mc->mfd);
    free(mc);
    return nil;
}
@






<<function setcursor>>=
void
setcursor(Mousectl *mc, Cursor *c)
{
    char curs[2*4 + 2*2*16]; // sizeof Cursor

    if(c == nil)
        write(mc->cfd, curs, 0);
    else{
        BPLONG(curs+0*4, c->offset.x);
        BPLONG(curs+1*4, c->offset.y);
        memmove(curs+2*4, c->clr, 2*2*16);
        write(mc->cfd, curs, sizeof curs);
    }
}
@
% case when == nil is to reset the cursor to original big arrow cursor.
%ocaml: have set_cursor and reset_cursor

% note that also use c->set indirectly because bytes are after clr
% in the struct and 2*2*16 overflow Cursor.clr

%? devmouse.c code? for /dev/cursor?



\subsection{[[mousescrollsize()]]}
% advanced topic? who calls that?

<<function mousescrollsize>>=
int
mousescrollsize(int maxlines)
{
    static int lines, pcnt;
    char *mss;

    if(lines == 0 && pcnt == 0){
        mss = getenv("mousescrollsize");
        if(mss){
            if(strchr(mss, '%') != nil)
                pcnt = atof(mss);
            else
                lines = atoi(mss);
            free(mss);
        }
        if(lines == 0 && pcnt == 0)
            lines = 1;
        if(pcnt>=100)
            pcnt = 100;
    }

    if(lines)
        return lines;
    return pcnt * maxlines/100.0;	
}
@

\section{Menus}
\l mv in advanced shapes? windowing system support?
\l mv in appendix (nice example of use of drawing API)?
\l mv in Widgets.nw? or have Widgets chapter here and say that just subset?

% related to mouse too.
% used in Windows.nw for the wm menus.

\subsection{[[Menu]]}

<<struct Menu>>=
struct Menu
{
    char	**item;
    <<[[Menu]] other fields>>
};
@
%ocaml: list of pair with string * closure, so no need
% to have intermediate and redundant enum or hardcoded integers
% to know which entry was clicked (as done in rio)



\subsection{Constants}

<<enum _anon_ (lib_graphics/libdraw/menuhit.c)>>=
enum
{
    Margin = 4,		/* outside to text */
    Border = 2,		/* outside to selection boxes */
    Blackborder = 2,	/* width of outlining border */
    Vspacing = 2,		/* extra spacing between lines of text */
    <<[[menuhit.c]] constants>>
};
@
\l Blackborder -> border_size

% FIGURE! where see the dimensions used!

\subsection{Colors}

<<global back (lib_graphics/libdraw/menuhit.c)>>=
static	Image	*back;
@
\l background

<<global high (lib_graphics/libdraw/menuhit.c)>>=
static	Image	*high;
@
\l background_highlighted

<<global bord (lib_graphics/libdraw/menuhit.c)>>=
static	Image	*bord;
@
\l longer name, border

<<global text (lib_graphics/libdraw/menuhit.c)>>=
static	Image	*text;
@
\l text_color

<<global htext (lib_graphics/libdraw/menuhit.c)>>=
static	Image	*htext;
@
\l longer name, text_highlighted


<<global menutxt (lib_graphics/libdraw/menuhit.c)>>=
static	Image	*menutxt;
@
% diff with text?

<<[[menuhit()]] initialize colors>>=
if(back == nil)
    menucolors();
@

<<function menucolors (lib_graphics/libdraw/menuhit.c)>>=
static
void
menucolors(void)
{
    /* Main tone is greenish, with negative selection */
    back = allocimagemix(display, DPalegreen, DWhite);
    high = allocimage(display, Rect(0,0,1,1), view->chan, true, DDarkgreen);	/* dark green */
    bord = allocimage(display, Rect(0,0,1,1), view->chan, true, DMedgreen);	/* not as dark green */
    <<[[menucolors()]] sanity check images>>
    text = display->black;
    htext = back;
    return;

<<[[menucolors()]] Error label>>
}
@

<<[[menucolors()]] sanity check images>>=
if(back == nil || high == nil || bord == nil)
    goto Error;
@

<<[[menucolors()]] Error label>>=
Error:
freeimage(back);
freeimage(high);
freeimage(bord);
back = display->white;
high = display->black;
bord = display->black;
text = display->black;
htext = display->white;
@
%ocaml: use exn for error. When can not allocate image?

% color3? why note color2?
% menucolors -> <>
<<function allocimagemix>>=
Image*
allocimagemix(Display *d, ulong color1, ulong color3)
{
    Image *t, *b;
    static Image *qmask;

    if(qmask == nil)
        qmask = allocimage(d, Rect(0,0,1,1), GREY8, true, 0x3F3F3FFF);

    <<[[allocimagemix()]] if depth less than 8>>
    else{	/* use a solid color, blended using alpha */
        t = allocimage(d, Rect(0,0,1,1), d->screenimage->chan, true, color1);
        <<[[allocimagemix()]] sanity check t>>
        b = allocimage(d, Rect(0,0,1,1), d->screenimage->chan, true, color3);
        <<[[allocimagemix()]] sanity check b>>
        draw(b, b->r, t, qmask, ZP);
        freeimage(t);
        return b;
    }
}
@
% this allocate a color with a pattern, like mostly white
% with some green dots.

<<[[allocimagemix()]] sanity check t>>=
if(t == nil)
    return nil;
@
<<[[allocimagemix()]] sanity check b>>=
if(b == nil){
    freeimage(t);
    return nil;
}
@
%ocaml: finalize and exn

\subsection{[[menuhits()]]}

% entry point
<<function menuhit>>=
int
menuhit(int button, Mousectl *mc, Menu *menu, Screen *scr)
{
    int i;
    int lasti;
    char *item;
    int nitem, nitemdrawn, 
    int maxwid, wid;
    Rectangle r, menur, textr;
    Image *b, *backup, *save;
    Point pt;
    bool scrolling;
    int off;
    <<[[menuhit()]] other locals>>

    <<[[menuhit()]] initialize colors>>
    <<[[menuhit()]] set repl and clip on view>>

    <<[[menuhit()]] compute [[maxwid]] and [[nitem]]>>
    <<[[menuhit()]] set lasthit>>
    <<[[menuhit()]] if need a scroller for items>>
    else{
        scrolling = false;
        nitemdrawn = nitem;
        wid = maxwid;
        off = 0;
        lasti = menu->lasthit;
    }
    <<[[menuhit()]] set [[r]], the temporary rectangle to draw the menu>>
    <<[[menuhit()]] set [[menur]], the adjusted rectangle to draw the menu>>
    <<[[menuhit()]] set [[textr]], the rectangle to draw the text>>
    <<[[menuhit()]] set [[scrollr]], the rectangle to draw maybe a scrollbar>>

    <<[[menuhit()]] set [[b]] the image to draw on and right [[backup]]>>
    <<[[menuhit()]] paint on [[b]]>>

    <<[[menuhit()]] allocate [[save]] image>>
    <<[[menuhit()]] loop while button still pressed and return [[lasti]]>>

    <<[[menuhit()]] restore what was under the menu in [[backup]]>>
    <<[[menuhit()]] free [[save]] image>>
    <<[[menuhit()]] restore clip on view>>
    flushimage(display, true);
    if(lasti >= 0){
        <<[[menuhit()]] save lasthit before returning>>
        return menu->lasthit;
    }
    return -1;
}
@
% >> >> >> >> >>
%pad: but -> button
%ocaml: clearer to use button variant than use bitset
% and then bitset tricks above

\subsubsection{The items size}

<<[[menuhit()]] compute [[maxwid]] and [[nitem]]>>=
maxwid = 0;
for(nitem = 0;
    item = menu->item? menu->item[nitem] : (*menu->gen)(nitem);
    nitem++){
    i = stringwidth(font, item);
    if(i > maxwid)
        maxwid = i;
}
@
%ocaml: map and foldl(max), and no need nitem compute (just use List.length)

<<[[Menu]] other fields>>=
char	*(*gen)(int);
@
% some app uses that?

\subsubsection{The rectangles}

<<[[menuhit()]] set [[r]], the temporary rectangle to draw the menu>>=
r = Rect(0, 0, wid, nitemdrawn*(font->height+Vspacing));
r = insetrect(r, -Margin); // enlarge
r = rectsubpt(r, Pt(wid/2, lasti*(font->height+Vspacing)+font->height/2));
r = rectaddpt(r, mc->xy);
@
%old: I added the first line where create first simple rectangle without margin
%ocaml: use pipe operator and currying, so shorter

% centered on last entry

<<[[menuhit()]] set [[menur]], the adjusted rectangle to draw the menu>>=
pt = ZP;
<<[[menuhit()]] adjust [[pt]] if [[r]] outside view>>
menur = rectaddpt(r, pt);
@

<<[[menuhit()]] adjust [[pt]] if [[r]] outside view>>=
if(r.max.x > view->r.max.x)
    pt.x = view->r.max.x - r.max.x;
if(r.max.y > view->r.max.y)
    pt.y = view->r.max.y - r.max.y;
if(r.min.x < view->r.min.x)
    pt.x = view->r.min.x-r.min.x;
if(r.min.y < view->r.min.y)
    pt.y = view->r.min.y-r.min.y;
@



<<[[menuhit()]] set [[textr]], the rectangle to draw the text>>=
textr.max.x = menur.max.x - Margin;
textr.min.x = textr.max.x - maxwid;
textr.min.y = menur.min.y + Margin;
textr.max.y = textr.min.y + nitemdrawn*(font->height+Vspacing);
@
\l why not simply insetrect(menur, Margin)? because before
\l  was using wid but here maxwid?


<<function menurect (lib_graphics/libdraw/menuhit.c)>>=
/*
 * r is a rectangle holding the text elements.
 * return the rectangle, including its black edge, holding element i.
 */
static Rectangle
menurect(Rectangle r, int i)
{
    <<[[menurect()]] sanity check i>>
    r.min.y += (font->height+Vspacing)*i;
    r.max.y = r.min.y + font->height+Vspacing;
    return insetrect(r, Border-Margin);
}
@
% Border-margin = -2 is negative, so enlarge textr

<<[[menurect()]] sanity check i>>=
if(i < 0)
    return Rect(0, 0, 0, 0);
@
%ocaml: exn!


\subsubsection{The image}

<<[[menuhit()]] set [[b]] the image to draw on and right [[backup]]>>=
if(scr){
    b = allocwindow(scr, menur, Refbackup, DWhite);
    <<[[menuhit()]] sanitize b>>
    backup = nil;
}else{
    b = view;
    backup = allocimage(display, menur, view->chan, false, -1);
    if(backup)
        draw(backup, menur, view, nil, menur.min);
}
@



<<[[menuhit()]] sanitize b>>=
if(b == nil)
    b = view;
@

<<[[menuhit()]] restore what was under the menu in [[backup]]>>=
if(b != view)
    freeimage(b);
if(backup){
    draw(view, menur, backup, nil, menur.min);
    freeimage(backup);
}
@

% note that freeimage free the resource and restore what was under
% the layer on the desktop!

\subsubsection{The paint}

<<[[menuhit()]] paint on [[b]]>>=
draw(b, menur, back, nil, ZP);
border(b, menur, Blackborder, bord, ZP);
<<[[menuhit()]] move cursor to lasti entry>>
menupaint(b, menu, textr, off, nitemdrawn);
<<[[menuhit()]] if scrolling, paint the scroll>>
@

% menuhit -> <>
<<function menupaint (lib_graphics/libdraw/menuhit.c)>>=
static void
menupaint(Image *m, Menu *menu, Rectangle textr, int off, int nitemdrawn)
{
    int i;

    draw(m, insetrect(textr, Border-Margin), back, nil, ZP);
    for(i = 0; i<nitemdrawn; i++)
        paintitem(m, menu, textr, off, i, false, nil, nil);
}
@
\l why redraw again background? because if was scrolling?

% menupain | menuscan -> <>
<<function paintitem (lib_graphics/libdraw/menuhit.c)>>=
static
void
paintitem(Image *m, Menu *menu, Rectangle textr, int off, int i, bool highlight, Image *save, Image *restore)
{
    char *item;
    Rectangle r;
    Point pt;

    <<[[paintitem()]] sanity check i>>
    r = menurect(textr, i);
    <<[[paintitem()]] if restore>>
    <<[[paintitem()]] if save>>
    item = menu->item? menu->item[i+off] : (*menu->gen)(i+off);
    pt.x = (textr.min.x + textr.max.x - stringwidth(font, item))/2;
    pt.y = textr.min.y + i*(font->height+Vspacing);
    draw(m, r, highlight? high : back, nil, pt);
    string(m, pt, highlight? htext : text, pt, font, item);
}
@
% the pt.x instruction is to center text :) nice, simple.

\l why pass pt to draw and to fourth arg of string?

% call draw again cause will call paintitem to redraw on past stuff
% and especially to highlight


<<[[paintitem()]] sanity check i>>=
if(i < 0)
    return;
@
% yes, can be called with i = -1, when went out of menu
% and return back towards menu, lasti will still be -1

<<[[menuhit()]] move cursor to lasti entry>>=
r = menurect(textr, lasti);
moveto(mc, divpt(addpt(r.min, r.max), 2));
@
\l why before menupaint?

\subsubsection{The loop}

<<[[menuhit()]] loop while button still pressed and return [[lasti]]>>=
while(mc->buttons & (1<<(button-1))){
    lasti = menuscan(b, menu, button, mc, textr, off, lasti, save);
    if(lasti >= 0)
        break;
    while(!ptinrect(mc->xy, textr) && (mc->buttons & (1<<(button-1)))){
        <<[[menuhit()]] if scrolling and mouse in [[scrollr]]>>
        readmouse(mc);
    }
}
@
% when goes out of textr, menuscan will return -1 in which case
% we loop until we go back in and we go back in lasti is still
% -1 so may call paintitem with -1.

<<[[menuhit()]] allocate [[save]] image>>=
save = allocimage(display, menurect(textr, 0), view->chan, false, -1);
@
%old: save was in the next chunk, but more logical here
\l why need save and backup? backup is if not use allocwindow,
\l  save is needed anyway to draw highlighted text (but could
\l  alloc and free a layer each time too)

<<[[paintitem()]] if save>>=
if(save)
    draw(save, save->r, m, nil, r.min);
@

<<[[paintitem()]] if restore>>=
if(restore){
    draw(m, r, restore, nil, restore->r.min);
    return;
}
@

<<[[menuhit()]] free [[save]] image>>=
freeimage(save);
@

\subsubsection{The scan}

% lasti can be -1 below

<<function menuscan (lib_graphics/libdraw/menuhit.c)>>=
/*
 * menur is a rectangle holding all the highlightable text elements.
 * track mouse while inside the box, return what's selected when button
 * is raised, -1 as soon as it leaves box.
 * invariant: nothing is highlighted on entry or exit.
 */
static int
menuscan(Image *m, Menu *menu, int button, Mousectl *mc, Rectangle textr, int off, int lasti, Image *save)
{
    int i;

    paintitem(m, menu, textr, off, lasti, true, save, nil);
    for(readmouse(mc); mc->buttons & (1<<(button-1)); readmouse(mc)){
        i = menusel(textr, mc->xy);
        if(i != -1 && i == lasti)
            continue;
        // else (i == -1 || i != lasti)
        paintitem(m, menu, textr, off, lasti, false, nil, save); // restore
        if(i == -1)
            return i;
        lasti = i;
        paintitem(m, menu, textr, off, lasti, true, save, nil);
    }
    return lasti;
}
@
% >>
% complex flow with continue and return ...

% remember that readmouse internally flush the display! so no need
% to do it but important! otherwise get no refresh. and just see the
% old menu list.

% first paintitem is to highlight lasti

<<function menusel (lib_graphics/libdraw/menuhit.c)>>=
/*
 * r is a rectangle holding the text elements.
 * return the element number containing p.
 */
static int
menusel(Rectangle r, Point p)
{
    r = insetrect(r, Margin);
    if(!ptinrect(p, r))
        return -1;
    return (p.y - r.min.y)/(font->height+Vspacing);
}
@
\l why reduce by Margin? textr is already a reduced menur

\subsubsection{Misc}

<<[[menuhit()]] other locals>>=
Rectangle sc; // save clipr
@
<<[[menuhit()]] set repl and clip on view>>=
sc = view->clipr;
replclipr(view, false, view->r);
@
<<[[menuhit()]] restore clip on view>>=
replclipr(view, false, sc);
@

% why need that?

\subsection{Last hit}

% Allows to display menu centered on your last choice.
% So fast to repeat the same operation.

<<[[menuhit()]] set lasthit>>=
if(menu->lasthit<0 || menu->lasthit>=nitem)
    menu->lasthit = 0;
@

<<[[Menu]] other fields>>=
int	lasthit;
@

<<[[menuhit()]] save lasthit before returning>>=
menu->lasthit = lasti+off;
@

\subsection{Scrolling menus}

<<[[menuhit.c]] constants>>=
Maxunscroll = 25,	/* maximum #entries before scrolling turns on */
Nscroll = 20,		/* number entries in scrolling part */
Scrollwid = 14,		/* width of scroll bar */
Gap = 4,			/* between text and scroll bar */
@

<<[[menuhit()]] other locals>>=
int screenitem;
@

<<[[menuhit()]] if need a scroller for items>>=
screenitem = (Dy(view->r) - 10) / (font->height + Vspacing);
if(nitem>Maxunscroll || nitem>screenitem){
    scrolling = 1;
    nitemdrawn = Nscroll;
    if(nitemdrawn > screenitem)
        nitemdrawn = screenitem;
    wid = maxwid + Gap + Scrollwid;
    off = menu->lasthit - nitemdrawn/2;
    if(off < 0)
        off = 0;
    if(off > nitem-nitemdrawn)
        off = nitem-nitemdrawn;
    lasti = menu->lasthit-off;
}
@

<<[[menuhit()]] other locals>>=
Rectangle scrollr;
@
<<[[menuhit()]] set [[scrollr]], the rectangle to draw maybe a scrollbar>>=
<<[[menuhit()]] if scrolling set scrollr>>
else
    scrollr = Rect(0, 0, 0, 0);
@
% I dont think it needs a default value, if not scrolling then never used

<<[[menuhit()]] if scrolling set scrollr>>=
if(scrolling){
    scrollr = insetrect(menur, Border);
    scrollr.max.x = scrollr.min.x+Scrollwid;
}
@

<<[[menuhit()]] if scrolling, paint the scroll>>=
if(scrolling)
    menuscrollpaint(b, scrollr, off, nitem, nitemdrawn);
@

<<function menuscrollpaint (lib_graphics/libdraw/menuhit.c)>>=
static void
menuscrollpaint(Image *m, Rectangle scrollr, int off, int nitem, int nitemdrawn)
{
    Rectangle r;

    draw(m, scrollr, back, nil, ZP);
    r.min.x = scrollr.min.x;
    r.max.x = scrollr.max.x;
    r.min.y = scrollr.min.y + (Dy(scrollr)*off)/nitem;
    r.max.y = scrollr.min.y + (Dy(scrollr)*(off+nitemdrawn))/nitem;
    if(r.max.y < r.min.y+2)
        r.max.y = r.min.y+2;
    border(m, r, 1, bord, ZP);
    if(menutxt == nil)
        menutxt = allocimage(display, Rect(0, 0, 1, 1), view->chan, true, DDarkgreen);	/* border color; BUG? */
    if(menutxt)
        draw(m, insetrect(r, 1), menutxt, nil, ZP);
}
@

<<[[menuhit()]] other locals>>=
int noff;
@
<<[[menuhit()]] if scrolling and mouse in [[scrollr]]>>=
if(scrolling && ptinrect(mc->xy, scrollr)){
    noff = ((mc->xy.y-scrollr.min.y)*nitem)/Dy(scrollr);
    noff -= nitemdrawn/2;
    if(noff < 0)
        noff = 0;
    if(noff > nitem-nitemdrawn)
        noff = nitem-nitemdrawn;
    if(noff != off){
        off = noff;
        menupaint(b, menu, textr, off, nitemdrawn);
        menuscrollpaint(b, scrollr, off, nitem, nitemdrawn);
    }
}
@


\section{Selection}

\subsection{[[getrect.c]]}

% =~ sweep() action done by rio, but available for other programs
% like menuhit.c


<<constant W (lib_graphics/libdraw/getrect.c)>>=
#define	W	Borderwidth
@

<<global tmp (lib_graphics/libdraw/getrect.c)>>=
static Image *tmp[4];
@

<<global red (lib_graphics/libdraw/getrect.c)>>=
static Image *red;
@

<<global sweep (lib_graphics/libdraw/getrect.c)>>=
static Cursor sweep={
    {-7, -7},
    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0x07,
     0xE0, 0x07, 0xE0, 0x07, 0xE3, 0xF7, 0xE3, 0xF7,
     0xE3, 0xE7, 0xE3, 0xF7, 0xE3, 0xFF, 0xE3, 0x7F,
     0xE0, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,},
    {0x00, 0x00, 0x7F, 0xFE, 0x40, 0x02, 0x40, 0x02,
     0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x41, 0xE2,
     0x41, 0xC2, 0x41, 0xE2, 0x41, 0x72, 0x40, 0x38,
     0x40, 0x1C, 0x40, 0x0E, 0x7F, 0xE6, 0x00, 0x00,}
};
@

<<function brects (lib_graphics/libdraw/getrect.c)>>=
static
void
brects(Rectangle r, Rectangle rp[4])
{
    if(Dx(r) < 2*W)
        r.max.x = r.min.x+2*W;
    if(Dy(r) < 2*W)
        r.max.y = r.min.y+2*W;
    rp[0] = Rect(r.min.x, r.min.y, r.max.x, r.min.y+W);
    rp[1] = Rect(r.min.x, r.max.y-W, r.max.x, r.max.y);
    rp[2] = Rect(r.min.x, r.min.y+W, r.min.x+W, r.max.y-W);
    rp[3] = Rect(r.max.x-W, r.min.y+W, r.max.x, r.max.y-W);
}
@

<<function getrect>>=
Rectangle
getrect(int but, Mousectl *mc)
{
    Rectangle r, rc;

    but = 1<<(but-1);
    setcursor(mc, &sweep);
    while(mc->buttons)
        readmouse(mc);
    while(!(mc->buttons & but)){
        readmouse(mc);
        if(mc->buttons & (7^but))
            goto Return;
    }
    r.min = mc->xy;
    r.max = mc->xy;
    do{
        rc = canonrect(r);
        drawgetrect(rc, 1);
        readmouse(mc);
        drawgetrect(rc, 0);
        r.max = mc->xy;
    }while(mc->buttons == but);

    Return:
    setcursor(mc, nil);
    if(mc->buttons & (7^but)){
        rc.min.x = rc.max.x = 0;
        rc.min.y = rc.max.y = 0;
        while(mc->buttons)
            readmouse(mc);
    }
    return rc;
}
@

<<function drawgetrect>>=
void
drawgetrect(Rectangle rc, int up)
{
    int i;
    Rectangle r, rects[4];

    /*
     * BUG: if for some reason we have two of these going on at once
     * when we must grow the tmp buffers, we lose data.  Also if tmp
     * is unallocated and we ask to restore the screen, it would be nice
     * to complain, but we silently make a mess.
     */
    if(up && tmp[0]!=nil)
        if(Dx(tmp[0]->r)<Dx(rc) || Dy(tmp[2]->r)<Dy(rc))
            freetmp();
    if(tmp[0] == 0){
        r = Rect(0, 0, max(Dx(display->screenimage->r), Dx(rc)), W);
        tmp[0] = allocimage(display, r, view->chan, false, -1);
        tmp[1] = allocimage(display, r, view->chan, false, -1);
        r = Rect(0, 0, W, max(Dy(display->screenimage->r), Dy(rc)));
        tmp[2] = allocimage(display, r, view->chan, false, -1);
        tmp[3] = allocimage(display, r, view->chan, false, -1);
        red = allocimage(display, Rect(0,0,1,1), view->chan, true, DRed);
        if(tmp[0]==0 || tmp[1]==0 || tmp[2]==0 || tmp[3]==0 || red==0){
            freetmp();
            drawerror(display, "getrect: allocimage failed");
        }
    }
    brects(rc, rects);
    if(!up){
        for(i=0; i<4; i++)
            draw(view, rects[i], tmp[i], nil, ZP);
        return;
    }
    for(i=0; i<4; i++){
        draw(tmp[i], Rect(0, 0, Dx(rects[i]), Dy(rects[i])), view, nil, rects[i].min);
        draw(view, rects[i], red, nil, ZP);
    }
}
@

% drawgetrect -> <>
<<function freetmp (lib_graphics/libdraw/getrect.c)>>=
static
void
freetmp(void)
{
    freeimage(tmp[0]);
    freeimage(tmp[1]);
    freeimage(tmp[2]);
    freeimage(tmp[3]);
    freeimage(red);
    tmp[0] = tmp[1] = tmp[2] = tmp[3] = red = nil;
}
@

<<function max>>=
static
int
max(int a, int b)
{
    if(a > b)
        return a;
    return b;
}
@




\section{Event-based IO}

% seen before /dev/mouse synchrony issue, and the introduction
% of ioproc and channel and alt(). 

% Events are an alternative API. 
% See event(2)
%  "These routines provide an interface to multiple sources of input 
%   for unthreaded programs. Threaded programs (see thread (2))
%   should instead use the threaded mouse and keyboard interface ..."

% event vs thread
% classic thread vs event slide.

% In the end most of the simple graphical apps (lens/color/clock) use events.
% The complex one use threads (rio/acme/sam/abaco).

% The event pipe!

% have lots of dupes, menuhit.c vs emenuhit.c?

%alt: X11 has XEvent structure
%related: big-bang function in racket/htdp

\subsection{Data structures}

<<enum Key>>=
enum
{
    Emouse	= 1,
    Ekeyboard	= 2,
};
@
% keys, arguments to einit. bitset actually.
% bitset because can have multiple events at the same time

<<type keys>>=
// bitset<Key>
typedef ulong keys;
@


<<struct Event>>=
struct	Event
{
    int		kbdc;
    Mouse	mouse;

    int		n;		/* number of characters in message */
    void	*v;		/* data unpacked by general event-handling function */
    byte	data[EMAXMSG];	/* message from an arbitrary file descriptor */
};
@
% int or Rune for kbdc?

% dupe of include/mouse.h
<<struct Mouse (include/event.h)>>=
struct	Mouse
{
    int		buttons;	/* bit array: LMR=124 */
    Point	xy;
    ulong	msec;
};
@

% dupe of include/mouse.h
<<struct Menu (include/event.h)>>=
struct Menu
{
    char	**item;
    char	*(*gen)(int);
    int	lasthit;
};
@

<<enum _anon_ (include/event.h)2>>=
enum
{
    MAXSLAVE = 32,
    EMAXMSG = 128+8192,	/* size of 9p header+data */
};
@
% 32 cos use bitset. A bit like select set?

<<struct Slave>>=
struct Slave
{
    int	pid;

    Ebuf	*head;		/* queue of messages for this descriptor */
    Ebuf	*tail;

    int	(*fn)(int, Event*, uchar*, int);
};
@
% generalize the special ioproc for the mouse and the keyboard
% but in the end the same.

<<struct Ebuf>>=
struct Ebuf
{
    int	n;		/* number of bytes in buf */
    byte	buf[EMAXMSG];

    // Extra
    Ebuf	*next;
};
@

<<global eslave>>=
static	Slave	eslave[MAXSLAVE];
@
<<global nslave>>=
static	int	nslave;
@



<<global Skeyboard>>=
static	int	Skeyboard = -1;
@
% index in eslave? the ioproc for the keyboard?

<<global Smouse>>=
static	int	Smouse = -1;
@

<<global Stimer>>=
static	int	Stimer = -1;
@


<<global parentpid>>=
static	int	parentpid;
@

<<global logfid>>=
static	fdt	logfid;
@


% The event pipe!
<<global epipe>>=
static	fdt	epipe[2];
@
% One pipe shared by all slaves. atomic write? I think so.
% first byte is slave identifier, followed by variable number of
% bytes depending if mouse or keyboard or something else.

<<global mousefd>>=
static	fdt	mousefd;
@
<<global cursorfd>>=
static	fdt	cursorfd;
@

\subsection{Initialization, [[einit()]]}

<<function einit>>=
void
einit(keys keys)
{
    fdt ctl, fd;
    char buf[256];

    parentpid = getpid();
    if(pipe(epipe) < 0)
        drawerror(display, "events: einit pipe");

    atexit(ekill);
    atnotify(enote, 1);

    snprint(buf, sizeof buf, "%s/mouse", display->devdir);
    mousefd = open(buf, ORDWR|OCEXEC);
    if(mousefd < 0)
        drawerror(display, "einit: can't open mouse\n");

    snprint(buf, sizeof buf, "%s/cursor", display->devdir);
    cursorfd = open(buf, ORDWR|OCEXEC);
    if(cursorfd < 0)
        drawerror(display, "einit: can't open cursor\n");

    if(keys&Ekeyboard){
        snprint(buf, sizeof buf, "%s/cons", display->devdir);
        fd = open(buf, OREAD);
        if(fd < 0)
            drawerror(display, "events: can't open console");

        snprint(buf, sizeof buf, "%s/consctl", display->devdir);
        ctl = open("/dev/consctl", OWRITE|OCEXEC);
        if(ctl < 0)
            drawerror(display, "events: can't open consctl");
        write(ctl, "rawon", 5);

        for(Skeyboard=0; Ekeyboard & ~(1<<Skeyboard); Skeyboard++)
            ;
        ekeyslave(fd);
    }
    if(keys&Emouse){
        estart(Emouse, mousefd, 1+4*12);
        for(Smouse=0; Emouse & ~(1<<Smouse); Smouse++)
            ;
    }
}
@
% >> >> >>


<<function ekill>>=
static void
ekill(void)
{
    enote(0, 0);
}
@

<<function enote>>=
static int
enote(void *v, char *s)
{
    char t[1];
    int i, pid;

    USED(v, s);
    pid = getpid();
    if(pid != parentpid){
        for(i=0; i<nslave; i++){
            if(pid == eslave[i].pid){
                t[0] = MAXSLAVE;
                write(epipe[1], t, 1);
                break;
            }
        }
        return 0;
    }
    close(epipe[0]);
    epipe[0] = -1;
    close(epipe[1]);
    epipe[1] = -1;
    for(i=0; i<nslave; i++){
        if(pid == eslave[i].pid)
            continue;	/* don't kill myself */
        postnote(PNPROC, eslave[i].pid, "die");
    }
    return 0;
}
@

\subsection{The slaves}

<<function ekeyslave>>=
static void
ekeyslave(fdt fd)
{
    Rune r;
    char t[3], k[10];
    int kr, kn, w;

    if(eforkslave(Ekeyboard) < MAXSLAVE)
        // parent (master)
        return;

    // child (slave) code
    kn = 0;
    t[0] = Skeyboard;
    for(;;){
        while(!fullrune(k, kn)){
            // blocking call
            kr = read(fd, k+kn, sizeof k - kn);
            if(kr <= 0)
                goto breakout;
            kn += kr;
        }
        w = chartorune(&r, k);
        kn -= w;
        memmove(k, &k[w], kn);
        t[1] = r;
        t[2] = r>>8; // TODO what about other parts of the Rune????
        // send to master
        if(write(epipe[1], t, 3) != 3)
            break;
    }
breakout:;
    t[0] = MAXSLAVE;
    write(epipe[1], t, 1);
    _exits(0);
}
@


<<function eforkslave>>=
static int
eforkslave(ulong key)
{
    int i, pid;

    for(i=0; i<MAXSLAVE; i++)
        if((key & ~(1<<i)) == 0 && eslave[i].pid == 0){
            if(nslave <= i)
                nslave = i + 1;
            /*
             * share the file descriptors so the last child
             * out closes all connections to the window server.
             */
            switch(pid = rfork(RFPROC)){
            // child
            case 0:
                return MAXSLAVE+i;
            case -1:
                fprint(2, "events: fork error\n");
                exits("fork");
            }
            // parent
            eslave[i].pid = pid;
            eslave[i].head = eslave[i].tail = nil;
            return i;
        }
    drawerror(display, "events: bad slave assignment");
    return 0;
}
@
% >> >>



% for the mouse
<<function estart>>=
ulong
estart(ulong key, fdt fd, int n)
{
    return estartfn(key, fd, n, nil);
}
@

<<function estartfn>>=
ulong
estartfn(ulong key, fdt fd, int n, int (*fn)(int, Event*, uchar*, int))
{
    char buf[EMAXMSG+1];
    int i, r;

    if(fd < 0)
        drawerror(display, "events: bad file descriptor");
    if(n <= 0 || n > EMAXMSG)
        n = EMAXMSG;

    i = eforkslave(key);
    // master
    if(i < MAXSLAVE){
        eslave[i].fn = fn;
        return 1<<i;
    }
    // slave
    buf[0] = i - MAXSLAVE; // slave identifier
    while((r = read(fd, buf+1, n))>0)
        if(write(epipe[1], buf, r+1)!=r+1)
            break;

    buf[0] = MAXSLAVE;
    write(epipe[1], buf, 1);
    _exits(nil);
    return 0;
}
@
% >>




\subsection{Event loop, [[event()]]}

% to get next event, usually called in event loop
<<function event>>=
keys
event(Event *e)
{
    return eread(~0UL, e);
}
@

<<function eread>>=
keys
eread(keys keys, Event *e)
{
    Ebuf *eb;
    int i, id;

    if(keys == 0)
        return 0;
    for(;;){
        // check if pending message
        for(i=0; i<nslave; i++) {
            if((keys & (1<<i)) && eslave[i].head){
                id = 1<<i;
                if(i == Smouse)
                    e->mouse = emouse();
                else if(i == Skeyboard)
                    e->kbdc = ekbd();
                else if(i == Stimer)
                    eslave[i].head = nil;
                else{
                    eb = ebread(&eslave[i]);
                    e->n = eb->n;
                    if(eslave[i].fn)
                        id = (*eslave[i].fn)(id, e, eb->buf, eb->n);
                    else
                        memmove(e->data, eb->buf, eb->n);
                    free(eb);
                }
                return id;
            }
        }
        // read from pipe new messages from the slaves
        extract();
    }
    return 0; // unreachable
}
@
% >> >>
%note: would like to use switch, but the Smouse are not constants, they
% are static globals



<<function emouse>>=
Mouse
emouse(void)
{
    Mouse m;
    Ebuf *eb;
    static int but[2];
    int b;

    if(Smouse < 0)
        drawerror(display, "events: mouse not initialized");
    eb = ebread(&eslave[Smouse]);
    m.xy.x = atoi((char*)eb->buf+1+0*12);
    m.xy.y = atoi((char*)eb->buf+1+1*12);
    b = atoi((char*)eb->buf+1+2*12);
    m.buttons = b;
    m.msec = atoi((char*)eb->buf+1+3*12);
    if (logfid)
        fprint(logfid, "b: %d xy: %P\n", m.buttons, m.xy);
    free(eb);
    return m;
}
@

<<function ekbd>>=
int
ekbd(void)
{
    Ebuf *eb;
    int c;

    if(Skeyboard < 0)
        drawerror(display, "events: keyboard not initialzed");
    eb = ebread(&eslave[Skeyboard]);
    c = eb->buf[0] + (eb->buf[1]<<8);
    free(eb);
    return c;
}
@
% >>



% emouse | ekbd | eread  -> <>
<<function ebread>>=
static
Ebuf*
ebread(Slave *s)
{
    Ebuf *eb;
    Dir *d;
    ulong l;

    for(;;){
        d = dirfstat(epipe[0]);
        if(d == nil)
            drawerror(display, "events: eread stat error");
        l = d->length;
        free(d);
        if(s->head && l==0)
            break;
        // else
        extract();
    }
    // eb = pop_queue(s->head, s->tail);
    eb = s->head;
    s->head = s->head->next;
    if(s->head == nil)
        s->tail = nil;

    return eb;
}
@

\subsection{The master, [[extract()]]}

<<function extract>>=
static void
extract(void)
{
    Slave *s;
    Ebuf *eb;
    int i, n;
    byte ebuf[EMAXMSG+1];

    /* avoid generating a message if there's nothing to show. */
    /* this test isn't perfect, though; could do flushimage(display, 0) then call extract */
    /* also: make sure we don't interfere if we're multiprocessing the display */
    if(display->locking){
        /* if locking is being done by program, this means it can't depend on automatic flush in emouse() etc. */
        if(canqlock(&display->qlock)){
            if(display->bufp > display->buf)
                flushimage(display, true);
            unlockdisplay(display);
        }
    }else
        if(display->bufp > display->buf)
            flushimage(display, true);

loop:
    if((n=read(epipe[0], ebuf, EMAXMSG+1)) < 0
    || ebuf[0] >= MAXSLAVE)
        drawerror(display, "eof on event pipe");
    if(n == 0)
        goto loop;

    i = ebuf[0];
    if(i >= nslave || n <= 1)
        drawerror(display, "events: protocol error: short read");
    s = &eslave[i];

    if(i == Stimer){
        s->head = (Ebuf *)1;
        return;
    }
    if(i == Skeyboard && n != 3)
        drawerror(display, "events: protocol error: keyboard");
    if(i == Smouse){
        if(n < 1+1+2*12)
            drawerror(display, "events: protocol error: mouse");
        if(ebuf[1] == 'r')
            eresized(1);

        /* squash extraneous mouse events */
        if((eb=s->tail) && memcmp(eb->buf+1+2*12, ebuf+1+1+2*12, 12)==0){
            memmove(eb->buf, &ebuf[1], n - 1);
            return;
        }
    }

    /* try to save space by only allocating as much buffer as we need */
    eb = malloc(sizeof(*eb) - sizeof(eb->buf) + n - 1);
    if(eb == nil)
        drawerror(display, "events: protocol error 4");
    eb->n = n - 1;
    memmove(eb->buf, &ebuf[1], n - 1);

    // add_queue(eb, s->head, s->tail)
    eb->next = nil;
    if(s->head)
        s->tail = s->tail->next = eb;
    else
        s->head = s->tail = eb;
}
@
% what if multiple events in the pipe? first out win all?
% timer too??

\subsection{[[ecanxxx()]]}

<<function ecanmouse>>=
int
ecanmouse(void)
{
    if(Smouse < 0)
        drawerror(display, "events: mouse not initialized");
    return ecanread(Emouse);
}
@

<<function ecankbd>>=
int
ecankbd(void)
{
    if(Skeyboard < 0)
        drawerror(display, "events: keyboard not initialzed");
    return ecanread(Ekeyboard);
}
@

<<function ecanread>>=
int
ecanread(ulong keys)
{
    Dir *d;
    int i;
    ulong l;

    for(;;){
        for(i=0; i<nslave; i++)
            if((keys & (1<<i)) && eslave[i].head)
                return 1;
        d = dirfstat(epipe[0]);
        if(d == nil)
            drawerror(display, "events: ecanread stat error");
        l = d->length;
        free(d);
        if(l == 0)
            return 0;
        extract();
    }
    return 0; // unreachable
}
@
% >>

\subsection{Timer}

<<function etimer>>=
ulong
etimer(ulong key, int n)
{
    char t[2];
    int cnt;

    if(Stimer != -1)
        drawerror(display, "events: timer started twice");
    Stimer = eforkslave(key);
    // master
    if(Stimer < MAXSLAVE)
        return 1<<Stimer;
    // slave
    if(n <= 0)
        n = 1000;
    t[0] = t[1] = Stimer - MAXSLAVE;
    do {
        sleep(n);
        cnt = write(epipe[1], t, 2);
    } while(cnt == 2);

    t[0] = MAXSLAVE;
    write(epipe[1], t, 1);
    _exits(nil);
    return 0;
}
@
% >> >> >> >> >>
%old: I moved the write outside the while and use a cnt local





\subsection{Misc}

<<function emoveto>>=
void
emoveto(Point pt)
{
    char buf[2*12+2];
    int n;

    n = sprint(buf, "m%d %d", pt.x, pt.y);
    write(mousefd, buf, n);
}
@

<<function esetcursor>>=
void
esetcursor(Cursor *c)
{
    uchar curs[2*4+2*2*16];

    if(c == 0)
        write(cursorfd, curs, 0);
    else{
        BPLONG(curs+0*4, c->offset.x);
        BPLONG(curs+1*4, c->offset.y);
        memmove(curs+2*4, c->clr, 2*2*16);
        write(cursorfd, curs, sizeof curs);
    }
}
@

<<function ereadmouse>>=
int
ereadmouse(Mouse *m)
{
    int n;
    char buf[128];

    do{
        n = read(mousefd, buf, sizeof(buf));
        if(n < 0)	/* probably interrupted */
            return -1;
        n = eatomouse(m, buf, n);
    }while(n == 0);
    return n;
}
@

<<function eatomouse>>=
int
eatomouse(Mouse *m, char *buf, int n)
{
    if(n != 1+4*12){
        werrstr("atomouse: bad count");
        return -1;
    }

    if(buf[0] == 'r')
        eresized(1);
    m->xy.x = atoi(buf+1+0*12);
    m->xy.y = atoi(buf+1+1*12);
    m->buttons = atoi(buf+1+2*12);
    m->msec = atoi(buf+1+3*12);
    return n;
}
@


\subsection{[[egetrects.c]]}
% event version of getrects.c ?


<<constant W>>=
#define	W	Borderwidth
@

<<global tmp>>=
static Image *tmp[4];
@

<<global red>>=
static Image *red;
@

<<global sweep>>=
static Cursor sweep={
    {-7, -7},
    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0x07,
     0xE0, 0x07, 0xE0, 0x07, 0xE3, 0xF7, 0xE3, 0xF7,
     0xE3, 0xE7, 0xE3, 0xF7, 0xE3, 0xFF, 0xE3, 0x7F,
     0xE0, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,},
    {0x00, 0x00, 0x7F, 0xFE, 0x40, 0x02, 0x40, 0x02,
     0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x41, 0xE2,
     0x41, 0xC2, 0x41, 0xE2, 0x41, 0x72, 0x40, 0x38,
     0x40, 0x1C, 0x40, 0x0E, 0x7F, 0xE6, 0x00, 0x00,}
};
@

% edrawgetrects -> <>
<<function brects>>=
static
void
brects(Rectangle r, Rectangle rp[4])
{
    if(Dx(r) < 2*W)
        r.max.x = r.min.x+2*W;
    if(Dy(r) < 2*W)
        r.max.y = r.min.y+2*W;
    rp[0] = Rect(r.min.x, r.min.y, r.max.x, r.min.y+W);
    rp[1] = Rect(r.min.x, r.max.y-W, r.max.x, r.max.y);
    rp[2] = Rect(r.min.x, r.min.y+W, r.min.x+W, r.max.y-W);
    rp[3] = Rect(r.max.x-W, r.min.y+W, r.max.x, r.max.y-W);
}
@

<<function egetrect>>=
Rectangle
egetrect(int but, Mouse *m)
{
    Rectangle r, rc;

    but = 1<<(but-1);
    esetcursor(&sweep);
    while(m->buttons)
        *m = emouse();
    while(!(m->buttons & but)){
        *m = emouse();
        if(m->buttons & (7^but))
            goto Return;
    }
    r.min = m->xy;
    r.max = m->xy;
    do{
        rc = canonrect(r);
        edrawgetrect(rc, 1);
        *m = emouse();
        edrawgetrect(rc, 0);
        r.max = m->xy;
    }while(m->buttons == but);

    Return:
    esetcursor(0);
    if(m->buttons & (7^but)){
        rc.min.x = rc.max.x = 0;
        rc.min.y = rc.max.y = 0;
        while(m->buttons)
            *m = emouse();
    }
    return rc;
}
@

<<function freetmp>>=
static
void
freetmp(void)
{
    freeimage(tmp[0]);
    freeimage(tmp[1]);
    freeimage(tmp[2]);
    freeimage(tmp[3]);
    freeimage(red);
    tmp[0] = tmp[1] = tmp[2] = tmp[3] = red = nil;
}
@

<<function edrawgetrect>>=
void
edrawgetrect(Rectangle rc, int up)
{
    int i;
    Rectangle r, rects[4];

    if(up && tmp[0]!=nil)
        if(Dx(tmp[0]->r)<Dx(rc) || Dy(tmp[2]->r)<Dy(rc))
            freetmp();

    if(tmp[0] == 0){
        r = Rect(0, 0, Dx(view->r), W);
        tmp[0] = allocimage(display, r, view->chan, 0, -1);
        tmp[1] = allocimage(display, r, view->chan, 0, -1);
        r = Rect(0, 0, W, Dy(view->r));
        tmp[2] = allocimage(display, r, view->chan, 0, -1);
        tmp[3] = allocimage(display, r, view->chan, 0, -1);
        red = allocimage(display, Rect(0,0,1,1), view->chan, 1, DRed);
        if(tmp[0]==0 || tmp[1]==0 || tmp[2]==0 || tmp[3]==0 || red==0)
            drawerror(display, "getrect: allocimage failed");
    }
    brects(rc, rects);
    if(!up){
        for(i=0; i<4; i++)
            draw(view, rects[i], tmp[i], nil, ZP);
        return;
    }
    for(i=0; i<4; i++){
        draw(tmp[i], Rect(0, 0, Dx(rects[i]), Dy(rects[i])), view, nil, rects[i].min);
        draw(view, rects[i], red, nil, ZP);
    }
}
@

\subsection{[[emenuhits.c]]}
% event version of menuhits.c

<<enum _anon_ (lib_graphics/libdraw/emenuhit.c)>>=
enum
{
    Margin = 4,		/* outside to text */
    Border = 2,		/* outside to selection boxes */
    Blackborder = 2,	/* width of outlining border */
    Vspacing = 2,		/* extra spacing between lines of text */
    Maxunscroll = 25,	/* maximum #entries before scrolling turns on */
    Nscroll = 20,		/* number entries in scrolling part */
    Scrollwid = 14,		/* width of scroll bar */
    Gap = 4,			/* between text and scroll bar */
};
@

<<global menutxt>>=
static	Image	*menutxt;
@

<<global back>>=
static	Image	*back;
@

<<global high>>=
static	Image	*high;
@

<<global bord>>=
static	Image	*bord;
@

<<global text>>=
static	Image	*text;
@

<<global htext>>=
static	Image	*htext;
@

<<function menucolors>>=
static
void
menucolors(void)
{
    /* Main tone is greenish, with negative selection */
    back = allocimagemix(display, DPalegreen, DWhite);
    high = allocimage(display, Rect(0,0,1,1), CMAP8, 1, DDarkgreen);	/* dark green */
    bord = allocimage(display, Rect(0,0,1,1), CMAP8, 1, DMedgreen);	/* not as dark green */
    if(back == nil || high == nil || bord == nil)
        goto Error;
    text = display->black;
    htext = back;
    return;

    Error:
    freeimage(back);
    freeimage(high);
    freeimage(bord);
    back = display->white;
    high = display->black;
    bord = display->black;
    text = display->black;
    htext = display->white;
}
@

<<function menurect>>=
/*
 * r is a rectangle holding the text elements.
 * return the rectangle, including its black edge, holding element i.
 */
static Rectangle
menurect(Rectangle r, int i)
{
    if(i < 0)
        return Rect(0, 0, 0, 0);
    r.min.y += (font->height+Vspacing)*i;
    r.max.y = r.min.y+font->height+Vspacing;
    return insetrect(r, Border-Margin);
}
@

<<function menusel>>=
/*
 * r is a rectangle holding the text elements.
 * return the element number containing p.
 */
static int
menusel(Rectangle r, Point p)
{
    r = insetrect(r, Margin);
    if(!ptinrect(p, r))
        return -1;
    return (p.y-r.min.y)/(font->height+Vspacing);
}
@

<<function paintitem>>=
static
void
paintitem(Menu *menu, Rectangle textr, int off, int i, int highlight, Image *save, Image *restore)
{
    char *item;
    Rectangle r;
    Point pt;

    if(i < 0)
        return;
    r = menurect(textr, i);
    if(restore){
        draw(view, r, restore, nil, restore->r.min);
        return;
    }
    if(save)
        draw(save, save->r, view, nil, r.min);
    item = menu->item? menu->item[i+off] : (*menu->gen)(i+off);
    pt.x = (textr.min.x+textr.max.x-stringwidth(font, item))/2;
    pt.y = textr.min.y+i*(font->height+Vspacing);
    draw(view, r, highlight? high : back, nil, pt);
    string(view, pt, highlight? htext : text, pt, font, item);
}
@

<<function menuscan>>=
/*
 * menur is a rectangle holding all the highlightable text elements.
 * track mouse while inside the box, return what's selected when button
 * is raised, -1 as soon as it leaves box.
 * invariant: nothing is highlighted on entry or exit.
 */
static int
menuscan(Menu *menu, int but, Mouse *m, Rectangle textr, int off, int lasti, Image *save)
{
    int i;

    paintitem(menu, textr, off, lasti, 1, save, nil);
    flushimage(display, true);	/* in case display->locking is set */
    *m = emouse();
    while(m->buttons & (1<<(but-1))){
        flushimage(display, true);	/* in case display->locking is set */
        *m = emouse();
        i = menusel(textr, m->xy);
        if(i != -1 && i == lasti)
            continue;
        paintitem(menu, textr, off, lasti, 0, nil, save);
        if(i == -1)
            return i;
        lasti = i;
        paintitem(menu, textr, off, lasti, 1, save, nil);
    }
    return lasti;
}
@

<<function menupaint>>=
static void
menupaint(Menu *menu, Rectangle textr, int off, int nitemdrawn)
{
    int i;

    draw(view, insetrect(textr, Border-Margin), back, nil, ZP);
    for(i = 0; i<nitemdrawn; i++)
        paintitem(menu, textr, off, i, 0, nil, nil);
}
@

<<function menuscrollpaint>>=
static void
menuscrollpaint(Rectangle scrollr, int off, int nitem, int nitemdrawn)
{
    Rectangle r;

    draw(view, scrollr, back, nil, ZP);
    r.min.x = scrollr.min.x;
    r.max.x = scrollr.max.x;
    r.min.y = scrollr.min.y + (Dy(scrollr)*off)/nitem;
    r.max.y = scrollr.min.y + (Dy(scrollr)*(off+nitemdrawn))/nitem;
    if(r.max.y < r.min.y+2)
        r.max.y = r.min.y+2;
    border(view, r, 1, bord, ZP);
    if(menutxt == 0)
        menutxt = allocimage(display, Rect(0, 0, 1, 1), CMAP8, 1, DDarkgreen);
    if(menutxt)
        draw(view, insetrect(r, 1), menutxt, nil, ZP);
}
@

<<function emenuhit>>=
int
emenuhit(int but, Mouse *m, Menu *menu)
{
    int i, nitem, nitemdrawn, maxwid, lasti, off, noff, wid, screenitem;
    int scrolling;
    Rectangle r, menur, sc, textr, scrollr;
    Image *b, *save;
    Point pt;
    char *item;

    if(back == nil)
        menucolors();
    sc = view->clipr;
    replclipr(view, 0, view->r);
    maxwid = 0;
    for(nitem = 0;
        item = menu->item? menu->item[nitem] : (*menu->gen)(nitem);
        nitem++){
        i = stringwidth(font, item);
        if(i > maxwid)
            maxwid = i;
    }
    if(menu->lasthit<0 || menu->lasthit>=nitem)
        menu->lasthit = 0;
    screenitem = (Dy(view->r)-10)/(font->height+Vspacing);
    if(nitem>Maxunscroll || nitem>screenitem){
        scrolling = 1;
        nitemdrawn = Nscroll;
        if(nitemdrawn > screenitem)
            nitemdrawn = screenitem;
        wid = maxwid + Gap + Scrollwid;
        off = menu->lasthit - nitemdrawn/2;
        if(off < 0)
            off = 0;
        if(off > nitem-nitemdrawn)
            off = nitem-nitemdrawn;
        lasti = menu->lasthit-off;
    }else{
        scrolling = 0;
        nitemdrawn = nitem;
        wid = maxwid;
        off = 0;
        lasti = menu->lasthit;
    }
    r = insetrect(Rect(0, 0, wid, nitemdrawn*(font->height+Vspacing)), -Margin);
    r = rectsubpt(r, Pt(wid/2, lasti*(font->height+Vspacing)+font->height/2));
    r = rectaddpt(r, m->xy);
    pt = ZP;
    if(r.max.x>view->r.max.x)
        pt.x = view->r.max.x-r.max.x;
    if(r.max.y>view->r.max.y)
        pt.y = view->r.max.y-r.max.y;
    if(r.min.x<view->r.min.x)
        pt.x = view->r.min.x-r.min.x;
    if(r.min.y<view->r.min.y)
        pt.y = view->r.min.y-r.min.y;
    menur = rectaddpt(r, pt);
    textr.max.x = menur.max.x-Margin;
    textr.min.x = textr.max.x-maxwid;
    textr.min.y = menur.min.y+Margin;
    textr.max.y = textr.min.y + nitemdrawn*(font->height+Vspacing);
    if(scrolling){
        scrollr = insetrect(menur, Border);
        scrollr.max.x = scrollr.min.x+Scrollwid;
    }else
        scrollr = Rect(0, 0, 0, 0);

    b = allocimage(display, menur, view->chan, 0, 0);
    if(b == 0)
        b = view;
    draw(b, menur, view, nil, menur.min);
    draw(view, menur, back, nil, ZP);
    border(view, menur, Blackborder, bord, ZP);
    save = allocimage(display, menurect(textr, 0), view->chan, 0, -1);
    r = menurect(textr, lasti);
    emoveto(divpt(addpt(r.min, r.max), 2));
    menupaint(menu, textr, off, nitemdrawn);
    if(scrolling)
        menuscrollpaint(scrollr, off, nitem, nitemdrawn);
    while(m->buttons & (1<<(but-1))){
        lasti = menuscan(menu, but, m, textr, off, lasti, save);
        if(lasti >= 0)
            break;
        while(!ptinrect(m->xy, textr) && (m->buttons & (1<<(but-1)))){
            if(scrolling && ptinrect(m->xy, scrollr)){
                noff = ((m->xy.y-scrollr.min.y)*nitem)/Dy(scrollr);
                noff -= nitemdrawn/2;
                if(noff < 0)
                    noff = 0;
                if(noff > nitem-nitemdrawn)
                    noff = nitem-nitemdrawn;
                if(noff != off){
                    off = noff;
                    menupaint(menu, textr, off, nitemdrawn);
                    menuscrollpaint(scrollr, off, nitem, nitemdrawn);
                }
            }
            flushimage(display, true);	/* in case display->locking is set */
            *m = emouse();
        }
    }
    draw(view, menur, b, nil, menur.min);
    if(b != view)
        freeimage(b);
    freeimage(save);
    replclipr(view, 0, sc);
    if(lasti >= 0){
        menu->lasthit = lasti+off;
        return menu->lasthit;
    }
    return -1;
}
@
% >> >>



\section{Graphical text mode}

% when do aux/vga it switches to graphic mode, but we still want a console!
% the kernel still needs a working (*screenputs)(...).

% this used to be a subsection of VGA driver, 
% but the code seems quite generic and almost independent of VGA
% so I moved it here.


<<global curpos>>=
Point     swconsole_curpos;
@
<<global window bis>>=
Rectangle swconsole_window;
@


<<global conscol>>=
Memimage *swconsole_conscol;
@
<<global back2>>=
Memimage *swconsole_back;
@

<<global memdefont2>>=
Memsubfont *swconsole_memdefont;
@


% main -> arch__screeninit -> screenwin -> <>
<<function swconsole_init>>=
void swconsole_init(void)
{
    Rectangle r;

    swconsole_back = memwhite;
    swconsole_conscol = memblack;

    swconsole_memdefont = getmemdefont();
    w = swconsole_memdefont->info[' '].width;
    h = swconsole_memdefont->height;

    r = insetrect(gscreen->r, 4);
    memimagedraw(gscreen, r, memblack, ZP, memopaque, ZP, S);
    swconsole_window = insetrect(r, 4);
    memimagedraw(gscreen, swconsole_window, memwhite, ZP, memopaque, ZP, S);
}
@


<<global swconsole h w>>=
static int h, w;
@

<<global swconsole_screenlock>>=
Lock      swconsole_screenlock;
@


<<function swconsole_scroll>>=
void
swconsole_scroll(void)
{
    int o;
    Point p;
    Rectangle r;

    o = Scroll*h;
    r = Rpt(swconsole_window.min, 
            Pt(swconsole_window.max.x, swconsole_window.max.y-o));
    p = Pt(swconsole_window.min.x, swconsole_window.min.y+o);
    memimagedraw(gscreen, r, gscreen, p, nil, p, S);
    arch_flushmemscreen(r);
    r = Rpt(Pt(swconsole_window.min.x, swconsole_window.max.y-o), 
            swconsole_window.max);
    memimagedraw(gscreen, r, swconsole_back, ZP, nil, ZP, S);
    arch_flushmemscreen(r);

    swconsole_curpos.y -= o;
}
@

<<function swconsole_screenputc>>=
void
swconsole_screenputc(char *buf)
{
    int w;
    uint pos;
    Point p;
    Rectangle r;
    static int *xp;
    static int xbuf[256];

    if (xp < xbuf || xp >= &xbuf[sizeof(xbuf)])
        xp = xbuf;

    switch (buf[0]) {
    case '\n':
        if (swconsole_curpos.y + h >= swconsole_window.max.y)
            swconsole_scroll();
        swconsole_curpos.y += h;
        swconsole_screenputc("\r");
        break;
    case '\r':
        xp = xbuf;
        swconsole_curpos.x = swconsole_window.min.x;
        break;
    case '\t':
        p = memsubfontwidth(swconsole_memdefont, " ");
        w = p.x;
        if (swconsole_curpos.x >= swconsole_window.max.x - Tabstop * w)
            swconsole_screenputc("\n");

        pos = (swconsole_curpos.x - swconsole_window.min.x) / w;
        pos = Tabstop - pos % Tabstop;
        *xp++ = swconsole_curpos.x;
        r = Rect(swconsole_curpos.x, swconsole_curpos.y, 
                 swconsole_curpos.x + pos * w, swconsole_curpos.y + h);
        memimagedraw(gscreen, r, swconsole_back, 
                     swconsole_back->r.min, nil, swconsole_back->r.min, S);
        arch_flushmemscreen(r);
        swconsole_curpos.x += pos * w;
        break;
    case '\b':
        if (xp <= xbuf)
            break;
        xp--;
        r = Rect(*xp, swconsole_curpos.y, 
                 swconsole_curpos.x, swconsole_curpos.y + h);
        memimagedraw(gscreen, r, swconsole_back, 
                     swconsole_back->r.min, nil, swconsole_back->r.min, S);
        arch_flushmemscreen(r);
        swconsole_curpos.x = *xp;
        break;
    case '\0':
        break;
    default:
        p = memsubfontwidth(swconsole_memdefont, buf);
        w = p.x;

        if (swconsole_curpos.x >= swconsole_window.max.x - w)
            swconsole_screenputc("\n");

        *xp++ = swconsole_curpos.x;
        r = Rect(swconsole_curpos.x, swconsole_curpos.y, 
                 swconsole_curpos.x + w, swconsole_curpos.y + h);
        memimagedraw(gscreen, r, swconsole_back, 
                     swconsole_back->r.min, nil, swconsole_back->r.min, S);
        memimagestring(gscreen, swconsole_curpos, swconsole_conscol, ZP, 
                       swconsole_memdefont, buf);
        arch_flushmemscreen(r);
        swconsole_curpos.x += w;
        break;
    }
}
@

<<function swconsole_screenputs>>=
void
swconsole_screenputs(char *s, int n)
{
    int i;
    Rune r;
    char buf[4];

    if(!arch_islo()) {
        /* don't deadlock trying to print in interrupt */
        if(!canlock(&swconsole_screenlock))
            return; 
    }
    else
        lock(&swconsole_screenlock);

    while(n > 0){
        i = chartorune(&r, s);
        if(i == 0){
            s++;
            --n;
            continue;
        }
        memmove(buf, s, i);
        buf[i] = 0;
        n -= i;
        s += i;
        swconsole_screenputc(buf);
    }
    unlock(&swconsole_screenlock);
}
@







\section{Blank screen}
% used by screenlock.c, used to save energy?

%echo blang > /dev/vgactl ??

<<[[vgactl]] cases(x86)>>=
case CMblank:
    drawblankscreen(true);
    return;
@
<<[[vgactl]] cases(x86)>>=
case CMunblank:
    drawblankscreen(false);
    return;
@

<<[[KDraw]] other fields>>=
bool	blanked;    /* screen turned off */
@


% in draw!
<<function drawblankscreen>>=
void
drawblankscreen(bool blank)
{
    int i, nc;
    ulong *p;

    if(blank == sdraw.blanked)
        return;
    if(!candlock())
        return;
    if(screenimage == nil){
        dunlock();
        return;
    }
    p = sdraw.savemap;
    nc = screenimage->depth > 8 ? 256 : 1<<screenimage->depth;

    /*
     * blankscreen uses the hardware to blank the screen
     * when possible.  to help in cases when it is not possible,
     * we set the color map to be all black.
     */
    if(!blank){ /* turn screen on */
        for(i=0; i<nc; i++, p+=3)
            arch_setcolor(i, p[0], p[1], p[2]);
        arch_blankscreen(false);
    }else{  /* turn screen off */
        arch_blankscreen(true);
        for(i=0; i<nc; i++, p+=3){
            arch_getcolor(i, &p[0], &p[1], &p[2]);
            arch_setcolor(i, 0, 0, 0);
        }
    }
    sdraw.blanked = blank;
    dunlock();
}
@
% >>

<<[[KDraw]] other fields>>=
ulong   savemap[3*256];
@



<<global blanktime>>=
ulong blanktime = 30;   /* in minutes; a half hour */
@
% used by drawactive()
<<[[vgactl]] cases(x86)>>=
case CMblanktime:
    blanktime = strtoul(cb->f[1], 0, 0);
    return;
@

<<[[KDraw]] other fields>>=
ulong   blanktime;  /* time of last operation */
@

% seems always caleld with active = true (from draw read/write colormap)
<<function drawactive>>=
/*
 * record activity on screen, changing blanking as appropriate
 */
void
drawactive(bool active)
{
    if(active){
        drawblankscreen(false);
        sdraw.blanktime = CPUS(0)->ticks;
    }else{
        if(blanktime && sdraw.blanktime 
           && TK2SEC(CPUS(0)->ticks - sdraw.blanktime)/60 >= blanktime)
            drawblankscreen(true);
    }
}
@

% vgaread -> <>
<<function drawidletime>>=
int
drawidletime(void)
{
    return TK2SEC(CPUS(0)->ticks - sdraw.blanktime)/60;
}
@

\subsection{Hardware support hook (x86)}

<<global hwblank(x86)>>=
bool hwblank = false;    /* turned on by drivers that are known good */
@

<<[[vgactl]] cases(x86)>>=
case CMhwblank:
    if(strcmp(cb->f[1], "on") == 0)
        hwblank = true;
    else if(strcmp(cb->f[1], "off") == 0)
        hwblank = false;
    else
        break;
    return;
@



<<[[VGAscr]] optional methods(x86)>>=
void  (*blank)(VGAscr*, int);
@

<<[[VGAscr]] other fields(x86)>>=
int isblank;
@
% dead isblank? not set in drawblankscreen, probably bug no?

<<function blankscreen bis(x86)>>=
void
arch_blankscreen(int blank)
{
    VGAscr *scr;

    scr = &vgascreen;
    if(hwblank){
        if(scr->blank)
            scr->blank(scr, blank);
        else
            vgablank(scr, blank);
    }
}
@

% blankscreen -> <>
<<function vgablank(x86)>>=
/*
 * Supposedly this is the way to turn DPMS
 * monitors off using just the VGA registers.
 * Unfortunately, it seems to mess up the video mode
 * on the cards I've tried.
 */
void
vgablank(VGAscr*, int blank)
{
    uchar seq1, crtc17;

    if(blank) {
        seq1 = 0x00;
        crtc17 = 0x80;
    } else {
        seq1 = 0x20;
        crtc17 = 0x00;
    }

    outs(Seqx, 0x0100);         /* synchronous reset */
    seq1 |= vgaxi(Seqx, 1) & ~0x20;
    vgaxo(Seqx, 1, seq1);
    crtc17 |= vgaxi(Crtx, 0x17) & ~0x80;
    arch_delay(10);
    vgaxo(Crtx, 0x17, crtc17);
    outs(Crtx, 0x0300);             /* end synchronous reset */
}
@



\section{Refresh methods}
\label{sec:refresh}

<<[[Client]] other fields>>=
Refresh*    refresh;
Rendez      refrend;
int     refreshme;
@

<<function drawrefactive>>=
int
drawrefactive(void *a)
{
    Client *c;

    c = a;
    return c->refreshme || c->refresh != nil;
}
@


<<struct Refresh>>=
struct Refresh
{
    DImage*     dimage;
    Rectangle   r;
    Refresh*    next;
};
@


% many -> <>
<<function drawwakeall>>=
void
drawwakeall(void)
{
    Client *cl;
    int i;

    for(i=0; i<sdraw.nclient; i++){
        cl = sdraw.client[i];
        if(cl && (cl->refreshme || cl->refresh))
            wakeup(&cl->refrend);
    }
}
@

<<[[drawclose()]] other locals>>=
Refresh *r;
@

<<[[drawclose()]] free refresh>>=
while(r = cl->refresh){ /* assign = */
    cl->refresh = r->next;
    free(r);
}
@

\subsection{[[/dev/draw/x/refresh]]}
\label{sec:refresh-device}

<<[[Display]] devdraw connection fields>>=
fdt		reffd; // /dev/draw/x/refresh
@

<<[[drawread()]] other locals>>=
Refresh *r;
@

<<[[drawread()]] switch qid cases>>=
case Qrefresh:
    if(n < 5*4)
        error(Ebadarg);
    for(;;){
        if(cl->refreshme || cl->refresh)
            break;

        dunlock();
        if(waserror()){
            dlock();    /* restore lock for waserror() above */
            nexterror();
        }

        sleep(&cl->refrend, drawrefactive, cl);

        poperror();
        dlock();
    }
    p = a;
    while(cl->refresh && n>=5*4){
        r = cl->refresh;
        BPLONG(p+0*4, r->dimage->id);
        BPLONG(p+1*4, r->r.min.x);
        BPLONG(p+2*4, r->r.min.y);
        BPLONG(p+3*4, r->r.max.x);
        BPLONG(p+4*4, r->r.max.y);
        cl->refresh = r->next;
        free(r);
        p += 5*4;
        n -= 5*4;
    }
    cl->refreshme = 0;
    n = p-(uchar*)a;
    break;
@



\subsection{Window refresh}

<<[[ldrawop()]] return if no save in dst>>=
if(insave && d->dstlayer->save == nil)
    return;
@

<<[[memdraw()]] if refresh function for src>>=
if(sl->save == nil)
    return;	/* refresh function makes this case unworkable */
@
% todo, memdraw does not handle src where window and refresh func

<<[[memdraw()]] if refresh function for dst>>=
if(dl->save == nil)
    return;	/* refresh function makes this case unworkable */
@

<<[[drawfreedimage()]] free refreshptr>>=
if(l->layer->refreshfn == drawrefresh)  /* else true owner will clean up */
    free(l->layer->refreshptr);
l->layer->refreshptr = nil;
@

<<function drawrefresh>>=
void
drawrefresh(Memimage*, Rectangle r, void *v)
{
    Refx *x;
    DImage *d;
    Client *c;
    Refresh *ref;

    if(v == 0)
        return;
    x = v;
    c = x->client;
    d = x->dimage;
    for(ref=c->refresh; ref; ref=ref->next)
        if(ref->dimage == d){
            combinerect(&ref->r, r);
            return;
        }
    ref = malloc(sizeof(Refresh));
    if(ref){
        ref->dimage = d;
        ref->r = r;
        ref->next = c->refresh;
        c->refresh = ref;
    }
}
@

<<[[drawmesg()]] free image case, if dscreen>>=
if(ll && ll->dscreen && ll->dscreen->owner != client)
    ll->dscreen->owner->refreshme = 1;
@



<<struct Refx>>=
struct Refx
{
    Client*     client;
    DImage*     dimage;
};
@




% used by shadow window in originwindow
<<function memlnorefresh>>=
void
memlnorefresh(Memimage *l, Rectangle r, void *v)
{
    USED(l);
    USED(r.min.x);
    USED(v);
}
@


<<[[lexposeop()]] if not save but refresh method>>=
else
    l->refreshfn(dst, r, l->refreshptr);
@

<<[[drawmesg()]] when top or bottom windows, refresh>>=
ll = drawlookup(client, BGLONG(a+1+1+2), true);
drawrefreshscreen(ll, client);
@

<<[[drawmesg()]] when position window, refresh>>=
ll = drawlookup(client, BGLONG(a+1), true);
drawrefreshscreen(ll, client);
@


<<function drawrefreshscreen>>=
void
drawrefreshscreen(DImage *l, Client *client)
{
    while(l != nil && l->dscreen == nil)
        l = l->fromname;
    if(l != nil && l->dscreen->owner != client)
        l->dscreen->owner->refreshme = 1;
}
@


<<[[Memlayer]] refresh fields>>=
Refreshfn	refreshfn;		/* function to call to refresh obscured parts if save==nil */
void		*refreshptr;	/* argument to refreshfn */
@


<<[[drawmesg()]] locals>>=
Refreshfn reffn;
Refx *refx;
@

<<enum Refresh>>=
enum RefreshMethod
{
    /* refresh methods */
    Refbackup	= 0,
    Refnone		= 1,

    Refmesg		= 2 // incomplete apparently
};
@
% has meaning only for layers?


<<[[drawmesg()]] when allocate window, set reffn>>=
reffn = nil;
switch(refresh){
case Refbackup:
    break;
case Refnone:
    reffn = memlnorefresh;
    break;
case Refmesg:
    reffn = drawrefresh;
    break;
default:
    error("unknown refresh method");
}
@


<<[[drawmesg()]] when allocate window, if reffn>>=
if(reffn){
    refx = nil;
    if(reffn == drawrefresh){
        refx = malloc(sizeof(Refx));
        if(refx == 0){
            drawuninstall(client, dstid);
            error(Edrawmem);
        }
        refx->client = client;
        refx->dimage = drawlookup(client, dstid, true);
    }
    memlsetrefresh(l, reffn, refx);
}
@

<<[[memlalloc()]] if refreshfn>>=
if(refreshfn)
    l->save = nil;
@



<<[[memlalloc()]] set refresh fields part1>>=
l->refreshfn = refreshfn;
l->refreshptr = nil;	/* don't set it until we're done */
@

<<[[memlalloc()]] set refresh fields part2>>=
l->refreshptr = refreshptr;
@


<<function memlsetrefresh>>=
int
memlsetrefresh(Memimage *i, Refreshfn fn, void *ptr)
{
    Memlayer *l;

    l = i->layer;
    if(l->refreshfn!=nil && fn!=nil){	/* just change functions */
        l->refreshfn = fn;
        l->refreshptr = ptr;
        return 1;
    }

    if(l->refreshfn == nil){	/* is using backup image; just free it */
        freememimage(l->save);
        l->save = nil;
        l->refreshfn = fn;
        l->refreshptr = ptr;
        return 1;
    }

    l->save = allocmemimage(i->r, i->chan);
    if(l->save == nil)
        return 0;
    /* easiest way is just to update the entire save area */
    l->refreshfn(i, i->r, l->refreshptr);
    l->refreshfn = nil;
    l->refreshptr = nil;
    return 1;
}
@


\section{Concurrency}

\subsection{[[lockdisplay()]]}

<<[[Display]] concurrency fields>>=
QLock	qlock;
@


% seems related to IO. graphics(2) mentions it when
%  use multi-thread program! then need lock Display around
%  each API call

<<function lockdisplay>>=
void
lockdisplay(Display *disp)
{
    <<[[lockdisplay()]] if debuglockdisplay>>
    else
        qlock(&disp->qlock);
}
@

<<function unlockdisplay>>=
void
unlockdisplay(Display *disp)
{
    qunlock(&disp->qlock);
}
@


% also need notify the library to use a locking protocol also
% for its own accesses (seems used mostly when do internal IO)
<<[[Display]] concurrency fields>>=
bool		locking;	/*program is using lockdisplay */
@

\subsection{[[/dev/draw/x/ctl]] concurrent access}

<<[[drawopen()]] locals>>=
DImage *di;
DName *dn;
@

<<[[drawopen()]] switch qid cases>>=
case Qctl:
    cl = drawclient(c);

    <<[[drawopen()]] switch qid cases, when Qctl, set busy>>

    flushrect = Rect(10000, 10000, -10000, -10000);
    dn = drawlookupname(strlen(screenname), screenname);
    if(dn == nil)
        error("draw: cannot happen 2");

    if(drawinstall(cl, 0, dn->dimage->image, 0) == 0)
        error(Edrawmem);

    di = drawlookup(cl, 0, false);
    if(di == nil)
        error("draw: cannot happen 1");

    <<[[drawopen()]] switch qid cases, when Qctl, set name>>

    incref(&cl->r);
    break;
@
% this is used when someone else access Qctl? normally
%  should have been accessed via Qnew above

\t rect? clipped? or full access? protection?? can draw on
% other windows? when write on /dev/draw/x/ctl ?

%TODO: drawlookupname should be screen_dimage!! assert! 

<<[[drawopen()]] switch qid cases, when Qctl, set name>>=
di->vers = dn->vers;
di->name = smalloc(strlen(screenname)+1);
strcpy(di->name, screenname);
di->fromname = dn->dimage;
di->fromname->ref++;
@







<<[[drawopen()]] switch qid cases, when Qctl, set busy>>=
if(cl->busy)
    error(Einuse);
cl->busy = true;
@

<<[[drawclose()]] if Qctl>>=
if(QID(c->qid) == Qctl)
    cl->busy = false;
@

<<[[Client]] concurrency fields>>=
bool     busy;
@
% only one client of /dev/draw/x/ctl





\section{Optimisations}

\subsection{[[memimagedraw()]] optimisations}

\subsubsection{[[hwdraw()]] (x86)}

<<[[hwdraw()]] when dst is the screen>>=
if(scr->fill == nil && scr->scroll == nil)
    return false;
/*
 * If we have an opaque mask and source is one opaque
 * pixel we can convert to the destination format and just
 * replicate with memset.
 */
m = Simplesrc|Simplemask|Fullmask;
if(scr->fill
&& (par->state&m)==m
&& ((par->srgba&0xFF) == 0xFF)
&& (par->op&S) == S)
    return scr->fill(scr, par->r, par->sdval);

/*
 * If no source alpha, an opaque mask, we can just copy the
 * source onto the destination.  If the channels are the same and
 * the source is not replicated, memmove suffices.
 */
m = Simplemask|Fullmask;
if(scr->scroll
&& src->data->bdata==dst->data->bdata
&& !(src->flags&Falpha)
&& (par->state&m)==m
&& (par->op&S) == S)
    return scr->scroll(scr, par->r, par->sr);

return false;   
@

% see fill and scroll in appendix


\subsubsection{[[chardraw()]]}
% also see drawchar() optimisation

% not sure why it's called chardraw. Seems unrelated to fonts.

<<[[memimagedraw()]] try chardraw>>=
/*
 * Character drawing.
 * Solid source color being painted through a boolean mask onto a 
 * high res image.
 */
if(chardraw(&par)){
    DBG1("chardraw handled\n");
    return;
}
@


<<function chardraw>>=
/*
 * Boolean character drawing.
 * Solid opaque color through a 1-bit greyscale mask.
 */
static bool
chardraw(Memdrawparam *par)
{
    Rectangle r, mr;
    Memimage *mask, *src, *dst;
    int op;
    int dx, dy;

    ulong bits;
    int i, ddepth, x, bx, ex, y, npack, bsh, depth;
    ulong v, maskwid, dstwid;
    uchar *wp, *rp, *q, *wc;
    ushort *ws;
    ulong *wl;
    uchar sp[4];

    DBG1("chardraw? mf %lux md %d sf %lux dxs %d dys %d dd %d ddat %p sdat %p\n",
        par->mask->flags, par->mask->depth, par->src->flags, 
        Dx(par->src->r), Dy(par->src->r), par->dst->depth, par->dst->data, par->src->data);

    mask = par->mask;
    src = par->src;
    dst = par->dst;
    r = par->r;
    mr = par->mr;
    op = par->op;

    if((par->state&(Replsrc|Simplesrc|Replmask)) != (Replsrc|Simplesrc)
    || mask->depth != 1 
    || src->flags&Falpha 
    || dst->depth<8 
    || dst->data==src->data
    || op != SoverD)
        return false;

    // else

    DBG1("chardraw...");

    depth = mask->depth;
    maskwid = mask->width * sizeof(ulong);
    rp = byteaddr(mask, mr.min);
    npack = 8/depth;
    bsh = (mr.min.x % npack) * depth;

    wp = byteaddr(dst, r.min);
    dstwid = dst->width*sizeof(ulong);
    DBG1("bsh %d\n", bsh);
    dy = Dy(r);
    dx = Dx(r);

    ddepth = dst->depth;

    /*
     * for loop counts from bsh to bsh+dx
     *
     * we want the bottom bits to be the amount
     * to shift the pixels down, so for n≡0 (mod 8) we want 
     * bottom bits 7.  for n≡1, 6, etc.
     * the bits come from -n-1.
     */

    bx = -bsh-1;
    ex = -bsh-1-dx;
    SET(bits);
    v = par->sdval;

    /* make little endian */
    sp[0] = v;
    sp[1] = v>>8;
    sp[2] = v>>16;
    sp[3] = v>>24;

    DBG1("sp %x %x %x %x\n", sp[0], sp[1], sp[2], sp[3]);
    for(y=0; y<dy; y++, rp+=maskwid, wp+=dstwid){
        q = rp;
        if(bsh)
            bits = *q++;
        switch(ddepth){
        <<[[chardraw()]] switch depth cases>>
        case 32:
            wl = (ulong*)wp;
            v = *(ulong*)sp;
            for(x=bx; x>ex; x--, wl++){
                i = x&7;
                if(i == 8-1)
                    bits = *q++;
                DBG1("bits %lux sh %d...", bits, i);
                if((bits>>i)&1)
                    *wl = v;
            }
            break;
        }
    }

    DBG1("\n");	
    return 1;	
}
@

\subsection{[[alphadraw()]] optimisations}

\subsubsection{Small replicated rectangle}

<<[[ParamDraw]] replication fields>>=
bool	replcache;	/* if set, cache buffers */
@



<<[[getparam()]] if small replicated rectangle>>=
if((img->flags&Frepl) && Dy(img->r) <= MAXBCACHE && Dy(img->r) < Dy(r)){
    p->replcache = true;
    nbuf = Dy(img->r);
}
@

<<[[ParamDraw]] replication fields>>=
Readfn	*replcall;
@

<<[[alphadraw()]] when small repl rectangle optimization>>=
/*
 * If the image has a small enough repl rectangle,
 * we can just read each line once and cache them.
 */
if(z->spar.replcache){
    z->spar.replcall = rdsrc;
    rdsrc = replread;
}
if(z->mpar.replcache){
    z->mpar.replcall = rdmask;
    rdmask = replread;
}
@

<<[[ParamDraw]] replication fields>>=
Buffer	bcache[MAXBCACHE];
ulong	bfilled;
@

<<enum _anon_ (lib_graphics/libmemdraw/draw.c)>>=
enum {
    MAXBCACHE = 16
};
@


<<function replread>>=
/*
 * Replicated cached scan line read.  Call the function listed in the Param,
 * but cache the result so that for replicated images we only do the work once.
 */
static Buffer
replread(Param *p, uchar *s, int y)
{
    Buffer *b;

    USED(s);
    b = &p->bcache[y];
    if((p->bfilled & (1<<y)) == 0){
        p->bfilled |= 1<<y;
        *b = p->replcall(p, p->bufbase+y*p->bufdelta, y);
    }
    return *b;
}
@
% >> >>

\subsubsection{No alpha source}

<<[[alphadraw()]] if source has no alpha and simple bit mask>>=
/*
 * If the mask is purely boolean, we can convert from src to dst format
 * when we read src, and then just copy it to dst where the mask tells us to.
 * This requires a boolean (1-bit grey) mask and lack of a source alpha channel.
 *
 * The computation is accomplished by assigning the function pointers as follows:
 *	rdsrc - read and convert source into dst format in a buffer
 * 	rdmask - convert mask to bytes, set pointer to it
 * 	rddst - fill with pointer to real dst data, but do no reads
 *	calc - copy src onto dst when mask says to.
 *	wrdst - do nothing
 * This is slightly sleazy, since things aren't doing exactly what their names say,
 * but it avoids a fair amount of code duplication to make this a case here
 * rather than have a separate booldraw.
 */
if(!(src->flags&Falpha) 
&& mask->chan == GREY1 
&& dst->depth >= 8 
&& op == SoverD){
    rdsrc = convfn(dst, &z->dpar, src, &z->spar, &ndrawbuf);
    rddst = readptr;
    rdmask = readfn(mask);
    calc = boolcopyfn(dst, mask);
    wrdst = nullwrite;
}
@
%old:
% DBG1("flag %lud mchan %lux=?%x dd %d\n", src->flags&Falpha, mask->chan, GREY1, dst->depth);
%    DBG1("boolcopy...");


<<[[alphadraw()]] when mask and source have no alpha, possibly adapt calc>>=
/*
 * Should really be above, but then boolcopyfns would have
 * to deal with bit alignment, and I haven't written that.
 *
 * This is a common case for things like ellipse drawing.
 * When there's no alpha involved and the mask is boolean,
 * we can avoid all the division and multiplication.
 */
if(mask->chan == GREY1 && !(src->flags&Falpha))
    calc = boolcalc[op];
else if(op == SoverD && !(src->flags&Falpha))
    calc = alphacalcS;
@
% here means depth < 8


\subsubsection{Simple bit mask and big dest, [[boolcopyxxx()]]}

<<[[ParamDraw]] conversion fields>>=
Readfn	*convreadcall;
Writefn	*convwritecall;
int	convbufoff;
Param	*convdpar;
int	convdx;
@

<<function convfn>>=
static Readfn*
convfn(Memimage *dst, Param *dpar, Memimage *src, Param *spar, int *ndrawbuf)
{
    if(dst->chan == src->chan && !(src->flags&Frepl)){
        DBG1("readptr...");
        return readptr;
    }

    if(dst->chan==CMAP8 && (src->chan==GREY1||src->chan==GREY2||src->chan==GREY4)){
        /* cheat because we know the replicated value is exactly the color map entry. */
        DBG1("Readnbit...");
        return readnbit;
    }

    spar->convreadcall = readfn(src);
    spar->convwritecall = writefn(dst);
    spar->convdpar = dpar;

    /* allocate a conversion buffer */
    spar->convbufoff = *ndrawbuf;
    *ndrawbuf += spar->dx*4;

    if(spar->dx > Dx(spar->img->r)){
        spar->convdx = spar->dx;
        spar->dx = Dx(spar->img->r);
    }

    DBG1("genconv...");
    return genconv;
}
@


<<[[ParamDraw]] conversion fields>>=
uchar	*convbuf;
@

<<[[alphadraw()]] set z params part2>>=
z->spar.convbuf = drawbuf + z->spar.convbufoff;
@

<<function genconv>>=
static Buffer
genconv(Param *p, uchar *buf, int y)
{
    Buffer b;
    int nb;
    uchar *r, *w, *ew;

    /* read from source into RGB format in convbuf */
    b = p->convreadcall(p, p->convbuf, y);

    /* write RGB format into dst format in buf */
    p->convwritecall(p->convdpar, buf, b);

    if(p->convdx){
        nb = p->convdpar->img->depth/8;
        r = buf;
        w = buf+nb*p->dx;
        ew = buf+nb*p->convdx;
        while(w<ew)
            *w++ = *r++;
    }

    b.red = buf;
    b.blu = b.grn = b.grey = b.alpha = nil;
    b.rgba = (ulong*)buf;
    b.delta = 0;
    
    return b;
}
@






<<global nullwrite>>=
static Writefn	nullwrite;
@
<<function nullwrite>>=
static void
nullwrite(Param *p, uchar *s, Buffer b)
{
    USED(p);
    USED(s);
    USED(b);
}
@

<<function readptr>>=
static Buffer
readptr(Param *p, uchar *s, int y)
{
    Buffer b;
    uchar *q;

    USED(s);
    q = p->bytermin + y*p->bwidth;
    b.red = q;	/* ptr to data */
    b.grn = b.blu = b.grey = b.alpha = nil;
    b.rgba = (ulong*)q;
    b.delta = p->img->depth/8;
    return b;
}
@

<<function boolcopyfn>>=
static Calcfn*
boolcopyfn(Memimage *img, Memimage *mask)
{
    if(mask->flags&Frepl && Dx(mask->r)==1 && Dy(mask->r)==1 && pixelbits(mask, mask->r.min)==~0)
        return boolmemmove;

    switch(img->depth){
    case 8:
        return boolcopy8;
    case 16:
        return boolcopy16;
    case 24:
        return boolcopy24;
    case 32:
        return boolcopy32;
    default:
        assert(0 /* boolcopyfn */);
    }
    return nil;
}
@

<<function boolmemmove>>=
static Buffer
boolmemmove(Buffer bdst, Buffer bsrc, Buffer b1, int dx, int i, int o)
{
    USED(i);
    USED(o);
    USED(b1);
    USED(bsrc);
    memmove(bdst.red, bsrc.red, dx*bdst.delta);
    return bdst;
}
@

<<function boolcopy8>>=
static Buffer
boolcopy8(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, int i, int o)
{
    uchar *m, *r, *w, *ew;

    USED(i);
    USED(o);
    m = bmask.grey;
    w = bdst.red;
    r = bsrc.red;
    ew = w+dx;
    for(; w < ew; w++,r++)
        if(*m++)
            *w = *r;
    return bdst;	/* not used */
}
@

<<function boolcopy16>>=
static Buffer
boolcopy16(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, int i, int o)
{
    uchar *m;
    ushort *r, *w, *ew;

    USED(i);
    USED(o);
    m = bmask.grey;
    w = (ushort*)bdst.red;
    r = (ushort*)bsrc.red;
    ew = w+dx;
    for(; w < ew; w++,r++)
        if(*m++)
            *w = *r;
    return bdst;	/* not used */
}
@

<<function boolcopy24>>=
static Buffer
boolcopy24(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, int i, int o)
{
    uchar *m;
    uchar *r, *w, *ew;

    USED(i);
    USED(o);
    m = bmask.grey;
    w = bdst.red;
    r = bsrc.red;
    ew = w+dx*3;
    while(w < ew){
        if(*m++){
            *w++ = *r++;
            *w++ = *r++;
            *w++ = *r++;
        }else{
            w += 3;
            r += 3;
        }
    }
    return bdst;	/* not used */
}
@

<<function boolcopy32>>=
static Buffer
boolcopy32(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, int i, int o)
{
    uchar *m;
    ulong *r, *w, *ew;

    USED(i);
    USED(o);
    m = bmask.grey;
    w = (ulong*)bdst.red;
    r = (ulong*)bsrc.red;
    ew = w+dx;
    for(; w < ew; w++,r++)
        if(*m++)
            *w = *r;
    return bdst;	/* not used */
}
@

\subsubsection{Simple bit mask, [[boolcalcxxx()]]}

<<global boolcalc>>=
static Calcfn *boolcalc[Ncomp] =
{
    alphacalc0,		/* Clear */
    boolcalc14,		/* DoutS */
    boolcalc236789,		/* SoutD */
    boolcalc236789,		/* DxorS */
    boolcalc14,		/* DinS */
    alphacalc5,		/* D */
    boolcalc236789,		/* DatopS */
    boolcalc236789,		/* DoverS */
    boolcalc236789,		/* SinD */
    boolcalc236789,		/* SatopD */
    boolcalc1011,		/* S */
    boolcalc1011,		/* SoverD */
};
@

%dead?
<<[[Buffer]] boolcalc fields>>=
/* used by boolcalc* for mask data */
uchar	*m;		/* ptr to mask data r.min byte; like p->bytermin */
int		mskip;	/* no. of left bits to skip in *m */
uchar	*bm;		/* ptr to mask data img->r.min byte; like p->bytey0s */
int		bmskip;	/* no. of left bits to skip in *bm */
uchar	*em;		/* ptr to mask data img->r.max.x byte; like p->bytey0e */
int		emskip;	/* no. of right bits to skip in *em */
@


<<function boolcalc14>>=
static Buffer
boolcalc14(Buffer bdst, Buffer b1, Buffer bmask, int dx, int grey, int op)
{
    Buffer obdst;
    int i, ma, zero;

    USED(b1);

    obdst = bdst;

    for(i=0; i<dx; i++){
        ma = *bmask.alpha;
        zero = ma ? op == DoutS : op == DinS;

        if(grey){
            if(zero)
                *bdst.grey = 0;
            bdst.grey += bdst.delta;
        }else{
            if(zero)
                *bdst.red = *bdst.grn = *bdst.blu = 0;
            bdst.red += bdst.delta;
            bdst.blu += bdst.delta;
            bdst.grn += bdst.delta;
        }
        bmask.alpha += bmask.delta;
        if(bdst.alpha != &ones){
            if(zero)
                *bdst.alpha = 0;
            bdst.alpha += bdst.delta;
        }
    }
    return obdst;
}
@

<<function boolcalc236789>>=
static Buffer
boolcalc236789(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, int grey, int op)
{
    Buffer obdst;
    int fs, fd;
    int i, ma, da, zero;
    ulong s, t;

    obdst = bdst;
    zero = !(op&1);

    for(i=0; i<dx; i++){
        ma = *bmask.alpha;
        da = *bdst.alpha;
        fs = da;
        if(op&2)
            fs = 255-da;
        fd = 0;
        if(op&4)
            fd = 255;

        if(grey){
            if(ma)
                *bdst.grey = MUL(fs, *bsrc.grey, s)+MUL(fd, *bdst.grey, t);
            else if(zero)
                *bdst.grey = 0;
            bsrc.grey += bsrc.delta;
            bdst.grey += bdst.delta;
        }else{
            if(ma){
                *bdst.red = MUL(fs, *bsrc.red, s)+MUL(fd, *bdst.red, t);
                *bdst.grn = MUL(fs, *bsrc.grn, s)+MUL(fd, *bdst.grn, t);
                *bdst.blu = MUL(fs, *bsrc.blu, s)+MUL(fd, *bdst.blu, t);
            }
            else if(zero)
                *bdst.red = *bdst.grn = *bdst.blu = 0;
            bsrc.red += bsrc.delta;
            bsrc.blu += bsrc.delta;
            bsrc.grn += bsrc.delta;
            bdst.red += bdst.delta;
            bdst.blu += bdst.delta;
            bdst.grn += bdst.delta;
        }
        bmask.alpha += bmask.delta;
        if(bdst.alpha != &ones){
            if(ma)
                *bdst.alpha = fs+MUL(fd, da, t);
            else if(zero)
                *bdst.alpha = 0;
            bdst.alpha += bdst.delta;
        }
    }
    return obdst;
}
@

<<function boolcalc1011>>=
static Buffer
boolcalc1011(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, int grey, int op)
{
    Buffer obdst;
    int i, ma, zero;

    obdst = bdst;
    zero = !(op&1);

    for(i=0; i<dx; i++){
        ma = *bmask.alpha;

        if(grey){
            if(ma)
                *bdst.grey = *bsrc.grey;
            else if(zero)
                *bdst.grey = 0;
            bsrc.grey += bsrc.delta;
            bdst.grey += bdst.delta;
        }else{
            if(ma){
                *bdst.red = *bsrc.red;
                *bdst.grn = *bsrc.grn;
                *bdst.blu = *bsrc.blu;
            }
            else if(zero)
                *bdst.red = *bdst.grn = *bdst.blu = 0;
            bsrc.red += bsrc.delta;
            bsrc.blu += bsrc.delta;
            bsrc.grn += bsrc.delta;
            bdst.red += bdst.delta;
            bdst.blu += bdst.delta;
            bdst.grn += bdst.delta;
        }
        bmask.alpha += bmask.delta;
        if(bdst.alpha != &ones){
            if(ma)
                *bdst.alpha = 255;
            else if(zero)
                *bdst.alpha = 0;
            bdst.alpha += bdst.delta;
        }
    }
    return obdst;
}
@






\subsubsection{No alpha source, [[alphacalcS()]]}

<<function alphacalcS>>=
/* source alpha 1 */
static Buffer
alphacalcS(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, int grey, int op)
{
    Buffer obdst;
    int fd;
    int i, ma;
    ulong s, t;

    USED(op);
    obdst = bdst;

    for(i=0; i<dx; i++){
        ma = *bmask.alpha;
        fd = 255-ma;

        if(grey){
            *bdst.grey = MUL(ma, *bsrc.grey, s)+MUL(fd, *bdst.grey, t);
            bsrc.grey += bsrc.delta;
            bdst.grey += bdst.delta;
        }else{
            *bdst.red = MUL(ma, *bsrc.red, s)+MUL(fd, *bdst.red, t);
            *bdst.grn = MUL(ma, *bsrc.grn, s)+MUL(fd, *bdst.grn, t);
            *bdst.blu = MUL(ma, *bsrc.blu, s)+MUL(fd, *bdst.blu, t);
            bsrc.red += bsrc.delta;
            bsrc.blu += bsrc.delta;
            bsrc.grn += bsrc.delta;
            bdst.red += bdst.delta;
            bdst.blu += bdst.delta;
            bdst.grn += bdst.delta;
        }
        if(bdst.alpha != &ones){
            *bdst.alpha = ma+MUL(fd, *bdst.alpha, t);
            bdst.alpha += bdst.delta;
        }
        bmask.alpha += bmask.delta;
    }
    return obdst;
}
@

\subsubsection{32 bits SoverD [[alphacalc()]]}

<<[[alphacalc11()]] special case for 32bits source and dest>>=
if(q){
    *bdst.rgba = MUL0123(ma, *bsrc.rgba, s, t)+MUL0123(fd, *bdst.rgba, u, v);
    bsrc.rgba++;
    bdst.rgba++;
    bsrc.alpha += sadelta;
    bmask.alpha += bmask.delta;
    continue;
}
@


<<function MUL0123>>=
#define MUL0123(a, x, s, t)	((MUL13(a, x, s)<<8)|MUL02(a, x, t))
@


<<function MUL13>>=
#define MUL13(a, x, t)		(t = (a)*(((x)&MASK13)>>8)+128, ((t+((t>>8)&MASK02))>>8)&MASK02)
@

<<constant MASK13>>=
#define MASK13	0xFF00FF00
@


<<function MUL02>>=
#define MUL02(a, x, t)		(t = (a)*(((x)&MASK02)>>0)+128, ((t+((t>>8)&MASK02))>>8)&MASK02)
@
<<constant MASK02>>=
#define MASK02	0x00FF00FF
@


\subsection{[[drawchar()]] optimisations}

% (to not confuse with chardraw)

<<[[drawchar()]] other locals>>=
static Memimage *tmp;
@

<<[[drawchar()]] optimization when possible>>=
/*
 * If we're drawing greyscale fonts onto a VGA screen,
 * it's very costly to read the screen memory to do the
 * alpha blending inside memdraw.  If this is really a stringbg,
 * then rdst is the bg image (in main memory) which we can
 * refer to for the underlying dst pixels instead of reading dst
 * directly.
 */
if(arch_ishwimage(dst) && !arch_ishwimage(rdst) && font->image->depth > 1){
    if(tmp == nil || tmp->chan != dst->chan || Dx(tmp->r) < Dx(r) || Dy(tmp->r) < Dy(r)){
        if(tmp)
            freememimage(tmp);
        tmp = allocmemimage(Rect(0,0,Dx(r),Dy(r)), dst->chan);
        if(tmp == nil)
            goto fallback;
    }
    memdraw(tmp, Rect(0,0,Dx(r),Dy(r)), rdst, r.min, memopaque, ZP, S);
    memdraw(tmp, Rect(0,0,Dx(r),Dy(r)), src, sp1, font->image, 
      Pt(fc->minx, fc->miny), op);
    memdraw(dst, r, tmp, ZP, memopaque, ZP, S);
}
@

\subsection{Flushing bounding boxes}

\subsubsection{Flushing lines}

% useful optimisation?


<<[[drawmesg()]] when draw line, possible flush>>=
/* avoid memlinebbox if possible */
if(dstid==0 || dst->layer!=nil){
    /* BUG: this is terribly inefficient: update maximal containing rect*/
    r = memlinebbox(p, q, e0, e1, j);
    dstflush(dstid, dst, insetrect(r, -(1+1+j)));
}
@

<<function memlinebbox>>=
Rectangle
memlinebbox(Point p0, Point p1, int end0, int end1, int radius)
{
    Rectangle r, r1;
    int extra;

    r.min.x = 10000000;
    r.min.y = 10000000;
    r.max.x = -10000000;
    r.max.y = -10000000;
    extra = lmax(memlineendsize(end0), memlineendsize(end1));
    r1 = insetrect(canonrect(Rpt(p0, p1)), -(radius+extra));
    addbbox(&r, r1.min);
    addbbox(&r, r1.max);
    return r;
}
@
% need canonrect here?

<<function memlineendsize>>=
int
memlineendsize(int end)
{
    int x3;

    if((end&0x3F) != Endarrow)
        return 0;
    if(end == Endarrow)
        x3 = Arrow3;
    else
        x3 = (end>>23) & 0x1FF;
    return x3;
}
@


<<function lmax>>=
static
int
lmax(int a, int b)
{
    if(a > b)
        return a;
    return b;
}
@


<<function addbbox>>=
/*
 * Simple-minded conservative code to compute bounding box of line.
 * Result is probably a little larger than it needs to be.
 */
static
void
addbbox(Rectangle *r, Point p)
{
    if(r->min.x > p.x)
        r->min.x = p.x;
    if(r->min.y > p.y)
        r->min.y = p.y;
    if(r->max.x < p.x+1)
        r->max.x = p.x+1;
    if(r->max.y < p.y+1)
        r->max.y = p.y+1;
}
@



\subsubsection{Flushing polygons}

<<[[drawmesg()]] when draw polygon, set doflush>>=
doflush = false;
if(dstid==0 || (dst->layer && dst->layer->screen->image->data == screenimage->data))
    doflush = true;    /* simplify test in loop */
@


<<[[drawmesg()]] when draw polygon, if doflush>>=
if(doflush){
    esize = j;
    if(*a == 'p'){
        if(y == 0){
            c = memlineendsize(e0);
            if(c > esize)
                esize = c;
        }
        if(y == ni-1){
            c = memlineendsize(e1);
            if(c > esize)
                esize = c;
        }
    }
    if(*a=='P' && e0!=1 && e0 !=~0)
        r = dst->clipr;
    else if(y > 0){
        r = Rect(q.x-oesize, q.y-oesize, q.x+oesize+1, q.y+oesize+1);
        combinerect(&r, Rect(p.x-esize, p.y-esize, p.x+esize+1, p.y+esize+1));
    }
    if(rectclip(&r, dst->clipr))  /* should perhaps be an arg to dstflush */
        dstflush(dstid, dst, r);
}
@

<<[[drawmesg()]] when draw polygon, special flush if y is 1>>=
if(y == 1)
    dstflush(dstid, dst, Rect(p.x-esize, p.y-esize, p.x+esize+1, p.y+esize+1));
@


\subsubsection{Flushing ellipses}

<<[[drawmesg()]] when draw ellipse, dstflush>>=
dstflush(dstid, dst, Rect(p.x-e0-j, p.y-e1-j, p.x+e0+j+1, p.y+e1+j+1));
@

\subsubsection{Flushing text}

<<[[drawmesg()]] when draw text, dstflush>>=
p.y -= font->ascent;
dstflush(dstid, dst, Rect(p.x, p.y, q.x, p.y+Dy(font->image->r)));
@

\subsubsection{Flushing and windows}


<<[[drawfreedimage()]] addflush>>=
if(l->data == screenimage->data)
    addflush(l->layer->screenr);
@

<<[[dstflush()]] locals>>=
Memlayer *l;
@

<<[[dstflush()]] if layer>>=
l = dst->layer;
if(l == nil)
    return;

// else
do{
    if(l->screen->image->data != screenimage->data)
        return;
    r = rectaddpt(r, l->delta);
    l = l->screen->image->layer;
}while(l);

addflush(r);

@


<<[[drawmesg()]] when allocate window, addflush>>=
addflush(l->layer->screenr);
@

<<[[drawmesg()]] when top or bottom windows, addflush>>=
if(lp[0]->layer->screen->image->data == screenimage->data)
    for(j=0; j<nw; j++)
        addflush(lp[j]->layer->screenr);
@


<<[[drawmesg()]] when position window, addflush>>=
addflush(r);
addflush(dst->layer->screenr);
@


% drawmsg(draw) -> dstflush -> <>
<<function addflush>>=
void
addflush(Rectangle r)
{
    int abb, ar, anbb;
    Rectangle nbb;

    if(!sdraw.softscreen || !rectclip(&r, screenimage->r))
        return;
    if(flushrect.min.x >= flushrect.max.x){
        flushrect = r;
        waste = 0;
        return;
    }
    // else

    nbb = flushrect;
    combinerect(&nbb, r);
    ar = Dx(r)*Dy(r);
    abb = Dx(flushrect)*Dy(flushrect);
    anbb = Dx(nbb)*Dy(nbb);
    /*
     * Area of new waste is area of new bb minus area of old bb,
     * less the area of the new segment, which we assume is not waste.
     * This could be negative, but that's OK.
     */
    waste += anbb-abb - ar;
    if(waste < 0)
        waste = 0;
    /*
     * absorb if:
     *  total area is small
     *  waste is less than half total area
     *  rectangles touch
     */
    if(anbb<=1024 || waste*2<anbb || rectXrect(flushrect, r)){
        flushrect = nbb;
        return;
    }

    /* emit current state */
    if(flushrect.min.x < flushrect.max.x)
        arch_flushmemscreen(flushrect);
    flushrect = r;

    waste = 0;
}
@
<<global waste>>=
static  int     waste;
@



\subsection{Image compression}

<<constant NMATCH>>=
/*
 * Compressed image file parameters and helper routines
 */
#define	NMATCH	3		/* shortest match possible */
@

<<constant NRUN>>=
#define	NRUN	(NMATCH+31)	/* longest match possible */
@


\subsubsection{Loading compressed images}


% user -> <>
<<function cloadimage>>=
int
cloadimage(Image *i, Rectangle r, uchar *data, int ndata)
{
    int m, nb, miny, maxy, ncblock;
    uchar *a;

    if(!rectinrect(r, i->r)){
        werrstr("cloadimage: bad rectangle");
        return -1;
    }

    miny = r.min.y;
    m = 0;
    ncblock = _compblocksize(r, i->depth);
    while(miny != r.max.y){
        maxy = atoi((char*)data+0*12);
        nb = atoi((char*)data+1*12);
        if(maxy<=miny || r.max.y<maxy){
            werrstr("creadimage: bad maxy %d", maxy);
            return -1;
        }
        data += 2*12;
        ndata -= 2*12;
        m += 2*12;
        if(nb<=0 || ncblock<nb || nb>ndata){
            werrstr("creadimage: bad count %d", nb);
            return -1;
        }
        a = bufimage(i->display, 21+nb);
        if(a == nil)
            return -1;
        a[0] = 'Y';
        BPLONG(a+1, i->id);
        BPLONG(a+5, r.min.x);
        BPLONG(a+9, miny);
        BPLONG(a+13, r.max.x);
        BPLONG(a+17, maxy);
        memmove(a+21, data, nb);
        miny = maxy;
        data += nb;
        ndata += nb;
        m += nb;
    }
    return m;
}
@




<<[[memload()]] if iscompressed>>=
if(iscompressed)
    loadfn = cloadmemimage;
@


% memload -> <> (as loadfn)
<<function cloadmemimage>>=
int
cloadmemimage(Memimage *i, Rectangle r, uchar *data, int ndata)
{
    int y, bpl, c, cnt, offs;
    uchar mem[NMEM], *memp, *omemp, *emem, *linep, *elinep, *u, *eu;

    if(!rectinrect(r, i->r))
        return -1;
    bpl = bytesperline(r, i->depth);
    u = data;
    eu = data+ndata;
    memp = mem;
    emem = mem+NMEM;
    y = r.min.y;
    linep = byteaddr(i, Pt(r.min.x, y));
    elinep = linep+bpl;
    for(;;){
        if(linep == elinep){
            if(++y == r.max.y)
                break;
            linep = byteaddr(i, Pt(r.min.x, y));
            elinep = linep+bpl;
        }
        if(u == eu){	/* buffer too small */
            return -1;
        }
        c = *u++;
        if(c >= 128){
            for(cnt=c-128+1; cnt!=0 ;--cnt){
                if(u == eu){		/* buffer too small */
                    return -1;
                }
                if(linep == elinep){	/* phase error */
                    return -1;
                }
                *linep++ = *u;
                *memp++ = *u++;
                if(memp == emem)
                    memp = mem;
            }
        }
        else{
            if(u == eu)	/* short buffer */
                return -1;
            offs = *u++ + ((c&3)<<8)+1;
            if(memp-mem < offs)
                omemp = memp+(NMEM-offs);
            else
                omemp = memp-offs;
            for(cnt=(c>>2)+NMATCH; cnt!=0; --cnt){
                if(linep == elinep)	/* phase error */
                    return -1;
                *linep++ = *omemp;
                *memp++ = *omemp++;
                if(omemp == emem)
                    omemp = mem;
                if(memp == emem)
                    memp = mem;
            }
        }
    }
    return u-data;
}
@



\subsubsection{Reading compressed images}


<<[[readimage()]] if first 11 characters are compressed string>>=
if(memcmp(hdr, "compressed\n", 11) == 0)
    return creadimage(d, fd, dolock);
@

% readimage -> <>
<<function creadimage>>=
Image *
creadimage(Display *d, int fd, int dolock)
{
    char hdr[5*12+1];
    Rectangle r;
    int m, nb, miny, maxy, new, ldepth, ncblock;
    uchar *buf, *a;
    Image *i;
    ulong chan;

    if(readn(fd, hdr, 5*12) != 5*12)
        return nil;

    /*
     * distinguish new channel descriptor from old ldepth.
     * channel descriptors have letters as well as numbers,
     * while ldepths are a single digit formatted as %-11d.
     */
    new = 0;
    for(m=0; m<10; m++){
        if(hdr[m] != ' '){
            new = 1;
            break;
        }
    }
    if(hdr[11] != ' '){
        werrstr("creadimage: bad format");
        return nil;
    }
    if(new){
        hdr[11] = '\0';
        if((chan = strtochan(hdr)) == 0){
            werrstr("creadimage: bad channel string %s", hdr);
            return nil;
        }
    }else{
        ldepth = ((int)hdr[10])-'0';
        if(ldepth<0 || ldepth>3){
            werrstr("creadimage: bad ldepth %d", ldepth);
            return nil;
        }
        chan = drawld2chan[ldepth];
    }
    r.min.x=atoi(hdr+1*12);
    r.min.y=atoi(hdr+2*12);
    r.max.x=atoi(hdr+3*12);
    r.max.y=atoi(hdr+4*12);
    if(r.min.x>r.max.x || r.min.y>r.max.y){
        werrstr("creadimage: bad rectangle");
        return nil;
    }

    if(d){
        if(dolock)
            lockdisplay(d);
        i = allocimage(d, r, chan, 0, 0);
        <<[[creadimage()]] set malloc tag for debug>>
        if(dolock)
            unlockdisplay(d);
        if(i == nil)
            return nil;
    }else{
        i = mallocz(sizeof(Image), 1);
        if(i == nil)
            return nil;
    }
    ncblock = _compblocksize(r, chantodepth(chan));
    buf = malloc(ncblock);
    if(buf == nil)
        goto Errout;
    miny = r.min.y;
    while(miny != r.max.y){
        if(readn(fd, hdr, 2*12) != 2*12){
        Errout:
            if(dolock)
                lockdisplay(d);
        Erroutlock:
            freeimage(i);
            if(dolock)
                unlockdisplay(d);
            free(buf);
            return nil;
        }
        maxy = atoi(hdr+0*12);
        nb = atoi(hdr+1*12);
        if(maxy<=miny || r.max.y<maxy){
            werrstr("creadimage: bad maxy %d", maxy);
            goto Errout;
        }
        if(nb<=0 || ncblock<nb){
            werrstr("creadimage: bad count %d", nb);
            goto Errout;
        }
        if(readn(fd, buf, nb)!=nb)
            goto Errout;
        if(d){
            if(dolock)
                lockdisplay(d);
            a = bufimage(i->display, 21+nb);
            if(a == nil)
                goto Erroutlock;
            a[0] = 'Y';
            BPLONG(a+1, i->id);
            BPLONG(a+5, r.min.x);
            BPLONG(a+9, miny);
            BPLONG(a+13, r.max.x);
            BPLONG(a+17, maxy);
            if(!new)	/* old image: flip the data bits */
                _twiddlecompressed(buf, nb);
            memmove(a+21, buf, nb);
            if(dolock)
                unlockdisplay(d);
        }
        miny = maxy;
    }
    free(buf);
    return i;
}
@


% creadimage -> <>
<<function _compblocksize>>=
int
_compblocksize(Rectangle r, int depth)
{
    int bpl;

    bpl = bytesperline(r, depth);
    bpl = 2*bpl;	/* add plenty extra for blocking, etc. */
    if(bpl < NCBLOCK)
        return NCBLOCK;
    return bpl;
}
@



% creadimage -> <>
% for old image format
<<function _twiddlecompressed>>=
/*
 * compressed data are seuences of byte codes.  
 * if the first byte b has the 0x80 bit set, the next (b^0x80)+1 bytes
 * are data.  otherwise, it's two bytes specifying a previous string to repeat.
 */
void
_twiddlecompressed(uchar *buf, int n)
{
    uchar *ebuf;
    int j, k, c;

    ebuf = buf+n;
    while(buf < ebuf){
        c = *buf++;
        if(c >= 128){
            k = c-128+1;
            for(j=0; j<k; j++, buf++)
                *buf ^= 0xFF;
        }else
            buf++;
    }
}
@



\subsubsection{Writing compressed images}

<<constant HSHIFT>>=
#define	HSHIFT	3	/* HSHIFT==5 runs slightly faster, but hash table is 64x bigger */
@

<<constant NHASH>>=
#define	NHASH	(1<<(HSHIFT*NMATCH))
@

<<constant HMASK>>=
#define	HMASK	(NHASH-1)
@

<<function hupdate>>=
#define	hupdate(h, c)	((((h)<<HSHIFT)^(c))&HMASK)
@

<<struct Hlist>>=
struct Hlist{
    uchar *s;
    Hlist *next, *prev;
};
@

% >> >>


<<constant NMEM>>=
#define	NMEM	1024		/* window size */
@

<<constant NDUMP>>=
#define	NDUMP	128		/* maximum length of dump */
@

<<constant NCBLOCK>>=
#define	NCBLOCK	6000		/* size of compressed blocks */
@



<<function writeimage>>=
int
writeimage(fdt fd, Image *i, bool dolock)
{
    uchar *outbuf, *outp, *eout;		/* encoded data, pointer, end */
    uchar *loutp;				/* start of encoded line */
    Hlist *hash;				/* heads of hash chains of past strings */
    Hlist *chain, *hp;			/* hash chain members, pointer */
    Hlist *cp;				/* next Hlist to fall out of window */
    int h;					/* hash value */
    uchar *line, *eline;			/* input line, end pointer */
    uchar *data, *edata;			/* input buffer, end pointer */
    ulong n;				/* length of input buffer */
    ulong nb;				/* # of bytes returned by unloadimage */
    int bpl;				/* input line length */
    int offs, runlen;			/* offset, length of consumed data */
    uchar dumpbuf[NDUMP];			/* dump accumulator */
    int ndump;				/* length of dump accumulator */
    int miny, dy;				/* y values while unloading input */
    int chunk, ncblock;
    Rectangle r;
    uchar *p, *q, *s, *es, *t;
    char hdr[11+5*12+1];
    char cbuf[20];

    chunk = i->display->bufsize - 32;	/* a little room for header */
    r = i->r;
    bpl = bytesperline(r, i->depth);
    n = Dy(r)*bpl;
    data = malloc(n);

    ncblock = _compblocksize(r, i->depth);
    outbuf = malloc(ncblock);
    hash = malloc(NHASH*sizeof(Hlist));
    chain = malloc(NMEM*sizeof(Hlist));
    if(data == 0 || outbuf == 0 || hash == 0 || chain == 0){
    ErrOut:
        free(data);
        free(outbuf);
        free(hash);
        free(chain);
        return -1;
    }

    for(miny = r.min.y; miny != r.max.y; miny += dy){
        dy = r.max.y-miny;
        if(dy*bpl > chunk)
            dy = chunk/bpl;

        if(dolock)
            lockdisplay(i->display);

        nb = unloadimage(i, Rect(r.min.x, miny, r.max.x, miny+dy),
            data+(miny-r.min.y)*bpl, dy*bpl);

        if(dolock)
            unlockdisplay(i->display);

        if(nb != dy*bpl)
            goto ErrOut;
    }

    sprint(hdr, "compressed\n%11s %11d %11d %11d %11d ",
        chantostr(cbuf, i->chan), r.min.x, r.min.y, r.max.x, r.max.y);
    if(write(fd, hdr, 11+5*12) != 11+5*12)
        goto ErrOut;
    edata = data+n;
    eout = outbuf+ncblock;
    line = data;
    r.max.y = r.min.y;
    while(line != edata){
        memset(hash, 0, NHASH*sizeof(Hlist));
        memset(chain, 0, NMEM*sizeof(Hlist));
        cp = chain;
        h = 0;
        outp = outbuf;
        for(n = 0; n != NMATCH; n++)
            h = hupdate(h, line[n]);
        loutp = outbuf;
        while(line != edata){
            ndump = 0;
            eline = line+bpl;
            for(p = line; p != eline; ){
                if(eline-p < NRUN)
                    es = eline;
                else
                    es = p+NRUN;
                q = 0;
                runlen = 0;
                for(hp = hash[h].next; hp; hp = hp->next){
                    s = p + runlen;
                    if(s >= es)
                        continue;
                    t = hp->s + runlen;
                    for(; s >= p; s--)
                        if(*s != *t--)
                            goto matchloop;
                    t += runlen+2;
                    s += runlen+2;
                    for(; s < es; s++)
                        if(*s != *t++)
                            break;
                    n = s-p;
                    if(n > runlen){
                        runlen = n;
                        q = hp->s;
                        if(n == NRUN)
                            break;
                    }
            matchloop: ;
                }
                if(runlen < NMATCH){
                    if(ndump == NDUMP){
                        if(eout-outp < ndump+1)
                            goto Bfull;
                        *outp++ = ndump-1+128;
                        memmove(outp, dumpbuf, ndump);
                        outp += ndump;
                        ndump = 0;
                    }
                    dumpbuf[ndump++] = *p;
                    runlen = 1;
                }
                else{
                    if(ndump != 0){
                        if(eout-outp < ndump+1)
                            goto Bfull;
                        *outp++ = ndump-1+128;
                        memmove(outp, dumpbuf, ndump);
                        outp += ndump;
                        ndump = 0;
                    }
                    offs = p-q-1;
                    if(eout-outp < 2)
                        goto Bfull;
                    *outp++ = ((runlen-NMATCH)<<2) + (offs>>8);
                    *outp++ = offs&255;
                }
                for(q = p+runlen; p != q; p++){
                    if(cp->prev)
                        cp->prev->next = 0;
                    cp->next = hash[h].next;
                    cp->prev = &hash[h];
                    if(cp->next)
                        cp->next->prev = cp;
                    cp->prev->next = cp;
                    cp->s = p;
                    if(++cp == &chain[NMEM])
                        cp = chain;
                    if(edata-p > NMATCH)
                        h = hupdate(h, p[NMATCH]);
                }
            }
            if(ndump != 0){
                if(eout-outp < ndump+1)
                    goto Bfull;
                *outp++ = ndump-1+128;
                memmove(outp, dumpbuf, ndump);
                outp += ndump;
            }
            line = eline;
            loutp = outp;
            r.max.y++;
        }
    Bfull:
        if(loutp == outbuf)
            goto ErrOut;
        n = loutp-outbuf;
        sprint(hdr, "%11d %11ld ", r.max.y, n);
        write(fd, hdr, 2*12);
        write(fd, outbuf, n);
        r.min.y = r.max.y;
    }
    free(data);
    free(outbuf);
    free(hash);
    free(chain);
    return 0;
}
@


\subsubsection{[[Memimage]] functions}


% not necessary, Memimage copy paste
% readmemimage -> <>
<<function creadmemimage>>=
Memimage*
creadmemimage(int fd)
{
    char hdr[5*12+1];
    Rectangle r;
    int m, nb, miny, maxy, new, ldepth, ncblock;
    uchar *buf;
    Memimage *i;
    ulong chan;

    if(readn(fd, hdr, 5*12) != 5*12){
        werrstr("readmemimage: short header (2)");
        return nil;
    }

    /*
     * distinguish new channel descriptor from old ldepth.
     * channel descriptors have letters as well as numbers,
     * while ldepths are a single digit formatted as %-11d.
     */
    new = 0;
    for(m=0; m<10; m++){
        if(hdr[m] != ' '){
            new = 1;
            break;
        }
    }
    if(hdr[11] != ' '){
        werrstr("creadimage: bad format");
        return nil;
    }
    if(new){
        hdr[11] = '\0';
        if((chan = strtochan(hdr)) == 0){
            werrstr("creadimage: bad channel string %s", hdr);
            return nil;
        }
    }else{
        ldepth = ((int)hdr[10])-'0';
        if(ldepth<0 || ldepth>3){
            werrstr("creadimage: bad ldepth %d", ldepth);
            return nil;
        }
        chan = drawld2chan[ldepth];
    }
    r.min.x=atoi(hdr+1*12);
    r.min.y=atoi(hdr+2*12);
    r.max.x=atoi(hdr+3*12);
    r.max.y=atoi(hdr+4*12);
    if(r.min.x>r.max.x || r.min.y>r.max.y){
        werrstr("creadimage: bad rectangle");
        return nil;
    }

    i = allocmemimage(r, chan);
    if(i == nil)
        return nil;
    ncblock = _compblocksize(r, i->depth);
    buf = malloc(ncblock);
    if(buf == nil)
        goto Errout;
    miny = r.min.y;
    while(miny != r.max.y){
        if(readn(fd, hdr, 2*12) != 2*12){
        Shortread:
            werrstr("readmemimage: short read");
        Errout:
            freememimage(i);
            free(buf);
            return nil;
        }
        maxy = atoi(hdr+0*12);
        nb = atoi(hdr+1*12);
        if(maxy<=miny || r.max.y<maxy){
            werrstr("readimage: bad maxy %d", maxy);
            goto Errout;
        }
        if(nb<=0 || ncblock<nb){
            werrstr("readimage: bad count %d", nb);
            goto Errout;
        }
        if(readn(fd, buf, nb)!=nb)
            goto Shortread;
        if(!new)	/* old image: flip the data bits */
            _twiddlecompressed(buf, nb);
        cloadmemimage(i, Rect(r.min.x, miny, r.max.x, maxy), buf, nb);
        miny = maxy;
    }
    free(buf);
    return i;
}
@




\section{Other image format}

% PNG, JPG, ... libjpeg, libtiff, ...

% libimg/ ? size LOC?

% http://blog.piston.rs/2017/01/08/the-image-library-is-now-pure-rust/

\section{Old image format}
\l simply delete no? hmm font uses this old format?

<<[[readimage()]] other locals>>=
bool new;
@

<<[[readimage()]] check if new or old format, set new>>=
/*
 * distinguish new channel descriptor from old ldepth.
 * channel descriptors have letters as well as numbers,
 * while ldepths are a single digit formatted as %-11d.
 */
new = false;
for(m=0; m<10; m++){
    if(hdr[m] != ' '){
        new = true;
        break;
    }
}
@


<<[[readimage()]] other locals>>=
int ldepth;
@

<<[[readimage()]] if old format>>=
if(!new){
    ldepth = ((int)hdr[10])-'0';
    if(ldepth<0 || ldepth>3){
        werrstr("readimage: bad ldepth %d", ldepth);
        return nil;
    }
    chan = drawld2chan[ldepth];
}
@


<<[[readimage()]] if old format, flip all bits>>=
if(!new)	/* an old image: must flip all the bits */
    for(j=0; j<chunk; j++)
        tmp[j] ^= 0xFF;
@

\section{[[Memimage]] duplicated API}
% for testing code, for togif, for graphics text mode below
% maybe could be put in appendix? or extra?

% dup of getdefont
<<function getmemdefont>>=
Memsubfont*
getmemdefont(void)
{
    char *hdr, *p;
    int n;
    Fontchar *fc;
    Memsubfont *f;
    int ld;
    Rectangle r;
    Memdata *md;
    Memimage *i;

    /*
     * make sure data is word-aligned.  this is true with Plan 9 compilers
     * but not in general.  the byte order is right because the data is
     * declared as char*, not ulong*.
     */
    p = (char*)defontdata;
    n = (uintptr)p & 3;
    if(n != 0){
        memmove(p+(4-n), p, sizeofdefont-n);
        p += 4-n;
    }
    ld = atoi(p+0*12);
    r.min.x = atoi(p+1*12);
    r.min.y = atoi(p+2*12);
    r.max.x = atoi(p+3*12);
    r.max.y = atoi(p+4*12);

    md = mallocz(sizeof(Memdata), 1);
    if(md == nil)
        return nil;
    
    p += 5*12;

    md->base = nil;		/* so freememimage doesn't free p */
    md->bdata = (uchar*)p;	/* ick */
    md->ref = 1;
    md->allocd = true;		/* so freememimage does free md */

    i = allocmemimaged(r, drawld2chan[ld], md);
    if(i == nil){
        free(md);
        return nil;
    }

    hdr = p + Dy(r) * i->width * sizeof(ulong);
    n = atoi(hdr);
    p = hdr+3*12;
    fc = malloc(sizeof(Fontchar)*(n+1));
    if(fc == nil){
        freememimage(i);
        return 0;
    }
    _unpackinfo(fc, (uchar*)p, n);
    f = allocmemsubfont("*default*", n, atoi(hdr+12), atoi(hdr+24), fc, i);
    if(f == nil){
        freememimage(i);
        free(fc);
        return 0;
    }
    return f;
}
@


%\subsection{[[Memsubfont]]}
% not sure you need that actually. Might be dead code.
% or just used in test code?

<<struct Memsubfont>>=
/*
 * Subfonts
 *
 * given char c, Subfont *f, Fontchar *i, and Point p, one says
 *	i = f->info+c;
 *	draw(b, Rect(p.x+i->left, p.y+i->top,
 *		p.x+i->left+((i+1)->x-i->x), p.y+i->bottom),
 *		color, f->bits, Pt(i->x, i->top));
 *	p.x += i->width;
 * to draw characters in the specified color (itself a Memimage) in Memimage b.
 */
struct	Memsubfont
{
    char	*name;

    Memimage	*bits;		/* of font */

    short	n;		/* number of chars in font */
    Fontchar *info;		/* n+1 character descriptors */

    uchar	height;		/* height of bitmap */
    char	ascent;		/* top of bitmap to baseline */
};
@
% ctor = ?
\l actually identical at Subfont, except Image vs Memimage.
\l and it's an important difference, cos the bits are really there





%openmemsubfont | getmemdefont -> <>
<<function allocmemsubfont>>=
Memsubfont*
allocmemsubfont(char *name, int n, int height, int ascent, Fontchar *info, Memimage *i)
{
    Memsubfont *f;
 
    f = malloc(sizeof(Memsubfont));
    if(f == 0)
        return 0;
    f->n = n;
    f->height = height;
    f->ascent = ascent;
    f->info = info;
    f->bits = i;
    if(name)
        f->name = strdup(name);
    else
        f->name = 0;
    return f;
}
@


<<function memsubfontwidth>>=
Point
memsubfontwidth(Memsubfont *f, char *cs)
{
    Rune c;
    Point p;
    uchar *s;
    Fontchar *i;
    int w, width;

    p = Pt(0, f->height);
    s = (uchar*)cs;
    for(; c=*s; p.x+=width){
        width = 0;
        if(c < Runeself)
            s++;
        else{
            w = chartorune(&c, (char*)s);
            if(w == 0){
                s++;
                continue;
            }
            s += w;
        }
        if(c >= f->n)
            continue;
        i = f->info+c;
        width = i->width;
    }
    return p;
}
@


% vgascreenputc -> <>
<<function memimagestring>>=
Point
memimagestring(Memimage *b, Point p, Memimage *color, Point cp, Memsubfont *f, char *cs)
{
    int w, width;
    uchar *s;
    Rune c;
    Fontchar *i;

    s = (uchar*)cs;
    for(; c=*s; p.x+=width, cp.x+=width){
        width = 0;
        if(c < Runeself)
            s++;
        else{
            w = chartorune(&c, (char*)s);
            if(w == 0){
                s++;
                continue;
            }
            s += w;
        }
        if(c >= f->n)
            continue;
        i = f->info+c;
        width = i->width;
        memdraw(b, Rect(p.x+i->left, p.y+i->top, p.x+i->left+(i[1].x-i[0].x), p.y+i->bottom),
            color, cp, f->bits, Pt(i->x, i->top), SoverD);
    }
    return p;
}
@



% dupe of readimage()
% used by togif.c, topng.c, etc
<<function readmemimage>>=
Memimage*
readmemimage(fdt fd)
{
    char hdr[5*12+1];
    int dy;
    ulong chan;
    uint l, n;
    int m, j;
    int new, miny, maxy;
    Rectangle r;
    uchar *tmp;
    int ldepth, chunk;
    Memimage *i;

    if(readn(fd, hdr, 11) != 11){
        werrstr("readimage: short header");
        return nil;
    }
    if(memcmp(hdr, "compressed\n", 11) == 0)
        return creadmemimage(fd);

    if(readn(fd, hdr+11, 5*12-11) != 5*12-11){
        werrstr("readimage: short header (2)");
        return nil;
    }

    /*
     * distinguish new channel descriptor from old ldepth.
     * channel descriptors have letters as well as numbers,
     * while ldepths are a single digit formatted as %-11d.
     */
    new = 0;
    for(m=0; m<10; m++){
        if(hdr[m] != ' '){
            new = 1;
            break;
        }
    }
    if(hdr[11] != ' '){
        werrstr("readimage: bad format");
        return nil;
    }
    if(new){
        hdr[11] = '\0';
        if((chan = strtochan(hdr)) == 0){
            werrstr("readimage: bad channel string %s", hdr);
            return nil;
        }
    }else{
        ldepth = ((int)hdr[10])-'0';
        if(ldepth<0 || ldepth>3){
            werrstr("readimage: bad ldepth %d", ldepth);
            return nil;
        }
        chan = drawld2chan[ldepth];
    }

    r.min.x = atoi(hdr+1*12);
    r.min.y = atoi(hdr+2*12);
    r.max.x = atoi(hdr+3*12);
    r.max.y = atoi(hdr+4*12);
    if(r.min.x>r.max.x || r.min.y>r.max.y){
        werrstr("readimage: bad rectangle");
        return nil;
    }

    miny = r.min.y;
    maxy = r.max.y;

    l = bytesperline(r, chantodepth(chan));
    i = allocmemimage(r, chan);
    if(i == nil)
        return nil;
    chunk = 32*1024;
    if(chunk < l)
        chunk = l;
    tmp = malloc(chunk);
    if(tmp == nil)
        goto Err;
    while(maxy > miny){
        dy = maxy - miny;
        if(dy*l > chunk)
            dy = chunk/l;
        if(dy <= 0){
            werrstr("readmemimage: image too wide for buffer");
            goto Err;
        }
        n = dy*l;
        m = readn(fd, tmp, n);
        if(m != n){
            werrstr("readmemimage: read count %d not %d: %r", m, n);
   Err:
    freememimage(i);
            free(tmp);
            return nil;
        }
        if(!new)	/* an old image: must flip all the bits */
            for(j=0; j<chunk; j++)
                tmp[j] ^= 0xFF;

        if(loadmemimage(i, Rect(r.min.x, miny, r.max.x, miny+dy), tmp, chunk) <= 0)
            goto Err;
        miny += dy;
    }
    free(tmp);
    return i;
}
@





<<constant CHUNK>>=
#define	CHUNK	8000
@

<<constant HSHIFT (lib_graphics/libmemdraw/write.c)>>=
#define	HSHIFT	3	/* HSHIFT==5 runs slightly faster, but hash table is 64x bigger */
@

<<constant NHASH (lib_graphics/libmemdraw/write.c)>>=
#define	NHASH	(1<<(HSHIFT*NMATCH))
@

<<constant HMASK (lib_graphics/libmemdraw/write.c)>>=
#define	HMASK	(NHASH-1)
@

<<function hupdate (lib_graphics/libmemdraw/write.c)>>=
#define	hupdate(h, c)	((((h)<<HSHIFT)^(c))&HMASK)
@

<<struct Hlist (lib_graphics/libmemdraw/write.c)>>=
struct Hlist{
    uchar *s;
    Hlist *next, *prev;
};
@

% dupe of writeimage
% called by iconv.c, but seems mostly dead
<<function writememimage>>=
int
writememimage(int fd, Memimage *i)
{
    uchar *outbuf, *outp, *eout;		/* encoded data, pointer, end */
    uchar *loutp;				/* start of encoded line */
    Hlist *hash;				/* heads of hash chains of past strings */
    Hlist *chain, *hp;			/* hash chain members, pointer */
    Hlist *cp;				/* next Hlist to fall out of window */
    int h;					/* hash value */
    uchar *line, *eline;			/* input line, end pointer */
    uchar *data, *edata;			/* input buffer, end pointer */
    ulong n;				/* length of input buffer */
    ulong nb;				/* # of bytes returned by unloadimage */
    int bpl;				/* input line length */
    int offs, runlen;			/* offset, length of consumed data */
    uchar dumpbuf[NDUMP];			/* dump accumulator */
    int ndump;				/* length of dump accumulator */
    int miny, dy;				/* y values while unloading input */
    int ncblock;				/* size of compressed blocks */
    Rectangle r;
    uchar *p, *q, *s, *es, *t;
    char hdr[11+5*12+1];
    char cbuf[20];

    r = i->r;
    bpl = bytesperline(r, i->depth);
    n = Dy(r)*bpl;
    data = malloc(n);
    ncblock = _compblocksize(r, i->depth);
    outbuf = malloc(ncblock);
    hash = malloc(NHASH*sizeof(Hlist));
    chain = malloc(NMEM*sizeof(Hlist));
    if(data == 0 || outbuf == 0 || hash == 0 || chain == 0){
    ErrOut:
        free(data);
        free(outbuf);
        free(hash);
        free(chain);
        return -1;
    }
    for(miny = r.min.y; miny != r.max.y; miny += dy){
        dy = r.max.y-miny;
        if(dy*bpl > CHUNK)
            dy = CHUNK/bpl;
        nb = unloadmemimage(i, Rect(r.min.x, miny, r.max.x, miny+dy),
            data+(miny-r.min.y)*bpl, dy*bpl);
        if(nb != dy*bpl)
            goto ErrOut;
    }
    sprint(hdr, "compressed\n%11s %11d %11d %11d %11d ",
        chantostr(cbuf, i->chan), r.min.x, r.min.y, r.max.x, r.max.y);
    if(write(fd, hdr, 11+5*12) != 11+5*12)
        goto ErrOut;
    edata = data+n;
    eout = outbuf+ncblock;
    line = data;
    r.max.y = r.min.y;
    while(line != edata){
        memset(hash, 0, NHASH*sizeof(Hlist));
        memset(chain, 0, NMEM*sizeof(Hlist));
        cp = chain;
        h = 0;
        outp = outbuf;
        for(n = 0; n != NMATCH; n++)
            h = hupdate(h, line[n]);
        loutp = outbuf;
        while(line != edata){
            ndump = 0;
            eline = line+bpl;
            for(p = line; p != eline; ){
                if(eline-p < NRUN)
                    es = eline;
                else
                    es = p+NRUN;
                q = 0;
                runlen = 0;
                for(hp = hash[h].next; hp; hp = hp->next){
                    s = p + runlen;
                    if(s >= es)
                        continue;
                    t = hp->s + runlen;
                    for(; s >= p; s--)
                        if(*s != *t--)
                            goto matchloop;
                    t += runlen+2;
                    s += runlen+2;
                    for(; s < es; s++)
                        if(*s != *t++)
                            break;
                    n = s-p;
                    if(n > runlen){
                        runlen = n;
                        q = hp->s;
                        if(n == NRUN)
                            break;
                    }
            matchloop: ;
                }
                if(runlen < NMATCH){
                    if(ndump == NDUMP){
                        if(eout-outp < ndump+1)
                            goto Bfull;
                        *outp++ = ndump-1+128;
                        memmove(outp, dumpbuf, ndump);
                        outp += ndump;
                        ndump = 0;
                    }
                    dumpbuf[ndump++] = *p;
                    runlen = 1;
                }
                else{
                    if(ndump != 0){
                        if(eout-outp < ndump+1)
                            goto Bfull;
                        *outp++ = ndump-1+128;
                        memmove(outp, dumpbuf, ndump);
                        outp += ndump;
                        ndump = 0;
                    }
                    offs = p-q-1;
                    if(eout-outp < 2)
                        goto Bfull;
                    *outp++ = ((runlen-NMATCH)<<2) + (offs>>8);
                    *outp++ = offs&255;
                }
                for(q = p+runlen; p != q; p++){
                    if(cp->prev)
                        cp->prev->next = 0;
                    cp->next = hash[h].next;
                    cp->prev = &hash[h];
                    if(cp->next)
                        cp->next->prev = cp;
                    cp->prev->next = cp;
                    cp->s = p;
                    if(++cp == &chain[NMEM])
                        cp = chain;
                    if(edata-p > NMATCH)
                        h = hupdate(h, p[NMATCH]);
                }
            }
            if(ndump != 0){
                if(eout-outp < ndump+1)
                    goto Bfull;
                *outp++ = ndump-1+128;
                memmove(outp, dumpbuf, ndump);
                outp += ndump;
            }
            line = eline;
            loutp = outp;
            r.max.y++;
        }
    Bfull:
        if(loutp == outbuf)
            goto ErrOut;
        n = loutp-outbuf;
        sprint(hdr, "%11d %11ld ", r.max.y, n);
        write(fd, hdr, 2*12);
        write(fd, outbuf, n);
        r.min.y = r.max.y;
    }
    free(data);
    free(outbuf);
    free(hash);
    free(chain);
    return 0;
}
@

\section{Video and animation}

% https://github.com/leandromoreira/digital_video_introduction

\chapter{Conclusion}
\label{chap:conclusion}

% That's it! you know now!

% Next book = Windowing system. Good example of use of many API
%  functions presented here.
% Also Editor is a graphical app.


% not covered:
% - 3D
%   http://www.adriancourreges.com/blog/2016/09/09/doom-2016-graphics-study/
% - Animation





%###############################################################################

\appendix

\chapter{Debugging}
\label{chap:debugging-appendix}


%dead:? used just for this? maybe better to remove no?
% libdraw
<<global _drawdebug>>=
bool	_drawdebug = false;
@
<<[[doflush()]] if _drawdebug>>=
if(_drawdebug)
    fprint(2, "flushimage fail: d=%p: n=%d nn=%d %r\n", d, n, nn); /**/
@
%ocaml: use exn and always do the check, not only if _drawdebug



<<global debuglockdisplay>>=
bool		debuglockdisplay = false;
@
<<[[lockdisplay()]] if debuglockdisplay>>=
if(debuglockdisplay){
    /* avoid busy looping; it's rare we collide anyway */
    while(!canqlock(&disp->qlock)){
        fprint(1, "proc %d waiting for display lock...\n", getpid());
        sleep(1000);
    }
}
@



\section{[[drawsetdebug()]]}

% API and marshalling
<<function drawsetdebug>>=
void
drawsetdebug(bool v)
{
    byte *a;
    a = bufimage(display, 1+1);
    <<[[drawsetdebug()]] sanity check a>>
    a[0] = 'D';
    a[1] = v;
}
@

<<[[drawsetdebug()]] sanity check a>>=
if(a == nil){
    fprint(2, "drawsetdebug: %r\n");
    return;
}
@

% libmemdraw
<<global drawdebug>>=
bool drawdebug;
@
% rename? memdrawdebug?



% Unmarshalling
<<[[drawmesg()]] cases>>=
/* toggle debugging: 'D' val[1] */
case 'D':
    printmesg(fmt="b", a, false);
    m = 1+1;
    <<[[drawmesg()]] sanity check n with m>>
    drawdebug = a[1];
    continue;
@

% but not really used in the kernel. All the code that was using
% drawdebug was actually commented (e.g., in libmemdraw/draw.c)


<<macro DBG1>>=
#define DBG1 if(0) print
@
\l mv in memdraw.h?
\t if actually replace 0 by drawdebug, and enable debug, then
\t  hellodraw just hangs

<<macro DBG>>=
#define DBG if(0) print
@

\section{Dumpers}


\subsection{Points and rectangles}

% user side
<<[[initdisplay()]] install dumpers>>=
fmtinstall('P', Pfmt);
fmtinstall('R', Rfmt);
@

% kernel side
<<[[memimageinit()]] install dumpers>>=
fmtinstall('P', Pfmt);
fmtinstall('R', Rfmt); 
@

%dumper
<<function Pfmt>>=
int
Pfmt(Fmt *f)
{
    Point p;

    p = va_arg(f->args, Point);
    return fmtprint(f, "[%d %d]", p.x, p.y);
}
@

%dumper
<<function Rfmt>>=
int
Rfmt(Fmt *f)
{
    Rectangle r;

    r = va_arg(f->args, Rectangle);
    return fmtprint(f, "%P %P", r.min, r.max);
}
@


%???
<<[[memimageinit()]] install dumpers>>=
fmtinstall('b', _ifmt);
@

\subsection{Channels}

<<function chantostr>>=
char*
chantostr(char *buf, ulong cc)
{
    ulong c, rc;
    char *p;

    if(chantodepth(cc) == 0)
        return nil;

    /* reverse the channel descriptor so we can easily generate the string in the right order */
    rc = 0;
    for(c=cc; c; c>>=8){
        rc <<= 8;
        rc |= c&0xFF;
    }

    p = buf;
    for(c=rc; c; c>>=8) {
        *p++ = channames[TYPE(c)];
        *p++ = '0'+NBITS(c);
    }
    *p = 0;

    return buf;
}
@



\subsection{Drawing commands}

% to debug drawmesg()

% drawmesg -> <>
<<function printmesg>>=
static void
printmesg(char *fmt, uchar *a, bool plsprnt)
{
    char buf[256];
    char *p, *q;
    int s, left;

    if(!plsprnt && !drawdebug){ //old: 1 || !plsprnt
        SET(s,q,p);
        USED(fmt, a, buf, p, q, s);
        return;
    }
    // else, plsprnt || drawdebug

    q = buf;
    *q++ = *a++;
    for(p=fmt; *p; p++){
        left = sizeof buf - 2 - (q - buf);  /* 2 for \n\0 */
        switch(*p){
        case 'l':
            q += snprint(q, left, " %ld", (long)BGLONG(a));
            a += 4;
            break;
        case 'L':
            q += snprint(q, left, " %.8lux", (ulong)BGLONG(a));
            a += 4;
            break;
        case 'R':
            q += snprint(q, left, " [%d %d %d %d]", BGLONG(a),
                BGLONG(a+4), BGLONG(a+8), BGLONG(a+12));
            a += 16;
            break;
        case 'P':
            q += snprint(q, left, " [%d %d]", BGLONG(a), BGLONG(a+4));
            a += 8;
            break;
        case 'b':
            q += snprint(q, left, " %d", *a++);
            break;
        case 's':
            q += snprint(q, left, " %d", BGSHORT(a));
            a += 2;
            break;
        case 'S':
            q += snprint(q, left, " %.4ux", BGSHORT(a));
            a += 2;
            break;
        }
    }
    *q++ = '\n';
    *q = '\0';
    iprint("%.*s", (int)(q-buf), buf);
}
@
%old: was 1 || plsprint == 0, so was always disabling printmesg,
% but better to put !drawdebug instead of 1

% the plsprint argument is just so can selectively decide which
% calls to trace when debugging an issue.

\section{Memory tags}

% not sure why do only those 3

<<[[allocimage()]] set malloc tag for debug>>=
if (i)
    setmalloctag(i, getcallerpc(&d));
@

<<[[_getsubfont()]] set malloc tag for debug>>=
setmalloctag(f, getcallerpc(&d));
@

<<[[creadimage()]] set malloc tag for debug>>=
setmalloctag(i, getcallerpc(&d));
@



\chapter{Error Management}
\label{chap:error}

\section{User side}

<<type Errorfn>>=
typedef void (*Errorfn)(Display*, char*);
@
%pad: I added that


% initdraw take an error parameter?

<<[[Display]] other fields>>=
Errorfn error;
@
%old: void	(*error)(Display*, char*);

% drawgetrect | readcolmap | writecolmap | ebread | ecanmouse | ...-> <>
<<function drawerror>>=
void
drawerror(Display *d, char *s)
{
    char err[ERRMAX];

    if(d && d->error)
        d->error(d, s);
    else{
        errstr(err, sizeof err);
        fprint(STDERR, "draw: %s: %s\n", s, err);
        exits(s); // extreme!
    }
}
@

% not so many calls to drawerror in libdraw/ actually.
% more use of werrstr and returning error code.

\section{Kernel side}

<<global Enodrawimage>>=
char Enodrawimage[] =   "unknown id for draw image";
@

<<global Enodrawscreen>>=
char Enodrawscreen[] =  "unknown id for draw screen";
@

<<global Eshortdraw>>=
char Eshortdraw[] = "short draw message";
@

<<global Eshortread>>=
char Eshortread[] = "draw read too short";
@

<<global Eimageexists>>=
char Eimageexists[] =   "image id in use";
@

<<global Escreenexists>>=
char Escreenexists[] =  "screen id in use";
@

<<global Edrawmem>>=
char Edrawmem[] =   "image memory allocation failed";
@

<<global Ereadoutside>>=
char Ereadoutside[] =   "readimage outside image";
@

<<global Ewriteoutside>>=
char Ewriteoutside[] =  "writeimage outside image";
@

<<global Enotfont>>=
char Enotfont[] =   "image not a font";
@

<<global Eindex>>=
char Eindex[] =     "character index out of range";
@

<<global Enoclient>>=
char Enoclient[] =  "no such draw client";
@

<<global Enameused>>=
char Enameused[] =  "image name in use";
@

%dead: //static    char Edepth[] =     "image has bad depth";

<<global Enoname>>=
char Enoname[] =    "no image with that name";
@

<<global Eoldname>>=
char Eoldname[] =   "named image no longer valid";
@

<<global Enamed>>=
char Enamed[] =     "image already has name";
@

<<global Ewrongname>>=
char Ewrongname[] =     "wrong name for image";
@






\chapter{Mathematics}
\label{chap:math}

\section{Trigonometric functions}

% float is expensive, so instead represent float in integer approximation.
% 0.0 = 0 degree, 1.0 = 1024

<<global sinus>>=
/*
 * Integer sine and cosine for integral degree argument.
 * Tables computed by (sin,cos)(PI*d/180).
 */
static short sinus[91] = {
    0,	/* 0 */
    18,	/* 1 */
    36,	/* 2 */
    54,	/* 3 */
    71,	/* 4 */
    89,	/* 5 */
    107,	/* 6 */
    125,	/* 7 */
    143,	/* 8 */
    160,	/* 9 */
    178,	/* 10 */
    195,	/* 11 */
    213,	/* 12 */
    230,	/* 13 */
    248,	/* 14 */
    265,	/* 15 */
    282,	/* 16 */
    299,	/* 17 */
    316,	/* 18 */
    333,	/* 19 */
    350,	/* 20 */
    367,	/* 21 */
    384,	/* 22 */
    400,	/* 23 */
    416,	/* 24 */
    433,	/* 25 */
    449,	/* 26 */
    465,	/* 27 */
    481,	/* 28 */
    496,	/* 29 */
    512,	/* 30 */
    527,	/* 31 */
    543,	/* 32 */
    558,	/* 33 */
    573,	/* 34 */
    587,	/* 35 */
    602,	/* 36 */
    616,	/* 37 */
    630,	/* 38 */
    644,	/* 39 */
    658,	/* 40 */
    672,	/* 41 */
    685,	/* 42 */
    698,	/* 43 */
    711,	/* 44 */
    724,	/* 45 */
    737,	/* 46 */
    749,	/* 47 */
    761,	/* 48 */
    773,	/* 49 */
    784,	/* 50 */
    796,	/* 51 */
    807,	/* 52 */
    818,	/* 53 */
    828,	/* 54 */
    839,	/* 55 */
    849,	/* 56 */
    859,	/* 57 */
    868,	/* 58 */
    878,	/* 59 */
    887,	/* 60 */
    896,	/* 61 */
    904,	/* 62 */
    912,	/* 63 */
    920,	/* 64 */
    928,	/* 65 */
    935,	/* 66 */
    943,	/* 67 */
    949,	/* 68 */
    956,	/* 69 */
    962,	/* 70 */
    968,	/* 71 */
    974,	/* 72 */
    979,	/* 73 */
    984,	/* 74 */
    989,	/* 75 */
    994,	/* 76 */
    998,	/* 77 */
    1002,	/* 78 */
    1005,	/* 79 */
    1008,	/* 80 */
    1011,	/* 81 */
    1014,	/* 82 */
    1016,	/* 83 */
    1018,	/* 84 */
    1020,	/* 85 */
    1022,	/* 86 */
    1023,	/* 87 */
    1023,	/* 88 */
    1024,	/* 89 */
    1024,	/* 90 */
};
@

<<function icossin>>=
void
icossin(int deg, int *cosp, int *sinp)
{
    int sinsign, cossign;
    short *stp, *ctp;

    deg %= 360;
    if(deg < 0)
        deg += 360;
    sinsign = 1;
    cossign = 1;
    stp = 0;
    ctp = 0;
    switch(deg/90){
    case 2:
        sinsign = -1;
        cossign = -1;
        deg -= 180;
        /* fall through */
    case 0:
        stp = &sinus[deg];
        ctp = &sinus[90-deg];
        break;
    case 3:
        sinsign = -1;
        cossign = -1;
        deg -= 180;
        /* fall through */
    case 1:
        deg = 180-deg;
        cossign = -cossign;
        stp = &sinus[deg];
        ctp = &sinus[90-deg];
        break;
    }
    *sinp = sinsign*stp[0];
    *cosp = cossign*ctp[0];
}
@



<<global sinus (lib_graphics/libdraw/icossin2.c)>>=
/*
 * Sine and Cosine of arctangents, calculated by 
 *   (sin(atan(index/100.0))*1024.+0.5)
 *   (cos(atan(index/100.0))*1024.+0.5)
 * To use, get rational tangent between 0<=tan<=1, scale by 100,
 * and look up sin and cos, and use linear interpolation.  divide by 1024.
 * Maximum error is 0.0020.  Without linear interpolation, it's 0.010.
 */
static
short sinus[] = {
    0,	/* 0.00 */
    10,	/* 0.01 */
    20,	/* 0.02 */
    31,	/* 0.03 */
    41,	/* 0.04 */
    51,	/* 0.05 */
    61,	/* 0.06 */
    72,	/* 0.07 */
    82,	/* 0.08 */
    92,	/* 0.09 */
    102,	/* 0.10 */
    112,	/* 0.11 */
    122,	/* 0.12 */
    132,	/* 0.13 */
    142,	/* 0.14 */
    152,	/* 0.15 */
    162,	/* 0.16 */
    172,	/* 0.17 */
    181,	/* 0.18 */
    191,	/* 0.19 */
    201,	/* 0.20 */
    210,	/* 0.21 */
    220,	/* 0.22 */
    230,	/* 0.23 */
    239,	/* 0.24 */
    248,	/* 0.25 */
    258,	/* 0.26 */
    267,	/* 0.27 */
    276,	/* 0.28 */
    285,	/* 0.29 */
    294,	/* 0.30 */
    303,	/* 0.31 */
    312,	/* 0.32 */
    321,	/* 0.33 */
    330,	/* 0.34 */
    338,	/* 0.35 */
    347,	/* 0.36 */
    355,	/* 0.37 */
    364,	/* 0.38 */
    372,	/* 0.39 */
    380,	/* 0.40 */
    388,	/* 0.41 */
    397,	/* 0.42 */
    405,	/* 0.43 */
    412,	/* 0.44 */
    420,	/* 0.45 */
    428,	/* 0.46 */
    436,	/* 0.47 */
    443,	/* 0.48 */
    451,	/* 0.49 */
    458,	/* 0.50 */
    465,	/* 0.51 */
    472,	/* 0.52 */
    480,	/* 0.53 */
    487,	/* 0.54 */
    493,	/* 0.55 */
    500,	/* 0.56 */
    507,	/* 0.57 */
    514,	/* 0.58 */
    520,	/* 0.59 */
    527,	/* 0.60 */
    533,	/* 0.61 */
    540,	/* 0.62 */
    546,	/* 0.63 */
    552,	/* 0.64 */
    558,	/* 0.65 */
    564,	/* 0.66 */
    570,	/* 0.67 */
    576,	/* 0.68 */
    582,	/* 0.69 */
    587,	/* 0.70 */
    593,	/* 0.71 */
    598,	/* 0.72 */
    604,	/* 0.73 */
    609,	/* 0.74 */
    614,	/* 0.75 */
    620,	/* 0.76 */
    625,	/* 0.77 */
    630,	/* 0.78 */
    635,	/* 0.79 */
    640,	/* 0.80 */
    645,	/* 0.81 */
    649,	/* 0.82 */
    654,	/* 0.83 */
    659,	/* 0.84 */
    663,	/* 0.85 */
    668,	/* 0.86 */
    672,	/* 0.87 */
    676,	/* 0.88 */
    681,	/* 0.89 */
    685,	/* 0.90 */
    689,	/* 0.91 */
    693,	/* 0.92 */
    697,	/* 0.93 */
    701,	/* 0.94 */
    705,	/* 0.95 */
    709,	/* 0.96 */
    713,	/* 0.97 */
    717,	/* 0.98 */
    720,	/* 0.99 */
    724,	/* 1.00 */
    728,	/* 1.01 */
};
@

<<global cosinus>>=
static
short cosinus[] = {
    1024,	/* 0.00 */
    1024,	/* 0.01 */
    1024,	/* 0.02 */
    1024,	/* 0.03 */
    1023,	/* 0.04 */
    1023,	/* 0.05 */
    1022,	/* 0.06 */
    1022,	/* 0.07 */
    1021,	/* 0.08 */
    1020,	/* 0.09 */
    1019,	/* 0.10 */
    1018,	/* 0.11 */
    1017,	/* 0.12 */
    1015,	/* 0.13 */
    1014,	/* 0.14 */
    1013,	/* 0.15 */
    1011,	/* 0.16 */
    1010,	/* 0.17 */
    1008,	/* 0.18 */
    1006,	/* 0.19 */
    1004,	/* 0.20 */
    1002,	/* 0.21 */
    1000,	/* 0.22 */
    998,	/* 0.23 */
    996,	/* 0.24 */
    993,	/* 0.25 */
    991,	/* 0.26 */
    989,	/* 0.27 */
    986,	/* 0.28 */
    983,	/* 0.29 */
    981,	/* 0.30 */
    978,	/* 0.31 */
    975,	/* 0.32 */
    972,	/* 0.33 */
    969,	/* 0.34 */
    967,	/* 0.35 */
    963,	/* 0.36 */
    960,	/* 0.37 */
    957,	/* 0.38 */
    954,	/* 0.39 */
    951,	/* 0.40 */
    947,	/* 0.41 */
    944,	/* 0.42 */
    941,	/* 0.43 */
    937,	/* 0.44 */
    934,	/* 0.45 */
    930,	/* 0.46 */
    927,	/* 0.47 */
    923,	/* 0.48 */
    920,	/* 0.49 */
    916,	/* 0.50 */
    912,	/* 0.51 */
    909,	/* 0.52 */
    905,	/* 0.53 */
    901,	/* 0.54 */
    897,	/* 0.55 */
    893,	/* 0.56 */
    890,	/* 0.57 */
    886,	/* 0.58 */
    882,	/* 0.59 */
    878,	/* 0.60 */
    874,	/* 0.61 */
    870,	/* 0.62 */
    866,	/* 0.63 */
    862,	/* 0.64 */
    859,	/* 0.65 */
    855,	/* 0.66 */
    851,	/* 0.67 */
    847,	/* 0.68 */
    843,	/* 0.69 */
    839,	/* 0.70 */
    835,	/* 0.71 */
    831,	/* 0.72 */
    827,	/* 0.73 */
    823,	/* 0.74 */
    819,	/* 0.75 */
    815,	/* 0.76 */
    811,	/* 0.77 */
    807,	/* 0.78 */
    804,	/* 0.79 */
    800,	/* 0.80 */
    796,	/* 0.81 */
    792,	/* 0.82 */
    788,	/* 0.83 */
    784,	/* 0.84 */
    780,	/* 0.85 */
    776,	/* 0.86 */
    773,	/* 0.87 */
    769,	/* 0.88 */
    765,	/* 0.89 */
    761,	/* 0.90 */
    757,	/* 0.91 */
    754,	/* 0.92 */
    750,	/* 0.93 */
    746,	/* 0.94 */
    742,	/* 0.95 */
    739,	/* 0.96 */
    735,	/* 0.97 */
    731,	/* 0.98 */
    728,	/* 0.99 */
    724,	/* 1.00 */
    720,	/* 1.01 */
};
@

<<function icossin2>>=
void
icossin2(int x, int y, int *cosp, int *sinp)
{
    int sinsign, cossign, tan, tan10, rem;
    short *stp, *ctp;

    if(x == 0){
        if(y >= 0)
            *sinp = ICOSSCALE, *cosp = 0;
        else
            *sinp = -ICOSSCALE, *cosp = 0;
        return;
    }
    sinsign = cossign = 1;
    if(x < 0){
        cossign = -1;
        x = -x;
    }
    if(y < 0){
        sinsign = -1;
        y = -y;
    }
    if(y > x){
        tan = 1000*x/y;
        tan10 = tan/10;
        stp = &cosinus[tan10];
        ctp = &sinus[tan10];
    }else{
        tan = 1000*y/x;
        tan10 = tan/10;
        stp = &sinus[tan10];
        ctp = &cosinus[tan10];
    }
    rem = tan-(tan10*10);
    *sinp = sinsign*(stp[0]+(stp[1]-stp[0])*rem/10);
    *cosp = cossign*(ctp[0]+(ctp[1]-ctp[0])*rem/10);
}
@





\chapter{Raspberry Pi VideoCore Driver TODO}
\label{chap:raspberry-pi-graphic-card}

% bcm2385 frame buffer and videocore GPU

% 1024 x 768 x 16 (and can do also x 32)
% but when in 32, does it mean GPU understand alpha channel?

% screen.c and vcore.c

\chapter{PC VGA driver TODO}
\label{chap:pc-vga-driver}

% graphics card in verilog
%https://github.com/mntmn/amiga2000-gfxcard

% history of CGA:
%https://www.youtube.com/watch?v=niKblgZupOc

\t make something generic out of it? so can have also a generic swcursor.c?

% XXX LP split
<<struct VGAscr(x86)>>=
struct VGAscr {

  ulong paddr;    /* frame buffer */
  void* vaddr;

  int   apsize;

  Memsubfont* memdefont;

  <<[[VGAscr]] cursor fields>>

  ulong colormap[Pcolours][3];
  int palettedepth;

  Pcidev* pci;
  ulong io;       /* device specific registers */
  ulong *mmio;

  ulong storage;
  bool useflush;

  ulong id; /* internal identifier for driver use */

  // the vga device methods
  VGAdev* dev;

  // why here? why not in VGAdev?
  <<[[VGAscr]] optional methods(x86)>>

  <<[[VGAscr]] other fields(x86)>>

  // Extra
  Lock  devlock;
};
@
%old: this used to have a gscreen and gscreendata fields, but
% there were just redundant with gscreen and gscreendata globals,
% so I removed those fields, which makes it also easier to move
% more generic stuff in screen.c


<<global vgascreen(x86)>>=
VGAscr vgascreen;
@
%set by screensize()? and probably via vgactl
%old: this used to be vgascreen[1], but I refactored to just vgascreen.
% I didn't find any vga driver having more than 1 VGAscr so not sure
% why it was like that. Once this was done, it didn't make sense to
% have the gscreen/gscreendata globals and vgascreen[0].gscreen
% and vgascreen[0].gscreendata so I removed those fields.


<<function VGAMEM(x86)>>=
#define VGAMEM()  0xA0000
@
% vgascreen.paddr?





<<[[VGAscr]] other fields(x86)>>=
int overlayinit;
@

%XXX move later
<<[[VGAscr]] optional methods(x86)>>=
int (*fill)(VGAscr*, Rectangle, ulong);
int (*scroll)(VGAscr*, Rectangle, Rectangle);
@





% !!!!!!!!!
<<function ishwimage(x86)>>=
bool
arch_ishwimage(Memimage* i)
{
  return (i->data->bdata == gscreendata.bdata);
}
@
% could be just i == gscreen no?
%old: //#define ishwimage(i)  (vgascreen[0].gscreendata && (i)->data->bdata == vgascreen[0].gscreendata->bdata)




% see "adventure in graphic card" from BeOS people in src/vga/? meh

<<enum vgamisc(x86)>>=
  Pcolours  = 256,    /* Palette */

  Pred    = 0,
  Pgreen  = 1,
  Pblue   = 2,

  Pblack    = 0x00,
  Pwhite    = 0xFF,
};
@

<<enum _anon_ (kernel/devices/screen/386/screen.h)2>>=
enum {
  Backgnd   = 0,  /* black */
};
@


<<global vgadevtab(x86)>>=
Dev vgadevtab = {
    .dc       =    'v',
    .name     =    "vga",
               
    .attach   =    vgaattach,
    .walk     =    vgawalk,

    .open     =    vgaopen,
    .close    =    vgaclose,
    .read     =    vgaread,
    .write    =    vgawrite,
    .stat     =    vgastat,

    .reset    =    vgareset,

    // generic
    .create   =    devcreate,
    .remove   =    devremove,
    .wstat    =    devwstat,
    .bread    =    devbread,
    .bwrite   =    devbwrite,
    .init     =    devinit,
    .shutdown =    devshutdown,
};
@
% put the devtab? where have the cirrus logic there?

\section{IO ports}

<<enum vgaports(x86)>>=
/*
 * Generic VGA registers.
 */
enum {
  MiscW   = 0x03C2, /* Miscellaneous Output (W) */
  MiscR   = 0x03CC, /* Miscellaneous Output (R) */
  Status0   = 0x03C2, /* Input status 0 (R) */
  Status1   = 0x03DA, /* Input Status 1 (R) */
  FeatureR  = 0x03CA, /* Feature Control (R) */
  FeatureW  = 0x03DA, /* Feature Control (W) */

  Seqx    = 0x03C4, /* Sequencer Index, Data at Seqx+1 */
  Crtx    = 0x03D4, /* CRT Controller Index, Data at Crtx+1 */
  Grx   = 0x03CE, /* Graphics Controller Index, Data at Grx+1 */
  Attrx   = 0x03C0, /* Attribute Controller Index and Data */

  PaddrW    = 0x03C8, /* Palette Address Register, write */
  Pdata     = 0x03C9, /* Palette Data Register */
  Pixmask   = 0x03C6, /* Pixel Mask Register */
  PaddrR    = 0x03C7, /* Palette Address Register, read */
  Pstatus   = 0x03C7, /* DAC Status (RO) */
@

<<function vgao(x86)>>=
#define vgao(port, data)  outb(port, data)
@


<<global vgaxlock(x86)>>=
static Lock vgaxlock;           /* access to index registers */
@

<<function vgaxi(x86)>>=
int
vgaxi(long port, uchar index)
{
    uchar data;

    ilock(&vgaxlock);
    switch(port){

    case Seqx:
    case Crtx:
    case Grx:
        outb(port, index);
        data = inb(port+1);
        break;

    case Attrx:
        /*
         * Allow processor access to the colour
         * palette registers. Writes to Attrx must
         * be preceded by a read from Status1 to
         * initialise the register to point to the
         * index register and not the data register.
         * Processor access is allowed by turning
         * off bit 0x20.
         */
        inb(Status1);
        if(index < 0x10){
            outb(Attrx, index);
            data = inb(Attrx+1);
            inb(Status1);
            outb(Attrx, 0x20|index);
        }
        else{
            outb(Attrx, 0x20|index);
            data = inb(Attrx+1);
        }
        break;

    default:
        iunlock(&vgaxlock);
        return -1;
    }
    iunlock(&vgaxlock);

    return data & 0xFF;
}
@

<<function vgaxo(x86)>>=
int
vgaxo(long port, uchar index, uchar data)
{
    ilock(&vgaxlock);
    switch(port){

    case Seqx:
    case Crtx:
    case Grx:
        /*
         * We could use an outport here, but some chips
         * (e.g., 86C928) have trouble with that for some
         * registers.
         */
        outb(port, index);
        outb(port+1, data);
        break;

    case Attrx:
        inb(Status1);
        if(index < 0x10){
            outb(Attrx, index);
            outb(Attrx, data);
            inb(Status1);
            outb(Attrx, 0x20|index);
        }
        else{
            outb(Attrx, 0x20|index);
            outb(Attrx, data);
        }
        break;

    default:
        iunlock(&vgaxlock);
        return -1;
    }
    iunlock(&vgaxlock);

    return 0;
}
@


\section{[[VGAdev]]}

<<struct VGAdev(x86)>>=
struct VGAdev {
  char* name;

  void  (*enable)(VGAscr*);
  void  (*disable)(VGAscr*);

  void  (*page)(VGAscr*, int);
  void  (*linear)(VGAscr*, int, int);
 
  // optional
  void  (*drawinit)(VGAscr*);
  int   (*fill)(VGAscr*, Rectangle, ulong);

  void  (*ovlctl)(VGAscr*, Chan*, void*, int);
  int   (*ovlwrite)(VGAscr*, void*, int, vlong);

  void  (*flush)(VGAscr*, Rectangle);
};
@

% linear? apparently can't use soft cursor with non-linear VGA, but
% I don't know what it means ...

\section{[[/dev/vgaxxx]]}

<<enum _anon_ (kernel/devices/screen/386/devvga.c)>>=
enum {
    Qdir,

    Qvgabios,
    Qvgactl,

    Qvgaovl,
    Qvgaovlctl,
};
@

<<global vgadir(x86)>>=
static Dirtab vgadir[] = {
    ".",    { Qdir, 0, QTDIR },     0,  0550,
    "vgabios",  { Qvgabios, 0 },    0x100000, 0440,
    "vgactl",       { Qvgactl, 0 },     0,  0660,
    "vgaovl",       { Qvgaovl, 0 },     0,  0660,
    "vgaovlctl",    { Qvgaovlctl, 0 },  0,  0660,
};
@

<<enum _anon_ (kernel/devices/screen/386/devvga.c)2>>=
enum {
    CMactualsize,
    CMblank,
    CMblanktime,
    CMdrawinit,
    CMhwaccel,
    CMhwblank,
    CMhwgc,
    CMlinear,
    CMpalettedepth,
    CMpanning,
    CMsize,
    CMtextmode,
    CMtype,
    CMunblank,
};
@

<<global vgactlmsg(x86)>>=
static Cmdtab vgactlmsg[] = {
    CMactualsize,   "actualsize",   2,
    CMblank,    "blank",    1,
    CMblanktime,    "blanktime",    2,
    CMdrawinit, "drawinit", 1,
    CMhwaccel,  "hwaccel",  2,
    CMhwblank,  "hwblank",  2,
    CMhwgc,     "hwgc",     2,
    CMlinear,   "linear",   0,
    CMpalettedepth, "palettedepth", 2,
    CMpanning,  "panning",  2,
    CMsize,     "size",     3,
    CMtextmode, "textmode", 1,
    CMtype,     "type",     2,
    CMunblank,  "unblank",  1,
};
@

<<function vgareset(x86)>>=
static void
vgareset(void)
{
    /* reserve the 'standard' vga registers */
    if(ioalloc(0x2b0, 0x2df-0x2b0+1, 0, "vga") < 0)
        panic("vga ports already allocated"); 
    if(ioalloc(0x3c0, 0x3da-0x3c0+1, 0, "vga") < 0)
        panic("vga ports already allocated"); 
}
@

<<function vgaattach(x86)>>=
static Chan*
vgaattach(char* spec)
{
    if(*spec && strcmp(spec, "0"))
        error(Eio);
    return devattach('v', spec);
}
@

<<function vgawalk(x86)>>=
Walkqid*
vgawalk(Chan* c, Chan *nc, char** name, int nname)
{
    return devwalk(c, nc, name, nname, vgadir, nelem(vgadir), devgen);
}
@

<<function vgastat(x86)>>=
static int
vgastat(Chan* c, uchar* dp, int n)
{
    return devstat(c, dp, n, vgadir, nelem(vgadir), devgen);
}
@

<<function vgaopen(x86)>>=
static Chan*
vgaopen(Chan* c, int omode)
{
    VGAscr *scr;
    static char *openctl = "openctl\n";

    scr = &vgascreen;
    if ((ulong)c->qid.path == Qvgaovlctl) {
        if (scr->dev && scr->dev->ovlctl)
            scr->dev->ovlctl(scr, c, openctl, strlen(openctl));
        else 
            error(Enonexist);
    }
    return devopen(c, omode, vgadir, nelem(vgadir), devgen);
}
@

<<function vgaclose(x86)>>=
static void
vgaclose(Chan* c)
{
    VGAscr *scr;
    static char *closectl = "closectl\n";

    scr = &vgascreen;
    if((ulong)c->qid.path == Qvgaovlctl)
        if(scr->dev && scr->dev->ovlctl){
            if(waserror()){
                print("ovlctl error: %s\n", up->errstr);
                return;
            }
            scr->dev->ovlctl(scr, c, closectl, strlen(closectl));
            poperror();
        }
}
@

<<[[screensize()]] initializations part2>>=
physgscreenr = gscreen->r;
@

<<global physgscreenr>>=
Rectangle physgscreenr;
@
% gscreen->r at init time, later can be different

%XXX LP split
<<function vgaread(x86)>>=
static long
vgaread(Chan* c, void* a, long n, vlong off)
{
    int len;
    char *p, *s;
    VGAscr *scr;
    ulong offset = off;
    char chbuf[30];

    switch((ulong)c->qid.path){

    case Qdir:
        return devdirread(c, a, n, vgadir, nelem(vgadir), devgen);

    case Qvgabios:
        if(offset >= 0x100000)
            return 0;
        if(offset+n >= 0x100000)
            n = 0x100000 - offset;
        memmove(a, (uchar*)arch_kaddr(0)+offset, n); // why not KADDR()?
        return n;

    case Qvgactl:
        scr = &vgascreen;

        p = malloc(READSTR);
        if(p == nil)
            error(Enomem);
        if(waserror()){
            free(p);
            nexterror();
        }

        len = 0;

        if(scr->dev)
            s = scr->dev->name;
        else
            s = "cga";
        len += snprint(p+len, READSTR-len, "type %s\n", s);

        if(gscreen) {
            len += snprint(p+len, READSTR-len, "size %dx%dx%d %s\n",
                gscreen->r.max.x, gscreen->r.max.y,
                gscreen->depth, chantostr(chbuf, gscreen->chan));

            if(Dx(gscreen->r) != Dx(physgscreenr) 
            || Dy(gscreen->r) != Dy(physgscreenr))
                len += snprint(p+len, READSTR-len, "actualsize %dx%d\n",
                    physgscreenr.max.x, physgscreenr.max.y);
        }

        len += snprint(p+len, READSTR-len, "blank time %lud idle %d state %s\n",
            blanktime, drawidletime(), scr->isblank ? "off" : "on");
        len += snprint(p+len, READSTR-len, "hwaccel %s\n", hwaccel ? "on" : "off");
        len += snprint(p+len, READSTR-len, "hwblank %s\n", hwblank ? "on" : "off");
        len += snprint(p+len, READSTR-len, "panning %s\n", panning ? "on" : "off");
        len += snprint(p+len, READSTR-len, "addr p 0x%lux v 0x%p size 0x%ux\n", scr->paddr, scr->vaddr, scr->apsize);
        USED(len);

        n = readstr(offset, a, n, p);
        poperror();
        free(p);

        return n;

    case Qvgaovl:
    case Qvgaovlctl:
        error(Ebadusefd);
        break;

    default:
        error(Egreg);
        break;
    }

    return 0;
}
@

%//static char Ebusy[] = "vga already configured";

<<function vgactl(x86)>>=
static void
vgactl(Cmdbuf *cb)
{
    int align, i, size, x, y, z;
    char *chanstr, *p;
    ulong chan;
    Cmdtab *ct;
    VGAscr *scr;
    extern VGAdev *vgadev[];
    extern VGAcur *vgacur[];

    scr = &vgascreen;
    ct = lookupcmd(cb, vgactlmsg, nelem(vgactlmsg));
    switch(ct->index){
    <<[[vgactl]] cases(x86)>>
    }

    cmderror(cb, "bad VGA control message");
}
@


<<[[vgactl]] cases(x86)>>=
case CMhwgc:
    if(strcmp(cb->f[1], "off") == 0){
        lock(&cursor);
        if(scr->cur){
            if(scr->cur->disable)
                scr->cur->disable(scr);
            scr->cur = nil;
        }
        unlock(&cursor);
        return;
    }
    if(strcmp(cb->f[1], "soft") == 0){
        lock(&cursor);
        swcursorinit_wrapper();
        if(scr->cur && scr->cur->disable)
            scr->cur->disable(scr);
        scr->cur = &swcursor;
        if(scr->cur->enable)
            scr->cur->enable(scr);
        unlock(&cursor);
        return;
    }
    for(i = 0; vgacur[i]; i++){
        if(strcmp(cb->f[1], vgacur[i]->name))
            continue;
        lock(&cursor);
        if(scr->cur && scr->cur->disable)
            scr->cur->disable(scr);
        scr->cur = vgacur[i];
        if(scr->cur->enable)
            scr->cur->enable(scr);
        unlock(&cursor);
        return;
    }
    break;
@
<<[[vgactl]] cases(x86)>>=
case CMtype:
    for(i = 0; vgadev[i]; i++){
        if(strcmp(cb->f[1], vgadev[i]->name))
            continue;
        if(scr->dev && scr->dev->disable)
            scr->dev->disable(scr);
        scr->dev = vgadev[i];
        if(scr->dev->enable)
            scr->dev->enable(scr);
        return;
    }
    break;
@


<<[[vgactl]] cases(x86)>>=
case CMsize:
    x = strtoul(cb->f[1], &p, 0);
    if(x == 0 || x > 10240)
        error(Ebadarg);
    if(*p)
        p++;

    y = strtoul(p, &p, 0);
    if(y == 0 || y > 10240)
        error(Ebadarg);
    if(*p)
        p++;

    z = strtoul(p, &p, 0);

    chanstr = cb->f[2];
    if((chan = strtochan(chanstr)) == 0)
        error("bad channel");

    if(chantodepth(chan) != z)
        error("depth, channel do not match");

    arch_cursoroff(1);
    deletescreenimage();
    if(screensize(x, y, z, chan))
        error(Egreg);
    vgascreenwin(scr);
    resetscreenimage();
    arch_cursoron(1);
    return;
@

<<function resetscreenimage>>=
void
resetscreenimage(void)
{
    dlock();
    initscreenimage();
    dunlock();
}
@



<<function deletescreenimage>>=
void
deletescreenimage(void)
{
    dlock();
    if(screenimage){
        /* will be freed via screendimage; disable */
        screenimage->clipr = ZR;
        screenimage = nil;
    }
    if(screendimage){
        drawfreedimage(screendimage);
        screendimage = nil;
    }
    dunlock();
}
@



<<[[vgactl]] cases(x86)>>=
case CMactualsize:
    if(gscreen == nil)
        error("set the screen size first");

    x = strtoul(cb->f[1], &p, 0);
    if(x == 0 || x > 2048)
        error(Ebadarg);
    if(*p)
        p++;

    y = strtoul(p, nil, 0);
    if(y == 0 || y > 2048)
        error(Ebadarg);

    if(x > gscreen->r.max.x || y > gscreen->r.max.y)
        error("physical screen bigger than virtual");

    physgscreenr = Rect(0,0,x,y);
    gscreen->clipr = physgscreenr;
    return;
@
<<[[vgactl]] cases(x86)>>=
case CMpalettedepth:
    x = strtoul(cb->f[1], &p, 0);
    if(x != 8 && x != 6)
        error(Ebadarg);

    scr->palettedepth = x;
    return;
@
<<[[vgactl]] cases(x86)>>=
case CMdrawinit:
    if(gscreen == nil)
        error("drawinit: no gscreen");
    if(scr->dev && scr->dev->drawinit)
        scr->dev->drawinit(scr);
    return;
@



<<[[vgactl]] cases(x86)>>=
case CMlinear:
    if(cb->nf!=2 && cb->nf!=3)
        error(Ebadarg);
    size = strtoul(cb->f[1], 0, 0);
    if(cb->nf == 2)
        align = 0;
    else
        align = strtoul(cb->f[2], 0, 0);
    if(screenaperture(size, align) < 0)
        error("not enough free address space");
    return;
@

% vgactl linear -> <>
<<function screenaperture(x86)>>=
int
screenaperture(int size, int align)
{
    VGAscr *scr;

    scr = &vgascreen;

    if(scr->paddr)  /* set up during enable */
        return 0;

    if(size == 0)
        return 0;

    if(scr->dev && scr->dev->linear){
        scr->dev->linear(scr, size, align);
        return 0;
    }

    /*
     * Need to allocate some physical address space.
     * The driver will tell the card to use it.
     */
    size = PGROUND(size);
    scr->paddr = upaalloc(size, align);
    if(scr->paddr == 0)
        return -1;
    scr->vaddr = vmap(scr->paddr, size);
    if(scr->vaddr == nil)
        return -1;
    scr->apsize = size;

    return 0;
}
@



%/*  
%case CMmemset:
%    memset((void*)strtoul(cb->f[1], 0, 0), atoi(cb->f[2]), atoi(cb->f[3]));
%    return;
%*/


<<global panning(x86)>>=
bool panning = false;
@
% try? 

<<[[vgactl]] cases(x86)>>=
case CMpanning:
    if(strcmp(cb->f[1], "on") == 0){
        if(scr == nil || scr->cur == nil)
            error("set screen first");
        if(!scr->cur->doespanning)
            error("panning not supported");
        gscreen->clipr = gscreen->r;
        panning = true;
    }
    else if(strcmp(cb->f[1], "off") == 0){
        gscreen->clipr = physgscreenr;
        panning = false;
    }else
        break;
    return;
@


<<[[vgactl]] cases(x86)>>=
case CMhwaccel:
    if(strcmp(cb->f[1], "on") == 0)
        hwaccel = 1;
    else if(strcmp(cb->f[1], "off") == 0)
        hwaccel = 0;
    else
        break;
    return;
@


<<[[vgactl]] cases(x86)>>=
case CMtextmode:
    arch__screeninit();
    return;
@
% screeninit() is in kernel.nw, and essentially does
% screenputs = cgascreenputs;





<<global Enooverlay(x86)>>=
char Enooverlay[] = "No overlay support";
@

<<function vgawrite(x86)>>=
static long
vgawrite(Chan* c, void* a, long n, vlong off)
{
    ulong offset = off;
    Cmdbuf *cb;
    VGAscr *scr;

    switch((ulong)c->qid.path){

    case Qdir:
        error(Eperm);

    case Qvgactl:
        if(offset || n >= READSTR)
            error(Ebadarg);
        cb = parsecmd(a, n);
        if(waserror()){
            free(cb);
            nexterror();
        }
        vgactl(cb);
        poperror();
        free(cb);
        return n;

    case Qvgaovl:
        scr = &vgascreen;
        if (scr->dev == nil || scr->dev->ovlwrite == nil) {
            error(Enooverlay);
            break;
        }
        return scr->dev->ovlwrite(scr, a, n, off);

    case Qvgaovlctl:
        scr = &vgascreen;
        if (scr->dev == nil || scr->dev->ovlctl == nil) {
            error(Enooverlay);
            break;
        }
        scr->dev->ovlctl(scr, c, a, n);
        return n;

    default:
        error(Egreg);
        break;
    }

    return 0;
}
@


\section{VGA linear addressing}

% used?

<<function vgalinearpciid(x86)>>=
void
vgalinearpciid(VGAscr *scr, int vid, int did)
{
    Pcidev *p;

    p = nil;
    while((p = pcimatch(p, vid, 0)) != nil){
        if(p->ccrb != 3)    /* video card */
            continue;
        if(did != 0 && p->did != did)
            continue;
        break;
    }
    if(p == nil)
        error("pci video card not found");

    scr->pci = p;
    vgalinearpci(scr);
}
@

% vgalinearpciid -> <>
<<function vgalinearpci(x86)>>=
void
vgalinearpci(VGAscr *scr)
{
    ulong paddr;
    int i, size, best;
    Pcidev *p;
    
    p = scr->pci;
    if(p == nil)
        return;

    /*
     * Scan for largest memory region on card.
     * Some S3 cards (e.g., Savage) have enormous
     * mmio regions (but even larger frame buffers).
     * Some 3dfx cards (e.g., Voodoo3) have mmio
     * buffers the same size as the frame buffer,
     * but only the frame buffer is marked as
     * prefetchable (bar&8).  If a card doesn't fit
     * into these heuristics, its driver will have to
     * call vgalinearaddr directly.
     */
    best = -1;
    for(i=0; i<nelem(p->mem); i++){
        if(p->mem[i].bar&1) /* not memory */
            continue;
        if(p->mem[i].size < 640*480)    /* not big enough */
            continue;
        if(best==-1 
        || p->mem[i].size > p->mem[best].size 
        || (p->mem[i].size == p->mem[best].size 
          && (p->mem[i].bar&8)
          && !(p->mem[best].bar&8)))
            best = i;
    }
    if(best >= 0){
        paddr = p->mem[best].bar & ~0x0F;
        size = p->mem[best].size;
        vgalinearaddr(scr, paddr, size);
        return;
    }
    error("no video memory found on pci card");
}
@


% vgalinearpci | vesalinear -> <>
<<function vgalinearaddr(x86)>>=
void
vgalinearaddr(VGAscr *scr, ulong paddr, int size)
{
    int x, nsize;
    ulong npaddr;

    /*
     * new approach.  instead of trying to resize this
     * later, let's assume that we can just allocate the
     * entire window to start with.
     */

    if(scr->paddr == paddr && size <= scr->apsize)
        return;

    if(scr->paddr){
        /*
         * could call vunmap and vmap,
         * but worried about dangling pointers in devdraw
         */
        error("cannot grow vga frame buffer");
    }
    
    /* round to page boundary, just in case */
    x = paddr&(BY2PG-1);
    npaddr = paddr-x;
    nsize = PGROUND(size+x);

    /*
     * Don't bother trying to map more than 4000x4000x32 = 64MB.
     * We only have a 256MB window.
     */
    if(nsize > 64*MB)
        nsize = 64*MB;
    scr->vaddr = vmap(npaddr, nsize);
    if(scr->vaddr == 0)
        error("cannot allocate vga frame buffer");
    scr->vaddr = (char*)scr->vaddr+x;
    scr->paddr = paddr;
    scr->apsize = nsize;
    /* let mtrr harmlessly fail on old CPUs, e.g., P54C */
    if(!waserror()){
        //mtrr(npaddr, nsize, "wc"); disabled mtrr
                error("mtrr disabled");
        poperror();
    }
}
@

\section{VGA page}

<<[[screensize()]] when use softscreen, other settings>>=
if(scr->dev && scr->dev->page){
    scr->vaddr = KADDR(VGAMEM());
    scr->apsize = 1<<16;
}
@
% >>

<<[[flushmemscreen()]] other locals>>=
byte *sp, *disp, *sdisp, *edisp;
int y, len, incs, off, page;
@

<<[[flushmemscreen()]] use VGA page>>=
incs = gscreen->width * BY2WD;

switch(gscreen->depth){
case 8:
    len = Dx(r);
    break;
default:
    len = 0;
    panic("flushmemscreen: depth\n");
    break;
}
if(len < 1)
    return;

off = r.min.y * gscreen->width * BY2WD 
       + (r.min.x * gscreen->depth)/8;
page = off/scr->apsize;
off %= scr->apsize;
disp = scr->vaddr;
sdisp = disp+off;
edisp = disp+scr->apsize;

off = r.min.y * gscreen->width * BY2WD
       + (r.min.x * gscreen->depth)/8;

sp = gscreendata.bdata + off;

// call device driver again, for subpart
scr->dev->page(scr, page);

for(y = r.min.y; y < r.max.y; y++) {
    if(sdisp + incs < edisp) {
        memmove(sdisp, sp, len);
        sp += incs;
        sdisp += incs;
    }
    else {
        off = edisp - sdisp;
        page++;
        if(off <= len){
            if(off > 0)
                memmove(sdisp, sp, off);

            // call device driver again, for subpart
            scr->dev->page(scr, page);
            if(len - off > 0)
                memmove(disp, sp+off, len - off);
        }
        else {
            memmove(sdisp, sp, len);
            // call device driver again, for subpart
            scr->dev->page(scr, page);
        }
        sp += incs;
        sdisp += incs - scr->apsize;
    }
}
@

\section{VESA}

% see more in Graphics_extra

<<global vgavesadev(x86)>>=
VGAdev vgavesadev = {
    "vesa",
    0,
    0,
    0,
    vesalinear,
    0,
    0,
    0,
    0,
    vesaflush,
};
@


<<function vesalinear(x86)>>=
static void
vesalinear(VGAscr *scr, int, int)
{
    int i, mode, size, havesize;
    uchar *p;
    ulong paddr;
    Pcidev *pci;

    if(hardscreen) {
        scr->vaddr = 0;
        scr->paddr = scr->apsize = 0;
        return;
    }

    vbecheck();
    mode = vbegetmode();
    /*
     * bochs loses the top bits - cannot use this
    if((mode&(1<<14)) == 0)
        error("not in linear graphics mode");
     */
    mode &= 0x3FFF;
    p = vbemodeinfo(mode);
    if(!(WORD(p+0) & (1<<4)))
        error("not in VESA graphics mode");
    if(!(WORD(p+0) & (1<<7)))
        error("not in linear graphics mode");

    paddr = LONG(p+40);
    size = WORD(p+20)*WORD(p+16);
    size = PGROUND(size);

    /*
     * figure out max size of memory so that we have
     * enough if the screen is resized.
     */
    pci = nil;
    havesize = 0;
    while(!havesize && (pci = pcimatch(pci, 0, 0)) != nil){
        if(pci->ccrb != Pcibcdisp)
            continue;
        for(i=0; i<nelem(pci->mem); i++)
            if(paddr == (pci->mem[i].bar&~0x0F)){
                if(pci->mem[i].size > size)
                    size = pci->mem[i].size;
                havesize = 1;
                break;
            }
    }

    /* no pci - heuristic guess */
    if (!havesize)
        if(size < 4*1024*1024)
            size = 4*1024*1024;
        else
            size = ROUND(size, 1024*1024);
    if(size > 16*1024*1024)     /* arbitrary */
        size = 16*1024*1024;

    vgalinearaddr(scr, paddr, size);
    if(scr->apsize)
        addvgaseg("vesascreen", scr->paddr, scr->apsize);

    if(Usesoftscreen){
        hardscreen = scr->vaddr;
        scr->vaddr = 0;
        scr->paddr = scr->apsize = 0;
    }
}
@
% >> >> >>


\section{Cirrus logic 5446}

% A classic car, I even got it I think :)

<<global vgaclgd542xdev(x86)>>=
VGAdev vgaclgd542xdev = {
    .name = "clgd542x",

    .enable = nil,
    .disable = nil,
    .page = clgd542xpage,
    .linear = clgd542xlinear,
};
@

\subsection{Linear mode}

<<function clgd542xlinear(x86)>>=
static void
clgd542xlinear(VGAscr* scr, int, int)
{
    vgalinearpciid(scr, 0x1013, 0);
}
@


\subsection{Page}

<<function clgd542xpage(x86)>>=
static void
clgd542xpage(VGAscr* scr, int page)
{
    lock(&scr->devlock);
    clgd542xpageset(scr, page);
    unlock(&scr->devlock);
}
@

<<function clgd542xpageset(x86)>>=
static int
clgd542xpageset(VGAscr*, int page)
{
    uchar gr09;
    int opage;
    
    if(vgaxi(Seqx, 0x07) & 0xF0)
        page = 0;
    gr09 = vgaxi(Grx, 0x09);
    if(vgaxi(Grx, 0x0B) & 0x20){
        vgaxo(Grx, 0x09, page<<2);
        opage = gr09>>2;
    }
    else{
        vgaxo(Grx, 0x09, page<<4);
        opage = gr09>>4;
    }

    return opage;
}
@



\subsection{Cursor}

<<global vgaclgd542xcur(x86)>>=
VGAcur vgaclgd542xcur = {
    .name = "clgd542xhwgc",

    .enable = clgd542xenable,
    .disable = clgd542xdisable,
    .load = clgd542xload,
    .move = clgd542xmove,
};
@


<<function clgd542xenable(x86)>>=
static void
clgd542xenable(VGAscr* scr)
{
    uchar sr12;
    int mem, x;
 
    /*
     * Disable the cursor.
     */
    sr12 = vgaxi(Seqx, 0x12);
    vgaxo(Seqx, 0x12, sr12 & ~0x01);

    /*
     * Cursor colours.
     * Can't call setcolor here as cursor is already locked.
     */
    vgaxo(Seqx, 0x12, sr12|0x02);
    vgao(PaddrW, 0x00);
    vgao(Pdata, Pwhite);
    vgao(Pdata, Pwhite);
    vgao(Pdata, Pwhite);
    vgao(PaddrW, 0x0F);
    vgao(Pdata, Pblack);
    vgao(Pdata, Pblack);
    vgao(Pdata, Pblack);
    vgaxo(Seqx, 0x12, sr12);

    mem = 0;
    switch(vgaxi(Crtx, 0x27) & ~0x03){

    case 0x88:              /* CL-GD5420 */
    case 0x8C:              /* CL-GD5422 */
    case 0x94:              /* CL-GD5424 */
    case 0x80:              /* CL-GD5425 */
    case 0x90:              /* CL-GD5426 */
    case 0x98:              /* CL-GD5427 */
    case 0x9C:              /* CL-GD5429 */
        /*
         * The BIOS leaves the memory size in Seq0A, bits 4 and 3.
         * See Technical Reference Manual Appendix E1, Section 1.3.2.
         *
         * The storage area for the 64x64 cursors is the last 16Kb of
         * display memory.
         */
        mem = (vgaxi(Seqx, 0x0A)>>3) & 0x03;
        break;

    case 0xA0:              /* CL-GD5430 */
    case 0xA8:              /* CL-GD5434 */
    case 0xAC:              /* CL-GD5436 */
    case 0xB8:              /* CL-GD5446 */
    case 0x30:              /* CL-GD7543 */
        /*
         * Attempt to intuit the memory size from the DRAM control
         * register. Minimum is 512KB.
         * If DRAM bank switching is on then there's double.
         */
        x = vgaxi(Seqx, 0x0F);
        mem = (x>>3) & 0x03;
        if(x & 0x80)
            mem++;
        break;

    case 0xBC:              /* CL-GD5480 */
        mem = 2;            /* 1024 = 256<<2 */
        x = vgaxi(Seqx, 0x0F);
        if((x & 0x18) == 0x18){
            mem <<= 1;      /* 2048 = 256<<3 */
            if(x & 0x80)
                mem <<= 2;  /* 2048 = 256<<4 */
        }
        if(vgaxi(Seqx, 0x17) & 0x80)
            mem <<= 1;
        break;

    default:                /* uh, ah dunno */
        break;
    }
    scr->storage = ((256<<mem)-16)*1024;

    /*
     * Set the current cursor to index 0
     * and turn the 64x64 cursor on.
     */
    vgaxo(Seqx, 0x13, 0);
    vgaxo(Seqx, 0x12, sr12|0x05);
}
@
% >> >> >> >> >> >> >>


<<function clgd542xdisable(x86)>>=
static void
clgd542xdisable(VGAscr*)
{
    uchar sr12;

    sr12 = vgaxi(Seqx, 0x12);
    vgaxo(Seqx, 0x12, sr12 & ~0x01);
}
@


% xxxload | xxxmove -> <>
<<function clgd542xinitcursor(x86)>>=
static void
clgd542xinitcursor(VGAscr* scr, int xo, int yo, int index)
{
    uchar *p, seq07;
    uint p0, p1;
    int opage, x, y;

    /*
     * Is linear addressing turned on? This will determine
     * how we access the cursor storage.
     */
    seq07 = vgaxi(Seqx, 0x07);
    opage = 0;
    p = scr->vaddr;
    if(!(seq07 & 0xF0)){
        lock(&scr->devlock);
        opage = clgd542xpageset(scr, scr->storage>>16);
        p += (scr->storage & 0xFFFF);
    }
    else
        p += scr->storage;
    p += index*1024;

    for(y = yo; y < 16; y++){
        p0 = scr->set[2*y];
        p1 = scr->set[2*y+1];
        if(xo){
            p0 = (p0<<xo)|(p1>>(8-xo));
            p1 <<= xo;
        }
        *p++ = p0;
        *p++ = p1;

        for(x = 16; x < 64; x += 8)
            *p++ = 0x00;

        p0 = scr->clr[2*y]|scr->set[2*y];
        p1 = scr->clr[2*y+1]|scr->set[2*y+1];
        if(xo){
            p0 = (p0<<xo)|(p1>>(8-xo));
            p1 <<= xo;
        }
        *p++ = p0;
        *p++ = p1;

        for(x = 16; x < 64; x += 8)
            *p++ = 0x00;
    }
    while(y < 64+yo){
        for(x = 0; x < 64; x += 8){
            *p++ = 0x00;
            *p++ = 0x00;
        }
        y++;
    }

    if(!(seq07 & 0xF0)){
        clgd542xpageset(scr, opage);
        unlock(&scr->devlock);
    }
}
@


<<function clgd542xmove(x86)>>=
static int
clgd542xmove(VGAscr* scr, Point p)
{
    int index, x, xo, y, yo;

    index = 0;
    if((x = p.x+scr->offset.x) < 0){
        xo = -x;
        x = 0;
    }
    else
        xo = 0;
    if((y = p.y+scr->offset.y) < 0){
        yo = -y;
        y = 0;
    }
    else
        yo = 0;

    if(xo || yo){
        clgd542xinitcursor(scr, xo, yo, 1);
        index = 1;
    }
    vgaxo(Seqx, 0x13, index<<2);
    
    vgaxo(Seqx, 0x10|((x & 0x07)<<5), (x>>3) & 0xFF);
    vgaxo(Seqx, 0x11|((y & 0x07)<<5), (y>>3) & 0xFF);

    return 0;
}
@


<<function clgd542xload(x86)>>=
static void
clgd542xload(VGAscr* scr, Cursor* curs)
{
    uchar sr12;

    /*
     * Disable the cursor.
     */
    sr12 = vgaxi(Seqx, 0x12);
    vgaxo(Seqx, 0x12, sr12 & ~0x01);

    memmove(&scr->Cursor, curs, sizeof(Cursor));
    clgd542xinitcursor(scr, 0, 0, 0);

    /*
     * Enable the cursor.
     */
    vgaxo(Seqx, 0x13, 0);
    vgaxo(Seqx, 0x12, sr12|0x05);
}
@



\section{[[/bin/vga]]}



\chapter{Examples of Graphical Applications TODO}
\label{chap:examples}

% rio! next book.

% hello world! shorter than horrible X11 version?

% put code for menu? after all it's a nice example of use
% of draw.h, and how to build. So put it here instead of in Adv topics?

% color.c? clock.c?
% lens? illustrate well features?
% faces.c? 
% both are mentioned in Unix Readers as very early graphic programs.



\chapter{Extra Code}

\ifallcode
#include "Graphics_extra.nw"
\fi

%\chapter{Changelog}
%\label{sec:changelog}
% code via make loc = 23 241 LOC (but code of tests, apps, drivers code, ...)
% orig nw = 26700, just lpized and many comments, 231 pages pdf
%  (but no tests, no apps)
% now: ? LOC ? pages, so added ?? LOE (Lines of explanations)


\chapter*{Glossary}
\addcontentsline{toc}{chapter}{Glossary}
\label{sec:glossary}

\begin{verbatim}
API = Application Programming Interface
LOC = Lines Of Code 
VGA = Video Graphics Array
RGB = Red Green Blue
GUI = Graphical User Interface
CAD = Computer Aided Design
OpenGL = Open Graphics Library
VGA = Video Graphics Array
\end{verbatim}
% 2D/3D?

\chapter*{Indexes}
\addcontentsline{toc}{chapter}{Index}

%\chapter{References} 
\addcontentsline{toc}{chapter}{References}

\bibliography{../docs/latex/Principia}
\bibliographystyle{alpha}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
