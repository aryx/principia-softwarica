\section{[[include/]]}

\subsection*{[[include/complete.h]]}

<<struct Completion>>=
struct Completion{
    uchar advance;		/* whether forward progress has been made */
    uchar complete;	/* whether the completion now represents a file or directory */
    char *string;		/* the string to advance, suffixed " " or "/" for file or directory */
    int nmatch;		/* number of files that matched */
    int nfile;			/* number of files returned */
    char **filename;	/* their names */
};
@


%-------------------------------------------------------------

<<include/complete.h>>=
#pragma	lib	"libcomplete.a"
#pragma src "/sys/src/libcomplete"

typedef struct Completion Completion;

<<struct Completion>>

Completion* complete(char *dir, char *s);
void freecompletion(Completion*);
@


\subsection*{[[include/cursor.h]]}

<<struct Cursor>>=
struct	Cursor
{
    Point	offset;
    uchar	clr[2*16];
    uchar	set[2*16];
};
@


%-------------------------------------------------------------

<<include/cursor.h>>=
#pragma src "/sys/src/libdraw"

<<struct Cursor>>
@


\subsection*{[[include/draw.h]]}

<<enum _anon_>>=
enum
{
    DOpaque		= 0xFFFFFFFF,
    DTransparent	= 0x00000000,		/* only useful for allocimage, memfillcolor */
    DBlack		= 0x000000FF,
    DWhite		= 0xFFFFFFFF,
    DRed		= 0xFF0000FF,
    DGreen		= 0x00FF00FF,
    DBlue		= 0x0000FFFF,
    DCyan		= 0x00FFFFFF,
    DMagenta		= 0xFF00FFFF,
    DYellow		= 0xFFFF00FF,
    DPaleyellow	= 0xFFFFAAFF,
    DDarkyellow	= 0xEEEE9EFF,
    DDarkgreen	= 0x448844FF,
    DPalegreen	= 0xAAFFAAFF,
    DMedgreen	= 0x88CC88FF,
    DDarkblue	= 0x000055FF,
    DPalebluegreen= 0xAAFFFFFF,
    DPaleblue		= 0x0000BBFF,
    DBluegreen	= 0x008888FF,
    DGreygreen	= 0x55AAAAFF,
    DPalegreygreen	= 0x9EEEEEFF,
    DYellowgreen	= 0x99994CFF,
    DMedblue		= 0x000099FF,
    DGreyblue	= 0x005DBBFF,
    DPalegreyblue	= 0x4993DDFF,
    DPurpleblue	= 0x8888CCFF,

    DNotacolor	= 0xFFFFFF00,
    DNofill		= DNotacolor,
    
};
@

<<enum _anon_ (include/draw.h)>>=
enum
{
    Displaybufsize	= 8000,
    ICOSSCALE	= 1024,
    Borderwidth =	4,
};
@

<<enum _anon_ (include/draw.h)2>>=
enum
{
    /* refresh methods */
    Refbackup	= 0,
    Refnone		= 1,
    Refmesg		= 2
};
@

<<constant NOREFRESH>>=
#define	NOREFRESH	((void*)-1)
@

<<enum _anon_ (include/draw.h)3>>=
enum
{
    /* line ends */
    Endsquare	= 0,
    Enddisc		= 1,
    Endarrow	= 2,
    Endmask		= 0x1F
};
@

<<function ARROW>>=
#define	ARROW(a, b, c)	(Endarrow|((a)<<5)|((b)<<14)|((c)<<23))
@

<<enum _anon_ (include/draw.h)4>>=
/*
 * image channel descriptors 
 */
enum {
    CRed = 0,
    CGreen,
    CBlue,
    CGrey,
    CAlpha,
    CMap,
    CIgnore,
    NChan,
};
@

<<function __DC>>=
#define __DC(type, nbits)	((((type)&15)<<4)|((nbits)&15))
@

<<function CHAN1>>=
#define CHAN1(a,b)	__DC(a,b)
@

<<function CHAN2>>=
#define CHAN2(a,b,c,d)	(CHAN1((a),(b))<<8|__DC((c),(d)))
@

<<function CHAN3>>=
#define CHAN3(a,b,c,d,e,f)	(CHAN2((a),(b),(c),(d))<<8|__DC((e),(f)))
@

<<function CHAN4>>=
#define CHAN4(a,b,c,d,e,f,g,h)	(CHAN3((a),(b),(c),(d),(e),(f))<<8|__DC((g),(h)))
@

<<function NBITS>>=
#define NBITS(c) ((c)&15)
@

<<function TYPE>>=
#define TYPE(c) (((c)>>4)&15)
@

<<enum _anon_ (include/draw.h)5>>=
enum {
    GREY1	= CHAN1(CGrey, 1),
    GREY2	= CHAN1(CGrey, 2),
    GREY4	= CHAN1(CGrey, 4),
    GREY8	= CHAN1(CGrey, 8),
    CMAP8	= CHAN1(CMap, 8),
    RGB15	= CHAN4(CIgnore, 1, CRed, 5, CGreen, 5, CBlue, 5),
    RGB16	= CHAN3(CRed, 5, CGreen, 6, CBlue, 5),
    RGB24	= CHAN3(CRed, 8, CGreen, 8, CBlue, 8),
    RGBA32	= CHAN4(CRed, 8, CGreen, 8, CBlue, 8, CAlpha, 8),
    ARGB32	= CHAN4(CAlpha, 8, CRed, 8, CGreen, 8, CBlue, 8),	/* stupid VGAs */
    XRGB32	= CHAN4(CIgnore, 8, CRed, 8, CGreen, 8, CBlue, 8),
    BGR24	= CHAN3(CBlue, 8, CGreen, 8, CRed, 8),
    ABGR32	= CHAN4(CAlpha, 8, CBlue, 8, CGreen, 8, CRed, 8),
    XBGR32	= CHAN4(CIgnore, 8, CBlue, 8, CGreen, 8, CRed, 8),
};
@

<<struct Point>>=
struct	Point
{
    int	x;
    int	y;
};
@

<<struct Rectangle>>=
struct Rectangle
{
    Point	min;
    Point	max;
};
@

<<struct Screen>>=
struct Screen
{
    Display	*display;	/* display holding data */
    int	id;		/* id of system-held Screen */
    Image	*image;		/* unused; for reference only */
    Image	*fill;		/* color to paint behind windows */
};
@

<<struct Display>>=
struct Display
{
    QLock		qlock;
    int		locking;	/*program is using lockdisplay */
    int		dirno;
    int		fd;
    int		reffd;
    int		ctlfd;
    int		imageid;
    int		local;
    void		(*error)(Display*, char*);
    char		*devdir;
    char		*windir;
    char		oldlabel[64];
    ulong		dataqid;
    Image		*white;
    Image		*black;
    Image		*opaque;
    Image		*transparent;
    Image		*image;
    uchar		*buf;
    int		bufsize;
    uchar		*bufp;
    Font		*defaultfont;
    Subfont		*defaultsubfont;
    Image		*windows;
    Image		*screenimage;
    int		_isnewdisplay;
};
@

<<struct Image>>=
struct Image
{
    Display		*display;	/* display holding data */
    int		id;		/* id of system-held Image */
    Rectangle	r;		/* rectangle in data area, local coords */
    Rectangle 	clipr;		/* clipping region */
    int		depth;		/* number of bits per pixel */
    ulong		chan;
    int		repl;		/* flag: data replicates to tile clipr */
    Screen		*screen;	/* 0 if not a window */
    Image		*next;	/* next in list of windows */
};
@

<<struct RGB>>=
struct RGB
{
    ulong	red;
    ulong	green;
    ulong	blue;
};
@

<<struct Fontchar>>=
/*
 * Subfonts
 *
 * given char c, Subfont *f, Fontchar *i, and Point p, one says
 *	i = f->info+c;
 *	draw(b, Rect(p.x+i->left, p.y+i->top,
 *		p.x+i->left+((i+1)->x-i->x), p.y+i->bottom),
 *		color, f->bits, Pt(i->x, i->top));
 *	p.x += i->width;
 * to draw characters in the specified color (itself an Image) in Image b.
 */

struct	Fontchar
{
    int		x;		/* left edge of bits */
    uchar		top;		/* first non-zero scan-line */
    uchar		bottom;		/* last non-zero scan-line + 1 */
    char		left;		/* offset of baseline */
    uchar		width;		/* width of baseline */
};
@

<<struct Subfont>>=
struct	Subfont
{
    char		*name;
    short		n;		/* number of chars in font */
    uchar		height;		/* height of image */
    char		ascent;		/* top of image to baseline */
    Fontchar 	*info;		/* n+1 character descriptors */
    Image		*bits;		/* of font */
    int		ref;
};
@

<<enum _anon_ (include/draw.h)6>>=
enum
{
    /* starting values */
    LOG2NFCACHE =	6,
    NFCACHE =	(1<<LOG2NFCACHE),	/* #chars cached */
    NFLOOK =	5,			/* #chars to scan in cache */
    NFSUBF =	2,			/* #subfonts to cache */
    /* max value */
    MAXFCACHE =	1024+NFLOOK,		/* upper limit */
    MAXSUBF =	50,			/* generous upper limit */
    /* deltas */
    DSUBF = 	4,
    /* expiry ages */
    SUBFAGE	=	10000,
    CACHEAGE =	10000
};
@

<<struct Cachefont>>=
struct Cachefont
{
    Rune		min;	/* lowest rune value to be taken from subfont */
    Rune		max;	/* highest rune value+1 to be taken from subfont */
    int		offset;	/* position in subfont of character at min */
    char		*name;			/* stored in font */
    char		*subfontname;		/* to access subfont */
};
@

<<struct Cacheinfo>>=
struct Cacheinfo
{
    ushort		x;		/* left edge of bits */
    uchar		width;		/* width of baseline */
    schar		left;		/* offset of baseline */
    Rune		value;	/* value of character at this slot in cache */
    ushort		age;
};
@

<<struct Cachesubf>>=
struct Cachesubf
{
    ulong		age;	/* for replacement */
    Cachefont	*cf;	/* font info that owns us */
    Subfont		*f;	/* attached subfont */
};
@

<<struct Font>>=
struct Font
{
    char		*name;
    Display		*display;
    short		height;	/* max height of image, interline spacing */
    short		ascent;	/* top of image to baseline */
    short		width;	/* widest so far; used in caching only */	
    short		nsub;	/* number of subfonts */
    ulong		age;	/* increasing counter; used for LRU */
    int		maxdepth;	/* maximum depth of all loaded subfonts */
    int		ncache;	/* size of cache */
    int		nsubf;	/* size of subfont list */
    Cacheinfo	*cache;
    Cachesubf	*subf;
    Cachefont	**sub;	/* as read from file */
    Image		*cacheimage;
};
@

<<function Dx>>=
#define	Dx(r)	((r).max.x-(r).min.x)
@

<<function Dy>>=
#define	Dy(r)	((r).max.y-(r).min.y)
@

<<function BGSHORT>>=
#define	BGSHORT(p)		(((p)[0]<<0) | ((p)[1]<<8))
@

<<function BGLONG>>=
#define	BGLONG(p)		((BGSHORT(p)<<0) | (BGSHORT(p+2)<<16))
@

<<function BPSHORT>>=
#define	BPSHORT(p, v)		((p)[0]=(v), (p)[1]=((v)>>8))
@

<<function BPLONG>>=
#define	BPLONG(p, v)		(BPSHORT(p, (v)), BPSHORT(p+2, (v)>>16))
@

<<constant NMATCH>>=
/*
 * Compressed image file parameters and helper routines
 */
#define	NMATCH	3		/* shortest match possible */
@

<<constant NRUN>>=
#define	NRUN	(NMATCH+31)	/* longest match possible */
@

<<constant NMEM>>=
#define	NMEM	1024		/* window size */
@

<<constant NDUMP>>=
#define	NDUMP	128		/* maximum length of dump */
@

<<constant NCBLOCK>>=
#define	NCBLOCK	6000		/* size of compressed blocks */
@


%-------------------------------------------------------------

<<include/draw.h>>=
#pragma src "/sys/src/libdraw"
#pragma lib "libdraw.a"

typedef struct	Cachefont Cachefont;
typedef struct	Cacheinfo Cacheinfo;
typedef struct	Cachesubf Cachesubf;
typedef struct	Display Display;
typedef struct	Font Font;
typedef struct	Fontchar Fontchar;
typedef struct	Image Image;
typedef struct	Mouse Mouse;
typedef struct	Point Point;
typedef struct	Rectangle Rectangle;
typedef struct	RGB RGB;
typedef struct	Screen Screen;
typedef struct	Subfont Subfont;

#pragma incomplete Mouse

#pragma varargck	type	"R"	Rectangle
#pragma varargck	type	"P"	Point
extern	int	Rfmt(Fmt*);
extern	int	Pfmt(Fmt*);

<<enum _anon_>>

<<enum _anon_ (include/draw.h)>>

<<enum _anon_ (include/draw.h)2>>
<<constant NOREFRESH>>

<<enum _anon_ (include/draw.h)3>>

<<function ARROW>>

typedef enum
{
    /* Porter-Duff compositing operators */
    Clear	= 0,

    SinD	= 8,
    DinS	= 4,
    SoutD	= 2,
    DoutS	= 1,

    S		= SinD|SoutD,
    SoverD	= SinD|SoutD|DoutS,
    SatopD	= SinD|DoutS,
    SxorD	= SoutD|DoutS,

    D		= DinS|DoutS,
    DoverS	= DinS|DoutS|SoutD,
    DatopS	= DinS|SoutD,
    DxorS	= DoutS|SoutD,	/* == SxorD */

    Ncomp = 12,
} Drawop;

<<enum _anon_ (include/draw.h)4>>

<<function __DC>>
<<function CHAN1>>
<<function CHAN2>>
<<function CHAN3>>
<<function CHAN4>>

<<function NBITS>>
<<function TYPE>>

<<enum _anon_ (include/draw.h)5>>

extern	char*	chantostr(char*, ulong);
extern	ulong	strtochan(char*);
extern	int		chantodepth(ulong);

<<struct Point>>

<<struct Rectangle>>

typedef void	(*Reffn)(Image*, Rectangle, void*);

<<struct Screen>>

<<struct Display>>

<<struct Image>>

<<struct RGB>>

<<struct Fontchar>>

<<struct Subfont>>

<<enum _anon_ (include/draw.h)6>>

<<struct Cachefont>>

<<struct Cacheinfo>>

<<struct Cachesubf>>

<<struct Font>>

<<function Dx>>
<<function Dy>>

/*
 * One of a kind
 */
extern int		mousescrollsize(int);

/*
 * Image management
 */
extern Image*	_allocimage(Image*, Display*, Rectangle, ulong, int, ulong, int, int);
extern Image*	allocimage(Display*, Rectangle, ulong, int, ulong);
extern uchar*	bufimage(Display*, int);
extern int	bytesperline(Rectangle, int);
extern void	closedisplay(Display*);
extern void	drawerror(Display*, char*);
extern int	flushimage(Display*, int);
extern int	freeimage(Image*);
extern int	_freeimage1(Image*);
extern int	geninitdraw(char*, void(*)(Display*, char*), char*, char*, char*, int);
extern int	initdraw(void(*)(Display*, char*), char*, char*);
extern int	newwindow(char*);
extern Display*	initdisplay(char*, char*, void(*)(Display*, char*));
extern int	loadimage(Image*, Rectangle, uchar*, int);
extern int	cloadimage(Image*, Rectangle, uchar*, int);
extern int	getwindow(Display*, int);
extern int	gengetwindow(Display*, char*, Image**, Screen**, int);
extern Image* readimage(Display*, int, int);
extern Image* creadimage(Display*, int, int);
extern int	unloadimage(Image*, Rectangle, uchar*, int);
extern int	wordsperline(Rectangle, int);
extern int	writeimage(int, Image*, int);
extern Image*	namedimage(Display*, char*);
extern int	nameimage(Image*, char*, int);
extern Image* allocimagemix(Display*, ulong, ulong);

/*
 * Colors
 */
extern	void	readcolmap(Display*, RGB*);
extern	void	writecolmap(Display*, RGB*);
extern	ulong	setalpha(ulong, uchar);

/*
 * Windows
 */
extern Screen*	allocscreen(Image*, Image*, int);
extern Image*	_allocwindow(Image*, Screen*, Rectangle, int, ulong);
extern Image*	allocwindow(Screen*, Rectangle, int, ulong);
extern void	bottomnwindows(Image**, int);
extern void	bottomwindow(Image*);
extern int	freescreen(Screen*);
extern Screen*	publicscreen(Display*, int, ulong);
extern void	topnwindows(Image**, int);
extern void	topwindow(Image*);
extern int	originwindow(Image*, Point, Point);

/*
 * Geometry
 */
extern Point		Pt(int, int);
extern Rectangle	Rect(int, int, int, int);
extern Rectangle	Rpt(Point, Point);
extern Point		addpt(Point, Point);
extern Point		subpt(Point, Point);
extern Point		divpt(Point, int);
extern Point		mulpt(Point, int);
extern int		eqpt(Point, Point);
extern int		eqrect(Rectangle, Rectangle);
extern Rectangle	insetrect(Rectangle, int);
extern Rectangle	rectaddpt(Rectangle, Point);
extern Rectangle	rectsubpt(Rectangle, Point);
extern Rectangle	canonrect(Rectangle);
extern int		rectXrect(Rectangle, Rectangle);
extern int		rectinrect(Rectangle, Rectangle);
extern void		combinerect(Rectangle*, Rectangle);
extern int		rectclip(Rectangle*, Rectangle);
extern int		ptinrect(Point, Rectangle);
extern void		replclipr(Image*, int, Rectangle);
extern int		drawreplxy(int, int, int);	/* used to be drawsetxy */
extern Point	drawrepl(Rectangle, Point);
extern int		rgb2cmap(int, int, int);
extern int		cmap2rgb(int);
extern int		cmap2rgba(int);
extern void		icossin(int, int*, int*);
extern void		icossin2(int, int, int*, int*);

/*
 * Graphics
 */
extern void	draw(Image*, Rectangle, Image*, Image*, Point);
extern void	drawop(Image*, Rectangle, Image*, Image*, Point, Drawop);
extern void	gendraw(Image*, Rectangle, Image*, Point, Image*, Point);
extern void	gendrawop(Image*, Rectangle, Image*, Point, Image*, Point, Drawop);
extern void	line(Image*, Point, Point, int, int, int, Image*, Point);
extern void	lineop(Image*, Point, Point, int, int, int, Image*, Point, Drawop);
extern void	poly(Image*, Point*, int, int, int, int, Image*, Point);
extern void	polyop(Image*, Point*, int, int, int, int, Image*, Point, Drawop);
extern void	fillpoly(Image*, Point*, int, int, Image*, Point);
extern void	fillpolyop(Image*, Point*, int, int, Image*, Point, Drawop);
extern Point	string(Image*, Point, Image*, Point, Font*, char*);
extern Point	stringop(Image*, Point, Image*, Point, Font*, char*, Drawop);
extern Point	stringn(Image*, Point, Image*, Point, Font*, char*, int);
extern Point	stringnop(Image*, Point, Image*, Point, Font*, char*, int, Drawop);
extern Point	runestring(Image*, Point, Image*, Point, Font*, Rune*);
extern Point	runestringop(Image*, Point, Image*, Point, Font*, Rune*, Drawop);
extern Point	runestringn(Image*, Point, Image*, Point, Font*, Rune*, int);
extern Point	runestringnop(Image*, Point, Image*, Point, Font*, Rune*, int, Drawop);
extern Point	stringbg(Image*, Point, Image*, Point, Font*, char*, Image*, Point);
extern Point	stringbgop(Image*, Point, Image*, Point, Font*, char*, Image*, Point, Drawop);
extern Point	stringnbg(Image*, Point, Image*, Point, Font*, char*, int, Image*, Point);
extern Point	stringnbgop(Image*, Point, Image*, Point, Font*, char*, int, Image*, Point, Drawop);
extern Point	runestringbg(Image*, Point, Image*, Point, Font*, Rune*, Image*, Point);
extern Point	runestringbgop(Image*, Point, Image*, Point, Font*, Rune*, Image*, Point, Drawop);
extern Point	runestringnbg(Image*, Point, Image*, Point, Font*, Rune*, int, Image*, Point);
extern Point	runestringnbgop(Image*, Point, Image*, Point, Font*, Rune*, int, Image*, Point, Drawop);
extern Point	_string(Image*, Point, Image*, Point, Font*, char*, Rune*, int, Rectangle, Image*, Point, Drawop);
extern Point	stringsubfont(Image*, Point, Image*, Subfont*, char*);
extern int		bezier(Image*, Point, Point, Point, Point, int, int, int, Image*, Point);
extern int		bezierop(Image*, Point, Point, Point, Point, int, int, int, Image*, Point, Drawop);
extern int		bezspline(Image*, Point*, int, int, int, int, Image*, Point);
extern int		bezsplineop(Image*, Point*, int, int, int, int, Image*, Point, Drawop);
extern int		bezsplinepts(Point*, int, Point**);
extern int		fillbezier(Image*, Point, Point, Point, Point, int, Image*, Point);
extern int		fillbezierop(Image*, Point, Point, Point, Point, int, Image*, Point, Drawop);
extern int		fillbezspline(Image*, Point*, int, int, Image*, Point);
extern int		fillbezsplineop(Image*, Point*, int, int, Image*, Point, Drawop);
extern void	ellipse(Image*, Point, int, int, int, Image*, Point);
extern void	ellipseop(Image*, Point, int, int, int, Image*, Point, Drawop);
extern void	fillellipse(Image*, Point, int, int, Image*, Point);
extern void	fillellipseop(Image*, Point, int, int, Image*, Point, Drawop);
extern void	arc(Image*, Point, int, int, int, Image*, Point, int, int);
extern void	arcop(Image*, Point, int, int, int, Image*, Point, int, int, Drawop);
extern void	fillarc(Image*, Point, int, int, Image*, Point, int, int);
extern void	fillarcop(Image*, Point, int, int, Image*, Point, int, int, Drawop);
extern void	border(Image*, Rectangle, int, Image*, Point);
extern void	borderop(Image*, Rectangle, int, Image*, Point, Drawop);

/*
 * Font management
 */
extern Font*	openfont(Display*, char*);
extern Font*	buildfont(Display*, char*, char*);
extern void	freefont(Font*);
extern Font*	mkfont(Subfont*, Rune);
extern int	cachechars(Font*, char**, Rune**, ushort*, int, int*, char**);
extern void	agefont(Font*);
extern Subfont*	allocsubfont(char*, int, int, int, Fontchar*, Image*);
extern Subfont*	lookupsubfont(Display*, char*);
extern void	installsubfont(char*, Subfont*);
extern void	uninstallsubfont(Subfont*);
extern void	freesubfont(Subfont*);
extern Subfont*	readsubfont(Display*, char*, int, int);
extern Subfont*	readsubfonti(Display*, char*, int, Image*, int);
extern int	writesubfont(int, Subfont*);
extern void	_unpackinfo(Fontchar*, uchar*, int);
extern Point	stringsize(Font*, char*);
extern int	stringwidth(Font*, char*);
extern int	stringnwidth(Font*, char*, int);
extern Point	runestringsize(Font*, Rune*);
extern int	runestringwidth(Font*, Rune*);
extern int	runestringnwidth(Font*, Rune*, int);
extern Point	strsubfontwidth(Subfont*, char*);
extern int	loadchar(Font*, Rune, Cacheinfo*, int, int, char**);
extern char*	subfontname(char*, char*, int);
extern Subfont*	_getsubfont(Display*, char*);
extern Subfont*	getdefont(Display*);
extern void		lockdisplay(Display*);
extern void	unlockdisplay(Display*);
extern int		drawlsetrefresh(ulong, int, void*, void*);

/*
 * Predefined 
 */
extern	uchar	defontdata[];
extern	int		sizeofdefont;
extern	Point		ZP;
extern	Rectangle	ZR;

/*
 * Set up by initdraw()
 */
extern	Display	*display;
extern	Font		*font;
extern	Image	*screen;
extern	Screen	*_screen;
extern	int	_cursorfd;
extern	int	_drawdebug;	/* set to 1 to see errors from flushimage */
extern	void	_setdrawop(Display*, Drawop);

<<function BGSHORT>>
<<function BGLONG>>
<<function BPSHORT>>
<<function BPLONG>>

<<constant NMATCH>>
<<constant NRUN>>
<<constant NMEM>>
<<constant NDUMP>>
<<constant NCBLOCK>>
extern	void	_twiddlecompressed(uchar*, int);
extern	int	_compblocksize(Rectangle, int);

/* XXX backwards helps; should go */
// extern	int		log2[];	/* was used by libmemlayer/line.c */
extern	ulong	drawld2chan[];
extern	void		drawsetdebug(int);
@


\subsection*{[[include/event.h]]}

<<enum _anon_ (include/event.h)>>=
enum
{
    Emouse		= 1,
    Ekeyboard	= 2,
};
@

<<enum _anon_ (include/event.h)2>>=
enum
{
    MAXSLAVE = 32,
    EMAXMSG = 128+8192,	/* size of 9p header+data */
};
@

<<struct Mouse>>=
struct	Mouse
{
    int	buttons;	/* bit array: LMR=124 */
    Point	xy;
    ulong	msec;
};
@

<<struct Event>>=
struct	Event
{
    int	kbdc;
    Mouse	mouse;
    int	n;		/* number of characters in message */
    void	*v;		/* data unpacked by general event-handling function */
    uchar	data[EMAXMSG];	/* message from an arbitrary file descriptor */
};
@

<<struct Menu>>=
struct Menu
{
    char	**item;
    char	*(*gen)(int);
    int	lasthit;
};
@


%-------------------------------------------------------------

<<include/event.h>>=
#pragma src "/sys/src/libdraw"
#pragma lib "libdraw.a"

typedef struct	Cursor Cursor;
typedef struct	Event Event;
typedef struct	Menu Menu;

<<enum _anon_ (include/event.h)>>

<<enum _anon_ (include/event.h)2>>

<<struct Mouse>>

<<struct Event>>

<<struct Menu>>

/*
 * Events
 */
extern void	 einit(ulong);
extern ulong	 estart(ulong, int, int);
extern ulong	 estartfn(ulong, int, int, int (*fn)(int, Event*, uchar*, int));
extern ulong	 etimer(ulong, int);
extern ulong	 event(Event*);
extern ulong	 eread(ulong, Event*);
extern Mouse	 emouse(void);
extern int	 ekbd(void);
extern int	 ecanread(ulong);
extern int	 ecanmouse(void);
extern int	 ecankbd(void);
//ugly!!!
extern void	 eresized(int);	/* supplied by user */
extern int	 emenuhit(int, Mouse*, Menu*);
extern int	eatomouse(Mouse*, char*, int);
extern Rectangle	getrect(int, Mouse*);
extern void	 esetcursor(Cursor*);
extern void	 emoveto(Point);
extern Rectangle	egetrect(int, Mouse*);
extern void		edrawgetrect(Rectangle, int);
extern int		ereadmouse(Mouse*);
extern int		eatomouse(Mouse*, char*, int);
@


\subsection*{[[include/frame.h]]}

<<enum _anon_ (include/frame.h)>>=
enum{
    BACK,
    HIGH,
    BORD,
    TEXT,
    HTEXT,
    NCOL
};
@

<<constant FRTICKW>>=
#define	FRTICKW	3
@

<<struct Frbox>>=
struct Frbox
{
    long		wid;		/* in pixels */
    long		nrune;		/* <0 ==> negate and treat as break char */
    union{
        uchar	*ptr;
        struct{
            short	bc;	/* break char */
            short	minwid;
        };
    };
};
@

<<struct Frame>>=
struct Frame
{
    Font		*font;		/* of chars in the frame */
    Display		*display;	/* on which frame appears */
    Image		*b;		/* on which frame appears */
    Image		*cols[NCOL];	/* text and background colors */
    Rectangle	r;		/* in which text appears */
    Rectangle	entire;		/* of full frame */
    void			(*scroll)(Frame*, int);	/* scroll function provided by application */
    Frbox		*box;
    ulong		p0, p1;		/* selection */
    ushort		nbox, nalloc;
    ushort		maxtab;		/* max size of tab, in pixels */
    ushort		nchars;		/* # runes in frame */
    ushort		nlines;		/* # lines with text */
    ushort		maxlines;	/* total # lines in frame */
    ushort		lastlinefull;	/* last line fills frame */
    ushort		modified;	/* changed since frselect() */
    Image		*tick;	/* typing tick */
    Image		*tickback;	/* saved image under tick */
    int			ticked;	/* flag: is tick onscreen? */
};
@

<<function NRUNE>>=
#define	NRUNE(b)	((b)->nrune<0? 1 : (b)->nrune)
@

<<function NBYTE>>=
#define	NBYTE(b)	strlen((char*)(b)->ptr)
@


%-------------------------------------------------------------

<<include/frame.h>>=
#pragma	src	"/sys/src/libframe"
#pragma	lib	"libframe.a"

typedef struct Frbox Frbox;
typedef struct Frame Frame;

<<enum _anon_ (include/frame.h)>>

<<constant FRTICKW>>

<<struct Frbox>>

<<struct Frame>>

ulong	frcharofpt(Frame*, Point);
Point	frptofchar(Frame*, ulong);
int	frdelete(Frame*, ulong, ulong);
void	frinsert(Frame*, Rune*, Rune*, ulong);
void	frselect(Frame*, Mousectl*);
void	frselectpaint(Frame*, Point, Point, Image*);
void	frdrawsel(Frame*, Point, ulong, ulong, int);
Point frdrawsel0(Frame*, Point, ulong, ulong, Image*, Image*);
void	frinit(Frame*, Rectangle, Font*, Image*, Image**);
void	frsetrects(Frame*, Rectangle, Image*);
void	frclear(Frame*, int);

uchar	*_frallocstr(Frame*, unsigned);
void	_frinsure(Frame*, int, unsigned);
Point	_frdraw(Frame*, Point);
void	_frgrowbox(Frame*, int);
void	_frfreebox(Frame*, int, int);
void	_frmergebox(Frame*, int);
void	_frdelbox(Frame*, int, int);
void	_frsplitbox(Frame*, int, int);
int	_frfindbox(Frame*, int, ulong, ulong);
void	_frclosebox(Frame*, int, int);
int	_frcanfit(Frame*, Point, Frbox*);
void	_frcklinewrap(Frame*, Point*, Frbox*);
void	_frcklinewrap0(Frame*, Point*, Frbox*);
void	_fradvance(Frame*, Point*, Frbox*);
int	_frnewwid(Frame*, Point, Frbox*);
int	_frnewwid0(Frame*, Point, Frbox*);
void	_frclean(Frame*, Point, int, int);
void	_frdrawtext(Frame*, Point, Image*, Image*);
void	_fraddbox(Frame*, int, int);
Point	_frptofcharptb(Frame*, ulong, Point, int);
Point	_frptofcharnb(Frame*, ulong, int);
int	_frstrlen(Frame*, int);
void	frtick(Frame*, Point, int);
void	frinittick(Frame*);
void	frredraw(Frame*);

<<function NRUNE>>
<<function NBYTE>>
@


\subsection*{[[include/keyboard.h]]}

<<struct Keyboardctl>>=
struct	Keyboardctl
{
    Channel	*c;	/* chan(Rune)[20] */

    char		*file;
    int		consfd;		/* to cons file */
    int		ctlfd;		/* to ctl file */
    int		pid;		/* of slave proc */
};
@

<<enum _anon_ (include/keyboard.h)>>=
enum {
    KF=	0xF000,	/* Rune: beginning of private Unicode space */
    Spec=	0xF800,
    /* KF|1, KF|2, ..., KF|0xC is F1, F2, ..., F12 */
    Khome=	KF|0x0D,
    Kup=	KF|0x0E,
    Kpgup=	KF|0x0F,
    Kprint=	KF|0x10,
    Kleft=	KF|0x11,
    Kright=	KF|0x12,
    Kdown=	Spec|0x00,
    Kview=	Spec|0x00,
    Kpgdown=	KF|0x13,
    Kins=	KF|0x14,
    Kend=	KF|0x18,

    Kalt=		KF|0x15,
    Kshift=	KF|0x16,
    Kctl=		KF|0x17,

    Kbs=	0x08,
    Kdel=	0x7f,
    Kesc=	0x1b,
    Keof=	0x04,
};
@


%-------------------------------------------------------------

<<include/keyboard.h>>=
#pragma src "/sys/src/libdraw"
#pragma lib "libdraw.a"

typedef struct 	Keyboardctl Keyboardctl;
typedef struct	Channel	Channel;

<<struct Keyboardctl>>


extern	Keyboardctl*	initkeyboard(char*);
extern	int		ctlkeyboard(Keyboardctl*, char*);
extern	void		closekeyboard(Keyboardctl*);

<<enum _anon_ (include/keyboard.h)>>
@


\subsection*{[[include/memdraw.h]]}

<<struct Memdata>>=
/*
 * Memdata is allocated from main pool, but .data from the image pool.
 * Memdata is allocated separately to permit patching its pointer after
 * compaction when windows share the image data.
 * The first word of data is a back pointer to the Memdata, to find
 * The word to patch.
 */

struct Memdata
{
    ulong	*base;	/* allocated data pointer */
    uchar	*bdata;	/* pointer to first byte of actual data; word-aligned */
    int		ref;		/* number of Memimages using this data */
    void*	imref;
    int		allocd;	/* is this malloc'd? */
};
@

<<enum _anon_ (include/memdraw.h)>>=
enum {
    Frepl		= 1<<0,	/* is replicated */
    Fsimple	= 1<<1,	/* is 1x1 */
    Fgrey	= 1<<2,	/* is grey */
    Falpha	= 1<<3,	/* has explicit alpha */
    Fcmap	= 1<<4,	/* has cmap channel */
    Fbytes	= 1<<5,	/* has only 8-bit channels */
};
@

<<struct Memimage>>=
struct Memimage
{
    Rectangle	r;		/* rectangle in data area, local coords */
    Rectangle	clipr;		/* clipping region */
    int		depth;	/* number of bits of storage per pixel */
    int		nchan;	/* number of channels */
    ulong	chan;	/* channel descriptions */
    Memcmap	*cmap;

    Memdata	*data;	/* pointer to data; shared by windows in this image */
    int		zero;		/* data->bdata+zero==&byte containing (0,0) */
    ulong	width;	/* width in words of a single scan line */
    Memlayer	*layer;	/* nil if not a layer*/
    ulong	flags;

    int		shift[NChan];
    int		mask[NChan];
    int		nbits[NChan];
};
@

<<struct Memcmap>>=
struct Memcmap
{
    uchar	cmap2rgb[3*256];
    uchar	rgb2cmap[16*16*16];
};
@

<<struct Memsubfont>>=
/*
 * Subfonts
 *
 * given char c, Subfont *f, Fontchar *i, and Point p, one says
 *	i = f->info+c;
 *	draw(b, Rect(p.x+i->left, p.y+i->top,
 *		p.x+i->left+((i+1)->x-i->x), p.y+i->bottom),
 *		color, f->bits, Pt(i->x, i->top));
 *	p.x += i->width;
 * to draw characters in the specified color (itself a Memimage) in Memimage b.
 */

struct	Memsubfont
{
    char		*name;
    short	n;		/* number of chars in font */
    uchar	height;		/* height of bitmap */
    char	ascent;		/* top of bitmap to baseline */
    Fontchar *info;		/* n+1 character descriptors */
    Memimage	*bits;		/* of font */
};
@

<<enum _anon_ (include/memdraw.h)2>>=
/*
 * Encapsulated parameters and information for sub-draw routines.
 */
enum {
    Simplesrc=1<<0,
    Simplemask=1<<1,
    Replsrc=1<<2,
    Replmask=1<<3,
    Fullmask=1<<4,
};
@

<<struct Memdrawparam>>=
struct	Memdrawparam
{
    Memimage *dst;
    Rectangle	r;
    Memimage *src;
    Rectangle sr;
    Memimage *mask;
    Rectangle mr;
    int op;

    ulong state;
    ulong mval;	/* if Simplemask, the mask pixel in mask format */
    ulong mrgba;	/* mval in rgba */
    ulong sval;	/* if Simplesrc, the source pixel in src format */
    ulong srgba;	/* sval in rgba */
    ulong sdval;	/* sval in dst format */
};
@


%-------------------------------------------------------------

<<include/memdraw.h>>=
#pragma	src	"/sys/src/libmemdraw"
#pragma	lib	"libmemdraw.a"

typedef struct	Memimage Memimage;
typedef struct	Memdata Memdata;
typedef struct	Memsubfont Memsubfont;
typedef struct	Memlayer Memlayer;
typedef struct	Memcmap Memcmap;
typedef struct	Memdrawparam	Memdrawparam;

#pragma incomplete Memlayer

<<struct Memdata>>

<<enum _anon_ (include/memdraw.h)>>

<<struct Memimage>>

<<struct Memcmap>>

<<struct Memsubfont>>

<<enum _anon_ (include/memdraw.h)2>>
<<struct Memdrawparam>>

/*
 * Memimage management
 */

extern Memimage*	allocmemimage(Rectangle, ulong);
extern Memimage*	allocmemimaged(Rectangle, ulong, Memdata*);
extern Memimage*	readmemimage(int);
extern Memimage*	creadmemimage(int);
extern int	writememimage(int, Memimage*);
extern void	freememimage(Memimage*);
extern int		loadmemimage(Memimage*, Rectangle, uchar*, int);
extern int		cloadmemimage(Memimage*, Rectangle, uchar*, int);
extern int		unloadmemimage(Memimage*, Rectangle, uchar*, int);
extern ulong*	wordaddr(Memimage*, Point);
extern uchar*	byteaddr(Memimage*, Point);
extern int		drawclip(Memimage*, Rectangle*, Memimage*, Point*, Memimage*, Point*, Rectangle*, Rectangle*);
extern void	memfillcolor(Memimage*, ulong);
extern int		memsetchan(Memimage*, ulong);

/*
 * Graphics
 */
extern void	memdraw(Memimage*, Rectangle, Memimage*, Point, Memimage*, Point, int);
extern void	memline(Memimage*, Point, Point, int, int, int, Memimage*, Point, int);
extern void	mempoly(Memimage*, Point*, int, int, int, int, Memimage*, Point, int);
extern void	memfillpoly(Memimage*, Point*, int, int, Memimage*, Point, int);
extern void	_memfillpolysc(Memimage*, Point*, int, int, Memimage*, Point, int, int, int, int);
extern void	memimagedraw(Memimage*, Rectangle, Memimage*, Point, Memimage*, Point, int);
extern int	hwdraw(Memdrawparam*);
extern void	memimageline(Memimage*, Point, Point, int, int, int, Memimage*, Point, int);
extern void	_memimageline(Memimage*, Point, Point, int, int, int, Memimage*, Point, Rectangle, int);
extern Point	memimagestring(Memimage*, Point, Memimage*, Point, Memsubfont*, char*);
extern void	memellipse(Memimage*, Point, int, int, int, Memimage*, Point, int);
extern void	memarc(Memimage*, Point, int, int, int, Memimage*, Point, int, int, int);
extern Rectangle	memlinebbox(Point, Point, int, int, int);
extern int	memlineendsize(int);
extern void	_memmkcmap(void);
extern void	memimageinit(void);

/*
 * Subfont management
 */
extern Memsubfont*	allocmemsubfont(char*, int, int, int, Fontchar*, Memimage*);
extern Memsubfont*	openmemsubfont(char*);
extern void	freememsubfont(Memsubfont*);
extern Point	memsubfontwidth(Memsubfont*, char*);
extern Memsubfont*	getmemdefont(void);

/*
 * Predefined 
 */
extern	Memimage*	memwhite;
extern	Memimage*	memblack;
extern	Memimage*	memopaque;
extern	Memimage*	memtransparent;
extern	Memcmap	*memdefcmap;

/*
 * Kernel interface
 */
void		memimagemove(void*, void*);

/*
 * Kernel cruft
 */
extern void	rdb(void);
extern int		(*iprint)(char*, ...);
#pragma varargck argpos iprint 1
extern int		drawdebug;

/*
 * doprint interface: numbconv bit strings
 */
#pragma varargck type "llb" vlong
#pragma varargck type "llb" uvlong
#pragma varargck type "lb" long
#pragma varargck type "lb" ulong
#pragma varargck type "b" int
#pragma varargck type "b" uint

@


\subsection*{[[include/memlayer.h]]}

<<struct Memscreen>>=
struct Memscreen
{
    Memimage	*frontmost;	/* frontmost layer on screen */
    Memimage	*rearmost;	/* rearmost layer on screen */
    Memimage	*image;		/* upon which all layers are drawn */
    Memimage	*fill;			/* if non-zero, picture to use when repainting */
};
@

<<struct Memlayer>>=
struct Memlayer
{
    Rectangle		screenr;	/* true position of layer on screen */
    Point			delta;	/* add delta to go from image coords to screen */
    Memscreen	*screen;	/* screen this layer belongs to */
    Memimage	*front;	/* window in front of this one */
    Memimage	*rear;	/* window behind this one*/
    int		clear;	/* layer is fully visible */
    Memimage	*save;	/* save area for obscured parts */
    Refreshfn	refreshfn;		/* function to call to refresh obscured parts if save==nil */
    void		*refreshptr;	/* argument to refreshfn */
};
@


%-------------------------------------------------------------

<<include/memlayer.h>>=
#pragma src "/sys/src/libmemlayer"
#pragma lib "libmemlayer.a"

typedef struct Memscreen Memscreen;
typedef void (*Refreshfn)(Memimage*, Rectangle, void*);

<<struct Memscreen>>

<<struct Memlayer>>

/*
 * These functions accept local coordinates
 */
int			memload(Memimage*, Rectangle, uchar*, int, int);
int			memunload(Memimage*, Rectangle, uchar*, int);

/*
 * All these functions accept screen coordinates, not local ones.
 */
void			_memlayerop(void (*fn)(Memimage*, Rectangle, Rectangle, void*, int), Memimage*, Rectangle, Rectangle, void*);
Memimage*	memlalloc(Memscreen*, Rectangle, Refreshfn, void*, ulong);
void			memldelete(Memimage*);
void			memlfree(Memimage*);
void			memltofront(Memimage*);
void			memltofrontn(Memimage**, int);
void			_memltofrontfill(Memimage*, int);
void			memltorear(Memimage*);
void			memltorearn(Memimage**, int);
int			memlsetrefresh(Memimage*, Refreshfn, void*);
void			memlhide(Memimage*, Rectangle);
void			memlexpose(Memimage*, Rectangle);
void			_memlsetclear(Memscreen*);
int			memlorigin(Memimage*, Point, Point);
void			memlnorefresh(Memimage*, Rectangle, void*);
@


\subsection*{[[include/mouse.h]]}

<<struct Mouse (include/mouse.h)>>=
struct	Mouse
{
    int	buttons;	/* bit array: LMR=124 */
    Point	xy;
    ulong	msec;
};
@

<<struct Mousectl>>=
struct Mousectl
{
    Mouse;
    Channel	*c;	/* chan(Mouse) */
    Channel	*resizec;	/* chan(int)[2] */
            /* buffered in case client is waiting for a mouse action before handling resize */

    char		*file;
    int		mfd;		/* to mouse file */
    int		cfd;		/* to cursor file */
    int		pid;		/* of slave proc */
    Image*	image;	/* of associated window/display */
};
@

<<struct Menu (include/mouse.h)>>=
struct Menu
{
    char	**item;
    char	*(*gen)(int);
    int	lasthit;
};
@


%-------------------------------------------------------------

<<include/mouse.h>>=
#pragma src "/sys/src/libdraw"

typedef struct	Channel Channel;
typedef struct	Cursor Cursor;
typedef struct	Menu Menu;
typedef struct 	Mousectl Mousectl;

<<struct Mouse (include/mouse.h)>>

<<struct Mousectl>>

<<struct Menu (include/mouse.h)>>

/*
 * Mouse
 */
extern Mousectl*	initmouse(char*, Image*);
extern void		moveto(Mousectl*, Point);
extern int			readmouse(Mousectl*);
extern void		closemouse(Mousectl*);
extern void		setcursor(Mousectl*, Cursor*);
extern void		drawgetrect(Rectangle, int);
extern Rectangle	getrect(int, Mousectl*);
extern int	 		menuhit(int, Mousectl*, Menu*, Screen*);
@


\subsection*{[[include/plumb.h]]}

<<struct Plumbmsg>>=
struct Plumbmsg
{
    char		*src;
    char		*dst;
    char		*wdir;
    char		*type;
    Plumbattr	*attr;
    int		ndata;
    char		*data;
};
@

<<struct Plumbattr>>=
struct Plumbattr
{
    char		*name;
    char		*value;
    Plumbattr	*next;
};
@


%-------------------------------------------------------------

<<include/plumb.h>>=
#pragma	lib	"libplumb.a"
#pragma	src	"/sys/src/libplumb"

/*
 * Message format:
 *	source application\n
 *	destination port\n
 *	working directory\n
 *	type\n
 *	attributes\n
 *	nbytes\n
 *	n bytes of data
 */

typedef struct Plumbattr Plumbattr;
typedef struct Plumbmsg Plumbmsg;

<<struct Plumbmsg>>

<<struct Plumbattr>>

int			plumbsend(int, Plumbmsg*);
int			plumbsendtext(int, char*, char*, char*, char*);
Plumbmsg*	plumbrecv(int);
char*		plumbpack(Plumbmsg*, int*);
Plumbmsg*	plumbunpack(char*, int);
Plumbmsg*	plumbunpackpartial(char*, int, int*);
char*		plumbpackattr(Plumbattr*);
Plumbattr*	plumbunpackattr(char*);
Plumbattr*	plumbaddattr(Plumbattr*, Plumbattr*);
Plumbattr*	plumbdelattr(Plumbattr*, char*);
void			plumbfree(Plumbmsg*);
char*		plumblookup(Plumbattr*, char*);
int			plumbopen(char*, int);
int			eplumb(int, char*);
@


\section{[[lib_graphics/libdraw/]]}

\subsection*{[[lib_graphics/libdraw/alloc.c]]}

<<function allocimage>>=
Image*
allocimage(Display *d, Rectangle r, ulong chan, int repl, ulong val)
{
    Image*	i;

    i =  _allocimage(nil, d, r, chan, repl, val, 0, 0);
    if (i)
        setmalloctag(i, getcallerpc(&d));
    return i;
}
@

<<function _allocimage>>=
Image*
_allocimage(Image *ai, Display *d, Rectangle r, ulong chan, int repl, ulong val, int screenid, int refresh)
{
    uchar *a;
    char *err;
    Image *i;
    Rectangle clipr;
    int id;
    int depth;

    err = 0;
    i = 0;

    if(chan == 0){
        werrstr("bad channel descriptor");
        return nil;
    }

    depth = chantodepth(chan);
    if(depth == 0){
        err = "bad channel descriptor";
    Error:
        if(err)
            werrstr("allocimage: %s", err);
        else
            werrstr("allocimage: %r");
        free(i);
        return 0;
    }

    /* flush pending data so we don't get error allocating the image */
    flushimage(d, 0);
    a = bufimage(d, 1+4+4+1+4+1+4*4+4*4+4);
    if(a == 0)
        goto Error;
    d->imageid++;
    id = d->imageid;
    a[0] = 'b';
    BPLONG(a+1, id);
    BPLONG(a+5, screenid);
    a[9] = refresh;
    BPLONG(a+10, chan);
    a[14] = repl;
    BPLONG(a+15, r.min.x);
    BPLONG(a+19, r.min.y);
    BPLONG(a+23, r.max.x);
    BPLONG(a+27, r.max.y);
    if(repl)
        /* huge but not infinite, so various offsets will leave it huge, not overflow */
        clipr = Rect(-0x3FFFFFFF, -0x3FFFFFFF, 0x3FFFFFFF, 0x3FFFFFFF);
    else
        clipr = r;
    BPLONG(a+31, clipr.min.x);
    BPLONG(a+35, clipr.min.y);
    BPLONG(a+39, clipr.max.x);
    BPLONG(a+43, clipr.max.y);
    BPLONG(a+47, val);
    if(flushimage(d, 0) < 0)
        goto Error;

    if(ai)
        i = ai;
    else{
        i = malloc(sizeof(Image));
        if(i == nil){
            a = bufimage(d, 1+4);
            if(a){
                a[0] = 'f';
                BPLONG(a+1, id);
                flushimage(d, 0);
            }
            goto Error;
        }
    }
    i->display = d;
    i->id = id;
    i->depth = depth;
    i->chan = chan;
    i->r = r;
    i->clipr = clipr;
    i->repl = repl;
    i->screen = 0;
    i->next = 0;
    return i;
}
@

<<function namedimage>>=
Image*
namedimage(Display *d, char *name)
{
    uchar *a;
    char *err, buf[12*12+1];
    Image *i;
    int id, n;
    ulong chan;

    err = 0;
    i = 0;

    n = strlen(name);
    if(n >= 256){
        err = "name too long";
    Error:
        if(err)
            werrstr("namedimage: %s", err);
        else
            werrstr("namedimage: %r");
        if(i)
            free(i);
        return 0;
    }
    /* flush pending data so we don't get error allocating the image */
    flushimage(d, 0);
    a = bufimage(d, 1+4+1+n);
    if(a == 0)
        goto Error;
    d->imageid++;
    id = d->imageid;
    a[0] = 'n';
    BPLONG(a+1, id);
    a[5] = n;
    memmove(a+6, name, n);
    if(flushimage(d, 0) < 0)
        goto Error;

    if(pread(d->ctlfd, buf, sizeof buf, 0) < 12*12)
        goto Error;
    buf[12*12] = '\0';

    i = malloc(sizeof(Image));
    if(i == nil){
    Error1:
        a = bufimage(d, 1+4);
        if(a){
            a[0] = 'f';
            BPLONG(a+1, id);
            flushimage(d, 0);
        }
        goto Error;
    }
    i->display = d;
    i->id = id;
    if((chan=strtochan(buf+2*12))==0){
        werrstr("bad channel '%.12s' from devdraw", buf+2*12);
        goto Error1;
    }
    i->chan = chan;
    i->depth = chantodepth(chan);
    i->repl = atoi(buf+3*12);
    i->r.min.x = atoi(buf+4*12);
    i->r.min.y = atoi(buf+5*12);
    i->r.max.x = atoi(buf+6*12);
    i->r.max.y = atoi(buf+7*12);
    i->clipr.min.x = atoi(buf+8*12);
    i->clipr.min.y = atoi(buf+9*12);
    i->clipr.max.x = atoi(buf+10*12);
    i->clipr.max.y = atoi(buf+11*12);
    i->screen = 0;
    i->next = 0;
    return i;
}
@

<<function nameimage>>=
int
nameimage(Image *i, char *name, int in)
{
    uchar *a;
    int n;

    n = strlen(name);
    a = bufimage(i->display, 1+4+1+1+n);
    if(a == 0)
        return 0;
    a[0] = 'N';
    BPLONG(a+1, i->id);
    a[5] = in;
    a[6] = n;
    memmove(a+7, name, n);
    if(flushimage(i->display, 0) < 0)
        return 0;
    return 1;
}
@

<<function _freeimage1>>=
int
_freeimage1(Image *i)
{
    uchar *a;
    Display *d;
    Image *w;

    if(i == 0 || i->display == 0)
        return 0;
    /* make sure no refresh events occur on this if we block in the write */
    d = i->display;
    /* flush pending data so we don't get error deleting the image */
    flushimage(d, 0);
    a = bufimage(d, 1+4);
    if(a == 0)
        return -1;
    a[0] = 'f';
    BPLONG(a+1, i->id);
    if(i->screen){
        w = d->windows;
        if(w == i)
            d->windows = i->next;
        else
            while(w){
                if(w->next == i){
                    w->next = i->next;
                    break;
                }
                w = w->next;
            }
    }
    if(flushimage(d, i->screen!=0) < 0)
        return -1;

    return 0;
}
@

<<function freeimage>>=
int
freeimage(Image *i)
{
    int ret;

    ret = _freeimage1(i);
    free(i);
    return ret;
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/alloc.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function allocimage>>

<<function _allocimage>>

<<function namedimage>>

<<function nameimage>>

<<function _freeimage1>>

<<function freeimage>>
@


\subsection*{[[lib_graphics/libdraw/allocimagemix.c]]}

<<function allocimagemix>>=
Image*
allocimagemix(Display *d, ulong color1, ulong color3)
{
    Image *t, *b;
    static Image *qmask;

    if(qmask == nil)
        qmask = allocimage(d, Rect(0,0,1,1), GREY8, 1, 0x3F3F3FFF);
        
    if(d->screenimage->depth <= 8){	/* create a 2Ã—2 texture */
        t = allocimage(d, Rect(0,0,1,1), d->screenimage->chan, 0, color1);
        if(t == nil)
            return nil;

        b = allocimage(d, Rect(0,0,2,2), d->screenimage->chan, 1, color3);
        if(b == nil){
            freeimage(t);
            return nil;
        }

        draw(b, Rect(0,0,1,1), t, nil, ZP);
        freeimage(t);
        return b;
    }else{	/* use a solid color, blended using alpha */
        t = allocimage(d, Rect(0,0,1,1), d->screenimage->chan, 1, color1);
        if(t == nil)
            return nil;

        b = allocimage(d, Rect(0,0,1,1), d->screenimage->chan, 1, color3);
        if(b == nil){
            freeimage(t);
            return nil;
        }

        draw(b, b->r, t, qmask, ZP);
        freeimage(t);
        return b;
    }
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/allocimagemix.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function allocimagemix>>
@


\subsection*{[[lib_graphics/libdraw/arith.c]]}

<<function Pt>>=
Point
Pt(int x, int y)
{
    Point p;

    p.x = x;
    p.y = y;
    return p;
}
@

<<function Rect>>=
Rectangle
Rect(int x, int y, int bx, int by)
{
    Rectangle r;

    r.min.x = x;
    r.min.y = y;
    r.max.x = bx;
    r.max.y = by;
    return r;
}
@

<<function Rpt>>=
Rectangle
Rpt(Point min, Point max)
{
    Rectangle r;

    r.min = min;
    r.max = max;
    return r;
}
@

<<function addpt>>=
Point
addpt(Point a, Point b)
{
    a.x += b.x;
    a.y += b.y;
    return a;
}
@

<<function subpt>>=
Point
subpt(Point a, Point b)
{
    a.x -= b.x;
    a.y -= b.y;
    return a;
}
@

<<function insetrect>>=
Rectangle
insetrect(Rectangle r, int n)
{
    r.min.x += n;
    r.min.y += n;
    r.max.x -= n;
    r.max.y -= n;
    return r;
}
@

<<function divpt>>=
Point
divpt(Point a, int b)
{
    a.x /= b;
    a.y /= b;
    return a;
}
@

<<function mulpt>>=
Point
mulpt(Point a, int b)
{
    a.x *= b;
    a.y *= b;
    return a;
}
@

<<function rectsubpt>>=
Rectangle
rectsubpt(Rectangle r, Point p)
{
    r.min.x -= p.x;
    r.min.y -= p.y;
    r.max.x -= p.x;
    r.max.y -= p.y;
    return r;
}
@

<<function rectaddpt>>=
Rectangle
rectaddpt(Rectangle r, Point p)
{
    r.min.x += p.x;
    r.min.y += p.y;
    r.max.x += p.x;
    r.max.y += p.y;
    return r;
}
@

<<function eqpt>>=
int
eqpt(Point p, Point q)
{
    return p.x==q.x && p.y==q.y;
}
@

<<function eqrect>>=
int
eqrect(Rectangle r, Rectangle s)
{
    return r.min.x==s.min.x && r.max.x==s.max.x &&
           r.min.y==s.min.y && r.max.y==s.max.y;
}
@

<<function rectXrect>>=
int
rectXrect(Rectangle r, Rectangle s)
{
    return r.min.x<s.max.x && s.min.x<r.max.x &&
           r.min.y<s.max.y && s.min.y<r.max.y;
}
@

<<function rectinrect>>=
int
rectinrect(Rectangle r, Rectangle s)
{
    return s.min.x<=r.min.x && r.max.x<=s.max.x && s.min.y<=r.min.y && r.max.y<=s.max.y;
}
@

<<function ptinrect>>=
int
ptinrect(Point p, Rectangle r)
{
    return p.x>=r.min.x && p.x<r.max.x &&
           p.y>=r.min.y && p.y<r.max.y;
}
@

<<function canonrect>>=
Rectangle
canonrect(Rectangle r)
{
    int t;
    if (r.max.x < r.min.x) {
        t = r.min.x;
        r.min.x = r.max.x;
        r.max.x = t;
    }
    if (r.max.y < r.min.y) {
        t = r.min.y;
        r.min.y = r.max.y;
        r.max.y = t;
    }
    return r;
}
@

<<function combinerect>>=
void
combinerect(Rectangle *r1, Rectangle r2)
{
    if(r1->min.x > r2.min.x)
        r1->min.x = r2.min.x;
    if(r1->min.y > r2.min.y)
        r1->min.y = r2.min.y;
    if(r1->max.x < r2.max.x)
        r1->max.x = r2.max.x;
    if(r1->max.y < r2.max.y)
        r1->max.y = r2.max.y;
}
@

<<global drawld2chan>>=
ulong drawld2chan[] = {
    GREY1,
    GREY2,
    GREY4,
    CMAP8,
};
@

<<global log2>>=
/*
 * was used by libmemlayer/line.c; made static, instead of deleting it,
 * to avoid updating many binaries on sources.
 */
static int log2[] = { -1, 0, 1, -1, 2, -1, -1, -1, 3, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, 4 /* BUG */, -1, -1, -1, -1, -1, -1, -1, 5 };
@

<<function setalpha>>=
ulong
setalpha(ulong color, uchar alpha)
{
    int red, green, blue;

    red = (color >> 3*8) & 0xFF;
    green = (color >> 2*8) & 0xFF;
    blue = (color >> 1*8) & 0xFF;
    /* ignore incoming alpha */
    red = (red * alpha)/255;
    green = (green * alpha)/255;
    blue = (blue * alpha)/255;
    return (red<<3*8) | (green<<2*8) | (blue<<1*8) | (alpha<<0*8);
}
@

<<global ZP>>=
Point	ZP;
@

<<global ZR>>=
Rectangle ZR;
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/arith.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function Pt>>

<<function Rect>>

<<function Rpt>>

<<function addpt>>

<<function subpt>>

<<function insetrect>>

<<function divpt>>

<<function mulpt>>

<<function rectsubpt>>

<<function rectaddpt>>

<<function eqpt>>

<<function eqrect>>

<<function rectXrect>>

<<function rectinrect>>

<<function ptinrect>>

<<function canonrect>>

<<function combinerect>>

<<global drawld2chan>>

<<global log2>>

<<function setalpha>>

<<global ZP>>
<<global ZR>>
@


\subsection*{[[lib_graphics/libdraw/bezier.c]]}

<<constant PINC>>=
#define	PINC	32		/* realloc granularity */
@

<<struct Plist>>=
struct Plist
{
    Point *p;
    int np;			/* -1 if malloc/realloc failed */
};
@

<<function appendpt>>=
static void
appendpt(Plist *l, Point p)
{
    if(l->np == -1)
        return;
    if(l->np == 0)
        l->p = malloc(PINC*sizeof(Point));
    else if(l->np%PINC == 0)
        l->p = realloc(l->p, (l->np+PINC)*sizeof(Point));
    if(l->p == 0){
        l->np = -1;
        return;
    }
    l->p[l->np++] = p;
}
@

<<function normsq>>=
static int
normsq(Point p)
{
    return p.x*p.x+p.y*p.y;
}
@

<<function psdist>>=
static int
psdist(Point p, Point a, Point b)
{
    int num, den;

    p = subpt(p, a);
    b = subpt(b, a);
    num = p.x*b.x + p.y*b.y;
    if(num <= 0)
        return normsq(p);
    den = normsq(b);
    if(num >= den)
        return normsq(subpt(b, p));
    return normsq(subpt(divpt(mulpt(b, num), den), p));
}
@

<<function bpts1>>=
/*
 * Convert cubic Bezier curve control points to polyline
 * vertices.  Leaves the last vertex off, so you can continue
 * with another curve.
 */
static void
bpts1(Plist *l, Point p0, Point p1, Point p2, Point p3, int scale)
{
    Point p01, p12, p23, p012, p123, p0123;
    Point tp0, tp1, tp2, tp3;
    tp0=divpt(p0, scale);
    tp1=divpt(p1, scale);
    tp2=divpt(p2, scale);
    tp3=divpt(p3, scale);
    if(psdist(tp1, tp0, tp3)<=1 && psdist(tp2, tp0, tp3)<=1){
        appendpt(l, tp0);
        appendpt(l, tp1);
        appendpt(l, tp2);
    }
    else{
        /*
         * if scale factor is getting too big for comfort,
         * rescale now & concede the rounding error
         */
        if(scale>(1<<12)){
            p0=tp0;
            p1=tp1;
            p2=tp2;
            p3=tp3;
            scale=1;
        }
        p01=addpt(p0, p1);
        p12=addpt(p1, p2);
        p23=addpt(p2, p3);
        p012=addpt(p01, p12);
        p123=addpt(p12, p23);
        p0123=addpt(p012, p123);
        bpts1(l, mulpt(p0, 8), mulpt(p01, 4), mulpt(p012, 2), p0123, scale*8);
        bpts1(l, p0123, mulpt(p123, 2), mulpt(p23, 4), mulpt(p3, 8), scale*8);
    }
}
@

<<function bpts>>=
static void
bpts(Plist *l, Point p0, Point p1, Point p2, Point p3)
{
    bpts1(l, p0, p1, p2, p3, 1);
}
@

<<function bezierpts>>=
static void
bezierpts(Plist *l, Point p0, Point p1, Point p2, Point p3)
{
    bpts(l, p0, p1, p2, p3);
    appendpt(l, p3);
}
@

<<function _bezsplinepts>>=
static void
_bezsplinepts(Plist *l, Point *pt, int npt)
{
    Point *p, *ep;
    Point a, b, c, d;
    int periodic;

    if(npt<3)
        return;
    ep = &pt[npt-3];
    periodic = eqpt(pt[0], ep[2]);
    if(periodic){
        a = divpt(addpt(ep[1], pt[0]), 2);
        b = divpt(addpt(ep[1], mulpt(pt[0], 5)), 6);
        c = divpt(addpt(mulpt(pt[0], 5), pt[1]), 6);
        d = divpt(addpt(pt[0], pt[1]), 2);
        bpts(l, a, b, c, d);
    }
    for(p=pt; p<=ep; p++){
        if(p==pt && !periodic){
            a = p[0];
            b = divpt(addpt(p[0], mulpt(p[1], 2)), 3);
        }
        else{
            a = divpt(addpt(p[0], p[1]), 2);
            b = divpt(addpt(p[0], mulpt(p[1], 5)), 6);
        }
        if(p==ep && !periodic){
            c = divpt(addpt(mulpt(p[1], 2), p[2]), 3);
            d = p[2];
        }
        else{
            c = divpt(addpt(mulpt(p[1], 5), p[2]), 6);
            d = divpt(addpt(p[1], p[2]), 2);
        }
        bpts(l, a, b, c, d);
    }
    appendpt(l, d);
}
@

<<function bezsplinepts>>=
int
bezsplinepts(Point *pt, int npt, Point **pp)
{
    Plist l;
    l.np = 0;
    l.p = nil;
    _bezsplinepts(&l, pt, npt);
    *pp  = l.p;
    return l.np;
}
@

<<function bezier>>=
int
bezier(Image *dst, Point p0, Point p1, Point p2, Point p3, int end0, int end1, int radius, Image *src, Point sp)
{
    return bezierop(dst, p0, p1, p2, p3, end0, end1, radius, src, sp, SoverD);
}
@

<<function bezierop>>=
int
bezierop(Image *dst, Point p0, Point p1, Point p2, Point p3, int end0, int end1, int radius, Image *src, Point sp, Drawop op)
{
    Plist l;

    l.np = 0;
    bezierpts(&l, p0, p1, p2, p3);
    if(l.np == -1)
        return 0;
    if(l.np != 0){
        polyop(dst, l.p, l.np, end0, end1, radius, src, addpt(subpt(sp, p0), l.p[0]), op);
        free(l.p);
    }
    return 1;
}
@

<<function bezspline>>=
int
bezspline(Image *dst, Point *pt, int npt, int end0, int end1, int radius, Image *src, Point sp)
{
    return bezsplineop(dst, pt, npt, end0, end1, radius, src, sp, SoverD);
}
@

<<function bezsplineop>>=
int
bezsplineop(Image *dst, Point *pt, int npt, int end0, int end1, int radius, Image *src, Point sp, Drawop op)
{
    Plist l;

    l.np = 0;
    _bezsplinepts(&l, pt, npt);
    if(l.np==-1)
        return 0;
    if(l.np != 0){
        polyop(dst, l.p, l.np, end0, end1, radius, src, addpt(subpt(sp, pt[0]), l.p[0]), op);
        free(l.p);
    }
    return 1;
}
@

<<function fillbezier>>=
int
fillbezier(Image *dst, Point p0, Point p1, Point p2, Point p3, int w, Image *src, Point sp)
{
    return fillbezierop(dst, p0, p1, p2, p3, w, src, sp, SoverD);
}
@

<<function fillbezierop>>=
int
fillbezierop(Image *dst, Point p0, Point p1, Point p2, Point p3, int w, Image *src, Point sp, Drawop op)
{
    Plist l;

    l.np = 0;
    bezierpts(&l, p0, p1, p2, p3);
    if(l.np == -1)
        return 0;
    if(l.np != 0){
        fillpolyop(dst, l.p, l.np, w, src, addpt(subpt(sp, p0), l.p[0]), op);
        free(l.p);
    }
    return 1;
}
@

<<function fillbezspline>>=
int
fillbezspline(Image *dst, Point *pt, int npt, int w, Image *src, Point sp)
{
    return fillbezsplineop(dst, pt, npt, w, src, sp, SoverD);
}
@

<<function fillbezsplineop>>=
int
fillbezsplineop(Image *dst, Point *pt, int npt, int w, Image *src, Point sp, Drawop op)
{
    Plist l;

    l.np = 0;
    _bezsplinepts(&l, pt, npt);
    if(l.np == -1)
        return 0;
    if(l.np > 0){
        fillpolyop(dst, l.p, l.np, w, src, addpt(subpt(sp, pt[0]), l.p[0]), op);
        free(l.p);
    }
    return 1;
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/bezier.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<constant PINC>>

typedef struct Plist Plist;
<<struct Plist>>

<<function appendpt>>

<<function normsq>>

<<function psdist>>

<<function bpts1>>

<<function bpts>>

<<function bezierpts>>

<<function _bezsplinepts>>

<<function bezsplinepts>>

<<function bezier>>

<<function bezierop>>

<<function bezspline>>

<<function bezsplineop>>

<<function fillbezier>>

<<function fillbezierop>>

<<function fillbezspline>>

<<function fillbezsplineop>>
@


\subsection*{[[lib_graphics/libdraw/border.c]]}

<<function border>>=
void
border(Image *im, Rectangle r, int i, Image *color, Point sp)
{
    if(i < 0){
        r = insetrect(r, i);
        sp = addpt(sp, Pt(i,i));
        i = -i;
    }
    draw(im, Rect(r.min.x, r.min.y, r.max.x, r.min.y+i),
        color, nil, sp);
    draw(im, Rect(r.min.x, r.max.y-i, r.max.x, r.max.y),
        color, nil, Pt(sp.x, sp.y+Dy(r)-i));
    draw(im, Rect(r.min.x, r.min.y+i, r.min.x+i, r.max.y-i),
        color, nil, Pt(sp.x, sp.y+i));
    draw(im, Rect(r.max.x-i, r.min.y+i, r.max.x, r.max.y-i),
        color, nil, Pt(sp.x+Dx(r)-i, sp.y+i));
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/border.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function border>>
@


\subsection*{[[lib_graphics/libdraw/buildfont.c]]}

<<function skip>>=
static char*
skip(char *s)
{
    while(*s==' ' || *s=='\n' || *s=='\t')
        s++;
    return s;
}
@

<<function buildfont>>=
Font*
buildfont(Display *d, char *buf, char *name)
{
    Font *fnt;
    Cachefont *c;
    char *s, *t;
    ulong min, max;
    int offset;
    char badform[] = "bad font format: number expected (char position %d)";

    s = buf;
    fnt = malloc(sizeof(Font));
    if(fnt == 0)
        return 0;
    memset(fnt, 0, sizeof(Font));
    fnt->display = d;
    fnt->name = strdup(name);
    fnt->ncache = NFCACHE+NFLOOK;
    fnt->nsubf = NFSUBF;
    fnt->cache = malloc(fnt->ncache * sizeof(fnt->cache[0]));
    fnt->subf = malloc(fnt->nsubf * sizeof(fnt->subf[0]));
    if(fnt->name==0 || fnt->cache==0 || fnt->subf==0){
    Err2:
        free(fnt->name);
        free(fnt->cache);
        free(fnt->subf);
        free(fnt->sub);
        free(fnt);
        return 0;
    }
    fnt->height = strtol(s, &s, 0);
    s = skip(s);
    fnt->ascent = strtol(s, &s, 0);
    s = skip(s);
    if(fnt->height<=0 || fnt->ascent<=0){
        werrstr("bad height or ascent in font file");
        goto Err2;
    }
    fnt->width = 0;
    fnt->nsub = 0;
    fnt->sub = 0;

    memset(fnt->subf, 0, fnt->nsubf * sizeof(fnt->subf[0]));
    memset(fnt->cache, 0, fnt->ncache*sizeof(fnt->cache[0]));
    fnt->age = 1;
    do{
        /* must be looking at a number now */
        if(*s<'0' || '9'<*s){
            werrstr(badform, s-buf);
            goto Err3;
        }
        min = strtol(s, &s, 0);
        s = skip(s);
        /* must be looking at a number now */
        if(*s<'0' || '9'<*s){
            werrstr(badform, s-buf);
            goto Err3;
        }
        max = strtol(s, &s, 0);
        s = skip(s);
        if(*s==0 || min>=Runemax || max>=Runemax || min>max){
            werrstr("illegal subfont range");
    Err3:
            freefont(fnt);
            return 0;
        }
        t = s;
        offset = strtol(s, &t, 0);
        if(t>s && (*t==' ' || *t=='\t' || *t=='\n'))
            s = skip(t);
        else
            offset = 0;
        fnt->sub = realloc(fnt->sub, (fnt->nsub+1)*sizeof(Cachefont*));
        if(fnt->sub == 0){
            /* realloc manual says fnt->sub may have been destroyed */
            fnt->nsub = 0;
            goto Err3;
        }
        c = malloc(sizeof(Cachefont));
        if(c == 0)
            goto Err3;
        fnt->sub[fnt->nsub] = c;
        c->min = min;
        c->max = max;
        c->offset = offset;
        t = s;
        while(*s && *s!=' ' && *s!='\n' && *s!='\t')
            s++;
        *s++ = 0;
        c->subfontname = 0;
        c->name = strdup(t);
        if(c->name == 0){
            free(c);
            goto Err3;
        }
        s = skip(s);
        fnt->nsub++;
    }while(*s);
    return fnt;
}
@

<<function freefont>>=
void
freefont(Font *f)
{
    int i;
    Cachefont *c;
    Subfont *s;

    if(f == 0)
        return;

    for(i=0; i<f->nsub; i++){
        c = f->sub[i];
        free(c->subfontname);
        free(c->name);
        free(c);
    }
    for(i=0; i<f->nsubf; i++){
        s = f->subf[i].f;
        if(s && display && s!=display->defaultsubfont)
            freesubfont(s);
    }
    freeimage(f->cacheimage);
    free(f->name);
    free(f->cache);
    free(f->subf);
    free(f->sub);
    free(f);
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/buildfont.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function skip>>

<<function buildfont>>

<<function freefont>>
@


\subsection*{[[lib_graphics/libdraw/bytesperline.c]]}

<<function unitsperline>>=
static
int
unitsperline(Rectangle r, int d, int bitsperunit)
{
    ulong l, t;

    if(d <= 0 || d > 32)	/* being called wrong.  d is image depth. */
        abort();

    if(r.min.x >= 0){
        l = (r.max.x*d+bitsperunit-1)/bitsperunit;
        l -= (r.min.x*d)/bitsperunit;
    }else{			/* make positive before divide */
        t = (-r.min.x*d+bitsperunit-1)/bitsperunit;
        l = t+(r.max.x*d+bitsperunit-1)/bitsperunit;
    }
    return l;
}
@

<<function wordsperline>>=
int
wordsperline(Rectangle r, int d)
{
    return unitsperline(r, d, 8*sizeof(ulong));
}
@

<<function bytesperline>>=
int
bytesperline(Rectangle r, int d)
{
    return unitsperline(r, d, 8);
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/bytesperline.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function unitsperline>>

<<function wordsperline>>

<<function bytesperline>>
@


\subsection*{[[lib_graphics/libdraw/chan.c]]}

<<global channames>>=
static char channames[] = "rgbkamx";
@

<<function chantostr>>=
char*
chantostr(char *buf, ulong cc)
{
    ulong c, rc;
    char *p;

    if(chantodepth(cc) == 0)
        return nil;

    /* reverse the channel descriptor so we can easily generate the string in the right order */
    rc = 0;
    for(c=cc; c; c>>=8){
        rc <<= 8;
        rc |= c&0xFF;
    }

    p = buf;
    for(c=rc; c; c>>=8) {
        *p++ = channames[TYPE(c)];
        *p++ = '0'+NBITS(c);
    }
    *p = 0;

    return buf;
}
@

<<function isspace>>=
/* avoid pulling in ctype when using with drawterm etc. */
static int
isspace(char c)
{
    return c==' ' || c== '\t' || c=='\r' || c=='\n';
}
@

<<function strtochan>>=
ulong
strtochan(char *s)
{
    char *p, *q;
    ulong c;
    int t, n, d;

    c = 0;
    d = 0;
    p=s;
    while(*p && isspace(*p))
        p++;

    while(*p && !isspace(*p)){
        if((q = strchr(channames, p[0])) == nil) 
            return 0;
        t = q-channames;
        if(p[1] < '0' || p[1] > '9')
            return 0;
        n = p[1]-'0';
        d += n;
        c = (c<<8) | __DC(t, n);
        p += 2;
    }
    if(d==0 || (d>8 && d%8) || (d<8 && 8%d))
        return 0;
    return c;
}
@

<<function chantodepth>>=
int
chantodepth(ulong c)
{
    int n;

    for(n=0; c; c>>=8){
        if(TYPE(c) >= NChan || NBITS(c) > 8 || NBITS(c) <= 0)
            return 0;
        n += NBITS(c);
    }
    if(n==0 || (n>8 && n%8) || (n<8 && 8%n))
        return 0;
    return n;
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/chan.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<global channames>>
<<function chantostr>>

<<function isspace>>

<<function strtochan>>

<<function chantodepth>>
@


\subsection*{[[lib_graphics/libdraw/cloadimage.c]]}

<<function cloadimage>>=
int
cloadimage(Image *i, Rectangle r, uchar *data, int ndata)
{
    int m, nb, miny, maxy, ncblock;
    uchar *a;

    if(!rectinrect(r, i->r)){
        werrstr("cloadimage: bad rectangle");
        return -1;
    }

    miny = r.min.y;
    m = 0;
    ncblock = _compblocksize(r, i->depth);
    while(miny != r.max.y){
        maxy = atoi((char*)data+0*12);
        nb = atoi((char*)data+1*12);
        if(maxy<=miny || r.max.y<maxy){
            werrstr("creadimage: bad maxy %d", maxy);
            return -1;
        }
        data += 2*12;
        ndata -= 2*12;
        m += 2*12;
        if(nb<=0 || ncblock<nb || nb>ndata){
            werrstr("creadimage: bad count %d", nb);
            return -1;
        }
        a = bufimage(i->display, 21+nb);
        if(a == nil)
            return -1;
        a[0] = 'Y';
        BPLONG(a+1, i->id);
        BPLONG(a+5, r.min.x);
        BPLONG(a+9, miny);
        BPLONG(a+13, r.max.x);
        BPLONG(a+17, maxy);
        memmove(a+21, data, nb);
        miny = maxy;
        data += nb;
        ndata += nb;
        m += nb;
    }
    return m;
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/cloadimage.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function cloadimage>>
@


\subsection*{[[lib_graphics/libdraw/computil.c]]}

<<function _twiddlecompressed>>=
/*
 * compressed data are seuences of byte codes.  
 * if the first byte b has the 0x80 bit set, the next (b^0x80)+1 bytes
 * are data.  otherwise, it's two bytes specifying a previous string to repeat.
 */
void
_twiddlecompressed(uchar *buf, int n)
{
    uchar *ebuf;
    int j, k, c;

    ebuf = buf+n;
    while(buf < ebuf){
        c = *buf++;
        if(c >= 128){
            k = c-128+1;
            for(j=0; j<k; j++, buf++)
                *buf ^= 0xFF;
        }else
            buf++;
    }
}
@

<<function _compblocksize>>=
int
_compblocksize(Rectangle r, int depth)
{
    int bpl;

    bpl = bytesperline(r, depth);
    bpl = 2*bpl;	/* add plenty extra for blocking, etc. */
    if(bpl < NCBLOCK)
        return NCBLOCK;
    return bpl;
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/computil.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function _twiddlecompressed>>

<<function _compblocksize>>
@


\subsection*{[[lib_graphics/libdraw/creadimage.c]]}

<<function creadimage>>=
Image *
creadimage(Display *d, int fd, int dolock)
{
    char hdr[5*12+1];
    Rectangle r;
    int m, nb, miny, maxy, new, ldepth, ncblock;
    uchar *buf, *a;
    Image *i;
    ulong chan;

    if(readn(fd, hdr, 5*12) != 5*12)
        return nil;

    /*
     * distinguish new channel descriptor from old ldepth.
     * channel descriptors have letters as well as numbers,
     * while ldepths are a single digit formatted as %-11d.
     */
    new = 0;
    for(m=0; m<10; m++){
        if(hdr[m] != ' '){
            new = 1;
            break;
        }
    }
    if(hdr[11] != ' '){
        werrstr("creadimage: bad format");
        return nil;
    }
    if(new){
        hdr[11] = '\0';
        if((chan = strtochan(hdr)) == 0){
            werrstr("creadimage: bad channel string %s", hdr);
            return nil;
        }
    }else{
        ldepth = ((int)hdr[10])-'0';
        if(ldepth<0 || ldepth>3){
            werrstr("creadimage: bad ldepth %d", ldepth);
            return nil;
        }
        chan = drawld2chan[ldepth];
    }
    r.min.x=atoi(hdr+1*12);
    r.min.y=atoi(hdr+2*12);
    r.max.x=atoi(hdr+3*12);
    r.max.y=atoi(hdr+4*12);
    if(r.min.x>r.max.x || r.min.y>r.max.y){
        werrstr("creadimage: bad rectangle");
        return nil;
    }

    if(d){
        if(dolock)
            lockdisplay(d);
        i = allocimage(d, r, chan, 0, 0);
        setmalloctag(i, getcallerpc(&d));
        if(dolock)
            unlockdisplay(d);
        if(i == nil)
            return nil;
    }else{
        i = mallocz(sizeof(Image), 1);
        if(i == nil)
            return nil;
    }
    ncblock = _compblocksize(r, chantodepth(chan));
    buf = malloc(ncblock);
    if(buf == nil)
        goto Errout;
    miny = r.min.y;
    while(miny != r.max.y){
        if(readn(fd, hdr, 2*12) != 2*12){
        Errout:
            if(dolock)
                lockdisplay(d);
        Erroutlock:
            freeimage(i);
            if(dolock)
                unlockdisplay(d);
            free(buf);
            return nil;
        }
        maxy = atoi(hdr+0*12);
        nb = atoi(hdr+1*12);
        if(maxy<=miny || r.max.y<maxy){
            werrstr("creadimage: bad maxy %d", maxy);
            goto Errout;
        }
        if(nb<=0 || ncblock<nb){
            werrstr("creadimage: bad count %d", nb);
            goto Errout;
        }
        if(readn(fd, buf, nb)!=nb)
            goto Errout;
        if(d){
            if(dolock)
                lockdisplay(d);
            a = bufimage(i->display, 21+nb);
            if(a == nil)
                goto Erroutlock;
            a[0] = 'Y';
            BPLONG(a+1, i->id);
            BPLONG(a+5, r.min.x);
            BPLONG(a+9, miny);
            BPLONG(a+13, r.max.x);
            BPLONG(a+17, maxy);
            if(!new)	/* old image: flip the data bits */
                _twiddlecompressed(buf, nb);
            memmove(a+21, buf, nb);
            if(dolock)
                unlockdisplay(d);
        }
        miny = maxy;
    }
    free(buf);
    return i;
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/creadimage.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function creadimage>>
@


\subsection*{[[lib_graphics/libdraw/debug.c]]}

<<function drawsetdebug>>=
void
drawsetdebug(int v)
{
    uchar *a;
    a = bufimage(display, 1+1);
    if(a == 0){
        fprint(2, "drawsetdebug: %r\n");
        return;
    }
    a[0] = 'D';
    a[1] = v;
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/debug.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function drawsetdebug>>
@


\subsection*{[[lib_graphics/libdraw/defont.c]]}

<<global defontdata>>=
/*
 * lucm/latin1.9, in uncompressed form
 */
uchar
defontdata[] =
{
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x30,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x30,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x30,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x32,0x33,0x30,0x34,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x31,0x35,0x20,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x30,0x06,0x06,0x03,0x42,0x40,0x00,0x00,0x00,0x18,0x03,0x03,
0x02,0x43,0x00,0x60,0x60,0x48,0x00,0x0d,0x0c,0x01,0x81,0x80,0xd0,0x90,0x00,0x00,
0x18,0x01,0x81,0x81,0x40,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x7f,0x9c,0x1c,
0x0e,0x07,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xe0,0x70,
0x38,0x1c,0x0e,0x04,0x81,0xc1,0xc0,0x70,0x00,0x1c,0x1c,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xaa,0x80,0xc0,0x63,0xe3,
0xf1,0xf8,0xfe,0x7f,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,0x7f,0xff,0xff,0x1f,0x8f,
0xc7,0xe3,0xf1,0xfb,0x7e,0x3e,0x3f,0x8f,0xff,0xe3,0xe3,0xff,0xff,0xff,0xff,0xff,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x0c,0x18,0x09,0x05,0x82,0x40,0xc0,0x00,0x00,0x06,0x0c,0x04,
0x82,0x40,0xc1,0x80,0x90,0x48,0x00,0x16,0x03,0x06,0x02,0x41,0x60,0x90,0x00,0x00,
0x06,0x06,0x02,0x41,0x41,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3e,0x7f,0xa0,0x10,
0x08,0x04,0x02,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x90,0x48,
0x24,0x12,0x09,0x06,0x82,0x01,0x00,0x90,0x00,0x20,0x10,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x04,0x80,0x00,0x40,0x00,0x00,0x38,0x06,0x18,0x00,0x00,0x00,0x00,0x00,
0x00,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x07,0xc6,0x01,0xf0,0x00,0x00,0x0c,0x00,0x18,0x00,0x00,0x30,0x00,0x3c,
0x00,0x60,0x06,0x01,0x8c,0x07,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xe0,0xc3,0xc0,0x01,0x54,0x9c,0xc0,0x5f,0xef,
0xf7,0xfb,0xfd,0xbf,0xff,0xff,0xff,0xff,0xff,0xff,0xfb,0x7f,0xff,0xff,0x6f,0xb7,
0xdb,0xed,0xf6,0xf9,0x7d,0xfe,0xff,0x6f,0xff,0xdf,0xef,0xff,0xff,0xff,0xff,0xff,
0xff,0x00,0x01,0x00,0x00,0x00,0x00,0x30,0x00,0x14,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x38,0x00,0x00,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x20,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x30,0x06,0x06,0x06,0x82,0x80,0xc0,0x00,
0x00,0x18,0x03,0x03,0x02,0x41,0x80,0x30,0x30,0x24,0x76,0x0d,0x0c,0x00,0xc0,0xc0,
0xd0,0x50,0x00,0x00,0x18,0x01,0x81,0x81,0x40,0x30,0x00,0x28,0x0f,0x7f,0xbc,0x1c,
0x0e,0x07,0x03,0xc0,0x10,0x70,0x24,0x10,0x09,0x07,0x03,0x80,0xe0,0x70,0x90,0x48,
0x24,0x12,0x09,0x05,0x81,0x81,0xc0,0x80,0x70,0x18,0x1c,0x07,0x01,0xc1,0xc0,0x90,
0x00,0x0c,0x04,0x84,0x83,0xe1,0xc0,0xe0,0x38,0x0c,0x0c,0x02,0x00,0x00,0x00,0x00,
0x00,0x06,0x1c,0x06,0x0f,0x87,0xc0,0x63,0xf8,0x78,0xfe,0x3e,0x0e,0x00,0x00,0x00,
0x00,0x00,0x00,0x7c,0x1c,0x0c,0x1f,0x03,0xc7,0xc3,0xf1,0xf8,0x3c,0x63,0x3f,0x0f,
0x8c,0x66,0x06,0x19,0x84,0x78,0x7e,0x1e,0x1f,0x07,0xcf,0xf3,0x1b,0x0d,0x86,0x63,
0x61,0x9f,0xc6,0x06,0x00,0x30,0x00,0x00,0x10,0x00,0x18,0x00,0x00,0x30,0x00,0x60,
0x00,0x60,0x06,0x01,0x8c,0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,
0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0xc0,0x60,0x00,0xaa,0xb6,0xc0,0x43,0xe3,
0xf1,0xf8,0xfc,0x3f,0xef,0x8f,0xdb,0xef,0xf6,0xf8,0xfb,0xff,0x1f,0x8f,0x6f,0xb7,
0xdb,0xed,0xf6,0xfa,0x7e,0x7e,0x3f,0x7f,0x8f,0xe7,0xe3,0xf8,0xfe,0x3e,0x3f,0x6f,
0x00,0x00,0x01,0x01,0xc8,0x0b,0x0c,0x30,0x7c,0x14,0x0f,0x0f,0x00,0x00,0x00,0x00,
0x78,0x00,0x1c,0x00,0x0f,0x07,0x81,0x80,0x00,0x7c,0x00,0x00,0x1c,0x0f,0x80,0x04,
0x42,0x23,0x90,0x00,0x18,0x0c,0x06,0x03,0x01,0x80,0xc0,0x3c,0x3c,0x3f,0x1f,0x8f,
0xc7,0xe7,0xe3,0xf1,0xf8,0xfc,0x7c,0x30,0x8f,0x07,0x83,0xc1,0xe0,0xf0,0x00,0x3d,
0x31,0x98,0xcc,0x66,0x36,0x19,0x80,0xcc,0x0c,0x18,0x09,0x0b,0x02,0x81,0x20,0x00,
0x00,0x06,0x0c,0x04,0x82,0x40,0x60,0xc0,0x48,0x24,0x18,0x16,0x03,0x03,0x01,0x21,
0x60,0x50,0x00,0x00,0x06,0x06,0x02,0x41,0x40,0xc1,0x80,0x28,0x87,0x7f,0x84,0x10,
0x08,0x04,0x02,0x40,0x38,0x48,0x24,0x10,0x09,0x04,0x04,0x81,0x00,0x80,0x90,0x48,
0x24,0x12,0x09,0x04,0x80,0x41,0x00,0x80,0x40,0x04,0x10,0x04,0x02,0x01,0x20,0x90,
0x00,0x0c,0x04,0x84,0x86,0x53,0x65,0xb0,0x08,0x18,0x06,0x0a,0x80,0x00,0x00,0x00,
0x00,0x0c,0x36,0x0e,0x19,0xcc,0xe0,0xe3,0xf8,0xcc,0xfe,0x63,0x1b,0x00,0x00,0x00,
0x00,0x00,0x00,0xc6,0x62,0x0c,0x19,0x86,0x66,0x63,0x01,0x80,0x66,0x63,0x0c,0x01,
0x8c,0xc6,0x06,0x19,0xc4,0xcc,0x63,0x33,0x19,0x8c,0x61,0x83,0x1b,0x0d,0x86,0x63,
0x61,0x80,0xc6,0x03,0x00,0x30,0x30,0x00,0x1c,0x00,0x18,0x00,0x00,0x30,0x00,0x60,
0x00,0x60,0x00,0x00,0x0c,0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,
0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0xc0,0x60,0x01,0x54,0x86,0xc0,0x7b,0xef,
0xf7,0xfb,0xfd,0xbf,0xc7,0xb7,0xdb,0xef,0xf6,0xfb,0xfb,0x7e,0xff,0x7f,0x6f,0xb7,
0xdb,0xed,0xf6,0xfb,0x7f,0xbe,0xff,0x7f,0xbf,0xfb,0xef,0xfb,0xfd,0xfe,0xdf,0x6f,
0xff,0x00,0x07,0x83,0x24,0x13,0x0c,0x30,0xc6,0x00,0x10,0x81,0x80,0x00,0x00,0x00,
0x84,0x00,0x22,0x00,0x01,0x80,0xc0,0x00,0x00,0xf4,0x00,0x00,0x2c,0x18,0xc0,0x0c,
0x46,0x20,0x90,0x00,0x18,0x0c,0x06,0x03,0x01,0x80,0xc0,0x70,0x66,0x30,0x18,0x0c,
0x06,0x01,0x80,0xc0,0x60,0x30,0x66,0x38,0x99,0x8c,0xc6,0x63,0x31,0x98,0x00,0x66,
0x31,0x98,0xcc,0x66,0x36,0x19,0x80,0xcc,0x00,0x00,0x00,0x00,0x00,0x00,0xc0,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x6c,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x00,0xff,0x7f,0xb8,0x1c,
0x0e,0x07,0x02,0x40,0x7c,0x70,0x3c,0x10,0x09,0x07,0x04,0x00,0xc0,0x60,0xe0,0x70,
0x38,0x1c,0x0e,0x04,0x83,0x81,0xc0,0x70,0x70,0x38,0x1c,0x07,0x02,0xc1,0xc0,0x90,
0x00,0x0c,0x00,0x04,0x86,0x43,0x69,0xb0,0x30,0x18,0x06,0x07,0x01,0x00,0x00,0x00,
0x00,0x0c,0x63,0x16,0x00,0xc0,0x61,0x62,0x01,0x80,0x06,0x63,0x31,0x80,0x00,0x00,
0x60,0x00,0xc0,0x06,0x43,0x16,0x19,0x8c,0x06,0x33,0x01,0x80,0xc0,0x63,0x0c,0x01,
0x8c,0x86,0x07,0x39,0xc5,0x86,0x63,0x61,0x99,0x8c,0x01,0x83,0x1b,0x0d,0xb6,0x63,
0x31,0x01,0x86,0x03,0x00,0x30,0x30,0x00,0x1c,0x3e,0x1b,0x03,0xc1,0xf0,0xf0,0x60,
0x3e,0x6e,0x3e,0x0f,0x8c,0x60,0xc5,0xb1,0xb8,0x38,0x6c,0x0f,0x8c,0xc7,0xc1,0x83,
0x19,0x8d,0x82,0x63,0x31,0x9f,0xc1,0x80,0xc0,0xc0,0x00,0xaa,0x86,0xc0,0x47,0xe3,
0xf1,0xf8,0xfd,0xbf,0x83,0x8f,0xc3,0xef,0xf6,0xf8,0xfc,0xff,0x3f,0x9f,0x1f,0x8f,
0xc7,0xe3,0xf1,0xfb,0x7c,0x7e,0x3f,0x8f,0x8f,0xc7,0xe3,0xf8,0xfd,0x3e,0x3f,0x6f,
0x00,0x0c,0x0d,0x43,0x03,0xe1,0x88,0x30,0xc0,0x00,0x27,0x41,0x80,0x00,0x00,0x01,
0x72,0x00,0x22,0x04,0x01,0x80,0xc0,0x03,0x18,0xf4,0x00,0x00,0x0c,0x18,0xc0,0x04,
0x82,0x43,0x20,0x18,0x2c,0x16,0x0b,0x05,0x82,0xc1,0x60,0xb0,0xc0,0x30,0x18,0x0c,
0x06,0x01,0x80,0xc0,0x60,0x30,0x63,0x38,0xb0,0xd8,0x6c,0x36,0x1b,0x0c,0x00,0xc7,
0x31,0x98,0xcc,0x66,0x33,0x11,0xf8,0xc8,0x7c,0x3e,0x1f,0x0f,0x87,0xc3,0xe1,0xd8,
0x3c,0x1e,0x0f,0x07,0x83,0xc7,0xc3,0xe1,0xf0,0xf8,0x06,0x37,0x07,0x03,0x81,0xc0,
0xe0,0x70,0x10,0x1d,0x31,0x98,0xcc,0x66,0x33,0x19,0xb0,0xc6,0x8f,0x7f,0x87,0x03,
0x81,0x80,0x90,0x30,0x6c,0x48,0x24,0x10,0x06,0x04,0x04,0x80,0x20,0x10,0x10,0x0e,
0x07,0x03,0x81,0xc0,0x60,0x88,0x38,0x0c,0x40,0x09,0x03,0x84,0x02,0x41,0x40,0x90,
0x00,0x0c,0x00,0x1f,0xe7,0x41,0xd1,0xa0,0x00,0x30,0x03,0x0a,0x81,0x00,0x00,0x00,
0x00,0x18,0x63,0x06,0x00,0xc0,0xc2,0x62,0x01,0xb0,0x0c,0x72,0x31,0x86,0x03,0x00,
0xc0,0x00,0x60,0x06,0x8f,0x16,0x19,0x0c,0x06,0x33,0x01,0x80,0xc0,0x63,0x0c,0x01,
0x8d,0x06,0x07,0x39,0x65,0x86,0x63,0x61,0x99,0x0e,0x01,0x83,0x19,0x89,0xb6,0x32,
0x33,0x03,0x06,0x01,0x80,0x30,0x78,0x00,0x00,0x03,0x1d,0x86,0x23,0x31,0x99,0xfc,
0x66,0x77,0x06,0x01,0x8c,0x40,0xc6,0xd9,0xdc,0x6c,0x76,0x19,0x8d,0xcc,0x27,0xf3,
0x19,0x8d,0x82,0x63,0x31,0x80,0xc0,0x80,0xc0,0x80,0x01,0x54,0x8c,0xc0,0x78,0xfc,
0x7e,0x7f,0x6f,0xcf,0x93,0xb7,0xdb,0xef,0xf9,0xfb,0xff,0xff,0xdf,0xef,0xef,0xf1,
0xf8,0xfc,0x7e,0x3f,0x9f,0x77,0xc7,0xf3,0xbf,0xf6,0xfc,0x7b,0xfd,0xbe,0xbf,0x6f,
0xff,0x0c,0x19,0x03,0x03,0x61,0x98,0x30,0x78,0x00,0x28,0x4f,0x83,0x30,0x00,0x01,
0x4a,0x00,0x1c,0x04,0x03,0x03,0x80,0x03,0x18,0xf4,0x00,0x00,0x0c,0x18,0xd9,0x84,
0x82,0x40,0xa0,0x18,0x2c,0x16,0x0b,0x05,0x82,0xc1,0x60,0xb0,0xc0,0x30,0x18,0x0c,
0x06,0x01,0x80,0xc0,0x60,0x30,0x63,0x2c,0xb0,0xd8,0x6c,0x36,0x1b,0x0c,0x64,0xcb,
0x31,0x98,0xcc,0x66,0x33,0x31,0x8c,0xd8,0x06,0x03,0x01,0x80,0xc0,0x60,0x30,0x6c,
0x62,0x33,0x19,0x8c,0xc6,0x60,0xc0,0x60,0x30,0x18,0x1e,0x3b,0x8d,0x86,0xc3,0x61,
0xb0,0xd8,0x10,0x36,0x31,0x98,0xcc,0x66,0x33,0x19,0xd8,0xc6,0x0f,0x7f,0x82,0x01,
0x02,0x40,0xd0,0x40,0x6c,0x70,0x24,0x1c,0x06,0x04,0x03,0x01,0xc0,0xe0,0x10,0x12,
0x09,0x04,0x82,0x40,0x90,0x50,0x10,0x12,0x70,0x09,0x04,0x04,0x01,0xc1,0x20,0x60,
0x00,0x0c,0x00,0x04,0x83,0xc0,0x20,0xcc,0x00,0x30,0x03,0x02,0x01,0x00,0x00,0x00,
0x00,0x18,0x63,0x06,0x01,0x83,0x84,0x63,0xf1,0xd8,0x18,0x3c,0x31,0x86,0x03,0x01,
0x83,0xf8,0x30,0x1c,0x9b,0x33,0x1e,0x0c,0x06,0x33,0xe1,0x80,0xc0,0x7f,0x0c,0x01,
0x8f,0x06,0x07,0x79,0x65,0x86,0x66,0x61,0x9e,0x07,0x81,0x83,0x19,0x89,0xb6,0x1c,
0x1a,0x03,0x06,0x01,0x80,0x30,0x48,0x00,0x00,0x03,0x18,0xcc,0x06,0x33,0x18,0x60,
0xc6,0x63,0x06,0x01,0x8c,0x80,0xc6,0xd9,0x8c,0xc6,0x63,0x31,0x8e,0x4c,0x01,0x83,
0x19,0x8d,0x92,0x32,0x31,0x81,0x87,0x00,0xc0,0x70,0xe4,0xaa,0x98,0xc0,0x7d,0xfe,
0xfd,0xbf,0x2f,0xbf,0x93,0x8f,0xdb,0xe3,0xf9,0xfb,0xff,0x1e,0x3f,0x1f,0xef,0xed,
0xf6,0xfb,0x7d,0xbf,0x6f,0xaf,0xef,0xed,0x8f,0xf6,0xfb,0xfb,0xfe,0x3e,0xdf,0x9f,
0x00,0x00,0x19,0x0f,0xc6,0x30,0xd0,0x00,0xcc,0x00,0x28,0x59,0x86,0x67,0xf0,0x01,
0x72,0x00,0x00,0x3f,0x86,0x00,0xc0,0x03,0x18,0xf4,0x00,0x00,0x0c,0x18,0xcc,0xc5,
0x32,0x83,0x4c,0x00,0x66,0x33,0x19,0x8c,0xc6,0x63,0x31,0xbc,0xc0,0x3e,0x1f,0x0f,
0x87,0xc1,0x80,0xc0,0x60,0x30,0xfb,0x2c,0xb0,0xd8,0x6c,0x36,0x1b,0x0c,0x38,0xcb,
0x31,0x98,0xcc,0x66,0x31,0xa1,0x8c,0xcc,0x06,0x03,0x01,0x80,0xc0,0x60,0x30,0x6c,
0xc0,0x63,0x31,0x98,0xcc,0x60,0xc0,0x60,0x30,0x18,0x37,0x31,0x98,0xcc,0x66,0x33,
0x19,0x8c,0x00,0x67,0x31,0x98,0xcc,0x66,0x33,0x19,0x8c,0xc6,0x1f,0x7f,0x82,0x01,
0x02,0x40,0xb0,0x40,0x6c,0x07,0x03,0x83,0x80,0xe0,0xe0,0x00,0x18,0x0e,0x10,0x10,
0x08,0x04,0x02,0x00,0xf0,0x20,0x10,0x1e,0x08,0x89,0x03,0x00,0xe0,0x38,0x1c,0x0e,
0x00,0x0c,0x00,0x04,0x81,0xe0,0x41,0x6c,0x00,0x30,0x03,0x00,0x0f,0xe0,0x03,0xf8,
0x00,0x30,0x63,0x06,0x03,0x00,0xc7,0xf0,0x39,0x8c,0x30,0x3e,0x1b,0x80,0x00,0x03,
0x00,0x00,0x18,0x30,0x9b,0x23,0x19,0x0c,0x06,0x33,0x01,0xf8,0xc6,0x63,0x0c,0x01,
0x8d,0x86,0x05,0xd9,0x35,0x86,0x7c,0x61,0x9b,0x01,0xc1,0x83,0x19,0x99,0xb4,0x1c,
0x0c,0x06,0x06,0x00,0xc0,0x30,0xcc,0x00,0x00,0x3f,0x18,0xcc,0x06,0x33,0xf8,0x60,
0xc6,0x63,0x06,0x01,0x8f,0x00,0xc6,0xd9,0x8c,0xc6,0x63,0x31,0x8c,0x0f,0x81,0x83,
0x18,0xd9,0xba,0x1c,0x1b,0x03,0x00,0x80,0xc0,0x81,0x75,0x54,0x98,0xc0,0x7d,0xfe,
0xfd,0xbf,0x4f,0xbf,0x93,0xf8,0xfc,0x7c,0x7f,0x1f,0x1f,0x6f,0xe7,0xf1,0xef,0xef,
0xf7,0xfb,0xfd,0xff,0x0f,0xdf,0xef,0xe1,0xf7,0x76,0xfc,0xff,0x1f,0xc7,0xe3,0xf1,
0xff,0x08,0x19,0x03,0x06,0x31,0xf8,0x00,0xc6,0x00,0x28,0x5b,0x8c,0xc0,0x11,0xf1,
0x4a,0x00,0x00,0x04,0x0c,0x00,0xc0,0x03,0x18,0x74,0x38,0x00,0x0c,0x18,0xc6,0x65,
0x52,0xb8,0x54,0x18,0x46,0x23,0x11,0x88,0xc4,0x62,0x31,0x30,0xc0,0x30,0x18,0x0c,
0x06,0x01,0x80,0xc0,0x60,0x30,0x63,0x26,0xb0,0xd8,0x6c,0x36,0x1b,0x0c,0x10,0xd3,
0x31,0x98,0xcc,0x66,0x30,0xc1,0x8c,0xc6,0x7e,0x3f,0x1f,0x8f,0xc7,0xe3,0xf1,0xfc,
0xc0,0x7f,0x3f,0x9f,0xcf,0xe0,0xc0,0x60,0x30,0x18,0x63,0x31,0x98,0xcc,0x66,0x33,
0x19,0x8c,0xfe,0x6b,0x31,0x98,0xcc,0x66,0x31,0xb1,0x8c,0x6c,0x0e,0x7f,0x82,0x01,
0x01,0x80,0x90,0x30,0xc6,0x08,0x01,0x02,0x00,0x40,0x80,0xe0,0x24,0x04,0x1c,0x10,
0x08,0x04,0x02,0x00,0x90,0x20,0x10,0x12,0x0d,0x86,0x00,0x81,0x00,0x40,0x20,0x10,
0x00,0x04,0x00,0x1f,0xe1,0x70,0xbb,0x28,0x00,0x30,0x03,0x00,0x01,0x00,0x00,0x00,
0x00,0x30,0x63,0x06,0x06,0x00,0x67,0xf0,0x19,0x8c,0x30,0x67,0x0d,0x80,0x00,0x01,
0x83,0xf8,0x30,0x30,0x9b,0x7f,0x19,0x8c,0x06,0x33,0x01,0x80,0xc6,0x63,0x0c,0x01,
0x8c,0xc6,0x05,0xd9,0x35,0x86,0x60,0x61,0x99,0x80,0xe1,0x83,0x18,0xd0,0xdc,0x26,
0x0c,0x0c,0x06,0x00,0xc0,0x30,0x84,0x00,0x00,0x63,0x18,0xcc,0x06,0x33,0x00,0x60,
0xc6,0x63,0x06,0x01,0x8d,0x80,0xc6,0xd9,0x8c,0xc6,0x63,0x31,0x8c,0x03,0xe1,0x83,
0x18,0xd9,0xba,0x1c,0x1b,0x06,0x01,0x80,0xc0,0xc1,0x38,0xaa,0x80,0xc0,0x7d,0xfe,
0xfe,0x7f,0x6f,0xcf,0x39,0xf7,0xfe,0xfd,0xff,0xbf,0x7f,0x0f,0xdb,0xfb,0xe3,0xef,
0xf7,0xfb,0xfd,0xff,0x6f,0xdf,0xef,0xed,0xf2,0x79,0xff,0x7e,0xff,0xbf,0xdf,0xef,
0x00,0x0c,0x19,0x03,0x03,0x60,0x60,0x30,0x66,0x00,0x28,0x4d,0xc6,0x60,0x10,0x00,
0x84,0x00,0x00,0x04,0x0f,0x87,0x80,0x03,0x18,0x14,0x38,0x00,0x3f,0x0f,0x8c,0xc2,
0x90,0x84,0xa4,0x18,0xfe,0x7f,0x3f,0x9f,0xcf,0xe7,0xf1,0xf0,0xc0,0x30,0x18,0x0c,
0x06,0x01,0x80,0xc0,0x60,0x30,0x63,0x26,0xb0,0xd8,0x6c,0x36,0x1b,0x0c,0x38,0xd3,
0x31,0x98,0xcc,0x66,0x30,0xc1,0x98,0xc6,0xc6,0x63,0x31,0x98,0xcc,0x66,0x33,0x60,
0xc0,0x60,0x30,0x18,0x0c,0x00,0xc0,0x60,0x30,0x18,0x63,0x31,0x98,0xcc,0x66,0x33,
0x19,0x8c,0x00,0x6b,0x31,0x98,0xcc,0x66,0x31,0xb1,0x8c,0x6c,0x1c,0x7f,0x81,0x20,
0x90,0x38,0x18,0x0b,0x83,0x06,0x01,0x03,0x80,0x40,0xe0,0x90,0x24,0x04,0x03,0x8e,
0x86,0xc3,0x61,0x90,0x24,0x12,0x0e,0x04,0x8a,0x81,0xc7,0x70,0xc0,0x30,0x18,0x0c,
0x00,0x00,0x00,0x04,0x81,0x31,0x6f,0x30,0x00,0x18,0x06,0x00,0x01,0x00,0x00,0x00,
0x00,0x60,0x63,0x06,0x0c,0x00,0x60,0x60,0x19,0x8c,0x60,0x63,0x01,0x80,0x00,0x00,
0xc0,0x00,0x60,0x00,0x4d,0xe1,0x99,0x8c,0x06,0x33,0x01,0x80,0xc6,0x63,0x0c,0x01,
0x8c,0xc6,0x04,0x99,0x1d,0x86,0x60,0x61,0x99,0x80,0x61,0x83,0x18,0xd0,0xdc,0x63,
0x0c,0x0c,0x06,0x00,0x60,0x30,0x84,0x00,0x00,0x63,0x18,0xcc,0x06,0x33,0x00,0x60,
0x6e,0x63,0x06,0x01,0x8c,0xc0,0xc6,0xd9,0x8c,0xc6,0x63,0x31,0x8c,0x00,0x61,0x83,
0x18,0xd0,0xcc,0x26,0x0e,0x0c,0x03,0x00,0xc0,0x60,0x01,0x54,0x98,0xc0,0x7e,0xdf,
0x6f,0xc7,0xe7,0xf4,0x7c,0xf9,0xfe,0xfc,0x7f,0xbf,0x1f,0x5f,0xdb,0xfb,0xfc,0x71,
0x79,0x3c,0x9e,0x6f,0xdb,0xed,0xf1,0xfb,0x75,0x7e,0x38,0x8f,0x3f,0xcf,0xe7,0xf3,
0xff,0x0c,0x0d,0x03,0x03,0xe1,0xf8,0x30,0x3c,0x00,0x27,0x40,0x03,0x30,0x00,0x00,
0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x18,0x14,0x00,0x00,0x00,0x00,0x19,0x82,
0xf8,0x98,0xbe,0x70,0xc3,0x61,0xb0,0xd8,0x6c,0x36,0x1b,0x30,0xc0,0x30,0x18,0x0c,
0x06,0x01,0x80,0xc0,0x60,0x30,0x63,0x23,0xb0,0xd8,0x6c,0x36,0x1b,0x0c,0x4c,0xe3,
0x31,0x98,0xcc,0x66,0x30,0xc1,0xf0,0xc6,0xc6,0x63,0x31,0x98,0xcc,0x66,0x33,0x60,
0xc0,0x60,0x30,0x18,0x0c,0x00,0xc0,0x60,0x30,0x18,0x63,0x31,0x98,0xcc,0x66,0x33,
0x19,0x8c,0x10,0x73,0x31,0x98,0xcc,0x66,0x30,0xe1,0x8c,0x38,0x1c,0x7f,0x80,0xa0,
0x50,0x10,0x24,0x0d,0xff,0x01,0x01,0x02,0x00,0x40,0x80,0xf0,0x24,0x04,0x02,0x01,
0x81,0x20,0x10,0x30,0x28,0x1a,0x09,0x06,0x8a,0x81,0x20,0x90,0x20,0x08,0x04,0x02,
0x00,0x0c,0x00,0x04,0x85,0x32,0x6f,0xb8,0x00,0x18,0x06,0x00,0x01,0x01,0xc0,0x00,
0x70,0x60,0x36,0x06,0x1f,0xcc,0xe0,0x63,0x30,0xd8,0x60,0x63,0x33,0x06,0x03,0x00,
0x60,0x00,0xc0,0x30,0x60,0x61,0x99,0x86,0x66,0x63,0x01,0x80,0x66,0x63,0x0c,0x03,
0x0c,0x66,0x04,0x19,0x1c,0xcc,0x60,0x33,0x18,0xcc,0x61,0x81,0xb0,0x60,0xcc,0x63,
0x0c,0x18,0x06,0x00,0x60,0x30,0x00,0x00,0x00,0x67,0x19,0x86,0x23,0x71,0x88,0x60,
0x36,0x63,0x06,0x01,0x8c,0x60,0xc6,0xd9,0x8c,0x6c,0x66,0x1b,0x8c,0x08,0x61,0x83,
0xb8,0x70,0xcc,0x63,0x0c,0x18,0x03,0x00,0xc0,0x60,0x00,0xaa,0x98,0xc0,0x7f,0x5f,
0xaf,0xef,0xdb,0xf2,0x00,0xfe,0xfe,0xfd,0xff,0xbf,0x7f,0x6f,0xdb,0xfb,0xfd,0xfe,
0x7e,0xdf,0xef,0xcf,0xd7,0xe5,0xf6,0xf9,0x75,0x7e,0xdf,0x6f,0xdf,0xf7,0xfb,0xfd,
0x00,0x0c,0x07,0xc6,0x04,0x10,0x60,0x30,0x06,0x00,0x10,0x80,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x3f,0x80,0x00,0x00,0x03,0xb8,0x14,0x00,0x00,0x00,0x00,0x00,0x04,
0x11,0x21,0x04,0xc0,0xc3,0x61,0xb0,0xd8,0x6c,0x36,0x1b,0x30,0x66,0x30,0x18,0x0c,
0x06,0x01,0x80,0xc0,0x60,0x30,0x66,0x23,0x99,0x8c,0xc6,0x63,0x31,0x98,0x00,0x66,
0x1b,0x0d,0x86,0xc3,0x60,0xc1,0x80,0xc6,0xce,0x67,0x33,0x99,0xcc,0xe6,0x73,0x74,
0x62,0x31,0x18,0x8c,0x46,0x20,0xc0,0x60,0x30,0x18,0x36,0x31,0x8d,0x86,0xc3,0x61,
0xb0,0xd8,0x10,0x36,0x3b,0x9d,0xce,0xe7,0x70,0xc1,0x98,0x30,0x00,0x7f,0x80,0xc0,
0x60,0x10,0x24,0x0c,0x38,0x0e,0x01,0x02,0x00,0x40,0x80,0xa0,0x18,0x0e,0x03,0x00,
0x80,0x40,0x60,0x50,0x30,0x16,0x0e,0x05,0x88,0x81,0xc0,0x81,0xc0,0x70,0x38,0x1c,
0x00,0x0c,0x00,0x04,0x83,0xe0,0x39,0xcc,0x00,0x0c,0x0c,0x00,0x00,0x01,0xc0,0x00,
0x70,0xc0,0x1c,0x06,0x1f,0xc7,0xc0,0x61,0xe0,0x70,0x60,0x3e,0x1e,0x06,0x03,0x00,
0x00,0x00,0x00,0x30,0x1e,0x61,0x9f,0x03,0xc7,0xc3,0xf1,0x80,0x3e,0x63,0x3f,0x1e,
0x0c,0x67,0xe4,0x19,0x0c,0x78,0x60,0x1e,0x18,0xc7,0xc1,0x80,0xe0,0x60,0xcc,0x63,
0x0c,0x1f,0xc6,0x00,0x30,0x30,0x00,0x00,0x00,0x3b,0x9f,0x03,0xc1,0xb0,0xf0,0x60,
0x06,0x63,0x06,0x01,0x8c,0x70,0xc6,0xd9,0x8c,0x38,0x7c,0x0d,0x8c,0x07,0xc0,0xf1,
0xd8,0x60,0xcc,0x63,0x0c,0x1f,0xc3,0x00,0xc0,0x60,0x01,0x54,0x80,0xc0,0x7f,0x3f,
0x9f,0xef,0xdb,0xf3,0xc7,0xf1,0xfe,0xfd,0xff,0xbf,0x7f,0xff,0xe7,0xf1,0xfc,0xff,
0x7f,0xbf,0x9f,0xaf,0xcf,0xe9,0xf1,0xfa,0x77,0x7e,0x3f,0x7e,0x3f,0x8f,0xc7,0xe3,
0xff,0x0c,0x01,0x0f,0xe8,0x08,0x60,0x30,0xc6,0x00,0x0f,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xd8,0x14,0x00,0x00,0x00,0x00,0x00,0x04,
0x11,0x3d,0x04,0xc0,0xc3,0x61,0xb0,0xd8,0x6c,0x36,0x1b,0x3c,0x3c,0x3f,0x1f,0x8f,
0xc7,0xe7,0xe3,0xf1,0xf8,0xfc,0x7c,0x21,0x8f,0x07,0x83,0xc1,0xe0,0xf0,0x00,0xbc,
0x0e,0x07,0x03,0x81,0xc0,0xc1,0x80,0xcc,0x77,0x3b,0x9d,0xce,0xe7,0x73,0xb9,0x98,
0x3c,0x1e,0x0f,0x07,0x83,0xc0,0xc0,0x60,0x30,0x18,0x1c,0x31,0x87,0x03,0x81,0xc0,
0xe0,0x70,0x00,0x5c,0x1d,0x8e,0xc7,0x63,0xb0,0xc1,0xf0,0x30,0x00,0x7f,0x81,0x40,
0xa0,0x10,0x28,0x0a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x90,0x00,0x00,0x02,0x00,
0x80,0x80,0x10,0xf8,0x28,0x12,0x09,0x04,0x80,0x01,0x20,0x80,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x06,0x18,0x00,0x00,0x00,0x40,0x00,
0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x07,0xc0,0x31,0xf0,0x01,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xcc,0x00,0x00,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x60,0x01,0x80,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x18,0x00,0x01,0xe0,0xc3,0xc0,0x00,0x00,0xff,0xc0,0x7e,0xbf,
0x5f,0xef,0xd7,0xf5,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfd,0xff,
0x7f,0x7f,0xef,0x07,0xd7,0xed,0xf6,0xfb,0x7f,0xfe,0xdf,0x7f,0xff,0xff,0xff,0xff,
0x00,0x0c,0x01,0x00,0x00,0x00,0x00,0x30,0x7c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x14,0x00,0x08,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0xc6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x81,0x80,0x60,0x00,0x7f,0x81,0x20,
0x90,0x10,0x1c,0x0a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x80,
0x81,0xe0,0x60,0x10,0x24,0x12,0x0e,0x04,0x80,0x01,0xc0,0x70,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x78,0x00,0x00,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x01,0x80,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7f,0xfe,0xdf,
0x6f,0xef,0xe3,0xf5,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,0x7f,
0x7e,0x1f,0x9f,0xef,0xdb,0xed,0xf1,0xfb,0x7f,0xfe,0x3f,0x8f,0xff,0xff,0xff,0xff,
0x00,0x0c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x7c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x81,0x80,0x60,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x32,0x35,0x36,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x31,0x35,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x31,0x33,0x20,
0x00,0x00,0x01,0x0c,0x00,0x09,0x09,0x00,0x01,0x0f,0x00,0x09,0x12,0x00,0x01,0x0f,
0x00,0x09,0x1b,0x00,0x01,0x0f,0x00,0x09,0x24,0x00,0x01,0x0f,0x00,0x09,0x2d,0x00,
0x01,0x0f,0x00,0x09,0x36,0x00,0x01,0x0f,0x00,0x09,0x3f,0x00,0x03,0x0d,0x00,0x09,
0x48,0x00,0x03,0x0d,0x00,0x09,0x51,0x00,0x03,0x0d,0x00,0x09,0x5a,0x00,0x03,0x0d,
0x00,0x09,0x63,0x00,0x03,0x0d,0x00,0x09,0x6c,0x00,0x03,0x0d,0x00,0x09,0x75,0x00,
0x03,0x0e,0x00,0x09,0x7e,0x00,0x03,0x0d,0x00,0x09,0x87,0x00,0x03,0x0d,0x00,0x09,
0x90,0x00,0x01,0x0f,0x00,0x09,0x99,0x00,0x01,0x0f,0x00,0x09,0xa2,0x00,0x01,0x0f,
0x00,0x09,0xab,0x00,0x01,0x0f,0x00,0x09,0xb4,0x00,0x01,0x0f,0x00,0x09,0xbd,0x00,
0x01,0x0f,0x00,0x09,0xc6,0x00,0x01,0x0f,0x00,0x09,0xcf,0x00,0x01,0x0f,0x00,0x09,
0xd8,0x00,0x01,0x0f,0x00,0x09,0xe1,0x00,0x03,0x0d,0x00,0x09,0xea,0x00,0x01,0x0f,
0x00,0x09,0xf3,0x00,0x01,0x0f,0x00,0x09,0xfc,0x00,0x03,0x0d,0x00,0x09,0x05,0x01,
0x03,0x0d,0x00,0x09,0x0e,0x01,0x03,0x0d,0x00,0x09,0x17,0x01,0x03,0x0d,0x00,0x09,
0x20,0x01,0x00,0x00,0x00,0x09,0x29,0x01,0x03,0x0d,0x00,0x09,0x32,0x01,0x02,0x05,
0x00,0x09,0x3b,0x01,0x03,0x0d,0x00,0x09,0x44,0x01,0x02,0x0e,0x00,0x09,0x4d,0x01,
0x03,0x0d,0x00,0x09,0x56,0x01,0x03,0x0d,0x00,0x09,0x5f,0x01,0x02,0x06,0x00,0x09,
0x68,0x01,0x02,0x0e,0x00,0x09,0x71,0x01,0x02,0x0e,0x00,0x09,0x7a,0x01,0x03,0x08,
0x00,0x09,0x83,0x01,0x05,0x0c,0x00,0x09,0x8c,0x01,0x0b,0x0f,0x00,0x09,0x95,0x01,
0x08,0x09,0x00,0x09,0x9e,0x01,0x0b,0x0d,0x00,0x09,0xa7,0x01,0x02,0x0e,0x00,0x09,
0xb0,0x01,0x03,0x0d,0x00,0x09,0xb9,0x01,0x03,0x0d,0x00,0x09,0xc2,0x01,0x03,0x0d,
0x00,0x09,0xcb,0x01,0x03,0x0d,0x00,0x09,0xd4,0x01,0x03,0x0d,0x00,0x09,0xdd,0x01,
0x03,0x0d,0x00,0x09,0xe6,0x01,0x03,0x0d,0x00,0x09,0xef,0x01,0x03,0x0d,0x00,0x09,
0xf8,0x01,0x03,0x0d,0x00,0x09,0x01,0x02,0x03,0x0d,0x00,0x09,0x0a,0x02,0x06,0x0d,
0x00,0x09,0x13,0x02,0x06,0x0f,0x00,0x09,0x1c,0x02,0x05,0x0c,0x00,0x09,0x25,0x02,
0x07,0x0a,0x00,0x09,0x2e,0x02,0x05,0x0c,0x00,0x09,0x37,0x02,0x03,0x0d,0x00,0x09,
0x40,0x02,0x03,0x0d,0x00,0x09,0x49,0x02,0x03,0x0d,0x00,0x09,0x52,0x02,0x03,0x0d,
0x00,0x09,0x5b,0x02,0x03,0x0d,0x00,0x09,0x64,0x02,0x03,0x0d,0x00,0x09,0x6d,0x02,
0x03,0x0d,0x00,0x09,0x76,0x02,0x03,0x0d,0x00,0x09,0x7f,0x02,0x03,0x0d,0x00,0x09,
0x88,0x02,0x03,0x0d,0x00,0x09,0x91,0x02,0x03,0x0d,0x00,0x09,0x9a,0x02,0x03,0x0d,
0x00,0x09,0xa3,0x02,0x03,0x0d,0x00,0x09,0xac,0x02,0x03,0x0d,0x00,0x09,0xb5,0x02,
0x03,0x0d,0x00,0x09,0xbe,0x02,0x03,0x0d,0x00,0x09,0xc7,0x02,0x03,0x0d,0x00,0x09,
0xd0,0x02,0x03,0x0d,0x00,0x09,0xd9,0x02,0x03,0x0f,0x00,0x09,0xe2,0x02,0x03,0x0d,
0x00,0x09,0xeb,0x02,0x03,0x0d,0x00,0x09,0xf4,0x02,0x03,0x0d,0x00,0x09,0xfd,0x02,
0x03,0x0d,0x00,0x09,0x06,0x03,0x03,0x0d,0x00,0x09,0x0f,0x03,0x03,0x0d,0x00,0x09,
0x18,0x03,0x03,0x0d,0x00,0x09,0x21,0x03,0x03,0x0d,0x00,0x09,0x2a,0x03,0x03,0x0d,
0x00,0x09,0x33,0x03,0x02,0x0e,0x00,0x09,0x3c,0x03,0x02,0x0e,0x00,0x09,0x45,0x03,
0x02,0x0e,0x00,0x09,0x4e,0x03,0x04,0x0b,0x00,0x09,0x57,0x03,0x0d,0x0e,0x00,0x09,
0x60,0x03,0x02,0x06,0x00,0x09,0x69,0x03,0x05,0x0d,0x00,0x09,0x72,0x03,0x02,0x0d,
0x00,0x09,0x7b,0x03,0x05,0x0d,0x00,0x09,0x84,0x03,0x02,0x0d,0x00,0x09,0x8d,0x03,
0x05,0x0d,0x00,0x09,0x96,0x03,0x02,0x0d,0x00,0x09,0x9f,0x03,0x05,0x0f,0x00,0x09,
0xa8,0x03,0x02,0x0d,0x00,0x09,0xb1,0x03,0x02,0x0d,0x00,0x09,0xba,0x03,0x02,0x0f,
0x00,0x09,0xc3,0x03,0x02,0x0d,0x00,0x09,0xcc,0x03,0x02,0x0d,0x00,0x09,0xd5,0x03,
0x05,0x0d,0x00,0x09,0xde,0x03,0x05,0x0d,0x00,0x09,0xe7,0x03,0x05,0x0d,0x00,0x09,
0xf0,0x03,0x05,0x0f,0x00,0x09,0xf9,0x03,0x05,0x0f,0x00,0x09,0x02,0x04,0x05,0x0d,
0x00,0x09,0x0b,0x04,0x05,0x0d,0x00,0x09,0x14,0x04,0x03,0x0d,0x00,0x09,0x1d,0x04,
0x05,0x0d,0x00,0x09,0x26,0x04,0x05,0x0d,0x00,0x09,0x2f,0x04,0x05,0x0d,0x00,0x09,
0x38,0x04,0x05,0x0d,0x00,0x09,0x41,0x04,0x05,0x0f,0x00,0x09,0x4a,0x04,0x05,0x0d,
0x00,0x09,0x53,0x04,0x02,0x0e,0x00,0x09,0x5c,0x04,0x02,0x0e,0x00,0x09,0x65,0x04,
0x02,0x0e,0x00,0x09,0x6e,0x04,0x07,0x0a,0x00,0x09,0x77,0x04,0x01,0x0d,0x00,0x09,
0x80,0x04,0x00,0x0e,0x00,0x09,0x89,0x04,0x00,0x0f,0x00,0x09,0x92,0x04,0x00,0x0f,
0x00,0x09,0x9b,0x04,0x00,0x0f,0x00,0x09,0xa4,0x04,0x00,0x0f,0x00,0x09,0xad,0x04,
0x00,0x0f,0x00,0x09,0xb6,0x04,0x00,0x0f,0x00,0x09,0xbf,0x04,0x00,0x0f,0x00,0x09,
0xc8,0x04,0x00,0x0f,0x00,0x09,0xd1,0x04,0x00,0x0f,0x00,0x09,0xda,0x04,0x00,0x0f,
0x00,0x09,0xe3,0x04,0x00,0x0f,0x00,0x09,0xec,0x04,0x00,0x0f,0x00,0x09,0xf5,0x04,
0x00,0x0f,0x00,0x09,0xfe,0x04,0x00,0x0f,0x00,0x09,0x07,0x05,0x00,0x0f,0x00,0x09,
0x10,0x05,0x00,0x0f,0x00,0x09,0x19,0x05,0x00,0x0f,0x00,0x09,0x22,0x05,0x00,0x0f,
0x00,0x09,0x2b,0x05,0x00,0x0f,0x00,0x09,0x34,0x05,0x00,0x0f,0x00,0x09,0x3d,0x05,
0x00,0x0f,0x00,0x09,0x46,0x05,0x00,0x0f,0x00,0x09,0x4f,0x05,0x00,0x0f,0x00,0x09,
0x58,0x05,0x00,0x0f,0x00,0x09,0x61,0x05,0x00,0x0f,0x00,0x09,0x6a,0x05,0x00,0x0f,
0x00,0x09,0x73,0x05,0x00,0x0f,0x00,0x09,0x7c,0x05,0x00,0x0f,0x00,0x09,0x85,0x05,
0x00,0x0f,0x00,0x09,0x8e,0x05,0x00,0x0f,0x00,0x09,0x97,0x05,0x00,0x0f,0x00,0x09,
0xa0,0x05,0x00,0x0d,0x00,0x09,0xa9,0x05,0x05,0x0f,0x00,0x09,0xb2,0x05,0x02,0x0e,
0x00,0x09,0xbb,0x05,0x03,0x0d,0x00,0x09,0xc4,0x05,0x03,0x0d,0x00,0x09,0xcd,0x05,
0x03,0x0d,0x00,0x09,0xd6,0x05,0x02,0x0e,0x00,0x09,0xdf,0x05,0x03,0x0e,0x00,0x09,
0xe8,0x05,0x02,0x04,0x00,0x09,0xf1,0x05,0x03,0x0d,0x00,0x09,0xfa,0x05,0x03,0x0a,
0x00,0x09,0x03,0x06,0x06,0x0b,0x00,0x09,0x0c,0x06,0x07,0x0a,0x00,0x09,0x15,0x06,
0x08,0x09,0x00,0x09,0x1e,0x06,0x03,0x0b,0x00,0x09,0x27,0x06,0x02,0x03,0x00,0x09,
0x30,0x06,0x03,0x07,0x00,0x09,0x39,0x06,0x05,0x0c,0x00,0x09,0x42,0x06,0x03,0x0a,
0x00,0x09,0x4b,0x06,0x03,0x0a,0x00,0x09,0x54,0x06,0x02,0x04,0x00,0x09,0x5d,0x06,
0x05,0x0f,0x00,0x09,0x66,0x06,0x03,0x0e,0x00,0x09,0x6f,0x06,0x08,0x0a,0x00,0x09,
0x78,0x06,0x0d,0x0f,0x00,0x09,0x81,0x06,0x03,0x0a,0x00,0x09,0x8a,0x06,0x03,0x0a,
0x00,0x09,0x93,0x06,0x06,0x0b,0x00,0x09,0x9c,0x06,0x03,0x0d,0x00,0x09,0xa5,0x06,
0x03,0x0d,0x00,0x09,0xae,0x06,0x03,0x0d,0x00,0x09,0xb7,0x06,0x05,0x0f,0x00,0x09,
0xc0,0x06,0x00,0x0d,0x00,0x09,0xc9,0x06,0x00,0x0d,0x00,0x09,0xd2,0x06,0x00,0x0d,
0x00,0x09,0xdb,0x06,0x00,0x0d,0x00,0x09,0xe4,0x06,0x00,0x0d,0x00,0x09,0xed,0x06,
0x01,0x0d,0x00,0x09,0xf6,0x06,0x03,0x0d,0x00,0x09,0xff,0x06,0x03,0x0f,0x00,0x09,
0x08,0x07,0x00,0x0d,0x00,0x09,0x11,0x07,0x00,0x0d,0x00,0x09,0x1a,0x07,0x00,0x0d,
0x00,0x09,0x23,0x07,0x00,0x0d,0x00,0x09,0x2c,0x07,0x00,0x0d,0x00,0x09,0x35,0x07,
0x00,0x0d,0x00,0x09,0x3e,0x07,0x00,0x0d,0x00,0x09,0x47,0x07,0x00,0x0d,0x00,0x09,
0x50,0x07,0x03,0x0d,0x00,0x09,0x59,0x07,0x00,0x0d,0x00,0x09,0x62,0x07,0x00,0x0d,
0x00,0x09,0x6b,0x07,0x00,0x0d,0x00,0x09,0x74,0x07,0x00,0x0d,0x00,0x09,0x7d,0x07,
0x00,0x0d,0x00,0x09,0x86,0x07,0x00,0x0d,0x00,0x09,0x8f,0x07,0x06,0x0b,0x00,0x09,
0x98,0x07,0x03,0x0d,0x00,0x09,0xa1,0x07,0x00,0x0d,0x00,0x09,0xaa,0x07,0x00,0x0d,
0x00,0x09,0xb3,0x07,0x00,0x0d,0x00,0x09,0xbc,0x07,0x00,0x0d,0x00,0x09,0xc5,0x07,
0x00,0x0d,0x00,0x09,0xce,0x07,0x03,0x0d,0x00,0x09,0xd7,0x07,0x02,0x0d,0x00,0x09,
0xe0,0x07,0x02,0x0d,0x00,0x09,0xe9,0x07,0x02,0x0d,0x00,0x09,0xf2,0x07,0x02,0x0d,
0x00,0x09,0xfb,0x07,0x02,0x0d,0x00,0x09,0x04,0x08,0x02,0x0d,0x00,0x09,0x0d,0x08,
0x02,0x0d,0x00,0x09,0x16,0x08,0x05,0x0d,0x00,0x09,0x1f,0x08,0x05,0x0f,0x00,0x09,
0x28,0x08,0x02,0x0d,0x00,0x09,0x31,0x08,0x02,0x0d,0x00,0x09,0x3a,0x08,0x02,0x0d,
0x00,0x09,0x43,0x08,0x02,0x0d,0x00,0x09,0x4c,0x08,0x02,0x0d,0x00,0x09,0x55,0x08,
0x02,0x0d,0x00,0x09,0x5e,0x08,0x02,0x0d,0x00,0x09,0x67,0x08,0x02,0x0d,0x00,0x09,
0x70,0x08,0x02,0x0d,0x00,0x09,0x79,0x08,0x02,0x0d,0x00,0x09,0x82,0x08,0x02,0x0d,
0x00,0x09,0x8b,0x08,0x02,0x0d,0x00,0x09,0x94,0x08,0x02,0x0d,0x00,0x09,0x9d,0x08,
0x02,0x0d,0x00,0x09,0xa6,0x08,0x02,0x0d,0x00,0x09,0xaf,0x08,0x05,0x0c,0x00,0x09,
0xb8,0x08,0x05,0x0d,0x00,0x09,0xc1,0x08,0x02,0x0d,0x00,0x09,0xca,0x08,0x02,0x0d,
0x00,0x09,0xd3,0x08,0x02,0x0d,0x00,0x09,0xdc,0x08,0x02,0x0d,0x00,0x09,0xe5,0x08,
0x02,0x0f,0x00,0x09,0xee,0x08,0x03,0x0f,0x00,0x09,0xf7,0x08,0x02,0x0f,0x00,0x09,
0x00,0x09,0x00,0x00,0x00,0x00,
};
@

<<global sizeofdefont>>=
int	sizeofdefont = sizeof defontdata;
@

<<function _unpackinfo>>=
void
_unpackinfo(Fontchar *fc, uchar *p, int n)
{
    int j;

    for(j=0;  j<=n;  j++){
        fc->x = p[0]|(p[1]<<8);
        fc->top = p[2];
        fc->bottom = p[3];
        fc->left = p[4];
        fc->width = p[5];
        fc++;
        p += 6;
    }
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/defont.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<global defontdata>>

<<global sizeofdefont>>

<<function _unpackinfo>>
@


\subsection*{[[lib_graphics/libdraw/draw.c]]}

<<function _setdrawop>>=
void
_setdrawop(Display *d, Drawop op)
{
    uchar *a;

    if(op != SoverD){
        a = bufimage(d, 1+1);
        if(a == 0)
            return;
        a[0] = 'O';
        a[1] = op;
    }
}
@

<<function draw1>>=
static void
draw1(Image *dst, Rectangle *r, Image *src, Point *p0, Image *mask, Point *p1, Drawop op)
{
    uchar *a;

    _setdrawop(dst->display, op);

    a = bufimage(dst->display, 1+4+4+4+4*4+2*4+2*4);
    if(a == 0)
        return;
    if(src == nil)
        src = dst->display->black;
    if(mask == nil)
        mask = dst->display->opaque;
    a[0] = 'd';
    BPLONG(a+1, dst->id);
    BPLONG(a+5, src->id);
    BPLONG(a+9, mask->id);
    BPLONG(a+13, r->min.x);
    BPLONG(a+17, r->min.y);
    BPLONG(a+21, r->max.x);
    BPLONG(a+25, r->max.y);
    BPLONG(a+29, p0->x);
    BPLONG(a+33, p0->y);
    BPLONG(a+37, p1->x);
    BPLONG(a+41, p1->y);
}
@

<<function draw>>=
void
draw(Image *dst, Rectangle r, Image *src, Image *mask, Point p1)
{
    draw1(dst, &r, src, &p1, mask, &p1, SoverD);
}
@

<<function drawop>>=
void
drawop(Image *dst, Rectangle r, Image *src, Image *mask, Point p1, Drawop op)
{
    draw1(dst, &r, src, &p1, mask, &p1, op);
}
@

<<function gendraw>>=
void
gendraw(Image *dst, Rectangle r, Image *src, Point p0, Image *mask, Point p1)
{
    draw1(dst, &r, src, &p0, mask, &p1, SoverD);
}
@

<<function gendrawop>>=
void
gendrawop(Image *dst, Rectangle r, Image *src, Point p0, Image *mask, Point p1, Drawop op)
{
    draw1(dst, &r, src, &p0, mask, &p1, op);
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/draw.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function _setdrawop>>
        
<<function draw1>>

<<function draw>>

<<function drawop>>

<<function gendraw>>

<<function gendrawop>>
@


\subsection*{[[lib_graphics/libdraw/drawrepl.c]]}

<<function drawreplxy>>=
int
drawreplxy(int min, int max, int x)
{
    int sx;

    sx = (x-min)%(max-min);
    if(sx < 0)
        sx += max-min;
    return sx+min;
}
@

<<function drawrepl>>=
Point
drawrepl(Rectangle r, Point p)
{
    p.x = drawreplxy(r.min.x, r.max.x, p.x);
    p.y = drawreplxy(r.min.y, r.max.y, p.y);
    return p;
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/drawrepl.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function drawreplxy>>

<<function drawrepl>>

@


\subsection*{[[lib_graphics/libdraw/egetrect.c]]}

<<constant W>>=
#define	W	Borderwidth
@

<<global tmp>>=
static Image *tmp[4];
@

<<global red>>=
static Image *red;
@

<<global sweep>>=
static Cursor sweep={
    {-7, -7},
    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0x07,
     0xE0, 0x07, 0xE0, 0x07, 0xE3, 0xF7, 0xE3, 0xF7,
     0xE3, 0xE7, 0xE3, 0xF7, 0xE3, 0xFF, 0xE3, 0x7F,
     0xE0, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,},
    {0x00, 0x00, 0x7F, 0xFE, 0x40, 0x02, 0x40, 0x02,
     0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x41, 0xE2,
     0x41, 0xC2, 0x41, 0xE2, 0x41, 0x72, 0x40, 0x38,
     0x40, 0x1C, 0x40, 0x0E, 0x7F, 0xE6, 0x00, 0x00,}
};
@

<<function brects>>=
static
void
brects(Rectangle r, Rectangle rp[4])
{
    if(Dx(r) < 2*W)
        r.max.x = r.min.x+2*W;
    if(Dy(r) < 2*W)
        r.max.y = r.min.y+2*W;
    rp[0] = Rect(r.min.x, r.min.y, r.max.x, r.min.y+W);
    rp[1] = Rect(r.min.x, r.max.y-W, r.max.x, r.max.y);
    rp[2] = Rect(r.min.x, r.min.y+W, r.min.x+W, r.max.y-W);
    rp[3] = Rect(r.max.x-W, r.min.y+W, r.max.x, r.max.y-W);
}
@

<<function egetrect>>=
Rectangle
egetrect(int but, Mouse *m)
{
    Rectangle r, rc;

    but = 1<<(but-1);
    esetcursor(&sweep);
    while(m->buttons)
        *m = emouse();
    while(!(m->buttons & but)){
        *m = emouse();
        if(m->buttons & (7^but))
            goto Return;
    }
    r.min = m->xy;
    r.max = m->xy;
    do{
        rc = canonrect(r);
        edrawgetrect(rc, 1);
        *m = emouse();
        edrawgetrect(rc, 0);
        r.max = m->xy;
    }while(m->buttons == but);

    Return:
    esetcursor(0);
    if(m->buttons & (7^but)){
        rc.min.x = rc.max.x = 0;
        rc.min.y = rc.max.y = 0;
        while(m->buttons)
            *m = emouse();
    }
    return rc;
}
@

<<function freetmp>>=
static
void
freetmp(void)
{
    freeimage(tmp[0]);
    freeimage(tmp[1]);
    freeimage(tmp[2]);
    freeimage(tmp[3]);
    freeimage(red);
    tmp[0] = tmp[1] = tmp[2] = tmp[3] = red = nil;
}
@

<<function edrawgetrect>>=
void
edrawgetrect(Rectangle rc, int up)
{
    int i;
    Rectangle r, rects[4];

    if(up && tmp[0]!=nil)
        if(Dx(tmp[0]->r)<Dx(rc) || Dy(tmp[2]->r)<Dy(rc))
            freetmp();

    if(tmp[0] == 0){
        r = Rect(0, 0, Dx(screen->r), W);
        tmp[0] = allocimage(display, r, screen->chan, 0, -1);
        tmp[1] = allocimage(display, r, screen->chan, 0, -1);
        r = Rect(0, 0, W, Dy(screen->r));
        tmp[2] = allocimage(display, r, screen->chan, 0, -1);
        tmp[3] = allocimage(display, r, screen->chan, 0, -1);
        red = allocimage(display, Rect(0,0,1,1), screen->chan, 1, DRed);
        if(tmp[0]==0 || tmp[1]==0 || tmp[2]==0 || tmp[3]==0 || red==0)
            drawerror(display, "getrect: allocimage failed");
    }
    brects(rc, rects);
    if(!up){
        for(i=0; i<4; i++)
            draw(screen, rects[i], tmp[i], nil, ZP);
        return;
    }
    for(i=0; i<4; i++){
        draw(tmp[i], Rect(0, 0, Dx(rects[i]), Dy(rects[i])), screen, nil, rects[i].min);
        draw(screen, rects[i], red, nil, ZP);
    }
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/egetrect.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <cursor.h>
#include <event.h>

<<constant W>>

<<global tmp>>
<<global red>>

<<global sweep>>

<<function brects>>

<<function egetrect>>

<<function freetmp>>

<<function edrawgetrect>>
@


\subsection*{[[lib_graphics/libdraw/ellipse.c]]}

<<function doellipse>>=
static
void
doellipse(int cmd, Image *dst, Point *c, int xr, int yr, int thick, Image *src, Point *sp, int alpha, int phi, Drawop op)
{
    uchar *a;

    _setdrawop(dst->display, op);

    a = bufimage(dst->display, 1+4+4+2*4+4+4+4+2*4+2*4);
    if(a == 0){
        fprint(2, "image ellipse: %r\n");
        return;
    }
    a[0] = cmd;
    BPLONG(a+1, dst->id);
    BPLONG(a+5, src->id);
    BPLONG(a+9, c->x);
    BPLONG(a+13, c->y);
    BPLONG(a+17, xr);
    BPLONG(a+21, yr);
    BPLONG(a+25, thick);
    BPLONG(a+29, sp->x);
    BPLONG(a+33, sp->y);
    BPLONG(a+37, alpha);
    BPLONG(a+41, phi);
}
@

<<function ellipse>>=
void
ellipse(Image *dst, Point c, int a, int b, int thick, Image *src, Point sp)
{
    doellipse('e', dst, &c, a, b, thick, src, &sp, 0, 0, SoverD);
}
@

<<function ellipseop>>=
void
ellipseop(Image *dst, Point c, int a, int b, int thick, Image *src, Point sp, Drawop op)
{
    doellipse('e', dst, &c, a, b, thick, src, &sp, 0, 0, op);
}
@

<<function fillellipse>>=
void
fillellipse(Image *dst, Point c, int a, int b, Image *src, Point sp)
{
    doellipse('E', dst, &c, a, b, 0, src, &sp, 0, 0, SoverD);
}
@

<<function fillellipseop>>=
void
fillellipseop(Image *dst, Point c, int a, int b, Image *src, Point sp, Drawop op)
{
    doellipse('E', dst, &c, a, b, 0, src, &sp, 0, 0, op);
}
@

<<function arc>>=
void
arc(Image *dst, Point c, int a, int b, int thick, Image *src, Point sp, int alpha, int phi)
{
    alpha |= 1<<31;
    doellipse('e', dst, &c, a, b, thick, src, &sp, alpha, phi, SoverD);
}
@

<<function arcop>>=
void
arcop(Image *dst, Point c, int a, int b, int thick, Image *src, Point sp, int alpha, int phi, Drawop op)
{
    alpha |= 1<<31;
    doellipse('e', dst, &c, a, b, thick, src, &sp, alpha, phi, op);
}
@

<<function fillarc>>=
void
fillarc(Image *dst, Point c, int a, int b, Image *src, Point sp, int alpha, int phi)
{
    alpha |= 1<<31;
    doellipse('E', dst, &c, a, b, 0, src, &sp, alpha, phi, SoverD);
}
@

<<function fillarcop>>=
void
fillarcop(Image *dst, Point c, int a, int b, Image *src, Point sp, int alpha, int phi, Drawop op)
{
    alpha |= 1<<31;
    doellipse('E', dst, &c, a, b, 0, src, &sp, alpha, phi, op);
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/ellipse.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function doellipse>>

<<function ellipse>>

<<function ellipseop>>

<<function fillellipse>>

<<function fillellipseop>>

<<function arc>>

<<function arcop>>

<<function fillarc>>

<<function fillarcop>>
@


\subsection*{[[lib_graphics/libdraw/emenuhit.c]]}

<<enum _anon_ (lib_graphics/libdraw/emenuhit.c)>>=
enum
{
    Margin = 4,		/* outside to text */
    Border = 2,		/* outside to selection boxes */
    Blackborder = 2,	/* width of outlining border */
    Vspacing = 2,		/* extra spacing between lines of text */
    Maxunscroll = 25,	/* maximum #entries before scrolling turns on */
    Nscroll = 20,		/* number entries in scrolling part */
    Scrollwid = 14,		/* width of scroll bar */
    Gap = 4,			/* between text and scroll bar */
};
@

<<global menutxt>>=
static	Image	*menutxt;
@

<<global back>>=
static	Image	*back;
@

<<global high>>=
static	Image	*high;
@

<<global bord>>=
static	Image	*bord;
@

<<global text>>=
static	Image	*text;
@

<<global htext>>=
static	Image	*htext;
@

<<function menucolors>>=
static
void
menucolors(void)
{
    /* Main tone is greenish, with negative selection */
    back = allocimagemix(display, DPalegreen, DWhite);
    high = allocimage(display, Rect(0,0,1,1), CMAP8, 1, DDarkgreen);	/* dark green */
    bord = allocimage(display, Rect(0,0,1,1), CMAP8, 1, DMedgreen);	/* not as dark green */
    if(back==nil || high==nil || bord==nil)
        goto Error;
    text = display->black;
    htext = back;
    return;

    Error:
    freeimage(back);
    freeimage(high);
    freeimage(bord);
    back = display->white;
    high = display->black;
    bord = display->black;
    text = display->black;
    htext = display->white;
}
@

<<function menurect>>=
/*
 * r is a rectangle holding the text elements.
 * return the rectangle, including its black edge, holding element i.
 */
static Rectangle
menurect(Rectangle r, int i)
{
    if(i < 0)
        return Rect(0, 0, 0, 0);
    r.min.y += (font->height+Vspacing)*i;
    r.max.y = r.min.y+font->height+Vspacing;
    return insetrect(r, Border-Margin);
}
@

<<function menusel>>=
/*
 * r is a rectangle holding the text elements.
 * return the element number containing p.
 */
static int
menusel(Rectangle r, Point p)
{
    r = insetrect(r, Margin);
    if(!ptinrect(p, r))
        return -1;
    return (p.y-r.min.y)/(font->height+Vspacing);
}
@

<<function paintitem>>=
static
void
paintitem(Menu *menu, Rectangle textr, int off, int i, int highlight, Image *save, Image *restore)
{
    char *item;
    Rectangle r;
    Point pt;

    if(i < 0)
        return;
    r = menurect(textr, i);
    if(restore){
        draw(screen, r, restore, nil, restore->r.min);
        return;
    }
    if(save)
        draw(save, save->r, screen, nil, r.min);
    item = menu->item? menu->item[i+off] : (*menu->gen)(i+off);
    pt.x = (textr.min.x+textr.max.x-stringwidth(font, item))/2;
    pt.y = textr.min.y+i*(font->height+Vspacing);
    draw(screen, r, highlight? high : back, nil, pt);
    string(screen, pt, highlight? htext : text, pt, font, item);
}
@

<<function menuscan>>=
/*
 * menur is a rectangle holding all the highlightable text elements.
 * track mouse while inside the box, return what's selected when button
 * is raised, -1 as soon as it leaves box.
 * invariant: nothing is highlighted on entry or exit.
 */
static int
menuscan(Menu *menu, int but, Mouse *m, Rectangle textr, int off, int lasti, Image *save)
{
    int i;

    paintitem(menu, textr, off, lasti, 1, save, nil);
    flushimage(display, 1);	/* in case display->locking is set */
    *m = emouse();
    while(m->buttons & (1<<(but-1))){
        flushimage(display, 1);	/* in case display->locking is set */
        *m = emouse();
        i = menusel(textr, m->xy);
        if(i != -1 && i == lasti)
            continue;
        paintitem(menu, textr, off, lasti, 0, nil, save);
        if(i == -1)
            return i;
        lasti = i;
        paintitem(menu, textr, off, lasti, 1, save, nil);
    }
    return lasti;
}
@

<<function menupaint>>=
static void
menupaint(Menu *menu, Rectangle textr, int off, int nitemdrawn)
{
    int i;

    draw(screen, insetrect(textr, Border-Margin), back, nil, ZP);
    for(i = 0; i<nitemdrawn; i++)
        paintitem(menu, textr, off, i, 0, nil, nil);
}
@

<<function menuscrollpaint>>=
static void
menuscrollpaint(Rectangle scrollr, int off, int nitem, int nitemdrawn)
{
    Rectangle r;

    draw(screen, scrollr, back, nil, ZP);
    r.min.x = scrollr.min.x;
    r.max.x = scrollr.max.x;
    r.min.y = scrollr.min.y + (Dy(scrollr)*off)/nitem;
    r.max.y = scrollr.min.y + (Dy(scrollr)*(off+nitemdrawn))/nitem;
    if(r.max.y < r.min.y+2)
        r.max.y = r.min.y+2;
    border(screen, r, 1, bord, ZP);
    if(menutxt == 0)
        menutxt = allocimage(display, Rect(0, 0, 1, 1), CMAP8, 1, DDarkgreen);
    if(menutxt)
        draw(screen, insetrect(r, 1), menutxt, nil, ZP);
}
@

<<function emenuhit>>=
int
emenuhit(int but, Mouse *m, Menu *menu)
{
    int i, nitem, nitemdrawn, maxwid, lasti, off, noff, wid, screenitem;
    int scrolling;
    Rectangle r, menur, sc, textr, scrollr;
    Image *b, *save;
    Point pt;
    char *item;

    if(back == nil)
        menucolors();
    sc = screen->clipr;
    replclipr(screen, 0, screen->r);
    maxwid = 0;
    for(nitem = 0;
        item = menu->item? menu->item[nitem] : (*menu->gen)(nitem);
        nitem++){
        i = stringwidth(font, item);
        if(i > maxwid)
            maxwid = i;
    }
    if(menu->lasthit<0 || menu->lasthit>=nitem)
        menu->lasthit = 0;
    screenitem = (Dy(screen->r)-10)/(font->height+Vspacing);
    if(nitem>Maxunscroll || nitem>screenitem){
        scrolling = 1;
        nitemdrawn = Nscroll;
        if(nitemdrawn > screenitem)
            nitemdrawn = screenitem;
        wid = maxwid + Gap + Scrollwid;
        off = menu->lasthit - nitemdrawn/2;
        if(off < 0)
            off = 0;
        if(off > nitem-nitemdrawn)
            off = nitem-nitemdrawn;
        lasti = menu->lasthit-off;
    }else{
        scrolling = 0;
        nitemdrawn = nitem;
        wid = maxwid;
        off = 0;
        lasti = menu->lasthit;
    }
    r = insetrect(Rect(0, 0, wid, nitemdrawn*(font->height+Vspacing)), -Margin);
    r = rectsubpt(r, Pt(wid/2, lasti*(font->height+Vspacing)+font->height/2));
    r = rectaddpt(r, m->xy);
    pt = ZP;
    if(r.max.x>screen->r.max.x)
        pt.x = screen->r.max.x-r.max.x;
    if(r.max.y>screen->r.max.y)
        pt.y = screen->r.max.y-r.max.y;
    if(r.min.x<screen->r.min.x)
        pt.x = screen->r.min.x-r.min.x;
    if(r.min.y<screen->r.min.y)
        pt.y = screen->r.min.y-r.min.y;
    menur = rectaddpt(r, pt);
    textr.max.x = menur.max.x-Margin;
    textr.min.x = textr.max.x-maxwid;
    textr.min.y = menur.min.y+Margin;
    textr.max.y = textr.min.y + nitemdrawn*(font->height+Vspacing);
    if(scrolling){
        scrollr = insetrect(menur, Border);
        scrollr.max.x = scrollr.min.x+Scrollwid;
    }else
        scrollr = Rect(0, 0, 0, 0);

    b = allocimage(display, menur, screen->chan, 0, 0);
    if(b == 0)
        b = screen;
    draw(b, menur, screen, nil, menur.min);
    draw(screen, menur, back, nil, ZP);
    border(screen, menur, Blackborder, bord, ZP);
    save = allocimage(display, menurect(textr, 0), screen->chan, 0, -1);
    r = menurect(textr, lasti);
    emoveto(divpt(addpt(r.min, r.max), 2));
    menupaint(menu, textr, off, nitemdrawn);
    if(scrolling)
        menuscrollpaint(scrollr, off, nitem, nitemdrawn);
    while(m->buttons & (1<<(but-1))){
        lasti = menuscan(menu, but, m, textr, off, lasti, save);
        if(lasti >= 0)
            break;
        while(!ptinrect(m->xy, textr) && (m->buttons & (1<<(but-1)))){
            if(scrolling && ptinrect(m->xy, scrollr)){
                noff = ((m->xy.y-scrollr.min.y)*nitem)/Dy(scrollr);
                noff -= nitemdrawn/2;
                if(noff < 0)
                    noff = 0;
                if(noff > nitem-nitemdrawn)
                    noff = nitem-nitemdrawn;
                if(noff != off){
                    off = noff;
                    menupaint(menu, textr, off, nitemdrawn);
                    menuscrollpaint(scrollr, off, nitem, nitemdrawn);
                }
            }
            flushimage(display, 1);	/* in case display->locking is set */
            *m = emouse();
        }
    }
    draw(screen, menur, b, nil, menur.min);
    if(b != screen)
        freeimage(b);
    freeimage(save);
    replclipr(screen, 0, sc);
    if(lasti >= 0){
        menu->lasthit = lasti+off;
        return menu->lasthit;
    }
    return -1;
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/emenuhit.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <event.h>

<<enum _anon_ (lib_graphics/libdraw/emenuhit.c)>>

<<global menutxt>>
<<global back>>
<<global high>>
<<global bord>>
<<global text>>
<<global htext>>

<<function menucolors>>

<<function menurect>>

<<function menusel>>

<<function paintitem>>

<<function menuscan>>

<<function menupaint>>

<<function menuscrollpaint>>

<<function emenuhit>>
@


\subsection*{[[lib_graphics/libdraw/event.c]]}

<<struct Slave>>=
struct Slave
{
    int	pid;
    Ebuf	*head;		/* queue of messages for this descriptor */
    Ebuf	*tail;
    int	(*fn)(int, Event*, uchar*, int);
};
@

<<struct Ebuf>>=
struct Ebuf
{
    Ebuf	*next;
    int	n;		/* number of bytes in buf */
    uchar	buf[EMAXMSG];
};
@

<<global eslave>>=
static	Slave	eslave[MAXSLAVE];
@

<<global Skeyboard>>=
static	int	Skeyboard = -1;
@

<<global Smouse>>=
static	int	Smouse = -1;
@

<<global Stimer>>=
static	int	Stimer = -1;
@

<<global logfid>>=
static	int	logfid;
@

<<global nslave>>=
static	int	nslave;
@

<<global parentpid>>=
static	int	parentpid;
@

<<global epipe>>=
static	int	epipe[2];
@

<<global mousefd>>=
static	int	mousefd;
@

<<global cursorfd>>=
static	int	cursorfd;
@

<<function ebread>>=
static
Ebuf*
ebread(Slave *s)
{
    Ebuf *eb;
    Dir *d;
    ulong l;

    for(;;){
        d = dirfstat(epipe[0]);
        if(d == nil)
            drawerror(display, "events: eread stat error");
        l = d->length;
        free(d);
        if(s->head && l==0)
            break;
        extract();
    }
    eb = s->head;
    s->head = s->head->next;
    if(s->head == 0)
        s->tail = 0;
    return eb;
}
@

<<function event>>=
ulong
event(Event *e)
{
    return eread(~0UL, e);
}
@

<<function eread>>=
ulong
eread(ulong keys, Event *e)
{
    Ebuf *eb;
    int i, id;

    if(keys == 0)
        return 0;
    for(;;){
        for(i=0; i<nslave; i++)
            if((keys & (1<<i)) && eslave[i].head){
                id = 1<<i;
                if(i == Smouse)
                    e->mouse = emouse();
                else if(i == Skeyboard)
                    e->kbdc = ekbd();
                else if(i == Stimer)
                    eslave[i].head = 0;
                else{
                    eb = ebread(&eslave[i]);
                    e->n = eb->n;
                    if(eslave[i].fn)
                        id = (*eslave[i].fn)(id, e, eb->buf, eb->n);
                    else
                        memmove(e->data, eb->buf, eb->n);
                    free(eb);
                }
                return id;
            }
        extract();
    }
}
@

<<function ecanmouse>>=
int
ecanmouse(void)
{
    if(Smouse < 0)
        drawerror(display, "events: mouse not initialized");
    return ecanread(Emouse);
}
@

<<function ecankbd>>=
int
ecankbd(void)
{
    if(Skeyboard < 0)
        drawerror(display, "events: keyboard not initialzed");
    return ecanread(Ekeyboard);
}
@

<<function ecanread>>=
int
ecanread(ulong keys)
{
    Dir *d;
    int i;
    ulong l;

    for(;;){
        for(i=0; i<nslave; i++)
            if((keys & (1<<i)) && eslave[i].head)
                return 1;
        d = dirfstat(epipe[0]);
        if(d == nil)
            drawerror(display, "events: ecanread stat error");
        l = d->length;
        free(d);
        if(l == 0)
            return 0;
        extract();
    }
}
@

<<function estartfn>>=
ulong
estartfn(ulong key, int fd, int n, int (*fn)(int, Event*, uchar*, int))
{
    char buf[EMAXMSG+1];
    int i, r;

    if(fd < 0)
        drawerror(display, "events: bad file descriptor");
    if(n <= 0 || n > EMAXMSG)
        n = EMAXMSG;
    i = eforkslave(key);
    if(i < MAXSLAVE){
        eslave[i].fn = fn;
        return 1<<i;
    }
    buf[0] = i - MAXSLAVE;
    while((r = read(fd, buf+1, n))>0)
        if(write(epipe[1], buf, r+1)!=r+1)
            break;
    buf[0] = MAXSLAVE;
    write(epipe[1], buf, 1);
    _exits(0);
    return 0;
}
@

<<function estart>>=
ulong
estart(ulong key, int fd, int n)
{
    return estartfn(key, fd, n, nil);
}
@

<<function etimer>>=
ulong
etimer(ulong key, int n)
{
    char t[2];

    if(Stimer != -1)
        drawerror(display, "events: timer started twice");
    Stimer = eforkslave(key);
    if(Stimer < MAXSLAVE)
        return 1<<Stimer;
    if(n <= 0)
        n = 1000;
    t[0] = t[1] = Stimer - MAXSLAVE;
    do
        sleep(n);
    while(write(epipe[1], t, 2) == 2);
    t[0] = MAXSLAVE;
    write(epipe[1], t, 1);
    _exits(0);
    return 0;
}
@

<<function ekeyslave>>=
static void
ekeyslave(int fd)
{
    Rune r;
    char t[3], k[10];
    int kr, kn, w;

    if(eforkslave(Ekeyboard) < MAXSLAVE)
        return;
    kn = 0;
    t[0] = Skeyboard;
    for(;;){
        while(!fullrune(k, kn)){
            kr = read(fd, k+kn, sizeof k - kn);
            if(kr <= 0)
                goto breakout;
            kn += kr;
        }
        w = chartorune(&r, k);
        kn -= w;
        memmove(k, &k[w], kn);
        t[1] = r;
        t[2] = r>>8;
        if(write(epipe[1], t, 3) != 3)
            break;
    }
breakout:;
    t[0] = MAXSLAVE;
    write(epipe[1], t, 1);
    _exits(0);
}
@

<<function einit>>=
void
einit(ulong keys)
{
    int ctl, fd;
    char buf[256];

    parentpid = getpid();
    if(pipe(epipe) < 0)
        drawerror(display, "events: einit pipe");
    atexit(ekill);
    atnotify(enote, 1);
    snprint(buf, sizeof buf, "%s/mouse", display->devdir);
    mousefd = open(buf, ORDWR|OCEXEC);
    if(mousefd < 0)
        drawerror(display, "einit: can't open mouse\n");
    snprint(buf, sizeof buf, "%s/cursor", display->devdir);
    cursorfd = open(buf, ORDWR|OCEXEC);
    if(cursorfd < 0)
        drawerror(display, "einit: can't open cursor\n");
    if(keys&Ekeyboard){
        snprint(buf, sizeof buf, "%s/cons", display->devdir);
        fd = open(buf, OREAD);
        if(fd < 0)
            drawerror(display, "events: can't open console");
        snprint(buf, sizeof buf, "%s/consctl", display->devdir);
        ctl = open("/dev/consctl", OWRITE|OCEXEC);
        if(ctl < 0)
            drawerror(display, "events: can't open consctl");
        write(ctl, "rawon", 5);
        for(Skeyboard=0; Ekeyboard & ~(1<<Skeyboard); Skeyboard++)
            ;
        ekeyslave(fd);
    }
    if(keys&Emouse){
        estart(Emouse, mousefd, 1+4*12);
        for(Smouse=0; Emouse & ~(1<<Smouse); Smouse++)
            ;
    }
}
@

<<function extract>>=
static void
extract(void)
{
    Slave *s;
    Ebuf *eb;
    int i, n;
    uchar ebuf[EMAXMSG+1];

    /* avoid generating a message if there's nothing to show. */
    /* this test isn't perfect, though; could do flushimage(display, 0) then call extract */
    /* also: make sure we don't interfere if we're multiprocessing the display */
    if(display->locking){
        /* if locking is being done by program, this means it can't depend on automatic flush in emouse() etc. */
        if(canqlock(&display->qlock)){
            if(display->bufp > display->buf)
                flushimage(display, 1);
            unlockdisplay(display);
        }
    }else
        if(display->bufp > display->buf)
            flushimage(display, 1);
loop:
    if((n=read(epipe[0], ebuf, EMAXMSG+1)) < 0
    || ebuf[0] >= MAXSLAVE)
        drawerror(display, "eof on event pipe");
    if(n == 0)
        goto loop;
    i = ebuf[0];
    if(i >= nslave || n <= 1)
        drawerror(display, "events: protocol error: short read");
    s = &eslave[i];
    if(i == Stimer){
        s->head = (Ebuf *)1;
        return;
    }
    if(i == Skeyboard && n != 3)
        drawerror(display, "events: protocol error: keyboard");
    if(i == Smouse){
        if(n < 1+1+2*12)
            drawerror(display, "events: protocol error: mouse");
        if(ebuf[1] == 'r')
            eresized(1);
        /* squash extraneous mouse events */
        if((eb=s->tail) && memcmp(eb->buf+1+2*12, ebuf+1+1+2*12, 12)==0){
            memmove(eb->buf, &ebuf[1], n - 1);
            return;
        }
    }
    /* try to save space by only allocating as much buffer as we need */
    eb = malloc(sizeof(*eb) - sizeof(eb->buf) + n - 1);
    if(eb == 0)
        drawerror(display, "events: protocol error 4");
    eb->n = n - 1;
    memmove(eb->buf, &ebuf[1], n - 1);
    eb->next = 0;
    if(s->head)
        s->tail = s->tail->next = eb;
    else
        s->head = s->tail = eb;
}
@

<<function eforkslave>>=
static int
eforkslave(ulong key)
{
    int i, pid;

    for(i=0; i<MAXSLAVE; i++)
        if((key & ~(1<<i)) == 0 && eslave[i].pid == 0){
            if(nslave <= i)
                nslave = i + 1;
            /*
             * share the file descriptors so the last child
             * out closes all connections to the window server.
             */
            switch(pid = rfork(RFPROC)){
            case 0:
                return MAXSLAVE+i;
            case -1:
                fprint(2, "events: fork error\n");
                exits("fork");
            }
            eslave[i].pid = pid;
            eslave[i].head = eslave[i].tail = 0;
            return i;
        }
    drawerror(display, "events: bad slave assignment");
    return 0;
}
@

<<function enote>>=
static int
enote(void *v, char *s)
{
    char t[1];
    int i, pid;

    USED(v, s);
    pid = getpid();
    if(pid != parentpid){
        for(i=0; i<nslave; i++){
            if(pid == eslave[i].pid){
                t[0] = MAXSLAVE;
                write(epipe[1], t, 1);
                break;
            }
        }
        return 0;
    }
    close(epipe[0]);
    epipe[0] = -1;
    close(epipe[1]);
    epipe[1] = -1;
    for(i=0; i<nslave; i++){
        if(pid == eslave[i].pid)
            continue;	/* don't kill myself */
        postnote(PNPROC, eslave[i].pid, "die");
    }
    return 0;
}
@

<<function ekill>>=
static void
ekill(void)
{
    enote(0, 0);
}
@

<<function emouse>>=
Mouse
emouse(void)
{
    Mouse m;
    Ebuf *eb;
    static int but[2];
    int b;

    if(Smouse < 0)
        drawerror(display, "events: mouse not initialized");
    eb = ebread(&eslave[Smouse]);
    m.xy.x = atoi((char*)eb->buf+1+0*12);
    m.xy.y = atoi((char*)eb->buf+1+1*12);
    b = atoi((char*)eb->buf+1+2*12);
    m.buttons = b;
    m.msec = atoi((char*)eb->buf+1+3*12);
    if (logfid)
        fprint(logfid, "b: %d xy: %P\n", m.buttons, m.xy);
    free(eb);
    return m;
}
@

<<function ekbd>>=
int
ekbd(void)
{
    Ebuf *eb;
    int c;

    if(Skeyboard < 0)
        drawerror(display, "events: keyboard not initialzed");
    eb = ebread(&eslave[Skeyboard]);
    c = eb->buf[0] + (eb->buf[1]<<8);
    free(eb);
    return c;
}
@

<<function emoveto>>=
void
emoveto(Point pt)
{
    char buf[2*12+2];
    int n;

    n = sprint(buf, "m%d %d", pt.x, pt.y);
    write(mousefd, buf, n);
}
@

<<function esetcursor>>=
void
esetcursor(Cursor *c)
{
    uchar curs[2*4+2*2*16];

    if(c == 0)
        write(cursorfd, curs, 0);
    else{
        BPLONG(curs+0*4, c->offset.x);
        BPLONG(curs+1*4, c->offset.y);
        memmove(curs+2*4, c->clr, 2*2*16);
        write(cursorfd, curs, sizeof curs);
    }
}
@

<<function ereadmouse>>=
int
ereadmouse(Mouse *m)
{
    int n;
    char buf[128];

    do{
        n = read(mousefd, buf, sizeof(buf));
        if(n < 0)	/* probably interrupted */
            return -1;
        n = eatomouse(m, buf, n);
    }while(n == 0);
    return n;
}
@

<<function eatomouse>>=
int
eatomouse(Mouse *m, char *buf, int n)
{
    if(n != 1+4*12){
        werrstr("atomouse: bad count");
        return -1;
    }

    if(buf[0] == 'r')
        eresized(1);
    m->xy.x = atoi(buf+1+0*12);
    m->xy.y = atoi(buf+1+1*12);
    m->buttons = atoi(buf+1+2*12);
    m->msec = atoi(buf+1+3*12);
    return n;
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/event.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <cursor.h>
#include <event.h>

typedef struct	Slave Slave;
typedef struct	Ebuf Ebuf;

<<struct Slave>>

<<struct Ebuf>>

<<global eslave>>
<<global Skeyboard>>
<<global Smouse>>
<<global Stimer>>
<<global logfid>>

<<global nslave>>
<<global parentpid>>
<<global epipe>>

static	int	eforkslave(ulong);
static	void	extract(void);
static	void	ekill(void);
static	int	enote(void *, char *);

<<global mousefd>>
<<global cursorfd>>

<<function ebread>>

<<function event>>

<<function eread>>

<<function ecanmouse>>

<<function ecankbd>>

<<function ecanread>>

<<function estartfn>>

<<function estart>>

<<function etimer>>

<<function ekeyslave>>

<<function einit>>

<<function extract>>

<<function eforkslave>>

<<function enote>>

<<function ekill>>

<<function emouse>>

<<function ekbd>>

<<function emoveto>>

<<function esetcursor>>

<<function ereadmouse>>

<<function eatomouse>>
@


\subsection*{[[lib_graphics/libdraw/fmt.c]]}

<<function Rfmt>>=
int
Rfmt(Fmt *f)
{
    Rectangle r;

    r = va_arg(f->args, Rectangle);
    return fmtprint(f, "%P %P", r.min, r.max);
}
@

<<function Pfmt>>=
int
Pfmt(Fmt *f)
{
    Point p;

    p = va_arg(f->args, Point);
    return fmtprint(f, "[%d %d]", p.x, p.y);
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/fmt.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function Rfmt>>

<<function Pfmt>>

@


\subsection*{[[lib_graphics/libdraw/font.c]]}

<<constant PJW>>=
#define	PJW	0	/* use NUL==pjw for invisible characters */
@

<<function cachechars>>=
int
cachechars(Font *f, char **ss, Rune **rr, ushort *cp, int max, int *wp, char **subfontname)
{
    int i, th, sh, h, ld, w, rw, wid, nc;
    char *sp;
    Rune r, *rp, vr;
    ulong a;
    Cacheinfo *c, *tc, *ec;

    if(ss){
        sp = *ss;
        rp = L"";
    }else{
        sp = "";
        rp = *rr;
    }
    wid = 0;
    *subfontname = 0;
    for(i=0; i<max && (*sp || *rp); sp+=w, rp+=rw){
        if(ss){
            r = *(uchar*)sp;
            if(r < Runeself)
                w = 1;
            else{
                w = chartorune(&vr, sp);
                r = vr;
            }
            rw = 0;
        }else{
            r = *rp;
            w = 0;
            rw = 1;
        }

        sh = (17 * (uint)r) & (f->ncache-NFLOOK-1);
        c = &f->cache[sh];
        ec = c+NFLOOK;
        h = sh;
        while(c < ec){
            if(c->value==r && c->age)
                goto Found;
            c++;
            h++;
        }
    
        /*
         * Not found; toss out oldest entry
         */
        a = ~0;
        th = sh;
        tc = &f->cache[th];
        while(tc < ec){
            if(tc->age < a){
                a = tc->age;
                h = th;
                c = tc;
            }
            tc++;
            th++;
        }

        if(a && (f->age-a)<500){	/* kicking out too recent; resize */
            nc = 2*(f->ncache-NFLOOK) + NFLOOK;
            if(nc <= MAXFCACHE){
                if(i == 0)
                    fontresize(f, f->width, nc, f->maxdepth);
                /* else flush first; retry will resize */
                break;
            }
        }

        if(c->age == f->age)	/* flush pending string output */
            break;

        ld = loadchar(f, r, c, h, i, subfontname);
        if(ld <= 0){
            if(ld == 0)
                continue;
            break;
        }
        c = &f->cache[h];	/* may have reallocated f->cache */
    
        Found:
        wid += c->width;
        c->age = f->age;
        cp[i] = h;
        i++;
    }
    if(ss)
        *ss = sp;
    else
        *rr = rp;
    *wp = wid;
    return i;
}
@

<<function agefont>>=
void
agefont(Font *f)
{
    Cacheinfo *c, *ec;
    Cachesubf *s, *es;

    f->age++;
    if(f->age == 65536){
        /*
         * Renormalize ages
         */
        c = f->cache;
        ec = c+f->ncache;
        while(c < ec){
            if(c->age){
                c->age >>= 2;
                c->age++;
            }
            c++;
        }
        s = f->subf;
        es = s+f->nsubf;
        while(s < es){
            if(s->age){
                if(s->age<SUBFAGE && s->cf->name != nil){
                    /* clean up */
                    if(display &&
                        s->f != display->defaultsubfont)
                        freesubfont(s->f);
                    s->cf = nil;
                    s->f = nil;
                    s->age = 0;
                }else{
                    s->age >>= 2;
                    s->age++;
                }
            }
            s++;
        }
        f->age = (65536>>2) + 1;
    }
}
@

<<function cf2subfont>>=
static Subfont*
cf2subfont(Cachefont *cf, Font *f)
{
    int depth;
    char *name;
    Subfont *sf;

    name = cf->subfontname;
    if(name == nil){
        if(f->display && f->display->screenimage)
            depth = f->display->screenimage->depth;
        else
            depth = 8;
        name = subfontname(cf->name, f->name, depth);
        if(name == nil)
            return nil;
        cf->subfontname = name;
    }
    sf = lookupsubfont(f->display, name);
    return sf;
}
@

<<function loadchar>>=
/* return 1 if load succeeded, 0 if failed, -1 if must retry */
int
loadchar(Font *f, Rune r, Cacheinfo *c, int h, int noflush, char **subfontname)
{
    int i, oi, wid, top, bottom;
    Rune pic;
    Fontchar *fi;
    Cachefont *cf;
    Cachesubf *subf, *of;
    uchar *b;

    pic = r;
    Again:
    for(i=0; i<f->nsub; i++){
        cf = f->sub[i];
        if(cf->min<=pic && pic<=cf->max)
            goto Found;
    }
    TryPJW:
    if(pic != PJW){
        pic = PJW;
        goto Again;
    }
    return 0;

    Found:
    /*
     * Choose exact or oldest
     */
    oi = 0;
    subf = &f->subf[0];
    for(i=0; i<f->nsubf; i++){
        if(cf == subf->cf)
            goto Found2;
        if(subf->age < f->subf[oi].age)
            oi = i;
        subf++;
    }
    subf = &f->subf[oi];

    if(subf->f){
        if(f->age-subf->age>SUBFAGE || f->nsubf>MAXSUBF){
    Toss:
            /* ancient data; toss */
            freesubfont(subf->f);
            subf->cf = nil;
            subf->f = nil;
            subf->age = 0;
        }else{				/* too recent; grow instead */
            of = f->subf;
            f->subf = malloc((f->nsubf+DSUBF)*sizeof *subf);
            if(f->subf == nil){
                f->subf = of;
                goto Toss;
            }
            memmove(f->subf, of, (f->nsubf+DSUBF)*sizeof *subf);
            memset(f->subf+f->nsubf, 0, DSUBF*sizeof *subf);
            subf = &f->subf[f->nsubf];
            f->nsubf += DSUBF;
            free(of);
        }
    }
    subf->age = 0;
    subf->cf = nil;
    subf->f = cf2subfont(cf, f);
    if(subf->f == nil){
        if(cf->subfontname == nil)
            goto TryPJW;
        *subfontname = cf->subfontname;
        return -1;
    }

    subf->cf = cf;
    if(subf->f->ascent > f->ascent && f->display){
        /* should print something? this is a mistake in the font file */
        /* must prevent c->top from going negative when loading cache */
        Image *b;
        int d, t;
        d = subf->f->ascent - f->ascent;
        b = subf->f->bits;
        draw(b, b->r, b, nil, addpt(b->r.min, Pt(0, d)));
        draw(b, Rect(b->r.min.x, b->r.max.y-d, b->r.max.x, b->r.max.y), f->display->black, nil, b->r.min);
        for(i=0; i<subf->f->n; i++){
            t = subf->f->info[i].top-d;
            if(t < 0)
                t = 0;
            subf->f->info[i].top = t;
            t = subf->f->info[i].bottom-d;
            if(t < 0)
                t = 0;
            subf->f->info[i].bottom = t;
        }
        subf->f->ascent = f->ascent;
    }

    Found2:
    subf->age = f->age;

    /* possible overflow here, but works out okay */
    pic += cf->offset;
    pic -= cf->min;
    if(pic >= subf->f->n)
        goto TryPJW;
    fi = &subf->f->info[pic];
    if(fi->width == 0)
        goto TryPJW;
    wid = (fi+1)->x - fi->x;
    if(f->width < wid || f->width == 0 || f->maxdepth < subf->f->bits->depth){
        /*
         * Flush, free, reload (easier than reformatting f->b)
         */
        if(noflush)
            return -1;
        if(f->width < wid)
            f->width = wid;
        if(f->maxdepth < subf->f->bits->depth)
            f->maxdepth = subf->f->bits->depth;
        i = fontresize(f, f->width, f->ncache, f->maxdepth);
        if(i <= 0)
            return i;
        /* c is still valid as didn't reallocate f->cache */
    }
    c->value = r;
    top = fi->top + (f->ascent-subf->f->ascent);
    bottom = fi->bottom + (f->ascent-subf->f->ascent);
    c->width = fi->width;
    c->x = h*f->width;
    c->left = fi->left;
    if(f->display == nil)
        return 1;
    flushimage(f->display, 0);	/* flush any pending errors */
    b = bufimage(f->display, 37);
    if(b == 0)
        return 0;
    b[0] = 'l';
    BPLONG(b+1, f->cacheimage->id);
    BPLONG(b+5, subf->f->bits->id);
    BPSHORT(b+9, c-f->cache);
    BPLONG(b+11, c->x);
    BPLONG(b+15, top);
    BPLONG(b+19, c->x+((fi+1)->x-fi->x));
    BPLONG(b+23, bottom);
    BPLONG(b+27, fi->x);
    BPLONG(b+31, fi->top);
    b[35] = fi->left;
    b[36] = fi->width;
    return 1;
}
@

<<function freeup>>=
/* release all subfonts, return number freed */
static
int
freeup(Font *f)
{
    Cachesubf *s, *es;
    int nf;

    if(f->sub[0]->name == nil)	/* font from mkfont; don't free */
        return 0;
    s = f->subf;
    es = s+f->nsubf;
    nf = 0;
    while(s < es){
        if(s->age){
            freesubfont(s->f);
            s->cf = nil;
            s->f = nil;
            s->age = 0;
            nf++;
        }
        s++;
    }
    return nf;
}
@

<<function fontresize>>=
/* return whether resize succeeded && f->cache is unchanged */
static int
fontresize(Font *f, int wid, int ncache, int depth)
{
    Cacheinfo *i;
    int ret;
    Image *new;
    uchar *b;
    Display *d;

    ret = 0;
    if(depth <= 0)
        depth = 1;
    if(wid <= 0)
        wid = 1;

    d = f->display;
    if(d == nil)
        goto Nodisplay;

    new = allocimage(d, Rect(0, 0, ncache*wid, f->height), CHAN1(CGrey, depth), 0, 0);
    if(new == nil){
        fprint(2, "font cache resize failed: %r\n");
        abort();
        goto Return;
    }
    flushimage(d, 0);	/* flush any pending errors */
    b = bufimage(d, 1+4+4+1);
    if(b == 0){
        freeimage(new);
        goto Return;
    }
    b[0] = 'i';
    BPLONG(b+1, new->id);
    BPLONG(b+5, ncache);
    b[9] = f->ascent;
    if(flushimage(d, 0) < 0){
        fprint(2, "resize: init failed: %r\n");
        freeimage(new);
        goto Return;
    }
    freeimage(f->cacheimage);
    f->cacheimage = new;
    Nodisplay:
    f->width = wid;
    f->maxdepth = depth;
    ret = 1;
    if(f->ncache != ncache){
        i = malloc(ncache*sizeof f->cache[0]);
        if(i != nil){
            ret = 0;
            free(f->cache);
            f->ncache = ncache;
            f->cache = i;
        }
        /* else just wipe the cache clean and things will be ok */
    }
    Return:
    memset(f->cache, 0, f->ncache*sizeof f->cache[0]);
    return ret;
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/font.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

static int	fontresize(Font*, int, int, int);
static int	freeup(Font*);

<<constant PJW>>

<<function cachechars>>

<<function agefont>>

<<function cf2subfont>>

<<function loadchar>>

<<function freeup>>

<<function fontresize>>
@


\subsection*{[[lib_graphics/libdraw/freesubfont.c]]}

<<function freesubfont>>=
void
freesubfont(Subfont *f)
{
    if(f == 0)
        return;
    f->ref--;
    if(f->ref > 0)
        return;
    uninstallsubfont(f);
    free(f->info);	/* note: f->info must have been malloc'ed! */
    freeimage(f->bits);
    free(f);
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/freesubfont.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function freesubfont>>
@


\subsection*{[[lib_graphics/libdraw/getdefont.c]]}

<<function getdefont>>=
Subfont*
getdefont(Display *d)
{
    char *hdr, *p;
    int n;
    Fontchar *fc;
    Subfont *f;
    int ld;
    Rectangle r;
    Image *i;

    /*
     * make sure data is word-aligned.  this is true with Plan 9 compilers
     * but not in general.  the byte order is right because the data is
     * declared as char*, not ulong*.
     */
    p = (char*)defontdata;
    n = (int)(uvlong)p & 3;				/* stupid ape */
    if(n != 0){
        memmove(p+(4-n), p, sizeofdefont-n);
        p += 4-n;
    }
    ld = atoi(p+0*12);
    r.min.x = atoi(p+1*12);
    r.min.y = atoi(p+2*12);
    r.max.x = atoi(p+3*12);
    r.max.y = atoi(p+4*12);

    i = allocimage(d, r, drawld2chan[ld], 0, 0);
    if(i == 0)
        return 0;

    p += 5*12;
    n = loadimage(i, r, (uchar*)p, (defontdata+sizeofdefont)-(uchar*)p);
    if(n < 0){
        freeimage(i);
        return 0;
    }

    hdr = p+n;
    n = atoi(hdr);
    p = hdr+3*12;
    fc = malloc(sizeof(Fontchar)*(n+1));
    if(fc == 0){
        freeimage(i);
        return 0;
    }
    _unpackinfo(fc, (uchar*)p, n);
    f = allocsubfont("*default*", n, atoi(hdr+12), atoi(hdr+24), fc, i);
    if(f == 0){
        freeimage(i);
        free(fc);
        return 0;
    }
    return f;
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/getdefont.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function getdefont>>
@


\subsection*{[[lib_graphics/libdraw/getrect.c]]}

<<constant W (lib_graphics/libdraw/getrect.c)>>=
#define	W	Borderwidth
@

<<global tmp (lib_graphics/libdraw/getrect.c)>>=
static Image *tmp[4];
@

<<global red (lib_graphics/libdraw/getrect.c)>>=
static Image *red;
@

<<global sweep (lib_graphics/libdraw/getrect.c)>>=
static Cursor sweep={
    {-7, -7},
    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0x07,
     0xE0, 0x07, 0xE0, 0x07, 0xE3, 0xF7, 0xE3, 0xF7,
     0xE3, 0xE7, 0xE3, 0xF7, 0xE3, 0xFF, 0xE3, 0x7F,
     0xE0, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,},
    {0x00, 0x00, 0x7F, 0xFE, 0x40, 0x02, 0x40, 0x02,
     0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x41, 0xE2,
     0x41, 0xC2, 0x41, 0xE2, 0x41, 0x72, 0x40, 0x38,
     0x40, 0x1C, 0x40, 0x0E, 0x7F, 0xE6, 0x00, 0x00,}
};
@

<<function brects (lib_graphics/libdraw/getrect.c)>>=
static
void
brects(Rectangle r, Rectangle rp[4])
{
    if(Dx(r) < 2*W)
        r.max.x = r.min.x+2*W;
    if(Dy(r) < 2*W)
        r.max.y = r.min.y+2*W;
    rp[0] = Rect(r.min.x, r.min.y, r.max.x, r.min.y+W);
    rp[1] = Rect(r.min.x, r.max.y-W, r.max.x, r.max.y);
    rp[2] = Rect(r.min.x, r.min.y+W, r.min.x+W, r.max.y-W);
    rp[3] = Rect(r.max.x-W, r.min.y+W, r.max.x, r.max.y-W);
}
@

<<function getrect>>=
Rectangle
getrect(int but, Mousectl *mc)
{
    Rectangle r, rc;

    but = 1<<(but-1);
    setcursor(mc, &sweep);
    while(mc->buttons)
        readmouse(mc);
    while(!(mc->buttons & but)){
        readmouse(mc);
        if(mc->buttons & (7^but))
            goto Return;
    }
    r.min = mc->xy;
    r.max = mc->xy;
    do{
        rc = canonrect(r);
        drawgetrect(rc, 1);
        readmouse(mc);
        drawgetrect(rc, 0);
        r.max = mc->xy;
    }while(mc->buttons == but);

    Return:
    setcursor(mc, nil);
    if(mc->buttons & (7^but)){
        rc.min.x = rc.max.x = 0;
        rc.min.y = rc.max.y = 0;
        while(mc->buttons)
            readmouse(mc);
    }
    return rc;
}
@

<<function freetmp (lib_graphics/libdraw/getrect.c)>>=
static
void
freetmp(void)
{
    freeimage(tmp[0]);
    freeimage(tmp[1]);
    freeimage(tmp[2]);
    freeimage(tmp[3]);
    freeimage(red);
    tmp[0] = tmp[1] = tmp[2] = tmp[3] = red = nil;
}
@

<<function max>>=
static
int
max(int a, int b)
{
    if(a > b)
        return a;
    return b;
}
@

<<function drawgetrect>>=
void
drawgetrect(Rectangle rc, int up)
{
    int i;
    Rectangle r, rects[4];

    /*
     * BUG: if for some reason we have two of these going on at once
     * when we must grow the tmp buffers, we lose data.  Also if tmp
     * is unallocated and we ask to restore the screen, it would be nice
     * to complain, but we silently make a mess.
     */
    if(up && tmp[0]!=nil)
        if(Dx(tmp[0]->r)<Dx(rc) || Dy(tmp[2]->r)<Dy(rc))
            freetmp();
    if(tmp[0] == 0){
        r = Rect(0, 0, max(Dx(display->screenimage->r), Dx(rc)), W);
        tmp[0] = allocimage(display, r, screen->chan, 0, -1);
        tmp[1] = allocimage(display, r, screen->chan, 0, -1);
        r = Rect(0, 0, W, max(Dy(display->screenimage->r), Dy(rc)));
        tmp[2] = allocimage(display, r, screen->chan, 0, -1);
        tmp[3] = allocimage(display, r, screen->chan, 0, -1);
        red = allocimage(display, Rect(0,0,1,1), screen->chan, 1, DRed);
        if(tmp[0]==0 || tmp[1]==0 || tmp[2]==0 || tmp[3]==0 || red==0){
            freetmp();
            drawerror(display, "getrect: allocimage failed");
        }
    }
    brects(rc, rects);
    if(!up){
        for(i=0; i<4; i++)
            draw(screen, rects[i], tmp[i], nil, ZP);
        return;
    }
    for(i=0; i<4; i++){
        draw(tmp[i], Rect(0, 0, Dx(rects[i]), Dy(rects[i])), screen, nil, rects[i].min);
        draw(screen, rects[i], red, nil, ZP);
    }
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/getrect.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <cursor.h>
#include <mouse.h>

<<constant W (lib_graphics/libdraw/getrect.c)>>

<<global tmp (lib_graphics/libdraw/getrect.c)>>
<<global red (lib_graphics/libdraw/getrect.c)>>

<<global sweep (lib_graphics/libdraw/getrect.c)>>

<<function brects (lib_graphics/libdraw/getrect.c)>>

<<function getrect>>

<<function freetmp (lib_graphics/libdraw/getrect.c)>>

<<function max>>

<<function drawgetrect>>
@


\subsection*{[[lib_graphics/libdraw/getsubfont.c]]}

<<function _getsubfont>>=
/*
 * Default version: treat as file name
 */

Subfont*
_getsubfont(Display *d, char *name)
{
    int fd;
    Subfont *f;

    fd = open(name, OREAD);
        
    if(fd < 0){
        fprint(2, "getsubfont: can't open %s: %r\n", name);
        return 0;
    }
    /*
     * unlock display so i/o happens with display released, unless
     * user is doing his own locking, in which case this could break things.
     * _getsubfont is called only from string.c and stringwidth.c,
     * which are known to be safe to have this done.
     */
    if(d && d->locking == 0)
        unlockdisplay(d);
    f = readsubfont(d, name, fd, d && d->locking==0);
    if(d && d->locking == 0)
        lockdisplay(d);
    if(f == 0)
        fprint(2, "getsubfont: can't read %s: %r\n", name);
    close(fd);
    setmalloctag(f, getcallerpc(&d));
    return f;
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/getsubfont.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function _getsubfont>>
@


\subsection*{[[lib_graphics/libdraw/icossin.c]]}

<<global sinus>>=
/*
 * Integer sine and cosine for integral degree argument.
 * Tables computed by (sin,cos)(PI*d/180).
 */
static short sinus[91] = {
    0,	/* 0 */
    18,	/* 1 */
    36,	/* 2 */
    54,	/* 3 */
    71,	/* 4 */
    89,	/* 5 */
    107,	/* 6 */
    125,	/* 7 */
    143,	/* 8 */
    160,	/* 9 */
    178,	/* 10 */
    195,	/* 11 */
    213,	/* 12 */
    230,	/* 13 */
    248,	/* 14 */
    265,	/* 15 */
    282,	/* 16 */
    299,	/* 17 */
    316,	/* 18 */
    333,	/* 19 */
    350,	/* 20 */
    367,	/* 21 */
    384,	/* 22 */
    400,	/* 23 */
    416,	/* 24 */
    433,	/* 25 */
    449,	/* 26 */
    465,	/* 27 */
    481,	/* 28 */
    496,	/* 29 */
    512,	/* 30 */
    527,	/* 31 */
    543,	/* 32 */
    558,	/* 33 */
    573,	/* 34 */
    587,	/* 35 */
    602,	/* 36 */
    616,	/* 37 */
    630,	/* 38 */
    644,	/* 39 */
    658,	/* 40 */
    672,	/* 41 */
    685,	/* 42 */
    698,	/* 43 */
    711,	/* 44 */
    724,	/* 45 */
    737,	/* 46 */
    749,	/* 47 */
    761,	/* 48 */
    773,	/* 49 */
    784,	/* 50 */
    796,	/* 51 */
    807,	/* 52 */
    818,	/* 53 */
    828,	/* 54 */
    839,	/* 55 */
    849,	/* 56 */
    859,	/* 57 */
    868,	/* 58 */
    878,	/* 59 */
    887,	/* 60 */
    896,	/* 61 */
    904,	/* 62 */
    912,	/* 63 */
    920,	/* 64 */
    928,	/* 65 */
    935,	/* 66 */
    943,	/* 67 */
    949,	/* 68 */
    956,	/* 69 */
    962,	/* 70 */
    968,	/* 71 */
    974,	/* 72 */
    979,	/* 73 */
    984,	/* 74 */
    989,	/* 75 */
    994,	/* 76 */
    998,	/* 77 */
    1002,	/* 78 */
    1005,	/* 79 */
    1008,	/* 80 */
    1011,	/* 81 */
    1014,	/* 82 */
    1016,	/* 83 */
    1018,	/* 84 */
    1020,	/* 85 */
    1022,	/* 86 */
    1023,	/* 87 */
    1023,	/* 88 */
    1024,	/* 89 */
    1024,	/* 90 */
};
@

<<function icossin>>=
void
icossin(int deg, int *cosp, int *sinp)
{
    int sinsign, cossign;
    short *stp, *ctp;

    deg %= 360;
    if(deg < 0)
        deg += 360;
    sinsign = 1;
    cossign = 1;
    stp = 0;
    ctp = 0;
    switch(deg/90){
    case 2:
        sinsign = -1;
        cossign = -1;
        deg -= 180;
        /* fall through */
    case 0:
        stp = &sinus[deg];
        ctp = &sinus[90-deg];
        break;
    case 3:
        sinsign = -1;
        cossign = -1;
        deg -= 180;
        /* fall through */
    case 1:
        deg = 180-deg;
        cossign = -cossign;
        stp = &sinus[deg];
        ctp = &sinus[90-deg];
        break;
    }
    *sinp = sinsign*stp[0];
    *cosp = cossign*ctp[0];
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/icossin.c>>=
#include	<u.h>
#include	<libc.h>
#include	<draw.h>

<<global sinus>>

<<function icossin>>
@


\subsection*{[[lib_graphics/libdraw/icossin2.c]]}

<<global sinus (lib_graphics/libdraw/icossin2.c)>>=
/*
 * Sine and Cosine of arctangents, calculated by 
 *   (sin(atan(index/100.0))*1024.+0.5)
 *   (cos(atan(index/100.0))*1024.+0.5)
 * To use, get rational tangent between 0<=tan<=1, scale by 100,
 * and look up sin and cos, and use linear interpolation.  divide by 1024.
 * Maximum error is 0.0020.  Without linear interpolation, it's 0.010.
 */
static
short sinus[] = {
    0,	/* 0.00 */
    10,	/* 0.01 */
    20,	/* 0.02 */
    31,	/* 0.03 */
    41,	/* 0.04 */
    51,	/* 0.05 */
    61,	/* 0.06 */
    72,	/* 0.07 */
    82,	/* 0.08 */
    92,	/* 0.09 */
    102,	/* 0.10 */
    112,	/* 0.11 */
    122,	/* 0.12 */
    132,	/* 0.13 */
    142,	/* 0.14 */
    152,	/* 0.15 */
    162,	/* 0.16 */
    172,	/* 0.17 */
    181,	/* 0.18 */
    191,	/* 0.19 */
    201,	/* 0.20 */
    210,	/* 0.21 */
    220,	/* 0.22 */
    230,	/* 0.23 */
    239,	/* 0.24 */
    248,	/* 0.25 */
    258,	/* 0.26 */
    267,	/* 0.27 */
    276,	/* 0.28 */
    285,	/* 0.29 */
    294,	/* 0.30 */
    303,	/* 0.31 */
    312,	/* 0.32 */
    321,	/* 0.33 */
    330,	/* 0.34 */
    338,	/* 0.35 */
    347,	/* 0.36 */
    355,	/* 0.37 */
    364,	/* 0.38 */
    372,	/* 0.39 */
    380,	/* 0.40 */
    388,	/* 0.41 */
    397,	/* 0.42 */
    405,	/* 0.43 */
    412,	/* 0.44 */
    420,	/* 0.45 */
    428,	/* 0.46 */
    436,	/* 0.47 */
    443,	/* 0.48 */
    451,	/* 0.49 */
    458,	/* 0.50 */
    465,	/* 0.51 */
    472,	/* 0.52 */
    480,	/* 0.53 */
    487,	/* 0.54 */
    493,	/* 0.55 */
    500,	/* 0.56 */
    507,	/* 0.57 */
    514,	/* 0.58 */
    520,	/* 0.59 */
    527,	/* 0.60 */
    533,	/* 0.61 */
    540,	/* 0.62 */
    546,	/* 0.63 */
    552,	/* 0.64 */
    558,	/* 0.65 */
    564,	/* 0.66 */
    570,	/* 0.67 */
    576,	/* 0.68 */
    582,	/* 0.69 */
    587,	/* 0.70 */
    593,	/* 0.71 */
    598,	/* 0.72 */
    604,	/* 0.73 */
    609,	/* 0.74 */
    614,	/* 0.75 */
    620,	/* 0.76 */
    625,	/* 0.77 */
    630,	/* 0.78 */
    635,	/* 0.79 */
    640,	/* 0.80 */
    645,	/* 0.81 */
    649,	/* 0.82 */
    654,	/* 0.83 */
    659,	/* 0.84 */
    663,	/* 0.85 */
    668,	/* 0.86 */
    672,	/* 0.87 */
    676,	/* 0.88 */
    681,	/* 0.89 */
    685,	/* 0.90 */
    689,	/* 0.91 */
    693,	/* 0.92 */
    697,	/* 0.93 */
    701,	/* 0.94 */
    705,	/* 0.95 */
    709,	/* 0.96 */
    713,	/* 0.97 */
    717,	/* 0.98 */
    720,	/* 0.99 */
    724,	/* 1.00 */
    728,	/* 1.01 */
};
@

<<global cosinus>>=
static
short cosinus[] = {
    1024,	/* 0.00 */
    1024,	/* 0.01 */
    1024,	/* 0.02 */
    1024,	/* 0.03 */
    1023,	/* 0.04 */
    1023,	/* 0.05 */
    1022,	/* 0.06 */
    1022,	/* 0.07 */
    1021,	/* 0.08 */
    1020,	/* 0.09 */
    1019,	/* 0.10 */
    1018,	/* 0.11 */
    1017,	/* 0.12 */
    1015,	/* 0.13 */
    1014,	/* 0.14 */
    1013,	/* 0.15 */
    1011,	/* 0.16 */
    1010,	/* 0.17 */
    1008,	/* 0.18 */
    1006,	/* 0.19 */
    1004,	/* 0.20 */
    1002,	/* 0.21 */
    1000,	/* 0.22 */
    998,	/* 0.23 */
    996,	/* 0.24 */
    993,	/* 0.25 */
    991,	/* 0.26 */
    989,	/* 0.27 */
    986,	/* 0.28 */
    983,	/* 0.29 */
    981,	/* 0.30 */
    978,	/* 0.31 */
    975,	/* 0.32 */
    972,	/* 0.33 */
    969,	/* 0.34 */
    967,	/* 0.35 */
    963,	/* 0.36 */
    960,	/* 0.37 */
    957,	/* 0.38 */
    954,	/* 0.39 */
    951,	/* 0.40 */
    947,	/* 0.41 */
    944,	/* 0.42 */
    941,	/* 0.43 */
    937,	/* 0.44 */
    934,	/* 0.45 */
    930,	/* 0.46 */
    927,	/* 0.47 */
    923,	/* 0.48 */
    920,	/* 0.49 */
    916,	/* 0.50 */
    912,	/* 0.51 */
    909,	/* 0.52 */
    905,	/* 0.53 */
    901,	/* 0.54 */
    897,	/* 0.55 */
    893,	/* 0.56 */
    890,	/* 0.57 */
    886,	/* 0.58 */
    882,	/* 0.59 */
    878,	/* 0.60 */
    874,	/* 0.61 */
    870,	/* 0.62 */
    866,	/* 0.63 */
    862,	/* 0.64 */
    859,	/* 0.65 */
    855,	/* 0.66 */
    851,	/* 0.67 */
    847,	/* 0.68 */
    843,	/* 0.69 */
    839,	/* 0.70 */
    835,	/* 0.71 */
    831,	/* 0.72 */
    827,	/* 0.73 */
    823,	/* 0.74 */
    819,	/* 0.75 */
    815,	/* 0.76 */
    811,	/* 0.77 */
    807,	/* 0.78 */
    804,	/* 0.79 */
    800,	/* 0.80 */
    796,	/* 0.81 */
    792,	/* 0.82 */
    788,	/* 0.83 */
    784,	/* 0.84 */
    780,	/* 0.85 */
    776,	/* 0.86 */
    773,	/* 0.87 */
    769,	/* 0.88 */
    765,	/* 0.89 */
    761,	/* 0.90 */
    757,	/* 0.91 */
    754,	/* 0.92 */
    750,	/* 0.93 */
    746,	/* 0.94 */
    742,	/* 0.95 */
    739,	/* 0.96 */
    735,	/* 0.97 */
    731,	/* 0.98 */
    728,	/* 0.99 */
    724,	/* 1.00 */
    720,	/* 1.01 */
};
@

<<function icossin2>>=
void
icossin2(int x, int y, int *cosp, int *sinp)
{
    int sinsign, cossign, tan, tan10, rem;
    short *stp, *ctp;

    if(x == 0){
        if(y >= 0)
            *sinp = ICOSSCALE, *cosp = 0;
        else
            *sinp = -ICOSSCALE, *cosp = 0;
        return;
    }
    sinsign = cossign = 1;
    if(x < 0){
        cossign = -1;
        x = -x;
    }
    if(y < 0){
        sinsign = -1;
        y = -y;
    }
    if(y > x){
        tan = 1000*x/y;
        tan10 = tan/10;
        stp = &cosinus[tan10];
        ctp = &sinus[tan10];
    }else{
        tan = 1000*y/x;
        tan10 = tan/10;
        stp = &sinus[tan10];
        ctp = &cosinus[tan10];
    }
    rem = tan-(tan10*10);
    *sinp = sinsign*(stp[0]+(stp[1]-stp[0])*rem/10);
    *cosp = cossign*(ctp[0]+(ctp[1]-ctp[0])*rem/10);
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/icossin2.c>>=
#include	<u.h>
#include	<libc.h>
#include	<draw.h>

<<global sinus (lib_graphics/libdraw/icossin2.c)>>

<<global cosinus>>

<<function icossin2>>
@


\subsection*{[[lib_graphics/libdraw/init.c]]}

<<global display>>=
Display	*display;
@

<<global font>>=
Font	*font;
@

<<global screen>>=
Image	*screen;
@

<<global _drawdebug>>=
int	_drawdebug = 0;
@

<<global deffontname>>=
static char deffontname[] = "*default*";
@

<<global _screen>>=
Screen	*_screen;
@

<<global debuglockdisplay>>=
int		debuglockdisplay = 0;
@

<<function drawshutdown>>=
/* note handler */
static void
drawshutdown(void)
{
    Display *d;

    d = display;
    if(d){
        display = nil;
        _closedisplay(d, 1);
    }
}
@

<<function geninitdraw>>=
int
geninitdraw(char *devdir, void(*error)(Display*, char*), char *fontname, char *label, char *windir, int ref)
{
    int fd, n;
    Subfont *df;
    char buf[128];

    display = initdisplay(devdir, windir, error);
    if(display == nil)
        return -1;

    /*
     * Set up default font
     */
    df = getdefont(display);
    display->defaultsubfont = df;
    if(df == nil){
        fprint(2, "imageinit: can't open default subfont: %r\n");
    Error:
        closedisplay(display);
        display = nil;
        return -1;
    }
    if(fontname == nil){
        fd = open("/env/font", OREAD);
        if(fd >= 0){
            n = read(fd, buf, sizeof(buf));
            if(n>0 && n<sizeof buf-1){
                buf[n] = 0;
                fontname = buf;
            }
            close(fd);
        }
    }
    /*
     * Build fonts with caches==depth of screen, for speed.
     * If conversion were faster, we'd use 0 and save memory.
     */
    if(fontname == nil){
        snprint(buf, sizeof buf, "%d %d\n0 %d\t%s\n", df->height, df->ascent,
            df->n-1, deffontname);
//BUG: Need something better for this	installsubfont("*default*", df);
        font = buildfont(display, buf, deffontname);
        if(font == nil){
            fprint(2, "imageinit: can't open default font: %r\n");
            goto Error;
        }
    }else{
        font = openfont(display, fontname);	/* BUG: grey fonts */
        if(font == nil){
            fprint(2, "imageinit: can't open font %s: %r\n", fontname);
            goto Error;
        }
    }
    display->defaultfont = font;

    /*
     * Write label; ignore errors (we might not be running under rio)
     */
    if(label){
        snprint(buf, sizeof buf, "%s/label", display->windir);
        fd = open(buf, OREAD);
        if(fd >= 0){
            read(fd, display->oldlabel, (sizeof display->oldlabel)-1);
            close(fd);
            fd = create(buf, OWRITE, 0666);
            if(fd >= 0){
                write(fd, label, strlen(label));
                close(fd);
            }
        }
    }

    snprint(buf, sizeof buf, "%s/winname", display->windir);
    if(gengetwindow(display, buf, &screen, &_screen, ref) < 0)
        goto Error;

    atexit(drawshutdown);

    return 1;
}
@

<<function initdraw>>=
int
initdraw(void(*error)(Display*, char*), char *fontname , char *label)
{
    char *dev = "/dev";

    if(access("/dev/draw/new", AEXIST)<0 && bind("#i", "/dev", MAFTER)<0){
        fprint(2, "imageinit: can't bind /dev/draw: %r\n");
        return -1;
    }
    return geninitdraw(dev, error, fontname, label, dev, Refnone);
}
@

<<function gengetwindow>>=
/*
 * Attach, or possibly reattach, to window.
 * If reattaching, maintain value of screen pointer.
 */
int
gengetwindow(Display *d, char *winname, Image **winp, Screen **scrp, int ref)
{
    int n, fd;
    char buf[64+1];
    Image *image;
    Rectangle r;

    fd = open(winname, OREAD);
    if(fd<0 || (n=read(fd, buf, sizeof buf-1))<=0){
        if((image=d->image) == nil){
            fprint(2, "gengetwindow: %r\n");
            *winp = nil;
            d->screenimage = nil;
            return -1;
        }
        strcpy(buf, "noborder");
    }else{
        close(fd);
        buf[n] = '\0';
        if(*winp != nil){
            _freeimage1(*winp);
            freeimage((*scrp)->image);
            freescreen(*scrp);
            *scrp = nil;
        }
        image = namedimage(d, buf);
        if(image == 0){
            fprint(2, "namedimage %s failed: %r\n", buf);
            *winp = nil;
            d->screenimage = nil;
            return -1;
        }
        assert(image->chan != 0);
    }

    d->screenimage = image;
    *scrp = allocscreen(image, d->white, 0);
    if(*scrp == nil){
        freeimage(d->screenimage);
        *winp = nil;
        d->screenimage = nil;
        return -1;
    }

    r = image->r;
    if(strncmp(buf, "noborder", 8) != 0)
        r = insetrect(image->r, Borderwidth);
    *winp = _allocwindow(*winp, *scrp, r, ref, DWhite);
    if(*winp == nil){
        freescreen(*scrp);
        *scrp = nil;
        freeimage(image);
        d->screenimage = nil;
        return -1;
    }
    d->screenimage = *winp;
    assert((*winp)->chan != 0);
    return 1;
}
@

<<function getwindow>>=
int
getwindow(Display *d, int ref)
{
    char winname[128];

    snprint(winname, sizeof winname, "%s/winname", d->windir);
    return gengetwindow(d, winname, &screen, &_screen, ref);
}
@

<<constant NINFO>>=
#define	NINFO	12*12
@

<<function initdisplay>>=
Display*
initdisplay(char *dev, char *win, void(*error)(Display*, char*))
{
    char buf[128], info[NINFO+1], *t, isnew;
    int n, datafd, ctlfd, reffd;
    Display *disp;
    Dir *dir;
    Image *image;

    fmtinstall('P', Pfmt);
    fmtinstall('R', Rfmt);
    if(dev == 0)
        dev = "/dev";
    if(win == 0)
        win = "/dev";
    if(strlen(dev)>sizeof buf-25 || strlen(win)>sizeof buf-25){
        werrstr("initdisplay: directory name too long");
        return nil;
    }
    t = strdup(win);
    if(t == nil)
        return nil;

    sprint(buf, "%s/draw/new", dev);
    ctlfd = open(buf, ORDWR|OCEXEC);
    if(ctlfd < 0){
        if(bind("#i", dev, MAFTER) < 0){
    Error1:
            free(t);
            werrstr("initdisplay: %s: %r", buf);
            return 0;
        }
        ctlfd = open(buf, ORDWR|OCEXEC);
    }
    if(ctlfd < 0)
        goto Error1;
    if((n=read(ctlfd, info, sizeof info)) < 12){
    Error2:
        close(ctlfd);
        goto Error1;
    }
    if(n==NINFO+1)
        n = NINFO;
    info[n] = '\0';
    isnew = 0;
    if(n < NINFO)	/* this will do for now, we need something better here */
        isnew = 1;
    sprint(buf, "%s/draw/%d/data", dev, atoi(info+0*12));
    datafd = open(buf, ORDWR|OCEXEC);
    if(datafd < 0)
        goto Error2;
    sprint(buf, "%s/draw/%d/refresh", dev, atoi(info+0*12));
    reffd = open(buf, OREAD|OCEXEC);
    if(reffd < 0){
    Error3:
        close(datafd);
        goto Error2;
    }
    disp = mallocz(sizeof(Display), 1);
    if(disp == 0){
    Error4:
        close(reffd);
        goto Error3;
    }
    image = nil;
    if(0){
    Error5:
        free(image);
        free(disp);
        goto Error4;
    }
    if(n >= NINFO){
        image = mallocz(sizeof(Image), 1);
        if(image == nil)
            goto Error5;
        image->display = disp;
        image->id = 0;
        image->chan = strtochan(info+2*12);
        image->depth = chantodepth(image->chan);
        image->repl = atoi(info+3*12);
        image->r.min.x = atoi(info+4*12);
        image->r.min.y = atoi(info+5*12);
        image->r.max.x = atoi(info+6*12);
        image->r.max.y = atoi(info+7*12);
        image->clipr.min.x = atoi(info+8*12);
        image->clipr.min.y = atoi(info+9*12);
        image->clipr.max.x = atoi(info+10*12);
        image->clipr.max.y = atoi(info+11*12);
    }

    disp->_isnewdisplay = isnew;
    disp->bufsize = iounit(datafd);
    if(disp->bufsize <= 0)
        disp->bufsize = 8000;
    if(disp->bufsize < 512){
        werrstr("iounit %d too small", disp->bufsize);
        goto Error5;
    }
    disp->buf = malloc(disp->bufsize+5);	/* +5 for flush message */
    if(disp->buf == nil)
        goto Error5;

    disp->image = image;
    disp->dirno = atoi(info+0*12);
    disp->fd = datafd;
    disp->ctlfd = ctlfd;
    disp->reffd = reffd;
    disp->bufp = disp->buf;
    disp->error = error;
    disp->windir = t;
    disp->devdir = strdup(dev);
    qlock(&disp->qlock);
    disp->white = allocimage(disp, Rect(0, 0, 1, 1), GREY1, 1, DWhite);
    disp->black = allocimage(disp, Rect(0, 0, 1, 1), GREY1, 1, DBlack);
    if(disp->white == nil || disp->black == nil){
        free(disp->devdir);
        free(disp->white);
        free(disp->black);
        goto Error5;
    }
    disp->opaque = disp->white;
    disp->transparent = disp->black;
    dir = dirfstat(ctlfd);
    if(dir!=nil && dir->type=='i'){
        disp->local = 1;
        disp->dataqid = dir->qid.path;
    }
    if(dir!=nil && dir->qid.vers==1)	/* other way to tell */
        disp->_isnewdisplay = 1;
    free(dir);

    return disp;
}
@

<<function closedisplay>>=
/*
 * Call with d unlocked.
 * Note that disp->defaultfont and defaultsubfont are not freed here.
 */
void
closedisplay(Display *disp)
{
    _closedisplay(disp, 0);
}
@

<<function _closedisplay>>=
static void
_closedisplay(Display *disp, int isshutdown)
{
    int fd;
    char buf[128];

    if(disp == nil)
        return;
    if(disp == display)
        display = nil;
    if(disp->oldlabel[0]){
        snprint(buf, sizeof buf, "%s/label", disp->windir);
        fd = open(buf, OWRITE);
        if(fd >= 0){
            write(fd, disp->oldlabel, strlen(disp->oldlabel));
            close(fd);
        }
    }

    /*
     * if we're shutting down, don't free all the resources.
     * if other procs are getting shot down by notes too,
     * one might get shot down while holding the malloc lock.
     * just let the kernel clean things up when we exit.
     */
    if(isshutdown)
        return;

    free(disp->devdir);
    free(disp->windir);
    freeimage(disp->white);
    freeimage(disp->black);
    close(disp->fd);
    close(disp->ctlfd);
    /* should cause refresh slave to shut down */
    close(disp->reffd);
    qunlock(&disp->qlock);
    free(disp);
}
@

<<function lockdisplay>>=
void
lockdisplay(Display *disp)
{
    if(debuglockdisplay){
        /* avoid busy looping; it's rare we collide anyway */
        while(!canqlock(&disp->qlock)){
            fprint(1, "proc %d waiting for display lock...\n", getpid());
            sleep(1000);
        }
    }else
        qlock(&disp->qlock);
}
@

<<function unlockdisplay>>=
void
unlockdisplay(Display *disp)
{
    qunlock(&disp->qlock);
}
@

<<function drawerror>>=
void
drawerror(Display *d, char *s)
{
    char err[ERRMAX];

    if(d && d->error)
        d->error(d, s);
    else{
        errstr(err, sizeof err);
        fprint(2, "draw: %s: %s\n", s, err);
        exits(s);
    }
}
@

<<function doflush>>=
static
int
doflush(Display *d)
{
    int n, nn;

    n = d->bufp-d->buf;
    if(n <= 0)
        return 1;

    if((nn=write(d->fd, d->buf, n)) != n){
        if(_drawdebug)
            fprint(2, "flushimage fail: d=%p: n=%d nn=%d %r\n", d, n, nn); /**/
        d->bufp = d->buf;	/* might as well; chance of continuing */
        return -1;
    }
    d->bufp = d->buf;
    return 1;
}
@

<<function flushimage>>=
int
flushimage(Display *d, int visible)
{
    if(d == nil)
        return 0;
    if(visible){
        *d->bufp++ = 'v';	/* five bytes always reserved for this */
        if(d->_isnewdisplay){
            BPLONG(d->bufp, d->screenimage->id);
            d->bufp += 4;
        }
    }
    return doflush(d);
}
@

<<function bufimage>>=
uchar*
bufimage(Display *d, int n)
{
    uchar *p;

    if(n<0 || n>d->bufsize){
        werrstr("bad count in bufimage");
        return 0;
    }
    if(d->bufp+n > d->buf+d->bufsize)
        if(doflush(d) < 0)
            return 0;
    p = d->bufp;
    d->bufp += n;
    return p;
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/init.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<global display>>
<<global font>>
<<global screen>>
<<global _drawdebug>>

<<global deffontname>>
<<global _screen>>

<<global debuglockdisplay>>

static void _closedisplay(Display*, int);

<<function drawshutdown>>

<<function geninitdraw>>

<<function initdraw>>

<<function gengetwindow>>

<<function getwindow>>

<<constant NINFO>>

<<function initdisplay>>

<<function closedisplay>>

<<function _closedisplay>>

<<function lockdisplay>>

<<function unlockdisplay>>

<<function drawerror>>

<<function doflush>>

<<function flushimage>>

<<function bufimage>>

@


\subsection*{[[lib_graphics/libdraw/keyboard.c]]}

<<function closekeyboard>>=
void
closekeyboard(Keyboardctl *kc)
{
    if(kc == nil)
        return;

    postnote(PNPROC, kc->pid, "kill");

//#ifdef BUG
//	/* Drain the channel */
//	while(?kc->c)
//		<-kc->c;
//#endif

    close(kc->ctlfd);
    close(kc->consfd);
    free(kc->file);
    free(kc->c);
    free(kc);
}
@

<<function _ioproc>>=
static
void
_ioproc(void *arg)
{
    int m, n;
    char buf[20];
    Rune r;
    Keyboardctl *kc;

    kc = arg;
    threadsetname("kbdproc");
    kc->pid = getpid();
    n = 0;
    for(;;){
        while(n>0 && fullrune(buf, n)){
            m = chartorune(&r, buf);
            n -= m;
            memmove(buf, buf+m, n);
            send(kc->c, &r);
        }
        m = read(kc->consfd, buf+n, sizeof buf-n);
        if(m <= 0){
            yield();	/* if error is due to exiting, we'll exit here */
            fprint(2, "keyboard read error: %r\n");
            threadexits("error");
        }
        n += m;
    }
}
@

<<function initkeyboard>>=
Keyboardctl*
initkeyboard(char *file)
{
    Keyboardctl *kc;
    char *t;

    kc = mallocz(sizeof(Keyboardctl), 1);
    if(kc == nil)
        return nil;
    if(file == nil)
        file = "/dev/cons";
    kc->file = strdup(file);
    kc->consfd = open(file, ORDWR|OCEXEC);
    t = malloc(strlen(file)+16);
    if(kc->consfd<0 || t==nil){
Error1:
        free(kc);
        return nil;
    }
    sprint(t, "%sctl", file);
    kc->ctlfd = open(t, OWRITE|OCEXEC);
    if(kc->ctlfd < 0){
        fprint(2, "initkeyboard: can't open %s: %r\n", t);
Error2:
        close(kc->consfd);
        free(t);
        goto Error1;
    }
    if(ctlkeyboard(kc, "rawon") < 0){
        fprint(2, "initkeyboard: can't turn on raw mode on %s: %r\n", t);
        close(kc->ctlfd);
        goto Error2;
    }
    free(t);
    kc->c = chancreate(sizeof(Rune), 20);
    proccreate(_ioproc, kc, 4096);
    return kc;
}
@

<<function ctlkeyboard>>=
int
ctlkeyboard(Keyboardctl *kc, char *m)
{
    return write(kc->ctlfd, m, strlen(m));
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/keyboard.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <keyboard.h>


<<function closekeyboard>>

<<function _ioproc>>

<<function initkeyboard>>

<<function ctlkeyboard>>
@


\subsection*{[[lib_graphics/libdraw/line.c]]}

<<function line>>=
void
line(Image *dst, Point p0, Point p1, int end0, int end1, int radius, Image *src, Point sp)
{
    lineop(dst, p0, p1, end0, end1, radius, src, sp, SoverD);
}
@

<<function lineop>>=
void
lineop(Image *dst, Point p0, Point p1, int end0, int end1, int radius, Image *src, Point sp, Drawop op)
{
    uchar *a;

    _setdrawop(dst->display, op);

    a = bufimage(dst->display, 1+4+2*4+2*4+4+4+4+4+2*4);
    if(a == 0){
        fprint(2, "image line: %r\n");
        return;
    }
    a[0] = 'L';
    BPLONG(a+1, dst->id);
    BPLONG(a+5, p0.x);
    BPLONG(a+9, p0.y);
    BPLONG(a+13, p1.x);
    BPLONG(a+17, p1.y);
    BPLONG(a+21, end0);
    BPLONG(a+25, end1);
    BPLONG(a+29, radius);
    BPLONG(a+33, src->id);
    BPLONG(a+37, sp.x);
    BPLONG(a+41, sp.y);
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/line.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function line>>

<<function lineop>>
@


\subsection*{[[lib_graphics/libdraw/loadimage.c]]}

<<function loadimage>>=
int
loadimage(Image *i, Rectangle r, uchar *data, int ndata)
{
    long dy;
    int n, bpl;
    uchar *a;
    int chunk;

    chunk = i->display->bufsize - 64;

    if(!rectinrect(r, i->r)){
        werrstr("loadimage: bad rectangle");
        return -1;
    }
    bpl = bytesperline(r, i->depth);
    n = bpl*Dy(r);
    if(n > ndata){
        werrstr("loadimage: insufficient data");
        return -1;
    }
    ndata = 0;
    while(r.max.y > r.min.y){
        dy = r.max.y - r.min.y;
        if(dy*bpl > chunk)
            dy = chunk/bpl;
        if(dy <= 0){
            werrstr("loadimage: image too wide for buffer");
            return -1;
        }
        n = dy*bpl;
        a = bufimage(i->display, 21+n);
        if(a == nil){
            werrstr("bufimage failed");
            return -1;
        }
        a[0] = 'y';
        BPLONG(a+1, i->id);
        BPLONG(a+5, r.min.x);
        BPLONG(a+9, r.min.y);
        BPLONG(a+13, r.max.x);
        BPLONG(a+17, r.min.y+dy);
        memmove(a+21, data, n);
        ndata += n;
        data += n;
        r.min.y += dy;
    }
    if(flushimage(i->display, 0) < 0)
        return -1;
    return ndata;
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/loadimage.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function loadimage>>
@


\subsection*{[[lib_graphics/libdraw/menuhit.c]]}

<<enum _anon_ (lib_graphics/libdraw/menuhit.c)>>=
enum
{
    Margin = 4,		/* outside to text */
    Border = 2,		/* outside to selection boxes */
    Blackborder = 2,	/* width of outlining border */
    Vspacing = 2,		/* extra spacing between lines of text */
    Maxunscroll = 25,	/* maximum #entries before scrolling turns on */
    Nscroll = 20,		/* number entries in scrolling part */
    Scrollwid = 14,		/* width of scroll bar */
    Gap = 4,			/* between text and scroll bar */
};
@

<<global menutxt (lib_graphics/libdraw/menuhit.c)>>=
static	Image	*menutxt;
@

<<global back (lib_graphics/libdraw/menuhit.c)>>=
static	Image	*back;
@

<<global high (lib_graphics/libdraw/menuhit.c)>>=
static	Image	*high;
@

<<global bord (lib_graphics/libdraw/menuhit.c)>>=
static	Image	*bord;
@

<<global text (lib_graphics/libdraw/menuhit.c)>>=
static	Image	*text;
@

<<global htext (lib_graphics/libdraw/menuhit.c)>>=
static	Image	*htext;
@

<<function menucolors (lib_graphics/libdraw/menuhit.c)>>=
static
void
menucolors(void)
{
    /* Main tone is greenish, with negative selection */
    back = allocimagemix(display, DPalegreen, DWhite);
    high = allocimage(display, Rect(0,0,1,1), screen->chan, 1, DDarkgreen);	/* dark green */
    bord = allocimage(display, Rect(0,0,1,1), screen->chan, 1, DMedgreen);	/* not as dark green */
    if(back==nil || high==nil || bord==nil)
        goto Error;
    text = display->black;
    htext = back;
    return;

    Error:
    freeimage(back);
    freeimage(high);
    freeimage(bord);
    back = display->white;
    high = display->black;
    bord = display->black;
    text = display->black;
    htext = display->white;
}
@

<<function menurect (lib_graphics/libdraw/menuhit.c)>>=
/*
 * r is a rectangle holding the text elements.
 * return the rectangle, including its black edge, holding element i.
 */
static Rectangle
menurect(Rectangle r, int i)
{
    if(i < 0)
        return Rect(0, 0, 0, 0);
    r.min.y += (font->height+Vspacing)*i;
    r.max.y = r.min.y+font->height+Vspacing;
    return insetrect(r, Border-Margin);
}
@

<<function menusel (lib_graphics/libdraw/menuhit.c)>>=
/*
 * r is a rectangle holding the text elements.
 * return the element number containing p.
 */
static int
menusel(Rectangle r, Point p)
{
    r = insetrect(r, Margin);
    if(!ptinrect(p, r))
        return -1;
    return (p.y-r.min.y)/(font->height+Vspacing);
}
@

<<function paintitem (lib_graphics/libdraw/menuhit.c)>>=
static
void
paintitem(Image *m, Menu *menu, Rectangle textr, int off, int i, int highlight, Image *save, Image *restore)
{
    char *item;
    Rectangle r;
    Point pt;

    if(i < 0)
        return;
    r = menurect(textr, i);
    if(restore){
        draw(m, r, restore, nil, restore->r.min);
        return;
    }
    if(save)
        draw(save, save->r, m, nil, r.min);
    item = menu->item? menu->item[i+off] : (*menu->gen)(i+off);
    pt.x = (textr.min.x+textr.max.x-stringwidth(font, item))/2;
    pt.y = textr.min.y+i*(font->height+Vspacing);
    draw(m, r, highlight? high : back, nil, pt);
    string(m, pt, highlight? htext : text, pt, font, item);
}
@

<<function menuscan (lib_graphics/libdraw/menuhit.c)>>=
/*
 * menur is a rectangle holding all the highlightable text elements.
 * track mouse while inside the box, return what's selected when button
 * is raised, -1 as soon as it leaves box.
 * invariant: nothing is highlighted on entry or exit.
 */
static int
menuscan(Image *m, Menu *menu, int but, Mousectl *mc, Rectangle textr, int off, int lasti, Image *save)
{
    int i;

    paintitem(m, menu, textr, off, lasti, 1, save, nil);
    for(readmouse(mc); mc->buttons & (1<<(but-1)); readmouse(mc)){
        i = menusel(textr, mc->xy);
        if(i != -1 && i == lasti)
            continue;
        paintitem(m, menu, textr, off, lasti, 0, nil, save);
        if(i == -1)
            return i;
        lasti = i;
        paintitem(m, menu, textr, off, lasti, 1, save, nil);
    }
    return lasti;
}
@

<<function menupaint (lib_graphics/libdraw/menuhit.c)>>=
static void
menupaint(Image *m, Menu *menu, Rectangle textr, int off, int nitemdrawn)
{
    int i;

    draw(m, insetrect(textr, Border-Margin), back, nil, ZP);
    for(i = 0; i<nitemdrawn; i++)
        paintitem(m, menu, textr, off, i, 0, nil, nil);
}
@

<<function menuscrollpaint (lib_graphics/libdraw/menuhit.c)>>=
static void
menuscrollpaint(Image *m, Rectangle scrollr, int off, int nitem, int nitemdrawn)
{
    Rectangle r;

    draw(m, scrollr, back, nil, ZP);
    r.min.x = scrollr.min.x;
    r.max.x = scrollr.max.x;
    r.min.y = scrollr.min.y + (Dy(scrollr)*off)/nitem;
    r.max.y = scrollr.min.y + (Dy(scrollr)*(off+nitemdrawn))/nitem;
    if(r.max.y < r.min.y+2)
        r.max.y = r.min.y+2;
    border(m, r, 1, bord, ZP);
    if(menutxt == 0)
        menutxt = allocimage(display, Rect(0, 0, 1, 1), screen->chan, 1, DDarkgreen);	/* border color; BUG? */
    if(menutxt)
        draw(m, insetrect(r, 1), menutxt, nil, ZP);
}
@

<<function menuhit>>=
int
menuhit(int but, Mousectl *mc, Menu *menu, Screen *scr)
{
    int i, nitem, nitemdrawn, maxwid, lasti, off, noff, wid, screenitem;
    int scrolling;
    Rectangle r, menur, sc, textr, scrollr;
    Image *b, *save, *backup;
    Point pt;
    char *item;

    if(back == nil)
        menucolors();
    sc = screen->clipr;
    replclipr(screen, 0, screen->r);
    maxwid = 0;
    for(nitem = 0;
        item = menu->item? menu->item[nitem] : (*menu->gen)(nitem);
        nitem++){
        i = stringwidth(font, item);
        if(i > maxwid)
            maxwid = i;
    }
    if(menu->lasthit<0 || menu->lasthit>=nitem)
        menu->lasthit = 0;
    screenitem = (Dy(screen->r)-10)/(font->height+Vspacing);
    if(nitem>Maxunscroll || nitem>screenitem){
        scrolling = 1;
        nitemdrawn = Nscroll;
        if(nitemdrawn > screenitem)
            nitemdrawn = screenitem;
        wid = maxwid + Gap + Scrollwid;
        off = menu->lasthit - nitemdrawn/2;
        if(off < 0)
            off = 0;
        if(off > nitem-nitemdrawn)
            off = nitem-nitemdrawn;
        lasti = menu->lasthit-off;
    }else{
        scrolling = 0;
        nitemdrawn = nitem;
        wid = maxwid;
        off = 0;
        lasti = menu->lasthit;
    }
    r = insetrect(Rect(0, 0, wid, nitemdrawn*(font->height+Vspacing)), -Margin);
    r = rectsubpt(r, Pt(wid/2, lasti*(font->height+Vspacing)+font->height/2));
    r = rectaddpt(r, mc->xy);
    pt = ZP;
    if(r.max.x>screen->r.max.x)
        pt.x = screen->r.max.x-r.max.x;
    if(r.max.y>screen->r.max.y)
        pt.y = screen->r.max.y-r.max.y;
    if(r.min.x<screen->r.min.x)
        pt.x = screen->r.min.x-r.min.x;
    if(r.min.y<screen->r.min.y)
        pt.y = screen->r.min.y-r.min.y;
    menur = rectaddpt(r, pt);
    textr.max.x = menur.max.x-Margin;
    textr.min.x = textr.max.x-maxwid;
    textr.min.y = menur.min.y+Margin;
    textr.max.y = textr.min.y + nitemdrawn*(font->height+Vspacing);
    if(scrolling){
        scrollr = insetrect(menur, Border);
        scrollr.max.x = scrollr.min.x+Scrollwid;
    }else
        scrollr = Rect(0, 0, 0, 0);

    if(scr){
        b = allocwindow(scr, menur, Refbackup, DWhite);
        if(b == nil)
            b = screen;
        backup = nil;
    }else{
        b = screen;
        backup = allocimage(display, menur, screen->chan, 0, -1);
        if(backup)
            draw(backup, menur, screen, nil, menur.min);
    }
    draw(b, menur, back, nil, ZP);
    border(b, menur, Blackborder, bord, ZP);
    save = allocimage(display, menurect(textr, 0), screen->chan, 0, -1);
    r = menurect(textr, lasti);
    moveto(mc, divpt(addpt(r.min, r.max), 2));
    menupaint(b, menu, textr, off, nitemdrawn);
    if(scrolling)
        menuscrollpaint(b, scrollr, off, nitem, nitemdrawn);
    while(mc->buttons & (1<<(but-1))){
        lasti = menuscan(b, menu, but, mc, textr, off, lasti, save);
        if(lasti >= 0)
            break;
        while(!ptinrect(mc->xy, textr) && (mc->buttons & (1<<(but-1)))){
            if(scrolling && ptinrect(mc->xy, scrollr)){
                noff = ((mc->xy.y-scrollr.min.y)*nitem)/Dy(scrollr);
                noff -= nitemdrawn/2;
                if(noff < 0)
                    noff = 0;
                if(noff > nitem-nitemdrawn)
                    noff = nitem-nitemdrawn;
                if(noff != off){
                    off = noff;
                    menupaint(b, menu, textr, off, nitemdrawn);
                    menuscrollpaint(b, scrollr, off, nitem, nitemdrawn);
                }
            }
            readmouse(mc);
        }
    }
    if(b != screen)
        freeimage(b);
    if(backup){
        draw(screen, menur, backup, nil, menur.min);
        freeimage(backup);
    }
    freeimage(save);
    replclipr(screen, 0, sc);
    flushimage(display, 1);
    if(lasti >= 0){
        menu->lasthit = lasti+off;
        return menu->lasthit;
    }
    return -1;
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/menuhit.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <mouse.h>

<<enum _anon_ (lib_graphics/libdraw/menuhit.c)>>

<<global menutxt (lib_graphics/libdraw/menuhit.c)>>
<<global back (lib_graphics/libdraw/menuhit.c)>>
<<global high (lib_graphics/libdraw/menuhit.c)>>
<<global bord (lib_graphics/libdraw/menuhit.c)>>
<<global text (lib_graphics/libdraw/menuhit.c)>>
<<global htext (lib_graphics/libdraw/menuhit.c)>>

<<function menucolors (lib_graphics/libdraw/menuhit.c)>>

<<function menurect (lib_graphics/libdraw/menuhit.c)>>

<<function menusel (lib_graphics/libdraw/menuhit.c)>>

<<function paintitem (lib_graphics/libdraw/menuhit.c)>>

<<function menuscan (lib_graphics/libdraw/menuhit.c)>>

<<function menupaint (lib_graphics/libdraw/menuhit.c)>>

<<function menuscrollpaint (lib_graphics/libdraw/menuhit.c)>>

<<function menuhit>>
@


\subsection*{[[lib_graphics/libdraw/mkfont.c]]}

<<function mkfont>>=
/*
 * Cobble fake font using existing subfont
 */
Font*
mkfont(Subfont *subfont, Rune min)
{
    Font *font;
    Cachefont *c;

    font = malloc(sizeof(Font));
    if(font == 0)
        return 0;
    memset(font, 0, sizeof(Font));
    font->display = subfont->bits->display;
    font->name = strdup("<synthetic>");
    font->ncache = NFCACHE+NFLOOK;
    font->nsubf = NFSUBF;
    font->cache = malloc(font->ncache * sizeof(font->cache[0]));
    font->subf = malloc(font->nsubf * sizeof(font->subf[0]));
    if(font->name==0 || font->cache==0 || font->subf==0){
    Err:
        free(font->name);
        free(font->cache);
        free(font->subf);
        free(font->sub);
        free(font);
        return 0;
    }
    memset(font->cache, 0, font->ncache*sizeof(font->cache[0]));
    memset(font->subf, 0, font->nsubf*sizeof(font->subf[0]));
    font->height = subfont->height;
    font->ascent = subfont->ascent;
    font->age = 1;
    font->sub = malloc(sizeof(Cachefont*));
    if(font->sub == 0)
        goto Err;
    c = malloc(sizeof(Cachefont));
    if(c == 0)
        goto Err;
    font->nsub = 1;
    font->sub[0] = c;
    c->min = min;
    c->max = min+subfont->n-1;
    c->offset = 0;
    c->name = 0;	/* noticed by freeup() and agefont() */
    c->subfontname = 0;
    font->subf[0].age = 0;
    font->subf[0].cf = c;
    font->subf[0].f = subfont;
    return font;
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/mkfont.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function mkfont>>
@


\subsection*{[[lib_graphics/libdraw/mouse.c]]}

<<function moveto>>=
void
moveto(Mousectl *m, Point pt)
{
    fprint(m->mfd, "m%d %d", pt.x, pt.y);
    m->xy = pt;
}
@

<<function closemouse>>=
void
closemouse(Mousectl *mc)
{
    if(mc == nil)
        return;

    postnote(PNPROC, mc->pid, "kill");

    do; while(nbrecv(mc->c, &mc->Mouse) > 0);

    close(mc->mfd);
    close(mc->cfd);
    free(mc->file);
    free(mc->c);
    free(mc->resizec);
    free(mc);
}
@

<<function readmouse>>=
int
readmouse(Mousectl *mc)
{
    if(mc->image)
        flushimage(mc->image->display, 1);
    if(recv(mc->c, &mc->Mouse) < 0){
        fprint(2, "readmouse: %r\n");
        return -1;
    }
    return 0;
}
@

<<function _ioproc (lib_graphics/libdraw/mouse.c)>>=
static
void
_ioproc(void *arg)
{
    int n, nerr, one;
    char buf[1+5*12];
    Mouse m;
    Mousectl *mc;

    mc = arg;
    threadsetname("mouseproc");
    one = 1;
    memset(&m, 0, sizeof m);
    mc->pid = getpid();
    nerr = 0;
    for(;;){
        n = read(mc->mfd, buf, sizeof buf);
        if(n != 1+4*12){
            yield();	/* if error is due to exiting, we'll exit here */
            fprint(2, "mouse: bad count %d not 49: %r\n", n);
            if(n<0 || ++nerr>10)
                threadexits("read error");
            continue;
        }
        nerr = 0;
        switch(buf[0]){
        case 'r':
            send(mc->resizec, &one);
            /* fall through */
        case 'm':
            m.xy.x = atoi(buf+1+0*12);
            m.xy.y = atoi(buf+1+1*12);
            m.buttons = atoi(buf+1+2*12);
            m.msec = atoi(buf+1+3*12);
            send(mc->c, &m);
            /*
             * mc->Mouse is updated after send so it doesn't have wrong value if we block during send.
             * This means that programs should receive into mc->Mouse (see readmouse() above) if
             * they want full synchrony.
             */
            mc->Mouse = m;
            break;
        }
    }
}
@

<<function initmouse>>=
Mousectl*
initmouse(char *file, Image *i)
{
    Mousectl *mc;
    char *t, *sl;

    mc = mallocz(sizeof(Mousectl), 1);
    if(file == nil)
        file = "/dev/mouse";
    mc->file = strdup(file);
    mc->mfd = open(file, ORDWR|OCEXEC);
    if(mc->mfd<0 && strcmp(file, "/dev/mouse")==0){
        bind("#m", "/dev", MAFTER);
        mc->mfd = open(file, ORDWR|OCEXEC);
    }
    if(mc->mfd < 0){
        free(mc);
        return nil;
    }
    t = malloc(strlen(file)+16);
    if (t == nil) {
        close(mc->mfd);
        free(mc);
        return nil;
    }
    strcpy(t, file);
    sl = utfrrune(t, '/');
    if(sl)
        strcpy(sl, "/cursor");
    else
        strcpy(t, "/dev/cursor");
    mc->cfd = open(t, ORDWR|OCEXEC);
    free(t);
    mc->image = i;
    mc->c = chancreate(sizeof(Mouse), 0);
    mc->resizec = chancreate(sizeof(int), 2);
    proccreate(_ioproc, mc, 4096);
    return mc;
}
@

<<function setcursor>>=
void
setcursor(Mousectl *mc, Cursor *c)
{
    char curs[2*4+2*2*16];

    if(c == nil)
        write(mc->cfd, curs, 0);
    else{
        BPLONG(curs+0*4, c->offset.x);
        BPLONG(curs+1*4, c->offset.y);
        memmove(curs+2*4, c->clr, 2*2*16);
        write(mc->cfd, curs, sizeof curs);
    }
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/mouse.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <cursor.h>
#include <mouse.h>

<<function moveto>>

<<function closemouse>>

<<function readmouse>>

<<function _ioproc (lib_graphics/libdraw/mouse.c)>>

<<function initmouse>>

<<function setcursor>>
@


\subsection*{[[lib_graphics/libdraw/newwindow.c]]}

<<function newwindow>>=
/* Connect us to new window, if possible */
int
newwindow(char *str)
{
    int fd;
    char *wsys;
    char buf[256];

    wsys = getenv("wsys");
    if(wsys == nil)
        return -1;
    fd = open(wsys, ORDWR);
    free(wsys);
    if(fd < 0)
        return -1;
    rfork(RFNAMEG);
    if(str)
        snprint(buf, sizeof buf, "new %s", str);
    else
        strcpy(buf, "new");
    return mount(fd, -1, "/dev", MBEFORE, buf);
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/newwindow.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function newwindow>>

@


\subsection*{[[lib_graphics/libdraw/openfont.c]]}

<<function openfont>>=
Font*
openfont(Display *d, char *name)
{
    Font *fnt;
    int fd, i, n;
    char *buf;
    Dir *dir;

    fd = open(name, OREAD);
    if(fd < 0)
        return 0;

    dir = dirfstat(fd);
    if(dir == nil){
    Err0:
        close(fd);
        return 0;
    }
    n = dir->length;
    free(dir);
    buf = malloc(n+1);
    if(buf == 0)
        goto Err0;
    buf[n] = 0;
    i = read(fd, buf, n);
    close(fd);
    if(i != n){
        free(buf);
        return 0;
    }
    fnt = buildfont(d, buf, name);
    free(buf);
    return fnt;
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/openfont.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function openfont>>
@


\subsection*{[[lib_graphics/libdraw/poly.c]]}

<<function addcoord>>=
static
uchar*
addcoord(uchar *p, int oldx, int newx)
{
    int dx;

    dx = newx-oldx;
    /* does dx fit in 7 signed bits? */
    if((unsigned)(dx - -0x40) <= 0x7F)
        *p++ = dx&0x7F;
    else{
        *p++ = 0x80 | (newx&0x7F);
        *p++ = newx>>7;
        *p++ = newx>>15;
    }
    return p;
}
@

<<function dopoly>>=
static
void
dopoly(int cmd, Image *dst, Point *pp, int np, int end0, int end1, int radius, Image *src, Point *sp, Drawop op)
{
    uchar *a, *t, *u;
    int i, ox, oy;

    if(np == 0)
        return;
    t = malloc(np*2*3);
    if(t == nil)
        return;
    u = t;
    ox = oy = 0;
    for(i=0; i<np; i++){
        u = addcoord(u, ox, pp[i].x);
        ox = pp[i].x;
        u = addcoord(u, oy, pp[i].y);
        oy = pp[i].y;
    }

    _setdrawop(dst->display, op);

    a = bufimage(dst->display, 1+4+2+4+4+4+4+2*4+(u-t));
    if(a == 0){
        free(t);
        fprint(2, "image poly: %r\n");
        return;
    }
    a[0] = cmd;
    BPLONG(a+1, dst->id);
    BPSHORT(a+5, np-1);
    BPLONG(a+7, end0);
    BPLONG(a+11, end1);
    BPLONG(a+15, radius);
    BPLONG(a+19, src->id);
    BPLONG(a+23, sp->x);
    BPLONG(a+27, sp->y);
    memmove(a+31, t, u-t);
    free(t);
}
@

<<function poly>>=
void
poly(Image *dst, Point *p, int np, int end0, int end1, int radius, Image *src, Point sp)
{
    dopoly('p', dst, p, np, end0, end1, radius, src, &sp, SoverD);
}
@

<<function polyop>>=
void
polyop(Image *dst, Point *p, int np, int end0, int end1, int radius, Image *src, Point sp, Drawop op)
{
    dopoly('p', dst, p, np, end0, end1, radius, src, &sp, op);
}
@

<<function fillpoly>>=
void
fillpoly(Image *dst, Point *p, int np, int wind, Image *src, Point sp)
{
    dopoly('P', dst, p, np, wind, 0, 0, src, &sp, SoverD);
}
@

<<function fillpolyop>>=
void
fillpolyop(Image *dst, Point *p, int np, int wind, Image *src, Point sp, Drawop op)
{
    dopoly('P', dst, p, np, wind, 0, 0, src, &sp, op);
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/poly.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function addcoord>>

<<function dopoly>>

<<function poly>>

<<function polyop>>

<<function fillpoly>>

<<function fillpolyop>>
@


\subsection*{[[lib_graphics/libdraw/readcolmap.c]]}

<<function getval>>=
static ulong
getval(char **p)
{
    ulong v;
    char *q;

    v = strtoul(*p, &q, 0);
    v |= v<<8;
    v |= v<<16;
    *p = q;
    return v;
}
@

<<function readcolmap>>=
void
readcolmap(Display *d, RGB *colmap)
{
    int i;
    char *p, *q;
    Biobuf *b;
    char buf[128];

    USED(screen);

    sprint(buf, "/dev/draw/%d/colormap", d->dirno);
    b = Bopen(buf, OREAD);
    if(b == 0)
        drawerror(d, "rdcolmap: can't open colormap device");

    for(;;) {
        p = Brdline(b, '\n');
        if(p == 0)
            break;
        i = strtoul(p, &q, 0);
        if(i < 0 || i > 255) {
            fprint(2, "rdcolmap: bad index\n");
            exits("bad");
        }
        p = q;
        colmap[255-i].red = getval(&p);
        colmap[255-i].green = getval(&p);
        colmap[255-i].blue = getval(&p);
    }
    Bterm(b);
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/readcolmap.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <bio.h>

<<function getval>>

<<function readcolmap>>
@


\subsection*{[[lib_graphics/libdraw/readimage.c]]}

<<function readimage>>=
Image*
readimage(Display *d, int fd, int dolock)
{
    char hdr[5*12+1];
    int dy;
    int new;
    uint l, n;
    int m, j, chunk;
    int miny, maxy;
    Rectangle r;
    int ldepth;
    ulong chan;
    uchar *tmp;
    Image *i;

    if(readn(fd, hdr, 11) != 11)
        return nil;
    if(memcmp(hdr, "compressed\n", 11) == 0)
        return creadimage(d, fd, dolock);
    if(readn(fd, hdr+11, 5*12-11) != 5*12-11)
        return nil;
    if(d)
        chunk = d->bufsize - 32;	/* a little room for header */
    else
        chunk = 8192;

    /*
     * distinguish new channel descriptor from old ldepth.
     * channel descriptors have letters as well as numbers,
     * while ldepths are a single digit formatted as %-11d.
     */
    new = 0;
    for(m=0; m<10; m++){
        if(hdr[m] != ' '){
            new = 1;
            break;
        }
    }
    if(hdr[11] != ' '){
        werrstr("readimage: bad format");
        return nil;
    }
    if(new){
        hdr[11] = '\0';
        if((chan = strtochan(hdr)) == 0){
            werrstr("readimage: bad channel string %s", hdr);
            return nil;
        }
    }else{
        ldepth = ((int)hdr[10])-'0';
        if(ldepth<0 || ldepth>3){
            werrstr("readimage: bad ldepth %d", ldepth);
            return nil;
        }
        chan = drawld2chan[ldepth];
    }

    r.min.x = atoi(hdr+1*12);
    r.min.y = atoi(hdr+2*12);
    r.max.x = atoi(hdr+3*12);
    r.max.y = atoi(hdr+4*12);
    if(r.min.x>r.max.x || r.min.y>r.max.y){
        werrstr("readimage: bad rectangle");
        return nil;
    }

    miny = r.min.y;
    maxy = r.max.y;

    l = bytesperline(r, chantodepth(chan));
    if(d){
        if(dolock)
            lockdisplay(d);
        i = allocimage(d, r, chan, 0, -1);
        if(dolock)
            unlockdisplay(d);
        if(i == nil)
            return nil;
    }else{
        i = mallocz(sizeof(Image), 1);
        if(i == nil)
            return nil;
    }

    tmp = malloc(chunk);
    if(tmp == nil)
        goto Err;
    while(maxy > miny){
        dy = maxy - miny;
        if(dy*l > chunk)
            dy = chunk/l;
        if(dy <= 0){
            werrstr("readimage: image too wide for buffer");
            goto Err;
        }
        n = dy*l;
        m = readn(fd, tmp, n);
        if(m != n){
            werrstr("readimage: read count %d not %d: %r", m, n);
   Err:
            if(dolock)
                lockdisplay(d);
   Err1:
    freeimage(i);
            if(dolock)
                unlockdisplay(d);
            free(tmp);
            return nil;
        }
        if(!new)	/* an old image: must flip all the bits */
            for(j=0; j<chunk; j++)
                tmp[j] ^= 0xFF;

        if(d){
            if(dolock)
                lockdisplay(d);
            if(loadimage(i, Rect(r.min.x, miny, r.max.x, miny+dy), tmp, chunk) <= 0)
                goto Err1;
            if(dolock)
                unlockdisplay(d);
        }
        miny += dy;
    }
    free(tmp);
    return i;
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/readimage.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function readimage>>
@


\subsection*{[[lib_graphics/libdraw/readsubfont.c]]}

<<function readsubfonti>>=
Subfont*
readsubfonti(Display*d, char *name, int fd, Image *ai, int dolock)
{
    char hdr[3*12+4+1];
    int n;
    uchar *p;
    Fontchar *fc;
    Subfont *f;
    Image *i;

    i = ai;
    if(i == nil){
        i = readimage(d, fd, dolock);
        if(i == nil)
            return nil;
    }
    if(read(fd, hdr, 3*12) != 3*12){
        if(ai == nil)
            freeimage(i);
        werrstr("rdsubfonfile: header read error: %r");
        return nil;
    }
    n = atoi(hdr);
    p = malloc(6*(n+1));
    if(p == nil)
        goto Err;
    if(read(fd, p, 6*(n+1)) != 6*(n+1)){
        werrstr("rdsubfonfile: fontchar read error: %r");
    Err:
        if(ai == nil)
            freeimage(i);
        free(p);
        return nil;
    }
    fc = malloc(sizeof(Fontchar)*(n+1));
    if(fc == nil)
        goto Err;
    _unpackinfo(fc, p, n);
    if(dolock)
        lockdisplay(d);
    f = allocsubfont(name, n, atoi(hdr+12), atoi(hdr+24), fc, i);
    if(dolock)
        unlockdisplay(d);
    if(f == nil){
        free(fc);
        goto Err;
    }
    free(p);
    return f;
}
@

<<function readsubfont>>=
Subfont*
readsubfont(Display *d, char *name, int fd, int dolock)
{
    return readsubfonti(d, name, fd, nil, dolock);
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/readsubfont.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function readsubfonti>>

<<function readsubfont>>
@


\subsection*{[[lib_graphics/libdraw/rectclip.c]]}

<<function rectclip>>=
int
rectclip(Rectangle *rp, Rectangle b)		/* first by reference, second by value */
{
    Rectangle *bp = &b;
    /*
     * Expand rectXrect() in line for speed
     */
    if((rp->min.x<bp->max.x && bp->min.x<rp->max.x &&
        rp->min.y<bp->max.y && bp->min.y<rp->max.y)==0)
        return 0;
    /* They must overlap */
    if(rp->min.x < bp->min.x)
        rp->min.x = bp->min.x;
    if(rp->min.y < bp->min.y)
        rp->min.y = bp->min.y;
    if(rp->max.x > bp->max.x)
        rp->max.x = bp->max.x;
    if(rp->max.y > bp->max.y)
        rp->max.y = bp->max.y;
    return 1;
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/rectclip.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function rectclip>>
@


\subsection*{[[lib_graphics/libdraw/replclipr.c]]}

<<function replclipr>>=
void
replclipr(Image *i, int repl, Rectangle clipr)
{
    uchar *b;

    b = bufimage(i->display, 22);
    b[0] = 'c';
    BPLONG(b+1, i->id);
    repl = repl!=0;
    b[5] = repl;
    BPLONG(b+6, clipr.min.x);
    BPLONG(b+10, clipr.min.y);
    BPLONG(b+14, clipr.max.x);
    BPLONG(b+18, clipr.max.y);
    i->repl = repl;
    i->clipr = clipr;
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/replclipr.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function replclipr>>
@


\subsection*{[[lib_graphics/libdraw/rgb.c]]}

<<function rgb2cmap>>=
/*
 * This original version, although fast and a true inverse of
 * cmap2rgb, in the sense that rgb2cmap(cmap2rgb(c))
 * returned the original color, does a terrible job for RGB
 * triples that do not appear in the color map, so it has been
 * replaced by the much slower version below, that loops
 * over the color map looking for the nearest point in RGB
 * space.  There is no visual psychology reason for that
 * criterion, but it's easy to implement and the results are
 * far more pleasing. 
 *
int
rgb2cmap(int cr, int cg, int cb)
{
    int r, g, b, v, cv;

    if(cr < 0)
        cr = 0;
    else if(cr > 255)
        cr = 255;
    if(cg < 0)
        cg = 0;
    else if(cg > 255)
        cg = 255;
    if(cb < 0)
        cb = 0;
    else if(cb > 255)
        cb = 255;
    r = cr>>6;
    g = cg>>6;
    b = cb>>6;
    cv = cr;
    if(cg > cv)
        cv = cg;
    if(cb > cv)
        cv = cb;
    v = (cv>>4)&3;
    return ((((r<<2)+v)<<4)+(((g<<2)+b+v-r)&15));
}
*/

int
rgb2cmap(int cr, int cg, int cb)
{
    int i, r, g, b, sq;
    ulong rgb;
    int best, bestsq;

    best = 0;
    bestsq = 0x7FFFFFFF;
    for(i=0; i<256; i++){
        rgb = cmap2rgb(i);
        r = (rgb>>16) & 0xFF;
        g = (rgb>>8) & 0xFF;
        b = (rgb>>0) & 0xFF;
        sq = (r-cr)*(r-cr)+(g-cg)*(g-cg)+(b-cb)*(b-cb);
        if(sq < bestsq){
            bestsq = sq;
            best = i;
        }
    }
    return best;
}
@

<<function cmap2rgb>>=
int
cmap2rgb(int c)
{
    int j, num, den, r, g, b, v, rgb;

    r = c>>6;
    v = (c>>4)&3;
    j = (c-v+r)&15;
    g = j>>2;
    b = j&3;
    den=r;
    if(g>den)
        den=g;
    if(b>den)
        den=b;
    if(den==0) {
        v *= 17;
        rgb = (v<<16)|(v<<8)|v;
    }
    else{
        num=17*(4*den+v);
        rgb = ((r*num/den)<<16)|((g*num/den)<<8)|(b*num/den);
    }
    return rgb;
}
@

<<function cmap2rgba>>=
int
cmap2rgba(int c)
{
    return (cmap2rgb(c)<<8)|0xFF;
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/rgb.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function rgb2cmap>>

<<function cmap2rgb>>

<<function cmap2rgba>>
@


\subsection*{[[lib_graphics/libdraw/scroll.c]]}

<<function mousescrollsize>>=
int
mousescrollsize(int maxlines)
{
    static int lines, pcnt;
    char *mss;

    if(lines == 0 && pcnt == 0){
        mss = getenv("mousescrollsize");
        if(mss){
            if(strchr(mss, '%') != nil)
                pcnt = atof(mss);
            else
                lines = atoi(mss);
            free(mss);
        }
        if(lines == 0 && pcnt == 0)
            lines = 1;
        if(pcnt>=100)
            pcnt = 100;
    }

    if(lines)
        return lines;
    return pcnt * maxlines/100.0;	
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/scroll.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function mousescrollsize>>
@


\subsection*{[[lib_graphics/libdraw/string.c]]}

<<enum _anon_ (lib_graphics/libdraw/string.c)>>=
enum
{
    Max = 100
};
@

<<function string>>=
Point
string(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s)
{
    return _string(dst, pt, src, sp, f, s, nil, 1<<24, dst->clipr, nil, ZP, SoverD);
}
@

<<function stringop>>=
Point
stringop(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, Drawop op)
{
    return _string(dst, pt, src, sp, f, s, nil, 1<<24, dst->clipr, nil, ZP, op);
}
@

<<function stringn>>=
Point
stringn(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, int len)
{
    return _string(dst, pt, src, sp, f, s, nil, len, dst->clipr, nil, ZP, SoverD);
}
@

<<function stringnop>>=
Point
stringnop(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, int len, Drawop op)
{
    return _string(dst, pt, src, sp, f, s, nil, len, dst->clipr, nil, ZP, op);
}
@

<<function runestring>>=
Point
runestring(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r)
{
    return _string(dst, pt, src, sp, f, nil, r, 1<<24, dst->clipr, nil, ZP, SoverD);
}
@

<<function runestringop>>=
Point
runestringop(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r, Drawop op)
{
    return _string(dst, pt, src, sp, f, nil, r, 1<<24, dst->clipr, nil, ZP, op);
}
@

<<function runestringn>>=
Point
runestringn(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r, int len)
{
    return _string(dst, pt, src, sp, f, nil, r, len, dst->clipr, nil, ZP, SoverD);
}
@

<<function runestringnop>>=
Point
runestringnop(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r, int len, Drawop op)
{
    return _string(dst, pt, src, sp, f, nil, r, len, dst->clipr, nil, ZP, op);
}
@

<<function _string>>=
Point
_string(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, Rune *r, int len, Rectangle clipr, Image *bg, Point bgp, Drawop op)
{
    int m, n, wid, max;
    ushort cbuf[Max], *c, *ec;
    uchar *b;
    char *subfontname;
    char **sptr;
    Rune **rptr;
    Font *def;
    Subfont *sf;

    if(s == nil){
        s = "";
        sptr = nil;
    }else
        sptr = &s;
    if(r == nil){
        r = (Rune*) L"";
        rptr = nil;
    }else
        rptr = &r;
    sf = nil;
    while((*s || *r) && len){
        max = Max;
        if(len < max)
            max = len;
        n = cachechars(f, sptr, rptr, cbuf, max, &wid, &subfontname);
        if(n > 0){
            _setdrawop(dst->display, op);

            m = 47+2*n;
            if(bg)
                m += 4+2*4;
            b = bufimage(dst->display, m);
            if(b == 0){
                fprint(2, "string: %r\n");
                break;
            }
            if(bg)
                b[0] = 'x';
            else
                b[0] = 's';
            BPLONG(b+1, dst->id);
            BPLONG(b+5, src->id);
            BPLONG(b+9, f->cacheimage->id);
            BPLONG(b+13, pt.x);
            BPLONG(b+17, pt.y+f->ascent);
            BPLONG(b+21, clipr.min.x);
            BPLONG(b+25, clipr.min.y);
            BPLONG(b+29, clipr.max.x);
            BPLONG(b+33, clipr.max.y);
            BPLONG(b+37, sp.x);
            BPLONG(b+41, sp.y);
            BPSHORT(b+45, n);
            b += 47;
            if(bg){
                BPLONG(b, bg->id);
                BPLONG(b+4, bgp.x);
                BPLONG(b+8, bgp.y);
                b += 12;
            }
            ec = &cbuf[n];
            for(c=cbuf; c<ec; c++, b+=2)
                BPSHORT(b, *c);
            pt.x += wid;
            bgp.x += wid;
            agefont(f);
            len -= n;
        }
        if(subfontname){
            freesubfont(sf);
            if((sf=_getsubfont(f->display, subfontname)) == 0){
                def = f->display ? f->display->defaultfont : nil;
                if(def && f!=def)
                    f = def;
                else
                    break;
            }
            /* 
             * must not free sf until cachechars has found it in the cache
             * and picked up its own reference.
             */
        }
    }
    return pt;
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/string.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<enum _anon_ (lib_graphics/libdraw/string.c)>>

<<function string>>

<<function stringop>>

<<function stringn>>

<<function stringnop>>

<<function runestring>>

<<function runestringop>>

<<function runestringn>>

<<function runestringnop>>

<<function _string>>
@


\subsection*{[[lib_graphics/libdraw/stringbg.c]]}

<<function stringbg>>=
Point
stringbg(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, Image *bg, Point bgp)
{
    return _string(dst, pt, src, sp, f, s, nil, 1<<24, dst->clipr, bg, bgp, SoverD);
}
@

<<function stringbgop>>=
Point
stringbgop(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, Image *bg, Point bgp, int op)
{
    return _string(dst, pt, src, sp, f, s, nil, 1<<24, dst->clipr, bg, bgp, op);
}
@

<<function stringnbg>>=
Point
stringnbg(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, int len, Image *bg, Point bgp)
{
    return _string(dst, pt, src, sp, f, s, nil, len, dst->clipr, bg, bgp, SoverD);
}
@

<<function stringnbgop>>=
Point
stringnbgop(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, int len, Image *bg, Point bgp, int op)
{
    return _string(dst, pt, src, sp, f, s, nil, len, dst->clipr, bg, bgp, op);
}
@

<<function runestringbg>>=
Point
runestringbg(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r, Image *bg, Point bgp)
{
    return _string(dst, pt, src, sp, f, nil, r, 1<<24, dst->clipr, bg, bgp, SoverD);
}
@

<<function runestringbgop>>=
Point
runestringbgop(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r, Image *bg, Point bgp, int op)
{
    return _string(dst, pt, src, sp, f, nil, r, 1<<24, dst->clipr, bg, bgp, op);
}
@

<<function runestringnbg>>=
Point
runestringnbg(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r, int len, Image *bg, Point bgp)
{
    return _string(dst, pt, src, sp, f, nil, r, len, dst->clipr, bg, bgp, SoverD);
}
@

<<function runestringnbgop>>=
Point
runestringnbgop(Image *dst, Point pt, Image *src, Point sp, Font *f, Rune *r, int len, Image *bg, Point bgp, int op)
{
    return _string(dst, pt, src, sp, f, nil, r, len, dst->clipr, bg, bgp, op);
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/stringbg.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function stringbg>>

<<function stringbgop>>

<<function stringnbg>>

<<function stringnbgop>>

<<function runestringbg>>

<<function runestringbgop>>

<<function runestringnbg>>

<<function runestringnbgop>>
@


\subsection*{[[lib_graphics/libdraw/stringsubfont.c]]}

<<function stringsubfont>>=
Point
stringsubfont(Image *b, Point p, Image *color, Subfont *f, char *cs)
{
    int w, width;
    uchar *s;
    Rune c;
    Fontchar *i;

    s = (uchar*)cs;
    for(; c=*s; p.x+=width){
        width = 0;
        if(c < Runeself)
            s++;
        else{
            w = chartorune(&c, (char*)s);
            if(w == 0){
                s++;
                continue;
            }
            s += w;
        }
        if(c >= f->n)
            continue;
        i = f->info+c;
        width = i->width;
        draw(b, Rect(p.x+i->left, p.y+i->top, p.x+i->left+(i[1].x-i[0].x), p.y+i->bottom),
            color, f->bits, Pt(i->x, i->top));
    }
    return p;
}
@

<<function strsubfontwidth>>=
Point
strsubfontwidth(Subfont *f, char *cs)
{
    Rune c;
    Point p;
    uchar *s;
    Fontchar *i;
    int w, width;

    p = Pt(0, f->height);
    s = (uchar*)cs;
    for(; c=*s; p.x+=width){
        width = 0;
        if(c < Runeself)
            s++;
        else{
            w = chartorune(&c, (char*)s);
            if(w == 0){
                s++;
                continue;
            }
            s += w;
        }
        if(c >= f->n)
            continue;
        i = f->info+c;
        width = i->width;
    }
    return p;
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/stringsubfont.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function stringsubfont>>

<<function strsubfontwidth>>
@


\subsection*{[[lib_graphics/libdraw/stringwidth.c]]}

<<enum _anon_ (lib_graphics/libdraw/stringwidth.c)>>=
enum { Max = 64 };
@

<<function _stringnwidth>>=
int
_stringnwidth(Font *f, char *s, Rune *r, int len)
{
    int wid, twid, n, max, l;
    char *name;
    ushort cbuf[Max];
    Rune rune, **rptr;
    char *subfontname, **sptr;
    Font *def;

    if(s == nil){
        s = "";
        sptr = nil;
    }else
        sptr = &s;
    if(r == nil){
          r = L"";
        rptr = nil;
    }else
        rptr = &r;
    twid = 0;
    while(len>0 && (*s || *r)){
        max = Max;
        if(len < max)
            max = len;
        n = 0;
        while((l = cachechars(f, sptr, rptr, cbuf, max, &wid, &subfontname)) <= 0){
            if(++n > 10){
                if(*r)
                    rune = *r;
                else
                    chartorune(&rune, s);
                if(f->name != nil)
                    name = f->name;
                else
                    name = "unnamed font";
                fprint(2, "stringwidth: bad character set for rune 0x%.4ux in %s\n", rune, name);
                return twid;
            }
            if(subfontname){
                if(_getsubfont(f->display, subfontname) == 0){
                    def = f->display->defaultfont;
                    if(def && f!=def)
                        f = def;
                    else
                        break;
                }
            }
        }
        agefont(f);
        twid += wid;
        len -= l;
    }
    return twid;
}
@

<<function stringnwidth>>=
int
stringnwidth(Font *f, char *s, int len)
{
    return _stringnwidth(f, s, nil, len);
}
@

<<function stringwidth>>=
int
stringwidth(Font *f, char *s)
{
    return _stringnwidth(f, s, nil, 1<<24);
}
@

<<function stringsize>>=
Point
stringsize(Font *f, char *s)
{
    return Pt(_stringnwidth(f, s, nil, 1<<24), f->height);
}
@

<<function runestringnwidth>>=
int
runestringnwidth(Font *f, Rune *r, int len)
{
    return _stringnwidth(f, nil, r, len);
}
@

<<function runestringwidth>>=
int
runestringwidth(Font *f, Rune *r)
{
    return _stringnwidth(f, nil, r, 1<<24);
}
@

<<function runestringsize>>=
Point
runestringsize(Font *f, Rune *r)
{
    return Pt(_stringnwidth(f, nil, r, 1<<24), f->height);
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/stringwidth.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<enum _anon_ (lib_graphics/libdraw/stringwidth.c)>>

<<function _stringnwidth>>

<<function stringnwidth>>

<<function stringwidth>>

<<function stringsize>>

<<function runestringnwidth>>

<<function runestringwidth>>

<<function runestringsize>>
@


\subsection*{[[lib_graphics/libdraw/subfont.c]]}

<<function allocsubfont>>=
Subfont*
allocsubfont(char *name, int n, int height, int ascent, Fontchar *info, Image *i)
{
    Subfont *f;

    assert(height != 0 /* allocsubfont */);

    f = malloc(sizeof(Subfont));
    if(f == 0)
        return 0;
    f->n = n;
    f->height = height;
    f->ascent = ascent;
    f->info = info;
    f->bits = i;
    f->ref = 1;
    if(name){
        f->name = strdup(name);
        if(lookupsubfont(i->display, name) == 0)
            installsubfont(name, f);
    }else
        f->name = 0;
    return f;
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/subfont.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function allocsubfont>>
@


\subsection*{[[lib_graphics/libdraw/subfontcache.c]]}

<<global lastname>>=
/*
 * Easy versions of the cache routines; may be substituted by fancier ones for other purposes
 */

static char	*lastname;
@

<<global lastsubfont>>=
Subfont	*lastsubfont;
@

<<function lookupsubfont>>=
Subfont*
lookupsubfont(Display *d, char *name)
{
    if(d && strcmp(name, "*default*") == 0)
        return d->defaultsubfont;
    if(lastname && strcmp(name, lastname)==0)
    if(d==lastsubfont->bits->display){
        lastsubfont->ref++;
        return lastsubfont;
    }
    return 0;
}
@

<<function installsubfont>>=
void
installsubfont(char *name, Subfont *subfont)
{
    free(lastname);
    lastname = strdup(name);
    lastsubfont = subfont;	/* notice we don't free the old one; that's your business */
}
@

<<function uninstallsubfont>>=
void
uninstallsubfont(Subfont *subfont)
{
    if(subfont == lastsubfont){
        lastname = 0;
        lastsubfont = 0;
    }
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/subfontcache.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<global lastname>>
<<global lastsubfont>>

<<function lookupsubfont>>

<<function installsubfont>>

<<function uninstallsubfont>>
@


\subsection*{[[lib_graphics/libdraw/subfontname.c]]}

<<function subfontname>>=
/*
 * Default version: convert to file name
 */

char*
subfontname(char *cfname, char *fname, int maxdepth)
{
    char *t, *u, *tmp1, *tmp2;
    int i;

    t = strdup(cfname);  /* t is the return string */
    if(strcmp(cfname, "*default*") == 0)
        return t;
    if(t[0] != '/'){
        tmp2 = strdup(fname);
        u = utfrrune(tmp2, '/');
        if(u)
            u[0] = 0;
        else
            strcpy(tmp2, ".");
        tmp1 = smprint("%s/%s", tmp2, t);
        free(tmp2);
        free(t);
        t = tmp1;
    }

    if(maxdepth > 8)
        maxdepth = 8;

    for(i=3; i>=0; i--){
        if((1<<i) > maxdepth)
            continue;
        /* try i-bit grey */
        tmp2 = smprint("%s.%d", t, i);
        if(access(tmp2, AREAD) == 0) {
            free(t);
            return tmp2;
        }
        free(tmp2);
    }

    /* try default */
    if(access(t, AREAD) == 0)
        return t;

    free(t);
    return nil;
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/subfontname.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function subfontname>>
@


\section{[[lib_graphics/libdraw/tests/]]}

\subsection*{[[lib_graphics/libdraw/tests/drawtest.c]]}

<<function main>>=
void
main(int argc, char **argv)
{
        print("%dn", wordsperline(Rect(atoi(argv[1]), atoi(argv[2]), atoi(argv[3]), atoi(argv[4])), atoi(argv[5])));
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/tests/drawtest.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function main>>
@


\section{[[lib_graphics/libdraw/]]}

\subsection*{[[lib_graphics/libdraw/unloadimage.c]]}

<<function unloadimage>>=
int
unloadimage(Image *i, Rectangle r, uchar *data, int ndata)
{
    int bpl, n, ntot, dy;
    uchar *a;
    Display *d;

    if(!rectinrect(r, i->r)){
        werrstr("unloadimage: bad rectangle");
        return -1;
    }
    bpl = bytesperline(r, i->depth);
    if(ndata < bpl*Dy(r)){
        werrstr("unloadimage: buffer too small");
        return -1;
    }

    d = i->display;
    flushimage(d, 0);	/* make sure subsequent flush is for us only */
    ntot = 0;
    while(r.min.y < r.max.y){
        a = bufimage(d, 1+4+4*4);
        if(a == 0){
            werrstr("unloadimage: %r");
            return -1;
        }
        dy = 8000/bpl;
        if(dy <= 0){
            werrstr("unloadimage: image too wide");
            return -1;
        }
        if(dy > Dy(r))
            dy = Dy(r);
        a[0] = 'r';
        BPLONG(a+1, i->id);
        BPLONG(a+5, r.min.x);
        BPLONG(a+9, r.min.y);
        BPLONG(a+13, r.max.x);
        BPLONG(a+17, r.min.y+dy);
        if(flushimage(d, 0) < 0)
            return -1;
        n = read(d->fd, data+ntot, ndata-ntot);
        if(n < 0)
            return n;
        ntot += n;
        r.min.y += dy;
    }
    return ntot;
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/unloadimage.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function unloadimage>>
@


\subsection*{[[lib_graphics/libdraw/window.c]]}

<<global screenid>>=
static int	screenid;
@

<<function allocscreen>>=
Screen*
allocscreen(Image *image, Image *fill, int public)
{
    uchar *a;
    Screen *s;
    int id, try;
    Display *d;

    d = image->display;
    if(d != fill->display){
        werrstr("allocscreen: image and fill on different displays");
        return 0;
    }
    s = malloc(sizeof(Screen));
    if(s == 0)
        return 0;
    SET(id);
    for(try=0; try<25; try++){
        /* loop until find a free id */
        a = bufimage(d, 1+4+4+4+1);
        if(a == 0){
            free(s);
            return 0;
        }
        id = ++screenid;
        a[0] = 'A';
        BPLONG(a+1, id);
        BPLONG(a+5, image->id);
        BPLONG(a+9, fill->id);
        a[13] = public;
        if(flushimage(d, 0) != -1)
            break;
    }
    s->display = d;
    s->id = id;
    s->image = image;
    assert(s->image && s->image->chan != 0);

    s->fill = fill;
    return s;
}
@

<<function publicscreen>>=
Screen*
publicscreen(Display *d, int id, ulong chan)
{
    uchar *a;
    Screen *s;

    s = malloc(sizeof(Screen));
    if(s == 0)
        return 0;
    a = bufimage(d, 1+4+4);
    if(a == 0){
    Error:
        free(s);
        return 0;
    }
    a[0] = 'S';
    BPLONG(a+1, id);
    BPLONG(a+5, chan);
    if(flushimage(d, 0) < 0)
        goto Error;

    s->display = d;
    s->id = id;
    s->image = 0;
    s->fill = 0;
    return s;
}
@

<<function freescreen>>=
int
freescreen(Screen *s)
{
    uchar *a;
    Display *d;

    if(s == 0)
        return 0;
    d = s->display;
    a = bufimage(d, 1+4);
    if(a == 0)
        return -1;
    a[0] = 'F';
    BPLONG(a+1, s->id);
    /*
     * flush(1) because screen is likely holding last reference to
     * window, and want it to disappear visually.
     */
    if(flushimage(d, 1) < 0)
        return -1;
    free(s);
    return 1;
}
@

<<function allocwindow>>=
Image*
allocwindow(Screen *s, Rectangle r, int ref, ulong val)
{
    return _allocwindow(nil, s, r, ref, val);
}
@

<<function _allocwindow>>=
Image*
_allocwindow(Image *i, Screen *s, Rectangle r, int ref, ulong val)
{
    Display *d;

    d = s->display;
    i = _allocimage(i, d, r, d->screenimage->chan, 0, val, s->id, ref);
    if(i == 0)
        return 0;
    i->screen = s;
    i->next = s->display->windows;
    s->display->windows = i;
    return i;
}
@

<<function topbottom>>=
static
void
topbottom(Image **w, int n, int top)
{
    int i;
    uchar *b;
    Display *d;

    if(n < 0){
    Ridiculous:
        fprint(2, "top/bottom: ridiculous number of windows\n");
        return;
    }
    if(n == 0)
        return;
    if(n > (w[0]->display->bufsize-100)/4)
        goto Ridiculous;
    /*
     * this used to check that all images were on the same screen.
     * we don't know the screen associated with images we acquired
     * by name.  instead, check that all images are on the same display.
     * the display will check that they are all on the same screen.
     */
    d = w[0]->display;
    for(i=1; i<n; i++)
        if(w[i]->display != d){
            fprint(2, "top/bottom: windows not on same screen\n");
            return;
        }

    if(n==0)
        return;
    b = bufimage(d, 1+1+2+4*n);
    b[0] = 't';
    b[1] = top;
    BPSHORT(b+2, n);
    for(i=0; i<n; i++)
        BPLONG(b+4+4*i, w[i]->id);
}
@

<<function bottomwindow>>=
void
bottomwindow(Image *w)
{
    if(w->screen == 0)
        return;
    topbottom(&w, 1, 0);
}
@

<<function topwindow>>=
void
topwindow(Image *w)
{
    if(w->screen == 0)
        return;
    topbottom(&w, 1, 1);
}
@

<<function bottomnwindows>>=
void
bottomnwindows(Image **w, int n)
{
    topbottom(w, n, 0);
}
@

<<function topnwindows>>=
void
topnwindows(Image **w, int n)
{
    topbottom(w, n, 1);
}
@

<<function originwindow>>=
int
originwindow(Image *w, Point log, Point scr)
{
    uchar *b;
    Point delta;

    flushimage(w->display, 0);
    b = bufimage(w->display, 1+4+2*4+2*4);
    if(b == nil)
        return 0;
    b[0] = 'o';
    BPLONG(b+1, w->id);
    BPLONG(b+5, log.x);
    BPLONG(b+9, log.y);
    BPLONG(b+13, scr.x);
    BPLONG(b+17, scr.y);
    if(flushimage(w->display, 1) < 0)
        return -1;
    delta = subpt(log, w->r.min);
    w->r = rectaddpt(w->r, delta);
    w->clipr = rectaddpt(w->clipr, delta);
    return 1;
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/window.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

typedef struct Memimage Memimage;

<<global screenid>>

<<function allocscreen>>

<<function publicscreen>>

<<function freescreen>>

<<function allocwindow>>

<<function _allocwindow>>

<<function topbottom>>

<<function bottomwindow>>

<<function topwindow>>

<<function bottomnwindows>>

<<function topnwindows>>

<<function originwindow>>
@


\subsection*{[[lib_graphics/libdraw/writecolmap.c]]}

<<function writecolmap>>=
/*
 * This code (and the devdraw interface) will have to change
 * if we ever get bitmaps with ldepth > 3, because the
 * colormap will have to be written in chunks
 */

void
writecolmap(Display *d, RGB *m)
{
    int i, n, fd;
    char buf[64], *t;
    ulong r, g, b;

    sprint(buf, "/dev/draw/%d/colormap", d->dirno);
    fd = open(buf, OWRITE);
    if(fd < 0)
        drawerror(d, "writecolmap: open colormap failed");
    t = malloc(8192);
    if (t == nil)
        drawerror(d, "writecolmap: no memory");
    n = 0;
    for(i = 0; i < 256; i++) {
        r = m[i].red>>24;
        g = m[i].green>>24;
        b = m[i].blue>>24;
        n += sprint(t+n, "%d %lud %lud %lud\n", 255-i, r, g, b);
    }
    i = write(fd, t, n);
    free(t);
    close(fd);
    if(i != n)
        drawerror(d, "writecolmap: bad write");
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/writecolmap.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function writecolmap>>
@


\subsection*{[[lib_graphics/libdraw/writeimage.c]]}

<<constant HSHIFT>>=
#define	HSHIFT	3	/* HSHIFT==5 runs slightly faster, but hash table is 64x bigger */
@

<<constant NHASH>>=
#define	NHASH	(1<<(HSHIFT*NMATCH))
@

<<constant HMASK>>=
#define	HMASK	(NHASH-1)
@

<<function hupdate>>=
#define	hupdate(h, c)	((((h)<<HSHIFT)^(c))&HMASK)
@

<<struct Hlist>>=
struct Hlist{
    uchar *s;
    Hlist *next, *prev;
};
@

<<function writeimage>>=
int
writeimage(int fd, Image *i, int dolock)
{
    uchar *outbuf, *outp, *eout;		/* encoded data, pointer, end */
    uchar *loutp;				/* start of encoded line */
    Hlist *hash;				/* heads of hash chains of past strings */
    Hlist *chain, *hp;			/* hash chain members, pointer */
    Hlist *cp;				/* next Hlist to fall out of window */
    int h;					/* hash value */
    uchar *line, *eline;			/* input line, end pointer */
    uchar *data, *edata;			/* input buffer, end pointer */
    ulong n;				/* length of input buffer */
    ulong nb;				/* # of bytes returned by unloadimage */
    int bpl;				/* input line length */
    int offs, runlen;			/* offset, length of consumed data */
    uchar dumpbuf[NDUMP];			/* dump accumulator */
    int ndump;				/* length of dump accumulator */
    int miny, dy;				/* y values while unloading input */
    int chunk, ncblock;
    Rectangle r;
    uchar *p, *q, *s, *es, *t;
    char hdr[11+5*12+1];
    char cbuf[20];

    chunk = i->display->bufsize - 32;	/* a little room for header */
    r = i->r;
    bpl = bytesperline(r, i->depth);
    n = Dy(r)*bpl;
    data = malloc(n);
    ncblock = _compblocksize(r, i->depth);
    outbuf = malloc(ncblock);
    hash = malloc(NHASH*sizeof(Hlist));
    chain = malloc(NMEM*sizeof(Hlist));
    if(data == 0 || outbuf == 0 || hash == 0 || chain == 0){
    ErrOut:
        free(data);
        free(outbuf);
        free(hash);
        free(chain);
        return -1;
    }
    for(miny = r.min.y; miny != r.max.y; miny += dy){
        dy = r.max.y-miny;
        if(dy*bpl > chunk)
            dy = chunk/bpl;
        if(dolock)
            lockdisplay(i->display);
        nb = unloadimage(i, Rect(r.min.x, miny, r.max.x, miny+dy),
            data+(miny-r.min.y)*bpl, dy*bpl);
        if(dolock)
            unlockdisplay(i->display);
        if(nb != dy*bpl)
            goto ErrOut;
    }
    sprint(hdr, "compressed\n%11s %11d %11d %11d %11d ",
        chantostr(cbuf, i->chan), r.min.x, r.min.y, r.max.x, r.max.y);
    if(write(fd, hdr, 11+5*12) != 11+5*12)
        goto ErrOut;
    edata = data+n;
    eout = outbuf+ncblock;
    line = data;
    r.max.y = r.min.y;
    while(line != edata){
        memset(hash, 0, NHASH*sizeof(Hlist));
        memset(chain, 0, NMEM*sizeof(Hlist));
        cp = chain;
        h = 0;
        outp = outbuf;
        for(n = 0; n != NMATCH; n++)
            h = hupdate(h, line[n]);
        loutp = outbuf;
        while(line != edata){
            ndump = 0;
            eline = line+bpl;
            for(p = line; p != eline; ){
                if(eline-p < NRUN)
                    es = eline;
                else
                    es = p+NRUN;
                q = 0;
                runlen = 0;
                for(hp = hash[h].next; hp; hp = hp->next){
                    s = p + runlen;
                    if(s >= es)
                        continue;
                    t = hp->s + runlen;
                    for(; s >= p; s--)
                        if(*s != *t--)
                            goto matchloop;
                    t += runlen+2;
                    s += runlen+2;
                    for(; s < es; s++)
                        if(*s != *t++)
                            break;
                    n = s-p;
                    if(n > runlen){
                        runlen = n;
                        q = hp->s;
                        if(n == NRUN)
                            break;
                    }
            matchloop: ;
                }
                if(runlen < NMATCH){
                    if(ndump == NDUMP){
                        if(eout-outp < ndump+1)
                            goto Bfull;
                        *outp++ = ndump-1+128;
                        memmove(outp, dumpbuf, ndump);
                        outp += ndump;
                        ndump = 0;
                    }
                    dumpbuf[ndump++] = *p;
                    runlen = 1;
                }
                else{
                    if(ndump != 0){
                        if(eout-outp < ndump+1)
                            goto Bfull;
                        *outp++ = ndump-1+128;
                        memmove(outp, dumpbuf, ndump);
                        outp += ndump;
                        ndump = 0;
                    }
                    offs = p-q-1;
                    if(eout-outp < 2)
                        goto Bfull;
                    *outp++ = ((runlen-NMATCH)<<2) + (offs>>8);
                    *outp++ = offs&255;
                }
                for(q = p+runlen; p != q; p++){
                    if(cp->prev)
                        cp->prev->next = 0;
                    cp->next = hash[h].next;
                    cp->prev = &hash[h];
                    if(cp->next)
                        cp->next->prev = cp;
                    cp->prev->next = cp;
                    cp->s = p;
                    if(++cp == &chain[NMEM])
                        cp = chain;
                    if(edata-p > NMATCH)
                        h = hupdate(h, p[NMATCH]);
                }
            }
            if(ndump != 0){
                if(eout-outp < ndump+1)
                    goto Bfull;
                *outp++ = ndump-1+128;
                memmove(outp, dumpbuf, ndump);
                outp += ndump;
            }
            line = eline;
            loutp = outp;
            r.max.y++;
        }
    Bfull:
        if(loutp == outbuf)
            goto ErrOut;
        n = loutp-outbuf;
        sprint(hdr, "%11d %11ld ", r.max.y, n);
        write(fd, hdr, 2*12);
        write(fd, outbuf, n);
        r.min.y = r.max.y;
    }
    free(data);
    free(outbuf);
    free(hash);
    free(chain);
    return 0;
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/writeimage.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<constant HSHIFT>>
<<constant NHASH>>
<<constant HMASK>>
<<function hupdate>>
typedef struct Hlist Hlist;
<<struct Hlist>>

<<function writeimage>>
@


\subsection*{[[lib_graphics/libdraw/writesubfont.c]]}

<<function packinfo>>=
static
void
packinfo(Fontchar *fc, uchar *p, int n)
{
    int j;

    for(j=0;  j<=n;  j++){
        p[0] = fc->x;
        p[1] = fc->x>>8;
        p[2] = fc->top;
        p[3] = fc->bottom;
        p[4] = fc->left;
        p[5] = fc->width;
        fc++;
        p += 6;
    }
}
@

<<function writesubfont>>=
int
writesubfont(int fd, Subfont *f)
{
    char hdr[3*12+1];
    uchar *data;
    int nb;

    sprint(hdr, "%11d %11d %11d ", f->n, f->height, f->ascent);
    if(write(fd, hdr, 3*12) != 3*12){
   Err:
        werrstr("writesubfont: bad write: %r");
        return -1;
    }
    nb = 6*(f->n+1);
    data = malloc(nb);
    if(data == nil)
        return -1;
    packinfo(f->info, data, f->n);
    if(write(fd, data, nb) != nb)
        goto Err;
    free(data);
    return 0;
}
@


%-------------------------------------------------------------

<<lib_graphics/libdraw/writesubfont.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>

<<function packinfo>>

<<function writesubfont>>
@


\section{[[lib_graphics/libmemdraw/]]}

\subsection*{[[lib_graphics/libmemdraw/alloc.c]]}

<<function memimagemove>>=
void
memimagemove(void *from, void *to)
{
    Memdata *md;

    md = *(Memdata**)to;
    if(md->base != from){
        print("compacted data not right: #%p\n", md->base);
        abort();
    }
    md->base = to;

    /* if allocmemimage changes this must change too */
    md->bdata = (uchar*)md->base+sizeof(Memdata*)+sizeof(ulong);
}
@

<<function allocmemimaged>>=
Memimage*
allocmemimaged(Rectangle r, ulong chan, Memdata *md)
{
    int d;
    ulong l;
    Memimage *i;

    if(Dx(r) <= 0 || Dy(r) <= 0){
        werrstr("bad rectangle %R", r);
        return nil;
    }
    if((d = chantodepth(chan)) == 0) {
        werrstr("bad channel descriptor %.8lux", chan);
        return nil;
    }

    l = wordsperline(r, d);

    i = mallocz(sizeof(Memimage), 1);
    if(i == nil)
        return nil;

    i->data = md;
    i->zero = sizeof(ulong)*l*r.min.y;
    
    if(r.min.x >= 0)
        i->zero += (r.min.x*d)/8;
    else
        i->zero -= (-r.min.x*d+7)/8;
    i->zero = -i->zero;
    i->width = l;
    i->r = r;
    i->clipr = r;
    i->flags = 0;
    i->layer = nil;
    i->cmap = memdefcmap;
    if(memsetchan(i, chan) < 0){
        free(i);
        return nil;
    }
    return i;
}
@

<<function allocmemimage>>=
Memimage*
allocmemimage(Rectangle r, ulong chan)
{
    int d;
    uchar *p;
    ulong l, nw;
    Memdata *md;
    Memimage *i;

    if((d = chantodepth(chan)) == 0) {
        werrstr("bad channel descriptor %.8lux", chan);
        return nil;
    }

    l = wordsperline(r, d);
    nw = l*Dy(r);
    md = malloc(sizeof(Memdata));
    if(md == nil)
        return nil;

    md->ref = 1;
    md->base = poolalloc(imagmem, sizeof(Memdata*)+(1+nw)*sizeof(ulong));
    if(md->base == nil){
        free(md);
        return nil;
    }

    p = (uchar*)md->base;
    *(Memdata**)p = md;
    p += sizeof(Memdata*);

    *(ulong*)p = getcallerpc(&r);
    p += sizeof(ulong);

    /* if this changes, memimagemove must change too */
    md->bdata = p;
    md->allocd = 1;

    i = allocmemimaged(r, chan, md);
    if(i == nil){
        poolfree(imagmem, md->base);
        free(md);
        return nil;
    }
    md->imref = i;
    return i;
}
@

<<function freememimage>>=
void
freememimage(Memimage *i)
{
    if(i == nil)
        return;
    if(i->data->ref-- == 1 && i->data->allocd){
        if(i->data->base)
            poolfree(imagmem, i->data->base);
        free(i->data);
    }
    free(i);
}
@

<<function wordaddr>>=
/*
 * Wordaddr is deprecated.
 */
ulong*
wordaddr(Memimage *i, Point p)
{
    return (ulong*) ((uintptr)byteaddr(i, p) & ~(sizeof(ulong)-1));
}
@

<<function byteaddr>>=
uchar*
byteaddr(Memimage *i, Point p)
{
    uchar *a;

    a = i->data->bdata+i->zero+sizeof(ulong)*p.y*i->width;

    if(i->depth < 8){
        /*
         * We need to always round down,
         * but C rounds toward zero.
         */
        int np;
        np = 8/i->depth;
        if(p.x < 0)
            return a+(p.x-np+1)/np;
        else
            return a+p.x/np;
    }
    else
        return a+p.x*(i->depth/8);
}
@

<<function memsetchan>>=
int
memsetchan(Memimage *i, ulong chan)
{
    int d;
    int t, j, k;
    ulong cc;
    int bytes;

    if((d = chantodepth(chan)) == 0) {
        werrstr("bad channel descriptor");
        return -1;
    }

    i->depth = d;
    i->chan = chan;
    i->flags &= ~(Fgrey|Falpha|Fcmap|Fbytes);
    bytes = 1;
    for(cc=chan, j=0, k=0; cc; j+=NBITS(cc), cc>>=8, k++){
        t=TYPE(cc);
        if(t < 0 || t >= NChan){
            werrstr("bad channel string");
            return -1;
        }
        if(t == CGrey)
            i->flags |= Fgrey;
        if(t == CAlpha)
            i->flags |= Falpha;
        if(t == CMap && i->cmap == nil){
            i->cmap = memdefcmap;
            i->flags |= Fcmap;
        }

        i->shift[t] = j;
        i->mask[t] = (1<<NBITS(cc))-1;
        i->nbits[t] = NBITS(cc);
        if(NBITS(cc) != 8)
            bytes = 0;
    }
    i->nchan = k;
    if(bytes)
        i->flags |= Fbytes;
    return 0;
}
@


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/alloc.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <pool.h>

<<function memimagemove>>

<<function allocmemimaged>>

<<function allocmemimage>>

<<function freememimage>>

<<function wordaddr>>

<<function byteaddr>>

<<function memsetchan>>
@


\subsection*{[[lib_graphics/libmemdraw/arc.c]]}

<<enum _anon_ (lib_graphics/libmemdraw/arc.c)>>=
/*
 * elarc(dst,c,a,b,t,src,sp,alpha,phi)
 *   draws the part of an ellipse between rays at angles alpha and alpha+phi
 *   measured counterclockwise from the positive x axis. other
 *   arguments are as for ellipse(dst,c,a,b,t,src,sp)
 */

enum
{
    R, T, L, B	/* right, top, left, bottom */
};
@

<<global corners>>=
static
Point corners[] = {
    {1,1},
    {-1,1},
    {-1,-1},
    {1,-1}
};
@

<<global p00>>=
static
Point p00;
@

<<function memarc>>=
/*
 * make a "wedge" mask covering the desired angle and contained in
 * a surrounding square; draw a full ellipse; intersect that with the
 * wedge to make a mask through which to copy src to dst.
 */
void
memarc(Memimage *dst, Point c, int a, int b, int t, Memimage *src, Point sp, int alpha, int phi, int op)
{
    int i, w, beta, tmp, c1, c2, m, m1;
    Rectangle rect;
    Point p,	bnd[8];
    Memimage *wedge, *figure, *mask;

    if(a < 0)
        a = -a;
    if(b < 0)
        b = -b;
    w = t;
    if(w < 0)
        w = 0;
    alpha = -alpha;		/* compensate for upside-down coords */
    phi = -phi;
    beta = alpha + phi;
    if(phi < 0){
        tmp = alpha;
        alpha = beta;
        beta = tmp;
        phi = -phi;
    }
    if(phi >= 360){
        memellipse(dst, c, a, b, t, src, sp, op);
        return;
    }
    while(alpha < 0)
        alpha += 360;
    while(beta < 0)
        beta += 360;
    c1 = alpha/90 & 3;	/* number of nearest corner */
    c2 = beta/90 & 3;
        /*
         * icossin returns point at radius ICOSSCALE.
         * multiplying by m1 moves it outside the ellipse
        */
    rect = Rect(-a-w, -b-w, a+w+1, b+w+1);
    m = rect.max.x;	/* inradius of bounding square */
    if(m < rect.max.y)
        m = rect.max.y;
    m1 = (m+ICOSSCALE-1) >> 10;
    m = m1 << 10;		/* assure m1*cossin is inside */
    i = 0;
    bnd[i++] = Pt(0,0);
    icossin(alpha, &p.x, &p.y);
    bnd[i++] = mulpt(p, m1);
    for(;;) {
        bnd[i++] = mulpt(corners[c1], m);
        if(c1==c2 && phi<180)
            break;
        c1 = (c1+1) & 3;
        phi -= 90;
    }
    icossin(beta, &p.x, &p.y);
    bnd[i++] = mulpt(p, m1);

    figure = nil;
    mask = nil;
    wedge = allocmemimage(rect, GREY1);
    if(wedge == nil)
        goto Return;
    memfillcolor(wedge, DTransparent);
    memfillpoly(wedge, bnd, i, ~0, memopaque, p00, S);
    figure = allocmemimage(rect, GREY1);
    if(figure == nil)
        goto Return;
    memfillcolor(figure, DTransparent);
    memellipse(figure, p00, a, b, t, memopaque, p00, S);
    mask = allocmemimage(rect, GREY1);
    if(mask == nil)
        goto Return;
    memfillcolor(mask, DTransparent);
    memimagedraw(mask, rect, figure, rect.min, wedge, rect.min, S);
    c = subpt(c, dst->r.min);
    memdraw(dst, dst->r, src, subpt(sp, c), mask, subpt(p00, c), op);

    Return:
    freememimage(wedge);
    freememimage(figure);
    freememimage(mask);
}
@


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/arc.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<enum _anon_ (lib_graphics/libmemdraw/arc.c)>>

<<global corners>>

<<global p00>>

<<function memarc>>
@


\subsection*{[[lib_graphics/libmemdraw/cload.c]]}

<<function cloadmemimage>>=
int
cloadmemimage(Memimage *i, Rectangle r, uchar *data, int ndata)
{
    int y, bpl, c, cnt, offs;
    uchar mem[NMEM], *memp, *omemp, *emem, *linep, *elinep, *u, *eu;

    if(!rectinrect(r, i->r))
        return -1;
    bpl = bytesperline(r, i->depth);
    u = data;
    eu = data+ndata;
    memp = mem;
    emem = mem+NMEM;
    y = r.min.y;
    linep = byteaddr(i, Pt(r.min.x, y));
    elinep = linep+bpl;
    for(;;){
        if(linep == elinep){
            if(++y == r.max.y)
                break;
            linep = byteaddr(i, Pt(r.min.x, y));
            elinep = linep+bpl;
        }
        if(u == eu){	/* buffer too small */
            return -1;
        }
        c = *u++;
        if(c >= 128){
            for(cnt=c-128+1; cnt!=0 ;--cnt){
                if(u == eu){		/* buffer too small */
                    return -1;
                }
                if(linep == elinep){	/* phase error */
                    return -1;
                }
                *linep++ = *u;
                *memp++ = *u++;
                if(memp == emem)
                    memp = mem;
            }
        }
        else{
            if(u == eu)	/* short buffer */
                return -1;
            offs = *u++ + ((c&3)<<8)+1;
            if(memp-mem < offs)
                omemp = memp+(NMEM-offs);
            else
                omemp = memp-offs;
            for(cnt=(c>>2)+NMATCH; cnt!=0; --cnt){
                if(linep == elinep)	/* phase error */
                    return -1;
                *linep++ = *omemp;
                *memp++ = *omemp++;
                if(omemp == emem)
                    omemp = mem;
                if(memp == emem)
                    memp = mem;
            }
        }
    }
    return u-data;
}
@


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/cload.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>

<<function cloadmemimage>>
@


\subsection*{[[lib_graphics/libmemdraw/cmap.c]]}

<<global def>>=
static Memcmap def = {
/* cmap2rgb */ {
    0x00,0x00,0x00,0x00,0x00,0x44,0x00,0x00,0x88,0x00,0x00,0xcc,0x00,0x44,0x00,0x00,
    0x44,0x44,0x00,0x44,0x88,0x00,0x44,0xcc,0x00,0x88,0x00,0x00,0x88,0x44,0x00,0x88,
    0x88,0x00,0x88,0xcc,0x00,0xcc,0x00,0x00,0xcc,0x44,0x00,0xcc,0x88,0x00,0xcc,0xcc,
    0x00,0xdd,0xdd,0x11,0x11,0x11,0x00,0x00,0x55,0x00,0x00,0x99,0x00,0x00,0xdd,0x00,
    0x55,0x00,0x00,0x55,0x55,0x00,0x4c,0x99,0x00,0x49,0xdd,0x00,0x99,0x00,0x00,0x99,
    0x4c,0x00,0x99,0x99,0x00,0x93,0xdd,0x00,0xdd,0x00,0x00,0xdd,0x49,0x00,0xdd,0x93,
    0x00,0xee,0x9e,0x00,0xee,0xee,0x22,0x22,0x22,0x00,0x00,0x66,0x00,0x00,0xaa,0x00,
    0x00,0xee,0x00,0x66,0x00,0x00,0x66,0x66,0x00,0x55,0xaa,0x00,0x4f,0xee,0x00,0xaa,
    0x00,0x00,0xaa,0x55,0x00,0xaa,0xaa,0x00,0x9e,0xee,0x00,0xee,0x00,0x00,0xee,0x4f,
    0x00,0xff,0x55,0x00,0xff,0xaa,0x00,0xff,0xff,0x33,0x33,0x33,0x00,0x00,0x77,0x00,
    0x00,0xbb,0x00,0x00,0xff,0x00,0x77,0x00,0x00,0x77,0x77,0x00,0x5d,0xbb,0x00,0x55,
    0xff,0x00,0xbb,0x00,0x00,0xbb,0x5d,0x00,0xbb,0xbb,0x00,0xaa,0xff,0x00,0xff,0x00,
    0x44,0x00,0x44,0x44,0x00,0x88,0x44,0x00,0xcc,0x44,0x44,0x00,0x44,0x44,0x44,0x44,
    0x44,0x88,0x44,0x44,0xcc,0x44,0x88,0x00,0x44,0x88,0x44,0x44,0x88,0x88,0x44,0x88,
    0xcc,0x44,0xcc,0x00,0x44,0xcc,0x44,0x44,0xcc,0x88,0x44,0xcc,0xcc,0x44,0x00,0x00,
    0x55,0x00,0x00,0x55,0x00,0x55,0x4c,0x00,0x99,0x49,0x00,0xdd,0x55,0x55,0x00,0x55,
    0x55,0x55,0x4c,0x4c,0x99,0x49,0x49,0xdd,0x4c,0x99,0x00,0x4c,0x99,0x4c,0x4c,0x99,
    0x99,0x49,0x93,0xdd,0x49,0xdd,0x00,0x49,0xdd,0x49,0x49,0xdd,0x93,0x49,0xdd,0xdd,
    0x4f,0xee,0xee,0x66,0x00,0x00,0x66,0x00,0x66,0x55,0x00,0xaa,0x4f,0x00,0xee,0x66,
    0x66,0x00,0x66,0x66,0x66,0x55,0x55,0xaa,0x4f,0x4f,0xee,0x55,0xaa,0x00,0x55,0xaa,
    0x55,0x55,0xaa,0xaa,0x4f,0x9e,0xee,0x4f,0xee,0x00,0x4f,0xee,0x4f,0x4f,0xee,0x9e,
    0x55,0xff,0xaa,0x55,0xff,0xff,0x77,0x00,0x00,0x77,0x00,0x77,0x5d,0x00,0xbb,0x55,
    0x00,0xff,0x77,0x77,0x00,0x77,0x77,0x77,0x5d,0x5d,0xbb,0x55,0x55,0xff,0x5d,0xbb,
    0x00,0x5d,0xbb,0x5d,0x5d,0xbb,0xbb,0x55,0xaa,0xff,0x55,0xff,0x00,0x55,0xff,0x55,
    0x88,0x00,0x88,0x88,0x00,0xcc,0x88,0x44,0x00,0x88,0x44,0x44,0x88,0x44,0x88,0x88,
    0x44,0xcc,0x88,0x88,0x00,0x88,0x88,0x44,0x88,0x88,0x88,0x88,0x88,0xcc,0x88,0xcc,
    0x00,0x88,0xcc,0x44,0x88,0xcc,0x88,0x88,0xcc,0xcc,0x88,0x00,0x00,0x88,0x00,0x44,
    0x99,0x00,0x4c,0x99,0x00,0x99,0x93,0x00,0xdd,0x99,0x4c,0x00,0x99,0x4c,0x4c,0x99,
    0x4c,0x99,0x93,0x49,0xdd,0x99,0x99,0x00,0x99,0x99,0x4c,0x99,0x99,0x99,0x93,0x93,
    0xdd,0x93,0xdd,0x00,0x93,0xdd,0x49,0x93,0xdd,0x93,0x93,0xdd,0xdd,0x99,0x00,0x00,
    0xaa,0x00,0x00,0xaa,0x00,0x55,0xaa,0x00,0xaa,0x9e,0x00,0xee,0xaa,0x55,0x00,0xaa,
    0x55,0x55,0xaa,0x55,0xaa,0x9e,0x4f,0xee,0xaa,0xaa,0x00,0xaa,0xaa,0x55,0xaa,0xaa,
    0xaa,0x9e,0x9e,0xee,0x9e,0xee,0x00,0x9e,0xee,0x4f,0x9e,0xee,0x9e,0x9e,0xee,0xee,
    0xaa,0xff,0xff,0xbb,0x00,0x00,0xbb,0x00,0x5d,0xbb,0x00,0xbb,0xaa,0x00,0xff,0xbb,
    0x5d,0x00,0xbb,0x5d,0x5d,0xbb,0x5d,0xbb,0xaa,0x55,0xff,0xbb,0xbb,0x00,0xbb,0xbb,
    0x5d,0xbb,0xbb,0xbb,0xaa,0xaa,0xff,0xaa,0xff,0x00,0xaa,0xff,0x55,0xaa,0xff,0xaa,
    0xcc,0x00,0xcc,0xcc,0x44,0x00,0xcc,0x44,0x44,0xcc,0x44,0x88,0xcc,0x44,0xcc,0xcc,
    0x88,0x00,0xcc,0x88,0x44,0xcc,0x88,0x88,0xcc,0x88,0xcc,0xcc,0xcc,0x00,0xcc,0xcc,
    0x44,0xcc,0xcc,0x88,0xcc,0xcc,0xcc,0xcc,0x00,0x00,0xcc,0x00,0x44,0xcc,0x00,0x88,
    0xdd,0x00,0x93,0xdd,0x00,0xdd,0xdd,0x49,0x00,0xdd,0x49,0x49,0xdd,0x49,0x93,0xdd,
    0x49,0xdd,0xdd,0x93,0x00,0xdd,0x93,0x49,0xdd,0x93,0x93,0xdd,0x93,0xdd,0xdd,0xdd,
    0x00,0xdd,0xdd,0x49,0xdd,0xdd,0x93,0xdd,0xdd,0xdd,0xdd,0x00,0x00,0xdd,0x00,0x49,
    0xee,0x00,0x4f,0xee,0x00,0x9e,0xee,0x00,0xee,0xee,0x4f,0x00,0xee,0x4f,0x4f,0xee,
    0x4f,0x9e,0xee,0x4f,0xee,0xee,0x9e,0x00,0xee,0x9e,0x4f,0xee,0x9e,0x9e,0xee,0x9e,
    0xee,0xee,0xee,0x00,0xee,0xee,0x4f,0xee,0xee,0x9e,0xee,0xee,0xee,0xee,0x00,0x00,
    0xff,0x00,0x00,0xff,0x00,0x55,0xff,0x00,0xaa,0xff,0x00,0xff,0xff,0x55,0x00,0xff,
    0x55,0x55,0xff,0x55,0xaa,0xff,0x55,0xff,0xff,0xaa,0x00,0xff,0xaa,0x55,0xff,0xaa,
    0xaa,0xff,0xaa,0xff,0xff,0xff,0x00,0xff,0xff,0x55,0xff,0xff,0xaa,0xff,0xff,0xff,
},
/* rgb2cmap */ {
    0x00,0x00,0x11,0x01,0x01,0x12,0x23,0x34,0x02,0x13,0x24,0x35,0x03,0x14,0x25,0x36,
    0x00,0x11,0x11,0x01,0x01,0x12,0x23,0x34,0x02,0x13,0x24,0x35,0x03,0x14,0x25,0x36,
    0x11,0x11,0x11,0x01,0x01,0x12,0x23,0x34,0x02,0x13,0x24,0x35,0x03,0x14,0x25,0x36,
    0x04,0x04,0x04,0x05,0x05,0x05,0x05,0x06,0x06,0x06,0x17,0x07,0x07,0x18,0x18,0x29,
    0x04,0x04,0x04,0x05,0x05,0x05,0x16,0x06,0x06,0x17,0x28,0x07,0x07,0x18,0x29,0x3a,
    0x15,0x15,0x15,0x05,0x05,0x16,0x16,0x06,0x06,0x17,0x28,0x39,0x07,0x18,0x29,0x3a,
    0x26,0x26,0x26,0x05,0x16,0x16,0x27,0x27,0x38,0x28,0x28,0x39,0x39,0x29,0x29,0x3a,
    0x37,0x37,0x37,0x09,0x09,0x09,0x27,0x38,0x0a,0x0a,0x39,0x0b,0x0b,0x0b,0x1c,0x3a,
    0x08,0x08,0x08,0x09,0x09,0x09,0x38,0x0a,0x0a,0x0a,0x1b,0x0b,0x0b,0x1c,0x1c,0x2d,
    0x19,0x19,0x19,0x09,0x1a,0x1a,0x2b,0x0a,0x0a,0x1b,0x1b,0x0b,0x0b,0x1c,0x2d,0x3e,
    0x2a,0x2a,0x2a,0x1a,0x2b,0x2b,0x2b,0x3c,0x1b,0x1b,0x2c,0x2c,0x3d,0x2d,0x2d,0x3e,
    0x3b,0x3b,0x3b,0x0d,0x0d,0x3c,0x3c,0x0e,0x0e,0x0e,0x2c,0x3d,0x0f,0x0f,0x3e,0x3e,
    0x0c,0x0c,0x0c,0x0d,0x0d,0x0d,0x3c,0x0e,0x0e,0x0e,0x3d,0x0f,0x0f,0x0f,0x10,0x3e,
    0x1d,0x1d,0x1d,0x1e,0x1e,0x1e,0x2f,0x0e,0x1f,0x1f,0x20,0x0f,0x0f,0x10,0x10,0x21,
    0x2e,0x2e,0x2e,0x1e,0x2f,0x2f,0x2f,0x1f,0x1f,0x20,0x20,0x31,0x10,0x10,0x21,0x21,
    0x3f,0x3f,0x3f,0x2f,0x30,0x30,0x30,0x30,0x20,0x31,0x31,0x31,0x31,0x21,0x21,0x32,
    0x00,0x11,0x11,0x01,0x01,0x12,0x23,0x34,0x02,0x13,0x24,0x35,0x03,0x14,0x25,0x36,
    0x11,0x11,0x11,0x01,0x01,0x12,0x23,0x34,0x02,0x13,0x24,0x35,0x03,0x14,0x25,0x36,
    0x11,0x11,0x22,0x22,0x01,0x12,0x23,0x34,0x02,0x13,0x24,0x35,0x03,0x14,0x25,0x36,
    0x04,0x04,0x22,0x05,0x05,0x05,0x05,0x06,0x06,0x06,0x17,0x07,0x07,0x18,0x18,0x29,
    0x04,0x04,0x04,0x05,0x05,0x05,0x16,0x06,0x06,0x17,0x28,0x07,0x07,0x18,0x29,0x3a,
    0x15,0x15,0x15,0x05,0x05,0x16,0x16,0x06,0x06,0x17,0x28,0x39,0x07,0x18,0x29,0x3a,
    0x26,0x26,0x26,0x05,0x16,0x16,0x27,0x27,0x38,0x28,0x28,0x39,0x39,0x29,0x29,0x3a,
    0x37,0x37,0x37,0x09,0x09,0x09,0x27,0x38,0x0a,0x0a,0x39,0x0b,0x0b,0x0b,0x1c,0x3a,
    0x08,0x08,0x08,0x09,0x09,0x09,0x38,0x0a,0x0a,0x0a,0x1b,0x0b,0x0b,0x1c,0x1c,0x2d,
    0x19,0x19,0x19,0x09,0x1a,0x1a,0x2b,0x0a,0x0a,0x1b,0x1b,0x0b,0x0b,0x1c,0x2d,0x3e,
    0x2a,0x2a,0x2a,0x1a,0x2b,0x2b,0x2b,0x3c,0x1b,0x1b,0x2c,0x2c,0x3d,0x2d,0x2d,0x3e,
    0x3b,0x3b,0x3b,0x0d,0x0d,0x3c,0x3c,0x0e,0x0e,0x0e,0x2c,0x3d,0x0f,0x0f,0x3e,0x3e,
    0x0c,0x0c,0x0c,0x0d,0x0d,0x0d,0x3c,0x0e,0x0e,0x0e,0x3d,0x0f,0x0f,0x0f,0x10,0x3e,
    0x1d,0x1d,0x1d,0x1e,0x1e,0x1e,0x2f,0x0e,0x1f,0x1f,0x20,0x0f,0x0f,0x10,0x10,0x21,
    0x2e,0x2e,0x2e,0x1e,0x2f,0x2f,0x2f,0x1f,0x1f,0x20,0x20,0x31,0x10,0x10,0x21,0x21,
    0x3f,0x3f,0x3f,0x2f,0x30,0x30,0x30,0x30,0x20,0x31,0x31,0x31,0x31,0x21,0x21,0x32,
    0x11,0x11,0x11,0x01,0x01,0x12,0x23,0x34,0x02,0x13,0x24,0x35,0x03,0x14,0x25,0x36,
    0x11,0x11,0x22,0x22,0x01,0x12,0x23,0x34,0x02,0x13,0x24,0x35,0x03,0x14,0x25,0x36,
    0x11,0x22,0x22,0x22,0x33,0x33,0x23,0x34,0x02,0x13,0x24,0x35,0x03,0x14,0x25,0x36,
    0x04,0x22,0x22,0x33,0x33,0x33,0x05,0x06,0x06,0x06,0x17,0x07,0x07,0x18,0x18,0x29,
    0x04,0x04,0x33,0x33,0x33,0x05,0x16,0x06,0x06,0x17,0x28,0x07,0x07,0x18,0x29,0x3a,
    0x15,0x15,0x33,0x33,0x05,0x16,0x16,0x06,0x06,0x17,0x28,0x39,0x07,0x18,0x29,0x3a,
    0x26,0x26,0x26,0x05,0x16,0x16,0x27,0x27,0x38,0x28,0x28,0x39,0x39,0x29,0x29,0x3a,
    0x37,0x37,0x37,0x09,0x09,0x09,0x27,0x38,0x0a,0x0a,0x39,0x0b,0x0b,0x0b,0x1c,0x3a,
    0x08,0x08,0x08,0x09,0x09,0x09,0x38,0x0a,0x0a,0x0a,0x1b,0x0b,0x0b,0x1c,0x1c,0x2d,
    0x19,0x19,0x19,0x09,0x1a,0x1a,0x2b,0x0a,0x0a,0x1b,0x1b,0x0b,0x0b,0x1c,0x2d,0x3e,
    0x2a,0x2a,0x2a,0x1a,0x2b,0x2b,0x2b,0x3c,0x1b,0x1b,0x2c,0x2c,0x3d,0x2d,0x2d,0x3e,
    0x3b,0x3b,0x3b,0x0d,0x0d,0x3c,0x3c,0x0e,0x0e,0x0e,0x2c,0x3d,0x0f,0x0f,0x3e,0x3e,
    0x0c,0x0c,0x0c,0x0d,0x0d,0x0d,0x3c,0x0e,0x0e,0x0e,0x3d,0x0f,0x0f,0x0f,0x10,0x3e,
    0x1d,0x1d,0x1d,0x1e,0x1e,0x1e,0x2f,0x0e,0x1f,0x1f,0x20,0x0f,0x0f,0x10,0x10,0x21,
    0x2e,0x2e,0x2e,0x1e,0x2f,0x2f,0x2f,0x1f,0x1f,0x20,0x20,0x31,0x10,0x10,0x21,0x21,
    0x3f,0x3f,0x3f,0x2f,0x30,0x30,0x30,0x30,0x20,0x31,0x31,0x31,0x31,0x21,0x21,0x32,
    0x4f,0x4f,0x22,0x40,0x40,0x40,0x40,0x41,0x41,0x41,0x52,0x42,0x42,0x53,0x53,0x64,
    0x4f,0x22,0x22,0x22,0x40,0x40,0x40,0x41,0x41,0x41,0x52,0x42,0x42,0x53,0x53,0x64,
    0x22,0x22,0x22,0x33,0x33,0x33,0x40,0x41,0x41,0x41,0x52,0x42,0x42,0x53,0x53,0x64,
    0x43,0x22,0x33,0x33,0x33,0x44,0x44,0x45,0x45,0x45,0x56,0x46,0x46,0x46,0x57,0x68,
    0x43,0x43,0x33,0x33,0x44,0x44,0x44,0x45,0x45,0x45,0x56,0x46,0x46,0x57,0x57,0x68,
    0x43,0x43,0x33,0x44,0x44,0x44,0x55,0x45,0x45,0x56,0x56,0x46,0x46,0x57,0x68,0x68,
    0x43,0x43,0x43,0x44,0x44,0x55,0x55,0x45,0x45,0x56,0x67,0x46,0x46,0x57,0x68,0x79,
    0x47,0x47,0x47,0x48,0x48,0x48,0x48,0x49,0x49,0x49,0x49,0x4a,0x4a,0x4a,0x5b,0x79,
    0x47,0x47,0x47,0x48,0x48,0x48,0x48,0x49,0x49,0x49,0x5a,0x4a,0x4a,0x4a,0x5b,0x6c,
    0x47,0x47,0x47,0x48,0x48,0x59,0x59,0x49,0x49,0x5a,0x5a,0x4a,0x4a,0x5b,0x5b,0x6c,
    0x58,0x58,0x58,0x59,0x59,0x59,0x6a,0x49,0x5a,0x5a,0x6b,0x6b,0x5b,0x5b,0x6c,0x7d,
    0x4b,0x4b,0x4b,0x4c,0x4c,0x4c,0x4c,0x4d,0x4d,0x4d,0x6b,0x4e,0x4e,0x4e,0x6c,0x7d,
    0x4b,0x4b,0x4b,0x4c,0x4c,0x4c,0x4c,0x4d,0x4d,0x4d,0x5e,0x4e,0x4e,0x4e,0x5f,0x5f,
    0x5c,0x5c,0x5c,0x4c,0x5d,0x5d,0x5d,0x4d,0x4d,0x5e,0x5e,0x4e,0x4e,0x5f,0x5f,0x60,
    0x5c,0x5c,0x5c,0x5d,0x5d,0x6e,0x6e,0x5e,0x5e,0x5e,0x6f,0x6f,0x5f,0x5f,0x60,0x60,
    0x6d,0x6d,0x6d,0x6e,0x6e,0x6e,0x7f,0x7f,0x6f,0x6f,0x70,0x70,0x5f,0x60,0x60,0x71,
    0x4f,0x4f,0x40,0x40,0x40,0x40,0x51,0x41,0x41,0x52,0x63,0x42,0x42,0x53,0x64,0x75,
    0x4f,0x4f,0x22,0x40,0x40,0x40,0x51,0x41,0x41,0x52,0x63,0x42,0x42,0x53,0x64,0x75,
    0x43,0x22,0x33,0x33,0x33,0x40,0x51,0x41,0x41,0x52,0x63,0x42,0x42,0x53,0x64,0x75,
    0x43,0x43,0x33,0x33,0x44,0x44,0x44,0x45,0x45,0x45,0x56,0x46,0x46,0x57,0x57,0x68,
    0x43,0x43,0x33,0x44,0x44,0x44,0x55,0x45,0x45,0x56,0x56,0x46,0x46,0x57,0x68,0x68,
    0x43,0x43,0x43,0x44,0x44,0x55,0x55,0x45,0x45,0x56,0x67,0x46,0x46,0x57,0x68,0x79,
    0x54,0x54,0x54,0x44,0x55,0x55,0x55,0x45,0x56,0x56,0x67,0x78,0x78,0x57,0x68,0x79,
    0x47,0x47,0x47,0x48,0x48,0x48,0x48,0x49,0x49,0x49,0x49,0x4a,0x4a,0x4a,0x5b,0x79,
    0x47,0x47,0x47,0x48,0x48,0x48,0x59,0x49,0x49,0x49,0x5a,0x4a,0x4a,0x5b,0x5b,0x6c,
    0x58,0x58,0x58,0x48,0x59,0x59,0x59,0x49,0x49,0x5a,0x5a,0x4a,0x4a,0x5b,0x6c,0x6c,
    0x69,0x69,0x69,0x59,0x59,0x6a,0x6a,0x49,0x5a,0x5a,0x6b,0x6b,0x5b,0x5b,0x6c,0x7d,
    0x4b,0x4b,0x4b,0x4c,0x4c,0x4c,0x7b,0x4d,0x4d,0x4d,0x6b,0x4e,0x4e,0x4e,0x7d,0x7d,
    0x4b,0x4b,0x4b,0x4c,0x4c,0x4c,0x7b,0x4d,0x4d,0x4d,0x5e,0x4e,0x4e,0x4e,0x5f,0x7d,
    0x5c,0x5c,0x5c,0x5d,0x5d,0x5d,0x5d,0x4d,0x5e,0x5e,0x5e,0x4e,0x4e,0x5f,0x5f,0x60,
    0x6d,0x6d,0x6d,0x5d,0x6e,0x6e,0x6e,0x5e,0x5e,0x6f,0x6f,0x70,0x5f,0x5f,0x60,0x60,
    0x7e,0x7e,0x7e,0x6e,0x6e,0x7f,0x7f,0x7f,0x6f,0x6f,0x70,0x70,0x70,0x60,0x60,0x71,
    0x50,0x50,0x50,0x40,0x40,0x51,0x51,0x41,0x41,0x52,0x63,0x74,0x42,0x53,0x64,0x75,
    0x50,0x50,0x50,0x40,0x40,0x51,0x51,0x41,0x41,0x52,0x63,0x74,0x42,0x53,0x64,0x75,
    0x50,0x50,0x33,0x33,0x40,0x51,0x51,0x41,0x41,0x52,0x63,0x74,0x42,0x53,0x64,0x75,
    0x43,0x43,0x33,0x44,0x44,0x44,0x55,0x45,0x45,0x56,0x56,0x46,0x46,0x57,0x68,0x68,
    0x43,0x43,0x43,0x44,0x44,0x55,0x55,0x45,0x45,0x56,0x67,0x46,0x46,0x57,0x68,0x79,
    0x54,0x54,0x54,0x44,0x55,0x55,0x55,0x45,0x56,0x56,0x67,0x78,0x78,0x57,0x68,0x79,
    0x54,0x54,0x54,0x55,0x55,0x55,0x66,0x66,0x56,0x67,0x67,0x78,0x78,0x68,0x68,0x79,
    0x47,0x47,0x47,0x48,0x48,0x48,0x66,0x49,0x49,0x49,0x78,0x78,0x4a,0x4a,0x5b,0x79,
    0x47,0x47,0x47,0x48,0x48,0x59,0x59,0x49,0x49,0x5a,0x5a,0x4a,0x4a,0x5b,0x6c,0x6c,
    0x58,0x58,0x58,0x59,0x59,0x59,0x6a,0x49,0x5a,0x5a,0x6b,0x6b,0x5b,0x5b,0x6c,0x7d,
    0x69,0x69,0x69,0x59,0x6a,0x6a,0x6a,0x7b,0x5a,0x6b,0x6b,0x6b,0x7c,0x6c,0x6c,0x7d,
    0x7a,0x7a,0x7a,0x4c,0x4c,0x7b,0x7b,0x7b,0x4d,0x6b,0x6b,0x7c,0x7c,0x4e,0x7d,0x7d,
    0x4b,0x4b,0x4b,0x4c,0x4c,0x7b,0x7b,0x4d,0x4d,0x5e,0x7c,0x7c,0x4e,0x5f,0x5f,0x7d,
    0x5c,0x5c,0x5c,0x5d,0x5d,0x5d,0x6e,0x4d,0x5e,0x5e,0x6f,0x4e,0x5f,0x5f,0x60,0x60,
    0x6d,0x6d,0x6d,0x6e,0x6e,0x6e,0x6e,0x5e,0x6f,0x6f,0x6f,0x70,0x5f,0x60,0x60,0x71,
    0x7e,0x7e,0x7e,0x6e,0x7f,0x7f,0x7f,0x7f,0x6f,0x70,0x70,0x70,0x70,0x60,0x71,0x71,
    0x61,0x61,0x61,0x40,0x51,0x51,0x62,0x62,0x73,0x63,0x63,0x74,0x74,0x64,0x64,0x75,
    0x61,0x61,0x61,0x40,0x51,0x51,0x62,0x62,0x73,0x63,0x63,0x74,0x74,0x64,0x64,0x75,
    0x61,0x61,0x61,0x40,0x51,0x51,0x62,0x62,0x73,0x63,0x63,0x74,0x74,0x64,0x64,0x75,
    0x43,0x43,0x43,0x44,0x44,0x55,0x55,0x45,0x45,0x56,0x67,0x46,0x46,0x57,0x68,0x79,
    0x54,0x54,0x54,0x44,0x55,0x55,0x55,0x45,0x56,0x56,0x67,0x78,0x78,0x57,0x68,0x79,
    0x54,0x54,0x54,0x55,0x55,0x55,0x66,0x66,0x56,0x67,0x67,0x78,0x78,0x68,0x68,0x79,
    0x65,0x65,0x65,0x55,0x55,0x66,0x66,0x66,0x77,0x67,0x78,0x78,0x78,0x78,0x79,0x79,
    0x65,0x65,0x65,0x48,0x48,0x66,0x66,0x77,0x77,0x77,0x78,0x78,0x78,0x5b,0x79,0x79,
    0x76,0x76,0x76,0x48,0x59,0x59,0x77,0x77,0x77,0x5a,0x5a,0x4a,0x4a,0x5b,0x6c,0x6c,
    0x69,0x69,0x69,0x59,0x59,0x6a,0x6a,0x77,0x5a,0x5a,0x6b,0x6b,0x5b,0x6c,0x6c,0x7d,
    0x69,0x69,0x69,0x6a,0x6a,0x6a,0x7b,0x7b,0x5a,0x6b,0x6b,0x7c,0x7c,0x6c,0x7d,0x7d,
    0x7a,0x7a,0x7a,0x4c,0x7b,0x7b,0x7b,0x7b,0x4d,0x6b,0x7c,0x7c,0x7c,0x7c,0x7d,0x7d,
    0x7a,0x7a,0x7a,0x4c,0x7b,0x7b,0x7b,0x7b,0x4d,0x5e,0x7c,0x7c,0x7c,0x5f,0x5f,0x7d,
    0x6d,0x6d,0x6d,0x5d,0x5d,0x6e,0x7b,0x5e,0x5e,0x6f,0x6f,0x7c,0x5f,0x5f,0x60,0x60,
    0x6d,0x6d,0x6d,0x6e,0x6e,0x6e,0x7f,0x7f,0x6f,0x6f,0x70,0x70,0x5f,0x60,0x60,0x71,
    0x7e,0x7e,0x7e,0x7f,0x7f,0x7f,0x7f,0x7f,0x6f,0x70,0x70,0x70,0x70,0x60,0x71,0x71,
    0x72,0x72,0x72,0x8f,0x8f,0x62,0x62,0x73,0x73,0x80,0x74,0x81,0x81,0x81,0x92,0x75,
    0x72,0x72,0x72,0x8f,0x8f,0x62,0x62,0x73,0x73,0x80,0x74,0x81,0x81,0x81,0x92,0x75,
    0x72,0x72,0x72,0x83,0x83,0x62,0x62,0x73,0x73,0x80,0x74,0x81,0x81,0x81,0x92,0x75,
    0x82,0x82,0x82,0x83,0x83,0x83,0x83,0x84,0x84,0x84,0x84,0x85,0x85,0x85,0x96,0x79,
    0x82,0x82,0x82,0x83,0x83,0x83,0x66,0x84,0x84,0x84,0x67,0x85,0x85,0x85,0x96,0x79,
    0x65,0x65,0x65,0x83,0x83,0x66,0x66,0x66,0x84,0x84,0x78,0x78,0x85,0x85,0x96,0x79,
    0x65,0x65,0x65,0x83,0x66,0x66,0x66,0x77,0x77,0x77,0x78,0x78,0x78,0x96,0x79,0x79,
    0x76,0x76,0x76,0x87,0x87,0x66,0x77,0x77,0x77,0x88,0x78,0x89,0x89,0x89,0x89,0x79,
    0x76,0x76,0x76,0x87,0x87,0x87,0x77,0x77,0x88,0x88,0x88,0x89,0x89,0x89,0x9a,0x9a,
    0x86,0x86,0x86,0x87,0x87,0x87,0x77,0x88,0x88,0x88,0x6b,0x89,0x89,0x9a,0x9a,0x7d,
    0x7a,0x7a,0x7a,0x87,0x6a,0x7b,0x7b,0x7b,0x88,0x6b,0x6b,0x7c,0x7c,0x9a,0x7d,0x7d,
    0x8a,0x8a,0x8a,0x8b,0x8b,0x7b,0x7b,0x8c,0x8c,0x8c,0x7c,0x7c,0x8d,0x8d,0x7d,0x7d,
    0x8a,0x8a,0x8a,0x8b,0x8b,0x8b,0x7b,0x8c,0x8c,0x8c,0x7c,0x8d,0x8d,0x8d,0x9e,0x9e,
    0x8a,0x8a,0x8a,0x8b,0x8b,0x8b,0x9c,0x8c,0x8c,0x9d,0x9d,0x8d,0x8d,0x9e,0x9e,0x9e,
    0x9b,0x9b,0x9b,0x9c,0x9c,0x9c,0x7f,0x8c,0x9d,0x9d,0x70,0x70,0x9e,0x9e,0x9e,0x71,
    0x7e,0x7e,0x7e,0x7f,0x7f,0x7f,0x7f,0x7f,0x9d,0x70,0x70,0x70,0x9e,0x9e,0x71,0x71,
    0x8e,0x8e,0x8e,0x8f,0x8f,0x8f,0x73,0x73,0x80,0x80,0x91,0x81,0x81,0x92,0x92,0xa3,
    0x8e,0x8e,0x8e,0x8f,0x8f,0x8f,0x73,0x73,0x80,0x80,0x91,0x81,0x81,0x92,0x92,0xa3,
    0x82,0x82,0x82,0x83,0x83,0x83,0x73,0x73,0x80,0x80,0x91,0x81,0x81,0x92,0x92,0xa3,
    0x82,0x82,0x82,0x83,0x83,0x83,0x83,0x84,0x84,0x84,0x95,0x85,0x85,0x85,0x96,0xa7,
    0x82,0x82,0x82,0x83,0x83,0x83,0x94,0x84,0x84,0x84,0x95,0x85,0x85,0x96,0x96,0xa7,
    0x82,0x82,0x82,0x83,0x83,0x94,0x94,0x84,0x84,0x95,0x95,0x85,0x85,0x96,0xa7,0xa7,
    0x76,0x76,0x76,0x83,0x94,0x94,0x77,0x77,0x77,0x95,0x95,0x85,0x85,0x96,0xa7,0xa7,
    0x76,0x76,0x76,0x87,0x87,0x87,0x77,0x77,0x88,0x88,0x88,0x89,0x89,0x89,0x9a,0x9a,
    0x86,0x86,0x86,0x87,0x87,0x87,0x77,0x88,0x88,0x88,0x99,0x89,0x89,0x9a,0x9a,0xab,
    0x86,0x86,0x86,0x87,0x87,0x98,0x98,0x88,0x88,0x99,0x99,0x89,0x89,0x9a,0x9a,0xab,
    0x97,0x97,0x97,0x98,0x98,0x98,0x98,0x88,0x99,0x99,0x99,0x89,0x9a,0x9a,0xab,0xab,
    0x8a,0x8a,0x8a,0x8b,0x8b,0x8b,0x8b,0x8c,0x8c,0x8c,0x8c,0x8d,0x8d,0x8d,0xab,0xbc,
    0x8a,0x8a,0x8a,0x8b,0x8b,0x8b,0x8b,0x8c,0x8c,0x8c,0x9d,0x8d,0x8d,0x8d,0x9e,0x9e,
    0x9b,0x9b,0x9b,0x8b,0x9c,0x9c,0x9c,0x8c,0x9d,0x9d,0x9d,0x8d,0x8d,0x9e,0x9e,0xaf,
    0x9b,0x9b,0x9b,0x9c,0x9c,0xad,0xad,0x9d,0x9d,0x9d,0xae,0xae,0x9e,0x9e,0xaf,0xaf,
    0xac,0xac,0xac,0xad,0xad,0xad,0xad,0x9d,0xae,0xae,0xae,0xbf,0x9e,0xaf,0xaf,0xaf,
    0x9f,0x9f,0x9f,0x8f,0x90,0x90,0xa1,0x80,0x80,0x91,0x91,0x81,0x81,0x92,0xa3,0xb4,
    0x9f,0x9f,0x9f,0x8f,0x90,0x90,0xa1,0x80,0x80,0x91,0x91,0x81,0x81,0x92,0xa3,0xb4,
    0x9f,0x9f,0x9f,0x83,0x90,0x90,0xa1,0x80,0x80,0x91,0x91,0x81,0x81,0x92,0xa3,0xb4,
    0x82,0x82,0x82,0x83,0x83,0x94,0x94,0x84,0x84,0x95,0x95,0x85,0x85,0x96,0x96,0xa7,
    0x93,0x93,0x93,0x83,0x94,0x94,0x94,0x84,0x84,0x95,0x95,0x85,0x85,0x96,0xa7,0xa7,
    0x93,0x93,0x93,0x94,0x94,0x94,0xa5,0x84,0x95,0x95,0xa6,0xa6,0x96,0x96,0xa7,0xb8,
    0xa4,0xa4,0xa4,0x94,0x94,0xa5,0xa5,0x77,0x95,0x95,0xa6,0xa6,0x96,0xa7,0xa7,0xb8,
    0x86,0x86,0x86,0x87,0x87,0x87,0x77,0x88,0x88,0x88,0x99,0x89,0x89,0x9a,0x9a,0xb8,
    0x86,0x86,0x86,0x87,0x87,0x98,0x98,0x88,0x88,0x99,0x99,0x89,0x89,0x9a,0x9a,0xab,
    0x97,0x97,0x97,0x98,0x98,0x98,0x98,0x88,0x99,0x99,0x99,0x89,0x9a,0x9a,0xab,0xab,
    0x97,0x97,0x97,0x98,0x98,0xa9,0xa9,0x99,0x99,0x99,0xaa,0xaa,0x9a,0xab,0xab,0xbc,
    0x8a,0x8a,0x8a,0x8b,0x8b,0xa9,0xa9,0x8c,0x8c,0x8c,0xaa,0x8d,0x8d,0x8d,0xab,0xbc,
    0x8a,0x8a,0x8a,0x8b,0x8b,0x9c,0x9c,0x8c,0x8c,0x9d,0x9d,0x8d,0x8d,0x9e,0x9e,0xbc,
    0x9b,0x9b,0x9b,0x9c,0x9c,0x9c,0xad,0x9d,0x9d,0x9d,0xae,0x8d,0x9e,0x9e,0xaf,0xaf,
    0xac,0xac,0xac,0x9c,0xad,0xad,0xad,0x9d,0x9d,0xae,0xae,0xae,0x9e,0xaf,0xaf,0xaf,
    0xbd,0xbd,0xbd,0xad,0xad,0xbe,0xbe,0xbe,0xae,0xae,0xbf,0xbf,0xbf,0xaf,0xaf,0xb0,
    0xa0,0xa0,0xa0,0x90,0xa1,0xa1,0xa1,0xb2,0x91,0x91,0xa2,0xa2,0xb3,0xa3,0xa3,0xb4,
    0xa0,0xa0,0xa0,0x90,0xa1,0xa1,0xa1,0xb2,0x91,0x91,0xa2,0xa2,0xb3,0xa3,0xa3,0xb4,
    0xa0,0xa0,0xa0,0x90,0xa1,0xa1,0xa1,0xb2,0x91,0x91,0xa2,0xa2,0xb3,0xa3,0xa3,0xb4,
    0x93,0x93,0x93,0x94,0x94,0x94,0xa5,0x84,0x95,0x95,0xa6,0xa6,0x96,0x96,0xa7,0xb8,
    0xa4,0xa4,0xa4,0x94,0x94,0xa5,0xa5,0x84,0x95,0x95,0xa6,0xa6,0x96,0x96,0xa7,0xb8,
    0xa4,0xa4,0xa4,0x94,0xa5,0xa5,0xa5,0xb6,0x95,0xa6,0xa6,0xa6,0xb7,0xa7,0xa7,0xb8,
    0xa4,0xa4,0xa4,0xa5,0xa5,0xa5,0xb6,0xb6,0x95,0xa6,0xa6,0xb7,0xb7,0xa7,0xb8,0xb8,
    0xb5,0xb5,0xb5,0x87,0x87,0xb6,0xb6,0xb6,0x88,0x99,0xa6,0xb7,0xb7,0x9a,0xb8,0xb8,
    0x97,0x97,0x97,0x98,0x98,0x98,0x98,0x88,0x99,0x99,0x99,0x89,0x9a,0x9a,0xab,0xab,
    0x97,0x97,0x97,0x98,0x98,0xa9,0xa9,0x99,0x99,0x99,0xaa,0xaa,0x9a,0xab,0xab,0xbc,
    0xa8,0xa8,0xa8,0xa9,0xa9,0xa9,0xa9,0xa9,0x99,0xaa,0xaa,0xaa,0xbb,0xab,0xab,0xbc,
    0xa8,0xa8,0xa8,0xa9,0xa9,0xa9,0xba,0xba,0x8c,0xaa,0xaa,0xbb,0xbb,0xab,0xbc,0xbc,
    0xb9,0xb9,0xb9,0x9c,0x9c,0xba,0xba,0xba,0x9d,0x9d,0xbb,0xbb,0xbb,0x9e,0x9e,0xbc,
    0xac,0xac,0xac,0x9c,0x9c,0xad,0xad,0x9d,0x9d,0xae,0xae,0xae,0x9e,0x9e,0xaf,0xaf,
    0xac,0xac,0xac,0xad,0xad,0xad,0xbe,0xbe,0xae,0xae,0xae,0xbf,0x9e,0xaf,0xaf,0xb0,
    0xbd,0xbd,0xbd,0xbe,0xbe,0xbe,0xbe,0xbe,0xae,0xbf,0xbf,0xbf,0xbf,0xaf,0xb0,0xb0,
    0xb1,0xb1,0xb1,0xce,0xce,0xb2,0xb2,0xcf,0xcf,0xa2,0xa2,0xb3,0xb3,0xc0,0xb4,0xb4,
    0xb1,0xb1,0xb1,0xce,0xce,0xb2,0xb2,0xcf,0xcf,0xa2,0xa2,0xb3,0xb3,0xc0,0xb4,0xb4,
    0xb1,0xb1,0xb1,0xc2,0xc2,0xb2,0xb2,0xc3,0xc3,0xa2,0xa2,0xb3,0xb3,0xc0,0xb4,0xb4,
    0xc1,0xc1,0xc1,0xc2,0xc2,0xc2,0xa5,0xc3,0xc3,0xc3,0xa6,0xc4,0xc4,0xc4,0xa7,0xb8,
    0xc1,0xc1,0xc1,0xc2,0xc2,0xa5,0xb6,0xc3,0xc3,0xc3,0xa6,0xc4,0xc4,0xc4,0xb8,0xb8,
    0xb5,0xb5,0xb5,0xc2,0xa5,0xb6,0xb6,0xb6,0xc3,0xa6,0xa6,0xb7,0xb7,0xc4,0xb8,0xb8,
    0xb5,0xb5,0xb5,0xa5,0xb6,0xb6,0xb6,0xb6,0xc3,0xa6,0xb7,0xb7,0xb7,0xb7,0xb8,0xb8,
    0xc5,0xc5,0xc5,0xc6,0xc6,0xb6,0xb6,0xc7,0xc7,0xc7,0xb7,0xb7,0xc8,0xc8,0xb8,0xb8,
    0xc5,0xc5,0xc5,0xc6,0xc6,0xc6,0xc6,0xc7,0xc7,0xc7,0xaa,0xc8,0xc8,0xc8,0xab,0xbc,
    0xa8,0xa8,0xa8,0xc6,0xc6,0xa9,0xa9,0xc7,0xc7,0xaa,0xaa,0xaa,0xc8,0xc8,0xab,0xbc,
    0xa8,0xa8,0xa8,0xa9,0xa9,0xa9,0xba,0xba,0xaa,0xaa,0xaa,0xbb,0xbb,0xab,0xbc,0xbc,
    0xb9,0xb9,0xb9,0xca,0xca,0xba,0xba,0xba,0xcb,0xaa,0xbb,0xbb,0xbb,0xcc,0xbc,0xbc,
    0xb9,0xb9,0xb9,0xca,0xca,0xba,0xba,0xcb,0xcb,0xcb,0xbb,0xbb,0xcc,0xcc,0xcc,0xbc,
    0xc9,0xc9,0xc9,0xca,0xca,0xca,0xba,0xcb,0xcb,0xcb,0xae,0xcc,0xcc,0xcc,0xaf,0xaf,
    0xbd,0xbd,0xbd,0xad,0xbe,0xbe,0xbe,0xbe,0xae,0xae,0xbf,0xbf,0xcc,0xaf,0xaf,0xb0,
    0xbd,0xbd,0xbd,0xbe,0xbe,0xbe,0xbe,0xbe,0xbf,0xbf,0xbf,0xbf,0xbf,0xaf,0xb0,0xb0,
    0xcd,0xcd,0xcd,0xce,0xce,0xce,0xb2,0xcf,0xcf,0xcf,0xb3,0xb3,0xc0,0xc0,0xd1,0xb4,
    0xcd,0xcd,0xcd,0xce,0xce,0xce,0xb2,0xcf,0xcf,0xcf,0xb3,0xb3,0xc0,0xc0,0xd1,0xb4,
    0xc1,0xc1,0xc1,0xc2,0xc2,0xc2,0xb2,0xc3,0xc3,0xc3,0xb3,0xb3,0xc0,0xc0,0xd1,0xb4,
    0xc1,0xc1,0xc1,0xc2,0xc2,0xc2,0xc2,0xc3,0xc3,0xc3,0xd4,0xc4,0xc4,0xc4,0xd5,0xd5,
    0xc1,0xc1,0xc1,0xc2,0xc2,0xc2,0xb6,0xc3,0xc3,0xc3,0xd4,0xc4,0xc4,0xc4,0xd5,0xb8,
    0xc1,0xc1,0xc1,0xc2,0xc2,0xb6,0xb6,0xc3,0xc3,0xd4,0xb7,0xb7,0xc4,0xd5,0xd5,0xb8,
    0xb5,0xb5,0xb5,0xc2,0xb6,0xb6,0xb6,0xb6,0xc3,0xd4,0xb7,0xb7,0xb7,0xd5,0xd5,0xb8,
    0xc5,0xc5,0xc5,0xc6,0xc6,0xc6,0xb6,0xc7,0xc7,0xc7,0xb7,0xc8,0xc8,0xc8,0xd9,0xd9,
    0xc5,0xc5,0xc5,0xc6,0xc6,0xc6,0xc6,0xc7,0xc7,0xc7,0xd8,0xc8,0xc8,0xc8,0xd9,0xd9,
    0xc5,0xc5,0xc5,0xc6,0xc6,0xd7,0xd7,0xc7,0xc7,0xd8,0xd8,0xc8,0xc8,0xd9,0xd9,0xbc,
    0xb9,0xb9,0xb9,0xd7,0xd7,0xba,0xba,0xba,0xd8,0xd8,0xbb,0xbb,0xbb,0xd9,0xd9,0xbc,
    0xb9,0xb9,0xb9,0xca,0xca,0xba,0xba,0xcb,0xcb,0xcb,0xbb,0xbb,0xcc,0xcc,0xcc,0xbc,
    0xc9,0xc9,0xc9,0xca,0xca,0xca,0xba,0xcb,0xcb,0xcb,0xbb,0xcc,0xcc,0xcc,0xdd,0xdd,
    0xc9,0xc9,0xc9,0xca,0xca,0xdb,0xdb,0xcb,0xcb,0xdc,0xdc,0xcc,0xcc,0xdd,0xdd,0xdd,
    0xda,0xda,0xda,0xdb,0xdb,0xdb,0xdb,0xdc,0xdc,0xdc,0xdc,0xcc,0xdd,0xdd,0xdd,0xb0,
    0xbd,0xbd,0xbd,0xdb,0xbe,0xbe,0xbe,0xdc,0xdc,0xbf,0xbf,0xbf,0xdd,0xdd,0xb0,0xb0,
    0xde,0xde,0xde,0xdf,0xdf,0xdf,0xe0,0xcf,0xd0,0xd0,0xe1,0xc0,0xc0,0xd1,0xd1,0xe2,
    0xde,0xde,0xde,0xdf,0xdf,0xdf,0xe0,0xcf,0xd0,0xd0,0xe1,0xc0,0xc0,0xd1,0xd1,0xe2,
    0xde,0xde,0xde,0xdf,0xdf,0xdf,0xe0,0xc3,0xd0,0xd0,0xe1,0xc0,0xc0,0xd1,0xd1,0xe2,
    0xd2,0xd2,0xd2,0xc2,0xd3,0xd3,0xd3,0xc3,0xc3,0xd4,0xd4,0xc4,0xc4,0xd5,0xd5,0xe6,
    0xd2,0xd2,0xd2,0xd3,0xd3,0xd3,0xd3,0xc3,0xd4,0xd4,0xd4,0xc4,0xc4,0xd5,0xd5,0xe6,
    0xd2,0xd2,0xd2,0xd3,0xd3,0xd3,0xe4,0xc3,0xd4,0xd4,0xe5,0xc4,0xd5,0xd5,0xe6,0xe6,
    0xe3,0xe3,0xe3,0xd3,0xd3,0xe4,0xb6,0xd4,0xd4,0xe5,0xe5,0xb7,0xd5,0xd5,0xe6,0xe6,
    0xc5,0xc5,0xc5,0xc6,0xc6,0xc6,0xd7,0xc7,0xc7,0xd8,0xd8,0xc8,0xc8,0xd9,0xd9,0xd9,
    0xd6,0xd6,0xd6,0xc6,0xd7,0xd7,0xd7,0xc7,0xd8,0xd8,0xd8,0xc8,0xc8,0xd9,0xd9,0xea,
    0xd6,0xd6,0xd6,0xd7,0xd7,0xd7,0xe8,0xd8,0xd8,0xd8,0xe9,0xc8,0xd9,0xd9,0xea,0xea,
    0xe7,0xe7,0xe7,0xd7,0xd7,0xe8,0xe8,0xd8,0xd8,0xe9,0xe9,0xe9,0xd9,0xd9,0xea,0xea,
    0xc9,0xc9,0xc9,0xca,0xca,0xca,0xba,0xcb,0xcb,0xcb,0xe9,0xcc,0xcc,0xcc,0xea,0xea,
    0xc9,0xc9,0xc9,0xca,0xca,0xdb,0xdb,0xcb,0xcb,0xdc,0xdc,0xcc,0xcc,0xdd,0xdd,0xdd,
    0xda,0xda,0xda,0xdb,0xdb,0xdb,0xdb,0xdc,0xdc,0xdc,0xdc,0xcc,0xdd,0xdd,0xdd,0xee,
    0xda,0xda,0xda,0xdb,0xdb,0xec,0xec,0xdc,0xdc,0xed,0xed,0xed,0xdd,0xdd,0xee,0xee,
    0xeb,0xeb,0xeb,0xec,0xec,0xec,0xec,0xdc,0xed,0xed,0xed,0xed,0xdd,0xee,0xee,0xee,
    0xef,0xef,0xef,0xdf,0xe0,0xe0,0xe0,0xd0,0xd0,0xe1,0xe1,0xf2,0xd1,0xd1,0xe2,0xe2,
    0xef,0xef,0xef,0xdf,0xe0,0xe0,0xe0,0xd0,0xd0,0xe1,0xe1,0xf2,0xd1,0xd1,0xe2,0xe2,
    0xef,0xef,0xef,0xdf,0xe0,0xe0,0xe0,0xd0,0xd0,0xe1,0xe1,0xf2,0xd1,0xd1,0xe2,0xe2,
    0xd2,0xd2,0xd2,0xd3,0xd3,0xe4,0xe4,0xd4,0xd4,0xd4,0xe5,0xe5,0xd5,0xd5,0xe6,0xe6,
    0xe3,0xe3,0xe3,0xd3,0xe4,0xe4,0xe4,0xd4,0xd4,0xe5,0xe5,0xf6,0xd5,0xd5,0xe6,0xe6,
    0xe3,0xe3,0xe3,0xe4,0xe4,0xe4,0xe4,0xd4,0xe5,0xe5,0xe5,0xf6,0xd5,0xe6,0xe6,0xf7,
    0xe3,0xe3,0xe3,0xe4,0xe4,0xe4,0xf5,0xf5,0xe5,0xe5,0xf6,0xf6,0xd5,0xe6,0xe6,0xf7,
    0xd6,0xd6,0xd6,0xd7,0xd7,0xd7,0xf5,0xc7,0xd8,0xd8,0xf6,0xc8,0xd9,0xd9,0xd9,0xf7,
    0xd6,0xd6,0xd6,0xd7,0xd7,0xe8,0xe8,0xd8,0xd8,0xd8,0xe9,0xe9,0xd9,0xd9,0xea,0xea,
    0xe7,0xe7,0xe7,0xd7,0xe8,0xe8,0xe8,0xd8,0xd8,0xe9,0xe9,0xe9,0xd9,0xea,0xea,0xea,
    0xe7,0xe7,0xe7,0xe8,0xe8,0xe8,0xf9,0xf9,0xe9,0xe9,0xe9,0xfa,0xd9,0xea,0xea,0xfb,
    0xf8,0xf8,0xf8,0xe8,0xf9,0xf9,0xf9,0xcb,0xe9,0xe9,0xfa,0xfa,0xcc,0xea,0xea,0xfb,
    0xda,0xda,0xda,0xdb,0xdb,0xdb,0xdb,0xdc,0xdc,0xdc,0xdc,0xcc,0xdd,0xdd,0xdd,0xee,
    0xda,0xda,0xda,0xdb,0xdb,0xec,0xec,0xdc,0xdc,0xed,0xed,0xed,0xdd,0xdd,0xee,0xee,
    0xeb,0xeb,0xeb,0xec,0xec,0xec,0xec,0xdc,0xed,0xed,0xed,0xed,0xdd,0xee,0xee,0xee,
    0xeb,0xeb,0xeb,0xec,0xec,0xfd,0xfd,0xfd,0xed,0xed,0xfe,0xfe,0xee,0xee,0xee,0xff,
    0xf0,0xf0,0xf0,0xe0,0xf1,0xf1,0xf1,0xf1,0xe1,0xf2,0xf2,0xf2,0xf2,0xe2,0xe2,0xf3,
    0xf0,0xf0,0xf0,0xe0,0xf1,0xf1,0xf1,0xf1,0xe1,0xf2,0xf2,0xf2,0xf2,0xe2,0xe2,0xf3,
    0xf0,0xf0,0xf0,0xe0,0xf1,0xf1,0xf1,0xf1,0xe1,0xf2,0xf2,0xf2,0xf2,0xe2,0xe2,0xf3,
    0xe3,0xe3,0xe3,0xe4,0xe4,0xe4,0xf5,0xf5,0xe5,0xe5,0xf6,0xf6,0xd5,0xe6,0xe6,0xf7,
    0xf4,0xf4,0xf4,0xe4,0xe4,0xf5,0xf5,0xf5,0xe5,0xe5,0xf6,0xf6,0xf6,0xe6,0xe6,0xf7,
    0xf4,0xf4,0xf4,0xe4,0xf5,0xf5,0xf5,0xf5,0xe5,0xf6,0xf6,0xf6,0xf6,0xe6,0xf7,0xf7,
    0xf4,0xf4,0xf4,0xf5,0xf5,0xf5,0xf5,0xf5,0xe5,0xf6,0xf6,0xf6,0xf6,0xe6,0xf7,0xf7,
    0xf4,0xf4,0xf4,0xf5,0xf5,0xf5,0xf5,0xf5,0xd8,0xf6,0xf6,0xf6,0xd9,0xd9,0xf7,0xf7,
    0xe7,0xe7,0xe7,0xe8,0xe8,0xe8,0xe8,0xd8,0xe9,0xe9,0xe9,0xfa,0xd9,0xea,0xea,0xea,
    0xf8,0xf8,0xf8,0xe8,0xe8,0xf9,0xf9,0xf9,0xe9,0xe9,0xfa,0xfa,0xfa,0xea,0xea,0xfb,
    0xf8,0xf8,0xf8,0xf9,0xf9,0xf9,0xf9,0xf9,0xe9,0xfa,0xfa,0xfa,0xfa,0xea,0xfb,0xfb,
    0xf8,0xf8,0xf8,0xf9,0xf9,0xf9,0xf9,0xf9,0xfa,0xfa,0xfa,0xfa,0xfa,0xea,0xfb,0xfb,
    0xf8,0xf8,0xf8,0xdb,0xf9,0xf9,0xf9,0xdc,0xdc,0xfa,0xfa,0xfa,0xdd,0xdd,0xee,0xfb,
    0xeb,0xeb,0xeb,0xec,0xec,0xec,0xec,0xdc,0xed,0xed,0xed,0xed,0xdd,0xee,0xee,0xee,
    0xeb,0xeb,0xeb,0xec,0xec,0xfd,0xfd,0xfd,0xed,0xed,0xfe,0xfe,0xee,0xee,0xee,0xff,
    0xfc,0xfc,0xfc,0xfd,0xfd,0xfd,0xfd,0xfd,0xed,0xfe,0xfe,0xfe,0xfe,0xee,0xff,0xff,
}
};
@

<<global memdefcmap>>=
Memcmap *memdefcmap = &def;
@

<<function _memmkcmap>>=
void _memmkcmap(void){}
@


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/cmap.c>>=
/*
 * generated by mkcmap.c
 */
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>

<<global def>>
<<global memdefcmap>>
<<function _memmkcmap>>
@


\subsection*{[[lib_graphics/libmemdraw/cread.c]]}

<<function creadmemimage>>=
Memimage*
creadmemimage(int fd)
{
    char hdr[5*12+1];
    Rectangle r;
    int m, nb, miny, maxy, new, ldepth, ncblock;
    uchar *buf;
    Memimage *i;
    ulong chan;

    if(readn(fd, hdr, 5*12) != 5*12){
        werrstr("readmemimage: short header (2)");
        return nil;
    }

    /*
     * distinguish new channel descriptor from old ldepth.
     * channel descriptors have letters as well as numbers,
     * while ldepths are a single digit formatted as %-11d.
     */
    new = 0;
    for(m=0; m<10; m++){
        if(hdr[m] != ' '){
            new = 1;
            break;
        }
    }
    if(hdr[11] != ' '){
        werrstr("creadimage: bad format");
        return nil;
    }
    if(new){
        hdr[11] = '\0';
        if((chan = strtochan(hdr)) == 0){
            werrstr("creadimage: bad channel string %s", hdr);
            return nil;
        }
    }else{
        ldepth = ((int)hdr[10])-'0';
        if(ldepth<0 || ldepth>3){
            werrstr("creadimage: bad ldepth %d", ldepth);
            return nil;
        }
        chan = drawld2chan[ldepth];
    }
    r.min.x=atoi(hdr+1*12);
    r.min.y=atoi(hdr+2*12);
    r.max.x=atoi(hdr+3*12);
    r.max.y=atoi(hdr+4*12);
    if(r.min.x>r.max.x || r.min.y>r.max.y){
        werrstr("creadimage: bad rectangle");
        return nil;
    }

    i = allocmemimage(r, chan);
    if(i == nil)
        return nil;
    ncblock = _compblocksize(r, i->depth);
    buf = malloc(ncblock);
    if(buf == nil)
        goto Errout;
    miny = r.min.y;
    while(miny != r.max.y){
        if(readn(fd, hdr, 2*12) != 2*12){
        Shortread:
            werrstr("readmemimage: short read");
        Errout:
            freememimage(i);
            free(buf);
            return nil;
        }
        maxy = atoi(hdr+0*12);
        nb = atoi(hdr+1*12);
        if(maxy<=miny || r.max.y<maxy){
            werrstr("readimage: bad maxy %d", maxy);
            goto Errout;
        }
        if(nb<=0 || ncblock<nb){
            werrstr("readimage: bad count %d", nb);
            goto Errout;
        }
        if(readn(fd, buf, nb)!=nb)
            goto Shortread;
        if(!new)	/* old image: flip the data bits */
            _twiddlecompressed(buf, nb);
        cloadmemimage(i, Rect(r.min.x, miny, r.max.x, maxy), buf, nb);
        miny = maxy;
    }
    free(buf);
    return i;
}
@


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/cread.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>

<<function creadmemimage>>
@


\subsection*{[[lib_graphics/libmemdraw/defont.c]]}

<<function getmemdefont>>=
Memsubfont*
getmemdefont(void)
{
    char *hdr, *p;
    int n;
    Fontchar *fc;
    Memsubfont *f;
    int ld;
    Rectangle r;
    Memdata *md;
    Memimage *i;

    /*
     * make sure data is word-aligned.  this is true with Plan 9 compilers
     * but not in general.  the byte order is right because the data is
     * declared as char*, not ulong*.
     */
    p = (char*)defontdata;
    n = (uintptr)p & 3;
    if(n != 0){
        memmove(p+(4-n), p, sizeofdefont-n);
        p += 4-n;
    }
    ld = atoi(p+0*12);
    r.min.x = atoi(p+1*12);
    r.min.y = atoi(p+2*12);
    r.max.x = atoi(p+3*12);
    r.max.y = atoi(p+4*12);

    md = mallocz(sizeof(Memdata), 1);
    if(md == nil)
        return nil;
    
    p += 5*12;

    md->base = nil;		/* so freememimage doesn't free p */
    md->bdata = (uchar*)p;	/* ick */
    md->ref = 1;
    md->allocd = 1;		/* so freememimage does free md */

    i = allocmemimaged(r, drawld2chan[ld], md);
    if(i == nil){
        free(md);
        return nil;
    }

    hdr = p+Dy(r)*i->width*sizeof(ulong);
    n = atoi(hdr);
    p = hdr+3*12;
    fc = malloc(sizeof(Fontchar)*(n+1));
    if(fc == 0){
        freememimage(i);
        return 0;
    }
    _unpackinfo(fc, (uchar*)p, n);
    f = allocmemsubfont("*default*", n, atoi(hdr+12), atoi(hdr+24), fc, i);
    if(f == 0){
        freememimage(i);
        free(fc);
        return 0;
    }
    return f;
}
@


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/defont.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>

<<function getmemdefont>>
@


\subsection*{[[lib_graphics/libmemdraw/draw.c]]}

<<global drawdebug>>=
int drawdebug;
@

<<global tablesbuilt>>=
static int	tablesbuilt;
@

<<function RGB2K>>=
/* perfect approximation to NTSC = .299r+.587g+.114b when 0 â‰¤ r,g,b < 256 */
#define RGB2K(r,g,b)	((156763*(r)+307758*(g)+59769*(b))>>19)
@

<<function DIV255>>=
/* #define DIV255(x) (((x)*257+256)>>16)  */
#define DIV255(x) ((((x)+1)*257)>>16)
@

<<function MUL>>=
/* #define DIV255(x) (tmp=(x)+1, (tmp+(tmp>>8))>>8) */

#define MUL(x, y, t)	(t = (x)*(y)+128, (t+(t>>8))>>8)
@

<<constant MASK13>>=
#define MASK13	0xFF00FF00
@

<<constant MASK02>>=
#define MASK02	0x00FF00FF
@

<<function MUL13>>=
#define MUL13(a, x, t)		(t = (a)*(((x)&MASK13)>>8)+128, ((t+((t>>8)&MASK02))>>8)&MASK02)
@

<<function MUL02>>=
#define MUL02(a, x, t)		(t = (a)*(((x)&MASK02)>>0)+128, ((t+((t>>8)&MASK02))>>8)&MASK02)
@

<<function MUL0123>>=
#define MUL0123(a, x, s, t)	((MUL13(a, x, s)<<8)|MUL02(a, x, t))
@

<<function MUL2>>=
#define MUL2(u, v, x, y)	(t = (u)*(v)+(x)*(y)+256, (t+(t>>8))>>8)
@

<<global memones>>=
static Memimage*	memones;
@

<<global memzeros>>=
static Memimage*	memzeros;
@

<<global memwhite>>=
Memimage *memwhite;
@

<<global memblack>>=
Memimage *memblack;
@

<<global memtransparent>>=
Memimage *memtransparent;
@

<<global memopaque>>=
Memimage *memopaque;
@

<<function memimageinit>>=
void
memimageinit(void)
{
    static int didinit = 0;

    if(didinit)
        return;

    didinit = 1;

    if(strcmp(imagmem->name, "Image") == 0 || strcmp(imagmem->name, "image") == 0)
        imagmem->move = memimagemove;

    mktables();
    _memmkcmap();

    fmtinstall('R', Rfmt); 
    fmtinstall('P', Pfmt);
    fmtinstall('b', _ifmt);

    memones = allocmemimage(Rect(0,0,1,1), GREY1);
    memones->flags |= Frepl;
    memones->clipr = Rect(-0x3FFFFFF, -0x3FFFFFF, 0x3FFFFFF, 0x3FFFFFF);
    *byteaddr(memones, ZP) = ~0;

    memzeros = allocmemimage(Rect(0,0,1,1), GREY1);
    memzeros->flags |= Frepl;
    memzeros->clipr = Rect(-0x3FFFFFF, -0x3FFFFFF, 0x3FFFFFF, 0x3FFFFFF);
    *byteaddr(memzeros, ZP) = 0;

    if(memones == nil || memzeros == nil)
        assert(0 /*cannot initialize memimage library */);	/* RSC BUG */

    memwhite = memones;
    memblack = memzeros;
    memopaque = memones;
    memtransparent = memzeros;
}
@

<<function memimagedraw>>=
//#define DBG if(0)

void
memimagedraw(Memimage *dst, Rectangle r, Memimage *src, Point p0, Memimage *mask, Point p1, int op)
{
    static int n = 0;
    Memdrawparam par;

    if(mask == nil)
        mask = memopaque;

    //DBG	print("memimagedraw %p/%luX %R @ %p %p/%luX %P %p/%luX %P... ", dst, dst->chan, r, dst->data->bdata, src, src->chan, p0, mask, mask->chan, p1);

    if(drawclip(dst, &r, src, &p0, mask, &p1, &par.sr, &par.mr) == 0){
//		if(drawdebug)
//			iprint("empty clipped rectangle\n");
        return;
    }

    if(op < Clear || op > SoverD){
//		if(drawdebug)
//			iprint("op out of range: %d\n", op);
        return;
    }

    par.op = op;
    par.dst = dst;
    par.r = r;
    par.src = src;
    /* par.sr set by drawclip */
    par.mask = mask;
    /* par.mr set by drawclip */

    par.state = 0;
    if(src->flags&Frepl){
        par.state |= Replsrc;
        if(Dx(src->r)==1 && Dy(src->r)==1){
            par.sval = pixelbits(src, src->r.min);
            par.state |= Simplesrc;
            par.srgba = imgtorgba(src, par.sval);
            par.sdval = rgbatoimg(dst, par.srgba);
            if((par.srgba&0xFF) == 0 && (op&DoutS)){
//				if (drawdebug) iprint("fill with transparent source\n");
                return;	/* no-op successfully handled */
            }
        }
    }

    if(mask->flags & Frepl){
        par.state |= Replmask;
        if(Dx(mask->r)==1 && Dy(mask->r)==1){
            par.mval = pixelbits(mask, mask->r.min);
            if(par.mval == 0 && (op&DoutS)){
//				if(drawdebug) iprint("fill with zero mask\n");
                return;	/* no-op successfully handled */
            }
            par.state |= Simplemask;
            if(par.mval == ~0)
                par.state |= Fullmask;
            par.mrgba = imgtorgba(mask, par.mval);
        }
    }

//	if(drawdebug)
//		iprint("dr %R sr %R mr %R...", r, par.sr, par.mr);
    //DBG print("draw dr %R sr %R mr %R %lux\n", r, par.sr, par.mr, par.state);

    /*
     * Now that we've clipped the parameters down to be consistent, we 
     * simply try sub-drawing routines in order until we find one that was able
     * to handle us.  If the sub-drawing routine returns zero, it means it was
     * unable to satisfy the request, so we do not return.
     */

    /*
     * Hardware support.  Each video driver provides this function,
     * which checks to see if there is anything it can help with.
     * There could be an if around this checking to see if dst is in video memory.
     */
    //DBG print("test hwdraw\n");
    if(hwdraw(&par)){
//if(drawdebug) iprint("hw handled\n");
      //DBG print("hwdraw handled\n");
        return;
    }
    /*
     * Optimizations using memmove and memset.
     */
    //DBG print("test memoptdraw\n");
    if(memoptdraw(&par)){
//if(drawdebug) iprint("memopt handled\n");
      //DBG print("memopt handled\n");
        return;
    }

    /*
     * Character drawing.
     * Solid source color being painted through a boolean mask onto a high res image.
     */
    //DBG print("test chardraw\n");
    if(chardraw(&par)){
//if(drawdebug) iprint("chardraw handled\n");
      //DBG print("chardraw handled\n");
        return;
    }

    /*
     * General calculation-laden case that does alpha for each pixel.
     */
    //DBG print("do alphadraw\n");
    alphadraw(&par);
//if(drawdebug) iprint("alphadraw handled\n");
    //DBG print("alphadraw handled\n");
}
@

<<function drawclip>>=
/*
 * Clip the destination rectangle further based on the properties of the 
 * source and mask rectangles.  Once the destination rectangle is properly
 * clipped, adjust the source and mask rectangles to be the same size.
 * Then if source or mask is replicated, move its clipped rectangle
 * so that its minimum point falls within the repl rectangle.
 *
 * Return zero if the final rectangle is null.
 */
int
drawclip(Memimage *dst, Rectangle *r, Memimage *src, Point *p0, Memimage *mask, Point *p1, Rectangle *sr, Rectangle *mr)
{
    Point rmin, delta;
    int splitcoords;
    Rectangle omr;

    if(r->min.x>=r->max.x || r->min.y>=r->max.y)
        return 0;
    splitcoords = (p0->x!=p1->x) || (p0->y!=p1->y);
    /* clip to destination */
    rmin = r->min;
    if(!rectclip(r, dst->r) || !rectclip(r, dst->clipr))
        return 0;
    /* move mask point */
    p1->x += r->min.x-rmin.x;
    p1->y += r->min.y-rmin.y;
    /* move source point */
    p0->x += r->min.x-rmin.x;
    p0->y += r->min.y-rmin.y;
    /* map destination rectangle into source */
    sr->min = *p0;
    sr->max.x = p0->x+Dx(*r);
    sr->max.y = p0->y+Dy(*r);
    /* sr is r in source coordinates; clip to source */
    if(!(src->flags&Frepl) && !rectclip(sr, src->r))
        return 0;
    if(!rectclip(sr, src->clipr))
        return 0;
    /* compute and clip rectangle in mask */
    if(splitcoords){
        /* move mask point with source */
        p1->x += sr->min.x-p0->x;
        p1->y += sr->min.y-p0->y;
        mr->min = *p1;
        mr->max.x = p1->x+Dx(*sr);
        mr->max.y = p1->y+Dy(*sr);
        omr = *mr;
        /* mr is now rectangle in mask; clip it */
        if(!(mask->flags&Frepl) && !rectclip(mr, mask->r))
            return 0;
        if(!rectclip(mr, mask->clipr))
            return 0;
        /* reflect any clips back to source */
        sr->min.x += mr->min.x-omr.min.x;
        sr->min.y += mr->min.y-omr.min.y;
        sr->max.x += mr->max.x-omr.max.x;
        sr->max.y += mr->max.y-omr.max.y;
        *p1 = mr->min;
    }else{
        if(!(mask->flags&Frepl) && !rectclip(sr, mask->r))
            return 0;
        if(!rectclip(sr, mask->clipr))
            return 0;
        *p1 = sr->min;
    }

    /* move source clipping back to destination */
    delta.x = r->min.x - p0->x;
    delta.y = r->min.y - p0->y;
    r->min.x = sr->min.x + delta.x;
    r->min.y = sr->min.y + delta.y;
    r->max.x = sr->max.x + delta.x;
    r->max.y = sr->max.y + delta.y;

    /* move source rectangle so sr->min is in src->r */
    if(src->flags&Frepl) {
        delta.x = drawreplxy(src->r.min.x, src->r.max.x, sr->min.x) - sr->min.x;
        delta.y = drawreplxy(src->r.min.y, src->r.max.y, sr->min.y) - sr->min.y;
        sr->min.x += delta.x;
        sr->min.y += delta.y;
        sr->max.x += delta.x;
        sr->max.y += delta.y;
    }
    *p0 = sr->min;

    /* move mask point so it is in mask->r */
    *p1 = drawrepl(mask->r, *p1);
    mr->min = *p1;
    mr->max.x = p1->x+Dx(*sr);
    mr->max.y = p1->y+Dy(*sr);

    assert(Dx(*sr) == Dx(*mr) && Dx(*mr) == Dx(*r));
    assert(Dy(*sr) == Dy(*mr) && Dy(*mr) == Dy(*r));
    assert(ptinrect(*p0, src->r));
    assert(ptinrect(*p1, mask->r));
    assert(ptinrect(r->min, dst->r));

    return 1;
}
@

<<global replbit>>=
/*
 * Conversion tables.
 */
static uchar replbit[1+8][256];		/* replbit[x][y] is the replication of the x-bit quantity y to 8-bit depth */
@

<<global conv18>>=
static uchar conv18[256][8];		/* conv18[x][y] is the yth pixel in the depth-1 pixel x */
@

<<global conv28>>=
static uchar conv28[256][4];		/* ... */
@

<<global conv48>>=
static uchar conv48[256][2];
@

<<function mktables>>=
static void
mktables(void)
{
    int i, j, mask, sh, small;
        
    if(tablesbuilt)
        return;

    fmtinstall('R', Rfmt);
    fmtinstall('P', Pfmt);
    tablesbuilt = 1;

    /* bit replication up to 8 bits */
    for(i=0; i<256; i++){
        for(j=0; j<=8; j++){	/* j <= 8 [sic] */
            small = i & ((1<<j)-1);
            replbit[j][i] = (small*replmul[j])>>8;
        }
    }

    /* bit unpacking up to 8 bits, only powers of 2 */
    for(i=0; i<256; i++){
        for(j=0, sh=7, mask=1; j<8; j++, sh--)
            conv18[i][j] = replbit[1][(i>>sh)&mask];

        for(j=0, sh=6, mask=3; j<4; j++, sh-=2)
            conv28[i][j] = replbit[2][(i>>sh)&mask];

        for(j=0, sh=4, mask=15; j<2; j++, sh-=4)
            conv48[i][j] = replbit[4][(i>>sh)&mask];
    }
}
@

<<global ones>>=
static uchar ones = 0xff;
@

<<struct Buffer>>=
struct Buffer {
    /* used by most routines */
    uchar	*red;
    uchar	*grn;
    uchar	*blu;
    uchar	*alpha;
    uchar	*grey;
    ulong	*rgba;
    int	delta;	/* number of bytes to add to pointer to get next pixel to the right */

    /* used by boolcalc* for mask data */
    uchar	*m;		/* ptr to mask data r.min byte; like p->bytermin */
    int		mskip;	/* no. of left bits to skip in *m */
    uchar	*bm;		/* ptr to mask data img->r.min byte; like p->bytey0s */
    int		bmskip;	/* no. of left bits to skip in *bm */
    uchar	*em;		/* ptr to mask data img->r.max.x byte; like p->bytey0e */
    int		emskip;	/* no. of right bits to skip in *em */
};
@

<<enum _anon_ (lib_graphics/libmemdraw/draw.c)>>=
enum {
    MAXBCACHE = 16
};
@

<<struct ParamDraw>>=
/* giant rathole to customize functions with */
struct ParamDraw {
    Readfn	*replcall;
    Readfn	*greymaskcall;	
    Readfn	*convreadcall;
    Writefn	*convwritecall;

    Memimage *img;
    Rectangle	r;
    int	dx;	/* of r */
    int	needbuf;
    int	convgrey;
    int	alphaonly;

    uchar	*bytey0s;		/* byteaddr(Pt(img->r.min.x, img->r.min.y)) */
    uchar	*bytermin;	/* byteaddr(Pt(r.min.x, img->r.min.y)) */
    uchar	*bytey0e;		/* byteaddr(Pt(img->r.max.x, img->r.min.y)) */
    int		bwidth;

    int	replcache;	/* if set, cache buffers */
    Buffer	bcache[MAXBCACHE];
    ulong	bfilled;
    uchar	*bufbase;
    int	bufoff;
    int	bufdelta;

    int	dir;

    int	convbufoff;
    uchar	*convbuf;
    Param	*convdpar;
    int	convdx;
};
@

<<global drawbuf>>=
static uchar *drawbuf;
@

<<global ndrawbuf>>=
static int	ndrawbuf;
@

<<global mdrawbuf>>=
static int	mdrawbuf;
@

<<global nullwrite>>=
static Writefn	nullwrite;
@

<<global alphacalc>>=
static Calcfn *alphacalc[Ncomp] = 
{
    alphacalc0,		/* Clear */
    alphacalc14,		/* DoutS */
    alphacalc2810,		/* SoutD */
    alphacalc3679,		/* DxorS */
    alphacalc14,		/* DinS */
    alphacalc5,		/* D */
    alphacalc3679,		/* DatopS */
    alphacalc3679,		/* DoverS */
    alphacalc2810,		/* SinD */
    alphacalc3679,		/* SatopD */
    alphacalc2810,		/* S */
    alphacalc11,		/* SoverD */
};
@

<<global boolcalc>>=
static Calcfn *boolcalc[Ncomp] =
{
    alphacalc0,		/* Clear */
    boolcalc14,		/* DoutS */
    boolcalc236789,		/* SoutD */
    boolcalc236789,		/* DxorS */
    boolcalc14,		/* DinS */
    alphacalc5,		/* D */
    boolcalc236789,		/* DatopS */
    boolcalc236789,		/* DoverS */
    boolcalc236789,		/* SinD */
    boolcalc236789,		/* SatopD */
    boolcalc1011,		/* S */
    boolcalc1011,		/* SoverD */
};
@

<<struct Dbuf>>=
struct Dbuf
{
    uchar *p;
    int n;
    Param spar, mpar, dpar;
    int inuse;
};
@

<<global dbuf>>=
static Dbuf dbuf[10];
@

<<function allocdbuf>>=
static Dbuf*
allocdbuf(void)
{
    int i;

    for(i=0; i<nelem(dbuf); i++){
        if(dbuf[i].inuse)
            continue;
        if(!_tas(&dbuf[i].inuse))
            return &dbuf[i];
    }
    return nil;
}
@

<<function getparam>>=
static void
getparam(Param *p, Memimage *img, Rectangle r, int convgrey, int needbuf, int *ndrawbuf)
{
    int nbuf;

    memset(p, 0, sizeof *p);

    p->img = img;
    p->r = r;
    p->dx = Dx(r);
    p->needbuf = needbuf;
    p->convgrey = convgrey;

    assert(img->r.min.x <= r.min.x && r.min.x < img->r.max.x);

    p->bytey0s = byteaddr(img, Pt(img->r.min.x, img->r.min.y));
    p->bytermin = byteaddr(img, Pt(r.min.x, img->r.min.y));
    p->bytey0e = byteaddr(img, Pt(img->r.max.x, img->r.min.y));
    p->bwidth = sizeof(ulong)*img->width;

    assert(p->bytey0s <= p->bytermin && p->bytermin <= p->bytey0e);

    if(p->r.min.x == p->img->r.min.x)
        assert(p->bytermin == p->bytey0s);

    nbuf = 1;
    if((img->flags&Frepl) && Dy(img->r) <= MAXBCACHE && Dy(img->r) < Dy(r)){
        p->replcache = 1;
        nbuf = Dy(img->r);
    }
    p->bufdelta = 4*p->dx;
    p->bufoff = *ndrawbuf;
    *ndrawbuf += p->bufdelta*nbuf;
}
@

<<function clipy>>=
static void
clipy(Memimage *img, int *y)
{
    int dy;

    dy = Dy(img->r);
    if(*y == dy)
        *y = 0;
    else if(*y == -1)
        *y = dy-1;
    assert(0 <= *y && *y < dy);
}
@

<<function dumpbuf>>=
static void
dumpbuf(char *s, Buffer b, int n)
{
    int i;
    uchar *p;
    
    print("%s", s);
    for(i=0; i<n; i++){
        print(" ");
        if(p=b.grey){
            print(" k%.2uX", *p);
            b.grey += b.delta;
        }else{	
            if(p=b.red){
                print(" r%.2uX", *p);
                b.red += b.delta;
            }
            if(p=b.grn){
                print(" g%.2uX", *p);
                b.grn += b.delta;
            }
            if(p=b.blu){
                print(" b%.2uX", *p);
                b.blu += b.delta;
            }
        }
        if((p=b.alpha) != &ones){
            print(" Î±%.2uX", *p);
            b.alpha += b.delta;
        }
    }
    print("\n");
}
@

<<function alphadraw>>=
/*
 * For each scan line, we expand the pixels from source, mask, and destination
 * into byte-aligned red, green, blue, alpha, and grey channels.  If buffering is not
 * needed and the channels were already byte-aligned (grey8, rgb24, rgba32, rgb32),
 * the readers need not copy the data: they can simply return pointers to the data.
 * If the destination image is grey and the source is not, it is converted using the NTSC
 * formula.
 *
 * Once we have all the channels, we call either rgbcalc or greycalc, depending on 
 * whether the destination image is color.  This is allowed to overwrite the dst buffer (perhaps
 * the actual data, perhaps a copy) with its result.  It should only overwrite the dst buffer
 * with the same format (i.e. red bytes with red bytes, etc.)  A new buffer is returned from
 * the calculator, and that buffer is passed to a function to write it to the destination.
 * If the buffer is already pointing at the destination, the writing function is a no-op.
 */
static int
alphadraw(Memdrawparam *par)
{
    int isgrey, starty, endy, op;
    int needbuf, dsty, srcy, masky;
    int y, dir, dx, dy, ndrawbuf;
    uchar *drawbuf;
    Buffer bsrc, bdst, bmask;
    Readfn *rdsrc, *rdmask, *rddst;
    Calcfn *calc;
    Writefn *wrdst;
    Memimage *src, *mask, *dst;
    Rectangle r, sr, mr;
    Dbuf *z;

    r = par->r;
    dx = Dx(r);
    dy = Dy(r);

    z = allocdbuf();
    if(z == nil)
        return 0;

    src = par->src;
    mask = par->mask;	
    dst = par->dst;
    sr = par->sr;
    mr = par->mr;
    op = par->op;

    isgrey = dst->flags&Fgrey;

    /*
     * Buffering when src and dst are the same bitmap is sufficient but not 
     * necessary.  There are stronger conditions we could use.  We could
     * check to see if the rectangles intersect, and if simply moving in the
     * correct y direction can avoid the need to buffer.
     */
    needbuf = (src->data == dst->data);

    ndrawbuf = 0;
    getparam(&z->spar, src, sr, isgrey, needbuf, &ndrawbuf);
    getparam(&z->dpar, dst, r, isgrey, needbuf, &ndrawbuf);
    getparam(&z->mpar, mask, mr, 0, needbuf, &ndrawbuf);

    dir = (needbuf && byteaddr(dst, r.min) > byteaddr(src, sr.min)) ? -1 : 1;
    z->spar.dir = z->mpar.dir = z->dpar.dir = dir;

    /*
     * If the mask is purely boolean, we can convert from src to dst format
     * when we read src, and then just copy it to dst where the mask tells us to.
     * This requires a boolean (1-bit grey) mask and lack of a source alpha channel.
     *
     * The computation is accomplished by assigning the function pointers as follows:
     *	rdsrc - read and convert source into dst format in a buffer
     * 	rdmask - convert mask to bytes, set pointer to it
     * 	rddst - fill with pointer to real dst data, but do no reads
     *	calc - copy src onto dst when mask says to.
     *	wrdst - do nothing
     * This is slightly sleazy, since things aren't doing exactly what their names say,
     * but it avoids a fair amount of code duplication to make this a case here
     * rather than have a separate booldraw.
     */
//if(drawdebug) iprint("flag %lud mchan %lux=?%x dd %d\n", src->flags&Falpha, mask->chan, GREY1, dst->depth);
    if(!(src->flags&Falpha) && mask->chan == GREY1 && dst->depth >= 8 && op == SoverD){
//if(drawdebug) iprint("boolcopy...");
        rdsrc = convfn(dst, &z->dpar, src, &z->spar, &ndrawbuf);
        rddst = readptr;
        rdmask = readfn(mask);
        calc = boolcopyfn(dst, mask);
        wrdst = nullwrite;
    }else{
        /* usual alphadraw parameter fetching */
        rdsrc = readfn(src);
        rddst = readfn(dst);
        wrdst = writefn(dst);
        calc = alphacalc[op];

        /*
         * If there is no alpha channel, we'll ask for a grey channel
         * and pretend it is the alpha.
         */
        if(mask->flags&Falpha){
            rdmask = readalphafn(mask);
            z->mpar.alphaonly = 1;
        }else{
            z->mpar.greymaskcall = readfn(mask);
            z->mpar.convgrey = 1;
            rdmask = greymaskread;

            /*
             * Should really be above, but then boolcopyfns would have
             * to deal with bit alignment, and I haven't written that.
             *
             * This is a common case for things like ellipse drawing.
             * When there's no alpha involved and the mask is boolean,
             * we can avoid all the division and multiplication.
             */
            if(mask->chan == GREY1 && !(src->flags&Falpha))
                calc = boolcalc[op];
            else if(op == SoverD && !(src->flags&Falpha))
                calc = alphacalcS;
        }
    }

    /*
     * If the image has a small enough repl rectangle,
     * we can just read each line once and cache them.
     */
    if(z->spar.replcache){
        z->spar.replcall = rdsrc;
        rdsrc = replread;
    }
    if(z->mpar.replcache){
        z->mpar.replcall = rdmask;
        rdmask = replread;
    }

    if(z->n < ndrawbuf){
        free(z->p);
        if((z->p = mallocz(ndrawbuf, 0)) == nil){
            z->inuse = 0;
            return 0;
        }
        z->n = ndrawbuf;
    }
    drawbuf = z->p;

    /*
     * Before we were saving only offsets from drawbuf in the parameter
     * structures; now that drawbuf has been grown to accomodate us,
     * we can fill in the pointers.
     */
    z->spar.bufbase = drawbuf+z->spar.bufoff;
    z->mpar.bufbase = drawbuf+z->mpar.bufoff;
    z->dpar.bufbase = drawbuf+z->dpar.bufoff;
    z->spar.convbuf = drawbuf+z->spar.convbufoff;

    if(dir == 1){
        starty = 0;
        endy = dy;
    }else{
        starty = dy-1;
        endy = -1;
    }

    /*
     * srcy, masky, and dsty are offsets from the top of their
     * respective Rectangles.  they need to be contained within
     * the rectangles, so clipy can keep them there without division.
   */
    srcy = (starty + sr.min.y - src->r.min.y)%Dy(src->r);
    masky = (starty + mr.min.y - mask->r.min.y)%Dy(mask->r);
    dsty = starty + r.min.y - dst->r.min.y;

    assert(0 <= srcy && srcy < Dy(src->r));
    assert(0 <= masky && masky < Dy(mask->r));
    assert(0 <= dsty && dsty < Dy(dst->r));

    for(y=starty; y!=endy; y+=dir, srcy+=dir, masky+=dir, dsty+=dir){
        clipy(src, &srcy);
        clipy(dst, &dsty);
        clipy(mask, &masky);

        bsrc = rdsrc(&z->spar, z->spar.bufbase, srcy);
        //DBG print("[");
        bmask = rdmask(&z->mpar, z->mpar.bufbase, masky);
        //DBG print("]\n");
        bdst = rddst(&z->dpar, z->dpar.bufbase, dsty);
        //DBG		dumpbuf("src", bsrc, dx);
        //DBG		dumpbuf("mask", bmask, dx);
        //DBG		dumpbuf("dst", bdst, dx);
        bdst = calc(bdst, bsrc, bmask, dx, isgrey, op);
        wrdst(&z->dpar, z->dpar.bytermin+dsty*z->dpar.bwidth, bdst);
    }

    z->inuse = 0;
    return 1;
}
@

<<function alphacalc0>>=
//#undef DBG

static Buffer
alphacalc0(Buffer bdst, Buffer b1, Buffer b2, int dx, int grey, int op)
{
    USED(grey);
    USED(op);
    USED(b1);
    USED(b2);
    memset(bdst.rgba, 0, dx*bdst.delta);
    return bdst;
}
@

<<function alphacalc14>>=
static Buffer
alphacalc14(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, int grey, int op)
{
    Buffer obdst;
    int fd, sadelta;
    int i, sa, ma, q;
    ulong s, t;

    obdst = bdst;
    sadelta = bsrc.alpha == &ones ? 0 : bsrc.delta;
    q = bsrc.delta == 4 && bdst.delta == 4;

    for(i=0; i<dx; i++){
        sa = *bsrc.alpha;
        ma = *bmask.alpha;
        fd = MUL(sa, ma, t);
        if(op == DoutS)
            fd = 255-fd;

        if(grey){
            *bdst.grey = MUL(fd, *bdst.grey, t);
            bsrc.grey += bsrc.delta;
            bdst.grey += bdst.delta;
        }else{
            if(q){
                *bdst.rgba = MUL0123(fd, *bdst.rgba, s, t);
                bsrc.rgba++;
                bdst.rgba++;
                bsrc.alpha += sadelta;
                bmask.alpha += bmask.delta;
                continue;
            }
            *bdst.red = MUL(fd, *bdst.red, t);
            *bdst.grn = MUL(fd, *bdst.grn, t);
            *bdst.blu = MUL(fd, *bdst.blu, t);
            bsrc.red += bsrc.delta;
            bsrc.blu += bsrc.delta;
            bsrc.grn += bsrc.delta;
            bdst.red += bdst.delta;
            bdst.blu += bdst.delta;
            bdst.grn += bdst.delta;
        }
        if(bdst.alpha != &ones){
            *bdst.alpha = MUL(fd, *bdst.alpha, t);
            bdst.alpha += bdst.delta;
        }
        bmask.alpha += bmask.delta;
        bsrc.alpha += sadelta;
    }
    return obdst;
}
@

<<function alphacalc2810>>=
static Buffer
alphacalc2810(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, int grey, int op)
{
    Buffer obdst;
    int fs, sadelta;
    int i, ma, da, q;
    ulong s, t;

    obdst = bdst;
    sadelta = bsrc.alpha == &ones ? 0 : bsrc.delta;
    q = bsrc.delta == 4 && bdst.delta == 4;

    for(i=0; i<dx; i++){
        ma = *bmask.alpha;
        da = *bdst.alpha;
        if(op == SoutD)
            da = 255-da;
        fs = ma;
        if(op != S)
            fs = MUL(fs, da, t);

        if(grey){
            *bdst.grey = MUL(fs, *bsrc.grey, t);
            bsrc.grey += bsrc.delta;
            bdst.grey += bdst.delta;
        }else{
            if(q){
                *bdst.rgba = MUL0123(fs, *bsrc.rgba, s, t);
                bsrc.rgba++;
                bdst.rgba++;
                bmask.alpha += bmask.delta;
                bdst.alpha += bdst.delta;
                continue;
            }
            *bdst.red = MUL(fs, *bsrc.red, t);
            *bdst.grn = MUL(fs, *bsrc.grn, t);
            *bdst.blu = MUL(fs, *bsrc.blu, t);
            bsrc.red += bsrc.delta;
            bsrc.blu += bsrc.delta;
            bsrc.grn += bsrc.delta;
            bdst.red += bdst.delta;
            bdst.blu += bdst.delta;
            bdst.grn += bdst.delta;
        }
        if(bdst.alpha != &ones){
            *bdst.alpha = MUL(fs, *bsrc.alpha, t);
            bdst.alpha += bdst.delta;
        }
        bmask.alpha += bmask.delta;
        bsrc.alpha += sadelta;
    }
    return obdst;
}
@

<<function alphacalc3679>>=
static Buffer
alphacalc3679(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, int grey, int op)
{
    Buffer obdst;
    int fs, fd, sadelta;
    int i, sa, ma, da, q;
    ulong s, t, u, v;

    obdst = bdst;
    sadelta = bsrc.alpha == &ones ? 0 : bsrc.delta;
    q = bsrc.delta == 4 && bdst.delta == 4;

    for(i=0; i<dx; i++){
        sa = *bsrc.alpha;
        ma = *bmask.alpha;
        da = *bdst.alpha;
        if(op == SatopD)
            fs = MUL(ma, da, t);
        else
            fs = MUL(ma, 255-da, t);
        if(op == DoverS)
            fd = 255;
        else{
            fd = MUL(sa, ma, t);
            if(op != DatopS)
                fd = 255-fd;
        }

        if(grey){
            *bdst.grey = MUL(fs, *bsrc.grey, s)+MUL(fd, *bdst.grey, t);
            bsrc.grey += bsrc.delta;
            bdst.grey += bdst.delta;
        }else{
            if(q){
                *bdst.rgba = MUL0123(fs, *bsrc.rgba, s, t)+MUL0123(fd, *bdst.rgba, u, v);
                bsrc.rgba++;
                bdst.rgba++;
                bsrc.alpha += sadelta;
                bmask.alpha += bmask.delta;
                bdst.alpha += bdst.delta;
                continue;
            }
            *bdst.red = MUL(fs, *bsrc.red, s)+MUL(fd, *bdst.red, t);
            *bdst.grn = MUL(fs, *bsrc.grn, s)+MUL(fd, *bdst.grn, t);
            *bdst.blu = MUL(fs, *bsrc.blu, s)+MUL(fd, *bdst.blu, t);
            bsrc.red += bsrc.delta;
            bsrc.blu += bsrc.delta;
            bsrc.grn += bsrc.delta;
            bdst.red += bdst.delta;
            bdst.blu += bdst.delta;
            bdst.grn += bdst.delta;
        }
        if(bdst.alpha != &ones){
            *bdst.alpha = MUL(fs, sa, s)+MUL(fd, da, t);
            bdst.alpha += bdst.delta;
        }
        bmask.alpha += bmask.delta;
        bsrc.alpha += sadelta;
    }
    return obdst;
}
@

<<function alphacalc5>>=
static Buffer
alphacalc5(Buffer bdst, Buffer b1, Buffer b2, int dx, int grey, int op)
{
    USED(dx);
    USED(grey);
    USED(op);
    USED(b1);
    USED(b2);
    return bdst;
}
@

<<function alphacalc11>>=
static Buffer
alphacalc11(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, int grey, int op)
{
    Buffer obdst;
    int fd, sadelta;
    int i, sa, ma, q;
    ulong s, t, u, v;

    USED(op);
    obdst = bdst;
    sadelta = bsrc.alpha == &ones ? 0 : bsrc.delta;
    q = bsrc.delta == 4 && bdst.delta == 4;

    for(i=0; i<dx; i++){
        sa = *bsrc.alpha;
        ma = *bmask.alpha;
        fd = 255-MUL(sa, ma, t);

        if(grey){
            *bdst.grey = MUL(ma, *bsrc.grey, s)+MUL(fd, *bdst.grey, t);
            bsrc.grey += bsrc.delta;
            bdst.grey += bdst.delta;
        }else{
            if(q){
                *bdst.rgba = MUL0123(ma, *bsrc.rgba, s, t)+MUL0123(fd, *bdst.rgba, u, v);
                bsrc.rgba++;
                bdst.rgba++;
                bsrc.alpha += sadelta;
                bmask.alpha += bmask.delta;
                continue;
            }
            *bdst.red = MUL(ma, *bsrc.red, s)+MUL(fd, *bdst.red, t);
            *bdst.grn = MUL(ma, *bsrc.grn, s)+MUL(fd, *bdst.grn, t);
            *bdst.blu = MUL(ma, *bsrc.blu, s)+MUL(fd, *bdst.blu, t);
            bsrc.red += bsrc.delta;
            bsrc.blu += bsrc.delta;
            bsrc.grn += bsrc.delta;
            bdst.red += bdst.delta;
            bdst.blu += bdst.delta;
            bdst.grn += bdst.delta;
        }
        if(bdst.alpha != &ones){
            *bdst.alpha = MUL(ma, sa, s)+MUL(fd, *bdst.alpha, t);
            bdst.alpha += bdst.delta;
        }
        bmask.alpha += bmask.delta;
        bsrc.alpha += sadelta;
    }
    return obdst;
}
@

<<function alphacalcS>>=
/* source alpha 1 */
static Buffer
alphacalcS(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, int grey, int op)
{
    Buffer obdst;
    int fd;
    int i, ma;
    ulong s, t;

    USED(op);
    obdst = bdst;

    for(i=0; i<dx; i++){
        ma = *bmask.alpha;
        fd = 255-ma;

        if(grey){
            *bdst.grey = MUL(ma, *bsrc.grey, s)+MUL(fd, *bdst.grey, t);
            bsrc.grey += bsrc.delta;
            bdst.grey += bdst.delta;
        }else{
            *bdst.red = MUL(ma, *bsrc.red, s)+MUL(fd, *bdst.red, t);
            *bdst.grn = MUL(ma, *bsrc.grn, s)+MUL(fd, *bdst.grn, t);
            *bdst.blu = MUL(ma, *bsrc.blu, s)+MUL(fd, *bdst.blu, t);
            bsrc.red += bsrc.delta;
            bsrc.blu += bsrc.delta;
            bsrc.grn += bsrc.delta;
            bdst.red += bdst.delta;
            bdst.blu += bdst.delta;
            bdst.grn += bdst.delta;
        }
        if(bdst.alpha != &ones){
            *bdst.alpha = ma+MUL(fd, *bdst.alpha, t);
            bdst.alpha += bdst.delta;
        }
        bmask.alpha += bmask.delta;
    }
    return obdst;
}
@

<<function boolcalc14>>=
static Buffer
boolcalc14(Buffer bdst, Buffer b1, Buffer bmask, int dx, int grey, int op)
{
    Buffer obdst;
    int i, ma, zero;

    USED(b1);

    obdst = bdst;

    for(i=0; i<dx; i++){
        ma = *bmask.alpha;
        zero = ma ? op == DoutS : op == DinS;

        if(grey){
            if(zero)
                *bdst.grey = 0;
            bdst.grey += bdst.delta;
        }else{
            if(zero)
                *bdst.red = *bdst.grn = *bdst.blu = 0;
            bdst.red += bdst.delta;
            bdst.blu += bdst.delta;
            bdst.grn += bdst.delta;
        }
        bmask.alpha += bmask.delta;
        if(bdst.alpha != &ones){
            if(zero)
                *bdst.alpha = 0;
            bdst.alpha += bdst.delta;
        }
    }
    return obdst;
}
@

<<function boolcalc236789>>=
static Buffer
boolcalc236789(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, int grey, int op)
{
    Buffer obdst;
    int fs, fd;
    int i, ma, da, zero;
    ulong s, t;

    obdst = bdst;
    zero = !(op&1);

    for(i=0; i<dx; i++){
        ma = *bmask.alpha;
        da = *bdst.alpha;
        fs = da;
        if(op&2)
            fs = 255-da;
        fd = 0;
        if(op&4)
            fd = 255;

        if(grey){
            if(ma)
                *bdst.grey = MUL(fs, *bsrc.grey, s)+MUL(fd, *bdst.grey, t);
            else if(zero)
                *bdst.grey = 0;
            bsrc.grey += bsrc.delta;
            bdst.grey += bdst.delta;
        }else{
            if(ma){
                *bdst.red = MUL(fs, *bsrc.red, s)+MUL(fd, *bdst.red, t);
                *bdst.grn = MUL(fs, *bsrc.grn, s)+MUL(fd, *bdst.grn, t);
                *bdst.blu = MUL(fs, *bsrc.blu, s)+MUL(fd, *bdst.blu, t);
            }
            else if(zero)
                *bdst.red = *bdst.grn = *bdst.blu = 0;
            bsrc.red += bsrc.delta;
            bsrc.blu += bsrc.delta;
            bsrc.grn += bsrc.delta;
            bdst.red += bdst.delta;
            bdst.blu += bdst.delta;
            bdst.grn += bdst.delta;
        }
        bmask.alpha += bmask.delta;
        if(bdst.alpha != &ones){
            if(ma)
                *bdst.alpha = fs+MUL(fd, da, t);
            else if(zero)
                *bdst.alpha = 0;
            bdst.alpha += bdst.delta;
        }
    }
    return obdst;
}
@

<<function boolcalc1011>>=
static Buffer
boolcalc1011(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, int grey, int op)
{
    Buffer obdst;
    int i, ma, zero;

    obdst = bdst;
    zero = !(op&1);

    for(i=0; i<dx; i++){
        ma = *bmask.alpha;

        if(grey){
            if(ma)
                *bdst.grey = *bsrc.grey;
            else if(zero)
                *bdst.grey = 0;
            bsrc.grey += bsrc.delta;
            bdst.grey += bdst.delta;
        }else{
            if(ma){
                *bdst.red = *bsrc.red;
                *bdst.grn = *bsrc.grn;
                *bdst.blu = *bsrc.blu;
            }
            else if(zero)
                *bdst.red = *bdst.grn = *bdst.blu = 0;
            bsrc.red += bsrc.delta;
            bsrc.blu += bsrc.delta;
            bsrc.grn += bsrc.delta;
            bdst.red += bdst.delta;
            bdst.blu += bdst.delta;
            bdst.grn += bdst.delta;
        }
        bmask.alpha += bmask.delta;
        if(bdst.alpha != &ones){
            if(ma)
                *bdst.alpha = 255;
            else if(zero)
                *bdst.alpha = 0;
            bdst.alpha += bdst.delta;
        }
    }
    return obdst;
}
@

<<function replread>>=
/*
 * Replicated cached scan line read.  Call the function listed in the Param,
 * but cache the result so that for replicated images we only do the work once.
 */
static Buffer
replread(Param *p, uchar *s, int y)
{
    Buffer *b;

    USED(s);
    b = &p->bcache[y];
    if((p->bfilled & (1<<y)) == 0){
        p->bfilled |= 1<<y;
        *b = p->replcall(p, p->bufbase+y*p->bufdelta, y);
    }
    return *b;
}
@

<<function greymaskread>>=
/*
 * Alpha reading function that simply relabels the grey pointer.
 */
static Buffer
greymaskread(Param *p, uchar *buf, int y)
{
    Buffer b;

    b = p->greymaskcall(p, buf, y);
    b.alpha = b.grey;
    return b;
}
@

<<function readnbit>>=
//#define DBG if(0)

static Buffer
readnbit(Param *p, uchar *buf, int y)
{
    Buffer b;
    Memimage *img;
    uchar *repl, *r, *w, *ow, bits;
    int i, n, sh, depth, x, dx, npack, nbits;

    b.rgba = (ulong*)buf;
    b.grey = w = buf;
    b.red = b.blu = b.grn = w;
    b.alpha = &ones;
    b.delta = 1;

    dx = p->dx;
    img = p->img;
    depth = img->depth;
    repl = &replbit[depth][0];
    npack = 8/depth;
    sh = 8-depth;

    /* copy from p->r.min.x until end of repl rectangle */
    x = p->r.min.x;
    n = dx;
    if(n > p->img->r.max.x - x)
        n = p->img->r.max.x - x;

    r = p->bytermin + y*p->bwidth;
    //DBG print("readnbit dx %d %p=%p+%d*%d, *r=%d fetch %d ", dx, r, p->bytermin, y, p->bwidth, *r, n);
    bits = *r++;
    nbits = 8;
    if(i=x&(npack-1)){
      //DBG print("throwaway %d...", i);
        bits <<= depth*i;
        nbits -= depth*i;
    }
    for(i=0; i<n; i++){
        if(nbits == 0){
          //DBG print("(%.2ux)...", *r);
            bits = *r++;
            nbits = 8;
        }
        *w++ = repl[bits>>sh];
        //DBG print("bit %x...", repl[bits>>sh]);
        bits <<= depth;
        nbits -= depth;
    }
    dx -= n;
    if(dx == 0)
        return b;

    assert(x+i == p->img->r.max.x);

    /* copy from beginning of repl rectangle until where we were before. */
    x = p->img->r.min.x;
    n = dx;
    if(n > p->r.min.x - x)
        n = p->r.min.x - x;

    r = p->bytey0s + y*p->bwidth;
    //DBG print("x=%d r=%p...", x, r);
    bits = *r++;
    nbits = 8;
    if(i=x&(npack-1)){
        bits <<= depth*i;
        nbits -= depth*i;
    }
    //DBG print("nbits=%d...", nbits);
    for(i=0; i<n; i++){
        if(nbits == 0){
            bits = *r++;
            nbits = 8;
        }
        *w++ = repl[bits>>sh];
        //DBG print("bit %x...", repl[bits>>sh]);
        bits <<= depth;
        nbits -= depth;
        //DBG print("bits %x nbits %d...", bits, nbits);
    }
    dx -= n;
    if(dx == 0)
        return b;

    assert(dx > 0);
    /* now we have exactly one full scan line: just replicate the buffer itself until we are done */
    ow = buf;
    while(dx--)
        *w++ = *ow++;

    return b;
}
@

<<function writenbit>>=
//#define DBG if(0)

static void
writenbit(Param *p, uchar *w, Buffer src)
{
    uchar *r;
    ulong bits;
    int i, sh, depth, npack, nbits, x, ex;

    assert(src.grey != nil && src.delta == 1);

    x = p->r.min.x;
    ex = x+p->dx;
    depth = p->img->depth;
    npack = 8/depth;

    i=x&(npack-1);
    bits = i ? (*w >> (8-depth*i)) : 0;
    nbits = depth*i;
    sh = 8-depth;
    r = src.grey;

    for(; x<ex; x++){
        bits <<= depth;
        //DBG print(" %x", *r);
        bits |= (*r++ >> sh);
        nbits += depth;
        if(nbits == 8){
            *w++ = bits;
            nbits = 0;
        }
    }

    if(nbits){
        sh = 8-nbits;
        bits <<= sh;
        bits |= *w & ((1<<sh)-1);
        *w = bits;
    }
    //DBG print("\n");
    return;
}
@

<<function readcmap>>=
//#undef DBG



static Buffer
readcmap(Param *p, uchar *buf, int y)
{
    Buffer b;
    int a, convgrey, copyalpha, dx, i, m;
    uchar *q, *cmap, *begin, *end, *r, *w;

    begin = p->bytey0s + y*p->bwidth;
    r = p->bytermin + y*p->bwidth;
    end = p->bytey0e + y*p->bwidth;
    cmap = p->img->cmap->cmap2rgb;
    convgrey = p->convgrey;
    copyalpha = (p->img->flags&Falpha) ? 1 : 0;

    w = buf;
    dx = p->dx;
    if(copyalpha){
        b.alpha = buf++;
        a = p->img->shift[CAlpha]/8;
        m = p->img->shift[CMap]/8;
        for(i=0; i<dx; i++){
            *w++ = r[a];
            q = cmap+r[m]*3;
            r += 2;
            if(r == end)
                r = begin;
            if(convgrey){
                *w++ = RGB2K(q[0], q[1], q[2]);
            }else{
                *w++ = q[2];	/* blue */
                *w++ = q[1];	/* green */
                *w++ = q[0];	/* red */
            }
        }
    }else{
        b.alpha = &ones;
        for(i=0; i<dx; i++){
            q = cmap+*r++*3;
            if(r == end)
                r = begin;
            if(convgrey){
                *w++ = RGB2K(q[0], q[1], q[2]);
            }else{
                *w++ = q[2];	/* blue */
                *w++ = q[1];	/* green */
                *w++ = q[0];	/* red */
            }
        }
    }

    b.rgba = (ulong*)(buf-copyalpha);

    if(convgrey){
        b.grey = buf;
        b.red = b.blu = b.grn = buf;
        b.delta = 1+copyalpha;
    }else{
        b.blu = buf;
        b.grn = buf+1;
        b.red = buf+2;
        b.grey = nil;
        b.delta = 3+copyalpha;
    }
    return b;
}
@

<<function writecmap>>=
static void
writecmap(Param *p, uchar *w, Buffer src)
{
    uchar *cmap, *red, *grn, *blu;
    int i, dx, delta;

    cmap = p->img->cmap->rgb2cmap;
    
    delta = src.delta;
    red= src.red;
    grn = src.grn;
    blu = src.blu;

    dx = p->dx;
    for(i=0; i<dx; i++, red+=delta, grn+=delta, blu+=delta)
        *w++ = cmap[(*red>>4)*256+(*grn>>4)*16+(*blu>>4)];
}
@

<<function readbyte>>=
//#define DBG if(0)

static Buffer
readbyte(Param *p, uchar *buf, int y)
{
    Buffer b;
    Memimage *img;
    int dx, isgrey, convgrey, alphaonly, copyalpha, i, nb;
    uchar *begin, *end, *r, *w, *rrepl, *grepl, *brepl, *arepl, *krepl;
    uchar ured, ugrn, ublu;
    ulong u;

    img = p->img;
    begin = p->bytey0s + y*p->bwidth;
    r = p->bytermin + y*p->bwidth;
    end = p->bytey0e + y*p->bwidth;

    w = buf;
    dx = p->dx;
    nb = img->depth/8;

    convgrey = p->convgrey;	/* convert rgb to grey */
    isgrey = img->flags&Fgrey;
    alphaonly = p->alphaonly;
    copyalpha = (img->flags&Falpha) ? 1 : 0;

    //DBG print("copyalpha %d alphaonly %d convgrey %d isgrey %d\n", copyalpha, alphaonly, convgrey, isgrey);
    /* if we can, avoid processing everything */
    if(!(img->flags&Frepl) && !convgrey && (img->flags&Fbytes)){
        memset(&b, 0, sizeof b);
        if(p->needbuf){
            memmove(buf, r, dx*nb);
            r = buf;
        }
        b.rgba = (ulong*)r;
        if(copyalpha)
            b.alpha = r+img->shift[CAlpha]/8;
        else
            b.alpha = &ones;
        if(isgrey){
            b.grey = r+img->shift[CGrey]/8;
            b.red = b.grn = b.blu = b.grey;
        }else{
            b.red = r+img->shift[CRed]/8;
            b.grn = r+img->shift[CGreen]/8;
            b.blu = r+img->shift[CBlue]/8;
        }
        b.delta = nb;
        return b;
    }

    //DBG print("2\n");
    rrepl = replbit[img->nbits[CRed]];
    grepl = replbit[img->nbits[CGreen]];
    brepl = replbit[img->nbits[CBlue]];
    arepl = replbit[img->nbits[CAlpha]];
    krepl = replbit[img->nbits[CGrey]];

    for(i=0; i<dx; i++){
        u = r[0] | (r[1]<<8) | (r[2]<<16) | (r[3]<<24);
        if(copyalpha) {
            *w++ = arepl[(u>>img->shift[CAlpha]) & img->mask[CAlpha]];
            //DBG print("a %x\n", w[-1]);
        }

        if(isgrey)
            *w++ = krepl[(u >> img->shift[CGrey]) & img->mask[CGrey]];
        else if(!alphaonly){
            ured = rrepl[(u >> img->shift[CRed]) & img->mask[CRed]];
            ugrn = grepl[(u >> img->shift[CGreen]) & img->mask[CGreen]];
            ublu = brepl[(u >> img->shift[CBlue]) & img->mask[CBlue]];
            if(convgrey){
              //DBG print("g %x %x %x\n", ured, ugrn, ublu);
                *w++ = RGB2K(ured, ugrn, ublu);
                //DBG print("%x\n", w[-1]);
            }else{
                *w++ = brepl[(u >> img->shift[CBlue]) & img->mask[CBlue]];
                *w++ = grepl[(u >> img->shift[CGreen]) & img->mask[CGreen]];
                *w++ = rrepl[(u >> img->shift[CRed]) & img->mask[CRed]];
            }
        }
        r += nb;
        if(r == end)
            r = begin;
    }
    
    b.alpha = copyalpha ? buf : &ones;
    b.rgba = (ulong*)buf;
    if(alphaonly){
        b.red = b.grn = b.blu = b.grey = nil;
        if(!copyalpha)
            b.rgba = nil;
        b.delta = 1;
    }else if(isgrey || convgrey){
        b.grey = buf+copyalpha;
        b.red = b.grn = b.blu = buf+copyalpha;
        b.delta = copyalpha+1;
        //DBG print("alpha %x grey %x\n", b.alpha ? *b.alpha : 0xFF, *b.grey);
    }else{
        b.blu = buf+copyalpha;
        b.grn = buf+copyalpha+1;
        b.grey = nil;
        b.red = buf+copyalpha+2;
        b.delta = copyalpha+3;
    }
    return b;
}
@

<<function writebyte>>=
//#define DBG if(0)

static void
writebyte(Param *p, uchar *w, Buffer src)
{
    Memimage *img;
    int i, isalpha, isgrey, nb, delta, dx, adelta;
    uchar ff, *red, *grn, *blu, *grey, *alpha;
    ulong u, mask;

    img = p->img;

    red = src.red;
    grn = src.grn;
    blu = src.blu;
    alpha = src.alpha;
    delta = src.delta;
    grey = src.grey;
    dx = p->dx;

    nb = img->depth/8;
    mask = (nb==4) ? 0 : ~((1<<img->depth)-1);

    isalpha = img->flags&Falpha;
    isgrey = img->flags&Fgrey;
    adelta = src.delta;

    if(isalpha && (alpha == nil || alpha == &ones)){
        ff = 0xFF;
        alpha = &ff;
        adelta = 0;
    }

    for(i=0; i<dx; i++){
        u = w[0] | (w[1]<<8) | (w[2]<<16) | (w[3]<<24);
        //DBG print("u %.8lux...", u);
        u &= mask;
        //DBG print("&mask %.8lux...", u);
        if(isgrey){
            u |= ((*grey >> (8-img->nbits[CGrey])) & img->mask[CGrey]) << img->shift[CGrey];
            //DBG print("|grey %.8lux...", u);
            grey += delta;
        }else{
            u |= ((*red >> (8-img->nbits[CRed])) & img->mask[CRed]) << img->shift[CRed];
            u |= ((*grn >> (8-img->nbits[CGreen])) & img->mask[CGreen]) << img->shift[CGreen];
            u |= ((*blu >> (8-img->nbits[CBlue])) & img->mask[CBlue]) << img->shift[CBlue];
            red += delta;
            grn += delta;
            blu += delta;
            //DBG print("|rgb %.8lux...", u);
        }

        if(isalpha){
            u |= ((*alpha >> (8-img->nbits[CAlpha])) & img->mask[CAlpha]) << img->shift[CAlpha];
            alpha += adelta;
            //DBG print("|alpha %.8lux...", u);
        }

        w[0] = u;
        w[1] = u>>8;
        w[2] = u>>16;
        w[3] = u>>24;
        w += nb;
    }
}
@

<<function readfn>>=
//#undef DBG

static Readfn*
readfn(Memimage *img)
{
    if(img->depth < 8)
        return readnbit;
    if(img->nbits[CMap] == 8)
        return readcmap;
    return readbyte;
}
@

<<function readalphafn>>=
static Readfn*
readalphafn(Memimage *m)
{
    USED(m);
    return readbyte;
}
@

<<function writefn>>=
static Writefn*
writefn(Memimage *img)
{
    if(img->depth < 8)
        return writenbit;
    if(img->chan == CMAP8)
        return writecmap;
    return writebyte;
}
@

<<function nullwrite>>=
static void
nullwrite(Param *p, uchar *s, Buffer b)
{
    USED(p);
    USED(s);
    USED(b);
}
@

<<function readptr>>=
static Buffer
readptr(Param *p, uchar *s, int y)
{
    Buffer b;
    uchar *q;

    USED(s);
    q = p->bytermin + y*p->bwidth;
    b.red = q;	/* ptr to data */
    b.grn = b.blu = b.grey = b.alpha = nil;
    b.rgba = (ulong*)q;
    b.delta = p->img->depth/8;
    return b;
}
@

<<function boolmemmove>>=
static Buffer
boolmemmove(Buffer bdst, Buffer bsrc, Buffer b1, int dx, int i, int o)
{
    USED(i);
    USED(o);
    USED(b1);
    USED(bsrc);
    memmove(bdst.red, bsrc.red, dx*bdst.delta);
    return bdst;
}
@

<<function boolcopy8>>=
static Buffer
boolcopy8(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, int i, int o)
{
    uchar *m, *r, *w, *ew;

    USED(i);
    USED(o);
    m = bmask.grey;
    w = bdst.red;
    r = bsrc.red;
    ew = w+dx;
    for(; w < ew; w++,r++)
        if(*m++)
            *w = *r;
    return bdst;	/* not used */
}
@

<<function boolcopy16>>=
static Buffer
boolcopy16(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, int i, int o)
{
    uchar *m;
    ushort *r, *w, *ew;

    USED(i);
    USED(o);
    m = bmask.grey;
    w = (ushort*)bdst.red;
    r = (ushort*)bsrc.red;
    ew = w+dx;
    for(; w < ew; w++,r++)
        if(*m++)
            *w = *r;
    return bdst;	/* not used */
}
@

<<function boolcopy24>>=
static Buffer
boolcopy24(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, int i, int o)
{
    uchar *m;
    uchar *r, *w, *ew;

    USED(i);
    USED(o);
    m = bmask.grey;
    w = bdst.red;
    r = bsrc.red;
    ew = w+dx*3;
    while(w < ew){
        if(*m++){
            *w++ = *r++;
            *w++ = *r++;
            *w++ = *r++;
        }else{
            w += 3;
            r += 3;
        }
    }
    return bdst;	/* not used */
}
@

<<function boolcopy32>>=
static Buffer
boolcopy32(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, int i, int o)
{
    uchar *m;
    ulong *r, *w, *ew;

    USED(i);
    USED(o);
    m = bmask.grey;
    w = (ulong*)bdst.red;
    r = (ulong*)bsrc.red;
    ew = w+dx;
    for(; w < ew; w++,r++)
        if(*m++)
            *w = *r;
    return bdst;	/* not used */
}
@

<<function genconv>>=
static Buffer
genconv(Param *p, uchar *buf, int y)
{
    Buffer b;
    int nb;
    uchar *r, *w, *ew;

    /* read from source into RGB format in convbuf */
    b = p->convreadcall(p, p->convbuf, y);

    /* write RGB format into dst format in buf */
    p->convwritecall(p->convdpar, buf, b);

    if(p->convdx){
        nb = p->convdpar->img->depth/8;
        r = buf;
        w = buf+nb*p->dx;
        ew = buf+nb*p->convdx;
        while(w<ew)
            *w++ = *r++;
    }

    b.red = buf;
    b.blu = b.grn = b.grey = b.alpha = nil;
    b.rgba = (ulong*)buf;
    b.delta = 0;
    
    return b;
}
@

<<function convfn>>=
static Readfn*
convfn(Memimage *dst, Param *dpar, Memimage *src, Param *spar, int *ndrawbuf)
{
    if(dst->chan == src->chan && !(src->flags&Frepl)){
//if(drawdebug) iprint("readptr...");
        return readptr;
    }

    if(dst->chan==CMAP8 && (src->chan==GREY1||src->chan==GREY2||src->chan==GREY4)){
        /* cheat because we know the replicated value is exactly the color map entry. */
//if(drawdebug) iprint("Readnbit...");
        return readnbit;
    }

    spar->convreadcall = readfn(src);
    spar->convwritecall = writefn(dst);
    spar->convdpar = dpar;

    /* allocate a conversion buffer */
    spar->convbufoff = *ndrawbuf;
    *ndrawbuf += spar->dx*4;

    if(spar->dx > Dx(spar->img->r)){
        spar->convdx = spar->dx;
        spar->dx = Dx(spar->img->r);
    }

//if(drawdebug) iprint("genconv...");
    return genconv;
}
@

<<function pixelbits>>=
static ulong
pixelbits(Memimage *i, Point pt)
{
    uchar *p;
    ulong val;
    int off, bpp, npack;

    val = 0;
    p = byteaddr(i, pt);
    switch(bpp=i->depth){
    case 1:
    case 2:
    case 4:
        npack = 8/bpp;
        off = pt.x%npack;
        val = p[0] >> bpp*(npack-1-off);
        val &= (1<<bpp)-1;
        break;
    case 8:
        val = p[0];
        break;
    case 16:
        val = p[0]|(p[1]<<8);
        break;
    case 24:
        val = p[0]|(p[1]<<8)|(p[2]<<16);
        break;
    case 32:
        val = p[0]|(p[1]<<8)|(p[2]<<16)|(p[3]<<24);
        break;
    }
    while(bpp<32){
        val |= val<<bpp;
        bpp *= 2;
    }
    return val;
}
@

<<function boolcopyfn>>=
static Calcfn*
boolcopyfn(Memimage *img, Memimage *mask)
{
    if(mask->flags&Frepl && Dx(mask->r)==1 && Dy(mask->r)==1 && pixelbits(mask, mask->r.min)==~0)
        return boolmemmove;

    switch(img->depth){
    case 8:
        return boolcopy8;
    case 16:
        return boolcopy16;
    case 24:
        return boolcopy24;
    case 32:
        return boolcopy32;
    default:
        assert(0 /* boolcopyfn */);
    }
    return nil;
}
@

<<function memsetb>>=
/*
 * Optimized draw for filling and scrolling; uses memset and memmove.
 */
static void
memsetb(void *vp, uchar val, int n)
{
    uchar *p, *ep;

    p = vp;
    ep = p+n;
    while(p<ep)
        *p++ = val;
}
@

<<function memsets>>=
static void
memsets(void *vp, ushort val, int n)
{
    ushort *p, *ep;

    p = vp;
    ep = p+n;
    while(p<ep)
        *p++ = val;
}
@

<<function memsetl>>=
static void
memsetl(void *vp, ulong val, int n)
{
    ulong *p, *ep;

    p = vp;
    ep = p+n;
    while(p<ep)
        *p++ = val;
}
@

<<function memset24>>=
static void
memset24(void *vp, ulong val, int n)
{
    uchar *p, *ep;
    uchar a,b,c;

    p = vp;
    ep = p+3*n;
    a = val;
    b = val>>8;
    c = val>>16;
    while(p<ep){
        *p++ = a;
        *p++ = b;
        *p++ = c;
    }
}
@

<<function imgtorgba>>=
static ulong
imgtorgba(Memimage *img, ulong val)
{
    uchar r, g, b, a;
    int nb, ov, v;
    ulong chan;
    uchar *p;

    a = 0xFF;
    r = g = b = 0xAA;	/* garbage */
    for(chan=img->chan; chan; chan>>=8){
        nb = NBITS(chan);
        ov = v = val&((1<<nb)-1);
        val >>= nb;

        while(nb < 8){
            v |= v<<nb;
            nb *= 2;
        }
        v >>= (nb-8);

        switch(TYPE(chan)){
        case CRed:
            r = v;
            break;
        case CGreen:
            g = v;
            break;
        case CBlue:
            b = v;
            break;
        case CAlpha:
            a = v;
            break;
        case CGrey:
            r = g = b = v;
            break;
        case CMap:
            p = img->cmap->cmap2rgb+3*ov;
            r = *p++;
            g = *p++;	
            b = *p;
            break;
        }
    }
    return (r<<24)|(g<<16)|(b<<8)|a;	
}
@

<<function rgbatoimg>>=
static ulong
rgbatoimg(Memimage *img, ulong rgba)
{
    ulong chan;
    int d, nb;
    ulong v;
    uchar *p, r, g, b, a, m;

    v = 0;
    r = rgba>>24;
    g = rgba>>16;
    b = rgba>>8;
    a = rgba;
    d = 0;
    for(chan=img->chan; chan; chan>>=8){
        nb = NBITS(chan);
        switch(TYPE(chan)){
        case CRed:
            v |= (r>>(8-nb))<<d;
            break;
        case CGreen:
            v |= (g>>(8-nb))<<d;
            break;
        case CBlue:
            v |= (b>>(8-nb))<<d;
            break;
        case CAlpha:
            v |= (a>>(8-nb))<<d;
            break;
        case CMap:
            p = img->cmap->rgb2cmap;
            m = p[(r>>4)*256+(g>>4)*16+(b>>4)];
            v |= (m>>(8-nb))<<d;
            break;
        case CGrey:
            m = RGB2K(r,g,b);
            v |= (m>>(8-nb))<<d;
            break;
        }
        d += nb;
    }
//	print("rgba2img %.8lux = %.*lux\n", rgba, 2*d/8, v);
    return v;
}
@

<<function memoptdraw>>=
//#define DBG if(0)

static int
memoptdraw(Memdrawparam *par)
{
    int m, y, dy, dx, op;
    ulong v;
    Memimage *src;
    Memimage *dst;

    dx = Dx(par->r);
    dy = Dy(par->r);
    src = par->src;
    dst = par->dst;
    op = par->op;

    //DBG print("state %lux mval %lux dd %d\n", par->state, par->mval, dst->depth);
    /*
     * If we have an opaque mask and source is one opaque pixel we can convert to the
     * destination format and just replicate with memset.
     */
    m = Simplesrc|Simplemask|Fullmask;
    if((par->state&m)==m && (par->srgba&0xFF) == 0xFF && (op ==S || op == SoverD)){
        uchar *dp, p[4];
        int d, dwid, ppb, np, nb;
        uchar lm, rm;

        //DBG print("memopt, dst %p, dst->data->bdata %p\n", dst, dst->data->bdata);
        dwid = dst->width*sizeof(ulong);
        dp = byteaddr(dst, par->r.min);
        v = par->sdval;
        //DBG print("sdval %lud, depth %d\n", v, dst->depth);
        switch(dst->depth){
        case 1:
        case 2:
        case 4:
            for(d=dst->depth; d<8; d*=2)
                v |= (v<<d);
            ppb = 8/dst->depth;	/* pixels per byte */
            m = ppb-1;
            /* left edge */
            np = par->r.min.x&m;		/* no. pixels unused on left side of word */
            dx -= (ppb-np);
            nb = 8 - np * dst->depth;		/* no. bits used on right side of word */
            lm = (1<<nb)-1;
            //DBG print("np %d x %d nb %d lm %ux ppb %d m %ux\n", np, par->r.min.x, nb, lm, ppb, m);	

            /* right edge */
            np = par->r.max.x&m;	/* no. pixels used on left side of word */
            dx -= np;
            nb = 8 - np * dst->depth;		/* no. bits unused on right side of word */
            rm = ~((1<<nb)-1);
            //DBG print("np %d x %d nb %d rm %ux ppb %d m %ux\n", np, par->r.max.x, nb, rm, ppb, m);	

            //DBG print("dx %d Dx %d\n", dx, Dx(par->r));
            /* lm, rm are masks that are 1 where we should touch the bits */
            if(dx < 0){	/* just one byte */
                lm &= rm;
                for(y=0; y<dy; y++, dp+=dwid)
                    *dp ^= (v ^ *dp) & lm;
            }else if(dx == 0){	/* no full bytes */
                if(lm)
                    dwid--;

                for(y=0; y<dy; y++, dp+=dwid){
                    if(lm){
                      //DBG print("dp %p v %lux lm %ux (v ^ *dp) & lm %lux\n", dp, v, lm, (v^*dp)&lm);
                        *dp ^= (v ^ *dp) & lm;
                        dp++;
                    }
                    *dp ^= (v ^ *dp) & rm;
                }
            }else{		/* full bytes in middle */
                dx /= ppb;
                if(lm)
                    dwid--;
                dwid -= dx;

                for(y=0; y<dy; y++, dp+=dwid){
                    if(lm){
                        *dp ^= (v ^ *dp) & lm;
                        dp++;
                    }
                    memset(dp, v, dx);
                    dp += dx;
                    *dp ^= (v ^ *dp) & rm;
                }
            }
            return 1;
        case 8:
            for(y=0; y<dy; y++, dp+=dwid)
                memset(dp, v, dx);
            return 1;
        case 16:
            p[0] = v;		/* make little endian */
            p[1] = v>>8;
            v = *(ushort*)p;
            //DBG print("dp=%p; dx=%d; for(y=0; y<%d; y++, dp+=%d)\nmemsets(dp, v, dx);\n",
            //	dp, dx, dy, dwid);
            for(y=0; y<dy; y++, dp+=dwid)
                memsets(dp, v, dx);
            return 1;
        case 24:
            for(y=0; y<dy; y++, dp+=dwid)
                memset24(dp, v, dx);
            return 1;
        case 32:
            p[0] = v;		/* make little endian */
            p[1] = v>>8;
            p[2] = v>>16;
            p[3] = v>>24;
            v = *(ulong*)p;
            for(y=0; y<dy; y++, dp+=dwid)
                memsetl(dp, v, dx);
            return 1;
        default:
            assert(0 /* bad dest depth in memoptdraw */);
        }
    }

    /*
     * If no source alpha, an opaque mask, we can just copy the
     * source onto the destination.  If the channels are the same and
     * the source is not replicated, memmove suffices.
     */
    m = Simplemask|Fullmask;
    if((par->state&(m|Replsrc))==m && src->depth >= 8 
    && src->chan == dst->chan && !(src->flags&Falpha) && (op == S || op == SoverD)){
        uchar *sp, *dp;
        long swid, dwid, nb;
        int dir;

        if(src->data == dst->data && byteaddr(dst, par->r.min) > byteaddr(src, par->sr.min))
            dir = -1;
        else
            dir = 1;

        swid = src->width*sizeof(ulong);
        dwid = dst->width*sizeof(ulong);
        sp = byteaddr(src, par->sr.min);
        dp = byteaddr(dst, par->r.min);
        if(dir == -1){
            sp += (dy-1)*swid;
            dp += (dy-1)*dwid;
            swid = -swid;
            dwid = -dwid;
        }
        nb = (dx*src->depth)/8;
        for(y=0; y<dy; y++, sp+=swid, dp+=dwid)
            memmove(dp, sp, nb);
        return 1;
    }

    /*
     * If we have a 1-bit mask, 1-bit source, and 1-bit destination, and
     * they're all bit aligned, we can just use bit operators.  This happens
     * when we're manipulating boolean masks, e.g. in the arc code.
     */
    if((par->state&(Simplemask|Simplesrc|Replmask|Replsrc))==0 
    && dst->chan==GREY1 && src->chan==GREY1 && par->mask->chan==GREY1 
    && (par->r.min.x&7)==(par->sr.min.x&7) && (par->r.min.x&7)==(par->mr.min.x&7)){
        uchar *sp, *dp, *mp;
        uchar lm, rm;
        long swid, dwid, mwid;
        int i, x, dir;

        sp = byteaddr(src, par->sr.min);
        dp = byteaddr(dst, par->r.min);
        mp = byteaddr(par->mask, par->mr.min);
        swid = src->width*sizeof(ulong);
        dwid = dst->width*sizeof(ulong);
        mwid = par->mask->width*sizeof(ulong);

        if(src->data == dst->data && byteaddr(dst, par->r.min) > byteaddr(src, par->sr.min)){
            dir = -1;
        }else
            dir = 1;

        lm = 0xFF>>(par->r.min.x&7);
        rm = 0xFF<<(8-(par->r.max.x&7));
        dx -= (8-(par->r.min.x&7)) + (par->r.max.x&7);

        if(dx < 0){	/* one byte wide */
            lm &= rm;
            if(dir == -1){
                dp += dwid*(dy-1);
                sp += swid*(dy-1);
                mp += mwid*(dy-1);
                dwid = -dwid;
                swid = -swid;
                mwid = -mwid;
            }
            for(y=0; y<dy; y++){
                *dp ^= (*dp ^ *sp) & *mp & lm;
                dp += dwid;
                sp += swid;
                mp += mwid;
            }
            return 1;
        }

        dx /= 8;
        if(dir == 1){
            i = (lm!=0)+dx+(rm!=0);
            mwid -= i;
            swid -= i;
            dwid -= i;
            for(y=0; y<dy; y++, dp+=dwid, sp+=swid, mp+=mwid){
                if(lm){
                    *dp ^= (*dp ^ *sp++) & *mp++ & lm;
                    dp++;
                }
                for(x=0; x<dx; x++){
                    *dp ^= (*dp ^ *sp++) & *mp++;
                    dp++;
                }
                if(rm){
                    *dp ^= (*dp ^ *sp++) & *mp++ & rm;
                    dp++;
                }
            }
            return 1;
        }else{
        /* dir == -1 */
            i = (lm!=0)+dx+(rm!=0);
            dp += dwid*(dy-1)+i-1;
            sp += swid*(dy-1)+i-1;
            mp += mwid*(dy-1)+i-1;
            dwid = -dwid+i;
            swid = -swid+i;
            mwid = -mwid+i;
            for(y=0; y<dy; y++, dp+=dwid, sp+=swid, mp+=mwid){
                if(rm){
                    *dp ^= (*dp ^ *sp--) & *mp-- & rm;
                    dp--;
                }
                for(x=0; x<dx; x++){
                    *dp ^= (*dp ^ *sp--) & *mp--;
                    dp--;
                }
                if(lm){
                    *dp ^= (*dp ^ *sp--) & *mp-- & lm;
                    dp--;
                }
            }
        }
        return 1;
    }
    return 0;	
}
@

<<function chardraw>>=
/*
 * Boolean character drawing.
 * Solid opaque color through a 1-bit greyscale mask.
 */
static int
chardraw(Memdrawparam *par)
{
    ulong bits;
    int i, ddepth, dy, dx, x, bx, ex, y, npack, bsh, depth, op;
    ulong v, maskwid, dstwid;
    uchar *wp, *rp, *q, *wc;
    ushort *ws;
    ulong *wl;
    uchar sp[4];
    Rectangle r, mr;
    Memimage *mask, *src, *dst;

if(0) if(drawdebug) iprint("chardraw? mf %lux md %d sf %lux dxs %d dys %d dd %d ddat %p sdat %p\n",
        par->mask->flags, par->mask->depth, par->src->flags, 
        Dx(par->src->r), Dy(par->src->r), par->dst->depth, par->dst->data, par->src->data);

    mask = par->mask;
    src = par->src;
    dst = par->dst;
    r = par->r;
    mr = par->mr;
    op = par->op;

    if((par->state&(Replsrc|Simplesrc|Replmask)) != (Replsrc|Simplesrc)
    || mask->depth != 1 || src->flags&Falpha || dst->depth<8 || dst->data==src->data
    || op != SoverD)
        return 0;

//if(drawdebug) iprint("chardraw...");

    depth = mask->depth;
    maskwid = mask->width*sizeof(ulong);
    rp = byteaddr(mask, mr.min);
    npack = 8/depth;
    bsh = (mr.min.x % npack) * depth;

    wp = byteaddr(dst, r.min);
    dstwid = dst->width*sizeof(ulong);
    //DBG print("bsh %d\n", bsh);
    dy = Dy(r);
    dx = Dx(r);

    ddepth = dst->depth;

    /*
     * for loop counts from bsh to bsh+dx
     *
     * we want the bottom bits to be the amount
     * to shift the pixels down, so for nâ‰¡0 (mod 8) we want 
     * bottom bits 7.  for nâ‰¡1, 6, etc.
     * the bits come from -n-1.
     */

    bx = -bsh-1;
    ex = -bsh-1-dx;
    SET(bits);
    v = par->sdval;

    /* make little endian */
    sp[0] = v;
    sp[1] = v>>8;
    sp[2] = v>>16;
    sp[3] = v>>24;

//print("sp %x %x %x %x\n", sp[0], sp[1], sp[2], sp[3]);
    for(y=0; y<dy; y++, rp+=maskwid, wp+=dstwid){
        q = rp;
        if(bsh)
            bits = *q++;
        switch(ddepth){
        case 8:
//if(drawdebug) iprint("8loop...");
            wc = wp;
            for(x=bx; x>ex; x--, wc++){
                i = x&7;
                if(i == 8-1)
                    bits = *q++;
                //DBG print("bits %lux sh %d...", bits, i);
                if((bits>>i)&1)
                    *wc = v;
            }
            break;
        case 16:
            ws = (ushort*)wp;
            v = *(ushort*)sp;
            for(x=bx; x>ex; x--, ws++){
                i = x&7;
                if(i == 8-1)
                    bits = *q++;
                //DBG print("bits %lux sh %d...", bits, i);
                if((bits>>i)&1)
                    *ws = v;
            }
            break;
        case 24:
            wc = wp;
            for(x=bx; x>ex; x--, wc+=3){
                i = x&7;
                if(i == 8-1)
                    bits = *q++;
                //DBG print("bits %lux sh %d...", bits, i);
                if((bits>>i)&1){
                    wc[0] = sp[0];
                    wc[1] = sp[1];
                    wc[2] = sp[2];
                }
            }
            break;
        case 32:
            wl = (ulong*)wp;
            v = *(ulong*)sp;
            for(x=bx; x>ex; x--, wl++){
                i = x&7;
                if(i == 8-1)
                    bits = *q++;
                //DBG iprint("bits %lux sh %d...", bits, i);
                if((bits>>i)&1)
                    *wl = v;
            }
            break;
        }
    }

    //DBG print("\n");	
    return 1;	
}
@

<<function memfillcolor>>=
/*
 * Fill entire byte with replicated (if necessary) copy of source pixel,
 * assuming destination ldepth is >= source ldepth.
 *
 * This code is just plain wrong for >8bpp.
 *
ulong
membyteval(Memimage *src)
{
    int i, val, bpp;
    uchar uc;

    unloadmemimage(src, src->r, &uc, 1);
    bpp = src->depth;
    uc <<= (src->r.min.x&(7/src->depth))*src->depth;
    uc &= ~(0xFF>>bpp);
    /* pixel value is now in high part of byte. repeat throughout byte 
    val = uc;
    for(i=bpp; i<8; i<<=1)
        val |= val>>i;
    return val;
}
 * 
 */

void
memfillcolor(Memimage *i, ulong val)
{
    ulong bits;
    int d, y;

    if(val == DNofill)
        return;

    bits = rgbatoimg(i, val);
    switch(i->depth){
    case 24:	/* 24-bit images suck */
        for(y=i->r.min.y; y<i->r.max.y; y++)
            memset24(byteaddr(i, Pt(i->r.min.x, y)), bits, Dx(i->r));
        break;
    default:	/* 1, 2, 4, 8, 16, 32 */
        for(d=i->depth; d<32; d*=2)
            bits = (bits << d) | bits;
        memsetl(wordaddr(i, i->r.min), bits, i->width*Dy(i->r));
        break;
    }
}
@


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/draw.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <pool.h>

extern Pool* imagmem;
<<global drawdebug>>
<<global tablesbuilt>>

<<function RGB2K>>

/*
 * for 0 â‰¤ x â‰¤ 255*255, (x*0x0101+0x100)>>16 is a perfect approximation.
 * for 0 â‰¤ x < (1<<16), x/255 = ((x+1)*0x0101)>>16 is a perfect approximation.
 * the last one is perfect for all up to 1<<16, avoids a multiply, but requires a rathole.
 */
<<function DIV255>>
<<function MUL>>
<<constant MASK13>>
<<constant MASK02>>
<<function MUL13>>
<<function MUL02>>
<<function MUL0123>>

<<function MUL2>>

static void mktables(void);
typedef int Subdraw(Memdrawparam*);
static Subdraw chardraw, alphadraw, memoptdraw;

<<global memones>>
<<global memzeros>>
<<global memwhite>>
<<global memblack>>
<<global memtransparent>>
<<global memopaque>>

int	_ifmt(Fmt*);

<<function memimageinit>>

static ulong imgtorgba(Memimage*, ulong);
static ulong rgbatoimg(Memimage*, ulong);
static ulong pixelbits(Memimage*, Point);

<<function memimagedraw>>
//#undef DBG

<<function drawclip>>

<<global replbit>>
<<global conv18>>
<<global conv28>>
<<global conv48>>

extern int replmul[];

<<function mktables>>

<<global ones>>

/*
 * General alpha drawing case.  Can handle anything.
 */
typedef struct	Buffer	Buffer;
<<struct Buffer>>

typedef struct	ParamDraw	Param;
typedef Buffer	Readfn(Param*, uchar*, int);
typedef void	Writefn(Param*, uchar*, Buffer);
typedef Buffer	Calcfn(Buffer, Buffer, Buffer, int, int, int);

<<enum _anon_ (lib_graphics/libmemdraw/draw.c)>>

<<struct ParamDraw>>

<<global drawbuf>>
<<global ndrawbuf>>
<<global mdrawbuf>>
static Readfn	greymaskread, replread, readptr;
<<global nullwrite>>
static Calcfn	alphacalc0, alphacalc14, alphacalc2810, alphacalc3679, alphacalc5, alphacalc11, alphacalcS;
static Calcfn	boolcalc14, boolcalc236789, boolcalc1011;

static Readfn*	readfn(Memimage*);
static Readfn*	readalphafn(Memimage*);
static Writefn*	writefn(Memimage*);

static Calcfn*	boolcopyfn(Memimage*, Memimage*);
static Readfn*	convfn(Memimage*, Param*, Memimage*, Param*, int*);
static Readfn*	ptrfn(Memimage*);

<<global alphacalc>>

<<global boolcalc>>

/*
 * Avoid standard Lock, QLock so that can be used in kernel.
 */
typedef struct Dbuf Dbuf;
<<struct Dbuf>>
<<global dbuf>>

<<function allocdbuf>>

<<function getparam>>

<<function clipy>>

<<function dumpbuf>>

//#define DBG if(0)


<<function alphadraw>>

<<function alphacalc0>>

<<function alphacalc14>>

<<function alphacalc2810>>

<<function alphacalc3679>>

<<function alphacalc5>>

<<function alphacalc11>>

/*
not used yet
source and mask alpha 1
static Buffer
alphacalcS0(Buffer bdst, Buffer bsrc, Buffer bmask, int dx, int grey, int op)
{
    Buffer obdst;
    int i;

    USED(op);
    obdst = bdst;
    if(bsrc.delta == bdst.delta){
        memmove(bdst.rgba, bsrc.rgba, dx*bdst.delta);
        return obdst;
    }
    for(i=0; i<dx; i++){
        if(grey){
            *bdst.grey = *bsrc.grey;
            bsrc.grey += bsrc.delta;
            bdst.grey += bdst.delta;
        }else{
            *bdst.red = *bsrc.red;
            *bdst.grn = *bsrc.grn;
            *bdst.blu = *bsrc.blu;
            bsrc.red += bsrc.delta;
            bsrc.blu += bsrc.delta;
            bsrc.grn += bsrc.delta;
            bdst.red += bdst.delta;
            bdst.blu += bdst.delta;
            bdst.grn += bdst.delta;
        }
        if(bdst.alpha != &ones){
            *bdst.alpha = 255;
            bdst.alpha += bdst.delta;
        }
    }
    return obdst;
}
*/

<<function alphacalcS>>

<<function boolcalc14>>

<<function boolcalc236789>>

<<function boolcalc1011>>
<<function replread>>

<<function greymaskread>>

<<function readnbit>>

//#undef DBG
<<function writenbit>>

<<function readcmap>>

<<function writecmap>>

<<function readbyte>>

//#undef DBG
<<function writebyte>>

<<function readfn>>

<<function readalphafn>>

<<function writefn>>

<<function nullwrite>>

<<function readptr>>

<<function boolmemmove>>

<<function boolcopy8>>

<<function boolcopy16>>

<<function boolcopy24>>

<<function boolcopy32>>

<<function genconv>>

<<function convfn>>

<<function pixelbits>>

<<function boolcopyfn>>

<<function memsetb>>

<<function memsets>>

<<function memsetl>>

<<function memset24>>

<<function imgtorgba>>

<<function rgbatoimg>>

<<function memoptdraw>>

//#undef DBG
//#define DBG if(0)

<<function chardraw>>

//#undef DBG


<<function memfillcolor>>

@


\subsection*{[[lib_graphics/libmemdraw/ellipse.c]]}

<<struct ParamEllipse>>=
struct ParamEllipse {
    Memimage	*dst;
    Memimage	*src;
    Point			c;
    int			t;
    Point			sp;
    Memimage	*disc;
    int			op;
};
@

<<struct State>>=
/*
 * denote residual error by e(x,y) = b^2*x^2 + a^2*y^2 - a^2*b^2
 * e(x,y) = 0 on ellipse, e(x,y) < 0 inside, e(x,y) > 0 outside
 */

struct State {
    int	a;
    int	x;
    vlong	a2;	/* a^2 */
    vlong	b2;	/* b^2 */
    vlong	b2x;	/* b^2 * x */
    vlong	a2y;	/* a^2 * y */
    vlong	c1;
    vlong	c2;	/* test criteria */
    vlong	ee;	/* ee = e(x+1/2,y-1/2) - (a^2+b^2)/4 */
    vlong	dxe;
    vlong	dye;
    vlong	d2xe;
    vlong	d2ye;
};
@

<<function newstate>>=
static
State*
newstate(State *s, int a, int b)
{
    s->x = 0;
    s->a = a;
    s->a2 = (vlong)(a*a);
    s->b2 = (vlong)(b*b);
    s->b2x = (vlong)0;
    s->a2y = s->a2*(vlong)b;
    s->c1 = -((s->a2>>2) + (vlong)(a&1) + s->b2);
    s->c2 = -((s->b2>>2) + (vlong)(b&1));
    s->ee = -s->a2y;
    s->dxe = (vlong)0;
    s->dye = s->ee<<1;
    s->d2xe = s->b2<<1;
    s->d2ye = s->a2<<1;
    return s;
}
@

<<function step>>=
/*
 * return x coord of rightmost pixel on next scan line
 */
static
int
step(State *s)
{
    while(s->x < s->a) {
        if(s->ee+s->b2x <= s->c1 ||	/* e(x+1,y-1/2) <= 0 */
           s->ee+s->a2y <= s->c2) {	/* e(x+1/2,y) <= 0 (rare) */
            s->dxe += s->d2xe;	  
            s->ee += s->dxe;	  
            s->b2x += s->b2;
            s->x++;	  
            continue;
        }
        s->dye += s->d2ye;	  
        s->ee += s->dye;	  
        s->a2y -= s->a2;
        if(s->ee-s->a2y <= s->c2) {	/* e(x+1/2,y-1) <= 0 */
            s->dxe += s->d2xe;	  
            s->ee += s->dxe;	  
            s->b2x += s->b2;
            return s->x++;
        }
        break;
    }
    return s->x;	  
}
@

<<function memellipse>>=
void
memellipse(Memimage *dst, Point c, int a, int b, int t, Memimage *src, Point sp, int op)
{
    State in, out;
    int y, inb, inx, outx, u;
    Param p;

    if(a < 0)
        a = -a;
    if(b < 0)
        b = -b;
    p.dst = dst;
    p.src = src;
    p.c = c;
    p.t = t;
    p.sp = subpt(sp, c);
    p.disc = nil;
    p.op = op;

    u = (t<<1)*(a-b);
    if(b<a && u>b*b || a<b && -u>a*a) {
/*	if(b<a&&(t<<1)>b*b/a || a<b&&(t<<1)>a*a/b)	# very thick */
        bellipse(b, newstate(&in, a, b), &p);
        return;
    }

    if(t < 0) {
        inb = -1;
        newstate(&out, a, y = b);
    } else {	
        inb = b - t;
        newstate(&out, a+t, y = b+t);
    }
    if(t > 0)
        newstate(&in, a-t, inb);
    inx = 0;
    for( ; y>=0; y--) {
        outx = step(&out);
        if(y > inb) {
            erect(-outx, y, outx, y, &p);
            if(y != 0)
                erect(-outx, -y, outx, -y, &p);
            continue;
        }
        if(t > 0) {
            inx = step(&in);
            if(y == inb)
                inx = 0;
        } else if(inx > outx)
            inx = outx;
        erect(inx, y, outx, y, &p);
        if(y != 0)
            erect(inx, -y, outx, -y, &p);
        erect(-outx, y, -inx, y, &p);
        if(y != 0)
            erect(-outx, -y, -inx, -y, &p);
        inx = outx + 1;
    }
}
@

<<global p00 (lib_graphics/libmemdraw/ellipse.c)>>=
static Point p00 = {0, 0};
@

<<function bellipse>>=
/*
 * a brushed ellipse
 */
static
void
bellipse(int y, State *s, Param *p)
{
    int t, ox, oy, x, nx;

    t = p->t;
    p->disc = allocmemimage(Rect(-t,-t,t+1,t+1), GREY1);
    if(p->disc == nil)
        return;
    memfillcolor(p->disc, DTransparent);
    memellipse(p->disc, p00, t, t, -1, memopaque, p00, p->op);
    oy = y;
    ox = 0;
    nx = x = step(s);
    do {
        while(nx==x && y-->0)
            nx = step(s);
        y++;
        eline(-x,-oy,-ox, -y, p);
        eline(ox,-oy,  x, -y, p);
        eline(-x,  y,-ox, oy, p);
        eline(ox,  y,  x, oy, p);
        ox = x+1;
        x = nx;
        y--;
        oy = y;
    } while(oy > 0);
}
@

<<function erect>>=
/*
 * a rectangle with closed (not half-open) coordinates expressed
 * relative to the center of the ellipse
 */
static
void
erect(int x0, int y0, int x1, int y1, Param *p)
{
    Rectangle r;

/*	print("R %d,%d %d,%d\n", x0, y0, x1, y1); /**/
    r = Rect(p->c.x+x0, p->c.y+y0, p->c.x+x1+1, p->c.y+y1+1);
    memdraw(p->dst, r, p->src, addpt(p->sp, r.min), memopaque, p00, p->op);
}
@

<<function epoint>>=
/*
 * a brushed point similarly specified
 */
static
void
epoint(int x, int y, Param *p)
{
    Point p0;
    Rectangle r;

/*	print("P%d %d,%d\n", p->t, x, y);	/**/
    p0 = Pt(p->c.x+x, p->c.y+y);
    r = Rpt(addpt(p0, p->disc->r.min), addpt(p0, p->disc->r.max));
    memdraw(p->dst, r, p->src, addpt(p->sp, r.min), p->disc, p->disc->r.min, p->op);
}
@

<<function eline>>=
/* 
 * a brushed horizontal or vertical line similarly specified
 */
static
void
eline(int x0, int y0, int x1, int y1, Param *p)
{
/*	print("L%d %d,%d %d,%d\n", p->t, x0, y0, x1, y1); /**/
    if(x1 > x0+1)
        erect(x0+1, y0-p->t, x1-1, y1+p->t, p);
    else if(y1 > y0+1)
        erect(x0-p->t, y0+1, x1+p->t, y1-1, p);
    epoint(x0, y0, p);
    if(x1-x0 || y1-y0)
        epoint(x1, y1, p);
}
@


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/ellipse.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

/*
 * ellipse(dst, c, a, b, t, src, sp)
 *   draws an ellipse centered at c with semiaxes a,b>=0
 *   and semithickness t>=0, or filled if t<0.  point sp
 *   in src maps to c in dst
 *
 *   very thick skinny ellipses are brushed with circles (slow)
 *   others are approximated by filling between 2 ellipses
 *   criterion for very thick when b<a: t/b > 0.5*x/(1-x)
 *   where x = b/a
 */

typedef struct ParamEllipse	Param;
typedef struct State	State;

static	void	bellipse(int, State*, Param*);
static	void	erect(int, int, int, int, Param*);
static	void	eline(int, int, int, int, Param*);

<<struct ParamEllipse>>

<<struct State>>

<<function newstate>>

<<function step>>

<<function memellipse>>

<<global p00 (lib_graphics/libmemdraw/ellipse.c)>>

<<function bellipse>>

<<function erect>>

<<function epoint>>

<<function eline>>
@


\subsection*{[[lib_graphics/libmemdraw/fillpoly.c]]}

<<struct Seg>>=
struct Seg
{
    Point	p0;
    Point	p1;
    long	num;
    long	den;
    long	dz;
    long	dzrem;
    long	z;
    long	zerr;
    long	d;
};
@

<<function fillcolor>>=
static void
fillcolor(Memimage *dst, int left, int right, int y, Memimage *src, Point p)
{
    int srcval;

    USED(src);
    srcval = p.x;
    p.x = left;
    p.y = y;
    memset(byteaddr(dst, p), srcval, right-left);
}
@

<<function fillline>>=
static void
fillline(Memimage *dst, int left, int right, int y, Memimage *src, Point p, int op)
{
    Rectangle r;

    r.min.x = left;
    r.min.y = y;
    r.max.x = right;
    r.max.y = y+1;
    p.x += left;
    p.y += y;
    memdraw(dst, r, src, p, memopaque, p, op);
}
@

<<function fillpoint>>=
static void
fillpoint(Memimage *dst, int x, int y, Memimage *src, Point p, int op)
{
    Rectangle r;

    r.min.x = x;
    r.min.y = y;
    r.max.x = x+1;
    r.max.y = y+1;
    p.x += x;
    p.y += y;
    memdraw(dst, r, src, p, memopaque, p, op);
}
@

<<function memfillpoly>>=
void
memfillpoly(Memimage *dst, Point *vert, int nvert, int w, Memimage *src, Point sp, int op)
{
    _memfillpolysc(dst, vert, nvert, w, src, sp, 0, 0, 0, op);
}
@

<<function _memfillpolysc>>=
void
_memfillpolysc(Memimage *dst, Point *vert, int nvert, int w, Memimage *src, Point sp, int detail, int fixshift, int clipped, int op)
{
    Seg **seg, *segtab;
    Point p0;
    int i;

    if(nvert == 0)
        return;

    seg = malloc((nvert+2)*sizeof(Seg*));
    if(seg == nil)
        return;
    segtab = malloc((nvert+1)*sizeof(Seg));
    if(segtab == nil) {
        free(seg);
        return;
    }

    sp.x = (sp.x - vert[0].x) >> fixshift;
    sp.y = (sp.y - vert[0].y) >> fixshift;
    p0 = vert[nvert-1];
    if(!fixshift) {
        p0.x <<= 1;
        p0.y <<= 1;
    }
    for(i = 0; i < nvert; i++) {
        segtab[i].p0 = p0;
        p0 = vert[i];
        if(!fixshift) {
            p0.x <<= 1;
            p0.y <<= 1;
        }
        segtab[i].p1 = p0;
        segtab[i].d = 1;
    }
    if(!fixshift)
        fixshift = 1;

    xscan(dst, seg, segtab, nvert, w, src, sp, detail, fixshift, clipped, op);
    if(detail)
        yscan(dst, seg, segtab, nvert, w, src, sp, fixshift, op);

    free(seg);
    free(segtab);
}
@

<<function mod>>=
static long
mod(long x, long y)
{
    long z;

    z = x%y;
    if((long)(((ulong)z)^((ulong)y)) > 0 || z == 0)
        return z;
    return z + y;
}
@

<<function sdiv>>=
static long
sdiv(long x, long y)
{
    if((long)(((ulong)x)^((ulong)y)) >= 0 || x == 0)
        return x/y;

    return (x+((y>>30)|1))/y-1;
}
@

<<function smuldivmod>>=
static long
smuldivmod(long x, long y, long z, long *mod)
{
    vlong vx;

    if(x == 0 || y == 0){
        *mod = 0;
        return 0;
    }
    vx = x;
    vx *= y;
    *mod = vx % z;
    if(*mod < 0)
        *mod += z;	/* z is always >0 */
    if((vx < 0) == (z < 0))
        return vx/z;
    return -((-vx)/z);
}
@

<<function xscan>>=
static void
xscan(Memimage *dst, Seg **seg, Seg *segtab, int nseg, int wind, Memimage *src, Point sp, int detail, int fixshift, int clipped, int op)
{
    long y, maxy, x, x2, xerr, xden, onehalf;
    Seg **ep, **next, **p, **q, *s;
    long n, i, iy, cnt, ix, ix2, minx, maxx;
    Point pt;
    void	(*fill)(Memimage*, int, int, int, Memimage*, Point, int);

    fill = fillline;
/*
 * This can only work on 8-bit destinations, since fillcolor is
 * just using memset on sp.x.
 *
 * I'd rather not even enable it then, since then if the general
 * code is too slow, someone will come up with a better improvement
 * than this sleazy hack.	-rsc
 *
    if(clipped && (src->flags&Frepl) && src->depth==8 && Dx(src->r)==1 && Dy(src->r)==1) {
        fill = fillcolor;
        sp.x = membyteval(src);
    }
 *
 */
    USED(clipped);


    for(i=0, s=segtab, p=seg; i<nseg; i++, s++) {
        *p = s;
        if(s->p0.y == s->p1.y)
            continue;
        if(s->p0.y > s->p1.y) {
            pt = s->p0;
            s->p0 = s->p1;
            s->p1 = pt;
            s->d = -s->d;
        }
        s->num = s->p1.x - s->p0.x;
        s->den = s->p1.y - s->p0.y;
        s->dz = sdiv(s->num, s->den) << fixshift;
        s->dzrem = mod(s->num, s->den) << fixshift;
        s->dz += sdiv(s->dzrem, s->den);
        s->dzrem = mod(s->dzrem, s->den);
        p++;
    }
    n = p-seg;
    if(n == 0)
        return;
    *p = 0;
    qsort(seg, p-seg , sizeof(Seg*), ycompare);

    onehalf = 0;
    if(fixshift)
        onehalf = 1 << (fixshift-1);

    minx = dst->clipr.min.x;
    maxx = dst->clipr.max.x;

    y = seg[0]->p0.y;
    if(y < (dst->clipr.min.y << fixshift))
        y = dst->clipr.min.y << fixshift;
    iy = (y + onehalf) >> fixshift;
    y = (iy << fixshift) + onehalf;
    maxy = dst->clipr.max.y << fixshift;

    ep = next = seg;

    while(y<maxy) {
        for(q = p = seg; p < ep; p++) {
            s = *p;
            if(s->p1.y < y)
                continue;
            s->z += s->dz;
            s->zerr += s->dzrem;
            if(s->zerr >= s->den) {
                s->z++;
                s->zerr -= s->den;
                if(s->zerr < 0 || s->zerr >= s->den)
                    print("bad ratzerr1: %ld den %ld dzrem %ld\n", s->zerr, s->den, s->dzrem);
            }
            *q++ = s;
        }

        for(p = next; *p; p++) {
            s = *p;
            if(s->p0.y >= y)
                break;
            if(s->p1.y < y)
                continue;
            s->z = s->p0.x;
            s->z += smuldivmod(y - s->p0.y, s->num, s->den, &s->zerr);
            if(s->zerr < 0 || s->zerr >= s->den)
                print("bad ratzerr2: %ld den %ld ratdzrem %ld\n", s->zerr, s->den, s->dzrem);
            *q++ = s;
        }
        ep = q;
        next = p;

        if(ep == seg) {
            if(*next == 0)
                break;
            iy = (next[0]->p0.y + onehalf) >> fixshift;
            y = (iy << fixshift) + onehalf;
            continue;
        }

        zsort(seg, ep);

        for(p = seg; p < ep; p++) {
            cnt = 0;
            x = p[0]->z;
            xerr = p[0]->zerr;
            xden = p[0]->den;
            ix = (x + onehalf) >> fixshift;
            if(ix >= maxx)
                break;
            if(ix < minx)
                ix = minx;
            cnt += p[0]->d;
            p++;
            for(;;) {
                if(p == ep) {
                    print("xscan: fill to infinity");
                    return;
                }
                cnt += p[0]->d;
                if((cnt&wind) == 0)
                    break;
                p++;
            }
            x2 = p[0]->z;
            ix2 = (x2 + onehalf) >> fixshift;
            if(ix2 <= minx)
                continue;
            if(ix2 > maxx)
                ix2 = maxx;
            if(ix == ix2 && detail) {
                if(xerr*p[0]->den + p[0]->zerr*xden > p[0]->den*xden)
                    x++;
                ix = (x + x2) >> (fixshift+1);
                ix2 = ix+1;
            }
            (*fill)(dst, ix, ix2, iy, src, sp, op);
        }
        y += (1<<fixshift);
        iy++;
    }
}
@

<<function yscan>>=
static void
yscan(Memimage *dst, Seg **seg, Seg *segtab, int nseg, int wind, Memimage *src, Point sp, int fixshift, int op)
{
    long x, maxx, y, y2, yerr, yden, onehalf;
    Seg **ep, **next, **p, **q, *s;
    int n, i, ix, cnt, iy, iy2, miny, maxy;
    Point pt;

    for(i=0, s=segtab, p=seg; i<nseg; i++, s++) {
        *p = s;
        if(s->p0.x == s->p1.x)
            continue;
        if(s->p0.x > s->p1.x) {
            pt = s->p0;
            s->p0 = s->p1;
            s->p1 = pt;
            s->d = -s->d;
        }
        s->num = s->p1.y - s->p0.y;
        s->den = s->p1.x - s->p0.x;
        s->dz = sdiv(s->num, s->den) << fixshift;
        s->dzrem = mod(s->num, s->den) << fixshift;
        s->dz += sdiv(s->dzrem, s->den);
        s->dzrem = mod(s->dzrem, s->den);
        p++;
    }
    n = p-seg;
    if(n == 0)
        return;
    *p = 0;
    qsort(seg, n , sizeof(Seg*), xcompare);

    onehalf = 0;
    if(fixshift)
        onehalf = 1 << (fixshift-1);

    miny = dst->clipr.min.y;
    maxy = dst->clipr.max.y;

    x = seg[0]->p0.x;
    if(x < (dst->clipr.min.x << fixshift))
        x = dst->clipr.min.x << fixshift;
    ix = (x + onehalf) >> fixshift;
    x = (ix << fixshift) + onehalf;
    maxx = dst->clipr.max.x << fixshift;

    ep = next = seg;

    while(x<maxx) {
        for(q = p = seg; p < ep; p++) {
            s = *p;
            if(s->p1.x < x)
                continue;
            s->z += s->dz;
            s->zerr += s->dzrem;
            if(s->zerr >= s->den) {
                s->z++;
                s->zerr -= s->den;
                if(s->zerr < 0 || s->zerr >= s->den)
                    print("bad ratzerr1: %ld den %ld ratdzrem %ld\n", s->zerr, s->den, s->dzrem);
            }
            *q++ = s;
        }

        for(p = next; *p; p++) {
            s = *p;
            if(s->p0.x >= x)
                break;
            if(s->p1.x < x)
                continue;
            s->z = s->p0.y;
            s->z += smuldivmod(x - s->p0.x, s->num, s->den, &s->zerr);
            if(s->zerr < 0 || s->zerr >= s->den)
                print("bad ratzerr2: %ld den %ld ratdzrem %ld\n", s->zerr, s->den, s->dzrem);
            *q++ = s;
        }
        ep = q;
        next = p;

        if(ep == seg) {
            if(*next == 0)
                break;
            ix = (next[0]->p0.x + onehalf) >> fixshift;
            x = (ix << fixshift) + onehalf;
            continue;
        }

        zsort(seg, ep);

        for(p = seg; p < ep; p++) {
            cnt = 0;
            y = p[0]->z;
            yerr = p[0]->zerr;
            yden = p[0]->den;
            iy = (y + onehalf) >> fixshift;
            if(iy >= maxy)
                break;
            if(iy < miny)
                iy = miny;
            cnt += p[0]->d;
            p++;
            for(;;) {
                if(p == ep) {
                    print("yscan: fill to infinity");
                    return;
                }
                cnt += p[0]->d;
                if((cnt&wind) == 0)
                    break;
                p++;
            }
            y2 = p[0]->z;
            iy2 = (y2 + onehalf) >> fixshift;
            if(iy2 <= miny)
                continue;
            if(iy2 > maxy)
                iy2 = maxy;
            if(iy == iy2) {
                if(yerr*p[0]->den + p[0]->zerr*yden > p[0]->den*yden)
                    y++;
                iy = (y + y2) >> (fixshift+1);
                fillpoint(dst, ix, iy, src, sp, op);
            }
        }
        x += (1<<fixshift);
        ix++;
    }
}
@

<<function zsort>>=
static void
zsort(Seg **seg, Seg **ep)
{
    int done;
    Seg **q, **p, *s;

    if(ep-seg < 20) {
        /* bubble sort by z - they should be almost sorted already */
        q = ep;
        do {
            done = 1;
            q--;
            for(p = seg; p < q; p++) {
                if(p[0]->z > p[1]->z) {
                    s = p[0];
                    p[0] = p[1];
                    p[1] = s;
                    done = 0;
                }
            }
        } while(!done);
    } else {
        q = ep-1;
        for(p = seg; p < q; p++) {
            if(p[0]->z > p[1]->z) {
                qsort(seg, ep-seg, sizeof(Seg*), zcompare);
                break;
            }
        }
    }
}
@

<<function ycompare>>=
static int
ycompare(void *a, void *b)
{
    Seg **s0, **s1;
    long y0, y1;

    s0 = a;
    s1 = b;
    y0 = (*s0)->p0.y;
    y1 = (*s1)->p0.y;

    if(y0 < y1)
        return -1;
    if(y0 == y1)
        return 0;
    return 1;
}
@

<<function xcompare>>=
static int
xcompare(void *a, void *b)
{
    Seg **s0, **s1;
    long x0, x1;

    s0 = a;
    s1 = b;
    x0 = (*s0)->p0.x;
    x1 = (*s1)->p0.x;

    if(x0 < x1)
        return -1;
    if(x0 == x1)
        return 0;
    return 1;
}
@

<<function zcompare>>=
static int
zcompare(void *a, void *b)
{
    Seg **s0, **s1;
    long z0, z1;

    s0 = a;
    s1 = b;
    z0 = (*s0)->z;
    z1 = (*s1)->z;

    if(z0 < z1)
        return -1;
    if(z0 == z1)
        return 0;
    return 1;
}
@


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/fillpoly.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

typedef struct Seg	Seg;

<<struct Seg>>

static	void	zsort(Seg **seg, Seg **ep);
static	int	ycompare(void*, void*);
static	int	xcompare(void*, void*);
static	int	zcompare(void*, void*);
static	void	xscan(Memimage *dst, Seg **seg, Seg *segtab, int nseg, int wind, Memimage *src, Point sp, int, int, int, int);
static	void	yscan(Memimage *dst, Seg **seg, Seg *segtab, int nseg, int wind, Memimage *src, Point sp, int, int);

<<function fillcolor>>

<<function fillline>>

<<function fillpoint>>

<<function memfillpoly>>

<<function _memfillpolysc>>

<<function mod>>

<<function sdiv>>

<<function smuldivmod>>

<<function xscan>>

<<function yscan>>

<<function zsort>>

<<function ycompare>>

<<function xcompare>>

<<function zcompare>>
@


\subsection*{[[lib_graphics/libmemdraw/hwdraw.c]]}

% hmm actually prefer the one in kernel/


\subsection*{[[lib_graphics/libmemdraw/iprint.c]]}

<<function memdraw_iprint>>=
int
memdraw_iprint(char*,...)
{
    return -1;
}
@

<<global iprint>>=
int		(*iprint)(char*, ...) = &memdraw_iprint;
@


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/iprint.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>

<<function memdraw_iprint>>

<<global iprint>>

@


\subsection*{[[lib_graphics/libmemdraw/line.c]]}

<<enum _anon_ (lib_graphics/libmemdraw/line.c)>>=
enum
{
    Arrow1 = 8,
    Arrow2 = 10,
    Arrow3 = 3,
};
@

<<function lmin>>=
static
int
lmin(int a, int b)
{
    if(a < b)
        return a;
    return b;
}
@

<<function lmax>>=
static
int
lmax(int a, int b)
{
    if(a > b)
        return a;
    return b;
}
@

<<function horline1>>=
/*
 * Rather than line clip, we run the Bresenham loop over the full line,
 * and clip on each pixel.  This is more expensive but means that
 * lines look the same regardless of how the windowing has tiled them.
 * For speed, we check for clipping outside the loop and make the
 * test easy when possible.
 */

static
void
horline1(Memimage *dst, Point p0, Point p1, int srcval, Rectangle clipr)
{
    int x, y, dy, deltay, deltax, maxx;
    int dd, easy, e, bpp, m, m0;
    uchar *d;

    deltax = p1.x - p0.x;
    deltay = p1.y - p0.y;
    dd = dst->width*sizeof(ulong);
    dy = 1;
    if(deltay < 0){
        dd = -dd;
        deltay = -deltay;
        dy = -1;
    }
    maxx = lmin(p1.x, clipr.max.x-1);
    bpp = dst->depth;
    m0 = 0xFF^(0xFF>>bpp);
    m = m0 >> (p0.x&(7/dst->depth))*bpp;
    easy = ptinrect(p0, clipr) && ptinrect(p1, clipr);
    e = 2*deltay - deltax;
    y = p0.y;
    d = byteaddr(dst, p0);
    deltay *= 2;
    deltax = deltay - 2*deltax;
    for(x=p0.x; x<=maxx; x++){
        if(easy || (clipr.min.x<=x && clipr.min.y<=y && y<clipr.max.y))
            *d ^= (*d^srcval) & m;
        if(e > 0){
            y += dy;
            d += dd;
            e += deltax;
        }else
            e += deltay;
        d++;
        m >>= bpp;
        if(m == 0)
            m = m0;
    }
}
@

<<function verline1>>=
static
void
verline1(Memimage *dst, Point p0, Point p1, int srcval, Rectangle clipr)
{
    int x, y, deltay, deltax, maxy;
    int easy, e, bpp, m, m0, dd;
    uchar *d;

    deltax = p1.x - p0.x;
    deltay = p1.y - p0.y;
    dd = 1;
    if(deltax < 0){
        dd = -1;
        deltax = -deltax;
    }
    maxy = lmin(p1.y, clipr.max.y-1);
    bpp = dst->depth;
    m0 = 0xFF^(0xFF>>bpp);
    m = m0 >> (p0.x&(7/dst->depth))*bpp;
    easy = ptinrect(p0, clipr) && ptinrect(p1, clipr);
    e = 2*deltax - deltay;
    x = p0.x;
    d = byteaddr(dst, p0);
    deltax *= 2;
    deltay = deltax - 2*deltay;
    for(y=p0.y; y<=maxy; y++){
        if(easy || (clipr.min.y<=y && clipr.min.x<=x && x<clipr.max.x))
            *d ^= (*d^srcval) & m;
        if(e > 0){
            x += dd;
            d += dd;
            e += deltay;
        }else
            e += deltax;
        d += dst->width*sizeof(ulong);
        m >>= bpp;
        if(m == 0)
            m = m0;
    }
}
@

<<function horliner>>=
static
void
horliner(Memimage *dst, Point p0, Point p1, Memimage *src, Point dsrc, Rectangle clipr)
{
    int x, y, sx, sy, deltay, deltax, minx, maxx;
    int bpp, m, m0;
    uchar *d, *s;

    deltax = p1.x - p0.x;
    deltay = p1.y - p0.y;
    sx = drawreplxy(src->r.min.x, src->r.max.x, p0.x+dsrc.x);
    minx = lmax(p0.x, clipr.min.x);
    maxx = lmin(p1.x, clipr.max.x-1);
    bpp = dst->depth;
    m0 = 0xFF^(0xFF>>bpp);
    m = m0 >> (minx&(7/dst->depth))*bpp;
    for(x=minx; x<=maxx; x++){
        y = p0.y + (deltay*(x-p0.x)+deltax/2)/deltax;
        if(clipr.min.y<=y && y<clipr.max.y){
            d = byteaddr(dst, Pt(x, y));
            sy = drawreplxy(src->r.min.y, src->r.max.y, y+dsrc.y);
            s = byteaddr(src, Pt(sx, sy));
            *d ^= (*d^*s) & m;
        }
        if(++sx >= src->r.max.x)
            sx = src->r.min.x;
        m >>= bpp;
        if(m == 0)
            m = m0;
    }
}
@

<<function verliner>>=
static
void
verliner(Memimage *dst, Point p0, Point p1, Memimage *src, Point dsrc, Rectangle clipr)
{
    int x, y, sx, sy, deltay, deltax, miny, maxy;
    int bpp, m, m0;
    uchar *d, *s;

    deltax = p1.x - p0.x;
    deltay = p1.y - p0.y;
    sy = drawreplxy(src->r.min.y, src->r.max.y, p0.y+dsrc.y);
    miny = lmax(p0.y, clipr.min.y);
    maxy = lmin(p1.y, clipr.max.y-1);
    bpp = dst->depth;
    m0 = 0xFF^(0xFF>>bpp);
    for(y=miny; y<=maxy; y++){
        if(deltay == 0)	/* degenerate line */
            x = p0.x;
        else
            x = p0.x + (deltax*(y-p0.y)+deltay/2)/deltay;
        if(clipr.min.x<=x && x<clipr.max.x){
            m = m0 >> (x&(7/dst->depth))*bpp;
            d = byteaddr(dst, Pt(x, y));
            sx = drawreplxy(src->r.min.x, src->r.max.x, x+dsrc.x);
            s = byteaddr(src, Pt(sx, sy));
            *d ^= (*d^*s) & m;
        }
        if(++sy >= src->r.max.y)
            sy = src->r.min.y;
    }
}
@

<<function horline>>=
static
void
horline(Memimage *dst, Point p0, Point p1, Memimage *src, Point dsrc, Rectangle clipr)
{
    int x, y, deltay, deltax, minx, maxx;
    int bpp, m, m0;
    uchar *d, *s;

    deltax = p1.x - p0.x;
    deltay = p1.y - p0.y;
    minx = lmax(p0.x, clipr.min.x);
    maxx = lmin(p1.x, clipr.max.x-1);
    bpp = dst->depth;
    m0 = 0xFF^(0xFF>>bpp);
    m = m0 >> (minx&(7/dst->depth))*bpp;
    for(x=minx; x<=maxx; x++){
        y = p0.y + (deltay*(x-p0.x)+deltay/2)/deltax;
        if(clipr.min.y<=y && y<clipr.max.y){
            d = byteaddr(dst, Pt(x, y));
            s = byteaddr(src, addpt(dsrc, Pt(x, y)));
            *d ^= (*d^*s) & m;
        }
        m >>= bpp;
        if(m == 0)
            m = m0;
    }
}
@

<<function verline>>=
static
void
verline(Memimage *dst, Point p0, Point p1, Memimage *src, Point dsrc, Rectangle clipr)
{
    int x, y, deltay, deltax, miny, maxy;
    int bpp, m, m0;
    uchar *d, *s;

    deltax = p1.x - p0.x;
    deltay = p1.y - p0.y;
    miny = lmax(p0.y, clipr.min.y);
    maxy = lmin(p1.y, clipr.max.y-1);
    bpp = dst->depth;
    m0 = 0xFF^(0xFF>>bpp);
    for(y=miny; y<=maxy; y++){
        if(deltay == 0)	/* degenerate line */
            x = p0.x;
        else
            x = p0.x + deltax*(y-p0.y)/deltay;
        if(clipr.min.x<=x && x<clipr.max.x){
            m = m0 >> (x&(7/dst->depth))*bpp;
            d = byteaddr(dst, Pt(x, y));
            s = byteaddr(src, addpt(dsrc, Pt(x, y)));
            *d ^= (*d^*s) & m;
        }
    }
}
@

<<function membrush>>=
static Memimage*
membrush(int radius)
{
    static Memimage *brush;
    static int brushradius;

    if(brush==nil || brushradius!=radius){
        freememimage(brush);
        brush = allocmemimage(Rect(0, 0, 2*radius+1, 2*radius+1), memopaque->chan);
        if(brush != nil){
            memfillcolor(brush, DTransparent);	/* zeros */
            memellipse(brush, Pt(radius, radius), radius, radius, -1, memopaque, Pt(radius, radius), S);
        }
        brushradius = radius;
    }
    return brush;
}
@

<<function discend>>=
static
void
discend(Point p, int radius, Memimage *dst, Memimage *src, Point dsrc, int op)
{
    Memimage *disc;
    Rectangle r;

    disc = membrush(radius);
    if(disc != nil){
        r.min.x = p.x - radius;
        r.min.y = p.y - radius;
        r.max.x = p.x + radius+1;
        r.max.y = p.y + radius+1;
        memdraw(dst, r, src, addpt(r.min, dsrc), disc, Pt(0,0), op);
    }
}
@

<<function arrowend>>=
static
void
arrowend(Point tip, Point *pp, int end, int sin, int cos, int radius)
{
    int x1, x2, x3;

    /* before rotation */
    if(end == Endarrow){
        x1 = Arrow1;
        x2 = Arrow2;
        x3 = Arrow3;
    }else{
        x1 = (end>>5) & 0x1FF;	/* distance along line from end of line to tip */
        x2 = (end>>14) & 0x1FF;	/* distance along line from barb to tip */
        x3 = (end>>23) & 0x1FF;	/* distance perpendicular from edge of line to barb */
    }

    /* comments follow track of right-facing arrowhead */
    pp->x = tip.x+((2*radius+1)*sin/2-x1*cos);		/* upper side of shaft */
    pp->y = tip.y-((2*radius+1)*cos/2+x1*sin);
    pp++;
    pp->x = tip.x+((2*radius+2*x3+1)*sin/2-x2*cos);		/* upper barb */
    pp->y = tip.y-((2*radius+2*x3+1)*cos/2+x2*sin);
    pp++;
    pp->x = tip.x;
    pp->y = tip.y;
    pp++;
    pp->x = tip.x+(-(2*radius+2*x3+1)*sin/2-x2*cos);	/* lower barb */
    pp->y = tip.y-(-(2*radius+2*x3+1)*cos/2+x2*sin);
    pp++;
    pp->x = tip.x+(-(2*radius+1)*sin/2-x1*cos);		/* lower side of shaft */
    pp->y = tip.y+((2*radius+1)*cos/2-x1*sin);
}
@

<<function _memimageline>>=
void
_memimageline(Memimage *dst, Point p0, Point p1, int end0, int end1, int radius, Memimage *src, Point sp, Rectangle clipr, int op)
{
    /*
     * BUG: We should really really pick off purely horizontal and purely
     * vertical lines and handle them separately with calls to memimagedraw
     * on rectangles.
     */

    int hor;
    int sin, cos, dx, dy, t;
    Rectangle oclipr, r;
    Point q, pts[10], *pp, d;

    if(radius < 0)
        return;
    if(rectclip(&clipr, dst->r) == 0)
        return;
    if(rectclip(&clipr, dst->clipr) == 0)
        return;
    d = subpt(sp, p0);
    if(rectclip(&clipr, rectsubpt(src->clipr, d)) == 0)
        return;
    if((src->flags&Frepl)==0 && rectclip(&clipr, rectsubpt(src->r, d))==0)
        return;
    /* this means that only verline() handles degenerate lines (p0==p1) */
    hor = (abs(p1.x-p0.x) > abs(p1.y-p0.y));
    /*
     * Clipping is a little peculiar.  We can't use Sutherland-Cohen
     * clipping because lines are wide.  But this is probably just fine:
     * we do all math with the original p0 and p1, but clip when deciding
     * what pixels to draw.  This means the layer code can call this routine,
     * using clipr to define the region being written, and get the same set
     * of pixels regardless of the dicing.
     */
    if((hor && p0.x>p1.x) || (!hor && p0.y>p1.y)){
        q = p0;
        p0 = p1;
        p1 = q;
        t = end0;
        end0 = end1;
        end1 = t;
    }

    if((p0.x == p1.x || p0.y == p1.y) && (end0&0x1F) == Endsquare && (end1&0x1F) == Endsquare){
        r.min = p0;
        r.max = p1;
        if(p0.x == p1.x){
            r.min.x -= radius;
            r.max.x += radius+1;
        }
        else{
            r.min.y -= radius;
            r.max.y += radius+1;
        }
        oclipr = dst->clipr;
        sp = addpt(r.min, d);
        dst->clipr = clipr;
        memimagedraw(dst, r, src, sp, memopaque, sp, op);
        dst->clipr = oclipr;
        return;
    }

/*    Hard: */
    /* draw thick line using polygon fill */
    icossin2(p1.x-p0.x, p1.y-p0.y, &cos, &sin);
    dx = (sin*(2*radius+1))/2;
    dy = (cos*(2*radius+1))/2;
    pp = pts;
    oclipr = dst->clipr;
    dst->clipr = clipr;
    q.x = ICOSSCALE*p0.x+ICOSSCALE/2-cos/2;
    q.y = ICOSSCALE*p0.y+ICOSSCALE/2-sin/2;
    switch(end0 & 0x1F){
    case Enddisc:
        discend(p0, radius, dst, src, d, op);
        /* fall through */
    case Endsquare:
    default:
        pp->x = q.x-dx;
        pp->y = q.y+dy;
        pp++;
        pp->x = q.x+dx;
        pp->y = q.y-dy;
        pp++;
        break;
    case Endarrow:
        arrowend(q, pp, end0, -sin, -cos, radius);
        _memfillpolysc(dst, pts, 5, ~0, src, addpt(pts[0], mulpt(d, ICOSSCALE)), 1, 10, 1, op);
        pp[1] = pp[4];
        pp += 2;
    }
    q.x = ICOSSCALE*p1.x+ICOSSCALE/2+cos/2;
    q.y = ICOSSCALE*p1.y+ICOSSCALE/2+sin/2;
    switch(end1 & 0x1F){
    case Enddisc:
        discend(p1, radius, dst, src, d, op);
        /* fall through */
    case Endsquare:
    default:
        pp->x = q.x+dx;
        pp->y = q.y-dy;
        pp++;
        pp->x = q.x-dx;
        pp->y = q.y+dy;
        pp++;
        break;
    case Endarrow:
        arrowend(q, pp, end1, sin, cos, radius);
        _memfillpolysc(dst, pp, 5, ~0, src, addpt(pp[0], mulpt(d, ICOSSCALE)), 1, 10, 1, op);
        pp[1] = pp[4];
        pp += 2;
    }
    _memfillpolysc(dst, pts, pp-pts, ~0, src, addpt(pts[0], mulpt(d, ICOSSCALE)), 0, 10, 1, op);
    dst->clipr = oclipr;
    return;
}
@

<<function memimageline>>=
void
memimageline(Memimage *dst, Point p0, Point p1, int end0, int end1, int radius, Memimage *src, Point sp, int op)
{
    _memimageline(dst, p0, p1, end0, end1, radius, src, sp, dst->clipr, op);
}
@

<<function addbbox>>=
/*
 * Simple-minded conservative code to compute bounding box of line.
 * Result is probably a little larger than it needs to be.
 */
static
void
addbbox(Rectangle *r, Point p)
{
    if(r->min.x > p.x)
        r->min.x = p.x;
    if(r->min.y > p.y)
        r->min.y = p.y;
    if(r->max.x < p.x+1)
        r->max.x = p.x+1;
    if(r->max.y < p.y+1)
        r->max.y = p.y+1;
}
@

<<function memlineendsize>>=
int
memlineendsize(int end)
{
    int x3;

    if((end&0x3F) != Endarrow)
        return 0;
    if(end == Endarrow)
        x3 = Arrow3;
    else
        x3 = (end>>23) & 0x1FF;
    return x3;
}
@

<<function memlinebbox>>=
Rectangle
memlinebbox(Point p0, Point p1, int end0, int end1, int radius)
{
    Rectangle r, r1;
    int extra;

    r.min.x = 10000000;
    r.min.y = 10000000;
    r.max.x = -10000000;
    r.max.y = -10000000;
    extra = lmax(memlineendsize(end0), memlineendsize(end1));
    r1 = insetrect(canonrect(Rpt(p0, p1)), -(radius+extra));
    addbbox(&r, r1.min);
    addbbox(&r, r1.max);
    return r;
}
@


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/line.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<enum _anon_ (lib_graphics/libmemdraw/line.c)>>

<<function lmin>>

<<function lmax>>

#ifdef NOTUSED
<<function horline1>>

<<function verline1>>

<<function horliner>>

<<function verliner>>

<<function horline>>

<<function verline>>
#endif /* NOTUSED */

<<function membrush>>

<<function discend>>

<<function arrowend>>

<<function _memimageline>>

<<function memimageline>>

<<function addbbox>>

<<function memlineendsize>>

<<function memlinebbox>>
@


\subsection*{[[lib_graphics/libmemdraw/load.c]]}

<<function loadmemimage>>=
int
loadmemimage(Memimage *i, Rectangle r, uchar *data, int ndata)
{
    int y, l, lpart, rpart, mx, m, mr;
    uchar *q;

    if(!rectinrect(r, i->r))
        return -1;
    l = bytesperline(r, i->depth);
    if(ndata < l*Dy(r))
        return -1;
    ndata = l*Dy(r);
    q = byteaddr(i, r.min);
    mx = 7/i->depth;
    lpart = (r.min.x & mx) * i->depth;
    rpart = (r.max.x & mx) * i->depth;
    m = 0xFF >> lpart;
    /* may need to do bit insertion on edges */
    if(l == 1){	/* all in one byte */
        if(rpart)
            m ^= 0xFF >> rpart;
        for(y=r.min.y; y<r.max.y; y++){
            *q ^= (*data^*q) & m;
            q += i->width*sizeof(ulong);
            data++;
        }
        return ndata;
    }
    if(lpart==0 && rpart==0){	/* easy case */
        for(y=r.min.y; y<r.max.y; y++){
            memmove(q, data, l);
            q += i->width*sizeof(ulong);
            data += l;
        }
        return ndata;
    }
    mr = 0xFF ^ (0xFF >> rpart);
    if(lpart!=0 && rpart==0){
        for(y=r.min.y; y<r.max.y; y++){
            *q ^= (*data^*q) & m;
            if(l > 1)
                memmove(q+1, data+1, l-1);
            q += i->width*sizeof(ulong);
            data += l;
        }
        return ndata;
    }
    if(lpart==0 && rpart!=0){
        for(y=r.min.y; y<r.max.y; y++){
            if(l > 1)
                memmove(q, data, l-1);
            q[l-1] ^= (data[l-1]^q[l-1]) & mr;
            q += i->width*sizeof(ulong);
            data += l;
        }
        return ndata;
    }
    for(y=r.min.y; y<r.max.y; y++){
        *q ^= (*data^*q) & m;
        if(l > 2)
            memmove(q+1, data+1, l-2);
        q[l-1] ^= (data[l-1]^q[l-1]) & mr;
        q += i->width*sizeof(ulong);
        data += l;
    }
    return ndata;
}
@


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/load.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>

<<function loadmemimage>>
@


\subsection*{[[lib_graphics/libmemdraw/openmemsubfont.c]]}

<<function openmemsubfont>>=
Memsubfont*
openmemsubfont(char *name)
{
    Memsubfont *sf;
    Memimage *i;
    Fontchar *fc;
    int fd, n;
    char hdr[3*12+4+1];
    uchar *p;

    fd = open(name, OREAD);
    if(fd < 0)
        return nil;
    p = nil;
    i = readmemimage(fd);
    if(i == nil)
        goto Err;
    if(read(fd, hdr, 3*12) != 3*12){
        werrstr("openmemsubfont: header read error: %r");
        goto Err;
    }
    n = atoi(hdr);
    p = malloc(6*(n+1));
    if(p == nil)
        goto Err;
    if(read(fd, p, 6*(n+1)) != 6*(n+1)){
        werrstr("openmemsubfont: fontchar read error: %r");
        goto Err;
    }
    fc = malloc(sizeof(Fontchar)*(n+1));
    if(fc == nil)
        goto Err;
    _unpackinfo(fc, p, n);
    sf = allocmemsubfont(name, n, atoi(hdr+12), atoi(hdr+24), fc, i);
    if(sf == nil){
        free(fc);
        goto Err;
    }
    free(p);
    return sf;
Err:
    close(fd);
    if (i != nil)
        freememimage(i);
    if (p != nil)
        free(p);
    return nil;
}
@


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/openmemsubfont.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>

<<function openmemsubfont>>
@


\subsection*{[[lib_graphics/libmemdraw/poly.c]]}

<<function mempoly>>=
void
mempoly(Memimage *dst, Point *vert, int nvert, int end0, int end1, int radius, Memimage *src, Point sp, int op)
{
    int i, e0, e1;
    Point d;

    if(nvert < 2)
        return;
    d = subpt(sp, vert[0]);
    for(i=1; i<nvert; i++){
        e0 = e1 = Enddisc;
        if(i == 1)
            e0 = end0;
        if(i == nvert-1)
            e1 = end1;
        memline(dst, vert[i-1], vert[i], e0, e1, radius, src, addpt(d, vert[i-1]), op);
    }
}
@


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/poly.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<function mempoly>>
@


\subsection*{[[lib_graphics/libmemdraw/read.c]]}

<<function readmemimage>>=
Memimage*
readmemimage(int fd)
{
    char hdr[5*12+1];
    int dy;
    ulong chan;
    uint l, n;
    int m, j;
    int new, miny, maxy;
    Rectangle r;
    uchar *tmp;
    int ldepth, chunk;
    Memimage *i;

    if(readn(fd, hdr, 11) != 11){
        werrstr("readimage: short header");
        return nil;
    }
    if(memcmp(hdr, "compressed\n", 11) == 0)
        return creadmemimage(fd);
    if(readn(fd, hdr+11, 5*12-11) != 5*12-11){
        werrstr("readimage: short header (2)");
        return nil;
    }

    /*
     * distinguish new channel descriptor from old ldepth.
     * channel descriptors have letters as well as numbers,
     * while ldepths are a single digit formatted as %-11d.
     */
    new = 0;
    for(m=0; m<10; m++){
        if(hdr[m] != ' '){
            new = 1;
            break;
        }
    }
    if(hdr[11] != ' '){
        werrstr("readimage: bad format");
        return nil;
    }
    if(new){
        hdr[11] = '\0';
        if((chan = strtochan(hdr)) == 0){
            werrstr("readimage: bad channel string %s", hdr);
            return nil;
        }
    }else{
        ldepth = ((int)hdr[10])-'0';
        if(ldepth<0 || ldepth>3){
            werrstr("readimage: bad ldepth %d", ldepth);
            return nil;
        }
        chan = drawld2chan[ldepth];
    }

    r.min.x = atoi(hdr+1*12);
    r.min.y = atoi(hdr+2*12);
    r.max.x = atoi(hdr+3*12);
    r.max.y = atoi(hdr+4*12);
    if(r.min.x>r.max.x || r.min.y>r.max.y){
        werrstr("readimage: bad rectangle");
        return nil;
    }

    miny = r.min.y;
    maxy = r.max.y;

    l = bytesperline(r, chantodepth(chan));
    i = allocmemimage(r, chan);
    if(i == nil)
        return nil;
    chunk = 32*1024;
    if(chunk < l)
        chunk = l;
    tmp = malloc(chunk);
    if(tmp == nil)
        goto Err;
    while(maxy > miny){
        dy = maxy - miny;
        if(dy*l > chunk)
            dy = chunk/l;
        if(dy <= 0){
            werrstr("readmemimage: image too wide for buffer");
            goto Err;
        }
        n = dy*l;
        m = readn(fd, tmp, n);
        if(m != n){
            werrstr("readmemimage: read count %d not %d: %r", m, n);
   Err:
    freememimage(i);
            free(tmp);
            return nil;
        }
        if(!new)	/* an old image: must flip all the bits */
            for(j=0; j<chunk; j++)
                tmp[j] ^= 0xFF;

        if(loadmemimage(i, Rect(r.min.x, miny, r.max.x, miny+dy), tmp, chunk) <= 0)
            goto Err;
        miny += dy;
    }
    free(tmp);
    return i;
}
@


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/read.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>

<<function readmemimage>>
@


\section{[[lib_graphics/libmemdraw/scripts/]]}

\subsection*{[[lib_graphics/libmemdraw/scripts/mkcmap.c]]}

<<function mkcmap>>=
/*
struct Memcmap
{
    uchar	cmap2rgb[3*256];
    uchar	rgb2cmap[16*16*16];
};
*/

static Memcmap*
mkcmap(void)
{
    static Memcmap def;

    int i, rgb, r, g, b;

    for(i=0; i<256; i++){
        rgb = cmap2rgb(i);
        r = (rgb>>16)&0xff;
        g = (rgb>>8)&0xff;
        b = rgb&0xff;
        def.cmap2rgb[3*i] = r;
        def.cmap2rgb[3*i+1] = g;
        def.cmap2rgb[3*i+2] = b;
    }

    for(r=0; r<16; r++)
    for(g=0; g<16; g++)
    for(b=0; b<16; b++)
        def.rgb2cmap[r*16*16+g*16+b] = rgb2cmap(r*0x11, g*0x11, b*0x11);
    return &def;
}
@

<<function main (lib_graphics/libmemdraw/scripts/mkcmap.c)>>=
void
main(int argc, char **argv)
{
    Memcmap *c;
    int i, j, inferno;

    inferno = 0;
    ARGBEGIN{
    case 'i':
        inferno = 1;
    }ARGEND

    memimageinit();
    c = mkcmap();
    if(!inferno)
        print("#include <u.h>\n#include <libc.h>\n");
    else
        print("#include \"lib9.h\"\n");
    print("#include <draw.h>\n");
    print("#include <memdraw.h>\n\n");
    print("static Memcmap def = {\n");
    print("/* cmap2rgb */ {\n");
    for(i=0; i<sizeof(c->cmap2rgb); ){
        print("\t");
        for(j=0; j<16; j++, i++)
            print("0x%2.2ux,", c->cmap2rgb[i]);
        print("\n");
    }
    print("},\n");
    print("/* rgb2cmap */ {\n");
    for(i=0; i<sizeof(c->rgb2cmap);){
        print("\t");
        for(j=0; j<16; j++, i++)
            print("0x%2.2ux,", c->rgb2cmap[i]);
        print("\n");
    }
    print("}\n");
    print("};\n");
    print("Memcmap *memdefcmap = &def;\n");
    print("void _memmkcmap(void){}\n");
    exits(0);
}
@


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/scripts/mkcmap.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>

<<function mkcmap>>

<<function main (lib_graphics/libmemdraw/scripts/mkcmap.c)>>
@


\section{[[lib_graphics/libmemdraw/]]}

\subsection*{[[lib_graphics/libmemdraw/string.c]]}

<<function memimagestring>>=
Point
memimagestring(Memimage *b, Point p, Memimage *color, Point cp, Memsubfont *f, char *cs)
{
    int w, width;
    uchar *s;
    Rune c;
    Fontchar *i;

    s = (uchar*)cs;
    for(; c=*s; p.x+=width, cp.x+=width){
        width = 0;
        if(c < Runeself)
            s++;
        else{
            w = chartorune(&c, (char*)s);
            if(w == 0){
                s++;
                continue;
            }
            s += w;
        }
        if(c >= f->n)
            continue;
        i = f->info+c;
        width = i->width;
        memdraw(b, Rect(p.x+i->left, p.y+i->top, p.x+i->left+(i[1].x-i[0].x), p.y+i->bottom),
            color, cp, f->bits, Pt(i->x, i->top), SoverD);
    }
    return p;
}
@

<<function memsubfontwidth>>=
Point
memsubfontwidth(Memsubfont *f, char *cs)
{
    Rune c;
    Point p;
    uchar *s;
    Fontchar *i;
    int w, width;

    p = Pt(0, f->height);
    s = (uchar*)cs;
    for(; c=*s; p.x+=width){
        width = 0;
        if(c < Runeself)
            s++;
        else{
            w = chartorune(&c, (char*)s);
            if(w == 0){
                s++;
                continue;
            }
            s += w;
        }
        if(c >= f->n)
            continue;
        i = f->info+c;
        width = i->width;
    }
    return p;
}
@


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/string.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<function memimagestring>>

<<function memsubfontwidth>>
@


\subsection*{[[lib_graphics/libmemdraw/subfont.c]]}

<<function allocmemsubfont>>=
Memsubfont*
allocmemsubfont(char *name, int n, int height, int ascent, Fontchar *info, Memimage *i)
{
    Memsubfont *f;

    f = malloc(sizeof(Memsubfont));
    if(f == 0)
        return 0;
    f->n = n;
    f->height = height;
    f->ascent = ascent;
    f->info = info;
    f->bits = i;
    if(name)
        f->name = strdup(name);
    else
        f->name = 0;
    return f;
}
@

<<function freememsubfont>>=
void
freememsubfont(Memsubfont *f)
{
    if(f == 0)
        return;
    free(f->info);	/* note: f->info must have been malloc'ed! */
    freememimage(f->bits);
    free(f);
}
@


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/subfont.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>

<<function allocmemsubfont>>

<<function freememsubfont>>
@


\section{[[lib_graphics/libmemdraw/tests/]]}

\subsection*{[[lib_graphics/libmemdraw/tests/arctest.c]]}

<<function main (lib_graphics/libmemdraw/tests/arctest.c)>>=
//}


void
main(int argc, char **argv)
{
    Memimage *x;
    Point c = {208,871};
    int a = 441;
    int b = 441;
    int thick = 0;
    Point sp = {0,0};
    int alpha = 51;
    int phi = 3;
    vlong t0, t1;
    int i, n;
    vlong del;

    if (argc != 2) {
        fprint(2, "usage: arctest number\n");
        exits("usage");
    }
    memimageinit();

    x = allocmemimage(Rect(0,0,1000,1000), CMAP8);
    n = atoi(argv[1]);

    t0 = nsec();
    t0 = nsec();
    t0 = nsec();
    t1 = nsec();
    del = t1-t0;
    t0 = nsec();
    for(i=0; i<n; i++)
        memarc(x, c, a, b, thick, memblack, sp, alpha, phi, SoverD);
    t1 = nsec();
    print("%lld %lld\n", t1-t0-del, del);
}
@


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/tests/arctest.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

//static int drawdebug = 0;
//
//void
//rdb(void)
//{
//}
//
//int
//iprint(char *fmt, ...)
//{
//	int n;	
//	va_list va;
//	char buf[1024];
//
//	va_start(va, fmt);
//	n = vseprint(buf, buf+sizeof buf, fmt, va) - buf;
//	va_end(va);
//
//	write(1,buf,n);
//	return 1;
<<function main (lib_graphics/libmemdraw/tests/arctest.c)>>
@


\subsection*{[[lib_graphics/libmemdraw/tests/memdrawtest.c]]}

<<function RGB2K (lib_graphics/libmemdraw/tests/memdrawtest.c)>>=
//#define DBG if(0)
#define RGB2K(r,g,b)	((299*((ulong)(r))+587*((ulong)(g))+114*((ulong)(b)))/1000)
@

<<global drawdebug (lib_graphics/libmemdraw/tests/memdrawtest.c)>>=
//old: used to have static in front, but at some point I got
//some errors (I probably introduced some regressions in 8c of kencc)
int drawdebug=0;
@

<<global seed>>=
static int	seed;
@

<<global niters>>=
static int	niters = 100;
@

<<global dbpp>>=
static int	dbpp;	/* bits per pixel in destination */
@

<<global sbpp>>=
static int	sbpp;	/* bits per pixel in src */
@

<<global mbpp>>=
static int	mbpp;	/* bits per pixel in mask */
@

<<global dpm>>=
static int	dpm;	/* pixel mask at high part of byte, in destination */
@

<<global nbytes>>=
static int	nbytes;	/* in destination */
@

<<global Xrange>>=
static int	Xrange	= 64;
@

<<global Yrange>>=
static int	Yrange	= 8;
@

<<global dst>>=
static Memimage	*dst;
@

<<global src>>=
static Memimage	*src;
@

<<global mask>>=
static Memimage	*mask;
@

<<global stmp>>=
static Memimage	*stmp;
@

<<global mtmp>>=
static Memimage	*mtmp;
@

<<global ones (lib_graphics/libmemdraw/tests/memdrawtest.c)>>=
static Memimage	*ones;
@

<<global dstbits>>=
static uchar	*dstbits;
@

<<global srcbits>>=
static uchar	*srcbits;
@

<<global maskbits>>=
static uchar	*maskbits;
@

<<global savedstbits>>=
static ulong	*savedstbits;
@

<<function main (lib_graphics/libmemdraw/tests/memdrawtest.c)>>=
//}

void
main(int argc, char *argv[])
{
    memimageinit();
    seed = time(0);

    ARGBEGIN{
    case 'x':
        Xrange = atoi(ARGF());
        break;
    case 'y':
        Yrange = atoi(ARGF());
        break;
    case 'n':
        niters = atoi(ARGF());
        break;
    case 's':
        seed = atoi(ARGF());
        break;
    }ARGEND

    dchan = "r8g8b8";
    schan = "r8g8b8";
    mchan = "r8g8b8";
    switch(argc){
    case 3:	mchan = argv[2];
    case 2:	schan = argv[1];
    case 1:	dchan = argv[0];
    case 0:	break;
    default:	goto Usage;
    Usage:
        fprint(2, "usage: dtest [dchan [schan [mchan]]]\n");
        exits("usage");
    }

//	fmtinstall('b', numbconv);	/* binary! */

    fprint(2, "%s -x %d -y %d -s 0x%x %s %s %s\n", argv0, Xrange, Yrange, seed, dchan, schan, mchan);
    srand(seed);

    dst = allocmemimage(Rect(0, 0, Xrange, Yrange), strtochan(dchan));
    src = allocmemimage(Rect(0, 0, Xrange, Yrange), strtochan(schan));
    mask = allocmemimage(Rect(0, 0, Xrange, Yrange), strtochan(mchan));
    stmp = allocmemimage(Rect(0, 0, Xrange, Yrange), strtochan(schan));
    mtmp = allocmemimage(Rect(0, 0, Xrange, Yrange), strtochan(mchan));
    ones = allocmemimage(Rect(0, 0, Xrange, Yrange), strtochan(mchan));
//	print("chan %lux %lux %lux %lux %lux %lux\n", dst->chan, src->chan, mask->chan, stmp->chan, mtmp->chan, ones->chan);
    if(dst==0 || src==0 || mask==0 || mtmp==0 || ones==0) {
    Alloc:
        fprint(2, "dtest: allocation failed: %r\n");
        exits("alloc");
    }
    nbytes = (4*Xrange+4)*Yrange;
    srcbits = malloc(nbytes);
    dstbits = malloc(nbytes);
    maskbits = malloc(nbytes);
    savedstbits = malloc(nbytes);
    if(dstbits==0 || srcbits==0 || maskbits==0 || savedstbits==0)
        goto Alloc;
    dbpp = dst->depth;
    sbpp = src->depth;
    mbpp = mask->depth;
    dpm = 0xFF ^ (0xFF>>dbpp);
    memset(ones->data->bdata, 0xFF, ones->width*sizeof(ulong)*Yrange);


    fprint(2, "dtest: verify single pixel operation\n");
    verifyone();

    fprint(2, "dtest: verify full line non-replicated\n");
    verifyline();

    fprint(2, "dtest: verify full rectangle non-replicated\n");
    verifyrect();

    fprint(2, "dtest: verify full rectangle source replicated\n");
    verifyrectrepl(1, 0);

    fprint(2, "dtest: verify full rectangle mask replicated\n");
    verifyrectrepl(0, 1);

    fprint(2, "dtest: verify full rectangle source and mask replicated\n");
    verifyrectrepl(1, 1);

    exits(0);
}
@

<<function Bprintr5g6b5>>=
/*
 * Dump out an ASCII representation of an image.  The label specifies
 * a list of characters to put at various points in the picture.
 */
static void
Bprintr5g6b5(Biobuf *bio, char*, ulong v)
{
    int r,g,b;
    r = (v>>11)&31;
    g = (v>>5)&63;
    b = v&31;
    Bprint(bio, "%.2x%.2x%.2x", r,g,b);
}
@

<<function Bprintr5g5b5a1>>=
static void
Bprintr5g5b5a1(Biobuf *bio, char*, ulong v)
{
    int r,g,b,a;
    r = (v>>11)&31;
    g = (v>>6)&31;
    b = (v>>1)&31;
    a = v&1;
    Bprint(bio, "%.2x%.2x%.2x%.2x", r,g,b,a);
}
@

<<function dumpimage>>=
void
dumpimage(char *name, Memimage *img, void *vdata, Point labelpt)
{
    Biobuf b;
    uchar *data;
    uchar *p;
    char *arg;
    void (*fmt)(Biobuf*, char*, ulong);
    int npr, x, y, nb, bpp;
    ulong v, mask;
    Rectangle r;

    fmt = nil;
    arg = nil;
    switch(img->depth){
    case 1:
    case 2:
    case 4:
        fmt = (void(*)(Biobuf*,char*,ulong))Bprint;
        arg = "%.1ux";
        break;
    case 8:
        fmt = (void(*)(Biobuf*,char*,ulong))Bprint;
        arg = "%.2ux";
        break;
    case 16:
        arg = nil;
        if(img->chan == RGB16)
            fmt = Bprintr5g6b5;
        else{
            fmt = (void(*)(Biobuf*,char*,ulong))Bprint;
            arg = "%.4ux";
        }
        break;
    case 24:
        fmt = (void(*)(Biobuf*,char*,ulong))Bprint;
        arg = "%.6lux";
        break;
    case 32:
        fmt = (void(*)(Biobuf*,char*,ulong))Bprint;
        arg = "%.8lux";
        break;
    }
    if(fmt == nil){
        fprint(2, "bad format\n");
        abort();
    }

    r  = img->r;
    Binit(&b, 2, OWRITE);
    data = vdata;
    bpp = img->depth;
    Bprint(&b, "%s\t%d\tr %R clipr %R repl %d data %p *%P\n", name, r.min.x, r, img->clipr, (img->flags&Frepl) ? 1 : 0, vdata, labelpt);
    mask = (1ULL<<bpp)-1;
//	for(y=r.min.y; y<r.max.y; y++){
    for(y=0; y<Yrange; y++){
        nb = 0;
        v = 0;
        p = data+(byteaddr(img, Pt(0,y))-(uchar*)img->data->bdata);
        Bprint(&b, "%-4d\t", y);
//		for(x=r.min.x; x<r.max.x; x++){
        for(x=0; x<Xrange; x++){
            if(x==0)
                Bprint(&b, "\t");

            if(x != 0 && (x%8)==0)
                Bprint(&b, " ");

            npr = 0;
            if(x==labelpt.x && y==labelpt.y){
                Bprint(&b, "*");
                npr++;
            }
            if(npr == 0)
                Bprint(&b, " ");

            while(nb < bpp){
                v &= (1<<nb)-1;
                v |= (ulong)(*p++) << nb;
                nb += 8;
            }
            nb -= bpp;
//			print("bpp %d v %.8lux mask %.8lux nb %d\n", bpp, v, mask, nb);
            fmt(&b, arg, (v>>nb)&mask);
        }
        Bprint(&b, "\n");
    }
    Bterm(&b);
}
@

<<function checkone>>=
/*
 * Verify that the destination pixel has the specified value.
 * The value is in the high bits of v, suitably masked, but must
 * be extracted from the destination Memimage.
 */
void
checkone(Point p, Point sp, Point mp)
{
    int delta;
    uchar *dp, *sdp;

    delta = (uchar*)byteaddr(dst, p)-(uchar*)dst->data->bdata;
    dp = (uchar*)dst->data->bdata+delta;
    sdp = (uchar*)savedstbits+delta;

    if(memcmp(dp, sdp, (dst->depth+7)/8) != 0) {
        fprint(2, "dtest: one bad pixel drawing at dst %P from source %P mask %P\n", p, sp, mp);
        fprint(2, " %.2ux %.2ux %.2ux %.2ux should be %.2ux %.2ux %.2ux %.2ux\n",
            dp[0], dp[1], dp[2], dp[3], sdp[0], sdp[1], sdp[2], sdp[3]);
        fprint(2, "addresses dst %p src %p mask %p\n", dp, byteaddr(src, sp), byteaddr(mask, mp));
        dumpimage("src", src, src->data->bdata, sp);
        dumpimage("mask", mask, mask->data->bdata, mp);
        dumpimage("origdst", dst, dstbits, p);
        dumpimage("dst", dst, dst->data->bdata, p);
        dumpimage("gooddst", dst, savedstbits, p);
        abort();
    }
}
@

<<function RECTPTS>>=
/*
 * Verify that the destination line has the same value as the saved line.
 */
#define RECTPTS(r) (r).min.x, (r).min.y, (r).max.x, (r).max.y
@

<<function checkline>>=
void
checkline(Rectangle r, Point sp, Point mp, int y, Memimage *stmp, Memimage *mtmp)
{
    ulong *dp;
    int nb;
    ulong *saved;

    dp = wordaddr(dst, Pt(0, y));
    saved = savedstbits + y*dst->width;
    if(dst->depth < 8)
        nb = Xrange/(8/dst->depth);
    else
        nb = Xrange*(dst->depth/8);
    if(memcmp(dp, saved, nb) != 0){
        fprint(2, "dtest: bad line at y=%d; saved %p dp %p\n", y, saved, dp);
        fprint(2, "draw dst %R src %P mask %P\n", r, sp, mp);
        dumpimage("src", src, src->data->bdata, sp);
        if(stmp) dumpimage("stmp", stmp, stmp->data->bdata, sp);
        dumpimage("mask", mask, mask->data->bdata, mp);
        if(mtmp) dumpimage("mtmp", mtmp, mtmp->data->bdata, mp);
        dumpimage("origdst", dst, dstbits, r.min);
        dumpimage("dst", dst, dst->data->bdata, r.min);
        dumpimage("gooddst", dst, savedstbits, r.min);
        abort();
    }
}
@

<<function fill>>=
/*
 * Fill the bits of an image with random data.
 * The Memimage parameter is used only to make sure
 * the data is well formatted: only ucbits is written.
 */
void
fill(Memimage *img, uchar *ucbits)
{
    int i, x, y;
    ushort *up;
    uchar alpha, r, g, b;
    void *data;

    if((img->flags&Falpha) == 0){
        up = (ushort*)ucbits;
        for(i=0; i<nbytes/2; i++)
            *up++ = lrand() >> 7;
        if(i+i != nbytes)
            *(uchar*)up = lrand() >> 7;
    }else{
        data = img->data->bdata;
        img->data->bdata = ucbits;

        for(x=img->r.min.x; x<img->r.max.x; x++)
        for(y=img->r.min.y; y<img->r.max.y; y++){
            alpha = rand() >> 4;
            r = rand()%(alpha+1);
            g = rand()%(alpha+1);
            b = rand()%(alpha+1);
            putpixel(img, Pt(x,y), rgbatopix(r,g,b,alpha));
        }
        img->data->bdata = data;
    }
        
}
@

<<function verifyonemask>>=
/*
 * Mask is preset; do the rest
 */
void
verifyonemask(void)
{
    Point dp, sp, mp;

    fill(dst, dstbits);
    fill(src, srcbits);
    memmove(dst->data->bdata, dstbits, dst->width*sizeof(ulong)*Yrange);
    memmove(src->data->bdata, srcbits, src->width*sizeof(ulong)*Yrange);
    memmove(mask->data->bdata, maskbits, mask->width*sizeof(ulong)*Yrange);

    dp.x = nrand(Xrange);
    dp.y = nrand(Yrange);

    sp.x = nrand(Xrange);
    sp.y = nrand(Yrange);

    mp.x = nrand(Xrange);
    mp.y = nrand(Yrange);

    drawonepixel(dst, dp, src, sp, mask, mp);
    memmove(mask->data->bdata, maskbits, mask->width*sizeof(ulong)*Yrange);
    memmove(savedstbits, dst->data->bdata, dst->width*sizeof(ulong)*Yrange);
    
    memmove(dst->data->bdata, dstbits, dst->width*sizeof(ulong)*Yrange);
    memimagedraw(dst, Rect(dp.x, dp.y, dp.x+1, dp.y+1), src, sp, mask, mp, SoverD);
    memmove(mask->data->bdata, maskbits, mask->width*sizeof(ulong)*Yrange);

    checkone(dp, sp, mp);
}
@

<<function verifyone>>=
void
verifyone(void)
{
    int i;

    /* mask all zeros */
    memset(maskbits, 0, nbytes);
    for(i=0; i<niters; i++)
        verifyonemask();

    /* mask all ones */
    memset(maskbits, 0xFF, nbytes);
    for(i=0; i<niters; i++)
        verifyonemask();

    /* random mask */
    for(i=0; i<niters; i++){
        fill(mask, maskbits);
        verifyonemask();
    }
}
@

<<function verifylinemask>>=
/*
 * Mask is preset; do the rest
 */
void
verifylinemask(void)
{
    Point sp, mp, tp, up;
    Rectangle dr;
    int x;

    fill(dst, dstbits);
    fill(src, srcbits);
    memmove(dst->data->bdata, dstbits, dst->width*sizeof(ulong)*Yrange);
    memmove(src->data->bdata, srcbits, src->width*sizeof(ulong)*Yrange);
    memmove(mask->data->bdata, maskbits, mask->width*sizeof(ulong)*Yrange);

    dr.min.x = nrand(Xrange-1);
    dr.min.y = nrand(Yrange-1);
    dr.max.x = dr.min.x + 1 + nrand(Xrange-1-dr.min.x);
    dr.max.y = dr.min.y + 1;

    sp.x = nrand(Xrange);
    sp.y = nrand(Yrange);

    mp.x = nrand(Xrange);
    mp.y = nrand(Yrange);

    tp = sp;
    up = mp;
    for(x=dr.min.x; x<dr.max.x && tp.x<Xrange && up.x<Xrange; x++,tp.x++,up.x++)
        memimagedraw(dst, Rect(x, dr.min.y, x+1, dr.min.y+1), src, tp, mask, up, SoverD);
    memmove(savedstbits, dst->data->bdata, dst->width*sizeof(ulong)*Yrange);

    memmove(dst->data->bdata, dstbits, dst->width*sizeof(ulong)*Yrange);

    memimagedraw(dst, dr, src, sp, mask, mp, SoverD);
    checkline(dr, drawrepl(src->r, sp), drawrepl(mask->r, mp), dr.min.y, nil, nil);
}
@

<<function verifyline>>=
void
verifyline(void)
{
    int i;

    /* mask all ones */
    memset(maskbits, 0xFF, nbytes);
    for(i=0; i<niters; i++)
        verifylinemask();

    /* mask all zeros */
    memset(maskbits, 0, nbytes);
    for(i=0; i<niters; i++)
        verifylinemask();

    /* random mask */
    for(i=0; i<niters; i++){
        fill(mask, maskbits);
        verifylinemask();
    }
}
@

<<function verifyrectmask>>=
/*
 * Mask is preset; do the rest
 */
void
verifyrectmask(void)
{
    Point sp, mp, tp, up;
    Rectangle dr;
    int x, y;

    fill(dst, dstbits);
    fill(src, srcbits);
    memmove(dst->data->bdata, dstbits, dst->width*sizeof(ulong)*Yrange);
    memmove(src->data->bdata, srcbits, src->width*sizeof(ulong)*Yrange);
    memmove(mask->data->bdata, maskbits, mask->width*sizeof(ulong)*Yrange);

    dr.min.x = nrand(Xrange-1);
    dr.min.y = nrand(Yrange-1);
    dr.max.x = dr.min.x + 1 + nrand(Xrange-1-dr.min.x);
    dr.max.y = dr.min.y + 1 + nrand(Yrange-1-dr.min.y);

    sp.x = nrand(Xrange);
    sp.y = nrand(Yrange);

    mp.x = nrand(Xrange);
    mp.y = nrand(Yrange);

    tp = sp;
    up = mp;
    for(y=dr.min.y; y<dr.max.y && tp.y<Yrange && up.y<Yrange; y++,tp.y++,up.y++){
        for(x=dr.min.x; x<dr.max.x && tp.x<Xrange && up.x<Xrange; x++,tp.x++,up.x++)
            memimagedraw(dst, Rect(x, y, x+1, y+1), src, tp, mask, up, SoverD);
        tp.x = sp.x;
        up.x = mp.x;
    }
    memmove(savedstbits, dst->data->bdata, dst->width*sizeof(ulong)*Yrange);

    memmove(dst->data->bdata, dstbits, dst->width*sizeof(ulong)*Yrange);

    memimagedraw(dst, dr, src, sp, mask, mp, SoverD);
    for(y=0; y<Yrange; y++)
        checkline(dr, drawrepl(src->r, sp), drawrepl(mask->r, mp), y, nil, nil);
}
@

<<function verifyrect>>=
void
verifyrect(void)
{
    int i;

    /* mask all zeros */
    memset(maskbits, 0, nbytes);
    for(i=0; i<niters; i++)
        verifyrectmask();

    /* mask all ones */
    memset(maskbits, 0xFF, nbytes);
    for(i=0; i<niters; i++)
        verifyrectmask();

    /* random mask */
    for(i=0; i<niters; i++){
        fill(mask, maskbits);
        verifyrectmask();
    }
}
@

<<function randrect>>=
Rectangle
randrect(void)
{
    Rectangle r;

    r.min.x = nrand(Xrange-1);
    r.min.y = nrand(Yrange-1);
    r.max.x = r.min.x + 1 + nrand(Xrange-1-r.min.x);
    r.max.y = r.min.y + 1 + nrand(Yrange-1-r.min.y);
    return r;
}
@

<<function tilexy>>=
/*
 * Return coordinate corresponding to x withing range [minx, maxx)
 */
int
tilexy(int minx, int maxx, int x)
{
    int sx;

    sx = (x-minx) % (maxx-minx);
    if(sx < 0)
        sx += maxx-minx;
    return sx+minx;
}
@

<<function replicate>>=
void
replicate(Memimage *i, Memimage *tmp)
{
    Rectangle r, r1;
    int x, y, nb;

    /* choose the replication window (i->r) */
    r.min.x = nrand(Xrange-1);
    r.min.y = nrand(Yrange-1);
    /* make it trivial more often than pure chance allows */
    switch(lrand()&0){
    case 1:
        r.max.x = r.min.x + 2;
        r.max.y = r.min.y + 2;
        if(r.max.x < Xrange && r.max.y < Yrange)
            break;
        /* fall through */
    case 0:
        r.max.x = r.min.x + 1;
        r.max.y = r.min.y + 1;
        break;
    default:
        if(r.min.x+3 >= Xrange)
            r.max.x = Xrange;
        else
            r.max.x = r.min.x+3 + nrand(Xrange-(r.min.x+3));

        if(r.min.y+3 >= Yrange)
            r.max.y = Yrange;
        else
            r.max.y = r.min.y+3 + nrand(Yrange-(r.min.y+3));
    }
    assert(r.min.x >= 0);	
    assert(r.max.x <= Xrange);
    assert(r.min.y >= 0);
    assert(r.max.y <= Yrange);
    /* copy from i to tmp so we have just the replicated bits */
    nb = tmp->width*sizeof(ulong)*Yrange;
    memset(tmp->data->bdata, 0, nb);
    memimagedraw(tmp, r, i, r.min, ones, r.min, SoverD);
    memmove(i->data->bdata, tmp->data->bdata, nb);
    /* i is now a non-replicated instance of the replication */
    /* replicate it by hand through tmp */
    memset(tmp->data->bdata, 0, nb);
    x = -(tilexy(r.min.x, r.max.x, 0)-r.min.x);
    for(; x<Xrange; x+=Dx(r)){
        y = -(tilexy(r.min.y, r.max.y, 0)-r.min.y);
        for(; y<Yrange; y+=Dy(r)){
            /* set r1 to instance of tile by translation */
            r1.min.x = x;
            r1.min.y = y;
            r1.max.x = r1.min.x+Dx(r);
            r1.max.y = r1.min.y+Dy(r);
            memimagedraw(tmp, r1, i, r.min, ones, r.min, SoverD);
        }
    }
    i->flags |= Frepl;
    i->r = r;
    i->clipr = randrect();
//	fprint(2, "replicate [[%d %d] [%d %d]] [[%d %d][%d %d]]\n", r.min.x, r.min.y, r.max.x, r.max.y,
//		i->clipr.min.x, i->clipr.min.y, i->clipr.max.x, i->clipr.max.y);
    tmp->clipr = i->clipr;
}
@

<<function verifyrectmaskrepl>>=
/*
 * Mask is preset; do the rest
 */
void
verifyrectmaskrepl(int srcrepl, int maskrepl)
{
    Point sp, mp, tp, up;
    Rectangle dr;
    int x, y;
    Memimage *s, *m;

//	print("verfrect %d %d\n", srcrepl, maskrepl);
    src->flags &= ~Frepl;
    src->r = Rect(0, 0, Xrange, Yrange);
    src->clipr = src->r;
    stmp->flags &= ~Frepl;
    stmp->r = Rect(0, 0, Xrange, Yrange);
    stmp->clipr = src->r;
    mask->flags &= ~Frepl;
    mask->r = Rect(0, 0, Xrange, Yrange);
    mask->clipr = mask->r;
    mtmp->flags &= ~Frepl;
    mtmp->r = Rect(0, 0, Xrange, Yrange);
    mtmp->clipr = mask->r;

    fill(dst, dstbits);
    fill(src, srcbits);

    memmove(dst->data->bdata, dstbits, dst->width*sizeof(ulong)*Yrange);
    memmove(src->data->bdata, srcbits, src->width*sizeof(ulong)*Yrange);
    memmove(mask->data->bdata, maskbits, mask->width*sizeof(ulong)*Yrange);

    if(srcrepl){
        replicate(src, stmp);
        s = stmp;
    }else
        s = src;
    if(maskrepl){
        replicate(mask, mtmp);
        m = mtmp;
    }else
        m = mask;

    dr = randrect();

    sp.x = nrand(Xrange);
    sp.y = nrand(Yrange);

    mp.x = nrand(Xrange);
    mp.y = nrand(Yrange);

    //DBG	print("smalldraws\n");
    for(tp.y=sp.y,up.y=mp.y,y=dr.min.y; y<dr.max.y && tp.y<Yrange && up.y<Yrange; y++,tp.y++,up.y++)
        for(tp.x=sp.x,up.x=mp.x,x=dr.min.x; x<dr.max.x && tp.x<Xrange && up.x<Xrange; x++,tp.x++,up.x++)
            memimagedraw(dst, Rect(x, y, x+1, y+1), s, tp, m, up, SoverD);
    memmove(savedstbits, dst->data->bdata, dst->width*sizeof(ulong)*Yrange);

    memmove(dst->data->bdata, dstbits, dst->width*sizeof(ulong)*Yrange);

    //DBG	print("bigdraw\n");
    memimagedraw(dst, dr, src, sp, mask, mp, SoverD);
    for(y=0; y<Yrange; y++)
        checkline(dr, drawrepl(src->r, sp), drawrepl(mask->r, mp), y, srcrepl?stmp:nil, maskrepl?mtmp:nil);
}
@

<<function verifyrectrepl>>=
void
verifyrectrepl(int srcrepl, int maskrepl)
{
    int i;

    /* mask all ones */
    memset(maskbits, 0xFF, nbytes);
    for(i=0; i<niters; i++)
        verifyrectmaskrepl(srcrepl, maskrepl);

    /* mask all zeros */
    memset(maskbits, 0, nbytes);
    for(i=0; i<niters; i++)
        verifyrectmaskrepl(srcrepl, maskrepl);

    /* random mask */
    for(i=0; i<niters; i++){
        fill(mask, maskbits);
        verifyrectmaskrepl(srcrepl, maskrepl);
    }
}
@

<<function replbits>>=
/*
 * Convert v, which is nhave bits wide, into its nwant bits wide equivalent.
 * Replicates to widen the value, truncates to narrow it.
 */
ulong
replbits(ulong v, int nhave, int nwant)
{
    v &= (1<<nhave)-1;
    for(; nhave<nwant; nhave*=2)
        v |= v<<nhave;
    v >>= (nhave-nwant);
    return v & ((1<<nwant)-1);
}
@

<<function pixtorgba>>=
/*
 * Decode a pixel into the uchar* values.
 */
void
pixtorgba(ulong v, uchar *r, uchar *g, uchar *b, uchar *a)
{
    *a = v>>24;
    *r = v>>16;
    *g = v>>8;
    *b = v;
}
@

<<function rgbatopix>>=
/*
 * Convert uchar channels into ulong pixel.
 */
ulong
rgbatopix(uchar r, uchar g, uchar b, uchar a)
{
    return (a<<24)|(r<<16)|(g<<8)|b;
}
@

<<function getpixel>>=
/*
 * Retrieve the pixel value at pt in the image.
 */
ulong
getpixel(Memimage *img, Point pt)
{
    uchar r, g, b, a, *p;
    int nbits, npack, bpp;
    ulong v, c, rbits, bits;

    r = g = b = 0;
    a = ~0;	/* default alpha is full */

    p = byteaddr(img, pt);
    v = p[0]|(p[1]<<8)|(p[2]<<16)|(p[3]<<24);
    bpp = img->depth;
    if(bpp<8){
        /*
         * Sub-byte greyscale pixels.
         *
         * We want to throw away the top pt.x%npack pixels and then use the next bpp bits
         * in the bottom byte of v.  This madness is due to having big endian bits
         * but little endian bytes.
         */
        npack = 8/bpp;
        v >>= 8 - bpp*(pt.x%npack+1);
        v &= (1<<bpp)-1;
        r = g = b = replbits(v, bpp, 8);
    }else{
        /*
         * General case.  We need to parse the channel descriptor and do what it says.
         * In all channels but the color map, we replicate to 8 bits because that's the
         * precision that all calculations are done at.
         *
         * In the case of the color map, we leave the bits alone, in case a color map
         * with less than 8 bits of index is used.  This is currently disallowed, so it's
         * sort of silly.
         */

        for(c=img->chan; c; c>>=8){
            nbits = NBITS(c);
            bits = v & ((1<<nbits)-1);
            rbits = replbits(bits, nbits, 8);
            v >>= nbits;
            switch(TYPE(c)){
            case CRed:
                r = rbits;
                break;
            case CGreen:
                g = rbits;
                break;
            case CBlue:
                b = rbits;
                break;
            case CGrey:
                r = g = b = rbits;
                break;
            case CAlpha:
                a = rbits;
                break;
            case CMap:
                p = img->cmap->cmap2rgb + 3*bits;
                r = p[0];
                g = p[1];
                b = p[2];
                break;
            case CIgnore:
                break;
            default:
                fprint(2, "unknown channel type %lud\n", TYPE(c));
                abort();
            }
        }
    }
    return rgbatopix(r, g, b, a);
}
@

<<function getgrey>>=
/*
 * Return the greyscale equivalent of a pixel.
 */
uchar
getgrey(Memimage *img, Point pt)
{
    uchar r, g, b, a;
    pixtorgba(getpixel(img, pt), &r, &g, &b, &a);
    return RGB2K(r, g, b);
}
@

<<function getmask>>=
/*
 * Return the value at pt in image, if image is interpreted
 * as a mask.  This means the alpha channel if present, else
 * the greyscale or its computed equivalent.
 */
uchar
getmask(Memimage *img, Point pt)
{
    if(img->flags&Falpha)
        return getpixel(img, pt)>>24;
    else
        return getgrey(img, pt);
}
@

<<function putpixel>>=
/*
 * Write a pixel to img at point pt.
 * 
 * We do this by reading a 32-bit little endian
 * value from p and then writing it back
 * after tweaking the appropriate bits.  Because
 * the data is little endian, we don't have to worry
 * about what the actual depth is, as long as it is
 * less than 32 bits.
 */
void
putpixel(Memimage *img, Point pt, ulong nv)
{
    uchar r, g, b, a, *p, *q;
    ulong c, mask, bits, v;
    int bpp, sh, npack, nbits;

    pixtorgba(nv, &r, &g, &b, &a);

    p = byteaddr(img, pt);
    v = p[0]|(p[1]<<8)|(p[2]<<16)|(p[3]<<24);
    bpp = img->depth;
    //DBG print("v %.8lux...", v);
    if(bpp < 8){
        /*
         * Sub-byte greyscale pixels.  We need to skip the leftmost pt.x%npack pixels,
         * which is equivalent to skipping the rightmost npack - pt.x%npack - 1 pixels.
         */	
        npack = 8/bpp;
        sh = bpp*(npack - pt.x%npack - 1);
        bits = RGB2K(r,g,b);
        //DBG print("repl %lux 8 %d = %lux...", bits, bpp, replbits(bits, 8, bpp));
        bits = replbits(bits, 8, bpp);
        mask = (1<<bpp)-1;
        //DBG print("bits %lux mask %lux sh %d...", bits, mask, sh);
        mask <<= sh;
        bits <<= sh;
        //DBG print("(%lux & %lux) | (%lux & %lux)", v, ~mask, bits, mask);
        v = (v & ~mask) | (bits & mask);
    } else {
        /*
         * General case.  We need to parse the channel descriptor again.
         */
        sh = 0;
        for(c=img->chan; c; c>>=8){
            nbits = NBITS(c);
            switch(TYPE(c)){
            case CRed:
                bits = r;
                break;
            case CGreen:
                bits = g;
                break;
            case CBlue:
                bits = b;
                break;
            case CGrey:
                bits = RGB2K(r, g, b);
                break;
            case CAlpha:
                bits = a;
                break;
            case CIgnore:
                bits = 0;
                break;
            case CMap:
                q = img->cmap->rgb2cmap;
                bits = q[(r>>4)*16*16+(g>>4)*16+(b>>4)];
                break;
            default:
                SET(bits);
                fprint(2, "unknown channel type %lud\n", TYPE(c));
                abort();
            }

            //DBG print("repl %lux 8 %d = %lux...", bits, nbits, replbits(bits, 8, nbits));
            if(TYPE(c) != CMap)
                bits = replbits(bits, 8, nbits);
            mask = (1<<nbits)-1;
            //DBG print("bits %lux mask %lux sh %d...", bits, mask, sh);
            bits <<= sh;
            mask <<= sh;
            v = (v & ~mask) | (bits & mask);
            sh += nbits;
        }
    }
    //DBG print("v %.8lux\n", v);
    p[0] = v;
    p[1] = v>>8;
    p[2] = v>>16;
    p[3] = v>>24;	
}
@

<<function drawonepixel>>=
//#define DBG if(0)

void
drawonepixel(Memimage *dst, Point dp, Memimage *src, Point sp, Memimage *mask, Point mp)
{
    uchar m, M, sr, sg, sb, sa, sk, dr, dg, db, da, dk;

    pixtorgba(getpixel(dst, dp), &dr, &dg, &db, &da);
    pixtorgba(getpixel(src, sp), &sr, &sg, &sb, &sa);
    m = getmask(mask, mp);
    M = 255-(sa*m)/255;

    //DBG print("dst %x %x %x %x src %x %x %x %x m %x = ", dr,dg,db,da, sr,sg,sb,sa, m);
    if(dst->flags&Fgrey){
        /*
         * We need to do the conversion to grey before the alpha calculation
         * because the draw operator does this, and we need to be operating
         * at the same precision so we get exactly the same answers.
         */
        sk = RGB2K(sr, sg, sb);
        dk = RGB2K(dr, dg, db);
        dk = (sk*m + dk*M)/255;
        dr = dg = db = dk;
        da = (sa*m + da*M)/255;
    }else{
        /*
         * True color alpha calculation treats all channels (including alpha)
         * the same.  It might have been nice to use an array, but oh well.
         */
        dr = (sr*m + dr*M)/255;
        dg = (sg*m + dg*M)/255;
        db = (sb*m + db*M)/255;
        da = (sa*m + da*M)/255;
    }

    //DBG print("%x %x %x %x\n", dr,dg,db,da);
    putpixel(dst, dp, rgbatopix(dr, dg, db, da));
}
@


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/tests/memdrawtest.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <draw.h>
#include <memdraw.h>

<<function RGB2K (lib_graphics/libmemdraw/tests/memdrawtest.c)>>

/*
 * This program tests the 'memimagedraw' primitive stochastically.
 * It tests the combination aspects of it thoroughly, but since the
 * three images it uses are disjoint, it makes no check of the
 * correct behavior when images overlap.  That is, however, much
 * easier to get right and to test.
 */

void	drawonepixel(Memimage*, Point, Memimage*, Point, Memimage*, Point);
void	verifyone(void);
void	verifyline(void);
void	verifyrect(void);
void	verifyrectrepl(int, int);
void putpixel(Memimage *img, Point pt, ulong nv);
ulong rgbatopix(uchar, uchar, uchar, uchar);

static char *dchan, *schan, *mchan;
<<global drawdebug (lib_graphics/libmemdraw/tests/memdrawtest.c)>>
<<global seed>>
<<global niters>>
<<global dbpp>>
<<global sbpp>>
<<global mbpp>>
<<global dpm>>
<<global nbytes>>

<<global Xrange>>
<<global Yrange>>

<<global dst>>
<<global src>>
<<global mask>>
<<global stmp>>
<<global mtmp>>
<<global ones (lib_graphics/libmemdraw/tests/memdrawtest.c)>>
<<global dstbits>>
<<global srcbits>>
<<global maskbits>>
<<global savedstbits>>

//void
//rdb(void)
//{
//}
//
//int
//iprint(char *fmt, ...)
//{
//	int n;	
//	va_list va;
//	char buf[1024];
//
//	va_start(va, fmt);
//	n = vseprint(buf, buf+sizeof buf, fmt, va) - buf;
//	va_end(va);
//
//	write(1,buf,n);
//	return 1;
<<function main (lib_graphics/libmemdraw/tests/memdrawtest.c)>>

<<function Bprintr5g6b5>>

<<function Bprintr5g5b5a1>>

<<function dumpimage>>

<<function checkone>>

<<function RECTPTS>>
<<function checkline>>

<<function fill>>

<<function verifyonemask>>

<<function verifyone>>

<<function verifylinemask>>

<<function verifyline>>

<<function verifyrectmask>>

<<function verifyrect>>

<<function randrect>>

<<function tilexy>>

<<function replicate>>

<<function verifyrectmaskrepl>>

<<function verifyrectrepl>>

/*
 * Trivial draw implementation.
 * Color values are passed around as ulongs containing Î±Î±RRGGBB
 */

<<function replbits>>

<<function pixtorgba>>

<<function rgbatopix>>

<<function getpixel>>

<<function getgrey>>

<<function getmask>>
//#undef DBG
//#define DBG if(0)

<<function putpixel>>
//#undef DBG
<<function drawonepixel>>
@


\section{[[lib_graphics/libmemdraw/]]}

\subsection*{[[lib_graphics/libmemdraw/unload.c]]}

<<function unloadmemimage>>=
int
unloadmemimage(Memimage *i, Rectangle r, uchar *data, int ndata)
{
    int y, l;
    uchar *q;

    if(!rectinrect(r, i->r))
        return -1;
    l = bytesperline(r, i->depth);
    if(ndata < l*Dy(r))
        return -1;
    ndata = l*Dy(r);
    q = byteaddr(i, r.min);
    for(y=r.min.y; y<r.max.y; y++){
        memmove(data, q, l);
        q += i->width*sizeof(ulong);
        data += l;
    }
    return ndata;
}
@


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/unload.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>

<<function unloadmemimage>>
@


\subsection*{[[lib_graphics/libmemdraw/write.c]]}

<<constant CHUNK>>=
#define	CHUNK	8000
@

<<constant HSHIFT (lib_graphics/libmemdraw/write.c)>>=
#define	HSHIFT	3	/* HSHIFT==5 runs slightly faster, but hash table is 64x bigger */
@

<<constant NHASH (lib_graphics/libmemdraw/write.c)>>=
#define	NHASH	(1<<(HSHIFT*NMATCH))
@

<<constant HMASK (lib_graphics/libmemdraw/write.c)>>=
#define	HMASK	(NHASH-1)
@

<<function hupdate (lib_graphics/libmemdraw/write.c)>>=
#define	hupdate(h, c)	((((h)<<HSHIFT)^(c))&HMASK)
@

<<struct Hlist (lib_graphics/libmemdraw/write.c)>>=
struct Hlist{
    uchar *s;
    Hlist *next, *prev;
};
@

<<function writememimage>>=
int
writememimage(int fd, Memimage *i)
{
    uchar *outbuf, *outp, *eout;		/* encoded data, pointer, end */
    uchar *loutp;				/* start of encoded line */
    Hlist *hash;				/* heads of hash chains of past strings */
    Hlist *chain, *hp;			/* hash chain members, pointer */
    Hlist *cp;				/* next Hlist to fall out of window */
    int h;					/* hash value */
    uchar *line, *eline;			/* input line, end pointer */
    uchar *data, *edata;			/* input buffer, end pointer */
    ulong n;				/* length of input buffer */
    ulong nb;				/* # of bytes returned by unloadimage */
    int bpl;				/* input line length */
    int offs, runlen;			/* offset, length of consumed data */
    uchar dumpbuf[NDUMP];			/* dump accumulator */
    int ndump;				/* length of dump accumulator */
    int miny, dy;				/* y values while unloading input */
    int ncblock;				/* size of compressed blocks */
    Rectangle r;
    uchar *p, *q, *s, *es, *t;
    char hdr[11+5*12+1];
    char cbuf[20];

    r = i->r;
    bpl = bytesperline(r, i->depth);
    n = Dy(r)*bpl;
    data = malloc(n);
    ncblock = _compblocksize(r, i->depth);
    outbuf = malloc(ncblock);
    hash = malloc(NHASH*sizeof(Hlist));
    chain = malloc(NMEM*sizeof(Hlist));
    if(data == 0 || outbuf == 0 || hash == 0 || chain == 0){
    ErrOut:
        free(data);
        free(outbuf);
        free(hash);
        free(chain);
        return -1;
    }
    for(miny = r.min.y; miny != r.max.y; miny += dy){
        dy = r.max.y-miny;
        if(dy*bpl > CHUNK)
            dy = CHUNK/bpl;
        nb = unloadmemimage(i, Rect(r.min.x, miny, r.max.x, miny+dy),
            data+(miny-r.min.y)*bpl, dy*bpl);
        if(nb != dy*bpl)
            goto ErrOut;
    }
    sprint(hdr, "compressed\n%11s %11d %11d %11d %11d ",
        chantostr(cbuf, i->chan), r.min.x, r.min.y, r.max.x, r.max.y);
    if(write(fd, hdr, 11+5*12) != 11+5*12)
        goto ErrOut;
    edata = data+n;
    eout = outbuf+ncblock;
    line = data;
    r.max.y = r.min.y;
    while(line != edata){
        memset(hash, 0, NHASH*sizeof(Hlist));
        memset(chain, 0, NMEM*sizeof(Hlist));
        cp = chain;
        h = 0;
        outp = outbuf;
        for(n = 0; n != NMATCH; n++)
            h = hupdate(h, line[n]);
        loutp = outbuf;
        while(line != edata){
            ndump = 0;
            eline = line+bpl;
            for(p = line; p != eline; ){
                if(eline-p < NRUN)
                    es = eline;
                else
                    es = p+NRUN;
                q = 0;
                runlen = 0;
                for(hp = hash[h].next; hp; hp = hp->next){
                    s = p + runlen;
                    if(s >= es)
                        continue;
                    t = hp->s + runlen;
                    for(; s >= p; s--)
                        if(*s != *t--)
                            goto matchloop;
                    t += runlen+2;
                    s += runlen+2;
                    for(; s < es; s++)
                        if(*s != *t++)
                            break;
                    n = s-p;
                    if(n > runlen){
                        runlen = n;
                        q = hp->s;
                        if(n == NRUN)
                            break;
                    }
            matchloop: ;
                }
                if(runlen < NMATCH){
                    if(ndump == NDUMP){
                        if(eout-outp < ndump+1)
                            goto Bfull;
                        *outp++ = ndump-1+128;
                        memmove(outp, dumpbuf, ndump);
                        outp += ndump;
                        ndump = 0;
                    }
                    dumpbuf[ndump++] = *p;
                    runlen = 1;
                }
                else{
                    if(ndump != 0){
                        if(eout-outp < ndump+1)
                            goto Bfull;
                        *outp++ = ndump-1+128;
                        memmove(outp, dumpbuf, ndump);
                        outp += ndump;
                        ndump = 0;
                    }
                    offs = p-q-1;
                    if(eout-outp < 2)
                        goto Bfull;
                    *outp++ = ((runlen-NMATCH)<<2) + (offs>>8);
                    *outp++ = offs&255;
                }
                for(q = p+runlen; p != q; p++){
                    if(cp->prev)
                        cp->prev->next = 0;
                    cp->next = hash[h].next;
                    cp->prev = &hash[h];
                    if(cp->next)
                        cp->next->prev = cp;
                    cp->prev->next = cp;
                    cp->s = p;
                    if(++cp == &chain[NMEM])
                        cp = chain;
                    if(edata-p > NMATCH)
                        h = hupdate(h, p[NMATCH]);
                }
            }
            if(ndump != 0){
                if(eout-outp < ndump+1)
                    goto Bfull;
                *outp++ = ndump-1+128;
                memmove(outp, dumpbuf, ndump);
                outp += ndump;
            }
            line = eline;
            loutp = outp;
            r.max.y++;
        }
    Bfull:
        if(loutp == outbuf)
            goto ErrOut;
        n = loutp-outbuf;
        sprint(hdr, "%11d %11ld ", r.max.y, n);
        write(fd, hdr, 2*12);
        write(fd, outbuf, n);
        r.min.y = r.max.y;
    }
    free(data);
    free(outbuf);
    free(hash);
    free(chain);
    return 0;
}
@


%-------------------------------------------------------------

<<lib_graphics/libmemdraw/write.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>

<<constant CHUNK>>

<<constant HSHIFT (lib_graphics/libmemdraw/write.c)>>
<<constant NHASH (lib_graphics/libmemdraw/write.c)>>
<<constant HMASK (lib_graphics/libmemdraw/write.c)>>
<<function hupdate (lib_graphics/libmemdraw/write.c)>>
typedef struct Hlist Hlist;
<<struct Hlist (lib_graphics/libmemdraw/write.c)>>

<<function writememimage>>
@


\section{[[lib_graphics/libmemlayer/]]}

\subsection*{[[lib_graphics/libmemlayer/draw.c]]}

<<struct Draw>>=
struct Draw
{
    Point	deltas;
    Point	deltam;
    Memlayer		*dstlayer;
    Memimage	*src;
    Memimage	*mask;
    int	op;
};
@

<<function ldrawop>>=
static
void
ldrawop(Memimage *dst, Rectangle screenr, Rectangle clipr, void *etc, int insave)
{
    struct Draw *d;
    Point p0, p1;
    Rectangle oclipr, srcr, r, mr;
    int ok;

    d = etc;
    if(insave && d->dstlayer->save==nil)
        return;

    p0 = addpt(screenr.min, d->deltas);
    p1 = addpt(screenr.min, d->deltam);

    if(insave){
        r = rectsubpt(screenr, d->dstlayer->delta);
        clipr = rectsubpt(clipr, d->dstlayer->delta);
    }else
        r = screenr;

    /* now in logical coordinates */

    /* clipr may have narrowed what we should draw on, so clip if necessary */
    if(!rectinrect(r, clipr)){
        oclipr = dst->clipr;
        dst->clipr = clipr;
        ok = drawclip(dst, &r, d->src, &p0, d->mask, &p1, &srcr, &mr);
        dst->clipr = oclipr;
        if(!ok)
            return;
    }
    memdraw(dst, r, d->src, p0, d->mask, p1, d->op);
}
@

<<function memdraw>>=
void
memdraw(Memimage *dst, Rectangle r, Memimage *src, Point p0, Memimage *mask, Point p1, int op)
{
    struct Draw d;
    Rectangle srcr, tr, mr;
    Memlayer *dl, *sl;

    if(drawdebug)
        iprint("memdraw %p %R %p %P %p %P\n", dst, r, src, p0, mask, p1);

    if(mask == nil)
        mask = memopaque;

    if(mask->layer){
if(drawdebug)	iprint("mask->layer != nil\n");
        return;	/* too hard, at least for now */
    }

    Top:
    if(dst->layer==nil && src->layer==nil){
        memimagedraw(dst, r, src, p0, mask, p1, op);
        return;
    }

    if(drawclip(dst, &r, src, &p0, mask, &p1, &srcr, &mr) == 0){
if(drawdebug)	iprint("drawclip dstcr %R srccr %R maskcr %R\n", dst->clipr, src->clipr, mask->clipr);
        return;
    }

    /*
   * Convert to screen coordinates.
     */
    dl = dst->layer;
    if(dl != nil){
        r.min.x += dl->delta.x;
        r.min.y += dl->delta.y;
        r.max.x += dl->delta.x;
        r.max.y += dl->delta.y;
    }
    Clearlayer:
    if(dl!=nil && dl->clear){
        if(src == dst){
            p0.x += dl->delta.x;
            p0.y += dl->delta.y;
            src = dl->screen->image;
        }
        dst = dl->screen->image;
        goto Top;
    }

    sl = src->layer;
    if(sl != nil){
        p0.x += sl->delta.x;
        p0.y += sl->delta.y;
        srcr.min.x += sl->delta.x;
        srcr.min.y += sl->delta.y;
        srcr.max.x += sl->delta.x;
        srcr.max.y += sl->delta.y;
    }

    /*
     * Now everything is in screen coordinates.
     * mask is an image.  dst and src are images or obscured layers.
     */

    /*
     * if dst and src are the same layer, just draw in save area and expose.
     */
    if(dl!=nil && dst==src){
        if(dl->save == nil)
            return;	/* refresh function makes this case unworkable */
        if(rectXrect(r, srcr)){
            tr = r;
            if(srcr.min.x < tr.min.x){
                p1.x += tr.min.x - srcr.min.x;
                tr.min.x = srcr.min.x;
            }
            if(srcr.min.y < tr.min.y){
                p1.y += tr.min.x - srcr.min.x;
                tr.min.y = srcr.min.y;
            }
            if(srcr.max.x > tr.max.x)
                tr.max.x = srcr.max.x;
            if(srcr.max.y > tr.max.y)
                tr.max.y = srcr.max.y;
            memlhide(dst, tr);
        }else{
            memlhide(dst, r);
            memlhide(dst, srcr);
        }
        memdraw(dl->save, rectsubpt(r, dl->delta), dl->save,
            subpt(srcr.min, src->layer->delta), mask, p1, op);
        memlexpose(dst, r);
        return;
    }

    if(sl){
        if(sl->clear){
            src = sl->screen->image;
            if(dl != nil){
                r.min.x -= dl->delta.x;
                r.min.y -= dl->delta.y;
                r.max.x -= dl->delta.x;
                r.max.y -= dl->delta.y;
            }
            goto Top;
        }
        /* relatively rare case; use save area */
        if(sl->save == nil)
            return;	/* refresh function makes this case unworkable */
        memlhide(src, srcr);
        /* convert back to logical coordinates */
        p0.x -= sl->delta.x;
        p0.y -= sl->delta.y;
        srcr.min.x -= sl->delta.x;
        srcr.min.y -= sl->delta.y;
        srcr.max.x -= sl->delta.x;
        srcr.max.y -= sl->delta.y;
        src = src->layer->save;
    }

    /*
     * src is now an image.  dst may be an image or a clear layer
     */
    if(dst->layer==nil)
        goto Top;
    if(dst->layer->clear)
        goto Clearlayer;

    /*
     * dst is an obscured layer
     */
    d.deltas = subpt(p0, r.min);
    d.deltam = subpt(p1, r.min);
    d.dstlayer = dl;
    d.src = src;
    d.op = op;
    d.mask = mask;
    _memlayerop(ldrawop, dst, r, r, &d);
}
@


%-------------------------------------------------------------

<<lib_graphics/libmemlayer/draw.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<struct Draw>>

<<function ldrawop>>

<<function memdraw>>
@


\subsection*{[[lib_graphics/libmemlayer/lalloc.c]]}

<<function memlalloc>>=
Memimage*
memlalloc(Memscreen *s, Rectangle screenr, Refreshfn refreshfn, void *refreshptr, ulong val)
{
    Memlayer *l;
    Memimage *n;
    static Memimage *paint;

    if(paint == nil){
        paint = allocmemimage(Rect(0,0,1,1), RGBA32);
        if(paint == nil)
            return nil;
        paint->flags |= Frepl;
        paint->clipr = Rect(-0x3FFFFFF, -0x3FFFFFF, 0x3FFFFFF, 0x3FFFFFF);
    }

    n = allocmemimaged(screenr, s->image->chan, s->image->data);
    if(n == nil)
        return nil;
    l = malloc(sizeof(Memlayer));
    if(l == nil){
        free(n);
        return nil;
    }

    l->screen = s;
    if(refreshfn)
        l->save = nil;
    else{
        l->save = allocmemimage(screenr, s->image->chan);
        if(l->save == nil){
            free(l);
            free(n);
            return nil;
        }
        /* allocmemimage doesn't initialize memory; this paints save area */
        if(val != DNofill)
            memfillcolor(l->save, val);
    }
    l->refreshfn = refreshfn;
    l->refreshptr = nil;	/* don't set it until we're done */
    l->screenr = screenr;
    l->delta = Pt(0,0);

    n->data->ref++;
    n->zero = s->image->zero;
    n->width = s->image->width;
    n->layer = l;

    /* start with new window behind all existing ones */
    l->front = s->rearmost;
    l->rear = nil;
    if(s->rearmost)
        s->rearmost->layer->rear = n;
    s->rearmost = n;
    if(s->frontmost == nil)
        s->frontmost = n;
    l->clear = 0;

    /* now pull new window to front */
    _memltofrontfill(n, val != DNofill);
    l->refreshptr = refreshptr;

    /*
     * paint with requested color; previously exposed areas are already right
     * if this window has backing store, but just painting the whole thing is simplest.
     */
    if(val != DNofill){
        memsetchan(paint, n->chan);
        memfillcolor(paint, val);
        memdraw(n, n->r, paint, n->r.min, nil, n->r.min, S);
    }
    return n;
}
@


%-------------------------------------------------------------

<<lib_graphics/libmemlayer/lalloc.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<function memlalloc>>
@


\subsection*{[[lib_graphics/libmemlayer/layerop.c]]}

<<function RECUR>>=
#define	RECUR(a,b,c,d)	_layerop(fn, i, Rect(a.x, b.y, c.x, d.y), clipr, etc, front->layer->rear);
@

<<function _layerop>>=
static void
_layerop(
    void (*fn)(Memimage*, Rectangle, Rectangle, void*, int),
    Memimage *i,
    Rectangle r,
    Rectangle clipr,
    void *etc,
    Memimage *front)
{
    Rectangle fr;

    Top:
    if(front == i){
        /* no one is in front of this part of window; use the screen */
        fn(i->layer->screen->image, r, clipr, etc, 0);
        return;
    }
    fr = front->layer->screenr;
    if(rectXrect(r, fr) == 0){
        /* r doesn't touch this window; continue on next rearmost */
        // assert(front && front->layer && front->layer->screen && front->layer->rear);
        front = front->layer->rear;
        goto Top;
    }
    if(fr.max.y < r.max.y){
        RECUR(r.min, fr.max, r.max, r.max);
        r.max.y = fr.max.y;
    }
    if(r.min.y < fr.min.y){
        RECUR(r.min, r.min, r.max, fr.min);
        r.min.y = fr.min.y;
    }
    if(fr.max.x < r.max.x){
        RECUR(fr.max, r.min, r.max, r.max);
        r.max.x = fr.max.x;
    }
    if(r.min.x < fr.min.x){
        RECUR(r.min, r.min, fr.min, r.max);
        r.min.x = fr.min.x;
    }
    /* r is covered by front, so put in save area */
    (*fn)(i->layer->save, r, clipr, etc, 1);
}
@

<<function _memlayerop>>=
/*
 * Assumes incoming rectangle has already been clipped to i's logical r and clipr
 */
void
_memlayerop(
    void (*fn)(Memimage*, Rectangle, Rectangle, void*, int),
    Memimage *i,
    Rectangle screenr,	/* clipped to window boundaries */
    Rectangle clipr,		/* clipped also to clipping rectangles of hierarchy */
    void *etc)
{
    Memlayer *l;
    Rectangle r, scr;

    l = i->layer;
    if(!rectclip(&screenr, l->screenr))
        return;
    if(l->clear){
        fn(l->screen->image, screenr, clipr, etc, 0);
        return;
    }
    r = screenr;
    scr = l->screen->image->clipr;

    /*
     * Do the piece on the screen
     */
    if(rectclip(&screenr, scr))
        _layerop(fn, i, screenr, clipr, etc, l->screen->frontmost);
    if(rectinrect(r, scr))
        return;

    /*
     * Do the piece off the screen
    */
    if(!rectXrect(r, scr)){
        /* completely offscreen; easy */
        fn(l->save, r, clipr, etc, 1);
        return;
    }
    if(r.min.y < scr.min.y){
        /* above screen */
        fn(l->save, Rect(r.min.x, r.min.y, r.max.x, scr.min.y), clipr, etc, 1);
        r.min.y = scr.min.y;
    }
    if(r.max.y > scr.max.y){
        /* below screen */
        fn(l->save, Rect(r.min.x, scr.max.y, r.max.x, r.max.y), clipr, etc, 1);
        r.max.y = scr.max.y;
    }
    if(r.min.x < scr.min.x){
        /* left of screen */
        fn(l->save, Rect(r.min.x, r.min.y, scr.min.x, r.max.y), clipr, etc, 1);
        r.min.x = scr.min.x;
    }
    if(r.max.x > scr.max.x){
        /* right of screen */
        fn(l->save, Rect(scr.max.x, r.min.y, r.max.x, r.max.y), clipr, etc, 1);
    }
}
@


%-------------------------------------------------------------

<<lib_graphics/libmemlayer/layerop.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<function RECUR>>

<<function _layerop>>

<<function _memlayerop>>
@


\subsection*{[[lib_graphics/libmemlayer/ldelete.c]]}

<<function memldelete>>=
void
memldelete(Memimage *i)
{
    Memscreen *s;
    Memlayer *l;

    l = i->layer;
    /* free backing store and disconnect refresh, to make pushback fast */
    freememimage(l->save);
    l->save = nil;
    l->refreshptr = nil;
    memltorear(i);

    /* window is now the rearmost;  clean up screen structures and deallocate */
    s = i->layer->screen;
    if(s->fill){
        i->clipr = i->r;
        memdraw(i, i->r, s->fill, i->r.min, nil, i->r.min, S);
    }
    if(l->front){
        l->front->layer->rear = nil;
        s->rearmost = l->front;
    }else{
        s->frontmost = nil;
        s->rearmost = nil;
    }
    free(l);
    freememimage(i);
}
@

<<function memlfree>>=
/*
 * Just free the data structures, don't do graphics
 */
void
memlfree(Memimage *i)
{
    Memlayer *l;

    l = i->layer;
    freememimage(l->save);
    free(l);
    freememimage(i);
}
@

<<function _memlsetclear>>=
void
_memlsetclear(Memscreen *s)
{
    Memimage *i, *j;
    Memlayer *l;

    for(i=s->rearmost; i; i=i->layer->front){
        l = i->layer;
        l->clear = rectinrect(l->screenr, l->screen->image->clipr);
        if(l->clear)
            for(j=l->front; j; j=j->layer->front)
                if(rectXrect(l->screenr, j->layer->screenr)){
                    l->clear = 0;
                    break;
                }
    }
}
@


%-------------------------------------------------------------

<<lib_graphics/libmemlayer/ldelete.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<function memldelete>>

<<function memlfree>>

<<function _memlsetclear>>
@


\subsection*{[[lib_graphics/libmemlayer/lhide.c]]}

<<function lhideop>>=
/*
 * Hide puts that portion of screenr now on the screen into the window's save area.
 * Expose puts that portion of screenr now in the save area onto the screen.
 *
 * Hide and Expose both require that the layer structures in the screen
 * match the geometry they are being asked to update, that is, they update the
 * save area (hide) or screen (expose) based on what those structures tell them.
 * This means they must be called at the correct time during window shuffles.
 */

static
void
lhideop(Memimage *src, Rectangle screenr, Rectangle clipr, void *etc, int insave)
{
    Rectangle r;
    Memlayer *l;

    USED(clipr.min.x);
    USED(insave);
    l = etc;
    if(src != l->save){	/* do nothing if src is already in save area */
        r = rectsubpt(screenr, l->delta);
        memdraw(l->save, r, src, screenr.min, nil, screenr.min, S);
    }
}
@

<<function memlhide>>=
void
memlhide(Memimage *i, Rectangle screenr)
{
    if(i->layer->save == nil)
        return;
    if(rectclip(&screenr, i->layer->screen->image->r) == 0)
        return;
    _memlayerop(lhideop, i, screenr, screenr, i->layer);
}
@

<<function lexposeop>>=
static
void
lexposeop(Memimage *dst, Rectangle screenr, Rectangle clipr, void *etc, int insave)
{
    Memlayer *l;
    Rectangle r;

    USED(clipr.min.x);
    if(insave)	/* if dst is save area, don't bother */
        return;
    l = etc;
    r = rectsubpt(screenr, l->delta);
    if(l->save)
        memdraw(dst, screenr, l->save, r.min, nil, r.min, S);
    else
        l->refreshfn(dst, r, l->refreshptr);
}
@

<<function memlexpose>>=
void
memlexpose(Memimage *i, Rectangle screenr)
{
    if(rectclip(&screenr, i->layer->screen->image->r) == 0)
        return;
    _memlayerop(lexposeop, i, screenr, screenr, i->layer);
}
@


%-------------------------------------------------------------

<<lib_graphics/libmemlayer/lhide.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<function lhideop>>

<<function memlhide>>

<<function lexposeop>>

<<function memlexpose>>
@


\subsection*{[[lib_graphics/libmemlayer/line.c]]}

<<struct Lline>>=
struct Lline
{
    Point			p0;
    Point			p1;
    Point			delta;
    int			end0;
    int			end1;
    int			radius;
    Point			sp;
    Memlayer		*dstlayer;
    Memimage	*src;
    int			op;
};
@

<<function _memline>>=
static
void
_memline(Memimage *dst, Point p0, Point p1, int end0, int end1, int radius, Memimage *src, Point sp, Rectangle clipr, int op)
{
    Rectangle r;
    struct Lline ll;
    Point d;
    int srcclipped;
    Memlayer *dl;

    if(radius < 0)
        return;
    if(src->layer)	/* can't draw line with layered source */
        return;
    srcclipped = 0;

   Top:
    dl = dst->layer;
    if(dl == nil){
        _memimageline(dst, p0, p1, end0, end1, radius, src, sp, clipr, op);
        return;
    }
    if(!srcclipped){
        d = subpt(sp, p0);
        if(rectclip(&clipr, rectsubpt(src->clipr, d)) == 0)
            return;
        if((src->flags&Frepl)==0 && rectclip(&clipr, rectsubpt(src->r, d))==0)
            return;
        srcclipped = 1;
    }

    /* dst is known to be a layer */
    p0.x += dl->delta.x;
    p0.y += dl->delta.y;
    p1.x += dl->delta.x;
    p1.y += dl->delta.y;
    clipr.min.x += dl->delta.x;
    clipr.min.y += dl->delta.y;
    clipr.max.x += dl->delta.x;
    clipr.max.y += dl->delta.y;
    if(dl->clear){
        dst = dst->layer->screen->image;
        goto Top;
    }

    /* XXX */
    /* this is not the correct set of tests */
//	if(log2[dst->depth] != log2[src->depth] || log2[dst->depth]!=3)
//		return;

    /* can't use sutherland-cohen clipping because lines are wide */
    r = memlinebbox(p0, p1, end0, end1, radius);
    /*
     * r is now a bounding box for the line;
     * use it as a clipping rectangle for subdivision
     */
    if(rectclip(&r, clipr) == 0)
        return;
    ll.p0 = p0;
    ll.p1 = p1;
    ll.end0 = end0;
    ll.end1 = end1;
    ll.sp = sp;
    ll.dstlayer = dst->layer;
    ll.src = src;
    ll.radius = radius;
    ll.delta = dl->delta;
    ll.op = op;
    _memlayerop(llineop, dst, r, r, &ll);
}
@

<<function llineop>>=
static
void
llineop(Memimage *dst, Rectangle screenr, Rectangle clipr, void *etc, int insave)
{
    struct Lline *ll;
    Point p0, p1;

    USED(screenr.min.x);
    ll = etc;
    if(insave && ll->dstlayer->save==nil)
        return;
    if(!rectclip(&clipr, screenr))
        return;
    if(insave){
        p0 = subpt(ll->p0, ll->delta);
        p1 = subpt(ll->p1, ll->delta);
        clipr = rectsubpt(clipr, ll->delta);
    }else{
        p0 = ll->p0;
        p1 = ll->p1;
    }
    _memline(dst, p0, p1, ll->end0, ll->end1, ll->radius, ll->src, ll->sp, clipr, ll->op);
}
@

<<function memline>>=
void
memline(Memimage *dst, Point p0, Point p1, int end0, int end1, int radius, Memimage *src, Point sp, int op)
{
    _memline(dst, p0, p1, end0, end1, radius, src, sp, dst->clipr, op);
}
@


%-------------------------------------------------------------

<<lib_graphics/libmemlayer/line.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<struct Lline>>

static void llineop(Memimage*, Rectangle, Rectangle, void*, int);

<<function _memline>>

<<function llineop>>

<<function memline>>
@


\subsection*{[[lib_graphics/libmemlayer/load.c]]}

<<function memload>>=
int
memload(Memimage *dst, Rectangle r, uchar *data, int n, int iscompressed)
{
    int (*loadfn)(Memimage*, Rectangle, uchar*, int);
    Memimage *tmp;
    Memlayer *dl;
    Rectangle lr;
    int dx;

    loadfn = loadmemimage;
    if(iscompressed)
        loadfn = cloadmemimage;

    Top:
    dl = dst->layer;
    if(dl == nil)
        return loadfn(dst, r, data, n);

    /*
   * Convert to screen coordinates.
     */
    lr = r;
    r.min.x += dl->delta.x;
    r.min.y += dl->delta.y;
    r.max.x += dl->delta.x;
    r.max.y += dl->delta.y;
    dx = dl->delta.x&(7/dst->depth);
    if(dl->clear && dx==0){
        dst = dl->screen->image;
        goto Top;
    }

    /*
     * dst is an obscured layer or data is unaligned
     */
    if(dl->save && dx==0){
        n = loadfn(dl->save, lr, data, n);
        if(n > 0)
            memlexpose(dst, r);
        return n;
    }
    tmp = allocmemimage(lr, dst->chan);
    if(tmp == nil)
        return -1;
    n = loadfn(tmp, lr, data, n);
    memdraw(dst, lr, tmp, lr.min, nil, lr.min, S);
    freememimage(tmp);
    return n;
}
@


%-------------------------------------------------------------

<<lib_graphics/libmemlayer/load.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<function memload>>
@


\subsection*{[[lib_graphics/libmemlayer/lorigin.c]]}

<<function memlorigin>>=
/*
 * Place i so i->r.min = log, i->layer->screenr.min == scr.
*/
int
memlorigin(Memimage *i, Point log, Point scr)
{
    Memlayer *l;
    Memscreen *s;
    Memimage *t, *shad, *nsave;
    Rectangle x, newr, oldr;
    Point delta;
    int overlap, eqlog, eqscr, wasclear;

    l = i->layer;
    s = l->screen;
    oldr = l->screenr;
    newr = Rect(scr.x, scr.y, scr.x+Dx(oldr), scr.y+Dy(oldr));
    eqscr = eqpt(scr, oldr.min);
    eqlog = eqpt(log, i->r.min);
    if(eqscr && eqlog)
        return 0;
    nsave = nil;
    if(eqlog==0 && l->save!=nil){
        nsave = allocmemimage(Rect(log.x, log.y, log.x+Dx(oldr), log.y+Dy(oldr)), i->chan);
        if(nsave == nil)
            return -1;
    }

    /*
     * Bring it to front and move logical coordinate system.
     */
    memltofront(i);
    wasclear = l->clear;
    if(nsave){
        if(!wasclear)
            memimagedraw(nsave, nsave->r, l->save, l->save->r.min, nil, Pt(0,0), S);
        freememimage(l->save);
        l->save = nsave;
    }
    delta = subpt(log, i->r.min);
    i->r = rectaddpt(i->r, delta);
    i->clipr = rectaddpt(i->clipr, delta);
    l->delta = subpt(l->screenr.min, i->r.min);
    if(eqscr)
        return 0;

    /*
     * To clean up old position, make a shadow window there, don't paint it,
     * push it behind this one, and (later) delete it.  Because the refresh function
     * for this fake window is a no-op, this will cause no graphics action except
     * to restore the background and expose the windows previously hidden.
     */
    shad = memlalloc(s, oldr, memlnorefresh, nil, DNofill);
    if(shad == nil)
        return -1;
    s->frontmost = i;
    if(s->rearmost == i)
        s->rearmost = shad;
    else
        l->rear->layer->front = shad;
    shad->layer->front = i;
    shad->layer->rear = l->rear;
    l->rear = shad;
    l->front = nil;
    shad->layer->clear = 0;

    /*
     * Shadow is now holding down the fort at the old position.
     * Move the window and hide things obscured by new position.
     */
    for(t=l->rear->layer->rear; t!=nil; t=t->layer->rear){
        x = newr;
        overlap = rectclip(&x, t->layer->screenr);
        if(overlap){
            memlhide(t, x);
            t->layer->clear = 0;
        }
    }
    l->screenr = newr;
    l->delta = subpt(scr, i->r.min);
    l->clear = rectinrect(newr, l->screen->image->clipr);

    /*
     * Everything's covered.  Copy to new position and delete shadow window.
     */
    if(wasclear)
        memdraw(s->image, newr, s->image, oldr.min, nil, Pt(0,0), S);
    else
        memlexpose(i, newr);
    memldelete(shad);

    return 1;
}
@

<<function memlnorefresh>>=
void
memlnorefresh(Memimage *l, Rectangle r, void *v)
{
    USED(l);
    USED(r.min.x);
    USED(v);
}
@


%-------------------------------------------------------------

<<lib_graphics/libmemlayer/lorigin.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<function memlorigin>>

<<function memlnorefresh>>
@


\subsection*{[[lib_graphics/libmemlayer/lsetrefresh.c]]}

<<function memlsetrefresh>>=
int
memlsetrefresh(Memimage *i, Refreshfn fn, void *ptr)
{
    Memlayer *l;

    l = i->layer;
    if(l->refreshfn!=nil && fn!=nil){	/* just change functions */
        l->refreshfn = fn;
        l->refreshptr = ptr;
        return 1;
    }

    if(l->refreshfn == nil){	/* is using backup image; just free it */
        freememimage(l->save);
        l->save = nil;
        l->refreshfn = fn;
        l->refreshptr = ptr;
        return 1;
    }

    l->save = allocmemimage(i->r, i->chan);
    if(l->save == nil)
        return 0;
    /* easiest way is just to update the entire save area */
    l->refreshfn(i, i->r, l->refreshptr);
    l->refreshfn = nil;
    l->refreshptr = nil;
    return 1;
}
@


%-------------------------------------------------------------

<<lib_graphics/libmemlayer/lsetrefresh.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<function memlsetrefresh>>
@


\subsection*{[[lib_graphics/libmemlayer/ltofront.c]]}

<<function _memltofront>>=
/*
 * Pull i towards top of screen, just behind front
*/
static
void
_memltofront(Memimage *i, Memimage *front, int fill)
{
    Memlayer *l;
    Memscreen *s;
    Memimage *f, *ff, *rr;
    Rectangle x;
    int overlap;

    l = i->layer;
    s = l->screen;
    while(l->front != front){
        f = l->front;
        x = l->screenr;
        overlap = rectclip(&x, f->layer->screenr);
        if(overlap){
            memlhide(f, x);
            f->layer->clear = 0;
        }
        /* swap l and f in screen's list */
        ff = f->layer->front;
        rr = l->rear;
        if(ff == nil)
            s->frontmost = i;
        else
            ff->layer->rear = i;
        if(rr == nil)
            s->rearmost = f;
        else
            rr->layer->front = f;
        l->front = ff;
        l->rear = f;
        f->layer->front = i;
        f->layer->rear = rr;
        if(overlap && fill)
            memlexpose(i, x);
    }
}
@

<<function _memltofrontfill>>=
void
_memltofrontfill(Memimage *i, int fill)
{
    _memltofront(i, nil, fill);
    _memlsetclear(i->layer->screen);
}
@

<<function memltofront>>=
void
memltofront(Memimage *i)
{
    _memltofront(i, nil, 1);
    _memlsetclear(i->layer->screen);
}
@

<<function memltofrontn>>=
void
memltofrontn(Memimage **ip, int n)
{
    Memimage *i, *front;
    Memscreen *s;

    if(n == 0)
        return;
    front = nil;
    while(--n >= 0){
        i = *ip++;
        _memltofront(i, front, 1);
        front = i;
    }
    s = front->layer->screen;
    _memlsetclear(s);
}
@


%-------------------------------------------------------------

<<lib_graphics/libmemlayer/ltofront.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<function _memltofront>>

<<function _memltofrontfill>>

<<function memltofront>>

<<function memltofrontn>>
@


\subsection*{[[lib_graphics/libmemlayer/ltorear.c]]}

<<function _memltorear>>=
void
_memltorear(Memimage *i, Memimage *rear)
{
    Memlayer *l;
    Memscreen *s;
    Memimage *f, *r, *rr;
    Rectangle x;
    int overlap;

    l = i->layer;
    s = l->screen;
    while(l->rear != rear){
        r = l->rear;
        x = l->screenr;
        overlap = rectclip(&x, r->layer->screenr);
        if(overlap){
            memlhide(i, x);
            l->clear = 0;
        }
        /* swap l and r in screen's list */
        rr = r->layer->rear;
        f = l->front;
        if(rr == nil)
            s->rearmost = i;
        else
            rr->layer->front = i;
        if(f == nil)
            s->frontmost = r;
        else
            f->layer->rear = r;
        l->rear = rr;
        l->front = r;
        r->layer->rear = i;
        r->layer->front = f;
        if(overlap)
            memlexpose(r, x);
    }
}
@

<<function memltorear>>=
void
memltorear(Memimage *i)
{
    _memltorear(i, nil);
    _memlsetclear(i->layer->screen);
}
@

<<function memltorearn>>=
void
memltorearn(Memimage **ip, int n)
{
    Memimage *i, *rear;
    Memscreen *s;

    if(n == 0)
        return;
    rear = nil;
    while(--n >= 0){
        i = *ip++;
        _memltorear(i, rear);
        rear = i;
    }
    s = rear->layer->screen;
    _memlsetclear(s);
}
@


%-------------------------------------------------------------

<<lib_graphics/libmemlayer/ltorear.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<function _memltorear>>

<<function memltorear>>

<<function memltorearn>>
@


\subsection*{[[lib_graphics/libmemlayer/unload.c]]}

<<function memunload>>=
int
memunload(Memimage *src, Rectangle r, uchar *data, int n)
{
    Memimage *tmp;
    Memlayer *dl;
    Rectangle lr;
    int dx;

    Top:
    dl = src->layer;
    if(dl == nil)
        return unloadmemimage(src, r, data, n);

    /*
   * Convert to screen coordinates.
     */
    lr = r;
    r.min.x += dl->delta.x;
    r.min.y += dl->delta.y;
    r.max.x += dl->delta.x;
    r.max.y += dl->delta.y;
    dx = dl->delta.x&(7/src->depth);
    if(dl->clear && dx==0){
        src = dl->screen->image;
        goto Top;
    }

    /*
     * src is an obscured layer or data is unaligned
     */
    if(dl->save && dx==0){
        if(dl->refreshfn != nil)
            return -1;	/* can't unload window if it's not Refbackup */
        if(n > 0)
            memlhide(src, r);
        n = unloadmemimage(dl->save, lr, data, n);
        return n;
    }
    tmp = allocmemimage(lr, src->chan);
    if(tmp == nil)
        return -1;
    memdraw(tmp, lr, src, lr.min, nil, lr.min, S);
    n = unloadmemimage(tmp, lr, data, n);
    freememimage(tmp);
    return n;
}
@


%-------------------------------------------------------------

<<lib_graphics/libmemlayer/unload.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <memdraw.h>
#include <memlayer.h>

<<function memunload>>
@


\section{[[windows/rio/]]}

\subsection*{[[windows/rio/globals.c]]}

<<windows/rio/globals.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <cursor.h>
#include <mouse.h>
#include <keyboard.h>
#include <frame.h>
#include <fcall.h>

#include "dat.h"
#include "fns.h"

<<global font (windows/rio/dat.h)>>
<<global mousectl>>
<<global mouse>>
<<global keyboardctl>>
<<global display (windows/rio/dat.h)>>
<<global view>>
<<global wscreen>>
<<global boxcursor>>
<<global crosscursor>>
<<global sightcursor>>
<<global whitearrow>>
<<global query>>
<<global corners (windows/rio/dat.h)>>
<<global background>>
<<global lightgrey>>
<<global red (windows/rio/dat.h)>>
<<global window>>
<<global wkeyboard>>
<<global nwindow>>
<<global snarffd>>
<<global input>>
<<global all>>
<<global filsys>>
<<global hidden>>
<<global nhidden>>
<<global nsnarf>>
<<global snarf>>
<<global scrolling>>
<<global maxtab>>
<<global winclosechan>>
<<global deletechan>>
<<global startdir>>
<<global sweeping>>
<<global wctlfd>>
<<global srvpipe>>
<<global srvwctl>>
<<global errorshouldabort>>
<<global menuing>>
<<global snarfversion>>
<<global messagesize>>

@

\subsection*{[[windows/rio/dat.h]]}

<<enum _anon_ (windows/rio/dat.h)>>=
enum
{
    Qdir,			/* /dev for this window */
    Qcons,
    Qconsctl,
    Qcursor,
    Qwdir,
    Qwinid,
    Qwinname,
    Qkbdin,
    Qlabel,
    Qmouse,
    Qnew,
    Qscreen,
    Qsnarf,
    Qtext,
    Qwctl,
    Qwindow,
    Qwsys,		/* directory of window directories */
    Qwsysdir,		/* window directory, child of wsys */

    QMAX,
};
@

<<enum _anon_ (windows/rio/dat.h)2>>=
enum
{
    Kscrolloneup = KF|0x20,
    Kscrollonedown = KF|0x21,
};
@

<<constant STACK>>=
#define	STACK	8192
@

<<enum _anon_ (windows/rio/dat.h)3>>=
enum
{
    Selborder		= 4,		/* border of selected window */
    Unselborder	= 1,		/* border of unselected window */
    Scrollwid 		= 12,		/* width of scroll bar */
    Scrollgap 		= 4,		/* gap right of scroll bar */
    BIG			= 3,		/* factor by which window dimension can exceed screen */
};
@

<<enum _anon_ (windows/rio/dat.h)4>>=
enum
{
    TRUE		= 1,
    FALSE		= 0,
};
@

<<function QID>>=
#define	QID(w,q)	((w<<8)|(q))
@

<<function WIN>>=
#define	WIN(q)	((((ulong)(q).path)>>8) & 0xFFFFFF)
@

<<function FILE>>=
#define	FILE(q)	(((ulong)(q).path) & 0xFF)
@

<<enum _anon_ (windows/rio/dat.h)5>>=
enum	/* control messages */
{
    Wakeup,
    Reshaped,
    Moved,
    Refresh,
    Movemouse,
    Rawon,
    Rawoff,
    Holdon,
    Holdoff,
    Deleted,
    Exited,
};
@

<<struct Wctlmesg>>=
struct Wctlmesg
{
    int		type;
    Rectangle	r;
    Image	*image;
};
@

<<struct Conswritemesg>>=
struct Conswritemesg
{
    Channel	*cw;		/* chan(Stringpair) */
};
@

<<struct Consreadmesg>>=
struct Consreadmesg
{
    Channel	*c1;		/* chan(tuple(char*, int) == Stringpair) */
    Channel	*c2;		/* chan(tuple(char*, int) == Stringpair) */
};
@

<<struct Mousereadmesg>>=
struct Mousereadmesg
{
    Channel	*cm;		/* chan(Mouse) */
};
@

<<struct Stringpair>>=
struct Stringpair	/* rune and nrune or byte and nbyte */
{
    void		*s;
    int		ns;
};
@

<<struct Mousestate>>=
struct Mousestate
{
    Mouse;
    ulong	counter;	/* serial no. of mouse event */
};
@

<<struct Mouseinfo>>=
struct Mouseinfo
{
    Mousestate	queue[16];
    int	ri;	/* read index into queue */
    int	wi;	/* write index */
    ulong	counter;	/* serial no. of last mouse event we received */
    ulong	lastcounter;	/* serial no. of last mouse event sent to client */
    int	lastb;	/* last button state we received */
    uchar	qfull;	/* filled the queue; no more recording until client comes back */	
};	
@

<<struct Window>>=
struct Window
{
    Ref;
    QLock;
    Frame;
    Image		*i;
    Mousectl		mc;
    Mouseinfo	mouse;
    Channel		*ck;			/* chan(Rune[10]) */
    Channel		*cctl;		/* chan(Wctlmesg)[20] */
    Channel		*conswrite;	/* chan(Conswritemesg) */
    Channel		*consread;	/* chan(Consreadmesg) */
    Channel		*mouseread;	/* chan(Mousereadmesg) */
    Channel		*wctlread;		/* chan(Consreadmesg) */
    uint			nr;			/* number of runes in window */
    uint			maxr;		/* number of runes allocated in r */
    Rune			*r;
    uint			nraw;
    Rune			*raw;
    uint			org;
    uint			q0;
    uint			q1;
    uint			qh;
    int			id;
    char			name[32];
    uint			namecount;
    Rectangle		scrollr;
    /*
     * Rio once used originwindow, so screenr could be different from i->r.
     * Now they're always the same but the code doesn't assume so.
    */
    Rectangle		screenr;	/* screen coordinates of window */
    int			resized;
    int			wctlready;
    Rectangle		lastsr;
    int			topped;
    int			notefd;
    uchar		scrolling;
    Cursor		cursor;
    Cursor		*cursorp;
    uchar		holding;
    uchar		rawing;
    uchar		ctlopen;
    uchar		wctlopen;
    uchar		deleted;
    uchar		mouseopen;
    char			*label;
    int			pid;
    char			*dir;
};
@

<<struct Dirtab>>=
struct Dirtab
{
    char		*name;
    uchar	type;
    uint		qid;
    uint		perm;
};
@

<<struct FidRio>>=
struct FidRio
{
    int		fid;
    int		busy;
    int		open;
    int		mode;
    Qid		qid;
    Window	*w;
    Dirtab	*dir;
    Fid		*next;
    int		nrpart;
    uchar	rpart[UTFmax];
};
@

<<struct Xfid>>=
struct Xfid
{
        Ref;
        Xfid		*next;
        Xfid		*free;
        Fcall;
        Channel	*c;	/* chan(void(*)(Xfid*)) */
        Fid		*f;
        uchar	*buf;
        Filsys	*fs;
        QLock	active;
        int		flushing;	/* another Xfid is trying to flush us */
        int		flushtag;	/* our tag, so flush can find us */
        Channel	*flushc;	/* channel(int) to notify us we're being flushed */
};
@

<<enum _anon_ (windows/rio/dat.h)6>>=
enum
{
    Nhash	= 16,
};
@

<<struct Filsys>>=
struct Filsys
{
        int		cfd;
        int		sfd;
        int		pid;
        char		*user;
        Channel	*cxfidalloc;	/* chan(Xfid*) */
        Fid		*fids[Nhash];
};
@

<<struct Timer>>=
struct Timer
{
    int		dt;
    int		cancel;
    Channel	*c;	/* chan(int) */
    Timer	*next;
};
@


%-------------------------------------------------------------

<<windows/rio/dat.h>>=
<<enum _anon_ (windows/rio/dat.h)>>

<<enum _anon_ (windows/rio/dat.h)2>>

<<constant STACK>>

typedef	struct	Consreadmesg Consreadmesg;
typedef	struct	Conswritemesg Conswritemesg;
typedef	struct	Stringpair Stringpair;
typedef	struct	Dirtab Dirtab;
typedef	struct	FidRio Fid;
typedef	struct	Filsys Filsys;
typedef	struct	Mouseinfo	Mouseinfo;
typedef	struct	Mousereadmesg Mousereadmesg;
typedef	struct	Mousestate	Mousestate;
typedef	struct	Ref Ref;
typedef	struct	Timer Timer;
typedef	struct	Wctlmesg Wctlmesg;
typedef	struct	Window Window;
typedef	struct	Xfid Xfid;

<<enum _anon_ (windows/rio/dat.h)3>>

<<enum _anon_ (windows/rio/dat.h)4>>

<<function QID>>
<<function WIN>>
<<function FILE>>

<<enum _anon_ (windows/rio/dat.h)5>>

<<struct Wctlmesg>>

<<struct Conswritemesg>>

<<struct Consreadmesg>>

<<struct Mousereadmesg>>

<<struct Stringpair>>

<<struct Mousestate>>

<<struct Mouseinfo>>

<<struct Window>>

int		winborder(Window*, Point);
void		winctl(void*);
void		winshell(void*);
Window*	wlookid(int);
Window*	wmk(Image*, Mousectl*, Channel*, Channel*, int);
Window*	wpointto(Point);
Window*	wtop(Point);
void		wtopme(Window*);
void		wbottomme(Window*);
char*	wcontents(Window*, int*);
int		wbswidth(Window*, Rune);
int		wclickmatch(Window*, int, int, int, uint*);
int		wclose(Window*);
int		wctlmesg(Window*, int, Rectangle, Image*);
int		wctlmesg(Window*, int, Rectangle, Image*);
uint		wbacknl(Window*, uint, uint);
uint		winsert(Window*, Rune*, int, uint);
void		waddraw(Window*, Rune*, int);
void		wborder(Window*, int);
void		wclosewin(Window*);
void		wcurrent(Window*);
void		wcut(Window*);
void		wdelete(Window*, uint, uint);
void		wdoubleclick(Window*, uint*, uint*);
void		wfill(Window*);
void		wframescroll(Window*, int);
void		wkeyctl(Window*, Rune);
void		wmousectl(Window*);
void		wmovemouse(Window*, Point);
void		wpaste(Window*);
void		wplumb(Window*);
void		wrefresh(Window*, Rectangle);
void		wrepaint(Window*);
void		wresize(Window*, Image*, int);
void		wscrdraw(Window*);
void		wscroll(Window*, int);
void		wselect(Window*);
void		wsendctlmesg(Window*, int, Rectangle, Image*);
void		wsetcursor(Window*, int);
void		wsetname(Window*);
void		wsetorigin(Window*, uint, int);
void		wsetpid(Window*, int, int);
void		wsetselect(Window*, uint, uint);
void		wshow(Window*, uint);
void		wsnarf(Window*);
void 		wscrsleep(Window*, uint);
void		wsetcols(Window*);

<<struct Dirtab>>

<<struct FidRio>>

<<struct Xfid>>

Channel*	xfidinit(void);
void		xfidctl(void*);
void		xfidflush(Xfid*);
void		xfidattach(Xfid*);
void		xfidopen(Xfid*);
void		xfidclose(Xfid*);
void		xfidread(Xfid*);
void		xfidwrite(Xfid*);

<<enum _anon_ (windows/rio/dat.h)6>>

<<struct Filsys>>

Filsys*	filsysinit(Channel*);
int		filsysmount(Filsys*, int);
Xfid*		filsysrespond(Filsys*, Xfid*, Fcall*, char*);
void		filsyscancel(Xfid*);

void		wctlproc(void*);
void		wctlthread(void*);

void		deletetimeoutproc(void*);

<<struct Timer>>

extern Font		*font;
extern Mousectl	*mousectl;
extern Mouse	*mouse;
extern Keyboardctl	*keyboardctl;
extern Display	*display;
extern Image	*view;
extern Screen	*wscreen;
extern Cursor	boxcursor;
extern Cursor	crosscursor;
extern Cursor	sightcursor;
extern Cursor	whitearrow;
extern Cursor	query;
extern Cursor	*corners[9];
extern Image	*background;
extern Image	*lightgrey;
extern Image	*red;
extern Window	**window;
extern Window	*wkeyboard;	/* window of simulated keyboard */
extern int		nwindow;
extern int		snarffd;
extern Window	*input;
extern QLock	all;			/* BUG */
extern Filsys	*filsys;
extern Window	*hidden[100];
extern int		nhidden;
extern int		nsnarf;
extern Rune*	snarf;
extern int		scrolling;
extern int		maxtab;
extern Channel*	winclosechan;
extern Channel*	deletechan;
extern char		*startdir;
extern int		sweeping;
extern int		wctlfd;
extern char		srvpipe[];
extern char		srvwctl[];
extern int		errorshouldabort;
extern int		menuing;
extern int		snarfversion;	/* updated each time it is written */
extern int		messagesize; 		/* negotiated in 9P version setup */

@


\subsection*{[[windows/rio/data.c]]}

<<global crosscursor (windows/rio/data.c)>>=
Cursor crosscursor = {
    {-7, -7},
    {0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0,
     0x03, 0xC0, 0x03, 0xC0, 0xFF, 0xFF, 0xFF, 0xFF,
     0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0xC0, 0x03, 0xC0,
     0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, },
    {0x00, 0x00, 0x01, 0x80, 0x01, 0x80, 0x01, 0x80,
     0x01, 0x80, 0x01, 0x80, 0x01, 0x80, 0x7F, 0xFE,
     0x7F, 0xFE, 0x01, 0x80, 0x01, 0x80, 0x01, 0x80,
     0x01, 0x80, 0x01, 0x80, 0x01, 0x80, 0x00, 0x00, }
};
@

<<global boxcursor (windows/rio/data.c)>>=
Cursor boxcursor = {
    {-7, -7},
    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xFF, 0xFF, 0xF8, 0x1F, 0xF8, 0x1F, 0xF8, 0x1F,
     0xF8, 0x1F, 0xF8, 0x1F, 0xF8, 0x1F, 0xFF, 0xFF,
     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, },
    {0x00, 0x00, 0x7F, 0xFE, 0x7F, 0xFE, 0x7F, 0xFE,
     0x70, 0x0E, 0x70, 0x0E, 0x70, 0x0E, 0x70, 0x0E,
     0x70, 0x0E, 0x70, 0x0E, 0x70, 0x0E, 0x70, 0x0E,
     0x7F, 0xFE, 0x7F, 0xFE, 0x7F, 0xFE, 0x00, 0x00, }
};
@

<<global sightcursor (windows/rio/data.c)>>=
Cursor sightcursor = {
    {-7, -7},
    {0x1F, 0xF8, 0x3F, 0xFC, 0x7F, 0xFE, 0xFB, 0xDF,
     0xF3, 0xCF, 0xE3, 0xC7, 0xFF, 0xFF, 0xFF, 0xFF,
     0xFF, 0xFF, 0xFF, 0xFF, 0xE3, 0xC7, 0xF3, 0xCF,
     0x7B, 0xDF, 0x7F, 0xFE, 0x3F, 0xFC, 0x1F, 0xF8, },
    {0x00, 0x00, 0x0F, 0xF0, 0x31, 0x8C, 0x21, 0x84,
     0x41, 0x82, 0x41, 0x82, 0x41, 0x82, 0x7F, 0xFE,
     0x7F, 0xFE, 0x41, 0x82, 0x41, 0x82, 0x41, 0x82,
     0x21, 0x84, 0x31, 0x8C, 0x0F, 0xF0, 0x00, 0x00, }
};
@

<<global whitearrow (windows/rio/data.c)>>=
Cursor whitearrow = {
    {0, 0},
    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFC, 
     0xFF, 0xF0, 0xFF, 0xF0, 0xFF, 0xF8, 0xFF, 0xFC, 
     0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFC, 
     0xF3, 0xF8, 0xF1, 0xF0, 0xE0, 0xE0, 0xC0, 0x40, },
    {0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x06, 0xC0, 0x1C, 
     0xC0, 0x30, 0xC0, 0x30, 0xC0, 0x38, 0xC0, 0x1C, 
     0xC0, 0x0E, 0xC0, 0x07, 0xCE, 0x0E, 0xDF, 0x1C, 
     0xD3, 0xB8, 0xF1, 0xF0, 0xE0, 0xE0, 0xC0, 0x40, }
};
@

<<global query (windows/rio/data.c)>>=
Cursor query = {
    {-7,-7},
    {0x0f, 0xf0, 0x1f, 0xf8, 0x3f, 0xfc, 0x7f, 0xfe, 
     0x7c, 0x7e, 0x78, 0x7e, 0x00, 0xfc, 0x01, 0xf8, 
     0x03, 0xf0, 0x07, 0xe0, 0x07, 0xc0, 0x07, 0xc0, 
     0x07, 0xc0, 0x07, 0xc0, 0x07, 0xc0, 0x07, 0xc0, },
    {0x00, 0x00, 0x0f, 0xf0, 0x1f, 0xf8, 0x3c, 0x3c, 
     0x38, 0x1c, 0x00, 0x3c, 0x00, 0x78, 0x00, 0xf0, 
     0x01, 0xe0, 0x03, 0xc0, 0x03, 0x80, 0x03, 0x80, 
     0x00, 0x00, 0x03, 0x80, 0x03, 0x80, 0x00, 0x00, }
};
@

<<global tl>>=
Cursor tl = {
    {-4, -4},
    {0xfe, 0x00, 0x82, 0x00, 0x8c, 0x00, 0x87, 0xff, 
     0xa0, 0x01, 0xb0, 0x01, 0xd0, 0x01, 0x11, 0xff, 
     0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 
     0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x1f, 0x00, },
    {0x00, 0x00, 0x7c, 0x00, 0x70, 0x00, 0x78, 0x00, 
     0x5f, 0xfe, 0x4f, 0xfe, 0x0f, 0xfe, 0x0e, 0x00, 
     0x0e, 0x00, 0x0e, 0x00, 0x0e, 0x00, 0x0e, 0x00, 
     0x0e, 0x00, 0x0e, 0x00, 0x0e, 0x00, 0x00, 0x00, }
};
@

<<global t>>=
static Cursor t = {
    {-7, -8},
    {0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x06, 0xc0, 
     0x1c, 0x70, 0x10, 0x10, 0x0c, 0x60, 0xfc, 0x7f, 
     0x80, 0x01, 0x80, 0x01, 0x80, 0x01, 0xff, 0xff, 
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, },
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 
     0x03, 0x80, 0x0f, 0xe0, 0x03, 0x80, 0x03, 0x80, 
     0x7f, 0xfe, 0x7f, 0xfe, 0x7f, 0xfe, 0x00, 0x00, 
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }
};
@

<<global tr>>=
Cursor tr = {
    {-11, -4},
    {0x00, 0x7f, 0x00, 0x41, 0x00, 0x31, 0xff, 0xe1, 
     0x80, 0x05, 0x80, 0x0d, 0x80, 0x0b, 0xff, 0x88, 
     0x00, 0x88, 0x0, 0x88, 0x00, 0x88, 0x00, 0x88, 
     0x00, 0x88, 0x00, 0x88, 0x00, 0x88, 0x00, 0xf8, },
    {0x00, 0x00, 0x00, 0x3e, 0x00, 0x0e, 0x00, 0x1e, 
     0x7f, 0xfa, 0x7f, 0xf2, 0x7f, 0xf0, 0x00, 0x70, 
     0x00, 0x70, 0x00, 0x70, 0x00, 0x70, 0x00, 0x70, 
     0x00, 0x70, 0x00, 0x70, 0x00, 0x70, 0x00, 0x00, }
};
@

<<global r>>=
Cursor r = {
    {-8, -7},
    {0x07, 0xc0, 0x04, 0x40, 0x04, 0x40, 0x04, 0x58, 
     0x04, 0x68, 0x04, 0x6c, 0x04, 0x06, 0x04, 0x02, 
     0x04, 0x06, 0x04, 0x6c, 0x04, 0x68, 0x04, 0x58, 
     0x04, 0x40, 0x04, 0x40, 0x04, 0x40, 0x07, 0xc0, },
    {0x00, 0x00, 0x03, 0x80, 0x03, 0x80, 0x03, 0x80, 
     0x03, 0x90, 0x03, 0x90, 0x03, 0xf8, 0x03, 0xfc, 
     0x03, 0xf8, 0x03, 0x90, 0x03, 0x90, 0x03, 0x80, 
     0x03, 0x80, 0x03, 0x80, 0x03, 0x80, 0x00, 0x00, }
};
@

<<global br>>=
Cursor br = {
    {-11, -11},
    {0x00, 0xf8, 0x00, 0x88, 0x00, 0x88, 0x00, 0x88, 
     0x00, 0x88, 0x00, 0x88, 0x00, 0x88, 0x00, 0x88, 
     0xff, 0x88, 0x80, 0x0b, 0x80, 0x0d, 0x80, 0x05, 
     0xff, 0xe1, 0x00, 0x31, 0x00, 0x41, 0x00, 0x7f, },
    {0x00, 0x00, 0x00, 0x70, 0x00, 0x70, 0x00, 0x70, 
     0x0, 0x70, 0x00, 0x70, 0x00, 0x70, 0x00, 0x70, 
     0x00, 0x70, 0x7f, 0xf0, 0x7f, 0xf2, 0x7f, 0xfa, 
     0x00, 0x1e, 0x00, 0x0e, 0x00, 0x3e, 0x00, 0x00, }
};
@

<<global b>>=
Cursor b = {
    {-7, -7},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
     0xff, 0xff, 0x80, 0x01, 0x80, 0x01, 0x80, 0x01, 
     0xfc, 0x7f, 0x0c, 0x60, 0x10, 0x10, 0x1c, 0x70, 
     0x06, 0xc0, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, },
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
     0x00, 0x00, 0x7f, 0xfe, 0x7f, 0xfe, 0x7f, 0xfe, 
     0x03, 0x80, 0x03, 0x80, 0x0f, 0xe0, 0x03, 0x80, 
     0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }
};
@

<<global bl>>=
Cursor bl = {
    {-4, -11},
    {0x1f, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 
     0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 
     0x11, 0xff, 0xd0, 0x01, 0xb0, 0x01, 0xa0, 0x01, 
     0x87, 0xff, 0x8c, 0x00, 0x82, 0x00, 0xfe, 0x00, },
    {0x00, 0x00, 0x0e, 0x00, 0x0e, 0x00, 0x0e, 0x00, 
     0x0e, 0x00, 0x0e, 0x00, 0x0e, 0x00, 0x0e, 0x00, 
     0x0e, 0x00, 0x0f, 0xfe, 0x4f, 0xfe, 0x5f, 0xfe, 
     0x78, 0x00, 0x70, 0x00, 0x7c, 0x00, 0x00, 0x0, }
};
@

<<global l>>=
Cursor l = {
    {-7, -7},
    {0x03, 0xe0, 0x02, 0x20, 0x02, 0x20, 0x1a, 0x20, 
     0x16, 0x20, 0x36, 0x20, 0x60, 0x20, 0x40, 0x20, 
     0x60, 0x20, 0x36, 0x20, 0x16, 0x20, 0x1a, 0x20, 
     0x02, 0x20, 0x02, 0x20, 0x02, 0x20, 0x03, 0xe0, },
    {0x00, 0x00, 0x01, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 
     0x09, 0xc0, 0x09, 0xc0, 0x1f, 0xc0, 0x3f, 0xc0, 
     0x1f, 0xc0, 0x09, 0xc0, 0x09, 0xc0, 0x01, 0xc0, 
     0x01, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x00, 0x00, }
};
@

<<global corners (windows/rio/data.c)>>=
Cursor *corners[9] = {
    &tl,	&t,	&tr,
    &l,	nil,	&r,
    &bl,	&b,	&br,
};
@

<<function iconinit>>=
void
iconinit(void)
{
    background = allocimage(display, Rect(0,0,1,1), RGB24, 1, 0x777777FF);
    red = allocimage(display, Rect(0,0,1,1), RGB24, 1, 0xDD0000FF);
}
@


%-------------------------------------------------------------

<<windows/rio/data.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <cursor.h>
#include <mouse.h>
#include <keyboard.h>
#include <frame.h>
#include <fcall.h>

#include "dat.h"
#include "fns.h"

<<global crosscursor (windows/rio/data.c)>>

<<global boxcursor (windows/rio/data.c)>>

<<global sightcursor (windows/rio/data.c)>>

<<global whitearrow (windows/rio/data.c)>>

<<global query (windows/rio/data.c)>>

<<global tl>>

<<global t>>

<<global tr>>

<<global r>>

<<global br>>

<<global b>>

<<global bl>>

<<global l>>

<<global corners (windows/rio/data.c)>>

<<function iconinit>>
@


\subsection*{[[windows/rio/fns.h]]}

<<function runemalloc>>=
#define	runemalloc(n)		malloc((n)*sizeof(Rune))
@

<<function runerealloc>>=
#define	runerealloc(a, n)	realloc(a, (n)*sizeof(Rune))
@

<<function runemove>>=
#define	runemove(a, b, n)	memmove(a, b, (n)*sizeof(Rune))
@


%-------------------------------------------------------------

<<windows/rio/fns.h>>=
void	keyboardsend(char*, int);
int	whide(Window*);
int	wunhide(int);
void	freescrtemps(void);
int	parsewctl(char**, Rectangle, Rectangle*, int*, int*, int*, int*, char**, char*, char*);
int	writewctl(Xfid*, char*);
Window *new(Image*, int, int, int, char*, char*, char**);
void	riosetcursor(Cursor*, int);
int	min(int, int);
int	max(int, int);
Rune*	strrune(Rune*, Rune);
int	isalnum(Rune);
void	timerstop(Timer*);
void	timercancel(Timer*);
Timer*	timerstart(int);
void	error(char*);
void	killprocs(void);
int	shutdown(void*, char*);
void	iconinit(void);
void	*erealloc(void*, uint);
void *emalloc(uint);
char *estrdup(char*);
void	button3menu(void);
void	button2menu(Window*);
void	cvttorunes(char*, int, Rune*, int*, int*, int*);
/* was (byte*,int)	runetobyte(Rune*, int); */
char* runetobyte(Rune*, int, int*);
void	putsnarf(void);
void	getsnarf(void);
void	timerinit(void);
int	goodrect(Rectangle);

<<function runemalloc>>
<<function runerealloc>>
<<function runemove>>
@


\subsection*{[[windows/rio/fsys.c]]}

<<global Eperm>>=
char Eperm[] = "permission denied";
@

<<global Eexist>>=
char Eexist[] = "file does not exist";
@

<<global Enotdir>>=
char Enotdir[] = "not a directory";
@

<<global Ebadfcall>>=
char	Ebadfcall[] = "bad fcall type";
@

<<global Eoffset>>=
char	Eoffset[] = "illegal offset";
@

<<global messagesize (windows/rio/fsys.c)>>=
int	messagesize = 8192+IOHDRSZ;	/* good start */
@

<<enum _anon_ (windows/rio/fsys.c)>>=
enum{
    DEBUG = 0
};
@

<<global dirtab>>=
Dirtab dirtab[]=
{
    { ".",			QTDIR,	Qdir,			0500|DMDIR },
    { "cons",		QTFILE,	Qcons,		0600 },
    { "cursor",		QTFILE,	Qcursor,		0600 },
    { "consctl",	QTFILE,	Qconsctl,		0200 },
    { "winid",		QTFILE,	Qwinid,		0400 },
    { "winname",	QTFILE,	Qwinname,	0400 },
    { "kbdin",		QTFILE,	Qkbdin,		0200 },
    { "label",		QTFILE,	Qlabel,		0600 },
    { "mouse",	QTFILE,	Qmouse,		0600 },
    { "screen",		QTFILE,	Qscreen,		0400 },
    { "snarf",		QTFILE,	Qsnarf,		0600 },
    { "text",		QTFILE,	Qtext,		0400 },
    { "wdir",		QTFILE,	Qwdir,		0600 },
    { "wctl",		QTFILE,	Qwctl,		0600 },
    { "window",	QTFILE,	Qwindow,		0400 },
    { "wsys",		QTDIR,	Qwsys,		0500|DMDIR },
    { nil, }
};
@

<<global clockfd>>=
int	clockfd;
@

<<global firstmessage>>=
int	firstmessage = 1;
@

<<global srvpipe (windows/rio/fsys.c)>>=
char	srvpipe[64];
@

<<global srvwctl (windows/rio/fsys.c)>>=
char	srvwctl[64];
@

<<global fcall>>=
Xfid* 	(*fcall[Tmax])(Filsys*, Xfid*, Fid*) =
{
    [Tflush]	= filsysflush,
    [Tversion]	= filsysversion,
    [Tauth]	= filsysauth,
    [Tattach]	= filsysattach,
    [Twalk]	= filsyswalk,
    [Topen]	= filsysopen,
    [Tcreate]	= filsyscreate,
    [Tread]	= filsysread,
    [Twrite]	= filsyswrite,
    [Tclunk]	= filsysclunk,
    [Tremove]= filsysremove,
    [Tstat]	= filsysstat,
    [Twstat]	= filsyswstat,
};
@

<<function post>>=
void
post(char *name, char *envname, int srvfd)
{
    int fd;
    char buf[32];

    fd = create(name, OWRITE|ORCLOSE|OCEXEC, 0600);
    if(fd < 0)
        error(name);
    sprint(buf, "%d",srvfd);
    if(write(fd, buf, strlen(buf)) != strlen(buf))
        error("srv write");
    putenv(envname, name);
}
@

<<function cexecpipe>>=
/*
 * Build pipe with OCEXEC set on second fd.
 * Can't put it on both because we want to post one in /srv.
 */
int
cexecpipe(int *p0, int *p1)
{
    /* pipe the hard way to get close on exec */
    if(bind("#|", "/mnt/temp", MREPL) < 0)
        return -1;
    *p0 = open("/mnt/temp/data", ORDWR);
    *p1 = open("/mnt/temp/data1", ORDWR|OCEXEC);
    unmount(nil, "/mnt/temp");
    if(*p0<0 || *p1<0)
        return -1;
    return 0;
}
@

<<function filsysinit>>=
Filsys*
filsysinit(Channel *cxfidalloc)
{
    int n, fd, pid, p0;
    Filsys *fs;
    Channel *c;
    char buf[128];

    fs = emalloc(sizeof(Filsys));
    if(cexecpipe(&fs->cfd, &fs->sfd) < 0)
        goto Rescue;
    fmtinstall('F', fcallfmt);
    clockfd = open("/dev/time", OREAD|OCEXEC);
    fd = open("/dev/user", OREAD);
    strcpy(buf, "Jean-Paul_Belmondo");
    if(fd >= 0){
        n = read(fd, buf, sizeof buf-1);
        if(n > 0)
            buf[n] = 0;
        close(fd);
    }
    fs->user = estrdup(buf);
    fs->cxfidalloc = cxfidalloc;
    pid = getpid();

    /*
     * Create and post wctl pipe
     */
    if(cexecpipe(&p0, &wctlfd) < 0)
        goto Rescue;
    sprint(srvwctl, "/srv/riowctl.%s.%d", fs->user, pid);
    post(srvwctl, "wctl", p0);
    close(p0);

    /*
     * Start server processes
     */
    c = chancreate(sizeof(char*), 0);
    if(c == nil)
        error("wctl channel");
    proccreate(wctlproc, c, 4096);
    threadcreate(wctlthread, c, 4096);
    proccreate(filsysproc, fs, 10000);

    /*
     * Post srv pipe
     */
    sprint(srvpipe, "/srv/rio.%s.%d", fs->user, pid);
    post(srvpipe, "wsys", fs->cfd);

    return fs;

Rescue:
    free(fs);
    return nil;
}
@

<<function filsysproc>>=
static
void
filsysproc(void *arg)
{
    int n;
    Xfid *x;
    Fid *f;
    Fcall t;
    uchar *buf;
    Filsys *fs;

    threadsetname("FILSYSPROC");
    fs = arg;
    fs->pid = getpid();
    x = nil;
    for(;;){
        buf = emalloc(messagesize+UTFmax);	/* UTFmax for appending partial rune in xfidwrite */
        n = read9pmsg(fs->sfd, buf, messagesize);
        if(n <= 0){
            yield();	/* if threadexitsall'ing, will not return */
            fprint(2, "rio: %d: read9pmsg: %d %r\n", getpid(), n);
            errorshouldabort = 0;
            error("eof or i/o error on server channel");
        }
        if(x == nil){
            send(fs->cxfidalloc, nil);
            recv(fs->cxfidalloc, &x);
            x->fs = fs;
        }
        x->buf = buf;
        if(convM2S(buf, n, x) != n)
            error("convert error in convM2S");
        if(DEBUG)
            fprint(2, "rio:<-%F\n", &x->Fcall);
        if(fcall[x->type] == nil)
            x = filsysrespond(fs, x, &t, Ebadfcall);
        else{
            if(x->type==Tversion || x->type==Tauth)
                f = nil;
            else
                f = newfid(fs, x->fid);
            x->f = f;
            x  = (*fcall[x->type])(fs, x, f);
        }
        firstmessage = 0;
    }
}
@

<<function filsysmount>>=
/*
 * Called only from a different FD group
 */
int
filsysmount(Filsys *fs, int id)
{
    char buf[32];

    close(fs->sfd);	/* close server end so mount won't hang if exiting */
    sprint(buf, "%d", id);
    if(mount(fs->cfd, -1, "/mnt/wsys", MREPL, buf) < 0){
        fprint(2, "mount failed: %r\n");
        return -1;
    }
    if(bind("/mnt/wsys", "/dev", MBEFORE) < 0){
        fprint(2, "bind failed: %r\n");
        return -1;
    }
    return 0;
}
@

<<function filsysrespond>>=
Xfid*
filsysrespond(Filsys *fs, Xfid *x, Fcall *t, char *err)
{
    int n;

    if(err){
        t->type = Rerror;
        t->ename = err;
    }else
        t->type = x->type+1;
    t->fid = x->fid;
    t->tag = x->tag;
    if(x->buf == nil)
        x->buf = malloc(messagesize);
    n = convS2M(t, x->buf, messagesize);
    if(n <= 0)
        error("convert error in convS2M");
    if(write(fs->sfd, x->buf, n) != n)
        error("write error in respond");
    if(DEBUG)
        fprint(2, "rio:->%F\n", t);
    free(x->buf);
    x->buf = nil;
    return x;
}
@

<<function filsyscancel>>=
void
filsyscancel(Xfid *x)
{
    if(x->buf){
        free(x->buf);
        x->buf = nil;
    }
}
@

<<function filsysversion>>=
static
Xfid*
filsysversion(Filsys *fs, Xfid *x, Fid*)
{
    Fcall t;

    if(!firstmessage)
        return filsysrespond(x->fs, x, &t, "version request not first message");
    if(x->msize < 256)
        return filsysrespond(x->fs, x, &t, "version: message size too small");
    messagesize = x->msize;
    t.msize = messagesize;
    if(strncmp(x->version, "9P2000", 6) != 0)
        return filsysrespond(x->fs, x, &t, "unrecognized 9P version");
    t.version = "9P2000";
    return filsysrespond(fs, x, &t, nil);
}
@

<<function filsysauth>>=
static
Xfid*
filsysauth(Filsys *fs, Xfid *x, Fid*)
{
    Fcall t;

        return filsysrespond(fs, x, &t, "rio: authentication not required");
}
@

<<function filsysflush>>=
static
Xfid*
filsysflush(Filsys*, Xfid *x, Fid*)
{
    sendp(x->c, xfidflush);
    return nil;
}
@

<<function filsysattach>>=
static
Xfid*
filsysattach(Filsys *, Xfid *x, Fid *f)
{
    Fcall t;

    if(strcmp(x->uname, x->fs->user) != 0)
        return filsysrespond(x->fs, x, &t, Eperm);
    f->busy = TRUE;
    f->open = FALSE;
    f->qid.path = Qdir;
    f->qid.type = QTDIR;
    f->qid.vers = 0;
    f->dir = dirtab;
    f->nrpart = 0;
    sendp(x->c, xfidattach);
    return nil;
}
@

<<function numeric>>=
static
int
numeric(char *s)
{
    for(; *s!='\0'; s++)
        if(*s<'0' || '9'<*s)
            return 0;
    return 1;
}
@

<<function filsyswalk>>=
static
Xfid*
filsyswalk(Filsys *fs, Xfid *x, Fid *f)
{
    Fcall t;
    Fid *nf;
    int i, id;
    uchar type;
    ulong path;
    Dirtab *d, *dir;
    Window *w;
    char *err;
    Qid qid;

    if(f->open)
        return filsysrespond(fs, x, &t, "walk of open file");
    nf = nil;
    if(x->fid  != x->newfid){
        /* BUG: check exists */
        nf = newfid(fs, x->newfid);
        if(nf->busy)
            return filsysrespond(fs, x, &t, "clone to busy fid");
        nf->busy = TRUE;
        nf->open = FALSE;
        nf->dir = f->dir;
        nf->qid = f->qid;
        nf->w = f->w;
        incref(f->w);
        nf->nrpart = 0;	/* not open, so must be zero */
        f = nf;	/* walk f */
    }

    t.nwqid = 0;
    err = nil;

    /* update f->qid, f->dir only if walk completes */
    qid = f->qid;
    dir = f->dir;

    if(x->nwname > 0){
        for(i=0; i<x->nwname; i++){
            if((qid.type & QTDIR) == 0){
                err = Enotdir;
                break;
            }
            if(strcmp(x->wname[i], "..") == 0){
                type = QTDIR;
                path = Qdir;
                dir = dirtab;
                if(FILE(qid) == Qwsysdir)
                    path = Qwsys;
                id = 0;
    Accept:
                if(i == MAXWELEM){
                    err = "name too long";
                    break;
                }
                qid.type = type;
                qid.vers = 0;
                qid.path = QID(id, path);
                t.wqid[t.nwqid++] = qid;
                continue;
            }

            if(qid.path == Qwsys){
                /* is it a numeric name? */
                if(!numeric(x->wname[i]))
                    break;
                /* yes: it's a directory */
                id = atoi(x->wname[i]);
                qlock(&all);
                w = wlookid(id);
                if(w == nil){
                    qunlock(&all);
                    break;
                }
                path = Qwsysdir;
                type = QTDIR;
                qunlock(&all);
                incref(w);
                sendp(winclosechan, f->w);
                f->w = w;
                dir = dirtab;
                goto Accept;
            }
        
            if(snarffd>=0 && strcmp(x->wname[i], "snarf")==0)
                break;	/* don't serve /dev/snarf if it's provided in the environment */
            id = WIN(f->qid);
            d = dirtab;
            d++;	/* skip '.' */
            for(; d->name; d++)
                if(strcmp(x->wname[i], d->name) == 0){
                    path = d->qid;
                    type = d->type;
                    dir = d;
                    goto Accept;
                }

            break;	/* file not found */
        }

        if(i==0 && err==nil)
            err = Eexist;
    }

    if(err!=nil || t.nwqid<x->nwname){
        if(nf){
            if(nf->w)
                sendp(winclosechan, nf->w);
            nf->open = FALSE;
            nf->busy = FALSE;
        }
    }else if(t.nwqid == x->nwname){
        f->dir = dir;
        f->qid = qid;
    }

    return filsysrespond(fs, x, &t, err);
}
@

<<function filsysopen>>=
static
Xfid*
filsysopen(Filsys *fs, Xfid *x, Fid *f)
{
    Fcall t;
    int m;

    /* can't truncate anything, so just disregard */
    x->mode &= ~(OTRUNC|OCEXEC);
    /* can't execute or remove anything */
    if(x->mode==OEXEC || (x->mode&ORCLOSE))
        goto Deny;
    switch(x->mode){
    default:
        goto Deny;
    case OREAD:
        m = 0400;
        break;
    case OWRITE:
        m = 0200;
        break;
    case ORDWR:
        m = 0600;
        break;
    }
    if(((f->dir->perm&~(DMDIR|DMAPPEND))&m) != m)
        goto Deny;
        
    sendp(x->c, xfidopen);
    return nil;

    Deny:
    return filsysrespond(fs, x, &t, Eperm);
}
@

<<function filsyscreate>>=
static
Xfid*
filsyscreate(Filsys *fs, Xfid *x, Fid*)
{
    Fcall t;

    return filsysrespond(fs, x, &t, Eperm);
}
@

<<function idcmp>>=
static
int
idcmp(void *a, void *b)
{
    return *(int*)a - *(int*)b;
}
@

<<function filsysread>>=
static
Xfid*
filsysread(Filsys *fs, Xfid *x, Fid *f)
{
    Fcall t;
    uchar *b;
    int i, n, o, e, len, j, k, *ids;
    Dirtab *d, dt;
    uint clock;
    char buf[16];

    if((f->qid.type & QTDIR) == 0){
        sendp(x->c, xfidread);
        return nil;
    }
    o = x->offset;
    e = x->offset+x->count;
    clock = getclock();
    b = malloc(messagesize-IOHDRSZ);	/* avoid memset of emalloc */
    if(b == nil)
        return filsysrespond(fs, x, &t, "out of memory");
    n = 0;
    switch(FILE(f->qid)){
    case Qdir:
    case Qwsysdir:
        d = dirtab;
        d++;	/* first entry is '.' */
        for(i=0; d->name!=nil && i<e; i+=len){
            len = dostat(fs, WIN(x->f->qid), d, b+n, x->count-n, clock);
            if(len <= BIT16SZ)
                break;
            if(i >= o)
                n += len;
            d++;
        }
        break;
    case Qwsys:
        qlock(&all);
        ids = emalloc(nwindow*sizeof(int));
        for(j=0; j<nwindow; j++)
            ids[j] = window[j]->id;
        qunlock(&all);
        qsort(ids, nwindow, sizeof ids[0], idcmp);
        dt.name = buf;
        for(i=0, j=0; j<nwindow && i<e; i+=len){
            k = ids[j];
            sprint(dt.name, "%d", k);
            dt.qid = QID(k, Qdir);
            dt.type = QTDIR;
            dt.perm = DMDIR|0700;
            len = dostat(fs, k, &dt, b+n, x->count-n, clock);
            if(len == 0)
                break;
            if(i >= o)
                n += len;
            j++;
        }
        free(ids);
        break;
    }
    t.data = (char*)b;
    t.count = n;
    filsysrespond(fs, x, &t, nil);
    free(b);
    return x;
}
@

<<function filsyswrite>>=
static
Xfid*
filsyswrite(Filsys*, Xfid *x, Fid*)
{
    sendp(x->c, xfidwrite);
    return nil;
}
@

<<function filsysclunk>>=
static
Xfid*
filsysclunk(Filsys *fs, Xfid *x, Fid *f)
{
    Fcall t;

    if(f->open){
        f->busy = FALSE;
        f->open = FALSE;
        sendp(x->c, xfidclose);
        return nil;
    }
    if(f->w)
        sendp(winclosechan, f->w);
    f->busy = FALSE;
    f->open = FALSE;
    return filsysrespond(fs, x, &t, nil);
}
@

<<function filsysremove>>=
static
Xfid*
filsysremove(Filsys *fs, Xfid *x, Fid*)
{
    Fcall t;

    return filsysrespond(fs, x, &t, Eperm);
}
@

<<function filsysstat>>=
static
Xfid*
filsysstat(Filsys *fs, Xfid *x, Fid *f)
{
    Fcall t;

    t.stat = emalloc(messagesize-IOHDRSZ);
    t.nstat = dostat(fs, WIN(x->f->qid), f->dir, t.stat, messagesize-IOHDRSZ, getclock());
    x = filsysrespond(fs, x, &t, nil);
    free(t.stat);
    return x;
}
@

<<function filsyswstat>>=
static
Xfid*
filsyswstat(Filsys *fs, Xfid *x, Fid*)
{
    Fcall t;

    return filsysrespond(fs, x, &t, Eperm);
}
@

<<function newfid>>=
static
Fid*
newfid(Filsys *fs, int fid)
{
    Fid *f, *ff, **fh;

    ff = nil;
    fh = &fs->fids[fid&(Nhash-1)];
    for(f=*fh; f; f=f->next)
        if(f->fid == fid)
            return f;
        else if(ff==nil && f->busy==FALSE)
            ff = f;
    if(ff){
        ff->fid = fid;
        return ff;
    }
    f = emalloc(sizeof *f);
    f->fid = fid;
    f->next = *fh;
    *fh = f;
    return f;
}
@

<<function getclock>>=
static
uint
getclock(void)
{
    char buf[32];

    seek(clockfd, 0, 0);
    read(clockfd, buf, sizeof buf);
    return atoi(buf);
}
@

<<function dostat>>=
static
int
dostat(Filsys *fs, int id, Dirtab *dir, uchar *buf, int nbuf, uint clock)
{
    Dir d;

    d.qid.path = QID(id, dir->qid);
    if(dir->qid == Qsnarf)
        d.qid.vers = snarfversion;
    else
        d.qid.vers = 0;
    d.qid.type = dir->type;
    d.mode = dir->perm;
    d.length = 0;	/* would be nice to do better */
    d.name = dir->name;
    d.uid = fs->user;
    d.gid = fs->user;
    d.muid = fs->user;
    d.atime = clock;
    d.mtime = clock;
    return convD2M(&d, buf, nbuf);
}
@


%-------------------------------------------------------------

<<windows/rio/fsys.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <cursor.h>
#include <mouse.h>
#include <keyboard.h>
#include <frame.h>
#include <fcall.h>

#include "dat.h"
#include "fns.h"

<<global Eperm>>
<<global Eexist>>
<<global Enotdir>>
<<global Ebadfcall>>
<<global Eoffset>>

<<global messagesize (windows/rio/fsys.c)>>

<<enum _anon_ (windows/rio/fsys.c)>>

<<global dirtab>>

static uint		getclock(void);
static void		filsysproc(void*);
static Fid*		newfid(Filsys*, int);
static int		dostat(Filsys*, int, Dirtab*, uchar*, int, uint);

<<global clockfd>>
<<global firstmessage>>

<<global srvpipe (windows/rio/fsys.c)>>
<<global srvwctl (windows/rio/fsys.c)>>

static	Xfid*	filsysflush(Filsys*, Xfid*, Fid*);
static	Xfid*	filsysversion(Filsys*, Xfid*, Fid*);
static	Xfid*	filsysauth(Filsys*, Xfid*, Fid*);
static	Xfid*	filsysnop(Filsys*, Xfid*, Fid*);
static	Xfid*	filsysattach(Filsys*, Xfid*, Fid*);
static	Xfid*	filsyswalk(Filsys*, Xfid*, Fid*);
static	Xfid*	filsysopen(Filsys*, Xfid*, Fid*);
static	Xfid*	filsyscreate(Filsys*, Xfid*, Fid*);
static	Xfid*	filsysread(Filsys*, Xfid*, Fid*);
static	Xfid*	filsyswrite(Filsys*, Xfid*, Fid*);
static	Xfid*	filsysclunk(Filsys*, Xfid*, Fid*);
static	Xfid*	filsysremove(Filsys*, Xfid*, Fid*);
static	Xfid*	filsysstat(Filsys*, Xfid*, Fid*);
static	Xfid*	filsyswstat(Filsys*, Xfid*, Fid*);

<<global fcall>>

<<function post>>

<<function cexecpipe>>

<<function filsysinit>>

<<function filsysproc>>

<<function filsysmount>>

<<function filsysrespond>>

<<function filsyscancel>>

<<function filsysversion>>

<<function filsysauth>>

<<function filsysflush>>

<<function filsysattach>>

<<function numeric>>

<<function filsyswalk>>

<<function filsysopen>>

<<function filsyscreate>>

<<function idcmp>>

<<function filsysread>>

<<function filsyswrite>>

<<function filsysclunk>>

<<function filsysremove>>

<<function filsysstat>>

<<function filsyswstat>>

<<function newfid>>

<<function getclock>>

<<function dostat>>
@


\subsection*{[[windows/rio/rio.c]]}

<<global exitchan>>=
Channel	*exitchan;	/* chan(int) */
@

<<global winclosechan (windows/rio/rio.c)>>=
Channel	*winclosechan; /* chan(Window*); */
@

<<global viewr>>=
Rectangle	viewr;
@

<<global threadrforkflag>>=
int		threadrforkflag = 0;	/* should be RFENVG but that hides rio from plumber */
@

<<global fontname>>=
char		*fontname;
@

<<global mainpid>>=
int		mainpid;
@

<<enum _anon_ (windows/rio/rio.c)>>=
enum
{
    New,
    Reshape,
    Move,
    Delete,
    Hide,
    Exit,
};
@

<<enum _anon_ (windows/rio/rio.c)2>>=
enum
{
    Cut,
    Paste,
    Snarf,
    Plumb,
    Send,
    Scroll,
};
@

<<global menu2str>>=
char		*menu2str[] = {
 [Cut]		"cut",
 [Paste]		"paste",
 [Snarf]		"snarf",
 [Plumb]		"plumb",
 [Send]		"send",
 [Scroll]		"scroll",
            nil
};
@

<<global menu2>>=
Menu menu2 =
{
    menu2str
};
@

<<global Hidden>>=
int	Hidden = Exit+1;
@

<<global menu3str>>=
char		*menu3str[100] = {
 [New]		"New",
 [Reshape]	"Resize",
 [Move]		"Move",
 [Delete]		"Delete",
 [Hide]		"Hide",
 [Exit]		"Exit",
            nil
};
@

<<global menu3>>=
Menu menu3 =
{
    menu3str
};
@

<<global rcargv>>=
char *rcargv[] = { "rc", "-i", nil };
@

<<global kbdargv>>=
char *kbdargv[] = { "rc", "-c", nil, nil };
@

<<global errorshouldabort (windows/rio/rio.c)>>=
int errorshouldabort = 0;
@

<<function derror>>=
void
derror(Display*, char *errorstr)
{
    error(errorstr);
}
@

<<function usage>>=
void
usage(void)
{
    fprint(2, "usage: rio [-f font] [-i initcmd] [-k kbdcmd] [-s]\n");
    exits("usage");
}
@

<<function threadmain>>=
void
threadmain(int argc, char *argv[])
{
    char *initstr, *kbdin, *s;
    static void *arg[1];
    char buf[256];
    Image *i;
    Rectangle r;

    //PAD: let's keep the Exit option!
    //PAD: if(strstr(argv[0], ".out") == nil){
    //PAD: 	menu3str[Exit] = nil;
    //PAD: 	Hidden--;
    //PAD: }
    initstr = nil;
    kbdin = nil;
    maxtab = 0;
    ARGBEGIN{
    case 'f':
        fontname = ARGF();
        if(fontname == nil)
            usage();
        break;
    case 'i':
        initstr = ARGF();
        if(initstr == nil)
            usage();
        break;
    case 'k':
        if(kbdin != nil)
            usage();
        kbdin = ARGF();
        if(kbdin == nil)
            usage();
        break;
    case 's':
        scrolling = TRUE;
        break;
    }ARGEND

    mainpid = getpid();
    if(getwd(buf, sizeof buf) == nil)
        startdir = estrdup(".");
    else
        startdir = estrdup(buf);
    if(fontname == nil)
        fontname = getenv("font");
    if(fontname == nil)
        fontname = "/lib/font/bit/lucm/unicode.9.font";
    s = getenv("tabstop");
    if(s != nil)
        maxtab = strtol(s, nil, 0);
    if(maxtab == 0)
        maxtab = 4;
    free(s);
    /* check font before barging ahead */
    if(access(fontname, 0) < 0){
        fprint(2, "rio: can't access %s: %r\n", fontname);
        exits("font open");
    }
    putenv("font", fontname);

    snarffd = open("/dev/snarf", OREAD|OCEXEC);

    if(geninitdraw(nil, derror, nil, "rio", nil, Refnone) < 0){
        fprint(2, "rio: can't open display: %r\n");
        exits("display open");
    }
    iconinit();
    view = screen;
    viewr = view->r;
    mousectl = initmouse(nil, screen);
    if(mousectl == nil)
        error("can't find mouse");
    mouse = mousectl;
    keyboardctl = initkeyboard(nil);
    if(keyboardctl == nil)
        error("can't find keyboard");
    wscreen = allocscreen(screen, background, 0);
    if(wscreen == nil)
        error("can't allocate screen");
    draw(view, viewr, background, nil, ZP);
    flushimage(display, 1);

    exitchan = chancreate(sizeof(int), 0);
    winclosechan = chancreate(sizeof(Window*), 0);
    deletechan = chancreate(sizeof(char*), 0);

    timerinit();
    threadcreate(keyboardthread, nil, STACK);
    threadcreate(mousethread, nil, STACK);
    threadcreate(winclosethread, nil, STACK);
    threadcreate(deletethread, nil, STACK);
    filsys = filsysinit(xfidinit());

    if(filsys == nil)
        fprint(2, "rio: can't create file system server: %r\n");
    else{
        errorshouldabort = 1;	/* suicide if there's trouble after this */
        if(initstr)
            proccreate(initcmd, initstr, STACK);
        if(kbdin){
            kbdargv[2] = kbdin;
            r = screen->r;
            r.max.x = r.min.x+300;
            r.max.y = r.min.y+80;
            i = allocwindow(wscreen, r, Refbackup, DWhite);
            wkeyboard = new(i, FALSE, scrolling, 0, nil, "/bin/rc", kbdargv);
            if(wkeyboard == nil)
                error("can't create keyboard window");
        }
        threadnotify(shutdown, 1);
        recv(exitchan, nil);
    }
    killprocs();
    threadexitsall(nil);
}
@

<<function putsnarf>>=
/*
 * /dev/snarf updates when the file is closed, so we must open our own
 * fd here rather than use snarffd
 */
void
putsnarf(void)
{
    int fd, i, n;

    if(snarffd<0 || nsnarf==0)
        return;
    fd = open("/dev/snarf", OWRITE);
    if(fd < 0)
        return;
    /* snarf buffer could be huge, so fprint will truncate; do it in blocks */
    for(i=0; i<nsnarf; i+=n){
        n = nsnarf-i;
        if(n >= 256)
            n = 256;
        if(fprint(fd, "%.*S", n, snarf+i) < 0)
            break;
    }
    close(fd);
}
@

<<function getsnarf>>=
void
getsnarf(void)
{
    int i, n, nb, nulls;
    char *sn, buf[1024];

    if(snarffd < 0)
        return;
    sn = nil;
    i = 0;
    seek(snarffd, 0, 0);
    while((n = read(snarffd, buf, sizeof buf)) > 0){
        sn = erealloc(sn, i+n+1);
        memmove(sn+i, buf, n);
        i += n;
        sn[i] = 0;
    }
    if(i > 0){
        snarf = runerealloc(snarf, i+1);
        cvttorunes(sn, i, snarf, &nb, &nsnarf, &nulls);
        free(sn);
    }
}
@

<<function initcmd>>=
void
initcmd(void *arg)
{
    char *cmd;

    cmd = arg;
    rfork(RFENVG|RFFDG|RFNOTEG|RFNAMEG);
    procexecl(nil, "/bin/rc", "rc", "-c", cmd, nil);
    fprint(2, "rio: exec failed: %r\n");
    exits("exec");
}
@

<<global oknotes>>=
char *oknotes[] =
{
    "delete",
    "hangup",
    "kill",
    "exit",
    nil
};
@

<<function shutdown>>=
int
shutdown(void *, char *msg)
{
    int i;
    static Lock shutdownlk;
    
    killprocs();
    for(i=0; oknotes[i]; i++)
        if(strncmp(oknotes[i], msg, strlen(oknotes[i])) == 0){
            lock(&shutdownlk);	/* only one can threadexitsall */
            threadexitsall(msg);
        }
    fprint(2, "rio %d: abort: %s\n", getpid(), msg);
    abort();
    exits(msg);
    return 0;
}
@

<<function killprocs>>=
void
killprocs(void)
{
    int i;

    for(i=0; i<nwindow; i++)
        postnote(PNGROUP, window[i]->pid, "hangup");
}
@

<<function keyboardthread>>=
void
keyboardthread(void*)
{
    Rune buf[2][20], *rp;
    int n, i;

    threadsetname("keyboardthread");
    n = 0;
    for(;;){
        rp = buf[n];
        n = 1-n;
        recv(keyboardctl->c, rp);
        for(i=1; i<nelem(buf[0])-1; i++)
            if(nbrecv(keyboardctl->c, rp+i) <= 0)
                break;
        rp[i] = L'\0';
        if(input != nil)
            sendp(input->ck, rp);
    }
}
@

<<function keyboardsend>>=
/*
 * Used by /dev/kbdin
 */
void
keyboardsend(char *s, int cnt)
{
    Rune *r;
    int i, nb, nr;

    r = runemalloc(cnt);
    /* BUGlet: partial runes will be converted to error runes */
    cvttorunes(s, cnt, r, &nb, &nr, nil);
    for(i=0; i<nr; i++)
        send(keyboardctl->c, &r[i]);
    free(r);
}
@

<<function portion>>=
int
portion(int x, int lo, int hi)
{
    x -= lo;
    hi -= lo;
    if(x < 20)
        return 0;
    if(x > hi-20)
        return 2;
    return 1;
}
@

<<function whichcorner>>=
int
whichcorner(Window *w, Point p)
{
    int i, j;
    
    i = portion(p.x, w->screenr.min.x, w->screenr.max.x);
    j = portion(p.y, w->screenr.min.y, w->screenr.max.y);
    return 3*j+i;
}
@

<<function cornercursor>>=
void
cornercursor(Window *w, Point p, int force)
{
    if(w!=nil && winborder(w, p))
        riosetcursor(corners[whichcorner(w, p)], force);
    else
        wsetcursor(w, force);
}
@

<<function winclosethread>>=
/* thread to allow fsysproc to synchronize window closing with main proc */
void
winclosethread(void*)
{
    Window *w;

    threadsetname("winclosethread");
    for(;;){
        w = recvp(winclosechan);
        wclose(w);
    }
}
@

<<function deletethread>>=
/* thread to make Deleted windows that the client still holds disappear offscreen after an interval */
void
deletethread(void*)
{
    char *s;
    Image *i;

    threadsetname("deletethread");
    for(;;){
        s = recvp(deletechan);
        i = namedimage(display, s);
        if(i != nil){
            /* move it off-screen to hide it, since client is slow in letting it go */
            originwindow(i, i->r.min, view->r.max);
        }
        freeimage(i);
        free(s);
    }
}
@

<<function deletetimeoutproc>>=
void
deletetimeoutproc(void *v)
{
    char *s;

    s = v;
    sleep(750);	/* remove window from screen after 3/4 of a second */
    sendp(deletechan, s);
}
@

<<function keyboardhide>>=
/*
 * Button 6 - keyboard toggle - has been pressed.
 * Send event to keyboard, wait for button up, send that.
 * Note: there is no coordinate translation done here; this
 * is just about getting button 6 to the keyboard simulator.
 */
void
keyboardhide(void)
{
    send(wkeyboard->mc.c, mouse);
    do
        readmouse(mousectl);
    while(mouse->buttons & (1<<5));
    send(wkeyboard->mc.c, mouse);
}
@

<<enum _anon_ (windows/rio/rio.c)3>>=
enum {
    MReshape,
    MMouse,
    NALT
};
@

<<function mousethread>>=
void
mousethread(void*)
{
    int sending, inside, scrolling, moving, band;
    Window *oin, *w, *winput;
    Image *i;
    Rectangle r;
    Point xy;
    Mouse tmp;
    static Alt alts[NALT+1];

    threadsetname("mousethread");
    sending = FALSE;
    scrolling = FALSE;
    moving = FALSE;

    alts[MReshape].c = mousectl->resizec;
    alts[MReshape].v = nil;
    alts[MReshape].op = CHANRCV;
    alts[MMouse].c = mousectl->c;
    alts[MMouse].v = &mousectl->Mouse;
    alts[MMouse].op = CHANRCV;
    alts[NALT].op = CHANEND;

    for(;;)
        switch(alt(alts)){
        case MReshape:
            resized();
            break;
        case MMouse:
            if(wkeyboard!=nil && (mouse->buttons & (1<<5))){
                keyboardhide();
                break;
            }
        Again:
            winput = input;
            /* override everything for the keyboard window */
            if(wkeyboard!=nil && ptinrect(mouse->xy, wkeyboard->screenr)){
                /* make sure it's on top; this call is free if it is */
                wtopme(wkeyboard);
                winput = wkeyboard;
            }
            if(winput!=nil && winput->i!=nil){
                /* convert to logical coordinates */
                xy.x = mouse->xy.x + (winput->i->r.min.x-winput->screenr.min.x);
                xy.y = mouse->xy.y + (winput->i->r.min.y-winput->screenr.min.y);

                /* the up and down scroll buttons are not subject to the usual rules */
                if((mouse->buttons&(8|16)) && !winput->mouseopen)
                    goto Sending;

                inside = ptinrect(mouse->xy, insetrect(winput->screenr, Selborder));
                if(winput->mouseopen)
                    scrolling = FALSE;
                else if(scrolling)
                    scrolling = mouse->buttons;
                else
                    scrolling = mouse->buttons && ptinrect(xy, winput->scrollr);
                /* topped will be zero or less if window has been bottomed */
                if(sending == FALSE && !scrolling && winborder(winput, mouse->xy) && winput->topped>0){
                    moving = TRUE;
                }else if(inside && (scrolling || winput->mouseopen || (mouse->buttons&1)))
                    sending = TRUE;
            }else
                sending = FALSE;
            if(sending){
            Sending:
                if(mouse->buttons == 0){
                    cornercursor(winput, mouse->xy, 0);
                    sending = FALSE;
                }else
                    wsetcursor(winput, 0);
                tmp = mousectl->Mouse;
                tmp.xy = xy;
                send(winput->mc.c, &tmp);
                continue;
            }
            w = wpointto(mouse->xy);
            /* change cursor if over anyone's border */
            if(w != nil)
                cornercursor(w, mouse->xy, 0);
            else
                riosetcursor(nil, 0);
            if(moving && (mouse->buttons&7)){
                oin = winput;
                band = mouse->buttons & 3;
                sweeping = 1;
                if(band)
                    i = bandsize(winput);
                else
                    i = drag(winput, &r);
                sweeping = 0;
                if(i != nil){
                    if(winput == oin){
                        if(band)
                            wsendctlmesg(winput, Reshaped, i->r, i);
                        else
                            wsendctlmesg(winput, Moved, r, i);
                        cornercursor(winput, mouse->xy, 1);
                    }else
                        freeimage(i);
                }
            }
            if(w != nil)
                cornercursor(w, mouse->xy, 0);
            /* we're not sending the event, but if button is down maybe we should */
            if(mouse->buttons){
                /* w->topped will be zero or less if window has been bottomed */
                if(w==nil || (w==winput && w->topped>0)){
                    if(mouse->buttons & 1){
                        ;
                    }else if(mouse->buttons & 2){
                        if(winput && !winput->mouseopen)
                            button2menu(winput);
                    }else if(mouse->buttons & 4)
                        button3menu();
                }else{
                    /* if button 1 event in the window, top the window and wait for button up. */
                    /* otherwise, top the window and pass the event on */
                    if(wtop(mouse->xy) && (mouse->buttons!=1 || winborder(w, mouse->xy)))
                        goto Again;
                    goto Drain;
                }
            }
            moving = FALSE;
            break;

        Drain:
            do
                readmouse(mousectl);
            while(mousectl->buttons);
            moving = FALSE;
            goto Again;	/* recalculate mouse position, cursor */
        }
}
@

<<function resized>>=
void
resized(void)
{
    Image *im;
    int i, j, ishidden;
    Rectangle r;
    Point o, n;
    Window *w;

    if(getwindow(display, Refnone) < 0)
        error("failed to re-attach window");
    freescrtemps();
    view = screen;
    freescreen(wscreen);
    wscreen = allocscreen(screen, background, 0);
    if(wscreen == nil)
        error("can't re-allocate screen");
    draw(view, view->r, background, nil, ZP);
    o = subpt(viewr.max, viewr.min);
    n = subpt(view->clipr.max, view->clipr.min);
    for(i=0; i<nwindow; i++){
        w = window[i];
        if(w->deleted)
            continue;
        r = rectsubpt(w->i->r, viewr.min);
        r.min.x = (r.min.x*n.x)/o.x;
        r.min.y = (r.min.y*n.y)/o.y;
        r.max.x = (r.max.x*n.x)/o.x;
        r.max.y = (r.max.y*n.y)/o.y;
        r = rectaddpt(r, screen->clipr.min);
        ishidden = 0;
        for(j=0; j<nhidden; j++)
            if(w == hidden[j]){
                ishidden = 1;
                break;
            }
        if(ishidden){
            im = allocimage(display, r, screen->chan, 0, DWhite);
            r = ZR;
        }else
            im = allocwindow(wscreen, r, Refbackup, DWhite);
        if(im)
            wsendctlmesg(w, Reshaped, r, im);
    }
    viewr = screen->r;
    flushimage(display, 1);
}
@

<<function button3menu>>=
void
button3menu(void)
{
    int i;

    for(i=0; i<nhidden; i++)
        menu3str[i+Hidden] = hidden[i]->label;
    menu3str[i+Hidden] = nil;

    sweeping = 1;
    switch(i = menuhit(3, mousectl, &menu3, wscreen)){
    case -1:
        break;
    case New:
        new(sweep(), FALSE, scrolling, 0, nil, "/bin/rc", nil);
        break;
    case Reshape:
        resize();
        break;
    case Move:
        move();
        break;
    case Delete:
        delete();
        break;
    case Hide:
        hide();
        break;
    case Exit:
        if(Hidden > Exit){
            send(exitchan, nil);
            break;
        }
        /* else fall through */
    default:
        unhide(i);
        break;
    }
    sweeping = 0;
}
@

<<function button2menu>>=
void
button2menu(Window *w)
{
    if(w->deleted)
        return;
    incref(w);
    if(w->scrolling)
        menu2str[Scroll] = "noscroll";
    else
        menu2str[Scroll] = "scroll";
    switch(menuhit(2, mousectl, &menu2, wscreen)){
    case Cut:
        wsnarf(w);
        wcut(w);
        wscrdraw(w);
        break;

    case Snarf:
        wsnarf(w);
        break;

    case Paste:
        getsnarf();
        wpaste(w);
        wscrdraw(w);
        break;

    case Plumb:
        wplumb(w);
        break;

    case Send:
        getsnarf();
        wsnarf(w);
        if(nsnarf == 0)
            break;
        if(w->rawing){
            waddraw(w, snarf, nsnarf);
            if(snarf[nsnarf-1]!='\n' && snarf[nsnarf-1]!='\004')
                          waddraw(w, L"\n", 1);
        }else{
            winsert(w, snarf, nsnarf, w->nr);
            if(snarf[nsnarf-1]!='\n' && snarf[nsnarf-1]!='\004')
                winsert(w, L"\n", 1, w->nr);
        }
        wsetselect(w, w->nr, w->nr);
        wshow(w, w->nr);
        break;

    case Scroll:
        if(w->scrolling ^= 1)
            wshow(w, w->nr);
        break;
    }
    wclose(w);
    wsendctlmesg(w, Wakeup, ZR, nil);
    flushimage(display, 1);
}
@

<<function onscreen>>=
Point
onscreen(Point p)
{
    p.x = max(screen->clipr.min.x, p.x);
    p.x = min(screen->clipr.max.x, p.x);
    p.y = max(screen->clipr.min.y, p.y);
    p.y = min(screen->clipr.max.y, p.y);
    return p;
}
@

<<function sweep>>=
Image*
sweep(void)
{
    Image *i, *oi;
    Rectangle r;
    Point p0, p;

    i = nil;
    menuing = TRUE;
    riosetcursor(&crosscursor, 1);
    while(mouse->buttons == 0)
        readmouse(mousectl);
    p0 = onscreen(mouse->xy);
    p = p0;
    r.min = p;
    r.max = p;
    oi = nil;
    while(mouse->buttons == 4){
        readmouse(mousectl);
        if(mouse->buttons != 4 && mouse->buttons != 0)
            break;
        if(!eqpt(mouse->xy, p)){
            p = onscreen(mouse->xy);
            r = canonrect(Rpt(p0, p));
            if(Dx(r)>5 && Dy(r)>5){
                i = allocwindow(wscreen, r, Refnone, 0xEEEEEEFF); /* grey */
                freeimage(oi);
                if(i == nil)
                    goto Rescue;
                oi = i;
                border(i, r, Selborder, red, ZP);
                flushimage(display, 1);
            }
        }
    }
    if(mouse->buttons != 0)
        goto Rescue;
    if(i==nil || Dx(i->r)<100 || Dy(i->r)<3*font->height)
        goto Rescue;
    oi = i;
    i = allocwindow(wscreen, oi->r, Refbackup, DWhite);
    freeimage(oi);
    if(i == nil)
        goto Rescue;
    border(i, r, Selborder, red, ZP);
    cornercursor(input, mouse->xy, 1);
    goto Return;

 Rescue:
    freeimage(i);
    i = nil;
    cornercursor(input, mouse->xy, 1);
    while(mouse->buttons)
        readmouse(mousectl);

 Return:
    moveto(mousectl, mouse->xy);	/* force cursor update; ugly */
    menuing = FALSE;
    return i;
}
@

<<function drawedge>>=
void
drawedge(Image **bp, Rectangle r)
{
    Image *b = *bp;
    if(b != nil && Dx(b->r) == Dx(r) && Dy(b->r) == Dy(r))
        originwindow(b, r.min, r.min);
    else{
        freeimage(b);
        *bp = allocwindow(wscreen, r, Refbackup, DRed);
    }
}
@

<<function drawborder>>=
void
drawborder(Rectangle r, int show)
{
    static Image *b[4];
    int i;
    if(show == 0){
        for(i = 0; i < 4; i++){
            freeimage(b[i]);
            b[i] = nil;
        }
    }else{
        r = canonrect(r);
        drawedge(&b[0], Rect(r.min.x, r.min.y, r.min.x+Borderwidth, r.max.y));
        drawedge(&b[1], Rect(r.min.x+Borderwidth, r.min.y, r.max.x-Borderwidth, r.min.y+Borderwidth));
        drawedge(&b[2], Rect(r.max.x-Borderwidth, r.min.y, r.max.x, r.max.y));
        drawedge(&b[3], Rect(r.min.x+Borderwidth, r.max.y-Borderwidth, r.max.x-Borderwidth, r.max.y));
    }
}
@

<<function drag>>=
Image*
drag(Window *w, Rectangle *rp)
{
    Image *i, *ni;
    Point p, op, d, dm, om;
    Rectangle r;

    i = w->i;
    menuing = TRUE;
    om = mouse->xy;
    riosetcursor(&boxcursor, 1);
    dm = subpt(mouse->xy, w->screenr.min);
    d = subpt(i->r.max, i->r.min);
    op = subpt(mouse->xy, dm);
    drawborder(Rect(op.x, op.y, op.x+d.x, op.y+d.y), 1);
    flushimage(display, 1);
    while(mouse->buttons == 4){
        p = subpt(mouse->xy, dm);
        if(!eqpt(p, op)){
            drawborder(Rect(p.x, p.y, p.x+d.x, p.y+d.y), 1);
            flushimage(display, 1);
            op = p;
        }
        readmouse(mousectl);
    }
    r = Rect(op.x, op.y, op.x+d.x, op.y+d.y);
    drawborder(r, 0);
    cornercursor(w, mouse->xy, 1);
    moveto(mousectl, mouse->xy);	/* force cursor update; ugly */
    menuing = FALSE;
    flushimage(display, 1);
    if(mouse->buttons!=0 || (ni=allocwindow(wscreen, r, Refbackup, DWhite))==nil){
        moveto(mousectl, om);
        while(mouse->buttons)
            readmouse(mousectl);
        *rp = Rect(0, 0, 0, 0);
        return nil;
    }
    draw(ni, ni->r, i, nil, i->r.min);
    *rp = r;
    return ni;
}
@

<<function cornerpt>>=
Point
cornerpt(Rectangle r, Point p, int which)
{
    switch(which){
    case 0:	/* top left */
        p = Pt(r.min.x, r.min.y);
        break;
    case 2:	/* top right */
        p = Pt(r.max.x,r.min.y);
        break;
    case 6:	/* bottom left */
        p = Pt(r.min.x, r.max.y);
        break;
    case 8:	/* bottom right */
        p = Pt(r.max.x, r.max.y);
        break;
    case 1:	/* top edge */
        p = Pt(p.x,r.min.y);
        break;
    case 5:	/* right edge */
        p = Pt(r.max.x, p.y);
        break;
    case 7:	/* bottom edge */
        p = Pt(p.x, r.max.y);
        break;
    case 3:		/* left edge */
        p = Pt(r.min.x, p.y);
        break;
    }
    return p;
}
@

<<function whichrect>>=
Rectangle
whichrect(Rectangle r, Point p, int which)
{
    switch(which){
    case 0:	/* top left */
        r = Rect(p.x, p.y, r.max.x, r.max.y);
        break;
    case 2:	/* top right */
        r = Rect(r.min.x, p.y, p.x, r.max.y);
        break;
    case 6:	/* bottom left */
        r = Rect(p.x, r.min.y, r.max.x, p.y);
        break;
    case 8:	/* bottom right */
        r = Rect(r.min.x, r.min.y, p.x, p.y);
        break;
    case 1:	/* top edge */
        r = Rect(r.min.x, p.y, r.max.x, r.max.y);
        break;
    case 5:	/* right edge */
        r = Rect(r.min.x, r.min.y, p.x, r.max.y);
        break;
    case 7:	/* bottom edge */
        r = Rect(r.min.x, r.min.y, r.max.x, p.y);
        break;
    case 3:		/* left edge */
        r = Rect(p.x, r.min.y, r.max.x, r.max.y);
        break;
    }
    return canonrect(r);
}
@

<<function bandsize>>=
Image*
bandsize(Window *w)
{
    Image *i;
    Rectangle r, or;
    Point p, startp;
    int which, but;

    p = mouse->xy;
    but = mouse->buttons;
    which = whichcorner(w, p);
    p = cornerpt(w->screenr, p, which);
    wmovemouse(w, p);
    readmouse(mousectl);
    r = whichrect(w->screenr, p, which);
    drawborder(r, 1);
    or = r;
    startp = p;
    
    while(mouse->buttons == but){
        p = onscreen(mouse->xy);
        r = whichrect(w->screenr, p, which);
        if(!eqrect(r, or) && goodrect(r)){
            drawborder(r, 1);
            flushimage(display, 1);
            or = r;
        }
        readmouse(mousectl);
    }
    p = mouse->xy;
    drawborder(or, 0);
    flushimage(display, 1);
    wsetcursor(w, 1);
    if(mouse->buttons!=0 || Dx(or)<100 || Dy(or)<3*font->height){
        while(mouse->buttons)
            readmouse(mousectl);
        return nil;
    }
    if(abs(p.x-startp.x)+abs(p.y-startp.y) <= 1)
        return nil;
    i = allocwindow(wscreen, or, Refbackup, DWhite);
    if(i == nil)
        return nil;
    border(i, r, Selborder, red, ZP);
    return i;
}
@

<<function pointto>>=
Window*
pointto(int wait)
{
    Window *w;

    menuing = TRUE;
    riosetcursor(&sightcursor, 1);
    while(mouse->buttons == 0)
        readmouse(mousectl);
    if(mouse->buttons == 4)
        w = wpointto(mouse->xy);
    else
        w = nil;
    if(wait){
        while(mouse->buttons){
            if(mouse->buttons!=4 && w !=nil){	/* cancel */
                cornercursor(input, mouse->xy, 0);
                w = nil;
            }
            readmouse(mousectl);
        }
        if(w != nil && wpointto(mouse->xy) != w)
            w = nil;
    }
    cornercursor(input, mouse->xy, 0);
    moveto(mousectl, mouse->xy);	/* force cursor update; ugly */
    menuing = FALSE;
    return w;
}
@

<<function delete>>=
void
delete(void)
{
    Window *w;

    w = pointto(TRUE);
    if(w)
        wsendctlmesg(w, Deleted, ZR, nil);
}
@

<<function resize>>=
void
resize(void)
{
    Window *w;
    Image *i;

    w = pointto(TRUE);
    if(w == nil)
        return;
    i = sweep();
    if(i)
        wsendctlmesg(w, Reshaped, i->r, i);
}
@

<<function move>>=
void
move(void)
{
    Window *w;
    Image *i;
    Rectangle r;

    w = pointto(FALSE);
    if(w == nil)
        return;
    i = drag(w, &r);
    if(i)
        wsendctlmesg(w, Moved, r, i);
    cornercursor(input, mouse->xy, 1);
}
@

<<function whide>>=
int
whide(Window *w)
{
    Image *i;
    int j;

    for(j=0; j<nhidden; j++)
        if(hidden[j] == w)	/* already hidden */
            return -1;
    i = allocimage(display, w->screenr, w->i->chan, 0, DWhite);
    if(i){
        hidden[nhidden++] = w;
        wsendctlmesg(w, Reshaped, ZR, i);
        return 1;
    }
    return 0;
}
@

<<function wunhide>>=
int
wunhide(int h)
{
    Image *i;
    Window *w;

    w = hidden[h];
    i = allocwindow(wscreen, w->i->r, Refbackup, DWhite);
    if(i){
        --nhidden;
        memmove(hidden+h, hidden+h+1, (nhidden-h)*sizeof(Window*));
        wsendctlmesg(w, Reshaped, w->i->r, i);
        return 1;
    }
    return 0;
}
@

<<function hide>>=
void
hide(void)
{
    Window *w;

    w = pointto(TRUE);
    if(w == nil)
        return;
    whide(w);
}
@

<<function unhide>>=
void
unhide(int h)
{
    Window *w;

    h -= Hidden;
    w = hidden[h];
    if(w == nil)
        return;
    wunhide(h);
}
@

<<function new>>=
Window*
new(Image *i, int hideit, int scrollit, int pid, char *dir, char *cmd, char **argv)
{
    Window *w;
    Mousectl *mc;
    Channel *cm, *ck, *cctl, *cpid;
    void **arg;

    if(i == nil)
        return nil;
    cm = chancreate(sizeof(Mouse), 0);
    ck = chancreate(sizeof(Rune*), 0);
    cctl = chancreate(sizeof(Wctlmesg), 4);
    cpid = chancreate(sizeof(int), 0);
    if(cm==nil || ck==nil || cctl==nil)
        error("new: channel alloc failed");
    mc = emalloc(sizeof(Mousectl));
    *mc = *mousectl;
    mc->image = i;
    mc->c = cm;
    w = wmk(i, mc, ck, cctl, scrollit);
    free(mc);	/* wmk copies *mc */
    window = erealloc(window, ++nwindow*sizeof(Window*));
    window[nwindow-1] = w;
    if(hideit){
        hidden[nhidden++] = w;
        w->screenr = ZR;
    }
    threadcreate(winctl, w, 8192);
    if(!hideit)
        wcurrent(w);
    flushimage(display, 1);
    if(pid == 0){
        arg = emalloc(5*sizeof(void*));
        arg[0] = w;
        arg[1] = cpid;
        arg[2] = cmd;
        if(argv == nil)
            arg[3] = rcargv;
        else
            arg[3] = argv;
        arg[4] = dir;
        proccreate(winshell, arg, 8192);
        pid = recvul(cpid);
        free(arg);
    }
    if(pid == 0){
        /* window creation failed */
        wsendctlmesg(w, Deleted, ZR, nil);
        chanfree(cpid);
        return nil;
    }
    wsetpid(w, pid, 1);
    wsetname(w);
    if(dir)
        w->dir = estrdup(dir);
    chanfree(cpid);
    return w;
}
@


%-------------------------------------------------------------

<<windows/rio/rio.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <cursor.h>
#include <mouse.h>
#include <keyboard.h>
#include <frame.h>
#include <fcall.h>
#include <plumb.h>

#include "dat.h"
#include "fns.h"

/*
 *  WASHINGTON (AP) - The Food and Drug Administration warned
 * consumers Wednesday not to use ``Rio'' hair relaxer products
 * because they may cause severe hair loss or turn hair green....
 *    The FDA urged consumers who have experienced problems with Rio
 * to notify their local FDA office, local health department or the
 * company at 1â€‘800â€‘543â€‘3002.
 */

void		resize(void);
void		move(void);
void		delete(void);
void		hide(void);
void		unhide(int);
void		newtile(int);
Image	*sweep(void);
Image	*bandsize(Window*);
Image*	drag(Window*, Rectangle*);
void		refresh(Rectangle);
void		resized(void);

void	mousethread(void*);
void	keyboardthread(void*);
void winclosethread(void*);
void deletethread(void*);
void	initcmd(void*);

<<global exitchan>>
<<global winclosechan (windows/rio/rio.c)>>
<<global viewr>>
<<global threadrforkflag>>
<<global fontname>>
<<global mainpid>>

<<enum _anon_ (windows/rio/rio.c)>>

<<enum _anon_ (windows/rio/rio.c)2>>

<<global menu2str>>

<<global menu2>>

<<global Hidden>>

<<global menu3str>>

<<global menu3>>

<<global rcargv>>
<<global kbdargv>>

<<global errorshouldabort (windows/rio/rio.c)>>

<<function derror>>

<<function usage>>

<<function threadmain>>

<<function putsnarf>>

<<function getsnarf>>

<<function initcmd>>

<<global oknotes>>

<<function shutdown>>

<<function killprocs>>

<<function keyboardthread>>

//pad: Dead?
<<function keyboardsend>>

<<function portion>>

<<function whichcorner>>

<<function cornercursor>>

<<function winclosethread>>

<<function deletethread>>

<<function deletetimeoutproc>>

<<function keyboardhide>>

<<enum _anon_ (windows/rio/rio.c)3>>

<<function mousethread>>

<<function resized>>

<<function button3menu>>

<<function button2menu>>

<<function onscreen>>

<<function sweep>>

<<function drawedge>>

<<function drawborder>>

<<function drag>>

<<function cornerpt>>

<<function whichrect>>

<<function bandsize>>

<<function pointto>>

<<function delete>>

<<function resize>>

<<function move>>

<<function whide>>

<<function wunhide>>

<<function hide>>

<<function unhide>>

<<function new>>
@


\subsection*{[[windows/rio/scrl.c]]}

<<global scrtmp>>=
static Image *scrtmp;
@

<<function scrtemps>>=
static
void
scrtemps(void)
{
    int h;

    if(scrtmp)
        return;
    h = BIG*Dy(screen->r);
    scrtmp = allocimage(display, Rect(0, 0, 32, h), screen->chan, 0, DWhite);
    if(scrtmp == nil)
        error("scrtemps");
}
@

<<function freescrtemps>>=
void
freescrtemps(void)
{
    freeimage(scrtmp);
    scrtmp = nil;
}
@

<<function scrpos>>=
static
Rectangle
scrpos(Rectangle r, uint p0, uint p1, uint tot)
{
    Rectangle q;
    int h;

    q = r;
    h = q.max.y-q.min.y;
    if(tot == 0)
        return q;
    if(tot > 1024*1024){
        tot>>=10;
        p0>>=10;
        p1>>=10;
    }
    if(p0 > 0)
        q.min.y += h*p0/tot;
    if(p1 < tot)
        q.max.y -= h*(tot-p1)/tot;
    if(q.max.y < q.min.y+2){
        if(q.min.y+2 <= r.max.y)
            q.max.y = q.min.y+2;
        else
            q.min.y = q.max.y-2;
    }
    return q;
}
@

<<function wscrdraw>>=
void
wscrdraw(Window *w)
{
    Rectangle r, r1, r2;
    Image *b;

    scrtemps();
    if(w->i == nil)
        error("scrdraw");
    r = w->scrollr;
    b = scrtmp;
    r1 = r;
    r1.min.x = 0;
    r1.max.x = Dx(r);
    r2 = scrpos(r1, w->org, w->org+w->nchars, w->nr);
    if(!eqrect(r2, w->lastsr)){
        w->lastsr = r2;
        /* move r1, r2 to (0,0) to avoid clipping */
        r2 = rectsubpt(r2, r1.min);
        r1 = rectsubpt(r1, r1.min);
        draw(b, r1, w->cols[BORD], nil, ZP);
        draw(b, r2, w->cols[BACK], nil, ZP);
        r2.min.x = r2.max.x-1;
        draw(b, r2, w->cols[BORD], nil, ZP);
        draw(w->i, r, b, nil, Pt(0, r1.min.y));
    }
}
@

<<function wscrsleep>>=
void
wscrsleep(Window *w, uint dt)
{
    Timer	*timer;
    int y, b;
    static Alt alts[3];

    timer = timerstart(dt);
    y = w->mc.xy.y;
    b = w->mc.buttons;
    alts[0].c = timer->c;
    alts[0].v = nil;
    alts[0].op = CHANRCV;
    alts[1].c = w->mc.c;
    alts[1].v = &w->mc.Mouse;
    alts[1].op = CHANRCV;
    alts[2].op = CHANEND;
    for(;;)
        switch(alt(alts)){
        case 0:
            timerstop(timer);
            return;
        case 1:
            if(abs(w->mc.xy.y-y)>2 || w->mc.buttons!=b){
                timercancel(timer);
                return;
            }
            break;
        }
}
@

<<function wscroll>>=
void
wscroll(Window *w, int but)
{
    uint p0, oldp0;
    Rectangle s;
    int x, y, my, h, first;

    s = insetrect(w->scrollr, 1);
    h = s.max.y-s.min.y;
    x = (s.min.x+s.max.x)/2;
    oldp0 = ~0;
    first = TRUE;
    do{
        flushimage(display, 1);
        if(w->mc.xy.x<s.min.x || s.max.x<=w->mc.xy.x){
            readmouse(&w->mc);
        }else{
            my = w->mc.xy.y;
            if(my < s.min.y)
                my = s.min.y;
            if(my >= s.max.y)
                my = s.max.y;
            if(!eqpt(w->mc.xy, Pt(x, my))){
                wmovemouse(w, Pt(x, my));
                readmouse(&w->mc);		/* absorb event generated by moveto() */
            }
            if(but == 2){
                y = my;
                if(y > s.max.y-2)
                    y = s.max.y-2;
                if(w->nr > 1024*1024)
                    p0 = ((w->nr>>10)*(y-s.min.y)/h)<<10;
                else
                    p0 = w->nr*(y-s.min.y)/h;
                if(oldp0 != p0)
                    wsetorigin(w, p0, FALSE);
                oldp0 = p0;
                readmouse(&w->mc);
                continue;
            }
            if(but == 1)
                p0 = wbacknl(w, w->org, (my-s.min.y)/w->font->height);
            else
                p0 = w->org+frcharofpt(w, Pt(s.max.x, my));
            if(oldp0 != p0)
                wsetorigin(w, p0, TRUE);
            oldp0 = p0;
            /* debounce */
            if(first){
                flushimage(display, 1);
                sleep(200);
                nbrecv(w->mc.c, &w->mc.Mouse);
                first = FALSE;
            }
            wscrsleep(w, 100);
        }
    }while(w->mc.buttons & (1<<(but-1)));
    while(w->mc.buttons)
        readmouse(&w->mc);
}
@


%-------------------------------------------------------------

<<windows/rio/scrl.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <cursor.h>
#include <mouse.h>
#include <keyboard.h>
#include <frame.h>
#include <fcall.h>

#include "dat.h"
#include "fns.h"

<<global scrtmp>>

<<function scrtemps>>

<<function freescrtemps>>

<<function scrpos>>

<<function wscrdraw>>

<<function wscrsleep>>

<<function wscroll>>
@


\subsection*{[[windows/rio/time.c]]}

<<global ctimer>>=
static Channel*	ctimer;	/* chan(Timer*)[100] */
@

<<global timer>>=
static Timer *timer;
@

<<function msec>>=
static
uint
msec(void)
{
    return nsec()/1000000;
}
@

<<function timerstop>>=
void
timerstop(Timer *t)
{
    t->next = timer;
    timer = t;
}
@

<<function timercancel>>=
void
timercancel(Timer *t)
{
    t->cancel = TRUE;
}
@

<<function timerproc>>=
static
void
timerproc(void*)
{
    int i, nt, na, dt, del;
    Timer **t, *x;
    uint old, new;

    rfork(RFFDG);
    threadsetname("TIMERPROC");
    t = nil;
    na = 0;
    nt = 0;
    old = msec();
    for(;;){
        sleep(1);	/* will sleep minimum incr */
        new = msec();
        dt = new-old;
        old = new;
        if(dt < 0)	/* timer wrapped; go around, losing a tick */
            continue;
        for(i=0; i<nt; i++){
            x = t[i];
            x->dt -= dt;
            del = 0;
            if(x->cancel){
                timerstop(x);
                del = 1;
            }else if(x->dt <= 0){
                /*
                 * avoid possible deadlock if client is
                 * now sending on ctimer
                 */
                if(nbsendul(x->c, 0) > 0)
                    del = 1;
            }
            if(del){
                memmove(&t[i], &t[i+1], (nt-i-1)*sizeof t[0]);
                --nt;
                --i;
            }
        }
        if(nt == 0){
            x = recvp(ctimer);
    gotit:
            if(nt == na){
                na += 10;
                t = realloc(t, na*sizeof(Timer*));
                if(t == nil)
                    abort();
            }
            t[nt++] = x;
            old = msec();
        }
        if(nbrecv(ctimer, &x) > 0)
            goto gotit;
    }
}
@

<<function timerinit>>=
void
timerinit(void)
{
    ctimer = chancreate(sizeof(Timer*), 100);
    proccreate(timerproc, nil, STACK);
}
@

<<function timerstart>>=
/*
 * timeralloc() and timerfree() don't lock, so can only be
 * called from the main proc.
 */
Timer*
timerstart(int dt)
{
    Timer *t;

    t = timer;
    if(t)
        timer = timer->next;
    else{
        t = emalloc(sizeof(Timer));
        t->c = chancreate(sizeof(int), 0);
    }
    t->next = nil;
    t->dt = dt;
    t->cancel = FALSE;
    sendp(ctimer, t);
    return t;
}
@


%-------------------------------------------------------------

<<windows/rio/time.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <cursor.h>
#include <mouse.h>
#include <keyboard.h>
#include <frame.h>
#include <fcall.h>

#include "dat.h"
#include "fns.h"

<<global ctimer>>
<<global timer>>

<<function msec>>

<<function timerstop>>

<<function timercancel>>

<<function timerproc>>

<<function timerinit>>

<<function timerstart>>
@


\subsection*{[[windows/rio/util.c]]}

<<function cvttorunes>>=
void
cvttorunes(char *p, int n, Rune *r, int *nb, int *nr, int *nulls)
{
    uchar *q;
    Rune *s;
    int j, w;

    /*
     * Always guaranteed that n bytes may be interpreted
     * without worrying about partial runes.  This may mean
     * reading up to UTFmax-1 more bytes than n; the caller
     * knows this.  If n is a firm limit, the caller should
     * set p[n] = 0.
     */
    q = (uchar*)p;
    s = r;
    for(j=0; j<n; j+=w){
        if(*q < Runeself){
            w = 1;
            *s = *q++;
        }else{
            w = chartorune(s, (char*)q);
            q += w;
        }
        if(*s)
            s++;
        else if(nulls)
                *nulls = TRUE;
    }
    *nb = (char*)q-p;
    *nr = s-r;
}
@

<<function error>>=
void
error(char *s)
{
    fprint(2, "rio: %s: %r\n", s);
    if(errorshouldabort)
        abort();
    threadexitsall("error");
}
@

<<function erealloc>>=
void*
erealloc(void *p, uint n)
{
    p = realloc(p, n);
    if(p == nil)
        error("realloc failed");
    return p;
}
@

<<function emalloc>>=
void*
emalloc(uint n)
{
    void *p;

    p = malloc(n);
    if(p == nil)
        error("malloc failed");
    memset(p, 0, n);
    return p;
}
@

<<function estrdup>>=
char*
estrdup(char *s)
{
    char *p;

    p = malloc(strlen(s)+1);
    if(p == nil)
        error("strdup failed");
    strcpy(p, s);
    return p;
}
@

<<function isalnum>>=
int
isalnum(Rune c)
{
    /*
     * Hard to get absolutely right.  Use what we know about ASCII
     * and assume anything above the Latin control characters is
     * potentially an alphanumeric.
     */
    if(c <= ' ')
        return FALSE;
    if(0x7F<=c && c<=0xA0)
        return FALSE;
    if(utfrune("!\"#$%&'()*+,-./:;<=>?@[\\]^`{|}~", c))
        return FALSE;
    return TRUE;
}
@

<<function strrune>>=
Rune*
strrune(Rune *s, Rune c)
{
    Rune c1;

    if(c == 0) {
        while(*s++)
            ;
        return s-1;
    }

    while(c1 = *s++)
        if(c1 == c)
            return s-1;
    return nil;
}
@

<<function min>>=
int
min(int a, int b)
{
    if(a < b)
        return a;
    return b;
}
@

<<function max (windows/rio/util.c)>>=
int
max(int a, int b)
{
    if(a > b)
        return a;
    return b;
}
@

<<function runetobyte>>=
char*
runetobyte(Rune *r, int n, int *ip)
{
    char *s;
    int m;

    s = emalloc(n*UTFmax+1);
    m = snprint(s, n*UTFmax+1, "%.*S", n, r);
    *ip = m;
    return s;
}
@


%-------------------------------------------------------------

<<windows/rio/util.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <cursor.h>
#include <mouse.h>
#include <keyboard.h>
#include <frame.h>
#include <fcall.h>

#include "dat.h"
#include "fns.h"

<<function cvttorunes>>

<<function error>>

<<function erealloc>>

<<function emalloc>>

<<function estrdup>>

<<function isalnum>>

<<function strrune>>

<<function min>>

<<function max (windows/rio/util.c)>>

<<function runetobyte>>

@


\subsection*{[[windows/rio/wctl.c]]}

<<global Ebadwr>>=
char	Ebadwr[]		= "bad rectangle in wctl request";
@

<<global Ewalloc>>=
char	Ewalloc[]		= "window allocation failed in wctl request";
@

<<enum _anon_ (windows/rio/wctl.c)>>=
/* >= Top are disallowed if mouse button is pressed */
enum
{
    New,
    Resize,
    Move,
    Scroll,
    Noscroll,
    Set,
    Top,
    Bottom,
    Current,
    Hide,
    Unhide,
    Delete,
};
@

<<global cmds>>=
static char *cmds[] = {
    [New]	= "new",
    [Resize]	= "resize",
    [Move]	= "move",
    [Scroll]	= "scroll",
    [Noscroll]	= "noscroll",
    [Set]		= "set",
    [Top]	= "top",
    [Bottom]	= "bottom",
    [Current]	= "current",
    [Hide]	= "hide",
    [Unhide]	= "unhide",
    [Delete]	= "delete",
    nil
};
@

<<enum _anon_ (windows/rio/wctl.c)2>>=
enum
{
    Cd,
    Deltax,
    Deltay,
    Hidden,
    Id,
    Maxx,
    Maxy,
    Minx,
    Miny,
    PID,
    R,
    Scrolling,
    Noscrolling,
};
@

<<global params>>=
static char *params[] = {
    [Cd]	 			= "-cd",
    [Deltax]			= "-dx",
    [Deltay]			= "-dy",
    [Hidden]			= "-hide",
    [Id]				= "-id",
    [Maxx]			= "-maxx",
    [Maxy]			= "-maxy",
    [Minx]			= "-minx",
    [Miny]			= "-miny",
    [PID]				= "-pid",
    [R]				= "-r",
    [Scrolling]			= "-scroll",
    [Noscrolling]		= "-noscroll",
    nil
};
@

<<function goodrect>>=
/*
 * Check that newly created window will be of manageable size
 */
int
goodrect(Rectangle r)
{
    if(!eqrect(canonrect(r), r))
        return 0;
    if(Dx(r)<100 || Dy(r)<3*font->height)
        return 0;
    /* must have some screen and border visible so we can move it out of the way */
    if(Dx(r) >= Dx(screen->r) && Dy(r) >= Dy(screen->r))
        return 0;
    /* reasonable sizes only please */
    if(Dx(r) > BIG*Dx(screen->r))
        return 0;
    if(Dy(r) > BIG*Dx(screen->r))
        return 0;
    return 1;
}
@

<<function word>>=
static
int
word(char **sp, char *tab[])
{
    char *s, *t;
    int i;

    s = *sp;
    while(isspace(*s))
        s++;
    t = s;
    while(*s!='\0' && !isspace(*s))
        s++;
    for(i=0; tab[i]!=nil; i++)
        if(strncmp(tab[i], t, strlen(tab[i])) == 0){
            *sp = s;
            return i;
    }
    return -1;
}
@

<<function set>>=
int
set(int sign, int neg, int abs, int pos)
{
    if(sign < 0)
        return neg;
    if(sign > 0)
        return pos;
    return abs;
}
@

<<function newrect>>=
Rectangle
newrect(void)
{
    static int i = 0;
    int minx, miny, dx, dy;

    dx = min(600, Dx(screen->r) - 2*Borderwidth);
    dy = min(400, Dy(screen->r) - 2*Borderwidth);
    minx = 32 + 16*i;
    miny = 32 + 16*i;
    i++;
    i %= 10;

    return Rect(minx, miny, minx+dx, miny+dy);
}
@

<<function shift>>=
void
shift(int *minp, int *maxp, int min, int max)
{
    if(*minp < min){
        *maxp += min-*minp;
        *minp = min;
    }
    if(*maxp > max){
        *minp += max-*maxp;
        *maxp = max;
    }
}
@

<<function rectonscreen>>=
Rectangle
rectonscreen(Rectangle r)
{
    shift(&r.min.x, &r.max.x, screen->r.min.x, screen->r.max.x);
    shift(&r.min.y, &r.max.y, screen->r.min.y, screen->r.max.y);
    return r;
}
@

<<function riostrtol>>=
/* permit square brackets, in the manner of %R */
int
riostrtol(char *s, char **t)
{
    int n;

    while(*s!='\0' && (*s==' ' || *s=='\t' || *s=='['))
        s++;
    if(*s == '[')
        s++;
    n = strtol(s, t, 10);
    if(*t != s)
        while((*t)[0] == ']')
            (*t)++;
    return n;
}
@

<<function parsewctl>>=
int
parsewctl(char **argp, Rectangle r, Rectangle *rp, int *pidp, int *idp, int *hiddenp, int *scrollingp, char **cdp, char *s, char *err)
{
    int cmd, param, xy, sign;
    char *t;

    *pidp = 0;
    *hiddenp = 0;
    *scrollingp = scrolling;
    *cdp = nil;
    cmd = word(&s, cmds);
    if(cmd < 0){
        strcpy(err, "unrecognized wctl command");
        return -1;
    }
    if(cmd == New)
        r = newrect();

    strcpy(err, "missing or bad wctl parameter");
    while((param = word(&s, params)) >= 0){
        switch(param){	/* special cases */
        case Hidden:
            *hiddenp = 1;
            continue;
        case Scrolling:
            *scrollingp = 1;
            continue;
        case Noscrolling:
            *scrollingp = 0;
            continue;
        case R:
            r.min.x = riostrtol(s, &t);
            if(t == s)
                return -1;
            s = t;
            r.min.y = riostrtol(s, &t);
            if(t == s)
                return -1;
            s = t;
            r.max.x = riostrtol(s, &t);
            if(t == s)
                return -1;
            s = t;
            r.max.y = riostrtol(s, &t);
            if(t == s)
                return -1;
            s = t;
            continue;
        }
        while(isspace(*s))
            s++;
        if(param == Cd){
            *cdp = s;
            while(*s && !isspace(*s))
                s++;
            if(*s != '\0')
                *s++ = '\0';
            continue;
        }
        sign = 0;
        if(*s == '-'){
            sign = -1;
            s++;
        }else if(*s == '+'){
            sign = +1;
            s++;
        }
        if(!isdigit(*s))
            return -1;
        xy = riostrtol(s, &s);
        switch(param){
        case -1:
            strcpy(err, "unrecognized wctl parameter");
            return -1;
        case Minx:
            r.min.x = set(sign, r.min.x-xy, xy, r.min.x+xy);
            break;
        case Miny:
            r.min.y = set(sign, r.min.y-xy, xy, r.min.y+xy);
            break;
        case Maxx:
            r.max.x = set(sign, r.max.x-xy, xy, r.max.x+xy);
            break;
        case Maxy:
            r.max.y = set(sign, r.max.y-xy, xy, r.max.y+xy);
            break;
        case Deltax:
            r.max.x = set(sign, r.max.x-xy, r.min.x+xy, r.max.x+xy);
            break;
        case Deltay:
            r.max.y = set(sign, r.max.y-xy, r.min.y+xy, r.max.y+xy);
            break;
        case Id:
            if(idp != nil)
                *idp = xy;
            break;
        case PID:
            if(pidp != nil)
                *pidp = xy;
            break;
        }
    }

    *rp = rectonscreen(rectaddpt(r, screen->r.min));

    while(isspace(*s))
        s++;
    if(cmd!=New && *s!='\0'){
        strcpy(err, "extraneous text in wctl message");
        return -1;
    }

    if(argp)
        *argp = s;

    return cmd;
}
@

<<function wctlnew>>=
int
wctlnew(Rectangle rect, char *arg, int pid, int hideit, int scrollit, char *dir, char *err)
{
    char **argv;
    Image *i;

    if(!goodrect(rect)){
        strcpy(err, Ebadwr);
        return -1;
    }
    argv = emalloc(4*sizeof(char*));
    argv[0] = "rc";
    argv[1] = "-c";
    while(isspace(*arg))
        arg++;
    if(*arg == '\0'){
        argv[1] = "-i";
        argv[2] = nil;
    }else{
        argv[2] = arg;
        argv[3] = nil;
    }
    if(hideit)
        i = allocimage(display, rect, screen->chan, 0, DWhite);
    else
        i = allocwindow(wscreen, rect, Refbackup, DWhite);
    if(i == nil){
        strcpy(err, Ewalloc);
        return -1;
    }
    border(i, rect, Selborder, red, ZP);

    new(i, hideit, scrollit, pid, dir, "/bin/rc", argv);

    free(argv);	/* when new() returns, argv and args have been copied */
    return 1;
}
@

<<function writewctl>>=
int
writewctl(Xfid *x, char *err)
{
    int cnt, cmd, j, id, hideit, scrollit, pid;
    Image *i;
    char *arg, *dir;
    Rectangle rect;
    Window *w;

    w = x->f->w;
    cnt = x->count;
    x->data[cnt] = '\0';
    id = 0;

    rect = rectsubpt(w->screenr, screen->r.min);
    cmd = parsewctl(&arg, rect, &rect, &pid, &id, &hideit, &scrollit, &dir, x->data, err);
    if(cmd < 0)
        return -1;

    if(mouse->buttons!=0 && cmd>=Top){
        strcpy(err, "action disallowed when mouse active");
        return -1;
    }

    if(id != 0){
        for(j=0; j<nwindow; j++)
            if(window[j]->id == id)
                break;
        if(j == nwindow){
            strcpy(err, "no such window id");
            return -1;
        }
        w = window[j];
        if(w->deleted || w->i==nil){
            strcpy(err, "window deleted");
            return -1;
        }
    }

    switch(cmd){
    case New:
        return wctlnew(rect, arg, pid, hideit, scrollit, dir, err);
    case Set:
        if(pid > 0)
            wsetpid(w, pid, 0);
        return 1;
    case Move:
        rect = Rect(rect.min.x, rect.min.y, rect.min.x+Dx(w->screenr), rect.min.y+Dy(w->screenr));
        rect = rectonscreen(rect);
        /* fall through */
    case Resize:
        if(!goodrect(rect)){
            strcpy(err, Ebadwr);
            return -1;
        }
        if(eqrect(rect, w->screenr))
            return 1;
        i = allocwindow(wscreen, rect, Refbackup, DWhite);
        if(i == nil){
            strcpy(err, Ewalloc);
            return -1;
        }
        border(i, rect, Selborder, red, ZP);
        wsendctlmesg(w, Reshaped, i->r, i);
        return 1;
    case Scroll:
        w->scrolling = 1;
        wshow(w, w->nr);
        wsendctlmesg(w, Wakeup, ZR, nil);
        return 1;
    case Noscroll:
        w->scrolling = 0;
        wsendctlmesg(w, Wakeup, ZR, nil);
        return 1;
    case Top:
        wtopme(w);
        return 1;
    case Bottom:
        wbottomme(w);
        return 1;
    case Current:
        wcurrent(w);
        return 1;
    case Hide:
        switch(whide(w)){
        case -1:
            strcpy(err, "window already hidden");
            return -1;
        case 0:
            strcpy(err, "hide failed");
            return -1;
        default:
            break;
        }
        return 1;
    case Unhide:
        for(j=0; j<nhidden; j++)
            if(hidden[j] == w)
                break;
        if(j == nhidden){
            strcpy(err, "window not hidden");
            return -1;
        }
        if(wunhide(j) == 0){
            strcpy(err, "hide failed");
            return -1;
        }
        return 1;
    case Delete:
        wsendctlmesg(w, Deleted, ZR, nil);
        return 1;
    }
    strcpy(err, "invalid wctl message");
    return -1;
}
@

<<function wctlthread>>=
void
wctlthread(void *v)
{
    char *buf, *arg, *dir;
    int cmd, id, pid, hideit, scrollit;
    Rectangle rect;
    char err[ERRMAX];
    Channel *c;

    c = v;

    threadsetname("WCTLTHREAD");

    for(;;){
        buf = recvp(c);
        cmd = parsewctl(&arg, ZR, &rect, &pid, &id, &hideit, &scrollit, &dir, buf, err);

        switch(cmd){
        case New:
            wctlnew(rect, arg, pid, hideit, scrollit, dir, err);
        }
        free(buf);
    }
}
@

<<function wctlproc>>=
void
wctlproc(void *v)
{
    char *buf;
    int n, eofs;
    Channel *c;

    threadsetname("WCTLPROC");
    c = v;

    eofs = 0;
    for(;;){
        buf = emalloc(messagesize);
        n = read(wctlfd, buf, messagesize-1);	/* room for \0 */
        if(n < 0)
            break;
        if(n == 0){
            if(++eofs > 20)
                break;
            continue;
        }
        eofs = 0;

        buf[n] = '\0';
        sendp(c, buf);
    }
}
@


%-------------------------------------------------------------

<<windows/rio/wctl.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <cursor.h>
#include <mouse.h>
#include <keyboard.h>
#include <frame.h>
#include <fcall.h>
#include <plumb.h>

#include "dat.h"
#include "fns.h"

#include <ctype.h>

<<global Ebadwr>>
<<global Ewalloc>>

<<enum _anon_ (windows/rio/wctl.c)>>

<<global cmds>>

<<enum _anon_ (windows/rio/wctl.c)2>>

<<global params>>

<<function goodrect>>

<<function word>>

<<function set>>

<<function newrect>>

<<function shift>>

<<function rectonscreen>>

<<function riostrtol>>


<<function parsewctl>>

<<function wctlnew>>

<<function writewctl>>

<<function wctlthread>>

<<function wctlproc>>
@


\subsection*{[[windows/rio/wind.c]]}

<<enum _anon_ (windows/rio/wind.c)>>=
enum
{
    HiWater	= 640000,	/* max size of history */
    LoWater	= 400000,	/* min size of history after max'ed */
    MinWater	= 20000,	/* room to leave available when reallocating */
};
@

<<global topped>>=
static	int		topped;
@

<<global id>>=
static	int		id;
@

<<global cols>>=
static	Image	*cols[NCOL];
@

<<global grey>>=
static	Image	*grey;
@

<<global darkgrey>>=
static	Image	*darkgrey;
@

<<global lastcursor>>=
static	Cursor	*lastcursor;
@

<<global titlecol>>=
static	Image	*titlecol;
@

<<global lighttitlecol>>=
static	Image	*lighttitlecol;
@

<<global holdcol>>=
static	Image	*holdcol;
@

<<global lightholdcol>>=
static	Image	*lightholdcol;
@

<<global paleholdcol>>=
static	Image	*paleholdcol;
@

<<function wmk>>=
Window*
wmk(Image *i, Mousectl *mc, Channel *ck, Channel *cctl, int scrolling)
{
    Window *w;
    Rectangle r;

    if(cols[0] == nil){
        /* greys are multiples of 0x11111100+0xFF, 14* being palest */
        grey = allocimage(display, Rect(0,0,1,1), CMAP8, 1, 0xEEEEEEFF);
        darkgrey = allocimage(display, Rect(0,0,1,1), CMAP8, 1, 0x666666FF);
        cols[BACK] = display->white;
        cols[HIGH] = allocimage(display, Rect(0,0,1,1), CMAP8, 1, 0xCCCCCCFF);
        cols[BORD] = allocimage(display, Rect(0,0,1,1), CMAP8, 1, 0x999999FF);
        cols[TEXT] = display->black;
        cols[HTEXT] = display->black;
        titlecol = allocimage(display, Rect(0,0,1,1), CMAP8, 1, DGreygreen);
        lighttitlecol = allocimage(display, Rect(0,0,1,1), CMAP8, 1, DPalegreygreen);
        holdcol = allocimage(display, Rect(0,0,1,1), CMAP8, 1, DMedblue);
        lightholdcol = allocimage(display, Rect(0,0,1,1), CMAP8, 1, DGreyblue);
        paleholdcol = allocimage(display, Rect(0,0,1,1), CMAP8, 1, DPalegreyblue);
    }
    w = emalloc(sizeof(Window));
    w->screenr = i->r;
    r = insetrect(i->r, Selborder+1);
    w->i = i;
    w->mc = *mc;
    w->ck = ck;
    w->cctl = cctl;
    w->cursorp = nil;
    w->conswrite = chancreate(sizeof(Conswritemesg), 0);
    w->consread =  chancreate(sizeof(Consreadmesg), 0);
    w->mouseread =  chancreate(sizeof(Mousereadmesg), 0);
    w->wctlread =  chancreate(sizeof(Consreadmesg), 0);
    w->scrollr = r;
    w->scrollr.max.x = r.min.x+Scrollwid;
    w->lastsr = ZR;
    r.min.x += Scrollwid+Scrollgap;
    frinit(w, r, font, i, cols);
    w->maxtab = maxtab*stringwidth(font, "0");
    w->topped = ++topped;
    w->id = ++id;
    w->notefd = -1;
    w->scrolling = scrolling;
    w->dir = estrdup(startdir);
    w->label = estrdup("<unnamed>");
    r = insetrect(w->i->r, Selborder);
    draw(w->i, r, cols[BACK], nil, w->entire.min);
    wborder(w, Selborder);
    wscrdraw(w);
    incref(w);	/* ref will be removed after mounting; avoids delete before ready to be deleted */
    return w;
}
@

<<function wsetname>>=
void
wsetname(Window *w)
{
    int i, n;
    char err[ERRMAX];
    
    n = sprint(w->name, "window.%d.%d", w->id, w->namecount++);
    for(i='A'; i<='Z'; i++){
        if(nameimage(w->i, w->name, 1) > 0)
            return;
        errstr(err, sizeof err);
        if(strcmp(err, "image name in use") != 0)
            break;
        w->name[n] = i;
        w->name[n+1] = 0;
    }
    w->name[0] = 0;
    fprint(2, "rio: setname failed: %s\n", err);
}
@

<<function wresize>>=
void
wresize(Window *w, Image *i, int move)
{
    Rectangle r, or;

    or = w->i->r;
    if(move || (Dx(or)==Dx(i->r) && Dy(or)==Dy(i->r)))
        draw(i, i->r, w->i, nil, w->i->r.min);
    freeimage(w->i);
    w->i = i;
    wsetname(w);
    w->mc.image = i;
    r = insetrect(i->r, Selborder+1);
    w->scrollr = r;
    w->scrollr.max.x = r.min.x+Scrollwid;
    w->lastsr = ZR;
    r.min.x += Scrollwid+Scrollgap;
    if(move)
        frsetrects(w, r, w->i);
    else{
        frclear(w, FALSE);
        frinit(w, r, w->font, w->i, cols);
        wsetcols(w);
        w->maxtab = maxtab*stringwidth(w->font, "0");
        r = insetrect(w->i->r, Selborder);
        draw(w->i, r, cols[BACK], nil, w->entire.min);
        wfill(w);
        wsetselect(w, w->q0, w->q1);
        wscrdraw(w);
    }
    wborder(w, Selborder);
    w->topped = ++topped;
    w->resized = TRUE;
    w->mouse.counter++;
}
@

<<function wrefresh>>=
void
wrefresh(Window *w, Rectangle)
{
    /* BUG: rectangle is ignored */
    if(w == input)
        wborder(w, Selborder);
    else
        wborder(w, Unselborder);
    if(w->mouseopen)
        return;
    draw(w->i, insetrect(w->i->r, Borderwidth), w->cols[BACK], nil, w->i->r.min);
    w->ticked = 0;
    if(w->p0 > 0)
        frdrawsel(w, frptofchar(w, 0), 0, w->p0, 0);
    if(w->p1 < w->nchars)
        frdrawsel(w, frptofchar(w, w->p1), w->p1, w->nchars, 0);
    frdrawsel(w, frptofchar(w, w->p0), w->p0, w->p1, 1);
    w->lastsr = ZR;
    wscrdraw(w);
}
@

<<function wclose>>=
int
wclose(Window *w)
{
    int i;

    i = decref(w);
    if(i > 0)
        return 0;
    if(i < 0)
        error("negative ref count");
    if(!w->deleted)
        wclosewin(w);
    wsendctlmesg(w, Exited, ZR, nil);
    return 1;
}
@

<<function winctl>>=
void
winctl(void *arg)
{
    Rune *rp, *bp, *tp, *up, *kbdr;
    uint qh;
    int nr, nb, c, wid, i, npart, initial, lastb;
    char *s, *t, part[3];
    Window *w;
    Mousestate *mp, m;
    enum { WKey, WMouse, WMouseread, WCtl, WCwrite, WCread, WWread, NWALT };
    Alt alts[NWALT+1];
    Mousereadmesg mrm;
    Conswritemesg cwm;
    Consreadmesg crm;
    Consreadmesg cwrm;
    Stringpair pair;
    Wctlmesg wcm;
    char buf[4*12+1];

    w = arg;
    snprint(buf, sizeof buf, "winctl-id%d", w->id);
    threadsetname(buf);

    mrm.cm = chancreate(sizeof(Mouse), 0);
    cwm.cw = chancreate(sizeof(Stringpair), 0);
    crm.c1 = chancreate(sizeof(Stringpair), 0);
    crm.c2 = chancreate(sizeof(Stringpair), 0);
    cwrm.c1 = chancreate(sizeof(Stringpair), 0);
    cwrm.c2 = chancreate(sizeof(Stringpair), 0);
    

    alts[WKey].c = w->ck;
    alts[WKey].v = &kbdr;
    alts[WKey].op = CHANRCV;
    alts[WMouse].c = w->mc.c;
    alts[WMouse].v = &w->mc.Mouse;
    alts[WMouse].op = CHANRCV;
    alts[WMouseread].c = w->mouseread;
    alts[WMouseread].v = &mrm;
    alts[WMouseread].op = CHANSND;
    alts[WCtl].c = w->cctl;
    alts[WCtl].v = &wcm;
    alts[WCtl].op = CHANRCV;
    alts[WCwrite].c = w->conswrite;
    alts[WCwrite].v = &cwm;
    alts[WCwrite].op = CHANSND;
    alts[WCread].c = w->consread;
    alts[WCread].v = &crm;
    alts[WCread].op = CHANSND;
    alts[WWread].c = w->wctlread;
    alts[WWread].v = &cwrm;
    alts[WWread].op = CHANSND;
    alts[NWALT].op = CHANEND;

    npart = 0;
    lastb = -1;
    for(;;){
        if(w->mouseopen && w->mouse.counter != w->mouse.lastcounter)
            alts[WMouseread].op = CHANSND;
        else
            alts[WMouseread].op = CHANNOP;
        if(!w->scrolling && !w->mouseopen && w->qh>w->org+w->nchars)
            alts[WCwrite].op = CHANNOP;
        else
            alts[WCwrite].op = CHANSND;
        if(w->deleted || !w->wctlready)
            alts[WWread].op = CHANNOP;
        else
            alts[WWread].op = CHANSND;
        /* this code depends on NL and EOT fitting in a single byte */
        /* kind of expensive for each loop; worth precomputing? */
        if(w->holding)
            alts[WCread].op = CHANNOP;
        else if(npart || (w->rawing && w->nraw>0))
            alts[WCread].op = CHANSND;
        else{
            alts[WCread].op = CHANNOP;
            for(i=w->qh; i<w->nr; i++){
                c = w->r[i];
                if(c=='\n' || c=='\004'){
                    alts[WCread].op = CHANSND;
                    break;
                }
            }
        }
        switch(alt(alts)){
        case WKey:
            for(i=0; kbdr[i]!=L'\0'; i++)
                wkeyctl(w, kbdr[i]);
//			wkeyctl(w, r);
///			while(nbrecv(w->ck, &r))
//				wkeyctl(w, r);
            break;
        case WMouse:
            if(w->mouseopen) {
                w->mouse.counter++;

                /* queue click events */
                if(!w->mouse.qfull && lastb != w->mc.buttons) {	/* add to ring */
                    mp = &w->mouse.queue[w->mouse.wi];
                    if(++w->mouse.wi == nelem(w->mouse.queue))
                        w->mouse.wi = 0;
                    if(w->mouse.wi == w->mouse.ri)
                        w->mouse.qfull = TRUE;
                    mp->Mouse = w->mc;
                    mp->counter = w->mouse.counter;
                    lastb = w->mc.buttons;
                }
            } else
                wmousectl(w);
            break;
        case WMouseread:
            /* send a queued event or, if the queue is empty, the current state */
            /* if the queue has filled, we discard all the events it contained. */
            /* the intent is to discard frantic clicking by the user during long latencies. */
            w->mouse.qfull = FALSE;
            if(w->mouse.wi != w->mouse.ri) {
                m = w->mouse.queue[w->mouse.ri];
                if(++w->mouse.ri == nelem(w->mouse.queue))
                    w->mouse.ri = 0;
            } else
                m = (Mousestate){w->mc.Mouse, w->mouse.counter};

            w->mouse.lastcounter = m.counter;
            send(mrm.cm, &m.Mouse);
            continue;
        case WCtl:
            if(wctlmesg(w, wcm.type, wcm.r, wcm.image) == Exited){
                chanfree(crm.c1);
                chanfree(crm.c2);
                chanfree(mrm.cm);
                chanfree(cwm.cw);
                chanfree(cwrm.c1);
                chanfree(cwrm.c2);
                threadexits(nil);
            }
            continue;
        case WCwrite:
            recv(cwm.cw, &pair);
            rp = pair.s;
            nr = pair.ns;
            bp = rp;
            for(i=0; i<nr; i++)
                if(*bp++ == '\b'){
                    --bp;
                    initial = 0;
                    tp = runemalloc(nr);
                    runemove(tp, rp, i);
                    up = tp+i;
                    for(; i<nr; i++){
                        *up = *bp++;
                        if(*up == '\b')
                            if(up == tp)
                                initial++;
                            else
                                --up;
                        else
                            up++;
                    }
                    if(initial){
                        if(initial > w->qh)
                            initial = w->qh;
                        qh = w->qh-initial;
                        wdelete(w, qh, qh+initial);
                        w->qh = qh;
                    }
                    free(rp);
                    rp = tp;
                    nr = up-tp;
                    rp[nr] = 0;
                    break;
                }
            w->qh = winsert(w, rp, nr, w->qh)+nr;
            if(w->scrolling || w->mouseopen)
                wshow(w, w->qh);
            wsetselect(w, w->q0, w->q1);
            wscrdraw(w);
            free(rp);
            break;
        case WCread:
            recv(crm.c1, &pair);
            t = pair.s;
            nb = pair.ns;
            i = npart;
            npart = 0;
            if(i)
                memmove(t, part, i);
            while(i<nb && (w->qh<w->nr || w->nraw>0)){
                if(w->qh == w->nr){
                    wid = runetochar(t+i, &w->raw[0]);
                    w->nraw--;
                    runemove(w->raw, w->raw+1, w->nraw);
                }else
                    wid = runetochar(t+i, &w->r[w->qh++]);
                c = t[i];	/* knows break characters fit in a byte */
                i += wid;
                if(!w->rawing && (c == '\n' || c=='\004')){
                    if(c == '\004')
                        i--;
                    break;
                }
            }
            if(i==nb && w->qh<w->nr && w->r[w->qh]=='\004')
                w->qh++;
            if(i > nb){
                npart = i-nb;
                memmove(part, t+nb, npart);
                i = nb;
            }
            pair.s = t;
            pair.ns = i;
            send(crm.c2, &pair);
            continue;
        case WWread:
            w->wctlready = 0;
            recv(cwrm.c1, &pair);
            if(w->deleted || w->i==nil)
                pair.ns = sprint(pair.s, "");
            else{
                s = "visible";
                for(i=0; i<nhidden; i++)
                    if(hidden[i] == w){
                        s = "hidden";
                        break;
                    }
                t = "notcurrent";
                if(w == input)
                    t = "current";
                pair.ns = snprint(pair.s, pair.ns, "%11d %11d %11d %11d %s %s ",
                    w->i->r.min.x, w->i->r.min.y, w->i->r.max.x, w->i->r.max.y, t, s);
            }
            send(cwrm.c2, &pair);
            continue;
        }
        if(!w->deleted)
            flushimage(display, 1);
    }
}
@

<<function waddraw>>=
void
waddraw(Window *w, Rune *r, int nr)
{
    w->raw = runerealloc(w->raw, w->nraw+nr);
    runemove(w->raw+w->nraw, r, nr);
    w->nraw += nr;
}
@

<<function interruptproc>>=
/*
 * Need to do this in a separate proc because if process we're interrupting
 * is dying and trying to print tombstone, kernel is blocked holding p->debug lock.
 */
void
interruptproc(void *v)
{
    int *notefd;

    notefd = v;
    write(*notefd, "interrupt", 9);
    free(notefd);
}
@

<<function windfilewidth>>=
int
windfilewidth(Window *w, uint q0, int oneelement)
{
    uint q;
    Rune r;

    q = q0;
    while(q > 0){
        r = w->r[q-1];
        if(r<=' ')
            break;
        if(oneelement && r=='/')
            break;
        --q;
    }
    return q0-q;
}
@

<<function showcandidates>>=
void
showcandidates(Window *w, Completion *c)
{
    int i;
    Fmt f;
    Rune *rp;
    uint nr, qline, q0;
    char *s;

    runefmtstrinit(&f);
    if (c->nmatch == 0)
        s = "[no matches in ";
    else
        s = "[";
    if(c->nfile > 32)
        fmtprint(&f, "%s%d files]\n", s, c->nfile);
    else{
        fmtprint(&f, "%s", s);
        for(i=0; i<c->nfile; i++){
            if(i > 0)
                fmtprint(&f, " ");
            fmtprint(&f, "%s", c->filename[i]);
        }
        fmtprint(&f, "]\n");
    }
    /* place text at beginning of line before host point */
    qline = w->qh;
    while(qline>0 && w->r[qline-1] != '\n')
        qline--;

    rp = runefmtstrflush(&f);
    nr = runestrlen(rp);

    q0 = w->q0;
    q0 += winsert(w, rp, runestrlen(rp), qline) - qline;
    free(rp);
    wsetselect(w, q0+nr, q0+nr);
}
@

<<function namecomplete>>=
Rune*
namecomplete(Window *w)
{
    int nstr, npath;
    Rune *rp, *path, *str;
    Completion *c;
    char *s, *dir, *root;

    /* control-f: filename completion; works back to white space or / */
    if(w->q0<w->nr && w->r[w->q0]>' ')	/* must be at end of word */
        return nil;
    nstr = windfilewidth(w, w->q0, TRUE);
    str = runemalloc(nstr);
    runemove(str, w->r+(w->q0-nstr), nstr);
    npath = windfilewidth(w, w->q0-nstr, FALSE);
    path = runemalloc(npath);
    runemove(path, w->r+(w->q0-nstr-npath), npath);
    rp = nil;

    /* is path rooted? if not, we need to make it relative to window path */
    if(npath>0 && path[0]=='/'){
        dir = malloc(UTFmax*npath+1);
        sprint(dir, "%.*S", npath, path);
    }else{
        if(strcmp(w->dir, "") == 0)
            root = ".";
        else
            root = w->dir;
        dir = malloc(strlen(root)+1+UTFmax*npath+1);
        sprint(dir, "%s/%.*S", root, npath, path);
    }
    dir = cleanname(dir);

    s = smprint("%.*S", nstr, str);
    c = complete(dir, s);
    free(s);
    if(c == nil)
        goto Return;

    if(!c->advance)
        showcandidates(w, c);

    if(c->advance)
        rp = runesmprint("%s", c->string);

  Return:
    freecompletion(c);
    free(dir);
    free(path);
    free(str);
    return rp;
}
@

<<function wkeyctl>>=
void
wkeyctl(Window *w, Rune r)
{
    uint q0 ,q1;
    int n, nb, nr;
    Rune *rp;
    int *notefd;

    if(r == 0)
        return;
    if(w->deleted)
        return;
    /* navigation keys work only when mouse is not open */
    if(!w->mouseopen)
        switch(r){
        case Kdown:
            n = w->maxlines/3;
            goto case_Down;
        case Kscrollonedown:
            n = mousescrollsize(w->maxlines);
            if(n <= 0)
                n = 1;
            goto case_Down;
        case Kpgdown:
            n = 2*w->maxlines/3;
        case_Down:
            q0 = w->org+frcharofpt(w, Pt(w->Frame.r.min.x, w->Frame.r.min.y+n*w->font->height));
            wsetorigin(w, q0, TRUE);
            return;
        case Kup:
            n = w->maxlines/3;
            goto case_Up;
        case Kscrolloneup:
            n = mousescrollsize(w->maxlines);
            if(n <= 0)
                n = 1;
            goto case_Up;
        case Kpgup:
            n = 2*w->maxlines/3;
        case_Up:
            q0 = wbacknl(w, w->org, n);
            wsetorigin(w, q0, TRUE);
            return;
        case Kleft:
            if(w->q0 > 0){
                q0 = w->q0-1;
                wsetselect(w, q0, q0);
                wshow(w, q0);
            }
            return;
        case Kright:
            if(w->q1 < w->nr){
                q1 = w->q1+1;
                wsetselect(w, q1, q1);
                wshow(w, q1);
            }
            return;
        case Khome:
            wshow(w, 0);
            return;
        case Kend:
            wshow(w, w->nr);
            return;
        case 0x01:	/* ^A: beginning of line */
            if(w->q0==0 || w->q0==w->qh || w->r[w->q0-1]=='\n')
                return;
            nb = wbswidth(w, 0x15 /* ^U */);
            wsetselect(w, w->q0-nb, w->q0-nb);
            wshow(w, w->q0);
            return;
        case 0x05:	/* ^E: end of line */
            q0 = w->q0;
            while(q0 < w->nr && w->r[q0]!='\n')
                q0++;
            wsetselect(w, q0, q0);
            wshow(w, w->q0);
            return;
        }
    if(w->rawing && (w->q0==w->nr || w->mouseopen)){
        waddraw(w, &r, 1);
        return;
    }
    if(r==0x1B || (w->holding && r==0x7F)){	/* toggle hold */
        if(w->holding)
            --w->holding;
        else
            w->holding++;
        wrepaint(w);
        if(r == 0x1B)
            return;
    }
    if(r != 0x7F){
        wsnarf(w);
        wcut(w);
    }
    switch(r){
    case 0x7F:		/* send interrupt */
        w->qh = w->nr;
        wshow(w, w->qh);
        notefd = emalloc(sizeof(int));
        *notefd = w->notefd;
        proccreate(interruptproc, notefd, 4096);
        return;
    case 0x06:	/* ^F: file name completion */
    case Kins:		/* Insert: file name completion */
        rp = namecomplete(w);
        if(rp == nil)
            return;
        nr = runestrlen(rp);
        q0 = w->q0;
        q0 = winsert(w, rp, nr, q0);
        wshow(w, q0+nr);
        free(rp);
        return;
    case 0x08:	/* ^H: erase character */
    case 0x15:	/* ^U: erase line */
    case 0x17:	/* ^W: erase word */
        if(w->q0==0 || w->q0==w->qh)
            return;
        nb = wbswidth(w, r);
        q1 = w->q0;
        q0 = q1-nb;
        if(q0 < w->org){
            q0 = w->org;
            nb = q1-q0;
        }
        if(nb > 0){
            wdelete(w, q0, q0+nb);
            wsetselect(w, q0, q0);
        }
        return;
    }
    /* otherwise ordinary character; just insert */
    q0 = w->q0;
    q0 = winsert(w, &r, 1, q0);
    wshow(w, q0+1);
}
@

<<function wsetcols>>=
void
wsetcols(Window *w)
{
    if(w->holding)
        if(w == input)
            w->cols[TEXT] = w->cols[HTEXT] = holdcol;
        else
            w->cols[TEXT] = w->cols[HTEXT] = lightholdcol;
    else
        if(w == input)
            w->cols[TEXT] = w->cols[HTEXT] = display->black;
        else
            w->cols[TEXT] = w->cols[HTEXT] = darkgrey;
}
@

<<function wrepaint>>=
void
wrepaint(Window *w)
{
    wsetcols(w);
    if(!w->mouseopen)
        frredraw(w);
    if(w == input){
        wborder(w, Selborder);
        wsetcursor(w, 0);
    }else
        wborder(w, Unselborder);
}
@

<<function wbswidth>>=
int
wbswidth(Window *w, Rune c)
{
    uint q, eq, stop;
    Rune r;
    int skipping;

    /* there is known to be at least one character to erase */
    if(c == 0x08)	/* ^H: erase character */
        return 1;
    q = w->q0;
    stop = 0;
    if(q > w->qh)
        stop = w->qh;
    skipping = TRUE;
    while(q > stop){
        r = w->r[q-1];
        if(r == '\n'){		/* eat at most one more character */
            if(q == w->q0)	/* eat the newline */
                --q;
            break; 
        }
        if(c == 0x17){
            eq = isalnum(r);
            if(eq && skipping)	/* found one; stop skipping */
                skipping = FALSE;
            else if(!eq && !skipping)
                break;
        }
        --q;
    }
    return w->q0-q;
}
@

<<function wsnarf>>=
void
wsnarf(Window *w)
{
    if(w->q1 == w->q0)
        return;
    nsnarf = w->q1-w->q0;
    snarf = runerealloc(snarf, nsnarf);
    snarfversion++;	/* maybe modified by parent */
    runemove(snarf, w->r+w->q0, nsnarf);
    putsnarf();
}
@

<<function wcut>>=
void
wcut(Window *w)
{
    if(w->q1 == w->q0)
        return;
    wdelete(w, w->q0, w->q1);
    wsetselect(w, w->q0, w->q0);
}
@

<<function wpaste>>=
void
wpaste(Window *w)
{
    uint q0;

    if(nsnarf == 0)
        return;
    wcut(w);
    q0 = w->q0;
    if(w->rawing && q0==w->nr){
        waddraw(w, snarf, nsnarf);
        wsetselect(w, q0, q0);
    }else{
        q0 = winsert(w, snarf, nsnarf, w->q0);
        wsetselect(w, q0, q0+nsnarf);
    }
}
@

<<function wplumb>>=
void
wplumb(Window *w)
{
    Plumbmsg *m;
    static int fd = -2;
    char buf[32];
    uint p0, p1;
    Cursor *c;

    if(fd == -2)
        fd = plumbopen("send", OWRITE|OCEXEC);
    if(fd < 0)
        return;
    m = emalloc(sizeof(Plumbmsg));
    m->src = estrdup("rio");
    m->dst = nil;
    m->wdir = estrdup(w->dir);
    m->type = estrdup("text");
    p0 = w->q0;
    p1 = w->q1;
    if(w->q1 > w->q0)
        m->attr = nil;
    else{
        while(p0>0 && w->r[p0-1]!=' ' && w->r[p0-1]!='\t' && w->r[p0-1]!='\n')
            p0--;
        while(p1<w->nr && w->r[p1]!=' ' && w->r[p1]!='\t' && w->r[p1]!='\n')
            p1++;
        sprint(buf, "click=%d", w->q0-p0);
        m->attr = plumbunpackattr(buf);
    }
    if(p1-p0 > messagesize-1024){
        plumbfree(m);
        return;	/* too large for 9P */
    }
    m->data = runetobyte(w->r+p0, p1-p0, &m->ndata);
    if(plumbsend(fd, m) < 0){
        c = lastcursor;
        riosetcursor(&query, 1);
        sleep(300);
        riosetcursor(c, 1);
    }
    plumbfree(m);
}
@

<<function winborder>>=
int
winborder(Window *w, Point xy)
{
    return ptinrect(xy, w->screenr) && !ptinrect(xy, insetrect(w->screenr, Selborder));
}
@

<<function wmousectl>>=
void
wmousectl(Window *w)
{
    int but;

    if(w->mc.buttons == 1)
        but = 1;
    else if(w->mc.buttons == 2)
        but = 2;
    else if(w->mc.buttons == 4)
        but = 3;
    else{
        if(w->mc.buttons == 8)
            wkeyctl(w, Kscrolloneup);
        if(w->mc.buttons == 16)
            wkeyctl(w, Kscrollonedown);
        return;
    }

    incref(w);		/* hold up window while we track */
    if(w->deleted)
        goto Return;
    if(ptinrect(w->mc.xy, w->scrollr)){
        if(but)
            wscroll(w, but);
        goto Return;
    }
    if(but == 1)
        wselect(w);
    /* else all is handled by main process */
   Return:
    wclose(w);
}
@

<<function wdelete>>=
void
wdelete(Window *w, uint q0, uint q1)
{
    uint n, p0, p1;

    n = q1-q0;
    if(n == 0)
        return;
    runemove(w->r+q0, w->r+q1, w->nr-q1);
    w->nr -= n;
    if(q0 < w->q0)
        w->q0 -= min(n, w->q0-q0);
    if(q0 < w->q1)
        w->q1 -= min(n, w->q1-q0);
    if(q1 < w->qh)
        w->qh -= n;
    else if(q0 < w->qh)
        w->qh = q0;
    if(q1 <= w->org)
        w->org -= n;
    else if(q0 < w->org+w->nchars){
        p1 = q1 - w->org;
        if(p1 > w->nchars)
            p1 = w->nchars;
        if(q0 < w->org){
            w->org = q0;
            p0 = 0;
        }else
            p0 = q0 - w->org;
        frdelete(w, p0, p1);
        wfill(w);
    }
}
@

<<global clickwin>>=
static Window	*clickwin;
@

<<global clickmsec>>=
static uint	clickmsec;
@

<<global selectwin>>=
static Window	*selectwin;
@

<<global selectq>>=
static uint	selectq;
@

<<function framescroll>>=
/*
 * called from frame library
 */
void
framescroll(Frame *f, int dl)
{
    if(f != &selectwin->Frame)
        error("frameselect not right frame");
    wframescroll(selectwin, dl);
}
@

<<function wframescroll>>=
void
wframescroll(Window *w, int dl)
{
    uint q0;

    if(dl == 0){
        wscrsleep(w, 100);
        return;
    }
    if(dl < 0){
        q0 = wbacknl(w, w->org, -dl);
        if(selectq > w->org+w->p0)
            wsetselect(w, w->org+w->p0, selectq);
        else
            wsetselect(w, selectq, w->org+w->p0);
    }else{
        if(w->org+w->nchars == w->nr)
            return;
        q0 = w->org+frcharofpt(w, Pt(w->Frame.r.min.x, w->Frame.r.min.y+dl*w->font->height));
        if(selectq >= w->org+w->p1)
            wsetselect(w, w->org+w->p1, selectq);
        else
            wsetselect(w, selectq, w->org+w->p1);
    }
    wsetorigin(w, q0, TRUE);
}
@

<<function wselect>>=
void
wselect(Window *w)
{
    uint q0, q1;
    int b, x, y, first;

    first = 1;
    selectwin = w;
    /*
     * Double-click immediately if it might make sense.
     */
    b = w->mc.buttons;
    q0 = w->q0;
    q1 = w->q1;
    selectq = w->org+frcharofpt(w, w->mc.xy);
    if(clickwin==w && w->mc.msec-clickmsec<500)
    if(q0==q1 && selectq==w->q0){
        wdoubleclick(w, &q0, &q1);
        wsetselect(w, q0, q1);
        flushimage(display, 1);
        x = w->mc.xy.x;
        y = w->mc.xy.y;
        /* stay here until something interesting happens */
        do
            readmouse(&w->mc);
        while(w->mc.buttons==b && abs(w->mc.xy.x-x)<3 && abs(w->mc.xy.y-y)<3);
        w->mc.xy.x = x;	/* in case we're calling frselect */
        w->mc.xy.y = y;
        q0 = w->q0;	/* may have changed */
        q1 = w->q1;
        selectq = q0;
    }
    if(w->mc.buttons == b){
        w->scroll = framescroll;
        frselect(w, &w->mc);
        /* horrible botch: while asleep, may have lost selection altogether */
        if(selectq > w->nr)
            selectq = w->org + w->p0;
        w->Frame.scroll = nil;
        if(selectq < w->org)
            q0 = selectq;
        else
            q0 = w->org + w->p0;
        if(selectq > w->org+w->nchars)
            q1 = selectq;
        else
            q1 = w->org+w->p1;
    }
    if(q0 == q1){
        if(q0==w->q0 && clickwin==w && w->mc.msec-clickmsec<500){
            wdoubleclick(w, &q0, &q1);
            clickwin = nil;
        }else{
            clickwin = w;
            clickmsec = w->mc.msec;
        }
    }else
        clickwin = nil;
    wsetselect(w, q0, q1);
    flushimage(display, 1);
    while(w->mc.buttons){
        w->mc.msec = 0;
        b = w->mc.buttons;
        if(b & 6){
            if(b & 2){
                wsnarf(w);
                wcut(w);
            }else{
                if(first){
                    first = 0;
                    getsnarf();
                }
                wpaste(w);
            }
        }
        wscrdraw(w);
        flushimage(display, 1);
        while(w->mc.buttons == b)
            readmouse(&w->mc);
        clickwin = nil;
    }
}
@

<<function wsendctlmesg>>=
void
wsendctlmesg(Window *w, int type, Rectangle r, Image *image)
{
    Wctlmesg wcm;

    wcm.type = type;
    wcm.r = r;
    wcm.image = image;
    send(w->cctl, &wcm);
}
@

<<function wctlmesg>>=
int
wctlmesg(Window *w, int m, Rectangle r, Image *i)
{
    char buf[64];

    switch(m){
    default:
        error("unknown control message");
        break;
    case Wakeup:
        break;
    case Moved:
    case Reshaped:
        if(w->deleted){
            freeimage(i);
            break;
        }
        w->screenr = r;
        strcpy(buf, w->name);
        wresize(w, i, m==Moved);
        w->wctlready = 1;
        proccreate(deletetimeoutproc, estrdup(buf), 4096);
        if(Dx(r) > 0){
            if(w != input)
                wcurrent(w);
        }else if(w == input)
            wcurrent(nil);
        flushimage(display, 1);
        break;
    case Refresh:
        if(w->deleted || Dx(w->screenr)<=0 || !rectclip(&r, w->i->r))
            break;
        if(!w->mouseopen)
            wrefresh(w, r);
        flushimage(display, 1);
        break;
    case Movemouse:
        if(sweeping || !ptinrect(r.min, w->i->r))
            break;
        wmovemouse(w, r.min);
    case Rawon:
        break;
    case Rawoff:
        if(w->deleted)
            break;
        while(w->nraw > 0){
            wkeyctl(w, w->raw[0]);
            --w->nraw;
            runemove(w->raw, w->raw+1, w->nraw);
        }
        break;
    case Holdon:
    case Holdoff:
        if(w->deleted)
            break;
        wrepaint(w);
        flushimage(display, 1);
        break;
    case Deleted:
        if(w->deleted)
            break;
        write(w->notefd, "hangup", 6);
        proccreate(deletetimeoutproc, estrdup(w->name), 4096);
        wclosewin(w);
        break;
    case Exited:
        frclear(w, TRUE);
        close(w->notefd);
        chanfree(w->mc.c);
        chanfree(w->ck);
        chanfree(w->cctl);
        chanfree(w->conswrite);
        chanfree(w->consread);
        chanfree(w->mouseread);
        chanfree(w->wctlread);
        free(w->raw);
        free(w->r);
        free(w->dir);
        free(w->label);
        free(w);
        break;
    }
    return m;
}
@

<<function wmovemouse>>=
/*
 * Convert back to physical coordinates
 */
void
wmovemouse(Window *w, Point p)
{
    p.x += w->screenr.min.x-w->i->r.min.x;
    p.y += w->screenr.min.y-w->i->r.min.y;
    moveto(mousectl, p);
}
@

<<function wborder>>=
void
wborder(Window *w, int type)
{
    Image *col;

    if(w->i == nil)
        return;
    if(w->holding){
        if(type == Selborder)
            col = holdcol;
        else
            col = paleholdcol;
    }else{
        if(type == Selborder)
            col = titlecol;
        else
            col = lighttitlecol;
    }

    border(w->i, w->i->r, Selborder, col, ZP);
}
@

<<function wpointto>>=
Window*
wpointto(Point pt)
{
    int i;
    Window *v, *w;

    w = nil;
    for(i=0; i<nwindow; i++){
        v = window[i];
        if(ptinrect(pt, v->screenr))
        if(!v->deleted)
        if(w==nil || v->topped>w->topped)
            w = v;
    }
    return w;
}
@

<<function wcurrent>>=
void
wcurrent(Window *w)
{
    Window *oi;

    if(wkeyboard!=nil && w==wkeyboard)
        return;
    oi = input;
    input = w;
    if(oi!=w && oi!=nil)
        wrepaint(oi);
    if(w !=nil){
        wrepaint(w);
        wsetcursor(w, 0);
    }
    if(w != oi){
        if(oi){
            oi->wctlready = 1;
            wsendctlmesg(oi, Wakeup, ZR, nil);
        }
        if(w){
            w->wctlready = 1;
            wsendctlmesg(w, Wakeup, ZR, nil);
        }
    }
}
@

<<function wsetcursor>>=
void
wsetcursor(Window *w, int force)
{
    Cursor *p;

    if(w==nil || /*w!=input || */ w->i==nil || Dx(w->screenr)<=0)
        p = nil;
    else if(wpointto(mouse->xy) == w){
        p = w->cursorp;
        if(p==nil && w->holding)
            p = &whitearrow;
    }else
        p = nil;
    if(!menuing)
        riosetcursor(p, force && !menuing);
}
@

<<function riosetcursor>>=
void
riosetcursor(Cursor *p, int force)
{
    if(!force && p==lastcursor)
        return;
    setcursor(mousectl, p);
    lastcursor = p;
}
@

<<function wtop>>=
Window*
wtop(Point pt)
{
    Window *w;

    w = wpointto(pt);
    if(w){
        if(w->topped == topped)
            return nil;
        topwindow(w->i);
        wcurrent(w);
        flushimage(display, 1);
        w->topped = ++topped;
    }
    return w;
}
@

<<function wtopme>>=
void
wtopme(Window *w)
{
    if(w!=nil && w->i!=nil && !w->deleted && w->topped!=topped){
        topwindow(w->i);
        flushimage(display, 1);
        w->topped = ++ topped;
    }
}
@

<<function wbottomme>>=
void
wbottomme(Window *w)
{
    if(w!=nil && w->i!=nil && !w->deleted){
        bottomwindow(w->i);
        flushimage(display, 1);
        w->topped = - ++topped;
    }
}
@

<<function wlookid>>=
Window*
wlookid(int id)
{
    int i;

    for(i=0; i<nwindow; i++)
        if(window[i]->id == id)
            return window[i];
    return nil;
}
@

<<function wclosewin>>=
void
wclosewin(Window *w)
{
    Rectangle r;
    int i;

    w->deleted = TRUE;
    if(w == input){
        input = nil;
        wsetcursor(w, 0);
    }
    if(w == wkeyboard)
        wkeyboard = nil;
    for(i=0; i<nhidden; i++)
        if(hidden[i] == w){
            --nhidden;
            memmove(hidden+i, hidden+i+1, (nhidden-i)*sizeof(hidden[0]));
            hidden[nhidden] = nil;
            break;
        }
    for(i=0; i<nwindow; i++)
        if(window[i] == w){
            --nwindow;
            memmove(window+i, window+i+1, (nwindow-i)*sizeof(Window*));
            w->deleted = TRUE;
            r = w->i->r;
            /* move it off-screen to hide it, in case client is slow in letting it go */
            //if(0) originwindow(w->i, r.min, view->r.max);
            freeimage(w->i);
            w->i = nil;
            return;
        }
    error("unknown window in closewin");
}
@

<<function wsetpid>>=
void
wsetpid(Window *w, int pid, int dolabel)
{
    char buf[128];
    int fd;

    w->pid = pid;
    if(dolabel){
        sprint(buf, "rc %d", pid);
        free(w->label);
        w->label = estrdup(buf);
    }
    sprint(buf, "/proc/%d/notepg", pid);
    fd = open(buf, OWRITE|OCEXEC);
    if(w->notefd > 0)
        close(w->notefd);
    w->notefd = fd;
}
@

<<function winshell>>=
void
winshell(void *args)
{
    Window *w;
    Channel *pidc;
    void **arg;
    char *cmd, *dir;
    char **argv;

    arg = args;
    w = arg[0];
    pidc = arg[1];
    cmd = arg[2];
    argv = arg[3];
    dir = arg[4];
    rfork(RFNAMEG|RFFDG|RFENVG);
    if(filsysmount(filsys, w->id) < 0){
        fprint(2, "mount failed: %r\n");
        sendul(pidc, 0);
        threadexits("mount failed");
    }
    close(0);
    if(open("/dev/cons", OREAD) < 0){
        fprint(2, "can't open /dev/cons: %r\n");
        sendul(pidc, 0);
        threadexits("/dev/cons");
    }
    close(1);
    if(open("/dev/cons", OWRITE) < 0){
        fprint(2, "can't open /dev/cons: %r\n");
        sendul(pidc, 0);
        threadexits("open");	/* BUG? was terminate() */
    }
    if(wclose(w) == 0){	/* remove extra ref hanging from creation */
        notify(nil);
        dup(1, 2);
        if(dir)
            chdir(dir);
        procexec(pidc, cmd, argv);
        _exits("exec failed");
    }
}
@

<<global left1>>=
static Rune left1[] =  { L'{', L'[', L'(', L'<', L'Â«', 0 };
@

<<global right1>>=
static Rune right1[] = { L'}', L']', L')', L'>', L'Â»', 0 };
@

<<global left2>>=
static Rune left2[] =  { L'\n', 0 };
@

<<global left3>>=
static Rune left3[] =  { L'\'', L'"', L'`', 0 };
@

<<global left>>=
Rune *left[] = {
    left1,
    left2,
    left3,
    nil
};
@

<<global right>>=
Rune *right[] = {
    right1,
    left2,
    left3,
    nil
};
@

<<function wdoubleclick>>=
void
wdoubleclick(Window *w, uint *q0, uint *q1)
{
    int c, i;
    Rune *r, *l, *p;
    uint q;

    for(i=0; left[i]!=nil; i++){
        q = *q0;
        l = left[i];
        r = right[i];
        /* try matching character to left, looking right */
        if(q == 0)
            c = '\n';
        else
            c = w->r[q-1];
        p = strrune(l, c);
        if(p != nil){
            if(wclickmatch(w, c, r[p-l], 1, &q))
                *q1 = q-(c!='\n');
            return;
        }
        /* try matching character to right, looking left */
        if(q == w->nr)
            c = '\n';
        else
            c = w->r[q];
        p = strrune(r, c);
        if(p != nil){
            if(wclickmatch(w, c, l[p-r], -1, &q)){
                *q1 = *q0+(*q0<w->nr && c=='\n');
                *q0 = q;
                if(c!='\n' || q!=0 || w->r[0]=='\n')
                    (*q0)++;
            }
            return;
        }
    }
    /* try filling out word to right */
    while(*q1<w->nr && isalnum(w->r[*q1]))
        (*q1)++;
    /* try filling out word to left */
    while(*q0>0 && isalnum(w->r[*q0-1]))
        (*q0)--;
}
@

<<function wclickmatch>>=
int
wclickmatch(Window *w, int cl, int cr, int dir, uint *q)
{
    Rune c;
    int nest;

    nest = 1;
    for(;;){
        if(dir > 0){
            if(*q == w->nr)
                break;
            c = w->r[*q];
            (*q)++;
        }else{
            if(*q == 0)
                break;
            (*q)--;
            c = w->r[*q];
        }
        if(c == cr){
            if(--nest==0)
                return 1;
        }else if(c == cl)
            nest++;
    }
    return cl=='\n' && nest==1;
}
@

<<function wbacknl>>=
uint
wbacknl(Window *w, uint p, uint n)
{
    int i, j;

    /* look for start of this line if n==0 */
    if(n==0 && p>0 && w->r[p-1]!='\n')
        n = 1;
    i = n;
    while(i-->0 && p>0){
        --p;	/* it's at a newline now; back over it */
        if(p == 0)
            break;
        /* at 128 chars, call it a line anyway */
        for(j=128; --j>0 && p>0; p--)
            if(w->r[p-1]=='\n')
                break;
    }
    return p;
}
@

<<function wshow>>=
void
wshow(Window *w, uint q0)
{
    int qe;
    int nl;
    uint q;

    qe = w->org+w->nchars;
    if(w->org<=q0 && (q0<qe || (q0==qe && qe==w->nr)))
        wscrdraw(w);
    else{
        nl = 4*w->maxlines/5;
        q = wbacknl(w, q0, nl);
        /* avoid going backwards if trying to go forwards - long lines! */
        if(!(q0>w->org && q<w->org))
            wsetorigin(w, q, TRUE);
        while(q0 > w->org+w->nchars)
            wsetorigin(w, w->org+1, FALSE);
    }
}
@

<<function wsetorigin>>=
void
wsetorigin(Window *w, uint org, int exact)
{
    int i, a, fixup;
    Rune *r;
    uint n;

    if(org>0 && !exact){
        /* org is an estimate of the char posn; find a newline */
        /* don't try harder than 256 chars */
        for(i=0; i<256 && org<w->nr; i++){
            if(w->r[org] == '\n'){
                org++;
                break;
            }
            org++;
        }
    }
    a = org-w->org;
    fixup = 0;
    if(a>=0 && a<w->nchars){
        frdelete(w, 0, a);
        fixup = 1;	/* frdelete can leave end of last line in wrong selection mode; it doesn't know what follows */
    }else if(a<0 && -a<w->nchars){
        n = w->org - org;
        r = runemalloc(n);
        runemove(r, w->r+org, n);
        frinsert(w, r, r+n, 0);
        free(r);
    }else
        frdelete(w, 0, w->nchars);
    w->org = org;
    wfill(w);
    wscrdraw(w);
    wsetselect(w, w->q0, w->q1);
    if(fixup && w->p1 > w->p0)
        frdrawsel(w, frptofchar(w, w->p1-1), w->p1-1, w->p1, 1);
}
@

<<function wsetselect>>=
void
wsetselect(Window *w, uint q0, uint q1)
{
    int p0, p1;

    /* w->p0 and w->p1 are always right; w->q0 and w->q1 may be off */
    w->q0 = q0;
    w->q1 = q1;
    /* compute desired p0,p1 from q0,q1 */
    p0 = q0-w->org;
    p1 = q1-w->org;
    if(p0 < 0)
        p0 = 0;
    if(p1 < 0)
        p1 = 0;
    if(p0 > w->nchars)
        p0 = w->nchars;
    if(p1 > w->nchars)
        p1 = w->nchars;
    if(p0==w->p0 && p1==w->p1)
        return;
    /* screen disagrees with desired selection */
    if(w->p1<=p0 || p1<=w->p0 || p0==p1 || w->p1==w->p0){
        /* no overlap or too easy to bother trying */
        frdrawsel(w, frptofchar(w, w->p0), w->p0, w->p1, 0);
        frdrawsel(w, frptofchar(w, p0), p0, p1, 1);
        goto Return;
    }
    /* overlap; avoid unnecessary painting */
    if(p0 < w->p0){
        /* extend selection backwards */
        frdrawsel(w, frptofchar(w, p0), p0, w->p0, 1);
    }else if(p0 > w->p0){
        /* trim first part of selection */
        frdrawsel(w, frptofchar(w, w->p0), w->p0, p0, 0);
    }
    if(p1 > w->p1){
        /* extend selection forwards */
        frdrawsel(w, frptofchar(w, w->p1), w->p1, p1, 1);
    }else if(p1 < w->p1){
        /* trim last part of selection */
        frdrawsel(w, frptofchar(w, p1), p1, w->p1, 0);
    }

    Return:
    w->p0 = p0;
    w->p1 = p1;
}
@

<<function winsert>>=
uint
winsert(Window *w, Rune *r, int n, uint q0)
{
    uint m;

    if(n == 0)
        return q0;
    if(w->nr+n>HiWater && q0>=w->org && q0>=w->qh){
        m = min(HiWater-LoWater, min(w->org, w->qh));
        w->org -= m;
        w->qh -= m;
        if(w->q0 > m)
            w->q0 -= m;
        else
            w->q0 = 0;
        if(w->q1 > m)
            w->q1 -= m;
        else
            w->q1 = 0;
        w->nr -= m;
        runemove(w->r, w->r+m, w->nr);
        q0 -= m;
    }
    if(w->nr+n > w->maxr){
        /*
         * Minimize realloc breakage:
         *	Allocate at least MinWater
         * 	Double allocation size each time
         *	But don't go much above HiWater
         */
        m = max(min(2*(w->nr+n), HiWater), w->nr+n)+MinWater;
        if(m > HiWater)
            m = max(HiWater+MinWater, w->nr+n);
        if(m > w->maxr){
            w->r = runerealloc(w->r, m);
            w->maxr = m;
        }
    }
    runemove(w->r+q0+n, w->r+q0, w->nr-q0);
    runemove(w->r+q0, r, n);
    w->nr += n;
    /* if output touches, advance selection, not qh; works best for keyboard and output */
    if(q0 <= w->q1)
        w->q1 += n;
    if(q0 <= w->q0)
        w->q0 += n;
    if(q0 < w->qh)
        w->qh += n;
    if(q0 < w->org)
        w->org += n;
    else if(q0 <= w->org+w->nchars)
        frinsert(w, r, r+n, q0-w->org);
    return q0;
}
@

<<function wfill>>=
void
wfill(Window *w)
{
    Rune *rp;
    int i, n, m, nl;

    if(w->lastlinefull)
        return;
    rp = malloc(messagesize);
    do{
        n = w->nr-(w->org+w->nchars);
        if(n == 0)
            break;
        if(n > 2000)	/* educated guess at reasonable amount */
            n = 2000;
        runemove(rp, w->r+(w->org+w->nchars), n);
        /*
         * it's expensive to frinsert more than we need, so
         * count newlines.
         */
        nl = w->maxlines-w->nlines;
        m = 0;
        for(i=0; i<n; ){
            if(rp[i++] == '\n'){
                m++;
                if(m >= nl)
                    break;
            }
        }
        frinsert(w, rp, rp+i, w->nchars);
    }while(w->lastlinefull == FALSE);
    free(rp);
}
@

<<function wcontents>>=
char*
wcontents(Window *w, int *ip)
{
    return runetobyte(w->r, w->nr, ip);
}
@


%-------------------------------------------------------------

<<windows/rio/wind.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <cursor.h>
#include <mouse.h>
#include <keyboard.h>
#include <frame.h>
#include <fcall.h>
#include <plumb.h>

#include <complete.h>

#include "dat.h"
#include "fns.h"

<<enum _anon_ (windows/rio/wind.c)>>

<<global topped>>
<<global id>>

<<global cols>>
<<global grey>>
<<global darkgrey>>
<<global lastcursor>>
<<global titlecol>>
<<global lighttitlecol>>
<<global holdcol>>
<<global lightholdcol>>
<<global paleholdcol>>

<<function wmk>>

<<function wsetname>>

<<function wresize>>

<<function wrefresh>>

<<function wclose>>


<<function winctl>>

<<function waddraw>>

<<function interruptproc>>

<<function windfilewidth>>

<<function showcandidates>>

<<function namecomplete>>

<<function wkeyctl>>

<<function wsetcols>>

<<function wrepaint>>

<<function wbswidth>>

<<function wsnarf>>

<<function wcut>>

<<function wpaste>>

<<function wplumb>>

<<function winborder>>

<<function wmousectl>>

<<function wdelete>>


<<global clickwin>>
<<global clickmsec>>
<<global selectwin>>
<<global selectq>>

<<function framescroll>>

<<function wframescroll>>

<<function wselect>>

<<function wsendctlmesg>>

<<function wctlmesg>>

<<function wmovemouse>>

<<function wborder>>

<<function wpointto>>

<<function wcurrent>>

<<function wsetcursor>>

<<function riosetcursor>>

<<function wtop>>

<<function wtopme>>

<<function wbottomme>>

<<function wlookid>>

<<function wclosewin>>

<<function wsetpid>>

<<function winshell>>

<<global left1>>
<<global right1>>
<<global left2>>
<<global left3>>

<<global left>>
<<global right>>

<<function wdoubleclick>>

<<function wclickmatch>>


<<function wbacknl>>

<<function wshow>>

<<function wsetorigin>>

<<function wsetselect>>

<<function winsert>>

<<function wfill>>

<<function wcontents>>
@


\subsection*{[[windows/rio/xfid.c]]}

<<constant MAXSNARF>>=
#define	MAXSNARF	100*1024
@

<<global Einuse>>=
char Einuse[] =		"file in use";
@

<<global Edeleted>>=
char Edeleted[] =	"window deleted";
@

<<global Ebadreq>>=
char Ebadreq[] =	"bad graphics request";
@

<<global Etooshort>>=
char Etooshort[] =	"buffer too small";
@

<<global Ebadtile>>=
char Ebadtile[] =	"unknown tile";
@

<<global Eshort>>=
char Eshort[] =		"short i/o request";
@

<<global Elong>>=
char Elong[] = 		"snarf buffer too long";
@

<<global Eunkid>>=
char Eunkid[] = 	"unknown id in attach";
@

<<global Ebadrect>>=
char Ebadrect[] = 	"bad rectangle in attach";
@

<<global Ewindow>>=
char Ewindow[] = 	"cannot make window";
@

<<global Enowindow>>=
char Enowindow[] = 	"window has no image";
@

<<global Ebadmouse>>=
char Ebadmouse[] = 	"bad format on /dev/mouse";
@

<<global Ebadwrect>>=
char Ebadwrect[] = 	"rectangle outside screen";
@

<<global Ebadoffset>>=
char Ebadoffset[] = 	"window read not on scan line boundary";
@

<<global xfidfree>>=
static	Xfid	*xfidfree;
@

<<global xfid>>=
static	Xfid	*xfid;
@

<<global cxfidalloc>>=
static	Channel	*cxfidalloc;	/* chan(Xfid*) */
@

<<global cxfidfree>>=
static	Channel	*cxfidfree;	/* chan(Xfid*) */
@

<<global tsnarf>>=
static	char	*tsnarf;
@

<<global ntsnarf>>=
static	int	ntsnarf;
@

<<enum _anon_ (windows/rio/xfid.c)>>=
enum { 
    Alloc, 
    Free, 
    N 
};
@

<<function xfidallocthread>>=
void
xfidallocthread(void*)
{
    Xfid *x;
    static Alt alts[N+1];

    alts[Alloc].c = cxfidalloc;
    alts[Alloc].v = nil;
    alts[Alloc].op = CHANRCV;
    alts[Free].c = cxfidfree;
    alts[Free].v = &x;
    alts[Free].op = CHANRCV;
    alts[N].op = CHANEND;
    for(;;){
        switch(alt(alts)){
        case Alloc:
            x = xfidfree;
            if(x)
                xfidfree = x->free;
            else{
                x = emalloc(sizeof(Xfid));
                x->c = chancreate(sizeof(void(*)(Xfid*)), 0);
                x->flushc = chancreate(sizeof(int), 0);	/* notification only; no data */
                x->flushtag = -1;
                x->next = xfid;
                xfid = x;
                threadcreate(xfidctl, x, 16384);
            }
            if(x->ref != 0){
                fprint(2, "%p incref %ld\n", x, x->ref);
                error("incref");
            }
            if(x->flushtag != -1)
                error("flushtag in allocate");
            incref(x);
            sendp(cxfidalloc, x);
            break;
        case Free:
            if(x->ref != 0){
                fprint(2, "%p decref %ld\n", x, x->ref);
                error("decref");
            }
            if(x->flushtag != -1)
                error("flushtag in free");
            x->free = xfidfree;
            xfidfree = x;
            break;
        }
    }
}
@

<<function xfidinit>>=
Channel*
xfidinit(void)
{
    cxfidalloc = chancreate(sizeof(Xfid*), 0);
    cxfidfree = chancreate(sizeof(Xfid*), 0);
    threadcreate(xfidallocthread, nil, STACK);
    return cxfidalloc;
}
@

<<function xfidctl>>=
void
xfidctl(void *arg)
{
    Xfid *x;
    void (*f)(Xfid*);
    char buf[64];

    x = arg;
    snprint(buf, sizeof buf, "xfid.%p", x);
    threadsetname(buf);
    for(;;){
        f = recvp(x->c);
        (*f)(x);
        if(decref(x) == 0)
            sendp(cxfidfree, x);
    }
}
@

<<function xfidflush>>=
void
xfidflush(Xfid *x)
{
    Fcall t;
    Xfid *xf;

    for(xf=xfid; xf; xf=xf->next)
        if(xf->flushtag == x->oldtag){
            xf->flushtag = -1;
            xf->flushing = TRUE;
            incref(xf);	/* to hold data structures up at tail of synchronization */
            if(xf->ref == 1)
                error("ref 1 in flush");
            if(canqlock(&xf->active)){
                qunlock(&xf->active);
                sendul(xf->flushc, 0);
            }else{
                qlock(&xf->active);	/* wait for him to finish */
                qunlock(&xf->active);
            }
            xf->flushing = FALSE;
            if(decref(xf) == 0)
                sendp(cxfidfree, xf);
            break;
        }
    filsysrespond(x->fs, x, &t, nil);
}
@

<<function xfidattach>>=
void
xfidattach(Xfid *x)
{
    Fcall t;
    int id, hideit, scrollit;
    Window *w;
    char *err, *n, *dir, errbuf[ERRMAX];
    int pid, newlymade;
    Rectangle r;
    Image *i;

    t.qid = x->f->qid;
    qlock(&all);
    w = nil;
    err = Eunkid;
    newlymade = FALSE;
    hideit = 0;

    if(x->aname[0] == 'N'){	/* N 100,100, 200, 200 - old syntax */
        n = x->aname+1;
        pid = strtoul(n, &n, 0);
        if(*n == ',')
            n++;
        r.min.x = strtoul(n, &n, 0);
        if(*n == ',')
            n++;
        r.min.y = strtoul(n, &n, 0);
        if(*n == ',')
            n++;
        r.max.x = strtoul(n, &n, 0);
        if(*n == ',')
            n++;
        r.max.y = strtoul(n, &n, 0);
  Allocate:
        if(!goodrect(r))
            err = Ebadrect;
        else{
            if(hideit)
                i = allocimage(display, r, screen->chan, 0, DWhite);
            else
                i = allocwindow(wscreen, r, Refbackup, DWhite);
            if(i){
                border(i, r, Selborder, display->black, ZP);
                if(pid == 0)
                    pid = -1;	/* make sure we don't pop a shell! - UGH */
                w = new(i, hideit, scrolling, pid, nil, nil, nil);
                flushimage(display, 1);
                newlymade = TRUE;
            }else
                err = Ewindow;
        }
    }else if(strncmp(x->aname, "new", 3) == 0){	/* new -dx -dy - new syntax, as in wctl */
        pid = 0;
        if(parsewctl(nil, ZR, &r, &pid, nil, &hideit, &scrollit, &dir, x->aname, errbuf) < 0)
            err = errbuf;
        else
            goto Allocate;
    }else{
        id = atoi(x->aname);
        w = wlookid(id);
    }
    x->f->w = w;
    if(w == nil){
        qunlock(&all);
        x->f->busy = FALSE;
        filsysrespond(x->fs, x, &t, err);
        return;
    }
    if(!newlymade)	/* counteract dec() in winshell() */
        incref(w);
    qunlock(&all);
    filsysrespond(x->fs, x, &t, nil);
}
@

<<function xfidopen>>=
void
xfidopen(Xfid *x)
{
    Fcall t;
    Window *w;

    w = x->f->w;
    if(w->deleted){
        filsysrespond(x->fs, x, &t, Edeleted);
        return;
    }
    switch(FILE(x->f->qid)){
    case Qconsctl:
        if(w->ctlopen){
            filsysrespond(x->fs, x, &t, Einuse);
            return;
        }
        w->ctlopen = TRUE;
        break;
    case Qkbdin:
        if(w !=  wkeyboard){
            filsysrespond(x->fs, x, &t, Eperm);
            return;
        }
        break;
    case Qmouse:
        if(w->mouseopen){
            filsysrespond(x->fs, x, &t, Einuse);
            return;
        }
        /*
         * Reshaped: there's a race if the appl. opens the
         * window, is resized, and then opens the mouse,
         * but that's rare.  The alternative is to generate
         * a resized event every time a new program starts
         * up in a window that has been resized since the
         * dawn of time.  We choose the lesser evil.
         */
        w->resized = FALSE;
        w->mouseopen = TRUE;
        break;
    case Qsnarf:
        if(x->mode==ORDWR || x->mode==OWRITE){
            if(tsnarf)
                free(tsnarf);	/* collision, but OK */
            ntsnarf = 0;
            tsnarf = malloc(1);
        }
        break;
    case Qwctl:
        if(x->mode==OREAD || x->mode==ORDWR){
            /*
             * It would be much nicer to implement fan-out for wctl reads,
             * so multiple people can see the resizings, but rio just isn't
             * structured for that.  It's structured for /dev/cons, which gives
             * alternate data to alternate readers.  So to keep things sane for
             * wctl, we compromise and give an error if two people try to
             * open it.  Apologies.
             */
            if(w->wctlopen){
                filsysrespond(x->fs, x, &t, Einuse);
                return;
            }
            w->wctlopen = TRUE;
            w->wctlready = 1;
            wsendctlmesg(w, Wakeup, ZR, nil);
        }
        break;
    }
    t.qid = x->f->qid;
    t.iounit = messagesize-IOHDRSZ;
    x->f->open = TRUE;
    x->f->mode = x->mode;
    filsysrespond(x->fs, x, &t, nil);
}
@

<<function xfidclose>>=
void
xfidclose(Xfid *x)
{
    Fcall t;
    Window *w;
    int nb, nulls;

    w = x->f->w;
    switch(FILE(x->f->qid)){
    case Qconsctl:
        if(w->rawing){
            w->rawing = FALSE;
            wsendctlmesg(w, Rawoff, ZR, nil);
        }
        if(w->holding){
            w->holding = FALSE;
            wsendctlmesg(w, Holdoff, ZR, nil);
        }
        w->ctlopen = FALSE;
        break;
    case Qcursor:
        w->cursorp = nil;
        wsetcursor(w, FALSE);
        break;
    case Qmouse:
        w->resized = FALSE;
        w->mouseopen = FALSE;
        if(w->i != nil)
            wsendctlmesg(w, Refresh, w->i->r, nil);
        break;
    /* odd behavior but really ok: replace snarf buffer when /dev/snarf is closed */
    case Qsnarf:
        if(x->f->mode==ORDWR || x->f->mode==OWRITE){
            snarf = runerealloc(snarf, ntsnarf+1);
            cvttorunes(tsnarf, ntsnarf, snarf, &nb, &nsnarf, &nulls);
            free(tsnarf);
            tsnarf = nil;
            ntsnarf = 0;
        }
        break;
    case Qwctl:
        if(x->f->mode==OREAD || x->f->mode==ORDWR)
            w->wctlopen = FALSE;
        break;
    }
    wclose(w);
    filsysrespond(x->fs, x, &t, nil);
}
@

<<enum _anon_ (windows/rio/xfid.c)2>>=
enum { CWdata, CWflush, NCW };
@

<<function xfidwrite>>=
void
xfidwrite(Xfid *x)
{
    Fcall fc;
    int c, cnt, qid, nb, off, nr;
    char buf[256], *p;
    Point pt;
    Window *w;
    Rune *r;
    Conswritemesg cwm;
    Stringpair pair;
    Alt alts[NCW+1];

    w = x->f->w;
    if(w->deleted){
        filsysrespond(x->fs, x, &fc, Edeleted);
        return;
    }
    qid = FILE(x->f->qid);
    cnt = x->count;
    off = x->offset;
    x->data[cnt] = 0;
    switch(qid){
    case Qcons:
        nr = x->f->nrpart;
        if(nr > 0){
            memmove(x->data+nr, x->data, cnt);	/* there's room: see malloc in filsysproc */
            memmove(x->data, x->f->rpart, nr);
            cnt += nr;
            x->f->nrpart = 0;
        }
        r = runemalloc(cnt);
        cvttorunes(x->data, cnt-UTFmax, r, &nb, &nr, nil);
        /* approach end of buffer */
        while(fullrune(x->data+nb, cnt-nb)){
            c = nb;
            nb += chartorune(&r[nr], x->data+c);
            if(r[nr])
                nr++;
        }
        if(nb < cnt){
            memmove(x->f->rpart, x->data+nb, cnt-nb);
            x->f->nrpart = cnt-nb;
        }
        x->flushtag = x->tag;

        alts[CWdata].c = w->conswrite;
        alts[CWdata].v = &cwm;
        alts[CWdata].op = CHANRCV;
        alts[CWflush].c = x->flushc;
        alts[CWflush].v = nil;
        alts[CWflush].op = CHANRCV;
        alts[NCW].op = CHANEND;
    
        switch(alt(alts)){
        case CWdata:
            break;
        case CWflush:
            filsyscancel(x);
            return;
        }

        /* received data */
        x->flushtag = -1;
        if(x->flushing){
            recv(x->flushc, nil);	/* wake up flushing xfid */
            pair.s = runemalloc(1);
            pair.ns = 0;
            send(cwm.cw, &pair);		/* wake up window with empty data */
            filsyscancel(x);
            return;
        }
        qlock(&x->active);
        pair.s = r;
        pair.ns = nr;
        send(cwm.cw, &pair);
        fc.count = x->count;
        filsysrespond(x->fs, x, &fc, nil);
        qunlock(&x->active);
        return;

    case Qconsctl:
        if(strncmp(x->data, "holdon", 6)==0){
            if(w->holding++ == 0)
                wsendctlmesg(w, Holdon, ZR, nil);
            break;
        }
        if(strncmp(x->data, "holdoff", 7)==0 && w->holding){
            if(--w->holding == FALSE)
                wsendctlmesg(w, Holdoff, ZR, nil);
            break;
        }
        if(strncmp(x->data, "rawon", 5)==0){
            if(w->holding){
                w->holding = FALSE;
                wsendctlmesg(w, Holdoff, ZR, nil);
            }
            if(w->rawing++ == 0)
                wsendctlmesg(w, Rawon, ZR, nil);
            break;
        }
        if(strncmp(x->data, "rawoff", 6)==0 && w->rawing){
            if(--w->rawing == 0)
                wsendctlmesg(w, Rawoff, ZR, nil);
            break;
        }
        filsysrespond(x->fs, x, &fc, "unknown control message");
        return;

    case Qcursor:
        if(cnt < 2*4+2*2*16)
            w->cursorp = nil;
        else{
            w->cursor.offset.x = BGLONG(x->data+0*4);
            w->cursor.offset.y = BGLONG(x->data+1*4);
            memmove(w->cursor.clr, x->data+2*4, 2*2*16);
            w->cursorp = &w->cursor;
        }
        wsetcursor(w, !sweeping);
        break;

    case Qlabel:
        if(off != 0){
            filsysrespond(x->fs, x, &fc, "non-zero offset writing label");
            return;
        }
        free(w->label);
        w->label = emalloc(cnt+1);
        memmove(w->label, x->data, cnt);
        w->label[cnt] = 0;
        break;

    case Qmouse:
        if(w!=input || Dx(w->screenr)<=0)
            break;
        if(x->data[0] != 'm'){
            filsysrespond(x->fs, x, &fc, Ebadmouse);
            return;
        }
        p = nil;
        pt.x = strtoul(x->data+1, &p, 0);
        if(p == nil){
            filsysrespond(x->fs, x, &fc, Eshort);
            return;
        }
        pt.y = strtoul(p, nil, 0);
        if(w==input && wpointto(mouse->xy)==w)
            wsendctlmesg(w, Movemouse, Rpt(pt, pt), nil);
        break;

    case Qsnarf:
        /* always append only */
        if(ntsnarf > MAXSNARF){	/* avoid thrashing when people cut huge text */
            filsysrespond(x->fs, x, &fc, Elong);
            return;
        }
        tsnarf = erealloc(tsnarf, ntsnarf+cnt+1);	/* room for NUL */
        memmove(tsnarf+ntsnarf, x->data, cnt);
        ntsnarf += cnt;
        snarfversion++;
        break;

    case Qwdir:
        if(cnt == 0)
            break;
        if(x->data[cnt-1] == '\n'){
            if(cnt == 1)
                break;
            x->data[cnt-1] = '\0';
        }
        /* assume data comes in a single write */
        /*
          * Problem: programs like dossrv, ftp produce illegal UTF;
          * we must cope by converting it first.
          */
        snprint(buf, sizeof buf, "%.*s", cnt, x->data);
        if(buf[0] == '/'){
            free(w->dir);
            w->dir = estrdup(buf);
        }else{
            p = emalloc(strlen(w->dir) + 1 + strlen(buf) + 1);
            sprint(p, "%s/%s", w->dir, buf);
            free(w->dir);
            w->dir = cleanname(p);
        }
        break;

    case Qkbdin:
        keyboardsend(x->data, cnt);
        break;

    case Qwctl:
        if(writewctl(x, buf) < 0){
            filsysrespond(x->fs, x, &fc, buf);
            return;
        }
        flushimage(display, 1);
        break;

    default:
        fprint(2, buf, "unknown qid %d in write\n", qid);
        sprint(buf, "unknown qid in write");
        filsysrespond(x->fs, x, &fc, buf);
        return;
    }
    fc.count = cnt;
    filsysrespond(x->fs, x, &fc, nil);
}
@

<<function readwindow>>=
int
readwindow(Image *i, char *t, Rectangle r, int offset, int n)
{
    int ww, y;

    offset -= 5*12;
    ww = bytesperline(r, screen->depth);
    r.min.y += offset/ww;
    if(r.min.y >= r.max.y)
        return 0;
    y = r.min.y + n/ww;
    if(y < r.max.y)
        r.max.y = y;
    if(r.max.y <= r.min.y)
        return 0;
    return unloadimage(i, r, (uchar*)t, n);
}
@

<<enum _anon_ (windows/rio/xfid.c)3>>=
enum { CRdata, CRflush, NCR };
@

<<enum _anon_ (windows/rio/xfid.c)4>>=
enum { MRdata, MRflush, NMR };
@

<<enum _anon_ (windows/rio/xfid.c)5>>=
enum { WCRdata, WCRflush, NWCR };
@

<<function xfidread>>=
void
xfidread(Xfid *x)
{
    Fcall fc;
    int n, off, cnt, c;
    uint qid;
    char buf[128], *t;
    char cbuf[30];
    Window *w;
    Mouse ms;
    Rectangle r;
    Image *i;
    Channel *c1, *c2;	/* chan (tuple(char*, int)) */
    Consreadmesg crm;
    Mousereadmesg mrm;
    Consreadmesg cwrm;
    Stringpair pair;
    Alt alts[NCR+1];

    w = x->f->w;
    if(w->deleted){
        filsysrespond(x->fs, x, &fc, Edeleted);
        return;
    }
    qid = FILE(x->f->qid);
    off = x->offset;
    cnt = x->count;
    switch(qid){
    case Qcons:
        x->flushtag = x->tag;

        alts[CRdata].c = w->consread;
        alts[CRdata].v = &crm;
        alts[CRdata].op = CHANRCV;
        alts[CRflush].c = x->flushc;
        alts[CRflush].v = nil;
        alts[CRflush].op = CHANRCV;
        alts[NMR].op = CHANEND;

        switch(alt(alts)){
        case CRdata:
            break;
        case CRflush:
            filsyscancel(x);
            return;
        }

        /* received data */
        x->flushtag = -1;
        c1 = crm.c1;
        c2 = crm.c2;
        t = malloc(cnt+UTFmax+1);	/* room to unpack partial rune plus */
        pair.s = t;
        pair.ns = cnt;
        send(c1, &pair);
        if(x->flushing){
            recv(x->flushc, nil);	/* wake up flushing xfid */
            recv(c2, nil);			/* wake up window and toss data */
            free(t);
            filsyscancel(x);
            return;
        }
        qlock(&x->active);
        recv(c2, &pair);
        fc.data = pair.s;
        fc.count = pair.ns;
        filsysrespond(x->fs, x, &fc, nil);
        free(t);
        qunlock(&x->active);
        break;

    case Qlabel:
        n = strlen(w->label);
        if(off > n)
            off = n;
        if(off+cnt > n)
            cnt = n-off;
        fc.data = w->label+off;
        fc.count = cnt;
        filsysrespond(x->fs, x, &fc, nil);
        break;

    case Qmouse:
        x->flushtag = x->tag;

        alts[MRdata].c = w->mouseread;
        alts[MRdata].v = &mrm;
        alts[MRdata].op = CHANRCV;
        alts[MRflush].c = x->flushc;
        alts[MRflush].v = nil;
        alts[MRflush].op = CHANRCV;
        alts[NMR].op = CHANEND;

        switch(alt(alts)){
        case MRdata:
            break;
        case MRflush:
            filsyscancel(x);
            return;
        }

        /* received data */
        x->flushtag = -1;
        if(x->flushing){
            recv(x->flushc, nil);		/* wake up flushing xfid */
            recv(mrm.cm, nil);			/* wake up window and toss data */
            filsyscancel(x);
            return;
        }
        qlock(&x->active);
        recv(mrm.cm, &ms);
        c = 'm';
        if(w->resized)
            c = 'r';
        n = sprint(buf, "%c%11d %11d %11d %11ld ", c, ms.xy.x, ms.xy.y, ms.buttons, ms.msec);
        w->resized = 0;
        fc.data = buf;
        fc.count = min(n, cnt);
        filsysrespond(x->fs, x, &fc, nil);
        qunlock(&x->active);
        break;

    case Qcursor:
        filsysrespond(x->fs, x, &fc, "cursor read not implemented");
        break;

    /* The algorithm for snarf and text is expensive but easy and rarely used */
    case Qsnarf:
        getsnarf();
        if(nsnarf)
            t = runetobyte(snarf, nsnarf, &n);
        else {
            t = nil;
            n = 0;
        }
        goto Text;

    case Qtext:
        t = wcontents(w, &n);
        goto Text;

    Text:
        if(off > n){
            off = n;
            cnt = 0;
        }
        if(off+cnt > n)
            cnt = n-off;
        fc.data = t+off;
        fc.count = cnt;
        filsysrespond(x->fs, x, &fc, nil);
        free(t);
        break;

    case Qwdir:
        t = estrdup(w->dir);
        n = strlen(t);
        goto Text;

    case Qwinid:
        n = sprint(buf, "%11d ", w->id);
        t = estrdup(buf);
        goto Text;


    case Qwinname:
        n = strlen(w->name);
        if(n == 0){
            filsysrespond(x->fs, x, &fc, "window has no name");
            break;
        }
        t = estrdup(w->name);
        goto Text;

    case Qwindow:
        i = w->i;
        if(i == nil || Dx(w->screenr)<=0){
            filsysrespond(x->fs, x, &fc, Enowindow);
            return;
        }
        r = w->screenr;
        goto caseImage;

    case Qscreen:
        i = display->image;
        if(i == nil){
            filsysrespond(x->fs, x, &fc, "no top-level screen");
            break;
        }
        r = i->r;
        /* fall through */

    caseImage:
        if(off < 5*12){
            n = sprint(buf, "%11s %11d %11d %11d %11d ",
                chantostr(cbuf, screen->chan),
                i->r.min.x, i->r.min.y, i->r.max.x, i->r.max.y);
            t = estrdup(buf);
            goto Text;
        }
        t = malloc(cnt);
        fc.data = t;
        n = readwindow(i, t, r, off, cnt);	/* careful; fc.count is unsigned */
        if(n < 0){
            buf[0] = 0;
            errstr(buf, sizeof buf);
            filsysrespond(x->fs, x, &fc, buf);
        }else{
            fc.count = n;
            filsysrespond(x->fs, x, &fc, nil);
        }
        free(t);
        return;

    case Qwctl:	/* read returns rectangle, hangs if not resized */
        if(cnt < 4*12){
            filsysrespond(x->fs, x, &fc, Etooshort);
            break;
        }
        x->flushtag = x->tag;

        alts[WCRdata].c = w->wctlread;
        alts[WCRdata].v = &cwrm;
        alts[WCRdata].op = CHANRCV;
        alts[WCRflush].c = x->flushc;
        alts[WCRflush].v = nil;
        alts[WCRflush].op = CHANRCV;
        alts[NMR].op = CHANEND;

        switch(alt(alts)){
        case WCRdata:
            break;
        case WCRflush:
            filsyscancel(x);
            return;
        }

        /* received data */
        x->flushtag = -1;
        c1 = cwrm.c1;
        c2 = cwrm.c2;
        t = malloc(cnt+1);	/* be sure to have room for NUL */
        pair.s = t;
        pair.ns = cnt+1;
        send(c1, &pair);
        if(x->flushing){
            recv(x->flushc, nil);	/* wake up flushing xfid */
            recv(c2, nil);			/* wake up window and toss data */
            free(t);
            filsyscancel(x);
            return;
        }
        qlock(&x->active);
        recv(c2, &pair);
        fc.data = pair.s;
        if(pair.ns > cnt)
            pair.ns = cnt;
        fc.count = pair.ns;
        filsysrespond(x->fs, x, &fc, nil);
        free(t);
        qunlock(&x->active);
        break;

    default:
        fprint(2, "unknown qid %d in read\n", qid);
        sprint(buf, "unknown qid in read");
        filsysrespond(x->fs, x, &fc, buf);
        break;
    }
}
@


%-------------------------------------------------------------

<<windows/rio/xfid.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <cursor.h>
#include <mouse.h>
#include <keyboard.h>
#include <frame.h>
#include <fcall.h>
#include <plumb.h>

#include "dat.h"
#include "fns.h"

<<constant MAXSNARF>>

<<global Einuse>>
<<global Edeleted>>
<<global Ebadreq>>
<<global Etooshort>>
<<global Ebadtile>>
<<global Eshort>>
<<global Elong>>
<<global Eunkid>>
<<global Ebadrect>>
<<global Ewindow>>
<<global Enowindow>>
<<global Ebadmouse>>
<<global Ebadwrect>>
<<global Ebadoffset>>
extern char Eperm[];

<<global xfidfree>>
<<global xfid>>
<<global cxfidalloc>>
<<global cxfidfree>>

<<global tsnarf>>
<<global ntsnarf>>

<<enum _anon_ (windows/rio/xfid.c)>>

<<function xfidallocthread>>

<<function xfidinit>>

<<function xfidctl>>

<<function xfidflush>>

<<function xfidattach>>

<<function xfidopen>>

<<function xfidclose>>

<<enum _anon_ (windows/rio/xfid.c)2>>

<<function xfidwrite>>

<<function readwindow>>

<<enum _anon_ (windows/rio/xfid.c)3>>
<<enum _anon_ (windows/rio/xfid.c)4>>
<<enum _anon_ (windows/rio/xfid.c)5>>

<<function xfidread>>
@


\section{[[windows/apps/]]}

\subsection*{[[windows/apps/clock.c]]}

<<function circlept>>=
static Point
circlept(Point c, int r, int degrees)
{

    double rad;
    rad = (double) degrees * PI/180.0;
    c.x += cos(rad)*r;
    c.y -= sin(rad)*r;
    return c;
}
@

<<function redraw>>=
static void
redraw(Image *screen)
{
    static int tm, ntm;
    static Rectangle r;
    static Point c;
    static int rad;
    static Image *im;
    int i;
    int anghr, angmin;
    static Tm tms;
    static Tm ntms;

    ntm = time(0);
    if(ntm == tm && eqrect(screen->r, r))
        return;

    ntms = *localtime(ntm);
    anghr = 90-(ntms.hour*5 + ntms.min/12)*6;
    angmin = 90-ntms.min*6;
    tm = ntm;
    tms = ntms;
    r = screen->r;
    c = divpt(addpt(r.min, r.max), 2);
    rad = Dx(r) < Dy(r) ? Dx(r) : Dy(r);
    rad /= 2;
    rad -= 8;

    draw(screen, screen->r, back, nil, ZP);
    for(i=0; i<12; i++)
        fillellipse(screen, circlept(c, rad, i*(360/12)), 2, 2, dots, ZP);

    line(screen, c, circlept(c, (rad*3)/4, angmin), 0, 0, 1, minhand, ZP);
    line(screen, c, circlept(c, rad/2, anghr), 0, 0, 1, hrhand, ZP);

    flushimage(display, 1);
}
@

<<function eresized>>=
void
eresized(int new)
{
    if(new && getwindow(display, Refnone) < 0)
        fprint(2,"can't reattach to window");
    redraw(screen);
}
@

<<function main (windows/apps/clock.c)>>=
void
main(int, char**)
{
    Event e;
    Mouse m;
    Menu menu;
    char *mstr[] = {"exit", 0};
    int key, timer;
    int t;

    if (initdraw(0, 0, "clock") < 0)
        sysfatal("initdraw failed");
    back = allocimagemix(display, DPalebluegreen, DWhite);

    hrhand = allocimage(display, Rect(0,0,1,1), CMAP8, 1, DDarkblue);
    minhand = allocimage(display, Rect(0,0,1,1), CMAP8, 1, DPaleblue);
    dots = allocimage(display, Rect(0,0,1,1), CMAP8, 1, DBlue);
    redraw(screen);

    einit(Emouse);
    t = (30*1000);
    timer = etimer(0, t);

    menu.item = mstr;
    menu.lasthit = 0;
        // the event loop
    for(;;) {
        key = event(&e);
        if(key == Emouse) {
            m = e.mouse;
            if(m.buttons & 4) {
                if(emenuhit(3, &m, &menu) == 0)
                    exits(0);
            }
        } else if(key == timer) {
            redraw(screen);
        }
    }	
}
@


%-------------------------------------------------------------

<<windows/apps/clock.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <event.h>

static Image *hrhand, *minhand;
static Image *dots, *back;

<<function circlept>>

<<function redraw>>

<<function eresized>>

<<function main (windows/apps/clock.c)>>
@


\subsection*{[[windows/apps/colors.c]]}

<<global pixel>>=
static Image *pixel;
@

<<global crect>>=
static Rectangle crect[256];
@

<<global color>>=
static Image *color[256];
@

<<function eresized (windows/apps/colors.c)>>=
void
eresized(int new)
{
    int x, y, i, n, nx, ny;
    Rectangle r, b;

    if(new && getwindow(display, Refnone) < 0){
        fprint(2, "colors: can't reattach to window: %r\n");
        exits("resized");
    }
    if(screen->depth > 8){
        n = 256;
        nx = 16;
    }else{
        n = 1<<screen->depth;
        nx = 1<<(screen->depth/2);
    }

    ny = n/nx;
    draw(screen, screen->r, display->white, nil, ZP);
    r = insetrect(screen->r, 5);
    r.min.y+=20;
    b.max.y=r.min.y;
    for(i=n-1, y=0; y!=ny; y++){
        b.min.y=b.max.y;
        b.max.y=r.min.y+(r.max.y-r.min.y)*(y+1)/ny;
        b.max.x=r.min.x;
        for(x=0; x!=nx; x++, --i){
            b.min.x=b.max.x;
            b.max.x=r.min.x+(r.max.x-r.min.x)*(x+1)/nx;
            crect[i]=insetrect(b, 1);
            draw(screen, crect[i], color[i], nil, ZP);
        }
    }
    flushimage(display, 1);
}
@

<<global buttons>>=
static char *buttons[] =
{
    "exit",
    0
};
@

<<function grey>>=
static ulong
grey(int i)
{
    if(i < 0)
        return grey(0);
    if(i > 255)
        return grey(255);
    return (i<<16)+(i<<8)+i;
}
@

<<global menu>>=
static Menu menu =
{
    buttons
};
@

<<global dither>>=
static int
dither[16] =  {
    0, 8, 2, 10,
    12, 4, 14, 6,
    3, 11, 1, 9,
    15, 7, 13, 5
};
@

<<function main (windows/apps/colors.c)>>=
void
main(int argc, char *argv[])
{
    Point p;
    Mouse m;
    int i, j, k, l, n, ramp, prev;
    char buf[100];
    char *fmt;
    Image *dark;
    ulong rgb;

    ramp = 0;

    fmt = "index %3d r %3lud g %3lud b %3lud 0x%.8luX        ";
    ARGBEGIN{
    default:
        goto Usage;
    case 'x':
        fmt = "index %2luX r %3luX g %3luX b %3luX 0x%.8luX       ";
        break;
    case 'r':
        ramp = 1;
        break;
    }ARGEND

    if(argc){
    Usage:
        fprint(2, "Usage: %s [-rx]\n", argv0);
        exits("usage");
    }

    if(initdraw(nil, nil, "colors") < 0)
        sysfatal("initdraw failed: %r");
    einit(Emouse);

    for(i=0; i<256; i++){
        if(ramp){
            if(screen->chan == CMAP8){
                /* dither the fine grey */
                j = i-(i%17);
                dark = allocimage(display, Rect(0,0,1,1), screen->chan, 1, (grey(j)<<8)+0xFF);
                color[i] = allocimage(display, Rect(0,0,4,4), screen->chan, 1, (grey(j+17)<<8)+0xFF);
                for(j=0; j<16; j++){
                    k = j%4;
                    l = j/4;
                    if(dither[j] > (i%17))
                        draw(color[i], Rect(k, l, k+1, l+1), dark, nil, ZP);
                }
                freeimage(dark);
            }else
                color[i] = allocimage(display, Rect(0,0,1,1), screen->chan, 1, (grey(i)<<8)+0xFF);
        }else
            color[i] = allocimage(display, Rect(0,0,1,1), screen->chan, 1, (cmap2rgb(i)<<8)+0xFF);
        if(color[i] == nil)
            sysfatal("can't allocate image: %r");
    }
    eresized(0);
    prev = -1;
    for(;;){
        m = emouse();
        switch(m.buttons){
        case 1:
            while(m.buttons){
                if(screen->depth > 8)
                    n = 256;
                else
                    n = 1<<screen->depth;
                for(i=0; i!=n; i++)
                    if(i!=prev && ptinrect(m.xy, crect[i])){
                        if(ramp)
                            rgb = grey(i);
                        else
                            rgb = cmap2rgb(i);
                        sprint(buf, fmt,
                            i,
                            (rgb>>16)&0xFF,
                            (rgb>>8)&0xFF,
                            rgb&0xFF,
                            (rgb<<8) | 0xFF);
                        p = addpt(screen->r.min, Pt(2,2));
                        draw(screen, Rpt(p, addpt(p, stringsize(font, buf))), display->white, nil, p);
                        string(screen, p, display->black, ZP, font, buf);
                        prev=i;
                        break;
                    }
                m = emouse();
            }
            break;

        case 4:
            switch(emenuhit(3, &m, &menu)){
            case 0:
                exits(0);
            }
        }
    }
}
@


%-------------------------------------------------------------

<<windows/apps/colors.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <event.h>

static int nbit, npix;
<<global pixel>>
<<global crect>>
<<global color>>

<<function eresized (windows/apps/colors.c)>>

<<global buttons>>

<<function grey>>

<<global menu>>

<<global dither>>

<<function main (windows/apps/colors.c)>>
@


\subsection*{[[windows/apps/lens.c]]}

<<enum _anon_ (windows/apps/lens.c)>>=
enum {
    Edge = 5,
    Maxmag = 16
};
@

<<enum _anon_ (windows/apps/lens.c)2>>=
enum {
    Mzoom,
    Munzoom,
    Mgrid,
    Mredraw,
    Mexit
};
@

<<global menustr>>=
static char *menustr[] = {
    "zoom",
    "unzoom",
    "grid",
    "redraw",
    "exit",
    nil
};
@

<<global menu (windows/apps/lens.c)>>=
static Menu menu = {
    menustr,
    nil,
    -1
};
@

<<global lastp>>=
static Point lastp;
@

<<global red (windows/apps/lens.c)>>=
static Image *red;
@

<<global tmp (windows/apps/lens.c)>>=
static Image *tmp;
@

<<global grid>>=
static Image *grid;
@

<<global chequer>>=
static Image *chequer;
@

<<global screenfd>>=
static int	screenfd;
@

<<global mag>>=
static int	mag = 4;
@

<<global showgrid>>=
static int	showgrid = 0;
@

<<global screenr>>=
static Rectangle	screenr;
@

<<global screenbuf>>=
static uchar	*screenbuf;
@

<<function drawit>>=
void
drawit(void)
{
    Rectangle r;
    border(screen, screen->r, Edge, red, ZP);
    magnify();
    r = insetrect(screen->r, Edge);
    draw(screen, r, tmp, nil, tmp->r.min);
    flushimage(display, 1);
}
@

<<global bypp>>=
static int bypp;
@

<<function main (windows/apps/lens.c)>>=
void
main(int argc, char *argv[])
{
    Event e;
    char buf[5*12];
    ulong chan;
    int d;

    USED(argc, argv);
    if(initdraw(nil, nil, "lens") < 0){
        fprint(2, "lens: initdraw failed: %r\n");
        exits("initdraw");
    }
    einit(Emouse|Ekeyboard);
    red = allocimage(display, Rect(0, 0, 1, 1), CMAP8, 1, DRed);
    chequer = allocimage(display, Rect(0, 0, 2, 2), GREY1, 1, DBlack);
    draw(chequer, Rect(0, 0, 1, 1), display->white, nil, ZP);
    draw(chequer, Rect(1, 1, 2, 2), display->white, nil, ZP);
    lastp = divpt(addpt(screen->r.min, screen->r.max), 2);
    screenfd = open("/dev/screen", OREAD);
    if(screenfd < 0){
        fprint(2, "lens: can't open /dev/screen: %r\n");
        exits("screen");
    }
    if(read(screenfd, buf, sizeof buf) != sizeof buf){
        fprint(2, "lens: can't read /dev/screen: %r\n");
        exits("screen");
    }
    chan = strtochan(buf);
    d = chantodepth(chan);
    if(d < 8){
        fprint(2, "lens: can't handle screen format %11.11s\n", buf);
        exits("screen");
    }
    bypp = d/8;
    screenr.min.x = atoi(buf+1*12);
    screenr.min.y = atoi(buf+2*12);
    screenr.max.x = atoi(buf+3*12);
    screenr.max.y = atoi(buf+4*12);
    screenbuf = malloc(bypp*Dx(screenr)*Dy(screenr));
    if(screenbuf == nil){
        fprint(2, "lens: buffer malloc failed: %r\n");
        exits("malloc");
    }
    eresized(0);

    for(;;)
        switch(event(&e)){
        case Ekeyboard:
            switch(e.kbdc){
            case 'q':
            case 0x7f:
            case '\04':
            caseexit:
                exits(nil);
            case '=':
            case '+':
            casezoom:
                if(mag < Maxmag){
                    mag++;
                    makegrid();
                    drawit();
                }
                break;
            case 'g':
            casegrid:
                showgrid = !showgrid;
                makegrid();
                drawit();
                break;
            case '-':
            case '_':
            caseunzoom:
                if(mag > 1){
                    mag--;
                    makegrid();
                    drawit();
                }
                break;
            case '.':
            case ' ':
            caseredraw:
                drawit();
                break;
            case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': case'0':
                mag = e.kbdc-'0';
                if(mag == 0)
                    mag = 10;
                makegrid();
                drawit();
                break;
            }
            break;
        case Emouse:
            if(e.mouse.buttons & 1){
                lastp = e.mouse.xy;
                drawit();
            }
            if(e.mouse.buttons & 4)
                switch(emenuhit(3, &e.mouse, &menu)){
                case Mzoom:
                    goto casezoom;
                case Munzoom:
                    goto caseunzoom;
                case Mgrid:
                    goto casegrid;
                case Mredraw:
                    goto caseredraw;
                case Mexit:
                    goto caseexit;
                }
            break;
        }
}
@

<<function makegrid>>=
void
makegrid(void)
{
    int m;
    if (grid != nil) {
        freeimage(grid);
        grid = nil;
    }
    if (showgrid) {
        m = mag;
        if (m < 5)
            m *= 10;
        grid = allocimage(display, Rect(0, 0, m, m),
            CHAN2(CGrey, 8, CAlpha, 8), 1, DTransparent);
        if (grid != nil){
            draw(grid, Rect(0, 0, m, 1), chequer, nil, ZP);
            draw(grid, Rect(0, 1, 1, m), chequer, nil, ZP);
        }
    }
}
@

<<function eresized (windows/apps/lens.c)>>=
void
eresized(int new)
{
    if(new && getwindow(display, Refnone) < 0){
        fprint(2, "lens: can't reattach to window: %r\n");
        exits("attach");
    }
    freeimage(tmp);
    tmp = allocimage(display, Rect(0, 0, Dx(screen->r)-Edge, Dy(screen->r)-Edge+Maxmag), screen->chan, 0, DNofill);
    if(tmp == nil){
        fprint(2, "lens: allocimage failed: %r\n");
        exits("allocimage");
    }
    drawit();
}
@

<<function magnify>>=
void
magnify(void)
{
    int x, y, xx, yy, dd, i;
    int dx, dy;
    int xoff, yoff;
    uchar out[8192];
    uchar sp[4];

    dx = (Dx(tmp->r)+mag-1)/mag;
    dy = (Dy(tmp->r)+mag-1)/mag;
    xoff = lastp.x-Dx(tmp->r)/(mag*2);
    yoff  = lastp.y-Dy(tmp->r)/(mag*2);

    yy = yoff;
    dd = dy;
    if(yy < 0){
        dd += dy;
        yy = 0;
    }
    if(yy+dd > Dy(screenr))
        dd = Dy(screenr)-yy;
    seek(screenfd, 5*12+bypp*yy*Dx(screenr), 0);
    if(readn(screenfd, screenbuf+bypp*yy*Dx(screenr), bypp*Dx(screenr)*dd) != bypp*Dx(screenr)*dd){
        fprint(2, "lens: can't read screen: %r\n");
        return;
    }

    for(y=0; y<dy; y++){
        yy = yoff+y;
        if(yy>=0 && yy<Dy(screenr))
            for(x=0; x<dx; x++){
                xx = xoff+x;
                if(xx>=0 && xx<Dx(screenr))	/* snarf pixel at xx, yy */
                    for(i=0; i<bypp; i++)
                        sp[i] = screenbuf[bypp*(yy*Dx(screenr)+xx)+i];
                else
                    sp[0] = sp[1] = sp[2] = sp[3] = 0;

                for(xx=0; xx<mag; xx++)
                    if(x*mag+xx < tmp->r.max.x)
                        for(i=0; i<bypp; i++)
                            out[(x*mag+xx)*bypp+i] = sp[i];
            }
        else
            memset(out, 0, bypp*Dx(tmp->r));
        for(yy=0; yy<mag && y*mag+yy<Dy(tmp->r); yy++){
            werrstr("no error");
            if(loadimage(tmp, Rect(0, y*mag+yy, Dx(tmp->r), y*mag+yy+1), out, bypp*Dx(tmp->r)) != bypp*Dx(tmp->r)){
                exits("load");
            }
        }
    }
    if (showgrid && mag && grid)
        draw(tmp, tmp->r, grid, nil, mulpt(Pt(xoff, yoff), mag));
}
@


%-------------------------------------------------------------

<<windows/apps/lens.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <event.h>

<<enum _anon_ (windows/apps/lens.c)>>

<<enum _anon_ (windows/apps/lens.c)2>>

<<global menustr>>

<<global menu (windows/apps/lens.c)>>

<<global lastp>>
<<global red (windows/apps/lens.c)>>
<<global tmp (windows/apps/lens.c)>>
<<global grid>>
<<global chequer>>
<<global screenfd>>
<<global mag>>
<<global showgrid>>
<<global screenr>>
<<global screenbuf>>

void	magnify(void);
void makegrid(void);

<<function drawit>>

<<global bypp>>

<<function main (windows/apps/lens.c)>>

<<function makegrid>>

<<function eresized (windows/apps/lens.c)>>

<<function magnify>>
@


\subsection*{[[windows/apps/screenlock.c]]}

<<global pic>>=
static char pic[] = "/lib/bunny.bit";
@

<<global vgactl>>=
static int vgactl;
@

<<global debug>>=
static int debug;
@

<<global doblank>>=
static int doblank;
@

<<global chatty>>=
static int chatty = 0;
@

<<global user>>=
static char user[256];
@

<<function blankscreen>>=
static void
blankscreen(int blank)
{
    if(vgactl < 0)
        return;
    seek(vgactl, 0, 0);
    if(fprint(vgactl, blank? "blank": "unblank") < 0)
        fprint(2, "blankscreen: can't blank: %r\n");
}
@

<<function error (windows/apps/screenlock.c)>>=
static void
error(char *fmt, ...)
{
    Fmt f;
    char buf[64];
    va_list arg;

    fmtfdinit(&f, 1, buf, sizeof buf);
    fmtprint(&f, "screenlock: ");
    va_start(arg, fmt);
    fmtvprint(&f, fmt, arg);
    va_end(arg);
    fmtprint(&f, "\n");
    fmtfdflush(&f);
    threadexitsall("fatal error");
}
@

<<function usage (windows/apps/screenlock.c)>>=
static void
usage(void)
{
    fprint(2, "usage: %s\n", argv0);
    exits("usage");
}
@

<<function readfile>>=
static void
readfile(char *name, char *buf, int nbuf, int addnul)
{
    int fd;

    fd = open(name, OREAD);
    if(fd == -1)
        error("%s - can't open: %r", name);
    nbuf = read(fd, buf, nbuf-addnul);
    close(fd);
    if(nbuf == -1)
        error("%s - can't can't read: %r", name);
    if(addnul)
        buf[nbuf] = '\0';
}
@

<<function readline>>=
static void
readline(char *buf, int nbuf)
{
    char c;
    int i;

    i = 0;
    while(i < nbuf-1)
        if(read(0, &c, 1) != 1 || c == '\04' || c == '\177'){
            i = 0;
            break;
        } else if(c == '\n')
            break;
        else if(c == '\b' && i > 0)
            --i;
        else if(c == ('u' & 037))
            i = 0;
        else
            buf[i++] = c;
    buf[i] = '\0';
}
@

<<function checkpassword>>=
static void
checkpassword(void)
{
    int fd, consctl, must;
    char buf[256];
    AuthInfo *ai;
    static int opened;

    must = 1;
    if(!opened){
        fd = open("/dev/cons", OREAD);
        if(fd == -1)
            error("can't open cons: %r");
        dup(fd, 0);
        close(fd);
        fd = open("/dev/cons", OWRITE);
        if(fd == -1)
            error("can't open cons: %r");
        dup(fd, 1);
        dup(1, 2);
        close(fd);
        consctl = open("/dev/consctl", OWRITE);
        if(consctl == -1)
            error("can't open consctl: %r");
        if(write(consctl, "rawon", 5) != 5)
            error("can't turn off echo\n");
        opened = 1;
    }

    for(;;){
        if(chatty || !must)
            fprint(2, "%s's screenlock password: ", user);
        memset(buf, 0, sizeof buf);
        readline(buf, sizeof buf);
        blankscreen(0);
        if(chatty || !must)
            fprint(2, "\n");
        if(buf[0] == '\0' || buf[0] == '\04'){
            if(must)
                continue;
            error("no password typed");
        }

        /* authenticate */
        ai = auth_userpasswd(user, buf);
        if(ai != nil && ai->cap != nil)
            break;
        auth_freeAI(ai);

        if(chatty || !must)
            fprint(2, "password mismatch\n");
        doblank = 1;
    }
    memset(buf, 0, sizeof buf);
    blankscreen(0);
}
@

<<function blanker>>=
static void
blanker(void *)
{
    int tics;

    tics = 0;
    for(;;){
        if(doblank > 0){
            doblank = 0;
            tics = 10;
        }
        if(tics > 0 && --tics == 0)
            blankscreen(1);
        sleep(1000);
    }
}
@

<<function grabmouse>>=
static void
grabmouse(void*)
{
    int fd, x, y;
    char ibuf[256], obuf[256];

    if(debug)
        return;
    fd = open("/dev/mouse", ORDWR);
    if(fd < 0)
        error("can't open /dev/mouse: %r");

    snprint(obuf, sizeof obuf, "m %d %d",
        screen->r.min.x + Dx(screen->r)/2,
        screen->r.min.y + Dy(screen->r)/2);
    while(read(fd, ibuf, sizeof ibuf) > 0){
        ibuf[12] = 0;
        ibuf[24] = 0;
        x = atoi(ibuf+1);
        y = atoi(ibuf+13);
        if(x != screen->r.min.x + Dx(screen->r)/2 ||
           y != screen->r.min.y + Dy(screen->r)/2){
            fprint(fd, "%s", obuf);
            doblank = 1;
        }
    }
}
@

<<function screenstring>>=
/* lay down text at `p' */
static void
screenstring(Point p, char *s)
{
    string(screen, p, screen->display->white, ZP, font, s);
    flushimage(display, 1);
}
@

<<function lockscreen>>=
static void
lockscreen(void)
{
    enum { Nfld = 5, Fldlen = 12, Cursorlen = 2*4 + 2*2*16, };
    char *s;
    char buf[Nfld*Fldlen], *flds[Nfld], newcmd[128], cbuf[Cursorlen];
    int fd, dx, dy;
    Image *i;
    Point p;
    Rectangle r;
    Tm *tm;

    fd = open("/dev/screen", OREAD);
    if(fd < 0)
        error("can't open /dev/screen: %r");
    if(read(fd, buf, Nfld*Fldlen) != Nfld*Fldlen)
        error("can't read /dev/screen: %r");
    close(fd);
    buf[sizeof buf-1] = 0;
    if(tokenize(buf, flds, Nfld) != Nfld)
        error("can't tokenize /dev/screen header");
    snprint(newcmd, sizeof newcmd, "-r %s %s %d %d",
        flds[1], flds[2], atoi(flds[3]) - 1, atoi(flds[4]) - 1);
    newwindow(newcmd);
    if (initdraw(nil, nil, "screenlock") < 0)
        sysfatal("initdraw failed");
    if(display == nil)
        error("no display");

    /* screen is now open and covered.  grab mouse and hold on tight */
    procrfork(grabmouse, nil, 4096, RFFDG);
    procrfork(blanker, nil, 4096, RFFDG);
    fd = open(pic, OREAD);
    if(fd > 0){
        i = readimage(display, fd, 0);
        if(i){
    r = screen->r;
            p = Pt(r.max.x / 2, r.max.y * 2 / 3); 
            dx = (Dx(screen->r) - Dx(i->r)) / 2;
            r.min.x += dx;
            r.max.x -= dx;
            dy = (Dy(screen->r) - Dy(i->r)) / 2;
            r.min.y += dy;
            r.max.y -= dy;
            draw(screen, screen->r, display->black, nil, ZP);
            draw(screen, r, i, nil, i->r.min);
            flushimage(display, 1);
        }
        close(fd);

        /* identify the user on screen, centered */
        tm = localtime(time(0));
        s = smprint("user %s at %d:%02.2d", getuser(), tm->hour, tm->min);
        p = subpt(p, Pt(stringwidth(font, "m") * strlen(s) / 2, 0));
        screenstring(p, s);
    }

    /* clear the cursor */
    fd = open("/dev/cursor", OWRITE);
    if(fd > 0){
        memset(cbuf, 0, sizeof cbuf);
        write(fd, cbuf, sizeof cbuf);
        /* leave it open */
    }
}
@

<<function threadmain (windows/apps/screenlock.c)>>=
void
threadmain(int argc, char *argv[])
{
    readfile("#c/user", user, sizeof user, 1);

    if((vgactl = open("/dev/vgactl", OWRITE)) < 0)
        vgactl = open("#v/vgactl", OWRITE);

    ARGBEGIN{
    case 'd':
        debug++;
        break;
    default:
        usage();
    }ARGEND

    if(argc != 0)
        usage();

    doblank = 1;
    lockscreen();
    checkpassword();
    threadexitsall(nil);
}
@


%-------------------------------------------------------------

<<windows/apps/screenlock.c>>=
/* screenlock - lock a terminal */
#include <u.h>
#include <libc.h>
#include <libsec.h>
#include <draw.h>
#include <thread.h>
#include <auth.h>

<<global pic>>

<<global vgactl>>
<<global debug>>
<<global doblank>>
<<global chatty>>

<<global user>>

<<function blankscreen>>

<<function error (windows/apps/screenlock.c)>>

<<function usage (windows/apps/screenlock.c)>>


<<function readfile>>

<<function readline>>

<<function checkpassword>>

<<function blanker>>

<<function grabmouse>>

<<function screenstring>>

<<function lockscreen>>

<<function threadmain (windows/apps/screenlock.c)>>
@


\subsection*{[[windows/apps/statusbar.c]]}

<<enum _anon_ (windows/apps/statusbar.c)>>=
enum {PNCTL=3};
@

<<global nokill>>=
static int nokill;
@

<<global textmode>>=
static int textmode;
@

<<global title>>=
static char *title;
@

<<global light>>=
static Image *light;
@

<<global dark>>=
static Image *dark;
@

<<global text (windows/apps/statusbar.c)>>=
static Image *text;
@

<<function initcolor>>=
static void
initcolor(void)
{
    text = display->black;
    light = allocimagemix(display, DPalegreen, DWhite);
    dark = allocimage(display, Rect(0,0,1,1), CMAP8, 1, DDarkgreen);
}
@

<<global rbar>>=
static Rectangle rbar;
@

<<global ptext>>=
static Point ptext;
@

<<global last>>=
static int last;
@

<<global lastp (windows/apps/statusbar.c)>>=
static int lastp = -1;
@

<<global backup>>=
static char backup[80];
@

<<function drawbar>>=
void
drawbar(void)
{
    int i, j;
    int p;
    char buf[400], bar[200];
    static char lastbar[200];

    if(n > d || n < 0 || d <= 0)
        return;

    i = (Dx(rbar)*n)/d;
    p = (n*100LL)/d;

    if(textmode){
        if(Dx(rbar) > 150){
            rbar.min.x = 0;
            rbar.max.x = 150;
            return;
        }
        bar[0] = '|';
        for(j=0; j<i; j++)
            bar[j+1] = '#';
        for(; j<Dx(rbar); j++)
            bar[j+1] = '-';
        bar[j++] = '|';
        bar[j++] = ' ';
        sprint(bar+j, "%3d%% ", p);
        for(i=0; bar[i]==lastbar[i] && bar[i]; i++)
            ;
        memset(buf, '\b', strlen(lastbar)-i);
        strcpy(buf+strlen(lastbar)-i, bar+i);
        if(buf[0])
            write(1, buf, strlen(buf));
        strcpy(lastbar, bar);
        return;
    }

    if(lastp == p && last == i)
        return;

    if(lastp != p){
        sprint(buf, "%d%%", p);
        
        stringbg(screen, addpt(screen->r.min, Pt(Dx(rbar)-30, 4)), text, ZP, display->defaultfont, buf, light, ZP);
        lastp = p;
    }

    if(last != i){
        if(i > last)
            draw(screen, Rect(rbar.min.x+last, rbar.min.y, rbar.min.x+i, rbar.max.y),
                dark, nil, ZP);
        else
            draw(screen, Rect(rbar.min.x+i, rbar.min.y, rbar.min.x+last, rbar.max.y),
                light, nil, ZP);
        last = i;
    }
    flushimage(display, 1);
}
@

<<function eresized (windows/apps/statusbar.c)>>=
void
eresized(int new)
{
    Point p, q;
    Rectangle r;

    if(new && getwindow(display, Refnone) < 0)
        fprint(2,"can't reattach to window");

    r = screen->r;
    draw(screen, r, light, nil, ZP);
    p = string(screen, addpt(r.min, Pt(4,4)), text, ZP,
        display->defaultfont, title);

    p.x = r.min.x+4;
    p.y += display->defaultfont->height+4;

    q = subpt(r.max, Pt(4,4));
    rbar = Rpt(p, q);

    ptext = Pt(r.max.x-4-stringwidth(display->defaultfont, "100%"), r.min.x+4);
    border(screen, rbar, -2, dark, ZP);
    last = 0;
    lastp = -1;

    drawbar();
}
@

<<function bar>>=
void
bar(Biobuf *b)
{
    char *p, *f[2];
    Event e;
    int k, die, parent, child;

    parent = getpid();

    die = 0;
    if(textmode)
        child = -1;
    else
    switch(child = rfork(RFMEM|RFPROC)) {
    case 0:
        sleep(1000);
        while(!die && (k = eread(Ekeyboard|Emouse, &e))) {
            if(nokill==0 && k == Ekeyboard && (e.kbdc == 0x7F || e.kbdc == 0x03)) { /* del, ctl-c */
                die = 1;
                postnote(PNPROC, parent, "interrupt");
                _exits("interrupt");
            }
        }
        _exits(0);
    }

    while(!die && (p = Brdline(b, '\n'))) {
        p[Blinelen(b)-1] = '\0';
        if(tokenize(p, f, 2) != 2)
            continue;
        n = strtoll(f[0], 0, 0);
        d = strtoll(f[1], 0, 0);
        drawbar();
    }
    postnote(PNCTL, child, "kill");
}
@

<<function usage (windows/apps/statusbar.c)>>=
static void
usage(void)
{
    fprint(2, "usage: aux/statusbar [-kt] [-w minx,miny,maxx,maxy] 'title'\n");
    exits("usage");
}
@

<<function main (windows/apps/statusbar.c)>>=
void
main(int argc, char **argv)
{
    Biobuf b;
    char *p, *q;
    int lfd;

    p = "0,0,200,60";
    
    ARGBEGIN{
    case 'w':
        p = ARGF();
        break;
    case 't':
        textmode = 1;
        break;
    case 'k':
        nokill = 1;
        break;
    default:
        usage();
    }ARGEND;

    if(argc != 1)
        usage();

    title = argv[0];

    lfd = dup(0, -1);

    while(q = strchr(p, ','))
        *q = ' ';
    Binit(&b, lfd, OREAD);
    if(textmode || newwin(p) < 0){
        textmode = 1;
        rbar = Rect(0, 0, 60, 1);
    }else{
        if(initdraw(0, 0, "bar") < 0)
            exits("initdraw");
        initcolor();
        einit(Emouse|Ekeyboard);
        eresized(0);
    }
    bar(&b);

    exits(0);
}
@

<<function rdenv>>=
/* all code below this line should be in the library, but is stolen from colors instead */
static char*
rdenv(char *name)
{
    char *v;
    int fd, size;

    fd = open(name, OREAD);
    if(fd < 0)
        return 0;
    size = seek(fd, 0, 2);
    v = malloc(size+1);
    if(v == 0){
        fprint(2, "%s: can't malloc: %r\n", argv0);
        exits("no mem");
    }
    seek(fd, 0, 0);
    read(fd, v, size);
    v[size] = 0;
    close(fd);
    return v;
}
@

<<function newwin>>=
int
newwin(char *win)
{
    char *srv, *mntsrv;
    char spec[100];
    int srvfd, cons, pid;

    switch(rfork(RFFDG|RFPROC|RFNAMEG|RFENVG|RFNOTEG|RFNOWAIT)){
    case -1:
        fprint(2, "statusbar: can't fork: %r\n");
        return -1;
    case 0:
        break;
    default:
        exits(0);
    }

    srv = rdenv("/env/wsys");
    if(srv == 0){
        mntsrv = rdenv("/mnt/term/env/wsys");
        if(mntsrv == 0){
            fprint(2, "statusbar: can't find $wsys\n");
            return -1;
        }
        srv = malloc(strlen(mntsrv)+10);
        sprint(srv, "/mnt/term%s", mntsrv);
        free(mntsrv);
        pid  = 0;			/* can't send notes to remote processes! */
    }else
        pid = getpid();
    USED(pid);
    srvfd = open(srv, ORDWR);
    free(srv);
    if(srvfd == -1){
        fprint(2, "statusbar: can't open %s: %r\n", srv);
        return -1;
    }
    sprint(spec, "new -r %s", win);
    if(mount(srvfd, -1, "/mnt/wsys", 0, spec) == -1){
        fprint(2, "statusbar: can't mount /mnt/wsys: %r (spec=%s)\n", spec);
        return -1;
    }
    close(srvfd);
    unmount("/mnt/acme", "/dev");
    bind("/mnt/wsys", "/dev", MBEFORE);
    cons = open("/dev/cons", OREAD);
    if(cons==-1){
    NoCons:
        fprint(2, "statusbar: can't open /dev/cons: %r");
        return -1;
    }
    dup(cons, 0);
    close(cons);
    cons = open("/dev/cons", OWRITE);
    if(cons==-1)
        goto NoCons;
    dup(cons, 1);
    dup(cons, 2);
    close(cons);
//	wctlfd = open("/dev/wctl", OWRITE);
    return 0;
}
@

<<function screenrect>>=
Rectangle
screenrect(void)
{
    int fd;
    char buf[12*5];

    fd = open("/dev/screen", OREAD);
    if(fd == -1)
        fd=open("/mnt/term/dev/screen", OREAD);
    if(fd == -1){
        fprint(2, "%s: can't open /dev/screen: %r\n", argv0);
        exits("window read");
    }
    if(read(fd, buf, sizeof buf) != sizeof buf){
        fprint(2, "%s: can't read /dev/screen: %r\n", argv0);
        exits("screen read");
    }
    close(fd);
    return Rect(atoi(buf+12), atoi(buf+24), atoi(buf+36), atoi(buf+48));
}
@

<<function postnote>>=
int
postnote(int group, int pid, char *note)
{
    char file[128];
    int f, r;

    switch(group) {
    case PNPROC:
        sprint(file, "/proc/%d/note", pid);
        break;
    case PNGROUP:
        sprint(file, "/proc/%d/notepg", pid);
        break;
    case PNCTL:
        sprint(file, "/proc/%d/ctl", pid);
        break;
    default:
        return -1;
    }

    f = open(file, OWRITE);
    if(f < 0)
        return -1;

    r = strlen(note);
    if(write(f, note, r) != r) {
        close(f);
        return -1;
    }
    close(f);
    return 0;
}
@


%-------------------------------------------------------------

<<windows/apps/statusbar.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <bio.h>
#include <event.h>

<<enum _anon_ (windows/apps/statusbar.c)>>

static char* rdenv(char*);
int newwin(char*);
Rectangle screenrect(void);

<<global nokill>>
<<global textmode>>
<<global title>>

<<global light>>
<<global dark>>
<<global text (windows/apps/statusbar.c)>>

<<function initcolor>>

<<global rbar>>
<<global ptext>>
static vlong n, d;
<<global last>>
<<global lastp (windows/apps/statusbar.c)>>

<<global backup>>

<<function drawbar>>

<<function eresized (windows/apps/statusbar.c)>>

<<function bar>>


<<function usage (windows/apps/statusbar.c)>>

<<function main (windows/apps/statusbar.c)>>


<<function rdenv>>

<<function newwin>>

<<function screenrect>>

<<function postnote>>
@


\subsection*{[[windows/apps/winwatch.c]]}

<<struct Win>>=
struct Win {
    int n;
    int dirty;
    char *label;
    Rectangle r;
};
@

<<global exclude>>=
static Reprog  *exclude  = nil;
@

<<global win>>=
static Win *win;
@

<<global nwin>>=
static int nwin;
@

<<global mwin>>=
static int mwin;
@

<<global onwin>>=
static int onwin;
@

<<global lightblue>>=
static Image *lightblue;
@

<<enum _anon_ (windows/apps/winwatch.c)>>=
enum {
    PAD = 3,
    MARGIN = 5
};
@

<<function erealloc (windows/apps/winwatch.c)>>=
static void*
erealloc(void *v, ulong n)
{
    v = realloc(v, n);
    if(v == nil)
        sysfatal("out of memory reallocating %lud", n);
    return v;
}
@

<<function emalloc (windows/apps/winwatch.c)>>=
static void*
emalloc(ulong n)
{
    void *v;

    v = malloc(n);
    if(v == nil)
        sysfatal("out of memory allocating %lud", n);
    memset(v, 0, n);
    return v;
}
@

<<function estrdup (windows/apps/winwatch.c)>>=
static char*
estrdup(char *s)
{
    int l;
    char *t;

    if (s == nil)
        return nil;
    l = strlen(s)+1;
    t = emalloc(l);
    memcpy(t, s, l);

    return t;
}
@

<<function refreshwin>>=
static void
refreshwin(void)
{
    char label[128];
    int i, fd, lfd, n, nr, nw, m;
    Dir *pd;

    if((fd = open("/dev/wsys", OREAD)) < 0)
        return;

    nw = 0;
/* i'd rather read one at a time but rio won't let me */
    while((nr=dirread(fd, &pd)) > 0){
        for(i=0; i<nr; i++){
            n = atoi(pd[i].name);
            sprint(label, "/dev/wsys/%d/label", n);
            if((lfd = open(label, OREAD)) < 0)
                continue;
            m = read(lfd, label, sizeof(label)-1);
            close(lfd);
            if(m < 0)
                continue;
            label[m] = '\0';
            if(exclude != nil && regexec(exclude,label,nil,0))
                continue;

            if(nw < nwin && win[nw].n == n && strcmp(win[nw].label, label)==0){
                nw++;
                continue;
            }
    
            if(nw < nwin){
                free(win[nw].label);
                win[nw].label = nil;
            }
            
            if(nw >= mwin){
                mwin += 8;
                win = erealloc(win, mwin*sizeof(win[0]));
            }
            win[nw].n = n;
            win[nw].label = estrdup(label);
            win[nw].dirty = 1;
            win[nw].r = Rect(0,0,0,0);
            nw++;
        }
        free(pd);
    }
    while(nwin > nw)
        free(win[--nwin].label);
    nwin = nw;
    close(fd);
}
@

<<function drawnowin>>=
static void
drawnowin(int i)
{
    Rectangle r;

    r = Rect(0,0,(Dx(screen->r)-2*MARGIN+PAD)/cols-PAD, font->height);
    r = rectaddpt(rectaddpt(r, Pt(MARGIN+(PAD+Dx(r))*(i/rows),
                MARGIN+(PAD+Dy(r))*(i%rows))), screen->r.min);
    draw(screen, insetrect(r, -1), lightblue, nil, ZP);
}
@

<<function drawwin>>=
static void
drawwin(int i)
{
    draw(screen, win[i].r, lightblue, nil, ZP);
    _string(screen, addpt(win[i].r.min, Pt(2,0)), display->black, ZP,
        font, win[i].label, nil, strlen(win[i].label), 
        win[i].r, nil, ZP, SoverD);
    border(screen, win[i].r, 1, display->black, ZP);	
    win[i].dirty = 0;
}
@

<<function geometry>>=
static int
geometry(void)
{
    int i, ncols, z;
    Rectangle r;

    z = 0;
    rows = (Dy(screen->r)-2*MARGIN+PAD)/(font->height+PAD);
    if(rows*cols < nwin || rows*cols >= nwin*2){
        ncols = nwin <= 0 ? 1 : (nwin+rows-1)/rows;
        if(ncols != cols){
            cols = ncols;
            z = 1;
        }
    }

    r = Rect(0,0,(Dx(screen->r)-2*MARGIN+PAD)/cols-PAD, font->height);
    for(i=0; i<nwin; i++)
        win[i].r = rectaddpt(rectaddpt(r, Pt(MARGIN+(PAD+Dx(r))*(i/rows),
                    MARGIN+(PAD+Dy(r))*(i%rows))), screen->r.min);

    return z;
}
@

<<function redraw (windows/apps/winwatch.c)>>=
static void
redraw(Image *screen, int all)
{
    int i;

    all |= geometry();
    if(all)
        draw(screen, screen->r, lightblue, nil, ZP);
    for(i=0; i<nwin; i++)
        if(all || win[i].dirty)
            drawwin(i);
    if(!all)
        for(; i<onwin; i++)
            drawnowin(i);

    onwin = nwin;
}
@

<<function eresized (windows/apps/winwatch.c)>>=
void
eresized(int new)
{
    if(new && getwindow(display, Refmesg) < 0)
        fprint(2,"can't reattach to window");
    geometry();
    redraw(screen, 1);
}
@

<<function click>>=
static void
click(Mouse m)
{
    int fd, i, j;	
    char buf[128];

    if(m.buttons == 0 || (m.buttons & ~4))
        return;

    for(i=0; i<nwin; i++)
        if(ptinrect(m.xy, win[i].r))
            break;
    if(i == nwin)
        return;

    do
        m = emouse();
    while(m.buttons == 4);

    if(m.buttons != 0){
        do
            m = emouse();
        while(m.buttons);
        return;
    }

    for(j=0; j<nwin; j++)
        if(ptinrect(m.xy, win[j].r))
            break;
    if(j != i)
        return;

    sprint(buf, "/dev/wsys/%d/wctl", win[i].n);
    if((fd = open(buf, OWRITE)) < 0)
        return;
    write(fd, "unhide\n", 7);
    write(fd, "top\n", 4);
    write(fd, "current\n", 8);
    close(fd);
}
@

<<function usage (windows/apps/winwatch.c)>>=
static void
usage(void)
{
    fprint(2, "usage: winwatch [-e exclude] [-f font]\n");
    exits("usage");
}
@

<<function main (windows/apps/winwatch.c)>>=
void
main(int argc, char **argv)
{
    char *fontname;
    int Etimer;
    Event e;

    fontname = "/lib/font/bit/lucidasans/unicode.8.font";
    ARGBEGIN{
    case 'f':
        fontname = EARGF(usage());
        break;
    case 'e':
        exclude = regcomp(EARGF(usage()));
        if(exclude == nil)
            sysfatal("Bad regexp");
        break;
    default:
        usage();
    }ARGEND

    if(argc)
        usage();

    initdraw(0, 0, "winwatch");
    lightblue = allocimagemix(display, DPalebluegreen, DWhite);
    if(lightblue == nil)
        sysfatal("allocimagemix: %r");
    if((font = openfont(display, fontname)) == nil)
        sysfatal("font '%s' not found", fontname);

    refreshwin();
    redraw(screen, 1);
    einit(Emouse|Ekeyboard);
    Etimer = etimer(0, 2500);

    for(;;){
        switch(eread(Emouse|Ekeyboard|Etimer, &e)){
        case Ekeyboard:
            if(e.kbdc==0x7F || e.kbdc=='q')
                exits(0);
            break;
        case Emouse:
            if(e.mouse.buttons)
                click(e.mouse);
            /* fall through  */
        default:	/* Etimer */
            refreshwin();
            redraw(screen, 0);
            break;
        }
    }
}
@


%-------------------------------------------------------------

<<windows/apps/winwatch.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <event.h>
#include <regexp.h>

typedef struct Win Win;
<<struct Win>>



<<global exclude>>
<<global win>>
<<global nwin>>
<<global mwin>>
<<global onwin>>
static int rows, cols;
<<global lightblue>>

extern Font *font;

<<enum _anon_ (windows/apps/winwatch.c)>>

<<function erealloc (windows/apps/winwatch.c)>>

<<function emalloc (windows/apps/winwatch.c)>>

<<function estrdup (windows/apps/winwatch.c)>>


<<function refreshwin>>

<<function drawnowin>>

<<function drawwin>>

<<function geometry>>

<<function redraw (windows/apps/winwatch.c)>>

<<function eresized (windows/apps/winwatch.c)>>

<<function click>>

<<function usage (windows/apps/winwatch.c)>>

<<function main (windows/apps/winwatch.c)>>
@


\section{[[windows/]]}


\section{[[windows/libcomplete/]]}

\subsection*{[[windows/libcomplete/complete.c]]}

<<function longestprefixlength>>=
static int
longestprefixlength(char *a, char *b, int n)
{
    int i, w;
    Rune ra, rb;

    for(i=0; i<n; i+=w){
        w = chartorune(&ra, a);
        chartorune(&rb, b);
        if(ra != rb)
            break;
        a += w;
        b += w;
    }
    return i;
}
@

<<function freecompletion>>=
void
freecompletion(Completion *c)
{
    if(c){
        free(c->filename);
        free(c);
    }
}
@

<<function strpcmp>>=
static int
strpcmp(const void *va, const void *vb)
{
    char *a, *b;

    a = *(char**)va;
    b = *(char**)vb;
    return strcmp(a, b);
}
@

<<function complete>>=
Completion*
complete(char *dir, char *s)
{
    long i, l, n, nfile, len, nbytes;
    int fd, minlen;
    Dir *dirp;
    char **name, *p;
    ulong* mode;
    Completion *c;

    if(strchr(s, '/') != nil){
        werrstr("slash character in name argument to complete()");
        return nil;
    }

    fd = open(dir, OREAD);
    if(fd < 0)
        return nil;

    n = dirreadall(fd, &dirp);
    if(n <= 0){
        close(fd);
        return nil;
    }

    /* find longest string, for allocation */
    len = 0;
    for(i=0; i<n; i++){
        l = strlen(dirp[i].name) + 1 + 1; /* +1 for /   +1 for \0 */
        if(l > len)
            len = l;
    }

    name = malloc(n*sizeof(char*));
    mode = malloc(n*sizeof(ulong));
    c = malloc(sizeof(Completion) + len);
    if(name == nil || mode == nil || c == nil)
        goto Return;
    memset(c, 0, sizeof(Completion));

    /* find the matches */
    len = strlen(s);
    nfile = 0;
    minlen = 1000000;
    for(i=0; i<n; i++)
        if(strncmp(s, dirp[i].name, len) == 0){
            name[nfile] = dirp[i].name;
            mode[nfile] = dirp[i].mode;
            if(minlen > strlen(dirp[i].name))
                minlen = strlen(dirp[i].name);
            nfile++;
        }

    if(nfile > 0) {
        /* report interesting results */
        /* trim length back to longest common initial string */
        for(i=1; i<nfile; i++)
            minlen = longestprefixlength(name[0], name[i], minlen);

        /* build the answer */
        c->complete = (nfile == 1);
        c->advance = c->complete || (minlen > len);
        c->string = (char*)(c+1);
        memmove(c->string, name[0]+len, minlen-len);
        if(c->complete)
            c->string[minlen++ - len] = (mode[0]&DMDIR)? '/' : ' ';
        c->string[minlen - len] = '\0';
        c->nmatch = nfile;
    } else {
        /* no match, so return all possible strings */
        for(i=0; i<n; i++){
            name[i] = dirp[i].name;
            mode[i] = dirp[i].mode;
        }
        nfile = n;
        c->nmatch = 0;
    }

    /* attach list of names */
    nbytes = nfile * sizeof(char*);
    for(i=0; i<nfile; i++)
        nbytes += strlen(name[i]) + 1 + 1;
    c->filename = malloc(nbytes);
    if(c->filename == nil)
        goto Return;
    p = (char*)(c->filename + nfile);
    for(i=0; i<nfile; i++){
        c->filename[i] = p;
        strcpy(p, name[i]);
        p += strlen(p);
        if(mode[i] & DMDIR)
            *p++ = '/';
        *p++ = '\0';
    }
    c->nfile = nfile;
    qsort(c->filename, c->nfile, sizeof(c->filename[0]), strpcmp);

  Return:
    free(name);
    free(mode);
    free(dirp);
    close(fd);
    return c;
}
@


%-------------------------------------------------------------

<<windows/libcomplete/complete.c>>=
#include <u.h>
#include <libc.h>
#include "complete.h"

<<function longestprefixlength>>

<<function freecompletion>>

<<function strpcmp>>

<<function complete>>
@


\section{[[windows/libframe/]]}

\subsection*{[[windows/libframe/frbox.c]]}

<<constant SLOP>>=
#define	SLOP	25
@

<<function _fraddbox>>=
void
_fraddbox(Frame *f, int bn, int n)	/* add n boxes after bn, shift the rest up,
                 * box[bn+n]==box[bn] */
{
    int i;

    if(bn > f->nbox)
        drawerror(f->display, "_fraddbox");
    if(f->nbox+n > f->nalloc)
        _frgrowbox(f, n+SLOP);
    for(i=f->nbox; --i>=bn; )
        f->box[i+n] = f->box[i];
    f->nbox+=n;
}
@

<<function _frclosebox>>=
void
_frclosebox(Frame *f, int n0, int n1)	/* inclusive */
{
    int i;

    if(n0>=f->nbox || n1>=f->nbox || n1<n0)
        drawerror(f->display, "_frclosebox");
    n1++;
    for(i=n1; i<f->nbox; i++)
        f->box[i-(n1-n0)] = f->box[i];
    f->nbox -= n1-n0;
}
@

<<function _frdelbox>>=
void
_frdelbox(Frame *f, int n0, int n1)	/* inclusive */
{
    if(n0>=f->nbox || n1>=f->nbox || n1<n0)
        drawerror(f->display, "_frdelbox");
    _frfreebox(f, n0, n1);
    _frclosebox(f, n0, n1);
}
@

<<function _frfreebox>>=
void
_frfreebox(Frame *f, int n0, int n1)	/* inclusive */
{
    int i;

    if(n1<n0)
        return;
    if(n0>=f->nbox || n1>=f->nbox)
        drawerror(f->display, "_frfreebox");
    n1++;
    for(i=n0; i<n1; i++)
        if(f->box[i].nrune >= 0)
            free(f->box[i].ptr);
}
@

<<function _frgrowbox>>=
void
_frgrowbox(Frame *f, int delta)
{
    f->nalloc += delta;
    f->box = realloc(f->box, f->nalloc*sizeof(Frbox));
    if(f->box == 0)
        drawerror(f->display, "_frgrowbox");
}
@

<<function dupbox>>=
static
void
dupbox(Frame *f, int bn)
{
    uchar *p;

    if(f->box[bn].nrune < 0)
        drawerror(f->display, "dupbox");
    _fraddbox(f, bn, 1);
    if(f->box[bn].nrune >= 0){
        p = _frallocstr(f, NBYTE(&f->box[bn])+1);
        strcpy((char*)p, (char*)f->box[bn].ptr);
        f->box[bn+1].ptr = p;
    }
}
@

<<function runeindex>>=
static
uchar*
runeindex(uchar *p, int n)
{
    int i, w;
    Rune rune;

    for(i=0; i<n; i++,p+=w)
        if(*p < Runeself)
            w = 1;
        else{
            w = chartorune(&rune, (char*)p);
            USED(rune);
        }
    return p;
}
@

<<function truncatebox>>=
static
void
truncatebox(Frame *f, Frbox *b, int n)	/* drop last n chars; no allocation done */
{
    if(b->nrune<0 || b->nrune<n)
        drawerror(f->display, "truncatebox");
    b->nrune -= n;
    runeindex(b->ptr, b->nrune)[0] = 0;
    b->wid = stringwidth(f->font, (char *)b->ptr);
}
@

<<function chopbox>>=
static
void
chopbox(Frame *f, Frbox *b, int n)	/* drop first n chars; no allocation done */
{
    char *p;

    if(b->nrune<0 || b->nrune<n)
        drawerror(f->display, "chopbox");
    p = (char*)runeindex(b->ptr, n);
    memmove((char*)b->ptr, p, strlen(p)+1);
    b->nrune -= n;
    b->wid = stringwidth(f->font, (char *)b->ptr);
}
@

<<function _frsplitbox>>=
void
_frsplitbox(Frame *f, int bn, int n)
{
    dupbox(f, bn);
    truncatebox(f, &f->box[bn], f->box[bn].nrune-n);
    chopbox(f, &f->box[bn+1], n);
}
@

<<function _frmergebox>>=
void
_frmergebox(Frame *f, int bn)		/* merge bn and bn+1 */
{
    Frbox *b;

    b = &f->box[bn];
    _frinsure(f, bn, NBYTE(&b[0])+NBYTE(&b[1])+1);
    strcpy((char*)runeindex(b[0].ptr, b[0].nrune), (char*)b[1].ptr);
    b[0].wid += b[1].wid;
    b[0].nrune += b[1].nrune;
    _frdelbox(f, bn+1, bn+1);
}
@

<<function _frfindbox>>=
int
_frfindbox(Frame *f, int bn, ulong p, ulong q)	/* find box containing q and put q on a box boundary */
{
    Frbox *b;

    for(b = &f->box[bn]; bn<f->nbox && p+NRUNE(b)<=q; bn++, b++)
        p += NRUNE(b);
    if(p != q)
        _frsplitbox(f, bn++, (int)(q-p));
    return bn;
}
@


%-------------------------------------------------------------

<<windows/libframe/frbox.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <mouse.h>
#include <frame.h>

<<constant SLOP>>

<<function _fraddbox>>

<<function _frclosebox>>

<<function _frdelbox>>

<<function _frfreebox>>

<<function _frgrowbox>>

<<function dupbox>>

<<function runeindex>>

<<function truncatebox>>

<<function chopbox>>

<<function _frsplitbox>>

<<function _frmergebox>>

<<function _frfindbox>>
@


\subsection*{[[windows/libframe/frdelete.c]]}

<<function frdelete>>=
int
frdelete(Frame *f, ulong p0, ulong p1)
{
    Point pt0, pt1, ppt0;
    Frbox *b;
    int n0, n1, n;
    ulong cn1;
    Rectangle r;
    int nn0;
    Image *col;

    if(p0>=f->nchars || p0==p1 || f->b==nil)
        return 0;
    if(p1 > f->nchars)
        p1 = f->nchars;
    n0 = _frfindbox(f, 0, 0, p0);
    if(n0 == f->nbox)
        drawerror(f->display, "off end in frdelete");
    n1 = _frfindbox(f, n0, p0, p1);
    pt0 = _frptofcharnb(f, p0, n0);
    pt1 = frptofchar(f, p1);
    if(f->p0 == f->p1)
        frtick(f, frptofchar(f, f->p0), 0);
    nn0 = n0;
    ppt0 = pt0;
    _frfreebox(f, n0, n1-1);
    f->modified = 1;

    /*
     * Invariants:
     *  - pt0 points to beginning, pt1 points to end
     *  - n0 is box containing beginning of stuff being deleted
     *  - n1, b are box containing beginning of stuff to be kept after deletion
     *  - cn1 is char position of n1
     *  - f->p0 and f->p1 are not adjusted until after all deletion is done
     */
    b = &f->box[n1];
    cn1 = p1;
    while(pt1.x!=pt0.x && n1<f->nbox){
        _frcklinewrap0(f, &pt0, b);
        _frcklinewrap(f, &pt1, b);
        n = _frcanfit(f, pt0, b);
        if(n==0)
            drawerror(f->display, "_frcanfit==0");
        r.min = pt0;
        r.max = pt0;
        r.max.y += f->font->height;
        if(b->nrune > 0){
            if(n != b->nrune){
                _frsplitbox(f, n1, n);
                b = &f->box[n1];
            }
            r.max.x += b->wid;
            draw(f->b, r, f->b, nil, pt1);
            cn1 += b->nrune;
        }else{
            r.max.x += _frnewwid0(f, pt0, b);
            if(r.max.x > f->r.max.x)
                r.max.x = f->r.max.x;
            col = f->cols[BACK];
            if(f->p0<=cn1 && cn1<f->p1)
                col = f->cols[HIGH];
            draw(f->b, r, col, nil, pt0);
            cn1++;
        }
        _fradvance(f, &pt1, b);
        pt0.x += _frnewwid(f, pt0, b);
        f->box[n0++] = f->box[n1++];
        b++;
    }
    if(n1==f->nbox && pt0.x!=pt1.x)	/* deleting last thing in window; must clean up */
        frselectpaint(f, pt0, pt1, f->cols[BACK]);
    if(pt1.y != pt0.y){
        Point pt2;

        pt2 = _frptofcharptb(f, 32767, pt1, n1);
        if(pt2.y > f->r.max.y)
            drawerror(f->display, "frptofchar in frdelete");
        if(n1 < f->nbox){
            int q0, q1, q2;

            q0 = pt0.y+f->font->height;
            q1 = pt1.y+f->font->height;
            q2 = pt2.y+f->font->height;
            if(q2 > f->r.max.y)
                q2 = f->r.max.y;
            draw(f->b, Rect(pt0.x, pt0.y, pt0.x+(f->r.max.x-pt1.x), q0),
                f->b, nil, pt1);
            draw(f->b, Rect(f->r.min.x, q0, f->r.max.x, q0+(q2-q1)),
                f->b, nil, Pt(f->r.min.x, q1));
            frselectpaint(f, Pt(pt2.x, pt2.y-(pt1.y-pt0.y)), pt2, f->cols[BACK]);
        }else
            frselectpaint(f, pt0, pt2, f->cols[BACK]);
    }
    _frclosebox(f, n0, n1-1);
    if(nn0>0 && f->box[nn0-1].nrune>=0 && ppt0.x-f->box[nn0-1].wid>=(int)f->r.min.x){
        --nn0;
        ppt0.x -= f->box[nn0].wid;
    }
    _frclean(f, ppt0, nn0, n0<f->nbox-1? n0+1 : n0);
    if(f->p1 > p1)
        f->p1 -= p1-p0;
    else if(f->p1 > p0)
        f->p1 = p0;
    if(f->p0 > p1)
        f->p0 -= p1-p0;
    else if(f->p0 > p0)
        f->p0 = p0;
    f->nchars -= p1-p0;
    if(f->p0 == f->p1)
        frtick(f, frptofchar(f, f->p0), 1);
    pt0 = frptofchar(f, f->nchars);
    n = f->nlines;
    f->nlines = (pt0.y-f->r.min.y)/f->font->height+(pt0.x>f->r.min.x);
    return n - f->nlines;
}
@


%-------------------------------------------------------------

<<windows/libframe/frdelete.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <mouse.h>
#include <frame.h>

<<function frdelete>>
@


\subsection*{[[windows/libframe/frdraw.c]]}

<<function _frdrawtext>>=
void
_frdrawtext(Frame *f, Point pt, Image *text, Image *back)
{
    Frbox *b;
    int nb;
    static int x;

    for(nb=0,b=f->box; nb<f->nbox; nb++, b++){
        _frcklinewrap(f, &pt, b);
        if(b->nrune >= 0){
            stringbg(f->b, pt, text, ZP, f->font, (char*)b->ptr, back, ZP);
        }
        pt.x += b->wid;
    }
}
@

<<function nbytes>>=
static int
nbytes(char *s0, int nr)
{
    char *s;
    Rune r;

    s = s0;
    while(--nr >= 0)
        s += chartorune(&r, s);
    return s-s0;
}
@

<<function frdrawsel>>=
void
frdrawsel(Frame *f, Point pt, ulong p0, ulong p1, int issel)
{
    Image *back, *text;

    if(f->ticked)
        frtick(f, frptofchar(f, f->p0), 0);

    if(p0 == p1){
        frtick(f, pt, issel);
        return;
    }

    if(issel){
        back = f->cols[HIGH];
        text = f->cols[HTEXT];
    }else{
        back = f->cols[BACK];
        text = f->cols[TEXT];
    }

    frdrawsel0(f, pt, p0, p1, back, text);
}
@

<<function frdrawsel0>>=
Point
frdrawsel0(Frame *f, Point pt, ulong p0, ulong p1, Image *back, Image *text)
{
    Frbox *b;
    int nb, nr, w, x, trim;
    Point qt;
    uint p;
    char *ptr;

    p = 0;
    b = f->box;
    trim = 0;
    for(nb=0; nb<f->nbox && p<p1; nb++){
        nr = b->nrune;
        if(nr < 0)
            nr = 1;
        if(p+nr <= p0)
            goto Continue;
        if(p >= p0){
            qt = pt;
            _frcklinewrap(f, &pt, b);
            /* fill in the end of a wrapped line */
            if(pt.y > qt.y)
                draw(f->b, Rect(qt.x, qt.y, f->r.max.x, pt.y), back, nil, qt);
        }
        ptr = (char*)b->ptr;
        if(p < p0){	/* beginning of region: advance into box */
            ptr += nbytes(ptr, p0-p);
            nr -= (p0-p);
            p = p0;
        }
        trim = 0;
        if(p+nr > p1){	/* end of region: trim box */
            nr -= (p+nr)-p1;
            trim = 1;
        }
        if(b->nrune<0 || nr==b->nrune)
            w = b->wid;
        else
            w = stringnwidth(f->font, ptr, nr);
        x = pt.x+w;
        if(x > f->r.max.x)
            x = f->r.max.x;
        draw(f->b, Rect(pt.x, pt.y, x, pt.y+f->font->height), back, nil, pt);
        if(b->nrune >= 0)
            stringnbg(f->b, pt, text, ZP, f->font, ptr, nr, back, ZP);
        pt.x += w;
        Continue:
        b++;
        p += nr;
    }
    /* if this is end of last plain text box on wrapped line, fill to end of line */
    if(p1>p0 &&  b>f->box && b<f->box+f->nbox && b[-1].nrune>0 && !trim){
        qt = pt;
        _frcklinewrap(f, &pt, b);
        if(pt.y > qt.y)
            draw(f->b, Rect(qt.x, qt.y, f->r.max.x, pt.y), back, nil, qt);
    }
    return pt;
}
@

<<function frredraw>>=
void
frredraw(Frame *f)
{
    int ticked;
    Point pt;

    if(f->p0 == f->p1){
        ticked = f->ticked;
        if(ticked)
            frtick(f, frptofchar(f, f->p0), 0);
        frdrawsel0(f, frptofchar(f, 0), 0, f->nchars, f->cols[BACK], f->cols[TEXT]);
        if(ticked)
            frtick(f, frptofchar(f, f->p0), 1);
        return;
    }

    pt = frptofchar(f, 0);
    pt = frdrawsel0(f, pt, 0, f->p0, f->cols[BACK], f->cols[TEXT]);
    pt = frdrawsel0(f, pt, f->p0, f->p1, f->cols[HIGH], f->cols[HTEXT]);
    pt = frdrawsel0(f, pt, f->p1, f->nchars, f->cols[BACK], f->cols[TEXT]);
}
@

<<function frtick>>=
void
frtick(Frame *f, Point pt, int ticked)
{
    Rectangle r;

    if(f->ticked==ticked || f->tick==0 || !ptinrect(pt, f->r))
        return;
    pt.x--;	/* looks best just left of where requested */
    r = Rect(pt.x, pt.y, pt.x+FRTICKW, pt.y+f->font->height);
    /* can go into left border but not right */
    if(r.max.x > f->r.max.x)
        r.max.x = f->r.max.x;
    if(ticked){
        draw(f->tickback, f->tickback->r, f->b, nil, pt);
        draw(f->b, r, f->tick, nil, ZP);
    }else
        draw(f->b, r, f->tickback, nil, ZP);
    f->ticked = ticked;
}
@

<<function _frdraw>>=
Point
_frdraw(Frame *f, Point pt)
{
    Frbox *b;
    int nb, n;

    for(b=f->box,nb=0; nb<f->nbox; nb++, b++){
        _frcklinewrap0(f, &pt, b);
        if(pt.y == f->r.max.y){
            f->nchars -= _frstrlen(f, nb);
            _frdelbox(f, nb, f->nbox-1);
            break;
        }
        if(b->nrune > 0){
            n = _frcanfit(f, pt, b);
            if(n == 0)
                drawerror(f->display, "_frcanfit==0");
            if(n != b->nrune){
                _frsplitbox(f, nb, n);
                b = &f->box[nb];
            }
            pt.x += b->wid;
        }else{
            if(b->bc == '\n'){
                pt.x = f->r.min.x;
                pt.y+=f->font->height;
            }else
                pt.x += _frnewwid(f, pt, b);
        }
    }
    return pt;
}
@

<<function _frstrlen>>=
int
_frstrlen(Frame *f, int nb)
{
    int n;

    for(n=0; nb<f->nbox; nb++)
        n += NRUNE(&f->box[nb]);
    return n;
}
@


%-------------------------------------------------------------

<<windows/libframe/frdraw.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <mouse.h>
#include <frame.h>

<<function _frdrawtext>>

<<function nbytes>>

<<function frdrawsel>>

<<function frdrawsel0>>

<<function frredraw>>

<<function frtick>>

<<function _frdraw>>

<<function _frstrlen>>
@


\subsection*{[[windows/libframe/frinit.c]]}

<<function frinit>>=
void
frinit(Frame *f, Rectangle r, Font *ft, Image *b, Image *cols[NCOL])
{
    f->font = ft;
    f->display = b->display;
    f->maxtab = 8*stringwidth(ft, "0");
    f->nbox = 0;
    f->nalloc = 0;
    f->nchars = 0;
    f->nlines = 0;
    f->p0 = 0;
    f->p1 = 0;
    f->box = 0;
    f->lastlinefull = 0;
    if(cols != 0)
        memmove(f->cols, cols, sizeof f->cols);
    frsetrects(f, r, b);
    if(f->tick==nil && f->cols[BACK]!=0)
        frinittick(f);
}
@

<<function frinittick>>=
void
frinittick(Frame *f)
{
    Image *b;
    Font *ft;

    b = f->display->screenimage;
    ft = f->font;
    if(f->tick)
        freeimage(f->tick);
    f->tick = allocimage(f->display, Rect(0, 0, FRTICKW, ft->height), b->chan, 0, DWhite);
    if(f->tick == nil)
        return;
    if(f->tickback)
        freeimage(f->tickback);
    f->tickback = allocimage(f->display, f->tick->r, b->chan, 0, DWhite);
    if(f->tickback == 0){
        freeimage(f->tick);
        f->tick = 0;
        return;
    }
    /* background color */
    draw(f->tick, f->tick->r, f->cols[BACK], nil, ZP);
    /* vertical line */
    draw(f->tick, Rect(FRTICKW/2, 0, FRTICKW/2+1, ft->height), f->cols[TEXT], nil, ZP);
    /* box on each end */
    draw(f->tick, Rect(0, 0, FRTICKW, FRTICKW), f->cols[TEXT], nil, ZP);
    draw(f->tick, Rect(0, ft->height-FRTICKW, FRTICKW, ft->height), f->cols[TEXT], nil, ZP);
}
@

<<function frsetrects>>=
void
frsetrects(Frame *f, Rectangle r, Image *b)
{
    f->b = b;
    f->entire = r;
    f->r = r;
    f->r.max.y -= (r.max.y-r.min.y)%f->font->height;
    f->maxlines = (r.max.y-r.min.y)/f->font->height;
}
@

<<function frclear>>=
void
frclear(Frame *f, int freeall)
{
    if(f->nbox)
        _frdelbox(f, 0, f->nbox-1);
    if(f->box)
        free(f->box);
    if(freeall){
        freeimage(f->tick);
        freeimage(f->tickback);
        f->tick = 0;
        f->tickback = 0;
    }
    f->box = 0;
    f->ticked = 0;
}
@


%-------------------------------------------------------------

<<windows/libframe/frinit.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <mouse.h>
#include <frame.h>

<<function frinit>>

<<function frinittick>>

<<function frsetrects>>

<<function frclear>>
@


\subsection*{[[windows/libframe/frinsert.c]]}

<<constant DELTA>>=
#define	DELTA	25
@

<<constant TMPSIZE>>=
#define	TMPSIZE	256
@

<<global frame>>=
static Frame		frame;
@

<<function bxscan>>=
static
Point
bxscan(Frame *f, Rune *sp, Rune *ep, Point *ppt)
{
    int w, c, nb, delta, nl, nr, rw;
    Frbox *b;
    char *s, tmp[TMPSIZE+3];	/* +3 for rune overflow */
    uchar *p;

    frame.r = f->r;
    frame.b = f->b;
    frame.font = f->font;
    frame.maxtab = f->maxtab;
    frame.nbox = 0;
    frame.nchars = 0;
    memmove(frame.cols, f->cols, sizeof frame.cols);
    delta = DELTA;
    nl = 0;
    for(nb=0; sp<ep && nl<=f->maxlines; nb++,frame.nbox++){
        if(nb == frame.nalloc){
            _frgrowbox(&frame, delta);
            if(delta < 10000)
                delta *= 2;
        }
        b = &frame.box[nb];
        c = *sp;
        if(c=='\t' || c=='\n'){
            b->bc = c;
            b->wid = 5000;
            b->minwid = (c=='\n')? 0 : stringwidth(frame.font, " ");
            b->nrune = -1;
            if(c=='\n')
                nl++;
            frame.nchars++;
            sp++;
        }else{
            s = tmp;
            nr = 0;
            w = 0;
            while(sp < ep){
                c = *sp;
                if(c=='\t' || c=='\n')
                    break;
                rw = runetochar(s, sp);
                if(s+rw >= tmp+TMPSIZE)
                    break;
                w += runestringnwidth(frame.font, sp, 1);
                sp++;
                s += rw;
                nr++;
            }
            *s++ = 0;
            p = _frallocstr(f, s-tmp);
            b = &frame.box[nb];
            b->ptr = p;
            memmove(p, tmp, s-tmp);
            b->wid = w;
            b->nrune = nr;
            frame.nchars += nr;
        }
    }
    _frcklinewrap0(f, ppt, &frame.box[0]);
    return _frdraw(&frame, *ppt);
}
@

<<function chopframe>>=
static
void
chopframe(Frame *f, Point pt, ulong p, int bn)
{
    Frbox *b;

    for(b = &f->box[bn]; ; b++){
        if(b >= &f->box[f->nbox])
            drawerror(f->display, "endofframe");
        _frcklinewrap(f, &pt, b);
        if(pt.y >= f->r.max.y)
            break;
        p += NRUNE(b);
        _fradvance(f, &pt, b);
    }
    f->nchars = p;
    f->nlines = f->maxlines;
    if(b<&f->box[f->nbox])				/* BUG */
        _frdelbox(f, (int)(b-f->box), f->nbox-1);
}
@

<<struct points_frinsert>>=
struct points_frinsert {
    Point pt0, pt1;
};
@

<<function frinsert>>=
void
frinsert(Frame *f, Rune *sp, Rune *ep, ulong p0)
{
    Point pt0, pt1, opt0, ppt0, ppt1, pt;
    Frbox *b;
    int n, n0, nn0, y;
    ulong cn0;
    Image *col;
    Rectangle r;
    static struct points_frinsert *pts;
    static int nalloc=0;
    int npts;

    if(p0>f->nchars || sp==ep || f->b==nil)
        return;
    n0 = _frfindbox(f, 0, 0, p0);
    cn0 = p0;
    nn0 = n0;
    pt0 = _frptofcharnb(f, p0, n0);
    ppt0 = pt0;
    opt0 = pt0;
    pt1 = bxscan(f, sp, ep, &ppt0);
    ppt1 = pt1;
    if(n0 < f->nbox){
        _frcklinewrap(f, &pt0, b = &f->box[n0]);	/* for frdrawsel() */
        _frcklinewrap0(f, &ppt1, b);
    }
    f->modified = 1;
    /*
     * ppt0 and ppt1 are start and end of insertion as they will appear when
     * insertion is complete. pt0 is current location of insertion position
     * (p0); pt1 is terminal point (without line wrap) of insertion.
     */
    if(f->p0 == f->p1)
        frtick(f, frptofchar(f, f->p0), 0);

    /*
     * Find point where old and new x's line up
     * Invariants:
     *	pt0 is where the next box (b, n0) is now
     *	pt1 is where it will be after the insertion
     * If pt1 goes off the rectangle, we can toss everything from there on
     */
    for(b = &f->box[n0],npts=0;
         pt1.x!=pt0.x && pt1.y!=f->r.max.y && n0<f->nbox; b++,n0++,npts++){
        _frcklinewrap(f, &pt0, b);
        _frcklinewrap0(f, &pt1, b);
        if(b->nrune > 0){
            n = _frcanfit(f, pt1, b);
            if(n == 0)
                drawerror(f->display, "_frcanfit==0");
            if(n != b->nrune){
                _frsplitbox(f, n0, n);
                b = &f->box[n0];
            }
        }
        if(npts == nalloc){
            pts = realloc(pts, (npts+DELTA)*sizeof(pts[0]));
            nalloc += DELTA;
            b = &f->box[n0];
        }
        pts[npts].pt0 = pt0;
        pts[npts].pt1 = pt1;
        /* has a text box overflowed off the frame? */
        if(pt1.y == f->r.max.y)
            break;
        _fradvance(f, &pt0, b);
        pt1.x += _frnewwid(f, pt1, b);
        cn0 += NRUNE(b);
    }
    if(pt1.y > f->r.max.y)
        drawerror(f->display, "frinsert pt1 too far");
    if(pt1.y==f->r.max.y && n0<f->nbox){
        f->nchars -= _frstrlen(f, n0);
        _frdelbox(f, n0, f->nbox-1);
    }
    if(n0 == f->nbox)
        f->nlines = (pt1.y-f->r.min.y)/f->font->height+(pt1.x>f->r.min.x);
    else if(pt1.y!=pt0.y){
        int q0, q1;

        y = f->r.max.y;
        q0 = pt0.y+f->font->height;
        q1 = pt1.y+f->font->height;
        f->nlines += (q1-q0)/f->font->height;
        if(f->nlines > f->maxlines)
            chopframe(f, ppt1, p0, nn0);
        if(pt1.y < y){
            r = f->r;
            r.min.y = q1;
            r.max.y = y;
            if(q1 < y)
                draw(f->b, r, f->b, nil, Pt(f->r.min.x, q0));
            r.min = pt1;
            r.max.x = pt1.x+(f->r.max.x-pt0.x);
            r.max.y = q1;
            draw(f->b, r, f->b, nil, pt0);
        }
    }
    /*
     * Move the old stuff down to make room.  The loop will move the stuff
     * between the insertion and the point where the x's lined up.
     * The draw()s above moved everything down after the point they lined up.
     */
    for((y=pt1.y==f->r.max.y?pt1.y:0),b = &f->box[n0-1]; --npts>=0; --b){
        pt = pts[npts].pt1;
        if(b->nrune > 0){
            r.min = pt;
            r.max = r.min;
            r.max.x += b->wid;
            r.max.y += f->font->height;
            draw(f->b, r, f->b, nil, pts[npts].pt0);
            /* clear bit hanging off right */
            if(npts==0 && pt.y>pt0.y){
                /*
                 * first new char is bigger than first char we're
                 * displacing, causing line wrap. ugly special case.
                 */
                r.min = opt0;
                r.max = opt0;
                r.max.x = f->r.max.x;
                r.max.y += f->font->height;
                if(f->p0<=cn0 && cn0<f->p1)	/* b+1 is inside selection */
                    col = f->cols[HIGH];
                else
                    col = f->cols[BACK];
                draw(f->b, r, col, nil, r.min);
            }else if(pt.y < y){
                r.min = pt;
                r.max = pt;
                r.min.x += b->wid;
                r.max.x = f->r.max.x;
                r.max.y += f->font->height;
                if(f->p0<=cn0 && cn0<f->p1)	/* b+1 is inside selection */
                    col = f->cols[HIGH];
                else
                    col = f->cols[BACK];
                draw(f->b, r, col, nil, r.min);
            }
            y = pt.y;
            cn0 -= b->nrune;
        }else{
            r.min = pt;
            r.max = pt;
            r.max.x += b->wid;
            r.max.y += f->font->height;
            if(r.max.x >= f->r.max.x)
                r.max.x = f->r.max.x;
            cn0--;
            if(f->p0<=cn0 && cn0<f->p1)	/* b is inside selection */
                col = f->cols[HIGH];
            else
                col = f->cols[BACK];
            draw(f->b, r, col, nil, r.min);
            y = 0;
            if(pt.x == f->r.min.x)
                y = pt.y;
        }
    }
    /* insertion can extend the selection, so the condition here is different */
    if(f->p0<p0 && p0<=f->p1)
        col = f->cols[HIGH];
    else
        col = f->cols[BACK];
    frselectpaint(f, ppt0, ppt1, col);
    _frdrawtext(&frame, ppt0, f->cols[TEXT], col);
    _fraddbox(f, nn0, frame.nbox);
    for(n=0; n<frame.nbox; n++)
        f->box[nn0+n] = frame.box[n];
    if(nn0>0 && f->box[nn0-1].nrune>=0 && ppt0.x-f->box[nn0-1].wid>=f->r.min.x){
        --nn0;
        ppt0.x -= f->box[nn0].wid;
    }
    n0 += frame.nbox;
    _frclean(f, ppt0, nn0, n0<f->nbox-1? n0+1 : n0);
    f->nchars += frame.nchars;
    if(f->p0 >= p0)
        f->p0 += frame.nchars;
    if(f->p0 > f->nchars)
        f->p0 = f->nchars;
    if(f->p1 >= p0)
        f->p1 += frame.nchars;
    if(f->p1 > f->nchars)
        f->p1 = f->nchars;
    if(f->p0 == f->p1)
        frtick(f, frptofchar(f, f->p0), 1);
}
@


%-------------------------------------------------------------

<<windows/libframe/frinsert.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <mouse.h>
#include <frame.h>

<<constant DELTA>>
<<constant TMPSIZE>>
<<global frame>>

<<function bxscan>>

<<function chopframe>>

<<struct points_frinsert>>

<<function frinsert>>
@


\subsection*{[[windows/libframe/frptofchar.c]]}

<<function _frptofcharptb>>=
Point
_frptofcharptb(Frame *f, ulong p, Point pt, int bn)
{
    uchar *s;
    Frbox *b;
    int w, l;
    Rune r;

    for(b = &f->box[bn]; bn<f->nbox; bn++,b++){
        _frcklinewrap(f, &pt, b);
        if(p < (l=NRUNE(b))){
            if(b->nrune > 0)
                for(s=b->ptr; p>0; s+=w, p--){
                    if((r = *s) < Runeself)
                        w = 1;
                    else
                        w = chartorune(&r, (char*)s);
                    pt.x += stringnwidth(f->font, (char*)s, 1);
                    if(r==0 || pt.x>f->r.max.x)
                        drawerror(f->display, "frptofchar");
                }
            break;
        }
        p -= l;
        _fradvance(f, &pt, b);
    }
    return pt;
}
@

<<function frptofchar>>=
Point
frptofchar(Frame *f, ulong p)
{
    return _frptofcharptb(f, p, f->r.min, 0);
}
@

<<function _frptofcharnb>>=
Point
_frptofcharnb(Frame *f, ulong p, int nb)	/* doesn't do final _fradvance to next line */
{
    Point pt;
    int nbox;

    nbox = f->nbox;
    f->nbox = nb;
    pt = _frptofcharptb(f, p, f->r.min, 0);
    f->nbox = nbox;
    return pt;
}
@

<<function _frgrid>>=
static
Point
_frgrid(Frame *f, Point p)
{
    p.y -= f->r.min.y;
    p.y -= p.y%f->font->height;
    p.y += f->r.min.y;
    if(p.x > f->r.max.x)
        p.x = f->r.max.x;
    return p;
}
@

<<function frcharofpt>>=
ulong
frcharofpt(Frame *f, Point pt)
{
    Point qt;
    int w, bn;
    uchar *s;
    Frbox *b;
    ulong p;
    Rune r;

    pt = _frgrid(f, pt);
    qt = f->r.min;
    for(b=f->box,bn=0,p=0; bn<f->nbox && qt.y<pt.y; bn++,b++){
        _frcklinewrap(f, &qt, b);
        if(qt.y >= pt.y)
            break;
        _fradvance(f, &qt, b);
        p += NRUNE(b);
    }
    for(; bn<f->nbox && qt.x<=pt.x; bn++,b++){
        _frcklinewrap(f, &qt, b);
        if(qt.y > pt.y)
            break;
        if(qt.x+b->wid > pt.x){
            if(b->nrune < 0)
                _fradvance(f, &qt, b);
            else{
                s = b->ptr;
                for(;;){
                    if((r = *s) < Runeself)
                        w = 1;
                    else
                        w = chartorune(&r, (char*)s);
                    if(r == 0)
                        drawerror(f->display, "end of string in frcharofpt");
                    qt.x += stringnwidth(f->font, (char*)s, 1);
                    s += w;
                    if(qt.x > pt.x)
                        break;
                    p++;
                }
            }
        }else{
            p += NRUNE(b);
            _fradvance(f, &qt, b);
        }
    }
    return p;
}
@


%-------------------------------------------------------------

<<windows/libframe/frptofchar.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <mouse.h>
#include <frame.h>

<<function _frptofcharptb>>

<<function frptofchar>>

<<function _frptofcharnb>>

<<function _frgrid>>

<<function frcharofpt>>
@


\subsection*{[[windows/libframe/frselect.c]]}

<<function region>>=
static
int
region(int a, int b)
{
    if(a < b)
        return -1;
    if(a == b)
        return 0;
    return 1;
}
@

<<function frselect>>=
void
frselect(Frame *f, Mousectl *mc)	/* when called, button 1 is down */
{
    ulong p0, p1, q;
    Point mp, pt0, pt1, qt;
    int reg, b, scrled;

    mp = mc->xy;
    b = mc->buttons;

    f->modified = 0;
    frdrawsel(f, frptofchar(f, f->p0), f->p0, f->p1, 0);
    p0 = p1 = frcharofpt(f, mp);
    f->p0 = p0;
    f->p1 = p1;
    pt0 = frptofchar(f, p0);
    pt1 = frptofchar(f, p1);
    frdrawsel(f, pt0, p0, p1, 1);
    reg = 0;
    do{
        scrled = 0;
        if(f->scroll){
            if(mp.y < f->r.min.y){
                (*f->scroll)(f, -(f->r.min.y-mp.y)/(int)f->font->height-1);
                p0 = f->p1;
                p1 = f->p0;
                scrled = 1;
            }else if(mp.y > f->r.max.y){
                (*f->scroll)(f, (mp.y-f->r.max.y)/(int)f->font->height+1);
                p0 = f->p0;
                p1 = f->p1;
                scrled = 1;
            }
            if(scrled){
                if(reg != region(p1, p0))
                    q = p0, p0 = p1, p1 = q;	/* undo the swap that will happen below */
                pt0 = frptofchar(f, p0);
                pt1 = frptofchar(f, p1);
                reg = region(p1, p0);
            }
        }
        q = frcharofpt(f, mp);
        if(p1 != q){
            if(reg != region(q, p0)){	/* crossed starting point; reset */
                if(reg > 0)
                    frdrawsel(f, pt0, p0, p1, 0);
                else if(reg < 0)
                    frdrawsel(f, pt1, p1, p0, 0);
                p1 = p0;
                pt1 = pt0;
                reg = region(q, p0);
                if(reg == 0)
                    frdrawsel(f, pt0, p0, p1, 1);
            }
            qt = frptofchar(f, q);
            if(reg > 0){
                if(q > p1)
                    frdrawsel(f, pt1, p1, q, 1);
                else if(q < p1)
                    frdrawsel(f, qt, q, p1, 0);
            }else if(reg < 0){
                if(q > p1)
                    frdrawsel(f, pt1, p1, q, 0);
                else
                    frdrawsel(f, qt, q, p1, 1);
            }
            p1 = q;
            pt1 = qt;
        }
        f->modified = 0;
        if(p0 < p1) {
            f->p0 = p0;
            f->p1 = p1;
        }
        else {
            f->p0 = p1;
            f->p1 = p0;
        }
        if(scrled)
            (*f->scroll)(f, 0);
        flushimage(f->display, 1);
        if(!scrled)
            readmouse(mc);
        mp = mc->xy;
    }while(mc->buttons == b);
}
@

<<function frselectpaint>>=
void
frselectpaint(Frame *f, Point p0, Point p1, Image *col)
{
    int n;
    Point q0, q1;

    q0 = p0;
    q1 = p1;
    q0.y += f->font->height;
    q1.y += f->font->height;
    n = (p1.y-p0.y)/f->font->height;
    if(f->b == nil)
        drawerror(f->display, "frselectpaint b==0");
    if(p0.y == f->r.max.y)
        return;
    if(n == 0)
        draw(f->b, Rpt(p0, q1), col, nil, ZP);
    else{
        if(p0.x >= f->r.max.x)
            p0.x = f->r.max.x-1;
        draw(f->b, Rect(p0.x, p0.y, f->r.max.x, q0.y), col, nil, ZP);
        if(n > 1)
            draw(f->b, Rect(f->r.min.x, q0.y, f->r.max.x, p1.y),
                col, nil, ZP);
        draw(f->b, Rect(f->r.min.x, p1.y, q1.x, q1.y),
            col, nil, ZP);
    }
}
@


%-------------------------------------------------------------

<<windows/libframe/frselect.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <mouse.h>
#include <frame.h>

<<function region>>

<<function frselect>>

<<function frselectpaint>>
@


\subsection*{[[windows/libframe/frstr.c]]}

<<constant CHUNK (windows/libframe/frstr.c)>>=
#define	CHUNK	16
@

<<function ROUNDUP>>=
#define	ROUNDUP(n)	((n+CHUNK)&~(CHUNK-1))
@

<<function _frallocstr>>=
uchar *
_frallocstr(Frame *f, unsigned n)
{
    uchar *p;

    p = malloc(ROUNDUP(n));
    if(p == 0)
        drawerror(f->display, "out of memory");
    return p;
}
@

<<function _frinsure>>=
void
_frinsure(Frame *f, int bn, unsigned n)
{
    Frbox *b;
    uchar *p;

    b = &f->box[bn];
    if(b->nrune < 0)
        drawerror(f->display, "_frinsure");
    if(ROUNDUP(b->nrune) > n)	/* > guarantees room for terminal NUL */
        return;
    p = _frallocstr(f, n);
    b = &f->box[bn];
    memmove(p, b->ptr, NBYTE(b)+1);
    free(b->ptr);
    b->ptr = p;
}
@


%-------------------------------------------------------------

<<windows/libframe/frstr.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <mouse.h>
#include <frame.h>

<<constant CHUNK (windows/libframe/frstr.c)>>
<<function ROUNDUP>>

<<function _frallocstr>>

<<function _frinsure>>
@


\subsection*{[[windows/libframe/frutil.c]]}

<<function _frcanfit>>=
int
_frcanfit(Frame *f, Point pt, Frbox *b)
{
    int left, w, nr;
    uchar *p;
    Rune r;

    left = f->r.max.x-pt.x;
    if(b->nrune < 0)
        return b->minwid <= left;
    if(left >= b->wid)
        return b->nrune;
    for(nr=0,p=b->ptr; *p; p+=w,nr++){
        r = *p;
        if(r < Runeself)
            w = 1;
        else
            w = chartorune(&r, (char*)p);
        left -= stringnwidth(f->font, (char*)p, 1);
        if(left < 0)
            return nr;
    }
    drawerror(f->display, "_frcanfit can't");
    return 0;
}
@

<<function _frcklinewrap>>=
void
_frcklinewrap(Frame *f, Point *p, Frbox *b)
{
    if((b->nrune<0? b->minwid : b->wid) > f->r.max.x-p->x){
        p->x = f->r.min.x;
        p->y += f->font->height;
    }
}
@

<<function _frcklinewrap0>>=
void
_frcklinewrap0(Frame *f, Point *p, Frbox *b)
{
    if(_frcanfit(f, *p, b) == 0){
        p->x = f->r.min.x;
        p->y += f->font->height;
    }
}
@

<<function _fradvance>>=
void
_fradvance(Frame *f, Point *p, Frbox *b)
{
    if(b->nrune<0 && b->bc=='\n'){
        p->x = f->r.min.x;
        p->y += f->font->height;
    }else
        p->x += b->wid;
}
@

<<function _frnewwid>>=
int
_frnewwid(Frame *f, Point pt, Frbox *b)
{
    b->wid = _frnewwid0(f, pt, b);
    return b->wid;
}
@

<<function _frnewwid0>>=
int
_frnewwid0(Frame *f, Point pt, Frbox *b)
{
    int c, x;

    c = f->r.max.x;
    x = pt.x;
    if(b->nrune>=0 || b->bc!='\t')
        return b->wid;
    if(x+b->minwid > c)
        x = pt.x = f->r.min.x;
    x += f->maxtab;
    x -= (x-f->r.min.x)%f->maxtab;
    if(x-pt.x<b->minwid || x>c)
        x = pt.x+b->minwid;
    return x-pt.x;
}
@

<<function _frclean>>=
void
_frclean(Frame *f, Point pt, int n0, int n1)	/* look for mergeable boxes */
{
    Frbox *b;
    int nb, c;

    c = f->r.max.x;
    for(nb=n0; nb<n1-1; nb++){
        b = &f->box[nb];
        _frcklinewrap(f, &pt, b);
        while(b[0].nrune>=0 && nb<n1-1 && b[1].nrune>=0 && pt.x+b[0].wid+b[1].wid<c){
            _frmergebox(f, nb);
            n1--;
            b = &f->box[nb];
        }
        _fradvance(f, &pt, &f->box[nb]);
    }
    for(; nb<f->nbox; nb++){
        b = &f->box[nb];
        _frcklinewrap(f, &pt, b);
        _fradvance(f, &pt, &f->box[nb]);
    }
    f->lastlinefull = 0;
    if(pt.y >= f->r.max.y)
        f->lastlinefull = 1;
}
@


%-------------------------------------------------------------

<<windows/libframe/frutil.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <mouse.h>
#include <frame.h>

<<function _frcanfit>>

<<function _frcklinewrap>>

<<function _frcklinewrap0>>

<<function _fradvance>>

<<function _frnewwid>>

<<function _frnewwid0>>

<<function _frclean>>
@


\section{[[windows/libpanel/]]}

\subsection*{[[windows/libpanel/button.c]]}

<<struct Button>>=
struct Button{
    int btype;			/* button type */
    Icon *icon;			/* what to write on the button */
    int check;			/* for check/radio buttons */
    void (*hit)(Panel *, int, int);	/* call back user code on check/radio hit */
    void (*menuhit)(int, int);	/* call back user code on menu item hit */
    void (*pl_buttonhit)(Panel *, int);	/* call back user code on button hit */
    int index;			/* arg to menuhit */
    int buttons;
};
@

<<constant BUTTON>>=
/*
 * Button types
 */
#define	BUTTON	1
@

<<constant CHECK>>=
#define	CHECK	2
@

<<constant RADIO>>=
#define	RADIO	3
@

<<function pl_drawbutton>>=
void pl_drawbutton(Panel *p){
    Rectangle r;
    Button *bp;
    bp=p->data;
    r=pl_box(p->b, p->r, p->state);
    switch(bp->btype){
    case CHECK:
        r=pl_check(p->b, r, bp->check);
        break;
    case RADIO:
        r=pl_radio(p->b, r, bp->check);
        break;
    }
    pl_drawicon(p->b, r, PLACECEN, p->flags, bp->icon);
}
@

<<function pl_hitbutton>>=
int pl_hitbutton(Panel *p, Mouse *m){
    int oldstate, hitme;
    Panel *sib;
    Button *bp;
    bp=p->data;
    oldstate=p->state;
    if(m->buttons&OUT){
        hitme=0;
        p->state=UP;
    }
    else if(m->buttons&7){
        hitme=0;
        p->state=DOWN;
        bp->buttons=m->buttons;
    }
    else{	/* mouse inside, but no buttons down */
        hitme=p->state==DOWN;
        p->state=UP;
    }
    if(hitme) switch(bp->btype){
    case CHECK:
        if(hitme) bp->check=!bp->check;
        break;
    case RADIO:
        if(bp->check) bp->check=0;
        else{
            if(p->parent){
                for(sib=p->parent->child;sib;sib=sib->next){
                    if(sib->hit==pl_hitbutton
                    && ((Button *)sib->data)->btype==RADIO
                    && ((Button *)sib->data)->check){
                        ((Button *)sib->data)->check=0;
                        pldraw(sib, p->b);
                    }
                }
            }
            bp->check=1;
        }
        break;
    }
    if(hitme || oldstate!=p->state) pldraw(p, p->b);
    if(hitme && bp->hit){
        bp->hit(p, bp->buttons, bp->check);
        p->state=UP;
    }
    return 0;
}
@

<<function pl_typebutton>>=
void pl_typebutton(Panel *g, Rune c){
    USED(g, c);
}
@

<<function pl_getsizebutton>>=
Point pl_getsizebutton(Panel *p, Point children){
    Point s;
    int ckw;
    Button *bp;
    USED(children);		/* shouldn't have any children */
    bp=p->data;
    s=pl_iconsize(p->flags, bp->icon);
    if(bp->btype!=BUTTON){
        ckw=pl_ckwid();
        if(s.y<ckw){
            s.x+=ckw;
            s.y=ckw;
        }
        else s.x+=s.y;
    }
    return pl_boxsize(s, p->state);
}
@

<<function pl_childspacebutton>>=
void pl_childspacebutton(Panel *g, Point *ul, Point *size){
    USED(g, ul, size);
}
@

<<function pl_initbtype>>=
void pl_initbtype(Panel *v, int flags, Icon *icon, void (*hit)(Panel *, int, int), int btype){
    Button *bp;
    bp=v->data;
    v->flags=flags|LEAF;
    v->state=UP;
    v->draw=pl_drawbutton;
    v->hit=pl_hitbutton;
    v->type=pl_typebutton;
    v->getsize=pl_getsizebutton;
    v->childspace=pl_childspacebutton;
    bp->btype=btype;
    bp->check=0;
    bp->hit=hit;
    bp->icon=icon;
    switch(btype){
    case BUTTON: v->kind="button"; break;
    case CHECK:  v->kind="checkbutton"; break;
    case RADIO:  v->kind="radiobutton"; break;
    }
}
@

<<function pl_buttonhit>>=
void pl_buttonhit(Panel *p, int buttons, int check){
    USED(check);
    if(((Button *)p->data)->pl_buttonhit) ((Button *)p->data)->pl_buttonhit(p, buttons);
}
@

<<function plinitbutton>>=
void plinitbutton(Panel *p, int flags, Icon *icon, void (*hit)(Panel *, int)){
    ((Button *)p->data)->pl_buttonhit=hit;
    pl_initbtype(p, flags, icon, pl_buttonhit, BUTTON);
}
@

<<function plinitcheckbutton>>=
void plinitcheckbutton(Panel *p, int flags, Icon *icon, void (*hit)(Panel *, int, int)){
    pl_initbtype(p, flags, icon, hit, CHECK);
}
@

<<function plinitradiobutton>>=
void plinitradiobutton(Panel *p, int flags, Icon *icon, void (*hit)(Panel *, int, int)){
    pl_initbtype(p, flags, icon, hit, RADIO);
}
@

<<function plbutton>>=
Panel *plbutton(Panel *parent, int flags, Icon *icon, void (*hit)(Panel *, int)){
    Panel *p;
    p=pl_newpanel(parent, sizeof(Button));
    plinitbutton(p, flags, icon, hit);
    return p;
}
@

<<function plcheckbutton>>=
Panel *plcheckbutton(Panel *parent, int flags, Icon *icon, void (*hit)(Panel *, int, int)){
    Panel *p;
    p=pl_newpanel(parent, sizeof(Button));
    plinitcheckbutton(p, flags, icon, hit);
    return p;
}
@

<<function plradiobutton>>=
Panel *plradiobutton(Panel *parent, int flags, Icon *icon, void (*hit)(Panel *, int, int)){
    Panel *p;
    p=pl_newpanel(parent, sizeof(Button));
    plinitradiobutton(p, flags, icon, hit);
    return p;
}
@

<<function pl_hitmenu>>=
void pl_hitmenu(Panel *p, int buttons){
    void (*hit)(int, int);
    hit=((Button *)p->data)->menuhit;
    if(hit) hit(buttons, ((Button *)p->data)->index);
}
@

<<function plinitmenu>>=
void plinitmenu(Panel *v, int flags, Icon **item, int cflags, void (*hit)(int, int)){
    Panel *b;
    int i;
    v->flags=flags;
    v->kind="menu";
    if(v->child){
        plfree(v->child);
        v->child=0;
    }
    for(i=0;item[i];i++){
        b=plbutton(v, cflags, item[i], pl_hitmenu);
        ((Button *)b->data)->menuhit=hit;
        ((Button *)b->data)->index=i;
    }
}
@

<<function plmenu>>=
Panel *plmenu(Panel *parent, int flags, Icon **item, int cflags, void (*hit)(int, int)){
    Panel *v;
    v=plgroup(parent, flags);
    plinitmenu(v, flags, item, cflags, hit);
    return v;
}
@

<<function plsetbutton>>=
void plsetbutton(Panel *p, int val){
    ((Button *)p->data)->check=val;
}
@


%-------------------------------------------------------------

<<windows/libpanel/button.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <event.h>
#include <panel.h>
#include "pldefs.h"
typedef struct Button Button;
<<struct Button>>
<<constant BUTTON>>
<<constant CHECK>>
<<constant RADIO>>
<<function pl_drawbutton>>
<<function pl_hitbutton>>
<<function pl_typebutton>>
<<function pl_getsizebutton>>
<<function pl_childspacebutton>>
<<function pl_initbtype>>
<<function pl_buttonhit>>
<<function plinitbutton>>
<<function plinitcheckbutton>>
<<function plinitradiobutton>>
<<function plbutton>>
<<function plcheckbutton>>
<<function plradiobutton>>
<<function pl_hitmenu>>
<<function plinitmenu>>
<<function plmenu>>
<<function plsetbutton>>
@


\subsection*{[[windows/libpanel/canvas.c]]}

<<struct Canvas>>=
struct Canvas{
    void (*draw)(Panel *);
    void (*hit)(Panel *, Mouse *);
};
@

<<function pl_drawcanvas>>=
void pl_drawcanvas(Panel *p){
    Canvas *c;
    c=p->data;
    if(c->draw) c->draw(p);
}
@

<<function pl_hitcanvas>>=
int pl_hitcanvas(Panel *p, Mouse *m){
    Canvas *c;
    c=p->data;
    if(c->hit) c->hit(p, m);
    return 0;
}
@

<<function pl_typecanvas>>=
void pl_typecanvas(Panel *p, Rune c){
    USED(p, c);
}
@

<<function pl_getsizecanvas>>=
Point pl_getsizecanvas(Panel *p, Point children){
    USED(p, children);
    return Pt(0,0);
}
@

<<function pl_childspacecanvas>>=
void pl_childspacecanvas(Panel *p, Point *ul, Point *size){
    USED(p, ul, size);
}
@

<<function plinitcanvas>>=
void plinitcanvas(Panel *v, int flags, void (*draw)(Panel *), void (*hit)(Panel *, Mouse *)){
    Canvas *c;
    v->flags=flags|LEAF;
    v->draw=pl_drawcanvas;
    v->hit=pl_hitcanvas;
    v->type=pl_typecanvas;
    v->getsize=pl_getsizecanvas;
    v->childspace=pl_childspacecanvas;
    v->kind="canvas";
    c=v->data;
    c->draw=draw;
    c->hit=hit;
}
@

<<function plcanvas>>=
Panel *plcanvas(Panel *parent, int flags, void (*draw)(Panel *), void (*hit)(Panel *, Mouse *)){
    Panel *p;
    p=pl_newpanel(parent, sizeof(Canvas));
    plinitcanvas(p, flags, draw, hit);
    return p;
}
@


%-------------------------------------------------------------

<<windows/libpanel/canvas.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <event.h>
#include <panel.h>
#include "pldefs.h"
typedef struct Canvas Canvas;
<<struct Canvas>>
<<function pl_drawcanvas>>
<<function pl_hitcanvas>>
<<function pl_typecanvas>>
<<function pl_getsizecanvas>>
<<function pl_childspacecanvas>>
<<function plinitcanvas>>
<<function plcanvas>>
@


\subsection*{[[windows/libpanel/draw.c]]}

<<constant PWID>>=
#define	PWID	1	/* width of label border */
@

<<constant BWID>>=
#define	BWID	1	/* width of button relief */
@

<<constant FWID>>=
#define	FWID	2	/* width of frame relief */
@

<<constant SPACE>>=
#define	SPACE	1	/* space inside relief of button or frame */
@

<<constant CKSIZE>>=
#define	CKSIZE	3	/* size of check mark */
@

<<constant CKSPACE>>=
#define	CKSPACE	2	/* space around check mark */
@

<<constant CKWID>>=
#define	CKWID	1	/* width of frame around check mark */
@

<<constant CKINSET>>=
#define	CKINSET	1	/* space around check mark frame */
@

<<constant CKBORDER>>=
#define	CKBORDER 2	/* space around X inside frame */
@

<<global plldepth>>=
static int plldepth;
@

<<function pl_drawinit>>=
int pl_drawinit(int ldepth){
    plldepth=ldepth;
    pl_white=allocimage(display, Rect(0,0,1,1), screen->chan, 1, 0xFFFFFFFF);
    pl_light=allocimagemix(display, DPalebluegreen, DWhite);
    pl_dark =allocimage(display, Rect(0,0,1,1), screen->chan, 1, DPurpleblue);
    pl_black=allocimage(display, Rect(0,0,1,1), screen->chan, 1, 0x000000FF);
    pl_hilit=allocimage(display, Rect(0,0,1,1), CHAN1(CAlpha,8), 1, 0x80);
    if(pl_white==0 || pl_light==0 || pl_black==0 || pl_dark==0) return 0;
    return 1;
}
@

<<function pl_relief>>=
void pl_relief(Image *b, Image *ul, Image *lr, Rectangle r, int wid){
    int x, y;
    draw(b, Rect(r.min.x, r.max.y-wid, r.max.x, r.max.y), lr, 0, ZP); /* bottom */
    draw(b, Rect(r.max.x-wid, r.min.y, r.max.x, r.max.y), lr, 0, ZP); /* right */
    draw(b, Rect(r.min.x, r.min.y, r.min.x+wid, r.max.y), ul, 0, ZP); /* left */
    draw(b, Rect(r.min.x, r.min.y, r.max.x, r.min.y+wid), ul, 0, ZP); /* top */
    for(x=0;x!=wid;x++) for(y=wid-1-x;y!=wid;y++){
        draw(b, rectaddpt(Rect(0,0,1,1), Pt(x+r.max.x-wid, y+r.min.y)), lr, 0, ZP);
        draw(b, rectaddpt(Rect(0,0,1,1), Pt(x+r.min.x, y+r.max.y-wid)), lr, 0, ZP);
    }
}
@

<<function pl_boxoutline>>=
Rectangle pl_boxoutline(Image *b, Rectangle r, int style, int fill){
    if(plldepth==0) switch(style){
    case UP:
        pl_relief(b, pl_black, pl_black, r, BWID);
        r=insetrect(r, BWID);
        if(fill) draw(b, r, pl_white, 0, ZP);
        else border(b, r, SPACE, pl_white, ZP);
        break;
    case DOWN:
    case DOWN1:
    case DOWN2:
    case DOWN3:
        pl_relief(b, pl_black, pl_black, r, BWID);
        r=insetrect(r, BWID);
        if(fill) draw(b, r, pl_black, 0, ZP);
        border(b, r, SPACE, pl_black, ZP);
        break;
    case PASSIVE:
        if(fill) draw(b, r, pl_white, 0, ZP);
        r=insetrect(r, PWID);
        if(!fill) border(b, r, SPACE, pl_white, ZP);
        break;
    case FRAME:
        pl_relief(b, pl_white, pl_black, r, FWID);
        r=insetrect(r, FWID);
        pl_relief(b, pl_black, pl_white, r, FWID);
        r=insetrect(r, FWID);
        if(fill) draw(b, r, pl_white, 0, ZP);
        else border(b, r, SPACE, pl_white, ZP);
        break;
    }
    else switch(style){
    case UP:
        pl_relief(b, pl_white, pl_black, r, BWID);
        r=insetrect(r, BWID);
        if(fill) draw(b, r, pl_light, 0, ZP);
        else border(b, r, SPACE, pl_white, ZP);
        break;
    case DOWN:
    case DOWN1:
    case DOWN2:
    case DOWN3:
        pl_relief(b, pl_black, pl_white, r, BWID);
        r=insetrect(r, BWID);
        if(fill) draw(b, r, pl_dark, 0, ZP);
        else border(b, r, SPACE, pl_black, ZP);
        break;
    case PASSIVE:
        if(fill) draw(b, r, pl_light, 0, ZP);
        r=insetrect(r, PWID);
        if(!fill) border(b, r, SPACE, pl_white, ZP);
        break;
    case FRAME:
        pl_relief(b, pl_white, pl_black, r, FWID);
        r=insetrect(r, FWID);
        pl_relief(b, pl_black, pl_white, r, FWID);
        r=insetrect(r, FWID);
        if(fill) draw(b, r, pl_light, 0, ZP);
        else border(b, r, SPACE, pl_white, ZP);
        break;
    }
    return insetrect(r, SPACE);
}
@

<<function pl_outline>>=
Rectangle pl_outline(Image *b, Rectangle r, int style){
    return pl_boxoutline(b, r, style, 0);
}
@

<<function pl_box>>=
Rectangle pl_box(Image *b, Rectangle r, int style){
    return pl_boxoutline(b, r, style, 1);
}
@

<<function pl_boxsize>>=
Point pl_boxsize(Point interior, int state){
    switch(state){
    case UP:
    case DOWN:
    case DOWN1:
    case DOWN2:
    case DOWN3:
        return addpt(interior, Pt(2*(BWID+SPACE), 2*(BWID+SPACE)));
    case PASSIVE:
        return addpt(interior, Pt(2*(PWID+SPACE), 2*(PWID+SPACE)));
    case FRAME:
        return addpt(interior, Pt(4*FWID+2*SPACE, 4*FWID+2*SPACE));
    }
    return Pt(0, 0);
}
@

<<function pl_interior>>=
void pl_interior(int state, Point *ul, Point *size){
    switch(state){
    case UP:
    case DOWN:
    case DOWN1:
    case DOWN2:
    case DOWN3:
        *ul=addpt(*ul, Pt(BWID+SPACE, BWID+SPACE));
        *size=subpt(*size, Pt(2*(BWID+SPACE), 2*(BWID+SPACE)));
        break;
    case PASSIVE:
        *ul=addpt(*ul, Pt(PWID+SPACE, PWID+SPACE));
        *size=subpt(*size, Pt(2*(PWID+SPACE), 2*(PWID+SPACE)));
        break;
    case FRAME:
        *ul=addpt(*ul, Pt(2*FWID+SPACE, 2*FWID+SPACE));
        *size=subpt(*size, Pt(4*FWID+2*SPACE, 4*FWID+2*SPACE));
    }
}
@

<<function pl_drawicon>>=
void pl_drawicon(Image *b, Rectangle r, int stick, int flags, Icon *s){
    Rectangle save;
    Point ul, offs;
    ul=r.min;
    offs=subpt(subpt(r.max, r.min), pl_iconsize(flags, s));
    switch(stick){
    case PLACENW:	                                break;
    case PLACEN:	ul.x+=offs.x/2;                 break;
    case PLACENE:	ul.x+=offs.x;                   break;
    case PLACEW:	                ul.y+=offs.y/2; break;
    case PLACECEN:	ul.x+=offs.x/2; ul.y+=offs.y/2; break;
    case PLACEE:	ul.x+=offs.x;                   break;
    case PLACESW:	                ul.y+=offs.y;   break;
    case PLACES:	ul.x+=offs.x/2; ul.y+=offs.y;   break;
    case PLACESE:	ul.x+=offs.x;   ul.y+=offs.y;   break;
    }
    save=b->clipr;
    if(!rectclip(&r, save))
        return;
    replclipr(b, b->repl, r);
    if(flags&BITMAP) draw(b, Rpt(ul, addpt(ul, pl_iconsize(flags, s))), s, 0, ZP);
    else string(b, ul, pl_black, ZP, font, s);
    replclipr(b, b->repl, save);
}
@

<<function pl_radio>>=
/*
 * Place a check mark at the left end of r.  Return the unused space.
 * Caller must guarantee that r.max.x-r.min.x>=r.max.y-r.min.y!
 */
Rectangle pl_radio(Image *b, Rectangle r, int val){
    Rectangle remainder;
    remainder=r;
    r.max.x=r.min.x+r.max.y-r.min.y;
    remainder.min.x=r.max.x;
    r=insetrect(r, CKINSET);
    if(plldepth==0)
        pl_relief(b, pl_black, pl_black, r, CKWID);
    else
        pl_relief(b, pl_black, pl_white, r, CKWID);
    r=insetrect(r, CKWID);
    if(plldepth==0)
        draw(b, r, pl_white, 0, ZP);
    else
        draw(b, r, pl_light, 0, ZP);
    if(val) draw(b, insetrect(r, CKSPACE), pl_black, 0, ZP);
    return remainder;
}
@

<<function pl_check>>=
Rectangle pl_check(Image *b, Rectangle r, int val){
    Rectangle remainder;
    remainder=r;
    r.max.x=r.min.x+r.max.y-r.min.y;
    remainder.min.x=r.max.x;
    r=insetrect(r, CKINSET);
    if(plldepth==0)
        pl_relief(b, pl_black, pl_black, r, CKWID);
    else
        pl_relief(b, pl_black, pl_white, r, CKWID);
    r=insetrect(r, CKWID);
    if(plldepth==0)
        draw(b, r, pl_white, 0, ZP);
    else
        draw(b, r, pl_light, 0, ZP);
    r=insetrect(r, CKBORDER);
    if(val){
        line(b, Pt(r.min.x,   r.min.y+1), Pt(r.max.x-1, r.max.y  ), Endsquare, Endsquare, 0, pl_black, ZP);
        line(b, Pt(r.min.x,   r.min.y  ), Pt(r.max.x,   r.max.y  ), Endsquare, Endsquare, 0, pl_black, ZP);
        line(b, Pt(r.min.x+1, r.min.y  ), Pt(r.max.x,   r.max.y-1), Endsquare, Endsquare, 0, pl_black, ZP);
        line(b, Pt(r.min.x  , r.max.y-2), Pt(r.max.x-1, r.min.y-1), Endsquare, Endsquare, 0, pl_black, ZP);
        line(b, Pt(r.min.x,   r.max.y-1), Pt(r.max.x,   r.min.y-1), Endsquare, Endsquare, 0, pl_black, ZP);
        line(b, Pt(r.min.x+1, r.max.y-1), Pt(r.max.x,   r.min.y  ), Endsquare, Endsquare, 0, pl_black, ZP);
    }
    return remainder;
}
@

<<function pl_ckwid>>=
int pl_ckwid(void){
    return 2*(CKINSET+CKSPACE+CKWID)+CKSIZE;
}
@

<<function pl_sliderupd>>=
void pl_sliderupd(Image *b, Rectangle r1, int dir, int lo, int hi){
    Rectangle r2, r3;
    r2=r1;
    r3=r1;
    if(lo<0) lo=0;
    if(hi<=lo) hi=lo+1;
    switch(dir){
    case HORIZ:
        r1.max.x=r1.min.x+lo;
        r2.min.x=r1.max.x;
        r2.max.x=r1.min.x+hi;
        if(r2.max.x>r3.max.x) r2.max.x=r3.max.x;
        r3.min.x=r2.max.x;
        break;
    case VERT:
        r1.max.y=r1.min.y+lo;
        r2.min.y=r1.max.y;
        r2.max.y=r1.min.y+hi;
        if(r2.max.y>r3.max.y) r2.max.y=r3.max.y;
        r3.min.y=r2.max.y;
        break;
    }
    draw(b, r1, pl_light, 0, ZP);
    draw(b, r2, pl_dark, 0, ZP);
    draw(b, r3, pl_light, 0, ZP);
}
@

<<function pl_drawall>>=
void pl_drawall(Panel *p, Image *b){
    if(p->flags&INVIS) return;
    p->b=b;
    p->draw(p);
    for(p=p->child;p;p=p->next) pl_draw1(p, b);
}
@

<<function pl_draw1>>=
void pl_draw1(Panel *p, Image *b){
    if(b!=0)
        pl_drawall(p, b);
}
@

<<function pldraw>>=
void pldraw(Panel *p, Image *b){
    pl_draw1(p, b);
    flushimage(display, 1);
}
@

<<function pl_invis>>=
void pl_invis(Panel *p, int v){
    for(;p;p=p->next){
        if(v) p->flags|=INVIS; else p->flags&=~INVIS;
        pl_invis(p->child, v);
    }
}
@

<<function pl_iconsize>>=
Point pl_iconsize(int flags, Icon *p){
    if(flags&BITMAP) return subpt(((Image *)p)->r.max, ((Image *)p)->r.min);
    return stringsize(font, (char *)p);
}
@

<<function pl_highlight>>=
void pl_highlight(Image *b, Rectangle r){
    draw(b, r, pl_dark, pl_hilit, ZP);
}
@

<<function pl_clr>>=
void pl_clr(Image *b, Rectangle r){
    draw(b, r, display->white, 0, ZP);
}
@

<<function pl_fill>>=
void pl_fill(Image *b, Rectangle r){
    draw(b, r, plldepth==0? pl_white : pl_light, 0, ZP);
}
@

<<function pl_cpy>>=
void pl_cpy(Image *b, Point dst, Rectangle src){
    draw(b, Rpt(dst, addpt(dst, subpt(src.max, src.min))), b, 0, src.min);
}
@


%-------------------------------------------------------------

<<windows/libpanel/draw.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <event.h>
#include <panel.h>
#include "pldefs.h"
<<constant PWID>>
<<constant BWID>>
<<constant FWID>>
<<constant SPACE>>
<<constant CKSIZE>>
<<constant CKSPACE>>
<<constant CKWID>>
<<constant CKINSET>>
<<constant CKBORDER>>
<<global plldepth>>
static Image *pl_white, *pl_light, *pl_dark, *pl_black, *pl_hilit;
<<function pl_drawinit>>
<<function pl_relief>>
<<function pl_boxoutline>>
<<function pl_outline>>
<<function pl_box>>
<<function pl_boxsize>>
<<function pl_interior>>

<<function pl_drawicon>>
<<function pl_radio>>
<<function pl_check>>
<<function pl_ckwid>>
<<function pl_sliderupd>>
void pl_draw1(Panel *p, Image *b);
<<function pl_drawall>>
<<function pl_draw1>>
<<function pldraw>>
<<function pl_invis>>
<<function pl_iconsize>>
<<function pl_highlight>>
<<function pl_clr>>
<<function pl_fill>>
<<function pl_cpy>>
@


\subsection*{[[windows/libpanel/edit.c]]}

<<struct Edit>>=
struct Edit{
    Point minsize;
    void (*hit)(Panel *);
    int sel0, sel1;
    Textwin *t;
    Rune *text;
    int ntext;
};
@

<<function pl_drawedit>>=
void pl_drawedit(Panel *p){
    Edit *ep;
    Panel *sb;
    ep=p->data;
    if(ep->t==0){
        ep->t=twnew(p->b, font, ep->text, ep->ntext);
        if(ep->t==0){
            fprint(2, "pl_drawedit: can't allocate\n");
            exits("no mem");
        }
    }
    ep->t->b=p->b;
    twreshape(ep->t, p->r);
    twhilite(ep->t, ep->sel0, ep->sel1, 1);
    sb=p->yscroller;
    if(sb && sb->setscrollbar)
        sb->setscrollbar(sb, ep->t->top, ep->t->bot, ep->t->etext-ep->t->text);
}
@

<<function pl_snarfedit>>=
char *pl_snarfedit(Panel *p){
    int s0, s1;
    Rune *t;
    t=pleget(p);
    plegetsel(p, &s0, &s1);
    if(t==0 || s0>=s1)
        return nil;
    return smprint("%.*S", s1-s0, t+s0);
}
@

<<function pl_pasteedit>>=
void pl_pasteedit(Panel *p, char *s){
    Rune *t;
    if(t=runesmprint("%s", s)){
        plepaste(p, t, runestrlen(t));
        free(t);
    }
}
@

<<function pl_hitedit>>=
/*
 * Should do double-clicks:
 *	If ep->sel0==ep->sel1 on entry and the
 *	call to twselect returns the same selection, then
 *	expand selections (| marks possible selection points, ... is expanded selection)
 *	<|...|>			<> must nest
 *	(|...|)			() must nest
 *	[|...|]			[] must nest
 *	{|...|}			{} must nest
 *	'|...|'			no ' in ...
 *	"|...|"			no " in ...
 *	\n|...|\n		either newline may be the corresponding end of text
 *				include the trailing newline in the selection
 *	...|I...		I and ... are characters satisfying pl_idchar(I)
 *	...I|
 */
int pl_hitedit(Panel *p, Mouse *m){
    Edit *ep;
    ep=p->data;
    if(ep->t && m->buttons&1){
        plgrabkb(p);
        ep->t->b=p->b;
        twhilite(ep->t, ep->sel0, ep->sel1, 0);
        twselect(ep->t, m);
        ep->sel0=ep->t->sel0;
        ep->sel1=ep->t->sel1;
        if((m->buttons&7)==3){
            plsnarf(p);
            plepaste(p, 0, 0);	/* cut */
        }
        else if((m->buttons&7)==5)
            plpaste(p);
        else if(ep->hit)
            (*ep->hit)(p);
    }
    return 0;
}
@

<<function pl_scrolledit>>=
void pl_scrolledit(Panel *p, int dir, int buttons, int num, int den){
    Edit *ep;
    Textwin *t;
    Panel *sb;
    int index, nline;
    if(dir!=VERT) return;
    ep=p->data;
    t=ep->t;
    if(t==0) return;
    t->b=p->b;
    switch(buttons){
    default:
        return;
    case 1:		/* top line moves to mouse position */
        nline=(t->r.max.y-t->r.min.y)/t->hgt*num/den;
        index=t->top;
        while(index!=0 && nline!=0)
            if(t->text[--index]=='\n') --nline;
        break;
    case 2:		/* absolute */
        index=(t->etext-t->text)*num/den;
        break;
    case 4:		/* mouse points at new top line */
        index=twpt2rune(t,
            Pt(t->r.min.x, t->r.min.y+(t->r.max.y-t->r.min.y)*num/den));
        break;
    }
    while(index!=0 && t->text[index-1]!='\n') --index;
    if(index!=t->top){
        twhilite(ep->t, ep->sel0, ep->sel1, 0);
        twscroll(t, index);
        p->scr.pos.y=t->top;
        twhilite(ep->t, ep->sel0, ep->sel1, 1);
        sb=p->yscroller;
        if(sb && sb->setscrollbar)
            sb->setscrollbar(sb, t->top, t->bot, t->etext-t->text);
    }
}
@

<<function pl_typeedit>>=
void pl_typeedit(Panel *p, Rune c){
    Edit *ep;
    Textwin *t;
    int bot, scrolled;
    Panel *sb;
    ep=p->data;
    t=ep->t;
    if(t==0) return;
    t->b=p->b;
    twhilite(t, ep->sel0, ep->sel1, 0);
    switch(c){
    case Kesc:
        plsnarf(p);
        plepaste(p, 0, 0);	/* cut */
        break;
    case Kdel:	/* clear */
        ep->sel0=0;
        ep->sel1=plelen(p);
        plepaste(p, 0, 0);	/* cut */
        break;
    case Kbs:	/* ^H: erase character */
        if(ep->sel0!=0) --ep->sel0;
        twreplace(t, ep->sel0, ep->sel1, 0, 0);
        break;
//	case Knack:	/* ^U: erase line */
//		while(ep->sel0!=0 && t->text[ep->sel0-1]!='\n') --ep->sel0;
//		twreplace(t, ep->sel0, ep->sel1, 0, 0);
//		break;
//	case Ketb:	/* ^W: erase word */
//		while(ep->sel0!=0 && !pl_idchar(t->text[ep->sel0-1])) --ep->sel0;
//		while(ep->sel0!=0 && pl_idchar(t->text[ep->sel0-1])) --ep->sel0;
//		twreplace(t, ep->sel0, ep->sel1, 0, 0);
//		break;
    default:
        if((c & 0xFF00) == KF || (c & 0xFF00) == Spec)
            break;
        twreplace(t, ep->sel0, ep->sel1, &c, 1);
        ++ep->sel0;
        break;
    }
    ep->sel1=ep->sel0;
    /*
     * Scroll up until ep->sel0 is above t->bot.
     */
    scrolled=0;
    do{
        bot=t->bot;
        if(ep->sel0<=bot) break;
        twscroll(t, twpt2rune(t, Pt(t->r.min.x, t->r.min.y+font->height)));
        scrolled++;
    }while(bot!=t->bot);
    if(scrolled){
        sb=p->yscroller;
        if(sb && sb->setscrollbar)
            sb->setscrollbar(sb, t->top, t->bot, t->etext-t->text);
    }
    twhilite(t, ep->sel0, ep->sel1, 1);
}
@

<<function pl_getsizeedit>>=
Point pl_getsizeedit(Panel *p, Point children){
    USED(children);
    return pl_boxsize(((Edit *)p->data)->minsize, p->state);
}
@

<<function pl_childspaceedit>>=
void pl_childspaceedit(Panel *g, Point *ul, Point *size){
    USED(g, ul, size);
}
@

<<function pl_freeedit>>=
void pl_freeedit(Panel *p){
    Edit *ep;
    ep=p->data;
    if(ep->t) twfree(ep->t);
    ep->t=0;
}
@

<<function plinitedit>>=
void plinitedit(Panel *v, int flags, Point minsize, Rune *text, int ntext, void (*hit)(Panel *)){
    Edit *ep;
    ep=v->data;
    v->flags=flags|LEAF;
    v->state=UP;
    v->draw=pl_drawedit;
    v->hit=pl_hitedit;
    v->type=pl_typeedit;
    v->getsize=pl_getsizeedit;
    v->childspace=pl_childspaceedit;
    v->free=pl_freeedit;
    v->snarf=pl_snarfedit;
    v->paste=pl_pasteedit;
    v->kind="edit";
    ep->hit=hit;
    ep->minsize=minsize;
    ep->text=text;
    ep->ntext=ntext;
    if(ep->t!=0) twfree(ep->t);
    ep->t=0;
    ep->sel0=-1;
    ep->sel1=-1;
    v->scroll=pl_scrolledit;
    v->scr.pos=Pt(0,0);
    v->scr.size=Pt(ntext,0);
}
@

<<function pledit>>=
Panel *pledit(Panel *parent, int flags, Point minsize, Rune *text, int ntext, void (*hit)(Panel *)){
    Panel *v;
    v=pl_newpanel(parent, sizeof(Edit));
    ((Edit *)v->data)->t=0;
    plinitedit(v, flags, minsize, text, ntext, hit);
    return v;
}
@

<<function plescroll>>=
void plescroll(Panel *p, int top){
    Textwin *t;
    t=((Edit*)p->data)->t;
    if(t) twscroll(t, top);
}
@

<<function plegetsel>>=
void plegetsel(Panel *p, int *sel0, int *sel1){
    Edit *ep;
    ep=p->data;
    *sel0=ep->sel0;
    *sel1=ep->sel1;
}
@

<<function plelen>>=
int plelen(Panel *p){
    Textwin *t;
    t=((Edit*)p->data)->t;
    if(t==0) return 0;
    return t->etext-t->text;
}
@

<<function pleget>>=
Rune *pleget(Panel *p){
    Textwin *t;
    t=((Edit*)p->data)->t;
    if(t==0) return 0;
    return t->text;
}
@

<<function plesel>>=
void plesel(Panel *p, int sel0, int sel1){
    Edit *ep;
    ep=p->data;
    if(ep->t==0) return;
    ep->t->b=p->b;
    twhilite(ep->t, ep->sel0, ep->sel1, 0);
    ep->sel0=sel0;
    ep->sel1=sel1;
    twhilite(ep->t, ep->sel0, ep->sel1, 1);
}
@

<<function plepaste>>=
void plepaste(Panel *p, Rune *text, int ntext){
    Edit *ep;
    ep=p->data;
    if(ep->t==0) return;
    ep->t->b=p->b;
    twhilite(ep->t, ep->sel0, ep->sel1, 0);
    twreplace(ep->t, ep->sel0, ep->sel1, text, ntext);
    ep->sel1=ep->sel0+ntext;
    twhilite(ep->t, ep->sel0, ep->sel1, 1);
    p->scr.size.y=ep->t->etext-ep->t->text;
    p->scr.pos.y=ep->t->top;
}
@

<<function plemove>>=
void plemove(Panel *p, Point d){
    Edit *ep;
    ep=p->data;
    if(ep->t && !eqpt(d, Pt(0,0))) twmove(ep->t, d);
}
@


%-------------------------------------------------------------

<<windows/libpanel/edit.c>>=
/*
 * Interface includes:
 *	void plescroll(Panel *p, int top);
 *		move the given character position onto the top line
 *	void plegetsel(Panel *p, int *sel0, int *sel1);
 *		read the selection back
 *	int plelen(Panel *p);
 *		read the length of the text back
 *	Rune *pleget(Panel *p);
 *		get a pointer to the text
 *	void plesel(Panel *p, int sel0, int sel1);
 *		set the selection -- adjusts hiliting
 *	void plepaste(Panel *p, Rune *text, int ntext);
 *		replace the selection with the given text
 */
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <event.h>
#include <panel.h>
#include "pldefs.h"
#include <keyboard.h>

typedef struct Edit Edit;
<<struct Edit>>
<<function pl_drawedit>>

<<function pl_snarfedit>>
<<function pl_pasteedit>>

<<function pl_hitedit>>
<<function pl_scrolledit>>
<<function pl_typeedit>>
<<function pl_getsizeedit>>
<<function pl_childspaceedit>>
<<function pl_freeedit>>
<<function plinitedit>>
<<function pledit>>
<<function plescroll>>
<<function plegetsel>>
<<function plelen>>
<<function pleget>>
<<function plesel>>
<<function plepaste>>
<<function plemove>>
@


\subsection*{[[windows/libpanel/entry.c]]}

<<struct Entry>>=
struct Entry{
    char *entry;
    char *entp;
    char *eent;
    void (*hit)(Panel *, char *);
    Point minsize;
};
@

<<constant SLACK>>=
#define	SLACK	7	/* enough for one extra rune and â—€ and a nul */
@

<<function pl_snarfentry>>=
char *pl_snarfentry(Panel *p){
    Entry *ep;
    int n;

    if(p->flags&USERFL)	/* no snarfing from password entry */
        return nil;
    ep=p->data;
    n=ep->entp-ep->entry;
    if(n<=0) return nil;
    return smprint("%.*s", n, ep->entry);
}
@

<<function pl_pasteentry>>=
void pl_pasteentry(Panel *p, char *s){
    Entry *ep;
    char *e;
    int n, m;

    ep=p->data;
    n=ep->entp-ep->entry;
    m=strlen(s);
    e=pl_erealloc(ep->entry,n+m+SLACK);
    ep->entry=e;
    e+=n;
    strncpy(e, s, m);
    e+=m;
    *e='\0';
    ep->entp=ep->eent=e;
    pldraw(p, p->b);
}
@

<<function pl_drawentry>>=
void pl_drawentry(Panel *p){
    Rectangle r;
    Entry *ep;
    char *s;

    ep=p->data;
    r=pl_box(p->b, p->r, p->state);
    s=ep->entry;
    if(p->flags & USERFL){
        char *p;
        s=strdup(s);
        for(p=s; *p; p++)
            *p='*';
    }
    if(stringwidth(font, s)<=r.max.x-r.min.x)
        pl_drawicon(p->b, r, PLACEW, 0, s);
    else
        pl_drawicon(p->b, r, PLACEE, 0, s);
    if(s != ep->entry)
        free(s);
}
@

<<function pl_hitentry>>=
int pl_hitentry(Panel *p, Mouse *m){
    if((m->buttons&7)==1){
        plgrabkb(p);

        p->state=DOWN;
        pldraw(p, p->b);
        while(m->buttons&1){
            int old;
            old=m->buttons;
            *m=emouse();
            if((old&7)==1){
                if((m->buttons&7)==3){
                    Entry *ep;

                    plsnarf(p);

                    /* cut */
                    ep=p->data;
                    ep->entp=ep->entry;
                    *ep->entp='\0';
                    pldraw(p, p->b);
                }
                if((m->buttons&7)==5)
                    plpaste(p);
            }
        }
        p->state=UP;
        pldraw(p, p->b);
    }
    return 0;
}
@

<<function pl_typeentry>>=
void pl_typeentry(Panel *p, Rune c){
    int n;
    Entry *ep;
    ep=p->data;
    switch(c){
    case '\n':
    case '\r':
        *ep->entp='\0';
        if(ep->hit) ep->hit(p, ep->entry);
        return;
    case Kesc:
        plsnarf(p);
        /* no break */
    case Kdel:	/* clear */
//	case Knack:	/* ^U: erase line */
//		ep->entp=ep->entry;
//		*ep->entp='\0';
//		break;
    case Kbs:	/* ^H: erase character */
        while(ep->entp!=ep->entry && !pl_rune1st(ep->entp[-1])) *--ep->entp='\0';
        if(ep->entp!=ep->entry) *--ep->entp='\0';
        break;
//	case Ketb:	/* ^W: erase word */
//		while(ep->entp!=ep->entry && !pl_idchar(ep->entp[-1]))
//			--ep->entp;
//		while(ep->entp!=ep->entry && pl_idchar(ep->entp[-1]))
//			--ep->entp;
//		*ep->entp='\0';
//		break;
    default:
        if(c < 0x20 || (c & 0xFF00) == KF || (c & 0xFF00) == Spec)
            break;
        ep->entp+=runetochar(ep->entp, &c);
        if(ep->entp>ep->eent){
            n=ep->entp-ep->entry;
            ep->entry=pl_erealloc(ep->entry, n+100+SLACK);
            ep->entp=ep->entry+n;
            ep->eent=ep->entp+100;
        }
        *ep->entp='\0';
        break;
    }
    pldraw(p, p->b);
}
@

<<function pl_getsizeentry>>=
Point pl_getsizeentry(Panel *p, Point children){
    USED(children);
    return pl_boxsize(((Entry *)p->data)->minsize, p->state);
}
@

<<function pl_childspaceentry>>=
void pl_childspaceentry(Panel *p, Point *ul, Point *size){
    USED(p, ul, size);
}
@

<<function pl_freeentry>>=
void pl_freeentry(Panel *p){
    Entry *ep;
    ep = p->data;
    free(ep->entry);
    ep->entry = ep->eent = ep->entp = 0;
}
@

<<function plinitentry>>=
void plinitentry(Panel *v, int flags, int wid, char *str, void (*hit)(Panel *, char *)){
    int elen;
    Entry *ep;
    ep=v->data;
    v->flags=flags|LEAF;
    v->state=UP;
    v->draw=pl_drawentry;
    v->hit=pl_hitentry;
    v->type=pl_typeentry;
    v->getsize=pl_getsizeentry;
    v->childspace=pl_childspaceentry;
    ep->minsize=Pt(wid, font->height);
    v->free=pl_freeentry;
    v->snarf=pl_snarfentry;
    v->paste=pl_pasteentry;
    elen=100;
    if(str) elen+=strlen(str);
    ep->entry=pl_erealloc(ep->entry, elen+SLACK);
    ep->eent=ep->entry+elen;
    strecpy(ep->entry, ep->eent, str ? str : "");
    ep->entp=ep->entry+strlen(ep->entry);
    ep->hit=hit;
    v->kind="entry";
}
@

<<function plentry>>=
Panel *plentry(Panel *parent, int flags, int wid, char *str, void (*hit)(Panel *, char *)){
    Panel *v;
    v=pl_newpanel(parent, sizeof(Entry));
    plinitentry(v, flags, wid, str, hit);
    return v;
}
@

<<function plentryval>>=
char *plentryval(Panel *p){
    Entry *ep;
    ep=p->data;
    *ep->entp='\0';
    return ep->entry;
}
@


%-------------------------------------------------------------

<<windows/libpanel/entry.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <event.h>
#include <panel.h>
#include "pldefs.h"
#include <keyboard.h>

typedef struct Entry Entry;
<<struct Entry>>
<<constant SLACK>>
<<function pl_snarfentry>>
<<function pl_pasteentry>>
<<function pl_drawentry>>
<<function pl_hitentry>>
<<function pl_typeentry>>
<<function pl_getsizeentry>>
<<function pl_childspaceentry>>
<<function pl_freeentry>>
<<function plinitentry>>
<<function plentry>>
<<function plentryval>>
@


\subsection*{[[windows/libpanel/event.c]]}

<<function plgrabkb>>=
void plgrabkb(Panel *g){
    plkbfocus=g;
}
@

<<function plkeyboard>>=
void plkeyboard(Rune c){
    if(plkbfocus){
        plkbfocus->type(plkbfocus, c);
        flushimage(display, 1);
    }
}
@

<<function pl_ptinpanel>>=
/*
 * Return the most leafward, highest priority panel containing p
 */
Panel *pl_ptinpanel(Point p, Panel *g){
    Panel *v;
    for(;g;g=g->next) if(ptinrect(p, g->r)){
        v=pl_ptinpanel(p, g->child);
        if(v && v->pri(v, p)>=g->pri(g, p)) return v;
        return g;
    }
    return 0;
}
@

<<function plmouse>>=
void plmouse(Panel *g, Mouse *m){
    Panel *hit, *last;
    if(g->flags&REMOUSE)
        hit=g->lastmouse;
    else{
        hit=pl_ptinpanel(m->xy, g);
        last=g->lastmouse;
        if(last && last!=hit){
            m->buttons|=OUT;
            last->hit(last, m);
            m->buttons&=~OUT;
        }
    }
    if(hit){
        if(hit->hit(hit, m))
            g->flags|=REMOUSE;
        else
            g->flags&=~REMOUSE;
        g->lastmouse=hit;
    }
    flushimage(display, 1);
}
@


%-------------------------------------------------------------

<<windows/libpanel/event.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <event.h>
#include <panel.h>
#include "pldefs.h"

<<function plgrabkb>>
<<function plkeyboard>>

<<function pl_ptinpanel>>
<<function plmouse>>
@


\subsection*{[[windows/libpanel/frame.c]]}

<<function pl_drawframe>>=
void pl_drawframe(Panel *p){
    pl_box(p->b, p->r, FRAME);
}
@

<<function pl_hitframe>>=
int pl_hitframe(Panel *p, Mouse *m){
    USED(p, m);
    return 0;
}
@

<<function pl_typeframe>>=
void pl_typeframe(Panel *p, Rune c){
    USED(p, c);
}
@

<<function pl_getsizeframe>>=
Point pl_getsizeframe(Panel *p, Point children){
    USED(p);
    return pl_boxsize(children, FRAME);
}
@

<<function pl_childspaceframe>>=
void pl_childspaceframe(Panel *p, Point *ul, Point *size){
    USED(p);
    pl_interior(FRAME, ul, size);
}
@

<<function plinitframe>>=
void plinitframe(Panel *v, int flags){
    v->flags=flags;
    v->draw=pl_drawframe;
    v->hit=pl_hitframe;
    v->type=pl_typeframe;
    v->getsize=pl_getsizeframe;
    v->childspace=pl_childspaceframe;
    v->kind="frame";
}
@

<<function plframe>>=
Panel *plframe(Panel *parent, int flags){
    Panel *p;
    p=pl_newpanel(parent, 0);
    plinitframe(p, flags);
    return p;
}
@


%-------------------------------------------------------------

<<windows/libpanel/frame.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <event.h>
#include <panel.h>
#include "pldefs.h"
<<function pl_drawframe>>
<<function pl_hitframe>>
<<function pl_typeframe>>
<<function pl_getsizeframe>>
<<function pl_childspaceframe>>
<<function plinitframe>>
<<function plframe>>
@


\subsection*{[[windows/libpanel/group.c]]}

<<function pl_drawgroup>>=
void pl_drawgroup(Panel *p){
    USED(p);
}
@

<<function pl_hitgroup>>=
int pl_hitgroup(Panel *p, Mouse *m){
    USED(p, m);
    return 0;
}
@

<<function pl_typegroup>>=
void pl_typegroup(Panel *p, Rune c){
    USED(p, c);
}
@

<<function pl_getsizegroup>>=
Point pl_getsizegroup(Panel *p, Point children){
    USED(p);
    return children;
}
@

<<function pl_childspacegroup>>=
void pl_childspacegroup(Panel *p, Point *ul, Point *size){
    USED(p, ul, size);
}
@

<<function plinitgroup>>=
void plinitgroup(Panel *v, int flags){
    v->flags=flags;
    v->draw=pl_drawgroup;
    v->hit=pl_hitgroup;
    v->type=pl_typegroup;
    v->getsize=pl_getsizegroup;
    v->childspace=pl_childspacegroup;
    v->kind="group";
}
@

<<function plgroup>>=
Panel *plgroup(Panel *parent, int flags){
    Panel *p;
    p=pl_newpanel(parent, 0);
    plinitgroup(p, flags);
    return p;
}
@


%-------------------------------------------------------------

<<windows/libpanel/group.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <event.h>
#include <panel.h>
#include "pldefs.h"
<<function pl_drawgroup>>
<<function pl_hitgroup>>
<<function pl_typegroup>>
<<function pl_getsizegroup>>
<<function pl_childspacegroup>>
<<function plinitgroup>>
<<function plgroup>>
@


\subsection*{[[windows/libpanel/init.c]]}

<<function plinit>>=
/*
 * Just a wrapper for all the initialization routines
 */
int plinit(int ldepth){
    if(!pl_drawinit(ldepth)) return 0;
    return 1;
}
@


%-------------------------------------------------------------

<<windows/libpanel/init.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <event.h>
#include <panel.h>
#include "pldefs.h"
<<function plinit>>
@


\subsection*{[[windows/libpanel/label.c]]}

<<struct Label>>=
struct Label{
    int placement;
    Icon *icon;
};
@

<<function pl_drawlabel>>=
void pl_drawlabel(Panel *p){
    Label *l;
    l=p->data;
    pl_drawicon(p->b, pl_box(p->b, p->r, PASSIVE), l->placement, p->flags, l->icon);
}
@

<<function pl_hitlabel>>=
int pl_hitlabel(Panel *p, Mouse *m){
    USED(p, m);
    return 0;
}
@

<<function pl_typelabel>>=
void pl_typelabel(Panel *p, Rune c){
    USED(p, c);
}
@

<<function pl_getsizelabel>>=
Point pl_getsizelabel(Panel *p, Point children){
    USED(children);		/* shouldn't have any children */
    return pl_boxsize(pl_iconsize(p->flags, ((Label *)p->data)->icon), PASSIVE);
}
@

<<function pl_childspacelabel>>=
void pl_childspacelabel(Panel *g, Point *ul, Point *size){
    USED(g, ul, size);
}
@

<<function plinitlabel>>=
void plinitlabel(Panel *v, int flags, Icon *icon){
    v->flags=flags|LEAF;
    ((Label *)(v->data))->icon=icon;
    v->draw=pl_drawlabel;
    v->hit=pl_hitlabel;
    v->type=pl_typelabel;
    v->getsize=pl_getsizelabel;
    v->childspace=pl_childspacelabel;
    v->kind="label";
}
@

<<function pllabel>>=
Panel *pllabel(Panel *parent, int flags, Icon *icon){
    Panel *p;
    p=pl_newpanel(parent, sizeof(Label));
    plinitlabel(p, flags, icon);
    plplacelabel(p, PLACECEN);
    return p;
}
@

<<function plplacelabel>>=
void plplacelabel(Panel *p, int placement){
    ((Label *)(p->data))->placement=placement;
}
@


%-------------------------------------------------------------

<<windows/libpanel/label.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <event.h>
#include <panel.h>
#include "pldefs.h"
typedef struct Label Label;
<<struct Label>>
<<function pl_drawlabel>>
<<function pl_hitlabel>>
<<function pl_typelabel>>
<<function pl_getsizelabel>>
<<function pl_childspacelabel>>
<<function plinitlabel>>
<<function pllabel>>
<<function plplacelabel>>
@


\subsection*{[[windows/libpanel/list.c]]}

<<struct List>>=
struct List{
    void (*hit)(Panel *, int, int);	/* call user back on hit */
    char *(*gen)(Panel *, int);	/* return text given index or 0 if out of range */
    int lo;				/* indices of first, last items displayed */
    int sel;			/* index of hilited item */
    int len;			/* # of items in list */
    Rectangle listr;
    Point minsize;
    int buttons;
};
@

<<constant MAXHGT>>=
#define	MAXHGT	12
@

<<function pl_listsel>>=
void pl_listsel(Panel *p, int sel, int on){
    List *lp;
    int hi;
    Rectangle r;
    lp=p->data;
    hi=lp->lo+(lp->listr.max.y-lp->listr.min.y)/font->height;
    if(lp->lo>=0 && lp->lo<=sel && sel<hi && sel<lp->len){
        r=lp->listr;
        r.min.y+=(sel-lp->lo)*font->height;
        r.max.y=r.min.y+font->height;
        if(on)
            pl_highlight(p->b, r);
        else{
            pl_fill(p->b, r);
            pl_drawicon(p->b, r, PLACEW, 0, lp->gen(p, sel));
        }
    }
}
@

<<function pl_liststrings>>=
void pl_liststrings(Panel *p, int lo, int hi, Rectangle r){
    Panel *sb;
    List *lp;
    char *s;
    int i;
    lp=p->data;
    for(i=lo;i!=hi && (s=lp->gen(p, i));i++){
        r.max.y=r.min.y+font->height;
        pl_drawicon(p->b, r, PLACEW, 0, s);
        r.min.y+=font->height;
    }
    if(lo<=lp->sel && lp->sel<hi) pl_listsel(p, lp->sel, 1);
    sb=p->yscroller;
    if(sb && sb->setscrollbar)
        sb->setscrollbar(sb, lp->lo,
            lp->lo+(lp->listr.max.y-lp->listr.min.y)/font->height, lp->len);
}
@

<<function pl_drawlist>>=
void pl_drawlist(Panel *p){
    List *lp;
    lp=p->data;
    lp->listr=pl_box(p->b, p->r, UP);
    pl_liststrings(p, lp->lo, lp->lo+(lp->listr.max.y-lp->listr.min.y)/font->height,
        lp->listr);
}
@

<<function pl_hitlist>>=
int pl_hitlist(Panel *p, Mouse *m){
    int oldsel, hitme;
    Point ul, size;
    List *lp;
    lp=p->data;
    hitme=0;
    ul=p->r.min;
    size=subpt(p->r.max, p->r.min);
    pl_interior(p->state, &ul, &size);
    oldsel=lp->sel;
    if(m->buttons&OUT){
        p->state=UP;
        if(m->buttons&~OUT) lp->sel=-1;
    }
    else if(p->state==DOWN || m->buttons&7){
        lp->sel=(m->xy.y-ul.y)/font->height+lp->lo;
        if(m->buttons&7){
            lp->buttons=m->buttons;
            p->state=DOWN;
        }
        else{
            hitme=1;
            p->state=UP;
        }
    }
    if(oldsel!=lp->sel){
        pl_listsel(p, oldsel, 0);
        pl_listsel(p, lp->sel, 1);
    }
    if(hitme && 0<=lp->sel && lp->sel<lp->len && lp->hit)
        lp->hit(p, lp->buttons, lp->sel);
    return 0;
}
@

<<function pl_scrolllist>>=
void pl_scrolllist(Panel *p, int dir, int buttons, int val, int len){
    Point ul, size;
    int nlist, oldlo, hi, nline, y;
    List *lp;
    Rectangle r;
    lp=p->data;
    ul=p->r.min;
    size=subpt(p->r.max, p->r.min);
    pl_interior(p->state, &ul, &size);
    nlist=size.y/font->height;
    oldlo=lp->lo;
    if(dir==VERT) switch(buttons){
    case 1: lp->lo-=nlist*val/len; break;
    case 2: lp->lo=lp->len*val/len; break;
    case 4:	lp->lo+=nlist*val/len; break;
    }
    if(lp->lo<0) lp->lo=0;
    if(lp->lo>=lp->len) lp->lo=lp->len-1;
    if(lp->lo==oldlo) return;
    p->scr.pos.y=lp->lo;
    r=lp->listr;
    nline=(r.max.y-r.min.y)/font->height;
    hi=lp->lo+nline;
    if(hi<=oldlo || lp->lo>=oldlo+nline){
        pl_box(p->b, r, PASSIVE);
        pl_liststrings(p, lp->lo, hi, r);
    }
    else if(lp->lo<oldlo){
        y=r.min.y+(oldlo-lp->lo)*font->height;
        pl_cpy(p->b, Pt(r.min.x, y), 
            Rect(r.min.x, r.min.y, r.max.x, r.min.y+(hi-oldlo)*font->height));
        r.max.y=y;
        pl_box(p->b, r, PASSIVE);
        pl_liststrings(p, lp->lo, oldlo, r);
    }
    else{
        pl_cpy(p->b, r.min, Rect(r.min.x, r.min.y+(lp->lo-oldlo)*font->height,
            r.max.x, r.max.y));
        r.min.y=r.min.y+(oldlo+nline-lp->lo)*font->height;
        pl_box(p->b, r, PASSIVE);
        pl_liststrings(p, oldlo+nline, hi, r);
    }
}
@

<<function pl_typelist>>=
void pl_typelist(Panel *g, Rune c){
    USED(g, c);
}
@

<<function pl_getsizelist>>=
Point pl_getsizelist(Panel *p, Point children){
    USED(children);
    return pl_boxsize(((List *)p->data)->minsize, p->state);
}
@

<<function pl_childspacelist>>=
void pl_childspacelist(Panel *g, Point *ul, Point *size){
    USED(g, ul, size);
}
@

<<function plinitlist>>=
void plinitlist(Panel *v, int flags, char *(*gen)(Panel *, int), int nlist, void (*hit)(Panel *, int, int)){
    List *lp;
    int wid, max;
    char *str;
    lp=v->data;
    v->flags=flags|LEAF;
    v->state=UP;
    v->draw=pl_drawlist;
    v->hit=pl_hitlist;
    v->type=pl_typelist;
    v->getsize=pl_getsizelist;
    v->childspace=pl_childspacelist;
    lp->gen=gen;
    lp->hit=hit;
    max=0;
    for(lp->len=0;str=gen(v, lp->len);lp->len++){
        wid=stringwidth(font, str);
        if(wid>max) max=wid;
    }
    if(flags&(FILLX|EXPAND)){
        for(lp->len=0;gen(v, lp->len);lp->len++);
        lp->minsize=Pt(0, nlist*font->height);
    }
    else{
        max=0;
        for(lp->len=0;str=gen(v, lp->len);lp->len++){
            wid=stringwidth(font, str);
            if(wid>max) max=wid;
        }
        lp->minsize=Pt(max, nlist*font->height);
    }
    lp->sel=-1;
    lp->lo=0;
    v->scroll=pl_scrolllist;
    v->scr.pos=Pt(0,0);
    v->scr.size=Pt(0,lp->len);
    v->kind="list";
}
@

<<function pllist>>=
Panel *pllist(Panel *parent, int flags, char *(*gen)(Panel *, int), int nlist, void (*hit)(Panel *, int, int)){
    Panel *v;
    v=pl_newpanel(parent, sizeof(List));
    plinitlist(v, flags, gen, nlist, hit);
    return v;
}
@


%-------------------------------------------------------------

<<windows/libpanel/list.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <event.h>
#include <panel.h>
#include "pldefs.h"
typedef struct List List;
<<struct List>>
<<constant MAXHGT>>
<<function pl_listsel>>
<<function pl_liststrings>>
<<function pl_drawlist>>
<<function pl_hitlist>>
<<function pl_scrolllist>>
<<function pl_typelist>>
<<function pl_getsizelist>>
<<function pl_childspacelist>>
<<function plinitlist>>
<<function pllist>>
@


\subsection*{[[windows/libpanel/mem.c]]}

<<function pl_emalloc>>=
void *pl_emalloc(int n){
    void *v;
    v=mallocz(n, 1);
    if(v==0){
        fprint(2, "Can't malloc!\n");
        exits("no mem");
    }
    setmalloctag(v, getcallerpc(&n));
    return v;
}
@

<<function pl_erealloc>>=
void *pl_erealloc(void *v, int n)
{
    v=realloc(v, n);
    if(v==0){
        fprint(2, "Can't realloc!\n");
        exits("no mem");
    }
    setrealloctag(v, getcallerpc(&v));
    return v;
}
@

<<function pl_unexpected>>=
void pl_unexpected(Panel *g, char *rou){
    fprint(2, "%s called unexpectedly (%s %lux)\n", rou, g->kind, (ulong)g);
    abort();
}
@

<<function pl_drawerror>>=
void pl_drawerror(Panel *g){
    pl_unexpected(g, "draw");
}
@

<<function pl_hiterror>>=
int pl_hiterror(Panel *g, Mouse *m){
    USED(m);
    pl_unexpected(g, "hit");
    return 0;
}
@

<<function pl_typeerror>>=
void pl_typeerror(Panel *g, Rune c){
    USED(c);
    pl_unexpected(g, "type");
}
@

<<function pl_getsizeerror>>=
Point pl_getsizeerror(Panel *g, Point childsize){
    pl_unexpected(g, "getsize");
    return childsize;
}
@

<<function pl_childspaceerror>>=
void pl_childspaceerror(Panel *g, Point *ul, Point *size){
    USED(ul, size);
    pl_unexpected(g, "childspace");
}
@

<<function pl_scrollerror>>=
void pl_scrollerror(Panel *g, int dir, int button, int num, int den){
    USED(dir, button, num, den);
    pl_unexpected(g, "scroll");
}
@

<<function pl_setscrollbarerror>>=
void pl_setscrollbarerror(Panel *g, int top, int bot, int den){
    USED(top, bot, den);
    pl_unexpected(g, "setscrollbar");
}
@

<<function pl_prinormal>>=
int pl_prinormal(Panel *, Point){
    return PRI_NORMAL;
}
@

<<function pl_newpanel>>=
Panel *pl_newpanel(Panel *parent, int ndata){
    Panel *v;
    if(parent && parent->flags&LEAF){
        fprint(2, "newpanel: can't create child of %s %lux\n", parent->kind, (ulong)parent);
        exits("bad newpanel");
    }
    v=pl_emalloc(sizeof(Panel));
    v->r=Rect(0,0,0,0);
    v->flags=0;
    v->ipad=Pt(0,0);
    v->pad=Pt(0,0);
    v->size=Pt(0,0);
    v->sizereq=Pt(0,0);
    v->lastmouse=0;
    v->next=0;
    v->child=0;
    v->echild=0;
    v->b=0;
    v->pri=pl_prinormal;
    v->scrollee=0;
    v->xscroller=0;
    v->yscroller=0;
    v->parent=parent;
    v->scr.pos=Pt(0,0);
    v->scr.size=Pt(0,0);
    if(parent){
        if(parent->child==0)
            parent->child=v;
        else
            parent->echild->next=v;
        parent->echild=v;
    }
    v->draw=pl_drawerror;
    v->hit=pl_hiterror;
    v->type=pl_typeerror;
    v->getsize=pl_getsizeerror;
    v->childspace=pl_childspaceerror;
    v->scroll=pl_scrollerror;
    v->setscrollbar=pl_setscrollbarerror;
    v->free=0;
    v->snarf=0;
    v->paste=0;
    if(ndata)
        v->data=pl_emalloc(ndata);
    else
        v->data=0;
    return v;
}
@

<<function plfree>>=
void plfree(Panel *p){
    Panel *cp, *ncp;
    if(p==0)
        return;
    if(p==plkbfocus)
        plkbfocus=0;
    for(cp=p->child;cp;cp=ncp){
        ncp=cp->next;
        plfree(cp);
    }
    if(p->free) p->free(p);
    if(p->data) free(p->data);
    free(p);
}
@


%-------------------------------------------------------------

<<windows/libpanel/mem.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <event.h>
#include <panel.h>
#include "pldefs.h"
<<function pl_emalloc>>
<<function pl_erealloc>>
<<function pl_unexpected>>
<<function pl_drawerror>>
<<function pl_hiterror>>
<<function pl_typeerror>>
<<function pl_getsizeerror>>
<<function pl_childspaceerror>>
<<function pl_scrollerror>>
<<function pl_setscrollbarerror>>
<<function pl_prinormal>>
<<function pl_newpanel>>
<<function plfree>>
@


\subsection*{[[windows/libpanel/message.c]]}

<<struct Message>>=
struct Message{
    char *text;
    Point minsize;
};
@

<<function pl_textmsg>>=
void pl_textmsg(Image *b, Rectangle r, Font *f, char *s){
    char *start, *end;	/* of line */
    Point where;
    int lwid, c, wid;
    where=r.min;
    wid=r.max.x-r.min.x;
    do{
        start=s;
        lwid=0;
        end=s;
        do{
            for(;*s!=' ' && *s!='\0';s=pl_nextrune(s)) lwid+=pl_runewidth(f, s);
            if(lwid>wid) break;
            end=s;
            for(;*s==' ';s=pl_nextrune(s)) lwid+=pl_runewidth(f, s);
        }while(*s!='\0');
        if(end==start)	/* can't even fit one word on line! */
            end=s;
        c=*end;
        *end='\0';
        string(b, where, display->black, ZP, f, start);
        *end=c;
        where.y+=font->height;
        s=end;
        while(*s==' ') s=pl_nextrune(s);
    }while(*s!='\0');
}
@

<<function pl_foldsize>>=
Point pl_foldsize(Font *f, char *s, int wid){
    char *start, *end;	/* of line */
    Point size;
    int lwid, ewid;
    size=Pt(0,0);
    do{
        start=s;
        lwid=0;
        end=s;
        ewid=lwid;
        do{
            for(;*s!=' ' && *s!='\0';s=pl_nextrune(s)) lwid+=pl_runewidth(f, s);
            if(lwid>wid) break;
            end=s;
            ewid=lwid;
            for(;*s==' ';s=pl_nextrune(s)) lwid+=pl_runewidth(f, s);
        }while(*s!='\0');
        if(end==start){	/* can't even fit one word on line! */
            ewid=lwid;
            end=s;
        }
        if(ewid>size.x) size.x=ewid;
        size.y+=font->height;
        s=end;
        while(*s==' ') s=pl_nextrune(s);
    }while(*s!='\0');
    return size;
}
@

<<function pl_drawmessage>>=
void pl_drawmessage(Panel *p){
    pl_textmsg(p->b, pl_box(p->b, p->r, PASSIVE), font, ((Message *)p->data)->text);
}
@

<<function pl_hitmessage>>=
int pl_hitmessage(Panel *g, Mouse *m){
    USED(g, m);
    return 0;
}
@

<<function pl_typemessage>>=
void pl_typemessage(Panel *g, Rune c){
    USED(g, c);
}
@

<<function pl_getsizemessage>>=
Point pl_getsizemessage(Panel *p, Point children){
    Message *mp;
    USED(children);
    mp=p->data;
    return pl_boxsize(pl_foldsize(font, mp->text, mp->minsize.x), PASSIVE);
}
@

<<function pl_childspacemessage>>=
void pl_childspacemessage(Panel *p, Point *ul, Point *size){
    USED(p, ul, size);
}
@

<<function plinitmessage>>=
void plinitmessage(Panel *v, int flags, int wid, char *msg){
    Message *mp;
    mp=v->data;
    v->flags=flags|LEAF;
    v->draw=pl_drawmessage;
    v->hit=pl_hitmessage;
    v->type=pl_typemessage;
    v->getsize=pl_getsizemessage;
    v->childspace=pl_childspacemessage;
    mp->text=msg;
    mp->minsize=Pt(wid, font->height);
    v->kind="message";
}
@

<<function plmessage>>=
Panel *plmessage(Panel *parent, int flags, int wid, char *msg){
    Panel *v;
    v=pl_newpanel(parent, sizeof(Message));
    plinitmessage(v, flags, wid, msg);
    return v;
}
@


%-------------------------------------------------------------

<<windows/libpanel/message.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <event.h>
#include <panel.h>
#include "pldefs.h"
typedef struct Message Message;
<<struct Message>>
<<function pl_textmsg>>
<<function pl_foldsize>>
<<function pl_drawmessage>>
<<function pl_hitmessage>>
<<function pl_typemessage>>
<<function pl_getsizemessage>>
<<function pl_childspacemessage>>
<<function plinitmessage>>
<<function plmessage>>
@


\subsection*{[[windows/libpanel/pack.c]]}

<<function pl_max>>=
int pl_max(int a, int b){
    return a>b?a:b;
}
@

<<function pl_sizesibs>>=
Point pl_sizesibs(Panel *p){
    Point s;
    if(p==0) return Pt(0,0);
    s=pl_sizesibs(p->next);
    switch(p->flags&PACK){
    case PACKN:
    case PACKS:
        s.x=pl_max(s.x, p->sizereq.x);
        s.y+=p->sizereq.y;
        break;
    case PACKE:
    case PACKW:
        s.x+=p->sizereq.x;
        s.y=pl_max(s.y, p->sizereq.y);
        break;
    }
    return s;
}
@

<<function pl_sizereq>>=
/*
 * Compute the requested size of p and its descendants.
 */
void pl_sizereq(Panel *p){
    Panel *cp;
    Point maxsize;
    maxsize=Pt(0,0);
    for(cp=p->child;cp;cp=cp->next){
        pl_sizereq(cp);
        if(cp->sizereq.x>maxsize.x) maxsize.x=cp->sizereq.x;
        if(cp->sizereq.y>maxsize.y) maxsize.y=cp->sizereq.y;
    }
    for(cp=p->child;cp;cp=cp->next){
        if(cp->flags&MAXX) cp->sizereq.x=maxsize.x;
        if(cp->flags&MAXY) cp->sizereq.y=maxsize.y;
    }
    p->childreq=pl_sizesibs(p->child);
    p->sizereq=addpt(addpt(p->getsize(p, p->childreq), p->ipad), p->pad);
    if(p->flags&FIXEDX) p->sizereq.x=p->fixedsize.x;
    if(p->flags&FIXEDY) p->sizereq.y=p->fixedsize.y;
}
@

<<function pl_getshare>>=
Point pl_getshare(Panel *p){
    Point share;
    if(p==0) return Pt(0,0);
    share=pl_getshare(p->next);
    if(p->flags&EXPAND) switch(p->flags&PACK){
    case PACKN:
    case PACKS:
        if(share.x==0) share.x=1;
        share.y++;
        break;
    case PACKE:
    case PACKW:
        share.x++;
        if(share.y==0) share.y=1;
        break;
    }
    return share;
}
@

<<function pl_setrect>>=
/*
 * Set the sizes and rectangles of p and its descendants, given their requested sizes.
 */
void pl_setrect(Panel *p, Point ul, Point avail){
    Point space, newul, newspace, slack, share;
    int l;
    Panel *c;
    p->size=subpt(p->sizereq, p->pad);
    ul=addpt(ul, divpt(p->pad, 2));
    avail=subpt(avail, p->pad);
    if(p->size.x>avail.x)
        p->size.x = avail.x;
    if(p->size.y>avail.y)
        p->size.y = avail.y;
    if(p->flags&(FILLX|EXPAND)) p->size.x=avail.x;
    if(p->flags&(FILLY|EXPAND)) p->size.y=avail.y;
    switch(p->flags&PLACE){
    case PLACECEN:	ul.x+=(avail.x-p->size.x)/2; ul.y+=(avail.y-p->size.y)/2; break;
    case PLACES:	ul.x+=(avail.x-p->size.x)/2; ul.y+= avail.y-p->size.y   ; break;
    case PLACEE:	ul.x+= avail.x-p->size.x   ; ul.y+=(avail.y-p->size.y)/2; break;
    case PLACEW:	                             ul.y+=(avail.y-p->size.y)/2; break;
    case PLACEN:	ul.x+=(avail.x-p->size.x)/2;                              break;
    case PLACENE:	ul.x+= avail.x-p->size.x   ;                              break;
    case PLACENW:                                                             break;
    case PLACESE:	ul.x+= avail.x-p->size.x   ; ul.y+= avail.y-p->size.y   ; break;
    case PLACESW:                                ul.y+= avail.y-p->size.y   ; break;
    }
    p->r=Rpt(ul, addpt(ul, p->size));
    space=p->size;
    p->childspace(p, &ul, &space);
    slack=subpt(space, p->childreq);
    share=pl_getshare(p->child);
    for(c=p->child;c;c=c->next){
        if(c->flags&EXPAND){
            switch(c->flags&PACK){
            case PACKN:
            case PACKS:
                c->sizereq.x+=slack.x;
                l=slack.y/share.y;
                c->sizereq.y+=l;
                slack.y-=l;
                --share.y;
                break;
            case PACKE:
            case PACKW:
                l=slack.x/share.x;
                c->sizereq.x+=l;
                slack.x-=l;
                --share.x;
                c->sizereq.y+=slack.y;
                break;
            }
        }
        switch(c->flags&PACK){
        case PACKN:
            newul=Pt(ul.x, ul.y+c->sizereq.y);
            newspace=Pt(space.x, space.y-c->sizereq.y);
            pl_setrect(c, ul, Pt(space.x, c->sizereq.y));
            break;
        case PACKW:
            newul=Pt(ul.x+c->sizereq.x, ul.y);
            newspace=Pt(space.x-c->sizereq.x, space.y);
            pl_setrect(c, ul, Pt(c->sizereq.x, space.y));
            break;
        case PACKS:
            newul=ul;
            newspace=Pt(space.x, space.y-c->sizereq.y);
            pl_setrect(c, Pt(ul.x, ul.y+space.y-c->sizereq.y),
                Pt(space.x, c->sizereq.y));
            break;
        case PACKE:
            newul=ul;
            newspace=Pt(space.x-c->sizereq.x, space.y);
            pl_setrect(c, Pt(ul.x+space.x-c->sizereq.x, ul.y),
                Pt(c->sizereq.x, space.y));
            break;
        }
        ul=newul;
        space=newspace;
    }
}
@

<<function plpack>>=
void plpack(Panel *p, Rectangle where){
    pl_sizereq(p);
    pl_setrect(p, where.min, subpt(where.max, where.min));
}
@

<<function plmove>>=
/*
 * move an already-packed panel so that p->r=raddp(p->r, d)
 */
void plmove(Panel *p, Point d){
    if(strcmp(p->kind, "edit") == 0)	/* sorry */
        plemove(p, d);
    p->r=rectaddpt(p->r, d);
    for(p=p->child;p;p=p->next) plmove(p, d);
}
@


%-------------------------------------------------------------

<<windows/libpanel/pack.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <event.h>
#include <panel.h>
#include "pldefs.h"
<<function pl_max>>
<<function pl_sizesibs>>
<<function pl_sizereq>>
<<function pl_getshare>>
<<function pl_setrect>>
<<function plpack>>
<<function plmove>>
@


\subsection*{[[windows/libpanel/panel.h]]}

<<struct Scroll>>=
struct Scroll{
    Point pos, size;
};
@

<<struct Rtext>>=
struct Rtext{
    int flags;		/* responds to hits? text selection? */
    void *user;		/* user data */
    int space;		/* how much space before, if no break */
    int indent;		/* how much space before, after a break */
    Image *b;		/* what to display, if nonzero */
    Panel *p;		/* what to display, if nonzero and b==0 */
    Font *font;		/* font in which to draw text */
    char *text;		/* what to display, if b==0 and p==0 */
    Rtext *next;		/* next piece */
    /* private below */
    Rtext *nextline;	/* links line to line */
    Rtext *last;		/* last, for append */
    Rectangle r;		/* where to draw, if origin were Pt(0,0) */
    int topy;		/* y coord of top of line */
    int wid;		/* not including space */
};
@

<<struct Panel>>=
struct Panel{
    Point ipad, pad;				/* extra space inside and outside */
    Point fixedsize;				/* size of Panel, if FIXED */
    int user;					/* available for user */
    void *userp;					/* available for user */
    Rectangle r;					/* where the Panel goes */
    /* private below */
    Panel *next;					/* It's a list! */
    Panel *child, *echild, *parent;			/* No, it's a tree! */
    Image *b;					/* where we're drawn */
    int flags;					/* position flags, see below */
    char *kind;					/* what kind of panel? */
    int state;					/* for hitting & drawing purposes */
    Point size;					/* space for this Panel */
    Point sizereq;					/* size requested by this Panel */
    Point childreq;					/* total size needed by children */
    Panel *lastmouse;				/* who got the last mouse event? */
    Panel *scrollee;				/* pointer to scrolled window */
    Panel *xscroller, *yscroller;			/* pointers to scroll bars */
    Scroll scr;					/* scroll data */
    void *data;					/* kind-specific data */
    void (*draw)(Panel *);				/* draw panel and children */
    int (*pri)(Panel *, Point);			/* priority for hitting */
    int (*hit)(Panel *, Mouse *);			/* process mouse event */
    void (*type)(Panel *, Rune);			/* process keyboard event */
    Point (*getsize)(Panel *, Point);		/* return size, given child size */
    void (*childspace)(Panel *, Point *, Point *);	/* child ul & size given our size */
    void (*scroll)(Panel *, int, int, int, int);	/* scroll bar to scrollee */
    void (*setscrollbar)(Panel *, int, int, int);	/* scrollee to scroll bar */
    void (*free)(Panel *);				/* free fields of data when done */
    char* (*snarf)(Panel *);			/* snarf text from panel */
    void (*paste)(Panel *, char *);			/* paste text into panel */
};
@

<<constant PACK>>=
/*
 * Panel flags
 */
#define	PACK	0x0007		/* which side of the parent is the Panel attached to? */
@

<<constant PACKN>>=
#define		PACKN	0x0000
@

<<constant PACKE>>=
#define		PACKE	0x0001
@

<<constant PACKS>>=
#define		PACKS	0x0002
@

<<constant PACKW>>=
#define		PACKW	0x0003
@

<<constant PACKCEN>>=
#define		PACKCEN	0x0004	/* only used by pulldown */
@

<<constant FILLX>>=
#define	FILLX	0x0008		/* grow horizontally to fill the available space */
@

<<constant FILLY>>=
#define	FILLY	0x0010		/* grow vertically to fill the available space */
@

<<constant PLACE>>=
#define	PLACE	0x01e0		/* which side of its space should the Panel adhere to? */
@

<<constant PLACECEN>>=
#define		PLACECEN 0x0000
@

<<constant PLACES>>=
#define		PLACES	0x0020
@

<<constant PLACEE>>=
#define		PLACEE	0x0040
@

<<constant PLACEW>>=
#define		PLACEW	0x0060
@

<<constant PLACEN>>=
#define		PLACEN	0x0080
@

<<constant PLACENE>>=
#define		PLACENE	0x00a0
@

<<constant PLACENW>>=
#define		PLACENW	0x00c0
@

<<constant PLACESE>>=
#define		PLACESE	0x00e0
@

<<constant PLACESW>>=
#define		PLACESW	0x0100
@

<<constant EXPAND>>=
#define	EXPAND	0x0200		/* use up all extra space in the parent */
@

<<constant FIXED>>=
#define	FIXED	0x0c00		/* don't pass children's size requests through to parent */
@

<<constant FIXEDX>>=
#define	FIXEDX	0x0400
@

<<constant FIXEDY>>=
#define	FIXEDY	0x0800
@

<<constant MAXX>>=
#define	MAXX	0x1000		/* make x size as big as biggest sibling's */
@

<<constant MAXY>>=
#define	MAXY	0x2000		/* make y size as big as biggest sibling's */
@

<<constant BITMAP>>=
#define	BITMAP	0x4000		/* text argument is a bitmap, not a string */
@

<<constant USERFL>>=
#define USERFL	0x100000	/* start of user flag */
@

<<constant OUT>>=
/*
 * An extra bit in Mouse.buttons
 */
#define	OUT	8			/* Mouse.buttons bit, set when mouse leaves Panel */
@

<<constant PRI_NORMAL>>=
/*
 * Priorities
 */
#define	PRI_NORMAL	0		/* ordinary panels */
@

<<constant PRI_POPUP>>=
#define	PRI_POPUP	1		/* popup menus */
@

<<constant PRI_SCROLLBAR>>=
#define	PRI_SCROLLBAR	2		/* scroll bars */
@

<<constant PL_HOT>>=
/* Rtext.flags */
#define PL_HOT		1
@

<<constant PL_SEL>>=
#define PL_SEL		2
@

<<global plkbfocus>>=
Panel *plkbfocus;			/* the panel in keyboard focus */
@


%-------------------------------------------------------------

<<windows/libpanel/panel.h>>=
//#pragma	src	"/sys/src/libpanel"
//#pragma	lib	"libpanel.a"
typedef struct Scroll Scroll;
typedef struct Panel Panel;		/* a Graphical User Interface element */
typedef struct Rtext Rtext;		/* formattable text */
typedef void Icon;			/* Always used as Icon * -- Image or char */
typedef struct Idol Idol;		/* A picture/text combo */
<<struct Scroll>>
<<struct Rtext>>
<<struct Panel>>
<<constant PACK>>
<<constant PACKN>>
<<constant PACKE>>
<<constant PACKS>>
<<constant PACKW>>
<<constant PACKCEN>>
<<constant FILLX>>
<<constant FILLY>>
<<constant PLACE>>
<<constant PLACECEN>>
<<constant PLACES>>
<<constant PLACEE>>
<<constant PLACEW>>
<<constant PLACEN>>
<<constant PLACENE>>
<<constant PLACENW>>
<<constant PLACESE>>
<<constant PLACESW>>
<<constant EXPAND>>
<<constant FIXED>>
<<constant FIXEDX>>
<<constant FIXEDY>>
<<constant MAXX>>
<<constant MAXY>>
<<constant BITMAP>>
<<constant USERFL>>

<<constant OUT>>
<<constant PRI_NORMAL>>
<<constant PRI_POPUP>>
<<constant PRI_SCROLLBAR>>

<<constant PL_HOT>>
<<constant PL_SEL>>

<<global plkbfocus>>

int plinit(int);			/* initialization */
void plpack(Panel *, Rectangle);	/* figure out where to put the Panel & children */
void plmove(Panel *, Point);		/* move an already-packed panel to a new location */
void pldraw(Panel *, Image *);		/* display the panel on the bitmap */
void plfree(Panel *);			/* give back space */
void plgrabkb(Panel *);			/* this Panel should receive keyboard events */
void plkeyboard(Rune);			/* send a keyboard event to the appropriate Panel */
void plmouse(Panel *, Mouse *);		/* send a Mouse event to a Panel tree */
void plscroll(Panel *, Panel *, Panel *); /* link up scroll bars */
char *plentryval(Panel *);		/* entry delivers its value */
void plsetbutton(Panel *, int);		/* set or clear the mark on a button */
void plsetslider(Panel *, int, int);	/* set the value of a slider */
Rune *pleget(Panel *);			/* get the text from an edit window */
int plelen(Panel *);			/* get the length of the text from an edit window */
void plegetsel(Panel *, int *, int *);	/* get the selection from an edit window */
void plepaste(Panel *, Rune *, int);	/* paste in an edit window */
void plesel(Panel *, int, int);		/* set the selection in an edit window */
void plescroll(Panel *, int);		/* scroll an edit window */
Scroll plgetscroll(Panel *);		/* get scrolling information from panel */
void plsetscroll(Panel *, Scroll);	/* set scrolling information */
void plplacelabel(Panel *, int);	/* label placement */

/*
 * Panel creation & reinitialization functions
 */
Panel *plbutton(Panel *pl, int, Icon *, void (*)(Panel *pl, int));
Panel *plcanvas(Panel *pl, int, void (*)(Panel *), void (*)(Panel *pl, Mouse *));
Panel *plcheckbutton(Panel *pl, int, Icon *, void (*)(Panel *pl, int, int));
Panel *pledit(Panel *, int, Point, Rune *, int, void (*)(Panel *));
Panel *plentry(Panel *pl, int, int, char *, void (*)(Panel *pl, char *));
Panel *plframe(Panel *pl, int);
Panel *plgroup(Panel *pl, int);
Panel *plidollist(Panel*, int, Point, Font*, Idol*, void (*)(Panel*, int, void*));
Panel *pllabel(Panel *pl, int, Icon *);
Panel *pllist(Panel *pl, int, char *(*)(Panel *, int), int, void(*)(Panel *pl, int, int));
Panel *plmenu(Panel *pl, int, Icon **, int, void (*)(int, int));
Panel *plmenubar(Panel *pl, int, int, Icon *, Panel *pl, Icon *, ...);
Panel *plmessage(Panel *pl, int, int, char *);
Panel *plpopup(Panel *pl, int, Panel *pl, Panel *pl, Panel *pl);
Panel *plpulldown(Panel *pl, int, Icon *, Panel *pl, int);
Panel *plradiobutton(Panel *pl, int, Icon *, void (*)(Panel *pl, int, int));
Panel *plscrollbar(Panel *plparent, int flags);
Panel *plslider(Panel *pl, int, Point, void(*)(Panel *pl, int, int, int));
Panel *pltextview(Panel *, int, Point, Rtext *, void (*)(Panel *, int, Rtext *));
void plinitbutton(Panel *, int, Icon *, void (*)(Panel *, int));
void plinitcanvas(Panel *, int, void (*)(Panel *), void (*)(Panel *, Mouse *));
void plinitcheckbutton(Panel *, int, Icon *, void (*)(Panel *, int, int));
void plinitedit(Panel *, int, Point, Rune *, int, void (*)(Panel *));
void plinitentry(Panel *, int, int, char *, void (*)(Panel *, char *));
void plinitframe(Panel *, int);
void plinitgroup(Panel *, int);
void plinitidollist(Panel*, int, Point, Font*, Idol*, void (*)(Panel*, int, void*));
void plinitlabel(Panel *, int, Icon *);
void plinitlist(Panel *, int, char *(*)(Panel *, int), int, void(*)(Panel *, int, int));
void plinitmenu(Panel *, int, Icon **, int, void (*)(int, int));
void plinitmessage(Panel *, int, int, char *);
void plinitpopup(Panel *, int, Panel *, Panel *, Panel *);
void plinitpulldown(Panel *, int, Icon *, Panel *, int);
void plinitradiobutton(Panel *, int, Icon *, void (*)(Panel *, int, int));
void plinitscrollbar(Panel *parent, int flags);
void plinitslider(Panel *, int, Point, void(*)(Panel *, int, int, int));
void plinittextview(Panel *, int, Point, Rtext *, void (*)(Panel *, int, Rtext *));
/*
 * Rtext constructors & destructor
 */
Rtext *plrtstr(Rtext **, int, int, Font *, char *, int, void *);
Rtext *plrtbitmap(Rtext **, int, int, Image *, int, void *);
Rtext *plrtpanel(Rtext **, int, int, Panel *, void *);
void plrtfree(Rtext *);
void plrtseltext(Rtext *, Rtext *, Rtext *);
char *plrtsnarftext(Rtext *);

int plgetpostextview(Panel *);
void plsetpostextview(Panel *, int);

/*
 * Idols
 */
Idol *plmkidol(Idol**, Image*, Image*, char*, void*);
void plfreeidol(Idol*);
Point plidolsize(Idol*, Font*, int);
void *plidollistgetsel(Panel*);

/*
 * Snarf
 */
void plputsnarf(char *);
char *plgetsnarf(void);
void plsnarf(Panel *);			/* snarf a panel */
void plpaste(Panel *);			/* paste a panel */
@


\subsection*{[[windows/libpanel/pldefs.h]]}

<<constant HITME>>=
#define	HITME	0x08000		/* tells ptinpanel not to look at children */
@

<<constant LEAF>>=
#define	LEAF	0x10000		/* newpanel will refuse to attach children */
@

<<constant INVIS>>=
#define	INVIS	0x20000		/* don't draw this */
@

<<constant REMOUSE>>=
#define	REMOUSE	0x40000		/* send next mouse event here, even if not inside */
@

<<enum _anon_ (windows/libpanel/pldefs.h)>>=
/*
 * States, also styles
 */
enum{
    UP,
    DOWN1,
    DOWN2,
    DOWN3,
    DOWN,
    PASSIVE,
    FRAME
};
@

<<enum _anon_ (windows/libpanel/pldefs.h)2>>=
/*
 * Scroll flags
 */
enum{
    SCROLLUP,
    SCROLLDOWN,
    SCROLLABSY,
    SCROLLLEFT,
    SCROLLRIGHT,
    SCROLLABSX,
};
@

<<enum _anon_ (windows/libpanel/pldefs.h)3>>=
/*
 * Scrollbar, slider orientations
 */
enum{
    HORIZ,
    VERT
};
@

<<struct Textwin>>=
struct Textwin{
    Rune *text, *etext, *eslack;	/* text, with some slack off the end */
    int top, bot;			/* range of runes visible on screen */
    int sel0, sel1;			/* selection */
    Point *loc, *eloc;		/* ul corners of visible runes (+1 more at end!) */
    Image *b;			/* bitmap the text is drawn in */
    Rectangle r;			/* rectangle the text is drawn in */
    Font *font;			/* font text is drawn in */
    int hgt;			/* same as font->height */
    int tabstop;			/* tab settings are every tabstop pixels */
    int mintab;			/* the minimum size of a tab */
};
@


%-------------------------------------------------------------

<<windows/libpanel/pldefs.h>>=
/*
 * Definitions for internal use only
 */
/*
 * Variable-font text routines
 * These could make a separate library.
 */
int pl_rtfmt(Rtext *, int);
void pl_rtdraw(Image *, Rectangle, Rtext *, int);
void pl_rtredraw(Image *, Rectangle, Rtext *, int, int);
Rtext *pl_rthit(Rtext *, int, Point, Point);
<<constant HITME>>
<<constant LEAF>>
<<constant INVIS>>
<<constant REMOUSE>>
<<enum _anon_ (windows/libpanel/pldefs.h)>>
<<enum _anon_ (windows/libpanel/pldefs.h)2>>
<<enum _anon_ (windows/libpanel/pldefs.h)3>>
Panel *pl_newpanel(Panel *, int);	/* make a new Panel, given parent & data size */
void *pl_emalloc(int);			/* allocate some space, exit on error */
void *pl_erealloc(void*,int);		/* reallocate some space, exit on error */
void pl_print(Panel *);			/* print a Panel tree */
Panel *pl_ptinpanel(Point, Panel *);	/* highest-priority subpanel containing point */
/*
 * Drawing primitives
 */
int pl_drawinit(int);
Rectangle pl_box(Image *, Rectangle, int);
Rectangle pl_outline(Image *, Rectangle, int);
Point pl_boxsize(Point, int);
void pl_interior(int, Point *, Point *);
void pl_drawicon(Image *, Rectangle, int, int, Icon *);
Rectangle pl_check(Image *, Rectangle, int);
Rectangle pl_radio(Image *, Rectangle, int);
int pl_ckwid(void);
void pl_sliderupd(Image *, Rectangle, int, int, int);
void pl_invis(Panel *, int);
Point pl_iconsize(int, Icon *);
void pl_highlight(Image *, Rectangle);
void pl_clr(Image *, Rectangle);
void pl_fill(Image *, Rectangle);
void pl_cpy(Image *, Point, Rectangle);

/*
 * Rune mangling functions
 */
int pl_idchar(int);
int pl_rune1st(int);
char *pl_nextrune(char *);
int pl_runewidth(Font *, char *);
/*
 * Fixed-font Text-window routines
 * These could be separated out into a separate library.
 */
typedef struct Textwin Textwin;
<<struct Textwin>>
Textwin *twnew(Image *, Font *, Rune *, int);
void twfree(Textwin *);
void twhilite(Textwin *, int, int, int);
void twselect(Textwin *, Mouse *);
void twreplace(Textwin *, int, int, Rune *, int);
void twscroll(Textwin *, int);
int twpt2rune(Textwin *, Point);
void twreshape(Textwin *, Rectangle);
void twmove(Textwin *, Point);
void plemove(Panel *, Point);
@


\subsection*{[[windows/libpanel/popup.c]]}

<<struct Popup>>=
struct Popup{
    Image *save;			/* where to save what the popup covers */
    Panel *pop[3];			/* what to pop up */
};
@

<<function pl_drawpopup>>=
void pl_drawpopup(Panel *p){
    USED(p);
}
@

<<function pl_hitpopup>>=
int pl_hitpopup(Panel *g, Mouse *m){
    Panel *p;
    Point d;
    Popup *pp;

    pp=g->data;
    if(g->state==UP){
        switch(m->buttons&7){
        case 0: p=g->child; break;
        case 1:	p=pp->pop[0]; g->state=DOWN1; break;
        case 2: p=pp->pop[1]; g->state=DOWN2; break;
        case 4: p=pp->pop[2]; g->state=DOWN3; break;
        default: p=0; break;
        }
        if(p==0){
            p=g->child;
            g->state=DOWN;
        }
        else if(g->state!=UP){
            plpack(p, screen->clipr);
            if(p->lastmouse)
                d=subpt(m->xy, divpt(addpt(p->lastmouse->r.min,
                             p->lastmouse->r.max), 2));
            else
                d=subpt(m->xy, divpt(addpt(p->r.min, p->r.max), 2));
            if(p->r.min.x+d.x<g->r.min.x) d.x=g->r.min.x-p->r.min.x;
            if(p->r.max.x+d.x>g->r.max.x) d.x=g->r.max.x-p->r.max.x;
            if(p->r.min.y+d.y<g->r.min.y) d.y=g->r.min.y-p->r.min.y;
            if(p->r.max.y+d.y>g->r.max.y) d.y=g->r.max.y-p->r.max.y;
            plmove(p, d);
            pp->save=allocimage(display, p->r, g->b->chan, 0, DNofill);
            if(pp->save!=0) draw(pp->save, p->r, g->b, 0, p->r.min);
            pl_invis(p, 0);
            pldraw(p, g->b);
        }
    }
    else{
        switch(g->state){
        default: SET(p); break;			/* can't happen! */
        case DOWN1: p=pp->pop[0]; break;
        case DOWN2: p=pp->pop[1]; break;
        case DOWN3: p=pp->pop[2]; break;
        case DOWN:  p=g->child;  break;
        }
        if((m->buttons&7)==0){
            if(g->state!=DOWN){
                if(pp->save!=0){
                    draw(g->b, p->r, pp->save, 0, p->r.min);
                    flushimage(display, 1);
                    freeimage(pp->save);
                    pp->save=0;
                }
                pl_invis(p, 1);
            }
            g->state=UP;
        }
    }
    plmouse(p, m);
    if((m->buttons&7)==0)
        g->state=UP;
    return (m->buttons&7)!=0;
}
@

<<function pl_typepopup>>=
void pl_typepopup(Panel *g, Rune c){
    USED(g, c);
}
@

<<function pl_getsizepopup>>=
Point pl_getsizepopup(Panel *g, Point children){
    USED(g);
    return children;
}
@

<<function pl_childspacepopup>>=
void pl_childspacepopup(Panel *g, Point *ul, Point *size){
    USED(g, ul, size);
}
@

<<function pl_pripopup>>=
int pl_pripopup(Panel *, Point){
    return PRI_POPUP;
}
@

<<function plinitpopup>>=
void plinitpopup(Panel *v, int flags, Panel *pop0, Panel *pop1, Panel *pop2){
    Popup *pp;
    pp=v->data;
    v->flags=flags;
    v->pri=pl_pripopup;
    v->state=UP;
    v->draw=pl_drawpopup;
    v->hit=pl_hitpopup;
    v->type=pl_typepopup;
    v->getsize=pl_getsizepopup;
    v->childspace=pl_childspacepopup;
    pp->pop[0]=pop0;
    pp->pop[1]=pop1;
    pp->pop[2]=pop2;
    pp->save=0;
    v->kind="popup";
}
@

<<function plpopup>>=
Panel *plpopup(Panel *parent, int flags, Panel *pop0, Panel *pop1, Panel *pop2){
    Panel *v;
    v=pl_newpanel(parent, sizeof(Popup));
    plinitpopup(v, flags, pop0, pop1, pop2);
    return v;
}
@


%-------------------------------------------------------------

<<windows/libpanel/popup.c>>=
/*
 * popup
 *	looks like a group, except diverts hits on certain buttons to
 *	panels that it temporarily pops up.
 */
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <event.h>
#include <panel.h>
#include "pldefs.h"
typedef struct Popup Popup;
<<struct Popup>>
<<function pl_drawpopup>>
<<function pl_hitpopup>>
<<function pl_typepopup>>
<<function pl_getsizepopup>>
<<function pl_childspacepopup>>
<<function pl_pripopup>>
<<function plinitpopup>>
<<function plpopup>>
@


\subsection*{[[windows/libpanel/print.c]]}

<<function pl_iprint>>=
void pl_iprint(int indent, char *fmt, ...){
    char buf[8192];
    va_list arg;
    memset(buf, '\t', indent);
    va_start(arg, fmt);
    write(1, buf, vsnprint(buf+indent, sizeof(buf)-indent, fmt, arg));
    va_end(arg);
}
@

<<function pl_ipprint>>=
void pl_ipprint(Panel *p, int n){
    Panel *c;
    char *place, *stick;
    pl_iprint(n, "%s (0x%.8x)\n", p->kind, p);
    pl_iprint(n, "  r=(%d %d, %d %d)\n",
        p->r.min.x, p->r.min.y, p->r.max.x, p->r.max.y);
    switch(p->flags&PACK){
    default: SET(place); break;
    case PACKN: place="n"; break;
    case PACKE: place="e"; break;
    case PACKS: place="s"; break;
    case PACKW: place="w"; break;
    }
    switch(p->flags&PLACE){
    default: SET(stick); break;
    case PLACECEN:	stick=""; break;
    case PLACES:	stick=" stick s"; break;
    case PLACEE:	stick=" stick e"; break;
    case PLACEW:	stick=" stick w"; break;
    case PLACEN:	stick=" stick n"; break;
    case PLACENE:	stick=" stick ne"; break;
    case PLACENW:	stick=" stick nw"; break;
    case PLACESE:	stick=" stick se"; break;
    case PLACESW:	stick=" stick sw"; break;
    }
    pl_iprint(n, "  place %s%s%s%s%s%s\n",
        place,
        p->flags&FILLX?" fill x":"",
        p->flags&FILLY?" fill y":"",
        stick,
        p->flags&EXPAND?" expand":"",
        p->flags&FIXED?" fixed":"");
    if(!eqpt(p->pad, Pt(0, 0))) pl_iprint(n, "  pad=%d,%d)\n", p->pad.x, p->pad.y);
    if(!eqpt(p->ipad, Pt(0, 0))) pl_iprint(n, "  ipad=%d,%d)\n", p->ipad.x, p->ipad.y);
    pl_iprint(n, "  size=(%d,%d), sizereq=(%d,%d)\n",
        p->size.x, p->size.y, p->sizereq.x, p->sizereq.y);
    for(c=p->child;c;c=c->next)
        pl_ipprint(c, n+1);
}
@

<<function pl_print>>=
void pl_print(Panel *p){
    pl_ipprint(p, 0);
}
@


%-------------------------------------------------------------

<<windows/libpanel/print.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <event.h>
#include <panel.h>
#include "pldefs.h"
<<function pl_iprint>>
<<function pl_ipprint>>
<<function pl_print>>
@


\subsection*{[[windows/libpanel/pulldown.c]]}

<<struct Pulldown>>=
struct Pulldown{
    Icon *icon;		/* button label */
    Panel *pull;		/* Panel to pull down */
    int side;		/* which side of the button to put the panel on */
    Image *save;		/* where to save what we draw the panel on */
};
@

<<function pl_drawpulldown>>=
void pl_drawpulldown(Panel *p){
    pl_drawicon(p->b, pl_box(p->b, p->r, p->state), PLACECEN,
        p->flags, ((Pulldown *)p->data)->icon);
}
@

<<function pl_hitpulldown>>=
int pl_hitpulldown(Panel *g, Mouse *m){
    int oldstate, passon;
    Rectangle r;
    Panel *p, *hitme;
    Pulldown *pp;
    pp=g->data;
    oldstate=g->state;
    p=pp->pull;
    hitme=0;
    switch(g->state){
    case UP:
        if(!ptinrect(m->xy, g->r))
            g->state=UP;
        else if(m->buttons&7){
            r=g->b->r;
            p->flags&=~PLACE;
            switch(pp->side){
            case PACKN:
                r.min.x=g->r.min.x;
                r.max.y=g->r.min.y;
                p->flags|=PLACESW;
                break;
            case PACKS:
                r.min.x=g->r.min.x;
                r.min.y=g->r.max.y;
                p->flags|=PLACENW;
                break;
            case PACKE:
                r.min.x=g->r.max.x;
                r.min.y=g->r.min.y;
                p->flags|=PLACENW;
                break;
            case PACKW:
                r.max.x=g->r.min.x;
                r.min.y=g->r.min.y;
                p->flags|=PLACENE;
                break;
            case PACKCEN:
                r.min=g->r.min;
                p->flags|=PLACENW;
                break;
            }
            plpack(p, r);
            pp->save=allocimage(display, p->r, g->b->chan, 0, DNofill);
            if(pp->save!=0) draw(pp->save, p->r, g->b, 0, p->r.min);
            pl_invis(p, 0);
            pldraw(p, g->b);
            g->state=DOWN;
        }
        break;
    case DOWN:
        if(!ptinrect(m->xy, g->r)){
            switch(pp->side){
            default: SET(passon); break;		/* doesn't happen */
            case PACKN: passon=m->xy.y<g->r.min.y; break;
            case PACKS: passon=m->xy.y>=g->r.max.y; break;
            case PACKE: passon=m->xy.x>=g->r.max.x; break;
            case PACKW: passon=m->xy.x<g->r.min.x; break;
            case PACKCEN: passon=1; break;
            }
            if(passon){
                hitme=p;
                if((m->buttons&7)==0) g->state=UP;
            }
            else	g->state=UP;
        }
        else if((m->buttons&7)==0) g->state=UP;
        else hitme=p;
        if(g->state!=DOWN && pp->save){
            draw(g->b, p->r, pp->save, 0, p->r.min);
            freeimage(pp->save);
            pp->save=0;
            pl_invis(p, 1);
            hitme=p;
        }
    }
    if(g->state!=oldstate) pldraw(g, g->b);
    if(hitme) plmouse(hitme, m);
    return g->state==DOWN;
}
@

<<function pl_typepulldown>>=
void pl_typepulldown(Panel *p, Rune c){
    USED(p, c);
}
@

<<function pl_getsizepulldown>>=
Point pl_getsizepulldown(Panel *p, Point children){
    USED(p, children);
    return pl_boxsize(pl_iconsize(p->flags, ((Pulldown *)p->data)->icon), p->state);
}
@

<<function pl_childspacepulldown>>=
void pl_childspacepulldown(Panel *p, Point *ul, Point *size){
    USED(p, ul, size);
}
@

<<function plinitpulldown>>=
void plinitpulldown(Panel *v, int flags, Icon *icon, Panel *pullthis, int side){
    Pulldown *pp;
    pp=v->data;
    v->flags=flags|LEAF;
    v->draw=pl_drawpulldown;
    v->hit=pl_hitpulldown;
    v->type=pl_typepulldown;
    v->getsize=pl_getsizepulldown;
    v->childspace=pl_childspacepulldown;
    pp->pull=pullthis;
    pp->side=side;
    pp->icon=icon;
    v->kind="pulldown";
}
@

<<function plpulldown>>=
Panel *plpulldown(Panel *parent, int flags, Icon *icon, Panel *pullthis, int side){
    Panel *v;
    v=pl_newpanel(parent, sizeof(Pulldown));
    v->state=UP;
    ((Pulldown *)v->data)->save=0;
    plinitpulldown(v, flags, icon, pullthis, side);
    return v;
}
@

<<function plmenubar>>=
Panel *plmenubar(Panel *parent, int flags, int cflags, Icon *l1, Panel *m1, Icon *l2, ...){
    Panel *v;
    va_list arg;
    Icon *s;
    int pulldir;
    switch(cflags&PACK){
    default:
        SET(pulldir);
        break;
    case PACKE:
    case PACKW:
        pulldir=PACKS;
        break;
    case PACKN:
    case PACKS:
        pulldir=PACKE;
        break;
    }
    v=plgroup(parent, flags);
    va_start(arg, cflags);
    while((s=va_arg(arg, Icon *))!=0)
        plpulldown(v, cflags, s, va_arg(arg, Panel *), pulldir);
    va_end(arg);
    USED(l1, m1, l2);
    v->kind="menubar";
    return v;
}
@


%-------------------------------------------------------------

<<windows/libpanel/pulldown.c>>=
/*
 * pulldown
 *	makes a button that pops up a panel when hit
 */
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <event.h>
#include <panel.h>
#include "pldefs.h"
typedef struct Pulldown Pulldown;
<<struct Pulldown>>
<<function pl_drawpulldown>>
<<function pl_hitpulldown>>
<<function pl_typepulldown>>
<<function pl_getsizepulldown>>
<<function pl_childspacepulldown>>
<<function plinitpulldown>>
<<function plpulldown>>
<<function plmenubar>>
@


\subsection*{[[windows/libpanel/rtext.c]]}

<<constant LEAD>>=
#define LEAD	4	/* extra space between lines */
@

<<constant BORD>>=
#define BORD	2	/* extra border for images */
@

<<function pl_rtnew>>=
Rtext *pl_rtnew(Rtext **t, int space, int indent, Image *b, Panel *p, Font *f, char *s, int flags, void *user){
    Rtext *new;
    new=pl_emalloc(sizeof(Rtext));
    new->flags=flags;
    new->user=user;
    new->space=space;
    new->indent=indent;
    new->b=b;
    new->p=p;
    new->font=f;
    new->text=s;
    new->next=0;
    new->nextline=0;
    new->r=Rect(0,0,0,0);
    if(*t)
        (*t)->last->next=new;
    else
        *t=new;
    (*t)->last=new;
    return new;
}
@

<<function plrtpanel>>=
Rtext *plrtpanel(Rtext **t, int space, int indent, Panel *p, void *user){
    return pl_rtnew(t, space, indent, 0, p, 0, 0, 1, user);
}
@

<<function plrtstr>>=
Rtext *plrtstr(Rtext **t, int space, int indent, Font *f, char *s, int flags, void *user){
    return pl_rtnew(t, space, indent, 0, 0, f, s, flags, user);
}
@

<<function plrtbitmap>>=
Rtext *plrtbitmap(Rtext **t, int space, int indent, Image *b, int flags, void *user){
    return pl_rtnew(t, space, indent, b, 0, 0, 0, flags, user);
}
@

<<function plrtfree>>=
void plrtfree(Rtext *t){
    Rtext *next;
    while(t){
        next=t->next;
        free(t);
        t=next;
    }
}
@

<<function pltabsize>>=
void pltabsize(int min, int size){
    pl_tabmin=min;
    pl_tabsize=size;
}
@

<<function pl_space>>=
int pl_space(int space, int pos, int indent){
    if(space>=0) return space;
    switch(PL_OP(space)){
    default:
        return 0;
    case PL_TAB:
        return ((pos-indent+pl_tabmin)/pl_tabsize+PL_ARG(space))*pl_tabsize+indent-pos;
    }
}
@

<<function pl_rtfmt>>=
/*
 * initialize rectangles & nextlines of text starting at t,
 * galley width is wid.  Returns the total length of the text
 */
int pl_rtfmt(Rtext *t, int wid){
    Rtext *tp, *eline;
    int ascent, descent, x, space, a, d, w, topy, indent;
    Point p;
    p=Pt(0,0);
    eline=t;
    while(t){
        ascent=0;
        descent=0;
        indent=space=pl_space(t->indent, 0, 0);
        x=0;
        tp=t;
        for(;;){
            if(tp->b){
                a=tp->b->r.max.y-tp->b->r.min.y+BORD;
                d=BORD;
                w=tp->b->r.max.x-tp->b->r.min.x+BORD*2;
            }
            else if(tp->p){
                /* what if plpack fails? */
                plpack(tp->p, Rect(0,0,wid,wid));
                plmove(tp->p, subpt(Pt(0,0), tp->p->r.min));
                a=tp->p->r.max.y-tp->p->r.min.y;
                d=0;
                w=tp->p->r.max.x-tp->p->r.min.x;
            }
            else{
                a=tp->font->ascent;
                d=tp->font->height-a;
                w=tp->wid=stringwidth(tp->font, tp->text);
            }
            if(x+w+space>wid) break;
            if(a>ascent) ascent=a;
            if(d>descent) descent=d;
            x+=w+space;
            tp=tp->next;
            if(tp==0){
                eline=0;
                break;
            }
            space=pl_space(tp->space, x, indent);
            if(space) eline=tp;
        }
        if(eline==t){	/* No progress!  Force fit the first block! */
            if(tp==t){
                if(a>ascent) ascent=a;
                if(d>descent) descent=d;
                eline=tp->next;
            }else
                eline=tp;
        }
        topy=p.y;
        p.y+=ascent;
        p.x=indent=pl_space(t->indent, 0, 0);
        for(;;){
            t->topy=topy;
            t->r.min.x=p.x;
            if(t->b){
                t->r.max.y=p.y+BORD;
                t->r.min.y=p.y-(t->b->r.max.y-t->b->r.min.y)-BORD;
                p.x+=(t->b->r.max.x-t->b->r.min.x)+BORD*2;
            }
            else if(t->p){
                t->r.max.y=p.y;
                t->r.min.y=p.y-t->p->r.max.y;
                p.x+=t->p->r.max.x;
            }
            else{
                t->r.min.y=p.y-t->font->ascent;
                t->r.max.y=t->r.min.y+t->font->height;
                p.x+=t->wid;
            }
            t->r.max.x=p.x;
            t->nextline=eline;
            t=t->next;
            if(t==eline) break;
            p.x+=pl_space(t->space, p.x, indent);
        }
        p.y+=descent+LEAD;
    }
    return p.y;
}
@

<<function pl_stuffbitmap>>=
/*
 * If we draw the text in a backup bitmap and copy it onto the screen,
 * the bitmap pointers in all the subpanels point to the wrong bitmap.
 * This code fixes them.
 */
void pl_stuffbitmap(Panel *p, Image *b){
    p->b=b;
    for(p=p->child;p;p=p->next)
        pl_stuffbitmap(p, b);
}
@

<<function pl_rtdraw>>=
void pl_rtdraw(Image *b, Rectangle r, Rtext *t, int yoffs){
    static Image *backup;
    Point offs, lp;
    Rectangle dr;
    Image *bb;

    bb = b;
    if(backup==0 || backup->chan!=b->chan || rectinrect(r, backup->r)==0){
        freeimage(backup);
        backup=allocimage(display, bb->r, bb->chan, 0, DNofill);
    }
    if(backup)
        b=backup;
    pl_clr(b, r);
    lp=ZP;
    offs=subpt(r.min, Pt(0, yoffs));
    for(;t;t=t->next) if(!eqrect(t->r, Rect(0,0,0,0))){
        dr=rectaddpt(t->r, offs);
        if(dr.max.y>r.min.y
        && dr.min.y<r.max.y){
            if(t->b){
                draw(b, insetrect(dr, BORD), t->b, 0, t->b->r.min);
                if(t->flags&PL_HOT) border(b, dr, 1, display->black, ZP);
                if(t->flags&PL_SEL)
                    pl_highlight(b, dr);
            }
            else if(t->p){
                plmove(t->p, subpt(dr.min, t->p->r.min));
                pldraw(t->p, b);
                if(b!=bb)
                    pl_stuffbitmap(t->p, bb);
            }
            else{
                string(b, dr.min, display->black, ZP, t->font, t->text);
                if(t->flags&PL_SEL)
                    pl_highlight(b, dr);
                if(t->flags&PL_HOT){
                    if(lp.y+1 != dr.max.y)
                        lp = Pt(dr.min.x, dr.max.y-1);
                    line(b, lp, Pt(dr.max.x, dr.max.y-1),
                        Endsquare, Endsquare, 0,
                        display->black, ZP);
                    lp = Pt(dr.max.x, dr.max.y-1);
                    continue;
                }
            }
            lp=ZP;
        }
    }
    if(b!=bb)
        draw(bb, r, b, 0, r.min);
}
@

<<function pl_reposition>>=
/*
 * Reposition text already drawn in the window.
 * We just move the pixels and update the positions of any
 * enclosed panels
 */
void pl_reposition(Rtext *t, Image *b, Point p, Rectangle r){
    Point offs;
    pl_cpy(b, p, r);
    offs=subpt(p, r.min);
    for(;t;t=t->next)
        if(!eqrect(t->r, Rect(0,0,0,0)) && !t->b && t->p)
            plmove(t->p, offs);
}
@

<<function pl_rtredraw>>=
/*
 * Rectangle r of Image b contains an image of Rtext t, offset by oldoffs.
 * Redraw the text to have offset yoffs.
 */
void pl_rtredraw(Image *b, Rectangle r, Rtext *t, int yoffs, int oldoffs){
    int dy, size;
    dy=oldoffs-yoffs;
    size=r.max.y-r.min.y;
    if(dy>=size || -dy>=size)
        pl_rtdraw(b, r, t, yoffs);
    else if(dy<0){
        pl_reposition(t, b, r.min,
            Rect(r.min.x, r.min.y-dy, r.max.x, r.max.y));
        pl_rtdraw(b, Rect(r.min.x, r.max.y+dy, r.max.x, r.max.y),
            t, yoffs+size+dy);
    }
    else if(dy>0){
        pl_reposition(t, b, Pt(r.min.x, r.min.y+dy),
            Rect(r.min.x, r.min.y, r.max.x, r.max.y-dy));
        pl_rtdraw(b, Rect(r.min.x, r.min.y, r.max.x, r.min.y+dy), t, yoffs);
    }
}
@

<<function pl_rthit>>=
Rtext *pl_rthit(Rtext *t, int yoffs, Point p, Point ul){
    Rectangle r;
    Point lp;
    if(t==0) return 0;
    p.x-=ul.x;
    p.y+=yoffs-ul.y;
    while(t->nextline && t->nextline->topy<=p.y) t=t->nextline;
    lp=ZP;
    for(;t!=0;t=t->next){
        if(t->topy>p.y) return 0;
        r = t->r;
        if((t->flags&PL_HOT) != 0 && t->b == nil && t->p == nil){
            if(lp.y == r.max.y && lp.x < r.min.x)
                r.min.x=lp.x;
            lp=r.max;
        } else
            lp=ZP;
        if(ptinrect(p, r)) return t;
    }
    return 0;
}
@

<<function plrtseltext>>=
void plrtseltext(Rtext *t, Rtext *s, Rtext *e){
    while(t){
        t->flags &= ~PL_SEL;
        t = t->next;
    }
    if(s==0 || e==0)
        return;
    for(t=s; t!=0 && t!=e; t=t->next)
        ;
    if(t==e){
        for(t=s; t!=e; t=t->next)
            t->flags |= PL_SEL;
    }else{
        for(t=e; t!=s; t=t->next)
            t->flags |= PL_SEL;
    }
    t->flags |= PL_SEL;
}
@

<<function plrtsnarftext>>=
char *plrtsnarftext(Rtext *w){
    char *b, *p, *e, *t;
    int n;

    b=p=e=0;
    for(; w; w = w->next){
        if((w->flags&PL_SEL)==0 || w->text==0)
            continue;
        n = strlen(w->text)+64;
        if(p+n >= e){
            n = (p+n+64)-b;
            t = pl_erealloc(b, n);
            p = t+(p-b);
            e = t+n;
            b = t;
        }
        if(w->space == 0)
            p += sprint(p, "%s", w->text);
        else if(w->space > 0)
            p += sprint(p, " %s", w->text);
        else if(PL_OP(w->space) == PL_TAB)
            p += sprint(p, "\t%s", w->text);
        if(w->nextline == w->next)
            p += sprint(p, "\n");
    }
    return b;
}
@


%-------------------------------------------------------------

<<windows/libpanel/rtext.c>>=
/*
 * Rich text with images.
 * Should there be an offset field, to do subscripts & kerning?
 */
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <event.h>
#include <panel.h>
#include "pldefs.h"
#include "rtext.h"

<<constant LEAD>>
<<constant BORD>>

<<function pl_rtnew>>
<<function plrtpanel>>
<<function plrtstr>>
<<function plrtbitmap>>
<<function plrtfree>>
int pl_tabmin, pl_tabsize;
<<function pltabsize>>
<<function pl_space>>
<<function pl_rtfmt>>

<<function pl_stuffbitmap>>

<<function pl_rtdraw>>
<<function pl_reposition>>
<<function pl_rtredraw>>
<<function pl_rthit>>

<<function plrtseltext>>

<<function plrtsnarftext>>
@


\subsection*{[[windows/libpanel/rtext.h]]}

<<constant PL_NOPBIT>>=
/*
 * Rtext definitions
 */
#define	PL_NOPBIT	4
@

<<constant PL_NARGBIT>>=
#define	PL_NARGBIT	12
@

<<constant PL_ARGMASK>>=
#define	PL_ARGMASK	((1<<PL_NARGBIT)-1)
@

<<function PL_SPECIAL>>=
#define	PL_SPECIAL(op)	(((-1<<PL_NOPBIT)|op)<<PL_NARGBIT)
@

<<function PL_OP>>=
#define	PL_OP(t)	((t)&~PL_ARGMASK)
@

<<function PL_ARG>>=
#define	PL_ARG(t)	((t)&PL_ARGMASK)
@

<<constant PL_TAB>>=
#define	PL_TAB		PL_SPECIAL(0)		/* # of tab stops before text */
@


%-------------------------------------------------------------

<<windows/libpanel/rtext.h>>=
<<constant PL_NOPBIT>>
<<constant PL_NARGBIT>>
<<constant PL_ARGMASK>>
<<function PL_SPECIAL>>
<<function PL_OP>>
<<function PL_ARG>>
<<constant PL_TAB>>
void pltabsize(int, int);			/* set min tab and tab size */
@


\subsection*{[[windows/libpanel/scroll.c]]}

<<function plscroll>>=
void plscroll(Panel *scrollee, Panel *xscroller, Panel *yscroller){
    scrollee->xscroller=xscroller;
    scrollee->yscroller=yscroller;
    if(xscroller) xscroller->scrollee=scrollee;
    if(yscroller) yscroller->scrollee=scrollee;
}
@

<<function plgetscroll>>=
Scroll plgetscroll(Panel *p){
    return p->scr;
}
@

<<function plsetscroll>>=
void plsetscroll(Panel *p, Scroll s){
    if(p->scroll){
        if(s.size.x) p->scroll(p, HORIZ, 2, s.pos.x, s.size.x);
        if(s.size.y) p->scroll(p, VERT, 2, s.pos.y, s.size.y);
    }
}
@


%-------------------------------------------------------------

<<windows/libpanel/scroll.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <event.h>
#include <panel.h>
#include "pldefs.h"
<<function plscroll>>
<<function plgetscroll>>
<<function plsetscroll>>
@


\subsection*{[[windows/libpanel/scrollbar.c]]}

<<struct Scrollbar>>=
struct Scrollbar{
    int dir;		/* HORIZ or VERT */
    int lo, hi;		/* setting, in screen coordinates */
    int buttons;		/* saved mouse buttons for transmittal to scrollee */
    Rectangle interior;
    Point minsize;
};
@

<<constant SBWID>>=
#define	SBWID	15	/* should come from draw.c? */
@

<<function pl_drawscrollbar>>=
void pl_drawscrollbar(Panel *p){
    Scrollbar *sp;
    sp=p->data;
    sp->interior=pl_outline(p->b, p->r, p->state);
    pl_sliderupd(p->b, sp->interior, sp->dir, sp->lo, sp->hi);
}
@

<<function pl_hitscrollbar>>=
int pl_hitscrollbar(Panel *g, Mouse *m){
    int oldstate, pos, len, dy;
    Point ul, size;
    Scrollbar *sp;
    sp=g->data;
    ul=g->r.min;
    size=subpt(g->r.max, g->r.min);
    pl_interior(g->state, &ul, &size);
    oldstate=g->state;
    if(!(g->flags & USERFL) && (m->buttons&OUT || !ptinrect(m->xy, g->r))){
        m->buttons&=~OUT;
        g->state=UP;
        goto out;
    }
    if(sp->dir==HORIZ){
        pos=m->xy.x-ul.x;
        len=size.x;
    }
    else{
        pos=m->xy.y-ul.y;
        len=size.y;
    }
    if(pos<0) pos=0;
    else if(pos>len) pos=len;
    if(m->buttons&7){
        g->state=DOWN;
        sp->buttons=m->buttons;
        switch(m->buttons){
        case 1:
            dy=pos*(sp->hi-sp->lo)/len;
            pl_sliderupd(g->b, sp->interior, sp->dir, sp->lo-dy,
                sp->hi-dy);
            break;
        case 2:
            if(g->scrollee && g->scrollee->scroll)
                g->scrollee->scroll(g->scrollee, sp->dir,
                    m->buttons, pos, len);
            break;
        case 4:
            dy=pos*(sp->hi-sp->lo)/len;
            pl_sliderupd(g->b, sp->interior, sp->dir, sp->lo+dy,
                sp->hi+dy);
            break;
        }
    }
    else{
        if(!(sp->buttons&2) && g->state==DOWN && g->scrollee && g->scrollee->scroll)
            g->scrollee->scroll(g->scrollee, sp->dir, sp->buttons,
                pos, len);
        g->state=UP;
    }
out:
    if(oldstate!=g->state) pldraw(g, g->b);
    return g->state==DOWN;
}
@

<<function pl_typescrollbar>>=
void pl_typescrollbar(Panel *p, Rune c){
    USED(p, c);
}
@

<<function pl_getsizescrollbar>>=
Point pl_getsizescrollbar(Panel *p, Point children){
    USED(children);
    return pl_boxsize(((Scrollbar *)p->data)->minsize, p->state);
}
@

<<function pl_childspacescrollbar>>=
void pl_childspacescrollbar(Panel *p, Point *ul, Point *size){
    USED(p, ul, size);
}
@

<<function pl_setscrollbarscrollbar>>=
/*
 * Arguments lo, hi and len are in the scrollee's natural coordinates
 */
void pl_setscrollbarscrollbar(Panel *p, int lo, int hi, int len){
    Point ul, size;
    int mylen;
    Scrollbar *sp;
    sp=p->data;
    ul=p->r.min;
    size=subpt(p->r.max, p->r.min);
    pl_interior(p->state, &ul, &size);
    mylen=sp->dir==HORIZ?size.x:size.y;
    if(len==0) len=1;
    sp->lo=lo*mylen/len;
    sp->hi=hi*mylen/len;
    if(sp->lo<0) sp->lo=0;
    if(sp->lo>=mylen) sp->hi=mylen-1;
    if(sp->hi<=sp->lo) sp->hi=sp->lo+1;
    if(sp->hi>mylen) sp->hi=mylen;
    pldraw(p, p->b);
}
@

<<function pl_priscrollbar>>=
int pl_priscrollbar(Panel *, Point){
    return PRI_SCROLLBAR;
}
@

<<function plinitscrollbar>>=
void plinitscrollbar(Panel *v, int flags){
    Scrollbar *sp;
    sp=v->data;
    v->flags=flags|LEAF;
    v->pri=pl_priscrollbar;
    v->state=UP;
    v->draw=pl_drawscrollbar;
    v->hit=pl_hitscrollbar;
    v->type=pl_typescrollbar;
    v->getsize=pl_getsizescrollbar;
    v->childspace=pl_childspacescrollbar;
    v->setscrollbar=pl_setscrollbarscrollbar;
    switch(flags&PACK){
    case PACKN:
    case PACKS:
        sp->dir=HORIZ;
        sp->minsize=Pt(0, SBWID);
        v->flags|=FILLX;
        break;
    case PACKE:
    case PACKW:
        sp->dir=VERT;
        sp->minsize=Pt(SBWID, 0);
        v->flags|=FILLY;
        break;
    }
    sp->lo=0;
    sp->hi=0;
    v->kind="scrollbar";
}
@

<<function plscrollbar>>=
Panel *plscrollbar(Panel *parent, int flags){
    Panel *v;
    v=pl_newpanel(parent, sizeof(Scrollbar));
    plinitscrollbar(v, flags);
    return v;
}
@


%-------------------------------------------------------------

<<windows/libpanel/scrollbar.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <event.h>
#include <panel.h>
#include "pldefs.h"
typedef struct Scrollbar Scrollbar;
<<struct Scrollbar>>
<<constant SBWID>>
<<function pl_drawscrollbar>>
<<function pl_hitscrollbar>>
<<function pl_typescrollbar>>
<<function pl_getsizescrollbar>>
<<function pl_childspacescrollbar>>
<<function pl_setscrollbarscrollbar>>
<<function pl_priscrollbar>>
<<function plinitscrollbar>>
<<function plscrollbar>>
@


\subsection*{[[windows/libpanel/slider.c]]}

<<struct Slider>>=
struct Slider{
    int dir;			/* HORIZ or VERT */
    int val;			/* setting, in screen coordinates */
    Point minsize;
    void (*hit)(Panel *, int, int, int);	/* call back to user when slider changes */
    int buttons;
};
@

<<function pl_drawslider>>=
void pl_drawslider(Panel *p){
    Rectangle r;
    Slider *sp;
    sp=p->data;
    r=pl_box(p->b, p->r, UP);
    switch(sp->dir){
    case HORIZ: pl_sliderupd(p->b, r, sp->dir, 0, sp->val); break;
    case VERT:  pl_sliderupd(p->b, r, sp->dir, r.max.y-sp->val, r.max.y); break;
    }
}
@

<<function pl_hitslider>>=
int pl_hitslider(Panel *p, Mouse *m){
    int oldstate, oldval, len;
    Point ul, size;
    Slider *sp;
    sp=p->data;
    ul=p->r.min;
    size=subpt(p->r.max, p->r.min);
    pl_interior(p->state, &ul, &size);
    oldstate=p->state;
    oldval=sp->val;
    SET(len);
    if(m->buttons&OUT)
        p->state=UP;
    else if(m->buttons&7){
        p->state=DOWN;
        sp->buttons=m->buttons;
        if(sp->dir==HORIZ){
            sp->val=m->xy.x-ul.x;
            len=size.x;
        }
        else{
            sp->val=ul.y+size.y-m->xy.y;
            len=size.y;
        }
        if(sp->val<0) sp->val=0;
        else if(sp->val>len) sp->val=len;
    }
    else	/* mouse inside, but no buttons down */
        p->state=UP;
    if(oldval!=sp->val || oldstate!=p->state) pldraw(p, p->b);
    if(oldval!=sp->val && sp->hit) sp->hit(p, sp->buttons, sp->val, len);
    return 0;
}
@

<<function pl_typeslider>>=
void pl_typeslider(Panel *p, Rune c){
    USED(p, c);
}
@

<<function pl_getsizeslider>>=
Point pl_getsizeslider(Panel *p, Point children){
    USED(children);
    return pl_boxsize(((Slider *)p->data)->minsize, p->state);
}
@

<<function pl_childspaceslider>>=
void pl_childspaceslider(Panel *g, Point *ul, Point *size){
    USED(g, ul, size);
}
@

<<function plinitslider>>=
void plinitslider(Panel *v, int flags, Point size, void (*hit)(Panel *, int, int, int)){
    Slider *sp;
    sp=v->data;
    v->r=Rect(0,0,size.x,size.y);
    v->flags=flags|LEAF;
    v->state=UP;
    v->draw=pl_drawslider;
    v->hit=pl_hitslider;
    v->type=pl_typeslider;
    v->getsize=pl_getsizeslider;
    v->childspace=pl_childspaceslider;
    sp->minsize=size;
    sp->dir=size.x>size.y?HORIZ:VERT;
    sp->hit=hit;
    v->kind="slider";
}
@

<<function plslider>>=
Panel *plslider(Panel *parent, int flags, Point size, void (*hit)(Panel *, int, int, int)){
    Panel *p;
    p=pl_newpanel(parent, sizeof(Slider));
    plinitslider(p, flags, size, hit);
    return p;
}
@

<<function plsetslider>>=
void plsetslider(Panel *p, int value, int range){
    Slider *sp;
    sp=p->data;
    if(value<0) value=0;
    else if(value>range) value=range;
    if(sp->dir==HORIZ) sp->val=value*(p->r.max.x-p->r.min.x)/range;
    else sp->val=value*(p->r.max.y-p->r.min.y)/range;
}
@


%-------------------------------------------------------------

<<windows/libpanel/slider.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <event.h>
#include <panel.h>
#include "pldefs.h"
typedef struct Slider Slider;
<<struct Slider>>
<<function pl_drawslider>>
<<function pl_hitslider>>
<<function pl_typeslider>>
<<function pl_getsizeslider>>
<<function pl_childspaceslider>>
<<function plinitslider>>
<<function plslider>>
<<function plsetslider>>
@


\subsection*{[[windows/libpanel/snarf.c]]}

<<function plputsnarf>>=
void plputsnarf(char *s){
    int fd;

    if(s==0 || *s=='\0')
        return;
    if((fd=open("/dev/snarf", OWRITE|OTRUNC))>=0){
        write(fd, s, strlen(s));
        close(fd);
    }
}
@

<<function plgetsnarf>>=
char *plgetsnarf(void){
    int fd, n, r;
    char *s;

    if((fd=open("/dev/snarf", OREAD))<0)
        return nil;
    n=0;
    s=nil;
    for(;;){
        s=pl_erealloc(s, n+1024);
        if((r = read(fd, s+n, 1024)) <= 0)
            break;
        n += r;
    }
    close(fd);
    if(n <= 0){
        free(s);
        return nil;
    }
    s[n] = '\0';
    return s;
}
@

<<function plsnarf>>=
void plsnarf(Panel *p){
    char *s;

    if(p==0 || p->snarf==0)
        return;
    s=p->snarf(p);
    plputsnarf(s);
    free(s);
}
@

<<function plpaste>>=
void plpaste(Panel *p){
    char *s;

    if(p==0 || p->paste==0)
        return;
    if(s=plgetsnarf()){
        p->paste(p, s);
        free(s);
    }
}
@


%-------------------------------------------------------------

<<windows/libpanel/snarf.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <event.h>
#include <panel.h>
#include "pldefs.h"

<<function plputsnarf>>
<<function plgetsnarf>>
<<function plsnarf>>
<<function plpaste>>
@


\subsection*{[[windows/libpanel/textview.c]]}

<<struct Textview>>=
struct Textview{
    void (*hit)(Panel *, int, Rtext *); /* call back to user on hit */
    Rtext *text;			/* text */
    int yoffs;			/* offset of top of screen */
    Rtext *hitword;			/* text to hilite */
    Rtext *hitfirst;		/* first word in range select */
    int twid;			/* text width */
    int thgt;			/* text height */
    Point minsize;			/* smallest acceptible window size */
    int buttons;
};
@

<<function pl_setscrpos>>=
void pl_setscrpos(Panel *p, Textview *tp, Rectangle r){
    Panel *sb;
    int lo, hi;
    lo=tp->yoffs;
    hi=lo+r.max.y-r.min.y;	/* wrong? */
    sb=p->yscroller;
    if(sb && sb->setscrollbar) sb->setscrollbar(sb, lo, hi, tp->thgt);
}
@

<<function pl_drawtextview>>=
void pl_drawtextview(Panel *p){
    int twid;
    Rectangle r;
    Textview *tp;
    tp=p->data;
    r=pl_outline(p->b, p->r, UP);
    twid=r.max.x-r.min.x;
    if(twid!=tp->twid){
        tp->twid=twid;
        tp->thgt=pl_rtfmt(tp->text, tp->twid);
        p->scr.size.y=tp->thgt;
    }
    p->scr.pos.y=tp->yoffs;
    pl_rtdraw(p->b, r, tp->text, tp->yoffs);
    pl_setscrpos(p, tp, r);
}
@

<<function pl_passon>>=
/*
 * If t is a panel word, pass the mouse event on to it
 */
void pl_passon(Rtext *t, Mouse *m){
    if(t && t->b==0 && t->p!=0)
        plmouse(t->p, m);
}
@

<<function pl_hittextview>>=
int pl_hittextview(Panel *p, Mouse *m){
    Rtext *oldhitword, *oldhitfirst;
    int hitme, oldstate;
    Point ul, size;
    Textview *tp;

    tp=p->data;

    hitme=0;
    oldstate=p->state;
    oldhitword=tp->hitword;
    oldhitfirst=tp->hitfirst;
    if(oldhitword==oldhitfirst)
        pl_passon(oldhitword, m);
    if(m->buttons&OUT)
        p->state=UP;
    else if(m->buttons&7){
        p->state=DOWN;
        tp->buttons=m->buttons;
        if(oldhitword==0 || oldhitword->p==0 || (oldhitword->p->flags&REMOUSE)==0){
            ul=p->r.min;
            size=subpt(p->r.max, p->r.min);
            pl_interior(p->state, &ul, &size);
            tp->hitword=pl_rthit(tp->text, tp->yoffs, m->xy, ul);
            if(tp->hitword==0)
                if(oldhitword!=0 && oldstate==DOWN)
                    tp->hitword=oldhitword;
                else
                    tp->hitfirst=0;
            if(tp->hitword!=0 && oldstate!=DOWN)
                tp->hitfirst=tp->hitword;
        }
    }
    else{
        if(p->state==DOWN) hitme=1;
        p->state=UP;
    }
    if(tp->hitfirst!=oldhitfirst || tp->hitword!=oldhitword){
        plrtseltext(tp->text, tp->hitword, tp->hitfirst);
        pl_drawtextview(p);
        if(tp->hitword==tp->hitfirst)
            pl_passon(tp->hitword, m);
    }
    if(hitme && tp->hit && tp->hitword!=0 && tp->hitword==tp->hitfirst){
        plrtseltext(tp->text, 0, 0);
        pl_drawtextview(p);
        tp->hit(p, tp->buttons, tp->hitword);
        tp->hitword=0;
        tp->hitfirst=0;
    }
    return 0;
}
@

<<function pl_scrolltextview>>=
void pl_scrolltextview(Panel *p, int dir, int buttons, int num, int den){
    int yoffs;
    Point ul, size;
    Textview *tp;
    Rectangle r;
    if(dir!=VERT) return;

    tp=p->data;
    ul=p->r.min;
    size=subpt(p->r.max, p->r.min);
    pl_interior(p->state, &ul, &size);
    switch(buttons){
    default:
        SET(yoffs);
        break;
    case 1:		/* left -- top moves to pointer */
        yoffs=(vlong)tp->yoffs-num*size.y/den;
        if(yoffs<0) yoffs=0;
        break;
    case 2:		/* middle -- absolute index of file */
        yoffs=(vlong)tp->thgt*num/den;
        break;
    case 4:		/* right -- line pointed at moves to top */
        yoffs=tp->yoffs+(vlong)num*size.y/den;
        if(yoffs>tp->thgt) yoffs=tp->thgt;
        break;
    }
    if(yoffs!=tp->yoffs){
        r=pl_outline(p->b, p->r, p->state);
        pl_rtredraw(p->b, r, tp->text, yoffs, tp->yoffs);
        p->scr.pos.y=tp->yoffs=yoffs;
        pl_setscrpos(p, tp, r);
    }
}
@

<<function pl_typetextview>>=
void pl_typetextview(Panel *g, Rune c){
    USED(g, c);
}
@

<<function pl_getsizetextview>>=
Point pl_getsizetextview(Panel *p, Point children){
    USED(children);
    return pl_boxsize(((Textview *)p->data)->minsize, p->state);
}
@

<<function pl_childspacetextview>>=
void pl_childspacetextview(Panel *g, Point *ul, Point *size){
    USED(g, ul, size);
}
@

<<function pl_pritextview>>=
/*
 * Priority depends on what thing inside the panel we're pointing at.
 */
int pl_pritextview(Panel *p, Point xy){
    Point ul, size;
    Textview *tp;
    Rtext *h;
    tp=p->data;
    ul=p->r.min;
    size=subpt(p->r.max, p->r.min);
    pl_interior(p->state, &ul, &size);
    h=pl_rthit(tp->text, tp->yoffs, xy, ul);
    if(h && h->b==0 && h->p!=0){
        p=pl_ptinpanel(xy, h->p);
        if(p) return p->pri(p, xy);
    }
    return PRI_NORMAL;
}
@

<<function pl_snarftextview>>=
char* pl_snarftextview(Panel *p){
    return plrtsnarftext(((Textview *)p->data)->text);
}
@

<<function plinittextview>>=
void plinittextview(Panel *v, int flags, Point minsize, Rtext *t, void (*hit)(Panel *, int, Rtext *)){
    Textview *tp;
    tp=v->data;
    v->flags=flags|LEAF;
    v->state=UP;
    v->draw=pl_drawtextview;
    v->hit=pl_hittextview;
    v->type=pl_typetextview;
    v->getsize=pl_getsizetextview;
    v->childspace=pl_childspacetextview;
    v->kind="textview";
    v->pri=pl_pritextview;
    tp->hit=hit;
    tp->minsize=minsize;
    tp->text=t;
    tp->yoffs=0;
    tp->hitfirst=0;
    tp->hitword=0;
    v->scroll=pl_scrolltextview;
    v->snarf=pl_snarftextview;
    tp->twid=-1;
    v->scr.pos=Pt(0,0);
    v->scr.size=Pt(0,1);
}
@

<<function pltextview>>=
Panel *pltextview(Panel *parent, int flags, Point minsize, Rtext *t, void (*hit)(Panel *, int, Rtext *)){
    Panel *v;
    v=pl_newpanel(parent, sizeof(Textview));
    plinittextview(v, flags, minsize, t, hit);
    return v;
}
@

<<function plgetpostextview>>=
int plgetpostextview(Panel *p){
    return ((Textview *)p->data)->yoffs;
}
@

<<function plsetpostextview>>=
void plsetpostextview(Panel *p, int yoffs){
    ((Textview *)p->data)->yoffs=yoffs;
    pldraw(p, p->b);
}
@


%-------------------------------------------------------------

<<windows/libpanel/textview.c>>=
/*
 * Fonted text viewer, calls out to code in rtext.c
 *
 * Should redo this to copy the already-visible parts on scrolling & only
 * update the newly appearing stuff -- then the offscreen assembly bitmap can go away.
 */
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <event.h>
#include <panel.h>
#include "pldefs.h"

typedef struct Textview Textview;
<<struct Textview>>

<<function pl_setscrpos>>
<<function pl_drawtextview>>
<<function pl_passon>>
<<function pl_hittextview>>
<<function pl_scrolltextview>>
<<function pl_typetextview>>
<<function pl_getsizetextview>>
<<function pl_childspacetextview>>
<<function pl_pritextview>>

<<function pl_snarftextview>>

<<function plinittextview>>
<<function pltextview>>
<<function plgetpostextview>>
<<function plsetpostextview>>
@


\subsection*{[[windows/libpanel/textwin.c]]}

<<constant SLACK (windows/libpanel/textwin.c)>>=
#define SLACK 100
@

<<function tw_before>>=
/*
 * Is text at point a before or after that at point b?
 */
int tw_before(Textwin *t, Point a, Point b){
    return a.y<b.y || a.y<b.y+t->hgt && a.x<b.x;
}
@

<<function twpt2rune>>=
/*
 * Return the character index indicated by point p, or -1
 * if its off-screen.  The screen must be up-to-date.
 *
 * Linear search should be binary search.
 */
int twpt2rune(Textwin *t, Point p){
    Point *el, *lp;
    el=t->loc+(t->bot-t->top);
    for(lp=t->loc;lp!=el;lp++)
        if(tw_before(t, p, *lp)){
            if(lp==t->loc) return t->top;
            return lp-t->loc+t->top-1;
        }
    return t->bot;
}
@

<<function tw_rune2pt>>=
/*
 * Return ul corner of the character with the given index
 */
Point tw_rune2pt(Textwin *t, int i){
    if(i<t->top) return t->r.min;
    if(i>t->bot) return t->r.max;
    return t->loc[i-t->top];
}
@

<<function tw_storeloc>>=
/*
 * Store p at t->loc[l], extending t->loc if necessary
 */
void tw_storeloc(Textwin *t, int l, Point p){
    int nloc;
    if(l>=t->eloc-t->loc){
        nloc=l+SLACK;
        t->loc=pl_erealloc(t->loc, nloc*sizeof(Point));
        t->eloc=t->loc+nloc;
    }
    t->loc[l]=p;
}
@

<<function tw_setloc>>=
/*
 * Set the locations at which the given runes should appear.
 * Returns the index of the first rune not set, which might not
 * be last because we reached the bottom of the window.
 *
 * N.B. this zaps the loc of r[last], so that value should be saved first,
 * if it's important.
 */
int tw_setloc(Textwin *t, int first, int last, Point ul){
    Rune *r, *er;
    int x, dt, lp;
    char buf[UTFmax+1];
    er=t->text+last;
    for(r=t->text+first,lp=first-t->top;r!=er && ul.y+t->hgt<=t->r.max.y;r++,lp++){
        tw_storeloc(t, lp, ul);
        switch(*r){
        case '\n':
            ul.x=t->r.min.x;
            ul.y+=t->hgt;
            break;
        case '\t':
            x=ul.x-t->r.min.x+t->mintab+t->tabstop;
            x-=x%t->tabstop;
            ul.x=x+t->r.min.x;
            if(ul.x>t->r.max.x){
                ul.x=t->r.min.x;
                ul.y+=t->hgt;
                tw_storeloc(t, lp, ul);
                if(ul.y+t->hgt>t->r.max.y) return r-t->text;
                ul.x+=+t->tabstop;
            }
            break;
        default:
            buf[runetochar(buf, r)]='\0';
            dt=stringwidth(t->font, buf);
            ul.x+=dt;
            if(ul.x>t->r.max.x){
                ul.x=t->r.min.x;
                ul.y+=t->hgt;
                tw_storeloc(t, lp, ul);
                if(ul.y+t->hgt>t->r.max.y) return r-t->text;
                ul.x+=dt;
            }
            break;
        }
    }
    tw_storeloc(t, lp, ul);
    return r-t->text;
}
@

<<function tw_draw>>=
/*
 * Draw the given runes at their locations.
 * Bug -- saving up multiple characters would
 * reduce the number of calls to string,
 * and probably make this a lot faster.
 */
void tw_draw(Textwin *t, int first, int last){
    Rune *r, *er;
    Point *lp, ul, ur;
    char buf[UTFmax+1];
    if(first<t->top) first=t->top;
    if(last>t->bot) last=t->bot;
    if(last<=first) return;
    er=t->text+last;
    for(r=t->text+first,lp=t->loc+(first-t->top);r!=er;r++,lp++){
        if(lp->y+t->hgt>t->r.max.y){
            fprint(2, "chr %C, index %ld of %d, loc %d %d, off bottom\n",
                *r, lp-t->loc, t->bot-t->top, lp->x, lp->y);
            return;
        }
        switch(*r){
        case '\n':
            ur=*lp;
            break;
        case '\t':
            ur=*lp;
            if(lp[1].y!=lp[0].y)
                ul=Pt(t->r.min.x, lp[1].y);
            else
                ul=*lp;
            pl_clr(t->b, Rpt(ul, Pt(lp[1].x, ul.y+t->hgt)));
            break;
        default:
            buf[runetochar(buf, r)]='\0';
    /***/		pl_clr(t->b, Rpt(*lp, addpt(*lp, stringsize(t->font, buf))));
            ur=string(t->b, *lp, display->black, ZP, t->font, buf);
            break;
        }
        if(lp[1].y!=lp[0].y)
    /***/		pl_clr(t->b, Rpt(ur, Pt(t->r.max.x, ur.y+t->hgt)));
    }
}
@

<<function tw_hilitep>>=
/*
 * Hilight the characters with tops between ul and ur
 */
void tw_hilitep(Textwin *t, Point ul, Point ur){
    Point swap;
    int y;
    if(tw_before(t, ur, ul)){ swap=ul; ul=ur; ur=swap;}
    y=ul.y+t->hgt;
    if(y>t->r.max.y) y=t->r.max.y;
    if(ul.y==ur.y)
        pl_highlight(t->b, Rpt(ul, Pt(ur.x, y)));
    else{
        pl_highlight(t->b, Rpt(ul, Pt(t->r.max.x, y)));
        ul=Pt(t->r.min.x, y);
        pl_highlight(t->b, Rpt(ul, Pt(t->r.max.x, ur.y)));
        ul=Pt(t->r.min.x, ur.y);
        y=ur.y+t->hgt;
        if(y>t->r.max.y) y=t->r.max.y;
        pl_highlight(t->b, Rpt(ul, Pt(ur.x, y)));
    }
}
@

<<function twhilite>>=
/*
 * Hilite/unhilite the given range of characters
 */
void twhilite(Textwin *t, int sel0, int sel1, int on){
    Point ul, ur;
    int swap, y;
    if(sel1<sel0){ swap=sel0; sel0=sel1; sel1=swap; }
    if(sel1<t->top || t->bot<sel0) return;
    if(sel0<t->top) sel0=t->top;
    if(sel1>t->bot) sel1=t->bot;
    if(!on){
        if(sel1==sel0){
            ul=t->loc[sel0-t->top];
            y=ul.y+t->hgt;
            if(y>t->r.max.y) y=t->r.max.y;
            pl_clr(t->b, Rpt(ul, Pt(ul.x+1, y)));
        }else
            tw_draw(t, sel0, sel1);
        return;
    }
    ul=t->loc[sel0-t->top];
    if(sel1==sel0)
        ur=addpt(ul, Pt(1, 0));
    else
        ur=t->loc[sel1-t->top];
    tw_hilitep(t, ul, ur);
}
@

<<function twselect>>=
/*
 * Set t->sel[01] from mouse input.
 * Also hilites the selection.
 * Caller should unhilite the previous
 * selection before calling this.
 */
void twselect(Textwin *t, Mouse *m){
    int sel0, sel1, newsel;
    Point p0, p1, newp;
    sel0=sel1=twpt2rune(t, m->xy);
    p0=tw_rune2pt(t, sel0);
    p1=addpt(p0, Pt(1, 0));
    twhilite(t, sel0, sel1, 1);
    for(;;){
        flushimage(display, 1);
        *m=emouse();
        if((m->buttons&7)!=1) break;
        newsel=twpt2rune(t, m->xy);
        newp=tw_rune2pt(t, newsel);
        if(eqpt(newp, p0)) newp=addpt(newp, Pt(1, 0));
        if(!eqpt(newp, p1)){
            if((sel0<=sel1 && sel1<newsel) || (newsel<sel1 && sel1<sel0))
                tw_hilitep(t, p1, newp);
            else if((sel0<=newsel && newsel<sel1) || (sel1<newsel && newsel<=sel0)){
                twhilite(t, sel1, newsel, 0);
                if(newsel==sel0)
                    tw_hilitep(t, p0, newp);
            }else if((newsel<sel0 && sel0<=sel1) || (sel1<sel0 && sel0<=newsel)){
                twhilite(t, sel0, sel1, 0);
                tw_hilitep(t, p0, newp);
            }
            sel1=newsel;
            p1=newp;
        }
    }
    if(sel0<=sel1){
        t->sel0=sel0;
        t->sel1=sel1;
    }
    else{
        t->sel0=sel1;
        t->sel1=sel0;
    }
}
@

<<function tw_clrend>>=
/*
 * Clear the area following the last displayed character
 */
void tw_clrend(Textwin *t){
    Point ul;
    int y;
    ul=t->loc[t->bot-t->top];
    y=ul.y+t->hgt;
    if(y>t->r.max.y) y=t->r.max.y;
    pl_clr(t->b, Rpt(ul, Pt(t->r.max.x, y)));
    ul=Pt(t->r.min.x, y);
    pl_clr(t->b, Rpt(ul, t->r.max));
}
@

<<function tw_moverect>>=
/*
 * Move part of a line of text, truncating the source or padding
 * the destination on the right if necessary.
 */
void tw_moverect(Textwin *t, Point uld, Point urd, Point uls, Point urs){
    int sw, dw, d;
    if(urs.y!=uls.y) urs=Pt(t->r.max.x, uls.y);
    if(urd.y!=uld.y) urd=Pt(t->r.max.x, uld.y);
    sw=uls.x-urs.x;
    dw=uld.x-urd.x;
    if(dw>sw){
        d=dw-sw;
        pl_clr(t->b, Rect(urd.x-d, urd.y, urd.x, urd.y+t->hgt));
        dw=sw;
    }
    pl_cpy(t->b, uld, Rpt(uls, Pt(uls.x+dw, uls.y+t->hgt)));
}
@

<<function tw_moveup>>=
/*
 * Move a block of characters up or to the left:
 *	Identify contiguous runs of characters whose width doesn't change, and
 *	move them in one bitblt per run.
 *	If we get to a point where source and destination are x-aligned,
 *	they will remain x-aligned for the rest of the block.
 *	Then, if they are y-aligned, they're already in the right place.
 *	Otherwise, we can move them in three bitblts; one if all the
 *	remaining characters are on one line.
 */
void tw_moveup(Textwin *t, Point *dp, Point *sp, Point *esp){
    Point uld, uls;			/* upper left of destination/source */
    int y;
    while(sp!=esp && sp->x!=dp->x){
        uld=*dp;
        uls=*sp;
        while(sp!=esp && sp->y==uls.y && dp->y==uld.y && sp->x-uls.x==dp->x-uld.x){
            sp++;
            dp++;
        }
        tw_moverect(t, uld, *dp, uls, *sp);
    }
    if(sp==esp || esp->y==dp->y) return;
    if(esp->y==sp->y){	/* one line only */
        pl_cpy(t->b, *dp, Rpt(*sp, Pt(esp->x, sp->y+t->hgt)));
        return;
    }
    y=sp->y+t->hgt;
    pl_cpy(t->b, *dp, Rpt(*sp, Pt(t->r.max.x, y)));
    pl_cpy(t->b, Pt(t->r.min.x, dp->y+t->hgt),
        Rect(t->r.min.x, y, t->r.max.x, esp->y));
    y=dp->y+esp->y-sp->y;
    pl_cpy(t->b, Pt(t->r.min.x, y),
        Rect(t->r.min.x, esp->y, esp->x, esp->y+t->hgt));
}
@

<<function tw_movedn>>=
/*
 * Same as above, but moving down and in reverse order, so as not to overwrite stuff
 * not moved yet.
 */
void tw_movedn(Textwin *t, Point *dp, Point *bsp, Point *esp){
    Point *sp, urs, urd;
    int dy;
    dp+=esp-bsp;
    sp=esp;
    dy=dp->y-sp->y;
    while(sp!=bsp && dp[-1].x==sp[-1].x){
        --dp;
        --sp;
    }
    if(dy!=0){
        if(sp->y==esp->y)
            pl_cpy(t->b, *dp, Rect(sp->x, sp->y, esp->x, esp->y+t->hgt));
        else{
            pl_cpy(t->b, Pt(t->r.min.x, sp->x+dy),
                Rect(t->r.min.x, sp->y, esp->x, esp->y+t->hgt));
            pl_cpy(t->b, Pt(t->r.min.x, dp->y+t->hgt),
                Rect(t->r.min.x, sp->y+t->hgt, t->r.max.x, esp->y));
            pl_cpy(t->b, *dp,
                Rect(sp->x, sp->y, t->r.max.x, sp->y+t->hgt));
        }
    }
    while(sp!=bsp){
        urd=*dp;
        urs=*sp;
        while(sp!=bsp && sp[-1].y==sp[0].y && dp[-1].y==dp[0].y
           && sp[-1].x-sp[0].x==dp[-1].x-dp[0].x){
            --sp;
            --dp;
        }
        tw_moverect(t, *dp, urd, *sp, urs);
    }
}
@

<<function tw_relocate>>=
/*
 * Move the given range of characters, already drawn on
 * the given textwin, to the given location.
 * Start and end must both index characters that are initially on-screen.
 */
void tw_relocate(Textwin *t, int first, int last, Point dst){
    Point *srcloc;
    int nbyte;
    if(first<t->top || last<first || t->bot<last) return;
    nbyte=(last-first+1)*sizeof(Point);
    srcloc=pl_emalloc(nbyte);
    memmove(srcloc, &t->loc[first-t->top], nbyte);
    tw_setloc(t, first, last, dst);
    if(tw_before(t, dst, srcloc[0]))
        tw_moveup(t, t->loc+first-t->top, srcloc, srcloc+(last-first));
    else
        tw_movedn(t, t->loc+first-t->top, srcloc, srcloc+(last-first));
}
@

<<function twreplace>>=
/*
 * Replace the runes with indices from r0 to r1-1 with the text
 * pointed to by text, and with length ntext.
 *	Open up a hole in t->text, t->loc.
 *	Insert new text, calculate their locs (save the extra loc that's overwritten first)
 *	(swap saved & overwritten locs)
 *	move tail.
 *	calc locs and draw new text after tail, if necessary.
 *	draw new text, if necessary
 */
void twreplace(Textwin *t, int r0, int r1, Rune *ins, int nins){
    int olen, nlen, tlen, dtop;
    olen=t->etext-t->text;
    nlen=olen+nins-(r1-r0);
    tlen=t->eslack-t->text;
    if(nlen>tlen){
        tlen=nlen+SLACK;
        t->text=pl_erealloc(t->text, tlen*sizeof(Rune));
        t->eslack=t->text+tlen;
    }
    if(olen!=nlen)
        memmove(t->text+r0+nins, t->text+r1, (olen-r1)*sizeof(Rune));
    if(nins!=0)	/* ins can be 0 if nins==0 */
        memmove(t->text+r0, ins, nins*sizeof(Rune));
    t->etext=t->text+nlen;
    if(r0>t->bot)		/* insertion is completely below visible text */
        return;
    if(r1<t->top){		/* insertion is completely above visible text */
        dtop=nlen-olen;
        t->top+=dtop;
        t->bot+=dtop;
        return;
    }
    if(1 || t->bot<=r0+nins){	/* no useful text on screen below r0 */
        if(r0<=t->top)	/* no useful text above, either */
            t->top=r0;
        t->bot=tw_setloc(t, r0, nlen, t->loc[r0-t->top]);
        tw_draw(t, r0, t->bot);
        tw_clrend(t);
        return;
    }
    /*
     * code for case where there is useful text below is missing (see `1 ||' above)
     */
}
@

<<function twscroll>>=
/*
 * This works but is stupid.
 */
void twscroll(Textwin *t, int top){
    while(top!=0 && t->text[top-1]!='\n') --top;
    t->top=top;
    t->bot=tw_setloc(t, top, t->etext-t->text, t->r.min);
    tw_draw(t, t->top, t->bot);
    tw_clrend(t);
}
@

<<function twreshape>>=
void twreshape(Textwin *t, Rectangle r){
    t->r=r;
    t->bot=tw_setloc(t, t->top, t->etext-t->text, t->r.min);
    tw_draw(t, t->top, t->bot);
    tw_clrend(t);
}
@

<<function twnew>>=
Textwin *twnew(Image *b, Font *f, Rune *text, int ntext){
    Textwin *t;
    t=pl_emalloc(sizeof(Textwin));
    t->text=pl_emalloc((ntext+SLACK)*sizeof(Rune));
    t->loc=pl_emalloc(SLACK*sizeof(Point));
    t->eloc=t->loc+SLACK;
    t->etext=t->text+ntext;
    t->eslack=t->etext+SLACK;
    if(ntext) memmove(t->text, text, ntext*sizeof(Rune));
    t->top=0;
    t->bot=0;
    t->sel0=0;
    t->sel1=0;
    t->b=b;
    t->font=f;
    t->hgt=f->height;
    t->mintab=stringwidth(f, "0");
    t->tabstop=8*t->mintab;
    return t;
}
@

<<function twfree>>=
void twfree(Textwin *t){
    free(t->loc);
    free(t->text);
    free(t);
}
@

<<function twmove>>=
/*
 * Correct the character locations in a textwin after the panel is moved.
 * This horrid hack would not be necessary if loc values were relative
 * to the panel, rather than absolute.
 */
void twmove(Textwin *t, Point d){
    Point *lp;
    t->r = rectaddpt(t->r, d);
    for(lp=t->loc; lp<t->eloc; lp++)
        *lp = addpt(*lp, d);
}
@


%-------------------------------------------------------------

<<windows/libpanel/textwin.c>>=
/*
 * Text windows
 *	void twhilite(Textwin *t, int sel0, int sel1, int on)
 *		hilite (on=1) or unhilite (on=0) a range of characters
 *	void twselect(Textwin *t, Mouse *m)
 *		set t->sel0, t->sel1 from mouse input.
 *		Also hilites selection.
 *		Caller should first unhilite previous selection.
 *	void twreplace(Textwin *t, int r0, int r1, Rune *ins, int nins)
 *		Replace the given range of characters with the given insertion.
 *		Caller should unhilite selection while this is called.
 *	void twscroll(Textwin *t, int top)
 *		Character with index top moves to the top line of the screen.
 *	int twpt2rune(Textwin *t, Point p)
 *		which character is displayed at point p?
 *	void twreshape(Textwin *t, Rectangle r)
 *		save r and redraw the text
 *	Textwin *twnew(Bitmap *b, Font *f, Rune *text, int ntext)
 *		create a new text window
 *	void twfree(Textwin *t)
 *		get rid of a surplus Textwin
 */
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <event.h>
#include <panel.h>
#include "pldefs.h"

<<constant SLACK (windows/libpanel/textwin.c)>>

<<function tw_before>>
<<function twpt2rune>>
<<function tw_rune2pt>>
<<function tw_storeloc>>
<<function tw_setloc>>
<<function tw_draw>>
<<function tw_hilitep>>
<<function twhilite>>
<<function twselect>>
<<function tw_clrend>>
<<function tw_moverect>>
<<function tw_moveup>>
<<function tw_movedn>>
<<function tw_relocate>>
<<function twreplace>>
<<function twscroll>>
<<function twreshape>>
<<function twnew>>
<<function twfree>>
<<function twmove>>
@


\subsection*{[[windows/libpanel/utf.c]]}

<<function pl_idchar>>=
/*
 * This is the same definition that 8Â½ uses
 */
int pl_idchar(int c){
    if(c<=' '
    || 0x7F<=c && c<=0xA0
    || utfrune("!\"#$%&'()*+,-./:;<=>?@`[\\]^{|}~", c))
        return 0;
    return 1;
}
@

<<function pl_rune1st>>=
int pl_rune1st(int c){
    return (c&0xc0)!=0x80;
}
@

<<function pl_nextrune>>=
char *pl_nextrune(char *s){
    do s++; while(!pl_rune1st(*s));
    return s;
}
@

<<function pl_runewidth>>=
int pl_runewidth(Font *f, char *s){
    char r[4], *t;
    t=r;
    do *t++=*s++; while(!pl_rune1st(*s));
    *t='\0';
    return stringwidth(f, r);
}
@


%-------------------------------------------------------------

<<windows/libpanel/utf.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <event.h>
#include <panel.h>
#include "pldefs.h"
<<function pl_idchar>>
<<function pl_rune1st>>
<<function pl_nextrune>>
<<function pl_runewidth>>
@


\section{[[windows/libplumb/]]}

\subsection*{[[windows/libplumb/event.c]]}

<<struct EQueue>>=
struct EQueue
{
    int		id;
    char		*buf;
    int		nbuf;
    EQueue	*next;
};
@

<<global equeue>>=
static	EQueue	*equeue;
@

<<global eqlock>>=
static	Lock		eqlock;
@

<<function partial>>=
static
int
partial(int id, Event *e, uchar *b, int n)
{
    EQueue *eq, *p;
    int nmore;

    lock(&eqlock);
    for(eq = equeue; eq != nil; eq = eq->next)
        if(eq->id == id)
            break;
    unlock(&eqlock);
    if(eq == nil)
        return 0;
    /* partial message exists for this id */
    eq->buf = realloc(eq->buf, eq->nbuf+n);
    if(eq->buf == nil)
        drawerror(display, "eplumb: cannot allocate buffer");
    memmove(eq->buf+eq->nbuf, b, n);
    eq->nbuf += n;
    e->v = plumbunpackpartial((char*)eq->buf, eq->nbuf, &nmore);
    if(nmore == 0){	/* no more to read in this message */
        lock(&eqlock);
        if(eq == equeue)
            equeue = eq->next;
        else{
            for(p = equeue; p!=nil && p->next!=eq; p = p->next)
                ;
            if(p == nil)
                drawerror(display, "eplumb: bad event queue");
            p->next = eq->next;
        }
        unlock(&eqlock);
        free(eq->buf);
        free(eq);
    }
    return 1;
}
@

<<function addpartial>>=
static
void
addpartial(int id, char *b, int n)
{
    EQueue *eq;

    eq = malloc(sizeof(EQueue));
    if(eq == nil)
        return;
    eq->id = id;
    eq->nbuf = n;
    eq->buf = malloc(n);
    if(eq->buf == nil){
        free(eq);
        return;
    }
    memmove(eq->buf, b, n);
    lock(&eqlock);
    eq->next = equeue;
    equeue = eq;
    unlock(&eqlock);
}
@

<<function plumbevent>>=
static
int
plumbevent(int id, Event *e, uchar *b, int n)
{
    int nmore;

    if(partial(id, e, b, n) == 0){
        /* no partial message already waiting for this id */
        e->v = plumbunpackpartial((char*)b, n, &nmore);
        if(nmore > 0)	/* incomplete message */
            addpartial(id, (char*)b, n);
    }
    if(e->v == nil)
        return 0;
    return id;
}
@

<<function eplumb>>=
int
eplumb(int key, char *port)
{
    int fd;

    fd = plumbopen(port, OREAD|OCEXEC);
    if(fd < 0)
        return -1;
    return estartfn(key, fd, 8192, plumbevent);
}
@


%-------------------------------------------------------------

<<windows/libplumb/event.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <event.h>
#include "plumb.h"

typedef struct EQueue EQueue;

<<struct EQueue>>

<<global equeue>>
<<global eqlock>>

<<function partial>>

<<function addpartial>>

<<function plumbevent>>

<<function eplumb>>
@


\subsection*{[[windows/libplumb/mesg.c]]}

<<function plumbopen>>=
int
plumbopen(char *name, int omode)
{
    int fd, f;
    char *s, *plumber;
    char buf[128], err[ERRMAX];

    if(name[0] == '/')
        return open(name, omode);
        
    /* find elusive plumber */
    if(access("/mnt/plumb/send", AWRITE) >= 0)
        plumber = "/mnt/plumb";
    else if(access("/mnt/term/mnt/plumb/send", AWRITE) >= 0)
        plumber = "/mnt/term/mnt/plumb";
    else{
        /* last resort: try mounting service */
        plumber = "/mnt/plumb";
        s = getenv("plumbsrv");
        if(s == nil)
            return -1;
        f = open(s, ORDWR);
        free(s);
        if(f < 0)
            return -1;
        if(mount(f, -1, "/mnt/plumb", MREPL, "") < 0){
            close(f);
            return -1;
        }
        if(access("/mnt/plumb/send", AWRITE) < 0)
            return -1;
    }

    snprint(buf, sizeof buf, "%s/%s", plumber, name);
    fd = open(buf, omode);
    if(fd >= 0)
        return fd;

    /* try creating port; used by non-standard plumb implementations */
    rerrstr(err, sizeof err);
    fd = create(buf, omode, 0600);
    if(fd >= 0)
        return fd;
    errstr(err, sizeof err);

    return -1;
}
@

<<function Strlen>>=
static int
Strlen(char *s)
{
    if(s == nil)
        return 0;
    return strlen(s);
}
@

<<function Strcpy>>=
static char*
Strcpy(char *s, char *t)
{
    if(t == nil)
        return s;
    return strcpy(s, t) + strlen(t);
}
@

<<function quote>>=
/* quote attribute value, if necessary */
static char*
quote(char *s, char *buf, char *bufe)
{
    char *t;
    int c;

    if(s == nil){
        buf[0] = '\0';
        return buf;
    }
    if(strpbrk(s, " '=\t") == nil)
        return s;
    t = buf;
    *t++ = '\'';
    while(t < bufe-2){
        c = *s++;
        if(c == '\0')
            break;
        *t++ = c;
        if(c == '\'')
            *t++ = c;
    }
    *t++ = '\'';
    *t = '\0';
    return buf;
}
@

<<function plumbpackattr>>=
char*
plumbpackattr(Plumbattr *attr)
{
    int n;
    Plumbattr *a;
    char *s, *t, *buf, *bufe;

    if(attr == nil)
        return nil;
    if((buf = malloc(4096)) == nil)
        return nil;
    bufe = buf + 4096;
    n = 0;
    for(a=attr; a!=nil; a=a->next)
        n += Strlen(a->name) + 1 + Strlen(quote(a->value, buf, bufe)) + 1;
    s = malloc(n);
    if(s == nil) {
        free(buf);
        return nil;
    }
    t = s;
    *t = '\0';
    for(a=attr; a!=nil; a=a->next){
        if(t != s)
            *t++ = ' ';
        strcpy(t, a->name);
        strcat(t, "=");
        strcat(t, quote(a->value, buf, bufe));
        t += strlen(t);
    }
    if(t > s+n)
        abort();
    free(buf);
    return s;
}
@

<<function plumblookup>>=
char*
plumblookup(Plumbattr *attr, char *name)
{
    while(attr){
        if(strcmp(attr->name, name) == 0)
            return attr->value;
        attr = attr->next;
    }
    return nil;
}
@

<<function plumbpack>>=
char*
plumbpack(Plumbmsg *m, int *np)
{
    int n, ndata;
    char *buf, *p, *attr;

    ndata = m->ndata;
    if(ndata < 0)
        ndata = Strlen(m->data);
    attr = plumbpackattr(m->attr);
    n = Strlen(m->src)+1 + Strlen(m->dst)+1 + Strlen(m->wdir)+1 +
        Strlen(m->type)+1 + Strlen(attr)+1 + 16 + ndata;
    buf = malloc(n+1);	/* +1 for '\0' */
    if(buf == nil){
        free(attr);
        return nil;
    }
    p = Strcpy(buf, m->src);
    *p++ = '\n';
    p = Strcpy(p, m->dst);
    *p++ = '\n';
    p = Strcpy(p, m->wdir);
    *p++ = '\n';
    p = Strcpy(p, m->type);
    *p++ = '\n';
    p = Strcpy(p, attr);
    *p++ = '\n';
    p += sprint(p, "%d\n", ndata);
    memmove(p, m->data, ndata);
    *np = (p-buf)+ndata;
    buf[*np] = '\0';	/* null terminate just in case */
    if(*np >= n+1)
        abort();
    free(attr);
    return buf;
}
@

<<function plumbsend>>=
int
plumbsend(int fd, Plumbmsg *m)
{
    char *buf;
    int n;

    buf = plumbpack(m, &n);
    if(buf == nil)
        return -1;
    n = write(fd, buf, n);
    free(buf);
    return n;
}
@

<<function plumbline>>=
static int
plumbline(char **linep, char *buf, int i, int n, int *bad)
{
    int starti;
    char *p;

    starti = i;
    while(i<n && buf[i]!='\n')
        i++;
    if(i == n)
        *bad = 1;
    else{
        p = malloc((i-starti) + 1);
        if(p == nil)
            *bad = 1;
        else{
            memmove(p, buf+starti, i-starti);
            p[i-starti] = '\0';
        }
        *linep = p;
        i++;
    }
    return i;
}
@

<<function plumbfree>>=
void
plumbfree(Plumbmsg *m)
{
    Plumbattr *a, *next;

    free(m->src);
    free(m->dst);
    free(m->wdir);
    free(m->type);
    for(a=m->attr; a!=nil; a=next){
        next = a->next;
        free(a->name);
        free(a->value);
        free(a);
    }
    free(m->data);
    free(m);
}
@

<<function plumbunpackattr>>=
Plumbattr*
plumbunpackattr(char *p)
{
    Plumbattr *attr, *prev, *a;
    char *q, *v, *buf, *bufe;
    int c, quoting;

    buf = malloc(4096);
    if(buf == nil)
        return nil;
    bufe = buf + 4096;
    attr = prev = nil;
    while(*p!='\0' && *p!='\n'){
        while(*p==' ' || *p=='\t')
            p++;
        if(*p == '\0')
            break;
        for(q=p; *q!='\0' && *q!='\n' && *q!=' ' && *q!='\t'; q++)
            if(*q == '=')
                break;
        if(*q != '=')
            break;	/* malformed attribute */
        a = malloc(sizeof(Plumbattr));
        if(a == nil)
            break;
        a->name = malloc(q-p+1);
        if(a->name == nil){
            free(a);
            break;
        }
        memmove(a->name, p, q-p);
        a->name[q-p] = '\0';
        /* process quotes in value */
        q++;	/* skip '=' */
        v = buf;
        quoting = 0;
        while(*q!='\0' && *q!='\n'){
            if(v >= bufe)
                break;
            c = *q++;
            if(quoting){
                if(c == '\''){
                    if(*q == '\'')
                        q++;
                    else{
                        quoting = 0;
                        continue;
                    }
                }
            }else{
                if(c==' ' || c=='\t')
                    break;
                if(c == '\''){
                    quoting = 1;
                    continue;
                }
            }
            *v++ = c;
        }
        a->value = malloc(v-buf+1);
        if(a->value == nil){
            free(a->name);
            free(a);
            break;
        }
        memmove(a->value, buf, v-buf);
        a->value[v-buf] = '\0';
        a->next = nil;
        if(prev == nil)
            attr = a;
        else
            prev->next = a;
        prev = a;
        p = q;
    }
    free(buf);
    return attr;
}
@

<<function plumbaddattr>>=
Plumbattr*
plumbaddattr(Plumbattr *attr, Plumbattr *new)
{
    Plumbattr *l;

    l = attr;
    if(l == nil)
        return new;
    while(l->next != nil)
        l = l->next;
    l->next = new;
    return attr;
}
@

<<function plumbdelattr>>=
Plumbattr*
plumbdelattr(Plumbattr *attr, char *name)
{
    Plumbattr *l, *prev;

    prev = nil;
    for(l=attr; l!=nil; l=l->next){
        if(strcmp(name, l->name) == 0)
            break;
        prev = l;
    }
    if(l == nil)
        return nil;
    if(prev)
        prev->next = l->next;
    else
        attr = l->next;
    free(l->name);
    free(l->value);
    free(l);
    return attr;
}
@

<<function plumbunpackpartial>>=
Plumbmsg*
plumbunpackpartial(char *buf, int n, int *morep)
{
    Plumbmsg *m;
    int i, bad;
    char *ntext, *attr;

    m = malloc(sizeof(Plumbmsg));
    if(m == nil)
        return nil;
    memset(m, 0, sizeof(Plumbmsg));
    if(morep != nil)
        *morep = 0;
    bad = 0;
    i = plumbline(&m->src, buf, 0, n, &bad);
    i = plumbline(&m->dst, buf, i, n, &bad);
    i = plumbline(&m->wdir, buf, i, n, &bad);
    i = plumbline(&m->type, buf, i, n, &bad);
    i = plumbline(&attr, buf, i, n, &bad);
    i = plumbline(&ntext, buf, i, n, &bad);
    if(bad){
        plumbfree(m);
        return nil;
    }
    m->attr = plumbunpackattr(attr);
    free(attr);
    m->ndata = atoi(ntext);
    if(m->ndata != n-i){
        bad = 1;
        if(morep!=nil && m->ndata>n-i)
            *morep = m->ndata - (n-i);
    }
    free(ntext);
    if(!bad){
        m->data = malloc(n-i+1);	/* +1 for '\0' */
        if(m->data == nil)
            bad = 1;
        else{
            memmove(m->data, buf+i, m->ndata);
            m->ndata = n-i;
            /* null-terminate in case it's text */
            m->data[m->ndata] = '\0';
        }
    }
    if(bad){
        plumbfree(m);
        m = nil;
    }
    return m;
}
@

<<function plumbunpack>>=
Plumbmsg*
plumbunpack(char *buf, int n)
{
    return plumbunpackpartial(buf, n, nil);
}
@

<<function plumbrecv>>=
Plumbmsg*
plumbrecv(int fd)
{
    char *buf;
    Plumbmsg *m;
    int n, more;

    buf = malloc(8192);
    if(buf == nil)
        return nil;
    n = read(fd, buf, 8192);
    m = nil;
    if(n > 0){
        m = plumbunpackpartial(buf, n, &more);
        if(m==nil && more>0){
            /* we now know how many more bytes to read for complete message */
            buf = realloc(buf, n+more);
            if(buf == nil)
                return nil;
            if(readn(fd, buf+n, more) == more)
                m = plumbunpackpartial(buf, n+more, nil);
        }
    }
    free(buf);
    return m;
}
@


%-------------------------------------------------------------

<<windows/libplumb/mesg.c>>=
#include <u.h>
#include <libc.h>
#include "plumb.h"

<<function plumbopen>>

<<function Strlen>>

<<function Strcpy>>

<<function quote>>

<<function plumbpackattr>>

<<function plumblookup>>

<<function plumbpack>>

<<function plumbsend>>

<<function plumbline>>

<<function plumbfree>>

<<function plumbunpackattr>>

<<function plumbaddattr>>

<<function plumbdelattr>>

<<function plumbunpackpartial>>

<<function plumbunpack>>

<<function plumbrecv>>
@


\subsection*{[[windows/libplumb/plumbsendtext.c]]}

<<function plumbsendtext>>=
int
plumbsendtext(int fd, char *src, char *dst, char *wdir, char *data)
{
    Plumbmsg m;

    m.src = src;
    m.dst = dst;
    m.wdir = wdir;
    m.type = "text";
    m.attr = nil;
    m.ndata = strlen(data);
    m.data = data;
    return plumbsend(fd, &m);
}
@


%-------------------------------------------------------------

<<windows/libplumb/plumbsendtext.c>>=
#include <u.h>
#include <libc.h>
#include "plumb.h"

<<function plumbsendtext>>
@


\section{[[kernel/devices/screen/386/]]}


\subsection*{[[kernel/devices/screen/386/devvga.c]]}

<<enum _anon_ (kernel/devices/screen/386/devvga.c)>>=
enum {
    Qdir,
    Qvgabios,
    Qvgactl,
    Qvgaovl,
    Qvgaovlctl,
};
@

<<global vgadir>>=
static Dirtab vgadir[] = {
    ".",    { Qdir, 0, QTDIR },     0,  0550,
    "vgabios",  { Qvgabios, 0 },    0x100000, 0440,
    "vgactl",       { Qvgactl, 0 },     0,  0660,
    "vgaovl",       { Qvgaovl, 0 },     0,  0660,
    "vgaovlctl",    { Qvgaovlctl, 0 },  0,  0660,
};
@

<<enum _anon_ (kernel/devices/screen/386/devvga.c)2>>=
enum {
    CMactualsize,
    CMblank,
    CMblanktime,
    CMdrawinit,
    CMhwaccel,
    CMhwblank,
    CMhwgc,
    CMlinear,
    CMpalettedepth,
    CMpanning,
    CMsize,
    CMtextmode,
    CMtype,
    CMunblank,
};
@

<<global vgactlmsg>>=
static Cmdtab vgactlmsg[] = {
    CMactualsize,   "actualsize",   2,
    CMblank,    "blank",    1,
    CMblanktime,    "blanktime",    2,
    CMdrawinit, "drawinit", 1,
    CMhwaccel,  "hwaccel",  2,
    CMhwblank,  "hwblank",  2,
    CMhwgc,     "hwgc",     2,
    CMlinear,   "linear",   0,
    CMpalettedepth, "palettedepth", 2,
    CMpanning,  "panning",  2,
    CMsize,     "size",     3,
    CMtextmode, "textmode", 1,
    CMtype,     "type",     2,
    CMunblank,  "unblank",  1,
};
@

<<function vgareset>>=
static void
vgareset(void)
{
    /* reserve the 'standard' vga registers */
    if(ioalloc(0x2b0, 0x2df-0x2b0+1, 0, "vga") < 0)
        panic("vga ports already allocated"); 
    if(ioalloc(0x3c0, 0x3da-0x3c0+1, 0, "vga") < 0)
        panic("vga ports already allocated"); 
}
@

<<function vgaattach>>=
static Chan*
vgaattach(char* spec)
{
    if(*spec && strcmp(spec, "0"))
        error(Eio);
    return devattach('v', spec);
}
@

<<function vgawalk>>=
Walkqid*
vgawalk(Chan* c, Chan *nc, char** name, int nname)
{
    return devwalk(c, nc, name, nname, vgadir, nelem(vgadir), devgen);
}
@

<<function vgastat>>=
static int
vgastat(Chan* c, uchar* dp, int n)
{
    return devstat(c, dp, n, vgadir, nelem(vgadir), devgen);
}
@

<<function vgaopen>>=
static Chan*
vgaopen(Chan* c, int omode)
{
    VGAscr *scr;
    static char *openctl = "openctl\n";

    scr = &vgascreen[0];
    if ((ulong)c->qid.path == Qvgaovlctl) {
        if (scr->dev && scr->dev->ovlctl)
            scr->dev->ovlctl(scr, c, openctl, strlen(openctl));
        else 
            error(Enonexist);
    }
    return devopen(c, omode, vgadir, nelem(vgadir), devgen);
}
@

<<function vgaclose>>=
static void
vgaclose(Chan* c)
{
    VGAscr *scr;
    static char *closectl = "closectl\n";

    scr = &vgascreen[0];
    if((ulong)c->qid.path == Qvgaovlctl)
        if(scr->dev && scr->dev->ovlctl){
            if(waserror()){
                print("ovlctl error: %s\n", up->errstr);
                return;
            }
            scr->dev->ovlctl(scr, c, closectl, strlen(closectl));
            poperror();
        }
}
@

<<function vgaread>>=
//}

static long
vgaread(Chan* c, void* a, long n, vlong off)
{
    int len;
    char *p, *s;
    VGAscr *scr;
    ulong offset = off;
    char chbuf[30];

    switch((ulong)c->qid.path){

    case Qdir:
        return devdirread(c, a, n, vgadir, nelem(vgadir), devgen);

    case Qvgabios:
        if(offset >= 0x100000)
            return 0;
        if(offset+n >= 0x100000)
            n = 0x100000 - offset;
        memmove(a, (uchar*)kaddr(0)+offset, n);
        return n;

    case Qvgactl:
        scr = &vgascreen[0];

        p = malloc(READSTR);
        if(p == nil)
            error(Enomem);
        if(waserror()){
            free(p);
            nexterror();
        }

        len = 0;

        if(scr->dev)
            s = scr->dev->name;
        else
            s = "cga";
        len += snprint(p+len, READSTR-len, "type %s\n", s);

        if(scr->gscreen) {
            len += snprint(p+len, READSTR-len, "size %dx%dx%d %s\n",
                scr->gscreen->r.max.x, scr->gscreen->r.max.y,
                scr->gscreen->depth, chantostr(chbuf, scr->gscreen->chan));

            if(Dx(scr->gscreen->r) != Dx(physgscreenr) 
            || Dy(scr->gscreen->r) != Dy(physgscreenr))
                len += snprint(p+len, READSTR-len, "actualsize %dx%d\n",
                    physgscreenr.max.x, physgscreenr.max.y);
        }

        len += snprint(p+len, READSTR-len, "blank time %lud idle %d state %s\n",
            blanktime, drawidletime(), scr->isblank ? "off" : "on");
        len += snprint(p+len, READSTR-len, "hwaccel %s\n", hwaccel ? "on" : "off");
        len += snprint(p+len, READSTR-len, "hwblank %s\n", hwblank ? "on" : "off");
        len += snprint(p+len, READSTR-len, "panning %s\n", panning ? "on" : "off");
        len += snprint(p+len, READSTR-len, "addr p 0x%lux v 0x%p size 0x%ux\n", scr->paddr, scr->vaddr, scr->apsize);
        USED(len);

        n = readstr(offset, a, n, p);
        poperror();
        free(p);

        return n;

    case Qvgaovl:
    case Qvgaovlctl:
        error(Ebadusefd);
        break;

    default:
        error(Egreg);
        break;
    }

    return 0;
}
@

<<function vgactl>>=
//static char Ebusy[] = "vga already configured";

static void
vgactl(Cmdbuf *cb)
{
    int align, i, size, x, y, z;
    char *chanstr, *p;
    ulong chan;
    Cmdtab *ct;
    VGAscr *scr;
    extern VGAdev *vgadev[];
    extern VGAcur *vgacur[];

    scr = &vgascreen[0];
    ct = lookupcmd(cb, vgactlmsg, nelem(vgactlmsg));
    switch(ct->index){
    case CMhwgc:
        if(strcmp(cb->f[1], "off") == 0){
            lock(&cursor);
            if(scr->cur){
                if(scr->cur->disable)
                    scr->cur->disable(scr);
                scr->cur = nil;
            }
            unlock(&cursor);
            return;
        }
        if(strcmp(cb->f[1], "soft") == 0){
            lock(&cursor);
            swcursorinit();
            if(scr->cur && scr->cur->disable)
                scr->cur->disable(scr);
            scr->cur = &swcursor;
            if(scr->cur->enable)
                scr->cur->enable(scr);
            unlock(&cursor);
            return;
        }
        for(i = 0; vgacur[i]; i++){
            if(strcmp(cb->f[1], vgacur[i]->name))
                continue;
            lock(&cursor);
            if(scr->cur && scr->cur->disable)
                scr->cur->disable(scr);
            scr->cur = vgacur[i];
            if(scr->cur->enable)
                scr->cur->enable(scr);
            unlock(&cursor);
            return;
        }
        break;

    case CMtype:
        for(i = 0; vgadev[i]; i++){
            if(strcmp(cb->f[1], vgadev[i]->name))
                continue;
            if(scr->dev && scr->dev->disable)
                scr->dev->disable(scr);
            scr->dev = vgadev[i];
            if(scr->dev->enable)
                scr->dev->enable(scr);
            return;
        }
        break;

    case CMtextmode:
        screeninit();
        return;

    case CMsize:
        x = strtoul(cb->f[1], &p, 0);
        if(x == 0 || x > 10240)
            error(Ebadarg);
        if(*p)
            p++;

        y = strtoul(p, &p, 0);
        if(y == 0 || y > 10240)
            error(Ebadarg);
        if(*p)
            p++;

        z = strtoul(p, &p, 0);

        chanstr = cb->f[2];
        if((chan = strtochan(chanstr)) == 0)
            error("bad channel");

        if(chantodepth(chan) != z)
            error("depth, channel do not match");

        cursoroff(1);
        deletescreenimage();
        if(screensize(x, y, z, chan))
            error(Egreg);
        vgascreenwin(scr);
        resetscreenimage();
        cursoron(1);
        return;

    case CMactualsize:
        if(scr->gscreen == nil)
            error("set the screen size first");

        x = strtoul(cb->f[1], &p, 0);
        if(x == 0 || x > 2048)
            error(Ebadarg);
        if(*p)
            p++;

        y = strtoul(p, nil, 0);
        if(y == 0 || y > 2048)
            error(Ebadarg);

        if(x > scr->gscreen->r.max.x || y > scr->gscreen->r.max.y)
            error("physical screen bigger than virtual");

        physgscreenr = Rect(0,0,x,y);
        scr->gscreen->clipr = physgscreenr;
        return;
    
    case CMpalettedepth:
        x = strtoul(cb->f[1], &p, 0);
        if(x != 8 && x != 6)
            error(Ebadarg);

        scr->palettedepth = x;
        return;

    case CMdrawinit:
        if(scr->gscreen == nil)
            error("drawinit: no gscreen");
        if(scr->dev && scr->dev->drawinit)
            scr->dev->drawinit(scr);
        return;
    
    case CMlinear:
        if(cb->nf!=2 && cb->nf!=3)
            error(Ebadarg);
        size = strtoul(cb->f[1], 0, 0);
        if(cb->nf == 2)
            align = 0;
        else
            align = strtoul(cb->f[2], 0, 0);
        if(screenaperture(size, align) < 0)
            error("not enough free address space");
        return;
/*  
    case CMmemset:
        memset((void*)strtoul(cb->f[1], 0, 0), atoi(cb->f[2]), atoi(cb->f[3]));
        return;
*/

    case CMblank:
        drawblankscreen(1);
        return;
    
    case CMunblank:
        drawblankscreen(0);
        return;
    
    case CMblanktime:
        blanktime = strtoul(cb->f[1], 0, 0);
        return;

    case CMpanning:
        if(strcmp(cb->f[1], "on") == 0){
            if(scr == nil || scr->cur == nil)
                error("set screen first");
            if(!scr->cur->doespanning)
                error("panning not supported");
            scr->gscreen->clipr = scr->gscreen->r;
            panning = 1;
        }
        else if(strcmp(cb->f[1], "off") == 0){
            scr->gscreen->clipr = physgscreenr;
            panning = 0;
        }else
            break;
        return;

    case CMhwaccel:
        if(strcmp(cb->f[1], "on") == 0)
            hwaccel = 1;
        else if(strcmp(cb->f[1], "off") == 0)
            hwaccel = 0;
        else
            break;
        return;
    
    case CMhwblank:
        if(strcmp(cb->f[1], "on") == 0)
            hwblank = 1;
        else if(strcmp(cb->f[1], "off") == 0)
            hwblank = 0;
        else
            break;
        return;
    }

    cmderror(cb, "bad VGA control message");
}
@

<<global Enooverlay>>=
char Enooverlay[] = "No overlay support";
@

<<function vgawrite>>=
static long
vgawrite(Chan* c, void* a, long n, vlong off)
{
    ulong offset = off;
    Cmdbuf *cb;
    VGAscr *scr;

    switch((ulong)c->qid.path){

    case Qdir:
        error(Eperm);

    case Qvgactl:
        if(offset || n >= READSTR)
            error(Ebadarg);
        cb = parsecmd(a, n);
        if(waserror()){
            free(cb);
            nexterror();
        }
        vgactl(cb);
        poperror();
        free(cb);
        return n;

    case Qvgaovl:
        scr = &vgascreen[0];
        if (scr->dev == nil || scr->dev->ovlwrite == nil) {
            error(Enooverlay);
            break;
        }
        return scr->dev->ovlwrite(scr, a, n, off);

    case Qvgaovlctl:
        scr = &vgascreen[0];
        if (scr->dev == nil || scr->dev->ovlctl == nil) {
            error(Enooverlay);
            break;
        }
        scr->dev->ovlctl(scr, c, a, n);
        return n;

    default:
        error(Egreg);
        break;
    }

    return 0;
}
@

<<global vgadevtab>>=
Dev vgadevtab = {
    .dc       =    'v',
    .name     =    "vga",
               
    .reset    =    vgareset,
    .init     =    devinit,
    .shutdown =    devshutdown,
    .attach   =    vgaattach,
    .walk     =    vgawalk,
    .stat     =    vgastat,
    .open     =    vgaopen,
    .create   =    devcreate,
    .close    =    vgaclose,
    .read     =    vgaread,
    .bread    =    devbread,
    .write    =    vgawrite,
    .bwrite   =    devbwrite,
    .remove   =    devremove,
    .wstat    =    devwstat,
};
@


%-------------------------------------------------------------

<<kernel/devices/screen/386/devvga.c>>=
/*
 * VGA controller
 */
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"
#include "io.h"
#include "../port/error.h"

#include <draw.h>
#include <memdraw.h>
#include <cursor.h>
#include "screen.h"

<<enum _anon_ (kernel/devices/screen/386/devvga.c)>>

<<global vgadir>>

<<enum _anon_ (kernel/devices/screen/386/devvga.c)2>>

<<global vgactlmsg>>

<<function vgareset>>

<<function vgaattach>>

<<function vgawalk>>

<<function vgastat>>

<<function vgaopen>>

<<function vgaclose>>

//static void
//checkport(int start, int end)
//{
//  /* standard vga regs are OK */
//  if(start >= 0x2b0 && end <= 0x2df+1)
//      return;
//  if(start >= 0x3c0 && end <= 0x3da+1)
//      return;
//
//  if(iounused(start, end))
//      return;
//  error(Eperm);
<<function vgaread>>

<<function vgactl>>

<<global Enooverlay>>

<<function vgawrite>>

<<global vgadevtab>>
@


\subsection*{[[kernel/devices/screen/386/screen.c]]}

<<global physgscreenr>>=
//Point ZP = {0, 0};

Rectangle physgscreenr;
@

<<global gscreendata>>=
Memdata gscreendata;
@

<<global gscreen>>=
Memimage *gscreen;
@

<<global vgascreen>>=
VGAscr vgascreen[1];
@

<<global arrow>>=
Cursor  arrow = {
    { -1, -1 },
    { 0xFF, 0xFF, 0x80, 0x01, 0x80, 0x02, 0x80, 0x0C, 
      0x80, 0x10, 0x80, 0x10, 0x80, 0x08, 0x80, 0x04, 
      0x80, 0x02, 0x80, 0x01, 0x80, 0x02, 0x8C, 0x04, 
      0x92, 0x08, 0x91, 0x10, 0xA0, 0xA0, 0xC0, 0x40, 
    },
    { 0x00, 0x00, 0x7F, 0xFE, 0x7F, 0xFC, 0x7F, 0xF0, 
      0x7F, 0xE0, 0x7F, 0xE0, 0x7F, 0xF0, 0x7F, 0xF8, 
      0x7F, 0xFC, 0x7F, 0xFE, 0x7F, 0xFC, 0x73, 0xF8, 
      0x61, 0xF0, 0x60, 0xE0, 0x40, 0x40, 0x00, 0x00, 
    },
};
@

<<global didswcursorinit>>=
int didswcursorinit;
@

<<global softscreen>>=
static void *softscreen;
@

<<function screensize>>=
int
screensize(int x, int y, int z, ulong chan)
{
    VGAscr *scr;
    void *oldsoft;

    lock(&vgascreenlock);
    if(waserror()){
        unlock(&vgascreenlock);
        nexterror();
    }

    memimageinit();
    scr = &vgascreen[0];
    oldsoft = softscreen;

    if(scr->paddr == 0){
        int width = (x*z)/BI2WD;
        void *p;

        p = xalloc(width*BY2WD*y);
        if(p == nil)
            error("no memory for vga soft screen");
        gscreendata.bdata = softscreen = p;
        if(scr->dev && scr->dev->page){
            scr->vaddr = KADDR(VGAMEM());
            scr->apsize = 1<<16;
        }
        scr->useflush = 1;
    }
    else{
        gscreendata.bdata = scr->vaddr;
        scr->useflush = scr->dev && scr->dev->flush;
    }

    scr->gscreen = nil;
    if(gscreen)
        freememimage(gscreen);
    gscreen = allocmemimaged(Rect(0,0,x,y), chan, &gscreendata);
    if(gscreen == nil)
        error("no memory for vga memimage");
    vgaimageinit(chan);

    scr->palettedepth = 6;  /* default */
    scr->gscreendata = &gscreendata;
    scr->memdefont = getmemdefont();
    scr->gscreen = gscreen;

    physgscreenr = gscreen->r;
    unlock(&vgascreenlock);
    poperror();
    if(oldsoft)
        xfree(oldsoft);

    memimagedraw(gscreen, gscreen->r, memblack, ZP, nil, ZP, S);
    flushmemscreen(gscreen->r);

    if(didswcursorinit)
        swcursorinit();
    drawcmap();
    return 0;
}
@

<<function screenaperture>>=
int
screenaperture(int size, int align)
{
    VGAscr *scr;

    scr = &vgascreen[0];

    if(scr->paddr)  /* set up during enable */
        return 0;

    if(size == 0)
        return 0;

    if(scr->dev && scr->dev->linear){
        scr->dev->linear(scr, size, align);
        return 0;
    }

    /*
     * Need to allocate some physical address space.
     * The driver will tell the card to use it.
     */
    size = PGROUND(size);
    scr->paddr = upaalloc(size, align);
    if(scr->paddr == 0)
        return -1;
    scr->vaddr = vmap(scr->paddr, size);
    if(scr->vaddr == nil)
        return -1;
    scr->apsize = size;

    return 0;
}
@

<<function attachscreen>>=
uchar*
attachscreen(Rectangle* r, ulong* chan, int* d, int* width, int *softscreen)
{
    VGAscr *scr;

    scr = &vgascreen[0];
    if(scr->gscreen == nil || scr->gscreendata == nil)
        return nil;

    *r = scr->gscreen->clipr;
    *chan = scr->gscreen->chan;
    *d = scr->gscreen->depth;
    *width = scr->gscreen->width;
    *softscreen = scr->useflush;

    return scr->gscreendata->bdata;
}
@

<<function flushmemscreen>>=
/*
 * It would be fair to say that this doesn't work for >8-bit screens.
 */
void
flushmemscreen(Rectangle r)
{
    VGAscr *scr;
    uchar *sp, *disp, *sdisp, *edisp;
    int y, len, incs, off, page;

    scr = &vgascreen[0];
    if(scr->dev && scr->dev->flush){
        scr->dev->flush(scr, r);
        return;
    }
    if(scr->gscreen == nil || scr->useflush == 0)
        return;
    if(scr->dev == nil || scr->dev->page == nil)
        return;

    if(rectclip(&r, scr->gscreen->r) == 0)
        return;

    incs = scr->gscreen->width * BY2WD;

    switch(scr->gscreen->depth){
    default:
        len = 0;
        panic("flushmemscreen: depth\n");
        break;
    case 8:
        len = Dx(r);
        break;
    }
    if(len < 1)
        return;

    off = r.min.y*scr->gscreen->width*BY2WD+(r.min.x*scr->gscreen->depth)/8;
    page = off/scr->apsize;
    off %= scr->apsize;
    disp = scr->vaddr;
    sdisp = disp+off;
    edisp = disp+scr->apsize;

    off = r.min.y*scr->gscreen->width*BY2WD+(r.min.x*scr->gscreen->depth)/8;

    sp = scr->gscreendata->bdata + off;

    scr->dev->page(scr, page);
    for(y = r.min.y; y < r.max.y; y++) {
        if(sdisp + incs < edisp) {
            memmove(sdisp, sp, len);
            sp += incs;
            sdisp += incs;
        }
        else {
            off = edisp - sdisp;
            page++;
            if(off <= len){
                if(off > 0)
                    memmove(sdisp, sp, off);
                scr->dev->page(scr, page);
                if(len - off > 0)
                    memmove(disp, sp+off, len - off);
            }
            else {
                memmove(sdisp, sp, len);
                scr->dev->page(scr, page);
            }
            sp += incs;
            sdisp += incs - scr->apsize;
        }
    }
}
@

<<function getcolor>>=
void
getcolor(ulong p, ulong* pr, ulong* pg, ulong* pb)
{
    VGAscr *scr;
    ulong x;

    scr = &vgascreen[0];
    if(scr->gscreen == nil)
        return;

    switch(scr->gscreen->depth){
    default:
        x = 0x0F;
        break;
    case 8:
        x = 0xFF;
        break;
    }
    p &= x;

    lock(&cursor);
    *pr = scr->colormap[p][0];
    *pg = scr->colormap[p][1];
    *pb = scr->colormap[p][2];
    unlock(&cursor);
}
@

<<function setpalette>>=
int
setpalette(ulong p, ulong r, ulong g, ulong b)
{
    VGAscr *scr;
    int d;

    scr = &vgascreen[0];
    d = scr->palettedepth;

    lock(&cursor);
    scr->colormap[p][0] = r;
    scr->colormap[p][1] = g;
    scr->colormap[p][2] = b;
    vgao(PaddrW, p);
    vgao(Pdata, r>>(32-d));
    vgao(Pdata, g>>(32-d));
    vgao(Pdata, b>>(32-d));
    unlock(&cursor);

    return ~0;
}
@

<<function setcolor>>=
/*
 * On some video cards (e.g. Mach64), the palette is used as the 
 * DAC registers for >8-bit modes.  We don't want to set them when the user
 * is trying to set a colormap and the card is in one of these modes.
 */
int
setcolor(ulong p, ulong r, ulong g, ulong b)
{
    VGAscr *scr;
    int x;

    scr = &vgascreen[0];
    if(scr->gscreen == nil)
        return 0;

    switch(scr->gscreen->depth){
    case 1:
    case 2:
    case 4:
        x = 0x0F;
        break;
    case 8:
        x = 0xFF;
        break;
    default:
        return 0;
    }
    p &= x;

    return setpalette(p, r, g, b);
}
@

<<function cursoron>>=
int
cursoron(bool dolock)
{
    VGAscr *scr;
    int v;

    scr = &vgascreen[0];
    if(scr->cur == nil || scr->cur->move == nil)
        return 0;

    if(dolock)
        lock(&cursor);
    v = scr->cur->move(scr, mousexy());
    if(dolock)
        unlock(&cursor);

    return v;
}
@

<<function cursoroff>>=
void
cursoroff(int)
{
}
@

<<function ksetcursor>>=
void
ksetcursor(Cursor* curs)
{
    VGAscr *scr;

    scr = &vgascreen[0];
    if(scr->cur == nil || scr->cur->load == nil)
        return;

    scr->cur->load(scr, curs);
}
@

<<global hwaccel>>=
int hwaccel = 1;
@

<<global hwblank>>=
int hwblank = 0;    /* turned on by drivers that are known good */
@

<<global panning>>=
int panning = 0;
@

<<function hwdraw>>=
//@Scheck: not dead, actually this is overriding some def in libmemdraw!! ugly
int hwdraw(Memdrawparam *par)
{
    VGAscr *scr;
    Memimage *dst, *src, *mask;
    int m;

    if(hwaccel == 0)
        return 0;

    scr = &vgascreen[0];
    if((dst=par->dst) == nil || dst->data == nil)
        return 0;
    if((src=par->src) == nil || src->data == nil)
        return 0;
    if((mask=par->mask) == nil || mask->data == nil)
        return 0;

    if(scr->cur == &swcursor){
        /*
         * always calling swcursorhide here doesn't cure
         * leaving cursor tracks nor failing to refresh menus
         * with the latest libmemdraw/draw.c.
         */
        if(dst->data->bdata == gscreendata.bdata)
            swcursoravoid(par->r);
        if(src->data->bdata == gscreendata.bdata)
            swcursoravoid(par->sr);
        if(mask->data->bdata == gscreendata.bdata)
            swcursoravoid(par->mr);
    }
    
    if(dst->data->bdata != gscreendata.bdata)
        return 0;

    if(scr->fill==nil && scr->scroll==nil)
        return 0;

    /*
     * If we have an opaque mask and source is one opaque
     * pixel we can convert to the destination format and just
     * replicate with memset.
     */
    m = Simplesrc|Simplemask|Fullmask;
    if(scr->fill
    && (par->state&m)==m
    && ((par->srgba&0xFF) == 0xFF)
    && (par->op&S) == S)
        return scr->fill(scr, par->r, par->sdval);

    /*
     * If no source alpha, an opaque mask, we can just copy the
     * source onto the destination.  If the channels are the same and
     * the source is not replicated, memmove suffices.
     */
    m = Simplemask|Fullmask;
    if(scr->scroll
    && src->data->bdata==dst->data->bdata
    && !(src->flags&Falpha)
    && (par->state&m)==m
    && (par->op&S) == S)
        return scr->scroll(scr, par->r, par->sr);

    return 0;   
}
@

<<function blankscreen bis>>=
void
blankscreen(int blank)
{
    VGAscr *scr;

    scr = &vgascreen[0];
    if(hwblank){
        if(scr->blank)
            scr->blank(scr, blank);
        else
            vgablank(scr, blank);
    }
}
@

<<function vgalinearpciid>>=
void
vgalinearpciid(VGAscr *scr, int vid, int did)
{
    Pcidev *p;

    p = nil;
    while((p = pcimatch(p, vid, 0)) != nil){
        if(p->ccrb != 3)    /* video card */
            continue;
        if(did != 0 && p->did != did)
            continue;
        break;
    }
    if(p == nil)
        error("pci video card not found");

    scr->pci = p;
    vgalinearpci(scr);
}
@

<<function vgalinearpci>>=
void
vgalinearpci(VGAscr *scr)
{
    ulong paddr;
    int i, size, best;
    Pcidev *p;
    
    p = scr->pci;
    if(p == nil)
        return;

    /*
     * Scan for largest memory region on card.
     * Some S3 cards (e.g. Savage) have enormous
     * mmio regions (but even larger frame buffers).
     * Some 3dfx cards (e.g., Voodoo3) have mmio
     * buffers the same size as the frame buffer,
     * but only the frame buffer is marked as
     * prefetchable (bar&8).  If a card doesn't fit
     * into these heuristics, its driver will have to
     * call vgalinearaddr directly.
     */
    best = -1;
    for(i=0; i<nelem(p->mem); i++){
        if(p->mem[i].bar&1) /* not memory */
            continue;
        if(p->mem[i].size < 640*480)    /* not big enough */
            continue;
        if(best==-1 
        || p->mem[i].size > p->mem[best].size 
        || (p->mem[i].size == p->mem[best].size 
          && (p->mem[i].bar&8)
          && !(p->mem[best].bar&8)))
            best = i;
    }
    if(best >= 0){
        paddr = p->mem[best].bar & ~0x0F;
        size = p->mem[best].size;
        vgalinearaddr(scr, paddr, size);
        return;
    }
    error("no video memory found on pci card");
}
@

<<function vgalinearaddr>>=
void
vgalinearaddr(VGAscr *scr, ulong paddr, int size)
{
    int x, nsize;
    ulong npaddr;

    /*
     * new approach.  instead of trying to resize this
     * later, let's assume that we can just allocate the
     * entire window to start with.
     */

    if(scr->paddr == paddr && size <= scr->apsize)
        return;

    if(scr->paddr){
        /*
         * could call vunmap and vmap,
         * but worried about dangling pointers in devdraw
         */
        error("cannot grow vga frame buffer");
    }
    
    /* round to page boundary, just in case */
    x = paddr&(BY2PG-1);
    npaddr = paddr-x;
    nsize = PGROUND(size+x);

    /*
     * Don't bother trying to map more than 4000x4000x32 = 64MB.
     * We only have a 256MB window.
     */
    if(nsize > 64*MB)
        nsize = 64*MB;
    scr->vaddr = vmap(npaddr, nsize);
    if(scr->vaddr == 0)
        error("cannot allocate vga frame buffer");
    scr->vaddr = (char*)scr->vaddr+x;
    scr->paddr = paddr;
    scr->apsize = nsize;
    /* let mtrr harmlessly fail on old CPUs, e.g., P54C */
    if(!waserror()){
        //mtrr(npaddr, nsize, "wc"); disabled mtrr
                error("mtrr disabled");
        poperror();
    }
}
@

<<global swvisible>>=
/*
 * Software cursor. 
 */
int swvisible;  /* is the cursor visible? */
@

<<global swenabled>>=
int swenabled;  /* is the cursor supposed to be on the screen? */
@

<<global swback>>=
Memimage*   swback; /* screen under cursor */
@

<<global swimg>>=
Memimage*   swimg;  /* cursor image */
@

<<global swmask>>=
Memimage*   swmask; /* cursor mask */
@

<<global swimg1>>=
Memimage*   swimg1;
@

<<global swmask1>>=
Memimage*   swmask1;
@

<<global swoffset>>=
Point   swoffset;
@

<<global swrect>>=
Rectangle   swrect; /* screen rectangle in swback */
@

<<global swpt>>=
Point   swpt;   /* desired cursor location */
@

<<global swvispt>>=
Point   swvispt;    /* actual cursor location */
@

<<global swvers>>=
int swvers; /* incremented each time cursor image changes */
@

<<global swvisvers>>=
int swvisvers;  /* the version on the screen */
@

<<function swcursorhide>>=
/*
 * called with drawlock locked for us, most of the time.
 * kernel prints at inopportune times might mean we don't
 * hold the lock, but memimagedraw is now reentrant so
 * that should be okay: worst case we get cursor droppings.
 */
void
swcursorhide(void)
{
    if(swvisible == 0)
        return;
    if(swback == nil)
        return;
    swvisible = 0;
    memimagedraw(gscreen, swrect, swback, ZP, memopaque, ZP, S);
    flushmemscreen(swrect);
}
@

<<function swcursoravoid>>=
void
swcursoravoid(Rectangle r)
{
    if(swvisible && rectXrect(r, swrect))
        swcursorhide();
}
@

<<function swcursordraw>>=
void
swcursordraw(void)
{
    if(swvisible)
        return;
    if(swenabled == 0)
        return;
    if(swback == nil || swimg1 == nil || swmask1 == nil)
        return;
    assert(!canqlock(&drawlock));
    swvispt = swpt;
    swvisvers = swvers;
    swrect = rectaddpt(Rect(0,0,16,16), swvispt);
    memimagedraw(swback, swback->r, gscreen, swpt, memopaque, ZP, S);
    memimagedraw(gscreen, swrect, swimg1, ZP, swmask1, ZP, SoverD);
    flushmemscreen(swrect);
    swvisible = 1;
}
@

<<function swenable>>=
/*
 * Need to lock drawlock for ourselves.
 */
void
swenable(VGAscr*)
{
    swenabled = 1;
    if(canqlock(&drawlock)){
        swcursordraw();
        qunlock(&drawlock);
    }
}
@

<<function swdisable>>=
void
swdisable(VGAscr*)
{
    swenabled = 0;
    if(canqlock(&drawlock)){
        swcursorhide();
        qunlock(&drawlock);
    }
}
@

<<function swload>>=
void
swload(VGAscr*, Cursor *curs)
{
    uchar *ip, *mp;
    int i, j, set, clr;

    if(!swimg || !swmask || !swimg1 || !swmask1)
        return;
    /*
     * Build cursor image and mask.
     * Image is just the usual cursor image
     * but mask is a transparent alpha mask.
     * 
     * The 16x16x8 memimages do not have
     * padding at the end of their scan lines.
     */
    ip = byteaddr(swimg, ZP);
    mp = byteaddr(swmask, ZP);
    for(i=0; i<32; i++){
        set = curs->set[i];
        clr = curs->clr[i];
        for(j=0x80; j; j>>=1){
            *ip++ = set&j ? 0x00 : 0xFF;
            *mp++ = (clr|set)&j ? 0xFF : 0x00;
        }
    }
    swoffset = curs->offset;
    swvers++;
    memimagedraw(swimg1, swimg1->r, swimg, ZP, memopaque, ZP, S);
    memimagedraw(swmask1, swmask1->r, swmask, ZP, memopaque, ZP, S);
}
@

<<function swmove>>=
int
swmove(VGAscr*, Point p)
{
    swpt = addpt(p, swoffset);
    return 0;
}
@

<<function swcursorclock>>=
void
swcursorclock(void)
{
    int x;

    if(!swenabled)
        return;
    if(swvisible && eqpt(swpt, swvispt) && swvers==swvisvers)
        return;

    x = splhi();
    if(swenabled)
    if(!swvisible || !eqpt(swpt, swvispt) || swvers!=swvisvers)
    if(canqlock(&drawlock)){
        swcursorhide();
        swcursordraw();
        qunlock(&drawlock);
    }
    splx(x);
}
@

<<function swcursorinit>>=
void
swcursorinit(void)
{
    static int init, warned;
    VGAscr *scr;

    didswcursorinit = 1;
    if(!init){
        init = 1;
        addclock0link(swcursorclock, 10);
    }
    scr = &vgascreen[0];
    if(scr==nil || scr->gscreen==nil)
        return;

    if(scr->dev == nil || scr->dev->linear == nil){
        if(!warned){
            print("cannot use software cursor on non-linear vga screen\n");
            warned = 1;
        }
        return;
    }

    if(swback){
        freememimage(swback);
        freememimage(swmask);
        freememimage(swmask1);
        freememimage(swimg);
        freememimage(swimg1);
    }

    swback = allocmemimage(Rect(0,0,32,32), gscreen->chan);
    swmask = allocmemimage(Rect(0,0,16,16), GREY8);
    swmask1 = allocmemimage(Rect(0,0,16,16), GREY1);
    swimg = allocmemimage(Rect(0,0,16,16), GREY8);
    swimg1 = allocmemimage(Rect(0,0,16,16), GREY1);
    if(swback==nil || swmask==nil || swmask1==nil || swimg==nil || swimg1 == nil){
        print("software cursor: allocmemimage fails");
        return;
    }

    memfillcolor(swmask, DOpaque);
    memfillcolor(swmask1, DOpaque);
    memfillcolor(swimg, DBlack);
    memfillcolor(swimg1, DBlack);
}
@

<<global swcursor>>=
VGAcur swcursor =
{
    "soft",
    swenable,
    swdisable,
    swload,
    swmove,
};
@


%-------------------------------------------------------------

<<kernel/devices/screen/386/screen.c>>=
#include "u.h"
#include "../port/lib.h"
#include "../port/error.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"

#include "io.h"
#include <ureg.h>

#include <draw.h>
#include <memdraw.h>
#include <cursor.h>
#include "screen.h"

//#define RGB2K(r,g,b)    ((156763*(r)+307758*(g)+59769*(b))>>19)

extern void swcursorhide(void);
extern void swcursoravoid(Rectangle);
extern void vgalinearpci(VGAscr*);


//already in libdraw/arith.c
<<global physgscreenr>>

<<global gscreendata>>
<<global gscreen>>

<<global vgascreen>>

<<global arrow>>

<<global didswcursorinit>>

<<global softscreen>>

<<function screensize>>

<<function screenaperture>>

<<function attachscreen>>

<<function flushmemscreen>>

<<function getcolor>>

<<function setpalette>>

<<function setcolor>>

<<function cursoron>>

<<function cursoroff>>

<<function ksetcursor>>

<<global hwaccel>>
<<global hwblank>>
<<global panning>>

<<function hwdraw>>

<<function blankscreen bis>>

<<function vgalinearpciid>>

<<function vgalinearpci>>

<<function vgalinearaddr>>


<<global swvisible>>
<<global swenabled>>
<<global swback>>
<<global swimg>>
<<global swmask>>
<<global swimg1>>
<<global swmask1>>

<<global swoffset>>
<<global swrect>>
<<global swpt>>
<<global swvispt>>
<<global swvers>>
<<global swvisvers>>

<<function swcursorhide>>

<<function swcursoravoid>>

<<function swcursordraw>>

<<function swenable>>

<<function swdisable>>

<<function swload>>

<<function swmove>>

<<function swcursorclock>>

<<function swcursorinit>>

<<global swcursor>>

@


\subsection*{[[kernel/devices/screen/386/screen.h]]}

<<struct Cursorinfo>>=
struct Cursorinfo {
  Cursor;
  Lock;
};
@

<<enum _anon_ (kernel/devices/screen/386/screen.h)>>=
/*
 * Generic VGA registers.
 */
enum {
  MiscW   = 0x03C2, /* Miscellaneous Output (W) */
  MiscR   = 0x03CC, /* Miscellaneous Output (R) */
  Status0   = 0x03C2, /* Input status 0 (R) */
  Status1   = 0x03DA, /* Input Status 1 (R) */
  FeatureR  = 0x03CA, /* Feature Control (R) */
  FeatureW  = 0x03DA, /* Feature Control (W) */

  Seqx    = 0x03C4, /* Sequencer Index, Data at Seqx+1 */
  Crtx    = 0x03D4, /* CRT Controller Index, Data at Crtx+1 */
  Grx   = 0x03CE, /* Graphics Controller Index, Data at Grx+1 */
  Attrx   = 0x03C0, /* Attribute Controller Index and Data */

  PaddrW    = 0x03C8, /* Palette Address Register, write */
  Pdata   = 0x03C9, /* Palette Data Register */
  Pixmask   = 0x03C6, /* Pixel Mask Register */
  PaddrR    = 0x03C7, /* Palette Address Register, read */
  Pstatus   = 0x03C7, /* DAC Status (RO) */

  Pcolours  = 256,    /* Palette */
  Pred    = 0,
  Pgreen    = 1,
  Pblue   = 2,

  Pblack    = 0x00,
  Pwhite    = 0xFF,
};
@

<<function VGAMEM>>=
#define VGAMEM()  0xA0000
@

<<function vgao>>=
//#define vgai(port)    inb(port)
#define vgao(port, data)  outb(port, data)
@

<<struct VGAdev>>=
struct VGAdev {
  char* name;

  void  (*enable)(VGAscr*);
  void  (*disable)(VGAscr*);
  void  (*page)(VGAscr*, int);
  void  (*linear)(VGAscr*, int, int);
  void  (*drawinit)(VGAscr*);
  int (*fill)(VGAscr*, Rectangle, ulong);
  void  (*ovlctl)(VGAscr*, Chan*, void*, int);
  int (*ovlwrite)(VGAscr*, void*, int, vlong);
  void (*flush)(VGAscr*, Rectangle);
};
@

<<struct VGAcur>>=
struct VGAcur {
  char* name;

  void  (*enable)(VGAscr*);
  void  (*disable)(VGAscr*);
  void  (*load)(VGAscr*, Cursor*);
  int (*move)(VGAscr*, Point);

  int doespanning;
};
@

<<struct VGAscr>>=
/*
 */
struct VGAscr {
  Lock  devlock;
  VGAdev* dev;
  Pcidev* pci;

  VGAcur* cur;
  ulong storage;
  Cursor;

  int useflush;

  ulong paddr;    /* frame buffer */
  void* vaddr;
  int   apsize;

  ulong io;       /* device specific registers */
  ulong *mmio;
  
  ulong colormap[Pcolours][3];
  int palettedepth;

  Memimage* gscreen;
  Memdata* gscreendata;
  Memsubfont* memdefont;

  int (*fill)(VGAscr*, Rectangle, ulong);
  int (*scroll)(VGAscr*, Rectangle, Rectangle);
  void  (*blank)(VGAscr*, int);
  ulong id; /* internal identifier for driver use */
  int isblank;
  int overlayinit;
};
@

<<enum _anon_ (kernel/devices/screen/386/screen.h)2>>=
enum {
  Backgnd   = 0,  /* black */
};
@

<<function ishwimage>>=
#define ishwimage(i)  (vgascreen[0].gscreendata && (i)->data->bdata == vgascreen[0].gscreendata->bdata)
@


%-------------------------------------------------------------

<<kernel/devices/screen/386/screen.h>>=
typedef struct Cursor Cursor;
typedef struct Cursorinfo Cursorinfo;
<<struct Cursorinfo>>

/* devmouse.c */
extern void mousetrack(int, int, int, int);
extern Point mousexy(void);
extern void mouseaccelerate(int);

extern Cursorinfo cursor;
extern Cursor arrow;

<<enum _anon_ (kernel/devices/screen/386/screen.h)>>

<<function VGAMEM>>
<<function vgao>>

extern int vgaxi(long, uchar);
extern int vgaxo(long, uchar, uchar);

/*
 */
typedef struct VGAdev VGAdev;
typedef struct VGAcur VGAcur;
typedef struct VGAscr VGAscr;

<<struct VGAdev>>

<<struct VGAcur>>

<<struct VGAscr>>

extern VGAscr vgascreen[];

<<enum _anon_ (kernel/devices/screen/386/screen.h)2>>

/* mouse.c */
extern void kmousectl(Cmdbuf*);
//now in portfns_devices.h: extern void mouseresize(void);

/* screen.c */
extern int    hwaccel;  /* use hw acceleration; default on */
extern int    hwblank;  /* use hw blanking; default on */
extern int    panning;  /* use virtual screen panning; default off */
extern void addvgaseg(char*, ulong, ulong);
extern uchar* attachscreen(Rectangle*, ulong*, int*, int*, int*);
extern void flushmemscreen(Rectangle);
extern int  cursoron(int);
extern void cursoroff(int);
extern void ksetcursor(Cursor*);
extern int  screensize(int, int, int, ulong);
extern int  screenaperture(int, int);
extern Rectangle physgscreenr;  /* actual monitor size */
extern void blankscreen(int);

extern VGAcur swcursor;
extern void swcursorinit(void);
//extern void swcursorhide(void);
//extern void swcursoravoid(Rectangle);
//extern void swcursorunhide(void);

/* devdraw.c */
extern void deletescreenimage(void);
extern void resetscreenimage(void);
extern ulong  blanktime;
//extern int    drawhasclients(void);
//extern void setscreenimageclipr(Rectangle);
//extern void drawflush(void);
extern int drawidletime(void);
extern QLock  drawlock;

/* vga.c */
extern void vgascreenwin(VGAscr*);
extern void vgaimageinit(ulong);
extern void vgalinearpciid(VGAscr*, int, int);
extern void vgalinearaddr(VGAscr*, ulong, int);

extern void drawblankscreen(int);
extern void vgablank(VGAscr*, int);

extern Lock vgascreenlock;

<<function ishwimage>>
@


\subsection*{[[kernel/devices/screen/386/vga.c]]}

<<global back2>>=
static Memimage* back;
@

<<global conscol>>=
static Memimage *conscol;
@

<<global curpos>>=
static Point curpos;
@

<<global window bis>>=
static Rectangle window;
@

<<global xp>>=
static int *xp;
@

<<global xbuf>>=
static int xbuf[256];
@

<<global vgascreenlock>>=
Lock vgascreenlock;
@

<<function vgaimageinit>>=
//int drawdebug;

void
vgaimageinit(ulong chan)
{
    if(back == nil){
        back = allocmemimage(Rect(0,0,1,1), chan);  /* RSC BUG */
        if(back == nil)
            panic("back alloc");        /* RSC BUG */
        back->flags |= Frepl;
        back->clipr = Rect(-0x3FFFFFF, -0x3FFFFFF, 0x3FFFFFF, 0x3FFFFFF);
        memfillcolor(back, DBlack);
    }

    if(conscol == nil){
        conscol = allocmemimage(Rect(0,0,1,1), chan);   /* RSC BUG */
        if(conscol == nil)
            panic("conscol alloc"); /* RSC BUG */
        conscol->flags |= Frepl;
        conscol->clipr = Rect(-0x3FFFFFF, -0x3FFFFFF, 0x3FFFFFF, 0x3FFFFFF);
        memfillcolor(conscol, DWhite);
    }
}
@

<<function vgascroll>>=
static void
vgascroll(VGAscr* scr)
{
    int h, o;
    Point p;
    Rectangle r;

    h = scr->memdefont->height;
    o = 8*h;
    r = Rpt(window.min, Pt(window.max.x, window.max.y-o));
    p = Pt(window.min.x, window.min.y+o);
    memimagedraw(scr->gscreen, r, scr->gscreen, p, nil, p, S);
    r = Rpt(Pt(window.min.x, window.max.y-o), window.max);
    memimagedraw(scr->gscreen, r, back, ZP, nil, ZP, S);

    curpos.y -= o;
}
@

<<function vgascreenputc>>=
static void
vgascreenputc(VGAscr* scr, char* buf, Rectangle *flushr)
{
    Point p;
    int h, w, pos;
    Rectangle r;

//  drawdebug = 1;
    if(xp < xbuf || xp >= &xbuf[sizeof(xbuf)])
        xp = xbuf;

    h = scr->memdefont->height;
    switch(buf[0]){

    case '\n':
        if(curpos.y+h >= window.max.y){
            vgascroll(scr);
            *flushr = window;
        }
        curpos.y += h;
        vgascreenputc(scr, "\r", flushr);
        break;

    case '\r':
        xp = xbuf;
        curpos.x = window.min.x;
        break;

    case '\t':
        p = memsubfontwidth(scr->memdefont, " ");
        w = p.x;
        if(curpos.x >= window.max.x-4*w)
            vgascreenputc(scr, "\n", flushr);

        pos = (curpos.x-window.min.x)/w;
        pos = 4-(pos%4);
        *xp++ = curpos.x;
        r = Rect(curpos.x, curpos.y, curpos.x+pos*w, curpos.y + h);
        memimagedraw(scr->gscreen, r, back, back->r.min, nil, back->r.min, S);
        curpos.x += pos*w;
        break;

    case '\b':
        if(xp <= xbuf)
            break;
        xp--;
        r = Rect(*xp, curpos.y, curpos.x, curpos.y+h);
        memimagedraw(scr->gscreen, r, back, back->r.min, nil, ZP, S);
        combinerect(flushr, r);
        curpos.x = *xp;
        break;

    case '\0':
        break;

    default:
        p = memsubfontwidth(scr->memdefont, buf);
        w = p.x;

        if(curpos.x >= window.max.x-w)
            vgascreenputc(scr, "\n", flushr);

        *xp++ = curpos.x;
        r = Rect(curpos.x, curpos.y, curpos.x+w, curpos.y+h);
        memimagedraw(scr->gscreen, r, back, back->r.min, nil, back->r.min, S);
        memimagestring(scr->gscreen, curpos, conscol, ZP, scr->memdefont, buf);
        combinerect(flushr, r);
        curpos.x += w;
    }
//  drawdebug = 0;
}
@

<<function vgascreenputs>>=
static void
vgascreenputs(char* s, int n)
{
    int i, gotdraw;
    Rune r;
    char buf[4];
    VGAscr *scr;
    Rectangle flushr;

    scr = &vgascreen[0];

    if(!islo()){
        /*
         * Don't deadlock trying to
         * print in an interrupt.
         */
        if(!canlock(&vgascreenlock))
            return;
    }
    else
        lock(&vgascreenlock);

    /*
     * Be nice to hold this, but not going to deadlock
     * waiting for it.  Just try and see.
     */
    gotdraw = canqlock(&drawlock);

    flushr = Rect(10000, 10000, -10000, -10000);

    while(n > 0){
        i = chartorune(&r, s);
        if(i == 0){
            s++;
            --n;
            continue;
        }
        memmove(buf, s, i);
        buf[i] = 0;
        n -= i;
        s += i;
        vgascreenputc(scr, buf, &flushr);
    }
    flushmemscreen(flushr);

    if(gotdraw)
        qunlock(&drawlock);
    unlock(&vgascreenlock);
}
@

<<function vgascreenwin>>=
void
vgascreenwin(VGAscr* scr)
{
    int h, w;

    h = scr->memdefont->height;
    w = scr->memdefont->info[' '].width;

    window = insetrect(scr->gscreen->r, 48);
    window.max.x = window.min.x+((window.max.x-window.min.x)/w)*w;
    window.max.y = window.min.y+((window.max.y-window.min.y)/h)*h;
    curpos = window.min;

    screenputs = vgascreenputs;
}
@

<<function vgablank>>=
/*
 * Supposedly this is the way to turn DPMS
 * monitors off using just the VGA registers.
 * Unfortunately, it seems to mess up the video mode
 * on the cards I've tried.
 */
void
vgablank(VGAscr*, int blank)
{
    uchar seq1, crtc17;

    if(blank) {
        seq1 = 0x00;
        crtc17 = 0x80;
    } else {
        seq1 = 0x20;
        crtc17 = 0x00;
    }

    outs(Seqx, 0x0100);         /* synchronous reset */
    seq1 |= vgaxi(Seqx, 1) & ~0x20;
    vgaxo(Seqx, 1, seq1);
    crtc17 |= vgaxi(Crtx, 0x17) & ~0x80;
    delay(10);
    vgaxo(Crtx, 0x17, crtc17);
    outs(Crtx, 0x0300);             /* end synchronous reset */
}
@

<<function addvgaseg>>=
void
addvgaseg(char *name, ulong pa, ulong size)
{
    Physseg seg;

    memset(&seg, 0, sizeof seg);
    seg.attr = SG_PHYSICAL;
    seg.name = name;
    seg.pa = pa;
    seg.size = size;
    addphysseg(&seg);
}
@


%-------------------------------------------------------------

<<kernel/devices/screen/386/vga.c>>=
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"
#include "io.h"
#include "../port/error.h"

#include <draw.h>
#include <memdraw.h>
#include <cursor.h>
#include "screen.h"

<<global back2>>
<<global conscol>>

<<global curpos>>
<<global window bis>>
<<global xp>>
<<global xbuf>>
<<global vgascreenlock>>
<<function vgaimageinit>>

<<function vgascroll>>

<<function vgascreenputc>>

<<function vgascreenputs>>

<<function vgascreenwin>>

<<function vgablank>>

<<function addvgaseg>>

//void
//cornerstring(char *s)
//{
//  int h, w;
//  VGAscr *scr;
//  Rectangle r;
//  Point p;
//
//  scr = &vgascreen[0];
//  if(scr->vaddr == nil || screenputs != vgascreenputs)
//      return;
//  p = memsubfontwidth(scr->memdefont, s);
//  w = p.x;
//  h = scr->memdefont->height;
//
//  r = Rect(0, 0, w, h);
//  memimagedraw(scr->gscreen, r, back, back->r.min, nil, back->r.min, S);
//  memimagestring(scr->gscreen, r.min, conscol, ZP, scr->memdefont, s);
////    flushmemscreen(r);
//}
@


\subsection*{[[kernel/devices/screen/386/vgaclgd542x.c]]}

<<function clgd542xpageset>>=
static int
clgd542xpageset(VGAscr*, int page)
{
    uchar gr09;
    int opage;
    
    if(vgaxi(Seqx, 0x07) & 0xF0)
        page = 0;
    gr09 = vgaxi(Grx, 0x09);
    if(vgaxi(Grx, 0x0B) & 0x20){
        vgaxo(Grx, 0x09, page<<2);
        opage = gr09>>2;
    }
    else{
        vgaxo(Grx, 0x09, page<<4);
        opage = gr09>>4;
    }

    return opage;
}
@

<<function clgd542xpage>>=
static void
clgd542xpage(VGAscr* scr, int page)
{
    lock(&scr->devlock);
    clgd542xpageset(scr, page);
    unlock(&scr->devlock);
}
@

<<function clgd542xlinear>>=
static void
clgd542xlinear(VGAscr* scr, int, int)
{
    vgalinearpciid(scr, 0x1013, 0);
}
@

<<function clgd542xdisable>>=
static void
clgd542xdisable(VGAscr*)
{
    uchar sr12;

    sr12 = vgaxi(Seqx, 0x12);
    vgaxo(Seqx, 0x12, sr12 & ~0x01);
}
@

<<function clgd542xenable>>=
static void
clgd542xenable(VGAscr* scr)
{
    uchar sr12;
    int mem, x;
 
    /*
     * Disable the cursor.
     */
    sr12 = vgaxi(Seqx, 0x12);
    vgaxo(Seqx, 0x12, sr12 & ~0x01);

    /*
     * Cursor colours.
     * Can't call setcolor here as cursor is already locked.
     */
    vgaxo(Seqx, 0x12, sr12|0x02);
    vgao(PaddrW, 0x00);
    vgao(Pdata, Pwhite);
    vgao(Pdata, Pwhite);
    vgao(Pdata, Pwhite);
    vgao(PaddrW, 0x0F);
    vgao(Pdata, Pblack);
    vgao(Pdata, Pblack);
    vgao(Pdata, Pblack);
    vgaxo(Seqx, 0x12, sr12);

    mem = 0;
    switch(vgaxi(Crtx, 0x27) & ~0x03){

    case 0x88:              /* CL-GD5420 */
    case 0x8C:              /* CL-GD5422 */
    case 0x94:              /* CL-GD5424 */
    case 0x80:              /* CL-GD5425 */
    case 0x90:              /* CL-GD5426 */
    case 0x98:              /* CL-GD5427 */
    case 0x9C:              /* CL-GD5429 */
        /*
         * The BIOS leaves the memory size in Seq0A, bits 4 and 3.
         * See Technical Reference Manual Appendix E1, Section 1.3.2.
         *
         * The storage area for the 64x64 cursors is the last 16Kb of
         * display memory.
         */
        mem = (vgaxi(Seqx, 0x0A)>>3) & 0x03;
        break;

    case 0xA0:              /* CL-GD5430 */
    case 0xA8:              /* CL-GD5434 */
    case 0xAC:              /* CL-GD5436 */
    case 0xB8:              /* CL-GD5446 */
    case 0x30:              /* CL-GD7543 */
        /*
         * Attempt to intuit the memory size from the DRAM control
         * register. Minimum is 512KB.
         * If DRAM bank switching is on then there's double.
         */
        x = vgaxi(Seqx, 0x0F);
        mem = (x>>3) & 0x03;
        if(x & 0x80)
            mem++;
        break;

    case 0xBC:              /* CL-GD5480 */
        mem = 2;            /* 1024 = 256<<2 */
        x = vgaxi(Seqx, 0x0F);
        if((x & 0x18) == 0x18){
            mem <<= 1;      /* 2048 = 256<<3 */
            if(x & 0x80)
                mem <<= 2;  /* 2048 = 256<<4 */
        }
        if(vgaxi(Seqx, 0x17) & 0x80)
            mem <<= 1;
        break;

    default:                /* uh, ah dunno */
        break;
    }
    scr->storage = ((256<<mem)-16)*1024;

    /*
     * Set the current cursor to index 0
     * and turn the 64x64 cursor on.
     */
    vgaxo(Seqx, 0x13, 0);
    vgaxo(Seqx, 0x12, sr12|0x05);
}
@

<<function clgd542xinitcursor>>=
static void
clgd542xinitcursor(VGAscr* scr, int xo, int yo, int index)
{
    uchar *p, seq07;
    uint p0, p1;
    int opage, x, y;

    /*
     * Is linear addressing turned on? This will determine
     * how we access the cursor storage.
     */
    seq07 = vgaxi(Seqx, 0x07);
    opage = 0;
    p = scr->vaddr;
    if(!(seq07 & 0xF0)){
        lock(&scr->devlock);
        opage = clgd542xpageset(scr, scr->storage>>16);
        p += (scr->storage & 0xFFFF);
    }
    else
        p += scr->storage;
    p += index*1024;

    for(y = yo; y < 16; y++){
        p0 = scr->set[2*y];
        p1 = scr->set[2*y+1];
        if(xo){
            p0 = (p0<<xo)|(p1>>(8-xo));
            p1 <<= xo;
        }
        *p++ = p0;
        *p++ = p1;

        for(x = 16; x < 64; x += 8)
            *p++ = 0x00;

        p0 = scr->clr[2*y]|scr->set[2*y];
        p1 = scr->clr[2*y+1]|scr->set[2*y+1];
        if(xo){
            p0 = (p0<<xo)|(p1>>(8-xo));
            p1 <<= xo;
        }
        *p++ = p0;
        *p++ = p1;

        for(x = 16; x < 64; x += 8)
            *p++ = 0x00;
    }
    while(y < 64+yo){
        for(x = 0; x < 64; x += 8){
            *p++ = 0x00;
            *p++ = 0x00;
        }
        y++;
    }

    if(!(seq07 & 0xF0)){
        clgd542xpageset(scr, opage);
        unlock(&scr->devlock);
    }
}
@

<<function clgd542xload>>=
static void
clgd542xload(VGAscr* scr, Cursor* curs)
{
    uchar sr12;

    /*
     * Disable the cursor.
     */
    sr12 = vgaxi(Seqx, 0x12);
    vgaxo(Seqx, 0x12, sr12 & ~0x01);

    memmove(&scr->Cursor, curs, sizeof(Cursor));
    clgd542xinitcursor(scr, 0, 0, 0);

    /*
     * Enable the cursor.
     */
    vgaxo(Seqx, 0x13, 0);
    vgaxo(Seqx, 0x12, sr12|0x05);
}
@

<<function clgd542xmove>>=
static int
clgd542xmove(VGAscr* scr, Point p)
{
    int index, x, xo, y, yo;

    index = 0;
    if((x = p.x+scr->offset.x) < 0){
        xo = -x;
        x = 0;
    }
    else
        xo = 0;
    if((y = p.y+scr->offset.y) < 0){
        yo = -y;
        y = 0;
    }
    else
        yo = 0;

    if(xo || yo){
        clgd542xinitcursor(scr, xo, yo, 1);
        index = 1;
    }
    vgaxo(Seqx, 0x13, index<<2);
    
    vgaxo(Seqx, 0x10|((x & 0x07)<<5), (x>>3) & 0xFF);
    vgaxo(Seqx, 0x11|((y & 0x07)<<5), (y>>3) & 0xFF);

    return 0;
}
@

<<global vgaclgd542xdev>>=
VGAdev vgaclgd542xdev = {
    "clgd542x",

    0,
    0,
    clgd542xpage,
    clgd542xlinear,
};
@

<<global vgaclgd542xcur>>=
VGAcur vgaclgd542xcur = {
    "clgd542xhwgc",

    clgd542xenable,
    clgd542xdisable,
    clgd542xload,
    clgd542xmove,
};
@


%-------------------------------------------------------------

<<kernel/devices/screen/386/vgaclgd542x.c>>=
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"
#include "io.h"
#include "../port/error.h"

#include <draw.h>
#include <memdraw.h>
#include <cursor.h>
#include "screen.h"

<<function clgd542xpageset>>

<<function clgd542xpage>>

<<function clgd542xlinear>>

<<function clgd542xdisable>>

<<function clgd542xenable>>

<<function clgd542xinitcursor>>

<<function clgd542xload>>

<<function clgd542xmove>>

<<global vgaclgd542xdev>>

<<global vgaclgd542xcur>>
@


\subsection*{[[kernel/devices/screen/386/vgavesa.c]]}

<<enum _anon_ (kernel/devices/screen/386/vgavesa.c)>>=
enum {
    Usesoftscreen = 1,
};
@

<<global hardscreen>>=
static void *hardscreen;
@

<<global modebuf>>=
static uchar modebuf[0x1000];
@

<<function WORD>>=
// pad: seems similar to macros in fcall.h, factorize?
#define WORD(p) ((p)[0] | ((p)[1]<<8))
@

<<function LONG>>=
#define LONG(p) ((p)[0] | ((p)[1]<<8) | ((p)[2]<<16) | ((p)[3]<<24))
@

<<function vbesetup>>=
//#define PLONG(p, v) do{(p)[0] = (v); (p)[1] = (v)>>8; (p)[2] = (v)>>16; (p)[3] = (v)>>24;}while(0)

static uchar*
vbesetup(Ureg *u, int ax)
{
    ulong pa;

    pa = PADDR(RMBUF);
    memset(modebuf, 0, sizeof modebuf);
    memset(u, 0, sizeof *u);
    u->ax = ax;
    u->es = (pa>>4)&0xF000;
    u->di = pa&0xFFFF;
    return modebuf;
}
@

<<function vbecall>>=
static void
vbecall(Ureg *u)
{
    Chan *creg, *cmem;
    ulong pa;

    cmem = namec("/dev/realmodemem", Aopen, ORDWR, 0);
    if(waserror()){
        cclose(cmem);
        nexterror();
    }
    creg = namec("/dev/realmode", Aopen, ORDWR, 0);
    if(waserror()){
        cclose(creg);
        nexterror();
    }
    pa = PADDR(RMBUF);
    /* TODO: check read and write return values */
    devtab[cmem->type]->write(cmem, modebuf, sizeof modebuf, pa);
    u->trap = 0x10;
    devtab[creg->type]->write(creg, u, sizeof *u, 0);

    devtab[creg->type]->read(creg, u, sizeof *u, 0);
    if((u->ax&0xFFFF) != 0x004F)
        error("vesa bios error");
    devtab[cmem->type]->read(cmem, modebuf, sizeof modebuf, pa);

    poperror();
    cclose(creg);
    poperror();
    cclose(cmem);
}
@

<<function vbecheck>>=
static void
vbecheck(void)
{
    Ureg u;
    uchar *p;

    p = vbesetup(&u, 0x4F00);
    strcpy((char*)p, "VBE2");
    vbecall(&u);
    if(memcmp((char*)p, "VESA", 4) != 0)
        error("bad vesa signature");
    if(p[5] < 2)
        error("bad vesa version");
}
@

<<function vbegetmode>>=
static int
vbegetmode(void)
{
    Ureg u;

    vbesetup(&u, 0x4F03);
    vbecall(&u);
    return u.bx;
}
@

<<function vbemodeinfo>>=
static uchar*
vbemodeinfo(int mode)
{
    uchar *p;
    Ureg u;

    p = vbesetup(&u, 0x4F01);
    u.cx = mode;
    vbecall(&u);
    return p;
}
@

<<function vesalinear>>=
static void
vesalinear(VGAscr *scr, int, int)
{
    int i, mode, size, havesize;
    uchar *p;
    ulong paddr;
    Pcidev *pci;

    if(hardscreen) {
        scr->vaddr = 0;
        scr->paddr = scr->apsize = 0;
        return;
    }

    vbecheck();
    mode = vbegetmode();
    /*
     * bochs loses the top bits - cannot use this
    if((mode&(1<<14)) == 0)
        error("not in linear graphics mode");
     */
    mode &= 0x3FFF;
    p = vbemodeinfo(mode);
    if(!(WORD(p+0) & (1<<4)))
        error("not in VESA graphics mode");
    if(!(WORD(p+0) & (1<<7)))
        error("not in linear graphics mode");

    paddr = LONG(p+40);
    size = WORD(p+20)*WORD(p+16);
    size = PGROUND(size);

    /*
     * figure out max size of memory so that we have
     * enough if the screen is resized.
     */
    pci = nil;
    havesize = 0;
    while(!havesize && (pci = pcimatch(pci, 0, 0)) != nil){
        if(pci->ccrb != Pcibcdisp)
            continue;
        for(i=0; i<nelem(pci->mem); i++)
            if(paddr == (pci->mem[i].bar&~0x0F)){
                if(pci->mem[i].size > size)
                    size = pci->mem[i].size;
                havesize = 1;
                break;
            }
    }

    /* no pci - heuristic guess */
    if (!havesize)
        if(size < 4*1024*1024)
            size = 4*1024*1024;
        else
            size = ROUND(size, 1024*1024);
    if(size > 16*1024*1024)     /* arbitrary */
        size = 16*1024*1024;

    vgalinearaddr(scr, paddr, size);
    if(scr->apsize)
        addvgaseg("vesascreen", scr->paddr, scr->apsize);

    if(Usesoftscreen){
        hardscreen = scr->vaddr;
        scr->vaddr = 0;
        scr->paddr = scr->apsize = 0;
    }
}
@

<<function vesaflush>>=
static void
vesaflush(VGAscr *scr, Rectangle r)
{
    int t, w, wid, off;
    ulong *hp, *sp, *esp;

    if(hardscreen == nil)
        return;
    if(rectclip(&r, scr->gscreen->r) == 0)
        return;
    sp = (ulong*)(scr->gscreendata->bdata + scr->gscreen->zero);
    t = (r.max.x * scr->gscreen->depth + 2*BI2WD-1) / BI2WD;
    w = (r.min.x * scr->gscreen->depth) / BI2WD;
    w = (t - w) * BY2WD;
    wid = scr->gscreen->width;
    off = r.min.y * wid + (r.min.x * scr->gscreen->depth) / BI2WD;

    hp = hardscreen;
    hp += off;
    sp += off;
    esp = sp + Dy(r) * wid;
    while(sp < esp){
        memmove(hp, sp, w);
        hp += wid;
        sp += wid;
    }
}
@

<<global vgavesadev>>=
VGAdev vgavesadev = {
    "vesa",
    0,
    0,
    0,
    vesalinear,
    0,
    0,
    0,
    0,
    vesaflush,
};
@


%-------------------------------------------------------------

<<kernel/devices/screen/386/vgavesa.c>>=
/*
 * vga driver using just vesa bios to set up.
 *
 * note that setting hwaccel to zero will cause cursor ghosts to be
 * left behind.  hwaccel set non-zero repairs this.
 */
#include "u.h"
#include "../port/lib.h"
#include "../port/error.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"

#include "io.h"
#include <ureg.h>

#include <draw.h>
#include <memdraw.h>
#include <cursor.h>
#include "screen.h"

<<enum _anon_ (kernel/devices/screen/386/vgavesa.c)>>

<<global hardscreen>>
<<global modebuf>>

<<function WORD>>
<<function LONG>>
//#define PWORD(p, v) do{(p)[0] = (v); (p)[1] = (v)>>8;}while(0)
<<function vbesetup>>

<<function vbecall>>

<<function vbecheck>>

<<function vbegetmode>>

<<function vbemodeinfo>>

<<function vesalinear>>

<<function vesaflush>>

<<global vgavesadev>>
@


\subsection*{[[kernel/devices/screen/386/vgax.c]]}

<<global vgaxlock>>=
static Lock vgaxlock;           /* access to index registers */
@

<<function vgaxi>>=
int
vgaxi(long port, uchar index)
{
    uchar data;

    ilock(&vgaxlock);
    switch(port){

    case Seqx:
    case Crtx:
    case Grx:
        outb(port, index);
        data = inb(port+1);
        break;

    case Attrx:
        /*
         * Allow processor access to the colour
         * palette registers. Writes to Attrx must
         * be preceded by a read from Status1 to
         * initialise the register to point to the
         * index register and not the data register.
         * Processor access is allowed by turning
         * off bit 0x20.
         */
        inb(Status1);
        if(index < 0x10){
            outb(Attrx, index);
            data = inb(Attrx+1);
            inb(Status1);
            outb(Attrx, 0x20|index);
        }
        else{
            outb(Attrx, 0x20|index);
            data = inb(Attrx+1);
        }
        break;

    default:
        iunlock(&vgaxlock);
        return -1;
    }
    iunlock(&vgaxlock);

    return data & 0xFF;
}
@

<<function vgaxo>>=
int
vgaxo(long port, uchar index, uchar data)
{
    ilock(&vgaxlock);
    switch(port){

    case Seqx:
    case Crtx:
    case Grx:
        /*
         * We could use an outport here, but some chips
         * (e.g. 86C928) have trouble with that for some
         * registers.
         */
        outb(port, index);
        outb(port+1, data);
        break;

    case Attrx:
        inb(Status1);
        if(index < 0x10){
            outb(Attrx, index);
            outb(Attrx, data);
            inb(Status1);
            outb(Attrx, 0x20|index);
        }
        else{
            outb(Attrx, 0x20|index);
            outb(Attrx, data);
        }
        break;

    default:
        iunlock(&vgaxlock);
        return -1;
    }
    iunlock(&vgaxlock);

    return 0;
}
@


%-------------------------------------------------------------

<<kernel/devices/screen/386/vgax.c>>=
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"
#include "../port/error.h"

#include "io.h"

#include <draw.h>
#include <memdraw.h>
#include <cursor.h>
#include "screen.h"

<<global vgaxlock>>

<<function vgaxi>>

<<function vgaxo>>
@


\section{[[kernel/devices/screen/]]}

\subsection*{[[kernel/devices/screen/devdraw.c]]}

<<enum _anon_ (kernel/devices/screen/devdraw.c)>>=
enum
{
    Qtopdir     = 0,
    Qnew,
    Qwinname,
    Q3rd,
    Q2nd,
    Qcolormap,
    Qctl,
    Qdata,
    Qrefresh,
};
@

<<constant QSHIFT>>=
/*
 * Qid path is:
 *   4 bits of file type (qids above)
 *  24 bits of mux slot number +1; 0 means not attached to client
 */
#define QSHIFT  4   /* location in qid of client # */
@

<<function QID bis>>=
#define QID(q)      ((((ulong)(q).path)&0x0000000F)>>0)
@

<<function CLIENTPATH>>=
#define CLIENTPATH(q)   ((((ulong)q)&0x7FFFFFF0)>>QSHIFT)
@

<<constant NHASH bis>>=
//#define CLIENT(q)   CLIENTPATH((q).path)

#define NHASH       (1<<5)
@

<<constant HASHMASK>>=
#define HASHMASK    (NHASH-1)
@

<<constant IOUNIT>>=
#define IOUNIT      (64*1024)
@

<<global blanktime>>=
ulong blanktime = 30;   /* in minutes; a half hour */
@

<<struct KDraw>>=
struct KDraw
{
    int     clientid;
    int     nclient;
    Client**    client;
    int     nname;
    DName*      name;
    int     vers;
    int     softscreen;
    int     blanked;    /* screen turned off */
    ulong       blanktime;  /* time of last operation */
    ulong       savemap[3*256];
};
@

<<struct Client>>=
struct Client
{
    Ref     r;
    DImage*     dimage[NHASH];
    CScreen*    cscreen;
    Refresh*    refresh;
    Rendez      refrend;
    uchar*      readdata;
    int     nreaddata;
    int     busy;
    int     clientid;
    int     slot;
    int     refreshme;
    int     infoid;
    int     op;
};
@

<<struct Refresh>>=
struct Refresh
{
    DImage*     dimage;
    Rectangle   r;
    Refresh*    next;
};
@

<<struct Refx>>=
struct Refx
{
    Client*     client;
    DImage*     dimage;
};
@

<<struct DName>>=
struct DName
{
    char        *name;
    Client      *client;
    DImage*     dimage;
    int     vers;
};
@

<<struct FChar>>=
struct FChar
{
    int     minx;   /* left edge of bits */
    int     maxx;   /* right edge of bits */
    uchar       miny;   /* first non-zero scan-line */
    uchar       maxy;   /* last non-zero scan-line + 1 */
    schar       left;   /* offset of baseline */
    uchar       width;  /* width of baseline */
};
@

<<struct DImage>>=
/*
 * Reference counts in DImages:
 *  one per open by original client
 *  one per screen image or fill
 *  one per image derived from this one by name
 */
struct DImage
{
    int     id;
    int     ref;
    char        *name;
    int     vers;
    Memimage*   image;
    int     ascent;
    int     nfchar;
    FChar*      fchar;
    DScreen*    dscreen;    /* 0 if not a window */
    DImage*     fromname;   /* image this one is derived from, by name */
    DImage*     next;
};
@

<<struct CScreen>>=
struct CScreen
{
    DScreen*    dscreen;
    CScreen*    next;
};
@

<<struct DScreen>>=
struct DScreen
{
    int     id;
    int     public;
    int     ref;
    DImage      *dimage;
    DImage      *dfill;
    Memscreen*  screen;
    Client*     owner;
    DScreen*    next;
};
@

<<global sdraw>>=
static  KDraw        sdraw;
@

<<global drawlock>>=
    QLock   drawlock;
@

<<global screenimage>>=
static  Memimage    *screenimage;
@

<<global screendimage>>=
static  DImage* screendimage;
@

<<global screenname>>=
static  char    screenname[40];
@

<<global screennameid>>=
static  int screennameid;
@

<<global flushrect>>=
static  Rectangle   flushrect;
@

<<global waste>>=
static  int     waste;
@

<<global dscreen>>=
static  DScreen*    dscreen;
@

<<global Enodrawimage>>=
static  char Enodrawimage[] =   "unknown id for draw image";
@

<<global Enodrawscreen>>=
static  char Enodrawscreen[] =  "unknown id for draw screen";
@

<<global Eshortdraw>>=
static  char Eshortdraw[] = "short draw message";
@

<<global Eshortread>>=
static  char Eshortread[] = "draw read too short";
@

<<global Eimageexists>>=
static  char Eimageexists[] =   "image id in use";
@

<<global Escreenexists>>=
static  char Escreenexists[] =  "screen id in use";
@

<<global Edrawmem>>=
static  char Edrawmem[] =   "image memory allocation failed";
@

<<global Ereadoutside>>=
static  char Ereadoutside[] =   "readimage outside image";
@

<<global Ewriteoutside>>=
static  char Ewriteoutside[] =  "writeimage outside image";
@

<<global Enotfont>>=
static  char Enotfont[] =   "image not a font";
@

<<global Eindex>>=
static  char Eindex[] =     "character index out of range";
@

<<global Enoclient>>=
static  char Enoclient[] =  "no such draw client";
@

<<global Enameused>>=
//static    char Edepth[] =     "image has bad depth";
static  char Enameused[] =  "image name in use";
@

<<global Enoname>>=
static  char Enoname[] =    "no image with that name";
@

<<global Eoldname>>=
static  char Eoldname[] =   "named image no longer valid";
@

<<global Enamed>>=
static  char Enamed[] =     "image already has name";
@

<<global Ewrongname>>=
static  char Ewrongname[] =     "wrong name for image";
@

<<function dlock>>=
static void
dlock(void)
{
    qlock(&drawlock);
}
@

<<function candlock>>=
static int
candlock(void)
{
    return canqlock(&drawlock);
}
@

<<function dunlock>>=
static void
dunlock(void)
{
    qunlock(&drawlock);
}
@

<<function drawgen>>=
static int
drawgen(Chan *c, char*, Dirtab*, int, int s, Dir *dp)
{
    int t;
    Qid q;
    ulong path;
    Client *cl;

    q.vers = 0;

    if(s == DEVDOTDOT){
        switch(QID(c->qid)){
        case Qtopdir:
        case Q2nd:
            mkqid(&q, Qtopdir, 0, QTDIR);
            devdir(c, q, "#i", 0, eve, 0500, dp);
            break;
        case Q3rd:
            cl = drawclientofpath(c->qid.path);
            if(cl == nil)
                strncpy(up->genbuf, "??", sizeof up->genbuf);
            else
                snprint(up->genbuf, sizeof up->genbuf,
                    "%d", cl->clientid);
            mkqid(&q, Q2nd, 0, QTDIR);
            devdir(c, q, up->genbuf, 0, eve, 0500, dp);
            break;
        default:
            panic("drawwalk %llux", c->qid.path);
        }
        return 1;
    }

    /*
     * Top level directory contains the name of the device.
     */
    t = QID(c->qid);
    if(t == Qtopdir){
        switch(s){
        case 0:
            mkqid(&q, Q2nd, 0, QTDIR);
            devdir(c, q, "draw", 0, eve, 0555, dp);
            break;
        case 1:
            mkqid(&q, Qwinname, 0, QTFILE);
            devdir(c, q, "winname", 0, eve, 0444, dp);
            break;
        default:
            return -1;
        }
        return 1;
    }

    if(t == Qwinname){
        mkqid(&q, Qwinname, 0, QTFILE);
        devdir(c, q, "winname", 0, eve, 0444, dp);
        return 1;
    }

    /*
     * Second level contains "new" plus all the clients.
     */
    if(t == Q2nd || t == Qnew){
        if(s == 0){
            mkqid(&q, Qnew, 0, QTFILE);
            devdir(c, q, "new", 0, eve, 0666, dp);
        }
        else if(s <= sdraw.nclient){
            cl = sdraw.client[s-1];
            if(cl == 0)
                return 0;
            snprint(up->genbuf, sizeof up->genbuf, "%d",
                cl->clientid);
            mkqid(&q, (s<<QSHIFT)|Q3rd, 0, QTDIR);
            devdir(c, q, up->genbuf, 0, eve, 0555, dp);
            return 1;
        }
        else
            return -1;
        return 1;
    }

    /*
     * Third level.
     */
    path = c->qid.path&~((1<<QSHIFT)-1);    /* slot component */
    q.vers = c->qid.vers;
    q.type = QTFILE;
    switch(s){
    case 0:
        q.path = path|Qcolormap;
        devdir(c, q, "colormap", 0, eve, 0600, dp);
        break;
    case 1:
        q.path = path|Qctl;
        devdir(c, q, "ctl", 0, eve, 0600, dp);
        break;
    case 2:
        q.path = path|Qdata;
        devdir(c, q, "data", 0, eve, 0600, dp);
        break;
    case 3:
        q.path = path|Qrefresh;
        devdir(c, q, "refresh", 0, eve, 0400, dp);
        break;
    default:
        return -1;
    }
    return 1;
}
@

<<function drawrefactive>>=
static
int
drawrefactive(void *a)
{
    Client *c;

    c = a;
    return c->refreshme || c->refresh!=0;
}
@

<<function drawrefreshscreen>>=
static
void
drawrefreshscreen(DImage *l, Client *client)
{
    while(l != nil && l->dscreen == nil)
        l = l->fromname;
    if(l != nil && l->dscreen->owner != client)
        l->dscreen->owner->refreshme = 1;
}
@

<<function drawrefresh>>=
static
void
drawrefresh(Memimage*, Rectangle r, void *v)
{
    Refx *x;
    DImage *d;
    Client *c;
    Refresh *ref;

    if(v == 0)
        return;
    x = v;
    c = x->client;
    d = x->dimage;
    for(ref=c->refresh; ref; ref=ref->next)
        if(ref->dimage == d){
            combinerect(&ref->r, r);
            return;
        }
    ref = malloc(sizeof(Refresh));
    if(ref){
        ref->dimage = d;
        ref->r = r;
        ref->next = c->refresh;
        c->refresh = ref;
    }
}
@

<<function addflush>>=
static void
addflush(Rectangle r)
{
    int abb, ar, anbb;
    Rectangle nbb;

    if(sdraw.softscreen==0 || !rectclip(&r, screenimage->r))
        return;

    if(flushrect.min.x >= flushrect.max.x){
        flushrect = r;
        waste = 0;
        return;
    }
    nbb = flushrect;
    combinerect(&nbb, r);
    ar = Dx(r)*Dy(r);
    abb = Dx(flushrect)*Dy(flushrect);
    anbb = Dx(nbb)*Dy(nbb);
    /*
     * Area of new waste is area of new bb minus area of old bb,
     * less the area of the new segment, which we assume is not waste.
     * This could be negative, but that's OK.
     */
    waste += anbb-abb - ar;
    if(waste < 0)
        waste = 0;
    /*
     * absorb if:
     *  total area is small
     *  waste is less than half total area
     *  rectangles touch
     */
    if(anbb<=1024 || waste*2<anbb || rectXrect(flushrect, r)){
        flushrect = nbb;
        return;
    }
    /* emit current state */
    if(flushrect.min.x < flushrect.max.x)
        flushmemscreen(flushrect);
    flushrect = r;
    waste = 0;
}
@

<<function dstflush>>=
static
void
dstflush(int dstid, Memimage *dst, Rectangle r)
{
    Memlayer *l;

    if(dstid == 0){
        combinerect(&flushrect, r);
        return;
    }
    /* how can this happen? -rsc, dec 12 2002 */
    if(dst == 0){
        print("nil dstflush\n");
        return;
    }
    l = dst->layer;
    if(l == nil)
        return;
    do{
        if(l->screen->image->data != screenimage->data)
            return;
        r = rectaddpt(r, l->delta);
        l = l->screen->image->layer;
    }while(l);
    addflush(r);
}
@

<<function drawflush>>=
void
drawflush(void)
{
    if(flushrect.min.x < flushrect.max.x)
        flushmemscreen(flushrect);
    flushrect = Rect(10000, 10000, -10000, -10000);
}
@

<<function drawcmp>>=
static
int
drawcmp(char *a, char *b, int n)
{
    if(strlen(a) != n)
        return 1;
    return memcmp(a, b, n);
}
@

<<function drawlookupname>>=
DName*
drawlookupname(int n, char *str)
{
    DName *name, *ename;

    name = sdraw.name;
    ename = &name[sdraw.nname];
    for(; name<ename; name++)
        if(drawcmp(name->name, str, n) == 0)
            return name;
    return 0;
}
@

<<function drawgoodname>>=
int
drawgoodname(DImage *d)
{
    DName *n;

    /* if window, validate the screen's own images */
    if(d->dscreen)
        if(drawgoodname(d->dscreen->dimage) == 0
        || drawgoodname(d->dscreen->dfill) == 0)
            return 0;
    if(d->name == nil)
        return 1;
    n = drawlookupname(strlen(d->name), d->name);
    if(n==nil || n->vers!=d->vers)
        return 0;
    return 1;
}
@

<<function drawlookup>>=
DImage*
drawlookup(Client *client, int id, int checkname)
{
    DImage *d;

    d = client->dimage[id&HASHMASK];
    while(d){
        if(d->id == id){
            if(checkname && !drawgoodname(d))
                error(Eoldname);
            return d;
        }
        d = d->next;
    }
    return 0;
}
@

<<function drawlookupdscreen>>=
DScreen*
drawlookupdscreen(int id)
{
    DScreen *s;

    s = dscreen;
    while(s){
        if(s->id == id)
            return s;
        s = s->next;
    }
    return 0;
}
@

<<function drawlookupscreen>>=
DScreen*
drawlookupscreen(Client *client, int id, CScreen **cs)
{
    CScreen *s;

    s = client->cscreen;
    while(s){
        if(s->dscreen->id == id){
            *cs = s;
            return s->dscreen;
        }
        s = s->next;
    }
    error(Enodrawscreen);
    return 0;
}
@

<<function allocdimage>>=
DImage*
allocdimage(Memimage *i)
{
    DImage *d;

    d = malloc(sizeof(DImage));
    if(d == 0)
        return 0;
    d->ref = 1;
    d->name = 0;
    d->vers = 0;
    d->image = i;
    d->nfchar = 0;
    d->fchar = 0;
    d->fromname = 0;
    return d;
}
@

<<function drawinstall>>=
Memimage*
drawinstall(Client *client, int id, Memimage *i, DScreen *dscreen)
{
    DImage *d;

    d = allocdimage(i);
    if(d == 0)
        return 0;
    d->id = id;
    d->dscreen = dscreen;
    d->next = client->dimage[id&HASHMASK];
    client->dimage[id&HASHMASK] = d;
    return i;
}
@

<<function drawinstallscreen>>=
Memscreen*
drawinstallscreen(Client *client, DScreen *d, int id, DImage *dimage, DImage *dfill, int public)
{
    Memscreen *s;
    CScreen *c;

    c = malloc(sizeof(CScreen));
    if(dimage && dimage->image && dimage->image->chan == 0)
        panic("bad image %p in drawinstallscreen", dimage->image);

    if(c == 0)
        return 0;
    if(d == 0){
        d = malloc(sizeof(DScreen));
        if(d == 0){
            free(c);
            return 0;
        }
        s = malloc(sizeof(Memscreen));
        if(s == 0){
            free(c);
            free(d);
            return 0;
        }
        s->frontmost = 0;
        s->rearmost = 0;
        d->dimage = dimage;
        if(dimage){
            s->image = dimage->image;
            dimage->ref++;
        }
        d->dfill = dfill;
        if(dfill){
            s->fill = dfill->image;
            dfill->ref++;
        }
        d->ref = 0;
        d->id = id;
        d->screen = s;
        d->public = public;
        d->next = dscreen;
        d->owner = client;
        dscreen = d;
    }
    c->dscreen = d;
    d->ref++;
    c->next = client->cscreen;
    client->cscreen = c;
    return d->screen;
}
@

<<function drawdelname>>=
void
drawdelname(DName *name)
{
    int i;

    i = name-sdraw.name;
    memmove(name, name+1, (sdraw.nname-(i+1))*sizeof(DName));
    sdraw.nname--;
}
@

<<function drawfreedscreen>>=
void
drawfreedscreen(DScreen *this)
{
    DScreen *ds, *next;

    this->ref--;
    if(this->ref < 0)
        print("negative ref in drawfreedscreen\n");
    if(this->ref > 0)
        return;
    ds = dscreen;
    if(ds == this){
        dscreen = this->next;
        goto Found;
    }
    while(next = ds->next){ /* assign = */
        if(next == this){
            ds->next = this->next;
            goto Found;
        }
        ds = next;
    }
    error(Enodrawimage);

    Found:
    if(this->dimage)
        drawfreedimage(this->dimage);
    if(this->dfill)
        drawfreedimage(this->dfill);
    free(this->screen);
    free(this);
}
@

<<function drawfreedimage>>=
void
drawfreedimage(DImage *dimage)
{
    int i;
    Memimage *l;
    DScreen *ds;

    dimage->ref--;
    if(dimage->ref < 0)
        print("negative ref in drawfreedimage\n");
    if(dimage->ref > 0)
        return;

    /* any names? */
    for(i=0; i<sdraw.nname; )
        if(sdraw.name[i].dimage == dimage)
            drawdelname(sdraw.name+i);
        else
            i++;
    if(dimage->fromname){   /* acquired by name; owned by someone else*/
        drawfreedimage(dimage->fromname);
        goto Return;
    }
//  if(dimage->image == screenimage)    /* don't free the display */
//      goto Return;
    ds = dimage->dscreen;
    if(ds){
        l = dimage->image;
        if(l->data == screenimage->data)
            addflush(l->layer->screenr);
        if(l->layer->refreshfn == drawrefresh)  /* else true owner will clean up */
            free(l->layer->refreshptr);
        l->layer->refreshptr = nil;
        if(drawgoodname(dimage))
            memldelete(l);
        else
            memlfree(l);
        drawfreedscreen(ds);
    }else
        freememimage(dimage->image);
    Return:
    free(dimage->fchar);
    free(dimage);
}
@

<<function drawuninstallscreen>>=
void
drawuninstallscreen(Client *client, CScreen *this)
{
    CScreen *cs, *next;

    cs = client->cscreen;
    if(cs == this){
        client->cscreen = this->next;
        drawfreedscreen(this->dscreen);
        free(this);
        return;
    }
    while(next = cs->next){ /* assign = */
        if(next == this){
            cs->next = this->next;
            drawfreedscreen(this->dscreen);
            free(this);
            return;
        }
        cs = next;
    }
}
@

<<function drawuninstall>>=
void
drawuninstall(Client *client, int id)
{
    DImage *d, *next;

    d = client->dimage[id&HASHMASK];
    if(d == 0)
        error(Enodrawimage);
    if(d->id == id){
        client->dimage[id&HASHMASK] = d->next;
        drawfreedimage(d);
        return;
    }
    while(next = d->next){  /* assign = */
        if(next->id == id){
            d->next = next->next;
            drawfreedimage(next);
            return;
        }
        d = next;
    }
    error(Enodrawimage);
}
@

<<function drawaddname>>=
void
drawaddname(Client *client, DImage *di, int n, char *str)
{
    DName *name, *ename, *new, *t;

    name = sdraw.name;
    ename = &name[sdraw.nname];
    for(; name<ename; name++)
        if(drawcmp(name->name, str, n) == 0)
            error(Enameused);
    t = smalloc((sdraw.nname+1)*sizeof(DName));
    memmove(t, sdraw.name, sdraw.nname*sizeof(DName));
    free(sdraw.name);
    sdraw.name = t;
    new = &sdraw.name[sdraw.nname++];
    new->name = smalloc(n+1);
    memmove(new->name, str, n);
    new->name[n] = 0;
    new->dimage = di;
    new->client = client;
    new->vers = ++sdraw.vers;
}
@

<<function drawnewclient>>=
Client*
drawnewclient(void)
{
    Client *cl, **cp;
    int i;

    for(i=0; i<sdraw.nclient; i++){
        cl = sdraw.client[i];
        if(cl == 0)
            break;
    }
    if(i == sdraw.nclient){
        cp = malloc((sdraw.nclient+1)*sizeof(Client*));
        if(cp == 0)
            return 0;
        memmove(cp, sdraw.client, sdraw.nclient*sizeof(Client*));
        free(sdraw.client);
        sdraw.client = cp;
        sdraw.nclient++;
        cp[i] = 0;
    }
    cl = malloc(sizeof(Client));
    if(cl == 0)
        return 0;
    memset(cl, 0, sizeof(Client));
    cl->slot = i;
    cl->clientid = ++sdraw.clientid;
    cl->op = SoverD;
    sdraw.client[i] = cl;
    return cl;
}
@

<<function drawclientop>>=
static int
drawclientop(Client *cl)
{
    int op;

    op = cl->op;
    cl->op = SoverD;
    return op;
}
@

<<function drawclientofpath>>=
//}

Client*
drawclientofpath(ulong path)
{
    Client *cl;
    int slot;

    slot = CLIENTPATH(path);
    if(slot == 0)
        return nil;
    cl = sdraw.client[slot-1];
    if(cl==0 || cl->clientid==0)
        return nil;
    return cl;
}
@

<<function drawclient>>=
Client*
drawclient(Chan *c)
{
    Client *client;

    client = drawclientofpath(c->qid.path);
    if(client == nil)
        error(Enoclient);
    return client;
}
@

<<function drawimage>>=
Memimage*
drawimage(Client *client, uchar *a)
{
    DImage *d;

    d = drawlookup(client, BGLONG(a), 1);
    if(d == nil)
        error(Enodrawimage);
    return d->image;
}
@

<<function drawrectangle>>=
void
drawrectangle(Rectangle *r, uchar *a)
{
    r->min.x = BGLONG(a+0*4);
    r->min.y = BGLONG(a+1*4);
    r->max.x = BGLONG(a+2*4);
    r->max.y = BGLONG(a+3*4);
}
@

<<function drawpoint>>=
void
drawpoint(Point *p, uchar *a)
{
    p->x = BGLONG(a+0*4);
    p->y = BGLONG(a+1*4);
}
@

<<function drawchar>>=
Point
drawchar(Memimage *dst, Memimage *rdst, Point p, Memimage *src, Point *sp, DImage *font, int index, int op)
{
    FChar *fc;
    Rectangle r;
    Point sp1;
    static Memimage *tmp;

    fc = &font->fchar[index];
    r.min.x = p.x+fc->left;
    r.min.y = p.y-(font->ascent-fc->miny);
    r.max.x = r.min.x+(fc->maxx-fc->minx);
    r.max.y = r.min.y+(fc->maxy-fc->miny);
    sp1.x = sp->x+fc->left;
    sp1.y = sp->y+fc->miny;

    /*
     * If we're drawing greyscale fonts onto a VGA screen,
     * it's very costly to read the screen memory to do the
     * alpha blending inside memdraw.  If this is really a stringbg,
     * then rdst is the bg image (in main memory) which we can
     * refer to for the underlying dst pixels instead of reading dst
     * directly.
     */
    if(ishwimage(dst) && !ishwimage(rdst) && font->image->depth > 1){
        if(tmp == nil || tmp->chan != dst->chan || Dx(tmp->r) < Dx(r) || Dy(tmp->r) < Dy(r)){
            if(tmp)
                freememimage(tmp);
            tmp = allocmemimage(Rect(0,0,Dx(r),Dy(r)), dst->chan);
            if(tmp == nil)
                goto fallback;
        }
        memdraw(tmp, Rect(0,0,Dx(r),Dy(r)), rdst, r.min, memopaque, ZP, S);
        memdraw(tmp, Rect(0,0,Dx(r),Dy(r)), src, sp1, font->image, Pt(fc->minx, fc->miny), op);
        memdraw(dst, r, tmp, ZP, memopaque, ZP, S);
    }else{
    fallback:
        memdraw(dst, r, src, sp1, font->image, Pt(fc->minx, fc->miny), op);
    }

    p.x += fc->width;
    sp->x += fc->width;
    return p;
}
@

<<function makescreenimage>>=
static DImage*
makescreenimage(void)
{
    int width, depth;
    ulong chan;
    DImage *di;
    Memdata *md;
    Memimage *i;
    Rectangle r;

    md = malloc(sizeof *md);
    if(md == nil)
        return nil;
    md->allocd = 1;
    md->base = nil;
    md->bdata = attachscreen(&r, &chan, &depth, &width, &sdraw.softscreen);
    if(md->bdata == nil){
        free(md);
        return nil;
    }
    md->ref = 1;
    i = allocmemimaged(r, chan, md);
    if(i == nil){
        free(md);
        return nil;
    }
    i->width = width;
    i->clipr = r;

    di = allocdimage(i);
    if(di == nil){
        freememimage(i);    /* frees md */
        return nil;
    }
    if(!waserror()){
        snprint(screenname, sizeof screenname, "noborder.screen.%d", ++screennameid);
        drawaddname(nil, di, strlen(screenname), screenname);
        poperror();
    }
    return di;
}
@

<<function initscreenimage>>=
static int
initscreenimage(void)
{
    if(screenimage != nil)
        return 1;

    screendimage = makescreenimage();
    if(screendimage == nil)
        return 0;
    screenimage = screendimage->image;
// iprint("initscreenimage %p %p\n", screendimage, screenimage);
    mouseresize();
    return 1;
}
@

<<function deletescreenimage>>=
void
deletescreenimage(void)
{
    dlock();
    if(screenimage){
        /* will be freed via screendimage; disable */
        screenimage->clipr = ZR;
        screenimage = nil;
    }
    if(screendimage){
        drawfreedimage(screendimage);
        screendimage = nil;
    }
    dunlock();
}
@

<<function resetscreenimage>>=
void
resetscreenimage(void)
{
    dlock();
    initscreenimage();
    dunlock();
}
@

<<function drawattach>>=
static Chan*
drawattach(char *spec)
{
    dlock();
    if(!initscreenimage()){
        dunlock();
        error("no frame buffer");
    }
    dunlock();
    return devattach('i', spec);
}
@

<<function drawwalk>>=
static Walkqid*
drawwalk(Chan *c, Chan *nc, char **name, int nname)
{
    if(screenimage == nil)
        error("no frame buffer");
    return devwalk(c, nc, name, nname, 0, 0, drawgen);
}
@

<<function drawstat>>=
static int
drawstat(Chan *c, uchar *db, int n)
{
    return devstat(c, db, n, 0, 0, drawgen);
}
@

<<function drawopen>>=
static Chan*
drawopen(Chan *c, int omode)
{
    Client *cl;
    DName *dn;
    DImage *di;

    if(c->qid.type & QTDIR){
        c = devopen(c, omode, 0, 0, drawgen);
        c->iounit = IOUNIT;
    }

    dlock();
    if(waserror()){
        dunlock();
        nexterror();
    }

    if(QID(c->qid) == Qnew){
        cl = drawnewclient();
        if(cl == 0)
            error(Enodev);
        c->qid.path = Qctl|((cl->slot+1)<<QSHIFT);
    }

    switch(QID(c->qid)){
    case Qwinname:
        break;

    case Qnew:
        break;

    case Qctl:
        cl = drawclient(c);
        if(cl->busy)
            error(Einuse);
        cl->busy = 1;
        flushrect = Rect(10000, 10000, -10000, -10000);
        dn = drawlookupname(strlen(screenname), screenname);
        if(dn == 0)
            error("draw: cannot happen 2");
        if(drawinstall(cl, 0, dn->dimage->image, 0) == 0)
            error(Edrawmem);
        di = drawlookup(cl, 0, 0);
        if(di == 0)
            error("draw: cannot happen 1");
        di->vers = dn->vers;
        di->name = smalloc(strlen(screenname)+1);
        strcpy(di->name, screenname);
        di->fromname = dn->dimage;
        di->fromname->ref++;
        incref(&cl->r);
        break;

    case Qcolormap:
    case Qdata:
    case Qrefresh:
        cl = drawclient(c);
        incref(&cl->r);
        break;
    }
    dunlock();
    poperror();
    c->mode = openmode(omode);
    c->flag |= COPEN;
    c->offset = 0;
    c->iounit = IOUNIT;
    return c;
}
@

<<function drawclose>>=
static void
drawclose(Chan *c)
{
    int i;
    DImage *d, **dp;
    Client *cl;
    Refresh *r;

    if(QID(c->qid) < Qcolormap) /* Qtopdir, Qnew, Q3rd, Q2nd have no client */
        return;
    dlock();
    if(waserror()){
        dunlock();
        nexterror();
    }

    cl = drawclient(c);
    if(QID(c->qid) == Qctl)
        cl->busy = 0;
    if((c->flag&COPEN) && (decref(&cl->r)==0)){
        while(r = cl->refresh){ /* assign = */
            cl->refresh = r->next;
            free(r);
        }
        /* free names */
        for(i=0; i<sdraw.nname; )
            if(sdraw.name[i].client == cl)
                drawdelname(sdraw.name+i);
            else
                i++;
        while(cl->cscreen)
            drawuninstallscreen(cl, cl->cscreen);
        /* all screens are freed, so now we can free images */
        dp = cl->dimage;
        for(i=0; i<NHASH; i++){
            while((d = *dp) != nil){
                *dp = d->next;
                drawfreedimage(d);
            }
            dp++;
        }
        sdraw.client[cl->slot] = 0;
        drawflush();    /* to erase visible, now dead windows */
        free(cl);
    }
    dunlock();
    poperror();
}
@

<<function drawread>>=
long
drawread(Chan *c, void *a, long n, vlong off)
{
    int index, m;
    ulong red, green, blue;
    Client *cl;
    uchar *p;
    Refresh *r;
    DImage *di;
    Memimage *i;
    ulong offset = off;
    char buf[16];

    if(c->qid.type & QTDIR)
        return devdirread(c, a, n, 0, 0, drawgen);
    if(QID(c->qid) == Qwinname)
        return readstr(off, a, n, screenname);

    cl = drawclient(c);
    dlock();
    if(waserror()){
        dunlock();
        nexterror();
    }
    switch(QID(c->qid)){
    case Qctl:
        if(n < 12*12)
            error(Eshortread);
        if(cl->infoid < 0)
            error(Enodrawimage);
        if(cl->infoid == 0){
            i = screenimage;
            if(i == nil)
                error(Enodrawimage);
        }else{
            di = drawlookup(cl, cl->infoid, 1);
            if(di == nil)
                error(Enodrawimage);
            i = di->image;
        }
        n = snprint(a, n,
            "%11d %11d %11s %11d %11d %11d %11d %11d %11d %11d %11d %11d ",
            cl->clientid, cl->infoid, chantostr(buf, i->chan),
            (i->flags&Frepl)==Frepl,
            i->r.min.x, i->r.min.y, i->r.max.x, i->r.max.y,
            i->clipr.min.x, i->clipr.min.y, i->clipr.max.x,
            i->clipr.max.y);
        cl->infoid = -1;
        break;

    case Qcolormap:
        drawactive(1);  /* to restore map from backup */
        p = malloc(4*12*256+1);
        if(p == 0)
            error(Enomem);
        m = 0;
        for(index = 0; index < 256; index++){
            getcolor(index, &red, &green, &blue);
            m += snprint((char*)p+m, 4*12*256+1 - m,
                "%11d %11lud %11lud %11lud\n", index,
                red>>24, green>>24, blue>>24);
        }
        n = readstr(offset, a, n, (char*)p);
        free(p);
        break;

    case Qdata:
        if(cl->readdata == nil)
            error("no draw data");
        if(n < cl->nreaddata)
            error(Eshortread);
        n = cl->nreaddata;
        memmove(a, cl->readdata, cl->nreaddata);
        free(cl->readdata);
        cl->readdata = nil;
        break;

    case Qrefresh:
        if(n < 5*4)
            error(Ebadarg);
        for(;;){
            if(cl->refreshme || cl->refresh)
                break;
            dunlock();
            if(waserror()){
                dlock();    /* restore lock for waserror() above */
                nexterror();
            }
            sleep(&cl->refrend, drawrefactive, cl);
            poperror();
            dlock();
        }
        p = a;
        while(cl->refresh && n>=5*4){
            r = cl->refresh;
            BPLONG(p+0*4, r->dimage->id);
            BPLONG(p+1*4, r->r.min.x);
            BPLONG(p+2*4, r->r.min.y);
            BPLONG(p+3*4, r->r.max.x);
            BPLONG(p+4*4, r->r.max.y);
            cl->refresh = r->next;
            free(r);
            p += 5*4;
            n -= 5*4;
        }
        cl->refreshme = 0;
        n = p-(uchar*)a;
        break;
    }
    dunlock();
    poperror();
    return n;
}
@

<<function drawwakeall>>=
void
drawwakeall(void)
{
    Client *cl;
    int i;

    for(i=0; i<sdraw.nclient; i++){
        cl = sdraw.client[i];
        if(cl && (cl->refreshme || cl->refresh))
            wakeup(&cl->refrend);
    }
}
@

<<function drawwrite>>=
static long
drawwrite(Chan *c, void *a, long n, vlong)
{
    char buf[128], *fields[4], *q;
    Client *cl;
    int i, m, red, green, blue, x;

    if(c->qid.type & QTDIR)
        error(Eisdir);
    cl = drawclient(c);
    dlock();
    if(waserror()){
        drawwakeall();
        dunlock();
        nexterror();
    }
    switch(QID(c->qid)){
    case Qctl:
        if(n != 4)
            error("unknown draw control request");
        cl->infoid = BGLONG((uchar*)a);
        break;

    case Qcolormap:
        drawactive(1);  /* to restore map from backup */
        m = n;
        n = 0;
        while(m > 0){
            x = m;
            if(x > sizeof(buf)-1)
                x = sizeof(buf)-1;
            q = memccpy(buf, a, '\n', x);
            if(q == 0)
                break;
            i = q-buf;
            n += i;
            a = (char*)a + i;
            m -= i;
            *q = 0;
            if(tokenize(buf, fields, nelem(fields)) != 4)
                error(Ebadarg);
            i = strtoul(fields[0], 0, 0);
            red = strtoul(fields[1], 0, 0);
            green = strtoul(fields[2], 0, 0);
            blue = strtoul(fields[3], &q, 0);
            if(fields[3] == q)
                error(Ebadarg);
            if(red>255 || green>255 || blue>255 || i<0 || i>255)
                error(Ebadarg);
            red |= red<<8;
            red |= red<<16;
            green |= green<<8;
            green |= green<<16;
            blue |= blue<<8;
            blue |= blue<<16;
            setcolor(i, red, green, blue);
        }
        break;

    case Qdata:
        drawmesg(cl, a, n);
        drawwakeall();
        break;

    default:
        error(Ebadusefd);
    }
    dunlock();
    poperror();
    return n;
}
@

<<function drawcoord>>=
uchar*
drawcoord(uchar *p, uchar *maxp, int oldx, int *newx)
{
    int b, x;

    if(p >= maxp)
        error(Eshortdraw);
    b = *p++;
    x = b & 0x7F;
    if(b & 0x80){
        if(p+1 >= maxp)
            error(Eshortdraw);
        x |= *p++ << 7;
        x |= *p++ << 15;
        if(x & (1<<22))
            x |= ~0<<23;
    }else{
        if(b & 0x40)
            x |= ~0<<7;
        x += oldx;
    }
    *newx = x;
    return p;
}
@

<<function printmesg>>=
static void
printmesg(char *fmt, uchar *a, int plsprnt)
{
    char buf[256];
    char *p, *q;
    int s, left;

    if(1|| plsprnt==0){
        SET(s,q,p);
        USED(fmt, a, buf, p, q, s);
        return;
    }
    q = buf;
    *q++ = *a++;
    for(p=fmt; *p; p++){
        left = sizeof buf - 2 - (q - buf);  /* 2 for \n\0 */
        switch(*p){
        case 'l':
            q += snprint(q, left, " %ld", (long)BGLONG(a));
            a += 4;
            break;
        case 'L':
            q += snprint(q, left, " %.8lux", (ulong)BGLONG(a));
            a += 4;
            break;
        case 'R':
            q += snprint(q, left, " [%d %d %d %d]", BGLONG(a),
                BGLONG(a+4), BGLONG(a+8), BGLONG(a+12));
            a += 16;
            break;
        case 'P':
            q += snprint(q, left, " [%d %d]", BGLONG(a), BGLONG(a+4));
            a += 8;
            break;
        case 'b':
            q += snprint(q, left, " %d", *a++);
            break;
        case 's':
            q += snprint(q, left, " %d", BGSHORT(a));
            a += 2;
            break;
        case 'S':
            q += snprint(q, left, " %.4ux", BGSHORT(a));
            a += 2;
            break;
        }
    }
    *q++ = '\n';
    *q = 0;
    iprint("%.*s", (int)(q-buf), buf);
}
@

<<function drawmesg>>=
void
drawmesg(Client *client, void *av, int n)
{
    int c, repl, m, y, dstid, scrnid, ni, ci, j, nw, e0, e1, op, ox, oy, oesize, esize, doflush;
    uchar *u, *a, refresh;
    char *fmt;
    ulong value, chan;
    Rectangle r, clipr;
    Point p, q, *pp, sp;
    Memimage *i, *bg, *dst, *src, *mask;
    Memimage *l, **lp;
    Memscreen *scrn;
    DImage *font, *ll, *di, *ddst, *dsrc;
    DName *dn;
    DScreen *dscrn;
    FChar *fc;
    Refx *refx;
    CScreen *cs;
    Refreshfn reffn;

    a = av;
    m = 0;
    fmt = nil;
    if(waserror()){
        if(fmt) printmesg(fmt, a, 1);
    /*  iprint("error: %s\n", up->errstr);  */
        nexterror();
    }
    while((n-=m) > 0){
        USED(fmt);
        a += m;
        switch(*a){
        default:
            error("bad draw command");
        /* new allocate: 'b' id[4] screenid[4] refresh[1] chan[4] repl[1] R[4*4] clipR[4*4] rrggbbaa[4] */
        case 'b':
            printmesg(fmt="LLbLbRRL", a, 0);
            m = 1+4+4+1+4+1+4*4+4*4+4;
            if(n < m)
                error(Eshortdraw);
            dstid = BGLONG(a+1);
            scrnid = BGSHORT(a+5);
            refresh = a[9];
            chan = BGLONG(a+10);
            repl = a[14];
            drawrectangle(&r, a+15);
            drawrectangle(&clipr, a+31);
            value = BGLONG(a+47);
            if(drawlookup(client, dstid, 0))
                error(Eimageexists);
            if(scrnid){
                dscrn = drawlookupscreen(client, scrnid, &cs);
                scrn = dscrn->screen;
                if(repl || chan!=scrn->image->chan)
                    error("image parameters incompatible with screen");
                reffn = nil;
                switch(refresh){
                case Refbackup:
                    break;
                case Refnone:
                    reffn = memlnorefresh;
                    break;
                case Refmesg:
                    reffn = drawrefresh;
                    break;
                default:
                    error("unknown refresh method");
                }
                l = memlalloc(scrn, r, reffn, 0, value);
                if(l == 0)
                    error(Edrawmem);
                addflush(l->layer->screenr);
                l->clipr = clipr;
                rectclip(&l->clipr, r);
                if(drawinstall(client, dstid, l, dscrn) == 0){
                    memldelete(l);
                    error(Edrawmem);
                }
                dscrn->ref++;
                if(reffn){
                    refx = nil;
                    if(reffn == drawrefresh){
                        refx = malloc(sizeof(Refx));
                        if(refx == 0){
                            drawuninstall(client, dstid);
                            error(Edrawmem);
                        }
                        refx->client = client;
                        refx->dimage = drawlookup(client, dstid, 1);
                    }
                    memlsetrefresh(l, reffn, refx);
                }
                continue;
            }
            i = allocmemimage(r, chan);
            if(i == 0)
                error(Edrawmem);
            if(repl)
                i->flags |= Frepl;
            i->clipr = clipr;
            if(!repl)
                rectclip(&i->clipr, r);
            if(drawinstall(client, dstid, i, 0) == 0){
                freememimage(i);
                error(Edrawmem);
            }
            memfillcolor(i, value);
            continue;

        /* allocate screen: 'A' id[4] imageid[4] fillid[4] public[1] */
        case 'A':
            printmesg(fmt="LLLb", a, 1);
            m = 1+4+4+4+1;
            if(n < m)
                error(Eshortdraw);
            dstid = BGLONG(a+1);
            if(dstid == 0)
                error(Ebadarg);
            if(drawlookupdscreen(dstid))
                error(Escreenexists);
            ddst = drawlookup(client, BGLONG(a+5), 1);
            dsrc = drawlookup(client, BGLONG(a+9), 1);
            if(ddst==0 || dsrc==0)
                error(Enodrawimage);
            if(drawinstallscreen(client, 0, dstid, ddst, dsrc, a[13]) == 0)
                error(Edrawmem);
            continue;

        /* set repl and clip: 'c' dstid[4] repl[1] clipR[4*4] */
        case 'c':
            printmesg(fmt="LbR", a, 0);
            m = 1+4+1+4*4;
            if(n < m)
                error(Eshortdraw);
            ddst = drawlookup(client, BGLONG(a+1), 1);
            if(ddst == nil)
                error(Enodrawimage);
            if(ddst->name)
                error("cannot change repl/clipr of shared image");
            dst = ddst->image;
            if(a[5])
                dst->flags |= Frepl;
            drawrectangle(&dst->clipr, a+6);
            continue;

        /* draw: 'd' dstid[4] srcid[4] maskid[4] R[4*4] P[2*4] P[2*4] */
        case 'd':
            printmesg(fmt="LLLRPP", a, 0);
            m = 1+4+4+4+4*4+2*4+2*4;
            if(n < m)
                error(Eshortdraw);
            dst = drawimage(client, a+1);
            dstid = BGLONG(a+1);
            src = drawimage(client, a+5);
            mask = drawimage(client, a+9);
            drawrectangle(&r, a+13);
            drawpoint(&p, a+29);
            drawpoint(&q, a+37);
            op = drawclientop(client);
            memdraw(dst, r, src, p, mask, q, op);
            dstflush(dstid, dst, r);
            continue;

        /* toggle debugging: 'D' val[1] */
        case 'D':
            printmesg(fmt="b", a, 0);
            m = 1+1;
            if(n < m)
                error(Eshortdraw);
            drawdebug = a[1];
            continue;

        /* ellipse: 'e' dstid[4] srcid[4] center[2*4] a[4] b[4] thick[4] sp[2*4] alpha[4] phi[4]*/
        case 'e':
        case 'E':
            printmesg(fmt="LLPlllPll", a, 0);
            m = 1+4+4+2*4+4+4+4+2*4+2*4;
            if(n < m)
                error(Eshortdraw);
            dst = drawimage(client, a+1);
            dstid = BGLONG(a+1);
            src = drawimage(client, a+5);
            drawpoint(&p, a+9);
            e0 = BGLONG(a+17);
            e1 = BGLONG(a+21);
            if(e0<0 || e1<0)
                error("invalid ellipse semidiameter");
            j = BGLONG(a+25);
            if(j < 0)
                error("negative ellipse thickness");
            drawpoint(&sp, a+29);
            c = j;
            if(*a == 'E')
                c = -1;
            ox = BGLONG(a+37);
            oy = BGLONG(a+41);
            op = drawclientop(client);
            /* high bit indicates arc angles are present */
            if(ox & (1<<31)){
                if((ox & (1<<30)) == 0)
                    ox &= ~(1<<31);
                memarc(dst, p, e0, e1, c, src, sp, ox, oy, op);
            }else
                memellipse(dst, p, e0, e1, c, src, sp, op);
            dstflush(dstid, dst, Rect(p.x-e0-j, p.y-e1-j, p.x+e0+j+1, p.y+e1+j+1));
            continue;

        /* free: 'f' id[4] */
        case 'f':
            printmesg(fmt="L", a, 1);
            m = 1+4;
            if(n < m)
                error(Eshortdraw);
            ll = drawlookup(client, BGLONG(a+1), 0);
            if(ll && ll->dscreen && ll->dscreen->owner != client)
                ll->dscreen->owner->refreshme = 1;
            drawuninstall(client, BGLONG(a+1));
            continue;

        /* free screen: 'F' id[4] */
        case 'F':
            printmesg(fmt="L", a, 1);
            m = 1+4;
            if(n < m)
                error(Eshortdraw);
            drawlookupscreen(client, BGLONG(a+1), &cs);
            drawuninstallscreen(client, cs);
            continue;

        /* initialize font: 'i' fontid[4] nchars[4] ascent[1] */
        case 'i':
            printmesg(fmt="Llb", a, 1);
            m = 1+4+4+1;
            if(n < m)
                error(Eshortdraw);
            dstid = BGLONG(a+1);
            if(dstid == 0)
                error("cannot use display as font");
            font = drawlookup(client, dstid, 1);
            if(font == 0)
                error(Enodrawimage);
            if(font->image->layer)
                error("cannot use window as font");
            ni = BGLONG(a+5);
            if(ni<=0 || ni>4096)
                error("bad font size (4096 chars max)");
            free(font->fchar);  /* should we complain if non-zero? */
            font->fchar = malloc(ni*sizeof(FChar));
            if(font->fchar == 0)
                error("no memory for font");
            memset(font->fchar, 0, ni*sizeof(FChar));
            font->nfchar = ni;
            font->ascent = a[9];
            continue;

        /* load character: 'l' fontid[4] srcid[4] index[2] R[4*4] P[2*4] left[1] width[1] */
        case 'l':
            printmesg(fmt="LLSRPbb", a, 0);
            m = 1+4+4+2+4*4+2*4+1+1;
            if(n < m)
                error(Eshortdraw);
            font = drawlookup(client, BGLONG(a+1), 1);
            if(font == 0)
                error(Enodrawimage);
            if(font->nfchar == 0)
                error(Enotfont);
            src = drawimage(client, a+5);
            ci = BGSHORT(a+9);
            if(ci >= font->nfchar)
                error(Eindex);
            drawrectangle(&r, a+11);
            drawpoint(&p, a+27);
            memdraw(font->image, r, src, p, memopaque, p, S);
            fc = &font->fchar[ci];
            fc->minx = r.min.x;
            fc->maxx = r.max.x;
            fc->miny = r.min.y;
            fc->maxy = r.max.y;
            fc->left = a[35];
            fc->width = a[36];
            continue;

        /* draw line: 'L' dstid[4] p0[2*4] p1[2*4] end0[4] end1[4] radius[4] srcid[4] sp[2*4] */
        case 'L':
            printmesg(fmt="LPPlllLP", a, 0);
            m = 1+4+2*4+2*4+4+4+4+4+2*4;
            if(n < m)
                error(Eshortdraw);
            dst = drawimage(client, a+1);
            dstid = BGLONG(a+1);
            drawpoint(&p, a+5);
            drawpoint(&q, a+13);
            e0 = BGLONG(a+21);
            e1 = BGLONG(a+25);
            j = BGLONG(a+29);
            if(j < 0)
                error("negative line width");
            src = drawimage(client, a+33);
            drawpoint(&sp, a+37);
            op = drawclientop(client);
            memline(dst, p, q, e0, e1, j, src, sp, op);
            /* avoid memlinebbox if possible */
            if(dstid==0 || dst->layer!=nil){
                /* BUG: this is terribly inefficient: update maximal containing rect*/
                r = memlinebbox(p, q, e0, e1, j);
                dstflush(dstid, dst, insetrect(r, -(1+1+j)));
            }
            continue;

        /* create image mask: 'm' newid[4] id[4] */
/*
 *
        case 'm':
            printmesg("LL", a, 0);
            m = 4+4;
            if(n < m)
                error(Eshortdraw);
            break;
 *
 */

        /* attach to a named image: 'n' dstid[4] j[1] name[j] */
        case 'n':
            printmesg(fmt="Lz", a, 0);
            m = 1+4+1;
            if(n < m)
                error(Eshortdraw);
            j = a[5];
            if(j == 0)  /* give me a non-empty name please */
                error(Eshortdraw);
            m += j;
            if(n < m)
                error(Eshortdraw);
            dstid = BGLONG(a+1);
            if(drawlookup(client, dstid, 0))
                error(Eimageexists);
            dn = drawlookupname(j, (char*)a+6);
            if(dn == nil)
                error(Enoname);
            if(drawinstall(client, dstid, dn->dimage->image, 0) == 0)
                error(Edrawmem);
            di = drawlookup(client, dstid, 0);
            if(di == 0)
                error("draw: cannot happen");
            di->vers = dn->vers;
            di->name = smalloc(j+1);
            di->fromname = dn->dimage;
            di->fromname->ref++;
            memmove(di->name, a+6, j);
            di->name[j] = 0;
            client->infoid = dstid;
            continue;

        /* name an image: 'N' dstid[4] in[1] j[1] name[j] */
        case 'N':
            printmesg(fmt="Lbz", a, 0);
            m = 1+4+1+1;
            if(n < m)
                error(Eshortdraw);
            c = a[5];
            j = a[6];
            if(j == 0)  /* give me a non-empty name please */
                error(Eshortdraw);
            m += j;
            if(n < m)
                error(Eshortdraw);
            di = drawlookup(client, BGLONG(a+1), 0);
            if(di == 0)
                error(Enodrawimage);
            if(di->name)
                error(Enamed);
            if(c)
                drawaddname(client, di, j, (char*)a+7);
            else{
                dn = drawlookupname(j, (char*)a+7);
                if(dn == nil)
                    error(Enoname);
                if(dn->dimage != di)
                    error(Ewrongname);
                drawdelname(dn);
            }
            continue;

        /* position window: 'o' id[4] r.min [2*4] screenr.min [2*4] */
        case 'o':
            printmesg(fmt="LPP", a, 0);
            m = 1+4+2*4+2*4;
            if(n < m)
                error(Eshortdraw);
            dst = drawimage(client, a+1);
            if(dst->layer){
                drawpoint(&p, a+5);
                drawpoint(&q, a+13);
                r = dst->layer->screenr;
                ni = memlorigin(dst, p, q);
                if(ni < 0)
                    error("image origin failed");
                if(ni > 0){
                    addflush(r);
                    addflush(dst->layer->screenr);
                    ll = drawlookup(client, BGLONG(a+1), 1);
                    drawrefreshscreen(ll, client);
                }
            }
            continue;

        /* set compositing operator for next draw operation: 'O' op */
        case 'O':
            printmesg(fmt="b", a, 0);
            m = 1+1;
            if(n < m)
                error(Eshortdraw);
            client->op = a[1];
            continue;

        /* filled polygon: 'P' dstid[4] n[2] wind[4] ignore[2*4] srcid[4] sp[2*4] p0[2*4] dp[2*2*n] */
        /* polygon: 'p' dstid[4] n[2] end0[4] end1[4] radius[4] srcid[4] sp[2*4] p0[2*4] dp[2*2*n] */
        case 'p':
        case 'P':
            printmesg(fmt="LslllLPP", a, 0);
            m = 1+4+2+4+4+4+4+2*4;
            if(n < m)
                error(Eshortdraw);
            dstid = BGLONG(a+1);
            dst = drawimage(client, a+1);
            ni = BGSHORT(a+5);
            if(ni < 0)
                error("negative count in polygon");
            e0 = BGLONG(a+7);
            e1 = BGLONG(a+11);
            j = 0;
            if(*a == 'p'){
                j = BGLONG(a+15);
                if(j < 0)
                    error("negative polygon line width");
            }
            src = drawimage(client, a+19);
            drawpoint(&sp, a+23);
            drawpoint(&p, a+31);
            ni++;
            pp = malloc(ni*sizeof(Point));
            if(pp == nil)
                error(Enomem);
            doflush = 0;
            if(dstid==0 || (dst->layer && dst->layer->screen->image->data == screenimage->data))
                doflush = 1;    /* simplify test in loop */
            ox = oy = 0;
            esize = 0;
            u = a+m;
            for(y=0; y<ni; y++){
                q = p;
                oesize = esize;
                u = drawcoord(u, a+n, ox, &p.x);
                u = drawcoord(u, a+n, oy, &p.y);
                ox = p.x;
                oy = p.y;
                if(doflush){
                    esize = j;
                    if(*a == 'p'){
                        if(y == 0){
                            c = memlineendsize(e0);
                            if(c > esize)
                                esize = c;
                        }
                        if(y == ni-1){
                            c = memlineendsize(e1);
                            if(c > esize)
                                esize = c;
                        }
                    }
                    if(*a=='P' && e0!=1 && e0 !=~0)
                        r = dst->clipr;
                    else if(y > 0){
                        r = Rect(q.x-oesize, q.y-oesize, q.x+oesize+1, q.y+oesize+1);
                        combinerect(&r, Rect(p.x-esize, p.y-esize, p.x+esize+1, p.y+esize+1));
                    }
                    if(rectclip(&r, dst->clipr))        /* should perhaps be an arg to dstflush */
                        dstflush(dstid, dst, r);
                }
                pp[y] = p;
            }
            if(y == 1)
                dstflush(dstid, dst, Rect(p.x-esize, p.y-esize, p.x+esize+1, p.y+esize+1));
            op = drawclientop(client);
            if(*a == 'p')
                mempoly(dst, pp, ni, e0, e1, j, src, sp, op);
            else
                memfillpoly(dst, pp, ni, e0, src, sp, op);
            free(pp);
            m = u-a;
            continue;

        /* read: 'r' id[4] R[4*4] */
        case 'r':
            printmesg(fmt="LR", a, 0);
            m = 1+4+4*4;
            if(n < m)
                error(Eshortdraw);
            i = drawimage(client, a+1);
            drawrectangle(&r, a+5);
            if(!rectinrect(r, i->r))
                error(Ereadoutside);
            c = bytesperline(r, i->depth);
            c *= Dy(r);
            free(client->readdata);
            client->readdata = mallocz(c, 0);
            if(client->readdata == nil)
                error("readimage malloc failed");
            client->nreaddata = memunload(i, r, client->readdata, c);
            if(client->nreaddata < 0){
                free(client->readdata);
                client->readdata = nil;
                error("bad readimage call");
            }
            continue;

        /* string: 's' dstid[4] srcid[4] fontid[4] P[2*4] clipr[4*4] sp[2*4] ni[2] ni*(index[2]) */
        /* stringbg: 'x' dstid[4] srcid[4] fontid[4] P[2*4] clipr[4*4] sp[2*4] ni[2] bgid[4] bgpt[2*4] ni*(index[2]) */
        case 's':
        case 'x':
            printmesg(fmt="LLLPRPs", a, 0);
            m = 1+4+4+4+2*4+4*4+2*4+2;
            if(*a == 'x')
                m += 4+2*4;
            if(n < m)
                error(Eshortdraw);

            dst = drawimage(client, a+1);
            dstid = BGLONG(a+1);
            src = drawimage(client, a+5);
            font = drawlookup(client, BGLONG(a+9), 1);
            if(font == 0)
                error(Enodrawimage);
            if(font->nfchar == 0)
                error(Enotfont);
            drawpoint(&p, a+13);
            drawrectangle(&r, a+21);
            drawpoint(&sp, a+37);
            ni = BGSHORT(a+45);
            u = a+m;
            m += ni*2;
            if(n < m)
                error(Eshortdraw);
            clipr = dst->clipr;
            dst->clipr = r;
            op = drawclientop(client);
            bg = dst;
            if(*a == 'x'){
                /* paint background */
                bg = drawimage(client, a+47);
                drawpoint(&q, a+51);
                r.min.x = p.x;
                r.min.y = p.y-font->ascent;
                r.max.x = p.x;
                r.max.y = r.min.y+Dy(font->image->r);
                j = ni;
                while(--j >= 0){
                    ci = BGSHORT(u);
                    if(ci<0 || ci>=font->nfchar){
                        dst->clipr = clipr;
                        error(Eindex);
                    }
                    r.max.x += font->fchar[ci].width;
                    u += 2;
                }
                memdraw(dst, r, bg, q, memopaque, ZP, op);
                u -= 2*ni;
            }
            q = p;
            while(--ni >= 0){
                ci = BGSHORT(u);
                if(ci<0 || ci>=font->nfchar){
                    dst->clipr = clipr;
                    error(Eindex);
                }
                q = drawchar(dst, bg, q, src, &sp, font, ci, op);
                u += 2;
            }
            dst->clipr = clipr;
            p.y -= font->ascent;
            dstflush(dstid, dst, Rect(p.x, p.y, q.x, p.y+Dy(font->image->r)));
            continue;

        /* use public screen: 'S' id[4] chan[4] */
        case 'S':
            printmesg(fmt="Ll", a, 0);
            m = 1+4+4;
            if(n < m)
                error(Eshortdraw);
            dstid = BGLONG(a+1);
            if(dstid == 0)
                error(Ebadarg);
            dscrn = drawlookupdscreen(dstid);
            if(dscrn==0 || (dscrn->public==0 && dscrn->owner!=client))
                error(Enodrawscreen);
            if(dscrn->screen->image->chan != BGLONG(a+5))
                error("inconsistent chan");
            if(drawinstallscreen(client, dscrn, 0, 0, 0, 0) == 0)
                error(Edrawmem);
            continue;

        /* top or bottom windows: 't' top[1] nw[2] n*id[4] */
        case 't':
            printmesg(fmt="bsL", a, 0);
            m = 1+1+2;
            if(n < m)
                error(Eshortdraw);
            nw = BGSHORT(a+2);
            if(nw < 0)
                error(Ebadarg);
            if(nw == 0)
                continue;
            m += nw*4;
            if(n < m)
                error(Eshortdraw);
            lp = malloc(nw*sizeof(Memimage*));
            if(lp == 0)
                error(Enomem);
            if(waserror()){
                free(lp);
                nexterror();
            }
            for(j=0; j<nw; j++)
                lp[j] = drawimage(client, a+1+1+2+j*4);
            if(lp[0]->layer == 0)
                error("images are not windows");
            for(j=1; j<nw; j++)
                if(lp[j]->layer->screen != lp[0]->layer->screen)
                    error("images not on same screen");
            if(a[1])
                memltofrontn(lp, nw);
            else
                memltorearn(lp, nw);
            if(lp[0]->layer->screen->image->data == screenimage->data)
                for(j=0; j<nw; j++)
                    addflush(lp[j]->layer->screenr);
            ll = drawlookup(client, BGLONG(a+1+1+2), 1);
            drawrefreshscreen(ll, client);
            poperror();
            free(lp);
            continue;

        /* visible: 'v' */
        case 'v':
            printmesg(fmt="", a, 0);
            m = 1;
            drawflush();
            continue;

        /* write: 'y' id[4] R[4*4] data[x*1] */
        /* write from compressed data: 'Y' id[4] R[4*4] data[x*1] */
        case 'y':
        case 'Y':
            printmesg(fmt="LR", a, 0);
        //  iprint("load %c\n", *a);
            m = 1+4+4*4;
            if(n < m)
                error(Eshortdraw);
            dstid = BGLONG(a+1);
            dst = drawimage(client, a+1);
            drawrectangle(&r, a+5);
            if(!rectinrect(r, dst->r))
                error(Ewriteoutside);
            y = memload(dst, r, a+m, n-m, *a=='Y');
            if(y < 0)
                error("bad writeimage call");
            dstflush(dstid, dst, r);
            m += y;
            continue;
        }
    }
    poperror();
}
@

<<global drawdevtab>>=
Dev drawdevtab = {
    .dc       =    'i',
    .name     =    "draw",
               
    .reset    =    devreset,
    .init     =    devinit,
    .shutdown =    devshutdown,
    .attach   =    drawattach,
    .walk     =    drawwalk,
    .stat     =    drawstat,
    .open     =    drawopen,
    .create   =    devcreate,
    .close    =    drawclose,
    .read     =    drawread,
    .bread    =    devbread,
    .write    =    drawwrite,
    .bwrite   =    devbwrite,
    .remove   =    devremove,
    .wstat    =    devwstat,
};
@

<<function drawcmap>>=
/*
 * On 8 bit displays, load the default color map
 */
void
drawcmap(void)
{
    int r, g, b, cr, cg, cb, v;
    int num, den;
    int i, j;

    drawactive(1);  /* to restore map from backup */
    for(r=0,i=0; r!=4; r++)
        for(v=0; v!=4; v++,i+=16){
        for(g=0,j=v-r; g!=4; g++)
            for(b=0;b!=4;b++,j++){
            den = r;
            if(g > den)
                den = g;
            if(b > den)
                den = b;
            if(den == 0)    /* divide check -- pick grey shades */
                cr = cg = cb = v*17;
            else{
                num = 17*(4*den+v);
                cr = r*num/den;
                cg = g*num/den;
                cb = b*num/den;
            }
            setcolor(i+(j&15),
                cr*0x01010101, cg*0x01010101, cb*0x01010101);
            }
    }
}
@

<<function drawblankscreen>>=
void
drawblankscreen(int blank)
{
    int i, nc;
    ulong *p;

    if(blank == sdraw.blanked)
        return;
    if(!candlock())
        return;
    if(screenimage == nil){
        dunlock();
        return;
    }
    p = sdraw.savemap;
    nc = screenimage->depth > 8 ? 256 : 1<<screenimage->depth;

    /*
     * blankscreen uses the hardware to blank the screen
     * when possible.  to help in cases when it is not possible,
     * we set the color map to be all black.
     */
    if(blank == 0){ /* turn screen on */
        for(i=0; i<nc; i++, p+=3)
            setcolor(i, p[0], p[1], p[2]);
        blankscreen(0);
    }else{  /* turn screen off */
        blankscreen(1);
        for(i=0; i<nc; i++, p+=3){
            getcolor(i, &p[0], &p[1], &p[2]);
            setcolor(i, 0, 0, 0);
        }
    }
    sdraw.blanked = blank;
    dunlock();
}
@

<<function drawactive>>=
/*
 * record activity on screen, changing blanking as appropriate
 */
void
drawactive(int active)
{
    if(active){
        drawblankscreen(0);
        sdraw.blanktime = CPUS(0)->ticks;
    }else{
        if(blanktime && sdraw.blanktime && TK2SEC(CPUS(0)->ticks - sdraw.blanktime)/60 >= blanktime)
            drawblankscreen(1);
    }
}
@

<<function drawidletime>>=
int
drawidletime(void)
{
    return TK2SEC(CPUS(0)->ticks - sdraw.blanktime)/60;
}
@


%-------------------------------------------------------------

<<kernel/devices/screen/devdraw.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "../port/error.h"

#include    <draw.h>
#include    <memdraw.h>
#include    <memlayer.h>
#include    <cursor.h>
#include    "screen.h"

<<enum _anon_ (kernel/devices/screen/devdraw.c)>>

<<constant QSHIFT>>

<<function QID bis>>
<<function CLIENTPATH>>
<<constant NHASH bis>>
<<constant HASHMASK>>
<<constant IOUNIT>>

typedef struct Client Client;
typedef struct KDraw KDraw;
typedef struct DImage DImage;
typedef struct DScreen DScreen;
typedef struct CScreen CScreen;
typedef struct FChar FChar;
typedef struct Refresh Refresh;
typedef struct Refx Refx;
typedef struct DName DName;

<<global blanktime>>

<<struct KDraw>>

<<struct Client>>

<<struct Refresh>>

<<struct Refx>>

<<struct DName>>

<<struct FChar>>

<<struct DImage>>

<<struct CScreen>>

<<struct DScreen>>

<<global sdraw>>
<<global drawlock>>

<<global screenimage>>
<<global screendimage>>
<<global screenname>>
<<global screennameid>>

<<global flushrect>>
<<global waste>>
<<global dscreen>>
extern  void        flushmemscreen(Rectangle);
    void        drawmesg(Client*, void*, int);
    void        drawuninstall(Client*, int);
    void        drawfreedimage(DImage*);
    Client*     drawclientofpath(ulong);
    DImage* allocdimage(Memimage*);

<<global Enodrawimage>>
<<global Enodrawscreen>>
<<global Eshortdraw>>
<<global Eshortread>>
<<global Eimageexists>>
<<global Escreenexists>>
<<global Edrawmem>>
<<global Ereadoutside>>
<<global Ewriteoutside>>
<<global Enotfont>>
<<global Eindex>>
<<global Enoclient>>
<<global Enameused>>
<<global Enoname>>
<<global Eoldname>>
<<global Enamed>>
<<global Ewrongname>>

<<function dlock>>

<<function candlock>>

<<function dunlock>>

<<function drawgen>>

<<function drawrefactive>>

<<function drawrefreshscreen>>

<<function drawrefresh>>

<<function addflush>>

<<function dstflush>>

<<function drawflush>>

<<function drawcmp>>

<<function drawlookupname>>

<<function drawgoodname>>

<<function drawlookup>>

<<function drawlookupdscreen>>

<<function drawlookupscreen>>

<<function allocdimage>>

<<function drawinstall>>

<<function drawinstallscreen>>

<<function drawdelname>>

<<function drawfreedscreen>>

<<function drawfreedimage>>

<<function drawuninstallscreen>>

<<function drawuninstall>>

<<function drawaddname>>

<<function drawnewclient>>

<<function drawclientop>>

//int
//drawhasclients(void)
//{
//  /*
//   * if draw has ever been used, we can't resize the frame buffer,
//   * even if all clients have exited (nclients is cumulative); it's too
//   * hard to make work.
//   */
//  return sdraw.nclient != 0;
<<function drawclientofpath>>


<<function drawclient>>

<<function drawimage>>

<<function drawrectangle>>

<<function drawpoint>>

<<function drawchar>>

<<function makescreenimage>>

<<function initscreenimage>>

<<function deletescreenimage>>

<<function resetscreenimage>>

<<function drawattach>>

<<function drawwalk>>

<<function drawstat>>

<<function drawopen>>

<<function drawclose>>

<<function drawread>>

<<function drawwakeall>>

<<function drawwrite>>

<<function drawcoord>>

<<function printmesg>>

<<function drawmesg>>

<<global drawdevtab>>

<<function drawcmap>>

<<function drawblankscreen>>

<<function drawactive>>

<<function drawidletime>>
@


