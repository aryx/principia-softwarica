\section{[[include/gui/]]}

\subsection{[[include/gui/panel.h]]}


%-------------------------------------------------------------

<<include/gui/panel.h>>=
#pragma	src	"/sys/src/libpanel"
#pragma	lib	"libpanel.a"

<<type [[Icon]]>>

// forward decls
typedef struct Panel Panel;		/* a Graphical User Interface element */
typedef struct Scroll Scroll;
typedef struct Rtext Rtext;		/* formattable text */
typedef struct Idol Idol;		/* A picture/text combo */

<<struct [[Scroll]]>>
<<struct [[Rtext]]>>
<<struct [[Panel]]>>

/*
 * Panel flags
 */
<<constant [[PACK]]>>
<<constant [[PACKN]]>>
<<constant [[PACKE]]>>
<<constant [[PACKS]]>>
<<constant [[PACKW]]>>

<<constant [[PACKCEN]]>>

<<constant [[FILLX]]>>
<<constant [[FILLY]]>>

<<constant [[PLACE]]>>
<<constant [[PLACECEN]]>>

<<constant [[PLACES]]>>
<<constant [[PLACEE]]>>
<<constant [[PLACEW]]>>
<<constant [[PLACEN]]>>
<<constant [[PLACENE]]>>
<<constant [[PLACENW]]>>
<<constant [[PLACESE]]>>
<<constant [[PLACESW]]>>

<<constant [[EXPAND]]>>

<<constant [[FIXED]]>>
<<constant [[FIXEDX]]>>
<<constant [[FIXEDY]]>>

<<constant [[MAXX]]>>
<<constant [[MAXY]]>>

<<constant [[BITMAP]]>>
<<constant [[USERFL]]>>

<<constant [[OUT]]>>

/*
 * Priorities
 */
<<constant [[PRI_NORMAL]]>>
<<constant [[PRI_POPUP]]>>
<<constant [[PRI_SCROLLBAR]]>>

/* Rtext.flags */
<<constant [[PL_HOT]]>>
<<constant [[PL_SEL]]>>

<<global [[plkbfocus]]>>

//pad's stuff
<<constant [[NOFLAG]]>>

// Initialization
int plinit(int);			/* initialization */

// Memory
void plfree(Panel *);			/* give back space */

// Drawing
void pldraw(Panel *, Image *);		/* display the panel on the bitmap */

// Events
void plkeyboard(Rune);			/* send a keyboard event to the appropriate Panel */
void plmouse(Panel *, Mouse *);		/* send a Mouse event to a Panel tree */

// Packing
void plpack(Panel *, Rectangle);	/* figure out where to put the Panel & children */
void plmove(Panel *, Point);		/* move an already-packed panel to a new location */


//XXX
void plgrabkb(Panel *);			/* this Panel should receive keyboard events */
void plscroll(Panel *, Panel *, Panel *); /* link up scroll bars */
void plepaste(Panel *, Rune *, int);	/* paste in an edit window */

/*
 * Panel creation & reinitialization functions
 */
Panel *pllabel(Panel *pl, int, Icon *);

Panel *plbutton(Panel *pl, int, Icon *, void (*)(Panel *pl, int));
Panel *plcheckbutton(Panel *pl, int, Icon *, void (*)(Panel *pl, int, int));
Panel *plradiobutton(Panel *pl, int, Icon *, void (*)(Panel *pl, int, int));

Panel *plentry(Panel *pl, int, int, char *, void (*)(Panel *pl, char *));
Panel *pledit(Panel *, int, Point, Rune *, int, void (*)(Panel *));
Panel *plmessage(Panel *pl, int, int, char *);

Panel *plslider(Panel *pl, int, Point, void(*)(Panel *pl, int, int, int));

Panel *plcanvas(Panel *pl, int, void (*)(Panel *), void (*)(Panel *pl, Mouse *));

Panel *plgroup(Panel *pl, int);
Panel *plframe(Panel *pl, int);
Panel *pllist(Panel *pl, int, char *(*)(Panel *, int), int, void(*)(Panel *pl, int, int));
Panel *plidollist(Panel*, int, Point, Font*, Idol*, void (*)(Panel*, int, void*));

Panel *plmenu(Panel *pl, int, Icon **, int, void (*)(int, int));
Panel *plmenubar(Panel *pl, int, int, Icon *, Panel *pl, Icon *, ...);
Panel *plpopup(Panel *pl, int, Panel *pl, Panel *pl, Panel *pl);
Panel *plpulldown(Panel *pl, int, Icon *, Panel *pl, int);

Panel *plscrollbar(Panel *plparent, int flags);
Panel *pltextview(Panel *, int, Point, Rtext *, void (*)(Panel *, int, Rtext *));


// setters
void plplacelabel(Panel *, int);	/* label placement */
void plsetbutton(Panel *, int);		/* set or clear the mark on a button */
void plsetslider(Panel *, int, int);	/* set the value of a slider */
void plesel(Panel *, int, int);		/* set the selection in an edit window */
void plescroll(Panel *, int);		/* scroll an edit window */
void plsetscroll(Panel *, Scroll);	/* set scrolling information */

// getters
char *plentryval(Panel *);		/* entry delivers its value */
Rune *pleget(Panel *);			/* get the text from an edit window */
int plelen(Panel *);			/* get the length of the text from an edit window */
void plegetsel(Panel *, int *, int *);	/* get the selection from an edit window */
Scroll plgetscroll(Panel *);		/* get scrolling information from panel */


// plinitxxx()
void plinitlabel(Panel *, int, Icon *);

void plinitbutton(Panel *, int, Icon *, void (*)(Panel *, int));
void plinitcheckbutton(Panel *, int, Icon *, void (*)(Panel *, int, int));
void plinitradiobutton(Panel *, int, Icon *, void (*)(Panel *, int, int));

void plinitcanvas(Panel *, int, void (*)(Panel *), void (*)(Panel *, Mouse *));
void plinitedit(Panel *, int, Point, Rune *, int, void (*)(Panel *));
void plinitentry(Panel *, int, int, char *, void (*)(Panel *, char *));
void plinitframe(Panel *, int);
void plinitgroup(Panel *, int);
void plinitidollist(Panel*, int, Point, Font*, Idol*, void (*)(Panel*, int, void*));
void plinitlist(Panel *, int, char *(*)(Panel *, int), int, void(*)(Panel *, int, int));
void plinitmenu(Panel *, int, Icon **, int, void (*)(int, int));
void plinitmessage(Panel *, int, int, char *);
void plinitpopup(Panel *, int, Panel *, Panel *, Panel *);
void plinitpulldown(Panel *, int, Icon *, Panel *, int);
void plinitscrollbar(Panel *parent, int flags);
void plinitslider(Panel *, int, Point, void(*)(Panel *, int, int, int));
void plinittextview(Panel *, int, Point, Rtext *, void (*)(Panel *, int, Rtext *));

/*
 * Rtext constructors & destructor
 */
Rtext *plrtstr(Rtext **, int, int, Font *, char *, int, void *);
Rtext *plrtbitmap(Rtext **, int, int, Image *, int, void *);
Rtext *plrtpanel(Rtext **, int, int, Panel *, void *);
void plrtfree(Rtext *);
void plrtseltext(Rtext *, Rtext *, Rtext *);
char *plrtsnarftext(Rtext *);

int plgetpostextview(Panel *);
void plsetpostextview(Panel *, int);

/*
 * Idols
 */
Idol *plmkidol(Idol**, Image*, Image*, char*, void*);
void plfreeidol(Idol*);
Point plidolsize(Idol*, Font*, int);
void *plidollistgetsel(Panel*);

/*
 * Snarf
 */
void plputsnarf(char *);
char *plgetsnarf(void);
void plsnarf(Panel *);			/* snarf a panel */
void plpaste(Panel *);			/* paste a panel */
@


\subsection{[[include/gui/rtext.h]]}

<<constant [[PL_NOPBIT]]>>=
#define	PL_NOPBIT	4
@
<<constant [[PL_NARGBIT]]>>=
#define	PL_NARGBIT	12
@
<<constant [[PL_ARGMASK]]>>=
#define	PL_ARGMASK	((1<<PL_NARGBIT)-1)
@

<<function [[PL_SPECIAL]]>>=
#define	PL_SPECIAL(op)	(((-1<<PL_NOPBIT)|op)<<PL_NARGBIT)
@

<<function [[PL_OP]]>>=
#define	PL_OP(t)	((t)&~PL_ARGMASK)
@

<<function [[PL_ARG]]>>=
#define	PL_ARG(t)	((t)&PL_ARGMASK)
@

<<constant [[PL_TAB]]>>=
#define	PL_TAB		PL_SPECIAL(0)		/* # of tab stops before text */
@


%-------------------------------------------------------------

<<include/gui/rtext.h>>=

/*
 * Rtext definitions
 */
<<constant [[PL_NOPBIT]]>>
<<constant [[PL_NARGBIT]]>>
<<constant [[PL_ARGMASK]]>>
<<function [[PL_SPECIAL]]>>

<<function [[PL_OP]]>>
<<function [[PL_ARG]]>>
<<constant [[PL_TAB]]>>

void pltabsize(int, int);			/* set min tab and tab size */
@



\section{[[lib_gui/libpanel/]]}


\subsection{[[lib_gui/libpanel/pldefs.h]]}

%dead:
%<<constant [[HITME]]>>=
%#define	HITME	0x08000		/* tells ptinpanel not to look at children */
%@





<<enum [[_anon_ (lib_gui/libpanel/pldefs.h)2]]>>=
/*
 * Scroll flags
 */
enum{
    SCROLLUP,
    SCROLLDOWN,
    SCROLLABSY,
    SCROLLLEFT,
    SCROLLRIGHT,
    SCROLLABSX,
};
@
%dead?

<<enum [[_anon_ (lib_gui/libpanel/pldefs.h)3]]>>=
/*
 * Scrollbar, slider orientations
 */
enum{
    HORIZ,
    VERT
};
@

<<struct [[Textwin]]>>=
struct Textwin{
    Rune *text, *etext, *eslack;	/* text, with some slack off the end */
    int top, bot;			/* range of runes visible on screen */
    int sel0, sel1;			/* selection */
    Point *loc, *eloc;		/* ul corners of visible runes (+1 more at end!) */
    Image *b;			/* bitmap the text is drawn in */
    Rectangle r;			/* rectangle the text is drawn in */
    Font *font;			/* font text is drawn in */
    int hgt;			/* same as font->height */
    int tabstop;			/* tab settings are every tabstop pixels */
    int mintab;			/* the minimum size of a tab */
};
@


%-------------------------------------------------------------

<<lib_gui/libpanel/pldefs.h>>=
/*
 * Definitions for internal use only
 */

/*
 * Variable-font text routines
 * These could make a separate library.
 */
int pl_rtfmt(Rtext *, int);
void pl_rtdraw(Image *, Rectangle, Rtext *, int);
void pl_rtredraw(Image *, Rectangle, Rtext *, int, int);
Rtext *pl_rthit(Rtext *, int, Point, Point);

<<constant [[LEAF]]>>
<<constant [[INVIS]]>>
<<constant [[REMOUSE]]>>

<<enum [[Style]]>>
<<enum [[_anon_ (lib_gui/libpanel/pldefs.h)2]]>>
<<enum [[_anon_ (lib_gui/libpanel/pldefs.h)3]]>>

Panel *pl_newpanel(Panel *, int);	/* make a new Panel, given parent & data size */
void *pl_emalloc(int);			/* allocate some space, exit on error */
void *pl_erealloc(void*,int);		/* reallocate some space, exit on error */

void pl_print(Panel *);			/* print a Panel tree */
Panel *pl_ptinpanel(Point, Panel *);	/* highest-priority subpanel containing point */

/*
 * Drawing primitives
 */
int pl_drawinit(int);
Rectangle pl_box(Image *, Rectangle, int);
Rectangle pl_outline(Image *, Rectangle, int);
Point pl_boxsize(Point, int);
void pl_interior(int, Point *, Point *);
void pl_drawicon(Image *, Rectangle, int, int, Icon *);
Rectangle pl_check(Image *, Rectangle, int);
Rectangle pl_radio(Image *, Rectangle, int);
int pl_ckwid(void);
void pl_sliderupd(Image *, Rectangle, int, int, int);
void pl_invis(Panel *, int);
Point pl_iconsize(int, Icon *);
void pl_highlight(Image *, Rectangle);
void pl_clr(Image *, Rectangle);
void pl_fill(Image *, Rectangle);
void pl_cpy(Image *, Point, Rectangle);

/*
 * Rune mangling functions
 */
int pl_idchar(int);
int pl_rune1st(int);
char *pl_nextrune(char *);
int pl_runewidth(Font *, char *);

/*
 * Fixed-font Text-window routines
 * These could be separated out into a separate library.
 */
typedef struct Textwin Textwin;
<<struct [[Textwin]]>>

Textwin *twnew(Image *, Font *, Rune *, int);
void twfree(Textwin *);
void twhilite(Textwin *, int, int, int);
void twselect(Textwin *, Mouse *);
void twreplace(Textwin *, int, int, Rune *, int);
void twscroll(Textwin *, int);
int twpt2rune(Textwin *, Point);
void twreshape(Textwin *, Rectangle);
void twmove(Textwin *, Point);
void plemove(Panel *, Point);
@



\subsection{[[lib_gui/libpanel/init.c]]}

%-------------------------------------------------------------

<<lib_gui/libpanel/init.c>>=
<<[[libpanel]] includes>>

<<function [[plinit]]>>
@


\subsection{[[lib_gui/libpanel/mem.c]]}


%-------------------------------------------------------------

<<lib_gui/libpanel/mem.c>>=
<<[[libpanel]] includes>>

<<function [[pl_emalloc]]>>
<<function [[pl_erealloc]]>>

<<function [[pl_unexpected]]>>
<<function [[pl_drawerror]]>>
<<function [[pl_hiterror]]>>
<<function [[pl_typeerror]]>>
<<function [[pl_getsizeerror]]>>
<<function [[pl_childspaceerror]]>>
<<function [[pl_scrollerror]]>>
<<function [[pl_setscrollbarerror]]>>

<<function [[pl_prinormal]]>>

<<function [[pl_newpanel]]>>
<<function [[plfree]]>>
@


\subsection{[[lib_gui/libpanel/draw.c]]}

<<constant [[PWID]]>>=
#define	PWID	1	/* width of label border */
@

<<constant [[BWID]]>>=
#define	BWID	1	/* width of button relief */
@

<<constant [[FWID]]>>=
#define	FWID	2	/* width of frame relief */
@


<<constant [[CKSIZE]]>>=
#define	CKSIZE	3	/* size of check mark */
@

<<constant [[CKSPACE]]>>=
#define	CKSPACE	2	/* space around check mark */
@

<<constant [[CKWID]]>>=
#define	CKWID	1	/* width of frame around check mark */
@

<<constant [[CKINSET]]>>=
#define	CKINSET	1	/* space around check mark frame */
@

<<constant [[CKBORDER]]>>=
#define	CKBORDER 2	/* space around X inside frame */
@











<<function [[pl_ckwid]]>>=
int pl_ckwid(void){
    return 2*(CKINSET+CKSPACE+CKWID)+CKSIZE;
}
@

<<function [[pl_sliderupd]]>>=
void pl_sliderupd(Image *b, Rectangle r1, int dir, int lo, int hi){
    Rectangle r2, r3;
    r2=r1;
    r3=r1;
    if(lo<0) lo=0;
    if(hi<=lo) hi=lo+1;
    switch(dir){
    case HORIZ:
        r1.max.x=r1.min.x+lo;
        r2.min.x=r1.max.x;
        r2.max.x=r1.min.x+hi;
        if(r2.max.x>r3.max.x) r2.max.x=r3.max.x;
        r3.min.x=r2.max.x;
        break;
    case VERT:
        r1.max.y=r1.min.y+lo;
        r2.min.y=r1.max.y;
        r2.max.y=r1.min.y+hi;
        if(r2.max.y>r3.max.y) r2.max.y=r3.max.y;
        r3.min.y=r2.max.y;
        break;
    }
    draw(b, r1, pl_light, 0, ZP);
    draw(b, r2, pl_dark, 0, ZP);
    draw(b, r3, pl_light, 0, ZP);
}
@




<<function [[pl_invis]]>>=
void pl_invis(Panel *p, int v){
    for(;p;p=p->next){
        if(v) 
            p->flags|=INVIS; 
        else 
            p->flags&=~INVIS;
        pl_invis(p->child, v);
    }
}
@
<<constant [[INVIS]]>>=
#define	INVIS	0x20000		/* don't draw this */
@



<<function [[pl_highlight]]>>=
void pl_highlight(Image *b, Rectangle r){
    draw(b, r, pl_dark, pl_hilit, ZP);
}
@

<<function [[pl_clr]]>>=
void pl_clr(Image *b, Rectangle r){
    draw(b, r, display->white, 0, ZP);
}
@

<<function [[pl_fill]]>>=
void pl_fill(Image *b, Rectangle r){
    draw(b, r, plldepth==0? pl_white : pl_light, 0, ZP);
}
@

<<function [[pl_cpy]]>>=
void pl_cpy(Image *b, Point dst, Rectangle src){
    draw(b, Rpt(dst, addpt(dst, subpt(src.max, src.min))), b, 0, src.min);
}
@


%-------------------------------------------------------------

<<lib_gui/libpanel/draw.c>>=
<<[[libpanel]] includes>>

<<constant [[PWID]]>>
<<constant [[BWID]]>>
<<constant [[FWID]]>>
<<constant [[SPACE]]>>
<<constant [[CKSIZE]]>>
<<constant [[CKSPACE]]>>
<<constant [[CKWID]]>>
<<constant [[CKINSET]]>>
<<constant [[CKBORDER]]>>

<<global [[plldepth]]>>

<<globals [[pl_xxx]]>>

<<function [[pl_drawinit]]>>
<<function [[pl_relief]]>>
<<function [[pl_boxoutline]]>>
<<function [[pl_outline]]>>
<<function [[pl_box]]>>
<<function [[pl_boxsize]]>>
<<function [[pl_interior]]>>

<<function [[pl_drawicon]]>>
<<function [[pl_radio]]>>
<<function [[pl_check]]>>
<<function [[pl_ckwid]]>>
<<function [[pl_sliderupd]]>>

void pl_draw1(Panel *p, Image *b);

<<function [[pl_drawall]]>>
<<function [[pl_draw1]]>>
<<function [[pldraw]]>>
<<function [[pl_invis]]>>
<<function [[pl_iconsize]]>>
<<function [[pl_highlight]]>>
<<function [[pl_clr]]>>
<<function [[pl_fill]]>>
<<function [[pl_cpy]]>>
@


\subsection{[[lib_gui/libpanel/event.c]]}

%-------------------------------------------------------------

<<lib_gui/libpanel/event.c>>=
<<[[libpanel]] includes>>

<<function [[plgrabkb]]>>
<<function [[plkeyboard]]>>

<<function [[pl_ptinpanel]]>>
<<function [[plmouse]]>>
@


\subsection{[[lib_gui/libpanel/print.c]]}


%-------------------------------------------------------------

<<lib_gui/libpanel/print.c>>=
<<[[libpanel]] includes>>

<<function [[pl_iprint]]>>
<<function [[pl_ipprint]]>>
<<function [[pl_print]]>>
@


\subsection{[[lib_gui/libpanel/label.c]]}


%-------------------------------------------------------------

<<lib_gui/libpanel/label.c>>=
<<[[libpanel]] includes>>

typedef struct Label Label;

<<struct [[Label]]>>

<<function [[pl_drawlabel]]>>
<<function [[pl_hitlabel]]>>
<<function [[pl_typelabel]]>>
<<function [[pl_getsizelabel]]>>
<<function [[pl_childspacelabel]]>>
<<function [[plinitlabel]]>>
<<function [[pllabel]]>>
<<function [[plplacelabel]]>>
@


\subsection{[[lib_gui/libpanel/button.c]]}


%-------------------------------------------------------------

<<lib_gui/libpanel/button.c>>=
<<[[libpanel]] includes>>

typedef struct Button Button;

<<struct [[Button]]>>

/*
 * Button types
 */
<<constant [[BUTTON]]>>
<<constant [[CHECK]]>>
<<constant [[RADIO]]>>

<<function [[pl_drawbutton]]>>
<<function [[pl_hitbutton]]>>
<<function [[pl_typebutton]]>>
<<function [[pl_getsizebutton]]>>
<<function [[pl_childspacebutton]]>>
<<function [[pl_initbtype]]>>
<<function [[pl_buttonhit]]>>
<<function [[plinitbutton]]>>
<<function [[plinitcheckbutton]]>>
<<function [[plinitradiobutton]]>>
<<function [[plbutton]]>>
<<function [[plcheckbutton]]>>
<<function [[plradiobutton]]>>

<<function [[pl_hitmenu]]>>
<<function [[plinitmenu]]>>
<<function [[plmenu]]>>
<<function [[plsetbutton]]>>
@


\subsection{[[lib_gui/libpanel/entry.c]]}



%-------------------------------------------------------------

<<lib_gui/libpanel/entry.c>>=
<<[[libpanel]] includes>>
#include <keyboard.h>

typedef struct Entry Entry;

<<struct [[Entry]]>>
<<constant [[SLACK]]>>

<<function [[pl_snarfentry]]>>
<<function [[pl_pasteentry]]>>
<<function [[pl_drawentry]]>>
<<function [[pl_hitentry]]>>
<<function [[pl_typeentry]]>>
<<function [[pl_getsizeentry]]>>
<<function [[pl_childspaceentry]]>>
<<function [[pl_freeentry]]>>
<<function [[plinitentry]]>>
<<function [[plentry]]>>
<<function [[plentryval]]>>
@


\subsection{[[lib_gui/libpanel/edit.c]]}



%-------------------------------------------------------------

<<lib_gui/libpanel/edit.c>>=
/*
 * Interface includes:
 *	void plescroll(Panel *p, int top);
 *		move the given character position onto the top line
 *	void plegetsel(Panel *p, int *sel0, int *sel1);
 *		read the selection back
 *	int plelen(Panel *p);
 *		read the length of the text back
 *	Rune *pleget(Panel *p);
 *		get a pointer to the text
 *	void plesel(Panel *p, int sel0, int sel1);
 *		set the selection -- adjusts hiliting
 *	void plepaste(Panel *p, Rune *text, int ntext);
 *		replace the selection with the given text
 */
<<[[libpanel]] includes>>
#include <keyboard.h>

typedef struct Edit Edit;

<<struct [[Edit]]>>
<<function [[pl_drawedit]]>>

<<function [[pl_snarfedit]]>>
<<function [[pl_pasteedit]]>>

<<function [[pl_hitedit]]>>
<<function [[pl_scrolledit]]>>
<<function [[pl_typeedit]]>>
<<function [[pl_getsizeedit]]>>
<<function [[pl_childspaceedit]]>>
<<function [[pl_freeedit]]>>
<<function [[plinitedit]]>>
<<function [[pledit]]>>
<<function [[plescroll]]>>
<<function [[plegetsel]]>>
<<function [[plelen]]>>
<<function [[pleget]]>>
<<function [[plesel]]>>
<<function [[plepaste]]>>
<<function [[plemove]]>>
@


\subsection{[[lib_gui/libpanel/slider.c]]}


%-------------------------------------------------------------

<<lib_gui/libpanel/slider.c>>=
<<[[libpanel]] includes>>

typedef struct Slider Slider;

<<struct [[Slider]]>>

<<function [[pl_drawslider]]>>
<<function [[pl_hitslider]]>>
<<function [[pl_typeslider]]>>
<<function [[pl_getsizeslider]]>>
<<function [[pl_childspaceslider]]>>
<<function [[plinitslider]]>>
<<function [[plslider]]>>
<<function [[plsetslider]]>>
@


\subsection{[[lib_gui/libpanel/canvas.c]]}


%-------------------------------------------------------------

<<lib_gui/libpanel/canvas.c>>=
<<[[libpanel]] includes>>

typedef struct Canvas Canvas;

<<struct [[Canvas]]>>

<<function [[pl_drawcanvas]]>>
<<function [[pl_hitcanvas]]>>
<<function [[pl_typecanvas]]>>
<<function [[pl_getsizecanvas]]>>
<<function [[pl_childspacecanvas]]>>
<<function [[plinitcanvas]]>>
<<function [[plcanvas]]>>
@


\subsection{[[lib_gui/libpanel/frame.c]]}


%-------------------------------------------------------------

<<lib_gui/libpanel/frame.c>>=
<<[[libpanel]] includes>>

<<function [[pl_drawframe]]>>
<<function [[pl_hitframe]]>>
<<function [[pl_typeframe]]>>
<<function [[pl_getsizeframe]]>>
<<function [[pl_childspaceframe]]>>
<<function [[plinitframe]]>>
<<function [[plframe]]>>
@


\subsection{[[lib_gui/libpanel/group.c]]}


%-------------------------------------------------------------

<<lib_gui/libpanel/group.c>>=
<<[[libpanel]] includes>>

<<function [[pl_drawgroup]]>>
<<function [[pl_hitgroup]]>>
<<function [[pl_typegroup]]>>
<<function [[pl_getsizegroup]]>>
<<function [[pl_childspacegroup]]>>
<<function [[plinitgroup]]>>
<<function [[plgroup]]>>
@


\subsection{[[lib_gui/libpanel/list.c]]}


%-------------------------------------------------------------

<<lib_gui/libpanel/list.c>>=
<<[[libpanel]] includes>>

typedef struct List List;

<<struct [[List]]>>
<<constant [[MAXHGT]]>>

<<function [[pl_listsel]]>>
<<function [[pl_liststrings]]>>
<<function [[pl_drawlist]]>>
<<function [[pl_hitlist]]>>
<<function [[pl_scrolllist]]>>
<<function [[pl_typelist]]>>
<<function [[pl_getsizelist]]>>
<<function [[pl_childspacelist]]>>
<<function [[plinitlist]]>>
<<function [[pllist]]>>
@


\subsection{[[lib_gui/libpanel/message.c]]}


%-------------------------------------------------------------

<<lib_gui/libpanel/message.c>>=
<<[[libpanel]] includes>>

typedef struct Message Message;

<<struct [[Message]]>>

<<function [[pl_textmsg]]>>
<<function [[pl_foldsize]]>>
<<function [[pl_drawmessage]]>>
<<function [[pl_hitmessage]]>>
<<function [[pl_typemessage]]>>
<<function [[pl_getsizemessage]]>>
<<function [[pl_childspacemessage]]>>
<<function [[plinitmessage]]>>
<<function [[plmessage]]>>
@


\subsection{[[lib_gui/libpanel/pack.c]]}


%-------------------------------------------------------------

<<lib_gui/libpanel/pack.c>>=
<<[[libpanel]] includes>>

<<function [[pl_max]]>>
<<function [[pl_sizesibs]]>>
<<function [[pl_sizereq]]>>
<<function [[pl_getshare]]>>
<<function [[pl_setrect]]>>
<<function [[plpack]]>>
<<function [[plmove]]>>
@


\subsection{[[lib_gui/libpanel/popup.c]]}


%-------------------------------------------------------------

<<lib_gui/libpanel/popup.c>>=
/*
 * popup
 *	looks like a group, except diverts hits on certain buttons to
 *	panels that it temporarily pops up.
 */
<<[[libpanel]] includes>>

typedef struct Popup Popup;

<<struct [[Popup]]>>

<<function [[pl_drawpopup]]>>
<<function [[pl_hitpopup]]>>
<<function [[pl_typepopup]]>>
<<function [[pl_getsizepopup]]>>
<<function [[pl_childspacepopup]]>>
<<function [[pl_pripopup]]>>
<<function [[plinitpopup]]>>
<<function [[plpopup]]>>
@


\subsection{[[lib_gui/libpanel/pulldown.c]]}


%-------------------------------------------------------------

<<lib_gui/libpanel/pulldown.c>>=
/*
 * pulldown
 *	makes a button that pops up a panel when hit
 */
<<[[libpanel]] includes>>

typedef struct Pulldown Pulldown;

<<struct [[Pulldown]]>>

<<function [[pl_drawpulldown]]>>
<<function [[pl_hitpulldown]]>>
<<function [[pl_typepulldown]]>>
<<function [[pl_getsizepulldown]]>>
<<function [[pl_childspacepulldown]]>>
<<function [[plinitpulldown]]>>
<<function [[plpulldown]]>>
<<function [[plmenubar]]>>
@


\subsection{[[lib_gui/libpanel/rtext.c]]}

<<constant [[LEAD]]>>=
#define LEAD	4	/* extra space between lines */
@

<<constant [[BORD]]>>=
#define BORD	2	/* extra border for images */
@


<<function [[pltabsize]]>>=
void pltabsize(int min, int size){
    pl_tabmin=min;
    pl_tabsize=size;
}
@

<<function [[pl_space]]>>=
int pl_space(int space, int pos, int indent){
    if(space>=0) return space;
    switch(PL_OP(space)){
    default:
        return 0;
    case PL_TAB:
        return ((pos-indent+pl_tabmin)/pl_tabsize+PL_ARG(space))*pl_tabsize+indent-pos;
    }
}
@

<<function [[pl_rtfmt]]>>=
/*
 * initialize rectangles & nextlines of text starting at t,
 * galley width is wid.  Returns the total length of the text
 */
int pl_rtfmt(Rtext *t, int wid){
    Rtext *tp, *eline;
    int ascent, descent, x, space, a, d, w, topy, indent;
    Point p;
    p=Pt(0,0);
    eline=t;
    while(t){
        ascent=0;
        descent=0;
        indent=space=pl_space(t->indent, 0, 0);
        x=0;
        tp=t;
        for(;;){
            if(tp->b){
                a=tp->b->r.max.y-tp->b->r.min.y+BORD;
                d=BORD;
                w=tp->b->r.max.x-tp->b->r.min.x+BORD*2;
            }
            else if(tp->p){
                /* what if plpack fails? */
                plpack(tp->p, Rect(0,0,wid,wid));
                plmove(tp->p, subpt(Pt(0,0), tp->p->r.min));
                a=tp->p->r.max.y-tp->p->r.min.y;
                d=0;
                w=tp->p->r.max.x-tp->p->r.min.x;
            }
            else{
                a=tp->font->ascent;
                d=tp->font->height-a;
                w=tp->wid=stringwidth(tp->font, tp->text);
            }
            if(x+w+space>wid) break;
            if(a>ascent) ascent=a;
            if(d>descent) descent=d;
            x+=w+space;
            tp=tp->next;
            if(tp==0){
                eline=0;
                break;
            }
            space=pl_space(tp->space, x, indent);
            if(space) eline=tp;
        }
        if(eline==t){	/* No progress!  Force fit the first block! */
            if(tp==t){
                if(a>ascent) ascent=a;
                if(d>descent) descent=d;
                eline=tp->next;
            }else
                eline=tp;
        }
        topy=p.y;
        p.y+=ascent;
        p.x=indent=pl_space(t->indent, 0, 0);
        for(;;){
            t->topy=topy;
            t->r.min.x=p.x;
            if(t->b){
                t->r.max.y=p.y+BORD;
                t->r.min.y=p.y-(t->b->r.max.y-t->b->r.min.y)-BORD;
                p.x+=(t->b->r.max.x-t->b->r.min.x)+BORD*2;
            }
            else if(t->p){
                t->r.max.y=p.y;
                t->r.min.y=p.y-t->p->r.max.y;
                p.x+=t->p->r.max.x;
            }
            else{
                t->r.min.y=p.y-t->font->ascent;
                t->r.max.y=t->r.min.y+t->font->height;
                p.x+=t->wid;
            }
            t->r.max.x=p.x;
            t->nextline=eline;
            t=t->next;
            if(t==eline) break;
            p.x+=pl_space(t->space, p.x, indent);
        }
        p.y+=descent+LEAD;
    }
    return p.y;
}
@

<<function [[pl_stuffbitmap]]>>=
/*
 * If we draw the text in a backup bitmap and copy it onto the screen,
 * the bitmap pointers in all the subpanels point to the wrong bitmap.
 * This code fixes them.
 */
void pl_stuffbitmap(Panel *p, Image *b){
    p->b=b;
    for(p=p->child;p;p=p->next)
        pl_stuffbitmap(p, b);
}
@


<<function [[pl_reposition]]>>=
/*
 * Reposition text already drawn in the window.
 * We just move the pixels and update the positions of any
 * enclosed panels
 */
void pl_reposition(Rtext *t, Image *b, Point p, Rectangle r){
    Point offs;
    pl_cpy(b, p, r);
    offs=subpt(p, r.min);
    for(;t;t=t->next)
        if(!eqrect(t->r, Rect(0,0,0,0)) && !t->b && t->p)
            plmove(t->p, offs);
}
@




<<function [[plrtsnarftext]]>>=
char *plrtsnarftext(Rtext *w){
    char *b, *p, *e, *t;
    int n;

    b=p=e=0;
    for(; w; w = w->next){
        if((w->flags&PL_SEL)==0 || w->text==0)
            continue;
        n = strlen(w->text)+64;
        if(p+n >= e){
            n = (p+n+64)-b;
            t = pl_erealloc(b, n);
            p = t+(p-b);
            e = t+n;
            b = t;
        }
        if(w->space == 0)
            p += sprint(p, "%s", w->text);
        else if(w->space > 0)
            p += sprint(p, " %s", w->text);
        else if(PL_OP(w->space) == PL_TAB)
            p += sprint(p, "\t%s", w->text);
        if(w->nextline == w->next)
            p += sprint(p, "\n");
    }
    return b;
}
@


%-------------------------------------------------------------

<<lib_gui/libpanel/rtext.c>>=
/*
 * Rich text with images.
 * Should there be an offset field, to do subscripts & kerning?
 */
<<[[libpanel]] includes>>
#include "rtext.h"

<<constant [[LEAD]]>>
<<constant [[BORD]]>>

<<function [[pl_rtnew]]>>
<<function [[plrtpanel]]>>
<<function [[plrtstr]]>>
<<function [[plrtbitmap]]>>
<<function [[plrtfree]]>>
int pl_tabmin;
int pl_tabsize;
<<function [[pltabsize]]>>
<<function [[pl_space]]>>
<<function [[pl_rtfmt]]>>

<<function [[pl_stuffbitmap]]>>

<<function [[pl_rtdraw]]>>
<<function [[pl_reposition]]>>
<<function [[pl_rtredraw]]>>
<<function [[pl_rthit]]>>

<<function [[plrtseltext]]>>

<<function [[plrtsnarftext]]>>
@


\subsection{[[lib_gui/libpanel/scroll.c]]}

<<function [[plscroll]]>>=
void plscroll(Panel *scrollee, Panel *xscroller, Panel *yscroller){
    scrollee->xscroller=xscroller;
    scrollee->yscroller=yscroller;
    if(xscroller) xscroller->scrollee=scrollee;
    if(yscroller) yscroller->scrollee=scrollee;
}
@

<<function [[plgetscroll]]>>=
Scroll plgetscroll(Panel *p){
    return p->scr;
}
@

<<function [[plsetscroll]]>>=
void plsetscroll(Panel *p, Scroll s){
    if(p->scroll){
        if(s.size.x) p->scroll(p, HORIZ, 2, s.pos.x, s.size.x);
        if(s.size.y) p->scroll(p, VERT, 2, s.pos.y, s.size.y);
    }
}
@


%-------------------------------------------------------------

<<lib_gui/libpanel/scroll.c>>=
<<[[libpanel]] includes>>

<<function [[plscroll]]>>
<<function [[plgetscroll]]>>
<<function [[plsetscroll]]>>
@


\subsection{[[lib_gui/libpanel/scrollbar.c]]}


<<constant [[SBWID]]>>=
#define	SBWID	15	/* should come from draw.c? */
@




%-------------------------------------------------------------

<<lib_gui/libpanel/scrollbar.c>>=
<<[[libpanel]] includes>>

typedef struct Scrollbar Scrollbar;

<<struct [[Scrollbar]]>>
<<constant [[SBWID]]>>

<<function [[pl_drawscrollbar]]>>
<<function [[pl_hitscrollbar]]>>
<<function [[pl_typescrollbar]]>>
<<function [[pl_getsizescrollbar]]>>
<<function [[pl_childspacescrollbar]]>>
<<function [[pl_setscrollbarscrollbar]]>>
<<function [[pl_priscrollbar]]>>
<<function [[plinitscrollbar]]>>
<<function [[plscrollbar]]>>
@


\subsection{[[lib_gui/libpanel/snarf.c]]}


%-------------------------------------------------------------

<<lib_gui/libpanel/snarf.c>>=
<<[[libpanel]] includes>>

<<function [[plputsnarf]]>>
<<function [[plgetsnarf]]>>
<<function [[plsnarf]]>>
<<function [[plpaste]]>>
@


\subsection{[[lib_gui/libpanel/textview.c]]}


<<function [[pl_setscrpos]]>>=
void pl_setscrpos(Panel *p, Textview *tp, Rectangle r){
    Panel *sb;
    int lo, hi;
    lo=tp->yoffs;
    hi=lo+r.max.y-r.min.y;	/* wrong? */
    sb=p->yscroller;
    if(sb && sb->setscrollbar) sb->setscrollbar(sb, lo, hi, tp->thgt);
}
@


<<function [[pl_passon]]>>=
/*
 * If t is a panel word, pass the mouse event on to it
 */
void pl_passon(Rtext *t, Mouse *m){
    if(t && t->b==0 && t->p!=0)
        plmouse(t->p, m);
}
@


<<function [[pl_scrolltextview]]>>=
void pl_scrolltextview(Panel *p, int dir, int buttons, int num, int den){
    int yoffs;
    Point ul, size;
    Textview *tp;
    Rectangle r;
    if(dir!=VERT) return;

    tp=p->data;
    ul=p->r.min;
    size=subpt(p->r.max, p->r.min);
    pl_interior(p->state, &ul, &size);
    switch(buttons){
    default:
        SET(yoffs);
        break;
    case 1:		/* left -- top moves to pointer */
        yoffs=(vlong)tp->yoffs-num*size.y/den;
        if(yoffs<0) yoffs=0;
        break;
    case 2:		/* middle -- absolute index of file */
        yoffs=(vlong)tp->thgt*num/den;
        break;
    case 4:		/* right -- line pointed at moves to top */
        yoffs=tp->yoffs+(vlong)num*size.y/den;
        if(yoffs>tp->thgt) yoffs=tp->thgt;
        break;
    }
    if(yoffs!=tp->yoffs){
        r=pl_outline(p->b, p->r, p->state);
        pl_rtredraw(p->b, r, tp->text, yoffs, tp->yoffs);
        p->scr.pos.y=tp->yoffs=yoffs;
        pl_setscrpos(p, tp, r);
    }
}
@



<<function [[pl_pritextview]]>>=
/*
 * Priority depends on what thing inside the panel we're pointing at.
 */
int pl_pritextview(Panel *p, Point xy){
    Point ul, size;
    Textview *tp;
    Rtext *h;
    tp=p->data;
    ul=p->r.min;
    size=subpt(p->r.max, p->r.min);
    pl_interior(p->state, &ul, &size);
    h=pl_rthit(tp->text, tp->yoffs, xy, ul);
    if(h && h->b==0 && h->p!=0){
        p=pl_ptinpanel(xy, h->p);
        if(p) return p->pri(p, xy);
    }
    return PRI_NORMAL;
}
@

<<function [[pl_snarftextview]]>>=
char* pl_snarftextview(Panel *p){
    return plrtsnarftext(((Textview *)p->data)->text);
}
@



<<function [[plgetpostextview]]>>=
int plgetpostextview(Panel *p){
    return ((Textview *)p->data)->yoffs;
}
@

<<function [[plsetpostextview]]>>=
void plsetpostextview(Panel *p, int yoffs){
    ((Textview *)p->data)->yoffs=yoffs;
    pldraw(p, p->b);
}
@


%-------------------------------------------------------------

<<lib_gui/libpanel/textview.c>>=
/*
 * Fonted text viewer, calls out to code in rtext.c
 *
 * Should redo this to copy the already-visible parts on scrolling & only
 * update the newly appearing stuff -- then the offscreen assembly bitmap can go away.
 */
<<[[libpanel]] includes>>

typedef struct Textview Textview;
<<struct [[Textview]]>>

<<function [[pl_setscrpos]]>>
<<function [[pl_drawtextview]]>>
<<function [[pl_passon]]>>
<<function [[pl_hittextview]]>>
<<function [[pl_scrolltextview]]>>
<<function [[pl_typetextview]]>>
<<function [[pl_getsizetextview]]>>
<<function [[pl_childspacetextview]]>>
<<function [[pl_pritextview]]>>

<<function [[pl_snarftextview]]>>

<<function [[plinittextview]]>>
<<function [[pltextview]]>>
<<function [[plgetpostextview]]>>
<<function [[plsetpostextview]]>>
@


\subsection{[[lib_gui/libpanel/textwin.c]]}

<<constant [[SLACK]]([[(lib_gui/libpanel/textwin.c)]])>>=
#define SLACK 100
@

<<function [[tw_before]]>>=
/*
 * Is text at point a before or after that at point b?
 */
int tw_before(Textwin *t, Point a, Point b){
    return a.y<b.y || a.y<b.y+t->hgt && a.x<b.x;
}
@

<<function [[twpt2rune]]>>=
/*
 * Return the character index indicated by point p, or -1
 * if its off-screen.  The screen must be up-to-date.
 *
 * Linear search should be binary search.
 */
int twpt2rune(Textwin *t, Point p){
    Point *el, *lp;
    el=t->loc+(t->bot-t->top);
    for(lp=t->loc;lp!=el;lp++)
        if(tw_before(t, p, *lp)){
            if(lp==t->loc) return t->top;
            return lp-t->loc+t->top-1;
        }
    return t->bot;
}
@

<<function [[tw_rune2pt]]>>=
/*
 * Return ul corner of the character with the given index
 */
Point tw_rune2pt(Textwin *t, int i){
    if(i<t->top) return t->r.min;
    if(i>t->bot) return t->r.max;
    return t->loc[i-t->top];
}
@

<<function [[tw_storeloc]]>>=
/*
 * Store p at t->loc[l], extending t->loc if necessary
 */
void tw_storeloc(Textwin *t, int l, Point p){
    int nloc;
    if(l>=t->eloc-t->loc){
        nloc=l+SLACK;
        t->loc=pl_erealloc(t->loc, nloc*sizeof(Point));
        t->eloc=t->loc+nloc;
    }
    t->loc[l]=p;
}
@

<<function [[tw_setloc]]>>=
/*
 * Set the locations at which the given runes should appear.
 * Returns the index of the first rune not set, which might not
 * be last because we reached the bottom of the window.
 *
 * N.B. this zaps the loc of r[last], so that value should be saved first,
 * if it's important.
 */
int tw_setloc(Textwin *t, int first, int last, Point ul){
    Rune *r, *er;
    int x, dt, lp;
    char buf[UTFmax+1];
    er=t->text+last;
    for(r=t->text+first,lp=first-t->top;r!=er && ul.y+t->hgt<=t->r.max.y;r++,lp++){
        tw_storeloc(t, lp, ul);
        switch(*r){
        case '\n':
            ul.x=t->r.min.x;
            ul.y+=t->hgt;
            break;
        case '\t':
            x=ul.x-t->r.min.x+t->mintab+t->tabstop;
            x-=x%t->tabstop;
            ul.x=x+t->r.min.x;
            if(ul.x>t->r.max.x){
                ul.x=t->r.min.x;
                ul.y+=t->hgt;
                tw_storeloc(t, lp, ul);
                if(ul.y+t->hgt>t->r.max.y) return r-t->text;
                ul.x+=+t->tabstop;
            }
            break;
        default:
            buf[runetochar(buf, r)]='\0';
            dt=stringwidth(t->font, buf);
            ul.x+=dt;
            if(ul.x>t->r.max.x){
                ul.x=t->r.min.x;
                ul.y+=t->hgt;
                tw_storeloc(t, lp, ul);
                if(ul.y+t->hgt>t->r.max.y) return r-t->text;
                ul.x+=dt;
            }
            break;
        }
    }
    tw_storeloc(t, lp, ul);
    return r-t->text;
}
@

<<function [[tw_draw]]>>=
/*
 * Draw the given runes at their locations.
 * Bug -- saving up multiple characters would
 * reduce the number of calls to string,
 * and probably make this a lot faster.
 */
void tw_draw(Textwin *t, int first, int last){
    Rune *r, *er;
    Point *lp, ul, ur;
    char buf[UTFmax+1];
    if(first<t->top) first=t->top;
    if(last>t->bot) last=t->bot;
    if(last<=first) return;
    er=t->text+last;
    for(r=t->text+first,lp=t->loc+(first-t->top);r!=er;r++,lp++){
        if(lp->y+t->hgt>t->r.max.y){
            fprint(2, "chr %C, index %ld of %d, loc %d %d, off bottom\n",
                *r, lp-t->loc, t->bot-t->top, lp->x, lp->y);
            return;
        }
        switch(*r){
        case '\n':
            ur=*lp;
            break;
        case '\t':
            ur=*lp;
            if(lp[1].y!=lp[0].y)
                ul=Pt(t->r.min.x, lp[1].y);
            else
                ul=*lp;
            pl_clr(t->b, Rpt(ul, Pt(lp[1].x, ul.y+t->hgt)));
            break;
        default:
            buf[runetochar(buf, r)]='\0';
    /***/		pl_clr(t->b, Rpt(*lp, addpt(*lp, stringsize(t->font, buf))));
            ur=string(t->b, *lp, display->black, ZP, t->font, buf);
            break;
        }
        if(lp[1].y!=lp[0].y)
    /***/		pl_clr(t->b, Rpt(ur, Pt(t->r.max.x, ur.y+t->hgt)));
    }
}
@

<<function [[tw_hilitep]]>>=
/*
 * Hilight the characters with tops between ul and ur
 */
void tw_hilitep(Textwin *t, Point ul, Point ur){
    Point swap;
    int y;
    if(tw_before(t, ur, ul)){ swap=ul; ul=ur; ur=swap;}
    y=ul.y+t->hgt;
    if(y>t->r.max.y) y=t->r.max.y;
    if(ul.y==ur.y)
        pl_highlight(t->b, Rpt(ul, Pt(ur.x, y)));
    else{
        pl_highlight(t->b, Rpt(ul, Pt(t->r.max.x, y)));
        ul=Pt(t->r.min.x, y);
        pl_highlight(t->b, Rpt(ul, Pt(t->r.max.x, ur.y)));
        ul=Pt(t->r.min.x, ur.y);
        y=ur.y+t->hgt;
        if(y>t->r.max.y) y=t->r.max.y;
        pl_highlight(t->b, Rpt(ul, Pt(ur.x, y)));
    }
}
@

<<function [[twhilite]]>>=
/*
 * Hilite/unhilite the given range of characters
 */
void twhilite(Textwin *t, int sel0, int sel1, int on){
    Point ul, ur;
    int swap, y;
    if(sel1<sel0){ swap=sel0; sel0=sel1; sel1=swap; }
    if(sel1<t->top || t->bot<sel0) return;
    if(sel0<t->top) sel0=t->top;
    if(sel1>t->bot) sel1=t->bot;
    if(!on){
        if(sel1==sel0){
            ul=t->loc[sel0-t->top];
            y=ul.y+t->hgt;
            if(y>t->r.max.y) y=t->r.max.y;
            pl_clr(t->b, Rpt(ul, Pt(ul.x+1, y)));
        }else
            tw_draw(t, sel0, sel1);
        return;
    }
    ul=t->loc[sel0-t->top];
    if(sel1==sel0)
        ur=addpt(ul, Pt(1, 0));
    else
        ur=t->loc[sel1-t->top];
    tw_hilitep(t, ul, ur);
}
@

<<function [[twselect]]>>=
/*
 * Set t->sel[01] from mouse input.
 * Also hilites the selection.
 * Caller should unhilite the previous
 * selection before calling this.
 */
void twselect(Textwin *t, Mouse *m){
    int sel0, sel1, newsel;
    Point p0, p1, newp;
    sel0=sel1=twpt2rune(t, m->xy);
    p0=tw_rune2pt(t, sel0);
    p1=addpt(p0, Pt(1, 0));
    twhilite(t, sel0, sel1, 1);
    for(;;){
        flushimage(display, 1);
        *m=emouse();
        if((m->buttons&7)!=1) break;
        newsel=twpt2rune(t, m->xy);
        newp=tw_rune2pt(t, newsel);
        if(eqpt(newp, p0)) newp=addpt(newp, Pt(1, 0));
        if(!eqpt(newp, p1)){
            if((sel0<=sel1 && sel1<newsel) || (newsel<sel1 && sel1<sel0))
                tw_hilitep(t, p1, newp);
            else if((sel0<=newsel && newsel<sel1) || (sel1<newsel && newsel<=sel0)){
                twhilite(t, sel1, newsel, 0);
                if(newsel==sel0)
                    tw_hilitep(t, p0, newp);
            }else if((newsel<sel0 && sel0<=sel1) || (sel1<sel0 && sel0<=newsel)){
                twhilite(t, sel0, sel1, 0);
                tw_hilitep(t, p0, newp);
            }
            sel1=newsel;
            p1=newp;
        }
    }
    if(sel0<=sel1){
        t->sel0=sel0;
        t->sel1=sel1;
    }
    else{
        t->sel0=sel1;
        t->sel1=sel0;
    }
}
@

<<function [[tw_clrend]]>>=
/*
 * Clear the area following the last displayed character
 */
void tw_clrend(Textwin *t){
    Point ul;
    int y;
    ul=t->loc[t->bot-t->top];
    y=ul.y+t->hgt;
    if(y>t->r.max.y) y=t->r.max.y;
    pl_clr(t->b, Rpt(ul, Pt(t->r.max.x, y)));
    ul=Pt(t->r.min.x, y);
    pl_clr(t->b, Rpt(ul, t->r.max));
}
@

<<function [[tw_moverect]]>>=
/*
 * Move part of a line of text, truncating the source or padding
 * the destination on the right if necessary.
 */
void tw_moverect(Textwin *t, Point uld, Point urd, Point uls, Point urs){
    int sw, dw, d;
    if(urs.y!=uls.y) urs=Pt(t->r.max.x, uls.y);
    if(urd.y!=uld.y) urd=Pt(t->r.max.x, uld.y);
    sw=uls.x-urs.x;
    dw=uld.x-urd.x;
    if(dw>sw){
        d=dw-sw;
        pl_clr(t->b, Rect(urd.x-d, urd.y, urd.x, urd.y+t->hgt));
        dw=sw;
    }
    pl_cpy(t->b, uld, Rpt(uls, Pt(uls.x+dw, uls.y+t->hgt)));
}
@

<<function [[tw_moveup]]>>=
/*
 * Move a block of characters up or to the left:
 *	Identify contiguous runs of characters whose width doesn't change, and
 *	move them in one bitblt per run.
 *	If we get to a point where source and destination are x-aligned,
 *	they will remain x-aligned for the rest of the block.
 *	Then, if they are y-aligned, they're already in the right place.
 *	Otherwise, we can move them in three bitblts; one if all the
 *	remaining characters are on one line.
 */
void tw_moveup(Textwin *t, Point *dp, Point *sp, Point *esp){
    Point uld, uls;			/* upper left of destination/source */
    int y;
    while(sp!=esp && sp->x!=dp->x){
        uld=*dp;
        uls=*sp;
        while(sp!=esp && sp->y==uls.y && dp->y==uld.y && sp->x-uls.x==dp->x-uld.x){
            sp++;
            dp++;
        }
        tw_moverect(t, uld, *dp, uls, *sp);
    }
    if(sp==esp || esp->y==dp->y) return;
    if(esp->y==sp->y){	/* one line only */
        pl_cpy(t->b, *dp, Rpt(*sp, Pt(esp->x, sp->y+t->hgt)));
        return;
    }
    y=sp->y+t->hgt;
    pl_cpy(t->b, *dp, Rpt(*sp, Pt(t->r.max.x, y)));
    pl_cpy(t->b, Pt(t->r.min.x, dp->y+t->hgt),
        Rect(t->r.min.x, y, t->r.max.x, esp->y));
    y=dp->y+esp->y-sp->y;
    pl_cpy(t->b, Pt(t->r.min.x, y),
        Rect(t->r.min.x, esp->y, esp->x, esp->y+t->hgt));
}
@

<<function [[tw_movedn]]>>=
/*
 * Same as above, but moving down and in reverse order, so as not to overwrite stuff
 * not moved yet.
 */
void tw_movedn(Textwin *t, Point *dp, Point *bsp, Point *esp){
    Point *sp, urs, urd;
    int dy;
    dp+=esp-bsp;
    sp=esp;
    dy=dp->y-sp->y;
    while(sp!=bsp && dp[-1].x==sp[-1].x){
        --dp;
        --sp;
    }
    if(dy!=0){
        if(sp->y==esp->y)
            pl_cpy(t->b, *dp, Rect(sp->x, sp->y, esp->x, esp->y+t->hgt));
        else{
            pl_cpy(t->b, Pt(t->r.min.x, sp->x+dy),
                Rect(t->r.min.x, sp->y, esp->x, esp->y+t->hgt));
            pl_cpy(t->b, Pt(t->r.min.x, dp->y+t->hgt),
                Rect(t->r.min.x, sp->y+t->hgt, t->r.max.x, esp->y));
            pl_cpy(t->b, *dp,
                Rect(sp->x, sp->y, t->r.max.x, sp->y+t->hgt));
        }
    }
    while(sp!=bsp){
        urd=*dp;
        urs=*sp;
        while(sp!=bsp && sp[-1].y==sp[0].y && dp[-1].y==dp[0].y
           && sp[-1].x-sp[0].x==dp[-1].x-dp[0].x){
            --sp;
            --dp;
        }
        tw_moverect(t, *dp, urd, *sp, urs);
    }
}
@

<<function [[tw_relocate]]>>=
/*
 * Move the given range of characters, already drawn on
 * the given textwin, to the given location.
 * Start and end must both index characters that are initially on-screen.
 */
void tw_relocate(Textwin *t, int first, int last, Point dst){
    Point *srcloc;
    int nbyte;
    if(first<t->top || last<first || t->bot<last) return;
    nbyte=(last-first+1)*sizeof(Point);
    srcloc=pl_emalloc(nbyte);
    memmove(srcloc, &t->loc[first-t->top], nbyte);
    tw_setloc(t, first, last, dst);
    if(tw_before(t, dst, srcloc[0]))
        tw_moveup(t, t->loc+first-t->top, srcloc, srcloc+(last-first));
    else
        tw_movedn(t, t->loc+first-t->top, srcloc, srcloc+(last-first));
}
@

<<function [[twreplace]]>>=
/*
 * Replace the runes with indices from r0 to r1-1 with the text
 * pointed to by text, and with length ntext.
 *	Open up a hole in t->text, t->loc.
 *	Insert new text, calculate their locs (save the extra loc that's overwritten first)
 *	(swap saved & overwritten locs)
 *	move tail.
 *	calc locs and draw new text after tail, if necessary.
 *	draw new text, if necessary
 */
void twreplace(Textwin *t, int r0, int r1, Rune *ins, int nins){
    int olen, nlen, tlen, dtop;
    olen=t->etext-t->text;
    nlen=olen+nins-(r1-r0);
    tlen=t->eslack-t->text;
    if(nlen>tlen){
        tlen=nlen+SLACK;
        t->text=pl_erealloc(t->text, tlen*sizeof(Rune));
        t->eslack=t->text+tlen;
    }
    if(olen!=nlen)
        memmove(t->text+r0+nins, t->text+r1, (olen-r1)*sizeof(Rune));
    if(nins!=0)	/* ins can be 0 if nins==0 */
        memmove(t->text+r0, ins, nins*sizeof(Rune));
    t->etext=t->text+nlen;
    if(r0>t->bot)		/* insertion is completely below visible text */
        return;
    if(r1<t->top){		/* insertion is completely above visible text */
        dtop=nlen-olen;
        t->top+=dtop;
        t->bot+=dtop;
        return;
    }
    if(1 || t->bot<=r0+nins){	/* no useful text on screen below r0 */
        if(r0<=t->top)	/* no useful text above, either */
            t->top=r0;
        t->bot=tw_setloc(t, r0, nlen, t->loc[r0-t->top]);
        tw_draw(t, r0, t->bot);
        tw_clrend(t);
        return;
    }
    /*
     * code for case where there is useful text below is missing (see `1 ||' above)
     */
}
@

<<function [[twscroll]]>>=
/*
 * This works but is stupid.
 */
void twscroll(Textwin *t, int top){
    while(top!=0 && t->text[top-1]!='\n') --top;
    t->top=top;
    t->bot=tw_setloc(t, top, t->etext-t->text, t->r.min);
    tw_draw(t, t->top, t->bot);
    tw_clrend(t);
}
@

<<function [[twreshape]]>>=
void twreshape(Textwin *t, Rectangle r){
    t->r=r;
    t->bot=tw_setloc(t, t->top, t->etext-t->text, t->r.min);
    tw_draw(t, t->top, t->bot);
    tw_clrend(t);
}
@

<<function [[twnew]]>>=
Textwin *twnew(Image *b, Font *f, Rune *text, int ntext){
    Textwin *t;
    t=pl_emalloc(sizeof(Textwin));
    t->text=pl_emalloc((ntext+SLACK)*sizeof(Rune));
    t->loc=pl_emalloc(SLACK*sizeof(Point));
    t->eloc=t->loc+SLACK;
    t->etext=t->text+ntext;
    t->eslack=t->etext+SLACK;
    if(ntext) memmove(t->text, text, ntext*sizeof(Rune));
    t->top=0;
    t->bot=0;
    t->sel0=0;
    t->sel1=0;
    t->b=b;
    t->font=f;
    t->hgt=f->height;
    t->mintab=stringwidth(f, "0");
    t->tabstop=8*t->mintab;
    return t;
}
@

<<function [[twfree]]>>=
void twfree(Textwin *t){
    free(t->loc);
    free(t->text);
    free(t);
}
@

<<function [[twmove]]>>=
/*
 * Correct the character locations in a textwin after the panel is moved.
 * This horrid hack would not be necessary if loc values were relative
 * to the panel, rather than absolute.
 */
void twmove(Textwin *t, Point d){
    Point *lp;
    t->r = rectaddpt(t->r, d);
    for(lp=t->loc; lp<t->eloc; lp++)
        *lp = addpt(*lp, d);
}
@


%-------------------------------------------------------------

<<lib_gui/libpanel/textwin.c>>=
/*
 * Text windows
 *	void twhilite(Textwin *t, int sel0, int sel1, int on)
 *		hilite (on=1) or unhilite (on=0) a range of characters
 *	void twselect(Textwin *t, Mouse *m)
 *		set t->sel0, t->sel1 from mouse input.
 *		Also hilites selection.
 *		Caller should first unhilite previous selection.
 *	void twreplace(Textwin *t, int r0, int r1, Rune *ins, int nins)
 *		Replace the given range of characters with the given insertion.
 *		Caller should unhilite selection while this is called.
 *	void twscroll(Textwin *t, int top)
 *		Character with index top moves to the top line of the screen.
 *	int twpt2rune(Textwin *t, Point p)
 *		which character is displayed at point p?
 *	void twreshape(Textwin *t, Rectangle r)
 *		save r and redraw the text
 *	Textwin *twnew(Bitmap *b, Font *f, Rune *text, int ntext)
 *		create a new text window
 *	void twfree(Textwin *t)
 *		get rid of a surplus Textwin
 */
<<[[libpanel]] includes>>

<<constant [[SLACK]]([[(lib_gui/libpanel/textwin.c)]])>>

<<function [[tw_before]]>>
<<function [[twpt2rune]]>>
<<function [[tw_rune2pt]]>>
<<function [[tw_storeloc]]>>
<<function [[tw_setloc]]>>
<<function [[tw_draw]]>>
<<function [[tw_hilitep]]>>
<<function [[twhilite]]>>
<<function [[twselect]]>>
<<function [[tw_clrend]]>>
<<function [[tw_moverect]]>>
<<function [[tw_moveup]]>>
<<function [[tw_movedn]]>>
<<function [[tw_relocate]]>>
<<function [[twreplace]]>>
<<function [[twscroll]]>>
<<function [[twreshape]]>>
<<function [[twnew]]>>
<<function [[twfree]]>>
<<function [[twmove]]>>
@


\subsection{[[lib_gui/libpanel/utf.c]]}

<<function [[pl_idchar]]>>=
/*
 * This is the same definition that 8½ uses
 */
int pl_idchar(int c){
    if(c<=' '
    || 0x7F<=c && c<=0xA0
    || utfrune("!\"#$%&'()*+,-./:;<=>?@`[\\]^{|}~", c))
        return 0;
    return 1;
}
@
%$

<<function [[pl_rune1st]]>>=
int pl_rune1st(int c){
    return (c&0xc0)!=0x80;
}
@

<<function [[pl_nextrune]]>>=
char *pl_nextrune(char *s){
    do s++; while(!pl_rune1st(*s));
    return s;
}
@

<<function [[pl_runewidth]]>>=
int pl_runewidth(Font *f, char *s){
    char r[4], *t;
    t=r;
    do *t++=*s++; while(!pl_rune1st(*s));
    *t='\0';
    return stringwidth(f, r);
}
@


%-------------------------------------------------------------

<<lib_gui/libpanel/utf.c>>=
<<[[libpanel]] includes>>

<<function [[pl_idchar]]>>
<<function [[pl_rune1st]]>>
<<function [[pl_nextrune]]>>
<<function [[pl_runewidth]]>>
@
