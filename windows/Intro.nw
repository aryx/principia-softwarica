%\chapter{Introduction}

The goal of this book is to explain with full details the source code of
a {windowing system}.
\n wikipedia uses this term rather than Window System

\section{Motivations}
\label{sec:motivations}

Why a windowing system? 
Because I think you are a better programmer if
you fully understand how things work under the hood,
and one of the first thing you should see on your screen is
a set of {windows}.
\n def (better later)
The {windowing system} is the program
allowing you to create and manipulate those {windows}.
\n or set of programs (said later)
\n def window (defined later) but most people knows intuitively what it is

%dup: Graphics.nw
Windowing systems are usually coupled with a {graphics system}
to form a {graphical user interface} (GUI).
\n can have a GUI without a windowing system (said later)
\n windowing system is a kind of GUI, a meta-GUI implementing WIMP (said later)
%history: %dup: Graphics.nw
GUIs, introduced in the 1970's with the Xerox Alto~\cite{alto},
were a vast improvement over {text-based} user interfaces, to
the point where every mainstream operating systems now come with a GUI
(e.g., Microsoft Windows, macOS, or Linux with X~Window).
\n iOS/Android dont have windows. just IM actually, but still GUI (said later)
\n even command line become more powerful with multiple windows (said later)

A windowing system relies on a graphics system to {render}
the graphics of a window on a specific rectangular {surface} of the screen.
However, a window is not just a surface; it is also a process.
\l well not in mini-X, draw, etc. rio is universal! like Unix kernel!
\l we will focus on universal windowing system! more than window.h and draw!
Thus, a windowing system manages not only a set of
surfaces, but also a set of processes.
This is similar to what a kernel does.
\n define graphical app vs window vs client vs process (said later)
%
Moreover, just like the kernel manages the {CPU} and {memory}
and virtualizes those resources shared among multiple processes, 
a windowing system manages the {screen} and {input devices} 
(e.g., the mouse, the keyboard)
and virtualizes those resources shared among multiple windows.
\n could be in Principles, but motiv is "rio is as important as the kernel!"
\n multiplex, virtualization, virtual X, abstraction (said later better)
%
The windowing system is a natural extension of the kernel.
In fact, the need for multiple processes and 
a multi-tasking kernel is less obvious without a windowing system.
Linux offers {virtual consoles} where the user can launch independent
commands, but those consoles are a poor's man windowing system.
\l Emacs also has a windowing system, so screen command line tool, etc


Surprisingly, there is almost no book explaining how a windowing system works,
even though there is a myriad of books on kernels.
I can cite {\em The NeWS book: An Introduction to the
Network/Extensible Window System}~\cite{news-book},
or one chapter of 
{\em Computer Graphics, Principles and Practice}~\cite{cgpp-foley}
dedicated to user interface software.
%
Books on operating systems usually do not even include a
chapter on windowing systems.
%
This is a pity because the windowing system is as important
as the kernel for the user.
\n Per Brinch Hansen was right, windowing systems is a major OS innovation!
\l less complex than kernel, but still not trivial!
\l how to implement a windowing system? coordinate processes, clients/server,
\l  async input from multiple sources, concurrency, graphics, efficient, etc.
\l other motivation is that great concurrent program! learn a lot.
\l  learn many concurrency patterns. Also different programming model! reactif!

Here are a few questions I hope this book will answer:
\begin{itemize}

\item What is the software architecture of a windowing system? 
Is the windowing system a regular program?
How does it have access to the mouse and the screen?
Does it need special privileges from the kernel?
How does it cooperate with the kernel?
\l What kind of program it is? server? kernel? setuid program?
\n Xorg originally was a setuid program doing directly assembly ins/out

\item How does the windowing system manage multiple windows/processes? How
does it communicate with those processes?
\n kernel: syscall interface and time interrupt handler
\n rio: through files! /dev/{cons,mouse} for input and /dev/draw for graphics
\n  (and /dev/winname). syscall (for draw), shared image IPC, pipe IPC (for fs)
\n X11: sockets and client/server archi with loop in server

\item How does the windowing system control access to the screen,
a resource used by multiple windows at the same time?
How does it cooperate with the graphics system?
\n leverage draw and delegate to draw

\item How does the windowing system intercept the
drawing operations done by windows
to make sure they can not draw in other windows? 
How is the screen virtualized?
\n well they can draw in other windows, but have originWindow/clipping/named-image
\n I use window instead of graphical application. More specific.
\l intercept pb maybe too specific to draw/rio; no pb in X~Window.

\item How does the windowing system handle the mouse device? When
are mouse events dispatched to the windows? How does
the windowing system decide which window should receive the mouse
event? 
\l difference between a system mouse event and an application mouse event? 
\n location of coordinate and kind of click

\item How does the introduction of the mouse, graphics, and windows changes
the programming model of an application?
%What are the differences between a command-line application and
%a graphical application beyond the obvious? 
\n more a Graphics.nw question in the end, but because rio/draw is special.
\l diff between graphical application and window application
How can an application {react} to a mouse event?
How can the windowing system itself react to a mouse event?
\l windowing system itself is a graphical program and so use same model

\item How does the windowing system handle the keyboard device? How does it
decide which window should receive a keyboard event? How does
it deliver a keyboard event to this window?
\n focused window policy (or follow-mouse focus)
\n and virtual fs for /dev/cons
\l also raw mode need

\l How demultiplex the screen mouse and keyboard? How virtualize?
\n per-process namespace and fileserver for /mnt/wsys/mouse /mnt/wsys/cons
% need create process, delete process, associate window, 
% send resize/refresh, ... kinda a scheduler
% actually you will learn a lot about concurrent programming! nice side effect.

\item How are overlapping windows managed? Where are stored
the pixels of a window overlapped by another window?
How are those pixels restored on the screen
when an overlapped window is exposed back?
\n actually mostly handled by Graphics.nw
\n X11: expose event, but ugly

\item What are the differences among
a windowing system,
a window manager,
a window compositor,
a window server, and
a desktop system?
\l a display server, graphical shell, display manager, session manager, GUI, ...
\n windowing system is all of that mostly.



\item How does a terminal emulator (e.g., [[xterm]]) work?
What are the standard input and output of traditional 
command-line applications when running under an emulator? 
How does the emulator offer
a backward-compatible environment for those applications?
\l how collaborate with kernel?
\n X11: xterm is huge
\n rio: virtual devices far more elegant than pseudo-devices (pty of xterm)

\item What happens when you type [[ls]] in a terminal emulator?
What are the set of programs involved in such a command? What
is the trace of such a command through the different layers
of the software stack, from the keyboard interrupt to
the display of text glyphs on the screen in the appropriate window?

\end{itemize}
\l How terminal scrolling, text selection, copy/paste, etc (libframe/)
\l How menus? actually a layer. How dialog boxes? widgets?

%tags used in this file for different recurring themes:
 %real-world: mostly talk about X~Window
 %in-plan9: when in general section (e.g., principles), instantiate with plan9
 %rio-reflection: exposing features provided by rio but also used by rio
 %toc: %trans: %dup: etc

\t put in conclusion non-trivial adv algo and data structures seen? see comment
%data-structures (beyond list/hashtbl):
% - circular buffers (Window.mouse.queue) producer/consumer indexes
% - growing arrays (windows (by 1), Window.r, Window.nraw, ...)

%algorithms:

%concurrency patterns:
% - master/workers
% - producer/consumer queue (Window.mouse.queue)
% - send and receive alts =~ select
% - passing channels as parameters
% - procs vs threads
% - cooperative threads and no need for lock! 

\section{The \plan{} windowing system: [[rio]]}
\label{sec:rio}

I will explain in this book the code of the \plan windowing system 
[[rio]]~\cite{rio-slides}\footnote{See
\url{http://plan9.bell-labs.com/magic/man2html/4/rio} for its manual page.},
which contains about 10~000 lines of code (LOC).
\n when include libframe/ and libplumb/ and libcomplete/! include full emulator!
[[rio]] is written entirely in C.
\l why called rio? r IO? because plan9 was called Brazil at some point?

%dup: (and adapted) Graphics.nw, intro/motivations
In most operating systems (e.g., macOS, Microsoft Windows),
the windowing system is {\em strongly} coupled with the {graphics system}.
\l and even with the kernel? old Xorg was special. in windows?
%
In \plan, the windowing system [[rio]], and the graphics system,
called [[draw]], are clearly separated; [[rio]] is a user-space
program that relies on [[draw]], which is implemented
as a device in the kernel
(for more information on [[draw]], read the \book{Graphics}).
In \plan, you can run graphical applications with or without [[rio]].
%rio-reflection:
In fact, [[rio]] itself is just a graphical application.
\l call initdraw(), see chapter X.
\n pictures of clock with/without rio (said later)
\l in fact can have recursive!
\l all in userspace, so portable! x86 and ARM!
\l this simplify things but also complicate other I think.


%dup: (and adapted) from Assembler.nw
Like for most books in \principia, I chose a \plan program because
those programs are simple, small, elegant, open source, and they form together
a coherent set.
%history: %dup: (and extended) Graphics.nw
[[rio]] comes from a series of windowing systems designed by Rob Pike:
[[8-1/2]]~\cite{eight-and-a-half}, 
the direct ancestor of [[rio]], running also under \plan;
the ``Concurrent Window System''~\cite{concurrent-window-system}, 
programmed in the Newsqueak language; and 
[[mpx]], the windowing system of the Blit~\cite{blit} machine.
%history:
[[mpx]] was the first windowing system for Unix, and one of the first
windowing system back in 
1982\footnote{See \url{https://www.youtube.com/watch?v=emh22gT5e9k}
for an historical demo of the Blit and [[mpx]], which has
a user interface almost identical to [[rio]].
}.
\n actually GUI of mpx is very similar to rio; not much changed, except color.
\n mpx for multiplex
It was created even before the Macintosh, X~Window, and Microsoft Windows.
\n comment shows the lineage and dates
% Alto -> Pilot? -> Star (commercial system, mouse & windows, desktop metaphor)
%     the electronic office
%      |> Blit, mux ->  ... -> rio
%      |> Smalltalk (or just application on top of Alto?) -> ...
%      |> Macintosh -> Window -> ...
%      |> Lisp Machine? -> W Window -> X~Window
\n so not a bad idea to explain rio; it has street credit like X.


%dup: (and adapted) Graphics.nw
Like many other services in \plan, some of the [[rio]] services
are accessible through files. Indeed, [[rio]] is a graphical application
{\em and} a filesystem.
%
To understand why a part of [[rio]] is implemented as a filesystem, you need
(1) to have a general idea on how to implement a windowing system,
and (2) be familiar with some of the advanced features of the
\plan kernel.

Regarding the first point, at a high level,
a windowing system is a program 
that uses
the mouse (via [[/dev/mouse]] under \plan), 
the keyboard (via [[/dev/cons]]), and 
the screen (via [[/dev/draw]]).
%
However, an application
running in a window
is not different; such an application also wants to
use the mouse, the keyboard, and the screen.
%
Thus, a windowing system can be implemented simply
as a {\em multiplexer}; the windowing system can use
the {\em physical devices} (managed by the kernel)
and serve {\em virtual devices}
to the multiple windows running under it\footnote{For more information, 
see Section~\ref{sec:windowing-system-api} and especially
Figure~\ref{fig:rio-multiplexer}.
}.


Regarding the second point, the \plan kernel has a few
original features that makes it easy to implement 
virtual devices served by programs in user space. Those features are
the {\em per-process namespace}, the {\em union-mount}, and
the {\em file-server protocol 9P}
(see the \book{Kernel} for more information on those features,
or the two \plan articles~\cite{plan9, namespaces-plan9},
which contain both good introductions to those features).
%
With [[rio]], the virtual devices are accessible under [[/mnt/wsys/]]
(e.g., [[/mnt/wsys/mouse]], [[/mnt/wsys/cons]]), 
%
but also under [[/dev/]] 
(e.g., [[/dev/mouse]], [[/dev/cons]]), 
thanks to the union-mount. 
%
Thanks to the per-process namespace, the applications
running under [[rio]] {see} a different [[/dev/mouse]], [[/dev/cons]],
and could see a different [[/dev/draw]]\footnote{For [[/dev/draw]],
the [[draw]] device can already multiplex the screen among 
multiple clients (in [[/dev/draw/1/]], [[/dev/draw/2]], etc).
There is no need for a virtual [[/dev/draw]].
However, the ancestor of [[rio]], [[8-1/2]]~\cite{eight-and-a-half}, 
was serving a virtual [[/dev/draw]] device file, which was more elegant
but also more inefficient.
For more information, see Section~\ref{sec:winname}.
}.
%
Finally, thanks to 9P, all those virtual device files can be served 
by a single user-space program: [[rio]].
%from rio slides:
% "Each window mounts a different root of a distinct file system implemented
%  by Rio, containing an identical-looking simulation of the standard 
%  device file set for display, mouse, and keyboard."
\l again, if not clear, do not worry, explain more later, and can namespace.ps


A nice side effect of the multiplexer approach used by [[rio]] is that
[[rio]] can run under itself (see Section~\ref{sec:recursive-rio}).
%
This is useful for development and debugging purposes.
\n another nice side effect is that same app can run with or without rio (later)
\t I used that? when I introduced some regressions, I could go back to
\t  old binary and run that! but was syscall compatible?
%
Moreover, because you can export filesystems through
the network in \plan, [[rio]] is also a 
{networked windowing system}, similar to X~Window
(even though the code of [[rio]] does not include a single line of
code related to networking).
%
Thus, in \plan, programs running on one machine
can have their window displayed on another machine.

%pro: not as used as X Window. Still production quality.
% In fact first windowing system for Unix! 
% and very interesting program. You will learn about concurrency
% a lot, many concurrency patterns. Inspiration for Go by Google!

\section{Other windowing systems}
\label{sec:other-windowing-systems}

Here are a few windowing systems that I considered for this book,
but which I ultimately discarded:
\begin{itemize}

%history:
\item Xorg\furl{http://xorg.freedesktop.org}, which I mentioned already
in the \book{Graphics}, 
%dup: Graphics.nw
is the most popular open-source implementation of 
the X~Window System~\cite{x-window},
a windowing system (and a graphics system) designed in the 1980's at MIT.
%
However, its codebase is enormous. In fact, the whole system is divided
in hundreds of repositories\furl{https://cgit.freedesktop.org/xorg}
to better handle its complexity. One of this repository,
[[xserver]]\furl{https://cgit.freedesktop.org/xorg/xserver/},
which contains the code of the {display server},
\l and window {compositor}, but then need define compositor here?
has already more than 500~000 LOC. 
\n KDrive (Xkdrive and Xfbdev) are small actually; but still need libX11/...
This does not even include the code of the
{window manager} (e.g., [[twm]] with 17~000 LOC),
\n can have many window managers under X11; policy-free server.
the {terminal emulator} (e.g., [[xterm]] with 80~000 LOC),
\n rxvt is 37 000 LOC so similar (said later)
or the libraries required by clients
to communicate with the display server (e.g., [[Xlib]] with 150~000 LOC).
Xorg, in total, contains more than two orders of magnitude more code 
than [[rio]].


Part of the reason for the enormous size of Xorg is that
Xorg supports many graphic cards,
\l (with hardware acceleration),
many monitors, many input devices, and many extensions (e.g., 3D operations).
\n XRender, XRandR, Shape, etc also many optimisations.
%
Another reason is that X~Window is an old program;
programmers extended X~Window for more than 30 years now.
Programmers added many extensions while still being forced to remain
backward compatible with applications designed in the 1980's. 

%dup: Graphics.nw
X~Window defines a {communication protocol}, X11, for a 
networked client/server architecture.
Client applications must use {\em sockets} to connect to the display server.
%
Unfortunately, the set of mechanisms used by clients to interact
with the screen, mouse, or keyboard is quite different from
the one offered by the kernel, for instance, the simple opening of 
files in [[/dev/]] such as  [[/dev/mouse]]. 
In some sense, X~Window {\em masks} the features of the underlying kernel.
%
On the opposite, [[rio]]
is {\em transparent}~\cite{window-system-should-be-transparent}
and instead {generalizes} the services offered by the kernel, for instance,
with the virtual device file [[/dev/mouse]].
\n not super clear for now (but better explained later)
%
Of course, the use of sockets in X~Window allows client applications
to display their result on another machine on the network.
However, this is also possible with [[rio]], for free, thanks to the generic
9P protocol.
\t cite 9P?
\l still a /dev/cons, /dev/draw, /dev/mouse
\l x86 specific? X on Raspberry Pi? 
\n Raspberry Pi seems to finance wayland  and also bare metal Squeak.

%dup: Graphics.nw, intro/motiv intro/rio
Finally, the graphics and windowing system parts of Xorg are strongly coupled;
%
this coupling makes the whole system harder to understand than [[rio]]
and [[draw]], which we can study separately.


\item Wayland\furl{https://wayland.freedesktop.org/} is a protocol, 
similar to X11,
specifying the communication between a display server, called
a Wayland {\em compositor}, and a set of {local} clients.
Weston\furl{https://cgit.freedesktop.org/wayland/weston/}
is a reference implementation of a Wayland compositor.
%
Wayland and Weston grew out of the frustation of some
developers of Xorg with the complexity of X~Window, as well as
the difficulty for X~Window to support the modern needs of a windowing
system: 
transluscent windows, 
drop shadows on the window's border as in macOS Aqua,
fancy window-switcher such as macOS Expose, etc.

Fortunately, during the last ten years, lots of the code of
Xorg got gradually moved out of the display server and
put either in the Linux kernel (e.g., the resolution setting
of the screen, called KMS for kernel mode setting, or the ability
to interact directly with the graphics hardware, called DRM
for direct rendering manager),
or in external libraries (e.g., 
Cairo for an advanced drawing API, 
or [[libinput]] for a generic interface to the input devices).
%
What remains in Xorg is an old drawing API, the ability
to have remote applications, and a display server that is backward
compatible with old applications.
\l Useless intermediate. 
%
The developers of Wayland used this opportunity to redesign
from scratch a modern windowing system, while reusing lots of the
code that was now outside Xorg.

There are many differences between Wayland and X11.
For instance, Wayland does not specify any drawing API. Instead,
it assumes the clients do their own graphics rendering by using
libraries such as Cairo on locally-shared image buffers.
Weston then just uses those shared buffers
and composes them together (hence the use of the word {``compositor''}),
while possibly applying effects during the image composition
such as transluscence.
%
The use of locally-shared buffers means that 
Wayland does not support remote applications. Fortunately, most users now
run and display their applications on the same machine.
\l footnote? well except for the Web, so maybe remote app is important
\l  and done with lots of complexity, so maybe better to go back to rio model!
\l not network transparent. No remote cos no drawing API (but can do VNC-like)
\n need rewrite X11 apps? not if they're using GTK/QT. Already compatible!
\n still need xterm? actually has one (LOC?)

The code of Wayland and Weston is far smaller than Xorg:
120~000 LOC (not including the tests).
However, this is still one order of magnitude more code than [[rio]].
%
Moreover, Weston relies on many libraries (e.g., Cairo, [[libinput]]),
as well as lots of code and subsystems of the Linux graphics stack
(e.g., KMS, DRM, GEM, fbdev, evdev);
this would add lots of code to explain.
\l  a pile of layers with the kernel, soft archi diagrams looks complicated
%https://drewdevault.com/2017/06/10/Introduction-to-Wayland.html

\item Nano-X\furl{http://www.microwindows.org/}
(previously known as MicroWindows) is a windowing system and graphics system
designed originally for small devices such as PDAs.
\n started in 1999. No news since 2011 though in the repository. Still run?
\n was mentioned by tinyGL, and also by picoGUI.
%
It started as a fork of Mini-X, a graphics system for MINIX.
Both Mini-X and Nano-X are modeled after X~Window, and offer
an API similar to Xlib.
\n Nano-X has also an API similar to the one in Microsoft Windows
Nano-X added a client/server architecture to Mini-X, as well
as a window manager, to become a full windowing system.

Nano-X is highly portable, with support for many machines 
(e.g., x86 desktops, MIPS machines, ARM embedded devices).
Moreover, Nano-X does not require any external graphics library; 
it just requires an access to the framebuffer from the Linux kernel.
It is far smaller than Xorg: 80~000 LOC (not including the tests,
application demos, the Win32 API, and the fonts).
%
However, this is still bigger than the code of [[draw]] and [[rio]]
combined.
\n which moreover can be studied separately (but said elsewhere)

\end{itemize}

\begin{figure}[]\centering
\includegraphics[height=0.45\textheight]{lineage}
\caption{Windowing systems timeline}
\label{fig:lineage}
\end{figure}

%dup: Shell.nw
Figure~\ref{fig:lineage} presents a timeline of major windowing systems.
%
I think [[rio]] represents the best compromise for this book: 
\l for \principia
it implements the essential features of a windowing system
%dup: intro/rio
while still having a small and understandable codebase (10~000 LOC).

\l lots of other windowing systems, see the comment in the .nw
%industry:
% - Windows DWM
% - macOS Quartz compositor (innovative: Expose, window closing effects, etc)
% - Android SurfaceFlinger (but no real windows on the screen)
% - Qnx photons, 1.44MB demo disk! even with web browser!
%history:
% - Alto, started in 1973, had overlapping windows, mouse, fonts, etc
% - Smalltalk?
% - Blit (mux -> rio/draw), 1982
% - NeWS, Network/Extensible Window system =~ X + Display Postscript, 1989
%   https://books.google.com/books?id=DdbvBwAAQBAJ
%other:
% - MIR, very similar to Wayland; used only by Canonical.
%   but seems now abandonned
% - nuttx has some graphic and windowing stack apparently too!
%   http://nuttx.org/doku.php?id=documentation:nxgraphics
% - HelenOS Gui? https://www.youtube.com/watch?v=ZjqYRv2xOSw&feature=youtu.be
%   code?
% - pico GUI? \furl{http://picogui.org/} seems similar to Nano-X.
%   no news since 2003 on website and repository
%   mentions microwindows on history document, saying he should have use it
% - Kolibri/MenuetOS, also floppy disk with full GUI, but all in assembly
% - berlin? dead?
% - http://ignorethecode.net/blog/2009/04/22/oberon/
% - redox in rust has a windowing system apparently, Orbital?
% - arcan/durden https://arcan-fe.com/ mix of game engine, display server
%   and streaming multimedia engine, inspired by plan9 too:
%   https://arcan-fe.com/2017/04/17/one-night-in-rio-vacation-photos-from-plan9/
%semi windowing systems (single client with multiple windows; no clients/server)
% - Mini-X (see Graphics.nw)
% - TWIN   (see Graphics.nw)
%text-based windowing systems or libraries:
% - newt?
% - stuff used by Turbo Pascal? had dialog boxes!
% - twin (another one)
%mini:
% - mgr http://www.hack.org/mc/mgr/, but very old, and restrictive license
% - Xynth and Xfast
% - Xorg contains also a few mini server to prototype thinhs (written by 
%   Keith packard again)
%window managers: (still rely on X11)
% - xmonad
% - efuns/gwml
% - tinyWM, 50 LOC http://incise.org/tinywm.html
% - another claimed to be minimal WM http://www.cc.rim.or.jp/~hok/heliwm/
%research:
% - 10/gui http://ignorethecode.net/blog/2009/10/13/10_gui/
% - xmonad in Coq, hmmm
%   http://www.staff.science.uu.nl/~swier004/Publications/XmonadInCoq.pdf
% - 3D windowing systems? Looking glasses of Sun?

% nice list of X wannabe killers:
% http://linuxfinances.info/info/xbloat.html

%nice set of screenshots of past famous GUIs:
% http://toastytech.com/guis/
% http://toastytech.com/guis/guitimeline.html

% history me: 
%  - tos, sega yeno, atari GEM, dos, windows 3.11
%  - one Linux terminal
%  - job control shell! (otherwise multi tasking OS but just one term so ...)
%  - multi terminal Alt-Fx on Linux
%  - screen or tux programs (actually I never used but many people do)
%  - X11 and xterm with as many windows as you want!
%  - FVWM fast key to many terminals
%  - Emacs eshell fast key to many terminals
%  - virtual desktops
%  - macOS expose! bird's eye view (great feature)

%maybe not great, but rare example of blogs on how to make a windowing system:
% http://www.trackze.ro/windowing-systems-learning-by-example-introduction/
% http://www.trackze.ro/wsbe-9-coup-de-grace/

% concurrent programming in ML contain the description of a windowing system

% contenders to X windows:
% https://bbs.archlinux.org/viewtopic.php?id=87281

\section{Getting started}
\label{sec:getting-started}

%dup: (and adapted) Assembler.mw
To play with [[rio]], you will first need to install
the \plan fork used in \principia (see \urlinstall).
Once installed, you can test [[rio]] under \plan
by executing the following commands:

\begin{verbatim}
1   $ bind -a '#v' /dev
2   $ vga -l 640x480x8 
# screen should change layout
3   $ bind -a '#i' /dev

4   $ rio
\end{verbatim}
% x86 for vga part
\t need also /mnt/temp for pipes, and other stuff (use ramfs for now, ugly)

Then, if you right-click with the mouse somewhere on the screen,
you should see graphics similar to the one in Figure~\ref{fig:rio-start}.
\n need mouse with 3 buttons (said later)

\begin{figure}\begin{center}
\includegraphics[width=8cm]{pics/rio-start}
\end{center}
\caption{The screen, just after [[rio]] started and the user right-clicked.}
\label{fig:rio-start}
\end{figure}
\n terminal window? not yet! minimal spirit for now!
\t explain QEMU? or even simpler, remove it! via gimp scriptfu?


Line~1 through 3, above, install the graphics system of \plan ([[draw]])
and configure it to run at the [[640x480x8]] resolution 
(See the \book{Graphics} for more information on [[draw]]).
%
Line~4 then executes [[rio]], which should take over
the screen to create the graphics shown in Figure~\ref{fig:rio-start}.


\section{Requirements}

%dup: from Assembler.nw
Because most of this book is made of C source code, 
you will need a good knowledge of 
the C programming language~\cite{k-r} to understand it.
%
Moreover, because [[rio]] relies on many advanced features
of the \plan kernel, and builds upon the \plan graphics system [[draw]],
I strongly suggest you to read the \book{Kernel} and \book{Graphics}
before reading this book.
%
Note that [[rio]] is implemented as a filesystem in user space, 
and uses the protocol 9P to communicate with the kernel. 
Thus, it can also be useful to read the \book{Network}, which describes 9P.
\t actually now in Libcore
In the same way, I also suggest you to read the \book{Libcore},
which explains the thread library, which is heavily used by [[rio]].

\begin{table*}[tbh!]
\begin{center}
\begin{tabular}{lp{7cm}p{4cm}lp{33mm}}
\toprule
{\bf Book} & {\bf Concepts} & {\bf Device Files} & {\bf Codes} & {\bf Headers} \\
\otoprule
\nobook{Graphics} & 
display server, drawing API, shared image, overlapping layers & 
[[/dev/draw]] [[/dev/winname]] [[/dev/vgactl]] & [[#i]] [[#v]] &
[[draw.h]] [[window.h]] [[mouse.h]] [[keyboard.h]] \\

\nobook{Kernel} &
filesystem, device, pipe, console, per-process namespace, union-mount, shared memory &
% system call
[[/dev/cons]] [[/dev/consctl]] [[/dev/mouse]] [[/dev/pipes/]] & [[#c]] [[#m]] [[#|]] &
[[syscall.h]] \\

\nobook{Libcore} &
channel, proc, thread, message, message queue &
% system call
& &
[[libc.h]] [[thread.h]] \\

\nobook{Network} &
remote procedure call (RPC), filesystem in user space, 9P protocol &
[[/srv]] & [[#s]] &
[[fcall.h]] \\


\bottomrule
\end{tabular}
\end{center}
\caption{\principia books related to the \nobook{Windows}.}
\label{tab:principia-books}
\end{table*}
\l also API (mount, bind, alt, read9pmsg, fcallfmt, sendp, threadcreate, proc)? 
\l data structures?

Table~\ref{tab:principia-books} presents
the list of related \principia books,
as well as the concepts, devices, and header files used by [[rio]]
and introduced by those books.
%
The most important book in Table~\ref{tab:principia-books} 
is the \nobook{Graphics}.
%
Regarding the three other books, you can probably understand most of the code
in the following chapters without reading those books if you read at least
{\em Plan 9 from Bell Labs}~\cite{plan9},
as well as {\em The Use of Name Spaces in Plan 9}~\cite{namespaces-plan9};
those two articles introduce many of the concepts listed 
in Table~\ref{tab:principia-books}.


As I said in Section~\ref{sec:motivations},
there are very few books explaining
the concepts, theories, and algorithms used in windowing systems.
%dup: (and extended) intro/motivations
I can cite {\em The NeWS book}~\cite{news-book},
{\em Methodology of Window Management}~\cite{methodology-window-management},
and one chapter of 
{\em Computer Graphics, Principles and Practice}~\cite{cgpp-foley}.
\l Introduction to window management, Steinhart, 320p SIGGRAPH 1990 course note
\l  (but cant find it)
\l Oberon? 
\l X~Window series of OReilly is more on the protocol and API
\l http://keithp.com/~keithp/talks/Xarchitecture/Talk.htm
\l nothing since 1990?
Those books are useful, but they are not mandatory to understand this book.

%dup: (and changed a lot) from Graphics.nw
If, while reading this book,
you have specific questions on the interfaces of [[rio]],
or on the API used by [[rio]], you can find answers in certain manual pages.
%
Those pages are located under [[docs/man/]] in my \plan repository.
Here is a list of pages relevant to [[rio]] and a short description
of their content:

\begin{itemize}

\item [[1/rio]]: the command-line and graphical user interface of [[rio]]

\item [[4/rio]]: the filesystem interface of [[rio]]

\item [[2/draw]]: the [[draw.h]] API
\t a few changes though, like screen -> view.
%\item [[2/graphics]]: the big picture (no pun intented)

\item [[2/window]]: the [[window.h]] API
\n so I was right to create this file! there was a different man page!

\item [[2/keyboard]]: the [[keyboard.h]] API
%\item [[3/cons]]: the [[/dev/cons]] interface

\item [[2/mouse]]: the [[mouse.h]] API
%\item [[3/mouse]]: the [[/dev/mouse]] interface

\item [[2/thread]]: the thread and channel library 
%\item [[2/event]]: event API, an alternative to threads and channels

\item [[5/0intro]]: the 9P protocol
\l and man/5/* 

\end{itemize}

Finally, the [[windows/docs/]] directory in my \plan repository
contains documents describing either [[rio]]~\cite{rio-slides}
or ancestors of [[rio]]~\cite{eight-and-a-half, concurrent-window-system,
window-system-should-be-transparent, blit}.
%dup: Graphics.nw
All those documents are useful to understand some of the 
design decisions presented in this book.
\l also to learn about GUI, namespaces, some implementation details.

\section{About this document}
\input{../docs/latex/About}

\section{Copyright}
\input{../docs/latex/CopyrightPlan9Text}

\section{Acknowledgments}

I would like to acknowledge of course the author of
[[rio]], Rob Pike, 
who wrote in some sense most of this book.






%******************************************************************************
\chapter{Overview}
%******************************************************************************

%trans: %dup: Assembler.nw
Before showing the source code of [[rio]] in the following chapters,
%toc: Assembler.nw
I first give in this chapter an overview 
of the general principles of a windowing system.
%
I also describe quickly the graphical user interface of [[rio]],
as well as its filesystem interface in [[/mnt/wsys/]].
%
I also show the code of a toy application running under [[rio]].
% and using functions from [[draw.h]] and [[mouse.h]].
\n graphical application vs window application (said later)
\l Different model! Interactive! Reactive!
\l using threads, so good first step for code of rio
%dup: Assembler.nw
Finally, I define terms, explain how the code is organized, 
and more generally give the background necessary
to understand the code I will show later.

\section{Windowing system principles}
\label{sec:principles}

A {\em windowing system} is a program (or a set of programs)
with a {graphical user interface} (GUI) allowing the user to
create and manipulate {windows}.
\l def of GUI? program with graphics and interactive with mouse?
A {\em window} is a usually rectangular and resizeable
{surface} of the screen containing the GUI of another program.
%
Just like the kernel is a {\em meta-program}, that is 
a program allowing the user to run other programs, 
the windowing system is a {\em meta-GUI}, that is
a graphical user interface allowing the user to run other
graphical user interfaces.
%without: ??? mess, need coordinator intermediate, like for kernel
% to virtualize and have independent stuff

In addition to windows, a windowing system traditionally uses 
{\em icons}, 
{\em menus}, and a
{\em pointer}, or {\em WIMP} for short.
\n actually rio just WMP (said below)
Note that windowing systems are not the only kind of meta-GUIs.
For example, the user interface of phones running under iOS or
Android do not have any windows. Moreover, the user can use
multiple pointers at the same time through his multiple fingers.
\n has unresizable tabs instead of windows.
%
Those interfaces are called {\em post-WIMP} interfaces.

%\subsection{Desktop system}
%\subsection{Desktop shell}
A {\em desktop system} is a kind of windowing system
promoting the following metaphor: 
{a windowing system is like a physical desk in an office}.
%
A desktop system usually includes applications
and icons mimicking the real-life objects of an office:
a garbage can, 
folders, 
a clock,
a rolodex,
an alarm,
a calendar,
etc.
%
The window is then like a paper on a desk; it can be moved
around, or stacked on top of other papers. Each window represents
a separate activity.

The Xerox Star~\cite{xerox-star} was the first desktop system.
%real-world:
Desktop systems are the most popular windowing systems
(e.g., Microsoft Windows, macOS),
because they offer a familiar interface to the user.
%
On Linux, the desktop systems 
KDE\furl{https://www.kde.org/} and 
GNOME\furl{https://www.gnome.org/}
are implemented as a set of applications
\l and a special window manager
on top of X~Window.
%in-plan9:
\plan does not have a desktop system; [[rio]] does not
use any icon and does not promote an office metaphor. [[rio]] is
not a WIMP, just a WMP.
\l why? simpler, minimalst, non-essential anyway.



\begin{figure}[!]\centering
\begin{verbatim}
+-------------+ +-------------+ +-----------+
|   Window    | |   Window    | |  Textual  |
|application 1| |application 2| |application|
+------+--^---+ +-+---^-------+ +----^------+
       |  |       |   |              |
+------+--+-------+---+--------------+------+
|      |  |       |   |          +---v----+ |
|      |  +-------+---+----+----->Terminal| |
|   +--v----------v+       |     |emulator| |
|   |    Window    <-------+-----+        | |
|   |  compositor  |       |     +--------+ |
|   +--------------+     +-+------------+   |
|   |   Display    |     |    Window    |   |
|   |    server    <-----+   manager    |   |
|   +----+---------+     +----^-----^---+   |
|        |    Windowing system|     |       |
+--------+--------------------+-----+-------+
+--------v--------------------+-----+-------+
|        |         Kernel     |     |       |
+--------+--------------------^-----^-------+
+--------v---+          +-----+-+ +-+-------+
|  Display   |          | Mouse | |Keyboard |
|   device   |          |device | | device  |
+------------+          +-------+ +---------+
\end{verbatim}
\caption{Components of a windowing system.}
\label{fig:window-system-components}
\end{figure}
\l could also put libs, at the top, like Xlib, provides nice connection API
\n could have input manager
\l desktop system then is bigger; just windowing systems with special programs


A windowing system has many {components}, which sometimes
can even be separate programs. 
\n hence  'set of programs' above
I mentioned them already in Section~\ref{sec:other-windowing-systems}:
the {display server}, the {window compositor}, the {window manager}, and
the {terminal emulator}.
%
Figure~\ref{fig:window-system-components} 
presents the relationships between those components.
%trans:
Figure~\ref{fig:window-system-components} shows also four important
{layers}: the hardware at the very bottom, the kernel and windowing system 
in the middle, and the applications at the top.
\l layer confusing with draw layer?
%
Moreover, in this book, I divide applications in three different categories:

\begin{itemize}

\item {\em Textual applications}: those are command-line
programs, which just read and output text (e.g., [[grep]]).

\item {\em Graphical applications}: those are programs
drawing on the whole screen and using the mouse (e.g., the Doom video game)

\item {\em Window applications}: those are programs
drawing and using the mouse inside a window
(e.g., the Microsoft minesweeper video game)
\l and possibly use multiple windows

\end{itemize}
\n also Web application

A windowing system is mostly concerned with the last category,
but it usually offers a way to run in a special environment
the other kinds of applications. For instance, the terminal emulator
in Figure~\ref{fig:window-system-components} allows to run
textual applications.

%toc:
The following sections will explain the relations between
the different components in Figure~\ref{fig:window-system-components}
as well as the role of each of those components. I will also
quickly describe how those components are implemented in X~Window and [[rio]].
\l different soft archi possible.
But before, I need to better characterize what is a window.


\l imagine how would you code a windowing system? not that easy.
\l multiplexer!

\subsection{The window}

A window is multiple things at the same time.
First, it is a {delimited surface} of the screen
containing the visual {\em output} of a running program\footnote{
The term ``window'' is actually a misnomer~\cite{pike-layers}. 
In graphics terminology, such an output is called instead the
{\em viewport}.}.
\l but in {pike-window-transparent} he says that "apt word because in
\l  a transparent windowing system, it is through windows that you see
\l  the operating systems and its programs"
\n he cites NewMan-Sproull-79; a window is actually the whole virtual world.
\l it is a {dynamic picture} representing a separate activity.
\n Magic Ink! Bret Victor.
%
It is also an {interactive region} of the screen responding to {\em input}
from the mouse; when the mouse hovers {inside} a window, 
the underlying program can {react}.
\l ``rectangular area which maintains input/output  context for a 
\l  particular program or graphics application.''
%
Finally, it is a {container} that can be manipulated
from the {outside}; a window can be moved, resized, closed, etc.
\n by window manager, via decoration/border (said later)
\l Like OS/shell; a Graphical shell!


A window surface is made of multiple elements,
as shown in Figure~\ref{fig:window-elements}.
Here is the list of those elements as well as their functions:


\begin{itemize}

\item {\em Window content}: contains the GUI of the underlying running program


\item {\em Window border}: allows the user to move or resize the window
\n generated by window manager (said later)
\l also clear boundary with other windows/programs (drop shadows at least)

\item {\em Title bar}: contains usually the name of the program
\l can be changed by program itself, /dev/label

\item {\em Windowing system icons}: allows the user to close, expand, or hide
the window

\end{itemize}

\begin{figure}[!]\centering
\begin{verbatim}
+------------------------------------+
|+--------------------+----icons----+|
||                    |     +--+ \ /||
||       Title Bar    |     |  |  X ||
||                    | --- +--+ / \||
|+--------------------+-------------+|
||                                  ||
||                                  ||
||                                  ||
||          Window Content          ||
||                                  ||
||                                  ||
||                                  ||
||                                  ||
|+----------------------------------+|
+-----------Window border------------+
\end{verbatim}
\caption{Window elements.}
\label{fig:window-elements}
\end{figure}


Only the first element is mandatory; the other elements,
forming the {\em window decoration}, are all optionals.
\n done by window manager (said later)
%in-plan9: %dup: overview/principle (for icon part)
For instance, in [[rio]], windows have a border but they have
neither a title bar nor icons 
(see Figure~\ref{fig:rio-gui}). % in Section~\ref{sec:rio-gui}
\n sometimes even no border; everything done via keyboard


%in-plan9:
In [[rio]], as well as in many other windowing systems,
windows can {overlap} each other. Thus, 
windows can be {\em stacked} {on top of each other}, 
hiding the pixels of the windows below.
\n how to restore those pixels (explained later)
%
In other windowing systems, windows instead are {\em tiled} automatically
{next to each other} (or hidden completely).
%real-world:
Finally, in recent windowing systems, windows can be
{\em composited} {with each other}; 
%dup: intro/other-systems
the windowing system composes the images representing the different windows
together and can apply special effects, for instance,
transluscence or drop shadows as in macOS\footnote{Another 
nice effect is to zoom out and tile automatically
all the images of the windows, as in macOS Expose,
to get a bird's eye view of all the windows.}.
\n even dynamic!
\l thus combining some advantages of tiling and stacking
\l in the end tiling, overlapped, composited


\subsection{Display server}
\label{sec:display-server}
\l and communication protocol

%trans: now that window clearer, I switch back to Figure X and its components.

%trans:
The first component of a windowing system is the display server.
%dup: (a bit changed) Graphics.nw
A {\em display server} is a {graphics system} that accepts {drawing commands}
from multiple {\em clients} via a {\em communication protocol},
and then translates those commands into instructions to the graphics card.
%http://tech.slashdot.org/story/14/06/19/1317227/x-window-system-turns-30-years-old?utm_source=slashdot&utm_medium=facebook
%"A server lets clients access a shared resource. On a file server, it's
%storage. On a web server, it's documents. On a compute server, it's
%processing. On an X server, the shared resource is the display, and
%clients are given access to it."
%
The display server is responsible for all the visual {output}
of all the applications, as well as the
visual output of the windowing system itself (e.g., the window decorations, 
the background image).
\n the system menu, the cursor
%
This is why in Figure~\ref{fig:window-system-components}, 
the applications, window manager, and terminal
emulator are all connected to the display server 
(through the window compositor, which I will explain in
Section~\ref{sec:compositor}).
%dup: Graphics.nw (overview/principles/display-server)
A display server uses a client/server architecture because
it needs to serve many clients: 
the multiple processes corresponding to the multiple windows on the screen.
\n and rio itself when display server is outside windowing system

\t Can have graphics system without client/server archi, direct, but
\l if want universal windowing system, then need multiple clients in
\l independent processes, and so need server. mini-X is not universal. draw is!

\t Some graphics system allow to create windows, e.g., draw,
\l but if does not have window manager, app must implement one. 


%real-world: %dup: (changed, not-coupled) intro/motiv intro/rio intro/other
In X~Window (as well as in most windowing systems),
the display server is an integral part of the windowing system.
%
Moreover, the communication protocol of X~Window, X11, 
is used not only to carry drawing
commands from the clients, but also to relay input {events} from the devices
to the clients.
%
In that case, the display server acts also as a {\em window server}
as it manages all the communications with the windows.
\l input and output
\n display server vs window server vs compositor

%in-plan9:
In \plan, the display server [[draw]] is outside [[rio]], in the kernel,
and serves only the drawing commands from the clients.
The communication protocol of [[draw]] is described in the
\book{Graphics} (and involves the [[/dev/draw/x/data]] files).
\l in rio just output; for input use traditional (virtual) devices.
%dup: (and adapted) Graphics.nw   intro/motiv intro/rio intro/...
%In \plan, you can run graphical applications with or without
%the windowing system; the graphics system and windowing system
%are clearly separated.
\l (Alto was mixing? Smalltalk was? Blit was?)
\l rio itself use comm protocol with draw to display things!

\l clients/server archi. (=> threads?)


\subsection{Window compositor}
\label{sec:compositor}

A {\em window compositor} is an optional component of a windowing system 
%real-world: 
(found in modern windowing systems)
allowing windows to be {\em composited} with each other.
%dup: (and adapted) intro/other-systems overview/principle/window
Each window application draws first in an {\em off-screen image}.
Then, the compositor composes all those images together while
applying possibly advanced effects such as transluscence or drop shadows. 
\n 3d effects, scaling (Expose)
\l Policy on how to compose?
Finally, the composition is sent to the display server,
which outputs the result on the screen.
%
This is why in Figure~\ref{fig:window-system-components}, 
the window applications are all connected first to the compositor.
%
The compositor and display server are usually tightly coupled,
hence the direct contact between the two respective boxes in 
Figure~\ref{fig:window-system-components}.

%real-world: X window? not really, this is why Wayland?
% macOS first one? and then with Expose got tiling, stacking, compositing!
\n tiling, stacking, or compositing (said before)

%in-plan9:
In [[rio]], which favors a minimalist approach, there is no compositor;
each window application is connected directly to the 
display server ([[draw]]).
That means [[rio]] does not offer special effects such as transluscence, but
it would not be difficult to extend [[rio]] to include a compositor
to support those effects.
\l just change /dev/winname to off-screen image


\subsection{Window manager}
\label{sec:window-manager}

The {\em window manager} is the component
responsible for all the user {inputs} to the windowing system:
inputs from the mouse, the keyboard, or other devices.
\l also window decoration, placement
%
Those inputs can lead to the 
moving, 
resizing, 
opening, 
closing, or 
hiding
of windows, hence the term ``window manager''.
%
Indeed, the action of the mouse over the window decorations can trigger
the changes to the windows listed above.
%
In fact, the window manager is also responsible for
the display of those window decorations.
%
This is why in Figure~\ref{fig:window-system-components}, 
the window manager is connected to the display server,


When the mouse is over the {window content}, the role of the
window manager is then to {relay} the input events to the
application.
%
This is why in Figure~\ref{fig:window-system-components}, 
the mouse and keyboard devices are connected to
the window manager, which is connected itself to
all the window applications (and the terminal emulator)
in order to {\em dispatch} the input to the appropriate window.


%real-world:
In X~Window, the window manager is a separate program.
There are more than 50 different window managers available for X~Window,
each with different window decorations, different {input policies},
different {menus}, etc.
The window manager communicates also with the display server, like other
clients. However, the window manager is assigned a special role 
by the display server.
\l under X11 this is actually delegated to another program
%alt: rebind parent window and root window concept. Hints for positions.

%alt: 
In Weston and Wayland, the display server, compositor, and window manager
are all parts of the same program.
\l but poor display server; just bitmaps transfer; drawing is done by cairo
%  https://wayland.freedesktop.org/faq.html#heading_toc_j_11
% "The Wayland architecture integrates the display server, window manager
%  and compositor into one process"

%in-plan9:
With [[rio]], there is only one window manager, which is an
integral part of the windowing system.
There is only one style of window decoration, kept to a minimum:
%dup: overview/principle overview/principle/window
no title bar, no icon, just a thin blue window border
(see Figure~\ref{fig:rio-gui}). % in Section~\ref{sec:rio-gui}.
\n in rio no icon, so way to start new process is tricky (said later)

%\subsection{Process manager}

% it's a kinda of scheduler, a bit like kernel. Need manage
% set of processes/activities. Need to keep track of them.

%\subsection{Graphical shell}

% can launch new processes
% could be separate program than wm, e.g., the Dock under macOS.


\subsection{Terminal emulator}
\label{sec:terminal-emulator}

%trans: 
The last component of a windowing system is the terminal emulator.
%
A {\em terminal emulator} provides a backward-compatible
environment for command-line applications to run inside
a window, without having to rewrite and recompile those applications.
%
The emulator has also usually some basic line-editing capabilities
such as handling the backspace key or copy-pasting.
\l factorize stuff 
\l actually old terminal have special capacity in kernel too, echoing


The terminal emulator is an optional component of the windowing system
that most users never use, but that most programmers can not live without.
%
Indeed, thanks to the emulator, the programmer can run
all his classic tools (e.g., shells, compilers, linkers, [[grep]])
under the windowing system, and even run multiple tools
at the same time in different windows.
%
An alternative is to use an integrated development environment (IDE),
but IDEs rarely integrate all the tools used by a programmer.

% GUI introduce a new model, new devices, new way to interact, new APIs.
% but what about old command line application? How run?
% could recompile, but why put complexity in it? instead emulator.


%in-unix: %dup? Kernel.nw? Shell.nw?
The environment needed by a command-line application under \unix
or \plan is minimal:
three opened files, in the first three {file descriptors} of the process,
corresponding to the 
{\em standard input},
{\em standard output}, and 
{\em standard error}.
%real-world: %in-plan9:
Those file descriptors correspond usually to the
{teletype device} ([[/dev/tty]]) under \unix, or one
of the {virtual console} under Linux ([[/dev/tty1]], [[/dev/tty2]], etc.),
or finally the {console device} under \plan ([[/dev/cons]]).
%
Those file descriptors can also correspond to regular files when 
the user uses {redirections} in the shell (e.g., [[ls > list.txt]]).
\l   via fork, adjust, exec trick


Under a windowing system, those input/output descriptors must be connected
to the emulator.
\l no teletype device
\l also fork/adjust/exec input/output connected to emulator
%
This is why in Figure~\ref{fig:window-system-components},
the terminal emulator is connected in both directions
to the textual application;
%
the terminal emulator
relays from the window manager the keyboard input to the application, and 
relays from the application the output text to the display server 
(by drawing this text with a special font in the window).



%real-world: 
In X~Window, terminal emulators (e.g., [[xterm]], [[rxvt]]) 
are separate programs.
\n iterm, iterm2, gnome-terminal, Konsole, etc
The standard input and output of command-line applications
running under those terminals are connected to a
{\em pseudo-tty} (PTY), which is a pair of {\em pseudo-devices}
(the master and the slave) managed by the kernel.
Those pseudo-devices and connected themselves to the terminal program 
in user space, as well as to the command-line application.
% http://rachid.koucha.free.fr/tech_corner/pty_pdip.html
%
I must admit I do not fully understand how it works. % lol :)
\l See X? In Wayland simpler?
%
The code of [[xterm]] is very complex with more than 80~000 LOC
%dup: Principia.nw
(eight times more code than the code of [[rio]], which is the whole
windowing system).
[[rxvt]] is smaller, but still has 37~000 LOC.


%in-plan9: beautiful! transparent!
With [[rio]], the terminal emulator is an integral part of the windowing
system and accounts for only 2600 LOC (including the
code to support scrollbars, filename completion, copy-pasting, etc).
\n terminal.c, libframe, libcomplete, libplumb
This is mainly because the pseudo-tty is replaced by a more
general approach: {\em virtual devices} and {\em filesystems in user space}.
%
Indeed, under  [[rio]], a command-line application still
opens the {console device} by opening in read and write {modes}
[[/dev/cons]]. However, this file, thanks to the per-process namespace
feature of \plan, is not the device file managed by the kernel but
a virtual device managed by [[rio]]; 
every file request on [[/dev/cons]] is redirected to a 9P request to [[rio]]
(which itself uses the ``real'' [[/dev/cons]] managed by the kernel).
\l See X for more information?



\subsection{Windowing system API}
\label{sec:windowing-system-api}

%trans: 
I just described the {\em internal} structure of a windowing system,
as well as the environment needed by command-line applications
when running under a terminal emulator.
%
But, what about the {\em external} interface of a windowing system,
as well as the needs of a window application?
% running under this windowing system?
%
What API should a windowing system offer to its clients?
\l the top edges in Figure~\ref{fig:window-system-components}


Obviously, a window application
% running under a windowing system
wants to access the screen, the mouse, and optionaly the keyboard.
%in-plan9: %dup: (but clearer) intro/rio
Note that there is already an API to access those devices under \plan.
Indeed, 
%to access 
%the screen, 
%the mouse, and 
%the keyboard 
a \plan graphical application (e.g., Doom) can simply read or write in 
%respectively 
the 
[[/dev/draw]], 
[[/dev/mouse]], and
[[/dev/cons]]
{devices files}, which are managed by the \plan kernel 
(see the \book{Graphics} and \book{Kernel}).
%
The top of Figure~\ref{fig:rio-multiplexer} illustrates one such
graphical application called [[App 1]].
%
This program can also use functions from the 
[[draw.h]], 
[[mouse.h]], and 
[[keyboard.h]] 
header files instead of using directly the device files, 
but those functions are just thin wrappers that ultimately read and write
in the corresponding device files.


\begin{figure}[!]\centering
\begin{verbatim}
                                       +---+
                  +------+ /dev/draw   |   |
                  |      +------------->   |
                  |      | /dev/mouse  |   | +--------+
                  |App 1 <-------------+   | |Display |
                  |      | /dev/cons   |   | | device |
                  |      <-------------+   | +--------+
                  +------+             |   |
+------+ /dev/draw   +---+             | K |
|      +-------------> w |             | e | +--------+
|      | /dev/mouse  | i |             | r | | Mouse  |
|App 2 <-------------+ n |             | n | | device |
|      | /dev/cons   | d |             | e | +--------+
|      <-------------+ o | /dev/draw   | l |
+------+             | w +------------->   |
                     |   | /dev/mouse  |   |
+------+ /dev/draw   | s <-------------+   | +--------+
|      +-------------> y | /dev/cons   |   | |Keyboard|
|      | /dev/mouse  | s <-------------+   | | device |
|App 3 <-------------+ t |             |   | +--------+
|      | /dev/cons   | e |             |   |
|      <-------------+ m |             |   |
+------+             +---+             +---+
\end{verbatim}
\caption{Windowing system as a multiplexer.}
\label{fig:rio-multiplexer}
\end{figure}
\n actually a bit different for /dev/draw, but simpler to cheat for now

%in-plan9:
Thus, under \plan,
one way to define the external interface of a windowing system
is to just mimic the interface defined by the kernel,
as shown at the bottom of Figure~\ref{fig:rio-multiplexer}.
%in-plan9: %dup: (but clearer) intro/rio
As mentioned in Section~\ref{sec:rio}, [[rio]] is
implemented as a {\em multiplexer}; 
it accesses the {physical devices} (managed by the kernel) 
at the bottom right of Figure~\ref{fig:rio-multiplexer},
and provides {virtual devices} to its clients ([[App 2]] and [[App 3]])
with similar interfaces at the bottom left of 
Figure~\ref{fig:rio-multiplexer}.
\l like for terminal emulator, virtual device files.

%dup: (but clearer) intro/other-systems
This multiplexer approach makes [[rio]] a 
{\em transparent}~\cite{window-system-should-be-transparent} windowing system.
%
Indeed, [[rio]] does not need to introduce a new API.
\n in fact it will a bit, for resize, and for /srv for creating windows
%for a graphical application running under [[rio]], 
%it is exactly as if [[rio]] was not there.
%
In fact, this transparence enables the same
graphical application to run with or without [[rio]], as shown
respectively in Figure~\ref{fig:clock-rio} and Figure~\ref{fig:clock-no-rio}
for the [[clock]] application.
%
Under \plan, there is almost no difference between a graphical application
and a window application.
\l almost cos few differences still, need to use view, resize, etc.
%dup: intro/rio %rio-reflection:
This transparence enables also [[rio]] to run recursively under itself
(see Section~\ref{sec:recursive-rio}).
%rio-reflection: so everything rio used from kernel must be emulated!
% can be confusing sometimes.

\begin{figure}\begin{center}
\includegraphics[width=8cm]{pics/clock-rio}
\end{center}
\caption{[[clock]] running inside [[rio]].}
\label{fig:clock-rio}
\end{figure}

\begin{figure}\begin{center}
\includegraphics[width=8cm]{pics/clock-no-rio}
\end{center}
\caption{[[clock]] running without [[rio]].}
\label{fig:clock-no-rio}
\end{figure}


%real-world:
X~Window, on the opposite, is not a transparent windowing system. It
introduces a special protocol and special APIs to access
the screen, the mouse, and the keyboard. You can not run a window
application without X~Window, and you can not run a graphical
application (e.g., Doom) inside a window in X~Window
(unless you rewrite Doom to use the X~Window API).
\n can in Windows though no? or can if Doom programmed in a special way?
\n  but then it can run only in X~Window.
\n or need an X~Window extension?
% 2 different worlds
\l cant run X inside X? apparently you can, but maybe need lots of code.
\l partly because run on OS without features necessary for virtual device files
\l  but also cos badly designed

\subsection{Window applications versus graphical applications}
\l very specific to plan9? maybe not.

Window applications and graphical applications have a lot in common:
they both draw on the screen, use the mouse, and possibly use the keyboard.
\l in raw mode.
%in-plan9:
As I said above,
in \plan, the difference between a graphical application and a window
application is fuzzy since you can also run graphical applications
inside a window.
%
However, this is possible only because
of some careful design decisions in [[rio]] and [[draw]].
\l and also few changes in the code
%explained in the following sections.
\l or additional code in application, or special library.
%real-world: X~Window?
%toc:
There are a few differences between running inside or outside a windowing
system, as explained in the following sections.

\subsubsection{A virtual screen}

One of the role of a windowing system is to 
offer {abstractions} hiding complexity, just like the kernel does.
%
Indeed, thanks to {\em virtual memory}, 
a process thinks it is alone and has access
to the whole memory, starting at address 0.
This simplifies greatly programming; the programmer does not have to care
about the physical memory layout and which memory is used by other processes.
%
In the same way, thanks to {preemptive scheduling},
a process thinks it is alone and has exclusive access to the CPU.
Again, the programmer does not have to care about the other processes
and how they use the processor (or processors). 
Each process uses a {\em virtual CPU}.


%in-plan9: but could be made more general
When running without [[rio]], a graphical application has access to the
whole screen. The origin point ([[Pt(0,0)]]) corresponds
to the top left corner of the screen (see the \book{Graphics}).
%
This should be similar when the graphical application is running under [[rio]].
This is why [[rio]] offers a {\em virtual screen} to each window, where
the origin point corresponds to the top left corner of the {window content}.
\t with originWindow. even if window in right corner. but bug right now

Thanks to the virtual screen, a graphical application running in a window 
%thinks it is alone; it 
does not even know it is running inside a windowing system.
%
Moreover, the programmer does not have to care about the other windows, or
where is located the window on the screen;
whatever the location, drawing a line from [[Pt(0,0)]] will always
start from the top left corner of the window, even though the window
itself is located at the very right of the screen.
\l just like virtual /dev/cons for emulator,
\n in the end natural to use virtual devices to represent virtual things
%
The programmer can use {\em virtual coordinates} 
(a.k.a. {\em logical coordinates}); those coordinates
are then translated in {\em physical coordinates} on the screen
by the windowing system.

%in-plan9: how implemented? actually complicated, see later

%real-world: same, logical coords in X~Window?
 
\subsubsection{A virtual mouse}

%trans:
What is true for the screen should also be true for the mouse.
%in-plan9:
This is why [[rio]] offers also a {\em virtual mouse} to each window; 
the location of the mouse read by the window application is relative to
the window, not the whole screen. The programmer can use
virtual coordinates again.
\l does not need to know run inside rio.
\t actually there is a bug right now

With [[rio]], the programmer does not have to check if the mouse
is on top of its window, or if the mouse is used concurrently
by another program; all of this is handled automatically by
the windowing system, which hides complexity by offering
a virtual mouse. When a window is at the top,
and the mouse cursor over this window,
\l focus defined later, grrr
[[rio]] then {\em dispatches} the mouse event to the corresponding process.
\l sure it is the actual mechanism in rio?
\l in X window can have different policy for that. follow-mouse vs focus

%in-plan9: virtual mouse concept implemented via virtual device /dev/mouse
%  natural. 
%real-world: same? X~Window?

\subsubsection{Overlapping windows}
\label{sec:layer-introduction}

%trans:
In addition to a reduced drawing surface, 
\l and different coordinate system
%
an important difference for a graphical application running inside a window
is that windows can overlap each other, and so hide each other.
%trans:
Where are stored the hidden pixels? How are those hidden
pixels restored when the window is exposed back?

%real-world:
In X~Window, because the early graphics machines did not have
much memory, the hidden pixels are not saved anywhere.
Instead, the display server {\em notifies} the client by
an {\em expose event} when a part of its window is exposed back.
It is the responsibility of the client, and so of the
programmer, to draw back what was hidden.
%real-world: from SunDew (ancestor of NeWS):
%"a window should be just that. it is a surface on which he
%can write, and that it persists. All overlap issues should be
%completely hidden from the client"
% => no refresh/repaint brain damage.

%in-plan9: 
With [[rio]], the programmer does not have to care about
overlapping windows. The windowing system hides complexity
by storing the hidden pixels in {\em off-screen images}.
When a window is exposed back, the windowing system then
copies the pixels from those off-screen images back to the screen.
\l well in fact it is done by draw
\l (like suspended process) (so need save window content somewhere)
This is consistent with the idea of the virtual screen:
the programmer does not have to care about the other windows.
\l the other windows, or the idea itself of being in a window. Abstraction!

%dup: (summarized) Graphics.nw
To manage overlapping windows, 
[[rio]] relies on a special data structure of [[draw]]:
the {image layer} (see the \book{Graphics} and \cite{pike-layers}).
\l [[Desktop]] [[Memdesktop]] and [[Image]] [[Memlayer]]
%
%A {\em BaseImage} is an image tagged in special
%way so that it can have layers upon it.
%[[rio]] uses the image corresponding to the screen as its desktop.
\n too complex for now
A {\em layer} is an image that overlaps
a rectangular sub-area of another image called the {\em base layer}.
With [[draw]], the programmer can use multiple layers
stacked on top of each other and on top of the base layer.
%
When a program draws in a layer,
\l draws on base for pixels not overlapped
the pixels overlapped by another layer are automatically saved
in an off-screen image.
\l alternative is big off-screen image for all, and window compositor
%
All the drawing functions of [[draw.h]] have special code to handle
the case where the image passed as a parameter is a layer.
\n in fact it is in libmemdraw, not libdraw
%The programmer does not have to know whether the image is a layer or not.
%
The programmer can also use
additional functions from [[window.h]] that are valid only
for layers, for instance, moving a layer at the top
with [[topwindow()]]. This function possibly copies the hidden
pixels saved in an off-screen image (if the layer was overlapped)
back to the base layer (e.g., the screen).

%in-plan9:
A layer is similar to a window, but the layer does not have any 
associated process; it is just a graphic construct.
It is one of the building block of [[rio]]. 
%rio-reflection:
Indeed, as you will see later in Section~\ref{sec:new-layer},
with [[rio]] {\em each window is associated to a layer}; 
each window will draw in its layer.
\l and base layer is the screen.
%
Moreover, when the user clicks on a window, [[rio]] internally calls
[[topwindow()]] with the appropriate layer as a parameter.
\l see Section X for the code.
%The public images created by [[rio]] and mentioned previously
%are actually layers of the screen. 

\subsubsection{Creating windows}

A windowing system should offer an API to create windows, not
just to draw things in a window.

%in-plan9:
In \plan, the toplevel windows, whose dimensions are specified by the user
(see Section~\ref{sec:rio-gui}),
are created by [[rio]], but each graphical application
can also create {\em sub-windows} inside its window.
%
Just like [[rio]] internally uses layers to represent toplevel windows, a
graphical application can also use layers to represent sub-windows.
%rio-reflection:
\l after all rio itself is a graphical application
Thanks again to [[window.h]], an application such as the editor [[acme]]
\l cite
can use multiple layers to represent different files in multiple columns.
%
In the same way, a dialog box, a menu, or any {\em widget} can be
represented internally as a layer. By using a layer, the programmer
of the widget does not have to care about the pixels overlapped
by the widget (or the pixels of the widget overlapped by another widget).

%in-plan9:
Note that layers do not have a border. To implement the window decorations,
[[rio]] draws a blue border rectangle inside the layer.
\l and then dimension of layer passed to process? originWindow? clipping?
Note also that sub-windows have to be inside the parent window.
It is not possible to create a layer that extends above the boundaries
of the window.
%
However, [[rio]] offers another API to create toplevel windows.
This API requires advanced features of [[rio]] and so is
explained later in Chapter~\ref{chap:advanced}.
\n /srv/, so there is some windowing system API a bit.

%real-world: X window complex, create window, passed 
% to window manager, rebind parent of window.


\subsubsection{Resizing windows}
\label{sec:principles-resize-window}

%trans:
The last difference between a window application and a graphical
application is that windows can be resized.
\l well can change resolution too for graphics applications, but rare
Unfortunately, as opposed to overlapping windows, this complexity 
can not be hidden to the programmer.

%real-world:
In most windowing systems, the window application is notified of a 
{\em resize event} when its window is resized. It is then the responsibility
of the programmer to provide a {\em callback} for such an event
that redraws everything.

%real-world:
In X~Window, this event is communicated to the client application
through the general {\em event mechanism} of X11. At startup time, 
the application communicates to the display server an
{\em event mask} specifying the set of events the application is interested
in. If the resize event {matches} the event mask, then X~Window
will notify the client of a resize event.
\l what if no event mask and resize? crash?
\l Cleaner? too specific to window context and so cant be transparent?

%in-plan9:
With [[rio]], the event is communicated to the application through the 
[[/dev/mouse]] virtual device file. 
\n [[/mnt/wsys/mouse]] too early to use /mnt/wsys
\l a bit ugly, should have instead a /dev/resize, but then can be transparent
\l in fact also through /dev/mouse for kernel
A graphical application usually reads this file to keep track
of the changes to the mouse location and the states of its buttons.
%
During a resize event, [[/dev/mouse]] contains 
the character [['r']] (for resize), instead of the character [['m']] 
(for mouse).
\l and size of new window? no, another mechanism for that.
%followed by integers encoding the location and the button states of the mouse.
\l see docs/man/3/mouse
\l and then getwindow() to grab new public layer and adjust global view (later)
%rio-reflection: rio does that itself since can be run inside a window




\section{[[rio]] interfaces}

%trans:
I just described the general principles of a windowing system,
and illustrated those principles with examples from X~Window and [[rio]].
%
I will now focus exclusively on [[rio]] and give more details
about its interfaces.

%toc:
[[rio]] is first a program you run through the command line, with 
optional command-line arguments. 
%
Then, it takes over the screen and becomes a graphical application.
%
Finally, it internally spawns a new process acting as a filesystem. 
%
Thus, [[rio]] has three different interfaces, which I will describe 
in the following sections.

\subsection{Command-line interface}

The command-line interface of [[rio]] is pretty simple:

<<function [[usage]]>>=
void
usage(void)
{
    fprint(STDERR, "usage: rio [-f font] [-i initcmd] [-k kbdcmd] [-s]\n");
    exits("usage");
}
@
\n no rio -help, call [[usage()]] only when give wrong argument to a -x above

Most of the time you will run [[rio]] without any argument,
as shown in Section~\ref{sec:getting-started}.
%
The arguments are all optionals and correspond to
advanced features of [[rio]] I will explain in Chapter~\ref{chap:advanced}.


\subsection{Graphical user interface}
\label{sec:rio-gui}

%trans:
The most important interface of [[rio]] is of course its
graphical user interface.
%
Once launched from the command-line, [[rio]] takes over the whole 
%rio-reflection:
screen\footnote{Unless it is run recursively inside one of its window,
as shown in Section~\ref{sec:recursive-rio}.
}
and displays a grey background image, as shown in
Figure~\ref{fig:rio-start}. % of Section~\ref{sec:getting-started}.
%
Then, using the mouse, you can create new windows.
%
Figure~\ref{fig:rio-gui} illustrates the main elements of [[rio]]'s GUI.


%dup: overview/principles/...
As mentioned in Section~\ref{sec:principles}, [[rio]] has a 
minimalist interface: no icon, no title bar, just a thin
blue border around windows.
%
You can left-click on a window to put it at the {top} if it
was overlapped. Moreover, by doing so, the window gets
the {\em focus}; this means every keyboard input will be sent
to this window.
\t window with focus is also called the {\em current window}.
\t also mouse! do cat /dev/mouse and you will see, dispatch only if focus
\l really? focus by click? or is it just if mouse is inside window?
When a window gets the focus, its border changes from a light
blue to a darker blue, as shown at the bottom of Figure~\ref{fig:rio-gui}.
Moreover, for window terminals, if the window loses the focus,
the text inside the window changes from black to a light grey,
as shown in the left of Figure~\ref{fig:rio-gui}.
\l nice visual feedback
\l get an event? or get that because terminal is builtin?


\begin{figure}\begin{center}
\includegraphics[width=8cm]{pics/rio-gui}
\end{center}
\caption{Graphical user interface of [[rio]] after a right-click.}
\label{fig:rio-gui}
\end{figure}
\t annotate subtle things, like blue frame, or light grey text when unfocused
\t menus, winborder, use bubbles and arrows a la powerpoint


By right-clicking outside any window, on the grey background image of [[rio]],
you trigger a {\em system menu} allowing you to 
create, 
resize, 
move, 
delete,
or hide 
a window, as shown in 
the right of Figure~\ref{fig:rio-gui}.
\n actually can also right click in textual window
\n button3menu()
\l also exit rio.
Note that [[rio]] requires a mouse with three buttons (left, middle, and right).
%
To create a new window, activate the system menu,
then hold the right-click, choose [[New]],
and finally release the right-click.
The cursor will then change from a big arrow to a plus sign,
to indicate a different {\em mode} of operation.
%
You must now specify a rectangle by right-clicking again and hold
while drawing a rectangle on the screen, as shown
in Figure~\ref{fig:new-step1-specify-new-window}.
%
Once you release the right-click, a new window terminal will appear,
as shown in Figure~\ref{fig:new-step2-basic-window-terminal}, with
a {shell prompt} at the top.


\begin{figure}\begin{center}
\includegraphics[width=8cm]{pics/new-step1-specify-new-window}
\end{center}
\caption{Creating a new window.}
\label{fig:new-step1-specify-new-window}
\end{figure}


\begin{figure}\begin{center}
\includegraphics[width=8cm]{pics/new-step2-basic-window-terminal}
\end{center}
\caption{Built-in terminal running under [[rio]].}
\label{fig:new-step2-basic-window-terminal}
\end{figure}
\l maybe start to type colors and screenshot of that


Because there is no icon in [[rio]], to launch a graphical
application you need first to create a window
terminal. Once created, you can type in the terminal window
the name of the graphical application you want to launch,
for instance, [[colors]].
%
This application should then take over the virtual screen of the
window terminal\footnote{Just like it takes over the whole screen when
launched outside [[rio]].},
as shown in Figure~\ref{fig:new-step3-color-app}.
%rio-reflection: 
\l same mechanism that rio uses also initially
\l same mechanism that makes possible recursive-rio
%
Once you quit this graphical application, the terminal will be back.
\l Graphical shell! Run commands. but no Dock. No Icon.
\l Also possible to create window programmatically, see Section X.
\t how does it work actually? save content?

\begin{figure}\begin{center}
\includegraphics[width=8cm]{pics/new-step3-color-app}
\end{center}
\caption{[[colors]] graphical application running under [[rio]].}
\label{fig:new-step3-color-app}
\end{figure}

You can also use the border of the window to resize or move the window.
When the mouse is over the border, the cursor changes again to
indicate a possible action. By left-clicking or middle-clicking
on the border, you can respectively resize or move the window.
\l also menu resize/move/delete/hide also cursor change and right-click
\l  to designate the window


For a full description of the GUI of [[rio]], I refer
you to its manual page in [[docs/man/1/rio]] in my \plan repository.
\l also a bit 8-1/2 ancestor of rio with same interface (actually since mpx)
%dup: (adapted) intro/rio
You can also watch the historical demo of the Blit
and [[mpx]] at \url{https://www.youtube.com/watch?v=emh22gT5e9k};
the user interface of [[mpx]] is almost identical to the one in [[rio]].
\l just black and white instead of color


\subsection{Filesystem interface}
\n also windowing system API

%trans:
As opposed to the two previous interfaces,
the last interface of [[rio]] is almost invisible to the user.
%
It is the set of files served by [[rio]] to all its window processes:
the filesystem interface.
%
It is mostly invisible because it is mainly an interface for programs, 
not users.
\l can explore in /mnt/wsys/ though for user
%dup: intro/rio intro/other-systems overview/principle/emulator  overview/principle/api
Moreover, as explained in Section~\ref{sec:windowing-system-api},
[[rio]] is a transparent windowing system;
the files served by [[rio]] mimic and replace {existing} device files managed
by the kernel (e.g., [[/dev/mouse]]), making the interface harder to notice.
\l but a few files more too

\l As I said in Section~\ref{sec:rio}, [[rio]] is also a filesystem in user space.
\l (more accurately a fileserver because in userspace).
\l to understand why, need expose internals of rio. will not do that here. 
\l See Section X for trace of creating new window and connect process to rio fs.

%toc:
In the following sections, I will describe the files served by [[rio]]. 
Those files act as interfaces to access
the screen, 
the mouse,
the keyboard,
but also the windowing system itself.
%dup: intro/rio 
I will prefix those files with [[/mnt/wsys/]] because that is
where the [[rio]] filesystem is originally {mounted} by the
window processes.
\t see Section X for full explanation of connection
However, as mentioned in Section~\ref{sec:rio},
those files are also available in [[/dev]], thanks to the union-mount
feature of the \plan kernel.
%dup: intro/rio overview/principles/api
It is by being accessible in [[/dev/]] that [[rio]] can become a multiplexer, 
as explained in Section~\ref{sec:windowing-system-api}. However, by using
the [[/mnt/wsys]] prefix, it is clearer that the file involved
is the file served by [[rio]] (e.g., [[/mnt/wsys/mouse]]) and not
the real device served by the kernel (e.g., [[/dev/mouse]]).
\n or a parent rio when in recursive rio

In the following sections, I will also repeat partly explanations 
found in the \book{Graphics} and \book{Kernel},  as [[rio]] emulates 
interfaces provided by the graphics system and the kernel. 
%\l morever rio relies a lot on services of draw, will remind those services.
However, the interfaces have a few differences because the context in
which the graphical application runs is different.

\subsubsection{The screen, [[/dev/draw]] and [[/mnt/wsys/winname]]}
\label{sec:winname}
\n was originally in overview/principles/api, but bad cos too rio-specific.
\n then I moved it here but bad cos was too big.
\n I then extracted the general stuff and put it in overview/principles/vs

%trans:
The first interface [[rio]] needs to mimic is the interface to the screen,
%
which under \plan involves the [[/dev/draw/]] directory and the
[[draw.h]] header file. 
%dup: (big summary) Graphics.nw
\l This file declares functions to draw lines, rectangles, text, etc.


Figure~\ref{fig:rio-multiplexer} % \pageref?
showed a windowing system multiplexing
[[/dev/draw]], [[/dev/mouse]], and [[/dev/cons]].
\l could have /dev/screen, instead of /dev/draw, but then harder remote apps
%alt: %dup: (but better explained than in footnote) intro/rio
This was how [[8-1/2]]~\cite{eight-and-a-half}, the ancestor of [[rio]],
was implemented. Under [[8-1/2]], each window was seeing
a [[/mnt/wsys/draw]] virtual device file in which the process
could write drawing commands. [[8-1/2]] would then convert
the logical coordinates in the drawing command to physical coordinates,
\l also clipping, save off-screen image if overlapped, more?
and send the resulting command to the real [[/dev/draw]] device file
managed by the kernel.
%
This was elegant. However, each drawing operation involved two 
\n interprocess communications (IPCs)? actually not really IPC with kernel
communications:
one between the application and the windowing system,
\l actually via kernel too
and the other between the windowing system and the kernel.
Those two round-trips were too inefficient for certain applications.
\l like video-games? other? still inefficient on modern machines?


%dup: (but better explained than in footnote) intro/rio  %dup? Graphics.nw
To remove one round-trip, [[rio]] does not multiplex [[/dev/draw]].
Instead, each window application connects directly to the [[draw]] device,
which is more efficient.
\l FIGURE? where see windows and rio are connected directly
%
However, this forced the [[draw]] device to 
serve multiple processes in addition to [[rio]]
(in [[/dev/draw/2/]], [[/dev/draw/3/]], etc),
and to become a display server.
%
Moreover, this required a new mechanism for [[rio]] to communicate
to [[draw]] which part of the screen is allocated to each
client of [[draw]].
%
This mechanism is complex and involves multiple features
of [[draw]] and [[rio]]:

\begin{enumerate}
\item Instead of [[/mnt/wsys/draw]], [[rio]] serves a file
named [[/mnt/wsys/winname]], which contains a different string
for each window (e.g., [["window.3"]]).
\l actually window.id.namecount
\l how can be different?

\item This string corresponds to the name
of a layer allocated by [[rio]] for the window
(see Section~\ref{sec:layer-introduction} for an introduction to layers).
\n see explanations of layer in principles
\l nameimage
\l just window content? or window decoration too?
This layer has the
dimension specified by the user during the creation of the window
(see Figure~\ref{fig:new-step1-specify-new-window}).
\l actually it is not an image but a window/layer of the screen, so can be
\l  a subimage, and for screen it is a subpart of the screen
\l also includes window decoration?

\item This layer, which is also an image, is made {\em public} by [[rio]]. 
Thanks to an inter-process communication (IPC)
feature of [[draw]], this public image can be accessed
by multiple processes
(see the \book{Graphics}).
\l nameimage()
\l but then security issue

\item On the client side, remember that each graphical
application must first call [[initdraw()]].
[[initdraw()]] calls itself [[gengetwindow()]], which
reads [[/dev/winname]] and grabs a reference to 
the corresponding public image.
\l namedimage(), but really it is just a reference to a Memimage in kernel space
This reference is then stored in the global [[view]].
%
By using [[view]] instead of [[display->image]] (see the \book{Graphics})
for the arguments of the drawing functions of [[draw.h]],
the graphical application can become also a window application, for free.
\l this layer becomes base image. so layer on top of this layer.
\n well still need to implement the resize callback
% FIGURE?

\end{enumerate}

Note that [[initdraw()]] calls [[gengetwindow()]] even when
the graphical application runs outside [[rio]]. To {\em bootstrap}, 
the [[draw]] device serves also a [[/dev/winname]] file, which contains
the string [[noborder.screen.1]]. This string corresponds also
to an image: the whole screen. In that case, the global [[view]]
and [[display->image]] references both the screen.
%rio-reflection: rio calls initdraw, and uses view!

For more information, Section~\ref{sec:trace-draw} explains
the full trace of a drawing operation through the 
windowing system, the graphics system, and the kernel.


\subsubsection{The mouse, [[/mnt/wsys/mouse]] and [[/mnt/wsys/cursor]]}
\label{sec:mnt-wsys-mouse}

%trans:
The second interface [[rio]] needs to mimic is 
%
the interface to the mouse, which under \plan involves the [[/dev/mouse]] 
and [[/dev/cursor]] files, as well as the [[mouse.h]] header file.


%dup:? Kernel.nw
The [[/dev/mouse]] interface defined by the mouse device driver
in the kernel is simple.
%dup: overview/principles/vs/resize
As mentioned in Section~\ref{sec:principles-resize-window}, 
a graphical application can keep track of changes to the mouse location or
the states of its buttons by reading (with [[read()]]) [[/dev/mouse]].
\l synchronously
%
When the user does an action with the mouse, the [[read()]] system call
returns, and the buffer parameter of [[read()]]
\l see \book{Libcore}
is modified to contain the character [['m']] (for mouse), followed by 
integers encoding the location and the button states of the mouse.
\l could have FIGURE with cat /dev/mouse
\l could even have FIGURE with 2 windows and cat /mnt/wsys/1/mouse
%
The graphical application can then inspect those integers and modify 
the GUI, or do nothing.
\l can also write in /dev/mouse


%trans:
As opposed to [[/dev/draw]], [[rio]] does multiplex [[/dev/mouse]]\footnote{Why
the difference? Why is there not a mouse server, 
just like there is a display server? 
%
Because there is no need to optimise the access to [[/dev/mouse]].
%
Indeed, the two round trips underlying the access to
[[/mnt/wsys/mouse]] are not as critical as the access
to an hypothetical [[/mnt/wsys/draw]]. In the context of a video game,
a game application may have to generate 30 to 60 images per
second; this may require hundreds or more calls to drawing
functions of [[draw.h]], and many accesses to [[/dev/draw]].
%
However, user actions are slower and the application does not
need to react to a mouse event so frequently. Moreover, the size of
the data involved with [[/dev/mouse]] is small: just a few bytes
to represent a mouse location and button states.
\l no need to be handle at the frame rate. sure?
} as shown in Figure~\ref{fig:rio-multiplexer}.
%
The main job of [[rio]] regarding the mouse interface
is to relay a [[read()]] by the window application on 
[[/mnt/wsys/mouse]] to a [[read()]] on the real [[/dev/mouse]],
\l actually otherway around, rio reads /dev/mouse and dispatch
and to convert the physical coordinates of the mouse to logical coordinates.
\t does it do it now?
%dup: (but changed a bit) overview/principles/vs/resize
Moreover, as mentioned in Section~\ref{sec:principles-resize-window},
[[rio]] abuses [[/mnt/wsys/mouse]] to also transmit
the resize events to the graphical application. The buffer contains
then the character [['r']] (for resize).
\l followed by stuff?

After a window application reads the [['r']] character 
in [[/mnt/wsys/mouse]],
it is the responsibility of the programmer to call [[getwindow()]],
%
which  is a function similar to the [[gengetwindow()]] function I mentioned
before. % Section X
[[getwindow()]] also reads [[/dev/winname]].
This file should contain a new string
corresponding to a new public image with the new dimension of the window.
%
Then, [[getwindow()]] grabs the reference to this new public image in which
the graphical application should now draw in.
[[getwindow()]] also updates the global [[view]].
\l it does?


Another job of [[rio]] is to multiplex [[/dev/cursor]]
and to offer a {\em virtual cursor} to each application.
%
Thanks to [[/mnt/wsys/cursor]], each application can use
a different cursor and can change the cursor.
%
When the user hovers a window, the cursor changes
according to what the window application wrote in his
[[/mnt/wsys/cursor]] file; if nothing was written, a default
cursor is used.

\bigskip
The fact that a program running in a window opened or not 
its [[/mnt/wsys/mouse]]
\l or cursor?
file is an important information for [[rio]]. Depending on this opened status,
[[rio]] will behave differently. For instance, 
if an application opens [[/mnt/wsys/mouse]], many features of the terminal
emulator are automatically disabled.
\l see rio(4).
Indeed, using the mouse is a strong hint for [[rio]] that the application
is a graphical application, not a command-line application.
%
Another hint is the opening of [[/dev/draw/new]] by the application, 
but this file is not managed by [[rio]], and so out of reach of [[rio]].
%
In the rest of the book, I will use the term {\em graphical window}
for a window in which the underlying program opened [[/mnt/wsys/mouse]],
and {\em textual window} otherwise.

\t mv somewhere else?
%trans:
The last important information regarding the mouse interface concerns
the [[mouse.h]] header file.
%
\t mv with virtual mouse? quite rio specific, but contain principles
A programming alternative
to using directly [[/dev/mouse]] is to use the functions
from [[mouse.h]] such as [[initmouse()]] (see the \book{Graphics}).
\n why discuss now? cos I mention mouse.h above.
%
[[initmouse()]] internally uses [[/dev/mouse]], but wraps 
the device file in a data structure ([[Mousectl]]) allowing
the use of {\em threads} and {\em channels} (see the \book{Libcore}).
%
Using channels gives more flexibility to the programmer. For instance,
the program can {\em react} simultaneously to changes in [[/dev/mouse]] 
and [[/dev/cons]], and so can handle mouse events as well as keyboard
events. Without [[mouse.h]], the programmer can either read
synchronously [[/dev/mouse]], or read synchronously [[/dev/cons]], 
but not both at the same time\footnote{
There is no [[select()]] system call in \plan. Threads,
channels, and the \plan{} function [[alt()]]
are the \plan{}'s way to do things done usually with [[select()]]
under \unix.
}.
%rio-reflection:
Note that
%, as you will see in Chapter~\ref{chap:main},
[[rio]] itself calls [[initmouse()]] at startup time,
and uses heavily channels and threads, as you will see
in the rest of the book.



\subsubsection{The keyboard, [[/mnt/wsys/cons]] and [[/mnt/wsys/consctl]]}

%trans:
The last interface [[rio]] needs to mimic is the interface to the keyboard,
%
which under \plan involves the [[/dev/cons]] and [[/dev/consctl]] files,
as well as the [[keyboard.h]] header file.


%dup? Kernel.nw
[[/dev/cons]] stands for {\em console device}; 
it is the device representing the {terminal}.
%
The [[/dev/cons]] interface defined by the kernel is simple:
a program reading from [[/dev/cons]] will read characters from the keyboard;
\n actually unicode, 
\t actually utf8 encoding of runes!
a program writing to [[/dev/cons]] will output text on the screen.
\n classic text-based user interface
%
At boot time, the first \plan process opens [[/dev/cons]] two times:
\l init?
one in {read}-mode, and the other in {write}-mode.
%dup: overview/principle/terminal-emulator
Those two first file descriptors correspond
to the {\em standard input} and {\em standard output} of the program 
(see the \book{Kernel}).
\n also standard error
\l \ref{sec:terminal-emulator}
%
Those file descriptors and then {inherited} through [[fork()]]
and [[exec()]] by the shell, as well as by the command-line
applications launched from the shell, unless the user used redirections
(see the \book{Shell}).
%
Remember that
the [[printf()]] function from the C library internally does some 
[[write(1, ...)]]m
\l see \book{Libcore}
and the [[scanf()]] function internally does some 
[[read(0, ...)]].
% those conventions are great. can have generic tools.


%dup? Kernel.nw
The kernel offers also a few convenient features by default
regarding the input of characters.
%
For instance, when a program reads [[/dev/cons]],
the user can interactively edit the characters to sent to the program
by using the {\em backspace} or {\em delete} keys to correct typing mistakes.
He can also use the {\em cursor} keys to move in the line.
Moreover, the characters typed are automatically {\em echoed} on the screen,
making it easy to see the typing mistakes.
Finally, the characters are sent only when the user types the 
{\em newline} character.
\l of if too many characters buffered already?
\n mini editor! bootstrapping editor (see Principia.nw)
%
By putting those features in the kernel, all command-line applications
do not have to care about typing mistakes.
\l also buffered input and output? output only when \n? also faster originally?
%alt: how kernel multiplex keyboard? it does not really, only one process
% read the key at the same time
%alt: evdev in linux? yet another mechanism


%dup? Kernel.nw
Note that those line-editing features can also be disabled by the application.
%
Indeed, in certain contexts, the application may not want the
input to be buffered. For instance, a video game wants
to respond as soon as possible to the key typed by the user; it does not
make sense to force each time the user to also type the newline character.
%
This is why the kernel provides also the [[/dev/consctl]] (for console
control) device file. By writing [[rawon]] (for {\em raw access} on)
in [[/dev/consctl]],
\l raw mode vs cooked mode apparently, funny
the application indicates to the kernel that the default line-editing 
features of the kernel should be disabled; the application
wants {raw access} to the keyboard
\l some command line app also use the raw mode? libreadline?
%rio-reflection:
(note that [[rio]] itself writes [[rawon]] in [[/dev/consctl]]
at startup time, so it can handle the keyboard itself).
%
A call to [[read()]] on [[/dev/cons]] will then return after each key
is typed. Moreover, no character will be echoed by default on the screen.



The job of [[rio]] regarding the keyboard interface depends also
on whether the application in the window wants or not raw access 
to the keyboard.
%
This is why [[rio]] multiplex not only [[/dev/cons]], but also [[/dev/consctl]].
\l not shown in Figure~\ref{fig:rio-multiplexer}
The behavior of [[/mnt/wsys/cons]] depends on the opening and content
of [[/mnt/wsys/consctl]].
%The behavior of [[/mnt/wsys/cons]] depends on the opening 
%status of [[/mnt/wsys/mouse]].
\l sure? can have graphical app without rawon?
This is usually correlated with whether or not the window is a
graphical window (raw access on), or textual window (line-editing on).


For graphical windows, writing on [[/mnt/wsys/cons]] should be 
considered an error.
\t Is it?
Indeed, the graphical application should instead use the [[string()]] 
\l or runestring
function from [[draw.h]] to output text on the screen at a specific
location via [[/dev/draw]]
(see the \book{Graphics}).
%
Only reads on [[/mnt/wsys/cons]] should be supported by [[rio]].
Moreover, each key typed should be sent directly to the
graphical application if its window has currently the focus.


For textual windows, the job of [[rio]] and its terminal emulator
is to imitate what the kernel does by default, including the line-editing
features.
%
In fact, under [[rio]], the user can also use {\em copy-pasting} with
the mouse to edit a line before it is sent to the program.
%
Both reads and writes on [[/mnt/wsys/cons]] should be supported by [[rio]]
for textual windows.
%
Reads to [[/mnt/wsys/cons]] by a command-line application
should return only when the user typed the newline character in the 
terminal emulator.
%
Writes to [[/mnt/wsys/cons]] should be converted to calls to
[[string()]] by the terminal emulator, in order to output text at 
\l or runestring
the right place in the window (possibly applying line wrapping).

\n kbdin explained later

%trans:
Similar to the mouse,
%
a programming alternative to using directly [[/dev/cons]] is to use 
the functions from [[keyboard.h]] such as [[initkeyboard()]] 
(see the \book{Graphics}).
%
[[initkeyboard()]] internally enables raw access to the keyboard
by writing [[rawon]] in [[/dev/consctl]].
%
[[initkeyboard()]] internally uses [[/dev/cons]], but wraps 
the device file in a data structure ([[Keyboardctl]]) allowing also
the use of {threads} and {channels}.
%rio-reflection:
Again, as you will see in Chapter~\ref{chap:main},
[[rio]] itself calls [[initkeyboard()]] at startup time.
\l and use Keyboardctl
  
\subsubsection{Other [[/mnt/wsys/]] files}

%trans:
I just presented the main files served by [[rio]] to its window processes. 
Those files are virtual versions of device files managed by the kernel.
%dup: intro/other-system ...
Thanks to those virtual devices, [[rio]] is a transparent
windowing system enabling graphical applications to run inside windows.
\l why also can even run rio inside rio!

[[rio]] serves also files that are interfaces to
advanced features of the windowing system itself.
%
Here is the list of those files and a short description
of their content (Chapter~\ref{chap:window-files}
and Chapter~\ref{chap:advanced} will give more details about those files):

\begin{itemize}

\item [[/mnt/wsys/winid]]: This read-only file contains a 
number unique to each window, the {\em window identifier}.
This identifier is useful in conjunction with [[/mnt/wsys/wsys/]] 
presented below.

\item [[/mnt/wsys/label]]:
[[rio]] does not use title bars, but each window can write a string
called a {\em window label} in its [[/mnt/wsys/label]] file,
to describe the window. 
This label is then used by the system menu; 
the menu lists all the hidden windows by their labels
(see Section~\ref{sec:window-hide})
\l other uses of labels?

\item [[/mnt/wsys/screen]]: This read-only file contains an image
\l dynamic image
(in the \plan image format) representing the content of the screen
at the moment [[/mnt/wsys/screen]] was read.
Thanks to this file, it is very easy to take screenshots in \plan.
\l no need fancy app! lens.c uses it too.
\l can use that for accessibilty?


\item [[/mnt/wsys/window]]: This read-only file contains
also an image, but representing only the content of the window.

\item [[/mnt/wsys/text]]: This read-only file is useful
only for textual windows. It contains a full dump of the text
displayed in the terminal.
\l useful for?

\item [[/mnt/wsys/snarf]]: This file is used for copy-pasting
(see Section~\ref{sec:snarf}).

\item [[/mnt/wsys/wdir]]: This file is used for filename completion 
(see Section~\ref{sec:wdir}).

\item [[/mnt/wsys/wsys/]]: This directory allows to explore
the set of windows. [[/mnt/wsys/wsys/]] is to windows
what [[/proc/]] is to processes (see the \book{Kernel}).
The {\em key} used for [[/mnt/wsys/wsys/]] is not the
process identifier, as in [[/proc]], but the window identifier
presented above.
%
Just like [[/mnt/wsys/]] contains
files representing information about the window of the program,
[[/mnt/wsys/2/]] contains the same files but representing
the information about the window with the window identifier [[2]].



\item [[/mnt/wsys/wctl]]: This file is used to control programmatically 
a window.
%
Just like a user can use the mouse to act on a window, for instance,
by clicking on the border of a window to resize it,
a program can use [[/mnt/wsys/wctl]] to do similar things.
By writing {\em control commands} in [[/mnt/wsys/wctl]], a program
can control its own window.
\l so resize API?
In fact, a program can control also
another window, for instance, by writing in [[/mnt/wsys/wsys/2/wctl]]
(see Section~\ref{sec:mnt-wsys-wctl} for more information).
\l very powerful, lots of uses. Selenium style?


\end{itemize}

%dup: (adapted) Graphics.nw
For more information on the files served by [[rio]]
and their format, I refer you to the documentation of
[[rio]] in [[docs/man/4/rio]] in my \plan repository.
\t also files in /srv/, see Section X.

%% also has special files in /srv/
%% for external process to create new window and still have the mount.
%% for processes outside rio namespace.
%% wsys and wctl are advanced stuff we can delay
%% wctl for sure, allow to control rio from command line but less important
%%/srv
%% rio.user.pid
%% riowctl.user.pid
%%env var:
%% $wsys (e.g., /srv/rio.pad.21)
%% $wctl (e.g., /srv/riowctl.pad.21)
%%
%%can also ctl rio by writing in $wctl
%% also have fileserver that can take command (e.g., wctlnew())
%% the fileserver offer also virtual views for the apps running
%% inside the windows
%% mount #s/rio.user.pid /mnt/wsys 1
%% mount -b #s/rio.user.pid /dev
%
%% manual creation of window (not via menu) see rio(5)
%% mount $wsys /tmp 'new -r 0 0 128 64 -pid' $pid
%% echo hi > /tmp/cons
%% :)







\section{[[hellorio.c]]}
\label{sec:hellorio}

%GUI architectures:
%https://martinfowler.com/eaaDev/uiArchs.html

%trans:
Now that you know the principles and the interfaces of [[rio]],
%
I can present the code of a toy {window application}: [[hellorio]].


[[hellorio]] is a simple application written in C displaying initially
[[Hello Rio]] at the location of the mouse. Then, when the user types
a key, the [[Hello Rio]] message is replaced by the typed character,
as illustrated in Figure~\ref{fig:hellorio}.
Finally, you can quit the application by typing the letter [['q']] (for quit).
\l cleaner than hello world for X11. No need expose ugly stuff! (but resize)
\n and actually hello-also-non-english-world!

\begin{figure}\begin{center}
\includegraphics[width=8cm]{pics/hellorio}
\end{center}
\caption{[[hellorio]] running in a window, after the user typed [['m']].}
\label{fig:hellorio}
\end{figure}


The goal of this section is to illustate some of the concepts I
introduced before with concrete code.
\l which concepts? windowing system API? like use of view? initmouse? initdraw?
\l  but can not see use of virtual files directly, sad
%rio-reflection:
Moreover, the code of [[hellorio]] in [[hellorio.c]],
although simplistic, is a good introduction to the code of [[rio]] itself. 
Indeed, [[rio]] also needs to use the mouse, the keyboard, or 
draw things on the screen. 
[[hellorio.c]] will introduce also the use of channels and threads, which are 
heavily used by [[rio]].
\n threads and procs implicitely, but still introduces defs of channel/threads
\n also define Rune


I already presented in the \book{Graphics} the code of a toy
{graphical application}: [[hellodraw]]. 
%dup: overview/principles/api
As I said in Section~\ref{sec:windowing-system-api}, a graphical application
can also be a window application under \plan.
%
However, this requires a few changes in the code of the graphical application,
for instance, the use of the global [[view]] as mentioned
in Section~\ref{sec:winname}. 
[[hellodraw]] was not using this global, and so could not run inside a window.
\n well it can but then it's ugly
%
Moreover, [[hellodraw]] was just using the graphics facilities of [[draw]],
with functions from [[draw.h]]. 
[[hellorio]] is an interactive graphical application that also uses 
the mouse and the keyboard, with functions from [[mouse.h]] and [[keyboard.h]].
%
Finally, by handling the resize event, [[hellorio]]
can also become a window application.
\l correct window application, nice citizen
\l this is why I do not use hellodraw.c as an example

%react sucks, event model is far better:
% https://tech.polyconseil.fr/code-your-js-app-like-its-86.html

\subsection{Skeleton and output code}
\label{sec:hellorio-skeleton}

Here is the skeleton of [[hellorio.c]]:

<<windows/rio/tests/hellorio.c>>=
#include <u.h>
#include <libc.h>

#include <draw.h>
#include <mouse.h>
#include <keyboard.h>

#include <thread.h>

Image *bgcolor;
Point mouseloc;
Rune str[20];

<<type EventType (hellorio.c)>>

void redraw(void);

void threadmain(int argc, char* argv[]) {
  int result;
  Keyboardctl* keyboardctl;
  Mousectl*    mousectl;
  <<[[threadmain()]] other locals (hellorio.c)>>

  result = initdraw(nil, nil, "Hello Rio");
  <<[[threadmain()]] sanity check result (hellorio.c)>>
  mousectl = initmouse(nil, view);
  <<[[threadmain()]] sanity check mousectl (hellorio.c)>>
  keyboardctl = initkeyboard(nil);
  <<[[threadmain()]] sanity check keyboardctl (hellorio.c)>>

  bgcolor = allocimage(display, Rect(0,0,1,1), RGBA32, true, DMagenta);
  runestrcpy(str, L"Hello Rio");
  mouseloc = Pt(200, 200);

  <<[[threadmain()]] alts setup (hellorio.c)>>
  redraw();
  <<[[threadmain()]] event loop (hellorio.c)>>
}

void redraw(void) 
{
  draw(view, view->r, bgcolor, nil, ZP);
  runestring(view, mouseloc, display->black, ZP, font, str);
  flushimage(display, true);
}
@
\l str[20] for size of rune buffer in Keyboardctl.c 
\l  USED(argc); USED(argv);
%ocaml: dont have to use global, can pass them to redraw
% and can have initdraw return a display
%ocaml: less nil, better interface with default values (or remove
% useless genericity of the interface)

Here are a few important things to note about 
the skeleton of [[hellorio.c]], from top to bottom,
as well as how the code compares to the code of [[hellodraw.c]] 
in the \book{Graphics}:
\l put some Line X. would be clearer.

\begin{itemize}

\item In addition to [[draw.h]], [[hellorio.c]] also includes
[[mouse.h]] and [[keyboard.h]], as it uses the mouse and
the keyboard.


\item [[hellorio.c]] also includes [[thread.h]], a header file
containing functions related to threads,
the [[Channel]] structure, and the declarations of
primitives operating on channels (e.g., [[send()]], [[recv()]]).
\l also Alt
%dup? Libcore 
A {\em channel} is essentially a {queue} of {\em messages}.
\l buffered or unbuffered queue
%
Threads communicate and {synchronize} with each
other by exchanging messages through channels
(see the \book{Libcore}).
\l based on Alef, Newsqueak, and more generally CSP
%
Even though the code in [[hellorio.c]] does not create
threads explicitely, some of the functions called from
[[hellorio.c]] (e.g., [[initmouse()]], [[initkeyboard()]])
do create threads internally
(see the \book{Graphics}).
\n actually procs, not threads, but procs also create (single) threads

%dup? Libcore
The \plan thread library defines two separate constructs
to carry computations: {threads} and {procs}.
%dup: (shorten) 2/thread
A {\em proc} is a \plan process containing 
{cooperatively-scheduled} {\em threads}.
%
Remember that in \plan, processes can share memory with each other
(via the [[RFMEM]] flag to [[rfork()]], see the \book{Kernel}).
%
Thus, just like multiple threads in the same proc share memory,
multiple procs can also share memory,
and can communicate with each other through channels declared 
in this shared address space.
\t then what is the difference? why need 2 constructs?
%
In other operating systems, a \plan proc is similar to a {\em system thread},
and a \plan thread is similar to a {\em light-weight thread} 
(or a {\em coroutine}).
\l and channel is?
\t both are useful, both have pro and cons, depending on task. explained later.
\l  pro of light-weight is cheap and no need lock inside same proc cos
\l  never run in parallel

%dup: Graphics.nw
\item As I said in the \book{Graphics}, with [[draw]]
{\em everything is an image}, including colors, as shown 
by the type of the global [[bgcolor]].


\item The key typed by the user is stored in an array of [[Rune]]s.
%dup? Libcore
A {\em rune} is the name given to
a {\em unicode character} in \plan (see the \book{Libcore}).
%
The type of a key entered in the keyboard is not a [[char]]
but a [[Rune]] in \plan, which is convenient.
%
Indeed, the code of [[hellorio.c]] will work also if the user
enters {chinese characters}, or letters with european accents.
%
Even special combinations such as the [[Control]] key and the [[d]] key
will return a single rune, whose representation [[^d]] will
be correctly displayed on the screen (thanks to [[runestring()]] called
in [[redraw()]]).
\l this simplifies programming, e.g. efuns?
\l but then can catch just hitting Control?


\item Most of the graphics-related code is not
in [[main()]], as in [[hellodraw.c]], but in a separate
function: [[redraw()]]. This is because this code will be
called multiple times, after each input event, as you will see soon.


\item The entry point of [[hellorio.c]] is not 
[[main()]] but [[threadmain()]]. 
%dup: 2/thread
Indeed, the thread library provides already a [[main()]]
that sets up a proc with a single thread executing [[threadmain()]].
\l done because automagically link when include thread.h (see \book{Linker})
\l bootstrap, setup scheduler


\item Similar to [[hellodraw.c]], the first call of [[hellorio.c]]
is to [[initdraw()]], to connect to the display server.
%
[[hellorio.c]] also calls [[initmouse()]] and [[initkeyboard()]]
to connect respectively to the mouse and the keyboard device.
%dup? Graphics.nw
Those two functions internally create a proc 
\t containing a single thread, but then confusing?
reading synchronously on respectively [[/dev/mouse]] and [[/dev/cons]]
(see the \book{Graphics}).
%
Those two functions uses a proc,
\t creates a new proc, and not just simply a thread, because if
\t thread then would block.
and not a thread, because
a thread should not block. Indeed, if for instance a thread is blocked
on a read on [[/dev/mouse]], the other threads in the same proc
\t including threadmain
would also be blocked. Threads are cooperatively-scheduled;
they need to cooperate with each other.
\t by using a proc for code doing IO, safe. Proc with single thread, so block only himself
\l was similar in ocaml before? also issue in lwt no?



\item Regarding the graphics-related code, [[hellorio.c]] is very
similar to [[hellodraw.c]], with the use of functions
of [[draw.h]] such as [[allocimage()]], [[draw()]], [[runestring()]], 
or [[flushimage()]].
%
The main difference is the use of the global [[view]], set by
[[initdraw()]] (see Section~\ref{sec:winname}), instead of [[display->image]],
for the arguments of the drawing functions.
\l security issue, can still draw on the whole screen, hmm
\t use originWindow! by default! so even less change compared to hellodraw.c
%old:
% a bit annoying that have to transform your xy into the final
% xy ourself by adding view->r.min. Not really "abstraction"
% power. I'd rather have my 0x0 to be the top left on _my_ window.
%update: actually you can, but you have to make your image a window
% which means you also have to create a Screen first.

\end{itemize}

The skeleton of [[hellorio.c]], above, omits the error management
code shown below:

<<[[threadmain()]] sanity check result (hellorio.c)>>=
if (result < 0)
  exits("Error in initdraw");
@
<<[[threadmain()]] sanity check mousectl (hellorio.c)>>=
if(mousectl == nil)
  exits("can't find mouse");
@
<<[[threadmain()]] sanity check keyboardctl (hellorio.c)>>=
if(keyboardctl == nil)
  exits("can't find keyboard");
@
%ocaml: use exn

In the rest of this book, I will usually not comment the 
error-management code. Such code is often trivial (but necessary).

\subsection{Input code}
\label{sec:hellorio-input-code}

%trans:
I have shown the code responsible for the visual {output} of [[hellorio]].
%
I can now present the code dealing with the {inputs} to [[hellorio]],
making [[hellorio]] an {interactive} program.


[[hellorio]] must handle three different kinds of inputs: inputs 
from the mouse,
from the keyboard, and 
from the windowing system itself with its resize event.
%
The type below defines those different {\em event types} for [[hellorio]]:

<<type EventType (hellorio.c)>>=
enum EventType {
  EMouse,
  EKey,
  EResize,

  NALT
};
@
\l explain NALT? classic, like in Assembler.nw
%ocaml: use ADT and typed channels instead of flat generic enum
% so less need those .v, .c fields. and intermediate Alt type
% (but still need an intermediate event type that does the union of
% the events for a particular thread)

[[hellorio]] needs to deal {\em simultaneously} with the mouse,
keyboard, and windowing system. Indeed, the program can not just
synchronously read [[/dev/mouse]]; maybe the next event will be
a keyboard event, not a mouse event.
%
To do so, the [[thread.h]] header file defines the 
[[Alt]] (for alternative) structure.
%dup: overview/interface/fs/mouse
As mentioned in Section~\ref{sec:mnt-wsys-mouse},
there is no [[select()]] system call in \plan.
%
Instead, \plan provides the [[alt()]] function
(see the \book{Libcore})
that takes as an argument a {map} of event types to [[Alt]].
\l signature of alt()?
This map is stored first in a local variable:

<<[[threadmain()]] other locals (hellorio.c)>>=
// map<EventType, Alt>
Alt alts[NALT+1];
@
%ocaml: specialized ADT directly

%dup? 2/thread?
Each value of this map (each ``alternative'') contains essentially a channel. 
A call to [[alt()]] will then return if anything is exchanged 
(received or sent) on {\em one of the channels} of the map.
%
In fact, [[alt()]] will also return the event type associated with
the channel in which a message was exchanged.
\l if multiple messages exchanged? first? both?
%
With [[alt()]], it is possible to {listen} to multiple channels
at the same time (or to {emit} to multiple channels at the same time).
\l for emit too, cos can emit only if ready

For each event type, the local variable [[alts]] is initialized
with the channel to receive from (or send to) in the [[Alt.c]] field:


<<[[threadmain()]] alts setup (hellorio.c)>>=
alts[EMouse].c = mousectl->c;
alts[EMouse].v = &mouse;
alts[EMouse].op = CHANRCV;

alts[EKey].c = keyboardctl->c;
alts[EKey].v = keys;
alts[EKey].op = CHANRCV;

alts[EResize].c = mousectl->resizec;
alts[EResize].v = nil;
alts[EResize].op = CHANRCV;
@
%ocaml: similar; use Event.wrap and Event.select and no need
% intermediate Alt .c .v .op untyped, just use ADT

The [[Alt.op]] field contains the type of {\em channel operation},
Here, [[CHANRCV]] because the program is listening (receiving)
on all channels. It is also possible to emit simultaneously
on multiple channels by using instead [[CHANSND]].
\l can send only if other party is ready to receive.

[[mousectl]] and 
[[keyboardctl]], above, are 
two local variables containing the return value of respectively
[[initmouse()]] and 
[[initkeyboard()]]
(see the skeleton of [[hellorio.c]]).
%
The types of those variables are respectively
the structure [[Mousectl]] and
the structure [[Keyboardctl]], 
defined respectively in
[[mouse.h]] and
[[keyboard.h]].
Both structures are explained in the \book{Graphics}.
%
The most important fields in those structures are [[Mousectl.c]]
and [[Keyboardctl.c]] which are the channels used to communicate
with the procs created by [[initmouse()]] and [[initkeyboard()]].
\l actually the single thead in proc. see explanation of skeleton earlier
%
For instance, the proc created by [[initmouse()]] reads synchronously
on [[/dev/mouse]], and when [[read()]] returns data, this data
is sent on [[Mousectl.c]]. This data can then be read by any thread
receiving on [[Mousectl.c]].
%
Thanks to [[alts]], [[hellorio]] can listen simultaneously on changes
in [[/dev/mouse]] or [[/dev/cons]].


The field [[Alt.v]] must contain a pointer to an area where 
to store the data received on a channel (or the data to send,
if the channel operation was [[CHANSND]]).
The size of this area depends on the {\em channel type} 
(see the \book{Libcore}).
%
For the keyboard, [[Keyboardctl.c]] is a channel containing up to
20 buffered keys (so even if the user types really fast, no data is lost).

<<[[threadmain()]] other locals (hellorio.c)>>=
Rune keys[20];
@

For the mouse, [[Mousectl.c]] is a channel containing just one [[Mouse]]:

<<[[threadmain()]] other locals (hellorio.c)>>=
Mouse mouse;
@
\l both this local are taken address of by code above


Each array of [[Alt]]s must finish with a special {\em end marker}: 
[[CHANEND]].

<<[[threadmain()]] alts setup (hellorio.c)>>=
alts[NALT].op = CHANEND;
@

% \subsection{The event loop}

I can finally show the last piece of code of [[hellorio.c]]:
the {\em event loop} and the call to [[alt()]]:
\n I call it event loop even if it's not from event.h, because similar spirit

<<[[threadmain()]] event loop (hellorio.c)>>=
for(;;) {
  switch(alt(alts)){
  <<[[threadmain()]] event loop cases (hellorio.c)>>
  }
  redraw();
}
@
\l you will see many times this kind of loop and switch

When one of the channel in [[alts]] receives a message,
[[alt()]] returns the corresponding event type.
%
The program can then switch on the event type,
inspect the {message} referenced from [[Alt.v]],
and modify globals.


For the mouse, the program modifies the global [[mouseloc]] with
the last coordinate of the mouse:

<<[[threadmain()]] event loop cases (hellorio.c)>>=
case EMouse:
  mouseloc = mouse.xy;
  break;
@

This global is then used in [[redraw()]] as a parameter to [[draw()]]
to display some text at the right location.


For the keyboard, the program modifies the global [[keys]].
%
As mentioned above, the channel type of [[keyboardctl->c]] is an array 
of 20 runes.
%
A channel is a bufferred or unbuffered queue of messages.
%
The call to [[alt()]] stores only one message in the area pointed by [[Alt.v]].
%
It is the responsibility of the programmer to call [[nbrecv()]] to transfer 
the remaining messages in the queue.
\t not super clear

\ifallcode
<<[[threadmain()]] other locals (hellorio.c)>>=
int i;
@
\fi
<<[[threadmain()]] event loop cases (hellorio.c)>>=
case EKey:
    for(i=1; i<nelem(keys)-1; i++)
        if(nbrecv(keyboardctl->c, keys+i) <= 0)
            break;
    keys[i] = L'\0';
    runestrcpy(str, keys);
    if(keys[0] == L'q')
      exits("done");
    break;
@
%ocaml: how to use buffered channels with size in OCaml?

For the resize event, the program just needs
to call [[getwindow()]], which will update the global [[view]],
as explained in Section~\ref{sec:mnt-wsys-mouse}:

<<[[threadmain()]] event loop cases (hellorio.c)>>=
case EResize:
  if(getwindow(display, Refnone) < 0)
    exits("failed to re-attach window");
  break;
@

%trans:
This concludes the code of [[hellorio.c]].

With command-line programs, the program is in control;
the program ask questions to the user. 
With graphical applications (and window applications), the
user is in control; the application {\em reacts} to external events. 
%
This is a new programming model. The application is more than
an interactive program, it is a reactive program.
\l reactive not proactive. callback.
\l inside-out style (see Mini-X tutorial; I saw that sentence other times)


%\subsection{Events versus threads}
% instead of channels (and threads) and alt(), alternative is to use events

% Seen multiple input devices: mouse, keyboard 
% (and potentially also input from rio itself when resize event or move)
% But issue of synchrony.
%dup? Graphics.nw
% In fact already had issue in Graphics.nw.
% 2 models:
% events: one activity, multiple source of events (and asynchronous)
% threads: multiple activities, multiple source of events (and asynchronous)

% for threads, under the hood, it's alts() and channels, shared memory
%  and atomic increment (=~ futex?)
% for events, it's a pipe from one master to multiple slaves and read().

% input events
% user-generated events (action with window manager)
%  expose event! resize event!

%alt: threads and channels! keyboard thread, mouse thread! display thread
% (but rely on event loop under the hood for thread scheduler?)

